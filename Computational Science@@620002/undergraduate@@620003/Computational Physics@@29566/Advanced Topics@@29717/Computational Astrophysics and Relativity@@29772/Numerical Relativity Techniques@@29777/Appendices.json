{"hands_on_practices": [{"introduction": "Before tackling the full complexity of Einstein's equations, it is invaluable to build a working simulation in a simplified setting. This exercise guides you through developing a \"Flatland\" numerical relativity code, simulating the gravitational interaction of two masses in a $2+1$ dimensional periodic universe [@problem_id:2420566]. You will implement a complete particle-mesh (PM) code, using the Fast Fourier Transform (FFT) to solve the governing field equation and a symplectic integrator to evolve the particle trajectories, providing a hands-on introduction to the entire simulation pipeline from field solving to dynamics.", "problem": "You are asked to implement a fully runnable program that numerically evolves a simplified weak-field $2+1$ dimensional gravity toy model in a periodic square domain, capturing the effective interaction between two localized “point masses” represented by smooth Gaussian sources on a uniform grid. The goal is to simulate head-on and grazing encounters using techniques inspired by numerical relativity and to decide, from the computed trajectories, whether the two masses collide under a specified proximity threshold. All calculations must be performed in dimensionless geometrized units where the gravitational coupling and the speed of light are normalized, and no physical unit conversion is required in the final output.\n\nStarting point and modeling assumptions:\n- Use the Einstein field equations in the weak-field, slow-motion limit, with a conformally flat ansatz for the spatial metric and a small gravitational potential. In this limit, and in $2+1$ dimensions with negligible gravitational radiation, the field reduces to a constraint of Poisson type for a scalar potential $\\Phi$ coupled to a surface mass density $\\rho$. This yields the elliptic constraint of the form\n$$\n\\nabla^2 \\Phi = \\kappa \\,\\rho,\n$$\nwhere $\\kappa$ is a dimensionless coupling constant you shall take as fixed and positive. Assume a periodic square domain of side length $L$ and adopt spectral methods consistent with periodic boundary conditions to solve this elliptic constraint at each time step.\n- Represent each “point mass” by a normalized Gaussian of width $\\sigma$ centered at its instantaneous position $\\boldsymbol{x}_p(t)$ so that the integrated mass equals a prescribed $m_p$. Approximate the geodesic equation for slow motion by\n$$\n\\frac{d \\boldsymbol{v}}{dt} = -\\nabla \\Phi,\\qquad \\frac{d \\boldsymbol{x}}{dt} = \\boldsymbol{v},\n$$\nwhich is consistent with linearized gravity in this regime. Evolve particle positions and velocities using a second-order accurate symplectic (leapfrog) integrator.\n\nNumerical method requirements:\n- Discretize the square domain into a uniform $N\\times N$ grid with spacing $\\Delta x = L/N$.\n- At each step, construct $\\rho(\\boldsymbol{x})$ as the sum of two Gaussians with total mass $m_1$ and $m_2$, each having width $\\sigma$:\n$$\n\\rho(\\boldsymbol{x}) = \\sum_{p=1}^{2} \\frac{m_p}{2\\pi \\sigma^2}\\exp\\!\\left(-\\frac{\\|\\boldsymbol{x}-\\boldsymbol{x}_p\\|_{\\text{per}}^2}{2\\sigma^2}\\right),\n$$\nwhere $\\|\\cdot\\|_{\\text{per}}$ denotes the minimum-image norm under periodic boundaries.\n- Solve the elliptic constraint in Fourier space using the Fast Fourier Transform (FFT): for wavevectors $\\boldsymbol{k}=(k_x,k_y)$,\n$$\n-|\\boldsymbol{k}|^2 \\,\\widehat{\\Phi}(\\boldsymbol{k}) = \\kappa\\, \\widehat{\\rho}(\\boldsymbol{k})\\quad\\Rightarrow\\quad \\widehat{\\Phi}(\\boldsymbol{k}) = -\\kappa \\frac{\\widehat{\\rho}(\\boldsymbol{k})}{|\\boldsymbol{k}|^2},\n$$\nwith the zero mode set to satisfy $\\widehat{\\Phi}(\\boldsymbol{0})=0$ (potential defined up to a constant). Obtain the acceleration field using\n$$\n\\boldsymbol{a}(\\boldsymbol{x}) = -\\nabla \\Phi(\\boldsymbol{x}),\\quad \\text{implemented spectrally via}\\quad \\widehat{\\partial_i \\Phi} = i\\,k_i\\,\\widehat{\\Phi}.\n$$\n- Interpolate the acceleration $\\boldsymbol{a}$ from the grid to particle positions using bilinear interpolation consistent with periodic wrapping.\n\nTime integration:\n- Use the leapfrog scheme (kick-drift-kick):\n  1. Compute $\\boldsymbol{a}^n = \\boldsymbol{a}(\\boldsymbol{x}^n)$ from the current particle positions via the above field solve.\n  2. Half-kick: $\\boldsymbol{v}^{n+\\tfrac{1}{2}} = \\boldsymbol{v}^n + \\tfrac{\\Delta t}{2}\\,\\boldsymbol{a}^n$.\n  3. Drift: $\\boldsymbol{x}^{n+1} = \\boldsymbol{x}^n + \\Delta t\\,\\boldsymbol{v}^{n+\\tfrac{1}{2}}$ (apply periodic wrapping to stay in the domain).\n  4. Recompute the field at $\\boldsymbol{x}^{n+1}$ to obtain $\\boldsymbol{a}^{n+1}$ and complete the kick: $\\boldsymbol{v}^{n+1} = \\boldsymbol{v}^{n+\\tfrac{1}{2}} + \\tfrac{\\Delta t}{2}\\,\\boldsymbol{a}^{n+1}$.\n- Throughout the evolution, track the instantaneous particle separation using the minimum-image convention for periodic domains:\n$$\nd(t) = \\left\\|\\left[\\boldsymbol{x}_1(t)-\\boldsymbol{x}_2(t)\\right]_{\\text{per}}\\right\\|_2.\n$$\nDefine a “collision” as occurring if $\\min_t d(t) < 2\\sigma$ during the simulated interval.\n\nTest suite specification:\nUse the following three test cases, all in dimensionless geometrized units, with identical global numerical parameters $N$, $L$, $\\sigma$, and $\\kappa$, but differing in particle masses and initial conditions. For each case, evolve for a fixed number of steps and decide whether a collision occurred, returning a boolean.\n\nGlobal numerical parameters for all cases:\n- Grid size: $N = 64$.\n- Domain size: $L = 1.0$.\n- Gaussian width: $\\sigma = 0.02$.\n- Coupling: $\\kappa = 0.1$.\n- Time step: $\\Delta t = 0.002$.\n- Number of steps: $n_{\\text{steps}} = 300$.\n\nCase A (head-on, equal masses):\n- Masses: $m_1 = 0.5$, $m_2 = 0.5$.\n- Initial positions: $\\boldsymbol{x}_1(0) = (0.3,\\,0.5)$, $\\boldsymbol{x}_2(0) = (0.7,\\,0.5)$.\n- Initial velocities: $\\boldsymbol{v}_1(0) = (0.08,\\,0.0)$, $\\boldsymbol{v}_2(0) = (-0.08,\\,0.0)$.\n\nCase B (grazing, equal masses, larger impact parameter):\n- Masses: $m_1 = 0.5$, $m_2 = 0.5$.\n- Initial positions: $\\boldsymbol{x}_1(0) = (0.3,\\,0.4)$, $\\boldsymbol{x}_2(0) = (0.7,\\,0.6)$.\n- Initial velocities: $\\boldsymbol{v}_1(0) = (0.08,\\,0.0)$, $\\boldsymbol{v}_2(0) = (-0.08,\\,0.0)$.\n\nCase C (head-on, very small masses):\n- Masses: $m_1 = 0.02$, $m_2 = 0.02$.\n- Initial positions: $\\boldsymbol{x}_1(0) = (0.3,\\,0.5)$, $\\boldsymbol{x}_2(0) = (0.7,\\,0.5)$.\n- Initial velocities: $\\boldsymbol{v}_1(0) = (0.08,\\,0.0)$, $\\boldsymbol{v}_2(0) = (-0.08,\\,0.0)$.\n\nAnswer specification and output format:\n- For each test case, compute the boolean collision indicator defined by whether the minimum separation satisfies $\\min_t d(t) < 2\\sigma$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the three cases in the order A, B, C (for example, \"[True,False,False]\"). Since these are booleans, they are unitless and must be printed as plain boolean values.", "solution": "The problem statement is valid. It presents a well-defined computational physics task grounded in established principles of classical field theory and numerical analysis. The model, while simplified, is a standard toy problem in the study of gravitational dynamics, often referred to as a Particle-Mesh (PM) simulation. All parameters, initial conditions, equations, and numerical methods are specified with sufficient clarity and precision to permit a unique, verifiable solution. We will proceed with the construction of the algorithm.\n\nThe core of the problem is to simulate the N-body problem, here with $N=2$ particles, under a self-generated gravitational field. The force is not calculated via direct pairwise summation but through a field-mediated approach. The simulation loop advances the state of the system—positions $\\boldsymbol{x}_p(t)$ and velocities $\\boldsymbol{v}_p(t)$ for particles $p=1, 2$—through discrete time steps of size $\\Delta t$. Each time step consists of two main stages: first, computing the forces on the particles given their current positions, and second, using these forces to update their positions and velocities.\n\nFirst, we address the computation of the acceleration field, $\\boldsymbol{a} = -\\nabla \\Phi$. This requires solving the $2$-dimensional Poisson equation,\n$$\n\\nabla^2 \\Phi(\\boldsymbol{x}) = \\kappa \\,\\rho(\\boldsymbol{x}),\n$$\non a periodic square domain of side length $L$. The source term, $\\rho(\\boldsymbol{x})$, is the surface mass density generated by the two particles. The problem specifies a grid-based method with a uniform mesh of $N \\times N$ points.\n\nThe density field is constructed by distributing the mass of each particle onto the grid. Each particle is a smooth Gaussian distribution, not a true point mass, to avoid singularities. The density at any point $\\boldsymbol{x}$ is given by\n$$\n\\rho(\\boldsymbol{x}) = \\sum_{p=1}^{2} \\frac{m_p}{2\\pi \\sigma^2}\\exp\\!\\left(-\\frac{\\|\\boldsymbol{x}-\\boldsymbol{x}_p\\|_{\\text{per}}^2}{2\\sigma^2}\\right).\n$$\nHere, $\\|\\boldsymbol{x}-\\boldsymbol{x}_p\\|_{\\text{per}}$ is the distance under the minimum image convention, which correctly handles the periodic nature of the domain. To implement this, for each grid point $\\boldsymbol{x}_{ij}$, we calculate its shortest distance to each particle $\\boldsymbol{x}_p$ and sum the Gaussian contributions. For a separation vector $\\Delta\\boldsymbol{x} = \\boldsymbol{x}_{ij}-\\boldsymbol{x}_p$, its periodic counterpart is found by taking each component $\\Delta x_k$ and mapping it to the interval $[-L/2, L/2]$.\n\nWith the density field $\\rho_{ij}$ discretized on the grid, we solve for the potential $\\Phi$. The use of periodic boundary conditions makes spectral methods based on the Fast Fourier Transform (FFT) exceptionally efficient. We transform the Poisson equation into Fourier space. The Fourier transform of the Laplacian operator is $\\mathcal{F}\\{\\nabla^2 f\\} = -|\\boldsymbol{k}|^2 \\widehat{f}(\\boldsymbol{k})$, where $\\boldsymbol{k}=(k_x, k_y)$ is the wavevector. The discrete wavevectors for a grid of size $N$ and domain length $L$ are given by $k_i = 2\\pi n_i/L$, where $n_i$ are integers from $-N/2$ to $N/2-1$. The field equation becomes an algebraic equation in Fourier space for each mode $\\boldsymbol{k}$:\n$$\n-|\\boldsymbol{k}|^2 \\,\\widehat{\\Phi}(\\boldsymbol{k}) = \\kappa\\, \\widehat{\\rho}(\\boldsymbol{k}).\n$$\nThis is solved for the Fourier coefficients of the potential:\n$$\n\\widehat{\\Phi}(\\boldsymbol{k}) = -\\kappa \\frac{\\widehat{\\rho}(\\boldsymbol{k})}{|\\boldsymbol{k}|^2}.\n$$\nFor the zero-frequency mode $\\boldsymbol{k}=\\boldsymbol{0}$, the denominator $|\\boldsymbol{k}|^2$ is zero. This singularity reflects the fact that the potential is defined only up to an arbitrary constant. The problem specifies the physical choice $\\widehat{\\Phi}(\\boldsymbol{0}) = 0$, which sets the spatial average of the potential to zero. For all other modes, the division is well-defined.\n\nOnce $\\widehat{\\Phi}(\\boldsymbol{k})$ is known, we can find the acceleration field $\\boldsymbol{a} = -\\nabla\\Phi$. In Fourier space, the gradient operator $\\nabla$ corresponds to multiplication by $i\\boldsymbol{k}$. Therefore, the Fourier transform of the acceleration vector is\n$$\n\\widehat{\\boldsymbol{a}}(\\boldsymbol{k}) = -i\\boldsymbol{k}\\,\\widehat{\\Phi}(\\boldsymbol{k}).\n$$\nApplying a 2D inverse FFT to the components $\\widehat{a}_x(\\boldsymbol{k})$ and $\\widehat{a}_y(\\boldsymbol{k})$ yields the acceleration field components $a_x(\\boldsymbol{x})$ and $a_y(\\boldsymbol{x})$ on the discrete grid.\n\nThe particles, however, are not located on the grid points. To find the acceleration at a particle's continuous position $\\boldsymbol{x}_p$, we must interpolate the acceleration field from the grid. As specified, bilinear interpolation is used. This method approximates the value at $\\boldsymbol{x}_p$ using a weighted average of the values at the four nearest grid points forming a cell that encloses $\\boldsymbol{x}_p$. This interpolation must also respect the periodic boundary conditions, which can be handled robustly using library functions like `scipy.ndimage.map_coordinates` with periodic wrapping mode.\n\nWith a method to compute acceleration $\\boldsymbol{a}(\\boldsymbol{x}^n)$ at any time step $n$, we evolve the particle dynamics using the specified second-order leapfrog integrator (kick-drift-kick variant). This symplectic scheme is well-suited for Hamiltonian systems as it exhibits good long-term conservation properties. The update proceeds as follows:\n1.  Compute initial acceleration: $\\boldsymbol{a}^n = \\boldsymbol{a}(\\boldsymbol{x}^n)$.\n2.  Half-kick for velocity: $\\boldsymbol{v}^{n+\\frac{1}{2}} = \\boldsymbol{v}^n + \\frac{\\Delta t}{2}\\,\\boldsymbol{a}^n$.\n3.  Full drift for position: $\\boldsymbol{x}^{n+1} = \\boldsymbol{x}^n + \\Delta t\\,\\boldsymbol{v}^{n+\\frac{1}{2}}$. Positions are then wrapped back into the domain $[0, L) \\times [0, L)$ using the modulo operator.\n4.  Recompute acceleration at the new positions: $\\boldsymbol{a}^{n+1} = \\boldsymbol{a}(\\boldsymbol{x}^{n+1})$.\n5.  Second half-kick for velocity: $\\boldsymbol{v}^{n+1} = \\boldsymbol{v}^{n+\\frac{1}{2}} + \\frac{\\Delta t}{2}\\,\\boldsymbol{a}^{n+1}$.\n\nThis constitutes one full time step. The process is repeated for $n_{\\text{steps}}$ iterations. Throughout the simulation, we monitor the separation distance between the two particles, $d(t) = \\|\\boldsymbol{x}_1(t)-\\boldsymbol{x}_2(t)\\|_{\\text{per}}$. A \"collision\" is registered if the minimum distance observed during the entire evolution, $\\min_t d(t)$, falls below the threshold of $2\\sigma$. The final output is a boolean value for each test case indicating whether this condition was met.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import map_coordinates\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations for all test cases and print results.\n    \"\"\"\n\n    # Global numerical parameters for all cases\n    N = 64\n    L = 1.0\n    sigma = 0.02\n    kappa = 0.1\n    dt = 0.002\n    n_steps = 300\n    collision_threshold = 2.0 * sigma\n\n    test_cases = [\n        # Case A: Head-on, equal masses\n        {\n            'masses': np.array([0.5, 0.5]),\n            'positions': np.array([[0.3, 0.5], [0.7, 0.5]]),\n            'velocities': np.array([[0.08, 0.0], [-0.08, 0.0]])\n        },\n        # Case B: Grazing, equal masses\n        {\n            'masses': np.array([0.5, 0.5]),\n            'positions': np.array([[0.3, 0.4], [0.7, 0.6]]),\n            'velocities': np.array([[0.08, 0.0], [-0.08, 0.0]])\n        },\n        # Case C: Head-on, very small masses\n        {\n            'masses': np.array([0.02, 0.02]),\n            'positions': np.array([[0.3, 0.5], [0.7, 0.5]]),\n            'velocities': np.array([[0.08, 0.0], [-0.08, 0.0]])\n        }\n    ]\n\n    results = []\n    \n    # Memoize grid and wavenumber calculations as they are constant for all runs\n    grid_coords = np.linspace(0, L, N, endpoint=False)\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n    k_freq = np.fft.fftfreq(N, d=L / N) * 2 * np.pi\n    kx, ky = np.meshgrid(k_freq, k_freq)\n    ksq = kx**2 + ky**2\n    ksq[0, 0] = 1.0  # Placeholder to avoid division-by-zero warning\n\n    for case in test_cases:\n        collided = run_simulation(\n            case, N, L, sigma, kappa, dt, n_steps, collision_threshold,\n            xx, yy, kx, ky, ksq\n        )\n        results.append(collided)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_acceleration(positions, masses, N, L, sigma, kappa, xx, yy, kx, ky, ksq):\n    \"\"\"\n    Computes acceleration on particles using a particle-mesh FFT method.\n    \"\"\"\n    # 1. Deposit mass density onto the grid\n    rho = np.zeros((N, N), dtype=float)\n    for p_idx in range(len(masses)):\n        pos = positions[p_idx]\n        mass = masses[p_idx]\n        \n        # Calculate periodic distance from each grid point to the particle\n        dx = xx - pos[0]\n        dy = yy - pos[1]\n        dx -= L * np.round(dx / L)\n        dy -= L * np.round(dy / L)\n        dist_sq = dx**2 + dy**2\n        \n        normalization = mass / (2 * np.pi * sigma**2)\n        rho += normalization * np.exp(-dist_sq / (2 * sigma**2))\n\n    # 2. Solve for potential in Fourier space\n    rho_hat = np.fft.fft2(rho)\n    phi_hat = -kappa * rho_hat / ksq\n    phi_hat[0, 0] = 0.0  # Set zero mode of potential to zero\n\n    # 3. Compute acceleration field in Fourier space and transform back\n    ax_hat = -1j * kx * phi_hat\n    ay_hat = -1j * ky * phi_hat\n    ax_grid = np.real(np.fft.ifft2(ax_hat))\n    ay_grid = np.real(np.fft.ifft2(ay_hat))\n\n    # 4. Interpolate acceleration to particle positions using bilinear interpolation\n    # with periodic wrapping\n    # map_coordinates requires coordinates in index space (not world space)\n    # and in (row, col) which corresponds to (y, x) order.\n    particle_coords_idx = positions / (L / N)\n    coords = particle_coords_idx.T[::-1, :]\n    \n    ax_interp = map_coordinates(ax_grid, coords, order=1, mode='wrap')\n    ay_interp = map_coordinates(ay_grid, coords, order=1, mode='wrap')\n    \n    return np.vstack((ax_interp, ay_interp)).T\n\ndef get_periodic_distance(pos1, pos2, L_domain):\n    \"\"\"Calculates the minimum-image distance.\"\"\"\n    delta = pos1 - pos2\n    delta -= L_domain * np.round(delta / L_domain)\n    return np.linalg.norm(delta)\n\ndef run_simulation(case, N, L, sigma, kappa, dt, n_steps, threshold, xx, yy, kx, ky, ksq):\n    \"\"\"\n    Evolves the system for a single test case.\n    \"\"\"\n    positions = case['positions'].copy()\n    velocities = case['velocities'].copy()\n    masses = case['masses']\n    \n    min_dist = get_periodic_distance(positions[0], positions[1], L)\n\n    # Compute initial acceleration to start the leapfrog integrator\n    accel_n = compute_acceleration(positions, masses, N, L, sigma, kappa, xx, yy, kx, ky, ksq)\n\n    for _ in range(n_steps):\n        # 1. Half-kick for velocity\n        vel_half = velocities + (dt / 2.0) * accel_n\n        \n        # 2. Full drift for position\n        positions_n1 = positions + dt * vel_half\n        positions_n1 %= L  # Apply periodic boundary conditions\n\n        # 3. Recompute acceleration at new positions\n        accel_n1 = compute_acceleration(positions_n1, masses, N, L, sigma, kappa, xx, yy, kx, ky, ksq)\n        \n        # 4. Second half-kick for velocity\n        velocities_n1 = vel_half + (dt / 2.0) * accel_n1\n\n        # Update state for the next iteration\n        positions = positions_n1\n        velocities = velocities_n1\n        accel_n = accel_n1\n\n        # Track minimum distance\n        dist = get_periodic_distance(positions[0], positions[1], L)\n        if dist  min_dist:\n            min_dist = dist\n\n    return min_dist  threshold\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2420566"}, {"introduction": "Writing a working simulation is only the first step; writing an efficient one is a deeper challenge that lies at the heart of computational science. This practice problem shifts focus from implementation to analysis, asking you to compare the computational cost versus accuracy for different numerical schemes used in evolving the BSSN equations [@problem_id:2420602]. By analyzing how the total work scales with the desired error tolerance for second-order and fourth-order finite difference methods, you will develop a crucial intuition for why higher-order methods are often indispensable for high-precision simulations, despite their greater complexity per step.", "problem": "You are asked to compare the computational cost and accuracy of two finite-difference spatial discretizations used to evolve the Baumgarte–Shapiro–Shibata–Nakamura (BSSN) formulation of Einstein’s equations in numerical relativity. Consider the following setting.\n\n- The evolution is performed on a uniform cubic domain of side length $L$ in geometric units where $c=1$, for a fixed physical time interval $T$, on a three-dimensional grid (so $d=3$).\n- The principal part of the BSSN system is hyperbolic with characteristic speeds bounded by $\\mathcal{O}(1)$.\n- Spatial derivatives are approximated by centered, uniform-grid finite differences using either a $p=2$ scheme (e.g., a $3$-point stencil per coordinate direction) or a $p=4$ scheme (e.g., a $5$-point stencil per coordinate direction).\n- Time integration uses the method of lines with an explicit scheme of order at least $\\max(p,4)$, such as fourth-order Runge–Kutta (RK$4$). The stability (Courant–Friedrichs–Lewy) condition can be written as $\\Delta t \\le \\lambda_p\\, h$, where $h$ is the uniform grid spacing and $\\lambda_p$ is a method-dependent constant, with $\\lambda_4  \\lambda_2$.\n- Let $C_p$ denote the number of floating-point operations per grid point required to evaluate the right-hand side once (for the chosen spatial discretization of order $p$), with $C_4  C_2$ due to the wider stencil and additional arithmetic.\n- For smooth solutions over the fixed time $T$, assume the global error is dominated by the spatial discretization and scales as $E_p \\approx A\\, h^p$ for some problem-dependent constant $A$ independent of $h$ and $p$.\n\nDefine the target accuracy by a tolerance $\\varepsilon$ in a suitable norm (e.g., a max norm) at time $T$, and define the total floating-point work $W_p$ as the product of the number of grid points, the number of time steps, and the per-point right-hand-side cost $C_p$.\n\nWhich of the following statements about the scaling of $W_p$ with $\\varepsilon$ and the relative efficiency and accuracy of the $p=2$ versus $p=4$ schemes is correct?\n\nA. In $d=3$, with $T$ and $L$ fixed and for smooth solutions whose error is spatially dominated, the total work scales (up to $\\varepsilon$-independent constants) as $W_2 \\propto C_2\\,\\lambda_2^{-1}\\,\\varepsilon^{-2}$ and $W_4 \\propto C_4\\,\\lambda_4^{-1}\\,\\varepsilon^{-1}$. Therefore, for sufficiently small $\\varepsilon$, the $p=4$ scheme is asymptotically more efficient despite its larger $C_4$ and smaller $\\lambda_4$.\n\nB. In $d=3$, the total work scales as $W_2 \\propto C_2\\,\\lambda_2^{-1}\\,\\varepsilon^{-3/2}$ and $W_4 \\propto C_4\\,\\lambda_4^{-1}\\,\\varepsilon^{-1/2}$, so both methods have essentially the same asymptotic behavior and the advantage of $p=4$ is at most a constant factor.\n\nC. Because the $p=4$ stencil is wider, its stable time step scales as $\\Delta t \\propto h^2$, so in $d=3$ both methods have $W \\propto \\varepsilon^{-2}$ and there is no asymptotic efficiency advantage to $p=4$.\n\nD. For fixed $h$, the $p=4$ method is less accurate than the $p=2$ method for BSSN due to its higher-order derivatives, so to meet a given $\\varepsilon$ it requires a finer grid than $p=2$; any cost difference is therefore only due to noise reduction from the wider stencil rather than truncation error order.", "solution": "We proceed from first principles: grid resolution and time step constraints, truncation error scaling, and operation counts.\n\nLet $h$ be the uniform grid spacing in each coordinate direction, with $N \\approx L/h$ points per direction, so the total number of grid points is $N^3 \\approx (L/h)^3$. The explicit time step is constrained by the Courant–Friedrichs–Lewy condition $\\Delta t \\le \\lambda_p h$, where $\\lambda_p$ is a constant depending on the discretization order $p$ and on characteristic speeds of the hyperbolic system, which are bounded by $\\mathcal{O}(1)$.\n\nThe number of time steps to cover the fixed physical time $T$ is $N_t \\approx T/\\Delta t \\gtrsim T/(\\lambda_p h)$. Up to constants independent of $h$ and $\\varepsilon$, we have $N_t \\propto \\lambda_p^{-1} h^{-1}$.\n\nPer right-hand-side evaluation, the per-point operation count is $C_p$, so the total work $W_p$ (in floating-point operations) for the evolution to time $T$ scales as\n$$\nW_p \\;\\propto\\; C_p \\times \\text{(number of grid points)} \\times \\text{(number of time steps)}\n\\;\\propto\\; C_p \\left(\\frac{L}{h}\\right)^3 \\left(\\frac{T}{\\lambda_p h}\\right)\n\\;\\propto\\; C_p\\,\\lambda_p^{-1}\\, h^{-(3+1)} \\;=\\; C_p\\,\\lambda_p^{-1}\\, h^{-4}.\n$$\n\nAccuracy requirement: by the definition of a $p$th-order spatial finite-difference scheme and the assumption that the global error is spatially dominated over the fixed $T$, the error scales as\n$$\nE_p \\;\\approx\\; A\\, h^p,\n$$\nfor some constant $A$ depending on the solution’s smoothness and the PDE but independent of $h$ (and treated as independent of $p$ in this scaling argument). Imposing a target tolerance $\\varepsilon$ requires $E_p \\lesssim \\varepsilon$, i.e.,\n$$\nh \\;\\lesssim\\; \\left(\\frac{\\varepsilon}{A}\\right)^{1/p}.\n$$\nInverting this relation and substituting into the work estimate gives\n$$\nW_p \\;\\propto\\; C_p\\,\\lambda_p^{-1}\\, \\left(\\left(\\frac{\\varepsilon}{A}\\right)^{1/p}\\right)^{-4}\n\\;=\\; C_p\\,\\lambda_p^{-1}\\, A^{4/p}\\, \\varepsilon^{-4/p}.\n$$\nUp to $\\varepsilon$-independent constants, the dominant dependence is\n$$\nW_p \\;\\propto\\; C_p\\,\\lambda_p^{-1}\\, \\varepsilon^{-4/p}.\n$$\n\nFor $p=2$,\n$$\nW_2 \\;\\propto\\; C_2\\,\\lambda_2^{-1}\\, \\varepsilon^{-4/2} \\;=\\; C_2\\,\\lambda_2^{-1}\\,\\varepsilon^{-2}.\n$$\nFor $p=4$,\n$$\nW_4 \\;\\propto\\; C_4\\,\\lambda_4^{-1}\\, \\varepsilon^{-4/4} \\;=\\; C_4\\,\\lambda_4^{-1}\\,\\varepsilon^{-1}.\n$$\nTherefore, in $d=3$ with fixed $T$ and $L$, the fourth-order method requires asymptotically fewer floating-point operations to reach small $\\varepsilon$ because $\\varepsilon^{-1}$ grows more slowly than $\\varepsilon^{-2}$ as $\\varepsilon \\to 0$, even though $C_4  C_2$ and $\\lambda_4  \\lambda_2$. The crossover tolerance $\\varepsilon_\\star$ at which $W_2 \\approx W_4$ satisfies\n$$\nC_2\\,\\lambda_2^{-1}\\,\\varepsilon_\\star^{-2} \\;\\approx\\; C_4\\,\\lambda_4^{-1}\\,\\varepsilon_\\star^{-1}\n\\;\\;\\Rightarrow\\;\\; \\varepsilon_\\star \\;\\approx\\; \\frac{C_4}{C_2}\\,\\frac{\\lambda_2}{\\lambda_4},\n$$\nso for $\\varepsilon \\ll \\varepsilon_\\star$ the $p=4$ scheme is more efficient, while for $\\varepsilon \\gg \\varepsilon_\\star$ the $p=2$ scheme may be cheaper due to smaller constants.\n\nAccuracy at fixed $h$: since $E_p \\approx A h^p$, for the same $h$ the $p=4$ scheme has error $E_4 \\approx A h^4$, which is smaller than $E_2 \\approx A h^2$ by a factor $\\approx h^2$ for sufficiently smooth solutions. Thus, at fixed resolution, $p=4$ is more accurate, not less.\n\nNow evaluate each option:\n\n- Option A: It states precisely the derived scalings $W_2 \\propto C_2\\,\\lambda_2^{-1}\\,\\varepsilon^{-2}$ and $W_4 \\propto C_4\\,\\lambda_4^{-1}\\,\\varepsilon^{-1}$ in $d=3$, and correctly concludes the asymptotic efficiency of $p=4$ for small $\\varepsilon$ despite larger per-step cost and smaller $\\lambda_4$. This matches the derivation. Verdict — Correct.\n\n- Option B: It claims exponents $-3/2$ and $-1/2$, which would correspond to $W_p \\propto \\varepsilon^{-(d)/p}$ (missing the extra factor from the number of time steps). This neglects the $h^{-1}$ factor from the time stepping and is therefore inconsistent with the method-of-lines explicit scheme for hyperbolic problems. Verdict — Incorrect.\n\n- Option C: It asserts that the stable time step for $p=4$ scales as $\\Delta t \\propto h^2$ due to the wider stencil. For hyperbolic equations with centered differences, the Courant–Friedrichs–Lewy condition gives $\\Delta t \\propto h$ with an order-dependent constant, not $\\propto h^2$ (parabolic problems have $\\Delta t \\propto h^2$). Thus the premise and the resulting conclusion are both incorrect. Verdict — Incorrect.\n\n- Option D: It claims that at fixed $h$, the $p=4$ method is less accurate for BSSN. This contradicts the definition of truncation order for smooth solutions: higher $p$ yields smaller error at the same $h$. Verdict — Incorrect.", "answer": "$$\\boxed{A}$$", "id": "2420602"}, {"introduction": "A simulation's final output is a vast collection of data, but the goal of numerical relativity is to extract physical insights. This hands-on practice focuses on this crucial \"post-processing\" stage, where you will implement a diagnostic to measure the spin of a black hole from simulation data on its horizon [@problem_id:2420583]. Using the established isolated horizon formalism, you will compute the dimensionless spin parameter $\\chi$ by performing a numerical surface integral, providing a direct link between the geometric output of a simulation and a key physical property of a black hole.", "problem": "You must write a complete, self-contained program that implements a quasi-local black hole spin diagnostic using the isolated horizon formalism in geometrized units where $G=c=1$. Consider individual black holes whose apparent horizons are axisymmetric topological spheres with areal radius $R$, so that the spherical surface area is $A=4\\pi R^2$ and the area element is $\\mathrm{d}A = R^2 \\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi$, where the spherical angles are $\\theta\\in[0,\\pi]$ and $\\phi\\in[0,2\\pi)$ in radians. The spin angular momentum associated with an axisymmetry vector field is defined by the isolated horizon integral\n$$\nJ \\equiv \\frac{1}{8\\pi}\\int_{S} \\omega_a \\,\\phi^a\\,\\mathrm{d}A,\n$$\nwhere the contraction $\\omega_a \\phi^a$ is a given scalar function on the horizon. Define the irreducible mass by the area relation\n$$\nM_{\\mathrm{irr}} \\equiv \\sqrt{\\frac{A}{16\\pi}},\n$$\nand the Christodoulou mass by\n$$\nM^2 \\equiv M_{\\mathrm{irr}}^2 + \\frac{J^2}{4 M_{\\mathrm{irr}}^2}.\n$$\nThe dimensionless spin parameter is\n$$\n\\chi \\equiv \\frac{|J|}{M^2}.\n$$\nAll quantities are dimensionless in these units.\n\nYour program must, for each test case below, numerically evaluate the integral for $J$ using the specified $\\omega_a \\phi^a$ on the spherical surface, compute $M_{\\mathrm{irr}}$ and $M$, and output the corresponding $\\chi$. Angles $\\theta$ and $\\phi$ must be interpreted in radians. The final results must be rounded to six decimal places.\n\nTest suite. For each case, use the given areal radius $R$ and the specified scalar function $f(\\theta,\\phi)\\equiv \\omega_a \\phi^a$:\n- Case 1: $R=1$, $f(\\theta,\\phi)=\\alpha$ with $\\alpha=1$.\n- Case 2: $R=3$, $f(\\theta,\\phi)=0$.\n- Case 3: $R=2$, $f(\\theta,\\phi)=\\alpha\\sin^2\\theta$ with $\\alpha=\\tfrac{3}{4}$.\n- Case 4: $R=\\tfrac{3}{2}$, $f(\\theta,\\phi)=\\alpha\\sin^2\\theta\\cos(2\\phi)$ with $\\alpha=2$.\n\nRequired final output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each entry being the value of $\\chi$ for the corresponding case in order, rounded to six decimal places. For example, an acceptable format is $[\\chi_1,\\chi_2,\\chi_3,\\chi_4]$ where each $\\chi_i$ is a float with six digits after the decimal point.", "solution": "The problem statement has been analyzed and is determined to be valid. It is scientifically grounded in the principles of general relativity, specifically the isolated horizon formalism used for quasi-local characterization of black holes. The definitions provided for spin angular momentum, irreducible mass, and Christodoulou mass are standard in this context. The problem is well-posed, with all necessary data and equations provided to arrive at a unique, meaningful solution for each test case. The language is objective and precise.\n\nThe core of the problem is to compute the dimensionless spin parameter $\\chi$ for a series of axisymmetric black hole apparent horizons. This requires a multi-step calculation starting from the given areal radius $R$ and a scalar function $f(\\theta,\\phi) \\equiv \\omega_a \\phi^a$ on the horizon surface.\n\nThe fundamental quantities are defined as follows:\nThe surface area of the spherical horizon is $A = 4\\pi R^2$.\nThe irreducible mass, $M_{\\mathrm{irr}}$, is defined in terms of the area:\n$$ M_{\\mathrm{irr}} \\equiv \\sqrt{\\frac{A}{16\\pi}} $$\nSubstituting the expression for $A$, we obtain a simpler relation:\n$$ M_{\\mathrm{irr}} = \\sqrt{\\frac{4\\pi R^2}{16\\pi}} = \\sqrt{\\frac{R^2}{4}} = \\frac{R}{2} $$\nThis simplification is useful. The irreducible mass represents the portion of the black hole's mass-energy that cannot be extracted via Penrose processes.\n\nThe spin angular momentum, $J$, is given by the surface integral:\n$$ J \\equiv \\frac{1}{8\\pi}\\int_{S} f(\\theta,\\phi)\\,\\mathrm{d}A $$\nwhere $f(\\theta,\\phi) = \\omega_a \\phi^a$. The area element in spherical coordinates is $\\mathrm{d}A = R^2 \\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi$. The integral becomes:\n$$ J = \\frac{1}{8\\pi} \\int_{0}^{2\\pi} \\int_{0}^{\\pi} f(\\theta, \\phi) R^2 \\sin\\theta \\, \\mathrm{d}\\theta \\, \\mathrm{d}\\phi = \\frac{R^2}{8\\pi} \\int_{0}^{2\\pi} \\mathrm{d}\\phi \\int_{0}^{\\pi} f(\\theta, \\phi) \\sin\\theta \\, \\mathrm{d}\\theta $$\nThis integral will be computed numerically as specified by the problem.\n\nThe Christodoulou mass, $M$, which represents the total mass-energy of the black hole as measured at infinity, is defined by the Christodoulou-Ruffini mass formula:\n$$ M^2 \\equiv M_{\\mathrm{irr}}^2 + \\frac{J^2}{4 M_{\\mathrm{irr}}^2} $$\nSubstituting our expression for $M_{\\mathrm{irr}}$:\n$$ M^2 = \\left(\\frac{R}{2}\\right)^2 + \\frac{J^2}{4 \\left(\\frac{R}{2}\\right)^2} = \\frac{R^2}{4} + \\frac{J^2}{R^2} $$\n\nFinally, the dimensionless spin parameter, $\\chi$, is calculated as:\n$$ \\chi \\equiv \\frac{|J|}{M^2} $$\nA value of $\\chi=0$ corresponds to a non-rotating (Schwarzschild-like) black hole, while $\\chi=1$ corresponds to a maximally rotating (extremal Kerr-like) black hole within this theoretical framework.\n\nThe computational procedure for each test case is as follows:\n1.  Define the integrand function for the numerical integration of $J$. Let this be $I(\\theta, \\phi) = f(\\theta, \\phi)\\sin\\theta$.\n2.  Numerically evaluate the double integral $\\mathcal{I} = \\int_{0}^{2\\pi} \\mathrm{d}\\phi \\int_{0}^{\\pi} I(\\theta, \\phi) \\, \\mathrm{d}\\theta$ using the `scipy.integrate.dblquad` function. The call will be structured as `dblquad(lambda theta, phi: I(theta, phi), 0, 2*pi, 0, pi)`.\n3.  Calculate $J = \\frac{R^2}{8\\pi} \\mathcal{I}$.\n4.  Calculate $M^2 = \\frac{R^2}{4} + \\frac{J^2}{R^2}$.\n5.  Calculate $\\chi = \\frac{|J|}{M^2}$. Note that if $R=0$, both $M^2$ and the denominator in the $J^2$ term would be zero, but all given test cases have $R > 0$. Similarly, if $M^2=0$, it implies $R=0$ and $J=0$, which is a trivial case not present here.\n6.  The final value of $\\chi$ is rounded to six decimal places for output.\n\nWe now apply this procedure to each test case.\n\n**Case 1:** $R=1$, $f(\\theta,\\phi)=1$.\n- $J_1 = \\frac{1^2}{8\\pi} \\int_0^{2\\pi} \\mathrm{d}\\phi \\int_0^{\\pi} (1) \\sin\\theta \\, \\mathrm{d}\\theta = \\frac{1}{8\\pi} \\cdot (2\\pi) \\cdot (2) = \\frac{4\\pi}{8\\pi} = \\frac{1}{2}$.\n- $M_1^2 = \\frac{1^2}{4} + \\frac{(1/2)^2}{1^2} = \\frac{1}{4} + \\frac{1}{4} = \\frac{1}{2}$.\n- $\\chi_1 = \\frac{|1/2|}{1/2} = 1$. Result: $1.000000$.\n\n**Case 2:** $R=3$, $f(\\theta,\\phi)=0$.\n- The integrand is zero, so the integral is zero. Thus, $J_2 = 0$.\n- This corresponds to a non-rotating black hole.\n- $M_2^2 = \\frac{3^2}{4} + \\frac{0^2}{3^2} = \\frac{9}{4}$.\n- $\\chi_2 = \\frac{0}{9/4} = 0$. Result: $0.000000$.\n\n**Case 3:** $R=2$, $f(\\theta,\\phi)=\\frac{3}{4}\\sin^2\\theta$.\n- $J_3 = \\frac{2^2}{8\\pi} \\int_0^{2\\pi} \\mathrm{d}\\phi \\int_0^{\\pi} \\frac{3}{4}\\sin^2\\theta \\sin\\theta \\, \\mathrm{d}\\theta = \\frac{4}{8\\pi} \\frac{3}{4} \\int_0^{2\\pi} \\mathrm{d}\\phi \\int_0^{\\pi} \\sin^3\\theta \\, \\mathrm{d}\\theta$.\n- The integral $\\int_0^{\\pi} \\sin^3\\theta\\,\\mathrm{d}\\theta = 4/3$. The integral $\\int_0^{2\\pi} \\mathrm{d}\\phi = 2\\pi$.\n- $J_3 = \\frac{3}{8\\pi} \\cdot (2\\pi) \\cdot (4/3) = 1$.\n- $M_3^2 = \\frac{2^2}{4} + \\frac{1^2}{2^2} = 1 + \\frac{1}{4} = \\frac{5}{4} = 1.25$.\n- $\\chi_3 = \\frac{|1|}{5/4} = \\frac{4}{5} = 0.8$. Result: $0.800000$.\n\n**Case 4:** $R=\\frac{3}{2}$, $f(\\theta,\\phi)=2\\sin^2\\theta\\cos(2\\phi)$.\n- $J_4 = \\frac{(3/2)^2}{8\\pi} \\int_0^{2\\pi} \\int_0^{\\pi} 2\\sin^2\\theta\\cos(2\\phi) \\sin\\theta \\, \\mathrm{d}\\theta \\, \\mathrm{d}\\phi$.\n- The integral is separable: $J_4 \\propto \\left(\\int_0^{\\pi} \\sin^3\\theta \\, \\mathrm{d}\\theta \\right) \\left(\\int_0^{2\\pi} \\cos(2\\phi) \\, \\mathrm{d}\\phi \\right)$.\n- The integral over $\\phi$ is $\\int_0^{2\\pi} \\cos(2\\phi) \\, \\mathrm{d}\\phi = \\left[\\frac{\\sin(2\\phi)}{2}\\right]_0^{2\\pi} = 0$.\n- Therefore, $J_4 = 0$.\n- $\\chi_4 = 0$. Result: $0.000000$.\n\nThe provided program implements this logic precisely using numerical integration.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import dblquad\n\ndef solve():\n    \"\"\"\n    Solves for the dimensionless spin parameter for a set of black hole test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (R, f_func) where R is the areal radius and\n    # f_func is the scalar function f(theta, phi) = omega_a * phi^a.\n    test_cases = [\n        (1.0, lambda theta, phi: 1.0),\n        (3.0, lambda theta, phi: 0.0),\n        (2.0, lambda theta, phi: (3.0/4.0) * np.sin(theta)**2),\n        (1.5, lambda theta, phi: 2.0 * np.sin(theta)**2 * np.cos(2*phi))\n    ]\n\n    results = []\n    for R, f_func in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        chi = calculate_spin_parameter(R, f_func)\n        results.append(chi)\n\n    # Format the final results as strings with six decimal places.\n    results_str = [f\"{res:.6f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\ndef calculate_spin_parameter(R, f_func):\n    \"\"\"\n    Calculates the dimensionless spin parameter chi for a given black hole horizon.\n\n    Args:\n        R (float): The areal radius of the apparent horizon.\n        f_func (callable): A function f(theta, phi) representing the scalar omega_a * phi^a.\n\n    Returns:\n        float: The dimensionless spin parameter chi.\n    \"\"\"\n    if R = 0:\n        # Physical radius must be positive.\n        return 0.0\n\n    # 1. Calculate Spin Angular Momentum J\n    # J = (1 / 8*pi) * integral_S(f * dA)\n    # dA = R^2 * sin(theta) * d(theta) * d(phi)\n    # J = (R^2 / 8*pi) * integral_{phi=0}^{2pi} integral_{theta=0}^{pi} f(theta, phi) * sin(theta) d(theta) d(phi)\n    \n    # Define the integrand for the numerical integration.\n    # dblquad integrates func(y, x), where y is the first argument.\n    # Here, y = theta, x = phi.\n    integrand = lambda theta, phi: f_func(theta, phi) * np.sin(theta)\n\n    # Perform the numerical double integration.\n    # Outer integral (phi) from 0 to 2*pi.\n    # Inner integral (theta) from 0 to pi.\n    integral_val, _ = dblquad(integrand, 0, 2*np.pi, 0, np.pi)\n    \n    J = (R**2 / (8 * np.pi)) * integral_val\n\n    # 2. Calculate Irreducible Mass M_irr\n    # M_irr = sqrt(A / 16*pi), where A = 4*pi*R^2\n    # This simplifies to M_irr = R / 2\n    M_irr = R / 2.0\n\n    # 3. Calculate Christodoulou Mass M\n    # M^2 = M_irr^2 + J^2 / (4 * M_irr^2)\n    try:\n        M_squared = M_irr**2 + J**2 / (4 * M_irr**2)\n    except ZeroDivisionError:\n        # This case happens if M_irr is zero, which means R is zero.\n        # For J=0, M^2=0, chi is undefined. For J!=0, M-squared is infinite.\n        # We handle R=0 at the start. So this should not be reached.\n        return np.nan\n\n    # 4. Calculate Dimensionless Spin Parameter chi\n    # chi = |J| / M^2\n    if M_squared == 0:\n        # M_squared is zero only if R=0 and J=0.\n        # A non-rotating point mass has chi=0.\n        return 0.0\n\n    chi = np.abs(J) / M_squared\n    \n    return chi\n\nsolve()\n```", "id": "2420583"}]}