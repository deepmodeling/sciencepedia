{"hands_on_practices": [{"introduction": "The 3+1 decomposition of Einstein's equations beautifully separates the theory into constraints and evolution. Before we can simulate the dynamic evolution of spacetime, we must first construct a valid initial \"snapshot\" at a given moment in time. This is not an arbitrary process; the initial data must satisfy the Hamiltonian and momentum constraint equations. This exercise [@problem_id:2370134], focusing on a simplified \"thin-sandwich\" problem, provides direct, hands-on experience with this fundamental concept. By solving for the lapse function $\\alpha$ and shift vector $\\beta^i$ that are consistent with a prescribed spatial metric and its time derivative, you will see how these abstract constraints translate into a concrete, solvable system of differential equations.", "problem": "Consider the vacuum Einstein equations in the $3+1$ decomposition on a single time slice with a spatial metric $ \\gamma_{ij}(x) $ and its time derivative $ \\dot{\\gamma}_{ij}(x) $ on a one-dimensional periodic domain $ x \\in [0,2\\pi) $. Assume small perturbations about a flat background so that $ \\gamma_{ij}(x) = \\delta_{ij} + h_{ij}(x) $ with $ \\lVert h_{ij} \\rVert \\ll 1 $, all fields depend only on $ x $, and spatial indices are raised and lowered with $ \\delta_{ij} $. Impose the following conditions: (i) maximal slicing with vanishing trace of the extrinsic curvature $ K = 0 $, (ii) the lapse $ \\alpha $ is spatially constant and normalized by the condition that its spatial average equals $ 1 $, and (iii) periodic boundary conditions for all fields. Work in the linearized regime about flat space and require the linearized kinematic relation and momentum constraint to hold:\n- Kinematic relation: $ \\dot{\\gamma}_{ij} = -2 \\alpha K_{ij} + \\partial_i \\beta_j + \\partial_j \\beta_i $,\n- Momentum constraint: $ \\partial_j K^{ij} = 0 $,\nwhere $ \\beta^i(x) $ is the shift vector and $ K_{ij}(x) $ is the extrinsic curvature. Given that $ K = \\gamma^{ij} K_{ij} = 0 $ (maximal slicing), determine $ \\alpha $ and $ \\beta^i(x) $ that satisfy these relations for each of the test cases below. The problem is unitless.\n\nYou are given four test cases that specify the symmetric tensor field $ \\dot{\\gamma}_{ij}(x) \\equiv S_{ij}(x) $ componentwise (all unspecified components are zero, and symmetry means $ S_{ij} = S_{ji} $):\n- Test 1 (trace-only mode): $ S_{xx}(x) = \\cos(x) $.\n- Test 2 (shear-only off-diagonal mode): $ S_{xy}(x) = \\sin(2x) $ (and hence $ S_{yx}(x) = \\sin(2x) $).\n- Test 3 (transverse-traceless-like diagonal mode): $ S_{yy}(x) = \\cos(3x) $ and $ S_{zz}(x) = -\\cos(3x) $.\n- Test 4 (mixed mode): $ S_{xx}(x) = \\sin(x) $, $ S_{xy}(x) = \\cos(3x) $ (and $ S_{yx}(x) = \\cos(3x) $), and $ S_{xz}(x) = \\sin(2x) $ (and $ S_{zx}(x) = \\sin(2x) $).\n\nFor each test, compute a solution $ \\alpha $ and $ \\beta^i(x) $ that satisfy the stated equations in the linearized regime, under the stated conditions. Then, for each test, report the two quantities:\n- the spatial average of $ \\alpha $,\n- the spatial root-mean-square norm of the shift $ \\beta^i(x) $, defined by\n$$ \\lVert \\beta \\rVert_{\\mathrm{RMS}} \\equiv \\sqrt{\\frac{1}{2\\pi} \\int_0^{2\\pi} \\left( \\beta_x(x)^2 + \\beta_y(x)^2 + \\beta_z(x)^2 \\right) \\, dx }. $$\n\nYour program should produce a single line of output containing the results for all four tests as a comma-separated list enclosed in square brackets. The list must be ordered as\n$ [\\bar{\\alpha}_1, \\lVert \\beta \\rVert_{\\mathrm{RMS},1}, \\bar{\\alpha}_2, \\lVert \\beta \\rVert_{\\mathrm{RMS},2}, \\bar{\\alpha}_3, \\lVert \\beta \\rVert_{\\mathrm{RMS},3}, \\bar{\\alpha}_4, \\lVert \\beta \\rVert_{\\mathrm{RMS},4}] $,\nwhere $ \\bar{\\alpha}_k $ is the spatial average of $ \\alpha $ for test $ k $, and $ \\lVert \\beta \\rVert_{\\mathrm{RMS},k} $ is the spatial root-mean-square norm of the shift for test $ k $. All quantities are to be reported as real numbers (dimensionless). No angles are used in the output. The domain is $ x \\in [0,2\\pi) $ and all integrals are with respect to $ x $ over this interval.", "solution": "The user has presented a problem in computational physics concerning the $3+1$ decomposition of Einstein's equations in a linearized, one-dimensional setting. This professor will now validate and solve it.\n\n**Problem Validation**\n\nFirst, I extract the givens as stated:\n- The system is described by vacuum Einstein equations in $3+1$ form on a single time slice.\n- The spatial domain is one-dimensional and periodic: $x \\in [0, 2\\pi)$.\n- All fields depend only on $x$.\n- The spatial metric is a small perturbation of a flat background: $\\gamma_{ij}(x) = \\delta_{ij} + h_{ij}(x)$, with $\\lVert h_{ij} \\rVert \\ll 1$.\n- Indices are raised and lowered with the flat metric $\\delta_{ij}$.\n- A maximal slicing condition is imposed: the trace of the extrinsic curvature is zero, $K = \\gamma^{ij}K_{ij} = 0$.\n- The lapse function $\\alpha$ is spatially constant and normalized with a spatial average of $1$.\n- All fields obey periodic boundary conditions.\n- The linearized equations to be satisfied are the kinematic relation, $\\dot{\\gamma}_{ij} = -2 \\alpha K_{ij} + \\partial_i \\beta_j + \\partial_j \\beta_i$, and the momentum constraint, $\\partial_j K^{ij} = 0$.\n- The time derivative of the metric is given as $\\dot{\\gamma}_{ij}(x) \\equiv S_{ij}(x)$.\n- The quantities to be determined are the lapse $\\alpha$ and the shift vector $\\beta^i(x)$.\n\nThe problem is scientifically grounded in general relativity, specifically the ADM formalism. It is well-posed, objective, and contains sufficient information for a unique solution to the requested quantities, provided a standard physical gauge choice is made for an integration constant. The problem is therefore **valid**.\n\n**Solution Derivation**\n\nThe problem asks for the spatial average of the lapse, $\\bar{\\alpha}$, and the root-mean-square norm of the shift, $\\lVert \\beta \\rVert_{\\mathrm{RMS}}$, for four test cases.\n\n**1. Determine the Lapse Function $\\alpha$**\nThe problem states that the lapse $\\alpha$ is spatially constant, i.e., $\\alpha(x) = C$ for some constant $C$. It is also normalized such that its spatial average is $1$:\n$$ \\bar{\\alpha} \\equiv \\frac{1}{2\\pi} \\int_0^{2\\pi} \\alpha(x) \\, dx = 1 $$\nSubstituting $\\alpha(x) = C$ into the normalization condition gives:\n$$ \\frac{1}{2\\pi} \\int_0^{2\\pi} C \\, dx = \\frac{1}{2\\pi} (2\\pi C) = C = 1 $$\nThus, the lapse function is fixed to $\\alpha(x) = 1$. Consequently, its spatial average is $\\bar{\\alpha} = 1$ for all test cases. This is not a quantity to be derived from dynamics, but is fixed by the stated gauge conditions.\n\n**2. Simplify the Constraint and Kinematic Equations**\nThe fields depend only on $x$, so spatial derivatives are $\\partial_i = (\\frac{d}{dx}, 0, 0)$. Indices are manipulated with $\\delta_{ij}$.\n\nThe linearized momentum constraint is $\\partial_j K^{ij} = 0$. Since only the $x$-derivative is non-zero, this reduces to $\\frac{d}{dx} K^{x i} = 0$. As indices are raised with $\\delta^{ij}$, we have $K^{xi} = K_{xi}$. So, the components $K_{xx}(x)$, $K_{xy}(x)$, and $K_{xz}(x)$ must be spatially constant.\n\nThe maximal slicing condition $K = 0$, in the linearized regime, is $K = \\delta^{ij}K_{ij} = K_{xx} + K_{yy} + K_{zz} = 0$.\n\nThe kinematic relation is given by $\\dot{\\gamma}_{ij} \\equiv S_{ij} = -2\\alpha K_{ij} + \\partial_i\\beta_j + \\partial_j\\beta_i$. With $\\alpha=1$ and dependence only on $x$, the components are:\n$$ S_{xx} = -2K_{xx} + 2\\frac{d\\beta_x}{dx} $$\n$$ S_{xy} = -2K_{xy} + \\frac{d\\beta_y}{dx} $$\n$$ S_{xz} = -2K_{xz} + \\frac{d\\beta_z}{dx} $$\n$$ S_{yy} = -2K_{yy} \\implies K_{yy} = -\\frac{1}{2}S_{yy}(x) $$\n$$ S_{zz} = -2K_{zz} \\implies K_{zz} = -\\frac{1}{2}S_{zz}(x) $$\n$$ S_{yz} = -2K_{yz} \\implies K_{yz} = -\\frac{1}{2}S_{yz}(x) $$\n\nSubstituting the expressions for $K_{yy}$ and $K_{zz}$ into the trace condition $K=0$:\n$$ K_{xx} - \\frac{1}{2}S_{yy}(x) - \\frac{1}{2}S_{zz}(x) = 0 \\implies K_{xx} = \\frac{1}{2}\\left( S_{yy}(x) + S_{zz}(x) \\right) $$\nSince $K_{xx}$ must be a constant, this implies that the sum $S_{yy}(x) + S_{zz}(x)$ must also be constant. For all given test cases, $S_{yy}(x) + S_{zz}(x) = 0$, which is constant. Therefore, $K_{xx} = 0$.\n\nNow we determine the constants $K_{xy}$ and $K_{xz}$. We integrate the kinematic relations for $S_{xy}$ and $S_{xz}$ over the periodic domain $[0, 2\\pi)$. The integrals of the $\\frac{d\\beta_i}{dx}$ terms vanish due to the periodicity of $\\beta_i(x)$.\n$$ \\int_0^{2\\pi} S_{xy}(x) \\, dx = -2 \\int_0^{2\\pi} K_{xy} \\, dx + \\int_0^{2\\pi} \\frac{d\\beta_y}{dx} \\, dx = -4\\pi K_{xy} $$\n$$ \\implies K_{xy} = -\\frac{1}{4\\pi}\\int_0^{2\\pi} S_{xy}(x) \\, dx $$\nSimilarly, $K_{xz} = -\\frac{1}{4\\pi}\\int_0^{2\\pi} S_{xz}(x) \\, dx$.\nIn all provided test cases, the source terms $S_{ij}(x)$ are given by sine or cosine functions with integer wave numbers greater than or equal to $1$. The integral of such functions over $[0, 2\\pi]$ is zero. Therefore, $K_{xy} = 0$ and $K_{xz} = 0$ for all test cases.\n\nWith $K_{xx}=K_{xy}=K_{xz}=0$, the equations for the shift vector $\\beta^i$ simplify to:\n$$ \\frac{d\\beta_x}{dx} = \\frac{1}{2} S_{xx}(x) $$\n$$ \\frac{d\\beta_y}{dx} = S_{xy}(x) $$\n$$ \\frac{d\\beta_z}{dx} = S_{xz}(x) $$\nThese are integrated to find $\\beta_i(x)$. The integration introduces constants, which we fix by enforcing that each component $\\beta_i(x)$ has zero spatial average, i.e., $\\int_0^{2\\pi} \\beta_i(x) dx = 0$. This is a standard gauge choice that uniquely determines the shift vector and corresponds to the solution with the minimum RMS norm.\n\n**3. Calculation for Each Test Case**\nWe use the general formula for the mean square of a periodic function $g(x)$ composed of orthogonal modes, $\\frac{1}{2\\pi}\\int_0^{2\\pi} g(x)^2 \\, dx$. For $g(x) = A\\cos(kx)$ or $g(x) = A\\sin(kx)$ with integer $k \\ge 1$, this is $\\frac{1}{2}A^2$. The RMS norm is the square root of the sum of the mean squares of the components.\n\n- **Test 1:** $S_{xx}(x) = \\cos(x)$.\n  $\\frac{d\\beta_x}{dx} = \\frac{1}{2}\\cos(x) \\implies \\beta_x(x) = \\frac{1}{2}\\sin(x)$.\n  $\\beta_y(x) = 0$, $\\beta_z(x) = 0$.\n  $\\lVert \\beta \\rVert_{\\mathrm{RMS}}^2 = \\frac{1}{2\\pi} \\int_0^{2\\pi} (\\frac{1}{2}\\sin(x))^2 dx = \\frac{1}{4} \\cdot \\frac{1}{2} = \\frac{1}{8}$.\n  $\\lVert \\beta \\rVert_{\\mathrm{RMS}} = \\sqrt{1/8} = \\frac{\\sqrt{2}}{4}$.\n\n- **Test 2:** $S_{xy}(x) = \\sin(2x)$.\n  $\\frac{d\\beta_y}{dx} = \\sin(2x) \\implies \\beta_y(x) = -\\frac{1}{2}\\cos(2x)$.\n  $\\beta_x(x) = 0$, $\\beta_z(x) = 0$.\n  $\\lVert \\beta \\rVert_{\\mathrm{RMS}}^2 = \\frac{1}{2\\pi} \\int_0^{2\\pi} (-\\frac{1}{2}\\cos(2x))^2 dx = \\frac{1}{4} \\cdot \\frac{1}{2} = \\frac{1}{8}$.\n  $\\lVert \\beta \\rVert_{\\mathrm{RMS}} = \\sqrt{1/8} = \\frac{\\sqrt{2}}{4}$.\n\n- **Test 3:** $S_{yy}(x) = \\cos(3x)$, $S_{zz}(x) = -\\cos(3x)$.\n  $S_{xx}=S_{xy}=S_{xz}=0$.\n  $\\frac{d\\beta_i}{dx} = 0$ for all $i$, which implies $\\beta_i(x) = 0$.\n  $\\lVert \\beta \\rVert_{\\mathrm{RMS}} = 0$.\n\n- **Test 4:** $S_{xx}(x) = \\sin(x)$, $S_{xy}(x) = \\cos(3x)$, $S_{xz}(x) = \\sin(2x)$.\n  $\\frac{d\\beta_x}{dx} = \\frac{1}{2}\\sin(x) \\implies \\beta_x(x) = -\\frac{1}{2}\\cos(x)$.\n  $\\frac{d\\beta_y}{dx} = \\cos(3x) \\implies \\beta_y(x) = \\frac{1}{3}\\sin(3x)$.\n  $\\frac{d\\beta_z}{dx} = \\sin(2x) \\implies \\beta_z(x) = -\\frac{1}{2}\\cos(2x)$.\n  The components are orthogonal. The total mean square is the sum of individual mean squares:\n  $\\lVert \\beta \\rVert_{\\mathrm{RMS}}^2 = \\frac{1}{2\\pi}\\int_0^{2\\pi} \\beta_x^2 dx + \\frac{1}{2\\pi}\\int_0^{2\\pi} \\beta_y^2 dx + \\frac{1}{2\\pi}\\int_0^{2\\pi} \\beta_z^2 dx$\n  $\\lVert \\beta \\rVert_{\\mathrm{RMS}}^2 = \\frac{1}{2}(-\\frac{1}{2})^2 + \\frac{1}{2}(\\frac{1}{3})^2 + \\frac{1}{2}(-\\frac{1}{2})^2 = \\frac{1}{8} + \\frac{1}{18} + \\frac{1}{8} = \\frac{1}{4} + \\frac{1}{18} = \\frac{9+2}{36} = \\frac{11}{36}$.\n  $\\lVert \\beta \\rVert_{\\mathrm{RMS}} = \\sqrt{11/36} = \\frac{\\sqrt{11}}{6}$.\n\n**Summary of Results**\nThe final list of results $[\\bar{\\alpha}_1, \\lVert \\beta \\rVert_{\\mathrm{RMS},1}, \\bar{\\alpha}_2, \\lVert \\beta \\rVert_{\\mathrm{RMS},2}, \\bar{\\alpha}_3, \\lVert \\beta \\rVert_{\\mathrm{RMS},3}, \\bar{\\alpha}_4, \\lVert \\beta \\rVert_{\\mathrm{RMS},4}]$ is:\n$[1.0, \\frac{\\sqrt{2}}{4}, 1.0, \\frac{\\sqrt{2}}{4}, 1.0, 0.0, 1.0, \\frac{\\sqrt{11}}{6}]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the lapse and shift vector properties for four test cases\n    in linearized 1D general relativity on a periodic domain.\n    \"\"\"\n    \n    # The problem specifies a spatially constant lapse alpha with a spatial average of 1.\n    # This uniquely determines alpha = 1 for all cases. The spatial average is thus 1.\n    alpha_avg = 1.0\n\n    # Test 1: S_xx = cos(x)\n    # d(beta_x)/dx = 1/2 * S_xx = 1/2 * cos(x) -> beta_x = 1/2 * sin(x)\n    # RMS norm^2 = (1/2pi) * integral_0^2pi (1/2*sin(x))^2 dx = (1/4) * (1/2) = 1/8\n    beta_rms_1 = np.sqrt(1.0 / 8.0)\n\n    # Test 2: S_xy = sin(2x)\n    # d(beta_y)/dx = S_xy = sin(2x) -> beta_y = -1/2 * cos(2x)\n    # RMS norm^2 = (1/2pi) * integral_0^2pi (-1/2*cos(2x))^2 dx = (1/4) * (1/2) = 1/8\n    beta_rms_2 = np.sqrt(1.0 / 8.0)\n\n    # Test 3: S_yy = cos(3x), S_zz = -cos(3x)\n    # S_ix = 0 for all i. d(beta_i)/dx = 0 -> beta_i = 0.\n    # RMS norm = 0\n    beta_rms_3 = 0.0\n\n    # Test 4: S_xx = sin(x), S_xy = cos(3x), S_xz = sin(2x)\n    # d(beta_x)/dx = 1/2 * sin(x) -> beta_x = -1/2 * cos(x)\n    # d(beta_y)/dx = cos(3x) -> beta_y = 1/3 * sin(3x)\n    # d(beta_z)/dx = sin(2x) -> beta_z = -1/2 * cos(2x)\n    # RMS norm^2 is the sum of mean squares of orthogonal components:\n    # MS_x = (1/2) * (-1/2)^2 = 1/8\n    # MS_y = (1/2) * (1/3)^2 = 1/18\n    # MS_z = (1/2) * (-1/2)^2 = 1/8\n    # Total RMS norm^2 = 1/8 + 1/18 + 1/8 = 2/8 + 1/18 = 1/4 + 1/18 = (9+2)/36 = 11/36\n    beta_rms_4 = np.sqrt(11.0 / 36.0)\n\n    results = [\n        alpha_avg, beta_rms_1,\n        alpha_avg, beta_rms_2,\n        alpha_avg, beta_rms_3,\n        alpha_avg, beta_rms_4\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2370134"}, {"introduction": "Once a valid set of initial data is constructed, the next challenge is to evolve it forward in time. The ADM evolution equations form a complex system of hyperbolic partial differential equations that are typically solved using numerical methods on a computer. This practice problem [@problem_id:2370142] serves as a crucial numerical laboratory, using the simple scalar wave equation as an analogue for the full Einstein equations. By implementing and comparing different finite-difference schemes, you will develop an intuition for the core concepts of numerical stability, accuracy, and convergence—essential skills for any computational physicist tackling wave-like phenomena, from sound waves to gravitational waves.", "problem": "You are to implement a numerical evolution of the scalar wave equation arising from a simple case of the $3+1$ decomposition of Einstein’s equations. Consider Minkowski spacetime with lapse $\\alpha=1$, shift $\\beta^{i}=0$, and spatial metric $\\gamma_{ij}=\\delta_{ij}$. In these conditions, for a scalar field $\\phi(x,t)$ the covariant wave equation reduces to the one-dimensional scalar wave equation\n$$\\partial_{t}^{2}\\phi(x,t)=c^{2}\\,\\partial_{x}^{2}\\phi(x,t).$$\nIntroduce the first-order-in-time formulation by defining the auxiliary variable $\\Pi(x,t)=\\partial_{t}\\phi(x,t)$ to obtain the system\n$$\\partial_{t}\\phi(x,t)=\\Pi(x,t),\\qquad \\partial_{t}\\Pi(x,t)=c^{2}\\,\\partial_{x}^{2}\\phi(x,t).$$\nWork on the periodic domain $x\\in[0,2\\pi]$ with wave speed $c=1$. Use the initial data\n$$\\phi(x,0)=\\sin(kx),\\qquad \\Pi(x,0)=0,$$\nwith wavenumber $k=1$. The exact solution at time $t$ is\n$$\\phi_{\\text{exact}}(x,t)=\\cos(ckt)\\,\\sin(kx)=\\cos(t)\\,\\sin(x).$$\n\nYour task is to implement two different centered finite-differencing stencils for the spatial second derivative $\\partial_{x}^{2}\\phi$ on a uniform grid with $N$ points and periodic boundary conditions:\n- Second-order accurate stencil:\n$$\\partial_{x}^{2}\\phi(x_{i})\\approx\\frac{\\phi_{i-1}-2\\phi_{i}+\\phi_{i+1}}{\\Delta x^{2}}.$$\n- Fourth-order accurate stencil:\n$$\\partial_{x}^{2}\\phi(x_{i})\\approx\\frac{-\\phi_{i-2}+16\\phi_{i-1}-30\\phi_{i}+16\\phi_{i+1}-\\phi_{i+2}}{12\\,\\Delta x^{2}}.$$\n\nEvolve the system from $t=0$ to a specified final time $T$ using any consistent and stable time integrator. Define the discrete $L^{2}$ error of $\\phi$ at time $T$ as\n$$E(N)=\\left(\\Delta x\\sum_{i=0}^{N-1}\\left[\\phi_{i}(T)-\\phi_{\\text{exact}}(x_{i},T)\\right]^{2}\\right)^{1/2}.$$\nGiven a pair of resolutions $(N_{\\text{coarse}},N_{\\text{fine}})$ with $N_{\\text{fine}}=2N_{\\text{coarse}}$, define the observed convergence rate\n$$p=\\frac{\\log\\left(E(N_{\\text{coarse}})/E(N_{\\text{fine}})\\right)}{\\log\\left(\\Delta x_{\\text{coarse}}/\\Delta x_{\\text{fine}}\\right)}.$$\n\nAssess stability as follows: if, during the evolution, any numerical value becomes non-finite or the discrete energy\n$$\\mathcal{E}(t)=\\frac{1}{2}\\int_{0}^{2\\pi}\\left[\\Pi(x,t)^{2}+c^{2}\\left(\\partial_{x}\\phi(x,t)\\right)^{2}\\right]\\mathrm{d}x$$\ngrows by more than a fixed factor of $10$ relative to its initial value, declare the run unstable. In the discrete setting, approximate $\\partial_{x}\\phi$ using a centered stencil of the same formal order as used for $\\partial_{x}^{2}\\phi$, and approximate the integral by a Riemann sum with spacing $\\Delta x$.\n\nFor each test case below, use a Courant-like factor $\\lambda=\\Delta t/\\Delta x$ to set the time step as $\\Delta t=\\lambda\\,\\Delta x/c$, and integrate to the specified $T$. If either the coarse or fine resolution run is unstable, report the convergence rate for that test case as not-a-number.\n\nImplement your program to run the following test suite and aggregate the results:\n- Test A (happy path, second-order): stencil order $s=2$, $\\lambda=0.4$, $(N_{\\text{coarse}},N_{\\text{fine}})=(64,128)$, $T=1.0$.\n- Test B (happy path, fourth-order): stencil order $s=4$, $\\lambda=0.4$, $(N_{\\text{coarse}},N_{\\text{fine}})=(64,128)$, $T=1.0$.\n- Test C (edge case, unstable): stencil order $s=4$, $\\lambda=3.0$, $(N_{\\text{coarse}},N_{\\text{fine}})=(64,128)$, $T=1.0$.\n\nYour program should produce a single line of output containing the observed convergence rates for Tests A, B, and C, in that order, as a comma-separated list enclosed in square brackets (for example, $\"[p_{A},p_{B},p_{C}]\"$). Use the IEEE not-a-number value to indicate instability for a test (that is, print a value that parses as a floating-point not-a-number).", "solution": "The problem as stated is valid. It is scientifically grounded, well-posed, objective, and provides a complete, self-contained set of instructions for a standard numerical analysis exercise in computational physics. It is free of any mathematical or physical inconsistencies. I will therefore proceed with a solution.\n\nThe problem requires the numerical evolution of the one-dimensional scalar wave equation, presented as a first-order system in time:\n$$\n\\partial_{t}\\phi(x,t)=\\Pi(x,t) \\\\\n\\partial_{t}\\Pi(x,t)=c^{2}\\,\\partial_{x}^{2}\\phi(x,t)\n$$\non a periodic domain $x \\in [0, 2\\pi]$ with wave speed $c=1$. The initial data are $\\phi(x,0)=\\sin(kx)$ and $\\Pi(x,0)=0$ with wavenumber $k=1$.\n\nFirst, we discretize the spatial domain into a uniform grid of $N$ points $x_i = i\\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = 2\\pi/N$. The continuous fields $\\phi(x,t)$ and $\\Pi(x,t)$ are represented by their values on the grid, denoted as $\\phi_i(t)$ and $\\Pi_i(t)$.\n\nThe spatial second derivative term, $\\partial_{x}^{2}\\phi$, is approximated using a finite difference stencil of order $s$. This converts the system of partial differential equations into a large system of coupled ordinary differential equations (ODEs):\n$$\n\\frac{d\\phi_i(t)}{dt} = \\Pi_i(t) \\\\\n\\frac{d\\Pi_i(t)}{dt} = c^2 (\\mathcal{D}_x^2 \\phi)_i(t)\n$$\nwhere $(\\mathcal{D}_x^2 \\phi)_i$ denotes the discrete second derivative operator applied to the vector $\\phi = (\\phi_0, \\phi_1, \\dots, \\phi_{N-1})$ at grid point $i$. For a stencil of order $s=2$, the operator is:\n$$\n(\\mathcal{D}_x^2 \\phi)_i = \\frac{\\phi_{i-1} - 2\\phi_i + \\phi_{i+1}}{\\Delta x^2}\n$$\nFor a stencil of order $s=4$, it is:\n$$\n(\\mathcal{D}_x^2 \\phi)_i = \\frac{-\\phi_{i-2} + 16\\phi_{i-1} - 30\\phi_i + 16\\phi_{i+1} - \\phi_{i+2}}{12\\Delta x^2}\n$$\nThe periodic boundary conditions mean that indices are interpreted modulo $N$. For example, $\\phi_{-1} = \\phi_{N-1}$ and $\\phi_{N} = \\phi_{0}$. This is efficiently implemented using array-rolling operations.\n\nTo integrate this system of ODEs in time from $t=0$ to a final time $T$, we use the classical fourth-order Runge-Kutta (RK4) method. This is a robust and sufficiently high-order integrator, ensuring that the temporal discretization error does not contaminate the measurement of the spatial convergence rate. The state vector for our system is $Y(t) = (\\phi_0, \\dots, \\phi_{N-1}, \\Pi_0, \\dots, \\Pi_{N-1})^T$. The RK4 method advances the solution from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ as follows:\n$$\n\\begin{align*}\nK_1 &= F(Y(t_n)) \\\\\nK_2 &= F(Y(t_n) + \\frac{\\Delta t}{2} K_1) \\\\\nK_3 &= F(Y(t_n) + \\frac{\\Delta t}{2} K_2) \\\\\nK_4 &= F(Y(t_n) + \\Delta t K_3) \\\\\nY(t_{n+1}) &= Y(t_n) + \\frac{\\Delta t}{6} (K_1 + 2K_2 + 2K_3 + K_4)\n\\end{align*}\n$$\nwhere $F(Y)$ represents the right-hand side of our ODE system. The time step $\\Delta t$ is determined by the Courant-like factor $\\lambda$ as $\\Delta t = \\lambda \\Delta x / c$.\n\nStability of the evolution is monitored through two criteria. First, we check if any numerical value in the state vectors $\\phi_i(t)$ or $\\Pi_i(t)$ becomes non-finite (e.g., NaN or infinity). Second, we monitor the discrete energy of the system, which should be nearly conserved for a stable, non-dissipative scheme. The discrete energy is an approximation of the continuous functional:\n$$\n\\mathcal{E}(t) = \\frac{1}{2}\\int_{0}^{2\\pi}\\left[\\Pi(x,t)^{2}+c^{2}\\left(\\partial_{x}\\phi(x,t)\\right)^{2}\\right]\\mathrm{d}x \\approx \\frac{\\Delta x}{2} \\sum_{i=0}^{N-1} \\left[ \\Pi_i(t)^2 + c^2 ((\\mathcal{D}_x \\phi)_i(t))^2 \\right]\n$$\nThe discrete first-derivative operator $\\mathcal{D}_x$ must have the same order of accuracy $s$ as the second-derivative operator $\\mathcal{D}_x^2$. For $s=2$, we use the centered stencil:\n$$\n(\\mathcal{D}_x \\phi)_i = \\frac{\\phi_{i+1} - \\phi_{i-1}}{2\\Delta x}\n$$\nAnd for $s=4$:\n$$\n(\\mathcal{D}_x \\phi)_i = \\frac{-\\phi_{i+2} + 8\\phi_{i+1} - 8\\phi_{i-1} + \\phi_{i-2}}{12\\Delta x}\n$$\nA simulation is flagged as unstable if the energy $\\mathcal{E}(t)$ at any time step grows by more than a factor of $10$ relative to its initial value $\\mathcal{E}(0)$.\n\nFor each test case, we perform two simulations: one with a coarse resolution $N_{\\text{coarse}}$ and one with a fine resolution $N_{\\text{fine}}=2N_{\\text{coarse}}$. If either run is unstable, the result is reported as not-a-number (NaN). Otherwise, we compute the discrete $L^2$ error at the final time $T$ for both resolutions:\n$$\nE(N) = \\left(\\Delta x \\sum_{i=0}^{N-1} \\left[\\phi_i(T) - \\phi_{\\text{exact}}(x_i, T)\\right]^2\\right)^{1/2}\n$$\nwhere $\\phi_{\\text{exact}}(x,t)=\\cos(ct)\\sin(kx)$. The observed convergence rate $p$ is then calculated as:\n$$\np = \\frac{\\log(E(N_{\\text{coarse}})/E(N_{\\text{fine}}))}{\\log(\\Delta x_{\\text{coarse}}/\\Delta x_{\\text{fine}})} = \\frac{\\log(E(N_{\\text{coarse}})/E(N_{\\text{fine}}))}{\\log(2)}\n$$\nThe denominator is $\\log(2)$ because $N_{\\text{fine}} = 2N_{\\text{coarse}}$ implies $\\Delta x_{\\text{coarse}} = 2\\Delta x_{\\text{fine}}$. The implementation proceeds by creating functions for the spatial derivatives, the time evolution, and the convergence analysis as described.", "answer": "```python\nimport numpy as np\n\ndef d_phi_dx_stencil(phi, dx, order):\n    \"\"\"Computes the first spatial derivative using a centered stencil.\"\"\"\n    if order == 2:\n        # 2nd-order stencil: (phi_{i+1} - phi_{i-1}) / (2*dx)\n        return (np.roll(phi, -1) - np.roll(phi, 1)) / (2.0 * dx)\n    elif order == 4:\n        # 4th-order stencil: (-phi_{i+2} + 8*phi_{i+1} - 8*phi_{i-1} + phi_{i-2}) / (12*dx)\n        return (-np.roll(phi, -2) + 8.0 * np.roll(phi, -1) - 8.0 * np.roll(phi, 1) + np.roll(phi, 2)) / (12.0 * dx)\n    else:\n        raise ValueError(\"Unsupported stencil order for d_phi_dx.\")\n\ndef d2_phi_dx2_stencil(phi, dx, order):\n    \"\"\"Computes the second spatial derivative using a centered stencil.\"\"\"\n    if order == 2:\n        # 2nd-order stencil: (phi_{i-1} - 2*phi_i + phi_{i+1}) / dx^2\n        return (np.roll(phi, 1) - 2.0 * phi + np.roll(phi, -1)) / (dx**2)\n    elif order == 4:\n        # 4th-order stencil: (-phi_{i-2} + 16*phi_{i-1} - 30*phi_i + 16*phi_{i+1} - phi_{i-2}) / (12*dx^2)\n        return (-np.roll(phi, 2) + 16.0 * np.roll(phi, 1) - 30.0 * phi + 16.0 * np.roll(phi, -1) - np.roll(phi, -2)) / (12.0 * dx**2)\n    else:\n        raise ValueError(\"Unsupported stencil order for d2_phi_dx2.\")\n\ndef calculate_energy(phi, Pi, dx, c, order):\n    \"\"\"Computes the discrete energy of the system.\"\"\"\n    dphi_dx = d_phi_dx_stencil(phi, dx, order)\n    integrand = Pi**2 + c**2 * dphi_dx**2\n    return 0.5 * np.sum(integrand) * dx\n\ndef evolve(N, T_final, lambda_cfl, stencil_order, c, k):\n    \"\"\"\n    Evolves the scalar wave equation from t=0 to T_final.\n    Returns the final state phi and an instability flag.\n    \"\"\"\n    L = 2.0 * np.pi\n    dx = L / N\n    x = np.linspace(0, L, N, endpoint=False)\n    \n    # Initial conditions\n    phi = np.sin(k * x)\n    Pi = np.zeros(N)\n\n    # Time step from Courant-like factor\n    dt = lambda_cfl * dx / c\n    num_steps = int(np.ceil(T_final / dt))\n    dt = T_final / num_steps  # Adjust dt to hit T_final exactly\n\n    # Stability check setup\n    initial_energy = calculate_energy(phi, Pi, dx, c, stencil_order)\n    if initial_energy == 0: initial_energy = 1.0e-15 # Avoid division by zero if starts at rest with zero grad\n    is_unstable = False\n\n    # RHS of the ODE system dY/dt = F(Y)\n    def rhs(phi_state, Pi_state):\n        dphi_dt = Pi_state\n        dPi_dt = c**2 * d2_phi_dx2_stencil(phi_state, dx, stencil_order)\n        return dphi_dt, dPi_dt\n\n    # RK4 time integration loop\n    for _ in range(num_steps):\n        # k1\n        dphi_dt1, dPi_dt1 = rhs(phi, Pi)\n        \n        # k2\n        phi_k2 = phi + 0.5 * dt * dphi_dt1\n        Pi_k2 = Pi + 0.5 * dt * dPi_dt1\n        dphi_dt2, dPi_dt2 = rhs(phi_k2, Pi_k2)\n\n        # k3\n        phi_k3 = phi + 0.5 * dt * dphi_dt2\n        Pi_k3 = Pi + 0.5 * dt * dPi_dt2\n        dphi_dt3, dPi_dt3 = rhs(phi_k3, Pi_k3)\n\n        # k4\n        phi_k4 = phi + dt * dphi_dt3\n        Pi_k4 = Pi + dt * dPi_dt3\n        dphi_dt4, dPi_dt4 = rhs(phi_k4, Pi_k4)\n\n        # Update state\n        phi += (dt / 6.0) * (dphi_dt1 + 2 * dphi_dt2 + 2 * dphi_dt3 + dphi_dt4)\n        Pi += (dt / 6.0) * (dPi_dt1 + 2 * dPi_dt2 + 2 * dPi_dt3 + dPi_dt4)\n\n        # Stability checks\n        if not np.all(np.isfinite(phi)) or not np.all(np.isfinite(Pi)):\n            is_unstable = True\n            break\n        \n        current_energy = calculate_energy(phi, Pi, dx, c, stencil_order)\n        if current_energy > 10.0 * initial_energy:\n            is_unstable = True\n            break\n            \n    return phi, is_unstable\n\ndef run_convergence_test(s, lambda_cfl, N_pair, T, c, k):\n    \"\"\"\n    Runs a coarse and fine simulation to calculate the convergence rate.\n    \"\"\"\n    N_coarse, N_fine = N_pair\n    \n    # Coarse run\n    phi_coarse, unstable_coarse = evolve(N=N_coarse, T_final=T, lambda_cfl=lambda_cfl, stencil_order=s, c=c, k=k)\n    \n    # Fine run\n    phi_fine, unstable_fine = evolve(N=N_fine, T_final=T, lambda_cfl=lambda_cfl, stencil_order=s, c=c, k=k)\n    \n    if unstable_coarse or unstable_fine:\n        return np.nan\n\n    # Calculate L2 error for coarse grid\n    L = 2.0 * np.pi\n    dx_coarse = L / N_coarse\n    x_coarse = np.linspace(0, L, N_coarse, endpoint=False)\n    phi_exact_coarse = np.cos(c * k * T) * np.sin(k * x_coarse)\n    error_coarse = np.sqrt(dx_coarse * np.sum((phi_coarse - phi_exact_coarse)**2))\n\n    # Calculate L2 error for fine grid\n    dx_fine = L / N_fine\n    x_fine = np.linspace(0, L, N_fine, endpoint=False)\n    phi_exact_fine = np.cos(c * k * T) * np.sin(k * x_fine)\n    error_fine = np.sqrt(dx_fine * np.sum((phi_fine - phi_exact_fine)**2))\n    \n    # Calculate convergence rate\n    # The refinement ratio of grid spacing is dx_coarse / dx_fine = 2\n    if error_fine == 0.0 or error_coarse == 0.0:\n      return np.inf # Avoid log(0)\n    \n    convergence_rate = np.log(error_coarse / error_fine) / np.log(2.0)\n    \n    return convergence_rate\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints results.\n    \"\"\"\n    c = 1.0\n    k = 1.0\n    \n    test_cases = [\n        # Test A: s=2, stable\n        {'s': 2, 'lambda': 0.4, 'N_pair': (64, 128), 'T': 1.0},\n        # Test B: s=4, stable\n        {'s': 4, 'lambda': 0.4, 'N_pair': (64, 128), 'T': 1.0},\n        # Test C: s=4, unstable\n        {'s': 4, 'lambda': 3.0, 'N_pair': (64, 128), 'T': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        p = run_convergence_test(s=case['s'], lambda_cfl=case['lambda'], \n                                 N_pair=case['N_pair'], T=case['T'], c=c, k=k)\n        results.append(p)\n    \n    # Format the float/nan results into the required string representation\n    result_str = [f\"{r:.6f}\" if not np.isnan(r) else \"nan\" for r in results]\n\n    print(f\"[{','.join(result_str)}]\")\n\nsolve()\n```", "id": "2370142"}, {"introduction": "The final piece of the puzzle in numerical relativity is analyzing and interpreting the evolution. A unique feature of the 3+1 formalism is the freedom to choose the lapse $\\alpha$ and shift $\\beta^i$, a choice of coordinates known as the \"gauge\". This choice is not merely a technicality; it has profound consequences for the behavior of the simulation and its physical interpretation. This exercise [@problem_id:2370126] explores the \"geodesic slicing\" condition where $\\alpha=1$, corresponding to observers following timelike geodesics. You will discover firsthand how this seemingly simple choice can lead to coordinate \"crashing\", where coordinate lines are pulled into a singularity, demonstrating a critical lesson in designing stable, long-term spacetime evolutions.", "problem": "Consider a spherically symmetric vacuum spacetime described by the Schwarzschild solution and formulate it in the $3+1$ (Arnowitt–Deser–Misner, ADM) decomposition, where the spacetime metric is written in terms of a lapse function $\\alpha$, a shift vector $\\beta^i$, and a spatial metric $\\gamma_{ij}$. In geodesic slicing, the lapse is fixed to the constant value $\\alpha = 1$, so that the time coordinate measures the proper time along the normal congruence of worldlines orthogonal to the spatial hypersurfaces. In a horizon-penetrating representation that is consistent with the Schwarzschild geometry, this choice corresponds to a slicing in which the normal observers follow timelike geodesics that free-fall from rest at spatial infinity.\n\nYour task is to reason from these base principles and construct a minimal, self-consistent model that captures how geodesic slicing tends to focus coordinate lines toward the singularity. Proceed as follows.\n\n1) From the Schwarzschild spacetime and the $3+1$ decomposition definitions (lapse $\\alpha$, shift $\\beta^i$, spatial metric $\\gamma_{ij}$), use the geodesic slicing condition $\\alpha = 1$ and consider the congruence of timelike geodesics that start at rest at spatial infinity and fall radially inward. Using the geodesic equation and appropriate conserved quantities for radial motion in a spherically symmetric, static vacuum spacetime, derive an ordinary differential equation satisfied by the areal radius $r(t)$ of a freely falling observer, where $t$ is the coordinate time equal to the observers’ proper time due to $\\alpha = 1$. Solve this ordinary differential equation to obtain $r(t)$ in terms of the initial areal radius $r_0$ at $t = 0$ and the mass parameter $M$. Work in geometrized units where the gravitational constant $G$ and the speed of light $c$ are set to $1$.\n\n2) To quantify focusing, consider a one-parameter family (congruence) of such radial geodesics labeled by their initial areal radius $r_0$. Let $r(t;r_0)$ denote the areal radius at time $t$ for the geodesic that had areal radius $r_0$ at $t = 0$. Define the radial mapping Jacobian $J(t;r_0) = \\partial r(t;r_0)/\\partial r_0$ at fixed $t$. In spherical symmetry, the physical volume of a thin comoving shell is proportional to $r^2 \\mathrm{d}r$, so define the comoving volume scaling factor\n$$\nS(t;r_0) = \\frac{r(t;r_0)^2 \\, J(t;r_0)}{r_0^2},\n$$\nwhich measures how a small comoving shell’s volume changes relative to its initial volume. Derive a closed-form expression for $S(t;r_0)$, and determine the finite time $t_{\\mathrm{sing}}(r_0, M)$ at which $S(t;r_0)$ reaches zero, signalling complete focusing of the congruence at the physical singularity. Express $t_{\\mathrm{sing}}$ and $S(t;r_0)$ in terms of $r_0$, $M$, and $t$ only. In geometrized units, $t$ and $M$ have the same dimensions; report times in units of $M$ and radii in the same length units as $M$.\n\n3) Implement the geodesic slicing update as a program that evaluates, for a given mass $M$, initial areal radius $r_0$, and time $t \\ge 0$, the following outputs:\n- The areal radius $r(t;r_0)$ in the same length units as $M$.\n- The dimensionless comoving volume scaling factor $S(t;r_0)$.\nIf $t \\ge t_{\\mathrm{sing}}(r_0, M)$, take $r(t;r_0) = 0$ and $S(t;r_0) = 0$ to represent that the congruence has focused at the singularity. All computations must be carried out in geometrized units with $G = c = 1$. No angles are needed.\n\nTest suite and answer specification:\nUse the following five test cases, each specified as a triple $(M, r_0, t)$ with all quantities in geometrized units where $G = c = 1$:\n- Test $1$: $(M, r_0, t) = (1.0, 10.0, 1.0)$.\n- Test $2$: $(M, r_0, t) = (1.0, 4.0, \\tfrac{1}{2} \\, t_{\\mathrm{sing}}(4.0, 1.0))$.\n- Test $3$: $(M, r_0, t) = (1.0, 2.0, 0.99 \\, t_{\\mathrm{sing}}(2.0, 1.0))$.\n- Test $4$: $(M, r_0, t) = (1.0, 3.0, 1.5 \\, t_{\\mathrm{sing}}(3.0, 1.0))$.\n- Test $5$: $(M, r_0, t) = (2.0, 100.0, 1.0)$.\n\nYour program should compute for each test case the pair of floats $(r(t;r_0), S(t;r_0))$ and aggregate the results of all five cases into a single line of output as a comma-separated list enclosed in square brackets, ordered as\n$[r_1, S_1, r_2, S_2, r_3, S_3, r_4, S_4, r_5, S_5]$,\nwhere $r_k$ and $S_k$ correspond to test case $k$. All numbers must be printed as decimal floats in the stated units. The program must be self-contained and require no input.", "solution": "We begin from the $3+1$ (Arnowitt–Deser–Misner, ADM) decomposition of spacetime, where the line element can be written as\n$$\n\\mathrm{d}s^2 = -\\alpha^2 \\mathrm{d}t^2 + \\gamma_{ij} \\left( \\mathrm{d}x^i + \\beta^i \\mathrm{d}t \\right) \\left( \\mathrm{d}x^j + \\beta^j \\mathrm{d}t \\right),\n$$\nwith lapse $\\alpha$, shift $\\beta^i$, and spatial metric $\\gamma_{ij}$. In geodesic slicing, the lapse is fixed to $\\alpha = 1$, so the time coordinate $t$ is the proper time measured along the normal congruence of worldlines orthogonal to spatial slices.\n\nFor the Schwarzschild spacetime (vacuum, spherically symmetric, asymptotically flat with mass parameter $M$), there exists a horizon-penetrating form of the metric consistent with $\\alpha = 1$, namely the Painlevé–Gullstrand slicing. In this slicing, normal observers free-fall radially from rest at spatial infinity; their worldlines are timelike geodesics. We will use the properties of these radial geodesics to build a minimal model for focusing.\n\nStep 1: Radial geodesics in geodesic slicing with $\\alpha = 1$.\nConsider a radial timelike geodesic starting from rest at spatial infinity. In Schwarzschild spacetime, there is a conserved energy per unit mass $E$ along geodesics due to stationarity. For free fall from rest at infinity, $E = 1$. In a horizon-penetrating form adapted to these geodesics with $\\alpha = 1$, the coordinate time $t$ equals the proper time along the geodesic, because the normal observers are comoving with the geodesic congruence. For radial motion, the areal radius $r$ satisfies the geodesic equation, which, using $E = 1$ and spherical symmetry, implies the effective one-dimensional equation of motion\n$$\n\\frac{\\mathrm{d}r}{\\mathrm{d}t} = - \\sqrt{\\frac{2 M}{r}},\n$$\nwhere the negative sign corresponds to infall. This can be obtained by combining $E = -u_t$ and the normalization $u^\\mu u_\\mu = -1$ for the four-velocity $u^\\mu$, together with the fact that in the chosen slicing the time coordinate equals proper time along the geodesic congruence. The square root arises from the Newtonian-like effective potential for radial free fall in the Schwarzschild geometry, and the equality of coordinate and proper times here is a specific feature of geodesic slicing with $\\alpha = 1$ adapted to the congruence.\n\nThis ordinary differential equation is separable. Write\n$$\n\\frac{\\mathrm{d}r}{\\mathrm{d}t} = - \\sqrt{2 M} \\, r^{-1/2}.\n$$\nMultiply both sides by $r^{1/2}$:\n$$\nr^{1/2} \\, \\mathrm{d}r = - \\sqrt{2 M} \\, \\mathrm{d}t.\n$$\nNote that\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\left( r^{3/2} \\right) = \\frac{3}{2} r^{1/2} \\frac{\\mathrm{d}r}{\\mathrm{d}t}.\n$$\nHence,\n$$\n\\frac{2}{3} \\frac{\\mathrm{d}}{\\mathrm{d}t}\\left( r^{3/2} \\right) = - \\sqrt{2 M}.\n$$\nIntegrating from $t = 0$ with $r(0) = r_0$ to some $t \\ge 0$:\n$$\n\\frac{2}{3} \\left[ r(t)^{3/2} - r_0^{3/2} \\right] = - \\sqrt{2 M} \\, t.\n$$\nRearrange to obtain\n$$\nr(t)^{3/2} = r_0^{3/2} - \\frac{3}{2} \\sqrt{2 M} \\, t,\n$$\nand thus the explicit solution\n$$\nr(t; r_0, M) = \\left( r_0^{3/2} - \\frac{3}{2} \\sqrt{2 M} \\, t \\right)^{2/3}.\n$$\nThis solution is valid until the parenthesis becomes zero. The finite time at which $r$ reaches zero is the singularity-hitting time\n$$\nt_{\\mathrm{sing}}(r_0, M) = \\frac{2}{3} \\frac{r_0^{3/2}}{\\sqrt{2 M}}.\n$$\nFor $t \\ge t_{\\mathrm{sing}}$, the formula yields a non-real or non-physical value; physically, the congruence reaches the singularity. In our model we will take $r(t) = 0$ for $t \\ge t_{\\mathrm{sing}}$.\n\nStep 2: Focusing quantified by a comoving volume scaling factor.\nConsider a congruence of these radial geodesics labeled by their initial areal radius $r_0$. The mapping $r_0 \\mapsto r(t;r_0, M)$ at fixed $t$ has Jacobian\n$$\nJ(t; r_0, M) = \\frac{\\partial r(t; r_0, M)}{\\partial r_0}.\n$$\nFrom the explicit solution,\n$$\nr(t) = \\left( r_0^{3/2} - A t \\right)^{2/3}, \\quad \\text{with } A \\equiv \\frac{3}{2} \\sqrt{2 M}.\n$$\nDifferentiate with respect to $r_0$:\n$$\nJ(t; r_0, M) = \\frac{2}{3} \\left( r_0^{3/2} - A t \\right)^{-1/3} \\cdot \\frac{3}{2} r_0^{1/2} = r_0^{1/2} \\left( r_0^{3/2} - A t \\right)^{-1/3}.\n$$\nIn spherical symmetry, the proper volume of a thin shell at areal radius $r$ with thickness $\\mathrm{d}r$ scales as $4 \\pi r^2 \\mathrm{d}r$. A comoving shell labeled by thickness $\\mathrm{d}r_0$ therefore has volume proportional to $r^2 J \\, \\mathrm{d}r_0$. Relative to the initial volume proportional to $r_0^2 \\mathrm{d}r_0$, the comoving volume scaling factor is\n$$\nS(t; r_0, M) = \\frac{r(t; r_0, M)^2 \\, J(t; r_0, M)}{r_0^2}.\n$$\nSubstitute the expressions for $r(t)$ and $J$:\n$$\nS(t; r_0, M) = \\frac{\\left( r_0^{3/2} - A t \\right)^{4/3} \\cdot r_0^{1/2} \\left( r_0^{3/2} - A t \\right)^{-1/3}}{r_0^2}\n= \\frac{r_0^{1/2}}{r_0^2} \\left( r_0^{3/2} - A t \\right)\n= r_0^{-3/2} \\left( r_0^{3/2} - A t \\right).\n$$\nThis simplifies to\n$$\nS(t; r_0, M) = 1 - \\frac{A t}{r_0^{3/2}} = 1 - \\frac{\\tfrac{3}{2} \\sqrt{2 M} \\, t}{r_0^{3/2}}.\n$$\nThis expression is linear in $t$, starts at $S(0; r_0, M) = 1$, and reaches zero at exactly the singularity time $t_{\\mathrm{sing}}(r_0, M) = \\dfrac{2}{3} \\dfrac{r_0^{3/2}}{\\sqrt{2 M}}$. For $t \\ge t_{\\mathrm{sing}}$, we set $S = 0$ in our model to reflect the collapse of the comoving shell volume at the singularity.\n\nStep 3: Algorithm and numerical considerations.\nGiven $(M, r_0, t)$ with $M > 0$, $r_0 > 0$, and $t \\ge 0$:\n- Compute $A = \\dfrac{3}{2} \\sqrt{2 M}$.\n- Compute $t_{\\mathrm{sing}} = \\dfrac{2}{3} \\dfrac{r_0^{3/2}}{\\sqrt{2 M}}$.\n- If $t \\ge t_{\\mathrm{sing}}$, set $r = 0$ and $S = 0$.\n- Else, compute $r = \\left( r_0^{3/2} - A t \\right)^{2/3}$ and $S = 1 - \\dfrac{A t}{r_0^{3/2}}$.\n\nAll quantities are in geometrized units with $G = c = 1$. Radii and times have the same units as $M$ (for example, multiples of $M$). The output is requested as floats. No angles are involved.\n\nTest suite coverage rationale:\n- Test $1$ $(M, r_0, t) = (1.0, 10.0, 1.0)$: a generic “happy path” case far from the singularity.\n- Test $2$ $(M, r_0, t) = (1.0, 4.0, \\tfrac{1}{2} t_{\\mathrm{sing}})$: checks the exact mid-point scaling $S = \\tfrac{1}{2}$.\n- Test $3$ $(M, r_0, t) = (1.0, 2.0, 0.99 \\, t_{\\mathrm{sing}})$: near-singularity behavior with $S \\approx 0.01$ and small $r$.\n- Test $4$ $(M, r_0, t) = (1.0, 3.0, 1.5 \\, t_{\\mathrm{sing}})$: beyond the singularity time where the model prescribes $(r, S) = (0, 0)$.\n- Test $5$ $(M, r_0, t) = (2.0, 100.0, 1.0)$: large radius and larger mass to verify weak focusing over short times.\n\nThe final program implements these formulas directly and prints a single line with the concatenated results as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef singularity_time(M: float, r0: float) -> float:\n    \"\"\"\n    Compute t_sing = (2/3) * r0^(3/2) / sqrt(2M) in geometrized units (G=c=1).\n    \"\"\"\n    return (2.0 / 3.0) * (r0 ** 1.5) / np.sqrt(2.0 * M)\n\ndef evolve_geodesic_geodesic_slicing(M: float, r0: float, t: float) -> tuple[float, float]:\n    \"\"\"\n    Geodesic slicing (alpha=1) radial free-fall in Schwarzschild (Painleve-Gullstrand congruence).\n    Given M, initial areal radius r0, and time t >= 0, return:\n      r(t) = max( (r0^(3/2) - (3/2)*sqrt(2M)*t)^(2/3), 0 )\n      S(t) = max( 1 - ((3/2)*sqrt(2M)*t)/r0^(3/2), 0 )\n    \"\"\"\n    # Guard for physical domain\n    if M <= 0.0 or r0 <= 0.0 or t < 0.0:\n        # For robustness, return NaNs if parameters are unphysical\n        return (float('nan'), float('nan'))\n\n    A = 1.5 * np.sqrt(2.0 * M)\n    tsing = singularity_time(M, r0)\n\n    if t >= tsing:\n        return (0.0, 0.0)\n\n    # Compute r(t) and S(t)\n    parent = r0 ** 1.5 - A * t\n    # Numerical safety: parent should be positive here\n    parent = max(parent, 0.0)\n    r_t = parent ** (2.0 / 3.0)\n    S_t = 1.0 - (A * t) / (r0 ** 1.5)\n    # Clip small negative due to roundoff\n    if S_t < 0.0 and S_t > -1e-14:\n        S_t = 0.0\n    return (r_t, S_t)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is (M, r0, t)\n    tests = []\n    # Test 1: (1.0, 10.0, 1.0)\n    tests.append((1.0, 10.0, 1.0))\n    # Test 2: (1.0, 4.0, 0.5 * t_sing(4.0, 1.0))\n    M2, r02 = 1.0, 4.0\n    t2 = 0.5 * singularity_time(M2, r02)\n    tests.append((M2, r02, t2))\n    # Test 3: (1.0, 2.0, 0.99 * t_sing(2.0, 1.0))\n    M3, r03 = 1.0, 2.0\n    t3 = 0.99 * singularity_time(M3, r03)\n    tests.append((M3, r03, t3))\n    # Test 4: (1.0, 3.0, 1.5 * t_sing(3.0, 1.0))\n    M4, r04 = 1.0, 3.0\n    t4 = 1.5 * singularity_time(M4, r04)\n    tests.append((M4, r04, t4))\n    # Test 5: (2.0, 100.0, 1.0)\n    tests.append((2.0, 100.0, 1.0))\n\n    results = []\n    for (M, r0, t) in tests:\n        r_t, S_t = evolve_geodesic_geodesic_slicing(M, r0, t)\n        results.append(r_t)\n        results.append(S_t)\n\n    # Final print statement in the exact required format.\n    # Ensure standard decimal representation\n    formatted = \",\".join(f\"{x:.12g}\" for x in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2370126"}]}