{"hands_on_practices": [{"introduction": "Before tackling complex fluid dynamics, we must first master the concept of numerical stability. This practice guides you through a hands-on exploration of the celebrated Courant–Friedrichs–Lewy (CFL) condition, a fundamental principle governing explicit numerical schemes for time-dependent problems [@problem_id:2381376]. By simulating the simple one-dimensional wave equation at, below, and above the stability limit, you will directly observe the dramatic consequences of an unstable scheme and gain a crucial intuition for why the time step in a simulation cannot be chosen arbitrarily.", "problem": "You will investigate numerical stability of an explicit finite-volume solver for the one-dimensional linear advection equation, using the Courant-Friedrichs-Lewy (CFL) condition as the organizing principle. Start from the conservation-law form of linear advection,\n$$\n\\frac{\\partial q}{\\partial t} + \\frac{\\partial f}{\\partial x} = 0,\\quad f = a\\,q,\n$$\nwhere $q(x,t)$ is a scalar field and $a$ is a constant advection speed. Use the following physically consistent setup: the spatial domain is periodic with length $L$ in meters, the advection speed $a$ is in meters per second, and time $t$ is in seconds. The exact solution for smooth initial data is the constant-speed translation\n$$\nq(x,t) = q_0(x - a\\,t) \\quad \\text{on the periodic domain}.\n$$\nYour tasks are:\n- From the conservation form and explicit time advance, derive a first-order upwind finite-volume method appropriate for $a > 0$ on a uniform grid. Do not use any pre-derived discrete update expressions; start from the definition of the numerical flux and the finite-volume update for a cell average.\n- Using discrete Fourier (von Neumann) analysis on the derived scheme, obtain the stability restriction on the nondimensional Courant number $C$, where\n$$\nC = \\frac{|a|\\,\\Delta t}{\\Delta x}.\n$$\n- Implement the derived method with periodic boundary conditions and advance an initial condition to a prescribed final time. Use a uniform mesh with $N$ cells and $\\Delta x = L/N$, and a constant time step $\\Delta t$ chosen from a target Courant number $C$ via $\\Delta t = C\\,\\Delta x/a$. For each run, use an integer number of time steps $n_{\\text{steps}}$, so that the final time is $T = n_{\\text{steps}}\\,\\Delta t$.\n- Use the smooth, periodic Gaussian initial condition of unit amplitude centered at $x_0$ with width $\\sigma$,\n$$\nq_0(x) = \\exp\\!\\left(-\\frac{d(x,x_0)^2}{2\\,\\sigma^2}\\right),\n$$\nwhere $d(x,x_0)$ is the shortest periodic distance on the interval $[0,L)$.\n- To assess stability numerically, declare a run unstable if at any time step the absolute value of any cell average exceeds a threshold equal to $M$ times the initial maximum amplitude, where $M$ is a fixed factor. Otherwise, declare the run stable. Quantify the accuracy at the final time by the relative discrete $\\ell^2$ error with respect to the exact solution on the grid,\n$$\n\\varepsilon = \\frac{\\left\\| q^{n_{\\text{steps}}} - q_{\\text{exact}}(\\cdot,T)\\right\\|_2}{\\left\\| q_{\\text{exact}}(\\cdot,T) \\right\\|_2},\n$$\nwhere $\\|\\cdot\\|_2$ is the Euclidean norm over grid point values. For an unstable run, report a large sentinel error value $E_{\\text{sentinel}}$.\n\nImplement a program that performs exactly the following test suite, returning for each case a list containing a boolean stability flag and the error $\\varepsilon$ (or the sentinel value if unstable):\n\n- Case A (below the stability limit): $L = 1.0$ meters, $a = 1.0$ meters per second, $N = 100$, $x_0 = 0.25$ meters, $\\sigma = 0.05$ meters, $C = 0.5$, $n_{\\text{steps}} = 200$, $M = 10$, $E_{\\text{sentinel}} = 10^{9}$.\n- Case B (at the stability limit): $L = 1.0$ meters, $a = 1.0$ meters per second, $N = 100$, $x_0 = 0.25$ meters, $\\sigma = 0.05$ meters, $C = 1.0$, $n_{\\text{steps}} = 100$, $M = 10$, $E_{\\text{sentinel}} = 10^{9}$.\n- Case C (above the stability limit): $L = 1.0$ meters, $a = 1.0$ meters per second, $N = 100$, $x_0 = 0.25$ meters, $\\sigma = 0.05$ meters, $C = 1.1$, $n_{\\text{steps}} = 50$, $M = 10$, $E_{\\text{sentinel}} = 10^{9}$.\n\nAngle units are not used in this problem. Ensure that the program uses meters and seconds consistently for all dimensional inputs as stated above. The final output must be a single line containing a list of the three results, each result itself being a list of the form $[\\text{stable}, \\varepsilon]$, in the exact order A, B, C. For example, the format must be\n$$\n\\big[\\,[\\text{True},\\,0.0123],[\\text{True},\\,0.0],[\\text{False},\\,1000000000.0]\\,\\big],\n$$\nwith boolean values for stability and floating-point values for errors. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.", "solution": "The problem as stated is subjected to validation.\n\n### Step 1: Extract Givens\n\nThe governing partial differential equation is the one-dimensional linear advection equation in conservation form:\n$$\n\\frac{\\partial q}{\\partial t} + \\frac{\\partial f}{\\partial x} = 0\n$$\nwith flux $f = a\\,q$, where $a$ is a constant advection speed.\n\nThe domain is periodic with length $L$.\nThe initial condition is a smooth Gaussian profile:\n$$\nq_0(x) = \\exp\\!\\left(-\\frac{d(x,x_0)^2}{2\\,\\sigma^2}\\right)\n$$\nwhere $d(x,x_0)$ is the shortest periodic distance on $[0,L)$.\nThe exact solution for smooth initial data is $q(x,t) = q_0(x - a\\,t)$.\n\nNumerical parameters are defined as follows:\n- Number of uniform grid cells: $N$\n- Cell width: $\\Delta x = L/N$\n- Courant number: $C = \\frac{|a|\\,\\Delta t}{\\Delta x}$\n- Time step: $\\Delta t = C\\,\\Delta x/a$ (for $a>0$)\n- Number of time steps: $n_{\\text{steps}}$\n- Final time: $T = n_{\\text{steps}}\\,\\Delta t$\n\nStability and accuracy metrics are:\n- Stability threshold factor: $M$\n- A run is declared unstable if $\\max(|q|) > M \\times \\max(|q_0|)$ at any time.\n- Sentinel error for unstable runs: $E_{\\text{sentinel}}$\n- Relative discrete $\\ell^2$ error: $\\varepsilon = \\frac{\\left\\| q^{n_{\\text{steps}}} - q_{\\text{exact}}(\\cdot,T)\\right\\|_2}{\\left\\| q_{\\text{exact}}(\\cdot,T) \\right\\|_2}$\n\nTest cases:\n- Case A: $L = 1.0$, $a = 1.0$, $N = 100$, $x_0 = 0.25$, $\\sigma = 0.05$, $C = 0.5$, $n_{\\text{steps}} = 200$, $M = 10$, $E_{\\text{sentinel}} = 10^{9}$.\n- Case B: $L = 1.0$, $a = 1.0$, $N = 100$, $x_0 = 0.25$, $\\sigma = 0.05$, $C = 1.0$, $n_{\\text{steps}} = 100$, $M = 10$, $E_{\\text{sentinel}} = 10^{9}$.\n- Case C: $L = 1.0$, $a = 1.0$, $N = 100$, $x_0 = 0.25$, $\\sigma = 0.05$, $C = 1.1$, $n_{\\text{steps}} = 50$, $M = 10$, $E_{\\text{sentinel}} = 10^{9}$.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded:** The problem is based on the linear advection equation, the finite-volume method, and von Neumann stability analysis. These are fundamental, well-established concepts in computational physics and applied mathematics. The problem is scientifically sound.\n- **Well-Posed:** The problem statement is clear, and all necessary parameters and conditions are provided for each case. The tasks—derivation, analysis, and implementation—are unambiguously defined, leading to a unique and meaningful result.\n- **Objective:** The problem is formulated in precise, objective language. There are no subjective or opinion-based statements.\n- **Completeness and Consistency:** The problem is self-contained. All variables and constants are defined, and the test cases are fully specified. The physical units (meters, seconds) are consistent throughout.\n\n### Step 3: Verdict and Action\n\nThe problem is valid. It is a standard, well-posed exercise in numerical methods for partial differential equations. A full solution will be provided.\n\n### Derivation of the First-Order Upwind Finite-Volume Method\n\nWe begin with the integral form of the conservation law over a control volume, or cell, $I_i = [x_{i-1/2}, x_{i+1/2}]$, where the cell center is $x_i$ and the cell width is $\\Delta x = x_{i+1/2} - x_{i-1/2}$. Integrating the PDE over this cell gives:\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial q}{\\partial t} dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial f}{\\partial x} dx = 0\n$$\nApplying Leibniz integral rule and the fundamental theorem of calculus, we obtain:\n$$\n\\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} q(x,t) dx + \\left[ f(q(x_{i+1/2},t)) - f(q(x_{i-1/2},t)) \\right] = 0\n$$\nWe define the cell average of $q$ over cell $i$ at time $t$ as:\n$$\n\\bar{q}_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} q(x,t) dx\n$$\nSubstituting this definition into the integrated equation yields an exact ordinary differential equation for the cell average $\\bar{q}_i(t)$:\n$$\n\\frac{d\\bar{q}_i}{dt} = -\\frac{1}{\\Delta x} \\left[ f(q(x_{i+1/2},t)) - f(q(x_{i-1/2},t)) \\right]\n$$\nTo obtain a numerical scheme, we discretize in time using the forward Euler method and approximate the point values of the flux $f$ at the cell interfaces. Let $\\bar{q}_i^n \\approx \\bar{q}_i(t^n)$ where $t^n = n\\Delta t$. The time derivative is approximated as $\\frac{d\\bar{q}_i}{dt} \\approx \\frac{\\bar{q}_i^{n+1} - \\bar{q}_i^n}{\\Delta t}$.\nThe interface fluxes are approximated by a numerical flux function $F$, which depends on the states of the neighboring cells at time $t^n$. The equation becomes:\n$$\n\\frac{\\bar{q}_i^{n+1} - \\bar{q}_i^n}{\\Delta t} = -\\frac{1}{\\Delta x} \\left[ F_{i+1/2} - F_{i-1/2} \\right]\n$$\nwhere $F_{i+1/2}$ is the numerical flux at the interface $x_{i+1/2}$. This can be rewritten as the finite-volume update formula:\n$$\n\\bar{q}_i^{n+1} = \\bar{q}_i^n - \\frac{\\Delta t}{\\Delta x} \\left[ F_{i+1/2} - F_{i-1/2} \\right]\n$$\nFor the first-order upwind scheme, the numerical flux is determined by the direction of information propagation, which is given by the sign of the advection speed $a$. The problem specifies $a > 0$, so information propagates from left to right. The flux at an interface should be determined by the state in the \"upwind\" cell, which is the cell to the left.\nTherefore, the flux at the right interface of cell $i$, $x_{i+1/2}$, is determined by the state in cell $i$:\n$$\nF_{i+1/2} = f(\\bar{q}_i^n) = a \\bar{q}_i^n\n$$\nSimilarly, the flux at the left interface of cell $i$, $x_{i-1/2}$, is determined by the state in cell $i-1$:\n$$\nF_{i-1/2} = f(\\bar{q}_{i-1}^n) = a \\bar{q}_{i-1}^n\n$$\nSubstituting these numerical fluxes into the update formula, we obtain the first-order upwind scheme for $a > 0$:\n$$\n\\bar{q}_i^{n+1} = \\bar{q}_i^n - \\frac{\\Delta t}{\\Delta x} (a \\bar{q}_i^n - a \\bar{q}_{i-1}^n)\n$$\nAs per the problem definition, we introduce the nondimensional Courant number $C = \\frac{a \\Delta t}{\\Delta x}$ (since $a>0$, $|a|=a$). The final scheme is:\n$$\n\\bar{q}_i^{n+1} = \\bar{q}_i^n - C (\\bar{q}_i^n - \\bar{q}_{i-1}^n)\n$$\n\n### Von Neumann Stability Analysis\n\nTo analyze the stability of the derived scheme, we employ discrete Fourier (von Neumann) analysis. We consider a single Fourier mode for the solution on the grid:\n$$\n\\bar{q}_j^n = \\hat{q}^n e^{i k x_j} = \\hat{q}^n e^{i k j \\Delta x}\n$$\nwhere $\\hat{q}^n$ is the complex amplitude of the mode at time step $n$, $k$ is the wavenumber, and $i = \\sqrt{-1}$. Substituting this ansatz into the numerical scheme:\n$$\n\\hat{q}^{n+1} e^{i k j \\Delta x} = \\hat{q}^n e^{i k j \\Delta x} - C \\left( \\hat{q}^n e^{i k j \\Delta x} - \\hat{q}^n e^{i k (j-1) \\Delta x} \\right)\n$$\nWe define the amplification factor $G(k) = \\frac{\\hat{q}^{n+1}}{\\hat{q}^n}$. Dividing the equation by $\\hat{q}^n e^{i k j \\Delta x}$ yields:\n$$\nG(k) = 1 - C \\left( 1 - e^{-i k \\Delta x} \\right)\n$$\nLet $\\theta = k \\Delta x$ be the nondimensional wavenumber. The amplification factor is a function of $\\theta$:\n$$\nG(\\theta) = 1 - C (1 - e^{-i\\theta}) = 1 - C (1 - (\\cos\\theta - i\\sin\\theta)) = (1 - C + C\\cos\\theta) + i(C\\sin\\theta)\n$$\nFor the scheme to be stable, the magnitude of the amplification factor must not exceed unity for all possible values of $\\theta$, i.e., $|G(\\theta)| \\le 1$. We analyze its magnitude squared:\n$$\n|G(\\theta)|^2 = (1 - C + C\\cos\\theta)^2 + (C\\sin\\theta)^2\n$$\n$$\n|G(\\theta)|^2 = (1-C)^2 + 2C(1-C)\\cos\\theta + C^2\\cos^2\\theta + C^2\\sin^2\\theta\n$$\n$$\n|G(\\theta)|^2 = 1 - 2C + C^2 + 2C(1-C)\\cos\\theta + C^2 = 1 - 2C + 2C^2 + (2C-2C^2)\\cos\\theta\n$$\n$$\n|G(\\theta)|^2 = 1 - 2C(1-C) + 2C(1-C)\\cos\\theta = 1 - 2C(1-C)(1-\\cos\\theta)\n$$\nThe stability condition $|G(\\theta)|^2 \\le 1$ implies:\n$$\n1 - 2C(1-C)(1-\\cos\\theta) \\le 1 \\implies -2C(1-C)(1-\\cos\\theta) \\le 0\n$$\nSince $\\theta$ is real, the term $(1-\\cos\\theta)$ is always non-negative, ranging from $0$ to $2$. Thus, stability requires:\n$$\nC(1-C) \\ge 0\n$$\nGiven that the Courant number $C = \\frac{a \\Delta t}{\\Delta x}$ is non-negative (as $a>0, \\Delta t>0, \\Delta x>0$), this inequality is satisfied for:\n$$\n0 \\le C \\le 1\n$$\nThis is the Courant-Friedrichs-Lewy (CFL) stability condition for the first-order upwind scheme.\n\n### Numerical Implementation Strategy\n\nThe derived scheme is implemented on a uniform periodic grid.\n1.  **Grid and Parameters**: For a domain of length $L$ with $N$ cells, the cell width is $\\Delta x = L/N$. The grid points representing cell centers are $x_j = j \\Delta x$ for $j=0, 1, \\dots, N-1$.\n2.  **Initial Condition**: The initial state vector $q^0$ is populated with values $q_j^0 = q_0(x_j)$. The periodic distance function $d(x_1, x_2)$ on a domain of length $L$ is computed as $d(x_1, x_2) = \\min(|x_1-x_2|, L - |x_1-x_2|)$. The initial maximum amplitude is $\\max(|q_0|) = 1$ by construction.\n3.  **Time Stepping**: The time step $\\Delta t$ is calculated from the specified Courant number $C$ as $\\Delta t = C \\Delta x / a$. The simulation runs for a fixed number of steps, $n_{\\text{steps}}$.\n4.  **Update Step**: The update equation $\\bar{q}_i^{n+1} = \\bar{q}_i^n - C (\\bar{q}_i^n - \\bar{q}_{i-1}^n)$ is applied to all cells $i=0, \\dots, N-1$. The term $\\bar{q}_{i-1}^n$ for cell $i=0$ is $\\bar{q}_{N-1}^n$ due to periodic boundary conditions. This is efficiently implemented using a circular shift (`numpy.roll`).\n5.  **Stability Check**: At each time step $n$, before the update, the condition $\\max(|\\bar{q}^n|) \\le M \\times 1.0$ is checked. If violated, the run is flagged as unstable, and the simulation for that case terminates.\n6.  **Error Calculation**: If the simulation completes all $n_{\\text{steps}}$ without violating the stability criterion, it is flagged as stable. The final numerical solution is $q^{n_{\\text{steps}}}$. The exact solution at the final time $T=n_{\\text{steps}}\\Delta t$ is $q_{exact}(x,T) = q_0(x-aT)$. This is computed by evaluating the initial profile at grid points shifted by $-aT$. The final center of the Gaussian is $x_{0,final} = (x_0 + aT) \\pmod L$. The exact solution on the grid is then $q_{exact,j} = \\exp(-d(x_j, x_{0,final})^2 / (2\\sigma^2))$. The relative $\\ell^2$ error $\\varepsilon$ is then computed. For unstable runs, $\\varepsilon$ is set to $E_{\\text{sentinel}}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection problem for three test cases\n    to investigate numerical stability of the first-order upwind scheme.\n    \"\"\"\n    \n    test_cases = [\n        # Case A: C = 0.5 (stable)\n        {'L': 1.0, 'a': 1.0, 'N': 100, 'x0': 0.25, 'sigma': 0.05, \n         'C': 0.5, 'n_steps': 200, 'M': 10, 'E_sentinel': 1e9},\n        # Case B: C = 1.0 (marginally stable, exact shift)\n        {'L': 1.0, 'a': 1.0, 'N': 100, 'x0': 0.25, 'sigma': 0.05, \n         'C': 1.0, 'n_steps': 100, 'M': 10, 'E_sentinel': 1e9},\n        # Case C: C = 1.1 (unstable)\n        {'L': 1.0, 'a': 1.0, 'N': 100, 'x0': 0.25, 'sigma': 0.05, \n         'C': 1.1, 'n_steps': 50, 'M': 10, 'E_sentinel': 1e9},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack parameters\n        L = case['L']\n        a = case['a']\n        N = case['N']\n        x0 = case['x0']\n        sigma = case['sigma']\n        C = case['C']\n        n_steps = case['n_steps']\n        M = case['M']\n        E_sentinel = case['E_sentinel']\n\n        # Grid setup\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False) # Grid points for cell centers\n\n        # Time step calculation\n        dt = C * dx / a\n        T_final = n_steps * dt\n\n        # Helper for periodic distance\n        def periodic_distance(x1, x2, domain_length):\n            diff = np.abs(x1 - x2)\n            return np.minimum(diff, domain_length - diff)\n\n        # Initial condition\n        q = np.exp(-periodic_distance(x, x0, L)**2 / (2 * sigma**2))\n        \n        # Initial maximum amplitude is 1.0 by definition of the Gaussian\n        initial_max_q = 1.0\n        stability_threshold = M * initial_max_q\n\n        is_stable = True\n        # Time-stepping loop\n        for _ in range(n_steps):\n            if np.max(np.abs(q)) > stability_threshold:\n                is_stable = False\n                break\n            \n            # Copy of current state for the update\n            q_n = q.copy()\n            \n            # First-order upwind scheme (for a > 0)\n            # q_i^{n+1} = q_i^n - C * (q_i^n - q_{i-1}^n)\n            # np.roll(q_n, 1) provides q_{i-1} with periodic boundaries\n            q = q_n - C * (q_n - np.roll(q_n, 1))\n\n        # Final error calculation\n        if not is_stable:\n             # Check one last time after the final step for cases that blow up on the last step\n            if np.max(np.abs(q)) > stability_threshold:\n                 error = E_sentinel\n            else: # Should not happen if loop broke, but as a safeguard\n                is_stable = True # If it did not actually exceed threshold\n\n        if is_stable:\n            # Exact solution at T_final\n            x_center_final = (x0 + a * T_final) % L\n            q_exact = np.exp(-periodic_distance(x, x_center_final, L)**2 / (2 * sigma**2))\n            \n            # Calculate relative L2 error\n            norm_diff = np.linalg.norm(q - q_exact)\n            norm_exact = np.linalg.norm(q_exact)\n            \n            if norm_exact > 0:\n                error = norm_diff / norm_exact\n            else:\n                error = norm_diff # Should not happen for a Gaussian\n        else:\n            error = E_sentinel\n\n        results.append([is_stable, error])\n\n    # Final print statement in the exact required format\n    # The default str representation of a list in Python is '[item1, item2, ...]'\n    # which matches the required format including the space after the comma.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2381376"}, {"introduction": "Having grasped the importance of stability, we now turn to a more physically rich problem: the viscous Burgers' equation [@problem_id:2381332]. This celebrated equation provides a simplified model for the full Navier–Stokes equations, capturing the essential interplay between nonlinear wave steepening from the convective term $u u_x$ and smoothing from the viscous term $\\nu u_{xx}$. By implementing a solver for this problem, you will learn to handle both convective and diffusive terms, each with its own stability constraint, and visually confirm how viscosity acts to smooth sharp gradients.", "problem": "Consider the viscous one-dimensional Burgers' equation, a canonical model for convection-diffusion dynamics in computational fluid dynamics fundamentals within computational physics:\n$$\nu_t + u\\,u_x = \\nu\\,u_{xx},\n$$\nposed on a finite one-dimensional domain with fixed boundary states. Start from the conservation-law viewpoint that balances a nonlinear convective flux with Fickian diffusion, and derive a stable semi-discrete method based on first principles: the rate of change of a field equals the negative divergence of its advective flux plus the diffusion term. Use this to design a fully discrete algorithm that approximates the time evolution of a shock-like initial profile and demonstrates how viscosity $\\,\\nu\\,$ smooths steep gradients.\n\nYour task is to write a complete, runnable program that:\n- Discretizes space uniformly on a domain $\\,x \\in [-L/2,\\,L/2]\\,$ with $\\,L = 2\\,$ using $\\,N_x\\,$ grid points with spacing $\\,\\Delta x\\,$.\n- Enforces fixed Dirichlet boundary conditions $\\,u(-L/2,t)=+1\\,$ and $\\,u(+L/2,t)=-1\\,$ for all $\\,t$.\n- Uses the smooth shock-like initial condition\n$$\nu(x,0) = -\\tanh\\!\\left(\\frac{x}{\\delta}\\right),\n$$\nwith $\\,\\delta > 0\\,$ controlling the initial thickness.\n- Advances in time to a specified final time $\\,T\\,$ using an explicit method. Choose a time step $\\,\\Delta t\\,$ at each step to satisfy a stability restriction that accounts for both convection and diffusion. Specifically, enforce\n$$\n\\Delta t \\le C \\,\\min\\!\\left(\\frac{\\Delta x}{\\max_x |u|},\\,\\frac{\\Delta x^2}{2\\nu}\\right),\n$$\nwhere $\\,C \\in (0,1)\\,$ is a Courant–Friedrichs–Lewy (CFL) safety factor.\n- Approximates the convective derivative $\\,u\\,u_x\\,$ with a monotone, first-order upwind difference based on the local sign of $\\,u\\,$, and approximates the diffusive term $\\,u_{xx}\\,$ with a centered second-order difference, both applied to interior points. Keep boundary values fixed at each time level.\n\nFor each test case, after evolving to time $\\,T\\,$, compute the single scalar diagnostic\n$$\nG(T) = \\max_{x \\,\\text{on grid interior}} \\left| \\frac{\\partial u}{\\partial x}(x,T) \\right|,\n$$\napproximating the spatial derivative on interior points using a centered difference. Report $\\,G(T)\\,$ as a floating-point number rounded to $\\,6\\,$ decimal places. Larger $\\,G(T)\\,$ indicates a steeper profile; smaller $\\,G(T)\\,$ indicates stronger smoothing.\n\nAll quantities are dimensionless, so no physical units are required.\n\nImplement your solver to handle the following test suite of parameters, each specified as a tuple $\\,( \\nu,\\, T,\\, N_x,\\, \\delta,\\, C )\\,$:\n- Case $1$: $\\,(0.01,\\,0.2,\\,401,\\,0.05,\\,0.4)$\n- Case $2$: $\\,(0.001,\\,0.2,\\,401,\\,0.05,\\,0.4)$\n- Case $3$: $\\,(0.05,\\,0.2,\\,401,\\,0.05,\\,0.4)$\n- Case $4$ (edge case, no evolution): $\\,(0.01,\\,0.0,\\,401,\\,0.05,\\,0.4)$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where $\\,r_k = G(T)\\,$ for case $\\,k\\,$, each rounded to $\\,6\\,$ decimal places.", "solution": "The problem statement is scientifically sound and well-posed. It presents a standard problem in computational fluid dynamics: the numerical solution of the one-dimensional viscous Burgers' equation. All parameters, conditions, and numerical schemes are clearly defined, permitting a unique and verifiable solution. We proceed with the derivation and implementation of the specified algorithm.\n\nThe problem requires solving the viscous Burgers' equation,\n$$\n\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n$$\non a domain $x \\in [-L/2, L/2]$ with $L=2$. This equation is a fundamental model for phenomena where both nonlinear convection and viscous diffusion are present.\n\nThe governing equation can be interpreted from first principles, as requested. In one dimension, the conservation law for a quantity $u$ with flux $J$ is $\\frac{\\partial u}{\\partial t} + \\frac{\\partial J}{\\partial x} = 0$. The total flux $J$ is composed of an advective part and a diffusive part. The advective flux is given by the flow of the quantity with itself, which is described by the flux function $F(u) = \\frac{1}{2}u^2$. The diffusive flux is modeled by Fick's law, $q = -\\nu \\frac{\\partial u}{\\partial x}$. The total flux is thus $J = F(u) + q = \\frac{1}{2}u^2 - \\nu \\frac{\\partial u}{\\partial x}$. Substituting this into the conservation law gives\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x} \\left( \\frac{1}{2}u^2 - \\nu \\frac{\\partial u}{\\partial x} \\right) = 0\n$$\nApplying the chain rule, $\\frac{\\partial}{\\partial x}(\\frac{1}{2}u^2) = u \\frac{\\partial u}{\\partial x}$, and assuming viscosity $\\nu$ is constant, we recover the original form of the equation: $\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}$. This confirms the problem statement's basis in conservation principles. The term $u_t$ is the rate of change, $-u u_x$ is the negative divergence of the advective flux, and $\\nu u_{xx}$ is the diffusion term.\n\nWe develop a numerical solution using a finite difference method. The domain is discretized into $N_x$ equally spaced points $x_j = -L/2 + j \\cdot \\Delta x$ for $j=0, 1, \\dots, N_x-1$, with grid spacing $\\Delta x = L/(N_x-1)$. Let $u_j^n$ denote the numerical approximation of $u(x_j, t_n)$.\n\nThe semi-discrete form of the equation for an interior grid point $j$ is\n$$\n\\frac{d u_j}{d t} = - \\left(u \\frac{\\partial u}{\\partial x}\\right)_j + \\nu \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_j\n$$\n\nThe spatial derivatives are approximated as specified:\n1.  **Convective Term**: A first-order upwind scheme is used for the term $u \\frac{\\partial u}{\\partial x}$. The choice of difference stencil depends on the sign of the local velocity $u_j$. If $u_j > 0$, information propagates from left to right, so a backward difference is used. If $u_j  0$, information propagates from right to left, requiring a forward difference.\n    $$\n    \\left(u \\frac{\\partial u}{\\partial x}\\right)_j \\approx\n    \\begin{cases}\n    u_j \\frac{u_j - u_{j-1}}{\\Delta x}  \\text{if } u_j > 0 \\\\\n    u_j \\frac{u_{j+1} - u_j}{\\Delta x}  \\text{if } u_j \\le 0\n    \\end{cases}\n    $$\n    This scheme introduces numerical diffusion, which helps stabilize the solution in the presence of sharp gradients (shocks), making it a monotone scheme.\n\n2.  **Diffusive Term**: A second-order central difference is used for the viscous term $\\frac{\\partial^2 u}{\\partial x^2}$.\n    $$\n    \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_j \\approx \\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}\n    $$\n\nCombining these, the semi-discrete equation for interior points ($j=1, \\dots, N_x-2$) becomes:\n$$\n\\frac{d u_j}{d t} = -\\left( \\begin{cases} u_j \\frac{u_j - u_{j-1}}{\\Delta x}  \\text{if } u_j > 0 \\\\ u_j \\frac{u_{j+1} - u_j}{\\Delta x}  \\text{if } u_j \\le 0 \\end{cases} \\right) + \\nu \\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}\n$$\n\nFor time integration, an explicit forward Euler method is employed. The solution at time step $n+1$ is calculated from the solution at step $n$:\n$$\nu_j^{n+1} = u_j^n + \\Delta t_n \\cdot \\left(\\frac{du_j}{dt}\\right)^n\n$$\nwhere $\\Delta t_n$ is the time step size at step $n$. The stability of this explicit scheme is contingent on the time step satisfying the Courant–Friedrichs–Lewy (CFL) condition. For a convection-diffusion equation, the condition combines constraints from both phenomena:\n$$\n\\Delta t_n \\le C \\cdot \\min\\left(\\frac{\\Delta x}{\\max_j |u_j^n|}, \\frac{\\Delta x^2}{2\\nu}\\right)\n$$\nwhere $C$ is a safety factor $(0  C  1)$. The first term in the minimum is the convective constraint, and the second is the diffusive constraint. An adaptive time step is calculated at each iteration to ensure stability.\n\nThe initial condition is a smooth shock-like profile:\n$$\nu(x,0) = -\\tanh(x/\\delta)\n$$\nThis is applied to the grid such that $u_j^0 = -\\tanh(x_j/\\delta)$. The boundary conditions are fixed (Dirichlet) for all time: $u(x_0, t) = u(-1, t) = +1$ and $u(x_{N_x-1}, t) = u(1, t) = -1$. In the discrete algorithm, these are enforced by setting $u_0^{n+1}=+1$ and $u_{N_x-1}^{n+1}=-1$ at every time level.\n\nThe overall algorithm proceeds as follows:\n1.  Initialize the solution vector $u^0$ from the initial condition. Enforce boundary values.\n2.  Set current time $t=0$.\n3.  Loop while $t  T$:\n    a. Calculate the maximum absolute velocity $\\max|u^n|$.\n    b. Compute the stable time step $\\Delta t_n$ using the CFL condition. Ensure $t + \\Delta t_n$ does not exceed $T$.\n    c. For all interior points $j=1, \\dots, N_x-2$, compute the right-hand side of the semi-discrete equation.\n    d. Update the interior points using the forward Euler step: $u_j^{n+1} = u_j^n + \\Delta t_n \\cdot (\\text{RHS})_j^n$.\n    e. The boundary values $u_0^{n+1}$ and $u_{N_x-1}^{n+1}$ remain fixed.\n    f. Advance time: $t \\leftarrow t + \\Delta t_n$.\n4.  Once $t=T$, the simulation is complete.\n\nFinally, the diagnostic metric $G(T)$ is computed. It is defined as the maximum absolute value of the spatial gradient on the grid interior at the final time $T$:\n$$\nG(T) = \\max_{j \\in \\{1, \\dots, N_x-2\\}} \\left| \\left(\\frac{\\partial u}{\\partial x}\\right)_j \\right|\n$$\nThe gradient is approximated using a second-order centered difference:\n$$\n\\left(\\frac{\\partial u}{\\partial x}\\right)_j \\approx \\frac{u_{j+1} - u_{j-1}}{2\\Delta x}\n$$\nThis metric quantifies the steepness of the profile, with larger values indicating a sharper \"shock.\"", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_burgers(nu, T, Nx, delta, C_cfl):\n    \"\"\"\n    Solves the 1D viscous Burgers' equation using a finite difference method.\n\n    Args:\n        nu (float): Viscosity coefficient.\n        T (float): Final time.\n        Nx (int): Number of grid points.\n        delta (float): Initial shock profile thickness parameter.\n        C_cfl (float): CFL safety factor.\n\n    Returns:\n        float: The diagnostic G(T) rounded to 6 decimal places.\n    \"\"\"\n    # 1. Setup the spatial grid and initial condition\n    L = 2.0\n    x = np.linspace(-L / 2.0, L / 2.0, Nx)\n    dx = L / (Nx - 1)\n\n    # Initial condition: u(x, 0) = -tanh(x / delta)\n    u = -np.tanh(x / delta)\n\n    # 2. Time evolution loop\n    t = 0.0\n    # The loop condition handles the T=0 case naturally.\n    while t  T:\n        # Enforce fixed Dirichlet boundary conditions at each step.\n        u[0] = 1.0\n        u[-1] = -1.0\n\n        # Calculate the adaptive time step based on the CFL condition.\n        umax = np.max(np.abs(u))\n        \n        # Convective time step constraint. Handle umax=0 to avoid division by zero.\n        if umax > 1e-12:\n            dt_conv = dx / umax\n        else:\n            dt_conv = float('inf')\n\n        # Diffusive time step constraint.\n        dt_diff = dx**2 / (2.0 * nu)\n        \n        # Determine the time step, ensuring not to step over the final time T.\n        dt = C_cfl * min(dt_conv, dt_diff)\n        if t + dt > T:\n            dt = T - t\n\n        # Store the current state to compute the RHS of the PDE.\n        u_old = u.copy()\n        \n        # Isolate interior points for vectorization.\n        u_interior = u_old[1:-1]\n\n        # Calculate convective term using first-order upwind scheme.\n        # This is vectorized for efficiency.\n        grad_fwd = (u_old[2:] - u_old[1:-1]) / dx\n        grad_bwd = (u_old[1:-1] - u_old[0:-2]) / dx\n        \n        # np.where selects the appropriate difference based on the sign of u.\n        convection_term = np.where(u_interior > 0, u_interior * grad_bwd, u_interior * grad_fwd)\n\n        # Calculate diffusive term using second-order central difference.\n        diffusion_term = nu * (u_old[2:] - 2 * u_old[1:-1] + u_old[0:-2]) / (dx**2)\n        \n        # Update the solution for interior points using forward Euler.\n        u[1:-1] = u_interior + dt * (-convection_term + diffusion_term)\n\n        # Advance time.\n        t += dt\n\n    # 3. Post-processing: Compute the diagnostic G(T).\n    # The gradient is computed on interior points using a centered difference.\n    du_dx_interior = (u[2:] - u[0:-2]) / (2.0 * dx)\n    \n    # G(T) is the max absolute value of this gradient.\n    G_T = np.max(np.abs(du_dx_interior))\n\n    return round(G_T, 6)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.01, 0.2, 401, 0.05, 0.4),   # Case 1\n        (0.001, 0.2, 401, 0.05, 0.4),  # Case 2\n        (0.05, 0.2, 401, 0.05, 0.4),   # Case 3\n        (0.01, 0.0, 401, 0.05, 0.4),   # Case 4 (edge case)\n    ]\n\n    results = []\n    for case in test_cases:\n        nu, T, Nx, delta, C_cfl = case\n        result = solve_burgers(nu, T, Nx, delta, C_cfl)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2381332"}, {"introduction": "Our final practice introduces one of the most elegant and powerful ideas in modern computational fluid dynamics: the Godunov method [@problem_id:2381391]. Instead of relying on artificial smearing, this approach solves the exact physical problem—a local Riemann problem—at each cell interface to determine the numerical flux. By implementing a Godunov solver for the inviscid Burgers' equation, you will build a true shock-capturing scheme from first principles and gain appreciation for the physics-based methods used to simulate complex flows with discontinuities.", "problem": "Implement a first-order Godunov finite-volume scheme for the one-dimensional inviscid Burgers conservation law on a periodic domain. The governing equation is the scalar conservation law $\\partial_t u + \\partial_x f(u) = 0$ with flux $f(u) = \\tfrac{1}{2} u^2$. Work on the spatial domain $x \\in [0,1]$ with periodic boundary conditions and a uniform grid of $N_x$ cells. The cell averages at time $t^n$ are denoted by $u_i^n$ for $i \\in \\{0,1,\\dots,N_x-1\\}$. The Godunov method advances the solution in time via the conservative update\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+\\tfrac{1}{2}} - F_{i-\\tfrac{1}{2}} \\right) ,\n$$\nwhere $\\Delta x = 1/N_x$ and $F_{i+\\tfrac{1}{2}}$ is the intercell numerical flux constructed by solving the exact local Riemann problem at the interface between cell $i$ (left state) and cell $i+1$ (right state), evaluated at the interface location $x=0$ in self-similar coordinates $x/t$. Specifically, $F_{i+\\tfrac{1}{2}}$ must be $f\\!\\left(u^\\ast(0; u_L, u_R)\\right)$, where $u^\\ast(\\xi; u_L, u_R)$ is the exact solution to the Riemann problem with initial states $u_L$ and $u_R$, and $\\xi = x/t$. You must determine and use the exact interface state $u^\\ast(0; u_L, u_R)$ implied by the Burgers equation. Advance in time with an explicit time step constrained by the Courant–Friedrichs–Lewy (CFL) condition based on the maximum characteristic speed, using\n$$\n\\Delta t \\le \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max_i |f'(u_i^n)|} ,\n$$\nwith $f'(u) = u$. Use periodic indexing so that cell $-1$ is cell $N_x-1$ and cell $N_x$ is cell $0$.\n\nYour program must implement this scheme and validate it against exact solutions at a specified final time $T$ for the following test suite. For each case, construct the specified initial condition $u(x,0)$, evolve to time $T$ with the Godunov method, and compute the discrete $\\ell^1$ error at $T$ against the corresponding exact solution $u_{\\mathrm{exact}}(x,T)$ evaluated at cell centers $x_i = (i+\\tfrac{1}{2}) \\Delta x$:\n$$\nE_1 = \\Delta x \\sum_{i=0}^{N_x-1} \\left| u_i^N - u_{\\mathrm{exact}}(x_i,T) \\right|.\n$$\n\nTest suite (four cases):\n- Case A (rarefaction): $N_x = 200$, $\\mathrm{CFL} = 0.9$, $T = 0.2$, initial data is a Riemann step located at $x_0 = 0.5$ with left state $u_L = 0$ and right state $u_R = 1$. The exact solution is the centered rarefaction self-similar solution for the Burgers equation emanating from $x_0$.\n- Case B (shock): $N_x = 200$, $\\mathrm{CFL} = 0.9$, $T = 0.2$, initial data is a Riemann step located at $x_0 = 0.5$ with left state $u_L = 1$ and right state $u_R = 0$. The exact solution is a single shock propagating with speed given by the Rankine–Hugoniot condition from $x_0$.\n- Case C (constant state preservation): $N_x = 150$, $\\mathrm{CFL} = 0.9$, $T = 0.3$, initial data $u(x,0) \\equiv 0.2$. The exact solution is the same constant state for all times.\n- Case D (smooth pre-shock evolution): $N_x = 400$, $\\mathrm{CFL} = 0.9$, $T = 0.05$, initial data $u(x,0) = \\sin(2\\pi x)$. The exact solution is given by the method of characteristics before shock formation; for $T$ chosen, the map along characteristics is strictly monotone, and the exact solution at cell center $x_i$ is defined implicitly by $u_{\\mathrm{exact}}(x_i,T) = u_0(\\alpha)$ where $\\alpha$ solves $x_i = \\alpha + T\\,u_0(\\alpha)$ with $u_0(\\alpha) = \\sin(2\\pi \\alpha)$.\n\nAngle units are not applicable. No physical units are involved. Your program should produce a single line of output containing the four $\\ell^1$ errors for Cases A–D, each rounded to $6$ decimal places, as a comma-separated list enclosed in square brackets, in the order [A,B,C,D]. For example, the output must have the form $[e_A,e_B,e_C,e_D]$ with each $e_\\cdot$ a decimal numeral rounded to $6$ places.", "solution": "The problem requires the implementation of a first-order Godunov finite-volume method to solve the one-dimensional inviscid Burgers' equation, given by the scalar conservation law $\\partial_t u + \\partial_x f(u) = 0$. The specific flux function is $f(u) = \\frac{1}{2} u^2$. The problem is posed on a spatial domain $x \\in [0, 1]$ with periodic boundary conditions.\n\nFirst, we establish the numerical framework. The domain $[0, 1]$ is discretized into $N_x$ uniform cells, each of width $\\Delta x = 1/N_x$. The cells are indexed by $i \\in \\{0, 1, \\dots, N_x-1\\}$. The solution within each cell $i$ is represented by its cell average at time $t^n = n \\Delta t$, denoted by $u_i^n$. The finite-volume method advances the solution in time using the conservative update formula:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}} \\right)\n$$\nHere, $F_{i+\\frac{1}{2}}$ represents the numerical flux across the interface between cell $i$ and cell $i+1$. The Godunov method defines this flux by solving the exact Riemann problem at the interface.\n\nThe core of the Godunov method is the determination of the numerical flux, $F_{i+\\frac{1}{2}}$. For each interface, we consider a local Riemann problem with initial data consisting of two constant states: the left state $u_L = u_i^n$ and the right state $u_R = u_{i+1}^n$. The solution to this Riemann problem, $u(x,t)$, is self-similar and can be expressed as a function of $\\xi = x/t$. The Godunov flux is then defined as the physical flux evaluated at the state that appears at the interface location $\\xi=0$, i.e., $F_{i+\\frac{1}{2}} = f(u^*(\\xi=0; u_L, u_R))$.\n\nFor the Burgers' equation, the characteristic speed is given by $f'(u) = u$. The structure of the Riemann problem solution depends on the relationship between $u_L$ and $u_R$.\n\n1.  **Rarefaction Wave ($u_L \\le u_R$):** The solution is a continuous fan of states. The state at the interface, $u^*(0)$, is determined as follows:\n    - If $u_L \\ge 0$, characteristics at the interface originate from the left state. Thus, $u^*(0) = u_L$.\n    - If $u_R \\le 0$, characteristics at the interface originate from the right state. Thus, $u^*(0) = u_R$.\n    - If $u_L  0  u_R$, the characteristic with speed $0$ is part of the rarefaction fan. The state at $\\xi=0$ is $u^*(0) = 0$.\n    The corresponding flux $F_{i+\\frac{1}{2}}$ is $f(u_L)$, $f(u_R)$, or $f(0)=0$, respectively.\n\n2.  **Shock Wave ($u_L > u_R$):** The solution is a discontinuity (a shock) that propagates with speed $s$ given by the Rankine–Hugoniot condition:\n    $$\n    s = \\frac{f(u_R) - f(u_L)}{u_R - u_L} = \\frac{\\frac{1}{2}u_R^2 - \\frac{1}{2}u_L^2}{u_R - u_L} = \\frac{1}{2}(u_L + u_R)\n    $$\n    The state at the interface, $u^*(0)$, depends on the direction of shock propagation relative to the interface:\n    - If $s > 0$, the shock moves to the right. The state at the interface location $\\xi=0$ is the left state, $u^*(0) = u_L$.\n    - If $s \\le 0$, the shock is stationary or moves to the left. The state at the interface is the right state, $u^*(0) = u_R$.\n    The corresponding flux $F_{i+\\frac{1}{2}}$ is $f(u_L)$ or $f(u_R)$, respectively.\n\nThe time step $\\Delta t$ is chosen to satisfy the Courant–Friedrichs–Lewy (CFL) condition for stability. For an explicit scheme, the numerical domain of dependence must contain the physical domain of dependence. This requires that the time step be limited by the maximum characteristic speed in the domain:\n$$\n\\Delta t = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max_i |f'(u_i^n)|} = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max_i |u_i^n|}\n$$\nwhere $\\mathrm{CFL} \\le 1$ is the CFL number. A value of $\\mathrm{CFL}=0.9$ is used. If $\\max_i |u_i^n| = 0$, the solution is stationary, and any $\\Delta t$ is stable; for implementation, we can choose $\\Delta t = T-t^n$ to complete the simulation in one step.\n\nTo implement the scheme, we iterate in time from $t=0$ to the final time $T$. At each time step $t^n$, we first compute the maximum characteristic speed and determine $\\Delta t$. To avoid overshooting the final time $T$, the last time step is adjusted to be $\\Delta t = T-t^n$. Then, we compute the numerical fluxes $F_{i+\\frac{1}{2}}$ for all interfaces $i=0, \\dots, N_x-1$. Due to periodic boundary conditions, the right state for the interface at $i=N_x-1$ is $u_0^n$. Finally, we apply the conservative update to find all $u_i^{n+1}$.\n\nAfter the evolution to time $T$, the numerical solution is compared to the exact solution for each test case. The discrete $\\ell^1$ error is computed as:\n$$\nE_1 = \\Delta x \\sum_{i=0}^{N_x-1} \\left| u_i^N - u_{\\mathrm{exact}}(x_i,T) \\right|\n$$\nwhere $u_i^N$ is the final computed cell average for cell $i$, and $u_{\\mathrm{exact}}(x_i, T)$ is the exact solution evaluated at the cell center $x_i = (i+\\frac{1}{2})\\Delta x$.\n\nFor Case D, the exact solution $u(x,T) = u_0(\\alpha)$ is defined implicitly via the method of characteristics, where $x = \\alpha + T u_0(\\alpha)$. For a given grid point $x_i$, we must solve the transcendental equation $x_i = \\alpha + T \\sin(2\\pi \\alpha)$ for $\\alpha$. Since the time $T=0.05$ is before shock formation, this equation has a unique root $\\alpha$ for each $x_i$, which can be found efficiently using a numerical root-finding algorithm like Newton's method.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import newton\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the Godunov scheme.\n    \"\"\"\n\n    # --- Test Case Definitions ---\n    # Case A: Rarefaction\n    case_a = {\n        'Nx': 200, 'CFL': 0.9, 'T': 0.2, 'x0': 0.5, 'uL': 0.0, 'uR': 1.0, 'case_name': 'A'\n    }\n    # Case B: Shock\n    case_b = {\n        'Nx': 200, 'CFL': 0.9, 'T': 0.2, 'x0': 0.5, 'uL': 1.0, 'uR': 0.0, 'case_name': 'B'\n    }\n    # Case C: Constant State\n    case_c = {\n        'Nx': 150, 'CFL': 0.9, 'T': 0.3, 'u_const': 0.2, 'case_name': 'C'\n    }\n    # Case D: Smooth pre-shock evolution\n    case_d = {\n        'Nx': 400, 'CFL': 0.9, 'T': 0.05, 'case_name': 'D'\n    }\n\n    test_cases = [case_a, case_b, case_c, case_d]\n    errors = []\n\n    for params in test_cases:\n        case_name = params['case_name']\n        Nx = params['Nx']\n        CFL = params['CFL']\n        T = params['T']\n        \n        dx = 1.0 / Nx\n        x = (np.arange(Nx) + 0.5) * dx\n\n        # Define initial and exact solution functions for each case\n        if case_name == 'A':\n            uL, uR, x0 = params['uL'], params['uR'], params['x0']\n            u0 = np.where(x  x0, uL, uR)\n            def u_exact_func(t, x_grid):\n                xi = (x_grid - x0) / t\n                return np.where(xi = uL, uL, np.where(xi >= uR, uR, xi))\n        \n        elif case_name == 'B':\n            uL, uR, x0 = params['uL'], params['uR'], params['x0']\n            u0 = np.where(x  x0, uL, uR)\n            def u_exact_func(t, x_grid):\n                s = 0.5 * (uL + uR)\n                shock_pos = x0 + s * t\n                return np.where(x_grid  shock_pos, uL, uR)\n\n        elif case_name == 'C':\n            u_const = params['u_const']\n            u0 = np.full(Nx, u_const)\n            def u_exact_func(t, x_grid):\n                return np.full_like(x_grid, u_const)\n\n        elif case_name == 'D':\n            u0 = np.sin(2.0 * np.pi * x)\n            def u_exact_func(t, x_grid):\n                # We need to solve x = alpha + t * sin(2*pi*alpha) for alpha for each x in x_grid\n                def g(alpha, x_val, t_val):\n                    return alpha + t_val * np.sin(2.0 * np.pi * alpha) - x_val\n                \n                # Use scipy's Newton solver, vectorized\n                # Initial guess for alpha is x itself\n                alpha_roots = newton(g, x_grid, args=(x_grid, t))\n                return np.sin(2.0 * np.pi * alpha_roots)\n\n        # Run the solver\n        error = godunov_solver(Nx, CFL, T, u0, u_exact_func)\n        errors.append(error)\n\n    # Format the output as specified\n    formatted_errors = [f\"{err:.6f}\" for err in errors]\n    print(f\"[{','.join(formatted_errors)}]\")\n\ndef godunov_flux(uL, uR):\n    \"\"\"\n    Computes the Godunov flux for the Burgers' equation f(u) = 0.5 * u^2.\n    Accepts numpy arrays for uL and uR.\n    \"\"\"\n    f_uL = 0.5 * uL**2\n    f_uR = 0.5 * uR**2\n    s = 0.5 * (uL + uR)\n\n    # Conditions for selecting the flux based on the Riemann problem solution\n    is_shock = uL > uR\n    \n    # Flux for shock waves\n    flux_shock = np.where(s > 0, f_uL, f_uR)\n\n    # Flux for rarefaction waves\n    flux_raref = np.where(uL >= 0, f_uL, np.where(uR = 0, f_uR, 0.0))\n    \n    return np.where(is_shock, flux_shock, flux_raref)\n\ndef godunov_solver(Nx, CFL, T, u0, u_exact_func):\n    \"\"\"\n    Solves the 1D Burgers' equation using a first-order Godunov scheme.\n    \"\"\"\n    dx = 1.0 / Nx\n    x = (np.arange(Nx) + 0.5) * dx\n    \n    u = np.copy(u0)\n    t = 0.0\n\n    while t  T:\n        # Determine max characteristic speed\n        max_speed = np.max(np.abs(u))\n\n        # Calculate time step based on CFL condition\n        if max_speed == 0:\n            dt = T - t  # Solution is stationary, step to the end\n        else:\n            dt = CFL * dx / max_speed\n        \n        # Ensure the last step lands exactly on T\n        dt = min(dt, T - t)\n\n        # Define left and right states for all interfaces, with periodic BC\n        u_L = u\n        u_R = np.roll(u, -1)\n\n        # Compute numerical fluxes at all interfaces i+1/2\n        fluxes = godunov_flux(u_L, u_R)\n\n        # Compute flux difference using periodicity\n        flux_diff = fluxes - np.roll(fluxes, 1)\n\n        # Update solution\n        u = u - (dt / dx) * flux_diff\n        \n        t += dt\n\n    # Compute exact solution at time T\n    u_final_exact = u_exact_func(T, x)\n    \n    # Compute L1 error\n    l1_error = dx * np.sum(np.abs(u - u_final_exact))\n    \n    return l1_error\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2381391"}]}