{"hands_on_practices": [{"introduction": "At its core, a projection method is a numerical embodiment of the Helmholtz-Hodge decomposition, which separates a vector field into its divergence-free (solenoidal) and curl-free (irrotational) components. This first exercise provides a direct look at this principle by demonstrating that the projection operation is geometrically an orthogonal projection onto the subspace of divergence-free fields. By proving and then numerically verifying that the projection step minimizes the kinetic energy of a velocity field [@problem_id:2430752], you will build a foundational understanding of why this method is so effective at enforcing the incompressibility constraint.", "problem": "Consider an incompressible fluid on a two-dimensional periodic domain. Let the domain be the square $[0,2\\pi]\\times[0,2\\pi]$ with periodic boundary conditions in both directions. Let $\\vec{u}(\\vec{x})$ denote a sufficiently smooth velocity field, and define the kinetic energy\n$$\nE[\\vec{u}] \\;=\\; \\int_{[0,2\\pi]^2} \\frac{1}{2}\\, \\lvert \\vec{u}(\\vec{x}) \\rvert^2 \\,\\mathrm{d}\\vec{x}.\n$$\nIn the projection framework for incompressible flow, given an intermediate velocity field $\\vec{u}^{\\star}$, the continuous projection step produces a solenoidal velocity $\\vec{u}^{\\mathrm{proj}}$ by solving for a scalar field $p$ such that\n$$\n\\nabla^2 p \\;=\\; \\nabla\\cdot \\vec{u}^{\\star}, \\quad \\text{and} \\quad \\vec{u}^{\\mathrm{proj}} \\;=\\; \\vec{u}^{\\star} - \\nabla p,\n$$\nwith the periodic boundary condition on $p$ and zero-mean normalization for uniqueness. Angles in all trigonometric functions are in radians.\n\nTasks:\n1. Prove, from first principles, that the continuous projection step is energy-dissipating in the sense that\n$$\nE[\\vec{u}^{\\mathrm{proj}}] \\;\\le\\; E[\\vec{u}^{\\star}],\n$$\nwith equality if and only if $\\nabla\\cdot \\vec{u}^{\\star} = 0$.\n\n2. Implement a program that, for each of the prescribed test cases listed below, constructs the velocity field $\\vec{u}^{\\star}$ on a uniform grid of $N\\times N$ points over $[0,2\\pi]\\times[0,2\\pi]$, applies a numerically consistent discrete projection step to obtain a discretely divergence-free velocity field $\\vec{u}^{\\mathrm{proj}}$, and computes the relative change in kinetic energy\n$$\n\\delta \\;=\\; \\frac{E_h[\\vec{u}^{\\mathrm{proj}}] - E_h[\\vec{u}^{\\star}]}{E_h[\\vec{u}^{\\star}]},\n$$\nwhere $E_h[\\cdot]$ is the standard rectangle-rule discrete approximation of $E[\\cdot]$ on the uniform grid:\n$$\nE_h[\\vec{u}] \\;=\\; \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\frac{1}{2}\\left( u_x(x_i,y_j)^2 + u_y(x_i,y_j)^2 \\right)\\,\\Delta x\\,\\Delta y,\n$$\nwith $\\Delta x = 2\\pi/N$ and $\\Delta y = 2\\pi/N$, and $(x_i,y_j) = (i\\,\\Delta x, j\\,\\Delta y)$.\n\nTest suite (each test case specifies $N$ and the analytic form of $\\vec{u}^{\\star}$; all fields are defined over $[0,2\\pi]\\times[0,2\\pi]$ with periodicity):\n\n- Test case A (divergence-free input):\n  - Grid: $N = 64$.\n  - Streamfunction: $\\psi(x,y) = \\sin(x)\\cos(y)$.\n  - Velocity: $\\vec{u}^{\\star}(x,y) = \\left(-\\partial_y \\psi(x,y), \\;\\partial_x \\psi(x,y)\\right)$.\n\n- Test case B (purely irrotational input):\n  - Grid: $N = 32$.\n  - Potential: $\\phi(x,y) = \\sin(3x) + \\cos(2y)$.\n  - Velocity: $\\vec{u}^{\\star}(x,y) = \\nabla \\phi(x,y)$.\n\n- Test case C (mixed input: solenoidal plus irrotational):\n  - Grid: $N = 48$.\n  - Streamfunction: $\\psi(x,y) = \\sin(x)\\cos(y)$.\n  - Potential: $\\phi(x,y) = \\sin(3x) + \\cos(2y)$.\n  - Mixing coefficient: $\\alpha = 0.5$.\n  - Velocity: $\\vec{u}^{\\star}(x,y) = \\left(-\\partial_y \\psi(x,y), \\;\\partial_x \\psi(x,y)\\right) + \\alpha\\,\\nabla \\phi(x,y)$.\n\n- Test case D (uniform flow, divergence-free):\n  - Grid: $N = 16$.\n  - Velocity: $\\vec{u}^{\\star}(x,y) = (1.0,\\,-0.5)$.\n\nFor each test case, your program must compute the single scalar $\\delta$ as defined above. Your program should produce a single line of output containing the results as a comma-separated list of decimal numbers rounded to exactly $10$ decimal places, enclosed in square brackets, in the order $[\\delta_A,\\delta_B,\\delta_C,\\delta_D]$. For example, an acceptable output format is\n$$\n[\\delta_A,\\delta_B,\\delta_C,\\delta_D]\n$$\nwith each $\\delta$ rounded to exactly $10$ decimal places. No physical units are required; all quantities are dimensionless.", "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It is a standard problem in computational fluid dynamics. We proceed with the two tasks.\n\n**Task 1: Proof of Energy Dissipation**\n\nWe are asked to prove that the projection step is energy-dissipating, meaning $E[\\vec{u}^{\\mathrm{proj}}] \\le E[\\vec{u}^{\\star}]$, with equality if and only if the initial field $\\vec{u}^{\\star}$ is already divergence-free, i.e., $\\nabla\\cdot \\vec{u}^{\\star} = 0$.\n\nThe kinetic energy of the projected velocity field $\\vec{u}^{\\mathrm{proj}}$ is defined as:\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = \\int_{\\Omega} \\frac{1}{2} |\\vec{u}^{\\mathrm{proj}}|^2 \\, \\mathrm{d}\\vec{x}\n$$\nwhere $\\Omega = [0, 2\\pi] \\times [0, 2\\pi]$ is the periodic domain.\n\nBy definition, the projected velocity is given by $\\vec{u}^{\\mathrm{proj}} = \\vec{u}^{\\star} - \\nabla p$. Substituting this into the energy expression gives:\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = \\int_{\\Omega} \\frac{1}{2} |\\vec{u}^{\\star} - \\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\nWe expand the squared norm in the integrand:\n$$\n|\\vec{u}^{\\star} - \\nabla p|^2 = (\\vec{u}^{\\star} - \\nabla p) \\cdot (\\vec{u}^{\\star} - \\nabla p) = |\\vec{u}^{\\star}|^2 - 2 \\vec{u}^{\\star} \\cdot \\nabla p + |\\nabla p|^2\n$$\nSubstituting this back into the integral for energy:\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = \\int_{\\Omega} \\frac{1}{2} |\\vec{u}^{\\star}|^2 \\, \\mathrm{d}\\vec{x} - \\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} + \\int_{\\Omega} \\frac{1}{2} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\nThe first term is the energy of the intermediate field, $E[\\vec{u}^{\\star}]$. So we have:\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}] - \\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} + \\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\nLet us analyze the cross term, $\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x}$. We use integration by parts, which in multiple dimensions relies on the divergence theorem. We use the product rule for divergence: $\\nabla \\cdot (p \\vec{u}^{\\star}) = (\\nabla p) \\cdot \\vec{u}^{\\star} + p (\\nabla \\cdot \\vec{u}^{\\star})$. Rearranging gives:\n$$\n\\vec{u}^{\\star} \\cdot \\nabla p = \\nabla \\cdot (p \\vec{u}^{\\star}) - p (\\nabla \\cdot \\vec{u}^{\\star})\n$$\nIntegrating over the domain $\\Omega$:\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = \\int_{\\Omega} \\nabla \\cdot (p \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x} - \\int_{\\Omega} p (\\nabla \\cdot \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x}\n$$\nBy the Divergence Theorem, the integral of a divergence over a closed domain (or a periodic domain, where boundary terms cancel) is zero. Thus, $\\int_{\\Omega} \\nabla \\cdot (p \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x} = 0$.\nThe equation simplifies to:\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = - \\int_{\\Omega} p (\\nabla \\cdot \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x}\n$$\nFrom the problem statement, the pressure field $p$ is obtained by solving the Poisson equation $\\nabla^2 p = \\nabla \\cdot \\vec{u}^{\\star}$. Substituting this in:\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = - \\int_{\\Omega} p (\\nabla^2 p) \\, \\mathrm{d}\\vec{x}\n$$\nWe apply integration by parts again to the right-hand side. Using the identity $\\nabla\\cdot(p\\nabla p) = \\nabla p \\cdot \\nabla p + p \\nabla^2 p = |\\nabla p|^2 + p\\nabla^2 p$:\n$$\n\\int_{\\Omega} p (\\nabla^2 p) \\, \\mathrm{d}\\vec{x} = \\int_{\\Omega} \\nabla\\cdot(p\\nabla p) \\, \\mathrm{d}\\vec{x} - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\nAgain, the integral of the divergence term $\\nabla\\cdot(p\\nabla p)$ is zero over the periodic domain. This leaves:\n$$\n\\int_{\\Omega} p (\\nabla^2 p) \\, \\mathrm{d}\\vec{x} = - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\nSubstituting this result back into our expression for the cross term:\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = - \\left( - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} \\right) = \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\nNow we return to the expression for $E[\\vec{u}^{\\mathrm{proj}}]$:\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}] - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} + \\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}] - \\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\nThe integrand $|\\nabla p|^2$ is a squared real-valued quantity, so it is non-negative. Therefore, the integral $\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} \\ge 0$.\nThis directly implies:\n$$\nE[\\vec{u}^{\\mathrm{proj}}] \\le E[\\vec{u}^{\\star}]\n$$\nThis concludes the first part of the proof.\n\nFor the condition of equality, $E[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}]$ holds if and only if the subtractive term is zero:\n$$\n\\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} = 0\n$$\nSince the integrand $|\\nabla p|^2$ is non-negative and the function $p$ is assumed to be sufficiently smooth, this equality can only be true if the integrand is identically zero everywhere. That is, $|\\nabla p(\\vec{x})|^2 = 0$ for all $\\vec{x} \\in \\Omega$, which implies $\\nabla p(\\vec{x}) = \\vec{0}$.\nThis means that the scalar field $p$ must be a constant over the domain.\nThe problem states that $p$ is subject to a zero-mean normalization condition, $\\int_{\\Omega} p \\, \\mathrm{d}\\vec{x} = 0$. If $p$ is a constant $C$, then $\\int_{\\Omega} C \\, \\mathrm{d}\\vec{x} = C \\cdot \\text{Area}(\\Omega) = 0$, which implies $C=0$.\nSo, $p(\\vec{x}) = 0$ for all $\\vec{x}$.\n\nIf $p(\\vec{x})=0$, then the Poisson equation $\\nabla^2 p = \\nabla \\cdot \\vec{u}^{\\star}$ becomes $\\nabla^2 (0) = 0 = \\nabla \\cdot \\vec{u}^{\\star}$. Thus, equality holds if $\\nabla \\cdot \\vec{u}^{\\star} = 0$.\n\nConversely, if $\\nabla \\cdot \\vec{u}^{\\star} = 0$, we must solve the homogeneous Poisson equation $\\nabla^2 p = 0$ with periodic boundary conditions and zero-mean normalization. The unique solution to this problem is $p(\\vec{x}) = 0$. This implies $\\nabla p = \\vec{0}$, and therefore the subtractive energy term $\\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}$ is zero. This leads to $E[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}]$.\n\nThus, we have proven that $E[\\vec{u}^{\\mathrm{proj}}] \\le E[\\vec{u}^{\\star}]$, with equality holding if and only if $\\nabla \\cdot \\vec{u}^{\\star} = 0$. This demonstrates that the projection operator orthogonally projects the vector field onto the subspace of divergence-free fields, minimizing the kinetic energy by removing the component that is a pure gradient.\n\n**Task 2: Numerical Implementation**\n\nThe numerical implementation applies a discrete version of the projection operator using a spectral method, which is highly accurate for periodic problems. The steps for the algorithm are as follows:\n\n1.  Construct the grid and the initial velocity field $\\vec{u}^{\\star}$ for each test case.\n2.  Calculate the initial discrete kinetic energy $E_h[\\vec{u}^{\\star}]$.\n3.  Compute the 2D Fast Fourier Transform (FFT) of the components of $\\vec{u}^{\\star}$ to get $\\hat{u}^{\\star}_x$ and $\\hat{u}^{\\star}_y$.\n4.  Compute the Fourier transform of the divergence, $\\widehat{\\nabla\\cdot \\vec{u}^{\\star}} = i k_x \\hat{u}^{\\star}_x + i k_y \\hat{u}^{\\star}_y$, where $k_x$ and $k_y$ are the integer wavenumbers corresponding to the discrete grid.\n5.  Solve the Poisson equation $\\nabla^2 p = \\nabla\\cdot \\vec{u}^{\\star}$ in Fourier space. This becomes $-(k_x^2 + k_y^2)\\hat{p} = \\widehat{\\nabla\\cdot \\vec{u}^{\\star}}$. The solution for the Fourier coefficients of the pressure is $\\hat{p} = \\frac{i k_x \\hat{u}^{\\star}_x + i k_y \\hat{u}^{\\star}_y}{k_x^2 + k_y^2}$. The singularity at $k_x=k_y=0$ is handled by setting $\\hat{p}(0,0)=0$, which enforces the zero-mean condition on $p$.\n6.  Compute the Fourier transform of the pressure gradient, $\\widehat{\\nabla p} = (i k_x \\hat{p}, i k_y \\hat{p})$.\n7.  Apply an inverse 2D FFT to obtain the pressure gradient $\\nabla p$ in physical space.\n8.  Compute the projected velocity field $\\vec{u}^{\\mathrm{proj}} = \\vec{u}^{\\star} - \\nabla p$.\n9.  Calculate the final discrete kinetic energy $E_h[\\vec{u}^{\\mathrm{proj}}]$.\n10. Compute the relative change in energy, $\\delta = (E_h[\\vec{u}^{\\mathrm{proj}}] - E_h[\\vec{u}^{\\star}]) / E_h[\\vec{u}^{\\star}]$.\n\nThis procedure is implemented for each of the four test cases provided.\n- Cases A and D involve analytically divergence-free fields. The computed $\\delta$ should be close to $0$, with any non-zero value resulting from floating-point precision limits.\n- Case B involves a pure gradient field. The projection should result in a zero velocity field, and $\\delta$ should be very close to $-1$.\n- Case C is a mixed field. The projection removes the gradient component, resulting in a negative $\\delta$ whose value depends on the relative energies of the solenoidal and irrotational parts. The analytical prediction is $\\delta = -13/17 \\approx -0.7647$. The numerical result should be very close to this value.\n\nThe provided Python code implements this algorithm.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the projection problem for four test cases and computes the\n    relative change in kinetic energy.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'id': 'A', 'N': 64, 'type': 'streamfunction'},\n        {'id': 'B', 'N': 32, 'type': 'potential'},\n        {'id': 'C', 'N': 48, 'type': 'mixed'},\n        {'id': 'D', 'N': 16, 'type': 'uniform'}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case['N']\n        L = 2.0 * np.pi\n        dx = L / N\n        dy = L / N\n        \n        # Create grid\n        x = np.arange(N) * dx\n        xx, yy = np.meshgrid(x, x, indexing='ij')\n\n        u_star_x = np.zeros((N, N))\n        u_star_y = np.zeros((N, N))\n\n        # Construct the intermediate velocity field u_star for each test case\n        if case['type'] == 'streamfunction':\n            # Case A: Divergence-free input\n            # psi(x,y) = sin(x)cos(y)\n            # u = -d_y psi = sin(x)sin(y)\n            # v =  d_x psi = cos(x)cos(y)\n            u_star_x = np.sin(xx) * np.sin(yy)\n            u_star_y = np.cos(xx) * np.cos(yy)\n        elif case['type'] == 'potential':\n            # Case B: Purely irrotational input\n            # phi(x,y) = sin(3x) + cos(2y)\n            # u = d_x phi = 3cos(3x)\n            # v = d_y phi = -2sin(2y)\n            u_star_x = 3.0 * np.cos(3.0 * xx)\n            u_star_y = -2.0 * np.sin(2.0 * yy)\n        elif case['type'] == 'mixed':\n            # Case C: Mixed input\n            alpha = 0.5\n            # Solenoidal part from streamfunction psi(x,y) = sin(x)cos(y)\n            u_psi_x = np.sin(xx) * np.sin(yy)\n            u_psi_y = np.cos(xx) * np.cos(yy)\n            # Irrotational part from potential phi(x,y) = sin(3x) + cos(2y)\n            u_phi_x = 3.0 * np.cos(3.0 * xx)\n            u_phi_y = -2.0 * np.sin(2.0 * yy)\n            u_star_x = u_psi_x + alpha * u_phi_x\n            u_star_y = u_psi_y + alpha * u_phi_y\n        elif case['type'] == 'uniform':\n            # Case D: Uniform flow, divergence-free\n            u_star_x = np.full((N, N), 1.0)\n            u_star_y = np.full((N, N), -0.5)\n\n        # Calculate discrete kinetic energy E_h[u_star]\n        E_star = 0.5 * np.sum(u_star_x**2 + u_star_y**2) * dx * dy\n        \n        if E_star == 0.0:\n            # This case will not be hit by the problem's test suite\n            results.append(0.0)\n            continue\n            \n        # Perform projection using Fourier spectral method\n        \n        # Wavenumbers (integer values)\n        k = np.fft.fftfreq(N) * N\n        kx, ky = np.meshgrid(k, k, indexing='ij')\n\n        # FFT of the velocity field\n        u_star_x_hat = np.fft.fft2(u_star_x)\n        u_star_y_hat = np.fft.fft2(u_star_y)\n        \n        # Divergence in Fourier space\n        div_u_star_hat = 1j * kx * u_star_x_hat + 1j * ky * u_star_y_hat\n        \n        # Solve Poisson equation for pressure p in Fourier space\n        # - (kx^2 + ky^2) * p_hat = div_u_star_hat\n        ksq = kx**2 + ky**2\n        \n        # Inverse of -(k^2) operator, with singularity at k=0 handled\n        # ksq_inv_neg will be -1/ksq for k != 0, and 0 for k = 0\n        ksq_inv_neg = np.zeros_like(ksq)\n        non_zero_k = ksq > 0\n        ksq_inv_neg[non_zero_k] = -1.0 / ksq[non_zero_k]\n        \n        p_hat = div_u_star_hat * ksq_inv_neg\n        \n        # The zero-mean pressure condition corresponds to p_hat[0,0] = 0,\n        # which is automatically satisfied by the above procedure since ksq_inv_neg[0,0] = 0.\n        \n        # Gradient of p in Fourier space\n        grad_p_x_hat = 1j * kx * p_hat\n        grad_p_y_hat = 1j * ky * p_hat\n        \n        # Transform gradient back to physical space.\n        # The result must be real; .real discards negligible imaginary parts from numerical error.\n        grad_p_x = np.fft.ifft2(grad_p_x_hat).real\n        grad_p_y = np.fft.ifft2(grad_p_y_hat).real\n        \n        # Compute the projected velocity field\n        u_proj_x = u_star_x - grad_p_x\n        u_proj_y = u_star_y - grad_p_y\n        \n        # Calculate discrete kinetic energy E_h[u_proj]\n        E_proj = 0.5 * np.sum(u_proj_x**2 + u_proj_y**2) * dx * dy\n        \n        # Calculate relative change in kinetic energy delta\n        delta = (E_proj - E_star) / E_star\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2430752"}, {"introduction": "Building on the energy conservation principles from the previous exercise, this practice delves into a critical, and often subtle, aspect of numerical implementation. You will investigate how the choice of discrete operators for the gradient ($G$) and divergence ($D$) affects the long-term energy conservation of the system. This exercise [@problem_id:2430781] beautifully illustrates that maintaining the discrete adjoint relationship, where $D$ is the negative adjoint of $G$, is crucial for preventing the artificial creation or destruction of energy, a purely numerical artifact that can compromise the physical realism of a simulation.", "problem": "Consider a two-dimensional, periodic, square domain $[0,1] \\times [0,1]$ discretized by a uniform Cartesian grid with $N \\times N$ points and grid spacing $h = 1/N$. The discrete velocity field is represented at cell centers as $u = (u_x, u_y)$, where $u_x$ and $u_y$ are arrays of shape $N \\times N$. The discrete inner product is defined by\n$$\n\\langle a, b \\rangle_h = h^2 \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( a_x(i,j) b_x(i,j) + a_y(i,j) b_y(i,j) \\right),\n$$\nand the discrete kinetic energy is $E = \\tfrac{1}{2} \\langle u, u \\rangle_h$.\n\nDefine the time update from $u^n$ to $u^{n+1}$ by a pressure-projection step of the form\n$$\nu^{n+1} = u^* - \\Delta t \\, G p^{n+1}, \\quad u^* = u^n,\n$$\nwhere the discrete pressure $p^{n+1}$ satisfies the Poisson equation\n$$\n\\frac{1}{\\Delta t} D u^* = L p^{n+1}, \\quad L = D G.\n$$\nAll operations are defined on the periodic grid.\n\nThe discrete gradient operator $G$ and divergence operator $D$ are to be chosen from the following sets:\n- Operator set A (central-central): $G_c p = (\\mathrm{D}_{x}^{c} p, \\mathrm{D}_{y}^{c} p)$ and $D_c u = \\mathrm{D}_{x}^{c} u_x + \\mathrm{D}_{y}^{c} u_y$,\n- Operator set B (central-forward): $G_c p = (\\mathrm{D}_{x}^{c} p, \\mathrm{D}_{y}^{c} p)$ and $D_f u = \\mathrm{D}_{x}^{f} u_x + \\mathrm{D}_{y}^{f} u_y$,\n\nwhere $\\mathrm{D}_{x}^{c}$ and $\\mathrm{D}_{y}^{c}$ are the standard centered finite difference operators with periodic wrap,\n$$\n\\mathrm{D}_{x}^{c} \\phi(i,j) = \\frac{\\phi(i,j+1) - \\phi(i,j-1)}{2h}, \\quad \\mathrm{D}_{y}^{c} \\phi(i,j) = \\frac{\\phi(i+1,j) - \\phi(i-1,j)}{2h},\n$$\nand $\\mathrm{D}_{x}^{f}$ and $\\mathrm{D}_{y}^{f}$ are the standard forward finite difference operators with periodic wrap,\n$$\n\\mathrm{D}_{x}^{f} \\phi(i,j) = \\frac{\\phi(i,j+1) - \\phi(i,j)}{h}, \\quad \\mathrm{D}_{y}^{f} \\phi(i,j) = \\frac{\\phi(i+1,j) - \\phi(i,j)}{h}.\n$$\n\nInitialize the velocity field using a discrete streamfunction $\\psi(i,j) = \\sin(2\\pi x_j)\\sin(2\\pi y_i)$ with $x_j = j h$ and $y_i = i h$. Define\n$$\nu_x^0 = \\mathrm{D}_{y}^{c} \\psi, \\quad u_y^0 = -\\mathrm{D}_{x}^{c} \\psi.\n$$\n\nFor each test case below, simulate the system for a prescribed number of time steps starting from $u^0$, using the specified operator set to define $D$, with $G=G_c$ as given above, and $L = D G$. Use periodic boundary conditions for all discrete operators. Compute the discrete kinetic energy drift after the final time step as\n$$\n\\Delta E = E^{\\text{final}} - E^{\\text{initial}},\n$$\nwhich is a dimensionless real number.\n\nTest suite:\n- Case $1$: $N = 32$, $\\Delta t = 0.1$, number of steps $= 1000$, operator set A.\n- Case $2$: $N = 32$, $\\Delta t = 0.1$, number of steps $= 1000$, operator set B.\n- Case $3$: $N = 8$, $\\Delta t = 0.2$, number of steps $= 400$, operator set B.\n- Case $4$: $N = 32$, $\\Delta t = 0.01$, number of steps $= 1000$, operator set B.\n\nYour task is to implement a program that carries out the above simulation for each test case, computes the corresponding energy drift $\\Delta E$ (a float) for each case, and aggregates the results.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each float written in scientific notation with $10$ significant digits, in the order of Cases $1$ through $4$ (for example, $[\\text{r1},\\text{r2},\\text{r3},\\text{r4}]$).", "solution": "The problem presents a valid numerical experiment in computational physics, specifically focusing on the properties of projection methods for incompressible flow simulations. It is scientifically grounded, well-posed, and all variables and procedures are defined with sufficient precision. I will now proceed with a detailed solution.\n\nThe core of the problem is to simulate the time evolution of a two-dimensional velocity field $u$ on a periodic domain, governed by a simplified projection method. The update rule from time step $n$ to $n+1$ is given by a projection of an intermediate velocity field $u^*$ onto the space of discretely divergence-free fields. In this problem, the intermediate step is trivial, $u^* = u^n$. The projection is formulated as:\n$$\nu^{n+1} = u^n - \\Delta t \\, G p^{n+1}\n$$\nwhere $p^{n+1}$ is the discrete pressure field at the new time step, and $G$ is the discrete gradient operator. The pressure is determined by enforcing that the resulting velocity field $u^{n+1}$ is divergence-free, i.e., $D u^{n+1} = 0$, where $D$ is the discrete divergence operator. Applying the divergence operator to the update equation gives:\n$$\nD u^{n+1} = D u^n - \\Delta t \\, D G p^{n+1} = 0\n$$\nThis leads to the pressure Poisson equation (PPE):\n$$\nL p^{n+1} = \\frac{1}{\\Delta t} D u^n\n$$\nwhere $L = DG$ is the discrete Laplacian operator.\n\nThe simulation is performed on a periodic grid, which makes the use of the Discrete Fourier Transform (DFT) highly efficient. The convolution theorem states that a differentiation (or any finite difference operation) in physical space corresponds to a multiplication by a \"symbol\" in Fourier space. Solving the PPE in Fourier space becomes a simple algebraic division.\n\nLet $\\hat{\\phi}$ represent the 2D DFT of a field $\\phi$. The PPE transforms to:\n$$\n\\hat{L} \\hat{p}^{n+1} = \\frac{1}{\\Delta t} \\widehat{D u^n}\n$$\nwhere $\\hat{L}$ and $\\widehat{D u^n}$ are the Fourier space representations of the Laplacian operator and the divergence of $u^n$, respectively. The pressure field in Fourier space is then found by:\n$$\n\\hat{p}^{n+1} = \\frac{1}{\\hat{L}} \\left( \\frac{1}{\\Delta t} \\widehat{D u^n} \\right)\n$$\nFor periodic boundary conditions, the discrete Laplacian $\\hat{L}$ has a zero eigenvalue for the zero-frequency mode ($k_x = 0, k_y = 0$), corresponding to the constant pressure mode. However, the divergence of any field on a periodic domain sums to zero, meaning its zero-frequency component is also zero. This leads to a $0/0$ indeterminacy, which is resolved by setting the zero-frequency component of the pressure, $\\hat{p}(0,0)$, to zero. This is permissible because only the gradient of the pressure, $G p$, appears in the velocity update, and the gradient of a constant is zero.\n\nThe Fourier symbols for the specified discrete operators are derived first. The problem defines the standard centered difference gradient operator $G_c p = (\\mathrm{D}_{x}^{c} p, \\mathrm{D}_{y}^{c} p)$. Its Fourier symbols are:\n$$\n\\hat{g}_x = \\frac{i \\sin(2 \\pi k_x h)}{h}, \\quad \\hat{g}_y = \\frac{i \\sin(2 \\pi k_y h)}{h}\n$$\nwhere $k_x, k_y = \\texttt{fftfreq}(N, h)$ are wavenumbers in cycles per unit length.\n\nThe symbols for the divergence operators are:\n- Operator Set A ($D_c$): $\\hat{d}_x = \\hat{g}_x$, $\\hat{d}_y = \\hat{g}_y$.\n- Operator Set B ($D_f$):\n$$\n\\hat{d}_x = \\frac{e^{i 2 \\pi k_x h} - 1}{h}, \\quad \\hat{d}_y = \\frac{e^{i 2 \\pi k_y h} - 1}{h}\n$$\nThe symbol for the discrete Laplacian $L=DG$ is $\\hat{L} = \\hat{d}_x \\hat{g}_x + \\hat{d}_y \\hat{g}_y$.\n\nThe simulation procedure for each test case is as follows:\n1. Initialize the grid, parameters ($N, \\Delta t, h$), and Fourier-space operators ($\\hat{g}_x, \\hat{g}_y, \\hat{d}_x, \\hat{d}_y, \\hat{L}$).\n2. Construct the initial velocity field $u^0$ from the streamfunction $\\psi$. This involves applying centered finite differences.\n3. Calculate the initial kinetic energy $E^{\\text{initial}} = \\frac{1}{2} h^2 \\sum_{i,j} \\left( (u_x^0)^2 + (u_y^0)^2 \\right)$.\n4. Iterate for the prescribed number of time steps:\n    a. Transform the current velocity field $(u_x^n, u_y^n)$ to Fourier space $(\\hat{u}_x^n, \\hat{u}_y^n)$.\n    b. Calculate the divergence in Fourier space: $\\widehat{D u^n} = \\hat{d}_x \\hat{u}_x^n + \\hat{d}_y \\hat{u}_y^n$.\n    c. Solve for the pressure: $\\hat{p}^{n+1} = \\frac{1}{\\Delta t \\hat{L}} \\widehat{D u^n}$. The division by $\\hat{L}$ is performed element-wise, with the division-by-zero at the zero-frequency mode handled by setting the result to zero.\n    d. Update the velocity field directly in Fourier space: $\\hat{u}^{n+1} = \\hat{u}^n - \\Delta t \\, \\hat{G}\\hat{p}^{n+1}$.\n5. After the final step, calculate the final kinetic energy $E^{\\text{final}}$ using the final velocity field transformed back to physical space.\n6. The result for the case is the energy drift $\\Delta E = E^{\\text{final}} - E^{\\text{initial}}$.\n\nFor Operator Set A, the divergence and gradient operators are adjoint, specifically $D_c = -G_c^\\dagger$. The initial velocity field is constructed to be discretely divergence-free with respect to $D_c$, i.e., $D_c u^0 = 0$. Consequently, $p^1$ is constant, its gradient is zero, and $u^1=u^0$. By induction, the velocity field remains constant, and the theoretical energy drift is zero. Any non-zero result is due to floating-point precision error. For Operator Set B, the operators are not adjoint, and the initial field is not discretely divergence-free with respect to $D_f$. Thus, a non-zero energy drift is expected.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational physics problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: N=32, dt=0.1, steps=1000, op set A\n        (32, 0.1, 1000, \"A\"),\n        # Case 2: N=32, dt=0.1, steps=1000, op set B\n        (32, 0.1, 1000, \"B\"),\n        # Case 3: N=8, dt=0.2, steps=400, op set B\n        (8, 0.2, 400, \"B\"),\n        # Case 4: N=32, dt=0.01, steps=1000, op set B\n        (32, 0.01, 1000, \"B\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, dt, num_steps, op_set = case\n        energy_drift = run_simulation(N, dt, num_steps, op_set)\n        results.append(f\"{energy_drift:.10e}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_simulation(N, dt, num_steps, op_set):\n    \"\"\"\n    Performs the simulation for a single test case.\n    \"\"\"\n    # Grid and parameters\n    h = 1.0 / N\n    coords = np.arange(N) * h\n    # Per problem statement indexing: y_i (axis 0), x_j (axis 1)\n    yy, xx = np.meshgrid(coords, coords, indexing='ij')\n\n    # Initial condition from streamfunction\n    # psi(i,j) = sin(2*pi*x_j)sin(2*pi*y_i)\n    psi = np.sin(2 * np.pi * xx) * np.sin(2 * np.pi * yy)\n    \n    # u_x^0 = D_y^c(psi), u_y^0 = -D_x^c(psi)\n    # D_y^c is difference along axis 0 (i)\n    u_x = (np.roll(psi, -1, axis=0) - np.roll(psi, 1, axis=0)) / (2 * h)\n    # D_x^c is difference along axis 1 (j)\n    u_y = -(np.roll(psi, -1, axis=1) - np.roll(psi, 1, axis=1)) / (2 * h)\n\n    # Initial kinetic energy\n    E_initial = 0.5 * h**2 * (np.sum(u_x**2) + np.sum(u_y**2))\n\n    # Fourier space setup\n    k_vals = np.fft.fftfreq(N, d=h)\n    kx, ky = np.meshgrid(k_vals, k_vals, indexing='ij')\n\n    # Fourier symbols for operators\n    # Note: problem statement implies Gp = (D_y^c p, D_x^c p).\n    # This is non-standard. We use the standard Gp = (D_x^c p, D_y^c p).\n    ghat_x = (1j * np.sin(2 * np.pi * kx * h)) / h\n    ghat_y = (1j * np.sin(2 * np.pi * ky * h)) / h\n\n    if op_set == \"A\":\n        dhat_x = ghat_x\n        dhat_y = ghat_y\n    elif op_set == \"B\":\n        dhat_x = (np.exp(2j * np.pi * kx * h) - 1) / h\n        dhat_y = (np.exp(2j * np.pi * ky * h) - 1) / h\n    else:\n        raise ValueError(\"Invalid operator set\")\n\n    # Laplacian symbol L_hat = D_hat * G_hat\n    L_hat = dhat_x * ghat_x + dhat_y * ghat_y\n\n    # Inverse Laplacian, handling the zero-frequency mode\n    L_hat_inv = np.zeros_like(L_hat)\n    non_zero_mask = L_hat != 0\n    L_hat_inv[non_zero_mask] = 1.0 / L_hat[non_zero_mask]\n\n    # Evolve in Fourier space for efficiency\n    u_x_hat = np.fft.fft2(u_x)\n    u_y_hat = np.fft.fft2(u_y)\n\n    # Time-stepping loop\n    for _ in range(num_steps):\n        # div(u) in Fourier space\n        div_u_hat = dhat_x * u_x_hat + dhat_y * u_y_hat\n\n        # p_hat = (1/dt) * (1/L_hat) * div_u_hat\n        p_hat = (1.0 / dt) * L_hat_inv * div_u_hat\n        \n        # Update u_hat: u_hat_new = u_hat - dt * G_hat * p_hat\n        u_x_hat -= dt * ghat_x * p_hat\n        u_y_hat -= dt * ghat_y * p_hat\n        \n    # Transform final velocity back to physical space\n    u_x_final = np.fft.ifft2(u_x_hat).real\n    u_y_final = np.fft.ifft2(u_y_hat).real\n\n    # Final kinetic energy\n    E_final = 0.5 * h**2 * (np.sum(u_x_final**2) + np.sum(u_y_final**2))\n    \n    return E_final - E_initial\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2430781"}, {"introduction": "This final practice showcases the power and flexibility of the projection method framework by adapting it to a different physical regime: flow through a porous medium, modeled by the Brinkman equations. You will modify the standard Navier-Stokes solver to include a Darcy drag term and implement a semi-implicit time-stepping scheme where the viscous term is treated implicitly. This task [@problem_id:2430757] demonstrates how the fundamental predictor-corrector structure can be integrated with more advanced numerical techniques to tackle a wider range of problems in physics and engineering.", "problem": "Consider the incompressible Brinkman flow model on a two-dimensional periodic square domain of side length $L$, governed by the conservation of mass and momentum. The conservation of mass imposes $ \\nabla \\cdot \\vec{u} = 0$. The conservation of momentum in the Brinkman model, for kinematic viscosity $ \\nu > 0 $ and spatially varying permeability $ K(x,y) > 0 $, adds a Darcy drag term, resulting in\n$$\n\\frac{\\partial \\vec{u}}{\\partial t} + (\\vec{u}\\cdot\\nabla)\\vec{u} = -\\nabla p + \\nu \\nabla^2 \\vec{u} - \\frac{\\nu}{K(x,y)} \\vec{u} + \\vec{f},\n$$\nwith periodic boundary conditions in both directions and initial condition $ \\vec{u}(x,y,0) = \\vec{u}_0(x,y)$. All quantities are nondimensional.\n\nYour task is to derive, implement, and test a semi-implicit projection method using a Fourier pseudo-spectral discretization under periodic boundary conditions. The derivation must start from the conservation laws stated above. Specifically:\n\n1. Begin from the divergence-free constraint $ \\nabla \\cdot \\vec{u} = 0 $ and the Brinkman momentum equation. Derive a time-marching scheme that:\n   - Treats the viscous term $ \\nu \\nabla^2 \\vec{u} $ implicitly via a Fourier multiplier.\n   - Treats the nonlinear advection term $ (\\vec{u}\\cdot\\nabla)\\vec{u} $, the Darcy drag term $ -\\nu \\vec{u}/K(x,y) $, and the body force $ \\vec{f} $ explicitly in time.\n   - Enforces incompressibility at each time step using a projection method that computes a pressure-like scalar to correct the intermediate velocity field.\n\n2. Use a uniform grid with $ N \\times N $ points on $ [0,L)\\times[0,L) $ and discrete Fourier transforms to compute spatial derivatives and to solve the implicit viscous substep and the pressure Poisson equation mode-by-mode. Assume $ L = 1 $ and periodicity in both directions. You must use the standard discrete wave numbers $ k_x = 2\\pi n_x $ and $ k_y = 2\\pi n_y $ with $ n_x,n_y \\in \\{ -\\frac{N}{2},\\ldots,\\frac{N}{2}-1 \\} $ scaled appropriately for the domain length.\n\n3. Implement the algorithm to march in time from $ t=0 $ to $ t=T $, with fixed time step $ \\Delta t $, and report the requested diagnostics for the following test suite. All quantities below are nondimensional.\n\nTest suite (use these exact parameters):\n- Grid and domain: $ N = 64 $, $ L = 1 $ for all tests.\n- Time step: $ \\Delta t = 0.002 $ for all tests.\n- Spatial discretization: Fourier pseudo-spectral with periodic boundary conditions in both directions.\n- Initialization: zero velocity unless explicitly specified.\n\nTest 1 (homogeneous permeability, forced flow toward steady Darcy balance):\n- Viscosity: $ \\nu = 1.0 $.\n- Permeability: constant $ K(x,y) \\equiv 0.2 $.\n- Body force: $ \\vec{f} = (1.0, 0.0) $.\n- Initial condition: $ \\vec{u}_0 = (0,0) $.\n- Final time: $ T = 1.0 $.\n- Diagnostic to report: the absolute error between the spatial average of the $ x $-velocity at $ t=T $ and the Darcy-Brinkman steady prediction $ \\overline{u}_x^\\star = (K/\\nu) f_x $. That is, report $ E_1 = \\left| \\langle u_x(\\cdot,\\cdot,T) \\rangle - (K/\\nu) f_x \\right| $ as a float.\n\nTest 2 (spatially varying permeability, incompressibility check):\n- Viscosity: $ \\nu = 1.0 $.\n- Permeability: $ K(x,y) = 0.05 $ for $ x < 0.5 $ and $ K(x,y) = 0.2 $ for $ x \\ge 0.5 $.\n- Body force: $ \\vec{f} = (1.0, 0.0) $.\n- Initial condition: $ \\vec{u}_0 = (0,0) $.\n- Final time: $ T = 1.0 $.\n- Diagnostic to report: the root-mean-square of the divergence at $ t=T $, namely $ E_2 = \\sqrt{ \\langle (\\nabla \\cdot \\vec{u}(\\cdot,\\cdot,T))^2 \\rangle } $ as a float.\n\nTest 3 (homogeneous permeability, unforced decay under Darcy drag):\n- Viscosity: $ \\nu = 1.0 $.\n- Permeability: constant $ K(x,y) \\equiv 0.1 $.\n- Body force: $ \\vec{f} = (0.0, 0.0) $.\n- Initial condition: uniform velocity $ \\vec{u}_0 = (0.4, 0.0) $.\n- Final time: $ T = 0.3 $.\n- Diagnostic to report: the absolute error between the spatial average of the $ x $-velocity at $ t=T $ and the analytic mean-mode decay prediction $ \\overline{u}_x(T) = 0.4 \\exp\\left( - \\nu T / K \\right) $. Report $ E_3 = \\left| \\langle u_x(\\cdot,\\cdot,T) \\rangle - 0.4 \\exp( - \\nu T / K ) \\right| $ as a float.\n\nImplementation and output requirements:\n- Use a semi-implicit projection method based on your derivation.\n- Compute spatial derivatives spectrally using the discrete Fourier transform.\n- All integrals over the domain (spatial averages and norms) must be computed as simple arithmetic means over grid points.\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets: $ [E_1,E_2,E_3] $ with each entry rounded to six decimal places.", "solution": "The problem statement is subjected to validation and is found to be scientifically grounded, well-posed, and complete. It represents a standard numerical problem in computational fluid dynamics. We shall proceed with the derivation and solution.\n\nThe governing equations for the system are the conservation of mass for an incompressible fluid and the Brinkman momentum equation on a two-dimensional periodic domain $[0,L) \\times [0,L)$:\n$$\n\\nabla \\cdot \\vec{u} = 0\n$$\n$$\n\\frac{\\partial \\vec{u}}{\\partial t} + (\\vec{u}\\cdot\\nabla)\\vec{u} = -\\nabla p + \\nu \\nabla^2 \\vec{u} - \\frac{\\nu}{K(x,y)} \\vec{u} + \\vec{f}\n$$\nHere, $\\vec{u} = (u_x, u_y)$ is the velocity field, $p$ is the pressure, $\\nu > 0$ is the kinematic viscosity, $K(x,y) > 0$ is the permeability, and $\\vec{f}$ is an external body force.\n\nWe are tasked to derive and implement a semi-implicit projection method. The time discretization splits the update from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ into two main steps.\n\n**Step 1: Advection-Diffusion-Reaction Step**\n\nFirst, we compute an intermediate velocity field, denoted $\\vec{u}^*$, by advancing the momentum equation forward in time but omitting the pressure gradient term. The scheme treats the viscous term $\\nu \\nabla^2 \\vec{u}$ implicitly for numerical stability, while the nonlinear advection term $(\\vec{u}\\cdot\\nabla)\\vec{u}$, the Darcy drag term $-\\frac{\\nu}{K}\\vec{u}$, and the body force $\\vec{f}$ are treated explicitly. Using a first-order time-stepping scheme (Forward Euler for explicit terms, Backward Euler for the implicit term), we write:\n$$\n\\frac{\\vec{u}^* - \\vec{u}^n}{\\Delta t} = -(\\vec{u}^n\\cdot\\nabla)\\vec{u}^n + \\nu \\nabla^2 \\vec{u}^* - \\frac{\\nu}{K} \\vec{u}^n + \\vec{f}^n\n$$\nLet us group all explicit terms into a single function $\\vec{R}(\\vec{u}^n) = -(\\vec{u}^n\\cdot\\nabla)\\vec{u}^n - \\frac{\\nu}{K}\\vec{u}^n + \\vec{f}^n$. Rearranging the equation to solve for $\\vec{u}^*$ yields a Helmholtz-type equation for each velocity component:\n$$\n(I - \\Delta t \\nu \\nabla^2) \\vec{u}^* = \\vec{u}^n + \\Delta t \\vec{R}(\\vec{u}^n)\n$$\nwhere $I$ is the identity operator. For a problem with periodic boundary conditions, the Fourier pseudo-spectral method is exceptionally efficient. We apply the discrete Fourier transform (DFT), denoted by a hat symbol ($\\hat{\\cdot}$), to this equation. In Fourier space, the Laplacian operator $\\nabla^2$ becomes an algebraic multiplication by $-|\\vec{k}|^2 = -(k_x^2 + k_y^2)$, where $\\vec{k}=(k_x, k_y)$ is the wavevector. The transformed equation is:\n$$\n(1 + \\Delta t \\nu |\\vec{k}|^2) \\hat{\\vec{u}}^*(\\vec{k}) = \\widehat{\\vec{u}^n + \\Delta t \\vec{R}(\\vec{u}^n)}(\\vec{k})\n$$\nWe can solve for the Fourier coefficients of the intermediate velocity $\\hat{\\vec{u}}^*$ directly:\n$$\n\\hat{\\vec{u}}^*(\\vec{k}) = \\frac{\\hat{\\vec{u}}^n(\\vec{k}) + \\Delta t \\hat{\\vec{R}}^n(\\vec{k})}{1 + \\Delta t \\nu |\\vec{k}|^2}\n$$\nThe explicit term $\\vec{R}(\\vec{u}^n)$ is computed using a pseudo-spectral approach. The spatial derivatives required for the advection term $(\\vec{u}^n\\cdot\\nabla)\\vec{u}^n$ are computed by multiplying their Fourier transforms by $i\\vec{k}$. The subsequent vector and scalar products are performed in physical space. After obtaining $\\hat{\\vec{u}}^*$, the intermediate velocity $\\vec{u}^*$ is recovered via an inverse DFT.\n\n**Step 2: Projection Step**\n\nThe intermediate velocity field $\\vec{u}^*$ does not, in general, satisfy the incompressibility constraint $\\nabla \\cdot \\vec{u} = 0$. The projection step corrects $\\vec{u}^*$ to produce a divergence-free field $\\vec{u}^{n+1}$. The relationship between the final velocity $\\vec{u}^{n+1}$, the intermediate velocity $\\vec{u}^*$, and the pressure $p^{n+1}$ is given by:\n$$\n\\frac{\\vec{u}^{n+1} - \\vec{u}^*}{\\Delta t} = -\\nabla p^{n+1}\n$$\nThis equation shows that the sole purpose of the pressure gradient is to project $\\vec{u}^*$ onto the space of divergence-free fields. By enforcing $\\nabla \\cdot \\vec{u}^{n+1} = 0$ and taking the divergence of the equation above, we obtain a Poisson equation for the pressure:\n$$\n\\nabla \\cdot \\vec{u}^{n+1} - \\nabla \\cdot \\vec{u}^* = -\\Delta t \\nabla^2 p^{n+1} \\implies \\nabla^2 p^{n+1} = \\frac{1}{\\Delta t} \\nabla \\cdot \\vec{u}^*\n$$\nThis Poisson equation is also solved in Fourier space. Applying the DFT yields:\n$$\n-|\\vec{k}|^2 \\hat{p}^{n+1}(\\vec{k}) = \\frac{1}{\\Delta t} \\widehat{\\nabla \\cdot \\vec{u}^*}(\\vec{k}) = \\frac{1}{\\Delta t} \\left(i \\vec{k} \\cdot \\hat{\\vec{u}}^*(\\vec{k})\\right)\n$$\nSolving for $\\hat{p}^{n+1}(\\vec{k})$ for $\\vec{k} \\neq \\vec{0}$:\n$$\n\\hat{p}^{n+1}(\\vec{k}) = - \\frac{i}{\\Delta t |\\vec{k}|^2} (\\vec{k} \\cdot \\hat{\\vec{u}}^*(\\vec{k}))\n$$\nThe mean pressure mode $\\hat{p}^{n+1}(\\vec{0})$ is indeterminate and is set to $0$. The velocity is then updated in Fourier space:\n$$\n\\hat{\\vec{u}}^{n+1}(\\vec{k}) = \\hat{\\vec{u}}^*(\\vec{k}) - \\Delta t (i\\vec{k}) \\hat{p}^{n+1}(\\vec{k})\n$$\nSubstituting the expression for $\\hat{p}^{n+1}(\\vec{k})$ gives the final projection formula for $\\vec{k} \\neq \\vec{0}$:\n$$\n\\hat{\\vec{u}}^{n+1}(\\vec{k}) = \\hat{\\vec{u}}^*(\\vec{k}) - \\Delta t (i\\vec{k}) \\left(- \\frac{i}{\\Delta t |\\vec{k}|^2} (\\vec{k} \\cdot \\hat{\\vec{u}}^*(\\vec{k}))\\right) = \\hat{\\vec{u}}^*(\\vec{k}) - \\frac{\\vec{k}(\\vec{k} \\cdot \\hat{\\vec{u}}^*(\\vec{k}))}{|\\vec{k}|^2}\n$$\nFor the mean mode $\\vec{k}=\\vec{0}$, the correction term is zero, so $\\hat{\\vec{u}}^{n+1}(\\vec{0}) = \\hat{\\vec{u}}^*(\\vec{0})$. This operation corresponds to applying the Hodge-Helmholtz decomposition, subtracting the gradient part of $\\vec{u}^*$ to leave a solenoidal field. The final velocity $\\vec{u}^{n+1}$ is obtained by applying the inverse DFT to $\\hat{\\vec{u}}^{n+1}$. This two-step cycle is repeated until the final time $T$ is reached.", "answer": "```python\nimport numpy as np\n\ndef simulate_brinkman(N, L, dt, T, nu, K, f_func, u0_func):\n    \"\"\"\n    Solves the 2D incompressible Brinkman equations using a Fourier pseudo-spectral\n    semi-implicit projection method on a periodic domain.\n\n    Args:\n        N (int): Number of grid points in each direction.\n        L (float): Side length of the square domain [0, L) x [0, L).\n        dt (float): Time step size.\n        T (float): Final time.\n        nu (float): Kinematic viscosity.\n        K (np.ndarray): Permeability field (N x N array).\n        f_func (function): Function returning the body force vector (fx, fy).\n        u0_func (function): Function returning the initial velocity vector (u0x, u0y).\n\n    Returns:\n        tuple: Final velocity fields (ux, uy).\n    \"\"\"\n    # Grid and wavenumbers\n    x = np.linspace(0, L, N, endpoint=False)\n    y = np.linspace(0, L, N, endpoint=False)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Wavenumbers for spatial derivatives\n    # Frequencies are in cycles per unit length\n    freq = np.fft.fftfreq(N, d=L/N)\n    # Wavenumbers are 2*pi*frequency\n    k = 2 * np.pi * freq\n    KX, KY = np.meshgrid(k, k, indexing='ij')\n    K_sq = KX**2 + KY**2\n\n    # Avoid division by zero for the k=0 mode in the projection step\n    K_sq_inv = np.zeros_like(K_sq)\n    nonzero_k = K_sq > 1e-12\n    K_sq_inv[nonzero_k] = 1.0 / K_sq[nonzero_k]\n\n    # Pre-calculate the denominator for the implicit viscous solve\n    helmholtz_denom = 1.0 + nu * dt * K_sq\n\n    # Initial conditions\n    ux, uy = u0_func(X, Y, N)\n    \n    # Body force\n    fx, fy = f_func(X, Y, N)\n\n    # Time-stepping loop\n    num_steps = int(np.ceil(T / dt))\n    for step in range(num_steps):\n        # --- Step 1: Intermediate velocity u* ---\n\n        # Compute explicit terms (advection, Darcy drag)\n        ux_hat = np.fft.fft2(ux)\n        uy_hat = np.fft.fft2(uy)\n\n        # Derivatives for advection term\n        duxdx = np.fft.ifft2(1j * KX * ux_hat).real\n        duxdy = np.fft.ifft2(1j * KY * ux_hat).real\n        duydx = np.fft.ifft2(1j * KX * uy_hat).real\n        duydy = np.fft.ifft2(1j * KY * uy_hat).real\n        \n        # Advection term components in physical space\n        adv_x = ux * duxdx + uy * duxdy\n        adv_y = ux * duydx + uy * duydy\n\n        # Sum of all explicit terms (R vector)\n        Rx = -adv_x - (nu / K) * ux + fx\n        Ry = -adv_y - (nu / K) * uy + fy\n\n        # Form RHS for Helmholtz solve: u_star = (u^n + dt*R) / (1 - dt*nu*lap)\n        rhs_x = ux + dt * Rx\n        rhs_y = uy + dt * Ry\n        \n        # Solve for u_star in Fourier space\n        ux_star_hat = np.fft.fft2(rhs_x) / helmholtz_denom\n        uy_star_hat = np.fft.fft2(rhs_y) / helmholtz_denom\n\n        # --- Step 2: Projection ---\n\n        # Project intermediate velocity to be divergence-free\n        # This is done entirely in Fourier space\n        k_dot_u_star = KX * ux_star_hat + KY * uy_star_hat\n        \n        # Subtract the gradient part\n        ux_new_hat = ux_star_hat - k_dot_u_star * KX * K_sq_inv\n        uy_new_hat = uy_star_hat - k_dot_u_star * KY * K_sq_inv\n\n        # Transform back to physical space for the next step\n        ux = np.fft.ifft2(ux_new_hat).real\n        uy = np.fft.ifft2(uy_new_hat).real\n\n    return ux, uy\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    # Global parameters\n    N = 64\n    L = 1.0\n    dt = 0.002\n    \n    results = []\n\n    # --- Test 1 ---\n    T1 = 1.0\n    nu1 = 1.0\n    K1_val = 0.2\n    K1 = np.full((N, N), K1_val)\n    f1_x, f1_y = 1.0, 0.0\n    def f1_func(X, Y, N): return np.full((N,N), f1_x), np.full((N,N), f1_y)\n    def u0_1_func(X, Y, N): return np.zeros((N, N)), np.zeros((N, N))\n    \n    ux1, uy1 = simulate_brinkman(N, L, dt, T1, nu1, K1, f1_func, u0_1_func)\n    \n    mean_ux1 = np.mean(ux1)\n    steady_pred1 = (K1_val / nu1) * f1_x\n    E1 = np.abs(mean_ux1 - steady_pred1)\n    results.append(f\"{E1:.6f}\")\n\n    # --- Test 2 ---\n    T2 = 1.0\n    nu2 = 1.0\n    K2 = np.full((N, N), 0.2)\n    K2[:N//2, :] = 0.05\n    f2_x, f2_y = 1.0, 0.0\n    def f2_func(X, Y, N): return np.full((N,N), f2_x), np.full((N,N), f2_y)\n    def u0_2_func(X, Y, N): return np.zeros((N, N)), np.zeros((N, N))\n\n    ux2, uy2 = simulate_brinkman(N, L, dt, T2, nu2, K2, f2_func, u0_2_func)\n    \n    # Calculate divergence spectrally\n    freq = np.fft.fftfreq(N, d=L/N)\n    k = 2 * np.pi * freq\n    KX, KY = np.meshgrid(k, k, indexing='ij')\n    \n    ux2_hat = np.fft.fft2(ux2)\n    uy2_hat = np.fft.fft2(uy2)\n    div_u_hat = 1j * KX * ux2_hat + 1j * KY * uy2_hat\n    div_u = np.fft.ifft2(div_u_hat).real\n    \n    E2 = np.sqrt(np.mean(div_u**2))\n    results.append(f\"{E2:.6f}\")\n\n    # --- Test 3 ---\n    T3 = 0.3\n    nu3 = 1.0\n    K3_val = 0.1\n    K3 = np.full((N, N), K3_val)\n    f3_x, f3_y = 0.0, 0.0\n    u0_3_val = 0.4\n    def f3_func(X, Y, N): return np.zeros((N,N)), np.zeros((N,N))\n    def u0_3_func(X, Y, N): return np.full((N, N), u0_3_val), np.zeros((N, N))\n    \n    ux3, uy3 = simulate_brinkman(N, L, dt, T3, nu3, K3, f3_func, u0_3_func)\n    \n    mean_ux3 = np.mean(ux3)\n    analytic_pred3 = u0_3_val * np.exp(-nu3 * T3 / K3_val)\n    E3 = np.abs(mean_ux3 - analytic_pred3)\n    results.append(f\"{E3:.6f}\")\n    \n    # Final output format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2430757"}]}