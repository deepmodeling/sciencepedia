{"hands_on_practices": [{"introduction": "The first step in understanding a system governed by a pair potential, such as the Lennard-Jones potential, is often to analyze its potential energy landscape. This exercise [@problem_id:2423729] provides a hands-on introduction to energy minimization by having you calculate and compare the ground state energies for two highly symmetric cluster configurations. Through this process, you will discover how the geometry of a particle arrangement directly determines its stability and will derive the optimal structure from first principles.", "problem": "You are to write a complete, runnable program that, in reduced Lennard–Jones (LJ) units, determines and compares the minimum pairwise potential energies for two highly symmetric configurations of a cluster of $N=13$ particles interacting via the Lennard–Jones pair potential. The two configurations are the $N=13$ icosahedral cluster and the $N=13$ Face-Centered Cubic (FCC) cuboctahedral cluster, each consisting of a single particle at the origin surrounded by $12$ particles placed at the vertices of the corresponding polyhedron. All energies must be reported in reduced LJ energy units (that is, in units of $\\varepsilon$), all distances must be in reduced LJ distance units (that is, in units of $\\sigma$), and any angles, if used, must be in radians.\n\nFundamental base:\n- The Lennard–Jones pair potential between two particles separated by a distance $r$ is\n$$\nU(r)=4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^{6}\\right].\n$$\n- For a system of $N$ particles at positions $\\{\\mathbf{r}_i\\}_{i=1}^{N}$, the total potential energy is\n$$\nE=\\sum_{1\\le i&lt;j\\le N}U\\!\\left(\\left\\lVert \\mathbf{r}_i-\\mathbf{r}_j\\right\\rVert\\right).\n$$\n- Rigid translations and rotations do not change any interparticle distances, hence the total energy is invariant under rigid motions.\n\nYour task is to:\n- Construct coordinates for the two $N=13$ templates:\n  - Icosahedral: one particle at the origin and $12$ at the vertices of a regular icosahedron defined by the canonical Cartesian coordinate set $\\{(0,\\pm 1,\\pm \\varphi),(\\pm 1,\\pm \\varphi,0),(\\pm \\varphi,0,\\pm 1)\\}$ where $\\varphi=(1+\\sqrt{5})/2$.\n  - Face-Centered Cubic (FCC) cuboctahedral: one particle at the origin and $12$ at the vertices given by all distinct permutations of $(0,\\pm 1,\\pm 1)$.\n- Treat each template as a uniformly scaled configuration by a single positive scale factor $s&gt;0$, applied to all coordinates.\n- Starting only from the definitions above, derive the total energy of a uniformly scaled configuration as a function of $s$, and use this to determine the $s$ that minimizes the total energy for each template. Express all results in reduced LJ units by setting $\\varepsilon=\\sigma=1$.\n- Scientifically justify why the energy is invariant under rigid rotations and translations.\n\nNumerical and algorithmic requirements:\n- Implement the algorithm to compute the sums\n$$\nS_6=\\sum_{1\\le i&lt;j\\le N}\\frac{1}{r_{ij,0}^{6}},\\qquad S_{12}=\\sum_{1\\le i&lt;j\\le N}\\frac{1}{r_{ij,0}^{12}},\n$$\nwhere $r_{ij,0}$ are pair distances in the unscaled template ($s=1$). Use these to determine the energy-minimizing scale factor $s^\\star$ for each template and the corresponding minimized energy. All calculations must be performed in reduced units with $\\varepsilon=\\sigma=1$.\n- Verify energy invariance by computing the energy after a fixed rigid rotation and a fixed rigid translation of the optimized icosahedral configuration. Use the rotation of angle $\\theta=0.789$ about the axis proportional to $(1,2,3)$, and the translation vector $(0.3,-1.1,2.0)$. Angles must be in radians.\n\nTest suite and output specification:\n- Use the following test cases and produce the requested outputs in the specified order. The final output must be a single line containing a comma-separated Python-style list with no extra text. The list must contain:\n  1. The minimized total energy for the icosahedral configuration (a float).\n  2. The minimized total energy for the FCC cuboctahedral configuration (a float).\n  3. A boolean indicating whether the icosahedral minimized energy is strictly lower than the FCC cuboctahedral minimized energy.\n  4. A boolean indicating whether the energy of the icosahedral configuration is invariant under the specified rigid rotation (within a tolerance of $10^{-10}$ absolute energy units).\n  5. A boolean indicating whether the energy of the icosahedral configuration is invariant under the specified rigid translation (within a tolerance of $10^{-10}$ absolute energy units).\n  6. A boolean indicating whether, for the icosahedral configuration, the energy at $s=0.5\\,s^\\star$ is higher than the minimized energy.\n  7. A boolean indicating whether, for the icosahedral configuration, the energy at $s=2.0\\,s^\\star$ is higher than the minimized energy.\n- Angle input is in radians. Energies must be expressed in reduced LJ energy units (that is, in units of $\\varepsilon$). Distances are in reduced LJ distance units (that is, in units of $\\sigma$).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, \"[result1,result2,result3,result4,result5,result6,result7]\". Floats must be printed to exactly $8$ digits after the decimal point.\n\nEnsure scientific realism and internal consistency at all steps. Your program must be fully deterministic, require no user input, and run as given.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of computational physics, specifically using the Lennard-Jones potential to model atomic cluster energetics. The problem is well-posed, providing all necessary definitions, constants, and clear objectives for a deterministic solution. Its language is objective and its structure is logically consistent, free from contradictions or ambiguities.\n\nThe total potential energy $E$ for a system of $N$ particles interacting via the Lennard-Jones (LJ) pair potential is given by the sum over all unique pairs of particles $(i, j)$:\n$$\nE = \\sum_{1 \\le i < j \\le N} U(\\left\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\right\\rVert)\n$$\nIn reduced units, where the energy unit $\\varepsilon=1$ and the length unit $\\sigma=1$, the LJ potential simplifies to:\n$$\nU(r) = 4 \\left[ \\left(\\frac{1}{r}\\right)^{12} - \\left(\\frac{1}{r}\\right)^{6} \\right]\n$$\nThe problem considers configurations generated by uniformly scaling a base template of coordinates $\\{\\mathbf{r}_{i,0}\\}$ by a positive factor $s > 0$. The position of the $i$-th particle is $\\mathbf{r}_i = s \\cdot \\mathbf{r}_{i,0}$. The distance $r_{ij}$ between particles $i$ and $j$ is thus also scaled by $s$:\n$$\nr_{ij} = \\left\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\right\\rVert = \\left\\lVert s \\cdot \\mathbf{r}_{i,0} - s \\cdot \\mathbf{r}_{j,0} \\right\\rVert = s \\left\\lVert \\mathbf{r}_{i,0} - \\mathbf{r}_{j,0} \\right\\rVert = s \\cdot r_{ij,0}\n$$\nwhere $r_{ij,0}$ is the distance in the unscaled template (i.e., for $s=1$).\n\nSubstituting this scaled distance into the energy expression, the total energy $E$ becomes a function of $s$:\n$$\nE(s) = \\sum_{1 \\le i < j \\le N} 4 \\left[ \\left(\\frac{1}{s \\cdot r_{ij,0}}\\right)^{12} - \\left(\\frac{1}{s \\cdot r_{ij,0}}\\right)^{6} \\right]\n$$\nBy factoring out the terms involving $s$, we can separate the geometry of the cluster from the scaling:\n$$\nE(s) = 4 \\left[ \\frac{1}{s^{12}} \\sum_{1 \\le i < j \\le N} \\frac{1}{r_{ij,0}^{12}} - \\frac{1}{s^6} \\sum_{1 \\le i < j \\le N} \\frac{1}{r_{ij,0}^6} \\right]\n$$\nWe define the geometric sums $S_{12}$ and $S_6$, which depend only on the fixed template geometry:\n$$\nS_{12} = \\sum_{1 \\le i < j \\le N} \\frac{1}{r_{ij,0}^{12}}, \\qquad S_6 = \\sum_{1 \\le i < j \\le N} \\frac{1}{r_{ij,0}^6}\n$$\nThe total energy as a function of the scale factor $s$ is then elegantly expressed as:\n$$\nE(s) = 4 \\left( \\frac{S_{12}}{s^{12}} - \\frac{S_6}{s^6} \\right)\n$$\nTo find the scale factor $s^\\star$ that minimizes the energy, we must solve for $s$ where the derivative of $E(s)$ with respect to $s$ is zero:\n$$\n\\frac{dE}{ds} = 4 \\left( -12 \\frac{S_{12}}{s^{13}} + 6 \\frac{S_6}{s^7} \\right) = 0\n$$\nSolving for $s$ (which we denote $s^\\star$) gives:\n$$\n12 \\frac{S_{12}}{(s^\\star)^{13}} = 6 \\frac{S_6}{(s^\\star)^7} \\implies 2 S_{12} = S_6 (s^\\star)^6 \\implies (s^\\star)^6 = \\frac{2 S_{12}}{S_6}\n$$\nThe optimal scale factor is therefore:\n$$\ns^\\star = \\left( \\frac{2 S_{12}}{S_6} \\right)^{1/6}\n$$\nThe minimum energy $E^\\star = E(s^\\star)$ is found by substituting $(s^\\star)^6$ and $(s^\\star)^{12} = ( (s^\\star)^6 )^2 = \\left(\\frac{2 S_{12}}{S_6}\\right)^2$ back into the energy function:\n$$\nE^\\star = 4 \\left( S_{12} \\left[ \\left(\\frac{S_6}{2 S_{12}}\\right)^2 \\right] - S_6 \\left[ \\frac{S_6}{2 S_{12}} \\right] \\right) = 4 \\left( \\frac{S_6^2}{4 S_{12}} - \\frac{S_6^2}{2 S_{12}} \\right) = 4 \\left( -\\frac{S_6^2}{4 S_{12}} \\right)\n$$\nThis simplifies to the minimal potential energy for the scaled structure:\n$$\nE^\\star = -\\frac{S_6^2}{S_{12}}\n$$\nThis fundamental result shows that the minimum energy is determined entirely by the geometric properties of the unscaled particle configuration.\n\nThe invariance of the total energy under rigid motions (translations and rotations) is a direct consequence of the potential depending only on interparticle distances.\n- **Translation Invariance**: Let each particle's position vector $\\mathbf{r}_i$ be shifted by a constant vector $\\mathbf{v}$ to a new position $\\mathbf{r}_i' = \\mathbf{r}_i + \\mathbf{v}$. The vector difference between any two particles remains unchanged: $\\mathbf{r}_i' - \\mathbf{r}_j' = (\\mathbf{r}_i + \\mathbf{v}) - (\\mathbf{r}_j + \\mathbf{v}) = \\mathbf{r}_i - \\mathbf{r}_j$. Consequently, the distance $\\left\\lVert \\mathbf{r}_i' - \\mathbf{r}_j' \\right\\rVert = \\left\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\right\\rVert$ is invariant. Since all pairwise distances are unchanged, the total energy $E$ is unchanged.\n- **Rotation Invariance**: Let each particle's position vector $\\mathbf{r}_i$ be transformed by a rotation matrix $R$, giving a new position $\\mathbf{r}_i' = R \\mathbf{r}_i$. Rotations are isometries, meaning they preserve distances. The squared distance between two rotated points is $\\left\\lVert \\mathbf{r}_i' - \\mathbf{r}_j' \\right\\rVert^2 = \\left\\lVert R(\\mathbf{r}_i - \\mathbf{r}_j) \\right\\rVert^2 = (\\mathbf{r}_i - \\mathbf{r}_j)^T R^T R (\\mathbf{r}_i - \\mathbf{r}_j)$. Since $R$ is an orthogonal matrix, $R^T R = I$ (the identity matrix), so $\\left\\lVert \\mathbf{r}_i' - \\mathbf{r}_j' \\right\\rVert^2 = \\left\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\right\\rVert^2$. The scalar distances are preserved, and thus the total energy $E$ is invariant.\n\nThe computational procedure is as follows:\n1.  Generate the unscaled coordinates for the $N=13$ icosahedral and FCC cuboctahedral clusters. The icosahedral vertices use the golden ratio $\\varphi = (1+\\sqrt{5})/2$.\n2.  For each template, compute all unique pairwise distances $r_{ij,0}$ and use them to calculate the geometric sums $S_6$ and $S_{12}$.\n3.  Calculate the minimized energy $E^\\star$ for each configuration using the derived formula $E^\\star = -S_6^2 / S_{12}$.\n4.  For the icosahedral cluster, calculate the optimal scale factor $s^\\star_{ico}$ and scale the template coordinates to obtain the energy-minimized positions $\\{\\mathbf{r}_i^\\star\\}$.\n5.  Verify energy invariance by applying the specified rotation (angle $\\theta=0.789$ rad about axis $(1,2,3)$) and translation (vector $(0.3,-1.1,2.0)$) to the optimized icosahedral coordinates. The energy of the transformed coordinates is computed and compared to the original minimized energy within a tolerance of $10^{-10}$.\n6.  Finally, the energy of the icosahedral configuration is computed at $s = 0.5 s^\\star_{ico}$ and $s = 2.0 s^\\star_{ico}$ to confirm that these energies are higher than the minimum, as expected from the nature of the potential well.\nAll calculations are performed in reduced LJ units ($\\varepsilon=1$, $\\sigma=1$).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\nfrom scipy.spatial.distance import pdist\n\ndef solve():\n    \"\"\"\n    Computes and compares the minimum potential energies for N=13\n    Lennard-Jones clusters in icosahedral and FCC cuboctahedral configurations.\n    \"\"\"\n\n    def get_cluster_coordinates(name: str) -> np.ndarray:\n        \"\"\"Generates the template coordinates for a given cluster type.\"\"\"\n        if name == 'icosahedron':\n            phi = (1.0 + np.sqrt(5.0)) / 2.0\n            vertices = [\n                (0, 1, phi), (0, 1, -phi), (0, -1, phi), (0, -1, -phi),\n                (1, phi, 0), (1, -phi, 0), (-1, phi, 0), (-1, -phi, 0),\n                (phi, 0, 1), (-phi, 0, 1), (phi, 0, -1), (-phi, 0, -1)\n            ]\n        elif name == 'fcc_cuboctahedron':\n            vertices = [\n                (1, 1, 0), (1, -1, 0), (-1, 1, 0), (-1, -1, 0),\n                (1, 0, 1), (1, 0, -1), (-1, 0, 1), (-1, 0, -1),\n                (0, 1, 1), (0, 1, -1), (0, -1, 1), (0, -1, -1)\n            ]\n        else:\n            raise ValueError(\"Unknown cluster name\")\n\n        coords = np.array([(0.0, 0.0, 0.0)] + vertices, dtype=np.float64)\n        return coords\n\n    def compute_geometric_sums(coords: np.ndarray) -> tuple[float, float]:\n        \"\"\"Computes the geometric sums S6 and S12 from coordinates.\"\"\"\n        # pdist computes the condensed distance matrix (upper triangle)\n        distances = pdist(coords)\n        \n        # Element-wise exponentiation\n        inv_dists_6 = np.power(distances, -6)\n        inv_dists_12 = np.power(distances, -12)\n\n        s6 = np.sum(inv_dists_6)\n        s12 = np.sum(inv_dists_12)\n        \n        return s6, s12\n\n    def calculate_total_energy(coords: np.ndarray) -> float:\n        \"\"\"Computes the total LJ potential energy for a set of coordinates.\"\"\"\n        distances = pdist(coords)\n        inv_dists_6 = np.power(distances, -6)\n        inv_dists_12 = np.power(distances, -12)\n        energy = 4.0 * (np.sum(inv_dists_12) - np.sum(inv_dists_6))\n        return energy\n\n    # --- Icosahedral Cluster ---\n    coords_ico_0 = get_cluster_coordinates('icosahedron')\n    S6_ico, S12_ico = compute_geometric_sums(coords_ico_0)\n    E_ico_min = -S6_ico**2 / S12_ico\n    s_ico_star = (2 * S12_ico / S6_ico)**(1/6)\n\n    # --- FCC Cuboctahedral Cluster ---\n    coords_fcc_0 = get_cluster_coordinates('fcc_cuboctahedron')\n    S6_fcc, S12_fcc = compute_geometric_sums(coords_fcc_0)\n    E_fcc_min = -S6_fcc**2 / S12_fcc\n\n    # 1. Minimized energy for icosahedral configuration\n    result1 = E_ico_min\n    \n    # 2. Minimized energy for FCC cuboctahedral configuration\n    result2 = E_fcc_min\n\n    # 3. Boolean: Is icosahedral energy lower than FCC?\n    result3 = result1 < result2\n\n    # --- Verification for Icosahedral Cluster ---\n    coords_ico_opt = coords_ico_0 * s_ico_star\n    E_ref = calculate_total_energy(coords_ico_opt)\n\n    # 4. Rotation Invariance Test\n    theta = 0.789\n    axis = np.array([1.0, 2.0, 3.0])\n    rot_vec = theta * axis / np.linalg.norm(axis)\n    rotation = Rotation.from_rotvec(rot_vec)\n    coords_ico_rot = rotation.apply(coords_ico_opt)\n    E_rot = calculate_total_energy(coords_ico_rot)\n    result4 = np.isclose(E_ref, E_rot, rtol=0, atol=1e-10)\n\n    # 5. Translation Invariance Test\n    trans_vec = np.array([0.3, -1.1, 2.0])\n    coords_ico_trans = coords_ico_opt + trans_vec\n    E_trans = calculate_total_energy(coords_ico_trans)\n    result5 = np.isclose(E_ref, E_trans, rtol=0, atol=1e-10)\n    \n    # --- Energy Landscape Test for Icosahedral Cluster ---\n    # Energy function E(s) = 4 * (S12/s^12 - S6/s^6)\n    \n    # 6. Energy at s = 0.5 * s_star\n    s1 = 0.5 * s_ico_star\n    E_s1 = 4.0 * (S12_ico / s1**12 - S6_ico / s1**6)\n    result6 = E_s1 > E_ico_min\n\n    # 7. Energy at s = 2.0 * s_star\n    s2 = 2.0 * s_ico_star\n    E_s2 = 4.0 * (S12_ico / s2**12 - S6_ico / s2**6)\n    result7 = E_s2 > E_ico_min\n\n    results = [result1, result2, result3, result4, result5, result6, result7]\n\n    # Format the final output string\n    formatted_results = [\n        f\"{results[0]:.8f}\",\n        f\"{results[1]:.8f}\",\n        str(results[2]),\n        str(results[3]),\n        str(results[4]),\n        str(results[5]),\n        str(results[6])\n    ]\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "2423729"}, {"introduction": "Moving from static structures to thermodynamics, we can explore how microscopic pair potentials determine the macroscopic, observable properties of matter. This practice [@problem_id:2423726] uses an exactly solvable one-dimensional fluid model to bridge the gap between the microscopic and macroscopic worlds. You will apply fundamental principles of statistical mechanics to derive bulk properties like density and compressibility directly from the parameters of a square-well interaction potential.", "problem": "Consider a one-dimensional system of identical particles of hard-core diameter $\\sigma&gt;0$ constrained to move on a line. The pairwise interaction potential between two particle centers separated by a distance $r$ is a square-well potential given by\n$$\nu(r)=\n\\begin{cases}\n+\\infty, & r&lt;\\sigma,\\\\\n-\\varepsilon, & \\sigma\\le r&lt;\\lambda\\sigma,\\\\\n0, & r\\ge \\lambda\\sigma,\n\\end{cases}\n$$\nwith well depth $\\varepsilon\\ge 0$ and range parameter $\\lambda$ satisfying $1&lt;\\lambda\\le 2$. The system is in the isothermal-isobaric ensemble at absolute temperature $T$ and external pressure $P$. Let $\\beta=1/(k_{\\mathrm{B}}T)$, where $k_{\\mathrm{B}}$ is the Boltzmann constant.\n\nBecause of the one-dimensional ordering and the condition $1&lt;\\lambda\\le 2$, only nearest-neighbor pairs can interact attractively. In the isothermal-isobaric ensemble, define the nearest-neighbor center-to-center separation random variable $r\\ge \\sigma$, with probability density proportional to $\\exp[-\\beta u(r)]\\exp[-\\beta P r]$.\n\nDefine the following dimensionless observables:\n- The reduced number density $\\rho^\\ast=\\rho\\,\\sigma$, where $\\rho$ is the number density of particle centers (number per unit length).\n- The zero-wavenumber static structure factor $S(0)=\\rho\\,k_{\\mathrm{B}}T\\,\\kappa_T$, where $\\kappa_T$ is the isothermal compressibility at fixed temperature.\n\nYou must:\n1. Use $\\sigma$ as the unit of length. All distances in intermediate derivations should be understood relative to $\\sigma$. Report all outputs as dimensionless numbers.\n2. Treat the system exactly within the isothermal-isobaric ensemble under the stated assumptions. Starting from the fundamental statistical mechanical definitions, express the necessary partition function for a single nearest-neighbor separation and obtain $\\langle r\\rangle$ and $\\mathrm{Var}(r)$ from derivatives of the appropriate cumulant-generating function. Use these to compute $\\rho^\\ast=\\sigma/\\langle r\\rangle$ and $S(0)=\\mathrm{Var}(r)/\\langle r\\rangle^2$.\n3. For each parameter set in the test suite below, compute $(\\rho^\\ast,S(0))$ and round each numerical result to six decimal places.\n\nTest suite (each case is specified by $(\\beta\\varepsilon,\\lambda,\\beta P \\sigma)$):\n- Case A: $(0.0,\\,1.5,\\,1.0)$\n- Case B: $(1.0,\\,1.5,\\,1.0)$\n- Case C: $(3.0,\\,1.5,\\,1.0)$\n- Case D: $(1.0,\\,2.0,\\,1.0)$\n- Case E: $(1.0,\\,1.5,\\,0.1)$\n- Case F: $(1.0,\\,1.5,\\,10.0)$\n\nFinal output format:\n- Your program should produce a single line of output containing a comma-separated list of six entries, each entry being a two-element list $[\\rho^\\ast,S(0)]$ corresponding to Cases A through F in order. The entire output must be a single list enclosed in square brackets, with no spaces. For example, an output with two hypothetical entries would look like: `[[0.500000,0.250000],[0.600000,0.200000],...]`.", "solution": "The problem statement is subjected to validation and is found to be scientifically grounded, well-posed, and self-contained. It describes a standard, exactly solvable model in one-dimensional statistical mechanics. All provided definitions and relations are correct. No inconsistencies or ambiguities are detected. We may therefore proceed with the derivation and solution.\n\nThe system consists of particles on a line interacting via a square-well potential. Due to the one-dimensional ordering and the range constraint $1 < \\lambda \\le 2$, only nearest-neighbor interactions are non-zero. The system is in the isothermal-isobaric (NPT) ensemble. The problem seeks to determine the reduced number density $\\rho^\\ast$ and the zero-wavenumber static structure factor $S(0)$.\n\nFirst, we work in dimensionless units as instructed. Let the hard-core diameter $\\sigma$ be the unit of length. We define the dimensionless separation as $x = r/\\sigma$. The thermodynamic parameters are made dimensionless as $\\varepsilon^* = \\beta \\varepsilon$ and $P^* = \\beta P \\sigma$. The potential energy $u(x)$ in these units is:\n$$\n\\beta u(x\\sigma)=\n\\begin{cases}\n+\\infty, & x<1,\\\\\n-\\varepsilon^*, & 1 \\le x < \\lambda,\\\\\n0, & x \\ge 1,\n\\end{cases}\n$$\nwhere $x \\ge 1$ due to the hard-core repulsion.\n\nThe probability density function for the nearest-neighbor separation $x$ is proportional to the Boltzmann factor for the energy of a single separation in the isobaric ensemble, which is $u(x\\sigma) + P r = u(x\\sigma) + (P\\sigma)x$. The associated partition function for a single separation, which we denote $I(P^*, \\varepsilon^*, \\lambda)$, is given by the integral over all possible separations $x \\ge 1$:\n$$\nI(P^*) = \\int_1^\\infty \\exp[-\\beta u(x\\sigma) - P^* x] dx\n$$\nThe integral is split based on the piecewise definition of the potential:\n$$\nI(P^*) = \\int_1^{\\lambda} \\exp[-(-\\varepsilon^*)] \\exp[-P^* x] dx + \\int_{\\lambda}^{\\infty} \\exp[-0] \\exp[-P^* x] dx\n$$\n$$\nI(P^*) = e^{\\varepsilon^*} \\int_1^{\\lambda} e^{-P^* x} dx + \\int_{\\lambda}^{\\infty} e^{-P^* x} dx\n$$\nFor $P^* > 0$, these standard exponential integrals evaluate to:\n$$\n\\int_1^{\\lambda} e^{-P^* x} dx = \\frac{1}{P^*} (e^{-P^*} - e^{-P^*\\lambda})\n$$\n$$\n\\int_{\\lambda}^{\\infty} e^{-P^* x} dx = \\frac{1}{P^*} e^{-P^*\\lambda}\n$$\nSubstituting these results, we obtain the expression for the partition function:\n$$\nI(P^*) = e^{\\varepsilon^*} \\left[ \\frac{1}{P^*} (e^{-P^*} - e^{-P^*\\lambda}) \\right] + \\frac{1}{P^*} e^{-P^*\\lambda} = \\frac{1}{P^*} \\left[ e^{\\varepsilon^*-P^*} - (e^{\\varepsilon^*}-1)e^{-P^*\\lambda} \\right]\n$$\nThe logarithm of this function, $\\ln I(P^*)$, is the cumulant-generating function for the random variable $x$ with respect to the parameter $-P^*$. The cumulants, which are the mean $\\langle x \\rangle$ and variance $\\mathrm{Var}(x)$, can be obtained by differentiation.\nThe first cumulant is the mean value $\\langle x \\rangle$:\n$$\n\\langle x \\rangle = -\\frac{\\partial}{\\partial P^*} \\ln I(P^*)\n$$\nThe second cumulant is the variance $\\mathrm{Var}(x) = \\langle x^2 \\rangle - \\langle x \\rangle^2$:\n$$\n\\mathrm{Var}(x) = \\frac{\\partial^2}{\\partial (P^*)^2} \\ln I(P^*) = -\\frac{\\partial \\langle x \\rangle}{\\partial P^*}\n$$\nFirst, we compute $\\ln I(P^*)$:\n$$\n\\ln I(P^*) = -\\ln P^* + \\ln \\left( e^{\\varepsilon^*-P^*} - (e^{\\varepsilon^*}-1)e^{-P^*\\lambda} \\right)\n$$\nDifferentiating with respect to $P^*$ to find $\\langle x \\rangle$:\n$$\n\\langle x \\rangle = -\\left[ -\\frac{1}{P^*} + \\frac{-e^{\\varepsilon^*-P^*} - (e^{\\varepsilon^*}-1)(-\\lambda)e^{-P^*\\lambda}}{e^{\\varepsilon^*-P^*} - (e^{\\varepsilon^*}-1)e^{-P^*\\lambda}} \\right] = \\frac{1}{P^*} + \\frac{e^{\\varepsilon^*-P^*} - \\lambda(e^{\\varepsilon^*}-1)e^{-P^*\\lambda}}{e^{\\varepsilon^*-P^*} - (e^{\\varepsilon^*}-1)e^{-P^*\\lambda}}\n$$\nTo find the variance, we differentiate $\\langle x \\rangle$ with respect to $P^*$ and take the negative. Let $D_0 = e^{\\varepsilon^*-P^*} - (e^{\\varepsilon^*}-1)e^{-P^*\\lambda}$. Then $\\langle x \\rangle = 1/P^* + N_1/D_0$, where $N_1 = e^{\\varepsilon^*-P^*} - \\lambda(e^{\\varepsilon^*}-1)e^{-P^*\\lambda}$.\n$$\n\\mathrm{Var}(x) = -\\frac{\\partial \\langle x \\rangle}{\\partial P^*} = -\\left(-\\frac{1}{(P^*)^2} + \\frac{\\partial}{\\partial P^*}\\left(\\frac{N_1}{D_0}\\right)\\right) = \\frac{1}{(P^*)^2} - \\frac{N_1'D_0 - N_1D_0'}{D_0^2}\n$$\nAfter performing the differentiation and considerable algebraic simplification, the numerator of the fraction becomes:\n$$\nN_1'D_0 - N_1D_0' = (\\lambda - 1)^2 (e^{\\varepsilon^*}-1) e^{\\varepsilon^*-P^*(1+\\lambda)}\n$$\nThis gives the final expression for the variance:\n$$\n\\mathrm{Var}(x) = \\frac{1}{(P^*)^2} - \\frac{(\\lambda-1)^2 (e^{\\varepsilon^*}-1) e^{\\varepsilon^*-P^*(1+\\lambda)}}{\\left(e^{\\varepsilon^*-P^*} - (e^{\\varepsilon^*}-1)e^{-P^*\\lambda}\\right)^2}\n$$\nThe required observables are related to these moments. The reduced number density is $\\rho^\\ast = \\rho\\sigma$. Since number density $\\rho=1/\\langle r \\rangle$, we have $\\rho^\\ast = \\sigma/\\langle r \\rangle = \\sigma/(\\sigma\\langle x \\rangle) = 1/\\langle x \\rangle$. The zero-wavenumber static structure factor for this one-dimensional system is $S(0) = \\mathrm{Var}(r)/\\langle r \\rangle^2 = \\sigma^2 \\mathrm{Var}(x) / (\\sigma^2 \\langle x \\rangle^2) = \\mathrm{Var}(x)/\\langle x \\rangle^2$.\n\nWith these analytical expressions, we can now compute the values for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for reduced density and static structure factor for a 1D square-well fluid.\n    \"\"\"\n    # Test suite: each case is specified by (beta*epsilon, lambda, beta*P*sigma)\n    test_cases = [\n        # Case A: (beta_eps, lambda, beta_P_sigma)\n        (0.0, 1.5, 1.0),\n        # Case B\n        (1.0, 1.5, 1.0),\n        # Case C\n        (3.0, 1.5, 1.0),\n        # Case D\n        (1.0, 2.0, 1.0),\n        # Case E\n        (1.0, 1.5, 0.1),\n        # Case F\n        (1.0, 1.5, 10.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        eps_star, lam, p_star = case\n\n        # For the case eps_star == 0, the model simplifies to a hard-rod fluid.\n        if eps_star == 0.0:\n            mean_x = 1.0 / p_star + 1.0\n            var_x = 1.0 / p_star**2\n        else:\n            # Numerically stable calculation using np.expm1(x) for exp(x) - 1\n            exp_eps_star_m1 = np.expm1(eps_star)\n            \n            # Common terms in the expressions\n            term_A = np.exp(eps_star - p_star)\n            term_B = exp_eps_star_m1 * np.exp(-p_star * lam)\n\n            # Denominator D_0\n            D0 = term_A - term_B\n            \n            # Calculate mean of dimensionless separation <x>\n            mean_x_numerator = term_A - lam * term_B\n            mean_x = 1.0 / p_star + mean_x_numerator / D0\n            \n            # Calculate variance of dimensionless separation Var(x)\n            var_x_frac_numerator = (lam - 1.0)**2 * exp_eps_star_m1 * np.exp(eps_star - p_star * (1.0 + lam))\n            var_x = (1.0 / p_star**2) - (var_x_frac_numerator / D0**2)\n\n        # Calculate final observables\n        # rho_star = sigma / <r> = 1 / <x>\n        rho_star = 1.0 / mean_x\n        # S(0) = Var(r) / <r>^2 = Var(x) / <x>^2\n        s0 = var_x / mean_x**2\n\n        # Round to six decimal places as required\n        results.append([round(rho_star, 6), round(s0, 6)])\n\n    # Format the output string\n    # E.g., [[0.5,0.25],[0.6,0.2],...]\n    output_str = \"[\" + \",\".join([f\"[{r[0]:.6f},{r[1]:.6f}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2423726"}, {"introduction": "Pair potentials are the engines of molecular motion, dictating the forces that govern a system's dynamics over time. This final challenge [@problem_id:2423746] guides you in building a basic molecular dynamics (MD) simulator from the ground up, based on Newton's second law. By deriving forces from a given potential and implementing a robust time-integration algorithm, you will simulate a multi-particle system and gain direct experience with the core methods of one of computational physics' most powerful techniques.", "problem": "You are tasked with deriving and implementing a purely repulsive pairwise interaction potential suitable for simulating an \"anti-gravity\" explosion of particles in a confined cubic volume. Work in dimensionless units so that all reported results are unitless numbers. The confined volume is a cube with side length $L$, defined by $[0,L]^3$, with specularly reflecting (perfectly elastic) walls. All particles have equal mass $m$.\n\nStarting point and definitions:\n- Begin from Newton's second law $\\mathbf{F}_i = m \\,\\ddot{\\mathbf{r}}_i$ applied to each particle $i$, and the definition of conservative force $\\mathbf{F}_i = - \\nabla_{\\mathbf{r}_i} U$, where $U$ is the total potential energy.\n- Use a purely repulsive, soft-core, inverse-distance potential between particles $i$ and $j$ separated by distance $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$:\n$$\nV(r_{ij}) = \\frac{C}{\\sqrt{r_{ij}^2 + s^2}},\n$$\nwith $C > 0$ and $s > 0$. The total potential energy is $U = \\sum_{i<j} V(r_{ij})$.\n- Derive the explicit pairwise force on particle $i$ due to particle $j$ from $V(r_{ij})$, and thus the total acceleration $\\ddot{\\mathbf{r}}_i$.\n\nTime integration:\n- Derive a second-order accurate, time-reversible update rule for positions and velocities based on Taylor expansions, consistent with Molecular Dynamics (MD). Use the velocity Verlet scheme with time step $\\Delta t$.\n- Impose specular reflection at the walls: when a particle crosses a wall with outward normal $\\hat{\\mathbf{n}}$, its velocity is instantaneously mapped as $\\mathbf{v} \\mapsto \\mathbf{v} - 2(\\mathbf{v}\\cdot \\hat{\\mathbf{n}})\\hat{\\mathbf{n}}$, and its position is reflected back into $[0,L]^3$.\n\nEnergy:\n- Define the total energy as\n$$\nE = \\sum_{i=1}^{N} \\frac{1}{2} m \\lVert \\mathbf{v}_i \\rVert^2 + \\sum_{i<j} V(r_{ij}).\n$$\nFor simulations without wall collisions over a time interval, the velocity Verlet method should approximately conserve $E$ with an error that decreases as $\\Delta t \\to 0$.\n\nImplementation requirements:\n- Implement the derived force, acceleration, and velocity Verlet integrator with reflecting boundary conditions exactly as defined above.\n- Use the following fixed global parameters for all test cases: $m = 1$, $C = 1$, $s = 0.1$, $L = 10$.\n- Handle reflections robustly even if a single time step causes a particle to cross a boundary by more than one wall thickness; ensure that each crossing in an axis in a single step produces one velocity inversion of the corresponding component and counts as one reflection event.\n\nTest suite:\nImplement four independent simulations with the following initial conditions and time-integration settings. Each simulation starts at time $t=0$ and advances to $t = T$ using the given $\\Delta t$ and a constant time step count $N_{\\text{steps}} = T / \\Delta t$ (assume $T$ is an exact multiple of $\\Delta t$).\n\n- Test $1$ (two-body repulsion, separation growth):\n  - $N = 2$.\n  - Initial positions: $\\mathbf{r}_1(0) = (4.0, 5.0, 5.0)$, $\\mathbf{r}_2(0) = (6.0, 5.0, 5.0)$.\n  - Initial velocities: $\\mathbf{v}_1(0) = (0.0, 0.0, 0.0)$, $\\mathbf{v}_2(0) = (0.0, 0.0, 0.0)$.\n  - $\\Delta t = 1.0 \\times 10^{-3}$, $T = 0.5$.\n  - Required result: the final center-to-center distance $r_{12}(T)$ as a float.\n\n- Test $2$ (energy conservation without wall collisions):\n  - $N = 3$.\n  - Place the three particles at the vertices of an equilateral triangle of side $a = 1.0$ in the plane $z=5.0$ and centered at $(5.0, 5.0, 5.0)$. Let $R = a/\\sqrt{3}$. Use:\n    - $\\mathbf{r}_1(0) = (5.0 + R, 5.0, 5.0)$,\n    - $\\mathbf{r}_2(0) = (5.0 - R/2, 5.0 + (\\sqrt{3}/2)R, 5.0)$,\n    - $\\mathbf{r}_3(0) = (5.0 - R/2, 5.0 - (\\sqrt{3}/2)R, 5.0)$.\n  - Initial velocities: all zero, $\\mathbf{v}_i(0) = (0.0, 0.0, 0.0)$ for $i \\in \\{1,2,3\\}$.\n  - $\\Delta t = 5.0 \\times 10^{-4}$, $T = 0.2$.\n  - Required result: the absolute relative energy error at final time, $\\left|E(T) - E(0)\\right| / E(0)$, as a float.\n\n- Test $3$ (single-particle wall reflection):\n  - $N = 1$.\n  - Initial position: $\\mathbf{r}_1(0) = (2.0, 5.0, 5.0)$.\n  - Initial velocity: $\\mathbf{v}_1(0) = (3.0, 0.0, 0.0)$.\n  - $\\Delta t = 1.0 \\times 10^{-3}$, $T = 3.0$.\n  - Required result: the final $x$-component of velocity $v_{1x}(T)$ as a float.\n\n- Test $4$ (many-body \"explosion\" and wall-contact kinematics):\n  - $N = 8$.\n  - Initial positions: the eight corners of a cube of side $0.2$ centered at $(5.0, 5.0, 5.0)$, i.e., all combinations of offsets $(\\pm 0.1, \\pm 0.1, \\pm 0.1)$ added to $(5.0, 5.0, 5.0)$.\n  - Initial velocities: all zero.\n  - $\\Delta t = 1.0 \\times 10^{-3}$, $T = 1.5$.\n  - Required result: the total count of wall reflections accumulated across all particles and all axes during the run, as an integer. Count one reflection for each velocity-component inversion caused by crossing a wall.\n\nFinal output format:\n- Your program should produce a single line of output containing the four test results in order as a comma-separated list enclosed in square brackets, for example, $[r_{12}(T),\\epsilon_E,v_{1x}(T),N_{\\text{refl}}]$, where $\\epsilon_E$ denotes the relative energy error from Test $2$ and $N_{\\text{refl}}$ the reflection count from Test $4$.", "solution": "The problem statement has been critically examined and is found to be scientifically grounded, well-posed, and objective. It presents a standard exercise in computational physics, specifically in the domain of Molecular Dynamics (MD), which is based on the fundamental principles of classical mechanics. All required parameters, initial conditions, and mathematical definitions are provided, forming a complete and non-contradictory description of the system to be simulated. The terminology, including the metaphorical use of \"anti-gravity,\" is specified with sufficient mathematical rigor to permit a unique and formalizable solution. We may therefore proceed with the derivation and implementation.\n\nThe solution requires the derivation of the equations of motion, the implementation of a numerical integration scheme, and the handling of boundary conditions. We shall address each of these components in a systematic, first-principles manner.\n\n### 1. Force and Acceleration Derivation\n\nThe system dynamics are governed by Newton's second law, $\\mathbf{F}_i = m \\ddot{\\mathbf{r}}_i$, where the force $\\mathbf{F}_i$ on particle $i$ is conservative and thus derivable from a total potential energy $U$.\n$$\n\\mathbf{F}_i = - \\nabla_{\\mathbf{r}_i} U\n$$\nThe total potential energy $U$ is the sum of pairwise potentials $V(r_{ij})$ over all unique pairs of particles $(i, j)$ with $i < j$.\n$$\nU = \\sum_{i<j} V(r_{ij}) = \\frac{1}{2} \\sum_{i \\neq j} V(r_{ij})\n$$\nThe pairwise potential is given as a soft-core inverse-distance potential:\n$$\nV(r_{ij}) = \\frac{C}{\\sqrt{r_{ij}^2 + s^2}} = C (r_{ij}^2 + s^2)^{-1/2}\n$$\nwhere $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$ is the Euclidean distance between particles $i$ and $j$.\n\nTo find the force on a specific particle, say particle $k$, we compute the gradient of $U$ with respect to $\\mathbf{r}_k$. The only terms in the sum for $U$ that depend on $\\mathbf{r}_k$ are those where one of the indices is $k$.\n$$\n\\mathbf{F}_k = - \\nabla_{\\mathbf{r}_k} \\left( \\sum_{j \\neq k} V(r_{kj}) \\right) = - \\sum_{j \\neq k} \\nabla_{\\mathbf{r}_k} V(r_{kj})\n$$\nWe apply the chain rule for the gradient: $\\nabla_{\\mathbf{r}_k} V(r_{kj}) = \\frac{dV}{dr_{kj}} \\nabla_{\\mathbf{r}_k} r_{kj}$.\nThe gradient of the distance function is $\\nabla_{\\mathbf{r}_k} r_{kj} = \\nabla_{\\mathbf{r}_k} \\lVert \\mathbf{r}_k - \\mathbf{r}_j \\rVert = \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{\\lVert \\mathbf{r}_k - \\mathbf{r}_j \\rVert} = \\frac{\\mathbf{r}_{kj}}{r_{kj}} = \\hat{\\mathbf{r}}_{kj}$.\nThe derivative of the potential with respect to distance is:\n$$\n\\frac{dV}{dr} = C \\left(-\\frac{1}{2}\\right) (r^2 + s^2)^{-3/2} (2r) = -C \\frac{r}{(r^2 + s^2)^{3/2}}\n$$\nCombining these results, the force exerted on particle $k$ by particle $j$ is:\n$$\n\\mathbf{F}_{kj} = -\\left( -C \\frac{r_{kj}}{(r_{kj}^2 + s^2)^{3/2}} \\right) \\hat{\\mathbf{r}}_{kj} = C \\frac{r_{kj}}{(r_{kj}^2 + s^2)^{3/2}} \\frac{\\mathbf{r}_{kj}}{r_{kj}} = C \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{(\\lVert \\mathbf{r}_k - \\mathbf{r}_j \\rVert^2 + s^2)^{3/2}}\n$$\nThe total force on particle $k$ is the vector sum of forces from all other particles:\n$$\n\\mathbf{F}_k = \\sum_{j \\neq k} \\mathbf{F}_{kj} = C \\sum_{j \\neq k} \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{(\\lVert \\mathbf{r}_k - \\mathbf{r}_j \\rVert^2 + s^2)^{3/2}}\n$$\nFrom this, the acceleration of particle $k$ is given by $\\mathbf{a}_k = \\ddot{\\mathbf{r}}_k = \\mathbf{F}_k / m$:\n$$\n\\mathbf{a}_k(t) = \\frac{C}{m} \\sum_{j \\neq k} \\frac{\\mathbf{r}_k(t) - \\mathbf{r}_j(t)}{(\\lVert \\mathbf{r}_k(t) - \\mathbf{r}_j(t) \\rVert^2 + s^2)^{3/2}}\n$$\nThis expression is used to compute accelerations at each time step.\n\n### 2. Numerical Integration: Velocity Verlet Scheme\n\nThe problem demands a second-order accurate, time-reversible integrator. The velocity Verlet algorithm satisfies these requirements. The algorithm advances the system state $(\\mathbf{r}(t), \\mathbf{v}(t))$ to $(\\mathbf{r}(t+\\Delta t), \\mathbf{v}(t+\\Delta t))$. Given positions $\\mathbf{r}_n = \\mathbf{r}(t_n)$, velocities $\\mathbf{v}_n = \\mathbf{v}(t_n)$, and accelerations $\\mathbf{a}_n = \\mathbf{a}(t_n)$, the state at the next time step $t_{n+1} = t_n + \\Delta t$ is computed as follows:\n\n1.  **Position Update:** First, the positions are advanced over the full time step $\\Delta t$ using the current velocities and accelerations.\n    $$\n    \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t + \\frac{1}{2}\\mathbf{a}_n \\Delta t^2\n    $$\n2.  **Force/Acceleration Update:** The forces, and thus accelerations $\\mathbf{a}_{n+1}$, are calculated using the newly computed positions $\\mathbf{r}_{n+1}$.\n    $$\n    \\mathbf{a}_{n+1} = \\frac{\\mathbf{F}(\\mathbf{r}_{n+1})}{m}\n    $$\n3.  **Velocity Update:** Finally, the velocities are updated using an average of the old and new accelerations.\n    $$\n    \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{1}{2}(\\mathbf{a}_n + \\mathbf{a}_{n+1})\\Delta t\n    $$\nThis scheme is numerically stable for appropriate $\\Delta t$ and conserves energy for conservative systems over long periods with an error proportional to $\\Delta t^2$. For the implementation, we use an equivalent but computationally more convenient \"leapfrog\" variant:\n\n1.  Calculate a half-step velocity: $\\mathbf{v}_{n+1/2} = \\mathbf{v}_n + \\frac{1}{2}\\mathbf{a}_n \\Delta t$.\n2.  Update positions fully: $\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_{n+1/2} \\Delta t$.\n3.  (Apply boundary conditions to $\\mathbf{r}_{n+1}$ and $\\mathbf{v}_{n+1/2}$).\n4.  Calculate new accelerations $\\mathbf{a}_{n+1}$ using $\\mathbf{r}_{n+1}$.\n5.  Complete the velocity update: $\\mathbf{v}_{n+1} = \\mathbf{v}_{n+1/2} + \\frac{1}{2}\\mathbf{a}_{n+1} \\Delta t$.\n\n### 3. Boundary Conditions: Specular Reflection\n\nThe particles are confined to a cubic box $[0, L]^3$. When a particle's trajectory crosses a boundary, it undergoes a specular (perfectly elastic) reflection. This is an instantaneous event that inverts the component of the particle's velocity normal to the wall, while its position is reflected back into the domain. This process conserves the particle's kinetic energy.\n\nThe reflection logic must be applied within the integration step. After the position update (step 2 of the leapfrog Verlet), we check each particle's new position for each coordinate axis $d \\in \\{x, y, z\\}$. Let $r_{i,d}$ be the $d$-component of particle $i$'s position and $v_{i,d}$ be the corresponding velocity component.\n\n-   If $r_{i,d} < 0$: The particle has crossed the lower boundary. We reflect its position to $r_{i,d}' = -r_{i,d}$ and invert its velocity component $v_{i,d}' = -v_{i,d}$.\n-   If $r_{i,d} > L$: The particle has crossed the upper boundary. We reflect its position to $r_{i,d}' = 2L - r_{i,d}$ and invert its velocity component $v_{i,d}' = -v_{i,d}$.\n\nThis procedure must be applied repeatedly within a single time step if a particle's trial position is so far outside the box that its first reflection still leaves it outside (e.g., $r_{i,d} < -L$ or $r_{i,d} > 2L$). A `while` loop is used to ensure the final position is strictly within $[0, L]^3$. Each velocity inversion event is counted as one reflection for Test $4$. This reflection is applied to the half-step velocity $\\mathbf{v}_{n+1/2}$ before it is used to compute the final velocity $\\mathbf{v}_{n+1}$.\n\n### 4. Total Energy\n\nThe total energy $E$ of the system is the sum of the kinetic energy $K$ and the potential energy $U$.\n$$\nE = K + U = \\sum_{i=1}^{N} \\frac{1}{2} m \\lVert \\mathbf{v}_i \\rVert^2 + \\sum_{i<j} \\frac{C}{\\sqrt{\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert^2 + s^2}}\n$$\nFor a conservative system, $E$ must be constant. The numerical integrator introduces a small error, so we expect $E$ to be approximately conserved. In Test $2$, no wall collisions occur, so any change in $E$ is due to the integrator's discretization error. The absolute relative energy error is calculated as $\\left|E(T) - E(0)\\right| / |E(0)|$. Note that $E(0) = U(0)$ since initial velocities are zero, and $U(0) > 0$.\n\n### 5. Simulation Algorithm\n\nThe overall simulation proceeds as follows:\n1.  **Initialization**: Set particle positions $\\mathbf{r}_0$ and velocities $\\mathbf{v}_0$ according to the test case. Set time $t = 0$. Initialize reflection counter to $0$.\n2.  **Initial Force Calculation**: Compute initial accelerations $\\mathbf{a}_0$ from $\\mathbf{r}_0$.\n3.  **Time Evolution Loop**: For each time step from $n=0$ to $N_{\\text{steps}}-1$:\n    a. Update positions and half-step velocities using the Velocity Verlet scheme.\n    b. Apply specular reflection boundary conditions, updating positions, half-step velocities, and the reflection counter as necessary.\n    c. Calculate new accelerations from the final positions of the step.\n    d. Update the full-step velocities to complete the integration step.\n4.  **Final Result**: After the loop finishes at time $T$, extract the required observable (final distance, energy error, final velocity, or total reflection count).\n\nThis procedure is deterministic and, when implemented correctly with the specified parameters and initial conditions, will yield the unique results demanded by the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ... (Not used)\n\ndef solve():\n    \"\"\"\n    Main function to run the four simulation test cases and print the results.\n    \"\"\"\n\n    class MD_Simulator:\n        \"\"\"\n        A class to perform Molecular Dynamics simulations based on the problem statement.\n        \"\"\"\n        def __init__(self, r0, v0, m=1.0, C=1.0, s=0.1, L=10.0):\n            self.N = r0.shape[0]  # Number of particles\n            self.pos = np.array(r0, dtype=np.float64)\n            self.vel = np.array(v0, dtype=np.float64)\n            \n            self.m = m\n            self.C = C\n            self.s = s\n            self.L = L\n            \n            self.acc = self._calculate_accelerations()\n            self.reflection_count = 0\n\n        def _calculate_accelerations(self):\n            \"\"\"Calculates accelerations on all particles due to pairwise forces.\"\"\"\n            if self.N < 2:\n                return np.zeros_like(self.pos)\n            \n            # Vectorized calculation of pairwise forces\n            displacements = self.pos[:, np.newaxis, :] - self.pos[np.newaxis, :, :]\n            dist_sq = np.sum(displacements**2, axis=2)\n            np.fill_diagonal(dist_sq, np.inf) # Avoid self-interaction division by zero\n            \n            # Force magnitude factor: C * (r^2 + s^2)^(-3/2)\n            denom = (dist_sq + self.s**2)**1.5\n            force_mag_factor = self.C / denom\n            \n            # Acceleration = Force / mass\n            # accel_i = sum_j (force_mag_factor_ij * displacement_ij) / m\n            accel = np.sum(force_mag_factor[:, :, np.newaxis] * displacements, axis=1) / self.m\n            return accel\n\n        def _apply_boundary_conditions(self):\n            \"\"\"Applies specular reflection boundary conditions.\"\"\"\n            for i in range(self.N):\n                for d in range(3): # x, y, z dimensions\n                    # Using a while loop to handle multiple boundary crossings in one step\n                    while self.pos[i, d] < 0 or self.pos[i, d] > self.L:\n                        self.reflection_count += 1\n                        if self.pos[i, d] < 0:\n                            self.pos[i, d] = -self.pos[i, d]\n                            self.vel[i, d] = -self.vel[i, d]\n                        else: # pos[i, d] > L\n                            self.pos[i, d] = 2 * self.L - self.pos[i, d]\n                            self.vel[i, d] = -self.vel[i, d]\n\n\n        def step(self, dt):\n            \"\"\"Advances the simulation by one time step dt using Velocity Verlet.\"\"\"\n            # 1. First half of velocity update\n            self.vel += 0.5 * self.acc * dt\n            \n            # 2. Position update\n            self.pos += self.vel * dt\n            \n            # 3. Apply boundary conditions\n            self._apply_boundary_conditions()\n            \n            # 4. Calculate new accelerations\n            self.acc = self._calculate_accelerations()\n            \n            # 5. Second half of velocity update\n            self.vel += 0.5 * self.acc * dt\n\n        def get_total_energy(self):\n            \"\"\"Calculates the total energy (kinetic + potential) of the system.\"\"\"\n            # Kinetic Energy\n            kinetic_energy = 0.5 * self.m * np.sum(self.vel**2)\n            \n            # Potential Energy\n            potential_energy = 0.0\n            if self.N >= 2:\n                r_ij_sq = np.sum((self.pos[:, np.newaxis, :] - self.pos[np.newaxis, :, :])**2, axis=2)\n                # Sum over unique pairs (i < j)\n                i_lower = np.tril_indices(self.N, -1)\n                potential_energy = self.C * np.sum(1.0 / np.sqrt(r_ij_sq[i_lower] + self.s**2))\n\n            return kinetic_energy + potential_energy\n\n    results = []\n\n    # --- Test 1: Two-body repulsion ---\n    r0_1 = np.array([[4.0, 5.0, 5.0], [6.0, 5.0, 5.0]])\n    v0_1 = np.zeros_like(r0_1)\n    dt1, T1 = 1.0e-3, 0.5\n    n_steps1 = int(T1 / dt1)\n    sim1 = MD_Simulator(r0_1, v0_1)\n    for _ in range(n_steps1):\n        sim1.step(dt1)\n    r12_final = np.linalg.norm(sim1.pos[0] - sim1.pos[1])\n    results.append(r12_final)\n    \n    # --- Test 2: Energy conservation ---\n    a = 1.0\n    R = a / np.sqrt(3)\n    r0_2 = np.array([\n        [5.0 + R, 5.0, 5.0],\n        [5.0 - R/2.0, 5.0 + (np.sqrt(3)/2.0)*R, 5.0],\n        [5.0 - R/2.0, 5.0 - (np.sqrt(3)/2.0)*R, 5.0],\n    ])\n    v0_2 = np.zeros_like(r0_2)\n    dt2, T2 = 5.0e-4, 0.2\n    n_steps2 = int(T2 / dt2)\n    sim2 = MD_Simulator(r0_2, v0_2)\n    E0 = sim2.get_total_energy()\n    for _ in range(n_steps2):\n        sim2.step(dt2)\n    ET = sim2.get_total_energy()\n    rel_energy_error = np.abs(ET - E0) / E0\n    results.append(rel_energy_error)\n\n    # --- Test 3: Single-particle wall reflection ---\n    r0_3 = np.array([[2.0, 5.0, 5.0]])\n    v0_3 = np.array([[3.0, 0.0, 0.0]])\n    dt3, T3 = 1.0e-3, 3.0\n    n_steps3 = int(T3 / dt3)\n    sim3 = MD_Simulator(r0_3, v0_3)\n    for _ in range(n_steps3):\n        sim3.step(dt3)\n    final_vx = sim3.vel[0, 0]\n    results.append(final_vx)\n\n    # --- Test 4: Many-body explosion ---\n    offsets = np.array([\n        [-0.1, -0.1, -0.1], [-0.1, -0.1,  0.1], [-0.1,  0.1, -0.1], [-0.1,  0.1,  0.1],\n        [ 0.1, -0.1, -0.1], [ 0.1, -0.1,  0.1], [ 0.1,  0.1, -0.1], [ 0.1,  0.1,  0.1]\n    ])\n    r0_4 = np.array([5.0, 5.0, 5.0]) + offsets\n    v0_4 = np.zeros_like(r0_4)\n    dt4, T4 = 1.0e-3, 1.5\n    n_steps4 = int(T4 / dt4)\n    sim4 = MD_Simulator(r0_4, v0_4)\n    for _ in range(n_steps4):\n        sim4.step(dt4)\n    total_reflections = sim4.reflection_count\n    results.append(total_reflections)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2423746"}]}