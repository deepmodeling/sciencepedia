{"hands_on_practices": [{"introduction": "This first practice is your entry point into the world of Diffusion-limited Aggregation. You will build a DLA simulator from the ground up, implementing the core mechanics of particle diffusion and sticking. By applying your model to both square and hexagonal lattices [@problem_id:2386014], you will gain hands-on experience in calculating the fractal dimension $D_f$ and exploring the powerful concept of universality, which posits that the macroscopic structure of the aggregate is surprisingly insensitive to the microscopic details of the underlying lattice.", "problem": "Write a complete, runnable program that simulates Diffusion-Limited Aggregation (DLA) for two two-dimensional lattices and estimates the fractal dimension by scaling of the radius of gyration. The objective is to model aggregation on both a square lattice and a hexagonal lattice and to compare the empirically estimated fractal dimension $D_f$ between the two. The program must run deterministically by using fixed random number seeds, and it must output a single line in the exact format specified below.\n\nFundamental base and definitions to be used:\n- Diffusion-Limited Aggregation (DLA) is a growth process in which particles perform unbiased nearest-neighbor random walks (a discrete model of Brownian motion consistent with the diffusion equation $\\partial_t \\rho = D \\nabla^2 \\rho$) until they stick to a cluster upon first contact with its boundary (adjacency to any occupied site).\n- A random walk step on a lattice chooses uniformly among the set of nearest neighbors. For the square lattice the walk has 4 neighbors per site, and for the hexagonal lattice it has 6 neighbors per site.\n- The radius of gyration $R_g$ of a set of $N$ points at positions $\\{\\mathbf{r}_i\\}_{i=1}^N$ is defined by\n$$\nR_g^2 = \\frac{1}{N}\\sum_{i=1}^N \\left|\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}\\right|^2,\n\\quad \\text{where} \\quad\n\\mathbf{r}_{\\mathrm{cm}}=\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i.\n$$\nFor a statistically self-similar aggregate (fractal), the scaling $R_g \\propto N^{1/D_f}$ holds, so that a log-log linear regression of $\\log R_g$ versus $\\log N$ yields a slope $s$ with $D_f = 1/s$.\n- Distances and angles must be treated in a mathematically consistent embedding. For the square lattice, the Cartesian embedding is $\\mathbf{r}=(x,y)$ with integer $x$ and $y$. For the hexagonal lattice, use an axial coordinate system $(q,r)$ with nearest-neighbor directions $(1,0)$, $(-1,0)$, $(0,1)$, $(0,-1)$, $(1,-1)$, $(-1,1)$, and embed into the plane via\n$$\nx = q + \\frac{1}{2} r,\\qquad y = \\frac{\\sqrt{3}}{2} r,\n$$\nso that Euclidean squared distance from the origin is\n$$\nx^2 + y^2 = q^2 + q r + r^2.\n$$\n\nSimulation rules and numerical details:\n- Initialize the aggregate with a single occupied site at the origin at $N=1$.\n- Launch each diffusing particle at a random direction on a circle of radius $R_{\\text{launch}} = \\sqrt{R_{\\max}^2} + \\Delta_{\\text{launch}}$, where $R_{\\max}^2$ is the current maximum squared Euclidean distance of any occupied site from the origin, and $\\Delta_{\\text{launch}}$ is a positive margin. Use a uniformly random angle in radians in $[0,2\\pi)$ to place the launch point, then round to the nearest lattice site (for the hexagonal lattice, perform rounding in axial coordinates consistent with the embedding; for the square lattice, round Cartesian coordinates). Angles must be treated in radians.\n- Perform an unbiased nearest-neighbor random walk until either:\n  1. The walker steps to a site whose neighbor set contains any currently occupied site. In that case, the walker sticks irreversibly at its current site and becomes part of the aggregate.\n  2. The walker wanders beyond a “kill” radius $R_{\\text{kill}} = R_{\\text{launch}} + \\Delta_{\\text{kill}}$, in which case the walker is discarded and a new walker is launched.\n- After each sticking event that increases $N$ to $N+1$, update the radius of gyration $R_g(N+1)$ using the exact definition above in the chosen embedding.\n- Estimate the fractal dimension $D_f$ by performing a least-squares linear regression of $\\log R_g(N)$ versus $\\log N$ over a range that avoids very small $N$ to reduce finite-size effects. Specifically, fit over $N \\ge N_{\\min}$ with $N_{\\min} = \\max(50, \\lfloor 0.2 N_{\\text{final}} \\rfloor)$ for $N_{\\text{final}} \\ge 100$, and $N_{\\min} = 10$ otherwise. Use natural logarithms.\n\nYour program must implement both lattice types and compute $D_f$ for each test case. The random number generator must be seeded per test case for deterministic behavior.\n\nRequired test suite (each tuple is $(\\text{lattice}, N_{\\text{final}}, \\text{seed}, \\Delta_{\\text{launch}}, \\Delta_{\\text{kill}})$):\n- Case A: $(\\text{\"square\"},\\, 220,\\, 2023,\\, 5,\\, 15)$\n- Case B: $(\\text{\"hex\"},\\, 220,\\, 2023,\\, 5,\\, 15)$\n- Case C: $(\\text{\"square\"},\\, 60,\\, 777,\\, 5,\\, 15)$\n- Case D: $(\\text{\"hex\"},\\, 60,\\, 777,\\, 5,\\, 15)$\n\nAll distances are dimensionless lattice spacings; angles must be in radians. The outputs are real numbers (floating-point) with no units. For each test case, the program must output the estimated $D_f$ rounded to three decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[\\text{Case A}, \\text{Case B}, \\text{Case C}, \\text{Case D}]$. For example: [$1.700,1.690,1.660,1.650].", "solution": "We model Diffusion-Limited Aggregation (DLA) by explicit nearest-neighbor random walks, grounding the approach in two fundamental elements. First, unbiased nearest-neighbor random walks on a lattice provide a discrete representation of Brownian motion, consistent with the diffusion equation $\\partial_t \\rho = D \\nabla^2 \\rho$. Second, fractal dimension $D_f$ of an aggregate is defined via mass-radius scaling. We avoid prescribing any lattice-specific shortcut formulas and instead derive the measurement procedure from definitions.\n\nPrinciples and derivation:\n1. Random walk dynamics and aggregation. Let $\\mathcal{S}$ denote the set of occupied sites, initially $\\mathcal{S}=\\{(0,0)\\}$. A walker is launched at Euclidean radius $R_{\\text{launch}} = \\sqrt{R_{\\max}^2} + \\Delta_{\\text{launch}}$, where $R_{\\max}^2=\\max_{\\mathbf{r}\\in\\mathcal{S}} \\|\\mathbf{r}\\|^2$. The launching direction is uniformly sampled in $[0,2\\pi)$ (radians), maintaining isotropy. For the square lattice, the position is rounded to integer Cartesian $(x,y)\\in\\mathbb{Z}^2$; for the hexagonal lattice, we use axial coordinates $(q,r)\\in\\mathbb{Z}^2$ with nearest neighbors $(1,0)$, $(-1,0)$, $(0,1)$, $(0,-1)$, $(1,-1)$, $(-1,1)$. The walk proceeds by picking a nearest neighbor uniformly at random at each step. If the walker’s current site has any neighbor in $\\mathcal{S}$, it sticks and the site is added to $\\mathcal{S}$. If it wanders beyond $R_{\\text{kill}}=R_{\\text{launch}}+\\Delta_{\\text{kill}}$, it is discarded and a new walker is launched. These rules implement growth limited by the diffusive flux to the aggregate boundary.\n\n2. Embedding and distance metrics. For the square lattice, we use $\\mathbf{r}=(x,y)$ with Euclidean squared distance $\\|\\mathbf{r}\\|^2=x^2+y^2$. For the hexagonal lattice, we embed axial coordinates $(q,r)$ as\n$$\nx = q + \\frac{1}{2} r,\\qquad y = \\frac{\\sqrt{3}}{2} r,\n$$\nwhich yields the identity\n$$\nx^2 + y^2 = q^2 + q r + r^2.\n$$\nThis identity allows exact Euclidean squared distance computations from integer axial coordinates without floating-point ambiguity during the random walk. We round launch points to the nearest hex site by converting Cartesian $(x,y)$ to fractional axial $(q_f,r_f)$ via $q_f = x - y/\\sqrt{3}$ and $r_f = 2y/\\sqrt{3}$ and then applying standard cube-coordinate rounding with the constraint $x_c + y_c + z_c = 0$ to obtain integer axial $(q,r)$.\n\n3. Fractal dimension from the radius of gyration. The radius of gyration for $N$ occupied sites at $\\{\\mathbf{r}_i\\}$ is\n$$\nR_g^2(N) = \\frac{1}{N}\\sum_{i=1}^N \\left|\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}\\right|^2\n= \\frac{1}{N}\\sum_{i=1}^N |\\mathbf{r}_i|^2 - \\left|\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i\\right|^2,\n$$\nwhich is exact and computationally convenient. For self-similar aggregates, the mass-radius scaling $N \\propto R^{{D_f}}$ implies $R \\propto N^{1/D_f}$ and therefore\n$$\n\\log R_g(N) = \\frac{1}{D_f}\\log N + \\text{constant}.\n$$\nThus, a least-squares fit of $\\log R_g$ versus $\\log N$ over a range avoiding small-$N$ transients yields a slope $s$ and estimate $D_f = 1/s$. To reduce finite-size and lattice artifacts, we fit over $N \\ge N_{\\min}$ with $N_{\\min}=\\max(50,\\lfloor 0.2 N_{\\text{final}}\\rfloor)$ when $N_{\\text{final}} \\ge 100$ and $N_{\\min}=10$ otherwise.\n\nAlgorithmic design:\n- Data structures: Maintain the occupied set $\\mathcal{S}$ as a hash set of lattice coordinates for $O(1)$ expected-time membership tests. Keep running sums $\\sum \\mathbf{r}_i$ and $\\sum |\\mathbf{r}_i|^2$ to update $R_g$ in $O(1)$ time at each sticking event. Track $R_{\\max}^2$ as the maximum Euclidean squared distance from the origin among occupied sites for launch radius updates.\n- Hexagonal implementation details: Use axial neighbors and exact formula $q^2 + q r + r^2$ for squared Euclidean distance during random walks for kill-radius checks. Convert only at sticking events to Cartesian $(x,y)$ for $R_g$ updates using $x=q+\\frac{1}{2}r$, $y=\\frac{\\sqrt{3}}{2}r$.\n- Determinism: Use a fixed seed per test case with an independent random number generator for reproducibility. Angles are sampled uniformly in radians in $[0,2\\pi)$.\n- Computational safeguards: Impose a generous maximum number of random-walk steps per launched walker to guarantee termination; if exceeded, discard and relaunch to avoid pathological trajectories. This does not bias results materially when the limit is set high.\n\nTest suite and output:\nWe run four cases with tuples $(\\text{lattice}, N_{\\text{final}}, \\text{seed}, \\Delta_{\\text{launch}}, \\Delta_{\\text{kill}})$:\n- Case A: $(\\text{\"square\"}, 220, 2023, 5, 15)$.\n- Case B: $(\\text{\"hex\"}, 220, 2023, 5, 15)$.\n- Case C: $(\\text{\"square\"}, 60, 777, 5, 15)$.\n- Case D: $(\\text{\"hex\"}, 60, 777, 5, 15)$.\nFor each case, we compute $D_f$ by linear regression of $\\log R_g$ versus $\\log N$ as specified, and we round the result to three decimal places. The program prints a single line in the format [$D_A, D_B, D_C, D_D$]. Typical DLA values in two dimensions are near $D_f \\approx 1.7$; the two lattices may yield slightly different estimates due to coordination number and lattice anisotropy, but both should be in the same range at these sizes.\n\nThe entire implementation adheres to the required environment, uses only allowed libraries, and produces the specified single-line output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# ---------------------------\n# DLA simulation on square and hex lattices with R_g scaling\n# ---------------------------\n\n# Neighbor steps for square and hex lattices\nSQUARE_NEIGHBORS = ((1, 0), (-1, 0), (0, 1), (0, -1))\nHEX_NEIGHBORS = ((1, 0), (-1, 0), (0, 1), (0, -1), (1, -1), (-1, 1))\n\nSQRT3 = np.sqrt(3.0)\nSQRT3_OVER_2 = SQRT3 / 2.0\n\ndef axial_to_cartesian(q: int, r: int) -> tuple[float, float]:\n    \"\"\"\n    Map axial hex coordinates (q, r) to Cartesian coordinates (x, y).\n    x = q + r/2\n    y = (sqrt(3)/2) * r\n    \"\"\"\n    x = q + 0.5 * r\n    y = SQRT3_OVER_2 * r\n    return x, y\n\ndef hex_distance_sq_axial(q: int, r: int) -> int:\n    \"\"\"\n    Exact Euclidean squared distance in the hex embedding:\n    x^2 + y^2 = q^2 + q*r + r^2\n    \"\"\"\n    return q*q + q*r + r*r\n\ndef cartesian_to_axial_round(x: float, y: float) -> tuple[int, int]:\n    \"\"\"\n    Convert Cartesian (x, y) in the hex embedding to the nearest axial integer (q, r)\n    using cube-coordinate rounding. Inverse of axial_to_cartesian.\n    From axial to cart: x = q + r/2, y = (sqrt(3)/2) r.\n    Inverse (fractional axial): q_f = x - y/sqrt(3), r_f = 2y/sqrt(3).\n    \"\"\"\n    qf = x - y / SQRT3\n    rf = 2.0 * y / SQRT3\n    # Convert to cube coords (x_c, y_c, z_c) with x_c + y_c + z_c = 0\n    xf = qf\n    zf = rf\n    yf = -xf - zf\n    rx = round(xf)\n    ry = round(yf)\n    rz = round(zf)\n    dx = abs(rx - xf)\n    dy = abs(ry - yf)\n    dz = abs(rz - zf)\n    if dx > dy and dx > dz:\n        rx = -ry - rz\n    elif dy > dz:\n        ry = -rx - rz\n    else:\n        rz = -rx - ry\n    q = int(rx)\n    r = int(rz)\n    return q, r\n\ndef simulate_dla(lattice: str, N_final: int, seed: int, launch_margin: float, kill_margin: float) -> float:\n    \"\"\"\n    Simulate DLA on the specified lattice ('square' or 'hex') until N_final occupied sites (including the seed),\n    return the estimated fractal dimension D_f by fitting log(R_g) vs log(N) with N >= N_min (see problem statement).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    if lattice == \"square\":\n        neighbors = SQUARE_NEIGHBORS\n        # Distance from origin squared\n        dist2 = lambda pos: pos[0]*pos[0] + pos[1]*pos[1]\n        # Map lattice coord to cartesian\n        to_cart = lambda pos: (float(pos[0]), float(pos[1]))\n        # Round launch on circle to nearest lattice site\n        def launch_from_radius(R_launch: float) -> tuple[int, int]:\n            theta = rng.uniform(0.0, 2.0*np.pi)\n            x = R_launch * np.cos(theta)\n            y = R_launch * np.sin(theta)\n            return int(round(x)), int(round(y))\n    elif lattice == \"hex\":\n        neighbors = HEX_NEIGHBORS\n        dist2 = lambda pos: hex_distance_sq_axial(pos[0], pos[1])\n        to_cart = lambda pos: axial_to_cartesian(pos[0], pos[1])\n        def launch_from_radius(R_launch: float) -> tuple[int, int]:\n            theta = rng.uniform(0.0, 2.0*np.pi)\n            x = R_launch * np.cos(theta)\n            y = R_launch * np.sin(theta)\n            return cartesian_to_axial_round(x, y)\n    else:\n        raise ValueError(\"Unknown lattice type\")\n\n    occupied = set()\n    origin = (0, 0)\n    occupied.add(origin)\n\n    # Running sums for R_g computation\n    sum_x = 0.0\n    sum_y = 0.0\n    sum_sq = 0.0\n    # R_g at N=1 is zero\n    Rg_by_N = [(1, 0.0)]\n\n    # Track maximum squared radius\n    Rmax2 = 0.0  # includes the origin which is 0\n\n    # Simulation parameters\n    max_steps_per_walker = 10000  # safety limit to avoid very long walks\n\n    # Main aggregation loop\n    while len(occupied) < N_final:\n        # Set launch and kill radii\n        R_launch = np.sqrt(Rmax2) + float(launch_margin)\n        R_kill = R_launch + float(kill_margin)\n        R_kill2 = R_kill * R_kill\n\n        # Launch a new walker\n        pos = launch_from_radius(R_launch)\n\n        steps = 0\n        while True:\n            steps += 1\n            if steps > max_steps_per_walker:\n                # Discard and relaunch\n                break\n\n            # Propose a random nearest-neighbor step\n            # Choose index more cheaply than rng.choice on small tuple\n            di = int(rng.integers(0, len(neighbors)))\n            dx, dy = neighbors[di]\n            new_pos = (pos[0] + dx, pos[1] + dy)\n\n            # Do not move into already occupied site (reflect by rejecting step)\n            if new_pos in occupied:\n                continue\n\n            pos = new_pos\n\n            # Kill if beyond kill radius\n            if dist2(pos) > R_kill2:\n                break\n\n            # Stick if adjacent to occupied site\n            hit = False\n            # Test adjacency\n            for ndx, ndy in neighbors:\n                nb = (pos[0] + ndx, pos[1] + ndy)\n                if nb in occupied:\n                    hit = True\n                    break\n            if hit:\n                # Stick the walker\n                occupied.add(pos)\n                # Update R_g running sums using Cartesian embedding\n                x, y = to_cart(pos)\n                sum_x += x\n                sum_y += y\n                sum_sq += x*x + y*y\n                N_now = len(occupied)\n                # Update Rmax2\n                d2 = x*x + y*y\n                if d2 > Rmax2:\n                    Rmax2 = d2\n                # Compute R_g from definition: R_g^2 = (sum |r|^2)/N - |sum r|^2 / N^2\n                cm2 = (sum_x*sum_x + sum_y*sum_y) / (N_now * N_now)\n                Rg2 = (sum_sq / N_now) - cm2\n                if Rg2 < 0.0:\n                    Rg2 = 0.0\n                Rg = float(np.sqrt(Rg2))\n                Rg_by_N.append((N_now, Rg))\n                break  # proceed to next walker\n\n    # Prepare data for fitting log(R_g) vs log(N)\n    Ns = np.array([n for n, _ in Rg_by_N], dtype=float)\n    Rgs = np.array([rg for _, rg in Rg_by_N], dtype=float)\n\n    # Select fitting range\n    if N_final >= 100:\n        N_min = max(50, int(np.floor(0.2 * N_final)))\n    else:\n        N_min = 10\n    mask = Ns >= N_min\n    # Ensure we have sufficient points; if not, relax to use all N >= 2\n    if not np.any(mask):\n        mask = Ns >= 2.0\n\n    # Avoid log of zero; filter R_g > 0 as well\n    mask = mask & (Rgs > 0.0)\n\n    # In degenerate cases with too few points, fall back to pseudo-estimate to avoid crash\n    if np.count_nonzero(mask) < 2:\n        # Minimal fallback: return NaN-like but still numeric; choose 0.0 as indicator\n        return float(\"nan\")\n\n    logN = np.log(Ns[mask])\n    logRg = np.log(Rgs[mask])\n\n    # Linear regression: logRg = m * logN + b\n    m, b = np.polyfit(logN, logRg, 1)\n    if m == 0.0:\n        return float(\"nan\")\n    D_est = 1.0 / m\n    return float(D_est)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (lattice, N_final, seed, launch_margin, kill_margin)\n    test_cases = [\n        (\"square\", 220, 2023, 5, 15),  # Case A\n        (\"hex\",    220, 2023, 5, 15),  # Case B\n        (\"square\",  60,  777, 5, 15),  # Case C\n        (\"hex\",     60,  777, 5, 15),  # Case D\n    ]\n\n    results = []\n    for lattice, N_final, seed, lmargin, kmargin in test_cases:\n        D_est = simulate_dla(lattice, N_final, seed, lmargin, kmargin)\n        # Round to three decimal places as required\n        if np.isnan(D_est):\n            # In the unlikely event of NaN, output 0.000 to maintain format\n            results.append(\"0.000\")\n        else:\n            results.append(f\"{D_est:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2386014"}, {"introduction": "While the classic DLA model produces mesmerizing fractal patterns, real-world aggregates often appear more compact due to particles settling into more stable positions. This practice introduces a surface relaxation mechanism, a physically motivated rule where newly attached particles can migrate to a nearby site with a higher coordination number. By implementing this search for the most stable attachment point [@problem_id:2386015], you will explore how simple local energy-minimization rules can fundamentally alter the growth process, leading to denser structures and providing a computational analogue to physical effects like annealing.", "problem": "You will implement a lattice model of diffusion-limited aggregation (DLA) with a surface relaxation mechanism. The purpose is to connect the discrete random walk model of diffusion to aggregation dynamics and then to a physically motivated restructuring rule that favors locally higher coordination. The fundamental base consists of the following facts: (i) on a sufficiently fine lattice, an unbiased discrete-time random walk approximates Brownian motion, which models diffusion governed by Fick’s laws; (ii) DLA is modeled by launching random walkers that adhere irreversibly upon first encounter with the cluster boundary; (iii) local surface relaxation is motivated by the tendency of newly attached particles to seek configurations with greater local coordination.\n\nModel description. Consider the infinite square lattice $\\mathbb{Z}^{2}$. Initialize the cluster as the occupied set $\\mathcal{C}$ containing a single seed at the origin $(0,0)$. At all times, the cluster is a set of lattice sites. A single random walker is launched from a circle of radius $R_{\\text{launch}}$ centered at the origin, where $R_{\\text{launch}} = R_{\\text{cluster}} + m_{\\text{launch}}$, $R_{\\text{cluster}}$ is the current maximum Euclidean distance of any occupied site to the origin, and $m_{\\text{launch}}$ is a fixed integer margin. The launch point is sampled by choosing a uniform angle $\\theta \\in [0,2\\pi)$ (in radians) and placing the walker at the nearest lattice point $\\big(\\text{round}(R_{\\text{launch}}\\cos\\theta), \\text{round}(R_{\\text{launch}}\\sin\\theta)\\big)$. The walker then executes an unbiased discrete random walk on $\\mathbb{Z}^{2}$ with equal probability $1/4$ to step to any of its $4$-neighbors at each step. If the walker’s Euclidean distance from the origin exceeds a kill radius $R_{\\text{kill}} = R_{\\text{cluster}} + m_{\\text{kill}}$, the walker is discarded and a new walker is launched as above.\n\nAttachment rule. When the walker occupies a site $\\mathbf{x} \\in \\mathbb{Z}^{2}$ such that at least one of its $4$-neighbors is in $\\mathcal{C}$, define $\\mathbf{x}$ as the nascent attachment site. Let $d_{\\text{relax}}$ be a nonnegative integer. Define the candidate set $\\mathcal{S}$ as all empty lattice sites $\\mathbf{y}$ with Chebyshev distance $\\|\\mathbf{y}-\\mathbf{x}\\|_{\\infty} \\le d_{\\text{relax}}$ such that $\\mathbf{y}$ has at least one occupied $4$-neighbor (equivalently, it lies on the perimeter of $\\mathcal{C}$). For each candidate $\\mathbf{y}$, define its coordination number $z(\\mathbf{y})$ as the number of occupied $4$-neighbors of $\\mathbf{y}$. The surface relaxation mechanism places the new particle at the $\\mathbf{y} \\in \\mathcal{S}$ that maximizes $z(\\mathbf{y})$. To ensure determinism, in the event of ties, choose the $\\mathbf{y}$ with minimum squared Euclidean distance $\\|\\mathbf{y}-\\mathbf{x}\\|_{2}^{2}$ to the nascent site, and if still tied, choose the lexicographically smallest $\\mathbf{y}$ by $(y\\text{-coordinate}, x\\text{-coordinate})$. Add the chosen $\\mathbf{y}$ to $\\mathcal{C}$ and update $R_{\\text{cluster}}$.\n\nMetrics. After aggregating $N$ particles (so that $|\\mathcal{C}| = N+1$ including the seed), compute:\n- The mean coordination number $\\bar{z}$, defined as the average of $z(\\mathbf{c})$ over all occupied sites $\\mathbf{c} \\in \\mathcal{C}$, where $z(\\mathbf{c})$ counts the number of occupied $4$-neighbors of $\\mathbf{c}$. This is a dimensionless quantity and must be reported rounded to $3$ decimal places.\n- The radius of gyration $R_{g}$ in lattice units, defined by\n$$\nR_{g} = \\sqrt{\\frac{1}{|\\mathcal{C}|}\\sum_{\\mathbf{c}\\in \\mathcal{C}} \\|\\mathbf{c} - \\mathbf{r}_{\\text{cm}}\\|_{2}^{2}}, \\quad \\mathbf{r}_{\\text{cm}} = \\frac{1}{|\\mathcal{C}|}\\sum_{\\mathbf{c}\\in \\mathcal{C}} \\mathbf{c},\n$$\nwhere $\\mathbf{r}_{\\text{cm}}$ is the center of mass of the occupied sites. Express $R_{g}$ in lattice units and round to $3$ decimal places.\n\nTest suite. Use the following three test cases on the same infinite lattice model, with the specified parameters and a fixed pseudo-random number generator seed for reproducibility:\n- Case A (baseline DLA without relaxation): $N=200$, $d_{\\text{relax}}=0$, $m_{\\text{launch}}=5$, $m_{\\text{kill}}=15$, seed $s=12345$.\n- Case B (mild relaxation): $N=200$, $d_{\\text{relax}}=1$, $m_{\\text{launch}}=5$, $m_{\\text{kill}}=15$, seed $s=12345$.\n- Case C (stronger relaxation): $N=200$, $d_{\\text{relax}}=2$, $m_{\\text{launch}}=5$, $m_{\\text{kill}}=15$, seed $s=12345$.\n\nAngle unit requirement. Any angles used for launch position sampling must be in radians.\n\nFinal output format. Your program must produce a single line of output containing a list of the results for the three cases as a comma-separated list enclosed in square brackets. Each case’s result must be a two-element list of the form $[\\bar{z}, R_{g}]$ with both entries rounded to $3$ decimal places as specified above. For example, the overall format must be\n\"[[zA,RgA],[zB,RgB],[zC,RgC]]\"\nwith no additional text. All radii are in lattice units, and all floating-point results must be rounded to $3$ decimal places.", "solution": "The problem has been subjected to validation and is determined to be valid. It is scientifically grounded, well-posed, and objective. The problem describes a discrete lattice model for diffusion-limited aggregation (DLA) incorporating a surface relaxation mechanism, a standard topic in computational statistical physics. The model is defined with mathematical precision, providing unambiguous rules for particle generation, movement, and attachment, along with specific, deterministic tie-breaking criteria. The parameters for the test suite are fully specified, ensuring the problem is self-contained and reproducible.\n\nThe solution is an algorithmic implementation of the described physical model. The simulation proceeds by iteratively adding particles to a growing cluster until the desired size is reached. The core of the algorithm is a loop that executes for each of the $N$ particles to be aggregated.\n\nFirst, we initialize the system. The cluster, $\\mathcal{C}$, is represented as a set of occupied integer coordinate pairs $(x,y)$. It is initialized with a single seed particle at the origin, so $\\mathcal{C} = \\{(0,0)\\}$. A pseudo-random number generator is seeded with the specified value $s$ to ensure reproducibility. The simulation then runs for $N$ iterations, with each iteration adding one particle to $\\mathcal{C}$.\n\nAt the beginning of each iteration, key dynamic parameters are updated. The cluster's maximal radius, $R_{\\text{cluster}}$, is computed as the maximum Euclidean distance from the origin to any site in $\\mathcal{C}$. Based on this, the launch radius $R_{\\text{launch}} = R_{\\text{cluster}} + m_{\\text{launch}}$ and the kill radius $R_{\\text{kill}} = R_{\\text{cluster}} + m_{\\text{kill}}$ are established.\n\nNext, a particle is introduced and its dynamics are simulated. This involves a nested loop that continues until a particle successfully attaches to the cluster.\n1.  **Launch**: A walker is launched from a random position on the launch circle. An angle $\\theta$ is sampled uniformly from $[0, 2\\pi)$. The launch coordinates are determined by finding the nearest integer lattice site to the point $(R_{\\text{launch}}\\cos\\theta, R_{\\text{launch}}\\sin\\theta)$, which is calculated as $(\\text{round}(R_{\\text{launch}}\\cos\\theta), \\text{round}(R_{\\text{launch}}\\sin\\theta))$.\n2.  **Random Walk**: The walker executes an unbiased random walk on the $\\mathbb{Z}^2$ lattice. At each time step, it moves to one of its four nearest neighbors with equal probability $1/4$.\n3.  **Termination Conditions**: The walk for a given particle terminates under one of two conditions:\n    *   **Kill**: If the walker's squared Euclidean distance from the origin, $x^2 + y^2$, exceeds $R_{\\text{kill}}^2$, the walker is discarded. The process then returns to the launch step to generate a new walker.\n    *   **Contact**: If the walker moves to a site $\\mathbf{x}$ that is adjacent (sharing an edge) to any site already in the cluster $\\mathcal{C}$, the random walk stops. This site $\\mathbf{x}$ is designated as the nascent attachment site.\n\nUpon contact, the attachment and relaxation mechanism is triggered. This determines the final position of the newly aggregated particle.\n1.  **Candidate Set Construction**: A set of candidate sites, $\\mathcal{S}$, is identified. This set comprises all empty lattice sites $\\mathbf{y}$ that are within a Chebyshev distance of $d_{\\text{relax}}$ from the nascent site $\\mathbf{x}$ (i.e., $\\|\\mathbf{y}-\\mathbf{x}\\|_{\\infty} \\le d_{\\text{relax}}$) and are also adjacent to at least one occupied site in the cluster $\\mathcal{C}$. The nascent site $\\mathbf{x}$ itself is guaranteed to be a member of $\\mathcal{S}$.\n2.  **Optimal Site Selection**: The final attachment site is chosen from $\\mathcal{S}$ based on a hierarchical optimization procedure to find the most stable position:\n    a.  First, we find the subset of candidates that maximize the coordination number $z(\\mathbf{y})$, defined as the number of occupied $4$-neighbors of site $\\mathbf{y}$.\n    b.  If this yields a tie (more than one candidate site has the same maximal coordination), the tie is broken by selecting the site(s) that minimize the squared Euclidean distance to the nascent site, $\\|\\mathbf{y}-\\mathbf{x}\\|_2^2$.\n    c.  If a tie still persists, the final tie is broken by choosing the site that is lexicographically smallest, based on an ordering of the coordinates $(y, x)$.\nThe uniquely determined optimal site is then added to the cluster $\\mathcal{C}$, and the main simulation loop proceeds to the next particle.\n\nAfter all $N$ particles have been aggregated, resulting in a total cluster size of $|\\mathcal{C}| = N+1$, the final metrics are computed.\n*   The center of mass, $\\mathbf{r}_{\\text{cm}}$, is calculated as the vector average of the coordinates of all sites in the cluster: $\\mathbf{r}_{\\text{cm}} = \\frac{1}{|\\mathcal{C}|}\\sum_{\\mathbf{c}\\in \\mathcal{C}} \\mathbf{c}$.\n*   The radius of gyration, $R_g$, is then computed using its definition: $R_g = \\sqrt{\\frac{1}{|\\mathcal{C}|}\\sum_{\\mathbf{c}\\in \\mathcal{C}} \\|\\mathbf{c} - \\mathbf{r}_{\\text{cm}}\\|_{2}^{2}}$.\n*   The mean coordination number, $\\bar{z}$, is found by summing the coordination numbers $z(\\mathbf{c})$ for every site $\\mathbf{c} \\in \\mathcal{C}$ and dividing by the total number of sites $|\\mathcal{C}|$. That is, $\\bar{z} = \\frac{1}{|\\mathcal{C}|} \\sum_{\\mathbf{c} \\in \\mathcal{C}} z(\\mathbf{c})$.\n\nThese two metrics, $R_g$ and $\\bar{z}$, are rounded to $3$ decimal places as required. The entire procedure is repeated for each of the three test cases specified, using the same random seed to ensure that the variation in results is due only to the change in the relaxation parameter $d_{\\text{relax}}$. The final output is formatted as a list of pairs, one for each test case.", "answer": "```python\nimport numpy as np\n\ndef run_simulation(N, d_relax, m_launch, m_kill, seed):\n    \"\"\"\n    Runs a single DLA simulation with surface relaxation.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    cluster = {(0, 0)}\n    \n    num_particles_to_add = N\n    \n    # Pre-define the 4-neighbor relative coordinates\n    NEIGHBOR_DELTAS = np.array([[1, 0], [-1, 0], [0, 1], [0, -1]])\n\n    for _ in range(num_particles_to_add):\n        # Update radii based on current cluster state\n        coords = np.array(list(cluster))\n        r_cluster_sq = np.max(np.sum(coords**2, axis=1))\n        r_cluster = np.sqrt(r_cluster_sq)\n        \n        r_launch = r_cluster + m_launch\n        r_kill_sq = (r_cluster + m_kill)**2\n\n        attached = False\n        while not attached:\n            # Launch a new walker\n            theta = rng.uniform(0, 2 * np.pi)\n            launch_pos_float = np.array([r_launch * np.cos(theta), r_launch * np.sin(theta)])\n            walker_pos = tuple(np.round(launch_pos_float).astype(int))\n\n            # Random walk loop for the current walker\n            while True:\n                # Check kill condition\n                if walker_pos[0]**2 + walker_pos[1]**2 > r_kill_sq:\n                    break  # Walker is killed, launch a new one\n\n                # Check for contact (nascent attachment)\n                neighbors = [(walker_pos[0] + dx, walker_pos[1] + dy) for dx, dy in NEIGHBOR_DELTAS]\n                if any(n in cluster for n in neighbors):\n                    nascent_site = walker_pos\n                    \n                    # ATTACHMENT AND RELAXATION LOGIC\n                    \n                    # 1. Construct candidate set\n                    candidates = []\n                    x_n, y_n = nascent_site\n                    for dy in range(-d_relax, d_relax + 1):\n                        for dx in range(-d_relax, d_relax + 1):\n                            cand_site = (x_n + dx, y_n + dy)\n                            if cand_site in cluster:\n                                continue\n                            \n                            cand_neighbors = [(cand_site[0] + d_dx, cand_site[1] + d_dy) for d_dx, d_dy in NEIGHBOR_DELTAS]\n                            if any(n in cluster for n in cand_neighbors):\n                                candidates.append(cand_site)\n                    \n                    # 2. Find the best candidate using hierarchical sorting\n                    def get_sort_key(cand):\n                        # Calculate coordination number z\n                        cand_neighbors = [(cand[0] + dx, cand[1] + dy) for dx, dy in NEIGHBOR_DELTAS]\n                        z = sum(1 for n in cand_neighbors if n in cluster)\n                        \n                        # Calculate squared Euclidean distance to nascent site\n                        d2 = (cand[0] - nascent_site[0])**2 + (cand[1] - nascent_site[1])**2\n                        \n                        # Return tuple for sorting: max z, min d2, min y, min x\n                        return (-z, d2, cand[1], cand[0])\n\n                    candidates.sort(key=get_sort_key)\n                    best_site = candidates[0]\n                    \n                    cluster.add(best_site)\n                    attached = True\n                    break # Exit walk loop, then the launch loop for this particle\n\n                # Move walker to a random neighbor\n                move = NEIGHBOR_DELTAS[rng.integers(0, 4)]\n                walker_pos = (walker_pos[0] + move[0], walker_pos[1] + move[1])\n    \n    # Simulation complete, calculate metrics\n    final_coords = np.array(list(cluster))\n    num_total_particles = len(final_coords)\n    \n    # Metric 1: Mean coordination number\n    total_z = 0\n    for c in cluster:\n        c_neighbors = [(c[0] + dx, c[1] + dy) for dx, dy in NEIGHBOR_DELTAS]\n        total_z += sum(1 for n in c_neighbors if n in cluster)\n    mean_z = total_z / num_total_particles\n    \n    # Metric 2: Radius of gyration\n    r_cm = np.mean(final_coords, axis=0)\n    sq_dists_from_cm = np.sum((final_coords - r_cm)**2, axis=1)\n    r_g = np.sqrt(np.mean(sq_dists_from_cm))\n    \n    return [round(mean_z, 3), round(r_g, 3)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, d_relax, m_launch, m_kill, seed)\n        (200, 0, 5, 15, 12345),  # Case A\n        (200, 1, 5, 15, 12345),  # Case B\n        (200, 2, 5, 15, 12345),  # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        N, d_relax, m_launch, m_kill, seed = case\n        result = run_simulation(N, d_relax, m_launch, m_kill, seed)\n        results.append(result)\n\n    # Format the final output string exactly as specified, without spaces in the inner lists.\n    formatted_results = [f'[{z},{Rg}]' for z, Rg in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2386015"}, {"introduction": "The characteristic sparse, branching structure of DLA arises because the outermost tips of the cluster are most likely to be hit by a diffusing particle. This practice explores a \"noise reduction\" scheme to counteract this effect, requiring a site to be visited multiple times before a particle permanently sticks. By implementing this rule [@problem_id:2386048], you will investigate how a kinetic parameter can systematically tune the aggregate's morphology from a sparse fractal towards a dense, compact object, and you will analyze how the effective fractal dimension $D_f$ depends on this \"stickiness\" threshold.", "problem": "Consider two-dimensional Diffusion-Limited Aggregation (DLA) on the integer lattice, where a single immobile seed occupies the origin at time $t=0$. Particles are released one at a time from a launching circle and perform unbiased nearest-neighbor random walks in discrete time. A noise-reduction rule is imposed: a particle does not immediately stick upon first landing adjacent to the cluster. Instead, each empty lattice site maintains an integer counter of how many times a random walker has landed there while that site has at least one nearest-neighbor already occupied. A site becomes permanently occupied only when its counter reaches a prescribed positive integer threshold $m$. The objective is to generate clusters for different $m$ and estimate the fractal dimension $D_f(m)$ via mass–radius scaling.\n\nModel specification:\n- Lattice: the set of integer pairs $(x,y)\\in\\mathbb{Z}^2$.\n- Seed: at time $t=0$, the occupied set is $\\{(0,0)\\}$.\n- Random walk dynamics: a walker at $(x,y)$ moves in one discrete step to $(x\\pm 1,y)$ or $(x,y\\pm 1)$ with equal probability $1/4$ per step.\n- Launch rule: let $R(t)$ denote the current cluster radius, defined as the maximum Euclidean distance $\\sqrt{x^2+y^2}$ over all occupied sites at time $t$. Define a margin $r_{\\mathrm{margin}}=5$ and a minimum launch radius $r_{\\min}=10$. Each new walker is launched from a uniformly random angle (in radians) on the circle of radius $r_{\\mathrm{launch}}=\\max\\{R(t)+r_{\\mathrm{margin}},\\,r_{\\min}\\}$, at the nearest lattice site to that circle. Angles must be sampled uniformly in $[0,2\\pi)$.\n- Kill rule: define a kill radius $r_{\\mathrm{kill}}=r_{\\mathrm{launch}}+3\\,r_{\\mathrm{margin}}$. If a walker’s Euclidean distance from the origin ever exceeds $r_{\\mathrm{kill}}$, that walker is discarded and a new walker is launched as above.\n- Exclusion: a proposed step that would place a walker on an occupied site is rejected and immediately resampled; equivalently, the walker remains at its current lattice site for that time step and draws a new direction on the next step.\n- Landing event and noise reduction: a landing event occurs whenever a walker is at an empty lattice site $(x,y)$ such that at least one of its four nearest neighbors is occupied. Each empty site $(x,y)$ maintains an integer counter $c(x,y)$ that starts at $0$ and is incremented by $1$ on each landing event at $(x,y)$. When $c(x,y)$ first reaches the threshold $m$, the site $(x,y)$ becomes permanently occupied, $c(x,y)$ is no longer needed for that site, and the current walker is removed. The cluster radius $R(t)$ is updated accordingly.\n- Termination: continue launching walkers and applying the above rules until the occupied set has cardinality exactly $N$.\n\nFractal dimension estimation:\n- For a completed cluster with occupied set $\\mathcal{C}$ of size $|\\mathcal{C}|=N$, define the cluster radius $R_{\\max}=\\max\\{\\sqrt{x^2+y^2}:(x,y)\\in\\mathcal{C}\\}$ and the mass function $M(R)=|\\{(x,y)\\in\\mathcal{C}:\\sqrt{x^2+y^2}\\le R\\}|$.\n- Define fitting window parameters $\\alpha=0.2$ and $\\beta=0.9$. Let $R_{\\min}=\\lceil\\alpha R_{\\max}\\rceil$ and $R_{\\mathrm{fit}}=\\lfloor\\beta R_{\\max}\\rfloor$. Consider the set of integer radii $\\{R_i\\}_{i=1}^K=\\{R\\in\\mathbb{Z}: R_{\\min}\\le R\\le R_{\\mathrm{fit}},\\,R\\ge 1\\}$, ordered increasingly, where $K$ is the number of such radii. For each $R_i$, compute $M(R_i)$. Estimate $D_f$ as the slope of the least-squares best-fit line to the points $\\{(\\log R_i,\\log M(R_i))\\}_{i=1}^K$.\n- All logarithms are natural logarithms.\n\nTest suite and required outputs:\n- Use the following test cases, each specified by the tuple $(m,N,\\text{seed})$, where “seed” initializes the random number generator to ensure reproducibility:\n  1. $(m=1,\\,N=900,\\,\\text{seed}=1337)$\n  2. $(m=3,\\,N=700,\\,\\text{seed}=2021)$\n  3. $(m=5,\\,N=600,\\,\\text{seed}=31415)$\n- For each case, simulate the cluster according to the model, estimate $D_f$ as above, and round the result to three decimal places.\n- Final output format: Your program should produce a single line of output containing the three rounded $D_f$ estimates as a comma-separated list enclosed in square brackets (for example, $[1.700,1.750,1.780]$). No additional text or lines should be printed. Angles must be in radians. All quantities are dimensionless, so no physical unit conversion is required.", "solution": "The problem statement is evaluated to be **valid**. It describes a well-posed problem in computational physics, specifically the simulation of noise-reduced Diffusion-Limited Aggregation (DLA) on a two-dimensional integer lattice. All parameters, rules, and objectives are specified with sufficient clarity and scientific soundness to permit a unique, reproducible solution.\n\nThe problem requires the simulation of cluster growth and subsequent estimation of the fractal dimension $D_f$. The core of the solution is a stochastic simulation algorithm, followed by a data analysis step using linear regression. The process must be repeated for three distinct test cases defined by the noise-reduction threshold $m$, the final cluster size $N$, and a random number generator seed.\n\n**Algorithmic Approach**\n\nThe simulation will be conducted on a sparse representation of the $\\mathbb{Z}^2$ lattice, which is necessary as the lattice is unbounded. The following data structures are employed:\n1.  **Occupied Sites**: A set of coordinate tuples, `occupied_sites`, stores the positions of particles that form the aggregated cluster. A `set` provides efficient $O(1)$ average time complexity for membership testing, which is crucial for the exclusion rule.\n2.  **Perimeter Sites**: A set, `perimeter_sites`, stores the coordinates of all empty sites that are nearest neighbors to at least one site in the cluster. This optimizes the check for a \"landing event,\" which by definition can only occur on such sites.\n3.  **Landing Counters**: A dictionary, `landing_counters`, maps perimeter site coordinates to an integer count. This tracks the number of times a random walker has visited each specific perimeter site, implementing the noise-reduction mechanism.\n\nThe simulation proceeds by adding one particle at a time until the cluster reaches the target size $N$. For each particle, the following steps are performed:\n\n1.  **Particle Launch**: A new walker is introduced into the system.\n    -   The current cluster radius, $R(t) = \\max\\{\\sqrt{x^2+y^2} \\mid (x,y) \\in \\text{occupied\\_sites}\\}$, is determined. To optimize, we maintain the maximum squared radius and update it only upon aggregation.\n    -   A launch radius $r_{\\mathrm{launch}} = \\max\\{R(t) + r_{\\mathrm{margin}}, r_{\\min}\\}$ is calculated, with $r_{\\mathrm{margin}} = 5$ and $r_{\\min} = 10$.\n    -   A random angle $\\theta$ is sampled uniformly from $[0, 2\\pi)$.\n    -   The walker is placed at the integer lattice site $(x, y)$ that is nearest to the point $(r_{\\mathrm{launch}}\\cos\\theta, r_{\\mathrm{launch}}\\sin\\theta)$ on the launch circle. This is achieved by rounding the floating-point coordinates. If this site is occupied (a rare event), a new angle is sampled until an empty launch site is found.\n    -   A kill radius is defined as $r_{\\mathrm{kill}} = r_{\\mathrm{launch}} + 3 \\cdot r_{\\mathrm{margin}}$.\n\n2.  **Random Walk**: The walker performs an unbiased random walk on the lattice. At each discrete time step:\n    -   **Kill Condition**: The walker's Euclidean distance from the origin is checked. If it exceeds $r_{\\mathrm{kill}}$, the walker is discarded, and the simulation proceeds to launch a new walker.\n    -   **Landing Event and Sticking**: It is checked if the walker's current position is in the `perimeter_sites` set.\n        -   If it is, a landing event occurs. The corresponding counter in `landing_counters` is incremented.\n        -   If the counter for this site reaches the threshold $m$, the site becomes part of the cluster. The `occupied_sites` and `perimeter_sites` sets are updated, the maximum cluster radius is recalculated, and the current walker is removed. A new walker is then launched.\n    -   **Movement**: A direction (up, down, left, or right) is chosen with equal probability $1/4$.\n        -   A proposed `next_pos` is calculated.\n        -   **Exclusion Rule**: If `next_pos` is in `occupied_sites`, the walker does not move in this time step.\n        -   Otherwise, the walker's position is updated to `next_pos`.\n\n**Fractal Dimension Estimation**\n\nAfter the cluster has grown to size $N$, its fractal dimension $D_f$ is estimated based on the mass-radius scaling relationship, $M(R) \\propto R^{D_f}$. This relationship is linear in a log-log plot: $\\log M(R) = D_f \\log R + \\text{const}$.\n\n1.  **Data Collection**:\n    -   The maximum radius of the final cluster, $R_{\\max}$, is determined.\n    -   A fitting window for the radius is defined by $R_{\\min-\\text{fit}} = \\lceil\\alpha R_{\\max}\\rceil$ and $R_{\\mathrm{fit}} = \\lfloor\\beta R_{\\max}\\rfloor$, with $\\alpha = 0.2$ and $\\beta = 0.9$.\n    -   For each integer radius $R$ in the range $[R_{\\min-\\text{fit}}, R_{\\mathrm{fit}}]$ (and $R \\ge 1$), the mass $M(R)$ is computed. $M(R)$ is the number of occupied sites within a distance $R$ from the origin.\n    -   A set of data points $(\\log R, \\log M(R))$ is generated for this range of radii. Natural logarithm is used as specified.\n\n2.  **Linear Regression**:\n    -   A simple linear regression is performed on the collected log-log data points.\n    -   The fractal dimension $D_f$ is the slope of the best-fit line. This can be calculated using standard numerical libraries, such as `numpy.polyfit`, which fits a polynomial of a specified degree to the data and returns the coefficients. For a line (degree $1$), the first coefficient is the slope.\n\nThis entire procedure is implemented within a Python script, utilizing the `numpy` library for numerical calculations and random number generation. The random generator is seeded for each test case to ensure reproducibility. The final computed values of $D_f$ are rounded to three decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_dla_and_get_df(m, N, seed):\n    \"\"\"\n    Simulates a noise-reduced DLA cluster and calculates its fractal dimension.\n\n    Args:\n        m (int): The noise reduction threshold.\n        N (int): The target number of particles in the cluster.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The estimated fractal dimension D_f.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # --- Data Structures ---\n    # The set of occupied lattice sites\n    occupied_sites = {(0, 0)}\n    # The set of empty sites adjacent to the cluster\n    perimeter_sites = {(1, 0), (-1, 0), (0, 1), (0, -1)}\n    # Counters for the number of landings on perimeter sites\n    landing_counters = {}\n    \n    current_R_sq = 0.0\n\n    # --- Model Parameters ---\n    R_MARGIN = 5\n    R_MIN_LAUNCH = 10\n    MOVES = np.array([[1, 0], [-1, 0], [0, 1], [0, -1]], dtype=np.int32)\n\n    # --- Main Simulation Loop ---\n    # Grow the cluster until it reaches size N\n    while len(occupied_sites) < N:\n        # --- 1. Set up for a new walker ---\n        current_R = np.sqrt(current_R_sq)\n        r_launch = max(current_R + R_MARGIN, R_MIN_LAUNCH)\n        r_kill_sq = (r_launch + 3 * R_MARGIN)**2\n\n        # Launch walker from a random position on the launch circle\n        while True:\n            angle = rng.uniform(0, 2 * np.pi)\n            x_c = r_launch * np.cos(angle)\n            y_c = r_launch * np.sin(angle)\n            walker_pos = (int(round(x_c)), int(round(y_c)))\n            if walker_pos not in occupied_sites:\n                break\n        \n        # --- 2. Random Walk Loop for the current walker ---\n        while True:\n            # Check kill condition\n            if walker_pos[0]**2 + walker_pos[1]**2 > r_kill_sq:\n                break  # Walker is killed, launch a new one\n\n            # Check for landing event (walker is on the cluster perimeter)\n            if walker_pos in perimeter_sites:\n                landing_counters[walker_pos] = landing_counters.get(walker_pos, 0) + 1\n                \n                # Check for sticking condition\n                if landing_counters[walker_pos] >= m:\n                    # Particle sticks!\n                    new_site = walker_pos\n                    occupied_sites.add(new_site)\n\n                    # Update cluster max radius\n                    current_R_sq = max(current_R_sq, new_site[0]**2 + new_site[1]**2)\n\n                    # Update perimeter and counters\n                    perimeter_sites.remove(new_site)\n                    if new_site in landing_counters:\n                        del landing_counters[new_site]\n\n                    for dx, dy in MOVES:\n                        neighbor = (new_site[0] + dx, new_site[1] + dy)\n                        if neighbor not in occupied_sites:\n                            perimeter_sites.add(neighbor)\n                    \n                    break # Walker has stuck, end its walk\n\n            # Perform one step of the random walk\n            move = MOVES[rng.integers(4)]\n            next_pos = (walker_pos[0] + move[0], walker_pos[1] + move[1])\n\n            # Exclusion rule: cannot move into an occupied site\n            if next_pos not in occupied_sites:\n                walker_pos = next_pos\n            # If next_pos is occupied, walker stays put for this time step\n\n    # --- 3. Fractal Dimension Estimation ---\n    ALPHA = 0.2\n    BETA = 0.9\n\n    R_max = np.sqrt(current_R_sq)\n    \n    R_min_fit = int(np.ceil(ALPHA * R_max))\n    R_fit = int(np.floor(BETA * R_max))\n\n    if R_min_fit > R_fit or R_fit < 1:\n        return np.nan # Not enough range for fitting\n\n    radii_for_fit = list(range(max(1, R_min_fit), R_fit + 1))\n    if not radii_for_fit:\n      return np.nan\n\n    log_R_values = []\n    log_M_values = []\n    \n    # Pre-calculate squared distances of all particles from origin\n    dist_sq_array = np.array([x**2 + y**2 for x, y in occupied_sites])\n    \n    for R_i in radii_for_fit:\n        R_i_sq = R_i**2\n        mass = np.sum(dist_sq_array <= R_i_sq)\n        if mass > 0:\n            log_R_values.append(np.log(R_i))\n            log_M_values.append(np.log(mass))\n\n    if len(log_R_values) < 2:\n        return np.nan # Not enough points for a linear regression\n\n    # Perform least-squares fit: log(M) = D_f * log(R) + C\n    # np.polyfit returns [slope, intercept]\n    slope, _ = np.polyfit(log_R_values, log_M_values, 1)\n    D_f = slope\n    \n    return D_f\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 900, 1337),\n        (3, 700, 2021),\n        (5, 600, 31415),\n    ]\n\n    results = []\n    for m, N, seed in test_cases:\n        df = simulate_dla_and_get_df(m, N, seed)\n        # Round result to three decimal places\n        results.append(f\"{df:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2386048"}]}