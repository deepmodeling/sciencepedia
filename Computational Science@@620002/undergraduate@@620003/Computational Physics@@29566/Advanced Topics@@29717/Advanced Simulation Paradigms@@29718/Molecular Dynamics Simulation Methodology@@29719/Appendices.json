{"hands_on_practices": [{"introduction": "One of the primary goals of molecular dynamics is to compute macroscopic observables, like pressure, from the underlying microscopic interactions. The theoretical bridge between the microscopic and macroscopic is the virial theorem. This practice [@problem_id:2414258] focuses on the crucial task of implementing the pressure calculation for a system under periodic boundary conditions (PBC), a standard technique for simulating bulk matter. By contrasting the correct implementation using the minimum image convention with an intentionally flawed one, you will gain a deep, practical understanding of why correctly handling interactions across periodic boundaries is a physical necessity, not just a technical detail.", "problem": "You are asked to implement a mechanical route pressure computation for a three-dimensional Lennard–Jones fluid within a cubic periodic simulation box. The objective is twofold: compute the instantaneous pressure using the virial theorem with a correct periodic treatment, and, in parallel, compute an erroneous pressure that intentionally mishandles periodic boundary conditions to expose the impact of such an error. Your final program must be a single, complete, runnable script that uses only the specified environment and prints the required outputs for the given test suite.\n\nAll calculations must use reduced Lennard–Jones units, where the energy scale $\\epsilon$ and the length scale $\\sigma$ are set to $\\epsilon = 1$ and $\\sigma = 1$, and the Boltzmann constant is $k_{\\mathrm{B}} = 1$. Express every pressure in the unit $\\epsilon/\\sigma^{3}$. Use a spherical cutoff radius $r_{\\mathrm{c}} = 2.5\\,\\sigma$ without shifting the potential or applying tail corrections.\n\nStarting from fundamental laws and core definitions:\n- Newton’s second law $m \\,\\mathrm{d}^{2}\\mathbf{r}/\\mathrm{d}t^{2} = \\mathbf{f}$ and the concept of pairwise central forces,\n- the classical virial theorem’s mechanical route to pressure for $N$ particles interacting via pair potentials,\n- the periodic boundary conditions in a cubic box of edge length $L$,\n\nderive an algorithm to compute the instantaneous pressure $P$ for a single configuration at a given temperature $T$. The pressure must have the ideal-gas contribution $\\rho k_{\\mathrm{B}} T$ with number density $\\rho = N/V$ and volume $V = L^{3}$, plus a configurational virial term obtained by summing over all distinct pairs $i<j$ using pairwise forces generated by the Lennard–Jones potential\n$$\nu(r) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right],\\quad \\text{for } r < r_{\\mathrm{c}},\n$$\nand $u(r)=0$ otherwise. Here $r$ is the scalar distance between two particles. Angles, if any, are implicit through vector dot products in radians.\n\nImplement two algorithms:\n- Correct algorithm: compute the pair separation vector $\\mathbf{r}_{ij}$ using the minimum image convention in a cubic periodic box of edge length $L$, namely for each Cartesian component $\\alpha \\in \\{x,y,z\\}$,\n$$\n\\Delta r_{\\alpha} \\leftarrow \\Delta r_{\\alpha} - L\\ \\mathrm{round}\\!\\left(\\frac{\\Delta r_{\\alpha}}{L}\\right),\n$$\nthen obtain $r = \\|\\mathbf{r}_{ij}\\|$, include the pair only if $r < r_{\\mathrm{c}}$, compute the pairwise force from $- \\mathrm{d}u/\\mathrm{d}r$, and accumulate the configurational virial using the mechanical definition based on the dot product $\\mathbf{r}_{ij}\\cdot \\mathbf{f}_{ij}$. Finally, add the ideal-gas term $\\rho k_{\\mathrm{B}} T$.\n- Erroneous algorithm (deliberately wrong): compute the pair separation vector as the raw difference without the minimum image convention, use that raw distance to decide the cutoff and to compute the virial contribution. Keep all other steps identical. This incorrect handling of periodicity is the only intended error.\n\nScientific and numerical details and requirements:\n- Use reduced units with $k_{\\mathrm{B}}=\\epsilon=\\sigma=1$ and report pressure in $\\epsilon/\\sigma^{3}$.\n- Use the Lennard–Jones force derived from the given potential and apply a hard cutoff at $r_{\\mathrm{c}}$; do not apply any long-range corrections.\n- The final numerical outputs must be rounded to six decimal places.\n\nTest suite (each test case independently defines $L$, $T$, and particle positions):\n- Test A (happy path, no boundary-crossing interactions): $L=10.0$, $T=1.2$, positions for $N=3$,\n  - $\\mathbf{r}_{1}=(1.0,\\,1.0,\\,1.0)$,\n  - $\\mathbf{r}_{2}=(2.0,\\,2.0,\\,2.0)$,\n  - $\\mathbf{r}_{3}=(3.0,\\,3.0,\\,3.0)$.\n- Test B (boundary-crossing pair to expose the error): $L=4.0$, $T=0.5$, positions for $N=2$,\n  - $\\mathbf{r}_{1}=(0.2,\\,0.1,\\,0.1)$,\n  - $\\mathbf{r}_{2}=(3.1,\\,0.1,\\,0.1)$.\n- Test C (mixed interactions, including a boundary-crossing diagonal pair): $L=5.0$, $T=1.0$, positions for $N=4$,\n  - $\\mathbf{r}_{1}=(0.2,\\,0.2,\\,0.2)$,\n  - $\\mathbf{r}_{2}=(4.3,\\,0.2,\\,0.2)$,\n  - $\\mathbf{r}_{3}=(2.5,\\,2.5,\\,2.5)$,\n  - $\\mathbf{r}_{4}=(3.6,\\,2.5,\\,2.5)$.\n\nYour program must:\n- Implement both the correct and the erroneous algorithms as specified above.\n- For each test case, compute two floats: the correct pressure and the erroneous pressure, in the unit $\\epsilon/\\sigma^{3}$, each rounded to six decimal places.\n- Produce a single line of output containing the results as a comma-separated list of lists in the exact format\n  “[ [P_correct_A,P_erroneous_A],[P_correct_B,P_erroneous_B],[P_correct_C,P_erroneous_C] ]”\n  with each float shown to six decimal places. For example: “[[0.123456,0.000001],[...],[...]]”.\n\nThe final outputs are purely numerical floats; no units or symbols should be printed. The use of radians is implicit in any vector operations and does not require explicit angle outputs.", "solution": "The problem statement is valid. It presents a well-defined task in computational physics, grounded in the principles of statistical mechanics and molecular simulation. All necessary parameters and definitions are provided, and there are no scientific or logical inconsistencies. We shall proceed with a full solution.\n\nThe objective is to compute the instantaneous pressure of a Lennard-Jones fluid in a periodic cubic box. The pressure $P$ in a system of $N$ particles in a volume $V$ at temperature $T$ is given by the virial theorem. The general expression is:\n$$\nP = \\rho k_{\\mathrm{B}} T + \\frac{1}{3V} \\left\\langle \\sum_{i=1}^{N} \\mathbf{r}_i \\cdot \\mathbf{f}_i^{\\text{int}} \\right\\rangle\n$$\nHere, $\\rho = N/V$ is the number density, $k_{\\mathrm{B}}$ is the Boltzmann constant, $\\mathbf{r}_i$ is the position of particle $i$, and $\\mathbf{f}_i^{\\text{int}}$ is the total internal force acting on particle $i$ due to all other particles in the system. The angle brackets $\\langle \\cdot \\rangle$ denote a time average, which for instantaneous pressure are omitted.\n\nThe total internal force on particle $i$ is the sum of pairwise forces: $\\mathbf{f}_i^{\\text{int}} = \\sum_{j \\ne i} \\mathbf{f}_{ij}$, where $\\mathbf{f}_{ij}$ is the force on particle $i$ from particle $j$. The virial term can be rewritten as a sum over unique pairs $(i, j)$ with $i<j$:\n$$\n\\sum_{i=1}^{N} \\mathbf{r}_i \\cdot \\mathbf{f}_i^{\\text{int}} = \\sum_{i=1}^{N} \\mathbf{r}_i \\cdot \\sum_{j \\ne i} \\mathbf{f}_{ij} = \\sum_{i<j} (\\mathbf{r}_i \\cdot \\mathbf{f}_{ij} + \\mathbf{r}_j \\cdot \\mathbf{f}_{ji})\n$$\nBy Newton's third law, $\\mathbf{f}_{ji} = -\\mathbf{f}_{ij}$. Thus, the sum becomes:\n$$\n\\sum_{i<j} (\\mathbf{r}_i - \\mathbf{r}_j) \\cdot \\mathbf{f}_{ij} = \\sum_{i<j} (-\\mathbf{r}_{ij}) \\cdot \\mathbf{f}_{ij}\n$$\nwhere $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$ is the separation vector from particle $i$ to $j$. The force $\\mathbf{f}_{ij}$ (force on $i$ from $j$) is $\\mathbf{f}_{ij} = -\\nabla_{\\mathbf{r}_i} u(r_{ij})$. For a central potential, this is:\n$$\n\\mathbf{f}_{ij} = -\\frac{\\mathrm{d}u}{\\mathrm{d}r_{ij}} \\frac{\\partial r_{ij}}{\\partial \\mathbf{r}_i} = -\\frac{\\mathrm{d}u}{\\mathrm{d}r_{ij}} \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{r_{ij}} = \\frac{\\mathrm{d}u}{\\mathrm{d}r_{ij}} \\frac{\\mathbf{r}_{ij}}{r_{ij}}\n$$\nSubstituting this into the pair virial expression gives:\n$$\n(-\\mathbf{r}_{ij}) \\cdot \\mathbf{f}_{ij} = (-\\mathbf{r}_{ij}) \\cdot \\left(\\frac{\\mathrm{d}u}{\\mathrm{d}r_{ij}} \\frac{\\mathbf{r}_{ij}}{r_{ij}}\\right) = -r_{ij} \\frac{\\mathrm{d}u}{\\mathrm{d}r_{ij}}\n$$\nThe pressure formula is therefore:\n$$\nP = \\rho k_{\\mathrm{B}} T + \\frac{1}{3V} \\sum_{i<j} \\left\\langle -r_{ij} \\frac{\\mathrm{d}u}{\\mathrm{d}r_{ij}} \\right\\rangle = \\rho k_{\\mathrm{B}} T - \\frac{1}{3V} \\sum_{i<j} \\left\\langle r_{ij} \\frac{\\mathrm{d}u}{\\mathrm{d}r_{ij}} \\right\\rangle\n$$\nThe Lennard-Jones potential is given by:\n$$\nu(r) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right]\n$$\nThe derivative with respect to $r$ is:\n$$\n\\frac{\\mathrm{d}u}{\\mathrm{d}r} = 4\\epsilon \\left[-12\\frac{\\sigma^{12}}{r^{13}} + 6\\frac{\\sigma^{6}}{r^{7}}\\right]\n$$\nThe pair virial term $r (\\mathrm{d}u/\\mathrm{d}r)$ is thus:\n$$\nr \\frac{\\mathrm{d}u}{\\mathrm{d}r} = 4\\epsilon \\left[-12\\left(\\frac{\\sigma}{r}\\right)^{12} + 6\\left(\\frac{\\sigma}{r}\\right)^{6}\\right] = -24\\epsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right]\n$$\nThe problem specifies reduced units where $\\epsilon=1$, $\\sigma=1$, $k_{\\mathrm{B}}=1$. The box is cubic with side length $L$, so $V=L^3$. The potential is truncated at a cutoff radius $r_{\\mathrm{c}}=2.5\\sigma=2.5$. The pressure equation for a single configuration becomes:\n$$\nP = \\frac{N T}{L^3} - \\frac{1}{3L^3} \\sum_{\\substack{i<j \\\\ r_{ij} < r_{\\mathrm{c}}}} \\left(-24 \\left[2r_{ij}^{-12} - r_{ij}^{-6}\\right]\\right)\n$$\n$$\nP = \\frac{N T}{L^3} + \\frac{8}{L^3} \\sum_{\\substack{i<j \\\\ r_{ij} < r_{\\mathrm{c}}}} \\left(2r_{ij}^{-12} - r_{ij}^{-6}\\right)\n$$\nThis is the central formula for implementation. The difference between the correct and erroneous algorithms lies solely in the calculation of the separation vector $\\mathbf{r}_{ij}$ and its magnitude $r_{ij}$.\n\n**Correct Algorithm (with Periodic Boundary Conditions):**\nFor each pair of particles $(i, j)$ with $i<j$:\n1. Compute the raw separation vector $\\Delta\\mathbf{r}_{\\text{raw}} = \\mathbf{r}_j - \\mathbf{r}_i$.\n2. Apply the minimum image convention (MIC) to each component $\\alpha \\in \\{x, y, z\\}$ to find the separation vector $\\mathbf{r}_{ij}$ in the periodic box:\n   $$\n   \\Delta r_{\\alpha} \\leftarrow \\Delta r_{\\alpha}^{\\text{raw}} - L \\cdot \\mathrm{round}\\!\\left(\\frac{\\Delta r_{\\alpha}^{\\text{raw}}}{L}\\right)\n   $$\n3. Compute the squared distance $r_{ij}^2 = (\\Delta r_x)^2 + (\\Delta r_y)^2 + (\\Delta r_z)^2$.\n4. If $r_{ij}^2 < r_{\\mathrm{c}}^2$, calculate its contribution to the virial sum. Otherwise, the contribution is zero.\n\n**Erroneous Algorithm (without Periodic Boundary Conditions):**\nFor each pair of particles $(i, j)$ with $i<j$:\n1. Compute the raw separation vector $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$.\n2. Do not apply the minimum image convention.\n3. Compute the squared distance $r_{ij}^2 = (\\Delta r_x)^2 + (\\Delta r_y)^2 + (\\Delta r_z)^2$.\n4. If $r_{ij}^2 < r_{\\mathrm{c}}^2$, calculate its contribution to the virial sum using this raw distance.\n\nThe implementation will apply these two procedures to the provided test cases, using the final derived formula.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_pressure(L, T, positions, use_pbc):\n    \"\"\"\n    Computes the instantaneous pressure of a Lennard-Jones fluid.\n\n    Args:\n        L (float): Edge length of the cubic simulation box.\n        T (float): Temperature of the system.\n        positions (np.ndarray): Nx3 array of particle positions.\n        use_pbc (bool): If True, use minimum image convention. If False, use raw coordinates.\n\n    Returns:\n        float: The computed instantaneous pressure.\n    \"\"\"\n    N = len(positions)\n    V = L**3\n    rho = N / V\n    \n    # Lennard-Jones reduced unit constants\n    rc = 2.5\n    rc2 = rc**2\n    \n    # Ideal gas contribution to pressure\n    ideal_pressure = rho * T\n\n    # Configurational contribution to pressure\n    configurational_virial_sum = 0.0\n    \n    # Loop over all unique pairs of particles\n    for i in range(N):\n        for j in range(i + 1, N):\n            # Calculate separation vector\n            rij_vec = positions[j] - positions[i]\n            \n            # Apply minimum image convention if required\n            if use_pbc:\n                rij_vec = rij_vec - L * np.round(rij_vec / L)\n            \n            # Calculate squared distance\n            r2 = np.sum(rij_vec**2)\n            \n            # Apply cutoff\n            if r2 < rc2:\n                # Calculate r^-6 and r^-12 (optimized to avoid repeated power calculations)\n                r_inv2 = 1.0 / r2\n                r_inv6 = r_inv2**3\n                r_inv12 = r_inv6**2\n                \n                # Pair virial contribution r * (du/dr) = -24 * [2*(sigma/r)^12 - (sigma/r)^6]\n                # The term in the pressure sum is 24 * [2*r^-12 - r^-6] / (3V)\n                # or 8 * [2*r^-12 - r^-6] / V\n                pair_virial_term = 2.0 * r_inv12 - r_inv6\n                configurational_virial_sum += pair_virial_term\n\n    # P = rho*kB*T + (1/3V) * sum(rij . fij)\n    # With the LJ potential, this simplifies to:\n    # P = rho*T + (8/V) * sum_pairs(2*r_ij^-12 - r_ij^-6)\n    configurational_pressure = (8.0 / V) * configurational_virial_sum\n    \n    total_pressure = ideal_pressure + configurational_pressure\n    \n    return total_pressure\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A\n        {\n            \"L\": 10.0,\n            \"T\": 1.2,\n            \"positions\": np.array([\n                [1.0, 1.0, 1.0],\n                [2.0, 2.0, 2.0],\n                [3.0, 3.0, 3.0]\n            ])\n        },\n        # Test B\n        {\n            \"L\": 4.0,\n            \"T\": 0.5,\n            \"positions\": np.array([\n                [0.2, 0.1, 0.1],\n                [3.1, 0.1, 0.1]\n            ])\n        },\n        # Test C\n        {\n            \"L\": 5.0,\n            \"T\": 1.0,\n            \"positions\": np.array([\n                [0.2, 0.2, 0.2],\n                [4.3, 0.2, 0.2],\n                [2.5, 2.5, 2.5],\n                [3.6, 2.5, 2.5]\n            ])\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        L = case[\"L\"]\n        T = case[\"T\"]\n        positions = case[\"positions\"]\n        \n        # Calculate correct pressure (with PBC)\n        p_correct = compute_pressure(L, T, positions, use_pbc=True)\n        \n        # Calculate erroneous pressure (without PBC)\n        p_erroneous = compute_pressure(L, T, positions, use_pbc=False)\n        \n        # Store results rounded to 6 decimal places as strings\n        all_results.append([f\"{p_correct:.6f}\", f\"{p_erroneous:.6f}\"])\n\n    # Format the final output string\n    # e.g., \"[[0.123456,0.000001],[...],[...]]\"\n    result_str = \"[\" + \",\".join([f\"[{c},{e}]\" for c, e in all_results]) + \"]\"\n    \n    print(result_str)\n\nsolve()\n```", "id": "2414258"}, {"introduction": "After a simulation is complete, the resulting trajectory of particle positions and velocities must be analyzed to extract meaningful physical properties. A cornerstone of statistical mechanics is the fluctuation-dissipation theorem, which connects the equilibrium fluctuations of a system to its linear response to external perturbations. This exercise [@problem_id:2414232] provides a classic application of this principle: calculating the constant-volume heat capacity, $C_V$, from the variance of the total energy, $\\langle E^2 \\rangle - \\langle E \\rangle^2$, sampled in a canonical (NVT) ensemble simulation. Mastering this technique is fundamental for characterizing the thermal properties of simulated materials.", "problem": "You are given finite time series of instantaneous total energies from four independent constant-number, constant-volume, constant-temperature (number-volume-temperature (NVT)) simulations of a classical many-particle system. Assume the simulations are ergodic and sample the canonical ensemble at fixed temperature. The total energy is denoted by $E$, the absolute temperature by $T$, and the Boltzmann constant by $k_B$. Use $k_B = 1.380649\\times 10^{-23}\\ \\mathrm{J/K}$. Throughout, treat the provided energy lists as the complete dataset for each case. Interpret all energies in joules and all temperatures in kelvin. The desired quantity is the heat capacity at constant volume $C_V$ expressed in joules per kelvin. Use the canonical-ensemble fluctuation relation that connects $C_V$ to the equilibrium energy moments, together with the definition of ensemble averages, and evaluate those averages by arithmetic means over the provided finite sets. Explicitly, if $\\{E_i\\}_{i=1}^M$ is the list of $M$ sampled energies, use $\\langle f(E)\\rangle \\approx \\frac{1}{M}\\sum_{i=1}^M f(E_i)$.\n\nThe canonical-ensemble relation to be used is\n$$\nC_V \\;=\\; \\frac{\\langle E^2\\rangle - \\langle E\\rangle^2}{k_\\mathrm{B}\\,T^2}.\n$$\n\nFor each test case, compute $C_V$ in $\\mathrm{J/K}$ and report each result rounded to six significant figures in scientific notation.\n\nTest suite:\n\n- Case 1 (happy path): $T = 300\\ \\mathrm{K}$, with energy list\n$[\\,1.14\\times 10^{-19},\\ 1.16\\times 10^{-19},\\ 1.18\\times 10^{-19},\\ 1.20\\times 10^{-19},\\ 1.22\\times 10^{-19},\\ 1.24\\times 10^{-19},\\ 1.26\\times 10^{-19},\\ 1.14\\times 10^{-19},\\ 1.16\\times 10^{-19},\\ 1.18\\times 10^{-19},\\ 1.20\\times 10^{-19},\\ 1.22\\times 10^{-19},\\ 1.24\\times 10^{-19},\\ 1.26\\times 10^{-19}\\,]\\ \\mathrm{J}$.\n\n- Case 2 (boundary: zero fluctuations): $T = 300\\ \\mathrm{K}$, with energy list\n$[\\,8.0\\times 10^{-20},\\ 8.0\\times 10^{-20},\\ 8.0\\times 10^{-20},\\ 8.0\\times 10^{-20},\\ 8.0\\times 10^{-20},\\ 8.0\\times 10^{-20},\\ 8.0\\times 10^{-20},\\ 8.0\\times 10^{-20}\\,]\\ \\mathrm{J}$.\n\n- Case 3 (temperature scaling check): $T = 600\\ \\mathrm{K}$, with energy list\n$[\\,9.9\\times 10^{-20},\\ 1.01\\times 10^{-19},\\ 1.03\\times 10^{-19},\\ 1.05\\times 10^{-19},\\ 1.07\\times 10^{-19},\\ 1.09\\times 10^{-19},\\ 1.11\\times 10^{-19},\\ 9.9\\times 10^{-20},\\ 1.01\\times 10^{-19},\\ 1.03\\times 10^{-19},\\ 1.05\\times 10^{-19},\\ 1.07\\times 10^{-19},\\ 1.09\\times 10^{-19},\\ 1.11\\times 10^{-19}\\,]\\ \\mathrm{J}$.\n\n- Case 4 (edge: very small sample size): $T = 250\\ \\mathrm{K}$, with energy list\n$[\\,4.8\\times 10^{-20},\\ 5.2\\times 10^{-20}\\,]\\ \\mathrm{J}$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $4$, for example\n$[r_1,r_2,r_3,r_4]$,\nwhere each $r_i$ is the computed value of $C_V$ in $\\mathrm{J/K}$, rounded to six significant figures and printed in scientific notation.", "solution": "In the canonical ensemble at fixed number of particles and volume, the system is in thermal equilibrium with a heat bath at absolute temperature $T$. The probability of a microstate with energy $E$ is proportional to $\\exp(-\\beta E)$ times the density of states, where $\\beta = 1/(k_B T)$. The partition function is $Z(\\beta) = \\sum_{\\text{states}} \\exp(-\\beta E)$. The ensemble-averaged energy is $\\langle E \\rangle = -\\partial \\ln Z / \\partial \\beta$. The heat capacity at constant volume is defined by $C_V = (\\partial \\langle E \\rangle / \\partial T)_V$. Using $\\beta = 1/(k_B T)$ and the chain rule,\n$$\n\\frac{\\partial}{\\partial T} = \\frac{\\partial \\beta}{\\partial T}\\,\\frac{\\partial}{\\partial \\beta} = -\\frac{1}{k_B T^2}\\,\\frac{\\partial}{\\partial \\beta}.\n$$\nTherefore,\n$$\nC_V = \\left(\\frac{\\partial \\langle E \\rangle}{\\partial T}\\right)_V = -\\frac{1}{k_B T^2}\\,\\frac{\\partial \\langle E \\rangle}{\\partial \\beta}.\n$$\nThe derivative of the average energy with respect to $\\beta$ is related to the variance of the energy:\n$$\n\\frac{\\partial \\langle E \\rangle}{\\partial \\beta} = -(\\langle E^2 \\rangle - \\langle E \\rangle^2).\n$$\nCombining these expressions yields the fluctuation-dissipation relation\n$$\nC_V = \\frac{\\langle E^2 \\rangle - \\langle E \\rangle^2}{k_B T^2}.\n$$\nFor a finite ergodic time series $\\{E_i\\}_{i=1}^M$ from a number-volume-temperature (NVT) simulation, ensemble averages are approximated by arithmetic means,\n$$\n\\langle E \\rangle \\approx \\frac{1}{M}\\sum_{i=1}^M E_i,\\qquad \\langle E^2 \\rangle \\approx \\frac{1}{M}\\sum_{i=1}^M E_i^2.\n$$\nHence, an estimator of $C_V$ from the given data is\n$$\nC_V \\approx \\frac{\\left(\\frac{1}{M}\\sum_{i=1}^M E_i^2\\right) - \\left(\\frac{1}{M}\\sum_{i=1}^M E_i\\right)^2}{k_B T^2}.\n$$\n\nApply this to each case.\n\nCase $1$: Let $M=14$, $T = 300\\ \\mathrm{K}$, and the list of energies in joules is\n$[\\,1.14\\times 10^{-19},\\ 1.16\\times 10^{-19},\\ 1.18\\times 10^{-19},\\ 1.20\\times 10^{-19},\\ 1.22\\times 10^{-19},\\ 1.24\\times 10^{-19},\\ 1.26\\times 10^{-19},\\ 1.14\\times 10^{-19},\\ 1.16\\times 10^{-19},\\ 1.18\\times 10^{-19},\\ 1.20\\times 10^{-19},\\ 1.22\\times 10^{-19},\\ 1.24\\times 10^{-19},\\ 1.26\\times 10^{-19}\\,]$. By symmetry of the list about $1.20\\times 10^{-19}\\ \\mathrm{J}$, the sample mean is $\\langle E \\rangle \\approx 1.20\\times 10^{-19}\\ \\mathrm{J}$. Writing $E_i = E_0 + d x_i$ with $E_0 = 1.20\\times 10^{-19}\\ \\mathrm{J}$, $d = 2.0\\times 10^{-21}\\ \\mathrm{J}$, and $x_i \\in \\{-3,-2,-1,0,1,2,3\\}$ repeated twice, we have $\\langle x \\rangle = 0$ and $\\langle x^2 \\rangle = 4$. Then $\\langle E^2 \\rangle - \\langle E \\rangle^2 \\approx d^2 \\langle x^2 \\rangle = 4 d^2 = 1.6\\times 10^{-41}\\ \\mathrm{J}^2$. With $k_B T^2 = (1.380649\\times 10^{-23}\\ \\mathrm{J/K})\\times (300)^2 = 1.2425841\\times 10^{-18}\\ \\mathrm{J/K}$,\n$$\nC_V \\approx \\frac{1.6\\times 10^{-41}}{1.2425841\\times 10^{-18}}\\ \\mathrm{J/K} \\approx 1.2878719\\times 10^{-23}\\ \\mathrm{J/K},\n$$\nwhich rounds to six significant figures as $1.28787\\times 10^{-23}\\ \\mathrm{J/K}$.\n\nCase $2$: $T = 300\\ \\mathrm{K}$, all energies equal to $8.0\\times 10^{-20}\\ \\mathrm{J}$. Then $\\langle E^2 \\rangle - \\langle E \\rangle^2 \\approx 0$, so\n$$\nC_V \\approx 0\\ \\mathrm{J/K}.\n$$\n\nCase $3$: $T = 600\\ \\mathrm{K}$, energies $E_i = E_0 + d x_i$ with $E_0 = 1.05\\times 10^{-19}\\ \\mathrm{J}$, $d = 4.0\\times 10^{-21}\\ \\mathrm{J}$, and the same $x_i$ pattern as in Case $1$. Then $\\langle E^2 \\rangle - \\langle E \\rangle^2 \\approx 4 d^2 = 6.4\\times 10^{-41}\\ \\mathrm{J}^2$, and $k_B T^2 = (1.380649\\times 10^{-23}\\ \\mathrm{J/K})\\times (600)^2 = 4.9703364\\times 10^{-18}\\ \\mathrm{J/K}$. Therefore,\n$$\nC_V \\approx \\frac{6.4\\times 10^{-41}}{4.9703364\\times 10^{-18}}\\ \\mathrm{J/K} \\approx 1.2878719\\times 10^{-23}\\ \\mathrm{J/K},\n$$\nwhich rounds to six significant figures as $1.28787\\times 10^{-23}\\ \\mathrm{J/K}$.\n\nCase $4$: $T = 250\\ \\mathrm{K}$, energies $[\\,4.8\\times 10^{-20},\\ 5.2\\times 10^{-20}\\,]\\ \\mathrm{J}$. The sample mean is $\\langle E \\rangle \\approx 5.0\\times 10^{-20}\\ \\mathrm{J}$. The centered values are $\\pm 2.0\\times 10^{-21}\\ \\mathrm{J}$. Thus $\\langle E^2 \\rangle - \\langle E \\rangle^2 \\approx (2.0\\times 10^{-21})^2 = 4.0\\times 10^{-42}\\ \\mathrm{J}^2$. With $k_B T^2 = (1.380649\\times 10^{-23}\\ \\mathrm{J/K})\\times (250)^2 = 8.62905625\\times 10^{-19}\\ \\mathrm{J/K}$,\n$$\nC_V \\approx \\frac{4.0\\times 10^{-42}}{8.62905625\\times 10^{-19}}\\ \\mathrm{J/K} \\approx 4.6355011\\times 10^{-24}\\ \\mathrm{J/K},\n$$\nwhich rounds to six significant figures as $4.63550\\times 10^{-24}\\ \\mathrm{J/K}$.\n\nThe program should compute these values directly from the provided lists using the stated relation and print a single line\n$[r_1,r_2,r_3,r_4]$ with each $r_i$ in $\\mathrm{J/K}$, rounded to six significant figures in scientific notation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nKB = 1.380649e-23  # J/K\n\ndef heat_capacity_from_fluctuations(energies, T):\n    # energies: numpy array in J, T in K\n    e = energies.astype(float)\n    mean_e = np.mean(e)\n    var_e = np.mean((e - mean_e) ** 2)  # ensemble variance estimate via finite-sample arithmetic mean\n    Cv = var_e / (KB * (T ** 2))\n    return Cv\n\ndef format_scientific_sig(x, sig=6):\n    # Format x in scientific notation with exactly 'sig' significant figures.\n    # Always produce one digit before the decimal point.\n    import math\n    if x == 0.0:\n        # Construct 0.00000...e+00 with (sig-1) decimals after the dot\n        return \"0.\" + \"0\"*(sig-1) + \"e+00\"\n    sign = \"-\" if x < 0 else \"\"\n    ax = abs(x)\n    exp = int(math.floor(math.log10(ax)))\n    mant = ax / (10 ** exp)\n    # round mantissa to have sig significant digits => (sig-1) digits after decimal\n    mant_rounded = round(mant, sig - 1)\n    # Handle rounding overflow like 9.99999 -> 10.00000\n    if mant_rounded >= 10.0:\n        mant_rounded /= 10.0\n        exp += 1\n    return f\"{sign}{mant_rounded:.{sig-1}f}e{exp:+03d}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"T\": 300.0,\n            \"E\": np.array([\n                1.14e-19, 1.16e-19, 1.18e-19, 1.20e-19, 1.22e-19, 1.24e-19, 1.26e-19,\n                1.14e-19, 1.16e-19, 1.18e-19, 1.20e-19, 1.22e-19, 1.24e-19, 1.26e-19\n            ])\n        },\n        # Case 2\n        {\n            \"T\": 300.0,\n            \"E\": np.array([8.0e-20] * 8)\n        },\n        # Case 3\n        {\n            \"T\": 600.0,\n            \"E\": np.array([\n                9.9e-20, 1.01e-19, 1.03e-19, 1.05e-19, 1.07e-19, 1.09e-19, 1.11e-19,\n                9.9e-20, 1.01e-19, 1.03e-19, 1.05e-19, 1.07e-19, 1.09e-19, 1.11e-19\n            ])\n        },\n        # Case 4\n        {\n            \"T\": 250.0,\n            \"E\": np.array([4.8e-20, 5.2e-20])\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        Cv = heat_capacity_from_fluctuations(case[\"E\"], case[\"T\"])  # J/K\n        results.append(format_scientific_sig(Cv, sig=6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2414232"}, {"introduction": "Standard molecular dynamics algorithms, which integrate Newton's equations of motion using a small, fixed time-step, are ideal for systems with smooth, continuous interaction potentials. However, for idealized models with discontinuous interactions, such as perfectly hard spheres or rods, this approach becomes inefficient and inaccurate. This practice [@problem_id:2414281] challenges you to implement an entirely different and powerful simulation paradigm: event-driven molecular dynamics (EDMD). Instead of advancing time by a fixed increment, the EDMD algorithm calculates the exact time of the next collision and evolves the system precisely from one \"event\" to the next, offering a glimpse into the diverse algorithmic landscape of molecular simulation.", "problem": "You are tasked with formulating and implementing a complete computational model for the one-dimensional molecular dynamics of identical hard rods. Consider a one-dimensional segment from position $x=0$ to position $x=L$ containing $N$ identical hard rods of length $a$ and mass $m$. Each rod is represented by its center coordinate $x_i(t)$ and its velocity $v_i(t)$ for $i\\in\\{1,\\dots,N\\}$. There are no external forces. The rods are perfectly rigid and cannot overlap. When two rods collide, the collision is instantaneous and perfectly elastic. When a rod collides with a wall at $x=0$ or $x=L$, the collision is instantaneous and perfectly elastic. Assume all masses are equal and that the only motion is along the line.\n\nThe physical rules are as follows:\n- Between collisions, each center moves with constant velocity, so $x_i(t)$ evolves linearly in time.\n- A rod cannot cross a wall; the center coordinate must satisfy $x_i(t)\\in[a/2,L-a/2]$ at all times.\n- In any perfectly elastic collision between two identical masses, the post-collision velocities are given by exchanging the pre-collision velocities of the two colliding rods.\n- In any perfectly elastic collision of a rod with a wall, the post-collision velocity is given by reversing the sign of the pre-collision velocity, while the center remains within the allowable interval.\n\nAll quantities must be treated in the International System of Units (SI units). Positions must be expressed in meters, velocities in meters per second, and time in seconds. All initial centers are strictly increasing and non-overlapping. There are no angle quantities in this problem.\n\nYour task is to write a complete, runnable program that computes, for each of the following specified test cases, the list of final center positions $\\{x_i(T)\\}_{i=1}^N$ at time $T$, in meters, ordered by the initial indexing of the rods (which coincides with strictly increasing initial positions). Each final position in each test case must be rounded to exactly six digits after the decimal point. Your program must not read any input and must print a single line of output that aggregates the results for all test cases as a single comma-separated list enclosed in square brackets, where each element is itself the square-bracketed, comma-separated list of final positions for that test case. The printed line must have no spaces. For example, if there are two test cases with final positions lists $[x_{1,1},x_{1,2}]$ and $[x_{2,1}]$, the output must be of the form $[[x_{1,1},x_{1,2}],[x_{2,1}]]$, using the required rounding.\n\nUse the following test suite, which is designed to cover general behavior, wall reflections, pair collisions, and sequences of different collision types. In every case, report all final center positions in meters, rounded to exactly six digits after the decimal point.\n\n- Test case $1$ (general multiparticle evolution): $N=3$, $L=10.0\\,\\mathrm{m}$, $a=1.0\\,\\mathrm{m}$, $T=10.0\\,\\mathrm{s}$, initial centers $[1.000000\\,\\mathrm{m},4.000000\\,\\mathrm{m},7.000000\\,\\mathrm{m}]$, initial velocities $[1.000000\\,\\mathrm{m/s},-0.500000\\,\\mathrm{m/s},0.200000\\,\\mathrm{m/s}]$.\n- Test case $2$ (single rod reflecting from a wall): $N=1$, $L=5.0\\,\\mathrm{m}$, $a=0.5\\,\\mathrm{m}$, $T=1.0\\,\\mathrm{s}$, initial center $[1.000000\\,\\mathrm{m}]$, initial velocity $[-2.000000\\,\\mathrm{m/s}]$.\n- Test case $3$ (two-rod head-on collision): $N=2$, $L=4.0\\,\\mathrm{m}$, $a=0.6\\,\\mathrm{m}$, $T=1.0\\,\\mathrm{s}$, initial centers $[1.000000\\,\\mathrm{m},2.500000\\,\\mathrm{m}]$, initial velocities $[1.000000\\,\\mathrm{m/s},-1.000000\\,\\mathrm{m/s}]$.\n- Test case $4$ (sequence of a wall reflection followed by a rod-rod collision): $N=3$, $L=6.0\\,\\mathrm{m}$, $a=1.0\\,\\mathrm{m}$, $T=5.0\\,\\mathrm{s}$, initial centers $[0.700000\\,\\mathrm{m},2.000000\\,\\mathrm{m},3.500000\\,\\mathrm{m}]$, initial velocities $[-1.000000\\,\\mathrm{m/s},0.000000\\,\\mathrm{m/s},-0.200000\\,\\mathrm{m/s}]$.\n\nFinal Output Format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces. Each element is the bracketed, comma-separated list of final centers for a test case, with each number rounded to exactly six digits after the decimal point in meters. For the above four test cases, the output must look like $[[x_{1,1},x_{1,2},x_{1,3}],[x_{2,1}],[x_{3,1},x_{3,2}],[x_{4,1},x_{4,2},x_{4,3}]]$ where every $x_{k,j}$ is a decimal numeral rounded as specified and expressed in meters.", "solution": "The problem presented is a standard exercise in computational physics, specifically the simulation of a one-dimensional gas of hard rods. It is a well-posed problem grounded in the principles of classical mechanics. My duty is to validate its premises and, if valid, to provide a rigorous, algorithmically sound solution.\n\n**Problem Validation**\n\nFirst, I have examined the problem statement for logical consistency, scientific soundness, and completeness.\nThe givens are:\n- A one-dimensional space of length $L$.\n- $N$ identical hard rods of length $a$ and mass $m$.\n- The state of rod $i$ is described by its center position $x_i(t)$ and velocity $v_i(t)$.\n- The center of each rod $i$ is constrained to the interval $[a/2, L-a/2]$.\n- Motion between collisions is uniform: $x_i(t)$ is linear.\n- Collision rules are provided:\n    1. For a collision between two rods, their velocities are exchanged. This is consistent with an elastic collision of two identical masses in one dimension, where conservation of momentum and kinetic energy dictates that $v_i' = v_j$ and $v_j' = v_i$.\n    2. For a collision between a rod and a wall, the rod's velocity is reversed. This corresponds to a perfectly elastic reflection.\n- All required parameters ($N$, $L$, $a$, $T$) and initial conditions ($x_i(0)$, $v_i(0)$) are specified for each test case.\n\nThe problem is scientifically grounded, a classic model system. The initial conditions provided for all test cases are physically valid; rods are non-overlapping and within the specified boundaries. A potential ambiguity could arise from simultaneous collisions (more than two particles colliding at the same instant). An analysis of the provided test cases reveals one instance of simultaneous events, but these events involve disjoint sets of particles. Such cases are unambiguous and can be resolved consistently. The problem is therefore deemed valid.\n\n**Methodology: Event-Driven Simulation**\n\nThe system dynamics are piecewise linear, with state changes occurring only at discrete moments in time, i.e., collisions. This structure lends itself to an event-driven simulation approach, which is significantly more efficient and accurate than a fixed time-step method for this class of problems. The simulation proceeds by calculating the time to the next collision event, advancing the system state to that moment, and then resolving the collision by updating the velocities of the involved particles.\n\nThe state of the system at any time $t$ is given by the set of positions and velocities $\\{x_i(t), v_i(t)\\}_{i=1}^N$. Between events, the position of rod $i$ evolves according to the equation of motion for a free particle:\n$$x_i(t + \\Delta t) = x_i(t) + v_i(t) \\Delta t$$\n\nThe core of the simulation is to determine the time interval $\\Delta t$ to the next event. There are two types of events: a collision between two adjacent rods, and a collision of a rod with a wall.\n\n**1. Rod-Rod Collision Time**\n\nA collision between two adjacent rods, $i$ and $i+1$ (assuming $x_i < x_{i+1}$), occurs when the distance between their centers becomes equal to their length, $a$. That is, $x_{i+1}(t) - x_i(t) = a$. Let the current time be $t_{curr}$ with positions $x_i$ and $x_{i+1}$ and velocities $v_i$ and $v_{i+1}$. We seek the time interval $\\Delta t$ such that:\n$$x_{i+1}(t_{curr} + \\Delta t) - x_i(t_{curr} + \\Delta t) = a$$\n$$(x_{i+1} + v_{i+1}\\Delta t) - (x_i + v_i\\Delta t) = a$$\nSolving for $\\Delta t$, we find the time to collision for the pair $(i, i+1)$:\n$$\\Delta t_{i,i+1} = \\frac{x_{i+1} - x_i - a}{v_i - v_{i+1}}$$\nA collision can occur only if the rods are approaching each other, which means the relative velocity $v_i - v_{i+1}$ must be positive. Since the initial separation $x_{i+1} - x_i$ is greater than $a$, the numerator is positive. Thus, we only consider cases where $\\Delta t_{i,i+1} > 0$. In a one-dimensional system of hard rods that cannot pass through one another, a rod can only collide with its immediate neighbors. Therefore, we only need to compute collision times for adjacent pairs $(i, i+1)$ for $i \\in \\{1, \\dots, N-1\\}$.\n\n**2. Rod-Wall Collision Time**\n\nA rod $i$ collides with a wall when its center reaches the boundary of its allowed domain, $[a/2, L-a/2]$.\n- Collision with the left wall (at $x=0$): The center reaches $x_i = a/2$.\n  $$x_i + v_i \\Delta t = a/2 \\implies \\Delta t_{i,L} = \\frac{a/2 - x_i}{v_i}$$\n  For a future collision, $\\Delta t_{i,L}$ must be positive. Since $x_i > a/2$, the numerator is negative, so a collision is possible only if $v_i < 0$.\n- Collision with the right wall (at $x=L$): The center reaches $x_i = L-a/2$.\n  $$x_i + v_i \\Delta t = L - a/2 \\implies \\Delta t_{i,R} = \\frac{L - a/2 - x_i}{v_i}$$\n  For a future collision, $\\Delta t_{i,R}$ must be positive. Since $x_i < L-a/2$, the numerator is positive, so a collision is possible only if $v_i > 0$.\n\n**Simulation Algorithm**\n\nThe simulation iterates through time from $t=0$ to $T$ by executing the following steps in a loop:\n\n1.  Initialize the system state: simulation time $t \\leftarrow 0$, positions $x_i \\leftarrow x_i(0)$, and velocities $v_i \\leftarrow v_i(0)$.\n2.  While $t < T$:\n    a. Calculate all possible future collision times: $\\Delta t_{i,i+1}$ for all adjacent pairs, and $\\Delta t_{i,L}$, $\\Delta t_{i,R}$ for all rods. Collect only the positive, non-zero results. A small positive tolerance ($\\epsilon > 0$) must be used for time comparisons to avoid infinite loops caused by floating-point arithmetic.\n    b. Find the minimum of these valid collision times, $\\Delta t_{min}$. If no future collisions are possible, set $\\Delta t_{min}$ to infinity.\n    c. Determine the time step for the next evolution: $\\Delta t_{step} = \\min(\\Delta t_{min}, T - t)$.\n    d. Evolve the system state: Advance the current time $t \\leftarrow t + \\Delta t_{step}$, and update all positions: $x_i \\leftarrow x_i + v_i \\Delta t_{step}$ for all $i \\in \\{1, \\dots, N\\}$.\n    e. If a collision occurred (i.e., $\\Delta t_{step} = \\Delta t_{min}$), identify all collision events that occur at this exact time. For each event, update the velocities of the involved particles according to the collision rules:\n        - For a rod-rod collision between $i$ and $j$: $v_i' = v_j$ and $v_j' = v_i$.\n        - For a wall collision involving rod $i$: $v_i' = -v_i$.\n        If multiple disjoint collisions occur simultaneously, all corresponding velocity updates are applied.\n3.  Upon loop termination, the final positions $\\{x_i(T)\\}$ are reported.\n\nThis algorithm guarantees that the system is evolved exactly from one event to the next, providing a precise trajectory. The implementation shall use floating-point numbers with sufficient precision and care in comparisons to ensure correctness.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D hard rod dynamics problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {'N': 3, 'L': 10.0, 'a': 1.0, 'T': 10.0, 'x0': [1.0, 4.0, 7.0], 'v0': [1.0, -0.5, 0.2]},\n        {'N': 1, 'L': 5.0, 'a': 0.5, 'T': 1.0, 'x0': [1.0], 'v0': [-2.0]},\n        {'N': 2, 'L': 4.0, 'a': 0.6, 'T': 1.0, 'x0': [1.0, 2.5], 'v0': [1.0, -1.0]},\n        {'N': 3, 'L': 6.0, 'a': 1.0, 'T': 5.0, 'x0': [0.7, 2.0, 3.5], 'v0': [-1.0, 0.0, -0.2]},\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        N = case['N']\n        L = case['L']\n        a = case['a']\n        T = case['T']\n        \n        x = np.array(case['x0'], dtype=float)\n        v = np.array(case['v0'], dtype=float)\n        \n        t = 0.0\n        # A small tolerance to prevent re-collision and floating point issues\n        epsilon = 1e-12\n\n        while T - t > epsilon:\n            \n            collision_times = []\n            \n            # Rod-rod collision times\n            for i in range(N - 1):\n                v_rel = v[i] - v[i+1]\n                if v_rel > 0:\n                    dist = x[i+1] - x[i] - a\n                    dt = dist / v_rel\n                    if dt > epsilon:\n                        collision_times.append({'dt': dt, 'type': 'rod-rod', 'indices': (i, i+1)})\n\n            # Rod-wall collision times\n            left_bound = a / 2.0\n            right_bound = L - a / 2.0\n            for i in range(N):\n                if v[i] < 0:\n                    dt = (left_bound - x[i]) / v[i]\n                    if dt > epsilon:\n                        collision_times.append({'dt': dt, 'type': 'wall', 'indices': (i, 'left')})\n                elif v[i] > 0:\n                    dt = (right_bound - x[i]) / v[i]\n                    if dt > epsilon:\n                        collision_times.append({'dt': dt, 'type': 'wall', 'indices': (i, 'right')})\n\n            if not collision_times:\n                dt_step = T - t\n            else:\n                min_dt = min(event['dt'] for event in collision_times)\n                dt_step = min(min_dt, T - t)\n            \n            # Advance system\n            x += v * dt_step\n            t += dt_step\n\n            # If a collision occurred, resolve it\n            if dt_step < T - t + epsilon and collision_times:\n                # Find all events happening at min_dt\n                v_pre_collision = v.copy()\n                events_to_resolve = [event for event in collision_times if abs(event['dt'] - min_dt) < epsilon]\n                \n                for event in events_to_resolve:\n                    if event['type'] == 'rod-rod':\n                        i, j = event['indices']\n                        v[i], v[j] = v_pre_collision[j], v_pre_collision[i]\n                    elif event['type'] == 'wall':\n                        i, _ = event['indices']\n                        v[i] = -v_pre_collision[i]\n        \n        all_results.append(list(x))\n\n    # Format the final output string exactly as required\n    formatted_results = []\n    for res_list in all_results:\n        s = '[' + ','.join(f'{val:.6f}' for val in res_list) + ']'\n        formatted_results.append(s)\n    \n    print('[' + ','.join(formatted_results) + ']')\n\nsolve()\n```", "id": "2414281"}]}