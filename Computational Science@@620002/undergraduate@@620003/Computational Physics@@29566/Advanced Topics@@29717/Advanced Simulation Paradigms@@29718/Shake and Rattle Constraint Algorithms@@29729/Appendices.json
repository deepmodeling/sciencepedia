{"hands_on_practices": [{"introduction": "To truly master constraint algorithms, we must first look under the hood. This exercise focuses on a fundamental aspect of the SHAKE algorithm: its iterative nature and convergence properties. By deriving and implementing the core recurrence relation for the constraint error, you will gain a deep, quantitative understanding of how the algorithm's efficiency is linked to the choice of integration time step [@problem_id:2436783].", "problem": "Consider two point particles of equal mass subject to a single holonomic distance constraint that fixes their separation to a prescribed bond length. Let the positions of the two particles at the end of an unconstrained predictor step be denoted by a relative displacement vector whose squared magnitude is $s = \\lVert \\mathbf{r}_{12} \\rVert^{2}$. The holonomic constraint is $g(\\mathbf{r}) = \\lVert \\mathbf{r}_{12} \\rVert^{2} - L^{2} = 0$, where $L$ is the target bond length. The classical SHAKE (a constraint projection method introduced for Molecular Dynamics by Ryckaert, Ciccotti, and Berendsen) position correction applies a Lagrange-multiplier-based update that, in its iterative linearized form for a single distance constraint and equal masses, can be written as an update on the relative vector $\\mathbf{r}_{12}$ of the form $\\mathbf{r}_{12}^{(k+1)} = \\mathbf{r}_{12}^{(k)} + \\delta \\mathbf{r}_{12}^{(k)}$ with $\\delta \\mathbf{r}_{12}^{(k)}$ proportional to $\\mathbf{r}_{12}^{(k)}$. If one denotes the current squared-length error by $e_{k} = \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^{2} - L^{2}$, the induced one-constraint SHAKE iteration produces a nonlinear recurrence $e_{k+1} = \\Phi(e_{k},L)$, which you must derive from first principles starting from the definition of the constraint, the gradient of the constraint, and the linearized Lagrange-multiplier correction step.\n\nYour task is to investigate how the number of SHAKE iterations required to reduce the squared-length error below a prescribed tolerance depends on the ratio of the timestep to a characteristic bond-period timescale. Use the following modeling assumptions to make the problem self-contained and universally applicable in dimensionless units:\n\n- Assume equal masses and a single distance constraint $g(\\mathbf{r}) = \\lVert \\mathbf{r}_{12} \\rVert^{2} - L^{2} = 0$.\n- Use the iterative, linearized SHAKE position-projection step derived from the holonomic constraint with Lagrange multipliers.\n- Let the initial squared-length error supplied to the SHAKE iteration be modeled as $e_{0} = C L^{2} \\left(\\frac{\\Delta t}{T}\\right)^{2}$, where $\\Delta t$ is the timestep, $T$ is a characteristic bond-period timescale (e.g., a vibrational period), and $C$ is a dimensionless constant arising from the kinematics of the fastest bonded motion. For definiteness, take $C = 4 \\pi^{2}$, which corresponds to the leading-order deviation incurred over one timestep when the unconstrained predictor does not supply the centripetal acceleration of a circular bonded motion with angular frequency $\\omega = \\frac{2 \\pi}{T}$.\n- Work in dimensionless units with $L = 1$, so that all squared-length errors are dimensionless. The tolerance for convergence is a relative squared-length error threshold $\\tau$ applied directly to $e_{k}$, i.e., stop the iteration when $e_{k} \\le \\tau$. Use $\\tau = 10^{-12}$.\n\nStarting from Newton's second law and the definition of a holonomic constraint enforced via Lagrange multipliers, first derive the explicit scalar recurrence $e_{k+1} = \\Phi(e_{k},L)$ for the single-constraint SHAKE iteration under the assumptions above. Then, write a complete, runnable program that, for each test case listed below, computes the minimal nonnegative integer number of iterations $N$ required so that after $N$ SHAKE iterations the squared-length error satisfies $e_{N} \\le \\tau$.\n\nTest suite (each item specifies the ratio $\\Delta t / T$):\n- Case A: $\\Delta t / T = 0$\n- Case B: $\\Delta t / T = \\frac{1}{50}$\n- Case C: $\\Delta t / T = \\frac{1}{20}$\n- Case D: $\\Delta t / T = \\frac{1}{10}$\n- Case E: $\\Delta t / T = \\frac{1}{5}$\n- Case F: $\\Delta t / T = \\frac{1}{2}$\n- Case G: $\\Delta t / T = 1$\n\nProgram requirements:\n- Implement the single-constraint iterative SHAKE update on the squared-length error using the derived scalar recurrence $e_{k+1} = \\Phi(e_{k},L)$ with $L = 1$ and $C = 4 \\pi^{2}$.\n- For each test case, initialize $e_{0} = C \\left(\\frac{\\Delta t}{T}\\right)^{2}$ and iterate until $e_{k} \\le \\tau$ with $\\tau = 10^{-12}$, counting the minimal number of iterations $N$.\n- The program must output a single line containing the seven integers $N$ for the cases A through G in order, as a comma-separated list enclosed in square brackets, for example, $[n_{A},n_{B},n_{C},n_{D},n_{E},n_{F},n_{G}]$.\n\nThere are no physical units in this formulation; all quantities are dimensionless by construction. Angles (through $\\pi$) are treated in radians. The final outputs are integers.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It presents a standard exercise in computational physics concerning the convergence properties of the SHAKE algorithm. It is complete, consistent, and requires a solution based on established mathematical and physical principles. Therefore, the problem is valid and I will proceed with its solution.\n\nThe task is twofold: first, to derive from first principles the scalar recurrence relation for the squared-length error in an iterative SHAKE procedure for a simple two-particle system; second, to implement this recurrence numerically to determine the number of iterations required for convergence under various conditions.\n\nLet the positions of the two particles of equal mass, $m_1 = m_2 = m$, be denoted by $\\mathbf{r}_1$ and $\\mathbf{r}_2$. The holonomic constraint fixes the distance between them:\n$$g(\\mathbf{r}_1, \\mathbf{r}_2) = (\\mathbf{r}_1 - \\mathbf{r}_2) \\cdot (\\mathbf{r}_1 - \\mathbf{r}_2) - L^2 = \\lVert \\mathbf{r}_{12} \\rVert^2 - L^2 = 0$$\nwhere $\\mathbf{r}_{12} = \\mathbf{r}_1 - \\mathbf{r}_2$ is the relative position vector and $L$ is the prescribed bond length.\n\nThe SHAKE algorithm is an iterative procedure to correct positions that have been updated by an unconstrained integration step, such that they satisfy the constraint equation. Let $\\mathbf{r}_i^{(k)}$ be the position of particle $i$ at iteration $k$ of the correction procedure, with $\\mathbf{r}_i^{(0)}$ being the unconstrained predicted position. The correction at each step, $\\delta \\mathbf{r}_i^{(k)} = \\mathbf{r}_i^{(k+1)} - \\mathbf{r}_i^{(k)}$, is assumed to be proportional to the gradient of the constraint function evaluated at $\\mathbf{r}^{(k)}$. For a single constraint, this is:\n$$\\delta \\mathbf{r}_i^{(k)} = \\frac{\\lambda_k}{m_i} \\nabla_{\\mathbf{r}_i} g(\\mathbf{r}^{(k)})$$\nwhere $\\lambda_k$ is a Lagrange multiplier determined at each iteration.\n\nThe Lagrange multiplier $\\lambda_k$ is found by linearizing the constraint equation around the current positions $\\mathbf{r}^{(k)}$. We require $g(\\mathbf{r}^{(k+1)}) = g(\\mathbf{r}^{(k)} + \\delta \\mathbf{r}^{(k)}) = 0$. A first-order Taylor expansion yields:\n$$g(\\mathbf{r}^{(k)}) + \\sum_{i=1}^{2} \\nabla_{\\mathbf{r}_i} g(\\mathbf{r}^{(k)}) \\cdot \\delta \\mathbf{r}_i^{(k)} \\approx 0$$\nSubstituting the expression for $\\delta \\mathbf{r}_i^{(k)}$:\n$$g(\\mathbf{r}^{(k)}) + \\sum_{i=1}^{2} \\nabla_{\\mathbf{r}_i} g(\\mathbf{r}^{(k)}) \\cdot \\left( \\frac{\\lambda_k}{m_i} \\nabla_{\\mathbf{r}_i} g(\\mathbf{r}^{(k)}) \\right) = 0$$\n$$g(\\mathbf{r}^{(k)}) + \\lambda_k \\sum_{i=1}^{2} \\frac{1}{m_i} \\lVert \\nabla_{\\mathbf{r}_i} g(\\mathbf{r}^{(k)}) \\rVert^2 = 0$$\nSolving for $\\lambda_k$ gives the general expression for the iterative Lagrange multiplier:\n$$\\lambda_k = - \\frac{g(\\mathbf{r}^{(k)})}{\\sum_{i=1}^{2} \\frac{1}{m_i} \\lVert \\nabla_{\\mathbf{r}_i} g(\\mathbf{r}^{(k)}) \\rVert^2}$$\n\nNow, we apply this formalism to our specific system. The gradients of the constraint function $g(\\mathbf{r}_{12}) = \\lVert \\mathbf{r}_{12} \\rVert^2 - L^2$ are:\n$$\\nabla_{\\mathbf{r}_1} g = 2\\mathbf{r}_{12}$$\n$$\\nabla_{\\mathbf{r}_2} g = -2\\mathbf{r}_{12}$$\nThe denominator in the expression for $\\lambda_k$ becomes, using $m_1=m_2=m$:\n$$\\sum_{i=1}^{2} \\frac{1}{m_i} \\lVert \\nabla_{\\mathbf{r}_i} g(\\mathbf{r}_{12}^{(k)}) \\rVert^2 = \\frac{1}{m} \\lVert 2\\mathbf{r}_{12}^{(k)} \\rVert^2 + \\frac{1}{m} \\lVert -2\\mathbf{r}_{12}^{(k)} \\rVert^2 = \\frac{4}{m} \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 + \\frac{4}{m} \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 = \\frac{8}{m} \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2$$\nThe constraint function itself, evaluated at iteration $k$, is $g(\\mathbf{r}_{12}^{(k)}) = \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 - L^2$.\nSubstituting these into the expression for $\\lambda_k$:\n$$\\lambda_k = - \\frac{\\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 - L^2}{\\frac{8}{m} \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2}$$\n\nThe update rule for the relative position vector $\\mathbf{r}_{12}$ is derived from the individual particle updates:\n$$\\mathbf{r}_{12}^{(k+1)} = \\mathbf{r}_1^{(k+1)} - \\mathbf{r}_2^{(k+1)} = (\\mathbf{r}_1^{(k)} + \\delta \\mathbf{r}_1^{(k)}) - (\\mathbf{r}_2^{(k)} + \\delta \\mathbf{r}_2^{(k)}) = \\mathbf{r}_{12}^{(k)} + (\\delta \\mathbf{r}_1^{(k)} - \\delta \\mathbf{r}_2^{(k)})$$\nUsing the gradient expressions:\n$$\\delta \\mathbf{r}_1^{(k)} - \\delta \\mathbf{r}_2^{(k)} = \\frac{\\lambda_k}{m} (2\\mathbf{r}_{12}^{(k)}) - \\frac{\\lambda_k}{m} (-2\\mathbf{r}_{12}^{(k)}) = \\frac{4\\lambda_k}{m} \\mathbf{r}_{12}^{(k)}$$\nThus, the vector update rule is:\n$$\\mathbf{r}_{12}^{(k+1)} = \\mathbf{r}_{12}^{(k)} + \\frac{4\\lambda_k}{m} \\mathbf{r}_{12}^{(k)} = \\mathbf{r}_{12}^{(k)} \\left(1 + \\frac{4\\lambda_k}{m}\\right)$$\nSubstituting the derived expression for $\\lambda_k$:\n$$\\mathbf{r}_{12}^{(k+1)} = \\mathbf{r}_{12}^{(k)} \\left(1 + \\frac{4}{m} \\left( - \\frac{\\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 - L^2}{\\frac{8}{m} \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2} \\right) \\right) = \\mathbf{r}_{12}^{(k)} \\left(1 - \\frac{1}{2} \\frac{\\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 - L^2}{\\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2} \\right)$$\nTo find the recurrence for the squared-length error, $e_k = \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 - L^2$, we take the squared norm of the vector update equation:\n$$\\lVert \\mathbf{r}_{12}^{(k+1)} \\rVert^2 = \\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 \\left(1 - \\frac{1}{2} \\frac{\\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 - L^2}{\\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2} \\right)^2$$\nLet us introduce the error definition, $\\lVert \\mathbf{r}_{12}^{(k)} \\rVert^2 = e_k + L^2$. The next error is $e_{k+1} = \\lVert \\mathbf{r}_{12}^{(k+1)} \\rVert^2 - L^2$.\n$$e_{k+1} + L^2 = (e_k + L^2) \\left(1 - \\frac{1}{2} \\frac{e_k}{e_k + L^2} \\right)^2$$\nSimplifying the term in parentheses:\n$$1 - \\frac{e_k}{2(e_k + L^2)} = \\frac{2(e_k + L^2) - e_k}{2(e_k + L^2)} = \\frac{e_k + 2L^2}{2(e_k + L^2)}$$\nSubstituting this back yields:\n$$e_{k+1} + L^2 = (e_k + L^2) \\left(\\frac{e_k + 2L^2}{2(e_k + L^2)}\\right)^2 = (e_k + L^2) \\frac{(e_k + 2L^2)^2}{4(e_k + L^2)^2} = \\frac{(e_k + 2L^2)^2}{4(e_k + L^2)}$$\n$$e_{k+1} + L^2 = \\frac{e_k^2 + 4e_k L^2 + 4L^4}{4(e_k + L^2)}$$\nIsolating $e_{k+1}$:\n$$e_{k+1} = \\frac{e_k^2 + 4e_k L^2 + 4L^4}{4(e_k + L^2)} - L^2 = \\frac{e_k^2 + 4e_k L^2 + 4L^4 - 4L^2(e_k + L^2)}{4(e_k + L^2)}$$\n$$e_{k+1} = \\frac{e_k^2 + 4e_k L^2 + 4L^4 - 4e_k L^2 - 4L^4}{4(e_k + L^2)}$$\nThis simplifies to the final recurrence relation for the squared-length error:\n$$e_{k+1} = \\frac{e_k^2}{4(e_k + L^2)}$$\nThis relation demonstrates the quadratic convergence of the SHAKE algorithm for small errors ($e_k \\ll L^2$), where $e_{k+1} \\approx e_k^2 / (4L^2)$.\n\nWith this derived recurrence, we proceed to the numerical computation as specified in the problem statement. We use $L=1$, $C = 4\\pi^2$, and a convergence tolerance $\\tau = 10^{-12}$. The initial error for each test case is $e_0 = C (\\Delta t / T)^2$. We seek the minimal non-negative integer $N$ such that $e_N \\le \\tau$. The program listed in the final answer implements this logic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SHAKE iteration problem for a suite of test cases.\n    It calculates the number of iterations N required for the squared-length\n    error to fall below a specified tolerance.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is the ratio of timestep to characteristic period, dt/T.\n    test_cases = [\n        0.0,          # Case A\n        1.0 / 50.0,   # Case B\n        1.0 / 20.0,   # Case C\n        1.0 / 10.0,   # Case D\n        1.0 / 5.0,    # Case E\n        1.0 / 2.0,    # Case F\n        1.0,          # Case G\n    ]\n\n    results = []\n    for dt_T_ratio in test_cases:\n        n_iterations = calculate_shake_iterations(dt_T_ratio)\n        results.append(n_iterations)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_shake_iterations(dt_T_ratio: float) -> int:\n    \"\"\"\n    Computes the minimal number of SHAKE iterations N for convergence.\n\n    Args:\n        dt_T_ratio: The ratio of the timestep dt to the characteristic\n                    bond period T.\n\n    Returns:\n        The minimal non-negative integer number of iterations N.\n    \"\"\"\n    # Parameters from the problem statement\n    l_bond = 1.0  # Dimensionless bond length\n    const_c = 4.0 * np.pi**2\n    tolerance = 1.0e-12\n\n    # Initial squared-length error e_0\n    # e_0 = C * L^2 * (dt/T)^2\n    e_k = const_c * (l_bond**2) * (dt_T_ratio**2)\n\n    # The problem asks for the minimal non-negative integer N such that e_N <= tau.\n    # We must first check the condition for N = 0.\n    if e_k <= tolerance:\n        return 0\n\n    n = 0\n    # The derived recurrence is e_{k+1} = e_k^2 / (4 * (e_k + L^2))\n    # Since L=1, this is e_{k+1} = e_k^2 / (4 * (e_k + 1))\n    # We iterate until the error is below the tolerance.\n    while True:\n        # Since e_0 is non-negative, and the recurrence maintains non-negativity,\n        # e_k will always be non-negative.\n        e_k = e_k**2 / (4.0 * (e_k + l_bond**2))\n        n += 1\n        if e_k <= tolerance:\n            return n\n\n# Execute the main function.\nsolve()\n```", "id": "2436783"}, {"introduction": "Why do we go to the trouble of implementing complex constraint algorithms? This practice provides a direct answer by comparing two common ways to model a stiff molecular bond: as a rigid constraint using RATTLE, and as a strong harmonic potential using a standard Velocity Verlet integrator. By implementing both and comparing their performance and accuracy, you will gain first-hand experience with the critical trade-offs between computational cost, time step limitations, and energy conservation in molecular simulations [@problem_id:2436794].", "problem": "Consider a planar system of two identical point masses with mass $m$ constrained to move in two spatial dimensions. Let the particle positions be $\\mathbf{r}_1(t)$ and $\\mathbf{r}_2(t)$ and the velocities be $\\mathbf{v}_1(t)$ and $\\mathbf{v}_2(t)$. There are no external fields. The center-of-mass is initially at the origin. The initial positions are $\\mathbf{r}_1(0)=(-L/2,0)$ and $\\mathbf{r}_2(0)=(+L/2,0)$. The initial velocities are $\\mathbf{v}_1(0)=(0,v_0)$ and $\\mathbf{v}_2(0)=(0,-v_0)$, so the relative velocity is tangential to the line connecting the masses. The bond length parameter is $L>0$.\n\nModel the bond between the two masses in two distinct ways:\n\n- Model A (rigid bond): The holonomic constraint is $g(\\mathbf{r}_1,\\mathbf{r}_2)=\\|\\mathbf{r}_2-\\mathbf{r}_1\\|-L=0$ for all times $t$.\n- Model B (stiff bond): The potential energy is $U(\\mathbf{r}_1,\\mathbf{r}_2)=\\tfrac{1}{2}k(\\|\\mathbf{r}_2-\\mathbf{r}_1\\|-L)^2$ with stiffness $k>0$.\n\nLet the total simulation time be $T>0$ and let the time-steps be $\\Delta t_{\\mathrm{A}}$ for Model A and $\\Delta t_{\\mathrm{B}}$ for Model B. For each model, evolve the system from $t=0$ to $t=T$ using a uniform time-step equal to the given value. For each model, compute:\n\n- The number of time-steps $N_{\\mathrm{A}}=\\lceil T/\\Delta t_{\\mathrm{A}}\\rceil$ and $N_{\\mathrm{B}}=\\lceil T/\\Delta t_{\\mathrm{B}}\\rceil$.\n- The root-mean-square bond-length deviation\n$$\n\\varepsilon_{\\mathrm{rms}}=\\sqrt{\\frac{1}{N+1}\\sum_{n=0}^{N}\\left(\\|\\mathbf{r}_2(t_n)-\\mathbf{r}_1(t_n)\\|-L\\right)^2},\n$$\nexpressed in meters, where $N$ is the corresponding number of steps and $t_n=n\\,\\Delta t$.\n- The absolute energy drift\n$$\n\\Delta E=\\left|E(T)-E(0)\\right| \\quad \\text{in joules},\n$$\nwhere for Model A the total energy is the total kinetic energy $E=\\tfrac{1}{2}m\\|\\mathbf{v}_1\\|^2+\\tfrac{1}{2}m\\|\\mathbf{v}_2\\|^2$, and for Model B the total energy is the sum of kinetic and potential energies $E=\\tfrac{1}{2}m\\|\\mathbf{v}_1\\|^2+\\tfrac{1}{2}m\\|\\mathbf{v}_2\\|^2+U$.\n\nUse the following test suite. Each test case provides $(m,L,k,v_0,T,\\Delta t_{\\mathrm{A}},\\Delta t_{\\mathrm{B}})$ in SI units:\n\n1. Test case $1$: $m=1.99264687992\\times 10^{-26}\\ \\text{kg}$, $L=1.0\\times 10^{-10}\\ \\text{m}$, $k=5.0\\times 10^{2}\\ \\text{N/m}$, $v_0=1.0\\times 10^{3}\\ \\text{m/s}$, $T=5.0\\times 10^{-14}\\ \\text{s}$, $\\Delta t_{\\mathrm{A}}=5.0\\times 10^{-16}\\ \\text{s}$, $\\Delta t_{\\mathrm{B}}=5.0\\times 10^{-17}\\ \\text{s}$.\n2. Test case $2$: $m=1.99264687992\\times 10^{-26}\\ \\text{kg}$, $L=1.0\\times 10^{-10}\\ \\text{m}$, $k=5.0\\times 10^{3}\\ \\text{N/m}$, $v_0=1.0\\times 10^{3}\\ \\text{m/s}$, $T=5.0\\times 10^{-14}\\ \\text{s}$, $\\Delta t_{\\mathrm{A}}=5.0\\times 10^{-16}\\ \\text{s}$, $\\Delta t_{\\mathrm{B}}=1.0\\times 10^{-17}\\ \\text{s}$.\n3. Test case $3$: $m=1.99264687992\\times 10^{-26}\\ \\text{kg}$, $L=1.0\\times 10^{-10}\\ \\text{m}$, $k=5.0\\times 10^{3}\\ \\text{N/m}$, $v_0=0.0\\ \\text{m/s}$, $T=5.0\\times 10^{-14}\\ \\text{s}$, $\\Delta t_{\\mathrm{A}}=5.0\\times 10^{-16}\\ \\text{s}$, $\\Delta t_{\\mathrm{B}}=1.0\\times 10^{-17}\\ \\text{s}$.\n\nFor each test case in the above order, your program must produce the following six results, in this exact order:\n\n1. $N_{\\mathrm{A}}$ as an integer.\n2. $N_{\\mathrm{B}}$ as an integer.\n3. $\\varepsilon_{\\mathrm{rms}}$ for Model A, in meters, as a floating-point number.\n4. $\\varepsilon_{\\mathrm{rms}}$ for Model B, in meters, as a floating-point number.\n5. $\\Delta E$ for Model A, in joules, as a floating-point number.\n6. $\\Delta E$ for Model B, in joules, as a floating-point number.\n\nFinal output format: Your program should produce a single line of output containing all results for all three test cases as a single, flat, comma-separated list enclosed in square brackets, in the order specified above and repeated per test case. For example, an output with three test cases has the form $[\\text{case1\\_value1},\\text{case1\\_value2},\\ldots,\\text{case3\\_value6}]$. All distances must be in meters and all energies in joules. Angles do not appear in this problem. There are no percentages in any answer.", "solution": "The problem is well-posed, scientifically grounded, and objective. It presents a standard exercise in computational physics: simulating a two-body system (diatomic molecule) using two different models for the inter-particle bond. All initial conditions, parameters, and evaluation metrics are clearly defined. Thus, the problem is valid, and a solution is provided below.\n\n### Principle-Based Design\n\nThe system consists of two identical masses $m$. With no external forces, the center of mass (CM) velocity is conserved. Given the initial conditions $\\mathbf{r}_1(0)=(-L/2,0)$, $\\mathbf{r}_2(0)=(+L/2,0)$ and $\\mathbf{v}_1(0)=(0,v_0)$, $\\mathbf{v}_2(0)=(0,-v_0)$, the CM is initially at rest at the origin and will remain there for all time $t$. The dynamics can be fully described by the relative coordinate $\\mathbf{r}(t)=\\mathbf{r}_2(t)-\\mathbf{r}_1(t)$. The initial conditions for the relative motion are $\\mathbf{r}(0) = (L, 0)$ and $\\mathbf{v}(0) = (0, -2v_0)$. The initial relative velocity is perpendicular to the bond axis, indicating the system is set into rotation.\n\nThe problem requires simulating this system using two models, for which we select appropriate numerical integration algorithms known for their stability and accuracy in molecular dynamics.\n\n#### Model A: Rigid Bond\n\nIn this model, the bond length is a holonomic constraint: $g(\\mathbf{r}_1, \\mathbf{r}_2) = \\|\\mathbf{r}_2 - \\mathbf{r}_1\\| - L = 0$. This constraint must be satisfied at all times. A standard and robust method for integrating equations of motion with holonomic constraints is the **RATTLE** algorithm. RATTLE is a modification of the Velocity Verlet algorithm that incorporates constraint forces through Lagrange multipliers, ensuring that both the position constraints $g=0$ and the velocity constraints $\\dot{g}=0$ are satisfied at each time step.\n\nSince there are no external or potential-derived forces, the algorithm simplifies. A common implementation of RATTLE, based on the leapfrog Verlet scheme, proceeds as follows for each time step $\\Delta t$:\n\n1.  **Unconstrained Position Update**: First, new unconstrained positions $\\mathbf{r}'_i$ are calculated by advancing the old positions $\\mathbf{r}_i(t)$ using the current velocities $\\mathbf{v}_i(t)$:\n    $$\n    \\mathbf{r}'_i = \\mathbf{r}_i(t) + \\mathbf{v}_i(t) \\Delta t\n    $$\n2.  **SHAKE Correction**: The unconstrained positions $\\mathbf{r}'_i$ will generally violate the bond length constraint. The SHAKE procedure corrects these positions. The correction for each particle is directed along the bond axis. For a two-particle system, this a simple geometric correction. Let $\\mathbf{r}'_{21} = \\mathbf{r}'_2 - \\mathbf{r}'_1$. The corrected positions $\\mathbf{r}_i(t+\\Delta t)$ are:\n    $$\n    \\mathbf{r}_1(t+\\Delta t) = \\mathbf{r}'_1 + \\alpha \\mathbf{r}'_{21} \\quad ; \\quad \\mathbf{r}_2(t+\\Delta t) = \\mathbf{r}'_2 - \\alpha \\mathbf{r}'_{21}\n    $$\n    where the correction factor $\\alpha$ is chosen to enforce the constraint:\n    $$\n    \\alpha = \\frac{1}{2} \\left(1 - \\frac{L}{\\|\\mathbf{r}'_{21}\\|}\\right)\n    $$\n3.  **Provisional Velocity Update**: Provisional velocities are calculated based on the change between the new corrected positions and the old positions:\n    $$\n    \\mathbf{v}'_i = \\frac{\\mathbf{r}_i(t+\\Delta t) - \\mathbf{r}_i(t)}{\\Delta t}\n    $$\n4.  **RATTLE Correction**: These provisional velocities must be corrected to satisfy the velocity constraint $\\dot{g} = (\\mathbf{r}_2-\\mathbf{r}_1)\\cdot(\\mathbf{v}_2-\\mathbf{v}_1) = 0$. The correction removes the component of the relative velocity that is parallel to the bond axis. The final velocities $\\mathbf{v}_i(t+\\Delta t)$ are given by:\n    $$\n    \\mathbf{v}_1(t+\\Delta t) = \\mathbf{v}'_1 - \\gamma \\mathbf{r}_{21}(t+\\Delta t) \\quad ; \\quad \\mathbf{v}_2(t+\\Delta t) = \\mathbf{v}'_2 + \\gamma \\mathbf{r}_{21}(t+\\Delta t)\n    $$\n    where $\\mathbf{r}_{21}(t+\\Delta t) = \\mathbf{r}_2(t+\\Delta t) - \\mathbf{r}_1(t+\\Delta t)$, and the factor $\\gamma$ is:\n    $$\n    \\gamma = - \\frac{\\mathbf{v}'_{21} \\cdot \\mathbf{r}_{21}(t+\\Delta t)}{2 \\|\\mathbf{r}_{21}(t+\\Delta t)\\|^2} = - \\frac{(\\mathbf{v}'_2 - \\mathbf{v}'_1) \\cdot \\mathbf{r}_{21}(t+\\Delta t)}{2L^2}\n    $$\nThis procedure ensures that the constraints are satisfied while maintaining good energy conservation, which is measured by $\\Delta E$. The root-mean-square deviation $\\varepsilon_{\\mathrm{rms}}$ will quantify the small numerical errors in satisfying the position constraint.\n\n#### Model B: Stiff Bond\n\nIn this model, the bond is represented by a harmonic potential $U = \\frac{1}{2}k(\\|\\mathbf{r}_2-\\mathbf{r}_1\\|-L)^2$. This defines a conservative force between the particles:\n$$\n\\mathbf{F}_1 = -\\nabla_{\\mathbf{r}_1} U = k(\\|\\mathbf{r}_{21}\\|-L) \\frac{\\mathbf{r}_{21}}{\\|\\mathbf{r}_{21}\\|} \\quad ; \\quad \\mathbf{F}_2 = -\\mathbf{F}_1\n$$\nwhere $\\mathbf{r}_{21} = \\mathbf{r}_2 - \\mathbf{r}_1$. This is a standard N-body problem with a defined potential. The **Velocity Verlet** algorithm is an excellent choice for this system. It is a symplectic integrator, which means it has favorable long-term energy conservation properties. The algorithm for one time step $\\Delta t$ is:\n\n1.  **Half-step Velocity Update**: Update velocities from $t$ to $t+\\Delta t/2$ using the forces at time $t$:\n    $$\n    \\mathbf{v}_i(t+\\Delta t/2) = \\mathbf{v}_i(t) + \\frac{\\mathbf{F}_i(t)}{m} \\frac{\\Delta t}{2}\n    $$\n2.  **Full-step Position Update**: Update positions from $t$ to $t+\\Delta t$ using the half-step velocities:\n    $$\n    \\mathbf{r}_i(t+\\Delta t) = \\mathbf{r}_i(t) + \\mathbf{v}_i(t+\\Delta t/2) \\Delta t\n    $$\n3.  **Force Calculation**: Compute the new forces $\\mathbf{F}_i(t+\\Delta t)$ using the new positions $\\mathbf{r}_i(t+\\Delta t)$.\n4.  **Second Half-step Velocity Update**: Update velocities from $t+\\Delta t/2$ to $t+\\Delta t$ using the new forces:\n    $$\n    \\mathbf{v}_i(t+\\Delta t) = \\mathbf{v}_i(t+\\Delta t/2) + \\frac{\\mathbf{F}_i(t+\\Delta t)}{m} \\frac{\\Delta t}{2}\n    $$\nThis algorithm evolves the system's trajectory, from which the metrics $\\varepsilon_{\\mathrm{rms}}$ and $\\Delta E$ are computed. For this model, the total energy includes both kinetic and potential terms. The time step $\\Delta t_{\\mathrm{B}}$ must be small enough to resolve the high-frequency bond vibrations, whose characteristic period is approximately $2\\pi\\sqrt{m/(2k)}$.\n\n### Metrics Computation\n\nFor both models, the simulation runs for $N = \\lceil T/\\Delta t \\rceil$ steps. At each step $n=0, 1, \\dots, N$, the bond length is computed to calculate the root-mean-square deviation $\\varepsilon_{\\mathrm{rms}}$. The total energy $E$ is computed at $t=0$ and $t=N\\Delta t$ to find the absolute energy drift $\\Delta E = |E(t=N\\Delta t)-E(0)|$.", "answer": "```python\nimport numpy as np\n\ndef simulate_model_A(m, L, v0, T, dt):\n    \"\"\"\n    Simulates a two-particle system with a rigid bond using the RATTLE algorithm.\n    \"\"\"\n    N = int(np.ceil(T / dt))\n    \n    r1 = np.array([-L / 2, 0.0], dtype=np.float64)\n    r2 = np.array([L / 2, 0.0], dtype=np.float64)\n    v1 = np.array([0.0, v0], dtype=np.float64)\n    v2 = np.array([0.0, -v0], dtype=np.float64)\n    \n    bond_devs_sq = [(np.linalg.norm(r2 - r1) - L)**2]\n    \n    E0 = 0.5 * m * (np.dot(v1, v1) + np.dot(v2, v2))\n    \n    for _ in range(N):\n        # Unconstrained position update (Verlet-I style)\n        r1_unc = r1 + v1 * dt\n        r2_unc = r2 + v2 * dt\n        \n        # SHAKE correction for positions\n        r21_unc = r2_unc - r1_unc\n        norm_r21_unc = np.linalg.norm(r21_unc)\n        \n        if norm_r21_unc == 0.0:\n            alpha = 0.0\n        else:\n            alpha = 0.5 * (1.0 - L / norm_r21_unc)\n        \n        correction = alpha * r21_unc\n        r1_new = r1_unc + correction\n        r2_new = r2_unc - correction\n        \n        # Provisional velocity update\n        v1_prov = (r1_new - r1) / dt\n        v2_prov = (r2_new - r2) / dt\n        \n        # RATTLE correction for velocities\n        r21_new = r2_new - r1_new\n        v21_prov = v2_prov - v1_prov\n        \n        # Note: ||r21_new|| should be L. Using L*L for stability.\n        r21_dot_v21 = np.dot(r21_new, v21_prov)\n        \n        gamma = -r21_dot_v21 / (2.0 * L**2)\n        \n        vel_correction = gamma * r21_new\n        v1_new = v1_prov - vel_correction\n        v2_new = v2_prov + vel_correction\n        \n        # Update state for next step\n        r1, r2, v1, v2 = r1_new, r2_new, v1_new, v2_new\n        \n        bond_devs_sq.append((np.linalg.norm(r2 - r1) - L)**2)\n        \n    Ef = 0.5 * m * (np.dot(v1, v1) + np.dot(v2, v2))\n    \n    eps_rms = np.sqrt(np.mean(bond_devs_sq))\n    delta_E = np.abs(Ef - E0)\n    \n    return eps_rms, delta_E\n\ndef simulate_model_B(m, L, k, v0, T, dt):\n    \"\"\"\n    Simulates a two-particle system with a stiff bond using the Velocity Verlet algorithm.\n    \"\"\"\n    N = int(np.ceil(T / dt))\n    \n    r1 = np.array([-L / 2, 0.0], dtype=np.float64)\n    r2 = np.array([L / 2, 0.0], dtype=np.float64)\n    v1 = np.array([0.0, v0], dtype=np.float64)\n    v2 = np.array([0.0, -v0], dtype=np.float64)\n    \n    def get_forces(r1_p, r2_p):\n        r21_p = r2_p - r1_p\n        dist = np.linalg.norm(r21_p)\n        if dist == 0.0:\n            return np.zeros(2, dtype=np.float64), np.zeros(2, dtype=np.float64)\n        force_mag = k * (dist - L)\n        f1 = force_mag * (r21_p / dist)\n        return f1, -f1\n\n    dist_init = np.linalg.norm(r2 - r1)\n    bond_devs_sq = [(dist_init - L)**2]\n    \n    U0 = 0.5 * k * (dist_init - L)**2\n    K0 = 0.5 * m * (np.dot(v1, v1) + np.dot(v2, v2))\n    E0 = K0 + U0\n\n    f1, f2 = get_forces(r1, r2)\n    \n    for _ in range(N):\n        # Velocity Verlet integrator\n        v1_half = v1 + (f1 / m) * (dt / 2.0)\n        v2_half = v2 + (f2 / m) * (dt / 2.0)\n        \n        r1_new = r1 + v1_half * dt\n        r2_new = r2 + v2_half * dt\n        \n        f1_new, f2_new = get_forces(r1_new, r2_new)\n        \n        v1_new = v1_half + (f1_new / m) * (dt / 2.0)\n        v2_new = v2_half + (f2_new / m) * (dt / 2.0)\n        \n        # Update state for next step\n        r1, r2, v1, v2 = r1_new, r2_new, v1_new, v2_new\n        f1, f2 = f1_new, f2_new\n        \n        bond_devs_sq.append((np.linalg.norm(r2 - r1) - L)**2)\n\n    dist_f = np.linalg.norm(r2 - r1)\n    Uf = 0.5 * k * (dist_f - L)**2\n    Kf = 0.5 * m * (np.dot(v1, v1) + np.dot(v2, v2))\n    Ef = Kf + Uf\n    \n    eps_rms = np.sqrt(np.mean(bond_devs_sq))\n    delta_E = np.abs(Ef - E0)\n    \n    return eps_rms, delta_E\n\n\ndef solve():\n    test_cases = [\n        (1.99264687992e-26, 1.0e-10, 5.0e2, 1.0e3, 5.0e-14, 5.0e-16, 5.0e-17),\n        (1.99264687992e-26, 1.0e-10, 5.0e3, 1.0e3, 5.0e-14, 5.0e-16, 1.0e-17),\n        (1.99264687992e-26, 1.0e-10, 5.0e3, 0.0, 5.0e-14, 5.0e-16, 1.0e-17)\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        m, L, k, v0, T, dt_A, dt_B = case\n        \n        NA = int(np.ceil(T / dt_A))\n        NB = int(np.ceil(T / dt_B))\n        \n        eps_A, dE_A = simulate_model_A(m, L, v0, T, dt_A)\n        eps_B, dE_B = simulate_model_B(m, L, k, v0, T, dt_B)\n        \n        all_results.extend([NA, NB, eps_A, eps_B, dE_A, dE_B])\n\n    # Format output as a single flat list\n    # Use 'g' format for floating point numbers to avoid unnecessary trailing zeros\n    # and to use scientific notation where appropriate.\n    formatted_results = [f\"{x:.15g}\" if isinstance(x, float) else str(x) for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2436794"}, {"introduction": "Real molecules are more than just pairs of atoms. This advanced exercise challenges you to generalize from a single constraint to a system of coupled constraints that define a rigid body. You will implement a \"group SHAKE\" solver for a planar hexagonal molecule, moving from scalar corrections to a matrix-based approach to simultaneously satisfy all geometric constraints [@problem_id:2436747]. This practice is a crucial step towards simulating complex molecular structures and understanding the collective dynamics of rigid bodies.", "problem": "You will implement a complete time-step for a system of holonomically constrained point masses in two spatial dimensions, based on first principles of constrained mechanics. The system consists of six identical point masses representing the carbon skeleton of a planar hexagon. Each point mass has mass $12.0$ in atomic mass units. Let $N$ be the number of particles, with $N=6$, and let $q \\in \\mathbb{R}^{2N}$ denote the planar positions arranged as $(x_0,y_0,x_1,y_1,\\dots,x_{N-1},y_{N-1})$, and $v \\in \\mathbb{R}^{2N}$ denote the corresponding velocities. There are no external forces. All angles in any trigonometric computation must be in radians. All lengths must be in angstroms (Å), all times in femtoseconds (fs), and all velocities in angstroms per femtosecond (Å/fs).\n\nDefine a reference configuration $q_{\\mathrm{ref}}$ as a regular hexagon of side length $1.397$ placed in the plane with its center at the origin, with vertices at angles $2\\pi k/6$ for integer $k$ from $0$ to $5$, scaled so that the side length is $1.397$. Construct a set of pairwise distance constraints between selected particle pairs $\\mathcal{S}$ that makes the hexagon rigid in the plane up to overall translation and rotation: include the six ring edges $(0,1)$, $(1,2)$, $(2,3)$, $(3,4)$, $(4,5)$, $(5,0)$, and add three diagonals $(0,2)$, $(0,3)$, $(0,4)$. For each pair $(i,j)\\in\\mathcal{S}$, define the target distance $d_{ij}$ to equal the Euclidean distance between the corresponding vertices in $q_{\\mathrm{ref}}$. For any configuration $q$, define the holonomic constraint functions\n$$\ng_{ij}(q) \\equiv \\tfrac{1}{2}\\left(\\lVert r_i-r_j\\rVert^2 - d_{ij}^2\\right),\n$$\nwhere $r_k \\in \\mathbb{R}^2$ is the position of particle $k$ extracted from $q$. The Jacobian $G(q)\\in\\mathbb{R}^{m\\times 2N}$, with $m=\\lvert\\mathcal{S}\\rvert$, is defined by row gradients $\\nabla g_{ij}(q)$, which have nonzero blocks only for particles $i$ and $j$. The time derivative of the constraints at $(q,v)$ is\n$\\dot g_{ij}(q,v)= (r_i-r_j)\\cdot(v_i-v_j)$,\nand can be written compactly as $G(q)\\,v$.\n\nYour program must perform, for each given test case, a single time step of duration $\\Delta t$ with zero external forces, as follows:\n\n$1.$ Given initial positions $q(0)$ and velocities $v(0)$, compute the unconstrained drift positions at time $\\Delta t$,\n$$\nq^\\ast \\equiv q(0)+\\Delta t\\,v(0).\n$$\n\n$2.$ Compute corrected positions $q(\\Delta t)=q^\\ast+\\Delta q$ that satisfy all holonomic constraints exactly, $g_{ij}(q(\\Delta t))=0$ for all $(i,j)\\in\\mathcal{S}$, while the correction $\\Delta q$ minimizes the mass-weighted quadratic form $\\tfrac{1}{2}\\sum_{k=0}^{N-1} m_k \\lVert \\Delta r_k\\rVert^2$.\n\n$3.$ Compute corrected velocities $v(\\Delta t)=v(0)+\\Delta v$ that satisfy all velocity constraints exactly at the corrected positions, namely $G(q(\\Delta t))\\,v(\\Delta t)=0$, while the correction $\\Delta v$ minimizes the mass-weighted quadratic form $\\tfrac{1}{2}\\sum_{k=0}^{N-1} m_k \\lVert \\Delta v_k\\rVert^2$.\n\nYou must implement any required numerical procedure to satisfy the above definitions to numerical precision. For reproducibility, all stochastic elements described below must use the specified seeds.\n\nFor each test case, report two real-valued quantities:\n- The maximum absolute holonomic constraint violation at the end of the step,\n$$\nr_{\\mathrm{pos}} \\equiv \\max_{(i,j)\\in\\mathcal{S}} \\lvert g_{ij}(q(\\Delta t))\\rvert,\n$$\nexpressed in $\\text{Å}^2$.\n- The maximum absolute velocity-constraint violation at the end of the step,\n$$\nr_{\\mathrm{vel}} \\equiv \\max_{(i,j)\\in\\mathcal{S}} \\lvert \\dot g_{ij}(q(\\Delta t),v(\\Delta t))\\rvert = \\lVert G(q(\\Delta t))\\,v(\\Delta t)\\rVert_{\\infty},\n$$\nexpressed in $\\text{Å}^2/\\text{fs}$.\n\nTest Suite:\n- Case A (general case): $\\Delta t=0.5$, $q(0)=q_{\\mathrm{ref}}$, and $v(0)$ sampled as independent standard normal components scaled by $0.2$; use random seed $1$.\n- Case B (larger time step): $\\Delta t=5.0$, $q(0)=q_{\\mathrm{ref}}$, and $v(0)$ sampled as independent standard normal components scaled by $0.1$; use random seed $2$.\n- Case C (initial geometric perturbation): $\\Delta t=0.0$, $q(0)$ equal to $q_{\\mathrm{ref}}$ plus independent zero-mean Gaussian perturbations of standard deviation $10^{-3}$ applied to each coordinate; $v(0)=0$; use random seed $3$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of three items, one per test case, each item being a two-element list $[r_{\\mathrm{pos}}, r_{\\mathrm{vel}}]$. For example, the required format is like\n$[[r_{\\mathrm{pos}}^{(A)},r_{\\mathrm{vel}}^{(A)}],[r_{\\mathrm{pos}}^{(B)},r_{\\mathrm{vel}}^{(B)}],[r_{\\mathrm{pos}}^{(C)},r_{\\mathrm{vel}}^{(C)}]]$,\nwith numeric values replacing the symbols.", "solution": "The user has presented a problem in computational physics requiring the implementation of a single time step for a holonomically constrained mechanical system. I will first validate the problem statement and then provide a detailed explanation of the solution methodology.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **System:** $N=6$ identical point masses in $D=2$ spatial dimensions.\n- **Mass:** $m_k = 12.0$ for each particle $k=0, \\dots, 5$.\n- **State variables:** positions $q \\in \\mathbb{R}^{2N}$, velocities $v \\in \\mathbb{R}^{2N}$.\n- **Forces:** No external forces.\n- **Units:** Length in angstroms (Å), time in femtoseconds (fs), velocity in Å/fs.\n- **Reference configuration $q_{\\mathrm{ref}}$:** A regular hexagon with side length $1.397$ Å, centered at the origin.\n- **Constraint pairs $\\mathcal{S}$:**\n  - Edges: $(0,1), (1,2), (2,3), (3,4), (4,5), (5,0)$.\n  - Diagonals: $(0,2), (0,3), (0,4)$.\n- **Number of constraints:** $m = |\\mathcal{S}| = 9$.\n- **Constraint functions:** $g_{ij}(q) = \\frac{1}{2}\\left(\\lVert r_i-r_j\\rVert^2 - d_{ij}^2\\right) = 0$, where $d_{ij}$ is the distance between particles $i$ and $j$ in $q_{\\mathrm{ref}}$.\n- **Velocity constraints:** $\\dot g_{ij}(q,v) = (r_i-r_j)\\cdot(v_i-v_j) = 0$, compactly written as $G(q)v=0$, where $G(q)$ is the constraint Jacobian.\n- **Time step algorithm:** For a time step $\\Delta t$, given $q(0), v(0)$:\n  1. Unconstrained drift: $q^\\ast = q(0)+\\Delta t\\,v(0)$.\n  2. Position correction: Find $q(\\Delta t)=q^\\ast+\\Delta q$ such that $g(q(\\Delta t))=0$ for all constraints, by minimizing the mass-weighted correction $\\frac{1}{2}\\sum_{k=0}^{N-1} m_k \\lVert \\Delta r_k\\rVert^2$.\n  3. Velocity correction: Find $v(\\Delta t)=v(0)+\\Delta v$ such that $G(q(\\Delta t))\\,v(\\Delta t)=0$, by minimizing the mass-weighted correction $\\frac{1}{2}\\sum_{k=0}^{N-1} m_k \\lVert \\Delta v_k\\rVert^2$.\n- **Outputs:**\n  - $r_{\\mathrm{pos}} = \\max_{(i,j)\\in\\mathcal{S}} \\lvert g_{ij}(q(\\Delta t))\\rvert$ ($\\text{Å}^2$).\n  - $r_{\\mathrm{vel}} = \\max_{(i,j)\\in\\mathcal{S}} \\lvert \\dot g_{ij}(q(\\Delta t),v(\\Delta t))\\rvert$ ($\\text{Å}^2/\\text{fs}$).\n- **Test Cases:**\n  - A: $\\Delta t=0.5$, $q(0)=q_{\\mathrm{ref}}$, $v(0) \\sim N(0, 0.2^2)$, seed $1$.\n  - B: $\\Delta t=5.0$, $q(0)=q_{\\mathrm{ref}}$, $v(0) \\sim N(0, 0.1^2)$, seed $2$.\n  - C: $\\Delta t=0.0$, $q(0)=q_{\\mathrm{ref}} + N(0, (10^{-3})^2)$, $v(0)=0$, seed $3$.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded:** The problem is firmly grounded in classical mechanics and computational physics. The described algorithm, while a specific variant, is a form of a constrained dynamics integrator related to the well-known SHAKE and RATTLE algorithms. These methods are standard for simulating molecular systems with rigid bonds or other geometric constraints.\n- **Well-Posed:** The problem is well-posed. The minimization problems for both position and velocity corrections are standard linearly constrained quadratic programs (for velocity) or non-linearly constrained quadratic programs (for position). These problems have unique solutions under the condition that the constraint gradients are linearly independent. For the specified planar hexagon, the $m=9$ constraints are correctly chosen to remove all internal degrees of freedom, leaving the $3$ degrees of freedom for rigid body motion in the plane (two translations, one rotation). The total degrees of freedom are $2N=12$, so $12-9=3$ remain, as expected. Thus, the constraint Jacobian should have full rank, ensuring the existence and uniqueness of the solutions to the linear systems that arise from the method of Lagrange multipliers.\n- **Objective:** The problem is stated with objective, precise language and clear instructions. There are no subjective or ambiguous statements.\n- **Flaws:** No flaws are identified. The problem does not violate scientific principles, is formalizable, self-contained, physically plausible, and well-structured.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. A solution will be provided.\n\n### Solution Methodology\n\nThe problem requires implementing a single time step of a constrained dynamics integrator. The algorithm is a specific sequence of operations: an unconstrained \"drift\" step followed by projection steps to enforce the position and velocity constraints. This can be viewed as a geometric integrator constructed via a Lie-Trotter splitting of the free-flow and constraint-projection operators. With zero external forces, the unconstrained dynamics is a simple drift. The core of the problem lies in implementing the projection steps. Both projections are defined as finding a minimal correction (in a mass-weighted sense) to satisfy the constraints. This is solved using the method of Lagrange multipliers.\n\n**1. System Setup**\nThe system consists of $N=6$ particles, each with mass $m_k = 12.0$. The positions are stored in a vector $q \\in \\mathbb{R}^{12}$, and velocities in $v \\in \\mathbb{R}^{12}$. The mass matrix $M$ is a diagonal $12 \\times 12$ matrix with the masses on the diagonal. Since all masses are equal to $m=12.0$, $M = mI$, and its inverse is $M^{-1} = (1/m)I$.\n\nThe reference configuration $q_{\\mathrm{ref}}$ is a regular hexagon with side length $d = 1.397$ Å. The position of particle $k$ is $r_k^{\\mathrm{ref}} = (d \\cos(2\\pi k/6), d \\sin(2\\pi k/6))$. The $m=9$ constraints are given by the set of pairs $\\mathcal{S}$. For each pair $(i,j) \\in \\mathcal{S}$, the squared target distance $d_{ij}^2 = \\lVert r_i^{\\mathrm{ref}} - r_j^{\\mathrm{ref}} \\rVert^2$ is pre-calculated. The holonomic constraint functions are $g_{ij}(q) = \\frac{1}{2}(\\lVert r_i-r_j\\rVert^2 - d_{ij}^2)$.\n\n**2. Position Correction (SHAKE-like Projection)**\nAfter the unconstrained drift $q^\\ast = q(0) + \\Delta t v(0)$, we must find a correction $\\Delta q$ such that $q(\\Delta t) = q^\\ast + \\Delta q$ satisfies $g(q(\\Delta t)) = 0$. The correction $\\Delta q$ must minimize $\\frac{1}{2}\\Delta q^T M \\Delta q$. The method of Lagrange multipliers leads to the condition that the correction must be a linear combination of the constraint gradients at the final position $q(\\Delta t)$:\n$$\nM \\Delta q = -G(q(\\Delta t))^T \\lambda\n$$\nwhere $\\lambda \\in \\mathbb{R}^m$ is a vector of Lagrange multipliers and $G(q)$ is the $m \\times 2N$ Jacobian matrix of the constraint functions, with rows $\\nabla g_{ij}(q)^T$. Substituting $\\Delta q = -M^{-1}G(q(\\Delta t))^T \\lambda$ into the definition of $q(\\Delta t)$ gives $q(\\Delta t) = q^\\ast - M^{-1}G(q(\\Delta t))^T \\lambda$. This, combined with the constraint equations $g(q(\\Delta t))=0$, forms a system of non-linear equations for $\\lambda$.\n\nThis system is solved iteratively using a Newton-Raphson method. Starting with an initial guess $q^{(0)} = q^\\ast$, each iteration $k$ computes a correction to $q^{(k)}$ by solving a linearized system. The update step is derived by solving for multipliers $\\lambda^{(k)}$ in the linear system:\n$$\n\\left( G(q^{(k)}) M^{-1} G(q^{(k)})^T \\right) \\lambda^{(k)} = g(q^{(k)})\n$$\nand then updating the positions:\n$$\nq^{(k+1)} = q^{(k)} - M^{-1}G(q^{(k)})^T \\lambda^{(k)}\n$$\nThis process is repeated until the constraint violations $\\max_l |g_l(q^{(k)})|$ fall below a numerical tolerance (e.g., $10^{-14}$ Å$^2$). The resulting position is $q(\\Delta t) = q^{(\\text{final})}$.\n\nThe Jacobian $G(q)$ has a sparse structure. For a constraint $g_{ij}$, the only non-zero entries in its gradient $\\nabla g_{ij}(q)$ are for particles $i$ and $j$: $\\nabla_{r_i} g_{ij} = (r_i - r_j)$ and $\\nabla_{r_j} g_{ij} = -(r_i - r_j)$.\n\n**3. Velocity Correction (RATTLE-like Projection)**\nNext, we find the corrected velocity $v(\\Delta t) = v(0) + \\Delta v$ that satisfies the velocity constraints $G(q(\\Delta t))v(\\Delta t) = 0$ and minimizes $\\frac{1}{2}\\Delta v^T M \\Delta v$.\nAgain, the method of Lagrange multipliers states that the correction $\\Delta v$ must be in the space spanned by the constraint gradients:\n$$\nM \\Delta v = -G(q(\\Delta t))^T \\mu\n$$\nwhere $\\mu \\in \\mathbb{R}^m$ are Lagrange multipliers. Substituting this into the velocity constraint equation:\n$$\nG(q(\\Delta t)) (v(0) - M^{-1}G(q(\\Delta t))^T \\mu) = 0\n$$\nThis yields a linear system for the multipliers $\\mu$:\n$$\n\\left( G(q(\\Delta t)) M^{-1} G(q(\\Delta t))^T \\right) \\mu = G(q(\\Delta t)) v(0)\n$$\nThe matrix $G M^{-1} G^T$ is the same $m \\times m$ matrix structure encountered in the position correction step, but evaluated at the new position $q(\\Delta t)$. After solving for $\\mu$, the final velocity is computed as:\n$$\nv(\\Delta t) = v(0) - M^{-1}G(q(\\Delta t))^T \\mu\n$$\nThis is a direct, non-iterative calculation. The resulting $v(\\Delta t)$ will satisfy the velocity constraints to machine precision.\n\nFinally, the required maximum absolute constraint violations, $r_{\\mathrm{pos}}$ and $r_{\\mathrm{vel}}$, are calculated using the final state $(q(\\Delta t), v(\\Delta t))$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a single time-step for a holonomically constrained system of 6 point masses\n    representing a planar hexagon, based on the SHAKE/RATTLE principles.\n    \"\"\"\n\n    # --- System Constants ---\n    N_PARTICLES = 6\n    N_DIMS = 2\n    MASS = 12.0\n    SIDE_LENGTH = 1.397\n    CONSTRAINTS = [\n        (0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0),  # Edges\n        (0, 2), (0, 3), (0, 4)                           # Diagonals\n    ]\n    N_CONSTRAINTS = len(CONSTRAINTS)\n\n    # --- Numerical Parameters ---\n    POS_TOLERANCE = 1e-14\n    MAX_ITERATIONS = 100\n\n    # --- Helper Functions ---\n\n    def get_q_ref():\n        \"\"\"Constructs the reference configuration of the regular hexagon.\"\"\"\n        q_ref = np.zeros((N_PARTICLES, N_DIMS))\n        for k in range(N_PARTICLES):\n            angle = 2.0 * np.pi * k / N_PARTICLES\n            q_ref[k, 0] = SIDE_LENGTH * np.cos(angle)\n            q_ref[k, 1] = SIDE_LENGTH * np.sin(angle)\n        return q_ref\n\n    def get_d_sq(q_ref):\n        \"\"\"Calculates the squared target distances for all constraints.\"\"\"\n        d_sq = np.zeros(N_CONSTRAINTS)\n        for c_idx, (i, j) in enumerate(CONSTRAINTS):\n            d_sq[c_idx] = np.sum((q_ref[i] - q_ref[j])**2)\n        return d_sq\n\n    # --- Pre-calculate reference properties ---\n    q_ref = get_q_ref()\n    d_sq_ref = get_d_sq(q_ref)\n\n    # --- Core Constraint Functions ---\n\n    def eval_g(q):\n        \"\"\"Evaluates the holonomic constraint functions g(q).\"\"\"\n        g = np.zeros(N_CONSTRAINTS)\n        for c_idx, (i, j) in enumerate(CONSTRAINTS):\n            dist_sq = np.sum((q[i] - q[j])**2)\n            g[c_idx] = 0.5 * (dist_sq - d_sq_ref[c_idx])\n        return g\n\n    def build_G(q):\n        \"\"\"Builds the constraint Jacobian matrix G(q).\"\"\"\n        G = np.zeros((N_CONSTRAINTS, N_PARTICLES * N_DIMS))\n        for c_idx, (i, j) in enumerate(CONSTRAINTS):\n            diff = q[i] - q[j]\n            G[c_idx, i*N_DIMS : (i+1)*N_DIMS] = diff\n            G[c_idx, j*N_DIMS : (j+1)*N_DIMS] = -diff\n        return G\n\n    def perform_timestep(q0, v0, dt):\n        \"\"\"Performs one complete time step of constrained dynamics.\"\"\"\n        # Step 1: Unconstrained Drift\n        q_star = q0 + dt * v0\n\n        # Step 2: Position Correction (iterative Newton-like solver)\n        q_curr = q_star.copy()\n        inv_mass = 1.0 / MASS\n        for _ in range(MAX_ITERATIONS):\n            g = eval_g(q_curr)\n            if np.max(np.abs(g)) < POS_TOLERANCE:\n                break\n            \n            G = build_G(q_curr)\n            J = inv_mass * (G @ G.T)\n            \n            try:\n                lambda_ = np.linalg.solve(J, g)\n            except np.linalg.LinAlgError:\n                lambda_ = np.linalg.pinv(J) @ g\n                \n            delta_q_flat = -inv_mass * (G.T @ lambda_)\n            q_curr += delta_q_flat.reshape((N_PARTICLES, N_DIMS))\n        \n        q_final = q_curr\n\n        # Step 3: Velocity Correction (direct solver)\n        v_uncorrected = v0\n        G_final = build_G(q_final)\n        J_final = inv_mass * (G_final @ G_final.T)\n        \n        b = G_final @ v_uncorrected.flatten()\n        \n        try:\n            mu = np.linalg.solve(J_final, b)\n        except np.linalg.LinAlgError:\n            mu = np.linalg.pinv(J_final) @ b\n            \n        delta_v_flat = -inv_mass * (G_final.T @ mu)\n        \n        v_final = v_uncorrected + delta_v_flat.reshape((N_PARTICLES, N_DIMS))\n        \n        return q_final, v_final\n\n    # --- Test Suite ---\n    test_cases_params = [\n        # Case A\n        {'dt': 0.5, 'q0_pert_std': 0.0, 'q0_seed': None, 'v0_scale': 0.2, 'v0_seed': 1},\n        # Case B\n        {'dt': 5.0, 'q0_pert_std': 0.0, 'q0_seed': None, 'v0_scale': 0.1, 'v0_seed': 2},\n        # Case C\n        {'dt': 0.0, 'q0_pert_std': 1e-3, 'q0_seed': 3, 'v0_scale': 0.0, 'v0_seed': None},\n    ]\n\n    final_results = []\n    for params in test_cases_params:\n        # Set up initial conditions for the case\n        if params['q0_pert_std'] > 0:\n            rng_q = np.random.default_rng(params['q0_seed'])\n            q0_pert = rng_q.normal(loc=0.0, scale=params['q0_pert_std'], size=(N_PARTICLES, N_DIMS))\n            q0 = q_ref + q0_pert\n        else:\n            q0 = q_ref.copy()\n\n        if params['v0_scale'] > 0:\n            rng_v = np.random.default_rng(params['v0_seed'])\n            v0 = rng_v.standard_normal(size=(N_PARTICLES, N_DIMS)) * params['v0_scale']\n        else:\n            v0 = np.zeros((N_PARTICLES, N_DIMS))\n\n        # Run the simulation step\n        q_final, v_final = perform_timestep(q0, v0, params['dt'])\n\n        # Calculate and store results\n        r_pos = np.max(np.abs(eval_g(q_final)))\n        \n        G_final = build_G(q_final)\n        g_dot_final = G_final @ v_final.flatten()\n        r_vel = np.max(np.abs(g_dot_final))\n        \n        final_results.append([r_pos, r_vel])\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "2436747"}]}