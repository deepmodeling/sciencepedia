{"hands_on_practices": [{"introduction": "While many numerical methods can accurately predict short-term motion, long-term physical simulations like those in astrophysics demand special properties. This practice demonstrates the crucial difference between a general-purpose integrator like the fourth-order Runge-Kutta (RK4) and a time-reversible, symplectic method like velocity-Verlet. By simulating a planetary orbit over many decades, you will numerically verify why the bounded energy error of the Verlet method makes it the superior choice for preserving the physical integrity of Hamiltonian systems over long timescales [@problem_id:2446756].", "problem": "Implement and compare two numerical integrators for Newtonian two-body motion in a plane, one that is time-reversible and symplectic (velocity Verlet) and one that is explicit and fourth-order but not time-reversible (Runge–Kutta of order four (RK4)). Consider a test particle of mass $m=1\\ \\mathrm{kg}$ moving under the gravitational field of a fixed central body with standard gravitational parameter $\\mu = G M = 1.32712440018\\times 10^{20}\\ \\mathrm{m^3/s^2}$. The equations of motion are the first-order system\n$$\n\\dot{\\mathbf{r}}(t) = \\mathbf{v}(t),\\qquad \\dot{\\mathbf{v}}(t) = -\\frac{\\mu}{\\|\\mathbf{r}(t)\\|^3}\\,\\mathbf{r}(t),\n$$\nwith total specific mechanical energy\n$$\nE(t) = \\frac{1}{2}\\,\\|\\mathbf{v}(t)\\|^2 - \\frac{\\mu}{\\|\\mathbf{r}(t)\\|},\n$$\nwhich is conserved exactly by the continuous dynamics. Use initial position $\\mathbf{r}_0 = (r_0,0)$ with $r_0 = 1.495978707\\times 10^{11}\\ \\mathrm{m}$ and initial velocity $\\mathbf{v}_0 = (0, v_{\\mathrm{init}})$ as specified in each test case. The velocity for a circular orbit at radius $r_0$ is $v_{\\mathrm{circ}} = \\sqrt{\\mu/r_0}$.\n\nSimulate the motion in two spatial dimensions using both integrators for each test case below. For each simulation, advance in uniform time steps of size $\\Delta t$ up to a total time $T$. Define the number of steps as $N=\\left\\lfloor T/\\Delta t \\right\\rfloor$, and advance exactly $N$ steps. Compute the absolute relative drift in the specific energy as\n$$\n\\varepsilon = \\left|\\frac{E_N - E_0}{|E_0|}\\right|,\n$$\nwhere $E_0$ is the initial specific energy and $E_N$ is the specific energy after $N$ steps. Report $\\varepsilon$ for both the velocity Verlet and the Runge–Kutta of order four (RK4) methods.\n\nUse the International System of Units (SI) throughout, with distances in $\\mathrm{m}$, time in $\\mathrm{s}$, and energy in $\\mathrm{J/kg}$ (specific energy). Angles, if any appear internally, should be in radians. The final outputs are dimensionless numbers.\n\nTest Suite:\n- Case $1$ (circular, fine step): $v_{\\mathrm{init}} = v_{\\mathrm{circ}}$, $\\Delta t = 86400\\ \\mathrm{s}$, $T = 50\\times 365.25\\times 86400\\ \\mathrm{s}$.\n- Case $2$ (circular, coarse step): $v_{\\mathrm{init}} = v_{\\mathrm{circ}}$, $\\Delta t = 5\\times 86400\\ \\mathrm{s}$, $T = 200\\times 365.25\\times 86400\\ \\mathrm{s}$.\n- Case $3$ (elliptical, more eccentric): $v_{\\mathrm{init}} = 0.7\\, v_{\\mathrm{circ}}$, $\\Delta t = 86400\\ \\mathrm{s}$, $T = 100\\times 365.25\\times 86400\\ \\mathrm{s}$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the six numbers in the following order: $[\\varepsilon_{\\mathrm{Verlet,1}}, \\varepsilon_{\\mathrm{RK4,1}}, \\varepsilon_{\\mathrm{Verlet,2}}, \\varepsilon_{\\mathrm{RK4,2}}, \\varepsilon_{\\mathrm{Verlet,3}}, \\varepsilon_{\\mathrm{RK4,3}}]$. Express each number in standard floating-point notation; scientific notation is acceptable. The results are dimensionless real numbers.", "solution": "The problem statement has been subjected to rigorous validation and is found to be scientifically grounded, well-posed, and objective. It represents a standard exercise in computational physics and celestial mechanics, with all necessary parameters and conditions clearly specified. There are no logical inconsistencies, factual errors, or ambiguities. Therefore, we shall proceed with a complete solution.\n\nThe problem requires the implementation and comparison of two numerical integration schemes for the classical Newtonian two-body problem in a plane. The system under consideration is a test particle orbiting a fixed central mass. The dynamics are governed by the following first-order system of ordinary differential equations:\n$$\n\\dot{\\mathbf{r}}(t) = \\mathbf{v}(t)\n$$\n$$\n\\dot{\\mathbf{v}}(t) = \\mathbf{a}(\\mathbf{r}(t)) = -\\frac{\\mu}{\\|\\mathbf{r}(t)\\|^3}\\,\\mathbf{r}(t)\n$$\nHere, $\\mathbf{r}(t)$ is the position vector, $\\mathbf{v}(t)$ is the velocity vector, and $\\mu$ is the standard gravitational parameter of the central body. A key conserved quantity in the exact continuous dynamics is the specific mechanical energy:\n$$\nE = \\frac{1}{2}\\,\\|\\mathbf{v}\\|^2 - \\frac{\\mu}{\\|\\mathbf{r}\\|}\n$$\nNumerical integrators will not conserve this quantity exactly. Our objective is to quantify this numerical error for two different methods: the velocity Verlet algorithm and the classical Runge-Kutta method of order four. The error is measured by the absolute relative energy drift, $\\varepsilon = \\left|\\frac{E_N - E_0}{|E_0|}\\right|$, after $N$ integration steps.\n\nLet us define the discrete time points as $t_n = n \\Delta t$, where $\\Delta t$ is the constant time step. The state of the system at time $t_n$ is $(\\mathbf{r}_n, \\mathbf{v}_n)$.\n\n**1. The Velocity Verlet Integrator**\n\nThe velocity Verlet algorithm is a member of the family of geometric integrators. It is specifically designed to be symplectic and time-reversible, which grants it excellent long-term stability for Hamiltonian systems like the one considered. It does not conserve energy exactly, but the energy error remains bounded and oscillates around the initial value, showing no secular drift. The algorithm is of second-order accuracy.\n\nGiven the state $(\\mathbf{r}_n, \\mathbf{v}_n)$, one step of the velocity Verlet algorithm to compute $(\\mathbf{r}_{n+1}, \\mathbf{v}_{n+1})$ proceeds as follows:\n1.  Compute the acceleration at the current position: $\\mathbf{a}_n = \\mathbf{a}(\\mathbf{r}_n)$.\n2.  Update the velocity by a half-step: $\\mathbf{v}_{n+1/2} = \\mathbf{v}_n + \\frac{\\Delta t}{2} \\mathbf{a}_n$.\n3.  Update the position by a full step using this intermediate velocity: $\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\Delta t \\, \\mathbf{v}_{n+1/2}$.\n4.  Compute the acceleration at the new position: $\\mathbf{a}_{n+1} = \\mathbf{a}(\\mathbf{r}_{n+1})$.\n5.  Update the velocity for the remaining half-step: $\\mathbf{v}_{n+1} = \\mathbf{v}_{n+1/2} + \\frac{\\Delta t}{2} \\mathbf{a}_{n+1}$.\n\nThese steps are combined for implementation, often into the form:\n$$\n\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t + \\frac{1}{2} \\mathbf{a}(\\mathbf{r}_n) \\Delta t^2\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{1}{2} (\\mathbf{a}(\\mathbf{r}_n) + \\mathbf{a}(\\mathbf{r}_{n+1})) \\Delta t\n$$\n\n**2. The Runge-Kutta 4th-Order (RK4) Integrator**\n\nThe classical fourth-order Runge-Kutta method is a widely used explicit integrator known for its high accuracy for a given step size. Its local truncation error is of order $O(\\Delta t^5)$ and its global error is of order $O(\\Delta t^4)$. However, RK4 is not symplectic. Consequently, for Hamiltonian systems, it typically introduces a systematic, or secular, drift in the energy, which accumulates over long integration times.\n\nFor our system $\\dot{\\mathbf{r}}=\\mathbf{v}$ and $\\dot{\\mathbf{v}}=\\mathbf{a}(\\mathbf{r})$, we define the state vector $\\mathbf{y} = (\\mathbf{r}, \\mathbf{v})$ and the function $\\mathbf{f}(\\mathbf{y}) = (\\mathbf{v}, \\mathbf{a}(\\mathbf{r}))$. The RK4 update from $\\mathbf{y}_n$ to $\\mathbf{y}_{n+1}$ is:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nThe intermediate stages $\\mathbf{k}_i = (\\mathbf{k}_{ri}, \\mathbf{k}_{vi})$ for $i=1, 2, 3, 4$ are calculated as:\n- Stage $1$:\n$$ \\mathbf{k}_{r1} = \\mathbf{v}_n \\qquad \\mathbf{k}_{v1} = \\mathbf{a}(\\mathbf{r}_n) $$\n- Stage $2$:\n$$ \\mathbf{k}_{r2} = \\mathbf{v}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{v1} \\qquad \\mathbf{k}_{v2} = \\mathbf{a}\\left(\\mathbf{r}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{r1}\\right) $$\n- Stage $3$:\n$$ \\mathbf{k}_{r3} = \\mathbf{v}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{v2} \\qquad \\mathbf{k}_{v3} = \\mathbf{a}\\left(\\mathbf{r}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{r2}\\right) $$\n- Stage $4$:\n$$ \\mathbf{k}_{r4} = \\mathbf{v}_n + \\Delta t \\, \\mathbf{k}_{v3} \\qquad \\mathbf{k}_{v4} = \\mathbf{a}\\left(\\mathbf{r}_n + \\Delta t \\, \\mathbf{k}_{r3}\\right) $$\nThe final updates for position and velocity are then computed by combining these stages:\n$$\n\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_{r1} + 2\\mathbf{k}_{r2} + 2\\mathbf{k}_{r3} + \\mathbf{k}_{r4})\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_{v1} + 2\\mathbf{k}_{v2} + 2\\mathbf{k}_{v3} + \\mathbf{k}_{v4})\n$$\n\n**3. Execution of Test Cases**\n\nFor each specified test case, we perform the following steps:\n1.  Establish the physical and simulation parameters: $\\mu = 1.32712440018 \\times 10^{20}\\ \\mathrm{m^3/s^2}$, $r_0 = 1.495978707 \\times 10^{11}\\ \\mathrm{m}$, and the case-specific values for $v_{\\mathrm{init}}$, $\\Delta t$, and $T$.\n2.  Calculate the circular velocity $v_{\\mathrm{circ}} = \\sqrt{\\mu/r_0}$ and the initial velocity $\\mathbf{v}_0 = (0, v_{\\mathrm{init}})$. The initial position is $\\mathbf{r}_0 = (r_0, 0)$.\n3.  Compute the initial specific energy $E_0 = E(\\mathbf{r}_0, \\mathbf{v}_0)$. For bound orbits, $E_0  0$.\n4.  Determine the number of integration steps $N = \\lfloor T/\\Delta t \\rfloor$.\n5.  Run two separate simulations, one with velocity Verlet and one with RK4. Each simulation starts from $(\\mathbf{r}_0, \\mathbf{v}_0)$ and runs for exactly $N$ steps.\n6.  After $N$ steps, obtain the final states $(\\mathbf{r}_{N,\\text{Verlet}}, \\mathbf{v}_{N,\\text{Verlet}})$ and $(\\mathbf{r}_{N,\\text{RK4}}, \\mathbf{v}_{N,\\text{RK4}})$.\n7.  Compute the final energies $E_{N,\\text{Verlet}}$ and $E_{N,\\text{RK4}}$.\n8.  Calculate the absolute relative energy drift $\\varepsilon$ for each method and store the results.\n\nThe comparison will highlight the fundamental difference between symplectic and non-symplectic integrators in long-term simulations of Hamiltonian systems. The velocity Verlet integrator is expected to demonstrate superior energy conservation properties over many orbits, even with a larger local error than RK4, while RK4's higher-order accuracy may be undermined by the accumulation of secular errors in energy.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares Velocity Verlet and RK4 integrators for the\n    Newtonian two-body problem, reporting the relative energy drift.\n    \"\"\"\n    # Physical and astronomical constants\n    MU_SUN = 1.32712440018e20  # Standard gravitational parameter of the Sun (m^3/s^2)\n    R0_EARTH = 1.495978707e11   # 1 Astronomical Unit (m)\n    DAY_S = 86400.0            # Seconds in one mean solar day\n    YEAR_S = 365.25 * DAY_S    # Seconds in one Julian year\n\n    # --- Core Physics and Numerical Functions ---\n\n    def acceleration(r_vec):\n        \"\"\"Computes gravitational acceleration vector.\"\"\"\n        dist = np.linalg.norm(r_vec)\n        if dist == 0:\n            # Avoid division by zero at the singularity, though it should not be reached.\n            return np.zeros_like(r_vec)\n        return -MU_SUN * r_vec / dist**3\n\n    def specific_energy(r_vec, v_vec):\n        \"\"\"Computes specific mechanical energy.\"\"\"\n        dist = np.linalg.norm(r_vec)\n        if dist == 0:\n            return np.inf\n        return 0.5 * np.dot(v_vec, v_vec) - MU_SUN / dist\n\n    def velocity_verlet_step(r, v, dt):\n        \"\"\"Performs a single step of the Velocity Verlet integration.\"\"\"\n        a_current = acceleration(r)\n        r_new = r + v * dt + 0.5 * a_current * dt**2\n        a_new = acceleration(r_new)\n        v_new = v + 0.5 * (a_current + a_new) * dt\n        return r_new, v_new\n\n    def rk4_step(r, v, dt):\n        \"\"\"Performs a single step of the RK4 integration.\"\"\"\n        # k1\n        k1_r = v\n        k1_v = acceleration(r)\n\n        # k2\n        r2 = r + 0.5 * dt * k1_r\n        k2_r = v + 0.5 * dt * k1_v\n        k2_v = acceleration(r2)\n\n        # k3\n        r3 = r + 0.5 * dt * k2_r\n        k3_r = v + 0.5 * dt * k2_v\n        k3_v = acceleration(r3)\n\n        # k4\n        r4 = r + dt * k3_r\n        k4_r = v + dt * k3_v\n        k4_v = acceleration(r4)\n\n        # Combine stages\n        r_new = r + (dt / 6.0) * (k1_r + 2*k2_r + 2*k3_r + k4_r)\n        v_new = v + (dt / 6.0) * (k1_v + 2*k2_v + 2*k3_v + k4_v)\n        return r_new, v_new\n\n    # --- Test Suite Setup ---\n    v_circ = np.sqrt(MU_SUN / R0_EARTH)\n\n    test_cases = [\n        # Case 1 (circular, fine step)\n        {'v_init_factor': 1.0, 'dt': 1.0 * DAY_S, 'T': 50.0 * YEAR_S},\n        # Case 2 (circular, coarse step)\n        {'v_init_factor': 1.0, 'dt': 5.0 * DAY_S, 'T': 200.0 * YEAR_S},\n        # Case 3 (elliptical, more eccentric)\n        {'v_init_factor': 0.7, 'dt': 1.0 * DAY_S, 'T': 100.0 * YEAR_S},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # --- Simulation Setup for the current case ---\n        v_init = case['v_init_factor'] * v_circ\n        dt = case['dt']\n        T = case['T']\n        \n        # Initial conditions\n        r0 = np.array([R0_EARTH, 0.0])\n        v0 = np.array([0.0, v_init])\n        \n        num_steps = int(T / dt) # As per problem spec: N = floor(T/dt)\n        \n        # Initial energy\n        E0 = specific_energy(r0, v0)\n\n        # --- Velocity Verlet Simulation ---\n        r_v, v_v = r0.copy(), v0.copy()\n        for _ in range(num_steps):\n            r_v, v_v = velocity_verlet_step(r_v, v_v, dt)\n        \n        E_N_verlet = specific_energy(r_v, v_v)\n        epsilon_verlet = abs((E_N_verlet - E0) / E0)\n        results.append(epsilon_verlet)\n        \n        # --- RK4 Simulation ---\n        r_rk, v_rk = r0.copy(), v0.copy()\n        for _ in range(num_steps):\n            r_rk, v_rk = rk4_step(r_rk, v_rk, dt)\n\n        E_N_rk4 = specific_energy(r_rk, v_rk)\n        epsilon_rk4 = abs((E_N_rk4 - E0) / E0)\n        results.append(epsilon_rk4)\n\n    # --- Final Output ---\n    # Convert results to string representation for printing\n    result_str = [f\"{res:.10e}\" for res in results]\n    print(f\"[{','.join(result_str)}]\")\n\nsolve()\n```", "id": "2446756"}, {"introduction": "Time-reversible integrators offer remarkable stability, but they are not infallible. Their reliability depends on a crucial relationship between the integration time step $\\Delta t$ and the natural frequencies of the system being simulated. In this exercise, you will investigate this dependency by finding a numerical resonance where the solution becomes unstable, even though the integrator is formally symplectic and time-reversible. This hands-on exploration of the stability condition $|\\omega \\Delta t| \\le 2$ will highlight the importance of choosing an appropriate time step to ensure physically meaningful results [@problem_id:2446795].", "problem": "Design and implement a complete program that, for a one-dimensional classical harmonic oscillator with Hamiltonian $H(x,p)=\\dfrac{p^2}{2m}+\\dfrac{1}{2}m\\omega^2 x^2$, detects a discrete-time step-size resonance that degrades the performance of a time-reversible integrator. Use dimensionless units with $m=1$, and express all quantities without physical units. Angles and angular frequency must be understood in radians, and time in the same dimensionless unit as the angular frequency (so $\\omega$ is in radians per unit time). The oscillator obeys Hamilton’s equations $\\dot{x}=p/m$ and $\\dot{p}=-m\\omega^2 x$.\n\nTo produce a consistent, testable result across implementations, evolve the system on a uniform time grid $t_n=n\\,\\Delta t$ using the following time-reversible second-order difference equation for positions:\n$$\nx_{n+1}=2x_n-x_{n-1}-(\\omega\\Delta t)^2\\,x_n,\n$$\nwith initial data specified at $t_0=0$ by $x_0=x(0)$ and $v_0=\\dot{x}(0)$. Initialize the sequence by taking\n$$\nx_1=x_0+\\Delta t\\,v_0-\\tfrac{1}{2}(\\omega\\Delta t)^2\\,x_0.\n$$\nAt each grid index $n\\ge 1$, define a discrete velocity by the centered difference\n$$\nv_n=\\frac{x_{n+1}-x_{n-1}}{2\\Delta t}.\n$$\nDefine the discrete energy at index $n$ by\n$$\nE_n=\\dfrac{1}{2}v_n^2+\\dfrac{1}{2}\\omega^2 x_n^2,\n$$\nand define the reference energy $E_0$ by the exact initial value\n$$\nE_0=\\dfrac{1}{2}v_0^2+\\dfrac{1}{2}\\omega^2 x_0^2.\n$$\nFor a fixed final time $T_{\\mathrm{final}}$, advance the sequence up to the largest integer index $N$ such that $N\\,\\Delta t\\le T_{\\mathrm{final}}$. Over indices $n=1,2,\\ldots,N-1$, measure the maximum relative energy deviation\n$$\n\\varepsilon_{\\max}=\\max_{1\\le n\\le N-1}\\frac{|E_n-E_0|}{E_0}.\n$$\nTo robustly detect numerical instability due to a time-step resonance, adopt the following divergence convention: if at any step $n$ the magnitude $|x_n|$ exceeds $10^6$, terminate the integration and report the scalar value $10^6$ for that test case in place of $\\varepsilon_{\\max}$.\n\nYour program must evaluate $\\varepsilon_{\\max}$ for the following test suite, which fixes the oscillator parameters and varies only the time step:\n- Natural frequency $\\omega=1$.\n- Initial conditions $x_0=1$ and $v_0=0$.\n- Final time $T_{\\mathrm{final}}=200\\cdot 2\\pi$.\n- Time steps $\\Delta t$ in the set $\\{\\;0.1,\\;1.0,\\;1.9,\\;2.0,\\;2.1\\;\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered to correspond to the listed time steps. Each listed number must be a decimal floating-point value rounded to $6$ significant figures, using either fixed-point or scientific notation as needed. For cases that trigger the divergence convention, output $10^6$ rounded to $6$ significant figures as specified. The output format must be exactly\n[res_0,res_1,res_2,res_3,res_4]\nwith no spaces and in the same order as the time steps above.", "solution": "The problem statement is valid. It is a well-posed, scientifically grounded exercise in computational physics that investigates the numerical stability of a time-reversible integrator for a classical harmonic oscillator. All parameters, equations, and evaluation criteria are provided with sufficient clarity and precision to permit a unique and verifiable solution.\n\nThe system under consideration is a one-dimensional harmonic oscillator with Hamiltonian $H(x,p)=\\dfrac{p^2}{2m}+\\dfrac{1}{2}m\\omega^2 x^2$. With dimensionless units and mass $m=1$, Hamilton's equations simplify to $\\dot{x}=p$ and $\\dot{p}=-\\omega^2 x$, which combine to give the standard second-order ordinary differential equation $\\ddot{x} + \\omega^2 x = 0$.\n\nThe numerical integration scheme is specified by the second-order difference equation for the position $x_n$ at time $t_n = n\\Delta t$:\n$$\nx_{n+1}=2x_n-x_{n-1}-(\\omega\\Delta t)^2\\,x_n\n$$\nThis is a standard explicit, time-reversible integrator known as the Størmer-Verlet method (in its position-Verlet form). Its primary advantage is excellent long-term conservation of a pseudo-Hamiltonian, which results in bounded energy error for stable oscillations, as opposed to the secular drift often exhibited by non-symplectic methods like Runge-Kutta.\n\nThe stability of this linear difference scheme is paramount. We can analyze it by substituting a trial solution of the form $x_n = z^n$, which yields the characteristic equation:\n$$\nz^2 - \\left(2 - (\\omega\\Delta t)^2\\right) z + 1 = 0\n$$\nFor the numerical solution to remain bounded, the roots $z$ of this quadratic equation must lie on the unit circle in the complex plane, which means $|z|=1$. The roots are given by:\n$$\nz_{\\pm} = \\frac{\\left(2 - (\\omega\\Delta t)^2\\right) \\pm \\sqrt{\\left(2 - (\\omega\\Delta t)^2\\right)^2 - 4}}{2}\n$$\nThe condition $|z|=1$ requires the discriminant to be non-positive:\n$$\n\\left(2 - (\\omega\\Delta t)^2\\right)^2 - 4 \\le 0 \\implies -2 \\le 2 - (\\omega\\Delta t)^2 \\le 2\n$$\nThis simplifies to $(\\omega\\Delta t)^2 \\le 4$, or the well-known stability condition for the Verlet method:\n$$\n|\\omega \\Delta t| \\le 2\n$$\nWhen $|\\omega \\Delta t| > 2$, one root has a magnitude greater than unity, causing the numerical solution to diverge exponentially. The case $|\\omega \\Delta t| = 2$ is a numerical resonance. At this point, the characteristic equation has a double root at $z=-1$, and the general solution takes the form $x_n = (A + Bn)(-1)^n$, predicting a linear growth in amplitude.\n\nThe problem requires evaluation for $\\omega=1$ and several values of $\\Delta t$:\n1.  $\\Delta t \\in \\{0.1, 1.0, 1.9\\}$: Here, $|\\omega \\Delta t|  2$, so the integration is in the stable regime. We expect bounded, oscillatory error in the discrete energy $E_n$. The magnitude of this error is expected to grow as $\\Delta t$ increases.\n2.  $\\Delta t = 2.0$: Here, $|\\omega \\Delta t| = 2$, which is the resonance condition. However, the specific initialization method given, $x_1=x_0+\\Delta t\\,v_0-\\tfrac{1}{2}(\\omega\\Delta t)^2\\,x_0$, combined with the initial conditions $x_0=1, v_0=0$, results in $x_1 = 1 - \\frac{1}{2}(1 \\cdot 2)^2(1) = 1-2 = -1$. The subsequent sequence becomes $x_n = (-1)^n$. For this particular non-generic trajectory, the discrete velocity $v_n = (x_{n+1}-x_{n-1})/(2\\Delta t)$ is always zero, and the discrete energy $E_n$ remains exactly equal to the initial energy $E_0$. Thus, the maximum relative energy deviation $\\varepsilon_{\\max}$ will be precisely zero.\n3.  $\\Delta t = 2.1$: Here, $|\\omega \\Delta t| > 2$, so the integration is unstable. The position $x_n$ will grow exponentially, and the simulation is expected to terminate by triggering the divergence condition $|x_n| > 10^6$.\n\nThe solution is implemented by a direct translation of the given algorithm. For each specified $\\Delta t$, the procedure is as follows:\n- Initialize the system with the given parameters: $\\omega=1, x_0=1, v_0=0$.\n- Calculate the total number of steps $N = \\lfloor T_{\\mathrm{final}} / \\Delta t \\rfloor$, with $T_{\\mathrm{final}}=400\\pi$.\n- Calculate the reference energy $E_0 = \\frac{1}{2}v_0^2+\\frac{1}{2}\\omega^2 x_0^2 = 0.5$.\n- Initialize the first two positions, $x_0$ and $x_1$, according to the problem specification.\n- Iterate from $n=1$ to $N-1$:\n    - Calculate the next position $x_{n+1}$ using the Verlet update rule.\n    - Check for divergence. If $|x_n| > 10^6$, the error for this $\\Delta t$ is set to $10^6$ and the simulation for this case is terminated.\n    - Compute the discrete velocity $v_n$ using the centered difference formula.\n    - Compute the discrete energy $E_n$.\n    - Update the maximum relative energy deviation $\\varepsilon_{\\max}$ observed thus far.\n    - Advance the positions for the next iteration.\n- Store the final value of $\\varepsilon_{\\max}$ for the current $\\Delta t$.\nThe final list of results is then formatted as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_num(n):\n    \"\"\"\n    Formats a number to 6 significant figures, with special handling\n    for the divergence value 1.0e6 to ensure it is represented\n    with 6 significant figures in scientific notation.\n    \"\"\"\n    if n == 1.0e6:\n        return \"1.00000e+06\"\n    return f\"{n:.6g}\"\n\ndef solve():\n    \"\"\"\n    Solves the problem of detecting time-step resonance for a harmonic oscillator\n    integrated with the Størmer-Verlet method.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0.1, 1.0, 1.9, 2.0, 2.1]\n\n    # Fixed parameters for the oscillator\n    omega = 1.0\n    x0 = 1.0\n    v0 = 0.0\n    T_final = 200.0 * 2.0 * np.pi\n    divergence_threshold = 1.0e6\n\n    results = []\n\n    # Calculate exact initial energy\n    E0 = 0.5 * v0**2 + 0.5 * omega**2 * x0**2\n    # Prevent division by zero if E0 is zero, although not the case here.\n    if E0 == 0:\n        E0 = 1.0 \n\n    for dt in test_cases:\n        # Determine the total number of steps\n        N = int(T_final / dt)\n\n        # Initialize variables for the simulation\n        max_rel_err = 0.0\n        diverged = False\n\n        # Set initial positions\n        x_prev = x0\n        \n        # Calculate x1 using the specified second-order initialization\n        wdt2 = (omega * dt)**2\n        x_curr = x0 + dt * v0 - 0.5 * wdt2 * x0\n\n        # Time-stepping loop from n=1 to N-1 to compute E_n up to E_{N-1}\n        for n in range(1, N):\n            # Check for divergence\n            if abs(x_curr) > divergence_threshold:\n                max_rel_err = divergence_threshold\n                diverged = True\n                break\n            \n            # Calculate next position using the Verlet update rule\n            x_next = (2.0 - wdt2) * x_curr - x_prev\n            \n            # Calculate discrete velocity and energy at step n\n            # v_n is defined by the centered difference at time t_n\n            v_n = (x_next - x_prev) / (2.0 * dt)\n            E_n = 0.5 * v_n**2 + 0.5 * omega**2 * x_curr**2\n            \n            # Calculate relative energy deviation and update the maximum\n            rel_err = abs(E_n - E0) / E0\n            if rel_err > max_rel_err:\n                max_rel_err = rel_err\n            \n            # Update positions for the next step\n            x_prev = x_curr\n            x_curr = x_next\n        \n        if not diverged and N > 0 and abs(x_curr) > divergence_threshold:\n            # Final check in case the last computed step diverged\n            max_rel_err = divergence_threshold\n\n        results.append(max_rel_err)\n\n    # Format results to 6 significant figures\n    formatted_results = [format_num(r) for r in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2446795"}, {"introduction": "The excellent long-term properties of the Verlet algorithm stem from its symmetric, time-reversible structure. However, this structure must be respected from the very beginning of the simulation. This practice focuses on the \"bootstrapping\" problem for the position Verlet integrator: how to compute the first step $x_1$ from the initial conditions $(x_0, v_0)$. By comparing a simple first-order method with a correct second-order one, you will quantify how an inconsistent initialization can compromise the integrator's long-term energy conservation and overall accuracy [@problem_id:2446800].", "problem": "Construct a complete, runnable program that compares how the choice of the first-step construction (bootstrapping) affects the long-term numerical trajectory when using the time-reversible position Verlet integrator to propagate a one-dimensional classical harmonic oscillator. Consider a point mass of mass $m$ moving in the potential $V(x) = \\tfrac{1}{2} k x^{2}$, so that the acceleration is $a(x) = -\\tfrac{k}{m} x$. The exact angular frequency is $\\omega = \\sqrt{\\tfrac{k}{m}}$, and for initial conditions $x(0)=x_{0}$ and $v(0)=v_{0}$, the exact solution is\n$$\nx_{\\mathrm{exact}}(t) = x_{0} \\cos(\\omega t) + \\frac{v_{0}}{\\omega} \\sin(\\omega t),\n\\qquad\nv_{\\mathrm{exact}}(t) = -x_{0}\\,\\omega \\sin(\\omega t) + v_{0} \\cos(\\omega t).\n$$\nAll angles must be treated in radians. All physical quantities must be expressed using the International System of Units (SI): positions in meters, velocities in meters per second, mass in kilograms, stiffness in newtons per meter, and time in seconds. The mechanical energy at time $t$ is\n$$\nE(t) = \\tfrac{1}{2} m\\, v(t)^{2} + \\tfrac{1}{2} k\\, x(t)^{2}.\n$$\nUse the position Verlet recurrence for discrete times $t_{n} = n\\,\\Delta t$ with fixed time step $\\Delta t$:\n$$\nx_{n+1} = 2\\,x_{n} - x_{n-1} + a(x_{n})\\,(\\Delta t)^{2}, \\quad \\text{where } a(x_{n}) = -\\frac{k}{m}\\,x_{n}.\n$$\nThis update requires a first step $x_{1}$ given $x_{0}$ and $v_{0}$. Compare the following two first-step constructions:\n- Euler bootstrap: $x_{1}^{\\mathrm{E}} = x_{0} + v_{0}\\,\\Delta t$.\n- Second-order Taylor bootstrap: $x_{1}^{\\mathrm{T}} = x_{0} + v_{0}\\,\\Delta t + \\tfrac{1}{2}\\,a(x_{0})\\,(\\Delta t)^{2}$.\n\nFor a given parameter set, simulate for $N$ steps to time $T = N\\,\\Delta t$ using each bootstrap, and compute the following two dimensionless diagnostics for each bootstrap:\n- Final relative position error, defined as\n$$\n\\varepsilon_{x} = \\frac{\\left|x_{N} - x_{\\mathrm{exact}}(T)\\right|}{A}, \\quad \\text{where } A = \\sqrt{x_{0}^{2} + \\left(\\frac{v_{0}}{\\omega}\\right)^{2}}.\n$$\n- Maximum relative energy deviation over the trajectory, defined as\n$$\n\\varepsilon_{E}^{\\max} = \\max_{1 \\le n \\le N-1} \\frac{\\left|E_{n} - E_{0}\\right|}{E_{0}},\n$$\nwhere $E_{0} = \\tfrac{1}{2} m\\, v_{0}^{2} + \\tfrac{1}{2} k\\, x_{0}^{2}$ and $E_{n} = \\tfrac{1}{2} m\\, v_{n}^{2} + \\tfrac{1}{2} k\\, x_{n}^{2}$ with $v_{n}$ obtained by the centered finite difference $v_{n} = \\dfrac{x_{n+1} - x_{n-1}}{2\\,\\Delta t}$ for $1 \\le n \\le N-1$. If $E_{0} = 0$, define $\\varepsilon_{E}^{\\max} = 0$.\n\nYour program must implement this setup and produce results for the following test suite of parameter sets, each expressed in the International System of Units (SI):\n- Test set A (happy path): $m = 1$, $k = 1$, $x_{0} = 1$, $v_{0} = 0$, $\\Delta t = 0.1$, $N = 10000$.\n- Test set B (near-stability edge for the discrete scheme): $m = 1$, $k = 25$, $x_{0} = 1$, $v_{0} = 0.5$, $\\Delta t = 0.39$, $N = 8000$.\n- Test set C (purely kinetic start): $m = 1$, $k = 1$, $x_{0} = 0$, $v_{0} = 1$, $\\Delta t = 0.05$, $N = 20000$.\n\nFor each test set, output a list of four numbers in the following order:\n$[\\varepsilon_{x}^{\\mathrm{E}}, \\varepsilon_{x}^{\\mathrm{T}}, \\varepsilon_{E,\\mathrm{E}}^{\\max}, \\varepsilon_{E,\\mathrm{T}}^{\\max}]$, where superscripts $\\mathrm{E}$ and $\\mathrm{T}$ refer to the Euler and Taylor bootstraps, respectively. The final program output must be a single line containing the results for all three test sets as a comma-separated list of these lists, with no spaces, for example:\n$[[a_{1},a_{2},a_{3},a_{4}],[b_{1},b_{2},b_{3},b_{4}],[c_{1},c_{2},c_{3},c_{4}]]$.\nEach number must be printed as a decimal with at least $6$ significant digits. All reported diagnostics are dimensionless and must be printed as decimals (do not use a percentage sign).", "solution": "The problem statement is subjected to validation and is found to be scientifically sound, well-posed, and free of ambiguity. It constitutes a standard exercise in computational physics, suitable for rigorous analysis. We shall now proceed with the solution.\n\nThe problem requires a comparative study of two bootstrapping methods for the position Verlet integrator, applied to the one-dimensional harmonic oscillator. The system is defined by a mass $m$ in a potential $V(x) = \\frac{1}{2} k x^2$, leading to the equation of motion $\\ddot{x} = -\\frac{k}{m} x$. The dynamics are characterized by the natural angular frequency $\\omega = \\sqrt{k/m}$.\n\nThe position Verlet algorithm is a second-order, time-reversible, and symplectic integrator. Its recurrence relation for discrete time steps $t_n = n \\Delta t$ is given by\n$$\nx_{n+1} = 2 x_n - x_{n-1} + a(x_n) (\\Delta t)^2,\n$$\nwhere $x_n \\approx x(t_n)$ and $a(x_n) = -\\frac{k}{m} x_n$ is the acceleration at position $x_n$. This is a three-term recurrence, meaning the computation of the position at step $n+1$, $x_{n+1}$, requires the positions from two previous steps, $x_n$ and $x_{n-1}$. To initiate the integration, we are given the initial state $(x_0, v_0)$ at $t=0$. From this, we have $x_0$, but we need a value for $x_1$ to begin the iterative process for $n \\ge 1$. The choice of $x_1$ is the bootstrapping problem.\n\nThe problem proposes two methods for determining $x_1$:\n\n1.  **Euler Bootstrap**: $x_1^{\\mathrm{E}} = x_0 + v_0 \\Delta t$. This is a first-order forward Euler step for the position.\n2.  **Second-Order Taylor Bootstrap**: $x_1^{\\mathrm{T}} = x_0 + v_0 \\Delta t + \\frac{1}{2} a(x_0) (\\Delta t)^2$. This corresponds to a second-order Taylor series expansion of the position $x(\\Delta t)$.\n\nThe theoretical foundation of the Verlet integrator lies in the sum of two Taylor series expansions around time $t_n$:\n$$\nx(t_n + \\Delta t) = x(t_n) + \\dot{x}(t_n)\\Delta t + \\frac{1}{2}\\ddot{x}(t_n)(\\Delta t)^2 + \\frac{1}{6}\\dddot{x}(t_n)(\\Delta t)^3 + \\mathcal{O}((\\Delta t)^4)\n$$\n$$\nx(t_n - \\Delta t) = x(t_n) - \\dot{x}(t_n)\\Delta t + \\frac{1}{2}\\ddot{x}(t_n)(\\Delta t)^2 - \\frac{1}{6}\\dddot{x}(t_n)(\\Delta t)^3 + \\mathcal{O}((\\Delta t)^4)\n$$\nSumming these two equations eliminates the odd-powered derivative terms, yielding:\n$$\nx(t_n + \\Delta t) + x(t_n - \\Delta t) = 2x(t_n) + \\ddot{x}(t_n)(\\Delta t)^2 + \\mathcal{O}((\\Delta t)^4)\n$$\nIdentifying $x_{n \\pm 1}$ with $x(t_n \\pm \\Delta t)$ and $a(x_n)$ with $\\ddot{x}(t_n)$, we recover the position Verlet formula. The local truncation error of the method is $\\mathcal{O}((\\Delta t)^4)$, leading to a global error of $\\mathcal{O}((\\Delta t)^2)$.\n\nCrucially, the derivation reveals that the method's accuracy and desirable properties, such as time-reversibility, depend on this symmetric structure. The bootstrapping step must be chosen with care to not disrupt this structure.\n\nThe second-order Taylor bootstrap for $x_1$,\n$$\nx_1^\\mathrm{T} = x_0 + v_0 \\Delta t + \\frac{1}{2}a(x_0)(\\Delta t)^2,\n$$\nis directly derived from the Taylor expansion for $x(\\Delta t)$ up to second order. This is consistent with the order of the Verlet integrator itself.\n\nIn contrast, the Euler bootstrap,\n$$\nx_1^\\mathrm{E} = x_0 + v_0 \\Delta t,\n$$\nis only a first-order approximation. It introduces an error of magnitude $\\frac{1}{2}a(x_0)(\\Delta t)^2$ in the very first step. This initial error, being of lower order than what is consistent with the integrator, propagates through the simulation and is expected to degrade the overall accuracy and, most notably, the long-term energy conservation. The Verlet method is valued for its excellent long-term energy stability (the numerical energy does not drift systematically but oscillates around the true value). An inconsistent bootstrap damages this property.\n\nFor the special case where the initial position is at the equilibrium point, $x_0=0$, the initial acceleration is also zero, $a(x_0)=0$. In this scenario, the term $\\frac{1}{2} a(x_0) (\\Delta t)^2$ vanishes, and the two bootstrap methods yield identical results: $x_1^{\\mathrm{E}} = x_1^{\\mathrm{T}} = v_0 \\Delta t$. Consequently, for Test Set C where $x_0=0$, the numerical trajectories and all derived diagnostics must be identical for both bootstraps.\n\nThe implementation will proceed as follows: a general function will be constructed to propagate the trajectory for $N$ steps using the position Verlet algorithm. This function will accept the physical parameters ($m, k, x_0, v_0, \\Delta t, N$) and a flag to select the bootstrap method. For each of the three test sets, this simulation will be run twice, once for each bootstrap method.\n\nAfter each simulation run, which generates the position trajectory $\\{x_n\\}_{n=0}^N$, the required diagnostics are computed.\n- The final relative position error, $\\varepsilon_x$, requires computation of the exact position at time $T = N \\Delta t$, given by $x_{\\mathrm{exact}}(T) = x_0 \\cos(\\omega T) + \\frac{v_0}{\\omega} \\sin(\\omega T)$, and the amplitude $A = \\sqrt{x_0^2 + (v_0/\\omega)^2}$. The error is then $\\varepsilon_x = |x_N - x_{\\mathrm{exact}}(T)| / A$.\n- The maximum relative energy deviation, $\\varepsilon_E^{\\max}$, requires computing the numerical velocity $v_n$ and energy $E_n$ for $n \\in [1, N-1]$. The velocity is computed using the centered difference formula $v_n = \\frac{x_{n+1} - x_{n-1}}{2 \\Delta t}$, which is consistent with the time-reversibility of the Verlet scheme. The energy at each step is $E_n = \\frac{1}{2}mv_n^2 + \\frac{1}{2}kx_n^2$. The diagnostic is then found by taking the maximum of $|E_n - E_0|/E_0$ over the trajectory, where $E_0 = \\frac{1}{2}mv_0^2 + \\frac{1}{2}kx_0^2$.\n\nThe results from these computations for each test set will be formatted and presented as specified. The expected outcome is that the Taylor bootstrap will consistently yield smaller errors, particularly for the energy deviation, except in cases like Test Set C where the methods are mathematically equivalent.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n\n    # Test cases are defined as tuples: (m, k, x0, v0, dt, N)\n    test_cases = [\n        # Test set A (happy path)\n        (1.0, 1.0, 1.0, 0.0, 0.1, 10000),\n        # Test set B (near-stability edge)\n        (1.0, 25.0, 1.0, 0.5, 0.39, 8000),\n        # Test set C (purely kinetic start)\n        (1.0, 1.0, 0.0, 1.0, 0.05, 20000),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        m, k, x0, v0, dt, N = params\n        \n        # Run with Euler bootstrap\n        x_euler = propagate_trajectory(m, k, x0, v0, dt, N, 'euler')\n        eps_x_euler, eps_E_max_euler = compute_diagnostics(m, k, x0, v0, dt, N, x_euler)\n\n        # Run with Taylor bootstrap\n        x_taylor = propagate_trajectory(m, k, x0, v0, dt, N, 'taylor')\n        eps_x_taylor, eps_E_max_taylor = compute_diagnostics(m, k, x0, v0, dt, N, x_taylor)\n        \n        case_results = [eps_x_euler, eps_x_taylor, eps_E_max_euler, eps_E_max_taylor]\n        all_results.append(case_results)\n\n    # Format the final output string as specified\n    formatted_case_results = []\n    for res_list in all_results:\n        # Use scientific notation to ensure at least 6 significant digits\n        formatted_list = [f\"{v:.15e}\" for v in res_list]\n        formatted_case_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output = f\"[{','.join(formatted_case_results)}]\"\n    print(final_output)\n\ndef propagate_trajectory(m, k, x0, v0, dt, N, bootstrap_method):\n    \"\"\"\n    Generates a trajectory using the position Verlet integrator.\n\n    Args:\n        m (float): Mass.\n        k (float): Spring constant.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        dt (float): Time step.\n        N (int): Number of steps.\n        bootstrap_method (str): 'euler' or 'taylor'.\n\n    Returns:\n        np.array: Array of positions [x_0, x_1, ..., x_N].\n    \"\"\"\n    x = np.zeros(N + 1)\n    x[0] = x0\n    \n    # Acceleration function\n    accel_factor = -k / m\n    def a(pos):\n        return accel_factor * pos\n\n    # First step (bootstrapping)\n    if bootstrap_method == 'euler':\n        x[1] = x0 + v0 * dt\n    elif bootstrap_method == 'taylor':\n        a0 = a(x0)\n        x[1] = x0 + v0 * dt + 0.5 * a0 * dt**2\n    else:\n        raise ValueError(\"Invalid bootstrap method specified.\")\n\n    # Main integration loop\n    dt_sq = dt**2\n    for n in range(1, N):\n        x[n+1] = 2 * x[n] - x[n-1] + a(x[n]) * dt_sq\n        \n    return x\n\ndef compute_diagnostics(m, k, x0, v0, dt, N, x_trajectory):\n    \"\"\"\n    Computes final position error and max energy deviation.\n\n    Args:\n        m (float): Mass.\n        k (float): Spring constant.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        dt (float): Time step.\n        N (int): Number of steps.\n        x_trajectory (np.array): Position trajectory.\n\n    Returns:\n        tuple: (eps_x, eps_E_max)\n    \"\"\"\n    omega = np.sqrt(k / m)\n\n    # 1. Final relative position error (eps_x)\n    T = N * dt\n    x_exact_T = x0 * np.cos(omega * T) + (v0 / omega) * np.sin(omega * T)\n    \n    amp_sq_term_v = v0 / omega\n    amplitude = np.sqrt(x0**2 + amp_sq_term_v**2)\n    \n    x_N = x_trajectory[N]\n    \n    if amplitude == 0.0:\n        # Trivial case: x0=0, v0=0. System is static.\n        eps_x = 0.0\n    else:\n        eps_x = np.abs(x_N - x_exact_T) / amplitude\n\n    # 2. Maximum relative energy deviation (eps_E_max)\n    E0 = 0.5 * m * v0**2 + 0.5 * k * x0**2\n    \n    if E0 == 0.0:\n        return eps_x, 0.0\n\n    max_rel_E_dev = 0.0\n    # Loop from n=1 to N-1\n    for n in range(1, N):\n        # Centered difference for velocity v_n\n        v_n = (x_trajectory[n+1] - x_trajectory[n-1]) / (2 * dt)\n        \n        # Energy E_n\n        E_n = 0.5 * m * v_n**2 + 0.5 * k * x_trajectory[n]**2\n        \n        rel_E_dev = np.abs(E_n - E0) / E0\n        if rel_E_dev > max_rel_E_dev:\n            max_rel_E_dev = rel_E_dev\n            \n    eps_E_max = max_rel_E_dev\n    \n    return eps_x, eps_E_max\n\nsolve()\n\n```", "id": "2446800"}]}