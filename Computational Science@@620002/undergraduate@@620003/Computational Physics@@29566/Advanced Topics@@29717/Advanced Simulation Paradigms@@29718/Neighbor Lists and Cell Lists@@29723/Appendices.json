{"hands_on_practices": [{"introduction": "Before we can optimize a simulation, we must first guarantee its correctness. This foundational practice [@problem_id:2416939] challenges you to determine the fundamental constraint on cell size in a system with particles of varying sizes. Establishing this condition is the most critical step in implementing a valid cell list algorithm, as an incorrect choice can lead to missed interactions and silently flawed simulation results.", "problem": "In a discrete element method (DEM) simulation of polydisperse spherical grains in three dimensions ($3$D), there are $N$ particles in a periodic cubic domain. Particle $i$ has radius $r_i$, with $r_{\\min} = \\min_i r_i$ and $r_{\\max} = \\max_i r_i$. Two particles interact via contact forces only when the distance between their centers is less than or equal to the sum of their radii, that is, when the center-to-center distance $d_{ij}$ satisfies $d_{ij} \\le r_i + r_j$. A uniform cubic cell-linked list is used for neighbor search with cubic cells of edge length $a$. For each particle, candidate neighbors are taken to be all particles located in the same cell and in the $26$ adjacent neighbor cells. There is no extra buffer (“skin”): the neighbor data structure is rebuilt every time step, and only those $27$ cells are ever searched.\n\nWhich choice best specifies how $a$ should be set in terms of the particle sizes to guarantee that no contacting pair is ever missed while keeping the neighbor enumeration minimal?\n\nA. Set $a$ equal to the smallest particle diameter, $a = 2 r_{\\min}$, to keep per-cell occupancy small.\n\nB. Set $a$ at least as large as the largest particle diameter, $a \\ge 2 r_{\\max}$, so that any contacting pair must lie in the same or adjacent cells; taking $a$ smaller can miss contacts.\n\nC. Set $a$ equal to the mean particle diameter, $a = 2 \\langle r \\rangle$, to balance accuracy and cost on average.\n\nD. Set $a$ equal to the geometric mean diameter, $a = 2 \\sqrt{r_{\\min} r_{\\max}}$, because it bounds most pairwise center separations.", "solution": "The problem statement must first be validated for its scientific and logical integrity before a solution is attempted.\n\n### Step 1: Extract Givens\n- Simulation method: Discrete Element Method (DEM).\n- System: $N$ polydisperse spherical grains in a $3$D periodic cubic domain.\n- Particle radii: $r_i$, with minimum $r_{\\min}$ and maximum $r_{\\max}$.\n- Interaction condition: Two particles $i$ and $j$ are in contact if their center-to-center distance $d_{ij}$ satisfies $d_{ij} \\le r_i + r_j$.\n- Neighbor search algorithm: A uniform cubic cell-linked list with cell edge length $a$.\n- Search stencil: For any given particle, candidate neighbors are searched in its own cell and the $26$ adjacent cells (a $3 \\times 3 \\times 3$ block of cells).\n- Rebuild policy: The neighbor data structure is rebuilt at every time step without any extra buffer or \"skin\".\n- Objective: Determine the condition on the cell edge length $a$ that guarantees no contacting pair is ever missed, while keeping the neighbor enumeration minimal.\n\n### Step 2: Validate Using Extracted Givens\nThe problem describes a standard short-range interaction scenario in a many-particle system, and the use of a cell-linked list (or cell grid) method for efficient neighbor finding. This is a fundamental and canonical problem in computational physics and molecular dynamics simulations. The components are as follows:\n- **Scientifically Grounded:** The setup is based on established principles of DEM and computational geometry. The contact condition for spheres and the cell list algorithm are standard. The problem is scientifically sound.\n- **Well-Posed:** The problem asks for the necessary condition on the cell size $a$ to ensure the correctness of the neighbor search algorithm under a specific search stencil. The objective is clearly stated: guarantee correctness while aiming for efficiency (\"minimal enumeration\"). A unique, derivable condition exists for this well-defined problem.\n- **Objective:** The problem is described using precise, technical language common to the field. There is no ambiguity or subjectivity.\n\nThe problem statement has no scientific or factual unsoundness, is formal and relevant, is complete, is realistic for a computational model, is well-posed, and is scientifically verifiable.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. A solution will be derived.\n\n### Solution Derivation\nThe cell-linked list method is employed to reduce the computational complexity of finding interacting pairs from $O(N^2)$ to $O(N)$. The correctness of this method hinges on the choice of the cell size, $a$. The problem specifies that for a given particle, we search for its neighbors in the $3 \\times 3 \\times 3$ block of cells centered on its own cell. This means that if two particles are to be identified as a potential interaction pair, they must reside in cells that are, at most, adjacent.\n\nLet the position vectors of the centers of two particles $i$ and $j$ be $\\vec{p}_i = (x_i, y_i, z_i)$ and $\\vec{p}_j = (x_j, y_j, z_j)$. The cell grid is aligned with the Cartesian axes. A particle at position $(x, y, z)$ is assigned to a cell with indices $(\\lfloor x/a \\rfloor, \\lfloor y/a \\rfloor, \\lfloor z/a \\rfloor)$.\n\nFor the neighbor search to be successful, if two particles $i$ and $j$ are in contact, the absolute difference of their cell indices along each dimension must be at most $1$. That is:\n$$|\\lfloor x_i/a \\rfloor - \\lfloor x_j/a \\rfloor| \\le 1$$\n$$|\\lfloor y_i/a \\rfloor - \\lfloor y_j/a \\rfloor| \\le 1$$\n$$|\\lfloor z_i/a \\rfloor - \\lfloor z_j/a \\rfloor| \\le 1$$\n\nA contact will be missed if, for example, the separation in the $x$-direction, $|x_i - x_j|$, is large enough that the particles are placed in non-adjacent cells, i.e., $|\\lfloor x_i/a \\rfloor - \\lfloor x_j/a \\rfloor| > 1$. This can happen if $|x_i - x_j| > a$. For instance, if particle $i$ is at $x_i = k \\cdot a - \\epsilon$ and particle $j$ is at $x_j = (k+1) \\cdot a + \\epsilon$ for some small $\\epsilon > 0$, then $|x_i - x_j| \\approx a$. Their cell indices would be $\\lfloor x_i/a \\rfloor = k-1$ and $\\lfloor x_j/a \\rfloor = k+1$, which differ by $2$.\n\nTo guarantee that this never happens for any interacting pair, the separation of their centers along any Cartesian axis must be less than or equal to the cell size $a$. Let $\\Delta x = |x_i - x_j|$, $\\Delta y = |y_i - y_j|$, and $\\Delta z = |z_i - z_j|$. The condition to guarantee finding the pair is:\n$$\\max(\\Delta x, \\Delta y, \\Delta z) \\le a$$\n\nThe contact condition is $d_{ij} = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2} \\le r_i + r_j$. The maximum possible value for $\\Delta x$ occurs when $\\Delta y = \\Delta z = 0$, in which case $\\Delta x = d_{ij}$. Thus, the maximum component separation is bounded by the maximum total separation: $\\Delta x \\le d_{ij}$.\n\nIn summary, for any two contacting particles $i$ and $j$, we have:\n$$\\Delta x \\le d_{ij} \\le r_i + r_j$$\n\nTo ensure that $\\Delta x \\le a$ for *all* possible contacting pairs, $a$ must be greater than or equal to the maximum possible value of the right-hand side. The maximum possible contact distance occurs for two of the largest particles in the system, i.e., two particles with radius $r_{\\max}$. Their maximum separation is $r_{\\max} + r_{\\max} = 2 r_{\\max}$.\n\nTherefore, the condition on $a$ must be:\n$$a \\ge \\max_{i,j \\text{ in contact}} (r_i + r_j)$$\nThe worst case, which we must accommodate, is two of the largest particles just touching.\n$$a \\ge r_{\\max} + r_{\\max} = 2 r_{\\max}$$\n\nIf $a < 2 r_{\\max}$, one can construct a counterexample. Let two particles, each with radius $r_{\\max}$, be in contact and aligned with the $x$-axis. Their centers are separated by a distance $2 r_{\\max}$. If we choose $a$ such that $a < 2 r_{\\max}$, it is possible to place these two particles such that their $x$-coordinates are $x_i = k \\cdot a - \\epsilon$ and $x_j = x_i + 2 r_{\\max}$. If $a < 2 r_{\\max}$, then $x_j$ can fall into cell $k+2$ or beyond, while $x_i$ is in cell $k-1$. The contact would be missed.\n\nTo keep neighbor enumeration minimal, one should choose the smallest possible cell size $a$ that still satisfies the correctness criterion. This means choosing the equality, $a = 2 r_{\\max}$. The condition itself, however, is the inequality $a \\ge 2 r_{\\max}$.\n\n### Option-by-Option Analysis\n\n**A. Set $a$ equal to the smallest particle diameter, $a = 2 r_{\\min}$, to keep per-cell occupancy small.**\nThis choice is flawed. In a polydisperse system where $r_{\\max} > r_{\\min}$, we can have $a = 2 r_{\\min} < 2 r_{\\max}$. As demonstrated in the derivation, if $a < 2 r_{\\max}$, it is possible for two contacting particles of radius $r_{\\max}$ to be placed in non-adjacent cells. This would violate the search guarantee. Therefore, this option is **Incorrect**.\n\n**B. Set $a$ at least as large as the largest particle diameter, $a \\ge 2 r_{\\max}$, so that any contacting pair must lie in the same or adjacent cells; taking $a$ smaller can miss contacts.**\nThis statement aligns perfectly with the derived condition. If $a \\ge 2 r_{\\max}$, then for any contacting pair $(i, j)$, the separation of their centers along any axis, e.g., $\\Delta x$, satisfies $\\Delta x \\le d_{ij} \\le r_i + r_j \\le 2 r_{\\max} \\le a$. With $\\Delta x \\le a$, $\\Delta y \\le a$, and $\\Delta z \\le a$, the particles are guaranteed to be in the same or adjacent cells. The claim that taking $a$ smaller can miss contacts is also correct, as shown by the worst-case scenario. This option is **Correct**.\n\n**C. Set $a$ equal to the mean particle diameter, $a = 2 \\langle r \\rangle$, to balance accuracy and cost on average.**\nThe use of a mean value, $\\langle r \\rangle$, is incorrect for establishing a strict guarantee. In any non-monodisperse system, $r_{\\max} > \\langle r \\rangle$. Thus, this choice implies $a = 2 \\langle r \\rangle < 2 r_{\\max}$. This fails to handle the worst-case scenario of two large particles in contact and can lead to missed interactions. The problem demands a guarantee, not an average-case performance. Therefore, this option is **Incorrect**.\n\n**D. Set $a$ equal to the geometric mean diameter, $a = 2 \\sqrt{r_{\\min} r_{\\max}}$, because it bounds most pairwise center separations.**\nSimilar to the arithmetic mean, the geometric mean provides a measure of central tendency. For $r_{\\min} < r_{\\max}$, we have $\\sqrt{r_{\\min} r_{\\max}} < r_{\\max}$. This implies $a = 2 \\sqrt{r_{\\min} r_{\\max}} < 2 r_{\\max}$, which is an insufficient condition. A guarantee must cover all cases, not \"most\" cases. The worst case of two particles of radius $r_{\\max}$ in contact would not be handled correctly. Therefore, this option is **Incorrect**.", "answer": "$$\\boxed{B}$$", "id": "2416939"}, {"introduction": "A common optimization is to not just find neighbors, but to store them in a 'Verlet list' and reuse it for several timesteps. This practice [@problem_id:2416999] delves into the crucial trade-off between this performance gain and the physical accuracy of your simulation. By modeling and calculating the systematic error introduced in the pressure due to a 'stale' list, you will gain a quantitative understanding of the consequences of this powerful optimization technique.", "problem": "You will analyze and quantify the systematic error in the instantaneous pressure of a Lennard–Jones fluid computed in a Molecular Dynamics (MD) simulation when the Verlet neighbor list is not updated for $k$ timesteps. The analysis must be implemented as a complete program that produces the requested numerical outputs. Work in reduced Lennard–Jones units with $m = 1$, $k_{\\mathrm{B}} = 1$, $\\epsilon = 1$, and $\\sigma = 1$, so that distances are expressed in units of $\\sigma$, energy in units of $\\epsilon$, time in units of $\\sqrt{m \\sigma^2 / \\epsilon}$, and pressure in units of $\\epsilon / \\sigma^3$.\n\nUse the following physically justified base concepts and definitions.\n\n- The instantaneous pressure of a classical particle system in a cubic periodic box of volume $V$ with number density $\\rho = N/V$ is, from the virial expression, $P = \\rho T + \\dfrac{1}{3V} \\sum_{i<j} \\mathbf{r}_{ij} \\cdot \\mathbf{f}_{ij}$, where $\\mathbf{r}_{ij}$ is the displacement from particle $j$ to particle $i$, and $\\mathbf{f}_{ij}$ is the pair force.\n- For a homogeneous and isotropic fluid, the pairwise virial contribution can be written as a radial integral $P = \\rho T + \\dfrac{2 \\pi}{3} \\rho^2 \\int_0^{\\infty} r^3 g(r) f(r) \\, dr$, where $g(r)$ is the radial distribution function and $f(r)$ is the magnitude of the pair force along the line of centers.\n- For the Lennard–Jones $12$–$6$ interaction in reduced units, the pair potential is $u(r) = 4 \\left[ \\left( \\dfrac{1}{r} \\right)^{12} - \\left( \\dfrac{1}{r} \\right)^6 \\right]$, and the pair force magnitude along the line of centers is $f(r) = 24 \\left[ 2 \\left( \\dfrac{1}{r} \\right)^{13} - \\left( \\dfrac{1}{r} \\right)^7 \\right]$.\n- In practice, the force is truncated at a cutoff $r_c$, that is, only pair forces for $r < r_c$ contribute. A Verlet neighbor list built at some time stores neighbors up to a list radius $r_{\\mathrm{list}} = r_c + \\delta$, where $\\delta$ is the skin. The list is valid as long as the maximum single-particle displacement since the last rebuild does not exceed $\\delta/2$. Cell lists are used to achieve linear-time neighbor search but do not change the physics nor the error mechanism; they only ensure that the neighbor list construction cost scales as $\\mathcal{O}(N)$.\n\nConsider the following modeling assumptions to quantify the error introduced by delaying the neighbor list rebuild by $k$ timesteps of size $dt$.\n\n- Assume ballistic displacements over $k$ steps, bounded by the root-mean-square speed $v_{\\mathrm{rms}} = \\sqrt{3 T}$ in reduced units, so that the maximum single-particle displacement is $s_{\\max} = v_{\\mathrm{rms}} \\, k \\, dt$.\n- The neighbor list is safe if $s_{\\max} \\le \\delta/2$. If $s_{\\max} > \\delta/2$, some pairs that were beyond $r_{\\mathrm{list}}$ at the last rebuild can now lie within $r_c$ and will be missing from the computation. In the worst case of two particles moving directly toward each other, the potential relative approach is up to $2 s_{\\max}$. The thickness of the missed shell adjacent to the cutoff is therefore $s_{\\mathrm{miss}} = \\max\\{ 0, 2 s_{\\max} - \\delta \\}$.\n- Approximating the radial distribution function near the cutoff by $g(r) \\approx 1$, the signed pressure bias due to the stale list is the contribution of the missed shell adjacent to $r_c$. The computed pressure misses the contribution from $r \\in [r_c - s_{\\mathrm{miss}}, r_c]$. To avoid unphysical divergences in an extreme parameter choice, constrain the lower integration limit to $r_{\\min} = 2^{1/6}$ (the location of the Lennard–Jones potential minimum), that is, use $r_a = \\max\\{ r_c - s_{\\mathrm{miss}}, r_{\\min} \\}$. Take the truncation with no force shifting at $r_c$.\n\nYour task is to implement a program that, for each test case, does all of the following in reduced units:\n\n1. Computes $v_{\\mathrm{rms}} = \\sqrt{3 T}$ and $s_{\\max} = v_{\\mathrm{rms}} \\, k \\, dt$.\n2. Computes $s_{\\mathrm{miss}} = \\max\\{ 0, 2 s_{\\max} - \\delta \\}$.\n3. If $s_{\\mathrm{miss}} \\le 0$, returns a pressure bias of $0$. Otherwise, evaluates the signed pressure bias\n$$\n\\Delta P \\equiv P_{\\mathrm{true}} - P_{\\mathrm{computed}} = \\frac{2 \\pi}{3} \\, \\rho^2 \\int_{r_a}^{r_c} r^3 f(r) \\, dr,\n$$\nwith $r_a = \\max\\{ r_c - s_{\\mathrm{miss}}, r_{\\min} \\}$ and $f(r)$ as given above. Report $\\Delta P$ in reduced pressure units $\\epsilon/\\sigma^3$.\n\nDesign your code to handle the following test suite, each specified by the tuple $(\\rho, T, r_c, \\delta, dt, k)$:\n\n- Case $1$: $(0.8, 1.0, 2.5, 0.3, 0.001, 50)$.\n- Case $2$: $(0.8, 1.0, 2.5, 0.3, 0.005, 50)$.\n- Case $3$: $(0.6, 1.5, 2.5, 0.2, 0.004, 80)$.\n- Case $4$ (boundary safety): $(0.8, 1.0, 2.5, 0.2, 0.002309401076758503, 25)$, where $dt$ is chosen so that $2 s_{\\max} = \\delta$ exactly.\n\nAll quantities and parameters are in reduced Lennard–Jones units. Express each result as a decimal float rounded to $6$ decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$), in the order of the cases above. No input should be read, and no external files should be used. The only output should be that single line.", "solution": "The problem statement is a valid exercise in computational physics. It is scientifically grounded, well-posed, objective, and contains all necessary information to derive a unique solution for each test case. The assumptions, such as ballistic particle motion and a uniform radial distribution function near the cutoff, are standard simplifications for estimating simulation errors. We shall proceed to derive and implement the solution.\n\nThe objective is to calculate the systematic error, or signed pressure bias $\\Delta P$, that arises from not updating a Verlet neighbor list for $k$ timesteps in a Molecular Dynamics simulation of a Lennard-Jones fluid. The problem provides a model for this error based on a set of physically justified approximations.\n\nThe pressure bias $\\Delta P$ is defined as the contribution from particle pairs that enter the force cutoff radius $r_c$ during the $k$ timesteps but are not included in force calculations because the neighbor list is stale. This corresponds to the integral of the virial over a \"missed\" spherical shell. The formula provided is:\n$$\n\\Delta P = \\frac{2 \\pi}{3} \\, \\rho^2 \\int_{r_a}^{r_c} r^3 f(r) \\, dr\n$$\nHere, $\\rho$ is the number density, $f(r)$ is the magnitude of the Lennard-Jones pair force, and the integration bounds are determined by the geometry of the missed interactions.\n\nThe key steps in the calculation for each test case, specified by the parameters $(\\rho, T, r_c, \\delta, dt, k)$, are as follows:\n\n$1$. Compute the maximum single-particle displacement, $s_{\\max}$. The model assumes ballistic motion, where the maximum speed is approximated by the root-mean-square speed, $v_{\\mathrm{rms}}$. In the given reduced units ($k_{\\mathrm{B}}=1$, $m=1$), this is:\n$$\nv_{\\mathrm{rms}} = \\sqrt{3 T}\n$$\nThe maximum displacement over $k$ timesteps of duration $dt$ is then:\n$$\ns_{\\max} = v_{\\mathrm{rms}} \\cdot k \\cdot dt\n$$\n\n$2$. Compute the thickness of the missed shell, $s_{\\mathrm{miss}}$. A Verlet list is built with a skin of thickness $\\delta$, extending the search radius to $r_{\\mathrm{list}} = r_c + \\delta$. The list is considered safe as long as any single particle does not move more than $\\delta/2$. If two particles move directly towards each other, their relative displacement can be up to $2 s_{\\max}$. The region of pairs that may have been missed is a shell of thickness $2 s_{\\max} - \\delta$ just inside $r_{\\mathrm{list}}$. We are interested in those that cross into the interaction range $r < r_c$. The thickness of this missed region, adjacent to $r_c$, is therefore:\n$$\ns_{\\mathrm{miss}} = \\max\\{ 0, 2 s_{\\max} - \\delta \\}\n$$\nIf $s_{\\mathrm{miss}} = 0$, no pairs are missed, and the pressure bias $\\Delta P = 0$.\n\n$3$. Determine the integration limits. If $s_{\\mathrm{miss}} > 0$, we must evaluate the pressure integral. The upper limit is $r_c$. The lower limit, $r_a$, is the inner boundary of the missed shell, $r_c - s_{\\mathrm{miss}}$. However, an additional constraint is imposed to avoid the unphysical divergence of the force at very small separations. The lower limit is clipped at the Lennard-Jones potential minimum, $r_{\\min} = 2^{1/6} \\sigma$. In reduced units where $\\sigma=1$, $r_{\\min} = 2^{1/6}$. Thus, the lower integration bound is:\n$$\nr_a = \\max\\{ r_c - s_{\\mathrm{miss}}, 2^{1/6} \\}\n$$\n\n$4$. Evaluate the integral. The integrand involves the Lennard-Jones force, $f(r) = 24 \\left[ 2 r^{-13} - r^{-7} \\right]$. The term to integrate is $r^3 f(r)$:\n$$\nr^3 f(r) = r^3 \\cdot 24 \\left( 2r^{-13} - r^{-7} \\right) = 48r^{-10} - 24r^{-4}\n$$\nThe definite integral can be found analytically. Let $I(r_a, r_c) = \\int_{r_a}^{r_c} (48r^{-10} - 24r^{-4}) \\, dr$. The antiderivative is:\n$$\n\\int (48r^{-10} - 24r^{-4}) \\, dr = 48 \\frac{r^{-9}}{-9} - 24 \\frac{r^{-3}}{-3} + C = -\\frac{16}{3}r^{-9} + 8r^{-3} + C\n$$\nEvaluating the definite integral from $r_a$ to $r_c$:\n$$\nI(r_a, r_c) = \\left[ 8r^{-3} - \\frac{16}{3}r^{-9} \\right]_{r_a}^{r_c} = \\left( 8r_c^{-3} - \\frac{16}{3}r_c^{-9} \\right) - \\left( 8r_a^{-3} - \\frac{16}{3}r_a^{-9} \\right)\n$$\n\n$5$. Calculate the final pressure bias, $\\Delta P$. By substituting the value of the integral back into the expression for $\\Delta P$:\n$$\n\\Delta P = \\frac{2 \\pi}{3} \\rho^2 \\cdot I(r_a, r_c)\n$$\nThis procedure is applied to each test case. The model assumes $g(r) \\approx 1$ in the missed shell, which is a reasonable approximation for estimating the order of magnitude of the error. The force is attractive for $r > 2^{1/6}$, so $f(r) < 0$. We therefore expect the missed contribution $\\Delta P$ to be negative, indicating that the computed pressure is artificially high.\n\nFor Case $1$: $(\\rho, T, r_c, \\delta, dt, k) = (0.8, 1.0, 2.5, 0.3, 0.001, 50)$.\n$v_{\\mathrm{rms}} = \\sqrt{3 \\cdot 1.0} = \\sqrt{3}$.\n$s_{\\max} = \\sqrt{3} \\cdot 50 \\cdot 0.001 = 0.05\\sqrt{3} \\approx 0.0866$.\n$2s_{\\max} \\approx 0.1732$, which is less than $\\delta = 0.3$.\nThus, $s_{\\mathrm{miss}} = 0$ and $\\Delta P = 0$.\n\nFor Case $4$: $(\\rho, T, r_c, \\delta, dt, k) = (0.8, 1.0, 2.5, 0.2, 0.002309401076758503, 25)$.\nThe timestep $dt$ is specifically chosen such that $2 s_{\\max} = \\delta$.\n$v_{\\mathrm{rms}} = \\sqrt{3}$.\n$s_{\\max} = \\sqrt{3} \\cdot 25 \\cdot \\frac{0.2}{2 \\sqrt{3} \\cdot 25} = 0.1$.\n$2s_{\\max} = 0.2 = \\delta$.\nTherefore, $s_{\\mathrm{miss}} = \\max\\{0, 0.2 - 0.2\\} = 0$, and $\\Delta P = 0$.\n\nFor the other cases where $s_{\\mathrm{miss}} > 0$, the full integral calculation is performed as outlined above. The final implementation will execute these steps for all provided test cases and format the results as requested.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Calculates the systematic pressure error in an MD simulation\n    due to a stale Verlet neighbor list for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (rho, T, r_c, delta, dt, k)\n    test_cases = [\n        (0.8, 1.0, 2.5, 0.3, 0.001, 50),\n        (0.8, 1.0, 2.5, 0.3, 0.005, 50),\n        (0.6, 1.5, 2.5, 0.2, 0.004, 80),\n        (0.8, 1.0, 2.5, 0.2, 0.002309401076758503, 25),\n    ]\n\n    results = []\n    \n    # Lennard-Jones potential minimum location in reduced units (sigma=1)\n    r_min = 2**(1/6)\n\n    for case in test_cases:\n        rho, T, r_c, delta, dt, k = case\n\n        # 1. Compute v_rms and s_max\n        # In reduced units, k_B = 1 and m = 1\n        v_rms = np.sqrt(3 * T)\n        s_max = v_rms * k * dt\n\n        # 2. Compute s_miss\n        # This is the thickness of the shell of missed pair interactions.\n        s_miss = max(0, 2 * s_max - delta)\n\n        # If the neighbor list is safe, the pressure bias is 0.\n        if s_miss = 0:\n            results.append(0.0)\n            continue\n\n        # 3. Evaluate the signed pressure bias integral\n        \n        # Lower integration limit, clipped at the LJ potential minimum\n        r_a = max(r_c - s_miss, r_min)\n        \n        # The integral is evaluated analytically.\n        # The indefinite integral of r^3 * f(r) is:\n        # F(r) = 8*r**(-3) - (16/3)*r**(-9)\n        def integral_antiderivative(r):\n            r_inv3 = r**(-3)\n            r_inv9 = r_inv3**3  # More stable than r**(-9)\n            return 8 * r_inv3 - (16/3) * r_inv9\n\n        # Evaluate the definite integral from r_a to r_c\n        integral_value = integral_antiderivative(r_c) - integral_antiderivative(r_a)\n        \n        # The pressure bias is proportional to the integral value.\n        # Prefactor is (2 * pi / 3) * rho^2, assuming g(r)=1.\n        delta_P = (2 * np.pi / 3) * rho**2 * integral_value\n        \n        results.append(delta_P)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to 6 decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2416999"}, {"introduction": "Modern simulations achieve massive scale by distributing work across many processors, a strategy known as parallel computing. This coding practice [@problem_id:2416963] introduces the fundamental logic of such an approach through domain decomposition. You will implement a pair-counting algorithm that uses 'ghost regions' to correctly handle interactions across processor boundaries, a cornerstone concept for writing efficient and correct parallel simulation codes.", "problem": "You are given a two-dimensional periodic domain of side lengths $L_x$ and $L_y$ containing $N$ point particles at fixed positions $\\{(x_i,y_i)\\}_{i=1}^N$. Two particles $i$ and $j$ form an interacting pair if and only if their Euclidean distance under the minimum-image convention on the periodic domain is less than or equal to a prescribed cutoff radius $r_c$. The minimum-image distance is defined as follows. For any coordinate difference $\\Delta x = x_j - x_i$, the periodic difference is $\\Delta x' = \\Delta x - \\operatorname{round}\\left(\\frac{\\Delta x}{L_x}\\right)L_x$. Similarly, $\\Delta y' = y_j - y_i - \\operatorname{round}\\left(\\frac{y_j - y_i}{L_y}\\right)L_y$. The distance is $d_{ij} = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2}$. A unique interacting pair is any unordered index pair $(i,j)$ with $1 \\le i  j \\le N$ satisfying $d_{ij} \\le r_c$.\n\nThe domain is logically decomposed into $P_x$ non-overlapping subdomains by partitioning the interval $[0,L_x)$ into equal-width strips of width $L_x/P_x$ along the $x$-direction, with periodic boundary conditions across $x=0$ and $x=L_x$. The $k$-th subdomain for $k \\in \\{0,1,\\dots,P_x-1\\}$ has interval $[k L_x/P_x,(k+1)L_x/P_x)$ along $x$ and the full interval $[0,L_y)$ along $y$. Each subdomain augments its local particles by a ghost region of width $r_c$ on both the left and right $x$ boundaries, importing any particles whose periodic $x$-coordinate lies within a distance $r_c$ of either boundary. Interacting pairs must be enumerated so that each unordered pair $(i,j)$ with $1 \\le i  j \\le N$ and $d_{ij} \\le r_c$ is counted exactly once globally, notwithstanding the duplication introduced by the ghost regions.\n\nYour program must, for each test case below, compute the total number of unique interacting pairs across the entire domain using an algorithm that respects the subdomain decomposition and ghost regions described above. All coordinates are in the same arbitrary length unit, and $r_c$, $L_x$, and $L_y$ are in that same unit. The program must treat all comparisons to the cutoff using the criterion $d_{ij} \\le r_c$.\n\nTest suite to be used by your program:\n- Test case $1$ (general case): $L_x = 10.0$, $L_y = 10.0$, $r_c = 2.1$, $P_x = 3$, with particle positions given by the ordered list\n$\\left[(1.0,1.0),(2.5,1.0),(3.9,1.0),(4.8,9.5),(4.8,0.6),(9.6,5.0),(0.4,5.0),(6.7,5.0)\\right]$.\n- Test case $2$ (boundary and equality case): $L_x = 8.0$, $L_y = 8.0$, $r_c = 2.0$, $P_x = 2$, with particle positions\n$\\left[(0.5,0.5),(7.5,0.5),(4.0,4.0),(6.0,4.0)\\right]$.\n- Test case $3$ (sparse case with empty subdomains): $L_x = 5.0$, $L_y = 5.0$, $r_c = 0.9$, $P_x = 4$, with particle positions\n$\\left[(0.2,0.2),(2.6,4.7),(4.8,2.5)\\right]$.\n\nFinal output format: Your program should produce a single line containing the results for all three test cases as a comma-separated list enclosed in square brackets, in the same order as the test cases above. Each result must be an integer equal to the number of unique interacting pairs, so the output must have the form $[\\text{n}_1,\\text{n}_2,\\text{n}_3]$ where each $\\text{n}_k$ is an integer.", "solution": "The problem presented is a valid computational physics exercise. It is scientifically grounded, well-posed, and objective. It describes a standard domain decomposition technique used in molecular simulations to efficiently compute short-range interactions. All parameters and conditions are specified, permitting a unique and verifiable solution. We will proceed with the solution.\n\nThe problem requires us to compute the total number of unique interacting particle pairs within a two-dimensional periodic domain. The core of the task is to implement a parallel computing strategy based on domain decomposition, where the domain is partitioned into vertical strips (subdomains). To correctly account for interactions across subdomain boundaries, each subdomain must consider not only its \"local\" particles but also \"ghost\" particles from neighboring regions.\n\nThe fundamental principles underlying the solution are as follows:\n\n1.  **Minimum Image Convention (MIC)**: In a periodic system, a particle interacts with the closest periodic image of every other particle. The distance calculation must account for the periodic boundaries. For a particle pair with coordinate differences $\\Delta x$ and $\\Delta y$ in a domain of size $L_x \\times L_y$, the MIC stipulates that the effective separation vector components are $\\Delta x' = \\Delta x - L_x \\cdot \\operatorname{round}(\\frac{\\Delta x}{L_x})$ and $\\Delta y' = \\Delta y - L_y \\cdot \\operatorname{round}(\\frac{\\Delta y}{L_y})$. The distance is then $d_{ij} = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2}$. An interaction occurs if $d_{ij} \\le r_c$, where $r_c$ is the cutoff radius. For computational efficiency, we will compare squared distances: $d_{ij}^2 \\le r_c^2$.\n\n2.  **Domain Decomposition**: The global domain is decomposed into $P_x$ subdomains along the $x$-axis. Each particle is uniquely assigned to a \"home\" or \"local\" subdomain based on its $x$-coordinate. This assignment is exclusive; particle $i$ with coordinate $x_i$ belongs to subdomain $k$ if $x_i \\in [k \\cdot L_x/P_x, (k+1) \\cdot L_x/P_x)$.\n\n3.  **Ghost Regions**: For a particle $i$ residing in subdomain $k$, any interacting partner $j$ must lie within a distance $r_c$. This implies their periodic $x$-distance is at most $r_c$. Therefore, to find all pairs involving its local particles, subdomain $k$ only needs to import copies of particles (ghosts) that are within a \"ghost layer\" of width $r_c$ from its own boundaries.\n\n4.  **Unique Pair Counting**: To prevent double-counting of pairs (e.g., subdomain $k$ counting $(i, j)$ and subdomain $m$ also counting $(j, i)$), a strict counting protocol is required. A common and correct convention is to assign the responsibility of counting a pair $(i, j)$ to the subdomain that \"owns\" the particle with the smaller index. The algorithm will be structured as follows: a subdomain $k$ iterates through its local particles $i$. For each such $i$, it checks for interactions with all other particles $j$ (both local and ghost) in its extended region, but only counts the pair if the original particle indices satisfy $i  j$. This guarantees that each unique pair $(i, j)$ is considered for counting exactly once, by the owner of particle $i$.\n\nThe algorithm proceeds step-by-step for each test case as follows:\n\n1.  **Initialization**: For a given test case with parameters $L_x, L_y, r_c, P_x$ and $N$ particle positions, we initialize the total pair count to $0$. We compute the squared cutoff radius $r_c^2$ and the width of each subdomain, $W = L_x / P_x$.\n\n2.  **Particle Ownership**: Each of the $N$ particles is assigned to an owner subdomain. For a particle $i$ at position $(x_i, y_i)$, its owner subdomain index $k$ is calculated as $k = \\lfloor x_i / W \\rfloor$. We must ensure $k$ is clipped to the range $[0, P_x-1]$.\n\n3.  **Subdomain Iteration**: We iterate through each subdomain $k$ from $0$ to $P_x-1$.\n\n4.  **Identify Local and Ghost Particles**: For the current subdomain $k$, we first identify the set of indices $L_k$ of its local particles. Then, we construct a larger set of indices $S_k$ that includes all particles in the subdomain's extended region. The extended region for subdomain $k$, which covers $[k \\cdot W, (k+1) \\cdot W)$, is given by $[k \\cdot W - r_c, (k+1) \\cdot W + r_c)$ along the $x$-axis. A particle $j$ at position $x_j$ belongs to this extended region if any of its periodic images, $x_j + m \\cdot L_x$ for $m \\in \\{-1, 0, 1\\}$, falls within this interval.\n\n5.  **Pair Counting**: For the current subdomain $k$, we iterate through each of its local particles $i \\in L_k$. For each $i$, we then iterate through all particles $j \\in S_k$ such that the index condition $i  j$ holds. For each such pair $(i, j)$, we calculate the squared MIC distance $d_{ij}^2$. If $d_{ij}^2 \\le r_c^2$, we increment the total pair count.\n\n6.  **Final Result**: After iterating through all subdomains, the accumulated total pair count is the final answer for the test case. This process is repeated for all test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(Lx, Ly, rc, Px, positions):\n    \"\"\"\n    Computes the number of interacting pairs for a single test case\n    using a domain decomposition algorithm.\n    \"\"\"\n    particles = np.array(positions, dtype=np.float64)\n    N = len(particles)\n    if N == 0:\n        return 0\n        \n    rc_sq = rc**2\n    subdomain_width = Lx / Px\n\n    # Assign each particle to an owner subdomain based on its x-coordinate.\n    # The interval for subdomain k is [k*width, (k+1)*width).\n    # np.floor(x / width) correctly assigns particles to subdomains.\n    # We clip to handle the case where a particle might be exactly at x=Lx.\n    owner = np.floor(particles[:, 0] / subdomain_width).astype(int)\n    owner = np.clip(owner, 0, Px - 1)\n\n    total_pairs = 0\n    box_dims = np.array([Lx, Ly])\n\n    def mic_dist_sq(p1, p2):\n        \"\"\"Calculates the squared Euclidean distance under the Minimum Image Convention.\"\"\"\n        delta = p2 - p1\n        # This implements delta' = delta - L * round(delta/L)\n        delta -= box_dims * np.round(delta / box_dims)\n        return np.dot(delta, delta)\n\n    # Iterate through each subdomain\n    for k in range(Px):\n        # Identify particles local to this subdomain\n        local_indices = np.where(owner == k)[0]\n        \n        # If the subdomain is empty, no pairs will be counted by it.\n        if len(local_indices) == 0:\n            continue\n\n        # Identify all particles in the extended subdomain (local + ghosts)\n        # The extended region for subdomain k is [xmin - rc, xmax + rc).\n        xmin = k * subdomain_width\n        xmax = (k + 1) * subdomain_width\n        ext_min = xmin - rc\n        ext_max = xmax + rc\n\n        subdomain_particle_indices = []\n        for j in range(N):\n            x_j = particles[j, 0]\n            # Check if particle j or its periodic images fall in the extended region.\n            # Checking images at m=-1, 0, 1 is sufficient for rc  Lx/2.\n            if (ext_min = x_j  ext_max) or \\\n               (ext_min = x_j + Lx  ext_max) or \\\n               (ext_min = x_j - Lx  ext_max):\n                subdomain_particle_indices.append(j)\n        \n        # Count pairs according to the rule:\n        # Particle i must be local to subdomain k.\n        # Particle j can be local or ghost.\n        # The index condition i  j ensures each pair is counted only once.\n        for i in local_indices:\n            for j in subdomain_particle_indices:\n                if i  j:\n                    if mic_dist_sq(particles[i], particles[j]) = rc_sq:\n                        total_pairs += 1\n\n    return total_pairs\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"Lx\": 10.0, \"Ly\": 10.0, \"rc\": 2.1, \"Px\": 3,\n            \"positions\": [(1.0, 1.0), (2.5, 1.0), (3.9, 1.0), (4.8, 9.5), \n                          (4.8, 0.6), (9.6, 5.0), (0.4, 5.0), (6.7, 5.0)]\n        },\n        # Test case 2\n        {\n            \"Lx\": 8.0, \"Ly\": 8.0, \"rc\": 2.0, \"Px\": 2,\n            \"positions\": [(0.5, 0.5), (7.5, 0.5), (4.0, 4.0), (6.0, 4.0)]\n        },\n        # Test case 3\n        {\n            \"Lx\": 5.0, \"Ly\": 5.0, \"rc\": 0.9, \"Px\": 4,\n            \"positions\": [(0.2, 0.2), (2.6, 4.7), (4.8, 2.5)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        num_pairs = solve_case(\n            case[\"Lx\"], case[\"Ly\"], case[\"rc\"], case[\"Px\"], case[\"positions\"]\n        )\n        results.append(num_pairs)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2416963"}]}