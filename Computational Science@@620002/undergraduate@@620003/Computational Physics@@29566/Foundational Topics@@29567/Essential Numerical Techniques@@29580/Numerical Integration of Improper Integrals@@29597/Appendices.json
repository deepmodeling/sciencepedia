{"hands_on_practices": [{"introduction": "A crucial test for any numerical method is its ability to reproduce fundamental physical principles, such as conservation laws. In this practice, you will verify the conservation of total probability for the diffusion process by integrating its fundamental solution, or Green's function, over all space [@problem_id:2419418]. This exercise provides essential experience with integrating smooth, rapidly decaying functions over infinite domains in one and two dimensions, showcasing the powerful technique of simplifying multidimensional integrals via a change to polar coordinates.", "problem": "Consider the fundamental solution (Green’s function) of the diffusion (heat) equation in one spatial dimension and in two spatial dimensions. For a positive diffusion coefficient $D$ and time $t>0$, the one-dimensional Green’s function is\n$$\nG_{1}(x,t;D)=\\frac{1}{\\sqrt{4\\pi D t}}\\exp\\!\\left(-\\frac{x^{2}}{4Dt}\\right),\n$$\ndefined for $x\\in\\mathbb{R}$, and the two-dimensional Green’s function is\n$$\nG_{2}(\\mathbf{r},t;D)=\\frac{1}{4\\pi D t}\\exp\\!\\left(-\\frac{\\|\\mathbf{r}\\|^{2}}{4Dt}\\right),\n$$\ndefined for $\\mathbf{r}\\in\\mathbb{R}^{2}$. The mathematical statement of conservation of total “energy” (total probability mass) for these fundamental solutions is that the corresponding improper integrals over the entire spatial domain equal $1$, that is,\n$$\nI_{1}(D,t)=\\int_{-\\infty}^{\\infty} G_{1}(x,t;D)\\,dx,\n\\quad\nI_{2}(D,t)=\\iint_{\\mathbb{R}^{2}} G_{2}(\\mathbf{r},t;D)\\,d^{2}\\mathbf{r},\n$$\nand conservation requires $I_{1}(D,t)=1$ and $I_{2}(D,t)=1$ for all $D>0$ and $t>0$.\n\nYour task is to write a complete, runnable program that numerically evaluates these improper integrals for given parameter values $(D,t)$ in one spatial dimension and in two spatial dimensions, respectively, and returns the computed values. The program must compute $I_{1}(D,t)$ and $I_{2}(D,t)$ by numerical integration over the full domains $\\mathbb{R}$ and $\\mathbb{R}^{2}$, without using any closed-form antiderivatives.\n\nTest suite:\n- Case $1$ (one-dimensional): $D=0.5$, $t=2.0$; compute $I_{1}(D,t)$.\n- Case $2$ (two-dimensional): $D=1.0$, $t=0.1$; compute $I_{2}(D,t)$.\n- Case $3$ (two-dimensional, small time): $D=1.0$, $t=10^{-4}$; compute $I_{2}(D,t)$.\n- Case $4$ (one-dimensional, large time and diffusion): $D=3.0$, $t=100.0$; compute $I_{1}(D,t)$.\n- Case $5$ (two-dimensional, small diffusion): $D=10^{-3}$, $t=5.0$; compute $I_{2}(D,t)$.\n\nYour program must produce a single line of output containing the results, in the same order as the cases above, as a comma-separated list enclosed in square brackets. Each result must be a floating-point number rounded to exactly $10$ decimal places. For example, the output must have the form\n$[r_{1},r_{2},r_{3},r_{4},r_{5}]$,\nwhere $r_{k}$ is the rounded numerical value for case $k$.", "solution": "The problem requires the numerical evaluation of two improper integrals, $I_1$ and $I_2$, which represent the total probability mass for the fundamental solutions of the one- and two-dimensional diffusion equations, respectively. This problem is well-posed, scientifically sound, and complete. The conservation law inherent in the diffusion process dictates that the analytical value of these integrals is exactly $1$ for any valid parameters $D>0$ and $t>0$. Our task is to verify this property numerically.\n\nThe numerical approach will rely on the `scipy.integrate.quad` function, which implements a robust adaptive quadrature algorithm suitable for improper integrals.\n\nFor the $1$-dimensional case, the integral to be computed is\n$$\nI_{1}(D,t)=\\int_{-\\infty}^{\\infty} G_{1}(x,t;D)\\,dx = \\int_{-\\infty}^{\\infty} \\frac{1}{\\sqrt{4\\pi D t}}\\exp\\!\\left(-\\frac{x^{2}}{4Dt}\\right) dx\n$$\nThis integral is computed directly by passing the integrand $G_1(x, t; D)$ and the domain $(-\\infty, \\infty)$ to the numerical quadrature routine.\n\nFor the $2$-dimensional case, direct numerical integration of\n$$\nI_{2}(D,t)=\\iint_{\\mathbb{R}^{2}} G_{2}(\\mathbf{r},t;D)\\,d^{2}\\mathbf{r} = \\iint_{\\mathbb{R}^{2}} \\frac{1}{4\\pi D t}\\exp\\!\\left(-\\frac{\\|\\mathbf{r}\\|^{2}}{4Dt}\\right) d^{2}\\mathbf{r}\n$$\nis inefficient. A superior method is to transform the integral to polar coordinates $(r, \\theta)$, where $\\|\\mathbf{r}\\| = r$ and the area element is $d^{2}\\mathbf{r} = r\\,dr\\,d\\theta$. The integration domain $\\mathbb{R}^2$ corresponds to $r \\in [0, \\infty)$ and $\\theta \\in [0, 2\\pi)$. The integral transforms to\n$$\nI_{2}(D, t) = \\int_0^{2\\pi} \\int_0^{\\infty} \\frac{1}{4\\pi D t}\\exp\\left(-\\frac{r^2}{4Dt}\\right) r\\,dr\\,d\\theta\n$$\nAs the integrand lacks dependence on $\\theta$, the angular integration is trivial and yields a factor of $2\\pi$. This reduces the problem to a single $1$-dimensional integral:\n$$\nI_{2}(D, t) = \\frac{2\\pi}{4\\pi D t} \\int_0^{\\infty} r \\exp\\left(-\\frac{r^2}{4Dt}\\right) dr = \\frac{1}{2Dt} \\int_0^{\\infty} r \\exp\\left(-\\frac{r^2}{4Dt}\\right) dr\n$$\nThis simplified integral over the domain $[0, \\infty)$ is then computed numerically with high efficiency and accuracy.\n\nThe program will process each of the $5$ test cases provided:\n1.  $1\\text{D}$: $D=0.5$, $t=2.0$\n2.  $2\\text{D}$: $D=1.0$, $t=0.1$\n3.  $2\\text{D}$: $D=1.0$, $t=10^{-4}$\n4.  $1\\text{D}$: $D=3.0$, $t=100.0$\n5.  $2\\text{D}$: $D=10^{-3}$, $t=5.0$\n\nIt will select the appropriate integration method ($1$D or the polar-reduced $2$D) for each case. The final numerical results will be rounded to exactly $10$ decimal places and presented in the specified list format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Numerically evaluates the improper integrals for the Green's functions\n    of the 1D and 2D diffusion equations for specified test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple contains: (dimensionality, D, t)\n    test_cases = [\n        (1, 0.5, 2.0),\n        (2, 1.0, 0.1),\n        (2, 1.0, 1e-4),\n        (1, 3.0, 100.0),\n        (2, 10**-3, 5.0)\n    ]\n\n    # Define the integrand for the 1D case, G_1(x, t; D).\n    def g1_integrand(x, D, t):\n        \"\"\"Integrand for the 1D Green's function G_1.\"\"\"\n        denominator = 4.0 * D * t\n        prefactor = 1.0 / np.sqrt(np.pi * denominator)\n        return prefactor * np.exp(-x**2 / denominator)\n\n    # Define the integrand for the 2D case after reduction to 1D via polar coordinates.\n    # This corresponds to f(r) = (r / (2*D*t)) * exp(-r^2 / (4*D*t)).\n    def g2_integrand_polar(r, D, t):\n        \"\"\"Integrand for the 2D Green's function in polar coordinates.\"\"\"\n        denominator = 4.0 * D * t\n        prefactor = r / (2.0 * D * t)\n        return prefactor * np.exp(-r**2 / denominator)\n\n    results = []\n    for case in test_cases:\n        dim, D, t = case\n        \n        integral_value = 0.0\n        if dim == 1:\n            # Perform the 1D improper integral from -inf to +inf.\n            integral_value, _ = quad(g1_integrand, -np.inf, np.inf, args=(D, t))\n        else:  # dim == 2\n            # Perform the 1D improper integral from 0 to +inf for the polar-reduced problem.\n            integral_value, _ = quad(g2_integrand_polar, 0, np.inf, args=(D, t))\n        \n        results.append(integral_value)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to 10 decimal places.\n    print(f\"[{','.join(f'{res:.10f}' for res in results)}]\")\n\nsolve()\n```", "id": "2419418"}, {"introduction": "Many integrals in science and statistics feature integrable singularities, where the function asymptotically approaches infinity at a point but the area under the curve remains finite. This exercise tackles such a case by asking you to compute the expectation value $\\mathbb{E}[\\ln X]$ for a variable $X$ following a Gamma distribution, which involves an integrand with a logarithmic singularity at the origin [@problem_id:2419387]. This practice demonstrates how modern quadrature routines can handle certain well-behaved singularities and connects the numerical result to established special functions, providing a solid method for verification.", "problem": "You are given a dimensionless random variable $X$ distributed according to a Gamma distribution with shape parameter $k&gt;0$ and unit scale. The probability density function is\n$$\nf(x;k)=\\frac{x^{k-1}e^{-x}}{\\Gamma(k)}, \\quad x&gt;0,\n$$\nwhere $\\Gamma(k)$ is the Gamma function defined by\n$$\n\\Gamma(k)=\\int_0^{\\infty} x^{k-1}e^{-x}\\,dx.\n$$\nYour task is to write a complete program that numerically evaluates the expectation\n$$\n\\mathbb{E}[\\ln X]=\\int_0^{\\infty} \\ln(x)\\, f(x;k)\\,dx\n$$\nfor each specified value of $k$. This integral is improper due to the infinite domain and the logarithmic singularity at $x=0$. Compute each value to an absolute numerical error not exceeding $10^{-10}$ and then round the final reported value to $12$ decimal places.\n\nTest suite (shape parameters $k$ to evaluate):\n- $k=\\tfrac{1}{2}$\n- $k=1$\n- $k=\\tfrac{3}{2}$\n- $k=10$\n\nFinal output format:\nYour program should produce a single line of output containing the results, in the same order as listed above, as a comma-separated list enclosed in square brackets. Each entry must be rounded to $12$ decimal places. For example, an output with four results should look like\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4].\n$$", "solution": "The problem requires the numerical computation of the expectation value $\\mathbb{E}[\\ln X]$, where $X$ is a random variable following a Gamma distribution with a given shape parameter $k>0$ and a unit scale parameter. The probability density function (PDF) is\n$$\nf(x;k) = \\frac{x^{k-1}e^{-x}}{\\Gamma(k)}, \\quad x > 0.\n$$\nThe expectation is defined by the integral\n$$\n\\mathbb{E}[\\ln X] = \\int_0^{\\infty} \\ln(x) f(x;k) \\,dx = \\frac{1}{\\Gamma(k)} \\int_0^{\\infty} \\ln(x) x^{k-1} e^{-x} \\,dx.\n$$\nThis integral must be evaluated for the specified values of $k$: $k=\\frac{1}{2}$, $k=1$, $k=\\frac{3}{2}$, and $k=10$.\n\nFirst, we analyze the integral. It is an improper integral due to two distinct features: the infinite upper limit of integration and a potential singularity at the lower limit, $x=0$. The behavior of the integrand's numerator, which we denote as $g(x;k) = \\ln(x) x^{k-1} e^{-x}$, near $x=0$ is dominated by the term $\\ln(x) x^{k-1}$. The integral $\\int_0^{\\epsilon} \\ln(x) x^{k-1} dx$ for some small $\\epsilon > 0$ is known to converge if and only if the power of $x$ is greater than $-1$, i.e., $k-1 > -1$, which simplifies to $k>0$. As the problem statement guarantees $k>0$, the singularity at $x=0$ is integrable. At the upper limit, as $x \\to \\infty$, the exponential term $e^{-x}$ decays to zero faster than any polynomial or logarithmic term $\\ln(x) x^{k-1}$ can grow. This ensures the convergence of the integral over the interval $[0, \\infty)$.\n\nThe problem is therefore a well-posed task in numerical integration. A robust numerical quadrature algorithm is necessary to handle these properties with the required accuracy. The `scipy.integrate.quad` function, a Python interface to the FORTRAN library QUADPACK, is exceptionally well-suited for this purpose. It is specifically designed to compute definite integrals, including those with infinite limits and integrable singularities at the boundaries of the integration interval.\n\nThe computational strategy is as follows:\n$1$. For each given value of $k$, we define the integrand corresponding to the numerator of the expectation formula, $I_{\\text{num}}(x, k) = \\ln(x) x^{k-1} e^{-x}$. It is numerically more stable to integrate this function first and then perform the division by $\\Gamma(k)$.\n$2$. We use `scipy.integrate.quad` to compute the value of the integral $J(k) = \\int_0^{\\infty} I_{\\text{num}}(x, k) \\,dx$. To ensure the final absolute error does not exceed the required tolerance of $10^{-10}$, a stricter tolerance, such as `epsabs`=$10^{-13}$, is specified for the `quad` function.\n$3$. We compute the value of the Gamma function, $\\Gamma(k)$, using the highly accurate implementation provided by `scipy.special.gamma`.\n$4$. The final expectation value is obtained by the division $\\mathbb{E}[\\ln X] = \\frac{J(k)}{\\Gamma(k)}$.\n\nIt is an established mathematical identity that this expectation is equal to the digamma function, $\\psi(k)$, which is defined as the logarithmic derivative of the Gamma function:\n$$\n\\psi(k) = \\frac{d}{dk} \\ln\\Gamma(k) = \\frac{\\Gamma'(k)}{\\Gamma(k)}.\n$$\nThis identity is derived by differentiating the integral definition of $\\Gamma(k)$ with respect to $k$, an operation justified by the Dominated Convergence Theorem:\n$$\n\\Gamma'(k) = \\frac{d}{dk} \\int_0^{\\infty} x^{k-1} e^{-x} \\,dx = \\int_0^{\\infty} \\frac{\\partial}{\\partial k} (x^{k-1} e^{-x}) \\,dx = \\int_0^{\\infty} (\\ln x) x^{k-1} e^{-x} \\,dx.\n$$\nDividing this result by $\\Gamma(k)$ confirms that $\\mathbb{E}[\\ln X] = \\psi(k)$. This analytical solution, available in `scipy.special.psi`, serves as a definitive benchmark against which the correctness of our numerical integration can be verified. For instance, for $k=1$, the expectation is $\\psi(1) = -\\gamma$, where $\\gamma \\approx 0.5772156649$ is the Euler-Mascheroni constant. For $k=\\frac{1}{2}$, the expectation is $\\psi(\\frac{1}{2}) = -\\gamma - 2\\ln 2 \\approx -1.9635100260$. The developed program must reproduce these values with high precision by direct integration, not by merely calling the pre-defined `psi` function.\n\nThe program will iterate through the list of test cases $k \\in \\{\\frac{1}{2}, 1, \\frac{3}{2}, 10\\}$. For each $k$, it will perform the numerical integration as outlined. The final computed value for each case will be rounded to $12$ decimal places, as specified in the problem statement, before being formatted for output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\nfrom scipy import special\n\ndef solve():\n    \"\"\"\n    Computes the expectation E[ln X] for a Gamma-distributed random variable X\n    with shape parameter k and unit scale.\n    \"\"\"\n    # Define the test cases for the shape parameter k.\n    test_cases = [0.5, 1.0, 1.5, 10.0]\n\n    results = []\n    \n    # The expectation is given by the integral of ln(x) * f(x;k) over (0, inf),\n    # where f(x;k) is the Gamma PDF. This is equivalent to:\n    # (1 / Gamma(k)) * integral[ln(x) * x**(k-1) * exp(-x) dx].\n    # We will numerically integrate the numerator and then divide by Gamma(k).\n\n    for k in test_cases:\n        # Define the numerator of the integrand as a function of x and k.\n        # This function is passed to the quadrature routine.\n        def numerator_integrand(x, k_val):\n            # This expression is singular at x=0 for k<=1, but the singularity\n            # is integrable, and `scipy.integrate.quad` is designed to handle this.\n            return np.log(x) * x**(k_val - 1) * np.exp(-x)\n            \n        # Compute the integral of the numerator from 0 to infinity.\n        # A high precision is requested for the integration routine to ensure\n        # the final absolute error is below the required 1e-10.\n        integral_numerator, _ = integrate.quad(\n            numerator_integrand,\n            0,\n            np.inf,\n            args=(k,),\n            epsabs=1e-13,\n            epsrel=1e-13\n        )\n        \n        # Compute the value of the Gamma function for the denominator.\n        gamma_val = special.gamma(k)\n        \n        # Calculate the final expectation value.\n        expectation = integral_numerator / gamma_val\n        \n        # Round the result to 12 decimal places as per the problem specification.\n        rounded_result = round(expectation, 12)\n        results.append(rounded_result)\n        \n    # The final output must be a single line containing a comma-separated\n    # list of results enclosed in square brackets.\n    # The str() conversion of the rounded floats provides the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2419387"}, {"introduction": "While some singularities can be handled automatically by library functions, stronger algebraic singularities often require direct intervention. In this capstone practice, you will learn a powerful and general technique: resolving a singularity through a coordinate transformation [@problem_id:2419378]. You will derive and implement a power-law change of variables that transforms an integrand with a singularity of the form $(x-a)^{\\alpha-1}$ into a regular, smooth function, which can then be efficiently evaluated using a standard quadrature routine.", "problem": "Design and implement a complete, runnable program that numerically evaluates one-dimensional improper integrals with algebraic endpoint singularities by using an adaptive quadrature scheme combined with a coordinate transformation that removes the singularity. Begin from the definition of an improper integral and the change-of-variables rule for integrals. The class of integrals to be addressed is\n$$\nI = \\int_{a}^{b} \\left(x - a\\right)^{\\alpha_L - 1} \\left(b - x\\right)^{\\alpha_R - 1} \\,\\psi(x)\\, dx,\n$$\nwhere $a \\lt b$ are finite real numbers, $\\alpha_L \\gt 0$ and $\\alpha_R \\gt 0$ are given exponents that ensure integrability at the endpoints, and $\\psi(x)$ is a given smooth function that is finite and continuous on $[a,b]$. Your task is to:\n- derive and implement a smooth, bijective change of variables that regularizes the integrand at any endpoint with $\\alpha \\neq 1$, so that the transformed integrand is finite at the transformed interval endpoints;\n- implement an adaptive quadrature with local error control that recursively subdivides the transformed integration domain until a user-specified absolute tolerance is met;\n- combine the above to handle three cases: only left endpoint singular, only right endpoint singular, and singular at both endpoints. If both endpoints are singular, you may split the interval $[a,b]$ at an interior point and treat each side with its appropriate endpoint transformation;\n- ensure numerical stability by avoiding operations that form undefined intermediate expressions at the original singular points.\n\nYour program must implement the integrator as a function that accepts $a$, $b$, $\\alpha_L$, $\\alpha_R$, a callable for $\\psi(x)$, an absolute tolerance, and a recursion cap, and returns a floating-point approximation to $I$. You must not rely on any handwritten analytic antiderivatives for the test suite; all integrals must be evaluated numerically by your implementation.\n\nAngle units are irrelevant here. There are no physical units; treat all quantities as dimensionless real numbers.\n\nTest suite. Your program must evaluate the following integrals with absolute error no greater than the specified tolerance $10^{-10}$, and compare each numerical result to its corresponding analytic value. The analytic values are given in terms of standard special functions: the Gamma function $\\Gamma(z)$, the Beta function $B(p,q) = \\dfrac{\\Gamma(p)\\Gamma(q)}{\\Gamma(p+q)}$, and the lower incomplete Gamma function $\\gamma(s,x)$. Use the following six test cases, all over the interval $[0,1]$:\n- Case $1$ (left endpoint singular): $\\alpha_L = 0.7$, $\\alpha_R = 1.0$, $\\psi(x) = 1$. Integral:\n$$\nI_1 = \\int_{0}^{1} x^{\\alpha_L - 1} \\, dx, \\quad \\text{exact} = \\dfrac{1}{\\alpha_L}.\n$$\n- Case $2$ (right endpoint singular): $\\alpha_L = 1.0$, $\\alpha_R = 0.55$, $\\psi(x) = 1$. Integral:\n$$\nI_2 = \\int_{0}^{1} (1 - x)^{\\alpha_R - 1} \\, dx, \\quad \\text{exact} = \\dfrac{1}{\\alpha_R}.\n$$\n- Case $3$ (both endpoints singular): $\\alpha_L = 0.4$, $\\alpha_R = 0.3$, $\\psi(x) = 1$. Integral:\n$$\nI_3 = \\int_{0}^{1} x^{\\alpha_L - 1} (1 - x)^{\\alpha_R - 1} \\, dx, \\quad \\text{exact} = B(\\alpha_L,\\alpha_R).\n$$\n- Case $4$ (left endpoint singular with smooth factor): $\\alpha_L = 0.9$, $\\alpha_R = 1.0$, $\\psi(x) = e^{-x}$. Integral:\n$$\nI_4 = \\int_{0}^{1} x^{\\alpha_L - 1} e^{-x} \\, dx, \\quad \\text{exact} = \\gamma(\\alpha_L,1).\n$$\n- Case $5$ (both endpoints strongly singular): $\\alpha_L = 0.05$, $\\alpha_R = 0.08$, $\\psi(x) = 1$. Integral:\n$$\nI_5 = \\int_{0}^{1} x^{\\alpha_L - 1} (1 - x)^{\\alpha_R - 1} \\, dx, \\quad \\text{exact} = B(\\alpha_L,\\alpha_R).\n$$\n- Case $6$ (no singularity, consistency check): $\\alpha_L = 1.0$, $\\alpha_R = 1.0$, $\\psi(x) = \\cos(x)$. Integral:\n$$\nI_6 = \\int_{0}^{1} \\cos(x) \\, dx, \\quad \\text{exact} = \\sin(1).\n$$\n\nImplementation details and constraints:\n- Your adaptive quadrature must be based on a well-posed error estimate derived from a rigorous rule, such as Simpson’s rule error cancellation, and must terminate when the sum of subinterval contributions meets the specified absolute tolerance $10^{-10}$ or when a reasonable maximum recursion depth is reached.\n- For endpoint singularities, the coordinate transformation you design must map the singular endpoint to a regular point in the transformed coordinate where the transformed integrand remains finite; if both endpoints are singular, you may split the integral and apply appropriate one-sided transformations on each subinterval.\n- Your program must use only standard library modules and, optionally, the Numerical Python library and the Scientific Python library as described in the execution environment constraints.\n\nFinal output format:\n- Your program should produce a single line of output containing a list literal with six boolean values, one per case in the order listed above, where each boolean is true if and only if the absolute error of that case is less than or equal to $10^{-10}$. The exact format must be:\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5,\\text{result}_6]\n$$\nwith the booleans written as language-native literals and commas separating the entries, no spaces required and no additional text.", "solution": "The problem presented is a standard, well-posed task in numerical analysis: the evaluation of one-dimensional improper integrals with algebraic endpoint singularities. The integral is of the form:\n$$\nI = \\int_{a}^{b} \\left(x - a\\right)^{\\alpha_L - 1} \\left(b - x\\right)^{\\alpha_R - 1} \\,\\psi(x)\\, dx\n$$\nwhere $a < b$ are finite real numbers, the exponents $\\alpha_L > 0$ and $\\alpha_R > 0$ ensure convergence, and $\\psi(x)$ is a smooth, finite, and continuous function on the closed interval $[a,b]$. A singularity exists at an endpoint if its corresponding exponent $\\alpha$ is less than $1$. The problem is scientifically grounded and all parameters are clearly defined. I shall therefore proceed with its solution.\n\nThe solution requires two primary components: a coordinate transformation to regularize the integrand and an adaptive quadrature scheme to perform the numerical integration.\n\n**1. Regularization via Change of Variables**\n\nThe core difficulty lies in the algebraic singularities where the integrand approaches infinity. A direct application of standard quadrature rules, which sample the function at specific points, will fail or converge very slowly. We can eliminate these singularities by a carefully chosen change of variables.\n\n**1.1. Left Endpoint Singularity ($x=a$)**\n\nConsider a singularity at $x=a$, which occurs if $\\alpha_L < 1$. We seek a transformation $x = g(u)$ that maps a new interval, starting at $u=0$, to the original interval, starting at $x=a$. The transformation must be designed such that the transformed integrand is regular at $u=0$. Let us propose a power-law transformation:\n$$\nx - a = u^m \\implies x(u) = a + u^m\n$$\nThe differential element transforms as:\n$$\ndx = m u^{m-1} du\n$$\nThe singular part of the integrand, $(x-a)^{\\alpha_L - 1}$, transforms as:\n$$\n(x(u)-a)^{\\alpha_L - 1} = (u^m)^{\\alpha_L - 1} = u^{m(\\alpha_L - 1)}\n$$\nCombining this with the transformed differential element (the Jacobian determinant), we get:\n$$\n(x-a)^{\\alpha_L - 1} dx \\rightarrow u^{m(\\alpha_L - 1)} (m u^{m-1}) du = m u^{m\\alpha_L - m + m - 1} du = m u^{m\\alpha_L - 1} du\n$$\nFor the transformed integrand to be regular at $u=0$, the exponent of $u$ must be a non-negative integer. The most effective choice is to make the exponent zero, which makes the factor a constant. This is achieved by setting:\n$$\nm\\alpha_L - 1 = 0 \\implies m = \\frac{1}{\\alpha_L}\n$$\nThis choice is valid for any $\\alpha_L > 0$ where a transformation is desired (i.e., $\\alpha_L \\neq 1$). The required transformation is:\n$$\nx(u) = a + u^{1/\\alpha_L}\n$$\nThe integration limits must also be transformed. If the original interval is $[a, c]$, the new interval in $u$ becomes $[0, (c-a)^{\\alpha_L}]$. The full integral transforms as:\n$$\n\\int_a^c (x-a)^{\\alpha_L-1} (b-x)^{\\alpha_R-1} \\psi(x) dx = \\int_0^{(c-a)^{\\alpha_L}} \\frac{1}{\\alpha_L} (b - x(u))^{\\alpha_R-1} \\psi(x(u)) du\n$$\nThe transformed integrand, $F(u) = \\frac{1}{\\alpha_L} (b - a - u^{1/\\alpha_L})^{\\alpha_R-1} \\psi(a+u^{1/\\alpha_L})$, is now regular at $u=0$. At this point, it evaluates to the finite value $\\frac{1}{\\alpha_L} (b-a)^{\\alpha_R-1} \\psi(a)$.\n\n**1.2. Right Endpoint Singularity ($x=b$)**\n\nA parallel argument applies to a singularity at $x=b$, which occurs if $\\alpha_R < 1$. We use a symmetric transformation:\n$$\nb - x = v^m \\implies x(v) = b - v^m\n$$\nChoosing $m = 1/\\alpha_R$ regularizes the integrand. The transformation is:\n$$\nx(v) = b - v^{1/\\alpha_R} \\quad \\text{with} \\quad dx = -\\frac{1}{\\alpha_R} v^{1/\\alpha_R-1} dv\n$$\nIf the original interval is $[c, b]$, we integrate from $v=(b-c)^{\\alpha_R}$ to $v=0$. Reversing the limits to maintain a positive direction of integration gives:\n$$\n\\int_c^b (x-a)^{\\alpha_L-1} (b-x)^{\\alpha_R-1} \\psi(x) dx = \\int_0^{(b-c)^{\\alpha_R}} \\frac{1}{\\alpha_R} (x(v)-a)^{\\alpha_L-1} \\psi(x(v)) dv\n$$\nThe transformed integrand, $G(v) = \\frac{1}{\\alpha_R} (b - a - v^{1/\\alpha_R})^{\\alpha_L-1} \\psi(b-v^{1/\\alpha_R})$, is regular at $v=0$.\n\n**1.3. Singularities at Both Endpoints**\n\nWhen singularities exist at both $x=a$ and $x=b$, we split the integral at an arbitrary interior point, typically the midpoint $c = (a+b)/2$:\n$$\nI = \\int_a^c f(x) dx + \\int_c^b f(x) dx\n$$\nThe first integral, $\\int_a^c$, has a singularity only at its left endpoint $x=a$. We can apply the transformation from section 1.1. The term $(b-x)^{\\alpha_R-1}$ is non-singular over $[a,c]$ and is simply carried along as part of the new integrand.\nThe second integral, $\\int_c^b$, has a singularity only at its right endpoint $x=b$. We apply the transformation from section 1.2. The term $(x-a)^{\\alpha_L-1}$ is non-singular over $[c,b]$ and is treated analogously.\nThe total integral is the sum of the results from these two regularized numerical integrations.\n\n**2. Adaptive Quadrature Scheme**\n\nWith the integrand regularized, we can apply a standard adaptive quadrature routine. The chosen method is based on Simpson's rule. For an interval $[p, q]$, we compute two approximations for $\\int_p^q f(t) dt$:\n1. A coarse approximation, $S_1$, using a single application of Simpson's rule over $[p, q]$.\n2. A finer approximation, $S_2$, by summing two applications of Simpson's rule over the subintervals $[p, (p+q)/2]$ and $[(p+q)/2, q]$.\nThe error of the finer approximation $S_2$ can be estimated as $\\mathcal{E} \\approx \\frac{1}{15} |S_2 - S_1|$.\nThe algorithm proceeds as follows:\n- If the estimated error $\\mathcal{E}$ is within a specified tolerance for the current interval, the integration is considered complete for this segment, and a more accurate result, $S_2 + \\frac{1}{15}(S_2-S_1)$, is returned.\n- If the error is too large, the interval is bisected, the tolerance is halved, and the procedure is applied recursively to each subinterval. The results are then summed.\n- A recursion depth limit is enforced to prevent stack overflow in cases of pathological integrands or insufficient precision.\n\n**3. Algorithmic Implementation**\n\nThe final program is structured as a main function that acts as a dispatcher.\n1. It first determines which endpoints, if any, require a transformation by checking if $\\alpha_L$ or $\\alpha_R$ are unequal to $1.0$.\n2. If no transformation is needed (the regular case, $\\alpha_L = \\alpha_R = 1.0$), it calls the adaptive quadrature routine directly on $\\psi(x)$ over $[a, b]$.\n3. If only one endpoint is singular, it defines the appropriate transformed integrand and new integration limits, then calls the adaptive quadrature routine.\n4. If both endpoints are singular, it splits the integral at the midpoint $c = (a+b)/2$. It then solves two separate sub-problems: one for the left part $[a,c]$ (handled as a left-singular problem) and one for the right part $[c,b]$ (handled as a right-singular problem). The total tolerance is distributed between the two sub-problems. The final result is the sum of the two parts.\n\nThis principled combination of analytical transformation and robust numerical quadrature provides an accurate and efficient method for evaluating the specified class of improper integrals.", "answer": "```python\nimport numpy as np\nfrom scipy.special import gamma, beta, gammainc\nimport sys\n\n# Set a higher recursion limit for the adaptive quadrature.\nsys.setrecursionlimit(2000)\n\n_MAX_RECURSION_DEPTH = 50\n\ndef _adaptive_quad_recursive(f, a, b, tol, depth):\n    \"\"\"\n    Recursively computes the integral of f from a to b using adaptive\n    Simpson's quadrature.\n    \"\"\"\n    if depth > _MAX_RECURSION_DEPTH:\n        raise RecursionError(\n            f\"Maximum recursion depth ({_MAX_RECURSION_DEPTH}) exceeded.\"\n        )\n\n    c = (a + b) / 2.0\n    fa, fb, fc = f(a), f(b), f(c)\n\n    # Simpson's rule on the whole interval [a, b]\n    s1 = (b - a) * (fa + 4 * fc + fb) / 6.0\n\n    # Simpson's rule on the two sub-intervals [a, c] and [c, b]\n    d = (a + c) / 2.0\n    e = (c + b) / 2.0\n    fd, fe = f(d), f(e)\n    s2_left = (c - a) * (fa + 4 * fd + fc) / 6.0\n    s2_right = (b - c) * (fc + 4 * fe + fb) / 6.0\n    s2 = s2_left + s2_right\n\n    # Error estimation based on the difference between the two approximations\n    error = abs(s2 - s1) / 15.0\n\n    if error <= tol:\n        # Richardson extrapolation provides a more accurate result and includes the error correction term.\n        return s2 + (s2 - s1) / 15.0\n    \n    # Recurse on sub-intervals with halved tolerance\n    return _adaptive_quad_recursive(f, a, c, tol / 2.0, depth + 1) + \\\n           _adaptive_quad_recursive(f, c, b, tol / 2.0, depth + 1)\n\ndef integrator(a, b, alpha_L, alpha_R, psi, tolerance, recursion_cap):\n    \"\"\"\n    Numerically evaluates the integral by dispatching to the appropriate\n    transformation and quadrature scheme.\n    \"\"\"\n    global _MAX_RECURSION_DEPTH\n    _MAX_RECURSION_DEPTH = recursion_cap\n\n    needs_left_transform = not np.isclose(alpha_L, 1.0)\n    needs_right_transform = not np.isclose(alpha_R, 1.0)\n    \n    if not needs_left_transform and not needs_right_transform:\n        # Case: Regular integral, exponents are 1.0. Integrand is psi(x).\n        return _adaptive_quad_recursive(psi, a, b, tolerance, 0)\n\n    elif needs_left_transform and not needs_right_transform:\n        # Case: Left endpoint singularity only.\n        # Transformation: x = a + u^(1/alpha_L)\n        \n        def transformed_integrand(u):\n            if u == 0.0:\n                # Limit as u -> 0, where x -> a.\n                # Since alpha_R=1, (b-x) term is 1.\n                return (1.0 / alpha_L) * psi(a)\n            \n            x = a + u**(1.0 / alpha_L)\n            # Full transformed integrand is (1/alpha_L) * (b-x)^(alpha_R-1) * psi(x)\n            # Here, alpha_R = 1.0, so (b-x)^0 = 1.\n            return (1.0 / alpha_L) * psi(x)\n        \n        u_b = (b - a)**alpha_L\n        return _adaptive_quad_recursive(transformed_integrand, 0.0, u_b, tolerance, 0)\n\n    elif not needs_left_transform and needs_right_transform:\n        # Case: Right endpoint singularity only.\n        # Transformation: x = b - v^(1/alpha_R)\n        \n        def transformed_integrand(v):\n            if v == 0.0:\n                # Limit as v -> 0, where x -> b.\n                # Since alpha_L=1, (x-a) term is 1.\n                return (1.0 / alpha_R) * psi(b)\n            \n            x = b - v**(1.0 / alpha_R)\n            # Here, alpha_L = 1.0, so (x-a)^0 = 1.\n            return (1.0 / alpha_R) * psi(x)\n            \n        v_b = (b - a)**alpha_R\n        return _adaptive_quad_recursive(transformed_integrand, 0.0, v_b, tolerance, 0)\n    \n    else:  # Both endpoints have singularities\n        # Split interval at midpoint\n        c = (a + b) / 2.0\n        tol_split = tolerance / 2.0\n        \n        # --- Left Part: Integral from a to c (singularity at a) ---\n        def left_transformed_integrand(u):\n            if u == 0.0:\n                # Limit as u -> 0, where x -> a\n                return (1.0 / alpha_L) * (b - a)**(alpha_R - 1.0) * psi(a)\n\n            x = a + u**(1.0 / alpha_L)\n            return (1.0 / alpha_L) * (b - x)**(alpha_R - 1.0) * psi(x)\n        \n        u_c = (c - a)**alpha_L\n        integral_L = _adaptive_quad_recursive(left_transformed_integrand, 0.0, u_c, tol_split, 0)\n        \n        # --- Right Part: Integral from c to b (singularity at b) ---\n        def right_transformed_integrand(v):\n            if v == 0.0:\n                # Limit as v -> 0, where x -> b\n                return (1.0 / alpha_R) * (b - a)**(alpha_L - 1.0) * psi(b)\n            x = b - v**(1.0 / alpha_R)\n            return (1.0 / alpha_R) * (x - a)**(alpha_L - 1.0) * psi(x)\n\n        v_c = (b - c)**alpha_R\n        integral_R = _adaptive_quad_recursive(right_transformed_integrand, 0.0, v_c, tol_split, 0)\n        \n        return integral_L + integral_R\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the integrator, and prints the results.\n    \"\"\"\n    tol = 1e-10\n    max_rec_depth = 100\n    a, b = 0.0, 1.0\n\n    test_cases = [\n        # Case 1: Left endpoint singular\n        {'a_L': 0.7, 'a_R': 1.0, 'psi': lambda x: 1.0, \n         'exact': lambda p: 1.0 / p['a_L']},\n        # Case 2: Right endpoint singular\n        {'a_L': 1.0, 'a_R': 0.55, 'psi': lambda x: 1.0, \n         'exact': lambda p: 1.0 / p['a_R']},\n        # Case 3: Both endpoints singular\n        {'a_L': 0.4, 'a_R': 0.3, 'psi': lambda x: 1.0, \n         'exact': lambda p: beta(p['a_L'], p['a_R'])},\n        # Case 4: Left endpoint singular with smooth factor\n        {'a_L': 0.9, 'a_R': 1.0, 'psi': lambda x: np.exp(-x),\n         'exact': lambda p: gammainc(p['a_L'], 1.0) * gamma(p['a_L'])}, # gamma(s,x) = gammainc(s,x)*Gamma(s)\n        # Case 5: Both endpoints strongly singular\n        {'a_L': 0.05, 'a_R': 0.08, 'psi': lambda x: 1.0,\n         'exact': lambda p: beta(p['a_L'], p['a_R'])},\n        # Case 6: No singularity (consistency check)\n        {'a_L': 1.0, 'a_R': 1.0, 'psi': lambda x: np.cos(x),\n         'exact': lambda p: np.sin(1.0)}\n    ]\n\n    results = []\n    for case in test_cases:\n        params = {'a_L': case['a_L'], 'a_R': case['a_R']}\n        \n        numerical_val = integrator(\n            a, b, case['a_L'], case['a_R'], case['psi'], tol, max_rec_depth\n        )\n        \n        exact_val = case['exact'](params)\n        \n        abs_error = abs(numerical_val - exact_val)\n        results.append(abs_error <= tol)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2419378"}]}