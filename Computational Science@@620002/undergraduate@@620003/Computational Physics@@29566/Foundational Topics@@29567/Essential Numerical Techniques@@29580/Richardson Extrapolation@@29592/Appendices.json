{"hands_on_practices": [{"introduction": "Richardson extrapolation is a powerful technique for improving the accuracy of numerical results by combining calculations from different step sizes. This first exercise [@problem_id:2197893] provides a direct application of the method for a common case where the numerical error is known to be of the first order, $O(h)$. By working through this introductory problem, you will master the fundamental calculation of producing a more accurate estimate without the computational expense of an even finer-grained simulation.", "problem": "A team of aerospace engineers is developing a computer simulation to predict the final landing velocity of a probe on a newly discovered exoplanet. The simulation employs a numerical integration algorithm to solve the equations of motion. It is known that the primary numerical method used has a global truncation error of the first order, commonly denoted as $O(h)$, where $h$ is the time step of the simulation.\n\nThe team conducts two simulation runs with different time steps to assess the convergence of their results.\n1.  With a time step of $h_1 = 0.20$ seconds, the simulation predicts a final landing velocity of $V(h_1) = 15.60$ m/s.\n2.  With a reduced time step of $h_2 = 0.10$ seconds, the simulation yields a more refined landing velocity of $V(h_2) = 15.85$ m/s.\n\nTo obtain a more accurate prediction without the computational expense of running another simulation with an even smaller time step, the team decides to use Richardson extrapolation. Apply Richardson extrapolation to the two available velocity estimates to compute an improved estimate of the true landing velocity.\n\nExpress your final answer for the improved velocity in m/s, rounded to four significant figures.", "solution": "Let the true landing velocity be $V$ and the numerical estimate with time step $h$ be $V(h)$. For a first-order method, the global truncation error model is\n$$\nV(h) = V + C h + O(h^{2}),\n$$\nwhere $C$ is an $h$-independent constant. For two step sizes $h_{1}$ and $h_{2}$, we have\n$$\nV(h_{1}) = V + C h_{1} + O(h_{1}^{2}), \\quad V(h_{2}) = V + C h_{2} + O(h_{2}^{2}).\n$$\nNeglecting $O(h^{2})$ terms and eliminating $C$ gives\n$$\nC \\approx \\frac{V(h_{2}) - V(h_{1})}{h_{2} - h_{1}}, \\quad V \\approx V(h_{2}) - C h_{2}.\n$$\nSubstituting $C$ yields the Richardson extrapolation formula for a first-order method:\n$$\nV \\approx V(h_{2}) - h_{2}\\,\\frac{V(h_{2}) - V(h_{1})}{h_{2} - h_{1}} = V(h_{2}) + \\frac{V(h_{2}) - V(h_{1})}{\\frac{h_{1}}{h_{2}} - 1}.\n$$\nWith $h_{1} = 0.20$, $h_{2} = 0.10$, $V(h_{1}) = 15.60$, and $V(h_{2}) = 15.85$, the step ratio is $r = \\frac{h_{1}}{h_{2}} = 2$, so\n$$\nV \\approx 15.85 + \\frac{15.85 - 15.60}{2 - 1} = 15.85 + 0.25 = 16.10.\n$$\nRounded to four significant figures, the improved estimate of the true landing velocity is $16.10$.", "answer": "$$\\boxed{16.10}$$", "id": "2197893"}, {"introduction": "A key to correctly applying Richardson extrapolation is choosing the right formula, which depends on the error structure of your numerical method. This practice [@problem_id:2197927] reverses the typical problem: given a specific extrapolation formula, you will deduce the order of the error, $p$, that the formula is designed to cancel. This exercise deepens your understanding of how the coefficients in the extrapolation formula are derived directly from the method's error expansion.", "problem": "In a numerical analysis task, a function $A(h)$ provides an approximation to an unknown exact value $L$. The approximation depends on a small positive step size $h$. The error of this approximation is known to follow the asymptotic relationship:\n$$L = A(h) + C h^{p} + O(h^{q})$$\nwhere $C$ is a non-zero constant, $p$ is a positive integer representing the order of the leading error term, and $q$ is another integer such that $q > p$.\n\nTo obtain a more accurate estimate for $L$, a single step of Richardson extrapolation is performed using the approximations at step sizes $h$ and $h/2$. The resulting extrapolated value, denoted $R(h)$, is calculated using the following specific formula:\n$$R(h) = \\frac{4A(h/2) - A(h)}{3}$$\nThe new approximation $R(h)$ converges to $L$ faster than $A(h)$ as $h \\to 0$. By analyzing the structure of this extrapolation formula, determine the integer value of $p$.", "solution": "We start from the given asymptotic expansion\n$$L = A(h) + C h^{p} + O(h^{q}),$$\nwith $C \\neq 0$, $p \\in \\mathbb{Z}_{>0}$, and $q > p$. Rearranging, this gives\n$$A(h) = L - C h^{p} + O(h^{q}).$$\nReplacing $h$ by $h/2$ yields\n$$A(h/2) = L - C \\left(\\frac{h}{2}\\right)^{p} + O\\left(\\left(\\frac{h}{2}\\right)^{q}\\right) = L - C 2^{-p} h^{p} + O(h^{q}),$$\nsince $O\\left((h/2)^{q}\\right) = O(h^{q})$.\n\nThe Richardson extrapolation provided is\n$$R(h) = \\frac{4 A(h/2) - A(h)}{3}.$$\nSubstitute the expansions of $A(h/2)$ and $A(h)$:\n$$R(h) = \\frac{4\\left(L - C 2^{-p} h^{p} + O(h^{q})\\right) - \\left(L - C h^{p} + O(h^{q})\\right)}{3}.$$\nSimplify the numerator:\n$$4L - 4 C 2^{-p} h^{p} + O(h^{q}) - L + C h^{p} - O(h^{q}) = 3L + h^{p}\\left(C - 4 C 2^{-p}\\right) + O(h^{q}).$$\nTherefore,\n$$R(h) = L + \\frac{h^{p}}{3} C \\left(1 - 4 \\cdot 2^{-p}\\right) + O(h^{q}).$$\n\nFor $R(h)$ to converge faster than $A(h)$, the coefficient of the leading error term $h^{p}$ must vanish, which requires\n$$1 - 4 \\cdot 2^{-p} = 0 \\quad \\Longrightarrow \\quad 4 = 2^{p} \\quad \\Longrightarrow \\quad p = 2.$$\nThus, the structure of the given extrapolation formula implies that the leading error order is $p=2$.", "answer": "$$\\boxed{2}$$", "id": "2197927"}, {"introduction": "We now bridge theory and practice by applying Richardson extrapolation to a realistic computational physics scenario. Simulating physical systems, such as a nonlinear pendulum, often involves numerical integrators like the Verlet algorithm, which have a second-order error, $O((\\Delta t)^2)$. This comprehensive challenge [@problem_id:2435010] requires you to implement a simulation, extract a physical quantity (the period), and use the appropriate extrapolation formula to significantly enhance its accuracy—a complete workflow common in scientific computing.", "problem": "You are asked to design and implement a program that uses Richardson extrapolation to improve the numerical estimate of the oscillation period of a nonlinear pendulum, when the pendulum’s motion is simulated with the Verlet algorithm. Work entirely in the International System of Units (SI units). Angles must be in radians, time in seconds, length in meters, and acceleration in meters per second squared. Your program must produce a single line of output as described at the end.\n\nThe physical model is the planar, undamped, nonlinear pendulum of length $L$ and gravitational acceleration $g$, with angular displacement $\\theta(t)$ evolving by the ordinary differential equation (ODE)\n$$\n\\frac{d^2 \\theta}{dt^2} + \\frac{g}{L}\\,\\sin\\!\\big(\\theta(t)\\big) = 0.\n$$\nAssume initial conditions $\\theta(0) = \\theta_0$ and $\\frac{d\\theta}{dt}(0) = 0$.\n\nSimulate the motion using the velocity Verlet algorithm (a second-order symplectic method), treating the state variables $\\theta$ and $\\omega = d\\theta/dt$ and the acceleration $a(\\theta) = -\\frac{g}{L}\\sin(\\theta)$. Evolve the system with a fixed time step $\\Delta t$ over a long enough time window to determine the oscillation period $T(\\Delta t)$. Estimate the period by detecting two successive zero-crossings of $\\theta$ with the same direction of crossing (e.g., both crossings from positive to negative), and compute the time difference between those two crossings. Use linear interpolation between discrete time samples to estimate each zero-crossing time. Repeat the simulation with the refined time step $\\Delta t/2$ to obtain $T(\\Delta t/2)$.\n\nAssume that the leading-order global discretization error of any smooth scalar quantity extracted from a velocity Verlet trajectory scales as $\\mathcal{O}(\\Delta t^2)$. Using this assumption, apply Richardson extrapolation to combine $T(\\Delta t)$ and $T(\\Delta t/2)$ into an improved estimate $\\widehat{T}$ of the true period $T$, by eliminating the leading error term.\n\nImplement the above for the following test suite of parameter sets, which are chosen to probe multiple regimes:\n- Case $1$ (happy path, moderate amplitude): $L = 1.0\\,\\text{m}$, $g = 9.81\\,\\text{m}/\\text{s}^2$, $\\theta_0 = 0.5\\,\\text{rad}$, $\\Delta t = 0.05\\,\\text{s}$.\n- Case $2$ (larger amplitude, more nonlinearity): $L = 1.0\\,\\text{m}$, $g = 9.81\\,\\text{m}/\\text{s}^2$, $\\theta_0 = 1.2\\,\\text{rad}$, $\\Delta t = 0.05\\,\\text{s}$.\n- Case $3$ (near-separatrix edge case, very large amplitude): $L = 1.0\\,\\text{m}$, $g = 9.81\\,\\text{m}/\\text{s}^2$, $\\theta_0 = 2.9\\,\\text{rad}$, $\\Delta t = 0.02\\,\\text{s}$.\n\nYour program must:\n- For each case, simulate with $\\Delta t$ and $\\Delta t/2$, estimate $T(\\Delta t)$ and $T(\\Delta t/2)$ from same-direction zero-crossings of $\\theta(t)$, and then compute the Richardson-extrapolated period estimate $\\widehat{T}$.\n- Express each final period estimate $\\widehat{T}$ in seconds, rounded to $6$ decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the three extrapolated period estimates as a comma-separated list enclosed in square brackets, in the order of the cases above, for example, $[\\widehat{T}_1,\\widehat{T}_2,\\widehat{T}_3]$. Ensure each $\\widehat{T}_k$ is rounded to $6$ decimal places.", "solution": "The task is to compute a high-accuracy estimate of the oscillation period of a nonlinear pendulum. This requires three components: a numerical simulation of the dynamics, a method to extract the period from the simulation data, and an extrapolation technique to improve the accuracy of the result.\n\nThe physical system is a simple pendulum of length $L$ in a gravitational field with acceleration $g$. Its motion is described by the angular displacement $\\theta(t)$. The governing second-order nonlinear ordinary differential equation is:\n$$\n\\frac{d^2 \\theta}{dt^2} = -\\frac{g}{L} \\sin(\\theta(t))\n$$\nWe define the state of the system with the angle $\\theta$ and angular velocity $\\omega = \\frac{d\\theta}{dt}$. The system is simulated starting from rest, so the initial conditions are $\\theta(0) = \\theta_0$ and $\\omega(0) = 0$.\n\nThe evolution of the system is computed numerically using the velocity Verlet algorithm, a second-order symplectic method well-suited for conservative mechanical systems. Given the state $(\\theta_n, \\omega_n)$ at time $t_n = n \\Delta t$, where $\\Delta t$ is the time step, the state at time $t_{n+1}$ is found through the following steps:\n1.  Compute the angle-dependent acceleration: $a_n = a(\\theta_n) = -\\frac{g}{L} \\sin(\\theta_n)$.\n2.  Update the velocity by a half-step: $\\omega_{n+1/2} = \\omega_n + a_n \\frac{\\Delta t}{2}$.\n3.  Update the position by a full step using this intermediate velocity: $\\theta_{n+1} = \\theta_n + \\omega_{n+1/2} \\Delta t$.\n4.  Compute the new acceleration: $a_{n+1} = a(\\theta_{n+1}) = -\\frac{g}{L} \\sin(\\theta_{n+1})$.\n5.  Update the velocity by the second half-step: $\\omega_{n+1} = \\omega_{n+1/2} + a_{n+1} \\frac{\\Delta t}{2}$.\n\nThe period of oscillation, $T$, is determined by tracking the angular position $\\theta(t)$. Since the pendulum is released from rest at a positive angle $\\theta_0$, its first zero-crossing will be in the negative direction (downward). A full period is the time elapsed between two successive zero-crossings in the same direction. We will find the time of the first downward crossing and the second downward crossing. If a crossing occurs between time $t_{n-1}$ and $t_n$, where $\\theta_{n-1} > 0$ and $\\theta_n \\leq 0$, we use linear interpolation to find a more precise estimate of the crossing time, $t_{cross}$:\n$$\nt_{cross} = t_{n-1} - \\theta_{n-1} \\frac{\\Delta t}{\\theta_n - \\theta_{n-1}}\n$$\nLet the times of the first two such crossings be $t_{cross,1}$ and $t_{cross,2}$. The numerical estimate of the period for a given time step $\\Delta t$ is then $T(\\Delta t) = t_{cross,2} - t_{cross,1}$.\n\nThe velocity Verlet algorithm has a global error of order two. This implies that the numerically computed period $T(\\Delta t)$ relates to the true period $T_{true}$ as:\n$$\nT(\\Delta t) = T_{true} + C (\\Delta t)^2 + \\mathcal{O}(\\Delta t^4)\n$$\nwhere $C$ is a constant independent of $\\Delta t$. We perform two simulations: one with step size $\\Delta t$ to get $T(\\Delta t)$, and another with step size $\\Delta t/2$ to get $T(\\Delta t/2)$. We have:\n$$\nT(\\Delta t/2) = T_{true} + C \\left(\\frac{\\Delta t}{2}\\right)^2 + \\mathcal{O}(\\Delta t^4) = T_{true} + \\frac{1}{4} C (\\Delta t)^2 + \\mathcal{O}(\\Delta t^4)\n$$\nWe can eliminate the leading $\\mathcal{O}(\\Delta t^2)$ error term by forming a linear combination of these two equations. Multiplying the second equation by $4$ and subtracting the first yields:\n$$\n4T(\\Delta t/2) - T(\\Delta t) = (4T_{true} - T_{true}) + (C(\\Delta t)^2 - C(\\Delta t)^2) + \\mathcal{O}(\\Delta t^4) = 3T_{true} + \\mathcal{O}(\\Delta t^4)\n$$\nSolving for $T_{true}$ gives the Richardson-extrapolated estimate, $\\widehat{T}$, which is accurate to $\\mathcal{O}(\\Delta t^4)$:\n$$\n\\widehat{T} = \\frac{4T(\\Delta t/2) - T(\\Delta t)}{3}\n$$\nThis procedure is applied to each test case to obtain the final, improved period estimates.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_period_from_simulation(L, g, theta0, dt):\n    \"\"\"\n    Simulates the nonlinear pendulum using the velocity Verlet algorithm and\n    calculates the oscillation period.\n\n    The period is determined by finding the time between two successive\n    downward zero-crossings of the angle theta, using linear interpolation\n    for precision.\n\n    Args:\n        L (float): Length of the pendulum in meters.\n        g (float): Gravitational acceleration in m/s^2.\n        theta0 (float): Initial angular displacement in radians.\n        dt (float): Time step for the simulation in seconds.\n\n    Returns:\n        float: The estimated period of oscillation in seconds.\n               Returns None if the period cannot be determined.\n    \"\"\"\n    theta = theta0\n    omega = 0.0\n    t = 0.0\n    \n    # Pre-calculate constant for acceleration\n    g_over_L = g / L\n\n    # Store previous state to detect crossing\n    theta_prev = theta\n\n    # Store times of downward zero crossings (theta from positive to negative)\n    crossing_times = []\n\n    # Estimate a safe maximum simulation time. The period increases with amplitude.\n    # The small angle period is 2*pi*sqrt(L/g). The true period is always longer.\n    # For theta0 near pi, the period can be very long.\n    # We simulate for at least 1.5 times a generous estimate of the period.\n    # Using an elliptic integral-based estimate for safety.\n    approx_period = 2.0 * np.pi * np.sqrt(L / g) * (1 + theta0**2 / 16.0)\n    if theta0 > 2.8: # Near separatrix, period grows rapidly\n        max_t = 10.0\n    else:\n        max_t = approx_period * 2.0\n    \n    # Simulation loop\n    num_steps = int(max_t / dt)\n    for _ in range(num_steps):\n        # Velocity Verlet integration step\n        accel_prev = -g_over_L * np.sin(theta)\n        omega_half = omega + 0.5 * accel_prev * dt\n        theta_next = theta + omega_half * dt\n        accel_next = -g_over_L * np.sin(theta_next)\n        omega_next = omega_half + 0.5 * accel_next * dt\n        \n        t += dt\n        theta_prev = theta\n        theta = theta_next\n        omega = omega_next\n\n        # Detect downward zero-crossing: theta from positive to non-positive\n        if theta_prev > 0 and theta <= 0:\n            # Linear interpolation to find the precise crossing time t_cross\n            # Point 1: (t-dt, theta_prev), Point 2: (t, theta)\n            # Equation of line: T(th) = (t-dt) + (th - theta_prev) * dt / (theta - theta_prev)\n            # Find T at th=0:\n            t_cross = (t - dt) - theta_prev * dt / (theta - theta_prev)\n            crossing_times.append(t_cross)\n            \n            # If two downward crossings are found, calculate period and exit\n            if len(crossing_times) >= 2:\n                return crossing_times[1] - crossing_times[0]\n                \n    # This part should not be reached if max_t is sufficient\n    return None\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the Richardson-extrapolated period for each case and\n    prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # (L, g, theta0, dt)\n        (1.0, 9.81, 0.5, 0.05),\n        (1.0, 9.81, 1.2, 0.05),\n        (1.0, 9.81, 2.9, 0.02),\n    ]\n\n    results = []\n    \n    for i, case in enumerate(test_cases):\n        L, g, theta0, dt = case\n        \n        # Calculate period with coarse time step dt\n        T_coarse = get_period_from_simulation(L, g, theta0, dt)\n        \n        # Calculate period with fine time step dt/2\n        T_fine = get_period_from_simulation(L, g, theta0, dt / 2.0)\n        \n        if T_coarse is None or T_fine is None:\n            raise ValueError(f\"Failed to determine period for case {i+1}\")\n\n        # Apply Richardson extrapolation for a method with O(h^2) error\n        # T_extrapolated = (4 * T_fine - T_coarse) / 3\n        T_extrapolated = (4.0 * T_fine - T_coarse) / 3.0\n        \n        # Format the result to 6 decimal places\n        results.append(f\"{T_extrapolated:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2435010"}]}