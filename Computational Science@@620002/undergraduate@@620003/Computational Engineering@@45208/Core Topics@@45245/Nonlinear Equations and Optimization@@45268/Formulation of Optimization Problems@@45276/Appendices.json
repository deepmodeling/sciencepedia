{"hands_on_practices": [{"introduction": "This exercise introduces one of the most fundamental problems in discrete optimization: the Set Cover problem. You will formulate the challenge of placing a minimum number of fire stations to cover all buildings in a city, a classic location problem [@problem_id:2394756]. This practice is valuable for learning how to translate high-level requirements like \"every building must be covered\" into a precise system of linear inequalities with binary decision variables.", "problem": "You are given a city with a finite set of buildings and a finite set of candidate locations where a fire station may be placed. For each candidate location and building, a travel time in minutes is provided. A building is said to be covered by a station if the stationâ€™s travel time to that building is less than or equal to a strictly enforced response-time threshold of $5$ minutes. The goal is to decide where to place stations so that every building is covered while using the minimum possible number of stations. All angles are irrelevant to this problem. All time quantities are in minutes and must be treated exactly as given.\n\nFormulate this as a mathematical optimization problem. Let the set of buildings be indexed by $i \\in \\{0,1,\\dots,n-1\\}$ and the set of candidate station locations be indexed by $j \\in \\{0,1,\\dots,m-1\\}$. Let $t_{ij}$ denote the travel time (in minutes) from candidate station $j$ to building $i$. Define a binary coverage parameter\n$$\na_{ij} = \\begin{cases}\n1, & \\text{if } t_{ij} \\le 5 \\\\\n0, & \\text{if } t_{ij} > 5\n\\end{cases}.\n$$\nDefine decision variables $x_j \\in \\{0,1\\}$ for all $j$, where $x_j = 1$ indicates a station is placed at candidate location $j$, and $x_j = 0$ otherwise. The optimization problem is:\n$$\n\\min \\sum_{j=0}^{m-1} x_j\n$$\nsubject to\n$$\n\\sum_{j=0}^{m-1} a_{ij} x_j \\ge 1, \\quad \\forall i \\in \\{0,1,\\dots,n-1\\},\n$$\n$$\nx_j \\in \\{0,1\\}, \\quad \\forall j \\in \\{0,1,\\dots,m-1\\}.\n$$\n\nImplement a complete, runnable program that, for each test case below, determines:\n- the minimum number of stations needed, and\n- one optimal set of station indices (using $0$-based indices) that achieves this minimum; if multiple optimal sets exist, return the lexicographically smallest sorted index set, where lexicographic order compares sorted index lists as tuples,\n- or determines that no feasible solution exists.\n\nIf no feasible solution exists (that is, at least one building is not within $5$ minutes of any candidate station), your program must output the integer $-1$ for that test case. Otherwise, for a feasible test case, your program must output a list of the form $[k,[j_1,j_2,\\dots,j_k]]$ where $k$ is the minimum number of stations and $[j_1,\\dots,j_k]$ is the strictly increasing list of chosen station indices.\n\nTest suite (each $T^{(c)}$ is an $m \\times n$ matrix; row $j$ and column $i$ give $t_{ij}$ in minutes):\n\n- Test case $1$: $m=n=5$,\n$$\nT^{(1)}=\\begin{bmatrix}\n4.0 & 5.0 & 6.0 & 6.0 & 6.2 \\\\\n6.1 & 3.5 & 4.0 & 5.0 & 6.5 \\\\\n3.0 & 6.0 & 6.0 & 6.0 & 4.5 \\\\\n7.0 & 6.8 & 2.5 & 3.5 & 5.5 \\\\\n8.0 & 7.5 & 6.2 & 6.1 & 1.5\n\\end{bmatrix}.\n$$\n\n- Test case $2$: $m=n=3$ (boundary coverage at exactly $5$ minutes),\n$$\nT^{(2)}=\\begin{bmatrix}\n5.0 & 5.0 & 5.0 \\\\\n5.0 & 6.0 & 6.0 \\\\\n6.0 & 5.0 & 6.0\n\\end{bmatrix}.\n$$\n\n- Test case $3$: $m=n=2$ (infeasible),\n$$\nT^{(3)}=\\begin{bmatrix}\n4.0 & 6.0 \\\\\n6.0 & 6.1\n\\end{bmatrix}.\n$$\n\n- Test case $4$: $m=n=4$ (multiple optimal solutions; lexicographically smallest must be chosen),\n$$\nT^{(4)}=\\begin{bmatrix}\n4.0 & 6.0 & 5.0 & 6.0 \\\\\n5.0 & 6.0 & 6.0 & 4.0 \\\\\n6.0 & 3.0 & 4.5 & 6.0 \\\\\n6.0 & 4.0 & 6.0 & 3.0\n\\end{bmatrix}.\n$$\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases $1$ through $4$. For each test case, output either $-1$ if infeasible, or a list of the form $[k,[j_1,\\dots,j_k]]$ as defined above. The final printed line must contain no spaces. For example, a valid overall output could look like `[[k_1,[j_1,...]],[k_2,[...]],-1,[k_4,...]]`.", "solution": "The problem presented is a classic integer linear programming formulation of the Set Cover problem, a fundamental topic in computational engineering and operations research. The objective is to find the minimum number of fire stations required to ensure every building in a city is covered, where coverage is defined by a maximum response time.\n\nA validation of the problem statement confirms that it is self-contained, consistent, and scientifically sound. It is well-posed, providing a clear objective function, a complete set of constraints, and explicit data for all test cases. The mathematical formulation,\n$$\n\\min \\sum_{j=0}^{m-1} x_j\n$$\nsubject to\n$$\n\\sum_{j=0}^{m-1} a_{ij} x_j \\ge 1, \\quad \\forall i \\in \\{0,1,\\dots,n-1\\},\n$$\n$$\nx_j \\in \\{0,1\\}, \\quad \\forall j \\in \\{0,1,\\dots,m-1\\},\n$$\nis a standard and correct representation of the Set Cover problem. The symbols are clearly defined: $x_j$ are the binary decision variables for placing a station at candidate location $j$, and $a_{ij}$ is a binary parameter indicating if station $j$ can cover building $i$ within the specified time threshold of $5$ minutes. The problem lacks any scientific fallacies, ambiguities, or contradictions, and is therefore deemed valid.\n\nThe core of the problem is to select a minimum-size subset of candidate station locations such that every building is covered. In the language of the Set Cover problem, the set of buildings $\\{0, 1, \\dots, n-1\\}$ constitutes the universe of elements to be covered. For each candidate station location $j \\in \\{0, 1, \\dots, m-1\\}$, we can define a set $S_j$ containing the indices of all buildings that station $j$ can cover. The problem is then to find the smallest sub-collection of these sets $\\{S_j\\}$ whose union covers the entire universe of buildings.\n\nThe Set Cover problem is known to be NP-hard. For large-scale instances, one would typically employ approximation algorithms or sophisticated solvers for integer linear programs. However, given the small dimensions of the provided test cases (e.g., $m, n \\le 5$), a direct, exact solution via an exhaustive search is computationally feasible and guarantees optimality. The algorithm proceeds as follows:\n\nFirst, we preprocess the input data. For each test case, given the $m \\times n$ travel time matrix $T^{(c)}$ where the entry at row $j$ and column $i$ is $t_{ij}$, we construct an $n \\times m$ binary coverage matrix $A$. The entry $a_{ij}$ of this matrix is $1$ if $t_{ij} \\le 5$, and $0$ otherwise. This matrix directly represents the coverage relationship: $a_{ij}=1$ signifies that station $j$ covers building $i$.\n\nSecond, we perform an infeasibility check. A necessary prerequisite for a feasible solution is that every building must be coverable by at least one candidate station. This is verified by checking that for each building $i$, the corresponding row in the coverage matrix $A$ contains at least one non-zero entry, i.e., $\\sum_{j=0}^{m-1} a_{ij} \\ge 1$. If this condition is violated for any building, no combination of stations can cover all buildings, and the problem is declared infeasible.\n\nThird, if the problem is feasible, we search for the optimal solution by iterating on the number of stations, $k$, from $k=1$ up to $m$. For each value of $k$, we generate all unique combinations of $k$ station locations from the $m$ available candidates. The problem requires the lexicographically smallest set of station indices among all optimal solutions. This is naturally handled by generating the combinations of station indices in lexicographical order. The first valid covering set found for the smallest $k$ is, by construction, the required optimal solution.\n\nFinally, for each generated combination of $k$ stations, we verify if it constitutes a valid cover. A combination is a valid cover if, for every building $i$, at least one of the selected $k$ stations covers it. The first combination that satisfies this condition is the solution. The search terminates, and we report the current value of $k$ and the corresponding set of station indices. If the loop completes without finding a solution for any $k \\le m$, it would imply infeasibility, which is already handled by our initial check. Because a feasible problem will always have a solution with $k \\le m$ (in the worst case, using all stations that contribute to covering at least one unique, otherwise uncovered building), the search is guaranteed to find a solution.", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to solve the set of test cases for the fire station location problem.\n    \"\"\"\n    T1 = np.array([\n        [4.0, 5.0, 6.0, 6.0, 6.2],\n        [6.1, 3.5, 4.0, 5.0, 6.5],\n        [3.0, 6.0, 6.0, 6.0, 4.5],\n        [7.0, 6.8, 2.5, 3.5, 5.5],\n        [8.0, 7.5, 6.2, 6.1, 1.5]\n    ])\n\n    T2 = np.array([\n        [5.0, 5.0, 5.0],\n        [5.0, 6.0, 6.0],\n        [6.0, 5.0, 6.0]\n    ])\n\n    T3 = np.array([\n        [4.0, 6.0],\n        [6.0, 6.1]\n    ])\n\n    T4 = np.array([\n        [4.0, 6.0, 5.0, 6.0],\n        [5.0, 6.0, 6.0, 4.0],\n        [6.0, 3.0, 4.5, 6.0],\n        [6.0, 4.0, 6.0, 3.0]\n    ])\n\n    test_cases = [T1, T2, T3, T4]\n    \n    results = []\n    for t_matrix in test_cases:\n        result = solve_set_cover(t_matrix)\n        results.append(result)\n\n    # Format the final output string as specified, with no spaces.\n    results_str = []\n    for res in results:\n        if res == -1:\n            results_str.append(\"-1\")\n        else:\n            k, indices = res\n            indices_str = ','.join(map(str, indices))\n            results_str.append(f\"[{k},[{indices_str}]]\")\n            \n    print(f\"[{','.join(results_str)}]\")\n\ndef solve_set_cover(t_matrix):\n    \"\"\"\n    Solves the set cover problem for a single test case.\n\n    Args:\n        t_matrix (np.ndarray): An m x n matrix of travel times, t_ij is at row j, col i.\n\n    Returns:\n        - A list [k, [j1, j2, ...]] for a feasible solution, where k is the minimum\n          number of stations and [j1, ...] are their indices.\n        - The integer -1 if no feasible solution exists.\n    \"\"\"\n    m, n = t_matrix.shape\n    response_time_threshold = 5.0\n\n    # Build the coverage sets for each station.\n    # station_covers[j] is a set of building indices covered by station j.\n    station_covers = [set() for _ in range(m)]\n    for j in range(m):  # station index\n        for i in range(n):  # building index\n            if t_matrix[j, i] <= response_time_threshold:\n                station_covers[j].add(i)\n\n    # Check for infeasibility: any building that cannot be covered by any station.\n    all_coverable_buildings = set()\n    for s in station_covers:\n        all_coverable_buildings.update(s)\n    \n    if len(all_coverable_buildings) < n:\n        return -1\n\n    # Brute-force search for the minimum number of stations (k).\n    # Iterate from k=1 up to m.\n    for k in range(1, m + 1):\n        # Generate combinations of k stations. `itertools.combinations`\n        # generates them in lexicographical order.\n        for station_indices in combinations(range(m), k):\n            covered_buildings = set()\n            for station_idx in station_indices:\n                covered_buildings.update(station_covers[station_idx])\n            \n            # Check if all n buildings are covered.\n            if len(covered_buildings) == n:\n                # This is the first solution found for the smallest k, and it's\n                # the lexicographically smallest set of for that_k. So it's optimal.\n                return [k, list(station_indices)]\n    \n    # This part of the code should not be reachable if the initial\n    # feasibility check is correct. A feasible problem always has a solution.\n    return -1\n\nsolve()\n```", "id": "2394756"}, {"introduction": "Moving from discrete placement to continuous resource allocation, this problem tackles how to distribute a budget to maximize overall return. You will model a scenario with diminishing returnsâ€”where each additional dollar spent yields progressively less benefitâ€”using concave functions [@problem_id:2394742]. The key principle you'll explore is that at the optimal solution, the marginal gain from the last dollar spent on any active channel should be equal, a cornerstone concept in economic-based optimization.", "problem": "You are given an allocation problem that must be formulated and solved from first principles in mathematical optimization. There are $n$ marketing channels indexed by $i \\in \\{1,\\dots,n\\}$. Let $x_i \\ge 0$ denote the nonnegative spend allocated to channel $i$. The goal is to maximize the total number of conversions, modeled by a sum of channel-specific conversion functions $f_i(x_i)$, subject to a total budget constraint and optional per-channel spend upper bounds $u_i \\in (0,+\\infty]$ (if no explicit upper bound is specified for a channel, take $u_i=+\\infty$). The optimization problem to be solved is:\nmaximize $\\sum_{i=1}^{n} f_i(x_i)$ subject to $\\sum_{i=1}^{n} x_i \\le B$, $0 \\le x_i \\le u_i$ for all $i$.\n\nFor this problem, the functions $f_i$ are concave, increasing, twice continuously differentiable functions from $[0,+\\infty)$ to $[0,+\\infty)$ chosen from the following families, with parameters that are strictly positive real numbers unless explicitly stated otherwise:\n\n- Logarithmic response (type L): $f_i(x) = a_i \\,\\log\\!\\big(1 + b_i x\\big)$ with parameters $a_i>0$, $b_i>0$. If $a_i=0$ is specified, then $f_i(x)\\equiv 0$ for all $x$.\n- Square-root response (type S): $f_i(x) = c_i \\,\\sqrt{x}$ with parameter $c_i>0$.\n- Exponential saturation (type E): $f_i(x) = d_i \\,\\big(1 - \\exp(-e_i x)\\big)$ with parameters $d_i>0$, $e_i>0$.\n\nAll logarithms are natural logarithms, and $\\exp(\\cdot)$ denotes the exponential function. All budgets and spends are nonnegative reals.\n\nYour task is to compute, for each test case specified below, the maximum value of the total conversions $\\sum_{i=1}^{n} f_i(x_i)$ attained by an optimal allocation $(x_1,\\dots,x_n)$ that satisfies the constraints. The answer for each test case must be reported as a single real number rounded to exactly $6$ decimal places.\n\nTest suite:\n\n- Test case $1$:\n  - Budget $B = 100.0$.\n  - Channels:\n    - Channel $1$: type L, parameters $a_1=120.0$, $b_1=0.015$, no upper bound ($u_1=+\\infty$).\n    - Channel $2$: type L, parameters $a_2=80.0$, $b_2=0.03$, no upper bound ($u_2=+\\infty$).\n    - Channel $3$: type E, parameters $d_3=200.0$, $e_3=0.02$, no upper bound ($u_3=+\\infty$).\n- Test case $2$:\n  - Budget $B = 0.0$.\n  - Channels:\n    - Channel $1$: type L, parameters $a_1=100.0$, $b_1=0.02$, no upper bound ($u_1=+\\infty$).\n    - Channel $2$: type S, parameter $c_2=50.0$, no upper bound ($u_2=+\\infty$).\n- Test case $3$:\n  - Budget $B = 50.0$.\n  - Channels (each with an explicit upper bound):\n    - Channel $1$: type S, parameter $c_1=40.0$, upper bound $u_1=10.0$.\n    - Channel $2$: type S, parameter $c_2=30.0$, upper bound $u_2=5.0$.\n- Test case $4$:\n  - Budget $B = 120.0$.\n  - Channels:\n    - Channel $1$: type L, parameters $a_1=150.0$, $b_1=0.01$, upper bound $u_1=80.0$.\n    - Channel $2$: type S, parameter $c_2=60.0$, no upper bound ($u_2=+\\infty$).\n    - Channel $3$: type E, parameters $d_3=180.0$, $e_3=0.05$, upper bound $u_3=30.0$.\n    - Channel $4$: type L, parameters $a_4=0.0$, $b_4=0.02$, no upper bound ($u_4=+\\infty$).\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the maximum total conversions for test cases $1$, $2$, $3$, and $4$ in this order, each rounded to exactly $6$ decimal places, for example, $[v_1,v_2,v_3,v_4]$ where each $v_k$ is a decimal number with exactly $6$ digits after the decimal point.", "solution": "The problem presented is a resource allocation problem, which is a classic example of convex optimization. The goal is to maximize a total objective function, which is the sum of individual concave functions, subject to a linear budget constraint and box constraints on the variables.\n\nThe optimization problem is formally stated as:\n$$\n\\begin{aligned}\n\\text{maximize} \\quad & Z = \\sum_{i=1}^{n} f_i(x_i) \\\\\n\\text{subject to} \\quad & \\sum_{i=1}^{n} x_i \\le B \\\\\n& 0 \\le x_i \\le u_i, \\quad \\text{for } i=1, \\dots, n\n\\end{aligned}\n$$\nHere, $x_i$ is the spend on channel $i$, $B$ is the total budget, and $u_i$ is the upper bound on spend for channel $i$. The functions $f_i(x_i)$ represent the conversions from channel $i$ for a spend of $x_i$. The problem states that each $f_i$ is concave, increasing, and twice continuously differentiable. The sum of concave functions is also concave. Maximizing a concave function over a convex feasible set (defined by linear inequalities) is a convex optimization problem.\n\nWe can solve this using the Karush-Kuhn-Tucker (KKT) conditions. The Lagrangian for this problem is:\n$$ L(x, \\lambda, \\mu, \\nu) = \\sum_{i=1}^{n} f_i(x_i) - \\lambda \\left( \\sum_{i=1}^{n} x_i - B \\right) - \\sum_{i=1}^{n} \\mu_i (x_i - u_i) + \\sum_{i=1}^{n} \\nu_i x_i $$\nwhere $\\lambda, \\mu_i, \\nu_i \\ge 0$ are the Lagrange multipliers associated with the budget constraint, upper bounds, and non-negativity constraints, respectively.\n\nThe KKT stationarity condition is $\\frac{\\partial L}{\\partial x_i} = 0$ for each $i$:\n$$ f'_i(x_i) - \\lambda - \\mu_i + \\nu_i = 0 $$\nwhere $f'_i(x_i)$ is the first derivative of $f_i$ with respect to $x_i$, representing the marginal conversion rate.\n\nThe complementary slackness conditions provide the following relationships for the optimal solution:\n1.  If $0 < x_i < u_i$, then $\\nu_i=0$ and $\\mu_i=0$, which implies $f'_i(x_i) = \\lambda$.\n2.  If $x_i = 0$, then $\\nu_i \\ge 0$ and $\\mu_i=0$, which implies $f'_i(0) \\le \\lambda$.\n3.  If $x_i = u_i$, then $\\nu_i = 0$ and $\\mu_i \\ge 0$, which implies $f'_i(u_i) \\ge \\lambda$.\n\nThe Lagrange multiplier $\\lambda$ can be interpreted as the marginal return (conversions per unit of spend) of the last dollar spent. At optimality, all channels that receive a non-zero spend (and are not at their upper cap) must have the same marginal return $\\lambda$.\n\nThis insight provides a method for finding the optimal allocation $(x_1, \\dots, x_n)$. For a given value of $\\lambda$, the optimal spend $x_i(\\lambda)$ for each channel is determined. Since $f_i$ is concave, $f'_i$ is a decreasing function. Therefore, its inverse, $(f'_i)^{-1}$, is also a decreasing function. The optimal spend $x_i$ for a given $\\lambda$ is:\n$$ x_i(\\lambda) = \\min(u_i, \\max(0, (f'_i)^{-1}(\\lambda))) $$\n\nThe total spend is a monotonically non-increasing function of $\\lambda$: $X(\\lambda) = \\sum_{i=1}^n x_i(\\lambda)$.\nOur task is to find a $\\lambda^* \\ge 0$ such that the total budget is utilized, i.e., $X(\\lambda^*) = B$, provided the total unconstrained spend would exceed $B$.\n\nThe derivatives $f'_i$ and their inverses $(f'_i)^{-1}$ for the given function families are:\n- **Logarithmic (L):** $f_i(x) = a_i \\log(1 + b_i x)$\n  - $f'_i(x) = \\frac{a_i b_i}{1 + b_i x}$\n  - $(f'_i)^{-1}(\\lambda) = \\frac{a_i}{\\lambda} - \\frac{1}{b_i}$\n- **Square-root (S):** $f_i(x) = c_i \\sqrt{x}$\n  - $f'_i(x) = \\frac{c_i}{2\\sqrt{x}}$\n  - $(f'_i)^{-1}(\\lambda) = \\left(\\frac{c_i}{2\\lambda}\\right)^2$\n- **Exponential saturation (E):** $f_i(x) = d_i (1 - \\exp(-e_i x))$\n  - $f'_i(x) = d_i e_i \\exp(-e_i x)$\n  - $(f'_i)^{-1}(\\lambda) = \\frac{1}{e_i} \\log\\left(\\frac{d_i e_i}{\\lambda}\\right)$\n\nThe overall algorithm is as follows:\n1.  Handle trivial cases. If $B=0$, all $x_i=0$ and total conversion is $0$.\n2.  Calculate the sum of all finite upper bounds, $U_{total} = \\sum_{i \\text{ s.t. } u_i<\\infty} u_i$. If the problem has any channel with $u_i = \\infty$, then the total capacity is infinite. If all $u_i$ are finite and $B \\ge U_{total}$, the budget constraint is not binding. The optimal solution is to spend up to the cap on every channel, $x_i = u_i$. The total conversion is $\\sum_i f_i(u_i)$.\n3.  If $0 < B < U_{total}$ (or $U_{total}=\\infty$), the budget constraint is active. We need to find the unique $\\lambda > 0$ that satisfies $\\sum_i x_i(\\lambda) = B$. Since $X(\\lambda)$ is monotonic, we can efficiently find this $\\lambda$ using a numerical root-finding algorithm like the bisection method. We search for a $\\lambda$ in a range, say $[\\lambda_{low}, \\lambda_{high}]$, that solves the equation $g(\\lambda) = X(\\lambda) - B = 0$.\n4.  The bisection search proceeds by repeatedly narrowing the search interval. In each step, we pick the midpoint $\\lambda_{mid}$ of the current interval, calculate the total spend $X(\\lambda_{mid})$, and update either the lower or upper bound of the interval based on whether $X(\\lambda_{mid})$ is greater or less than $B$.\n5.  After a sufficient number of iterations, the interval becomes small enough, and we can take its midpoint as the optimal $\\lambda^*$.\n6.  With the optimal $\\lambda^*$, we compute the final spend allocation $x_i^* = x_i(\\lambda^*)$ for each channel.\n7.  The maximum total conversion is then calculated by summing the conversions from the optimal spends: $Z^* = \\sum_i f_i(x_i^*)$.\n\nA special case is a channel with a zero-valued primary parameter (e.g., $a_i=0$ for type L), which results in $f_i(x) \\equiv 0$ and $f'_i(x) \\equiv 0$. For any $\\lambda > 0$, the condition $f'_i(0) \\le \\lambda$ is met, correctly yielding an optimal spend of $x_i=0$ for this channel.\n\nThis methodology provides a robust and general solution to the given class of optimization problems. The implementation will consist of functions representing the channel responses and their derivatives, and a main solver function that orchestrates the bisection search.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the results.\n    \"\"\"\n\n    class ChannelModel:\n        \"\"\"\n        A class to encapsulate the behavior of a single marketing channel.\n        \"\"\"\n        def __init__(self, ch_type, params, u_i):\n            self.ch_type = ch_type\n            self.params = params\n            self.u_i = u_i if u_i is not None else np.inf\n\n            # Pre-calculate derivatives at boundaries for efficiency\n            self.deriv_at_0 = self._f_prime(1e-12) # Use small epsilon for S-type\n            if self.ch_type == 'S':\n                self.deriv_at_0 = np.inf\n            else:\n                 self.deriv_at_0 = self._f_prime(0)\n            \n            self.deriv_at_u = 0\n            if self.u_i < np.inf:\n                self.deriv_at_u = self._f_prime(self.u_i)\n\n        def f(self, x):\n            \"\"\"Calculates the number of conversions for a given spend x.\"\"\"\n            if x < 0: x = 0\n            if self.ch_type == 'L':\n                a, b = self.params\n                if a == 0: return 0.0\n                return a * np.log(1 + b * x)\n            elif self.ch_type == 'S':\n                c, = self.params\n                return c * np.sqrt(x)\n            elif self.ch_type == 'E':\n                d, e = self.params\n                return d * (1 - np.exp(-e * x))\n            return 0.0\n\n        def _f_prime(self, x):\n            \"\"\"Calculates the marginal conversion rate (derivative) at spend x.\"\"\"\n            if self.ch_type == 'L':\n                a, b = self.params\n                if a == 0: return 0.0\n                return (a * b) / (1 + b * x)\n            elif self.ch_type == 'S':\n                c, = self.params\n                if x == 0: return np.inf\n                return c / (2 * np.sqrt(x))\n            elif self.ch_type == 'E':\n                d, e = self.params\n                return d * e * np.exp(-e * x)\n            return 0.0\n\n        def _f_prime_inv(self, lam):\n            \"\"\"Calculates spend x for a given marginal return lambda.\"\"\"\n            if lam <= 0: return np.inf\n            if self.ch_type == 'L':\n                a, b = self.params\n                if a == 0: return 0.0\n                if lam >= a * b: return 0.0\n                return a / lam - 1 / b\n            elif self.ch_type == 'S':\n                c, = self.params\n                return (c / (2 * lam))**2\n            elif self.ch_type == 'E':\n                d, e = self.params\n                if lam >= d * e: return 0.0\n                return np.log(d * e / lam) / e\n            return 0.0\n\n        def get_spend(self, lam):\n            \"\"\"Determines optimal spend for a given lambda.\"\"\"\n            if lam >= self.deriv_at_0:\n                return 0.0\n            if lam <= self.deriv_at_u and self.u_i < np.inf:\n                return self.u_i\n            \n            unbounded_spend = self._f_prime_inv(lam)\n            return min(self.u_i, max(0, unbounded_spend))\n\n    def solve_one_case(budget, channels_data):\n        \"\"\"\n        Solves a single instance of the allocation problem.\n        \"\"\"\n        if budget == 0.0:\n            return 0.0\n\n        channels = [ChannelModel(c_type, params, u_i) for c_type, params, u_i in channels_data]\n        \n        total_upper_bound = sum(ch.u_i for ch in channels if ch.u_i < np.inf)\n        if all(ch.u_i < np.inf for ch in channels) and budget >= total_upper_bound:\n            total_conversions = sum(ch.f(ch.u_i) for ch in channels)\n            return total_conversions\n\n        # Bisection search to find the optimal lambda\n        low_lam = 1e-9\n        high_lam = 1e6 # A sufficiently large upper bound for lambda\n        \n        for _ in range(100): # 100 iterations are sufficient for double precision\n            mid_lam = (low_lam + high_lam) / 2\n            current_spend = sum(ch.get_spend(mid_lam) for ch in channels)\n            \n            if current_spend > budget:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n        \n        final_lambda = (low_lam + high_lam) / 2\n        \n        # Calculate final conversions with the optimal lambda\n        total_conversions = sum(ch.f(ch.get_spend(final_lambda)) for ch in channels)\n        return total_conversions\n\n    test_cases = [\n        {\n            \"B\": 100.0,\n            \"channels\": [\n                ('L', (120.0, 0.015), None),\n                ('L', (80.0, 0.03), None),\n                ('E', (200.0, 0.02), None),\n            ]\n        },\n        {\n            \"B\": 0.0,\n            \"channels\": [\n                ('L', (100.0, 0.02), None),\n                ('S', (50.0,), None),\n            ]\n        },\n        {\n            \"B\": 50.0,\n            \"channels\": [\n                ('S', (40.0,), 10.0),\n                ('S', (30.0,), 5.0),\n            ]\n        },\n        {\n            \"B\": 120.0,\n            \"channels\": [\n                ('L', (150.0, 0.01), 80.0),\n                ('S', (60.0,), None),\n                ('E', (180.0, 0.05), 30.0),\n                ('L', (0.0, 0.02), None),\n            ]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_one_case(case[\"B\"], case[\"channels\"])\n        results.append(result)\n\n    # Format the final output string\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2394742"}, {"introduction": "This final practice addresses a complex engineering design challenge: optimizing the layout of a wind farm. Unlike the previous problems, the decision to place a turbine at one location directly impacts the performance of others due to aerodynamic wake effects [@problem_id:2394774]. This exercise demonstrates how to formulate problems with non-linear, interacting components, forcing you to model system-level effects to maximize the total power output of the entire farm.", "problem": "You are tasked with formulating and solving a facility placement optimization problem in which wind turbines are placed at candidate sites within a rectangular wind farm to maximize total electrical power output. The wind direction is fixed and aligned with the positive $x$-axis. The wake effect is modeled using a simplified Jensen (also known as Park) wake model: each upwind turbine reduces the wind speed available to downwind turbines if the downwind turbine lies within the expanding conical wake of the upwind turbine.\n\nFormulation requirements:\n- Decision variable: for each candidate site index $n$, define a binary variable $z_n \\in \\{0,1\\}$ indicating whether a turbine is installed at that site.\n- Exactly $T$ turbines must be installed: $\\sum_n z_n = T$.\n- A minimum spacing constraint must hold for any selected pair of sites $n \\neq m$: if $z_n = 1$ and $z_m = 1$, then the Euclidean distance between the sites must be at least $s_{\\min}$.\n- Let each candidate site have coordinates $(x_n,y_n)$ in meters. The wind speed is uniform and equal to $V_0$ meters per second at the upwind boundary.\n- Let rotor diameter be $D$ meters, rotor swept area be $A = \\pi (D/2)^2$ square meters, air density be $\\rho$ kilograms per cubic meter, and power coefficient be $C_p$ (dimensionless).\n- Let the axial induction factor be $a$ (dimensionless) and the wake decay constant be $k$ (dimensionless). For two selected turbines $j$ and $i$ with $x_j < x_i$, define the streamwise separation $d_{ji} = x_i - x_j$ and lateral separation $s_{ji} = |y_i - y_j|$. The wake radius at $x_i$ due to turbine $j$ is $r_{ji} = D/2 + k\\, d_{ji}$. Turbine $j$ influences turbine $i$ only if $s_{ji} \\le r_{ji}$, in which case the single-wake velocity deficit contributed by $j$ at $i$ is\n$$\n\\delta_{j\\to i} \\;=\\; \\frac{2a}{\\left(1 + \\frac{2k\\, d_{ji}}{D}\\right)^2}.\n$$\nMultiple wake deficits combine via the root-sum-square superposition. For a selected turbine $i$, let $\\mathcal{U}(i)$ be the set of selected turbines that are upwind of $i$ and influence it. The effective wind speed at $i$ is\n$$\nV_i \\;=\\; V_0 \\,\\Big(1 - \\sqrt{\\sum_{j\\in \\mathcal{U}(i)} \\delta_{j\\to i}^2}\\,\\Big),\n$$\nclipped below at $0$ if necessary. The electrical power extracted at $i$ is\n$$\nP_i \\;=\\; \\tfrac{1}{2}\\,\\rho\\, A\\, C_p\\, V_i^3.\n$$\nThe objective is to maximize the total power\n$$\n\\max_{z \\in \\{0,1\\}^M} \\;\\; \\sum_{i=1}^{M} z_i\\, P_i(z),\n$$\nsubject to the cardinality and spacing constraints, where $M$ is the number of candidate sites.\n\nUnits and final outputs:\n- All distances must be in meters, all velocities in meters per second, and the final power must be expressed in Watts. For each test case below, you must report the maximum achievable total power in Watts as an integer, obtained by rounding to the nearest integer.\n\nTest suite:\n- Test case $1$ (general case):\n  - Candidate grid along $x$: $\\{0, 300, 600, 900\\}$ meters.\n  - Candidate grid along $y$: $\\{0, 300, 600\\}$ meters.\n  - Number of turbines to place: $T = 4$.\n  - Minimum spacing: $s_{\\min} = 300$ meters.\n  - Free-stream wind speed: $V_0 = 12$ meters per second.\n  - Rotor diameter: $D = 100$ meters.\n  - Air density: $\\rho = 1.225$ kilograms per cubic meter.\n  - Power coefficient: $C_p = 0.4$.\n  - Axial induction factor: $a = \\tfrac{1}{3}$.\n  - Wake decay constant: $k = 0.05$.\n- Test case $2$ (single-turbine boundary case):\n  - Candidate grid along $x$: $\\{0, 200, 400\\}$ meters.\n  - Candidate grid along $y$: $\\{0, 200, 400\\}$ meters.\n  - Number of turbines to place: $T = 1$.\n  - Minimum spacing: $s_{\\min} = 300$ meters.\n  - Free-stream wind speed: $V_0 = 8$ meters per second.\n  - Rotor diameter: $D = 100$ meters.\n  - Air density: $\\rho = 1.225$ kilograms per cubic meter.\n  - Power coefficient: $C_p = 0.4$.\n  - Axial induction factor: $a = \\tfrac{1}{3}$.\n  - Wake decay constant: $k = 0.05$.\n- Test case $3$ (edge case with stronger alignment sensitivity):\n  - Candidate grid along $x$: $\\{0, 300, 600, 900\\}$ meters.\n  - Candidate grid along $y$: $\\{0, 300, 600\\}$ meters.\n  - Number of turbines to place: $T = 5$.\n  - Minimum spacing: $s_{\\min} = 300$ meters.\n  - Free-stream wind speed: $V_0 = 10$ meters per second.\n  - Rotor diameter: $D = 100$ meters.\n  - Air density: $\\rho = 1.225$ kilograms per cubic meter.\n  - Power coefficient: $C_p = 0.4$.\n  - Axial induction factor: $a = \\tfrac{1}{3}$.\n  - Wake decay constant: $k = 0.03$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of test cases $\\{1,2,3\\}$, for example, `[result1,result2,result3]`. Each result must be an integer in Watts obtained by rounding the optimal total power for its test case to the nearest integer.", "solution": "The problem statement is subjected to validation.\n\nStep 1: Extract Givens\n- Decision variables: $z_n \\in \\{0,1\\}$ for each candidate site $n$. $z_n=1$ if a turbine is placed, $z_n=0$ otherwise.\n- Cardinality constraint: Exactly $T$ turbines must be installed, $\\sum_n z_n = T$.\n- Spacing constraint: For any two selected sites $n \\neq m$ (i.e., $z_n=1, z_m=1$), the Euclidean distance $d_{nm}$ must satisfy $d_{nm} \\ge s_{\\min}$.\n- Candidate site coordinates: $(x_n, y_n)$ in meters.\n- Wind direction: Fixed, aligned with the positive $x$-axis.\n- Free-stream wind speed: $V_0$ (m/s).\n- Rotor diameter: $D$ (m).\n- Rotor swept area: $A = \\pi (D/2)^2$ (m$^2$).\n- Air density: $\\rho$ (kg/m$^3$).\n- Power coefficient: $C_p$ (dimensionless).\n- Axial induction factor: $a$ (dimensionless).\n- Wake decay constant: $k$ (dimensionless).\n- Wake model:\n  - Streamwise separation: $d_{ji} = x_i - x_j$ for $x_j < x_i$.\n  - Lateral separation: $s_{ji} = |y_i - y_j|$.\n  - Wake radius: $r_{ji} = D/2 + k\\,d_{ji}$.\n  - Wake influence condition: Turbine $j$ influences $i$ if $x_j < x_i$ and $s_{ji} \\le r_{ji}$.\n  - Single-wake velocity deficit: $\\delta_{j\\to i} = \\frac{2a}{(1 + \\frac{2k\\, d_{ji}}{D})^2}$.\n  - Wake superposition: Root-sum-square.\n  - Effective wind speed at turbine $i$: $V_i = V_0 (1 - \\sqrt{\\sum_{j\\in \\mathcal{U}(i)} \\delta_{j\\to i}^2})$, where $\\mathcal{U}(i)$ is the set of upwind turbines influencing $i$. $V_i$ is clipped at $0$.\n- Power calculation: $P_i = \\frac{1}{2}\\,\\rho\\, A\\, C_p\\, V_i^3$.\n- Objective function: Maximize total power $\\sum_{i=1}^{M} z_i P_i(z)$, where $M$ is the total number of sites.\n- Test Cases:\n  - Test case $1$: Candidate grid $x \\in \\{0, 300, 600, 900\\}$ m, $y \\in \\{0, 300, 600\\}$ m. $T=4$, $s_{\\min}=300$ m, $V_0=12$ m/s, $D=100$ m, $\\rho=1.225$ kg/m$^3$, $C_p=0.4$, $a=1/3$, $k=0.05$.\n  - Test case $2$: Candidate grid $x \\in \\{0, 200, 400\\}$ m, $y \\in \\{0, 200, 400\\}$ m. $T=1$, $s_{\\min}=300$ m, $V_0=8$ m/s, $D=100$ m, $\\rho=1.225$ kg/m$^3$, $C_p=0.4$, $a=1/3$, $k=0.05$.\n  - Test case $3$: Candidate grid $x \\in \\{0, 300, 600, 900\\}$ m, $y \\in \\{0, 300, 600\\}$ m. $T=5$, $s_{\\min}=300$ m, $V_0=10$ m/s, $D=100$ m, $\\rho=1.225$ kg/m$^3$, $C_p=0.4$, $a=1/3$, $k=0.03$.\n- Output requirement: Total power in Watts, rounded to the nearest integer.\n\nStep 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on the established Jensen (Park) wake model, a standard simplification in wind energy engineering. The power equation is fundamental physics. All models and parameters are physically meaningful and scientifically sound.\n- **Well-Posed**: The problem is a combinatorial optimization task. The search space consists of all possible placements of $T$ turbines on $M$ discrete sites. This space is finite. The objective function (total power) is well-defined for any given placement. Therefore, a maximum value is guaranteed to exist. The problem is well-posed.\n- **Objective**: The problem is specified using precise mathematical equations and unambiguous physical parameters. It is free from subjective or opinion-based statements.\n- **Completeness and Consistency**: All necessary data and models for calculating the objective function are provided for each test case. The constraints are clearly stated. A careful analysis of the minimum spacing constraint reveals it is non-restrictive for test cases $1$ and $3$, as the minimum distance between any two distinct sites is $300$ m, which equals $s_{\\min}$. For test case $2$, the constraint is non-trivial for pairs, but vacuously satisfied since only $T=1$ turbine is placed. This does not represent a contradiction but rather a specific setup for the test cases. The problem is self-contained and consistent.\n\nStep 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\nThe problem is one of facility location, a classic problem in combinatorial optimization. The goal is to select a subset of $T$ sites from a total of $M$ candidate sites to maximize an objective function, subject to certain constraints. Given the small number of candidate sites ($M=12$ for cases $1$ and $3$, $M=9$ for case $2$) and the small number of turbines to be placed ($T \\in \\{1, 4, 5\\}$), an exhaustive search of all possible valid layouts is a feasible and correct solution strategy.\n\nThe algorithm proceeds as follows:\n$1$. For each test case, generate the set of $M$ candidate site coordinates $(x_n, y_n)$ from the specified grids.\n$2$. Generate all possible combinations of placing $T$ turbines among the $M$ sites. The number of such combinations is given by the binomial coefficient $\\binom{M}{T}$.\n$3$. For each combination (representing a potential wind farm layout), verify that it satisfies the minimum spacing constraint. A layout is valid if for every pair of selected turbine sites $i$ and $j$, their Euclidean distance $\\sqrt{(x_i-x_j)^2 + (y_i-y_j)^2}$ is greater than or equal to $s_{\\min}$. As noted, for the provided test cases, this constraint does not eliminate any combinations.\n$4$. For each valid layout, calculate the total power output. This is the evaluation of the objective function. This calculation itself involves several steps:\n    a. For each turbine $i$ in the layout, its power output $P_i$ is determined by the effective wind speed $V_i$ at its location.\n    b. To find $V_i$, one must first account for the wake effects from all upwind turbines. A turbine $j$ is upwind of $i$ if $x_j < x_i$.\n    c. For each upwind turbine $j$, we check if turbine $i$ lies within its wake. This is true if the lateral separation $s_{ji} = |y_i - y_j|$ is no more than the wake radius at that downwind distance, $r_{ji} = D/2 + k(x_i - x_j)$.\n    d. If turbine $i$ is in the wake of one or more upwind turbines $j \\in \\mathcal{U}(i)$, the individual velocity deficits $\\delta_{j\\to i} = \\frac{2a}{(1 + 2k(x_i - x_j)/D)^2}$ are computed.\n    e. These deficits are combined using the root-sum-square method to find the total fractional velocity loss: $\\sqrt{\\sum_{j \\in \\mathcal{U}(i)} \\delta_{j\\to i}^2}$.\n    f. The effective wind speed is then $V_i = V_0 \\max(0, 1 - \\sqrt{\\sum_{j \\in \\mathcal{U}(i)} \\delta_{j\\to i}^2})$. If there are no upwind turbines affecting $i$, then $V_i = V_0$.\n    g. The power from turbine $i$ is calculated using the standard formula $P_i = \\frac{1}{2} \\rho A C_p V_i^3$, where $A = \\pi(D/2)^2$.\n    h. The total power for the layout is the sum of the power from all turbines: $P_{total} = \\sum_i P_i$.\n$5$. The maximum total power found across all valid layouts is the optimal solution for the test case. This final value is then rounded to the nearest integer, as required.\n\nThis brute-force enumeration guarantees finding the global maximum because it exhaustively checks every single possibility in the finite solution space. The computation is executed for each of the three test cases to find their respective optimal power outputs.", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the wind farm layout optimization problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"case_id\": 1,\n            \"x_grid\": [0, 300, 600, 900], # meters\n            \"y_grid\": [0, 300, 600], # meters\n            \"T\": 4, # number of turbines\n            \"s_min\": 300.0, # meters\n            \"V0\": 12.0, # m/s\n            \"D\": 100.0, # meters\n            \"rho\": 1.225, # kg/m^3\n            \"Cp\": 0.4,\n            \"a\": 1/3,\n            \"k\": 0.05,\n        },\n        {\n            \"case_id\": 2,\n            \"x_grid\": [0, 200, 400], # meters\n            \"y_grid\": [0, 200, 400], # meters\n            \"T\": 1,\n            \"s_min\": 300.0,\n            \"V0\": 8.0,\n            \"D\": 100.0,\n            \"rho\": 1.225,\n            \"Cp\": 0.4,\n            \"a\": 1/3,\n            \"k\": 0.05,\n        },\n        {\n            \"case_id\": 3,\n            \"x_grid\": [0, 300, 600, 900], # meters\n            \"y_grid\": [0, 300, 600], # meters\n            \"T\": 5,\n            \"s_min\": 300.0,\n            \"V0\": 10.0,\n            \"D\": 100.0,\n            \"rho\": 1.225,\n            \"Cp\": 0.4,\n            \"a\": 1/3,\n            \"k\": 0.03,\n        }\n    ]\n\n    results = []\n\n    for params in test_cases:\n        # Unpack parameters\n        x_grid = params[\"x_grid\"]\n        y_grid = params[\"y_grid\"]\n        T = params[\"T\"]\n        s_min = params[\"s_min\"]\n        V0 = params[\"V0\"]\n        D = params[\"D\"]\n        rho = params[\"rho\"]\n        Cp = params[\"Cp\"]\n        a = params[\"a\"]\n        k = params[\"k\"]\n        \n        # Generate candidate sites\n        sites = np.array([(x, y) for y in y_grid for x in x_grid])\n        num_sites = len(sites)\n        \n        # Rotor swept area\n        A = np.pi * (D / 2.0)**2\n        power_constant = 0.5 * rho * A * Cp\n\n        max_power = 0.0\n\n        # Generate all combinations of T sites\n        site_indices = range(num_sites)\n        for placement_indices in itertools.combinations(site_indices, T):\n            \n            # 1. Check spacing constraint\n            is_valid_spacing = True\n            if T > 1:\n                for i, j in itertools.combinations(placement_indices, 2):\n                    dist = np.linalg.norm(sites[i] - sites[j])\n                    if dist < s_min:\n                        is_valid_spacing = False\n                        break\n            \n            if not is_valid_spacing:\n                continue\n\n            # 2. Calculate total power for the valid layout\n            total_power = 0.0\n            placement_sites = sites[list(placement_indices)]\n\n            for i in range(T):\n                turbine_i_pos = placement_sites[i]\n                xi, yi = turbine_i_pos[0], turbine_i_pos[1]\n                \n                sum_deficit_sq = 0.0\n                \n                # Consider wake effects from other turbines in the placement\n                for j in range(T):\n                    if i == j:\n                        continue\n                    \n                    turbine_j_pos = placement_sites[j]\n                    xj, yj = turbine_j_pos[0], turbine_j_pos[1]\n\n                    # Check if turbine j is upwind of i\n                    if xj < xi:\n                        d_ji = xi - xj\n                        s_ji = np.abs(yi - yj)\n                        \n                        # Calculate wake radius\n                        r_ji = D / 2.0 + k * d_ji\n                        \n                        # Check if i is in the wake of j\n                        if s_ji <= r_ji:\n                            deficit = (2.0 * a) / (1.0 + (2.0 * k * d_ji) / D)**2\n                            sum_deficit_sq += deficit**2\n                \n                # Calculate effective wind speed at turbine i\n                velocity_loss_factor = np.sqrt(sum_deficit_sq)\n                Vi = V0 * (1.0 - velocity_loss_factor)\n                Vi = max(0.0, Vi)\n                \n                # Calculate power from turbine i\n                power_i = power_constant * Vi**3\n                total_power += power_i\n            \n            if total_power > max_power:\n                max_power = total_power\n\n        results.append(int(round(max_power)))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2394774"}]}