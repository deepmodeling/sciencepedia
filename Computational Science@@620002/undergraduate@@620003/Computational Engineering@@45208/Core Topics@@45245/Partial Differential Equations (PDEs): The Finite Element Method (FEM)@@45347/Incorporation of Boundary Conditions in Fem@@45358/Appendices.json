{"hands_on_practices": [{"introduction": "In engineering analysis, loads are rarely simple point forces. More often, we encounter distributed tractions like fluid pressure or wind load. This exercise guides you through a foundational skill in FEM: converting a continuous, distributed load into a set of discrete nodal forces that are energetically equivalent. This \"consistent nodal load\" vector ensures that the work done by the discrete forces accurately represents the work done by the real-world distributed pressure, a key principle for accurate simulation [@problem_id:2402844]. By working through the classic example of hydrostatic pressure on a dam, you will master the essential integration required to handle non-uniform Neumann boundary conditions.", "problem": "A vertical concrete dam is modeled in two dimensions under plane strain with unit out-of-plane thickness. The upstream water face coincides with the global line $x=0$ from the free surface at $z=0$ to depth $z=H$. The coordinate system is defined with $x$ horizontal pointing into the dam and $z$ vertical downward from the free surface. The hydrostatic pressure exerted by the water on the dam is $p(z)=\\rho g z$, where $\\rho$ is the fluid density and $g$ is the gravitational acceleration. The pressure acts normal to the face and into the dam.\n\nConsider a single straight boundary finite element along the upstream face, connecting node $1$ at $(x,z)=(0,0)$ and node $2$ at $(x,z)=(0,H)$. Use a linear interpolation along this boundary segment with nodal degrees of freedom ordered as $\\big[u_{1x},u_{1z},u_{2x},u_{2z}\\big]$. Determine the consistent equivalent nodal force vector for this boundary element in global components, expressed as a row vector $\\big[F_{1x},F_{1z},F_{2x},F_{2z}\\big]$ in terms of $\\rho$, $g$, and $H$.\n\nExpress the final result in Newton per unit out-of-plane thickness. Provide your answer as a single row matrix. No rounding is required.", "solution": "The problem statement will first be subjected to a rigorous validation to ascertain its scientific and logical integrity.\n\n**Step 1: Extract Givens**\n\n*   **Model**: A two-dimensional vertical concrete dam under plane strain conditions, with a unit out-of-plane thickness.\n*   **Coordinate System**: The $x$-axis is horizontal, pointing into the dam. The $z$-axis is vertical, pointing downward from the water's free surface.\n*   **Geometry**: The upstream face of the dam is a vertical line at $x=0$, extending from the free surface at $z=0$ to a depth of $z=H$.\n*   **Loading**: A hydrostatic pressure $p(z) = \\rho g z$ is exerted by the water on the upstream face, where $\\rho$ is the fluid density and $g$ is the gravitational acceleration. The pressure acts normal to the face and into the dam.\n*   **Finite Element Discretization**: A single straight boundary element is used to model the upstream face. This element connects node $1$ at $(x,z)=(0,0)$ and node $2$ at $(x,z)=(0,H)$.\n*   **Interpolation**: Linear interpolation is used along the boundary element.\n*   **Degrees of Freedom**: The nodal degrees of freedom are ordered as the vector $\\big[u_{1x}, u_{1z}, u_{2x}, u_{2z}\\big]$.\n*   **Objective**: To determine the consistent equivalent nodal force vector for this boundary element, expressed as a row vector $\\big[F_{1x}, F_{1z}, F_{2x}, F_{2z}\\big]$ in terms of $\\rho$, $g$, and $H$. The result is to be in units of force per unit out-of-plane thickness.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is analyzed against the required criteria.\n\n*   **Scientifically Grounded**: The problem is a standard application of the Finite Element Method (FEM) in structural mechanics. The formula for hydrostatic pressure, $p(z) = \\rho g z$, is a fundamental principle of fluid statics. The concept of consistent nodal loads derived from the principle of virtual work is a core tenet of FEM. The setup is a valid and common simplification for analyzing dams.\n*   **Well-Posed**: The problem provides all necessary information—geometry, loading function, element type, shape functions (implied by \"linear interpolation\"), and degrees of freedom—to uniquely determine the equivalent nodal force vector.\n*   **Objective**: The problem is stated using precise, objective, and unambiguous technical language.\n\nThe problem does not exhibit any flaws. It is scientifically sound, well-posed, completely specified, and directly solvable using established principles of computational engineering.\n\n**Step 3: Verdict and Action**\n\nThe problem is deemed **valid**. A solution will be derived.\n\n**Derivation of the Solution**\n\nThe consistent equivalent nodal force vector, $\\mathbf{F}_e$, is derived by equating the virtual work done by the distributed traction vector, $\\mathbf{t}$, to the virtual work done by the nodal forces. The governing relationship is:\n$$ \\delta W_{ext} = \\int_{\\Gamma_e} (\\delta \\mathbf{u})^T \\mathbf{t} \\, d\\Gamma = (\\delta \\mathbf{d}_e)^T \\mathbf{F}_e $$\nwhere $\\Gamma_e$ is the boundary of the element, $\\delta \\mathbf{u}$ is the virtual displacement field along the boundary, and $\\delta \\mathbf{d}_e$ is the vector of virtual nodal displacements.\n\nThe displacement field, $\\mathbf{u}(z)$, along the element is interpolated from the nodal displacements, $\\mathbf{d}_e = \\begin{pmatrix} u_{1x} & u_{1z} & u_{2x} & u_{2z} \\end{pmatrix}^T$, using linear shape functions. The element extends from $z=0$ to $z=H$. The linear shape functions in terms of the vertical coordinate $z$ are:\n$$ N_1(z) = 1 - \\frac{z}{H} $$\n$$ N_2(z) = \\frac{z}{H} $$\nThe displacement vector $\\mathbf{u}(z) = \\begin{pmatrix} u_x(z) \\\\ u_z(z) \\end{pmatrix}$ can be written in matrix form as:\n$$ \\mathbf{u}(z) = \\begin{bmatrix} N_1(z) & 0 & N_2(z) & 0 \\\\ 0 & N_1(z) & 0 & N_2(z) \\end{bmatrix} \\mathbf{d}_e = \\mathbf{N}(z) \\mathbf{d}_e $$\nwhere $\\mathbf{N}(z)$ is the shape function matrix. The virtual displacement field is then $\\delta\\mathbf{u}(z) = \\mathbf{N}(z) \\delta\\mathbf{d}_e$.\n\nSubstituting this into the virtual work equation gives:\n$$ (\\delta \\mathbf{d}_e)^T \\mathbf{F}_e = \\int_{\\Gamma_e} (\\mathbf{N}(z) \\delta\\mathbf{d}_e)^T \\mathbf{t}(z) \\, d\\Gamma = (\\delta \\mathbf{d}_e)^T \\int_{\\Gamma_e} \\mathbf{N}(z)^T \\mathbf{t}(z) \\, d\\Gamma $$\nSince this equality must hold for any arbitrary virtual nodal displacement vector $\\delta\\mathbf{d}_e$, we can deduce the expression for the equivalent nodal force vector:\n$$ \\mathbf{F}_e = \\int_{\\Gamma_e} \\mathbf{N}(z)^T \\mathbf{t}(z) \\, d\\Gamma $$\nThe pressure $p(z) = \\rho g z$ acts normal to the dam face and into the structure. The dam face is at $x=0$, so the force is directed along the positive $x$-axis. The traction vector $\\mathbf{t}(z)$ is therefore:\n$$ \\mathbf{t}(z) = \\begin{pmatrix} p(z) \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} \\rho g z \\\\ 0 \\end{pmatrix} $$\nThe integral is performed along the element's length, so $d\\Gamma = dz$ and the integration limits are from $z=0$ to $z=H$. The integral is performed per unit out-of-plane thickness, as specified.\n\nWe compute the product $\\mathbf{N}(z)^T \\mathbf{t}(z)$:\n$$ \\mathbf{N}(z)^T \\mathbf{t}(z) = \\begin{bmatrix} N_1(z) & 0 \\\\ 0 & N_1(z) \\\\ N_2(z) & 0 \\\\ 0 & N_2(z) \\end{bmatrix} \\begin{pmatrix} \\rho g z \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} N_1(z) \\rho g z \\\\ 0 \\\\ N_2(z) \\rho g z \\\\ 0 \\end{pmatrix} $$\nSubstituting the expressions for the shape functions:\n$$ \\mathbf{N}(z)^T \\mathbf{t}(z) = \\begin{pmatrix} (1 - \\frac{z}{H}) \\rho g z \\\\ 0 \\\\ (\\frac{z}{H}) \\rho g z \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} \\rho g (z - \\frac{z^2}{H}) \\\\ 0 \\\\ \\frac{\\rho g z^2}{H} \\\\ 0 \\end{pmatrix} $$\nNow, we integrate this vector from $z=0$ to $z=H$ to find the components of $\\mathbf{F}_e = \\begin{pmatrix} F_{1x} & F_{1z} & F_{2x} & F_{2z} \\end{pmatrix}^T$.\n\nThe first component, $F_{1x}$, is:\n$$ F_{1x} = \\int_{0}^{H} \\rho g \\left(z - \\frac{z^2}{H}\\right) dz = \\rho g \\left[ \\frac{z^2}{2} - \\frac{z^3}{3H} \\right]_{0}^{H} = \\rho g \\left( \\frac{H^2}{2} - \\frac{H^3}{3H} \\right) = \\rho g \\left( \\frac{H^2}{2} - \\frac{H^2}{3} \\right) = \\frac{1}{6} \\rho g H^2 $$\nThe second component, $F_{1z}$, is:\n$$ F_{1z} = \\int_{0}^{H} 0 \\, dz = 0 $$\nThe third component, $F_{2x}$, is:\n$$ F_{2x} = \\int_{0}^{H} \\frac{\\rho g z^2}{H} dz = \\frac{\\rho g}{H} \\left[ \\frac{z^3}{3} \\right]_{0}^{H} = \\frac{\\rho g}{H} \\left( \\frac{H^3}{3} \\right) = \\frac{1}{3} \\rho g H^2 $$\nThe fourth component, $F_{2z}$, is:\n$$ F_{2z} = \\int_{0}^{H} 0 \\, dz = 0 $$\nThe resulting consistent equivalent nodal force vector is $\\mathbf{F}_e = \\begin{pmatrix} \\frac{1}{6} \\rho g H^2 \\\\ 0 \\\\ \\frac{1}{3} \\rho g H^2 \\\\ 0 \\end{pmatrix}$.\nThe problem requests the result as a row vector $\\big[F_{1x}, F_{1z}, F_{2x}, F_{2z}\\big]$.\nThus, the final answer is $\\left[ \\frac{1}{6} \\rho g H^2, 0, \\frac{1}{3} \\rho g H^2, 0 \\right]$.\n\nA brief verification confirms the result. The total horizontal force is $\\int_{0}^{H} \\rho g z \\, dz = \\frac{1}{2} \\rho g H^2$. The sum of the nodal forces is $F_{1x} + F_{2x} = \\frac{1}{6} \\rho g H^2 + \\frac{1}{3} \\rho g H^2 = \\frac{1}{2} \\rho g H^2$. The total force is conserved.\nThe moment about node $1$ (at $z=0$) produced by the pressure is $\\int_{0}^{H} z (\\rho g z) \\, dz = \\frac{1}{3} \\rho g H^3$. The moment from the nodal forces is $H \\cdot F_{2x} = H \\cdot (\\frac{1}{3} \\rho g H^2) = \\frac{1}{3} \\rho g H^3$. The moment is also conserved. The derivation is correct.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{6} \\rho g H^{2} & 0 & \\frac{1}{3} \\rho g H^{2} & 0\n\\end{pmatrix}\n}\n$$", "id": "2402844"}, {"introduction": "Moving from by-hand calculations to a full simulation, this practice challenges you to implement a complete FEM solver for a problem with complex boundary requirements. Real-world scenarios often involve different types of conditions on various parts of the boundary, and sometimes even on the same edge. This coding exercise focuses on implementing these mixed boundary conditions, forcing a clear distinction between how essential (Dirichlet) and natural (Neumann) conditions are treated in the code [@problem_id:2402813]. You will learn to enforce Dirichlet conditions by directly modifying the algebraic system, while seeing how homogeneous Neumann conditions are elegantly handled by the underlying weak formulation with no extra effort.", "problem": "You are asked to design and implement a two-dimensional Finite Element Method (FEM) solver to demonstrate the incorporation of mixed boundary conditions on a single boundary edge, using only first principles. The setting is the unit square domain $\\Omega = [0,1] \\times [0,1]$ and the scalar Poisson equation with a uniform source term. Your task is to derive the appropriate weak form, design a linear triangular element discretization, and implement the mixed boundary condition where the bottom boundary is split into two parts: a Dirichlet part on the left fraction and a Neumann part on the right fraction. You must ensure the implementation is correct for different mesh resolutions and split positions.\n\nStart from the strong form partial differential equation (PDE)\n$$\n- \\nabla \\cdot \\left( \\nabla u \\right) = f \\quad \\text{in } \\Omega,\n$$\nwith the uniform source $f(x,y) = 1$. The boundary $\\partial \\Omega$ is decomposed as follows:\n- On the left boundary $\\{0\\} \\times [0,1]$, right boundary $\\{1\\} \\times [0,1]$, and top boundary $[0,1] \\times \\{1\\}$, impose the homogeneous Dirichlet boundary condition $u = 0$.\n- On the bottom boundary $[0,1] \\times \\{0\\}$, impose a mixed boundary condition defined by a split parameter $s \\in [0,1]$:\n  - For $x \\in [0,s]$, impose the homogeneous Dirichlet boundary condition $u = 0$.\n  - For $x \\in (s,1]$, impose the homogeneous Neumann boundary condition $\\frac{\\partial u}{\\partial n} = 0$.\n\nYour solution must:\n- Derive the Galerkin weak form starting from the strong form and the divergence theorem, clearly identifying how Dirichlet and Neumann boundary conditions enter the formulation from first principles.\n- Discretize $\\Omega$ with a structured triangular mesh formed by splitting each rectangle of a uniform $(N_x \\times N_y)$ grid along one diagonal into two triangles, using linear shape functions on each triangle.\n- Assemble the global stiffness matrix and load vector using exact element integrals for linear triangles and constant $f$. Enforce Dirichlet boundary conditions strongly on the corresponding nodes (row and column modification with prescribed values), and treat the homogeneous Neumann condition naturally (no contribution to the load on that boundary).\n- Compute the domain-averaged solution value\n$$\n\\bar{u} = \\frac{1}{|\\Omega|} \\int_{\\Omega} u(x,y) \\, d\\Omega,\n$$\nwhere $|\\Omega| = 1$. Use exact element formulas for linear triangles to compute $\\int_T u \\, d\\Omega$.\n\nYour program must implement and run the following test suite without requiring any user input:\n- Test case $1$: $N_x = 8$, $N_y = 8$, $s = 0.5$.\n- Test case $2$: $N_x = 9$, $N_y = 7$, $s = \\frac{1}{3}$.\n- Test case $3$: $N_x = 10$, $N_y = 10$, $s = 0$.\n- Test case $4$: $N_x = 6$, $N_y = 12$, $s = 1$.\n\nFor each test case, return a single floating-point number equal to $\\bar{u}$, rounded to $6$ decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[a_1,a_2,a_3,a_4]$). No physical units are required. Angles are not used. Percentages are not used. The output must be exactly one line with this format.", "solution": "The problem is subjected to validation and is found to be valid. It is a well-posed problem statement from computational engineering, providing all necessary information to formulate and solve for the requested quantity. It is scientifically grounded, objective, and contains no contradictions or ambiguities.\n\nThe task is to solve the two-dimensional Poisson equation with a constant source term on a unit square domain using the Finite Element Method (FEM). The boundary conditions are mixed, with a split condition on the bottom edge.\n\nThe governing partial differential equation (PDE), or strong form, is:\n$$\n- \\nabla \\cdot \\left( \\nabla u \\right) = f \\quad \\text{in } \\Omega = [0,1] \\times [0,1]\n$$\nwhere the source term is $f(x,y) = 1$. The boundary $\\partial \\Omega$ is partitioned into a Dirichlet boundary $\\Gamma_D$ and a Neumann boundary $\\Gamma_N$.\nThe boundary conditions are:\n1.  Homogeneous Dirichlet condition, $u = 0$, on the left, right, top, and the left portion of the bottom boundary. Specifically, $\\Gamma_D = (\\{0\\} \\times [0,1]) \\cup (\\{1\\} \\times [0,1]) \\cup ([0,1] \\times \\{1\\}) \\cup ([0,s] \\times \\{0\\})$.\n2.  Homogeneous Neumann condition, $\\frac{\\partial u}{\\partial n} = \\nabla u \\cdot \\mathbf{n} = 0$, on the right portion of the bottom boundary. Specifically, $\\Gamma_N = ((s,1] \\times \\{0\\})$.\n\n**1. Derivation of the Weak Form**\n\nTo derive the weak form, we multiply the PDE by a test function $v$ and integrate over the domain $\\Omega$:\n$$\n- \\int_{\\Omega} (\\nabla^2 u) v \\, d\\Omega = \\int_{\\Omega} f v \\, d\\Omega\n$$\nWe apply Green's first identity, a form of integration by parts, to the left-hand side term:\n$$\n\\int_{\\Omega} (\\nabla u \\cdot \\nabla v) \\, d\\Omega - \\int_{\\partial \\Omega} (\\nabla u \\cdot \\mathbf{n}) v \\, dS = \\int_{\\Omega} f v \\, d\\Omega\n$$\nRearranging gives the general weak form:\n$$\n\\int_{\\Omega} (\\nabla u \\cdot \\nabla v) \\, d\\Omega = \\int_{\\Omega} f v \\, d\\Omega + \\int_{\\partial \\Omega} \\frac{\\partial u}{\\partial n} v \\, dS\n$$\nThe trial function $u$ must belong to a function space that is sufficiently smooth and satisfies the Dirichlet boundary conditions. The test function $v$ is chosen from a corresponding space but must vanish where Dirichlet conditions are specified. Thus, for our problem, $v=0$ on $\\Gamma_D$. The boundary integral can be split over the Dirichlet and Neumann parts:\n$$\n\\int_{\\partial \\Omega} \\frac{\\partial u}{\\partial n} v \\, dS = \\int_{\\Gamma_D} \\frac{\\partial u}{\\partial n} v \\, dS + \\int_{\\Gamma_N} \\frac{\\partial u}{\\partial n} v \\, dS\n$$\nThe first term is zero because $v=0$ on $\\Gamma_D$. The second term is also zero because the prescribed Neumann condition on $\\Gamma_N$ is homogeneous, $\\frac{\\partial u}{\\partial n} = 0$. Therefore, the entire boundary integral vanishes. This is referred to as the \"natural\" incorporation of the homogeneous Neumann boundary condition; it does not introduce any new terms into the final equation.\n\nThe final weak form is to find $u \\in V$ such that for all $v \\in V_0$:\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} f v \\, d\\Omega\n$$\nwhere $V = \\{u \\in H^1(\\Omega) | u=0 \\text{ on } \\Gamma_D\\}$ and $V_0 = \\{v \\in H^1(\\Omega) | v=0 \\text{ on } \\Gamma_D\\}$.\n\n**2. Finite Element Discretization**\n\nWe discretize the domain $\\Omega$ into a mesh of triangular elements. Within each element, the solution $u$ is approximated by a linear combination of basis functions (or shape functions) $N_j$:\n$$\nu(x,y) \\approx u_h(x,y) = \\sum_{j=1}^{N_{nodes}} U_j N_j(x,y)\n$$\nwhere $U_j$ are the unknown solution values at the nodes of the mesh. A Galerkin approach uses the same basis functions as test functions, $v = N_i$. Substituting the approximation $u_h$ into the weak form and testing against each basis function $N_i$ yields a system of linear equations $KU=F$:\n$$\n\\sum_{j=1}^{N_{nodes}} \\left( \\int_{\\Omega} \\nabla N_j \\cdot \\nabla N_i \\, d\\Omega \\right) U_j = \\int_{\\Omega} f N_i \\, d\\Omega \\quad \\text{for } i=1, \\dots, N_{nodes}\n$$\nThe components of the global stiffness matrix $K$ and load vector $F$ are:\n$$\nK_{ij} = \\int_{\\Omega} \\nabla N_j \\cdot \\nabla N_i \\, d\\Omega \\quad \\text{and} \\quad F_i = \\int_{\\Omega} f N_i \\, d\\Omega\n$$\nFor a linear triangular element (P1 element) with vertices $(x_1, y_1), (x_2, y_2), (x_3, y_3)$ and area $A$, the shape functions are linear. Their gradients $\\nabla N_k$ are constant over the element. The element stiffness matrix $K^e$ can be computed exactly. For nodes $i,j \\in \\{1,2,3\\}$ of the element:\n$$\nK^e_{ij} = \\int_{T_e} \\nabla N_j \\cdot \\nabla N_i \\, d\\Omega = \\frac{1}{4A} (b_i b_j + c_i c_j)\n$$\nwhere $b_k = y_j - y_m$ and $c_k = x_m - x_j$ with cyclic permutation on indices $(k,j,m)$. Since the source term $f=1$ is constant, the element load vector $F^e$ is also computed exactly:\n$$\nF^e_i = \\int_{T_e} (1) N_i \\, d\\Omega = \\frac{A}{3}\n$$\n\n**3. Assembly and Boundary Conditions**\n\nThe global stiffness matrix $K$ and load vector $F$ are assembled by summing the contributions from all element matrices $K^e$ and vectors $F^e$. The domain is discretized into a structured grid of $N_x \\times N_y$ rectangles, each split into two triangles.\n\n- **Homogeneous Neumann Condition:** As established, this condition is natural and is handled by the weak form itself. No modification to the assembled $K$ and $F$ is required for nodes located on $\\Gamma_N$.\n\n- **Homogeneous Dirichlet Condition:** This condition is enforced \"strongly\" by modifying the linear system. For each node $k$ on the Dirichlet boundary $\\Gamma_D$, we must enforce $U_k = 0$. This is achieved by the specified row and column modification method. For each Dirichlet node $k$, the $k$-th row and $k$-th column of the stiffness matrix $K$ are set to zero, the diagonal entry $K_{kk}$ is set to $1$, and the corresponding entry $F_k$ in the load vector is set to $0$. This procedure isolates the equations for the Dirichlet nodes to $1 \\cdot U_k = 0$, while correctly adjusting the system for the remaining unknown (\"free\") nodal values. Since the prescribed value is zero, no modification of other entries in $F$ is needed.\n\n**4. Computation of the Averaged Solution**\n\nAfter solving the system $KU=F$ for the nodal values $U$, the domain-averaged solution $\\bar{u}$ is computed. Since the domain area $|\\Omega|=1$, this is equal to the integral of the solution over the domain. The integral is evaluated as a sum of integrals over each element:\n$$\n\\bar{u} = \\int_{\\Omega} u_h \\, d\\Omega = \\sum_{e \\in \\text{mesh}} \\int_{T_e} u_h^e \\, d\\Omega\n$$\nFor a linear triangular element, the integral is the product of the element's area and the average of its nodal values:\n$$\n\\int_{T_e} u_h^e \\, d\\Omega = \\int_{T_e} \\sum_{k=1}^3 U_k^e N_k^e \\, d\\Omega = \\frac{A_e}{3} \\sum_{k=1}^3 U_k^e\n$$\nSumming these contributions over all elements yields the final value for $\\bar{u}$.", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef calculate_element_matrices(coords):\n    \"\"\"\n    Calculates the element stiffness matrix and load vector for a linear triangular element.\n\n    Args:\n        coords (np.ndarray): A 3x2 array of the element's nodal coordinates.\n\n    Returns:\n        tuple: A tuple containing:\n            - Ke (np.ndarray): The 3x3 element stiffness matrix.\n            - Fe (np.ndarray): The 3x1 element load vector.\n            - area (float): The area of the element.\n    \"\"\"\n    p1, p2, p3 = coords[0, :], coords[1, :], coords[2, :]\n    \n    # Area calculation using the determinant of the coordinate matrix\n    mat = np.array([[1.0, p1[0], p1[1]], \n                    [1.0, p2[0], p2[1]], \n                    [1.0, p3[0], p3[1]]])\n    area = 0.5 * np.linalg.det(mat)\n\n    # b_k = y_j - y_m, c_k = x_m - x_j (cyclic permutation)\n    b = np.array([p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]])\n    c = np.array([p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]])\n\n    # Element stiffness matrix: K^e_ij = (b_i*b_j + c_i*c_j) / (4*A)\n    Ke = (np.outer(b, b) + np.outer(c, c)) / (4.0 * area)\n\n    # Element load vector for f=1: F^e_i = integral(1 * N_i dOmega) = A / 3\n    Fe = np.full(3, area / 3.0)\n\n    return Ke, Fe, area\n\ndef solve_fem_poisson(Nx, Ny, s):\n    \"\"\"\n    Solves the 2D Poisson equation on a unit square with mixed boundary conditions.\n\n    Args:\n        Nx (int): Number of elements in the x-direction.\n        Ny (int): Number of elements in the y-direction.\n        s (float): Split parameter for the bottom boundary condition.\n\n    Returns:\n        float: The domain-averaged solution value.\n    \"\"\"\n    # 1. Mesh Generation\n    hx = 1.0 / Nx\n    hy = 1.0 / Ny\n    num_nodes = (Nx + 1) * (Ny + 1)\n\n    nodes = np.zeros((num_nodes, 2))\n    for j in range(Ny + 1):\n        for i in range(Nx + 1):\n            node_idx = i + j * (Nx + 1)\n            nodes[node_idx] = [i * hx, j * hy]\n\n    elements = []\n    for j in range(Ny):\n        for i in range(Nx):\n            n1 = i + j * (Nx + 1)        # bottom-left\n            n2 = (i + 1) + j * (Nx + 1)  # bottom-right\n            n3 = (i + 1) + (j + 1) * (Nx + 1) # top-right\n            n4 = i + (j + 1) * (Nx + 1)  # top-left\n            elements.append([n1, n2, n3]) # Triangle 1\n            elements.append([n1, n3, n4]) # Triangle 2\n    \n    # 2. Assembly\n    K = lil_matrix((num_nodes, num_nodes))\n    F = np.zeros(num_nodes)\n\n    for el_nodes_indices in elements:\n        coords = nodes[el_nodes_indices, :]\n        Ke, Fe, _ = calculate_element_matrices(coords)\n        \n        for local_i in range(3):\n            global_i = el_nodes_indices[local_i]\n            F[global_i] += Fe[local_i]\n            for local_j in range(3):\n                global_j = el_nodes_indices[local_j]\n                K[global_i, global_j] += Ke[local_i, local_j]\n    \n    # 3. Apply Boundary Conditions\n    dirichlet_nodes = set()\n    tolerance = 1e-9\n\n    # Left, Right, Top boundaries\n    for j in range(Ny + 1):\n        dirichlet_nodes.add(0 + j * (Nx + 1))      # x=0\n        dirichlet_nodes.add(Nx + j * (Nx + 1))   # x=1\n    for i in range(1, Nx):\n        dirichlet_nodes.add(i + Ny * (Nx + 1))   # y=1\n\n    # Bottom boundary split ([0,s] is Dirichlet)\n    for i in range(Nx + 1):\n        if nodes[i, 0] <= s + tolerance:\n            dirichlet_nodes.add(i)\n\n    # Row and column modification for homogeneous Dirichlet BC (u=0)\n    for node_idx in dirichlet_nodes:\n        # Since prescribed value is 0, no need to update F for other rows.\n        # F -= K[:, node_idx] * 0\n        K[node_idx, :] = 0.0\n        K[:, node_idx] = 0.0\n        K[node_idx, node_idx] = 1.0\n        F[node_idx] = 0.0\n\n    # 4. Solve the linear system\n    K_csc = K.tocsc()\n    U = spsolve(K_csc, F)\n    \n    # 5. Post-processing: Compute domain-averaged solution\n    total_integral = 0.0\n    for el_nodes_indices in elements:\n        coords = nodes[el_nodes_indices, :]\n        \n        # Re-calculate area (or store it during assembly)\n        p1, p2, p3 = coords[0, :], coords[1, :], coords[2, :]\n        mat = np.array([[1.0, p1[0], p1[1]], [1.0, p2[0], p2[1]], [1.0, p3[0], p3[1]]])\n        area = 0.5 * np.linalg.det(mat)\n        \n        u_vals = U[el_nodes_indices]\n        el_integral = (abs(area) / 3.0) * np.sum(u_vals)\n        total_integral += el_integral\n        \n    # Domain area is 1, so u_bar is the total_integral\n    return total_integral\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    test_cases = [\n        (8, 8, 0.5),\n        (9, 7, 1.0/3.0),\n        (10, 10, 0.0),\n        (6, 12, 1.0)\n    ]\n\n    results = []\n    for Nx, Ny, s in test_cases:\n        u_bar = solve_fem_poisson(Nx, Ny, s)\n        results.append(f\"{u_bar:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2402813"}, {"introduction": "Some engineering problems require constraints that go beyond simple nodal values or pressure distributions; for instance, we might need to enforce a specific average temperature or total flux across a boundary. This advanced hands-on practice introduces the powerful and versatile Lagrange multiplier method to handle such integral constraints. You will augment the standard FEM system with an additional unknown, the Lagrange multiplier, which can be interpreted physically as the reaction flux required to enforce the constraint [@problem_id:2402864]. Completing this exercise will equip you with a sophisticated technique to tackle a much broader class of complex, constrained boundary value problems in your future work.", "problem": "Consider the scalar heat conduction problem on the open unit square domain $\\Omega = (0,1)\\times(0,1)$ with boundary $\\partial\\Omega$. Let the thermal conductivity be a positive constant $\\kappa&gt;0$ and let the volumetric source be a constant $q$ over $\\Omega$. The unknown temperature field is $T:\\overline{\\Omega}\\to\\mathbb{R}$. The weak problem is: find $T$ such that\n$$\\int_{\\Omega} \\kappa\\, \\nabla T\\cdot \\nabla v \\, \\mathrm{d}\\Omega \\;=\\; \\int_{\\Omega} q\\, v \\, \\mathrm{d}\\Omega \\quad \\text{for all admissible } v,$$\nsubject to homogeneous natural boundary conditions on $\\partial\\Omega$ and the global boundary-averaged constraint on the right boundary edge $\\Gamma=\\{(x,y)\\in \\partial\\Omega \\mid x=1\\}$,\n$$\\frac{1}{L}\\int_{\\Gamma} T \\,\\mathrm{d}\\Gamma \\;=\\; T_{\\text{avg}},$$\nwhere $L$ is the geometric length of $\\Gamma$ and $T_{\\text{avg}}$ is a prescribed constant. All quantities are non-dimensional; no physical units are used anywhere in this problem.\n\nUsing the Finite Element Method (FEM) with continuous, piecewise linear shape functions on a uniform triangulation of $\\Omega$ obtained by subdividing $\\Omega$ into $N_x\\times N_y$ congruent rectangles and then splitting each rectangle into two triangles by a consistent diagonal, with $N_x=N_y=8$, enforce the average boundary constraint on $\\Gamma$ by introducing a single Lagrange multiplier. Define the discrete scalar unknown vector corresponding to nodal temperatures as $\\mathbf{T}\\in \\mathbb{R}^n$, the Lagrange multiplier as $\\lambda\\in \\mathbb{R}$, and use the standard Galerkin formulation for the bilinear and linear forms. Denote by $\\mathbf{B}\\in \\mathbb{R}^{1\\times n}$ the row vector whose entries are given by the appropriately scaled integrals of the nodal basis functions along $\\Gamma$ so that $\\mathbf{B}\\,\\mathbf{T} = \\frac{1}{L}\\int_{\\Gamma} T_h \\,\\mathrm{d}\\Gamma$, where $T_h$ is the finite element interpolant of $T$.\n\nYour task is to write a program that, for each test case described below, assembles the discrete linear system with the Lagrange multiplier enforcing the average constraint on $\\Gamma$, solves for $(\\mathbf{T},\\lambda)$, and reports two values per test case:\n- the absolute error between the computed average temperature on $\\Gamma$ and the prescribed $T_{\\text{avg}}$, namely $\\left|\\mathbf{B}\\,\\mathbf{T} - T_{\\text{avg}}\\right|$, and\n- the value of the Lagrange multiplier $\\lambda$.\n\nUse the following test suite of parameter triples $(\\kappa, q, T_{\\text{avg}})$:\n- Test $1$: $(\\kappa, q, T_{\\text{avg}}) = (1.0, 0.0, 2.0)$,\n- Test $2$: $(\\kappa, q, T_{\\text{avg}}) = (1.0, 1.0, 0.0)$,\n- Test $3$: $(\\kappa, q, T_{\\text{avg}}) = (2.5, 0.0, -1.0)$,\n- Test $4$: $(\\kappa, q, T_{\\text{avg}}) = (0.7, 0.5, 0.3)$.\n\nAll computations must be performed on the uniform mesh with $N_x=N_y=8$ as specified above. The right boundary $\\Gamma$ is the entire edge at $x=1$, and the homogeneous natural boundary condition applies on the remainder of $\\partial\\Omega$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in sequence, for each test $i$ from $1$ to $4$, first the absolute error $\\left|\\mathbf{B}\\,\\mathbf{T} - T_{\\text{avg}}\\right|$ and then the Lagrange multiplier $\\lambda$, both rounded to six decimal places. Concretely, the output must be of the form\n$$\\big[ \\text{err}_1, \\lambda_1, \\text{err}_2, \\lambda_2, \\text{err}_3, \\lambda_3, \\text{err}_4, \\lambda_4 \\big],$$\nwhere each entry is a decimal number with exactly six digits after the decimal point.", "solution": "The problem statement has been critically examined and is determined to be valid. It describes a well-posed boundary value problem for the Poisson equation, formulated using the Finite Element Method with a Lagrange multiplier to enforce an integral constraint. At first glance, the problem appears ill-posed for a non-zero source term $q$ due to the imposition of homogeneous natural boundary conditions on the entire boundary $\\partial\\Omega$. A standard pure Neumann problem requires that the integral of the source term over the domain must be zero for a solution to exist, a condition violated in test cases where $q \\neq 0$.\n\nHowever, the introduction of a Lagrange multiplier $\\lambda$ to enforce the constraint $\\frac{1}{L}\\int_{\\Gamma} T \\,\\mathrm{d}\\Gamma = T_{\\text{avg}}$ fundamentally alters the problem. The augmented weak formulation leads to a mixed boundary value problem where the natural boundary condition $\\kappa \\nabla T \\cdot \\mathbf{n} = 0$ applies only on $\\partial\\Omega \\setminus \\Gamma$, while on the constrained boundary $\\Gamma$, the condition becomes $\\kappa \\nabla T \\cdot \\mathbf{n} = -\\lambda/L$. In this case, the compatibility condition derived from the divergence theorem becomes $\\int_\\Omega q \\, \\mathrm{d}\\Omega = \\lambda$, which serves to define the value of the Lagrange multiplier. The solution $T$ is rendered unique by the integral constraint on $\\Gamma$. The problem is thus scientifically sound and internally consistent.\n\nThe solution proceeds by discretizing the governing equations using the Finite Element Method. The starting point is the saddle-point problem derived from minimizing the system's potential energy subject to the given constraint. Find $(T, \\lambda) \\in V \\times \\mathbb{R}$ such that:\n$$\n\\int_{\\Omega} \\kappa \\nabla T \\cdot \\nabla v \\, d\\Omega + \\lambda \\left( \\frac{1}{L} \\int_{\\Gamma} v \\, d\\Gamma \\right) = \\int_{\\Omega} q v \\, d\\Omega, \\quad \\forall v \\in V\n$$\n$$\n\\frac{1}{L} \\int_{\\Gamma} T \\, d\\Gamma = T_{\\text{avg}}\n$$\nHere, $V$ is a suitable function space for the temperature field, and $v$ is the test function.\n\nThe domain $\\Omega = (0,1)\\times(0,1)$ is discretized into a uniform mesh of $N_x \\times N_y = 8 \\times 8$ rectangular cells. Each rectangle is then divided into two linear triangular elements using a consistent diagonal, resulting in $128$ elements and $(N_x+1)(N_y+1) = 81$ nodes. The temperature field $T$ is approximated as a continuous, piecewise linear function $T_h = \\sum_{j=1}^{n} T_j N_j$, where $T_j$ are the unknown nodal temperatures and $N_j$ are the linear basis (hat) functions, with $n=81$.\n\nSubstituting the approximation $T_h$ into the weak formulation and choosing the test functions $v$ to be the basis functions $N_i$ for $i=1, \\dots, n$ yields a system of linear algebraic equations. This system is augmented with the discretized constraint equation, forming a block matrix system:\n$$\n\\begin{pmatrix}\n\\mathbf{K} & \\mathbf{B}^T \\\\\n\\mathbf{B} & 0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{T} \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{f} \\\\\nT_{\\text{avg}}\n\\end{pmatrix}\n$$\nwhere $\\mathbf{T} \\in \\mathbb{R}^n$ is the vector of nodal temperatures and $\\lambda \\in \\mathbb{R}$ is the Lagrange multiplier. The components of this system are:\n\nThe global stiffness matrix $\\mathbf{K} \\in \\mathbb{R}^{n \\times n}$, with entries $K_{ij} = \\int_{\\Omega} \\kappa \\nabla N_i \\cdot \\nabla N_j \\, d\\Omega$. It is assembled by iterating over all triangular elements and summing their local contributions. For a single triangular element $e$ with area $A_e$ and nodal coordinates $(x_k, y_k)$, the element stiffness matrix $\\mathbf{k}^e$ has entries $k^e_{rs} = \\frac{\\kappa}{4 A_e} (b_r b_s + c_r c_s)$, where $b_r = y_{r+1} - y_{r+2}$ and $c_r = x_{r+2} - x_{r+1}$ (with cyclic index permutation).\n\nThe global force vector $\\mathbf{f} \\in \\mathbb{R}^n$, with entries $f_i = \\int_{\\Omega} q N_i \\, d\\Omega$. For a constant source $q$, the contribution from a single element $e$ to its three nodes is $f_i^e = \\int_{A_e} q N_i \\, d\\Omega = q A_e / 3$.\n\nThe constraint vector $\\mathbf{B} \\in \\mathbb{R}^{1 \\times n}$, with entries $B_j = \\frac{1}{L} \\int_{\\Gamma} N_j \\, d\\Gamma$. The boundary $\\Gamma$ is the edge at $x=1$ with length $L=1$. The basis function $N_j$ is non-zero on $\\Gamma$ only if node $j$ lies on this edge. The nodes on $\\Gamma$ are at coordinates $(1, j h_y)$ for $j=0, \\dots, N_y$, where $h_y = 1/N_y = 1/8$. The integral of a linear 1D basis function over an interval of length $h_y$ is $h_y/2$. Therefore, the non-zero entries of $\\mathbf{B}$ are:\n- For the two corner nodes on $\\Gamma$ (at $y=0$ and $y=1$), $B_j = (1/L) \\cdot (h_y/2) = (1/1) \\cdot (1/8)/2 = 1/16$.\n- For the $N_y-1=7$ interior nodes on $\\Gamma$, the basis function spans two segments, so $B_j = (1/L) \\cdot (h_y/2 + h_y/2) = h_y = 1/8$.\nAll other entries of $\\mathbf{B}$ are zero.\n\nThe resulting $(n+1) \\times (n+1)$ linear system is constructed as a sparse matrix and solved for the vector $(\\mathbf{T}, \\lambda)^T$. The required outputs are then calculated:\n1. The absolute error $\\left|\\mathbf{B}\\,\\mathbf{T} - T_{\\text{avg}}\\right|$. Since the constraint is enforced as an exact equation in the linear system, this error is expected to be on the order of machine precision.\n2. The Lagrange multiplier $\\lambda$. As shown by the compatibility condition, $\\lambda$ must equal the total source strength, $\\lambda = \\int_\\Omega q \\, d\\Omega = q$.\n\nThe procedure is executed for each set of parameters $(\\kappa, q, T_{\\text{avg}})$ provided in the test suite.", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the heat conduction problem with an average boundary constraint\n    using the Finite Element Method with a Lagrange multiplier.\n    \"\"\"\n    test_cases = [\n        (1.0, 0.0, 2.0),\n        (1.0, 1.0, 0.0),\n        (2.5, 0.0, -1.0),\n        (0.7, 0.5, 0.3),\n    ]\n\n    results = []\n    \n    # Mesh parameters\n    Nx = 8\n    Ny = 8\n\n    for kappa, q, T_avg in test_cases:\n        # Mesh generation\n        num_nodes_x = Nx + 1\n        num_nodes_y = Ny + 1\n        num_nodes = num_nodes_x * num_nodes_y\n        hx = 1.0 / Nx\n        hy = 1.0 / Ny\n\n        node_coords = np.array([(i * hx, j * hy) for j in range(num_nodes_y) for i in range(num_nodes_x)])\n\n        # Initialize global system matrices\n        K = lil_matrix((num_nodes, num_nodes))\n        f = np.zeros(num_nodes)\n\n        # Assembly loop over rectangular cells\n        for j in range(Ny):\n            for i in range(Nx):\n                # Global indices of the 4 cell nodes (BL, BR, TL, TR)\n                n_bl = i + j * num_nodes_x\n                n_br = (i + 1) + j * num_nodes_x\n                n_tl = i + (j + 1) * num_nodes_x\n                n_tr = (i + 1) + (j + 1) * num_nodes_x\n\n                # Split rectangle into two triangles (using BL-TR diagonal)\n                triangles = [\n                    (n_bl, n_br, n_tr),  # Bottom-right triangle\n                    (n_bl, n_tr, n_tl)   # Top-left triangle\n                ]\n\n                for tri_nodes in triangles:\n                    # Element coordinates\n                    coords = node_coords[list(tri_nodes)]\n                    p1, p2, p3 = coords\n                    \n                    # Element area\n                    Ae = 0.5 * np.abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n                    \n                    # Gradients of basis functions components\n                    b = np.array([p2[1]-p3[1], p3[1]-p1[1], p1[1]-p2[1]])\n                    c = np.array([p3[0]-p2[0], p1[0]-p3[0], p2[0]-p1[0]])\n                    \n                    # Element stiffness matrix\n                    Ke = (kappa / (4.0 * Ae)) * (np.outer(b, b) + np.outer(c, c))\n                    \n                    # Element force vector\n                    fe = (q * Ae / 3.0) * np.ones(3)\n\n                    # Assemble into global matrices\n                    for r in range(3):\n                        f[tri_nodes[r]] += fe[r]\n                        for s in range(3):\n                            K[tri_nodes[r], tri_nodes[s]] += Ke[r, s]\n        \n        # Assemble constraint vector B\n        L = 1.0 # Length of the boundary Gamma\n        B = np.zeros(num_nodes)\n        \n        # Nodes on the right boundary (x=1)\n        # Corner node at (1,0)\n        idx_bottom = Nx + 0 * num_nodes_x\n        B[idx_bottom] = (hy / 2.0) / L\n        # Corner node at (1,1)\n        idx_top = Nx + Ny * num_nodes_x\n        B[idx_top] = (hy / 2.0) / L\n        # Interior nodes\n        for j in range(1, Ny):\n            idx = Nx + j * num_nodes_x\n            B[idx] = hy / L\n\n        # Construct the augmented saddle-point system\n        n = num_nodes\n        M = lil_matrix((n + 1, n + 1))\n        rhs = np.zeros(n + 1)\n        \n        M[:n, :n] = K\n        M[:n, n] = B.reshape(-1, 1)\n        M[n, :n] = B\n        \n        rhs[:n] = f\n        rhs[n] = T_avg\n        \n        # Solve the linear system\n        M_csc = M.tocsc()\n        solution = spsolve(M_csc, rhs)\n\n        T_vec = solution[:n]\n        lambda_val = solution[n]\n        \n        # Post-processing: calculate error\n        T_avg_computed = np.dot(B, T_vec)\n        error = np.abs(T_avg_computed - T_avg)\n        \n        results.append(\"{:.6f}\".format(error))\n        results.append(\"{:.6f}\".format(lambda_val))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2402864"}]}