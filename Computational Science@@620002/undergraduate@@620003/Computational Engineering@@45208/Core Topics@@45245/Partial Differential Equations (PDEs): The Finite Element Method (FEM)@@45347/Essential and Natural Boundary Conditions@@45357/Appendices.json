{"hands_on_practices": [{"introduction": "The Method of Manufactured Solutions (MMS) is a cornerstone technique for verifying the correctness of scientific computing software. This practice guides you through the process of deriving the weak form of a partial differential equation, which is fundamental to the finite element method. By starting with a chosen \"manufactured\" solution, you will work backward to determine the corresponding source term and boundary data, providing a concrete understanding of how essential (Dirichlet) and natural (Neumann, Robin) conditions are incorporated into the variational framework [@problem_id:2544251]. This skill is invaluable for debugging and validating numerical simulations.", "problem": "Let $\\Omega = (0,1)\\times(0,1)$ be the unit square with boundary $\\partial\\Omega$ partitioned into three disjoint segments for an elliptic scalar diffusion model in the context of the finite element method (FEM) applied to a second-order partial differential equation (PDE). Consider the strong form\n$$-\\nabla\\cdot\\big(k(x,y)\\nabla u(x,y)\\big) = f(x,y)\\quad\\text{in }\\Omega,$$\nwith a manufactured choice of unknown and coefficient\n$$u(x,y) = \\exp(x)\\big(\\sin(\\pi y)+y^2\\big),\\qquad k(x,y) = 1+xy.$$\nImpose mixed boundary types on different boundary segments as follows:\n- Essential (Dirichlet) boundary $\\Gamma_D = \\{(x,0): 0<x<1\\}\\cup\\{(0,y): 0<y<1\\}$ with $u=g$.\n- Natural (Neumann) boundary $\\Gamma_N = \\{(x,1): 0<x<1\\}$ with outward unit normal $n=(0,1)$ and flux $q = n\\cdot(k\\nabla u)$ prescribed.\n- Robin boundary $\\Gamma_R = \\{(1,y): 0<y<1\\}$ with outward unit normal $n=(1,0)$ and condition $n\\cdot(k\\nabla u)+\\alpha u = h$, where the Robin parameter is chosen as $\\alpha(y)=1+y$ on $\\Gamma_R$.\n\nTasks:\n1. Starting from the strong form and using the divergence theorem, derive the weak form associated with the above model and classify which boundary conditions are essential versus natural within the FEM framework. Justify why Dirichlet data are enforced on the trial space, while Neumann and Robin data appear in the boundary integrals of the weak form.\n2. Using the given manufactured $u$ and $k$, compute consistent data $f$ in $\\Omega$, $g$ on $\\Gamma_D$, $q$ on $\\Gamma_N$, and $h$ on $\\Gamma_R$ (with the given $\\alpha$), so that the manufactured $u$ exactly satisfies the PDE and boundary conditions. Provide explicit expressions for $f$, $g$, $q$, and $h$.\n3. Provide the final simplified closed-form analytic expression for $f(x,y)$. This final expression is the answer to be graded. No rounding is required, and no units are necessary.\n\nYour final answer must be a single closed-form analytic expression for $f(x,y)$.", "solution": "The problem presented is a well-posed exercise in the framework of the finite element method, requiring the derivation of the weak form of a given partial differential equation and the calculation of consistent data for a manufactured solution. We shall proceed with the required tasks in sequence.\n\nFirst, we address the derivation of the weak formulation and the classification of the boundary conditions. The strong form of the problem is given by the second-order elliptic partial differential equation:\n$$-\\nabla\\cdot\\big(k(x,y)\\nabla u(x,y)\\big) = f(x,y) \\quad \\text{in } \\Omega$$\nTo derive the weak form, we multiply the PDE by an arbitrary test function $v$, which belongs to a suitable function space, and integrate over the domain $\\Omega$:\n$$\\int_{\\Omega} -\\nabla\\cdot(k\\nabla u) v \\,d\\Omega = \\int_{\\Omega} f v \\,d\\Omega$$\nWe apply the divergence theorem to the left-hand side. The divergence theorem in this context is often stated as Green's first identity: $\\int_{\\Omega} \\mathbf{F} \\cdot \\nabla v \\, d\\Omega = -\\int_{\\Omega} (\\nabla \\cdot \\mathbf{F}) v \\, d\\Omega + \\oint_{\\partial\\Omega} (\\mathbf{F} \\cdot \\mathbf{n}) v \\, dS$. Let $\\mathbf{F} = k\\nabla u$. This gives:\n$$\\int_{\\Omega} k\\nabla u \\cdot \\nabla v \\,d\\Omega - \\oint_{\\partial\\Omega} (k\\nabla u \\cdot \\mathbf{n}) v \\,dS = \\int_{\\Omega} f v \\,d\\Omega$$\nRearranging the terms, we obtain the general variational form:\n$$\\int_{\\Omega} k\\nabla u \\cdot \\nabla v \\,d\\Omega = \\int_{\\Omega} f v \\,d\\Omega + \\oint_{\\partial\\Omega} (k\\nabla u \\cdot \\mathbf{n}) v \\,dS$$\nThe boundary integral is partitioned according to the given boundary segments $\\partial\\Omega = \\Gamma_D \\cup \\Gamma_N \\cup \\Gamma_R$:\n$$\\oint_{\\partial\\Omega} (k\\nabla u \\cdot \\mathbf{n}) v \\,dS = \\int_{\\Gamma_D} (k\\nabla u \\cdot \\mathbf{n}) v \\,dS + \\int_{\\Gamma_N} (k\\nabla u \\cdot \\mathbf{n}) v \\,dS + \\int_{\\Gamma_R} (k\\nabla u \\cdot \\mathbf{n}) v \\,dS$$\nNow we incorporate the boundary conditions and define the appropriate function spaces. The trial function $u$ must belong to a space of functions with at least one square-integrable derivative, typically the Sobolev space $H^1(\\Omega)$. The test function $v$ belongs to a related space.\n\nThe Dirichlet condition $u=g$ on $\\Gamma_D$ is an **essential** boundary condition. In the finite element method, such conditions are imposed directly on the space of trial functions. We define the trial space $S = \\{ u \\in H^1(\\Omega) \\mid u|_{\\Gamma_D} = g \\}$ and the test space $V_0 = \\{ v \\in H^1(\\Omega) \\mid v|_{\\Gamma_D} = 0 \\}$. By requiring $v=0$ on $\\Gamma_D$, the integral over $\\Gamma_D$ vanishes: $\\int_{\\Gamma_D} (k\\nabla u \\cdot \\mathbf{n}) v \\,dS = 0$. This is why the condition is termed essential: it is a fundamental constraint on the function space itself, and the test functions are constructed to respect this constraint.\n\nThe Neumann condition, $k\\nabla u \\cdot \\mathbf{n} = q$ on $\\Gamma_N$, and the Robin condition, $k\\nabla u \\cdot \\mathbf{n} + \\alpha u = h$ on $\\Gamma_R$, are **natural** boundary conditions. They arise \"naturally\" from the integration-by-parts procedure and are incorporated into the weak form. We substitute these conditions into the remaining boundary integrals:\n- On $\\Gamma_N$: $\\int_{\\Gamma_N} (k\\nabla u \\cdot \\mathbf{n}) v \\,dS = \\int_{\\Gamma_N} q v \\,dS$.\n- On $\\Gamma_R$: $k\\nabla u \\cdot \\mathbf{n} = h - \\alpha u$. Thus, $\\int_{\\Gamma_R} (k\\nabla u \\cdot \\mathbf{n}) v \\,dS = \\int_{\\Gamma_R} (h-\\alpha u) v \\,dS = \\int_{\\Gamma_R} h v \\,dS - \\int_{\\Gamma_R} \\alpha u v \\,dS$.\n\nSubstituting these into the variational form and moving all terms involving the unknown $u$ to the left-hand side, we obtain the final weak form:\nFind $u \\in S$ such that for all $v \\in V_0$:\n$$ \\int_{\\Omega} k\\nabla u \\cdot \\nabla v \\,d\\Omega + \\int_{\\Gamma_R} \\alpha u v \\,dS = \\int_{\\Omega} f v \\,d\\Omega + \\int_{\\Gamma_N} q v \\,dS + \\int_{\\Gamma_R} h v \\,dS $$\nThe Neumann and Robin data ($q$ and $h$) appear in the linear functional on the right-hand side, while the Robin term $\\alpha u$ contributes to the bilinear form on the left-hand side. These conditions are satisfied in a weak, integral sense, rather than pointwise, which is why they are called natural.\n\nSecond, we compute the consistent data $f,g,q,h$ for the manufactured solution $u(x,y) = \\exp(x)(\\sin(\\pi y)+y^2)$ and coefficient $k(x,y)=1+xy$.\n\n1.  **Source Term $f(x,y)$**:\n    $f = -\\nabla\\cdot(k\\nabla u)$. We first compute the gradient of $u$:\n    $$ \\frac{\\partial u}{\\partial x} = \\exp(x)(\\sin(\\pi y)+y^2) $$\n    $$ \\frac{\\partial u}{\\partial y} = \\exp(x)(\\pi \\cos(\\pi y)+2y) $$\n    The source is $f = -\\nabla\\cdot(k\\nabla u)$, so we compute $\\nabla\\cdot(k\\nabla u) = \\frac{\\partial}{\\partial x}(k u_x) + \\frac{\\partial}{\\partial y}(k u_y)$.\n    $$ \\frac{\\partial}{\\partial x}(k u_x) = \\frac{\\partial}{\\partial x}\\big[ (1+xy)\\exp(x)(\\sin(\\pi y)+y^2) \\big] = (y)\\exp(x)(\\sin(\\pi y)+y^2) + (1+xy)\\exp(x)(\\sin(\\pi y)+y^2) = (1+y+xy)\\exp(x)(\\sin(\\pi y)+y^2) $$\n    $$ \\frac{\\partial}{\\partial y}(k u_y) = \\frac{\\partial}{\\partial y}\\big[ (1+xy)\\exp(x)(\\pi \\cos(\\pi y)+2y) \\big] = \\exp(x) \\big[ (x)(\\pi \\cos(\\pi y)+2y) + (1+xy)(-\\pi^2\\sin(\\pi y)+2) \\big] $$\n    Summing these and multiplying by $-1$ gives $f(x,y)$:\n    $$ f(x,y) = -\\exp(x) \\left[ (1+y+xy)(\\sin(\\pi y)+y^2) + x(\\pi \\cos(\\pi y)+2y) + (1+xy)(2-\\pi^2\\sin(\\pi y)) \\right] $$\n    Upon simplification by expanding and grouping terms:\n    $$ f(x,y) = -\\exp(x) \\left\\{ \\big[1+y-\\pi^2 + (1-\\pi^2)xy\\big]\\sin(\\pi y) + \\pi x \\cos(\\pi y) + (1+x)y^3 + y^2 + 4xy + 2 \\right\\} $$\n\n2.  **Dirichlet Data $g$ on $\\Gamma_D$**: $\\Gamma_D = \\{(x,0): 0<x<1\\}\\cup\\{(0,y): 0<y<1\\}$\n    -   On $\\{(x,0)\\}$, we set $y=0$: $g(x,0) = u(x,0) = \\exp(x)(\\sin(0)+0^2) = 0$.\n    -   On $\\{(0,y)\\}$, we set $x=0$: $g(0,y) = u(0,y) = \\exp(0)(\\sin(\\pi y)+y^2) = \\sin(\\pi y)+y^2$.\n\n3.  **Neumann Data $q$ on $\\Gamma_N$**: $\\Gamma_N = \\{(x,1): 0<x<1\\}$, $n=(0,1)$.\n    $q = n\\cdot(k\\nabla u) = k \\frac{\\partial u}{\\partial y}$. We evaluate this at $y=1$:\n    $$ k(x,1) = 1+x $$\n    $$ \\frac{\\partial u}{\\partial y}(x,1) = \\exp(x)(\\pi \\cos(\\pi)+2) = \\exp(x)(2-\\pi) $$\n    $$ q(x,1) = (1+x)\\exp(x)(2-\\pi) $$\n\n4.  **Robin Data $h$ on $\\Gamma_R$**: $\\Gamma_R = \\{(1,y): 0<y<1\\}$, $n=(1,0)$, $\\alpha(y)=1+y$.\n    $h = n\\cdot(k\\nabla u) + \\alpha u = k \\frac{\\partial u}{\\partial x} + \\alpha u$. We evaluate this at $x=1$:\n    $$ k(1,y) = 1+y $$\n    $$ \\frac{\\partial u}{\\partial x}(1,y) = \\exp(1)(\\sin(\\pi y)+y^2) $$\n    $$ u(1,y) = \\exp(1)(\\sin(\\pi y)+y^2) $$\n    The flux term is $k \\frac{\\partial u}{\\partial x} = (1+y)\\exp(1)(\\sin(\\pi y)+y^2)$.\n    The reaction term is $\\alpha u = (1+y)\\exp(1)(\\sin(\\pi y)+y^2)$.\n    $$ h(1,y) = (1+y)\\exp(1)(\\sin(\\pi y)+y^2) + (1+y)\\exp(1)(\\sin(\\pi y)+y^2) = 2(1+y)\\exp(1)(\\sin(\\pi y)+y^2) $$\n\nThird, the problem requires the final simplified closed-form analytic expression for $f(x,y)$, which was derived above and constitutes the final answer.", "answer": "$$\n\\boxed{-\\exp(x) \\left\\{ \\left[1+y-\\pi^2 + (1-\\pi^2)xy\\right]\\sin(\\pi y) + \\pi x \\cos(\\pi y) + (1+x)y^3 + y^2 + 4xy + 2 \\right\\}}\n$$", "id": "2544251"}, {"introduction": "The choice of boundary conditions is not merely a mathematical formality; it has profound consequences for the behavior of the solution. This exercise explores how the type of boundary condition—essential (Dirichlet) versus natural (Neumann)—interacts with the domain's geometry to affect the solution's smoothness, a property known as regularity. You will analyze how singularities, or regions where the solution's gradient becomes unbounded, can arise at sharp corners depending on the boundary conditions applied [@problem_id:2389711]. Understanding this relationship is critical for designing accurate and robust numerical methods, as it explains why simulations may fail or produce inaccurate results near geometric features.", "problem": "Consider the planar wedge domain in polar coordinates $\\Omega_{\\alpha} = \\{(r,\\theta)\\,:\\, 0 < r < 1,\\; 0 < \\theta < \\alpha\\}$, where $\\alpha \\in (0,2\\pi)$. Let $u(r,\\theta)$ solve the Laplace equation $\\Delta u = 0$ in $\\Omega_{\\alpha}$, where $\\Delta$ denotes the Laplacian in two dimensions. The two straight edges of the wedge are the rays $\\theta = 0$ and $\\theta = \\alpha$. On each edge, impose either an essential (Dirichlet) boundary condition $u=0$ or a natural (Neumann) boundary condition $\\partial u / \\partial n = 0$, where $n$ denotes the outward unit normal on the boundary.\n\nFor each configuration, define the corner singularity exponent $\\lambda_{\\min}(\\alpha,\\text{BC})$ to be the smallest positive real number $\\lambda > 0$ such that there exists a nontrivial harmonic solution in $\\Omega_{\\alpha}$ obeying the prescribed boundary conditions and having leading-order corner behavior of order $r^{\\lambda}$ as $r \\to 0^{+}$. Use this exponent to determine whether the gradient magnitude $\\|\\nabla u\\|$ is unbounded at the corner as $r \\to 0^{+}$. Classify the singularity using the indicator\n- $\\text{is\\_singular} = \\text{True}$ if $\\lambda_{\\min}(\\alpha,\\text{BC}) < 1$, and $\\text{False}$ otherwise,\nand quantify the blow-up rate of the gradient by the exponent\n- $b = \\max(0, 1 - \\lambda_{\\min}(\\alpha,\\text{BC}))$, in the sense that $\\|\\nabla u\\|$ behaves like $C\\, r^{-b}$ as $r \\to 0^{+}$ for some constant $C \\neq 0$ when $b > 0$.\n\nYour task is to write a complete, runnable program that, for each test case specified below, computes and returns the triple $[\\lambda_{\\min}, \\text{is\\_singular}, b]$.\n\nTest Suite (angles are in radians):\n- Case $1$: $\\alpha = \\dfrac{3\\pi}{2}$ with boundary conditions $\\text{Dirichlet}/\\text{Dirichlet}$ on $\\theta=0$ and $\\theta=\\alpha$.\n- Case $2$: $\\alpha = \\dfrac{3\\pi}{2}$ with boundary conditions $\\text{Neumann}/\\text{Neumann}$ on $\\theta=0$ and $\\theta=\\alpha$.\n- Case $3$: $\\alpha = \\dfrac{3\\pi}{2}$ with boundary conditions $\\text{Dirichlet}/\\text{Neumann}$ on $\\theta=0$ and $\\theta=\\alpha$.\n- Case $4$: $\\alpha = \\pi$ with boundary conditions $\\text{Dirichlet}/\\text{Dirichlet}$ on $\\theta=0$ and $\\theta=\\alpha$.\n- Case $5$: $\\alpha = \\dfrac{3\\pi}{4}$ with boundary conditions $\\text{Dirichlet}/\\text{Dirichlet}$ on $\\theta=0$ and $\\theta=\\alpha$.\n- Case $6$: $\\alpha = \\dfrac{7\\pi}{4}$ with boundary conditions $\\text{Dirichlet}/\\text{Neumann}$ on $\\theta=0$ and $\\theta=\\alpha$.\n- Case $7$: $\\alpha = \\dfrac{4\\pi}{3}$ with boundary conditions $\\text{Neumann}/\\text{Neumann}$ on $\\theta=0$ and $\\theta=\\alpha$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the cases above.\n- Each case’s result must itself be a list in the form $[\\lambda_{\\min}, \\text{is\\_singular}, b]$, where $\\lambda_{\\min}$ and $b$ are floating-point numbers and $\\text{is\\_singular}$ is a boolean.\n- Concretely, the output must look like $[[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],\\ldots]$ with no extra text before or after the list.", "solution": "The problem presented is valid, scientifically grounded, and well-posed. It addresses a classical topic in the theory of elliptic partial differential equations—the regularity of solutions near corners of the domain. This analysis is fundamental in computational engineering for designing accurate numerical methods, such as the finite element method, particularly in the context of adaptive mesh refinement.\n\nThe governing equation is the two-dimensional Laplace equation, $\\Delta u = 0$. In polar coordinates $(r, \\theta)$, this equation is:\n$$\n\\Delta u = \\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r} \\frac{\\partial u}{\\partial r} + \\frac{1}{r^2} \\frac{\\partial^2 u}{\\partial \\theta^2} = 0\n$$\nWe seek solutions in the wedge domain $\\Omega_{\\alpha} = \\{(r,\\theta)\\,:\\, 0 < r < 1,\\; 0 < \\theta < \\alpha\\}$. To analyze the behavior of the solution near the corner at $r=0$, we employ the method of separation of variables. We look for non-trivial solutions of the form $u(r,\\theta) = R(r)\\Theta(\\theta)$. Substituting this into the Laplace equation and rearranging terms yields:\n$$\n\\frac{r^2 R''(r) + r R'(r)}{R(r)} = - \\frac{\\Theta''(\\theta)}{\\Theta(\\theta)}\n$$\nSince the left side depends only on $r$ and the right side only on $\\theta$, both must equal a separation constant, which we denote by $\\mu$. This gives two ordinary differential equations:\n$$\n\\Theta''(\\theta) + \\mu \\Theta(\\theta) = 0\n$$\n$$\nr^2 R''(r) + r R'(r) - \\mu R(r) = 0\n$$\nFor the angular part, to have non-trivial solutions satisfying the homogeneous boundary conditions, we need oscillatory behavior, which requires the constant to be positive. We set $\\mu = \\lambda^2$ with $\\lambda > 0$. The angular equation becomes $\\Theta''(\\theta) + \\lambda^2 \\Theta(\\theta) = 0$, with the general solution:\n$$\n\\Theta(\\theta) = A \\cos(\\lambda\\theta) + B \\sin(\\lambda\\theta)\n$$\nThe radial equation is a Cauchy-Euler equation, $r^2 R'' + r R' - \\lambda^2 R = 0$, with general solution $R(r) = c_1 r^{\\lambda} + c_2 r^{-\\lambda}$. We are investigating solutions that have the form $r^{\\lambda}$ for positive $\\lambda$ as $r \\to 0^{+}$, so we focus on the $r^{\\lambda}$ term.\n\nThe coefficients $A$, $B$, and the permissible values of $\\lambda$ are determined by the boundary conditions on the straight edges $\\theta=0$ and $\\theta=\\alpha$. The problem specifies either essential (Dirichlet) or natural (Neumann) conditions.\n- A Dirichlet condition $u=0$ on a ray $\\theta = \\theta_0$ implies $\\Theta(\\theta_0) = 0$.\n- A Neumann condition $\\partial u / \\partial n = 0$ on a ray $\\theta = \\theta_0$ requires careful interpretation. The outward unit normal $\\mathbf{n}$ is orthogonal to the ray. In polar coordinates, this means $\\mathbf{n}$ is in the $\\pm \\hat{e}_{\\theta}$ direction. The gradient is $\\nabla u = \\frac{\\partial u}{\\partial r}\\hat{e}_r + \\frac{1}{r}\\frac{\\partial u}{\\partial \\theta}\\hat{e}_{\\theta}$. The normal derivative is thus $\\frac{\\partial u}{\\partial n} = \\nabla u \\cdot \\mathbf{n} = \\pm \\frac{1}{r}\\frac{\\partial u}{\\partial \\theta}$. The condition $\\partial u / \\partial n = 0$ is therefore equivalent to $\\frac{\\partial u}{\\partial \\theta} = 0$ on that ray, which implies $\\Theta'(\\theta_0) = 0$.\n\nWe analyze the four configurations of boundary conditions:\n\n1.  **Dirichlet/Dirichlet (DD)**: $u=0$ on $\\theta=0$ and $\\theta=\\alpha$.\n    - $\\Theta(0) = 0 \\implies A\\cos(0) + B\\sin(0) = A = 0$.\n    - The solution becomes $\\Theta(\\theta) = B\\sin(\\lambda\\theta)$.\n    - $\\Theta(\\alpha) = 0 \\implies B\\sin(\\lambda\\alpha) = 0$. For a non-trivial solution ($B \\neq 0$), we need $\\sin(\\lambda\\alpha) = 0$.\n    - This gives $\\lambda\\alpha = k\\pi$ for $k \\in \\{1, 2, 3, \\ldots\\}$. The smallest positive exponent is for $k=1$, so $\\lambda_{\\min} = \\dfrac{\\pi}{\\alpha}$.\n\n2.  **Neumann/Neumann (NN)**: $\\partial u/\\partial n=0$ on $\\theta=0$ and $\\theta=\\alpha$.\n    - $\\Theta'(0) = 0 \\implies \\lambda(-A\\sin(0) + B\\cos(0)) = \\lambda B = 0$. Since $\\lambda > 0$, we have $B=0$.\n    - The solution becomes $\\Theta(\\theta) = A\\cos(\\lambda\\theta)$.\n    - $\\Theta'(\\alpha) = 0 \\implies -\\lambda A\\sin(\\lambda\\alpha) = 0$. For a non-trivial solution ($A \\neq 0, \\lambda \\neq 0$), we need $\\sin(\\lambda\\alpha) = 0$.\n    - This again gives $\\lambda\\alpha = k\\pi$, and the smallest positive exponent is $\\lambda_{\\min} = \\dfrac{\\pi}{\\alpha}$ (for $k=1$; $k=0$ gives $\\lambda=0$, corresponding to a constant solution, which is excluded by the requirement $\\lambda > 0$).\n\n3.  **Dirichlet/Neumann (DN)**: $u=0$ on $\\theta=0$ and $\\partial u/\\partial n=0$ on $\\theta=\\alpha$.\n    - $\\Theta(0) = 0 \\implies A=0$. The solution is $\\Theta(\\theta) = B\\sin(\\lambda\\theta)$.\n    - $\\Theta'(\\alpha) = 0 \\implies \\lambda B\\cos(\\lambda\\alpha) = 0$. For a non-trivial solution, $\\cos(\\lambda\\alpha) = 0$.\n    - This gives $\\lambda\\alpha = (k + \\frac{1}{2})\\pi$ for $k \\in \\{0, 1, 2, \\ldots\\}$. The smallest positive exponent is for $k=0$, so $\\lambda_{\\min} = \\dfrac{\\pi}{2\\alpha}$.\n\n4.  **Neumann/Dirichlet (ND)**: $\\partial u/\\partial n=0$ on $\\theta=0$ and $u=0$ on $\\theta=\\alpha$.\n    - $\\Theta'(0) = 0 \\implies B=0$. The solution is $\\Theta(\\theta) = A\\cos(\\lambda\\theta)$.\n    - $\\Theta(\\alpha) = 0 \\implies A\\cos(\\lambda\\alpha) = 0$. For a non-trivial solution, $\\cos(\\lambda\\alpha) = 0$.\n    - This again gives $\\lambda\\alpha = (k + \\frac{1}{2})\\pi$, and the smallest positive exponent is $\\lambda_{\\min} = \\dfrac{\\pi}{2\\alpha}$.\n\nThe leading-order behavior of the solution near the corner is $u \\sim C r^{\\lambda_{\\min}} \\Theta_{\\min}(\\theta)$. The magnitude of the gradient is $\\|\\nabla u\\| = \\sqrt{(\\partial u/\\partial r)^2 + (r^{-1}\\partial u/\\partial \\theta)^2}$. The terms in the gradient behave as $r^{\\lambda_{\\min}-1}$. Therefore, $\\|\\nabla u\\| \\sim C' r^{\\lambda_{\\min}-1}$ as $r \\to 0^{+}$.\n\nThe gradient becomes unbounded if the exponent $\\lambda_{\\min}-1$ is negative, i.e., if $\\lambda_{\\min} < 1$. This justifies the definition of the singularity indicator: $\\text{is\\_singular} = (\\lambda_{\\min} < 1)$.\nIf a singularity exists, the blow-up rate is characterized by the exponent $b = -(\\lambda_{\\min}-1) = 1-\\lambda_{\\min}$. If the gradient is bounded ($\\lambda_{\\min} \\ge 1$), there is no blow-up, so the exponent is $0$. This corresponds to the given definition: $b = \\max(0, 1 - \\lambda_{\\min})$.\n\nThe algorithm is to compute $\\lambda_{\\min}$ based on the angle $\\alpha$ and the boundary condition type, and then use it to find $\\text{is\\_singular}$ and $b$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the corner singularity exponent, singularity presence, and\n    gradient blow-up rate for the Laplace equation in a wedge domain.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (angle_alpha_in_radians, boundary_condition_type).\n    test_cases = [\n        (3 * np.pi / 2, \"DD\"),  # Case 1: Dirichlet/Dirichlet\n        (3 * np.pi / 2, \"NN\"),  # Case 2: Neumann/Neumann\n        (3 * np.pi / 2, \"DN\"),  # Case 3: Dirichlet/Neumann\n        (np.pi,         \"DD\"),  # Case 4: Dirichlet/Dirichlet\n        (3 * np.pi / 4, \"DD\"),  # Case 5: Dirichlet/Dirichlet\n        (7 * np.pi / 4, \"DN\"),  # Case 6: Dirichlet/Neumann\n        (4 * np.pi / 3, \"NN\"),  # Case 7: Neumann/Neumann\n    ]\n\n    results = []\n    for alpha, bc_type in test_cases:\n        # Calculate the smallest positive singularity exponent lambda_min.\n        # The formulas are derived from separation of variables.\n        if bc_type == \"DD\" or bc_type == \"NN\":\n            # For Dirichlet/Dirichlet or Neumann/Neumann conditions.\n            lambda_min = np.pi / alpha\n        elif bc_type == \"DN\" or bc_type == \"ND\":\n            # For mixed Dirichlet/Neumann conditions.\n            lambda_min = np.pi / (2 * alpha)\n        else:\n            # This case should not be reached with the given test suite.\n            raise ValueError(f\"Unknown boundary condition type: {bc_type}\")\n\n        # The gradient of the solution behaves like r^(lambda_min - 1).\n        # A singularity in the gradient exists if lambda_min < 1.\n        is_singular = lambda_min < 1\n\n        # The blow-up rate exponent b is defined as max(0, 1 - lambda_min).\n        # It is positive only when the gradient is singular.\n        b = max(0.0, 1.0 - lambda_min)\n\n        # Append the calculated triple to the results list.\n        results.append([lambda_min, is_singular, b])\n\n    # Format the results into the specified string format.\n    # Example: [[val1,True,val2],[val3,False,val4]]\n    result_strings = []\n    for res in results:\n        # str() provides sufficient precision for floats and correct 'True'/'False' for booleans.\n        lambda_str = str(res[0])\n        singular_str = str(res[1])\n        b_str = str(res[2])\n        result_strings.append(f\"[{lambda_str},{singular_str},{b_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2389711"}, {"introduction": "Bridging the gap between theory and practice, this final exercise confronts a challenge central to computational engineering: implementing boundary conditions on realistic, curved domains. Since finite element meshes typically approximate curves with straight-sided polygons, we must understand the errors introduced by this geometric simplification. This practice focuses on quantifying the discrepancy between the true and the approximated boundary load for a natural (Neumann) boundary condition [@problem_id:2389726]. By analyzing this geometric error, you will gain insight into a crucial source of inaccuracy in finite element analysis and appreciate the need for careful mesh design to achieve high-fidelity results.", "problem": "Consider the imposition of a Neumann boundary condition on a smoothly curved boundary in two spatial dimensions within the weak formulation of a second-order elliptic partial differential equation. In the weak form, a Neumann (natural) boundary condition contributes a boundary integral of the form $\\int_{\\Gamma} g(\\mathbf{x})\\, v\\, \\mathrm{d}s$, where $g(\\mathbf{x})$ is the prescribed normal flux and $v$ is a test function. To isolate the effect of geometric approximation on the Neumann boundary condition, let $v \\equiv 1$ so that the quantity of interest reduces to the scalar boundary load $\\int_{\\Gamma} g(\\mathbf{x})\\, \\mathrm{d}s$.\n\nLet the true boundary segment be a circular arc of a circle with radius $R > 0$, parameterized by the polar angle $\\theta \\in [\\theta_a, \\theta_b]$ with $\\theta_b > \\theta_a$. Angles must be expressed in radians. Let the point on the circle at angle $\\theta$ be $\\mathbf{x}(\\theta) = (R \\cos \\theta, R \\sin \\theta)$. Let the prescribed Neumann flux be a smooth function that is affine in Cartesian coordinates, namely\n$$\ng(\\mathbf{x}) = q_0 + q_1 x + q_2 y,\n$$\nwith constants $q_0, q_1, q_2 \\in \\mathbb{R}$.\n\nDefine the exact boundary load as\n$$\nI_{\\text{exact}} = \\int_{\\Gamma} g(\\mathbf{x})\\, \\mathrm{d}s = \\int_{\\theta_a}^{\\theta_b} \\left(q_0 + q_1 R \\cos \\theta + q_2 R \\sin \\theta\\right) R\\, \\mathrm{d}\\theta.\n$$\n\nNow approximate the circular arc by a polyline with $N \\in \\mathbb{N}$ straight edges constructed by connecting the points $\\mathbf{x}(\\theta_i)$ for $i=0,1,\\dots,N$, where $\\theta_i = \\theta_a + i h$ and $h = (\\theta_b - \\theta_a)/N$. Let the $i$-th edge be the straight segment from $\\mathbf{x}(\\theta_i)$ to $\\mathbf{x}(\\theta_{i+1})$. The corresponding approximate boundary load is defined by integrating $g$ along each straight edge and summing, that is\n$$\nI_{\\text{approx}} = \\sum_{i=0}^{N-1} \\int_{0}^{1} g\\!\\left((1-t)\\,\\mathbf{x}(\\theta_i) + t\\,\\mathbf{x}(\\theta_{i+1})\\right)\\, \\left\\|\\mathbf{x}(\\theta_{i+1}) - \\mathbf{x}(\\theta_i)\\right\\|\\, \\mathrm{d}t,\n$$\nwhere $\\|\\cdot\\|$ denotes the Euclidean norm.\n\nFor each case in the test suite below, compute the absolute error $E_{\\text{abs}} = |I_{\\text{approx}} - I_{\\text{exact}}|$ and the relative error\n$$\nE_{\\text{rel}} = \\frac{E_{\\text{abs}}}{\\max\\!\\left(|I_{\\text{exact}}|, 10^{-12}\\right)}.\n$$\nReport only the relative error $E_{\\text{rel}}$ for each test case. The quantities are dimensionless.\n\nTest Suite (angles in radians):\n- Case $1$: $R = 1$, $\\theta_a = 0$, $\\theta_b = \\tfrac{\\pi}{2}$, $q_0 = 1$, $q_1 = 0$, $q_2 = 0$, $N = 4$.\n- Case $2$: $R = 1$, $\\theta_a = 0$, $\\theta_b = \\pi$, $q_0 = 1$, $q_1 = 0$, $q_2 = 0$, $N = 6$.\n- Case $3$: $R = 2$, $\\theta_a = 0$, $\\theta_b = \\tfrac{\\pi}{6}$, $q_0 = 1$, $q_1 = 0$, $q_2 = 0$, $N = 1$.\n- Case $4$: $R = 1.5$, $\\theta_a = \\tfrac{\\pi}{4}$, $\\theta_b = \\tfrac{3\\pi}{4}$, $q_0 = 0$, $q_1 = 0.5$, $q_2 = -0.25$, $N = 8$.\n- Case $5$: $R = 1$, $\\theta_a = 0$, $\\theta_b = 2\\pi$, $q_0 = 0.75$, $q_1 = 0.2$, $q_2 = -0.1$, $N = 32$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the relative errors for Cases $1$ through $5$ as a comma-separated list enclosed in square brackets, for example, $[e_1,e_2,e_3,e_4,e_5]$, where each $e_i$ is the floating-point value of $E_{\\text{rel}}$ for Case $i$.", "solution": "The task is to compute the relative error between the exact and approximate boundary load integrals. This requires deriving computable expressions for both quantities.\n\n**1. Exact Boundary Load, $I_{\\text{exact}}$**\n\nThe exact boundary load is defined by a definite integral over the angle $\\theta$:\n$$\nI_{\\text{exact}} = \\int_{\\theta_a}^{\\theta_b} (q_0 + q_1 R \\cos \\theta + q_2 R \\sin \\theta) R\\, \\mathrm{d}\\theta\n$$\nThe integration is performed term by term with respect to $\\theta$:\n$$\nI_{\\text{exact}} = R \\left[ \\int_{\\theta_a}^{\\theta_b} q_0 \\, \\mathrm{d}\\theta + q_1 R \\int_{\\theta_a}^{\\theta_b} \\cos \\theta \\, \\mathrm{d}\\theta + q_2 R \\int_{\\theta_a}^{\\theta_b} \\sin \\theta \\, \\mathrm{d}\\theta \\right]\n$$\nEvaluating the elementary integrals yields:\n$$\nI_{\\text{exact}} = R \\left[ q_0 \\theta + q_1 R \\sin \\theta - q_2 R \\cos \\theta \\right]_{\\theta_a}^{\\theta_b}\n$$\nApplying the fundamental theorem of calculus gives the final analytical expression:\n$$\nI_{\\text{exact}} = R \\left( q_0(\\theta_b - \\theta_a) + q_1 R(\\sin \\theta_b - \\sin \\theta_a) - q_2 R(\\cos \\theta_b - \\cos \\theta_a) \\right)\n$$\n\n**2. Approximate Boundary Load, $I_{\\text{approx}}$**\n\nThe approximate boundary load is calculated by summing the integrals over $N$ straight line segments. Consider the $i$-th segment from $\\mathbf{x}_i \\equiv \\mathbf{x}(\\theta_i)$ to $\\mathbf{x}_{i+1} \\equiv \\mathbf{x}(\\theta_{i+1})$. The length of this segment, $L_i = \\|\\mathbf{x}_{i+1} - \\mathbf{x}_i\\|$, is constant for all segments with the same angular step size $h = \\theta_{i+1} - \\theta_i$.\n$$\nL_i^2 = (R\\cos\\theta_{i+1} - R\\cos\\theta_i)^2 + (R\\sin\\theta_{i+1} - R\\sin\\theta_i)^2\n$$\n$$\nL_i^2 = R^2 \\left( 2 - 2(\\cos\\theta_{i+1}\\cos\\theta_i + \\sin\\theta_{i+1}\\sin\\theta_i) \\right) = 2R^2(1 - \\cos(\\theta_{i+1} - \\theta_i)) = 2R^2(1 - \\cos h)\n$$\nUsing the half-angle identity $1 - \\cos h = 2\\sin^2(h/2)$, the length is:\n$$\nL_h = \\sqrt{4R^2\\sin^2(h/2)} = 2R\\sin(h/2)\n$$\n(since $h \\ge 0$, $\\sin(h/2) \\ge 0$).\n\nThe integral over the $i$-th segment is $I_i = L_h \\int_{0}^{1} g((1-t)\\mathbf{x}_i + t\\mathbf{x}_{i+1}) \\mathrm{d}t$.\nThe flux function $g(\\mathbf{x}) = q_0 + q_1 x + q_2 y$ is affine in the Cartesian coordinates $(x,y)$. The parameterization of the segment, $\\mathbf{p}(t) = (1-t)\\mathbf{x}_i + t\\mathbf{x}_{i+1}$, is linear in $t$. Therefore, the composite function $g(\\mathbf{p}(t))$ is linear in $t$.\n$$\ng(\\mathbf{p}(t)) = g(\\mathbf{x}_i) + t(g(\\mathbf{x}_{i+1}) - g(\\mathbf{x}_i))\n$$\nThe integral of this linear function over $t \\in [0,1]$ is its average value at the endpoints:\n$$\n\\int_{0}^{1} g(\\mathbf{p}(t)) \\mathrm{d}t = \\frac{g(\\mathbf{x}_i) + g(\\mathbf{x}_{i+1})}{2}\n$$\nThis is the trapezoidal rule, which is exact for linear integrands. Thus, the contribution from the $i$-th segment is:\n$$\nI_i = L_h \\frac{g(\\mathbf{x}_i) + g(\\mathbf{x}_{i+1})}{2}\n$$\nThe total approximate load is the sum over all $N$ segments:\n$$\nI_{\\text{approx}} = \\sum_{i=0}^{N-1} I_i = \\sum_{i=0}^{N-1} L_h \\frac{g(\\mathbf{x}(\\theta_i)) + g(\\mathbf{x}(\\theta_{i+1}))}{2}\n$$\nwhere $\\theta_i = \\theta_a + i h$ and $h = (\\theta_b - \\theta_a)/N$. The function values are computed as $g(\\mathbf{x}(\\theta)) = q_0 + q_1 R \\cos \\theta + q_2 R \\sin \\theta$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # (R, theta_a, theta_b, q0, q1, q2, N)\n        (1.0, 0.0, np.pi / 2.0, 1.0, 0.0, 0.0, 4),\n        (1.0, 0.0, np.pi, 1.0, 0.0, 0.0, 6),\n        (2.0, 0.0, np.pi / 6.0, 1.0, 0.0, 0.0, 1),\n        (1.5, np.pi / 4.0, 3.0 * np.pi / 4.0, 0.0, 0.5, -0.25, 8),\n        (1.0, 0.0, 2.0 * np.pi, 0.75, 0.2, -0.1, 32),\n    ]\n\n    results = [calculate_relative_error(case) for case in test_cases]\n    \n    # Format the final output as a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_relative_error(case):\n    \"\"\"\n    Calculates the relative error for a single test case.\n\n    Args:\n        case (tuple): A tuple containing the parameters (R, theta_a, theta_b, q0, q1, q2, N).\n\n    Returns:\n        float: The computed relative error E_rel.\n    \"\"\"\n    R, theta_a, theta_b, q0, q1, q2, N = case\n\n    # 1. Calculate the exact boundary load I_exact\n    # I_exact = R * [q0*theta + q1*R*sin(theta) - q2*R*cos(theta)] from theta_a to theta_b\n    term_q0 = q0 * (theta_b - theta_a)\n    term_q1 = q1 * R * (np.sin(theta_b) - np.sin(theta_a))\n    term_q2 = -q2 * R * (np.cos(theta_b) - np.cos(theta_a))\n    I_exact = R * (term_q0 + term_q1 + term_q2)\n\n    # 2. Calculate the approximate boundary load I_approx\n    h = (theta_b - theta_a) / N\n    # Length of a single polyline segment\n    # L_h = 2 * R * sin(h/2)\n    L_h = 2.0 * R * np.sin(h / 2.0)\n\n    # Flux function g(theta)\n    def g_func(theta):\n        return q0 + q1 * R * np.cos(theta) + q2 * R * np.sin(theta)\n\n    # Sum contributions from all segments\n    I_approx = 0.0\n    for i in range(N):\n        theta_i = theta_a + i * h\n        theta_i_plus_1 = theta_a + (i + 1) * h\n        \n        g_i = g_func(theta_i)\n        g_i_plus_1 = g_func(theta_i_plus_1)\n        \n        # Integral over the i-th segment\n        segment_integral = L_h * (g_i + g_i_plus_1) / 2.0\n        I_approx += segment_integral\n\n    # 3. Calculate absolute and relative errors\n    E_abs = np.abs(I_approx - I_exact)\n    # Use max(|I_exact|, 1e-12) to prevent division by zero\n    denominator = np.maximum(np.abs(I_exact), 1e-12)\n    E_rel = E_abs / denominator\n    \n    return E_rel\n\nsolve()\n```", "id": "2389726"}]}