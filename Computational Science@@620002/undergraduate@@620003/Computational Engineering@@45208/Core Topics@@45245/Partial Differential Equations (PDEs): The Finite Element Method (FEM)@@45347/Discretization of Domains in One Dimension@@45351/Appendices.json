{"hands_on_practices": [{"introduction": "The foundation of many numerical methods lies in approximating derivatives on a discrete grid. This practice demystifies this process by guiding you through the derivation of a finite difference formula for a high-order derivative. By using Taylor series expansions, you will construct a compact stencil for the biharmonic operator, which is fundamental in fields like solid mechanics for modeling plate bending and in fluid dynamics. This exercise provides you with a core skill: the ability to derive your own discretization schemes for complex operators [@problem_id:2385929].", "problem": "Consider a one-dimensional uniform grid with nodes $x_i = x_0 + i h$ for integer $i$ and grid spacing $h>0$. Let $u:\\mathbb{R}\\to\\mathbb{R}$ be a function that is at least $C^6$-smooth in a neighborhood of $x_i$, and let $u_i \\equiv u(x_i)$. At an interior node $x_i$, construct a symmetric, compact $5$-point finite-difference approximation of the biharmonic operator, that is, the fourth derivative $u_{xxxx}(x_i)$, using only the nodal values $u_{i-2}, u_{i-1}, u_i, u_{i+1}, u_{i+2}$ and powers of $h$. The resulting approximation must be consistent with the definition of the fourth derivative and use no more than these $5$ points.\n\nProvide your final approximation as a single closed-form analytic expression in terms of $u_{i-2}, u_{i-1}, u_i, u_{i+1}, u_{i+2}$ and $h$. No rounding is required. Do not include any equality sign in the final expression.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- Grid: One-dimensional uniform grid with nodes $x_i = x_0 + i h$ for integer $i$.\n- Grid Spacing: $h > 0$.\n- Function: $u:\\mathbb{R}\\to\\mathbb{R}$ is at least $C^6$-smooth in a neighborhood of $x_i$.\n- Nodal Value: $u_i \\equiv u(x_i)$.\n- Objective: Construct a symmetric, compact $5$-point finite-difference approximation of the biharmonic operator, $u_{xxxx}(x_i)$, at an interior node $x_i$.\n- Stencil: The approximation must use only the nodal values $u_{i-2}, u_{i-1}, u_i, u_{i+1}, u_{i+2}$ and powers of $h$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is analyzed against the required criteria.\n- **Scientifically Grounded**: The problem is a standard exercise in numerical analysis for discretizing differential operators. The biharmonic operator is fundamental in solid mechanics and fluid dynamics. This is scientifically sound.\n- **Well-Posed**: The problem is well-posed. It asks for the derivation of a specific finite-difference formula given a clear stencil and symmetry constraint. The method of undetermined coefficients using Taylor series provides a path to a unique solution.\n- **Objective**: The problem is stated in precise, objective mathematical language.\n- **Conclusion**: The problem is free of scientific flaws, ambiguities, or missing information. It is a valid, well-defined problem in computational engineering.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be derived.\n\nThe objective is to find coefficients $c_{-2}, c_{-1}, c_0, c_1, c_2$ such that the linear combination\n$$\n\\mathcal{L}[u] = c_{-2}u_{i-2} + c_{-1}u_{i-1} + c_0u_i + c_1u_{i+1} + c_2u_{i+2}\n$$\nprovides a consistent approximation to the fourth derivative $u_{xxxx}(x_i) \\equiv \\frac{d^4u}{dx^4}\\big|_{x=x_i}$. The problem specifies a symmetric stencil, which implies $c_{-k} = c_k$. Thus, we need to find only three coefficients: $c_0$, $c_1$, and $c_2$. The approximation takes the form:\n$$\n\\mathcal{L}[u] = c_2(u_{i-2} + u_{i+2}) + c_1(u_{i-1} + u_{i+1}) + c_0u_i\n$$\n\nThe standard method for determining these coefficients is to use Taylor series expansions for each nodal value $u_{i+k}$ around the central point $x_i$. The function $u(x)$ is given to be at least $C^6$-smooth, which allows us to write the expansions with sufficient precision. Let $u^{(n)}_i$ denote $\\frac{d^n u}{dx^n}\\big|_{x=x_i}$.\n\nThe Taylor expansions for $u(x_i \\pm k h)$ are:\n$$\nu_{i \\pm k} = u(x_i \\pm kh) = \\sum_{n=0}^{\\infty} \\frac{(\\pm kh)^n}{n!} u^{(n)}_i\n$$\nSpecifically, for $k=1$ and $k=2$:\n$$\nu_{i+1} = u_i + h u^{(1)}_i + \\frac{h^2}{2} u^{(2)}_i + \\frac{h^3}{6} u^{(3)}_i + \\frac{h^4}{24} u^{(4)}_i + \\frac{h^5}{120} u^{(5)}_i + \\frac{h^6}{720} u^{(6)}_i + O(h^7)\n$$\n$$\nu_{i-1} = u_i - h u^{(1)}_i + \\frac{h^2}{2} u^{(2)}_i - \\frac{h^3}{6} u^{(3)}_i + \\frac{h^4}{24} u^{(4)}_i - \\frac{h^5}{120} u^{(5)}_i + \\frac{h^6}{720} u^{(6)}_i + O(h^7)\n$$\n$$\nu_{i+2} = u_i + 2h u^{(1)}_i + \\frac{(2h)^2}{2} u^{(2)}_i + \\frac{(2h)^3}{6} u^{(3)}_i + \\frac{(2h)^4}{24} u^{(4)}_i + \\frac{(2h)^5}{120} u^{(5)}_i + \\frac{(2h)^6}{720} u^{(6)}_i + O(h^7)\n$$\n$$\nu_{i-2} = u_i - 2h u^{(1)}_i + \\frac{(2h)^2}{2} u^{(2)}_i - \\frac{(2h)^3}{6} u^{(3)}_i + \\frac{(2h)^4}{24} u^{(4)}_i - \\frac{(2h)^5}{120} u^{(5)}_i + \\frac{(2h)^6}{720} u^{(6)}_i + O(h^7)\n$$\nDue to the symmetry of the stencil, it is advantageous to sum the pairs $u_{i+k} + u_{i-k}$. This automatically cancels all odd-order derivative terms.\n$$\nu_{i+1} + u_{i-1} = 2u_i + h^2 u^{(2)}_i + \\frac{h^4}{12} u^{(4)}_i + \\frac{h^6}{360} u^{(6)}_i + O(h^8)\n$$\n$$\nu_{i+2} + u_{i-2} = 2u_i + (2h)^2 u^{(2)}_i + \\frac{(2h)^4}{12} u^{(4)}_i + \\frac{(2h)^6}{360} u^{(6)}_i + O(h^8) = 2u_i + 4h^2 u^{(2)}_i + \\frac{16h^4}{12} u^{(4)}_i + \\frac{64h^6}{360} u^{(6)}_i + O(h^8)\n$$\nSubstituting these sums into the approximation form $\\mathcal{L}[u]$:\n$$\n\\mathcal{L}[u] = c_2 \\left( 2u_i + 4h^2 u^{(2)}_i + \\frac{4h^4}{3} u^{(4)}_i + \\dots \\right) + c_1 \\left( 2u_i + h^2 u^{(2)}_i + \\frac{h^4}{12} u^{(4)}_i + \\dots \\right) + c_0u_i\n$$\nWe group the terms by the order of the derivative of $u_i$:\n$$\n\\mathcal{L}[u] = (2c_1 + 2c_2 + c_0)u_i + h^2(c_1 + 4c_2)u^{(2)}_i + h^4\\left(\\frac{c_1}{12} + \\frac{4c_2}{3}\\right)u^{(4)}_i + \\dots\n$$\nFor this expression to be a consistent approximation of $u^{(4)}_i$, we must match the coefficients of the derivatives to the target $1 \\cdot u^{(4)}_i$. This means the coefficient of $u^{(4)}_i$ must be $1$, and the coefficients of lower-order derivatives ($u_i$ and $u^{(2)}_i$) must be $0$. This yields a system of three linear equations for $c_0, c_1, c_2$:\n\\begin{enumerate}\n    \\item Coeff of $u_i$: $c_0 + 2c_1 + 2c_2 = 0$\n    \\item Coeff of $u^{(2)}_i$: $h^2(c_1 + 4c_2) = 0 \\implies c_1 + 4c_2 = 0$\n    \\item Coeff of $u^{(4)}_i$: $h^4\\left(\\frac{c_1}{12} + \\frac{4c_2}{3}\\right) = 1 \\implies \\frac{c_1}{12} + \\frac{4c_2}{3} = \\frac{1}{h^4}$\n\\end{enumerate}\nFrom equation (2), we find $c_1 = -4c_2$.\nSubstituting this into equation (3):\n$$\n\\frac{-4c_2}{12} + \\frac{4c_2}{3} = \\frac{1}{h^4} \\implies -\\frac{c_2}{3} + \\frac{4c_2}{3} = \\frac{1}{h^4} \\implies c_2 = \\frac{1}{h^4}\n$$\nWith $c_2$ known, we find $c_1$:\n$$\nc_1 = -4c_2 = -\\frac{4}{h^4}\n$$\nFinally, we use equation (1) to find $c_0$:\n$$\nc_0 + 2\\left(-\\frac{4}{h^4}\\right) + 2\\left(\\frac{1}{h^4}\\right) = 0 \\implies c_0 - \\frac{8}{h^4} + \\frac{2}{h^4} = 0 \\implies c_0 = \\frac{6}{h^4}\n$$\nThe coefficients are therefore:\n$c_2 = c_{-2} = \\frac{1}{h^4}$, $c_1 = c_{-1} = -\\frac{4}{h^4}$, and $c_0 = \\frac{6}{h^4}$.\nSubstituting these coefficients back into the linear combination gives the desired approximation for $u_{xxxx}(x_i)$:\n$$\n\\frac{1}{h^4} u_{i-2} - \\frac{4}{h^4} u_{i-1} + \\frac{6}{h^4} u_i - \\frac{4}{h^4} u_{i+1} + \\frac{1}{h^4} u_{i+2}\n$$\nThis can be written more compactly. The final expression for the finite-difference approximation of the fourth derivative is:\n$$\n\\frac{u_{i-2} - 4u_{i-1} + 6u_i - 4u_{i+1} + u_{i+2}}{h^4}\n$$\nThis result is recognized as the centered finite difference formula for the fourth derivative, obtained by applying the centered second-difference operator twice. The coefficients $1, -4, 6, -4, 1$ correspond to the fourth row of Pascal's triangle with alternating signs, which is characteristic of the fourth-order central difference operator.", "answer": "$$\n\\boxed{\\frac{u_{i-2} - 4 u_{i-1} + 6 u_i - 4 u_{i+1} + u_{i+2}}{h^{4}}}\n$$", "id": "2385929"}, {"introduction": "Moving from theoretical derivation to practical application, we now tackle a common scenario in engineering: modeling systems with multiple materials. When properties like thermal conductivity change abruptly at an interface, it's crucial that our numerical method conserves physical quantities like flux. This hands-on coding practice introduces the Finite Volume Method (FVM), a robust technique designed to ensure conservation by discretizing the integral form of the governing equations. You will implement an FVM solver for a one-dimensional diffusion problem with a material interface, gaining practical experience in handling discontinuous coefficients and non-uniform grids [@problem_id:2385950].", "problem": "Consider steady one-dimensional diffusion on the interval $[0,L]$ with a piecewise-constant material property (conductivity) given by\n$$\nk(x) = \\begin{cases}\nk_1, & 0 \\le x < x_{\\mathrm{int}},\\\\\nk_2, & x_{\\mathrm{int}} \\le x \\le L.\n\\end{cases}\n$$\nThe state variable $T(x)$ satisfies the boundary value problem\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(k(x)\\frac{\\mathrm{d}T}{\\mathrm{d}x}\\right) = 0,\\quad T(0)=T_0,\\quad T(L)=T_L.\n$$\nAll quantities are nondimensional.\n\nYou must write a complete, runnable program that, for each test case below, discretizes $[0,L]$ into $N$ control volumes using a one-dimensional Finite Volume Method (FVM) that ensures local conservation of flux across all faces on a possibly nonuniform grid defined by a geometric progression with ratio $r>0$ (uniform when $r=1$). The grid is defined by widths $\\Delta x_i$ proportional to $r^{i-1}$ for $i\\in\\{1,2,\\dots,N\\}$, scaled so that $\\sum_{i=1}^N \\Delta x_i = L$, with control-volume centers at the midpoints. Assign $k(x)$ to each control volume according to the step function $k(x)$ using the control-volume center location. Enforce the Dirichlet boundary conditions $T(0)=T_0$ and $T(L)=T_L$. Compute the numerical steady solution and the corresponding constant diffusive flux, and also compute the exact flux obtained from the exact solution of the stated boundary value problem. For each test case, output the absolute difference between the numerical left-boundary flux and the exact flux as a single real number.\n\nTest suite (five cases). For each bullet, the parameters are $(L, N, k_1, k_2, x_{\\mathrm{int}}, T_0, T_L, r)$:\n- Case $1$: $(L=\\;1.0,\\; N=\\;10,\\; k_1=\\;10.0,\\; k_2=\\;1.0,\\; x_{\\mathrm{int}}=\\;0.4,\\; T_0=\\;100.0,\\; T_L=\\;0.0,\\; r=\\;1.0)$.\n- Case $2$: $(L=\\;1.0,\\; N=\\;9,\\; k_1=\\;1.0,\\; k_2=\\;100.0,\\; x_{\\mathrm{int}}=\\;0.5,\\; T_0=\\;0.0,\\; T_L=\\;1.0,\\; r=\\;1.0)$.\n- Case $3$: $(L=\\;1.0,\\; N=\\;7,\\; k_1=\\;0.1,\\; k_2=\\;5.0,\\; x_{\\mathrm{int}}=\\;0.0,\\; T_0=\\;20.0,\\; T_L=\\;50.0,\\; r=\\;1.0)$.\n- Case $4$: $(L=\\;2.0,\\; N=\\;12,\\; k_1=\\;15.0,\\; k_2=\\;2.0,\\; x_{\\mathrm{int}}=\\;1.4,\\; T_0=\\;300.0,\\; T_L=\\;200.0,\\; r=\\;3.0)$.\n- Case $5$: $(L=\\;1.0,\\; N=\\;8,\\; k_1=\\;5.0,\\; k_2=\\;5.0,\\; x_{\\mathrm{int}}=\\;0.3,\\; T_0=\\;10.0,\\; T_L=\\;0.0,\\; r=\\;1.0)$.\n\nRequirements for each test case:\n- Construct the nonuniform mesh as described with $N$ control volumes and ratio $r$.\n- Use a conservative Finite Volume Method (FVM) discretization in one dimension that ensures identical flux through shared faces at steady state, with piecewise-constant $k$ per control volume consistent with $k(x)$.\n- Enforce the Dirichlet boundary conditions at $x=0$ and $x=L$.\n- Compute the numerical flux at the left boundary, and compute the exact flux implied by the exact solution of the boundary value problem.\n- Produce the absolute difference between these two flux values as a real number.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets with no spaces, ordered as listed above; for example, an output of the form $[a_1,a_2,a_3,a_4,a_5]$, where each $a_i$ is the absolute error for case $i$.", "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to construct a unique and meaningful solution. The problem asks for the numerical solution of a one-dimensional steady-state diffusion equation using the Finite Volume Method (FVM), a standard and appropriate technique in computational engineering.\n\nWe begin with the derivation of the exact solution for the diffusive flux, followed by the formulation of the numerical method.\n\nThe governing equation for steady-state one-dimensional diffusion is\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(k(x)\\frac{\\mathrm{d}T}{\\mathrm{d}x}\\right) = 0\n$$\nwhere $T(x)$ is the temperature field and $k(x)$ is the thermal conductivity. Integrating this equation once with respect to $x$ yields\n$$\nk(x)\\frac{\\mathrm{d}T}{\\mathrm{d}x} = C\n$$\nwhere $C$ is a constant of integration. The diffusive flux is defined as $q(x) = -k(x)\\frac{\\mathrm{d}T}{\\mathrm{d}x}$. Therefore, the flux $q$ is constant throughout the domain, a direct consequence of conservation in a steady-state, source-free problem. We can write $q = -C$, so $\\frac{\\mathrm{d}T}{\\mathrm{d}x} = -\\frac{q_{\\text{exact}}}{k(x)}$.\n\nTo find the value of this constant flux, $q_{\\text{exact}}$, we integrate $\\frac{\\mathrm{d}T}{\\mathrm{d}x}$ across the entire domain from $x=0$ to $x=L$:\n$$\n\\int_{0}^{L} \\frac{\\mathrm{d}T}{\\mathrm{d}x} \\mathrm{d}x = T(L) - T(0) = T_L - T_0\n$$\nAlso,\n$$\n\\int_{0}^{L} \\left(-\\frac{q_{\\text{exact}}}{k(x)}\\right) \\mathrm{d}x = -q_{\\text{exact}} \\int_{0}^{L} \\frac{1}{k(x)} \\mathrm{d}x\n$$\nGiven the piecewise-constant definition of $k(x)$, the integral of its reciprocal is\n$$\n\\int_{0}^{L} \\frac{1}{k(x)} \\mathrm{d}x = \\int_{0}^{x_{\\mathrm{int}}} \\frac{1}{k_1} \\mathrm{d}x + \\int_{x_{\\mathrm{int}}}^{L} \\frac{1}{k_2} \\mathrm{d}x = \\frac{x_{\\mathrm{int}}}{k_1} + \\frac{L - x_{\\mathrm{int}}}{k_2}\n$$\nThis expression represents the total thermal resistance of the composite medium. By equating the two expressions for the temperature difference, we obtain\n$$\nT_L - T_0 = -q_{\\text{exact}} \\left( \\frac{x_{\\mathrm{int}}}{k_1} + \\frac{L - x_{\\mathrm{int}}}{k_2} \\right)\n$$\nSolving for the exact flux gives\n$$\nq_{\\text{exact}} = \\frac{T_0 - T_L}{\\frac{x_{\\mathrm{int}}}{k_1} + \\frac{L - x_{\\mathrm{int}}}{k_2}}\n$$\nThis formula provides the exact, constant flux against which the numerical result will be compared.\n\nNext, we formulate the Finite Volume Method. The domain $[0, L]$ is discretized into $N$ control volumes (CVs). The width of the $i$-th CV ($i \\in \\{1, 2, \\dots, N\\}$) is $\\Delta x_i$. These widths form a geometric progression, $\\Delta x_i = C r^{i-1}$, where the constant $C$ is chosen to satisfy $\\sum_{i=1}^N \\Delta x_i = L$. The sum is a geometric series, so for $r \\ne 1$, $C = L\\frac{r-1}{r^N-1}$, and for $r=1$, $C = L/N$. The center of the $i$-th CV is denoted by $x_{c,i}$, and the conductivity for this volume, $k_i$, is assigned as $k_i = k(x_{c,i})$.\n\nThe FVM is based on the integral form of the governing equation over each CV. For the $i$-th CV, which spans from face $x_{f,i-1}$ to $x_{f,i}$, we have:\n$$\n\\int_{x_{f,i-1}}^{x_{f,i}} \\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(k(x)\\frac{\\mathrm{d}T}{\\mathrm{d}x}\\right) \\mathrm{d}x = \\left[k(x)\\frac{\\mathrm{d}T}{\\mathrm{d}x}\\right]_{x_{f,i-1}}^{x_{f,i}} = 0\n$$\nThis simplifies to $q_{f,i-1} - q_{f,i} = 0$, where $q_{f,i}$ is the flux at the face separating CV $i$ and CV $i+1$. This states that the flux entering a CV from the left must equal the flux exiting to the right.\n\nThe face fluxes are approximated using the temperatures of the adjacent CV centers, $T_{i}$ and $T_{i+1}$. The flux $q_{f,i}$ is given by the temperature difference divided by the thermal resistance between the nodes:\n$$\nq_{f,i} = \\frac{T_i - T_{i+1}}{R_{i,i+1}}\n$$\nFor a conservative scheme, the resistance $R_{i,i+1}$ is correctly modeled as two resistances in series corresponding to the two halves of the adjacent CVs. This leads to a harmonic mean for the effective interface conductivity:\n$$\nR_{i,i+1} = \\frac{\\Delta x_i / 2}{k_i} + \\frac{\\Delta x_{i+1} / 2}{k_{i+1}}\n$$\nFor an internal CV $i$ (where $i \\in \\{2, \\dots, N-1\\}$), the flux balance $q_{f,i-1} - q_{f,i} = 0$ becomes:\n$$\n\\frac{T_{i-1} - T_i}{R_{i-1,i}} - \\frac{T_i - T_{i+1}}{R_{i,i+1}} = 0\n$$\nwhich rearranges to a linear equation in $T_{i-1}$, $T_i$, and $T_{i+1}$:\n$$\n\\left(\\frac{1}{R_{i-1,i}}\\right)T_{i-1} - \\left(\\frac{1}{R_{i-1,i}} + \\frac{1}{R_{i,i+1}}\\right)T_i + \\left(\\frac{1}{R_{i,i+1}}\\right)T_{i+1} = 0\n$$\n\nThe boundary conditions are incorporated at the first and last CVs. For CV $1$, the left face is the domain boundary at $x=0$, where $T(0)=T_0$. The resistance from the boundary to the center of CV $1$ is $R_{B,1} = (\\Delta x_1/2)/k_1$. The flux balance is:\n$$\n\\frac{T_0 - T_1}{R_{B,1}} - \\frac{T_1 - T_2}{R_{1,2}} = 0\n$$\nFor CV $N$, the right face is the domain boundary at $x=L$, where $T(L)=T_L$. The resistance from the center of CV $N$ to the boundary is $R_{N,B} = (\\Delta x_N/2)/k_N$:\n$$\n\\frac{T_{N-1} - T_N}{R_{N-1,N}} - \\frac{T_N - T_L}{R_{N,B}} = 0\n$$\nThese $N$ linear equations for the $N$ unknown temperatures $T_1, \\dots, T_N$ form a tridiagonal system $A\\vec{T} = \\vec{b}$, which can be solved efficiently.\n\nOnce the vector of cell-center temperatures $\\vec{T}$ is found, the numerical flux at the left boundary is calculated as:\n$$\nq_{\\text{num}} = \\frac{T_0 - T_1}{R_{B,1}} = \\frac{T_0 - T_1}{(\\Delta x_1 / 2) / k_1}\n$$\nDue to the conservative nature of the discretization, this flux value is constant across all CV faces in the numerical solution. The final result for each test case is the absolute error $|q_{\\text{num}} - q_{\\text{exact}}|$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D steady-state diffusion problem for a suite of test cases\n    using a conservative Finite Volume Method.\n    \"\"\"\n    test_cases = [\n        # (L, N, k1, k2, x_int, T0, TL, r)\n        (1.0, 10, 10.0, 1.0, 0.4, 100.0, 0.0, 1.0),\n        (1.0, 9, 1.0, 100.0, 0.5, 0.0, 1.0, 1.0),\n        (1.0, 7, 0.1, 5.0, 0.0, 20.0, 50.0, 1.0),\n        (2.0, 12, 15.0, 2.0, 1.4, 300.0, 200.0, 3.0),\n        (1.0, 8, 5.0, 5.0, 0.3, 10.0, 0.0, 1.0),\n    ]\n\n    results = []\n    for params in test_cases:\n        error = process_case(*params)\n        results.append(error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(L, N, k1, k2, x_int, T0, TL, r):\n    \"\"\"\n    Computes the absolute flux error for a single test case.\n    \"\"\"\n    # 1. Exact Flux Calculation\n    # The total thermal resistance is the sum of resistances of the two sections.\n    #Resistance R = length / conductivity.\n    res_1 = x_int / k1 if k1 != 0 else np.inf\n    res_2 = (L - x_int) / k2 if k2 != 0 else np.inf\n    total_resistance = res_1 + res_2\n    \n    if total_resistance == 0:\n        # Avoid division by zero if conductivities are infinite\n        q_exact = np.inf if T0 != TL else 0.0\n    elif np.isinf(total_resistance):\n        q_exact = 0.0\n    else:\n        q_exact = (T0 - TL) / total_resistance\n\n    # 2. Grid Generation\n    if r == 1.0:\n        deltas = np.full(N, L / N)\n    else:\n        # Sum of geometric series: C * (r^N - 1)/(r - 1) = L\n        # This determines the scaling constant C.\n        C = L * (r - 1) / (r**N - 1)\n        deltas = C * (r ** np.arange(N))\n\n    # Face positions (x_f) and cell center positions (x_c)\n    x_f = np.zeros(N + 1)\n    x_f[1:] = np.cumsum(deltas)\n    x_c = x_f[:-1] + deltas / 2.0\n\n    # 3. Assign Material Properties to Cells\n    # k_cell[i] is k1 if center of cell i is less than x_int, else k2.\n    k_cell = np.where(x_c  x_int, k1, k2)\n\n    # 4. Assemble Linear System Ax = b for cell temperatures\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # Handle N=1 explicitly for robustness, though test cases have N>=7.\n    if N == 1:\n        R_left_bnd = 0.5 * deltas[0] / k_cell[0]\n        R_right_bnd = 0.5 * deltas[0] / k_cell[0]\n        A[0, 0] = -(1 / R_left_bnd + 1 / R_right_bnd)\n        b[0] = -(T0 / R_left_bnd + TL / R_right_bnd)\n    else:\n        # First row (cell i=0)\n        C_L_bnd = 1 / (0.5 * deltas[0] / k_cell[0])\n        C_R_face = 1 / (0.5 * deltas[0] / k_cell[0] + 0.5 * deltas[1] / k_cell[1])\n        A[0, 0] = -(C_L_bnd + C_R_face)\n        A[0, 1] = C_R_face\n        b[0] = -C_L_bnd * T0\n        \n        # Internal rows (cell i=1 to N-2)\n        for i in range(1, N - 1):\n            C_W = 1 / (0.5 * deltas[i-1] / k_cell[i-1] + 0.5 * deltas[i] / k_cell[i])\n            C_E = 1 / (0.5 * deltas[i] / k_cell[i] + 0.5 * deltas[i+1] / k_cell[i+1])\n            A[i, i-1] = C_W\n            A[i, i]   = -(C_W + C_E)\n            A[i, i+1] = C_E\n        \n        # Last row (cell i=N-1)\n        C_W_face = 1 / (0.5 * deltas[N-2] / k_cell[N-2] + 0.5 * deltas[N-1] / k_cell[N-1])\n        C_R_bnd = 1 / (0.5 * deltas[N-1] / k_cell[N-1])\n        A[N-1, N-2] = C_W_face\n        A[N-1, N-1] = -(C_W_face + C_R_bnd)\n        b[N-1] = -C_R_bnd * TL\n    \n    # 5. Solve System for cell temperatures T_vec\n    T_vec = np.linalg.solve(A, b)\n\n    # 6. Calculate Numerical Flux at the left boundary\n    # Resistance from boundary x=0 to center of first cell\n    R_bc_left = 0.5 * deltas[0] / k_cell[0]\n    q_num = (T0 - T_vec[0]) / R_bc_left\n\n    # 7. Calculate and return absolute error\n    error = abs(q_num - q_exact)\n    # The FVM is exact for this problem, so error should be ~0.\n    # The question asks for a single real number.\n    # The provided code had a bug where the printed results had extra quotes.\n    # This simplified version just returns the float.\n    return float(f\"{error:.15e}\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2385950"}, {"introduction": "A numerical solution is an approximation, and a key task for a computational engineer is to understand and control its error. This practice introduces Richardson extrapolation, a powerful technique for improving the accuracy of a solution by combining results from computations on different grid resolutions. By leveraging the known asymptotic behavior of the discretization error, you can systematically eliminate the leading error term to achieve a higher-order accurate result without needing to devise a more complex discretization scheme from scratch. This exercise will teach you how to analyze your results critically and enhance their precision, a vital skill in computational validation [@problem_id:2385975].", "problem": "Consider the one-dimensional Poisson boundary value problem on the unit interval: find a sufficiently smooth function $u(x)$ such that $-u''(x) = f(x)$ for $x \\in (0,1)$ with Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$. Adopt a uniform mesh with $N$ equal subintervals of length $h = 1/N$ and interior nodes $x_i = i h$ for $i = 1,2,\\dots,N-1$. Using the standard second-order central difference approximation for the second derivative, derive the linear system that approximates $u(x)$ at interior nodes on a grid with $N$ subintervals. Then, using the well-tested fact that for smooth solutions and smooth $f$, the pointwise finite-difference error at a fixed interior point admits an asymptotic expansion in even powers of $h$, of the form $U_h(x_*) = u(x_*) + a h^2 + b h^4 + \\mathcal{O}(h^6)$ with constants $a$ and $b$ independent of $h$, construct a Richardson extrapolation formula that eliminates the leading $\\mathcal{O}(h^2)$ error term to achieve a fourth-order accurate approximation at a fixed point $x_*$. Your derivation must start from the central difference definition, and your extrapolation must be justified by the stated asymptotic error expansion without assuming any further unstated properties.\n\nImplementation requirements:\n- Solve the discrete Poisson problem on three nested grids with $N$, $2N$, and $4N$ uniform subintervals, respectively, each using the same second-order central difference scheme and the same Dirichlet boundary conditions.\n- Choose a point $x_* = m/N$ for an integer $m$ with $1 \\le m \\le N-1$ so that $x_*$ is an interior node on the coarsest grid and, hence, also a node on the finer grids (specifically at indices $2m$ and $4m$ on the $2N$ and $4N$ grids).\n- Compute the discrete solutions on each grid and extract the nodal values $U_h(x_*)$, $U_{h/2}(x_*)$, and $U_{h/4}(x_*)$ where $h = 1/N$.\n- Using your derived fourth-order Richardson extrapolation formula, form a fourth-order approximation to $u(x_*)$ using the two finest grids $2N$ and $4N$. Report the absolute error $|U^{(4)}(x_*) - u(x_*)|$, where $U^{(4)}(x_*)$ denotes your fourth-order approximation at $x_*$.\n- All trigonometric function evaluations must use angles in radians.\n\nTest suite:\nImplement your program to run the following three independent test cases. For each case, compute the absolute error at $x_*$ of the fourth-order approximation formed from the $2N$ and $4N$ grids as described above.\n- Case A (happy path, smooth sinusoid): $u(x) = \\sin(\\pi x)$, so $f(x) = \\pi^2 \\sin(\\pi x)$. Use $N = 8$ and $x_* = 1/2$ (i.e., $m = 4$).\n- Case B (higher frequency, interior point not at midpoint): $u(x) = \\sin(3\\pi x)$, so $f(x) = 9\\pi^2 \\sin(3\\pi x)$. Use $N = 10$ and $x_* = 3/10$ (i.e., $m = 3$).\n- Case C (polynomial, exactness edge case): $u(x) = x(1-x)$, so $f(x) = 2$. Use $N = 12$ and $x_* = 1/3$ (i.e., $m = 4$).\n\nFinal output format:\nYour program should produce a single line of output containing the three absolute errors for Cases A, B, and C, in that order, as a comma-separated list enclosed in square brackets. Each number must be printed in scientific notation with $12$ significant digits after the decimal point. For example, your output must have the form \"[a,b,c]\" where $a$, $b$, and $c$ are each printed using the format with $12$ digits after the decimal point in scientific notation.\n\nNo user input is required; all parameters are specified above. No physical units are involved. Angles in all trigonometric functions are in radians. The final numerical answers for each case are simple floating-point numbers.", "solution": "The problem statement is assessed to be valid. It is a well-posed problem in the field of computational engineering, specifically focused on the numerical solution of partial differential equations. The problem is scientifically grounded, free of ambiguity, and contains all necessary information for its resolution. We will proceed with the derivation and implementation as requested.\n\nThe subject is the one-dimensional Poisson boundary value problem:\n$$\n-u''(x) = f(x) \\quad \\text{for } x \\in (0,1)\n$$\nwith homogeneous Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$.\n\nFirst, we derive the finite difference approximation. We discretize the domain $[0,1]$ into $N$ equal subintervals of width $h = 1/N$. The grid points are $x_i = i h$ for $i = 0, 1, \\dots, N$. The interior points are $x_i$ for $i = 1, 2, \\dots, N-1$. Let $U_i$ be the numerical approximation of the exact solution $u(x_i)$ at the grid point $x_i$.\n\nThe second derivative $u''(x_i)$ at an interior node $x_i$ is approximated using the second-order central difference formula:\n$$\nu''(x_i) \\approx \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} = \\frac{u((i-1)h) - 2u(ih) + u((i+1)h)}{h^2}\n$$\nSubstituting this into the Poisson equation at node $x_i$, we get:\n$$\n-\\frac{U_{i-1} - 2U_i + U_{i+1}}{h^2} = f(x_i)\n$$\nThis equation can be rearranged to:\n$$\n-U_{i-1} + 2U_i - U_{i+1} = h^2 f(x_i)\n$$\nThis relation holds for each interior node, $i = 1, 2, \\dots, N-1$. The boundary conditions give $U_0 = u(0) = 0$ and $U_N = u(1) = 0$.\n\nApplying the boundary conditions to the equations for $i=1$ and $i=N-1$:\nFor $i=1$: $-U_0 + 2U_1 - U_2 = h^2 f(x_1)$, which simplifies to $2U_1 - U_2 = h^2 f(x_1)$.\nFor $i=N-1$: $-U_{N-2} + 2U_{N-1} - U_N = h^2 f(x_{N-1})$, which simplifies to $-U_{N-2} + 2U_{N-1} = h^2 f(x_{N-1})$.\n\nThese $N-1$ linear equations can be written in matrix form as $A \\mathbf{U} = \\mathbf{b}$, where $\\mathbf{U} = [U_1, U_2, \\dots, U_{N-1}]^T$ is the vector of unknown nodal values. The matrix $A$ is an $(N-1) \\times (N-1)$ symmetric, positive definite, tridiagonal matrix:\n$$\nA = \\begin{pmatrix}\n2  -1  0  \\cdots  0 \\\\\n-1  2  -1  \\cdots  0 \\\\\n0  -1  2  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  -1 \\\\\n0  \\cdots  0  -1  2\n\\end{pmatrix}\n$$\nThe right-hand side vector $\\mathbf{b}$ is given by:\n$$\n\\mathbf{b} = h^2 \\begin{pmatrix} f(x_1) \\\\ f(x_2) \\\\ \\vdots \\\\ f(x_{N-1}) \\end{pmatrix}\n$$\nSolving this linear system yields the approximate solution $\\mathbf{U}$ at the interior grid points.\n\nNext, we derive the Richardson extrapolation formula. The problem states that the error in the finite-difference solution $U_h(x_*)$ at a fixed point $x_*$ has the asymptotic expansion:\n$$\nU_h(x_*) = u(x_*) + a h^2 + b h^4 + \\mathcal{O}(h^6) \\quad (1)\n$$\nwhere $u(x_*)$ is the exact solution, and $a$ and $b$ are constants independent of the step size $h$.\n\nTo eliminate the leading error term of order $\\mathcal{O}(h^2)$, we compute the solution on a finer grid with step size $h_2 = h/2$. The solution on this grid, $U_{h/2}(x_*)$, has the expansion:\n$$\nU_{h/2}(x_*) = u(x_*) + a (h/2)^2 + b (h/2)^4 + \\mathcal{O}((h/2)^6)\n$$\n$$\nU_{h/2}(x_*) = u(x_*) + \\frac{1}{4} a h^2 + \\frac{1}{16} b h^4 + \\mathcal{O}(h^6) \\quad (2)\n$$\nWe seek a linear combination of $U_h(x_*)$ and $U_{h/2}(x_*)$ that cancels the $a h^2$ term. Multiply equation $(2)$ by $4$ and subtract equation $(1)$:\n$$\n4 U_{h/2}(x_*) - U_h(x_*) = 4\\left(u(x_*) + \\frac{1}{4} a h^2 + \\frac{1}{16} b h^4\\right) - \\left(u(x_*) + a h^2 + b h^4\\right) + \\mathcal{O}(h^6)\n$$\n$$\n4 U_{h/2}(x_*) - U_h(x_*) = (4-1)u(x_*) + (1-1)a h^2 + \\left(\\frac{4}{16}-1\\right)b h^4 + \\mathcal{O}(h^6)\n$$\n$$\n4 U_{h/2}(x_*) - U_h(x_*) = 3u(x_*) - \\frac{3}{4} b h^4 + \\mathcal{O}(h^6)\n$$\nSolving for $u(x_*)$, we obtain a new approximation, which we denote $U^{(4)}(x_*)$:\n$$\nU^{(4)}(x_*) = \\frac{4 U_{h/2}(x_*) - U_h(x_*)}{3} = u(x_*) - \\frac{1}{4} b h^4 + \\mathcal{O}(h^6)\n$$\nThis extrapolated value $U^{(4)}(x_*)$ is a fourth-order accurate approximation to $u(x_*)$. The problem requires its computation using solutions from grids with $2N$ and $4N$ subintervals. Let $h' = 1/(2N)$. Then the two grids have step sizes $h'$ and $h'/2$. The formula is:\n$$\nU^{(4)}(x_*) = \\frac{4 U_{1/(4N)}(x_*) - U_{1/(2N)}(x_*)}{3}\n$$\n\nThe implementation will consist of a function that, for a given $N$ and $f(x)$, constructs and solves the linear system $A \\mathbf{U} = \\mathbf{b}$. This function will be called for the grids with $2N$ and $4N$ subintervals for each test case. The nodal values at the specified point $x_*$ will be extracted. The index of $x_* = m/N$ on a grid with $k \\cdot N$ intervals is $k \\cdot m$. The corresponding $0$-based array index is $k \\cdot m - 1$. The fourth-order approximation is then calculated using the derived formula, and its absolute error with respect to the known exact solution is determined.\n\nFor Case C, where $u(x) = x(1-x)$, the exact solution is a quadratic polynomial. Its fourth derivative is zero, i.e., $u^{(4)}(x) = 0$. The local truncation error of the central difference scheme, which is proportional to $h^2 u^{(4)}(x)$, is therefore exactly zero. Consequently, the numerical solution $U_i$ will be identical to the exact solution $u(x_i)$ at the nodes, up to machine floating-point precision. The extrapolated value will also be exact, and the computed error should be close to zero.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve as solve_linear_system\n\ndef solve_poisson(N, f_func):\n    \"\"\"\n    Solves the 1D Poisson problem -u''=f on (0,1) with u(0)=u(1)=0\n    using a uniform grid with N subintervals.\n\n    Args:\n        N (int): The number of subintervals.\n        f_func (callable): The source function f(x).\n\n    Returns:\n        numpy.ndarray: The vector of numerical solutions at interior nodes.\n    \"\"\"\n    if N = 1:\n        return np.array([])\n    \n    h = 1.0 / N\n    n_interior = N - 1\n    \n    # Construct the tridiagonal matrix A\n    A = 2 * np.eye(n_interior) - np.eye(n_interior, k=1) - np.eye(n_interior, k=-1)\n    \n    # Construct the right-hand side vector b\n    x_nodes = np.linspace(h, 1.0 - h, n_interior)\n    b = h**2 * f_func(x_nodes)\n    \n    # Solve the linear system AU = b\n    U = solve_linear_system(A, b)\n    \n    return U\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            'name': 'A',\n            'u_exact': lambda x: np.sin(np.pi * x),\n            'f': lambda x: np.pi**2 * np.sin(np.pi * x),\n            'N': 8,\n            'm': 4\n        },\n        {\n            'name': 'B',\n            'u_exact': lambda x: np.sin(3 * np.pi * x),\n            'f': lambda x: 9 * np.pi**2 * np.sin(3 * np.pi * x),\n            'N': 10,\n            'm': 3\n        },\n        {\n            'name': 'C',\n            'u_exact': lambda x: x * (1 - x),\n            'f': lambda x: 2.0 + 0*x,  # 0*x to ensure vectorization\n            'N': 12,\n            'm': 4\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N_base = case['N']\n        m = case['m']\n        f_func = case['f']\n        u_exact_func = case['u_exact']\n        \n        # Grid sizes for computation\n        N2 = 2 * N_base\n        N3 = 4 * N_base\n\n        # Solve the problem on the two finest grids\n        U2 = solve_poisson(N2, f_func)\n        U3 = solve_poisson(N3, f_func)\n        \n        # Identify the point of interest x_*\n        x_star = m / N_base\n        \n        # Extract nodal values at x_star\n        # The 0-based index for x_* on a grid k*N is k*m - 1\n        idx2 = 2 * m - 1\n        idx3 = 4 * m - 1\n        \n        u_N2_star = U2[idx2]\n        u_N3_star = U3[idx3]\n        \n        # Apply Richardson extrapolation\n        # U^(4) = (4*U_finer - U_coarser)/3\n        u_extrapolated = (4 * u_N3_star - u_N2_star) / 3.0\n        \n        # Calculate the exact solution at x_star\n        u_true = u_exact_func(x_star)\n        \n        # Calculate the absolute error\n        error = np.abs(u_extrapolated - u_true)\n        results.append(error)\n\n    # Format the final output as specified\n    formatted_results = [f\"{res:.12e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2385975"}]}