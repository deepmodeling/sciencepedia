{"hands_on_practices": [{"introduction": "The journey into the finite element method begins with its most fundamental building block: the element stiffness matrix, which represents the relationships between adjacent nodes within a single element. This first exercise tasks you with deriving this matrix, $K^{(i)}$, from first principles for a one-dimensional diffusion problem. By using a non-uniform, logarithmically spaced mesh instead of a simple uniform one [@problem_id:2420728], you will move beyond rote memorization and demonstrate a true understanding of how an element's specific geometric properties directly shape its contribution to the global system.", "problem": "Consider the boundary value problem in one spatial dimension: find a sufficiently smooth function $u$ on the interval $\\left[x_{a}, x_{b}\\right]$ with $x_{a} > 0$ such that $-\\dfrac{d}{dx}\\left(\\kappa \\dfrac{du}{dx}\\right) = f(x)$ for $x \\in (x_{a}, x_{b})$, where $\\kappa > 0$ is a constant. Let the domain be partitioned into $N$ elements by the strictly increasing node sequence $\\{x_{j}\\}_{j=0}^{N}$ defined by a logarithmically spaced geometric progression,\n$$\nx_{j} = x_{a}\\, r^{\\,j}, \\quad r = \\left(\\dfrac{x_{b}}{x_{a}}\\right)^{\\!1/N}, \\quad j = 0, 1, \\dots, N,\n$$\nso that $x_{0} = x_{a}$ and $x_{N} = x_{b}$. On this mesh, consider the standard continuous piecewise-linear hat functions $\\{\\varphi_{j}\\}_{j=0}^{N}$ used in the finite element method (FEM), where FEM denotes the finite element method. For the element $e_{i} = [x_{i}, x_{i+1}]$ with local linear basis $\\{\\varphi_{i}, \\varphi_{i+1}\\}$, derive the two-by-two element stiffness matrix $K^{(i)}$ associated with the bilinear form induced by the differential operator. Express your final result entirely in terms of $x_{a}$, $x_{b}$, $N$, $i$, and $\\kappa$, using the ratio $r$ as defined above.\n\nYour final answer must be a single closed-form analytic expression for the $2 \\times 2$ matrix $K^{(i)}$. No numerical rounding is required.", "solution": "The weak formulation of the differential equation is obtained by multiplying by a test function $v(x)$ and integrating over the domain $[x_a, x_b]$. We apply integration by parts to the left-hand side term:\n$$\n\\int_{x_a}^{x_b} -\\dfrac{d}{dx}\\left(\\kappa \\dfrac{du}{dx}\\right) v(x) \\,dx = \\int_{x_a}^{x_b} \\kappa \\dfrac{du}{dx}\\dfrac{dv}{dx} \\,dx - \\left[\\kappa \\dfrac{du}{dx} v(x)\\right]_{x_a}^{x_b}\n$$\nThe bilinear form $a(u,v)$ associated with the differential operator is therefore:\n$$\na(u,v) = \\int_{x_a}^{x_b} \\kappa \\dfrac{du}{dx}\\dfrac{dv}{dx} \\,dx\n$$\nThe entries of the global stiffness matrix $K$ are given by $K_{jk} = a(\\varphi_k, \\varphi_j)$. The element stiffness matrix for element $e_i = [x_i, x_{i+1}]$ is a $2 \\times 2$ matrix $K^{(i)}$ associated with the local basis functions $\\varphi_i$ and $\\varphi_{i+1}$. Its entries are computed by restricting the integration to the element domain $[x_i, x_{i+1}]$. Let the local indices be $1$ and $2$, corresponding to global indices $i$ and $i+1$. The entries of $K^{(i)}$ are:\n$$\nK^{(i)}_{mn} = \\int_{x_i}^{x_{i+1}} \\kappa \\dfrac{d\\varphi_{i+m-1}}{dx}\\dfrac{d\\varphi_{i+n-1}}{dx} \\,dx, \\quad \\text{for } m, n \\in \\{1, 2\\}\n$$\nOn the element $e_i = [x_i, x_{i+1}]$, the linear basis functions are defined as:\n$$\n\\varphi_i(x) = \\dfrac{x_{i+1} - x}{x_{i+1} - x_i}\n$$\n$$\n\\varphi_{i+1}(x) = \\dfrac{x - x_i}{x_{i+1} - x_i}\n$$\nThe length of the element is $h_i = x_{i+1} - x_i$. The derivatives of these basis functions are constant over the interval $(x_i, x_{i+1})$:\n$$\n\\dfrac{d\\varphi_i}{dx} = -\\dfrac{1}{x_{i+1} - x_i} = -\\dfrac{1}{h_i}\n$$\n$$\n\\dfrac{d\\varphi_{i+1}}{dx} = \\dfrac{1}{x_{i+1} - x_i} = \\dfrac{1}{h_i}\n$$\nNow, we compute the four entries of the element stiffness matrix $K^{(i)}$. Since $\\kappa$ is a constant, it can be moved outside the integrals.\n\nEntry $K^{(i)}_{11}$:\n$$\nK^{(i)}_{11} = \\int_{x_i}^{x_{i+1}} \\kappa \\left(\\dfrac{d\\varphi_i}{dx}\\right)^2 \\,dx = \\kappa \\int_{x_i}^{x_{i+1}} \\left(-\\dfrac{1}{h_i}\\right)^2 \\,dx = \\dfrac{\\kappa}{h_i^2} \\int_{x_i}^{x_{i+1}} \\,dx = \\dfrac{\\kappa}{h_i^2} (x_{i+1} - x_i) = \\dfrac{\\kappa}{h_i}\n$$\nEntry $K^{(i)}_{22}$:\n$$\nK^{(i)}_{22} = \\int_{x_i}^{x_{i+1}} \\kappa \\left(\\dfrac{d\\varphi_{i+1}}{dx}\\right)^2 \\,dx = \\kappa \\int_{x_i}^{x_{i+1}} \\left(\\dfrac{1}{h_i}\\right)^2 \\,dx = \\dfrac{\\kappa}{h_i^2} \\int_{x_i}^{x_{i+1}} \\,dx = \\dfrac{\\kappa}{h_i^2} (x_{i+1} - x_i) = \\dfrac{\\kappa}{h_i}\n$$\nEntries $K^{(i)}_{12}$ and $K^{(i)}_{21}$:\n$$\nK^{(i)}_{12} = K^{(i)}_{21} = \\int_{x_i}^{x_{i+1}} \\kappa \\left(\\dfrac{d\\varphi_i}{dx}\\right)\\left(\\dfrac{d\\varphi_{i+1}}{dx}\\right) \\,dx = \\kappa \\int_{x_i}^{x_{i+1}} \\left(-\\dfrac{1}{h_i}\\right)\\left(\\dfrac{1}{h_i}\\right) \\,dx = -\\dfrac{\\kappa}{h_i^2} \\int_{x_i}^{x_{i+1}} \\,dx = -\\dfrac{\\kappa}{h_i^2} (x_{i+1} - x_i) = -\\dfrac{\\kappa}{h_i}\n$$\nCombining these results, the element stiffness matrix is:\n$$\nK^{(i)} = \\begin{pmatrix} \\dfrac{\\kappa}{h_i} & -\\dfrac{\\kappa}{h_i} \\\\ -\\dfrac{\\kappa}{h_i} & \\dfrac{\\kappa}{h_i} \\end{pmatrix} = \\dfrac{\\kappa}{h_i} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nThe final step is to express the element length $h_i$ in terms of the given parameters. The nodal coordinates are defined by the geometric progression $x_j = x_a r^j$. Thus, the length of element $e_i$ is:\n$$\nh_i = x_{i+1} - x_i = x_a r^{i+1} - x_a r^i = x_a r^i (r - 1)\n$$\nSubstituting this expression for $h_i$ into the matrix formula yields the final form for the element stiffness matrix:\n$$\nK^{(i)} = \\dfrac{\\kappa}{x_a r^i (r - 1)} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nThis expression depends only on the specified parameters $\\kappa$, $x_a$, $i$, and the ratio $r$, which itself is defined by $x_a$, $x_b$, and $N$. This completes the derivation.", "answer": "$$\n\\boxed{\\frac{\\kappa}{x_{a} r^{i} (r - 1)} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}}\n$$", "id": "2420728"}, {"introduction": "With the element matrices understood, the next step is to assemble them into a global system and solve for the unknown nodal values. This practice problem demonstrates the power and elegance of the weak formulation by introducing a challenging source term: a concentrated \"point load\" represented by a Dirac delta function, which does not conveniently fall on a mesh node [@problem_id:2420776]. Successfully solving this requires a firm grasp of how distributed loads are projected onto the basis functions to form the load vector, showcasing how FEM naturally handles such common and physically important scenarios.", "problem": "Consider the boundary value problem on the interval $[0,1]$:\n$$-u''(x) = \\delta(x - x_0), \\quad u(0)=0,\\quad u(1)=0,$$\nwhere $\\delta$ is the Dirac delta distribution and $x_0=\\frac{3}{5}$ is not a mesh node.\n\nLet the domain $[0,1]$ be partitioned into $N=4$ equal subintervals with nodes $x_i=\\frac{i}{4}$ for $i=0,1,2,3,4$. Let $V_h$ be the space of continuous, piecewise-linear functions on this mesh that vanish at the boundary, spanned by the standard hat functions associated with the interior nodes $x_1=\\frac{1}{4}$, $x_2=\\frac{1}{2}$, and $x_3=\\frac{3}{4}$. Let $u_h \\in V_h$ denote the standard Galerkin finite element approximation.\n\nCompute the value $u_h(x_0)$ at $x_0=\\frac{3}{5}$. Express your answer as a pure number without units. Round your answer to three significant figures.", "solution": "The given problem is a one-dimensional boundary value problem for the Poisson equation with a point source. The problem is to be solved using the standard Galerkin finite element method with piecewise-linear basis functions.\n\nThe problem statement is: find a function $u(x)$ such that\n$$ -u''(x) = \\delta(x - x_0), \\quad x \\in (0,1) $$\nwith boundary conditions $u(0)=0$ and $u(1)=0$. The point source is located at $x_0 = \\frac{3}{5}$.\n\nFirst, we derive the weak formulation. Let $V = H_0^1(0,1)$ be the Sobolev space of functions with square-integrable first derivatives that vanish at the boundaries $x=0$ and $x=1$. We multiply the differential equation by an arbitrary test function $v \\in V$ and integrate over the domain $[0,1]$:\n$$ -\\int_0^1 u''(x) v(x) \\,dx = \\int_0^1 \\delta(x - x_0) v(x) \\,dx $$\nApplying integration by parts to the left-hand side, we obtain:\n$$ \\int_0^1 u'(x) v'(x) \\,dx - [u'(x)v(x)]_0^1 = \\int_0^1 \\delta(x - x_0) v(x) \\,dx $$\nSince $v \\in H_0^1(0,1)$, we have $v(0)=0$ and $v(1)=0$, so the boundary term $[u'(x)v(x)]_0^1$ vanishes. The sifting property of the Dirac delta distribution simplifies the right-hand side:\n$$ \\int_0^1 \\delta(x - x_0) v(x) \\,dx = v(x_0) $$\nThe weak formulation is thus: find $u \\in V$ such that for all $v \\in V$,\n$$ a(u, v) = L(v) $$\nwhere the bilinear form is $a(u,v) = \\int_0^1 u'(x) v'(x) \\,dx$ and the linear functional is $L(v) = v(x_0)$.\n\nNext, we formulate the Galerkin problem. The domain $[0,1]$ is partitioned into $N=4$ equal subintervals, with nodes at $x_i = \\frac{i}{4}$ for $i=0, 1, 2, 3, 4$. The mesh size is $h = x_{i+1} - x_i = \\frac{1}{4}$. The finite element space $V_h \\subset V$ consists of continuous, piecewise-linear functions on this mesh that vanish at $x=0$ and $x=1$. The basis for $V_h$ is the set of standard \"hat\" functions $\\{\\phi_j(x)\\}_{j=1}^3$ associated with the interior nodes $x_1=\\frac{1}{4}$, $x_2=\\frac{1}{2}$, and $x_3=\\frac{3}{4}$.\n\nThe finite element approximation $u_h \\in V_h$ is expressed as a linear combination of these basis functions:\n$$ u_h(x) = \\sum_{j=1}^3 U_j \\phi_j(x) $$\nwhere $U_j = u_h(x_j)$ are the unknown nodal values. The Galerkin method seeks to find $u_h \\in V_h$ such that $a(u_h, v_h) = L(v_h)$ for all $v_h \\in V_h$. It is sufficient to enforce this for each basis function $v_h = \\phi_i(x)$, for $i=1, 2, 3$:\n$$ \\int_0^1 \\left( \\sum_{j=1}^3 U_j \\phi_j'(x) \\right) \\phi_i'(x) \\,dx = \\phi_i(x_0) $$\nThis yields a system of linear equations $A \\vec{U} = \\vec{f}$, where $\\vec{U} = (U_1, U_2, U_3)^T$, the stiffness matrix $A$ has entries $A_{ij} = \\int_0^1 \\phi_i'(x) \\phi_j'(x) \\,dx$, and the load vector $\\vec{f}$ has entries $f_i = \\phi_i(x_0)$.\n\nWe compute the stiffness matrix $A$. The derivative of the hat function $\\phi_i(x)$ is piecewise constant:\n$$ \\phi_i'(x) = \\begin{cases} \\frac{1}{h} & \\text{for } x \\in (x_{i-1}, x_i) \\\\ -\\frac{1}{h} & \\text{for } x \\in (x_i, x_{i+1}) \\\\ 0 & \\text{otherwise} \\end{cases} $$\nThe entries of the stiffness matrix for a uniform mesh are standard:\n$A_{ii} = \\int_{x_{i-1}}^{x_{i+1}} (\\phi_i'(x))^2 \\,dx = \\int_{x_{i-1}}^{x_i} (\\frac{1}{h})^2 \\,dx + \\int_{x_i}^{x_{i+1}} (-\\frac{1}{h})^2 \\,dx = \\frac{1}{h^2} (h) + \\frac{1}{h^2} (h) = \\frac{2}{h}$.\n$A_{i, i+1} = \\int_0^1 \\phi_i'(x) \\phi_{i+1}'(x) \\,dx = \\int_{x_i}^{x_{i+1}} (-\\frac{1}{h})(\\frac{1}{h}) \\,dx = -\\frac{1}{h^2} (h) = -\\frac{1}{h}$.\nBy symmetry, $A_{i+1, i} = -\\frac{1}{h}$. All other off-diagonal entries are zero.\nWith $h=\\frac{1}{4}$, we have $\\frac{1}{h}=4$. The stiffness matrix is:\n$$ A = \\frac{1}{h} \\begin{pmatrix} 2 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 2 \\end{pmatrix} = 4 \\begin{pmatrix} 2 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 2 \\end{pmatrix} = \\begin{pmatrix} 8 & -4 & 0 \\\\ -4 & 8 & -4 \\\\ 0 & -4 & 8 \\end{pmatrix} $$\n\nWe compute the load vector $\\vec{f}$. The entries are $f_i = \\phi_i(x_0)$ for $x_0=\\frac{3}{5}=0.6$. The nodes are $x_1=0.25$, $x_2=0.5$, $x_3=0.75$. The point $x_0=0.6$ lies in the subinterval $[x_2, x_3] = [0.5, 0.75]$. In this interval, only $\\phi_2(x)$ and $\\phi_3(x)$ are non-zero.\nTherefore, $f_1 = \\phi_1(x_0)=0$.\n$f_2 = \\phi_2(x_0) = \\frac{x_3 - x_0}{h} = \\frac{\\frac{3}{4} - \\frac{3}{5}}{\\frac{1}{4}} = \\frac{\\frac{15-12}{20}}{\\frac{1}{4}} = \\frac{3}{20} \\cdot 4 = \\frac{3}{5}$.\n$f_3 = \\phi_3(x_0) = \\frac{x_0 - x_2}{h} = \\frac{\\frac{3}{5} - \\frac{1}{2}}{\\frac{1}{4}} = \\frac{\\frac{6-5}{10}}{\\frac{1}{4}} = \\frac{1}{10} \\cdot 4 = \\frac{2}{5}$.\nThe load vector is $\\vec{f} = (0, \\frac{3}{5}, \\frac{2}{5})^T$.\n\nNow, we solve the linear system $A \\vec{U} = \\vec{f}$:\n$$ \\begin{pmatrix} 8 & -4 & 0 \\\\ -4 & 8 & -4 \\\\ 0 & -4 & 8 \\end{pmatrix} \\begin{pmatrix} U_1 \\\\ U_2 \\\\ U_3 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ \\frac{3}{5} \\\\ \\frac{2}{5} \\end{pmatrix} $$\nFrom the first equation, $8U_1 - 4U_2 = 0 \\implies U_1 = \\frac{1}{2}U_2$.\nSubstituting this into the second equation: $-4(\\frac{1}{2}U_2) + 8U_2 - 4U_3 = \\frac{3}{5} \\implies 6U_2 - 4U_3 = \\frac{3}{5}$.\nThe third equation is $-4U_2 + 8U_3 = \\frac{2}{5}$, which simplifies to $-2U_2 + 4U_3 = \\frac{1}{5}$.\nWe now have a $2 \\times 2$ system for $U_2$ and $U_3$:\n$$ 6U_2 - 4U_3 = \\frac{3}{5} $$\n$$ -2U_2 + 4U_3 = \\frac{1}{5} $$\nAdding the two equations gives $4U_2 = \\frac{4}{5}$, so $U_2 = \\frac{1}{5}$.\nSubstituting $U_2=\\frac{1}{5}$ back into the simplified third equation: $-2(\\frac{1}{5}) + 4U_3 = \\frac{1}{5} \\implies 4U_3 = \\frac{3}{5} \\implies U_3 = \\frac{3}{20}$.\nFinally, $U_1 = \\frac{1}{2}U_2 = \\frac{1}{2}(\\frac{1}{5}) = \\frac{1}{10}$.\nThe nodal values are $\\vec{U} = (\\frac{1}{10}, \\frac{1}{5}, \\frac{3}{20})^T$.\n\nThe task is to compute $u_h(x_0)$. Since $x_0 \\in [x_2, x_3]$, the solution $u_h(x_0)$ is determined by the linear interpolation between the nodal values $U_2$ and $U_3$. The formula for $u_h(x)$ on this interval is:\n$$ u_h(x) = U_2 \\phi_2(x) + U_3 \\phi_3(x), \\quad x \\in [x_2, x_3] $$\nWe evaluate this at $x=x_0=\\frac{3}{5}$:\n$$ u_h(x_0) = U_2 \\phi_2(x_0) + U_3 \\phi_3(x_0) $$\nWe have already computed $U_2 = \\frac{1}{5}$, $U_3 = \\frac{3}{20}$, $\\phi_2(x_0) = \\frac{3}{5}$, and $\\phi_3(x_0) = \\frac{2}{5}$.\nSubstituting these values:\n$$ u_h(\\frac{3}{5}) = (\\frac{1}{5}) (\\frac{3}{5}) + (\\frac{3}{20}) (\\frac{2}{5}) = \\frac{3}{25} + \\frac{6}{100} = \\frac{12}{100} + \\frac{6}{100} = \\frac{18}{100} = 0.18 $$\nAs a decimal, this is $0.18$. The problem requests the answer to be rounded to three significant figures. Thus, the value is $0.180$.", "answer": "$$\\boxed{0.180}$$", "id": "2420776"}, {"introduction": "Our exploration now extends to problems involving time or inertia, such as mechanical vibrations or transient heat flow, which require a mass matrix in addition to the stiffness matrix. This advanced exercise guides you through the derivation of the \"consistent\" mass matrix, $\\mathbf{M}$, and its common, computationally efficient approximation, the \"lumped\" mass matrix, $\\mathbf{M}_{\\mathrm{L}}$ [@problem_id:2420751]. By comparing the eigenvalue spectra of these two matrices, you will gain deep insight into a classic trade-off between theoretical accuracy and computational performance that is central to practical engineering simulation.", "problem": "Consider a one-dimensional domain $\\Omega = [0,L]$ with $L = 1$ discretized into nodes $\\{x_0, x_1, \\dots, x_N\\}$ with $x_0 = 0$ and $x_N = 1$. Let $\\{\\varphi_i(x)\\}_{i=0}^N$ denote the standard piecewise-linear \"hat\" basis functions associated with these nodes, where each $\\varphi_i(x)$ is continuous, equals $1$ at node $x_i$, equals $0$ at all other nodes $x_j$ with $j \\neq i$, and is linear on each subinterval $[x_{i-1}, x_i]$ and $[x_i, x_{i+1}]$ where defined. Assume constant density $\\rho = 1$.\n\nUsing the Galerkin finite element method (FEM), the consistent mass matrix $\\mathbf{M} \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ is defined by the $L^2(\\Omega)$ inner product\n$$\nM_{ij} = \\int_0^L \\varphi_i(x)\\,\\varphi_j(x)\\,dx \\quad \\text{for all } i,j \\in \\{0,1,\\dots,N\\}.\n$$\nThe lumped mass matrix $\\mathbf{M}_{\\mathrm{L}} \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ is the diagonal matrix formed by the row-sum heuristic applied to $\\mathbf{M}$, namely\n$$\n(\\mathbf{M}_{\\mathrm{L}})_{ii} = \\sum_{j=0}^N M_{ij}, \\quad (\\mathbf{M}_{\\mathrm{L}})_{ij} = 0 \\text{ for } i \\neq j.\n$$\n\nTask A (derivation). Starting only from the definitions of the basis functions $\\{\\varphi_i(x)\\}$ and the inner product defining $M_{ij}$ above, derive the local element-level consistent mass matrix on a generic element $[x_e, x_{e+1}]$ with element length $h_e = x_{e+1} - x_e$, using the two local hat functions that are linearly mapped from $[x_e, x_{e+1}]$ to $[0,h_e]$. Show how to assemble the global consistent mass matrix $\\mathbf{M}$ from these local contributions.\n\nTask B (implementation and comparison). Implement assembly of both $\\mathbf{M}$ and $\\mathbf{M}_{\\mathrm{L}}$ for an arbitrary strictly increasing node array $\\{x_i\\}_{i=0}^N$. To quantitatively compare their eigenvalue spectra in a basis-independent way, form the symmetric positive definite (SPD) similarity-transformed matrix\n$$\n\\mathbf{S} = \\mathbf{M}_{\\mathrm{L}}^{-\\frac{1}{2}}\\,\\mathbf{M}\\,\\mathbf{M}_{\\mathrm{L}}^{-\\frac{1}{2}},\n$$\nwhose spectrum equals that of $\\mathbf{M}_{\\mathrm{L}}^{-1}\\mathbf{M}$. Compute the minimum and maximum eigenvalues of $\\mathbf{S}$ for each of the test meshes listed below. Report each pair as a list $[\\lambda_{\\min}, \\lambda_{\\max}]$ of real numbers.\n\nTest suite (use exactly these four meshes in this order):\n- Test case $1$ (single element, uniform): nodes $[0, 1]$.\n- Test case $2$ (uniform, multiple elements): nodes $[0, \\tfrac{1}{4}, \\tfrac{1}{2}, \\tfrac{3}{4}, 1]$.\n- Test case $3$ (non-uniform): nodes $[0, 0.1, 0.3, 0.6, 1.0]$.\n- Test case $4$ (uniform, finer): nodes $[0, \\tfrac{1}{50}, \\tfrac{2}{50}, \\dots, 1]$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list of lists, in the same order as the test cases, with no spaces. For example, the required format is\n`[[\\lambda_{\\min}^{(1)},\\lambda_{\\max}^{(1)}],[\\lambda_{\\min}^{(2)},\\lambda_{\\max}^{(2)}],[\\lambda_{\\min}^{(3)},\\lambda_{\\max}^{(3)}],[\\lambda_{\\min}^{(4)},\\lambda_{\\max}^{(4)}]`\nEach $\\lambda_{\\min}^{(k)}$ and $\\lambda_{\\max}^{(k)}$ must be output as a floating-point number. No physical units are involved in this problem, and no angles or percentages are required.", "solution": "The problem is based on the standard one-dimensional finite element method with piecewise linear basis functions on a mesh $\\{x_i\\}_{i=0}^N$ covering $\\Omega = [0,1]$. The mass matrix captures the $L^2(\\Omega)$ inner product of basis functions, and the \"lumped\" variant replaces the full matrix with a diagonal approximation constructed by summing each row. To derive and implement the comparison, we proceed from first principles.\n\nDefinition of hat functions. For each node $x_i$, the hat function $\\varphi_i(x)$ is the continuous, piecewise linear function such that $\\varphi_i(x_i) = 1$ and $\\varphi_i(x_j) = 0$ for all $j \\neq i$. It is supported only on $[x_{i-1}, x_i] \\cup [x_i, x_{i+1}]$ (with the obvious truncation at boundaries). On any element $[x_e, x_{e+1}]$ with length $h_e = x_{e+1}-x_e$, there are exactly two nonzero local basis functions, which we denote by $\\hat{\\varphi}_1$ and $\\hat{\\varphi}_2$ such that $\\hat{\\varphi}_1(x_e) = 1$, $\\hat{\\varphi}_1(x_{e+1}) = 0$, and $\\hat{\\varphi}_2(x_e) = 0$, $\\hat{\\varphi}_2(x_{e+1}) = 1$. By linearity, on this element and using a local coordinate $\\xi \\in [0,h_e]$ defined by $\\xi = x - x_e$, these local basis functions are\n$$\n\\hat{\\varphi}_1(\\xi) = 1 - \\frac{\\xi}{h_e}, \\quad \\hat{\\varphi}_2(\\xi) = \\frac{\\xi}{h_e}.\n$$\n\nConsistent mass matrix at the element level. The element-level consistent mass matrix $\\mathbf{M}^{(e)} \\in \\mathbb{R}^{2\\times 2}$ is defined by the integrals of products of local basis functions on the element:\n$$\nM^{(e)}_{ij} = \\int_{x_e}^{x_{e+1}} \\hat{\\varphi}_i(x)\\,\\hat{\\varphi}_j(x)\\,dx = \\int_{0}^{h_e} \\hat{\\varphi}_i(\\xi)\\,\\hat{\\varphi}_j(\\xi)\\,d\\xi,\\quad i,j \\in \\{1,2\\}.\n$$\nComputing these integrals directly from the definitions yields\n$$\n\\int_{0}^{h_e} \\left(1 - \\frac{\\xi}{h_e}\\right)^2 d\\xi = \\int_{0}^{h_e} \\left(1 - \\frac{2\\xi}{h_e} + \\frac{\\xi^2}{h_e^2}\\right) d\\xi\n= \\left[\\xi - \\frac{\\xi^2}{h_e} + \\frac{\\xi^3}{3 h_e^2}\\right]_0^{h_e} = \\frac{h_e}{3},\n$$\n$$\n\\int_{0}^{h_e} \\left(\\frac{\\xi}{h_e}\\right)^2 d\\xi = \\int_{0}^{h_e} \\frac{\\xi^2}{h_e^2} d\\xi = \\left[\\frac{\\xi^3}{3 h_e^2}\\right]_0^{h_e} = \\frac{h_e}{3},\n$$\n$$\n\\int_{0}^{h_e} \\left(1 - \\frac{\\xi}{h_e}\\right)\\left(\\frac{\\xi}{h_e}\\right) d\\xi\n= \\int_{0}^{h_e} \\left(\\frac{\\xi}{h_e} - \\frac{\\xi^2}{h_e^2}\\right) d\\xi\n= \\left[\\frac{\\xi^2}{2 h_e} - \\frac{\\xi^3}{3 h_e^2}\\right]_0^{h_e} = \\frac{h_e}{6}.\n$$\nTherefore,\n$$\n\\mathbf{M}^{(e)} = \\begin{bmatrix}\n\\frac{h_e}{3} & \\frac{h_e}{6} \\\\\n\\frac{h_e}{6} & \\frac{h_e}{3}\n\\end{bmatrix} \\;=\\; \\frac{h_e}{6} \\begin{bmatrix}\n2 & 1 \\\\ 1 & 2\n\\end{bmatrix}.\n$$\n\nAssembly of the global consistent mass matrix. The global matrix $\\mathbf{M} \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ is obtained by summing each element's contributions into the rows and columns corresponding to its endpoint global node indices. Specifically, for element $e$ with global nodes $(e, e+1)$, we add:\n$$\nM_{e,e} \\mathrel{+}= \\frac{h_e}{3}, \\quad M_{e,e+1} \\mathrel{+}= \\frac{h_e}{6}, \\quad M_{e+1,e} \\mathrel{+}= \\frac{h_e}{6}, \\quad M_{e+1,e+1} \\mathrel{+}= \\frac{h_e}{3}.\n$$\nAfter processing all elements, $\\mathbf{M}$ is symmetric positive definite (SPD).\n\nLumped mass matrix via row-sum heuristic. The lumped mass matrix $\\mathbf{M}_{\\mathrm{L}}$ is defined by\n$$\n(\\mathbf{M}_{\\mathrm{L}})_{ii} = \\sum_{j=0}^{N} M_{ij}, \\quad (\\mathbf{M}_{\\mathrm{L}})_{ij} = 0 \\text{ for } i \\neq j.\n$$\nEquivalently, one can verify from the local formula that each element $[x_e, x_{e+1}]$ contributes $\\frac{h_e}{2}$ to each of its two endpoint nodes' diagonal entries, so that for interior nodes $i \\in \\{1,\\dots,N-1\\}$ one has\n$$\n(\\mathbf{M}_{\\mathrm{L}})_{ii} = \\frac{h_{i-1}}{2} + \\frac{h_{i}}{2},\n$$\nwhile for boundary nodes,\n$$\n(\\mathbf{M}_{\\mathrm{L}})_{00} = \\frac{h_{0}}{2}, \\quad (\\mathbf{M}_{\\mathrm{L}})_{NN} = \\frac{h_{N-1}}{2}.\n$$\nEither construction (row-sum of $\\mathbf{M}$ or summing element-level halves) yields the same diagonal for piecewise linear elements.\n\nSimilarity transform for spectrum comparison. To compare spectra in a basis-independent manner, form\n$$\n\\mathbf{S} = \\mathbf{M}_{\\mathrm{L}}^{-\\frac{1}{2}}\\,\\mathbf{M}\\,\\mathbf{M}_{\\mathrm{L}}^{-\\frac{1}{2}},\n$$\nwhich is SPD because $\\mathbf{M}$ and $\\mathbf{M}_{\\mathrm{L}}$ are SPD and $\\mathbf{M}_{\\mathrm{L}}^{-\\frac{1}{2}}$ exists. The eigenvalues of $\\mathbf{S}$ equal those of $\\mathbf{M}_{\\mathrm{L}}^{-1}\\mathbf{M}$, but $\\mathbf{S}$ is symmetric, so it is numerically preferable for computing eigenvalues using symmetric eigensolvers. If $\\mathbf{M}$ exactly equaled $\\mathbf{M}_{\\mathrm{L}}$, then $\\mathbf{S}$ would be the identity matrix and all eigenvalues would equal $1$. Deviations of the eigenvalues from $1$ quantify the difference between the consistent and lumped mass matrices.\n\nAlgorithmic steps for each test case mesh $\\{x_i\\}$:\n1. Compute element lengths $h_e = x_{e+1} - x_e$ for all $e \\in \\{0,\\dots,N-1\\}$ and verify $h_e > 0$.\n2. Initialize $\\mathbf{M}$ as the zero matrix in $\\mathbb{R}^{(N+1)\\times(N+1)}$.\n3. For each element $e$, add the local matrix contributions $\\frac{h_e}{6}\\begin{bmatrix}2 & 1 \\\\ 1 & 2\\end{bmatrix}$ into the global entries $(e,e)$, $(e,e+1)$, $(e+1,e)$, $(e+1,e+1)$.\n4. Form $\\mathbf{M}_{\\mathrm{L}}$ by summing rows of $\\mathbf{M}$ to obtain its diagonal entries, with off-diagonals set to zero.\n5. Form $\\mathbf{S}$ efficiently using the diagonal entries by scaling rows and columns: if $\\mathbf{D} = \\operatorname{diag}(\\mathbf{M}_{\\mathrm{L}})$ and $\\mathbf{d} = \\operatorname{diag}(\\mathbf{D})$, then $\\mathbf{S}_{ij} = \\mathbf{M}_{ij} / \\sqrt{d_i d_j}$.\n6. Compute the smallest and largest eigenvalues of $\\mathbf{S}$ using a symmetric eigensolver.\n7. Record $[\\lambda_{\\min}, \\lambda_{\\max}]$ in the order of the test cases.\n\nAnalytical check for the single-element case (test case $1$). With nodes $[0,1]$, we have $h_0 = 1$, so\n$$\n\\mathbf{M} = \\frac{1}{6}\\begin{bmatrix}2 & 1 \\\\ 1 & 2\\end{bmatrix} = \\begin{bmatrix}\\frac{1}{3} & \\frac{1}{6} \\\\ \\frac{1}{6} & \\frac{1}{3}\\end{bmatrix}, \\quad\n\\mathbf{M}_{\\mathrm{L}} = \\begin{bmatrix}\\frac{1}{2} & 0 \\\\ 0 & \\frac{1}{2}\\end{bmatrix}.\n$$\nThen\n$$\n\\mathbf{S} = \\mathbf{M}_{\\mathrm{L}}^{-\\frac{1}{2}} \\mathbf{M} \\mathbf{M}_{\\mathrm{L}}^{-\\frac{1}{2}} = 2 \\mathbf{M} = \\begin{bmatrix}\\frac{2}{3} & \\frac{1}{3} \\\\ \\frac{1}{3} & \\frac{2}{3}\\end{bmatrix}.\n$$\nThe eigenvalues of a symmetric $2\\times 2$ matrix with equal diagonals $a$ and off-diagonal $c$ are $a+c$ and $a-c$. Here $a = \\frac{2}{3}$ and $c = \\frac{1}{3}$, so the eigenvalues are $1$ and $\\frac{1}{3}$. This provides a consistency check for the implementation.\n\nImplementation notes. The assembly can be performed with $\\mathcal{O}(N)$ operations. The matrix $\\mathbf{S}$ is built by scaling the rows and columns of $\\mathbf{M}$ with the reciprocals of the square roots of the diagonal of $\\mathbf{M}_{\\mathrm{L}}$. The eigenvalue computation uses a symmetric eigensolver, which is robust for SPD matrices. For all four test cases, the matrices are small and well-conditioned, so direct dense computations are appropriate.\n\nThe program will construct the four meshes exactly as specified and print a single line containing a list of four lists, each with the smallest and largest eigenvalues for the corresponding test case, with no spaces. The first pair should match the analytical values $[\\frac{1}{3}, 1]$ up to floating-point rounding. The other pairs will be computed numerically.\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_consistent_mass(x):\n    \"\"\"\n    Assemble the global consistent mass matrix M for 1D linear finite elements\n    on the given strictly increasing node array x (length N+1).\n    Density rho = 1 is assumed.\n    Returns:\n        M: (N+1)x(N+1) symmetric positive definite numpy array\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    N = len(x) - 1  # number of elements\n    n_nodes = N + 1\n    M = np.zeros((n_nodes, n_nodes), dtype=float)\n    for e in range(N):\n        h = x[e+1] - x[e]\n        if h = 0:\n            raise ValueError(\"Node coordinates must be strictly increasing.\")\n        # Local consistent mass matrix for linear element: h/6 * [[2,1],[1,2]]\n        m00 = h / 3.0\n        m01 = h / 6.0\n        m11 = h / 3.0\n        i = e\n        j = e + 1\n        M[i, i] += m00\n        M[i, j] += m01\n        M[j, i] += m01\n        M[j, j] += m11\n    return M\n\ndef lump_mass_by_rowsum(M):\n    \"\"\"\n    Construct lumped mass matrix diagonal by row-sum heuristic.\n    Returns:\n        diag: 1D numpy array of diagonal entries of lumped mass matrix\n    \"\"\"\n    # Row-sum of M yields the diagonal of the lumped mass matrix for linear elements\n    diag = M.sum(axis=1)\n    # Ensure strict positivity\n    if np.any(diag = 0):\n        raise ValueError(\"Lumped mass diagonal must be strictly positive.\")\n    return diag\n\ndef scaled_similarity_matrix(M, lump_diag):\n    \"\"\"\n    Form S = D^{-1/2} M D^{-1/2}, where D = diag(lump_diag).\n    Returns:\n        S: symmetric similarity-transformed matrix\n    \"\"\"\n    inv_sqrt = 1.0 / np.sqrt(lump_diag)\n    # Efficient symmetric scaling: S_ij = M_ij / sqrt(di_i * di_j)\n    S = (inv_sqrt[:, None] * M) * inv_sqrt[None, :]\n    # Symmetrize numerically to avoid tiny asymmetry due to floating point ops\n    S = 0.5 * (S + S.T)\n    return S\n\ndef eigen_extremes_symmetric(S):\n    \"\"\"\n    Compute the smallest and largest eigenvalues of a symmetric matrix S.\n    Returns:\n        (lam_min, lam_max)\n    \"\"\"\n    # Using eigh for symmetric matrices; returns sorted eigenvalues\n    evals = np.linalg.eigvalsh(S)\n    return float(evals[0]), float(evals[-1])\n\ndef format_nested_no_spaces(nested):\n    \"\"\"\n    Format a nested list (list of lists of floats) without spaces, like JSON.\n    \"\"\"\n    def format_number(x):\n        # Use a compact representation while preserving precision reasonably\n        return f\"{x:.16g}\"\n    parts = []\n    parts.append(\"[\")\n    for i, sub in enumerate(nested):\n        parts.append(\"[\")\n        parts.append(\",\".join(format_number(v) for v in sub))\n        parts.append(\"]\")\n        if i != len(nested) - 1:\n            parts.append(\",\")\n    parts.append(\"]\")\n    return \"\".join(parts)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: single element, uniform\n        [0.0, 1.0],\n        # Test case 2: uniform, multiple elements (4 elements)\n        [0.0, 0.25, 0.5, 0.75, 1.0],\n        # Test case 3: non-uniform\n        [0.0, 0.1, 0.3, 0.6, 1.0],\n        # Test case 4: uniform, finer (50 elements -> 51 nodes)\n        list(np.linspace(0.0, 1.0, 51)),\n    ]\n\n    results = []\n    for x in test_cases:\n        M = assemble_consistent_mass(x)\n        lump_diag = lump_mass_by_rowsum(M)\n        S = scaled_similarity_matrix(M, lump_diag)\n        lam_min, lam_max = eigen_extremes_symmetric(S)\n        results.append([lam_min, lam_max])\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_nested_no_spaces(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "answer": "[[0.3333333333333333,1],[0.3632737600632599,1],[0.301511344909668,1],[0.3336670003732007,1]]", "id": "2420751"}]}