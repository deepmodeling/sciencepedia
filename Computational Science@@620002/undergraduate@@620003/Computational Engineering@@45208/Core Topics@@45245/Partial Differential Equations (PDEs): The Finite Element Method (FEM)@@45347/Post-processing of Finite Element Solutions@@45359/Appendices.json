{"hands_on_practices": [{"introduction": "The finite element method builds solutions from simple, piecewise functions, which are inherently approximations of the true, continuous physical fields. This first exercise provides a direct, hands-on calculation of this approximation error at its most fundamental level [@problem_id:2426703]. By comparing the exact strain from a known analytical displacement field to the strain recovered from a single bilinear element, you will quantify the interpolation error and gain a crucial intuition for the source of inaccuracies in finite element analysis.", "problem": "Consider a single isoparametric bilinear quadrilateral element of the Finite Element Method (FEM) occupying the unit square domain $\\Omega = \\{(x,y)\\,|\\,0 \\le x \\le 1,\\; 0 \\le y \\le 1\\}$ in Cartesian coordinates. The exact (analytical) displacement field is\n$$\n\\mathbf{u}(x,y) = \\begin{pmatrix} u(x,y) \\\\ v(x,y) \\end{pmatrix} = \\begin{pmatrix} x^{2} \\\\ y^{2} \\end{pmatrix}.\n$$\nThe exact small-strain tensor is defined by\n$$\n\\boldsymbol{\\varepsilon}(x,y) = \\tfrac{1}{2}\\big(\\nabla \\mathbf{u}(x,y) + \\nabla \\mathbf{u}(x,y)^{\\mathsf{T}}\\big).\n$$\nDefine the recovered finite element strain tensor $\\boldsymbol{\\varepsilon}_{h}(x,y)$ as follows: sample $\\mathbf{u}(x,y)$ at the four element corner nodes $(0,0)$, $(1,0)$, $(1,1)$, and $(0,1)$ to obtain nodal displacement vectors. Construct the bilinear interpolant of the displacement field using the standard bilinear shape functions on the unit square,\n$$\nN_{1}(x,y) = (1-x)(1-y),\\quad N_{2}(x,y) = x(1-y),\\quad N_{3}(x,y) = xy,\\quad N_{4}(x,y) = (1-x)y,\n$$\nand then compute $\\boldsymbol{\\varepsilon}_{h}(x,y)$ as the small-strain tensor of the interpolated displacement field, i.e., by applying the same symmetric gradient operator to the interpolated $\\mathbf{u}_{h}(x,y)$.\n\nLet the strain error tensor be $\\boldsymbol{e}_{\\varepsilon}(x,y) = \\boldsymbol{\\varepsilon}(x,y) - \\boldsymbol{\\varepsilon}_{h}(x,y)$. Using the Frobenius norm $|\\!|\\mathbf{A}|\\!|_{F}^{2} = \\mathbf{A}:\\mathbf{A}$, compute the element-wise $L^{2}$-norm of the strain error\n$$\nE = \\left(\\int_{0}^{1}\\int_{0}^{1} \\big\\| \\boldsymbol{e}_{\\varepsilon}(x,y) \\big\\|_{F}^{2}\\,\\mathrm{d}x\\,\\mathrm{d}y \\right)^{1/2}.\n$$\nProvide the exact value of $E$ as a closed-form expression. No rounding is required. Since strain is dimensionless, no units are required in the final answer.", "solution": "The problem statement is submitted for validation.\n\n**Step 1: Extract Givens**\n- Domain of integration: $\\Omega = \\{(x,y)\\,|\\,0 \\le x \\le 1,\\; 0 \\le y \\le 1\\}$.\n- Exact displacement field: $\\mathbf{u}(x,y) = \\begin{pmatrix} u(x,y) \\\\ v(x,y) \\end{pmatrix} = \\begin{pmatrix} x^{2} \\\\ y^{2} \\end{pmatrix}$.\n- Exact small-strain tensor definition: $\\boldsymbol{\\varepsilon}(x,y) = \\tfrac{1}{2}\\big(\\nabla \\mathbf{u}(x,y) + \\nabla \\mathbf{u}(x,y)^{\\mathsf{T}}\\big)$.\n- Element corner nodes: $(0,0)$, $(1,0)$, $(1,1)$, and $(0,1)$.\n- Bilinear shape functions: $N_{1}(x,y) = (1-x)(1-y)$, $N_{2}(x,y) = x(1-y)$, $N_{3}(x,y) = xy$, $N_{4}(x,y) = (1-x)y$.\n- Recovered strain tensor $\\boldsymbol{\\varepsilon}_{h}(x,y)$ is derived from the interpolated displacement field $\\mathbf{u}_{h}(x,y)$, which is constructed using the given shape functions and nodal displacements sampled from $\\mathbf{u}(x,y)$.\n- Strain error tensor: $\\boldsymbol{e}_{\\varepsilon}(x,y) = \\boldsymbol{\\varepsilon}(x,y) - \\boldsymbol{\\varepsilon}_{h}(x,y)$.\n- Frobenius norm definition: $|\\!|\\mathbf{A}|\\!|_{F}^{2} = \\mathbf{A}:\\mathbf{A} = \\sum_{i,j} A_{ij}^2$.\n- Error quantity to compute: $E = \\left(\\int_{0}^{1}\\int_{0}^{1} \\big\\| \\boldsymbol{e}_{\\varepsilon}(x,y) \\big\\|_{F}^{2}\\,\\mathrm{d}x\\,\\mathrm{d}y \\right)^{1/2}$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, as it employs standard definitions and procedures from continuum mechanics and the Finite Element Method (FEM). The concepts of bilinear interpolation, small-strain tensor, and $L^2$-norm error are fundamental to computational engineering. The problem is well-posed, providing all necessary functions, definitions, and domains to compute a unique, meaningful solution. The language is objective and mathematically precise. The problem contains no scientific unsoundness, missing information, or logical contradictions. The specified node ordering and shape functions are standard for a unit quadrilateral element.\n\n**Step 3: Verdict and Action**\nThe problem is deemed valid. A complete solution will be provided.\n\nThe solution proceeds systematically. First, we determine the interpolated displacement field $\\mathbf{u}_{h}(x,y)$. Second, we compute the exact strain tensor $\\boldsymbol{\\varepsilon}(x,y)$ and the interpolated strain tensor $\\boldsymbol{\\varepsilon}_{h}(x,y)$. Third, we find the strain error tensor $\\boldsymbol{e}_{\\varepsilon}(x,y)$. Finally, we compute its $L^{2}$-norm over the element domain.\n\n**1. Construct the Interpolated Displacement Field $\\mathbf{u}_{h}(x,y)$**\nWe must first evaluate the exact displacement field $\\mathbf{u}(x,y)$ at the four corner nodes of the unit square. The nodes are numbered counter-clockwise starting from the origin: Node $1$ is $(0,0)$, Node $2$ is $(1,0)$, Node $3$ is $(1,1)$, and Node $4$ is $(0,1)$.\nThe nodal displacement vectors are:\n$$\n\\mathbf{u}_{1} = \\mathbf{u}(0,0) = \\begin{pmatrix} 0^{2} \\\\ 0^{2} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n$$\n\\mathbf{u}_{2} = \\mathbf{u}(1,0) = \\begin{pmatrix} 1^{2} \\\\ 0^{2} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}\n$$\n$$\n\\mathbf{u}_{3} = \\mathbf{u}(1,1) = \\begin{pmatrix} 1^{2} \\\\ 1^{2} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}\n$$\n$$\n\\mathbf{u}_{4} = \\mathbf{u}(0,1) = \\begin{pmatrix} 0^{2} \\\\ 1^{2} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\nThe interpolated displacement field $\\mathbf{u}_{h}(x,y) = \\begin{pmatrix} u_{h}(x,y) \\\\ v_{h}(x,y) \\end{pmatrix}$ is constructed using the bilinear shape functions:\n$$\n\\mathbf{u}_{h}(x,y) = \\sum_{i=1}^{4} N_{i}(x,y) \\mathbf{u}_{i} = N_{1}(x,y)\\mathbf{u}_{1} + N_{2}(x,y)\\mathbf{u}_{2} + N_{3}(x,y)\\mathbf{u}_{3} + N_{4}(x,y)\\mathbf{u}_{4}\n$$\nSubstituting the shape functions and nodal displacements:\n$$\n\\mathbf{u}_{h}(x,y) = (1-x)(1-y)\\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} + x(1-y)\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + xy\\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} + (1-x)y\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\nWe compute the components $u_{h}$ and $v_{h}$:\n$$\nu_{h}(x,y) = 0 \\cdot (1-x)(1-y) + 1 \\cdot x(1-y) + 1 \\cdot xy + 0 \\cdot (1-x)y = x(1-y) + xy = x - xy + xy = x\n$$\n$$\nv_{h}(x,y) = 0 \\cdot (1-x)(1-y) + 0 \\cdot x(1-y) + 1 \\cdot xy + 1 \\cdot (1-x)y = xy + y(1-x) = xy + y - xy = y\n$$\nThus, the interpolated displacement field is:\n$$\n\\mathbf{u}_{h}(x,y) = \\begin{pmatrix} x \\\\ y \\end{pmatrix}\n$$\n\n**2. Compute the Strain Tensors $\\boldsymbol{\\varepsilon}(x,y)$ and $\\boldsymbol{\\varepsilon}_{h}(x,y)$**\nThe strain tensor $\\boldsymbol{\\varepsilon}$ is the symmetric part of the displacement gradient $\\nabla \\mathbf{u}$.\nFor the exact displacement field $\\mathbf{u}(x,y) = \\begin{pmatrix} x^2 \\\\ y^2 \\end{pmatrix}$, the gradient is:\n$$\n\\nabla \\mathbf{u}(x,y) = \\begin{pmatrix} \\frac{\\partial u}{\\partial x} & \\frac{\\partial u}{\\partial y} \\\\ \\frac{\\partial v}{\\partial x} & \\frac{\\partial v}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 2x & 0 \\\\ 0 & 2y \\end{pmatrix}\n$$\nSince this matrix is already symmetric, the exact strain tensor is:\n$$\n\\boldsymbol{\\varepsilon}(x,y) = \\frac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{\\mathsf{T}}) = \\nabla \\mathbf{u} = \\begin{pmatrix} 2x & 0 \\\\ 0 & 2y \\end{pmatrix}\n$$\nFor the interpolated displacement field $\\mathbf{u}_{h}(x,y) = \\begin{pmatrix} x \\\\ y \\end{pmatrix}$, the gradient is the identity matrix:\n$$\n\\nabla \\mathbf{u}_{h}(x,y) = \\begin{pmatrix} \\frac{\\partial u_{h}}{\\partial x} & \\frac{\\partial u_{h}}{\\partial y} \\\\ \\frac{\\partial v_{h}}{\\partial x} & \\frac{\\partial v_{h}}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}\n$$\nThe interpolated strain tensor $\\boldsymbol{\\varepsilon}_{h}$ is similarly:\n$$\n\\boldsymbol{\\varepsilon}_{h}(x,y) = \\frac{1}{2}(\\nabla \\mathbf{u}_{h} + (\\nabla \\mathbf{u}_{h})^{\\mathsf{T}}) = \\nabla \\mathbf{u}_{h} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}\n$$\n\n**3. Compute the Strain Error Tensor $\\boldsymbol{e}_{\\varepsilon}(x,y)$**\nThe strain error tensor is the difference between the exact and interpolated strain tensors:\n$$\n\\boldsymbol{e}_{\\varepsilon}(x,y) = \\boldsymbol{\\varepsilon}(x,y) - \\boldsymbol{\\varepsilon}_{h}(x,y) = \\begin{pmatrix} 2x & 0 \\\\ 0 & 2y \\end{pmatrix} - \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 2x-1 & 0 \\\\ 0 & 2y-1 \\end{pmatrix}\n$$\n\n**4. Compute the $L^{2}$-Norm of the Strain Error**\nWe require the value $E = \\left(\\int_{\\Omega} \\| \\boldsymbol{e}_{\\varepsilon} \\|_{F}^{2} \\, \\mathrm{d}A \\right)^{1/2}$. First, we compute the squared Frobenius norm of the error tensor:\n$$\n\\| \\boldsymbol{e}_{\\varepsilon}(x,y) \\|_{F}^{2} = (2x-1)^{2} + 0^{2} + 0^{2} + (2y-1)^{2} = (2x-1)^{2} + (2y-1)^{2}\n$$\nNext, we integrate this quantity over the unit square domain $\\Omega$:\n$$\nE^{2} = \\int_{0}^{1}\\int_{0}^{1} \\left( (2x-1)^{2} + (2y-1)^{2} \\right) \\,\\mathrm{d}x\\,\\mathrm{d}y\n$$\nThe integral is separable:\n$$\nE^{2} = \\int_{0}^{1}\\int_{0}^{1} (2x-1)^{2} \\,\\mathrm{d}x\\,\\mathrm{d}y + \\int_{0}^{1}\\int_{0}^{1} (2y-1)^{2} \\,\\mathrm{d}x\\,\\mathrm{d}y\n$$\nLet us evaluate the first term:\n$$\n\\int_{0}^{1}\\int_{0}^{1} (2x-1)^{2} \\,\\mathrm{d}x\\,\\mathrm{d}y = \\left(\\int_{0}^{1} \\mathrm{d}y\\right) \\left(\\int_{0}^{1} (2x-1)^{2} \\,\\mathrm{d}x\\right)\n$$\nThe integral with respect to $y$ is $1$. The integral with respect to $x$ is:\n$$\n\\int_{0}^{1} (2x-1)^{2} \\,\\mathrm{d}x = \\int_{0}^{1} (4x^{2} - 4x + 1) \\,\\mathrm{d}x = \\left[ \\frac{4x^{3}}{3} - \\frac{4x^{2}}{2} + x \\right]_{0}^{1} = \\left[ \\frac{4}{3}x^{3} - 2x^{2} + x \\right]_{0}^{1}\n$$\n$$\n= \\left(\\frac{4}{3} - 2 + 1\\right) - (0) = \\frac{4}{3} - 1 = \\frac{1}{3}\n$$\nThus, the first term of $E^2$ is $\\frac{1}{3}$. By symmetry, the second term is also $\\frac{1}{3}$:\n$$\n\\int_{0}^{1}\\int_{0}^{1} (2y-1)^{2} \\,\\mathrm{d}x\\,\\mathrm{d}y = \\left(\\int_{0}^{1} \\mathrm{d}x\\right) \\left(\\int_{0}^{1} (2y-1)^{2} \\,\\mathrm{d}y\\right) = 1 \\cdot \\frac{1}{3} = \\frac{1}{3}\n$$\nSumming the terms gives $E^{2}$:\n$$\nE^{2} = \\frac{1}{3} + \\frac{1}{3} = \\frac{2}{3}\n$$\nFinally, we take the square root to find $E$:\n$$\nE = \\sqrt{\\frac{2}{3}} = \\frac{\\sqrt{2}}{\\sqrt{3}} = \\frac{\\sqrt{6}}{3}\n$$\nThis is the exact value of the element-wise $L^2$-norm of the strain error.", "answer": "$$\n\\boxed{\\frac{\\sqrt{6}}{3}}\n$$", "id": "2426703"}, {"introduction": "A common challenge in post-processing is that derived quantities like stress are often constant within an element, leading to discontinuous jumps at element boundaries. To create smooth, readable contour plots, these element-based values must be converted into a single, continuous value at each node. This practice [@problem_id:2426709] guides you through implementing a widely used nodal averaging scheme, giving you a practical understanding of how raw simulation data is transformed into meaningful visualizations.", "problem": "A finite element computation on a two-dimensional domain produces element-centered scalar values. For each element $e$, a single scalar value $q_e$ (for example, an average element stress or energy density) is given. Consider linear triangular elements with three nodes and axis-aligned rectangular quadrilateral elements with four nodes. Define the tributary area $A_{e,i}$ contributed by element $e$ to node $i$ as the integral of the element’s scalar shape function associated with node $i$ over the element. For the element types considered, this tributary area equals the element area divided by the number of element nodes. The nodal averaged scalar $q_i$ at node $i$ shall be defined as the weighted average of all connected element values using tributary areas as weights:\n$$\nq_i \\;=\\; \\frac{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}\\, q_e}{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}},\n$$\nwhere $\\mathcal{E}(i)$ is the set of elements that contain node $i$. For a linear triangle with area $A_e$, $A_{e,i} = A_e/3$. For an axis-aligned rectangle with area $A_e$, $A_{e,i} = A_e/4$.\n\nLet the area $A_e$ of a triangle with vertices $(x_1,y_1)$, $(x_2,y_2)$, $(x_3,y_3)$ be computed by\n$$\nA_e \\;=\\; \\frac{1}{2}\\,\\left|\\,x_1\\,(y_2 - y_3) + x_2\\,(y_3 - y_1) + x_3\\,(y_1 - y_2)\\,\\right|.\n$$\nLet the area $A_e$ of a rectangle with vertices $(x_1,y_1)$, $(x_2,y_2)$, $(x_3,y_3)$, $(x_4,y_4)$ (listed in counterclockwise or clockwise order) be computed by the polygon formula\n$$\nA_e \\;=\\; \\frac{1}{2}\\,\\left|\\,\\sum_{k=1}^{4} x_k\\,y_{k+1} - y_k\\,x_{k+1}\\,\\right|, \\quad \\text{with } (x_{5},y_{5}) \\equiv (x_1,y_1).\n$$\nAssume all rectangles in the tests are axis-aligned.\n\nGiven the following test suite of independent meshes, each with node coordinates, element connectivity, element-centered scalars, and a specified node of interest, compute the nodal averaged scalar at the specified node for each mesh. Use zero-based indexing for node indices in the element connectivity.\n\nTest case $1$ (mixed rectangle and triangle, shared node):\n- Nodes:\n  - Node $0$: $(0,0)$\n  - Node $1$: $(2,0)$\n  - Node $2$: $(2,1)$\n  - Node $3$: $(0,1)$\n  - Node $4$: $(3,0)$\n  - Node $5$: $(3,1)$\n- Elements:\n  - Element $0$: type quad4, connectivity $[0,1,2,3]$, $q_{0} = 10$\n  - Element $1$: type tri3, connectivity $[2,4,5]$, $q_{1} = 4$\n- Node of interest: $2$\n\nTest case $2$ (single triangle incident to the node of interest):\n- Nodes:\n  - Node $0$: $(0,0)$\n  - Node $1$: $(1,0)$\n  - Node $2$: $(0,2)$\n- Elements:\n  - Element $0$: type tri3, connectivity $[0,1,2]$, $q_{0} = 7$\n- Node of interest: $0$\n\nTest case $3$ (two triangles forming a square, equal areas, different element values):\n- Nodes:\n  - Node $0$: $(0,0)$\n  - Node $1$: $(1,0)$\n  - Node $2$: $(1,1)$\n  - Node $3$: $(0,1)$\n- Elements:\n  - Element $0$: type tri3, connectivity $[0,1,2]$, $q_{0} = 9$\n  - Element $1$: type tri3, connectivity $[0,2,3]$, $q_{1} = 3$\n- Node of interest: $2$\n\nTest case $4$ (single rectangle incident to the node of interest):\n- Nodes:\n  - Node $0$: $(0,0)$\n  - Node $1$: $(3,0)$\n  - Node $2$: $(3,2)$\n  - Node $3$: $(0,2)$\n- Elements:\n  - Element $0$: type quad4, connectivity $[0,1,2,3]$, $q_{0} = 5$\n- Node of interest: $1$\n\nYour program must implement the nodal averaging scheme exactly as defined, use the area formulas above, and compute the value $q_i$ at the specified node for each test case in order. The final output must be a single line containing a bracketed, comma-separated list of floating-point numbers, each printed with exactly six digits after the decimal point, corresponding to test cases $1$ through $4$ in order. For example, your program should print a line of the form\n$[v_1,v_2,v_3,v_4]$\nwith each $v_k$ formatted to exactly six digits after the decimal point. No additional text should be printed.", "solution": "The problem statement is subjected to validation and is found to be valid. It is scientifically grounded, self-contained, and well-posed. It describes a standard nodal averaging procedure commonly employed in the post-processing of finite element analysis results. The provided data, definitions, and formulae are mathematically consistent and sufficient for deriving a unique solution for each test case.\n\nThe core task is to compute a nodal scalar value, $q_i$, at a specific node $i$ by performing a weighted average of scalar values, $q_e$, from all elements connected to that node. The formula is given as:\n$$\nq_i \\;=\\; \\frac{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}\\, q_e}{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}}\n$$\nHere, $\\mathcal{E}(i)$ is the set of elements connected to node $i$, and $A_{e,i}$ is the tributary area of element $e$ to node $i$. This tributary area is defined as the element's area, $A_e$, divided by its number of nodes, $n_e$. For a linear triangle (`tri3`), $n_e=3$. For an axis-aligned quadrilateral (`quad4`), $n_e=4$.\n\nThe area $A_e$ for any polygon with vertices $(x_1, y_1), (x_2, y_2), \\dots, (x_N, y_N)$ listed in sequence is computed using the Shoelace formula:\n$$\nA_e = \\frac{1}{2} \\left| \\sum_{k=1}^{N} (x_k y_{k+1} - x_{k+1} y_k) \\right|, \\quad \\text{with } (x_{N+1}, y_{N+1}) \\equiv (x_1, y_1)\n$$\nThis formula is applicable to both the triangular and rectangular elements specified.\n\nThe procedure is as follows for each test case:\n1.  Identify the node of interest, $i$.\n2.  Identify the set of connecting elements, $\\mathcal{E}(i)$.\n3.  For each element $e \\in \\mathcal{E}(i)$:\n    a. Determine its vertices and calculate its area, $A_e$.\n    b. Determine its number of nodes, $n_e$.\n    c. Calculate the tributary area, $A_{e,i} = A_e / n_e$.\n    d. Calculate the element's contribution to the numerator, $A_{e,i} q_e$, and the denominator, $A_{e,i}$.\n4.  Sum the contributions from all connected elements to find the total numerator and denominator.\n5.  Calculate the final nodal value, $q_i$.\n\nWe now apply this procedure to each test case.\n\n**Test Case 1**\nNode of interest: $i=2$.\nThe set of elements containing node $2$ is $\\mathcal{E}(2) = \\{0, 1\\}$.\n\nElement $0$ (type `quad4`, $n_0 = 4$, $q_0 = 10$):\n- Vertices: $(0,0), (2,0), (2,1), (0,1)$.\n- Area: $A_0 = | (0 \\cdot 0 - 2 \\cdot 0) + (2 \\cdot 1 - 2 \\cdot 0) + (2 \\cdot 1 - 0 \\cdot 1) + (0 \\cdot 0 - 0 \\cdot 0) | / 2 = |2 + 2| / 2 = 2.0$.\n- Tributary area: $A_{0,2} = A_0 / n_0 = 2.0 / 4 = 0.5$.\n- Numerator contribution: $A_{0,2} q_0 = 0.5 \\times 10 = 5.0$.\n- Denominator contribution: $A_{0,2} = 0.5$.\n\nElement $1$ (type `tri3`, $n_1 = 3$, $q_1 = 4$):\n- Vertices: $(2,1), (3,0), (3,1)$.\n- Area: $A_1 = | (2 \\cdot 0 - 3 \\cdot 1) + (3 \\cdot 1 - 3 \\cdot 0) + (3 \\cdot 1 - 2 \\cdot 1) | / 2 = |-3 + 3 + 1| / 2 = 0.5$.\n- Tributary area: $A_{1,2} = A_1 / n_1 = 0.5 / 3 = 1/6$.\n- Numerator contribution: $A_{1,2} q_1 = (1/6) \\times 4 = 4/6 = 2/3$.\n- Denominator contribution: $A_{1,2} = 1/6$.\n\nNodal average at node $2$:\n- $\\sum A_{e,2} q_e = 5.0 + 2/3 = 15/3 + 2/3 = 17/3$.\n- $\\sum A_{e,2} = 0.5 + 1/6 = 3/6 + 1/6 = 4/6 = 2/3$.\n- $q_2 = (17/3) / (2/3) = 17/2 = 8.5$.\n\n**Test Case 2**\nNode of interest: $i=0$.\nThe set of elements containing node $0$ is $\\mathcal{E}(0) = \\{0\\}$.\nSince only one element is connected to the node of interest, the weighted average simplifies to the element's value itself: $q_0 = q_e = 7$.\nCalculation to confirm:\n- Element $0$ (type `tri3`, $n_0 = 3$, $q_0 = 7$):\n- Vertices: $(0,0), (1,0), (0,2)$.\n- Area: $A_0 = |(0 \\cdot 0 - 1 \\cdot 0) + (1 \\cdot 2 - 0 \\cdot 0) + (0 \\cdot 0 - 0 \\cdot 2)| / 2 = |2| / 2 = 1.0$.\n- Tributary area: $A_{0,0} = A_0 / n_0 = 1.0 / 3 = 1/3$.\n- $q_0 = (A_{0,0} q_0) / A_{0,0} = q_0 = 7.0$.\n\n**Test Case 3**\nNode of interest: $i=2$.\nThe set of elements containing node $2$ is $\\mathcal{E}(2) = \\{0, 1\\}$.\n\nElement $0$ (type `tri3`, $n_0 = 3$, $q_0 = 9$):\n- Vertices: $(0,0), (1,0), (1,1)$.\n- Area: $A_0 = |(0 \\cdot 0 - 1 \\cdot 0) + (1 \\cdot 1 - 1 \\cdot 0) + (1 \\cdot 0 - 0 \\cdot 1)| / 2 = |1| / 2 = 0.5$.\n- Tributary area: $A_{0,2} = A_0 / 3 = 0.5 / 3 = 1/6$.\n- Numerator contribution: $A_{0,2} q_0 = (1/6) \\times 9 = 9/6 = 1.5$.\n- Denominator contribution: $A_{0,2} = 1/6$.\n\nElement $1$ (type `tri3`, $n_1 = 3$, $q_1 = 3$):\n- Vertices: $(0,0), (1,1), (0,1)$.\n- Area: $A_1 = |(0 \\cdot 1 - 1 \\cdot 0) + (1 \\cdot 1 - 0 \\cdot 1) + (0 \\cdot 0 - 0 \\cdot 0)| / 2 = |1| / 2 = 0.5$.\n- Tributary area: $A_{1,2} = A_1 / 3 = 0.5 / 3 = 1/6$.\n- Numerator contribution: $A_{1,2} q_1 = (1/6) \\times 3 = 3/6 = 0.5$.\n- Denominator contribution: $A_{1,2} = 1/6$.\n\nNodal average at node $2$:\n- $\\sum A_{e,2} q_e = 1.5 + 0.5 = 2.0$.\n- $\\sum A_{e,2} = 1/6 + 1/6 = 2/6 = 1/3$.\n- $q_2 = 2.0 / (1/3) = 6.0$.\nSince the tributary areas are equal ($A_{0,2} = A_{1,2}$), the result is the arithmetic mean of the element values: $(9+3)/2 = 6.0$.\n\n**Test Case 4**\nNode of interest: $i=1$.\nThe set of elements containing node $1$ is $\\mathcal{E}(1) = \\{0\\}$.\nAs in case $2$, the nodal value is simply the element value: $q_1 = q_e = 5$.\nCalculation to confirm:\n- Element $0$ (type `quad4`, $n_0 = 4$, $q_0 = 5$):\n- Vertices: $(0,0), (3,0), (3,2), (0,2)$.\n- Area: $A_0 = |(0 \\cdot 0 - 3 \\cdot 0) + (3 \\cdot 2 - 3 \\cdot 0) + (3 \\cdot 2 - 0 \\cdot 2) + (0 \\cdot 0 - 0 \\cdot 0)| / 2 = |6 + 6| / 2 = 6.0$.\n- Tributary area: $A_{0,1} = A_0 / n_0 = 6.0 / 4 = 1.5$.\n- $q_1 = (A_{0,1} q_0) / A_{0,1} = q_0 = 5.0$.\n\nThe final computed values are: $8.5$, $7.0$, $6.0$, and $5.0$. These must be formatted to six decimal places for output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required for this problem.\n\ndef get_polygon_area(vertices):\n    \"\"\"\n    Calculates the area of a polygon given its vertices using the Shoelace formula.\n    Args:\n        vertices (list of tuples): A list of (x, y) coordinates for the polygon's vertices,\n                                   ordered sequentially (clockwise or counter-clockwise).\n    Returns:\n        float: The area of the polygon.\n    \"\"\"\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    return abs(area) / 2.0\n\ndef solve():\n    \"\"\"\n    Solves the nodal averaging problem for a predefined suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        ({0: (0.0, 0.0), 1: (2.0, 0.0), 2: (2.0, 1.0), 3: (0.0, 1.0), 4: (3.0, 0.0), 5: (3.0, 1.0)},\n         [{\"type\": \"quad4\", \"conn\": [0, 1, 2, 3], \"q\": 10.0},\n          {\"type\": \"tri3\", \"conn\": [2, 4, 5], \"q\": 4.0}],\n         2),\n        # Test Case 2\n        ({0: (0.0, 0.0), 1: (1.0, 0.0), 2: (0.0, 2.0)},\n         [{\"type\": \"tri3\", \"conn\": [0, 1, 2], \"q\": 7.0}],\n         0),\n        # Test Case 3\n        ({0: (0.0, 0.0), 1: (1.0, 0.0), 2: (1.0, 1.0), 3: (0.0, 1.0)},\n         [{\"type\": \"tri3\", \"conn\": [0, 1, 2], \"q\": 9.0},\n          {\"type\": \"tri3\", \"conn\": [0, 2, 3], \"q\": 3.0}],\n         2),\n        # Test Case 4\n        ({0: (0.0, 0.0), 1: (3.0, 0.0), 2: (3.0, 2.0), 3: (0.0, 2.0)},\n         [{\"type\": \"quad4\", \"conn\": [0, 1, 2, 3], \"q\": 5.0}],\n         1),\n    ]\n\n    results = []\n    for case in test_cases:\n        node_coords, elements, node_idx = case\n\n        numerator = 0.0\n        denominator = 0.0\n        \n        # Find all elements connected to the node of interest and compute their contributions.\n        for elem in elements:\n            if node_idx in elem[\"conn\"]:\n                q_e = elem[\"q\"]\n                conn = elem[\"conn\"]\n                \n                # Get the coordinates of the element's vertices.\n                vertices = [node_coords[node_id] for node_id in conn]\n                \n                # Calculate the element area using the general polygon area formula.\n                A_e = get_polygon_area(vertices)\n                \n                # The number of nodes determines the denominator for the tributary area.\n                n_nodes = len(conn)\n                A_ei = A_e / n_nodes\n                \n                # Accumulate the weighted sum for the numerator and the sum of weights for the denominator.\n                numerator += A_ei * q_e\n                denominator += A_ei\n\n        # The problem statement guarantees the node of interest is part of at least\n        # one element, so the denominator will not be zero.\n        q_i = numerator / denominator\n        results.append(q_i)\n\n    # Format the final output as a bracketed, comma-separated list of floating-point numbers\n    # with exactly six digits after the decimal point.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2426709"}, {"introduction": "Beyond visualizing results, a key post-processing task is to assess the quality and reliability of the finite element solution itself. This advanced practice [@problem_id:2426760] introduces you to *a posteriori* error estimation by implementing the celebrated Zienkiewicz-Zhu (ZZ) error estimator. By first smoothing the discontinuous solution gradient and then measuring its deviation from the original FE gradient, you will learn a powerful technique to quantify the solution error, a critical step for solution verification and adaptive mesh refinement.", "problem": "Given a two-dimensional steady heat conduction problem with scalar, isotropic, and constant thermal conductivity $k$ on a patch of three linear triangular finite elements, consider the Finite Element Method (FEM) temperature approximation $u_h$ that is continuous and piecewise linear over the triangulation. For each triangle $\\Omega_e$ with vertex indices $(i,j,\\ell)$, let the constant elementwise gradient be $\\nabla u_h|_{\\Omega_e}$, and let the Zienkiewicz–Zhu (ZZ) recovered gradient field $\\widehat{\\nabla u}$ be the continuous, piecewise-linear vector field obtained by linearly interpolating nodal recovered gradients. At each node $n$ belonging to the patch, the nodal recovered gradient is defined by the area-weighted average of the constant gradients of all elements in the patch that are incident to that node:\n$$\n\\widehat{\\nabla u}^{(n)} \\;=\\; \\frac{\\sum\\limits_{e \\ni n} A_e\\,\\nabla u_h|_{\\Omega_e}}{\\sum\\limits_{e \\ni n} A_e},\n$$\nwhere $A_e$ is the area of element $\\Omega_e$. Within an element $\\Omega_e$ with local nodes $(i,j,\\ell)$ and linear shape functions $(N_i,N_j,N_\\ell)$, the recovered gradient field is\n$$\n\\widehat{\\nabla u}(x,y)\\Big|_{\\Omega_e} \\;=\\; N_i(x,y)\\,\\widehat{\\nabla u}^{(i)} \\;+\\; N_j(x,y)\\,\\widehat{\\nabla u}^{(j)} \\;+\\; N_\\ell(x,y)\\,\\widehat{\\nabla u}^{(\\ell)}.\n$$\nDefine the ZZ energy-norm error of the patch by\n$$\n\\left\\|e\\right\\|_{ZZ} \\;=\\; \\left(\\sum_{e=1}^{3} \\int_{\\Omega_e} k\\,\\big\\|\\widehat{\\nabla u}(x,y)-\\nabla u_h|_{\\Omega_e}\\big\\|_2^2\\,\\mathrm{d}\\Omega \\right)^{1/2}.\n$$\n\nAll quantities in this problem are nondimensional. Your task is to compute $\\left\\|e\\right\\|_{ZZ}$ for each of the following three test cases. In every case, the finite element mesh is a patch of three triangles that share the central node with index $0$ and have element connectivity $\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$. The FEM nodal temperature values $u_h$ are to be taken as the exact pointwise values of the given analytic field $u(x,y)$ at the mesh nodes.\n\nFor each test, use the specified nodal coordinates, thermal conductivity $k$, and analytic temperature field $u(x,y)$:\n- Test $1$ (exactly linear field; expected zero error in exact arithmetic):\n  - Nodes: $0:(0.0,\\,0.0)$, $1:(1.0,\\,0.0)$, $2:(-0.2,\\,1.1)$, $3:(-0.8,\\,-0.4)$.\n  - Connectivity: $\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$.\n  - Conductivity: $k=1.0$.\n  - Field: $u(x,y)=2x - y$.\n- Test $2$ (nonlinear field on a moderately shaped patch):\n  - Nodes: $0:(0.1,\\,0.2)$, $1:(0.9,\\,0.1)$, $2:(0.0,\\,1.0)$, $3:(-0.8,\\,0.2)$.\n  - Connectivity: $\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$.\n  - Conductivity: $k=2.0$.\n  - Field: $u(x,y)=x^2 + y$.\n- Test $3$ (nonlinear field including a slender triangle):\n  - Nodes: $0:(0.0,\\,0.0)$, $1:(0.001,\\,0.0)$, $2:(0.002,\\,0.05)$, $3:(-0.8,\\,0.001)$.\n  - Connectivity: $\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$.\n  - Conductivity: $k=0.5$.\n  - Field: $u(x,y)=\\sin(x)+0.5\\,y$.\n\nRequired conventions and definitions:\n- For a triangle with vertex coordinates $(x_i,y_i)$, $(x_j,y_j)$, $(x_\\ell,y_\\ell)$, let the signed doubled area be\n$$\n2A_{\\mathrm{sign}} \\;=\\; (x_j-x_i)(y_\\ell-y_i) - (x_\\ell-x_i)(y_j-y_i),\n$$\nand the (positive) area be $A \\,=\\, |A_{\\mathrm{sign}}|$.\n- For linear shape functions, the constant element gradient of $u_h$ in triangle $\\Omega_e$ is\n$$\n\\nabla u_h\\Big|_{\\Omega_e}\n= \\frac{1}{2A_{\\mathrm{sign}}}\n\\begin{bmatrix}\n(y_j-y_\\ell) & (y_\\ell-y_i) & (y_i-y_j) \\\\\n(x_\\ell-x_j) & (x_i-x_\\ell) & (x_j-x_i)\n\\end{bmatrix}\n\\begin{bmatrix}\nu_i\\\\ u_j\\\\ u_\\ell\n\\end{bmatrix}.\n$$\n\nYour program must compute, for each test case, the scalar $\\left\\|e\\right\\|_{ZZ}$ as defined above, using exact arithmetic for the elementwise integrals implied by the definition. Aggregate the three results into a single line of output as a comma-separated list enclosed in square brackets, with each value rounded to exactly six digits after the decimal point. For example, an output with placeholder values would look like $[0.000000,0.123456,0.654321]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3]$).", "solution": "The problem statement submitted for analysis is rigorously examined and found to be valid. It is scientifically grounded in the principles of the Finite Element Method (FEM), specifically concerning a posteriori error estimation using the Zienkiewicz-Zhu (ZZ) recovery technique. The problem is well-posed, providing all necessary data, including mesh geometry, connectivity, material properties, and analytical fields for setting nodal values. The language used is objective and mathematically precise. There are no contradictions, ambiguities, or violations of fundamental principles. Therefore, a reasoned solution will be provided.\n\nThe objective is to compute the Zienkiewicz-Zhu energy-norm error, $\\left\\|e\\right\\|_{ZZ}$, for a patch of three linear triangular elements for three distinct test cases. The total squared error is the summation of contributions from each element $\\Omega_e$:\n$$\n\\left\\|e\\right\\|_{ZZ}^2 \\;=\\; \\sum_{e=1}^{3} \\left\\|e\\right\\|_{ZZ,e}^2 \\;=\\; \\sum_{e=1}^{3} \\int_{\\Omega_e} k\\,\\big\\|\\widehat{\\nabla u}(x,y)-\\nabla u_h|_{\\Omega_e}\\big\\|_2^2\\,\\mathrm{d}\\Omega\n$$\nThe calculation proceeds through a sequence of logical steps.\n\n**Step 1: Nodal Temperature Evaluation**\nThe finite element approximation $u_h$ is continuous and piecewise linear. The problem dictates that the nodal values of the temperature field, $u_i$, are determined by sampling the given exact analytical field $u(x,y)$ at the coordinates of each mesh node $n_i=(x_i, y_i)$.\n$$\nu_i = u(x_i, y_i)\n$$\nThis is performed for all four nodes in the patch: $n_0, n_1, n_2, n_3$.\n\n**Step 2: Computation of Constant Element-wise Gradients**\nWithin each linear triangular element $\\Omega_e$, the gradient of the finite element solution, $\\nabla u_h|_{\\Omega_e}$, is a constant vector. For an element with vertices $(i,j,\\ell)$ having coordinates $(x_i,y_i)$, $(x_j,y_j)$, $(x_\\ell,y_\\ell)$ and nodal temperatures $(u_i,u_j,u_\\ell)$, this gradient vector $\\mathbf{g}_e = \\nabla u_h|_{\\Omega_e}$ is calculated using the provided formula:\n$$\n\\mathbf{g}_e = \\nabla u_h\\Big|_{\\Omega_e}\n= \\frac{1}{2A_{e,\\mathrm{sign}}}\n\\begin{bmatrix}\ny_j-y_\\ell & y_\\ell-y_i & y_i-y_j\\\\\nx_\\ell-x_j & x_i-x_\\ell & x_j-x_i\n\\end{bmatrix}\n\\begin{bmatrix}\nu_i\\\\ u_j\\\\ u_\\ell\n\\end{bmatrix}\n$$\nwhere $2A_{e,\\mathrm{sign}} = (x_j-x_i)(y_\\ell-y_i) - (x_\\ell-x_i)(y_j-y_i)$ is the signed doubled area of the element. This calculation is repeated for each of the three elements in the patch, yielding gradient vectors $\\mathbf{g}_1, \\mathbf{g}_2, \\mathbf{g}_3$. The (positive) area of each element is $A_e = \\frac{1}{2}|2A_{e,\\mathrm{sign}}|$.\n\n**Step 3: Computation of Nodal Recovered Gradients**\nThe Zienkiewicz-Zhu procedure constructs a continuous, improved gradient field, $\\widehat{\\nabla u}$, by first computing averaged gradients at the mesh nodes. The recovered gradient at a node $n$, denoted $\\widehat{\\nabla u}^{(n)}$ or $\\mathbf{G}_n$, is the area-weighted average of the constant gradients of all elements incident to that node:\n$$\n\\mathbf{G}_n = \\widehat{\\nabla u}^{(n)} \\;=\\; \\frac{\\sum\\limits_{e \\ni n} A_e\\,\\mathbf{g}_e}{\\sum\\limits_{e \\ni n} A_e}\n$$\nThis calculation is performed for each of the four nodes. For instance, the central node $n_0$ is shared by all three elements, so its recovered gradient is:\n$$\n\\mathbf{G}_0 \\;=\\; \\frac{A_1\\,\\mathbf{g}_1 + A_2\\,\\mathbf{g}_2 + A_3\\,\\mathbf{g}_3}{A_1+A_2+A_3}\n$$\nAn exterior node, such as $n_1$, is shared only by elements $1$ and $3$, so its recovered gradient is:\n$$\n\\mathbf{G}_1 \\;=\\; \\frac{A_1\\,\\mathbf{g}_1 + A_3\\,\\mathbf{g}_3}{A_1+A_3}\n$$\nThe recovered gradients $\\mathbf{G}_0, \\mathbf{G}_1, \\mathbf{G}_2, \\mathbf{G}_3$ are computed accordingly.\n\n**Step 4: Evaluation of the Element Error Integral**\nThe core of the task is to evaluate the integral for each element's contribution to the total error. Let $\\boldsymbol{\\delta}(x,y) = \\widehat{\\nabla u}(x,y)-\\nabla u_h|_{\\Omega_e}$. Within an element $\\Omega_e$ with nodes $(i,j,\\ell)$, this difference field is linear, as both $\\widehat{\\nabla u}$ and $u_h$ are piecewise linear. It can be expressed using the element shape functions $(N_i, N_j, N_\\ell)$:\n$$\n\\boldsymbol{\\delta}(x,y) = N_i(x,y)\\,\\boldsymbol{\\delta}_i + N_j(x,y)\\,\\boldsymbol{\\delta}_j + N_\\ell(x,y)\\,\\boldsymbol{\\delta}_\\ell\n$$\nwhere $\\boldsymbol{\\delta}_n = \\mathbf{G}_n - \\mathbf{g}_e$ is the difference vector at node $n$. The integral for element $e$ is:\n$$\n\\left\\|e\\right\\|_{ZZ,e}^2 \\;=\\; k \\int_{\\Omega_e} \\left\\| \\boldsymbol{\\delta}(x,y) \\right\\|_2^2 \\,\\mathrm{d}\\Omega = k \\int_{\\Omega_e} \\left( \\delta_x(x,y)^2 + \\delta_y(x,y)^2 \\right) \\,\\mathrm{d}\\Omega\n$$\nThe integral of the square of a linear scalar field $f(x,y) = N_i f_i + N_j f_j + N_\\ell f_\\ell$ over a triangular element has an exact analytical solution:\n$$\n\\int_{\\Omega_e} f(x,y)^2 \\,\\mathrm{d}\\Omega = \\frac{A_e}{12}(2f_i^2+2f_j^2+2f_\\ell^2 + 2f_if_j + 2f_if_\\ell + 2f_jf_\\ell) = \\mathbf{f}^T \\mathbf{M} \\mathbf{f}\n$$\nwhere $\\mathbf{f} = [f_i, f_j, f_\\ell]^T$ is the vector of nodal values and $\\mathbf{M}$ is the element mass matrix for linear triangles:\n$$\n\\mathbf{M} = \\frac{A_e}{12}\n\\begin{pmatrix}\n2 & 1 & 1 \\\\\n1 & 2 & 1 \\\\\n1 & 1 & 2\n\\end{pmatrix}\n$$\nApplying this to both components of $\\boldsymbol{\\delta}(x,y)$, we get:\n$$\n\\left\\|e\\right\\|_{ZZ,e}^2 = k \\left( \\boldsymbol{\\delta}_x^T \\mathbf{M} \\boldsymbol{\\delta}_x + \\boldsymbol{\\delta}_y^T \\mathbf{M} \\boldsymbol{\\delta}_y \\right)\n$$\nwhere $\\boldsymbol{\\delta}_x = [\\delta_{ix}, \\delta_{jx}, \\delta_{\\ell x}]^T$ and $\\boldsymbol{\\delta}_y = [\\delta_{iy}, \\delta_{jy}, \\delta_{\\ell y}]^T$ are the vectors of nodal difference components. This exact formula is used for the computation.\n\n**Step 5: Aggregation and Final Result**\nThe total squared error is the sum of the element-wise squared errors calculated in the previous step.\n$$\n\\left\\|e\\right\\|_{ZZ}^2 = \\sum_{e=1}^{3} \\left\\|e\\right\\|_{ZZ,e}^2\n$$\nThe final ZZ error norm is the square root of this sum:\n$$\n\\left\\|e\\right\\|_{ZZ} = \\sqrt{\\left\\|e\\right\\|_{ZZ}^2}\n$$\nThis complete procedure is implemented programmatically and applied to each of the three test cases to obtain the required numerical results.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Zienkiewicz-Zhu energy-norm error for three test cases\n    of a 2D steady heat conduction problem on a 3-element patch.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": {0: (0.0, 0.0), 1: (1.0, 0.0), 2: (-0.2, 1.1), 3: (-0.8, -0.4)},\n            \"k\": 1.0,\n            \"u_func\": lambda x, y: 2.0 * x - y\n        },\n        {\n            \"nodes\": {0: (0.1, 0.2), 1: (0.9, 0.1), 2: (0.0, 1.0), 3: (-0.8, 0.2)},\n            \"k\": 2.0,\n            \"u_func\": lambda x, y: x**2 + y\n        },\n        {\n            \"nodes\": {0: (0.0, 0.0), 1: (0.001, 0.0), 2: (0.002, 0.05), 3: (-0.8, 0.001)},\n            \"k\": 0.5,\n            \"u_func\": lambda x, y: np.sin(x) + 0.5 * y\n        }\n    ]\n    \n    # Mesh connectivity is the same for all test cases.\n    connectivity = [(0, 1, 2), (0, 2, 3), (0, 3, 1)]\n    \n    results = []\n\n    for case in test_cases:\n        nodes_coords = case[\"nodes\"]\n        k = case[\"k\"]\n        u_func = case[\"u_func\"]\n        \n        # Step 1: Compute nodal temperatures from the analytical field.\n        nodal_temps = {n: u_func(x, y) for n, (x, y) in nodes_coords.items()}\n\n        elem_data = {}\n        # Step 2: Compute constant element gradients and areas for all elements.\n        for elem_idx, elem_nodes in enumerate(connectivity):\n            n_i, n_j, n_l = elem_nodes\n            (xi, yi), (xj, yj), (xl, yl) = nodes_coords[n_i], nodes_coords[n_j], nodes_coords[n_l]\n\n            # Calculate signed doubled area and positive area.\n            two_A_sign = (xj - xi) * (yl - yi) - (xl - xi) * (yj - yi)\n            area = 0.5 * abs(two_A_sign)\n\n            # Assemble the B matrix for gradient calculation.\n            B_matrix = np.array([\n                [yj - yl, yl - yi, yi - yj],\n                [xl - xj, xi - xl, xj - xi]\n            ])\n            \n            # Vector of nodal temperatures for the element.\n            u_vec = np.array([nodal_temps[n_i], nodal_temps[n_j], nodal_temps[n_l]])\n            \n            # Calculate the constant element gradient.\n            grad_e = (1.0 / two_A_sign) * (B_matrix @ u_vec)\n            \n            elem_data[elem_idx] = {\"nodes\": elem_nodes, \"area\": area, \"grad\": grad_e}\n\n        # Step 3: Compute nodal recovered gradients.\n        # First, map each node to its incident elements.\n        node_to_elems = {n: [] for n in nodes_coords}\n        for elem_idx, elem_nodes in enumerate(connectivity):\n            for node_idx in elem_nodes:\n                node_to_elems[node_idx].append(elem_idx)\n        \n        nodal_recovered_grads = {}\n        for n in nodes_coords:\n            incident_elems = node_to_elems[n]\n            \n            # Perform area-weighted averaging.\n            sum_A_grad = np.zeros(2)\n            sum_A = 0.0\n            for elem_idx in incident_elems:\n                sum_A_grad += elem_data[elem_idx][\"area\"] * elem_data[elem_idx][\"grad\"]\n                sum_A += elem_data[elem_idx][\"area\"]\n            \n            nodal_recovered_grads[n] = sum_A_grad / sum_A\n\n        # Step 4 & 5: Compute element error integrals and aggregate.\n        total_E_squared = 0.0\n        for i in range(len(connectivity)):\n            data = elem_data[i]\n            n_i, n_j, n_l = data[\"nodes\"]\n            area = data[\"area\"]\n            g_e = data[\"grad\"]\n            \n            # Get the nodal recovered gradients for the current element's nodes.\n            G_i = nodal_recovered_grads[n_i]\n            G_j = nodal_recovered_grads[n_j]\n            G_l = nodal_recovered_grads[n_l]\n            \n            # Compute the difference between recovered gradient and FEM gradient at each node.\n            delta_i = G_i - g_e\n            delta_j = G_j - g_e\n            delta_l = G_l - g_e\n            \n            # Assemble vectors of x and y components of the differences.\n            delta_x = np.array([delta_i[0], delta_j[0], delta_l[0]])\n            delta_y = np.array([delta_i[1], delta_j[1], delta_l[1]])\n            \n            # Define the element mass matrix for a linear triangle.\n            M = (area / 12.0) * np.array([\n                [2.0, 1.0, 1.0],\n                [1.0, 2.0, 1.0],\n                [1.0, 1.0, 2.0]\n            ])\n            \n            # Evaluate the integral of the squared error field using the mass matrix.\n            integral_x_sq = delta_x.T @ M @ delta_x\n            integral_y_sq = delta_y.T @ M @ delta_y\n            \n            # The squared error energy for the element.\n            E_e_squared = k * (integral_x_sq + integral_y_sq)\n            total_E_squared += E_e_squared\n            \n        # Final ZZ error norm is the square root of the total squared error energy.\n        zz_error = np.sqrt(total_E_squared)\n        results.append(f\"{zz_error:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2426760"}]}