{"hands_on_practices": [{"introduction": "The primary allure of higher-order basis functions is their remarkable efficiency in approximating smooth solutions. This practice demonstrates this principle in a tangible way by modeling a classic fluid dynamics problem, Poiseuille flow, whose velocity profile is a simple parabola. By using a single quadratic ($p=2$) finite element, you will discover that the numerical method can capture the analytical solution perfectly, highlighting the power of matching the polynomial degree of your basis functions to the nature of the solution you seek [@problem_id:2399658].", "problem": "Consider steady, fully developed planar Poiseuille flow along the $x$-direction between two parallel plates located at $y=0$ and $y=H$. Let the constant pressure gradient be $g \\equiv -\\mathrm{d}p/\\mathrm{d}x > 0$ and the dynamic viscosity be $\\mu > 0$. The axial velocity $u(y)$ satisfies the one-dimensional boundary value problem\n$$-\\mu \\, u''(y) = g \\quad \\text{for } y \\in (0,H), \\qquad u(0)=0, \\quad u(H)=0.$$\nUsing the standard Galerkin finite element method (FEM) with a single quadratic element of polynomial degree $p=2$ spanning the interval $[0,H]$, employ Lagrange basis functions associated with the nodes at $y=0$, $y=H/2$, and $y=H$. Enforce the essential boundary conditions strongly at the boundary nodes.\n\nDetermine the $3$-component vector of nodal values $\\big(u(0),\\,u(H/2),\\,u(H)\\big)$ produced by this discretization. Report your final answer as a dimensionless $1 \\times 3$ row vector obtained by dividing each component by $(g H^{2}/\\mu)$. No numerical rounding is required, and no units should be included in the reported vector.", "solution": "The problem is first subjected to validation.\n\n**Step 1: Extract Givens**\n- Governing Equation: $-\\mu \\, u''(y) = g$ for $y \\in (0,H)$.\n- Constants: $g \\equiv -\\mathrm{d}p/\\mathrm{d}x > 0$ and $\\mu > 0$.\n- Boundary Conditions: $u(0)=0$, $u(H)=0$.\n- Method: Standard Galerkin finite element method (FEM).\n- Discretization: One quadratic element ($p=2$) over the domain $[0,H]$.\n- Nodal Coordinates: $y=0$, $y=H/2$, $y=H$.\n- Basis Functions: Lagrange basis functions associated with the nodes.\n- Boundary Condition Enforcement: Strong enforcement at boundary nodes.\n- Required Output: The dimensionless $1 \\times 3$ row vector of nodal values $\\big(u(0), u(H/2), u(H)\\big)$ after division by $(g H^{2}/\\mu)$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem describes planar Poiseuille flow, a fundamental concept in fluid dynamics. The governing equation is a valid simplification of the Navier-Stokes equations for this flow regime. The problem is scientifically sound.\n- **Well-Posed:** The problem is a one-dimensional, second-order elliptic boundary value problem with Dirichlet boundary conditions. A unique and stable solution is guaranteed to exist. The FEM formulation is also standard and well-posed.\n- **Objective:** The problem is stated using precise mathematical and physical terminology, free of any subjectivity or ambiguity.\n- **Completeness and Consistency:** The problem provides all necessary information (governing equation, domain, boundary conditions, and discretization details) and contains no internal contradictions.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is a well-defined problem in computational engineering that is scientifically grounded, well-posed, and complete. A rigorous solution can be derived.\n\nThe weak form of the boundary value problem is derived by multiplying the governing equation by a test function $v(y)$ from a suitable space and integrating over the domain $\\Omega = (0,H)$.\n$$\n\\int_{0}^{H} -\\mu u''(y) v(y) \\, dy = \\int_{0}^{H} g v(y) \\, dy\n$$\nApplying integration by parts to the left-hand side yields:\n$$\n\\int_{0}^{H} \\mu u'(y) v'(y) \\, dy - \\big[ \\mu u'(y) v(y) \\big]_{0}^{H} = \\int_{0}^{H} g v(y) \\, dy\n$$\nThe test function $v(y)$ must belong to the space of functions for which the integral is defined and which satisfy the homogeneous essential boundary conditions, i.e., $v(0)=0$ and $v(H)=0$. Therefore, the boundary term $\\big[ \\mu u'(y) v(y) \\big]_{0}^{H}$ vanishes. The weak formulation is: find $u(y)$ satisfying the essential boundary conditions such that\n$$\n\\int_{0}^{H} \\mu u'(y) v'(y) \\, dy = \\int_{0}^{H} g v(y) \\, dy\n$$\nfor all admissible test functions $v(y)$.\n\nIn the finite element method, the unknown function $u(y)$ is approximated by a linear combination of basis functions, $u_h(y) = \\sum_{j=1}^{3} U_j N_j(y)$, where $U_j$ are the unknown nodal values and $N_j(y)$ are the basis functions. The problem specifies a single quadratic element with nodes at $y_1=0$, $y_2=H/2$, and $y_3=H$. The corresponding Lagrange basis functions, which satisfy $N_j(y_i) = \\delta_{ij}$, are:\n$$\nN_1(y) = \\frac{(y - H/2)(y - H)}{(0 - H/2)(0 - H)} = \\frac{2}{H^2} \\left(y^2 - \\frac{3}{2}Hy + \\frac{H^2}{2}\\right)\n$$\n$$\nN_2(y) = \\frac{(y - 0)(y - H)}{(H/2 - 0)(H/2 - H)} = -\\frac{4}{H^2} (y^2 - Hy)\n$$\n$$\nN_3(y) = \\frac{(y - 0)(y - H/2)}{(H - 0)(H - H/2)} = \\frac{2}{H^2} \\left(y^2 - \\frac{1}{2}Hy\\right)\n$$\nThe problem states that the essential boundary conditions $u(0)=0$ and $u(H)=0$ are enforced strongly. This means the nodal values at the boundaries are fixed: $U_1 = u(0) = 0$ and $U_3 = u(H) = 0$. The approximation for the velocity field simplifies to $u_h(y) = U_2 N_2(y)$, as the terms with $N_1(y)$ and $N_3(y)$ are zero.\n\nIn the Galerkin method, the test functions are chosen from the same set as the basis functions. For the single unknown $U_2$, we need only one equation, which is obtained by choosing the test function $v(y) = N_2(y)$. This is the only basis function that is non-zero at the interior node and zero at the boundaries. Substituting $u_h(y)$ and $v(y)=N_2(y)$ into the weak form gives:\n$$\n\\int_{0}^{H} \\mu (U_2 N_2'(y)) (N_2'(y)) \\, dy = \\int_{0}^{H} g N_2(y) \\, dy\n$$\nThis is a single linear equation for the unknown $U_2$:\n$$\n\\left( \\mu \\int_{0}^{H} (N_2'(y))^2 \\, dy \\right) U_2 = g \\int_{0}^{H} N_2(y) \\, dy\n$$\nWe must compute the two integrals. First, the derivative of $N_2(y)$:\n$$\nN_2'(y) = \\frac{d}{dy}\\left(-\\frac{4y^2}{H^2} + \\frac{4y}{H}\\right) = -\\frac{8y}{H^2} + \\frac{4}{H}\n$$\nThe integral on the left-hand side is:\n$$\n\\int_{0}^{H} (N_2'(y))^2 \\, dy = \\int_{0}^{H} \\left(\\frac{4}{H} - \\frac{8y}{H^2}\\right)^2 \\, dy = \\int_{0}^{H} \\left(\\frac{16}{H^2} - \\frac{64y}{H^3} + \\frac{64y^2}{H^4}\\right) \\, dy\n$$\n$$\n= \\left[ \\frac{16y}{H^2} - \\frac{32y^2}{H^3} + \\frac{64y^3}{3H^4} \\right]_{0}^{H} = \\frac{16}{H} - \\frac{32}{H} + \\frac{64}{3H} = \\left(16 - 32 + \\frac{64}{3}\\right)\\frac{1}{H} = \\left(-16 + \\frac{64}{3}\\right)\\frac{1}{H} = \\frac{-48+64}{3H} = \\frac{16}{3H}\n$$\nThe integral on the right-hand side is:\n$$\n\\int_{0}^{H} N_2(y) \\, dy = \\int_{0}^{H} \\left(-\\frac{4y^2}{H^2} + \\frac{4y}{H}\\right) \\, dy = \\left[ -\\frac{4y^3}{3H^2} + \\frac{2y^2}{H} \\right]_{0}^{H} = -\\frac{4H}{3} + 2H = \\frac{2H}{3}\n$$\nSubstituting these results back into the equation for $U_2$:\n$$\n\\left( \\mu \\frac{16}{3H} \\right) U_2 = g \\frac{2H}{3}\n$$\nSolving for $U_2$:\n$$\nU_2 = \\frac{g \\cdot 2H/3}{\\mu \\cdot 16/(3H)} = \\frac{2gH}{3} \\cdot \\frac{3H}{16\\mu} = \\frac{6gH^2}{48\\mu} = \\frac{1}{8} \\frac{gH^2}{\\mu}\n$$\nThe vector of nodal values is $\\big(U_1, U_2, U_3\\big) = \\left(0, \\frac{1}{8}\\frac{gH^2}{\\mu}, 0\\right)$.\nTo obtain the required dimensionless vector, each component is divided by the scaling factor $(gH^2/\\mu)$:\n$$\n\\left( \\frac{0}{gH^2/\\mu}, \\frac{\\frac{1}{8}gH^2/\\mu}{gH^2/\\mu}, \\frac{0}{gH^2/\\mu} \\right) = \\left(0, \\frac{1}{8}, 0\\right)\n$$\nThis result is exact because the analytical solution to this problem, $u(y) = \\frac{g}{2\\mu}(Hy - y^2)$, is a quadratic polynomial, which can be represented exactly by the quadratic basis functions used in the discretization.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & \\frac{1}{8} & 0\n\\end{pmatrix}\n}\n$$", "id": "2399658"}, {"introduction": "While higher-order polynomials excel at representing smooth functions, they face challenges with discontinuities. This exercise explores what happens when we try to approximate a sharp jump, like a step function, using a basis of smooth Legendre polynomials. You will implement an $L^2$ projection and quantify the resulting \"Gibbs phenomenon\"â€”a characteristic overshoot at the discontinuity that does not disappear even as the polynomial degree $p$ increases [@problem_id:2399650]. This practice is key to understanding a common source of non-physical oscillations in numerical methods.", "problem": "You will write a complete, runnable program that constructs the square-integrable (Lebesgue $L^2$) orthogonal projection of a discontinuous function onto a one-dimensional polynomial subspace and then quantifies the resulting Gibbs-like overshoot near the discontinuity as a function of the polynomial degree. Work on the reference interval $[-1,1]$. Consider the step function $f:[-1,1]\\to\\mathbb{R}$ defined by $f(x)=0$ for $x<0$ and $f(x)=1$ for $x\\ge 0$. For a given nonnegative integer degree $p$, define the polynomial subspace $\\mathcal{P}_p$ as the set of all real polynomials of degree at most $p$. Using the weight function equal to $1$ on $[-1,1]$, define the $L^2$ projection $u_p\\in \\mathcal{P}_p$ of $f$ as the unique element that minimizes the $L^2$ error $\\|f-u\\|_{L^2([-1,1])}$ over all $u\\in\\mathcal{P}_p$. Represent $u_p$ in the modal basis of Legendre polynomials $\\{P_n\\}_{n=0}^p$ on $[-1,1]$, which are orthogonal with respect to the $L^2$ inner product with unit weight. Starting only from the orthogonality of the Legendre polynomials and the definition of the $L^2$ projection, derive the coefficients of $u_p$ in this basis. Do not use any pre-derived projection formulas; the derivation must follow from the orthogonality relations and the definition of projection. Then, evaluate $u_p$ on a uniform grid to measure the Gibbs-like overshoot near the jump at $x=0$. For a fixed window half-width $w=0.2$, define the right-neighborhood $\\Omega_R=(0,w]$ and the left-neighborhood $\\Omega_L=[-w,0)$. On a uniform grid of $M=20001$ points covering $[-w,w]$, compute the overshoot magnitude\n$$\n\\Gamma_p=\\max\\left\\{\\max_{x\\in\\Omega_R}\\left(u_p(x)-1\\right),\\ \\max_{x\\in\\Omega_L}\\left(-u_p(x)\\right),\\ 0\\right\\}.\n$$\nYour program must carry out the following steps for each degree $p$ in a specified test suite: construct $u_p$ via $L^2$ projection onto $\\mathcal{P}_p$ in the Legendre basis, evaluate $u_p$ on the specified grid, and compute $\\Gamma_p$ as defined above. Use the following test suite of polynomial degrees: $\\{0,1,3,5,10,20\\}$. All computations are dimensionless; no physical units are involved. The final output format must be a single line containing a Python list of floating-point values $[\\Gamma_{p_1},\\Gamma_{p_2},\\dots]$ corresponding to the degrees in the order $[0,1,3,5,10,20]$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4,r_5,r_6]$). The result for each $p$ must be a float. Ensure scientific realism by adhering to the exact definitions above, and design your computation to be numerically stable and reproducible with the specified grid parameters $w=0.2$ and $M=20001$ points. The algorithm must be derivable from the orthogonality of Legendre polynomials and the definition of $L^2$ projection without introducing any external shortcut formulas in the problem statement.", "solution": "The problem requires the construction and analysis of the $L^2$ orthogonal projection of a discontinuous function onto a space of one-dimensional polynomials. The objective is to quantify the Gibbs phenomenon, specifically the overshoot near the discontinuity at $x=0$, as a function of the polynomial degree $p$.\n\nThe function to be approximated is the step function $f:[-1,1] \\to \\mathbb{R}$ defined as\n$$\nf(x) = \\begin{cases} 0 & \\text{if } x < 0 \\\\ 1 & \\text{if } x \\ge 0 \\end{cases}\n$$\nWe seek its $L^2$ projection, denoted $u_p$, onto the subspace $\\mathcal{P}_p$ of polynomials of degree at most $p$. The space $\\mathcal{P}_p$ is a subspace of the Hilbert space $L^2([-1, 1])$ equipped with the inner product $(g, h) = \\int_{-1}^{1} g(x)h(x)dx$ and norm $\\|g\\|_{L^2} = \\sqrt{(g, g)}$. By definition, the projection $u_p \\in \\mathcal{P}_p$ is the unique element that minimizes the error norm $\\|f-u_p\\|_{L^2}$ over all possible choices of $u_p \\in \\mathcal{P}_p$.\n\nA fundamental property of the $L^2$ projection is that the error vector, $f-u_p$, is orthogonal to the subspace $\\mathcal{P}_p$. This is known as the Galerkin orthogonality condition:\n$$\n(f - u_p, v) = 0, \\quad \\forall v \\in \\mathcal{P}_p.\n$$\nWe represent the approximation $u_p(x)$ in the basis of Legendre polynomials, $\\{P_n(x)\\}_{n=0}^p$, which are orthogonal on the interval $[-1, 1]$ with a weight function of $1$. The expansion is\n$$\nu_p(x) = \\sum_{n=0}^{p} \\hat{f}_n P_n(x),\n$$\nwhere the coefficients $\\{\\hat{f}_n\\}_{n=0}^p$ are to be determined. Since the Legendre polynomials $\\{P_k(x)\\}_{k=0}^p$ form a basis for $\\mathcal{P}_p$, the Galerkin condition is satisfied if and only if the error is orthogonal to each basis function:\n$$\n(f - u_p, P_k) = 0, \\quad \\text{for } k=0, 1, \\dots, p.\n$$\nSubstituting the expansion of $u_p$ into this equation, we have:\n$$\n\\left(f - \\sum_{n=0}^{p} \\hat{f}_n P_n, P_k\\right) = 0.\n$$\nBy the linearity of the inner product:\n$$\n(f, P_k) - \\sum_{n=0}^{p} \\hat{f}_n (P_n, P_k) = 0.\n$$\nWe now invoke the orthogonality relation for Legendre polynomials:\n$$\n(P_n, P_k) = \\int_{-1}^{1} P_n(x) P_k(x) dx = \\frac{2}{2n+1}\\delta_{nk},\n$$\nwhere $\\delta_{nk}$ is the Kronecker delta. The sum collapses, as only the term with $n=k$ is non-zero:\n$$\n(f, P_k) - \\hat{f}_k (P_k, P_k) = 0 \\implies (f, P_k) - \\hat{f}_k \\frac{2}{2k+1} = 0.\n$$\nSolving for the coefficient $\\hat{f}_k$ yields the general formula for the projection coefficients:\n$$\n\\hat{f}_k = \\frac{2k+1}{2} (f, P_k) = \\frac{2k+1}{2} \\int_{-1}^{1} f(x)P_k(x) dx.\n$$\nThis derivation proceeds directly from the definition of the $L^2$ projection and the orthogonality of the basis, as required by the problem statement.\n\nNext, we compute the coefficients for the specified step function $f(x)$. The integral becomes:\n$$\n\\int_{-1}^{1} f(x)P_k(x) dx = \\int_{-1}^{0} (0) \\cdot P_k(x) dx + \\int_{0}^{1} (1) \\cdot P_k(x) dx = \\int_{0}^{1} P_k(x) dx.\n$$\nThus, the coefficients are given by $\\hat{f}_k = \\frac{2k+1}{2} \\int_{0}^{1} P_k(x) dx$. To evaluate this integral, we use the identity for Legendre polynomials valid for $k \\ge 1$: $(2k+1)P_k(x) = P'_{k+1}(x) - P'_{k-1}(x)$. Integrating from $0$ to $1$:\n$$\n\\int_{0}^{1} (2k+1)P_k(x) dx = \\left[ P_{k+1}(x) - P_{k-1}(x) \\right]_0^1.\n$$\n$$\n(2k+1)\\int_{0}^{1} P_k(x) dx = (P_{k+1}(1) - P_{k-1}(1)) - (P_{k+1}(0) - P_{k-1}(0)).\n$$\nUsing the property $P_n(1) = 1$ for all $n \\ge 0$, the first term vanishes: $1-1=0$. This gives, for $k \\ge 1$:\n$$\n\\int_{0}^{1} P_k(x) dx = \\frac{P_{k-1}(0) - P_{k+1}(0)}{2k+1}.\n$$\nSubstituting this back into the formula for $\\hat{f}_k$:\n$$\n\\hat{f}_k = \\frac{2k+1}{2} \\left(\\frac{P_{k-1}(0) - P_{k+1}(0)}{2k+1}\\right) = \\frac{P_{k-1}(0) - P_{k+1}(0)}{2}, \\quad \\text{for } k \\ge 1.\n$$\nFor the base case $k=0$, we compute directly:\n$$\n\\hat{f}_0 = \\frac{2(0)+1}{2} \\int_{0}^{1} P_0(x) dx = \\frac{1}{2} \\int_{0}^{1} 1 dx = \\frac{1}{2}.\n$$\nWe also know that $P_n(0) = 0$ for all odd $n$. Consequently, for an even index $k \\ge 2$, both $k-1$ and $k+1$ are odd, which means $P_{k-1}(0)=0$ and $P_{k+1}(0)=0$. Therefore, $\\hat{f}_k = 0$ for all even $k \\ge 2$.\nIn summary, the coefficients are:\n$$\n\\hat{f}_k = \\begin{cases} 1/2 & \\text{if } k = 0 \\\\ 0 & \\text{if } k \\ge 2 \\text{ is even} \\\\ \\frac{P_{k-1}(0) - P_{k+1}(0)}{2} & \\text{if } k \\text{ is odd} \\end{cases}\n$$\nWith these coefficients, the polynomial approximation $u_p(x)$ is fully defined for any degree $p$.\n\nThe final step is to quantify the overshoot magnitude $\\Gamma_p$ for the given degrees $p \\in \\{0, 1, 3, 5, 10, 20\\}$. A uniform grid of $M=20001$ points is generated over the interval $[-w, w]$ where $w=0.2$. The approximation $u_p(x)$ is evaluated at each point on this grid. The overshoot is then computed according to the formula:\n$$\n\\Gamma_p=\\max\\left\\{\\max_{x\\in\\Omega_R}\\left(u_p(x)-1\\right),\\ \\max_{x\\in\\Omega_L}\\left(-u_p(x)\\right),\\ 0\\right\\},\n$$\nwhere $\\Omega_R=(0, w]$ and $\\Omega_L=[-w, 0)$. The algorithm implemented in the final answer calculates these coefficients, constructs $u_p(x)$ for each specified degree, evaluates it on the grid, and computes $\\Gamma_p$ by finding the maximum deviations in the left and right neighborhoods of the discontinuity. The inclusion of $0$ in the outer $\\max$ function ensures that in cases of undershoot (or no overshoot), the reported value is $0$.", "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre\nfrom numpy.polynomial.legendre import Legendre\n\ndef solve():\n    \"\"\"\n    Computes the Gibbs-like overshoot for the L2 projection of a step function\n    onto polynomial subspaces of varying degrees.\n    \"\"\"\n    # Define the test cases (polynomial degrees) from the problem statement.\n    test_cases = [0, 1, 3, 5, 10, 20]\n\n    # Grid parameters for overshoot evaluation\n    w = 0.2\n    M = 20001\n    \n    # Generate the grid on which the approximation is evaluated.\n    x_grid = np.linspace(-w, w, M)\n    results = []\n\n    for p in test_cases:\n        # Step 1: Compute coefficients of the L2 projection in the Legendre basis.\n        # This implementation follows the derivation from first principles.\n        coeffs = np.zeros(p + 1)\n        \n        # Coefficient for k=0 is always 0.5 for this step function.\n        coeffs[0] = 0.5\n        \n        # Coefficients for k > 0.\n        if p > 0:\n            for k in range(1, p + 1):\n                if k % 2 == 1:  # k is odd\n                    # Formula from derivation: f_hat_k = (P_{k-1}(0) - P_{k+1}(0)) / 2\n                    p_km1_at_0 = eval_legendre(k - 1, 0)\n                    p_kp1_at_0 = eval_legendre(k + 1, 0)\n                    coeffs[k] = (p_km1_at_0 - p_kp1_at_0) / 2.0\n                else:  # k is even and k >= 2. The coefficient is 0.\n                    coeffs[k] = 0.0\n        \n        # Step 2: Construct the polynomial approximation u_p(x) using the coefficients.\n        # The Legendre class from numpy.polynomial creates a callable polynomial object.\n        u_p = Legendre(coeffs, domain=[-1, 1])\n        \n        # Step 3: Evaluate u_p on the specified grid near the discontinuity.\n        u_p_vals = u_p(x_grid)\n        \n        # Step 4: Compute the overshoot magnitude Gamma_p.\n        # The problem defines Omega_R = (0, w] and Omega_L = [-w, 0).\n        # Using boolean masks correctly partitions the grid according to these definitions.\n        \n        # Right-neighborhood Omega_R = (0, w]\n        mask_R = x_grid > 0\n        u_p_R = u_p_vals[mask_R]\n        \n        if u_p_R.size > 0:\n            overshoot_R = np.max(u_p_R - 1.0)\n        else:\n            # This case would occur if the grid had no points > 0.\n            overshoot_R = -np.inf\n\n        # Left-neighborhood Omega_L = [-w, 0)\n        mask_L = x_grid < 0\n        u_p_L = u_p_vals[mask_L]\n        \n        if u_p_L.size > 0:\n            overshoot_L = np.max(-u_p_L)\n        else:\n            # This case would occur if the grid had no points < 0.\n            overshoot_L = -np.inf\n        \n        # Gamma_p is the maximum of the right overshoot, left overshoot, and zero.\n        # The max with zero ensures no negative value is reported (i.e., accounts for undershoot).\n        gamma_p = np.max([overshoot_R, overshoot_L, 0.0])\n        results.append(gamma_p)\n\n    # Final print statement must be in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2399650"}, {"introduction": "Having observed the Gibbs phenomenon, a natural question is how to control it. This hands-on practice introduces modal filtering, a powerful technique for selectively damping the high-order coefficients in a polynomial expansion that are responsible for spurious oscillations. You will implement a common exponential filter and analyze its effect on a vector of modal coefficients, learning how to suppress numerical noise while preserving the essential low-order components of the solution [@problem_id:2399595].", "problem": "Consider the one-dimensional linear advection equation $u_t + a\\,u_x = 0$ discretized within a single reference element $x \\in [-1,1]$ using a polynomial approximation of total degree $N$ in an orthogonal modal basis $\\{\\phi_k(x)\\}_{k=0}^{N}$, where $\\phi_k(x)$ denotes the $k$-th Legendre polynomial on $[-1,1]$ normalized to be orthogonal in the $L^2$ inner product. The solution within the element is represented by the modal expansion $u_N(x,t) = \\sum_{k=0}^{N} \\hat{u}_k(t)\\,\\phi_k(x)$, where $\\hat{u}_k(t)$ are the modal coefficients. To control spurious oscillations arising from under-resolved gradients or discontinuities, a modal filter is applied to the coefficient vector, damping the highest-order modes while preserving the lower-order content relevant to smooth solution features.\n\nDefine a filter by $\\tilde{u}_N(x,t) = \\sum_{k=0}^{N} \\tilde{u}_k(t)\\,\\phi_k(x)$ with filtered modal coefficients given by\n$$\n\\tilde{u}_k = \\sigma_k \\,\\hat{u}_k, \\quad k=0,\\dots,N,\n$$\nwhere the filter factors $\\sigma_k$ are defined for prescribed integers $N \\ge 0$, $m \\in \\{0,1,\\dots,N\\}$, and parameters $\\alpha > 0$ and even integer $s \\ge 2$ by\n$$\n\\sigma_k = \n\\begin{cases}\n1, & 0 \\le k \\le m, \\\\[6pt]\n\\exp\\!\\left(-\\alpha \\left(\\dfrac{k - m}{N - m}\\right)^{s}\\right), & m < k \\le N,\n\\end{cases}\n$$\nwith the convention that if $N = m$ then $\\sigma_k = 1$ for all $k$.\n\nYou are to implement this filter and evaluate its properties and effects directly on given modal coefficient vectors. For each test case, compute the following three quantities:\n- A boolean indicator encoded as an integer $0$ or $1$ that equals $1$ if and only if $\\{\\sigma_k\\}_{k=0}^{N}$ is nonincreasing in $k$ and $\\sigma_0 = 1$.\n- The filtered energy fraction defined by the ratio\n$$\nR = \\frac{\\sum_{k=0}^{N} \\tilde{u}_k^2}{\\sum_{k=0}^{N} \\hat{u}_k^2},\n$$\nreturned as a real number.\n- The maximum preserved-mode deviation\n$$\n\\Delta = \\max_{0 \\le k \\le m} \\left|\\tilde{u}_k - \\hat{u}_k\\right|,\n$$\nreturned as a real number.\n\nAll three quantities must be computed from first principles according to the definitions above. No external data are required.\n\nImplement a program that, for each of the following test cases, computes and returns the triple $\\left(\\text{monotone\\_flag}, R, \\Delta\\right)$, where the real numbers are rounded to six decimal places:\n\n- Test case $1$: $N = 6$, $m = 2$, $\\alpha = 36$, $s = 4$, and $\\hat{u} = [\\, 1.0,\\ 0.5,\\ -0.3,\\ 0.2,\\ -0.1,\\ 0.1,\\ -0.05 \\,]$.\n- Test case $2$: $N = 3$, $m = 3$, $\\alpha = 10$, $s = 8$, and $\\hat{u} = [\\, 0.0,\\ 1.0,\\ -1.0,\\ 1.0 \\,]$.\n- Test case $3$: $N = 8$, $m = 0$, $\\alpha = 18$, $s = 2$, and $\\hat{u} = [\\, 1.0,\\ -0.5,\\ 0.3333333333333,\\ -0.25,\\ 0.2,\\ -0.1666666666667,\\ 0.1428571428571,\\ -0.125,\\ 0.1111111111111 \\,]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, aggregating all test cases in order and flattening the triples. For example, the output format must be\n$$\n[\\text{flag}_1, R_1, \\Delta_1, \\text{flag}_2, R_2, \\Delta_2, \\text{flag}_3, R_3, \\Delta_3],\n$$\nwhere $\\text{flag}_j$ is the integer $0$ or $1$ and $R_j$, $\\Delta_j$ are the rounded real numbers for test case $j$. No physical units are involved, and angles do not appear. All real-valued outputs must be rounded to six decimal places as specified.", "solution": "The one-dimensional linear advection equation $u_t + a\\,u_x = 0$ discretized by a polynomial basis within an element leads to a modal representation $u_N(x,t) = \\sum_{k=0}^{N} \\hat{u}_k(t)\\,\\phi_k(x)$, where $\\{\\phi_k\\}$ are orthogonal Legendre polynomials over $[-1,1]$. High-degree modes ($k$ large) primarily carry fine-scale content. In the presence of under-resolved features such as steep gradients or discontinuities, truncation at degree $N$ produces Gibbs-type oscillations dominated by the highest modes. A standard approach to stabilize is to damp high-order coefficients while preserving low-order content that represents the smooth part of the solution.\n\nA filter in modal space acts as a diagonal operator $F = \\mathrm{diag}(\\sigma_0,\\dots,\\sigma_N)$ applied to the vector of coefficients, $\\tilde{u} = F \\hat{u}$, with $\\tilde{u}_k = \\sigma_k \\hat{u}_k$. The design goals are: preserve the mean (and possibly a few lowest modes), enforce monotonic nonincreasing attenuation with mode index, and smoothly decay to strong damping for the highest modes. An exponential (Vandeven-type) filter satisfies these constraints:\n$$\n\\sigma_k = \n\\begin{cases}\n1, & 0 \\le k \\le m, \\\\[6pt]\n\\exp\\!\\left(-\\alpha \\left(\\dfrac{k - m}{N - m}\\right)^{s}\\right), & m < k \\le N,\n\\end{cases}\n$$\nwith even integer $s \\ge 2$ to ensure smoothness and $\\alpha > 0$ to control damping strength. If $N=m$, the definition reduces to $\\sigma_k=1$ for all $k$, representing no damping.\n\nWe verify the properties from first principles:\n\n1. Mean preservation and low-mode invariance: For $0 \\le k \\le m$, $\\sigma_k = 1$ by definition, so $\\tilde{u}_k = \\hat{u}_k$. In particular, the average mode $k=0$ is preserved.\n\n2. Monotonic nonincreasing attenuation: For $m < k \\le N$, define $r_k = \\frac{k-m}{N-m} \\in (0,1]$. The function $g(r) = \\exp(-\\alpha r^s)$ with $\\alpha>0$ and even $s$ is strictly decreasing for $r \\in (0,1]$ because $g'(r) = \\exp(-\\alpha r^s)\\,(-\\alpha s r^{s-1}) < 0$. Since $r_k$ increases with $k$, it follows that $\\sigma_k = g(r_k)$ is nonincreasing in $k$ on $\\{m+1,\\dots,N\\}$. Because $\\sigma_m = 1 \\ge \\sigma_{m+1}$, the full sequence $\\{\\sigma_k\\}_{k=0}^N$ is nonincreasing.\n\n3. Energy reduction: The squared $l^2$ norm of coefficients satisfies\n$$\n\\sum_{k=0}^N \\tilde{u}_k^2 = \\sum_{k=0}^N \\sigma_k^2 \\hat{u}_k^2 \\le \\sum_{k=0}^N \\hat{u}_k^2\n$$\nsince $0 \\le \\sigma_k \\le 1$. Therefore, the ratio $R = \\frac{\\sum \\tilde{u}_k^2}{\\sum \\hat{u}_k^2}$ lies in $[0,1]$ provided $\\hat{u} \\ne 0$. If $\\hat{u} = 0$, the ratio can be defined as $R=0$ by continuity.\n\nAlgorithmic steps to compute the requested quantities for each test case are:\n\n- Given $N$, $m$, $\\alpha$, $s$, construct $\\sigma_k$ for $k=0,\\dots,N$ using the piecewise definition above, with the special case $N=m$ returning all ones.\n- Check monotonicity and unit mean-preservation: verify $\\sigma_0 = 1$ and $\\sigma_{k} \\le \\sigma_{k-1}$ for $k=1,\\dots,N$. Return $1$ if true, else $0$.\n- Apply the filter: $\\tilde{u}_k = \\sigma_k \\hat{u}_k$ for all $k$.\n- Compute the filtered energy fraction $R = \\frac{\\sum_{k=0}^N \\tilde{u}_k^2}{\\sum_{k=0}^N \\hat{u}_k^2}$, with the convention $R=0$ if the denominator is zero to avoid division by zero.\n- Compute the preserved-mode deviation $\\Delta = \\max_{0 \\le k \\le m} |\\tilde{u}_k - \\hat{u}_k|$, which should be exactly $0$ in exact arithmetic. Round real-valued outputs $R$ and $\\Delta$ to six decimal places as specified.\n\nFor the provided test suite:\n\n- Test case $1$: $N = 6$, $m = 2$, $\\alpha = 36$, $s = 4$, $\\hat{u} = [\\, 1.0,\\ 0.5,\\ -0.3,\\ 0.2,\\ -0.1,\\ 0.1,\\ -0.05 \\,]$.\n- Test case $2$: $N = 3$, $m = 3$, $\\alpha = 10$, $s = 8$, $\\hat{u} = [\\, 0.0,\\ 1.0,\\ -1.0,\\ 1.0 \\,]$.\n- Test case $3$: $N = 8$, $m = 0$, $\\alpha = 18$, $s = 2$, $\\hat{u} = [\\, 1.0,\\ -0.5,\\ 0.3333333333333,\\ -0.25,\\ 0.2,\\ -0.1666666666667,\\ 0.1428571428571,\\ -0.125,\\ 0.1111111111111 \\,]$.\n\nThe program will compute the three requested quantities per test, round the real outputs to six decimals, and print a single flattened list in the required format. No physical units or angle units are involved, and all computations follow directly from the definitions given above.", "answer": "```python\nimport numpy as np\n\ndef build_filter_factors(N: int, m: int, alpha: float, s: int) -> np.ndarray:\n    \"\"\"\n    Construct sigma_k for k=0..N using the exponential modal filter.\n    If N == m, returns all ones.\n    \"\"\"\n    if N < 0:\n        raise ValueError(\"N must be nonnegative.\")\n    if not (0 <= m <= N):\n        raise ValueError(\"m must satisfy 0 <= m <= N.\")\n    if alpha <= 0:\n        raise ValueError(\"alpha must be positive.\")\n    if s % 2 != 0 or s < 2:\n        raise ValueError(\"s must be an even integer >= 2.\")\n\n    sigma = np.ones(N + 1, dtype=float)\n    if N == m:\n        return sigma\n\n    denom = float(N - m)\n    for k in range(m + 1, N + 1):\n        r = (k - m) / denom  # in (0,1]\n        sigma[k] = np.exp(-alpha * (r ** s))\n    return sigma\n\n\ndef is_monotone_nonincreasing_with_unit_mean(sigma: np.ndarray) -> bool:\n    \"\"\"\n    Check if sigma_0 == 1 and sigma is nonincreasing with k.\n    \"\"\"\n    if not np.isfinite(sigma).all():\n        return False\n    if abs(sigma[0] - 1.0) > 1e-15:\n        return False\n    # Nonincreasing: sigma[k] <= sigma[k-1] for k=1..N\n    diffs = np.diff(sigma)\n    return bool(np.all(diffs <= 1e-15))  # allow tiny numerical tolerance\n\n\ndef apply_filter(u_hat: np.ndarray, sigma: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Apply the modal filter: u_tilde_k = sigma_k * u_hat_k.\n    \"\"\"\n    if u_hat.shape != sigma.shape:\n        raise ValueError(\"u_hat and sigma must have the same shape.\")\n    return sigma * u_hat\n\n\ndef energy_fraction(u_hat: np.ndarray, u_tilde: np.ndarray) -> float:\n    \"\"\"\n    Compute R = ||u_tilde||^2 / ||u_hat||^2, with convention R=0 if denominator is 0.\n    \"\"\"\n    num = float(np.dot(u_tilde, u_tilde))\n    den = float(np.dot(u_hat, u_hat))\n    if den == 0.0:\n        return 0.0\n    return num / den\n\n\ndef preserved_mode_deviation(u_hat: np.ndarray, u_tilde: np.ndarray, m: int) -> float:\n    \"\"\"\n    Compute Delta = max_{0<=k<=m} |u_tilde_k - u_hat_k|.\n    If m < 0, return 0. If m >= N, consider all indices up to m intersected with length.\n    \"\"\"\n    if m < 0:\n        return 0.0\n    upto = min(m, len(u_hat) - 1)\n    if upto < 0:\n        return 0.0\n    return float(np.max(np.abs(u_tilde[:upto + 1] - u_hat[:upto + 1])))\n\n\ndef round_six(x: float) -> float:\n    \"\"\"\n    Round to six decimal places, returning a float to preserve the requested format.\n    \"\"\"\n    return float(f\"{x:.6f}\")\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, m, alpha, s, u_hat)\n        (6, 2, 36.0, 4, np.array([1.0, 0.5, -0.3, 0.2, -0.1, 0.1, -0.05], dtype=float)),\n        (3, 3, 10.0, 8, np.array([0.0, 1.0, -1.0, 1.0], dtype=float)),\n        (8, 0, 18.0, 2, np.array([1.0, -0.5, 0.3333333333333, -0.25, 0.2,\n                                  -0.1666666666667, 0.1428571428571, -0.125, 0.1111111111111], dtype=float)),\n    ]\n\n    results = []\n    for N, m, alpha, s, u_hat in test_cases:\n        sigma = build_filter_factors(N, m, alpha, s)\n        flag = 1 if is_monotone_nonincreasing_with_unit_mean(sigma) else 0\n        u_tilde = apply_filter(u_hat, sigma)\n        R = energy_fraction(u_hat, u_tilde)\n        Delta = preserved_mode_deviation(u_hat, u_tilde, m)\n        # Round real-valued outputs to six decimals\n        results.append(flag)\n        results.append(round_six(R))\n        results.append(round_six(Delta))\n\n    # Final print statement in the exact required format: single line, comma-separated, no spaces.\n    # Convert all entries to string while preserving integer vs float formats.\n    def to_str(x):\n        if isinstance(x, int):\n            return str(x)\n        else:\n            # Ensure fixed six-decimal formatting for floats\n            return f\"{x:.6f}\"\n\n    print(f\"[{','.join(to_str(x) for x in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2399595"}]}