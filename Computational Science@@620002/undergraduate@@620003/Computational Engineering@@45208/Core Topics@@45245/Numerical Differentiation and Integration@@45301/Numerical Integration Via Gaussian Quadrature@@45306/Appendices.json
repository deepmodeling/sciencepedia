{"hands_on_practices": [{"introduction": "Gaussian quadrature's remarkable efficiency stems from its deep connection to orthogonal polynomials. This practice explores this connection by tasking you to numerically verify the orthogonality of Legendre polynomials, the very basis for standard Gauss-Legendre quadrature. By observing when the quadrature yields an exact result and when it does not, you will gain a concrete understanding of the rule's degree of precision, a cornerstone of its practical application and analysis. [@problem_id:2419561]", "problem": "Implement a program that, for specified degree pairs, numerically evaluates the inner product integral of two Legendre polynomials using Gaussian quadrature (GQ). Let $P_n(x)$ denote the Legendre polynomial of degree $n$ on the interval $[-1,1]$ with the standard normalization $P_n(1)=1$. Define the inner product\n$$\nJ_{m,n} \\equiv \\int_{-1}^{1} P_m(x)\\,P_n(x)\\,dx.\n$$\nYour task is to compute numerical approximations to $J_{m,n}$ using the $N$-point Gauss-Legendre quadrature rule on $[-1,1]$ (that is, Gaussian quadrature with weight function $w(x)=1$ on $[-1,1]$). The Gaussian quadrature sum has the form\n$$\nQ_N[f] \\equiv \\sum_{i=1}^{N} w_i\\,f(x_i),\n$$\nwhere $\\{x_i\\}_{i=1}^N \\subset (-1,1)$ are the Gauss-Legendre nodes and $\\{w_i\\}_{i=1}^N$ are the corresponding positive weights.\n\nFrom first principles, recall the following foundational bases relevant to the task:\n- The Legendre polynomials $\\{P_n(x)\\}_{n\\ge 0}$ form an orthogonal sequence on $[-1,1]$ with respect to the constant weight $w(x)=1$.\n- The $N$-point Gauss-Legendre quadrature rule is exact for all polynomials of degree at most $d$, where $d$ depends on $N$ and the construction of the rule, and uses the roots of $P_N(x)$ as nodes.\n\nYour program must:\n- Use numerically generated Gauss-Legendre nodes and weights to evaluate $Q_N[P_m P_n]$ for each test case $(m,n,N)$.\n- Return the raw quadrature values (floating-point numbers) without any post-processing or rounding beyond standard double-precision arithmetic.\n\nTest suite:\n- Case $1$: $(m,n,N)=(2,3,3)$.\n- Case $2$: $(m,n,N)=(0,1,1)$.\n- Case $3$: $(m,n,N)=(10,9,10)$.\n- Case $4$: $(m,n,N)=(4,6,2)$.\n- Case $5$: $(m,n,N)=(7,7,8)$.\n\nDesign for coverage:\n- Cases $1$, $2$, and $3$ use sufficiently many nodes to capture the integral of $P_m(x)P_n(x)$ as a polynomial via Gaussian quadrature and probe different parity combinations as well as higher degrees.\n- Case $4$ deliberately uses too few nodes to reveal the effect of under-integration on an even integrand.\n- Case $5$ uses equal degrees to probe a nonzero self-inner-product captured by quadrature.\n\nFinal output format:\n- Your program should produce a single line of output containing the results, in the order of the test suite above, as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4,r_5]$), where each $r_k$ is the floating-point value returned by the quadrature for the corresponding case.", "solution": "The problem as stated is to numerically approximate the inner product integral of two Legendre polynomials, defined as\n$$\nJ_{m,n} \\equiv \\int_{-1}^{1} P_m(x)\\,P_n(x)\\,dx\n$$\nusing an $N$-point Gauss-Legendre quadrature rule. The function to be integrated is $f(x) = P_m(x) P_n(x)$. The numerical approximation is given by the sum\n$$\nQ_N[f] = \\sum_{i=1}^{N} w_i\\,f(x_i)\n$$\nwhere $\\{x_i\\}_{i=1}^N$ are the quadrature nodes and $\\{w_i\\}_{i=1}^N$ are the corresponding weights on the interval $[-1, 1]$.\n\nFirst, we must review the fundamental principles governing this problem. The Legendre polynomials, denoted $P_n(x)$ for degree $n \\ge 0$, form a complete orthogonal basis for the space of square-integrable functions on the interval $[-1, 1]$ with respect to the unit weight function $w(x) = 1$. Their orthogonality relationship is given by\n$$\n\\int_{-1}^{1} P_m(x) P_n(x) dx = \\frac{2}{2n+1} \\delta_{mn}\n$$\nwhere $\\delta_{mn}$ is the Kronecker delta, which is $1$ if $m=n$ and $0$ if $m \\neq n$. This is the exact analytical value of the integral $J_{m,n}$.\n\nSecond, the $N$-point Gauss-Legendre quadrature is constructed to be exact for any polynomial of degree up to $2N-1$. The integrand in our problem, $f(x) = P_m(x) P_n(x)$, is itself a polynomial of degree $m+n$. Consequently, the numerical quadrature $Q_N[P_m P_n]$ will yield the exact value of the integral $J_{m,n}$ if and only if the degree of the integrand does not exceed the degree of precision of the quadrature rule. That is, the approximation is exact if\n$$\nm+n \\le 2N-1\n$$\nWhen this condition is met, the numerical result must match the analytical result dictated by the orthogonality property. If $m+n > 2N-1$, the quadrature is not guaranteed to be exact and will produce an approximation whose accuracy depends on $N$ and the specific properties of the integrand.\n\nWe will now apply this theoretical framework to each test case.\n\n**Case 1: $(m,n,N) = (2,3,3)$**\nThe degree of the integrand is $m+n = 2+3 = 5$.\nThe degree of exactness for the $N=3$ point quadrature is $2N-1 = 2(3)-1 = 5$.\nSince $m+n \\le 2N-1$ (specifically, $5 \\le 5$), the quadrature is exact.\nAs $m=2 \\neq n=3$, the analytical value of the integral is $J_{2,3} = 0$.\nTherefore, the computed value $Q_3[P_2 P_3]$ must be $0$, within the limits of floating-point precision.\n\n**Case 2: $(m,n,N) = (0,1,1)$**\nThe degree of the integrand is $m+n = 0+1 = 1$.\nThe degree of exactness for the $N=1$ point quadrature is $2N-1 = 2(1)-1 = 1$.\nThe condition $m+n \\le 2N-1$ is met ($1 \\le 1$), so the quadrature is exact.\nSince $m=0 \\neq n=1$, the analytical value is $J_{0,1} = 0$.\nThe computed value $Q_1[P_0 P_1]$ must be $0$.\n\n**Case 3: $(m,n,N) = (10,9,10)$**\nThe degree of the integrand is $m+n = 10+9 = 19$.\nThe degree of exactness for the $N=10$ point quadrature is $2N-1 = 2(10)-1 = 19$.\nThe condition $m+n \\le 2N-1$ is met ($19 \\le 19$), so the quadrature is exact.\nSince $m=10 \\neq n=9$, the analytical value is $J_{10,9} = 0$.\nThe computed value $Q_{10}[P_{10} P_9]$ must be $0$.\n\n**Case 4: $(m,n,N) = (4,6,2)$**\nThe degree of the integrand is $m+n = 4+6 = 10$.\nThe degree of exactness for the $N=2$ point quadrature is $2N-1 = 2(2)-1 = 3$.\nHere, $m+n > 2N-1$ ($10 > 3$), so the quadrature is **not** exact. We expect a non-zero result, demonstrating the consequence of under-integration. The analytical result is $J_{4,6} = 0$, but the numerical method is insufficient to capture this.\nFor $N=2$, the nodes are the roots of $P_2(x) = \\frac{1}{2}(3x^2-1)$, which are $x_{1,2} = \\pm 1/\\sqrt{3}$. The weights are $w_{1,2} = 1$.\nThe quadrature sum is $Q_2[P_4 P_6] = w_1 P_4(x_1)P_6(x_1) + w_2 P_4(x_2)P_6(x_2)$.\n$Q_2[P_4 P_6] = (1) \\cdot P_4(-1/\\sqrt{3})P_6(-1/\\sqrt{3}) + (1) \\cdot P_4(1/\\sqrt{3})P_6(1/\\sqrt{3})$.\nSince $P_n(x)$ is an even function for even $n$, $P_n(-x) = P_n(x)$. Thus, the sum simplifies to $2 P_4(1/\\sqrt{3})P_6(1/\\sqrt{3})$.\nUsing the standard definitions $P_4(x) = \\frac{1}{8}(35x^4 - 30x^2 + 3)$ and $P_6(x) = \\frac{1}{16}(231x^6 - 315x^4 + 105x^2 - 5)$, we evaluate at $x=1/\\sqrt{3}$:\n$P_4(1/\\sqrt{3}) = \\frac{1}{8}\\left(35(\\frac{1}{9}) - 30(\\frac{1}{3}) + 3\\right) = \\frac{1}{8}\\left(\\frac{35}{9} - 10 + 3\\right) = \\frac{1}{8}\\left(\\frac{35-63}{9}\\right) = -\\frac{28}{72} = -\\frac{7}{18}$.\n$P_6(1/\\sqrt{3}) = \\frac{1}{16}\\left(231(\\frac{1}{27}) - 315(\\frac{1}{9}) + 105(\\frac{1}{3}) - 5\\right) = \\frac{1}{16}\\left(\\frac{77}{9} - 35 + 35 - 5\\right) = \\frac{1}{16}\\left(\\frac{77-45}{9}\\right) = \\frac{32}{144} = \\frac{2}{9}$.\nThe result is $Q_2[P_4 P_6] = 2 \\cdot (-\\frac{7}{18}) \\cdot (\\frac{2}{9}) = -\\frac{28}{162} = -\\frac{14}{81} \\approx -0.1728395$.\n\n**Case 5: $(m,n,N) = (7,7,8)$**\nThe degree of the integrand is $m+n = 7+7 = 14$.\nThe degree of exactness for the $N=8$ point quadrature is $2N-1 = 2(8)-1 = 15$.\nThe condition $m+n \\le 2N-1$ is met ($14 \\le 15$), so the quadrature is exact.\nSince $m=n=7$, the analytical value is non-zero:\n$J_{7,7} = \\frac{2}{2(7)+1} = \\frac{2}{15}$.\nThe computed value $Q_8[P_7 P_7]$ must be equal to $\\frac{2}{15} \\approx 0.133333...$.\n\nThe computational procedure will involve requesting the appropriate Gauss-Legendre nodes and weights for a given $N$, evaluating the product of the two specified Legendre polynomials at these nodes, and performing the weighted summation. Libraries such as `SciPy` provide robust implementations for generating both the quadrature rules and the Legendre polynomials.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre, roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes numerical approximations of the inner product of Legendre polynomials\n    using Gauss-Legendre quadrature for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is in the format (m, n, N) where m and n are the polynomial\n    # degrees and N is the number of quadrature points.\n    test_cases = [\n        (2, 3, 3),   # Case 1\n        (0, 1, 1),   # Case 2\n        (10, 9, 10), # Case 3\n        (4, 6, 2),   # Case 4\n        (7, 7, 8),   # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        m, n, N = case\n\n        # Generate the N-point Gauss-Legendre quadrature nodes and weights.\n        # roots_legendre(N) returns the roots of P_N(x) and the corresponding weights.\n        nodes, weights = roots_legendre(N)\n        \n        # Create callable Legendre polynomial functions for degrees m and n.\n        # The standard normalization P_k(1) = 1 is default in scipy.special.legendre.\n        P_m = legendre(m)\n        P_n = legendre(n)\n\n        # Evaluate the integrand, which is the product of the two polynomials,\n        # at the quadrature nodes.\n        integrand_values = P_m(nodes) * P_n(nodes)\n\n        # Compute the quadrature sum: sum(w_i * f(x_i)).\n        # This is the numerical approximation of the integral.\n        # np.dot is an efficient way to compute the sum of element-wise products.\n        integral_approximation = np.dot(weights, integrand_values)\n        \n        results.append(integral_approximation)\n\n    # Final print statement in the exact required format.\n    # The format is a comma-separated list of floating-point numbers\n    # enclosed in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2419561"}, {"introduction": "While standard quadrature excels with smooth functions, many physical models produce integrals with singularities that demand special treatment. This hands-on exercise guides you through a powerful technique to handle a logarithmic singularity by transforming the integral itself. You will learn to use a change of variables to absorb the problematic term into a new weight function, leading you from the familiar Gauss-Legendre to the Gauss-Laguerre quadrature, thereby demonstrating the adaptability of the Gaussian quadrature framework. [@problem_id:2419634]", "problem": "Design and implement a complete program that derives and applies a custom Gaussian quadrature to accurately approximate integrals of the form\n$$I[f] = \\int_{0}^{1} \\ln(x)\\, f(x)\\, dx,$$\nwhere $f$ is smooth on $[0,1]$ and the integrand has a logarithmic singularity at $x=0$. Your derivation must begin from fundamental bases appropriate to computational engineering and numerical analysis, namely: the change-of-variables formula for definite integrals, properties of orthogonal polynomials, and the foundational definition of Gaussian quadrature for a given weight function. You must not assume or state in advance any specialized quadrature rule that directly targets logarithmic singularities; instead, derive such a rule by transforming the integral into one with a standard nonnegative weight on an infinite interval, then apply an appropriate Gaussian quadrature. The approach must be logically justified from the stated bases and must remain scientifically realistic.\n\nImplementation requirements:\n- Starting from $I[f] = \\int_{0}^{1} \\ln(x)\\, f(x)\\, dx$, derive a variable transformation that removes the logarithm into the weight of an integral over $[0,\\infty)$.\n- Identify the orthogonal polynomial family and weight function on $[0,\\infty)$ that align with the transformed integral, and explain why the corresponding Gaussian quadrature rule is appropriate.\n- Implement a function that, for a positive integer $n$, returns a quadrature approximation $Q_{n}[f]$ to $I[f]$ using an $n$-point Gaussian quadrature tailored to the derived weight. You may obtain Gaussian quadrature nodes and weights using any standard routine in your programming environment.\n\nAngle unit requirement:\n- Whenever the function $f$ involves the sine function, interpret the argument in radians. For example, $f(x) = \\sin(\\pi x)$ uses $\\pi$ in radians.\n\nTest suite:\n- Your program must compute and return the quadrature approximations $Q_{n}[f]$ for the following five test cases:\n  1. $f(x) = 1$, with $n = 2$.\n  2. $f(x) = x$, with $n = 8$.\n  3. $f(x) = \\sin(\\pi x)$, with $n = 8$.\n  4. $f(x) = \\sin(\\pi x)$, with $n = 16$.\n  5. $f(x) = \\sin(\\pi x)$, with $n = 32$.\n- All computations are dimensionless; there are no physical units. For trigonometric functions, angles are in radians as stated.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases listed above.\n- Each floating-point number must be rounded to exactly $12$ decimal places.\n- For example, the format must be like\n$[\\text{value\\_1},\\text{value\\_2},\\text{value\\_3},\\text{value\\_4},\\text{value\\_5}]$,\nwith each $\\text{value\\_k}$ rounded to $12$ decimal places and no additional text printed.\n\nThe problem is universally applicable: a developer using any modern programming language can implement the change of variables, obtain Gaussian quadrature nodes and weights for the appropriate weight function on $[0,\\infty)$, evaluate $f$ at transformed nodes, and form the weighted sum to produce the required outputs. The final answers are floats and thus quantifiable.\n\nYour final program must be complete and runnable as specified without any user input or external data, and it must adhere to the exact output format described above.", "solution": "The problem requires the design and implementation of a numerical quadrature scheme to approximate the integral\n$$I[f] = \\int_{0}^{1} \\ln(x)\\, f(x)\\, dx$$\nwhere the function $f(x)$ is smooth on the interval $[0,1]$. The integrand possesses a logarithmic singularity at $x=0$, which complicates standard numerical integration methods. The derivation must proceed from fundamental principles by transforming the integral into a form suitable for a standard Gaussian quadrature rule.\n\nThe problem statement has been validated and is found to be scientifically grounded, well-posed, and objective. It provides a clear, self-contained set of requirements for a standard problem in computational engineering and numerical analysis. We may therefore proceed with the derivation and solution.\n\nThe core of the methodology is to apply a change of variables to transform the given integral, which is defined on a finite interval $[0,1]$ and involves a problematic logarithmic term, into an equivalent integral over an infinite interval $[0, \\infty)$ with a non-negative weight function amenable to Gaussian quadrature.\n\nLet us introduce the substitution $x = e^{-t}$. From this, we have $dx = -e^{-t}\\, dt$. The limits of integration must also be transformed:\n- As $x \\to 0^{+}$, we have $e^{-t} \\to 0^{+}$, which implies $t \\to \\infty$.\n- As $x \\to 1^{-}$, we have $e^{-t} \\to 1^{-}$, which implies $t \\to 0^{+}$.\n\nSubstituting these into the original integral expression, we obtain:\n$$I[f] = \\int_{\\infty}^{0} \\ln(e^{-t})\\, f(e^{-t})\\, (-e^{-t}\\, dt)$$\nThe term $\\ln(e^{-t})$ simplifies to $-t$. The expression becomes:\n$$I[f] = \\int_{\\infty}^{0} (-t)\\, f(e^{-t})\\, (-e^{-t}\\, dt) = \\int_{\\infty}^{0} t\\, e^{-t}\\, f(e^{-t})\\, dt$$\nBy reversing the limits of integration, we introduce a negative sign:\n$$I[f] = - \\int_{0}^{\\infty} t\\, e^{-t}\\, f(e^{-t})\\, dt$$\nThis transformed integral is of the form $-\\int_{0}^{\\infty} w(t) g(t) dt$ where the weight function is $w(t) = e^{-t}$ and the new function to be integrated is $g(t) = t\\, f(e^{-t})$. The weight function $w(t) = e^{-t}$ is non-negative over the domain $[0, \\infty)$, which satisfies the requirement for applying standard Gaussian quadrature theory.\n\nGaussian quadrature is constructed based on families of orthogonal polynomials. The family of polynomials orthogonal with respect to the weight function $w(t) = e^{-t}$ on the interval $[0, \\infty)$ are the **Laguerre polynomials**, denoted $L_n(t)$. The associated quadrature rule is known as **Gauss-Laguerre quadrature**.\n\nThe $n$-point Gauss-Laguerre quadrature formula approximates an integral of the form $\\int_{0}^{\\infty} e^{-t} h(t) dt$ as a weighted sum:\n$$\\int_{0}^{\\infty} e^{-t}\\, h(t)\\, dt \\approx \\sum_{i=1}^{n} w_i\\, h(t_i)$$\nwhere $t_i$ are the roots (nodes) of the $n$-th degree Laguerre polynomial $L_n(t)$, and $w_i$ are the corresponding quadrature weights. This approximation is exact if $h(t)$ is a polynomial of degree at most $2n-1$. Since the function $f(x)$ is specified as smooth, the transformed function $g(t) = t\\, f(e^{-t})$ is also smooth, and we can expect this quadrature to converge rapidly as $n$ increases.\n\nApplying this to our transformed integral, we set $h(t) = g(t) = t\\, f(e^{-t})$. The quadrature approximation for $I[f]$, which we will denote as $Q_n[f]$, is therefore:\n$$Q_n[f] = - \\sum_{i=1}^{n} w_i\\, g(t_i)$$\nSubstituting the expression for $g(t_i)$:\n$$Q_n[f] = - \\sum_{i=1}^{n} w_i\\, t_i\\, f(e^{-t_i})$$\nThis is the final formula for the custom quadrature rule. The procedure to compute $Q_n[f]$ is as follows:\n1. For a given number of points $n$, obtain the nodes $t_i$ and weights $w_i$ of the $n$-point Gauss-Laguerre quadrature rule (for the standard weight function $w(t)=e^{-t}$). These are available from standard numerical libraries.\n2. For each node $t_i$, compute the corresponding value of $x_i = e^{-t_i}$.\n3. Evaluate the function $f$ at these points, $f(x_i)$.\n4. Compute the sum $\\sum_{i=1}^{n} w_i\\, t_i\\, f(x_i)$.\n5. The final result is the negative of this sum.\n\nThis procedure is implemented to evaluate the specified test cases. The analytical solution for $f(x)=1$ is $I[1] = \\int_0^1 \\ln(x) dx = [x \\ln(x) - x]_0^1 = -1$. An $n$-point Gauss-Laguerre quadrature is exact for polynomials of degree up to $2n-1$. For $f(x)=1$, the transformed function is $g(t) = t f(e^{-t}) = t$. This is a polynomial of degree $1$. For $n=2$, the quadrature is exact for polynomials up to degree $2(2)-1=3$. Since $1 < 3$, the quadrature result for the first test case must be exactly $-1$. For other functions, the quadrature provides an approximation whose accuracy increases with $n$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_laguerre\n\ndef solve():\n    \"\"\"\n    Derives and applies a custom Gaussian quadrature for integrals with a logarithmic singularity.\n    \"\"\"\n\n    # Define the functions for the test suite.\n    def f1(x):\n        return 1.0\n\n    def f2(x):\n        return x\n\n    def f3(x):\n        return np.sin(np.pi * x)\n\n    # Test cases as tuples of (function, number of quadrature points n).\n    # The functions are passed as callables.\n    test_cases = [\n        (f1, 2),\n        (f2, 8),\n        (f3, 8),\n        (f3, 16),\n        (f3, 32),\n    ]\n\n    results = []\n    \n    for f_func, n in test_cases:\n        # Step 1: Obtain nodes (t_i) and weights (w_i) for n-point Gauss-Laguerre quadrature.\n        # The weight function for standard Laguerre polynomials is exp(-t) on [0, inf).\n        # This corresponds to alpha=0 in the generalized Laguerre polynomial L_n^(alpha).\n        nodes, weights = roots_laguerre(n)\n\n        # Step 2: Transform nodes t_i to x_i = exp(-t_i).\n        # The original integration variable x is on [0, 1].\n        x_vals = np.exp(-nodes)\n\n        # Step 3: Evaluate the function f at the transformed points x_i.\n        f_vals = f_func(x_vals)\n\n        # Step 4: Compute the quadrature sum.\n        # The formula is Q_n[f] = - sum_{i=1 to n} w_i * t_i * f(exp(-t_i)).\n        # Here, nodes are t_i, weights are w_i, and f_vals are f(exp(-t_i)).\n        quadrature_sum = np.sum(weights * nodes * f_vals)\n        \n        # Step 5: The final approximation is the negative of the sum.\n        result = -quadrature_sum\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Each floating-point number is formatted to 12 decimal places.\n    print(f\"[{','.join([f'{r:.12f}' for r in results])}]\")\n\nsolve()\n```", "id": "2419634"}, {"introduction": "Many real-world engineering problems, from stress analysis to fluid dynamics, require integration over two- or three-dimensional domains. This practice challenges you to extend the principles of Gaussian quadrature beyond the one-dimensional line to a two-dimensional triangle. By constructing a quadrature rule from first principles using the method of moments, you will see how the core ideas of optimal node placement and weights can be generalized to handle complex geometries, a foundational skill for advanced computational methods like the Finite Element Method. [@problem_id:2419614]", "problem": "In computational engineering, Gaussian-type quadrature on simplices approximates an integral over a domain by a weighted sum of function values at selected nodes. Consider the triangle $\\mathcal{T}$ in the plane with vertices at $(0,0)$, $(2,0)$, and $(0,1)$. Your goal is to construct a minimal-node quadrature rule on $\\mathcal{T}$ that is exact for all bivariate polynomials of total degree at most $2$, and then use it to evaluate a specific integral.\n\nConstruct the rule from first principles by starting from the definitions of polynomial exactness and symmetry. Use the following steps, without invoking any pre-tabulated rules:\n\n- Use symmetry and moment-matching to determine the location of nodes and the weights so that the rule integrates exactly all polynomials in $x$ and $y$ of total degree at most $2$ over $\\mathcal{T}$. Justify the choice of node locations and weights from the conditions for exactness of constants, linear terms, and quadratic terms.\n\n- Apply your constructed rule to evaluate the integral\n$$\n\\iint_{\\mathcal{T}} \\left(4x^{2} - 2xy + 3y^{2} + x - y + 5\\right)\\,\\mathrm{d}A.\n$$\nExpress your final result as an exact rational number. Do not round.", "solution": "The problem statement is first subjected to validation.\n\nStep 1: Extract Givens.\n- The domain of integration is a triangle $\\mathcal{T}$ with vertices at $(0,0)$, $(2,0)$, and $(0,1)$.\n- A minimal-node quadrature rule is to be constructed.\n- The rule must be exact for all bivariate polynomials of total degree at most $2$.\n- The construction must be from first principles, using symmetry and moment-matching.\n- The constructed rule is to be used to evaluate the integral $\\iint_{\\mathcal{T}} \\left(4x^{2} - 2xy + 3y^{2} + x - y + 5\\right)\\,\\mathrm{d}A$.\n- The final answer for the integral must be an exact rational number.\n\nStep 2: Validate Using Extracted Givens.\n- Scientific or Factual Unsoundness: The problem is a standard exercise in numerical analysis, specifically in the field of numerical integration (quadrature) over simplices. It is scientifically sound.\n- Non-Formalizable or Irrelevant: The problem is formal and directly related to the specified topic of Gaussian quadrature in computational engineering.\n- Incomplete or Contradictory Setup: The problem is well-defined. The geometry of the domain is specified, and the condition of exactness for polynomials up to degree $2$ is clear. The term \"minimal-node\" is a standard concept.\n- Unrealistic or Infeasible: The problem is abstract and mathematical; physical realism is not applicable.\n- Ill-Posed or Poorly Structured: The problem is well-posed. The existence and uniqueness of such quadrature rules are established topics in numerical analysis.\n- Outside Scientific Verifiability: The problem is a mathematical derivation and calculation, which is verifiable.\n\nStep 3: Verdict and Action.\nThe problem is valid. A complete solution will be provided.\n\nThe task is to construct a quadrature rule of the form\n$$ \\iint_{\\mathcal{T}} f(x, y) \\, \\mathrm{d}A \\approx \\sum_{i=1}^{N} w_i f(x_i, y_i) $$\nthat is exact for any bivariate polynomial $f(x,y)$ of total degree at most $2$. The number of nodes, $N$, must be minimal. The domain $\\mathcal{T}$ is the triangle with vertices $(0,0)$, $(2,0)$, and $(0,1)$. The boundaries of $\\mathcal{T}$ are given by $x \\ge 0$, $y \\ge 0$, and the line connecting $(2,0)$ and $(0,1)$, which is $y = 1 - \\frac{x}{2}$.\n\nFirst, we establish the conditions for exactness. The rule must integrate the basis polynomials of the space of polynomials of total degree up to $2$ exactly. A basis for this space is given by $\\{1, x, y, x^2, xy, y^2\\}$. This leads to a system of six equations, known as moment-matching equations. We must compute the moments $M_{ab} = \\iint_{\\mathcal{T}} x^a y^b \\, \\mathrm{d}A$ for $a+b \\le 2$.\n\nThe area of the triangle is $M_{00} = \\text{Area}(\\mathcal{T}) = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times 2 \\times 1 = 1$.\n\nWe compute the other moments by direct integration over $\\mathcal{T}$:\n$M_{10} = \\iint_{\\mathcal{T}} x \\, \\mathrm{d}A = \\int_{0}^{2} \\int_{0}^{1 - x/2} x \\, \\mathrm{d}y \\, \\mathrm{d}x = \\int_{0}^{2} x [y]_{0}^{1-x/2} \\, \\mathrm{d}x = \\int_{0}^{2} x(1-\\frac{x}{2}) \\, \\mathrm{d}x = \\int_{0}^{2} (x-\\frac{x^2}{2}) \\, \\mathrm{d}x = \\left[\\frac{x^2}{2} - \\frac{x^3}{6}\\right]_{0}^{2} = \\frac{4}{2} - \\frac{8}{6} = 2 - \\frac{4}{3} = \\frac{2}{3}$.\n\n$M_{01} = \\iint_{\\mathcal{T}} y \\, \\mathrm{d}A = \\int_{0}^{2} \\int_{0}^{1 - x/2} y \\, \\mathrm{d}y \\, \\mathrm{d}x = \\int_{0}^{2} \\frac{1}{2}(1-\\frac{x}{2})^2 \\, \\mathrm{d}x = \\frac{1}{2} \\int_{0}^{2} (1 - x + \\frac{x^2}{4}) \\, \\mathrm{d}x = \\frac{1}{2}\\left[x - \\frac{x^2}{2} + \\frac{x^3}{12}\\right]_{0}^{2} = \\frac{1}{2}(2 - 2 + \\frac{8}{12}) = \\frac{1}{2} \\cdot \\frac{2}{3} = \\frac{1}{3}$.\n\n$M_{20} = \\iint_{\\mathcal{T}} x^2 \\, \\mathrm{d}A = \\int_{0}^{2} x^2(1-\\frac{x}{2}) \\, \\mathrm{d}x = \\int_{0}^{2} (x^2 - \\frac{x^3}{2}) \\, \\mathrm{d}x = \\left[\\frac{x^3}{3} - \\frac{x^4}{8}\\right]_{0}^{2} = \\frac{8}{3} - \\frac{16}{8} = \\frac{8}{3} - 2 = \\frac{2}{3}$.\n\n$M_{11} = \\iint_{\\mathcal{T}} xy \\, \\mathrm{d}A = \\int_{0}^{2} x \\frac{1}{2}(1-\\frac{x}{2})^2 \\, \\mathrm{d}x = \\frac{1}{2} \\int_{0}^{2} (x - x^2 + \\frac{x^3}{4}) \\, \\mathrm{d}x = \\frac{1}{2}\\left[\\frac{x^2}{2} - \\frac{x^3}{3} + \\frac{x^4}{16}\\right]_{0}^{2} = \\frac{1}{2}(2 - \\frac{8}{3} + 1) = \\frac{1}{2}(3 - \\frac{8}{3}) = \\frac{1}{6}$.\n\n$M_{02} = \\iint_{\\mathcal{T}} y^2 \\, \\mathrm{d}A = \\int_{0}^{2} \\frac{1}{3}(1-\\frac{x}{2})^3 \\, \\mathrm{d}x$. Let $u = 1 - x/2$, so $\\mathrm{d}u = -\\frac{1}{2} \\mathrm{d}x$. The bounds change from $x \\in [0, 2]$ to $u \\in [1, 0]$.\n$M_{02} = \\int_{1}^{0} \\frac{1}{3}u^3 (-2) \\, \\mathrm{d}u = \\frac{2}{3} \\int_{0}^{1} u^3 \\, \\mathrm{d}u = \\frac{2}{3}\\left[\\frac{u^4}{4}\\right]_{0}^{1} = \\frac{2}{3} \\cdot \\frac{1}{4} = \\frac{1}{6}$.\n\nThe six conditions for the quadrature rule with nodes $(x_i, y_i)$ and weights $w_i$ are:\n1. $\\sum_{i=1}^{N} w_i = M_{00} = 1$\n2. $\\sum_{i=1}^{N} w_i x_i = M_{10} = \\frac{2}{3}$\n3. $\\sum_{i=1}^{N} w_i y_i = M_{01} = \\frac{1}{3}$\n4. $\\sum_{i=1}^{N} w_i x_i^2 = M_{20} = \\frac{2}{3}$\n5. $\\sum_{i=1}^{N} w_i x_i y_i = M_{11} = \\frac{1}{6}$\n6. $\\sum_{i=1}^{N} w_i y_i^2 = M_{02} = \\frac{1}{6}$\n\nFor a minimal-node rule, we seek the smallest $N$. There are $3N$ parameters ($w_i, x_i, y_i$ for each node) to satisfy $6$ constraints. This suggests $3N \\ge 6$, or $N \\ge 2$. It is a known result that for degree $2$ accuracy on a general triangle, $N=3$ is minimal. Following the principle of symmetry suggested in the problem, we select the three nodes to be the midpoints of the edges of the triangle $\\mathcal{T}$.\n- Midpoint of edge from $(0,0)$ to $(2,0)$: $P_1 = (1, 0)$.\n- Midpoint of edge from $(2,0)$ to $(0,1)$: $P_2 = (\\frac{2+0}{2}, \\frac{0+1}{2}) = (1, \\frac{1}{2})$.\n- Midpoint of edge from $(0,1)$ to $(0,0)$: $P_3 = (\\frac{0+0}{2}, \\frac{1+0}{2}) = (0, \\frac{1}{2})$.\n\nLet's assume symmetric weights, $w_1 = w_2 = w_3 = w$. From the first condition:\n$w_1 + w_2 + w_3 = 3w = 1 \\implies w = \\frac{1}{3}$.\nSo our candidate rule is: $N=3$, nodes $P_1(1,0), P_2(1,1/2), P_3(0,1/2)$, and weights $w_1=w_2=w_3=1/3$. We verify if this satisfies the remaining five conditions.\n\n2. $\\sum w_i x_i = \\frac{1}{3}(1) + \\frac{1}{3}(1) + \\frac{1}{3}(0) = \\frac{2}{3}$. Matches $M_{10}$. Correct.\n3. $\\sum w_i y_i = \\frac{1}{3}(0) + \\frac{1}{3}(\\frac{1}{2}) + \\frac{1}{3}(\\frac{1}{2}) = \\frac{1}{3}$. Matches $M_{01}$. Correct.\n4. $\\sum w_i x_i^2 = \\frac{1}{3}(1^2) + \\frac{1}{3}(1^2) + \\frac{1}{3}(0^2) = \\frac{2}{3}$. Matches $M_{20}$. Correct.\n5. $\\sum w_i x_i y_i = \\frac{1}{3}(1 \\cdot 0) + \\frac{1}{3}(1 \\cdot \\frac{1}{2}) + \\frac{1}{3}(0 \\cdot \\frac{1}{2}) = \\frac{1}{6}$. Matches $M_{11}$. Correct.\n6. $\\sum w_i y_i^2 = \\frac{1}{3}(0^2) + \\frac{1}{3}((\\frac{1}{2})^2) + \\frac{1}{3}((\\frac{1}{2})^2) = \\frac{1}{3}(\\frac{1}{4} + \\frac{1}{4}) = \\frac{1}{6}$. Matches $M_{02}$. Correct.\n\nThe constructed rule is exact for all polynomials of total degree at most $2$.\n\nNow, we apply this rule to evaluate the integral $I = \\iint_{\\mathcal{T}} f(x, y) \\, \\mathrm{d}A$, where $f(x, y) = 4x^{2} - 2xy + 3y^{2} + x - y + 5$.\nThe integrand $f(x,y)$ is a polynomial of total degree $2$. Therefore, the quadrature rule gives the exact value of the integral.\n$I = \\sum_{i=1}^{3} w_i f(x_i, y_i) = \\frac{1}{3} \\left( f(1,0) + f(1, \\frac{1}{2}) + f(0, \\frac{1}{2}) \\right)$.\n\nWe evaluate the function at each node:\n- $f(P_1) = f(1, 0) = 4(1)^2 - 2(1)(0) + 3(0)^2 + 1 - 0 + 5 = 4 + 1 + 5 = 10$.\n- $f(P_2) = f(1, \\frac{1}{2}) = 4(1)^2 - 2(1)(\\frac{1}{2}) + 3(\\frac{1}{2})^2 + 1 - \\frac{1}{2} + 5 = 4 - 1 + 3(\\frac{1}{4}) + 1 - \\frac{1}{2} + 5 = 9 + \\frac{3}{4} - \\frac{2}{4} = 9 + \\frac{1}{4} = \\frac{37}{4}$.\n- $f(P_3) = f(0, \\frac{1}{2}) = 4(0)^2 - 2(0)(\\frac{1}{2}) + 3(\\frac{1}{2})^2 + 0 - \\frac{1}{2} + 5 = 0 - 0 + \\frac{3}{4} - \\frac{1}{2} + 5 = 5 + \\frac{3}{4} - \\frac{2}{4} = 5 + \\frac{1}{4} = \\frac{21}{4}$.\n\nNow we calculate the integral:\n$I = \\frac{1}{3} \\left( 10 + \\frac{37}{4} + \\frac{21}{4} \\right) = \\frac{1}{3} \\left( 10 + \\frac{37+21}{4} \\right) = \\frac{1}{3} \\left( 10 + \\frac{58}{4} \\right) = \\frac{1}{3} \\left( 10 + \\frac{29}{2} \\right)$.\n$I = \\frac{1}{3} \\left( \\frac{20}{2} + \\frac{29}{2} \\right) = \\frac{1}{3} \\left( \\frac{49}{2} \\right) = \\frac{49}{6}$.\n\nThe result is an exact rational number as required.\nAs a check, we can compute the integral using the moments:\n$I = 4 M_{20} - 2 M_{11} + 3 M_{02} + M_{10} - M_{01} + 5 M_{00}$\n$I = 4(\\frac{2}{3}) - 2(\\frac{1}{6}) + 3(\\frac{1}{6}) + \\frac{2}{3} - \\frac{1}{3} + 5(1)$\n$I = \\frac{8}{3} - \\frac{1}{3} + \\frac{1}{2} + \\frac{2}{3} - \\frac{1}{3} + 5$\n$I = \\frac{8-1+2-1}{3} + \\frac{1}{2} + 5 = \\frac{8}{3} + \\frac{1}{2} + 5 = \\frac{16}{6} + \\frac{3}{6} + \\frac{30}{6} = \\frac{49}{6}$.\nThe result is confirmed.", "answer": "$$\n\\boxed{\\frac{49}{6}}\n$$", "id": "2419614"}]}