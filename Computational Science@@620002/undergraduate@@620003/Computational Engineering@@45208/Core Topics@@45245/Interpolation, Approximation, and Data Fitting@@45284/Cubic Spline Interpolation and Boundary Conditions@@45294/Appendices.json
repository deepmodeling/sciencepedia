{"hands_on_practices": [{"introduction": "The theory of cubic splines is built upon solving a system of linear equations to find the unknown second derivatives at each knot. This first exercise takes you from theory to practice, challenging you to implement a natural cubic spline from scratch. By coding the algorithm to solve the characteristic tridiagonal system, you will gain a foundational understanding of the engine that drives spline interpolation [@problem_id:2384309].", "problem": "You are given one-dimensional data sampled at strictly increasing nodes. For a set of nodes $x_0 < x_1 < \\dots < x_n$ with corresponding values $y_0, y_1, \\dots, y_n$, consider the unique natural cubic spline $S(x)$ defined by the following properties: on each interval $[x_i, x_{i+1}]$ the function $S(x)$ is a cubic polynomial; the function $S(x)$ satisfies the interpolation conditions $S(x_i) = y_i$ for all $i$ with $0 \\le i \\le n$; the first derivative $S'(x)$ is continuous on $[x_0, x_n]$; the second derivative $S''(x)$ is continuous on $[x_0, x_n]$; and the natural boundary conditions $S''(x_0) = 0$ and $S''(x_n) = 0$ hold. Your task is to write a complete program that, for each test case below, constructs the unique natural cubic spline $S(x)$ for the provided data set and evaluates $S(x)$ at a specified query point $x_q$.\n\nAll inputs in the test suite are explicitly given below. Each test case is independent. In each case, use the provided arrays $x$ and $y$ as the exact data to construct $S(x)$, and then compute the scalar value $S(x_q)$. No external data sources are permitted or needed. All computations are purely numerical and dimensionless; no physical units apply.\n\nTest Suite (each item is a triple $(x, y, x_q)$ to be processed independently, in the given order):\n- Test case $1$: $x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$, $y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$, $x_q = 1.3$.\n- Test case $2$: $x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$, $y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$, $x_q = 0.0$.\n- Test case $3$: $x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$, $y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$, $x_q = 3.0$.\n- Test case $4$: $x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$, $y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$, $x_q = 2.2$.\n- Test case $5$: $x = [\\,-1.0,\\,2.0\\,]$, $y = [\\,-1.0,\\,4.0\\,]$, $x_q = 0.5$.\n\nYour program must compute $S(x_q)$ for each of the above $5$ cases, in order, and produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each number in the output list must be a floating-point value rounded to exactly $8$ decimal places. For example, the required output format is $[r_1,r_2,r_3,r_4,r_5]$ where each $r_i$ is $S(x_q)$ rounded to $8$ decimal places for test case $i$.", "solution": "The goal is to construct the unique natural cubic spline $S(x)$ from the given data $(x_i, y_i)$ with $0 \\le i \\le n$, where $x_0 < x_1 < \\dots < x_n$. By definition, $S(x)$ is piecewise cubic on each interval $[x_i, x_{i+1}]$, interpolates the data $S(x_i) = y_i$, and has continuous first and second derivatives on $[x_0, x_n]$, with the natural boundary conditions $S''(x_0) = 0$ and $S''(x_n) = 0$.\n\nA standard construction proceeds by introducing the unknown vector of second derivatives at the knots, denoted by $M_i = S''(x_i)$ for $0 \\le i \\le n$. The step sizes are $h_i = x_{i+1} - x_i$ for $0 \\le i \\le n-1$. For interior indices $i$ with $1 \\le i \\le n-1$, continuity of $S'(x)$ and $S''(x)$ across the knots leads to a linear system for the interior second derivatives $M_1, M_2, \\dots, M_{n-1}$:\n$$\nh_{i-1} M_{i-1} + 2(h_{i-1} + h_{i}) M_i + h_i M_{i+1} = 6\\left( \\frac{y_{i+1} - y_i}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}} \\right),\n$$\nwith the natural boundary conditions $M_0 = 0$ and $M_n = 0$. For $n = 1$ (i.e., two nodes), there are no interior unknowns and the natural cubic spline reduces exactly to linear interpolation between the two points, which is consistent with $M_0 = 0$ and $M_1 = 0$.\n\nThe coefficient matrix of the system for $(M_1, \\dots, M_{n-1})$ is tridiagonal, with the following entries for $1 \\le i \\le n-1$:\n- Main diagonal: $b_i = 2(h_{i-1} + h_i)$.\n- Subdiagonal: $a_i = h_{i-1}$ for $i \\ge 2$.\n- Superdiagonal: $c_i = h_i$ for $i \\le n-2$.\nThe right-hand side is $d_i = 6\\left( \\frac{y_{i+1} - y_i}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}} \\right)$.\n\nThis linear system is strictly diagonally dominant for strictly increasing $x_i$ with $h_i > 0$, ensuring a unique solution. An efficient and exact method to solve a tridiagonal linear system in $\\mathcal{O}(n)$ time consists of a forward elimination phase that eliminates subdiagonal entries followed by a backward substitution phase to recover the unknowns. Specifically, let the system be expressed in compact notation as\n$$\na_i M_{i-1} + b_i M_i + c_i M_{i+1} = d_i, \\quad \\text{for } i = 1, 2, \\dots, n-1,\n$$\nwith the conventions that $a_1 = 0$ and $c_{n-1} = 0$. The forward elimination step constructs modified diagonals and right-hand side:\nfor $i = 2, 3, \\dots, n-1$,\n$$\nw = \\frac{a_i}{b_{i-1}}, \\quad\nb_i \\leftarrow b_i - w c_{i-1}, \\quad\nd_i \\leftarrow d_i - w d_{i-1}.\n$$\nThe backward substitution then computes\n$$\nM_{n-1} = \\frac{d_{n-1}}{b_{n-1}}, \\quad\nM_i = \\frac{d_i - c_i M_{i+1}}{b_i} \\quad \\text{for } i = n-2, n-3, \\dots, 1.\n$$\nFinally, set $M_0 = 0$ and $M_n = 0$ to obtain the full vector $(M_0, M_1, \\dots, M_n)$.\n\nWith the second derivatives known, the spline on interval $[x_i, x_{i+1}]$ can be evaluated for any $x \\in [x_i, x_{i+1}]$ using the Hermite-like representation\n$$\nS(x) = A y_i + B y_{i+1} + \\frac{h_i^2}{6} \\left[ (A^3 - A) M_i + (B^3 - B) M_{i+1} \\right],\n$$\nwhere $h_i = x_{i+1} - x_i$, $A = \\frac{x_{i+1} - x}{h_i}$, and $B = \\frac{x - x_i}{h_i}$. This representation satisfies $S(x_i) = y_i$, $S(x_{i+1}) = y_{i+1}$, and the continuity conditions by construction. If $n = 1$, then $M_i = 0$ for all indices and the formula reduces to the linear interpolation $S(x) = A y_0 + B y_1$.\n\nTo evaluate $S(x_q)$, determine the interval $[x_i, x_{i+1}]$ such that $x_q \\in [x_i, x_{i+1}]$. If $x_q = x_n$, select the final interval $[x_{n-1}, x_n]$. Compute $A$, $B$, and then $S(x_q)$ via the above formula. Repeating this for each test case produces the required scalar outputs. Each result is finally rounded to exactly $8$ decimal places and emitted in a single bracketed, comma-separated list in the specified order.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef natural_cubic_spline_second_derivatives(x, y):\n    \"\"\"\n    Compute second derivatives M at knots for the natural cubic spline.\n    x: list or array of strictly increasing floats\n    y: list or array of floats of same length as x\n    Returns: list of M values (second derivatives) at each knot.\n    \"\"\"\n    n = len(x) - 1  # number of intervals\n    if n < 1:\n        raise ValueError(\"At least two data points are required.\")\n    if n == 1:\n        # Two nodes: linear interpolation, M = 0 at both ends.\n        return [0.0, 0.0]\n\n    h = [x[i+1] - x[i] for i in range(n)]\n    # Build tridiagonal system for M[1..n-1]\n    m = n - 1  # number of interior unknowns\n    a = [0.0] * m  # sub-diagonal (a[0] unused or zero)\n    b = [0.0] * m  # main diagonal\n    c = [0.0] * m  # super-diagonal (c[m-1] unused or zero)\n    d = [0.0] * m  # right-hand side\n\n    for i in range(m):\n        hi_prev = h[i] if i >= 0 else None\n        hi = h[i+1] if (i + 1) < n else None\n        # Using indices: interior i corresponds to global index i+1\n        if i == 0:\n            a[i] = 0.0\n        else:\n            a[i] = h[i]\n        if i == m - 1:\n            c[i] = 0.0\n        else:\n            c[i] = h[i+1]\n        b[i] = 2.0 * (h[i] + h[i+1])\n\n        # Right-hand side\n        yi_minus = y[i]\n        yi = y[i+1]\n        yi_plus = y[i+2]\n        d[i] = 6.0 * ((yi_plus - yi) / h[i+1] - (yi - yi_minus) / h[i])\n\n    # Thomas algorithm: forward elimination\n    for i in range(1, m):\n        if b[i-1] == 0.0:\n            raise ZeroDivisionError(\"Singular tridiagonal system encountered.\")\n        w = a[i] / b[i-1]\n        b[i] -= w * c[i-1]\n        d[i] -= w * d[i-1]\n\n    # Back substitution\n    M_interior = [0.0] * m\n    M_interior[-1] = d[-1] / b[-1]\n    for i in range(m - 2, -1, -1):\n        M_interior[i] = (d[i] - c[i] * M_interior[i + 1]) / b[i]\n\n    # Assemble full M with natural boundary conditions\n    M = [0.0] + M_interior + [0.0]\n    return M\n\ndef evaluate_natural_cubic_spline(x, y, M, xq):\n    \"\"\"\n    Evaluate the natural cubic spline defined by (x, y, M) at xq.\n    x: list of knots (strictly increasing)\n    y: list of values\n    M: list of second derivatives at knots\n    xq: query point within [x[0], x[-1]]\n    \"\"\"\n    n = len(x) - 1\n    if xq <= x[0]:\n        i = 0\n    elif xq >= x[-1]:\n        i = n - 1\n    else:\n        # Find right interval i such that x[i] <= xq <= x[i+1]\n        # Using binary search\n        left, right = 0, n\n        while left <= right:\n            mid = (left + right) // 2\n            if x[mid] <= xq:\n                left = mid + 1\n            else:\n                right = mid - 1\n        i = max(0, min(right, n - 1))\n\n    h = x[i+1] - x[i]\n    if h == 0.0:\n        raise ZeroDivisionError(\"Zero interval width encountered.\")\n    A = (x[i+1] - xq) / h\n    B = (xq - x[i]) / h\n    # S(x) formula using second derivatives M\n    term = ((A**3 - A) * M[i] + (B**3 - B) * M[i+1]) * (h**2) / 6.0\n    Sx = A * y[i] + B * y[i+1] + term\n    return Sx\n\ndef solve():\n    # Define the test cases from the problem statement.\n    xA = [0.0, 0.5, 1.7, 2.2, 3.0]\n    yA = [0.0, 0.5, 1.8, 2.1, 1.2]\n    test_cases = [\n        (xA, yA, 1.3),\n        (xA, yA, 0.0),\n        (xA, yA, 3.0),\n        (xA, yA, 2.2),\n        ([-1.0, 2.0], [-1.0, 4.0], 0.5),\n    ]\n\n    results = []\n    for x, y, xq in test_cases:\n        # Compute second derivatives for the dataset\n        M = natural_cubic_spline_second_derivatives(x, y)\n        # Evaluate spline at query point\n        val = evaluate_natural_cubic_spline(x, y, M, xq)\n        results.append(val)\n\n    # Final print statement in the exact required format: 8 decimal places, no spaces\n    formatted = \"[\" + \",\".join(f\"{r:.8f}\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2384309"}, {"introduction": "Once you understand how to build a spline, the next critical skill is choosing the appropriate boundary conditions for a specific problem. This practice demonstrates this choice powerfully by comparing a natural spline with a periodic spline for interpolating a periodic function, $f(x) = \\sin(x)$. You will quantitatively see how matching the boundary conditions to the underlying nature of the data leads to a more accurate model [@problem_id:2382247].", "problem": "Consider the function $f(x) = \\sin(x)$ defined on the closed interval $[0, 2\\pi]$, where all angles are in radians. Let $x_0 = 0$ and $x_{N-1} = 2\\pi$. For a given integer $N \\geq 4$, define a set of $N$ sample points $\\{x_i\\}_{i=0}^{N-1}$ that are uniformly spaced on $[0, 2\\pi]$, and corresponding data values $y_i = f(x_i)$ for all $i$. Construct two cubic spline interpolants $S_{\\mathrm{nat}}(x)$ and $S_{\\mathrm{per}}(x)$ that interpolate the data $\\{(x_i, y_i)\\}$, where:\n- $S_{\\mathrm{nat}}(x)$ is the natural cubic spline, which satisfies the boundary conditions $S_{\\mathrm{nat}}''(x_0) = 0$ and $S_{\\mathrm{nat}}''(x_{N-1}) = 0$.\n- $S_{\\mathrm{per}}(x)$ is the periodic cubic spline, which satisfies $S_{\\mathrm{per}}^{(k)}(x_0) = S_{\\mathrm{per}}^{(k)}(x_{N-1})$ for $k \\in \\{0, 1, 2\\}$.\n\nDefine the true derivative at the boundaries as $f'(x_0) = \\cos(0)$ and $f'(x_{N-1}) = \\cos(2\\pi)$. For each spline type $\\tau \\in \\{\\mathrm{nat}, \\mathrm{per}\\}$, define the boundary derivative error\n$$\nE_{\\tau}(N) = \\max\\left( \\left| S_{\\tau}'(x_0) - f'(x_0) \\right|, \\left| S_{\\tau}'(x_{N-1}) - f'(x_{N-1}) \\right| \\right).\n$$\nFor each $N$ in the test suite, compute the ratio\n$$\nR(N) = \\frac{E_{\\mathrm{nat}}(N)}{E_{\\mathrm{per}}(N)}.\n$$\n\nYour program must:\n- Use the function $f(x) = \\sin(x)$ on $[0, 2\\pi]$ with angles in radians.\n- For each specified $N$, form the uniform grid including both endpoints, construct $S_{\\mathrm{nat}}(x)$ and $S_{\\mathrm{per}}(x)$ as defined above, evaluate $E_{\\mathrm{nat}}(N)$ and $E_{\\mathrm{per}}(N)$, and report $R(N)$.\n\nTest suite:\n- $N \\in \\{5, 9, 17, 64\\}$.\n\nThe required final output format is a single line containing the list of the four values $[R(5), R(9), R(17), R(64)]$ as a comma-separated list enclosed in square brackets, with each floating-point value rounded to exactly $8$ decimal places (for example, $[1.23456789,2.34567891,3.45678912,4.56789123]$). No other text should be printed.", "solution": "The problem statement has been validated and is deemed valid. It is a well-posed problem in computational engineering, grounded in the standard theory of cubic spline interpolation. It is self-contained, objective, and scientifically sound.\n\nThe task is to compare the accuracy of natural and periodic cubic splines in approximating the boundary derivatives of the function $f(x) = \\sin(x)$ on the interval $[0, 2\\pi]$. A cubic spline interpolant, $S(x)$, is a piecewise function, where each piece $S_i(x)$ on an interval $[x_i, x_{i+1}]$ is a cubic polynomial of the form:\n$$S_i(x) = a_i + b_i(x-x_i) + c_i(x-x_i)^2 + d_i(x-x_i)^3$$\nThe coefficients are determined by enforcing several conditions:\n1.  Interpolation: $S(x_i) = y_i$ for all $i=0, \\dots, N-1$.\n2.  Continuity: The spline $S(x)$, its first derivative $S'(x)$, and its second derivative $S''(x)$ are continuous over the entire interval $[x_0, x_{N-1}]$.\n\nThese conditions yield a system of linear equations. It is standard to solve for the second derivatives at the knots, $M_i = S''(x_i)$. For a uniform grid with spacing $h = (x_{N-1}-x_0)/(N-1)$, the equations for the interior knots ($i=1, \\dots, N-2$) are given by:\n$$M_{i-1} + 4M_i + M_{i+1} = \\frac{6}{h^2}(y_{i-1} - 2y_i + y_{i+1})$$\nTo obtain a unique solution for all $M_i$, two additional boundary conditions are required. The choice of these conditions defines the type of the spline.\n\n1.  **Natural Cubic Spline ($S_{\\mathrm{nat}}(x)$)**:\n    The boundary conditions are $S_{\\mathrm{nat}}''(x_0) = 0$ and $S_{\\mathrm{nat}}''(x_{N-1}) = 0$. This implies $M_0 = 0$ and $M_{N-1} = 0$. These constraints close the system of equations, resulting in a strictly diagonally dominant tridiagonal system for the unknown interior second derivatives $M_1, \\dots, M_{N-2}$, which guarantees a unique solution.\n    A critical observation for this specific problem is that the function being interpolated, $f(x) = \\sin(x)$, has true second derivatives at the boundaries of $f''(0) = -\\sin(0) = 0$ and $f''(2\\pi) = -\\sin(2\\pi) = 0$. Therefore, the natural spline's boundary conditions coincidentally match the true second derivatives of the function. This situation is analogous to a 'clamped' spline where the true second derivatives are provided, which is known to lead to a higher order of accuracy than a general natural spline.\n\n2.  **Periodic Cubic Spline ($S_{\\mathrm{per}}(x)$)**:\n    The boundary conditions are periodic: $S_{\\mathrm{per}}^{(k)}(x_0) = S_{\\mathrm{per}}^{(k)}(x_{N-1})$ for $k=0, 1, 2$. The function $f(x) = \\sin(x)$ and its derivatives are periodic on $[0, 2\\pi]$, so these conditions are consistent with the underlying function's properties. These conditions result in a cyclic tridiagonal system of equations for $M_0, \\dots, M_{N-1}$, which is also non-singular and has a unique solution. This type of spline is theoretically the most appropriate for interpolating periodic functions.\n\nThe first derivative of the spline at the endpoints is required to compute the error. These can be calculated from the values of $y_i$ and $M_i$. At the left boundary $x_0$:\n$$S'(x_0) = \\frac{y_1 - y_0}{h} - \\frac{h}{6}(2M_0 + M_1)$$\nAt the right boundary $x_{N-1}$:\n$$S'(x_{N-1}) = \\frac{y_{N-1} - y_{N-2}}{h} + \\frac{h}{6}(M_{N-2} + 2M_{N-1})$$\nThe true derivative of $f(x) = \\sin(x)$ is $f'(x) = \\cos(x)$. At the boundaries, the true values are $f'(0) = \\cos(0) = 1$ and $f'(2\\pi) = \\cos(2\\pi) = 1$.\nThe error for each spline type $\\tau \\in \\{\\mathrm{nat}, \\mathrm{per}\\}$ is defined as the maximum absolute difference between the spline's derivative and the true derivative at the two boundaries:\n$$E_{\\tau}(N) = \\max\\left( \\left| S_{\\tau}'(0) - 1 \\right|, \\left| S_{\\tau}'(2\\pi) - 1 \\right| \\right)$$\nFinally, the ratio $R(N) = E_{\\mathrm{nat}}(N) / E_{\\mathrm{per}}(N)$ is computed for each $N$ in the test suite.\n\nThe algorithm proceeds as follows:\nFor each given value of $N$:\n1.  Generate $N$ uniformly spaced points $\\{x_i\\}$ on $[0, 2\\pi]$ and the corresponding data values $y_i = \\sin(x_i)$.\n2.  Construct the natural cubic spline $S_{\\mathrm{nat}}(x)$ using the `scipy.interpolate.CubicSpline` library function with `bc_type='natural'`.\n3.  Construct the periodic cubic spline $S_{\\mathrm{per}}(x)$ using the same function with `bc_type='periodic'`.\n4.  Evaluate the first derivatives $S_{\\mathrm{nat}}'(0)$, $S_{\\mathrm{nat}}'(2\\pi)$, $S_{\\mathrm{per}}'(0)$, and $S_{\\mathrm{per}}'(2\\pi)$.\n5.  Calculate the errors $E_{\\mathrm{nat}}(N)$ and $E_{\\mathrm{per}}(N)$.\n6.  Compute the ratio $R(N)$.\n\nThis procedure is repeated for each $N$ in the set $\\{5, 9, 17, 64\\}$. The resulting ratios are collected and formatted as specified. The \"lucky\" choice of natural boundary conditions is expected to make $S_{\\mathrm{nat}}(x)$ surprisingly accurate, leading to an interesting comparison with the theoretically superior periodic spline.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Solves the cubic spline boundary derivative error problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [5, 9, 17, 64]\n\n    results = []\n    for N in test_cases:\n        # Step 1: Define the grid and data points for f(x) = sin(x) on [0, 2*pi].\n        # The grid is uniform and includes both endpoints.\n        x_points = np.linspace(0.0, 2.0 * np.pi, N)\n        y_points = np.sin(x_points)\n\n        # Step 2: Define the true derivative at the boundaries.\n        # f'(x) = cos(x), so f'(0) = 1 and f'(2*pi) = 1.\n        f_prime_true = 1.0\n\n        # Step 3: Construct the natural cubic spline and calculate its boundary derivative error.\n        # 'natural' sets the second derivative at the endpoints to zero.\n        # S_nat''(x_0) = 0, S_nat''(x_{N-1}) = 0.\n        s_nat = CubicSpline(x_points, y_points, bc_type='natural')\n        \n        # Evaluate the first derivative (nu=1) at the boundaries.\n        s_nat_prime_x0 = s_nat(x_points[0], nu=1)\n        s_nat_prime_x_end = s_nat(x_points[-1], nu=1)\n        \n        # Calculate the error E_nat(N).\n        error_nat = max(abs(s_nat_prime_x0 - f_prime_true), abs(s_nat_prime_x_end - f_prime_true))\n\n        # Step 4: Construct the periodic cubic spline and calculate its boundary derivative error.\n        # 'periodic' enforces S^(k)(x_0) = S^(k)(x_{N-1}) for k=0,1,2.\n        # This is valid because y_points[0] is numerically equal to y_points[-1].\n        s_per = CubicSpline(x_points, y_points, bc_type='periodic')\n\n        # Evaluate the first derivative (nu=1) at the boundaries.\n        s_per_prime_x0 = s_per(x_points[0], nu=1)\n        s_per_prime_x_end = s_per(x_points[-1], nu=1)\n        \n        # Calculate the error E_per(N).\n        error_per = max(abs(s_per_prime_x0 - f_prime_true), abs(s_per_prime_x_end - f_prime_true))\n\n        # Step 5: Compute the ratio R(N).\n        # We check for division by zero, although it is not expected for this problem.\n        if error_per == 0.0:\n            # If the periodic spline is perfectly accurate, the ratio is either 0 (if natural is also perfect)\n            # or infinite (if natural has error). In a computational context, we would report a very large number\n            # or handle as a special case. Given the problem, it's safe to assume error_per > 0.\n            ratio = np.inf if error_nat > 0 else 0.0\n        else:\n            ratio = error_nat / error_per\n        \n        results.append(ratio)\n\n    # Final print statement in the exact required format.\n    # Each float is formatted to 8 decimal places.\n    formatted_results = [f\"{r:.8f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2382247"}, {"introduction": "Interpolation models are often used to make predictions, which sometimes requires extrapolating beyond the original data range—a notoriously risky endeavor. This exercise explores how different boundary conditions (natural, clamped, and not-a-knot) govern the behavior and stability of extrapolation. Through a numerical sensitivity analysis, you will learn to quantify how robust your extrapolated predictions are to small changes in your data [@problem_id:2382282].", "problem": "You are tasked with implementing a complete, runnable program that constructs and evaluates cubic spline interpolants with different endpoint boundary conditions, and then quantifies how these conditions influence extrapolation beyond the data range. Your program must be deterministic and produce the exact output format described below.\n\nConsider data generated from the function $f(x) = \\sin(x)$ over the closed interval $[0,\\pi]$, with angles measured in radians. Let $n = 8$ sample points be uniformly spaced on $[0,\\pi]$, i.e., $x_i = 0 + (i-1)\\,\\Delta x$ with $\\Delta x = \\pi/(n-1)$ for $i = 1,2,\\dots,n$, and let $y_i = f(x_i)$ for $i = 1,2,\\dots,n$. You will construct a cubic spline interpolant $s(x)$ to the data $\\{(x_i,y_i)\\}_{i=1}^n$ under each of the following boundary conditions at the endpoints $x_1$ and $x_n$:\n\n- Natural boundary conditions: $s''(x_1) = 0$ and $s''(x_n) = 0$.\n- Clamped boundary conditions: $s'(x_1) = f'(x_1)$ and $s'(x_n) = f'(x_n)$, where $f'(x) = \\cos(x)$.\n- Not-a-knot boundary conditions: the third derivative is continuous at the first interior knot $x_2$ and the last interior knot $x_{n-1}$, which forces the first two and last two polynomial pieces to merge into single cubics.\n\nA cubic spline $s(x)$ is a piecewise cubic polynomial with global $C^2$-smoothness (i.e., $s(x)$, $s'(x)$, and $s''(x)$ are continuous for all $x$), satisfying the interpolation conditions $s(x_i) = y_i$ for all $i$. The boundary conditions above complete the specification so that a unique interpolant exists. Extrapolation of $s(x)$ beyond $[x_1,x_n]$ is defined by extending the cubic polynomial of the nearest boundary interval.\n\nYour program must compute the following quantitative diagnostics:\n\n- Define two extrapolation targets: $x_L = -0.5$ (to the left of $x_1$) and $x_R = \\pi + 0.5$ (to the right of $x_n$), with angles in radians.\n- For each boundary condition, compute the absolute extrapolation error at $x_L$ and at $x_R$, defined as $E_{\\text{left}} = |s(x_L) - f(x_L)|$ and $E_{\\text{right}} = |s(x_R) - f(x_R)|$.\n- To assess extrapolation stability controlled by the boundary conditions, define the following one-sided endpoint sensitivity metrics based on a small perturbation $\\varepsilon = 10^{-6}$:\n  - Right-end sensitivity at $x_R$: construct a perturbed dataset with only the rightmost data value changed to $y_n^{\\text{pert}} = y_n + \\varepsilon$, leaving all other $y_i$ unchanged and keeping the same boundary condition. Let $s^{\\text{pert}}(x)$ be the corresponding spline. Define $S_{\\text{right}} = |s^{\\text{pert}}(x_R) - s(x_R)| / \\varepsilon$.\n  - Left-end sensitivity at $x_L$: construct a perturbed dataset with only the leftmost data value changed to $y_1^{\\text{pert}} = y_1 + \\varepsilon$, leaving all other $y_i$ unchanged and keeping the same boundary condition. Define $S_{\\text{left}} = |s^{\\text{pert}}(x_L) - s(x_L)| / \\varepsilon$.\nThese sensitivities quantify how a unit change at the nearest endpoint data value influences an extrapolated prediction just beyond that endpoint, under each boundary condition.\n\nTest suite and required outputs:\n- Use exactly the three boundary conditions described above in the fixed order: natural, clamped, not-a-knot.\n- Use exactly $n = 8$, the function $f(x) = \\sin(x)$, $x_L = -0.5$, $x_R = \\pi + 0.5$, and $\\varepsilon = 10^{-6}$, with angles in radians.\n- Your program must compute and aggregate the following four lists of floating-point results in the exact order shown:\n  1. $[E_{\\text{right}}^{\\text{natural}}, E_{\\text{right}}^{\\text{clamped}}, E_{\\text{right}}^{\\text{not-a-knot}}]$,\n  2. $[E_{\\text{left}}^{\\text{natural}}, E_{\\text{left}}^{\\text{clamped}}, E_{\\text{left}}^{\\text{not-a-knot}}]$,\n  3. $[S_{\\text{right}}^{\\text{natural}}, S_{\\text{right}}^{\\text{clamped}}, S_{\\text{right}}^{\\text{not-a-knot}}]$,\n  4. $[S_{\\text{left}}^{\\text{natural}}, S_{\\text{left}}^{\\text{clamped}}, S_{\\text{left}}^{\\text{not-a-knot}}]$.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated top-level Python-style list of four lists, in the order specified above (for example, a line like $[[a,b,c],[d,e,f],[g,h,i],[j,k,l]]$). The numerical values must be floating-point numbers.\n\nScientific and algorithmic bases that you must rely on in your reasoning and implementation:\n- Definition of cubic splines as piecewise cubic functions with $C^2$ continuity, satisfying interpolation conditions.\n- Boundary condition roles in closing the linear system for spline coefficients.\n- Extrapolation for cubic splines as the natural continuation of the boundary interval’s cubic.\n- Sensitivity as a finite-difference approximation of a directional derivative with respect to data perturbations.\n\nAngles must be in radians, and all requested numerical answers must be returned as floating-point values in the exact output format described.", "solution": "The problem as stated is subjected to validation.\n\nStep 1: Extract Givens\n- Function: $f(x) = \\sin(x)$\n- Interval: $[0, \\pi]$\n- Number of sample points: $n = 8$\n- Sample points abscissas: $x_i = 0 + (i-1)\\Delta x$ with $\\Delta x = \\pi/(n-1)$ for $i=1, 2, \\dots, n$.\n- Sample points ordinates: $y_i = f(x_i)$ for $i=1, 2, \\dots, n$.\n- Boundary conditions to test:\n    1. Natural: $s''(x_1) = 0$ and $s''(x_n) = 0$.\n    2. Clamped: $s'(x_1) = f'(x_1)$ and $s'(x_n) = f'(x_n)$, where $f'(x) = \\cos(x)$.\n    3. Not-a-knot: Third derivative continuity at $x_2$ and $x_{n-1}$.\n- Extrapolation targets: $x_L = -0.5$, $x_R = \\pi + 0.5$.\n- Extrapolation error definitions: $E_{\\text{left}} = |s(x_L) - f(x_L)|$, $E_{\\text{right}} = |s(x_R) - f(x_R)|$.\n- Perturbation magnitude: $\\varepsilon = 10^{-6}$.\n- Sensitivity metric definitions:\n    - $S_{\\text{right}} = |s^{\\text{pert}}(x_R) - s(x_R)| / \\varepsilon$, where $s^{\\text{pert}}$ is the spline for data with $y_n$ replaced by $y_n + \\varepsilon$.\n    - $S_{\\text{left}} = |s^{\\text{pert}}(x_L) - s(x_L)| / \\varepsilon$, where $s^{\\text{pert}}$ is the spline for data with $y_1$ replaced by $y_1 + \\varepsilon$.\n- Required output structure: Four lists of results for the three boundary conditions (natural, clamped, not-a-knot) in order: $[E_{\\text{right}}]$, $[E_{\\text{left}}]$, $[S_{\\text{right}}]$, $[S_{\\text{left}}]$.\n\nStep 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective. It is a standard problem in computational engineering and numerical analysis, focused on the well-established theory of cubic spline interpolation.\n- **Scientific Soundness**: The definitions of cubic splines, their continuity properties ($C^2$), and the specified boundary conditions (natural, clamped, not-a-knot) are all standard and mathematically rigorous. The function $f(x) = \\sin(x)$ is infinitely differentiable and well-behaved, making it a suitable test case. The procedure for sensitivity analysis through finite differences is a valid numerical technique. The problem adheres to fundamental principles of numerical analysis.\n- **Well-Posedness**: For a given set of data points, each of the three specified boundary conditions closes the system of linear equations for the spline coefficients, guaranteeing the existence of a unique spline interpolant. The tasks are precisely defined and lead to deterministic, computable quantities.\n- **Completeness and Consistency**: All necessary parameters are provided: the function, the interval, the number of points $n=8$, the exact formula for node placement, the extrapolation points $x_L = -0.5$ and $x_R = \\pi + 0.5$, and the perturbation $\\varepsilon = 10^{-6}$. There are no contradictions.\n\nStep 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\nA cubic spline $s(x)$ interpolating a set of $n$ data points $\\{(x_i, y_i)\\}_{i=1}^n$ is a piecewise function. On each subinterval $[x_i, x_{i+1}]$ for $i=1, \\dots, n-1$, $s(x)$ is a cubic polynomial, which we denote as $s_i(x)$.\n$$s_i(x) = a_i + b_i(x-x_i) + c_i(x-x_i)^2 + d_i(x-x_i)^3$$\nThere are $4(n-1)$ coefficients $\\{a_i, b_i, c_i, d_i\\}_{i=1}^{n-1}$ to determine. The following conditions are imposed:\n1. Interpolation: $s_i(x_i) = y_i$ for $i=1, \\dots, n-1$ and $s_{n-1}(x_n) = y_n$. This provides $n$ conditions. From the first part, we find $a_i = y_i$.\n2. Continuity: At the $n-2$ interior knots $x_2, \\dots, x_{n-1}$, the function value, first derivative, and second derivative must be continuous.\n   - $s_{i-1}(x_i) = s_i(x_i) (= y_i)$\n   - $s'_{i-1}(x_i) = s'_i(x_i)$\n   - $s''_{i-1}(x_i) = s''_i(x_i)$\nThese continuity constraints provide $3(n-2)$ conditions. In total, we have $n + 3(n-2) = 4n-6$ conditions for $4(n-1) = 4n-4$ unknowns. We are short two conditions. These are provided by the boundary conditions at the endpoints $x_1$ and $x_n$.\n\nThe specified boundary conditions are:\n- **Natural**: The second derivatives at the endpoints are zero: $s''(x_1)=0$ and $s''(x_n)=0$. This implies that the spline approaches the endpoints with no curvature, mimicking a line. It is often used when no information about the endpoint derivatives is available.\n- **Clamped**: The first derivatives at the endpoints are specified. Here, they are matched to the true derivatives of the underlying function $f(x)$: $s'(x_1) = f'(x_1)$ and $s'(x_n) = f'(x_n)$. For $f(x)=\\sin(x)$, we have $f'(x)=\\cos(x)$, so $s'(0) = \\cos(0) = 1$ and $s'(\\pi) = \\cos(\\pi) = -1$.\n- **Not-a-knot**: This condition forces the first and second cubic pieces to be the same polynomial, and likewise for the last two pieces. This is achieved by enforcing continuity of the third derivative at the first interior knot $x_2$ and the last interior knot $x_{n-1}$. That is, $s'''(x_2^-) = s'''(x_2^+)$ and $s'''(x_{n-1}^-) = s'''(x_{n-1}^+)$.\n\nThe problem requires extrapolation, which means evaluating the spline $s(x)$ at points outside the interval $[x_1, x_n]$. This is performed by extending the cubic polynomial defined on the nearest boundary interval. For $x < x_1$, we use $s_1(x)$, and for $x > x_n$, we use $s_{n-1}(x)$.\n\nThe sensitivity metrics, $S_{\\text{left}}$ and $S_{\\text{right}}$, are finite-difference approximations to the partial derivatives of the extrapolated values with respect to the endpoint data values:\n$$ S_{\\text{left}} \\approx \\frac{\\partial s(x_L)}{\\partial y_1}, \\quad S_{\\text{right}} \\approx \\frac{\\partial s(x_R)}{\\partial y_n} $$\nThese metrics quantify the stability of extrapolation. A large sensitivity value indicates that a small change or error in an endpoint measurement can lead to a large, amplified error in the extrapolated prediction.\n\nThe solution proceeds as follows:\n1.  Set up the constants $n=8$, $\\varepsilon=10^{-6}$, and the evaluation points $x_L=-0.5$ and $x_R=\\pi+0.5$.\n2.  Generate the data points $\\{x_i, y_i\\}_{i=1}^n$ from $f(x)=\\sin(x)$ on $[0, \\pi]$ using $x_i = (i-1)\\pi/(n-1)$.\n3.  Iterate through the three boundary conditions: natural, clamped, and not-a-knot.\n4.  For each condition:\n    a. Construct the baseline cubic spline $s(x)$ using the original data $\\{x_i, y_i\\}$. For the clamped case, the derivatives $s'(0)=1$ and $s'(\\pi)=-1$ are supplied. Extrapolation is enabled.\n    b. Evaluate $s(x_L)$ and $s(x_R)$. Calculate the extrapolation errors $E_{\\text{left}} = |s(x_L) - \\sin(x_L)|$ and $E_{\\text{right}} = |s(x_R) - \\sin(x_R)|$.\n    c. To find $S_{\\text{right}}$, create a perturbed dataset where $y_n$ is replaced by $y_n + \\varepsilon$. Construct the perturbed spline $s^{\\text{pert}}(x)$ using the same boundary condition type. Calculate $S_{\\text{right}} = |s^{\\text{pert}}(x_R) - s(x_R)| / \\varepsilon$.\n    d. To find $S_{\\text{left}}$, create a perturbed dataset where $y_1$ is replaced by $y_1 + \\varepsilon$. Construct the perturbed spline $s^{\\text{pert}}(x)$. Calculate $S_{\\text{left}} = |s^{\\text{pert}}(x_L) - s(x_L)| / \\varepsilon$.\n5.  Collect the results for $E_{\\text{right}}$, $E_{\\text{left}}$, $S_{\\text{right}}$, and $S_{\\text{left}}$ into four separate lists, maintaining the order of the boundary conditions.\n6.  Format the four lists into a single list of lists for the final output. The implementation will utilize the `scipy.interpolate.CubicSpline` class, which provides a robust and efficient way to perform these constructions.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Constructs cubic splines with different boundary conditions,\n    evaluates extrapolation error and endpoint sensitivity.\n    \"\"\"\n\n    # Step 1: Define constants and problem parameters as per the statement.\n    n = 8\n    epsilon = 1e-6\n    x_left_target = -0.5\n    x_right_target = np.pi + 0.5\n    \n    # Define the true function and its derivative.\n    true_func = np.sin\n    true_func_deriv = np.cos\n    \n    # Step 2: Generate the sample data points.\n    # The problem statement uses 1-based indexing i=1,...,n.\n    # We use 0-based indexing for arrays.\n    # x_i = (i-1)*pi/(n-1) for i=1..n becomes x_j = j*pi/(n-1) for j=0..n-1.\n    x_nodes = np.linspace(0, np.pi, n)\n    y_nodes = true_func(x_nodes)\n\n    # Define the boundary conditions and their order for processing.\n    boundary_conditions = ['natural', 'clamped', 'not-a-knot']\n    \n    # Lists to store the computed diagnostics.\n    errors_right = []\n    errors_left = []\n    sensitivities_right = []\n    sensitivities_left = []\n    \n    # Step 3: Loop through each boundary condition type.\n    for bc_type in boundary_conditions:\n        \n        # --- Baseline Spline Calculation ---\n        # Special handling for 'clamped' condition which requires derivative values.\n        if bc_type == 'clamped':\n            # Derivatives at endpoints x_1=0 and x_n=pi.\n            # f'(x) = cos(x), so f'(0)=1, f'(pi)=-1.\n            deriv_at_endpoints = (true_func_deriv(x_nodes[0]), true_func_deriv(x_nodes[-1]))\n            # The bc_type argument for clamped specifies derivative order and value.\n            # (order, value) for left, (order, value) for right.\n            spline = CubicSpline(x_nodes, y_nodes, bc_type=((1, deriv_at_endpoints[0]), (1, deriv_at_endpoints[1])), extrapolate=True)\n        else:\n            # For 'natural' and 'not-a-knot', the string name is sufficient.\n            spline = CubicSpline(x_nodes, y_nodes, bc_type=bc_type, extrapolate=True)\n\n        # Evaluate extrapolation errors.\n        s_left = spline(x_left_target)\n        s_right = spline(x_right_target)\n        \n        f_left = true_func(x_left_target)\n        f_right = true_func(x_right_target)\n        \n        error_left = np.abs(s_left - f_left)\n        error_right = np.abs(s_right - f_right)\n        \n        errors_left.append(error_left)\n        errors_right.append(error_right)\n        \n        # --- Sensitivity Analysis: Right End ---\n        y_perturbed_right = y_nodes.copy()\n        y_perturbed_right[-1] += epsilon\n        \n        if bc_type == 'clamped':\n            # Per the problem, we keep the original boundary conditions.\n            spline_pert_right = CubicSpline(x_nodes, y_perturbed_right, bc_type=((1, deriv_at_endpoints[0]), (1, deriv_at_endpoints[1])), extrapolate=True)\n        else:\n            spline_pert_right = CubicSpline(x_nodes, y_perturbed_right, bc_type=bc_type, extrapolate=True)\n        \n        s_pert_right = spline_pert_right(x_right_target)\n        sensitivity_right = np.abs(s_pert_right - s_right) / epsilon\n        sensitivities_right.append(sensitivity_right)\n        \n        # --- Sensitivity Analysis: Left End ---\n        y_perturbed_left = y_nodes.copy()\n        y_perturbed_left[0] += epsilon\n\n        if bc_type == 'clamped':\n            # Keeping the same boundary condition.\n            spline_pert_left = CubicSpline(x_nodes, y_perturbed_left, bc_type=((1, deriv_at_endpoints[0]), (1, deriv_at_endpoints[1])), extrapolate=True)\n        else:\n            spline_pert_left = CubicSpline(x_nodes, y_perturbed_left, bc_type=bc_type, extrapolate=True)\n            \n        s_pert_left = spline_pert_left(x_left_target)\n        sensitivity_left = np.abs(s_pert_left - s_left) / epsilon\n        sensitivities_left.append(sensitivity_left)\n        \n    # Step 4: Assemble final results in the required list-of-lists format.\n    final_results = [\n        errors_right,\n        errors_left,\n        sensitivities_right,\n        sensitivities_left\n    ]\n    \n    # Final print statement must match the required format exactly.\n    # Convert list of lists to the string representation.\n    # Example: [[a,b,c],[d,e,f],[g,h,i],[j,k,l]]\n    result_str = f\"[{','.join(map(str, final_results))}]\"\n    # The default string representation of a list in Python is `[item1, item2, ...]`.\n    # We remove outer quotes and replace spaces for a compact representation.\n    result_str = str(final_results).replace(\" \", \"\")\n\n    print(result_str)\n```", "id": "2382282"}]}