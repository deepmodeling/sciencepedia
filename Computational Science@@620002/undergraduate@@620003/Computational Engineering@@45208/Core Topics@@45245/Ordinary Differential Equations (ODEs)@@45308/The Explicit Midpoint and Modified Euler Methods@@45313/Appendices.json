{"hands_on_practices": [{"introduction": "At first glance, the explicit midpoint and modified Euler methods appear to be two distinct numerical schemes. This exercise reveals a surprising and fundamental insight: for the important class of linear autonomous systems, $y' = Ay$, they are algebraically identical. By applying both methods to a system representing a damped harmonic oscillator, you will discover that their update rules simplify to the same amplification matrix, providing a deeper understanding of their core structure beyond their general-purpose formulas [@problem_id:2444104].", "problem": "Consider the linear autonomous ordinary differential equation (ODE) system $y'(t) = A y(t)$ with a constant real $2 \\times 2$ matrix $A$ whose eigenvalues are complex and have negative real part, corresponding to an underdamped oscillator. Let the initial condition be $y(0) = y_0 \\in \\mathbb{R}^2$. The exact solution is $y(t) = \\exp(A t)\\, y_0$, where $\\exp(\\cdot)$ denotes the matrix exponential.\n\nYou are asked to compute, for several parameter sets, the global error at a final time $T$ when numerically integrating the system using both the explicit midpoint method and the modified Euler method over a uniform grid with step size $h$. The global error is defined as the Euclidean two-norm of the difference between the numerical solution and the exact solution at $t = T$. No physical units are required for this problem, and all angles (if any appear during your internal derivations) are in radians.\n\nFor each test case below, the system matrix $A$ represents a damped oscillator with natural frequency $\\omega > 0$ and damping ratio $\\zeta \\in (0,1)$ given by\n$$\nA(\\omega,\\zeta) = \\begin{bmatrix}\n0 & 1 \\\\\n-\\omega^2 & -2 \\zeta \\omega\n\\end{bmatrix},\n$$\nthe initial condition is $y_0 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$, and the final time $T$ and step size $h$ are specified. Assume that the ratio $T/h$ is a positive integer so that $N = T/h$ uniform steps are taken.\n\nFor each test case, compute two floating-point numbers:\n- $E_{\\text{mid}}$: the global error at $t = T$ when using the explicit midpoint method with step size $h$ on $N$ steps.\n- $E_{\\text{mod}}$: the global error at $t = T$ when using the modified Euler method with step size $h$ on $N$ steps.\n\nUse the Euclidean two-norm for the error. The exact value $y(T)$ must be computed from the matrix exponential $y(T) = \\exp(A T) y_0$. Report each error as a floating-point decimal number.\n\nTest suite:\n1. $(\\omega, \\zeta, T, h) = (5.0, 0.1, 2.0, 0.01)$\n2. $(\\omega, \\zeta, T, h) = (5.0, 0.1, 1.0, 0.2)$\n3. $(\\omega, \\zeta, T, h) = (10.0, 0.999, 0.5, 0.005)$\n4. $(\\omega, \\zeta, T, h) = (40.0, 0.2, 1.0, 0.002)$\n5. $(\\omega, \\zeta, T, h) = (5.0, 0.1, 2.0, 0.001)$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain one entry per test case, in the same order as listed above. Each entry must itself be a two-element list of the form $[E_{\\text{mid}}, E_{\\text{mod}}]$. For example, the overall output format is\n$[[E_{\\text{mid}}^{(1)},E_{\\text{mod}}^{(1)}],[E_{\\text{mid}}^{(2)},E_{\\text{mod}}^{(2)}],\\dots,[E_{\\text{mid}}^{(5)},E_{\\text{mod}}^{(5)}]]$,\nwith each $E_{\\text{mid}}^{(i)}$ and $E_{\\text{mod}}^{(i)}$ reported as decimal numbers. It is acceptable to round each number to ten decimal places for presentation.", "solution": "The problem statement has been validated and is determined to be sound. It is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. The problem describes a classical damped harmonic oscillator system and asks for the comparison of two standard numerical integration methods.\n\n**Derivation of the Solution**\n\nThe problem requires a comparison of the global error of two numerical schemes for the linear autonomous ordinary differential equation (ODE) system:\n$$\n\\frac{dy}{dt} = A y(t), \\quad y(0) = y_0\n$$\nwhere $y(t) \\in \\mathbb{R}^2$ and $A \\in \\mathbb{R}^{2 \\times 2}$ is a constant matrix.\nThe two numerical methods are the explicit midpoint method and the modified Euler method. Let $y_n$ be the numerical approximation of $y(t_n)$ at time $t_n = n h$. The function defining the ODE is $f(t,y) = A y$. Since the system is autonomous, $f$ does not depend explicitly on $t$.\n\n**1. The Explicit Midpoint Method**\nThe general form of the explicit midpoint method for an ODE $y' = f(t,y)$ is:\n$$\nk_1 = f(t_n, y_n)\n$$\n$$\nk_2 = f(t_n + h/2, y_n + \\frac{h}{2} k_1)\n$$\n$$\ny_{n+1} = y_n + h k_2\n$$\nFor our linear system, where $f(y) = A y$, the steps become:\n$$\nk_1 = A y_n\n$$\n$$\nk_2 = A \\left( y_n + \\frac{h}{2} (A y_n) \\right) = A y_n + \\frac{h}{2} A^2 y_n = \\left( A + \\frac{h}{2} A^2 \\right) y_n\n$$\nSubstituting $k_2$ into the update rule for $y_{n+1}$:\n$$\ny_{n+1} = y_n + h \\left( A + \\frac{h}{2} A^2 \\right) y_n = \\left( I + h A + \\frac{h^2}{2} A^2 \\right) y_n\n$$\nThus, the propagation from one step to the next is governed by the amplification matrix $M_{\\text{mid}} = I + h A + \\frac{h^2}{2} A^2$.\n\n**2. The Modified Euler Method (Heun's Method)**\nThe general form of the modified Euler method, also known as Heun's method or the explicit trapezoidal rule, is:\n$$\nk_1 = f(t_n, y_n)\n$$\n$$\nk_2 = f(t_n + h, y_n + h k_1)\n$$\n$$\ny_{n+1} = y_n + \\frac{h}{2} (k_1 + k_2)\n$$\nFor our linear system, where $f(y) = A y$:\n$$\nk_1 = A y_n\n$$\n$$\nk_2 = A (y_n + h (A y_n)) = A y_n + h A^2 y_n = (A + h A^2) y_n\n$$\nSubstituting $k_1$ and $k_2$ into the update rule for $y_{n+1}$:\n$$\ny_{n+1} = y_n + \\frac{h}{2} \\left( A y_n + (A + h A^2) y_n \\right) = y_n + \\frac{h}{2} (2 A y_n + h A^2 y_n)\n$$\n$$\ny_{n+1} = y_n + h A y_n + \\frac{h^2}{2} A^2 y_n = \\left( I + h A + \\frac{h^2}{2} A^2 \\right) y_n\n$$\nThe amplification matrix for this method is $M_{\\text{mod}} = I + h A + \\frac{h^2}{2} A^2$.\n\n**Conclusion on Method Equivalence**\nFor a linear autonomous ODE system $y' = A y$, the explicit midpoint method and the modified Euler method are mathematically identical. Both methods produce the same sequence of approximations $y_n$ because their amplification matrices are the same:\n$$\nM_{\\text{mid}} = M_{\\text{mod}} = I + h A + \\frac{h^2}{2} A^2\n$$\nThis matrix is the Taylor series expansion of the exact one-step propagator, $\\exp(hA)$, truncated to the $2^{nd}$ order. As a consequence, the global error at the final time $T$ must be identical for both methods, i.e., $E_{\\text{mid}} = E_{\\text{mod}}$.\n\n**Algorithm for Error Computation**\nFor each test case $(\\omega, \\zeta, T, h)$:\n1. Construct the matrix $A$:\n   $$\n   A = \\begin{bmatrix}\n   0 & 1 \\\\\n   -\\omega^2 & -2 \\zeta \\omega\n   \\end{bmatrix}\n   $$\n2.  Define the initial condition $y_0 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$.\n3.  Calculate the number of steps $N = T/h$, which must be an integer per the problem statement.\n4.  Compute the exact solution at $t = T$. The exact solution to the initial value problem is $y(t) = \\exp(At) y_0$. At the final time $T$, this is:\n   $$\n   y_{\\text{exact}} = \\exp(A T) y_0\n   $$\n   The matrix exponential $\\exp(A T)$ will be computed using a high-precision library function.\n5.  Compute the numerical solution at $t = T$. Let $M = I + h A + \\frac{h^2}{2} A^2$ be the amplification matrix. After $N$ steps, the numerical solution is:\n   $$\n   y_{\\text{num}} = M^N y_0\n   $$\n   The matrix power $M^N$ will be computed efficiently.\n6.  Compute the global error. The error is the Euclidean norm of the difference between the numerical and exact solutions:\n   $$\n   E = \\| y_{\\text{num}} - y_{\\text{exact}} \\|_2\n   $$\n7.  Since both methods are identical, we set $E_{\\text{mid}} = E$ and $E_{\\text{mod}} = E$. This procedure is repeated for all five test cases.\n\nThe implementation will use `numpy` for matrix operations and `scipy.linalg.expm` for the matrix exponential.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the global error for two numerical methods on an ODE system\n    representing a damped oscillator.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (omega, zeta, T, h)\n    test_cases = [\n        (5.0, 0.1, 2.0, 0.01),\n        (5.0, 0.1, 1.0, 0.2),\n        (10.0, 0.999, 0.5, 0.005),\n        (40.0, 0.2, 1.0, 0.002),\n        (5.0, 0.1, 2.0, 0.001)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        omega, zeta, T, h = case\n\n        # Construct the system matrix A\n        A = np.array([\n            [0.0, 1.0],\n            [-omega**2, -2.0 * zeta * omega]\n        ])\n\n        # Initial condition\n        y0 = np.array([1.0, 0.0])\n\n        # Number of steps N (guaranteed to be integer)\n        N = int(T / h)\n\n        # 1. Exact solution using matrix exponential\n        # y(T) = exp(A*T) * y0\n        y_exact_T = expm(A * T) @ y0\n\n        # 2. Numerical solution\n        # For a linear autonomous system y' = Ay, both the explicit midpoint\n        # and modified Euler methods use the same amplification matrix:\n        # M = I + hA + (h^2/2)A^2\n        I = np.identity(2)\n        A_squared = A @ A\n        M = I + h * A + (h**2 / 2.0) * A_squared\n\n        # The solution at T is y_N = M^N * y0\n        # np.linalg.matrix_power is efficient for this\n        y_numerical_T = np.linalg.matrix_power(M, N) @ y0\n\n        # 3. Global error calculation\n        # Error is the Euclidean 2-norm of the difference\n        error = np.linalg.norm(y_numerical_T - y_exact_T)\n\n        # Since E_mid and E_mod are identical for this problem, they are both equal to 'error'.\n        E_mid = error\n        E_mod = error\n        \n        all_results.append([E_mid, E_mod])\n\n    # Final print statement in the exact required format.\n    # Example format: [[E_mid^(1),E_mod^(1)],[E_mid^(2),E_mod^(2)],...]\n    formatted_results = []\n    for res_pair in all_results:\n        # The problem states it is acceptable to round to 10 decimal places.\n        formatted_pair_str = f\"[{res_pair[0]:.10f}, {res_pair[1]:.10f}]\"\n        formatted_results.append(formatted_pair_str)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2444104"}, {"introduction": "Having seen their equivalence for linear systems, we now explore how the explicit midpoint and modified Euler methods behave differently in a nonlinear context. This practice tackles the classic Lotka-Volterra predator-prey model, a system which possesses a conserved quantity, meaning its exact solution trajectories are closed loops [@problem_id:2444171]. By tracking this quantity, you will learn to diagnose the qualitative behavior of numerical integrators, observing whether they preserve this geometric structure or introduce an artificial energy drift, causing the solution to spiral inwards or outwards over long-term simulations.", "problem": "Consider the two-dimensional Lotka–Volterra predator–prey system posed as an initial-value problem for an ordinary differential equation (ODE):\n$$\n\\begin{cases}\n\\dfrac{\\mathrm{d}x}{\\mathrm{d}t} = \\alpha x - \\beta x y, \\\\[6pt]\n\\dfrac{\\mathrm{d}y}{\\mathrm{d}t} = -\\gamma y + \\delta x y,\n\\end{cases}\n\\quad\n(x(0),y(0)) = (x_0,y_0),\n$$\nwhere $\\alpha>0$, $\\beta>0$, $\\gamma>0$, $\\delta>0$, and $(x(t),y(t))$ denote the prey and predator populations, respectively. For the continuous system, nontrivial trajectories with positive initial data remain on closed level sets around the unique positive equilibrium\n$$\n(x^\\ast,y^\\ast) = \\left(\\dfrac{\\gamma}{\\delta}, \\dfrac{\\alpha}{\\beta}\\right).\n$$\nDefine the invariant candidate (first integral) for this system as\n$$\nH(x,y) = \\delta x - \\gamma \\ln x + \\beta y - \\alpha \\ln y,\n$$\nwhich is constant along exact solutions for $x>0$, $y>0$. You will approximate the trajectory numerically and diagnose whether the discrete trajectory forms a closed loop or spirals inwards/outwards by inspecting the change in $H$.\n\nYour task is to write a complete program that, for each test case, advances the system using exactly one of the following two distinct two-stage Runge–Kutta (RK) methods: the explicit midpoint method or the modified Euler method (Heun’s method). For a given time step $h>0$ and a positive integer number of nominal oscillation periods $P$, integrate for a total time $T_{\\text{int}}$ defined by\n$$\nT_{\\text{int}} = P \\cdot \\dfrac{2\\pi}{\\sqrt{\\alpha \\gamma}},\n$$\nand use $N = \\left\\lfloor \\dfrac{T_{\\text{int}}}{h} + \\tfrac{1}{2}\\right\\rfloor$ time steps of size $h$ to cover this interval. Let $H_0 = H(x_0,y_0)$ and $H_N = H(x_N,y_N)$ denote the values of $H$ at the start and end of the numerical trajectory.\n\nClassification rule: define the relative drift\n$$\n\\rho = \\dfrac{H_N - H_0}{|H_0|}.\n$$\nWith a tolerance $\\tau = 0.01$ (expressed as a decimal), classify the trajectory as follows for each test case:\n- closed loop if $|\\rho| \\le \\tau$, encoded as the integer $0$,\n- outward spiral if $\\rho > \\tau$, encoded as the integer $1$,\n- inward spiral if $\\rho < -\\tau$, encoded as the integer $-1$.\n\nYour program must implement both methods separately and apply the specified one for each test case.\n\nTest suite: Your program must compute the classifications for the following four test cases. Each case is a tuple of the form $(m,\\alpha,\\beta,\\gamma,\\delta,x_0,y_0,h,P)$, where $m$ selects the method ($m=0$ for the explicit midpoint method and $m=1$ for the modified Euler method).\n- Case $1$: $(0,\\,1,\\,1,\\,1,\\,1,\\,1.2,\\,0.8,\\,0.05,\\,30)$.\n- Case $2$: $(1,\\,1,\\,1,\\,1,\\,1,\\,1.2,\\,0.8,\\,0.05,\\,30)$.\n- Case $3$: $(0,\\,1,\\,1,\\,1,\\,1,\\,1.5,\\,0.6,\\,0.2,\\,30)$.\n- Case $4$: $(1,\\,1,\\,1,\\,1,\\,1.5,\\,0.6,\\,0.2,\\,30)$.\n\nFinal output format: Your program should produce a single line of output containing the integer classifications for the four cases as a comma-separated list enclosed in square brackets, in the order of the cases above. For example, a syntactically valid format is a single line like \"[rA,rB,rC,rD]\" where each of $rA$, $rB$, $rC$, $rD$ is one of $-1$, $0$, or $1$.", "solution": "The problem statement is valid. It is a well-posed initial-value problem from computational engineering, grounded in the established principles of mathematical biology and numerical analysis. All parameters, conditions, and methodologies are clearly and unambiguously defined.\n\nThe problem centers on the numerical integration of the Lotka–Volterra predator–prey model, a system of two coupled, first-order, nonlinear ordinary differential equations (ODEs):\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} = f_x(x,y) = \\alpha x - \\beta x y\n$$\n$$\n\\frac{\\mathrm{d}y}{\\mathrm{d}t} = f_y(x,y) = -\\gamma y + \\delta x y\n$$\nHere, $x(t)$ is the prey population, $y(t)$ is the predator population, and the parameters $\\alpha, \\beta, \\gamma, \\delta$ are positive constants. The initial state of the system is given by $(x(0), y(0)) = (x_0, y_0)$.\n\nA distinguishing feature of the exact continuous system is the existence of a conserved quantity, or first integral, given by:\n$$\nH(x,y) = \\delta x - \\gamma \\ln x + \\beta y - \\alpha \\ln y\n$$\nThe value of $H(x(t), y(t))$ remains constant along any exact solution trajectory where $x>0$ and $y>0$. This implies that the solution trajectories are closed level-set curves of the function $H$ in the $(x,y)$ phase space, representing periodic population cycles.\n\nNumerical methods, being discrete approximations, typically fail to preserve such invariants exactly. The accumulated error causes the numerical trajectory either to spiral outwards (gaining \"energy\" as measured by $H$) or inwards (losing \"energy\"). This phenomenon is termed numerical drift. The sign and magnitude of the change in $H$ over the integration interval provide a quantitative diagnostic of the long-term qualitative behavior of the numerical solution.\n\nThe task requires implementing two distinct second-order Runge–Kutta (RK) methods to advance the solution from an initial state $\\mathbf{u}_n = [x_n, y_n]^T$ to the next state $\\mathbf{u}_{n+1}$ over a time step $h$. The ODE is expressed in vector form as $\\frac{\\mathrm{d}\\mathbf{u}}{\\mathrm{d}t} = \\mathbf{f}(\\mathbf{u})$.\n\nThe first method ($m=0$) is the **explicit midpoint method**. Its formulation is:\n$1$. Calculate the slope at the starting point:\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{u}_n)\n$$\n$2$. Use $\\mathbf{k}_1$ to estimate the state at the midpoint of the time interval, and calculate the slope there:\n$$\n\\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{u}_n + \\frac{h}{2}\\mathbf{k}_1\\right)\n$$\n$3$. Update the state using the midpoint slope $\\mathbf{k}_2$:\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + h \\mathbf{k}_2\n$$\n\nThe second method ($m=1$) is the **modified Euler method** (also known as Heun's method):\n$1$. Calculate the slope at the starting point:\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{u}_n)\n$$\n$2$. Use $\\mathbf{k}_1$ to make a preliminary full step (a predictor step) and calculate the slope at this predicted point:\n$$\n\\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{u}_n + h \\mathbf{k}_1\\right)\n$$\n$3$. Update the state using the average of the initial and predicted slopes (a corrector step):\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\frac{h}{2}(\\mathbf{k}_1 + \\mathbf{k}_2)\n$$\n\nFor each test case, the simulation proceeds as follows:\n$1$. The total integration time, $T_{\\text{int}}$, is determined by $P$ nominal periods of the linearized system, $T_{\\text{int}} = P \\cdot \\frac{2\\pi}{\\sqrt{\\alpha\\gamma}}$.\n$2$. The number of steps, $N$, is calculated by rounding the ratio of total time to step size: $N = \\left\\lfloor \\frac{T_{\\text{int}}}{h} + \\frac{1}{2}\\right\\rfloor$.\n$3$. The initial value of the invariant, $H_0 = H(x_0, y_0)$, is computed.\n$4$. The chosen numerical integrator is applied for $N$ steps to find the final state $(x_N, y_N)$.\n$5$. The final invariant value, $H_N = H(x_N, y_N)$, is computed.\n$6$. The relative drift, $\\rho = \\frac{H_N - H_0}{|H_0|}$, is calculated.\n$7$. The trajectory is classified based on the value of $\\rho$ relative to a tolerance $\\tau = 0.01$:\n    - **Closed loop (code $0$):** If $|\\rho| \\le \\tau$, the drift is considered negligible.\n    - **Outward spiral (code $1$):** If $\\rho > \\tau$, the numerical energy has significantly increased.\n    - **Inward spiral (code $-1$):** If $\\rho < -\\tau$, the numerical energy has significantly decreased.\n\nThe implementation will apply this logic to each of the four specified test cases, with the method selected by the parameter $m$. The final output consists of the integer classification codes for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Lotka-Volterra problem for four test cases, classifies trajectory\n    behavior by analyzing the drift of a system invariant.\n    \"\"\"\n\n    def lotka_volterra_rhs(u, alpha, beta, gamma, delta):\n        \"\"\"\n        Computes the right-hand side of the Lotka-Volterra ODE system.\n        u: state vector [x, y]\n        alpha, beta, gamma, delta: system parameters\n        \"\"\"\n        x, y = u\n        dxdt = alpha * x - beta * x * y\n        dydt = -gamma * y + delta * x * y\n        return np.array([dxdt, dydt])\n\n    def invariant_H(u, alpha, beta, gamma, delta):\n        \"\"\"\n        Computes the invariant (first integral) H of the Lotka-Volterra system.\n        u: state vector [x, y]\n        alpha, beta, gamma, delta: system parameters\n        \"\"\"\n        x, y = u\n        # The problem statement ensures x > 0 and y > 0 for initial conditions.\n        # Trajectories of the LV system do not cross the axes.\n        return delta * x - gamma * np.log(x) + beta * y - alpha * np.log(y)\n\n    def explicit_midpoint_step(u_n, h, f_rhs, params):\n        \"\"\"\n        Performs a single step of the explicit midpoint method.\n        u_n: current state vector\n        h: time step\n        f_rhs: function for the ODE's right-hand side\n        params: tuple of system parameters (alpha, beta, gamma, delta)\n        \"\"\"\n        k1 = f_rhs(u_n, *params)\n        k2 = f_rhs(u_n + 0.5 * h * k1, *params)\n        u_n1 = u_n + h * k2\n        return u_n1\n\n    def modified_euler_step(u_n, h, f_rhs, params):\n        \"\"\"\n        Performs a single step of the modified Euler (Heun's) method.\n        u_n: current state vector\n        h: time step\n        f_rhs: function for the ODE's right-hand side\n        params: tuple of system parameters (alpha, beta, gamma, delta)\n        \"\"\"\n        k1 = f_rhs(u_n, *params)\n        k2 = f_rhs(u_n + h * k1, *params)\n        u_n1 = u_n + 0.5 * h * (k1 + k2)\n        return u_n1\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, alpha, beta, gamma, delta, x0, y0, h, P)\n        # m=0: explicit midpoint, m=1: modified Euler\n        (0, 1.0, 1.0, 1.0, 1.0, 1.2, 0.8, 0.05, 30),\n        (1, 1.0, 1.0, 1.0, 1.0, 1.2, 0.8, 0.05, 30),\n        (0, 1.0, 1.0, 1.0, 1.0, 1.5, 0.6, 0.2, 30),\n        (1, 1.0, 1.0, 1.0, 1.0, 1.5, 0.6, 0.2, 30),\n    ]\n\n    results = []\n    tau = 0.01  # Tolerance for classification\n\n    for case in test_cases:\n        m, alpha, beta, gamma, delta, x0, y0, h, P = case\n        \n        params = (alpha, beta, gamma, delta)\n        \n        # Set initial state vector\n        u_0 = np.array([x0, y0])\n        \n        # Calculate total integration time and number of steps\n        T_int = P * 2 * np.pi / np.sqrt(alpha * gamma)\n        # N = floor(T_int/h + 1/2) as per problem statement\n        N = int(T_int / h + 0.5)\n        \n        # Compute initial value of the invariant\n        H_0 = invariant_H(u_0, alpha, beta, gamma, delta)\n        \n        # Select the numerical method based on m\n        if m == 0:\n            stepper = explicit_midpoint_step\n        else:  # m == 1\n            stepper = modified_euler_step\n            \n        # Perform the numerical integration\n        u_current = u_0\n        for _ in range(N):\n            u_current = stepper(u_current, h, lotka_volterra_rhs, params)\n        u_N = u_current\n        \n        # Compute final value of the invariant\n        H_N = invariant_H(u_N, alpha, beta, gamma, delta)\n        \n        # Calculate the relative drift\n        rho = (H_N - H_0) / np.abs(H_0)\n        \n        # Classify the trajectory based on the drift\n        if np.abs(rho) <= tau:\n            classification = 0\n        elif rho > tau:\n            classification = 1\n        else:  # rho < -tau\n            classification = -1\n            \n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2444171"}, {"introduction": "This final practice challenges you to apply your skills to a classic problem in dynamics: calculating the period of a large-amplitude nonlinear pendulum. The problem requires you to first convert the second-order governing equation into a system of two first-order ODEs, a crucial skill in computational physics and engineering. You will then implement the numerical methods to simulate the pendulum's motion and perform data analysis on the resulting time series to extract the oscillation period, comparing your findings against the exact analytical solution [@problem_id:2444127].", "problem": "Consider the nonlinear ordinary differential equation (ODE) initial value problem for a simple plane pendulum of length $L$ under uniform gravity $g$:\n$$\n\\theta''(t) \\;=\\; -\\frac{g}{L}\\,\\sin\\big(\\theta(t)\\big), \\quad \\theta(0) \\;=\\; \\theta_0,\\quad \\theta'(0) \\;=\\; 0,\n$$\nwhere $\\theta(t)$ is the angular displacement measured in radians. Introduce the state vector $\\mathbf{y}(t) = \\begin{bmatrix}\\theta(t) \\\\ \\omega(t)\\end{bmatrix}$ with $\\omega(t) = \\theta'(t)$ and rewrite the second-order ODE as a first-order system\n$$\n\\mathbf{y}'(t) \\;=\\; \\mathbf{f}(t,\\mathbf{y}) \\;=\\; \\begin{bmatrix}\\omega \\\\[4pt] -\\dfrac{g}{L}\\sin(\\theta) \\end{bmatrix}.\n$$\nYour task is to implement two second-order, explicit, two-stage Runge–Kutta (RK) methods—the explicit midpoint method and the modified Euler method (also known as Heun's method)—to approximate the full oscillation period for large-amplitude swings, and to compare the computed period against the theoretical value.\n\nFundamental bases you may assume as given are: the definition of an initial value problem for an ODE, the concept of a one-step method derived from Taylor expansion matching up to second order, and the known theoretical period for the nonlinear pendulum expressed using the complete elliptic integral of the first kind. Specifically, the theoretical period for amplitude $\\theta_0$ is\n$$\nT_{\\mathrm{th}}(\\theta_0;L,g) \\;=\\; 4\\sqrt{\\frac{L}{g}}\\,K\\!\\Big(m\\Big),\\quad m \\;=\\; \\sin^2\\!\\Big(\\frac{\\theta_0}{2}\\Big),\n$$\nwhere the complete elliptic integral of the first kind is\n$$\nK(m) \\;=\\; \\int_{0}^{\\pi/2} \\frac{1}{\\sqrt{1 - m\\sin^2\\phi}}\\; d\\phi.\n$$\n\nAlgorithmic task:\n- Implement both the explicit midpoint method and the modified Euler method for the first-order system $\\mathbf{y}'=\\mathbf{f}(t,\\mathbf{y})$.\n- For each method, given $(\\theta_0,L,g)$ and a fixed time step $h$, numerically integrate forward in time from $t=0$ until you can robustly estimate the period $T_{\\mathrm{num}}$ of the oscillation that starts from rest at $\\theta(0)=\\theta_0$. Use the following robust rule: detect the first two zero crossings of $\\omega(t)$ after $t>0$ (that is, times where $\\omega$ changes sign), linearly interpolate in time within the step to estimate those crossing times $t_1$ and $t_2$, and then estimate the full period as\n$$\nT_{\\mathrm{num}} \\;=\\; 2\\,(t_2 - t_1).\n$$\n- For each method, compute the absolute relative error\n$$\n\\varepsilon \\;=\\; \\frac{\\left|T_{\\mathrm{num}} - T_{\\mathrm{th}}\\right|}{T_{\\mathrm{th}}}\n$$\nas a dimensionless decimal.\n\nAngles must be in radians, lengths in meters, gravity in meters per second squared, and time in seconds. All outputs must be reported as decimal numbers. There are no percentage signs; if you wish to express something akin to a percentage, report it as a decimal fraction.\n\nTest suite:\nUse the following $5$ parameter sets $(\\theta_0,h,L,g)$, which are chosen to probe typical and challenging regimes, including large amplitudes and coarser time steps:\n- Case $1$: $(\\theta_0,h,L,g) = (1.2,\\; 0.01,\\; 1.0,\\; 9.81)$.\n- Case $2$: $(\\theta_0,h,L,g) = (2.8,\\; 0.01,\\; 1.0,\\; 9.81)$.\n- Case $3$: $(\\theta_0,h,L,g) = (2.8,\\; 0.05,\\; 1.0,\\; 9.81)$.\n- Case $4$: $(\\theta_0,h,L,g) = (0.1,\\; 0.02,\\; 1.0,\\; 9.81)$.\n- Case $5$: $(\\theta_0,h,L,g) = (3.0,\\; 0.005,\\; 1.0,\\; 9.81)$.\n\nFor each case, you must compute two numbers: the absolute relative error for the explicit midpoint method and the absolute relative error for the modified Euler method, each rounded to $8$ decimal places.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of $5$ bracketed pairs, each pair ordered as $[\\varepsilon_{\\text{midpoint}},\\varepsilon_{\\text{modified\\_Euler}}]$, all enclosed in square brackets. For example, a syntactically correct output with placeholder numbers would look like\n$$\n[[0.00000000,0.00000000],[0.00000000,0.00000000],[0.00000000,0.00000000],[0.00000000,0.00000000],[0.00000000,0.00000000]].\n$$\nYour program must follow the specified test suite exactly and print only this single line. No user input is allowed. The code must be complete and runnable as provided.", "solution": "The problem as stated is subjected to validation.\n\n**Step 1: Extract Givens**\n\nThe problem provides the following information:\n- The governing second-order ordinary differential equation (ODE) for a simple plane pendulum:\n$$\n\\theta''(t) \\;=\\; -\\frac{g}{L}\\,\\sin\\big(\\theta(t)\\big)\n$$\n- The initial conditions:\n$$\n\\theta(0) \\;=\\; \\theta_0,\\quad \\theta'(0) \\;=\\; 0\n$$\n- The state vector definition $\\mathbf{y}(t) = \\begin{bmatrix}\\theta(t) \\\\ \\omega(t)\\end{bmatrix}$ where $\\omega(t) = \\theta'(t)$.\n- The equivalent first-order ODE system:\n$$\n\\mathbf{y}'(t) \\;=\\; \\mathbf{f}(t,\\mathbf{y}) \\;=\\; \\begin{bmatrix}\\omega \\\\ -\\dfrac{g}{L}\\sin(\\theta) \\end{bmatrix}\n$$\n- The theoretical period $T_{\\mathrm{th}}$ for amplitude $\\theta_0$:\n$$\nT_{\\mathrm{th}}(\\theta_0;L,g) \\;=\\; 4\\sqrt{\\frac{L}{g}}\\,K\\!\\Big(m\\Big),\\quad m \\;=\\; \\sin^2\\!\\Big(\\frac{\\theta_0}{2}\\Big)\n$$\n- The definition of the complete elliptic integral of the first kind:\n$$\nK(m) \\;=\\; \\int_{0}^{\\pi/2} \\frac{1}{\\sqrt{1 - m\\sin^2\\phi}}\\; d\\phi\n$$\n- The numerical task involves two specific second-order Runge-Kutta methods: the explicit midpoint method and the modified Euler (Heun's) method.\n- A rule for numerically estimating the period $T_{\\mathrm{num}}$: find the first two zero crossings of $\\omega(t)$ for $t > 0$, denoted $t_1$ and $t_2$, via linear interpolation, and compute $T_{\\mathrm{num}} = 2(t_2 - t_1)$.\n- The definition of the absolute relative error:\n$$\n\\varepsilon \\;=\\; \\frac{\\left|T_{\\mathrm{num}} - T_{\\mathrm{th}}\\right|}{T_{\\mathrm{th}}}\n$$\n- Five test cases are provided as tuples of $(\\theta_0, h, L, g)$:\n1. $(1.2, 0.01, 1.0, 9.81)$\n2. $(2.8, 0.01, 1.0, 9.81)$\n3. $(2.8, 0.05, 1.0, 9.81)$\n4. $(0.1, 0.02, 1.0, 9.81)$\n5. $(3.0, 0.005, 1.0, 9.81)$\n- The required output format is a specific string representation of a list of pairs of errors.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is evaluated against the validation criteria.\n- **Scientifically Grounded**: The problem is founded on the principles of classical mechanics (the simple pendulum) and numerical analysis (Runge-Kutta methods). The governing equation, its first-order representation, and the analytical formula for the period are all standard and correct results in physics and mathematics.\n- **Well-Posed**: The problem is a well-posed initial value problem. The function $\\mathbf{f}(t, \\mathbf{y})$ is continuously differentiable, which guarantees the existence and uniqueness of a solution. The task of computing the numerical period and its error is clearly defined and leads to a unique result for a given method and step size.\n- **Objective**: The problem is stated in precise, formal, and objective mathematical language.\n- **Flaw Analysis**:\n    1.  **Scientific or Factual Unsoundness**: None. The physics and mathematics are sound.\n    2.  **Non-Formalizable or Irrelevant**: None. The problem is a direct and concrete application of numerical methods in computational engineering.\n    3.  **Incomplete or Contradictory Setup**: None. All necessary components are provided: the model, the methods, the analysis procedure, and the test data.\n    4.  **Unrealistic or Infeasible**: None. The physical parameters and initial conditions are realistic. The initial amplitudes, while large, are physically attainable (less than the unstable equilibrium at $\\theta = \\pi$).\n    5.  **Ill-Posed or Poorly Structured**: None. The instructions are unambiguous. The method for determining the numerical period is robust.\n    6.  **Outside Scientific Verifiability**: None. The results are computationally verifiable.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A full solution is warranted.\n\nThe core of the problem is to solve the initial value problem for the first-order system $\\mathbf{y}' = \\mathbf{f}(t, \\mathbf{y})$ using two different numerical schemes. The state vector is $\\mathbf{y} = [\\theta, \\omega]^T$. A generic one-step method advances the solution from time $t_n$ to $t_{n+1} = t_n + h$ as $\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\Phi(t_n, \\mathbf{y}_n, h; \\mathbf{f})$, where $\\Phi$ is the increment function.\n\nFirst, we define the two required second-order, two-stage Runge-Kutta methods.\n\n1.  **Explicit Midpoint Method**: The increment is calculated by evaluating the derivative at the midpoint of the time interval, using a forward Euler step to estimate the state at that midpoint.\n    The update rule is:\n    $$\n    \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n)\n    $$\n    $$\n    \\mathbf{k}_2 = \\mathbf{f}\\left(t_n + \\frac{h}{2}, \\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_1\\right)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + h\\mathbf{k}_2\n    $$\n\n2.  **Modified Euler Method (Heun's Method)**: This is a predictor-corrector method. An initial prediction for $\\mathbf{y}_{n+1}$ is made using forward Euler (the predictor), and this prediction is used to estimate the slope at the end of the interval. The final update averages the slopes at the beginning and end of the interval (the corrector).\n    The update rule is:\n    $$\n    \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n)\n    $$\n    $$\n    \\mathbf{k}_2 = \\mathbf{f}(t_n + h, \\mathbf{y}_n + h\\mathbf{k}_1)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{2}(\\mathbf{k}_1 + \\mathbf{k}_2)\n    $$\n\nTo evaluate the accuracy of these methods, we must compare the numerically computed oscillation period, $T_{\\mathrm{num}}$, with the theoretical period, $T_{\\mathrm{th}}$.\n\nThe theoretical period, $T_{\\mathrm{th}}$, is given by the formula involving the complete elliptic integral of the first kind, $K(m)$:\n$$\nT_{\\mathrm{th}} = 4\\sqrt{\\frac{L}{g}}\\,K(m), \\quad \\text{where} \\quad m = \\sin^2\\left(\\frac{\\theta_0}{2}\\right)\n$$\nThis integral must be computed numerically, for which standard library functions are available.\n\nThe numerical period, $T_{\\mathrm{num}}$, is determined by tracking the angular velocity $\\omega(t)$. The pendulum starts from rest at its maximum displacement, so $\\omega(0) = 0$. The first time $\\omega(t)$ returns to zero for $t > 0$ is at the opposite turning point, corresponding to half a period ($t_1 \\approx T/2$). The second time it returns to zero is at the completion of a full cycle ($t_2 \\approx T$). The problem specifies the robust estimation formula $T_{\\mathrm{num}} = 2(t_2 - t_1)$, which correctly evaluates to $T$ if $t_1=T/2$ and $t_2=T$.\nTo find the zero-crossing times $t_1$ and $t_2$, we iterate the numerical method and monitor the sign of the angular velocity component, $\\omega_n$. A zero crossing occurs between time steps $t_n$ and $t_{n+1}$ if $\\omega_n \\cdot \\omega_{n+1} < 0$. The precise crossing time $t_{\\text{cross}}$ is then estimated using linear interpolation between the points $(t_n, \\omega_n)$ and $(t_{n+1}, \\omega_{n+1})$:\n$$\nt_{\\text{cross}} = t_n - \\omega_n \\frac{t_{n+1} - t_n}{\\omega_{n+1} - \\omega_n} = t_n - \\omega_n \\frac{h}{\\omega_{n+1}-\\omega_n}\n$$\nThe first two such crossing times found for $t > 0$ will be $t_1$ and $t_2$.\n\nFinally, for each method and each test case, the absolute relative error $\\varepsilon$ is computed as:\n$$\n\\varepsilon = \\frac{|T_{\\mathrm{num}} - T_{\\mathrm{th}}|}{T_{\\mathrm{th}}}\n$$\n\nThe overall algorithm for each test case $(\\theta_0, h, L, g)$ is as follows:\n1.  Calculate $T_{\\mathrm{th}}$ using the provided formula and a high-precision value for the elliptic integral.\n2.  For each numerical method (explicit midpoint and modified Euler):\n    a. Initialize the state $\\mathbf{y}_0 = [\\theta_0, 0]^T$, time $t_0 = 0$, and an empty list for zero-crossing times.\n    b. Repeatedly apply the method's update rule to step forward in time, $\\mathbf{y}_{n+1} = \\text{step}(\\mathbf{y}_n)$.\n    c. At each step, check for a zero crossing of $\\omega(t)$. If a crossing is detected between $t_n$ and $t_{n+1}$, compute $t_{\\text{cross}}$ using linear interpolation and record it.\n    d. Continue until two crossing times, $t_1$ and $t_2$, have been recorded.\n    e. Compute $T_{\\mathrm{num}} = 2(t_2 - t_1)$.\n    f. Compute the error $\\varepsilon$.\n3.  Store the pair of errors $[\\varepsilon_{\\text{midpoint}}, \\varepsilon_{\\text{modified\\_Euler}}]$ for the test case.\n4.  After all test cases are processed, format the results into the specified string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import ellipk\n\ndef solve():\n    \"\"\"\n    Solves the pendulum problem for the given test suite, calculating the\n    relative error in the period for two numerical methods.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (theta0, h, L, g)\n        (1.2, 0.01, 1.0, 9.81),\n        (2.8, 0.01, 1.0, 9.81),\n        (2.8, 0.05, 1.0, 9.81),\n        (0.1, 0.02, 1.0, 9.81),\n        (3.0, 0.005, 1.0, 9.81),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        theta0, h, L, g = case\n        \n        # --- Define the ODE system ---\n        def f_ode(t, y, g_val, L_val):\n            \"\"\"\n            Represents the first-order system y' = f(t, y).\n            y = [theta, omega]\n            y' = [omega, -g/L * sin(theta)]\n            \"\"\"\n            theta, omega = y\n            return np.array([omega, -(g_val / L_val) * np.sin(theta)])\n\n        # --- Define the numerical methods ---\n        def explicit_midpoint_step(f, t, y, h_step, g_val, L_val):\n            k1 = f(t, y, g_val, L_val)\n            k2 = f(t + h_step / 2.0, y + (h_step / 2.0) * k1, g_val, L_val)\n            y_next = y + h_step * k2\n            return y_next\n\n        def modified_euler_step(f, t, y, h_step, g_val, L_val):\n            k1 = f(t, y, g_val, L_val)\n            k2 = f(t + h_step, y + h_step * k1, g_val, L_val)\n            y_next = y + (h_step / 2.0) * (k1 + k2)\n            return y_next\n            \n        # --- Function to compute numerical period ---\n        def compute_numerical_period(step_func, y0_val, h_step, g_val, L_val):\n            t = 0.0\n            y = np.copy(y0_val)\n            \n            crossing_times = []\n            max_steps = int(2.0 * (4 * np.sqrt(L_val/g_val) * 10) / h_step) # Generous max steps\n\n            # We need to find the first two zero crossings of omega for t > 0\n            for i in range(max_steps):\n                y_prev = np.copy(y)\n                t_prev = t\n                \n                y = step_func(f_ode, t, y, h_step, g_val, L_val)\n                t = t + h_step\n\n                omega_prev = y_prev[1]\n                omega_curr = y[1]\n\n                # Check for sign change in omega; omega(0)=0 so let's start checking after first step\n                if omega_prev * omega_curr < 0.0:\n                    # Linear interpolation to find the zero-crossing time\n                    t_cross = t_prev - omega_prev * h_step / (omega_curr - omega_prev)\n                    crossing_times.append(t_cross)\n                    \n                    if len(crossing_times) == 2:\n                        break\n            \n            if len(crossing_times) < 2:\n                # Should not happen with well-chosen max_steps\n                return -1.0 \n            \n            t1, t2 = crossing_times\n            T_num = 2.0 * (t2 - t1)\n            return T_num\n\n        # --- Function to compute theoretical period ---\n        def compute_theoretical_period(theta0_val, L_val, g_val):\n            m = np.sin(theta0_val / 2.0)**2\n            K_m = ellipk(m)\n            T_th = 4.0 * np.sqrt(L_val / g_val) * K_m\n            return T_th\n\n        # --- Main calculation for the case ---\n        case_results = []\n        y0 = np.array([theta0, 0.0])\n        T_th = compute_theoretical_period(theta0, L, g)\n        \n        methods = [explicit_midpoint_step, modified_euler_step]\n        \n        for method in methods:\n            T_num = compute_numerical_period(method, y0, h, g, L)\n            rel_error = np.abs(T_num - T_th) / T_th\n            case_results.append(f\"{rel_error:.8f}\")\n\n        all_results.append(f\"[{','.join(case_results)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2444127"}]}