{"hands_on_practices": [{"introduction": "Before we can improve upon a method, we must first understand its limitations. The primary drawback of the explicit Euler method is its first-order accuracy, which originates from its local truncation error. This thought experiment [@problem_id:2402543] provides a unique opportunity to dissect this error by finding a special condition where different error terms cancel, a phenomenon known as super-convergence. By deriving the step size that achieves this, you will gain a deeper, foundational understanding of how Taylor series govern the accuracy of numerical integrators.", "problem": "In computational engineering, a common improvement to the explicit Euler method for solving an ordinary differential equation (ODE) is to exploit problem structure to achieve higher accuracy on a single step through cancellation of leading error terms. Consider the scalar ordinary differential equation (ODE)\n$$\n\\frac{dy}{dt} = \\alpha t^{2} + \\beta t + \\gamma,\n$$\nwhere $\\alpha$, $\\beta$, and $\\gamma$ are real constants with $\\alpha \\neq 0$, and let the initial time be $t_{0}$ with initial value $y(t_{0}) = y_{0}$. You will take a single explicit Euler step from $t_{0}$ to $t_{0} + h$.\n\nStarting from first principles of Taylor expansion for the exact solution and the definition of the explicit Euler update, derive a nonzero step size $h$ (as a symbolic algebraic expression in $\\alpha$, $\\beta$, and $t_{0}$) for which the second-order local truncation error term is canceled by the third-order term, thereby achieving super-convergence for this single step. In this specific ODE, this cancellation makes the Euler step exact for that $h$. Provide your final $h$ in closed form. No rounding is required. Express your answer without units.", "solution": "The problem as stated is subjected to validation and is found to be scientifically grounded, well-posed, and objective. It is a standard problem in numerical analysis concerning the local truncation error of the explicit Euler method. We may therefore proceed with a rigorous derivation.\n\nThe core of the problem lies in the analysis of the local truncation error (LTE) for a single step of the explicit Euler method. The LTE is defined as the difference between the exact solution at the next time step and the value produced by the numerical method, assuming the method starts with the exact value at the current time step.\n\nLet the exact solution at time $t$ be $y(t)$. The given ordinary differential equation is:\n$$\n\\frac{dy}{dt} = y'(t) = \\alpha t^{2} + \\beta t + \\gamma\n$$\nThe initial condition is $y(t_{0}) = y_{0}$.\n\nA single step of the explicit Euler method approximates the solution $y(t_0 + h)$ with a new value $y_1$ given by:\n$$\ny_{1} = y_{0} + h \\cdot f(t_{0}, y_{0}) = y(t_{0}) + h \\cdot y'(t_{0})\n$$\nThe exact solution at time $t_{0} + h$ can be expressed using a Taylor series expansion around $t_{0}$:\n$$\ny(t_{0} + h) = y(t_{0}) + h y'(t_{0}) + \\frac{h^{2}}{2!} y''(t_{0}) + \\frac{h^{3}}{3!} y'''(t_{0}) + \\frac{h^{4}}{4!} y^{(4)}(t_{0}) + \\dots\n$$\nThe local truncation error, $T_{1}$, for this single step is the difference $y(t_{0} + h) - y_{1}$:\n$$\nT_{1} = \\left( y(t_{0}) + h y'(t_{0}) + \\frac{h^{2}}{2} y''(t_{0}) + \\frac{h^{3}}{6} y'''(t_{0}) + \\dots \\right) - \\left( y(t_{0}) + h y'(t_{0}) \\right)\n$$\n$$\nT_{1} = \\frac{h^{2}}{2} y''(t_{0}) + \\frac{h^{3}}{6} y'''(t_{0}) + \\frac{h^{4}}{24} y^{(4)}(t_{0}) + \\dots\n$$\nThe terms in this series are the error terms of increasing order in $h$. The problem specifies a particular ODE for which we must compute these terms. We find the necessary derivatives of $y(t)$ from the ODE itself:\n$$\ny'(t) = \\alpha t^{2} + \\beta t + \\gamma\n$$\n$$\ny''(t) = \\frac{d}{dt} (\\alpha t^{2} + \\beta t + \\gamma) = 2\\alpha t + \\beta\n$$\n$$\ny'''(t) = \\frac{d}{dt} (2\\alpha t + \\beta) = 2\\alpha\n$$\n$$\ny^{(4)}(t) = \\frac{d}{dt} (2\\alpha) = 0\n$$\nSince the fourth derivative and all higher derivatives are zero, the Taylor series for $y(t_{0}+h)$ is finite and terminates after the third-order term. Consequently, the local truncation error is given exactly by the sum of the second and third-order terms:\n$$\nT_{1} = \\frac{h^{2}}{2} y''(t_{0}) + \\frac{h^{3}}{6} y'''(t_{0})\n$$\nThe problem requires finding a nonzero step size $h$ for which the second-order error term, $\\frac{h^{2}}{2} y''(t_{0})$, is canceled by the third-order term, $\\frac{h^{3}}{6} y'''(t_{0})$. This condition mathematically translates to their sum being zero. As this sum constitutes the entire error for this specific ODE, setting it to zero means the Euler step becomes exact.\n$$\n\\frac{h^{2}}{2} y''(t_{0}) + \\frac{h^{3}}{6} y'''(t_{0}) = 0\n$$\nSubstitute the expressions for the derivatives evaluated at $t_{0}$:\n$$\ny''(t_{0}) = 2\\alpha t_{0} + \\beta\n$$\n$$\ny'''(t_{0}) = 2\\alpha\n$$\nThe equation becomes:\n$$\n\\frac{h^{2}}{2} (2\\alpha t_{0} + \\beta) + \\frac{h^{3}}{6} (2\\alpha) = 0\n$$\n$$\nh^{2} \\left[ \\frac{1}{2}(2\\alpha t_{0} + \\beta) + \\frac{\\alpha h}{3} \\right] = 0\n$$\nThis equation has two solutions for $h$. One is the trivial solution $h=0$. The problem explicitly requests a nonzero step size. Therefore, we solve for the non-trivial solution by setting the expression in the brackets to zero:\n$$\n\\frac{1}{2}(2\\alpha t_{0} + \\beta) + \\frac{\\alpha h}{3} = 0\n$$\nNow, we solve for $h$:\n$$\n\\frac{\\alpha h}{3} = -\\frac{1}{2}(2\\alpha t_{0} + \\beta)\n$$\nSince it is given that $\\alpha \\neq 0$, we can divide by $\\alpha$:\n$$\n\\frac{h}{3} = -\\frac{1}{2\\alpha}(2\\alpha t_{0} + \\beta)\n$$\n$$\nh = -\\frac{3}{2\\alpha}(2\\alpha t_{0} + \\beta)\n$$\nThis solution for $h$ is guaranteed to be non-zero provided that $2\\alpha t_0 + \\beta \\neq 0$, which means $y''(t_0) \\neq 0$. If $y''(t_0)$ were zero, the second-order error term would be absent, and the problem of cancellation as stated would be ill-defined. Thus, the derived expression is the general non-trivial solution. The expression can be simplified as:\n$$\nh = -\\frac{6\\alpha t_{0} + 3\\beta}{2\\alpha} = -3 t_{0} - \\frac{3\\beta}{2\\alpha}\n$$\nHowever, the factored form is equally correct and compact. We present the final answer in that form.", "answer": "$$\n\\boxed{-\\frac{3(2\\alpha t_{0} + \\beta)}{2\\alpha}}\n$$", "id": "2402543"}, {"introduction": "Understanding the leading error term of the Euler method, as explored previously, naturally leads to a powerful idea: what if we could estimate this error and subtract it? This exercise [@problem_id:2402452] guides you through implementing a \"deferred correction\" scheme, a two-stage process that does exactly that. You will first compute a rough solution with the standard Euler method and then use it to approximate the correction term needed to achieve higher accuracy, providing a hands-on look at how to systematically improve numerical solutions.", "problem": "You are asked to formalize and implement a deferred-correction improvement of the Forward Euler method for initial value problems of ordinary differential equations. Consider problems of the form $y'(t)=f(t,y(t))$ on a uniform grid $t_n=t_0+n h$, $n=0,1,\\dots,N$, where $h=(T-t_0)/N$, with an initial condition $y(t_0)=y_0$. Define a preliminary Forward Euler approximation $y_n^{E}$ by $y_{n+1}^{E}=y_n^{E}+h\\,f(t_n,y_n^{E})$ with $y_0^{E}=y_0$. Using this completed Euler run, define an approximation of the leading error term $y''(t_n)$ by the difference quotient\n$$\n\\widehat{y''}(t_n) \\coloneqq \\frac{ f(t_{n+1},\\,y_{n+1}^{E}) - f(t_n,\\,y_n^{E}) }{h}.\n$$\nThen re-solve a corrected problem by a one-step method that incorporates this estimate so that the corrected numerical solution $y_n^{C}$ is defined by\n$$\ny_{n+1}^{C} \\coloneqq y_n^{C} + h\\,f(t_n,y_n^{C}) + \\frac{h^2}{2}\\,\\widehat{y''}(t_n), \\quad y_0^{C}=y_0.\n$$\nFor each test case below, compute the absolute error at the final time $T$ for both the Forward Euler solution and the corrected solution, and compute the error ratio defined as the Forward Euler error divided by the corrected error.\n\nIn addition, for the specified observed-order tests, compute the observed global order $p$ of the corrected method from two step sizes $h_1$ and $h_2=h_1/2$ via\n$$\np \\coloneqq \\frac{\\log\\!\\big(e(h_1)/e(h_2)\\big)}{\\log(2)},\n$$\nwhere $e(h)$ is the absolute error at the final time $T$ obtained by the corrected method with step size $h$.\n\nAll answers must be expressed as dimensionless real numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each number must be printed in decimal scientific notation rounded to six significant digits, for example `[1.234560e-03, 2.500000e+00]`.\n\nTest suite and required outputs:\n\n- Test case $1$ (happy path, linear autonomous): $y'(t)=\\lambda y(t)$ with $\\lambda=-3$, $t_0=0$, $T=1$, $y_0=1$, $h=0.1$. Exact value at $T$ is $y(T)=\\exp(\\lambda T)$. Output three numbers: the Forward Euler absolute error, the corrected absolute error, and their ratio.\n\n- Test case $2$ (boundary/edge: single step): $y'(t)=\\lambda y(t)$ with $\\lambda=-1$, $t_0=0$, $T=1$, $y_0=1$, $h=1$. Exact value at $T$ is $y(T)=\\exp(\\lambda T)$. Output three numbers as in Test case $1$.\n\n- Test case $3$ (nonlinear autonomous): $y'(t)=-y(t)^3$, $t_0=0$, $T=1$, $y_0=1$, $h=0.1$. Exact value at $T$ is $y(T)=1/\\sqrt{1+2T}$. Output three numbers as in Test case $1$.\n\n- Test case $4$ (time-dependent linear): $y'(t)=t - y(t)$, $t_0=0$, $T=1$, $y_0=0$, $h=0.1$. Exact value at $T$ is $y(T)=T-1+\\exp(-T)$. Output three numbers as in Test case $1$.\n\n- Test case $5$ (observed order on linear autonomous): For $y'(t)=\\lambda y(t)$ with $\\lambda=-3$, $t_0=0$, $T=1$, $y_0=1$, compute the corrected-method absolute error at $T$ for $h_1=0.2$ and $h_2=0.1$, and then compute $p$ by the formula above. Output one number: the observed order $p$.\n\n- Test case $6$ (observed order on nonlinear autonomous): For $y'(t)=-y(t)^3$, $t_0=0$, $T=1$, $y_0=1$, compute the corrected-method absolute error at $T$ for $h_1=0.2$ and $h_2=0.1$, and then compute $p$ by the formula above. Output one number: the observed order $p$.\n\nFinal output format: Your program must print a single line in the form\n$[r_1,r_2,\\dots,r_{14}]$\nwhere the entries, in order, are the three numbers for Test case $1$, the three numbers for Test case $2$, the three numbers for Test case $3$, the three numbers for Test case $4$, followed by the single number for Test case $5$ and the single number for Test case $6$, each rendered in decimal scientific notation with six significant digits as specified above.", "solution": "The problem presented is valid and formalizes a deferred-correction technique for improving the Forward Euler method for solving initial value problems of the form $y'(t)=f(t,y(t))$ with an initial condition $y(t_0)=y_0$. The method is scientifically sound, well-posed, and all terms and procedures are defined unambiguously. It constitutes a standard problem in the field of numerical analysis for ordinary differential equations. We proceed with the solution.\n\nThe fundamental principle behind this method is the correction of the leading term in the local truncation error of the Forward Euler method. The Taylor series expansion of the exact solution $y(t)$ around $t_n$ is given by\n$$\ny(t_{n+1}) = y(t_n) + h y'(t_n) + \\frac{h^2}{2} y''(t_n) + O(h^3),\n$$\nwhere $h$ is the step size and $y'(t) = f(t, y(t))$. The Forward Euler method, $y_{n+1} = y_n + h f(t_n, y_n)$, approximates this expansion by retaining only the terms up to first order in $h$. The local truncation error is therefore $y(t_{n+1}) - (y(t_n) + h f(t_n, y(t_n))) = \\frac{h^2}{2} y''(t_n) + O(h^3)$, which leads to a global error of order $O(h)$.\n\nTo improve the accuracy, one can attempt to estimate and include the second-order term, $\\frac{h^2}{2} y''(t_n)$. This defines an idealized second-order method. The challenge is that $y''(t_n)$ is generally unknown. The proposed deferred-correction scheme addresses this by using a two-stage process.\n\nFirst, a preliminary, complete solution trajectory, denoted by $y_n^E$, is computed using the standard Forward Euler method over the entire interval $[t_0, T]$:\n$$\ny_{n+1}^E = y_n^E + h f(t_n, y_n^E), \\quad y_0^E = y_0.\n$$\nAlthough this solution is only first-order accurate, with a global error of $O(h)$, it provides an approximation of the solution at all grid points $t_n$.\n\nSecond, this preliminary solution is used to estimate the second derivative of the true solution, $y''(t_n)$. The definition of the second derivative is $y''(t) = \\frac{d}{dt} y'(t) = \\frac{d}{dt} f(t, y(t))$. A first-order finite difference approximation to this derivative at time $t_n$ is $\\frac{f(t_{n+1}, y(t_{n+1})) - f(t_n, y(t_n))}{h}$. The method approximates this by substituting the values from the preliminary Euler run, $y_n^E$ and $y_{n+1}^E$, for the true solution values $y(t_n)$ and $y(t_{n+1})$:\n$$\n\\widehat{y''}(t_n) \\coloneqq \\frac{f(t_{n+1}, y_{n+1}^E) - f(t_n, y_n^E)}{h}.\n$$\nThis calculation is performed for all necessary steps, i.e., for $n=0, 1, \\dots, N-1$. Since $y_n^E = y(t_n) + O(h)$, it can be shown that this approximation is first-order accurate, $\\widehat{y''}(t_n) = y''(t_n) + O(h)$.\n\nFinally, a new, corrected solution $y_n^C$ is computed. The integration scheme is modified to include the estimated error term. This results in a new one-step method where the correction term is pre-computed and acts as a forcing function:\n$$\ny_{n+1}^C = y_n^C + h f(t_n, y_n^C) + \\frac{h^2}{2} \\widehat{y''}(t_n), \\quad y_0^C = y_0.\n$$\nThe local truncation error of this corrected method is $O(h^3)$, because the $O(h^2)$ term from the Taylor expansion is approximately cancelled by the correction term: $\\frac{h^2}{2} y''(t_n) - \\frac{h^2}{2} \\widehat{y''}(t_n) = \\frac{h^2}{2} (y''(t_n) - (y''(t_n) + O(h))) = O(h^3)$. A method with local truncation error of order $O(h^{p+1})$ generally has a global error of order $O(h^p)$. Thus, we expect this corrected method to be second-order accurate, with a global error of $O(h^2)$. This hypothesis is tested in the specified observed-order calculations.\n\nThe algorithm is implemented as a general solver function that accepts the differential equation $f$, initial and final times $t_0$ and $T$, initial value $y_0$, and step size $h$. This function first performs the Euler run, then computes the array of $\\widehat{y''}(t_n)$ values, and finally performs the corrected integration. This solver is then applied to each of the six test cases defined in the problem statement. The requested quantities—absolute errors for the Euler and corrected methods, their ratio, and the observed order of convergence—are calculated and collected for the final output. The number of steps $N$ is taken to be $(T-t_0)/h$, and for all test cases this ratio is an integer as required for a uniform grid. The exact solutions provided are used to compute the errors at the final time $T$. The observed order of convergence, $p$, is computed using the formula $p = \\log(e(h_1)/e(h_2)) / \\log(2)$, which directly follows from the assumption that the error $e(h)$ behaves as $e(h) \\approx C h^p$ for some constant $C$.", "answer": "```python\nimport numpy as np\n\ndef deferred_correction_solver(f, t0, T, y0, h):\n    \"\"\"\n    Solves an ODE y'(t) = f(t, y) using Forward Euler and a deferred correction method.\n\n    Args:\n        f (callable): The function f(t, y).\n        t0 (float): Initial time.\n        T (float): Final time.\n        y0 (float): Initial value y(t0).\n        h (float): Step size.\n\n    Returns:\n        tuple: A tuple containing:\n            - y_euler_final (float): The final value from the Forward Euler method.\n            - y_corrected_final (float): The final value from the corrected method.\n    \"\"\"\n    if not np.isclose((T - t0) / h, round((T - t0) / h)):\n        raise ValueError(\"T-t0 must be an integer multiple of h\")\n    N = int(round((T - t0) / h))\n    t_grid = np.linspace(t0, T, N + 1)\n\n    # Stage 1: Compute preliminary solution using Forward Euler\n    yE = np.zeros(N + 1)\n    yE[0] = y0\n    for n in range(N):\n        yE[n + 1] = yE[n] + h * f(t_grid[n], yE[n])\n\n    # Stage 1.5: Compute the approximation of the second derivative\n    ypp_hat = np.zeros(N)\n    for n in range(N):\n        ypp_hat[n] = (f(t_grid[n + 1], yE[n + 1]) - f(t_grid[n], yE[n])) / h\n\n    # Stage 2: Compute the corrected solution\n    yC = np.zeros(N + 1)\n    yC[0] = y0\n    for n in range(N):\n        yC[n + 1] = yC[n] + h * f(t_grid[n], yC[n]) + (h**2 / 2) * ypp_hat[n]\n\n    return yE[N], yC[N]\n\ndef solve():\n    \"\"\"\n    Runs all test cases and prints the formatted results.\n    \"\"\"\n    results = []\n\n    # Test Case 1: y'(t) = -3y(t), h=0.1\n    f1 = lambda t, y: -3 * y\n    t0_1, T_1, y0_1, h_1 = 0, 1, 1, 0.1\n    y_exact_1 = np.exp(-3 * T_1)\n    yE_1, yC_1 = deferred_correction_solver(f1, t0_1, T_1, y0_1, h_1)\n    err_E1 = np.abs(yE_1 - y_exact_1)\n    err_C1 = np.abs(yC_1 - y_exact_1)\n    ratio1 = err_E1 / err_C1\n    results.extend([err_E1, err_C1, ratio1])\n\n    # Test Case 2: y'(t) = -y(t), h=1.0\n    f2 = lambda t, y: -1 * y\n    t0_2, T_2, y0_2, h_2 = 0, 1, 1, 1.0\n    y_exact_2 = np.exp(-1 * T_2)\n    yE_2, yC_2 = deferred_correction_solver(f2, t0_2, T_2, y0_2, h_2)\n    err_E2 = np.abs(yE_2 - y_exact_2)\n    err_C2 = np.abs(yC_2 - y_exact_2)\n    ratio2 = err_E2 / err_C2\n    results.extend([err_E2, err_C2, ratio2])\n\n    # Test Case 3: y'(t) = -y(t)^3, h=0.1\n    f3 = lambda t, y: -y**3\n    t0_3, T_3, y0_3, h_3 = 0, 1, 1, 0.1\n    y_exact_3 = 1 / np.sqrt(1 + 2 * T_3)\n    yE_3, yC_3 = deferred_correction_solver(f3, t0_3, T_3, y0_3, h_3)\n    err_E3 = np.abs(yE_3 - y_exact_3)\n    err_C3 = np.abs(yC_3 - y_exact_3)\n    ratio3 = err_E3 / err_C3\n    results.extend([err_E3, err_C3, ratio3])\n\n    # Test Case 4: y'(t) = t - y(t), h=0.1\n    f4 = lambda t, y: t - y\n    t0_4, T_4, y0_4, h_4 = 0, 1, 0, 0.1\n    y_exact_4 = T_4 - 1 + np.exp(-T_4)\n    yE_4, yC_4 = deferred_correction_solver(f4, t0_4, T_4, y0_4, h_4)\n    err_E4 = np.abs(yE_4 - y_exact_4)\n    err_C4 = np.abs(yC_4 - y_exact_4)\n    ratio4 = err_E4 / err_C4\n    results.extend([err_E4, err_C4, ratio4])\n\n    # Test Case 5: Observed order for Test Case 1\n    h5_1, h5_2 = 0.2, 0.1\n    _, yC_h1_5 = deferred_correction_solver(f1, t0_1, T_1, y0_1, h5_1)\n    err_h1_5 = np.abs(yC_h1_5 - y_exact_1)\n    err_h2_5 = err_C1 # Re-use calculation from Test Case 1\n    p5 = np.log(err_h1_5 / err_h2_5) / np.log(2)\n    results.append(p5)\n\n    # Test Case 6: Observed order for Test Case 3\n    h6_1, h6_2 = 0.2, 0.1\n    _, yC_h1_6 = deferred_correction_solver(f3, t0_3, T_3, y0_3, h6_1)\n    y_exact_6 = y_exact_3\n    err_h1_6 = np.abs(yC_h1_6 - y_exact_6)\n    err_h2_6 = err_C3 # Re-use calculation from Test Case 3\n    p6 = np.log(err_h1_6 / err_h2_6) / np.log(2)\n    results.append(p6)\n\n    # Format output as specified\n    formatted_results = [f\"{x:.6e}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2402452"}, {"introduction": "While deferred correction improves accuracy, many engineering systems, like oscillators and vibrating structures, pose a different challenge: stability. Explicit methods often require impractically small time steps to avoid numerical blow-up. This practice [@problem_id:2402453] introduces the semi-implicit Euler method, a crucial tool for simulating physical systems, and applies it to a classic mass-spring-damper model. By implementing this scheme, you will see firsthand how treating certain forces implicitly leads to superior stability, a vital property for reliable simulations in graphics, robotics, and structural analysis.", "problem": "You are given the one-dimensional mass–spring–damper model governed by the Ordinary Differential Equation (ODE): $$m \\, \\ddot{x}(t) + c \\, \\dot{x}(t) + k \\, x(t) = 0,$$ where $m$ is the mass in kilograms, $c$ is the viscous damping coefficient in kilograms per second, and $k$ is the spring stiffness in newtons per meter. Introduce the velocity variable $v(t) = \\dot{x}(t)$. Consider the following first-order time discretization of this system over uniform time steps of size $h$ seconds:\n$$v_{n+1} = \\frac{v_n - h \\, \\frac{k}{m} \\, x_n}{1 + h \\, \\frac{c}{m}}, \\quad x_{n+1} = x_n + h \\, v_{n+1},$$\nwith initial conditions $x_0$ and $v_0$. The quantities $x_n$ and $v_n$ approximate the position and velocity at discrete times $t_n = n h$.\n\nYour task is to write a complete, runnable program that:\n- Implements the above discrete-time update to propagate $x_n$ and $v_n$ for a prescribed number of steps $N$.\n- For each test case specified below, computes:\n  1. The final position $x_N$ in meters.\n  2. The final velocity $v_N$ in meters per second.\n  3. The final mechanical energy $$E_N = \\tfrac{1}{2} m v_N^2 + \\tfrac{1}{2} k x_N^2$$ in joules.\n  4. A boundedness indicator defined as follows: Let $$M = \\max_{0 \\le n \\le N} \\max\\{|x_n|, |v_n|\\}.$$ Define the result to be $1$ if $M \\le B$ and $0$ otherwise, where $B = 10^6$.\n- All values $x_N$, $v_N$, and $E_N$ must be expressed in International System of Units (SI). Do not print units; the numerical values are interpreted in SI units.\n\nUse the following test suite, where each case is a tuple $(m, c, k, h, N, x_0, v_0)$:\n- Case $1$: $(1.0, 0.5, 100.0, 0.1, 500, 1.0, 0.0)$\n- Case $2$: $(1.0, 10.0, 2500.0, 0.02, 1000, 1.0, 0.0)$\n- Case $3$: $(1.0, 0.0, 1.0, 2.2, 200, 1.0, 0.0)$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, append the four values $[x_N, v_N, E_N, \\text{bounded}]$ in order, with the boundedness indicator represented as an integer $1$ for true and $0$ for false. The final output must therefore contain $12$ comma-separated entries corresponding to the three cases, in the order of the cases given above, for example:\n\"[x1,v1,E1,b1,x2,v2,E2,b2,x3,v3,E3,b3]\".", "solution": "The problem statement is first subjected to a rigorous validation to ensure its scientific and logical integrity before any attempt at a solution is made.\n\n### Step 1: Extract Givens\n\nThe following information is provided verbatim in the problem statement:\n- **Governing ODE:** $m \\, \\ddot{x}(t) + c \\, \\dot{x}(t) + k \\, x(t) = 0$, where $m$ is mass (kg), $c$ is damping coefficient (kg/s), and $k$ is spring stiffness (N/m).\n- **State variable:** $v(t) = \\dot{x}(t)$.\n- **Discretization scheme:**\n  - Time step: $h$ (s).\n  - Approximations at $t_n = n h$: $x_n, v_n$.\n  - Update equations:\n    $$v_{n+1} = \\frac{v_n - h \\, \\frac{k}{m} \\, x_n}{1 + h \\, \\frac{c}{m}}, \\quad x_{n+1} = x_n + h \\, v_{n+1}$$\n- **Initial conditions:** $x_0, v_0$.\n- **Task:** For a given number of steps $N$, compute:\n  1. Final position $x_N$ (m).\n  2. Final velocity $v_N$ (m/s).\n  3. Final mechanical energy $E_N = \\tfrac{1}{2} m v_N^2 + \\tfrac{1}{2} k x_N^2$ (J).\n  4. Boundedness indicator: Let $M = \\max_{0 \\le n \\le N} \\max\\{|x_n|, |v_n|\\}$. The indicator is $1$ if $M \\le B$ and $0$ otherwise, where $B = 10^6$.\n- **Test Cases:** Each case is a tuple $(m, c, k, h, N, x_0, v_0)$.\n  - Case $1$: $(1.0, 0.5, 100.0, 0.1, 500, 1.0, 0.0)$\n  - Case $2$: $(1.0, 10.0, 2500.0, 0.02, 1000, 1.0, 0.0)$\n  - Case $3$: $(1.0, 0.0, 1.0, 2.2, 200, 1.0, 0.0)$\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientific Grounding:** The governing equation is the fundamental linear model for a mass-spring-damper system, a cornerstone of classical mechanics. The definition of mechanical energy is correct. The numerical scheme is a legitimate method for solving Ordinary Differential Equations. The problem is scientifically sound.\n- **Well-Posedness:** The initial value problem for the ODE is well-posed. The provided discretization scheme is explicit in its update rules, meaning $x_{n+1}$ and $v_{n+1}$ are uniquely determined from $x_n$ and $v_n$. The denominator $1 + h \\, \\frac{c}{m}$ is non-zero for all valid physical parameters ($m>0, c\\ge0, h>0$). The problem is well-posed.\n- **Objectivity:** The problem is phrased using precise, objective mathematical and physical terminology. The tasks are quantitative and unambiguous. The problem is objective.\n- **Completeness and Consistency:** All necessary constants, initial conditions, and parameters ($m, c, k, h, N, x_0, v_0, B$) are provided for each test case. The problem is self-contained and consistent. The units are specified in the International System of Units (SI), which is consistent.\n\n### Step 3: Verdict and Action\n\nThe problem statement is scientifically grounded, well-posed, and complete. It is deemed **valid**. A solution will be developed.\n\n### Solution\n\nThe solution requires the implementation of a numerical time-stepping algorithm to approximate the dynamics of a mass-spring-damper system.\n\n**1. Mathematical Formulation**\n\nThe second-order Ordinary Differential Equation (ODE)\n$$m \\, \\ddot{x}(t) + c \\, \\dot{x}(t) + k \\, x(t) = 0$$\nis transformed into a system of two first-order ODEs by introducing the velocity variable $v(t) = \\dot{x}(t)$. The system becomes:\n$$\n\\begin{cases}\n\\dot{x}(t) = v(t) \\\\\n\\dot{v}(t) = -\\frac{k}{m} x(t) - \\frac{c}{m} v(t)\n\\end{cases}\n$$\n\n**2. Discretization Scheme Analysis**\n\nThe provided update rules are:\n$$\nv_{n+1} = \\frac{v_n - h \\, \\frac{k}{m} \\, x_n}{1 + h \\, \\frac{c}{m}} \\tag{1}\n$$\n$$\nx_{n+1} = x_n + h \\, v_{n+1} \\tag{2}\n$$\nwhere $h$ is the time step, and $(x_n, v_n)$ are the approximations of $(x(t_n), v(t_n))$ at time $t_n = n h$.\n\nThis scheme can be identified as a semi-implicit method. By rearranging the equations into the form of finite differences, we can see its structure:\n$$\n\\frac{x_{n+1} - x_n}{h} = v_{n+1} \\quad \\text{(Implicit/Backward Euler step for position)}\n$$\n$$\n\\frac{v_{n+1} - v_n}{h} = -\\frac{k}{m} x_n - \\frac{c}{m} v_{n+1} \\quad \\text{(Mixed step for velocity)}\n$$\nThe velocity update uses the old position $x_n$ (an explicit or forward treatment of the spring force) and the new velocity $v_{n+1}$ (an implicit or backward treatment of the damping force). This structure often provides better stability than fully explicit methods, such as the standard forward Euler method, especially for stiff or oscillatory systems.\n\n**3. Stability Considerations for the Undamped Case**\n\nA critical aspect of numerical methods is stability. Consider Case $3$, where damping is absent ($c=0$). The parameter $c_m = c/m$ becomes $0$. The update equations simplify to:\n$$\nv_{n+1} = v_n - h \\frac{k}{m} x_n\n$$\n$$\nx_{n+1} = x_n + h v_{n+1}\n$$\nThis is the well-known symplectic Euler method. For the simple harmonic oscillator, its stability is conditional on the time step size. The stability criterion is $|h \\omega_0| \\le 2$, where $\\omega_0 = \\sqrt{k/m}$ is the natural angular frequency.\n\nFor Case $3$, we have $m=1.0$, $k=1.0$, and $h=2.2$. The natural frequency is $\\omega_0 = \\sqrt{1.0/1.0} = 1.0 \\, \\text{rad/s}$. We check the stability condition:\n$$\n|h \\omega_0| = |2.2 \\times 1.0| = 2.2\n$$\nSince $2.2 > 2.0$, the stability condition is violated. The numerical scheme is unstable for this choice of parameters. We must therefore predict that the numerical solution for Case $3$ will grow without bound, and the boundedness indicator should correctly be $0$. This is a feature of the test case, not a flaw in the problem.\n\n**4. Algorithmic Procedure**\n\nThe program will execute the following steps for each test case $(m, c, k, h, N, x_0, v_0)$:\n1.  Initialize the state variables $x = x_0$ and $v = v_0$.\n2.  Initialize a tracking variable for boundedness, $M_{max} = \\max(|x_0|, |v_0|)$.\n3.  Pre-compute the constant coefficients $\\frac{k}{m}$ and $\\frac{c}{m}$ to avoid redundant calculations inside the loop. The denominator term $1 + h \\frac{c}{m}$ will also be pre-computed.\n4.  Execute a loop for $n$ from $0$ to $N-1$:\n    a. Calculate $v_{n+1}$ using equation $(1)$.\n    b. Calculate $x_{n+1}$ using equation $(2)$.\n    c. Update the state: $(x_n, v_n) \\leftarrow (x_{n+1}, v_{n+1})$.\n    d. Update the tracker: $M_{max} = \\max(M_{max}, |x_{n+1}|, |v_{n+1}|)$.\n5.  After the loop completes, the final state is $(x_N, v_N)$.\n6.  Calculate the final energy $E_N = \\frac{1}{2} m v_N^2 + \\frac{1}{2} k x_N^2$.\n7.  Determine the boundedness indicator: $1$ if $M_{max} \\le 10^6$, and $0$ otherwise.\n8.  Collect the four results: $x_N, v_N, E_N,$ and the boundedness indicator.\n\nThis procedure will be systematically applied to all provided test cases to generate the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the mass-spring-damper problem for a given set of test cases\n    using the specified semi-implicit numerical scheme.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (m, c, k, h, N, x0, v0)\n    test_cases = [\n        (1.0, 0.5, 100.0, 0.1, 500, 1.0, 0.0),\n        (1.0, 10.0, 2500.0, 0.02, 1000, 1.0, 0.0),\n        (1.0, 0.0, 1.0, 2.2, 200, 1.0, 0.0),\n    ]\n\n    # Bounding constant B\n    BOUND = 10**6\n\n    results = []\n    \n    for case in test_cases:\n        m, c, k, h, N, x0, v0 = case\n\n        # Initialize state variables\n        x = float(x0)\n        v = float(v0)\n\n        # Initialize tracker for boundedness check\n        max_abs_val = max(abs(x), abs(v))\n\n        # Pre-compute coefficients for efficiency\n        k_over_m = k / m\n        c_over_m = c / m\n        denominator = 1.0 + h * c_over_m\n\n        # Time-stepping loop\n        for _ in range(int(N)):\n            # Apply the update equations\n            v_new = (v - h * k_over_m * x) / denominator\n            x_new = x + h * v_new\n\n            # Update the state\n            x, v = x_new, v_new\n            \n            # Update the maximum absolute value observed\n            max_abs_val = max(max_abs_val, abs(x), abs(v))\n\n        # Final state\n        x_N = x\n        v_N = v\n\n        # Calculate final mechanical energy\n        E_N = 0.5 * m * v_N**2 + 0.5 * k * x_N**2\n\n        # Determine boundedness indicator\n        is_bounded = 1 if max_abs_val = BOUND else 0\n\n        # Append results for this case\n        results.extend([x_N, v_N, E_N, is_bounded])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2402453"}]}