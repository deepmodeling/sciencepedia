{"hands_on_practices": [{"introduction": "Stiff systems of ordinary differential equations, which contain processes evolving on vastly different timescales, pose a significant challenge for many numerical methods. Explicit schemes like Forward Euler are often forced to take impractically small time steps to maintain stability, even when the solution itself is varying smoothly. This hands-on exercise [@problem_id:2372859] allows you to witness this phenomenon firsthand by comparing the explosive failure of Forward Euler with the robust stability of the Backward Euler method on a representative stiff problem, cementing the core motivation for using implicit solvers.", "problem": "Consider the linear autonomous system of Ordinary Differential Equations (ODE) given by $\\dot{x}(t)=A\\,x(t)$, where $A\\in\\mathbb{R}^{2\\times 2}$ is constant and $x(t)\\in\\mathbb{R}^{2}$. Two one-step methods are to be used for time advancement. The explicit method is defined by $x_{n+1}=x_{n}+h\\,A\\,x_{n}$ with stepsize $h>0$. The implicit method is defined by $x_{n+1}=x_{n}+H\\,A\\,x_{n+1}$ with stepsize $H>0$, equivalently written as $x_{n+1}=(I-H\\,A)^{-1}x_{n}$ whenever the inverse exists.\n\nYour task is to write a complete program that, for each test case specified below, performs the following for the given $2\\times 2$ matrix $A$, initial vector $x_{0}$, and small stepsize $h$:\n\n1. Compute the explicit iteration for $N_{\\mathrm{FE}}$ steps with stepsize $h$ using the update $x_{n+1}=x_{n}+h\\,A\\,x_{n}$, starting from $x_{0}$, to obtain $x_{\\mathrm{FE,final}}$.\n2. Define the large stepsize $H=1000\\,h$. Compute the implicit iteration for $N_{\\mathrm{BE}}$ steps with stepsize $H$ using the update $x_{n+1}=(I-H\\,A)^{-1}x_{n}$, starting from $x_{0}$, to obtain $x_{\\mathrm{BE,final}}$.\n3. Let $\\lVert\\cdot\\rVert$ denote the Euclidean norm on $\\mathbb{R}^{2}$. Define that the explicit method “explodes” if $\\lVert x_{\\mathrm{FE,final}}\\rVert>10\\,\\lVert x_{0}\\rVert$, and that the implicit method is “damped” if $\\lVert x_{\\mathrm{BE,final}}\\rVert<\\lVert x_{0}\\rVert$. For each case, output a boolean that is true if and only if both conditions hold.\n\nUse the following test suite:\n\n- Case $\\mathbf{1}$ (happy path, diagonal stiff system):\n  - $A=\\begin{bmatrix}-1&0\\\\0&-1000\\end{bmatrix}$,\n  - $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$,\n  - $h=0.003$,\n  - $H=1000\\,h=3$,\n  - $N_{\\mathrm{FE}}=12$,\n  - $N_{\\mathrm{BE}}=3$.\n- Case $\\mathbf{2}$ (boundary condition near explicit stability edge):\n  - $A=\\begin{bmatrix}-1&0\\\\0&-1000\\end{bmatrix}$,\n  - $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$,\n  - $h=0.002$,\n  - $H=1000\\,h=2$,\n  - $N_{\\mathrm{FE}}=12$,\n  - $N_{\\mathrm{BE}}=3$.\n- Case $\\mathbf{3}$ (coupled stiff system):\n  - $A=\\begin{bmatrix}-1&100\\\\0&-1000\\end{bmatrix}$,\n  - $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$,\n  - $h=0.003$,\n  - $H=1000\\,h=3$,\n  - $N_{\\mathrm{FE}}=12$,\n  - $N_{\\mathrm{BE}}=3$.\n\nFinal Output Format: Your program should produce a single line of output containing the boolean results for the three cases, in order, as a comma-separated list enclosed in square brackets (for example, `[True,False,True]`). No additional text should be printed.", "solution": "The problem as stated requires an analysis of two numerical methods for solving a linear system of ordinary differential equations, $\\dot{x}(t) = A x(t)$. This is a standard problem in the field of computational engineering and numerical analysis. I shall first validate the problem statement.\n\n### Step 1: Extract Givens\n\nThe givens are:\n- The system of ODEs: $\\dot{x}(t)=A\\,x(t)$, where $A\\in\\mathbb{R}^{2\\times 2}$ and $x(t)\\in\\mathbb{R}^{2}$.\n- The explicit method (Forward Euler): $x_{n+1}=x_{n}+h\\,A\\,x_{n} = (I + hA)x_n$, with stepsize $h>0$.\n- The implicit method (Backward Euler): $x_{n+1}=x_{n}+H\\,A\\,x_{n+1}$, equivalent to $x_{n+1}=(I-H\\,A)^{-1}x_{n}$, with stepsize $H>0$.\n- A large stepsize is defined as $H=1000\\,h$.\n- A condition for the explicit method to \"explode\" is defined as $\\lVert x_{\\mathrm{FE,final}}\\rVert>10\\,\\lVert x_{0}\\rVert$, where $\\lVert\\cdot\\rVert$ is the Euclidean norm.\n- A condition for the implicit method to be \"damped\" is defined as $\\lVert x_{\\mathrm{BE,final}}\\rVert<\\lVert x_{0}\\rVert$.\n- The final boolean output for each case is true if and only if the \"explodes\" condition and the \"damped\" condition both hold.\n\nTest cases are provided as follows:\n- **Case 1**: $A=\\begin{bmatrix}-1&0\\\\0&-1000\\end{bmatrix}$, $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$, $h=0.003$, $H=3$, $N_{\\mathrm{FE}}=12$, $N_{\\mathrm{BE}}=3$.\n- **Case 2**: $A=\\begin{bmatrix}-1&0\\\\0&-1000\\end{bmatrix}$, $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$, $h=0.002$, $H=2$, $N_{\\mathrm{FE}}=12$, $N_{\\mathrm{BE}}=3$.\n- **Case 3**: $A=\\begin{bmatrix}-1&100\\\\0&-1000\\end{bmatrix}$, $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$, $h=0.003$, $H=3$, $N_{\\mathrm{FE}}=12$, $N_{\\mathrm{BE}}=3$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is scientifically grounded, objective, and well-posed.\n- **Scientifically Grounded**: The problem addresses the fundamental concept of numerical stability for stiff ordinary differential equations, comparing the conditionally stable Forward Euler method with the A-stable Backward Euler method. These are classic topics in numerical analysis.\n- **Well-Posed**: All parameters ($A$, $x_0$, $h$, $H$, $N_{\\mathrm{FE}}$, $N_{\\mathrm{BE}}$) are precisely defined for each test case. The criteria for \"explodes\" and \"damped\" are unambiguous. A unique result exists for each case. The matrix $(I-HA)$ is invertible for all provided cases, as the eigenvalues of $HA$ do not equal $1$.\n- **Objective**: The problem is stated in an objective mathematical language, free of any subjective interpretation.\n\n### Step 3: Verdict and Action\n\nThe problem is valid. I will proceed with a full solution.\n\nThe core of this problem lies in the concept of numerical stability for stiff systems. A system $\\dot{x}=Ax$ is considered stiff if the matrix $A$ has eigenvalues with real parts that are all non-positive and differ by several orders of magnitude. The stability of a numerical method is determined by its amplification factor, $G$, which governs the propagation of the numerical solution: $x_{n+1} = G x_n$. For the solution to remain bounded, the spectral radius of the amplification factor, $\\rho(G)$, must satisfy $\\rho(G) \\le 1$.\n\nFor the explicit Forward Euler method, the amplification matrix is $G_{\\mathrm{FE}} = I + hA$. The stability condition is $\\rho(I+hA) \\le 1$, which translates to $|1+h\\lambda_i| \\le 1$ for all eigenvalues $\\lambda_i$ of $A$. This defines a stability region in the complex plane for the product $h\\lambda$. For stable systems (where $\\mathrm{Re}(\\lambda_i) \\le 0$), this method is only conditionally stable; it requires the stepsize $h$ to be sufficiently small, typically constrained by the eigenvalue with the largest magnitude.\n\nFor the implicit Backward Euler method, the amplification matrix is $G_{\\mathrm{BE}} = (I - HA)^{-1}$. The stability condition is $\\rho((I-HA)^{-1}) \\le 1$, which translates to $|(1-H\\lambda_i)^{-1}| \\le 1$ for all eigenvalues $\\lambda_i$ of $A$. This condition is satisfied for any $H > 0$ as long as $\\mathrm{Re}(\\lambda_i) \\leq 0$. This property is known as A-stability, making the method unconditionally stable for stiff systems. It allows for much larger stepsizes $H$ without numerical instability, which is computationally advantageous.\n\nNow, we analyze each case.\n\n**Case 1**: $A=\\begin{bmatrix}-1&0\\\\0&-1000\\end{bmatrix}$. The eigenvalues are $\\lambda_1 = -1$ and $\\lambda_2 = -1000$. The stepsize is $h=0.003$.\n- **Forward Euler**: We check the stability condition $|1+h\\lambda_i| \\le 1$.\n  - For $\\lambda_1 = -1$: $|1 + (0.003)(-1)| = |0.997| = 0.997 \\le 1$. This component is stable.\n  - For $\\lambda_2 = -1000$: $|1 + (0.003)(-1000)| = |1 - 3| = |-2| = 2 > 1$. This component is unstable.\n  The numerical solution will grow exponentially due to the unstable mode, and we expect the \"explodes\" condition to be met after $N_{\\mathrm{FE}}=12$ steps.\n- **Backward Euler**: The stepsize is $H=3$. The method is A-stable. The amplification factors for the eigenmodes are:\n  - For $\\lambda_1 = -1$: $|(1 - (3)(-1))^{-1}| = |1/4| = 0.25 < 1$. This component is strongly damped.\n  - For $\\lambda_2 = -1000$: $|(1 - (3)(-1000))^{-1}| = |1/3001| \\approx 3.33 \\times 10^{-4} < 1$. This component is very strongly damped.\n  The norm of the solution vector will decrease. Thus, we expect the \"damped\" condition to be met.\n- **Verdict**: Both conditions are expected to be true. The result for Case 1 is `True`.\n\n**Case 2**: $A=\\begin{bmatrix}-1&0\\\\0&-1000\\end{bmatrix}$. The eigenvalues are $\\lambda_1 = -1$ and $\\lambda_2 = -1000$. The stepsize is $h=0.002$.\n- **Forward Euler**: We check the stability condition $|1+h\\lambda_i| \\le 1$.\n  - For $\\lambda_1 = -1$: $|1 + (0.002)(-1)| = |0.998| = 0.998 \\le 1$. This component is stable.\n  - For $\\lambda_2 = -1000$: $|1 + (0.002)(-1000)| = |1 - 2| = |-1| = 1 \\le 1$. This component is on the boundary of the stability region.\n  The norm of the solution will not grow exponentially. The second component of the solution will oscillate with constant amplitude, while the first decays. The total norm is not expected to grow by a factor of $10$. The \"explodes\" condition will be false.\n- **Backward Euler**: The stepsize is $H=2$. The method is A-stable.\n  - Amplification for $\\lambda_1 = -1$: $|(1 - (2)(-1))^{-1}| = |1/3| < 1$.\n  - Amplification for $\\lambda_2 = -1000$: $|(1 - (2)(-1000))^{-1}| = |1/2001| < 1$.\n  The solution will be damped.\n- **Verdict**: The \"explodes\" condition is false, so the combined condition is false. The result for Case 2 is `False`.\n\n**Case 3**: $A=\\begin{bmatrix}-1&100\\\\0&-1000\\end{bmatrix}$. This is an upper triangular matrix, so its eigenvalues are its diagonal entries: $\\lambda_1 = -1$ and $\\lambda_2 = -1000$. The stepsize is $h=0.003$.\n- **Forward Euler**: The stability analysis depends only on the eigenvalues, which are identical to Case 1. With $h=0.003$, the eigenvalue $\\lambda_2 = -1000$ yields $|1 + (0.003)(-1000)| = 2 > 1$, so the method is unstable. The coupling term $A_{12}=100$ will transfer energy from the unstable mode to the stable one, but the overall solution will be dominated by the exponential growth of the unstable eigen-component. The \"explodes\" condition is expected to be met.\n- **Backward Euler**: The stepsize is $H=3$. The method is A-stable, irrespective of the coupling. The amplification factors are determined by the eigenvalues and are identical to those in Case 1. The solution will be \"damped\".\n- **Verdict**: Both conditions are expected to be true. The result for Case 3 is `True`.\n\nIn summary, the theoretical analysis predicts the results to be `True`, `False`, and `True` for the three cases, respectively. The following program will perform the direct numerical simulation to verify this conclusion.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the given problem by simulating two numerical methods for a system of ODEs\n    and checking for specific stability-related conditions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": np.array([[-1, 0], [0, -1000]]),\n            \"x0\": np.array([1, 1]),\n            \"h\": 0.003,\n            \"N_FE\": 12,\n            \"N_BE\": 3\n        },\n        {\n            \"A\": np.array([[-1, 0], [0, -1000]]),\n            \"x0\": np.array([1, 1]),\n            \"h\": 0.002,\n            \"N_FE\": 12,\n            \"N_BE\": 3\n        },\n        {\n            \"A\": np.array([[-1, 100], [0, -1000]]),\n            \"x0\": np.array([1, 1]),\n            \"h\": 0.003,\n            \"N_FE\": 12,\n            \"N_BE\": 3\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        x0 = case[\"x0\"].astype(float)\n        h = case[\"h\"]\n        N_FE = case[\"N_FE\"]\n        N_BE = case[\"N_BE\"]\n        \n        # The large stepsize H is defined as 1000*h\n        H = 1000 * h\n\n        # Calculate initial norm\n        norm_x0 = np.linalg.norm(x0)\n\n        # 1. Explicit method (Forward Euler) simulation\n        x_fe = x0.copy()\n        for _ in range(N_FE):\n            x_fe = x_fe + h * (A @ x_fe)\n        \n        norm_fe_final = np.linalg.norm(x_fe)\n        explodes = norm_fe_final > 10 * norm_x0\n\n        # 2. Implicit method (Backward Euler) simulation\n        x_be = x0.copy()\n        # Pre-compute the inverse of (I - H*A)\n        # I is the 2x2 identity matrix\n        I = np.identity(2)\n        inv_mat_be = np.linalg.inv(I - H * A)\n        \n        for _ in range(N_BE):\n            x_be = inv_mat_be @ x_be\n        \n        norm_be_final = np.linalg.norm(x_be)\n        damped = norm_be_final < norm_x0\n        \n        # 3. Check if both conditions hold\n        results.append(explodes and damped)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2372859"}, {"introduction": "The A-stability of the Backward Euler method allows us to take large time steps without fear of the numerical solution becoming unbounded, a clear advantage for stiff systems. However, it is crucial to understand that stability does not automatically imply accuracy. This practice [@problem_id:2372906] is designed to highlight this critical distinction by tasking you with applying Backward Euler to a decay process, where you will find that a large time step, while stable, can produce significant errors in accurately capturing the dynamics of the system.", "problem": "Consider a two-isotope, uncoupled radioactive decay model described by the ordinary differential equation (ODE) system\n$$\n\\frac{dc_f}{dt} = -\\lambda_f\\,c_f,\\qquad \\frac{dc_s}{dt} = -\\lambda_s\\,c_s,\n$$\nwith initial conditions\n$$\nc_f(0)=c_{f,0},\\qquad c_s(0)=c_{s,0},\n$$\nwhere $c_f$ and $c_s$ denote the concentrations of a fast- and a slow-decaying isotope, respectively, and $\\lambda_f$ and $\\lambda_s$ are positive decay rates with $\\lambda_f > \\lambda_s$. The exact solution for each isotope is\n$$\nc_f(t)=c_{f,0}\\,e^{-\\lambda_f t},\\qquad c_s(t)=c_{s,0}\\,e^{-\\lambda_s t}.\n$$\nYou are to approximate the solution using the Backward Euler method (BE) with a constant timestep $h$ from $t=0$ to a final time $t=T$, assuming $T/h$ is an integer so that a whole number of steps $N=T/h$ are taken. All quantities are nondimensional; do not append units to any numerical value.\n\nFor each test case, compute the following two quantities for the slow isotope component:\n1. A stability indicator $s$ for the single-step map applied to the slow component, defined as $s=1$ if the magnitude of the per-step amplification factor is less than or equal to $1$, and $s=0$ otherwise.\n2. The absolute error $E=\\lvert c_s^{\\text{BE}}(T)-c_s^{\\text{exact}}(T)\\rvert$ at time $T$.\n\nUse the following test suite of parameter sets $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)$:\n- Test A: $(10, 0.1, 1, 1, 1, 5)$.\n- Test B: $(50, 0.2, 2, 2, 10, 50)$.\n- Test C: $(1, 0.01, 3, 1, 100, 100)$.\n- Test D: $(5, 10^{-6}, 1, 1.5, 10^6, 10^6)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a two-element list $[s,E]$, where $s$ is an integer and $E$ is a float. The overall output format must be\n$$\n[[s_A,E_A],[s_B,E_B],[s_C,E_C],[s_D,E_D]],\n$$\nwith the test cases ordered as A, B, C, D, respectively, and with no additional spaces or text. For example, an output with placeholder values would look like\n`[[1,0.0],[1,0.0],[1,0.0],[1,0.0]]`.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- **Governing Equations**: A system of two uncoupled ordinary differential equations (ODEs) for radioactive decay:\n$$\n\\frac{dc_f}{dt} = -\\lambda_f\\,c_f,\\qquad \\frac{dc_s}{dt} = -\\lambda_s\\,c_s\n$$\n- **Initial Conditions**: $c_f(0)=c_{f,0}$ and $c_s(0)=c_{s,0}$.\n- **Parameters**: $c_f$ and $c_s$ are concentrations. $\\lambda_f$ and $\\lambda_s$ are positive decay rates, with $\\lambda_f > \\lambda_s$.\n- **Exact Solution**: $c_f(t)=c_{f,0}\\,e^{-\\lambda_f t}$ and $c_s(t)=c_{s,0}\\,e^{-\\lambda_s t}$.\n- **Numerical Method**: Backward Euler (BE) method with a constant timestep $h$ from $t=0$ to $t=T$. $N=T/h$ is an integer.\n- **Quantities to Compute**: For the slow isotope component ($c_s$):\n    1. Stability indicator $s$: $s=1$ if the magnitude of the per-step amplification factor is less than or equal to $1$; $s=0$ otherwise.\n    2. Absolute error $E=\\lvert c_s^{\\text{BE}}(T)-c_s^{\\text{exact}}(T)\\rvert$ at the final time $T$.\n- **Test Cases**:\n    - Test A: $(10, 0.1, 1, 1, 1, 5)$\n    - Test B: $(50, 0.2, 2, 2, 10, 50)$\n    - Test C: $(1, 0.01, 3, 1, 100, 100)$\n    - Test D: $(5, 10^{-6}, 1, 1.5, 10^6, 10^6)$\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, modeling a standard physical process (radioactive decay) with a canonical numerical method (Backward Euler). It is well-posed, objective, and self-contained. All necessary data are provided, and there are no internal contradictions. For each test case, the ratio $T/h$ is an integer as stated. The problem formulation is a standard exercise in numerical analysis for ODEs. The presence of parameters for the fast-decaying isotope ($c_f$, $\\lambda_f$) is noted, but since the ODE system is uncoupled, these parameters are irrelevant to the requested computations for the slow-decaying isotope ($c_s$). This does not constitute a flaw but rather tests the correct interpretation of the system.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be provided.\n\nThe problem requires the analysis of the slow-decaying isotope's concentration, $c_s$, governed by the ODE:\n$$\n\\frac{dc_s}{dt} = -\\lambda_s c_s\n$$\nwith the initial condition $c_s(0) = c_{s,0}$. The parameters related to the fast-decaying isotope, $c_f$, are irrelevant for this task because the two ODEs are uncoupled.\n\nWe will apply the Backward Euler method. Let $c_s^n$ be the numerical approximation of $c_s(t_n)$ at time $t_n = n h$, where $h$ is the timestep. The Backward Euler discretization of the ODE is:\n$$\n\\frac{c_s^{n+1} - c_s^n}{h} = -\\lambda_s c_s^{n+1}\n$$\nTo find the update rule, we solve for $c_s^{n+1}$:\n$$\nc_s^{n+1}(1 + h\\lambda_s) = c_s^n\n$$\n$$\nc_s^{n+1} = \\left(\\frac{1}{1 + h\\lambda_s}\\right) c_s^n\n$$\nThis equation defines the single-step map from one time level to the next.\n\n**1. Stability Indicator $s$**\nThe per-step amplification factor, $g$, is the term that multiplies the solution at the previous step to obtain the solution at the current step:\n$$\ng = \\frac{1}{1 + h\\lambda_s}\n$$\nThe stability of the method depends on the magnitude of this factor, $|g|$. The problem states that the stability indicator $s$ is $1$ if $|g| \\le 1$ and $0$ otherwise.\nFrom the problem givens, the decay rate $\\lambda_s$ is positive, and the timestep $h$ is also positive. Thus, their product $h\\lambda_s$ is strictly positive. This implies:\n$$\n1 + h\\lambda_s > 1\n$$\n$$\n0 < \\frac{1}{1 + h\\lambda_s} < 1\n$$\nTherefore, the amplification factor $g$ satisfies $0 < g < 1$, which means its magnitude $|g|$ is always less than $1$, regardless of the choice of $h > 0$ and $\\lambda_s > 0$. This is the well-known property of A-stability for the Backward Euler method applied to this class of problems. Consequently, for all specified test cases, the stability condition is met, and the stability indicator $s$ will be $1$.\n\n**2. Absolute Error $E$**\nTo find the numerical solution at the final time $T$, we apply the single-step map $N$ times, where $N=T/h$. Starting from the initial condition $c_s^0 = c_{s,0}$, we obtain a geometric progression:\n$$\nc_s^N = g^N c_s^0 = \\left(\\frac{1}{1 + h\\lambda_s}\\right)^N c_{s,0}\n$$\nSo, the numerical solution at $t=T$ is:\n$$\nc_s^{\\text{BE}}(T) = c_{s,0} \\left(\\frac{1}{1 + h\\lambda_s}\\right)^{T/h}\n$$\nThe exact solution at $t=T$ is given as:\n$$\nc_s^{\\text{exact}}(T) = c_{s,0} e^{-\\lambda_s T}\n$$\nThe absolute error $E$ is the magnitude of the difference between the numerical and exact solutions at $t=T$:\n$$\nE = \\lvert c_s^{\\text{BE}}(T) - c_s^{\\text{exact}}(T) \\rvert = \\left| c_{s,0} \\left(\\frac{1}{1 + h\\lambda_s}\\right)^{T/h} - c_{s,0} e^{-\\lambda_s T} \\right|\n$$\nSince $c_{s,0}$ is given as positive for all test cases, we can write:\n$$\nE = c_{s,0} \\left| \\left(\\frac{1}{1 + h\\lambda_s}\\right)^{T/h} - e^{-\\lambda_s T} \\right|\n$$\nThese formulae are implemented for each test case to compute the required pairs $[s, E]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes stability indicator and absolute error for a radioactive decay\n    model using the Backward Euler method for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (lambda_f, lambda_s, c_f0, c_s0, h, T)\n    test_cases = [\n        (10.0, 0.1, 1.0, 1.0, 1.0, 5.0),          # Test A\n        (50.0, 0.2, 2.0, 2.0, 10.0, 50.0),         # Test B\n        (1.0, 0.01, 3.0, 1.0, 100.0, 100.0),       # Test C\n        (5.0, 1e-6, 1.0, 1.5, 1e6, 1e6),           # Test D\n    ]\n\n    # Store formatted results for each test case\n    formatted_results = []\n    \n    for case in test_cases:\n        # Unpack parameters. The fast-decaying isotope parameters (lambda_f, c_f0)\n        # are not used as the system is uncoupled.\n        _lambda_f, lambda_s, _c_f0, c_s0, h, T = case\n\n        # 1. Compute the stability indicator s\n        # The amplification factor for Backward Euler on dc/dt = -lambda*c is g = 1 / (1 + h*lambda).\n        # Since lambda_s > 0 and h > 0, g is always between 0 and 1.\n        # Thus, the method is unconditionally stable, and s=1 for all cases.\n        amplification_factor = 1.0 / (1.0 + h * lambda_s)\n        s = 1 if np.abs(amplification_factor) <= 1.0 else 0\n\n        # 2. Compute the absolute error E at time T\n        \n        # The problem statement guarantees N = T/h is an integer.\n        N = int(round(T / h))\n\n        # Numerical solution using Backward Euler after N steps\n        c_s_be = c_s0 * (amplification_factor ** N)\n\n        # Exact solution at time T\n        c_s_exact = c_s0 * np.exp(-lambda_s * T)\n\n        # Absolute error\n        error_E = np.abs(c_s_be - c_s_exact)\n        \n        # Format the result pair as a string \"[s,E]\"\n        formatted_results.append(f\"[{s},{error_E}]\")\n\n    # Final print statement in the exact required format.\n    # e.g., [[s_A,E_A],[s_B,E_B],...]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2372906"}, {"introduction": "While the inherent damping of the Backward Euler method is beneficial for stabilizing stiff, dissipative problems, this same property can be a major drawback for conservative systems where physical quantities, like energy, should not change over time. This final exercise [@problem_id:2372896] shifts our focus to a Hamiltonian system—a simple pendulum—to investigate this effect. By numerically integrating the pendulum's motion and tracking its total energy, you will demonstrate that the Backward Euler method systematically removes energy from the system, a behavior known as numerical dissipation, illustrating the importance of choosing an integrator that respects the underlying physics of the problem.", "problem": "Consider the nondimensionalized simple pendulum modeled as a Hamiltonian system with generalized position $ \\theta $ (angle in radians) and canonical momentum $ p $ (angular momentum). Let mass $ m $ be in kilograms, length $ \\ell $ be in meters, gravitational acceleration $ g $ be in meters per second squared, and time $ t $ be in seconds. The continuous-time equations of motion derived from Hamiltonian mechanics are\n$$\n\\frac{d\\theta}{dt} \\;=\\; \\frac{p}{m\\,\\ell^2}, \n\\qquad\n\\frac{dp}{dt} \\;=\\; -\\,m\\,g\\,\\ell\\,\\sin(\\theta),\n$$\nwith Hamiltonian (total energy)\n$$\nH(\\theta,p) \\;=\\; \\frac{p^2}{2\\,m\\,\\ell^2} \\;+\\; m\\,g\\,\\ell\\,\\bigl(1-\\cos(\\theta)\\bigr).\n$$\nUsing the backward Euler time discretization with a fixed time step $ h > 0 $, advance the solution from $ t=0 $ to $ t=T $ starting from prescribed initial conditions $ \\theta(0)=\\theta_0 $ and $ p(0)=p_0 $. For each test case below, numerically integrate the system, compute the initial energy $ H(\\theta_0,p_0) $ and the final energy $ H(\\theta(T),p(T)) $, and report the energy ratio\n$$\nR \\;=\\; \\frac{H(\\theta(T),p(T))}{H(\\theta_0,p_0)}.\n$$\nAngles must be in radians. Energies must be computed in joules ($ \\mathrm{J} $). Your program must produce the ratios $ R $ rounded to six decimal places.\n\nTest suite:\n- Case $ 1 $ (happy path): $ m=1\\,\\mathrm{kg} $, $ \\ell=1\\,\\mathrm{m} $, $ g=9.81\\,\\mathrm{m/s^2} $, $ \\theta_0=1.0\\,\\mathrm{rad} $, $ p_0=0.0\\,\\mathrm{kg\\,m^2/s} $, $ h=0.1\\,\\mathrm{s} $, $ T=10.0\\,\\mathrm{s} $.\n- Case $ 2 $ (coarser step, stronger dissipation): $ m=1\\,\\mathrm{kg} $, $ \\ell=1\\,\\mathrm{m} $, $ g=9.81\\,\\mathrm{m/s^2} $, $ \\theta_0=1.0\\,\\mathrm{rad} $, $ p_0=0.0\\,\\mathrm{kg\\,m^2/s} $, $ h=0.5\\,\\mathrm{s} $, $ T=10.0\\,\\mathrm{s} $.\n- Case $ 3 $ (boundary case with zero gravity): $ m=1\\,\\mathrm{kg} $, $ \\ell=1\\,\\mathrm{m} $, $ g=0.0\\,\\mathrm{m/s^2} $, $ \\theta_0=0.3\\,\\mathrm{rad} $, $ p_0=0.5\\,\\mathrm{kg\\,m^2/s} $, $ h=0.4\\,\\mathrm{s} $, $ T=8.0\\,\\mathrm{s} $.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases, for example `[R_1,R_2,R_3]`, where each $ R_k $ is a floating-point number rounded to six decimal places.", "solution": "The problem presented is a standard initial value problem in computational mechanics, requiring the numerical integration of a Hamiltonian system. The problem is scientifically sound, well-posed, and contains all necessary information for a unique solution. My validation concludes that the problem is valid. We will proceed with the derivation and implementation of the solution.\n\nThe system describes a simple pendulum, with equations of motion for the generalized position $\\theta$ and canonical momentum $p$:\n$$\n\\frac{d\\theta}{dt} = \\frac{p}{m\\ell^2}\n$$\n$$\n\\frac{dp}{dt} = -mg\\ell\\sin(\\theta)\n$$\nThis system can be written in the compact form $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$, where the state vector is $\\mathbf{y} = [\\theta, p]^T$ and the vector field $\\mathbf{f}$ is given by:\n$$\n\\mathbf{f}(\\mathbf{y}) = \\begin{bmatrix} p / (m\\ell^2) \\\\ -mg\\ell\\sin(\\theta) \\end{bmatrix}\n$$\n\nThe task is to employ the backward Euler method, which is a first-order implicit numerical integration scheme. For a time step $h > 0$, the state at step $n+1$ is determined from the state at step $n$ by the relation:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\mathbf{f}(\\mathbf{y}_{n+1})\n$$\nwhere $\\mathbf{y}_n \\approx \\mathbf{y}(t_n)$ and $t_n = n h$.\n\nApplying this scheme to the pendulum system yields a pair of coupled, nonlinear algebraic equations for the unknown state $\\mathbf{y}_{n+1} = [\\theta_{n+1}, p_{n+1}]^T$:\n$$\n\\theta_{n+1} = \\theta_n + h \\left( \\frac{p_{n+1}}{m\\ell^2} \\right) \\quad (1)\n$$\n$$\np_{n+1} = p_n - h \\, mg\\ell \\sin(\\theta_{n+1}) \\quad (2)\n$$\n\nTo solve this system at each time step, we decouple the equations. We rearrange equation ($1$) to express $p_{n+1}$ as a function of $\\theta_{n+1}$:\n$$\np_{n+1} = \\frac{m\\ell^2}{h} (\\theta_{n+1} - \\theta_n)\n$$\nThis expression is then substituted into equation ($2$):\n$$\n\\frac{m\\ell^2}{h} (\\theta_{n+1} - \\theta_n) = p_n - h \\, mg\\ell \\sin(\\theta_{n+1})\n$$\nBy collecting all terms on one side, we formulate a scalar root-finding problem for $\\theta_{n+1}$. Let $x = \\theta_{n+1}$, the problem is to find the root of the function $F(x) = 0$, where:\n$$\nF(x) \\equiv x - \\theta_n - \\frac{h p_n}{m\\ell^2} + \\frac{h^2 g}{\\ell} \\sin(x) = 0\n$$\nThis is a transcendental equation that must be solved numerically. We will use the Newton-Raphson method, which is an iterative procedure defined by:\n$$\nx_{k+1} = x_k - \\frac{F(x_k)}{F'(x_k)}\n$$\nwhere $k$ is the iteration index and $F'(x)$ is the derivative of $F(x)$ with respect to $x$:\n$$\nF'(x) = 1 + \\frac{h^2 g}{\\ell} \\cos(x)\n$$\nA robust initial guess for the iteration is the value from the previous time step, i.e., $x_0 = \\theta_n$. Once a converged solution for $\\theta_{n+1}$ is obtained, the corresponding momentum $p_{n+1}$ is calculated directly using equation ($2$):\n$$\np_{n+1} = p_n - h \\, mg\\ell \\sin(\\theta_{n+1})\n$$\nThis procedure is repeated for $N = \\text{round}(T/h)$ time steps to advance the solution from the initial state $(\\theta_0, p_0)$ at $t=0$ to the final state $(\\theta(T), p(T))$ at $t=T$.\n\nThe final step is to compute the energy ratio $R$. The total energy of the system is given by the Hamiltonian:\n$$\nH(\\theta,p) = \\frac{p^2}{2m\\ell^2} + mg\\ell\\bigl(1-\\cos(\\theta)\\bigr)\n$$\nWe calculate the initial energy $H_0 = H(\\theta_0, p_0)$ and the final energy $H_T = H(\\theta(T), p(T))$. The ratio is then $R = H_T / H_0$.\n\nThe backward Euler method is known to be numerically dissipative for Hamiltonian systems, meaning that the computed energy is not conserved but generally decreases over time. This effect is more pronounced for larger time steps $h$. In the special case where $g=0$ (Case $3$), the system dynamics become linear, and the backward Euler method provides the exact solution, resulting in perfect energy conservation, i.e., $R=1$. This serves as a verification of the implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the pendulum dynamics using backward Euler and calculates the energy ratio.\n    \"\"\"\n\n    # Test cases: (m, l, g, theta0, p0, h, T)\n    test_cases = [\n        # Case 1 (happy path)\n        (1.0, 1.0, 9.81, 1.0, 0.0, 0.1, 10.0),\n        # Case 2 (coarser step, stronger dissipation)\n        (1.0, 1.0, 9.81, 1.0, 0.0, 0.5, 10.0),\n        # Case 3 (boundary case with zero gravity)\n        (1.0, 1.0, 0.0, 0.3, 0.5, 0.4, 8.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, l, g, theta0, p0, h, T = case\n        \n        # Define the Hamiltonian function to compute energy\n        def hamiltonian(theta, p, m_val, l_val, g_val):\n            kinetic_energy = p**2 / (2 * m_val * l_val**2)\n            potential_energy = m_val * g_val * l_val * (1 - np.cos(theta))\n            return kinetic_energy + potential_energy\n\n        # Calculate initial energy\n        H0 = hamiltonian(theta0, p0, m, l, g)\n\n        # Initialize state variables\n        theta_n = theta0\n        p_n = p0\n        \n        # Determine the number of time steps\n        num_steps = int(round(T / h))\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            # Define the nonlinear function F(x) = 0 to be solved for theta_{n+1}, where x = theta_{n+1}\n            # F(x) = x - theta_n - (h * p_n) / (m * l**2) + (h**2 * g / l) * sin(x)\n            \n            # Pre-compute constants for the function and its derivative\n            const1 = (h**2 * g) / l\n            const2 = (h * p_n) / (m * l**2)\n            \n            # Define F and its derivative F' for the root-finding algorithm\n            def F(x):\n                return x - theta_n - const2 + const1 * np.sin(x)\n\n            def F_prime(x):\n                return 1 + const1 * np.cos(x)\n            \n            # Use Newton's method from SciPy's root_scalar to find theta_{n+1}\n            # The initial guess is the value from the previous step.\n            sol = root_scalar(F, x0=theta_n, fprime=F_prime, method='newton', xtol=1e-12, rtol=1e-12)\n            theta_next = sol.root\n            \n            # Calculate p_{n+1} using the newly found theta_{n+1}\n            p_next = p_n - h * m * g * l * np.sin(theta_next)\n            \n            # Update the state for the next iteration\n            theta_n = theta_next\n            p_n = p_next\n\n        # The final state corresponds to time T\n        theta_T = theta_n\n        p_T = p_n\n        \n        # Calculate the final energy\n        HT = hamiltonian(theta_T, p_T, m, l, g)\n        \n        # Calculate the energy ratio. Handle the case H0=0 to avoid division by zero.\n        if H0 == 0:\n            ratio = 1.0 if HT == 0 else np.inf\n        else:\n            ratio = HT / H0\n            \n        results.append(round(ratio, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2372896"}]}