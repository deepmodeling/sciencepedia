{"hands_on_practices": [{"introduction": "The fundamental purpose of event detection is to accurately pinpoint moments when a system's state meets a specific condition, without the inefficiency of using excessively small time steps. A classic application arises in the study of complex dynamical systems, such as the Lorenz system, where trajectories are chaotic and cannot be predicted analytically. This first exercise [@problem_id:2390102] will guide you through the essential skill of detecting when a trajectory crosses a predefined plane in state space, a foundational task for analyzing the behavior of complex systems.", "problem": "A three-dimensional nonlinear dynamical system is defined by the Lorenz equations\n$$\n\\frac{dx}{dt} = \\sigma\\,(y - x), \\quad\n\\frac{dy}{dt} = x\\,(\\rho - z) - y, \\quad\n\\frac{dz}{dt} = x\\,y - \\beta\\,z,\n$$\nwith parameters $\\sigma > 0$, $\\beta > 0$, and $\\rho > 0$, and an initial condition $(x(0), y(0), z(0)) = (x_0, y_0, z_0)$. Consider the scalar function\n$$\ng(t) = z(t) - (\\rho - 1).\n$$\nA strict crossing of the plane $z = \\rho - 1$ at time $t^\\star \\in (0, T]$ is defined as any time for which there exists $\\epsilon > 0$ such that $g(t)$ is continuous on $(t^\\star - \\epsilon, t^\\star + \\epsilon)$ and $g(t)$ changes sign across $t^\\star$, that is, $g(t^\\star - \\delta)\\,g(t^\\star + \\delta) < 0$ for all sufficiently small $\\delta \\in (0, \\epsilon)$. Crossings at the initial time $t = 0$ must not be counted, even if $g(0) = 0$. Count both directions of crossing; no distinction is made between $g$ changing from negative to positive or from positive to negative.\n\nFor each test case below, determine the integer number of strict crossings of the plane $z = \\rho - 1$ that occur in the closed time interval $[0, T]$, excluding $t = 0$ and including any strict crossing at $t = T$ if it exists. All quantities are nondimensional.\n\nTest suite:\n1. $\\sigma = 10$, $\\beta = \\frac{8}{3}$, $\\rho = 28$, $(x_0, y_0, z_0) = (1, 1, 1)$, $T = 20$.\n2. $\\sigma = 10$, $\\beta = \\frac{8}{3}$, $\\rho = 28$, $(x_0, y_0, z_0) = (0, 1, 27)$, $T = 10$.\n3. $\\sigma = 10$, $\\beta = \\frac{8}{3}$, $\\rho = 28$, $(x_0, y_0, z_0) = (1, 1, 1)$, $T = 1$.\n\nYour program must produce a single line of output containing the results for the three test cases as a comma-separated list of integers enclosed in square brackets, ordered as listed above. For example, an output with counts $a$, $b$, and $c$ must be printed exactly as `[a,b,c]`.\nNo additional text should be printed.", "solution": "The problem as stated is valid. It is a well-posed and scientifically grounded exercise in computational science, specifically the numerical integration of a system of ordinary differential equations with event detection. The Lorenz system is a canonical model in chaos theory, and the task of locating state-space crossings is a standard procedure in the analysis of dynamical systems. All required parameters, initial conditions, and definitions are provided with sufficient clarity and are mutually consistent.\n\nThe problem requires us to find the number of times the solution trajectory of the Lorenz equations,\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{f}(t, \\mathbf{u}; \\sigma, \\rho, \\beta),\n$$\ncrosses the plane defined by $z = \\rho - 1$. Here, the state vector is $\\mathbf{u}(t) = [x(t), y(t), z(t)]^T$, and the vector field $\\mathbf{f}$ is given by:\n$$\n\\mathbf{f}(t, \\mathbf{u}) =\n\\begin{bmatrix}\n\\sigma(y - x) \\\\\nx(\\rho - z) - y \\\\\nxy - \\beta z\n\\end{bmatrix}\n$$\nThe problem is an initial value problem (IVP) over the time interval $[0, T]$, with the initial state $\\mathbf{u}(0) = [x_0, y_0, z_0]^T$.\n\nThe crossing condition is defined by the scalar event function $g(t) = z(t) - (\\rho - 1)$. A \"strict crossing\" at time $t^\\star \\in (0, T]$ corresponds to a root of this function, $g(t^\\star) = 0$, where $g(t)$ also changes sign. We are instructed to count all such roots, irrespective of the direction of the sign change.\n\nTo solve this problem, one must employ a numerical ODE solver capable of locating events. The `scipy.integrate.solve_ivp` function is a suitable and robust tool for this purpose. It integrates the IVP using an adaptive step-size method (such as `LSODA`, which is effective for both stiff and non-stiff problems) to maintain accuracy, while simultaneously monitoring for events.\n\nAn event is defined by providing a callable function to the solver. For this problem, the event function is precisely $g(t, \\mathbf{u}) = u_2 - (\\rho - 1)$, where $u_2$ corresponds to the state variable $z(t)$. The solver finds the roots of this function by checking for sign changes between integration steps and then using a root-finding algorithm (e.g., a variant of Brent's method) to pinpoint the exact time $t^\\star$ of the event.\n\nThe specific requirements of the problem are met as follows:\n$1$. **Counting all strict crossings**: This is achieved by setting the `direction` attribute of the event function to $0$. This instructs the solver to detect all roots where a sign change occurs, regardless of whether the function value transitions from negative to positive or positive to negative.\n$2$. **Non-terminal events**: To count all crossings within the interval $[0, T]$, the integration must not stop after the first event. This is accomplished by setting the `terminal` attribute of the event function to `False`.\n$3$. **Exclusion of $t=0$**: The integration proceeds forward in time from $t=0$. The solver's event-finding mechanism naturally locates roots in the open interval between integration steps, $(t_n, t_{n+1})$. Therefore, any detected events will have times $t^\\star > 0$, automatically fulfilling the condition to exclude crossings at the initial time. In the test case where $g(0) = z_0 - (\\rho - 1) = 27 - (28-1) = 0$, the initial derivative $\\frac{dz}{dt}|_{t=0} = x_0 y_0 - \\beta z_0 = 0 \\cdot 1 - \\frac{8}{3} \\cdot 27 = -72$ shows that the trajectory immediately moves into the region $z < \\rho-1$. Thus, there is no sign change across $t=0$, and a correctly implemented solver will not register this as an event, which is consistent with the problem's definition of a \"strict crossing.\"\n$4$. **Inclusion of $t=T$**: `solve_ivp` correctly finds events up to and including the final time of the integration span.\n\nThe final algorithm involves iterating through each test case, setting up the Lorenz system and the event function with the specified parameters $(\\sigma, \\rho, \\beta)$, initial condition $(x_0, y_0, z_0)$, and time horizon $T$. The `solve_ivp` function is called with these inputs. The number of strict crossings for each case is then the length of the array of event times returned by the solver.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the Lorenz system for three test cases and counts the number of\n    times the z-component crosses a specified plane.\n    \"\"\"\n\n    # Test suite: (sigma, beta, rho, (x0, y0, z0), T)\n    test_cases = [\n        (10.0, 8.0/3.0, 28.0, (1.0, 1.0, 1.0), 20.0),\n        (10.0, 8.0/3.0, 28.0, (0.0, 1.0, 27.0), 10.0),\n        (10.0, 8.0/3.0, 28.0, (1.0, 1.0, 1.0), 1.0),\n    ]\n\n    results = []\n\n    # System of ODEs for the Lorenz attractor\n    def lorenz_system(t, u, sigma, rho, beta):\n        x, y, z = u\n        dxdt = sigma * (y - x)\n        dydt = x * (rho - z) - y\n        dzdt = x * y - beta * z\n        return [dxdt, dydt, dzdt]\n\n    for case in test_cases:\n        sigma, beta, rho, u0, T = case\n\n        # Event function: g(t) = z(t) - (rho - 1)\n        # The solver requires the event function to accept the same arguments\n        # as the ODE system function when passed via 'args'.\n        def event_plane_crossing(t, u, sigma, rho, beta):\n            return u[2] - (rho - 1.0)\n\n        # Attribute: terminal=False to continue integration after an event.\n        event_plane_crossing.terminal = False\n        # Attribute: direction=0 to detect crossings in both directions.\n        event_plane_crossing.direction = 0\n\n        # Integrate the Lorenz equations over the interval [0, T]\n        # and find all events.\n        # LSODA is a good general-purpose solver for stiff or non-stiff systems.\n        # dense_output=True is recommended for accurate root finding.\n        sol = solve_ivp(\n            fun=lorenz_system,\n            t_span=(0, T),\n            y0=u0,\n            method='LSODA',\n            args=(sigma, rho, beta),\n            events=event_plane_crossing,\n            dense_output=True,\n            atol=1e-9,  # Absolute tolerance\n            rtol=1e-6   # Relative tolerance\n        )\n        \n        # The solver returns a list of event time arrays. Since we have one\n        # event function, we access the first element. The number of crossings\n        # is the length of this array.\n        num_crossings = len(sol.t_events[0])\n        results.append(num_crossings)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2390102"}, {"introduction": "Building upon detecting simple state crossings, many real-world events depend not on the instantaneous state of a system but on its cumulative history. For example, a component might fail after accumulating a certain amount of stress or energy. This practice introduces the powerful technique of state-space augmentation, where we add a new variable to our system of differential equations specifically to track such an integral quantity. In this hands-on problem [@problem_id:2390055], you will model a circuit breaker that trips based on total energy dissipated, providing a practical engineering context for mastering this essential modeling skill.", "problem": "You are asked to implement robust event detection in time integration for a simple electrical system where a protective device (a circuit breaker) trips when the cumulative resistive energy loss reaches a critical threshold. The system is a series resistor–inductor element driven by a known voltage input. Your program must compute the trip time using time integration with event detection and return a single aggregate result for a provided test suite.\n\nThe physical model is defined by the following fundamental laws and core definitions:\n- By Kirchhoff's Voltage Law (KVL), a series resistor–inductor circuit with input voltage $V(t)$ satisfies $L \\, \\dfrac{di}{dt} + R \\, i(t) = V(t)$, where $i(t)$ is the current, $R$ is the resistance, and $L$ is the inductance.\n- By Joule heating, the instantaneous resistive power is $p(t) = i(t)^2 \\, R$, and the cumulative energy dissipated in the resistor up to time $t$ is $e(t) = \\displaystyle \\int_{0}^{t} i(\\tau)^2 \\, R \\, d\\tau$.\n\nThe circuit breaker trip condition is that the cumulative energy $e(t)$ first reaches a critical threshold $E_{\\mathrm{crit}} > 0$. Define the event function $g(t) = E_{\\mathrm{crit}} - e(t)$. A trip occurs at the smallest time $t_{\\mathrm{trip}} \\ge 0$ such that $g(t_{\\mathrm{trip}}) = 0$. If no such time exists within the prescribed time horizon, the breaker does not trip in the considered interval.\n\nYour task:\n- Formulate the system as an augmented ordinary differential equation (ODE) for the state $y(t) = [\\, i(t), \\, e(t) \\,]^{\\mathsf{T}}$ using only the above fundamental relations, with initial conditions $i(0) = 0$ and $e(0) = 0$.\n- Numerically integrate the augmented system and detect the event $g(t) = 0$ with root-finding based event location that is consistent with continuous-time dynamics (do not rely on step-wise threshold checks without interpolation).\n- For each test case, if the event is found within the specified integration horizon $[0, T_{\\max}]$, report the first trip time $t_{\\mathrm{trip}}$ in seconds. If the event does not occur in $[0, T_{\\max}]$, report $-1.0$ for that test case.\n\nAngle units and physical units:\n- All times must be in seconds, and you must report trip times in seconds.\n- Any trigonometric input uses radians; for a sinusoidal input $V(t) = V_{0} \\sin(2 \\pi f t)$, the argument $2 \\pi f t$ is in radians.\n- Resistances are in ohms, inductances in henries, voltages in volts, and energy in joules.\n\nNumerical specification:\n- Use initial conditions $i(0) = 0$ and $e(0) = 0$ for all test cases.\n- Use a numerical ODE solver with event detection to locate $t_{\\mathrm{trip}}$ accurately.\n- When the trip occurs, output the first event time rounded to six decimal places.\n- If no trip occurs within the given horizon, output $-1.0$ for that test case.\n\nTest suite:\n- Case $1$ (sinusoidal input, typical trip): $R = 2\\,\\Omega$, $L = 0.005\\,\\mathrm{H}$, $V(t) = 10 \\sin(2 \\pi \\cdot 50 \\, t)\\,\\mathrm{V}$, $E_{\\mathrm{crit}} = 0.5\\,\\mathrm{J}$, $T_{\\max} = 0.2\\,\\mathrm{s}$.\n- Case $2$ (direct current step, very early trip): $R = 1\\,\\Omega$, $L = 0.01\\,\\mathrm{H}$, $V(t) = 5\\,\\mathrm{V}$, $E_{\\mathrm{crit}} = 0.001\\,\\mathrm{J}$, $T_{\\max} = 0.05\\,\\mathrm{s}$.\n- Case $3$ (ramp input, no trip within horizon): $R = 10\\,\\Omega$, $L = 0.05\\,\\mathrm{H}$, $V(t) = a \\, t$ with $a = 5\\,\\mathrm{V/s}$, $E_{\\mathrm{crit}} = 100\\,\\mathrm{J}$, $T_{\\max} = 2.0\\,\\mathrm{s}$.\n- Case $4$ (zero resistance edge case, no dissipation): $R = 0\\,\\Omega$, $L = 0.01\\,\\mathrm{H}$, $V(t) = 10 \\sin(2 \\pi \\cdot 60 \\, t)\\,\\mathrm{V}$, $E_{\\mathrm{crit}} = 0.1\\,\\mathrm{J}$, $T_{\\max} = 0.2\\,\\mathrm{s}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- Each element corresponds to one test case in the order listed above.\n- For cases that trip, print the trip time rounded to six decimal places; for cases without a trip in the horizon, print $-1.0$.\n- Example of the required output structure (illustrative only): `[0.012345,-1.0,0.100000,0.250000]`.", "solution": "The problem statement is evaluated and found to be valid. It is scientifically grounded in fundamental principles of electrical engineering, mathematically well-posed, and provides a complete and unambiguous specification for a computational task. We shall proceed with a formal solution.\n\nThe core of the problem is to model the dynamics of a series resistor-inductor (RL) circuit and to detect an event based on an integral quantity. The system's behavior is governed by two fundamental principles: Kirchhoff's Voltage Law and Joule's first law.\n\nKirchhoff's Voltage Law gives the governing differential equation for the current $i(t)$:\n$$ L \\frac{di}{dt} + R i(t) = V(t) $$\nThe cumulative energy $e(t)$ dissipated in the resistor is the time integral of the instantaneous power $p(t) = i(t)^2 R$:\n$$ e(t) = \\int_{0}^{t} i(\\tau)^2 R \\, d\\tau $$\nTo solve this system numerically, we formulate an augmented initial value problem (IVP). We define a state vector $y(t) = [y_1(t), y_2(t)]^{\\mathsf{T}}$, where $y_1(t) = i(t)$ is the current and $y_2(t) = e(t)$ is the cumulative energy. We then derive the system of first-order ordinary differential equations (ODEs) for $y(t)$.\n\nFrom Kirchhoff's law, the derivative of the first state variable is:\n$$ \\frac{dy_1}{dt} = \\frac{di}{dt} = \\frac{1}{L} \\left( V(t) - R i(t) \\right) = \\frac{1}{L} \\left( V(t) - R y_1(t) \\right) $$\nBy applying the Fundamental Theorem of Calculus to the definition of $e(t)$, we find the derivative of the second state variable:\n$$ \\frac{dy_2}{dt} = \\frac{de}{dt} = \\frac{d}{dt} \\int_{0}^{t} i(\\tau)^2 R \\, d\\tau = i(t)^2 R = y_1(t)^2 R $$\nThis results in the augmented ODE system:\n$$\n\\frac{d}{dt} \\begin{pmatrix} y_1 \\\\ y_2 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{L} (V(t) - R y_1) \\\\ R y_1^2 \\end{pmatrix}\n$$\nThe problem specifies initial conditions $i(0) = 0$ and $e(0) = 0$, which translates to the initial state vector $y(0) = [0, 0]^{\\mathsf{T}}$.\n\nThe circuit breaker trip is an event that occurs when $e(t)$ reaches a critical threshold $E_{\\mathrm{crit}}$. We define an event function $g(t)$ whose root corresponds to the event time:\n$$ g(t) = E_{\\mathrm{crit}} - e(t) = E_{\\mathrm{crit}} - y_2(t) $$\nWe seek the smallest time $t_{\\mathrm{trip}} \\ge 0$ for which $g(t_{\\mathrm{trip}}) = 0$. Since $R \\ge 0$, the energy derivative $\\frac{de}{dt} = R i^2$ is non-negative, meaning $e(t)$ is a non-decreasing function. Consequently, the event function $g(t)$ is non-increasing, which guarantees that if a root exists, it is unique.\n\nTo find $t_{\\mathrm{trip}}$, we employ a numerical ODE solver, such as `scipy.integrate.solve_ivp`, capable of handling event detection. The solver integrates the augmented ODE system over the time horizon $[0, T_{\\max}]$, while simultaneously monitoring the sign of the event function $g(t)$. The solver is configured to detect a zero-crossing of $g(t)$ from positive to negative. Upon detecting such a crossing between integration steps, a precise root-finding algorithm is used on the solver's dense output (a continuous interpolating polynomial) to locate the exact time of the event. This ensures accuracy and is superior to simple threshold checking at discrete time steps. If the integration completes up to $T_{\\max}$ without any event detection, we conclude that no trip occurs in the specified interval.\n\nA special case arises when the resistance $R=0$. In this scenario, the energy derivative $\\frac{de}{dt} = 0 \\cdot y_1^2$ is identically zero. With an initial condition of $e(0)=0$, the energy $e(t)$ remains zero for all time $t \\ge 0$. For any $E_{\\mathrm{crit}} > 0$, the event condition $e(t) = E_{\\mathrm{crit}}$ is never met, and thus no trip can occur.\n\nThe described numerical procedure is implemented and applied to each of the four test cases provided, using the specific parameters for $R$, $L$, $E_{\\mathrm{crit}}$, $T_{\\max}$, and the forcing function $V(t)$ for each case. The resulting trip time is reported rounded to six decimal places, or as $-1.0$ if no trip occurs within the horizon.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the circuit breaker trip time in a series RL circuit\n    for a suite of test cases.\n    \"\"\"\n\n    def find_trip_time(R, L, V_func, E_crit, T_max):\n        \"\"\"\n        Computes the trip time for a single set of circuit parameters.\n\n        Args:\n            R (float): Resistance in ohms.\n            L (float): Inductance in henries.\n            V_func (callable): Voltage function V(t).\n            E_crit (float): Critical energy threshold in joules.\n            T_max (float): Maximum integration time in seconds.\n\n        Returns:\n            float: The trip time rounded to 6 decimal places, or -1.0 if no trip.\n        \"\"\"\n        \n        # In the case of zero resistance, no energy is dissipated via Joule heating.\n        # Since e(0) = 0 and de/dt = R*i^2 = 0, e(t) will always be 0.\n        # If E_crit > 0, the event can never occur.\n        if R == 0.0 and E_crit > 0.0:\n            return -1.0\n\n        def ode_system(t, y, R_val, L_val, V_f):\n            \"\"\"\n            Defines the augmented ODE system dy/dt = f(t, y).\n            y[0] = i(t) (current)\n            y[1] = e(t) (cumulative energy)\n            \"\"\"\n            i, _ = y\n            # di/dt = (V(t) - R*i) / L\n            di_dt = (V_f(t) - R_val * i) / L_val\n            # de/dt = R * i^2\n            de_dt = R_val * i**2\n            return [di_dt, de_dt]\n\n        def event_function(t, y, E_crit_val):\n            \"\"\"\n            Event function g(t) = E_crit - e(t). A root is sought.\n            \"\"\"\n            return E_crit_val - y[1]\n\n        # The solver must stop when the event is found.\n        event_function.terminal = True\n        # We are looking for a crossing from positive to negative (e(t) increasing).\n        event_function.direction = -1\n\n        # Initial conditions: i(0) = 0, e(0) = 0.\n        y0 = [0.0, 0.0]\n        t_span = [0.0, T_max]\n\n        sol = solve_ivp(\n            fun=lambda t, y: ode_system(t, y, R, L, V_func),\n            t_span=t_span,\n            y0=y0,\n            events=lambda t, y: event_function(t, y, E_crit),\n            dense_output=True,  # Necessary for accurate event location\n            rtol=1e-8, # Stricter tolerance for accuracy\n            atol=1e-8\n        )\n\n        # sol.t_events is a list of arrays, one for each event function.\n        # We have one event function, so we check sol.t_events[0].\n        if sol.t_events and len(sol.t_events[0]) > 0:\n            trip_time = sol.t_events[0][0]\n            return round(trip_time, 6)\n        else:\n            return -1.0\n\n    # Test suite from the problem statement.\n    test_cases = [\n        # Case 1: Sinusoidal input, typical trip\n        {'R': 2.0, 'L': 0.005, 'V_func': lambda t: 10.0 * np.sin(2 * np.pi * 50 * t), 'E_crit': 0.5, 'T_max': 0.2},\n        # Case 2: Direct current step, very early trip\n        {'R': 1.0, 'L': 0.01, 'V_func': lambda t: 5.0, 'E_crit': 0.001, 'T_max': 0.05},\n        # Case 3: Ramp input, no trip within horizon\n        {'R': 10.0, 'L': 0.05, 'V_func': lambda t: 5.0 * t, 'E_crit': 100.0, 'T_max': 2.0},\n        # Case 4: Zero resistance edge case, no dissipation\n        {'R': 0.0, 'L': 0.01, 'V_func': lambda t: 10.0 * np.sin(2 * np.pi * 60 * t), 'E_crit': 0.1, 'T_max': 0.2},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_trip_time(\n            case['R'],\n            case['L'],\n            case['V_func'],\n            case['E_crit'],\n            case['T_max']\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2390055"}, {"introduction": "We now advance to an important class of models known as hybrid systems, which combine periods of smooth, continuous evolution with instantaneous, discrete changes or \"jumps\" in the state variables. In these systems, events are more than just moments to observe; they are triggers that fundamentally alter the system's state and restart the integration under new conditions. This final practice [@problem_id:2390118] uses the classic example of a bouncing ball to teach you how to construct a piecewise simulation, manage discontinuous state jumps at event times, and accurately model physical phenomena like collisions and energy loss.", "problem": "You are asked to design and implement a complete, runnable program that simulates a one-dimensional bouncing ball using event detection within numerical time integration. The vertical position is denoted by $y(t)$ with the ground at $y(t)=0$ and the upward direction taken as positive. The governing motion between impacts is given by Newton's second law and the definition of velocity, namely the ordinary differential equation (ODE) system\n$$\n\\frac{dy}{dt} = v, \\quad \\frac{dv}{dt} = -g,\n$$\nwith $g>0$ the constant gravitational acceleration. An impact event occurs when the event function $h(t,y,v)=y$ crosses zero from positive values, meaning the constraint $y(t)=0$ is satisfied with the approach direction from above. At each impact, the vertical velocity undergoes an instantaneous jump while the position remains continuous. Let $v^{-}<0$ be the vertical velocity just before impact and $v^{+}>0$ be the velocity just after impact. The jump law is determined by a coefficient of restitution $e(\\,\\cdot\\,)$ that depends on the magnitude of the pre-impact speed, with the physically motivated model\n$$\ne(s) \\;=\\; e_{\\min} \\;+\\; \\left(e_{\\max}-e_{\\min}\\right) \\exp\\!\\left(-\\frac{s}{v_c}\\right), \\quad s\\ge 0,\n$$\nwhere $0<e_{\\min}<e_{\\max}<1$ and $v_c>0$ are parameters. The jump law is\n$$\nv^{+} \\;=\\; -\\,e\\!\\left(\\left|v^{-}\\right|\\right)\\, v^{-}.\n$$\nBetween successive impacts, the solution is integrated forward in time until the next event $y(t)=0$ from above, or until the specified final time $T_{\\text{end}}$ is reached. To avoid an infinite number of diminishing rebounds, when the computed post-impact speed $v^{+}$ becomes less than a small threshold $v_{\\text{stop}}>0$ (in $\\text{m}/\\text{s}$), the ball is assumed to stick to the ground for the remainder of the simulation, i.e., it stays at $y(t)=0$ with $v(t)=0$ thereafter.\n\nStarting from the fundamental laws above, implement a robust event-detected time integration that:\n- Uses a root-finding event on $y(t)$ to detect and locate impacts with high accuracy.\n- Updates the velocity at each impact using the given $e(\\,\\cdot\\,)$.\n- Continues integration piecewise until $T_{\\text{end}}$ or sticking occurs.\n\nYour program must compute, for each test case in the test suite below:\n- The integer number of impacts that occur at times $t \\le T_{\\text{end}}$.\n- The final height $y(T_{\\text{end}})$ in meters, expressed to six digits after the decimal point.\n- The time of the last impact at or before $T_{\\text{end}}$ in seconds, expressed to six digits after the decimal point. If no impact occurs by $T_{\\text{end}}$, return $-1.000000$ for this value.\n\nUse the International System of Units (SI units): meters for $y$, meters per second for $v$, and seconds for $t$. Gravitational acceleration is $g=9.81\\,\\text{m}/\\text{s}^2$. Angles are not used in this problem. All numeric answers must be reported in SI units as specified. Your algorithm should ensure that event times and states are computed with sufficient accuracy that rounding to six digits after the decimal point is meaningful.\n\nTest suite (each case is given as a tuple $(y_0,v_0,e_{\\min},e_{\\max},v_c,T_{\\text{end}},v_{\\text{stop}})$):\n- Case $1$: $(10.0,\\,0.0,\\,0.2,\\,0.9,\\,2.0,\\,2.2,\\,10^{-3})$.\n- Case $2$: $(50.0,\\,0.0,\\,0.1,\\,0.8,\\,1.0,\\,3.4,\\,10^{-3})$.\n- Case $3$: $(0.001,\\,0.0,\\,0.3,\\,0.9,\\,0.5,\\,0.1,\\,10^{-3})$.\n- Case $4$: $(1.0,\\,5.0,\\,0.2,\\,0.9,\\,2.0,\\,0.1,\\,10^{-3})$.\n\nFor each test case, the program must produce a result triple $[N,\\,Y,\\,T]$ where $N$ is the integer number of impacts up to and including $T_{\\text{end}}$, $Y$ is the final height $y(T_{\\text{end}})$ in meters rounded to six digits after the decimal point, and $T$ is the time of the last impact at or before $T_{\\text{end}}$ in seconds rounded to six digits after the decimal point (or $-1.000000$ if none). Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, with each inner triple also enclosed in square brackets and with numbers in standard decimal notation with exactly six digits after the decimal point for the floating-point values. For example: `[[N1,Y1,T1],[N2,Y2,T2],[N3,Y3,T3],[N4,Y4,T4]]`.", "solution": "The problem posed is a well-defined initial value problem for a hybrid dynamical system, a common paradigm in computational engineering. It is scientifically grounded in Newtonian mechanics and involves a piecewise continuous evolution punctuated by discrete events. The problem is valid and admits a unique, verifiable solution.\n\nThe core of the problem is to simulate the one-dimensional motion of a bouncing ball under constant gravity. The state of the system at any time $t$ is described by its vertical position $y(t)$ and velocity $v(t)$.\n\n**1. Continuous Dynamics: Analytical Trajectory**\nBetween impacts, the motion is governed by the linear ordinary differential equation (ODE) system:\n$$\n\\frac{dy}{dt} = v, \\quad \\frac{dv}{dt} = -g\n$$\nwhere $g = 9.81 \\, \\text{m}/\\text{s}^2$ is the gravitational acceleration. For a segment of motion starting at time $t_k$ with initial state $(y(t_k), v(t_k)) = (y_k, v_k)$, this system has an exact analytical solution. Integrating the equations with respect to time yields the velocity and position for any $t \\ge t_k$:\n$$\nv(t) = v_k - g(t - t_k)\n$$\n$$\ny(t) = y_k + v_k(t - t_k) - \\frac{1}{2}g(t - t_k)^2\n$$\nThis trajectory is a parabola in the $y-t$ plane. Given the simplicity and exactness of this analytical solution, employing a general-purpose numerical ODE integrator such as a Runge-Kutta method is unnecessary and would introduce avoidable discretization errors. Our algorithm will leverage this exact solution for superior accuracy and efficiency.\n\n**2. Discrete Events: Impact Detection and Resolution**\nAn impact event is defined to occur when the event function $h(t, y, v) = y$ crosses zero from positive values. Using the analytical trajectory, we can precisely determine the time of the next impact by solving $y(t) = 0$. Let $\\Delta t = t - t_k$ be the time elapsed since the start of the current flight segment. We must solve the quadratic equation:\n$$\n\\frac{1}{2}g(\\Delta t)^2 - v_k \\Delta t - y_k = 0\n$$\nThe physically meaningful solution for forward time evolution ($\\Delta t > 0$) is:\n$$\n\\Delta t_{\\text{impact}} = \\frac{v_k + \\sqrt{v_k^2 + 2gy_k}}{g}\n$$\nThe time of the next impact is therefore $t_{k+1} = t_k + \\Delta t_{\\text{impact}}$.\n\nAt the moment of impact, the position is continuous ($y(t_{k+1}) = 0$), but the velocity undergoes an instantaneous jump. The velocity just before impact, $v^{-}$, is found by evaluating the velocity equation at $t = t_{k+1}$:\n$$\nv^{-} = v_k - g \\cdot \\Delta t_{\\text{impact}} < 0\n$$\nThe post-impact velocity, $v^{+}$, is determined by the jump law:\n$$\nv^{+} = -e(|v^{-}|) \\cdot v^{-}\n$$\nThe coefficient of restitution, $e(\\,\\cdot\\,)$, models the energy loss during the collision and is given as a function of the impact speed $s = |v^{-}|$ :\n$$\ne(s) = e_{\\min} + (e_{\\max} - e_{\\min}) \\exp\\left(-\\frac{s}{v_c}\\right)\n$$\nwhere $e_{\\min}$, $e_{\\max}$, and $v_c$ are given parameters.\n\n**3. Simulation Termination Conditions**\nThe simulation proceeds from one impact to the next until one of two conditions is met:\n1.  **Final Time Reached**: The time of the next calculated impact, $t_{k+1}$, occurs after the specified final simulation time, $T_{\\text{end}}$. In this case, no further impacts are processed, and the final state $(y(T_{\\text{end}}), v(T_{\\text{end}}))$ is computed using the analytical trajectory over the interval $[t_k, T_{\\text{end}}]$.\n2.  **Sticking Condition**: To prevent an infinite sequence of impacts with diminishing rebound heights (a Zeno phenomenon), a sticking condition is introduced. If the calculated post-impact velocity $v^{+}$ is less than a threshold $v_{\\text{stop}}$, the ball is considered to have come to rest. The simulation is terminated, and the state is fixed at $(y, v) = (0, 0)$ for all subsequent time. The final height $y(T_{\\text{end}})$ is therefore $0$.\n\n**4. Algorithmic Implementation**\nThe simulation is implemented as a loop that advances time from one event to the next.\n\n1.  **Initialization**: Set current time $t = 0$ and state $(y, v) = (y_0, v_0)$. Initialize impact count $N=0$ and last impact time $T_{\\text{last\\_impact}} = -1.0$.\n2.  **Loop Execution**: The loop continues as long as the current time $t < T_{\\text{end}}$.\n    a. **Event Prediction**: Calculate the time of the next impact, $t_{\\text{impact}}$, using the analytical formula derived above.\n    b. **Event Scheduling**:\n       - If $t_{\\text{impact}} > T_{\\text{end}}$, the next event is the end of the simulation. Calculate the final position $y(T_{\\text{end}})$ on the current trajectory and terminate the loop.\n       - If $t_{\\text{impact}} \\le T_{\\text{end}}$, an impact occurs. Increment $N$ and update $T_{\\text{last\\_impact}} = t_{\\text{impact}}$.\n    c. **Event Resolution**:\n       - Calculate the pre-impact velocity $v^{-}$ and the post-impact velocity $v^{+}$.\n       - Check for sticking: If $v^{+} < v_{\\text{stop}}$, set the final position $y(T_{\\text{end}})$ to $0$ and terminate the loop.\n       - Otherwise, update the system state for the next segment: set $t = t_{\\text{impact}}$, $y = 0$, and $v = v^{+}$.\n3.  **Result Aggregation**: After loop termination, assemble the computed values of $N$, $y(T_{\\text{end}})$, and $T_{\\text{last\\_impact}}$ into the required output format. This analytical, event-driven approach ensures high fidelity to the model without the complexities and potential inaccuracies of fixed-step or adaptive numerical integration schemes.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef coefficient_of_restitution(s, emin, emax, vc):\n    \"\"\"\n    Calculates the velocity-dependent coefficient of restitution.\n    s: pre-impact speed (|v-|)\n    emin, emax, vc: model parameters\n    \"\"\"\n    if vc <= 0:\n        return emin\n    return emin + (emax - emin) * np.exp(-s / vc)\n\ndef simulate_bounce(y0, v0, emin, emax, vc, T_end, v_stop):\n    \"\"\"\n    Simulates the one-dimensional bouncing ball for a single test case.\n    The simulation uses an analytical solution for the trajectory between impacts.\n    \"\"\"\n    g = 9.81\n\n    # Initial state\n    t = 0.0\n    y = y0\n    v = v0\n\n    # Result tracking\n    impact_count = 0\n    last_impact_time = -1.0\n\n    # The simulation loop advances from one event (impact) to the next.\n    while t < T_end:\n        # Determine time to next impact, assuming current state (t, y, v)\n        # is the beginning of a free-flight phase.\n        # The position y should be non-negative at the start of any segment.\n        \n        # A small tolerance is used to handle floating-point inaccuracies where y should be 0.\n        if y < 1e-12 and v <= 0:\n            # Ball is on the ground and not moving upwards, so it is considered stuck.\n            # No more flight is possible. The final height will be 0.\n            y_final = 0.0\n            return impact_count, y_final, last_impact_time\n\n        # To find time to impact, we solve y_new = 0 for dt, where y_new = y + v*dt - 0.5*g*dt^2.\n        # This is a quadratic equation: 0.5*g*(dt)^2 - v*dt - y = 0.\n        discriminant = v**2 + 2 * g * y\n        \n        # The discriminant should be non-negative for a physical upward or downward trajectory.\n        if discriminant < 0:\n            # This case indicates an unphysical state (e.g., y is negative).\n            # This can happen due to precision loss, so we treat it as stuck.\n            y_final = 0.0\n            return impact_count, y_final, last_impact_time\n            \n        # The physically correct root for forward time gives the time delta to impact.\n        dt_impact = (v + np.sqrt(discriminant)) / g\n        t_impact = t + dt_impact\n\n        # Check if this impact occurs after the simulation end time.\n        if t_impact > T_end:\n            # No more impacts will occur within the simulation window.\n            # Calculate the final position at T_end on the current trajectory.\n            dt_final_flight = T_end - t\n            y_final = y + v * dt_final_flight - 0.5 * g * dt_final_flight**2\n            return impact_count, y_final, last_impact_time\n\n        # An impact occurs at or before T_end.\n        impact_count += 1\n        last_impact_time = t_impact\n\n        # Calculate pre-impact velocity using v_final = v_initial - g*dt.\n        v_minus = v - g * dt_impact\n\n        # Calculate post-impact velocity using the coefficient of restitution.\n        s = abs(v_minus)\n        e = coefficient_of_restitution(s, emin, emax, vc)\n        v_plus = e * s  # This is the magnitude of the post-impact velocity.\n\n        # Check for the sticking condition.\n        if v_plus < v_stop:\n            # The ball loses enough energy to stick to the ground.\n            # The simulation ends conceptually at this impact.\n            y_final = 0.0\n            return impact_count, y_final, last_impact_time\n\n        # If not sticking, update the state for the next free-flight segment.\n        t = t_impact\n        y = 0.0  # Position is reset to the ground after impact.\n        v = v_plus # Velocity is reset to the new upward velocity.\n\n    # This part of the code is reached if the simulation loop terminates because t >= T_end.\n    # This can happen if an impact or sticking event occurs exactly at T_end.\n    # In this case, the final position y(T_end) is 0.\n    y_final = 0.0\n    return impact_count, y_final, last_impact_time\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (y0, v0, emin, emax, vc, T_end, v_stop)\n        (10.0, 0.0, 0.2, 0.9, 2.0, 2.2, 1e-3),\n        (50.0, 0.0, 0.1, 0.8, 1.0, 3.4, 1e-3),\n        (0.001, 0.0, 0.3, 0.9, 0.5, 0.1, 1e-3),\n        (1.0, 5.0, 0.2, 0.9, 2.0, 0.1, 1e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate the result for one case\n        N, Y, T = simulate_bounce(*case)\n        # Format the result list for this case\n        results.append(f\"[{N},{Y:.6f},{T:.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2390118"}]}