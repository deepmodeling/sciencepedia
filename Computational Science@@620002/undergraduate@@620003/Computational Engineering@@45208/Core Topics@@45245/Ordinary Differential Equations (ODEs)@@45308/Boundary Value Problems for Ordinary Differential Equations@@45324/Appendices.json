{"hands_on_practices": [{"introduction": "The finite difference method is a cornerstone of computational engineering, allowing us to approximate solutions to differential equations by converting them into solvable systems of algebraic equations. This foundational practice guides you through the core process of discretization, where you will transform a continuous boundary value problem (BVP) into a set of linear equations on a grid. You will learn not only how to approximate the derivatives but also how to correctly incorporate different types of boundary conditions, such as the Neumann condition given in this problem [@problem_id:2173556].", "problem": "Consider the two-point boundary value problem defined by the ordinary differential equation\n$$y'' - y = -x$$\non the interval $0 \\le x \\le 1$. The boundary conditions are given by $y'(0) = 1$ and $y(1) = 2$.\n\nWe wish to find an approximate numerical solution to this problem using the finite difference method. Partition the interval $[0, 1]$ into $n=3$ subintervals of equal width, $h$. Let $y_i$ denote the numerical approximation of the solution $y(x_i)$ at the grid points $x_i = i h$ for $i=0, 1, 2, 3$.\n\nTo discretize the differential equation, use the second-order central difference approximation for the second derivative, given by $y''(x_i) \\approx \\frac{y_{i+1} - 2y_i + y_{i-1}}{h^2}$. For the derivative boundary condition at $x=0$, use the first-order forward difference approximation, given by $y'(x_0) \\approx \\frac{y_1 - y_0}{h}$. This procedure will generate a system of linear equations for the unknown values $y_0, y_1, y_2$.\n\nCalculate the numerical approximation for $y(0)$. Express your answer as a fraction in simplest form.", "solution": "We partition the interval into $n=3$ equal subintervals, so $h=(1-0)/3=1/3$. The grid points are $x_{i}=ih$ for $i=0,1,2,3$, and the right boundary value gives $y_{3}=2$.\n\nUsing the first-order forward difference for the derivative boundary condition at $x=0$,\n$$\n\\frac{y_{1}-y_{0}}{h}=1 \\quad \\Rightarrow \\quad y_{1}=y_{0}+h.\n$$\nUsing the second-order central difference for the interior nodes, for $i=1$ and $i=2$ we have\n$$\n\\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^{2}}-y_{i}=-x_{i}.\n$$\nFor $i=1$, since $x_{1}=h$,\n$$\n\\frac{y_{2}-2y_{1}+y_{0}}{h^{2}}-y_{1}=-h,\n$$\nwhich after multiplying by $h^{2}$ becomes\n$$\ny_{2}-2y_{1}+y_{0}-h^{2}y_{1}=-h^{3}.\n$$\nSubstituting $y_{1}=y_{0}+h$ yields\n$$\ny_{2}+(-1-h^{2})y_{0}-(2+h^{2})h=-h^{3},\n$$\nso\n$$\ny_{2}=(1+h^{2})y_{0}+(2+h^{2})h-h^{3}.\n$$\nFor $i=2$, with $x_{2}=2h$ and $y_{3}=2$,\n$$\n\\frac{y_{3}-2y_{2}+y_{1}}{h^{2}}-y_{2}=-2h,\n$$\nor, multiplying by $h^{2}$,\n$$\ny_{3}-2y_{2}+y_{1}-h^{2}y_{2}=-2h^{3}.\n$$\nSubstituting $y_{3}=2$, $y_{1}=y_{0}+h$, and the expression for $y_{2}$ gives\n$$\n2+y_{0}+h-(2+h^{2})\\left[(1+h^{2})y_{0}+(2+h^{2})h-h^{3}\\right]=-2h^{3}.\n$$\nLetting $A=2+h^{2}$, this is\n$$\n2+y_{0}+h-A(1+h^{2})y_{0}-A^{2}h+Ah^{3}=-2h^{3}.\n$$\nRearranging,\n$$\n\\left[1-A(1+h^{2})\\right]y_{0}=-2h^{3}-2-h-Ah^{3}+A^{2}h.\n$$\nSince $A(1+h^{2})=2+3h^{2}+h^{4}$, the coefficient simplifies to $-(1+3h^{2}+h^{4})$, and the right-hand side simplifies to $-2+3h$. Therefore,\n$$\n-(1+3h^{2}+h^{4})\\,y_{0}=-2+3h \\quad \\Rightarrow \\quad y_{0}=\\frac{2-3h}{1+3h^{2}+h^{4}}.\n$$\nWith $h=\\frac{1}{3}$, we compute\n$$\n2-3h=2-1=1,\\qquad 1+3h^{2}+h^{4}=1+\\frac{1}{3}+\\frac{1}{81}=\\frac{109}{81}.\n$$\nHence\n$$\ny_{0}=\\frac{1}{109/81}=\\frac{81}{109}.\n$$\nTherefore, the finite difference approximation for $y(0)$ is $\\frac{81}{109}$.", "answer": "$$\\boxed{\\frac{81}{109}}$$", "id": "2173556"}, {"introduction": "An alternative and equally powerful technique for solving BVPs is the shooting method, which reframes the problem as a search for the correct initial conditions for an equivalent initial value problem (IVP). This coding-based exercise moves beyond simple application to explore how the shooting method reveals the often surprising nature of nonlinear systems. By investigating three carefully chosen BVPs, you will discover how nonlinearity can lead to multiple, no, or even a continuum of solutions—a critical insight for analyzing complex, real-world phenomena [@problem_id:2375115].", "problem": "Consider the shooting formulation of two-point boundary value problems for ordinary differential equations in a dimensionless setting. Let $x \\in [a,b]$ denote the independent variable, and let $y(x)$ denote the dependent variable. For a second-order ordinary differential equation, introduce the shooting parameter $s$ as the missing initial condition at $x=a$ and define a scalar root-finding function $F(s)$ whose zero(s) encode satisfaction of the boundary condition at $x=b$. Specifically, when the left boundary is Dirichlet, take $y(a) = \\alpha$ and $y^{\\prime}(a) = s$ and set $F(s) = y(b;s) - \\beta$. When the right boundary is Neumann, take $y^{\\prime}(b) = \\gamma$ and set $F(s) = y^{\\prime}(b;s) - \\gamma$. The map $s \\mapsto F(s)$ may have multiple, no, or a continuum of roots depending on the nonlinearity.\n\nYour task is to implement a program that, for three carefully chosen nonlinear boundary value problems, characterizes the root structure of the corresponding shooting function $F(s)$ using numerical integration of the initial value problems and scalar root bracketing. Angles used in any trigonometric expressions must be interpreted in radians.\n\nStart from the fundamental base that the initial value problem for a smooth right-hand side has a unique local solution, and in conservative cases multiplication by $y^{\\prime}$ yields a first integral of motion. Use the definitions of shooting and basic existence and uniqueness for initial value problems as your only starting points. Do not assume any explicit solutions unless derivable from this base.\n\nDefine three test cases as follows.\n\n- Case A (nonlinear conservative oscillator with Dirichlet–Dirichlet boundary conditions; expected multiple roots): Consider\n  $$ y^{\\prime\\prime}(x) + y(x)^3 = 0, \\quad x \\in [0,1], $$\n  with boundary conditions\n  $$ y(0) = 0, \\quad y(1) = 0. $$\n  Define the shooting parameter as $s = y^{\\prime}(0)$ and the root-finding function as $F(s) = y(1;s) - 0$. Numerically integrate the initial value problem for many values of $s$ to detect sign changes of $F(s)$ and then refine each bracketing interval to a root. For a symmetric search interval $[-S_{\\max}, S_{\\max}]$ with grid spacing $\\Delta s$, report the total count of distinct roots detected in this interval, counting the symmetric nonzero roots and, if present, the root at $s = 0$. Use the test parameters $S_{\\max} = 12$ and $\\Delta s = 0.05$.\n\n- Case B (nonlinear equation with Neumann–Neumann boundary conditions; expected zero roots): Consider\n  $$ y^{\\prime\\prime}(x) = 1 + \\big(y^{\\prime}(x)\\big)^2, \\quad x \\in [0,1], $$\n  with boundary conditions\n  $$ y^{\\prime}(0) = 0, \\quad y^{\\prime}(1) = 0. $$\n  Use $s = y(0)$ as the shooting parameter and define $F(s) = y^{\\prime}(1;s) - 0$. Numerically verify that no root exists by evaluating $F(s)$ at the two distinct shooting values $s_1 = -1$ and $s_2 = 1$, demonstrating that $F(s)$ is strictly nonzero and of the same sign at both points. Return a boolean that is true if and only if no root is detected by this test.\n\n- Case C (nonlinear equation with Neumann–Neumann boundary conditions; expected continuum of roots): Consider\n  $$ y^{\\prime\\prime}(x) = y(x)\\,y^{\\prime}(x), \\quad x \\in [0,1], $$\n  with boundary conditions\n  $$ y^{\\prime}(0) = 0, \\quad y^{\\prime}(1) = 0. $$\n  Use $s = y(0)$ as the shooting parameter and define $F(s) = y^{\\prime}(1;s) - 0$. Numerically verify a continuum of roots by evaluating $F(s)$ at two distinct shooting values $s_1 = -0.3$ and $s_2 = 0.8$, and checking that both evaluations yield zero within a tight numerical tolerance. Return a boolean that is true if and only if both values are numerically zero, which certifies multiple distinct $s$ for which the boundary condition is met.\n\nImplementation requirements and numerical specifications:\n\n- For each case, formulate the ordinary differential equation as a first-order system:\n  $$ y^{\\prime} = v, \\quad v^{\\prime} = f(x, y, v). $$\n- Use numerical integration of the initial value problem on $[0,1]$ to evaluate $F(s)$. If you use trigonometric functions in analysis, interpret angles in radians.\n- Use relative tolerance $10^{-10}$ and absolute tolerance $10^{-12}$ in the integrator.\n- For Case A, perform a coarse sweep of $F(s)$ on $[0, S_{\\max}]$ with spacing $\\Delta s$ to find sign changes of $F(s)$ and refine each bracket with a robust bracketing root finder. Mirror the count to $[-S_{\\max}, 0)$ and include the possible root at $s=0$ if detected.\n- For Cases B and C, evaluate at the specified $s$ values and use a tolerance of $10^{-8}$ to assess zero.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The output must be of the form\n  $$ [M, \\text{NR}, \\text{CR}], $$\n  where $M$ is the integer number of roots detected in Case A within $[-S_{\\max}, S_{\\max}]$, $\\text{NR}$ is a boolean indicating that no root exists in Case B by the specified test, and $\\text{CR}$ is a boolean indicating that a continuum is detected in Case C by the specified test.\n\nThe final program must be complete and runnable without user input, using only the Python standard library and the specified scientific libraries. All numerical values and parameters in this problem are dimensionless; no physical units are involved in any computation or reporting.", "solution": "The problem presented requires the numerical characterization of the solution structure for three distinct nonlinear two-point boundary value problems using the shooting method. A rigorous validation of the problem statement confirms its validity: it is scientifically grounded in the theory of ordinary differential equations, well-posed, objective, and provides a complete and consistent set of parameters for numerical implementation. We shall proceed with the solution.\n\nThe shooting method transforms a boundary value problem (BVP) into an initial value problem (IVP). We introduce a parameter, $s$, representing the missing initial condition at one boundary, say $x=a$. We then integrate the resulting IVP numerically to the other boundary at $x=b$. A function $F(s)$ is defined that equals zero if and only if the boundary condition at $x=b$ is satisfied. The roots of $F(s)$ correspond to solutions of the original BVP.\n\nFor a general second-order ODE of the form $y^{\\prime\\prime} = g(x, y, y^{\\prime})$, we reformulate it as a first-order system by letting $y_0 = y$ and $y_1 = y^{\\prime}$. The system is:\n$$\n\\begin{cases}\ny_0^{\\prime} = y_1 \\\\\ny_1^{\\prime} = g(x, y_0, y_1)\n\\end{cases}\n$$\nThis system is then solved using a numerical integrator. For this problem, we use the specified high-precision tolerances of relative tolerance $10^{-10}$ and absolute tolerance $10^{-12}$.\n\n### Case A: Nonlinear Conservative Oscillator\nThe boundary value problem is:\n$$ y^{\\prime\\prime}(x) + y(x)^3 = 0, \\quad x \\in [0,1], \\quad y(0) = 0, \\quad y(1) = 0 $$\nThe first-order system is:\n$$ \\mathbf{y}^{\\prime} = \\begin{pmatrix} y_0^{\\prime} \\\\ y_1^{\\prime} \\end{pmatrix} = \\begin{pmatrix} y_1 \\\\ -y_0^3 \\end{pmatrix} $$\nThe boundary condition at $x=0$ is of Dirichlet type, $y(0)=0$. We introduce the shooting parameter $s = y^{\\prime}(0)$. The initial conditions for the IVP are therefore $\\mathbf{y}(0) = [y_0(0), y_1(0)]^T = [0, s]^T$. The shooting function $F(s)$ is defined by the condition at the right boundary, $y(1)=0$:\n$$ F(s) = y_0(1; s) - 0 = y_0(1; s) $$\nThe problem asks for the total count of roots of $F(s)$ in the interval $s \\in [-12, 12]$.\n\nThe ODE is conservative, which suggests oscillatory solutions, leading to the expectation of multiple roots. Furthermore, the equation is invariant under the transformation $y \\to -y$. If $y(x;s)$ is the solution for the shooting parameter $s$, then $-y(x;s)$ is also a solution. The initial slope of $-y(x;s)$ is $-y^{\\prime}(0;s) = -s$. Thus, $F(-s) = y_0(1;-s) = -y_0(1;s) = -F(s)$. This odd symmetry implies that if $s_0 \\neq 0$ is a root, then $-s_0$ is also a root. Also, $F(0)=0$, corresponding to the trivial solution $y(x)=0$, so $s=0$ is always a root.\n\nOur procedure is as follows:\n1.  Establish that $s=0$ is a root.\n2.  Perform a search for roots in the interval $(0, S_{\\max}]$, where $S_{\\max} = 12$. We discretize this interval with a step $\\Delta s = 0.05$.\n3.  For each segment $[s_i, s_{i+1}]$ of the discretization where a sign change occurs, i.e., $F(s_i)F(s_{i+1}) < 0$, we confirm the existence of a unique root within that bracket using a robust numerical root-finder.\n4.  The number of roots found for $s>0$ is counted.\n5.  The total number of roots is $M = 1 + 2 \\times (\\text{number of positive roots})$, due to symmetry.\n\n### Case B: Absence of Solutions\nThe boundary value problem is:\n$$ y^{\\prime\\prime}(x) = 1 + \\big(y^{\\prime}(x)\\big)^2, \\quad x \\in [0,1], \\quad y^{\\prime}(0) = 0, \\quad y^{\\prime}(1) = 0 $$\nThe first-order system is:\n$$ \\mathbf{y}^{\\prime} = \\begin{pmatrix} y_0^{\\prime} \\\\ y_1^{\\prime} \\end{pmatrix} = \\begin{pmatrix} y_1 \\\\ 1 + y_1^2 \\end{pmatrix} $$\nThe boundary condition at $x=0$ is of Neumann type. The shooting parameter is thus chosen as the value of the function itself, $s = y(0)$. The initial conditions are $\\mathbf{y}(0) = [s, 0]^T$. The shooting function is derived from the right boundary condition, $y^{\\prime}(1)=0$:\n$$ F(s) = y_1(1; s) - 0 = y_1(1; s) $$\nThe equation for $y_1 = y^{\\prime}$ decouples from $y_0$: $y_1^{\\prime} = 1 + y_1^2$. This is a separable equation: $dy_1 / (1 + y_1^2) = dx$. Integrating from $x=0$ to a general $x$ with the initial condition $y_1(0) = 0$ yields $\\arctan(y_1(x)) = x$, or $y_1(x) = \\tan(x)$. Crucially, this solution for $y_1(x)$ is independent of $y_0(0) = s$. Therefore, the shooting function is a constant:\n$$ F(s) = y_1(1) = \\tan(1) \\approx 1.5574 $$\nSince $F(s)$ is a non-zero constant, it has no roots. We verify this numerically by evaluating $F(s)$ at two distinct points, $s_1 = -1$ and $s_2 = 1$, and confirming that both values are positive and non-zero. The boolean result `NR` is true if no root is detected by this test.\n\n### Case C: Continuum of Solutions\nThe boundary value problem is:\n$$ y^{\\prime\\prime}(x) = y(x)\\,y^{\\prime}(x), \\quad x \\in [0,1], \\quad y^{\\prime}(0) = 0, \\quad y^{\\prime}(1) = 0 $$\nThe first-order system is:\n$$ \\mathbf{y}^{\\prime} = \\begin{pmatrix} y_0^{\\prime} \\\\ y_1^{\\prime} \\end{pmatrix} = \\begin{pmatrix} y_1 \\\\ y_0 y_1 \\end{pmatrix} $$\nAs in Case B, we use the shooting parameter $s = y(0)$, leading to initial conditions $\\mathbf{y}(0) = [s, 0]^T$. The shooting function is $F(s) = y_1(1; s)$.\nAn analytical inspection of the system reveals a special property. The initial condition $y_1(0)=0$ places the system at an equilibrium state for the $y_1$ component, since $y_1^{\\prime}(0) = y_0(0) y_1(0) = s \\cdot 0 = 0$. By the uniqueness of solutions to initial value problems, if the initial state is an equilibrium, it remains there. Thus, $y_1(x) = 0$ for all $x \\in [0,1]$. This implies $y_0(x)$ is constant, so $y_0(x) = y_0(0) = s$.\nThe function $y(x) = s$ with $y^{\\prime}(x) = 0$ is a valid solution to the ODE $y^{\\prime\\prime} = y y^{\\prime}$ for any constant $s$, as it reduces to $0 = s \\cdot 0$.\nThis solution satisfies both boundary conditions $y^{\\prime}(0)=0$ and $y^{\\prime}(1)=0$. Therefore, $F(s) = y_1(1; s) = 0$ for all values of $s$. There exists a continuum of solutions. We verify this numerically by evaluating $F(s)$ at two distinct points, $s_1 = -0.3$ and $s_2 = 0.8$, and checking if both values are zero within a tolerance of $10^{-8}$. The boolean result `CR` is true if this test passes.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves three boundary value problems using the shooting method to characterize\n    the root structure of the corresponding shooting function F(s).\n    \"\"\"\n\n    # --- Case A: Nonlinear conservative oscillator ---\n    def solve_case_a():\n        s_max = 12.0\n        delta_s = 0.05\n        rtol = 1e-10\n        atol = 1e-12\n\n        def ode_a(t, y):\n            # y'' + y^3 = 0  =>  y0' = y1, y1' = -y0^3\n            y0, y1 = y\n            return [y1, -y0**3]\n\n        memo = {}\n        def F_a(s):\n            s_val = float(s)\n            if s_val in memo:\n                return memo[s_val]\n            \n            # Trivial case s=0\n            if abs(s_val) < 1e-15:\n                return 0.0\n\n            # Initial condition: y(0)=0, y'(0)=s\n            y0 = [0.0, s_val]\n            sol = solve_ivp(ode_a, [0, 1], y0, rtol=rtol, atol=atol)\n            # F(s) = y(1;s)\n            result = sol.y[0, -1]\n            memo[s_val] = result\n            return result\n\n        # The trivial solution y(x)=0 corresponding to s=0 is a root.\n        root_count = 1  \n        \n        # Scan for roots for s > 0\n        positive_roots = 0\n        s_grid = np.arange(delta_s, s_max + delta_s, delta_s)\n        \n        f_prev = F_a(0)\n        s_prev = 0\n        \n        for s_curr in s_grid:\n            f_curr = F_a(s_curr)\n            if np.sign(f_curr) != np.sign(f_prev) and f_prev != 0:\n                # Bracket found, refine with brentq to confirm root\n                try:\n                    brentq(F_a, s_prev, s_curr)\n                    positive_roots += 1\n                except ValueError:\n                    # Should not happen if sign change is correct\n                    pass\n            s_prev = s_curr\n            f_prev = f_curr\n\n        # Total roots = 1 (for s=0) + 2 * (positive roots) due to symmetry\n        M = 1 + 2 * positive_roots\n        return M\n\n    # --- Case B: Nonlinear equation with no roots ---\n    def solve_case_b():\n        s1 = -1.0\n        s2 = 1.0\n        zero_tol = 1e-8\n        rtol = 1e-10\n        atol = 1e-12\n\n        def ode_b(t, y):\n            # y'' = 1 + (y')^2  =>  y0' = y1, y1' = 1 + y1^2\n            y0, y1 = y\n            return [y1, 1 + y1**2]\n\n        def F_b(s):\n            # Initial condition: y(0)=s, y'(0)=0\n            y0 = [s, 0.0]\n            sol = solve_ivp(ode_b, [0, 1], y0, rtol=rtol, atol=atol)\n            # F(s) = y'(1;s)\n            return sol.y[1, -1]\n\n        f_s1 = F_b(s1)\n        f_s2 = F_b(s2)\n        \n        # Analytically, F(s) = tan(1) for all s.\n        # Check if both are non-zero and have the same sign.\n        no_root_detected = (\n            abs(f_s1) > zero_tol and\n            abs(f_s2) > zero_tol and\n            np.sign(f_s1) == np.sign(f_s2)\n        )\n        return no_root_detected\n\n    # --- Case C: Nonlinear equation with a continuum of roots ---\n    def solve_case_c():\n        s1 = -0.3\n        s2 = 0.8\n        zero_tol = 1e-8\n        rtol = 1e-10\n        atol = 1e-12\n\n        def ode_c(t, y):\n            # y'' = y * y'  =>  y0' = y1, y1' = y0 * y1\n            y0, y1 = y\n            return [y1, y0 * y1]\n\n        def F_c(s):\n            # Initial condition: y(0)=s, y'(0)=0\n            y0 = [s, 0.0]\n            sol = solve_ivp(ode_c, [0, 1], y0, rtol=rtol, atol=atol)\n            # F(s) = y'(1;s)\n            return sol.y[1, -1]\n\n        f_s1 = F_c(s1)\n        f_s2 = F_c(s2)\n\n        # Analytically, F(s) = 0 for all s.\n        # Check if both evaluations are numerically zero.\n        continuum_detected = (\n            abs(f_s1) < zero_tol and\n            abs(f_s2) < zero_tol\n        )\n        return continuum_detected\n\n    # Calculate results for all cases\n    result_a = solve_case_a()\n    result_b = solve_case_b()\n    result_c = solve_case_c()\n\n    # Print in the specified format [M, NR, CR]\n    print(f\"[{result_a},{result_b},{result_c}]\")\n\nsolve()\n```", "id": "2375115"}, {"introduction": "Real-world engineering challenges rarely involve a single, isolated equation; instead, they are often described by systems of coupled, nonlinear ODEs. This practice bridges theory and application by asking you to solve a reaction-diffusion system, a model fundamental to chemical engineering, materials science, and biology. Here, you will learn the modern workflow of using a robust, pre-built library solver to efficiently tackle such complex systems, a practical skill essential for tackling large-scale computational problems [@problem_id:2375141].", "problem": "Consider a one-dimensional, steady-state reaction–diffusion system on the closed interval $[0,1]$ with two species whose dimensionless concentrations are $A(x)$ and $B(x)$. The system is governed by the coupled boundary value problems\n$$D_A\\,A''(x) - k\\,A(x)\\,B(x) = 0,\\qquad D_B\\,B''(x) - k\\,A(x)\\,B(x) = 0,$$\nfor all $x \\in (0,1)$, where $D_A>0$ and $D_B>0$ are dimensionless diffusivities and $k \\ge 0$ is a dimensionless reaction rate. The boundary conditions are\n$$A(0) = A_L,\\quad A(1) = A_R,\\quad B(0) = B_L,\\quad B(1) = B_R.$$\n\nYour task is to write a complete, runnable program that, for each specified test case below, computes the scalar quantity\n$$I = \\int_{0}^{1} A(x)\\,B(x)\\,dx,$$\nwhere $A(x)$ and $B(x)$ are the solutions to the system for the given parameters and boundary data. All variables and parameters are dimensionless. Report each value of $I$ as a decimal number rounded to six digits after the decimal point.\n\nTest Suite:\n- Test Case 1 (general case): $D_A=1.0$, $D_B=0.5$, $k=2.0$, $A_L=1.0$, $A_R=0.2$, $B_L=0.3$, $B_R=1.2$.\n- Test Case 2 (no reaction edge case): $D_A=1.0$, $D_B=1.0$, $k=0.0$, $A_L=0.0$, $A_R=1.0$, $B_L=1.0$, $B_R=0.0$.\n- Test Case 3 (strongly unequal diffusivities): $D_A=10.0$, $D_B=0.1$, $k=1.5$, $A_L=0.8$, $A_R=0.6$, $B_L=0.2$, $B_R=0.9$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the three results in order as a comma-separated list enclosed in square brackets, with each entry rounded to six digits after the decimal point, for example, $[0.123456,0.234567,0.345678]$.", "solution": "The problem statement is subjected to validation.\n\n**1. Extraction of Givens:**\n- Governing Equations: $D_A\\,A''(x) - k\\,A(x)\\,B(x) = 0$ and $D_B\\,B''(x) - k\\,A(x)\\,B(x) = 0$ for $x \\in (0,1)$.\n- Parameters: Dimensionless diffusivities $D_A > 0$, $D_B > 0$, and dimensionless reaction rate $k \\ge 0$.\n- Boundary Conditions: $A(0) = A_L$, $A(1) = A_R$, $B(0) = B_L$, $B(1) = B_R$.\n- Objective: Compute the integral $I = \\int_{0}^{1} A(x)\\,B(x)\\,dx$.\n- Test Suite: Three distinct sets of parameters and boundary conditions are provided.\n\n**2. Validation:**\n- **Scientific Grounding:** The problem describes a canonical reaction–diffusion system, a fundamental and well-established model in chemical engineering and mathematical biology. The governing equations are scientifically sound.\n- **Well-Posedness:** The problem is a system of two coupled, second-order, nonlinear ordinary differential equations (ODEs) on a closed interval, supplied with four boundary conditions (two for each second-order equation). This constitutes a well-defined two-point boundary value problem (BVP). The parameters provided are physically realistic.\n- **Objectivity & Completeness:** The problem is stated using precise, unambiguous mathematical language. All necessary information (equations, parameters, boundary conditions, target quantity) is provided. The problem is self-contained and consistent.\n\n**3. Verdict:**\nThe problem is valid. It is a standard, well-posed BVP in computational science that can be solved with established numerical methods.\n\n**Solution Methodology:**\n\nThe task is to solve a system of coupled nonlinear ODEs that form a boundary value problem, and subsequently compute a definite integral involving the solutions.\n\nFirst, an analytical insight can be gained by examining the structure of the governing equations:\n$$D_A\\,A''(x) = k\\,A(x)\\,B(x)$$\n$$D_B\\,B''(x) = k\\,A(x)\\,B(x)$$\nIt is immediately apparent that $D_A\\,A''(x) = D_B\\,B''(x)$. Integrating this relation twice reveals a linear invariant of the system. Let $U(x) = D_A A(x) - D_B B(x)$. Then $U''(x) = 0$, which implies $U(x)$ is a linear function of $x$. The coefficients of this linear function are determined by the boundary conditions. This property can be used to reduce the system to a single, more complex, nonlinear ODE. However, for a general numerical solver, it is more direct and robust to address the original coupled system.\n\nThe numerical solution of a BVP requires converting the system of second-order ODEs into a system of first-order ODEs. A state vector $\\mathbf{y}(x)$ is defined as:\n$$\\mathbf{y}(x) = \\begin{bmatrix} y_1(x) \\\\ y_2(x) \\\\ y_3(x) \\\\ y_4(x) \\end{bmatrix} = \\begin{bmatrix} A(x) \\\\ A'(x) \\\\ B(x) \\\\ B'(x) \\end{bmatrix}$$\nThe original system is then rewritten as a system of four first-order ODEs, $\\mathbf{y}'(x) = \\mathbf{f}(x, \\mathbf{y}(x))$:\n$$\n\\begin{cases}\ny_1'(x) = y_2(x) \\\\\ny_2'(x) = \\frac{k}{D_A} y_1(x) y_3(x) \\\\\ny_3'(x) = y_4(x) \\\\\ny_4'(x) = \\frac{k}{D_B} y_1(x) y_3(x)\n\\end{cases}\n$$\nThe associated boundary conditions are applied at the endpoints of the domain $x \\in [0, 1]$:\n$$y_1(0) = A_L, \\quad y_1(1) = A_R, \\quad y_3(0) = B_L, \\quad y_3(1) = B_R$$\n\nThis system is a classical two-point boundary value problem. It shall be solved using a collocation method, which is a robust technique for such problems. The `scipy.integrate.solve_bvp` function from the SciPy library provides an implementation of this method. This solver requires three main components:\n1.  A function implementing the first-order ODE system $\\mathbf{f}(x, \\mathbf{y})$.\n2.  A function defining the residuals of the boundary conditions. For this problem, the residuals are $y_1(0) - A_L$, $y_1(1) - A_R$, $y_3(0) - B_L$, and $y_3(1) - B_R$. The solver will find a solution that makes these residuals zero.\n3.  An initial guess for the solution profile across a mesh of points in the domain $[0, 1]$. A linear interpolation between the boundary values provides a suitable and simple initial guess. For example, the initial guess for $A(x)$ is $A_{guess}(x) = A_L + (A_R - A_L)x$.\n\nSpecial attention is given to Test Case 2, where the reaction rate $k=0$. In this case, the governing equations simplify to $A''(x) = 0$ and $B''(x) = 0$. The solutions are linear functions of $x$, fully determined by their boundary conditions: $A(x) = (A_R-A_L)x + A_L$ and $B(x) = (B_R-B_L)x + B_L$. For this case, the integral $I$ can be computed analytically, yielding $I \\approx 0.166667$. This analytical result serves as a valuable verification point for the correctness of the general numerical implementation. The numerical solver must properly handle the $k=0$ case and reproduce this result.\n\nAfter the BVP solver finds the solution functions $A(x)$ and $B(x)$, represented as continuous splines, the final quantity $I = \\int_{0}^{1} A(x) B(x) dx$ is computed. This is achieved by evaluating the product $A(x)B(x)$ on a sufficiently dense grid of points over the interval $[0, 1]$ and then applying a high-order numerical quadrature rule, such as Simpson's rule, provided by `scipy.integrate.simpson`.\n\nThe procedure is executed for each of the three test cases specified. The resulting value of $I$ for each case is rounded to six digits after the decimal point as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_bvp, simpson\n\ndef solve():\n    \"\"\"\n    Solves the coupled reaction-diffusion BVP for three test cases\n    and computes the specified integral.\n    \"\"\"\n    # Test cases are defined as tuples of parameters:\n    # (D_A, D_B, k, A_L, A_R, B_L, B_R)\n    test_cases = [\n        # Test Case 1 (general case)\n        (1.0, 0.5, 2.0, 1.0, 0.2, 0.3, 1.2),\n        # Test Case 2 (no reaction edge case)\n        (1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0),\n        # Test Case 3 (strongly unequal diffusivities)\n        (10.0, 0.1, 1.5, 0.8, 0.6, 0.2, 0.9),\n    ]\n\n    results = []\n    for case in test_cases:\n        DA, DB, k, AL, AR, BL, BR = case\n\n        # Define the ODE system dy/dx = f(x, y).\n        # The state vector y is [A, A', B, B'].\n        def ode_system(x, y):\n            # Unpack state variables for clarity\n            A, A_prime, B, B_prime = y[0], y[1], y[2], y[3]\n            \n            # The system of first-order ODEs\n            # A'' = (k/DA) * A * B\n            # B'' = (k/DB) * A * B\n            A_double_prime = (k / DA) * A * B if DA > 0 else 0\n            B_double_prime = (k / DB) * A * B if DB > 0 else 0\n            \n            # Return derivatives as a column vector\n            return np.vstack((A_prime, A_double_prime, B_prime, B_double_prime))\n\n        # Define the boundary conditions residual function.\n        # The solver aims to make the return values of this function zero.\n        def bc(ya, yb):\n            # ya: solution at x=0, yb: solution at x=1\n            # y_i[0] is A, y_i[2] is B\n            return np.array([ya[0] - AL,   # A(0) = AL\n                             yb[0] - AR,   # A(1) = AR\n                             ya[2] - BL,   # B(0) = BL\n                             yb[2] - BR])  # B(1) = BR\n\n        # Set up an initial mesh and a guess for the solution.\n        # A linear interpolation between boundary values is a robust guess.\n        x_mesh = np.linspace(0, 1, 50)\n        y_guess = np.zeros((4, x_mesh.size))\n        \n        # Guess for A(x) and A'(x)\n        y_guess[0, :] = AL + (AR - AL) * x_mesh\n        y_guess[1, :] = AR - AL\n        \n        # Guess for B(x) and B'(x)\n        y_guess[2, :] = BL + (BR - BL) * x_mesh\n        y_guess[3, :] = BR - BL\n        \n        # Solve the boundary value problem.\n        # tol sets the desired accuracy of the solution.\n        sol = solve_bvp(ode_system, bc, x_mesh, y_guess, tol=1e-7)\n\n        # Evaluate the solution on a fine grid for accurate integration.\n        x_eval = np.linspace(0, 1, 501)\n        y_eval = sol.sol(x_eval)\n        \n        # Extract the solution components A(x) and B(x).\n        A_x = y_eval[0]\n        B_x = y_eval[2]\n        \n        # Compute the integral I = integral(A(x)*B(x)) dx from 0 to 1\n        # using Simpson's rule for high accuracy.\n        integrand = A_x * B_x\n        integral_val = simpson(integrand, x_eval)\n        \n        results.append(integral_val)\n\n    # Format the final results as specified in the problem statement.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2375141"}]}