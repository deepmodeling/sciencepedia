{"hands_on_practices": [{"introduction": "While many introductory examples of finite difference methods are presented on uniform grids, real-world applications often involve complex geometries or adaptive meshes where grid spacing is non-uniform. This practice builds a crucial, foundational skill by guiding you through the derivation of a second-order accurate approximation for the second derivative, $u_{xx}$, on a non-uniform grid from first principles using Taylor series analysis [@problem_id:2392901]. Understanding this derivation is key to appreciating how the local grid quality impacts the accuracy of a simulation and is essential for developing robust numerical solvers.", "problem": "Consider a smooth scalar field $u(x)$ representing, for example, the displacement field in the one-dimensional linear wave equation, where the spatial operator involves the second spatial derivative $u_{xx}$. Let $x_{i-1}<x_{i}<x_{i+1}$ be three consecutive, generally non-uniform, grid points with spacings $h_{i-1}=x_{i}-x_{i-1}$ and $h_{i}=x_{i+1}-x_{i}$. Assume that $u$ is at least four times continuously differentiable in a neighborhood of $x_{i}$. You may also assume, when discussing asymptotic consistency, that the grid is generated by a twice continuously differentiable, strictly increasing mapping $x(\\xi)$ from a uniform computational grid with spacing $\\Delta \\xi$, so that $h=\\max\\{h_{i-1},h_{i}\\}\\to 0$ as $\\Delta \\xi\\to 0$ and $h_{i}-h_{i-1}=\\mathcal{O}(h^{2})$.\n\nDerive a three-point finite difference approximation at $x_{i}$ of the form $a\\,u(x_{i-1})+b\\,u(x_{i})+c\\,u(x_{i+1})$ that approximates $u_{xx}(x_{i})$ with second-order consistency under the smooth-grid assumption stated above. Determine the leading terms in the local truncation error in terms of $h_{i-1}$, $h_{i}$, and derivatives of $u$ evaluated at $x_{i}$, and state the condition under which the approximation is second-order accurate.\n\nAnswer format:\n- Provide your final answer as a single closed-form analytical expression for the finite difference approximation to $u_{xx}(x_{i})$ in terms of $u(x_{i-1})$, $u(x_{i})$, $u(x_{i+1})$, $h_{i-1}$, and $h_{i}$.\n- No units are required.", "solution": "The problem statement is scrutinized and found to be valid. It is scientifically grounded in the principles of numerical analysis, well-posed with sufficient and consistent data, and expressed in objective mathematical language. It does not violate any of the criteria for invalidity. We may therefore proceed with the derivation.\n\nOur objective is to determine the coefficients $a$, $b$, and $c$ for a finite difference approximation of the form $L[u](x_i) = a\\,u(x_{i-1})+b\\,u(x_{i})+c\\,u(x_{i+1})$ that approximates the second derivative $u_{xx}(x_i) \\equiv u''(x_i)$. The function $u(x)$ is assumed to be at least four times continuously differentiable. We employ Taylor series expansions for $u(x_{i+1})$ and $u(x_{i-1})$ around the point $x_i$. Let $h_i = x_{i+1} - x_i$ and $h_{i-1} = x_i - x_{i-1}$. For brevity in the derivation, we denote $u(x_k)$ as $u_k$ and the derivatives of $u$ at $x_i$ as $u'_i, u''_i, u'''_i, u^{(4)}_i$.\n\nThe Taylor series expansions are:\n$$u(x_{i+1}) = u_{i+1} = u_i + h_i u'_i + \\frac{h_i^2}{2} u''_i + \\frac{h_i^3}{6} u'''_i + \\frac{h_i^4}{24} u^{(4)}_i + \\mathcal{O}(h_i^5)$$\n$$u(x_{i-1}) = u_{i-1} = u_i - h_{i-1} u'_i + \\frac{h_{i-1}^2}{2} u''_i - \\frac{h_{i-1}^3}{6} u'''_i + \\frac{h_{i-1}^4}{24} u^{(4)}_i + \\mathcal{O}(h_{i-1}^5)$$\n\nWe form the linear combination and substitute these expansions:\n$$a u_{i-1} + b u_i + c u_{i+1} = a\\left(u_i - h_{i-1} u'_i + \\frac{h_{i-1}^2}{2} u''_i - \\dots\\right) + b u_i + c\\left(u_i + h_i u'_i + \\frac{h_i^2}{2} u''_i + \\dots\\right)$$\n\nGrouping terms by the derivatives of $u$ at $x_i$:\n$$a u_{i-1} + b u_i + c u_{i+1} = (a+b+c)u_i + (c h_i - a h_{i-1})u'_i + \\left(\\frac{c h_i^2}{2} + \\frac{a h_{i-1}^2}{2}\\right)u''_i + \\left(\\frac{c h_i^3}{6} - \\frac{a h_{i-1}^3}{6}\\right)u'''_i + \\left(\\frac{c h_i^4}{24} + \\frac{a h_{i-1}^4}{24}\\right)u^{(4)}_i + \\dots$$\n\nTo ensure that this expression approximates $u''_i$, we match the coefficients of the derivatives:\n$1$. Coefficient of $u_i$: $a+b+c=0$\n$2$. Coefficient of $u'_i$: $c h_i - a h_{i-1} = 0$\n$3$. Coefficient of $u''_i$: $\\frac{c h_i^2}{2} + \\frac{a h_{i-1}^2}{2} = 1$\n\nFrom equation $(2)$, we find $a = c \\frac{h_i}{h_{i-1}}$. Substituting this into equation $(3)$:\n$$\\frac{c h_i^2}{2} + \\frac{(c h_i/h_{i-1}) h_{i-1}^2}{2} = 1$$\n$$\\frac{c}{2} (h_i^2 + h_i h_{i-1}) = 1$$\n$$\\frac{c h_i}{2} (h_i + h_{i-1}) = 1$$\nThis yields the coefficient $c$:\n$$c = \\frac{2}{h_i(h_i + h_{i-1})}$$\nNow we find $a$ using the relation from equation $(2)$:\n$$a = c \\frac{h_i}{h_{i-1}} = \\frac{2}{h_i(h_i + h_{i-1})} \\frac{h_i}{h_{i-1}} = \\frac{2}{h_{i-1}(h_i + h_{i-1})}$$\nFinally, we find $b$ from equation $(1)$:\n$$b = -a - c = -\\left(\\frac{2}{h_{i-1}(h_i + h_{i-1})} + \\frac{2}{h_i(h_i + h_{i-1})}\\right)$$\n$$b = -\\frac{2}{h_i + h_{i-1}}\\left(\\frac{1}{h_{i-1}} + \\frac{1}{h_i}\\right) = -\\frac{2}{h_i + h_{i-1}}\\left(\\frac{h_i + h_{i-1}}{h_i h_{i-1}}\\right) = -\\frac{2}{h_i h_{i-1}}$$\n\nThe finite difference approximation for $u_{xx}(x_i)$ is therefore:\n$$L[u](x_i) = \\frac{2}{h_{i-1}(h_i + h_{i-1})} u_{i-1} - \\frac{2}{h_i h_{i-1}} u_i + \\frac{2}{h_i(h_i + h_{i-1})} u_{i+1}$$\nThis expression can be rearranged into a more intuitive form:\n$$L[u](x_i) = \\frac{2}{h_i + h_{i-1}} \\left[ \\frac{u_{i+1} - u_i}{h_i} - \\frac{u_i - u_{i-1}}{h_{i-1}} \\right]$$\nThis shows the operator as a difference of first-order divided differences, normalized by the average spacing $\\frac{1}{2}(h_i+h_{i-1})$.\n\nThe local truncation error, $\\tau_i$, is defined by $L[u](x_i) = u''(x_i) + \\tau_i$. The leading terms of $\\tau_i$ are given by the higher-order terms in the Taylor expansion that were not cancelled.\n$$\\tau_i = \\left(\\frac{c h_i^3}{6} - \\frac{a h_{i-1}^3}{6}\\right)u'''_i + \\left(\\frac{c h_i^4}{24} + \\frac{a h_{i-1}^4}{24}\\right)u^{(4)}_i + \\mathcal{O}(h^3)$$\nwhere $h = \\max\\{h_i, h_{i-1}\\}$. We compute the coefficients.\nThe coefficient of $u'''_i$ is:\n$$\\frac{1}{6}(c h_i^3 - a h_{i-1}^3) = \\frac{1}{6}\\left(\\frac{2 h_i^3}{h_i(h_i + h_{i-1})} - \\frac{2 h_{i-1}^3}{h_{i-1}(h_i + h_{i-1})}\\right) = \\frac{1}{3(h_i + h_{i-1})}(h_i^2 - h_{i-1}^2) = \\frac{1}{3}(h_i - h_{i-1})$$\nThe coefficient of $u^{(4)}_i$ is:\n$$\\frac{1}{24}(c h_i^4 + a h_{i-1}^4) = \\frac{1}{24}\\left(\\frac{2 h_i^4}{h_i(h_i + h_{i-1})} + \\frac{2 h_{i-1}^4}{h_{i-1}(h_i + h_{i-1})}\\right) = \\frac{1}{12(h_i + h_{i-1})}(h_i^3 + h_{i-1}^3)$$\nUsing the identity $h_i^3 + h_{i-1}^3 = (h_i+h_{i-1})(h_i^2 - h_i h_{i-1} + h_{i-1}^2)$, this simplifies to:\n$$\\frac{1}{12}(h_i^2 - h_i h_{i-1} + h_{i-1}^2)$$\nThus, the leading terms of the local truncation error are:\n$$\\tau_i = \\frac{h_i - h_{i-1}}{3} u'''(x_i) + \\frac{h_i^2 - h_i h_{i-1} + h_{i-1}^2}{12} u^{(4)}(x_i) + \\mathcal{O}(h^3)$$\nThe order of consistency is determined by the lowest power of $h$ in $\\tau_i$. The first term is $\\mathcal{O}(h_i - h_{i-1})$ and the second term is $\\mathcal{O}(h^2)$. For a general non-uniform grid, $h_i - h_{i-1} = \\mathcal{O}(h)$, so the scheme is first-order consistent.\nFor the scheme to be second-order consistent, the truncation error must be $\\mathcal{O}(h^2)$. This requires the coefficient of the $u'''(x_i)$ term to be of order $\\mathcal{O}(h^2)$. The condition is therefore $h_i - h_{i-1} = \\mathcal{O}(h^2)$. This is precisely the smooth-grid assumption provided in the problem statement. Under this condition, the leading part of the truncation error is $\\mathcal{O}(h^2)$, and the approximation is second-order accurate.", "answer": "$$\\boxed{\\frac{2}{h_i+h_{i-1}} \\left( \\frac{u(x_{i+1})-u(x_i)}{h_i} - \\frac{u(x_i)-u(x_{i-1})}{h_{i-1}} \\right)}$$", "id": "2392901"}, {"introduction": "With the fundamentals of spatial discretization in hand, we can now assemble a complete simulation to model a fascinating physical phenomenon: resonance. This exercise challenges you to implement an explicit finite difference scheme for the one-dimensional wave equation with a forcing term tuned to a natural frequency of the system, leading to a dramatic amplification of the wave amplitude over time [@problem_id:2392923]. By comparing your numerical results against a derived exact solution, you will not only visualize resonance but also gain practical experience in code verification and appreciate the critical importance of the Courant-Friedrichs-Lewy (CFL) stability condition in time-dependent simulations.", "problem": "Consider the one-dimensional wave equation with a resonant separable forcing on a finite interval with homogeneous Dirichlet boundary conditions. Let the spatial domain be $[0,L]$ and define the wave field $u(x,t)$ by the partial differential equation\n$$\nu_{tt}(x,t) - c^2 u_{xx}(x,t) = \\sin(k_n x)\\,\\sin(\\omega_n t),\n$$\nfor $x \\in (0,L)$ and $t \\ge 0$, with boundary conditions $u(0,t)=0$ and $u(L,t)=0$, and initial conditions $u(x,0)=0$ and $u_t(x,0)=0$. Let $c$ denote the constant wave speed, and define the $n$th wavenumber and natural frequency by $k_n = \\frac{n\\pi}{L}$ and $\\omega_n = c k_n$. All quantities are to be treated as dimensionless, and all trigonometric arguments are in radians.\n\nYour task is to derive and implement a second-order accurate explicit finite difference scheme in both space and time to approximate $u(x,t)$, then compare the numerical solution at a specified final time $T$ to the exact solution obtained by projecting the problem onto the resonant eigenmode. You must proceed from the following fundamental base:\n- The wave equation $u_{tt} = c^2 u_{xx} + f(x,t)$ and its homogeneous Dirichlet boundary conditions on $[0,L]$.\n- The eigenfunctions $\\sin\\left(\\frac{m\\pi x}{L}\\right)$ for $m \\in \\mathbb{N}$ form an orthogonal basis on $[0,L]$ for functions vanishing at $x=0$ and $x=L$.\n- Central difference approximations in space and time that are second order accurate.\n\nDo not use any pre-quoted scheme or closed-form solution in the problem statement. Instead, derive:\n- A second-order central finite difference scheme on a uniform spatial grid with $N_x$ interior nodes and spacing $\\Delta x = \\frac{L}{N_x+1}$, with homogeneous Dirichlet boundary conditions enforced at the endpoints, and a uniform time step $\\Delta t$.\n- A stability constraint of Courant–Friedrichs–Lewy (CFL) type of the form $\\lambda = \\frac{c\\,\\Delta t}{\\Delta x} \\le \\text{constant}$ for stability of the explicit scheme, and choose $\\Delta t$ by a specified CFL number.\n- The exact solution at resonance by projecting the forcing onto the $n$th eigenmode and solving the resulting scalar initial value problem for the modal amplitude with zero initial data.\n\nNumerical requirements and definitions:\n- Use a uniform spatial grid with $N_x$ interior points; thus, the total grid has indices $j=0,1,\\dots,N_x+1$, where $j=0$ and $j=N_x+1$ are the boundary nodes at $x=0$ and $x=L$, respectively, and the interior nodes are $j=1,\\dots,N_x$ with $x_j = j\\,\\Delta x$.\n- Choose $\\Delta t$ from a target CFL number $\\text{CFL}$ via $\\Delta t_0 = \\text{CFL}\\,\\Delta x / c$. Then set the number of time steps to $M = \\lceil T/\\Delta t_0 \\rceil$ and redefine $\\Delta t = T/M$ so that the final time is exactly $T$. This implies the realized CFL number is $\\lambda = c\\,\\Delta t/\\Delta x$, which may be slightly below the target CFL.\n- Evolve the explicit scheme from $t=0$ to $t=T$ with the given initial and boundary conditions.\n- Define the discrete spatial $L^2$-norm at time $t$ for a grid function $w_j$ on interior points by\n$$\n\\|w(\\cdot,t)\\|_{2,\\Delta x} = \\sqrt{\\Delta x \\sum_{j=1}^{N_x} w_j^2 }.\n$$\n- At final time $T$, compute the relative error\n$$\n\\varepsilon = \\frac{\\|u_{\\text{num}}(\\cdot,T) - u_{\\text{exact}}(\\cdot,T)\\|_{2,\\Delta x}}{\\|u_{\\text{exact}}(\\cdot,T)\\|_{2,\\Delta x}},\n$$\nwhere $u_{\\text{exact}}(x,T)$ is the exact resonant solution obtained by the single-mode projection for the given parameters. If the denominator is $0$, report the absolute error $\\|u_{\\text{num}}(\\cdot,T)\\|_{2,\\Delta x}$.\n\nTest suite:\nFor each parameter set $(L,c,n,N_x,\\text{CFL},T)$ listed below, compute the relative error $\\varepsilon$ as defined above. Use radians for all trigonometric evaluations.\n- Case $1$ (happy path): $(L,c,n,N_x,\\text{CFL},T) = (1,1,1,200,0.9,2)$.\n- Case $2$ (CFL boundary): $(L,c,n,N_x,\\text{CFL},T) = (1,1,3,150,1.0,1.5)$.\n- Case $3$ (different $L$ and $c$): $(L,c,n,N_x,\\text{CFL},T) = (2,0.8,2,128,0.95,1.75)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of floating-point numbers enclosed in square brackets, in the order of the test cases above, for example, $\"[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3]\"$. All quantities are dimensionless.", "solution": "We start from the fundamental wave equation $u_{tt}(x,t) = c^2 u_{xx}(x,t) + f(x,t)$ on $x \\in (0,L)$ with homogeneous Dirichlet boundary conditions $u(0,t)=0$ and $u(L,t)=0$, and initial data $u(x,0)=0$ and $u_t(x,0)=0$. The forcing is $f(x,t) = \\sin(k_n x)\\,\\sin(\\omega_n t)$ with $k_n = \\frac{n\\pi}{L}$ and $\\omega_n = c k_n$. The standard eigenfunctions for this boundary value problem are $\\phi_m(x) = \\sin(k_m x)$ with $k_m = \\frac{m \\pi}{L}$ for $m \\in \\mathbb{N}$, forming an orthogonal basis on $[0,L]$ for the Dirichlet problem.\n\nPrinciple-based derivation of the exact solution via modal projection:\n- Project $u(x,t)$ onto the eigenfunctions. Since the forcing is exactly the $n$th eigenmode, only the $n$th mode is excited by orthogonality. Seek a solution of the form $u(x,t) = a(t)\\,\\sin(k_n x)$, which satisfies the homogeneous Dirichlet boundary conditions automatically.\n- Substitute into the partial differential equation:\n$$\na''(t)\\,\\sin(k_n x) - c^2 (-k_n^2)\\,a(t)\\,\\sin(k_n x) = \\sin(k_n x)\\,\\sin(\\omega_n t).\n$$\n- For $x \\in (0,L)$ with $\\sin(k_n x) \\neq 0$ generically, divide by $\\sin(k_n x)$ to obtain the scalar ordinary differential equation\n$$\na''(t) + \\omega_n^2 a(t) = \\sin(\\omega_n t),\n$$\nwith $a(0) = 0$ and $a'(0) = 0$, because $u(x,0)=0$ and $u_t(x,0)=0$ imply the same for $a(t)$.\n- This is a resonant, forced simple harmonic oscillator. A particular solution for resonance can be found by the method of undetermined coefficients. Propose $a_p(t) = A t \\cos(\\omega_n t)$, compute derivatives $a_p'(t) = A \\cos(\\omega_n t) - A \\omega_n t \\sin(\\omega_n t)$ and $a_p''(t) = -2 A \\omega_n \\sin(\\omega_n t) - A \\omega_n^2 t \\cos(\\omega_n t)$, and substitute into $a_p''(t) + \\omega_n^2 a_p(t)$ to get $-2 A \\omega_n \\sin(\\omega_n t)$. Setting this equal to $\\sin(\\omega_n t)$ yields $-2 A \\omega_n = 1$ and thus $A = -\\frac{1}{2\\omega_n}$. The homogeneous solution is $a_h(t) = C_1 \\cos(\\omega_n t) + C_2 \\sin(\\omega_n t)$.\n- Apply $a(0)=0$ to obtain $C_1=0$. Compute $a'(t) = C_2 \\omega_n \\cos(\\omega_n t) - \\frac{1}{2\\omega_n}\\cos(\\omega_n t) + \\frac{t}{2}\\sin(\\omega_n t)$ and apply $a'(0)=0$ to obtain $C_2 = \\frac{1}{2\\omega_n^2}$. Therefore,\n$$\na(t) = \\frac{1}{2\\omega_n^2}\\sin(\\omega_n t) - \\frac{t}{2\\omega_n}\\cos(\\omega_n t),\n$$\nand the exact solution is\n$$\nu_{\\text{exact}}(x,t) = \\left(\\frac{1}{2\\omega_n^2}\\sin(\\omega_n t) - \\frac{t}{2\\omega_n}\\cos(\\omega_n t)\\right)\\sin(k_n x).\n$$\n\nPrinciple-based derivation of the second-order finite difference scheme:\n- Discretize space on a uniform grid with $N_x$ interior points: $x_j = j \\Delta x$ for $j=0,1,\\dots,N_x+1$, where $\\Delta x = \\frac{L}{N_x+1}$, and $u_j^m \\approx u(x_j, t_m)$ with $t_m = m \\Delta t$.\n- Enforce homogeneous Dirichlet boundary conditions as $u_0^m = 0$ and $u_{N_x+1}^m = 0$ for all $m$.\n- Approximate the second time derivative and the second spatial derivative at interior grid points using centered differences:\n$$\n\\frac{u_j^{m+1} - 2u_j^m + u_j^{m-1}}{\\Delta t^2} \\approx u_{tt}(x_j,t_m), \\quad \\frac{u_{j+1}^m - 2u_j^m + u_{j-1}^m}{\\Delta x^2} \\approx u_{xx}(x_j,t_m).\n$$\n- Set $f_j^m = \\sin(k_n x_j)\\,\\sin(\\omega_n t_m)$ and equate:\n$$\n\\frac{u_j^{m+1} - 2u_j^m + u_j^{m-1}}{\\Delta t^2} = c^2 \\frac{u_{j+1}^m - 2u_j^m + u_{j-1}^m}{\\Delta x^2} + f_j^m.\n$$\n- Solve for the update at interior nodes:\n$$\nu_j^{m+1} = 2u_j^m - u_j^{m-1} + \\lambda^2 \\left(u_{j+1}^m - 2u_j^m + u_{j-1}^m\\right) + \\Delta t^2\\, f_j^m,\n$$\nwhere $\\lambda = \\frac{c\\,\\Delta t}{\\Delta x}$ is the Courant number. For initialization, the given initial conditions $u(x,0)=0$ and $u_t(x,0)=0$ imply $u_j^0=0$ and $u_j^1 = u_j^0 + \\Delta t\\,u_t(x_j,0) + \\frac{\\Delta t^2}{2}\\left(c^2 u_{xx}(x_j,0) + f(x_j,0)\\right) = 0$, since $u_{xx}(x,0)=0$ and $f(x,0)=0$.\n- The Courant–Friedrichs–Lewy (CFL) stability condition for the one-dimensional explicit second-order wave scheme is $\\lambda \\le 1$.\n\nAlgorithmic design:\n- Given $(L,c,n,N_x,\\text{CFL},T)$, compute $\\Delta x = \\frac{L}{N_x+1}$ and a tentative time step $\\Delta t_0 = \\text{CFL}\\,\\Delta x / c$. Choose the number of steps $M = \\lceil T/\\Delta t_0 \\rceil$ and then set $\\Delta t = T/M$ so that the final time is exactly $T$. This yields a realized Courant number $\\lambda = \\frac{c\\,\\Delta t}{\\Delta x} \\le \\text{CFL}$.\n- Initialize $u^0$ and $u^1$ as described.\n- For each time step $m=1,2,\\dots,M-1$, compute $u^{m+1}$ on interior nodes using the update formula with $f_j^m = \\sin(k_n x_j)\\sin(\\omega_n t_m)$ and set boundary values to zero.\n- At $t=T$, evaluate $u_{\\text{exact}}(x_j,T)$ using the resonant exact formula above. Compute the discrete $L^2$ relative error $\\varepsilon$ over interior nodes:\n$$\n\\varepsilon = \\frac{\\sqrt{\\Delta x \\sum_{j=1}^{N_x} \\left(u_j^M - u_{\\text{exact}}(x_j,T)\\right)^2}}{\\sqrt{\\Delta x \\sum_{j=1}^{N_x} \\left(u_{\\text{exact}}(x_j,T)\\right)^2}},\n$$\nwith the safeguard that if the denominator is $0$, report the absolute error in the numerator.\n\nTest suite and coverage:\n- Case $1$ uses $\\text{CFL}=0.9$ and a relatively fine grid to provide a standard accuracy check.\n- Case $2$ uses $\\text{CFL}=1.0$ at the stability boundary and a different mode $n=3$ to test stability and phase accuracy at the limit.\n- Case $3$ uses a different domain length $L=2$ and wave speed $c=0.8$ to test parameter robustness.\n\nThe program will implement this algorithm for the three test cases and print a single line with a Python-style list of the three relative errors in order.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_case(L, c, n, Nx, CFL, T):\n    # Spatial grid\n    dx = L / (Nx + 1)\n    x = np.linspace(0.0, L, Nx + 2)  # includes boundaries\n    interior = slice(1, Nx + 1)\n\n    # Wavenumber and frequency (radians)\n    k = n * np.pi / L\n    omega = c * k\n\n    # Time step setup from target CFL\n    if c == 0:\n        raise ValueError(\"Wave speed c must be nonzero.\")\n    dt0 = CFL * dx / c\n    if dt0 <= 0:\n        raise ValueError(\"Nonpositive tentative time step.\")\n    M = int(np.ceil(T / dt0)) if T > 0 else 1\n    # Ensure at least one step; handle T=0 gracefully\n    if M <= 0:\n        M = 1\n    dt = T / M if T > 0 else 0.0\n    lam = c * dt / dx  # realized Courant number\n\n    # Initialize arrays\n    u_old = np.zeros(Nx + 2)\n    u_cur = np.zeros(Nx + 2)\n    u_new = np.zeros(Nx + 2)\n\n    # Initial conditions: u(x,0)=0, u_t(x,0)=0 -> u^0 = 0, u^1 = 0 (since forcing at t=0 is zero)\n    # Time stepping\n    for m in range(1, M + 1):\n        t_m = (m - 1) * dt  # time level for f at central time in the scheme\n        # Compute forcing at time t_m on interior nodes\n        f = np.sin(k * x) * np.sin(omega * t_m)\n        # Update interior nodes\n        u_new[interior] = (\n            2.0 * u_cur[interior]\n            - u_old[interior]\n            + (lam ** 2)\n            * (\n                u_cur[interior.start + 1 : interior.stop + 1]\n                - 2.0 * u_cur[interior]\n                + u_cur[interior.start - 1 : interior.stop - 1]\n            )\n            + (dt ** 2) * f[interior]\n        )\n        # Enforce boundary conditions (Dirichlet)\n        u_new[0] = 0.0\n        u_new[-1] = 0.0\n        # Shift time levels\n        u_old, u_cur, u_new = u_cur, u_new, u_old  # reuse arrays to avoid reallocation\n\n    # Exact solution at t = T for resonance\n    # a(T) = (1/(2*omega^2)) * sin(omega*T) - (T/(2*omega)) * cos(omega*T)\n    # Handle omega=0 (should not occur because c>0 and n>=1 and L>0), but guard anyway.\n    if omega == 0.0:\n        a_T = 0.0\n    else:\n        a_T = (1.0 / (2.0 * omega ** 2)) * np.sin(omega * T) - (T / (2.0 * omega)) * np.cos(omega * T)\n    u_exact = a_T * np.sin(k * x)\n\n    # Compute discrete L2 norms over interior nodes\n    diff = u_cur[interior] - u_exact[interior]\n    num = np.sqrt(dx * np.dot(diff, diff))\n    denom = np.sqrt(dx * np.dot(u_exact[interior], u_exact[interior]))\n    if denom > 0:\n        rel_err = num / denom\n    else:\n        rel_err = num\n    return float(rel_err)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (L, c, n, Nx, CFL, T)\n    test_cases = [\n        (1.0, 1.0, 1, 200, 0.9, 2.0),     # Case 1: happy path\n        (1.0, 1.0, 3, 150, 1.0, 1.5),     # Case 2: CFL boundary\n        (2.0, 0.8, 2, 128, 0.95, 1.75),   # Case 3: different L and c\n    ]\n\n    results = []\n    for L, c, n, Nx, CFL, T in test_cases:\n        err = simulate_case(L, c, n, Nx, CFL, T)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2392923"}, {"introduction": "Moving into more realistic physical settings often requires using coordinate systems, like spherical or cylindrical coordinates, that contain singularities. A naive application of finite difference schemes can fail spectacularly at such points. This advanced practice introduces a powerful technique to circumvent this issue for the spherically symmetric wave equation by applying an analytical change of variables, $v=ru$, to transform the governing equation into a simple, singularity-free form before discretization [@problem_id:2392876]. This exercise beautifully illustrates the synergy between analytical insight and numerical computation, a hallmark of sophisticated engineering analysis.", "problem": "Consider the one-dimensional spherically symmetric wave equation\n$$\nu_{tt}(r,t) = c^2\\left(u_{rr}(r,t) + \\frac{2}{r}u_r(r,t)\\right), \\quad r \\in [0,R], \\ t \\ge 0,\n$$\nwith the regularity requirement that the solution is finite at the origin. All quantities are dimensionless. The initial displacement and initial velocity are specified by\n$$\nu(r,0) = \\frac{1}{r} f(r), \\quad u_t(r,0) = 0,\n$$\nwhere\n$$\nf(r) = r \\exp\\!\\left(-\\frac{(r - r_c)^2}{2\\sigma^2}\\right),\n$$\nand the value at the origin must be interpreted as the limit\n$$\nu(0,0) = \\lim_{r \\to 0^+} \\frac{f(r)}{r}.\n$$\nAt the outer boundary, impose the homogeneous Dirichlet condition\n$$\nu(R,t) = 0 \\quad \\text{for all } t \\ge 0.\n$$\nYou must devise a numerically stable and consistent treatment for the singular term at the origin, implement a finite difference time-domain solver on a uniform grid in space and time, and evolve the solution to a specified final time. For error assessment, compare the numerical solution against the exact solution constructed as follows. Define the odd extension of $f$ to the real line by\n$$\n\\tilde{f}(x) = \\begin{cases}\nf(x), & x \\ge 0,\\\\\n- f(-x), & x < 0,\n\\end{cases}\n$$\nand set\n$$\nv(r,t) = \\frac{1}{2}\\left[\\tilde{f}(r - c t) + \\tilde{f}(r + c t)\\right], \\quad r \\ge 0, \\ t \\ge 0.\n$$\nThen the exact displacement is\n$$\nu_{\\text{exact}}(r,t) = \\begin{cases}\n\\displaystyle \\frac{v(r,t)}{r}, & r > 0,\\\\[6pt]\n\\displaystyle \\left.\\frac{\\partial v}{\\partial r}\\right|_{r=0,t}, & r = 0,\n\\end{cases}\n$$\nwith the derivative at the origin given by\n$$\nu_{\\text{exact}}(0,t) = f'(c t), \\quad f'(r) = \\exp\\!\\left(-\\frac{(r - r_c)^2}{2\\sigma^2}\\right) - \\frac{r(r - r_c)}{\\sigma^2} \\exp\\!\\left(-\\frac{(r - r_c)^2}{2\\sigma^2}\\right).\n$$\nUse the following test suite of parameter values; all quantities are dimensionless:\n\n- Common parameters for all tests: $c = 1.0$, $R = 2.0$, $r_c = 0.6$, $\\sigma = 0.08$.\n- Test 1 (interior stability, sub-Courant): $N = 400$ spatial subintervals on $[0,R]$; spatial step $\\Delta r = R/N$; time step $\\Delta t = 0.9 \\, \\Delta r / c$; number of time steps $M = 50$; final time $T = M \\Delta t$.\n- Test 2 (boundary Courant case): $N = 400$; $\\Delta r = R/N$; time step $\\Delta t = 1.0 \\, \\Delta r / c$; $M = 50$; $T = M \\Delta t$.\n- Test 3 (super-Courant stress test for stability detection): $N = 300$; $\\Delta r = R/N$; time step $\\Delta t = 1.05 \\, \\Delta r / c$; $M = 200$; $T = M \\Delta t$.\n\nYour program must:\n\n- Implement a finite difference solver that produces a numerical approximation $u_{\\text{num}}(r_i, T)$ at the grid points $r_i = i \\Delta r$ for $i = 0,1,\\dots,N$.\n- For Test $1$ and Test $2$, compute the root-mean-square error\n$$\nE = \\left(\\frac{1}{N+1} \\sum_{i=0}^N \\left[u_{\\text{num}}(r_i,T) - u_{\\text{exact}}(r_i,T)\\right]^2 \\right)^{1/2}.\n$$\n- For Test $3$, return a boolean indicating whether the numerical solution remained finite and bounded by $10^6$ in absolute value at all grid points and at all time steps up to and including the final time $T$; return $\\text{True}$ if it remained bounded and finite, otherwise return $\\text{False}$.\n- Additionally, for Test $1$, report the absolute error at the origin at final time,\n$E_0 = |u_{\\text{num}}(0,T) - u_{\\text{exact}}(0,T)|$.\n\nFinal output format: Your program should produce a single line of output containing a list with four entries in the order $[E_{\\text{Test 1}}, E_{\\text{Test 2}}, \\text{Stable}_{\\text{Test 3}}, E_{0,\\text{Test 1}}]$, printed as a comma-separated list enclosed in square brackets (for example, $[0.00123,0.00111,True,0.00045]$). All outputs are dimensionless real numbers except the third entry, which is a boolean. Angles are not involved in this problem. No other units are to be used or inferred.", "solution": "The problem statement poses a well-defined initial-boundary value problem for the one-dimensional spherically symmetric wave equation. It is scientifically sound, self-contained, and objective. All parameters, conditions, and requirements for verification are specified. The provided \"exact\" solution, based on d'Alembert's formula, is appropriate for the specified simulation times, as reflections from the outer boundary at $r=R$ do not have time to influence the solution domain in the test cases where error is computed. The problem is therefore valid, and I shall proceed with its solution.\n\nThe governing partial differential equation (PDE) is\n$$\nu_{tt} = c^2\\left(u_{rr} + \\frac{2}{r}u_r\\right)\n$$\nwhere $u=u(r,t)$, and subscripts denote partial differentiation. The term $\\frac{2}{r}u_r$ presents a singularity at the origin, $r=0$, which requires special treatment in a numerical scheme.\n\nA robust and standard method to handle this singularity is to introduce a change of variable. Let $v(r,t) = r u(r,t)$. We can express the partial derivatives of $u$ in terms of $v$:\n$$\nu = \\frac{v}{r} \\implies u_r = \\frac{v_r r - v}{r^2}, \\quad u_{rr} = \\frac{(v_{rr} r) r^2 - (v_r r - v) 2r}{r^4} = \\frac{v_{rr}}{r} - \\frac{2v_r}{r^2} + \\frac{2v}{r^3}\n$$\nSubstituting these into the original PDE yields:\n$$\n\\left(\\frac{v}{r}\\right)_{tt} = c^2\\left(\\left(\\frac{v_{rr}}{r} - \\frac{2v_r}{r^2} + \\frac{2v}{r^3}\\right) + \\frac{2}{r}\\left(\\frac{v_r r - v}{r^2}\\right)\\right)\n$$\n$$\n\\frac{v_{tt}}{r} = c^2\\left(\\frac{v_{rr}}{r} - \\frac{2v_r}{r^2} + \\frac{2v}{r^3} + \\frac{2v_r}{r^2} - \\frac{2v}{r^3}\\right)\n$$\n$$\n\\frac{v_{tt}}{r} = c^2 \\frac{v_{rr}}{r}\n$$\nFor $r>0$, this simplifies to the canonical one-dimensional wave equation for $v(r,t)$:\n$$\nv_{tt} = c^2 v_{rr}\n$$\nThis transformation has effectively removed the singularity. We can now solve for $v(r,t)$ and then recover $u(r,t)$.\n\nNext, we must transform the initial and boundary conditions from $u$ to $v$:\n1.  **Initial Displacement:** $v(r,0) = r u(r,0) = r \\left(\\frac{1}{r} f(r)\\right) = f(r)$.\n2.  **Initial Velocity:** $v_t(r,0) = r u_t(r,0) = r \\cdot 0 = 0$.\n3.  **Boundary Condition at $r=R$:** $v(R,t) = R u(R,t) = R \\cdot 0 = 0$.\n4.  **Boundary Condition at $r=0$:** The requirement that $u(r,t)$ is finite at the origin implies $v(0,t) = \\lim_{r \\to 0} r u(r,t) = 0$.\n\nWe now have a standard problem for the 1D wave equation for $v(r,t)$ on the domain $[0,R]$ with homogeneous Dirichlet boundary conditions $v(0,t)=v(R,t)=0$. We can solve this using a finite difference time-domain (FDTD) method on a uniform grid with spatial step $\\Delta r = R/N$ and time step $\\Delta t$. Let $v_i^n \\approx v(i\\Delta r, n\\Delta t)$. Using second-order central differences for the derivatives $v_{tt}$ and $v_{rr}$, we obtain the explicit leapfrog scheme:\n$$\n\\frac{v_i^{n+1} - 2v_i^n + v_i^{n-1}}{(\\Delta t)^2} = c^2 \\frac{v_{i+1}^n - 2v_i^n + v_{i-1}^n}{(\\Delta r)^2}\n$$\nSolving for $v_i^{n+1}$ gives the update rule for interior points ($i=1, \\dots, N-1$):\n$$\nv_i^{n+1} = 2v_i^n - v_i^{n-1} + \\lambda^2 (v_{i+1}^n - 2v_i^n + v_{i-1}^n)\n$$\nwhere $\\lambda = c \\Delta t / \\Delta r$ is the Courant-Friedrichs-Lewy (CFL) number. This scheme is stable for $\\lambda \\le 1$.\n\nTo start the simulation, we need values at two initial time levels, $n=0$ and $n=1$. We have $v_i^0 = f(r_i)$. For the first time step, we use a central difference for the initial velocity condition $v_t(r,0)=0$:\n$$\n\\frac{v_i^1 - v_i^{-1}}{2\\Delta t} = 0 \\implies v_i^{-1} = v_i^1\n$$\nSubstituting this into the main update rule for $n=0$:\n$$\nv_i^1 = 2v_i^0 - v_i^{-1} + \\lambda^2(v_{i+1}^0 - 2v_i^0 + v_{i-1}^0) = 2v_i^0 - v_i^1 + \\lambda^2(v_{i+1}^0 - 2v_i^0 + v_{i-1}^0)\n$$\n$$\nv_i^1 = v_i^0 + \\frac{\\lambda^2}{2} (v_{i+1}^0 - 2v_i^0 + v_{i-1}^0)\n$$\nThis provides the values for $v_i^1$, allowing the time-stepping to proceed. The boundary conditions $v_0^n=0$ and $v_N^n=0$ are enforced at all time steps.\n\nAfter evolving $v_i^n$ up to the final time $T=M\\Delta t$, we must reconstruct the solution $u_i^M$.\n-   For interior points $r_i > 0$ (i.e., $i=1, \\dots, N$), the reconstruction is direct: $u_i^M = v_i^M / r_i = v_i^M / (i\\Delta r)$.\n-   At the origin $r_0=0$, we have $u(0,t) = \\lim_{r\\to 0} u(r,t) = \\lim_{r\\to 0} \\frac{v(r,t)}{r}$. Since $v(0,t)=0$, this is the definition of the partial derivative of $v$ with respect to $r$ at $r=0$.\n    $$\n    u(0,t) = \\left. \\frac{\\partial v}{\\partial r} \\right|_{r=0, t}\n    $$\n    We can approximate this derivative using a central difference. From the d'Alembert solution structure, $v$ must be an odd function with respect to the origin. This implies $v(-\\Delta r, t) = -v(\\Delta r, t)$, so $v_{-1}^n = -v_1^n$.\n    $$\n    u_0^M = \\frac{v_1^M - v_{-1}^M}{2\\Delta r} = \\frac{v_1^M - (-v_1^M)}{2\\Delta r} = \\frac{2v_1^M}{2\\Delta r} = \\frac{v_1^M}{\\Delta r}\n    $$\nThis completes the numerical method. The implementation will follow this transformed-variable approach. For Test $3$, the CFL number $\\lambda=1.05 > 1$, which violates the stability condition; we expect the numerical solution to grow exponentially, which will be detected by checking if its magnitude exceeds a large threshold ($10^6$).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D spherically symmetric wave equation using an FDTD scheme\n    and evaluates results for three test cases.\n    \"\"\"\n\n    # Common parameters for all tests\n    c_param = 1.0\n    R_param = 2.0\n    rc_param = 0.6\n    sigma_param = 0.08\n    \n    # Test cases defined in the problem statement\n    test_cases = [\n        {'N': 400, 'cfl': 0.9, 'M': 50, 'id': 'Test 1'},\n        {'N': 400, 'cfl': 1.0, 'M': 50, 'id': 'Test 2'},\n        {'N': 300, 'cfl': 1.05, 'M': 200, 'id': 'Test 3'},\n    ]\n\n    # Helper functions for the exact solution\n    def f(r, rc, sigma):\n        \"\"\"Initial condition function f(r).\"\"\"\n        return r * np.exp(-(r - rc)**2 / (2 * sigma**2))\n\n    def f_tilde(x, rc, sigma):\n        \"\"\"Odd extension of f(r).\"\"\"\n        x = np.asarray(x)\n        # Use np.where to handle piecewise definition\n        positive_x = x[x >= 0]\n        negative_x = x[x < 0]\n        \n        # Explicitly define for positive and negative parts\n        f_pos = f(positive_x, rc, sigma)\n        f_neg = -f(-negative_x, rc, sigma)\n        \n        # Combine results\n        result = np.zeros_like(x)\n        result[x >= 0] = f_pos\n        result[x < 0] = f_neg\n        return result\n\n    def f_prime(r, rc, sigma):\n        \"\"\"Derivative of f(r).\"\"\"\n        factor = np.exp(-(r - rc)**2 / (2 * sigma**2))\n        return factor - r * (r - rc) / sigma**2 * factor\n\n    def get_u_exact(r_grid, t, c, rc, sigma):\n        \"\"\"Computes the exact solution u(r,t).\"\"\"\n        u_ex = np.zeros_like(r_grid)\n        \n        r_plus_ct = r_grid + c * t\n        r_minus_ct = r_grid - c * t\n        \n        v_exact_t = 0.5 * (f_tilde(r_minus_ct, rc, sigma) + f_tilde(r_plus_ct, rc, sigma))\n        \n        # For r > 0\n        mask_r_pos = r_grid > 0\n        u_ex[mask_r_pos] = v_exact_t[mask_r_pos] / r_grid[mask_r_pos]\n        \n        # For r = 0\n        u_ex[0] = f_prime(c * t, rc, sigma)\n        \n        return u_ex\n\n    def run_simulation(N, cfl, M, c, R, rc, sigma, check_stability=False):\n        \"\"\"\n        Runs the FDTD simulation for the transformed variable v = r*u.\n        \"\"\"\n        dr = R / N\n        dt = cfl * dr / c\n        r_grid = np.linspace(0, R, N + 1)\n        lambda_sq = (c * dt / dr)**2\n\n        # Arrays for v at n-1, n, n+1 time steps\n        v_prev = np.zeros(N + 1)\n        v_curr = f(r_grid, rc, sigma)\n\n        # Enforce boundary conditions on initial state v(r,0)\n        v_curr[0] = 0.0\n        v_curr[N] = 0.0\n        \n        v_prev[:] = v_curr\n\n        # First time step using v_t(r,0)=0\n        v_next = np.zeros(N + 1)\n        for i in range(1, N):\n            v_next[i] = v_curr[i] + 0.5 * lambda_sq * (v_curr[i+1] - 2 * v_curr[i] + v_curr[i-1])\n        # BCs for v_next are already 0\n        v_curr[:] = v_next\n\n        # Main FDTD loop\n        for _ in range(1, M):\n            # This must be a copy to not be a view\n            v_temp = v_curr.copy()\n            for i in range(1, N):\n                v_next[i] = 2.0 * v_curr[i] - v_prev[i] + lambda_sq * (v_curr[i+1] - 2.0 * v_curr[i] + v_curr[i-1])\n            \n            v_prev[:] = v_temp\n            v_curr[:] = v_next\n\n            if check_stability:\n                u_check = np.zeros(N + 1)\n                u_check[1:] = v_curr[1:] / r_grid[1:]\n                u_check[0] = v_curr[1] / dr\n                if np.any(np.abs(u_check) > 1e6) or np.any(np.isnan(u_check)):\n                    return False  # Unstable\n        \n        if check_stability:\n            return True # Stable\n\n        # Reconstruct u from v at final time\n        u_num = np.zeros(N + 1)\n        u_num[1:] = v_curr[1:] / r_grid[1:]\n        u_num[0] = v_curr[1] / dr\n        return u_num\n\n    results = {}\n    for case in test_cases:\n        N, cfl, M, case_id = case['N'], case['cfl'], case['M'], case['id']\n\n        if case_id == 'Test 3':\n            is_stable = run_simulation(N, cfl, M, c_param, R_param, rc_param, sigma_param, check_stability=True)\n            results['stable_test3'] = is_stable\n        else:\n            T_final = M * cfl * (R_param / N) / c_param\n            u_numerical = run_simulation(N, cfl, M, c_param, R_param, rc_param, sigma_param)\n            \n            r_points = np.linspace(0, R_param, N + 1)\n            u_analytical = get_u_exact(r_points, T_final, c_param, rc_param, sigma_param)\n\n            rms_error = np.sqrt(np.mean((u_numerical - u_analytical)**2))\n\n            if case_id == 'Test 1':\n                results['E_test1'] = rms_error\n                origin_error = np.abs(u_numerical[0] - u_analytical[0])\n                results['E0_test1'] = origin_error\n            elif case_id == 'Test 2':\n                results['E_test2'] = rms_error\n\n    # Assemble the final list in the required order\n    final_output = [\n        results['E_test1'],\n        results['E_test2'],\n        results['stable_test3'],\n        results['E0_test1']\n    ]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_output))}]\")\n\nsolve()\n```", "id": "2392876"}]}