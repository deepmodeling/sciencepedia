{"hands_on_practices": [{"introduction": "Before attempting to solve a differential equation, we must first ensure the problem is \"well-posed\"â€”that is, it has a unique solution that is stable. For a second-order boundary value problem, this is directly linked to providing the correct number of boundary conditions. This exercise provides a crucial, hands-on exploration of this \"Goldilocks principle,\" allowing you to discover why specifying too few conditions leads to ambiguity and too many can lead to contradictions [@problem_id:2403367].", "problem": "Consider the one-dimensional, steady elliptic boundary value problem for the unknown function $u(x)$ on the closed interval $[0,1]$ given by the partial differential equation (PDE)\n$$\nu''(x) \\;=\\; -\\pi^2 \\sin(\\pi x), \\quad x \\in (0,1).\n$$\nYou must examine how the well-posedness of this second-order elliptic problem depends on the initial and boundary conditions. Specifically, compare the following three boundary-condition scenarios:\n- Scenario A (under-specified): only $u(0)=0$ is prescribed.\n- Scenario B (well-posed): both Dirichlet conditions $u(0)=0$ and $u(1)=0$ are prescribed.\n- Scenario C (over-specified): both Dirichlet conditions $u(0)=0$ and $u(1)=0$ are prescribed, and in addition the Neumann condition $u'(0)=0$ is imposed.\n\nWrite a complete, runnable program that attempts to compute a numerical solution for each scenario and classifies the outcome for each case according to the following convention:\n- Output $0$ if there is a unique solution that is consistent with all conditions.\n- Output $1$ if the problem is under-specified, leading to non-uniqueness.\n- Output $2$ if the problem is over-specified and inconsistent, so no solution satisfies all conditions simultaneously.\n\nYour program must apply the same underlying mathematical model and forcing term for all scenarios and must use the same internal parameters of your choosing for all scenarios in order to make the classification decision in a consistent way. Any mathematically consistent numerical approach may be used to reach the classification decision, but the classification itself must be determined by whether the conditions imply uniqueness, non-uniqueness, or inconsistency for the stated PDE.\n\nTest suite:\n- Scenario A: only $u(0)=0$.\n- Scenario B: $u(0)=0$ and $u(1)=0$.\n- Scenario C: $u(0)=0$, $u(1)=0$, and $u'(0)=0$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the classification results for Scenarios A, B, and C, in that order, as a comma-separated list enclosed in square brackets. For example, the format is $[c_1,c_2,c_3]$, where $c_1$, $c_2$, and $c_3$ are the integer codes defined above for Scenarios A, B, and C respectively.", "solution": "The problem as stated is valid. It is a well-defined mathematical exercise in the analysis of boundary value problems, a fundamental topic in computational engineering. It is scientifically grounded, objective, and contains all necessary information to proceed with a rigorous analysis and solution.\n\nThe problem requires an analysis of the well-posedness of the one-dimensional elliptic boundary value problem on the interval $[0,1]$:\n$$\nu''(x) = -\\pi^2 \\sin(\\pi x)\n$$\nThis is a second-order ordinary differential equation. The general solution is found by integrating twice with respect to $x$.\n\nThe first integration yields the derivative $u'(x)$:\n$$\nu'(x) = \\int -\\pi^2 \\sin(\\pi x) \\,dx = \\pi \\cos(\\pi x) + C_1\n$$\nwhere $C_1$ is the first constant of integration.\n\nThe second integration yields the general solution $u(x)$:\n$$\nu(x) = \\int (\\pi \\cos(\\pi x) + C_1) \\,dx = \\sin(\\pi x) + C_1 x + C_2\n$$\nwhere $C_2$ is the second constant of integration. The well-posedness of any specific problem instance depends on whether the provided boundary conditions are sufficient to uniquely determine the two constants, $C_1$ and $C_2$. We will now analyze each scenario.\n\nScenario A: Under-specified problem with one boundary condition, $u(0)=0$.\nWe apply this condition to the general solution:\n$$\nu(0) = \\sin(\\pi \\cdot 0) + C_1 \\cdot 0 + C_2 = 0\n$$\nThis implies $0 + 0 + C_2 = 0$, which simplifies to $C_2 = 0$. The solution is constrained to the form:\n$$\nu(x) = \\sin(\\pi x) + C_1 x\n$$\nThe constant $C_1$ remains undetermined. Since there is no other information to constrain $C_1$, there exists an infinite family of solutions, each corresponding to a different choice of $C_1$. The problem is therefore under-specified, leading to non-uniqueness. The classification code is $1$.\n\nScenario B: Well-posed problem with two Dirichlet boundary conditions, $u(0)=0$ and $u(1)=0$.\nThe first condition, $u(0)=0$, gives $C_2=0$, as determined in Scenario A. Now, we apply the second condition, $u(1)=0$, to the partially constrained solution $u(x) = \\sin(\\pi x) + C_1 x$:\n$$\nu(1) = \\sin(\\pi \\cdot 1) + C_1 \\cdot 1 = 0\n$$\nThis gives $0 + C_1 = 0$, which implies $C_1=0$. Both constants are now uniquely determined: $C_1=0$ and $C_2=0$. This yields the unique solution:\n$$\nu(x) = \\sin(\\pi x)\n$$\nThis solution is consistent with all prescribed conditions. The problem is well-posed, admitting a unique solution. The classification code is $0$.\n\nScenario C: Over-specified problem with three boundary conditions, $u(0)=0$, $u(1)=0$, and $u'(0)=0$.\nFrom the analysis of Scenario B, the first two conditions, $u(0)=0$ and $u(1)=0$, are sufficient to determine a unique solution, $u(x) = \\sin(\\pi x)$.\n\nNow, we must check if this unique solution is consistent with the third, additional condition, the Neumann condition $u'(0)=0$. We evaluate the derivative of our unique solution at $x=0$. The derivative is:\n$$\nu'(x) = \\frac{d}{dx}(\\sin(\\pi x)) = \\pi \\cos(\\pi x)\n$$\nAt $x=0$, the value is:\n$$\nu'(0) = \\pi \\cos(\\pi \\cdot 0) = \\pi \\cos(0) = \\pi \\cdot 1 = \\pi\n$$\nThe problem imposes the condition $u'(0)=0$, but the only solution satisfying the other two conditions yields $u'(0)=\\pi$. Since $\\pi \\neq 0$, there is a contradiction. No function can simultaneously satisfy all three conditions. The problem is over-specified and inconsistent. The classification code is $2$.\n\nTo implement a program that arrives at these classifications, we will employ a finite difference method (FDM). We discretize the domain $[0,1]$ into $N$ intervals of size $h=1/N$, with grid points $x_i = i h$ for $i=0, 1, \\dots, N$. The unknown function values are $u_i \\approx u(x_i)$. The second derivative is approximated by a central difference: $u''(x_i) \\approx (u_{i-1} - 2u_i + u_{i+1})/h^2$. This converts the differential equation into a system of linear equations. Our program will analyze the properties of this system for each scenario.\n\nFor Scenario A, with only one boundary condition, the resulting linear system will be underdetermined, corresponding to a singular matrix with a rank less than the number of unknowns. This indicates non-uniqueness (code $1$).\n\nFor Scenario B, the two Dirichlet conditions result in a square, non-singular system matrix. A unique solution exists. This is detected by the matrix having full rank (code $0$).\n\nFor Scenario C, we will first solve the well-posed system from Scenario B. Then, we will check if the resulting numerical solution satisfies the third condition, $u'(0)=0$, approximated by $(u_1 - u_0)/h = 0$. As the analytical work shows, this condition will not be met, indicating inconsistency (code $2$).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the well-posedness of a 1D elliptic BVP under three different\n    boundary condition scenarios and classifies them.\n    - 0: Unique, consistent solution.\n    - 1: Under-specified, non-unique solution.\n    - 2: Over-specified, inconsistent, no solution.\n    \"\"\"\n    \n    # Numerical parameters\n    N = 100  # Number of spatial intervals\n    h = 1.0 / N  # Step size\n    x = np.linspace(0, 1, N + 1)\n    \n    # Forcing function f(x) = -pi^2 * sin(pi*x)\n    f = -np.pi**2 * np.sin(np.pi * x)\n    \n    # The size of the unknown vector u = [u_0, u_1, ..., u_N] is N+1\n    num_unknowns = N + 1\n    \n    results = []\n\n    # --- Scenario A: u(0) = 0 ---\n    # The problem is under-specified. We construct a linear system A*u = b\n    # and check if the matrix A is singular.\n    A_A = np.zeros((num_unknowns, num_unknowns))\n    b_A = np.zeros(num_unknowns)\n    \n    # Boundary condition: u_0 = 0\n    A_A[0, 0] = 1.0\n    b_A[0] = 0.0\n    \n    # Discretized PDE: u_{i-1} - 2u_i + u_{i+1} = h^2 * f_i\n    # We use the original PDE form to avoid dividing by h^2, improving stability.\n    for i in range(1, N):\n        A_A[i, i - 1] = 1.0\n        A_A[i, i] = -2.0\n        A_A[i, i + 1] = 1.0\n        b_A[i] = h**2 * f[i]\n        \n    # The last row of A_A is all zeros because there is no condition on u_N.\n    # This makes the matrix singular. A singular system with a non-trivial\n    # null space implies non-unique solutions (if a solution exists).\n    # Rank will be less than the number of unknowns.\n    rank_A = np.linalg.matrix_rank(A_A)\n    if rank_A < num_unknowns:\n        # A rank-deficient system implies either no solution or infinite solutions.\n        # Analytically, we know solutions exist, so it is non-unique.\n        results.append(1)\n    else:\n        # This case should not be reached for Scenario A.\n        results.append(0)\n\n\n    # --- Scenario B: u(0) = 0 and u(1) = 0 ---\n    # The problem is well-posed. The matrix should be non-singular.\n    A_B = np.zeros((num_unknowns, num_unknowns))\n    b_B = np.zeros(num_unknowns)\n    \n    # Boundary condition: u_0 = 0\n    A_B[0, 0] = 1.0\n    b_B[0] = 0.0\n    \n    # Discretized PDE\n    for i in range(1, N):\n        A_B[i, i - 1] = 1.0\n        A_B[i, i] = -2.0\n        A_B[i, i + 1] = 1.0\n        b_B[i] = h**2 * f[i]\n\n    # Boundary condition: u_N = 0\n    A_B[N, N] = 1.0\n    b_B[N] = 0.0\n    \n    # A full-rank square matrix implies a unique solution.\n    rank_B = np.linalg.matrix_rank(A_B)\n    if rank_B == num_unknowns:\n        results.append(0)\n    else:\n        # This case should not be reached for Scenario B.\n        results.append(1)\n\n\n    # --- Scenario C: u(0)=0, u(1)=0, and u'(0)=0 ---\n    # The problem is over-specified. We solve the well-posed subproblem (Scenario B)\n    # and check if the solution is consistent with the additional condition u'(0)=0.\n    \n    # 1. Solve the system from Scenario B to get the unique solution for the\n    #    Dirichlet conditions u(0)=0 and u(1)=0.\n    try:\n        u_sol_B = np.linalg.solve(A_B, b_B)\n\n        # 2. Check consistency with the third condition, u'(0) = 0.\n        # We approximate the derivative at x=0 using a forward difference:\n        # u'(0) approx (u_1 - u_0) / h\n        numerical_deriv_at_0 = (u_sol_B[1] - u_sol_B[0]) / h\n        \n        # The analytical derivative is pi. The numerical result should be close to pi.\n        # We check if this value is close to 0, which is the imposed condition.\n        # A tolerance is used for the floating-point comparison.\n        if np.isclose(numerical_deriv_at_0, 0.0, atol=1e-6):\n            # This would mean the solution is consistent (code 0).\n            # However, we know analytically u'(0)=pi, so this path is not expected.\n            results.append(0)\n        else:\n            # The condition is not satisfied. The problem is inconsistent.\n            results.append(2)\n            \n    except np.linalg.LinAlgError:\n        # This should not happen since matrix B is non-singular.\n        # If it did, it would imply an issue with the well-posed sub-problem.\n        # A safe fallback would be to classify as inconsistent.\n        results.append(2)\n\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2403367"}, {"introduction": "In many real-world simulations, the initial state of a system and the conditions imposed at its boundaries do not smoothly match at the \"corners\" of the space-time domain. This exercise challenges you to confront the numerical consequences of such a discontinuity, a common issue when setting up computational models. By implementing a stable numerical scheme for the heat equation, you will gain direct experience managing these singularities and learn a valuable verification technique by comparing your results to an analytical reference solution [@problem_id:2403435].", "problem": "Consider the one-dimensional heat equation on a finite interval that approximates a semi-infinite domain,\n$$\n\\frac{\\partial u}{\\partial t}(x,t)=a\\,\\frac{\\partial^2 u}{\\partial x^2}(x,t),\\quad x\\in(0,L),\\ t\\in(0,T],\n$$\nwith initial condition\n$$\nu(x,0)=0,\\quad x\\in(0,L],\n$$\nand Dirichlet boundary conditions\n$$\nu(0,t)=1,\\quad t\\in(0,T],\\qquad u(L,t)=0,\\quad t\\in[0,T].\n$$\nThere is an incompatibility at the corner $(x,t)=(0,0)$ because $u(x,0)=0$ for $x>0$ while $u(0,t)=1$ for $t>0$. For small times and away from $x=L$, the solution behaves like the semi-infinite similarity solution\n$$\nu_{\\text{ref}}(x,t)=\\operatorname{erfc}\\!\\left(\\frac{x}{2\\sqrt{a\\,t}}\\right),\n$$\nwhere the complementary error function (erfc) is defined by\n$$\n\\operatorname{erfc}(z)=\\frac{2}{\\sqrt{\\pi}}\\int_{z}^{\\infty} e^{-s^2}\\,ds.\n$$\n\nTask: For each test case listed below, numerically approximate the solution of the initial-boundary value problem up to the specified time $t^\\ast$ and report the absolute error at the specified grid location $x_i=i\\,\\Delta x$, where the uniform grid has $N$ subintervals so that $\\Delta x=L/N$. The absolute error to report for a case is\n$$\nE=\\big|u_{\\text{num}}(x_i,t^\\ast)-u_{\\text{ref}}(x_i,t^\\ast)\\big|.\n$$\nYou may use any mathematically consistent method to approximate the solution, provided it respects the stated initial and boundary conditions.\n\nTest suite:\n- Case A (general case): $a=1.0$, $L=1.0$, $N=200$, $\\Delta t=10^{-5}$, $t^\\ast=10^{-3}$, $i=1$.\n- Case B (coarser time resolution to emphasize smoothing near the corner): $a=1.0$, $L=1.0$, $N=100$, $\\Delta t=2\\times 10^{-4}$, $t^\\ast=2\\times 10^{-2}$, $i=2$.\n- Case C (different diffusivity and shorter domain with negligible right boundary influence at $t^\\ast$): $a=0.2$, $L=0.5$, $N=100$, $\\Delta t=5\\times 10^{-5}$, $t^\\ast=5\\times 10^{-3}$, $i=1$.\n\nAll quantities are dimensionless. Angles are not involved. No percentages are required.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases above, with each float formatted in scientific notation with $8$ digits after the decimal point, for example,\n$$\n[\\text{result\\_A},\\text{result\\_B},\\text{result\\_C}],\n$$\nwhere each entry has the form $\\text{d.dddddddd}\\text{e}\\pm\\text{dd}$ using a lowercase $e$.", "solution": "The problem presented is a standard initial-boundary value problem for the one-dimensional heat equation. It is well-posed and scientifically sound, despite the specified discontinuity at the corner $(x,t)=(0,0)$, which presents a known numerical challenge. We proceed with its numerical resolution.\n\nThe governing partial differential equation (PDE) is the heat equation:\n$$\n\\frac{\\partial u}{\\partial t} = a \\frac{\\partial^2 u}{\\partial x^2}\n$$\nfor a function $u(x,t)$ on the domain $x \\in (0,L)$ and $t \\in (0,T]$.\n\nTo solve this equation numerically, we must discretize it in both space and time. We introduce a uniform spatial grid with points $x_j = j \\Delta x$ for $j = 0, 1, \\dots, N$, where the grid spacing is $\\Delta x = L/N$. The time domain is discretized into steps of size $\\Delta t$, with time points $t_k = k \\Delta t$. We denote the numerical approximation of $u(x_j, t_k)$ as $u_j^k$.\n\nThe second-order spatial derivative is approximated using a second-order central difference formula:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j, t_k} \\approx \\frac{u_{j+1}^k - 2u_j^k + u_{j-1}^k}{(\\Delta x)^2}\n$$\n\nFor the time derivative, an explicit forward Euler scheme would be conditionally stable, requiring the Courant-Friedrichs-Lewy (CFL) condition $r = a \\Delta t / (\\Delta x)^2 \\le 1/2$ to be met. For Case B, we calculate $r = 1.0 \\times (2 \\times 10^{-4}) / (1.0/100)^2 = 2.0$, which violates this condition, rendering the explicit method unstable. To ensure unconditional stability for all test cases, we select the implicit Backward Time, Centered Space (BTCS) method.\n\nThe BTCS scheme applies the finite differences at the future time step $k+1$:\n$$\n\\frac{u_j^{k+1} - u_j^k}{\\Delta t} = a \\frac{u_{j+1}^{k+1} - 2u_j^{k+1} + u_{j-1}^{k+1}}{(\\Delta x)^2}\n$$\nThis equation is valid for the interior grid points, $j = 1, 2, \\dots, N-1$. Rearranging the terms to group the unknown values at time step $k+1$ on the left side, we obtain a system of linear equations:\n$$\n-r u_{j-1}^{k+1} + (1+2r) u_j^{k+1} - r u_{j+1}^{k+1} = u_j^k\n$$\nwhere $r = a \\Delta t / (\\Delta x)^2$ is the diffusion number.\n\nThis system of $N-1$ equations for the $N-1$ unknown interior nodal values $\\{u_j^{k+1}\\}_{j=1}^{N-1}$ must be augmented with the boundary conditions.\nThe Dirichlet boundary conditions are $u(0,t)=1$ and $u(L,t)=0$. In our discrete framework, this means $u_0^{k+1} = 1$ and $u_N^{k+1} = 0$ for any time step $k+1 > 0$.\n\nIncorporating the boundary values into the equations for the first ($j=1$) and last ($j=N-1$) interior nodes, we have:\nFor $j=1$:\n$$ -r u_0^{k+1} + (1+2r) u_1^{k+1} - r u_2^{k+1} = u_1^k \\implies (1+2r) u_1^{k+1} - r u_2^{k+1} = u_1^k + r(1) $$\nFor $j=N-1$:\n$$ -r u_{N-2}^{k+1} + (1+2r) u_{N-1}^{k+1} - r u_N^{k+1} = u_{N-1}^k \\implies -r u_{N-2}^{k+1} + (1+2r) u_{N-1}^{k+1} = u_{N-1}^k + r(0) $$\nThe resulting system of equations, $A \\mathbf{u}_{\\text{int}}^{k+1} = \\mathbf{d}^k$, has a tridiagonal matrix $A$ of size $(N-1) \\times (N-1)$ and is solved at each time step. The matrix $A$ has a lower diagonal of $-r$, a main diagonal of $1+2r$, and an upper diagonal of $-r$. The right-hand side vector $\\mathbf{d}^k$ is constructed from the interior solution at the previous time step, $\\mathbf{u}_{\\text{int}}^k = (u_1^k, \\dots, u_{N-1}^k)^T$, with modifications based on the boundary conditions: $d_1 = u_1^k + r$ and $d_j = u_j^k$ for $j=2, \\dots, N-1$.\n\nThe algorithm proceeds as follows:\n1. Initialize the solution at time $t=0$. From the initial condition $u(x,0)=0$, we set $u_j^0 = 0$ for all $j=0, 1, \\dots, N$.\n2. For each time step from $t=0$ to $t=t^\\ast$:\n   a. Construct the tridiagonal matrix $A$ and the right-hand side vector $\\mathbf{d}^k$.\n   b. Solve the linear system $A \\mathbf{u}_{\\text{int}}^{k+1} = \\mathbf{d}^k$ for the interior nodal values at the next time step, $\\mathbf{u}_{\\text{int}}^{k+1}$. An efficient algorithm for tridiagonal systems, such as the Thomas algorithm (implemented in `scipy.linalg.solve_banded`), is used.\n   c. Update the solution vector.\n3. After the final time step, the numerical solution $u_{\\text{num}}(x_i, t^\\ast)$ is given by the value $u_i^K$, where $K = t^\\ast / \\Delta t$.\n4. This numerical solution is compared against the reference solution for the semi-infinite domain, $u_{\\text{ref}}(x_i, t^\\ast) = \\operatorname{erfc}(x_i / (2\\sqrt{a t^\\ast}))$. The absolute error is computed as $E = |u_i^K - u_{\\text{ref}}(x_i, t^\\ast)|$.\n\nThis procedure is applied to each test case to determine the required absolute error.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom scipy.special import erfc\n\ndef solve_case(params):\n    \"\"\"\n    Numerically solves the 1D heat equation for a given set of parameters\n    using the Backward Time, Centered Space (BTCS) implicit method.\n\n    Args:\n        params (tuple): A tuple containing the problem parameters:\n                        (a, L, N, dt, t_star, i).\n                        a: thermal diffusivity\n                        L: length of the domain\n                        N: number of subintervals\n                        dt: time step size\n                        t_star: final time\n                        i: grid index for error calculation\n\n    Returns:\n        float: The absolute error between the numerical solution and the\n               reference semi-infinite solution at the specified point.\n    \"\"\"\n    a, L, N, dt, t_star, i = params\n\n    # Discretization parameters\n    dx = L / N\n    r = a * dt / (dx**2)\n    num_steps = int(round(t_star / dt))\n\n    # Initial condition: u(x, 0) = 0 for x in [0, L]\n    # The solution vector u has N+1 points, for j = 0, ..., N.\n    u = np.zeros(N + 1)\n\n    # Set up the tridiagonal matrix for the BTCS aystem.\n    # The system is for the N-1 interior points (j = 1, ..., N-1).\n    # The banded matrix format for scipy.linalg.solve_banded is used.\n    # It has 3 rows: upper diagonal, main diagonal, lower diagonal.\n    A_banded = np.zeros((3, N - 1))\n    A_banded[0, 1:] = -r        # Upper diagonal (shifted one to the left)\n    A_banded[1, :] = 1 + 2 * r  # Main diagonal\n    A_banded[2, :-1] = -r       # Lower diagonal (shifted one to the right)\n\n    # Time-stepping loop\n    for _ in range(num_steps):\n        # Construct the right-hand side (RHS) vector from the solution\n        # at the current time step (u).\n        # We solve for the N-1 interior points.\n        rhs = u[1:N].copy()\n\n        # Modify RHS to incorporate Dirichlet boundary conditions.\n        # For the first interior point (j=1): u(0,t)=1.\n        # The term -r*u_0^{k+1} is moved to the RHS, becoming +r*u_0^{k+1} = +r*1.\n        rhs[0] += r\n        \n        # For the last interior point (j=N-1): u(L,t)=0.\n        # The term -r*u_N^{k+1} is moved to the RHS, becoming +r*u_N^{k+1} = +r*0.\n        # So, no change is needed for rhs[-1].\n\n        # Solve the tridiagonal system A * u_next_interior = rhs\n        u_interior_next = solve_banded((1, 1), A_banded, rhs)\n\n        # Update the interior points of the solution vector for the next time step.\n        u[1:N] = u_interior_next\n\n    # After the loop, u contains the numerical solution at time t_star.\n    x_i = i * dx\n    u_num = u[i]\n\n    # Calculate the reference semi-infinite domain solution.\n    u_ref = erfc(x_i / (2 * np.sqrt(a * t_star)))\n\n    # Calculate the absolute error.\n    error = np.abs(u_num - u_ref)\n    \n    return error\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: a=1.0, L=1.0, N=200, dt=10^-5, t*=10^-3, i=1\n        (1.0, 1.0, 200, 1e-5, 1e-3, 1),\n        # Case B: a=1.0, L=1.0, N=100, dt=2x10^-4, t*=2x10^-2, i=2\n        (1.0, 1.0, 100, 2e-4, 2e-2, 2),\n        # Case C: a=0.2, L=0.5, N=100, dt=5x10^-5, t*=5x10^-3, i=1\n        (0.2, 0.5, 100, 5e-5, 5e-3, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(case)\n        # Format the result to scientific notation with 8 decimal places.\n        results.append(f\"{error:.8e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2403435"}, {"introduction": "Boundary conditions are far more than static constraints; they can be dynamic drivers that actively inject energy and information into a physical system. This practice powerfully demonstrates the phenomenon of resonance, where a system's response is dramatically amplified when it is driven at one of its intrinsic natural frequencies. You will first derive these frequencies from first principles and then, by simulating the wave equation with a precisely tuned boundary input, witness firsthand the profound link between external conditions and a system's inherent dynamics [@problem_id:2403378].", "problem": "Consider the one-dimensional wave equation on a finite interval, posed in dimensionless form to avoid physical units. Let the field be $u(x,t)$ with spatial coordinate $x \\in [0,L]$ and time $t \\ge 0$. The governing partial differential equation (PDE) is\n$$\nu_{tt}(x,t) = c^2\\,u_{xx}(x,t),\n$$\nsubject to the Dirichlet boundary conditions\n$$\nu(0,t) = g(t), \\quad u(L,t) = 0,\n$$\nand the initial conditions\n$$\nu(x,0) = 0, \\quad u_t(x,0) = 0.\n$$\nThe boundary driving is a time-varying signal\n$$\ng(t) = A \\sin(\\omega t),\n$$\nwhere all angles are in radians.\n\nStarting from the method of separation of variables for the associated homogeneous boundary-value problem (with $g(t) \\equiv 0$), and using the orthogonality of eigenfunctions, derive the natural mode shapes and the corresponding natural angular frequencies of the domain. Use this derivation to define a parametric choice of $\\omega$ that is tuned to a selected natural mode of the domain, without assuming any shortcut formulas.\n\nYour computational task is to design and implement a second-order accurate, explicit finite-difference time-domain integrator for the PDE with the non-homogeneous Dirichlet boundary input $g(t)$, enforcing the boundary values at each time step. Use a uniform grid with $N_x$ subintervals, grid spacing $\\Delta x = L/N_x$, and explicit time step $\\Delta t$ chosen via the Courantâ€“Friedrichsâ€“Lewy (CFL) stability condition for the wave equation. Define the Courant number $r = c\\,\\Delta t/\\Delta x$. The explicit central-difference update for interior points should be second order in both space and time. Initialize the scheme using the given initial conditions consistently with the chosen update.\n\nDefine the following scalar performance metric for a given simulation: the maximum absolute displacement at the spatial midpoint $x=L/2$ attained over the simulated time interval,\n$$\nM = \\max_{0 \\le n \\le N_t} \\left| u\\!\\left(\\tfrac{L}{2}, n\\,\\Delta t \\right) \\right|,\n$$\nwhere $N_t$ is the total number of time steps.\n\nUsing the derivation of the natural frequencies from first principles, set the driving frequency to excite a selected mode by choosing\n$$\n\\omega = \\omega_m\\,(1+\\delta),\n$$\nwhere $m$ is a positive integer mode index you select, $\\omega_m$ is the $m$-th natural angular frequency you derived, and $\\delta$ is a dimensionless detuning parameter. For each simulation, run for a prescribed number of drive periods $P$ of the chosen $\\omega$; that is, simulate up to final time $T = P \\cdot 2\\pi/\\omega$. All quantities are dimensionless.\n\nImplement the computation and report $M$ for each of the following test cases. In all cases, use the same spatial resolution to make comparisons meaningful. Each tuple is $(L, c, N_x, r, m, \\delta, A, P)$:\n- Case A (resonant, fundamental mode): $(\\,\\; L=\\,1,\\; c=\\,1,\\; N_x=\\,200,\\; r=\\,0.9,\\; m=\\,1,\\; \\delta=\\,0,\\; A=\\,1,\\; P=\\,30\\,)$.\n- Case B (slight detuning): $(\\,\\; L=\\,1,\\; c=\\,1,\\; N_x=\\,200,\\; r=\\,0.9,\\; m=\\,1,\\; \\delta=\\,0.05,\\; A=\\,1,\\; P=\\,30\\,)$.\n- Case C (resonant, even mode measured at a nodal point): $(\\,\\; L=\\,1,\\; c=\\,1,\\; N_x=\\,200,\\; r=\\,0.9,\\; m=\\,2,\\; \\delta=\\,0,\\; A=\\,1,\\; P=\\,30\\,)$.\n- Case D (resonant, higher odd mode): $(\\,\\; L=\\,1,\\; c=\\,1,\\; N_x=\\,200,\\; r=\\,0.9,\\; m=\\,3,\\; \\delta=\\,0,\\; A=\\,1,\\; P=\\,30\\,)$.\n- Case E (CFL boundary of stability): $(\\,\\; L=\\,1,\\; c=\\,1,\\; N_x=\\,200,\\; r=\\,1,\\; m=\\,1,\\; \\delta=\\,0,\\; A=\\,1,\\; P=\\,30\\,)$.\n\nYour program must:\n- Compute the $m$-th natural frequency $\\omega_m$ from the separation-of-variables analysis you derived, then set $\\omega = \\omega_m\\,(1+\\delta)$.\n- Use the explicit second-order scheme with Courant number $r \\le 1$ and enforce $u(0,t)=g(t)$ and $u(L,t)=0$ at each time step.\n- For each case, simulate until $T = P \\cdot 2\\pi/\\omega$ and record $M$ as defined above.\n\nFinal output format: Your program should produce a single line of output containing the results for Cases A through E, in order, as a comma-separated list enclosed in square brackets, with each number rounded to six decimal places, for example [r_a,r_b,r_c,r_d,r_e].", "solution": "The problem as stated is valid. It is a well-posed initial-boundary value problem from computational engineering, grounded in the fundamental principles of wave mechanics and numerical analysis. It is free of contradiction, ambiguity, or scientific fallacy. We will proceed with a complete solution.\n\nFirst Principle Derivation of Natural Frequencies\n\nTo find the natural frequencies, we must analyze the associated homogeneous problem. This corresponds to the given partial differential equation (PDE) with zero boundary conditions.\nThe PDE is the one-dimensional wave equation:\n$$u_{tt}(x,t) = c^2 u_{xx}(x,t), \\quad x \\in [0, L], \\quad t \\ge 0$$\nThe associated homogeneous Dirichlet boundary conditions are:\n$$u(0,t) = 0, \\quad u(L,t) = 0$$\nWe employ the method of separation of variables, assuming a solution of the form $u(x,t) = X(x)T(t)$. Substituting this into the PDE yields:\n$$X(x)T''(t) = c^2 X''(x)T(t)$$\nRearranging terms to separate the spatial and temporal variables, we get:\n$$\\frac{T''(t)}{c^2 T(t)} = \\frac{X''(x)}{X(x)}$$\nSince the left side depends only on time $t$ and the right side depends only on space $x$, both must be equal to a constant. We denote this separation constant as $-\\lambda$. The negative sign is chosen to ensure oscillatory (and thus non-trivial) solutions that satisfy the boundary conditions.\n$$ \\frac{X''(x)}{X(x)} = -\\lambda \\quad \\text{and} \\quad \\frac{T''(t)}{c^2 T(t)} = -\\lambda $$\nThis results in two ordinary differential equations (ODEs):\n1.  Spatial ODE: $X''(x) + \\lambda X(x) = 0$\n2.  Temporal ODE: $T''(t) + \\lambda c^2 T(t) = 0$\n\nWe first solve the spatial ODE, which constitutes a Sturm-Liouville boundary value problem. The boundary conditions for $u(x,t)$ translate to conditions on $X(x)$:\n$$X(0) = 0, \\quad X(L) = 0$$\nThe general solution to the spatial ODE is $X(x) = C_1 \\cos(\\sqrt{\\lambda}x) + C_2 \\sin(\\sqrt{\\lambda}x)$.\nApplying the first boundary condition, $X(0) = 0$:\n$$C_1 \\cos(0) + C_2 \\sin(0) = C_1 \\cdot 1 + C_2 \\cdot 0 = C_1 = 0$$\nThis reduces the solution to $X(x) = C_2 \\sin(\\sqrt{\\lambda}x)$.\nApplying the second boundary condition, $X(L) = 0$:\n$$C_2 \\sin(\\sqrt{\\lambda}L) = 0$$\nFor a non-trivial solution, we require $C_2 \\neq 0$, which implies that $\\sin(\\sqrt{\\lambda}L)$ must be zero. This condition is met when the argument of the sine function is an integer multiple of $\\pi$:\n$$\\sqrt{\\lambda}L = m\\pi, \\quad \\text{for } m = 1, 2, 3, \\dots$$\nThe case $m=0$ is excluded as it leads to $\\lambda=0$ and the trivial solution $X(x)=0$. Negative integers for $m$ do not produce new independent solutions.\nSolving for the eigenvalues $\\lambda$, we obtain a discrete set of values:\n$$\\lambda_m = \\left(\\frac{m\\pi}{L}\\right)^2, \\quad m=1, 2, 3, \\dots$$\nThe corresponding eigenfunctions, or natural mode shapes, are:\n$$X_m(x) = \\sin\\left(\\frac{m\\pi x}{L}\\right)$$\nWe now return to the temporal ODE, substituting the eigenvalues $\\lambda_m$:\n$$T_m''(t) + \\lambda_m c^2 T_m(t) = 0$$\nThis is the equation for a simple harmonic oscillator. The natural angular frequency, $\\omega_m$, is the square root of the coefficient of $T_m(t)$:\n$$\\omega_m^2 = \\lambda_m c^2 = \\left(\\frac{m\\pi}{L}\\right)^2 c^2$$\nTaking the positive square root gives the natural angular frequencies:\n$$\\omega_m = \\frac{m\\pi c}{L}, \\quad m=1, 2, 3, \\dots$$\nThis completes the derivation. This formula will be used to set the driving frequency $\\omega = \\omega_m(1+\\delta)$ in the numerical simulation.\n\nFinite-Difference Time-Domain (FDTD) Scheme\n\nWe discretize the domain with a uniform grid. The spatial coordinate is $x_i = i\\Delta x$ for $i \\in \\{0, 1, \\dots, N_x\\}$, where $\\Delta x = L/N_x$. The time coordinate is $t_n = n\\Delta t$ for $n \\in \\{0, 1, \\dots, N_t\\}$. We denote the numerical approximation of the field as $u_i^n \\approx u(x_i, t_n)$.\n\nThe PDE $u_{tt} = c^2 u_{xx}$ is approximated using second-order central differences in both space and time:\n$$ \\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{(\\Delta t)^2} = c^2 \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2} $$\nSolving for $u_i^{n+1}$, the field at the next time step, gives the explicit update rule for interior grid points ($i=1, \\dots, N_x-1$):\n$$ u_i^{n+1} = 2u_i^n - u_i^{n-1} + \\left(\\frac{c\\Delta t}{\\Delta x}\\right)^2 (u_{i+1}^n - 2u_i^n + u_{i-1}^n) $$\nDefining the Courant number $r = c\\Delta t/\\Delta x$, the scheme simplifies to:\n$$ u_i^{n+1} = 2(1 - r^2)u_i^n + r^2(u_{i+1}^n + u_{i-1}^n) - u_i^{n-1} $$\nThis scheme is stable for $r \\le 1$, the Courant-Friedrichs-Lewy (CFL) condition.\n\nThe initial conditions are $u(x,0) = 0$ and $u_t(x,0)=0$.\nFrom $u(x,0)=0$, we set $u_i^0 = 0$ for all $i \\in \\{0, \\dots, N_x\\}$.\nThe time derivative $u_t(x,0)=0$ is used to find the solution at the first time step, $u_i^1$. We use a second-order central difference for the derivative at $t=0$:\n$$ \\frac{u_i^1 - u_i^{-1}}{2\\Delta t} = u_t(x_i, 0) = 0 \\implies u_i^{-1} = u_i^1 $$\nHere $u_i^{-1}$ is a fictitious \"ghost point\" in time. We substitute this into the update rule for $n=0$:\n$$ u_i^1 = 2(1 - r^2)u_i^0 + r^2(u_{i+1}^0 + u_{i-1}^0) - u_i^{-1} $$\nSubstituting $u_i^0=0$ and $u_i^{-1}=u_i^1$:\n$$ u_i^1 = 2(1 - r^2)(0) + r^2(0+0) - u_i^1 \\implies 2u_i^1 = 0 \\implies u_i^1 = 0 $$\nThis holds for the interior points. For the boundary points, the values are dictated by the boundary conditions.\nAt any time step $n$, the boundary conditions are enforced directly:\n$u_0^n = g(t_n) = A \\sin(\\omega t_n)$\n$u_{N_x}^n = 0$\nSo, for the initialization:\n- Time $n=0$: $u_i^0 = 0$ for all $i$. Note that $u_0^0=g(0)=A\\sin(0)=0$, which is consistent.\n- Time $n=1$: $u_i^1 = 0$ for interior points $i=1, \\dots, N_x-1$. The boundaries are $u_0^1 = g(\\Delta t)$ and $u_{N_x}^1 = 0$.\n\nThe simulation proceeds by iteratively applying the update rule, starting with these initial states. The maximum absolute displacement at the midpoint, $x=L/2$ (corresponding to index $i=N_x/2$), is recorded at each time step to find the overall maximum $M$.", "answer": "```python\nimport numpy as np\n\ndef run_simulation(L, c, Nx, r, m, delta, A, P):\n    \"\"\"\n    Solves the 1D wave equation using a finite-difference time-domain (FDTD) scheme.\n\n    Args:\n        L (float): Length of the domain.\n        c (float): Wave speed.\n        Nx (int): Number of spatial subintervals.\n        r (float): Courant number.\n        m (int): Mode index for driving frequency.\n        delta (float): Detuning parameter.\n        A (float): Amplitude of the boundary driving signal.\n        P (int): Number of drive periods to simulate.\n\n    Returns:\n        float: The maximum absolute displacement at the spatial midpoint.\n    \"\"\"\n    # 1. Setup grid and parameters\n    delta_x = L / Nx\n    \n    # 2. Calculate frequencies based on the derived formula\n    # Natural angular frequency for the m-th mode\n    omega_m = m * np.pi * c / L\n    # Driving angular frequency\n    omega = omega_m * (1.0 + delta)\n\n    # 3. Setup time stepping\n    delta_t = r * delta_x / c\n    # Final simulation time\n    if omega == 0:\n        # Avoid division by zero if frequency is zero (not in test cases but for robustness)\n        T_final = 0\n    else:\n        T_final = P * 2.0 * np.pi / omega\n    \n    # Total number of time steps (the loop will go up to Nt)\n    Nt = int(np.ceil(T_final / delta_t))\n\n    # Index of the spatial midpoint for performance metric\n    mid_point_idx = Nx // 2\n\n    # Courant number squared, used in the update rule\n    r_sq = r**2\n\n    # 4. Initialize field arrays\n    # u_prev stores the field at time step n-1\n    # u_curr stores the field at time step n\n    \n    # Per the derivation for ICs u(x,0)=0, u_t(x,0)=0:\n    # State at n=0 (t=0): u_prev array represents this.\n    # u(x,0)=0 implies u_i^0=0 for all i. The BC g(0)=A*sin(0)=0 is consistent.\n    u_prev = np.zeros(Nx + 1)\n    \n    # State at n=1 (t=delta_t): u_curr array represents this.\n    # u_i^1=0 for interior points. BCs are enforced.\n    u_curr = np.zeros(Nx + 1)\n    t = delta_t\n    u_curr[0] = A * np.sin(omega * t)\n    # u_curr[Nx] = 0 is already set by np.zeros.\n\n    # 5. Track max displacement at midpoint\n    # Initialize with the value at t=delta_t, since t=0 is zero everywhere.\n    max_disp = np.abs(u_curr[mid_point_idx])\n\n    # 6. Time-stepping loop\n    # This loop computes states for n=2, 3, ..., Nt.\n    # The loop iterates n from 1 to Nt-1 to compute u_next for time steps n+1.\n    for n in range(1, Nt):\n        # We have u_prev (n-1) and u_curr (n), compute u_next (n+1)\n        u_next = np.zeros(Nx + 1)\n\n        # Update interior points using a vectorized numpy operation for efficiency\n        # This applies the FDTD stencil: u_i^{n+1} = 2(1-r^2)u_i^n + r^2(u_{i+1}^n + u_{i-1}^n) - u_i^{n-1}\n        u_next[1:Nx] = 2.0 * (1.0 - r_sq) * u_curr[1:Nx] \\\n                      + r_sq * (u_curr[2:Nx+1] + u_curr[0:Nx-1]) \\\n                      - u_prev[1:Nx]\n\n        # Enforce boundary conditions at the next time step t = (n+1)*delta_t\n        t = (n + 1) * delta_t\n        u_next[0] = A * np.sin(omega * t)\n        u_next[Nx] = 0.0\n\n        # Update the performance metric\n        max_disp = max(max_disp, np.abs(u_next[mid_point_idx]))\n        \n        # Advance the state arrays for the next iteration\n        u_prev, u_curr = u_curr, u_next\n\n    return max_disp\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (L, c, Nx, r, m, delta, A, P)\n        (1.0, 1.0, 200, 0.9, 1, 0.0,    1.0, 30),  # Case A\n        (1.0, 1.0, 200, 0.9, 1, 0.05,   1.0, 30),  # Case B\n        (1.0, 1.0, 200, 0.9, 2, 0.0,    1.0, 30),  # Case C\n        (1.0, 1.0, 200, 0.9, 3, 0.0,    1.0, 30),  # Case D\n        (1.0, 1.0, 200, 1.0, 1, 0.0,    1.0, 30),  # Case E\n    ]\n\n    results = []\n    for case_params in test_cases:\n        max_displacement = run_simulation(*case_params)\n        results.append(f\"{max_displacement:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2403378"}]}