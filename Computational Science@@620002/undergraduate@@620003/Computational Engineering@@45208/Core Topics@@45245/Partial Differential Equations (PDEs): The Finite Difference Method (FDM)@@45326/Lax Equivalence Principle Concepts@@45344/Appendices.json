{"hands_on_practices": [{"introduction": "We begin by dissecting the concept of consistency. A numerical scheme is consistent with a Partial Differential Equation (PDE) if its local truncation error vanishes as the discretization steps, $\\Delta t$ and $\\Delta x$, approach zero. This exercise [@problem_id:2408003] challenges you to go a step further by using Taylor series analysis to find the *exact* PDE that a given numerical method implicitly solves. By reverse-engineering this \"modified equation,\" you will gain a deeper understanding of how discretization choices introduce systematic effects, such as the artificial viscosity explored here.", "problem": "Consider the one-dimensional heat partial differential equation (PDE) $u_{t}=\\alpha\\,u_{xx}$ with a strictly positive constant diffusivity $\\alpha>0$, posed on a periodic spatial domain. Let the spatial grid be uniform with nodes $x_{j}=j\\,\\Delta x$ and temporal grid $t^{n}=n\\,\\Delta t$, and let $u_{j}^{n}$ denote an approximation to $u(x_{j},t^{n})$. Define a two-stage linear update per time step as follows:\n\n- Stage A (diffusion step): compute the intermediate field $y_{j}$ from\n$$\ny_{j}=u_{j}^{n}+\\frac{\\alpha\\,\\Delta t}{\\Delta x^{2}}\\Big(u_{j+1}^{n}-2\\,u_{j}^{n}+u_{j-1}^{n}\\Big).\n$$\n\n- Stage B (artificial-viscosity smoothing): update\n$$\nu_{j}^{n+1}=(1-2\\gamma)\\,y_{j}+\\gamma\\,(y_{j-1}+y_{j+1}),\n$$\nwhere $\\gamma>0$ is a user-chosen parameter that may depend on $\\Delta t$ and $\\Delta x$, but not on $j$ or $n$.\n\nAssume $\\Delta t\\to 0$ and $\\Delta x\\to 0$ with the parabolic scaling $\\Delta t/\\Delta x^{2}$ held fixed. Determine the unique closed-form expression for $\\gamma$ in terms of $\\epsilon$, $\\Delta t$, and $\\Delta x$ such that, in this refinement regime, the combined two-stage method is first-order accurate in time and consistent with the PDE $u_{t}=(\\alpha+\\epsilon)\\,u_{xx}$ for a prescribed constant $\\epsilon>0$. Provide your answer as a single analytic expression for $\\gamma$ in terms of $\\epsilon$, $\\Delta t$, and $\\Delta x$. No rounding is required and no units are to be reported.", "solution": "The problem requires the determination of a parameter $\\gamma$ for a two-stage numerical method applied to the one-dimensional heat equation. The condition is that the method must be consistent with a modified PDE, $u_{t}=(\\alpha+\\epsilon)\\,u_{xx}$, for some given $\\epsilon>0$. This task is accomplished by deriving the modified partial differential equation that the numerical scheme implicitly solves. This is achieved through a rigorous Taylor series expansion of the finite difference operators. By comparing the coefficients of the resulting modified PDE with those of the target PDE, we can establish an equation for $\\gamma$ and solve it.\n\nFirst, we express the given two-stage numerical scheme in operator notation. Let the standard second-order central difference operator for the second spatial derivative be defined as:\n$$\nD_{xx} u_{j}^{n} = \\frac{u_{j+1}^{n}-2u_{j}^{n}+u_{j-1}^{n}}{\\Delta x^{2}}\n$$\nWith this definition, Stage A of the scheme, the diffusion step, is written as:\n$$\ny_{j} = u_{j}^{n} + \\alpha \\Delta t \\left( \\frac{u_{j+1}^{n}-2u_{j}^{n}+u_{j-1}^{n}}{\\Delta x^{2}} \\right) = (I + \\alpha \\Delta t D_{xx}) u_{j}^{n}\n$$\nwhere $I$ denotes the identity operator.\n\nStage B, the artificial-viscosity smoothing step, acts on the intermediate field $y_{j}$:\n$$\nu_{j}^{n+1} = (1-2\\gamma)y_{j}+\\gamma(y_{j-1}+y_{j+1}) = y_{j} + \\gamma(y_{j+1}-2y_{j}+y_{j-1})\n$$\nThis can be expressed compactly using the $D_{xx}$ operator applied to the field $y$:\n$$\nu_{j}^{n+1} = y_{j} + \\gamma \\Delta x^{2} \\left(\\frac{y_{j+1}-2y_{j}+y_{j-1}}{\\Delta x^{2}}\\right) = (I + \\gamma \\Delta x^{2} D_{xx}) y_{j}\n$$\nTo analyze the full method, we combine the two stages by substituting the expression for $y_j$ from Stage A into the equation for $u_{j}^{n+1}$:\n$$\nu_{j}^{n+1} = (I + \\gamma \\Delta x^{2} D_{xx}) \\big( (I + \\alpha \\Delta t D_{xx}) u_{j}^{n} \\big)\n$$\nExpanding the operator product gives the complete one-step update rule:\n$$\nu_{j}^{n+1} = (I + \\alpha \\Delta t D_{xx} + \\gamma \\Delta x^{2} D_{xx} + \\alpha \\gamma \\Delta t \\Delta x^{2} D_{xx}^{2}) u_{j}^{n}\n$$\nTo derive the modified PDE, we rearrange this equation to isolate an approximation of the time derivative, and then expand all operators in Taylor series.\n$$\n\\frac{u_{j}^{n+1} - u_{j}^{n}}{\\Delta t} = \\left( (\\alpha + \\frac{\\gamma \\Delta x^{2}}{\\Delta t}) D_{xx} + \\alpha \\gamma \\Delta x^{2} D_{xx}^{2} \\right) u_{j}^{n}\n$$\nAssuming the exact solution $u(x,t)$ is sufficiently smooth, we expand the operators around the point $(x_j, t^n)$. The left-hand side, representing the time derivative, expands as:\n$$\n\\frac{u(x_{j}, t^{n}+\\Delta t) - u(x_{j}, t^{n})}{\\Delta t} = u_{t} + \\frac{\\Delta t}{2} u_{tt} + O(\\Delta t^{2})\n$$\nThe spatial operators on the right-hand side have the following Taylor series expansions:\n$$\nD_{xx} u = u_{xx} + \\frac{\\Delta x^{2}}{12} u_{xxxx} + O(\\Delta x^{4})\n$$\n$$\nD_{xx}^{2} u = \\left(\\frac{\\partial^{2}}{\\partial x^{2}} + \\frac{\\Delta x^{2}}{12}\\frac{\\partial^{4}}{\\partial x^{4}} + \\dots\\right)^{2} u = u_{xxxx} + O(\\Delta x^{2})\n$$\nSubstituting these expansions into the scheme's equation yields:\n$$\nu_{t} + \\frac{\\Delta t}{2} u_{tt} + \\dots = \\left(\\alpha + \\frac{\\gamma \\Delta x^{2}}{\\Delta t}\\right) \\left(u_{xx} + \\frac{\\Delta x^{2}}{12} u_{xxxx} + \\dots \\right) + \\alpha \\gamma \\Delta x^{2} (u_{xxxx} + \\dots)\n$$\nIsolating the $u_t$ term gives the modified PDE that the numerical scheme satisfies:\n$$\nu_{t} = \\left(\\alpha + \\frac{\\gamma \\Delta x^{2}}{\\Delta t}\\right) u_{xx} - \\frac{\\Delta t}{2} u_{tt} + \\left[ \\left(\\alpha + \\frac{\\gamma \\Delta x^{2}}{\\Delta t}\\right)\\frac{\\Delta x^{2}}{12} + \\alpha \\gamma \\Delta x^{2} \\right] u_{xxxx} + \\dots\n$$\nThe problem requires that this scheme be consistent with the PDE $u_{t} = (\\alpha+\\epsilon)u_{xx}$. Two differential operators are consistent if their leading-order terms match. Therefore, the coefficient of the $u_{xx}$ term in our modified equation must be equal to the diffusion coefficient $(\\alpha+\\epsilon)$ in the target PDE. This dictates the following equality:\n$$\n\\alpha + \\frac{\\gamma \\Delta x^{2}}{\\Delta t} = \\alpha + \\epsilon\n$$\nSubtracting $\\alpha$ from both sides gives the condition on $\\gamma$:\n$$\n\\frac{\\gamma \\Delta x^{2}}{\\Delta t} = \\epsilon\n$$\nSolving for $\\gamma$ yields the unique closed-form expression:\n$$\n\\gamma = \\epsilon \\frac{\\Delta t}{\\Delta x^{2}}\n$$\nThis result is in terms of the specified parameters $\\epsilon$, $\\Delta t$, and $\\Delta x$. Given that $\\epsilon>0$, $\\Delta t>0$, and $\\Delta x^2>0$, the condition $\\gamma>0$ is satisfied.\n\nFinally, we must verify that this choice of $\\gamma$ leads to a scheme that is first-order accurate in time, as stated in the problem. The local truncation error with respect to the target PDE is given by the higher-order terms in the modified equation. Substituting our expression for $\\gamma$:\n$$\nu_{t} - (\\alpha + \\epsilon)u_{xx} = - \\frac{\\Delta t}{2} u_{tt} + \\left[ \\frac{(\\alpha + \\epsilon)\\Delta x^{2}}{12} + \\alpha \\left(\\epsilon \\frac{\\Delta t}{\\Delta x^{2}}\\right) \\Delta x^{2} \\right] u_{xxxx} + \\dots\n$$\n$$\nu_{t} - (\\alpha + \\epsilon)u_{xx} = - \\frac{\\Delta t}{2} u_{tt} + \\left( \\frac{(\\alpha + \\epsilon)\\Delta x^{2}}{12} + \\alpha \\epsilon \\Delta t \\right) u_{xxxx} + \\dots\n$$\nThe terms on the right-hand side represent the leading-order truncation error. The error terms are of order $O(\\Delta t)$ and $O(\\Delta x^{2})$. In the specified parabolic refinement regime, the ratio $\\Delta t/\\Delta x^{2}$ is held fixed, implying that $\\Delta t$ and $\\Delta x^{2}$ approach zero at the same rate. Thus, the overall truncation error is $O(\\Delta t, \\Delta x^{2})$. This corresponds to a method that is first-order in time and second-order in space. The condition of first-order accuracy in time is therefore met. The derived expression for $\\gamma$ is correct and unique.", "answer": "$$\n\\boxed{\\epsilon \\frac{\\Delta t}{\\Delta x^{2}}}\n$$", "id": "2408003"}, {"introduction": "Stability, the second pillar of the Lax Equivalence Principle, ensures that errors introduced during computation do not grow uncontrollably. While students often focus on the Courant-Friedrichs-Lewy (CFL) condition for the interior of the domain, this is only part of the story. This computational practice [@problem_id:2407931] demonstrates a critical real-world lesson: stability is a global property of the numerical system, and an improperly implemented boundary condition can render an otherwise stable scheme useless. You will see firsthand how a subtle error at the boundary can lead to a catastrophic failure of the simulation.", "problem": "Consider the one-dimensional wave equation on the spatial interval $[0,1]$ with wave speed $c>0$,\n$$u_{tt}(x,t)=c^2 u_{xx}(x,t),$$\nsubject to reflecting (free-end) boundary conditions $u_x(0,t)=0$ and $u_x(1,t)=0$, and initial data $u(x,0)=\\cos(2\\pi x)$ and $u_t(x,0)=0$. Discretize space with $J+1$ nodes indexed by $j=0,1,\\dots,J$ at points $x_j=j\\Delta x$, where $\\Delta x=1/J$, and discretize time with steps $t^n=n\\Delta t$, $n=0,1,\\dots,N_t$. Define the Courant-Friedrichs-Lewy (CFL) number $\\sigma = c\\,\\Delta t/\\Delta x$. Consider the second-order explicit finite-difference scheme\n$$u_j^{n+1}=2u_j^n-u_j^{n-1}+\\sigma^2\\left(u_{j+1}^n-2u_j^n+u_{j-1}^n\\right),$$\napplied for all grid indices $j=0,1,\\dots,J$ at each time level $n\\ge 1$, with the understanding that ghost values $u_{-1}^n$ and $u_{J+1}^n$ must be supplied to close the scheme at the boundaries. Use the second-order accurate first-step initialization consistent with $u_t(x,0)=0$,\n$$u_j^{1}=u_j^{0}+\\frac{1}{2}\\sigma^2\\left(u_{j+1}^{0}-2u_j^{0}+u_{j-1}^{0}\\right),$$\nagain interpreted for $j=0$ and $j=J$ using boundary closures via ghost values.\n\nDefine two distinct boundary closures for the ghost values:\n- Correct reflecting closure (free-end, consistent with $u_x=0$): $u_{-1}^n=+u_1^n$ and $u_{J+1}^n=+u_{J-1}^n$ for all $n$.\n- Incorrect reflecting closure with an erroneous amplification factor $\\beta>0$: $u_{-1}^n=\\beta\\,u_1^n$ and $u_{J+1}^n=\\beta\\,u_{J-1}^n$ for all $n$. Note that the correct reflecting closure corresponds to $\\beta=1$.\n\nFor each simulation, define the initial amplitude $M_0=\\max_{0\\le j\\le J}\\left|u_j^0\\right|$ and the running maximum $M_{\\max}=\\max_{0\\le n\\le N_t}\\max_{0\\le j\\le J}\\left|u_j^n\\right|$. Declare the discrete evolution to be unstable if the growth factor $G=M_{\\max}/M_0$ exceeds a specified threshold $R$, where $R=10$.\n\nYour task is to write a program that, for the parameter sets listed below, integrates the scheme and reports a boolean for each case indicating whether the evolution is unstable according to the above criterion. Use $c=1$, $u_j^0=\\cos(2\\pi x_j)$, and $u_j^{-1}$ not explicitly stored. Compute $\\Delta t=\\sigma\\,\\Delta x/c$ from the given $\\sigma$, and use the scheme exactly as stated.\n\nTest suite (each tuple is $(J,N_t,\\sigma,\\beta)$):\n- Case A: $(200,3000,0.9,1.0)$.\n- Case B: $(200,3000,0.9,1.2)$.\n- Case C: $(200,3000,1.0,1.0)$.\n- Case D: $(200,800,0.9,1.2)$.\n- Case E: $(100,5000,0.6,1.05)$.\n\nFinal output format: Your program should produce a single line of output containing a comma-separated list of Python booleans in the same order as the above cases, enclosed in square brackets, for example, $[\\text{True},\\text{False},\\dots]$. No other text should be printed. All quantities are dimensionless; no physical units are required. The output for each case must be a boolean computed from the growth criterion with threshold $R=10$ as defined above.", "solution": "The problem statement must first be subjected to rigorous validation.\n\n### Step 1: Extract Givens\n- **Partial Differential Equation**: $u_{tt}(x,t)=c^2 u_{xx}(x,t)$ for $x \\in [0,1]$.\n- **Wave Speed**: $c > 0$.\n- **Boundary Conditions (BCs)**: Reflecting (free-end) conditions, $u_x(0,t)=0$ and $u_x(1,t)=0$.\n- **Initial Conditions (ICs)**: $u(x,0)=\\cos(2\\pi x)$ and $u_t(x,0)=0$.\n- **Spatial Discretization**: $J+1$ nodes $x_j=j\\Delta x$ for $j=0,1,\\dots,J$, where $\\Delta x=1/J$.\n- **Temporal Discretization**: Time steps $t^n=n\\Delta t$ for $n=0,1,\\dots,N_t$.\n- **CFL Number**: $\\sigma = c\\,\\Delta t/\\Delta x$.\n- **Finite Difference Scheme (for $n \\ge 1$)**: $u_j^{n+1}=2u_j^n-u_j^{n-1}+\\sigma^2\\left(u_{j+1}^n-2u_j^n+u_{j-1}^n\\right)$.\n- **First-Step Initialization**: $u_j^{1}=u_j^{0}+\\frac{1}{2}\\sigma^2\\left(u_{j+1}^{0}-2u_j^{0}+u_{j-1}^{0}\\right)$.\n- **Ghost Value Closures**:\n    - Correct: $u_{-1}^n=+u_1^n$ and $u_{J+1}^n=+u_{J-1}^n$ (corresponds to $\\beta=1$).\n    - Incorrect: $u_{-1}^n=\\beta\\,u_1^n$ and $u_{J+1}^n=\\beta\\,u_{J-1}^n$ for a given $\\beta>0$.\n- **Instability Criterion**: An evolution is declared unstable if the growth factor $G=M_{\\max}/M_0$ exceeds the threshold $R=10$.\n    - Initial amplitude: $M_0=\\max_{0\\le j\\le J}\\left|u_j^0\\right|$.\n    - Running maximum: $M_{\\max}=\\max_{0\\le n\\le N_t}\\max_{0\\le j\\le J}\\left|u_j^n\\right|$.\n- **Simulation Parameters**:\n    - Constant: $c=1$.\n    - Initial state: $u_j^0=\\cos(2\\pi x_j)$.\n    - Test Suite $(J, N_t, \\sigma, \\beta)$:\n        - A: $(200, 3000, 0.9, 1.0)$\n        - B: $(200, 3000, 0.9, 1.2)$\n        - C: $(200, 3000, 1.0, 1.0)$\n        - D: $(200, 800, 0.9, 1.2)$\n        - E: $(100, 5000, 0.6, 1.05)$\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to validation against the established criteria.\n- **Scientifically Grounded**: The problem concerns the numerical solution of the one-dimensional wave equation using a standard explicit finite difference method. This is a canonical topic in computational engineering and numerical analysis. The investigation of numerical stability, particularly the influence of boundary condition implementations, is a fundamental and critical aspect of the field. The problem is sound.\n- **Well-Posed**: The underlying partial differential equation with the specified initial and boundary conditions is a well-posed problem. The numerical task is also well-posed: it requires a deterministic simulation with all parameters and procedures defined, leading to a unique, computable result for each test case.\n- **Objective**: The problem is stated using precise mathematical and algorithmic language. The criterion for instability is quantitative and unambiguous.\n- **Completeness and Consistency**: All necessary information—the PDE, domain, ICs, BCs, numerical scheme, parameters, and evaluation metric—is provided. There are no contradictions.\n- **Feasibility**: The specified grid sizes ($J=100, 200$) and number of time steps ($N_t \\le 5000$) are computationally manageable.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a well-defined exercise in numerical analysis. A solution will be provided.\n\n### Solution\n\nThe task is to simulate the one-dimensional wave equation, $u_{tt} = c^2 u_{xx}$, using a specified finite difference scheme and evaluate its stability under different boundary implementations.\n\n**1. Discretization and Scheme**\n\nThe provided finite difference scheme is derived by replacing the partial derivatives with second-order accurate central difference approximations:\n$$ u_{tt}(x_j, t^n) \\approx \\frac{u_j^{n+1} - 2u_j^n + u_j^{n-1}}{(\\Delta t)^2} $$\n$$ u_{xx}(x_j, t^n) \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} $$\nSubstituting these into the PDE $u_{tt} = c^2 u_{xx}$ and rearranging yields the specified three-level explicit scheme:\n$$ u_j^{n+1} = 2u_j^n - u_j^{n-1} + \\left(\\frac{c \\Delta t}{\\Delta x}\\right)^2 \\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right) $$\n$$ u_j^{n+1} = 2u_j^n - u_j^{n-1} + \\sigma^2 \\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right) $$\nThis scheme is conditionally stable. A von Neumann stability analysis for the scheme on an infinite domain (or with periodic boundary conditions) shows that stability requires the Courant-Friedrichs-Lewy (CFL) condition to be met: $\\sigma \\le 1$.\n\n**2. Initial Conditions**\n\nThe initial condition $u(x,0) = \\cos(2\\pi x)$ is discretized as $u_j^0 = \\cos(2\\pi x_j)$. The second initial condition, $u_t(x,0) = 0$, is incorporated using a second-order accurate method to find the solution at the first time step, $u_j^1$. We use a Taylor series expansion for $u(x, t)$ around $t=0$:\n$$ u(x_j, \\Delta t) = u(x_j, 0) + \\Delta t \\, u_t(x_j, 0) + \\frac{(\\Delta t)^2}{2} u_{tt}(x_j, 0) + \\mathcal{O}((\\Delta t)^3) $$\nGiven $u_t(x_j, 0) = 0$ and $u_{tt} = c^2 u_{xx}$, this simplifies to:\n$$ u_j^1 \\approx u_j^0 + \\frac{(c \\Delta t)^2}{2} u_{xx}(x_j, 0) \\approx u_j^0 + \\frac{c^2 (\\Delta t)^2}{2} \\frac{u_{j+1}^0 - 2u_j^0 + u_{j-1}^0}{(\\Delta x)^2} $$\n$$ u_j^1 = u_j^0 + \\frac{\\sigma^2}{2} \\left(u_{j+1}^0 - 2u_j^0 + u_{j-1}^0\\right) $$\nThis is precisely the first-step formula provided in the problem statement.\n\n**3. Boundary Conditions and Ghost Points**\n\nThe scheme requires values at $j=-1$ and $j=J+1$ to compute updates for $u_0^{n+1}$ and $u_J^{n+1}$, respectively. These are \"ghost points\" outside the physical domain. Their values are determined by the boundary conditions.\nThe Neumann condition $u_x(0,t)=0$ is discretized using a second-order central difference at $x_0=0$:\n$$ \\frac{u_1^n - u_{-1}^n}{2\\Delta x} = 0 \\implies u_{-1}^n = u_1^n $$\nSimilarly, at $x_J=1$, $u_x(1,t)=0$ implies $u_{J+1}^n = u_{J-1}^n$. This corresponds to the case $\\beta=1$.\nThe problem introduces a generalized, potentially incorrect closure, $u_{-1}^n = \\beta u_1^n$ and $u_{J+1}^n = \\beta u_{J-1}^n$. For $\\beta=1$, the boundary condition is consistent with the PDE's reflecting boundary. For $\\beta \\neq 1$, the numerical boundary condition is inconsistent. Specifically, if $\\beta > 1$, the reflected wave at the boundary is amplified, introducing a non-physical energy source. This is a known mechanism for boundary-induced numerical instability, even if the interior scheme satisfies the CFL condition ($\\sigma \\le 1$).\n\n**4. Algorithmic Implementation**\nFor each test case $(J, N_t, \\sigma, \\beta)$, the simulation proceeds as follows:\n1.  **Setup**: The spatial grid $x_j$ is created. Three arrays, which we denote $u_p$, $u_c$, and $u_n$, are allocated to store the solution at time levels $n-1$, $n$, and $n+1$.\n2.  **Initialization**: The initial condition $u_j^0 = \\cos(2\\pi x_j)$ is stored in $u_p$. The initial maximum amplitude $M_0 = \\max_j|u_j^0| = 1$ is recorded, and the running maximum $M_{\\max}$ is initialized to $M_0$.\n3.  **First Time Step**: The solution $u_j^1$ is computed and stored in $u_c$ using the special first-step formula. For the boundary points $j=0$ and $j=J$, the ghost point values $u_{-1}^0 = \\beta u_1^0$ and $u_{J+1}^0 = \\beta u_{J-1}^0$ are substituted into the formula.\n    - At $j=0$: $u_0^1 = u_0^0 + \\frac{\\sigma^2}{2} \\left((1+\\beta)u_1^0 - 2u_0^0\\right)$.\n    - At $j=J$: $u_J^1 = u_J^0 + \\frac{\\sigma^2}{2} \\left((1+\\beta)u_{J-1}^0 - 2u_J^0\\right)$.\n    After this step, $M_{\\max}$ is updated.\n4.  **Main Loop**: A loop runs for $n$ from $1$ to $N_t-1$. In each iteration, the solution $u_j^{n+1}$ is computed and stored in $u_n$ using the main three-level scheme, with $u_p$ holding $u^{n-1}$ and $u_c$ holding $u^n$. The ghost point substitutions are used for the boundary updates:\n    - At $j=0$: $u_0^{n+1} = 2u_0^n - u_0^{n-1} + \\sigma^2 \\left((1+\\beta)u_1^n - 2u_0^n\\right)$.\n    - At $j=J$: $u_J^{n+1} = 2u_J^n - u_J^{n-1} + \\sigma^2 \\left((1+\\beta)u_{J-1}^n - 2u_J^n\\right)$.\n    After each time step, $M_{\\max}$ is updated with the maximum amplitude of the newly computed solution. To proceed to the next step, the array references are efficiently rotated: $u_p$ becomes the old $u_c$, $u_c$ becomes the old $u_n$, and the old $u_p$ array is used as the buffer for the next time step's result.\n5.  **Evaluation**: After completing $N_t$ time steps, the growth factor $G = M_{\\max} / M_0$ is calculated. The simulation is declared unstable if $G > R$, where $R=10$.\n\nThis procedure is implemented for each test case to determine its stability. Cases with $\\sigma \\le 1$ and $\\beta=1$ are expected to be stable. Cases with $\\beta > 1$ are expected to be unstable, provided the simulation runs long enough for the boundary-induced growth to exceed the threshold.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the wave equation problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (J, Nt, sigma, beta)\n        (200, 3000, 0.9, 1.0),  # Case A\n        (200, 3000, 0.9, 1.2),  # Case B\n        (200, 3000, 1.0, 1.0),  # Case C\n        (200, 800, 0.9, 1.2),   # Case D\n        (100, 5000, 0.6, 1.05), # Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        J, Nt, sigma, beta = case\n        is_unstable = run_simulation(J, Nt, sigma, beta)\n        results.append(is_unstable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(J, Nt, sigma, beta):\n    \"\"\"\n    Runs a single simulation of the discretized wave equation.\n\n    Args:\n        J (int): Number of intervals in space (J+1 grid points).\n        Nt (int): Number of time steps.\n        sigma (float): Courant-Friedrichs-Lewy (CFL) number.\n        beta (float): Amplification factor for the boundary closure.\n\n    Returns:\n        bool: True if the simulation is unstable, False otherwise.\n    \"\"\"\n    c = 1.0\n    R = 10.0\n    \n    # Spatial grid setup\n    dx = 1.0 / J\n    x = np.linspace(0, 1, J + 1)\n\n    # Initialize solution arrays for time levels n-1, n, n+1\n    # u_p: solution at previous time step (initialized to t=0)\n    # u_c: solution at current time step\n    # u_n: solution at next time step (used as a buffer)\n    u_p = np.cos(2 * np.pi * x)\n    u_c = np.zeros_like(u_p)\n    u_n = np.zeros_like(u_p)\n\n    # Calculate initial maximum amplitude and initialize running maximum\n    M0 = np.max(np.abs(u_p))\n    if M0 == 0: M0 = 1.0 # Avoid division by zero for trivial ICs\n    M_max = M0\n\n    sigma_sq = sigma**2\n\n    # --- First time step (n=0 -> n=1), using special formula for u_t=0 ---\n    # Interior points\n    u_c[1:J] = u_p[1:J] + 0.5 * sigma_sq * (u_p[2:J+1] - 2 * u_p[1:J] + u_p[0:J-1])\n    \n    # Boundary j=0 (u_{-1} = beta * u_1)\n    u_c[0] = u_p[0] + 0.5 * sigma_sq * ((1 + beta) * u_p[1] - 2 * u_p[0])\n    \n    # Boundary j=J (u_{J+1} = beta * u_{J-1})\n    u_c[J] = u_p[J] + 0.5 * sigma_sq * ((1 + beta) * u_p[J-1] - 2 * u_p[J])\n\n    M_max = max(M_max, np.max(np.abs(u_c)))\n    \n    # --- Main time-stepping loop (n=1 to Nt-1) ---\n    # At start of loop: u_p is u^{n-1}, u_c is u^n. We compute u^{n+1}.\n    for n in range(1, Nt):\n        # Interior points j=1,...,J-1\n        u_n[1:J] = 2 * u_c[1:J] - u_p[1:J] + sigma_sq * (u_c[2:J+1] - 2 * u_c[1:J] + u_c[0:J-1])\n        \n        # Boundary j=0\n        u_n[0] = 2 * u_c[0] - u_p[0] + sigma_sq * ((1 + beta) * u_c[1] - 2 * u_c[0])\n        \n        # Boundary j=J\n        u_n[J] = 2 * u_c[J] - u_p[J] + sigma_sq * ((1 + beta) * u_c[J-1] - 2 * u_c[J])\n        \n        # Update running maximum\n        M_max = max(M_max, np.max(np.abs(u_n)))\n\n        # Efficiently rotate array references for the next iteration\n        u_p, u_c, u_n = u_c, u_n, u_p\n\n    # Check for instability\n    growth_factor = M_max / M0\n    return growth_factor > R\n\nsolve()\n```", "id": "2407931"}, {"introduction": "Having explored consistency and stability individually, we now synthesize these concepts using the full power of the Lax Equivalence Principle. The principle's statement that consistency and stability together are equivalent to convergence for well-posed linear problems is a cornerstone of numerical verification. In this capstone exercise [@problem_id:2407986], you will design a numerical experiment to test an unknown 'black-box' solver, using observed convergence to a manufactured solution as a practical test for consistency. This task mirrors the verification practices used in professional scientific software development, turning abstract theory into a robust tool for assessing code correctness.", "problem": "You are given oracle access to a single-step integrator for a one-dimensional periodic Partial Differential Equation (PDE) initial value problem on the spatial interval $[0,1]$ with periodic boundary conditions. You cannot see or modify the internal numerical scheme used by the integrator; you may only invoke it as a black box with a chosen spatial grid and time step. Your task is to design, implement, and execute a numerical experiment to determine, from first principles, whether the underlying discrete scheme is consistent with the linear advection PDE\n$$\nu_t + a\\,u_x = 0,\n$$\nwhere $a$ is a given positive constant, on $x\\in[0,1]$ with periodic boundary conditions.\n\nThe fundamental definitions that you may assume without proof are:\n- Consistency: the local truncation error of a discrete scheme for a PDE tends to zero as the mesh spacings tend to zero.\n- Stability: the solution produced by the discrete scheme remains uniformly bounded in an appropriate norm when applied to a homogeneous linear problem with bounded data, for all sufficiently fine discretizations.\n- Lax Equivalence Principle (Lax): for a linear, well-posed initial value problem, a consistent scheme is convergent if and only if it is stable; conversely, convergence implies consistency.\n\nYour numerical experiment must be based only on these fundamental definitions and facts. In particular, do not assume any particular discrete stencil or order of accuracy of the unknown scheme. You must reason from the base definitions to decide how to test consistency.\n\nDesign requirements for your numerical experiment:\n- Use the method of manufactured solutions: choose a smooth, periodic, exact solution of the target PDE and use it to construct initial and boundary data. A convenient choice is\n$$\nu(x,t) = \\sin\\!\\big(2\\pi(x - a t)\\big),\n$$\nwhich exactly solves $u_t + a\\,u_x = 0$ on $[0,1]$ with periodic boundary conditions for any constant $a>0$.\n- Spatial domain and grids: use uniform periodic grids with $N_x$ points over $[0,1)$, so that $\\Delta x = 1/N_x$. Consider the refinement sequence $N_x \\in \\{50, 100, 200, 400\\}$.\n- Time step selection: for each $N_x$, choose $\\Delta t = \\text{CFL}\\cdot \\Delta x/a$ with a fixed Courant–Friedrichs–Lewy (CFL) number $\\text{CFL} = 0.45$ to ensure a proportional refinement of temporal and spatial scales.\n- Final time: use $T = 1.0$. For the chosen manufactured solution and $a=1$, $u(\\cdot,T)$ equals $u(\\cdot,0)$ due to periodicity, which simplifies error assessment.\n- Error metric: for each grid, compute the discrete root-mean-square (RMS) error at time $T$,\n$$\nE(N_x) = \\Bigg(\\frac{1}{N_x}\\sum_{j=0}^{N_x-1}\\big(u_j^{\\text{num}}(T) - u(x_j,T)\\big)^2\\Bigg)^{1/2},\n$$\nwhere $x_j=j\\Delta x$ and $u_j^{\\text{num}}(T)$ is the black-box solution at time $T$.\n- Boundedness monitor: for each run, compute the amplification ratio\n$$\nG = \\frac{\\max_j |u_j^{\\text{num}}(T)|}{\\max_j |u_j^{\\text{num}}(0)|}.\n$$\nIf at any refinement level the run produces a non-finite number or $G > 10^3$, declare the scheme unstable for the tested configuration and treat the consistency verdict as inconclusive for that case.\n\nDecision rule grounded in the Lax Equivalence Principle:\n- If instability is detected on any refinement level (non-finite values or $G>10^3$), output the integer $-1$ for that case (unstable; cannot conclude consistency).\n- Otherwise, if the error sequence $E(N_x)$ is strictly decreasing with refinement and the finest-grid error satisfies $E(400) < 0.05$, declare the scheme convergent, hence consistent by Lax; output the integer $1$ for that case.\n- Otherwise, if the sequence does not decrease or the finest-grid error does not fall below the stated tolerance, declare the scheme inconsistent with the target PDE; output the integer $0$ for that case.\n\nTest suite and parameters:\n- Apply your experiment to three opaque solver instances, each purporting to solve the target problem, identified as $\\text{BB1}$, $\\text{BB2}$, and $\\text{BB3}$. Treat them as black boxes whose internals you cannot inspect. Use the parameters $a=1.0$, $\\text{CFL}=0.45$, and $T=1.0$ for all three.\n- Your program must execute the experiment for the three identifiers in the order $[\\text{BB1},\\text{BB2},\\text{BB3}]$ and produce a verdict per identifier using the decision rule above.\n\nFinal output format:\n- Your program should produce a single line of output containing the three integer results in a comma-separated list enclosed in square brackets, in the order $[\\text{BB1},\\text{BB2},\\text{BB3}]$. For example, a valid output could be $[1,0,-1]$.", "solution": "We begin from the foundational definitions of consistency, stability, and the Lax Equivalence Principle (Lax). For a linear, well-posed initial value problem such as the constant-coefficient advection equation $u_t + a u_x = 0$ with periodic boundary conditions, the Lax Equivalence Principle states that consistency together with stability is equivalent to convergence, and conversely convergence implies consistency. Therefore, if we can empirically observe convergence while also ruling out instability along a refinement path, then we can conclude consistency of the underlying scheme with respect to the given PDE.\n\nTo operationalize this with only black-box access to a solver, we use the method of manufactured solutions. Choose an exact smooth solution of the target PDE; we pick $u(x,t) = \\sin(2\\pi(x - a t))$, which satisfies $u_t + a u_x = 0$ on $[0,1]$ with periodic boundary conditions for any constant $a>0$. For $a=1$ and $T=1$, periodicity gives $u(x,1)=u(x,0)$, which facilitates error assessment because any discrepancy at time $T$ stems solely from discretization effects and not from changes in the exact solution’s amplitude or phase on the periodic domain.\n\nWe define a refinement path by uniform grids with $N_x \\in \\{50,100,200,400\\}$ so that $\\Delta x = 1/N_x$. To balance spatial and temporal refinement, we choose a fixed Courant–Friedrichs–Lewy number $\\text{CFL}=0.45$ and set $\\Delta t = \\text{CFL}\\cdot \\Delta x/a$. This ensures that both $\\Delta x \\to 0$ and $\\Delta t \\to 0$ proportionally, which is compatible with stability constraints of typical explicit advection schemes and keeps the test general.\n\nFor each refinement level, we supply the manufactured initial condition $u(x,0)=\\sin(2\\pi x)$ to the black-box solver and integrate to final time $T=1$. We then compute the discrete root-mean-square error\n$$\nE(N_x) = \\left(\\frac{1}{N_x}\\sum_{j=0}^{N_x-1}\\big(u_j^{\\text{num}}(T) - \\sin(2\\pi(x_j - a T))\\big)^2\\right)^{1/2}.\n$$\nTo guard against instability (which would invalidate a conclusion about consistency from convergence failure), we also monitor the amplification ratio\n$$\nG = \\frac{\\max_j |u_j^{\\text{num}}(T)|}{\\max_j |u_j^{\\text{num}}(0)|}.\n$$\nIf non-finite values appear or $G>10^3$ on any refinement, we classify the run as unstable and report $-1$ because Lax indicates that, without stability, non-convergence does not imply inconsistency.\n\nIf all runs remain bounded, we assess convergence by the behavior of $E(N_x)$ across refinements. A consistent and stable scheme should yield $E(N_x)\\to 0$ as $N_x\\to\\infty$. We adopt two quantitative checks that are robust and do not assume a particular order:\n- The error must strictly decrease with each refinement, i.e., $E(400) < E(200) < E(100) < E(50)$.\n- The finest-grid error must be small relative to the signal magnitude; we require $E(400) < 0.05$.\n\nIf both are satisfied, we declare convergence and, by Lax, consistency, and report $1$. Otherwise, the scheme is bounded but does not converge to the target PDE solution; we declare it inconsistent and report $0$.\n\nFor the provided test suite, there are three opaque solver instances: $\\text{BB1}$, $\\text{BB2}$, and $\\text{BB3}$, all tested with $a=1.0$, $\\text{CFL}=0.45$, $T=1.0$. Applying the procedure:\n- For $\\text{BB1}$, the error decreases under refinement and the finest-grid error is below the threshold, indicating convergence; hence, by Lax, the scheme is consistent with the advection PDE, and the verdict is $1$.\n- For $\\text{BB2}$, the runs remain bounded but the error does not decrease to near-zero as the mesh is refined (it asymptotes to a nonzero modeling error due to solving a different dynamics), so the verdict is $0$ (inconsistent).\n- For $\\text{BB3}$, the amplification ratio exceeds the stability threshold on at least one refinement, indicating instability; we cannot conclude consistency, so the verdict is $-1$.\n\nThe program implements the experiment, computes the errors and amplification ratios, applies the decision rule, and prints the results as a single line in the format $[r_1,r_2,r_3]$ for $[\\text{BB1},\\text{BB2},\\text{BB3}]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef manufactured_solution(x, t, a):\n    # u(x,t) = sin(2*pi*(x - a t))\n    return np.sin(2.0 * np.pi * (x - a * t))\n\ndef bb1_upwind_advection(u0, a, dx, dt, T):\n    \"\"\"\n    Black-box BB1: Upwind scheme for linear advection (a>0), periodic domain.\n    Stable for CFL <= 1, first-order accurate, consistent with advection PDE.\n    \"\"\"\n    u = u0.copy()\n    steps = max(1, int(np.ceil(T / dt)))\n    dt_eff = T / steps\n    cfl = a * dt_eff / dx\n    max_amp = np.max(np.abs(u))\n    for _ in range(steps):\n        u = u - cfl * (u - np.roll(u, 1))\n        # Monitor growth\n        max_amp = max(max_amp, np.max(np.abs(u)))\n        if not np.isfinite(max_amp) or max_amp > 1e8:  # early exit on blow-up\n            break\n    return u, max_amp\n\ndef bb2_implicit_heat(u0, nu, dx, dt, T):\n    \"\"\"\n    Black-box BB2: Backward Euler (implicit) for heat equation u_t = nu u_xx, periodic.\n    Unconditionally stable, but inconsistent with advection PDE if tested against it.\n    Uses spectral diagonalization of the discrete Laplacian.\n    \"\"\"\n    u = u0.copy()\n    N = u.size\n    steps = max(1, int(np.ceil(T / dt)))\n    dt_eff = T / steps\n    mu = nu * dt_eff / (dx * dx)\n\n    # Precompute spectral denominator for backward Euler: 1 + 4*mu*sin^2(pi k / N)\n    k = np.arange(0, N//2 + 1, dtype=float)  # rfft frequencies\n    s2 = np.sin(np.pi * k / N) ** 2\n    denom = 1.0 + 4.0 * mu * s2\n\n    max_amp = np.max(np.abs(u))\n    for _ in range(steps):\n        U = np.fft.rfft(u)\n        U_next = U / denom\n        u = np.fft.irfft(U_next, n=N)\n        max_amp = max(max_amp, np.max(np.abs(u)))\n        if not np.isfinite(max_amp) or max_amp > 1e8:\n            break\n    return u, max_amp\n\ndef bb3_ftcs_advection(u0, a, dx, dt, T):\n    \"\"\"\n    Black-box BB3: FTCS (Forward-Time Centered-Space) for advection, periodic.\n    This is known to be unstable for linear advection; intended to trigger instability.\n    \"\"\"\n    u = u0.copy()\n    steps = max(1, int(np.ceil(T / dt)))\n    dt_eff = T / steps\n    cfl = a * dt_eff / dx\n    max_amp = np.max(np.abs(u))\n    for _ in range(steps):\n        u = u - 0.5 * cfl * (np.roll(u, -1) - np.roll(u, 1))\n        max_amp = max(max_amp, np.max(np.abs(u)))\n        if np.any(~np.isfinite(u)) or max_amp > 1e8:\n            break\n    return u, max_amp\n\ndef run_black_box(identifier, Nx, a, cfl, T, nu_heat=0.01):\n    \"\"\"\n    Emulated black-box dispatcher. Interface is opaque to the experiment logic.\n    \"\"\"\n    dx = 1.0 / Nx\n    dt = cfl * dx / abs(a) if a != 0 else cfl * dx\n    x = np.linspace(0.0, 1.0, Nx, endpoint=False)\n    u0 = manufactured_solution(x, 0.0, a)\n\n    if identifier == \"BB1\":\n        un, max_amp = bb1_upwind_advection(u0, a, dx, dt, T)\n    elif identifier == \"BB2\":\n        un, max_amp = bb2_implicit_heat(u0, nu_heat, dx, dt, T)\n    elif identifier == \"BB3\":\n        un, max_amp = bb3_ftcs_advection(u0, a, dx, dt, T)\n    else:\n        raise ValueError(\"Unknown black-box identifier.\")\n\n    return x, u0, un, max_amp, dt\n\ndef classify_consistency(identifier, a=1.0, cfl=0.45, T=1.0):\n    \"\"\"\n    Execute the Lax-principle-based numerical experiment to determine\n    if the black-box scheme is consistent with the advection PDE.\n    Returns:\n    -1: unstable (cannot conclude),\n     1: consistent (convergent and bounded),\n     0: inconsistent (bounded but non-convergent).\n    \"\"\"\n    Nx_list = [50, 100, 200, 400]\n    errors = []\n    unstable = False\n    for Nx in Nx_list:\n        x, u0, un, max_amp, dt_used = run_black_box(identifier, Nx, a, cfl, T)\n        # Exact at final time\n        u_exact_T = manufactured_solution(x, T, a)\n        # Compute RMS error\n        err = np.sqrt(np.mean((un - u_exact_T) ** 2))\n        errors.append(err)\n        # Boundedness monitor\n        init_amp = np.max(np.abs(u0))\n        if init_amp == 0:\n            growth = np.inf if np.max(np.abs(un)) > 0 else 1.0\n        else:\n            growth = (np.max(np.abs(un)) / init_amp)\n        if not np.isfinite(growth) or growth > 1e3 or not np.all(np.isfinite(un)):\n            unstable = True\n            break\n\n    if unstable:\n        return -1\n\n    # Check monotonic decrease and small finest error\n    monotone = all(errors[i+1] < errors[i] for i in range(len(errors)-1))\n    finest_small = errors[-1] < 5e-2  # threshold per problem design\n    if monotone and finest_small:\n        return 1\n    else:\n        return 0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Three opaque solvers: BB1, BB2, BB3; parameters a=1.0, CFL=0.45, T=1.0\n    test_cases = [\n        (\"BB1\", 1.0, 0.45, 1.0),\n        (\"BB2\", 1.0, 0.45, 1.0),\n        (\"BB3\", 1.0, 0.45, 1.0),\n    ]\n\n    results = []\n    for ident, a, cfl, T in test_cases:\n        verdict = classify_consistency(ident, a=a, cfl=cfl, T=T)\n        results.append(verdict)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2407986"}]}