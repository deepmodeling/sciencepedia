{"hands_on_practices": [{"introduction": "We begin our hands-on exploration by constructing a complete numerical solver for the two-dimensional Poisson equation. This quintessential exercise bridges theory and practice, guiding you through the process of discretizing the partial differential equation using the five-point stencil and assembling the resulting sparse linear system efficiently [@problem_id:2438628]. Mastering this implementation is a cornerstone of computational science, providing a robust foundation for solving a vast range of physical problems.", "problem": "You are tasked with building a complete and efficient numerical solver for the two-dimensional Poisson equation using the standard five-point stencil on a rectangular grid. The problem is to be posed and solved in a purely mathematical and algorithmic setting, without any reliance on physical units. The solver must use the sparse matrix facilities of the Scientific Python (SciPy) library to ensure efficiency in assembly and solution.\n\nStarting point (fundamental base):\n- The two-dimensional Poisson equation is given by $-\\Delta u = f$ on a rectangular domain $\\Omega = [a_x,b_x] \\times [a_y,b_y]$, where $\\Delta$ denotes the Laplacian operator $\\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$.\n- Dirichlet boundary conditions prescribe $u = g$ on the boundary $\\partial \\Omega$.\n- The discrete approximation must be based on second-order centered finite differences on a uniform tensor-product grid with $N_x$ interior points in the $x$-direction and $N_y$ interior points in the $y$-direction. The grid spacings are $h_x = \\frac{b_x - a_x}{N_x + 1}$ and $h_y = \\frac{b_y - a_y}{N_y + 1}$.\n- The five-point stencil arises from combining the one-dimensional second-order centered differences in each coordinate direction.\n\nYour tasks:\n- Derive from Taylor expansions a consistent discrete approximation of the Laplacian that leads to a symmetric positive definite linear system for the interior grid values of $u$.\n- Design an efficient sparse assembly of the linear system using SciPyâ€™s sparse matrix operations that leverages the tensor-product (Kronecker) structure induced by the grid, avoiding explicit loops over all grid points when forming the matrix.\n- Incorporate Dirichlet boundary conditions into the right-hand side via boundary contributions.\n- Solve the resulting sparse linear system with an appropriate sparse solver.\n- Assess the accuracy by computing the discrete $L^2$-error norm between the numerical solution and a known manufactured exact solution on the interior grid, defined as\n$$\n\\|e\\|_{L^2(\\Omega_h)} \\equiv \\left( \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\left(u_{ij}^{\\text{num}} - u(x_i,y_j)\\right)^2 h_x h_y \\right)^{1/2},\n$$\nwhere $(x_i,y_j)$ are the interior grid nodes, $u_{ij}^{\\text{num}}$ is the computed solution at those nodes, and $u(x,y)$ is the exact manufactured solution.\n\nTest suite:\nImplement your solver and evaluate it on the following three manufactured-solution cases. In each case, $f$ and $g$ must be constructed from the exact $u$ so that the continuous solution is known. All functions are dimensionless and there are no physical units.\n\n- Case $1$ (happy path, zero Dirichlet boundary on a unit square):\n  - Domain: $[a_x,b_x] \\times [a_y,b_y] = [0,1] \\times [0,1]$.\n  - Grid: $N_x = 32$, $N_y = 32$.\n  - Exact solution: $u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$.\n  - Right-hand side: $f(x,y)$ consistent with $-\\Delta u = f$.\n  - Boundary condition: $g(x,y) = u(x,y)$ on $\\partial \\Omega$ (which evaluates to $0$ on the entire boundary for this exact solution).\n\n- Case $2$ (nonzero Dirichlet boundary, polynomial exact solution):\n  - Domain: $[a_x,b_x] \\times [a_y,b_y] = [0,1] \\times [0,1]$.\n  - Grid: $N_x = 10$, $N_y = 10$.\n  - Exact solution: $u(x,y) = x^2 + y^2$.\n  - Right-hand side: $f(x,y)$ consistent with $-\\Delta u = f$.\n  - Boundary condition: $g(x,y) = u(x,y)$ on $\\partial \\Omega$.\n\n- Case $3$ (anisotropic spacings on a rectangular domain):\n  - Domain: $[a_x,b_x] \\times [a_y,b_y] = [0,2] \\times [0,1]$.\n  - Grid: $N_x = 15$, $N_y = 9$.\n  - Exact solution: $u(x,y) = \\sin(\\frac{\\pi}{2} x)\\sin(\\pi y)$.\n  - Right-hand side: $f(x,y)$ consistent with $-\\Delta u = f$.\n  - Boundary condition: $g(x,y) = u(x,y)$ on $\\partial \\Omega$ (which evaluates to $0$ on the entire boundary for this exact solution).\n\nOutput specification:\n- For each case, compute the discrete $L^2$-error norm on the interior grid as specified above.\n- Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, with each floating-point value rounded to eight decimal places. For example: $[0.00123456,0.00000000,0.01234567]$.\n- No other output should be produced.\n\nImplementation constraints:\n- The final program must be a complete, runnable Python script that uses the Scientific Python (SciPy) sparse matrix tools for assembly and solution and the Numerical Python (NumPy) library for array operations.\n- The assembly should exploit the tensor-product structure of the discrete operator for efficiency.", "solution": "The problem presented is a standard, well-posed exercise in numerical analysis. It requires the implementation of a finite difference solver for the two-dimensional Poisson equation. The problem is scientifically grounded, internally consistent, and contains all necessary information to proceed. We will therefore provide a complete solution.\n\nThe process is methodical. First, we derive the discrete algebraic system from the continuous partial differential equation. Second, we formalize the structure of the system matrix and establish its properties. Third, we construct an efficient algorithm for its assembly and solution. Finally, we verify the implementation against manufactured solutions.\n\n**1. Discretization of the Poisson Equation**\n\nThe governing equation is the Poisson equation on a rectangular domain $\\Omega = [a_x, b_x] \\times [a_y, b_y]$:\n$$\n-\\Delta u = -\\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) = f(x,y)\n$$\nwith Dirichlet boundary conditions $u(x,y) = g(x,y)$ for $(x,y) \\in \\partial\\Omega$.\n\nWe introduce a uniform grid with $N_x$ interior points in the $x$-direction and $N_y$ interior points in the $y$-direction. The grid coordinates are $x_i = a_x + i \\cdot h_x$ for $i=0, 1, \\dots, N_x+1$ and $y_j = a_y + j \\cdot h_y$ for $j=0, 1, \\dots, N_y+1$. The grid spacings are $h_x = \\frac{b_x - a_x}{N_x + 1}$ and $h_y = \\frac{b_y - a_y}{N_y + 1}$. The unknown values are the function values $u_{ij} \\equiv u(x_i, y_j)$ at the interior grid points, where $i \\in \\{1, \\dots, N_x\\}$ and $j \\in \\{1, \\dots, N_y\\}$.\n\nTo approximate the second derivatives, we use second-order centered finite differences. The derivation relies on Taylor series expansion. For a sufficiently smooth function $u(x,y)$, we have:\n$$\nu(x_i \\pm h_x, y_j) = u(x_i, y_j) \\pm h_x \\frac{\\partial u}{\\partial x}\\bigg|_{ij} + \\frac{h_x^2}{2} \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{ij} \\pm \\frac{h_x^3}{6} \\frac{\\partial^3 u}{\\partial x^3}\\bigg|_{ij} + O(h_x^4)\n$$\nAdding the expansions for $u(x_i + h_x, y_j)$ and $u(x_i - h_x, y_j)$ eliminates the odd-order derivative terms:\n$$\nu(x_i + h_x, y_j) + u(x_i - h_x, y_j) = 2 u(x_i, y_j) + h_x^2 \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{ij} + O(h_x^4)\n$$\nSolving for the second derivative gives the centered difference approximation:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{ij} = \\frac{u(x_{i-1}, y_j) - 2u(x_i, y_j) + u(x_{i+1}, y_j)}{h_x^2} + O(h_x^2)\n$$\nAn analogous expression holds for $\\frac{\\partial^2 u}{\\partial y^2}$. Substituting these into the Poisson equation at an interior point $(x_i, y_j)$ yields the discrete equation:\n$$\n-\\left( \\frac{u_{i-1,j} - 2u_{ij} + u_{i+1,j}}{h_x^2} + \\frac{u_{i,j-1} - 2u_{ij} + u_{i,j+1}}{h_y^2} \\right) = f_{ij}\n$$\nwhere $f_{ij} = f(x_i, y_j)$. Rearranging terms, we obtain the five-point stencil formula:\n$$\n\\left(\\frac{2}{h_x^2} + \\frac{2}{h_y^2}\\right)u_{ij} - \\frac{1}{h_x^2}u_{i-1,j} - \\frac{1}{h_x^2}u_{i+1,j} - \\frac{1}{h_y^2}u_{i,j-1} - \\frac{1}{h_y^2}u_{i,j+1} = f_{ij}\n$$\nThis system of $N_x \\times N_y$ linear algebraic equations must be solved for the unknowns $u_{ij}$.\n\n**2. Linear System Assembly and Kronecker Product Structure**\n\nTo solve this system, we must express it in the matrix form $A\\mathbf{u} = \\mathbf{b}$. This requires mapping the two-dimensional grid of unknowns $\\{u_{ij}\\}$ to a one-dimensional vector $\\mathbf{u}$ of size $N_x N_y$. We adopt a column-major (lexicographical) ordering, where the index $k$ for the unknown $u_{ij}$ is given by $k = (i-1) + (j-1)N_x$, for $i \\in \\{1,\\dots,N_x\\}$ and $j \\in \\{1,\\dots,N_y\\}$.\n\nThe discrete negative Laplacian operator can be expressed as the sum of two operators, one for each spatial dimension: $L_h = L_x + L_y$. With the chosen vectorization, this separation of variables induces a tensor product, also known as Kronecker product, structure in the system matrix $A$.\n\nLet $A_x$ be the matrix representing the one-dimensional negative second derivative operator $-\\frac{d^2}{dx^2}$ on a grid with $N_x$ points. It is an $N_x \\times N_x$ tridiagonal matrix:\n$$\nA_x = \\frac{1}{h_x^2} \\begin{pmatrix} 2 & -1 & & \\\\ -1 & 2 & -1 & \\\\ & \\ddots & \\ddots & \\ddots \\\\ & & -1 & 2 & -1 \\\\ & & & -1 & 2 \\end{pmatrix}\n$$\nSimilarly, let $A_y$ be the corresponding $N_y \\times N_y$ matrix for the $y$-direction. Let $I_x$ and $I_y$ be identity matrices of size $N_x \\times N_x$ and $N_y \\times N_y$, respectively. The matrix $A$ representing the two-dimensional discrete negative Laplacian is given by the sum of two Kronecker products:\n$$\nA = (I_y \\otimes A_x) + (A_y \\otimes I_x)\n$$\nwhere $\\otimes$ denotes the Kronecker product. This construction results in an $(N_x N_y) \\times (N_x N_y)$ block-tridiagonal matrix. This structure is fundamental for efficient assembly using sparse matrix libraries. The matrix $A$ is symmetric and, for this problem, positive definite, which guarantees a unique solution.\n\n**3. Incorporating Boundary Conditions**\n\nWhen an interior point $(x_i, y_j)$ is adjacent to the boundary $\\partial\\Omega$, one or more of its neighbors in the stencil (e.g., $u_{i-1,j}$) has a known value prescribed by the Dirichlet condition $g(x,y)$. These known values must be moved to the right-hand side of the linear system. For example, for a point $(x_1, y_j)$ adjacent to the left boundary $x=a_x$, the term $-\\frac{1}{h_x^2} u_{0,j}$ becomes $-\\frac{1}{h_x^2} g(x_0, y_j)$, which is a known quantity. This term is added to the right-hand side, $f_{1j}$.\n\nThe general form of the $k$-th entry of the right-hand side vector $\\mathbf{b}$, corresponding to point $(x_i, y_j)$, is:\n$$\nb_k = f_{ij} + C_{bc}\n$$\nwhere $C_{bc}$ represents the sum of contributions from any adjacent boundary points. For a point $(x_i, y_j)$:\n- If $i=1$: $C_{bc}$ includes $\\frac{1}{h_x^2} g(a_x, y_j)$.\n- If $i=N_x$: $C_{bc}$ includes $\\frac{1}{h_x^2} g(b_x, y_j)$.\n- If $j=1$: $C_{bc}$ includes $\\frac{1}{h_y^2} g(x_i, a_y)$.\n- If $j=N_y$: $C_{bc}$ includes $\\frac{1}{h_y^2} g(x_i, b_y)$.\n\n**4. Numerical Implementation and Error Assessment**\n\nThe algorithm is as follows:\n1.  For a given test case, determine the domain $[a_x,b_x] \\times [a_y,b_y]$, grid dimensions $N_x, N_y$, and the analytical function for the exact solution $u(x,y)$.\n2.  Analytically compute the source term $f(x,y) = -\\Delta u(x,y)$ and the boundary function $g(x,y) = u(x,y)|_{\\partial\\Omega}$.\n3.  Construct the sparse $N_x \\times N_x$ matrix $A_x$ and $N_y \\times N_y$ matrix $A_y$ using `scipy.sparse.diags`.\n4.  Construct the full sparse system matrix $A$ of size $(N_x N_y) \\times (N_x N_y)$ using `scipy.sparse.kron`.\n5.  Construct the right-hand side vector $\\mathbf{b}$ by evaluating $f$ at all interior grid points and adding the boundary contributions as described above.\n6.  Solve the sparse linear system $A\\mathbf{u} = \\mathbf{b}$ for the vector of unknowns $\\mathbf{u}$ using a direct sparse solver like `scipy.sparse.linalg.spsolve`.\n7.  Reshape the solution vector $\\mathbf{u}$ into an $N_x \\times N_y$ grid `U_num`.\n8.  Evaluate the exact solution $u(x,y)$ on the interior grid to get `U_exact`.\n9.  Compute the discrete $L^2$-error norm:\n    $$\n    \\|e\\|_{L^2(\\Omega_h)} = \\left( \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} (u_{ij}^{\\text{num}} - u(x_i,y_j))^2 h_x h_y \\right)^{1/2}\n    $$\n\n**Test Case Details:**\n\nFor each case, we first derive the source function $f(x,y)$:\n- **Case 1:** $u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$.\n  $f = -\\Delta u = -(-\\pi^2\\sin(\\pi x)\\sin(\\pi y) - \\pi^2\\sin(\\pi x)\\sin(\\pi y)) = 2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$.\n- **Case 2:** $u(x,y) = x^2 + y^2$.\n  $f = -\\Delta u = -(2 + 2) = -4$.\n- **Case 3:** $u(x,y) = \\sin(\\frac{\\pi}{2} x)\\sin(\\pi y)$.\n  $f = -\\Delta u = -(-(\\frac{\\pi}{2})^2\\sin(\\frac{\\pi}{2} x)\\sin(\\pi y) - \\pi^2\\sin(\\frac{\\pi}{2} x)\\sin(\\pi y)) = \\frac{5\\pi^2}{4}\\sin(\\frac{\\pi}{2} x)\\sin(\\pi y)$.\n\nThe implementation will now follow these steps to compute the error for each case.", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve_poisson_2d(domain, grid_size, u_exact_func, f_func, g_func):\n    \"\"\"\n    Solves the 2D Poisson equation -Delta u = f on a rectangular domain\n    with Dirichlet boundary conditions u = g using a 5-point finite difference\n    stencil and sparse matrix representation.\n\n    Args:\n        domain (tuple): (ax, bx, ay, by) defining the domain [ax, bx] x [ay, by].\n        grid_size (tuple): (Nx, Ny) of interior grid points.\n        u_exact_func (callable): The exact solution u(x, y).\n        f_func (callable): The source term f(x, y).\n        g_func (callable): The Dirichlet boundary condition function g(x, y).\n\n    Returns:\n        float: The discrete L2-error norm of the solution.\n    \"\"\"\n    ax, bx, ay, by = domain\n    Nx, Ny = grid_size\n    N = Nx * Ny\n\n    hx = (bx - ax) / (Nx + 1)\n    hy = (by - ay) / (Ny + 1)\n\n    # Create grid for interior points\n    x_int = np.linspace(ax + hx, bx - hx, Nx)\n    y_int = np.linspace(ay + hy, by - hy, Ny)\n    X_int, Y_int = np.meshgrid(x_int, y_int, indexing='ij')\n\n    # Construct 1D Laplacian matrices\n    diagonals_x = [-1, 2, -1]\n    Ax = sparse.diags(diagonals_x, [-1, 0, 1], shape=(Nx, Nx)) / (hx**2)\n\n    diagonals_y = [-1, 2, -1]\n    Ay = sparse.diags(diagonals_y, [-1, 0, 1], shape=(Ny, Ny)) / (hy**2)\n\n    # Create identity matrices\n    Ix = sparse.identity(Nx)\n    Iy = sparse.identity(Ny)\n\n    # Construct 2D Laplacian matrix using Kronecker product (column-major ordering)\n    A = sparse.kron(Iy, Ax) + sparse.kron(Ay, Ix)\n    A = A.tocsr()\n\n    # Construct the right-hand side (RHS) vector b\n    # 1. Source term f\n    b = f_func(X_int, Y_int).flatten('F') # Use Fortran order for column-major\n\n    # 2. Boundary conditions\n    # We add contributions to b for interior points adjacent to the boundary.\n    \n    # Left and Right boundaries (x=ax, x=bx)\n    y_bnd = np.linspace(ay + hy, by - hy, Ny)\n    g_left = g_func(ax, y_bnd)\n    g_right = g_func(bx, y_bnd)\n    for j in range(Ny):\n        # A point (i=0, j) is adjacent to the left boundary\n        k = 0 + j * Nx\n        b[k] += g_left[j] / hx**2\n        # A point (i=Nx-1, j) is adjacent to the right boundary\n        k = (Nx - 1) + j * Nx\n        b[k] += g_right[j] / hx**2\n        \n    # Bottom and Top boundaries (y=ay, y=by)\n    x_bnd = np.linspace(ax + hx, bx - hx, Nx)\n    g_bottom = g_func(x_bnd, ay)\n    g_top = g_func(x_bnd, by)\n    for i in range(Nx):\n        # A point (i, j=0) is adjacent to the bottom boundary\n        k = i + 0 * Nx\n        b[k] += g_bottom[i] / hy**2\n        # A point (i, j=Ny-1) is adjacent to the top boundary\n        k = i + (Ny - 1) * Nx\n        b[k] += g_top[i] / hy**2\n\n    # Solve the linear system\n    u_vec = spsolve(A, b)\n\n    # Reshape solution vector to 2D grid\n    U_num = u_vec.reshape((Nx, Ny), order='F') # Fortran order for column-major\n\n    # Evaluate exact solution on the interior grid\n    U_exact = u_exact_func(X_int, Y_int)\n\n    # Compute discrete L2 error norm\n    error = np.sqrt(np.sum((U_num - U_exact)**2) * hx * hy)\n\n    return error\n\ndef solve():\n    \"\"\"Defines and runs the test suite.\"\"\"\n    \n    pi = np.pi\n    \n    test_cases = [\n        # Case 1: Happy path, zero Dirichlet BC\n        {\n            \"domain\": (0.0, 1.0, 0.0, 1.0),\n            \"grid_size\": (32, 32),\n            \"u_exact\": lambda x, y: np.sin(pi * x) * np.sin(pi * y),\n            \"f\": lambda x, y: 2 * pi**2 * np.sin(pi * x) * np.sin(pi * y),\n        },\n        # Case 2: Nonzero Dirichlet BC, polynomial solution\n        {\n            \"domain\": (0.0, 1.0, 0.0, 1.0),\n            \"grid_size\": (10, 10),\n            \"u_exact\": lambda x, y: x**2 + y**2,\n            \"f\": lambda x, y: -4.0 * np.ones_like(x),\n        },\n        # Case 3: Anisotropic spacings\n        {\n            \"domain\": (0.0, 2.0, 0.0, 1.0),\n            \"grid_size\": (15, 9),\n            \"u_exact\": lambda x, y: np.sin(pi/2 * x) * np.sin(pi * y),\n            \"f\": lambda x, y: (pi**2 / 4 + pi**2) * np.sin(pi/2 * x) * np.sin(pi * y),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # For all cases, the boundary condition g is simply the exact solution evaluated on the boundary.\n        g_func = case[\"u_exact\"]\n        \n        error = solve_poisson_2d(\n            domain=case[\"domain\"],\n            grid_size=case[\"grid_size\"],\n            u_exact_func=case[\"u_exact\"],\n            f_func=case[\"f\"],\n            g_func=g_func\n        )\n        results.append(error)\n\n    # Format the final output string as required.\n    formatted_results = ','.join([f\"{r:.8f}\" for r in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "2438628"}, {"introduction": "A skilled practitioner not only knows how to apply a numerical method but also understands its intrinsic limitations. This practice moves from implementation to critical analysis, using the method of manufactured solutions to investigate the anisotropic error behavior of the standard five-point stencil [@problem_id:2393578]. By comparing the solver's accuracy for features aligned with the grid versus those at a diagonal, you will gain crucial insights into a key weakness of this fundamental discretization.", "problem": "Consider the two-dimensional Poisson equation on the unit square domain, with strong but smooth features whose principal direction is either aligned with the grid axes or diagonally. The mathematical model is the boundary value problem for the scalar field $u(x,y)$ on $[0,1]\\times[0,1]$,\n$$- \\nabla^2 u(x,y) = f(x,y), \\quad (x,y)\\in (0,1)\\times(0,1),$$\nwith Dirichlet boundary condition $u(x,y) = u_{\\text{exact}}(x,y)$ on the boundary $\\partial([0,1]\\times[0,1])$. The Laplacian operator $\\nabla^2$ is defined by $\\nabla^2 u = \\partial^2 u / \\partial x^2 + \\partial^2 u / \\partial y^2$. You must use the standard five-point central-difference finite difference method on a uniform grid to approximate the operator $\\nabla^2$ and solve the resulting linear system for $u(x,y)$ at interior grid points.\n\nUse the method of manufactured solutions to define two exact solutions $u_{\\text{exact}}(x,y)$ whose sharpness is controlled by a width parameter $\\sigma > 0$, and whose directions are:\n- A diagonal ridge aligned with the line $x=y$: \n  $$u_{\\mathrm{diag}}(x,y;\\sigma) = \\exp\\!\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right).$$\n- An axis-aligned ridge along the $x$-axis direction centered at $x=0.5$:\n  $$u_{\\mathrm{axis}}(x,y;\\sigma) = \\exp\\!\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right).$$\n\nFor each manufactured solution, compute its continuous right-hand side $f(x,y)$ by applying the continuous Laplacian $\\nabla^2$ to $u_{\\text{exact}}$ and setting $f(x,y) = -\\nabla^2 u_{\\text{exact}}(x,y)$. For the diagonal ridge, note that $u_{\\mathrm{diag}}(x,y;\\sigma)$ depends on $s=x-y$ only; for a function $g(s)$, use the identities $\\partial^2 g/\\partial x^2 = g''(s)$ and $\\partial^2 g/\\partial y^2 = g''(s)$, which together imply $\\nabla^2 g(s) = 2 g''(s)$. For the axis-aligned ridge, note that $u_{\\mathrm{axis}}(x,y;\\sigma)$ depends only on $x$, so $\\nabla^2 u_{\\mathrm{axis}} = \\partial^2 u_{\\mathrm{axis}}/\\partial x^2$. These operations are all continuous derivatives; do not use discrete approximations to form $f(x,y)$.\n\nDiscretize the domain with a uniform Cartesian grid of $N\\times N$ points with spacing $h = 1/(N-1)$, where $N$ is an odd integer so that the line $y=0.5$ is a grid row. Assemble the standard five-point stencil for the Laplacian on interior points $(i,j)$, enforcing the Dirichlet boundary condition by setting the boundary to the exact manufactured solution. Form and solve the linear system for the interior unknowns using the standard five-point stencil only; do not use any higher-order or nine-point stencils.\n\nAfter computing the numerical solution for both the diagonal and axis-aligned manufactured solutions on the same grid and with the same $\\sigma$, reconstruct the full grid by inserting the exact boundary values. Then, evaluate the following two line-wise maximum absolute errors:\n- The diagonal-line error $E_{\\mathrm{diag}}$: the maximum absolute difference between the numerical and exact solutions along the discrete diagonal grid line $x=y$ (i.e., nodes with indices $i=j$), normalized by the exact maximum amplitude along that line. For $u_{\\mathrm{diag}}$, the exact value along $x=y$ is $1$ for all points on that line.\n- The axis-line error $E_{\\mathrm{axis}}$: the maximum absolute difference between the numerical and exact solutions along the horizontal line $y=0.5$ (i.e., nodes with index $j=(N-1)/2$), normalized by the exact maximum amplitude along that line. For $u_{\\mathrm{axis}}$, the exact peak value along $y=0.5$ occurs at $x=0.5$ and equals $1$.\n\nDefine the failure ratio\n$$R(N,\\sigma) = \\frac{E_{\\mathrm{diag}}}{E_{\\mathrm{axis}}}.$$\nValues $R(N,\\sigma) > 1$ indicate that the five-point stencil exhibits a larger error for the diagonally aligned sharp feature than for the axis-aligned feature, which demonstrates the grid-aligned anisotropy and failure to resolve diagonal sharpness at comparable resolution.\n\nYour program must:\n- Implement the five-point central-difference method to solve the Poisson problem for both $u_{\\mathrm{diag}}$ and $u_{\\mathrm{axis}}$, using the same grid and $\\sigma$.\n- Compute $E_{\\mathrm{diag}}$, $E_{\\mathrm{axis}}$, and $R(N,\\sigma)$ for each test case.\n- Output all ratios as a single list on one line as specified below.\n\nNo physical units are involved. Angles are not used. Express all floating-point outputs in plain decimal notation.\n\nTest suite to evaluate coverage:\n- Case $1$ (under-resolved diagonal feature): $N=33$, $\\sigma=0.02$.\n- Case $2$ (improved resolution): $N=65$, $\\sigma=0.02$.\n- Case $3$ (wider feature on coarse grid): $N=33$, $\\sigma=0.04$.\n\nFinal output format:\n- Your program should produce a single line of output containing the three ratios $R(N,\\sigma)$ corresponding to the cases above, as a comma-separated list enclosed in square brackets and with each value rounded to $6$ decimal places (for example, $[r_1,r_2,r_3]$).", "solution": "The problem presented is a valid and well-posed numerical analysis exercise. It concerns the solution of the two-dimensional Poisson equation using the five-point finite difference method and uses the method of manufactured solutions to analyze the anisotropic error characteristics of the stencil. All required information is provided, the physical and mathematical basis is sound, and the objectives are clear and verifiable.\n\nThe problem is to solve the Poisson equation on a unit square domain $\\Omega = [0,1]\\times[0,1]$:\n$$ - \\nabla^2 u(x,y) = f(x,y), \\quad (x,y) \\in (0,1)\\times(0,1) $$\nwith Dirichlet boundary conditions $u(x,y) = u_{\\text{exact}}(x,y)$ for $(x,y) \\in \\partial\\Omega$. The operator $\\nabla^2$ is the Laplacian, $\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$.\n\nThe method of manufactured solutions is employed. We define two exact solutions, $u_{\\mathrm{diag}}$ and $u_{\\mathrm{axis}}$, and derive the corresponding forcing functions $f(x,y)$ by applying the continuous operator: $f = -\\nabla^2 u_{\\text{exact}}$.\n\nFor the diagonal ridge, $u_{\\mathrm{diag}}(x,y;\\sigma) = \\exp(-\\frac{(x-y)^2}{2\\sigma^2})$. Let $g(s) = \\exp(-s^2/(2\\sigma^2))$ with $s=x-y$. The derivatives are $g'(s) = -\\frac{s}{\\sigma^2}g(s)$ and $g''(s) = (\\frac{s^2}{\\sigma^4} - \\frac{1}{\\sigma^2})g(s)$. Using the identity $\\nabla^2 g(x-y) = 2g''(x-y)$, the forcing function is:\n$$ f_{\\mathrm{diag}}(x,y;\\sigma) = -2 g''(x-y) = -2 \\left(\\frac{(x-y)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right) \\exp\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right) = 2\\left(\\frac{1}{\\sigma^2} - \\frac{(x-y)^2}{\\sigma^4}\\right) \\exp\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right) $$\n\nFor the axis-aligned ridge, $u_{\\mathrm{axis}}(x,y;\\sigma) = \\exp(-\\frac{(x-0.5)^2}{2\\sigma^2})$. This function only depends on $x$. Let $h(x) = \\exp(-(x-0.5)^2/(2\\sigma^2))$. The Laplacian is $\\nabla^2 h(x) = \\frac{d^2h}{dx^2}$. The second derivative is $\\frac{d^2h}{dx^2} = (\\frac{(x-0.5)^2}{\\sigma^4} - \\frac{1}{\\sigma^2})h(x)$. The forcing function is:\n$$ f_{\\mathrm{axis}}(x,y;\\sigma) = -\\frac{d^2u_{\\mathrm{axis}}}{dx^2} = -\\left(\\frac{(x-0.5)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right) \\exp\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right) = \\left(\\frac{1}{\\sigma^2} - \\frac{(x-0.5)^2}{\\sigma^4}\\right) \\exp\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right) $$\n\nThe domain is discretized using a uniform Cartesian grid with $N \\times N$ points, where $N$ is an odd integer. The grid spacing is $h = 1/(N-1)$. Let the grid points be $(x_i, y_j) = (ih, jh)$ for $i,j \\in \\{0, 1, \\dots, N-1\\}$. Let $U_{i,j}$ be the numerical approximation of $u(x_i, y_j)$.\n\nThe standard $5$-point central difference approximation for the negative Laplacian at an interior grid point $(x_i, y_j)$ for $i,j \\in \\{1, \\dots, N-2\\}$ is:\n$$ -\\nabla^2 u(x_i, y_j) \\approx \\frac{-U_{i+1,j} - U_{i-1,j} - U_{i,j+1} - U_{i,j-1} + 4U_{i,j}}{h^2} $$\nSetting this equal to the forcing term $f(x_i, y_j) = f_{i,j}$ gives the discrete equation:\n$$ 4U_{i,j} - U_{i+1,j} - U_{i-1,j} - U_{i,j+1} - U_{i,j-1} = h^2 f_{i,j} $$\nThis system of linear equations must be solved for the $(N-2) \\times (N-2)$ unknown interior values $U_{i,j}$. The values on the boundary (where $i=0$, $i=N-1$, $j=0$, or $j=N-1$) are known from the Dirichlet condition, $U_{i,j} = u_{\\text{exact}}(x_i, y_j)$. These known boundary values are moved to the right-hand side of the equations for interior points adjacent to the boundary.\n\nThis leads to a linear system of the form $A\\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u}$ is a vector of the $(N-2)^2$ unknown interior grid values, $A$ is a sparse, symmetric positive-definite, block-tridiagonal matrix of size $(N-2)^2 \\times (N-2)^2$, and $\\mathbf{b}$ is the right-hand side vector incorporating both the forcing term $f$ and the boundary conditions. The matrix $A$ has $4$ on its main diagonal, and entries of $-1$ corresponding to the four neighbors in the $5$-point stencil. This sparse system is solved numerically.\n\nAfter solving for the interior values, the full numerical solution grid is reconstructed by embedding the interior solution within the known exact boundary values.\n\nThe errors are then evaluated along specific lines. The diagonal-line error $E_{\\mathrm{diag}}$ is computed for the $u_{\\mathrm{diag}}$ case:\n$$ E_{\\mathrm{diag}} = \\frac{\\max_{i \\in \\{0, \\dots, N-1\\}} |U_{i,i} - u_{\\mathrm{diag}}(x_i, x_i)|}{\\max_{i} u_{\\mathrm{diag}}(x_i, x_i)} = \\max_{i} |U_{i,i} - 1| $$\nThe axis-line error $E_{\\mathrm{axis}}$ is computed for the $u_{\\mathrm{axis}}$ case along the line $y=0.5$, which corresponds to grid index $j_{\\text{mid}} = (N-1)/2$:\n$$ E_{\\mathrm{axis}} = \\frac{\\max_{i \\in \\{0, \\dots, N-1\\}} |U_{i,j_{\\text{mid}}} - u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})|}{\\max_{i} u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})} = \\max_{i} |U_{i,j_{\\text{mid}}} - u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})| $$\nIn both cases, the normalizing maximum amplitude of the exact solution along the respective line is $1$.\n\nFinally, the failure ratio $R(N,\\sigma) = E_{\\mathrm{diag}} / E_{\\mathrm{axis}}$ is computed to quantify the stencil's anisotropic error. The provided program implements this entire procedure for each of the specified test cases.", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef u_diag_func(X, Y, sigma):\n    \"\"\"Computes the exact solution for the diagonal ridge case.\"\"\"\n    s_sq = (X - Y)**2\n    sigma_sq = sigma**2\n    return np.exp(-s_sq / (2 * sigma_sq))\n\ndef f_diag_func(X, Y, sigma):\n    \"\"\"Computes the forcing term for the diagonal ridge case.\"\"\"\n    s_sq = (X - Y)**2\n    sigma_sq = sigma**2\n    sigma_4 = sigma**4\n    exp_term = np.exp(-s_sq / (2 * sigma_sq))\n    return 2 * (1 / sigma_sq - s_sq / sigma_4) * exp_term\n\ndef u_axis_func(X, Y, sigma):\n    \"\"\"Computes the exact solution for the axis-aligned ridge case.\"\"\"\n    z_sq = (X - 0.5)**2\n    sigma_sq = sigma**2\n    return np.exp(-z_sq / (2 * sigma_sq))\n\ndef f_axis_func(X, Y, sigma):\n    \"\"\"Computes the forcing term for the axis-aligned ridge case.\"\"\"\n    z_sq = (X - 0.5)**2\n    sigma_sq = sigma**2\n    sigma_4 = sigma**4\n    exp_term = np.exp(-z_sq / (2 * sigma_sq))\n    return (1 / sigma_sq - z_sq / sigma_4) * exp_term\n\ndef solve_poisson(N, sigma, u_exact_func, f_func):\n    \"\"\"\n    Solves the 2D Poisson equation using a 5-point finite difference stencil.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    x = np.linspace(0.0, 1.0, N)\n    y = np.linspace(0.0, 1.0, N)\n    X, Y = np.meshgrid(x, y, indexing='xy')\n\n    # Evaluate exact solution and forcing term on the full grid\n    u_exact = u_exact_func(X, Y, sigma)\n    f = f_func(X, Y, sigma)\n    \n    # Number of interior points in one dimension\n    M = N - 2\n    \n    # Construct the sparse matrix A for the linear system\n    main_diag = np.ones(M) * 4\n    off_diag = np.ones(M - 1) * -1\n    T = sparse.diags([off_diag, main_diag, off_diag], [-1, 0, 1], shape=(M, M), format='csr')\n    I_M = sparse.eye(M, format='csr')\n    A = sparse.kron(I_M, T) + sparse.diags([np.ones(M*(M-1))*-1, np.ones(M*(M-1))*-1], [-M, M], format='csr')\n    A = A.tocsc()\n\n    # Construct the right-hand side vector b\n    b_2d = h**2 * f[1:-1, 1:-1]\n    \n    # Add boundary condition contributions to b\n    # Note: U[j, i] corresponds to u at (x_i, y_j)\n    b_2d[:, 0] += u_exact[1:-1, 0]   # Left boundary (x=0)\n    b_2d[:, -1] += u_exact[1:-1, -1] # Right boundary (x=1)\n    b_2d[0, :] += u_exact[0, 1:-1]   # Bottom boundary (y=0)\n    b_2d[-1, :] += u_exact[-1, 1:-1] # Top boundary (y=1)\n    \n    b = b_2d.flatten(order='F') # Flatten column-major, for (i,j) -> k=(i-1)*M+(j-1)\n\n    # Solve the linear system\n    u_vec = spsolve(A, b)\n    \n    # Reshape solution vector to grid and insert into full solution grid\n    U_interior = u_vec.reshape((M, M), order='F')\n    U_numerical = np.copy(u_exact)\n    U_numerical[1:-1, 1:-1] = U_interior\n    \n    return U_numerical, u_exact\n\ndef solve():\n    test_cases = [\n        (33, 0.02),\n        (65, 0.02),\n        (33, 0.04),\n    ]\n\n    results = []\n    for N, sigma in test_cases:\n        # Diagonal case\n        U_diag_numerical, u_exact_diag_grid = solve_poisson(N, sigma, u_diag_func, f_diag_func)\n        diag_numerical = np.diag(U_diag_numerical)\n        diag_exact = np.diag(u_exact_diag_grid)\n        E_diag = np.max(np.abs(diag_numerical - diag_exact))\n\n        # Axis-aligned case\n        U_axis_numerical, u_exact_axis_grid = solve_poisson(N, sigma, u_axis_func, f_axis_func)\n        j_mid = (N - 1) // 2\n        axis_numerical_row = U_axis_numerical[j_mid, :]\n        axis_exact_row = u_exact_axis_grid[j_mid, :]\n        E_axis = np.max(np.abs(axis_numerical_row - axis_exact_row))\n        \n        # Failure ratio\n        R = E_diag / E_axis\n        results.append(R)\n\n    # Format results for printing\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2393578"}, {"introduction": "While direct solvers are effective for smaller systems, large-scale scientific simulations demand scalable iterative methods. This exercise introduces the Gauss-Seidel method with a red-black ordering, a powerful technique for solving the linear system derived from the five-point stencil [@problem_id:2438656]. Implementing this algorithm reveals how a specific update ordering, based on a \"coloring\" of the grid graph, exposes massive parallelism and paves the way for high-performance computing.", "problem": "Consider the two-dimensional Poisson problem posed on the unit square with homogeneous Dirichlet boundary conditions. Let the domain be $\\Omega=[0,1]\\times[0,1]$ and let the governing equation be $-\\Delta u(x,y) = f(x,y)$ on $\\Omega$ with $u(x,y)=0$ on $\\partial \\Omega$. Discretize $\\Omega$ using a uniform Cartesian grid with $N_x$ interior points along the $x$-direction and $N_y$ interior points along the $y$-direction. Let the grid spacings be $h_x = \\frac{1}{N_x+1}$ and $h_y = \\frac{1}{N_y+1}$. Denote interior indices by $i\\in\\{1,\\dots,N_x\\}$ and $j\\in\\{1,\\dots,N_y\\}$, corresponding to coordinates $x_i = i\\,h_x$ and $y_j = j\\,h_y$.\n\nUse the standard five-point stencil to form the discrete equations at each interior node $(i,j)$:\n$$(\\tfrac{2}{h_x^2}+\\tfrac{2}{h_y^2})\\,u_{i,j} - \\tfrac{1}{h_x^2}\\,(u_{i-1,j}+u_{i+1,j}) - \\tfrac{1}{h_y^2}\\,(u_{i,j-1}+u_{i,j+1}) = f_{i,j},$$\nwhere values that reference nodes on $\\partial\\Omega$ are taken as $0$ due to the homogeneous Dirichlet boundary condition. Consider the bipartite coloring of the interior grid defined by the parity of $i+j$: one color for nodes where $(i+j)$ is even and the other color for nodes where $(i+j)$ is odd.\n\nDefine a two-color sweep as follows. Starting from an initial array $u_{i,j}=0$ for all interior nodes, perform one synchronous update of all nodes of the first color using the most recent available neighbor values, followed by one synchronous update of all nodes of the second color using the most recent available neighbor values. On each update at node $(i,j)$, assign the new value by solving the local discrete equation for $u_{i,j}$:\n$$\nu_{i,j} \\leftarrow \\frac{ f_{i,j} + \\tfrac{1}{h_x^2}\\,(u_{i-1,j}+u_{i+1,j}) + \\tfrac{1}{h_y^2}\\,(u_{i,j-1}+u_{i,j+1}) }{ \\tfrac{2}{h_x^2}+\\tfrac{2}{h_y^2} }.\n$$\n\nFor a given number of two-color sweeps $K$, compute the approximate solution and quantify its accuracy using the interior root-mean-square error relative to a specified exact function $u^\\star(x,y)$:\n$$\n\\varepsilon = \\sqrt{\\frac{1}{N_x N_y} \\sum_{j=1}^{N_y}\\sum_{i=1}^{N_x} \\left(u_{i,j} - u^\\star(x_i,y_j)\\right)^2 }.\n$$\n\nFor the right-hand side $f(x,y)$ and the reference function $u^\\star(x,y)$, use either of the following test definitions, as specified per test case:\n- Sine test: $u^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ and $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$.\n- Zero test: $u^\\star(x,y) = 0$ and $f(x,y) = 0$.\n\nImplement a program that, for each test case, performs exactly $K$ two-color sweeps from the zero initial guess and returns the value of $\\varepsilon$ as a floating-point number.\n\nTest suite:\n- Test $1$: $(N_x,N_y,K,\\text{type}) = (32,32,30,\\text{sine})$.\n- Test $2$: $(N_x,N_y,K,\\text{type}) = (1,1,10,\\text{sine})$.\n- Test $3$: $(N_x,N_y,K,\\text{type}) = (31,17,40,\\text{sine})$.\n- Test $4$: $(N_x,N_y,K,\\text{type}) = (16,16,0,\\text{zero})$.\n\nYour program must compute and output the four errors $\\varepsilon$ corresponding to the tests above. The final output format must be a single line containing the results as a comma-separated list enclosed in square brackets, in the order of Tests $1$ through $4$, for example, $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4]$. No physical units are involved and no angles are used. The only acceptable outputs are floating-point numbers collected into the specified list format on a single line.", "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It is scientifically grounded, well-posed, objective, and complete. The problem describes the numerical solution of the two-dimensional Poisson equation, a standard and fundamental problem in computational engineering. The provided test cases, including the analytical solution $u^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ for which $-\\Delta u^\\star = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$, are correct and self-consistent. We may therefore proceed with the solution.\n\nThe task is to compute an approximate solution to the Poisson problem $-\\Delta u(x,y) = f(x,y)$ on the unit square $\\Omega = [0,1] \\times [0,1]$ with homogeneous Dirichlet boundary conditions $u(x,y)=0$ on the boundary $\\partial\\Omega$. The solution method is an iterative scheme based on a finite difference discretization.\n\n**1. Discretization**\n\nThe domain is discretized using a uniform Cartesian grid with $N_x$ and $N_y$ interior points in the $x$ and $y$ directions, respectively. The grid spacings are $h_x = \\frac{1}{N_x+1}$ and $h_y = \\frac{1}{N_y+1}$. An interior grid node $(i,j)$, for $i \\in \\{1, \\dots, N_x\\}$ and $j \\in \\{1, \\dots, N_y\\}$, corresponds to the spatial coordinate $(x_i, y_j) = (i h_x, j h_y)$.\n\nThe Laplace operator $\\Delta u$ is approximated using a standard five-point centered difference stencil. This transforms the partial differential equation into a system of linear algebraic equations for the unknown values $u_{i,j} \\approx u(x_i, y_j)$ at the interior nodes. The discrete equation at node $(i,j)$ is given as:\n$$\n(\\tfrac{2}{h_x^2}+\\tfrac{2}{h_y^2})\\,u_{i,j} - \\tfrac{1}{h_x^2}\\,(u_{i-1,j}+u_{i+1,j}) - \\tfrac{1}{h_y^2}\\,(u_{i,j-1}+u_{i,j+1}) = f_{i,j},\n$$\nwhere $f_{i,j} = f(x_i, y_j)$. For nodes adjacent to the boundary, the corresponding neighbor values (e.g., $u_{0,j}$) are set to $0$ as per the Dirichlet condition. To implement this conveniently, we use a computational grid of size $(N_y+2) \\times (N_x+2)$, where the outer layer of cells represents the boundary and is held at a constant value of $0$. The solution $u_{i,j}$ is stored in the interior of this padded array.\n\n**2. Iterative Solution: Gauss-Seidel with Two-Color (Red-Black) Ordering**\n\nThe system of linear equations is solved iteratively. The problem specifies a \"two-color sweep,\" which is a particular ordering for the Gauss-Seidel method. The grid nodes are partitioned into two sets, or \"colors,\" based on the parity of the sum of their indices, $i+j$. Let us designate nodes with $i+j$ even as \"red\" and nodes with $i+j$ odd as \"black\".\n\nThe fundamental property of this coloring with a five-point stencil is that all neighbors of a red node are black, and all neighbors of a black node are red. A two-color sweep consists of two stages:\n1.  Update all red nodes using the current values of their black neighbors. Since the updates for red nodes are independent of each other, they can be performed simultaneously (a synchronous update for the red set).\n2.  Update all black nodes using the most recent values available. This means using the newly computed values for their red neighbors from stage $1$ and the old values for any other neighbors (though with this coloring, all neighbors are red). This update can also be performed synchronously for the black set.\n\nThe update for $u_{i,j}$ is derived by isolating it from the discrete equation:\n$$\nu_{i,j} \\leftarrow \\frac{ f_{i,j} + \\tfrac{1}{h_x^2}\\,(u_{i-1,j}+u_{i+1,j}) + \\tfrac{1}{h_y^2}\\,(u_{i,j-1}+u_{i,j+1}) }{ \\tfrac{2}{h_x^2}+\\tfrac{2}{h_y^2} }\n$$\nThis process is repeated for a specified number of sweeps, $K$, starting from an initial guess of $u_{i,j}=0$ for all interior nodes.\n\n**3. Algorithmic Implementation**\n\nThe algorithm is implemented in Python using the `numpy` library for efficient array operations.\n- For each test case defined by $(N_x, N_y, K, \\text{type})$, we first set up the grid parameters $h_x, h_y$ and a padded solution array `U` of size $(N_y+2) \\times (N_x+2)$, initialized to all zeros.\n- We generate coordinate grids `X` and `Y` for the interior nodes to evaluate the source term $f(x,y)$ and the exact solution $u^\\star(x,y)$, storing them in arrays `F` and `U_star`, respectively.\n- Boolean masks, `red_mask` and `black_mask`, are created to identify the interior nodes belonging to each color based on the parity of $(i+j)$.\n- The iterative solver loops $K$ times. In each loop, we perform the two-stage update. This is vectorized for efficiency. First, the sum of neighbor values is computed for all interior points. Then, using the `red_mask`, the solution values at red nodes are updated. Following this, the neighbor sum is re-computed (now using the updated values at red nodes) and used to update the solution at black nodes via the `black_mask`.\n- Constants $\\frac{1}{h_x^2}$, $\\frac{1}{h_y^2}$ and the denominator term are pre-calculated for efficiency.\n\n**4. Error Quantification**\n\nAfter $K$ sweeps, the resulting approximate solution, which is the interior part of the array `U`, is compared against the exact solution evaluated on the grid, `U_star`. The accuracy is measured by the interior root-mean-square error, $\\varepsilon$:\n$$\n\\varepsilon = \\sqrt{\\frac{1}{N_x N_y} \\sum_{j=1}^{N_y}\\sum_{i=1}^{N_x} \\left(u_{i,j} - u^\\star(x_i,y_j)\\right)^2 }\n$$\nThis is computed using standard `numpy` functions. For the case $K=0$, the loop is skipped, and the error is calculated for the initial guess, $u_{i,j}=0$. For Test 4, where $u^\\star=0$ and the initial guess is $u=0$, the error $\\varepsilon$ is trivially $0$.\n\nThis methodology is applied to each of the four test cases to compute the corresponding error values.", "answer": "```python\nimport numpy as np\n\ndef run_solver(Nx, Ny, K, test_type):\n    \"\"\"\n    Solves the 2D Poisson problem on a unit square using a two-color\n    Gauss-Seidel iterative method.\n\n    Args:\n        Nx (int): Number of interior grid points in the x-direction.\n        Ny (int): Number of interior grid points in the y-direction.\n        K (int): Number of two-color sweeps to perform.\n        test_type (str): The test definition ('sine' or 'zero').\n\n    Returns:\n        float: The root-mean-square error of the approximate solution.\n    \"\"\"\n    # 1. Grid and padded solution array setup\n    hx = 1.0 / (Nx + 1)\n    hy = 1.0 / (Ny + 1)\n    \n    # Padded solution array U, initialized to 0. Boundaries remain 0.\n    U = np.zeros((Ny + 2, Nx + 2), dtype=np.float64)\n\n    # 2. Function and coordinate setup for interior points\n    x_coords = np.arange(1, Nx + 1) * hx\n    y_coords = np.arange(1, Ny + 1) * hy\n    X, Y = np.meshgrid(x_coords, y_coords)\n\n    PI = np.pi\n    if test_type == 'sine':\n        F = 2 * PI**2 * np.sin(PI * X) * np.sin(PI * Y)\n        U_star = np.sin(PI * X) * np.sin(PI * Y)\n    elif test_type == 'zero':\n        F = np.zeros((Ny, Nx), dtype=np.float64)\n        U_star = np.zeros((Ny, Nx), dtype=np.float64)\n    else:\n        raise ValueError(\"Invalid test_type specified.\")\n\n    # 3. Iterative solver logic\n    if K > 0:\n        # Create color masks for red-black ordering\n        # Indices i, j are 1-based in the problem statement\n        I, J = np.meshgrid(np.arange(1, Nx + 1), np.arange(1, Ny + 1))\n        # 'First color' (red) for nodes where (i+j) is even\n        red_mask = ((I + J) % 2) == 0\n        # 'Second color' (black) for nodes where (i+j) is odd\n        black_mask = ((I + J) % 2) != 0\n\n        # Pre-calculate stencil coefficients\n        cx = 1.0 / hx**2\n        cy = 1.0 / hy**2\n        c_diag = 1.0 / (2.0 * cx + 2.0 * cy)\n\n        # Get a view of the interior part of U for easier indexing\n        interior_U = U[1:-1, 1:-1]\n\n        for _ in range(K):\n            # Stage 1: Synchronous update of all 'red' nodes\n            # The update for red nodes depends only on black neighbors from previous state\n            neighbors_sum = cx * (U[1:-1, :-2] + U[1:-1, 2:]) + \\\n                            cy * (U[:-2, 1:-1] + U[2:, 1:-1])\n            interior_U[red_mask] = c_diag * (F[red_mask] + neighbors_sum[red_mask])\n            \n            # Stage 2: Synchronous update of all 'black' nodes\n            # The update for black nodes uses the newly updated red neighbors\n            neighbors_sum = cx * (U[1:-1, :-2] + U[1:-1, 2:]) + \\\n                            cy * (U[:-2, 1:-1] + U[2:, 1:-1])\n            interior_U[black_mask] = c_diag * (F[black_mask] + neighbors_sum[black_mask])\n\n    # 4. Error calculation\n    u_approx = U[1:-1, 1:-1]\n    diff_sq = (u_approx - U_star)**2\n    rmse = np.sqrt(np.mean(diff_sq))\n    \n    return rmse\n\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test suite and print results.\n    \"\"\"\n    test_cases = [\n        (32, 32, 30, 'sine'),\n        (1, 1, 10, 'sine'),\n        (31, 17, 40, 'sine'),\n        (16, 16, 0, 'zero'),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, K, test_type = case\n        result = run_solver(Nx, Ny, K, test_type)\n        results.append(result)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2438656"}]}