{"hands_on_practices": [{"introduction": "The differential form of a conservation law is a powerful tool, but its counterpart, the integral statement, is in many ways more fundamental. This is especially true when dealing with singularities like point sources or sinks, where fields and their derivatives may be undefined. This exercise demonstrates the power of the integral form, using the divergence theorem to elegantly solve for the field around a point source, a scenario where the differential form requires the more advanced theory of distributions. [@problem_id:2404130]", "problem": "A scalar concentration field $c(\\vec{x})$ diffuses in an unbounded, quiescent three-dimensional medium with constant diffusivity $D$. A steady point source of strength $S_{0}$ is located at position $\\vec{x}_{0}$, modeled by the Dirac delta function as $S(\\vec{x}) = S_{0}\\,\\delta(\\vec{x}-\\vec{x}_{0})$. The steady conservation of mass for $c(\\vec{x})$ is expressed in integral form for any bounded control volume $V$ with outward unit normal $\\vec{n}$ on its boundary $\\partial V$ as\n$$\n\\int_{\\partial V} \\left(-D\\,\\nabla c\\right)\\cdot \\vec{n}\\, \\mathrm{d}A \\;=\\; \\int_{V} S(\\vec{x})\\, \\mathrm{d}V,\n$$\nand in differential form (in the sense of distributions) as\n$$\n- D\\,\\nabla^{2} c \\;=\\; S(\\vec{x}).\n$$\nAway from the source location $\\vec{x}_{0}$, the field satisfies $\\nabla^{2} c = 0$ and decays to zero at spatial infinity. It is known that the unique spherically symmetric solution about $\\vec{x}_{0}$ that decays at infinity has the form $c(\\vec{x}) = A/r$ for $r = \\|\\vec{x}-\\vec{x}_{0}\\| > 0$, where $A$ is a constant.\n\nDetermine the constant $A$ in terms of $S_{0}$ and $D$ such that the solution is consistent with both the integral and differential statements of conservation. Express your final answer as a closed-form analytic expression. No numerical approximation is required.", "solution": "The problem statement is assessed and found to be valid. It is a well-posed problem in mathematical physics, specifically concerning the fundamental solution (or Green's function) for the Laplacian operator in three dimensions, which is a cornerstone of potential theory and transport phenomena. The problem is scientifically grounded, self-contained, and uses precise mathematical language. We proceed with the solution.\n\nThe objective is to determine the constant $A$ in the proposed solution $c(\\vec{x}) = A/r$, where $r = \\|\\vec{x}-\\vec{x}_{0}\\|$, such that it satisfies the steady conservation of mass for a scalar concentration $c(\\vec{x})$ in the presence of a point source $S(\\vec{x}) = S_{0}\\,\\delta(\\vec{x}-\\vec{x}_{0})$. We will use the integral form of the conservation law, as it naturally handles the singularity of the point source.\n\nThe integral conservation law is given for an arbitrary control volume $V$ as:\n$$\n\\int_{\\partial V} \\left(-D\\,\\nabla c\\right)\\cdot \\vec{n}\\, \\mathrm{d}A \\;=\\; \\int_{V} S(\\vec{x})\\, \\mathrm{d}V\n$$\nLet us choose a convenient control volume. Due to the spherical symmetry of the solution form about the source at $\\vec{x}_{0}$, we select $V$ to be a sphere of an arbitrary radius $R > 0$ centered at $\\vec{x}_{0}$. The boundary of this sphere is $\\partial V$.\n\nFirst, we evaluate the right-hand side (RHS) of the equation, which represents the total source strength within the volume $V$.\n$$\n\\text{RHS} = \\int_{V} S(\\vec{x})\\, \\mathrm{d}V = \\int_{V} S_{0}\\,\\delta(\\vec{x}-\\vec{x}_{0})\\, \\mathrm{d}V\n$$\nBy the sifting property of the Dirac delta function, this integral evaluates to $S_{0}$ because the point $\\vec{x}_{0}$ is contained within any sphere $V$ of radius $R>0$ centered at $\\vec{x}_{0}$.\n$$\n\\text{RHS} = S_{0}\n$$\n\nNext, we evaluate the left-hand side (LHS) of the equation, which represents the total flux of the scalar quantity out of the control volume.\n$$\n\\text{LHS} = \\int_{\\partial V} \\left(-D\\,\\nabla c\\right)\\cdot \\vec{n}\\, \\mathrm{d}A\n$$\nThe quantity $\\vec{J} = -D\\,\\nabla c$ is the diffusive flux vector. We must first compute the gradient of the concentration field $c(\\vec{x}) = A/r$. It is most convenient to work in a spherical coordinate system centered at $\\vec{x}_{0}$, where $r$ is the radial coordinate. The gradient of a spherically symmetric function $f(r)$ is given by $\\nabla f(r) = \\frac{\\mathrm{d}f}{\\mathrm{d}r}\\hat{e}_{r}$, where $\\hat{e}_{r}$ is the unit vector in the radial direction.\nFor $c(r) = A/r = Ar^{-1}$, the derivative with respect to $r$ is:\n$$\n\\frac{\\mathrm{d}c}{\\mathrm{d}r} = -A r^{-2} = -\\frac{A}{r^{2}}\n$$\nThus, the gradient of the concentration field is:\n$$\n\\nabla c = -\\frac{A}{r^{2}}\\hat{e}_{r}\n$$\nThe diffusive flux vector is then:\n$$\n\\vec{J} = -D\\,\\nabla c = -D \\left(-\\frac{A}{r^{2}}\\hat{e}_{r}\\right) = \\frac{DA}{r^{2}}\\hat{e}_{r}\n$$\nOn the boundary of our control volume $\\partial V$, which is a sphere of radius $r=R$, the outward unit normal vector $\\vec{n}$ is identical to the radial unit vector $\\hat{e}_{r}$. Therefore, the dot product in the integrand becomes:\n$$\n\\vec{J} \\cdot \\vec{n} = \\left(\\frac{DA}{r^{2}}\\hat{e}_{r}\\right) \\cdot \\hat{e}_{r} = \\frac{DA}{r^{2}}\n$$\nOn the surface $\\partial V$, we have $r=R$, so the integrand is constant over the entire surface:\n$$\n\\left.\\left(\\vec{J} \\cdot \\vec{n}\\right)\\right|_{r=R} = \\frac{DA}{R^{2}}\n$$\nNow, we can compute the surface integral for the LHS:\n$$\n\\text{LHS} = \\int_{\\partial V} \\frac{DA}{R^{2}} \\, \\mathrm{d}A = \\frac{DA}{R^{2}} \\int_{\\partial V} \\mathrm{d}A\n$$\nThe integral $\\int_{\\partial V} \\mathrm{d}A$ is the surface area of the sphere of radius $R$, which is $4\\pi R^{2}$.\n$$\n\\text{LHS} = \\frac{DA}{R^{2}} (4\\pi R^{2}) = 4\\pi DA\n$$\nThe result for the LHS is independent of the radius $R$ of the control volume, which is a necessary condition for consistency.\n\nFinally, we equate the LHS and RHS:\n$$\n4\\pi DA = S_{0}\n$$\nSolving for the constant $A$, we find:\n$$\nA = \\frac{S_{0}}{4\\pi D}\n$$\nThis result is consistent with both the integral and differential forms. For completeness, we verify this with the differential form, $-D\\,\\nabla^{2}c = S(\\vec{x})$. It is a standard result from the theory of distributions that the Laplacian of the function $1/r$ in three dimensions is $\\nabla^{2}(1/r) = -4\\pi\\delta(\\vec{x}-\\vec{x}_{0})$.\nSubstituting $c = A/r$ into the differential equation gives:\n$$\n-D\\,\\nabla^{2}\\left(\\frac{A}{r}\\right) = S_{0}\\,\\delta(\\vec{x}-\\vec{x}_{0})\n$$\n$$\n-DA\\,\\nabla^{2}\\left(\\frac{1}{r}\\right) = S_{0}\\,\\delta(\\vec{x}-\\vec{x}_{0})\n$$\n$$\n-DA(-4\\pi\\,\\delta(\\vec{x}-\\vec{x}_{0})) = S_{0}\\,\\delta(\\vec{x}-\\vec{x}_{0})\n$$\n$$\n4\\pi DA\\,\\delta(\\vec{x}-\\vec{x}_{0}) = S_{0}\\,\\delta(\\vec{x}-\\vec{x}_{0})\n$$\nFor this equality to hold, the coefficients must be equal: $4\\pi DA = S_{0}$, which yields the same expression for $A$. The solution is therefore fully consistent.", "answer": "$$\n\\boxed{\\frac{S_{0}}{4\\pi D}}\n$$", "id": "2404130"}, {"introduction": "Moving from fundamental theory to common engineering applications, we often encounter systems composed of multiple materials. At the interfaces between these materials, the conservation law must still hold, creating specific boundary conditions that link the behavior on both sides. This practice explores a steady-state diffusion problem across two different media separated by a semi-permeable membrane, illustrating how to apply the principle of constant flux to determine the overall transport rate and uncovering a powerful analogy to electrical circuits where resistances are placed in series. [@problem_id:2404179]", "problem": "A solute diffuses in a long, straight channel of constant cross-sectional area. Let the axial coordinate be $x$, with the left boundary at $x=-L_1$ and the right boundary at $x=+L_2$, where $L_1>0$ and $L_2>0$. The region $-L_1 \\le x < 0$ is filled with a medium of constant diffusivity $D_1>0$, and the region $0 < x \\le L_2$ is filled with a different medium of constant diffusivity $D_2>0$. At $x=0$ there is an idealized semi-permeable membrane of negligible thickness whose normal molar flux per unit area is linearly proportional to the concentration jump across it. Specifically, if $c(0^-)$ and $c(0^+)$ denote the limiting concentrations approaching the membrane from the left and right, respectively, then the membrane flux law is\n$$\nJ = P\\big(c(0^-) - c(0^+)\\big),\n$$\nwith membrane permeability $P>0$. There are no volumetric sources or sinks of solute, and the system is at steady state. The boundary concentrations are fixed at $c(-L_1)=c_1$ and $c(L_2)=c_2$, where $c_1$ and $c_2$ are given constants.\n\nAssume one-dimensional transport, conservation of mass, and Fickâ€™s law of diffusion within each homogeneous region. Define the positive direction for flux to be from left to right. Determine a closed-form symbolic expression for the steady-state molar flux per unit area $J$ in terms of $c_1$, $c_2$, $L_1$, $L_2$, $D_1$, $D_2$, and $P$. Provide your answer as a single analytic expression for $J$ without substituting numerical values and do not include units in your final expression.", "solution": "The fundamental principle is the conservation of mass. For a one-dimensional system at steady state with no volumetric sources or sinks, the differential form of the mass conservation law is:\n$$\n\\frac{dJ}{dx} = 0\n$$\nThis equation implies that the molar flux per unit area, $J$, is constant throughout the entire domain, from $x = -L_1$ to $x = L_2$.\n\nWithin each homogeneous region, the flux is described by Fick's first law of diffusion.\nFor Region 1 ($-L_1 \\le x < 0$):\n$$\nJ = -D_1 \\frac{dc}{dx}\n$$\nFor Region 2 ($0 < x \\le L_2$):\n$$\nJ = -D_2 \\frac{dc}{dx}\n$$\nSince $J$, $D_1$, and $D_2$ are constants, the concentration gradient $\\frac{dc}{dx}$ is also constant within each region. The concentration profiles $c(x)$ are therefore linear in each region. Integrating the equations for a constant flux $J$ yields:\nFor Region 1: $c(x) = -\\frac{J}{D_1}x + A_1$\nFor Region 2: $c(x) = -\\frac{J}{D_2}x + A_2$\nwhere $A_1$ and $A_2$ are constants of integration.\n\nWe use the given boundary and interface conditions to determine the unknowns $A_1$, $A_2$, and the flux $J$.\nThe boundary conditions at the outer edges are:\n1. $c(-L_1) = c_1 \\implies c_1 = -\\frac{J}{D_1}(-L_1) + A_1 = \\frac{JL_1}{D_1} + A_1$\n2. $c(L_2) = c_2 \\implies c_2 = -\\frac{J}{D_2}(L_2) + A_2 = -\\frac{JL_2}{D_2} + A_2$\n\nFrom these two equations, we can express the integration constants in terms of the flux $J$:\nFrom (1): $A_1 = c_1 - \\frac{JL_1}{D_1}$\nFrom (2): $A_2 = c_2 + \\frac{JL_2}{D_2}$\n\nThe concentrations at the interface $x=0$ are found by taking the limits of the concentration profiles:\n$c(0^-) = \\lim_{x \\to 0^-} c(x) = A_1$\n$c(0^+) = \\lim_{x \\to 0^+} c(x) = A_2$\n\nWe now use the third condition, the membrane flux law, which relates the flux to the concentration jump across the membrane:\n3. $J = P\\big(c(0^-) - c(0^+)\\big) = P(A_1 - A_2)$\n\nSubstitute the expressions for $A_1$ and $A_2$ into this equation:\n$$\nJ = P \\left[ \\left(c_1 - \\frac{JL_1}{D_1}\\right) - \\left(c_2 + \\frac{JL_2}{D_2}\\right) \\right]\n$$\nWe now solve this algebraic equation for $J$.\n$$\nJ = P(c_1 - c_2) - P\\frac{JL_1}{D_1} - P\\frac{JL_2}{D_2}\n$$\nGroup all terms containing $J$ on the left-hand side:\n$$\nJ + \\frac{PJL_1}{D_1} + \\frac{PJL_2}{D_2} = P(c_1 - c_2)\n$$\nFactor out $J$:\n$$\nJ \\left( 1 + \\frac{PL_1}{D_1} + \\frac{PL_2}{D_2} \\right) = P(c_1 - c_2)\n$$\nIsolating $J$ yields the expression:\n$$\nJ = \\frac{P(c_1 - c_2)}{1 + \\frac{PL_1}{D_1} + \\frac{PL_2}{D_2}}\n$$\nThis expression is correct. For a more physically insightful representation, we can divide the numerator and denominator by the permeability $P$:\n$$\nJ = \\frac{c_1 - c_2}{\\frac{1}{P} + \\frac{L_1}{D_1} + \\frac{L_2}{D_2}}\n$$\nThis form shows an analogy to Ohm's law, where the flux $J$ (current) is driven by a potential difference ($c_1 - c_2$) and is inversely proportional to the total resistance. The total resistance is the sum of the resistances of the three components in series: the diffusive resistance of medium 1 ($\\frac{L_1}{D_1}$), the diffusive resistance of medium 2 ($\\frac{L_2}{D_2}$), and the resistance of the membrane ($\\frac{1}{P}$). This is the final expression.", "answer": "$$\n\\boxed{\\frac{c_1 - c_2}{\\frac{L_1}{D_1} + \\frac{L_2}{D_2} + \\frac{1}{P}}}\n$$", "id": "2404179"}, {"introduction": "While analytical solutions provide deep insight, most real-world engineering problems require computational methods. The Finite Volume Method (FVM) is a cornerstone of computational fluid dynamics and transport phenomena precisely because it is built directly upon the integral conservation law, ensuring that the conserved quantity is also conserved numerically. This capstone exercise guides you through the process of building a 2D advection solver on an unstructured triangular mesh from first principles, a core skill that bridges the gap between the governing integral equation and a working computer program. [@problem_id:2404174]", "problem": "You are to construct a complete program that implements a finite volume method for a two-dimensional scalar conservation law on an unstructured triangular mesh, starting rigorously from the integral statement of conservation. The unknown field is a scalar $u(\\mathbf{x},t)$ that satisfies the conservation law\n$$\n\\frac{\\partial u}{\\partial t} + \\nabla \\cdot \\mathbf{F}(u) = 0,\n$$\nwith a linear flux of the form $\\mathbf{F}(u) = \\mathbf{v}\\,u$, where $\\mathbf{v}\\in\\mathbb{R}^2$ is a constant velocity vector. The computational domain is partitioned into nonoverlapping triangular control volumes, and the boundary condition is periodic on the rectangular boundary as specified in the test suite. You must design a conservative, consistent, monotone first-order finite volume discretization that approximates the evolution of cell averages $u_K^n$ in each triangular cell $K$ at times $t^n$.\n\nYour program must:\n- Derive the semi-discrete finite volume update from the integral conservation law over each triangle $K$ by converting boundary integrals into sums over its edges.\n- Assemble all geometric quantities that are needed, including triangle areas, edge lengths, and outward unit normals for each edge of each triangle, from first principles using the given node coordinates and element connectivity.\n- Enforce periodic boundary conditions by pairing designated boundary edges, treating each paired boundary as if it were an interior interface with a unique neighboring cell across it.\n- Choose a time increment $\\Delta t$ that respects a Courant-Friedrichs-Lewy (CFL) number $0.45$ computed from local wave speeds and mesh geometry to ensure stability, and advance the solution by a specified number of steps for each test case.\n\nUse the following test suite. In all cases, the domain is the unit square with periodic pairing of opposite edges as given.\n\n- Mesh $\\mathcal{M}_A$ (two triangles):\n  - Nodes (indexed by $0,1,2,3$): $\\mathbf{x}_0=(0,0)$, $\\mathbf{x}_1=(1,0)$, $\\mathbf{x}_2=(1,1)$, $\\mathbf{x}_3=(0,1)$.\n  - Triangles (vertex indices in counterclockwise order): $T_0=(0,1,2)$, $T_1=(0,2,3)$.\n  - Periodic edge pairs (unordered node pairs): $\\{(0,1),(3,2)\\}$ and $\\{(0,3),(1,2)\\}$, pairing bottom-to-top and left-to-right respectively.\n\n- Mesh $\\mathcal{M}_B$ (four triangles with a center node):\n  - Nodes (indexed by $0,1,2,3,4$): $\\mathbf{x}_0=(0,0)$, $\\mathbf{x}_1=(1,0)$, $\\mathbf{x}_2=(1,1)$, $\\mathbf{x}_3=(0,1)$, $\\mathbf{x}_4=(0.5,0.5)$.\n  - Triangles (vertex indices in counterclockwise order): $T_0=(0,1,4)$, $T_1=(1,2,4)$, $T_2=(2,3,4)$, $T_3=(3,0,4)$.\n  - Periodic edge pairs (unordered node pairs): $\\{(0,1),(3,2)\\}$ and $\\{(0,3),(1,2)\\}$.\n\nDefine three test cases as follows:\n\n- Test case $\\mathbf{A}$: Mesh $\\mathcal{M}_A$, velocity $\\mathbf{v}=(1,0)$, number of steps $N_A=20$, and initial condition $u_0(\\mathbf{x}) = \\sin(2\\pi x) + 0.5\\cos(2\\pi y)$. Report as a single real number the difference in the total conserved quantity between final and initial states, computed as\n$$\n\\Delta M_A = \\sum_{K} |K|\\left(u_K^{N_A} - u_K^{0}\\right),\n$$\nwhere $|K|$ is the area of triangle $K$. This quantity must be returned in no units.\n\n- Test case $\\mathbf{B}$: Mesh $\\mathcal{M}_B$, velocity $\\mathbf{v}=(0,0)$, number of steps $N_B=5$, and initial condition $u_0(\\mathbf{x}) = x + 2y$ evaluated at cell centroids. Report as a single real number the maximum absolute cellwise difference between the final and initial states,\n$$\nE_B = \\max_{K} \\left|u_K^{N_B} - u_K^{0}\\right|.\n$$\nThis quantity must be returned in no units.\n\n- Test case $\\mathbf{C}$: Mesh $\\mathcal{M}_B$, velocity $\\mathbf{v}=(0.5,0.25)$, number of steps $N_C=40$, and a piecewise-constant initial condition assigned per triangle index: $u_{T_0}^0=0.0$, $u_{T_1}^0=1.0$, $u_{T_2}^0=0.5$, $u_{T_3}^0=2.0$. Report a single boolean indicating whether the discrete maximum principle is respected after $N_C$ steps, namely whether\n$$\n\\min_K u_K^{0} \\le u_K^{N_C} \\le \\max_K u_K^{0}\n$$\nholds for all cells $K$ up to a numerical tolerance, which you must choose to be $10^{-12}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results of the three test cases as a comma-separated list enclosed in square brackets, in the order $[\\Delta M_A,E_B,\\text{DMP}_C]$, where $\\text{DMP}_C$ is the boolean for Test case $\\mathbf{C}$. For example, the format must be exactly like $[r_1,r_2,r_3]$ with no spaces.\n\nAngles, if any arise in your implementation, are to be treated in radians. No physical units are required in the answer; all reported quantities are dimensionless. All computations must be carried out from the stated first principles without invoking any pre-derived formulas not implied by the integral conservation law and basic geometry.", "solution": "The governing partial differential equation is the scalar conservation law:\n$$\n\\frac{\\partial u}{\\partial t} + \\nabla \\cdot \\mathbf{F}(u) = 0\n$$\nwhere $u(\\mathbf{x}, t)$ is the conserved scalar quantity, and $\\mathbf{F}(u) = \\mathbf{v} u$ is the linear flux function with a constant velocity vector $\\mathbf{v} \\in \\mathbb{R}^2$.\n\nThe foundation of the finite volume method is the integral form of this conservation law, obtained by integrating over an arbitrary, fixed control volume $K$, which in our case is a triangle:\n$$\n\\int_K \\frac{\\partial u}{\\partial t} \\, d A + \\int_K \\nabla \\cdot \\mathbf{F}(u) \\, d A = 0\n$$\nThe order of integration and differentiation can be swapped for the time derivative term. We define the cell average of $u$ over the triangle $K$ as:\n$$\nu_K(t) = \\frac{1}{|K|} \\int_K u(\\mathbf{x}, t) \\, d A\n$$\nwhere $|K|$ is the area of the triangle. The first term in the integral equation becomes $|K|\\frac{d u_K}{d t}$.\nFor the second term, we apply the Divergence Theorem, which converts the area integral of the divergence into a line integral over the boundary of the control volume, $\\partial K$:\n$$\n\\int_K \\nabla \\cdot \\mathbf{F}(u) \\, d A = \\oint_{\\partial K} \\mathbf{F}(u) \\cdot \\mathbf{n} \\, dl\n$$\nwhere $\\mathbf{n}$ is the outward-pointing unit normal vector to the boundary $\\partial K$.\n\nCombining these results, we obtain the exact semi-discrete equation for the evolution of the cell average:\n$$\n|K|\\frac{d u_K}{d t} + \\oint_{\\partial K} \\mathbf{F}(u) \\cdot \\mathbf{n} \\, dl = 0\n$$\nThe boundary $\\partial K$ of a triangle consists of three edges, which we denote by $e_j$ for $j \\in \\{0, 1, 2\\}$. The line integral can be written as a sum over these edges:\n$$\n\\frac{d u_K}{d t} = - \\frac{1}{|K|} \\sum_{j=0}^{2} \\int_{e_j} \\mathbf{F}(u) \\cdot \\mathbf{n}_j \\, dl\n$$\nwhere $\\mathbf{n}_j$ is the outward unit normal associated with edge $e_j$.\n\nTo obtain a numerical scheme, we must approximate the flux integral on the right-hand side. For a first-order method, we assume that the state $u$ is piecewise constant in each cell, equal to its cell average $u_K$. The flux function $\\mathbf{F}(u) \\cdot \\mathbf{n}$ is therefore also piecewise constant. However, at the interface between two cells, $K$ and its neighbor $K_j$ across edge $e_j$, the state is discontinuous. We must define a numerical flux, which is a single-valued function that depends on the states in the two adjacent cells, $u_K$ and $u_{K_j}$. The integral is then approximated as:\n$$\n\\int_{e_j} \\mathbf{F}(u) \\cdot \\mathbf{n}_j \\, dl \\approx |e_j| \\, \\mathcal{F}_{\\text{num}}(u_K, u_{K_j}, \\mathbf{n}_j; \\mathbf{v})\n$$\nwhere $|e_j|$ is the length of edge $e_j$.\nFor the linear advection equation, $\\mathbf{F}(u) \\cdot \\mathbf{n}_j = (\\mathbf{v} \\cdot \\mathbf{n}_j) u$. A simple and robust choice for the numerical flux that ensures monotonicity is the upwind flux. The upwind flux selects the state from the cell from which the flow is coming. The direction of flow through edge $e_j$ is determined by the sign of the normal velocity, $\\mathbf{v} \\cdot \\mathbf{n}_j$.\n- If $\\mathbf{v} \\cdot \\mathbf{n}_j > 0$, the flow is from cell $K$ to cell $K_j$. The upwind state is $u_K$.\n- If $\\mathbf{v} \\cdot \\mathbf{n}_j < 0$, the flow is from cell $K_j$ to cell $K$. The upwind state is $u_{K_j}$.\n- If $\\mathbf{v} \\cdot \\mathbf{n}_j = 0$, there is no flow across the edge, and the flux is zero.\nThis can be summarized as:\n$$\n\\mathcal{F}_{\\text{num}}(u_K, u_{K_j}, \\mathbf{n}_j; \\mathbf{v}) = (\\mathbf{v} \\cdot \\mathbf{n}_j) u_{\\text{upwind}} = \\max(0, \\mathbf{v} \\cdot \\mathbf{n}_j) u_K + \\min(0, \\mathbf{v} \\cdot \\mathbf{n}_j) u_{K_j}\n$$\nThe semi-discrete finite volume scheme is then:\n$$\n\\frac{d u_K}{d t} = - \\frac{1}{|K|} \\sum_{j=0}^{2} |e_j| \\left[ \\max(0, \\mathbf{v} \\cdot \\mathbf{n}_j) u_K + \\min(0, \\mathbf{v} \\cdot \\mathbf{n}_j) u_{K_j} \\right]\n$$\nFor time integration, we use the explicit forward Euler method. Let $u_K^n$ be the approximation of $u_K(t_n)$ at time $t_n = n \\Delta t$.\n$$\n\\frac{u_K^{n+1} - u_K^n}{\\Delta t} = - \\frac{1}{|K|} \\sum_{j=0}^{2} |e_j| \\left[ \\max(0, \\mathbf{v} \\cdot \\mathbf{n}_j) u_K^n + \\min(0, \\mathbf{v} \\cdot \\mathbf{n}_j) u_{K_j}^n \\right]\n$$\nThis gives the final, fully-discrete update formula:\n$$\nu_K^{n+1} = u_K^n - \\frac{\\Delta t}{|K|} \\sum_{j=0}^{2} |e_j| \\left[ \\max(0, \\mathbf{v} \\cdot \\mathbf{n}_j) u_K^n + \\min(0, \\mathbf{v} \\cdot \\mathbf{n}_j) u_{K_j}^n \\right]\n$$\nThis scheme is conservative by construction, as the flux leaving one cell is equal to the flux entering the adjacent cell. For this explicit scheme to be stable, the time step $\\Delta t$ must satisfy the Courant-Friedrichs-Lewy (CFL) condition. For this first-order upwind scheme, the scheme is monotone (and thus satisfies the discrete maximum principle) if the coefficient of $u_K^n$ is non-negative. This leads to a local time step restriction for each cell $K$:\n$$\n\\Delta t_K \\le \\frac{|K|}{\\sum_{j=0}^{2} |e_j| \\max(0, \\mathbf{v} \\cdot \\mathbf{n}_j)}\n$$\nThe global time step for the entire mesh is then chosen as:\n$$\n\\Delta t = \\text{CFL} \\times \\min_K (\\Delta t_K)\n$$\nwhere the problem specifies $\\text{CFL} = 0.45$.\n\nThe implementation requires the following steps:\n1.  **Mesh Preprocessing**: For each defined mesh, compute all necessary geometric and connectivity information.\n    - For each triangle $K$ with vertices $\\mathbf{x}_a, \\mathbf{x}_b, \\mathbf{x}_c$ given in counter-clockwise order:\n        - Area: $|K| = \\frac{1}{2} |(x_b-x_a)(y_c-y_a) - (x_c-x_a)(y_b-y_a)|$.\n        - Centroid: $\\mathbf{x}_K = \\frac{1}{3}(\\mathbf{x}_a + \\mathbf{x}_b + \\mathbf{x}_c)$, used for evaluating the initial condition.\n    - For each edge $e_j$ defined by vertices $\\mathbf{x}_p, \\mathbf{x}_q$:\n        - Length: $|e_j| = \\sqrt{(x_q-x_p)^2 + (y_q-y_p)^2}$.\n        - Outward normal vector, for an edge from $\\mathbf{x}_p$ to $\\mathbf{x}_q$ as part of a CCW-ordered triangle: $\\mathbf{n}_j = \\frac{1}{|e_j|}(y_q-y_p, x_p-x_q)$.\n    - **Connectivity**: An `edge-to-cell` map is built to identify neighboring cells. For boundary edges, the specified periodic pairing is used to identify the \"neighbor\" cell across the domain boundary.\n2.  **Simulation Execution**:\n    - Initialize the cell-averaged state $u^0_K$ for all cells $K$ based on the given initial condition.\n    - Calculate the stable time step $\\Delta t$ using the global CFL condition.\n    - Iterate for the specified number of time steps, applying the fully discrete update formula to compute $u_K^{n+1}$ from $u_K^n$ for all cells.\n3.  **Post-processing**: After the final time step, compute the required quantities for each test case.\n    - Test Case A: Compute the change in total mass $\\Delta M_A = \\sum_{K} |K|(u_K^{N_A} - u_K^{0})$. For a conservative scheme on a periodic domain, this should be close to zero, with any deviation due to floating-point error.\n    - Test Case B: With $\\mathbf{v} = (0,0)$, the flux is identically zero, so $u_K^n = u_K^0$ for all $n$. The maximum difference $E_B = \\max_{K} |u_K^{N_B} - u_K^{0}|$ must be zero.\n    - Test Case C: Check if the discrete maximum principle is satisfied, i.e., whether $\\min_K u_K^{0} \\le u_K^{N_C} \\le \\max_K u_K^{0}$ holds for all cells $K$ within a given tolerance.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    # --- Mesh Definitions ---\n    mesh_A = {\n        'nodes': np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n        'elements': np.array([[0, 1, 2], [0, 2, 3]]),\n        'periodic_pairs': [((0, 1), (3, 2)), ((0, 3), (1, 2))]\n    }\n    mesh_B = {\n        'nodes': np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0], [0.5, 0.5]]),\n        'elements': np.array([[0, 1, 4], [1, 2, 4], [2, 3, 4], [3, 0, 4]]),\n        'periodic_pairs': [((0, 1), (3, 2)), ((0, 3), (1, 2))]\n    }\n\n    # --- Test Case Definitions ---\n    CFL = 0.45\n    \n    # Test Case A\n    velocity_A = np.array([1.0, 0.0])\n    n_steps_A = 20\n    def ic_A(x, y):\n        return np.sin(2 * np.pi * x) + 0.5 * np.cos(2 * np.pi * y)\n    \n    # Test Case B\n    velocity_B = np.array([0.0, 0.0])\n    n_steps_B = 5\n    def ic_B(x, y):\n        return x + 2 * y\n\n    # Test Case C\n    velocity_C = np.array([0.5, 0.25])\n    n_steps_C = 40\n    ic_C_values = np.array([0.0, 1.0, 0.5, 2.0])\n\n    # --- Utility Functions ---\n    def build_mesh_properties(nodes, elements, periodic_pairs):\n        \"\"\"\n        Computes geometric properties (area, normals) and connectivity (neighbors) for a mesh.\n        \"\"\"\n        num_elements = len(elements)\n        mesh_props = {\n            'areas': np.zeros(num_elements),\n            'centroids': np.zeros((num_elements, 2)),\n            'edges': [[] for _ in range(num_elements)]\n        }\n        \n        edge_to_cells = {}\n        for i, elem_nodes in enumerate(elements):\n            p1, p2, p3 = nodes[elem_nodes]\n            \n            # Area using Shoelace formula\n            area = 0.5 * abs(p1[0]*(p2[1] - p3[1]) + p2[0]*(p3[1] - p1[1]) + p3[0]*(p1[1] - p2[1]))\n            mesh_props['areas'][i] = area\n            \n            # Centroid\n            mesh_props['centroids'][i] = (p1 + p2 + p3) / 3.0\n            \n            # Edges and connectivity\n            elem_edges = [(elem_nodes[0], elem_nodes[1]), \n                          (elem_nodes[1], elem_nodes[2]), \n                          (elem_nodes[2], elem_nodes[0])]\n            \n            for p_idx1, p_idx2 in elem_edges:\n                edge_key = tuple(sorted((p_idx1, p_idx2)))\n                if edge_key not in edge_to_cells:\n                    edge_to_cells[edge_key] = []\n                edge_to_cells[edge_key].append(i)\n\n        # Build periodic mapping\n        periodic_map = {}\n        for p1, p2 in periodic_pairs:\n            k1, k2 = tuple(sorted(p1)), tuple(sorted(p2))\n            periodic_map[k1] = k2\n            periodic_map[k2] = k1\n\n        # Finalize edge properties (normal, length, neighbor)\n        for i, elem_nodes in enumerate(elements):\n            p_indices = [elem_nodes[0], elem_nodes[1], elem_nodes[2]]\n            for k in range(3):\n                p_idx1, p_idx2 = p_indices[k], p_indices[(k + 1) % 3]\n                p1, p2 = nodes[p_idx1], nodes[p_idx2]\n                \n                # Edge vector and length\n                edge_vec = p2 - p1\n                length = np.linalg.norm(edge_vec)\n                \n                # Outward normal (for CCW vertices)\n                normal = np.array([edge_vec[1], -edge_vec[0]]) / length\n                \n                # Neighbor finding\n                edge_key = tuple(sorted((p_idx1, p_idx2)))\n                cell_neighbors = edge_to_cells[edge_key]\n                neighbor_idx = -1\n                if len(cell_neighbors) == 2:\n                    neighbor_idx = cell_neighbors[0] if cell_neighbors[1] == i else cell_neighbors[1]\n                else: # Boundary edge\n                    paired_edge_key = periodic_map[edge_key]\n                    neighbor_idx = edge_to_cells[paired_edge_key][0]\n\n                mesh_props['edges'][i].append({\n                    'length': length,\n                    'normal': normal,\n                    'neighbor': neighbor_idx\n                })\n\n        return mesh_props\n\n    def run_simulation(mesh, ic_func, ic_values, velocity, n_steps, cfl):\n        \"\"\"\n        Runs the finite volume simulation for a given setup.\n        \"\"\"\n        nodes, elements, periodic_pairs = mesh['nodes'], mesh['elements'], mesh['periodic_pairs']\n        num_elements = len(elements)\n        \n        mesh_props = build_mesh_properties(nodes, elements, periodic_pairs)\n        \n        # Initialize state u\n        u = np.zeros(num_elements)\n        if ic_func is not None:\n            for i in range(num_elements):\n                centroid = mesh_props['centroids'][i]\n                u[i] = ic_func(centroid[0], centroid[1])\n        else:\n            u = np.copy(ic_values)\n        \n        u_initial = np.copy(u)\n\n        # If velocity is zero, no change occurs\n        if np.all(velocity == 0):\n            return u_initial, u, mesh_props['areas']\n\n        # Calculate stable time step dt\n        min_dt_inv = 0.0\n        for i in range(num_elements):\n            area = mesh_props['areas'][i]\n            outflow_sum = 0.0\n            for edge in mesh_props['edges'][i]:\n                v_dot_n = np.dot(velocity, edge['normal'])\n                outflow_sum += max(0, v_dot_n) * edge['length']\n            \n            if outflow_sum > 1e-12: # Avoid division by zero\n                dt_inv_local = outflow_sum / area\n                if dt_inv_local > min_dt_inv:\n                    min_dt_inv = dt_inv_local\n        \n        dt = cfl / min_dt_inv if min_dt_inv > 1e-12 else float('inf')\n\n        # Time-stepping loop\n        for _ in range(n_steps):\n            u_new = np.copy(u)\n            for i in range(num_elements):\n                area = mesh_props['areas'][i]\n                flux_sum = 0.0\n                for edge in mesh_props['edges'][i]:\n                    v_dot_n = np.dot(velocity, edge['normal'])\n                    u_neighbor = u[edge['neighbor']]\n                    \n                    # Upwind flux\n                    numerical_flux = max(0, v_dot_n) * u[i] + min(0, v_dot_n) * u_neighbor\n                    flux_sum += edge['length'] * numerical_flux\n                \n                u_new[i] -= (dt / area) * flux_sum\n            u = u_new\n        \n        return u_initial, u, mesh_props['areas']\n\n    # --- Execute Test Cases ---\n    \n    # Case A\n    u0_A, uN_A, areas_A = run_simulation(mesh_A, ic_A, None, velocity_A, n_steps_A, CFL)\n    delta_M_A = np.sum(areas_A * (uN_A - u0_A))\n    \n    # Case B\n    u0_B, uN_B, _ = run_simulation(mesh_B, ic_B, None, velocity_B, n_steps_B, CFL)\n    E_B = np.max(np.abs(uN_B - u0_B))\n    \n    # Case C\n    u0_C, uN_C, _ = run_simulation(mesh_B, None, ic_C_values, velocity_C, n_steps_C, CFL)\n    min_ic = np.min(u0_C)\n    max_ic = np.max(u0_C)\n    tol = 1e-12\n    dmp_C = np.all((uN_C >= min_ic - tol) & (uN_C <= max_ic + tol))\n\n    # --- Final Output ---\n    results = [delta_M_A, E_B, dmp_C]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2404174"}]}