{"hands_on_practices": [{"introduction": "The journey into numerical methods for conservation laws begins with a fundamental test: does a scheme truly conserve the intended quantity? This practice directly contrasts a finite volume scheme for the conservation form of the Burgers' equation with a finite difference scheme for its non-conservation form. Through both analytical proof and numerical implementation [@problem_id:2379409], you will verify that only the scheme built upon the integral conservation law maintains the total discrete \"mass\" of the system, a critical property for physical accuracy.", "problem": "Consider the scalar, inviscid Burgers’ equation written in two algebraically equivalent but numerically distinct forms on the periodic one-dimensional domain $[0,1)$:\n1) Conservation form: $u_t + (f(u))_x = 0$ with $f(u) = \\tfrac{u^2}{2}$.\n2) Nonconservation form: $u_t + u\\,u_x = 0$.\n\nYour tasks are:\nA) Starting from the integral conservation law and a cell-averaged viewpoint, derive a fully discrete finite volume update for the conservation form using a numerical interface flux. Use the following discrete update on a uniform mesh with $N$ cells of width $\\Delta x = 1/N$ and periodic boundary conditions:\n$$\nu_i^{n+1} \\;=\\; u_i^n \\;-\\; \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right),\n$$\nwith the Rusanov (local Lax–Friedrichs) numerical flux\n$$\nF_{i+\\tfrac{1}{2}}^n \\;=\\; \\tfrac{1}{2}\\left(f(u_i^n) + f(u_{i+1}^n)\\right) \\;-\\; \\tfrac{1}{2}\\, a_{i+\\tfrac{1}{2}}^n \\left(u_{i+1}^n - u_i^n\\right),\n\\quad f(u) = \\tfrac{u^2}{2},\n\\quad a_{i+\\tfrac{1}{2}}^n = \\max\\left(\\lvert u_i^n\\rvert, \\lvert u_{i+1}^n\\rvert\\right).\n$$\nProve from first principles (the discrete divergence theorem on a periodic mesh) that the total discrete mass\n$$\nM^n \\;=\\; \\sum_{i=0}^{N-1} u_i^n \\,\\Delta x\n$$\nis exactly conserved for all time steps $n$, that is, $M^{n+1} = M^n$.\n\nB) Consider the nonconservation form $u_t + u\\,u_x = 0$ discretized at cell centers with a forward finite difference for the spatial derivative and forward Euler in time:\n$$\nu_i^{n+1} \\;=\\; u_i^n \\;-\\; \\Delta t\\,u_i^n\\,\\frac{u_{i+1}^n - u_i^n}{\\Delta x},\n$$\nwith periodic indexing $u_{N}^n \\equiv u_0^n$. Show analytically that, in general, the total discrete mass $M^n$ is not invariant under this update by expressing $M^{n+1} - M^n$ in terms of the discrete field $u_i^n$ and demonstrating that it does not vanish for generic data.\n\nC) Implementation task. Write a complete, runnable program that:\n- Uses periodic boundary conditions on $[0,1)$ and a uniform grid with cell centers at $x_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$.\n- Uses forward Euler in time for both updates.\n- Uses a time step chosen dynamically each step by the Courant–Friedrichs–Lewy (CFL) rule\n$$\n\\Delta t \\;=\\; \\text{CFL}\\cdot \\frac{\\Delta x}{\\max_i \\lvert u_i^n\\rvert + 10^{-12}},\n$$\nwith the minimum added only to avoid division by zero.\n- Evolves to a specified final time $T$.\n\nTest suite. For each test, return a single floating-point number equal to the mass difference $\\Delta M = M^{\\text{final}} - M^{\\text{initial}}$. Use the following tests:\n- Test 1 (conservative scheme): $N = 200$, $\\text{CFL} = 0.9$, $T = 0.1$, initial condition $u(x,0) = 0.5 + 0.5\\sin(2\\pi x)$. Expect $\\Delta M$ to be approximately zero to machine precision due to exact telescoping of the flux differences on a periodic mesh.\n- Test 2 (nonconservative scheme): $N = 200$, $\\text{CFL} = 0.4$, $T = 0.1$, initial condition $u(x,0) = 0.5 + 0.5\\sin(2\\pi x)$. Expect $\\Delta M$ to be nonzero.\n- Test 3 (nonconservative scheme): $N = 200$, $\\text{CFL} = 0.4$, $T = 0.1$, initial condition $u(x,0) = \\sin(2\\pi x)$. Expect $\\Delta M$ to be nonzero.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3]\"), where each $r_k$ is the floating-point mass difference for the corresponding test in the exact order listed above. No additional text should be printed. There are no physical units in this problem; all quantities are nondimensional.", "solution": "The problem as stated is subjected to validation.\n\n**Step 1: Extract Givens**\n- **Equations:**\n    1. Conservation form: $u_t + (\\frac{u^2}{2})_x = 0$.\n    2. Nonconservation form: $u_t + u\\,u_x = 0$.\n- **Domain:** Periodic, $[0,1)$.\n- **Task A (Conservative Scheme):**\n    - Finite volume update: $u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right)$.\n    - Rusanov numerical flux: $F_{i+\\tfrac{1}{2}}^n = \\tfrac{1}{2}\\left(f(u_i^n) + f(u_{i+1}^n)\\right) - \\tfrac{1}{2}\\, a_{i+\\tfrac{1}{2}}^n \\left(u_{i+1}^n - u_i^n\\right)$, with $f(u) = \\tfrac{u^2}{2}$ and $a_{i+\\tfrac{1}{2}}^n = \\max\\left(\\lvert u_i^n\\rvert, \\lvert u_{i+1}^n\\rvert\\right)$.\n    - Discrete mass: $M^n = \\sum_{i=0}^{N-1} u_i^n \\,\\Delta x$.\n    - Objective: Prove $M^{n+1} = M^n$.\n- **Task B (Nonconservative Scheme):**\n    - Discretization: $u_i^{n+1} = u_i^n - \\Delta t\\,u_i^n\\,\\frac{u_{i+1}^n - u_i^n}{\\Delta x}$, with periodic index $u_N^n \\equiv u_0^n$.\n    - Objective: Show $M^{n+1} \\neq M^n$ in general.\n- **Task C (Implementation):**\n    - Grid: Uniform with $N$ cells, centers at $x_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$, where $\\Delta x = 1/N$.\n    - Time step: $\\Delta t = \\text{CFL}\\cdot \\frac{\\Delta x}{\\max_i \\lvert u_i^n\\rvert + 10^{-12}}$.\n    - Final time: $T$.\n- **Test Suite:**\n    - Test $1$: Conservative, $N=200$, $\\text{CFL}=0.9$, $T=0.1$, $u(x,0) = 0.5 + 0.5\\sin(2\\pi x)$.\n    - Test $2$: Nonconservative, $N=200$, $\\text{CFL}=0.4$, $T=0.1$, $u(x,0) = 0.5 + 0.5\\sin(2\\pi x)$.\n    - Test $3$: Nonconservative, $N=200$, $\\text{CFL}=0.4$, $T=0.1$, $u(x,0) = \\sin(2\\pi x)$.\n- **Output:** Mass difference $\\Delta M = M^{\\text{final}} - M^{\\text{initial}}$ for each test.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is well-defined, scientifically sound, and objective. It addresses fundamental concepts of numerical methods for conservation laws, specifically the distinction between conservative and nonconservative discretizations of the Burgers' equation. All parameters and conditions required for both the analytical derivations and the numerical implementation are provided. The problem is a standard exercise in computational mathematics and engineering.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A rigorous solution will be provided.\n\n---\n\n**A) Proof of Mass Conservation for the Conservative Scheme**\n\nThe total discrete mass at time step $n+1$ is defined as\n$$\nM^{n+1} = \\sum_{i=0}^{N-1} u_i^{n+1} \\Delta x.\n$$\nSubstituting the finite volume update rule for $u_i^{n+1}$:\n$$\nM^{n+1} = \\sum_{i=0}^{N-1} \\left[ u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right) \\right] \\Delta x.\n$$\nDistributing the summation and the $\\Delta x$ term:\n$$\nM^{n+1} = \\sum_{i=0}^{N-1} u_i^n \\Delta x - \\Delta t \\sum_{i=0}^{N-1} \\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right).\n$$\nThe first term is the total mass at time step $n$, $M^n$. The equation becomes:\n$$\nM^{n+1} = M^n - \\Delta t \\sum_{i=0}^{N-1} \\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right).\n$$\nTo prove conservation, we must show that the summation term vanishes. The sum is a discrete analogue of an integral of a divergence over a domain. Let us expand the sum:\n$$\n\\sum_{i=0}^{N-1} \\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right) = \\left(F_{\\tfrac{1}{2}}^n - F_{-\\tfrac{1}{2}}^n\\right) + \\left(F_{\\tfrac{3}{2}}^n - F_{\\tfrac{1}{2}}^n\\right) + \\left(F_{\\tfrac{5}{2}}^n - F_{\\tfrac{3}{2}}^n\\right) + \\dots + \\left(F_{N-\\tfrac{1}{2}}^n - F_{N-\\tfrac{3}{2}}^n\\right).\n$$\nThis is a telescoping sum. The terms cancel out pairwise: the positive $F_{i+\\tfrac{1}{2}}^n$ from cell $i$ cancels the negative $F_{j-\\tfrac{1}{2}}^n$ from cell $j=i+1$. Let us formalize this. Let the numerical flux function be denoted by $\\mathcal{F}(u_L, u_R)$, such that $F_{i+\\tfrac{1}{2}}^n = \\mathcal{F}(u_i^n, u_{i+1}^n)$. The sum over all cells $i = 0, \\dots, N-1$ is:\n$$\n\\sum_{i=0}^{N-1} \\left( \\mathcal{F}(u_i^n, u_{i+1}^n) - \\mathcal{F}(u_{i-1}^n, u_i^n) \\right).\n$$\nDue to the periodic boundary conditions, the grid indices are interpreted modulo $N$. Specifically, $u_{N}^n = u_0^n$ and $u_{-1}^n = u_{N-1}^n$.\nLet's examine the sum by re-indexing. Let $G_i = \\mathcal{F}(u_{i-1}^n, u_i^n)$. The sum is $\\sum_{i=0}^{N-1} G_{i+1} - \\sum_{i=0}^{N-1} G_i$.\nLet us change the index in the first sum, $j=i+1$. When $i=0$, $j=1$; when $i=N-1$, $j=N$. So $\\sum_{j=1}^{N} G_j$.\nThe sum becomes $\\sum_{j=1}^{N} G_j - \\sum_{i=0}^{N-1} G_i = (G_1 + \\dots + G_{N-1} + G_N) - (G_0 + G_1 + \\dots + G_{N-1}) = G_N - G_0$.\nBy definition, $G_N = \\mathcal{F}(u_{N-1}^n, u_N^n)$ and $G_0 = \\mathcal{F}(u_{-1}^n, u_0^n)$.\nUsing periodicity, $u_N^n = u_0^n$ and $u_{-1}^n = u_{N-1}^n$.\nTherefore, $G_N = \\mathcal{F}(u_{N-1}^n, u_0^n)$ and $G_0 = \\mathcal{F}(u_{N-1}^n, u_0^n)$.\nThus, $G_N - G_0 = 0$.\nThe sum of flux differences over the periodic domain is identically zero. This is a manifestation of the discrete divergence theorem on a discrete torus.\nConsequently,\n$$\nM^{n+1} = M^n - \\Delta t \\cdot 0 = M^n.\n$$\nThe total discrete mass is exactly conserved at every time step, regardless of the specific form of the consistent and conservative numerical flux $\\mathcal{F}$. This concludes the proof.\n\n**B) Analysis of Mass Conservation for the Nonconservative Scheme**\n\nThe nonconservative scheme is given by the update rule:\n$$\nu_i^{n+1} = u_i^n - \\Delta t\\,u_i^n\\,\\frac{u_{i+1}^n - u_i^n}{\\Delta x}.\n$$\nThe change in total discrete mass from time step $n$ to $n+1$ is\n$$\nM^{n+1} - M^n = \\sum_{i=0}^{N-1} \\left(u_i^{n+1} - u_i^n\\right) \\Delta x.\n$$\nSubstituting the expression for $u_i^{n+1} - u_i^n$ from the update rule:\n$$\nM^{n+1} - M^n = \\sum_{i=0}^{N-1} \\left( -\\Delta t\\,u_i^n\\,\\frac{u_{i+1}^n - u_i^n}{\\Delta x} \\right) \\Delta x.\n$$\nThe $\\Delta x$ terms cancel:\n$$\nM^{n+1} - M^n = -\\Delta t \\sum_{i=0}^{N-1} u_i^n \\left(u_{i+1}^n - u_i^n\\right).\n$$\nExpanding the product inside the summation:\n$$\nM^{n+1} - M^n = -\\Delta t \\sum_{i=0}^{N-1} \\left( u_i^n u_{i+1}^n - (u_i^n)^2 \\right) = \\Delta t \\left( \\sum_{i=0}^{N-1} (u_i^n)^2 - \\sum_{i=0}^{N-1} u_i^n u_{i+1}^n \\right).\n$$\nThe index $i+1$ is taken modulo $N$ due to periodic boundary conditions. For mass to be conserved, the term in the parenthesis must be zero.\n$$\n\\sum_{i=0}^{N-1} (u_i^n)^2 - \\sum_{i=0}^{N-1} u_i^n u_{i+1}^n = 0.\n$$\nThis condition is not satisfied for generic field data $u_i^n$. Consider a simple case with $N=2$. The condition becomes:\n$$\n(u_0^n)^2 + (u_1^n)^2 - (u_0^n u_1^n + u_1^n u_0^n) = (u_0^n-u_1^n)^2 = 0,\n$$\nwhich requires $u_0^n=u_1^n$. For a nontrivial field where values are not all equal, e.g., $u_0^n=1$ and $u_1^n=2$, the expression is $(1-2)^2=1 \\neq 0$. The mass is not conserved.\nThe algebraic equivalence of the continuous equations $u_t + (u^2/2)_x = 0$ and $u_t + u u_x = 0$ relies on the chain rule, which is valid only for smooth solutions. Discretizations of the nonconservation form do not inherit the conservation property of the original integral law and fail to capture the correct physics (e.g., shock speeds) when discontinuities arise. This derivation demonstrates that failure at the discrete level.\n\n**C) Numerical Implementation**\n\nThe implementation will consist of two primary functions: one for the conservative finite volume scheme and one for the nonconservative finite difference scheme. Both will use a forward Euler time-stepping method with a dynamic time step determined by the CFL condition.\n\n- **Grid and State:** A uniform grid on $[0, 1)$ with $N$ cells is used. The state vector `u` stores the cell-averaged values $u_i$. Periodic boundary conditions are handled using array-shifting operations (e.g., `numpy.roll`).\n- **Conservative Scheme:** The update requires computing the Rusanov flux $F_{i+\\frac{1}{2}}$ at each cell interface. This is vectorized by creating shifted versions of the state vector `u` to represent $u_{i+1}$. The fluxes are computed for all interfaces simultaneously. The update for $u_i$ involves the difference of fluxes at its right and left boundaries, $F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}$. This is also vectorized by computing a vector of fluxes `F` and a shifted version `numpy.roll(F, 1)`.\n- **Nonconservative Scheme:** The update is simpler. The spatial derivative term $u_x$ is approximated by a forward difference, $\\frac{u_{i+1}-u_i}{\\Delta x}$. This is vectorized using `numpy.roll` to get the $u_{i+1}$ values.\n- **Time Loop:** For each test case, the system is initialized with the given initial condition and evolved from $t=0$ to the final time $T$. In each step, the maximum wave speed $\\max_i|u_i^n|$ is found to compute a stable $\\Delta t$ according to the CFL rule, ensuring that the time step does not exceed the remaining time to reach $T$.\n- **Mass Calculation:** The initial mass $M^{\\text{initial}}$ is computed before the time loop. The final mass $M^{\\text{final}}$ is computed after the loop finishes. The difference $\\Delta M = M^{\\text{final}} - M^{\\text{initial}}$ is then reported for each test. For Test $1$, this value is expected to be near machine precision, confirming the analytical proof. For Tests $2$ and $3$, nonzero values are expected.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_conservative(N, CFL, T, u0_func):\n    \"\"\"\n    Solves the Burgers' equation using the conservative finite volume scheme.\n    \"\"\"\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    u = u0_func(x)\n\n    M_initial = np.sum(u) * dx\n    \n    t = 0.0\n    while t < T:\n        max_abs_u = np.max(np.abs(u))\n        dt = CFL * dx / (max_abs_u + 1e-12)\n        if t + dt > T:\n            dt = T - t\n        \n        # Periodic boundary conditions via np.roll\n        u_right = np.roll(u, -1) # u_{i+1}\n\n        # Physical flux f(u) = u^2 / 2\n        f_u = 0.5 * u**2\n        f_u_right = 0.5 * u_right**2\n\n        # Rusanov flux (Local Lax-Friedrichs)\n        # a_{i+1/2} = max(|u_i|, |u_{i+1}|)\n        a = np.maximum(np.abs(u), np.abs(u_right))\n        \n        # F_{i+1/2}\n        flux = 0.5 * (f_u + f_u_right) - 0.5 * a * (u_right - u)\n        \n        # F_{i-1/2} via roll\n        flux_left = np.roll(flux, 1)\n\n        # Update u\n        u = u - (dt / dx) * (flux - flux_left)\n        \n        t += dt\n    \n    M_final = np.sum(u) * dx\n    return M_final - M_initial\n\ndef run_nonconservative(N, CFL, T, u0_func):\n    \"\"\"\n    Solves the Burgers' equation using the nonconservative finite difference scheme.\n    \"\"\"\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    u = u0_func(x)\n\n    M_initial = np.sum(u) * dx\n\n    t = 0.0\n    while t < T:\n        max_abs_u = np.max(np.abs(u))\n        dt = CFL * dx / (max_abs_u + 1e-12)\n        if t + dt > T:\n            dt = T - t\n        \n        # Periodic boundary conditions for u_{i+1}\n        u_right = np.roll(u, -1)\n\n        # Forward difference for u_x\n        ux = (u_right - u) / dx\n\n        # Update u\n        u = u - dt * u * ux\n        \n        t += dt\n\n    M_final = np.sum(u) * dx\n    return M_final - M_initial\n\n\ndef solve():\n    \"\"\"\n    Executes the test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"scheme\": \"conservative\",\n            \"N\": 200, \"CFL\": 0.9, \"T\": 0.1,\n            \"u0_func\": lambda x: 0.5 + 0.5 * np.sin(2 * np.pi * x)\n        },\n        {\n            \"scheme\": \"nonconservative\",\n            \"N\": 200, \"CFL\": 0.4, \"T\": 0.1,\n            \"u0_func\": lambda x: 0.5 + 0.5 * np.sin(2 * np.pi * x)\n        },\n        {\n            \"scheme\": \"nonconservative\",\n            \"N\": 200, \"CFL\": 0.4, \"T\": 0.1,\n            \"u0_func\": lambda x: np.sin(2 * np.pi * x)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[\"scheme\"] == \"conservative\":\n            delta_M = run_conservative(case[\"N\"], case[\"CFL\"], case[\"T\"], case[\"u0_func\"])\n        else:\n            delta_M = run_nonconservative(case[\"N\"], case[\"CFL\"], case[\"T\"], case[\"u0_func\"])\n        results.append(delta_M)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2379409"}, {"introduction": "Having established that non-conservative schemes can fail to conserve total mass, we now investigate the most dramatic consequence: the incorrect propagation of shock waves. A scheme that does not respect the underlying integral conservation law will fail to compute the correct shock speed as dictated by the Rankine–Hugoniot condition. This hands-on practice [@problem_id:2379415] challenges you to implement both conservative and non-conservative schemes to track a shock wave, quantitatively measuring how the non-conservative solution diverges from the physical reality over time.", "problem": "Consider the scalar conservation law and its nonconservative counterpart on a one-dimensional domain:\n1) Conservation form: $\\partial_t u + \\partial_x f(u) = 0$ with $f(u) = \\tfrac{1}{2} u^2$.\n2) Nonconservation (advective) form: $\\partial_t u + u \\, \\partial_x u = 0$.\n\nOn the spatial interval $[0,L]$ with $L = 6$, impose piecewise-constant initial data with a single discontinuity located at $x = x_0$, with $x_0 = 1$. Let the left and right constant states be $u_L$ and $u_R$, respectively, so that\n$u(x,0) = \\begin{cases}\nu_L, & x < x_0,\\\\\nu_R, & x \\ge x_0.\n\\end{cases}$\nImpose fixed boundary states (Dirichlet in time) $u(0,t) = u_L$ and $u(L,t) = u_R$ for all $t \\ge 0$.\n\nFor the conservation-law problem with $u_L > u_R$ and $u_L \\ge 0$, $u_R \\ge 0$, the unique entropy solution is a shock that propagates with Rankine–Hugoniot speed $s = \\dfrac{f(u_L) - f(u_R)}{u_L - u_R} = \\dfrac{u_L + u_R}{2}$, so the exact shock position is $x_{\\text{exact}}(t) = x_0 + s \\, t$.\n\nTask. Implement two explicit, first-order-in-time, finite-difference or finite-volume semi-discrete approximations on a uniform grid with $N$ cells, where $N = 1200$, grid spacing $\\Delta x = L/N$, and a shared time step $\\Delta t$ chosen dynamically so that a Courant–Friedrichs–Lewy (CFL) number strictly less than $1$ is respected at every step. Use the same $\\Delta t$ at each step for both approximations.\n- One approximation must be conservative for the conservation form $\\partial_t u + \\partial_x f(u) = 0$, meaning its update over each time step can be written in a telescoping flux-difference form that preserves the discrete total integral of $u$ in the absence of boundary flux changes.\n- The other approximation must discretize the nonconservation form $\\partial_t u + u \\, \\partial_x u = 0$ in a way that is not conservative, meaning it cannot be written as a telescoping flux difference and therefore does not, in general, preserve the discrete total integral of $u$.\n\nEvolve both approximations from $t=0$ to $t=T$ on the same grid. At the final time $t = T$, approximate the shock position $x_{\\text{num}}$ from each numerical solution as the unique location where $u(x,T)$ equals the midpoint value $\\tfrac{u_L + u_R}{2}$, determined by linear interpolation between adjacent grid nodes that straddle this midpoint; if no such straddling occurs, take the grid location where $|u(x,T) - \\tfrac{u_L + u_R}{2}|$ is minimized.\n\nFor each test case below, compute the signed error of the nonconservative approximation’s shock position relative to the exact shock position, defined as $E_{\\text{nc}} = x_{\\text{nc}}(T) - x_{\\text{exact}}(T)$, expressed in the same spatial units as $x$ (dimensionless here). Positive $E_{\\text{nc}}$ indicates that the nonconservative approximation’s shock is to the right of the exact location; negative indicates it is to the left. Use $L = 6$, $x_0 = 1$, $N = 1200$, and a fixed Courant–Friedrichs–Lewy (CFL) number of $0.45$ for time stepping. Assume $u_L \\ge 0$ and $u_R \\ge 0$ in all cases.\n\nTest Suite. Use the following parameter sets, each a triple $(u_L, u_R, T)$:\n- Case $1$: $(2.0, 0.0, 0.5)$.\n- Case $2$: $(2.0, 0.0, 2.0)$.\n- Case $3$: $(2.0, 0.0, 4.0)$.\n- Case $4$: $(1.5, 0.2, 4.0)$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases above:\n$[E_{\\text{nc}}^{(1)}, E_{\\text{nc}}^{(2)}, E_{\\text{nc}}^{(3)}, E_{\\text{nc}}^{(4)}]$.", "solution": "The problem as stated is subjected to validation.\n\n**Step 1: Extracted Givens**\n- Governing Equations:\n  1. Conservation Form: $\\partial_t u + \\partial_x f(u) = 0$, with flux function $f(u) = \\tfrac{1}{2} u^2$.\n  2. Nonconservation Form: $\\partial_t u + u \\, \\partial_x u = 0$.\n- Domain and Parameters: Spatial interval $x \\in [0,L]$ with $L=6$; number of grid cells $N=1200$; grid spacing $\\Delta x = L/N$.\n- Initial Condition (IC): A Riemann problem with a discontinuity at $x_0=1$.\n  $u(x,0) = \\begin{cases} u_L, & x < x_0 \\\\ u_R, & x \\ge x_0 \\end{cases}$\n- Boundary Conditions (BCs): $u(0,t) = u_L$ and $u(L,t) = u_R$ for $t \\ge 0$.\n- Solution Properties: The problem considers cases where $u_L > u_R$ and $u_L, u_R \\ge 0$, for which the entropy solution is a shock wave.\n- Exact Shock Propagation: Rankine-Hugoniot speed $s = \\dfrac{f(u_L) - f(u_R)}{u_L - u_R} = \\dfrac{u_L + u_R}{2}$. Exact position is $x_{\\text{exact}}(t) = x_0 + s \\, t$.\n- Numerical Method Requirements:\n  - Two explicit, first-order-in-time semi-discrete approximations. One must be conservative, the other non-conservative.\n  - A shared, dynamic time step $\\Delta t$ is computed at each step using a Courant–Friedrichs–Lewy (CFL) number of $0.45$.\n- Task:\n  - Evolve both numerical approximations from $t=0$ to a final time $t=T$.\n  - At $t=T$, determine the numerical shock position $x_{\\text{num}}$ from each solution. The position is defined as the location where $u(x,T) = \\tfrac{u_L + u_R}{2}$, found via linear interpolation. If no grid cells straddle this value, the position is the grid point where $|u(x,T) - \\tfrac{u_L + u_R}{2}|$ is minimized.\n  - Compute the signed error for the non-conservative scheme: $E_{\\text{nc}} = x_{\\text{nc}}(T) - x_{\\text{exact}}(T)$.\n- Test Suite: Parameters $(u_L, u_R, T)$ are provided for four distinct cases.\n\n**Step 2: Validation of Problem Statement**\nThe problem is subjected to scrutiny based on scientific and mathematical principles.\n- **Scientific Grounding**: The problem addresses the inviscid Burgers' equation, a fundamental and non-trivial model equation in the study of hyperbolic partial differential equations and fluid dynamics. The distinction between conservative and non-conservative numerical schemes and their differing convergence properties for discontinuous solutions (shocks) is a cornerstone of computational physics. The problem is scientifically sound.\n- **Well-Posedness**: The initial-boundary value problem for a scalar hyperbolic conservation law is well-posed. For the specified condition $u_L > u_R$ and convex flux $f(u) = \\frac{1}{2}u^2$, the analytical solution is a unique, stable shock wave. The numerical task is explicitly defined with all necessary parameters, rendering it unambiguous.\n- **Objectivity**: The problem is articulated using precise, objective mathematical language, free from any subjective or speculative content.\n\n**Step 3: Verdict**\nThe problem is valid. It is a well-defined exercise in numerical analysis that demonstrates a critical principle: non-conservative numerical schemes fail to converge to the correct weak solution for problems with shocks, specifically by propagating discontinuities at an incorrect speed. We proceed with the solution.\n\n**Principle-Based Solution**\n\nThe objective is to compare the shock propagation in numerical solutions of the Burgers' equation obtained from a conservative scheme versus a non-conservative one. This demonstrates the critical importance of the conservation form for capturing correct shock physics.\n\n**1. Discretization of the Domain**\nThe spatial domain $[0, L]$ is discretized into $N$ uniform cells. We use a cell-centered finite volume/difference approach. The cells are indexed by $i = 0, 1, \\dots, N-1$. The center of cell $i$ is located at $x_i = (i + 0.5)\\Delta x$, where $\\Delta x = L/N$. The discrete solution variable $U_i(t)$ represents the cell average of $u(x,t)$ over cell $i$.\n\n**2. Conservative Numerical Scheme**\nThe conservation form $\\partial_t u + \\partial_x f(u) = 0$ is the correct starting point for problems admitting shock solutions. Integrating over a control volume (cell $i$) from $x_{i-1/2}$ to $x_{i+1/2}$ yields:\n$$ \\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx + f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t)) = 0 $$\nDefining the cell average $U_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx$ and numerical fluxes $F_{i\\pm1/2}$ at cell interfaces, we obtain the semi-discrete finite volume form:\n$$ \\frac{d U_i}{dt} = -\\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2}) $$\nThis form is manifestly conservative: when summed over all cells, the internal fluxes cancel in a telescoping manner, ensuring that the total quantity $\\sum_i U_i \\Delta x$ changes only due to boundary fluxes.\n\nFor a first-order scheme, we use an upwind flux. The characteristic speed is $f'(u) = u$. Given $u_L, u_R \\ge 0$, the solution $u(x,t)$ remains non-negative, and information propagates from left to right. The upwind flux at interface $i+1/2$ is therefore determined by the state to its left, $U_i$.\n$$ F_{i+1/2} = f(U_i) = \\frac{1}{2} U_i^2 $$\nSubstituting this into the semi-discrete form gives:\n$$ \\frac{d U_i}{dt} = -\\frac{1}{\\Delta x} (f(U_i) - f(U_{i-1})) $$\nApplying explicit Euler time integration ($U_i^{n+1} = U_i^n + \\Delta t \\frac{d U_i}{dt}|_n$) yields the fully discrete conservative scheme:\n$$ U_{i,\\text{c}}^{n+1} = U_{i,\\text{c}}^n - \\frac{\\Delta t}{\\Delta x} \\left( \\frac{1}{2}(U_{i,\\text{c}}^n)^2 - \\frac{1}{2}(U_{i-1,\\text{c}}^n)^2 \\right) $$\n\n**3. Non-Conservative Numerical Scheme**\nThe non-conservation form $\\partial_t u + u \\partial_x u = 0$ is mathematically equivalent to the conservation form for smooth solutions, but this equivalence breaks down at discontinuities. A numerical scheme based on this form is not guaranteed to satisfy the integral conservation property and will generally compute incorrect shock speeds.\n\nWe discretize this equation directly. Using explicit Euler for time and a first-order upwind (backward) difference for the spatial derivative $\\partial_x u$ to respect the direction of information flow:\n$$ \\frac{U_i^{n+1} - U_i^n}{\\Delta t} + U_i^n \\frac{U_i^n - U_{i-1}^n}{\\Delta x} = 0 $$\nThis gives the fully discrete non-conservative scheme:\n$$ U_{i,\\text{nc}}^{n+1} = U_{i,\\text{nc}}^n - \\frac{\\Delta t}{\\Delta x} U_{i,\\text{nc}}^n (U_{i,\\text{nc}}^n - U_{i-1,\\text{nc}}^n) $$\nThis update rule cannot be written in the flux-difference form required for conservation.\n\n**4. Boundary and Initial Conditions**\n- **Initial Condition:** The piecewise constant initial data is mapped onto the grid by setting $U_i(0) = u_L$ for cell centers $x_i < x_0$ and $U_i(0) = u_R$ for $x_i \\ge x_0$. For $x_0 = 1$ and $N=1200$, the discontinuity falls between cells $i=199$ and $i=200$.\n- **Boundary Conditions:** For $u > 0$, the boundary at $x=0$ is an inflow boundary, while $x=L$ is an outflow boundary.\n  - At the inflow ($x=0$), the state is determined by the external condition $u(0,t)=u_L$. This is handled by using a ghost cell at index $i=-1$ with the value $U_{-1}^n = u_L$ for both schemes.\n  - At the outflow ($x=L$), the state is determined by the dynamics within the domain. No boundary condition needs to be imposed. The one-sided nature of our chosen upwind schemes naturally handles this by not requiring information from beyond the rightmost cell. The given condition $u(L,t)=u_R$ is thus an observation of the expected outflow state, not an imposed constraint for this flow direction.\n\n**5. Time Stepping and Stability**\nAn explicit Forward Euler method requires a limit on the time step size for stability, governed by the Courant–Friedrichs–Lewy (CFL) condition. The time step $\\Delta t$ must satisfy:\n$$ \\Delta t \\le \\text{CFL} \\frac{\\Delta x}{\\max_i |u_i|} $$\nThe problem specifies a dynamic $\\Delta t$ using $\\text{CFL} = 0.45$. At each time step $n$, we compute the global maximum speed $u_{\\max}^n = \\max(\\max_i |U_{i,\\text{c}}^n|, \\max_i |U_{i,\\text{nc}}^n|)$ across both solutions to ensure stability for both schemes with a shared $\\Delta t$. The time step is then $\\Delta t^n = 0.45 \\cdot \\Delta x / u_{\\max}^n$. The simulation time is advanced incrementally until the final time $T$ is reached.\n\n**6. Shock Position Localization and Error Calculation**\nAt the final time $T$, the numerical shock position $x_{\\text{nc}}$ for the non-conservative solution is found. We search for adjacent grid points $(x_i, U_{i,\\text{nc}})$ and $(x_{i+1}, U_{i+1,\\text{nc}})$ that straddle the midpoint value $u_{\\text{mid}} = (u_L+u_R)/2$. If found, the position is determined by linear interpolation:\n$$ x_{\\text{nc}} = x_i + \\Delta x \\frac{u_{\\text{mid}} - U_{i,\\text{nc}}}{U_{i+1,\\text{nc}} - U_{i,\\text{nc}}} $$\nIf no such pair exists, $x_{\\text{nc}}$ is taken as the grid location $x_j$ where $|U_{j,\\text{nc}} - u_{\\text{mid}}|$ is minimized. The exact shock location is computed as $x_{\\text{exact}}(T) = x_0 + sT$. The required error is $E_{\\text{nc}} = x_{\\text{nc}}(T) - x_{\\text{exact}}(T)$.\n\nThis procedure is systematically applied to all test cases to quantify the error in shock speed produced by the non-conservative discretization.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_burgers(u_L, u_R, T, L, N, cfl, x0):\n    \"\"\"\n    Solves Burgers' equation using conservative and non-conservative schemes\n    and returns the final state of the non-conservative solution.\n    \"\"\"\n    dx = L / N\n    x = np.linspace(dx / 2, L - dx / 2, N)\n\n    # Initial conditions\n    u_c = np.full_like(x, u_R)\n    u_nc = np.full_like(x, u_R)\n    \n    # Locate the discontinuity index\n    # Based on x_i < x0 ==> (i+0.5)*dx < x0 ==> i < x0/dx - 0.5\n    split_idx_float = x0 / dx - 0.5\n    split_idx = int(np.floor(split_idx_float)) + 1\n    \n    u_c[:split_idx] = u_L\n    u_nc[:split_idx] = u_L\n\n    t = 0.0\n    while t < T:\n        # Determine shared dynamic time step\n        u_max_c = np.max(np.abs(u_c))\n        u_max_nc = np.max(np.abs(u_nc))\n        u_max = max(u_max_c, u_max_nc, 1e-9) # Avoid division by zero\n        \n        dt = cfl * dx / u_max\n        if t + dt > T:\n            dt = T - t\n        \n        # --- Conservative Scheme (Upwind Finite Volume) ---\n        # Extend solution array with ghost cell for inflow BC\n        u_c_ghost = np.concatenate(([u_L], u_c))\n        \n        # Flux at cell interfaces (f(u) = 0.5*u^2). Upwind implies f(u_left).\n        # We need N fluxes for N cells updates\n        # The flux at the right of cell i is f(u_i)\n        # The flux at the left of cell i is f(u_{i-1})\n        # F_{i+1/2} corresponds to f(U_i), so the flux vector would be f(U_i) for i in 0..N-1\n        # The update is U_i^{n+1} = U_i^n - dt/dx * (F_{i+1/2} - F_{i-1/2})\n        #                         = U_i^n - dt/dx * (f(U_i) - f(U_{i-1}))\n        # Vectorized implementation:\n        flux_c = 0.5 * u_c_ghost**2\n        flux_diff_c = flux_c[1:] - flux_c[:-1]\n        u_c = u_c - (dt / dx) * flux_diff_c\n\n        # --- Non-Conservative Scheme (Upwind Finite Difference) ---\n        u_nc_ghost = np.concatenate(([u_L], u_nc))\n        \n        # Advective term: u * (u_i - u_{i-1})/dx\n        adv_term_nc = u_nc_ghost[1:] * (u_nc_ghost[1:] - u_nc_ghost[:-1])\n        u_nc = u_nc - (dt / dx) * adv_term_nc\n        \n        t += dt\n\n    return u_nc, x\n\ndef find_shock_pos(u_final, x_grid, u_L, u_R):\n    \"\"\"\n    Finds the numerical shock position by interpolation.\n    \"\"\"\n    u_mid = (u_L + u_R) / 2.0\n    \n    # Search for straddling grid cells\n    for i in range(len(u_final) - 1):\n        # (u[i] - u_mid) and (u[i+1] - u_mid) have different signs\n        if (u_final[i] - u_mid) * (u_final[i+1] - u_mid) <= 0:\n            u_i = u_final[i]\n            u_i1 = u_final[i+1]\n            x_i = x_grid[i]\n            dx = x_grid[1] - x_grid[0]\n            \n            # Avoid division by zero if u_i1 == u_i\n            if abs(u_i1 - u_i) < 1e-9:\n                return x_i + dx/2.0\n                \n            # Linear interpolation\n            return x_i + dx * (u_mid - u_i) / (u_i1 - u_i)\n\n    # If no straddling found, find closest point\n    min_dist_idx = np.argmin(np.abs(u_final - u_mid))\n    return x_grid[min_dist_idx]\n    \ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    # Problem definition\n    L = 6.0\n    x0 = 1.0\n    N = 1200\n    CFL = 0.45\n    \n    test_cases = [\n        (2.0, 0.0, 0.5),  # Case 1\n        (2.0, 0.0, 2.0),  # Case 2\n        (2.0, 0.0, 4.0),  # Case 3\n        (1.5, 0.2, 4.0),  # Case 4\n    ]\n\n    results = []\n    for u_L, u_R, T in test_cases:\n        # Calculate exact shock position\n        s_exact = (u_L + u_R) / 2.0\n        x_exact = x0 + s_exact * T\n        \n        # Run simulation to get final state\n        u_nc_final, x_grid = solve_burgers(u_L, u_R, T, L, N, CFL, x0)\n        \n        # Find numerical shock position for non-conservative scheme\n        x_nc = find_shock_pos(u_nc_final, x_grid, u_L, u_R)\n        \n        # Compute the error\n        error_nc = x_nc - x_exact\n        results.append(error_nc)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "2379415"}, {"introduction": "A numerical scheme can be written in a \"flux-difference\" form, appearing structurally conservative, yet still be incorrect if the numerical flux itself is flawed. This practice explores the crucial concept of flux consistency, where the numerical flux $\\hat{F}(u_L, u_R)$ must be consistent with the physical flux $f(u)$, such that $\\hat{F}(u, u) = f(u)$. By implementing a scheme with an intentionally inconsistent numerical flux [@problem_id:2379435], you will discover how such a method effectively solves the wrong conservation law, leading to predictable but physically incorrect results.", "problem": "You are to investigate the impact of violating the conservation form in a finite volume discretization by comparing a correctly conservative numerical flux to an intentionally incorrect nonconservative numerical flux for a scalar conservation law. Consider the one-dimensional scalar conservation law\n$$\nu_t + f(u)_x = 0 \\quad \\text{on} \\quad [x_L,x_R] \\times [0,T],\n$$\nwith flux\n$$\nf(u) = \\tfrac{1}{2} u^2,\n$$\nand initial Riemann data\n$$\nu(x,0) =\n\\begin{cases}\nu_L, & x < x_0,\\\\\nu_R, & x \\ge x_0,\n\\end{cases}\n$$\nwith outflow boundary conditions at the endpoints. The Jacobian of the flux is\n$$\nA(u) = f'(u) = u.\n$$\nUse a uniform grid with $N$ control volumes of width $\\Delta x = (x_R - x_L)/N$ and a time step $\\Delta t$ satisfying a Courant-Friedrichs-Lewy (CFL) condition with CFL number $c \\in (0,1)$.\n\nDefine two semi-discrete finite volume updates for cell averages $u_i(t)$ on cells $[x_{i-1/2},x_{i+1/2}]$ with the standard flux-difference form:\n$$\n\\frac{d u_i}{d t} = -\\frac{1}{\\Delta x}\\left( \\hat{F}_{i+1/2} - \\hat{F}_{i-1/2} \\right).\n$$\n\nFor the conservative discretization, use the local Lax-Friedrichs (also called Rusanov) numerical flux\n$$\n\\hat{F}^{\\text{cons}}(u_L,u_R) = \\tfrac{1}{2}\\big(f(u_L)+f(u_R)\\big) - \\tfrac{1}{2} a(u_L,u_R) (u_R - u_L),\n$$\nwhere\n$$\na(u_L,u_R) = \\max\\big(|f'(u_L)|, |f'(u_R)|\\big) = \\max\\big(|u_L|,|u_R|\\big).\n$$\n\nFor the intentionally nonconservative discretization, replace the central flux term by a nonconservative approximation formed from the average of $A(u)$ and the average of $u$:\n$$\n\\hat{F}^{\\text{noncons}}(u_L,u_R) = \\left(\\tfrac{1}{2}\\big(A(u_L)+A(u_R)\\big)\\right)\\left(\\tfrac{1}{2}\\big(u_L+u_R\\big)\\right) - \\tfrac{1}{2} a(u_L,u_R) (u_R - u_L),\n$$\nwith the same dissipation $a(u_L,u_R)$ as above. Advance the solution in time with a forward Euler method using a time step $\\Delta t$ that satisfies the CFL condition $\\Delta t \\le c \\, \\Delta x / \\max_i |u_i|$ at each time step.\n\nFor each test case below, compute the following diagnostics at the final time $T$:\n\n- For shock cases with $u_L > u_R$, compute the observed shock speed using the nonconservative scheme as\n$$\ns_{\\text{obs}} = \\frac{x_{\\text{shock}}(T) - x_0}{T},\n$$\nwhere $x_{\\text{shock}}(T)$ is the location where $u$ crosses the midpoint value $m = \\tfrac{1}{2}(u_L+u_R)$, determined by linear interpolation between adjacent cell centers. Compute the exact Rankine–Hugoniot shock speed for the conservation law,\n$$\ns_{\\text{exact}} = \\frac{f(u_L)-f(u_R)}{u_L - u_R} = \\tfrac{1}{2}(u_L + u_R),\n$$\nand report the difference\n$$\nd_s = s_{\\text{obs}} - s_{\\text{exact}}.\n$$\n\n- For rarefaction cases with $u_L < u_R$, compute the $L^1$ error at time $T$ for each scheme relative to the exact self-similar solution of the Burgers’ rarefaction,\n$$\nu(x,T) =\n\\begin{cases}\nu_L, & x - x_0 \\le u_L T,\\\\\n\\dfrac{x - x_0}{T}, & u_L T \\le x - x_0 \\le u_R T,\\\\\nu_R, & x - x_0 \\ge u_R T,\n\\end{cases}\n$$\nand report the difference of $L^1$ errors\n$$\nd_{L^1} = \\|u^{\\text{noncons}}(\\cdot,T) - u^{\\text{exact}}(\\cdot,T)\\|_{L^1} - \\|u^{\\text{cons}}(\\cdot,T) - u^{\\text{exact}}(\\cdot,T)\\|_{L^1}.\n$$\n\n- For constant-data cases with $u_L = u_R$, report the maximum absolute deviation of the nonconservative solution from the initial constant value,\n$$\nd_{\\max} = \\max_i \\big| u^{\\text{noncons}}_i(T) - u_L \\big|.\n$$\n\nUse the following parameter values, which constitute the test suite:\n\n- Spatial domain: $[x_L,x_R] = [-1,1]$.\n- Number of cells: $N = 800$.\n- Courant-Friedrichs-Lewy number: $c = 0.45$.\n- Boundary conditions: outflow.\n- Test cases $(u_L,u_R,x_0,T)$:\n  1. $(1.0, 0.0, 0.0, 0.2)$ shock case; report $d_s$.\n  2. $(0.0, 1.0, 0.0, 0.2)$ rarefaction case; report $d_{L^1}$.\n  3. $(0.5, 0.5, 0.0, 0.2)$ constant case; report $d_{\\max}$.\n  4. $(0.2, 0.0, -0.1, 0.3)$ small-amplitude shock; report $d_s$.\n\nYour program must produce a single line of output containing a list of the four results in the order of the test cases as a comma-separated list enclosed in square brackets, for example\n$$\n[\\;r_1,r_2,r_3,r_4\\;],\n$$\nwhere each $r_i$ is a real number as defined above. No additional text or lines should be printed. All numerical values in the output must be expressed as plain decimal numbers without units.", "solution": "The problem requires an investigation into the consequences of using a nonconservative numerical scheme for a scalar conservation law, specifically the inviscid Burgers' equation, $u_t + f(u)_x = 0$ with flux $f(u) = \\frac{1}{2}u^2$. A finite volume method is employed to compare a conservative scheme (using the local Lax-Friedrichs, or Rusanov, flux) against an intentionally nonconservative one. The analysis is performed for shock, rarefaction, and constant-data initial conditions.\n\nFirst, let us establish the theoretical foundation. A finite volume scheme for the conservation law $\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0$, integrated over a control volume $[x_{i-1/2}, x_{i+1/2}]$, yields the exact relation for the cell average $u_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$:\n$$\n\\frac{d u_i}{d t} = -\\frac{1}{\\Delta x}\\left( F(u(x_{i+1/2}, t)) - F(u(x_{i-1/2}, t)) \\right).\n$$\nHere, $F(u(x,t))$ is the physical flux evaluated at the cell interfaces. In a numerical scheme, this is replaced by a numerical flux function $\\hat{F}(u_L, u_R)$, which approximates the flux at an interface given the state $u_L$ to the left and $u_R$ to the right. The semi-discrete scheme is then:\n$$\n\\frac{d u_i}{d t} = -\\frac{1}{\\Delta x}\\left( \\hat{F}_{i+1/2} - \\hat{F}_{i-1/2} \\right),\n$$\nwhere $\\hat{F}_{i+1/2} = \\hat{F}(u_i, u_{i+1})$. This form is inherently conservative; the change in the total quantity $\\sum_i u_i \\Delta x$ is determined solely by the fluxes at the domain boundaries. However, for a scheme to converge to the correct weak solution of the conservation law, especially in the presence of discontinuities (shocks), the numerical flux $\\hat{F}(u_L, u_R)$ must be consistent with the physical flux $f(u)$, meaning $\\hat{F}(u, u) = f(u)$.\n\nThe conservative Rusanov flux is defined as:\n$$\n\\hat{F}^{\\text{cons}}(u_L,u_R) = \\tfrac{1}{2}\\big(f(u_L)+f(u_R)\\big) - \\tfrac{1}{2} a(u_L,u_R) (u_R - u_L).\n$$\nFor $u_L=u_R=u$, the dissipation term vanishes, and we have $\\hat{F}^{\\text{cons}}(u,u) = \\frac{1}{2}(f(u)+f(u)) = f(u)$. This flux is consistent.\n\nThe specified \"nonconservative\" flux is:\n$$\n\\hat{F}^{\\text{noncons}}(u_L,u_R) = \\left(\\tfrac{1}{2}\\big(A(u_L)+A(u_R)\\big)\\right)\\left(\\tfrac{1}{2}\\big(u_L+u_R\\big)\\right) - \\tfrac{1}{2} a(u_L,u_R) (u_R - u_L).\n$$\nWith $f(u) = \\frac{1}{2}u^2$, we have $A(u) = f'(u) = u$. Let us check its consistency:\n$$\n\\hat{F}^{\\text{noncons}}(u,u) = \\left(\\tfrac{1}{2}\\big(u+u\\big)\\right)\\left(\\tfrac{1}{2}\\big(u+u\\big)\\right) = u \\cdot u = u^2.\n$$\nThe physical flux is $f(u) = \\frac{1}{2}u^2$. Since $\\hat{F}^{\\text{noncons}}(u,u) = u^2 \\neq f(u)$, this numerical flux is inconsistent with the original conservation law. The scheme will not converge to the correct solution. Instead, it attempts to solve the incorrect conservation law $u_t + g(u)_x = 0$, where the effective numerical flux is $g(u) = u^2$.\n\nThe consequences of this inconsistency are profound:\n1.  For shock waves ($u_L > u_R$), the speed of a discontinuity must satisfy the Rankine-Hugoniot condition, $s = [f]/[u] = (f(u_L)-f(u_R))/(u_L-u_R)$. Our conservative scheme will approximate this speed. The nonconservative scheme will approximate the shock speed for the wrong conservation law: $s_{\\text{noncons}} = (g(u_L)-g(u_R))/(u_L-u_R) = (u_L^2-u_R^2)/(u_L-u_R) = u_L+u_R$. The exact speed for the correct law is $s_{\\text{exact}} = (\\frac{1}{2}u_L^2-\\frac{1}{2}u_R^2)/(u_L-u_R) = \\frac{1}{2}(u_L+u_R)$. The numerical solution from the inconsistent scheme is therefore expected to exhibit a shock traveling at the incorrect speed, with a predicted speed difference of $d_s \\approx s_{\\text{noncons}} - s_{\\text{exact}} = \\frac{1}{2}(u_L+u_R)$.\n\n2.  For rarefaction waves ($u_L < u_R$), the flow is smooth, and the inconsistency introduces errors that pollute the solution. The difference in $L^1$ errors, $d_{L^1}$, will quantify how much worse the nonconservative scheme performs compared to the conservative baseline.\n\n3.  For constant initial data ($u_L = u_R = u_c$), an exact solver would maintain this state. However, the nonconservative scheme can be unstable. Small numerical perturbations can be amplified, leading to spurious oscillations and a deviation from the constant state. The required diagnostic $d_{\\max}$ will measure the magnitude of this deviation.\n\nThe implementation proceeds as follows: A uniform grid of $N=800$ cells is defined on the domain $[x_L, x_R] = [-1, 1]$. Initial Riemann data are set for each test case. The solution is advanced in time using a forward Euler method. The time step $\\Delta t$ is calculated at each step to satisfy the CFL condition $\\Delta t = c \\cdot \\Delta x / \\max_i|u_i|$ with $c=0.45$, ensuring stability. The maximum wave speed $\\max_i|u_i|$ is taken over the entire numerical solution domain. Outflow boundary conditions are implemented by setting the values in ghost cells equal to the adjacent interior cells.\n\nFor each test case, the appropriate simulation(s) are run until the final time $T$.\n-   For a shock case, the nonconservative simulation is run. The final position of the shock, $x_{\\text{shock}}(T)$, is found by searching for the cell interface where the solution crosses the midpoint value $m = \\frac{1}{2}(u_L+u_R)$ and applying linear interpolation. The observed speed $s_{\\text{obs}}$ and the discrepancy $d_s = s_{\\text{obs}} - s_{\\text{exact}}$ are then computed.\n-   For the rarefaction case, both conservative and nonconservative simulations are run. The exact self-similar solution is computed on the grid at time $T$. The $L^1$ error for each numerical solution is calculated as $\\|u_{\\text{num}} - u_{\\text{exact}}\\|_{L^1} = \\sum_i |u_{i, \\text{num}} - u_{i, \\text{exact}}| \\Delta x$. The final reported value is the difference of these errors, $d_{L^1}$.\n-   For the constant-data case, the nonconservative simulation is run. The maximum absolute difference between the final numerical solution and the initial constant value $u_L$ is calculated across all cells to find $d_{\\max}$.\n\nThe code executes this logic for the four specified test cases and reports the resulting diagnostics.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing conservative and nonconservative finite volume schemes\n    for the inviscid Burgers' equation.\n    \"\"\"\n\n    test_cases = [\n        {'uL': 1.0, 'uR': 0.0, 'x0': 0.0, 'T': 0.2, 'type': 'shock'},\n        {'uL': 0.0, 'uR': 1.0, 'x0': 0.0, 'T': 0.2, 'type': 'rarefaction'},\n        {'uL': 0.5, 'uR': 0.5, 'x0': 0.0, 'T': 0.2, 'type': 'constant'},\n        {'uL': 0.2, 'uR': 0.0, 'x0': -0.1, 'T': 0.3, 'type': 'shock'},\n    ]\n\n    results = []\n    \n    # Global parameters\n    xL, xR = -1.0, 1.0\n    N = 800\n    cfl = 0.45\n    dx = (xR - xL) / N\n    x = np.linspace(xL + dx / 2.0, xR - dx / 2.0, N)\n\n    def f(u):\n        return 0.5 * u**2\n\n    def A(u):\n        return u\n\n    def F_cons(ul, ur):\n        a = np.maximum(np.abs(ul), np.abs(ur))\n        return 0.5 * (f(ul) + f(ur)) - 0.5 * a * (ur - ul)\n\n    def F_noncons(ul, ur):\n        a = np.maximum(np.abs(ul), np.abs(ur))\n        avg_u = 0.5 * (ul + ur)\n        avg_A = 0.5 * (A(ul) + A(ur))\n        return avg_A * avg_u - 0.5 * a * (ur - ul)\n\n    def run_sim(u0, T_final, schemes):\n        solutions = {s: u0.copy() for s in schemes}\n        \n        t = 0.0\n        while t < T_final:\n            max_u_abs = 1e-9 # Avoid division by zero\n            for u in solutions.values():\n                max_u_abs = np.maximum(max_u_abs, np.max(np.abs(u)))\n\n            dt = cfl * dx / max_u_abs\n            dt = min(dt, T_final - t)\n\n            for s_name, u in solutions.items():\n                u_ext = np.concatenate(([u[0]], u, [u[-1]]))\n                \n                ul = u_ext[:-1]\n                ur = u_ext[1:]\n                \n                if s_name == 'cons':\n                    flux = F_cons(ul, ur)\n                else:\n                    flux = F_noncons(ul, ur)\n                \n                u -= (dt / dx) * (flux[1:] - flux[:-1])\n            \n            t += dt\n            \n        return solutions\n\n    for case in test_cases:\n        uL, uR, x0, T, case_type = case['uL'], case['uR'], case['x0'], case['T'], case['type']\n        \n        # Initial condition - use np.where for robust floating point comparison\n        u0 = np.where(x < x0, uL, uR).astype(float)\n\n        if case_type == 'shock':\n            final_states = run_sim(u0, T, ['noncons'])\n            u_final = final_states['noncons']\n            \n            m = 0.5 * (uL + uR)\n            # Find the first index where u drops below the midpoint m\n            indices = np.where(u_final <= m)[0]\n            if len(indices) == 0 or indices[0] == 0:\n                # Shock has not entered or is at the very beginning\n                x_shock = x[np.argmin(u_final)]\n            else:\n                i = indices[0]\n                u_i = u_final[i]\n                u_im1 = u_final[i-1]\n                x_i = x[i]\n                x_im1 = x[i-1]\n                \n                if abs(u_i - u_im1) < 1e-9:\n                    x_shock = x_i\n                else:\n                    # Linear interpolation\n                    x_shock = x_im1 + (x_i - x_im1) * (m - u_im1) / (u_i - u_im1)\n\n            s_obs = (x_shock - x0) / T\n            s_exact = 0.5 * (uL + uR)\n            ds = s_obs - s_exact\n            results.append(ds)\n\n        elif case_type == 'rarefaction':\n            final_states = run_sim(u0, T, ['cons', 'noncons'])\n            u_cons = final_states['cons']\n            u_noncons = final_states['noncons']\n            \n            # Exact solution\n            xi_t = (x - x0) / T if T > 0 else np.zeros_like(x)\n            u_exact = np.full_like(x, 0.0)\n            u_exact = np.where(xi_t <= uL, uL, u_exact)\n            u_exact = np.where(xi_t >= uR, uR, u_exact)\n            mask = (xi_t > uL) & (xi_t < uR)\n            u_exact[mask] = xi_t[mask]\n\n            l1_err_cons = np.sum(np.abs(u_cons - u_exact)) * dx\n            l1_err_noncons = np.sum(np.abs(u_noncons - u_exact)) * dx\n            d_l1 = l1_err_noncons - l1_err_cons\n            results.append(d_l1)\n            \n        elif case_type == 'constant':\n            final_states = run_sim(u0, T, ['noncons'])\n            u_final = final_states['noncons']\n            d_max = np.max(np.abs(u_final - uL))\n            results.append(d_max)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2379435"}]}