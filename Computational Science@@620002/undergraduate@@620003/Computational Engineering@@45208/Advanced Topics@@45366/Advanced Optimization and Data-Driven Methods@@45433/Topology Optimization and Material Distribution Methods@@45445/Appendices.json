{"hands_on_practices": [{"introduction": "The Solid Isotropic Material with Penalization (SIMP) method is a cornerstone of density-based topology optimization. This foundational exercise guides you to reconstruct the SIMP material interpolation model from a set of physical and numerical requirements. By deriving and applying the formula [@problem_id:2606482], you will gain a concrete understanding of how the penalization scheme discourages inefficient \"gray\" areas, pushing the design towards a distinct, manufacturable layout of solid and void.", "problem": "Consider a linear elastic compliance-minimization topology optimization problem discretized by the Finite Element Method (FEM). The material distribution is represented by element-wise densities $\\rho_e \\in [0,1]$ over a fixed mesh, and an ersatz material approach is used to avoid singular stiffness matrices by assigning a small but nonzero stiffness to elements with $\\rho_e \\approx 0$. In the Solid Isotropic Material with Penalization (SIMP) framework, the effective element-wise Young’s modulus $E(\\rho_e)$ is required to satisfy the following fundamental conditions derived from the modeling assumptions:\n1) $E(\\rho_e)$ is monotonically increasing in $\\rho_e$.\n2) $E(0) = E_{\\min}$ and $E(1) = E_0$, where $E_0$ is the Young’s modulus of the fully solid material and $E_{\\min} \\ll E_0$ is the ersatz stiffness for near-void elements.\n3) The element stiffness matrix scales linearly with $E(\\rho_e)$, i.e., $K_e(\\rho_e) = E(\\rho_e)\\,\\tilde{K}_e$, where $\\tilde{K}_e$ is the reference stiffness matrix computed for unit modulus.\n4) A penalization exponent $p>1$ enforces the energetic disfavoring of intermediate densities by accentuating the contrast between $E(0)$ and $E(1)$.\n\nUsing only these conditions and dimensional consistency, first reconstruct the simplest smooth power-law interpolation for $E(\\rho_e)$ consistent with the above constraints for a given exponent $p$. Then, for $p=3$, $E_{\\min}=10^{-3}E_0$, and three representative element densities $\\rho_e \\in \\{0.1,\\,0.5,\\,0.9\\}$, compute the normalized effective stiffnesses $E(\\rho_e)/E_0$. Explain, in the context of topology optimization and in contrast to level-set formulations with crisp material boundaries, how these values reflect the penalization of intermediate densities and the role of $E_{\\min}$ in numerical stability.\n\nReport your answer as the row vector $[\\,E(0.1)/E_0,\\;E(0.5)/E_0,\\;E(0.9)/E_0\\,]$ using exact values (no rounding). No units are required because the normalization by $E_0$ renders the quantities dimensionless.", "solution": "The problem statement is subjected to validation before a solution is attempted.\n\nThe givens are as follows:\n- A linear elastic compliance-minimization problem is discretized using the Finite Element Method (FEM).\n- Material distribution is described by element-wise densities $\\rho_e \\in [0,1]$.\n- An ersatz material approach is used.\n- The framework is the Solid Isotropic Material with Penalization (SIMP) model.\n- The effective element-wise Young’s modulus $E(\\rho_e)$ must satisfy four conditions:\n    1. $E(\\rho_e)$ is monotonically increasing in $\\rho_e$.\n    2. Boundary conditions: $E(0) = E_{\\min}$ and $E(1) = E_0$, where $E_0$ is the solid material modulus and $E_{\\min} \\ll E_0$ is the ersatz stiffness.\n    3. The element stiffness matrix scales linearly with the modulus: $K_e(\\rho_e) = E(\\rho_e)\\,\\tilde{K}_e$.\n    4. A penalization exponent $p > 1$ is used to energetically disfavor intermediate densities.\n- Specific values for computation: $p=3$, $E_{\\min}=10^{-3}E_0$.\n- Representative densities for evaluation: $\\rho_e \\in \\{0.1,\\,0.5,\\,0.9\\}$.\n\nValidation of the problem statement:\n- **Scientific Grounding**: The problem is firmly grounded in the established theory of continuum mechanics and computational structural optimization. The SIMP method is a canonical and widely used technique in topology optimization. All assumptions and conditions are standard in the field.\n- **Well-Posedness**: The problem is well-posed. The constraints provided are sufficient to uniquely determine the simplest form of the interpolation function. The subsequent calculation is a direct application of this derived function.\n- **Objectivity**: The problem is stated in precise, objective, and technical language, free from ambiguity or subjective claims.\n\nThe problem statement is found to be valid as it is scientifically sound, well-posed, objective, and complete. No flaws from the checklist are identified. The solution process may proceed.\n\nFirst, we must reconstruct the simplest smooth power-law interpolation for the effective Young's modulus, $E(\\rho_e)$, based on the given conditions. Let the function be a general power-law relationship. The penalization (Condition 4) is introduced through the term $\\rho_e^p$. To satisfy the boundary conditions (Condition 2), we seek a function that maps the penalized density range, which is $[0^p, 1^p] = [0, 1]$, to the stiffness range $[E_{\\min}, E_0]$. A simple linear mapping of the penalized density variable $\\rho_e^p$ to the stiffness $E$ is the most straightforward approach.\n\nLet us propose the following functional form:\n$$\nE(\\rho_e) = A + B \\cdot \\rho_e^p\n$$\nwhere $A$ and $B$ are constants to be determined by the boundary conditions.\n\nUsing Condition 2, we have:\nAt $\\rho_e = 0$: $E(0) = A + B \\cdot (0)^p = A$. We are given $E(0) = E_{\\min}$, therefore $A = E_{\\min}$.\nAt $\\rho_e = 1$: $E(1) = A + B \\cdot (1)^p = A + B$. We are given $E(1) = E_0$.\nSubstituting $A = E_{\\min}$, we get $E_0 = E_{\\min} + B$, which implies $B = E_0 - E_{\\min}$.\n\nSubstituting the constants $A$ and $B$ back into the proposed form gives the interpolation scheme:\n$$\nE(\\rho_e) = E_{\\min} + (E_0 - E_{\\min})\\rho_e^p\n$$\nThis is the standard SIMP interpolation model. We must verify this against the remaining conditions.\n\n- **Condition 1 (Monotonicity)**: We check the derivative of $E(\\rho_e)$ with respect to $\\rho_e$:\n$$\n\\frac{dE}{d\\rho_e} = \\frac{d}{d\\rho_e} \\left( E_{\\min} + (E_0 - E_{\\min})\\rho_e^p \\right) = (E_0 - E_{\\min}) p \\rho_e^{p-1}\n$$\nGiven that $E_{\\min} \\ll E_0$, the term $(E_0 - E_{\\min})$ is positive. The penalization exponent $p > 1$ is also positive. For $\\rho_e \\in [0, 1]$, the term $\\rho_e^{p-1}$ is non-negative. Thus, $\\frac{dE}{d\\rho_e} \\ge 0$ over the entire domain, confirming that the function is monotonically increasing.\n\n- **Condition 3 (Linear Scaling of Stiffness Matrix)**: This is satisfied by the problem's own setup, where the element stiffness is defined as $K_e(\\rho_e) = E(\\rho_e)\\,\\tilde{K}_e$. Our derived $E(\\rho_e)$ is a scalar function that multiplies the reference stiffness matrix, which is consistent.\n\n- **Condition 4 (Penalization)**: For any $\\rho_e \\in (0, 1)$ and $p > 1$, we have $\\rho_e^p < \\rho_e$. The derived formula shows that the modulus scales with $\\rho_e^p$, not $\\rho_e$. In a typical compliance minimization problem, the total material volume is constrained, and it scales linearly with $\\rho_e$. The stiffness, however, scales with $\\rho_e^p$. This mismatch makes intermediate densities structurally inefficient (low stiffness for their \"cost\" in volume), thus driving the optimization algorithm to select nearly binary densities ($0$ or $1$).\n\nNext, we compute the normalized effective stiffness, $E(\\rho_e)/E_0$, for the given parameters $p=3$ and $E_{\\min} = 10^{-3}E_0$.\nThe normalized stiffness is:\n$$\n\\frac{E(\\rho_e)}{E_0} = \\frac{E_{\\min} + (E_0 - E_{\\min})\\rho_e^p}{E_0} = \\frac{E_{\\min}}{E_0} + \\left(1 - \\frac{E_{\\min}}{E_0}\\right)\\rho_e^p\n$$\nSubstituting the given values $\\frac{E_{\\min}}{E_0} = 10^{-3} = 0.001$ and $p=3$:\n$$\n\\frac{E(\\rho_e)}{E_0} = 0.001 + (1 - 0.001)\\rho_e^3 = 0.001 + 0.999 \\rho_e^3\n$$\nNow we evaluate this expression for the three specified values of $\\rho_e$:\n\n1. For $\\rho_e = 0.1$:\n$$\n\\frac{E(0.1)}{E_0} = 0.001 + 0.999 \\cdot (0.1)^3 = 0.001 + 0.999 \\cdot 0.001 = 0.001 \\cdot (1 + 0.999) = 0.001999\n$$\n\n2. For $\\rho_e = 0.5$:\n$$\n\\frac{E(0.5)}{E_0} = 0.001 + 0.999 \\cdot (0.5)^3 = 0.001 + 0.999 \\cdot 0.125 = 0.001 + 0.124875 = 0.125875\n$$\n\n3. For $\\rho_e = 0.9$:\n$$\n\\frac{E(0.9)}{E_0} = 0.001 + 0.999 \\cdot (0.9)^3 = 0.001 + 0.999 \\cdot 0.729 = 0.001 + 0.728271 = 0.729271\n$$\n\nFinally, we provide the required explanations.\n\n- **Penalization of intermediate densities**: The computed values demonstrate the effect of penalization. For an element with density $\\rho_e=0.5$, its normalized stiffness is only about $0.126$. This value is significantly lower than the density itself. If there were no penalization (i.e., $p=1$), the normalized stiffness would be approximately $\\frac{E(0.5)}{E_0} \\approx 0.5$. The exponent $p=3$ has reduced the stiffness contribution of this intermediate density element by a factor of approximately $0.5 / 0.126 \\approx 4$. An optimization algorithm that seeks to maximize stiffness for a given material volume will therefore find it highly inefficient to use material at this density, and will be driven to push the density towards either $0$ or $1$, resulting in a more black-and-white, manufacturable design.\n\n- **Role of $E_{\\min}$**: The minimum modulus $E_{\\min}$ is a numerical device, not a physical one. In the finite element formulation, the global stiffness matrix $K$ must be inverted to solve the system of linear equations $KU=F$. If elements were allowed to have zero stiffness ($E=0$), large regions of \"void\" elements could render the global matrix $K$ singular (non-invertible), causing the simulation to fail. By assigning a small, non-zero stiffness $E_{\\min}$ to void elements ($\\rho_e \\approx 0$), we guarantee that $K$ remains positive definite and invertible throughout the optimization process. The result for $\\rho_e=0.1$ shows the effect: the stiffness $0.001999 E_0$ is very small, dominated by the $E_{\\min}$ term (which contributes $0.001 E_0$) but critically, it is not zero.\n\n- **Contrast with Level-Set Formulations**: SIMP is a density-based method where the design variable is a material property field $\\rho_e(x)$ defined over a fixed mesh. This field can contain regions of intermediate density (\"gray\" material), and the penalization scheme is essential to suppress them. In contrast, level-set methods are boundary-based. They represent the structure implicitly via the zero-isocontour of a higher-dimensional function $\\phi(x)$. The domain is partitioned into distinct solid ($\\phi(x)<0$) and void ($\\phi(x)>0$) regions, with a sharp, well-defined boundary. There are no intermediate densities in the material model itself. Therefore, the concept of \"penalizing\" intermediate densities is irrelevant to level-set methods. The optimization in level-set methods evolves the boundary shape to minimize compliance, whereas SIMP evolves a material distribution. Consequently, level-set methods inherently produce crisp, analysis-ready designs but face greater challenges in initiating topological changes (e.g., creating new holes), a task that SIMP handles naturally.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.001999 & 0.125875 & 0.729271\n\\end{pmatrix}\n}\n$$", "id": "2606482"}, {"introduction": "An optimal design is only optimal with respect to a specific goal, and changing that goal can dramatically alter the result. This hands-on coding exercise challenges you to build a simple truss optimizer to directly compare the topologies generated by two different objectives: minimizing compliance (maximizing stiffness) and minimizing the maximum stress [@problem_id:2447108]. Through this practice, you will discover that the stiffest design is not always the one with the most uniform stress distribution, a fundamental insight for any engineering designer.", "problem": "Construct and solve a minimal, self-contained discrete topology optimization problem that compares the material layouts that minimize structural compliance with those that minimize the $p$-norm of the von Mises stress, $\\left( \\int \\sigma_{vM}^p \\, dV \\right)^{1/p}$, in the limit $p \\to \\infty$, using a small truss ground structure. Use nondimensional units throughout; no physical units are required.\n\nConsider a planar truss with $3$ nodes at coordinates $(0,0)$, $(L,0)$, and $(L,H)$, connected by up to $3$ straight bars with indices and connectivity ordered as $[(1\\text{-}2),(2\\text{-}3),(1\\text{-}3)]$. Let node $1$ at $(0,0)$ be fixed in both directions, node $2$ at $(L,0)$ be fixed in the vertical direction only, and node $3$ at $(L,H)$ be free. A downward point load of magnitude $F$ is applied at node $3$ in the vertical direction. The ground structure comprises the three candidate bars connecting the specified node pairs.\n\nUse linear elastic truss modeling with modulus $E>0$. For each bar $e$, define its length $L_e>0$ and direction cosines $(c_e,s_e)$ along its axis. Denote the global displacement vector by $u \\in \\mathbb{R}^{2n}$, where $n=3$ is the number of nodes. The global equilibrium is $K(\\rho)\\,u=f$, where $K(\\rho)$ is the assembled stiffness matrix built from element stiffness contributions\n$$\nK_e(\\rho_e) \\;=\\; \\frac{E A_e(\\rho_e)}{L_e} \n\\begin{bmatrix}\nc_e^2 & c_e s_e & -c_e^2 & -c_e s_e \\\\\nc_e s_e & s_e^2 & -c_e s_e & -s_e^2 \\\\\n- c_e^2 & -c_e s_e & c_e^2 & c_e s_e \\\\\n- c_e s_e & -s_e^2 & c_e s_e & s_e^2\n\\end{bmatrix},\n$$\nand $A_e(\\rho_e)$ is the cross-sectional area of bar $e$ as a function of a design density $\\rho_e \\in [0,1]$ via the Solid Isotropic Material with Penalization (SIMP) mapping\n$$\nA_e(\\rho_e) \\;=\\; A_{\\min} \\;+\\; A_0\\,\\rho_e^{q},\n$$\nwith $A_{\\min}>0$, $A_0>0$, and penalization exponent $q \\ge 1$. The compliance is\n$$\nJ_C(\\rho) \\;=\\; f^\\top u(\\rho),\n$$\nand the von Mises stress in each truss bar equals the absolute axial stress $\\sigma_e(\\rho)= E\\,\\varepsilon_e(\\rho)$, where the axial strain is\n$$\n\\varepsilon_e(\\rho) \\;=\\; \\frac{ \\big( u_j - u_i \\big) \\cdot \\begin{bmatrix} c_e \\\\ s_e \\end{bmatrix} }{L_e},\n$$\nwith $i$ and $j$ being the node indices of element $e$. The $p$-norm objective for stress is\n$$\nJ_{S,p}(\\rho) \\;=\\; \\left( \\sum_{e=1}^{3} \\int_{V_e} \\sigma_e(\\rho)^p \\, dV \\right)^{1/p} \n\\;=\\; \\left( \\sum_{e=1}^{3} \\sigma_e(\\rho)^p \\, A_e(\\rho_e)\\,L_e \\right)^{1/p}.\n$$\nAs $p \\to \\infty$, $J_{S,p}$ converges to the essential supremum of $|\\sigma|$, namely\n$$\nJ_{S,\\infty}(\\rho) \\;=\\; \\max_{e \\in \\{1,2,3\\}} |\\sigma_e(\\rho)|.\n$$\n\nImpose a global volume (material) constraint expressed on the penalized densities:\n$$\n\\sum_{e=1}^{3} \\rho_e^{q} \\;\\le\\; V_f \\cdot 3,\n$$\nwhere $V_f \\in (0,1]$ is the target volume fraction. Use a discrete design set $\\rho_e \\in \\{0, 0.5, 1\\}$ for all $e$, and interpret the final topology by thresholding at $0.5$: a bar is present if and only if $\\rho_e \\ge 0.5$.\n\nYour task is to write a complete, runnable program that, for each test case below, solves two independent discrete optimization problems over the $3^3$ designs satisfying the volume constraint: \n- one that minimizes the compliance $J_C$,\n- one that minimizes $J_{S,\\infty}$,\nand then compares the resulting topologies. In each minimization, break ties by preferring designs with smaller $\\sum_e \\rho_e$ (sparser topology), and then by lexicographic order on $(\\rho_1,\\rho_2,\\rho_3)$. The program must assemble truss stiffness matrices, apply boundary conditions as specified, solve $K(\\rho)\\,u=f$, compute stresses, and evaluate the objectives exactly as defined.\n\nUse the following fixed parameters (nondimensional):\n- $E = 1.0$, $F = 1.0$, $A_{\\min} = 0.05$, $A_0 = 1.0$, $q = 3$.\n- Discrete density levels $\\{0,0.5,1\\}$.\n- Bar order is fixed as $[(1\\text{-}2),(2\\text{-}3),(1\\text{-}3)]$.\n\nProvide the following test suite of three cases to exercise different behaviors:\n- Test $1$: $(L,H,V_f) = (1.0, 1.0, 2/3)$.\n- Test $2$: $(L,H,V_f) = (1.0, 1.0, 1/3)$.\n- Test $3$: $(L,H,V_f) = (1.0, 2.0, 2/3)$.\n\nFor each test case, the required result is a list with three entries:\n- the compliance-minimizing topology as a length-$3$ list of integers $0$ or $1$ in the fixed bar order,\n- the $p \\to \\infty$ stress-minimizing topology as a length-$3$ list of integers $0$ or $1$ in the same order,\n- the Hamming distance between those two topologies (an integer in $\\{0,1,2,3\\}$).\n\nFinal output format: Your program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets, where each test case result is itself a list as described above. For example, a syntactically valid output would have the form\n$[[[1,0,1],[1,1,0],1],[[\\dots],[\\dots],\\dots],[[\\dots],[\\dots],\\dots]]$.", "solution": "The problem statement is valid. It presents a well-defined, self-contained, and scientifically grounded exercise in computational structural optimization. All necessary parameters, governing equations, constraints, and objective functions are specified with clarity and precision, permitting a unique solution via exhaustive evaluation of a discrete design space. The problem is a classic example comparing stiffness-based and stress-based design criteria in topology optimization, a fundamental topic in computational engineering.\n\nWe proceed with the solution. The task is to identify optimal material layouts for a three-bar planar truss structure by minimizing two distinct objective functions: structural compliance ($J_C$) and maximum von Mises stress ($J_{S,\\infty}$). The optimization is performed over a discrete set of design variables, subject to a material volume constraint.\n\nFirst, we establish the analytical framework for the problem.\n\n**1. System Geometry and Kinematics**\n\nThe structure consists of three nodes with coordinates $N_1=(0,0)$, $N_2=(L,0)$, and $N_3=(L,H)$. Three potential bars connect these nodes:\n- Bar 1: connects $N_1$ and $N_2$. Its length is $L_1 = L$. The direction vector is $(L,0)$, so the direction cosines are $(c_1, s_1) = (1, 0)$.\n- Bar 2: connects $N_2$ and $N_3$. Its length is $L_2 = H$. The direction vector is $(0,H)$, so the direction cosines are $(c_2, s_2) = (0, 1)$.\n- Bar 3: connects $N_1$ and $N_3$. Its length is $L_3 = \\sqrt{L^2 + H^2}$. The direction vector is $(L,H)$, so the direction cosines are $(c_3, s_3) = (L/L_3, H/L_3)$.\n\n**2. Finite Element Formulation**\n\nThe system has $n=3$ nodes, each with two translational degrees of freedom (DOFs). This gives a total of $6$ DOFs, represented by the global displacement vector $u = [u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y}]^\\top$. The governing equilibrium equation is $K(\\rho)u = f$.\n\nThe design variables are the densities $\\rho_e$ for each bar $e \\in \\{1,2,3\\}$, where $\\rho_e$ belongs to the discrete set $\\{0, 0.5, 1\\}$. The cross-sectional area of each bar is determined by the Solid Isotropic Material with Penalization (SIMP) rule:\n$$\nA_e(\\rho_e) = A_{\\min} + A_0 \\rho_e^q\n$$\nwhere $A_{\\min} > 0$ is a minimum area to prevent singularity of the stiffness matrix, $A_0$ is the characteristic area, and $q$ is a penalization exponent.\n\nThe global stiffness matrix $K(\\rho)$ is a $6 \\times 6$ matrix assembled from the element stiffness matrices $K_e(\\rho_e)$:\n$$\nK_e(\\rho_e) = \\frac{E A_e(\\rho_e)}{L_e} \n\\begin{bmatrix}\nc_e^2 & c_e s_e & -c_e^2 & -c_e s_e \\\\\nc_e s_e & s_e^2 & -c_e s_e & -s_e^2 \\\\\n-c_e^2 & -c_e s_e & c_e^2 & c_e s_e \\\\\n-c_e s_e & -s_e^2 & c_e s_e & s_e^2\n\\end{bmatrix}\n$$\nThe assembly process maps the local DOFs of each element to the global DOF indices.\n\nBoundary conditions are:\n- Node 1: fixed. $u_{1x} = 0$, $u_{1y} = 0$. (DOFs 1, 2)\n- Node 2: roller support. $u_{2y} = 0$. (DOF 4)\n- Node 3: free.\n\nThe system of equations is solved for the free DOFs: $u_{2x}$ (DOF 3), $u_{3x}$ (DOF 5), and $u_{3y}$ (DOF 6). Let the vector of free displacements be $u_{\\text{free}} = [u_{2x}, u_{3x}, u_{3y}]^\\top$. We partition the global matrix $K$ and force vector $f$ according to free and prescribed DOFs. The reduced linear system is $K_{\\text{red}} u_{\\text{free}} = f_{\\text{red}}$.\n\nThe external load is a point force of magnitude $F$ applied at node 3 in the negative $y$-direction. The global force vector is $f = [0, 0, 0, 0, 0, -F]^\\top$. Consequently, the reduced force vector is $f_{\\text{red}} = [0, 0, -F]^\\top$.\n\nAfter solving for $u_{\\text{free}}$, the full displacement vector $u$ is reconstructed.\n\n**3. Objective Functions and Constraint**\n\nWith the displacements known, we evaluate the two objectives for each design $\\rho = (\\rho_1, \\rho_2, \\rho_3)$:\n\n- **Compliance**: $J_C(\\rho) = f^\\top u(\\rho) = (-F) \\cdot u_{3y}(\\rho)$. Minimizing compliance is equivalent to maximizing global stiffness.\n- **Maximum Stress**: $J_{S,\\infty}(\\rho) = \\max_{e} |\\sigma_e(\\rho)|$. The stress in each bar is $\\sigma_e(\\rho) = E \\varepsilon_e(\\rho)$, where the strain $\\varepsilon_e$ is computed from the nodal displacements:\n$$\n\\varepsilon_e(\\rho) = \\frac{1}{L_e} \\left( (u_{jx}-u_{ix})c_e + (u_{jy}-u_{iy})s_e \\right)\n$$\nfor a bar connecting nodes $i$ and $j$.\n\nThe optimization is subject to the volume constraint:\n$$\n\\sum_{e=1}^{3} \\rho_e^q \\le 3 V_f\n$$\nwhere $V_f$ is the target volume fraction and $q=3$ is the penalization power.\n\n**4. Solution by Enumeration**\n\nThe design space is small, containing $3^3 = 27$ possible designs. We can therefore find the exact optimum by enumerating all designs, filtering them by the volume constraint, and evaluating the objectives for each valid design.\n\nThe algorithm is as follows:\n1. For each test case defined by $(L, H, V_f)$:\n2. Generate the set of all $27$ possible design vectors $\\rho = (\\rho_1, \\rho_2, \\rho_3)$, where $\\rho_e \\in \\{0, 0.5, 1\\}$.\n3. For each design $\\rho$:\n    a. Check if it satisfies the volume constraint $\\sum_{e=1}^{3} \\rho_e^3 \\le 3 V_f$.\n    b. If valid, perform the finite element analysis:\n        i. Assemble the $3 \\times 3$ reduced stiffness matrix $K_{\\text{red}}$.\n        ii. Solve $K_{\\text{red}} u_{\\text{free}} = f_{\\text{red}}$ for $u_{\\text{free}}$.\n        iii. Compute compliance $J_C$ and stresses $\\sigma_e$ for all three bars.\n        iv. Determine the maximum stress $J_{S,\\infty}$.\n    c. Store the objectives and the design vector.\n4. From the set of valid designs, find the optimal designs for each objective function. This is done by sorting all valid designs based on a tuple key. For compliance minimization, the key is $(J_C, \\sum_e \\rho_e, \\rho_1, \\rho_2, \\rho_3)$. For stress minimization, the key is $(J_{S,\\infty}, \\sum_e \\rho_e, \\rho_1, \\rho_2, \\rho_3)$. The first element in the sorted list is the optimum, as it satisfies the primary objective minimization and all subsequent tie-breaking rules.\n5. Convert the optimal density vectors $\\rho^*$ to binary topology vectors where an element exists if $\\rho_e^* \\ge 0.5$.\n6. Compute the Hamming distance between the two resulting topologies.\n7. Format the results as specified for the final output.\n\nThis procedure guarantees finding the true optimal solutions according to the problem definition. The following Python code implements this logic.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a discrete topology optimization problem for a 3-bar truss.\n    Compares topologies from minimizing compliance vs. minimizing max stress.\n    \"\"\"\n    \n    # Fixed parameters\n    E = 1.0\n    F = 1.0\n    A_min = 0.05\n    A0 = 1.0\n    q = 3.0\n    \n    # Discrete design space for rho_e\n    rho_levels = [0.0, 0.5, 1.0]\n\n    # Test cases\n    test_cases = [\n        (1.0, 1.0, 2.0 / 3.0),  # Test 1\n        (1.0, 1.0, 1.0 / 3.0),  # Test 2\n        (1.0, 2.0, 2.0 / 3.0),  # Test 3\n    ]\n\n    # DOF mapping:\n    # Node 1 (0,0): DOFs 0(x), 1(y) - Prescribed (fixed)\n    # Node 2 (L,0): DOFs 2(x), 3(y) - DOF 3 Prescribed (roller)\n    # Node 3 (L,H): DOFs 4(x), 5(y) - Free\n    free_dofs = [2, 4, 5]\n    \n    # Element connectivity to global DOFs\n    elem_dofs = {\n        0: [0, 1, 2, 3], # Bar 1 (1-2)\n        1: [2, 3, 4, 5], # Bar 2 (2-3)\n        2: [0, 1, 4, 5]  # Bar 3 (1-3)\n    }\n\n    all_results = []\n\n    for L, H, Vf in test_cases:\n        # Geometric properties\n        lengths = np.array([L, H, np.sqrt(L**2 + H**2)])\n        cosines = np.array([1.0, 0.0, L / lengths[2]])\n        sines = np.array([0.0, 1.0, H / lengths[2]])\n        \n        # Volume constraint\n        vol_limit = 3.0 * Vf\n        \n        # Generate all 3^3 = 27 designs\n        designs = []\n        for r1 in rho_levels:\n            for r2 in rho_levels:\n                for r3 in rho_levels:\n                    designs.append(np.array([r1, r2, r3]))\n\n        valid_results = []\n\n        for rho in designs:\n            # Check volume constraint\n            if np.sum(rho**q) > vol_limit:\n                continue\n\n            # Calculate element areas\n            areas = A_min + A0 * rho**q\n\n            # Assemble reduced stiffness matrix K_red (3x3 for free DOFs)\n            K_global = np.zeros((6, 6))\n            for e in range(3):\n                Ae, Le, ce, se = areas[e], lengths[e], cosines[e], sines[e]\n                k_const = E * Ae / Le\n                k_mat_local = k_const * np.array([\n                    [ce**2, ce*se, -ce**2, -ce*se],\n                    [ce*se, se**2, -ce*se, -se**2],\n                    [-ce**2, -ce*se, ce**2, ce*se],\n                    [-ce*se, -se**2, ce*se, se**2]\n                ])\n                \n                # Assemble into global matrix\n                global_indices = np.ix_(elem_dofs[e], elem_dofs[e])\n                K_global[global_indices] += k_mat_local\n            \n            K_red = K_global[np.ix_(free_dofs, free_dofs)]\n            \n            # Solve for displacements\n            f_red = np.array([0.0, 0.0, -F])\n            try:\n                u_free = np.linalg.solve(K_red, f_red)\n            except np.linalg.LinAlgError:\n                # Unstable structure, huge compliance/stress, will not be optimal\n                continue\n\n            # Reconstruct full displacement vector\n            u_full = np.zeros(6)\n            u_full[free_dofs] = u_free\n            \n            # --- Calculate objectives ---\n            # 1. Compliance\n            compliance = -F * u_full[5] # f^T u\n\n            # 2. Stresses\n            stresses = np.zeros(3)\n            # Strain e = (1/L) * (u_j - u_i) . (c,s)\n            u_nodes = u_full.reshape((3,2))\n            strains_1 = (1/lengths[0]) * np.dot(u_nodes[1] - u_nodes[0], [cosines[0], sines[0]])\n            stresses[0] = E * strains_1\n            strains_2 = (1/lengths[1]) * np.dot(u_nodes[2] - u_nodes[1], [cosines[1], sines[1]])\n            stresses[1] = E * strains_2\n            strains_3 = (1/lengths[2]) * np.dot(u_nodes[2] - u_nodes[0], [cosines[2], sines[2]])\n            stresses[2] = E * strains_3\n            \n            max_stress = np.max(np.abs(stresses))\n\n            valid_results.append({\n                \"rho\": tuple(rho),\n                \"compliance\": compliance,\n                \"max_stress\": max_stress,\n                \"sum_rho\": np.sum(rho)\n            })\n\n        # --- Find optimal designs ---\n        # Sort for compliance minimization with tie-breaking\n        sorted_C = sorted(valid_results, key=lambda x: (x[\"compliance\"], x[\"sum_rho\"], x[\"rho\"]))\n        opt_rho_C = np.array(sorted_C[0][\"rho\"])\n        \n        # Sort for stress minimization with tie-breaking\n        sorted_S = sorted(valid_results, key=lambda x: (x[\"max_stress\"], x[\"sum_rho\"], x[\"rho\"]))\n        opt_rho_S = np.array(sorted_S[0][\"rho\"])\n\n        # Convert optimal rho to topology (0 or 1)\n        topo_C = (opt_rho_C >= 0.5).astype(int).tolist()\n        topo_S = (opt_rho_S >= 0.5).astype(int).tolist()\n\n        # Calculate Hamming distance\n        hamming_dist = sum(x != y for x, y in zip(topo_C, topo_S))\n\n        # Format result string for this test case\n        result_str = f\"[[{','.join(map(str, topo_C))}],[{','.join(map(str, topo_S))}],{hamming_dist}]\"\n        all_results.append(result_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2447108"}, {"introduction": "Topology optimization algorithms iteratively place material in response to physical fields like strain energy density. This advanced exercise flips the conventional problem on its head: given a final, optimized 2D structure, you must reverse-engineer the physical setup of loads and supports that would naturally produce it [@problem_id:2447126]. This practice requires implementing a 2D finite element analysis and will profoundly deepen your intuition for the powerful interplay between physics and form in computational design.", "problem": "Consider a two-dimensional linear elastic continuum discretized by four-node bilinear quadrilateral elements (Q4) with plane stress assumptions and unit thickness. Let the design domain be a uniform rectangular grid of elements with $n_x$ elements along the horizontal direction and $n_y$ elements along the vertical direction. The nodes have two translational degrees of freedom per node. The material behavior is characterized by Young's modulus $E$ and Poisson's ratio $\\nu$. The material distribution is described by a binary element-wise density field $\\rho_e \\in \\{0,1\\}$, where $\\rho_e = 1$ denotes a solid element and $\\rho_e = 0$ denotes a void element. The global stiffness matrix is assembled using the Solid Isotropic Material with Penalization (SIMP) interpolation: each element stiffness scales linearly with an effective modulus $E_e = E_{\\min} + \\rho_e^p \\left(E_0 - E_{\\min}\\right)$, where $E_0$ is the base modulus, $E_{\\min}$ is a small positive number to regularize voids, and $p \\ge 1$ is the penalization exponent.\n\nFor any given set of boundary conditions (a set of fixed degrees of freedom) and a nodal load vector, let the displacement vector $u$ be the unique solution of the linear equilibrium equation $K(\\rho)\\,u = f$, where $K(\\rho)$ is the global stiffness matrix assembled from the element stiffness matrices and $f$ is the global load vector. For each element $e$, define the reference element stiffness matrix $k_e^{(0)}$ computed with modulus $E_0$ and the corresponding element strain energy (per unit thickness) as $s_e = u_e^\\top k_e^{(0)} u_e$, where $u_e$ is the restriction of $u$ to the degrees of freedom of element $e$.\n\nDefine the following consistency criterion: given a binary density field $\\rho$ with $k$ solid elements (that is, $k = \\sum_e \\rho_e$), a pair consisting of a boundary condition set and a load vector is said to produce the topology $\\rho$ if, when solving equilibrium with $K(\\rho)$ and $f$, the set of the $k$ elements with the largest values of $s_e$ coincides exactly with the set $\\{e : \\rho_e = 1\\}$. In the case of ties in $s_e$, suppose elements are ordered by increasing element index and stable ordering is used for ranking.\n\nYou are given a finite set of candidate boundary condition sets and a finite set of candidate load vectors. For each test case described below, determine which pair (boundary condition index, load index) from the Cartesian product of the candidate sets produces the given topology according to the consistency criterion above. If multiple pairs produce the topology, choose the pair with the smallest indices in lexicographic order (that is, first minimize the boundary condition index, and within that, minimize the load index). If no pair produces the topology, return the pair $[-1,-1]$.\n\nUse the following data for all test cases:\n- Material parameters: base modulus $E_0 = 1$, Poisson's ratio $\\nu = 0.3$, penalization exponent $p = 3$, and regularization modulus $E_{\\min} = 10^{-6}$. All quantities are in consistent arbitrary units. The final outputs are unitless integer indices.\n- Geometry and meshing: the physical domain size is $L_x = n_x$ and $L_y = n_y$ so that each element has size $1 \\times 1$.\n- Element formulation: standard four-node bilinear quadrilateral elements under plane stress with $2 \\times 2$ Gauss integration and unit thickness.\n- Element indexing: elements are indexed as $e = j\\,n_x + i$, where $i \\in \\{0,\\dots,n_x-1\\}$ is the horizontal index and $j \\in \\{0,\\dots,n_y-1\\}$ is the vertical index, with $j = 0$ at the bottom row and increasing upward.\n- Node indexing: nodes are indexed as $n = j\\,(n_x+1) + i$, where $i \\in \\{0,\\dots,n_x\\}$ and $j \\in \\{0,\\dots,n_y\\}$.\n- Degrees of freedom: for node index $n$, the displacement degrees of freedom are $2n$ (horizontal) and $2n+1$ (vertical).\n\nCandidate boundary condition sets (fixed degrees of freedom):\n- Boundary condition $0$: all degrees of freedom on the left edge are fixed, that is, all $u_x$ and $u_y$ for nodes with $i = 0$.\n- Boundary condition $1$: all degrees of freedom on the bottom edge are fixed, that is, all $u_x$ and $u_y$ for nodes with $j = 0$.\n\nCandidate load vectors (each is a unit downward vertical load at a specific node):\n- Load $0$: a unit vertical downward force $-1$ applied at the vertical degree of freedom of the top-right node.\n- Load $1$: a unit vertical downward force $-1$ applied at the vertical degree of freedom of the bottom-right node.\n\nTest suite:\n- Test case $1$: $n_x = 1$, $n_y = 2$, density field $\\rho = [0, 1]$ (bottom element void, top element solid).\n- Test case $2$: $n_x = 1$, $n_y = 2$, density field $\\rho = [1, 0]$ (bottom element solid, top element void).\n- Test case $3$: $n_x = 1$, $n_y = 2$, density field $\\rho = [0, 0]$ (both elements void).\n\nYour program must compute, for each test case, the selected pair $[b,\\ell]$ where $b$ is the boundary condition index and $\\ell$ is the load index, according to the consistency criterion and tie-breaking rule stated above. The final output must be a single line containing the results for all test cases as a comma-separated list of lists in a single pair of square brackets, for example, $[[b_1,\\ell_1],[b_2,\\ell_2],[b_3,\\ell_3]]$. No additional text should be printed.", "solution": "The problem requires the validation of a given material topology against a specified consistency criterion for a set of load cases and boundary conditions. The analysis is grounded in the principles of linear elasticity and the Finite Element Method (FEM). A step-by-step procedure is followed to determine the correct load and boundary condition pair for each test case.\n\nThe governing equation for the static elastic system is the linear matrix equation:\n$$K(\\rho) u = f$$\nwhere $K(\\rho)$ is the global stiffness matrix, which depends on the material density field $\\rho$, $u$ is the vector of nodal displacements, and $f$ is the global nodal load vector.\n\nThe analysis proceeds with the following deterministic steps:\n\n1.  **Element Stiffness Matrix Formulation**: The foundation of the FEM analysis is the element stiffness matrix. For a four-node bilinear quadrilateral (Q4) element under plane stress conditions with unit thickness, the reference stiffness matrix $k_e^{(0)}$ (corresponding to Young's modulus $E_0=1$) is computed. This matrix relates the $8$ nodal displacements of the element to the nodal forces. It is calculated by numerical integration over the element's area:\n    $$k_e^{(0)} = \\int_{A_e} B^\\top D^{(0)} B \\, dA$$\n    Here, $D^{(0)}$ is the plane stress constitutive matrix for $E=E_0=1$ and $\\nu=0.3$. The strain-displacement matrix $B$ is derived from the derivatives of the Q4 shape functions. The integral is evaluated using $2 \\times 2$ Gaussian quadrature as specified. Since all elements possess identical geometry (a $1 \\times 1$ square), this $8 \\times 8$ matrix $k_e^{(0)}$ is pre-computed once and used for all elements.\n\n2.  **Global Stiffness Matrix Assembly**: The global stiffness matrix $K(\\rho)$ for the entire structure is assembled by summing the contributions from all individual element stiffness matrices. For each element $e$, its stiffness matrix $k_e$ is determined by the Solid Isotropic Material with Penalization (SIMP) rule. Given the binary density $\\rho_e \\in \\{0, 1\\}$, the local Young's modulus is $E_e = E_{\\min} + \\rho_e^p (E_0 - E_{\\min})$. Since $p=3$ and $\\rho_e$ is binary, this simplifies to $E_e = E_0$ for solid elements ($\\rho_e=1$) and $E_e = E_{\\min}$ for void elements ($\\rho_e=0$). Thus, the element stiffness is $k_e = E_e \\cdot k_e^{(0)}$. These matrices are then assembled into the global matrix $K$ based on the mesh connectivity.\n\n3.  **Iterative Search and System Solution**: For each test case defined by a mesh ($n_x, n_y$) and a target topology $\\rho$, we iterate through the Cartesian product of candidate boundary conditions (indexed by $b$) and load vectors (indexed by $\\ell$) in lexicographical order. For each pair $(b, \\ell)$:\n    a. The global stiffness matrix $K(\\rho)$ and the load vector $f$ are constructed.\n    b. Boundary conditions are applied by enforcing zero displacement for the specified degrees of freedom (DOFs). This is numerically achieved by partitioning the system into active and fixed DOFs and solving only for the active ones. The reduced system is $K_{aa} u_a = f_a$, where the subscript $a$ denotes active DOFs.\n    c. The system is solved for the displacement vector $u$. If a loaded DOF is also fixed, its displacement is zero, and the resulting structure deformation is null, leading to zero strain energies.\n\n4.  **Consistency Criterion Verification**: After obtaining the displacement field $u$, the consistency criterion is checked.\n    a. For each element $e$, the reference strain energy is computed as $s_e = u_e^\\top k_e^{(0)} u_e$, where $u_e$ is the sub-vector of nodal displacements for that element.\n    b. The number of solid elements, $k = \\sum_e \\rho_e$, is calculated.\n    c. If $k>0$, the elements are ranked in descending order of their strain energy $s_e$. Ties are resolved by favoring the element with the lower index, as per the stable sorting requirement. The set of the top $k$ elements from this ranking is identified.\n    d. This set of high-strain-energy elements is compared to the set of solid elements specified by the input topology $\\rho$. If the two sets are identical, the pair $(b, \\ell)$ is deemed to produce the topology.\n    e. A special case exists for $k=0$ (all elements are void). The set of $0$ elements with the highest strain energy is the empty set. The set of solid elements is also the empty set. As these sets are identical, the criterion is trivially satisfied for any pair $(b, \\ell)$.\n\n5.  **Result Selection**: Due to the lexicographical search order, the first pair $(b, \\ell)$ that satisfies the consistency criterion is selected as the result for the given test case. If no pair satisfies the criterion after checking all possibilities, the result is $[-1, -1]$.\n\nThis systematic procedure is implemented to compute the results for all provided test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the analysis for all test cases.\n    \"\"\"\n    # Global material and method parameters\n    E0 = 1.0\n    NU = 0.3\n    P = 3.0\n    E_MIN = 1e-6\n    \n    # Test cases as defined in the problem statement\n    test_cases = [\n        # (nx, ny, rho)\n        (1, 2, np.array([0, 1])),\n        (1, 2, np.array([1, 0])),\n        (1, 2, np.array([0, 0])),\n    ]\n\n    # Pre-compute the reference element stiffness matrix for a 1x1 element\n    # with E=1, as it is constant for all elements.\n    k_e_0 = get_element_stiffness_matrix(E=E0, nu=NU)\n\n    all_results = []\n    for nx, ny, rho in test_cases:\n        params = {\n            'nx': nx, 'ny': ny, 'rho': rho, \n            'E0': E0, 'NU': NU, 'P': P, 'E_MIN': E_MIN, \n            'k_e_0': k_e_0\n        }\n        result = find_producing_pair(params)\n        all_results.append(result)\n\n    # Format and print the final output exactly as required\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef find_producing_pair(params):\n    \"\"\"\n    Iterates through boundary conditions and load cases to find the first pair\n    that satisfies the consistency criterion for a given topology.\n    \"\"\"\n    bc_indices = [0, 1]\n    load_indices = [0, 1]\n\n    for b in bc_indices:\n        for l in load_indices:\n            if check_consistency(b, l, params):\n                return [b, l]\n    \n    return [-1, -1]\n\ndef check_consistency(b_idx, l_idx, params):\n    \"\"\"\n    Performs a full FEA and checks if the resulting strain energy distribution\n    is consistent with the input topology.\n    \"\"\"\n    nx, ny, rho = params['nx'], params['ny'], params['rho']\n    E0, P, E_MIN = params['E0'], params['P'], params['E_MIN']\n    k_e_0 = params['k_e_0']\n\n    num_elements = nx * ny\n    num_nodes = (nx + 1) * (ny + 1)\n    num_dofs = 2 * num_nodes\n\n    # 1. Assemble Global Stiffness Matrix K\n    K = np.zeros((num_dofs, num_dofs))\n    for e in range(num_elements):\n        rho_e = rho[e]\n        E_e = E_MIN + rho_e**P * (E0 - E_MIN)\n        k_e = E_e * k_e_0\n\n        elem_dofs = get_element_dofs(e, nx)\n        ix = np.ix_(elem_dofs, elem_dofs)\n        K[ix] += k_e\n\n    # 2. Define Load Vector f\n    f = np.zeros(num_dofs)\n    if l_idx == 0:  # Unit vertical downward force at top-right node\n        node_idx = ny * (nx + 1) + nx\n        dof_idx = 2 * node_idx + 1\n        f[dof_idx] = -1.0\n    elif l_idx == 1:  # Unit vertical downward force at bottom-right node\n        node_idx = 0 * (nx + 1) + nx\n        dof_idx = 2 * node_idx + 1\n        f[dof_idx] = -1.0\n\n    # 3. Define Boundary Conditions (fixed DOFs)\n    fixed_dofs = []\n    if b_idx == 0:  # Left edge fixed\n        for j in range(ny + 1):\n            node_idx = j * (nx + 1) + 0\n            fixed_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n    elif b_idx == 1:  # Bottom edge fixed\n        for i in range(nx + 1):\n            node_idx = 0 * (nx + 1) + i\n            fixed_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n\n    # 4. Solve Ku = f by partitioning the system\n    all_dofs = np.arange(num_dofs)\n    active_dofs = np.setdiff1d(all_dofs, fixed_dofs, assume_unique=True)\n    \n    K_reduced = K[np.ix_(active_dofs, active_dofs)]\n    f_reduced = f[active_dofs]\n    \n    try:\n        # Use scipy.linalg.solve for robustness\n        u_reduced = linalg.solve(K_reduced, f_reduced, assume_a='sym')\n    except linalg.LinAlgError:\n        # If the matrix is singular (e.g., unconstrained mechanism),\n        # this combination is physically invalid.\n        return False\n        \n    u = np.zeros(num_dofs)\n    u[active_dofs] = u_reduced\n\n    # 5. Calculate Element Strain Energies\n    strain_energies = np.zeros(num_elements)\n    for e in range(num_elements):\n        elem_dofs = get_element_dofs(e, nx)\n        u_e = u[elem_dofs]\n        s_e = u_e.T @ k_e_0 @ u_e\n        strain_energies[e] = s_e\n\n    # 6. Check Consistency Criterion\n    k = int(np.sum(rho))\n    \n    if k == 0:\n        # Trivial case: set of 0 largest elements is empty, as is the set of solid elements.\n        return True\n\n    # Get indices of elements, sorted by descending strain energy.\n    # kind='stable' ensures that for ties, the original order (by element index) is preserved.\n    sorted_indices = np.argsort(-strain_energies, kind='stable')\n    \n    highest_se_indices = set(sorted_indices[:k])\n    solid_indices = set(np.where(rho == 1)[0])\n    \n    return highest_se_indices == solid_indices\n\ndef get_element_dofs(e, nx):\n    \"\"\"\n    Computes the global DOF indices for a given element index.\n    \"\"\"\n    j = e // nx\n    i = e % nx\n    \n    # Node indices in counter-clockwise order: Bottom-Left, Bottom-Right, Top-Right, Top-Left\n    n1 = j * (nx + 1) + i\n    n2 = j * (nx + 1) + (i + 1)\n    n3 = (j + 1) * (nx + 1) + (i + 1)\n    n4 = (j + 1) * (nx + 1) + i\n    node_indices = [n1, n2, n3, n4]\n    \n    # Each node has 2 DOFs (x, y)\n    dofs = []\n    for n in node_indices:\n        dofs.extend([2 * n, 2 * n + 1])\n    return dofs\n\ndef get_element_stiffness_matrix(E, nu):\n    \"\"\"\n    Computes the 8x8 stiffness matrix for a 2D 4-node plane stress\n    element of size 1x1 using 2x2 Gaussian quadrature.\n    \"\"\"\n    # Plane stress constitutive matrix D\n    D = (E / (1 - nu**2)) * np.array([\n        [1, nu, 0],\n        [nu, 1, 0],\n        [0, 0, (1 - nu) / 2]\n    ])\n\n    # 2x2 Gauss quadrature points and weights\n    gp = 1 / np.sqrt(3)\n    gauss_points = [(-gp, -gp), (gp, -gp), (gp, gp), (-gp, gp)]\n    weights = [1.0, 1.0, 1.0, 1.0]\n\n    k_e = np.zeros((8, 8))\n    \n    # For a 1x1 element, the Jacobian determinant is constant\n    det_J = (1.0/2.0) * (1.0/2.0)\n    \n    for i, (xi, eta) in enumerate(gauss_points):\n        w = weights[i]\n        \n        # Shape function derivatives w.r.t. local coordinates (xi, eta)\n        dNdxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n        dNdeta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n        \n        # Jacobian for a 1x1 element centered at origin\n        # J = [[dx/dxi, dy/dxi], [dx/deta, dy/deta]] = [[0.5, 0], [0, 0.5]]\n        # inv(J) = [[2, 0], [0, 2]]\n        # d/dx = d/dxi * dxi/dx + d/deta * deta/dx = d/dxi * 2\n        # d/dy = d/dxi * dxi/dy + d/deta * deta/dy = d/deta * 2\n        \n        dNdx = 2.0 * dNdxi\n        dNdy = 2.0 * dNdeta\n        \n        # Strain-displacement matrix B\n        B = np.zeros((3, 8))\n        for j in range(4):\n            B[0, 2 * j] = dNdx[j]\n            B[1, 2 * j + 1] = dNdy[j]\n            B[2, 2 * j] = dNdy[j]\n            B[2, 2 * j + 1] = dNdx[j]\n\n        # Integrate: k_e += B.T * D * B * w * det(J) * thickness (t=1)\n        k_e += B.T @ D @ B * w * det_J * 4\n\n    return k_e\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2447126"}]}