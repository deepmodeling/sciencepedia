{"hands_on_practices": [{"introduction": "Many engineering design problems involve fitting one object optimally within another, a task that requires translating geometric intuition into a formal mathematical model. This practice challenges you to find the \"deepest\" point within a polyhedron, defined as the center of the largest possible inscribed ball (the Chebyshev center) [@problem_id:2410361]. You will learn how to convert geometric constraints, like the distance from a point to the boundary hyperplanes, into the linear inequalities required for a linear programming formulation, a fundamental skill in applying optimization to real-world scenarios.", "problem": "Consider the polyhedron $P \\subset \\mathbb{R}^{2}$ defined by the simultaneous linear inequalities\n$$\n-x \\leq 0,\\quad -y \\leq 0,\\quad x \\leq 4,\\quad y \\leq 3,\\quad x + y \\leq 5.\n$$\nA Euclidean ball in $\\mathbb{R}^{2}$ with center $c \\in \\mathbb{R}^{2}$ and radius $r \\geq 0$ is the set $B(c,r) = \\{ z \\in \\mathbb{R}^{2} : \\| z - c \\|_{2} \\leq r \\}$. Determine the exact maximal radius $r^{\\star}$ of any Euclidean ball fully contained in $P$. Express your final answer as a single exact analytic expression (no rounding).", "solution": "The problem as stated is subjected to validation.\n\n**Step 1: Extract Givens**\nThe polyhedron $P \\subset \\mathbb{R}^{2}$ is defined by the following linear inequalities:\n1. $-x \\leq 0$\n2. $-y \\leq 0$\n3. $x \\leq 4$\n4. $y \\leq 3$\n5. $x + y \\leq 5$\n\nThe definition of a Euclidean ball is given as $B(c,r) = \\{ z \\in \\mathbb{R}^{2} : \\| z - c \\|_{2} \\leq r \\}$ for a center $c \\in \\mathbb{R}^{2}$ and radius $r \\geq 0$.\n\nThe objective is to find the maximal radius $r^{\\star}$ of a Euclidean ball that is fully contained within $P$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is a well-defined mathematical optimization problem. It is scientifically grounded in the fields of convex geometry and linear programming. The polyhedron $P$ is a convex, compact set (a pentagon) in $\\mathbb{R}^{2}$ with a non-empty interior, as the point $(1,1)$ satisfies all inequalities. The task of finding the largest inscribed ball (the Chebyshev center) in a compact convex set is a classic, well-posed problem with a unique solution for the radius. The problem statement is objective, complete, and contains no contradictions or ambiguities.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n**Solution**\nThe problem is to find the maximal radius $r^{\\star}$ of a Euclidean ball $B(c, r)$ such that $B(c, r) \\subseteq P$. The polyhedron $P$ is an intersection of five closed half-planes. Let these half-planes be $H_i = \\{ z \\in \\mathbb{R}^2 : a_i^T z \\leq b_i \\}$ for $i=1, \\dots, 5$.\nThe defining inequalities can be written in the form $a_i^T z \\leq b_i$, where $z = \\begin{pmatrix} x \\\\ y \\end{pmatrix}$:\n1. $H_1$: $-x \\leq 0 \\implies \\begin{pmatrix} -1 & 0 \\end{pmatrix} z \\leq 0$. So, $a_1 = \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix}$, $b_1 = 0$.\n2. $H_2$: $-y \\leq 0 \\implies \\begin{pmatrix} 0 & -1 \\end{pmatrix} z \\leq 0$. So, $a_2 = \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix}$, $b_2 = 0$.\n3. $H_3$: $x \\leq 4 \\implies \\begin{pmatrix} 1 & 0 \\end{pmatrix} z \\leq 4$. So, $a_3 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$, $b_3 = 4$.\n4. $H_4$: $y \\leq 3 \\implies \\begin{pmatrix} 0 & 1 \\end{pmatrix} z \\leq 3$. So, $a_4 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$, $b_4 = 3$.\n5. $H_5$: $x+y \\leq 5 \\implies \\begin{pmatrix} 1 & 1 \\end{pmatrix} z \\leq 5$. So, $a_5 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$, $b_5 = 5$.\n\nA ball $B(c, r)$ is contained in a half-plane $a^T z \\leq b$ if and only if its center $c$ is in the half-plane and the distance from $c$ to the boundary hyperplane $a^T z = b$ is at least $r$. This condition is expressed as $a^T c + r \\|a\\|_2 \\leq b$.\n\nTo ensure $B(c, r) \\subseteq P$, this condition must hold for all five inequalities. Let $c = \\begin{pmatrix} c_x \\\\ c_y \\end{pmatrix}$. We first compute the Euclidean norms of the vectors $a_i$:\n$\\|a_1\\|_2 = \\| \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix} \\|_2 = 1$.\n$\\|a_2\\|_2 = \\| \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix} \\|_2 = 1$.\n$\\|a_3\\|_2 = \\| \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\|_2 = 1$.\n$\\|a_4\\|_2 = \\| \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} \\|_2 = 1$.\n$\\|a_5\\|_2 = \\| \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\|_2 = \\sqrt{1^2 + 1^2} = \\sqrt{2}$.\n\nThe conditions for the ball to be contained in $P$ become a system of inequalities for $c_x$, $c_y$, and $r$:\n1. $a_1^T c + r\\|a_1\\|_2 \\leq b_1 \\implies -c_x + r \\leq 0 \\implies r \\leq c_x$.\n2. $a_2^T c + r\\|a_2\\|_2 \\leq b_2 \\implies -c_y + r \\leq 0 \\implies r \\leq c_y$.\n3. $a_3^T c + r\\|a_3\\|_2 \\leq b_3 \\implies c_x + r \\leq 4 \\implies r \\leq 4 - c_x$.\n4. $a_4^T c + r\\|a_4\\|_2 \\leq b_4 \\implies c_y + r \\leq 3 \\implies r \\leq 3 - c_y$.\n5. $a_5^T c + r\\|a_5\\|_2 \\leq b_5 \\implies c_x + c_y + r\\sqrt{2} \\leq 5 \\implies r\\sqrt{2} \\leq 5 - c_x - c_y$.\n\nThe problem is now to find the maximum value of $r \\geq 0$ for which there exists a center $(c_x, c_y)$ satisfying these five inequalities. This is a linear programming problem.\nWe can analyze the feasible set for $(c_x, c_y)$ given a fixed $r$. From the inequalities, we have:\n$r \\leq c_x \\leq 4 - r$\n$r \\leq c_y \\leq 3 - r$\n$c_x + c_y \\leq 5 - r\\sqrt{2}$\n\nFor a feasible center $(c_x, c_y)$ to exist, the intervals for $c_x$ and $c_y$ must be non-empty. This requires:\n$r \\leq 4 - r \\implies 2r \\leq 4 \\implies r \\leq 2$.\n$r \\leq 3 - r \\implies 2r \\leq 3 \\implies r \\leq 1.5$.\nSo, we must have $r \\leq 1.5$.\n\nLet $C_r$ be the set of feasible centers $(c_x, c_y)$ for a given radius $r$. $C_r$ is the intersection of the rectangular region $R_r = [r, 4-r] \\times [r, 3-r]$ and the half-plane $c_x + c_y \\leq 5 - r\\sqrt{2}$. For $C_r$ to be non-empty, the point in $R_r$ that minimizes the function $f(c_x, c_y) = c_x + c_y$ must satisfy the fifth inequality. This point is $(c_x, c_y) = (r, r)$.\nSubstituting this point into the inequality gives the necessary condition for $C_r$ to be non-empty:\n$r + r \\leq 5 - r\\sqrt{2}$\n$2r \\leq 5 - r\\sqrt{2}$\n$r(2 + \\sqrt{2}) \\leq 5$\n$r \\leq \\frac{5}{2 + \\sqrt{2}}$\n\nTo find the maximal radius $r^{\\star}$, we must satisfy all derived upper bounds on $r$:\n$r \\leq 1.5$ and $r \\leq \\frac{5}{2 + \\sqrt{2}}$.\nLet's compare these two bounds.\n$\\frac{5}{2 + \\sqrt{2}} = \\frac{5(2 - \\sqrt{2})}{(2 + \\sqrt{2})(2 - \\sqrt{2})} = \\frac{5(2 - \\sqrt{2})}{4 - 2} = \\frac{5(2 - \\sqrt{2})}{2} = 5 - \\frac{5}{2}\\sqrt{2}$.\nWe check if $5 - \\frac{5}{2}\\sqrt{2} \\leq 1.5 = \\frac{3}{2}$.\n$10 - 5\\sqrt{2} \\leq 3 \\implies 7 \\leq 5\\sqrt{2} \\implies 49 \\leq 25 \\times 2 = 50$.\nThe inequality is true. Therefore, the more restrictive condition is $r \\leq \\frac{5}{2 + \\sqrt{2}}$.\n\nThe maximal radius is thus $r^{\\star} = \\frac{5}{2 + \\sqrt{2}}$.\nAt this radius, the feasible set of centers $C_{r^{\\star}}$ shrinks to a single point. The condition $r(2+\\sqrt{2}) \\leq 5$ becomes an equality, $r^{\\star}(2+\\sqrt{2}) = 5$, which implies that the center must be $c_x = c_y = r^{\\star}$.\nThe optimal center is $c^{\\star} = (r^{\\star}, r^{\\star})$. This center is equidistant from the three lines $x=0$, $y=0$, and $x+y=5$. The other two constraints, $c_x+r \\leq 4$ and $c_y+r \\leq 3$, are satisfied, as $2r^{\\star} < 3 < 4$.\nThe final expression for the maximal radius is:\n$r^{\\star} = \\frac{5}{2 + \\sqrt{2}} = \\frac{5(2 - \\sqrt{2})}{2}$.", "answer": "$$\\boxed{\\frac{5(2-\\sqrt{2})}{2}}$$", "id": "2410361"}, {"introduction": "Network optimization is a cornerstone of computational engineering, with applications ranging from logistics and supply chains to data routing and circuit design. This exercise explores the celebrated max-flow min-cut theorem through the powerful framework of linear programming [@problem_id:2410395]. Your task is not only to formulate the problem of maximizing flow through a network but also to derive its dual LP, revealing its profound and elegant connection to the seemingly separate problem of finding a minimum-capacity cut.", "problem": "Consider a directed network (graph) with node set $V=\\{v_1,v_2,v_3,v_4,v_5,v_6\\}$, source $s=v_1$, and sink $t=v_6$. Each directed arc $(i,j)$ has a nonnegative capacity $c_{ij}$. The nonzero capacities are:\n- $v_1 \\to v_2$ has $c_{12}=7$, $v_1 \\to v_3$ has $c_{13}=3$, $v_1 \\to v_4$ has $c_{14}=4$.\n- $v_2 \\to v_3$ has $c_{23}=2$, $v_2 \\to v_4$ has $c_{24}=3$, $v_2 \\to v_5$ has $c_{25}=5$.\n- $v_3 \\to v_4$ has $c_{34}=4$, $v_3 \\to v_5$ has $c_{35}=6$, $v_3 \\to v_6$ has $c_{36}=2$.\n- $v_4 \\to v_5$ has $c_{45}=2$, $v_4 \\to v_6$ has $c_{46}=5$.\n- $v_5 \\to v_6$ has $c_{56}=8$.\n\nUsing first-principles definitions of flows and cuts on directed networks, do the following in the framework of Linear Programming (LP):\n1) Formulate the Maximum $s$–$t$ Flow LP model for this network by specifying decision variables, objective function, and all constraints.\n2) Derive the LP dual of your maximum flow formulation and interpret the dual in terms of a Minimum $s$–$t$ Cut LP, making the correspondence between dual variables and the cut structure explicit.\n3) Determine the capacity of a minimum $s$–$t$ cut for this network.\n\nAnswer specification: Report only the minimum $s$–$t$ cut capacity as a single real number. No rounding is required, and no units are involved.", "solution": "The problem as stated is scientifically grounded, well-posed, objective, and self-contained. It is a standard problem in the field of computational engineering, specifically network optimization, which is a sub-field of linear programming and polyhedral geometry. No flaws are identified. We may proceed with the solution.\n\nThe problem requires a three-part analysis of a given directed network: formulation of the maximum flow problem as a Linear Program (LP), derivation and interpretation of its dual, and determination of the minimum cut capacity.\n\nLet the set of nodes be $V = \\{1, 2, 3, 4, 5, 6\\}$, with source $s=1$ and sink $t=6$. The set of directed arcs is denoted by $E$. For each arc $(i,j) \\in E$, there is a given capacity $c_{ij} \\ge 0$.\n\n**1. Maximum $s$–$t$ Flow LP Formulation**\n\nWe define the decision variables and formulate the LP model as follows.\nDecision Variables: Let $x_{ij}$ represent the amount of flow on the arc $(i,j) \\in E$. These variables must be non-negative.\nObjective Function: The goal is to maximize the total flow leaving the source node $s$. This value, denoted by $F$, is equivalent to the sum of flows on all arcs originating from $s$.\n$$ \\text{Maximize } F = x_{12} + x_{13} + x_{14} $$\nConstraints: The flow must adhere to two types of constraints.\n-Capacity Constraints: The flow on any arc $(i,j)$ cannot exceed its capacity $c_{ij}$.\n-Flow Conservation Constraints: For any node $i \\in V \\setminus \\{s,t\\}$ (an intermediate node), the total flow entering the node must equal the total flow exiting the node.\n$$ \\sum_{k:(k,i) \\in E} x_{ki} = \\sum_{j:(i,j) \\in E} x_{ij} \\quad \\text{for } i \\in \\{2, 3, 4, 5\\} $$\nThe complete LP formulation for the given network is:\n$$ \\text{Maximize } x_{12} + x_{13} + x_{14} $$\nSubject to:\n- Flow Conservation:\n$$ (x_{23} + x_{24} + x_{25}) - x_{12} = 0 \\quad (\\text{Node } 2) $$\n$$ (x_{34} + x_{35} + x_{36}) - x_{13} - x_{23} = 0 \\quad (\\text{Node } 3) $$\n$$ (x_{45} + x_{46}) - x_{14} - x_{24} - x_{34} = 0 \\quad (\\text{Node } 4) $$\n$$ x_{56} - (x_{25} + x_{35} + x_{45}) = 0 \\quad (\\text{Node } 5) $$\n- Capacity Constraints:\n$$ 0 \\le x_{12} \\le 7 $$\n$$ 0 \\le x_{13} \\le 3 $$\n$$ 0 \\le x_{14} \\le 4 $$\n$$ 0 \\le x_{23} \\le 2 $$\n$$ 0 \\le x_{24} \\le 3 $$\n$$ 0 \\le x_{25} \\le 5 $$\n$$ 0 \\le x_{34} \\le 4 $$\n$$ 0 \\le x_{35} \\le 6 $$\n$$ 0 \\le x_{36} \\le 2 $$\n$$ 0 \\le x_{45} \\le 2 $$\n$$ 0 \\le x_{46} \\le 5 $$\n$$ 0 \\le x_{56} \\le 8 $$\n\n**2. LP Dual and Interpretation as Minimum Cut**\n\nThe dual of the maximum flow LP can be formulated in terms of a potential $p_i$ for each node $i$ and a variable $z_{ij}$ for each arc $(i,j)$.\nDual (D):\n$$ \\text{minimize } \\sum_{(i,j)\\in E} c_{ij} z_{ij} $$\nsubject to:\n$$ p_i - p_j + z_{ij} \\ge 0 \\quad \\forall (i,j) \\in E $$\n$$ p_6 - p_1 \\ge 1 $$\n$$ z_{ij} \\ge 0 \\quad \\forall (i,j) \\in E $$\nThis dual LP has a profound interpretation: it is an LP formulation of the minimum $s-t$ cut problem. An $s-t$ cut is a partition of the vertex set $V$ into two disjoint sets, $S$ and $T$, such that $s \\in S$ and $t \\in T$. The capacity of the cut $(S,T)$ is $\\sum_{i \\in S, j \\in T, (i,j) \\in E} c_{ij}$. The max-flow min-cut theorem states that the value of the maximum flow is equal to the capacity of a minimum cut. This is a consequence of LP strong duality.\nThe dual variables $p_i$ can be thought of as defining the cut. For an optimal solution to the dual, the potentials will partition the nodes into two sets, corresponding to the $S$ and $T$ sets of a minimum cut. Due to the total unimodularity of the constraint matrix of the max-flow LP, the LP relaxation for the min-cut problem (which this dual represents) has an integral optimal solution, meaning it finds the true minimum cut.\n\n**3. Determination of the Minimum $s$–$t$ Cut Capacity**\n\nBy the max-flow min-cut theorem, the capacity of the minimum $s-t$ cut is equal to the value of the maximum $s-t$ flow. We can find this value by constructing a valid flow and demonstrating that it is maximal, or by identifying a cut and demonstrating it is minimal.\n\nConsider the cut $(S,T)$ where $S=\\{v_1\\}$ and $T=\\{v_2, v_3, v_4, v_5, v_6\\}$. The arcs that cross this cut from $S$ to $T$ are $(v_1, v_2)$, $(v_1, v_3)$, and $(v_1, v_4)$.\nThe capacity of this cut is:\n$$ C(S,T) = c_{12} + c_{13} + c_{14} = 7 + 3 + 4 = 14 $$\nNow, we must show that a flow of value $14$ is achievable. If a flow of value $14$ exists, then by the weak duality property of the max-flow min-cut problem (max flow $\\le$ min cut), this flow must be maximal and this cut must be minimal.\n\nWe construct a flow of value $14$:\n1.  From source $v_1$: send flow $x_{12}=7$, $x_{13}=3$, $x_{14}=4$. This saturates all outgoing arcs from the source. The total flow is $7+3+4=14$.\n2.  At node $v_2$: Inflow is $x_{12}=7$. We must route this flow onwards. Let $x_{25}=5$ (saturating the arc capacity) and $x_{24}=2$ (using part of $c_{24}=3$). The outflow is $5+2=7$. This is conserved.\n3.  At node $v_3$: Inflow is $x_{13}=3$. Let $x_{36}=2$ (saturating the arc capacity) and $x_{35}=1$ (using part of $c_{35}=6$). The outflow is $2+1=3$. This is conserved.\n4.  At node $v_4$: Inflow is $x_{14}+x_{24} = 4+2=6$. Let $x_{46}=5$ (saturating the arc capacity) and $x_{45}=1$ (using part of $c_{45}=2$). The outflow is $5+1=6$. This is conserved.\n5.  At node $v_5$: Inflow is $x_{25}+x_{35}+x_{45} = 5+1+1=7$. Let $x_{56}=7$ (using part of $c_{56}=8$). The outflow is $7$. This is conserved.\n6.  To sink $v_6$: Inflow is $x_{36}+x_{46}+x_{56} = 2+5+7=14$. This matches the total flow sent from the source.\n\nAll flow conservation and capacity constraints are met. We have constructed a valid flow with a total value of $14$.\nSince we have found a flow of value $14$ and a cut of capacity $14$, the maximum flow is $14$ and the minimum cut capacity is also $14$.", "answer": "$$\n\\boxed{14}\n$$", "id": "2410395"}, {"introduction": "While standard linear programs operate on continuous variables, many real-world decisions are discrete or binary. This computational practice guides you through the world of integer programming by tackling the classic minimum vertex cover problem [@problem_id:2410323]. By implementing and solving the problem's integer formulation, its linear programming relaxation, and the corresponding dual, you will gain hands-on experience with the critical concept of the \"integrality gap\" and its direct relationship to graph structure, a key theme in advanced combinatorial optimization.", "problem": "Construct a program that, for each given simple undirected graph, computes the optimal objective values of three closely related optimization models and compares them. Let the vertex set be indexed as $V=\\{0,1,\\dots,n-1\\}$ and the edge set be $E\\subseteq \\{\\{u,v\\}\\mid u,v\\in V, u\\neq v\\}$. Consider the following three models defined for a graph $G=(V,E)$:\n\n1. Integer Linear Programming (ILP) model for minimum vertex cover:\n   Minimize $\\sum_{i\\in V} x_i$ subject to $x_u + x_v \\ge 1$ for all $\\{u,v\\}\\in E$, and $x_i \\in \\{0,1\\}$ for all $i\\in V$.\n\n2. Linear Programming (LP) relaxation of the minimum vertex cover:\n   Minimize $\\sum_{i\\in V} x_i$ subject to $x_u + x_v \\ge 1$ for all $\\{u,v\\}\\in E$, and $0 \\le x_i \\le 1$ for all $i\\in V$.\n\n3. Dual LP (fractional matching):\n   Maximize $\\sum_{e\\in E} y_e$ subject to $\\sum_{e\\ni v} y_e \\le 1$ for all $v\\in V$, and $y_e \\ge 0$ for all $e\\in E$.\n\nFor each graph in the test suite below, your program must compute:\n- $s_{\\mathrm{int}}$, the optimal objective value of the ILP (minimum vertex cover size).\n- $s_{\\mathrm{lp}}$, the optimal objective value of the LP relaxation.\n- $m_{\\mathrm{frac}}$, the optimal objective value of the dual LP (fractional matching).\n- A boolean $b_{\\mathrm{dual}}$ indicating whether $|s_{\\mathrm{lp}}-m_{\\mathrm{frac}}| \\le 10^{-6}$ holds.\n- A boolean $b_{\\mathrm{int}}$ indicating whether $|s_{\\mathrm{int}}-s_{\\mathrm{lp}}| \\le 10^{-6}$ holds.\n- A boolean $b_{\\mathrm{bip}}$ indicating whether the graph is bipartite.\n\nYour program must use the following test suite of graphs, each given by the number of vertices $n$ and the list of edges $E$ as unordered pairs:\n- Test $1$ (bipartite, complete bipartite $K_{2,3}$): $n=5$, $E=\\{\\{0,2\\},\\{0,3\\},\\{0,4\\},\\{1,2\\},\\{1,3\\},\\{1,4\\}\\}$.\n- Test $2$ (non-bipartite odd cycle $C_3$): $n=3$, $E=\\{\\{0,1\\},\\{1,2\\},\\{2,0\\}\\}$.\n- Test $3$ (empty graph): $n=4$, $E=\\emptyset$.\n- Test $4$ (single edge with an isolated vertex): $n=3$, $E=\\{\\{0,1\\}\\}$.\n\nRequirements for numerical outputs:\n- All floating-point values must be rounded to exactly three digits after the decimal point using standard rounding rules.\n- There are no physical units involved.\n- Any equality comparisons between floating-point values must use the tolerance $10^{-6}$ as specified above.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a list of lists, in the order of the tests above. For each test, output the list $[s_{\\mathrm{int}}, s_{\\mathrm{lp}}, m_{\\mathrm{frac}}, b_{\\mathrm{dual}}, b_{\\mathrm{int}}, b_{\\mathrm{bip}}]$.\n- The overall output must be a single line representing a list of these per-test lists, for example $[[a_1,b_1,c_1,d_1,e_1,f_1],[a_2,b_2,c_2,d_2,e_2,f_2],\\dots]$, where $a_i$ and $b_i$ are integers or floats, and $d_i,e_i,f_i$ are booleans.\n\nDesign for coverage:\n- Test $1$ exercises a bipartite graph where the ILP and LP optima coincide.\n- Test $2$ exercises a non-bipartite graph where the LP relaxation may be strictly smaller than the ILP optimum.\n- Test $3$ is a boundary case with no edges.\n- Test $4$ is a minimal connected case with a single edge.", "solution": "We begin from first principles. A vertex cover of a graph $G=(V,E)$ is a set $C\\subseteq V$ such that every edge $\\{u,v\\}\\in E$ has at least one endpoint in $C$. The minimum vertex cover problem seeks to minimize $|C|$ over all such $C$. This is naturally expressed as an Integer Linear Programming (ILP) model by introducing binary decision variables $x_i$ for each vertex $i\\in V$, where $x_i=1$ if $i\\in C$ and $x_i=0$ otherwise. The covering condition for each edge $\\{u,v\\}\\in E$ is $x_u + x_v \\ge 1$. Thus the ILP is:\n$$\n\\begin{aligned}\n\\min \\quad & \\sum_{i\\in V} x_i \\\\\n\\text{s.t.} \\quad & x_u + x_v \\ge 1 \\quad \\forall \\{u,v\\}\\in E, \\\\\n& x_i \\in \\{0,1\\} \\quad \\forall i\\in V.\n\\end{aligned}\n$$\nThe Linear Programming (LP) relaxation replaces the integrality constraints by bounds $0\\le x_i \\le 1$:\n$$\n\\begin{aligned}\n\\min \\quad & \\sum_{i\\in V} x_i \\\\\n\\text{s.t.} \\quad & x_u + x_v \\ge 1 \\quad \\forall \\{u,v\\}\\in E, \\\\\n& 0 \\le x_i \\le 1 \\quad \\forall i\\in V.\n\\end{aligned}\n$$\nThe dual LP corresponding to this relaxation is the fractional matching problem. Introduce dual variables $y_e$ for each edge $e\\in E$, and obtain:\n$$\n\\begin{aligned}\n\\max \\quad & \\sum_{e\\in E} y_e \\\\\n\\text{s.t.} \\quad & \\sum_{e\\ni v} y_e \\le 1 \\quad \\forall v\\in V, \\\\\n& y_e \\ge 0 \\quad \\forall e\\in E.\n\\end{aligned}\n$$\nBy Linear Programming duality, the optimal objective values of the LP relaxation and the fractional matching dual are equal under feasibility and boundedness of both problems. This expresses the polyhedral relation that the vertex cover polytope’s LP relaxation and the matching polytope’s LP relaxation are dual.\n\nFor bipartite graphs, the node-edge incidence matrix is totally unimodular, which implies that the LP relaxation of the vertex cover has integral extreme points. Consequently, for bipartite graphs, the ILP optimum equals the LP optimum, which also equals the optimum of the fractional matching dual, aligning with Kőnig’s theorem. For non-bipartite graphs, the LP relaxation may yield a strictly smaller value than the ILP optimum, reflecting an integrality gap.\n\nAlgorithmic design to compute the required outputs proceeds as follows:\n- Compute $s_{\\mathrm{int}}$ exactly by evaluating the ILP over all subsets $C\\subseteq V$ in increasing order of cardinality until a vertex cover is found; correctness follows directly from the definition of a vertex cover and the minimization of $|C|$.\n- Compute $s_{\\mathrm{lp}}$ by solving the LP relaxation. To put it in standard inequality form for a numerical solver, rewrite $x_u + x_v \\ge 1$ as $-x_u - x_v \\le -1$, with bounds $0\\le x_i \\le 1$.\n- Compute $m_{\\mathrm{frac}}$ by solving the dual LP. To accommodate a minimization solver, maximize $\\sum y_e$ by minimizing $-\\sum y_e$, subject to $\\sum_{e\\ni v} y_e \\le 1$ and $y_e \\ge 0$.\n- Compute $b_{\\mathrm{dual}}$ by checking if $|s_{\\mathrm{lp}} - m_{\\mathrm{frac}}| \\le 10^{-6}$, as implied by strong duality for feasible and bounded instances.\n- Compute $b_{\\mathrm{int}}$ by checking if $|s_{\\mathrm{int}} - s_{\\mathrm{lp}}| \\le 10^{-6}$.\n- Compute $b_{\\mathrm{bip}}$ by a two-coloring breadth-first search test for bipartiteness.\n\nWe now apply this to the test suite.\n\nTest $1$: $K_{2,3}$ with $n=5$ and $E=\\{\\{0,2\\},\\{0,3\\},\\{0,4\\},\\{1,2\\},\\{1,3\\},\\{1,4\\}\\}$.\n- A minimum vertex cover is $\\{0,1\\}$ of size $|C|=2$, so $s_{\\mathrm{int}}=2$.\n- The LP relaxation has an integral optimal solution with the same value in bipartite graphs; thus $s_{\\mathrm{lp}}=2.0$.\n- The maximum matching has size $2$ in $K_{2,3}$, and the fractional matching optimum equals this value; hence $m_{\\mathrm{frac}}=2.0$.\n- Therefore $b_{\\mathrm{dual}}=\\text{True}$, $b_{\\mathrm{int}}=\\text{True}$, and $b_{\\mathrm{bip}}=\\text{True}$.\n\nTest $2$: $C_3$ with $n=3$ and $E=\\{\\{0,1\\},\\{1,2\\},\\{2,0\\}\\}$.\n- A minimum vertex cover has size $2$, so $s_{\\mathrm{int}}=2$.\n- The LP relaxation admits $x_0=x_1=x_2=\\tfrac{1}{2}$ with objective $\\tfrac{3}{2}$, which is optimal; thus $s_{\\mathrm{lp}}=1.5$.\n- The fractional matching sets $y_{\\{0,1\\}}=y_{\\{1,2\\}}=y_{\\{2,0\\}}=\\tfrac{1}{2}$ with objective $\\tfrac{3}{2}$, so $m_{\\mathrm{frac}}=1.5$.\n- Therefore $b_{\\mathrm{dual}}=\\text{True}$, $b_{\\mathrm{int}}=\\text{False}$, and $b_{\\mathrm{bip}}=\\text{False}$.\n\nTest $3$: Empty graph with $n=4$ and $E=\\emptyset$.\n- The empty set is a vertex cover, so $s_{\\mathrm{int}}=0$.\n- The LP relaxation has the zero solution with objective $0$, so $s_{\\mathrm{lp}}=0.0$.\n- The fractional matching has no edges and objective $0$, so $m_{\\mathrm{frac}}=0.0$.\n- Therefore $b_{\\mathrm{dual}}=\\text{True}$, $b_{\\mathrm{int}}=\\text{True}$, and $b_{\\mathrm{bip}}=\\text{True}$.\n\nTest $4$: Single edge with $n=3$ and $E=\\{\\{0,1\\}\\}$.\n- A minimum vertex cover has size $1$, so $s_{\\mathrm{int}}=1$.\n- The LP relaxation also has value $1.0$; thus $s_{\\mathrm{lp}}=1.0$.\n- The fractional matching sets $y_{\\{0,1\\}}=1$ with objective $1$, so $m_{\\mathrm{frac}}=1.0$.\n- Therefore $b_{\\mathrm{dual}}=\\text{True}$, $b_{\\mathrm{int}}=\\text{True}$, and $b_{\\mathrm{bip}}=\\text{True}$.\n\nWith floats rounded to three decimals, the per-test lists are $[2,2.000,2.000,\\text{True},\\text{True},\\text{True}]$, $[2,1.500,1.500,\\text{True},\\text{False},\\text{False}]$, $[0,0.000,0.000,\\text{True},\\text{True},\\text{True}]$, and $[1,1.000,1.000,\\text{True},\\text{True},\\text{True}]$. The program must compute these values generically from the definitions and produce them in a single-line list of lists as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import combinations, product, chain\nfrom collections import deque\n\nTOL = 1e-6\n\ndef is_bipartite(n, edges):\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    color = [None] * n\n    for s in range(n):\n        if color[s] is None:\n            color[s] = 0\n            q = deque([s])\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if color[v] is None:\n                        color[v] = 1 - color[u]\n                        q.append(v)\n                    elif color[v] == color[u]:\n                        return False\n    return True\n\ndef min_vertex_cover_integer(n, edges):\n    # Brute-force exact solution by increasing cardinality subsets\n    # Early exit once a cover is found\n    edge_list = edges\n    if not edge_list:\n        return 0\n    # Precompute for fast checking\n    for k in range(n + 1):\n        for subset in combinations(range(n), k):\n            subset_set = set(subset)\n            ok = True\n            for (u, v) in edge_list:\n                if (u not in subset_set) and (v not in subset_set):\n                    ok = False\n                    break\n            if ok:\n                return k\n    return n  # fallback, full set is always a cover\n\ndef lp_vertex_cover_value(n, edges):\n    # Minimize sum x_i subject to x_u + x_v >= 1, 0 = x_i = 1\n    c = np.ones(n, dtype=float)\n    m = len(edges)\n    if m == 0:\n        return 0.0\n    A = np.zeros((m, n), dtype=float)\n    b = np.full(m, -1.0, dtype=float)\n    for idx, (u, v) in enumerate(edges):\n        A[idx, u] = -1.0\n        A[idx, v] = -1.0\n    bounds = [(0.0, 1.0)] * n\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method=\"highs\")\n    if not res.success:\n        raise RuntimeError(\"LP vertex cover did not converge\")\n    val = float(res.fun)\n    # Clean small negative zeros\n    if abs(val)  1e-12:\n        val = 0.0\n    return val\n\ndef fractional_matching_value(n, edges):\n    # Maximize sum y_e subject to sum_{e incident to v} y_e = 1, y_e >= 0\n    m = len(edges)\n    if m == 0:\n        return 0.0\n    c = -np.ones(m, dtype=float)  # maximize -> minimize negative\n    A = np.zeros((n, m), dtype=float)\n    b = np.ones(n, dtype=float)\n    for j, (u, v) in enumerate(edges):\n        A[u, j] += 1.0\n        A[v, j] += 1.0\n    bounds = [(0.0, None)] * m\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method=\"highs\")\n    if not res.success:\n        raise RuntimeError(\"Fractional matching LP did not converge\")\n    val = -float(res.fun)\n    if abs(val)  1e-12:\n        val = 0.0\n    return val\n\ndef format_float(x):\n    return f\"{x:.3f}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (n, edges)\n    test_cases = [\n        (5, [(0,2),(0,3),(0,4),(1,2),(1,3),(1,4)]),           # K_{2,3}\n        (3, [(0,1),(1,2),(2,0)]),                             # C3\n        (4, []),                                              # Empty graph\n        (3, [(0,1)]),                                         # Single edge with isolated vertex\n    ]\n\n    per_case_outputs = []\n    for n, edges in test_cases:\n        # Normalize edges as unordered pairs (u  v)\n        norm_edges = []\n        for u, v in edges:\n            if u == v:\n                continue\n            a, b = (u, v) if u  v else (v, u)\n            norm_edges.append((a, b))\n        # Remove duplicates if any\n        norm_edges = list(dict.fromkeys(norm_edges).keys()) if hasattr(dict, \"fromkeys\") else list(set(norm_edges))\n        # Compute required quantities\n        s_int = min_vertex_cover_integer(n, norm_edges)\n        s_lp = lp_vertex_cover_value(n, norm_edges)\n        m_frac = fractional_matching_value(n, norm_edges)\n        b_dual = abs(s_lp - m_frac) = TOL\n        b_int = abs(s_int - s_lp) = TOL\n        b_bip = is_bipartite(n, norm_edges)\n        # Prepare string for this case: [s_int, s_lp, m_frac, b_dual, b_int, b_bip]\n        case_str = f\"[{s_int},{format_float(s_lp)},{format_float(m_frac)},{str(b_dual).lower()},{str(b_int).lower()},{str(b_bip).lower()}]\"\n        per_case_outputs.append(case_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(per_case_outputs)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2410323"}]}