{"hands_on_practices": [{"introduction": "The Fast Fourier Transform (FFT) is a cornerstone of modern computational science, but it can often feel like a black box. To truly master the DFT, it's invaluable to look under the hood and implement the algorithm that makes it so efficient. This practice [@problem_id:2387187] guides you through building the classic Cooley-Tukey radix-2 FFT algorithm from scratch, demonstrating the power of its divide-and-conquer approach. By implementing the transform yourself and using it to verify fundamental properties like the convolution theorem and Parseval's identity, you will gain a profound understanding of how the DFT works and why the FFT is one of the most important algorithms ever developed.", "problem": "Let $N$ be a positive integer of the form $N = 2^m$ for some nonnegative integer $m$. For a length-$N$ complex-valued sequence $x = \\{x_n\\}_{n=0}^{N-1}$, the discrete Fourier transform (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$ is defined by\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1,\n$$\nand the inverse discrete Fourier transform (IDFT) is defined by\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N} \\quad \\text{for } n = 0,1,\\dots,N-1,\n$$\nwhere all angles are in radians.\n\nWrite a complete program that, without calling any library Fourier transform routines, computes the DFT and IDFT for sequences of length $N = 2^m$. Your program must also verify the following fundamental properties against explicit test cases using only these definitions:\n\n- Circular convolution theorem: For sequences $a$ and $b$ of length $N$, their length-$N$ circular convolution $c$ defined by $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$ satisfies $C_k = A_k B_k$, where $A$, $B$, and $C$ are the DFTs of $a$, $b$, and $c$, respectively.\n- Parseval identity (with the above normalization): $\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$.\n\nYour program must implement its own fast algorithm to compute the DFT and IDFT for $N = 2^m$, and must include a direct $O(N^2)$ DFT for verification. Use a numerical tolerance $\\varepsilon = 10^{-9}$ where boolean validations are required. All angles must be interpreted in radians.\n\nUse the following test suite, and produce the outputs in the order given below:\n\n- Test $1$ (DFT correctness versus direct DFT, happy path): Let $N = 8$ and $x = [0,1,2,3,4,3,2,1]$. Compute $X$ using your fast implementation and $\\tilde{X}$ using the direct DFT. Output a boolean equal to $\\text{True}$ if $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $2$ (Inverse transform recovery): Using the same $N$ and $x$ as in Test $1$, compute $x'$ by applying your IDFT to $X$ from your fast implementation. Output a boolean equal to $\\text{True}$ if $\\max_n |x'_n - x_n| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $3$ (Circular convolution via frequency domain): Let $N = 8$, $a = [1,2,3,0,0,0,0,0]$, and $b = [0,1,0,0,0,0,0,0]$. Compute the length-$N$ circular convolution $c$ directly from its definition. Separately, compute $\\hat{c}$ by taking the DFTs of $a$ and $b$, multiplying pointwise, and applying the IDFT. Output the scalar $\\max_n |c_n - \\hat{c}_n|$ as a floating-point number.\n- Test $4$ (Parseval identity): Let $N = 16$ and $x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$ for $n = 0,1,\\dots,15$. Compute $X$ by your fast implementation. Output the scalar $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$ as a floating-point number.\n- Test $5$ (Edge case $N=1$): Let $N = 1$ and $x = [3 + 4i]$. Compute $X$ and then $x'$ via IDFT. Output a boolean equal to $\\text{True}$ if $|x'_0 - x_0| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $6$ (Smallest nontrivial size $N=2$): Let $N = 2$ and $x = [1,-1]$. Compute $X$ by your fast implementation. The exact DFT under the given convention is $[0,2]$. Output the scalar $\\max_k |X_k - [0,2]_k|$ as a floating-point number.\n\nFinal output format: Your program should produce a single line of output containing the six results, in order, as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5,r_6]$. All boolean entries must be either $\\text{True}$ or $\\text{False}$, and all real-valued entries must be printed in standard decimal or scientific notation. No other text should be printed.", "solution": "The problem presented is a well-posed and scientifically sound exercise in computational physics, specifically in the area of signal processing. It requires the implementation and verification of the Discrete Fourier Transform (DFT), its inverse (IDFT), and fundamental associated theorems. The problem is complete, objective, and its resolution is verifiable. We will proceed with the solution.\n\nThe core of the problem is the computation of the DFT, $X$, for a given discrete, complex-valued sequence, $x = \\{x_n\\}_{n=0}^{N-1}$, of length $N$. The definition is given as:\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\nA direct implementation of this formula involves two nested loops, one for each index $k$ from $0$ to $N-1$ and one for each index $n$ from $0$ to $N-1$. This leads to a computational complexity of $\\mathcal{O}(N^2)$, which is inefficient for large $N$. For verification purposes, such a direct method will be implemented.\n\nThe problem specifies that $N$ is a power of two, i.e., $N = 2^m$ for some non-negative integer $m$. This structure is key for employing a Fast Fourier Transform (FFT) algorithm, specifically the Cooley-Tukey decimation-in-time algorithm. This algorithm reduces the complexity from $\\mathcal{O}(N^2)$ to $\\mathcal{O}(N \\log N)$. The principle is one of divide and conquer. The length-$N$ DFT is recursively broken down into two length-$(N/2)$ DFTs.\n\nLet the sequence $x_n$ be split into its even-indexed elements, forming a sequence $x'_m = x_{2m}$, and its odd-indexed elements, forming a sequence $x''_m = x_{2m+1}$, each of length $N/2$. The DFT sum can be rewritten as:\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi i k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi i k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi i k m / (N/2)} + e^{-2\\pi i k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi i k m / (N/2)}\n$$\nLet $X'_k$ and $X''_k$ be the length-$(N/2)$ DFTs of $x'_m$ and $x''_m$, respectively. The expressions above become:\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\nwhere $W_N^k = e^{-2\\pi i k/N}$ is the \"twiddle factor\". For $k$ in the first half of the indices, $0 \\le k < N/2$, we have:\n$$\nX_k = X'_k + W_N^k X''_k\n$$\nFor the second half, where the index is $k+N/2$ for $0 \\le k < N/2$, we use the properties $X'_{k+N/2} = X'_k$, $X''_{k+N/2} = X''_k$, and $W_N^{k+N/2} = -W_N^k$. This yields:\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\nThis recursive definition allows the construction of the full DFT. The recursion terminates at the base case $N=1$, where the DFT of a sequence $\\{x_0\\}$ is simply $\\{X_0\\} = \\{x_0\\}$. Our implementation will follow this recursive structure.\n\nThe Inverse Discrete Fourier Transform (IDFT) is defined as:\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N}\n$$\nA separate implementation is not necessary. We can relate the IDFT to the forward DFT. Observe the following derivation:\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi i k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi i k n / N}\n$$\nThe right-hand side is the DFT of the complex-conjugated sequence $\\{\\overline{X_k}\\}_{k=0}^{N-1}$. Therefore, we can find $x_n$ by computing the DFT of $\\overline{X}$, taking the complex conjugate of the result, and scaling by $1/N$. That is, $x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$. This allows us to use our efficient FFT implementation to compute the inverse transform (IFFT) as well.\n\nThe problem further requires verification of two fundamental theorems.\n\nFirst, the circular convolution theorem. The circular convolution $c$ of two length-$N$ sequences, $a$ and $b$, is given by $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$. The theorem states that the DFT of the convolution is the pointwise product of the individual DFTs: $C_k = A_k B_k$. Thus, one can compute $c$ via the frequency domain: $c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$, where $\\odot$ denotes element-wise multiplication. We will test this by computing $c$ both directly and via the frequency domain route and comparing the results.\n\nSecond, Parseval's identity. For the given DFT normalization, the identity is:\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\nThis theorem relates the total energy of a signal in the time domain to its energy in the frequency domain. We will verify this for a specific test signal.\n\nThe program will proceed by first defining the necessary functions: a direct $\\mathcal{O}(N^2)$ DFT, a recursive $\\mathcal{O}(N \\log N)$ FFT, an IFFT based on the FFT, and a direct circular convolution function. Then, it will execute the $6$ specified test cases using these functions and a numerical tolerance of $\\varepsilon = 10^{-9}$ for comparisons. The results will be collected and printed in the required format.", "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N <= 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 <= epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 <= epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 <= epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2387187"}, {"introduction": "The DFT provides a frequency-domain view of a signal, but this view is sampled at a discrete set of frequency bins, much like looking at a landscape through the slats of a picket fence. This practice [@problem_id:2443816] explores the consequences of this discrete sampling, a phenomenon known as the \"picket-fence effect.\" You will first derive from first principles the amplitude loss, or \"scalloping loss,\" that occurs when a sinusoid's frequency falls between DFT bins, and then write a program to numerically verify your theoretical results and explore the beautiful symmetry of the resulting spectrum.", "problem": "Consider the discrete-time complex sinusoid and its Discrete Fourier Transform (DFT) under a rectangular time window. Use the following fundamental bases: (i) the definition of the DFT as a finite sum over samples, and (ii) the geometric-series identity for summing complex exponentials. Define the sampled signal as $x[n] = A \\exp\\left(j \\left(2\\pi \\frac{f_0}{F_s} n + \\varphi\\right)\\right)$ for integer $n$ with $0 \\le n \\le N-1$, amplitude $A > 0$, sampling frequency $F_s$ in hertz, and phase $\\varphi$ in radians. The DFT index set is $k \\in \\{0,1,\\dots,N-1\\}$, with DFT bin center frequencies $f_k = \\frac{k}{N} F_s$. The DFT is $X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j 2\\pi \\frac{k}{N} n\\right)$. The Fast Fourier Transform (FFT) is an algorithm to compute this DFT exactly with fewer arithmetic operations. Angles must be in radians.\n\nYour tasks are:\n1) Starting from the DFT definition and the geometric-series sum, derive an expression for the DFT magnitude $|X[k]|$ of the rectangularly windowed complex sinusoid when the sinusoid’s frequency $f_0$ does not land on a DFT bin. Specialize your result to the case $f_0$ is exactly halfway between two adjacent bins, i.e., $f_0 = \\left(k_0 + \\frac{1}{2}\\right)\\frac{F_s}{N}$ for some integer $k_0$. From this, derive a closed-form expression for the “scalloping ratio” $\\rho_{\\mathrm{theory}}$, defined as the ratio between the largest DFT-bin magnitude $|X[k]|$ at this half-bin offset and the on-bin magnitude $|X[k_0]|$ that would occur if $f_0$ were exactly $f_{k_0}$. Express $\\rho_{\\mathrm{theory}}$ as a function of $N$ only.\n2) Implement a program that, for each specified test case below, constructs $x[n]$ with $f_0$ exactly halfway between bins $k_0$ and $k_0+1$, computes the DFT using both a direct $O(N^2)$ summation and a Fast Fourier Transform, and evaluates:\n   a) the measured scalloping ratio $\\rho_{\\mathrm{meas}} = \\frac{\\max_k |X[k]|}{A N}$,\n   b) the absolute error $|\\rho_{\\mathrm{meas}} - \\rho_{\\mathrm{theory}}|$,\n   c) the two-bin symmetry error, defined as $\\left|\\frac{|X[k_0]|}{|X[k_0+1]|} - 1\\right|$, and\n   d) the infinity-norm difference between the direct DFT and the FFT, normalized by $A N$, i.e., $\\frac{\\max_k |X_{\\mathrm{direct}}[k] - X_{\\mathrm{FFT}}[k]|}{A N}$.\nYou must compute the DFT using both methods and report the requested scalars.\n\nScientific realism requirement: Your derivation for $\\rho_{\\mathrm{theory}}$ must begin with the DFT definition and the finite geometric-series identity. Do not invoke any specialized window-transform “result” without showing how it follows from those bases. All angles must be in radians. No other physical units appear in the outputs. All outputs are dimensionless real numbers.\n\nTest suite: Use the following four parameter sets $(N, F_s, k_0, A, \\varphi)$:\n- Case $1$: $(N=64,\\, F_s=8000,\\, k_0=10,\\, A=1.0,\\, \\varphi=0.3)$\n- Case $2$: $(N=63,\\, F_s=1000,\\, k_0=7,\\, A=2.0,\\, \\varphi=1.2)$\n- Case $3$: $(N=8,\\, F_s=128,\\, k_0=0,\\, A=0.5,\\, \\varphi=0.0)$\n- Case $4$: $(N=1024,\\, F_s=44100,\\, k_0=123,\\, A=1.0,\\, \\varphi=2.3)$\n\nFor each case, construct $f_0 = \\left(k_0 + \\frac{1}{2}\\right)\\frac{F_s}{N}$, generate $x[n]$ for $0 \\le n \\le N-1$, and compute $X[k]$ via both methods.\n\nFinal output format: Your program should produce a single line of output containing the results aggregated across the four cases as a flat, comma-separated list enclosed in square brackets. For each case in the order listed above, append the three scalars in this order: the absolute scalloping-ratio error $|\\rho_{\\mathrm{meas}} - \\rho_{\\mathrm{theory}}|$, the two-bin symmetry error $\\left|\\frac{|X[k_0]|}{|X[k_0+1]|} - 1\\right|$, and the normalized DFT-versus-FFT infinity-norm difference $\\frac{\\max_k |X_{\\mathrm{direct}}[k] - X_{\\mathrm{FFT}}[k]|}{A N}$. Thus, the program must print a single list with $12$ floating-point numbers.", "solution": "The problem statement is critically validated and deemed to be sound. It is scientifically grounded in the principles of digital signal processing, well-posed with clear definitions and objectives, and free of any ambiguity or contradiction. We may therefore proceed with a formal solution.\n\nThe solution is presented in two parts as required: first, a theoretical derivation of the scalloping ratio, and second, an explanation of the numerical implementation to verify this theory and compute related error metrics.\n\n**Part 1: Derivation of the Theoretical Scalloping Ratio $\\rho_{\\mathrm{theory}}$**\n\nThe derivation starts from the definition of the Discrete Fourier Transform (DFT). The signal is a complex sinusoid sampled over a finite interval, which constitutes an implicit rectangular window.\n\nThe discrete-time signal is defined as $x[n] = A \\exp\\left(j \\left(2\\pi \\frac{f_0}{F_s} n + \\varphi\\right)\\right)$ for $n \\in \\{0, 1, \\dots, N-1\\}$.\nThe DFT, $X[k]$, is defined as:\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j 2\\pi \\frac{kn}{N}\\right)$$\nSubstituting the expression for $x[n]$:\n$$X[k] = \\sum_{n=0}^{N-1} A e^{j\\varphi} \\exp\\left(j 2\\pi \\frac{f_0}{F_s} n\\right) \\exp\\left(-j 2\\pi \\frac{kn}{N}\\right)$$\nWe can factor out the constant term $A e^{j\\varphi}$ and combine the exponentials:\n$$X[k] = A e^{j\\varphi} \\sum_{n=0}^{N-1} \\left[\\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right)\\right)\\right]^n$$\nThis is a finite geometric series of the form $\\sum_{n=0}^{N-1} r^n$, where the common ratio is $r = \\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right)\\right)$. Using the identity for the sum of a geometric series, $\\sum_{n=0}^{N-1} r^n = \\frac{1-r^N}{1-r}$, which holds for $r \\neq 1$:\n$$X[k] = A e^{j\\varphi} \\frac{1 - \\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right) N\\right)}{1 - \\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right)\\right)} = A e^{j\\varphi} \\frac{1 - \\exp\\left(j 2\\pi \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}{1 - \\exp\\left(j \\frac{2\\pi}{N} \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}$$\nTo find the magnitude $|X[k]|$, we use the identity $|1 - e^{j\\theta}| = |e^{j\\theta/2}(e^{-j\\theta/2} - e^{j\\theta/2})| = |-2j e^{j\\theta/2}\\sin(\\theta/2)| = 2|\\sin(\\theta/2)|$. Applying this to the numerator and denominator:\n$$|X[k]| = |A e^{j\\varphi}| \\left|\\frac{2\\sin\\left(\\pi \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}{2\\sin\\left(\\frac{\\pi}{N} \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}\\right| = A \\left| \\frac{\\sin\\left(\\pi \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}{\\sin\\left(\\frac{\\pi}{N} \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)} \\right|$$\nThis is the general expression for the magnitude spectrum. Now, we specialize to the case where the frequency $f_0$ is exactly halfway between two adjacent DFT bins, $k_0$ and $k_0+1$: $f_0 = \\left(k_0 + \\frac{1}{2}\\right)\\frac{F_s}{N}$.\nThe term $\\frac{Nf_0}{F_s} - k$ becomes $k_0 + \\frac{1}{2} - k$.\nThe argument of the sine in the numerator is $\\pi \\left(k_0 - k + \\frac{1}{2}\\right)$. Since $k_0-k$ is an integer, let it be $m$. The argument is $m\\pi + \\frac{\\pi}{2}$. The sine of this angle is $\\sin(m\\pi + \\frac{\\pi}{2}) = \\cos(m\\pi) = (-1)^m$. Thus, its magnitude is always $1$.\nThe expression for the magnitude simplifies to:\n$$|X[k]| = \\frac{A}{\\left|\\sin\\left(\\frac{\\pi}{N} \\left(k_0 - k + \\frac{1}{2}\\right)\\right)\\right|}$$\nThe scalloping ratio $\\rho_{\\mathrm{theory}}$ compares the largest DFT magnitude at this half-bin offset to the on-bin magnitude. The on-bin magnitude is the value of $|X[k_0]|$ if the signal frequency were exactly on a bin, i.e., $f_0 = f_{k_0} = k_0\\frac{F_s}{N}$. In this on-bin case, the ratio $r$ for $k=k_0$ becomes $1$, and the geometric sum evaluates to $N$. The DFT is $X[k_0] = A e^{j\\varphi} N$, so the reference magnitude is $|X[k_0]|_{\\mathrm{on-bin}} = AN$.\n\nFor the half-bin case, the largest magnitude, $\\max_k |X[k]|$, occurs when the denominator $\\left|\\sin\\left(\\frac{\\pi}{N} \\left(k_0 - k + \\frac{1}{2}\\right)\\right)\\right|$ is minimized. This happens when the argument is closest to $0$. This occurs for $k = k_0$ and $k = k_0+1$.\nFor $k=k_0$, the argument is $\\frac{\\pi}{2N}$.\nFor $k=k_0+1$, the argument is $-\\frac{\\pi}{2N}$.\nIn both cases, the denominator's magnitude is $\\sin\\left(\\frac{\\pi}{2N}\\right)$ (assuming $N \\ge 2$, so the argument is in $(0, \\pi/2)$).\nThe largest DFT bin magnitude is therefore $\\max_k |X[k]| = \\frac{A}{\\sin\\left(\\frac{\\pi}{2N}\\right)}$.\n\nFinally, the theoretical scalloping ratio is the ratio of these two magnitudes:\n$$\\rho_{\\mathrm{theory}} = \\frac{\\max_k |X[k]|_{\\mathrm{half-bin}}}{|X[k_0]|_{\\mathrm{on-bin}}} = \\frac{A / \\sin\\left(\\frac{\\pi}{2N}\\right)}{AN} = \\frac{1}{N \\sin\\left(\\frac{\\pi}{2N}\\right)}$$\nThis is the required closed-form expression for $\\rho_{\\mathrm{theory}}$ as a function of $N$ only. For large $N$, using the approximation $\\sin(x) \\approx x$ for small $x$, we find $\\rho_{\\mathrm{theory}} \\approx \\frac{1}{N(\\pi/2N)} = \\frac{2}{\\pi} \\approx 0.6366$, which is the classic scalloping loss figure for a rectangular window.\n\n**Part 2: Numerical Implementation**\n\nThe provided program implements the computations specified in the problem statement for four test cases.\nFor each case $(N, F_s, k_0, A, \\varphi)$:\n$1$. The signal frequency $f_0$ is set to $f_0 = (k_0 + 0.5) \\frac{F_s}{N}$.\n$2$. The complex-valued signal $x[n]$ is generated for $n \\in \\{0, 1, \\dots, N-1\\}$.\n$3$. The DFT is computed using two methods:\n    a) A direct summation with $O(N^2)$ complexity, implemented via a matrix-vector product $X_{\\mathrm{direct}} = \\mathbf{W}x$, where $\\mathbf{W}$ is the $N \\times N$ DFT matrix with entries $W_{kn} = \\exp(-j2\\pi kn/N)$.\n    b) The Fast Fourier Transform (FFT) algorithm, using `numpy.fft.fft`, which computes the same DFT with $O(N \\log N)$ complexity.\n$4$. The following quantities are calculated:\n    a) The measured scalloping ratio $\\rho_{\\mathrm{meas}} = \\frac{\\max_k |X_{\\mathrm{FFT}}[k]|}{AN}$. We use the FFT result as it is the standard computational tool.\n    b) The absolute error $|\\rho_{\\mathrm{meas}} - \\rho_{\\mathrm{theory}}|$, which quantifies the agreement between our derived theory and the numerical computation. This should be close to machine precision.\n    c) The two-bin symmetry error $\\left|\\frac{|X_{\\mathrm{FFT}}[k_0]|}{|X_{\\mathrm{FFT}}[k_0+1]|} - 1\\right|$. Our derivation shows these two magnitudes should be identical, so this error measures the numerical symmetry of the computed spectrum.\n    d) The normalized infinity-norm difference $\\frac{\\max_k |X_{\\mathrm{direct}}[k] - X_{\\mathrm{FFT}}[k]|}{A N}$. This metric quantifies the numerical discrepancy between the two DFT computation methods, which arises from different orderings of floating-point operations and resultant round-off error accumulation.\n\nThe program then aggregates these three scalar error metrics for each of the four test cases into a single flat list of $12$ values for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT scalloping loss problem for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, Fs, k0, A, phi)\n    test_cases = [\n        (64, 8000.0, 10, 1.0, 0.3),\n        (63, 1000.0, 7, 2.0, 1.2),\n        (8, 128.0, 0, 0.5, 0.0),\n        (1024, 44100.0, 123, 1.0, 2.3),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, Fs, k0, A, phi = case\n\n        # 1. Construct signal\n        # Frequency is exactly halfway between bin k0 and k0+1\n        f0 = (k0 + 0.5) * Fs / N\n        n = np.arange(N)\n        # Complex sinusoid signal x[n]\n        x_n = A * np.exp(1j * (2 * np.pi * f0 / Fs * n + phi))\n\n        # 2. Compute DFT via direct O(N^2) summation\n        # Create the DFT matrix W\n        k = np.arange(N)\n        k_n_prod = np.outer(k, n)\n        W_matrix = np.exp(-1j * 2 * np.pi * k_n_prod / N)\n        # Compute DFT as a matrix-vector product\n        X_direct = W_matrix @ x_n\n\n        # 3. Compute DFT via FFT\n        X_fft = np.fft.fft(x_n)\n\n        # 4. Calculate the required metrics\n        \n        # a) Scalloping ratio error\n        # Theoretical scalloping ratio\n        # The argument of sin is small, so guard against N=0 (not in tests)\n        if N > 0:\n            rho_theory = 1.0 / (N * np.sin(np.pi / (2.0 * N)))\n        else:\n            rho_theory = 1.0 # Trivial case\n            \n        # Measured scalloping ratio using FFT results\n        max_mag_X_fft = np.max(np.abs(X_fft))\n        rho_meas = max_mag_X_fft / (A * N)\n        \n        # Absolute scalloping-ratio error\n        scalloping_ratio_error = np.abs(rho_meas - rho_theory)\n\n        # b) Two-bin symmetry error\n        # Magnitudes at bin k0 and k0+1 should be equal\n        mag_X_k0 = np.abs(X_fft[k0])\n        # The DFT is periodic, k0+1 is safe as k0 << N-1 in all test cases.\n        mag_X_k0_plus_1 = np.abs(X_fft[k0 + 1])\n        \n        if mag_X_k0_plus_1 == 0:\n            # Avoid division by zero, though not expected here\n            symmetry_error = np.inf if mag_X_k0 != 0 else 0\n        else:\n            symmetry_error = np.abs(mag_X_k0 / mag_X_k0_plus_1 - 1.0)\n            \n        # c) Normalized difference between direct DFT and FFT\n        # Infinity norm of the difference vector\n        norm_inf_diff = np.max(np.abs(X_direct - X_fft)) / (A * N)\n        \n        # Append results for the current case\n        results.extend([scalloping_ratio_error, symmetry_error, norm_inf_diff])\n\n    # Final print statement in the exact required format.\n    # The format specifier ensures standard floating point representation.\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\nsolve()\n```", "id": "2443816"}, {"introduction": "Fourier analysis allows us to represent complex signals as a sum of simple sinusoids, but what happens when we try to reconstruct a signal with sharp jumps, like a square wave, using only a finite number of those sinusoids? This coding exercise [@problem_id:2443812] invites you to investigate the Gibbs phenomenon, a persistent overshoot that appears near discontinuities. By systematically reconstructing a square wave with an increasing number of Fourier components, you will observe and quantify this fascinating artifact, gaining crucial insight into the behavior of Fourier series and the challenges of approximating discontinuous functions.", "problem": "Consider a discrete-time, real-valued, periodic square wave of one period represented by a length-$N$ sequence $s[n]$ with $n \\in \\{0,1,\\dots,N-1\\}$ and even $N$. The sequence is defined by\n$$\ns[n] =\n\\begin{cases}\n+1, & 0 \\le n < N/2,\\\\\n-1, & N/2 \\le n < N.\n\\end{cases}\n$$\nLet $X[k]$ denote the Discrete Fourier Transform (DFT) of $s[n]$, defined for $k \\in \\{0,1,\\dots,N-1\\}$ by\n$$\nX[k] = \\sum_{n=0}^{N-1} s[n] \\, e^{-i 2\\pi nk/N},\n$$\nand let the inverse Discrete Fourier Transform (IDFT) be given by\n$$\nx[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{i 2\\pi nk/N}.\n$$\nAll angles are measured in radians. For an integer bandwidth parameter $K$ with $0 \\le K \\le \\left\\lfloor \\frac{N}{2} \\right\\rfloor - 1$, define the index set\n$$\n\\mathcal{S}_K = \\{0\\} \\cup \\{1,2,\\dots,K\\} \\cup \\{N-K, N-K+1, \\dots, N-1\\},\n$$\nand the truncated-spectrum reconstruction\n$$\nx_K[n] = \\frac{1}{N} \\sum_{k \\in \\mathcal{S}_K} X[k] \\, e^{i 2\\pi nk/N}.\n$$\nLet $M_K = \\max_{0 \\le n \\le N-1} x_K[n]$ and $m_K = \\min_{0 \\le n \\le N-1} x_K[n]$. With high plateau $A_{\\text{high}} = +1$, low plateau $A_{\\text{low}} = -1$, and jump magnitude $J = A_{\\text{high}} - A_{\\text{low}} = 2$, define the normalized Gibbs deviation\n$$\nG_K = \\max\\left( \\frac{\\max(0, M_K - A_{\\text{high}})}{J}, \\; \\frac{\\max(0, A_{\\text{low}} - m_K)}{J} \\right).\n$$\nThe quantity $G_K$ captures the maximum of the normalized overshoot above $A_{\\text{high}}$ and the normalized undershoot below $A_{\\text{low}}$ across the reconstructed sequence $x_K[n]$. For sufficiently large $K$ that are not too close to the Nyquist limit, $G_K$ should approach the well-known Gibbs constant, approximately $0.08949$, for this square-wave jump.\n\nYour task is to write a complete program that, for each test case specified below, constructs $s[n]$, computes $X[k]$, forms $x_K[n]$ from the truncated spectrum, evaluates $G_K$, and outputs the results.\n\nTest suite (each test case is a pair $(N,K)$):\n- Case $1$: $(4096, 0)$.\n- Case $2$: $(4096, 1)$.\n- Case $3$: $(4096, 3)$.\n- Case $4$: $(4096, 7)$.\n- Case $5$: $(4096, 15)$.\n- Case $6$: $(4096, 63)$.\n- Case $7$: $(4096, 255)$.\n- Case $8$: $(64, 31)$.\n\nFor each case, compute $G_K$ as a floating-point number rounded to $6$ decimal places.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list of the eight rounded values, enclosed in square brackets, in the same order as the test cases above. For example, a valid output format is [$0.123456$,$0.234567$,$0.345678$,$0.456789$,$0.567890$,$0.678901$,$0.789012$,$0.890123$].", "solution": "The problem statement has been rigorously validated and is determined to be valid. It is scientifically grounded in the principles of Fourier analysis, mathematically well-posed, and objectively specified. The problem is self-contained, with all necessary definitions, constants, and parameters provided for a unique and verifiable solution. We shall therefore proceed with the derivation and computation.\n\nThe objective is to compute the normalized Gibbs deviation, $G_K$, for a truncated Fourier series reconstruction of a periodic square wave. The procedure involves several distinct steps which will be executed for each provided test case $(N, K)$.\n\nStep 1: Signal Generation\nFirst, we construct the discrete-time signal $s[n]$ for a given length $N$, which is specified to be an even integer. The signal represents one period of a square wave. Its definition is:\n$$\ns[n] =\n\\begin{cases}\n+1, & 0 \\le n < N/2,\\\\\n-1, & N/2 \\le n < N.\n\\end{cases}\n$$\nThis sequence is real-valued and has a length of $N$ samples, indexed from $n=0$ to $n=N-1$.\n\nStep 2: Discrete Fourier Transform (DFT)\nNext, we compute the DFT of the signal $s[n]$ to obtain its frequency-domain representation, $X[k]$. The DFT is defined as:\n$$\nX[k] = \\sum_{n=0}^{N-1} s[n] \\, e^{-i 2\\pi nk/N}\n$$\nfor $k \\in \\{0, 1, \\dots, N-1\\}$. For computational efficiency, this transform will be implemented using a Fast Fourier Transform (FFT) algorithm, which is appropriate as the values of $N$ in the test suite are powers of two.\n\nStep 3: Spectrum Truncation\nA truncated version of the spectrum is created according to the integer bandwidth parameter $K$. A new spectral sequence, which we can denote $X_K[k]$, is formed by preserving the coefficients of $X[k]$ for indices $k$ within the set $\\mathcal{S}_K$ and setting all other coefficients to zero. The index set $\\mathcal{S}_K$ is defined as:\n$$\n\\mathcal{S}_K = \\{0\\} \\cup \\{1,2,\\dots,K\\} \\cup \\{N-K, N-K+1, \\dots, N-1\\}\n$$\nThis set includes the DC component ($k=0$), the first $K$ positive frequency components ($k=1, \\dots, K$), and the corresponding $K$ negative frequency components ($k=N-K, \\dots, N-1$), which are necessary to ensure the reconstructed signal is real-valued. Thus, $X_K[k]$ is defined as:\n$$\nX_K[k] =\n\\begin{cases}\nX[k], & k \\in \\mathcal{S}_K,\\\\\n0, & k \\notin \\mathcal{S}_K.\n\\end{cases}\n$$\n\nStep 4: Signal Reconstruction\nThe truncated signal, $x_K[n]$, is synthesized by computing the Inverse Discrete Fourier Transform (IDFT) of the truncated spectrum $X_K[k]$. The IDFT formula is:\n$$\nx_K[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X_K[k] \\, e^{i 2\\pi nk/N}\n$$\nSimilar to the forward transform, an Inverse Fast Fourier Transform (IFFT) algorithm will be used for efficiency. Since the original signal $s[n]$ is real and the truncated spectrum $X_K[k]$ is constructed with conjugate symmetry (i.e., $X_K[k] = X_K[N-k]^*$), the resulting signal $x_K[n]$ will be real-valued, although minor imaginary components may arise from floating-point inaccuracies and should be discarded.\n\nStep 5: Gibbs Deviation Calculation\nFinally, we quantify the Gibbs phenomenon by calculating the normalized Gibbs deviation $G_K$. This requires finding the maximum and minimum values of the reconstructed signal $x_K[n]$ over one period:\n$$\nM_K = \\max_{0 \\le n \\le N-1} x_K[n]\n$$\n$$\nm_K = \\min_{0 \\le n \\le N-1} x_K[n]\n$$\nThe problem provides the high plateau level $A_{\\text{high}} = +1$, the low plateau level $A_{\\text{low}} = -1$, and the jump magnitude $J = A_{\\text{high}} - A_{\\text{low}} = 2$. The normalized Gibbs deviation $G_K$ is the maximum of the normalized overshoot and undershoot:\n$$\nG_K = \\max\\left( \\frac{\\max(0, M_K - A_{\\text{high}})}{J}, \\; \\frac{\\max(0, A_{\\text{low}} - m_K)}{J} \\right)\n$$\nSubstituting the given values, this becomes:\n$$\nG_K = \\max\\left( \\frac{\\max(0, M_K - 1)}{2}, \\; \\frac{\\max(0, -1 - m_K)}{2} \\right)\n$$\nThis calculation is performed for each $(N, K)$ pair specified in the test suite, and the resulting values of $G_K$ are rounded to $6$ decimal places as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the normalized Gibbs deviation G_K for a truncated Fourier series\n    reconstruction of a square wave for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement as (N, K) pairs.\n    test_cases = [\n        (4096, 0),\n        (4096, 1),\n        (4096, 3),\n        (4096, 7),\n        (4096, 15),\n        (4096, 63),\n        (4096, 255),\n        (64, 31),\n    ]\n\n    # Constants for Gibbs deviation calculation.\n    A_high = 1.0\n    A_low = -1.0\n    J = A_high - A_low  # Jump magnitude\n\n    results = []\n    for N, K in test_cases:\n        # Step 1: Construct the discrete-time square wave signal s[n].\n        # N is guaranteed to be even.\n        s_n = np.ones(N)\n        s_n[N // 2:] = -1.0\n\n        # Step 2: Compute the Discrete Fourier Transform (DFT) of s[n] using FFT.\n        X_k = np.fft.fft(s_n)\n\n        # Step 3: Truncate the spectrum based on the bandwidth parameter K.\n        # Create a new spectrum X_K_k initialized to zeros.\n        X_K_k = np.zeros_like(X_k, dtype=complex)\n\n        # The index set S_K is {0} U {1,...,K} U {N-K,...,N-1}.\n        # Copy the DC component (k=0).\n        if K >= 0:\n            X_K_k[0] = X_k[0]\n        \n        if K > 0:\n            # Copy positive frequency components (k=1,...,K).\n            X_K_k[1:K + 1] = X_k[1:K + 1]\n            # Copy negative frequency components (k=N-K,...,N-1).\n            X_K_k[N - K:] = X_k[N - K:]\n\n        # Step 4: Compute the truncated reconstruction x_K[n] using IFFT.\n        # np.fft.ifft includes the 1/N scaling factor.\n        # The result should be real due to conjugate symmetry, so we take the real part.\n        x_K_n = np.fft.ifft(X_K_k).real\n\n        # Step 5: Find the maximum and minimum values of the reconstructed signal.\n        M_K = np.max(x_K_n)\n        m_K = np.min(x_K_n)\n\n        # Step 6: Calculate the normalized Gibbs deviation G_K.\n        # It is the maximum of the normalized overshoot and undershoot.\n        overshoot_norm = max(0, M_K - A_high) / J\n        undershoot_norm = max(0, A_low - m_K) / J\n        G_K = max(overshoot_norm, undershoot_norm)\n        \n        # Round the result to 6 decimal places and append to the list.\n        results.append(round(G_K, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2443812"}]}