{"hands_on_practices": [{"introduction": "To truly master a new computational tool, one must first understand its inner workings. This exercise guides you through a step-by-step manual calculation of the Discrete Wavelet Transform (DWT) and its inverse, using the simple Haar wavelet system [@problem_id:2866836]. By following the flow of data through the analysis and synthesis filter banks and verifying the Perfect Reconstruction (PR) property, you will build a concrete intuition for the mechanics of the Fast Wavelet Transform algorithm.", "problem": "Consider the Discrete Wavelet Transform (DWT) implemented as a critically sampled two-channel filter bank using the orthonormal Haar system. The orthonormal Haar analysis filters are the low-pass scaling filter $h[0]=\\frac{1}{\\sqrt{2}}$, $h[1]=\\frac{1}{\\sqrt{2}}$ and the high-pass wavelet filter $g[0]=\\frac{1}{\\sqrt{2}}$, $g[1]=-\\frac{1}{\\sqrt{2}}$. Use the standard critically sampled tree with decimation by $2$ at each level and no boundary extension (i.e., pairwise blocking valid for lengths divisible by $2^{L}$), and the corresponding orthonormal synthesis filters to invert. Let the input sequence be $x[n]=[3,1,0,4,8,6,2,0]$, indexed for $n=0,1,\\dots,7$.\n\nTasks:\n- Compute by hand the $3$-level Haar DWT of $x[n]$ to obtain the approximation coefficients at level $3$ and the detail coefficients at levels $1,2,3$.\n- Reconstruct $\\hat{x}[n]$ from these coefficients using the inverse two-channel orthonormal Haar filter bank.\n- Define the scalar error energy\n$$E=\\sum_{n=0}^{7}\\left|x[n]-\\hat{x}[n]\\right|^{2}.$$\nReport the value of $E$.\n\nProvide the exact value of $E$ (no rounding). No units are required. Define all acronyms on first use: Discrete Wavelet Transform (DWT), Fast Wavelet Transform (FWT), Perfect Reconstruction (PR).", "solution": "The problem requires the computation of the reconstruction error energy for a signal processed by a $3$-level Discrete Wavelet Transform (DWT) and its inverse, using the orthonormal Haar wavelet basis. A critically sampled two-channel filter bank is specified, which is the standard structure for the Fast Wavelet Transform (FWT). The key property being tested is that of Perfect Reconstruction (PR), which is a fundamental characteristic of orthonormal filter banks in the absence of any information loss, such as quantization. We will proceed by explicitly calculating the forward and inverse transforms and then the error energy.\n\nThe input signal is $x[n] = [3, 1, 0, 4, 8, 6, 2, 0]$ for $n \\in \\{0, 1, \\dots, 7\\}$. The length is $N=8$.\nThe orthonormal Haar analysis filters are the low-pass scaling filter $h[n]$ and the high-pass wavelet filter $g[n]$:\n$$h[n] = \\frac{1}{\\sqrt{2}}\\delta[n] + \\frac{1}{\\sqrt{2}}\\delta[n-1]$$\n$$g[n] = \\frac{1}{\\sqrt{2}}\\delta[n] - \\frac{1}{\\sqrt{2}}\\delta[n-1]$$\nThe DWT is implemented by convolving the signal with these filters and then decimating by a factor of $2$. For the Haar system, this simplifies to pairwise averaging and differencing. We denote the approximation coefficients at level $j$ as $c_j$ and the detail coefficients as $d_j$. The input signal is $c_0[n] = x[n]$.\n\n**Part 1: Forward DWT (Analysis)**\n\n**Level 1 Decomposition:**\nThe input is $c_0 = [3, 1, 0, 4, 8, 6, 2, 0]$. We process pairs of samples.\nThe approximation coefficients $c_1[k]$ are computed as:\n$c_1[0] = \\frac{c_0[0] + c_0[1]}{\\sqrt{2}} = \\frac{3+1}{\\sqrt{2}} = \\frac{4}{\\sqrt{2}} = 2\\sqrt{2}$\n$c_1[1] = \\frac{c_0[2] + c_0[3]}{\\sqrt{2}} = \\frac{0+4}{\\sqrt{2}} = \\frac{4}{\\sqrt{2}} = 2\\sqrt{2}$\n$c_1[2] = \\frac{c_0[4] + c_0[5]}{\\sqrt{2}} = \\frac{8+6}{\\sqrt{2}} = \\frac{14}{\\sqrt{2}} = 7\\sqrt{2}$\n$c_1[3] = \\frac{c_0[6] + c_0[7]}{\\sqrt{2}} = \\frac{2+0}{\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}$\nSo, $c_1 = [2\\sqrt{2}, 2\\sqrt{2}, 7\\sqrt{2}, \\sqrt{2}]$.\n\nThe detail coefficients $d_1[k]$ are computed as:\n$d_1[0] = \\frac{c_0[0] - c_0[1]}{\\sqrt{2}} = \\frac{3-1}{\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}$\n$d_1[1] = \\frac{c_0[2] - c_0[3]}{\\sqrt{2}} = \\frac{0-4}{\\sqrt{2}} = -\\frac{4}{\\sqrt{2}} = -2\\sqrt{2}$\n$d_1[2] = \\frac{c_0[4] - c_0[5]}{\\sqrt{2}} = \\frac{8-6}{\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}$\n$d_1[3] = \\frac{c_0[6] - c_0[7]}{\\sqrt{2}} = \\frac{2-0}{\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}$\nSo, $d_1 = [\\sqrt{2}, -2\\sqrt{2}, \\sqrt{2}, \\sqrt{2}]$.\n\n**Level 2 Decomposition:**\nThe input is the approximation from the previous level, $c_1 = [2\\sqrt{2}, 2\\sqrt{2}, 7\\sqrt{2}, \\sqrt{2}]$.\n$c_2[0] = \\frac{c_1[0] + c_1[1]}{\\sqrt{2}} = \\frac{2\\sqrt{2} + 2\\sqrt{2}}{\\sqrt{2}} = \\frac{4\\sqrt{2}}{\\sqrt{2}} = 4$\n$c_2[1] = \\frac{c_1[2] + c_1[3]}{\\sqrt{2}} = \\frac{7\\sqrt{2} + \\sqrt{2}}{\\sqrt{2}} = \\frac{8\\sqrt{2}}{\\sqrt{2}} = 8$\nSo, $c_2 = [4, 8]$.\n\n$d_2[0] = \\frac{c_1[0] - c_1[1]}{\\sqrt{2}} = \\frac{2\\sqrt{2} - 2\\sqrt{2}}{\\sqrt{2}} = 0$\n$d_2[1] = \\frac{c_1[2] - c_1[3]}{\\sqrt{2}} = \\frac{7\\sqrt{2} - \\sqrt{2}}{\\sqrt{2}} = \\frac{6\\sqrt{2}}{\\sqrt{2}} = 6$\nSo, $d_2 = [0, 6]$.\n\n**Level 3 Decomposition:**\nThe input is $c_2 = [4, 8]$.\n$c_3[0] = \\frac{c_2[0] + c_2[1]}{\\sqrt{2}} = \\frac{4+8}{\\sqrt{2}} = \\frac{12}{\\sqrt{2}} = 6\\sqrt{2}$\nSo, $c_3 = [6\\sqrt{2}]$.\n\n$d_3[0] = \\frac{c_2[0] - c_2[1]}{\\sqrt{2}} = \\frac{4-8}{\\sqrt{2}} = -\\frac{4}{\\sqrt{2}} = -2\\sqrt{2}$\nSo, $d_3 = [-2\\sqrt{2}]$.\n\nThe $3$-level DWT of $x[n]$ consists of $\\{c_3, d_3, d_2, d_1\\}$.\n\n**Part 2: Inverse DWT (Synthesis)**\n\nThe inverse transform reconstructs the signal level by level. For an orthonormal filter bank, the synthesis operation is the adjoint of the analysis operation. For the Haar basis, this leads to the simple reconstruction formulas:\n$c_{j-1}[2k] = \\frac{c_j[k] + d_j[k]}{\\sqrt{2}}$\n$c_{j-1}[2k+1] = \\frac{c_j[k] - d_j[k]}{\\sqrt{2}}$\nWe denote the reconstructed approximation coefficients as $\\hat{c}_j$.\n\n**Level 3 to Level 2 Synthesis:**\nWe reconstruct $\\hat{c}_2$ from $c_3=[6\\sqrt{2}]$ and $d_3=[-2\\sqrt{2}]$.\n$\\hat{c}_2[0] = \\frac{c_3[0] + d_3[0]}{\\sqrt{2}} = \\frac{6\\sqrt{2} + (-2\\sqrt{2})}{\\sqrt{2}} = \\frac{4\\sqrt{2}}{\\sqrt{2}} = 4$\n$\\hat{c}_2[1] = \\frac{c_3[0] - d_3[0]}{\\sqrt{2}} = \\frac{6\\sqrt{2} - (-2\\sqrt{2})}{\\sqrt{2}} = \\frac{8\\sqrt{2}}{\\sqrt{2}} = 8$\nSo, $\\hat{c}_2 = [4, 8]$, which is identical to the original $c_2$.\n\n**Level 2 to Level 1 Synthesis:**\nWe reconstruct $\\hat{c}_1$ from $\\hat{c}_2=[4, 8]$ and $d_2=[0, 6]$.\nFor $k=0$:\n$\\hat{c}_1[0] = \\frac{\\hat{c}_2[0] + d_2[0]}{\\sqrt{2}} = \\frac{4+0}{\\sqrt{2}} = \\frac{4}{\\sqrt{2}} = 2\\sqrt{2}$\n$\\hat{c}_1[1] = \\frac{\\hat{c}_2[0] - d_2[0]}{\\sqrt{2}} = \\frac{4-0}{\\sqrt{2}} = \\frac{4}{\\sqrt{2}} = 2\\sqrt{2}$\nFor $k=1$:\n$\\hat{c}_1[2] = \\frac{\\hat{c}_2[1] + d_2[1]}{\\sqrt{2}} = \\frac{8+6}{\\sqrt{2}} = \\frac{14}{\\sqrt{2}} = 7\\sqrt{2}$\n$\\hat{c}_1[3] = \\frac{\\hat{c}_2[1] - d_2[1]}{\\sqrt{2}} = \\frac{8-6}{\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}$\nSo, $\\hat{c}_1 = [2\\sqrt{2}, 2\\sqrt{2}, 7\\sqrt{2}, \\sqrt{2}]$, identical to the original $c_1$.\n\n**Level 1 to Level 0 Synthesis:**\nWe reconstruct the final signal $\\hat{x}[n] = \\hat{c}_0[n]$ from $\\hat{c}_1$ and $d_1=[\\sqrt{2}, -2\\sqrt{2}, \\sqrt{2}, \\sqrt{2}]$.\nFor $k=0$:\n$\\hat{x}[0] = \\frac{\\hat{c}_1[0] + d_1[0]}{\\sqrt{2}} = \\frac{2\\sqrt{2} + \\sqrt{2}}{\\sqrt{2}} = \\frac{3\\sqrt{2}}{\\sqrt{2}} = 3$\n$\\hat{x}[1] = \\frac{\\hat{c}_1[0] - d_1[0]}{\\sqrt{2}} = \\frac{2\\sqrt{2} - \\sqrt{2}}{\\sqrt{2}} = \\frac{\\sqrt{2}}{\\sqrt{2}} = 1$\nFor $k=1$:\n$\\hat{x}[2] = \\frac{\\hat{c}_1[1] + d_1[1]}{\\sqrt{2}} = \\frac{2\\sqrt{2} + (-2\\sqrt{2})}{\\sqrt{2}} = 0$\n$\\hat{x}[3] = \\frac{\\hat{c}_1[1] - d_1[1]}{\\sqrt{2}} = \\frac{2\\sqrt{2} - (-2\\sqrt{2})}{\\sqrt{2}} = \\frac{4\\sqrt{2}}{\\sqrt{2}} = 4$\nFor $k=2$:\n$\\hat{x}[4] = \\frac{\\hat{c}_1[2] + d_1[2]}{\\sqrt{2}} = \\frac{7\\sqrt{2} + \\sqrt{2}}{\\sqrt{2}} = \\frac{8\\sqrt{2}}{\\sqrt{2}} = 8$\n$\\hat{x}[5] = \\frac{\\hat{c}_1[2] - d_1[2]}{\\sqrt{2}} = \\frac{7\\sqrt{2} - \\sqrt{2}}{\\sqrt{2}} = \\frac{6\\sqrt{2}}{\\sqrt{2}} = 6$\nFor $k=3$:\n$\\hat{x}[6] = \\frac{\\hat{c}_1[3] + d_1[3]}{\\sqrt{2}} = \\frac{\\sqrt{2} + \\sqrt{2}}{\\sqrt{2}} = \\frac{2\\sqrt{2}}{\\sqrt{2}} = 2$\n$\\hat{x}[7] = \\frac{\\hat{c}_1[3] - d_1[3]}{\\sqrt{2}} = \\frac{\\sqrt{2} - \\sqrt{2}}{\\sqrt{2}} = 0$\nThe reconstructed signal is $\\hat{x}[n]=[3, 1, 0, 4, 8, 6, 2, 0]$.\n\n**Part 3: Error Energy Calculation**\nThe original signal is $x[n]=[3, 1, 0, 4, 8, 6, 2, 0]$.\nThe reconstructed signal is $\\hat{x}[n]=[3, 1, 0, 4, 8, 6, 2, 0]$.\nClearly, $\\hat{x}[n] = x[n]$ for all $n \\in \\{0, 1, \\dots, 7\\}$.\nThe error signal is $e[n] = x[n] - \\hat{x}[n] = [0, 0, 0, 0, 0, 0, 0, 0]$.\nThe scalar error energy $E$ is defined as:\n$$E = \\sum_{n=0}^{7} |x[n] - \\hat{x}[n]|^2 = \\sum_{n=0}^{7} |e[n]|^2$$\nSubstituting the error signal:\n$$E = \\sum_{n=0}^{7} |0|^2 = 0$$\nThe result $E=0$ is expected. The problem setup describes an orthonormal filter bank with no modifications to the coefficients (e.g., quantization, thresholding) between the analysis and synthesis stages. Such systems possess the Perfect Reconstruction property, meaning the output is identical to the input, and thus the reconstruction error is zero. The calculation confirms this fundamental principle.", "answer": "$$\\boxed{0}$$", "id": "2866836"}, {"introduction": "Now that you understand how a DWT is computed, we address a more fundamental question: why use it? This practice explores the crucial concept of sparsity, which measures how efficiently a transform can represent a signal [@problem_id:2450300]. By comparing the DWT with the classic Discrete Fourier Transform (DFT) for different signal types, you will discover that the ideal transform is one whose basis functions best match the features within the signal, a core principle in modern signal processing and compression.", "problem": "You are to write a complete, runnable program that constructs specific discrete-time signals, analyzes their representation sparsity in the Discrete Fourier Transform (DFT) domain and in the Discrete Wavelet Transform (DWT) domain using the orthonormal Haar basis, and aggregates the results for a given test suite. All angles used in trigonometric functions must be in radians. No physical units are involved.\n\nDefinitions and requirements:\n1) Let a real-valued discrete-time signal be represented by a finite sequence $\\{x[n]\\}_{n=0}^{N-1}$ of length $N$, where $N$ is a positive even integer.\n2) The Discrete Fourier Transform (DFT) of $\\{x[n]\\}$ is the sequence $\\{X[k]\\}_{k=0}^{N-1}$ defined by\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\, 2\\pi \\, \\frac{n k}{N}} \\quad \\text{for} \\quad k=0,1,\\dots,N-1.\n$$\n3) The orthonormal Haar Discrete Wavelet Transform (DWT) of $\\{x[n]\\}$ is defined recursively by repeated application of the length-$2$ orthonormal analysis filters. At each level, for an input sequence $\\{u[m]\\}_{m=0}^{M-1}$ of even length $M$, define the approximation coefficients $\\{a[j]\\}_{j=0}^{\\frac{M}{2}-1}$ and detail coefficients $\\{d[j]\\}_{j=0}^{\\frac{M}{2}-1}$ by\n$$\na[j] = \\frac{u[2j] + u[2j+1]}{\\sqrt{2}}, \\quad d[j] = \\frac{u[2j] - u[2j+1]}{\\sqrt{2}},\n$$\nfor $j=0,1,\\dots,\\frac{M}{2}-1$. Use the approximation coefficients as the input $\\{u[m]\\}$ for the next level, and continue until a single approximation coefficient remains. The full set of Haar DWT coefficients consists of the final single approximation coefficient together with all detail coefficients from all levels. This transform is orthonormal and energy preserving.\n4) For any coefficient vector $\\{c[\\ell]\\}$ in a chosen domain (DFT magnitudes or Haar DWT coefficients), define its total energy by\n$$\nE = \\sum_{\\ell} |c[\\ell]|^2.\n$$\nGiven an energy capture fraction $\\alpha \\in (0,1]$, define the sparsity count $S_\\alpha$ for that coefficient vector as the smallest nonnegative integer $K$ such that the sum of the squared magnitudes of the $K$ largest-magnitude coefficients (by absolute value) is greater than or equal to $\\alpha E$. If $E=0$, define $S_\\alpha = 0$.\n5) For a signal $\\{x[n]\\}$, let $S_\\alpha^{\\text{DFT}}$ denote the sparsity count computed from the DFT magnitudes $\\{|X[k]|\\}$, and let $S_\\alpha^{\\text{DWT}}$ denote the sparsity count computed from the full set of Haar DWT coefficients. In this problem, use $\\alpha = 0.95$.\n\nTest suite:\nUse $N=256$ and the following four signals $\\{x^{(q)}[n]\\}$ for $q \\in \\{A,B,C,D\\}$, $n=0,1,\\dots,N-1$.\n- Case A (sum of two cosines, frequencies in cycles per record): Let $f_1 = 5$ and $f_2 = 13$. Define\n$$\nx^{(A)}[n] = \\cos\\!\\left(2\\pi \\frac{f_1 n}{N}\\right) + 0.5 \\cos\\!\\left(2\\pi \\frac{f_2 n}{N}\\right).\n$$\n- Case B (piecewise-constant, dyadic segmentation): Define\n$$\nx^{(B)}[n] =\n\\begin{cases}\n0, & 0 \\le n < 64,\\\\\n2, & 64 \\le n < 128,\\\\\n-1.5, & 128 \\le n < 192,\\\\\n0.5, & 192 \\le n < 256.\n\\end{cases}\n$$\n- Case C (zero signal): Define $x^{(C)}[n] = 0$ for all $n$.\n- Case D (linear chirp with linearly increasing instantaneous frequency): Let $f_0 = 3$ and $f_1 = 60$. Define $t_n = \\frac{n}{N}$ and the phase\n$$\n\\phi[n] = 2\\pi \\left( f_0 \\, t_n + \\frac{1}{2}(f_1 - f_0) \\, t_n^2 \\right),\n$$\nand set\n$$\nx^{(D)}[n] = \\sin\\!\\big(\\phi[n]\\big).\n$$\n\nAngle unit declaration: All trigonometric function arguments are in radians.\n\nFor each case $q \\in \\{A,B,C,D\\}$, compute the pair $\\big(S_{0.95}^{\\text{DFT}}(x^{(q)}), S_{0.95}^{\\text{DWT}}(x^{(q)})\\big)$ and also compute two boolean indicators:\n- Fourier-sparser indicator: $S_{0.95}^{\\text{DFT}}(x^{(q)}) < S_{0.95}^{\\text{DWT}}(x^{(q)})$.\n- Wavelet-sparser indicator: $S_{0.95}^{\\text{DWT}}(x^{(q)}) < S_{0.95}^{\\text{DFT}}(x^{(q)})$.\n\nFinal output format:\nYour program should produce a single line of output containing a list of four results, in the order $[A,B,C,D]$. Each result must be a list of the form $[K_F, K_W, F\\_sparser, W\\_sparser]$, where $K_F$ is $S_{0.95}^{\\text{DFT}}$, $K_W$ is $S_{0.95}^{\\text{DWT}}$, $F\\_sparser$ is the Fourier-sparser boolean, and $W\\_sparser$ is the Wavelet-sparser boolean. The entire output must be a single line that looks like\n$[[K_{F,A},K_{W,A},F\\_A,W\\_A],[K_{F,B},K_{W,B},F\\_B,W\\_B],[K_{F,C},K_{W,C},F\\_C,W\\_C],[K_{F,D},K_{W,D},F\\_D,W\\_D]]$\nwith no additional text.", "solution": "The problem presented is a well-defined computational exercise in signal processing, specifically concerning the analysis of signal representation sparsity. It requires the comparison of two fundamental transforms—the Discrete Fourier Transform (DFT) and the Discrete Wavelet Transform (DWT) using the Haar basis—for representing different types of signals. The problem statement is scientifically sound, mathematically unambiguous, and contains all necessary information for its resolution. Therefore, I deem the problem valid and shall proceed with a complete solution.\n\nThe core principle to be demonstrated is that the efficiency of a signal representation is critically dependent on the choice of basis functions. A signal that is \"sparse\" in a particular basis can be accurately represented or approximated using a small number of non-zero coefficients. This property is fundamental to modern data compression and analysis techniques. The DFT provides a basis of complex sinusoids, which is optimally sparse for signals composed of a few periodic components. The Haar DWT, on the other hand, provides a basis of piecewise-constant functions (scaled and shifted square waves), which is optimally sparse for signals that are themselves piecewise-constant with dyadic structure.\n\nThe solution methodology involves four primary steps for each test case:\n1.  Signal generation according to the specified mathematical formula.\n2.  Computation of the signal's representation in the DFT domain and the Haar DWT domain.\n3.  Calculation of the sparsity count, $S_{0.95}$, for both representations.\n4.  Comparison of the two sparsity counts to determine which basis provides a sparser representation.\n\nLet the signal be $\\{x[n]\\}_{n=0}^{N-1}$ with $N=256$.\n\nFirst, we compute the DFT coefficients $\\{X[k]\\}_{k=0}^{N-1}$ using the formula:\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\, 2\\pi \\, \\frac{n k}{N}}\n$$\nThis is efficiently implemented using the Fast Fourier Transform (FFT) algorithm.\n\nSecond, we compute the orthonormal Haar DWT coefficients. The process is recursive. Let the initial signal be $u_0 = x$. For each level $j=1, 2, \\dots, \\log_2(N)$, we take the approximation coefficients from the previous level, $u_{j-1}$, as input. The new approximation coefficients $a_j$ and detail coefficients $d_j$ are computed as:\n$$\na_j[m] = \\frac{u_{j-1}[2m] + u_{j-1}[2m+1]}{\\sqrt{2}}\n$$\n$$\nd_j[m] = \\frac{u_{j-1}[2m] - u_{j-1}[2m+1]}{\\sqrt{2}}\n$$\nThe input for the next level is $u_j = a_j$. This is repeated until a single approximation coefficient, $a_{\\log_2(N)}$, remains. The full DWT coefficient vector is the collection of the final approximation coefficient and all detail coefficients from every level: $\\{a_{\\log_2(N)}, d_{\\log_2(N)}, d_{\\log_2(N)-1}, \\dots, d_1\\}$. For $N=256$, there are $\\log_2(256)=8$ levels of decomposition.\n\nThird, for each set of coefficients $\\{c[\\ell]\\}$ (either the DFT magnitudes $\\{|X[k]|\\}$ or the Haar DWT coefficients), we compute the sparsity count $S_\\alpha$ for $\\alpha = 0.95$. The total energy is defined as $E = \\sum_{\\ell} |c[\\ell]|^2$. The sparsity count $S_\\alpha$ is the minimum number of coefficients $K$ whose squared magnitudes sum to at least $\\alpha E$. To find $K$, we sort the squared magnitudes $|c[\\ell]|^2$ in descending order and find the smallest $K$ such that the cumulative sum of the first $K$ terms meets or exceeds the threshold $0.95 E$. If $E=0$, then $S_\\alpha = 0$.\n\nLet's analyze each case before computation:\n- **Case A (Sum of cosines)**: The signal $x^{(A)}[n] = \\cos(2\\pi \\frac{5 n}{256}) + 0.5 \\cos(2\\pi \\frac{13 n}{256})$ is a sum of two pure sinusoids with integer frequencies $f_1=5$ and $f_2=13$. The DFT of a cosine $\\cos(2\\pi \\frac{f n}{N})$ consists of two impulses at frequencies $k=f$ and $k=N-f$. Thus, the DFT of $x^{(A)}[n]$ will have almost all its energy concentrated in just four coefficients corresponding to $k \\in \\{5, 13, 256-13, 256-5\\}$. The DFT representation will be extremely sparse. Conversely, the smooth sinusoidal nature of the signal is poorly matched to the blocky Haar wavelets, requiring many DWT coefficients for an accurate representation. We predict $S_{0.95}^{\\text{DFT}} < S_{0.95}^{\\text{DWT}}$.\n\n- **Case B (Piecewise-constant)**: The signal $x^{(B)}[n]$ is constant over four contiguous blocks of length $64$ each. The boundaries are at $n=64$, $n=128$, and $n=192$, which are all integer multiples of $N/4 = 256/4 = 64$. This dyadic structure aligns perfectly with the Haar basis functions. As shown by a step-by-step application of the DWT filter equations, only a very small number of Haar coefficients, corresponding to the discontinuities, will be non-zero. Our analysis shows exactly $4$ non-zero DWT coefficients. In contrast, the sharp discontinuities in the signal will spread energy widely across the frequency spectrum, leading to a dense DFT representation. We predict $S_{0.95}^{\\text{DWT}} < S_{0.95}^{\\text{DFT}}$.\n\n- **Case C (Zero signal)**: $x^{(C)}[n] = 0$. The DFT and DWT of a zero signal are both zero vectors. The energy in both domains is $E=0$. By definition, the sparsity count is $S_\\alpha = 0$ for both. Thus, $S_{0.95}^{\\text{DFT}} = S_{0.95}^{\\text{DWT}} = 0$. Neither is strictly sparser than the other.\n\n- **Case D (Linear chirp)**: The signal $x^{(D)}[n] = \\sin(\\phi[n])$ has an instantaneous frequency that varies linearly from $f_0=3$ to $f_1=60$. This signal is non-periodic and smooth. Its energy is spread over a wide range of frequencies in the DFT domain, so $S_{0.95}^{\\text{DFT}}$ will be large. It is also not piecewise-constant, so its Haar DWT representation will also be dense, making $S_{0.95}^{\\text{DWT}}$ large. Neither basis is a good fit. The relative performance is not obvious a priori and will be determined by computation. Wavelets are often cited for their ability to analyze such time-varying signals, but the rudimentary Haar wavelet is a poor choice for this task compared to smoother wavelets.\n\nThe final step is to implement this logic in a program to find the precise quantitative values for $S_{0.95}^{\\text{DFT}}$ and $S_{0.95}^{\\text{DWT}}$ and the corresponding boolean indicators for each case. The provided code in the final answer section executes these computations.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs, analyzes, and reports the sparsity of four test signals\n    in the DFT and Haar DWT domains.\n    \"\"\"\n\n    def haar_dwt(x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the full 1D orthonormal Haar Discrete Wavelet Transform.\n        \"\"\"\n        u = x.astype(np.float64)\n        coeffs = []\n        while len(u) > 1:\n            u_even = u[::2]\n            u_odd = u[1::2]\n            a = (u_even + u_odd) / np.sqrt(2)\n            d = (u_even - u_odd) / np.sqrt(2)\n            coeffs.insert(0, d)\n            u = a\n        \n        # The final structure is [a_final, d_logN, d_logN-1, ..., d_1]\n        full_coeffs = [u]\n        for d_level in coeffs:\n            full_coeffs.append(d_level)\n            \n        return np.concatenate(full_coeffs)\n\n    def calculate_sparsity(coeffs: np.ndarray, alpha: float) -> int:\n        \"\"\"\n        Calculates the sparsity count S_alpha for a given coefficient vector.\n        \"\"\"\n        if coeffs.size == 0:\n            return 0\n\n        # Use squared magnitudes for energy calculation\n        coeffs_mag_sq = np.abs(coeffs)**2\n        total_energy = np.sum(coeffs_mag_sq)\n\n        if total_energy == 0:\n            return 0\n\n        target_energy = alpha * total_energy\n        \n        # Sort squared magnitudes in descending order\n        sorted_mag_sq = np.sort(coeffs_mag_sq)[::-1]\n        \n        # Find the number of coefficients needed to capture the target energy\n        cumulative_energy = np.cumsum(sorted_mag_sq)\n        \n        # K is the smallest count such that the energy condition is met.\n        # np.searchsorted finds the index to insert to maintain order.\n        # If the target is met at index i, we need i+1 coefficients.\n        K = np.searchsorted(cumulative_energy, target_energy, side='left') + 1\n        \n        return int(K)\n\n    # General parameters from the problem statement\n    N = 256\n    alpha = 0.95\n    n = np.arange(N)\n\n    # Test Case A: Sum of two cosines\n    f1_A, f2_A = 5, 13\n    x_A = np.cos(2 * np.pi * f1_A * n / N) + 0.5 * np.cos(2 * np.pi * f2_A * n / N)\n\n    # Test Case B: Piecewise-constant signal\n    x_B = np.zeros(N)\n    x_B[64:128] = 2.0\n    x_B[128:192] = -1.5\n    x_B[192:256] = 0.5\n\n    # Test Case C: Zero signal\n    x_C = np.zeros(N)\n\n    # Test Case D: Linear chirp\n    f0_D, f1_D = 3, 60\n    t_n = n / N\n    phase_D = 2 * np.pi * (f0_D * t_n + 0.5 * (f1_D - f0_D) * t_n**2)\n    x_D = np.sin(phase_D)\n    \n    signals = {'A': x_A, 'B': x_B, 'C': x_C, 'D': x_D}\n    all_results = []\n    \n    # Process each case in the required order\n    for key in ['A', 'B', 'C', 'D']:\n        x = signals[key]\n        \n        # DFT Sparsity Calculation\n        dft_coeffs = np.fft.fft(x)\n        K_F = calculate_sparsity(dft_coeffs, alpha)\n        \n        # DWT Sparsity Calculation\n        dwt_coeffs = haar_dwt(x)\n        K_W = calculate_sparsity(dwt_coeffs, alpha)\n        \n        # Sparsity Comparison Indicators\n        F_sparser = K_F < K_W\n        W_sparser = K_W < K_F\n        \n        all_results.append([K_F, K_W, F_sparser, W_sparser])\n\n    # Format the output string exactly as specified\n    case_strings = []\n    for result_case in all_results:\n        kf, kw, fs, ws = result_case\n        case_strings.append(f\"[{kf},{kw},{str(fs)},{str(ws)}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2450300"}, {"introduction": "Wavelet transforms are not just a theoretical exercise; they are powerful diagnostic tools in computational engineering. This exercise simulates a common and practical task: analyzing the residual error between a computational model's prediction and an experimental measurement [@problem_id:2450301]. By applying Multiresolution Analysis (MRA) to the error signal, you will learn to identify the specific scales or frequencies at which your model is failing, providing invaluable insight for targeted model improvement.", "problem": "You are given a discrete-time experimental signal and the output of a computational model as real-valued sequences of equal length. Let the residual be defined by $r[n] = y_{\\mathrm{exp}}[n] - y_{\\mathrm{model}}[n]$ for $n \\in \\{0,1,\\dots,N-1\\}$. Consider an orthonormal Discrete Wavelet Transform (DWT) based on the Haar wavelet with periodic boundary conditions. A one-level transform maps a length-$N$ sequence $x[n]$ to approximation and detail coefficient sequences $a^{(1)}[k]$ and $d^{(1)}[k]$ of length $N/2$ given by\n$$\na^{(1)}[k] = \\frac{1}{\\sqrt{2}}\\left(x[(2k) \\bmod N] + x[(2k+1) \\bmod N]\\right),\n$$\n$$\nd^{(1)}[k] = \\frac{1}{\\sqrt{2}}\\left(x[(2k) \\bmod N] - x[(2k+1) \\bmod N]\\right),\n$$\nfor $k \\in \\{0,1,\\dots,N/2-1\\}$. For a multilevel decomposition to depth $J$, define recursively $a^{(j)}$ by applying the same transformation to $a^{(j-1)}$, with $a^{(0)} \\equiv x$, and collect $d^{(j)}$ at each level $j \\in \\{1,2,\\dots,J\\}$. For each level $j$, define the detail energy\n$$\nE_j = \\sum_{k=0}^{N/2^j-1} \\left(d^{(j)}[k]\\right)^2.\n$$\nLet the total detail energy be $E_{\\mathrm{tot}} = \\sum_{j=1}^{J} E_j$. Define the dominant level index\n$$\nj^{\\star} = \n\\begin{cases}\n\\arg\\max_{j \\in \\{1,\\dots,J\\}} E_j & \\text{if } E_{\\mathrm{tot}} > 0,\\\\\n0 & \\text{if } E_{\\mathrm{tot}} = 0,\n\\end{cases}\n$$\nwith the convention that if multiple levels attain the maximum value, the smallest such $j$ is chosen. Define also the dominance ratio\n$$\n\\rho = \n\\begin{cases}\n\\frac{E_{j^{\\star}}}{E_{\\mathrm{tot}}} & \\text{if } E_{\\mathrm{tot}} > 0,\\\\\n0 & \\text{if } E_{\\mathrm{tot}} = 0.\n\\end{cases}\n$$\n\nYour task is to determine, for each of the test cases below, the pair $[j^{\\star}, \\rho]$ that characterizes the scale at which the residual energy is most concentrated and how dominant that scale is. Angles in trigonometric functions must be in radians. Use the multilevel decomposition depth $J = 5$ and signal length $N = 256$.\n\nTest suite (each case specifies $y_{\\mathrm{exp}}[n]$ and $y_{\\mathrm{model}}[n]$ for $n \\in \\{0,1,\\dots,N-1\\}$):\n\n- Case $1$ (low-frequency sinusoidal residual):\n  - $y_{\\mathrm{exp}}[n] = \\sin\\!\\left(2\\pi \\cdot 4 \\cdot \\frac{n}{N}\\right)$,\n  - $y_{\\mathrm{model}}[n] = 0$ for all $n$.\n\n- Case $2$ (high-frequency sinusoidal residual):\n  - $y_{\\mathrm{exp}}[n] = \\sin\\!\\left(2\\pi \\cdot 40 \\cdot \\frac{n}{N}\\right)$,\n  - $y_{\\mathrm{model}}[n] = 0$ for all $n$.\n\n- Case $3$ (perfect model, zero residual):\n  - $y_{\\mathrm{exp}}[n] = \\sin\\!\\left(2\\pi \\cdot 10 \\cdot \\frac{n}{N}\\right)$,\n  - $y_{\\mathrm{model}}[n] = \\sin\\!\\left(2\\pi \\cdot 10 \\cdot \\frac{n}{N}\\right)$.\n\n- Case $4$ (localized transient residual):\n  - $y_{\\mathrm{exp}}[n] = \\exp\\!\\left(-\\frac{(n - 100)^2}{2 \\cdot 5^2}\\right)$,\n  - $y_{\\mathrm{model}}[n] = 0$ for all $n$.\n\nYour program must compute $r[n]$ for each case, perform the Haar DWT to depth $J = 5$, compute $E_j$ for $j \\in \\{1,2,3,4,5\\}$, then compute $j^{\\star}$ and $\\rho$ as defined above. The required final output format is a single line containing a list of the results for the four test cases, where each result is the pair $[j^{\\star}, \\rho]$ with the integer $j^{\\star}$ and the float $\\rho$ rounded to exactly six digits after the decimal point. The line must be formatted as a valid bracketed list with comma-separated entries, for example:\n$[[j^{\\star}_1,\\rho_1],[j^{\\star}_2,\\rho_2],[j^{\\star}_3,\\rho_3],[j^{\\star}_4,\\rho_4]]$.", "solution": "The user has provided a problem that requires the analysis of a residual signal using a multilevel Discrete Wavelet Transform (DWT) with the Haar wavelet. The goal is to identify the dominant scale of energy concentration in the residual for several test cases. The entire process, from problem validation to solution, is performed with strict adherence to scientific and mathematical correctness.\n\n### Step 1: Problem Validation\n\nThe problem statement is first subjected to a rigorous validation process.\n\n- **Extraction of Givens**: All definitions, constants, and formulas are extracted verbatim:\n    - Signal length $N=256$, decomposition depth $J=5$.\n    - Residual signal: $r[n] = y_{\\mathrm{exp}}[n] - y_{\\mathrm{model}}[n]$.\n    - One-level Haar DWT formulas for a sequence $x$ of length $M$:\n        - Approximation: $a^{(1)}[k] = \\frac{1}{\\sqrt{2}}(x[(2k) \\bmod M] + x[(2k+1) \\bmod M])$\n        - Detail: $d^{(1)}[k] = \\frac{1}{\\sqrt{2}}(x[(2k) \\bmod M] - x[(2k+1) \\bmod M])$\n        - The recursive application of the transform implies that for level $j$, the transform is applied to $a^{(j-1)}$ of length $M = N/2^{j-1}$, and thus the modulo operation should be with respect to $M$, not the original $N$. This is the only reasonable interpretation for a standard multilevel DWT.\n    - Detail energy at level $j$: $E_j = \\sum_{k} (d^{(j)}[k])^2$.\n    - Total detail energy: $E_{\\mathrm{tot}} = \\sum_{j=1}^{J} E_j$.\n    - Dominant level index $j^{\\star}$ and dominance ratio $\\rho$, with specific rules for the $E_{\\mathrm{tot}}=0$ case and tie-breaking for $\\arg\\max$.\n    - Four test cases with explicit functions for $y_{\\mathrm{exp}}[n]$ and $y_{\\mathrm{model}}[n]$.\n\n- **Validation Verdict**: The problem is **valid**.\n    - It is **scientifically grounded** in the established theory of wavelet analysis.\n    - It is **well-posed**, with all definitions, algorithms, and parameters specified, leading to a unique solution. The definitions for $j^\\star$ and $\\rho$ are unambiguous.\n    - It is **objective**, based entirely on mathematical formulas and numerical computation.\n    - It is **complete** and **consistent**. The recursive DWT definition is slightly ambiguous but has a clear, standard interpretation which is adopted.\n    - The problem falls squarely within the specified topic of wavelet transforms in computational engineering.\n\n### Step 2: Solution Derivation\n\nThe solution is implemented by following the definitions provided in the problem statement. The overall procedure for each test case is as follows:\n1.  Compute the residual signal $r[n]$.\n2.  Perform a $J=5$ level DWT on $r[n]$ to obtain the detail coefficients $d^{(j)}$ for $j=1, \\dots, 5$.\n3.  Calculate the energy $E_j$ for each detail level.\n4.  Compute the total detail energy $E_{\\mathrm{tot}}$.\n5.  Determine the dominant level $j^{\\star}$ and dominance ratio $\\rho$ based on the provided rules.\n\n**1. Residual Signal Generation**\nFor each test case, the residual signal $r[n]$ of length $N=256$ is computed by subtracting the model output $y_{\\mathrm{model}}[n]$ from the experimental signal $y_{\\mathrm{exp}}[n]$ for each sample $n \\in \\{0, 1, \\dots, 255\\}$.\n\n**2. Multilevel Haar DWT**\nA function is designed to perform one level of the Haar DWT. The input is a signal $x$ of length $M$. The outputs are the approximation coefficients $a$ and detail coefficients $d$, both of length $M/2$. The provided formulas simplify to a pairwise operation. For $k \\in \\{0, 1, \\dots, M/2-1\\}$:\n$$\na[k] = \\frac{1}{\\sqrt{2}}(x[2k] + x[2k+1])\n$$\n$$\nd[k] = \\frac{1}{\\sqrt{2}}(x[2k] - x[2k+1])\n$$\nThis operation is efficiently implemented using vectorized operations in `numpy`. The multilevel decomposition starts with the residual signal $r[n]$ as the initial approximation coefficients, $a^{(0)}$. The one-level DWT is then applied recursively $J=5$ times. In each level $j$, the approximation coefficients $a^{(j-1)}$ are decomposed into $a^{(j)}$ and $d^{(j)}$. The detail coefficients $d^{(j)}$ from each level are collected.\n\n**3. Energy Calculation**\nFor each set of detail coefficients $d^{(j)}$, the corresponding energy $E_j$ is computed by summing the squares of its elements, as per the definition $E_j = \\sum_{k} (d^{(j)}[k])^2$. This is equivalent to the squared $L^2$-norm of the coefficient vector. The total detail energy $E_{\\mathrm{tot}}$ is the sum of these individual level energies.\n\n**4. Dominant Scale and Ratio Calculation**\nThe final analysis depends on the value of $E_{\\mathrm{tot}}$.\n- If $E_{\\mathrm{tot}}$ is effectively zero (below a small floating-point tolerance, e.g., $10^{-12}$), then by definition, $j^{\\star} = 0$ and $\\rho = 0$. This case applies when the residual signal is constant (including zero), as the Haar detail coefficients will all be zero.\n- If $E_{\\mathrm{tot}} > 0$, the dominant level $j^{\\star}$ is found by identifying the level with the maximum energy, $j^{\\star} = \\arg\\max_{j \\in \\{1,\\dots,5\\}} E_j$. The problem specifies that in case of a tie, the smallest $j$ is chosen. The `numpy.argmax` function naturally satisfies this by returning the index of the first maximum. The dominance ratio is then calculated as $\\rho = E_{j^{\\star}} / E_{\\mathrm{tot}}$.\n\n**5. Analysis of Test Cases**\n- **Case 1 (Low-frequency):** The residual is a sine wave with frequency $f=4/256 = 1/64$ cycles/sample. The DWT acts as a filter bank, and this frequency falls into the band corresponding to detail level $j=5$. Thus, we expect $j^{\\star}=5$.\n- **Case 2 (High-frequency):** The residual is a sine wave with frequency $f=40/256 = 5/32$ cycles/sample. This frequency is within the band corresponding to detail level $j=2$. Thus, we expect $j^{\\star}=2$.\n- **Case 3 (Zero residual):** The residual is identically zero. All detail coefficients and energies will be zero. Therefore, $E_{\\mathrm{tot}}=0$, leading to $j^{\\star}=0$ and $\\rho=0$.\n- **Case 4 (Localized transient):** The residual is a narrow Gaussian pulse. Such a feature is localized in time and broad in frequency, meaning its energy is spread across multiple scales. The scale of the feature (width $\\sigma=5$) is best matched by wavelet scales of similar size. Level $j$ corresponds to features of size $2^j$. Since $2^2=4$ and $2^3=8$, the energy is expected to be concentrated around levels $j=2$ and $j=3$. The computation will reveal the dominant one.\n\nThe final computed values are formatted into a string as specified, with the float $\\rho$ represented with exactly six decimal places using standard rounding conventions (round half up).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dwt_level(x: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Computes one level of the Haar Discrete Wavelet Transform.\n    The implementation is a vectorized version of the formulas given in the problem.\n    The modulo operator in the problem definition is superfluous for power-of-2 lengths\n    and standard recursion, so it's not explicitly implemented, but the result is the same.\n    \"\"\"\n    # The formulas are x[2k] and x[2k+1], which corresponds to even and odd indices.\n    x_even = x[0::2]\n    x_odd = x[1::2]\n    \n    inv_sqrt2 = 1.0 / np.sqrt(2.0)\n    \n    # Approximation coefficients\n    a_next = (x_even + x_odd) * inv_sqrt2\n    \n    # Detail coefficients\n    d_next = (x_even - x_odd) * inv_sqrt2\n    \n    return a_next, d_next\n\ndef analyze_residual(r: np.ndarray, J: int) -> list:\n    \"\"\"\n    Performs a J-level DWT on the residual signal r and computes\n    the dominant level index j_star and dominance ratio rho.\n    \"\"\"\n    # Perform J-level DWT and collect detail coefficients\n    all_details = []\n    a_current = r.copy()\n    for _ in range(J):\n        a_current, d_next = dwt_level(a_current)\n        all_details.append(d_next)\n    \n    # Compute energies for each level\n    # E_j = sum(d_j[k]^2)\n    energies = [np.sum(d**2) for d in all_details]\n    \n    # Compute total detail energy\n    total_energy = np.sum(energies)\n    \n    # A small tolerance for floating-point comparison with zero\n    if total_energy > 1e-12:\n        max_energy = np.max(energies)\n        # np.argmax returns the first index of the maximum value,\n        # satisfying the tie-breaking rule (smallest j).\n        # Levels are 1-indexed, so we add 1.\n        j_star = np.argmax(energies) + 1\n        rho = max_energy / total_energy\n    else:\n        # If total energy is zero, use the specified values.\n        j_star = 0\n        rho = 0.0\n        \n    return [j_star, rho]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Global parameters from the problem statement\n    N = 256\n    J = 5\n    n = np.arange(N)\n    \n    # Define the test cases\n    test_cases = [\n        # Case 1: Low-frequency sinusoidal residual\n        (\n            np.sin(2 * np.pi * 4 * n / N),\n            np.zeros(N)\n        ),\n        # Case 2: High-frequency sinusoidal residual\n        (\n            np.sin(2 * np.pi * 40 * n / N),\n            np.zeros(N)\n        ),\n        # Case 3: Perfect model, zero residual\n        (\n            np.sin(2 * np.pi * 10 * n / N),\n            np.sin(2 * np.pi * 10 * n / N)\n        ),\n        # Case 4: Localized transient residual\n        (\n            np.exp(-(n - 100)**2 / (2 * 5**2)),\n            np.zeros(N)\n        )\n    ]\n\n    results = []\n    for y_exp, y_mod in test_cases:\n        # Calculate the residual signal for the current case\n        residual = y_exp - y_mod\n        \n        # Analyze the residual and get [j*, rho]\n        result = analyze_residual(residual, J)\n        results.append(result)\n\n    # Format the final output string precisely as required: [[j1,rho1],[j2,rho2],...]\n    # The format string {res[1]:.6f} ensures rho is rounded to 6 decimal places.\n    result_strings = [f\"[{res[0]},{res[1]:.6f}]\" for res in results]\n    final_output = \"[\" + \",\".join(result_strings) + \"]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2450301"}]}