{"hands_on_practices": [{"introduction": "To begin our practical exploration of scalability, we start with the foundational principle that governs all parallel computing: Amdahl's Law. This law provides a stark reminder that even with infinite processors, the speedup of a task is ultimately limited by its inherently serial components. This exercise [@problem_id:2433433] grounds this theory in the familiar context of a parallel software build, challenging you to dissect a process into its serial and parallelizable parts and calculate the realistic speedup. Mastering this calculation is the first step toward developing an intuition for performance ceilings in any parallel system.", "problem": "A large software project is built using a dependency-aware build tool that supports parallel job execution with a maximum concurrency of $N$ jobs (invoked as a flag analogous to \"make -j N\"). On a single core, careful profiling yields the following end-to-end timeline for one complete build of a single executable:\n\n- Pre-build dependency discovery, rule expansion, and global task graph construction: $12$ s. This phase is implemented by a single-threaded tool.\n- Compilation proper (per-translation-unit preprocessing, parsing, optimization, and code generation): $340$ s of Central Processing Unit (CPU) time that can be partitioned into independent tasks once inputs exist.\n- Source and header file Input/Output (I/O): $48$ s of aggregate time that, due to a single shared storage device and a serialized file system path in this environment, cannot be accelerated by adding more CPU cores. Treat this as inherently serial.\n- Final link and packaging to produce the executable: $20$ s. This step has a single consumer that starts only after all object files exist and proceeds sequentially.\n\nAssume that only the CPU-intensive compilation work can be parallelized across $N$ perfectly load-balanced, identical cores, with no additional runtime overheads beyond the phases described. All other phases are inherently serial in this environment.\n\nUsing only first principles (definitions of time-to-solution and speedup) and the scenario above, derive an expression for the theoretical speedup as a function of $N$, then evaluate it at $N=12$. Express your final answer as a unitless number and round to four significant figures.", "solution": "The problem statement is subjected to validation.\n\nStep 1: Extract Givens\n- Maximum concurrency: $N$ jobs\n- Pre-build phase time (serial): $T_{pre-build} = 12$ s\n- Compilation CPU time (parallelizable): $T_{compile,cpu} = 340$ s\n- Source and header file I/O time (serial): $T_{io} = 48$ s\n- Final link and packaging time (serial): $T_{link} = 20$ s\n- The compilation work is assumed to be perfectly parallelizable across $N$ cores.\n- All other specified phases are inherently serial.\n- The task is to derive the theoretical speedup $S$ as a function of $N$ and evaluate it for $N=12$, rounding to four significant figures.\n\nStep 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective. It describes a classic scenario for applying Amdahl's Law, a fundamental principle in computational engineering and parallel computing. The provided data are self-contained, consistent, and plausible. The assumptions, such as perfect load balancing and zero overhead, are standard idealizations used to isolate the core concept of scalability limits due to serial bottlenecks. The problem is not flawed; it is a straightforward exercise in performance modeling.\n\nStep 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\nThe total time to complete a task can be decomposed into two components: a portion that is inherently serial and a portion that is parallelizable. Let $T_{serial}$ be the total time consumed by serial tasks, and $T_{parallel}$ be the time consumed by the parallelizable task when executed on a single core.\n\nFrom the problem statement, the total serial time is the sum of the times for the pre-build, I/O, and linking phases:\n$$T_{serial} = T_{pre-build} + T_{io} + T_{link}$$\n$$T_{serial} = 12\\,\\text{s} + 48\\,\\text{s} + 20\\,\\text{s} = 80\\,\\text{s}$$\n\nThe portion of the work that can be parallelized is the compilation proper, which takes $T_{parallel} = 340\\,\\text{s}$ of CPU time on a single core.\n\nThe total time to solution on a single core, which we denote as $T(1)$, is the sum of the serial and parallel components:\n$$T(1) = T_{serial} + T_{parallel} = 80\\,\\text{s} + 340\\,\\text{s} = 420\\,\\text{s}$$\n\nWhen the task is executed on $N$ cores, the time for the serial portion remains unchanged. The time for the parallelizable portion is reduced by a factor of $N$, under the assumption of perfect parallelization and load balancing. The total time to solution on $N$ cores, $T(N)$, is therefore:\n$$T(N) = T_{serial} + \\frac{T_{parallel}}{N}$$\nSubstituting the known values, we have the expression for the time to solution as a function of $N$:\n$$T(N) = 80 + \\frac{340}{N}$$\n\nTheoretical speedup, $S(N)$, is defined as the ratio of the time to solution on a single processor to the time to solution on $N$ processors.\n$$S(N) = \\frac{T(1)}{T(N)}$$\n\nUsing the derived expressions for $T(1)$ and $T(N)$, we obtain the general formula for the speedup:\n$$S(N) = \\frac{T_{serial} + T_{parallel}}{T_{serial} + \\frac{T_{parallel}}{N}}$$\nSubstituting the numerical values into this expression gives:\n$$S(N) = \\frac{420}{80 + \\frac{340}{N}}$$\nThis is the required expression for the theoretical speedup as a function of $N$.\n\nThe problem requires evaluation of this speedup for $N=12$.\n$$S(12) = \\frac{420}{80 + \\frac{340}{12}}$$\nWe first evaluate the denominator:\n$$80 + \\frac{340}{12} = 80 + \\frac{85}{3} = \\frac{240}{3} + \\frac{85}{3} = \\frac{325}{3}$$\nNow we compute the speedup:\n$$S(12) = \\frac{420}{\\frac{325}{3}} = \\frac{420 \\times 3}{325} = \\frac{1260}{325}$$\nTo simplify this fraction, we can divide the numerator and denominator by their greatest common divisor. Both are divisible by $5$:\n$$S(12) = \\frac{252}{65}$$\nPerforming the division to obtain a decimal value:\n$$S(12) = 3.876923...$$\nThe problem asks for the answer to be rounded to four significant figures.\n$$S(12) \\approx 3.877$$\nThis result is consistent with Amdahl's Law, which demonstrates that the speedup is ultimately limited by the serial fraction of the code. In this case, the serial fraction is $\\frac{80}{420} \\approx 0.19$, which imposes a maximum theoretical speedup of $\\frac{1}{0.19...} = \\frac{420}{80} = 5.25$, regardless of how many cores are used. Our result for $N=12$ is correctly below this limit.", "answer": "$$\\boxed{3.877}$$", "id": "2433433"}, {"introduction": "Our first model assumed the parallel work could be perfectly distributed, but in many real-world applications, achieving a perfect workload distribution is impossible. This leads to the critical issue of load imbalance, where the total execution time is dictated by the single most overworked processor. This practice [@problem_id:2433435] asks you to model the performance of a parallel ray-tracing engine, a domain where some tasks (long-running rays) create a highly uneven workload. By calculating the effects of this imbalance, you will gain a deeper appreciation for why parallel efficiency is often as much about clever work distribution as it is about minimizing serial code.", "problem": "You are asked to construct a performance model for a ray-tracing engine that uses a static spatial domain decomposition across multiple processing elements. Rays traverse a grid of spatial cells; each traversal within a cell accumulates computational work, and each time a ray crosses from one processor’s subdomain to another, a communication overhead is incurred. Some rays travel long distances, causing load imbalance.\n\nAssume the following model and definitions:\n\n- There are $P$ identical processors. The scene is partitioned statically into $P$ spatial subdomains.\n- The total computational work is represented as per-processor counts of cell traversals. Let $W_j$ denote the number of cell traversals performed within processor $j$’s subdomain, for $j \\in \\{1,\\dots,P\\}$.\n- Let $X_j$ denote the number of inter-processor boundary crossings handled by processor $j$ (counted as communication events attributable to that processor).\n- Each cell traversal costs $c$ seconds. Each inter-processor boundary crossing costs $b$ seconds.\n- The serial runtime $T_1$ is the time taken by a single processor executing the same total number of cell traversals without any inter-processor communication, that is, only computation contributes to the runtime.\n- The predicted parallel runtime under static spatial decomposition, $T_P$, is given by the maximum across processors of the sum of computation and communication time on each processor.\n- The speedup is $S = T_1 / T_P$.\n- The parallel efficiency is $E = S / P$.\n- All times must be expressed in seconds. Report $T_1$ and $T_P$ in seconds, rounded to six decimal places. Report $S$ and $E$ as dimensionless decimal numbers rounded to six decimal places.\n\nFor each test case below, compute the list $[T_1, T_P, S, E]$.\n\nTest suite:\n\n- Case A (moderate imbalance, nonzero communication):\n  - $P = 4$, $c = 0.002\\,\\text{s}$, $b = 0.05\\,\\text{s}$,\n  - $W = [100, 120, 110, 90]$,\n  - $X = [3, 4, 2, 3]$.\n\n- Case B (single processor boundary case):\n  - $P = 1$, $c = 0.002\\,\\text{s}$, $b = 0.05\\,\\text{s}$,\n  - $W = [420]$,\n  - $X = [0]$.\n\n- Case C (severe load imbalance due to long rays):\n  - $P = 4$, $c = 0.002\\,\\text{s}$, $b = 0.05\\,\\text{s}$,\n  - $W = [100, 100, 100, 300]$,\n  - $X = [3, 3, 3, 20]$.\n\n- Case D (no communication overhead):\n  - $P = 4$, $c = 0.002\\,\\text{s}$, $b = 0.0\\,\\text{s}$,\n  - $W = [100, 120, 110, 90]$,\n  - $X = [3, 4, 2, 3]$.\n\n- Case E (idle processor present):\n  - $P = 5$, $c = 0.001\\,\\text{s}$, $b = 0.02\\,\\text{s}$,\n  - $W = [0, 50, 50, 50, 50]$,\n  - $X = [0, 1, 1, 1, 1]$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a sublist of four floating-point numbers $[T_1, T_P, S, E]$ rounded to six decimal places, and the overall output is a list of these sublists in the same order as the test suite. For example, an output with two cases would look like $[[\\dots],[\\dots]]$.", "solution": "The problem statement has been validated and is deemed valid. It is a well-posed, scientifically grounded problem in computational performance modeling, free of contradictions or ambiguities.\n\nThe analysis is based on a fundamental model of parallel computing performance, which accounts for computational work, communication overhead, and load imbalance. The metrics to be computed—serial runtime ($T_1$), parallel runtime ($T_P$), speedup ($S$), and parallel efficiency ($E$)—are standard in the field.\n\nThe governing equations are as follows:\n\n1.  **Serial Runtime ($T_1$)**: This represents the time to complete the total computational work on a single processor. Communication overhead does not exist in a serial execution. The total computational work is the sum of traversals across all subdomains.\n    $$W_{total} = \\sum_{j=1}^{P} W_j$$\n    The serial runtime is then:\n    $$T_1 = W_{total} \\times c$$\n\n2.  **Parallel Runtime ($T_P$)**: In a statically partitioned, synchronized parallel system, the total runtime is determined by the processor that takes the longest time to finish its work. This \"straggler\" processor's time is the sum of its computational work and its communication overhead.\n    The time for an individual processor $j$ is:\n    $$T_{P,j} = W_j \\times c + X_j \\times b$$\n    The overall parallel runtime is the maximum of these individual times:\n    $$T_P = \\max_{j \\in \\{1, \\dots, P\\}} \\{ T_{P,j} \\}$$\n\n3.  **Speedup ($S$)**: Speedup measures the performance gain from parallelization. It is the ratio of serial runtime to parallel runtime.\n    $$S = \\frac{T_1}{T_P}$$\n\n4.  **Parallel Efficiency ($E$)**: Efficiency normalizes speedup by the number of processors, indicating how effectively the processors are utilized. Ideal efficiency is $1$, but it is typically reduced by load imbalance and communication costs.\n    $$E = \\frac{S}{P} = \\frac{T_1}{P \\times T_P}$$\n\nThese principles will now be applied to each test case. All time values are in seconds.\n\n**Case A**\n- Givens: $P = 4$, $c = 0.002$, $b = 0.05$, $W = [100, 120, 110, 90]$, $X = [3, 4, 2, 3]$.\n- Total work: $W_{total} = 100 + 120 + 110 + 90 = 420$.\n- Serial time: $T_1 = 420 \\times 0.002 = 0.84\\,\\text{s}$.\n- Per-processor times:\n  - $T_{P,1} = 100 \\times 0.002 + 3 \\times 0.05 = 0.20 + 0.15 = 0.35\\,\\text{s}$.\n  - $T_{P,2} = 120 \\times 0.002 + 4 \\times 0.05 = 0.24 + 0.20 = 0.44\\,\\text{s}$.\n  - $T_{P,3} = 110 \\times 0.002 + 2 \\times 0.05 = 0.22 + 0.10 = 0.32\\,\\text{s}$.\n  - $T_{P,4} = 90 \\times 0.002 + 3 \\times 0.05 = 0.18 + 0.15 = 0.33\\,\\text{s}$.\n- Parallel time: $T_P = \\max\\{0.35, 0.44, 0.32, 0.33\\} = 0.44\\,\\text{s}$.\n- Speedup: $S = 0.84 / 0.44 \\approx 1.909091$.\n- Efficiency: $E = 1.909091 / 4 \\approx 0.477273$.\n- Result: $[0.840000, 0.440000, 1.909091, 0.477273]$.\n\n**Case B**\n- Givens: $P = 1$, $c = 0.002$, $b = 0.05$, $W = [420]$, $X = [0]$.\n- Total work: $W_{total} = 420$.\n- Serial time: $T_1 = 420 \\times 0.002 = 0.84\\,\\text{s}$.\n- Per-processor times:\n  - $T_{P,1} = 420 \\times 0.002 + 0 \\times 0.05 = 0.84\\,\\text{s}$.\n- Parallel time: $T_P = \\max\\{0.84\\} = 0.84\\,\\text{s}$. As expected, for $P=1$, $T_P = T_1$ since communication is zero.\n- Speedup: $S = 0.84 / 0.84 = 1.000000$.\n- Efficiency: $E = 1.000000 / 1 = 1.000000$.\n- Result: $[0.840000, 0.840000, 1.000000, 1.000000]$.\n\n**Case C**\n- Givens: $P = 4$, $c = 0.002$, $b = 0.05$, $W = [100, 100, 100, 300]$, $X = [3, 3, 3, 20]$.\n- Total work: $W_{total} = 100 + 100 + 100 + 300 = 600$.\n- Serial time: $T_1 = 600 \\times 0.002 = 1.20\\,\\text{s}$.\n- Per-processor times:\n  - $T_{P,1} = 100 \\times 0.002 + 3 \\times 0.05 = 0.20 + 0.15 = 0.35\\,\\text{s}$.\n  - $T_{P,2} = 100 \\times 0.002 + 3 \\times 0.05 = 0.20 + 0.15 = 0.35\\,\\text{s}$.\n  - $T_{P,3} = 100 \\times 0.002 + 3 \\times 0.05 = 0.20 + 0.15 = 0.35\\,\\text{s}$.\n  - $T_{P,4} = 300 \\times 0.002 + 20 \\times 0.05 = 0.60 + 1.00 = 1.60\\,\\text{s}$.\n- Parallel time: $T_P = \\max\\{0.35, 0.35, 0.35, 1.60\\} = 1.60\\,\\text{s}$.\n- Speedup: $S = 1.20 / 1.60 = 0.750000$. A speedup less than $1$ indicates parallel slowdown.\n- Efficiency: $E = 0.750000 / 4 = 0.187500$.\n- Result: $[1.200000, 1.600000, 0.750000, 0.187500]$.\n\n**Case D**\n- Givens: $P = 4$, $c = 0.002$, $b = 0.0$, $W = [100, 120, 110, 90]$, $X = [3, 4, 2, 3]$.\n- Total work: $W_{total} = 100 + 120 + 110 + 90 = 420$.\n- Serial time: $T_1 = 420 \\times 0.002 = 0.84\\,\\text{s}$.\n- Per-processor times ($b=0$):\n  - $T_{P,1} = 100 \\times 0.002 = 0.20\\,\\text{s}$.\n  - $T_{P,2} = 120 \\times 0.002 = 0.24\\,\\text{s}$.\n  - $T_{P,3} = 110 \\times 0.002 = 0.22\\,\\text{s}$.\n  - $T_{P,4} = 90 \\times 0.002 = 0.18\\,\\text{s}$.\n- Parallel time: $T_P = \\max\\{0.20, 0.24, 0.22, 0.18\\} = 0.24\\,\\text{s}$.\n- Speedup: $S = 0.84 / 0.24 = 3.500000$.\n- Efficiency: $E = 3.500000 / 4 = 0.875000$. The only source of inefficiency is load imbalance.\n- Result: $[0.840000, 0.240000, 3.500000, 0.875000]$.\n\n**Case E**\n- Givens: $P = 5$, $c = 0.001$, $b = 0.02$, $W = [0, 50, 50, 50, 50]$, $X = [0, 1, 1, 1, 1]$.\n- Total work: $W_{total} = 0 + 50 + 50 + 50 + 50 = 200$.\n- Serial time: $T_1 = 200 \\times 0.001 = 0.20\\,\\text{s}$.\n- Per-processor times:\n  - $T_{P,1} = 0 \\times 0.001 + 0 \\times 0.02 = 0.00\\,\\text{s}$.\n  - $T_{P,2} = 50 \\times 0.001 + 1 \\times 0.02 = 0.05 + 0.02 = 0.07\\,\\text{s}$.\n  - $T_{P,3} = 50 \\times 0.001 + 1 \\times 0.02 = 0.07\\,\\text{s}$.\n  - $T_{P,4} = 50 \\times 0.001 + 1 \\times 0.02 = 0.07\\,\\text{s}$.\n  - $T_{P,5} = 50 \\times 0.001 + 1 \\times 0.02 = 0.07\\,\\text{s}$.\n- Parallel time: $T_P = \\max\\{0.00, 0.07, 0.07, 0.07, 0.07\\} = 0.07\\,\\text{s}$.\n- Speedup: $S = 0.20 / 0.07 \\approx 2.857143$.\n- Efficiency: $E = 2.857143 / 5 \\approx 0.571429$.\n- Result: $[0.200000, 0.070000, 2.857143, 0.571429]$.\n\nThe calculations are complete.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes performance metrics for a parallel ray-tracing engine model.\n    \"\"\"\n    test_cases = [\n        {\n            \"P\": 4, \"c\": 0.002, \"b\": 0.05,\n            \"W\": np.array([100, 120, 110, 90]),\n            \"X\": np.array([3, 4, 2, 3])\n        },\n        {\n            \"P\": 1, \"c\": 0.002, \"b\": 0.05,\n            \"W\": np.array([420]),\n            \"X\": np.array([0])\n        },\n        {\n            \"P\": 4, \"c\": 0.002, \"b\": 0.05,\n            \"W\": np.array([100, 100, 100, 300]),\n            \"X\": np.array([3, 3, 3, 20])\n        },\n        {\n            \"P\": 4, \"c\": 0.002, \"b\": 0.0,\n            \"W\": np.array([100, 120, 110, 90]),\n            \"X\": np.array([3, 4, 2, 3])\n        },\n        {\n            \"P\": 5, \"c\": 0.001, \"b\": 0.02,\n            \"W\": np.array([0, 50, 50, 50, 50]),\n            \"X\": np.array([0, 1, 1, 1, 1])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        P = case[\"P\"]\n        c = case[\"c\"]\n        b = case[\"b\"]\n        W = case[\"W\"]\n        X = case[\"X\"]\n\n        # 1. Calculate Serial Runtime (T_1)\n        W_total = np.sum(W)\n        T_1 = W_total * c\n\n        # 2. Calculate Parallel Runtime (T_P)\n        # Time for each processor is a vector operation\n        T_Pj = W * c + X * b\n        T_P = np.max(T_Pj)\n        \n        # Handle case where T_P might be zero (all processors idle)\n        # to avoid division by zero. If T_P is 0, T_1 must also be 0.\n        # Speedup would be ill-defined, typically considered 1 in this context.\n        if T_P == 0.0:\n            S = 1.0 # By convention, if no work is done.\n        else:\n            S = T_1 / T_P\n\n        # 4. Calculate Parallel Efficiency (E)\n        E = S / P\n\n        all_results.append([T_1, T_P, S, E])\n\n    # Format the final output string as a list of lists of floats\n    # with six decimal places.\n    formatted_case_results = []\n    for result_list in all_results:\n        formatted_list_str = '[' + ','.join([f'{val:.6f}' for val in result_list]) + ']'\n        formatted_case_results.append(formatted_list_str)\n    \n    final_output_string = '[' + ','.join(formatted_case_results) + ']'\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "2433435"}, {"introduction": "The most advanced performance analysis involves moving from applying pre-defined models to interpreting real-world measurement data. Performance curves often show non-intuitive behavior, such as \"retrograde scaling,\" where adding more processors actually slows the system down. This phenomenon, which Amdahl's Law cannot explain, is captured by Gunther's Universal Scalability Law (USL). In this final exercise [@problem_id:2433475], you will act as a performance analyst, using the USL to diagnose the root cause of a scalability bottleneck from a set of throughput measurements, distinguishing between contention ($\\sigma$) and the more severe coherency ($\\kappa$) penalties.", "problem": "A software service is deployed on a multicore Central Processing Unit (CPU) and serves independent requests using a pool of worker threads. The request mix and code paths are unchanged as the thread count varies. You measure the steady-state throughput $X(N)$ in transactions per second as a function of the number of concurrent worker threads $N$ under a fixed external load generator. The following points are obtained: $(N, X(N)) \\in \\{(1, 100), (2, 190), (4, 360), (8, 680), (12, 820), (16, 780)\\}$. Define the speedup as $S(N) = X(N)/X(1)$. Assume that the Universal Scalability Law (USL) applies in this setting and that its parameters reflect, respectively, a contention effect with coefficient $\\sigma$ and a coherency effect with coefficient $\\kappa$.\n\nUsing only the measurements above and foundational definitions of throughput and speedup, decide which qualitative regime is most consistent with the data and what it implies for scaling beyond $N = 16$. Choose the single best option.\n\nA. The system is primarily contention-limited with negligible coherency effects (i.e., $\\sigma > 0$, $\\kappa \\approx 0$); throughput will increase monotonically toward a finite asymptote above $X(16)$ and will not decrease as $N$ increases.\n\nB. The system is primarily coherency-limited with non-negligible pairwise interaction costs (i.e., $\\kappa > 0$ not dominated by $\\sigma$); throughput exhibits a maximum near $N \\approx 12$ and will decrease for larger $N$.\n\nC. The system exhibits near-perfect linear scalability (i.e., both $\\sigma \\approx 0$ and $\\kappa \\approx 0$); throughput is approximately $X(N) \\approx N \\cdot X(1)$ over the observed range.\n\nD. The system is limited by a fixed serial fraction in the sense of Amdahl’s law; throughput increases sublinearly but strictly monotonically with $N$ and cannot decrease for larger $N$.", "solution": "The problem statement must first be validated for scientific and logical integrity.\n\n**Step 1: Extract Givens**\n- The system is a software service on a multicore CPU using a pool of worker threads to serve independent requests.\n- The request mix and code paths are constant as the thread count varies.\n- Throughput, $X(N)$, is measured as a function of the number of concurrent worker threads, $N$.\n- A fixed external load is applied.\n- The measured data points are $(N, X(N)) \\in \\{(1, 100), (2, 190), (4, 360), (8, 680), (12, 820), (16, 780)\\}$, where $X(N)$ is in transactions per second.\n- Speedup is defined as $S(N) = X(N)/X(1)$.\n- The Universal Scalability Law (USL) is assumed to apply.\n- The USL parameters are $\\sigma$ for contention and $\\kappa$ for coherency.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded. The Universal Scalability Law is a widely accepted model for analyzing the performance of parallel and concurrent systems. The experimental setup described—measuring the throughput of a threaded service on a multicore CPU—is a standard application domain for such analysis. The provided data are plausible for a real-world system, exhibiting initial speedup followed by performance degradation at higher concurrency. The problem is well-posed, providing sufficient data and a defined theoretical framework (the USL) to evaluate the qualitative behavior of the system. The terms are defined unambiguously. There are no contradictions, factual errors, or subjective claims.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. I will proceed with a solution.\n\n**Derivation**\n\nThe Universal Scalability Law (USL) models the speedup $S(N)$ as a function of the number of processors or threads $N$. The canonical form is given by:\n$$S(N) = \\frac{N}{1 + \\sigma(N-1) + \\kappa N(N-1)}$$\nHere, $\\sigma$ represents the fraction of work that is serialized due to contention for shared resources, and $\\kappa$ represents the additional overhead from maintaining data coherency, which typically scales quadratically with the number of workers (due to pairwise interactions).\n\nThroughput $X(N)$ is related to speedup $S(N)$ by the definition provided: $S(N) = X(N)/X(1)$. Therefore, the USL model for throughput is:\n$$X(N) = X(1) \\cdot S(N) = \\frac{X(1) \\cdot N}{1 + \\sigma(N-1) + \\kappa N(N-1)}$$\nFrom the data, we have $X(1) = 100$ transactions per second.\n\nWe must analyze the behavior of the measured throughput data in the context of this model. Let us calculate the speedup for each measured point:\n- For $N=1$: $X(1) = 100$. $S(1) = 100/100 = 1.0$. This is by definition.\n- For $N=2$: $X(2) = 190$. $S(2) = 190/100 = 1.9$.\n- For $N=4$: $X(4) = 360$. $S(4) = 360/100 = 3.6$.\n- For $N=8$: $X(8) = 680$. $S(8) = 680/100 = 6.8$.\n- For $N=12$: $X(12) = 820$. $S(12) = 820/100 = 8.2$.\n- For $N=16$: $X(16) = 780$. $S(16) = 780/100 = 7.8$.\n\nThe critical observation is that the throughput increases up to $N=12$ and then decreases at $N=16$, since $X(16) = 780 < X(12) = 820$. This phenomenon is known as retrograde scaling.\n\nLet us analyze the USL equation to understand what causes such behavior. The throughput $X(N)$ is a rational function of $N$. Its behavior for large $N$ is determined by the highest-order terms in the numerator and denominator.\n- The numerator is linear in $N$.\n- The denominator is a quadratic in $N$: $\\kappa N^2 + (\\sigma - \\kappa)N + (1 - \\sigma)$.\n\nIf the coherency effect is negligible ($\\kappa \\approx 0$), the USL reduces to Amdahl's Law (or a contention-only model):\n$$X(N) \\approx \\frac{X(1) \\cdot N}{1 + \\sigma(N-1)}$$\nIn this case, for $\\sigma > 0$, the function $X(N)$ is strictly monotonically increasing with $N$. As $N \\to \\infty$, the throughput approaches a finite asymptote:\n$$\\lim_{N\\to\\infty} X(N) = \\lim_{N\\to\\infty} \\frac{X(1) \\cdot N}{\\sigma N} = \\frac{X(1)}{\\sigma}$$\nThis model cannot account for a decrease in throughput.\n\nIf the coherency effect is non-negligible ($\\kappa > 0$), the denominator is dominated by the $\\kappa N^2$ term for large $N$. The throughput behaves as:\n$$X(N) \\sim \\frac{X(1) \\cdot N}{\\kappa N^2} = \\frac{X(1)}{\\kappa N}$$\nAs $N \\to \\infty$, $X(N) \\to 0$. Since $X(N)$ starts at $X(1) > 0$ and eventually goes to $0$, it must reach a maximum at some finite value of $N$. The location of this peak, $N_{peak}$, can be found by treating $N$ as a continuous variable and setting the derivative $dX(N)/dN$ to zero. This calculation yields $N_{peak} \\approx \\sqrt{(1-\\sigma)/\\kappa}$. A peak exists for a finite, real $N > 1$ if and only if $\\kappa > 0$ and $\\sigma < 1$.\n\nThe observed data, with $X(16) < X(12)$, decisively indicates that the system has passed its scalability peak. This is only possible if the coherency parameter $\\kappa$ is positive and significant.\n\n**Option-by-Option Analysis**\n\nA. The system is primarily contention-limited with negligible coherency effects (i.e., $\\sigma > 0$, $\\kappa \\approx 0$); throughput will increase monotonically toward a finite asymptote above $X(16)$ and will not decrease as $N$ increases.\nThis corresponds to a model where $\\kappa \\approx 0$. As derived above, such a model predicts strictly monotonic increasing throughput. The data explicitly contradicts this prediction, as throughput decreases from $N=12$ to $N=16$.\nVerdict: **Incorrect**.\n\nB. The system is primarily coherency-limited with non-negligible pairwise interaction costs (i.e., $\\kappa > 0$ not dominated by $\\sigma$); throughput exhibits a maximum near $N \\approx 12$ and will decrease for larger $N$.\nThis option posits a non-negligible coherency effect ($\\kappa > 0$). As derived, this is the necessary condition for the throughput to exhibit a maximum and then decrease. The data show that the maximum throughput occurs at or near $N=12$, followed by a decrease. This perfectly aligns with the theoretical implications of a significant $\\kappa$ term. The statement \"will decrease for larger N\" is a correct extrapolation based on the USL model with $\\kappa > 0$.\nVerdict: **Correct**.\n\nC. The system exhibits near-perfect linear scalability (i.e., both $\\sigma \\approx 0$ and $\\kappa \\approx 0$); throughput is approximately $X(N) \\approx N \\cdot X(1)$ over the observed range.\nThis implies $S(N) \\approx N$. A check against the data shows large deviations. For instance, for $N=12$, linear scalability predicts $X(12) = 12 \\cdot X(1) = 12 \\cdot 100 = 1200$. The measured value is $820$, a significant sub-linearity. For $N=16$, linear scalability predicts $X(16) = 1600$, while the measurement is $780$. The model is clearly a poor fit.\nVerdict: **Incorrect**.\n\nD. The system is limited by a fixed serial fraction in the sense of Amdahl’s law; throughput increases sublinearly but strictly monotonically with $N$ and cannot decrease for larger $N$.\nAmdahl's law is the special case of the USL where $\\kappa = 0$. This is the same physical model as described in option A. It only accounts for contention, not coherency. As such, it cannot explain the observed decrease in throughput. The data proves the system is not described by Amdahl's Law in this range.\nVerdict: **Incorrect**.", "answer": "$$\\boxed{B}$$", "id": "2433475"}]}