{"hands_on_practices": [{"introduction": "Assembling system matrices, such as the mass or stiffness matrix, is a fundamental step in any finite element-type method. In Isogeometric Analysis (IGA), a key advantage is that the basis functions are piecewise polynomials, allowing us to often integrate their products *exactly* using numerical quadrature. This exercise [@problem_id:2405752] challenges you to determine the minimum number of Gauss quadrature points needed to exactly integrate the mass matrix, a critical skill for balancing accuracy and computational efficiency in your simulations.", "problem": "In the context of Isogeometric Analysis (IGA), consider a $1$D model problem on the parametric domain $\\xi \\in [0,1]$ discretized using a B-spline basis $\\{B_{i}^{p}(\\xi)\\}$ of degree $p$ defined on an open, nondecreasing knot vector with simple internal knots. Focus on a single nonzero knot span $[\\xi_{a},\\xi_{b}] \\subset [0,1]$. Assume the physical domain mapping is the identity, i.e., $x=\\xi$, so the Jacobian is $1$, and that the mass density $\\rho$ is constant on $[\\xi_{a},\\xi_{b}]$. The element mass matrix over this knot span has entries\n$$\nM_{ij}^{(e)} \\;=\\; \\int_{\\xi_{a}}^{\\xi_{b}} \\rho\\, B_{i}^{p}(\\xi)\\, B_{j}^{p}(\\xi)\\, \\mathrm{d}\\xi.\n$$\nUsing Gauss–Legendre quadrature with $n$ points per knot span to assemble $M_{ij}^{(e)}$ exactly for every pair of indices $(i,j)$ whose supports intersect $[\\xi_{a},\\xi_{b}]$, determine the minimum number of Gauss points $n$ per knot span required for exact integration as a function of the spline degree $p$. Provide your answer as a single closed-form expression in terms of $p$.", "solution": "The problem requires the determination of the minimum number of Gauss–Legendre quadrature points, denoted by $n$, needed for the exact evaluation of the element mass matrix entries $M_{ij}^{(e)}$ over a single knot span $[\\xi_{a},\\xi_{b}]$. The formula for these entries is given by\n$$\nM_{ij}^{(e)} = \\int_{\\xi_{a}}^{\\xi_{b}} \\rho\\, B_{i}^{p}(\\xi)\\, B_{j}^{p}(\\xi)\\, \\mathrm{d}\\xi\n$$\nwhere $\\rho$ is a constant mass density and $B_{i}^{p}(\\xi)$ are B-spline basis functions of degree $p$.\n\nThe core of the problem lies in analyzing the integrand of this integral. The mass density $\\rho$ is stated to be constant. The functions $B_{i}^{p}(\\xi)$ are B-spline basis functions of degree $p$. A key property of B-splines is that on any given non-zero knot span, such as $[\\xi_{a}, \\xi_{b}]$, each basis function $B_{i}^{p}(\\xi)$ that has support on this span is a single polynomial of degree exactly $p$.\n\nThe integrand is the product of three terms: $\\rho$, $B_{i}^{p}(\\xi)$, and $B_{j}^{p}(\\xi)$. Since $\\rho$ is a constant (a polynomial of degree $0$), the degree of the entire integrand, let's call it $f(\\xi) = \\rho\\, B_{i}^{p}(\\xi)\\, B_{j}^{p}(\\xi)$, is determined by the product of the two B-spline basis functions. The degree of a product of polynomials is the sum of their individual degrees.\nTherefore, the degree of the polynomial $B_{i}^{p}(\\xi)\\, B_{j}^{p}(\\xi)$ on the interval $[\\xi_{a}, \\xi_{b}]$ is $p + p = 2p$. The integrand $f(\\xi)$ is thus a polynomial of degree $2p$.\n\nThe problem specifies the use of Gauss–Legendre quadrature for numerical integration. A fundamental theorem of numerical analysis states that a Gauss–Legendre quadrature rule with $n$ integration points can exactly integrate any polynomial of degree up to, and including, $2n-1$.\n\nFor the integral of $M_{ij}^{(e)}$ to be computed exactly, the degree of the quadrature rule must be sufficient to handle the degree of the integrand. This leads to the following inequality:\n$$\n2n-1 \\ge \\deg(f(\\xi))\n$$\nSubstituting the degree of our integrand, we have:\n$$\n2n-1 \\ge 2p\n$$\nWe must find the minimum integer value of $n$ that satisfies this condition. Rearranging the inequality to solve for $n$:\n$$\n2n \\ge 2p + 1\n$$\n$$\nn \\ge p + \\frac{1}{2}\n$$\nSince the number of quadrature points $n$ must be an integer, we must take the smallest integer value that is greater than or equal to $p + \\frac{1}{2}$. This is equivalent to taking the ceiling of $p + \\frac{1}{2}$.\n$$\nn_{\\min} = \\lceil p + 0.5 \\rceil\n$$\nGiven that the spline degree $p$ is an integer (e.g., $1$, $2$, $3$, ...), the quantity $p+0.5$ is never an integer. Therefore, the ceiling function will always round up to the next integer.\n$$\nn_{\\min} = p + 1\n$$\nTo verify this result: if we choose $n = p+1$ points, the Gauss-Legendre rule will exactly integrate polynomials of degree up to $2(p+1) - 1 = 2p+2-1=2p+1$. Since our integrand is a polynomial of degree $2p$, and $2p+1 \\ge 2p$, this number of points is sufficient. If we were to choose $n=p$ points, the rule would only guarantee exactness for polynomials of degree up to $2p-1$, which is insufficient for a polynomial of degree $2p$.\n\nThus, the minimum number of Gauss points required per knot span for the exact assembly of the mass matrix is $p+1$. This result is independent of the specific indices $i$ and $j$, as long as their corresponding basis functions have overlapping support on the knot span in question, and is also independent of the constant density $\\rho$ and the identity mapping.", "answer": "$$\\boxed{p+1}$$", "id": "2405752"}, {"introduction": "To solve complex problems efficiently, we often want to refine the computational mesh only where it's needed most, a process known as adaptive mesh refinement (AMR). This requires a reliable way to \"estimate\" where the error in our numerical solution is largest. This practice [@problem_id:2405738] provides hands-on experience with a posteriori error estimation by guiding you to implement a concrete, residual-based error indicator, a common technique that provides invaluable feedback for adaptive simulations.", "problem": "You are given a one-dimensional setting in Isogeometric Analysis (IGA) where the trial space consists of piecewise cubic, globally continuously differentiable splines (that is, $C^1$ splines) on a partition of the interval $[0,1]$. For a piecewise cubic function $u(x)$ of class $C^1$, the third derivative $u^{(3)}(x)$ is constant on each element and may be discontinuous at element interfaces. Define a local, jump-based error indicator per element using only the jumps of $u^{(3)}(x)$ across element boundaries.\n\nLet the mesh be defined by nodes $x_0, x_1, \\dots, x_N$ with $0 = x_0 < x_1 < \\dots < x_N = 1$. For element $e \\in \\{1, \\dots, N\\}$, define $E_e = [x_{e-1}, x_e]$ and element size $h_e = x_e - x_{e-1}$. On each element $E_e$, the third derivative is constant and denoted $g_e = u^{(3)}|_{E_e}$. At an internal node $x_i$ with $i \\in \\{1, \\dots, N-1\\}$, define the jump of the third derivative by\n$$\n[u^{(3)}]_{x_i} = \\lim_{x \\to x_i^+} u^{(3)}(x) - \\lim_{x \\to x_i^-} u^{(3)}(x) = g_{i+1} - g_i.\n$$\nAt the boundary nodes $x_0$ and $x_N$, set the jump to zero:\n$$\n[u^{(3)}]_{x_0} = 0, \\quad [u^{(3)}]_{x_N} = 0.\n$$\nDefine the local indicator for element $e$ by\n$$\n\\eta_e = \\sqrt{h_e} \\, \\sqrt{ \\left( [u^{(3)}]_{x_{e-1}} \\right)^2 + \\left( [u^{(3)}]_{x_e} \\right)^2 }.\n$$\n\nYour task is to compute the list of local indicators $\\eta_e$ for each element for each of the following test cases. Each test case is fully specified by its node coordinates and the per-element constants $g_e$ for $u^{(3)}$.\n\nTest Suite (each case gives $(x_0, \\dots, x_N)$ and $(g_1, \\dots, g_N)$):\n- Case $1$ (uniform mesh, nontrivial internal jumps): nodes $[0, 0.25, 0.5, 0.75, 1]$, values $[2, 2, 5, 1]$.\n- Case $2$ (uniform mesh, no jumps): nodes $[0, \\tfrac{1}{3}, \\tfrac{2}{3}, 1]$, values $[-1.2, -1.2, -1.2]$.\n- Case $3$ (nonuniform mesh, large contrast): nodes $[0, 0.1, 0.4, 1]$, values $[0, 7, -7]$.\n- Case $4$ (single element, boundary-only): nodes $[0, 1]$, values $[3.14]$.\n\nAll computations are dimensionless; no physical units are required. Angles are not involved. The result for each test case is the list $[\\eta_1, \\dots, \\eta_N]$ of floats.\n\nFinal Output Format: Your program should produce a single line of output containing the results for the four cases as a list of lists, where each inner list corresponds to one test case, in the same order as specified above. Each floating-point number must be rounded to $6$ decimal places. The printed format must have no spaces. For example: \n$$\n[[0.000000,1.500000,2.500000,2.000000],[0.000000,0.000000,0.000000],[2.213594,8.573214,10.844353],[0.000000]]\n$$", "solution": "The problem presented is scientifically grounded and well-posed, falling squarely within the domain of a posteriori error estimation for the numerical solution of differential equations. Specifically, it concerns the computation of a local error indicator for one-dimensional, $C^1$-continuous cubic splines, a common scenario in Isogeometric Analysis (IGA). The problem is entirely formal and procedural, requiring the direct application of the provided mathematical definitions. We will proceed with a systematic exposition of the computational method.\n\nLet the domain of interest be the interval $[0,1]$. This domain is partitioned by a mesh defined by a set of $N+1$ nodes, $x_0, x_1, \\dots, x_N$, such that $0 = x_0 < x_1 < \\dots < x_N = 1$. This partition creates $N$ elements, where the $e$-th element is the subinterval $E_e = [x_{e-1}, x_e]$ for $e \\in \\{1, \\dots, N\\}$. The length, or size, of element $E_e$ is given by $h_e = x_e - x_{e-1}$.\n\nThe approximate solution, $u(x)$, is a piecewise cubic spline that is globally continuously differentiable (of class $C^1$). This implies that its third derivative, $u^{(3)}(x)$, is a piecewise constant function. The problem provides these constant values for each element, denoted as $g_e = u^{(3)}|_{E_e}$.\n\nThe error indicator is based on the discontinuities, or jumps, of this third derivative at the element interfaces (the nodes). At any internal node $x_i$ for $i \\in \\{1, \\dots, N-1\\}$, the jump is defined as the difference between the value of $u^{(3)}(x)$ to the right and to the left of the node:\n$$\n[u^{(3)}]_{x_i} = \\lim_{x \\to x_i^+} u^{(3)}(x) - \\lim_{x \\to x_i^-} u^{(3)}(x) = g_{i+1} - g_i.\n$$\nAs per the problem statement, the jumps at the boundary nodes $x_0$ and $x_N$ are defined to be zero:\n$$\n[u^{(3)}]_{x_0} = 0, \\quad [u^{(3)}]_{x_N} = 0.\n$$\n\nWith these definitions, the local error indicator $\\eta_e$ for an element $E_e$ is constructed from its size $h_e$ and the jumps at its two boundary nodes, $x_{e-1}$ and $x_e$. The explicit formula is:\n$$\n\\eta_e = \\sqrt{h_e} \\sqrt{ \\left( [u^{(3)}]_{x_{e-1}} \\right)^2 + \\left( [u^{(3)}]_{x_e} \\right)^2 }.\n$$\n\nTo compute the indicators $\\eta_e$ for the provided test cases, we implement a clear, step-by-step algorithm:\n1.  From the input data for a test case, we identify the node coordinates $(x_0, \\dots, x_N)$ and the piecewise constant third derivative values $(g_1, \\dots, g_N)$. The number of elements is $N$.\n2.  We calculate the vector of element sizes, $\\mathbf{h}$, of length $N$, where the component $h_e$ corresponds to the size of element $E_e$.\n3.  We compute the vector of nodal jumps, $\\mathbf{J}$, of length $N+1$. The components $J_i = [u^{(3)}]_{x_i}$ for $i \\in \\{0, \\dots, N\\}$ are populated as follows:\n    - The boundary components are set to zero: $J_0 = 0$ and $J_N = 0$.\n    - The internal components are calculated from the derivative values: $J_i = g_{i+1} - g_i$ for $i \\in \\{1, \\dots, N-1\\}$.\n    - For a single-element mesh ($N=1$), there are no internal nodes, and the jump vector is simply $\\mathbf{J} = [0, 0]$.\n4.  Finally, we compute the vector of local indicators, $\\boldsymbol{\\eta}$, of length $N$. For each element $E_e$ (where $e \\in \\{1, \\dots, N\\}$), we apply the formula using the pre-computed sizes and jumps:\n    $$\n    \\eta_e = \\sqrt{h_e} \\sqrt{ (J_{e-1})^2 + (J_e)^2 }.\n    $$\nThe Python program provided in the final answer executes this well-defined algorithm for each test case, producing the required list of local indicators.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes local, jump-based error indicators for C^1 cubic splines\n    for a series of test cases in a 1D setting.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (list of node coordinates, list of g_e values).\n    test_cases = [\n        ([0, 0.25, 0.5, 0.75, 1], [2, 2, 5, 1]),\n        ([0, 1/3, 2/3, 1], [-1.2, -1.2, -1.2]),\n        ([0, 0.1, 0.4, 1], [0, 7, -7]),\n        ([0, 1], [3.14])\n    ]\n\n    all_results = []\n    for nodes_list, g_values_list in test_cases:\n        nodes = np.array(nodes_list, dtype=np.float64)\n        g_values = np.array(g_values_list, dtype=np.float64)\n\n        # N is the number of elements\n        N = len(g_values)\n        \n        # Calculate element sizes h_e = x_e - x_{e-1}\n        # h has N elements. h[i] corresponds to h_{i+1}.\n        h = np.diff(nodes)\n        \n        # Calculate jumps of the third derivative at each node.\n        # The jumps array has N+1 elements, for nodes x_0 to x_N.\n        # jumps[i] corresponds to the jump at node x_i.\n        jumps = np.zeros(N + 1, dtype=np.float64)\n        \n        # Jumps at internal nodes x_i for i=1,...,N-1\n        # Formula: [u^(3)]_{x_i} = g_{i+1} - g_i\n        # In 0-based indexing for g_values array:\n        # g_i corresponds to g_values[i-1]\n        # g_{i+1} corresponds to g_values[i]\n        # So jump at node x_i is g_values[i] - g_values[i-1].\n        for i in range(1, N):\n            jumps[i] = g_values[i] - g_values[i-1]\n        \n        # Jumps at boundary nodes x_0 and x_N are 0, which is the default\n        # value from np.zeros.\n        \n        # Calculate local indicators eta_e for each element e=1,...,N.\n        # The indicators array has N elements.\n        # Formula: eta_e = sqrt(h_e) * sqrt(([u^(3)]_{x_{e-1}})^2 + ([u^(3)]_{x_e})^2)\n        # In 0-based indexing:\n        # e_idx from 0 to N-1 refers to element E_{e_idx+1}.\n        # h_{e_idx+1} is h[e_idx].\n        # Jumps at its ends (x_{e_idx}, x_{e_idx+1}) are jumps[e_idx] and jumps[e_idx+1].\n        indicators = []\n        for e_idx in range(N):\n            h_e = h[e_idx]\n            jump_left = jumps[e_idx]\n            jump_right = jumps[e_idx+1]\n            eta_e = np.sqrt(h_e) * np.sqrt(jump_left**2 + jump_right**2)\n            indicators.append(eta_e)\n            \n        all_results.append(indicators)\n\n    # Format the final output string as specified.\n    # e.g., [[0.000000,1.500000],[...]] without spaces.\n    formatted_inner_lists = []\n    for res_list in all_results:\n        formatted_numbers = [f\"{num:.6f}\" for num in res_list]\n        formatted_inner_lists.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output = f\"[{','.join(formatted_inner_lists)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2405738"}, {"introduction": "One of the most powerful applications of Isogeometric Analysis lies in design optimization, where the geometry itself is part of the solution. By representing a structure's material layout with the same spline basis used for the analysis, IGA creates a seamless link between the design space and the physics simulation. This problem [@problem_id:2405802] guides you through a classic topology optimization task, revealing how a seemingly complex numerical problem can yield an elegant analytical solution through careful mathematical analysis—a hallmark of deep engineering insight.", "problem": "Consider a one-dimensional axial bar occupying the interval $[0,L]$ with $L=1$. The left end at $x=0$ is fixed and a tensile force $F$ is applied at $x=L$. The cross-sectional area is constant with $A=1$. The bar is made of a linearly elastic material whose modulus depends on a design field (material density) $\\rho(x)$ through the linear interpolation\n$$\nE(\\rho)=E_{\\min}+\\rho\\,(E_0-E_{\\min}),\n$$\nwith bounds $\\rho(x)\\in[\\rho_{\\min},1]$. The material density $\\rho(x)$ is represented as a Non-Uniform B-spline (NUBS) field on the parametric interval $u\\in[0,1]$ using an open, clamped, uniform knot vector and degree $k$ basis functions $\\{N_i^{(k)}(u)\\}_{i=1}^n$, with the identity geometry map $x=L\\,u$. Specifically,\n$$\n\\rho(x)=\\sum_{i=1}^n c_i\\,N_i^{(k)}\\!\\left(\\tfrac{x}{L}\\right),\n$$\nwhere $c_i\\in[\\rho_{\\min},1]$ are the density control variables, $n$ is the number of control points, and the basis satisfies $\\sum_{i=1}^n N_i^{(k)}(u)=1$ for all $u\\in[0,1]$.\n\nFor a statically determinate axial bar under the stated loading, the compliance (work of external forces) for a given density field $\\rho(x)$ equals\n$$\nC(\\mathbf{c})=\\frac{F^2}{A}\\int_0^L \\frac{1}{E(\\rho(x))}\\,\\mathrm{d}x,\n$$\nwhere $\\mathbf{c}=(c_1,\\dots,c_n)$. The design is subject to the average-density (volume fraction) constraint\n$$\n\\frac{1}{L}\\int_0^L \\rho(x)\\,\\mathrm{d}x=V^\\star,\n$$\ntogether with the bound constraints $\\rho_{\\min}\\le c_i\\le 1$ for all $i\\in\\{1,\\dots,n\\}$. Assume $V^\\star\\in[\\rho_{\\min},1]$.\n\nYour task is to determine, for each test case below, the value of the minimal compliance $C^\\star$ and one corresponding optimal vector of control densities $\\mathbf{c}^\\star$ that achieves it, under the stated model with $p=1$ in the modulus interpolation above. The B-spline basis is open, clamped, and uniformly spaced over $[0,1]$; the explicit knot vector is determined by $n$ and $k$ in the standard way (first and last knots repeated $k+1$ times, internal knots uniformly spaced).\n\nTest suite (each case is independent):\n- Case $1$: $L=1$, $A=1$, $n=4$, $k=3$, $F=1$, $E_0=1$, $E_{\\min}=10^{-3}$, $\\rho_{\\min}=10^{-3}$, $V^\\star=0.4$, $p=1$.\n- Case $2$: $L=1$, $A=1$, $n=3$, $k=2$, $F=2$, $E_0=3$, $E_{\\min}=0.3$, $\\rho_{\\min}=0.05$, $V^\\star=0.2$, $p=1$.\n- Case $3$: $L=1$, $A=1$, $n=5$, $k=2$, $F=1.5$, $E_0=2$, $E_{\\min}=0.1$, $\\rho_{\\min}=0.1$, $V^\\star=0.1$, $p=1$.\n- Case $4$: $L=1$, $A=1$, $n=1$, $k=0$, $F=1$, $E_0=5$, $E_{\\min}=10^{-3}$, $\\rho_{\\min}=10^{-3}$, $V^\\star=0.8$, $p=1$.\n\nAnswer specification and final output format:\n- For each case, compute a pair consisting of the minimal compliance $C^\\star$ and one corresponding optimal control vector $\\mathbf{c}^\\star=[c_1^\\star,\\dots,c_n^\\star]$.\n- All quantities are dimensionless. Report all floating-point numbers with exactly $6$ digits after the decimal point.\n- Your program should produce a single line of output containing a list of length $4$, where each entry is itself a two-element list of the form $[C^\\star,[c_1^\\star,\\dots,c_n^\\star]]$. The entire line must be printed without any spaces. For example, an output with two hypothetical cases would look like $[[1.234000,[0.500000,0.500000]],[2.000000,[0.300000,0.300000,0.300000]]]$.", "solution": "The stated problem is a structural optimization task to minimize the compliance of a one-dimensional bar. The problem can be formally stated as:\nFind the vector of control variables $\\mathbf{c} = (c_1, \\dots, c_n)$ that minimizes the objective function:\n$$C(\\mathbf{c}) = \\frac{F^2}{A}\\int_0^L \\frac{1}{E(\\rho(x))}\\,\\mathrm{d}x$$\nsubject to the constraints:\n$$1. \\quad \\frac{1}{L} \\int_0^L \\rho(x)\\,\\mathrm{d}x = V^\\star$$\n$$2. \\quad \\rho_{\\min} \\le c_i \\le 1, \\quad \\text{for } i=1, \\dots, n$$\nwhere $\\rho(x) = \\sum_{i=1}^n c_i N_i^{(k)}(x/L)$ and $E(\\rho) = E_{\\min} + \\rho(E_0 - E_{\\min})$.\n\nLet us analyze the structure of this optimization problem. For a statically determinate bar under a constant axial force $F$, the axial stress $\\sigma = F/A$ is uniform along the length of the bar. The objective function is proportional to the total strain energy. We can analyze the integrand, which is a function of the local material density $\\rho$. Let $f(\\rho) = \\frac{1}{E(\\rho)} = \\frac{1}{E_{\\min} + \\rho(E_0 - E_{\\min})}$. We examine the convexity of this function by computing its second derivative with respect to $\\rho$:\n$$f'(\\rho) = -\\frac{E_0 - E_{\\min}}{\\left(E_{\\min} + \\rho(E_0 - E_{\\min})\\right)^2}$$\n$$f''(\\rho) = 2\\frac{(E_0 - E_{\\min})^2}{\\left(E_{\\min} + \\rho(E_0 - E_{\\min})\\right)^3}$$\nGiven that $E_0 > E_{\\min} > 0$ and the density $\\rho(x)$ is positive (since $c_i \\ge \\rho_{\\min} > 0$ and $N_i^{(k)} \\ge 0$), the denominator $E(\\rho)$ is always positive. Therefore, $f''(\\rho) > 0$, which proves that $f(\\rho)$ is a strictly convex function of $\\rho$.\n\nThe objective function is the integral of a strictly convex function. The constraints on the design variables $\\mathbf{c}$ are linear. This constitutes a convex optimization problem. For such problems, we can leverage Jensen's inequality for integrals, which states that for a convex function $f$ and a function $\\rho(x)$:\n$$\\frac{1}{L}\\int_0^L f(\\rho(x))\\,\\mathrm{d}x \\ge f\\left(\\frac{1}{L}\\int_0^L \\rho(x)\\,\\mathrm{d}x\\right)$$\nStrict inequality holds unless $\\rho(x)$ is constant. Applying this to our problem:\n$$\\frac{1}{L}\\int_0^L \\frac{1}{E(\\rho(x))}\\,\\mathrm{d}x \\ge \\frac{1}{E\\left(\\frac{1}{L}\\int_0^L \\rho(x)\\,\\mathrm{d}x\\right)}$$\nUsing the volume constraint $\\frac{1}{L}\\int_0^L \\rho(x)\\,\\mathrm{d}x = V^\\star$, the inequality becomes:\n$$\\int_0^L \\frac{1}{E(\\rho(x))}\\,\\mathrm{d}x \\ge \\frac{L}{E(V^\\star)}$$\nThe minimum value of the integral is achieved when the equality holds, which occurs if and only if the density distribution $\\rho^\\star(x)$ is constant. To satisfy the volume constraint, this constant must be $V^\\star$. Thus, the unique optimal density distribution is $\\rho^\\star(x) = V^\\star$.\n\nWe must now verify that this optimal density field is achievable within the specified B-spline representation. The B-spline basis functions possess the partition of unity property: $\\sum_{i=1}^n N_i^{(k)}(u) = 1$ for all $u \\in [0, 1]$. By setting all control variables $c_i$ to the same value $V^\\star$, we can represent the constant function $\\rho(x) = V^\\star$:\n$$\\rho(x) = \\sum_{i=1}^n V^\\star N_i^{(k)}\\left(\\frac{x}{L}\\right) = V^\\star \\sum_{i=1}^n N_i^{(k)}\\left(\\frac{x}{L}\\right) = V^\\star \\cdot 1 = V^\\star$$\nThis choice for the control vector, $\\mathbf{c}^\\star = (V^\\star, V^\\star, \\dots, V^\\star)$, is feasible. The problem statement guarantees $V^\\star \\in [\\rho_{\\min}, 1]$, so the box constraints $c_i \\in [\\rho_{\\min}, 1]$ are satisfied. The volume constraint is satisfied by construction.\n\nTherefore, the optimal vector of control variables is $\\mathbf{c}^\\star = (V^\\star, \\dots, V^\\star)$, and the number of control variables $n$ and the spline degree $k$ do not influence the optimal solution for this particular problem.\n\nThe minimal compliance $C^\\star$ is calculated by substituting $\\rho(x) = V^\\star$ into the compliance formula:\n$$C^\\star = \\frac{F^2}{A}\\int_0^L \\frac{1}{E(V^\\star)}\\,\\mathrm{d}x = \\frac{F^2 L}{A E(V^\\star)}$$\nSubstituting the expression for $E(V^\\star)$:\n$$C^\\star = \\frac{F^2 L}{A \\left(E_{\\min} + V^\\star(E_0 - E_{\\min})\\right)}$$\nThis analytical result allows for direct computation of the solution for each test case without requiring a numerical optimization procedure.\nThe calculation for each case is as follows:\n\n**Case 1:** $L=1, A=1, n=4, F=1, E_0=1, E_{\\min}=0.001, V^\\star=0.4$.\n$\\mathbf{c}^\\star = (0.4, 0.4, 0.4, 0.4)$.\n$C^\\star = \\frac{1^2 \\cdot 1}{1 \\cdot (0.001 + 0.4(1 - 0.001))} = \\frac{1}{0.4006} \\approx 2.496256$.\n\n**Case 2:** $L=1, A=1, n=3, F=2, E_0=3, E_{\\min}=0.3, V^\\star=0.2$.\n$\\mathbf{c}^\\star = (0.2, 0.2, 0.2)$.\n$C^\\star = \\frac{2^2 \\cdot 1}{1 \\cdot (0.3 + 0.2(3 - 0.3))} = \\frac{4}{0.84} \\approx 4.761905$.\n\n**Case 3:** $L=1, A=1, n=5, F=1.5, E_0=2, E_{\\min}=0.1, V^\\star=0.1$.\n$\\mathbf{c}^\\star = (0.1, 0.1, 0.1, 0.1, 0.1)$.\n$C^\\star = \\frac{1.5^2 \\cdot 1}{1 \\cdot (0.1 + 0.1(2 - 0.1))} = \\frac{2.25}{0.29} \\approx 7.758621$.\n\n**Case 4:** $L=1, A=1, n=1, F=1, E_0=5, E_{\\min}=0.001, V^\\star=0.8$.\n$\\mathbf{c}^\\star = (0.8)$.\n$C^\\star = \\frac{1^2 \\cdot 1}{1 \\cdot (0.001 + 0.8(5 - 0.001))} = \\frac{1}{4.0002} \\approx 0.249988$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D bar compliance minimization problem for the given test cases.\n\n    The problem is a convex optimization problem where the objective function is\n    the integral of a strictly convex function of density, and the constraints\n    are linear. By Jensen's inequality, the minimum compliance is achieved for\n    a uniform density distribution rho(x) = V_star. This distribution is\n    representable in the B-spline basis by setting all control variables\n    c_i = V_star. This leads to a simple analytical solution, bypassing\n    the need for numerical optimization.\n    \"\"\"\n    test_cases = [\n        # Case 1: L=1, A=1, n=4, k=3, F=1, E0=1, Emin=1e-3, rhomin=1e-3, V_star=0.4\n        {'L': 1, 'A': 1, 'n': 4, 'F': 1, 'E0': 1, 'E_min': 1e-3, 'V_star': 0.4},\n        # Case 2: L=1, A=1, n=3, k=2, F=2, E0=3, Emin=0.3, rhomin=0.05, V_star=0.2\n        {'L': 1, 'A': 1, 'n': 3, 'F': 2, 'E0': 3, 'E_min': 0.3, 'V_star': 0.2},\n        # Case 3: L=1, A=1, n=5, k=2, F=1.5, E0=2, Emin=0.1, rhomin=0.1, V_star=0.1\n        {'L': 1, 'A': 1, 'n': 5, 'F': 1.5, 'E0': 2, 'E_min': 0.1, 'V_star': 0.1},\n        # Case 4: L=1, A=1, n=1, k=0, F=1, E0=5, Emin=1e-3, rhomin=1e-3, V_star=0.8\n        {'L': 1, 'A': 1, 'n': 1, 'F': 1, 'E0': 5, 'E_min': 1e-3, 'V_star': 0.8},\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case['n']\n        L = case['L']\n        A = case['A']\n        F = case['F']\n        E0 = case['E0']\n        E_min = case['E_min']\n        V_star = case['V_star']\n\n        # Optimal control vector has all entries equal to V_star\n        c_star = [V_star] * n\n\n        # Calculate Young's modulus for the optimal uniform density\n        E_star = E_min + V_star * (E0 - E_min)\n\n        # Calculate the minimal compliance\n        C_star = (F**2 * L) / (A * E_star)\n\n        results.append((C_star, c_star))\n    \n    # Format the output string as specified, with no spaces\n    result_strings = []\n    for C_star, c_star_list in results:\n        c_list_str = f'[{\",\".join(f\"{c:.6f}\" for c in c_star_list)}]'\n        pair_str = f'[{C_star:.6f},{c_list_str}]'\n        result_strings.append(pair_str)\n\n    final_output = f'[{\",\".join(result_strings)}]'\n    print(final_output)\n\nsolve()\n```", "id": "2405802"}]}