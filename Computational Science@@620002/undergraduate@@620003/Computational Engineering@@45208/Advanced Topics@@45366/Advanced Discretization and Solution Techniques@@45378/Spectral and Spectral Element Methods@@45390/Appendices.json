{"hands_on_practices": [{"introduction": "The Fourier spectral method is celebrated for its \"spectral accuracy,\" achieving exceptionally fast convergence for smooth, periodic functions. This exercise provides a practical and crucial lesson on the boundaries of this power. You will implement a Fourier-based solver for the simple Poisson equation $u''(x) = f(x)$ and apply it to both a well-behaved periodic problem and problems with non-periodic boundary conditions [@problem_id:2437055]. By comparing the numerical error in these cases, you will directly observe the Gibbs phenomenon and understand why inappropriately applying a Fourier basis leads to poor accuracy, motivating the need for other spectral methods like those based on Chebyshev or Legendre polynomials.", "problem": "Consider the one-dimensional boundary value problem for the unknown function $u(x)$,\n$$u''(x) = f(x), \\quad x \\in (0,1),$$\ntogether with boundary data that may be either periodic or non-periodic. Let $u_{\\mathrm{per}}$ denote the solution that satisfies the periodic boundary data $u(0)=u(1)$ and $u'(0)=u'(1)$, and let $u_{\\mathrm{D}}$ denote the solution that satisfies the non-periodic Dirichlet boundary data $u(0)=0$ and $u(1)=0$.\n\nDefine, for any positive even integer $N$, the equispaced grid $\\{x_j\\}_{j=0}^{N-1}$ with $x_j = j/N$. Let $f_N$ be the restriction of $f$ to this grid. Define $u_N$ to be the unique $1$-periodic trigonometric polynomial (zero spatial mean) whose discrete second derivative in the sense of trigonometric polynomials equals $f_N$ with its discrete mean removed. More precisely, in the discrete Fourier representation with wavenumbers $k_m = 2\\pi m$ for integer $m$ corresponding to the grid, $u_N$ satisfies\n$$-(k_m)^2 \\widehat{u}_m = \\widehat{f}_m \\quad \\text{for all modes with } m \\neq 0,$$\nand $\\widehat{u}_0 = 0$, where the hat denotes the discrete Fourier coefficient on the $N$-point grid, and the arithmetic for wavenumbers is understood modulo $N$. Angles are to be interpreted in radians.\n\nFor each test case below, you must compute the discrete $L^2$ error of $u_N$ against a specified target solution $u_\\star$ on the grid, defined as\n$$E_N = \\left(\\frac{1}{N} \\sum_{j=0}^{N-1} \\left(u_N(x_j) - u_\\star(x_j)\\right)^2 \\right)^{1/2}.$$\nAll answers must be unitless real numbers.\n\nUse the following test suite of four cases, and produce the errors $E_N$ in the order listed. Each case specifies $f$, the target solution $u_\\star$, and $N$:\n\n- Case $1$ (periodic, happy path): $f(x) = \\sin(2\\pi x)$, target $u_\\star(x) = -\\sin(2\\pi x)/(2\\pi)^2$, $N = 64$.\n- Case $2$ (non-periodic Dirichlet, constant forcing): $f(x) = -2$, target $u_\\star(x) = x(1-x)$, $N = 64$.\n- Case $3$ (non-periodic Dirichlet, endpoint-derivative mismatch): $f(x) = -\\pi^2 \\sin(\\pi x)$, target $u_\\star(x) = \\sin(\\pi x)$, $N = 64$.\n- Case $4$ (refinement of Case $2$): $f(x) = -2$, target $u_\\star(x) = x(1-x)$, $N = 128$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[E_{64}^{(1)},E_{64}^{(2)},E_{64}^{(3)},E_{128}^{(4)}]$, where each entry is the corresponding discrete $L^2$ error $E_N$ for the respective case.", "solution": "The problem statement is subjected to validation prior to any attempt at a solution.\n\n### Step 1: Extract Givens\n- **Governing Equation**: $u''(x) = f(x)$, for $x \\in (0,1)$.\n- **Unknown Function**: $u(x)$.\n- **Boundary Conditions**:\n    - Periodic: $u_{\\mathrm{per}}(0)=u_{\\mathrm{per}}(1)$ and $u'_{\\mathrm{per}}(0)=u'_{\\mathrm{per}}(1)$.\n    - Dirichlet: $u_{\\mathrm{D}}(0)=0$ and $u_{\\mathrm{D}}(1)=0$.\n- **Discretization**:\n    - Grid: Equispaced points $\\{x_j\\}_{j=0}^{N-1}$ with $x_j = j/N$ for a positive even integer $N$.\n    - Discrete functions: $f_N$ is the restriction of $f(x)$ to the grid.\n- **Numerical Solution Definition**: $u_N$ is a $1$-periodic trigonometric polynomial with zero spatial mean ($\\widehat{u}_0 = 0$). It is defined by the relation in discrete Fourier space:\n  $$-(k_m)^2 \\widehat{u}_m = \\widehat{f}_m \\quad \\text{for all modes with } m \\neq 0$$\n  where $\\widehat{u}_m$ and $\\widehat{f}_m$ are discrete Fourier coefficients, and $k_m = 2\\pi m$ are the wavenumbers. The right-hand side is stated to correspond to \"$f_N$ with its discrete mean removed\", which is implicitly handled by solving only for modes with $m \\neq 0$.\n- **Error Metric**: Discrete $L^2$ error, $$E_N = \\left(\\frac{1}{N} \\sum_{j=0}^{N-1} \\left(u_N(x_j) - u_\\star(x_j)\\right)^2 \\right)^{1/2}.$$\n- **Test Cases**:\n    1.  $f(x) = \\sin(2\\pi x)$, $u_\\star(x) = -\\sin(2\\pi x)/(2\\pi)^2$, $N = 64$.\n    2.  $f(x) = -2$, $u_\\star(x) = x(1-x)$, $N = 64$.\n    3.  $f(x) = -\\pi^2 \\sin(\\pi x)$, $u_\\star(x) = \\sin(\\pi x)$, $N = 64$.\n    4.  $f(x) = -2$, $u_\\star(x) = x(1-x)$, $N = 128$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed against the required criteria.\n\n- **Scientifically Grounded**: The problem describes the application of a Fourier spectral method to solve the one-dimensional Poisson equation. This is a fundamental and standard technique in computational science and engineering. The method and principles are well-established. This criterion is met.\n- **Well-Posed**: The continuous boundary value problems (both periodic and Dirichlet) are well-posed. The numerical scheme is also well-posed. The equation for the Fourier coefficients, $-(k_m)^2 \\widehat{u}_m = \\widehat{f}_m$, can be solved for $\\widehat{u}_m$ for all non-zero wavenumbers ($k_m \\neq 0$). The singularity at $k_0 = 0$ is handled by the solvability condition for the periodic Poisson equation (requiring the mean of the forcing term to be zero, which the numerical method enforces) and the imposition of a unique solution by setting the mean of the solution to zero ($\\widehat{u}_0 = 0$). This criterion is met.\n- **Objective**: The problem is stated using precise mathematical language and definitions. There is no subjective or ambiguous terminology. This criterion is met.\n- **Completeness and Consistency**: The problem provides all necessary functions, parameters, and definitions to construct a solution. There are no contradictions in the provided information. This criterion is met.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is scientifically sound, well-posed, objective, and self-contained. A solution will be provided.\n\n### Solution\nThe problem requires the solution of the one-dimensional Poisson equation, $u''(x) = f(x)$, on the domain $x \\in (0,1)$ using a Fourier spectral method. The core principle of Fourier spectral methods is the transformation of differential operators into algebraic operators in Fourier space.\n\nThe Fourier series representation of a function $u(x)$ on a $1$-periodic domain is $$u(x) = \\sum_{m=-\\infty}^{\\infty} \\check{u}_m e^{i 2\\pi m x}.$$ Differentiation with respect to $x$ corresponds to multiplication of the $m$-th Fourier coefficient $\\check{u}_m$ by $i 2\\pi m$. Consequently, the second derivative, $u''(x)$, has Fourier coefficients $(- (2\\pi m)^2) \\check{u}_m = -k_m^2 \\check{u}_m$, where $k_m = 2\\pi m$ is the wavenumber.\n\nThe prescribed numerical method is a discrete analogue of this principle. The algorithm proceeds as follows:\n\n1.  **Discretization**: For a given even integer $N$, the domain $[0,1)$ is discretized into an equispaced grid of $N$ points, $x_j = j/N$ for $j = 0, 1, \\dots, N-1$.\n\n2.  **Forcing Term Evaluation**: The forcing function $f(x)$ is evaluated at these grid points to obtain a vector of values $\\mathbf{f} = [f(x_0), f(x_1), \\dots, f(x_{N-1})]^T$.\n\n3.  **Forward Fourier Transform**: The vector $\\mathbf{f}$ is transformed into Fourier space using the Discrete Fourier Transform (DFT), typically implemented via the Fast Fourier Transform (FFT) algorithm. This yields the vector of discrete Fourier coefficients $\\hat{\\mathbf{f}}$:\n    $$ \\widehat{f}_m = \\sum_{j=0}^{N-1} f(x_j) e^{-i 2\\pi m j / N} $$\n    The index $m$ corresponds to discrete frequencies which, for a domain of length $L=1$, are integers. Standard numerical libraries provide routines to correctly order these frequencies, typically as $m \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$.\n\n4.  **Solve in Fourier Space**: The differential equation $u''(x) = f(x)$ becomes an algebraic equation for the discrete Fourier coefficients. The discrete second derivative operator corresponds to multiplication by $-(k_m)^2$, where $k_m$ are the wavenumbers associated with the discrete frequencies $m$. For a domain of length $1$, $k_m = 2\\pi m$. The problem for the coefficients $\\widehat{u}_m$ is:\n    $$ -(k_m)^2 \\widehat{u}_m = \\widehat{f}_m $$\n    This equation is only solved for non-zero modes ($m \\neq 0$), as specified. For the zero-frequency mode ($m=0$), the wavenumber $k_0$ is zero, leading to a singularity. This reflects the fact that the periodic Poisson problem has a solution only if the integral (or discrete sum) of the forcing term is zero. Furthermore, the solution is only unique up to an additive constant. The problem resolves this by specifying that the solution $u_N$ must have a zero mean, which is equivalent to setting its zeroth Fourier coefficient to zero: $\\widehat{u}_0 = 0$.\n    Thus, the vector of solution coefficients $\\hat{\\mathbf{u}}$ is computed as:\n    $$ \\widehat{u}_m = \\begin{cases} 0 & \\text{if } m = 0 \\\\ -\\frac{\\widehat{f}_m}{k_m^2} & \\text{if } m \\neq 0 \\end{cases} $$\n\n5.  **Inverse Fourier Transform**: The numerical solution in physical space, $u_N(x_j)$, is recovered by applying the Inverse DFT (implemented via IFFT) to the coefficient vector $\\hat{\\mathbf{u}}$:\n    $$ u_N(x_j) = \\frac{1}{N} \\sum_{m=0}^{N-1} \\widehat{u}_m e^{i 2\\pi m j / N} $$\n    Since the original forcing function $f(x)$ is real-valued, the solution $u_N(x_j)$ must also be real. The real part of the IFFT result is taken to discard any negligible imaginary components arising from floating-point arithmetic errors.\n\n6.  **Error Calculation**: The target solution $u_\\star(x)$ is evaluated on the grid $x_j$ to get $\\mathbf{u}_\\star$. The discrete $L^2$ error $E_N$ is then calculated as the Root Mean Square Error between the numerical solution $\\mathbf{u}_N$ and the target solution $\\mathbf{u}_\\star$:\n    $$ E_N = \\sqrt{\\frac{1}{N} \\sum_{j=0}^{N-1} (u_N(x_j) - u_\\star(x_j))^2} $$\n\n### Analysis of Test Cases\n- **Case 1**: $f(x) = \\sin(2\\pi x)$, $u_\\star(x) = -\\sin(2\\pi x)/(2\\pi)^2$, $N = 64$. The function $f(x)$ is a single, $1$-periodic Fourier mode with zero mean. The target solution $u_\\star(x)$ is the exact periodic solution with zero mean. The Fourier spectral method is exact for problems whose solutions are contained within the basis of trigonometric polynomials. As such, the error $E_{64}$ is expected to be near machine precision.\n\n- **Case 2**: $f(x) = -2$, $u_\\star(x) = x(1-x)$, $N = 64$. The target solution $u_\\star(x)$ satisfies the Dirichlet boundary conditions $u_\\star(0) = u_\\star(1) = 0$. However, it is not a $1$-periodic function, as its derivatives at the boundaries do not match: $u'_\\star(0) = 1$ while $u'_\\star(1) = -1$. The spectral method computes a periodic solution $u_N$. The error $u_N - u_\\star$ is dominated by the inability of the periodic trigonometric polynomial to represent the non-periodic target function accurately, especially at the boundaries. This boundary-condition mismatch leads to slow convergence (Gibbs phenomenon), and the error $E_{64}$ will be significant.\n\n- **Case 3**: $f(x) = -\\pi^2 \\sin(\\pi x)$, $u_\\star(x) = \\sin(\\pi x)$, $N = 64$. This case is analogous to Case 2. The target solution $u_\\star(x)$ satisfies Dirichlet boundary conditions but not periodic ones, as $u'_\\star(0) = \\pi \\neq u'_\\star(1) = -\\pi$. A large error is expected for the same reasons.\n\n- **Case 4**: $f(x) = -2$, $u_\\star(x) = x(1-x)$, $N = 128$. This is a grid refinement of Case 2. While the error is expected to be large, increasing $N$ should reduce the error. The rate of error reduction will be algebraic ($\\mathcal{O}(N^{-p})$ for some small $p>0$) rather than the exponential convergence observed for smooth, periodic problems. Comparing the result with Case 2 will show this sub-optimal convergence.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the discrete L2 error for a Fourier spectral solution to u''=f\n    for four different test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (periodic, happy path)\n        (lambda x: np.sin(2 * np.pi * x), \n         lambda x: -np.sin(2 * np.pi * x) / (2 * np.pi)**2, \n         64),\n        # Case 2 (non-periodic Dirichlet, constant forcing)\n        (lambda x: -2.0 + 0*x, \n         lambda x: x * (1 - x), \n         64),\n        # Case 3 (non-periodic Dirichlet, endpoint-derivative mismatch)\n        (lambda x: -(np.pi**2) * np.sin(np.pi * x), \n         lambda x: np.sin(np.pi * x), \n         64),\n        # Case 4 (refinement of Case 2)\n        (lambda x: -2.0 + 0*x, \n         lambda x: x * (1 - x), \n         128),\n    ]\n\n    results = []\n    for f_func, u_star_func, N in test_cases:\n        # 1. Define the grid\n        # x_j = j/N for j = 0, ..., N-1\n        x = np.arange(N) / N\n\n        # 2. Evaluate the forcing function on the grid\n        f_vals = f_func(x)\n\n        # 3. Compute the DFT of the forcing function\n        f_hat = np.fft.fft(f_vals)\n\n        # 4. Define wavenumbers and solve in Fourier space\n        # Frequencies m = [0, 1, ..., N/2-1, -N/2, ..., -1] for L=1\n        # The grid spacing d = 1/N\n        freqs = np.fft.fftfreq(N, d=1.0/N)\n        # Wavenumbers k_m = 2*pi*m\n        k = 2 * np.pi * freqs\n        \n        # The equation for Fourier coefficients is -(k_m)^2 * u_hat_m = f_hat_m\n        # We solve for u_hat_m = -f_hat_m / k_m^2 for m != 0\n        # and set u_hat_0 = 0\n        \n        # To avoid division by zero for k_0 = 0, we can use np.divide with a 'where' clause.\n        # Initialize u_hat to zeros.\n        u_hat = np.zeros_like(f_hat, dtype=complex)\n        \n        # Calculate k^2, avoiding direct computation at k=0 to prevent warnings.\n        k_squared = k**2\n        \n        # The condition k != 0 is equivalent to freqs != 0\n        nonzero_mask = (freqs != 0)\n        \n        u_hat[nonzero_mask] = -f_hat[nonzero_mask] / k_squared[nonzero_mask]\n\n        # 5. Transform back to physical space via Inverse FFT\n        u_N_vals = np.fft.ifft(u_hat)\n        \n        # The solution should be real; take the real part to discard numerical noise.\n        u_N_vals = u_N_vals.real\n\n        # 6. Evaluate the target solution and compute the error\n        u_star_vals = u_star_func(x)\n        \n        # Discrete L2 error (Root Mean Square Error)\n        error = np.sqrt(np.mean((u_N_vals - u_star_vals)**2))\n        results.append(error)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.10e}' for r in results)}]\")\n\nsolve()\n```", "id": "2437055"}, {"introduction": "Having explored the critical importance of periodicity for Fourier methods, we now turn to a problem where this property is a perfect fit: analyzing the steady-state behavior of a forced linear oscillator. Instead of simulating the system in time until transients decay, a spectral method allows for a direct and elegant solution. This practice involves transforming the governing ordinary differential equation into the frequency domain, where derivatives become algebraic multiplications, allowing you to solve for the periodic steady-state response with a simple division [@problem_id:2437054]. This powerful technique is fundamental in signal processing and control theory and showcases the computational efficiency of working in the spectral domain.", "problem": "Consider the linear time-invariant second-order ordinary differential equation (ODE) with periodic forcing over one period,\n$$\n\\frac{d^2 y}{dt^2} + 2 \\zeta \\omega_0 \\frac{d y}{dt} + \\omega_0^2 y = f(t),\n$$\nwhere $y(t)$ is unknown, $\\omega_0 > 0$ is the natural frequency, $\\zeta \\ge 0$ is the damping ratio, and $f(t)$ is a given function that is periodic with period $T$, that is, $f(t + T) = f(t)$ for all $t$. The goal is to compute directly the periodic steady-state solution $y_{\\mathrm{per}}(t)$ that satisfies the ODE and the periodicity condition $y_{\\mathrm{per}}(t+T) = y_{\\mathrm{per}}(t)$, without time-stepping to steady state.\n\nFundamental base to use:\n- The set of complex exponentials $\\{ e^{i \\omega_k t} \\}$, where $\\omega_k = \\frac{2\\pi k}{T}$ for integer $k$, forms an orthogonal basis for square-integrable $T$-periodic functions over one period.\n- For any sufficiently smooth periodic function $g(t)$ with period $T$, differentiation in time corresponds to multiplication by $i \\omega_k$ in the Fourier series representation; specifically, if $g(t) = \\sum_{k=-\\infty}^{\\infty} \\hat{g}_k e^{i \\omega_k t}$, then $\\frac{dg}{dt} = \\sum_{k=-\\infty}^{\\infty} (i \\omega_k) \\hat{g}_k e^{i \\omega_k t}$ and $\\frac{d^2 g}{dt^2} = \\sum_{k=-\\infty}^{\\infty} (-\\omega_k^2) \\hat{g}_k e^{i \\omega_k t}$.\n\nTask:\n1. Starting from these principles, derive how to compute $y_{\\mathrm{per}}(t)$ directly in the frequency domain using a Fourier spectral method in time. The derivation must make clear why the problem diagonalizes in the Fourier basis and why this yields the periodic steady-state solution without time-stepping.\n2. Implement a program that:\n   - Discretizes one period $[0, T)$ using $N$ equispaced nodes, where $N$ is specified in each test case.\n   - Constructs samples of $f(t)$ on this grid and uses the Discrete Fourier Transform (via the Fast Fourier Transform (FFT)) to obtain discrete Fourier coefficients.\n   - Computes the discrete Fourier coefficients of $y_{\\mathrm{per}}(t)$ by algebraic manipulation in the frequency domain consistent with the ODE and periodicity.\n   - Recovers $y_{\\mathrm{per}}(t)$ on the grid by the inverse transform.\n   - Verifies correctness by comparing the numerical $y_{\\mathrm{per}}(t)$ against an analytic periodic steady-state solution for the specific forcing functions provided in the test suite below.\n   - Reports, for each test case, the maximum absolute error over the $N$ grid points.\n3. All angles must be treated in radians. Time, if interpreted physically, is in seconds, but you are not required to output units. The final reported errors are dimensionless real numbers.\n\nTest suite:\nImplement and evaluate the following four test cases, which together exercise a range of behaviors including multi-harmonic forcing, zero-frequency forcing, and near-resonant response. In all cases, ensure all evaluations are over exactly one period $T$ with $N$ equispaced points.\n\n- Case $1$ (single-tone forcing, fundamental period):\n  - Parameters: $\\omega_0 = 1$, $\\zeta = 0.05$, $\\Omega = 1$, $T = \\frac{2\\pi}{\\Omega} = 2\\pi$, $N = 256$.\n  - Forcing: $f(t) = \\sin(\\Omega t)$.\n  - Analytic steady-state reference: a sinusoid at frequency $\\Omega$ with amplitude and phase determined by the frequency response of the ODE.\n- Case $2$ (bi-harmonic forcing):\n  - Parameters: $\\omega_0 = 3$, $\\zeta = 0.1$, $\\Omega = 2$, $T = \\frac{2\\pi}{\\Omega} = \\pi$, $N = 256$.\n  - Forcing: $f(t) = \\sin(\\Omega t) + 0.5 \\cos(2\\Omega t)$.\n  - Analytic steady-state reference: the superposition of responses at frequencies $\\Omega$ and $2\\Omega$.\n- Case $3$ (constant forcing, zero-frequency content):\n  - Parameters: $\\omega_0 = 2$, $\\zeta = 0.2$, $T = 2\\pi$, $N = 256$.\n  - Forcing: $f(t) = 1.5$ for all $t$.\n  - Analytic steady-state reference: a constant $y_{\\mathrm{per}}(t) = \\frac{1.5}{\\omega_0^2}$.\n- Case $4$ (near-resonant forcing with small damping):\n  - Parameters: $\\omega_0 = 2$, $\\zeta = 0.01$, $\\Omega = 1.98$, $T = \\frac{2\\pi}{\\Omega}$, $N = 256$.\n  - Forcing: $f(t) = \\cos(\\Omega t)$.\n  - Analytic steady-state reference: a sinusoid at frequency $\\Omega$ with amplitude and phase determined by the frequency response.\n\nFor the analytic steady-state reference in Cases $1$, $2$, and $4$, use the frequency response of the ODE: for a harmonic input at angular frequency $\\omega$, the steady-state output is obtained by multiplying the input’s complex amplitude by the transfer function\n$$\nH(i\\omega) = \\frac{1}{\\omega_0^2 - \\omega^2 + i \\, 2 \\zeta \\omega_0 \\omega},\n$$\nso that the real output for $\\cos(\\omega t)$ is $|H(i\\omega)| \\cos(\\omega t - \\phi)$ and for $\\sin(\\omega t)$ is $|H(i\\omega)| \\sin(\\omega t - \\phi)$ where\n$$\n|H(i\\omega)| = \\frac{1}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2 \\zeta \\omega_0 \\omega)^2}}, \\quad \\phi = \\operatorname{atan2}(2 \\zeta \\omega_0 \\omega, \\omega_0^2 - \\omega^2).\n$$\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[$error for Case $1$, error for Case $2$, error for Case $3$, error for Case $4]$, for example $[e_1,e_2,e_3,e_4]$. Each $e_j$ must be a real-valued floating-point number.", "solution": "We begin from the linear time-invariant second-order ordinary differential equation with periodic forcing,\n$$\n\\frac{d^2 y}{dt^2} + 2 \\zeta \\omega_0 \\frac{d y}{dt} + \\omega_0^2 y = f(t),\n$$\non the interval $[0, T)$ with periodic boundary conditions $y(t+T) = y(t)$ and likewise for derivatives. We seek the periodic steady-state solution $y_{\\mathrm{per}}(t)$.\n\nPrinciple-based derivation using spectral methods:\n1. Any sufficiently smooth $T$-periodic function $g(t)$ admits a Fourier series $g(t) = \\sum_{k=-\\infty}^{\\infty} \\hat{g}_k e^{i \\omega_k t}$ with $\\omega_k = \\frac{2\\pi k}{T}$. Differentiation acts diagonally on this basis:\n   $$\n   \\frac{dg}{dt} = \\sum_{k=-\\infty}^{\\infty} (i \\omega_k) \\hat{g}_k e^{i \\omega_k t}, \\quad \\frac{d^2 g}{dt^2} = \\sum_{k=-\\infty}^{\\infty} (-\\omega_k^2) \\hat{g}_k e^{i \\omega_k t}.\n   $$\n   This follows from the fundamental fact that exponentials are eigenfunctions of constant-coefficient differential operators.\n2. Expand both the unknown $y(t) = \\sum_{k} \\hat{y}_k e^{i \\omega_k t}$ and the forcing $f(t) = \\sum_{k} \\hat{f}_k e^{i \\omega_k t}$. Substitute into the ODE and exploit linearity and orthogonality to equate coefficients of $e^{i \\omega_k t}$ for each integer $k$:\n   $$\n   \\left(-\\omega_k^2\\right) \\hat{y}_k + 2 \\zeta \\omega_0 \\left(i \\omega_k\\right) \\hat{y}_k + \\omega_0^2 \\hat{y}_k = \\hat{f}_k.\n   $$\n   Therefore, for each mode $k$,\n   $$\n   \\hat{y}_k = \\frac{\\hat{f}_k}{\\omega_0^2 - \\omega_k^2 + i \\, 2 \\zeta \\omega_0 \\omega_k}.\n   $$\n   The denominator is nonzero for all $\\omega_k$ when $\\omega_0 > 0$, so the mapping is well-defined. This diagonalization in the Fourier basis shows that the periodic steady-state solution is obtained directly by filtering the forcing’s Fourier coefficients by the transfer function $H(i\\omega_k)$.\n3. The steady response to any periodic forcing is thus given by\n   $$\n   y_{\\mathrm{per}}(t) = \\sum_{k=-\\infty}^{\\infty} \\frac{\\hat{f}_k}{\\omega_0^2 - \\omega_k^2 + i \\, 2 \\zeta \\omega_0 \\omega_k} \\, e^{i \\omega_k t}.\n   $$\n   No time-stepping is needed, because the solution is computed directly in the frequency domain and then transformed back to the time domain.\n\nDiscrete algorithm using the Fast Fourier Transform (FFT):\n- Discretize the time interval $[0, T)$ with $N$ equispaced nodes $t_j = \\frac{j T}{N}$ for $j = 0, 1, \\dots, N-1$.\n- Sample $f(t)$ at these nodes to get values $f_j = f(t_j)$.\n- Compute the discrete Fourier transform $\\hat{f}_k$ via the FFT. The corresponding angular frequencies for the $k$-th FFT bin are $\\omega_k = 2\\pi \\nu_k$ where $\\nu_k$ are obtained from the FFT frequency grid $\\nu_k = \\operatorname{fftfreq}(N, \\Delta t)$ with $\\Delta t = \\frac{T}{N}$.\n- For each bin, compute the spectral response\n  $$\n  \\hat{y}_k = \\frac{\\hat{f}_k}{\\omega_0^2 - \\omega_k^2 + i \\, 2 \\zeta \\omega_0 \\omega_k}.\n  $$\n- Inverse transform with the inverse FFT to obtain the grid samples $y_j \\approx y_{\\mathrm{per}}(t_j)$. Because $f(t)$ and the operator are real, the numerical $y_j$ are real up to machine precision; take the real part to remove negligible imaginary components.\n\nAnalytic references for validation:\n- For a single-tone input $f(t) = \\cos(\\omega t)$, the steady-state solution is $y_{\\mathrm{per}}(t) = |H(i\\omega)| \\cos(\\omega t - \\phi)$, where\n  $$\n  |H(i\\omega)| = \\frac{1}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2 \\zeta \\omega_0 \\omega)^2}}, \\quad \\phi = \\operatorname{atan2}(2 \\zeta \\omega_0 \\omega, \\omega_0^2 - \\omega^2).\n  $$\n  For $f(t) = \\sin(\\omega t)$, equivalently $y_{\\mathrm{per}}(t) = |H(i\\omega)| \\sin(\\omega t - \\phi)$.\n- For a constant input $f(t) = f_0$, only the zero-frequency mode contributes, yielding $y_{\\mathrm{per}}(t) = \\frac{f_0}{\\omega_0^2}$.\n- For multi-harmonic forcing, linearity yields the sum of the respective steady responses.\n\nError metric and outputs:\n- For each test case, compute the maximum absolute error\n  $$\n  e = \\max_{0 \\le j \\le N-1} \\left| y_{\\mathrm{spec}}(t_j) - y_{\\mathrm{ref}}(t_j) \\right|.\n  $$\n  Here $y_{\\mathrm{spec}}$ is the spectral solution and $y_{\\mathrm{ref}}$ is the analytic reference built from the formulas above. The errors are dimensionless real numbers.\n- The program must output a single line with the list $[e_1,e_2,e_3,e_4]$ corresponding to the four specified cases in order.\n\nWhy correctness holds:\n- The continuous operator is diagonal in the Fourier basis because complex exponentials are eigenfunctions of constant-coefficient differential operators, with eigenvalues $-\\omega^2$ for the second derivative and $i\\omega$ for the first derivative. Therefore the mapping from $\\hat{f}_k$ to $\\hat{y}_k$ is an algebraic division by the transfer function denominator.\n- The discrete implementation with the FFT is a pseudospectral collocation method over one period: it enforces the ODE in the Fourier domain at the sampled frequencies of the periodic grid, which converges spectrally (exponentially fast) for smooth periodic data, hence the small errors observed for smooth sinusoids and constants.\n\nImplementation details:\n- Use $N = 256$ for all cases as specified, $\\Delta t = \\frac{T}{N}$, $\\omega_k = 2\\pi \\operatorname{fftfreq}(N, \\Delta t)$.\n- Build the analytic references using $|H(i\\omega)|$ and $\\phi$ formulas at the appropriate angular frequencies.\n- Report the four errors in the required single-line format.", "answer": "```python\nimport numpy as np\n\ndef spectral_steady_response(omega0, zeta, T, f_func, N):\n    \"\"\"\n    Compute the periodic steady-state solution y(t) on one period [0, T)\n    for y'' + 2*zeta*omega0*y' + omega0**2*y = f(t) using a Fourier spectral method.\n    \"\"\"\n    t = np.arange(N) * (T / N)\n    f_samples = f_func(t)\n\n    # FFT of forcing\n    Fk = np.fft.fft(f_samples)\n\n    # Angular frequency grid corresponding to FFT bins\n    dt = T / N\n    freq = np.fft.fftfreq(N, d=dt)  # in cycles per unit time\n    omega = 2 * np.pi * freq        # angular frequencies\n\n    # Transfer function denominator at i*omega: -omega^2 + i*2*zeta*omega0*omega + omega0^2\n    denom = (-omega**2) + 1j * (2.0 * zeta * omega0 * omega) + (omega0**2)\n\n    # Avoid division by zero is not needed here since omega0 > 0 ensures denom != 0 for all omega\n    Yk = Fk / denom\n\n    # Inverse FFT to get y on grid\n    y = np.fft.ifft(Yk).real\n    return t, y\n\ndef amp_phase(omega0, zeta, omega):\n    # Compute |H(i*omega)| and phase phi\n    re = omega0**2 - omega**2\n    im = 2.0 * zeta * omega0 * omega\n    mag = 1.0 / np.sqrt(re**2 + im**2)\n    phi = np.arctan2(im, re)\n    return mag, phi\n\ndef case1():\n    # Case 1: omega0=1, zeta=0.05, Omega=1, T=2*pi, N=256, f=sin(Omega t)\n    omega0 = 1.0\n    zeta = 0.05\n    Omega = 1.0\n    T = 2.0 * np.pi / Omega\n    N = 256\n    f_func = lambda t: np.sin(Omega * t)\n    t, y_spec = spectral_steady_response(omega0, zeta, T, f_func, N)\n    A, phi = amp_phase(omega0, zeta, Omega)\n    y_true = A * np.sin(Omega * t - phi)\n    err = np.max(np.abs(y_spec - y_true))\n    return err\n\ndef case2():\n    # Case 2: omega0=3, zeta=0.1, Omega=2, T=pi, N=256, f=sin(Omega t) + 0.5*cos(2 Omega t)\n    omega0 = 3.0\n    zeta = 0.1\n    Omega = 2.0\n    T = 2.0 * np.pi / Omega  # = pi\n    N = 256\n    f_func = lambda t: np.sin(Omega * t) + 0.5 * np.cos(2.0 * Omega * t)\n    t, y_spec = spectral_steady_response(omega0, zeta, T, f_func, N)\n    A1, phi1 = amp_phase(omega0, zeta, Omega)\n    A2, phi2 = amp_phase(omega0, zeta, 2.0 * Omega)\n    y_true = A1 * np.sin(Omega * t - phi1) + 0.5 * A2 * np.cos(2.0 * Omega * t - phi2)\n    err = np.max(np.abs(y_spec - y_true))\n    return err\n\ndef case3():\n    # Case 3: omega0=2, zeta=0.2, T=2*pi, N=256, f=1.5 constant\n    omega0 = 2.0\n    zeta = 0.2\n    T = 2.0 * np.pi\n    N = 256\n    f0 = 1.5\n    f_func = lambda t: f0 * np.ones_like(t)\n    t, y_spec = spectral_steady_response(omega0, zeta, T, f_func, N)\n    y_true = (f0 / (omega0**2)) * np.ones_like(t)\n    err = np.max(np.abs(y_spec - y_true))\n    return err\n\ndef case4():\n    # Case 4: omega0=2, zeta=0.01, Omega=1.98, T=2*pi/Omega, N=256, f=cos(Omega t)\n    omega0 = 2.0\n    zeta = 0.01\n    Omega = 1.98\n    T = 2.0 * np.pi / Omega\n    N = 256\n    f_func = lambda t: np.cos(Omega * t)\n    t, y_spec = spectral_steady_response(omega0, zeta, T, f_func, N)\n    A, phi = amp_phase(omega0, zeta, Omega)\n    y_true = A * np.cos(Omega * t - phi)\n    err = np.max(np.abs(y_spec - y_true))\n    return err\n\ndef solve():\n    results = [case1(), case2(), case3(), case4()]\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2437054"}, {"introduction": "Spectral methods are not confined to regular, grid-like domains. This exercise generalizes the concept to unstructured networks or graphs, a cornerstone of modern data analysis and computational science. You will solve a diffusion equation on a small, weighted graph by using the eigenvectors of the graph Laplacian matrix, $L$, as your basis functions [@problem_id:2436990]. Just as sine and cosine functions are the eigenfunctions of the standard derivative operator, the eigenvectors of $L$ diagonalize the discrete diffusion process on the graph, transforming a coupled system of equations into a simple, solvable set. This practice will broaden your perspective on what constitutes a \"spectral method\" and its applicability to complex, irregular geometries.", "problem": "Consider an undirected, weighted, connected graph with $N=5$ nodes labeled $\\{0,1,2,3,4\\}$. The edge set and weights are given as follows (each undirected edge $\\{i,j\\}$ has symmetric weight $w_{ij}=w_{ji}$):\n- $\\{0,1\\}$ with weight $1.0$,\n- $\\{0,2\\}$ with weight $0.4$,\n- $\\{0,4\\}$ with weight $0.2$,\n- $\\{1,2\\}$ with weight $0.3$,\n- $\\{1,3\\}$ with weight $0.8$,\n- $\\{2,4\\}$ with weight $0.6$,\n- $\\{3,4\\}$ with weight $0.5$.\n\nDefine the weighted adjacency matrix $A \\in \\mathbb{R}^{5 \\times 5}$ by $A_{ij}=w_{ij}$ if there is an edge between nodes $i$ and $j$, and $A_{ij}=0$ otherwise, with $A_{ii}=0$ for all $i$. Define the diagonal degree matrix $D \\in \\mathbb{R}^{5 \\times 5}$ by $D_{ii}=\\sum_{j=0}^{4} A_{ij}$. The combinatorial graph Laplacian is $L=D-A$.\n\nLet $u(t) \\in \\mathbb{R}^{5}$ solve the linear time-invariant Partial Differential Equation (PDE) on the network\n$$\n\\frac{d}{dt}u(t) = -\\alpha L\\,u(t) + b, \\quad u(0)=u_0\n$$\nwhere $\\alpha \\ge 0$ is a scalar diffusion parameter, $b \\in \\mathbb{R}^{5}$ is a constant source vector, and $u_0 \\in \\mathbb{R}^{5}$ is the initial condition. For each test case below, compute the state $u(T)$ at the specified final time $T$.\n\nBuild $L$ from the above graph, and for each test case, compute $u(T)$ exactly (up to numerical rounding) and then round each component of $u(T)$ to exactly six digits after the decimal point.\n\nTest Suite (each tuple is $(\\alpha, T, u_0, b)$, with all vectors in node order $[0,1,2,3,4]$):\n1. $(1.0, 1.0, [1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0])$\n2. $(0.0, 2.5, [-1.0, 2.0, 0.0, 1.0, 0.0], [0.3, -0.2, 0.1, 0.0, -0.1])$\n3. $(2.0, 0.0, [0.5, -0.5, 1.0, 0.0, 2.0], [1.0, -1.0, 0.0, 0.5, -0.5])$\n4. $(0.7, 0.8, [0.0, 0.0, 0.0, 0.0, 0.0], [1.0, -0.5, 0.0, 0.25, -0.25])$\n\nFinal Output Format:\nYour program must print a single line containing a comma-separated list enclosed in square brackets, where each entry corresponds to one test case in the given order and is itself a list of the $5$ rounded components of $u(T)$ in node order $[0,1,2,3,4]$. There must be no spaces anywhere in the output. Concretely, the output must be of the form\n[ [x_{1,0},x_{1,1},x_{1,2},x_{1,3},x_{1,4}], [x_{2,0},...,x_{2,4}], [x_{3,0},...,x_{3,4}], [x_{4,0},...,x_{4,4}] ]\nbut without spaces and with each $x_{k,i}$ rounded to six digits after the decimal point.", "solution": "The problem statement is subjected to validation and is found to be scientifically sound, well-posed, and complete. It describes a standard initial value problem for a system of linear ordinary differential equations, representing a diffusion process on a graph. All necessary data and definitions are provided, and there are no internal contradictions or ambiguities. I will therefore proceed with a complete solution.\n\nThe governing equation is a linear time-invariant (LTI) system given by\n$$\n\\frac{d}{dt}u(t) = -\\alpha L\\,u(t) + b, \\quad u(0)=u_0\n$$\nwhere $u(t) \\in \\mathbb{R}^{N}$ is the state vector, $L \\in \\mathbb{R}^{N \\times N}$ is the combinatorial graph Laplacian, $\\alpha \\ge 0$ is a scalar diffusion parameter, $b \\in \\mathbb{R}^{N}$ is a constant source vector, and $u_0 \\in \\mathbb{R}^{N}$ is the initial condition. Here, $N=5$.\n\nThe analytical solution to this system can be found using the method of eigendecomposition, which is appropriate as the graph Laplacian $L$ of an undirected graph is a real symmetric matrix. As such, $L$ is diagonalizable by an orthogonal matrix $V$ of its eigenvectors:\n$$\nL = V \\Lambda V^T\n$$\nwhere $\\Lambda$ is a diagonal matrix of the real eigenvalues $\\lambda_i$ of $L$, and $V$ is an orthogonal matrix ($V^T V = V V^T = I$) whose columns are the corresponding orthonormal eigenvectors. This decomposition is central to spectral methods on graphs.\n\nWe introduce a change of variables by projecting the state vector $u(t)$ onto the eigenbasis of $L$:\n$$\nv(t) = V^T u(t) \\quad \\iff \\quad u(t) = V v(t)\n$$\nSubstituting this into the governing equation gives:\n$$\n\\frac{d}{dt}(V v(t)) = -\\alpha (V \\Lambda V^T) (V v(t)) + b\n$$\n$$\nV \\frac{d v(t)}{dt} = -\\alpha V \\Lambda v(t) + b\n$$\nMultiplying from the left by $V^T$ and using the orthogonality of $V$:\n$$\n\\frac{d v(t)}{dt} = -\\alpha \\Lambda v(t) + V^T b\n$$\nThis transforms the original coupled system into a set of $N$ independent scalar linear ordinary differential equations. Let $c = V^T b$. The $i$-th equation is:\n$$\n\\frac{d v_i(t)}{dt} = -\\alpha \\lambda_i v_i(t) + c_i, \\quad v_i(0) = (V^T u_0)_i\n$$\nThe solution for each component $v_i(t)$ depends on the value of $\\lambda_i$. For a connected graph, the Laplacian $L$ has one simple eigenvalue $\\lambda_0 = 0$ and all other eigenvalues are strictly positive ($\\lambda_i > 0$ for $i > 0$).\n\nCase 1: $\\alpha \\lambda_i \\neq 0$. The solution is\n$$\nv_i(t) = e^{-\\alpha \\lambda_i t} v_i(0) + \\frac{1 - e^{-\\alpha \\lambda_i t}}{\\alpha \\lambda_i} c_i\n$$\nCase 2: $\\alpha \\lambda_i = 0$. The equation becomes $\\frac{d v_i(t)}{dt} = c_i$, with solution\n$$\nv_i(t) = v_i(0) + c_i t\n$$\nThis case applies if $\\alpha=0$ or if $\\lambda_i=0$. The provided test cases include instances of $\\alpha=0$ and $T=0$, which are handled as simple special cases:\n- If $T=0$, the solution is trivially $u(T) = u(0) = u_0$.\n- If $\\alpha=0$, the equation simplifies to $\\frac{d u(t)}{dt} = b$, whose solution is $u(T) = u_0 + bT$.\n\nOnce the vector $v(T)=[v_0(T), v_1(T), \\dots, v_{N-1}(T)]^T$ is computed at the final time $T$, the solution in the original basis is recovered by the inverse transformation:\n$$\nu(T) = V v(T)\n$$\nThe implementation will first construct the Laplacian matrix $L$ from the given graph structure. Then, for each test case, it will compute the solution $u(T)$ by applying the appropriate formula derived above. For the general case requiring eigendecomposition, we will use numerically robust linear algebra routines. The final components of $u(T)$ are rounded and formatted as per the problem specification.\n\nThe graph is defined by $N=5$ nodes and the following edges and weights: $w_{01}=1.0$, $w_{02}=0.4$, $w_{04}=0.2$, $w_{12}=0.3$, $w_{13}=0.8$, $w_{24}=0.6$, $w_{34}=0.5$.\nThe adjacency matrix $A$ is:\n$$\nA = \\begin{pmatrix}\n0.0 & 1.0 & 0.4 & 0.0 & 0.2 \\\\\n1.0 & 0.0 & 0.3 & 0.8 & 0.0 \\\\\n0.4 & 0.3 & 0.0 & 0.0 & 0.6 \\\\\n0.0 & 0.8 & 0.0 & 0.0 & 0.5 \\\\\n0.2 & 0.0 & 0.6 & 0.5 & 0.0\n\\end{pmatrix}\n$$\nThe diagonal degree matrix $D$ is formed by summing the rows of $A$: $D_{00}=1.6$, $D_{11}=2.1$, $D_{22}=1.3$, $D_{33}=1.3$, $D_{44}=1.3$.\nThe graph Laplacian $L=D-A$ is:\n$$\nL = \\begin{pmatrix}\n 1.6 & -1.0 & -0.4 &  0.0 & -0.2 \\\\\n-1.0 &  2.1 & -0.3 & -0.8 &  0.0 \\\\\n-0.4 & -0.3 &  1.3 &  0.0 & -0.6 \\\\\n 0.0 & -0.8 &  0.0 &  1.3 & -0.5 \\\\\n-0.2 &  0.0 & -0.6 & -0.5 &  1.3\n\\end{pmatrix}\n$$\nThis matrix will be used for all test case computations.", "answer": "```python\nimport numpy as np\n\ndef compute_u_T(L, alpha, T, u0, b):\n    \"\"\"\n    Computes the solution u(T) for the differential equation du/dt = -alpha*L*u + b.\n    \"\"\"\n    N = L.shape[0]\n\n    # Handle special cases for T=0 and alpha=0\n    if np.isclose(T, 0.0):\n        return u0\n    \n    if np.isclose(alpha, 0.0):\n        return u0 + b * T\n\n    # General case: alpha > 0 and T > 0\n    # The solution is found via eigendecomposition of L.\n    # L = V Lambda V^T\n    # u(T) = V [exp(-alpha*Lambda*T) V^T u0 + G V^T b]\n    # where G is a diagonal matrix with elements g_i.\n    \n    # Eigendecomposition of the symmetric matrix L\n    lambdas, V = np.linalg.eigh(L)\n    \n    # Transform initial condition and source term to the eigenbasis\n    v0 = V.T @ u0\n    c = V.T @ b\n    \n    # Compute the solution v(T) in the eigenbasis\n    vt = np.zeros(N, dtype=np.float64)\n    \n    for i in range(N):\n        lam = lambdas[i]\n        \n        # Homogeneous part of the solution for v_i(T)\n        hom_part = np.exp(-alpha * lam * T) * v0[i]\n        \n        # Inhomogeneous part of the solution for v_i(T)\n        inhom_part = 0.0\n        # The form of the inhomogeneous term depends on whether lambda_i is zero\n        if np.isclose(lam, 0.0):\n            # For lambda_i = 0, the coefficient of c_i is T\n            inhom_part = c[i] * T\n        else:\n            # For lambda_i != 0, the coefficient is (1-exp(-a*l*T))/(a*l)\n            # We use a numerically stable implementation using np.expm1(x) for e^x-1\n            x = -alpha * lam * T\n            coeff = -np.expm1(x) / (alpha * lam)\n            inhom_part = c[i] * coeff\n            \n        vt[i] = hom_part + inhom_part\n        \n    # Transform the solution back to the original basis\n    uT = V @ vt\n    \n    return uT\n\ndef solve():\n    \"\"\"\n    Main function to define the problem, run test cases, and print the output.\n    \"\"\"\n    # Define graph properties\n    N = 5\n    edges_with_weights = {\n        (0, 1): 1.0, (0, 2): 0.4, (0, 4): 0.2,\n        (1, 2): 0.3, (1, 3): 0.8,\n        (2, 4): 0.6,\n        (3, 4): 0.5\n    }\n\n    # Construct the adjacency matrix A\n    A = np.zeros((N, N))\n    for (i, j), w in edges_with_weights.items():\n        A[i, j] = A[j, i] = w\n\n    # Construct the degree matrix D\n    D = np.diag(np.sum(A, axis=1))\n\n    # Construct the combinatorial graph Laplacian L\n    L = D - A\n\n    # Test suite from the problem description\n    test_cases = [\n        (1.0, 1.0, [1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0]),\n        (0.0, 2.5, [-1.0, 2.0, 0.0, 1.0, 0.0], [0.3, -0.2, 0.1, 0.0, -0.1]),\n        (2.0, 0.0, [0.5, -0.5, 1.0, 0.0, 2.0], [1.0, -1.0, 0.0, 0.5, -0.5]),\n        (0.7, 0.8, [0.0, 0.0, 0.0, 0.0, 0.0], [1.0, -0.5, 0.0, 0.25, -0.25])\n    ]\n\n    all_results = []\n    for case in test_cases:\n        alpha, T, u0_list, b_list = case\n        u0 = np.array(u0_list, dtype=np.float64)\n        b = np.array(b_list, dtype=np.float64)\n        \n        u_T = compute_u_T(L, alpha, T, u0, b)\n        \n        # Append the result vector to the list of all results\n        all_results.append(u_T)\n\n    # Format the final output string as specified\n    formatted_results = []\n    for res_vec in all_results:\n        # Format each number to exactly six decimal places\n        str_vec = [f\"{x:.6f}\" for x in res_vec]\n        formatted_results.append(f\"[{','.join(str_vec)}]\")\n    \n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "2436990"}]}