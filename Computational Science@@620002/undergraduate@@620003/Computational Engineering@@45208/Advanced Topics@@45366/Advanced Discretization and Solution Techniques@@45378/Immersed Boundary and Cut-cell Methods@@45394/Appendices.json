{"hands_on_practices": [{"introduction": "Choosing the right discretization strategy is a critical first step in any computational analysis. This exercise explores the fundamental trade-off between a method's accuracy and its computational cost by comparing a geometrically simple cut-cell method with a more complex, boundary-conforming approach [@problem_id:2401407]. By creating and using idealized performance models, you will practice making high-level architectural decisions for a simulation based on quantitative estimates of efficiency and accuracy, a crucial skill for a computational engineer.", "problem": "You must write a complete program that implements and compares idealized computational cost and accuracy models for two numerical strategies for an incompressible, irrotational external aerodynamics problem: a Cartesian cut-cell finite-volume discretization versus a body-fitted unstructured triangulation. The flow model is taken as potential flow, governed by the Laplace equation for velocity potential, so that the dominant numerical effects arise from geometric resolution near an immersed circular obstacle and the bulk field resolution. Your implementation must follow the principle-based modeling assumptions below, which originate from standard definitions of discretization error scaling, geometric measures, and algorithmic complexity of modern solvers.\n\nStart from the following fundamental base:\n- The Partial Differential Equation (PDE) is the Laplace equation for potential flow. Discretization error for a consistent method behaves as a power law in the grid spacing, so that a global norm of the error scales as $E \\sim C h^{p}$, where $C$ depends on geometric and solution smoothness scales and $p$ is the formal order of accuracy of the method.\n- For a domain tessellation into control volumes or elements with characteristic size $h$, the number of degrees of freedom is proportional to the domain area divided by $h^{2}$. Hence, for a square domain with side length $L$ and area $A = L^{2}$, the unknown count scales as $N \\approx A / h^{2}$.\n- For a well-designed multigrid preconditioned solver, the arithmetic cost per solve scales linearly with the number of unknowns, up to a multiplicative iteration multiplier that captures deterioration due to conditioning. Thus, the solve cost has the form $S = k_{\\text{solve}} \\, N \\, m_{\\text{iter}}$, where $k_{\\text{solve}}$ is a constant work per unknown and $m_{\\text{iter}}$ is an iteration multiplier greater than or equal to $1$.\n\nYou must model each method as follows.\n- Geometry and measures: The computational domain is a square of side length $L$ (in $m$), centered circular obstacle of radius $R$ (in $m$), with area $A = L^{2}$ and perimeter $P = 2 \\pi R$.\n- Cut-cell method (Cartesian grid with embedded boundary):\n    - Grid spacing is $h_{\\text{cut}}$ (in $m$).\n    - Discretization error is dominated by first-order boundary approximation, so it follows $E_{\\text{cut}} = k_{c} \\left( \\dfrac{h_{\\text{cut}}}{R} \\right)^{p_{c}}$ with $p_{c} = 1$ and $k_{c} = 1.0$.\n    - Unknown count is approximated as $N_{\\text{cut}} = \\dfrac{A}{h_{\\text{cut}}^{2}}$.\n    - Iteration multiplier accounts for small-volume-fraction cut-cells via $m_{\\text{cut}} = 1 + c_{\\text{cond}} \\, \\dfrac{R}{h_{\\text{cut}}}$ with $c_{\\text{cond}} = 0.1$.\n    - Mesh generation cost for a Cartesian grid is modeled by a line-sweep setup cost $G_{\\text{cut}} = g_{\\text{grid}} \\, \\dfrac{L}{h_{\\text{cut}}}$ with $g_{\\text{grid}} = 5.0$.\n    - Total cost is $T_{\\text{cut}} = S_{\\text{cut}} + G_{\\text{cut}}$ with $S_{\\text{cut}} = k_{\\text{solve}} \\, N_{\\text{cut}} \\, m_{\\text{cut}}$ and $k_{\\text{solve}} = 1.0$.\n- Body-fitted unstructured mesh (triangular elements):\n    - Element size is $h_{\\text{body}}$ (in $m$).\n    - Discretization error is second-order in the bulk and along the smooth boundary, so $E_{\\text{body}} = k_{b} \\left( \\dfrac{h_{\\text{body}}}{R} \\right)^{p_{b}}$ with $p_{b} = 2$ and $k_{b} = 0.5$.\n    - Unknown count is approximated as bulk plus an inflation band near the boundary: $N_{\\text{body}} = \\dfrac{A - \\pi R^{2}}{h_{\\text{body}}^{2}} + c_{w} \\, \\dfrac{P}{h_{\\text{body}}}$ with $c_{w} = 3.0$.\n    - Iteration multiplier reflects mild shape-quality effects: $m_{\\text{body}} = 1 + c_{\\text{shape}} \\, \\dfrac{h_{\\text{body}}}{R}$ with $c_{\\text{shape}} = 0.05$.\n    - Mesh generation cost is proportional to the number of boundary nodes: $G_{\\text{body}} = g_{\\text{gen}} \\, \\dfrac{P}{h_{\\text{body}}}$ with $g_{\\text{gen}} = 20.0$.\n    - Total cost is $T_{\\text{body}} = S_{\\text{body}} + G_{\\text{body}}$ with $S_{\\text{body}} = k_{\\text{solve}} \\, N_{\\text{body}} \\, m_{\\text{body}}$ and the same $k_{\\text{solve}}$ as above.\n\nGiven a target error level $\\varepsilon$ (dimensionless), you must determine, for each method separately, the element or grid size $h$ that achieves $E \\le \\varepsilon$ with equality by inverting the error law and then evaluate the corresponding total cost. Specifically, solve for $h_{\\text{cut,target}}$ and $h_{\\text{body,target}}$ from the error laws, and then compute $T_{\\text{cut,target}}$ and $T_{\\text{body,target}}$ using the cost models above. Prefer the method with the strictly smaller target cost; encode this preference as an integer $b$, where $b = 0$ indicates the cut-cell method and $b = 1$ indicates the body-fitted method. If the target costs are equal within numerical tolerance, choose $b = 1$.\n\nAll physical distances must be interpreted in meters ($m$). All costs must be reported in abstract work units and are dimensionless. Errors are dimensionless. Angles do not appear and thus need no specification.\n\nTest suite. Your program must evaluate the following four test cases, each given as $(L, R, h_{\\text{cut}}, h_{\\text{body}}, \\varepsilon)$:\n- Case $1$: $(L, R, h_{\\text{cut}}, h_{\\text{body}}, \\varepsilon) = (\\,10,\\,1,\\,0.1,\\,0.1,\\,0.02\\,)$ in $m$ for the lengths and dimensionless for $\\varepsilon$.\n- Case $2$: $(\\,10,\\,1,\\,0.05,\\,0.2,\\,0.01\\,)$ with the same units.\n- Case $3$: $(\\,5,\\,0.2,\\,0.05,\\,0.05,\\,0.005\\,)$ with the same units.\n- Case $4$: $(\\,20,\\,3,\\,0.15,\\,0.1,\\,0.01\\,)$ with the same units.\n\nFor each test case, your program must compute and output, in this exact order:\n- $E_{\\text{cut}}$,\n- $E_{\\text{body}}$,\n- $T_{\\text{cut}}$,\n- $T_{\\text{body}}$,\n- $b$ (an integer, $0$ or $1$) indicating the preferred method at the target error cost,\n- $T_{\\text{best,target}} = \\min\\{T_{\\text{cut,target}}, T_{\\text{body,target}}\\}$.\n\nFinal output format. Your program should produce a single line of output containing all results for the four test cases aggregated into one flat, comma-separated list enclosed in square brackets. The results for each case must be appended in sequence, preserving the intra-case order above. For example, the output must have the form\n$[E_{\\text{cut},1},E_{\\text{body},1},T_{\\text{cut},1},T_{\\text{body},1},b_{1},T_{\\text{best,target},1},E_{\\text{cut},2},\\dots,E_{\\text{body},4},T_{\\text{cut},4},T_{\\text{body},4},b_{4},T_{\\text{best,target},4}]$.\nAll numeric values must be printed in standard decimal notation. Integers must be printed without decimal point.", "solution": "The problem, as stated, is a valid exercise in the algorithmic analysis of numerical methods. It is self-contained, mathematically consistent, and grounded in established principles of computational engineering. We proceed with the derivation of the solution.\n\nThe objective is to compute and compare the performance of two distinct discretization strategies for solving the Laplace equation in an external domain: a Cartesian cut-cell method and a body-fitted unstructured mesh method. The comparison is based on provided analytical models for discretization error and computational cost.\n\nThe computational domain is a square of side length $L$, from which a centered circular obstacle of radius $R$ is excluded. The domain area is $A = L^2$ and the obstacle perimeter is $P = 2 \\pi R$.\n\nFirst, we formalize the models for each method based on the provided specifications.\n\n**1. Cut-Cell Method**\n\nThis method uses a uniform Cartesian grid of spacing $h_{\\text{cut}}$. The presence of the obstacle is handled by cutting cells at the boundary.\n\n-   **Discretization Error**: The error is stipulated to be first-order, dominated by the boundary approximation.\n    $$E_{\\text{cut}} = k_{c} \\left( \\frac{h_{\\text{cut}}}{R} \\right)^{p_{c}}$$\n    with constants $k_{c} = 1.0$ and $p_{c} = 1$.\n\n-   **Degrees of Freedom**: The number of unknowns is proportional to the number of cells in the full domain.\n    $$N_{\\text{cut}} = \\frac{A}{h_{\\text{cut}}^2} = \\frac{L^2}{h_{\\text{cut}}^2}$$\n\n-   **Solver Complexity**: The solver cost, $S_{\\text{cut}}$, is linear in the number of unknowns, but is penalized by an iteration multiplier, $m_{\\text{cut}}$, which models the ill-conditioning caused by small cut-cells.\n    $$m_{\\text{cut}} = 1 + c_{\\text{cond}} \\frac{R}{h_{\\text{cut}}}$$\n    where $c_{\\text{cond}} = 0.1$. The solver cost is then:\n    $$S_{\\text{cut}} = k_{\\text{solve}} N_{\\text{cut}} m_{\\text{cut}}$$\n    with $k_{\\text{solve}} = 1.0$.\n\n-   **Generation Cost**: The mesh generation cost, $G_{\\text{cut}}$, is modeled as a line-sweep operation.\n    $$G_{\\text{cut}} = g_{\\text{grid}} \\frac{L}{h_{\\text{cut}}}$$\n    with $g_{\\text{grid}} = 5.0$.\n\n-   **Total Cost**: The total computational cost is the sum of solver and generation costs.\n    $$T_{\\text{cut}} = S_{\\text{cut}} + G_{\\text{cut}} = k_{\\text{solve}} \\frac{L^2}{h_{\\text{cut}}^2} \\left( 1 + c_{\\text{cond}} \\frac{R}{h_{\\text{cut}}} \\right) + g_{\\text{grid}} \\frac{L}{h_{\\text{cut}}}$$\n\n**2. Body-Fitted Unstructured Method**\n\nThis method uses a triangular mesh that conforms to the obstacle boundary. The characteristic element size is $h_{\\text{body}}$.\n\n-   **Discretization Error**: The error is second-order, benefiting from the smooth boundary-conforming mesh.\n    $$E_{\\text{body}} = k_{b} \\left( \\frac{h_{\\text{body}}}{R} \\right)^{p_{b}}$$\n    with constants $k_{b} = 0.5$ and $p_{b} = 2$.\n\n-   **Degrees of Freedom**: The number of unknowns is the sum of contributions from the bulk domain and a boundary-adjacent inflation layer.\n    $$N_{\\text{body}} = \\frac{A - \\pi R^2}{h_{\\text{body}}^2} + c_{w} \\frac{P}{h_{\\text{body}}} = \\frac{L^2 - \\pi R^2}{h_{\\text{body}}^2} + c_{w} \\frac{2 \\pi R}{h_{\\text{body}}}$$\n    with $c_{w} = 3.0$.\n\n-   **Solver Complexity**: The iteration multiplier, $m_{\\text{body}}$, accounts for mild conditioning effects due to element shape quality.\n    $$m_{\\text{body}} = 1 + c_{\\text{shape}} \\frac{h_{\\text{body}}}{R}$$\n    with $c_{\\text{shape}} = 0.05$. The solver cost is:\n    $$S_{\\text{body}} = k_{\\text{solve}} N_{\\text{body}} m_{\\text{body}}$$\n    with $k_{\\text{solve}} = 1.0$.\n\n-   **Generation Cost**: The mesh generation cost, $G_{\\text{body}}$, is proportional to the number of nodes on the boundary.\n    $$G_{\\text{body}} = g_{\\text{gen}} \\frac{P}{h_{\\text{body}}} = g_{\\text{gen}} \\frac{2 \\pi R}{h_{\\text{body}}}$$\n    with $g_{\\text{gen}} = 20.0$.\n\n-   **Total Cost**: The total computational cost is the sum of solver and generation costs.\n    $$T_{\\text{body}} = S_{\\text{body}} + G_{\\text{body}} = k_{\\text{solve}} \\left( \\frac{L^2 - \\pi R^2}{h_{\\text{body}}^2} + c_{w} \\frac{2 \\pi R}{h_{\\text{body}}} \\right) \\left( 1 + c_{\\text{shape}} \\frac{h_{\\text{body}}}{R} \\right) + g_{\\text{gen}} \\frac{2 \\pi R}{h_{\\text{body}}}$$\n\n**Computational Tasks**\n\nFor each test case, we perform two sets of calculations.\n\nFirst, we compute the error and cost for the specified grid sizes $h_{\\text{cut}}$ and $h_{\\text{body}}$ using the formulas above.\n\nSecond, we determine the optimal choice of method for a given target error level, $\\varepsilon$. This requires finding the grid size for each method that achieves this error, and then comparing their total costs.\n\n-   **Target Grid Size for Cut-Cell Method**: We set $E_{\\text{cut}} = \\varepsilon$ and solve for $h_{\\text{cut,target}}$.\n    $$\\varepsilon = k_{c} \\left( \\frac{h_{\\text{cut,target}}}{R} \\right)^{p_{c}} \\implies h_{\\text{cut,target}} = R \\left( \\frac{\\varepsilon}{k_{c}} \\right)^{1/p_{c}}$$\n    Substituting $k_{c}=1.0$ and $p_c=1$, we get:\n    $$h_{\\text{cut,target}} = R \\varepsilon$$\n\n-   **Target Grid Size for Body-Fitted Method**: We set $E_{\\text{body}} = \\varepsilon$ and solve for $h_{\\text{body,target}}$.\n    $$\\varepsilon = k_{b} \\left( \\frac{h_{\\text{body,target}}}{R} \\right)^{p_{b}} \\implies h_{\\text{body,target}} = R \\left( \\frac{\\varepsilon}{k_{b}} \\right)^{1/p_{b}}$$\n    Substituting $k_{b}=0.5$ and $p_b=2$, we get:\n    $$h_{\\text{body,target}} = R \\sqrt{2\\varepsilon}$$\n\nWith these target grid sizes, we compute their corresponding total costs, $T_{\\text{cut,target}}$ and $T_{\\text{body,target}}$, by substituting $h_{\\text{cut,target}}$ and $h_{\\text{body,target}}$ into the total cost formulas.\n\nThe preferred method, denoted by integer $b$, is determined by comparing these target costs. If $T_{\\text{cut,target}} < T_{\\text{body,target}}$, the cut-cell method is superior ($b=0$). Otherwise, including the case of equality, the body-fitted method is chosen ($b=1$). The minimum of these two costs is recorded as $T_{\\text{best,target}}$.\n\nThe final program will systematically apply these calculations to each test case provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares idealized computational cost and accuracy models for\n    cut-cell and body-fitted numerical methods for a potential flow problem.\n    \"\"\"\n\n    # --- Model Constants ---\n    # Cut-cell method constants\n    K_C = 1.0\n    P_C = 1.0\n    C_COND = 0.1\n    G_GRID = 5.0\n    K_SOLVE = 1.0\n\n    # Body-fitted method constants\n    K_B = 0.5\n    P_B = 2.0\n    C_W = 3.0\n    C_SHAPE = 0.05\n    G_GEN = 20.0\n\n    def calculate_cut_cell_metrics(L, R, h_cut):\n        \"\"\"\n        Calculates error and total cost for the cut-cell method.\n        \"\"\"\n        if h_cut <= 0:\n            return float('inf'), float('inf')\n\n        # Error model\n        E_cut = K_C * (h_cut / R)**P_C\n\n        # Cost model\n        A = L**2\n        N_cut = A / h_cut**2\n        m_cut = 1.0 + C_COND * (R / h_cut)\n        S_cut = K_SOLVE * N_cut * m_cut\n        G_cut = G_GRID * (L / h_cut)\n        T_cut = S_cut + G_cut\n\n        return E_cut, T_cut\n\n    def calculate_body_fitted_metrics(L, R, h_body):\n        \"\"\"\n        Calculates error and total cost for the body-fitted method.\n        \"\"\"\n        if h_body <= 0:\n            return float('inf'), float('inf')\n\n        # Error model\n        E_body = K_B * (h_body / R)**P_B\n\n        # Cost model\n        A = L**2\n        P = 2.0 * np.pi * R\n        N_body = (A - np.pi * R**2) / h_body**2 + C_W * (P / h_body)\n        m_body = 1.0 + C_SHAPE * (h_body / R)\n        S_body = K_SOLVE * N_body * m_body\n        G_body = G_GEN * (P / h_body)\n        T_body = S_body + G_body\n\n        return E_body, T_body\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, R, h_cut, h_body, epsilon)\n        (10.0, 1.0, 0.1, 0.1, 0.02),\n        (10.0, 1.0, 0.05, 0.2, 0.01),\n        (5.0, 0.2, 0.05, 0.05, 0.005),\n        (20.0, 3.0, 0.15, 0.1, 0.01),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, R, h_cut_in, h_body_in, epsilon = case\n\n        # --- Part 1: Calculation for given h values ---\n        E_cut, T_cut = calculate_cut_cell_metrics(L, R, h_cut_in)\n        E_body, T_body = calculate_body_fitted_metrics(L, R, h_body_in)\n\n        # --- Part 2: Calculation for target error epsilon ---\n        # Determine target grid sizes\n        h_cut_target = R * (epsilon / K_C)**(1.0 / P_C)\n        h_body_target = R * (epsilon / K_B)**(1.0 / P_B)\n\n        # Calculate costs at target grid sizes\n        _, T_cut_target = calculate_cut_cell_metrics(L, R, h_cut_target)\n        _, T_body_target = calculate_body_fitted_metrics(L, R, h_body_target)\n\n        # Determine preferred method and minimum cost\n        # b=0 for cut-cell, b=1 for body-fitted\n        # Body-fitted is preferred if its cost is less than or equal to cut-cell's\n        if T_cut_target < T_body_target:\n            b = 0\n        else:\n            b = 1\n\n        T_best_target = min(T_cut_target, T_body_target)\n\n        # Append all 6 results for the current case\n        results.extend([E_cut, E_body, T_cut, T_body, b, T_best_target])\n\n    # Final print statement in the exact required format.\n    # str() is used to ensure standard decimal notation for numbers that are not\n    # excessively large or small, and integer format for b.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2401407"}, {"introduction": "Once an embedded boundary approach is chosen, a key question is how to represent the interface itself and compute physical quantities there. This practice contrasts a \"diffuse\" interface, typical of the Immersed Boundary (IB) method, with a \"sharp\" geometric representation from a cut-cell method [@problem_id:2401412]. Through this hands-on coding task, you will gain a concrete understanding of how different interface representations translate to code and directly impact the accuracy of force calculations, a critical aspect of many engineering simulations.", "problem": "You are given a closed, smooth curve $\\Gamma \\subset \\mathbb{R}^2$ defined as the circle of radius $R$ centered at $(c_x,c_y)$, namely the zero level set of the signed-distance function $\\phi(x,y)=\\sqrt{(x-c_x)^2+(y-c_y)^2}-R$. Define the vector-valued force density on the plane by $\\mathbf{f}(x,y)=\\begin{bmatrix}\\cos(3\\theta(x,y))+\\tfrac{1}{2}\\\\ \\sin(2\\theta(x,y))\\end{bmatrix}$ where $\\theta(x,y)=\\mathrm{atan2}(y-c_y,x-c_x)$ is the polar angle around the center, expressed in radians. The total force is defined by the line integral $\\mathbf{F}=\\int_{\\Gamma}\\mathbf{f}\\,ds$.\n\nYour task is to compute and compare approximations of $\\mathbf{F}$ using two distinct approaches on a uniform Cartesian grid covering the square domain $\\Omega=[-L,L]^2$:\n\n- A diffuse-interface immersed-boundary approximation based on the regularized Dirac delta function. Let the regularized delta be\n$$\n\\delta_\\varepsilon(\\phi)=\n\\begin{cases}\n\\dfrac{1}{2\\varepsilon}\\left(1+\\cos\\left(\\dfrac{\\pi\\phi}{\\varepsilon}\\right)\\right), & |\\phi|\\le \\varepsilon \\\\\n0, & |\\phi|>\\varepsilon\n\\end{cases}\n$$\nand let $|\\nabla \\phi|=1$ for the signed distance $\\phi$. On a uniform grid of $N\\times N$ points with spacing $h=\\dfrac{2L}{N-1}$, approximate\n$$\n\\mathbf{F}_{\\mathrm{IB}}(\\varepsilon,h)\\approx \\iint_{\\Omega}\\mathbf{f}(x,y)\\,\\delta_\\varepsilon(\\phi(x,y))\\,|\\nabla\\phi(x,y)|\\,dx\\,dy\n$$\nby a Riemann sum with cell area $h^2$.\n\n- A sharp-interface cut-cell approximation that replaces $\\Gamma=\\{\\phi=0\\}$ by a polyline obtained by linear interpolation of $\\phi$ on each grid cell whose vertices straddle the zero level set. For each resulting line segment $s$ with length $|s|$ and midpoint $\\mathbf{m}_s$, approximate the line integral by\n$$\n\\mathbf{F}_{\\mathrm{CC}}(h)\\approx \\sum_{s}\\mathbf{f}(\\mathbf{m}_s)\\,|s|.\n$$\n\nUse radians for all angular quantities. For this manufactured test, the exact total force is\n$$\n\\mathbf{F}_{\\mathrm{true}}=\\int_{0}^{2\\pi}\\begin{bmatrix}\\cos(3\\theta)+\\tfrac{1}{2}\\\\ \\sin(2\\theta)\\end{bmatrix}R\\,d\\theta=\\begin{bmatrix}\\pi R\\\\ 0\\end{bmatrix}.\n$$\n\nImplement a program that evaluates the Euclidean-norm errors\n$$\ne_{\\mathrm{IB}}=\\left\\|\\mathbf{F}_{\\mathrm{IB}}(\\varepsilon,h)-\\mathbf{F}_{\\mathrm{true}}\\right\\|_2,\\qquad\ne_{\\mathrm{CC}}=\\left\\|\\mathbf{F}_{\\mathrm{CC}}(h)-\\mathbf{F}_{\\mathrm{true}}\\right\\|_2\n$$\nfor the following test suite of parameter sets, with $\\varepsilon=k_\\varepsilon\\,h$:\n\n- Test $1$: $L=1.2$, $R=0.9$, $N=33$, $(c_x,c_y)=(0.0,0.0)$, $k_\\varepsilon=1.5$.\n- Test $2$: $L=1.2$, $R=0.9$, $N=33$, $(c_x,c_y)=(0.2,-0.15)$, $k_\\varepsilon=0.5$.\n- Test $3$: $L=1.2$, $R=0.9$, $N=65$, $(c_x,c_y)=(0.2,-0.15)$, $k_\\varepsilon=1.5$.\n- Test $4$: $L=1.2$, $R=0.9$, $N=129$, $(c_x,c_y)=(0.37,0.22)$, $k_\\varepsilon=1.5$.\n\nYour program must produce a single line of output containing the $8$ floating-point results as a comma-separated list enclosed in square brackets, in the order $[e_{\\mathrm{IB}}^{(1)},e_{\\mathrm{CC}}^{(1)},e_{\\mathrm{IB}}^{(2)},e_{\\mathrm{CC}}^{(2)},e_{\\mathrm{IB}}^{(3)},e_{\\mathrm{CC}}^{(3)},e_{\\mathrm{IB}}^{(4)},e_{\\mathrm{CC}}^{(4)}]$, where the superscript indicates the test number. Each value must be rounded to $6$ decimal places. No other text should be printed. No physical units are required because all quantities are dimensionless in this setup.", "solution": "The problem requires the computation of a line integral of a vector-valued force density $\\mathbf{f}(x,y)$ over a circle $\\Gamma$. This is to be approximated using two different numerical methods on a uniform Cartesian grid: the diffuse-interface immersed boundary (IB) method and the sharp-interface cut-cell (CC) method. The accuracy of these methods is to be evaluated by comparing their results to the exact analytical solution.\n\nFirst, the necessary parameters for each test case are defined: the domain half-width $L$, circle radius $R$, center coordinates $(c_x, c_y)$, grid size $N \\times N$, and the Dirac delta function width parameter $k_\\varepsilon$. From these, the grid spacing $h = \\frac{2L}{N-1}$ and the delta function support radius $\\varepsilon = k_\\varepsilon h$ are derived. The computational grid consists of points $(x_i, y_j)$ where $x_i = -L + i \\cdot h$ and $y_j = -L + j \\cdot h$ for $i, j \\in \\{0, 1, \\dots, N-1\\}$.\n\nThe exact total force $\\mathbf{F}_{\\mathrm{true}}$ is given by the integral of the force density along the curve parameterized by the polar angle $\\theta$:\n$$\n\\mathbf{F}_{\\mathrm{true}} = \\int_{0}^{2\\pi} \\mathbf{f}(\\theta) R \\, d\\theta = \\int_{0}^{2\\pi} \\begin{bmatrix} \\cos(3\\theta) + \\frac{1}{2} \\\\ \\sin(2\\theta) \\end{bmatrix} R \\, d\\theta = \\begin{bmatrix} \\pi R \\\\ 0 \\end{bmatrix}\n$$\nThis serves as the benchmark against which the numerical approximations are compared.\n\nThe first numerical approach is the **Immersed Boundary (IB) method**. This method represents the singular force concentrated on the curve $\\Gamma$ as a regularized force field spread over a small neighborhood of the curve. This is achieved using a regularized Dirac delta function, $\\delta_\\varepsilon(\\phi)$, where $\\phi$ is the signed distance function to the curve $\\Gamma$. The total force is then approximated by integrating this regularized force field over the entire computational domain $\\Omega$:\n$$\n\\mathbf{F}_{\\mathrm{IB}}(\\varepsilon, h) = \\iint_{\\Omega} \\mathbf{f}(x,y) \\, \\delta_\\varepsilon(\\phi(x,y)) \\, |\\nabla\\phi(x,y)| \\, dx \\, dy\n$$\nGiven that $|\\nabla \\phi| = 1$ for a signed distance function, this simplifies the integral. We discretize this integral as a Riemann sum over the grid cells. For each grid point $(x_i, y_j)$, we evaluate the force density $\\mathbf{f}(x_i, y_j)$, the signed distance $\\phi(x_i, y_j)$, and the delta function $\\delta_\\varepsilon(\\phi(x_i, y_j))$. The total force is then the sum of these contributions scaled by the cell area $h^2$:\n$$\n\\mathbf{F}_{\\mathrm{IB}} \\approx \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\mathbf{f}(x_i, y_j) \\, \\delta_\\varepsilon(\\phi(x_i, y_j)) \\, h^2\n$$\nThe implementation involves computing these quantities on the $N \\times N$ grid and performing the summation.\n\nThe second numerical approach is the **Cut-Cell (CC) method**. This method provides a sharp representation of the geometry by explicitly reconstructing the curve $\\Gamma$ within each grid cell it intersects. The procedure is as follows:\n$1$. Iterate through each grid cell in the domain. A cell is defined by four adjacent grid points.\n$2$. For each cell, determine if it is \"cut\" by the curve $\\Gamma$. This is detected by checking if the signed distance function $\\phi$ changes sign between the cell's vertices. If all vertices have $\\phi$ values of the same sign, the cell is entirely inside or outside the curve and does not contribute to the line integral.\n$3$. If a cell is cut, the intersection points of $\\Gamma$ with the cell's edges are found. This is done by linear interpolation of $\\phi$ along each edge. For an edge connecting vertices $\\mathbf{p}_1$ and $\\mathbf{p}_2$ with signed distance values $\\phi_1$ and $\\phi_2$, the intersection point $\\mathbf{p}_{\\text{int}}$ where $\\phi=0$ is given by:\n$$\n\\mathbf{p}_{\\text{int}} = \\frac{\\phi_2 \\mathbf{p}_1 - \\phi_1 \\mathbf{p}_2}{\\phi_2 - \\phi_1}\n$$\n$4$. For a smooth curve like a circle and a sufficiently fine grid, each cut cell will have exactly two intersection points. These two points define a line segment $s$ which approximates the portion of $\\Gamma$ within that cell.\n$5$. The line integral is then approximated by summing the contributions from all such segments:\n$$\n\\mathbf{F}_{\\mathrm{CC}}(h) \\approx \\sum_{s} \\mathbf{f}(\\mathbf{m}_s) \\, |s|\n$$\nwhere $|s|$ is the length of segment $s$ and $\\mathbf{m}_s$ is its midpoint.\n\nFor each test case, both $\\mathbf{F}_{\\mathrm{IB}}$ and $\\mathbf{F}_{\\mathrm{CC}}$ are computed. The errors are then calculated as the Euclidean norm of the difference between the numerical approximation and the exact force $\\mathbf{F}_{\\mathrm{true}}$:\n$$\ne_{\\mathrm{IB}} = \\left\\|\\mathbf{F}_{\\mathrm{IB}} - \\mathbf{F}_{\\mathrm{true}}\\right\\|_2, \\qquad e_{\\mathrm{CC}} = \\left\\|\\mathbf{F}_{\\mathrm{CC}} - \\mathbf{F}_{\\mathrm{true}}\\right\\|_2\n$$\nThese error values are collected for all specified test cases and presented as the final output. It is noteworthy that in Test $4$, the circle extends slightly beyond the computational domain $\\Omega$. Both numerical methods operate strictly within $\\Omega$, thus they will approximate the integral over the truncated curve $\\Gamma \\cap \\Omega$. The comparison is still made against $\\mathbf{F}_{\\mathrm{true}}$, which is the integral over the full circle $\\Gamma$. This introduces a domain truncation error into the computed error metrics for that specific test case.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares immersed-boundary and cut-cell approximations of a line integral.\n    \"\"\"\n    test_cases = [\n        # (L, R, N, (cx, cy), k_eps)\n        (1.2, 0.9, 33, (0.0, 0.0), 1.5),\n        (1.2, 0.9, 33, (0.2, -0.15), 0.5),\n        (1.2, 0.9, 65, (0.2, -0.15), 1.5),\n        (1.2, 0.9, 129, (0.37, 0.22), 1.5),\n    ]\n\n    results = []\n    for L, R, N, (cx, cy), k_eps in test_cases:\n        h = (2 * L) / (N - 1)\n        eps = k_eps * h\n        \n        # Grid setup\n        x_coords = np.linspace(-L, L, N)\n        y_coords = np.linspace(-L, L, N)\n        xx, yy = np.meshgrid(x_coords, y_coords)\n\n        # Signed distance function\n        phi = np.sqrt((xx - cx)**2 + (yy - cy)**2) - R\n        \n        # Exact force\n        F_true = np.array([np.pi * R, 0.0])\n\n        # --- Immersed Boundary (IB) Calculation ---\n        F_ib = np.zeros(2)\n        \n        # Active region for delta function\n        active_mask = np.abs(phi) <= eps\n\n        phi_active = phi[active_mask]\n        xx_active = xx[active_mask]\n        yy_active = yy[active_mask]\n\n        delta_eps = (1.0 / (2.0 * eps)) * (1.0 + np.cos(np.pi * phi_active / eps))\n        \n        theta_active = np.arctan2(yy_active - cy, xx_active - cx)\n        \n        fx_active = np.cos(3 * theta_active) + 0.5\n        fy_active = np.sin(2 * theta_active)\n\n        F_ib[0] = np.sum(fx_active * delta_eps) * h**2\n        F_ib[1] = np.sum(fy_active * delta_eps) * h**2\n        \n        e_ib = np.linalg.norm(F_ib - F_true)\n        \n        # --- Cut-Cell (CC) Calculation ---\n        F_cc = np.zeros(2)\n        \n        phi_grid = phi\n\n        for j in range(N - 1):\n            for i in range(N - 1):\n                # Vertices (BL, BR, TR, TL) and their phi values\n                points = [\n                    np.array([x_coords[i], y_coords[j]]),\n                    np.array([x_coords[i+1], y_coords[j]]),\n                    np.array([x_coords[i+1], y_coords[j+1]]),\n                    np.array([x_coords[i], y_coords[j+1]])\n                ]\n                phis = [\n                    phi_grid[j, i], \n                    phi_grid[j, i+1], \n                    phi_grid[j+1, i+1], \n                    phi_grid[j+1, i]\n                ]\n\n                # If all phi values have the same sign, cell is not cut\n                if not (np.all(np.array(phis) > 0) or np.all(np.array(phis) < 0)):\n                    intersections = []\n                    for k in range(4):\n                        p1, p2 = points[k], points[(k + 1) % 4]\n                        phi1, phi2 = phis[k], phis[(k + 1) % 4]\n\n                        if phi1 * phi2 < 0:\n                            # Linear interpolation to find the zero-crossing at phi=0\n                            p_int = (p1 * phi2 - p2 * phi1) / (phi2 - phi1)\n                            intersections.append(p_int)\n                    \n                    if len(intersections) == 2:\n                        p_a, p_b = intersections\n                        \n                        # Segment length\n                        length_s = np.linalg.norm(p_a - p_b)\n                        \n                        # Midpoint\n                        m_s = (p_a + p_b) / 2.0\n                        \n                        # Force at midpoint\n                        theta_m = np.arctan2(m_s[1] - cy, m_s[0] - cx)\n                        f_m = np.array([\n                            np.cos(3 * theta_m) + 0.5,\n                            np.sin(2 * theta_m)\n                        ])\n                        \n                        F_cc += f_m * length_s\n\n        e_cc = np.linalg.norm(F_cc - F_true)\n        \n        results.extend([e_ib, e_cc])\n\n    # Format output\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2401412"}, {"introduction": "While powerful, explicit cut-cell methods face a significant practical hurdle known as the \"small cell problem.\" This exercise addresses the severe time-step restriction imposed by small cut cells, a direct consequence of the Courant-Friedrichs-Lewy (CFL) stability condition [@problem_id:2401456]. You will design and implement an optimal local time-stepping (LTS) scheme, a powerful technique to create an efficient and practical algorithm by overcoming this fundamental numerical bottleneck.", "problem": "Consider the one-dimensional linear advection equation $\\partial_t q + a\\,\\partial_x q = 0$ on a periodic interval discretized by a uniform Cartesian mesh with nominal cell width $h$. An immersed boundary cuts some cells, so that only a fraction $\\alpha_j \\in (0,1]$ of the nominal volume of cell $j$ contains fluid. In one spatial dimension the effective fluid length of a cut cell is $h_j = \\alpha_j h$. Assume a conservative explicit finite-volume update is applied to each cell, and let $\\nu \\in (0,1]$ denote a prescribed Courant number. The base time step for uncut cells is defined by the uniform-cell stability restriction $\\Delta t_{\\text{base}} = \\nu h / |a|$. Local time stepping is introduced by assigning to each cell an integer subcycling factor $r_j \\in \\{1,2,4,8,\\dots\\}$ (a power of two), so that the cell time step is $\\Delta t_j = \\Delta t_{\\text{base}}/r_j$. Stability requires that every cell satisfies the Courant–Friedrichs–Lewy inequality $|a|\\,\\Delta t_j / h_j \\le \\nu$. Let $T_{\\text{end}}$ be a final time such that $N_{\\text{base}} = T_{\\text{end}} / \\Delta t_{\\text{base}}$ is an integer, so each uncut cell executes exactly $N_{\\text{base}}$ base steps.\n\nYour task is to determine, for each test case listed below, a choice of subcycling factors $r_j$ that satisfies the stability inequality and the power-of-two constraint, minimizes the total number of cell updates over $[0,T_{\\text{end}}]$, and to quantify the efficiency of local time stepping relative to a uniform-small-step scheme. Here, a cell update means advancing that cell by its local time step once. For the uniform-small-step scheme, all cells are advanced with $\\Delta t_{\\text{uniform}} = \\Delta t_{\\text{base}} / R_{\\max}$ where $R_{\\max} = \\max_j r_j$.\n\nFor each test case, compute and report:\n- The list of subcycling factors $[r_1,\\dots,r_M]$ (integers).\n- The total number of updates performed by the local scheme $N_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j$ (integer).\n- The total number of updates performed by the uniform-small-step scheme $N_{\\text{uniform}} = N_{\\text{base}}\\,M\\,R_{\\max}$ (integer).\n- The efficiency gain $G = N_{\\text{uniform}}/N_{\\text{local}}$ rounded to six decimal places (float).\n- A boolean indicating whether the stability inequality $|a|\\,\\Delta t_j / h_j \\le \\nu$ holds for all cells under your chosen $r_j$ (boolean).\n\nUse the following test suite. All lengths must be in meters ($\\mathrm{m}$), speeds in meters per second ($\\mathrm{m/s}$), and times in seconds ($\\mathrm{s}$).\n- Test case A (happy path): $h = 1.0\\,\\mathrm{m}$, $a = 1.0\\,\\mathrm{m/s}$, $\\nu = 0.5$, $T_{\\text{end}} = 1.0\\,\\mathrm{s}$, $\\boldsymbol{\\alpha} = [\\,1.0,\\,0.5,\\,0.25,\\,0.125\\,]$.\n- Test case B (all uncut): $h = 0.5\\,\\mathrm{m}$, $a = 2.0\\,\\mathrm{m/s}$, $\\nu = 0.5$, $T_{\\text{end}} = 1.0\\,\\mathrm{s}$, $\\boldsymbol{\\alpha} = [\\,1.0,\\,1.0,\\,1.0\\,]$.\n- Test case C (extreme cut): $h = 1.0\\,\\mathrm{m}$, $a = 2.0\\,\\mathrm{m/s}$, $\\nu = 0.4$, $T_{\\text{end}} = 1.0\\,\\mathrm{s}$, $\\boldsymbol{\\alpha} = [\\,1.0,\\,0.2,\\,0.03\\,]$.\n- Test case D (boundary equality): $h = 2.0\\,\\mathrm{m}$, $a = 1.0\\,\\mathrm{m/s}$, $\\nu = 1.0$, $T_{\\text{end}} = 4.0\\,\\mathrm{s}$, $\\boldsymbol{\\alpha} = [\\,1.0,\\,0.5,\\,0.25,\\,0.125\\,]$.\n\nYour program must produce a single line of output containing the results for the test cases in the same order, aggregated into one outer list. Each test case result must itself be a list with the structure [r_list, N_local, N_uniform, G, stable_flag]. The single line must be a comma-separated list enclosed in square brackets, for example, \"[[...],[...],[...],[...]]\".", "solution": "The problem as stated will first be subjected to a rigorous validation process.\n\n**Step 1: Extracted Givens**\n\nThe fundamental physical model is the one-dimensional linear advection equation: $\\partial_t q + a\\,\\partial_x q = 0$.\nThe problem is discretized on a uniform Cartesian mesh with cell width $h$.\nImmersed boundaries result in cut cells, where cell $j$ has a fluid volume fraction $\\alpha_j \\in (0,1]$ and an effective length $h_j = \\alpha_j h$.\nA conservative explicit finite-volume update is used.\nThe prescribed Courant number is $\\nu \\in (0,1]$.\nThe time step for uncut cells (where $\\alpha_j=1$) is $\\Delta t_{\\text{base}} = \\nu h / |a|$.\nLocal time stepping is employed, with each cell $j$ having a subcycling factor $r_j$ and a local time step $\\Delta t_j = \\Delta t_{\\text{base}}/r_j$.\nThe subcycling factors are constrained to be powers of two: $r_j \\in \\{1, 2, 4, \\dots\\}$.\nThe Courant–Friedrichs–Lewy (CFL) stability condition for each cell is $|a|\\,\\Delta t_j / h_j \\le \\nu$.\nThe simulation runs until a final time $T_{\\text{end}}$. The quantity $N_{\\text{base}} = T_{\\text{end}} / \\Delta t_{\\text{base}}$ is specified to be an integer.\nThe objective is to choose the set of subcycling factors $\\{r_j\\}$ to minimize the total number of cell updates, $N_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j$.\nA reference uniform-small-step scheme is defined with a time step $\\Delta t_{\\text{uniform}} = \\Delta t_{\\text{base}} / R_{\\max}$, where $R_{\\max} = \\max_j r_j$. The total number of updates for this scheme is $N_{\\text{uniform}} = N_{\\text{base}}\\,M\\,R_{\\max}$.\nThe efficiency gain is defined as $G = N_{\\text{uniform}}/N_{\\text{local}}$.\nThe required outputs for each test case are: the list of factors $[r_1,\\dots,r_M]$, the total updates $N_{\\text{local}}$ and $N_{\\text{uniform}}$, the gain $G$, and a boolean stability flag.\nThe test cases provide specific values for $h$, $a$, $\\nu$, $T_{\\text{end}}$, and the vector $\\boldsymbol{\\alpha}$.\n\n**Step 2: Validation of Problem Statement**\n\nThe problem is scientifically grounded, being based on the standard advection equation and the well-established finite-volume method with local time-stepping for handling the small-cell problem in immersed boundary contexts. The CFL condition is a fundamental principle of explicit numerical methods. The problem is well-posed, presenting a constrained optimization problem with a clear objective function (minimizing $N_{\\text{local}}$) and well-defined constraints on the variables ($r_j$). The language is objective and mathematically precise. The setup is self-contained and free of contradictions. The provided data are dimensionally consistent and physically plausible. The problem does not violate any of the specified invalidity criteria.\n\n**Step 3: Verdict and Action**\n\nThe problem is deemed valid. A solution will be formulated.\n\n**Derivation of Optimal Subcycling Factors**\n\nThe objective is to minimize the total number of cell updates over the simulation time $[0, T_{\\text{end}}]$, given by the expression:\n$$\nN_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j\n$$\nSince $N_{\\text{base}}$ is a positive constant for any given test case, minimizing $N_{\\text{local}}$ is equivalent to minimizing the sum of the subcycling factors, $\\sum_{j=1}^M r_j$. As the choice of each $r_j$ is independent of the others, the sum is minimized by selecting the smallest possible valid $r_j$ for each cell $j$.\n\nThe constraints on each $r_j$ are:\n1. $r_j$ must be a power of two, i.e., $r_j = 2^k$ for some non-negative integer $k$.\n2. $r_j$ must satisfy the local CFL stability inequality: $|a|\\,\\Delta t_j / h_j \\le \\nu$.\n\nWe analyze the stability inequality by substituting the definitions of $\\Delta t_j$ and $h_j$:\n$$\n\\frac{|a|}{h_j} \\Delta t_j = \\frac{|a|}{\\alpha_j h} \\left( \\frac{\\Delta t_{\\text{base}}}{r_j} \\right) \\le \\nu\n$$\nNow, substitute the definition of $\\Delta t_{\\text{base}} = \\nu h / |a|$:\n$$\n\\frac{|a|}{\\alpha_j h} \\left( \\frac{1}{r_j} \\frac{\\nu h}{|a|} \\right) \\le \\nu\n$$\nAssuming $a \\ne 0$ and $h, \\nu > 0$, we can simplify the expression:\n$$\n\\frac{1}{\\alpha_j r_j} \\le 1\n$$\nSince $\\alpha_j > 0$ and $r_j$ must be positive, this is equivalent to:\n$$\nr_j \\ge \\frac{1}{\\alpha_j}\n$$\nCombining this with the power-of-two constraint, the optimal subcycling factor $r_j$ for cell $j$ is the smallest integer power of two that is greater than or equal to $1/\\alpha_j$.\n\nThis can be expressed formally. Let the minimum required value be $s_j = 1/\\alpha_j$. We seek the smallest non-negative integer $k$ such that $2^k \\ge s_j$. Taking the base-2 logarithm, we find $k \\ge \\log_2(s_j)$. Since $k$ must be an integer, the smallest such $k$ is $\\lceil \\log_2(s_j) \\rceil$. Therefore, the optimal subcycling factor for cell $j$ is:\n$$\nr_j = 2^{\\lceil \\log_2(1/\\alpha_j) \\rceil}\n$$\nFor uncut cells, $\\alpha_j=1$, which gives $1/\\alpha_j=1$. Since $\\log_2(1)=0$, we have $\\lceil 0 \\rceil = 0$ and $r_j = 2^0 = 1$, which is correct. This corresponds to a cell taking the base time step $\\Delta t_{\\text{base}}$. For cut cells, $\\alpha_j < 1$, which requires $r_j > 1$.\n\n**Calculation of Performance Metrics and Stability Check**\n\nOnce the list of optimal factors $\\boldsymbol{r} = [r_1, \\dots, r_M]$ has been determined for a given test case, the remaining quantities are calculated as follows:\n1. The maximum subcycling factor is $R_{\\max} = \\max_j r_j$.\n2. The number of base steps is $N_{\\text{base}} = T_{\\text{end}} / \\Delta t_{\\text{base}} = T_{\\text{end}} / (\\nu h / |a|)$.\n3. The total number of updates for the local time-stepping scheme is $N_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j$.\n4. The total number of updates for the uniform-small-step scheme is $N_{\\text{uniform}} = N_{\\text{base}} M R_{\\max}$.\n5. The efficiency gain is $G = N_{\\text{uniform}} / N_{\\text{local}}$.\n6. The boolean stability flag is determined by checking the CFL condition $|a|\\,\\Delta t_j / h_j \\le \\nu$ for all cells $j=1,\\dots,M$. By our construction, $r_j \\ge 1/\\alpha_j$, which is equivalent to the CFL condition being satisfied. Therefore, this flag will always be true.\n\nThis algorithm is applied to each test case to produce the required results. The final implementation will perform these calculations and format the output as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the local time stepping optimization problem for a series of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A: h, a, nu, T_end, alpha_list\n        (1.0, 1.0, 0.5, 1.0, [1.0, 0.5, 0.25, 0.125]),\n        # Test Case B\n        (0.5, 2.0, 0.5, 1.0, [1.0, 1.0, 1.0]),\n        # Test Case C\n        (1.0, 2.0, 0.4, 1.0, [1.0, 0.2, 0.03]),\n        # Test Case D\n        (2.0, 1.0, 1.0, 4.0, [1.0, 0.5, 0.25, 0.125]),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        h, a, nu, T_end, alpha_list = case\n        \n        # Determine the optimal subcycling factor r_j for each cell\n        r_list = []\n        for alpha_j in alpha_list:\n            # The stability condition r_j >= 1/alpha_j must be satisfied.\n            # We want the smallest power of two that meets this condition.\n            min_r_val = 1.0 / alpha_j\n            \n            # Efficiently find the smallest power of two >= min_r_val\n            # Can be found with logarithms: r = 2**ceil(log2(min_r_val))\n            # or with a simple loop.\n            r_j = 1\n            while r_j < min_r_val:\n                r_j *= 2\n            r_list.append(int(r_j))\n            \n        # Calculate performance metrics\n        M = len(alpha_list)\n        abs_a = abs(a)\n        \n        # Base time step and number of base steps\n        delta_t_base = nu * h / abs_a\n        N_base = int(round(T_end / delta_t_base))\n\n        # Total updates for local and uniform schemes\n        sum_r = sum(r_list)\n        N_local = N_base * sum_r\n        \n        R_max = max(r_list) if r_list else 1\n        N_uniform = N_base * M * R_max\n        \n        # Efficiency gain\n        G = N_uniform / N_local if N_local > 0 else 0.0\n        G_rounded = round(G, 6)\n        \n        # Verify stability for the chosen r_j\n        stable_flag = True\n        for r_j, alpha_j in zip(r_list, alpha_list):\n            h_j = alpha_j * h\n            delta_t_j = delta_t_base / r_j\n            cfl_val = abs_a * delta_t_j / h_j\n            # Use a small tolerance for floating point comparison\n            if cfl_val > nu + 1e-9:\n                stable_flag = False\n                break\n                \n        # Aggregate results for this case\n        case_result = [r_list, int(N_local), int(N_uniform), G_rounded, stable_flag]\n        all_results.append(case_result)\n\n    # Convert each element of the result lists to a string for join\n    def format_results(results):\n        formatted_list = []\n        for item in results:\n            if isinstance(item, list):\n                formatted_list.append(f\"[{','.join(map(str, item))}]\")\n            elif isinstance(item, float):\n                # Ensure float has required decimal places in string representation\n                formatted_list.append(f\"{item:.6f}\")\n            else:\n                 formatted_list.append(str(item))\n        return f\"[{','.join(formatted_list)}]\"\n\n    # Final print statement in the exact required format.\n    final_output_str = f\"[{','.join(map(format_results, all_results))}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2401456"}]}