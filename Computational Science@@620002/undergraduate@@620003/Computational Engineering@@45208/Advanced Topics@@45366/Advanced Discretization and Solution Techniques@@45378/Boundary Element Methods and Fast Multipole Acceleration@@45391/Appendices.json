{"hands_on_practices": [{"introduction": "To truly grasp the Boundary Element Method, we must start with first principles. This exercise [@problem_id:2374801] serves as a foundational practice, stripping BEM down to its simplest non-trivial form: a $2 \\times 2$ system. By analytically modeling the capacitance of two parallel strips, you will personally handle every core component of a BEM solution—from writing the integral equation using the Green's function to assembling and solving the matrix system for a meaningful physical quantity.", "problem": "Consider two identical, perfectly conducting, straight strips in two-dimensional electrostatics, embedded in a homogeneous medium of permittivity $\\varepsilon$. The strips are parallel to the $x$-axis, centered at $y=+h$ (upper strip) and $y=-h$ (lower strip), and each extends from $x=-a$ to $x=+a$. Assume invariance in the out-of-plane direction (per-unit-depth formulation).\n\nThe upper strip is held at potential $+V_{0}/2$ and the lower strip at potential $-V_{0}/2$, with $V_{0} > 0$. Model each strip as a single constant source element carrying an unknown uniform line charge density $\\lambda_{1}$ (upper) and $\\lambda_{2}$ (lower), and collocate the boundary condition at the center of each strip (at $x=0$ on each strip).\n\nUse the direct boundary element method with the free-space two-dimensional fundamental solution of the Laplace equation,\n$$\nG(\\mathbf{r}) \\;=\\; -\\frac{1}{2\\pi}\\,\\ln\\!\\left(\\frac{|\\mathbf{r}|}{L_{0}}\\right),\n$$\nwhere $L_{0} > 0$ is an arbitrary reference length introduced to render the logarithm’s argument dimensionless. Write the two-by-two linear system for the nodal potentials at the collocation points in terms of the unknown line charge densities, evaluate the matrix entries analytically, solve for $\\lambda_{1}$ and $\\lambda_{2}$, and then compute the capacitance per unit out-of-plane depth,\n$$\nC' \\;=\\; \\frac{Q'}{V_{0}}, \\quad \\text{with} \\quad Q' \\;=\\; \\int_{-a}^{a} \\lambda_{1}\\,\\mathrm{d}x \\;=\\; 2a\\,\\lambda_{1}.\n$$\nProvide your final answer as a single closed-form analytic expression for $C'$ in terms of $\\varepsilon$, $a$, and $h$. Do not perform any numerical approximation or rounding. Express the capacitance per unit out-of-plane depth in farads per meter.", "solution": "The problem statement is subjected to validation prior to any attempt at a solution.\n\nStep 1: Extract Givens.\n- System: Two identical, perfectly conducting, straight strips in two-dimensional electrostatics.\n- Medium: Homogeneous with permittivity $\\varepsilon$.\n- Geometry: Strips are parallel to the $x$-axis. Upper strip centered at $y=+h$, lower strip at $y=-h$. Each extends from $x=-a$ to $x=+a$. System is invariant in the out-of-plane direction.\n- Boundary Conditions: Upper strip potential is $\\phi_1 = +V_{0}/2$. Lower strip potential is $\\phi_2 = -V_{0}/2$, with $V_{0} > 0$.\n- Model: Each strip is a single constant source element. Upper strip carries uniform line charge density $\\lambda_{1}$. Lower strip carries uniform line charge density $\\lambda_{2}$.\n- Method: Direct boundary element method (BEM) with collocation at the center of each strip. The center of the upper strip is $\\mathbf{r}_1 = (0, +h)$. The center of the lower strip is $\\mathbf{r}_2 = (0,-h)$.\n- Fundamental Solution: The 2D free-space Green's function for the Laplace equation is given as $G(\\mathbf{r}) = -\\frac{1}{2\\pi}\\,\\ln\\left(\\frac{|\\mathbf{r}|}{L_{0}}\\right)$, where $L_{0} > 0$ is a reference length.\n- Objective:\n  1. Formulate the $2 \\times 2$ linear system for nodal potentials.\n  2. Evaluate matrix entries analytically.\n  3. Solve for $\\lambda_{1}$ and $\\lambda_{2}$.\n  4. Compute capacitance per unit out-of-plane depth, $C' = Q'/V_{0}$, where the total charge per unit depth on the upper strip is $Q' = \\int_{-a}^{a} \\lambda_{1}\\,\\mathrm{d}x = 2a\\,\\lambda_{1}$.\n  5. The final answer for $C'$ must be a closed-form expression in terms of $\\varepsilon$, $a$, and $h$.\n\nStep 2: Validate Using Extracted Givens.\n- Scientific Grounding: The problem is formulated within the established framework of two-dimensional electrostatics and the Boundary Element Method. The provided fundamental solution is correct for the 2D Laplace equation, and its use for calculating potential from a source distribution is standard.\n- Well-Posedness: The problem is well-posed. It provides all necessary information (geometry, boundary conditions, physical properties, and a simplified model) to determine a unique value for the capacitance within the constraints of the specified model.\n- Objectivity: The problem is stated using precise, objective, and standard scientific terminology.\n- Flaw Checklist: The problem does not violate any of the invalidity criteria. It is scientifically sound, formalizable, complete, feasible, well-structured, and verifiable. The employed model (single constant element per strip) is a standard coarse-grid approximation in BEM.\n\nStep 3: Verdict and Action.\nThe problem is deemed valid. A rigorous solution will now be developed.\n\nThe potential $\\phi(\\mathbf{r})$ at a field point $\\mathbf{r}=(x,y)$ generated by a line charge distribution $\\lambda(\\mathbf{r}')$ along a contour $\\Gamma$ in a medium of permittivity $\\varepsilon$ is given by the single-layer potential integral:\n$$ \\phi(\\mathbf{r}) \\;=\\; \\int_{\\Gamma} \\frac{\\lambda(\\mathbf{r}')}{\\varepsilon} G(\\mathbf{r} - \\mathbf{r}') \\,\\mathrm{d}\\Gamma' $$\nIn this problem, the contour $\\Gamma$ is composed of two disjoint strips, $\\Gamma_1$ (upper) and $\\Gamma_2$ (lower). The charge densities are constant on each strip: $\\lambda(\\mathbf{r}')=\\lambda_1$ for $\\mathbf{r}' \\in \\Gamma_1$ and $\\lambda(\\mathbf{r}')=\\lambda_2$ for $\\mathbf{r}' \\in \\Gamma_2$.\nThe potential at any point $\\mathbf{r}$ is the superposition of the potentials from both strips:\n$$ \\phi(\\mathbf{r}) \\;=\\; \\frac{\\lambda_1}{\\varepsilon} \\int_{\\Gamma_1} G(\\mathbf{r} - \\mathbf{r}') \\,\\mathrm{d}x' + \\frac{\\lambda_2}{\\varepsilon} \\int_{\\Gamma_2} G(\\mathbf{r} - \\mathbf{r}') \\,\\mathrm{d}x' $$\nwhere $\\Gamma_1$ is the segment from $(-a, h)$ to $(a, h)$ and $\\Gamma_2$ is the segment from $(-a, -h)$ to $(a, -h)$.\n\nWe apply the given boundary conditions at the collocation points, which are the centers of the strips: $\\mathbf{r}_1=(0, h)$ for the upper strip and $\\mathbf{r}_2=(0, -h)$ for the lower strip.\n$$ \\phi(\\mathbf{r}_1) = +\\frac{V_0}{2} \\quad \\text{and} \\quad \\phi(\\mathbf{r}_2) = -\\frac{V_0}{2} $$\nThis leads to a $2 \\times 2$ system of linear equations for the unknown charge densities $\\lambda_1$ and $\\lambda_2$:\n$$ \\begin{pmatrix} M_{11} & M_{12} \\\\ M_{21} & M_{22} \\end{pmatrix} \\begin{pmatrix} \\lambda_1 \\\\ \\lambda_2 \\end{pmatrix} = \\begin{pmatrix} +V_0/2 \\\\ -V_0/2 \\end{pmatrix} $$\nThe matrix entries $M_{ij}$ represent the potential at collocation point $\\mathbf{r}_i$ due to a unit charge density on strip $j$, multiplied by $1/\\varepsilon$.\n$$ M_{ij} = \\frac{1}{\\varepsilon} \\int_{\\Gamma_j} G(\\mathbf{r}_i - \\mathbf{r}') \\,\\mathrm{d}x' $$\n\nWe now evaluate the matrix entries analytically.\nFor $M_{11}$, the potential at $\\mathbf{r}_1=(0,h)$ from a unit charge on $\\Gamma_1$:\n$$ M_{11} = \\frac{1}{\\varepsilon} \\int_{-a}^{a} G((0,h) - (x',h)) \\,\\mathrm{d}x' = \\frac{1}{\\varepsilon} \\int_{-a}^{a} -\\frac{1}{2\\pi} \\ln\\left(\\frac{|-x'|}{L_0}\\right) \\,\\mathrm{d}x' $$\n$$ M_{11} = -\\frac{1}{2\\pi\\varepsilon} \\cdot 2 \\int_{0}^{a} \\ln\\left(\\frac{x'}{L_0}\\right) \\,\\mathrm{d}x' = -\\frac{1}{\\pi\\varepsilon} \\left[ x'\\ln\\left(\\frac{x'}{L_0}\\right) - x' \\right]_0^a $$\nUsing the fact that $\\lim_{x' \\to 0^+} x'\\ln(x') = 0$, we get:\n$$ M_{11} = -\\frac{1}{\\pi\\varepsilon} \\left( a\\ln\\left(\\frac{a}{L_0}\\right) - a \\right) = -\\frac{a}{\\pi\\varepsilon} \\left(\\ln\\left(\\frac{a}{L_0}\\right) - 1\\right) $$\nBy symmetry of the geometry, $M_{22} = M_{11}$.\n\nFor $M_{12}$, the potential at $\\mathbf{r}_1=(0,h)$ from a unit charge on $\\Gamma_2$:\n$$ M_{12} = \\frac{1}{\\varepsilon} \\int_{-a}^{a} G((0,h) - (x',-h)) \\,\\mathrm{d}x' = \\frac{1}{\\varepsilon} \\int_{-a}^{a} -\\frac{1}{2\\pi} \\ln\\left(\\frac{\\sqrt{x'^2 + (2h)^2}}{L_0}\\right) \\,\\mathrm{d}x' $$\n$$ M_{12} = -\\frac{1}{2\\pi\\varepsilon} \\int_{-a}^{a} \\left(\\frac{1}{2}\\ln(x'^2 + 4h^2) - \\ln(L_0)\\right) \\,\\mathrm{d}x' $$\nThe integral of $\\ln(x^2+c^2)$ is $x\\ln(x^2+c^2) - 2x + 2c\\arctan(x/c)$.\n$$ \\int_{-a}^{a} \\ln(x'^2+4h^2) \\,\\mathrm{d}x' = \\left[ x'\\ln(x'^2+4h^2) - 2x' + 4h\\arctan\\left(\\frac{x'}{2h}\\right) \\right]_{-a}^{a} $$\n$$ = 2a\\ln(a^2+4h^2) - 4a + 8h\\arctan\\left(\\frac{a}{2h}\\right) $$\nSubstituting this back into the expression for $M_{12}$:\n$$ M_{12} = -\\frac{1}{2\\pi\\varepsilon} \\left[ \\frac{1}{2}\\left(2a\\ln(a^2+4h^2) - 4a + 8h\\arctan\\left(\\frac{a}{2h}\\right)\\right) - 2a\\ln(L_0) \\right] $$\n$$ M_{12} = -\\frac{a}{\\pi\\varepsilon} \\left[ \\frac{1}{2}\\ln(a^2+4h^2) - 1 + \\frac{2h}{a}\\arctan\\left(\\frac{a}{2h}\\right) - \\ln(L_0) \\right] $$\n$$ M_{12} = -\\frac{a}{\\pi\\varepsilon} \\left[ \\ln\\left(\\frac{\\sqrt{a^2+4h^2}}{L_0}\\right) - 1 + \\frac{2h}{a}\\arctan\\left(\\frac{a}{2h}\\right) \\right] $$\nBy symmetry, $M_{21} = M_{12}$.\n\nThe system of equations is:\n$$ M_{11} \\lambda_1 + M_{12} \\lambda_2 = +\\frac{V_0}{2} $$\n$$ M_{12} \\lambda_1 + M_{11} \\lambda_2 = -\\frac{V_0}{2} $$\nAdding these two equations gives $(M_{11}+M_{12})(\\lambda_1+\\lambda_2)=0$. Since $M_{11}+M_{12} \\neq 0$ for any physical geometry, we must have $\\lambda_2 = -\\lambda_1$.\nSubstituting this into the first equation:\n$$ (M_{11} - M_{12})\\lambda_1 = \\frac{V_0}{2} \\implies \\lambda_1 = \\frac{V_0}{2(M_{11} - M_{12})} $$\nWe compute the difference $M_{11}-M_{12}$:\n$$ M_{11} - M_{12} = -\\frac{a}{\\pi\\varepsilon} \\left[ \\left(\\ln\\left(\\frac{a}{L_0}\\right) - 1\\right) - \\left(\\ln\\left(\\frac{\\sqrt{a^2+4h^2}}{L_0}\\right) - 1 + \\frac{2h}{a}\\arctan\\left(\\frac{a}{2h}\\right)\\right) \\right] $$\n$$ = -\\frac{a}{\\pi\\varepsilon} \\left[ \\ln(a) - \\ln(L_0) - \\ln(\\sqrt{a^2+4h^2}) + \\ln(L_0) - \\frac{2h}{a}\\arctan\\left(\\frac{a}{2h}\\right) \\right] $$\nThe arbitrary length $L_0$ cancels out, as it must for a physical quantity.\n$$ M_{11} - M_{12} = -\\frac{a}{\\pi\\varepsilon} \\left[ \\ln\\left(\\frac{a}{\\sqrt{a^2+4h^2}}\\right) - \\frac{2h}{a}\\arctan\\left(\\frac{a}{2h}\\right) \\right] $$\n$$ = \\frac{a}{\\pi\\varepsilon} \\left[ \\ln\\left(\\frac{\\sqrt{a^2+4h^2}}{a}\\right) + \\frac{2h}{a}\\arctan\\left(\\frac{a}{2h}\\right) \\right] $$\n$$ = \\frac{a}{\\pi\\varepsilon} \\left[ \\frac{1}{2}\\ln\\left(1+\\frac{4h^2}{a^2}\\right) + \\frac{2h}{a}\\arctan\\left(\\frac{a}{2h}\\right) \\right] $$\nNow we find $\\lambda_1$:\n$$ \\lambda_1 = \\frac{V_0}{2} \\left( \\frac{\\pi\\varepsilon}{a \\left[ \\frac{1}{2}\\ln\\left(1+\\frac{4h^2}{a^2}\\right) + \\frac{2h}{a}\\arctan\\left(\\frac{a}{2h}\\right) \\right]} \\right) $$\nThe capacitance per unit depth is $C' = Q'/V_0 = 2a\\lambda_1/V_0$.\n$$ C' = \\frac{2a}{V_0} \\lambda_1 = \\frac{a}{V_0} \\frac{V_0 \\pi\\varepsilon}{a \\left[ \\frac{1}{2}\\ln\\left(1+\\frac{4h^2}{a^2}\\right) + \\frac{2h}{a}\\arctan\\left(\\frac{a}{2h}\\right) \\right]} $$\n$$ C' = \\frac{\\pi\\varepsilon}{\\frac{1}{2}\\ln\\left(1+\\frac{4h^2}{a^2}\\right) + \\frac{2h}{a}\\arctan\\left(\\frac{a}{2h}\\right)} $$\nMultiplying numerator and denominator by $2$ to simplify the expression yields the final result.\n$$ C' = \\frac{2\\pi\\varepsilon}{\\ln\\left(1+\\frac{4h^2}{a^2}\\right) + \\frac{4h}{a}\\arctan\\left(\\frac{a}{2h}\\right)} $$\nThis expression gives the capacitance per unit depth in Farads per meter, depending only on $\\varepsilon$, $a$, and $h$, as required.\nThe result can be verified in the limit of an ideal parallel-plate capacitor where $a \\gg h$. Let $z=2h/a \\ll 1$. The denominator becomes $\\ln(1+z^2) + 2z \\arctan(1/z) \\approx z^2 + 2z(\\pi/2 - z) = \\pi z - z^2 \\approx \\pi z = 2\\pi h/a$.\nThus, $C' \\approx \\frac{2\\pi\\varepsilon}{2\\pi h/a} = \\varepsilon\\frac{a}{h}$, which is the correct formula for capacitance per unit depth of two parallel plates of width $2a$ and separation $2h$, neglecting fringing fields. The obtained formula correctly includes the fringing effects within the approximations of the model.", "answer": "$$\n\\boxed{\\frac{2\\pi\\varepsilon}{\\ln\\left(1+\\frac{4h^2}{a^2}\\right) + \\frac{4h}{a}\\arctan\\left(\\frac{a}{2h}\\right)}}\n$$", "id": "2374801"}, {"introduction": "While the previous exercise demonstrates the elegance of BEM, scaling it to thousands or millions of elements reveals a critical bottleneck: the dense matrix leads to a computational cost scaling as $O(N^2)$. The Fast Multipole Method (FMM) offers a revolutionary solution, reducing the complexity to nearly linear time. This problem [@problem_id:2374839] is a theoretical workout that takes you 'under the hood' of FMM to understand precisely where this remarkable efficiency comes from by analyzing the computational cost of each step in the algorithm.", "problem": "Consider the evaluation of a single-layer potential arising in a Boundary Element Method (BEM) for the Laplace equation in two spatial dimensions. All source points lie on the line segment $\\{(x,0): 0 \\le x \\le 1\\}$, and all target points lie on the parallel line segment $\\{(x,d): 0 \\le x \\le 1\\}$, where $d>0$ is fixed. There are $N$ sources and $N$ targets, both uniformly distributed along their respective segments. The kernel is the free-space Green’s function for the Laplace equation in two spatial dimensions, $G(\\mathbf{r}) = -\\frac{1}{2\\pi}\\ln|\\mathbf{r}|$.\n\nSuppose the evaluation of the potential at the $N$ targets is accelerated by a Fast Multipole Method (FMM). The FMM uses a dyadic hierarchical partition (branching factor $2$) of each segment into boxes down to leaves that contain at most $n_{0}$ points, where $n_{0}$ is fixed and independent of $N$. The multipole and local expansions are truncated at order $p$, chosen to meet a prescribed accuracy $\\varepsilon$, with $p$ independent of $N$ because $d$ is fixed. Assume the separation $d$ is strictly larger than the maximum leaf-box width so that no direct particle-to-particle near-field evaluations are performed between sources and targets; all interactions are mediated by expansions. For the cost model, assume:\n- A source-to-multipole (S2M) operation for one source in a leaf box costs $c_{\\mathrm{S2M}}\\,p$.\n- A multipole-to-multipole (M2M) translation for one box costs $c_{\\mathrm{M2M}}\\,p^{2}$.\n- A multipole-to-local (M2L) translation for one well-separated source–target box pair costs $c_{\\mathrm{M2L}}\\,p^{2}$.\n- A local-to-local (L2L) translation for one box costs $c_{\\mathrm{L2L}}\\,p^{2}$.\n- A local-to-target (L2T) evaluation for one target costs $c_{\\mathrm{L2T}}\\,p$.\n\nAssume there exists a level-independent constant $q$ such that, at any level of the hierarchy, the well-separated interaction list of any target box contains at most $q$ source boxes. All constants $c_{\\mathrm{S2M}}$, $c_{\\mathrm{M2M}}$, $c_{\\mathrm{M2L}}$, $c_{\\mathrm{L2L}}$, $c_{\\mathrm{L2T}}$, $n_{0}$, $p$, $q$, and $d$ are positive and independent of $N$.\n\nAs $N \\to \\infty$, let $T(N)$ denote the total arithmetic work of the FMM under this model. Determine the exponent $\\alpha$ such that $T(N) = \\Theta(N^{\\alpha})$. Provide the value of $\\alpha$ as a real number. No rounding is required.", "solution": "The user has provided a problem concerning the computational complexity of the Fast Multipole Method (FMM) applied to a specific one-dimensional particle distribution embedded in a two-dimensional space. I must first validate the problem statement and then, if it is valid, provide a rigorous derivation of the solution.\n\n### Step 1: Extract Givens\n- **System**: $N$ source points and $N$ target points.\n- **Source Domain**: Line segment $\\{(x,0): 0 \\le x \\le 1\\}$, uniformly distributed.\n- **Target Domain**: Line segment $\\{(x,d): 0 \\le x \\le 1\\}$, uniformly distributed, with $d>0$.\n- **Interaction Kernel**: $G(\\mathbf{r}) = -\\frac{1}{2\\pi}\\ln|\\mathbf{r}|$, the 2D Laplacian Green's function.\n- **FMM Hierarchy**: Dyadic partitioning (branching factor $2$) of the 1D segments.\n- **Leaf Box Criterion**: Maximum of $n_{0}$ points per leaf box, where $n_{0}$ is a constant.\n- **Expansion Order**: Constant integer $p$, independent of $N$.\n- **Interaction Condition**: No direct near-field interactions; all interactions are handled by expansions.\n- **Interaction List**: Any target box at any level interacts with at most $q$ source boxes, where $q$ is a constant.\n- **Cost Model**:\n    - S2M (per source): $c_{\\mathrm{S2M}}\\,p$\n    - M2M (per box): $c_{\\mathrm{M2M}}\\,p^{2}$\n    - M2L (per well-separated pair): $c_{\\mathrm{M2L}}\\,p^{2}$\n    - L2L (per box): $c_{\\mathrm{L2L}}\\,p^{2}$\n    - L2T (per target): $c_{\\mathrm{L2T}}\\,p$\n- **Constants**: $c_{\\mathrm{S2M}}$, $c_{\\mathrm{M2M}}$, $c_{\\mathrm{M2L}}$, $c_{\\mathrm{L2L}}$, $c_{\\mathrm{L2T}}$, $n_{0}$, $p$, $q$, $d$ are all positive constants independent of $N$.\n- **Objective**: Determine the exponent $\\alpha$ in the total computational cost scaling law $T(N) = \\Theta(N^{\\alpha})$ as $N \\to \\infty$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is evaluated against the validation criteria.\n1.  **Scientifically Grounded**: The problem is a standard theoretical analysis of the FMM, a cornerstone algorithm in computational engineering and physics. The cost model is consistent with established literature on the 2D FMM. The problem is sound.\n2.  **Well-Posed**: The problem is clearly defined. It provides a complete cost model and asks for a specific, calculable quantity (the scaling exponent $\\alpha$). A unique solution is expected.\n3.  **Objective**: The problem is stated using precise, formal language common to the field of scientific computing. There is no subjectivity.\n\nThe problem does not exhibit any of the defined flaws. It is not scientifically unsound, non-formalizable, incomplete, contradictory, unrealistic, or ill-posed. It is a valid, well-structured problem in computational complexity theory.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A full solution will be provided.\n\n### Derivation of the Solution\nThe total computational work, $T(N)$, is the sum of the costs of the five stages of the FMM algorithm. We will analyze the cost of each stage as a function of $N$.\n\nFirst, we must characterize the hierarchical tree structure. The source and target points are distributed on line segments of length $1$. The point density is $\\rho = N/1 = N$. The domain is partitioned dyadically, meaning each box is split into $2$ child boxes. The number of boxes at level $l$ of the tree is $2^l$. The tree recursion stops at the leaf level, $L$, when the number of points in a box is approximately $n_{0}$. A box at level $l$ has length $2^{-l}$. The number of points in a box at level $L$ is $\\rho \\cdot 2^{-L} = N \\cdot 2^{-L}$. The leaf condition is $N \\cdot 2^{-L} \\lesssim n_{0}$, which implies $2^L \\gtrsim N/n_{0}$. The depth of the tree is therefore $L = \\Theta(\\log N)$.\n\nThe total number of boxes in the tree is the sum of boxes over all levels from $l=0$ to $l=L$:\n$$\n\\text{Total boxes} = \\sum_{l=0}^{L} 2^l = 2^{L+1} - 1 = \\Theta(2^L)\n$$\nSince $2^L = \\Theta(N)$, the total number of boxes in the tree is $\\Theta(N)$.\n\nNow, we analyze the cost of each FMM stage:\n\n1.  **S2M (Source-to-Multipole) Cost**: This operation is performed for each of the $N$ source points to form the multipole expansions in the leaf boxes.\n    - Cost per source is $c_{\\mathrm{S2M}}\\,p$.\n    - Total S2M cost: $T_{\\mathrm{S2M}} = N \\cdot (c_{\\mathrm{S2M}}\\,p)$.\n    - Since $c_{\\mathrm{S2M}}$ and $p$ are constants, $T_{\\mathrm{S2M}} = \\Theta(N)$.\n\n2.  **M2M (Multipole-to-Multipole) Cost**: This constitutes the upward pass of the FMM. At each level $l$ from $L-1$ down to $0$, the multipole expansion of each parent box is computed from the expansions of its children. This operation is performed once for every non-leaf box.\n    - Number of non-leaf boxes is $\\sum_{l=0}^{L-1} 2^l = 2^L-1 = \\Theta(N)$.\n    - Cost per M2M translation is $c_{\\mathrm{M2M}}\\,p^2$.\n    - Total M2M cost: $T_{\\mathrm{M2M}} = \\Theta(N) \\cdot (c_{\\mathrm{M2M}}\\,p^2) = \\Theta(N)$.\n\n3.  **M2L (Multipole-to-Local) Cost**: This is the translation of multipole expansions from well-separated source boxes to local expansions for target boxes. This occurs at every level of the tree.\n    - At any level $l$, there are $2^l$ target boxes.\n    - The problem states that the interaction list for any target box contains at most $q$ source boxes, where $q$ is a constant.\n    - The number of M2L translations at level $l$ is therefore at most $q \\cdot 2^l$.\n    - The cost per M2L translation is $c_{\\mathrm{M2L}}\\,p^2$.\n    - Total M2L cost is the sum over all levels $l=0, \\dots, L$:\n      $$\n      T_{\\mathrm{M2L}} = \\sum_{l=0}^{L} (\\text{Num. target boxes at level }l) \\cdot (\\text{Avg. interaction list size}) \\cdot (\\text{Cost per translation})\n      $$\n      $$\n      T_{\\mathrm{M2L}} \\leq \\sum_{l=0}^{L} (2^l \\cdot q \\cdot c_{\\mathrm{M2L}}\\,p^2) = (q \\cdot c_{\\mathrm{M2L}}\\,p^2) \\sum_{l=0}^{L} 2^l = (q \\cdot c_{\\mathrm{M2L}}\\,p^2) (2^{L+1}-1)\n      $$\n    - Since $p$, $q$, and $c_{\\mathrm{M2L}}$ are constants and $2^L = \\Theta(N)$, the total M2L cost is $T_{\\mathrm{M2L}} = \\Theta(N)$.\n\n4.  **L2L (Local-to-Local) Cost**: This constitutes the downward pass. At each level $l$ from $1$ to $L$, the local expansion for each box is computed from its parent's local expansion. This is performed for every non-root box.\n    - Number of non-root boxes is $\\sum_{l=1}^{L} 2^l = 2^{L+1}-2 = \\Theta(N)$.\n    - Cost per L2L translation is $c_{\\mathrm{L2L}}\\,p^2$.\n    - Total L2L cost: $T_{\\mathrm{L2L}} = \\Theta(N) \\cdot (c_{\\mathrm{L2L}}\\,p^2) = \\Theta(N)$.\n\n5.  **L2T (Local-to-Target) Cost**: This final operation evaluates the local expansion at each of the $N$ target point locations. This happens in the leaf boxes.\n    - Cost per target is $c_{\\mathrm{L2T}}\\,p$.\n    - Total L2T cost: $T_{\\mathrm{L2T}} = N \\cdot (c_{\\mathrm{L2T}}\\,p)$.\n    - As $c_{\\mathrm{L2T}}$ and $p$ are constants, $T_{\\mathrm{L2T}} = \\Theta(N)$.\n\nThe total computational work $T(N)$ is the sum of the costs of these five stages:\n$$\nT(N) = T_{\\mathrm{S2M}} + T_{\\mathrm{M2M}} + T_{\\mathrm{M2L}} + T_{\\mathrm{L2L}} + T_{\\mathrm{L2T}}\n$$\n$$\nT(N) = \\Theta(N) + \\Theta(N) + \\Theta(N) + \\Theta(N) + \\Theta(N) = \\Theta(N)\n$$\nThe problem specifies that the total work scales as $T(N) = \\Theta(N^{\\alpha})$. By comparing this with our derived result, we have:\n$$\n\\Theta(N^{\\alpha}) = \\Theta(N^1)\n$$\nThis implies that the exponent $\\alpha$ must be $1$.", "answer": "$$\\boxed{1}$$", "id": "2374839"}, {"introduction": "Having built a BEM system from scratch and analyzed the theory of FMM acceleration, the final step is to bring the algorithm to life. This hands-on coding problem [@problem_id:2374805] guides you through the implementation of a simplified one-dimensional FMM-like algorithm, often called a tree code. You will implement the hierarchical data structure, compute multipole expansions, and code the recursive logic that distinguishes near and far interactions, providing a concrete and powerful understanding of how FMM works in practice.", "problem": "Implement a complete program that, for several specified point sets on a line with scalar source strengths, approximates the logarithmic potential generated by these sources at the source locations themselves using a hierarchical expansion scheme based on the Taylor series of the logarithmic kernel and compares it to the direct summation. Let the potential at the target index $i$ be defined by\n$$\nS_i = \\sum_{\\substack{j=1 \\\\ j \\ne i}}^{N} q_j \\,\\log\\!\\left|x_i - x_j\\right|,\n$$\nwhere $N$ is the number of sources, $x_j \\in \\mathbb{R}$ are source locations on the real line, and $q_j \\in \\mathbb{R}$ are source strengths.\n\nYour program must compute an approximation $S^{(\\mathrm{approx})}_i$ using a hierarchical partition of the bounding interval into a binary tree with box centers $c$ and half-lengths $a$, truncating the Taylor series of the kernel $\\log|x - x'|$ to order $p$ about box centers. For a box with center $c$ that is well separated from a target at position $x$, you must use the truncated multipole expansion based on the Taylor expansion of $\\log|x - x'|$:\n$$\n\\log|x - x'| = \\log|x - c| + \\log\\!\\left(1 - \\frac{x' - c}{x - c}\\right),\n$$\nwhich yields, for $\\left|x' - c\\right| < \\left|x - c\\right|$,\n$$\n\\log|x - x'| = \\log|x - c| - \\sum_{n=1}^{\\infty} \\frac{1}{n}\\,\\frac{(x' - c)^n}{(x - c)^n}.\n$$\nTruncate at order $p$ by defining the box moments\n$$\nM_n = \\sum_{j \\in \\text{box}} q_j (x_j - c)^n,\\quad n=0,1,\\dots,p,\n$$\nso that the contribution from that box to a target at $x$ is approximated by\n$$\n\\Phi_{\\text{box}}(x) \\approx M_0 \\,\\log|x - c| - \\sum_{n=1}^{p} \\frac{1}{n}\\,\\frac{M_n}{(x - c)^n}.\n$$\n\nTo construct moments at parent boxes from children, use the binomial translation identity to re-express moments about the parent center $c_{\\text{par}}$ in terms of child moments about $c_{\\text{ch}}$:\n$$\nM_n^{(\\text{par})} = \\sum_{k=0}^{n} \\binom{n}{k} \\,(c_{\\text{ch}} - c_{\\text{par}})^{\\,n-k}\\, M_k^{(\\text{ch})},\\quad n=0,1,\\dots,p.\n$$\n\nDefine the well-separation acceptance criterion as follows: for a box with center $c$ and half-length $a$, a target at $x$ is well separated from the box if\n$$\n|x - c| \\ge \\lambda\\, a,\n$$\nwith $\\lambda = 2$. If the criterion is satisfied, approximate the contribution of all sources in the box to the target using the truncated expansion as above. If the criterion is not satisfied and the box is not a leaf, refine to its children. If the criterion is not satisfied and the box is a leaf, evaluate the contribution from all sources in the leaf directly, excluding self-interaction when $x$ coincides with a source location in that leaf. Use a maximum tree depth $D = 20$ and a leaf capacity $L = 8$ as stopping criteria for refinement.\n\nUse expansion order $p = 12$ in all approximations. For each test case, compute:\n- The direct result $S^{(\\mathrm{direct})}_i$ by the definition for all $i = 1,\\dots,N$.\n- The approximate result $S^{(\\mathrm{approx})}_i$ using the hierarchical truncated expansion as defined above.\n- The maximum absolute error\n$$\nE = \\max_{1 \\le i \\le N} \\left| S^{(\\mathrm{approx})}_i - S^{(\\mathrm{direct})}_i \\right|.\n$$\n\nYour program must execute the above for the following test suite (each item defines $N$, $\\{x_j\\}_{j=1}^N$, and $\\{q_j\\}_{j=1}^N$):\n\n- Test case $1$ (uniform grid, alternating charges):\n  - $N = 16$,\n  - $x_j = \\dfrac{j-1}{N-1}$ for $j = 1,2,\\dots,N$,\n  - $q_j = (-1)^{\\,j-1}$ for $j = 1,2,\\dots,N$.\n\n- Test case $2$ (two tight clusters, alternating sign by cluster):\n  - $N = 20$,\n  - $x_j$ consists of the concatenation of $\\left\\{10^{-3}\\, j\\right\\}_{j=1}^{10}$ and $\\left\\{1 - 10^{-3}\\, j\\right\\}_{j=1}^{10}$,\n  - $q_j$ consists of the concatenation of $\\left\\{\\dfrac{1}{j}\\right\\}_{j=1}^{10}$ and $\\left\\{-\\dfrac{1}{j}\\right\\}_{j=1}^{10}$, in the same order as the positions.\n\n- Test case $3$ (single source, trivial boundary case):\n  - $N = 1$,\n  - $x_1 = \\dfrac{1}{2}$,\n  - $q_1 = 2$.\n\n- Test case $4$ (nonuniform quadratic grid, sinusoidal charges):\n  - $N = 32$,\n  - $x_j = \\left(\\dfrac{j-1}{N-1}\\right)^{2}$ for $j = 1,2,\\dots,N$,\n  - $q_j = \\sin\\!\\left(\\dfrac{2\\pi (j-1)}{N}\\right)$ for $j = 1,2,\\dots,N$.\n\nYour program must output a single line containing a Python-style list with the $4$ error values $E$, one per test case, each rounded to $8$ decimal places using standard rounding to the nearest representable decimal with $8$ digits after the decimal point. The ordering of the list must match the order of the test cases above. For example, an output with four placeholder values would look like \"[0.00000000,0.12345678,0.00000000,0.00000123]\".", "solution": "The problem posed is to implement and validate a one-dimensional hierarchical fast multipole-like method for computing logarithmic potentials. This is a standard problem in computational science, designed to reduce the computational complexity of N-body problems from the naive $O(N^2)$ scaling of direct summation to approximately $O(N)$. The problem statement is scientifically sound, mathematically consistent, and provides all necessary parameters and formulae. It is therefore deemed valid.\n\nThe core principle of this method is the hierarchical decomposition of the problem domain and the use of series expansions to approximate the influence of distant source clusters. We shall proceed by first establishing the theoretical and algorithmic framework, then presenting the implementation.\n\n**1. Hierarchical Space Decomposition**\n\nThe foundation of the method is a binary tree structure that recursively partitions the one-dimensional domain containing the sources.\nThe process begins with a single root \"box\" that represents an interval $[c-a, c+a]$ enclosing all $N$ source points $\\{x_j\\}$. Here, $c$ is the center and $a$ is the half-length of the interval. This root box is at level $0$ of the tree.\n\nA box at any level is subdivided into two child boxes of equal half-length if it contains more than a prescribed maximum number of points, $L$ (the leaf capacity), and if the maximum tree depth, $D$, has not been reached. For a parent box with center $c$ and half-length $a$, its two children will have centers $c - a/2$ and $c + a/2$, and both will have a half-length of $a/2$. This subdivision process continues recursively, generating a tree structure. A box that is not subdivided is termed a \"leaf\" box.\n\n**2. Upward Pass: Multipole Moment Computation**\n\nAfter constructing the tree, we perform an \"upward pass\" from the leaves to the root to compute multipole moments for each box. A multipole expansion provides a compact representation of the source distribution within a box as viewed from a distant point. The moments are coefficients in this expansion.\n\nFor a leaf box with center $c$, the moments $M_n$ of order $n=0, 1, \\ldots, p$ are computed directly from the source points $\\{x_j\\}$ and their strengths $\\{q_j\\}$ contained within that box:\n$$\nM_n = \\sum_{j \\in \\text{box}} q_j (x_j - c)^n\n$$\nFor a non-leaf (parent) box, its moments are not computed directly from sources. Instead, they are synthesized from the already-computed moments of its children. This is achieved via a moment-to-moment (M2M) translation. If a child box with center $c_{\\text{ch}}$ has moments $\\{M_k^{(\\text{ch})}\\}$, these can be re-expressed as a series about the parent's center $c_{\\text{par}}$. The formula for the translated moments is derived from the binomial expansion of $(x_j - c_{\\text{par}})^n = ((x_j - c_{\\text{ch}}) + (c_{\\text{ch}} - c_{\\text{par}}))^n$. Summing over all sources in the child box yields the contribution to the parent moments:\n$$\nM_n^{(\\text{par})} = \\sum_{k=0}^{n} \\binom{n}{k} (c_{\\text{ch}} - c_{\\text{par}})^{n-k} M_k^{(\\text{ch})}\n$$\nThe total moments for the parent box are the sum of the translated moments from both of its children. This process is applied recursively from the leaves upward, ensuring that every box in the tree has a complete set of multipole moments $\\{M_n\\}_{n=0}^p$.\n\n**3. Downward Pass: Potential Evaluation**\n\nThe potential $S_i$ at each target location $x_i$ is computed in a \"downward pass\" by traversing the tree from the root. For a given target $x_i$, the algorithm decides at each node whether to use a multipole approximation for the box's contribution or to refine the calculation by descending to its children.\n\nThis decision is governed by a well-separation criterion. A box with center $c$ and half-length $a$ is considered well-separated (i.e., in the \"far-field\") from a target point $x_i$ if the distance to its center is sufficiently large compared to its size:\n$$\n|x_i - c| \\ge \\lambda a\n$$\nwhere $\\lambda$ is a separation parameter, given as $\\lambda=2$.\n\nThe evaluation for a single target $x_i$ proceeds as follows, starting with the root box:\n1.  **Far-Field interaction**: If the current box is well-separated from $x_i$, its contribution to the potential at $x_i$ is approximated using the $p$-th order truncated multipole expansion. The formula is derived from the Taylor series of the logarithmic kernel $\\log|x_i - x'|$ around the box center $c$. The contribution is:\n    $$\n    \\Phi_{\\text{box}}(x_i) \\approx M_0 \\log|x_i - c| - \\sum_{n=1}^{p} \\frac{1}{n} \\frac{M_n}{(x_i - c)^n}\n    $$\n    This is a multipole-to-point (M2P) calculation. The traversal along this branch of the tree terminates.\n\n2.  **Near-Field interaction**: If the box is not well-separated from $x_i$, we must refine the calculation.\n    *   If the box is not a leaf, the algorithm recursively descends to its two children, and the contributions from each child are summed.\n    *   If the box is a leaf, a multipole approximation is no longer accurate. The contribution from the sources within this leaf must be computed by direct summation. For each source $x_j$ in the leaf, its exact contribution $q_j \\log|x_i - x_j|$ is added to the total potential, carefully excluding the self-interaction term where $j=i$.\n\nThe total potential $S_i^{(\\mathrm{approx})}$ is the sum of all contributions from the far-field multipole approximations and the near-field direct summations. This entire process is repeated for every target point $x_i$. The efficiency of this hierarchical method arises from aggregating the influence of many distant sources into a single, inexpensive multipole calculation, thereby avoiding the costly pairwise sums of the direct method.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\n\n# --- GLOBAL PARAMETERS ---\nP_ORDER = 12\nMAX_DEPTH = 20\nLEAF_CAPACITY = 8\nLAMBDA_SEP = 2.0\n\nclass Box:\n    \"\"\"Represents a box in the binary tree.\"\"\"\n    def __init__(self, center, half_length, level, point_indices):\n        self.center = center\n        self.half_length = half_length\n        self.level = level\n        self.point_indices = np.array(point_indices, dtype=int)\n        self.moments = np.zeros(P_ORDER + 1, dtype=float)\n        self.parent = None\n        self.left_child = None\n        self.right_child = None\n\n    @property\n    def is_leaf(self):\n        return self.left_child is None and self.right_child is None\n\ndef build_tree(x, n):\n    \"\"\"Builds the binary tree for the given points.\"\"\"\n    if n == 0:\n        return None\n    \n    min_x, max_x = np.min(x), np.max(x)\n    center = (min_x + max_x) / 2.0\n    half_length = (max_x - min_x) / 2.0\n    # Handle case where all points are at the same location\n    if half_length == 0.0:\n        half_length = 1e-5 # A small non-zero value\n\n    root = Box(center, half_length, 0, np.arange(n))\n    \n    queue = [root]\n    while queue:\n        current_box = queue.pop(0)\n        \n        # Subdivision criteria\n        if len(current_box.point_indices) = LEAF_CAPACITY or current_box.level >= MAX_DEPTH:\n            continue\n\n        # Subdivide\n        c, a = current_box.center, current_box.half_length\n        point_pos = x[current_box.point_indices]\n        \n        left_indices = current_box.point_indices[point_pos  c]\n        right_indices = current_box.point_indices[point_pos >= c]\n\n        if len(left_indices) > 0:\n            left_child = Box(c - a/2.0, a/2.0, current_box.level + 1, left_indices)\n            left_child.parent = current_box\n            current_box.left_child = left_child\n            queue.append(left_child)\n\n        if len(right_indices) > 0:\n            right_child = Box(c + a/2.0, a/2.0, current_box.level + 1, right_indices)\n            right_child.parent = current_box\n            current_box.right_child = right_child\n            queue.append(right_child)\n            \n    return root\n\ndef calculate_moments_upward_pass(box, x, q):\n    \"\"\"Recursively computes moments in a post-order traversal (upward pass).\"\"\"\n    if not box.is_leaf:\n        if box.left_child:\n            calculate_moments_upward_pass(box.left_child, x, q)\n        if box.right_child:\n            calculate_moments_upward_pass(box.right_child, x, q)\n        \n        # M2M translation from children to parent\n        box.moments.fill(0.0)\n        for child in [box.left_child, box.right_child]:\n            if child:\n                c_ch, c_par = child.center, box.center\n                dist_vec = c_ch - c_par\n                for n in range(P_ORDER + 1):\n                    m_n_par_contrib = 0.0\n                    for k in range(n + 1):\n                        m_n_par_contrib += comb(n, k, exact=True) * (dist_vec)**(n - k) * child.moments[k]\n                    box.moments[n] += m_n_par_contrib\n    else: # It is a leaf\n        # Compute moments directly from sources\n        for idx in box.point_indices:\n            dist_vec = x[idx] - box.center\n            for n in range(P_ORDER + 1):\n                box.moments[n] += q[idx] * (dist_vec)**n\n\ndef _recursive_potential_eval(target_idx, x, q, box):\n    \"\"\"Recursive helper for the downward pass potential evaluation.\"\"\"\n    target_pos = x[target_idx]\n    dist_to_center = np.abs(target_pos - box.center)\n    \n    # Well-separation criterion\n    is_well_separated = dist_to_center >= LAMBDA_SEP * box.half_length\n\n    if is_well_separated:\n        # Far-field: Use multipole expansion (M2P)\n        potential = 0.0\n        m = box.moments\n        dist = target_pos - box.center\n\n        # Handle log(|dist|) case where dist is 0, though separation criterion should prevent this.\n        if abs(dist)  1e-15: return 0.0\n        \n        potential += m[0] * np.log(np.abs(dist))\n        \n        dist_inv = 1.0 / dist\n        dist_inv_n = dist_inv # Starts with n=1\n        for n in range(1, P_ORDER + 1):\n            potential -= (1.0/n) * m[n] * dist_inv_n\n            dist_inv_n *= dist_inv\n        return potential\n    else:\n        # Near-field\n        if box.is_leaf:\n            # Direct summation for near-field leaf\n            potential = 0.0\n            for j in box.point_indices:\n                if j != target_idx:\n                    dist = np.abs(target_pos - x[j])\n                    if dist > 1e-15: # Avoid log(0)\n                        potential += q[j] * np.log(dist)\n            return potential\n        else:\n            # Refine to children\n            potential = 0.0\n            if box.left_child:\n                potential += _recursive_potential_eval(target_idx, x, q, box.left_child)\n            if box.right_child:\n                potential += _recursive_potential_eval(target_idx, x, q, box.right_child)\n            return potential\n\ndef compute_approximate(n, x, q):\n    \"\"\"Computes potentials using the hierarchical method.\"\"\"\n    if n = 1:\n        return np.zeros(n, dtype=float)\n\n    root = build_tree(x, n)\n    calculate_moments_upward_pass(root, x, q)\n    \n    s_approx = np.zeros(n, dtype=float)\n    for i in range(n):\n        s_approx[i] = _recursive_potential_eval(i, x, q, root)\n        \n    return s_approx\n\ndef compute_direct(n, x, q):\n    \"\"\"Computes potentials using direct summation.\"\"\"\n    s_direct = np.zeros(n, dtype=float)\n    if n = 1:\n        return s_direct\n        \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.abs(x[i] - x[j])\n                # Safety for log(0) though i != j should prevent it for distinct points.\n                if dist > 1e-15:\n                     s_direct[i] += q[j] * np.log(dist)\n    return s_direct\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = []\n\n    # Test case 1\n    n_1 = 16\n    x_1 = np.arange(n_1, dtype=float) / (n_1 - 1)\n    q_1 = (-1.0)**np.arange(n_1)\n    test_cases.append((n_1, x_1, q_1))\n    \n    # Test case 2\n    n_2 = 20\n    x_2_part1 = 1e-3 * np.arange(1, 11)\n    x_2_part2 = 1.0 - 1e-3 * np.arange(1, 11)\n    x_2 = np.concatenate([x_2_part1, x_2_part2])\n    q_2_part1 = 1.0 / np.arange(1, 11)\n    q_2_part2 = -1.0 / np.arange(1, 11)\n    q_2 = np.concatenate([q_2_part1, q_2_part2])\n    test_cases.append((n_2, x_2, q_2))\n\n    # Test case 3\n    n_3 = 1\n    x_3 = np.array([0.5])\n    q_3 = np.array([2.0])\n    test_cases.append((n_3, x_3, q_3))\n\n    # Test case 4\n    n_4 = 32\n    u_4 = np.arange(n_4, dtype=float) / (n_4 - 1)\n    x_4 = u_4**2\n    q_4 = np.sin(2 * np.pi * np.arange(n_4) / n_4)\n    test_cases.append((n_4, x_4, q_4))\n    \n    results = []\n    for n, x, q in test_cases:\n        s_direct = compute_direct(n, x, q)\n        s_approx = compute_approximate(n, x, q)\n        \n        if n == 0:\n            error = 0.0\n        else:\n            error = np.max(np.abs(s_approx - s_direct))\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "2374805"}]}