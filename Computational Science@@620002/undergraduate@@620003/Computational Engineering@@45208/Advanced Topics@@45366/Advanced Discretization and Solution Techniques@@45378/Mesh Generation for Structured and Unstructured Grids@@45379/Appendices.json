{"hands_on_practices": [{"introduction": "The first step in many analyses is to discretize a domain, often starting from a simple cloud of points. This practice guides you through the implementation of the renowned Bowyer-Watson algorithm, a cornerstone of unstructured mesh generation. By building a 2D Delaunay triangulation from scratch, you will gain a profound understanding of how to create high-quality meshes that satisfy the elegant empty circumcircle criterion, ensuring that the resulting triangles are as well-shaped as possible. This exercise [@problem_id:2412570] is not just about writing code; it's about building a foundational tool and a deep intuition for computational geometry.", "problem": "Implement a complete program that constructs a two-dimensional (2D) Delaunay triangulation using the Bowyer–Watson incremental insertion approach for a given finite set of planar points, and then quantitatively verifies key properties of the resulting mesh. Your implementation must be principled from first definitions of planar triangulations and the Delaunay empty circumcircle condition, and it must be self-contained.\n\nStart from the following fundamental base:\n- A planar triangulation of a finite point set in $\\mathbb{R}^2$ is a decomposition of the convex hull of the points into non-overlapping triangles whose vertices are the points, and whose union equals the convex hull.\n- The Delaunay triangulation (first defined by Boris Delaunay) of a finite point set in $\\mathbb{R}^2$ is any triangulation in which the open circumcircle of every triangle contains no other point from the set. Equivalently, for each triangle with vertices $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{c}$, if $\\mathbf{o}$ is its circumcenter and $r$ is the circumradius, then for every other point $\\mathbf{p}$, $\\|\\mathbf{p}-\\mathbf{o}\\|_2 > r$ must hold, allowing equality $\\|\\mathbf{p}-\\mathbf{o}\\|_2 = r$ as a non-unique edge case.\n- The circumcenter of a non-degenerate triangle is the unique intersection point of the perpendicular bisectors of its three edges.\n\nYour program must:\n1. Implement the Bowyer–Watson insertion scheme from first principles as follows. Begin with an enclosing super-triangle that strictly contains all input points. Insert points one by one. For each inserted point, identify all current triangles whose circumcircles contain the point (these are the “bad” triangles), delete them, compute the boundary polygon of the resulting cavity as those edges that are incident to exactly one deleted triangle, and finally retriangulate the cavity by connecting the new point to each boundary edge. After all points have been inserted, remove any triangle that includes a vertex of the super-triangle.\n2. Use stable numerical predicates built from the definitions above. When testing whether a point $\\mathbf{p}$ lies inside a circumcircle, compute the circumcenter $\\mathbf{o}$ and squared circumradius $r^2$, and compare $\\|\\mathbf{p}-\\mathbf{o}\\|_2^2$ and $r^2$ with a small tolerance $\\varepsilon > 0$ to implement the strict inequality “inside” as $\\|\\mathbf{p}-\\mathbf{o}\\|_2^2 \\le r^2 - \\varepsilon$. Degenerate triangles with area less than a tolerance should be ignored for containment tests.\n3. Deduplicate input points within a small tolerance to avoid repeated vertices, and ensure the algorithm remains robust when encountering nearly collinear and nearly co-circular configurations.\n\nFor each test case below, your program must return three quantities:\n- The number of triangles $T$ in the final triangulation (an integer).\n- A boolean indicating whether the empty circumcircle condition holds for all triangles when checked against all other points using the strict-inside-with-tolerance definition above.\n- The sum of the areas of all triangles (a floating-point number) rounded to $6$ decimal places. This number must be computed from first principles using the Euclidean area of each triangle with vertices $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{c}$ as $\\frac{1}{2}\\left|(\\mathbf{b}-\\mathbf{a}) \\times (\\mathbf{c}-\\mathbf{a})\\right|$, where $\\times$ denotes the scalar $z$-component of the two-dimensional cross product.\n\nAngle units are not used in this problem. All quantities are dimensionless.\n\nTest suite:\n- Case A (convex square with interior point): points $[(0,0),(1,0),(1,1),(0,1),(0.5,0.5)]$.\n- Case B (regular pentagon on the unit circle, a near co-circular stress test): points $\\left[\\left(\\cos\\left(\\frac{2\\pi k}{5}\\right),\\sin\\left(\\frac{2\\pi k}{5}\\right)\\right)\\right]$ for $k \\in \\{0,1,2,3,4\\}$.\n- Case C (collinear subset along one hull edge): points $[(0,0),(1,0),(2,0),(2,1),(0,1)]$.\n- Case D (duplicate point present): points $[(0,0),(1,0),(1,1),(0,1),(1,1)]$.\n- Case E (general interior set in the unit square): points $[(0.1,0.1),(0.9,0.1),(0.9,0.9),(0.1,0.9),(0.5,0.2),(0.8,0.5),(0.3,0.6),(0.5,0.8)]$.\n\nOutput specification:\n- For each case, output a list of the form `[T,delaunay_ok,area_sum]`, where $T$ is an integer, `delaunay_ok` is a boolean, and `area_sum` is a floating-point number rounded to $6$ decimal places as defined above.\n- Your program should produce a single line of output containing the results for all five cases as a comma-separated list enclosed in square brackets, for example: `[[…],[…],[…],[…],[…]]`.", "solution": "The posed problem requires the implementation of the Bowyer-Watson algorithm for two-dimensional Delaunay triangulation. The solution must be constructed from fundamental principles and must include verification of the resulting mesh properties. The problem is validated as scientifically sound, well-posed, and objective. It pertains to a standard topic in computational geometry and provides clear, testable requirements.\n\nThe core of the solution is a step-by-step implementation of the Bowyer-Watson algorithm. This algorithm is an incremental method that builds the triangulation by adding one point at a time. The fundamental geometric constructs are defined first. A point is a vector $\\mathbf{p} \\in \\mathbb{R}^2$. A triangle is defined by three vertices $(\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3)$ which are indices into a master list of point coordinates.\n\nThe area of a triangle with vertices $\\mathbf{a}=(a_x, a_y)$, $\\mathbf{b}=(b_x, b_y)$, and $\\mathbf{c}=(c_x, c_y)$ is computed using the 2D cross-product formula:\n$$ A = \\frac{1}{2} |a_x(b_y - c_y) + b_x(c_y - a_y) + c_x(a_y - b_y)| $$\nA triangle is considered degenerate if its area is less than a small tolerance $\\tau_{area}$, which occurs when its vertices are nearly collinear.\n\nFor a non-degenerate triangle, its circumcircle is uniquely defined. The circumcenter $\\mathbf{o}=(o_x, o_y)$ is the intersection of the perpendicular bisectors of the triangle's edges. Its coordinates can be computed directly from the vertex coordinates:\n$$ D = 2 (a_x(b_y - c_y) + b_x(c_y - a_y) + c_x(a_y - b_y)) $$\n$$ o_x = \\frac{1}{D} ( (a_x^2+a_y^2)(b_y-c_y) + (b_x^2+b_y^2)(c_y-a_y) + (c_x^2+c_y^2)(a_y-b_y) ) $$\n$$ o_y = \\frac{1}{D} ( (a_x^2+a_y^2)(c_x-b_x) + (b_x^2+b_y^2)(a_x-c_x) + (c_x^2+c_y^2)(b_x-a_x) ) $$\nThe denominator $D$ is twice the signed area. If $|D|$ is smaller than a tolerance, the circumcenter calculation is ill-conditioned and is aborted. The squared circumradius is then $r^2 = \\|\\mathbf{a} - \\mathbf{o}\\|_2^2$.\n\nThe key test in the Bowyer-Watson algorithm is determining if a point $\\mathbf{p}$ lies inside a triangle's circumcircle. Following the problem statement, this is implemented as a strict \"inside\" test with a tolerance $\\varepsilon > 0$:\n$$ \\|\\mathbf{p}-\\mathbf{o}\\|_2^2 \\le r^2 - \\varepsilon $$\nThis formulation robustly handles cases where points are nearly co-circular by classifying points on or very near the circle boundary as \"outside\".\n\nThe algorithm proceeds as follows:\n$1$. **Preprocessing**: Input points are deduplicated. Points $\\mathbf{p}_i, \\mathbf{p}_j$ are considered identical if their Euclidean distance $\\|\\mathbf{p}_i - \\mathbf{p}_j\\|_2$ is less than a tolerance $\\tau_{dist}$.\n$2$. **Initialization**: A \"super-triangle\" is created that is guaranteed to enclose all input points. This is done by finding the bounding box of the points and constructing a significantly larger triangle around it. The initial triangulation consists of only this super-triangle. Its vertices are added to the global list of points.\n$3$. **Incremental Insertion**: Each input point $\\mathbf{p}_{new}$ is inserted into the triangulation:\n    a. The set of \"bad\" triangles is found. A triangle is bad if $\\mathbf{p}_{new}$ lies inside its circumcircle.\n    b. The bad triangles are removed, forming a polygonal cavity. The boundary of this cavity is composed of edges that belonged to exactly one bad triangle.\n    c. The cavity is re-triangulated by creating new triangles, each formed by an edge from the boundary polygon and the point $\\mathbf{p}_{new}$.\n    d. The list of active triangles is updated by replacing the bad triangles with the new ones.\n$4$. **Finalization**: After all points are inserted, any triangles that share a vertex with the super-triangle are discarded. The remaining set is the Delaunay triangulation of the input points.\n\nFinally, for each test case, the required metrics are computed from the resulting triangulation:\n- $T$: The total number of triangles in the final mesh.\n- $\\texttt{delaunay\\_ok}$: A boolean flag. It is set to $\\texttt{True}$ if, for every triangle in the mesh, no other point from the input set lies strictly inside its circumcircle (verified using the same tolerant check). Otherwise, it is $\\texttt{False}$.\n- $\\texttt{area\\_sum}$: The sum of the areas of all triangles in the final mesh, rounded to $6$ decimal places. The sum is computed using a precision-preserving method before final rounding.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom collections import Counter\n\n# Global tolerances for numerical stability\nEPSILON_CIRCUMCIRCLE = 1e-9\nDEDUPLICATION_TOL = 1e-9\nAREA_TOL = 1e-12\n\nclass Triangle:\n    \"\"\"\n    Represents a triangle with vertices and its circumcircle.\n    Vertices are stored as indices into a global list of points.\n    \"\"\"\n    def __init__(self, v1_idx, v2_idx, v3_idx, points):\n        self.v_indices = (v1_idx, v2_idx, v3_idx)\n        self.vertices = (points[v1_idx], points[v2_idx], points[v3_idx])\n        \n        self.circumcenter = None\n        self.radius_sq = None\n        \n        self.area = self._calculate_area()\n        if self.area < AREA_TOL:\n            self.is_degenerate = True\n        else:\n            self.is_degenerate = False\n            self._calculate_circumcircle()\n\n    def _calculate_area(self):\n        a, b, c = self.vertices\n        # Using the Shoelace formula for area\n        return 0.5 * abs(a[0]*(b[1]-c[1]) + b[0]*(c[1]-a[1]) + c[0]*(a[1]-b[1]))\n\n    def _calculate_circumcircle(self):\n        a, b, c = self.vertices\n        ax, ay = a\n        bx, by = b\n        cx, cy = c\n        \n        D = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by))\n\n        if abs(D) < AREA_TOL:\n            # This should be caught by the area check, but as a safeguard\n            self.is_degenerate = True\n            return\n\n        asq = ax**2 + ay**2\n        bsq = bx**2 + by**2\n        csq = cx**2 + cy**2\n\n        ux = (asq * (by - cy) + bsq * (cy - ay) + csq * (ay - by)) / D\n        uy = (asq * (cx - bx) + bsq * (ax - cx) + csq * (bx - ax)) / D\n        \n        self.circumcenter = np.array([ux, uy])\n        self.radius_sq = (ax - ux)**2 + (ay - uy)**2\n\n    def contains_point_in_circumcircle(self, p):\n        if self.is_degenerate or self.circumcenter is None:\n            return False\n        \n        dist_sq = np.sum((p - self.circumcenter)**2)\n        # Strict inequality check with tolerance\n        return dist_sq <= self.radius_sq - EPSILON_CIRCUMCIRCLE\n\n    def get_edges(self):\n        # Return edges with sorted vertex indices to make them canonical for comparison\n        v1, v2, v3 = self.v_indices\n        return [\n            tuple(sorted((v1, v2))),\n            tuple(sorted((v2, v3))),\n            tuple(sorted((v3, v1)))\n        ]\n\ndef bowyer_watson(points):\n    \"\"\"\n    Constructs a Delaunay triangulation of a set of 2D points.\n    \"\"\"\n    # 1. Deduplicate points\n    unique_points_list = []\n    if points:\n        unique_points_list.append(points[0])\n        for p_in in points[1:]:\n            p_arr = np.array(p_in)\n            is_duplicate = False\n            for up in unique_points_list:\n                if np.linalg.norm(p_arr - np.array(up)) < DEDUPLICATION_TOL:\n                    is_duplicate = True\n                    break\n            if not is_duplicate:\n                unique_points_list.append(p_in)\n    \n    unique_points = [np.array(p) for p in unique_points_list]\n    num_input_points = len(unique_points)\n    \n    if num_input_points < 3:\n        return [], unique_points\n\n    # 2. Create super-triangle\n    min_x = min(p[0] for p in unique_points)\n    max_x = max(p[0] for p in unique_points)\n    min_y = min(p[1] for p in unique_points)\n    max_y = max(p[1] for p in unique_points)\n    \n    dx = max_x - min_x\n    dy = max_y - min_y\n    delta_max = max(dx, dy, 1.0) # Ensure non-zero for single-point case\n    center = np.array([(min_x + max_x) / 2, (min_y + max_y) / 2])\n    \n    # Large triangle enclosing the bounding box\n    s_v1 = center + np.array([-3 * delta_max, -3 * delta_max])\n    s_v2 = center + np.array([3 * delta_max, -3 * delta_max])\n    s_v3 = center + np.array([0, 3 * delta_max])\n    \n    all_points = unique_points + [s_v1, s_v2, s_v3]\n    st_idx1, st_idx2, st_idx3 = num_input_points, num_input_points + 1, num_input_points + 2\n\n    triangulation = [Triangle(st_idx1, st_idx2, st_idx3, all_points)]\n\n    # 3. Incremental insertion\n    for i in range(num_input_points):\n        point_to_add = all_points[i]\n        \n        bad_triangles = [t for t in triangulation if t.contains_point_in_circumcircle(point_to_add)]\n        \n        polygon_edges = []\n        for t in bad_triangles:\n            polygon_edges.extend(t.get_edges())\n        \n        edge_counts = Counter(polygon_edges)\n        boundary_edges = [edge for edge, count in edge_counts.items() if count == 1]\n        \n        triangulation = [t for t in triangulation if t not in bad_triangles]\n        \n        for edge in boundary_edges:\n            new_triangle = Triangle(edge[0], edge[1], i, all_points)\n            triangulation.append(new_triangle)\n            \n    # 4. Finalization\n    final_triangulation = []\n    for t in triangulation:\n        is_super_triangle = any(v_idx >= num_input_points for v_idx in t.v_indices)\n        if not is_super_triangle:\n            final_triangulation.append(t)\n            \n    return final_triangulation, all_points[:num_input_points]\n\ndef process_case(points):\n    \"\"\"\n    Runs the full process for one test case and returns the required metrics.\n    \"\"\"\n    final_triangulation, final_points = bowyer_watson(points)\n    \n    # 1. Number of triangles\n    T = len(final_triangulation)\n    \n    # 2. Verify Delaunay condition\n    delaunay_ok = True\n    if T > 0:\n        for t in final_triangulation:\n            # We don't verify against degenerate triangles in the mesh\n            if t.is_degenerate:\n                continue\n            \n            for i, p in enumerate(final_points):\n                if i in t.v_indices:\n                    continue\n                \n                if t.contains_point_in_circumcircle(p):\n                    delaunay_ok = False\n                    break\n            if not delaunay_ok:\n                break\n    \n    # 3. Sum of areas\n    area_sum = math.fsum(t.area for t in final_triangulation)\n    \n    return [T, delaunay_ok, round(area_sum, 6)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: convex square with interior point\n        [(0,0),(1,0),(1,1),(0,1),(0.5,0.5)],\n        # Case B: regular pentagon\n        [(np.cos(2 * np.pi * k / 5), np.sin(2 * np.pi * k / 5)) for k in range(5)],\n        # Case C: collinear subset\n        [(0,0),(1,0),(2,0),(2,1),(0,1)],\n        # Case D: duplicate point present\n        [(0,0),(1,0),(1,1),(0,1),(1,1)],\n        # Case E: general interior set\n        [(0.1,0.1),(0.9,0.1),(0.9,0.9),(0.1,0.9),(0.5,0.2),(0.8,0.5),(0.3,0.6),(0.5,0.8)]\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, which str() handles correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2412570"}, {"introduction": "Once a mesh is created, how do we know if it's \"good\"? The quality of a mesh directly impacts the accuracy and stability of numerical simulations. This practice [@problem_id:2412640] moves from mesh generation to mesh analysis, challenging you to implement a diagnostic toolkit for 3D tetrahedral elements. You will translate fundamental mathematical concepts—such as the Jacobian determinant, matrix singular values, and geometric ratios—into code that quantifies element distortion, inversion, and anisotropy. Developing this skill is essential for validating meshes and preemptively identifying regions that could cause a simulation to fail.", "problem": "You are given the task of designing and implementing a complete, runnable program that evaluates three geometric quality metrics for elements of an unstructured three-dimensional mesh of linear tetrahedra. The mesh is defined by node coordinates in three-dimensional Euclidean space $\\mathbb{R}^3$ and element connectivity. Your implementation must start from first principles of linear mappings and Euclidean geometry, and it must compute the following for each tetrahedral element and then aggregate them at the mesh level: aspect ratio, skewness, and the Jacobian determinant of the isoparametric mapping. All computations are to be performed with dimensionless quantities; no physical units are involved.\n\nFoundational definitions and assumptions:\n\n- A linear tetrahedral element is defined by four distinct nodes with coordinates $\\mathbf{x}_1,\\mathbf{x}_2,\\mathbf{x}_3,\\mathbf{x}_4 \\in \\mathbb{R}^3$. The corresponding affine map from the reference tetrahedron to the physical tetrahedron is\n$$\n\\mathbf{x}(\\boldsymbol{\\xi}) \\;=\\; \\mathbf{x}_1 \\;+\\; J \\,\\boldsymbol{\\xi},\n$$\nwhere $J \\in \\mathbb{R}^{3 \\times 3}$ is the Jacobian matrix with columns $J = \\begin{bmatrix} \\mathbf{x}_2-\\mathbf{x}_1 & \\mathbf{x}_3-\\mathbf{x}_1 & \\mathbf{x}_4-\\mathbf{x}_1 \\end{bmatrix}$ and $\\boldsymbol{\\xi}\\in\\mathbb{R}^3$ lies in the reference tetrahedron. For a linear tetrahedron, $J$ is constant over the element. The signed volume $V$ of the element satisfies $V = \\det(J)/6$.\n\n- The Euclidean norm of a vector $\\mathbf{v}\\in\\mathbb{R}^3$ is $\\lVert \\mathbf{v}\\rVert_2 = \\sqrt{\\mathbf{v}^\\top \\mathbf{v}}$.\n\n- The Singular Value Decomposition (SVD) writes $J = U \\Sigma V^\\top$ with $U,V\\in\\mathbb{R}^{3\\times 3}$ orthogonal and $\\Sigma = \\operatorname{diag}(\\sigma_1,\\sigma_2,\\sigma_3)$ with singular values $\\sigma_1 \\ge \\sigma_2 \\ge \\sigma_3 \\ge 0$. The determinant satisfies $\\det(J) = \\sigma_1 \\sigma_2 \\sigma_3 \\cdot \\det(U)\\det(V)$, and the absolute value is $\\lvert \\det(J)\\rvert = \\sigma_1 \\sigma_2 \\sigma_3$.\n\nElement-level quality metrics to compute from first principles:\n\n1. Aspect ratio. Let the six edge lengths be $l_{ij} = \\lVert \\mathbf{x}_i - \\mathbf{x}_j\\rVert_2$ for the index pairs $(i,j)\\in\\{(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)\\}$. Define the element aspect ratio by\n$$\n\\mathrm{AR} \\;=\\; \\frac{\\max l_{ij}}{\\min l_{ij}}.\n$$\nIf any $l_{ij} = 0$ (degenerate edge), define $\\mathrm{AR}$ to be $+\\infty$.\n\n2. Skewness. Using the singular values of $J$, define the skewness by\n$$\n\\mathrm{SK} \\;=\\; 1 - \\frac{\\sigma_{\\min}(J)}{\\sigma_{\\max}(J)} \\;=\\; 1 - \\frac{\\sigma_3}{\\sigma_1}.\n$$\nIf $\\sigma_1 = 0$ (fully degenerate), define $\\mathrm{SK} = 1$. This measure lies in $[0,1]$ for nondegenerate elements, with $\\mathrm{SK}=0$ indicating isotropy of the mapping columns and values close to $1$ indicating severe anisotropy or near-degeneracy.\n\n3. Jacobian determinant. For each element, compute the signed Jacobian determinant\n$$\n\\mathrm{JAC} \\;=\\; \\det(J).\n$$\nNegative values indicate inverted orientation. The element volume is $V = \\mathrm{JAC}/6$.\n\nMesh-level aggregation:\n\n- For a given mesh, define its worst aspect ratio as the maximum $\\mathrm{AR}$ over all elements.\n- Define its worst skewness as the maximum $\\mathrm{SK}$ over all elements.\n- Define its minimum Jacobian determinant as the minimum $\\mathrm{JAC}$ over all elements.\n\nProgram requirements:\n\n- Implement a parser for a simple in-memory mesh description format representing an unstructured tetrahedral mesh. Each mesh comprises a set of nodes and a set of tetrahedral elements referencing those nodes. Your program must embed the meshes internally as string constants; it must not read external files or require user input. The format is:\n  - A line \"NODES $N$\" followed by $N$ lines each containing \"$\\text{id}\\; x\\; y\\; z$\" with integer $\\text{id}$ and real coordinates $x,y,z$.\n  - A line \"ELEMENTS $M$\" followed by $M$ lines each containing \"$\\text{id}\\; n_1\\; n_2\\; n_3\\; n_4$\" with integer $\\text{id}$ and integer node indices $n_k$.\n\n- For each tetrahedral element, compute $\\mathrm{AR}$, $\\mathrm{SK}$, and $\\mathrm{JAC}$ as defined above using only the fundamental operations and definitions provided.\n\n- Aggregate per mesh as specified to produce three values per mesh: worst aspect ratio, worst skewness, and minimum Jacobian determinant.\n\nTest suite to be embedded and evaluated by your program:\n\n- Test mesh A (well-shaped, equilateral-like). Nodes:\n  - $\\mathbf{x}_1 = (0,\\,0,\\,0)$,\n  - $\\mathbf{x}_2 = (1,\\,0,\\,0)$,\n  - $\\mathbf{x}_3 = \\left(\\tfrac{1}{2},\\,\\tfrac{\\sqrt{3}}{2},\\,0\\right)$,\n  - $\\mathbf{x}_4 = \\left(\\tfrac{1}{2},\\,\\tfrac{\\sqrt{3}}{6},\\,\\tfrac{\\sqrt{6}}{3}\\right)$.\n  One element with connectivity $(1,2,3,4)$.\n\n- Test mesh B (near-degenerate sliver with very small volume). Nodes:\n  - $\\mathbf{x}_1 = (0,\\,0,\\,0)$,\n  - $\\mathbf{x}_2 = (2,\\,0,\\,0)$,\n  - $\\mathbf{x}_3 = (0,\\,2,\\,0)$,\n  - $\\mathbf{x}_4 = (1,\\,1,\\,10^{-6})$.\n  One element with connectivity $(1,2,3,4)$.\n\n- Test mesh C (inverted orientation). Same node coordinates as Test mesh A, but the single element connectivity is $(1,3,2,4)$ so that the mapping orientation is inverted.\n\nRequired final output format:\n\n- Your program must produce a single line of output containing a list of three lists, one per test mesh, in the exact order A, B, C. Each inner list must contain three floating-point numbers in the order $[\\mathrm{AR}_\\text{worst}, \\mathrm{SK}_\\text{worst}, \\mathrm{JAC}_\\text{min}]$ for that mesh. Round each number to six decimal places. The overall output format must be exactly\n$$\n\\big[ [a_1,s_1,j_1], [a_2,s_2,j_2], [a_3,s_3,j_3] \\big]\n$$\nwith numeric entries rendered as decimals rounded to six places and no additional text. For example, an admissible structure is\n`[[1.000000,0.375000,0.707107],[…],[…]]`.", "solution": "The problem requires the design and implementation of a program to evaluate three fundamental geometric quality metrics for a three-dimensional tetrahedral mesh: aspect ratio, skewness, and the Jacobian determinant of the isoparametric mapping. The evaluation must be performed for several test meshes, and the results aggregated at the mesh level. The validation of the problem statement has been completed and it is found to be scientifically grounded, well-posed, and complete. We now proceed to the detailed solution, beginning from the foundational principles as specified.\n\nThe core of the task is to analyze the geometry of each tetrahedral element. A linear tetrahedron is defined by four nodes, $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4 \\in \\mathbb{R}^3$. The geometry is characterized by the affine transformation that maps a canonical reference tetrahedron to the physical element in $\\mathbb{R}^3$. This mapping is given by $\\mathbf{x}(\\boldsymbol{\\xi}) = \\mathbf{x}_1 + J \\boldsymbol{\\xi}$, where $\\boldsymbol{\\xi}$ are the coordinates in the reference space and $J \\in \\mathbb{R}^{3 \\times 3}$ is the Jacobian matrix of the transformation. For a linear tetrahedron, this Jacobian is constant throughout the element.\n\nThe standard reference tetrahedron in computational mechanics has vertices at coordinate tuples $(0,0,0)$, $(1,0,0)$, $(0,1,0)$, and $(0,0,1)$. The affine map is constructed such that these reference vertices map to the physical nodes $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4$, respectively. This leads to the definition of the Jacobian matrix columns as the vectors spanning the edges of the physical tetrahedron originating from the first node, $\\mathbf{x}_1$:\n$$\nJ = \\begin{bmatrix} (\\mathbf{x}_2 - \\mathbf{x}_1) & (\\mathbf{x}_3 - \\mathbf{x}_1) & (\\mathbf{x}_4 - \\mathbf{x}_1) \\end{bmatrix}.\n$$\nThis matrix, $J$, and the set of the element's edge lengths are the foundational quantities from which all required metrics are derived.\n\nThe computational procedure is structured as follows:\n1.  Parse the provided mesh data, which is given in a specific string format, to establish node coordinates and element connectivity.\n2.  For each element in the mesh, retrieve the coordinates of its four defining nodes.\n3.  Compute the three specified element-level quality metrics: Aspect Ratio (AR), Skewness (SK), and Jacobian determinant (JAC).\n4.  Aggregate these metrics across all elements in the mesh to find the worst aspect ratio, worst skewness, and minimum Jacobian determinant.\n5.  Repeat for all test meshes and format the final results as required.\n\nWe now detail the calculation of each metric.\n\n1.  **Aspect Ratio ($\\mathrm{AR}$)**\n    The aspect ratio is a measure of how distorted an element is compared to an ideal shape (e.g., an equilateral tetrahedron). It is defined based on the lengths of the element's six edges. For a tetrahedron with nodes $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4$, the six edge lengths are $l_{ij} = \\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2$ for index pairs $(i,j)$ in $\\{(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)\\}$. The Euclidean norm $\\lVert \\mathbf{v} \\rVert_2$ of a vector $\\mathbf{v} = (v_x, v_y, v_z)$ is $\\sqrt{v_x^2 + v_y^2 + v_z^2}$.\n    The aspect ratio is then the ratio of the longest edge to the shortest edge:\n    $$\n    \\mathrm{AR} = \\frac{\\max_{i,j} l_{ij}}{\\min_{i,j} l_{ij}}.\n    $$\n    An ideal equilateral tetrahedron has an $\\mathrm{AR}$ of $1$. Higher values indicate greater distortion. If any edge has zero length, meaning $\\min l_{ij} = 0$, the element is degenerate, and its aspect ratio is defined as infinite ($\\infty$).\n\n2.  **Jacobian Determinant ($\\mathrm{JAC}$)**\n    The determinant of the Jacobian matrix, $\\mathrm{JAC} = \\det(J)$, is directly related to the element's volume. The signed volume of the tetrahedron is $V = \\det(J)/6$.\n    -   A positive determinant, $\\det(J) > 0$, indicates that the element's node ordering (connectivity) preserves the orientation of the reference element. This is the standard for a valid mesh.\n    -   A negative determinant, $\\det(J)  0$, signifies an inverted or \"inside-out\" element, which is geometrically and physically invalid for most simulation purposes.\n    -   A zero determinant, $\\det(J) = 0$, implies a degenerate element with zero volume (e.g., all four nodes are coplanar).\n\n3.  **Skewness ($\\mathrm{SK}$)**\n    Skewness measures the degree of anisotropy of the affine mapping from the reference to the physical element. It is defined using the singular values of the Jacobian matrix, $J$. The Singular Value Decomposition (SVD) of $J$ is $J = U \\Sigma V^\\top$, where $\\Sigma = \\operatorname{diag}(\\sigma_1, \\sigma_2, \\sigma_3)$ and $\\sigma_1 \\ge \\sigma_2 \\ge \\sigma_3 \\ge 0$ are the singular values. These values represent the scaling factors of the transformation along principal directions.\n    The skewness is defined as:\n    $$\n    \\mathrm{SK} = 1 - \\frac{\\sigma_{\\min}(J)}{\\sigma_{\\max}(J)} = 1 - \\frac{\\sigma_3}{\\sigma_1}.\n    $$\n    This metric ranges from $0$ to $1$. A value of $\\mathrm{SK}=0$ occurs when $\\sigma_1=\\sigma_2=\\sigma_3$, corresponding to a purely isotropic scaling (although not necessarily an equilateral tetrahedron, as the reference element itself is not equilateral). A value approaching $1$ indicates severe anisotropy or near-degeneracy (i.e., $\\sigma_3 \\ll \\sigma_1$). If $\\sigma_1 = 0$, the element is fully degenerate, and $\\mathrm{SK}$ is defined as $1$.\n\nThe implementation will utilize the `numpy` library for efficient vector and matrix operations, including the calculation of norms, determinants, and singular value decomposition, which are standard numerical implementations of these first principles.\n\nFinally, for each mesh, the element-wise metrics are aggregated:\n-   Worst Aspect Ratio: $\\mathrm{AR}_{\\text{worst}} = \\max_{\\text{elements}} \\mathrm{AR}$.\n-   Worst Skewness: $\\mathrm{SK}_{\\text{worst}} = \\max_{\\text{elements}} \\mathrm{SK}$.\n-   Minimum Jacobian: $\\mathrm{JAC}_{\\text{min}} = \\min_{\\text{elements}} \\mathrm{JAC}$.\n\nThese three aggregated values provide a concise summary of the quality of the entire mesh.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define, process, and evaluate the quality of test meshes.\n    \"\"\"\n    \n    # Test suite to be embedded and evaluated.\n    mesh_A_string = \"\"\"\n    NODES 4\n    1 0.0 0.0 0.0\n    2 1.0 0.0 0.0\n    3 0.5 0.8660254037844386 0.0\n    4 0.5 0.2886751345948129 0.816496580927726\n    ELEMENTS 1\n    1 1 2 3 4\n    \"\"\"\n\n    mesh_B_string = \"\"\"\n    NODES 4\n    1 0.0 0.0 0.0\n    2 2.0 0.0 0.0\n    3 0.0 2.0 0.0\n    4 1.0 1.0 0.000001\n    ELEMENTS 1\n    1 1 2 3 4\n    \"\"\"\n\n    mesh_C_string = \"\"\"\n    NODES 4\n    1 0.0 0.0 0.0\n    2 1.0 0.0 0.0\n    3 0.5 0.8660254037844386 0.0\n    4 0.5 0.2886751345948129 0.816496580927726\n    ELEMENTS 1\n    1 1 3 2 4\n    \"\"\"\n    \n    test_cases = [mesh_A_string, mesh_B_string, mesh_C_string]\n\n    all_results = []\n    for mesh_data in test_cases:\n        result = process_mesh(mesh_data)\n        all_results.append(result)\n\n    # Format the final output string as specified.\n    list_of_lists_str = []\n    for res in all_results:\n        # Format each number to 6 decimal places.\n        formatted_res = [f\"{x:.6f}\" for x in res]\n        list_of_lists_str.append(f\"[{','.join(formatted_res)}]\")\n    \n    final_output_str = f\"[{','.join(list_of_lists_str)}]\"\n    print(final_output_str)\n\ndef parse_mesh(mesh_string: str) - (dict, list):\n    \"\"\"\n    Parses a mesh description from a string into node and element data structures.\n    \n    Args:\n        mesh_string: A multiline string containing the mesh definition.\n        \n    Returns:\n        A tuple containing:\n        - A dictionary of nodes {node_id: np.array([x, y, z])}.\n        - A list of element connectivities [(n1, n2, n3, n4), ...].\n    \"\"\"\n    lines = mesh_string.strip().split('\\n')\n    nodes = {}\n    elements = []\n    \n    mode = None # \"NODES\" or \"ELEMENTS\"\n\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n        \n        parts = line.split()\n        if parts[0] == \"NODES\":\n            mode = \"NODES\"\n            continue\n        elif parts[0] == \"ELEMENTS\":\n            mode = \"ELEMENTS\"\n            continue\n\n        if mode == \"NODES\":\n            node_id = int(parts[0])\n            coords = np.array([float(p) for p in parts[1:]])\n            nodes[node_id] = coords\n        elif mode == \"ELEMENTS\":\n            # Element ID is ignored as per logic, only connectivity matters\n            node_ids = tuple(int(p) for p in parts[1:])\n            elements.append(node_ids)\n            \n    return nodes, elements\n\ndef compute_aspect_ratio(node_coords: list) - float:\n    \"\"\"\n    Computes the aspect ratio for a single tetrahedral element.\n    Aspect Ratio = max_edge_length / min_edge_length.\n    \"\"\"\n    points = [np.array(c) for c in node_coords]\n    \n    edge_indices = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n    edge_lengths = [np.linalg.norm(points[i] - points[j]) for i, j in edge_indices]\n        \n    min_len = min(edge_lengths)\n    max_len = max(edge_lengths)\n    \n    if min_len  1e-12: # Treat very small lengths as zero to handle degeneracy\n        return np.inf\n    \n    return max_len / min_len\n\ndef compute_jacobian_metrics(node_coords: list) - (float, float):\n    \"\"\"\n    Computes the Jacobian determinant and skewness for a single tetrahedral element.\n    \"\"\"\n    x1, x2, x3, x4 = [np.array(c) for c in node_coords]\n    \n    # Construct the Jacobian matrix J = [x2-x1, x3-x1, x4-x1], where each\n    # difference vector is a column.\n    J = np.vstack((x2 - x1, x3 - x1, x4 - x1)).T\n    \n    # Compute the signed Jacobian determinant.\n    jac_det = np.linalg.det(J)\n    \n    # Compute singular values for skewness. np.linalg.svd returns them sorted.\n    singular_values = np.linalg.svd(J, compute_uv=False)\n    \n    sigma_max = singular_values[0]\n    sigma_min = singular_values[-1]\n    \n    if sigma_max  1e-12:\n        skewness = 1.0\n    else:\n        skewness = 1.0 - (sigma_min / sigma_max)\n        \n    return jac_det, skewness\n\ndef process_mesh(mesh_string: str) - list:\n    \"\"\"\n    Processes a mesh, computes quality metrics for all its elements,\n    and returns the aggregated mesh-level quality indicators.\n    \n    Args:\n        mesh_string: The string defining the mesh.\n        \n    Returns:\n        A list containing [worst_aspect_ratio, worst_skewness, min_jacobian_determinant].\n    \"\"\"\n    nodes, elements = parse_mesh(mesh_string)\n    \n    worst_ar = 0.0\n    worst_sk = 0.0\n    min_jac = np.inf\n    \n    for elem_node_ids in elements:\n        # Node IDs in the mesh file are 1-based.\n        node_coords = [nodes[nid] for nid in elem_node_ids]\n        \n        # 1. Aspect Ratio\n        ar = compute_aspect_ratio(node_coords)\n        if ar  worst_ar:\n            worst_ar = ar\n\n        # 2. Jacobian Determinant and 3. Skewness\n        jac, sk = compute_jacobian_metrics(node_coords)\n        if sk  worst_sk:\n            worst_sk = sk\n        if jac  min_jac:\n            min_jac = jac\n            \n    return [worst_ar, worst_sk, min_jac]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2412640"}, {"introduction": "Beyond the geometry of its elements, a mesh possesses a rich topological structure that defines how elements connect to each other. A critical topological feature is the boundary, where physical interactions with the outside world are typically defined in a simulation. This powerful exercise [@problem_id:2412652] demonstrates how to identify all boundary faces of a 3D mesh using only its connectivity data, without any reference to vertex coordinates. By implementing a simple yet profound incidence counting algorithm rooted in algebraic topology, you will learn to separate a mesh's topology from its geometry, a key concept for writing robust and general mesh processing tools.", "problem": "You are given only the element-to-node connectivity of a three-dimensional unstructured simplicial mesh composed of tetrahedra. There are no coordinates. A tetrahedral element is represented by an ordered quadruple of distinct nonnegative integers, each integer being a global node identifier. From first principles in algebraic topology for simplicial complexes, the boundary of a collection of tetrahedra is composed of those triangular faces that are incident to an odd number of tetrahedra when orientation is neglected; in the usual manifold case this means exactly one. Formally, for a tetrahedron with node set $\\{i,j,k,\\ell\\}$, its set of triangular facets is the set of $2$-simplices $\\{\\{i,j,k\\},\\{i,j,\\ell\\},\\{i,k,\\ell\\},\\{j,k,\\ell\\}\\}$. Given a multiset union of all such facet triplets taken over all tetrahedra in the mesh, a face is a boundary face if and only if it appears exactly once in this multiset, equivalently, it has incidence count equal to $1$.\n \nTask: Write a complete program that, for each provided test case, identifies all boundary triangular faces and tags each such face with a boundary tag of $1$. Use the following base and requirements.\n \nFundamental base to be used in your reasoning and algorithm design:\n- Definition of a simplicial complex and its faces: the boundary of a $3$-simplex consists of its four $2$-simplices.\n- Incidence counting principle: in a collection of tetrahedra, a triangular face is on the boundary if its incidence count is $1$; otherwise it is interior. This definition is consistent regardless of local orientation because we treat each triangular face as an unordered node set.\n- Set and multiset counting rules: equality of triangular faces is determined by equality of the unordered triples of node identifiers, and counting is performed over these canonicalized unordered triples.\n \nAlgorithmic requirements:\n- For each tetrahedron with nodes $\\{a,b,c,d\\}$, enumerate its four triangular faces as the unordered triples $\\{a,b,c\\}$, $\\{a,b,d\\}$, $\\{a,c,d\\}$, and $\\{b,c,d\\}$.\n- Canonicalize each face by sorting its three node identifiers in ascending order to represent the face as a unique key. This removes dependence on element orientation.\n- Count the occurrences of each face key across the entire mesh connectivity. A face key with count equal to $1$ is a boundary face.\n- Tagging rule: attach the integer boundary tag $1$ to each boundary face. The tag value is simply the integer $1$ for every boundary face in this problem.\n- Output representation of faces: each face must be output as a list of three strictly ascending node identifiers followed by its tag, that is, as $[i,j,k,1]$ with $ijk$.\n \nTest suite:\nProvide results for the following five independent test cases, where each case is a list of tetrahedra, and each tetrahedron is an ordered quadruple of nodes. All node identifiers are nonnegative integers.\n- Case $1$ (single tetrahedron): $[[0,1,2,3]]$.\n- Case $2$ (two tetrahedra sharing one face, with opposite local orientation on that shared face): $[[0,1,2,3],[0,2,1,4]]$.\n- Case $3$ (three tetrahedra meeting non-manifoldly on one common face): $[[1,2,3,0],[2,1,3,4],[3,1,2,5]]$.\n- Case $4$ (disconnected mesh: one isolated tetrahedron and one pair sharing a face): $[[10,11,12,13],[20,21,22,23],[22,21,20,24]]$.\n- Case $5$ (duplicate tetrahedra occupying the same connectivity, testing robustness): $[[0,1,2,3],[0,1,2,3]]$.\n \nFor each test case, your program must compute:\n- The integer count of boundary faces.\n- The lexicographically sorted list of boundary faces, each as $[i,j,k,1]$ with $ijk$.\n \nFinal output format:\n- Your program should produce a single line of output containing the results for all five cases as a comma-separated list enclosed in square brackets. Each case result must itself be a two-element list: $[\\text{boundary\\_count}, \\text{boundary\\_faces}]$, where $\\text{boundary\\_faces}$ is the lexicographically sorted list of tagged faces as specified. For example, the overall output format is $[[c_1,F_1],[c_2,F_2],[c_3,F_3],[c_4,F_4],[c_5,F_5]]$ where $c_m$ is an integer and $F_m$ is a list of lists of integers.\n \nAngles and physical units are not applicable to this problem. All outputs are integer-valued or lists of integers. Your program must be fully self-contained, require no input, and must compute results exactly for the five cases specified above.", "solution": "The problem presented is a well-defined exercise in computational topology, a foundational subject in computational engineering and physics. The task is to identify the boundary faces of a three-dimensional simplicial complex defined by a list of its constituent $3$-simplices (tetrahedra). We are provided with only the combinatorial connectivity data, specifically the node identifiers for each tetrahedron, and no geometric coordinates.\n\nThe problem rests upon a fundamental principle from algebraic topology concerning the boundary operator on a simplicial complex. A simplicial complex is a collection of simplices (vertices, edges, triangles, tetrahedra, and their higher-dimensional counterparts) that is closed under the operations of taking faces and non-empty intersections. Let $K$ be a simplicial complex. A $p$-chain is a formal sum of $p$-simplices in $K$, written as $\\sum_{i} c_i \\sigma_i^p$, where $\\sigma_i^p$ are the $p$-simplices and $c_i$ are coefficients from a ring, typically the integers $\\mathbb{Z}$ or a finite field like $\\mathbb{Z}_2 = \\{0, 1\\}$.\n\nThe boundary operator, $\\partial_p$, maps a $p$-simplex to a sum of its $(p-1)$-dimensional faces (facets). For a $p$-simplex $\\sigma^p = [v_0, v_1, \\dots, v_p]$ defined by its $p+1$ vertices, its boundary is the $(p-1)$-chain given by:\n$$\n\\partial_p(\\sigma^p) = \\sum_{j=0}^{p} (-1)^j [v_0, \\dots, \\hat{v}_j, \\dots, v_p]\n$$\nwhere $[v_0, \\dots, \\hat{v}_j, \\dots, v_p]$ denotes the $(p-1)$-simplex formed by omitting vertex $v_j$. The signs $(-1)^j$ account for orientation.\n\nThe problem statement simplifies this by effectively considering chains over the field $\\mathbb{Z}_2$. In this context, addition is modulo $2$, so orientation signs can be disregarded (as $-1 \\equiv 1 \\pmod 2$). The boundary of a $3$-simplex (a tetrahedron) $\\sigma^3 = [v_0, v_1, v_2, v_3]$ is simply the sum of its four $2$-simplex (triangular) faces:\n$$\n\\partial_3(\\sigma^3) = [v_1, v_2, v_3] + [v_0, v_2, v_3] + [v_0, v_1, v_3] + [v_0, v_1, v_2]\n$$\nNow, consider a $3$-chain $C = \\sum_{i} \\sigma_i^3$, which represents the collection of all tetrahedra in our mesh. The boundary of this entire collection, $\\partial_3(C)$, is found by exploiting the linearity of the boundary operator:\n$$\n\\partial_3(C) = \\partial_3\\left(\\sum_{i} \\sigma_i^3\\right) = \\sum_{i} \\partial_3(\\sigma_i^3)\n$$\nIn this sum over $\\mathbb{Z}_2$, a given triangular face $\\tau$ will appear once for each tetrahedron that contains it as a facet. If $\\tau$ is a facet of an even number of tetrahedra in the collection, say $2k$ times, its total contribution to the sum is $2k \\cdot \\tau \\equiv 0 \\pmod 2$. If $\\tau$ is a facet of an odd number of tetrahedra, say $2k+1$ times, its total contribution is $(2k+1) \\cdot \\tau \\equiv 1 \\cdot \\tau \\pmod 2$. Thus, the boundary $\\partial_3(C)$ is precisely the set of triangular faces that are each incident to an odd number of tetrahedra in the mesh.\n\nThe problem defines a \"boundary face\" as one with an incidence count of exactly $1$. This is a specialization of the general principle for the common case of a simplicial pseudomanifold, where any interior face is shared by exactly two tetrahedra. The algorithmic requirements correctly formalize this principle for computational implementation.\n\nThe algorithm is as follows:\n$1$. We require a data structure to store the incidence count of each unique triangular face. A hash map (or dictionary in Python) is ideal, where keys represent faces and values store their counts.\n$2$. To handle orientation-independence and provide a unique representation for each face, we must canonicalize it. A face defined by three node identifiers $\\{i, j, k\\}$ is canonicalized by sorting these integers into a tuple, e.g., $(i', j', k')$ where $i'  j'  k'$. This sorted tuple will serve as the unique key in our hash map.\n$3$. We iterate through each tetrahedron in the input list of connectivities. For each tetrahedron, represented by its four node identifiers $\\{v_0, v_1, v_2, v_3\\}$, we generate its four triangular faces: $\\{v_0, v_1, v_2\\}$, $\\{v_0, v_1, v_3\\}$, $\\{v_0, v_2, v_3\\}$, and $\\{v_1, v_2, v_3\\}$.\n$4$. For each generated face, we produce its canonical key as described in step $2$. We then update the hash map: if the key is already present, we increment its associated count; otherwise, we add the key to the map with a count of $1$.\n$5$. After processing all tetrahedra, the hash map contains every unique face in the mesh and its total incidence count. We then iterate through the map. Any face (key) whose count is exactly $1$ is identified as a boundary face.\n$6$. These identified boundary faces, which are tuples of three sorted node identifiers, are collected. A boundary tag of $1$ is appended to each, forming a list $[i', j', k', 1]$.\n$7$. The final list of tagged boundary faces is sorted lexicographically to ensure a unique, ordered output as required. The total number of such faces is also computed.\n\nThis procedure is deterministic, computationally efficient for the given constraints, and correctly implements the underlying topological principle. For example, in Case $2$ with tetrahedra $[[0,1,2,3],[0,2,1,4]]$, the face defined by nodes $\\{0,1,2\\}$ is generated from both tetrahedra. Its canonical form, the tuple $(0,1,2)$, will have its count incremented twice, resulting in a final count of $2$. Thus, it is correctly identified as an interior face. All other faces, such as $\\{0,1,3\\}$ from the first tetrahedron and $\\{0,1,4\\}$ from the second, appear only once and are correctly identified as boundary faces. This logic extends to all test cases, including non-manifold configurations (Case $3$) where a face may be shared by more than two elements, and duplicated elements (Case $5$) where each face's count is simply doubled.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport collections\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves for boundary faces in five test cases of tetrahedral meshes.\n    \"\"\"\n    test_cases = [\n        # Case 1: single tetrahedron\n        [[0, 1, 2, 3]],\n        # Case 2: two tetrahedra sharing one face\n        [[0, 1, 2, 3], [0, 2, 1, 4]],\n        # Case 3: three tetrahedra meeting non-manifoldly on one common face\n        [[1, 2, 3, 0], [2, 1, 3, 4], [3, 1, 2, 5]],\n        # Case 4: disconnected mesh\n        [[10, 11, 12, 13], [20, 21, 22, 23], [22, 21, 20, 24]],\n        # Case 5: duplicate tetrahedra\n        [[0, 1, 2, 3], [0, 1, 2, 3]],\n    ]\n\n    results = []\n    for connectivity in test_cases:\n        # Use a dictionary to store face counts.\n        # Key: canonical face (sorted tuple of 3 node IDs)\n        # Value: incidence count\n        face_counts = collections.defaultdict(int)\n\n        # Iterate through each tetrahedron in the mesh\n        for tet_nodes in connectivity:\n            # A tetrahedron has 4 nodes. A triangular face is formed by 3 nodes.\n            # We generate all combinations of 3 nodes from the 4.\n            for face_nodes in combinations(tet_nodes, 3):\n                # Canonicalize the face by sorting its node IDs.\n                # This makes the representation unique regardless of orientation.\n                canonical_face = tuple(sorted(face_nodes))\n                face_counts[canonical_face] += 1\n\n        # Identify boundary faces\n        # A face is a boundary face if its incidence count is exactly 1.\n        boundary_faces = []\n        for face, count in face_counts.items():\n            if count == 1:\n                # The output format for a face is [i, j, k, 1]\n                tagged_face = list(face) + [1]\n                boundary_faces.append(tagged_face)\n        \n        # Sort the boundary faces lexicographically for a consistent output.\n        boundary_faces.sort()\n        \n        # Get the count of boundary faces.\n        boundary_count = len(boundary_faces)\n\n        # Store the result for this test case.\n        results.append([boundary_count, boundary_faces])\n\n    # The final output must be a single line string representation of the list\n    # of results, with no spaces. str() adds spaces, so we remove them.\n    final_output_string = str(results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```", "id": "2412652"}]}