{"hands_on_practices": [{"introduction": "This practice addresses a fundamental task in geometric design: creating a smooth curve that passes exactly through a series of data points. By setting up and solving a system of linear equations, you will determine the precise B-spline control points $\\{\\mathbf{P}_j\\}$ needed to make the curve $\\mathbf{C}(u)$ interpolate a given set of points $\\{\\mathbf{Q}_i\\}$. This exercise [@problem_id:2372182] bridges the gap between abstract control polygons and concrete design constraints, demonstrating a powerful method for shape modeling.", "problem": "Design a program that, for each given test case, constructs a nonrational B-spline curve of degree $p$ that interpolates a specified sequence of points in Euclidean space by enforcing exact interpolation at a set of parameter values. Let the sequence of data points be $\\{\\mathbf{Q}_i\\}_{i=0}^{n}$ with $\\mathbf{Q}_i \\in \\mathbb{R}^d$, where $d \\in \\{2,3\\}$. Define the B-spline basis functions $\\{N_{j,p}(u)\\}_{j=0}^{n}$ over a clamped open knot vector $\\mathbf{U} = \\{U_0,\\dots,U_{n+p+1}\\}$, and define the B-spline curve $ \\mathbf{C}(u) = \\sum_{j=0}^{n} N_{j,p}(u)\\,\\mathbf{P}_j$, where $\\{\\mathbf{P}_j\\}_{j=0}^{n}$ are the unknown control points in $\\mathbb{R}^d$. The interpolation requirement is $\\mathbf{C}(t_i) = \\mathbf{Q}_i$ for $i = 0,\\dots,n$, where $\\{t_i\\}_{i=0}^{n}$ are strictly increasing parameter values in $[0,1]$ obtained by chord-length parameterization defined by $t_0 = 0$, $t_i = \\left(\\sum_{k=1}^{i} \\|\\mathbf{Q}_k - \\mathbf{Q}_{k-1}\\|_2\\right) / \\left(\\sum_{k=1}^{n} \\|\\mathbf{Q}_k - \\mathbf{Q}_{k-1}\\|_2\\right)$ for $i=1,\\dots,n$, and hence $t_n = 1$. The clamped open knot vector must have multiplicity $p+1$ at the ends: $U_0 = \\cdots = U_p = 0$ and $U_{n+1} = \\cdots = U_{n+p+1} = 1$, with internal knots set by the averaging method for $j=1,\\dots,n-p$:\n$$\nU_{j+p} = \\frac{1}{p}\\sum_{i=j}^{j+p-1} t_i.\n$$\nFor each test case, compute control points $\\{\\mathbf{P}_j\\}_{j=0}^{n}$ that satisfy the interpolation constraints, evaluate the curve at the same parameter values $\\{t_i\\}$, and return the maximum interpolation residual measured by the Euclidean norm, i.e., $\\max_{0\\le i\\le n} \\|\\mathbf{C}(t_i)-\\mathbf{Q}_i\\|_2$, as a real number. No physical units are involved.\n\nTest Suite:\n- Case A (happy path, two-dimensional cubic): $p=3$, $\\mathbf{Q}_0=\\left(0,0\\right)$, $\\mathbf{Q}_1=\\left(1,2\\right)$, $\\mathbf{Q}_2=\\left(3,3\\right)$, $\\mathbf{Q}_3=\\left(4,2\\right)$, $\\mathbf{Q}_4=\\left(5,0\\right)$.\n- Case B (boundary degree, two-dimensional linear with multiple interior knots): $p=1$, $\\mathbf{Q}_0=\\left(0,0\\right)$, $\\mathbf{Q}_1=\\left(1,2\\right)$, $\\mathbf{Q}_2=\\left(2,2\\right)$, $\\mathbf{Q}_3=\\left(3,0\\right)$.\n- Case C (three-dimensional quadratic, nonuniform spacing): $p=2$, $\\mathbf{Q}_0=\\left(0,0,0\\right)$, $\\mathbf{Q}_1=\\left(1,0.5,0.1\\right)$, $\\mathbf{Q}_2=\\left(2,0.0,0.2\\right)$, $\\mathbf{Q}_3=\\left(3,-0.5,0.0\\right)$, $\\mathbf{Q}_4=\\left(4,0.0,-0.1\\right)$.\n\nYour program must, for each case in the order A, B, C, construct the parameter values $\\{t_i\\}$, construct the clamped open knot vector $\\mathbf{U}$ as specified, set up the interpolation equations implied by $\\mathbf{C}(t_i)=\\mathbf{Q}_i$ for $i=0,\\dots,n$, compute control points $\\{\\mathbf{P}_j\\}$, and output a single real number equal to $\\max_{i}\\|\\mathbf{C}(t_i)-\\mathbf{Q}_i\\|_2$ for that case.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[ \\text{resultA}, \\text{resultB}, \\text{resultC} \\right]$), where each entry is the maximum interpolation residual for the corresponding test case expressed as a real number.", "solution": "The user has provided a problem that requires the design of a program for B-spline curve interpolation. The problem is well-defined, scientifically sound, and falls within the domain of computational engineering. It has been validated as a valid problem.\n\nThe core of the problem is to find a set of control points $\\{\\mathbf{P}_j\\}_{j=0}^{n}$ for a B-spline curve of degree $p$, such that the curve passes through a given sequence of data points $\\{\\mathbf{Q}_i\\}_{i=0}^{n}$. The interpolation conditions are given by $\\mathbf{C}(t_i) = \\mathbf{Q}_i$ for a specific set of parameter values $\\{t_i\\}_{i=0}^{n}$.\n\nThe B-spline curve is defined as a linear combination of B-spline basis functions $N_{j,p}(u)$ and the unknown control points $\\mathbf{P}_j$:\n$$\n\\mathbf{C}(u) = \\sum_{j=0}^{n} N_{j,p}(u)\\,\\mathbf{P}_j\n$$\nSubstituting the interpolation conditions into this definition yields a system of $n+1$ linear equations for the $n+1$ unknown control points:\n$$\n\\mathbf{Q}_i = \\sum_{j=0}^{n} N_{j,p}(t_i)\\,\\mathbf{P}_j \\quad \\text{for } i = 0, \\dots, n\n$$\nThis system can be expressed in matrix form as $N \\mathbf{P} = \\mathbf{Q}$, where $N$ is an $(n+1) \\times (n+1)$ matrix with entries $N_{ij} = N_{j,p}(t_i)$, $\\mathbf{P}$ is the matrix of control points (with rows being $\\mathbf{P}_j^T$), and $\\mathbf{Q}$ is the matrix of data points (with rows being $\\mathbf{Q}_i^T$). Note that this system is solved independently for each coordinate of the points.\n\nThe solution proceeds via the following well-defined steps:\n\n1.  **Parameterization**: The parameter values $\\{t_i\\}_{i=0}^{n}$ are determined using the chord-length method. This method assigns parameter values proportionally to the cumulative Euclidean distance between consecutive data points. The total chord length is $L = \\sum_{k=1}^{n} \\|\\mathbf{Q}_k - \\mathbf{Q}_{k-1}\\|_2$. The parameters are then:\n    $$\n    t_0 = 0, \\quad t_i = \\frac{1}{L} \\sum_{k=1}^{i} \\|\\mathbf{Q}_k - \\mathbf{Q}_{k-1}\\|_2 \\quad \\text{for } i=1,\\dots,n\n    $$\n\n2.  **Knot Vector Generation**: A clamped open knot vector $\\mathbf{U}$ of size $n+p+2$ is constructed. The clamping ensures that the curve starts at $\\mathbf{P}_0$ and ends at $\\mathbf{P}_n$. The knots are defined as:\n    - End knots: $U_0 = \\dots = U_p = 0$ and $U_{n+1} = \\dots = U_{n+p+1} = 1$.\n    - Internal knots: The problem specifies an averaging method, where internal knots are computed based on the parameter values $\\{t_i\\}$:\n    $$\n    U_{j+p} = \\frac{1}{p}\\sum_{i=j}^{j+p-1} t_i \\quad \\text{for } j=1, \\dots, n-p\n    $$\n    This method of knot placement is designed to satisfy the Schoenberg-Whitney conditions, ensuring that the resulting interpolation matrix $N$ is non-singular and well-conditioned.\n\n3.  **Basis Function Evaluation**: The B-spline basis functions $N_{j,p}(u)$ are evaluated using the Cox-de Boor recursion formula. For $p > 0$:\n    $$\n    N_{j,p}(u) = \\frac{u - U_j}{U_{j+p} - U_j} N_{j,p-1}(u) + \\frac{U_{j+p+1} - u}{U_{j+p+1} - U_{j+1}} N_{j+1,p-1}(u)\n    $$\n    The base case for the recursion is:\n    $$\n    N_{j,0}(u) = \\begin{cases} 1 & \\text{if } U_j \\le u < U_{j+1} \\\\ 0 & \\text{otherwise} \\end{cases}\n    $$\n    A convention is used where any term with a zero denominator is treated as zero. For the very last knot interval, $[U_n, U_{n+1}]$, the interval is considered closed at the right end to handle $u=1$. Computationally, this process is implemented efficiently without recursion, by calculating values for increasing degrees.\n\n4.  **System Solution**: The interpolation matrix $N$ is populated by evaluating the basis functions at each parameter value $t_i$. The linear system $N \\mathbf{P} = \\mathbf{Q}$ is then solved for the control point matrix $\\mathbf{P}$ using a standard numerical linear algebra solver, such as `numpy.linalg.solve`, which is robust against potential numerical instabilities.\n\n5.  **Residual Calculation**: After computing the control points $\\{\\mathbf{P}_j\\}$, the B-spline curve $\\mathbf{C}(u)$ is fully defined. To verify the interpolation, the curve is evaluated at the original parameter values, $\\mathbf{C}(t_i)$. Due to floating-point arithmetic limitations, the computed $\\mathbf{C}(t_i)$ might not be exactly equal to $\\mathbf{Q}_i$. The interpolation residual for each point is calculated as the Euclidean norm of the difference, $\\|\\mathbf{C}(t_i) - \\mathbf{Q}_i\\|_2$. The final result for each test case is the maximum of these residuals over all $i=0, \\dots, n$. This value serves as a measure of the accuracy of the numerical implementation. For a correct implementation, this residual should be on the order of machine precision.", "answer": "```python\nimport numpy as np\n\ndef find_span(n, p, u, U):\n    \"\"\"\n    Determine the knot span index for a given parameter u.\n    This implementation is based on Algorithm A2.1 from \"The NURBS Book\".\n    \n    Args:\n        n (int): Number of control points minus 1.\n        p (int): Degree of the B-spline.\n        u (float): Parameter value.\n        U (np.ndarray): Knot vector.\n    \n    Returns:\n        int: The index of the knot span that contains u.\n    \"\"\"\n    if u >= U[n + 1]:  # Special case for u at the end of the domain\n        return n\n    \n    # Binary search for the span\n    low = p\n    high = n + 1\n    mid = (low + high) // 2\n    \n    while u < U[mid] or u >= U[mid + 1]:\n        if u < U[mid]:\n            high = mid\n        else:\n            low = mid\n        mid = (low + high) // 2\n    return mid\n\ndef basis_funs(i, u, p, U):\n    \"\"\"\n    Compute the non-zero B-spline basis functions.\n    This implementation is based on Algorithm A2.2 from \"The NURBS Book\".\n\n    Args:\n        i (int): Knot span index.\n        u (float): Parameter value.\n        p (int): Degree of the B-spline.\n        U (np.ndarray): Knot vector.\n\n    Returns:\n        np.ndarray: An array of p+1 non-zero basis function values.\n    \"\"\"\n    N = np.zeros(p + 1, dtype=np.float64)\n    N[0] = 1.0\n    left = np.zeros(p + 1, dtype=np.float64)\n    right = np.zeros(p + 1, dtype=np.float64)\n\n    for j in range(1, p + 1):\n        left[j] = u - U[i + 1 - j]\n        right[j] = U[i + j] - u\n        saved = 0.0\n        for r in range(j):\n            # The denominator can be zero if knots are repeated. The formula\n            # requires this term to be zero, which is handled implicitly\n            # if the numerator is also zero, but we add a check for robustness.\n            den = right[r + 1] + left[j - r]\n            if den == 0.0:\n                temp = 0.0\n            else:\n                temp = N[r] / den\n            N[r] = saved + right[r + 1] * temp\n            saved = left[j - r] * temp\n        N[j] = saved\n    return N\n\ndef solve_interpolation(p, Q_points):\n    \"\"\"\n    Computes the maximum interpolation residual for a single test case.\n\n    Args:\n        p (int): Degree of the B-spline.\n        Q_points (list of tuples): Sequence of data points to interpolate.\n\n    Returns:\n        float: The maximum interpolation residual.\n    \"\"\"\n    Q = np.array(Q_points, dtype=np.float64)\n    n = Q.shape[0] - 1\n    \n    # Step 1: Chord-length parameterization\n    t = np.zeros(n + 1, dtype=np.float64)\n    chord_lengths = np.linalg.norm(np.diff(Q, axis=0), axis=1)\n    total_length = np.sum(chord_lengths)\n    \n    if total_length < 1e-12: # Handle degenerate case where all points coincide.\n        return 0.0\n\n    cumulative_lengths = np.cumsum(chord_lengths)\n    t[1:] = cumulative_lengths / total_length\n    \n    # Step 2: Knot vector construction\n    num_knots = n + p + 2\n    U = np.zeros(num_knots, dtype=np.float64)\n    U[0:p+1] = 0.0\n    U[n+1:] = 1.0\n    \n    if p > 0 and n > p:\n        for j in range(1, n - p + 1):\n            U[p + j] = (1.0 / p) * np.sum(t[j : j + p])\n    elif p == 1 and n > 1: # The general formula covers this, but for clarity:\n        for j in range(1, n):\n            U[1 + j] = t[j]\n\n    # Step 3: Set up interpolation matrix N\n    N_matrix = np.zeros((n + 1, n + 1), dtype=np.float64)\n    for i in range(n + 1):\n        u_param = t[i]\n        span = find_span(n, p, u_param, U)\n        basis_values = basis_funs(span, u_param, p, U)\n        start_idx = span - p\n        N_matrix[i, start_idx : start_idx + p + 1] = basis_values\n\n    # Step 4: Solve for control points P\n    try:\n        P = np.linalg.solve(N_matrix, Q)\n    except np.linalg.LinAlgError:\n        return np.inf\n\n    # Step 5: Evaluate the curve and compute the maximum residual\n    Q_reconstructed = N_matrix @ P\n    residuals = np.linalg.norm(Q_reconstructed - Q, axis=1)\n    max_residual = np.max(residuals)\n    \n    return max_residual\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A: 2D cubic B-spline\n        (3, [ (0.0, 0.0), (1.0, 2.0), (3.0, 3.0), (4.0, 2.0), (5.0, 0.0) ]),\n        # Case B: 2D linear B-spline\n        (1, [ (0.0, 0.0), (1.0, 2.0), (2.0, 2.0), (3.0, 0.0) ]),\n        # Case C: 3D quadratic B-spline\n        (2, [ (0.0, 0.0, 0.0), (1.0, 0.5, 0.1), (2.0, 0.0, 0.2), (3.0, -0.5, 0.0), (4.0, 0.0, -0.1) ])\n    ]\n\n    results = []\n    for p, Q_points in test_cases:\n        result = solve_interpolation(p, Q_points)\n        # Format to scientific notation for consistent output of small numbers.\n        results.append(f\"{result:.17e}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2372182"}, {"introduction": "While B-splines offer flexibility through their knot vectors, many algorithms and systems are built upon the simpler foundation of Bézier curves. This exercise [@problem_id:2372217] guides you through the first-principles derivation of the transformation matrix that converts a segment of a uniform B-spline curve into its equivalent Bézier representation. Mastering this conversion deepens your understanding of how these curve schemes are mathematically related and is a key skill for building robust geometric modeling tools.", "problem": "A cubic B-spline curve with an open uniform knot vector and unit spacing is used to approximate a smooth profile in a computational engineering pipeline. Consider an interior knot span $\\left[u_k, u_{k+1}\\right]$ with $u_{k+1} - u_k = 1$. Let the curve segment on this span be written in two equivalent forms:\n- As a degree-$3$ B-spline segment using the $4$ control points $\\boldsymbol{P}_{k-3}, \\boldsymbol{P}_{k-2}, \\boldsymbol{P}_{k-1}, \\boldsymbol{P}_{k}$ and the nonzero basis functions $N_{k-3,3}(u), \\dots, N_{k,3}(u)$.\n- As a cubic Bézier curve using the $4$ Bézier control points $\\boldsymbol{Q}_0, \\boldsymbol{Q}_1, \\boldsymbol{Q}_2, \\boldsymbol{Q}_3$ and the Bernstein polynomials of degree $3$.\n\nStarting only from the fundamental definitions of B-spline basis functions via the Cox–de Boor recursion and the Bernstein polynomials, proceed as follows:\n- Reparameterize the span to $s \\in [0,1]$ using $s = u - u_k$.\n- Derive the polynomial form on $[0,1]$ of the $4$ nonzero cubic uniform B-spline basis functions for this span.\n- Express both the B-spline and the Bézier representations in the monomial power basis $\\left[s^3, s^2, s, 1\\right]$ to obtain their respective $4 \\times 4$ basis matrices.\n- From first principles, derive the $4 \\times 4$ linear transformation matrix $\\boldsymbol{T}$ such that\n$$\n\\begin{pmatrix}\n\\boldsymbol{Q}_0 \\\\ \\boldsymbol{Q}_1 \\\\ \\boldsymbol{Q}_2 \\\\ \\boldsymbol{Q}_3\n\\end{pmatrix}\n=\n\\boldsymbol{T}\n\\begin{pmatrix}\n\\boldsymbol{P}_{k-3} \\\\ \\boldsymbol{P}_{k-2} \\\\ \\boldsymbol{P}_{k-1} \\\\ \\boldsymbol{P}_k\n\\end{pmatrix}.\n$$\n\nGive your final answer as a single explicit $4 \\times 4$ matrix with rational entries. Do not use any pre-tabulated conversion formulas or results beyond the fundamental definitions. The final answer must be a single closed-form expression. No rounding is required.", "solution": "The problem as stated is valid. It is scientifically grounded in the principles of computational geometry, specifically the theory of B-splines and Bézier curves. The problem is well-posed, objective, and contains all necessary information for a unique solution to be derived from first principles. We shall proceed with the derivation.\n\nThe objective is to find the linear transformation matrix $\\boldsymbol{T}$ that maps a set of four uniform cubic B-spline control points $\\{\\boldsymbol{P}_{k-3}, \\boldsymbol{P}_{k-2}, \\boldsymbol{P}_{k-1}, \\boldsymbol{P}_{k}\\}$ to the set of four equivalent cubic Bézier control points $\\{\\boldsymbol{Q}_0, \\boldsymbol{Q}_1, \\boldsymbol{Q}_2, \\boldsymbol{Q}_3\\}$. The curve segment is defined over a knot span $[u_k, u_{k+1}]$, which is reparameterized by $s = u - u_k$ to the interval $[0,1]$.\n\nA curve segment $\\boldsymbol{C}(s)$ for $s \\in [0,1]$ can be expressed in two forms:\n$1$. As a B-spline segment: $\\boldsymbol{C}(s) = \\sum_{i=0}^{3} \\boldsymbol{P}_{k-3+i} b_i(s)$, where $b_i(s) = N_{k-3+i, 3}(u)$ are the B-spline basis functions evaluated on the span.\n$2$. As a Bézier segment: $\\boldsymbol{C}(s) = \\sum_{j=0}^{3} \\boldsymbol{Q}_j B_{j,3}(s)$, where $B_{j,3}(s)$ are the Bernstein basis polynomials.\n\nBoth representations can be written in a matrix form using the monomial basis $[s^3, s^2, s, 1]$. Let $\\boldsymbol{S}(s) = \\begin{pmatrix} s^3 & s^2 & s & 1 \\end{pmatrix}$.\nThen,\n$$ \\boldsymbol{C}(s) = \\boldsymbol{S}(s) \\boldsymbol{M}_{B-spline} \\begin{pmatrix} \\boldsymbol{P}_{k-3} \\\\ \\boldsymbol{P}_{k-2} \\\\ \\boldsymbol{P}_{k-1} \\\\ \\boldsymbol{P}_k \\end{pmatrix} = \\boldsymbol{S}(s) \\boldsymbol{M}_{Bezier} \\begin{pmatrix} \\boldsymbol{Q}_0 \\\\ \\boldsymbol{Q}_1 \\\\ \\boldsymbol{Q}_2 \\\\ \\boldsymbol{Q}_3 \\end{pmatrix} $$\nSince the monomial basis is linearly independent, the coefficients of $\\boldsymbol{S}(s)$ must be equal:\n$$ \\boldsymbol{M}_{B-spline} \\begin{pmatrix} \\boldsymbol{P}_{k-3} \\\\ \\boldsymbol{P}_{k-2} \\\\ \\boldsymbol{P}_{k-1} \\\\ \\boldsymbol{P}_k \\end{pmatrix} = \\boldsymbol{M}_{Bezier} \\begin{pmatrix} \\boldsymbol{Q}_0 \\\\ \\boldsymbol{Q}_1 \\\\ \\boldsymbol{Q}_2 \\\\ \\boldsymbol{Q}_3 \\end{pmatrix} $$\nFrom this, we can solve for the Bézier control points:\n$$ \\begin{pmatrix} \\boldsymbol{Q}_0 \\\\ \\boldsymbol{Q}_1 \\\\ \\boldsymbol{Q}_2 \\\\ \\boldsymbol{Q}_3 \\end{pmatrix} = (\\boldsymbol{M}_{Bezier})^{-1} \\boldsymbol{M}_{B-spline} \\begin{pmatrix} \\boldsymbol{P}_{k-3} \\\\ \\boldsymbol{P}_{k-2} \\\\ \\boldsymbol{P}_{k-1} \\\\ \\boldsymbol{P}_k \\end{pmatrix} $$\nThe desired transformation matrix is therefore $\\boldsymbol{T} = (\\boldsymbol{M}_{Bezier})^{-1} \\boldsymbol{M}_{B-spline}$. We will now derive the matrices $\\boldsymbol{M}_{B-spline}$ and $\\boldsymbol{M}_{Bezier}$ from their fundamental definitions.\n\nStep 1: Derivation of the Uniform Cubic B-spline Basis Functions\nWe use the Cox-de Boor recursion formula for B-spline basis functions of degree $p$:\n$$ N_{i,p}(u) = \\frac{u-u_i}{u_{i+p}-u_i}N_{i,p-1}(u) + \\frac{u_{i+p+1}-u}{u_{i+p+1}-u_{i+1}}N_{i+1,p-1}(u) $$\nwith $N_{i,0}(u) = 1$ if $u_i \\le u < u_{i+1}$ and $0$ otherwise.\nFor a uniform knot vector with unit spacing, we may set $u_i = i$ without loss of generality. The recursion simplifies to:\n$$ N_{i,p}(u) = \\frac{u-i}{p}N_{i,p-1}(u) + \\frac{i+p+1-u}{p}N_{i+1,p-1}(u) $$\nWe are interested in the interval $[u_k, u_{k+1}] = [k, k+1]$, parameterized by $s = u-k \\in [0,1]$, so $u=s+k$.\nThe four non-zero cubic ($p=3$) basis functions on this interval are $N_{k-3,3}(u), N_{k-2,3}(u), N_{k-1,3}(u), N_{k,3}(u)$. Let's denote their reparameterized forms as $b_0(s), b_1(s), b_2(s), b_3(s)$. We build them up from degree $0$.\n\nOn $u \\in [k, k+1)$, the only non-zero basis function of degree $0$ is $N_{k,0}(u)=1$. For degree $1$, the functions with support overlapping this interval are $N_{k-1,1}(u) = k+1-u = 1-s$ and $N_{k,1}(u) = u-k = s$.\n\nFor degree $2$ ($p=2$):\n$N_{k-2,2}(u) = \\frac{u-(k-2)}{2}N_{k-2,1}(u) + \\frac{k+1-u}{2}N_{k-1,1}(u) = 0 + \\frac{1-s}{2}(1-s) = \\frac{1}{2}(1-s)^2$.\n$N_{k-1,2}(u) = \\frac{u-(k-1)}{2}N_{k-1,1}(u) + \\frac{k+2-u}{2}N_{k,1}(u) = \\frac{s+1}{2}(1-s) + \\frac{2-s}{2}(s) = \\frac{1}{2}(-2s^2+2s+1)$.\n$N_{k,2}(u) = \\frac{u-k}{2}N_{k,1}(u) + \\frac{k+3-u}{2}N_{k+1,1}(u) = \\frac{s}{2}(s) + 0 = \\frac{1}{2}s^2$.\n\nFor degree $3$ ($p=3$):\n$b_0(s) = N_{k-3,3}(u) = \\frac{k+1-u}{3}N_{k-2,2}(u) = \\frac{1-s}{3} \\frac{(1-s)^2}{2} = \\frac{1}{6}(1-s)^3 = \\frac{1}{6}(-s^3+3s^2-3s+1)$.\n$b_1(s) = N_{k-2,3}(u) = \\frac{u-(k-2)}{3}N_{k-2,2}(u) + \\frac{k+2-u}{3}N_{k-1,2}(u) = \\frac{s+2}{3}\\frac{(1-s)^2}{2} + \\frac{2-s}{3}\\frac{-2s^2+2s+1}{2} = \\frac{1}{6}(3s^3-6s^2+4)$.\n$b_2(s) = N_{k-1,3}(u) = \\frac{u-(k-1)}{3}N_{k-1,2}(u) + \\frac{k+3-u}{3}N_{k,2}(u) = \\frac{s+1}{3}\\frac{-2s^2+2s+1}{2} + \\frac{3-s}{3}\\frac{s^2}{2} = \\frac{1}{6}(-3s^3+3s^2+3s+1)$.\n$b_3(s) = N_{k,3}(u) = \\frac{u-k}{3}N_{k,2}(u) = \\frac{s}{3}\\frac{s^2}{2} = \\frac{1}{6}s^3$.\n\nThe B-spline basis matrix $\\boldsymbol{M}_{B-spline}$ is formed by the coefficients of these polynomials in the basis $[s^3, s^2, s, 1]$. The $j$-th column corresponds to $b_{j-1}(s)$.\n$$ \\boldsymbol{M}_{B-spline} = \\frac{1}{6} \\begin{pmatrix} -1 & 3 & -3 & 1 \\\\ 3 & -6 & 3 & 0 \\\\ -3 & 0 & 3 & 0 \\\\ 1 & 4 & 1 & 0 \\end{pmatrix} $$\n\nStep 2: Derivation of the Bézier Basis Matrix\nThe cubic Bernstein basis polynomials are defined as $B_{i,3}(s) = \\binom{3}{i} s^i (1-s)^{3-i}$ for $i=0,1,2,3$.\n$B_{0,3}(s) = (1-s)^3 = -s^3 + 3s^2 - 3s + 1$.\n$B_{1,3}(s) = 3s(1-s)^2 = 3s^3 - 6s^2 + 3s$.\n$B_{2,3}(s) = 3s^2(1-s) = -3s^3 + 3s^2$.\n$B_{3,3}(s) = s^3$.\n\nThe Bézier basis matrix $\\boldsymbol{M}_{Bezier}$ is formed by the coefficients of these polynomials.\n$$ \\boldsymbol{M}_{Bezier} = \\begin{pmatrix} -1 & 3 & -3 & 1 \\\\ 3 & -6 & 3 & 0 \\\\ -3 & 3 & 0 & 0 \\\\ 1 & 0 & 0 & 0 \\end{pmatrix} $$\n\nStep 3: Derivation of the Inverse Bézier Basis Matrix\nTo find $\\boldsymbol{T}$, we need $(\\boldsymbol{M}_{Bezier})^{-1}$. We can derive this by relating the Bézier control points to the coefficients of the monomial power basis. For a curve $\\boldsymbol{C}(s) = \\boldsymbol{c}_3 s^3 + \\boldsymbol{c}_2 s^2 + \\boldsymbol{c}_1 s + \\boldsymbol{c}_0$, the Bézier points are given by its endpoint derivatives.\n$\\boldsymbol{Q}_0 = \\boldsymbol{C}(0) = \\boldsymbol{c}_0$.\n$\\boldsymbol{Q}_1 = \\boldsymbol{C}(0) + \\frac{1}{3}\\boldsymbol{C}'(0) = \\boldsymbol{c}_0 + \\frac{1}{3}\\boldsymbol{c}_1$.\n$\\boldsymbol{Q}_3 = \\boldsymbol{C}(1) = \\boldsymbol{c}_3 + \\boldsymbol{c}_2 + \\boldsymbol{c}_1 + \\boldsymbol{c}_0$.\n$\\boldsymbol{Q}_2 = \\boldsymbol{C}(1) - \\frac{1}{3}\\boldsymbol{C}'(1) = (\\boldsymbol{c}_3+\\boldsymbol{c}_2+\\boldsymbol{c}_1+\\boldsymbol{c}_0) - \\frac{1}{3}(3\\boldsymbol{c}_3+2\\boldsymbol{c}_2+\\boldsymbol{c}_1) = \\boldsymbol{c}_0 + \\frac{2}{3}\\boldsymbol{c}_1 + \\frac{1}{3}\\boldsymbol{c}_2$.\n\nIn matrix form, this relation is:\n$$ \\begin{pmatrix} \\boldsymbol{Q}_0 \\\\ \\boldsymbol{Q}_1 \\\\ \\boldsymbol{Q}_2 \\\\ \\boldsymbol{Q}_3 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1/3 & 1 \\\\ 0 & 1/3 & 2/3 & 1 \\\\ 1 & 1 & 1 & 1 \\end{pmatrix} \\begin{pmatrix} \\boldsymbol{c}_3 \\\\ \\boldsymbol{c}_2 \\\\ \\boldsymbol{c}_1 \\\\ \\boldsymbol{c}_0 \\end{pmatrix} $$\nThe vector $(\\boldsymbol{c}_3, \\boldsymbol{c}_2, \\boldsymbol{c}_1, \\boldsymbol{c}_0)^T$ is the result of $\\boldsymbol{M}_{B-spline} \\boldsymbol{P}_{vec}$. Therefore, the matrix above is $(\\boldsymbol{M}_{Bezier})^{-1}$.\n$$ (\\boldsymbol{M}_{Bezier})^{-1} = \\begin{pmatrix} 0 & 0 & 0 & 1 \\\\ 0 & 0 & \\frac{1}{3} & 1 \\\\ 0 & \\frac{1}{3} & \\frac{2}{3} & 1 \\\\ 1 & 1 & 1 & 1 \\end{pmatrix} $$\n\nStep 4: Calculation of the Transformation Matrix T\nFinally, we compute the product $\\boldsymbol{T} = (\\boldsymbol{M}_{Bezier})^{-1} \\boldsymbol{M}_{B-spline}$.\n$$ \\boldsymbol{T} = \\begin{pmatrix} 0 & 0 & 0 & 1 \\\\ 0 & 0 & \\frac{1}{3} & 1 \\\\ 0 & \\frac{1}{3} & \\frac{2}{3} & 1 \\\\ 1 & 1 & 1 & 1 \\end{pmatrix} \\frac{1}{6} \\begin{pmatrix} -1 & 3 & -3 & 1 \\\\ 3 & -6 & 3 & 0 \\\\ -3 & 0 & 3 & 0 \\\\ 1 & 4 & 1 & 0 \\end{pmatrix} $$\n$$ \\boldsymbol{T} = \\frac{1}{6} \\begin{pmatrix}\n(1) & (4) & (1) & (0) \\\\\n\\frac{1}{3}(-3)+1(1) & \\frac{1}{3}(0)+1(4) & \\frac{1}{3}(3)+1(1) & \\frac{1}{3}(0)+1(0) \\\\\n\\frac{1}{3}(3)+\\frac{2}{3}(-3)+1(1) & \\frac{1}{3}(-6)+\\frac{2}{3}(0)+1(4) & \\frac{1}{3}(3)+\\frac{2}{3}(3)+1(1) & \\frac{1}{3}(0)+\\frac{2}{3}(0)+1(0) \\\\\n(-1)+3-3+1 & 3-6+0+4 & -3+3+3+1 & 1+0+0+0\n\\end{pmatrix} $$\n$$ \\boldsymbol{T} = \\frac{1}{6} \\begin{pmatrix}\n1 & 4 & 1 & 0 \\\\\n-1+1 & 4 & 1+1 & 0 \\\\\n1-2+1 & -2+4 & 1+2+1 & 0 \\\\\n0 & 1 & 4 & 1\n\\end{pmatrix} = \\frac{1}{6} \\begin{pmatrix}\n1 & 4 & 1 & 0 \\\\\n0 & 4 & 2 & 0 \\\\\n0 & 2 & 4 & 0 \\\\\n0 & 1 & 4 & 1\n\\end{pmatrix} $$\nThe problem requests the final answer as a single explicit matrix with rational entries. We incorporate the scalar multiple into the matrix elements.\n$$ \\boldsymbol{T} = \\begin{pmatrix}\n\\frac{1}{6} & \\frac{4}{6} & \\frac{1}{6} & 0 \\\\\n0 & \\frac{4}{6} & \\frac{2}{6} & 0 \\\\\n0 & \\frac{2}{6} & \\frac{4}{6} & 0 \\\\\n0 & \\frac{1}{6} & \\frac{4}{6} & \\frac{1}{6}\n\\end{pmatrix} = \\begin{pmatrix}\n\\frac{1}{6} & \\frac{2}{3} & \\frac{1}{6} & 0 \\\\\n0 & \\frac{2}{3} & \\frac{1}{3} & 0 \\\\\n0 & \\frac{1}{3} & \\frac{2}{3} & 0 \\\\\n0 & \\frac{1}{6} & \\frac{2}{3} & \\frac{1}{6}\n\\end{pmatrix} $$\nThis is the required transformation matrix.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{6} & \\frac{2}{3} & \\frac{1}{6} & 0 \\\\\n0 & \\frac{2}{3} & \\frac{1}{3} & 0 \\\\\n0 & \\frac{1}{3} & \\frac{2}{3} & 0 \\\\\n0 & \\frac{1}{6} & \\frac{2}{3} & \\frac{1}{6}\n\\end{pmatrix}\n}\n$$", "id": "2372217"}, {"introduction": "This practice extends our focus from curves to surfaces and introduces the full power of Non-Uniform Rational B-Splines (NURBS) for modeling complex 3D shapes. You will develop an algorithm to compute the tangent plane at any point on a NURBS surface, a critical operation for geometric analysis, rendering, and simulation. This comprehensive exercise [@problem_id:2372227] requires you to synthesize your knowledge of basis function derivatives, the tensor-product surface definition, and the quotient rule for rational geometry.", "problem": "Design and implement a complete, runnable program that computes the coefficients of the tangent plane to a Non-Uniform Rational B-Spline (NURBS) tensor-product surface at specified parameter values. The solution must be derived from first principles of B-splines and rational surfaces and must not rely on external data or interactivity.\n\nYou must base your derivation and implementation on the following fundamental definitions and facts:\n- The B-spline basis functions of degree $p$ are defined recursively by the Cox–de Boor recursion:\n  - For $p=0$, $N_{i,0}(u) = 1$ if $u \\in [U_i, U_{i+1})$ and $0$ otherwise.\n  - For $p \\ge 1$,\n  $$\n  N_{i,p}(u) = \\frac{u-U_i}{U_{i+p}-U_i} N_{i,p-1}(u) + \\frac{U_{i+p+1}-u}{U_{i+p+1}-U_{i+1}} N_{i+1,p-1}(u),\n  $$\n  with the convention that terms with zero denominators contribute zero.\n- A tensor-product NURBS surface of degrees $p$ and $q$ is defined by control points $\\mathbf{P}_{i,j} \\in \\mathbb{R}^3$, associated nonnegative weights $w_{i,j}$, and knot vectors $U$ and $V$:\n  $$\n  \\mathbf{S}(u,v) = \\frac{\\sum_{i=0}^{n}\\sum_{j=0}^{m} N_{i,p}(u) \\, M_{j,q}(v) \\, w_{i,j} \\, \\mathbf{P}_{i,j}}{\\sum_{i=0}^{n}\\sum_{j=0}^{m} N_{i,p}(u) \\, M_{j,q}(v) \\, w_{i,j}},\n  $$\n  where $M_{j,q}(v)$ are the B-spline basis functions in $v$ with knot vector $V$.\n- The tangent plane at $(u_0,v_0)$ is the plane passing through the surface point $\\mathbf{S}(u_0,v_0)$ with normal vector $\\mathbf{n}(u_0,v_0) = \\mathbf{S}_u(u_0,v_0) \\times \\mathbf{S}_v(u_0,v_0)$, provided $\\|\\mathbf{n}\\| \\ne 0$. The plane coefficients $(a,b,c,d)$ satisfy $a x + b y + c z + d = 0$, with $(a,b,c) = \\mathbf{\\hat n}$ a unit normal and $d = -\\mathbf{\\hat n}\\cdot \\mathbf{S}(u_0,v_0)$.\n\nYou must implement the algorithm to evaluate $\\mathbf{S}(u,v)$ and its first partial derivatives $\\mathbf{S}_u(u,v)$ and $\\mathbf{S}_v(u,v)$ by combining:\n- Derivatives of the non-rational B-spline basis functions (via a principled recursion for basis function derivatives).\n- The quotient rule for rational functions to obtain derivatives of $\\mathbf{S}(u,v)$ from the derivatives of the weighted numerator and weight denominator.\n\nSurface specification to be used in your program:\n- Degrees: $p=q=2$.\n- Knot vectors (open uniform):\n  $$\n  U = [\\,0,\\,0,\\,0,\\,\\tfrac{1}{2},\\,1,\\,1,\\,1\\,], \\quad V = [\\,0,\\,0,\\,0,\\,\\tfrac{1}{2},\\,1,\\,1,\\,1\\,].\n  $$\n- Control net $\\mathbf{P}_{i,j}$ for $i \\in \\{0,1,2,3\\}$ and $j \\in \\{0,1,2,3\\}$ defined procedurally by\n  $$\n  \\mathbf{P}_{i,j} = \\big(i,\\; j,\\; 0.2\\,(i-1.5)^2 + 0.1\\,(j-1.5)^2\\big).\n  $$\n- Weights $w_{i,j}$ defined piecewise by\n  $$\n  w_{i,j} = \\begin{cases}\n  2, & \\text{if } i \\in \\{1,2\\} \\text{ and } j \\in \\{1,2\\},\\\\\n  1, & \\text{otherwise}.\n  \\end{cases}\n  $$\n\nAlgorithmic requirements:\n- Implement robust evaluation of B-spline basis functions and their first derivatives using a span-finding routine and a stable basis derivative algorithm.\n- Evaluate $\\mathbf{S}(u,v)$, $\\mathbf{S}_u(u,v)$, and $\\mathbf{S}_v(u,v)$ by assembling weighted sums over the nonzero basis supports and applying the quotient rule to convert from non-rational to rational derivatives.\n- Compute the unit normal $\\mathbf{\\hat n} = \\frac{\\mathbf{S}_u \\times \\mathbf{S}_v}{\\|\\mathbf{S}_u \\times \\mathbf{S}_v\\|}$ and enforce a deterministic orientation rule to avoid sign ambiguity: if the third component of $\\mathbf{\\hat n}$ is negative, flip the sign of $\\mathbf{\\hat n}$; if it is zero, require the second component to be nonnegative, and if also zero, require the first component to be nonnegative.\n- Compute plane coefficients $(a,b,c,d)$ with $(a,b,c)=\\mathbf{\\hat n}$ and $d=-\\mathbf{\\hat n}\\cdot \\mathbf{S}(u_0,v_0)$.\n- If $\\|\\mathbf{S}_u \\times \\mathbf{S}_v\\|$ is below a small tolerance (e.g., effectively zero), the plane is undefined; in that case, return four Not-a-Number values.\n\nNumerical output requirements:\n- Use the following test suite of parameter pairs $(u,v)$:\n  - Case $1$: $(u,v)=(0.3,\\,0.6)$,\n  - Case $2$: $(u,v)=(0.5,\\,0.5)$,\n  - Case $3$: $(u,v)=(0,\\,0)$,\n  - Case $4$: $(u,v)=(1,\\,1)$.\n- For each case, output the tangent plane coefficients $(a,b,c,d)$ as four floating-point numbers rounded to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list $[a,b,c,d]$ for the corresponding case, with no spaces. For example:\n  $$\n  [ [a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4] ]\n  $$\n  but printed without spaces and with each number rounded to six decimal places, e.g.,\n  $[[0.123456,0.234567,0.945678,-1.234567],[\\dots],\\dots]$.\n\nAngle units are not applicable. There are no physical units. All numerical values must follow the rounding requirement described above. The final program must be self-contained, require no input, and adhere to the specified output format.", "solution": "The problem requires the computation of tangent plane coefficients for a Non-Uniform Rational B-Spline (NURBS) surface at specified parameter values. This is a standard problem in computational geometry and computer-aided design. The solution will be derived from first principles as stipulated.\n\nA tensor-product NURBS surface $\\mathbf{S}(u,v)$ is a rational function defined as:\n$$\n\\mathbf{S}(u,v) = \\frac{\\mathbf{A}(u,v)}{w(u,v)}\n$$\nwhere $\\mathbf{A}(u,v)$ is the weighted sum of control points, and $w(u,v)$ is the sum of weights.\n$$\n\\mathbf{A}(u,v) = \\sum_{i=0}^{n}\\sum_{j=0}^{m} N_{i,p}(u) M_{j,q}(v) w_{i,j} \\mathbf{P}_{i,j}\n$$\n$$\nw(u,v) = \\sum_{i=0}^{n}\\sum_{j=0}^{m} N_{i,p}(u) M_{j,q}(v) w_{i,j}\n$$\nHere, $N_{i,p}(u)$ and $M_{j,q}(v)$ are the B-spline basis functions of degrees $p$ and $q$ over knot vectors $U$ and $V$, respectively. The control points are $\\mathbf{P}_{i,j}$ and weights are $w_{i,j}$.\n\nThe tangent plane at a point $\\mathbf{S}(u_0, v_0)$ is defined by the point itself and a normal vector $\\mathbf{n}$. The normal vector is given by the cross product of the partial derivatives of the surface with respect to its parameters, $\\mathbf{S}_u$ and $\\mathbf{S}_v$.\n$$\n\\mathbf{n}(u,v) = \\mathbf{S}_u(u,v) \\times \\mathbf{S}_v(u,v)\n$$\nThe partial derivatives are found using the quotient rule for vector-valued functions:\n$$\n\\mathbf{S}_u = \\frac{\\partial}{\\partial u} \\left( \\frac{\\mathbf{A}}{w} \\right) = \\frac{\\frac{\\partial \\mathbf{A}}{\\partial u} w - \\mathbf{A} \\frac{\\partial w}{\\partial u}}{w^2} = \\frac{\\mathbf{A}_u w - \\mathbf{A} w_u}{w^2}\n$$\n$$\n\\mathbf{S}_v = \\frac{\\partial}{\\partial v} \\left( \\frac{\\mathbf{A}}{w} \\right) = \\frac{\\frac{\\partial \\mathbf{A}}{\\partial v} w - \\mathbf{A} \\frac{\\partial w}{\\partial v}}{w^2} = \\frac{\\mathbf{A}_v w - \\mathbf{A} w_v}{w^2}\n$$\nThe terms $\\mathbf{A}_u, w_u, \\mathbf{A}_v, w_v$ are the partial derivatives of the non-rational numerator and denominator components:\n$$\n\\mathbf{A}_u(u,v) = \\sum_{i=0}^{n}\\sum_{j=0}^{m} N'_{i,p}(u) M_{j,q}(v) w_{i,j} \\mathbf{P}_{i,j}\n$$\n$$\nw_u(u,v) = \\sum_{i=0}^{n}\\sum_{j=0}^{m} N'_{i,p}(u) M_{j,q}(v) w_{i,j}\n$$\nAnalogous expressions exist for $\\mathbf{A}_v$ and $w_v$ involving the derivative of the basis functions $M'_{j,q}(v)$.\n\nThe derivatives of the B-spline basis functions $N_{i,p}(u)$ are given by the standard formula, which can itself be derived from the Cox-de Boor recursion:\n$$\nN'_{i,p}(u) = \\frac{p}{U_{i+p}-U_i} N_{i,p-1}(u) - \\frac{p}{U_{i+p+1}-U_{i+1}} N_{i+1,p-1}(u)\n$$\nAgain, terms with zero denominators are taken to be zero. This formula shows that derivatives of degree-$p$ basis functions can be computed from values of degree-$(p-1)$ basis functions.\n\nThe algorithmic procedure is as follows:\n1.  **Find Span**: For a given parameter value $u$, find the knot interval $[U_k, U_{k+1})$ in which it lies. The index $k$ is the span. This localizes the computation, as only $p+1$ basis functions are non-zero over this interval.\n2.  **Evaluate Basis Functions and Derivatives**:\n    -   Implement a function to compute the values of all non-zero basis functions $N_{k-p,p}(u), \\dots, N_{k,p}(u)$ of degree $p$ using the Cox-de Boor recursion.\n    -   Implement a function to compute the first derivatives of these basis functions. This function will first call the basis function evaluation routine for degree $p-1$, and then apply the derivative formula stated above.\n3.  **Evaluate Surface Point and Derivatives**: For a given pair $(u,v)$:\n    -   Find the spans for $u$ and $v$ in their respective knot vectors $U$ and $V$.\n    -   Evaluate the basis functions and their first derivatives for both $u$ and $v$ in their relevant spans. This yields arrays of values $\\{N_i(u)\\}, \\{N'_i(u)\\}, \\{M_j(v)\\}, \\{M'_j(v)\\}$.\n    -   Compute the six necessary sums ($\\mathbf{A}, w, \\mathbf{A}_u, w_u, \\mathbf{A}_v, w_v$) by iterating over the local support of the basis functions (i.e., a $(p+1) \\times (q+1)$ block of control points).\n    -   Assemble $\\mathbf{S}(u,v)$, $\\mathbf{S}_u(u,v)$, and $\\mathbf{S}_v(u,v)$ using the quotient rule formulas.\n4.  **Compute Plane Coefficients**:\n    -   Calculate the normal vector $\\mathbf{n} = \\mathbf{S}_u \\times \\mathbf{S}_v$.\n    -   Check if its magnitude $\\|\\mathbf{n}\\|$ is close to zero. If so, the plane is ill-defined.\n    -   Normalize the vector to get the unit normal $\\mathbf{\\hat n} = \\mathbf{n} / \\|\\mathbf{n}\\|$.\n    -   Apply the specified orientation rule to ensure a unique normal vector direction. If $\\hat{n}_z < 0$, flip the vector sign. If $\\hat{n}_z = 0$, ensure $\\hat{n}_y \\ge 0$. If both are zero, ensure $\\hat{n}_x \\ge 0$.\n    -   The plane coefficients are $(a,b,c,d)$, where $(a,b,c) = \\mathbf{\\hat n}$ and $d = -\\mathbf{\\hat n} \\cdot \\mathbf{S}(u,v)$.\n\nThe provided surface is of degree $p=q=2$ with $4 \\times 4$ control points $\\mathbf{P}_{i,j}$ and weights $w_{i,j}$ over open uniform knot vectors $U=V = [0, 0, 0, \\frac{1}{2}, 1, 1, 1]$. The parameter domain is $[0,1] \\times [0,1]$. Special care is taken at the boundaries of the domain ($u,v \\in \\{0,1\\}$) and at the internal knot $u=v=0.5$, though the general algorithm is robust to these cases provided correct implementation of the basis function and derivative formulas, especially the `0/0=0` convention.\n\nThe implementation will follow this principled structure, building from basis function evaluation up to the final plane equation.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define the NURBS surface, compute tangent planes for test cases,\n    and print the results in the specified format.\n    \"\"\"\n\n    # --- Surface Specification ---\n    p = 2  # Degree in u\n    q = 2  # Degree in v\n    U = np.array([0., 0., 0., 0.5, 1., 1., 1.])  # Knot vector in u\n    V = np.array([0., 0., 0., 0.5, 1., 1., 1.])  # Knot vector in v\n\n    n = len(U) - p - 2  # Number of control points in u is n+1 = 4\n    m = len(V) - q - 2  # Number of control points in v is m+1 = 4\n\n    # Procedurally generate control points P_ij\n    P = np.zeros((n + 1, m + 1, 3))\n    for i in range(n + 1):\n        for j in range(m + 1):\n            x = float(i)\n            y = float(j)\n            z = 0.2 * (i - 1.5)**2 + 0.1 * (j - 1.5)**2\n            P[i, j] = [x, y, z]\n\n    # Procedurally generate weights w_ij\n    W = np.ones((n + 1, m + 1))\n    W[1:3, 1:3] = 2.0\n\n    # --- Test Cases ---\n    test_cases = [\n        (0.3, 0.6),\n        (0.5, 0.5),\n        (0.0, 0.0),\n        (1.0, 1.0),\n    ]\n\n    results = []\n    for u_eval, v_eval in test_cases:\n        coeffs = compute_plane_coeffs(u_eval, v_eval, p, q, U, V, P, W)\n        results.append(coeffs)\n\n    # --- Format and Print Output ---\n    result_str_parts = []\n    for res in results:\n        if np.isnan(res[0]):\n            part = '[nan,nan,nan,nan]'\n        else:\n            part = '[' + ','.join([f\"{x:.6f}\" for x in res]) + ']'\n        result_str_parts.append(part)\n    \n    print(f\"[{','.join(result_str_parts)}]\")\n\ndef find_span(u, p, U):\n    \"\"\"\n    Find the knot span index i such that U_i <= u < U_{i+1}.\n    n is the number of control points minus 1.\n    \"\"\"\n    n = len(U) - p - 2\n    if u == U[n + 1]:\n        return n\n    \n    # Binary search for the span\n    low = p\n    high = n + 1\n    mid = (low + high) // 2\n    while u < U[mid] or u >= U[mid + 1]:\n        if u < U[mid]:\n            high = mid\n        else:\n            low = mid\n        mid = (low + high) // 2\n    return mid\n\ndef basis_funs(span, u, p, U):\n    \"\"\"\n    Compute the non-zero B-spline basis functions for a given span.\n    Uses the Cox-de Boor recursion.\n    Returns: A (p+1) element array with N_{span-p,p}(u), ..., N_{span,p}(u)\n    \"\"\"\n    N = np.zeros(p + 1)\n    left = np.zeros(p + 1)\n    right = np.zeros(p + 1)\n    N[0] = 1.0\n\n    for j in range(1, p + 1):\n        left[j] = u - U[span + 1 - j]\n        right[j] = U[span + j] - u\n        saved = 0.0\n        for r in range(j):\n            den = right[r + 1] + left[j - r]\n            temp = 0.0\n            if den != 0.0:\n                temp = N[r] / den\n            N[r] = saved + right[r + 1] * temp\n            saved = left[j - r] * temp\n        N[j] = saved\n    return N\n\ndef ders_basis_funs(span, u, p, U):\n    \"\"\"\n    Compute derivatives of B-spline basis functions.\n    Returns: A (p+1) element array with the first derivatives.\n    \"\"\"\n    if p == 0:\n        return np.zeros(1)\n        \n    N_prev = basis_funs(span, u, p - 1, U)\n    ders = np.zeros(p + 1)\n    \n    for j in range(p + 1):\n        i = span - p + j\n        term1 = 0.0\n        den1 = U[i + p] - U[i]\n        if den1 != 0.0 and j > 0:\n            term1 = N_prev[j - 1] / den1\n\n        term2 = 0.0\n        den2 = U[i + p + 1] - U[i + 1]\n        if den2 != 0.0 and j < p:\n            term2 = N_prev[j] / den2\n        \n        ders[j] = p * (term1 - term2)\n        \n    return ders\n\ndef surface_pt_and_ders(u, v, p, q, U, V, P, W):\n    \"\"\"\n    Computes the surface point S(u,v) and its first partial derivatives S_u, S_v.\n    \"\"\"\n    n = len(U) - p - 2\n    m = len(V) - q - 2\n\n    u_span = find_span(u, p, U)\n    v_span = find_span(v, q, V)\n    \n    Nu = basis_funs(u_span, u, p, U)\n    Nv = basis_funs(v_span, v, q, V)\n    \n    dNu = ders_basis_funs(u_span, u, p, U)\n    dNv = ders_basis_funs(v_span, v, q, V)\n\n    S_num = np.zeros(3)\n    S_den = 0.0\n    Su_num = np.zeros(3)\n    Su_den = 0.0\n    Sv_num = np.zeros(3)\n    Sv_den = 0.0\n\n    for i in range(p + 1):\n        for j in range(q + 1):\n            ii = u_span - p + i\n            jj = v_span - q + j\n            \n            w_ij = W[ii, jj]\n            P_ij = P[ii, jj]\n            \n            temp = Nu[i] * Nv[j] * w_ij\n            S_num += temp * P_ij\n            S_den += temp\n            \n            temp_u = dNu[i] * Nv[j] * w_ij\n            Su_num += temp_u * P_ij\n            Su_den += temp_u\n            \n            temp_v = Nu[i] * dNv[j] * w_ij\n            Sv_num += temp_v * P_ij\n            Sv_den += temp_v\n\n    if S_den == 0.0:\n        return np.full(3, np.nan), np.full(3, np.nan), np.full(3, np.nan)\n\n    S = S_num / S_den\n    Su = (Su_num * S_den - S_num * Su_den) / (S_den**2)\n    Sv = (Sv_num * S_den - S_num * Sv_den) / (S_den**2)\n\n    return S, Su, Sv\n\ndef compute_plane_coeffs(u, v, p, q, U, V, P, W):\n    \"\"\"\n    Computes the tangent plane coefficients (a, b, c, d) for the NURBS surface.\n    \"\"\"\n    S, Su, Sv = surface_pt_and_ders(u, v, p, q, U, V, P, W)\n    if np.any(np.isnan(S)):\n        return [np.nan, np.nan, np.nan, np.nan]\n\n    normal = np.cross(Su, Sv)\n    norm_mag = np.linalg.norm(normal)\n    \n    tolerance = 1e-12\n    if norm_mag < tolerance:\n        return [np.nan, np.nan, np.nan, np.nan]\n\n    n_hat = normal / norm_mag\n\n    # Deterministic orientation rule\n    if n_hat[2] < 0.0:\n        n_hat = -n_hat\n    elif abs(n_hat[2]) < tolerance:\n        if n_hat[1] < 0.0:\n            n_hat = -n_hat\n        elif abs(n_hat[1]) < tolerance:\n            if n_hat[0] < 0.0:\n                n_hat = -n_hat\n    \n    a, b, c = n_hat\n    d = -np.dot(n_hat, S)\n\n    return [a, b, c, d]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2372227"}]}