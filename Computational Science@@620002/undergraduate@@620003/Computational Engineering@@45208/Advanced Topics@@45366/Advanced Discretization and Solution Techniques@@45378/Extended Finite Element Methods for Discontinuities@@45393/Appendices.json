{"hands_on_practices": [{"introduction": "This practice is your first step into the core mechanics of the Extended Finite Element Method (XFEM). You will implement the fundamental Heaviside enrichment function, which allows us to model a jump discontinuity, like a material interface, directly across a finite element without altering the mesh. By constructing this enriched basis function and analyzing its properties, you will gain a concrete understanding of how XFEM introduces new information into the standard finite element approximation [@problem_id:2390842].", "problem": "Implement a complete program that constructs the Heaviside enrichment for a bilinear quadrilateral element in two dimensions as used in the Extended Finite Element Method (XFEM). Start from fundamental definitions for finite element shape functions and a level set representation of a discontinuity. Consider a single isoparametric quadrilateral element occupying the unit square domain $\\Omega_{e} = [0,1] \\times [0,1]$ with four nodes at $\\mathbf{x}_1 = (0,0)$, $\\mathbf{x}_2 = (1,0)$, $\\mathbf{x}_3 = (1,1)$, and $\\mathbf{x}_4 = (0,1)$. The standard bilinear shape functions are\n$$\nN_1(x,y) = (1-x)(1-y),\\quad N_2(x,y) = x(1-y),\\quad N_3(x,y) = xy,\\quad N_4(x,y) = (1-x)y,\n$$\nwhich satisfy the partition of unity $\\sum_{i=1}^{4} N_i(x,y) = 1$ for all $(x,y) \\in \\Omega_{e}$. A material interface is represented implicitly by the level set function $\\phi(\\mathbf{x})$ whose zero isocontour $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x}) = 0\\}$ defines the discontinuity.\n\nDefine the Heaviside function $H(\\phi)$ as\n$$\nH(\\phi) = \\begin{cases}\n+1, & \\phi > 0,\\\\\n0, & \\phi = 0,\\\\\n-1, & \\phi < 0.\n\\end{cases}\n$$\nDefine the Heaviside-enriched basis function for node $i$ as\n$$\n\\psi_i(\\mathbf{x}) = \\begin{cases}\nN_i(\\mathbf{x})\\left(H(\\phi(\\mathbf{x})) - H(\\phi(\\mathbf{x}_i))\\right), & \\text{if the element is cut},\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\nwhere the element is considered cut if $\\min_{j \\in \\{1,2,3,4\\}} \\phi(\\mathbf{x}_j) < 0$ and $\\max_{j \\in \\{1,2,3,4\\}} \\phi(\\mathbf{x}_j) > 0$. This criterion ensures that the enrichment is active only when the discontinuity crosses the element interior. This definition satisfies $\\psi_i(\\mathbf{x}_j) = 0$ for all nodes $j$ and introduces a displacement jump aligned with the sign change of $H(\\phi)$.\n\nYour task is to implement:\n- The level set function $\\phi(\\mathbf{x})$ as specified in the test suite below.\n- The Heaviside function $H(\\phi)$.\n- The enriched basis function $\\psi_i(\\mathbf{x})$ for node $i = 1$.\n- A uniform sampling over $\\Omega_e$ on a grid of $M \\times M$ points with $M = 101$, i.e., $x_k = k/(M-1)$ and $y_\\ell = \\ell/(M-1)$ for $k,\\ell \\in \\{0,1,\\dots,M-1\\}$.\n\nFor each test case below, compute the following quantitative diagnostics for $\\psi_1(\\mathbf{x})$:\n1. $z_{\\text{nodes}}$: the maximum absolute nodal value $\\max_{j \\in \\{1,2,3,4\\}} \\left|\\psi_1(\\mathbf{x}_j)\\right|$. This verifies the vanishing of the enrichment at the nodes.\n2. $z_{\\text{grid}}$: the maximum absolute value over the grid, $\\max_{(x,y)\\in \\mathcal{G}} \\left|\\psi_1(x,y)\\right|$, where $\\mathcal{G}$ is the set of grid points.\n3. $z_{\\text{jump}}$: the approximate jump of $\\psi_1$ across the interface at the element center $\\mathbf{p}_c=(0.5,0.5)$, computed as follows. If $\\left|\\phi(\\mathbf{p}_c)\\right| \\le \\tau$ with tolerance $\\tau = 10^{-12}$, approximate the jump by\n$$\nz_{\\text{jump}} \\approx \\psi_1(\\mathbf{p}_c + \\varepsilon \\mathbf{n}) - \\psi_1(\\mathbf{p}_c - \\varepsilon \\mathbf{n}),\n$$\nwhere $\\mathbf{n} = \\nabla \\phi(\\mathbf{p}_c)/\\|\\nabla \\phi(\\mathbf{p}_c)\\|$ is the unit normal computed by central finite differences with step $h = 10^{-8}$, and $\\varepsilon = 10^{-6}$. If $\\left|\\phi(\\mathbf{p}_c)\\right| > \\tau$, set $z_{\\text{jump}} = 0$.\n4. $z_{\\text{L2}}$: a discrete approximation to the $L^2$ norm of $\\psi_1$ over the element,\n$$\nz_{\\text{L2}} \\approx \\left(\\sum_{(x,y) \\in \\mathcal{G}} \\psi_1(x,y)^2 \\,\\Delta x \\,\\Delta y \\right)^{1/2},\n$$\nwith $\\Delta x = \\Delta y = 1/(M-1)$.\n\nTest suite (use node index $i=1$ in all cases):\n- Case A (interior cut through the center): $\\phi(x,y) = x + y - 1$.\n- Case B (boundary-aligned zero level set, no interior cut): $\\phi(x,y) = x$.\n- Case C (no cut anywhere): $\\phi(x,y) = x + y + 1$.\n\nScientific realism: The definitions above are standard in the Extended Finite Element Method (XFEM), and the grid-based diagnostics serve as a numerical surrogate for visualization by characterizing the magnitude and jump of the enriched basis over the element.\n\nYour program must output a single line containing a list of results, one list per test case, in the exact format\n$[ [z_{\\text{nodes}}^{(A)}, z_{\\text{grid}}^{(A)}, z_{\\text{jump}}^{(A)}, z_{\\text{L2}}^{(A)}], [z_{\\text{nodes}}^{(B)}, z_{\\text{grid}}^{(B)}, z_{\\text{jump}}^{(B)}, z_{\\text{L2}}^{(B)}], [z_{\\text{nodes}}^{(C)}, z_{\\text{grid}}^{(C)}, z_{\\text{jump}}^{(C)}, z_{\\text{L2}}^{(C)} ] ]$ with each number rounded to six decimal places. No physical units are used in this problem. Angles are not used. The output must be a single line without any additional text.", "solution": "The user has submitted a problem statement for validation and solution.\n\n### Step 1: Extract Givens\n- **Domain**: A two-dimensional bilinear isoparametric quadrilateral element $\\Omega_{e}$ defined by the unit square $[0,1] \\times [0,1]$.\n- **Nodes**: Four nodes at coordinates $\\mathbf{x}_1 = (0,0)$, $\\mathbf{x}_2 = (1,0)$, $\\mathbf{x}_3 = (1,1)$, and $\\mathbf{x}_4 = (0,1)$.\n- **Standard Basis Functions**: The standard bilinear shape functions are $N_1(x,y) = (1-x)(1-y)$, $N_2(x,y) = x(1-y)$, $N_3(x,y) = xy$, and $N_4(x,y) = (1-x)y$.\n- **Discontinuity Representation**: A level set function $\\phi(\\mathbf{x})$ is used, with the discontinuity defined by the zero isocontour $\\phi(\\mathbf{x}) = 0$.\n- **Heaviside Function**: The Heaviside function is defined as $H(\\phi) = +1$ for $\\phi > 0$, $H(\\phi) = -1$ for $\\phi < 0$, and $H(\\phi) = 0$ for $\\phi = 0$.\n- **Enriched Basis Function**: The Heaviside-enriched basis function for node $i$ is $\\psi_i(\\mathbf{x}) = N_i(\\mathbf{x})\\left(H(\\phi(\\mathbf{x})) - H(\\phi(\\mathbf{x}_i))\\right)$ if the element is cut, and $\\psi_i(\\mathbf{x})=0$ otherwise.\n- **Cut Element Criterion**: An element is considered cut if the level set function has both positive and negative values at its nodes, i.e., $\\min_{j} \\phi(\\mathbf{x}_j) < 0$ and $\\max_{j} \\phi(\\mathbf{x}_j) > 0$.\n- **Task Specifics**: The implementation must focus on the enrichment for node $i=1$.\n- **Numerical Grid**: The domain $\\Omega_e$ is to be discretized into a uniform grid of $M \\times M$ points, with $M=101$.\n- **Diagnostic Quantities for $\\psi_1(\\mathbf{x})$**:\n    1. $z_{\\text{nodes}} = \\max_{j \\in \\{1,2,3,4\\}} \\left|\\psi_1(\\mathbf{x}_j)\\right|$.\n    2. $z_{\\text{grid}} = \\max_{(x,y)\\in \\mathcal{G}} \\left|\\psi_1(x,y)\\right|$, over the grid $\\mathcal{G}$.\n    3. $z_{\\text{jump}}$: An approximation of the jump at the element center $\\mathbf{p}_c=(0.5,0.5)$. It is non-zero only if $|\\phi(\\mathbf{p}_c)| \\le \\tau=10^{-12}$. The jump is computed as $\\psi_1(\\mathbf{p}_c + \\varepsilon \\mathbf{n}) - \\psi_1(\\mathbf{p}_c - \\varepsilon \\mathbf{n})$, with $\\varepsilon = 10^{-6}$ and $\\mathbf{n}$ being the normalized gradient of $\\phi$ at $\\mathbf{p}_c$. The gradient is computed via central differences with step size $h=10^{-8}$.\n    4. $z_{\\text{L2}}$: A discrete $L^2$ norm, $z_{\\text{L2}} \\approx \\left(\\sum_{(x,y) \\in \\mathcal{G}} \\psi_1(x,y)^2 \\,\\Delta x \\,\\Delta y \\right)^{1/2}$, with grid spacing $\\Delta x = \\Delta y = 1/(M-1)$.\n- **Test Suite**:\n    - Case A: $\\phi(x,y) = x + y - 1$ (Interior cut).\n    - Case B: $\\phi(x,y) = x$ (Boundary-aligned, no interior cut).\n    - Case C: $\\phi(x,y) = x + y + 1$ (No cut).\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is subjected to rigorous validation.\n1.  **Scientific Grounding**: The problem is firmly rooted in the established principles of the Extended Finite Element Method (XFEM), a standard technique in computational mechanics for modeling problems with discontinuities. The definitions of the level set, Heaviside enrichment, and basis functions are canonical.\n2.  **Well-Posedness**: The problem is a well-defined computational task. All functions, parameters, and test cases are specified unambiguously, ensuring that a unique set of numerical results can be determined.\n3.  **Objectivity**: The language is objective and mathematical. No subjective interpretations are required.\n4.  **Completeness and Consistency**: The problem is self-contained. All necessary information is provided. The definitions are internally consistent; for instance, the enriched basis function $\\psi_i(\\mathbf{x})$ is constructed to be zero at all nodal locations $\\mathbf{x}_j$ by design, a property which the diagnostic $z_{\\text{nodes}}$ is intended to verify.\n5.  **Feasibility**: The required calculations are computationally feasible and standard for numerical analysis.\n\nAll criteria for a valid problem are met. There are no scientific, logical, or structural flaws.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n---\n\n### Principle-Based Design of the Solution\n\nThe objective is to implement and analyze a Heaviside-enriched basis function $\\psi_1(\\mathbf{x})$ for a bilinear quadrilateral element. This is a fundamental component of the Extended Finite Element Method (XFEM), which enriches the standard polynomial approximation space of the Finite Element Method (FEM) to model discontinuities without requiring the mesh to conform to the discontinuity geometry.\n\nThe algorithmic design proceeds directly from the definitions provided.\n\n**1. Element and Basis Function Definition**\nThe foundation is the standard bilinear element on the unit square $\\Omega_e = [0,1] \\times [0,1]$. The shape function for node $1$ (at the origin $(0,0)$) is $N_1(x,y) = (1-x)(1-y)$. The Heaviside function $H(\\phi)$ is implemented as the signum function, which maps positive, negative, and zero values of the level set function $\\phi$ to $+1$, $-1$, and $0$ respectively.\n\n**2. Enrichment Activation**\nThe core idea of XFEM is to apply enrichment only to elements that are actually intersected by the discontinuity. This is determined by the `cut element criterion`. The algorithm first evaluates the level set function $\\phi(\\mathbf{x})$ at the four element nodes $\\mathbf{x}_j$. If the signs of $\\phi(\\mathbf{x}_j)$ are not all the same (and not all zero), specifically if $\\min_j \\phi(\\mathbf{x}_j) < 0$ and $\\max_j \\phi(\\mathbf{x}_j) > 0$, the element is flagged as 'cut'. For all other cases (e.g., the discontinuity lies outside the element or is tangent at a boundary without crossing), the enrichment is inactive, and the enriched basis function $\\psi_1(\\mathbf{x})$ is identically zero throughout the element.\n\n**3. Construction of the Enriched Basis Function $\\psi_1(\\mathbf{x})$**\nIf the element is cut, the enriched basis function for node $1$ is constructed as:\n$$\n\\psi_1(\\mathbf{x}) = N_1(\\mathbf{x}) \\left( H(\\phi(\\mathbf{x})) - H(\\phi(\\mathbf{x}_1)) \\right)\n$$\nHere, $H(\\phi(\\mathbf{x}_1))$ is a constant scalar value determined by the sign of the level set at node $1$. The term $H(\\phi(\\mathbf{x}))$ varies spatially across the element, creating the desired jump. The product with the shape function $N_1(\\mathbf{x})$ ensures that the enrichment is localized and that its influence vanishes at a distance from node $1$. Crucially, this formulation guarantees $\\psi_1(\\mathbf{x}_j) = 0$ at all nodes $j=1,2,3,4$, since for $j \\neq 1$, $N_1(\\mathbf{x}_j)=0$, and for $j=1$, the term in parenthesis becomes zero.\n\n**4. Computation of Diagnostics**\nThe four diagnostics serve to characterize the behavior of $\\psi_1(\\mathbf{x})$.\n- $z_{\\text{nodes}}$: This verifies the theoretical property that $\\psi_1(\\mathbf{x})$ vanishes at all nodes. It is computed by evaluating $|\\psi_1(\\mathbf{x}_j)|$ at each of the four nodes and finding the maximum. The expected result is always $0$.\n- $z_{\\text{grid}}$: This measures the maximum amplitude of the enrichment function over the element. It is found by evaluating $|\\psi_1(x,y)|$ on a fine grid of $101 \\times 101$ points and identifying the maximum value.\n- $z_{\\text{jump}}$: This diagnostic quantifies the magnitude of the jump in the function $\\psi_1$ across the discontinuity line $\\phi=0$, specifically near the element center $\\mathbf{p}_c=(0.5,0.5)$. If the discontinuity does not pass through the center (i.e., $|\\phi(\\mathbf{p}_c)| > \\tau$), the jump is defined as $0$. Otherwise, the normal vector $\\mathbf{n}$ to the discontinuity is approximated using central finite differences on $\\phi$. The jump is then computed by sampling $\\psi_1$ at two points $\\mathbf{p}_c \\pm \\varepsilon\\mathbf{n}$ straddling the interface and taking their difference. For a Heaviside enrichment, the jump in $\\psi_1$ across the interface is expected to be approximately $N_1(\\mathbf{x}) \\times (H(\\phi>0) - H(\\phi<0)) = N_1(\\mathbf{x}) \\times (1 - (-1)) = 2 N_1(\\mathbf{x})$. At the center, this predicts a jump of $2 \\times N_1(0.5,0.5) = 2 \\times 0.25 = 0.5$.\n- $z_{\\text{L2}}$: This calculates the energy of the enrichment function. It is approximated by a discrete sum over the grid points, which corresponds to a numerical quadrature (Riemann sum) of the integral $\\int_{\\Omega_e} \\psi_1(x,y)^2 \\, dA$.\n\n**5. Analysis of Test Cases**\n- **Case A ($\\phi = x+y-1$):** Nodal values of $\\phi$ are $\\{-1, 0, 1, 0\\}$. Since negative and positive values exist, the element is cut. All diagnostics are expected to be non-zero (except $z_{\\text{nodes}}$). The interface passes through the center, so $z_{\\text{jump}}$ will be calculated and should be close to $0.5$.\n- **Case B ($\\phi = x$):** Nodal values are $\\{0, 1, 1, 0\\}$. Since $\\min_j \\phi(\\mathbf{x}_j)$ is not less than $0$, the `cut` criterion is not met. The enrichment is inactive, and $\\psi_1(\\mathbf{x})=0$. All diagnostics will be $0$.\n- **Case C ($\\phi = x+y+1$):** Nodal values are $\\{1, 2, 3, 2\\}$. All values are positive. The element is not cut. All diagnostics will be $0$.\n\nThis systematic procedure allows for a robust and correct implementation of the specified XFEM construct and its numerical analysis.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and evaluates a Heaviside-enriched basis function for a bilinear\n    quadrilateral element in XFEM.\n    \"\"\"\n\n    test_cases = [\n        {'name': 'A', 'phi': lambda x, y: x + y - 1},\n        {'name': 'B', 'phi': lambda x, y: x},\n        {'name': 'C', 'phi': lambda x, y: x + y + 1},\n    ]\n\n    all_results = []\n\n    M = 101\n    tau = 1e-12\n    h_grad = 1e-8\n    epsilon_jump = 1e-6\n    \n    nodes = np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]])\n    node_of_interest_idx = 0  # Node 1 is at index 0\n\n    x_grid_vals = np.linspace(0.0, 1.0, M)\n    y_grid_vals = np.linspace(0.0, 1.0, M)\n    xx, yy = np.meshgrid(x_grid_vals, y_grid_vals, indexing='xy')\n    dx = 1.0 / (M - 1)\n    dy = 1.0 / (M - 1)\n\n    def N1_func(x, y):\n        return (1.0 - x) * (1.0 - y)\n\n    def H_func(val):\n        return np.sign(val)\n\n    for case in test_cases:\n        phi_func = case['phi']\n\n        # Determine if the element is cut\n        phi_at_nodes = np.array([phi_func(n[0], n[1]) for n in nodes])\n        is_cut = np.min(phi_at_nodes) < 0 and np.max(phi_at_nodes) > 0\n\n        # Pre-calculate values for the enriched basis function psi_1\n        phi_at_node1 = phi_at_nodes[node_of_interest_idx]\n        H_phi_at_node1 = H_func(phi_at_node1)\n\n        # --- Define psi_1 for pointwise and grid evaluation ---\n        \n        # Pointwise function for z_jump calculation\n        def psi_1_pointwise(x, y):\n            if not is_cut:\n                return 0.0\n            phi_val = phi_func(x, y)\n            H_phi_val = H_func(phi_val)\n            return N1_func(x, y) * (H_phi_val - H_phi_at_node1)\n\n        # Vectorized grid evaluation for z_grid and z_L2\n        if not is_cut:\n            psi_grid = np.zeros_like(xx)\n        else:\n            phi_grid = phi_func(xx, yy)\n            H_phi_grid = H_func(phi_grid)\n            N1_grid = N1_func(xx, yy)\n            psi_grid = N1_grid * (H_phi_grid - H_phi_at_node1)\n\n        # --- Compute diagnostics ---\n\n        # 1. z_nodes\n        psi_at_nodes = np.array([psi_1_pointwise(n[0], n[1]) for n in nodes])\n        z_nodes = np.max(np.abs(psi_at_nodes))\n\n        # 2. z_grid\n        z_grid = np.max(np.abs(psi_grid))\n\n        # 3. z_jump\n        pc = np.array([0.5, 0.5])\n        phi_at_pc = phi_func(pc[0], pc[1])\n        \n        if np.abs(phi_at_pc) > tau or not is_cut:\n            z_jump = 0.0\n        else:\n            # Gradient by central finite differences\n            dphi_dx = (phi_func(pc[0] + h_grad, pc[1]) - phi_func(pc[0] - h_grad, pc[1])) / (2 * h_grad)\n            dphi_dy = (phi_func(pc[0], pc[1] + h_grad) - phi_func(pc[0], pc[1] - h_grad)) / (2 * h_grad)\n            grad_phi = np.array([dphi_dx, dphi_dy])\n            \n            norm_grad = np.linalg.norm(grad_phi)\n            if norm_grad < 1e-15: # Avoid division by zero\n                 n_vec = np.array([0.0, 0.0])\n            else:\n                 n_vec = grad_phi / norm_grad\n            \n            p_plus = pc + epsilon_jump * n_vec\n            p_minus = pc - epsilon_jump * n_vec\n            \n            psi_plus = psi_1_pointwise(p_plus[0], p_plus[1])\n            psi_minus = psi_1_pointwise(p_minus[0], p_minus[1])\n            \n            z_jump = psi_plus - psi_minus\n\n        # 4. z_L2\n        z_L2 = np.sqrt(np.sum(psi_grid**2) * dx * dy)\n\n        all_results.append([z_nodes, z_grid, z_jump, z_L2])\n\n    # Format the final output string as specified in the problem\n    formatted_cases = []\n    for case_result in all_results:\n        formatted_numbers = ', '.join([f'{num:.6f}' for num in case_result])\n        formatted_cases.append(f'[{formatted_numbers}]')\n    \n    final_string = f\"[{', '.join(formatted_cases)}]\"\n    print(final_string)\n\nsolve()\n```", "id": "2390842"}, {"introduction": "Building on the concept of enrichment, this exercise tackles a critical question in practical XFEM implementations: how do we automatically identify which elements need special treatment? You will develop a robust algorithm to classify elements based on their position relative to a crack, distinguishing between standard elements, those crossed by the crack body (Heaviside-enriched), and those containing the crack tip (tip-enriched). This practice focuses on the geometric logic and level-set data that drive the entire XFEM procedure for fracture mechanics [@problem_id:2551522].", "problem": "You are given a convex quadrilateral two-dimensional finite element with nodes indexed $i \\in \\{0,1,2,3\\}$ in counterclockwise order. Let $\\phi(\\mathbf{x})$ and $\\psi(\\mathbf{x})$ be two level-set fields used to represent a crack as follows: the crack surface is the zero-isocontour $\\{\\mathbf{x} : \\phi(\\mathbf{x}) = 0\\}$ and the crack tip is the intersection of zero-isocontours $\\{\\mathbf{x} : \\phi(\\mathbf{x}) = 0\\} \\cap \\{\\mathbf{x} : \\psi(\\mathbf{x}) = 0\\}$. Assume that within each element, the level sets are linearly interpolated along each edge from their nodal values. Your task is to derive, justify, and implement a robust classification criterion that assigns each element to one of three disjoint sets used in the extended finite element method: tip-enriched, Heaviside-enriched, or standard.\n\nFundamental base and admissible assumptions:\n- The extended finite element method (XFEM) employs the partition of unity method (PUM) to enrich the approximation space near discontinuities. The crack interior is represented using a Heaviside function enrichment, and the crack tip is represented using functions reflecting the asymptotic near-tip fields.\n- A linearly interpolated scalar field on a straight edge is strictly monotone if its nodal values have opposite signs, hence it has exactly one zero on that edge. If both nodal values have the same nonzero sign, it has no zero on that edge. If one nodal value is zero, the zero-isocontour passes through that node. These statements hold regardless of element anisotropy.\n- Let $\\tau$ denote a small tolerance with $\\tau = 10^{-12}$ used to decide when a floating-point value is considered to be zero.\n\nTask 1: From these bases, formulate a criterion using only the nodal coordinates $\\{(x_i,y_i)\\}_{i=0}^3$ and nodal level-set values $\\{(\\phi_i,\\psi_i)\\}_{i=0}^3$ that classifies an element as:\n- Tip-enriched if and only if the zero-isocontours of $\\phi$ and $\\psi$ intersect within the closed element, i.e., their intersection lies in the polygon including its boundary. In addition, if there exists a node $k$ such that $|\\phi_k| \\le \\tau$ and $|\\psi_k| \\le \\tau$, the element must be classified as tip-enriched.\n- Heaviside-enriched if and only if the zero-isocontour of $\\phi$ crosses the element but the element is not tip-enriched.\n- Standard otherwise.\n\nYour criterion must be derived from first principles of level-set interpolation along edges. Concretely, along each edge $(i,j)$, use the signs of the nodal values to identify whether $\\ell \\in \\{\\phi,\\psi\\}$ changes sign, and if so, compute the unique zero-crossing point by linear interpolation using\n$$\nt = \\frac{\\ell_i}{\\ell_i - \\ell_j}, \\qquad \\mathbf{p}_{\\ell,ij} = (1-t)\\,\\mathbf{x}_i + t\\,\\mathbf{x}_j,\n$$\nwhenever $\\ell_i \\cdot \\ell_j < 0$, and treat $\\ell_i = 0$ or $\\ell_j = 0$ (within tolerance $\\tau$) as a zero at the corresponding node. Use the set of all zero points on the element boundary for $\\phi$ to produce a single line segment approximating $\\{\\mathbf{x}:\\phi(\\mathbf{x})=0\\}$ within the element by connecting two distinct boundary zero points that are farthest apart (if fewer than two distinct points exist, then the zero-isocontour does not cross the element). Do the same for $\\psi$. Declare “tip-enriched” if and only if the resulting $\\phi$-segment and $\\psi$-segment intersect within the closed element or if there exists a node with both $\\phi$ and $\\psi$ equal to zero within tolerance $\\tau$. Declare “Heaviside-enriched” if and only if the $\\phi$-segment exists but the element is not tip-enriched. Otherwise, declare “standard.”\n\nTask 2: Justify that this edge-based, sign-change and interpolation-based criterion is robust under mesh anisotropy by appealing only to the fundamental bases above. In particular, argue that sign-change detection and linear interpolation along edges are invariant to element stretching and skewing and that the segment-intersection logic depends only on the geometry of zero crossings on the boundary.\n\nTask 3: Implement a program that applies your classification to the following test suite. Each test case provides nodal coordinates $(x_i,y_i)$ and nodal level sets $(\\phi_i,\\psi_i)$ in the fixed node order $i=0,1,2,3$.\n\n- Test case $1$ (Heaviside-enriched, “happy path”):\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,1\\,,\\,0\\,), (\\,1\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ -1, 1, 1, -1 ]$\n  - $\\psi_i = [ 2, 2, 2, 2 ]$\n\n- Test case $2$ (Tip-enriched, interior intersection):\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,1\\,,\\,0\\,), (\\,1\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ -0.5, 0.5, 0.5, -0.5 ]$\n  - $\\psi_i = [ -0.5, -0.5, 0.5, 0.5 ]$\n\n- Test case $3$ (Standard, no crack crossing):\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,1\\,,\\,0\\,), (\\,1\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ -1, -1, -1, -1 ]$\n  - $\\psi_i = [ -1, -1, -1, -1 ]$\n\n- Test case $4$ (Tip-enriched, degenerate tip at a node):\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,1\\,,\\,0\\,), (\\,1\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ 0, 1, 1, 0 ]$\n  - $\\psi_i = [ 0, 0, 1, 1 ]$\n\n- Test case $5$ (Heaviside-enriched, anisotropic rectangle):\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,10\\,,\\,0\\,), (\\,10\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ -5, 5, 5, -5 ]$\n  - $\\psi_i = [ 1, 1, 1, 1 ]$\n\n- Test case $6$ (Heaviside-enriched, both isocontours cross but do not intersect within the element):\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,1\\,,\\,0\\,), (\\,1\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ -0.5, 0.5, 0.5, -0.5 ]$\n  - $\\psi_i = [ -0.4, 0.6, 1.6, 0.6 ]$\n\nUse the following integer codes for classification: tip-enriched $\\to 2$, Heaviside-enriched $\\to 1$, standard $\\to 0$. Your program must process all test cases using the general criterion above and produce exactly one line of output containing the results as a comma-separated list enclosed in square brackets, for example $[a_1,a_2,\\dots,a_6]$, where each $a_k$ is the integer code for test case $k$ in order. No units or angles are involved in this problem, and no external input is required. Use tolerance $\\tau = 10^{-12}$ for zero tests and geometric predicates when needed.", "solution": "The task is to formulate, justify, and implement a robust criterion for classifying a two-dimensional quadrilateral finite element for use in the extended finite element method (XFEM). The classification depends on the element's relationship with a crack represented by two level-set functions, $\\phi(\\mathbf{x})$ and $\\psi(\\mathbf{x})$. The element must be categorized as tip-enriched, Heaviside-enriched, or standard, based solely on the nodal coordinates $\\{\\mathbf{x}_i\\}_{i=0}^3$ and the nodal values of the level-set functions $\\{(\\phi_i, \\psi_i)\\}_{i=0}^3$.\n\nThe derivation proceeds from first principles, adhering to the provided assumptions regarding linear interpolation of the level-set fields along element edges. The final algorithm is constructed in three stages: identification of boundary zero-crossings, approximation of the isocontours, and application of the classification logic.\n\n**1. Criterion Derivation**\n\n**Step 1.1: Identification of Boundary Zero-Crossings**\nLet $\\ell(\\mathbf{x})$ represent either the $\\phi(\\mathbf{x})$ or $\\psi(\\mathbf{x})$ level-set field. Within the element, the true isocontour $\\{\\mathbf{x} : \\ell(\\mathbf{x})=0\\}$ is unknown. However, its intersections with the element boundary can be determined precisely under the assumption of linear interpolation along edges. We examine each of the four edges of the quadrilateral, denoted by the node pairs $(0,1)$, $(1,2)$, $(2,3)$, and $(3,0)$. For an arbitrary edge connecting nodes $i$ and $j$ with coordinates $\\mathbf{x}_i$ and $\\mathbf{x}_j$, and nodal level-set values $\\ell_i$ and $\\ell_j$:\n\n- If a nodal value is zero within a given tolerance $\\tau$, i.e., $|\\ell_k| \\le \\tau$ for $k \\in \\{i, j\\}$, the isocontour passes through that node $\\mathbf{x}_k$.\n- If the nodal values have opposite signs, i.e., $\\ell_i \\cdot \\ell_j < 0$, the linear interpolant must have exactly one zero on the interior of the edge. The position of this zero-crossing is found by solving $\\ell(t) = (1-t)\\ell_i + t\\ell_j = 0$ for the parameter $t \\in (0,1)$. This gives $t = \\ell_i / (\\ell_i - \\ell_j)$. The corresponding coordinate is $\\mathbf{p}_{\\ell,ij} = (1-t)\\mathbf{x}_i + t\\mathbf{x}_j$.\n- If the nodal values have the same sign and are non-zero, i.e., $\\ell_i \\cdot \\ell_j > 0$, the isocontour does not cross that edge.\n\nBy applying this logic to all four edges for both $\\phi$ and $\\psi$, we generate two sets of unique boundary zero-crossing points, $Z_\\phi$ and $Z_\\psi$.\n\n**Step 1.2: Construction of Linear Isocontour Approximations**\nThe set of boundary points $Z_\\ell$ represents the discrete intersections of the isocontour $\\{\\mathbf{x} : \\ell(\\mathbf{x})=0\\}$ with the element boundary. To approximate the path of the isocontour across the element's interior, we connect two of these points. As stipulated, if the set $Z_\\ell$ contains fewer than two distinct points, the isocontour is considered not to cross the element, and no segment is formed. If $|Z_\\ell| \\ge 2$, we construct a single line segment by identifying the pair of points $\\{\\mathbf{p}_{\\ell,1}, \\mathbf{p}_{\\ell,2}\\} \\subseteq Z_\\ell$ that are separated by the maximum Euclidean distance:\n$$\n(\\mathbf{p}_{\\ell,1}, \\mathbf{p}_{\\ell,2}) = \\arg\\max_{\\mathbf{p}_a, \\mathbf{p}_b \\in Z_\\ell} \\|\\mathbf{p}_a - \\mathbf{p}_b\\|_2\n$$\nThis procedure yields a $\\phi$-segment, $S_\\phi$, connecting $\\mathbf{p}_{\\phi,1}$ and $\\mathbf{p}_{\\phi,2}$, and a $\\psi$-segment, $S_\\psi$, connecting $\\mathbf{p}_{\\psi,1}$ and $\\mathbf{p}_{\\psi,2}$, provided their respective sets of zero-crossings contain at least two points.\n\n**Step 1.3: Classification Algorithm**\nWith the necessary geometric constructs in place, the element is classified according to the following hierarchical criteria:\n\n1.  **Tip-Enriched (Code 2):** An element is classified as tip-enriched if the crack tip lies within its domain (including the boundary). This is determined by satisfying either of two conditions:\n    a. **Nodal Tip:** There exists a node $k \\in \\{0,1,2,3\\}$ where both level-set functions are simultaneously zero within the tolerance $\\tau$: $|\\phi_k| \\le \\tau$ and $|\\psi_k| \\le \\tau$. This represents a crack tip located exactly at a node.\n    b. **Interior Tip:** If the nodal tip condition is not met, we check if the approximated isocontours intersect. If both the $\\phi$-segment $S_\\phi$ and the $\\psi$-segment $S_\\psi$ exist, and they intersect ($S_\\phi \\cap S_\\psi \\neq \\emptyset$), the element is tip-enriched. This requires a standard computational geometry algorithm for line segment intersection.\n\n2.  **Heaviside-Enriched (Code 1):** If the element is not classified as tip-enriched, it is checked for enrichment with the discontinuous Heaviside function. This is appropriate if the crack body passes through the element, but the tip does not. This condition is met if and only if the $\\phi$-isocontour crosses the element, which is true if the set of boundary crossings $Z_\\phi$ contains at least two distinct points (i.e., the segment $S_\\phi$ exists).\n\n3.  **Standard (Code 0):** If an element is neither tip-enriched nor Heaviside-enriched, it is a standard, unenriched element. This occurs when the $\\phi$-isocontour does not cross the element boundary at two or more distinct points.\n\n**2. Justification of Robustness**\n\nThe proposed criterion is robust with respect to mesh anisotropy (i.e., element stretching and skewing) because its fundamental operations are invariant under affine transformations.\n\nAn affine transformation $T(\\mathbf{x}) = A\\mathbf{x} + \\mathbf{b}$, where $A$ is an invertible matrix and $\\mathbf{b}$ is a translation vector, maps lines to lines and preserves parallelism and ratios of distances along a line. A general convex quadrilateral will be mapped to another convex quadrilateral.\n\n1.  **Sign-Change Detection:** The first step, detecting a sign change of a level-set function between two nodes, is a purely topological operation. It depends only on the scalar values $\\ell_i$ and $\\ell_j$, which are invariant under a transformation of the coordinate system. Thus, the existence of a zero-crossing on an edge is independent of element geometry.\n\n2.  **Linear Interpolation:** The calculation of the interpolation parameter $t = \\ell_i/(\\ell_i - \\ell_j)$ depends only on the scalar level-set values and is therefore invariant. The location of the zero-crossing is a convex combination of the nodal coordinates, $\\mathbf{p} = (1-t)\\mathbf{x}_i + t\\mathbf{x}_j$. If the element undergoes an affine transformation $T$, the new nodal coordinates are $\\mathbf{x}'_i = T(\\mathbf{x}_i)$ and $\\mathbf{x}'_j = T(\\mathbf{x}_j)$. The new zero-crossing point is:\n    $$\n    \\mathbf{p}' = (1-t)\\mathbf{x}'_i + t\\mathbf{x}'_j = (1-t)T(\\mathbf{x}_i) + tT(\\mathbf{x}_j) = T((1-t)\\mathbf{x}_i + t\\mathbf{x}_j) = T(\\mathbf{p})\n    $$\n    This demonstrates that the zero-crossing point on the transformed edge is simply the transformation of the original zero-crossing point. The relative position of the crossing along the edge is preserved.\n\n3.  **Segment Construction and Intersection:** The subsequent steps—identifying the farthest pair of points and checking for segment intersection—are purely geometric procedures. Since an affine transformation maps the set of boundary zero-crossings $Z_\\ell$ to a new set $Z'_\\ell = \\{T(\\mathbf{p}) : \\mathbf{p} \\in Z_\\ell\\}$, and since affine maps do not preserve distances in general, the choice of the \"farthest\" pair might change. However, for a convex quadrilateral, the linear approximation of an isocontour typically crosses two edges, resulting in $|Z_\\ell| = 2$. In this common and stable case, the choice of segment endpoints is unique and thus its transformation is also unique. Even with more crossings, the intersection test itself is based on orientation predicates (collinearity and turning direction), which are preserved under affine transformations. If two segments intersect, their transformed versions will also intersect.\n\nTherefore, the entire classification logic, being built upon affine-invariant operations, is robust and yields consistent results for elements of arbitrary shape, including those with high aspect ratios or skewness.", "answer": "```python\nimport numpy as np\n\n# Geometric helper functions with a tolerance for floating-point comparisons\n_GEOM_TOL = 1e-9\n\ndef orientation(p, q, r):\n    \"\"\"\n    Computes the orientation of the ordered triplet (p, q, r).\n    Returns:\n     > 0 for counter-clockwise\n     < 0 for clockwise\n     = 0 for collinear\n    \"\"\"\n    val = (q[1] - p[1]) * (r[0] - q[0]) - \\\n          (q[0] - p[0]) * (r[1] - q[1])\n    if abs(val) < _GEOM_TOL:\n        return 0\n    return 1 if val > 0 else -1\n\ndef on_segment(p, q, r):\n    \"\"\"Given three collinear points p, q, r, checks if q lies on segment pr.\"\"\"\n    return (q[0] <= max(p[0], r[0]) + _GEOM_TOL and q[0] >= min(p[0], r[0]) - _GEOM_TOL and\n            q[1] <= max(p[1], r[1]) + _GEOM_TOL and q[1] >= min(p[1], r[1]) - _GEOM_TOL)\n\ndef segments_intersect(seg1, seg2):\n    \"\"\"Checks if two segments, seg1=(p1, q1) and seg2=(p2, q2), intersect.\"\"\"\n    p1, q1 = seg1\n    p2, q2 = seg2\n\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case: segments cross each other\n    if o1 != 0 and o2 != 0 and o3 != 0 and o4 != 0:\n        if o1 != o2 and o3 != o4:\n            return True\n\n    # Special Cases for collinearity\n    if o1 == 0 and on_segment(p1, p2, q1): return True\n    if o2 == 0 and on_segment(p1, q2, q1): return True\n    if o3 == 0 and on_segment(p2, p1, q2): return True\n    if o4 == 0 and on_segment(p2, q1, q2): return True\n\n    return False\n\ndef classify_element(coords, phi_vals, psi_vals, tau):\n    \"\"\"\n    Classifies an element as standard (0), Heaviside-enriched (1), or tip-enriched (2).\n    \"\"\"\n    coords = np.array(coords, dtype=float)\n    phi_vals = np.array(phi_vals, dtype=float)\n    psi_vals = np.array(psi_vals, dtype=float)\n\n    # Primary Criterion: Check for tip located at a node\n    for i in range(4):\n        if abs(phi_vals[i]) <= tau and abs(psi_vals[i]) <= tau:\n            return 2  # Tip-enriched\n\n    def find_zeros(ls_vals):\n        points = []\n        # Check nodes for zero value\n        for i in range(4):\n            if abs(ls_vals[i]) <= tau:\n                points.append(coords[i])\n        \n        # Check edges for sign change\n        for i in range(4):\n            j = (i + 1) % 4\n            val_i, val_j = ls_vals[i], ls_vals[j]\n            if val_i * val_j < 0:\n                # Denominator is non-zero if signs are strictly opposite\n                t = val_i / (val_i - val_j)\n                p_ij = (1.0 - t) * coords[i] + t * coords[j]\n                points.append(p_ij)\n        \n        if not points:\n            return []\n        \n        # Filter for unique points using a distance tolerance\n        unique_points = [points[0]]\n        for p in points[1:]:\n            is_duplicate = any(np.linalg.norm(p - up) < _GEOM_TOL for up in unique_points)\n            if not is_duplicate:\n                unique_points.append(p)\n        return unique_points\n\n    def form_segment(zero_points):\n        if len(zero_points) < 2:\n            return None\n        \n        max_dist_sq = -1.0\n        best_pair = (None, None)\n        for i in range(len(zero_points)):\n            for j in range(i + 1, len(zero_points)):\n                p1, p2 = zero_points[i], zero_points[j]\n                dist_sq = np.sum((p1 - p2)**2)\n                if dist_sq > max_dist_sq:\n                    max_dist_sq = dist_sq\n                    best_pair = (p1, p2)\n        return best_pair\n\n    # Find zero crossings for phi and psi\n    phi_zeros = find_zeros(phi_vals)\n    psi_zeros = find_zeros(psi_vals)\n    \n    # Form segments by connecting the two farthest zero-crossing points\n    phi_segment = form_segment(phi_zeros)\n    psi_segment = form_segment(psi_zeros)\n\n    # Tip-Enriched Criterion: Check for segment intersection\n    if phi_segment is not None and psi_segment is not None:\n        if segments_intersect(phi_segment, psi_segment):\n            return 2  # Tip-enriched\n\n    # Heaviside-Enriched Criterion: Check if phi-isocontour crosses the element\n    if phi_segment is not None:\n        return 1  # Heaviside-enriched\n\n    # Otherwise, it's a standard element\n    return 0  # Standard\n\ndef solve():\n    test_cases = [\n        # 1. Heaviside-enriched, \"happy path\"\n        {'coords': [[0,0], [1,0], [1,1], [0,1]], 'phi': [-1, 1, 1, -1], 'psi': [2, 2, 2, 2]},\n        # 2. Tip-enriched, interior intersection\n        {'coords': [[0,0], [1,0], [1,1], [0,1]], 'phi': [-0.5, 0.5, 0.5, -0.5], 'psi': [-0.5, -0.5, 0.5, 0.5]},\n        # 3. Standard, no crack crossing\n        {'coords': [[0,0], [1,0], [1,1], [0,1]], 'phi': [-1, -1, -1, -1], 'psi': [-1, -1, -1, -1]},\n        # 4. Tip-enriched, degenerate tip at a node\n        {'coords': [[0,0], [1,0], [1,1], [0,1]], 'phi': [0, 1, 1, 0], 'psi': [0, 0, 1, 1]},\n        # 5. Heaviside-enriched, anisotropic rectangle\n        {'coords': [[0,0], [10,0], [10,1], [0,1]], 'phi': [-5, 5, 5, -5], 'psi': [1, 1, 1, 1]},\n        # 6. Heaviside-enriched, both isocontours cross but do not intersect within the element\n        {'coords': [[0,0], [1,0], [1,1], [0,1]], 'phi': [-0.5, 0.5, 0.5, -0.5], 'psi': [-0.4, 0.6, 1.6, 0.6]}\n    ]\n    tau = 1e-12\n\n    results = []\n    for case in test_cases:\n        result = classify_element(case['coords'], case['phi'], case['psi'], tau)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2551522"}, {"introduction": "Once an element is enriched and partitioned by a discontinuity, a standard quadrature rule is no longer sufficient for accurate integration. This final practice addresses this crucial challenge by asking you to develop a custom quadrature scheme for an arbitrarily cut element. By partitioning the element into sub-domains and integrating over them, you will learn the essential technique for accurately assembling the system matrices in an XFEM simulation [@problem_id:2390826].", "problem": "In the context of the Extended Finite Element Method (XFEM), consider a single triangular finite element in two spatial dimensions. The element is intersected by a straight line that represents a discontinuity (for example, a crack surface). Let the triangle have vertices at coordinates in the plane, and let the line be represented implicitly by the scalar function $\\phi(x,y) = a x + b y + c$, with the positive half-plane defined by $\\{(x,y) \\, | \\, \\phi(x,y) \\ge 0\\}$. Define the unit step (Heaviside) enrichment domain as the intersection of the triangular element with this positive half-plane. The objective is to construct a custom numerical quadrature rule capable of integrating a polynomial field over the portion of the triangular element lying in the Heaviside domain.\n\nFor each given test case, compute the scalar integral\n$$\nI \\;=\\; \\iint_{\\Omega_+} f(x,y) \\,\\mathrm{d}A,\n$$\nwhere $\\Omega_+ = \\{(x,y) \\in T \\, | \\, \\phi(x,y) \\ge 0\\}$ and $T$ is the closed triangular region formed by the three vertices provided in the test case. The integrand for all test cases is the polynomial\n$$\nf(x,y) \\;=\\; x^2 + y.\n$$\nThere are no physical units attached to the quantity $I$; report the numerical values as real numbers. Angles do not appear in the problem. The final answers for each test case must be returned as floating-point numbers.\n\nUse the following test suite. In each case, the triangle is given by an ordered triplet of vertices and the line is given by its coefficients $(a,b,c)$ in the implicit form $\\phi(x,y) = a x + b y + c$.\n\n- Test case $1$ (general cut producing a convex quadrilateral subdomain):\n  - Triangle vertices: $(0,0)$, $(1,0)$, $(0,1)$.\n  - Line coefficients: $(a,b,c) = (1,1,-0.5)$, i.e., $\\phi(x,y) = x + y - 0.5$.\n\n- Test case $2$ (no cut, entire triangle lies in the positive half-plane):\n  - Triangle vertices: $(0,0)$, $(1,0)$, $(0,1)$.\n  - Line coefficients: $(a,b,c) = (1,1,1)$, i.e., $\\phi(x,y) = x + y + 1$.\n\n- Test case $3$ (boundary case, the line passes through a vertex and cuts the element):\n  - Triangle vertices: $(0,0)$, $(2,0)$, $(0,1)$.\n  - Line coefficients: $(a,b,c) = (-1,1,0)$, i.e., $\\phi(x,y) = -x + y$.\n\n- Test case $4$ (empty intersection, the positive half-plane does not intersect the triangle interior):\n  - Triangle vertices: $(0,0)$, $(1,0)$, $(0,1)$.\n  - Line coefficients: $(a,b,c) = (1,1,-2)$, i.e., $\\phi(x,y) = x + y - 2$.\n\nYour program must compute $I$ for each test case in the above order and produce a single line of output containing the four results as a comma-separated list enclosed in square brackets, for example, [$r_1$,$r_2$,$r_3$,$r_4$], where each $r_i$ is the floating-point result corresponding to test case $i$.", "solution": "The problem statement poses a well-defined task in computational engineering, specifically in the context of the Extended Finite Element Method (XFEM). It asks for the computation of a definite integral of a polynomial function over a domain defined by the intersection of a triangle and a half-plane.\n\n### Step 1: Extract Givens\n- **Integration Domain**: The region $\\Omega_+ = \\{(x,y) \\in T \\, | \\, \\phi(x,y) \\ge 0\\}$, where $T$ is a closed triangular region and $\\phi(x,y) = ax + by + c$ is a linear function.\n- **Integrand**: $f(x,y) = x^2 + y$.\n- **Integral to Compute**: $I = \\iint_{\\Omega_+} f(x,y) \\, \\mathrm{d}A$.\n- **Test Cases**:\n    1.  $T_1$: vertices $\\{(0,0), (1,0), (0,1)\\}$; $\\phi_1(x,y) = x + y - 0.5$.\n    2.  $T_2$: vertices $\\{(0,0), (1,0), (0,1)\\}$; $\\phi_2(x,y) = x + y + 1$.\n    3.  $T_3$: vertices $\\{(0,0), (2,0), (0,1)\\}$; $\\phi_3(x,y) = -x + y$.\n    4.  $T_4$: vertices $\\{(0,0), (1,0), (0,1)\\}$; $\\phi_4(x,y) = x + y - 2$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to validation:\n- **Scientifically Grounded**: The problem is a standard procedure in XFEM for handling discontinuities that do not conform to the mesh. It is based on fundamental principles of calculus and computational geometry. It is valid.\n- **Well-Posed**: The integration domain $\\Omega_+$ is a compact, convex set (a polygon, the full triangle, or the empty set). The integrand $f(x,y)$ is a polynomial, and is therefore continuous and bounded on $\\Omega_+$. The integral is well-defined and has a unique value. The problem is valid.\n- **Objective**: The problem is stated using precise mathematical language, free of any subjective or ambiguous terms. It is valid.\n- **Completeness and Consistency**: All necessary data (vertices, line coefficients, integrand) are provided for each test case. There are no contradictions. The problem is valid.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A rigorous solution will be constructed.\n\n### Solution Methodology\n\nThe core of the problem is to compute the integral $I = \\iint_{\\Omega_+} (x^2+y) \\, \\mathrm{d}A$. The domain $\\Omega_+$ is the part of the parent triangle $T$ for which the level set function $\\phi(x,y)$ is non-negative. The nature of $\\Omega_+$ depends on the signs of $\\phi$ evaluated at the vertices of $T$. Let the triangle vertices be $V_1, V_2, V_3$. We evaluate $\\phi_i = \\phi(V_i)$ for $i=1,2,3$.\n\nThe strategy is to classify the configuration based on how many vertices lie in the positive half-plane (where $\\phi \\ge 0$).\n\n1.  **All vertices in the positive half-plane**: If all $\\phi_i \\ge 0$, then the entire triangle $T$ is the domain of integration, $\\Omega_+ = T$.\n2.  **All vertices in the negative half-plane**: If all $\\phi_i < 0$, then $\\Omega_+$ is the empty set, and the integral is $0$.\n3.  **The line cuts the triangle**: If the vertices have mixed signs for $\\phi$, the line $\\phi(x,y)=0$ intersects the triangle. The integration domain $\\Omega_+$ is a convex polygon (either a triangle or a quadrilateral).\n    - **One vertex in the positive half-plane**: If one vertex, say $V_p$, has $\\phi(V_p) \\ge 0$, while the other two, $V_{n1}, V_{n2}$, have negative $\\phi$ values, the domain $\\Omega_+$ is a smaller triangle. Its vertices are $V_p$ and the two points where the line $\\phi=0$ intersects the edges $(V_p, V_{n1})$ and $(V_p, V_{n2})$.\n    - **Two vertices in the positive half-plane**: If two vertices, say $V_{p1}, V_{p2}$, have $\\phi \\ge 0$ and one vertex, $V_n$, has $\\phi < 0$, the domain $\\Omega_+$ is a quadrilateral. A direct and robust method to compute the integral is to subtract the integral over the small cut-off portion from the integral over the whole triangle. The cut-off portion is a triangle with vertices $V_n$ and the two intersection points of the line $\\phi=0$ with edges $(V_n, V_{p1})$ and $(V_n, V_{p2})$.\n\nThe intersection point $P_{int}$ on an edge connecting vertices $A$ and $B$ is found by parameterizing the edge as $P(t) = A + t(B-A)$ for $t \\in [0,1]$. By linearity of $\\phi$, we have $\\phi(P(t)) = (1-t)\\phi(A) + t\\phi(B) = 0$. Solving for $t$ yields $t = \\phi(A) / (\\phi(A) - \\phi(B))$. The intersection point is then $P_{int} = A + t(B-A)$.\n\nTo compute the integral of the polynomial $f(x,y)=x^2+y$ over any triangle, we use a numerical quadrature rule that is exact for quadratic polynomials. A three-point Gaussian quadrature rule located at the midpoints of the edges of the triangle satisfies this requirement. For a triangle $T'$ with area $A'$, the integral is given by:\n$$\n\\iint_{T'} f(x,y) \\, \\mathrm{d}A = \\frac{A'}{3} \\sum_{k=1}^{3} f(m_k)\n$$\nwhere $m_k$ are the midpoints of the three edges of $T'$. The area $A'$ of a triangle with vertices $(x_1, y_1), (x_2, y_2), (x_3, y_3)$ is calculated as $A' = \\frac{1}{2} |x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2)|$.\n\nThis methodology provides a complete and systematic approach to solving the problem for all given test cases.\n\n### Case-by-Case Analysis\n\n- **Test Case 1**: Vertices $V_1(0,0), V_2(1,0), V_3(0,1)$. Line $\\phi(x,y) = x+y-0.5$.\n$\\phi(V_1) = -0.5$, $\\phi(V_2) = 0.5$, $\\phi(V_3)=0.5$.\nThis is a \"two positive, one negative\" case. We compute the integral over the full parent triangle $T$ and subtract the integral over the small cut-off triangle formed by $V_1$ and the intersections on edges $(V_1,V_2)$ and $(V_1,V_3)$.\n- **Test Case 2**: Vertices $V_1(0,0), V_2(1,0), V_3(0,1)$. Line $\\phi(x,y) = x+y+1$.\n$\\phi(V_1)=1$, $\\phi(V_2)=2$, $\\phi(V_3)=2$. All positive. The integration is over the entire triangle $T$.\n- **Test Case 3**: Vertices $V_1(0,0), V_2(2,0), V_3(0,1)$. Line $\\phi(x,y) = -x+y$.\n$\\phi(V_1)=0$, $\\phi(V_2)=-2$, $\\phi(V_3)=1$. This is treated as a \"two positive ($\\phi \\ge 0$), one negative\" case.\n- **Test Case 4**: Vertices $V_1(0,0), V_2(1,0), V_3(0,1)$. Line $\\phi(x,y) = x+y-2$.\n$\\phi(V_1)=-2$, $\\phi(V_2)=-1$, $\\phi(V_3)=-1$. All negative. The integration domain is empty, so the integral is $0$.\n\nThe implementation will follow this logic to compute the required values.", "answer": "```python\nimport numpy as np\n\ndef integrate_over_triangle(vertices):\n    \"\"\"\n    Computes the integral of f(x,y) = x^2 + y over a triangle using a\n    3-point midpoint quadrature rule, which is exact for quadratic polynomials.\n    \n    Args:\n        vertices (list of tuples): A list of three (x, y) tuples for the triangle vertices.\n\n    Returns:\n        float: The value of the integral.\n    \"\"\"\n    p1, p2, p3 = np.array(vertices[0]), np.array(vertices[1]), np.array(vertices[2])\n\n    # Integrand function\n    f = lambda p: p[0]**2 + p[1]\n\n    # Area of the triangle\n    area = 0.5 * abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n\n    if area < 1e-12:  # Degenerate triangle\n        return 0.0\n\n    # Midpoints of the edges\n    m1 = (p1 + p2) / 2.0\n    m2 = (p2 + p3) / 2.0\n    m3 = (p3 + p1) / 2.0\n\n    # Evaluate function at midpoints\n    f_vals = [f(m1), f(m2), f(m3)]\n\n    # Apply quadrature rule\n    integral = (area / 3.0) * sum(f_vals)\n    return integral\n\n\ndef calculate_integral_for_case(triangle_verts, line_coeffs):\n    \"\"\"\n    Calculates the integral for a single test case by determining the\n    integration domain and applying the appropriate integration strategy.\n    \n    Args:\n        triangle_verts (list of tuples): Vertices of the parent triangle.\n        line_coeffs (tuple): Coefficients (a, b, c) of the line ax+by+c=0.\n    \n    Returns:\n        float: The final computed integral.\n    \"\"\"\n    a, b, c = line_coeffs\n    phi = lambda p: a*p[0] + b*p[1] + c\n    \n    V = [np.array(v) for v in triangle_verts]\n    phi_vals = np.array([phi(v) for v in V])\n    \n    pos_indices = [i for i, pv in enumerate(phi_vals) if pv >= 0]\n    neg_indices = [i for i, pv in enumerate(phi_vals) if pv < 0]\n\n    # Case 1: All vertices in the positive half-plane (phi >= 0)\n    if len(pos_indices) == 3:\n        return integrate_over_triangle(V)\n        \n    # Case 2: All vertices in the negative half-plane (phi < 0)\n    if len(neg_indices) == 3:\n        return 0.0\n\n    # Case 3: Line cuts the triangle.\n    # Case 3a: One vertex has phi >= 0, two have phi < 0.\n    # The integration domain is a small triangle.\n    if len(pos_indices) == 1:\n        p_idx = pos_indices[0]\n        n_idx1, n_idx2 = neg_indices\n        \n        Vp, Vn1, Vn2 = V[p_idx], V[n_idx1], V[n_idx2]\n        phi_p, phi_n1, phi_n2 = phi_vals[p_idx], phi_vals[n_idx1], phi_vals[n_idx2]\n        \n        # Intersection on edge (Vp, Vn1)\n        t1 = phi_p / (phi_p - phi_n1)\n        I1 = Vp + t1 * (Vn1 - Vp)\n        \n        # Intersection on edge (Vp, Vn2)\n        t2 = phi_p / (phi_p - phi_n2)\n        I2 = Vp + t2 * (Vn2 - Vp)\n        \n        integration_triangle = [Vp, I1, I2]\n        return integrate_over_triangle(integration_triangle)\n\n    # Case 3b: Two vertices have phi >= 0, one has phi < 0.\n    # The integration domain is a quadrilateral. We compute its integral by subtraction.\n    if len(pos_indices) == 2:\n        n_idx = neg_indices[0]\n        p_idx1, p_idx2 = pos_indices\n        \n        integral_total = integrate_over_triangle(V)\n        \n        Vn, Vp1, Vp2 = V[n_idx], V[p_idx1], V[p_idx2]\n        phi_n, phi_p1, phi_p2 = phi_vals[n_idx], phi_vals[p_idx1], phi_vals[p_idx2]\n        \n        # Intersection on edge (Vn, Vp1)\n        t1 = phi_n / (phi_n - phi_p1)\n        I1 = Vn + t1 * (Vp1 - Vn)\n        \n        # Intersection on edge (Vn, Vp2)\n        t2 = phi_n / (phi_n - phi_p2)\n        I2 = Vn + t2 * (Vp2 - Vn)\n        \n        cutoff_triangle = [Vn, I1, I2]\n        integral_cutoff = integrate_over_triangle(cutoff_triangle)\n\n        return integral_total - integral_cutoff\n    \n    return 0.0 # Should not be reached with valid triangle inputs\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        ([(0, 0), (1, 0), (0, 1)], (1, 1, -0.5)),\n        # Test case 2\n        ([(0, 0), (1, 0), (0, 1)], (1, 1, 1)),\n        # Test case 3\n        ([(0, 0), (2, 0), (0, 1)], (-1, 1, 0)),\n        # Test case 4\n        ([(0, 0), (1, 0), (0, 1)], (1, 1, -2)),\n    ]\n\n    results = []\n    for triangle_verts, line_coeffs in test_cases:\n        result = calculate_integral_for_case(triangle_verts, line_coeffs)\n        results.append(result)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.16f}'.rstrip('0').rstrip('.') for r in results)}]\")\n\nsolve()\n```", "id": "2390826"}]}