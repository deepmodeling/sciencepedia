{"hands_on_practices": [{"introduction": "Assessing mesh quality is a critical first step in any simulation, yet intuitive geometric metrics can sometimes be deceptive. This exercise demonstrates a classic pitfall where an element appears perfect based on its edge lengths but is, in fact, invalid or \"tangled.\" By working through this problem, you will understand the necessity of more rigorous metrics like the Jacobian determinant, which rigorously evaluates the validity of the mapping from an ideal reference element to the physical element [@problem_id:2412959].", "id": "2412959", "problem": "In computational engineering, mesh quality is often assessed by combining geometric shape metrics such as aspect ratio with mapping-based metrics such as the Jacobian determinant of the isoparametric transformation. Consider a two-dimensional ($2$D) bilinear isoparametric quadrilateral element that maps the reference square with parametric coordinates $(\\xi,\\eta) \\in [-1,1] \\times [-1,1]$ to a straight-edged quadrilateral in the physical plane. Use the following construction to illustrate that a perfect aspect ratio does not guarantee a valid mapping.\n\nDefine the physical node coordinates (in counterclockwise reference-node order) as\n$$\n(x_1,y_1)=(0,a),\\quad (x_2,y_2)=(a,0),\\quad (x_3,y_3)=(0,-a),\\quad (x_4,y_4)=(-a,0),\n$$\nwith $a>0$. For mesh quality assessment, adopt the edge-length-based aspect ratio \n$$\nr=\\frac{\\max\\{\\ell_1,\\ell_2,\\ell_3,\\ell_4\\}}{\\min\\{\\ell_1,\\ell_2,\\ell_3,\\ell_4\\}},\n$$\nwhere $\\ell_i$ is the Euclidean length of the $i$-th physical edge formed by consecutive nodes $i$ and $i+1$ (with node $5$ identified with node $1$).\n\nStarting from the standard bilinear isoparametric mapping for a $4$-node quadrilateral and the definition of the Jacobian matrix $J(\\xi,\\eta)$ of the mapping, do the following:\n- Establish that the constructed element has $r=1$.\n- Compute the Jacobian determinant at the element center $(\\xi,\\eta)=(0,0)$ and express it exactly in terms of $a$.\n\nProvide your final answer as a single closed-form expression for the Jacobian determinant at the element center in terms of $a$. Do not include units. No rounding is required.", "solution": "The problem requires an analysis of a specific two-dimensional bilinear isoparametric quadrilateral element to demonstrate that a perfect aspect ratio does not preclude an invalid mapping. This will be accomplished by first calculating the element's edge-length-based aspect ratio, $r$, and then computing the determinant of the Jacobian of the mapping at the element's center.\n\nFirst, we establish that the aspect ratio $r=1$. The physical coordinates of the four nodes are given in counterclockwise reference-node order as $(x_1, y_1) = (0, a)$, $(x_2, y_2) = (a, 0)$, $(x_3, y_3) = (0, -a)$, and $(x_4, y_4) = (-a, 0)$, for some constant $a > 0$. The aspect ratio is defined as the ratio of the maximum to the minimum edge length, $r = \\frac{\\max\\{\\ell_i\\}}{\\min\\{\\ell_i\\}}$. We compute the length of each of the four edges, $\\ell_i$, using the Euclidean distance formula $\\ell = \\sqrt{\\Delta x^2 + \\Delta y^2}$.\n\nThe length of the first edge, $\\ell_1$, between node $1$ and node $2$ is:\n$$\n\\ell_1 = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} = \\sqrt{(a - 0)^2 + (0 - a)^2} = \\sqrt{a^2 + (-a)^2} = \\sqrt{2a^2} = a\\sqrt{2}\n$$\n\nThe length of the second edge, $\\ell_2$, between node $2$ and node $3$ is:\n$$\n\\ell_2 = \\sqrt{(x_3 - x_2)^2 + (y_3 - y_2)^2} = \\sqrt{(0 - a)^2 + (-a - 0)^2} = \\sqrt{(-a)^2 + (-a)^2} = \\sqrt{2a^2} = a\\sqrt{2}\n$$\n\nThe length of the third edge, $\\ell_3$, between node $3$ and node $4$ is:\n$$\n\\ell_3 = \\sqrt{(x_4 - x_3)^2 + (y_4 - y_3)^2} = \\sqrt{(-a - 0)^2 + (0 - (-a))^2} = \\sqrt{(-a)^2 + a^2} = \\sqrt{2a^2} = a\\sqrt{2}\n$$\n\nThe length of the fourth edge, $\\ell_4$, between node $4$ and node $1$ is:\n$$\n\\ell_4 = \\sqrt{(x_1 - x_4)^2 + (y_1 - y_4)^2} = \\sqrt{(0 - (-a))^2 + (a - 0)^2} = \\sqrt{a^2 + a^2} = \\sqrt{2a^2} = a\\sqrt{2}\n$$\n\nSince all edge lengths are equal, $\\ell_1 = \\ell_2 = \\ell_3 = \\ell_4 = a\\sqrt{2}$, the maximum and minimum lengths are identical. Therefore, the aspect ratio is:\n$$\nr = \\frac{\\max\\{\\ell_i\\}}{\\min\\{\\ell_i\\}} = \\frac{a\\sqrt{2}}{a\\sqrt{2}} = 1\n$$\nThis demonstrates that the element has a perfect aspect ratio of $1$.\n\nNext, we compute the Jacobian determinant. The isoparametric mapping from the reference coordinates $(\\xi, \\eta)$ to the physical coordinates $(x, y)$ is defined by:\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad \\text{and} \\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\nThe standard bilinear shape functions $N_i(\\xi, \\eta)$ for the reference square $[-1,1] \\times [-1,1]$ are associated with the nodes in counterclockwise order starting from $(\\xi, \\eta) = (-1,-1)$:\n$N_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$\n$N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$\n$N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$\n$N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$\n\nSubstituting the given physical nodal coordinates:\n$x(\\xi, \\eta) = N_1(0) + N_2(a) + N_3(0) + N_4(-a) = a N_2 - a N_4$\n$y(\\xi, \\eta) = N_1(a) + N_2(0) + N_3(-a) + N_4(0) = a N_1 - a N_3$\n\nSubstituting the expressions for the shape functions:\n$$\nx(\\xi, \\eta) = a \\left( \\frac{1}{4}(1+\\xi)(1-\\eta) \\right) - a \\left( \\frac{1}{4}(1-\\xi)(1+\\eta) \\right) = \\frac{a}{4} ((1-\\eta+\\xi-\\xi\\eta) - (1+\\eta-\\xi-\\xi\\eta)) = \\frac{a}{4}(2\\xi - 2\\eta) = \\frac{a}{2}(\\xi - \\eta)\n$$\n$$\ny(\\xi, \\eta) = a \\left( \\frac{1}{4}(1-\\xi)(1-\\eta) \\right) - a \\left( \\frac{1}{4}(1+\\xi)(1+\\eta) \\right) = \\frac{a}{4} ((1-\\eta-\\xi+\\xi\\eta) - (1+\\eta+\\xi+\\xi\\eta)) = \\frac{a}{4}(-2\\eta - 2\\xi) = -\\frac{a}{2}(\\xi + \\eta)\n$$\nThe Jacobian matrix of the transformation is $J(\\xi, \\eta) = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}$. We compute the partial derivatives:\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}\\left(\\frac{a}{2}(\\xi - \\eta)\\right) = \\frac{a}{2}\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}\\left(\\frac{a}{2}(\\xi - \\eta)\\right) = -\\frac{a}{2}\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}\\left(-\\frac{a}{2}(\\xi + \\eta)\\right) = -\\frac{a}{2}\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}\\left(-\\frac{a}{2}(\\xi + \\eta)\\right) = -\\frac{a}{2}\n$$\nThe Jacobian matrix is therefore constant over the entire element:\n$$\nJ = \\begin{pmatrix} \\frac{a}{2} & -\\frac{a}{2} \\\\ -\\frac{a}{2} & -\\frac{a}{2} \\end{pmatrix}\n$$\nThe determinant of the Jacobian, $\\det(J)$, is:\n$$\n\\det(J) = \\left(\\frac{a}{2}\\right)\\left(-\\frac{a}{2}\\right) - \\left(-\\frac{a}{2}\\right)\\left(-\\frac{a}{2}\\right) = -\\frac{a^2}{4} - \\frac{a^2}{4} = -\\frac{2a^2}{4} = -\\frac{a^2}{2}\n$$\nSince the Jacobian determinant is constant, its value at the element center, $(\\xi, \\eta)=(0,0)$, is $-\\frac{a^2}{2}$. A negative Jacobian determinant indicates that the mapping is locally orientation-reversing, meaning the element is \"tangled\" or \"inverted\". This is an invalid element in the context of the finite element method. The exercise correctly demonstrates that a perfect geometric aspect ratio ($r=1$) does not guarantee a valid mapping.", "answer": "$$\n\\boxed{-\\frac{a^2}{2}}\n$$"}, {"introduction": "Once a poor-quality or inverted element is identified, we need effective strategies to improve the mesh. This practice provides a hands-on comparison between two fundamental approaches: the simple, fast Laplacian smoother and a more robust optimization-based method. Through a coding exercise, you will discover the relative strengths and weaknesses of each technique in the challenging but crucial task of \"untangling\" an inverted mesh, a common failure mode in mesh generation [@problem_id:2412991].", "id": "2412991", "problem": "You must write a complete and runnable program that constructs a small two-dimensional ($2$-D) triangular mesh, deliberately introduces an inverted element, and then compares a simple Laplacian smoother against an optimization-based smoother for their ability to untangle the inversion. Your program must implement both smoothers from first principles, apply them to a provided test suite of mesh configurations, and report whether each method successfully untangles the mesh in each case as a boolean.\n\nStart from the following fundamental base: the signed area of a triangle in the plane, defined for vertices $\\mathbf{p}_0=(x_0,y_0)$, $\\mathbf{p}_1=(x_1,y_1)$, and $\\mathbf{p}_2=(x_2,y_2)$ by\n$$\nA_s(\\mathbf{p}_0,\\mathbf{p}_1,\\mathbf{p}_2) = \\tfrac{1}{2}\\,\\det\\begin{bmatrix}x_1-x_0 & x_2-x_0\\\\ y_1-y_0 & y_2-y_0\\end{bmatrix} = \\tfrac{1}{2}\\big((x_1-x_0)(y_2-y_0)-(x_2-x_0)(y_1-y_0)\\big).\n$$\nA triangle is inverted if $A_s \\le 0$ for the chosen vertex ordering. A mesh is untangled if all its triangles have strictly positive signed area. The Laplacian smoother for an interior vertex $\\mathbf{x}_i^{(k)}$ at iteration $k$ is the explicit update\n$$\n\\mathbf{x}_i^{(k+1)} = \\mathbf{x}_i^{(k)} + \\alpha\\left(\\frac{1}{|\\mathcal{N}(i)|}\\sum_{j\\in \\mathcal{N}(i)} \\mathbf{x}_j^{(k)} - \\mathbf{x}_i^{(k)}\\right),\n$$\nwhere $\\mathcal{N}(i)$ denotes the $1$-ring neighbor set, $|\\mathcal{N}(i)|$ its cardinality, and $\\alpha\\in(0,1]$ the step size. Boundary vertices remain fixed. An optimization-based smoother is obtained by minimizing an energy that penalizes negative areas while encouraging short, smooth edges. One smooth penalty for negative signed area $A_s$ is obtained by the softplus function $\\operatorname{softplus}(z;\\beta) = \\tfrac{1}{\\beta}\\log(1+e^{\\beta z})$ applied to $z=-A_s$, yielding a differentiable hinge-like penalty that is large when $A_s$ is negative and near zero when $A_s$ is sufficiently positive. Let the objective be\n$$\nE(\\mathbf{X}) = w_{\\ell}\\sum_{(i,j)\\in \\mathcal{E}} \\|\\mathbf{x}_i-\\mathbf{x}_j\\|_2^2 \\;+\\; w_{a}\\sum_{t\\in\\mathcal{T}} \\operatorname{softplus}\\!\\left(-A_s(t);\\beta\\right)^2,\n$$\nwhere $\\mathcal{E}$ is the set of undirected mesh edges, $\\mathcal{T}$ is the set of triangles, $\\mathbf{X}$ stacks all vertex coordinates, and boundary vertices are fixed while interior vertices are optimized.\n\nProgramming task specification:\n- Construct a square boundary with vertices $\\mathbf{v}_0=(0,0)$, $\\mathbf{v}_1=(1,0)$, $\\mathbf{v}_2=(1,1)$, $\\mathbf{v}_3=(0,1)$, and a single interior vertex $\\mathbf{c}=(x_c,y_c)$ connected to form four triangles with consistent counterclockwise orientation: $(\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{c})$, $(\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{c})$, $(\\mathbf{v}_2,\\mathbf{v}_3,\\mathbf{c})$, $(\\mathbf{v}_3,\\mathbf{v}_0,\\mathbf{c})$. The boundary vertex indices are fixed.\n- Implement a Laplacian smoother that updates only interior vertices using the explicit iteration above with step size $\\alpha = 0.25$ for exactly $5$ iterations. Use the $1$-ring neighbors induced by the triangles.\n- Implement an optimization-based smoother that minimizes $E(\\mathbf{X})$ over only interior vertices with the following parameters: $w_{\\ell} = 1.0$, $w_{a} = 100.0$, and $\\beta = 10.0$. Use numerical optimization with bound constraints $-2 \\le x_c \\le 2$, $-2 \\le y_c \\le 2$. Construct $\\mathcal{E}$ from the triangle connectivity as the unique set of undirected edges.\n- Define the mesh as untangled if all triangle signed areas are strictly greater than a threshold $\\varepsilon = 10^{-12}$.\n\nTest suite:\n- Case $1$ (mild inversion): $\\mathbf{c}=(0.5,-0.05)$.\n- Case $2$ (severe inversion): $\\mathbf{c}=(0.5,-1.0)$.\n- Case $3$ (already valid): $\\mathbf{c}=(0.5,0.5)$.\n\nFor each case, run both smoothers starting from the specified initial $\\mathbf{c}$ and evaluate a boolean indicating whether the resulting mesh is untangled according to the criterion $A_s > \\varepsilon$ for all triangles. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order\n$[$Laplacian on Case $1$, Optimization on Case $1$, Laplacian on Case $2$, Optimization on Case $2$, Laplacian on Case $3$, Optimization on Case $3]$,\nfor example, $[b_1,b_2,b_3,b_4,b_5,b_6]$ where each $b_i$ is either True or False.", "solution": "The problem requires the implementation and comparison of two mesh smoothing algorithms—Laplacian smoothing and an optimization-based method—for their effectiveness in untangling an inverted two-dimensional triangular mesh. The validation of the problem statement confirms that it is scientifically sound, well-posed, and contains all necessary information to proceed with a solution. The approach is to first establish the mesh geometry and the metric for element validity, then to implement each smoothing algorithm as specified, and finally to apply them to the provided test cases to determine their success in producing a valid, untangled mesh.\n\nFirst, we define the computational domain and mesh topology. The mesh consists of five vertices: four fixed boundary vertices forming a unit square, $\\mathbf{v}_0=(0,0)$, $\\mathbf{v}_1=(1,0)$, $\\mathbf{v}_2=(1,1)$, and $\\mathbf{v}_3=(0,1)$, and a single movable interior vertex $\\mathbf{c}=(x_c, y_c)$. These vertices form a set of four triangles, with connectivity defined to ensure a consistent counter-clockwise orientation for a valid (non-inverted) mesh centered within the boundary: $T_0 = (\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{c})$, $T_1 = (\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{c})$, $T_2 = (\\mathbf{v}_2, \\mathbf{v}_3, \\mathbf{c})$, and $T_3 = (\\mathbf{v}_3, \\mathbf{v}_0, \\mathbf{c})$.\n\nThe quality of a triangle is determined by its signed area. For a triangle with vertices $\\mathbf{p}_0=(x_0,y_0)$, $\\mathbf{p}_1=(x_1,y_1)$, and $\\mathbf{p}_2=(x_2,y_2)$, the signed area $A_s$ is given by the formula:\n$$\nA_s(\\mathbf{p}_0, \\mathbf{p}_1, \\mathbf{p}_2) = \\frac{1}{2} \\det\\begin{bmatrix}x_1-x_0 & x_2-x_0 \\\\ y_1-y_0 & y_2-y_0\\end{bmatrix}\n$$\nA positive signed area corresponds to a counter-clockwise ordering of vertices, which is the convention for a valid element. A triangle is considered inverted if $A_s \\le 0$. A mesh is defined as untangled if all its constituent triangles have a signed area strictly greater than a small tolerance, $A_s > \\varepsilon$, where $\\varepsilon = 10^{-12}$.\n\nThe first method, Laplacian smoothing, is an iterative heuristic that repositions an interior vertex to the geometric centroid of its adjacent neighbors. The update for the position of an interior vertex $\\mathbf{x}_i$ at iteration $k$ is given by:\n$$\n\\mathbf{x}_i^{(k+1)} = \\mathbf{x}_i^{(k)} + \\alpha \\left( \\frac{1}{|\\mathcal{N}(i)|} \\sum_{j \\in \\mathcal{N}(i)} \\mathbf{x}_j^{(k)} - \\mathbf{x}_i^{(k)} \\right)\n$$\nIn our specific mesh, there is only one interior vertex, $\\mathbf{c}$. Its $1$-ring neighbors, $\\mathcal{N}(\\mathbf{c})$, are the four boundary vertices $\\{\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3\\}$. The centroid of these fixed neighbors is a constant point $\\bar{\\mathbf{v}} = \\frac{1}{4}(\\mathbf{v}_0 + \\mathbf{v}_1 + \\mathbf{v}_2 + \\mathbf{v}_3) = (\\frac{0+1+1+0}{4}, \\frac{0+0+1+1}{4}) = (0.5, 0.5)$. The iterative update for $\\mathbf{c}$ simplifies to:\n$$\n\\mathbf{c}^{(k+1)} = \\mathbf{c}^{(k)} + \\alpha (\\bar{\\mathbf{v}} - \\mathbf{c}^{(k)})\n$$\nThis process is executed for a fixed number of $5$ iterations with a step size $\\alpha = 0.25$. Boundary vertices remain unchanged.\n\nThe second method is an optimization-based smoother that seeks to minimize a global objective function $E(\\mathbf{X})$, where $\\mathbf{X}$ represents the coordinates of all vertices. The function is a weighted sum of two terms: a penalty on squared edge lengths and a penalty on non-positive triangle areas.\n$$\nE(\\mathbf{X}) = w_{\\ell}\\sum_{(i,j)\\in \\mathcal{E}} \\|\\mathbf{x}_i-\\mathbf{x}_j\\|_2^2 \\;+\\; w_{a}\\sum_{t\\in\\mathcal{T}} \\operatorname{softplus}\\!\\left(-A_s(t);\\beta\\right)^2\n$$\nThe set of edges $\\mathcal{E}$ includes the $4$ boundary edges and the $4$ edges connecting $\\mathbf{c}$ to each boundary vertex. The set of triangles $\\mathcal{T}$ contains the four triangles $\\{T_0, T_1, T_2, T_3\\}$. The term $\\operatorname{softplus}(z;\\beta) = \\frac{1}{\\beta}\\log(1+e^{\\beta z})$ is a smooth approximation of the ReLU function, which serves as a differentiable penalty for negative signed areas (when its argument is $z = -A_s$). The optimization is performed with respect to the coordinates of the interior vertex $\\mathbf{c}$ only, subject to the box constraints $-2 \\le x_c, y_c \\le 2$. The specified parameters are $w_{\\ell} = 1.0$, $w_{a} = 100.0$, and $\\beta = 10.0$. We will use a numerical optimization routine from the `scipy` library to find the coordinates of $\\mathbf{c}$ that minimize this objective function.\n\nFor each test case, the initial position of $\\mathbf{c}$ is set. Each of the two smoothing algorithms is then applied. After each run, the signed areas of all four triangles are computed using the final position of $\\mathbf{c}$. The mesh is certified as untangled if and only if all four areas are greater than $\\varepsilon = 10^{-12}$. The boolean result of this check is recorded for each method and each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.5, -0.05),  # Case 1 (mild inversion)\n        (0.5, -1.0),   # Case 2 (severe inversion)\n        (0.5, 0.5),    # Case 3 (already valid)\n    ]\n\n    # Global parameters\n    EPSILON = 1e-12\n    BOUNDARY_VERTS = np.array([\n        [0.0, 0.0],  # v0 (index 0)\n        [1.0, 0.0],  # v1 (index 1)\n        [1.0, 1.0],  # v2 (index 2)\n        [0.0, 1.0],  # v3 (index 3)\n    ])\n    # Vertex indices for the four triangles, with interior vertex at index 4\n    TRIANGLES_CONN = [\n        (0, 1, 4),\n        (1, 2, 4),\n        (2, 3, 4),\n        (3, 0, 4),\n    ]\n    # Unique undirected edges for the objective function\n    EDGES_CONN = [\n        (0, 1), (1, 2), (2, 3), (3, 0), # boundary edges\n        (0, 4), (1, 4), (2, 4), (3, 4)  # interior edges\n    ]\n\n    def signed_area(p0, p1, p2):\n        \"\"\"Calculates the signed area of a triangle given its vertices.\"\"\"\n        return 0.5 * ((p1[0] - p0[0]) * (p2[1] - p0[1]) - \n                      (p2[0] - p0[0]) * (p1[1] - p0[1]))\n\n    def check_untangled(interior_vert_pos):\n        \"\"\"Checks if the mesh is untangled given the position of the interior vertex.\"\"\"\n        all_verts = np.vstack((BOUNDARY_VERTS, interior_vert_pos))\n        for i, j, k in TRIANGLES_CONN:\n            p0, p1, p2 = all_verts[i], all_verts[j], all_verts[k]\n            if signed_area(p0, p1, p2) <= EPSILON:\n                return False\n        return True\n\n    def run_laplacian_smoother(initial_c):\n        \"\"\"Runs the Laplacian smoother for a specified number of iterations.\"\"\"\n        alpha = 0.25\n        num_iterations = 5\n        c_current = np.array(initial_c, dtype=float)\n        centroid = np.mean(BOUNDARY_VERTS, axis=0)\n\n        for _ in range(num_iterations):\n            # Update rule: c_new = c_old + alpha * (centroid - c_old)\n            c_current += alpha * (centroid - c_current)\n        \n        return c_current\n\n    def objective_function(c_coords, wl, wa, beta):\n        \"\"\"Objective function for optimization-based smoothing.\"\"\"\n        all_verts = np.vstack((BOUNDARY_VERTS, c_coords))\n        \n        # Edge length term\n        edge_energy = 0.0\n        for i, j in EDGES_CONN:\n            p1 = all_verts[i]\n            p2 = all_verts[j]\n            edge_energy += np.sum((p1 - p2)**2)\n            \n        # Area penalty term\n        area_penalty = 0.0\n        for i, j, k in TRIANGLES_CONN:\n            p0, p1, p2 = all_verts[i], all_verts[j], all_verts[k]\n            area = signed_area(p0, p1, p2)\n            \n            # softplus(-area; beta)\n            z = -area\n            # Use a numerically stable implementation for softplus\n            if beta * z > 700: # Avoid overflow in exp\n                 softplus_val = z\n            else:\n                 softplus_val = (1.0 / beta) * np.log1p(np.exp(beta * z))\n            area_penalty += softplus_val**2\n\n        return wl * edge_energy + wa * area_penalty\n\n    def run_optimization_smoother(initial_c):\n        \"\"\"Runs the optimization-based smoother.\"\"\"\n        wl, wa, beta = 1.0, 100.0, 10.0\n        bounds = [(-2.0, 2.0), (-2.0, 2.0)]\n        initial_c_np = np.array(initial_c, dtype=float)\n\n        result = minimize(\n            fun=objective_function,\n            x0=initial_c_np,\n            args=(wl, wa, beta),\n            method='L-BFGS-B',\n            bounds=bounds\n        )\n        return result.x\n\n    results = []\n    for case in test_cases:\n        initial_c = case\n        \n        # Run and evaluate Laplacian smoother\n        final_c_laplacian = run_laplacian_smoother(initial_c)\n        laplacian_success = check_untangled(final_c_laplacian)\n        results.append(laplacian_success)\n        \n        # Run and evaluate Optimization-based smoother\n        final_c_optimization = run_optimization_smoother(initial_c)\n        optimization_success = check_untangled(final_c_optimization)\n        results.append(optimization_success)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "In most engineering applications, simulation meshes must conform to a specified curved surface, like an automobile body or an airplane wing. This practice advances the concept of smoothing into this realistic context by introducing geometric constraints. You will implement a practical algorithm for surface mesh smoothing that improves element quality while ensuring the vertices remain on the underlying analytic surface, a critical skill for working with complex CAD models [@problem_id:2412997].", "id": "2412997", "problem": "You are given an analytic surface embedded in three-dimensional Euclidean space and a small set of triangular surface meshes whose vertices lie on the surface. For each mesh, perform a single constrained smoothing sweep on the vertex positions and assess the impact on element quality.\n\nSurface and tangent-plane constraint. Let the surface be the sphere of radius $R$ centered at the origin,\n$$\n\\mathcal{S} = \\left\\{ \\mathbf{x} \\in \\mathbb{R}^3 \\;\\middle|\\; \\|\\mathbf{x}\\|_2 = R \\right\\}.\n$$\nFor any $\\mathbf{x} \\in \\mathcal{S}$, its unit normal is $\\mathbf{n}(\\mathbf{x}) = \\mathbf{x}/R$, and its affine tangent plane is\n$$\n\\mathcal{T}_{\\mathbf{x}}\\mathcal{S} = \\left\\{ \\mathbf{y} \\in \\mathbb{R}^3 \\;\\middle|\\; (\\mathbf{y} - \\mathbf{x}) \\cdot \\mathbf{n}(\\mathbf{x}) = 0 \\right\\}.\n$$\n\nSmoothing objective per vertex. Consider a triangular mesh with vertex set $V=\\{\\mathbf{p}_i\\}_{i=1}^N \\subset \\mathcal{S}$ and face set $F \\subset \\{1,\\dots,N\\}^3$. For each vertex index $i$ that is not on the boundary of the mesh, let $\\mathcal{N}(i)$ denote the set of its neighboring vertex indices (those connected to $i$ by an edge). Define the constrained optimal intermediate position $\\mathbf{y}_i$ by the minimization problem\n$$\n\\mathbf{y}_i \\in \\underset{\\mathbf{y} \\in \\mathcal{T}_{\\mathbf{p}_i}\\mathcal{S}}{\\arg\\min}\\;\\sum_{j \\in \\mathcal{N}(i)} \\|\\mathbf{y} - \\mathbf{p}_j\\|_2^2.\n$$\nDefine the updated position $\\mathbf{z}_i$ by radial projection back to the sphere,\n$$\n\\mathbf{z}_i = \\frac{R}{\\|\\mathbf{y}_i\\|_2}\\,\\mathbf{y}_i.\n$$\nVertices on the boundary are not moved, that is, if $i$ is on the boundary, set $\\mathbf{z}_i = \\mathbf{p}_i$. A vertex is on the boundary if it belongs to at least one edge that is contained in exactly one face. One smoothing sweep replaces all $\\mathbf{p}_i$ by the corresponding $\\mathbf{z}_i$ simultaneously.\n\nTriangle quality. For any triangle with vertices $\\mathbf{a},\\mathbf{b},\\mathbf{c} \\in \\mathbb{R}^3$, define the area\n$$\nA(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = \\tfrac{1}{2}\\,\\|(\\mathbf{b}-\\mathbf{a}) \\times (\\mathbf{c}-\\mathbf{a})\\|_2,\n$$\nand the edge lengths $\\ell_1=\\|\\mathbf{b}-\\mathbf{a}\\|_2$, $\\ell_2=\\|\\mathbf{c}-\\mathbf{b}\\|_2$, $\\ell_3=\\|\\mathbf{a}-\\mathbf{c}\\|_2$. The quality of the triangle is\n$$\nq(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = \\frac{4\\sqrt{3}\\,A(\\mathbf{a},\\mathbf{b},\\mathbf{c})}{\\ell_1^2 + \\ell_2^2 + \\ell_3^2},\n$$\nwhich satisfies $0 < q \\le 1$ and achieves $q=1$ for an equilateral triangle. For a mesh, the average quality is the arithmetic mean of $q$ over all faces.\n\nTask. For each test case described below, compute the average triangle quality before the smoothing sweep, and after the smoothing sweep, and return the difference $\\Delta = \\overline{q}_{\\text{after}} - \\overline{q}_{\\text{before}}$.\n\nDefinitions used in the test cases. Let $\\operatorname{normalize}(\\mathbf{v}) = \\mathbf{v}/\\|\\mathbf{v}\\|_2$ for any nonzero $\\mathbf{v} \\in \\mathbb{R}^3$. Use $R=1$ in all cases. Angles, if any appear, are measured in radians, but no trigonometric input is required; all vertex coordinates are given directly.\n\nTest suite. There are three meshes.\n\nTest case $1$ (one interior vertex and three boundary vertices). Vertices:\n- $\\mathbf{p}_0 = (0,0,1)$,\n- $\\mathbf{p}_1 = \\operatorname{normalize}(1,0,0.2)$,\n- $\\mathbf{p}_2 = \\left(-\\tfrac{1}{2},\\tfrac{\\sqrt{3}}{2},0\\right)$,\n- $\\mathbf{p}_3 = \\left(-\\tfrac{1}{2},-\\tfrac{\\sqrt{3}}{2},0\\right)$.\nFaces: $(0,1,2)$, $(0,2,3)$, $(0,3,1)$.\n\nTest case $2$ (single boundary triangle). Vertices:\n- $\\mathbf{p}_1 = (1,0,0)$,\n- $\\mathbf{p}_2 = \\left(-\\tfrac{1}{2},\\tfrac{\\sqrt{3}}{2},0\\right)$,\n- $\\mathbf{p}_3 = \\left(-\\tfrac{1}{2},-\\tfrac{\\sqrt{3}}{2},0\\right)$.\nFace: $(1,2,3)$.\n\nTest case $3$ (one interior vertex with a four-vertex boundary ring). Vertices:\n- $\\mathbf{p}_c = \\operatorname{normalize}(0.2,-0.1,0.97)$,\n- $\\mathbf{p}_a = \\operatorname{normalize}(0.9,0.0,0.435)$,\n- $\\mathbf{p}_b = \\operatorname{normalize}(0.0,0.9,0.435)$,\n- $\\mathbf{p}_d = \\operatorname{normalize}(-0.9,0.0,0.435)$,\n- $\\mathbf{p}_e = \\operatorname{normalize}(0.0,-0.9,0.435)$.\nFaces: $(c,a,b)$, $(c,b,d)$, $(c,d,e)$, $(c,e,a)$.\n\nRequired final output. Your program should produce a single line of output containing the values of $\\Delta$ for test cases $1$, $2$, and $3$ respectively, in that order, as a comma-separated list enclosed in square brackets. Each $\\Delta$ must be rounded to exactly $6$ digits after the decimal point. For example: \"[$\\Delta_1,\\Delta_2,\\Delta_3$]\" where each $\\Delta_k$ is formatted to $6$ decimal places. No other text should be printed. Units do not apply; report pure real numbers in decimal form.", "solution": "The problem requires performing a single constrained smoothing sweep on several triangular surface meshes and evaluating the change in average element quality. The surface is a unit sphere centered at the origin.\n\nThe solution proceeds in four main stages for each given mesh:\n1.  **Mesh Analysis**: Identify the boundary vertices of the mesh. According to the problem definition, vertices that are part of any edge belonging to only one triangle are considered boundary vertices. All other vertices are interior.\n2.  **Initial Quality Assessment**: Compute the quality of each triangular face in the initial mesh and calculate the average quality, $\\overline{q}_{\\text{before}}$.\n3.  **Constrained Smoothing**: Compute the new positions for all vertices. Boundary vertices remain fixed. For each interior vertex, its new position is found by first solving a constrained optimization problem and then projecting the result back onto the sphere.\n4.  **Final Quality Assessment and Comparison**: Compute the average quality of the smoothed mesh, $\\overline{q}_{\\text{after}}$, using the new vertex positions. The final result is the difference $\\Delta = \\overline{q}_{\\text{after}} - \\overline{q}_{\\text{before}}$.\n\nLet us elaborate on the mathematical and algorithmic details of each stage.\n\n**1. Identification of Boundary Vertices**\n\nA vertex is on the boundary if it is part of an edge that belongs to exactly one face. To implement this, we can count the occurrences of each edge in the mesh. An edge is defined by two vertex indices, $(i, j)$. Since the order does not matter, we use a canonical representation, such as $(\\min(i,j), \\max(i,j))$, to represent the edge. We iterate through all faces of the mesh. For each face $(v_1, v_2, v_3)$, we identify its three edges, $(v_1, v_2)$, $(v_2, v_3)$, and $(v_3, v_1)$, and increment their counts in a hash map or dictionary. After processing all faces, we iterate through the map. Edges with a count of $1$ are boundary edges. The set of all vertices that constitute these boundary edges forms the set of boundary vertices.\n\n**2. Triangle Quality Metric**\n\nThe quality $q$ of a single triangle with vertices $\\mathbf{a}, \\mathbf{b}, \\mathbf{c} \\in \\mathbb{R}^3$ is given by the formula:\n$$\nq(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = \\frac{4\\sqrt{3}\\,A}{\\ell_1^2 + \\ell_2^2 + \\ell_3^2}\n$$\nwhere $A$ is the triangle's area and $\\ell_1, \\ell_2, \\ell_3$ are its edge lengths. The area can be computed using the cross product of two edge vectors:\n$$\nA(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = \\frac{1}{2} \\|(\\mathbf{b}-\\mathbf{a}) \\times (\\mathbf{c}-\\mathbf{a})\\|_2\n$$\nThe edge lengths are given by $\\ell_1 = \\|\\mathbf{b}-\\mathbf{a}\\|_2$, $\\ell_2 = \\|\\mathbf{c}-\\mathbf{b}\\|_2$, and $\\ell_3 = \\|\\mathbf{a}-\\mathbf{c}\\|_2$. This quality metric is normalized such that it equals $1$ for an equilateral triangle and approaches $0$ for a degenerate triangle. The average quality of a mesh is the arithmetic mean of $q$ over all its faces.\n\n**3. Constrained Smoothing Algorithm**\n\nThe smoothing process updates the position of each interior vertex $\\mathbf{p}_i$. Boundary vertices are not moved. The update for an interior vertex $\\mathbf{p}_i$ is a two-step process.\n\n**Step 3.1: Optimal Position on the Tangent Plane**\n\nFirst, we find an intermediate position $\\mathbf{y}_i$ that minimizes the sum of squared distances to its neighboring vertices, under the constraint that $\\mathbf{y}_i$ must lie on the tangent plane to the sphere at $\\mathbf{p}_i$. The objective function to minimize is:\n$$\nf(\\mathbf{y}) = \\sum_{j \\in \\mathcal{N}(i)} \\|\\mathbf{y} - \\mathbf{p}_j\\|_2^2\n$$\nwhere $\\mathcal{N}(i)$ is the set of indices of vertices adjacent to vertex $i$. The unconstrained minimum of this function is the centroid of the neighboring vertices, $\\mathbf{c}_i = \\frac{1}{|\\mathcal{N}(i)|} \\sum_{j \\in \\mathcal{N}(i)} \\mathbf{p}_j$.\n\nThe constraint is that $\\mathbf{y}_i$ must lie in the affine tangent plane $\\mathcal{T}_{\\mathbf{p}_i}\\mathcal{S}$. For the unit sphere ($R=1$) centered at the origin, the unit normal at $\\mathbf{p}_i$ is $\\mathbf{n}(\\mathbf{p}_i) = \\mathbf{p}_i$. The equation of the tangent plane is $(\\mathbf{y} - \\mathbf{p}_i) \\cdot \\mathbf{p}_i = 0$.\n\nThe solution to this constrained minimization problem is the orthogonal projection of the unconstrained minimizer $\\mathbf{c}_i$ onto the tangent plane. The formula for this projection is:\n$$\n\\mathbf{y}_i = \\mathbf{c}_i - ((\\mathbf{c}_i - \\mathbf{p}_i) \\cdot \\mathbf{n}(\\mathbf{p}_i)) \\mathbf{n}(\\mathbf{p}_i)\n$$\nSubstituting $\\mathbf{n}(\\mathbf{p}_i) = \\mathbf{p}_i$ and using the fact that $\\|\\mathbf{p}_i\\|_2=1$ (so $\\mathbf{p}_i \\cdot \\mathbf{p}_i = 1$), we simplify the expression:\n$$\n\\mathbf{y}_i = \\mathbf{c}_i - (\\mathbf{c}_i \\cdot \\mathbf{p}_i - \\mathbf{p}_i \\cdot \\mathbf{p}_i) \\mathbf{p}_i = \\mathbf{c}_i - (\\mathbf{c}_i \\cdot \\mathbf{p}_i - 1) \\mathbf{p}_i\n$$\nThis gives the intermediate position $\\mathbf{y}_i$.\n\n**Step 3.2: Projection back to the Sphere**\n\nThe point $\\mathbf{y}_i$ lies on the tangent plane but not necessarily on the sphere itself. The final updated position $\\mathbf{z}_i$ is obtained by projecting $\\mathbf{y}_i$ radially back onto the unit sphere:\n$$\n\\mathbf{z}_i = \\frac{R}{\\|\\mathbf{y}_i\\|_2}\\,\\mathbf{y}_i = \\frac{\\mathbf{y}_i}{\\|\\mathbf{y}_i\\|_2} \\quad (\\text{since } R=1)\n$$\nThis process is performed for all interior vertices simultaneously, meaning the calculation for each $\\mathbf{z}_i$ uses the original positions $\\{\\mathbf{p}_k\\}$. The new set of vertices for the smoothed mesh is $\\{\\mathbf{z}_i\\}$, where $\\mathbf{z}_i=\\mathbf{p}_i$ if $i$ is a boundary vertex.\n\n**4. Computation**\n\nFor each test case, we implement the following algorithm:\n1.  Define the initial vertex coordinates and face connectivity. All vertices specified with `normalize()` are normalized to have a Euclidean norm of $1$.\n2.  Compute the initial average quality $\\overline{q}_{\\text{before}}$.\n3.  Identify boundary and interior vertices by counting edge sharing among faces. An adjacency list mapping each vertex to its neighbors is also constructed.\n4.  Create a new array for the updated vertex positions, initialized with the original positions.\n5.  Iterate through each interior vertex $i$:\n    a. Calculate the centroid $\\mathbf{c}_i$ of its neighbors using their original positions.\n    b. Calculate the intermediate position $\\mathbf{y}_i$ by projecting $\\mathbf{c}_i$ onto the tangent plane at $\\mathbf{p}_i$.\n    c. Calculate the final position $\\mathbf{z}_i$ by normalizing $\\mathbf{y}_i$.\n    d. Store $\\mathbf{z}_i$ in the new positions array.\n6.  Compute the final average quality $\\overline{q}_{\\text{after}}$ using the updated vertex positions and the original face connectivity.\n7.  Calculate and record the difference $\\Delta = \\overline{q}_{\\text{after}} - \\overline{q}_{\\text{before}}$.\n\nThis procedure is applied to all three test cases to obtain the required values of $\\Delta$. For Test Case 2, all vertices are on the boundary, so no smoothing occurs, and thus $\\Delta = 0$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the mesh smoothing problem for all test cases.\n    \"\"\"\n\n    def normalize(v):\n        \"\"\" Normalizes a 3D vector to unit length. \"\"\"\n        norm = np.linalg.norm(v)\n        if norm == 0:\n            return v\n        return v / norm\n\n    def get_triangle_quality(a, b, c):\n        \"\"\" Calculates the quality of a single triangle. \"\"\"\n        l1_sq = np.sum((b - a)**2)\n        l2_sq = np.sum((c - b)**2)\n        l3_sq = np.sum((a - c)**2)\n        \n        sum_l_sq = l1_sq + l2_sq + l3_sq\n        if sum_l_sq == 0:\n            return 0.0\n\n        area = 0.5 * np.linalg.norm(np.cross(b - a, c - a))\n        \n        quality = (4.0 * np.sqrt(3.0) * area) / sum_l_sq\n        return quality\n\n    def get_avg_quality(vertices, faces):\n        \"\"\" Calculates the average quality of all triangles in a mesh. \"\"\"\n        if not faces:\n            return 0.0\n        total_quality = sum(get_triangle_quality(vertices[i], vertices[j], vertices[k]) for i, j, k in faces)\n        return total_quality / len(faces)\n\n    def get_mesh_info(num_vertices, faces):\n        \"\"\" Identifies boundary vertices and creates an adjacency list. \"\"\"\n        adj = {i: set() for i in range(num_vertices)}\n        edge_counts = {}\n        for i, j, k in faces:\n            edges = [tuple(sorted((i, j))), tuple(sorted((j, k))), tuple(sorted((k, i)))]\n            for edge in edges:\n                edge_counts[edge] = edge_counts.get(edge, 0) + 1\n            adj[i].update([j, k])\n            adj[j].update([i, k])\n            adj[k].update([i, j])\n\n        boundary_edges = {edge for edge, count in edge_counts.items() if count == 1}\n        boundary_vertices = set()\n        for i, j in boundary_edges:\n            boundary_vertices.add(i)\n            boundary_vertices.add(j)\n        \n        return adj, boundary_vertices\n\n    def process_case(vertices, faces_map):\n        \"\"\"\n        Processes a single test case: computes initial quality, performs smoothing,\n        computes final quality, and returns the difference.\n        \"\"\"\n        # Map faces to 0-based indices\n        faces = []\n        for face_tuple in faces_map:\n            faces.append(tuple(face_tuple))\n\n        num_vertices = len(vertices)\n        \n        # Calculate initial average quality\n        q_before = get_avg_quality(vertices, faces)\n\n        # Get adjacency list and boundary vertices\n        adj, boundary_vertices = get_mesh_info(num_vertices, faces)\n        \n        # Perform one smoothing sweep\n        new_vertices = np.copy(vertices)\n        interior_vertices = set(range(num_vertices)) - boundary_vertices\n\n        for i in interior_vertices:\n            p_i = vertices[i]\n            neighbors = list(adj[i])\n            \n            if not neighbors:\n                continue\n\n            # Calculate centroid of neighbors\n            neighbor_coords = np.array([vertices[j] for j in neighbors])\n            c_i = np.mean(neighbor_coords, axis=0)\n\n            # Project centroid onto the tangent plane at p_i (R=1)\n            # y_i = c_i - (<c_i - p_i, p_i>) * p_i\n            # y_i = c_i - (<c_i, p_i> - <p_i, p_i>) * p_i\n            # Since ||p_i||=1, <p_i,p_i>=1\n            y_i = c_i - (np.dot(c_i, p_i) - 1) * p_i\n            \n            # Project y_i back to the sphere\n            z_i = normalize(y_i)\n            new_vertices[i] = z_i\n\n        # Calculate final average quality\n        q_after = get_avg_quality(new_vertices, faces)\n\n        return q_after - q_before\n\n    # --- Test Case 1 ---\n    v0 = np.array([0.0, 0.0, 1.0])\n    v1 = normalize(np.array([1.0, 0.0, 0.2]))\n    v2 = np.array([-0.5, np.sqrt(3.0)/2.0, 0.0])\n    v3 = np.array([-0.5, -np.sqrt(3.0)/2.0, 0.0])\n    vertices1 = np.array([v0, v1, v2, v3])\n    faces1 = [(0, 1, 2), (0, 2, 3), (0, 3, 1)]\n    delta1 = process_case(vertices1, faces1)\n\n    # --- Test Case 2 ---\n    v1_tc2 = np.array([1.0, 0.0, 0.0])\n    v2_tc2 = np.array([-0.5, np.sqrt(3.0)/2.0, 0.0])\n    v3_tc2 = np.array([-0.5, -np.sqrt(3.0)/2.0, 0.0])\n    vertices2 = np.array([v1_tc2, v2_tc2, v3_tc2])\n    faces2 = [(0, 1, 2)]\n    delta2 = process_case(vertices2, faces2)\n\n    # --- Test Case 3 ---\n    vc = normalize(np.array([0.2, -0.1, 0.97]))\n    va = normalize(np.array([0.9, 0.0, 0.435]))\n    vb = normalize(np.array([0.0, 0.9, 0.435]))\n    vd = normalize(np.array([-0.9, 0.0, 0.435]))\n    ve = normalize(np.array([0.0, -0.9, 0.435]))\n    vertices3 = np.array([vc, va, vb, vd, ve])\n    # Mapping: c:0, a:1, b:2, d:3, e:4\n    faces3 = [(0, 1, 2), (0, 2, 3), (0, 3, 4), (0, 4, 1)]\n    delta3 = process_case(vertices3, faces3)\n    \n    results = [delta1, delta2, delta3]\n    formatted_results = [\"{:.6f}\".format(d) for d in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}