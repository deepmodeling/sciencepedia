{"hands_on_practices": [{"introduction": "We begin our hands-on exploration with the cornerstone of Godunov-type methods. This practice focuses on the one-dimensional linear advection equation, $u_t + a u_x = 0$, which serves as the fundamental prototype for all hyperbolic conservation laws. You will implement the Godunov method in its purest form by solving the exact Riemann problem at each cell interface, which for this simple equation, gives rise to the celebrated first-order upwind scheme. This exercise is essential for building the foundational understanding and coding framework upon which more complex solvers are built.[@problem_id:2448979]", "problem": "Consider the one-dimensional linear advection equation on the periodic domain $\\Omega = [0,1]$,\n$$\nu_t + a\\,u_x = 0,\n$$\nwith constant advection speed $a \\in \\mathbb{R}$ and initial condition $u(x,0) = u_0(x)$, where $x \\in \\Omega$ and $t \\ge 0$. Let the spatial grid be uniform with $N$ cells of width $\\Delta x = 1/N$ and cell centers $x_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta x$ for $i = 0,1,\\dots,N-1$. Let the method evolve cell averages $u_i^n$ at time levels $t^n$, in a conservative finite-volume form using numerical fluxes computed from the exact self-similar solution of the local Riemann problem at each cell interface. Enforce periodicity at $x=0$ and $x=1$. The time step $\\Delta t$ must satisfy the Courant–Friedrichs–Lewy (CFL) condition $|a|\\,\\Delta t \\le \\Delta x$, with a chosen Courant number $\\nu \\in (0,1]$ so that $\\Delta t = \\nu \\,\\Delta x/|a|$ when $|a|>0$, and any $\\Delta t>0$ when $a=0$. When the final time $T$ is not an integer multiple of $\\Delta t$, the last step must be shortened to land exactly at $t=T$. The exact solution is the periodic shift $u(x,T) = u_0((x - aT) \\pmod 1)$. Measure the discrete $L^1$ error at $t=T$ as\n$$\nE_{L^1} = \\sum_{i=0}^{N-1} \\left| u_i(T) - u_0((x_i - aT) \\pmod 1) \\right|\\,\\Delta x.\n$$\n\nYour program must, for each test case below, compute the numerical solution at time $T$ and output the corresponding $E_{L^1}$ as a floating-point number. No physical units are involved. Angles, where present in trigonometric functions, are in radians.\n\nTest suite:\n- Case $1$ (discontinuous profile, positive speed): $a=1$, $N=200$, $\\nu=0.9$, $T=0.25$, with\n  $$\n  u_0(x) = \\begin{cases}\n  1, & 0.1 \\le x < 0.3,\\\\\n  0, & \\text{otherwise},\n  \\end{cases}\n  $$\n  interpreted periodically on $[0,1]$.\n- Case $2$ (smooth profile, negative speed): $a=-0.7$, $N=200$, $\\nu=0.9$, $T=0.4$, with\n  $$\n  u_0(x) = \\sin(2\\pi x).\n  $$\n- Case $3$ (zero speed edge case): $a=0$, $N=200$, $\\nu=0.9$, $T=0.3$, with\n  $$\n  u_0(x) = \\begin{cases}\n  1, & x < 0.5,\\\\\n  0, & x \\ge 0.5,\n  \\end{cases}\n  $$\n  interpreted periodically on $[0,1]$.\n- Case $4$ (stability boundary $\\nu=1$): $a=1$, $N=100$, $\\nu=1$, $T=0.37$, with\n  $\n  u_0(x) = \\cos(2\\pi x).\n  $\n\nFinal output format: Your program should produce a single line of output containing the four $L^1$ errors in the order of Cases $1$ through $4$, formatted as a comma-separated list enclosed in square brackets. Each floating-point value must be rounded to $8$ decimal places. For example, an output with placeholder values would look like\n$\n[\\!0.12345678,0.00000000,0.31415927,0.27182818\\!].\n$", "solution": "The problem requires the numerical solution of the one-dimensional linear advection equation,\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\non a periodic domain $\\Omega = [0,1]$ with a constant advection speed $a \\in \\mathbb{R}$. The initial condition is given by $u(x,0) = u_0(x)$. We are to employ a conservative finite-volume method.\n\nThis problem is a standard, well-posed problem in computational fluid dynamics and is scientifically sound. It describes the first-order upwind method, a fundamental scheme for hyperbolic conservation laws. All parameters, conditions, and objectives are clearly defined and consistent. The problem is valid.\n\nThe solution proceeds as follows:\n\nFirst, we discretize the spatial domain $\\Omega$ into $N$ uniform cells, $C_i = [x_{i-1/2}, x_{i+1/2}]$ for $i=0, \\dots, N-1$. The width of each cell is $\\Delta x = 1/N$. The cell interfaces are located at $x_{i+1/2} = (i+1)\\Delta x$. The cell centers are $x_i = (i+1/2)\\Delta x$. The numerical solution consists of cell averages at discrete time levels $t^n$:\n$$\nu_i^n \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x, t^n) \\, dx.\n$$\nIntegrating the PDE over cell $C_i$ and over the time interval $[t^n, t^{n+1}]$ yields the exact relation for the cell average:\n$$\nu_i^{n+1} = u_i^n - \\frac{1}{\\Delta x} \\int_{t^n}^{t^{n+1}} \\left( f(u(x_{i+1/2}, t)) - f(u(x_{i-1/2}, t)) \\right) dt,\n$$\nwhere $f(u) = au$ is the flux function for the linear advection equation.Approximating the time integral with a single evaluation at $t^n$ leads to the semi-discrete conservative form:\n$$\n\\frac{du_i}{dt} = -\\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2}),\n$$\nwhere $F_{i+1/2}$ and $F_{i-1/2}$ are the numerical fluxes at the cell interfaces. A forward Euler time integration gives the fully-discrete form:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2}^n - F_{i-1/2}^n).\n$$\nThe problem specifies that the numerical flux is to be determined from the exact solution of the local Riemann problem at each interface. This defines the Godunov method. For the linear advection equation, the solution to the Riemann problem with initial states $u_L$ and $u_R$ is $u(x/t) = u_L$ for $x/t < a$ and $u(x/t) = u_R$ for $x/t > a$. The value at the interface ($x/t=0$) is taken from the upwind direction.\nThus, the state at interface $x_{i+1/2}$ is $u_{i+1/2} = u_i^n$ if $a>0$ and $u_{i+1/2} = u_{i+1}^n$ if $a<0$.\nThe numerical flux $F_{i+1/2}^n = f(u_{i+1/2}) = a u_{i+1/2}$ is therefore:\n$$\nF_{i+1/2}^n = \\begin{cases}\na u_i^n, & a > 0, \\\\\na u_{i+1}^n, & a < 0, \\\\\n0, & a = 0.\n\\end{cases}\n$$\nThis is the first-order upwind flux.\n\nThe update scheme differs for the sign of $a$:\nCase $1$: $a > 0$. The flux difference is $F_{i+1/2}^n - F_{i-1/2}^n = a u_i^n - a u_{i-1}^n$. The update scheme is:\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n).\n$$\nCase $2$: $a < 0$. The flux difference is $F_{i+1/2}^n - F_{i-1/2}^n = a u_{i+1}^n - a u_i^n$. The update scheme is:\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n).\n$$\nCase $3$: $a=0$. The flux is zero, so $u_i^{n+1} = u_i^n$. The solution is static.\n\nThe Courant number is defined as $\\nu = |a| \\Delta t / \\Delta x$. The update schemes can be written in terms of $\\nu$:\nFor $a > 0$: $u_i^{n+1} = u_i^n - \\nu (u_i^n - u_{i-1}^n)$.\nFor $a < 0$: $u_i^{n+1} = u_i^n + \\nu (u_{i+1}^n - u_i^n)$, since $a\\Delta t/\\Delta x = -|a|\\Delta t/\\Delta x = -\\nu$.\nPeriodic boundary conditions mean that indices are handled modulo $N$, i.e., $u_{-1}^n = u_{N-1}^n$ and $u_N^n = u_0^n$.\n\nThe time step is $\\Delta t = \\nu \\Delta x / |a|$ for $a \\neq 0$. The simulation runs from $t=0$ to $t=T$. If $T$ is not an integer multiple of $\\Delta t$, the final time step is adjusted to be smaller, $T - t^n$, to land exactly on the final time.\n\nThe initial cell averages $u_i^0$ are formally given by $u_i^0 = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} u_0(x) \\, dx$. For the smooth initial profiles (Cases $2$ and $4$), a second-order accurate approximation is $u_i^0 \\approx u_0(x_i)$. For the discontinuous profiles (Cases $1$ and $3$), the discontinuities are aligned with the grid interfaces, i.e., they occur at integer multiples of $\\Delta x$. In such a special case, the cell-averaged value $u_i^0$ is exactly equal to the point value at the cell center, $u_0(x_i)$. Thus, for all given test cases, we can initialize the solution by point-wise sampling: $u_i^0 = u_0(x_i)$.\n\nFinally, the discrete $L^1$ error is computed at $t=T$ by comparing the numerical solution $u_i(T)$ with the exact solution evaluated at the cell centers. The exact solution is $u(x,T) = u_0((x - aT) \\pmod 1)$. The error is:\n$$\nE_{L^1} = \\sum_{i=0}^{N-1} \\left| u_i(T) - u_0((x_i - aT) \\pmod 1) \\right|\\,\\Delta x.\n$$\nThe modulo operator ensures the argument of $u_0$ is mapped back into the domain $[0,1]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using a first-order upwind\n    finite volume method for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: a=1, N=200, nu=0.9, T=0.25, u0=square pulse\n        {\n            \"a\": 1.0, \"N\": 200, \"nu\": 0.9, \"T\": 0.25,\n            \"u0_func\": lambda x: np.where((x >= 0.1) & (x < 0.3), 1.0, 0.0),\n        },\n        # Case 2: a=-0.7, N=200, nu=0.9, T=0.4, u0=sine wave\n        {\n            \"a\": -0.7, \"N\": 200, \"nu\": 0.9, \"T\": 0.4,\n            \"u0_func\": lambda x: np.sin(2 * np.pi * x),\n        },\n        # Case 3: a=0, N=200, nu=0.9, T=0.3, u0=step function\n        {\n            \"a\": 0.0, \"N\": 200, \"nu\": 0.9, \"T\": 0.3,\n            \"u0_func\": lambda x: np.where(x < 0.5, 1.0, 0.0),\n        },\n        # Case 4: a=1, N=100, nu=1, T=0.37, u0=cosine wave\n        {\n            \"a\": 1.0, \"N\": 100, \"nu\": 1.0, \"T\": 0.37,\n            \"u0_func\": lambda x: np.cos(2 * np.pi * x),\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a = case[\"a\"]\n        N = case[\"N\"]\n        nu = case[\"nu\"]\n        T = case[\"T\"]\n        u0_func = case[\"u0_func\"]\n\n        # Spatial grid setup\n        dx = 1.0 / N\n        x = (np.arange(N) + 0.5) * dx\n\n        # Initialization of cell averages\n        # For the given problems, discontinuities are grid-aligned, so a\n        # point-wise sampling at cell centers is equivalent to cell-averaging.\n        u = u0_func(x)\n\n        t = 0.0\n\n        if a == 0.0:\n            # For a=0, the solution is static. u(T) is the same as u(0).\n            # No time stepping is necessary.\n            pass\n        else:\n            # Time step based on CFL condition\n            dt = nu * dx / abs(a)\n            \n            # Time-stepping loop\n            while t < T:\n                # Ensure the last step lands exactly on T\n                current_dt = min(dt, T - t)\n                \n                # The upwind scheme is implemented using vector operations and np.roll\n                # for efficient handling of periodic boundary conditions.\n                if a > 0:\n                    # Information propagates from left to right (increasing index)\n                    # Flux at interface i+1/2 is F = a * u_i\n                    # Update: u_i^{n+1} = u_i^n - (dt/dx) * (F_{i+1/2} - F_{i-1/2})\n                    # F_{i-1/2} corresponds to flux from u_{i-1}\n                    u_left = np.roll(u, 1)\n                    u = u - (a * current_dt / dx) * (u - u_left)\n                else: # a < 0\n                    # Information propagates from right to left (decreasing index)\n                    # Flux at interface i+1/2 is F = a * u_{i+1}\n                    # Update: u_i^{n+1} = u_i^n - (dt/dx) * (F_{i+1/2} - F_{i-1/2})\n                    # F_{i-1/2} corresponds to flux from u_i\n                    u_right = np.roll(u, -1)\n                    u = u - (a * current_dt / dx) * (u_right - u)\n                \n                t += current_dt\n\n        # Calculate exact solution at time T at cell centers\n        # The Python modulo operator % handles negative arguments correctly for this periodic domain.\n        x_shifted = (x - a * T) % 1.0\n        u_exact = u0_func(x_shifted)\n        \n        # Calculate discrete L1 error\n        l1_error = np.sum(np.abs(u - u_exact)) * dx\n        results.append(l1_error)\n\n    # Format the output as specified\n    formatted_results = [f\"{r:.8f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2448979"}, {"introduction": "Having implemented a basic Godunov scheme, the next step is to analyze its performance and understand its characteristic properties. All numerical schemes introduce errors, and for first-order upwind methods, the most prominent is numerical dissipation, which tends to smear sharp gradients over time. This practice introduces a critical diagnostic tool, the Total Variation (TV), to quantify this effect. You will compare the Godunov scheme to the classic Lax-Friedrichs scheme, observing firsthand how different flux approximations lead to drastically different levels of dissipation for an advected square wave.[@problem_id:2397651]", "problem": "Consider the scalar linear advection equation $u_t + a\\,u_x = 0$ on the periodic domain $x \\in [0,L)$ with constant advection speed $a \\in \\mathbb{R}$. The initial condition is a single square wave (top-hat) defined by\n$$\nu(x,0) = \\begin{cases}\nu_{\\text{high}}, & \\text{if } (x - x_0) \\bmod L \\in [0,w),\\\\\nu_{\\text{low}}, & \\text{otherwise},\n\\end{cases}\n$$\nwhere $L$, $x_0$, $w$, $u_{\\text{low}}$, and $u_{\\text{high}}$ are given constants. The spatial domain is partitioned into $M$ uniform cells of width $\\Delta x = L/M$, and the cell centers are $x_i = (i + \\tfrac{1}{2})\\,\\Delta x$ for $i \\in \\{0,1,\\dots,M-1\\}$. Assume periodic boundary conditions.\n\nEvolve the cell averages from time $t=0$ to the final time $T = L/|a|$ (one advection period) using two different conservative finite volume discretizations: the first-order Godunov scheme and the Lax–Friedrichs scheme. The time step $\\Delta t$ is set from the Courant–Friedrichs–Lewy (CFL) number by $\\text{CFL} = \\dfrac{|a|\\,\\Delta t}{\\Delta x}$. Use exactly $N = T/\\Delta t$ time steps, which is guaranteed to be an integer for the test cases below.\n\nFor each scheme, quantify numerical dissipation by the relative total variation\n$$\nR = \\frac{\\operatorname{TV}(u(\\cdot,T))}{\\operatorname{TV}(u(\\cdot,0))},\n$$\nwhere for a periodic grid function $\\{u_i\\}_{i=0}^{M-1}$,\n$$\n\\operatorname{TV}(u) = \\sum_{i=0}^{M-1} \\left|u_{i} - u_{i-1}\\right|, \\quad \\text{with the convention } u_{-1} \\equiv u_{M-1}.\n$$\nThe smaller the value of $R$, the more dissipative the scheme. Compute and report, for each test case, the pair of floats $[R_{\\text{Godunov}}, R_{\\text{LaxFriedrichs}}]$. Each reported float must be rounded to $6$ decimal places.\n\nTest suite (use these values exactly):\n- Global constants for all cases: $L = 1$, $x_0 = 0.1$, $u_{\\text{low}} = 0$, $u_{\\text{high}} = 1$.\n- Case A: $M = 200$, $a = 1$, $\\text{CFL} = 0.5$, $w = 0.2$.\n- Case B: $M = 120$, $a = 1$, $\\text{CFL} = 0.8$, $w = 0.1$.\n- Case C: $M = 180$, $a = -1$, $\\text{CFL} = 0.9$, $w = 0.33$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the two-float list for a case in the same order A, B, C. For example, the format must be\n$[[R_{\\text{Godunov},A},R_{\\text{LaxFriedrichs},A}],[R_{\\text{Godunov},B},R_{\\text{LaxFriedrichs},B}],[R_{\\text{Godunov},C},R_{\\text{LaxFriedrichs},C}]]$\nwith each $R$ rounded to $6$ decimal places and no additional text.", "solution": "The problem requires the numerical solution of the scalar linear advection equation, a prototype for hyperbolic conservation laws. The equation is given by\n$$u_t + a\\,u_x = 0$$\non a periodic spatial domain $x \\in [0,L)$. The flux function for this conservation law is $f(u) = a\\,u$. The problem is to be solved using a conservative finite volume method, which in one dimension takes the general form\n$$U_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)$$\nHere, $U_i^n$ is the average value of the solution in cell $i$ at time $t_n = n\\Delta t$, $\\Delta x$ is the uniform cell width, $\\Delta t$ is the time step, and $F_{i+1/2}$ is the numerical flux at the interface between cell $i$ and cell $i+1$.\n\nFirst, we must discretize the initial condition. The continuous initial state is a square wave,\n$$\nu(x,0) = \\begin{cases}\nu_{\\text{high}}, & \\text{if } (x - x_0) \\bmod L \\in [0,w),\\\\\nu_{\\text{low}}, & \\text{otherwise}.\n\\end{cases}\n$$\nThe domain $[0,L)$ is partitioned into $M$ cells, where cell $i$ covers the spatial interval $[i\\Delta x, (i+1)\\Delta x)$ for $i \\in \\{0, 1, \\dots, M-1\\}$, with $\\Delta x=L/M$. The initial cell averages $U_i^0$ are computed by integrating $u(x,0)$ over each cell:\n$$U_i^0 = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} u(x,0) \\,dx$$\nThis integral computes the volume of the intersection between the cell interval and the region where $u=u_{\\text{high}}$. For a wave defined on $[x_0, x_0+w)$, the overlap length with cell $i$ is $\\max(0, \\min((i+1)\\Delta x, x_0+w) - \\max(i\\Delta x, x_0))$. The cell average is then $U_i^0 = u_{\\text{low}} + (u_{\\text{high}} - u_{\\text{low}}) \\frac{\\text{overlap length}}{\\Delta x}$.\n\nThe time evolution is performed using two different schemes, defined by their numerical flux functions.\n\n1.  **Godunov Scheme**: This is an upwind scheme. The numerical flux is determined by the solution to the Riemann problem at the cell interface. For the linear advection equation, the characteristic speed is constant ($a$), so the information flows from the left if $a>0$ and from the right if $a<0$. The resulting flux is\n    $$F_{i+1/2}^{\\text{Godunov}} = \\begin{cases} f(U_i^n) = a\\,U_i^n, & \\text{if } a \\geq 0 \\\\ f(U_{i+1}^n) = a\\,U_{i+1}^n, & \\text{if } a < 0 \\end{cases}$$\n    The update rule can be written as:\n    $$U_i^{n+1} = U_i^n - \\frac{a \\Delta t}{\\Delta x}(U_i^n - U_{i-1}^n), \\quad \\text{for } a \\geq 0$$\n    $$U_i^{n+1} = U_i^n - \\frac{a \\Delta t}{\\Delta x}(U_{i+1}^n - U_i^n), \\quad \\text{for } a < 0$$\n    Using the Courant number $\\nu = a \\frac{\\Delta t}{\\Delta x}$, where $|\\nu|$ is the CFL number, this is $U_i^{n+1} = U_i^n - \\nu(U_i^n - U_{i-1}^n)$ for $a \\geq 0$ and $U_i^{n+1} = U_i^n - \\nu(U_{i+1}^n - U_i^n)$ for $a < 0$.\n\n2.  **Lax–Friedrichs Scheme**: This scheme introduces significant numerical dissipation by averaging adjacent states. The numerical flux is\n    $$F_{i+1/2}^{\\text{LF}} = \\frac{1}{2}\\left( f(U_i^n) + f(U_{i+1}^n) \\right) - \\frac{1}{2}\\frac{\\Delta x}{\\Delta t}\\left( U_{i+1}^n - U_i^n \\right)$$\n    Substituting this flux into the conservative update formula yields the direct update rule:\n    $$U_i^{n+1} = \\frac{1}{2}(U_{i+1}^n + U_{i-1}^n) - \\frac{a \\Delta t}{2 \\Delta x}(U_{i+1}^n - U_{i-1}^n)$$\n    Using the Courant number $\\nu = a \\frac{\\Delta t}{\\Delta x}$, this becomes $U_i^{n+1} = \\frac{1}{2}(U_{i+1}^n + U_{i-1}^n) - \\frac{\\nu}{2}(U_{i+1}^n - U_{i-1}^n)$.\n\nThe solution is evolved from $t=0$ to the final time $T=L/|a|$, which corresponds to one full advection period. The number of time steps is $N = T/\\Delta t = (L/|a|)/(\\text{CFL} \\cdot \\Delta x/|a|) = L/(\\text{CFL} \\cdot L/M) = M/\\text{CFL}$, which is an integer for all test cases.\n\nTo quantify numerical dissipation, we compute the total variation (TV) of the discrete solution $\\{u_i\\}_{i=0}^{M-1}$ as\n$$\\operatorname{TV}(u) = \\sum_{i=0}^{M-1} |u_i - u_{i-1}|$$\nwhere periodicity implies $u_{-1} \\equiv u_{M-1}$. The exact solution at time $T$ is identical to the initial condition due to the periodic advection, so its total variation is unchanged. Numerical schemes, however, introduce dissipation which typically reduces the total variation of the solution, smearing sharp gradients. We compute the initial total variation $\\operatorname{TV}(U^0)$ and the final total variation $\\operatorname{TV}(U^N)$. The relative total variation, $R = \\operatorname{TV}(U^N) / \\operatorname{TV}(U^0)$, serves as the metric for dissipation. A value of $R$ close to $1$ indicates low dissipation, while a smaller value indicates higher dissipation. We will compute this ratio $R$ for both schemes for each specified test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linear advection problem using Godunov and Lax-Friedrichs schemes\n    and computes the relative total variation for a set of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: M = 200, a = 1, CFL = 0.5, w = 0.2\n        {'M': 200, 'a': 1.0, 'CFL': 0.5, 'w': 0.2},\n        # Case B: M = 120, a = 1, CFL = 0.8, w = 0.1\n        {'M': 120, 'a': 1.0, 'CFL': 0.8, 'w': 0.1},\n        # Case C: M = 180, a = -1, CFL = 0.9, w = 0.33\n        {'M': 180, 'a': -1.0, 'CFL': 0.9, 'w': 0.33},\n    ]\n    \n    # Global constants\n    L = 1.0\n    x0 = 0.1\n    u_low = 0.0\n    u_high = 1.0\n\n    results = []\n\n    for case in test_cases:\n        M = case['M']\n        a = case['a']\n        CFL = case['CFL']\n        w = case['w']\n\n        # Discretization parameters\n        dx = L / M\n        T = L / abs(a)\n        dt = CFL * dx / abs(a)\n        N = int(round(T / dt)) # Ensure integer number of steps\n\n        # Initialize cell averages U0\n        U0 = np.full(M, u_low)\n        x_cells_L = np.arange(M) * dx\n        x_cells_R = x_cells_L + dx\n        \n        # Wave region (assuming no wrap-around for given x0, w, L)\n        wave_start = x0\n        wave_end = x0 + w\n\n        for i in range(M):\n            # Calculate overlap length of cell i with the wave region\n            overlap = max(0, min(x_cells_R[i], wave_end) - max(x_cells_L[i], wave_start))\n            if overlap > 0:\n                U0[i] = u_low + (u_high - u_low) * overlap / dx\n\n        # Function to calculate Total Variation\n        def calculate_tv(u):\n            # The convention u_{-1} = u_{M-1} is handled by np.roll\n            return np.sum(np.abs(u - np.roll(u, 1)))\n\n        tv0 = calculate_tv(U0)\n\n        # Evolve solution for both schemes\n        U_godunov = np.copy(U0)\n        U_lf = np.copy(U0)\n        \n        # Courant number nu = a * dt / dx\n        nu = a * dt / dx\n\n        for _ in range(N):\n            # --- Godunov (Upwind) Scheme ---\n            U_prev_g = np.roll(U_godunov, 1)\n            U_next_g = np.roll(U_godunov, -1)\n            if a >= 0:\n                U_godunov = U_godunov - nu * (U_godunov - U_prev_g)\n            else: # a < 0\n                U_godunov = U_godunov - nu * (U_next_g - U_godunov)\n\n            # --- Lax-Friedrichs Scheme ---\n            U_prev_lf = np.roll(U_lf, 1)\n            U_next_lf = np.roll(U_lf, -1)\n            U_lf = 0.5 * (U_next_lf + U_prev_lf) - 0.5 * nu * (U_next_lf - U_prev_lf)\n\n        # Calculate final total variations\n        tvf_godunov = calculate_tv(U_godunov)\n        tvf_lf = calculate_tv(U_lf)\n\n        # Calculate relative total variation R\n        R_godunov = tvf_godunov / tv0 if tv0 != 0 else 0\n        R_lf = tvf_lf / tv0 if tv0 != 0 else 0\n        \n        # Round and append results\n        results.append([round(R_godunov, 6), round(R_lf, 6)])\n\n    # Format the final output string\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2397651"}, {"introduction": "We now advance from simple scalar equations to the nonlinear Euler equations of gas dynamics, a system that governs phenomena from aerospace engineering to astrophysics. For such complex systems, the exact Riemann problem is too costly to solve in practice, which motivates the use of *approximate* Riemann solvers. This exercise challenges you to implement and compare two of the most influential approximate solvers: the Harten-Lax-van Leer (HLL) solver and its successor, the HLL-Contact (HLLC) solver. By simulating a stationary contact discontinuity—a wave composed of a density jump with uniform pressure and velocity—you will uncover a key deficiency in the HLL method and appreciate the elegant fix provided by the HLLC formulation, highlighting the ingenuity required to accurately capture complex fluid dynamics.[@problem_id:2397623]", "problem": "Implement a one-step first-order Godunov finite-volume update for the one-dimensional compressible Euler equations using two approximate Riemann solvers: the Harten-Lax-van Leer (HLL) solver and the Harten-Lax-van Leer-Contact (HLLC) solver. The goal is to demonstrate, from first principles, that the HLL solver incorrectly diffuses a stationary contact discontinuity while the HLLC solver resolves it exactly.\n\nBegin from the fundamental conservation laws in one space dimension for mass, momentum, and energy, written in conservative form with state vector $U$ and flux $F(U)$:\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0,\n$$\nwhere for the Euler equations,\n$$\nU = \n\\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\nE\n\\end{bmatrix},\n\\quad\nF(U) = \n\\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\nu (E + p)\n\\end{bmatrix},\n$$\nand the total energy satisfies\n$$\nE = \\frac{p}{\\gamma - 1} + \\frac{1}{2}\\rho u^2.\n$$\nAssume an ideal gas with ratio of specific heats $\\gamma$. Use a uniform grid of $N$ cells on a unit-length domain with cell width $\\Delta x = 1/N$. The first-order Godunov update for cell $i$ over a time step $\\Delta t$ is\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\nwhere $F_{i+\\frac{1}{2}}$ is the numerical flux obtained by solving a Riemann problem between left state $U_i^n$ and right state $U_{i+1}^n$ with an approximate Riemann solver.\n\nYou must implement both the HLL and HLLC numerical fluxes using wave-speed estimates based on bounding characteristic speeds. You must also implement transmissive (zero-gradient) boundary conditions using one ghost cell on each side.\n\nDesign the numerical time step using the Courant-Friedrichs-Lewy (CFL) condition:\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{\\max_i \\left(|u_i| + a_i\\right)},\n\\quad a_i = \\sqrt{\\gamma \\frac{p_i}{\\rho_i}}.\n$$\nAll quantities are non-dimensional; no physical units are required.\n\nYour program must perform a single explicit Godunov time step for each test case and report whether the expected phenomenon occurs: the HLL solver diffuses a stationary contact while the HLLC solver preserves it exactly. To quantify diffusion, use the total variation in density after one step,\n$$\n\\Delta \\rho_{\\text{L1}} = \\sum_{i=1}^{N} \\left|\\rho_i^{n+1} - \\rho_i^n\\right|.\n$$\nFor a perfectly stationary contact aligned with a cell face and uniform pressure and velocity, the HLLC flux should yield $\\Delta \\rho_{\\text{L1}} \\approx 0$, whereas the HLL flux should yield $\\Delta \\rho_{\\text{L1}} > 0$. Use a numerical tolerance $10^{-12}$ to decide equality to zero.\n\nTest Suite:\nFor each test case, initialize primitive variables $(\\rho, u, p)$ piecewise-constantly with a discontinuity at the domain midpoint $x = 0.5$. The left state $(\\rho_L, u_L, p_L)$ fills cells with centers $x < 0.5$ and the right state $(\\rho_R, u_R, p_R)$ fills cells with centers $x \\ge 0.5$. Use $\\gamma = 1.4$, $N = 10$, and $\\text{CFL} = 0.4$. The four test cases are:\n\n- Case A (stationary contact, moderate jump): $(\\rho_L, u_L, p_L, \\rho_R, u_R, p_R) = (1.0, 0.0, 1.0, 0.125, 0.0, 1.0)$.\n- Case B (stationary contact, strong jump): $(\\rho_L, u_L, p_L, \\rho_R, u_R, p_R) = (10.0, 0.0, 1.0, 0.1, 0.0, 1.0)$.\n- Case C (no discontinuity): $(\\rho_L, u_L, p_L, \\rho_R, u_R, p_R) = (1.0, 0.0, 1.0, 1.0, 0.0, 1.0)$.\n- Case D (stationary contact, weak jump): $(\\rho_L, u_L, p_L, \\rho_R, u_R, p_R) = (1.0, 0.0, 1.0, 0.8, 0.0, 1.0)$.\n\nFor each case, compute a one-step update with HLL and with HLLC. Then return a boolean for the case defined as\n$$\n\\text{result} = \\left(\\Delta \\rho_{\\text{L1}}^{\\text{HLL}} > 10^{-12}\\right) \\wedge \\left(\\Delta \\rho_{\\text{L1}}^{\\text{HLLC}} \\le 10^{-12}\\right).\n$$\nThis boolean should be true for Cases A, B, and D, and false for Case C.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets, for example $[\\text{true},\\text{false},\\text{true},\\text{true}]$ using the native boolean literals of your language.", "solution": "This document presents a validation and subsequent solution to the problem of implementing a one-step first-order Godunov finite-volume update for the one-dimensional compressible Euler equations. The objective is to demonstrate, from first principles, the differing behaviors of the Harten-Lax-van Leer (HLL) and Harten-Lax-van Leer-Contact (HLLC) approximate Riemann solvers when applied to a stationary contact discontinuity.\n\nThe problem is first subjected to a rigorous validation process.\n\n**Problem Validation**\n\n**Step 1: Extracted Givens**\n- **Governing Equations**: The one-dimensional Euler equations in conservative form:\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0\n$$\n- **State and Flux Vectors**:\n$$\nU = \n\\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\nE\n\\end{bmatrix},\n\\quad\nF(U) = \n\\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\nu (E + p)\n\\end{bmatrix}\n$$\n- **Equation of State**: For an ideal gas with ratio of specific heats $\\gamma$:\n$$\nE = \\frac{p}{\\gamma - 1} + \\frac{1}{2}\\rho u^2\n$$\n- **Numerical Scheme**: First-order Godunov finite-volume method:\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right)\n$$\n- **Grid**: Uniform grid with $N$ cells on a unit-length domain, cell width $\\Delta x = 1/N$.\n- **Numerical Flux**: $F_{i+\\frac{1}{2}}$ is the numerical flux at the interface between cells $i$ and $i+1$, computed using an approximate Riemann solver for the states $U_i^n$ and $U_{i+1}^n$.\n- **Solvers**: HLL and HLLC approximate Riemann solvers.\n- **Boundary Conditions**: Transmissive (zero-gradient) implemented with one ghost cell on each side.\n- **Time Step**: Courant-Friedrichs-Lewy (CFL) condition:\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{\\max_i \\left(|u_i| + a_i\\right)},\n\\quad \\text{where sound speed } a_i = \\sqrt{\\gamma \\frac{p_i}{\\rho_i}}.\n$$\n- **Diffusion Metric**: L1-norm of the change in density after one time step:\n$$\n\\Delta \\rho_{\\text{L1}} = \\sum_{i=1}^{N} \\left|\\rho_i^{n+1} - \\rho_i^n\\right|\n$$\n- **Numerical Tolerance**: $10^{-12}$ for testing against zero.\n- **Parameters**: $\\gamma = 1.4$, $N = 10$, $\\text{CFL} = 0.4$.\n- **Test Cases**: Initial piecewise-constant states $(\\rho, u, p)$ with a discontinuity at $x = 0.5$.\n    - Case A: $(1.0, 0.0, 1.0, 0.125, 0.0, 1.0)$\n    - Case B: $(10.0, 0.0, 1.0, 0.1, 0.0, 1.0)$\n    - Case C: $(1.0, 0.0, 1.0, 1.0, 0.0, 1.0)$\n    - Case D: $(1.0, 0.0, 1.0, 0.8, 0.0, 1.0)$\n- **Required Output**: For each case, a boolean value defined by:\n$$\n\\text{result} = \\left(\\Delta \\rho_{\\text{L1}}^{\\text{HLL}} > 10^{-12}\\right) \\wedge \\left(\\Delta \\rho_{\\text{L1}}^{\\text{HLLC}} \\le 10^{-12}\\right)\n$$\n\n**Step 2: Validation Analysis**\nThe problem is examined against prescribed criteria for validity.\n- **Scientific Grounding**: The problem is founded upon the Euler equations and the Godunov method, which are canonical subjects in computational fluid dynamics. The HLL and HLLC solvers are standard, well-documented algorithms. The problem is scientifically sound.\n- **Well-Posedness**: The problem specifies a deterministic, explicit numerical algorithm with all necessary initial conditions, boundary conditions, and parameters. A unique solution for the state after one time step is guaranteed.\n- **Objectivity**: The problem is formulated using precise mathematical and algorithmic language, free of any subjective or ambiguous terminology.\n- **Completeness and Consistency**: All information required for implementation is provided. The grid setup ($N=10$, discontinuity at $x=0.5$) correctly places the initial jump at the interface between cell $5$ and cell $6$. The parameters are physically and numerically consistent.\n\n**Step 3: Verdict**\nThe problem is **valid**. It is a well-posed, complete, and scientifically rigorous problem in computational engineering. We proceed to the solution.\n\n**Principle-Based Solution**\n\nThe objective is to solve the Euler equations, a system of hyperbolic conservation laws, using a finite-volume method. The integral form of the conservation law for a control volume (cell) $[x_{i-1/2}, x_{i+1/2}]$ is\n$$\n\\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} U(x, t) dx + F(U(x_{i+1/2}, t)) - F(U(x_{i-1/2}, t)) = 0\n$$\nAveraging over the cell width $\\Delta x = x_{i+1/2} - x_{i-1/2}$ yields\n$$\n\\frac{d U_i(t)}{dt} + \\frac{1}{\\Delta x}\\left(F(U(x_{i+1/2}, t)) - F(U(x_{i-1/2}, t))\\right) = 0,\n$$\nwhere $U_i(t)$ is the cell-averaged state. A first-order explicit time integration from $t^n$ to $t^{n+1} = t^n + \\Delta t$ gives the Godunov update formula:\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right)\n$$\nHere, $F_{i+1/2}$ is the numerical flux, which must approximate the time-averaged physical flux at the interface. Godunov's method defines this flux using the self-similar solution of the Riemann problem at the interface, evaluated along the line $x/t=0$. The Riemann problem at interface $x_{i+1/2}$ is defined by the initial condition consisting of two constant states, $U_L = U_i^n$ and $U_R = U_{i+1}^n$.\n\n**HLL Approximate Riemann Solver**\nThe HLL solver approximates the solution to the Riemann problem with a two-wave model. It assumes the left state $U_L$ and right state $U_R$ are separated by an intermediate constant state $U_*$, bounded by the fastest left-going wave speed $S_L$ and fastest right-going wave speed $S_R$. Integrating the conservation law over the region $[x_L, x_R] \\times [0, T]$ where $x_L < 0 < x_R$ and applying the divergence theorem gives the integral form of the Rankine-Hugoniot condition. This leads to the HLL state $U_* = \\frac{S_R U_R - S_L U_L - (F_R - F_L)}{S_R - S_L}$. The numerical flux at the interface $x/t=0$ is then determined by which region of the simplified wave structure contains the interface. This gives the HLL flux, $F^{\\text{HLL}}$:\n$$\nF^{\\text{HLL}} = \\begin{cases}\nF_L & \\text{if } 0 \\le S_L \\\\\n\\frac{S_R F_L - S_L F_R + S_L S_R (U_R - U_L)}{S_R - S_L} & \\text{if } S_L < 0 < S_R \\\\\nF_R & \\text{if } 0 > S_R\n\\end{cases}\n$$\nThe wave speeds $S_L$ and $S_R$ must bound all physical characteristic speeds. We use the Davis-Yee estimate:\n$$\nS_L = \\min(u_L - a_L, u_R - a_R), \\quad S_R = \\max(u_L + a_L, u_R + a_R)\n$$\nwhere $a_K = \\sqrt{\\gamma p_K / \\rho_K}$ for $K \\in \\{L, R\\}$. The HLL solver is simple and robust but is known to be overly diffusive, particularly for contact discontinuities, as it does not explicitly model them. For a stationary contact ($u_L=u_R=0, p_L=p_R$), the flux has a non-zero mass component if $\\rho_L \\neq \\rho_R$, which introduces spurious velocity and smearing of the density profile.\n\n**HLLC Approximate Riemann Solver**\nThe HLLC solver restores the contact discontinuity and shear waves absent in the HLL model. It assumes a three-wave structure with speeds $S_L$, $S_*$ (contact), and $S_R$, separating four constant states: $U_L$, $U_{L*}$, $U_{R*}$, and $U_R$. The wave speeds $S_L$ and $S_R$ are estimated as in HLL. The contact speed $S_*$ and the pressures in the \"star\" regions ($p_{L*} = p_{R*} = p_*$) are found by enforcing the Rankine-Hugoniot conditions across the $S_L$ and $S_R$ waves. This gives:\n$$\nS_* = \\frac{p_R - p_L + \\rho_L u_L(S_L - u_L) - \\rho_R u_R(S_R - u_R)}{\\rho_L (S_L - u_L) - \\rho_R (S_R - u_R)}\n$$\nThe intermediate states $U_{K*}$ (for $K \\in \\{L,R\\}$) are then given by applying the Rankine-Hugoniot conditions across the outer waves:\n$$\nU_{K*} = \\rho_K \\left(\\frac{S_K - u_K}{S_K - S_*}\\right) \\begin{bmatrix} 1 \\\\ S_* \\\\ E_K/\\rho_K + (S_* - u_K)(S_* + p_K/(\\rho_K(S_K-u_K))) \\end{bmatrix}\n$$\nThe HLLC flux, $F^{\\text{HLLC}}$, is selected based on the location of the interface $x/t=0$ within this wave structure:\n$$\nF^{\\text{HLLC}} = \\begin{cases}\nF_L & \\text{if } 0 \\le S_L \\\\\nF_L + S_L(U_{L*} - U_L) & \\text{if } S_L < 0 \\le S_* \\\\\nF_R + S_R(U_{R*} - U_R) & \\text{if } S_* < 0 < S_R \\\\\nF_R & \\text{if } 0 > S_R\n\\end{cases}\n$$\nFor a stationary contact discontinuity defined by $(\\rho_L, 0, p_0)$ and $(\\rho_R, 0, p_0)$, it can be shown that $S_* = 0$. The HLLC formulation then yields a numerical flux at the contact equal to the physical flux, $F = [0, p_0, 0]^T$. Consequently, for any cell, the incoming and outgoing fluxes are identical ($F_{i-1/2} = F_{i+1/2}$), resulting in $U_i^{n+1} = U_i^n$. The HLLC solver thus preserves a stationary contact discontinuity exactly, up to machine precision.\n\nThe provided test cases are designed to verify this behavior. Cases A, B, and D are stationary contacts with varying density jumps. The HLL solver is expected to produce a non-zero $\\Delta \\rho_{\\text{L1}}$, while the HLLC solver should produce $\\Delta \\rho_{\\text{L1}} \\approx 0$. Case C is a trivial case with no discontinuity, for which both solvers should yield $\\Delta \\rho_{\\text{L1}} \\approx 0$. The implementation below will quantify these effects.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a one-step first-order Godunov solver for the 1D Euler equations\n    to compare HLL and HLLC approximate Riemann solvers on stationary contacts.\n    \"\"\"\n    \n    # Test cases: (rho_L, u_L, p_L, rho_R, u_R, p_R)\n    test_cases = [\n        (1.0, 0.0, 1.0, 0.125, 0.0, 1.0),  # Case A\n        (10.0, 0.0, 1.0, 0.1, 0.0, 1.0),   # Case B\n        (1.0, 0.0, 1.0, 1.0, 0.0, 1.0),    # Case C\n        (1.0, 0.0, 1.0, 0.8, 0.0, 1.0),     # Case D\n    ]\n    \n    N = 10\n    CFL = 0.4\n    GAMMA = 1.4\n    TOL = 1e-12\n\n    def prim_to_cons(rho, u, p, gamma):\n        \"\"\"Convert primitive variables to conservative variables.\"\"\"\n        U = np.zeros((3, len(rho)))\n        U[0] = rho\n        U[1] = rho * u\n        U[2] = p / (gamma - 1.0) + 0.5 * rho * u**2\n        return U\n\n    def cons_to_prim(U, gamma):\n        \"\"\"Convert conservative variables to primitive variables and flux.\"\"\"\n        rho = U[0]\n        u = U[1] / rho\n        E = U[2]\n        p = (gamma - 1.0) * (E - 0.5 * rho * u**2)\n        \n        F = np.zeros_like(U)\n        F[0] = rho * u\n        F[1] = rho * u**2 + p\n        F[2] = u * (E + p)\n        \n        # Add a floor for pressure and density to avoid numerical issues\n        p = np.maximum(p, 1e-9)\n        rho = np.maximum(rho, 1e-9)\n\n        return rho, u, p, F\n\n    def hll_flux(U_L, U_R, gamma):\n        \"\"\"Calculate HLL flux for an array of interfaces.\"\"\"\n        rho_L, u_L, p_L, F_L = cons_to_prim(U_L, gamma)\n        rho_R, u_R, p_R, F_R = cons_to_prim(U_R, gamma)\n\n        a_L = np.sqrt(gamma * p_L / rho_L)\n        a_R = np.sqrt(gamma * p_R / rho_R)\n\n        S_L = np.minimum(u_L - a_L, u_R - a_R)\n        S_R = np.maximum(u_L + a_L, u_R + a_R)\n\n        F_hll = np.zeros_like(F_L)\n        \n        # Vectorized conditions\n        mask1 = S_L >= 0\n        mask3 = S_R <= 0\n        mask2 = ~mask1 & ~mask3 # S_L < 0 < S_R\n        \n        F_hll[:, mask1] = F_L[:, mask1]\n        F_hll[:, mask3] = F_R[:, mask3]\n\n        if np.any(mask2):\n            S_L_m2 = S_L[mask2]\n            S_R_m2 = S_R[mask2]\n            F_L_m2 = F_L[:, mask2]\n            F_R_m2 = F_R[:, mask2]\n            U_L_m2 = U_L[:, mask2]\n            U_R_m2 = U_R[:, mask2]\n            \n            F_hll[:, mask2] = (S_R_m2 * F_L_m2 - S_L_m2 * F_R_m2 + S_L_m2 * S_R_m2 * (U_R_m2 - U_L_m2)) / (S_R_m2 - S_L_m2)\n            \n        return F_hll\n\n    def hllc_flux(U_L, U_R, gamma):\n        \"\"\"Calculate HLLC flux for an array of interfaces.\"\"\"\n        rho_L, u_L, p_L, F_L = cons_to_prim(U_L, gamma)\n        rho_R, u_R, p_R, F_R = cons_to_prim(U_R, gamma)\n        \n        E_L = U_L[2]\n        E_R = U_R[2]\n        \n        a_L = np.sqrt(gamma * p_L / rho_L)\n        a_R = np.sqrt(gamma * p_R / rho_R)\n\n        S_L = np.minimum(u_L - a_L, u_R - a_R)\n        S_R = np.maximum(u_L + a_L, u_R + a_R)\n\n        p_star_num = p_R - p_L + rho_L * u_L * (S_L - u_L) - rho_R * u_R * (S_R - u_R)\n        p_star_den = rho_L * (S_L - u_L) - rho_R * (S_R - u_R)\n        S_star = p_star_num / p_star_den\n        \n        p_star = p_L + rho_L * (u_L - S_L) * (u_L - S_star)\n\n        F_hllc = np.zeros_like(F_L)\n\n        # Vectorized conditions\n        mask1 = 0.0 <= S_L\n        mask2 = (S_L < 0.0) & (0.0 <= S_star)\n        mask3 = (S_star < 0.0) & (0.0 < S_R)\n        mask4 = S_R <= 0.0\n\n        if np.any(mask1):\n            F_hllc[:, mask1] = F_L[:, mask1]\n        \n        if np.any(mask2):\n            factor_L = rho_L[mask2] * (S_L[mask2] - u_L[mask2]) / (S_L[mask2] - S_star[mask2])\n            U_star_L = np.zeros((3, np.sum(mask2)))\n            U_star_L[0] = factor_L\n            U_star_L[1] = factor_L * S_star[mask2]\n            U_star_L[2] = factor_L * (E_L[mask2] / rho_L[mask2] + (S_star[mask2] - u_L[mask2]) * (S_star[mask2] + p_L[mask2] / (rho_L[mask2] * (S_L[mask2] - u_L[mask2]))))\n            F_hllc[:, mask2] = F_L[:, mask2] + S_L[mask2] * (U_star_L - U_L[:, mask2])\n\n        if np.any(mask3):\n            factor_R = rho_R[mask3] * (S_R[mask3] - u_R[mask3]) / (S_R[mask3] - S_star[mask3])\n            U_star_R = np.zeros((3, np.sum(mask3)))\n            U_star_R[0] = factor_R\n            U_star_R[1] = factor_R * S_star[mask3]\n            U_star_R[2] = factor_R * (E_R[mask3] / rho_R[mask3] + (S_star[mask3] - u_R[mask3]) * (S_star[mask3] + p_R[mask3] / (rho_R[mask3] * (S_R[mask3] - u_R[mask3]))))\n            F_hllc[:, mask3] = F_R[:, mask3] + S_R[mask3] * (U_star_R - U_R[:, mask3])\n\n        if np.any(mask4):\n            F_hllc[:, mask4] = F_R[:, mask4]\n\n        return F_hllc\n\n    def run_one_step(U_n, dx, cfl, gamma, flux_solver):\n        \"\"\"Performs a single first-order Godunov time step.\"\"\"\n        num_cells = U_n.shape[1]\n        \n        # Apply boundary conditions (zero-gradient)\n        U_ext = np.zeros((3, num_cells + 2))\n        U_ext[:, 1:-1] = U_n\n        U_ext[:, 0] = U_n[:, 0]\n        U_ext[:, -1] = U_n[:, -1]\n        \n        rho_ext, u_ext, p_ext, _ = cons_to_prim(U_ext, gamma)\n        a_ext = np.sqrt(gamma * p_ext / rho_ext)\n        \n        # Calculate time step\n        max_speed = np.max(np.abs(u_ext) + a_ext)\n        dt = cfl * dx / max_speed\n        \n        # Left and right states for interfaces\n        U_L = U_ext[:, :-1]\n        U_R = U_ext[:, 1:]\n        \n        # Calculate fluxes at all interfaces\n        fluxes = flux_solver(U_L, U_R, gamma)\n        \n        # Update conservative variables\n        U_np1 = U_n - (dt / dx) * (fluxes[:, 1:] - fluxes[:, :-1])\n        \n        return U_np1\n\n    results = []\n    domain_length = 1.0\n    dx = domain_length / N\n    x = np.linspace(dx / 2.0, domain_length - dx / 2.0, N)\n\n    for case in test_cases:\n        rho_L, u_L, p_L, rho_R, u_R, p_R = case\n        \n        # Initial conditions\n        rho_initial = np.where(x < 0.5, rho_L, rho_R)\n        u_initial = np.where(x < 0.5, u_L, u_R)\n        p_initial = np.where(x < 0.5, p_L, p_R)\n        \n        U_initial = prim_to_cons(rho_initial, u_initial, p_initial, GAMMA)\n        \n        # Run HLL solver\n        U_final_hll = run_one_step(U_initial.copy(), dx, CFL, GAMMA, hll_flux)\n        rho_final_hll, _, _, _ = cons_to_prim(U_final_hll, GAMMA)\n        delta_rho_l1_hll = np.sum(np.abs(rho_final_hll - rho_initial))\n        \n        # Run HLLC solver\n        U_final_hllc = run_one_step(U_initial.copy(), dx, CFL, GAMMA, hllc_flux)\n        rho_final_hllc, _, _, _ = cons_to_prim(U_final_hllc, GAMMA)\n        delta_rho_l1_hllc = np.sum(np.abs(rho_final_hllc - rho_initial))\n        \n        # Evaluate condition\n        condition_met = (delta_rho_l1_hll > TOL) and (delta_rho_l1_hllc <= TOL)\n        results.append(condition_met)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\nsolve()\n\n```", "id": "2397623"}]}