{"hands_on_practices": [{"introduction": "Explicit time-stepping schemes are appealing for their simplicity, but this simplicity comes at a cost: conditional stability. If the time step $\\Delta t$ is too large, numerical errors can amplify catastrophically, rendering the simulation useless. This exercise challenges you to perform a von Neumann stability analysis for the 1D advection-diffusion equation discretized on a staggered grid using a forward Euler method [@problem_id:2438292]. Deriving the exact stability bound is a fundamental skill that provides deep insight into the interplay between time step, grid spacing, and physical parameters like velocity and diffusivity.", "problem": "Consider the one-dimensional ($1$D) linear advection-diffusion equation\n$$\n\\frac{\\partial \\phi}{\\partial t} + U\\,\\frac{\\partial \\phi}{\\partial x} = \\nu\\,\\frac{\\partial^2 \\phi}{\\partial x^2},\n$$\non a periodic domain, where $U$ is a spatially uniform constant advection speed and $\\nu$ is a positive constant kinematic diffusivity. Discretize the spatial domain using a uniform grid with spacing $\\Delta x$ and a one-dimensional staggered Marker-And-Cell (MAC) layout: the scalar field $\\phi$ is stored at cell centers indexed by integers $i$, while the velocity $U$ is a face-centered constant stored at half-integers $i+\\tfrac{1}{2}$. Advance in time using a fully explicit forward Euler method with time step $\\Delta t$. For the spatial discretizations, use:\n- a conservative flux-difference form for the advection term with face flux $(U \\phi)_{i+\\frac{1}{2}}$ computed from the face-centered velocity and a centered interpolation of $\\phi$ to faces, $\\phi_{i+\\frac{1}{2}} = \\tfrac{1}{2}(\\phi_{i+1} + \\phi_i)$,\n- a standard second-order central difference for diffusion at cell centers.\n\nUnder these assumptions, the update for cell-centered values $\\phi_i$ over one time step is\n$$\n\\phi_i^{n+1} = \\phi_i^{n} - \\Delta t\\,\\frac{(U\\phi)_{i+\\frac{1}{2}}^{n} - (U\\phi)_{i-\\frac{1}{2}}^{n}}{\\Delta x} + \\Delta t\\,\\nu\\,\\frac{\\phi_{i+1}^{n} - 2\\phi_{i}^{n} + \\phi_{i-1}^{n}}{\\Delta x^2},\n$$\nwith $(U\\phi)_{i+\\frac{1}{2}}^{n} = U\\,\\tfrac{1}{2}(\\phi_{i+1}^{n} + \\phi_{i}^{n})$ and likewise for $i-\\tfrac{1}{2}$. Assume periodic boundary conditions.\n\nConduct a von Neumann stability analysis of this fully explicit staggered-grid scheme and determine the exact largest time step $\\Delta t_{\\max}$, as an analytic expression in terms of $U$, $\\nu$, and $\\Delta x$, such that all Fourier modes are non-amplifying in magnitude over one time step. Use International System of Units (SI) throughout; the time step has units of seconds. Provide your final answer as a single closed-form expression in $U$, $\\nu$, and $\\Delta x$. No numerical rounding is required.", "solution": "The problem statement is first subjected to a critical validation procedure.\n\nStep 1: Extract Givens.\nThe governing partial differential equation is the one-dimensional linear advection-diffusion equation:\n$$\n\\frac{\\partial \\phi}{\\partial t} + U\\,\\frac{\\partial \\phi}{\\partial x} = \\nu\\,\\frac{\\partial^2 \\phi}{\\partial x^2}\n$$\nThe parameters are a spatially uniform constant advection speed $U$ and a positive constant kinematic diffusivity $\\nu$. The spatial domain is periodic and discretized with a uniform grid spacing $\\Delta x$. The numerical scheme is defined as follows:\n- Time integration: Fully explicit forward Euler method with time step $\\Delta t$.\n- Grid layout: Staggered Marker-And-Cell (MAC), with scalar $\\phi$ at cell centers $x_i = i \\Delta x$ and velocity $U$ at faces $x_{i+1/2} = (i+1/2)\\Delta x$.\n- Advection term discretization: A conservative flux-difference form, where the face flux is $(U \\phi)_{i+\\frac{1}{2}} = U\\,\\phi_{i+\\frac{1}{2}} = U\\,\\tfrac{1}{2}(\\phi_{i+1} + \\phi_i)$.\n- Diffusion term discretization: A standard second-order central difference.\nThe resulting fully-discrete update equation is given as:\n$$\n\\phi_i^{n+1} = \\phi_i^{n} - \\Delta t\\,\\frac{(U\\phi)_{i+\\frac{1}{2}}^{n} - (U\\phi)_{i-\\frac{1}{2}}^{n}}{\\Delta x} + \\Delta t\\,\\nu\\,\\frac{\\phi_{i+1}^{n} - 2\\phi_{i}^{n} + \\phi_{i-1}^{n}}{\\Delta x^2}\n$$\nwith the flux definitions:\n$$\n(U\\phi)_{i+\\frac{1}{2}}^{n} = U\\,\\frac{\\phi_{i+1}^{n} + \\phi_{i}^{n}}{2} \\quad \\text{and} \\quad (U\\phi)_{i-\\frac{1}{2}}^{n} = U\\,\\frac{\\phi_{i}^{n} + \\phi_{i-1}^{n}}{2}\n$$\nThe task is to find the maximum stable time step $\\Delta t_{\\max}$ by performing a von Neumann stability analysis.\n\nStep 2: Validate Using Extracted Givens.\nThe problem is assessed for validity.\n- **Scientifically Grounded**: The advection-diffusion equation is a fundamental model in transport phenomena. The numerical methods described (Forward Euler, central differences, staggered grid) are standard in computational engineering. The von Neumann analysis is the canonical technique for assessing the stability of linear finite difference schemes. The problem is scientifically sound.\n- **Well-Posed**: The problem is specified with sufficient detail. It provides the governing equation, the full discretization scheme, and a clear objective: to determine the stability limit. A unique solution for the stability bound exists and is meaningful.\n- **Objective**: The problem is stated using precise, unambiguous mathematical and technical language. It is free from subjective claims.\n- **Completeness and Consistency**: All necessary components for the analysis are provided. There are no contradictions in the definitions. The problem is self-contained.\n\nStep 3: Verdict and Action.\nThe problem is valid. The solution will now be derived.\n\nThe first step is to substitute the given flux expressions into the update equation.\n$$\n\\phi_i^{n+1} = \\phi_i^{n} - \\frac{\\Delta t}{\\Delta x} \\left( U\\,\\frac{\\phi_{i+1}^{n} + \\phi_{i}^{n}}{2} - U\\,\\frac{\\phi_{i}^{n} + \\phi_{i-1}^{n}}{2} \\right) + \\frac{\\nu \\Delta t}{\\Delta x^2} (\\phi_{i+1}^{n} - 2\\phi_i^{n} + \\phi_{i-1}^{n})\n$$\nSimplifying the advection term gives:\n$$\n\\phi_i^{n+1} = \\phi_i^{n} - \\frac{U \\Delta t}{2 \\Delta x} (\\phi_{i+1}^{n} - \\phi_{i-1}^{n}) + \\frac{\\nu \\Delta t}{\\Delta x^2} (\\phi_{i+1}^{n} - 2\\phi_i^{n} + \\phi_{i-1}^{n})\n$$\nThis scheme is a Forward-Time Central-Space (FTCS) discretization for both advection and diffusion terms. To analyze its stability, we perform a von Neumann analysis. We substitute a single Fourier mode for the solution at grid point $i$ and time level $n$:\n$$\n\\phi_i^n = \\hat{\\phi}^n(k) \\exp(I k x_i) = \\hat{\\phi}^n(k) \\exp(I k i \\Delta x)\n$$\nwhere $I = \\sqrt{-1}$ is the imaginary unit, $k$ is the wavenumber, and $\\hat{\\phi}^n(k)$ is the amplitude of the mode at time $n$. The amplification factor is defined as $G(k) = \\hat{\\phi}^{n+1}(k) / \\hat{\\phi}^n(k)$. Substituting the Fourier mode into the discrete equation yields:\n$$\nG(k) \\exp(Iki\\Delta x) = \\exp(Iki\\Delta x) - \\frac{U \\Delta t}{2 \\Delta x} (\\exp(Ik(i+1)\\Delta x) - \\exp(Ik(i-1)\\Delta x)) + \\frac{\\nu \\Delta t}{\\Delta x^2} (\\exp(Ik(i+1)\\Delta x) - 2\\exp(Iki\\Delta x) + \\exp(Ik(i-1)\\Delta x))\n$$\nDividing by $\\exp(Iki\\Delta x)$ gives the amplification factor $G(k)$:\n$$\nG(k) = 1 - \\frac{U \\Delta t}{2 \\Delta x} (\\exp(Ik\\Delta x) - \\exp(-Ik\\Delta x)) + \\frac{\\nu \\Delta t}{\\Delta x^2} (\\exp(Ik\\Delta x) - 2 + \\exp(-Ik\\Delta x))\n$$\nUsing the Euler identities $\\exp(I\\theta) - \\exp(-I\\theta) = 2I\\sin(\\theta)$ and $\\exp(I\\theta) + \\exp(-I\\theta) - 2 = 2\\cos(\\theta) - 2 = -4\\sin^2(\\theta/2)$, and letting $\\alpha = k\\Delta x$, we have:\n$$\nG(\\alpha) = 1 - \\frac{U \\Delta t}{2 \\Delta x} (2I\\sin(\\alpha)) + \\frac{\\nu \\Delta t}{\\Delta x^2} (2\\cos(\\alpha) - 2)\n$$\nLet the Courant number be $c = \\frac{U \\Delta t}{\\Delta x}$ and the diffusion number be $d = \\frac{\\nu \\Delta t}{\\Delta x^2}$. The amplification factor becomes:\n$$\nG(\\alpha) = 1 - I c \\sin(\\alpha) - 4d \\sin^2(\\alpha/2)\n$$\nFor the scheme to be stable, the magnitude of the amplification factor must not exceed unity for all possible wavenumbers, i.e., $|G(\\alpha)| \\le 1$ for all $\\alpha \\in [-\\pi, \\pi]$. We analyze the squared magnitude:\n$$\n|G(\\alpha)|^2 = \\left(1 - 4d \\sin^2(\\alpha/2)\\right)^2 + (-c \\sin(\\alpha))^2 \\le 1\n$$\n$$\n1 - 8d \\sin^2(\\alpha/2) + 16d^2 \\sin^4(\\alpha/2) + c^2 \\sin^2(\\alpha) \\le 1\n$$\nUsing the identity $\\sin^2(\\alpha) = (2\\sin(\\alpha/2)\\cos(\\alpha/2))^2 = 4\\sin^2(\\alpha/2)\\cos^2(\\alpha/2) = 4\\sin^2(\\alpha/2)(1-\\sin^2(\\alpha/2))$, we get:\n$$\n-8d \\sin^2(\\alpha/2) + 16d^2 \\sin^4(\\alpha/2) + 4c^2 \\sin^2(\\alpha/2)(1-\\sin^2(\\alpha/2)) \\le 0\n$$\nLet $S = \\sin^2(\\alpha/2)$. For $\\alpha \\in [-\\pi, \\pi]$, $S$ ranges from $0$ to $1$. For $S > 0$, we can divide by $S$:\n$$\n-8d + 16d^2 S + 4c^2 (1-S) \\le 0\n$$\n$$\n(4c^2 - 8d) + S(16d^2 - 4c^2) \\le 0\n$$\nThis inequality is linear in $S$ and must hold for all $S \\in [0, 1]$. This is only possible if the inequality holds at the endpoints $S=0$ and $S=1$.\nFor $S \\to 0$ (long wavelengths, $\\alpha \\to 0$):\n$$\n4c^2 - 8d \\le 0 \\implies c^2 \\le 2d\n$$\nFor $S=1$ (shortest wavelengths, $\\alpha = \\pm\\pi$):\n$$\n(4c^2 - 8d) + (16d^2 - 4c^2) \\le 0 \\implies 16d^2 - 8d \\le 0 \\implies 8d(2d-1) \\le 0\n$$\nSince $\\nu>0$, $\\Delta t>0$, and $\\Delta x^2>0$, we have $d>0$. Thus, this second condition simplifies to:\n$$\n2d-1 \\le 0 \\implies d \\le \\frac{1}{2}\n$$\nWe now have two conditions that must be satisfied simultaneously for stability:\n1. $c^2 \\le 2d$\n2. $d \\le \\frac{1}{2}$\n\nSubstitute the definitions of $c$ and $d$ back in terms of the physical parameters. For condition 1:\n$$\n\\left(\\frac{U \\Delta t}{\\Delta x}\\right)^2 \\le 2\\left(\\frac{\\nu \\Delta t}{\\Delta x^2}\\right) \\implies \\frac{U^2 (\\Delta t)^2}{\\Delta x^2} \\le \\frac{2\\nu \\Delta t}{\\Delta x^2}\n$$\nAssuming $\\Delta t > 0$, we can simplify to find a bound on $\\Delta t$:\n$$\nU^2 \\Delta t \\le 2\\nu \\implies \\Delta t \\le \\frac{2\\nu}{U^2} \\quad (\\text{for } U \\neq 0)\n$$\nFor condition 2:\n$$\n\\frac{\\nu \\Delta t}{\\Delta x^2} \\le \\frac{1}{2} \\implies \\Delta t \\le \\frac{\\Delta x^2}{2\\nu}\n$$\nThe time step $\\Delta t$ must satisfy both constraints. Therefore, the maximum allowable time step $\\Delta t_{max}$ is the minimum of the two upper bounds:\n$$\n\\Delta t_{\\max} = \\min\\left(\\frac{2\\nu}{U^2}, \\frac{\\Delta x^2}{2\\nu}\\right)\n$$\nThis expression is the complete and exact stability limit for the given numerical scheme.", "answer": "$$\n\\boxed{\\min\\left(\\frac{2\\nu}{U^2}, \\frac{\\Delta x^2}{2\\nu}\\right)}\n$$", "id": "2438292"}, {"introduction": "A cornerstone of the MAC scheme for incompressible fluids is the solution of a pressure Poisson equation at each time step, which ensures the velocity field remains divergence-free. This task is often the most computationally expensive part of the simulation, making efficient solvers essential. In this practice, you will implement a Red-Black Gauss-Seidel (RBGS) iterative solver for the discrete Poisson equation [@problem_id:2438296]. By running a numerical experiment, you will discover how the grid cell aspect ratio—a common feature in realistic simulations—can dramatically impact the solver's convergence rate, a crucial lesson in numerical performance.", "problem": "You are asked to quantify, by direct numerical experiment, how the grid cell aspect ratio influences the convergence rate of an iterative solver for the pressure Poisson equation on a Marker-And-Cell (MAC) staggered grid. Consider the unit square domain $[0,1]\\times[0,1]$ with pressure unknowns located at cell centers. Let $N_x$ and $N_y$ denote the number of interior pressure unknowns along the $x$- and $y$-directions, respectively. The uniform grid spacings are $\\Delta x = \\dfrac{1}{N_x+1}$ and $\\Delta y = \\dfrac{1}{N_y+1}$, so that the cell aspect ratio is $\\Delta x / \\Delta y = \\dfrac{N_y+1}{N_x+1}$. Impose homogeneous Dirichlet boundary conditions $p=0$ on $\\partial \\Omega$, and solve the discrete Poisson equation\n$$\n\\frac{p_{i+1,j}-2 p_{i,j}+p_{i-1,j}}{(\\Delta x)^2}+\\frac{p_{i,j+1}-2 p_{i,j}+p_{i,j-1}}{(\\Delta y)^2}=f_{i,j},\n$$\nfor all interior indices $(i,j)$, where the source term is sampled from the continuous function $f(x,y)=-2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$ at interior cell-center locations $(x_i,y_j)=(i\\,\\Delta x, j\\,\\Delta y)$ with $i\\in\\{1,\\dots,N_x\\}$ and $j\\in\\{1,\\dots,N_y\\}$. Use the Red-Black Gauss-Seidel (RBGS) iterative method starting from the zero field $p_{i,j}^{(0)}=0$ for all interior $(i,j)$, and enforce $p=0$ at all boundary nodes at every iteration. After each full RBGS sweep (one red update and one black update), compute the discrete residual\n$$\nr_{i,j}=\\frac{p_{i+1,j}-2 p_{i,j}+p_{i-1,j}}{(\\Delta x)^2}+\\frac{p_{i,j+1}-2 p_{i,j}+p_{i,j-1}}{(\\Delta y)^2}-f_{i,j},\n$$\nand the relative residual norm\n$$\n\\mathrm{RelRes}=\\frac{\\left(\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} r_{i,j}^2\\right)^{1/2}}{\\left(\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} f_{i,j}^2\\right)^{1/2}}.\n$$\nTerminate the iteration when $\\mathrm{RelRes}\\le \\varepsilon$ with tolerance $\\varepsilon=10^{-6}$, or when a hard cap of $N_{\\max}=100000$ full sweeps is reached, whichever occurs first. The quantity of interest for each case is the number of full RBGS sweeps required to meet the tolerance.\n\nTest suite: For each of the following parameter pairs $(N_x,N_y)$, run the above experiment and record the required number of sweeps as an integer:\n- Case $1$: $(N_x,N_y)=(32,32)$.\n- Case $2$: $(N_x,N_y)=(48,12)$.\n- Case $3$: $(N_x,N_y)=(12,48)$.\n- Case $4$: $(N_x,N_y)=(8,8)$.\n- Case $5$: $(N_x,N_y)=(64,16)$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the cases above, for example, $\\texttt{[r_1,r_2,r_3,r_4,r_5]}$, where each $r_k$ is the integer number of RBGS sweeps required for Case $k$.", "solution": "The problem presented is a well-posed numerical experiment in computational engineering, requiring the implementation of an iterative solver for the two-dimensional Poisson equation. The problem is scientifically sound, self-contained, and all data and constraints are clearly specified. The stated goal is to quantify the effect of grid cell aspect ratio on the convergence rate of the Red-Black Gauss-Seidel method. We shall proceed with the derivation and implementation of the required algorithm.\n\nThe governing partial differential equation is the Poisson equation on the unit square domain $\\Omega = [0,1]\\times[0,1]$ with homogeneous Dirichlet boundary conditions:\n$$\n\\nabla^2 p = \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} = f(x,y), \\quad \\text{for } (x,y) \\in \\Omega\n$$\n$$\np(x,y) = 0, \\quad \\text{for } (x,y) \\in \\partial\\Omega\n$$\nWe discretize this problem using a finite difference method on a uniform Cartesian grid. The pressure unknowns $p_{i,j}$ are located at cell centers $(x_i, y_j) = (i\\Delta x, j\\Delta y)$, for interior indices $i \\in \\{1, \\dots, N_x\\}$ and $j \\in \\{1, \\dots, N_y\\}$. The grid spacings are $\\Delta x = \\frac{1}{N_x+1}$ and $\\Delta y = \\frac{1}{N_y+1}$. Using a second-order central difference scheme for the second derivatives, we obtain the discrete Poisson equation at each interior node $(i,j)$:\n$$\n\\frac{p_{i+1,j}-2 p_{i,j}+p_{i-1,j}}{(\\Delta x)^2}+\\frac{p_{i,j+1}-2 p_{i,j}+p_{i,j-1}}{(\\Delta y)^2}=f_{i,j}\n$$\nwhere $f_{i,j}$ is the source term $f(x,y)=-2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$ evaluated at $(x_i, y_j)$. The homogeneous boundary conditions imply that $p_{i,j}=0$ if $i=0$, $i=N_x+1$, $j=0$, or $j=N_y+1$.\n\nTo solve this system iteratively, we first rearrange the equation to isolate $p_{i,j}$. This gives the update rule for a point-iterative method.\n$$\np_{i,j} \\left( \\frac{2}{(\\Delta x)^2} + \\frac{2}{(\\Delta y)^2} \\right) = \\frac{p_{i+1,j} + p_{i-1,j}}{(\\Delta x)^2} + \\frac{p_{i,j+1} + p_{i,j-1}}{(\\Delta y)^2} - f_{i,j}\n$$\nLetting $\\alpha_x = 1/(\\Delta x)^2$ and $\\alpha_y = 1/(\\Delta y)^2$, the update rule becomes:\n$$\np_{i,j} = \\frac{ \\alpha_x (p_{i+1,j} + p_{i-1,j}) + \\alpha_y (p_{i,j+1} + p_{i,j-1}) - f_{i,j} }{ 2(\\alpha_x + \\alpha_y) }\n$$\nThe Red-Black Gauss-Seidel (RBGS) method accelerates convergence by partitioning the grid points into two sets, \"red\" and \"black\", similar to a checkerboard. A node $(i,j)$ is designated red if the sum of its indices $i+j$ is even, and black if $i+j$ is odd. The key observation is that the update for any red node depends only on its four neighbors, which are all black. Likewise, the update for any black node depends only on its red neighbors.\n\nA full RBGS sweep proceeds in two stages:\n$1$. **Red Update**: All red nodes are updated simultaneously. The new value for a red node $p_{i,j}$ is computed using the values of its black neighbors from the previous iteration, let's say iteration $k$.\n$$\np_{i,j}^{(k+1/2)} = \\frac{ \\alpha_x (p_{i+1,j}^{(k)} + p_{i-1,j}^{(k)}) + \\alpha_y (p_{i,j+1}^{(k)} + p_{i,j-1}^{(k)}) - f_{i,j} }{ 2(\\alpha_x + \\alpha_y) }, \\quad \\text{for all red } (i,j)\n$$\n$2$. **Black Update**: All black nodes are updated simultaneously. The new value for a black node $p_{i,j}$ is computed using the newly updated values of its red neighbors from the current sweep, $k+1/2$.\n$$\np_{i,j}^{(k+1)} = \\frac{ \\alpha_x (p_{i+1,j}^{(k+1/2)} + p_{i-1,j}^{(k+1/2)}) + \\alpha_y (p_{i,j+1}^{(k+1/2)} + p_{i,j-1}^{(k+1/2)}) - f_{i,j} }{ 2(\\alpha_x + \\alpha_y) }, \\quad \\text{for all black } (i,j)\n$$\nThe result of these two stages is the pressure field at the end of sweep $k+1$, denoted $p^{(k+1)}$.\n\nAfter each full sweep, we must check for convergence. This is done by computing the discrete residual field $r_{i,j}$ for all interior nodes:\n$$\nr_{i,j} = \\alpha_x(p_{i+1,j}-2 p_{i,j}+p_{i-1,j}) + \\alpha_y(p_{i,j+1}-2 p_{i,j}+p_{i,j-1}) - f_{i,j}\n$$\nThe convergence is assessed using the relative residual norm, defined as the ratio of the discrete $L_2$-norm of the residual to the discrete $L_2$-norm of the source term:\n$$\n\\mathrm{RelRes}=\\frac{\\|r\\|_2}{\\|f\\|_2} = \\frac{\\left(\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} r_{i,j}^2\\right)^{1/2}}{\\left(\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} f_{i,j}^2\\right)^{1/2}}\n$$\nThe iterative process is terminated when $\\mathrm{RelRes} \\le \\varepsilon = 10^{-6}$ or when the number of sweeps reaches the maximum limit of $N_{\\max}=100000$. The recorded result is the number of full sweeps performed.\n\nThe numerical experiment procedure for each $(N_x, N_y)$ pair is as follows:\n$1$. Set up a $(N_y+2) \\times (N_x+2)$ grid array for the pressure $p$, initialized to zero. This accommodates the homogeneous Dirichlet boundary conditions, which remain fixed at zero.\n$2$. Compute the grid spacings $\\Delta x$ and $\\Delta y$, and the coefficients $\\alpha_x$, $\\alpha_y$.\n$3$. Construct the source term array $f_{i,j}$ for the interior nodes $i \\in \\{1, \\dots, N_x\\}$, $j \\in \\{1, \\dots, N_y\\}$. Calculate and store its $L_2$-norm, $\\|f\\|_2$.\n$4$. Create boolean masks to identify the red and black interior nodes based on the parity of $i+j$.\n$5$. Begin the main iteration loop, initializing the sweep counter to zero.\n$6$. In each loop:\n    a. Increment the sweep counter.\n    b. Perform the red update for all red interior nodes using vectorized operations on the pressure array.\n    c. Perform the black update for all black interior nodes, using the newly updated red node values.\n    d. Calculate the residual field $r$ over the interior grid.\n    e. Compute the relative residual norm $\\mathrm{RelRes}$.\n    f. If $\\mathrm{RelRes} \\le 10^{-6}$, break the loop.\n$7$. Return the final sweep count. This procedure is repeated for each test case specified in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_rbgs_solver(Nx, Ny):\n    \"\"\"\n    Solves the 2D Poisson equation using Red-Black Gauss-Seidel iteration.\n\n    Args:\n        Nx (int): Number of interior pressure unknowns along x-direction.\n        Ny (int): Number of interior pressure unknowns along y-direction.\n\n    Returns:\n        int: The number of sweeps required to meet the convergence criteria.\n    \"\"\"\n    # Problem parameters\n    epsilon = 1e-6\n    N_max = 100000\n\n    # Grid setup\n    dx = 1.0 / (Nx + 1)\n    dy = 1.0 / (Ny + 1)\n    ax = 1.0 / (dx**2)\n    ay = 1.0 / (dy**2)\n    inv_denom = 1.0 / (2.0 * (ax + ay))\n\n    # Pressure field with boundary layers, initialized to zero\n    # This automatically enforces p=0 boundary conditions.\n    p = np.zeros((Ny + 2, Nx + 2))\n\n    # Source term f\n    # Create coordinate arrays for the full grid (including boundaries)\n    x = np.linspace(0, 1, Nx + 2)\n    y = np.linspace(0, 1, Ny + 2)\n    # The meshgrid is created for the full (Ny+2)x(Nx+2) domain\n    xx, yy = np.meshgrid(x, y) \n\n    f_full = -2.0 * (np.pi**2) * np.sin(np.pi * xx) * np.sin(np.pi * yy)\n    f_interior = f_full[1:-1, 1:-1]\n    norm_f = np.linalg.norm(f_interior)\n    \n    # Pre-compute Red-Black masks for interior points\n    # Index grid for interior points (1 to N, for formula i+j)\n    J, I = np.meshgrid(np.arange(1, Ny + 1), np.arange(1, Nx + 1), indexing='ij')\n    # red_mask: where i+j is even\n    red_mask = (I + J) % 2 == 0\n    # black_mask: where i+j is odd\n    black_mask = ~red_mask\n\n    sweeps = 0\n    for k in range(N_max):\n        sweeps += 1\n\n        # --- Red Update ---\n        # The update for red points depends on their black neighbors.\n        # We can calculate the update for all interior points based on the current\n        # state of p, and then apply it only to the red points.\n        neighbors_sum = (ax * (p[1:-1, 2:] + p[1:-1, :-2]) +\n                         ay * (p[2:, 1:-1] + p[:-2, 1:-1]))\n        p_new_interior = (neighbors_sum - f_interior) * inv_denom\n        p[1:-1, 1:-1][red_mask] = p_new_interior[red_mask]\n\n        # --- Black Update ---\n        # The update for black points depends on their red neighbors, which\n        # have just been updated. Recalculate and apply.\n        neighbors_sum = (ax * (p[1:-1, 2:] + p[1:-1, :-2]) +\n                         ay * (p[2:, 1:-1] + p[:-2, 1:-1]))\n        p_new_interior = (neighbors_sum - f_interior) * inv_denom\n        p[1:-1, 1:-1][black_mask] = p_new_interior[black_mask]\n\n        # --- Convergence Check after a full sweep ---\n        # Calculate the discrete Laplacian of the updated pressure field p\n        laplacian_p = (ax * (p[1:-1, 2:] + p[1:-1, :-2] - 2.0 * p[1:-1, 1:-1]) +\n                       ay * (p[2:, 1:-1] + p[:-2, 1:-1] - 2.0 * p[1:-1, 1:-1]))\n        \n        # Calculate the residual field r = A*p - f\n        r = laplacian_p - f_interior\n        \n        # Calculate the relative residual norm\n        rel_res = np.linalg.norm(r) / norm_f\n        \n        if rel_res = epsilon:\n            break\n            \n    return sweeps\n\ndef solve():\n    \"\"\"\n    Main function to run the experiment for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 32), # Case 1\n        (48, 12), # Case 2\n        (12, 48), # Case 3\n        (8, 8),   # Case 4\n        (64, 16), # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny = case\n        result = run_rbgs_solver(Nx, Ny)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2438296"}, {"introduction": "The true power of a numerical method lies in its ability to tackle problems with realistic, complex geometries. While staggered Cartesian grids are highly efficient, they do not naturally conform to curved or angled boundaries. This advanced practice introduces the embedded boundary, or 'cut-cell,' method, a powerful technique to adapt a structured grid to an arbitrary geometry defined by a level-set function [@problem_id:2438357]. You will implement a finite-volume solver that modifies its stencils near the boundary, gaining hands-on experience in bridging the gap between simple academic examples and challenging real-world engineering applications.", "problem": "You are to implement a two-dimensional embedded-boundary, cut-cell discretization for a scalar elliptic problem on a Marker-And-Cell (MAC) grid, with the unknown pressure stored at cell centers. The computational domain is the unit square with coordinates $(x,y) \\in [0,1] \\times [0,1]$ and a uniform Cartesian mesh of size $N \\times N$ with spacing $h = 1/N$. The pressure $p$ satisfies the steady Poisson equation with constant diffusion coefficient and a manufactured source in the fluid subdomain $\\Omega_f \\subset [0,1]^2$:\n$$ -\\nabla^2 p = f \\quad \\text{in } \\Omega_f, $$\nwith Dirichlet boundary conditions on both the outer boundary $\\partial [0,1]^2$ and on an internal embedded boundary $\\Gamma \\subset [0,1]^2$ that separates the fluid from the solid region. The embedded boundary is represented by a signed-distance level set $\\phi(x,y)$ such that $\\phi(x,y) \\ge 0$ in the fluid and $\\phi(x,y)  0$ in the solid, with $\\Gamma = \\{(x,y): \\phi(x,y)=0\\}$. The MAC grid placement is such that pressure is stored at cell centers, while velocities would be stored at faces (you will not need velocities in this problem but should follow the MAC placement for pressure).\n\nYour implementation must start from first principles:\n- Finite-volume control of a cell-centered control volume with area $h^2$ in two dimensions, integrating the divergence form and using the divergence theorem to express fluxes across the four faces.\n- For each of the four coordinate-aligned directions, approximate the face-normal gradient using two-point fluxes between the cell center and either the neighboring fluid-cell center or the intersection point with the Dirichlet boundary where the boundary cuts the face-normal line, at a properly computed distance.\n\nUse the following well-tested base:\n- Manufactured solution $p^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y)$.\n- Source term $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$, since $\\Delta p^\\star = -2\\pi^2 p^\\star$ and thus $-\\nabla^2 p^\\star = 2\\pi^2 p^\\star$.\n- Dirichlet data on both the outer boundary and the embedded boundary equal to the manufactured solution: $p = p^\\star$.\n\nStaggered-grid context and stencil modification near the embedded boundary:\n- Pressure unknowns are stored at cell centers $(x_i,y_j)$ with $x_i = (i+1/2)h$, $y_j = (j+1/2)h$, where $i,j \\in \\{0,1,\\dots,N-1\\}$. Only cells with $\\phi(x_i,y_j) \\ge 0$ are fluid unknowns.\n- For each fluid cell, in the standard interior case with fluid neighbors in all four directions, use the five-point Laplacian stencil derived from the finite-volume flux balance:\n$$ \\frac{4p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1}}{h^2} = f(x_i,y_j). $$\n- For a neighbor in direction $d \\in \\{\\text{east, west, north, south}\\}$ that is outside the computational domain (outer Dirichlet boundary at a distance $\\delta = h/2$ from the cell center along direction $d$), replace the missing neighbor flux by a cut-face contribution that adds to the diagonal and the right-hand side:\n$$ a_{P} \\leftarrow a_{P} + \\frac{1}{h\\,\\delta}, \\quad b \\leftarrow b + \\frac{p_B}{h\\,\\delta}, $$\nwhere $p_B = p^\\star$ evaluated at the boundary point at distance $\\delta$ along direction $d$ from the cell center.\n- For a neighbor in direction $d$ that is a solid cell (i.e., $\\phi$ changes sign across that neighbor center), let $\\phi_P = \\phi(x_i,y_j)$ at the fluid cell center and $\\phi_N = \\phi$ at the neighboring center. Compute the fractional interface location along the center-to-center line as\n$$ \\lambda = \\frac{\\phi_P}{\\phi_P - \\phi_N}, \\quad \\delta = \\lambda\\,h, $$\nwith $\\lambda \\in (0,1)$, so that the interface lies a distance $\\delta$ from the fluid cell center along direction $d$. Approximate the cut-face flux by a two-point flux between the cell center and the Dirichlet boundary at the interface point, adding the same contribution as above with this $\\delta$:\n$$ a_{P} \\leftarrow a_{P} + \\frac{1}{h\\,\\delta}, \\quad b \\leftarrow b + \\frac{p_B}{h\\,\\delta}, $$\nwhere $p_B = p^\\star$ evaluated at the interface point displaced by $\\delta$ along direction $d$ from $(x_i,y_j)$.\n- For a neighbor in direction $d$ that is a fluid cell, use the standard neighbor coupling\n$$ a_{P} \\leftarrow a_{P} + \\frac{1}{h^2}, \\quad a_{N} \\leftarrow a_{N} - \\frac{1}{h^2}. $$\n\nThis yields a modified five-point stencil near cut cells that enforces Dirichlet conditions at the embedded boundary by replacing neighbor couplings with boundary contributions that depend on the distance to the interface. Assemble the linear system $A \\mathbf{p} = \\mathbf{b}$ over all fluid cells and solve for $\\mathbf{p}$. Then, compute the root-mean-square (RMS) error against $p^\\star$ over fluid cell centers:\n$$ \\varepsilon_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{(i,j)\\in \\Omega_f} \\left(p_{i,j} - p^\\star(x_i,y_j)\\right)^2}, $$\nwhere $M$ is the number of fluid cells.\n\nAngle units do not apply. All quantities are dimensionless; report errors as pure numbers.\n\nTest suite. Your program must run the following three test cases and return the three RMS errors as a single list in the order below:\n- Test $1$ (curved boundary, typical case): $N=64$, embedded boundary is a circle with center $(x_c,y_c)=(0.5,0.5)$ and radius $r=0.25$, with $\\phi(x,y) = \\sqrt{(x-x_c)^2+(y-y_c)^2} - r$. The fluid is the exterior of the circle, i.e., $\\phi \\ge 0$.\n- Test $2$ (grid-aligned boundary, reduction to standard stencil): $N=64$, embedded boundary is the vertical line at $x=0.5$, with $\\phi(x,y)=0.5-x$. The fluid is the region $x \\le 0.5$ (i.e., $\\phi \\ge 0$).\n- Test $3$ (small cut-cells near the outer boundary): $N=64$, embedded boundary is a circle with center $(x_c,y_c)=(0.75,0.5)$ and radius $r=0.24$ (so the closest approach to the right wall is $0.01$), with the same sign convention $\\phi \\ge 0$ for the fluid.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where each result is the RMS error for the corresponding test in the order listed above.", "solution": "The problem statement is subjected to rigorous validation.\n\nStep 1: Extract Givens.\n- Governing Equation: $-\\nabla^2 p = f$ in the fluid domain $\\Omega_f$.\n- Computational Domain: $[0,1] \\times [0,1]$.\n- Mesh: Uniform $N \\times N$ Cartesian grid, spacing $h = 1/N$.\n- Grid Type: Marker-And-Cell (MAC), with pressure $p$ at cell centers $(x_i,y_j) = ((i+1/2)h, (j+1/2)h)$ for $i,j \\in \\{0, \\dots, N-1\\}$.\n- Fluid/Solid Definition: A level set function $\\phi(x,y)$ defines the domains. $\\Omega_f = \\{(x,y) | \\phi(x,y) \\ge 0\\}$ is the fluid region. $\\phi(x,y)  0$ is the solid region. The interface is $\\Gamma = \\{(x,y) | \\phi(x,y) = 0\\}$.\n- Manufactured Solution: $p^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y)$.\n- Source Term: $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$.\n- Boundary Conditions: Dirichlet conditions $p = p^\\star(x,y)$ on the outer boundary $\\partial [0,1]^2$ and on the embedded boundary $\\Gamma$.\n- Discretization for Interior Cells: A five-point stencil for the Laplacian: $\\frac{4p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1}}{h^2} = f(x_i,y_j)$.\n- Discretization at Outer Boundary: For a face at distance $\\delta = h/2$ from the cell center, the matrix diagonal $a_P$ and right-hand side $b$ are modified: $a_{P} \\leftarrow a_{P} + \\frac{1}{h\\,\\delta}$ and $b \\leftarrow b + \\frac{p_B}{h\\,\\delta}$, where $p_B$ is $p^\\star$ at the boundary point.\n- Discretization at Embedded Boundary (Cut-Cell): For a fluid cell with center value $\\phi_P$ and a solid neighbor with center value $\\phi_N$, the distance to the interface is $\\delta = \\lambda h$, where $\\lambda = \\frac{\\phi_P}{\\phi_P - \\phi_N}$. The stencil modification is identical in form to the outer boundary case, using this new $\\delta$ and the corresponding boundary value $p_B = p^\\star$ at the interface point.\n- Error Metric: Root-Mean-Square (RMS) error $\\varepsilon_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{(i,j)\\in \\Omega_f} \\left(p_{i,j} - p^\\star(x_i,y_j)\\right)^2}$, where $M$ is the count of fluid cells.\n- Test Cases: Three specific cases are defined by $N$ and the function $\\phi(x,y)$.\n\nStep 2: Validate Using Extracted Givens.\n- **Scientifically Grounded:** The problem describes a standard numerical method (finite volume with cut-cell embedded boundaries) for a canonical elliptic partial differential equation (the Poisson equation). The Method of Manufactured Solutions is a rigorous technique for code verification. The entire problem is firmly rooted in the principles of numerical analysis and computational engineering.\n- **Well-Posed:** The underlying physical problem (Poisson equation with Dirichlet conditions) is well-posed. The described discretization leads to a linear system $A \\mathbf{p} = \\mathbf{b}$ where the matrix $A$ is sparse, symmetric positive-definite (or can be made so), and typically diagonally dominant, ensuring a unique and stable numerical solution exists.\n- **Objective:** The problem is specified with precise mathematical equations, boundary conditions, and numerical parameters. It is free from subjective or ambiguous language.\n\nStep 3: Verdict and Action.\nThe problem is found to be scientifically sound, well-posed, objective, and self-contained. It is a valid problem in computational engineering. I will proceed with a full solution.\n\nThe problem requires the construction of a finite-volume solver for the scalar Poisson equation $-\\nabla^2 p = f$. We begin from the integral form of the equation over a control volume $V_{i,j}$, which is a square cell of area $h^2$ centered at $(x_i, y_j)$. Applying the divergence theorem to the Laplacian term gives:\n$$ -\\int_{V_{i,j}} \\nabla \\cdot (\\nabla p) \\, dV = \\int_{V_{i,j}} f \\, dV $$\n$$ -\\oint_{\\partial V_{i,j}} \\nabla p \\cdot \\mathbf{n} \\, dS = \\int_{V_{i,j}} f \\, dV $$\nIn two dimensions, the control volume is an area and the boundary integral is a line integral over the four faces of the cell (east, west, north, south). Let the side length of the cell be $h$. The equation becomes:\n$$ -\\left[ \\int_{\\text{east}} \\frac{\\partial p}{\\partial x} dy - \\int_{\\text{west}} \\frac{\\partial p}{\\partial x} dy + \\int_{\\text{north}} \\frac{\\partial p}{\\partial y} dx - \\int_{\\text{south}} \\frac{\\partial p}{\\partial y} dx \\right] \\approx f(x_i, y_j) h^2 $$\nApproximating the integrals and gradients, the total flux out of the cell is the sum of fluxes across the four faces. The flux across the east face, for example, is $-h (\\frac{\\partial p}{\\partial x})_e$. The discrete equation for cell $(i,j)$ is a balance of these fluxes:\n$$ -h \\left[ (\\nabla p \\cdot \\mathbf{n})_e + (\\nabla p \\cdot \\mathbf{n})_w + (\\nabla p \\cdot \\mathbf{n})_n + (\\nabla p \\cdot \\mathbf{n})_s \\right] = f_{i,j} h^2 $$\n$$ (\\nabla p \\cdot \\mathbf{n})_e + (\\nabla p \\cdot \\mathbf{n})_w + (\\nabla p \\cdot \\mathbf{n})_n + (\\nabla p \\cdot \\mathbf{n})_s = -f_{i,j} h $$\nWe approximate the normal gradient at each face using a two-point finite difference. The specific approximation depends on whether the neighboring cell is fluid, solid, or outside the domain. Summing all contributions gives a linear equation for $p_{i,j}$.\n\nFor a cell $(i,j)$ where all four neighbors—$(i\\pm1, j)$ and $(i, j\\pm1)$—are also fluid cells, the gradients are approximated using centered differences. For the east face, the gradient is $(\\frac{\\partial p}{\\partial x})_e \\approx \\frac{p_{i+1,j} - p_{i,j}}{h}$. Summing all four flux approximations yields the standard five-point stencil for the negative Laplacian, scaled by $h^2$:\n$$ \\frac{4p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1}}{h^2} = f(x_i,y_j) $$\nThis equation can be rearranged to show contributions to a linear system. For each fluid neighbor, say $(i+1,j)$, the terms are $\\frac{1}{h^2}p_{i,j} - \\frac{1}{h^2}p_{i+1,j}$. This corresponds to adding $\\frac{1}{h^2}$ to the diagonal matrix element for $p_{i,j}$ and $-\\frac{1}{h^2}$ to the off-diagonal element corresponding to the neighbor $p_{i+1,j}$.\n\nWhen a cell face lies on the outer computational boundary (e.g., $x=1$), a Dirichlet condition $p=p_B$ is applied. The face is located at a distance $\\delta = h/2$ from the cell center. The normal gradient is approximated by a one-sided difference: $(\\frac{\\partial p}{\\partial x})_e \\approx \\frac{p_B - p_{i,j}}{\\delta}$. The contribution to the flux balance from this face is $\\frac{p_{i,j} - p_B}{h\\delta}$. This modifies the linear equation for $p_{i,j}$ by adding $\\frac{1}{h\\delta}$ to the diagonal coefficient and adding the known term $\\frac{p_B}{h\\delta}$ to the right-hand side vector.\n\nWhen a fluid cell $(i,j)$ is adjacent to a solid cell, the embedded boundary $\\Gamma$ cuts through the grid. We use the level set function $\\phi$ to locate the interface. Let $\\phi_P = \\phi(x_i, y_j) \\ge 0$ be the value at the fluid cell center and $\\phi_N  0$ be the value at the solid neighbor's center. Assuming $\\phi$ is a signed distance function, linear interpolation gives the fractional distance to the interface as $\\lambda = \\frac{\\phi_P}{\\phi_P - \\phi_N}$. The actual distance is $\\delta = \\lambda h$. The Dirichlet condition $p=p_B$ is applied at this interpolated point on the boundary. The gradient approximation becomes $\\frac{p_B - p_{i,j}}{\\delta}$, and the flux contribution is $\\frac{p_{i,j} - p_B}{h\\delta}$. This results in a stencil modification identical in form to the outer boundary case: the diagonal element is incremented by $\\frac{1}{h\\delta}$ and the right-hand side is incremented by $\\frac{p_B}{h\\delta}$.\n\nA critical edge case arises if a fluid cell center lies on the boundary, i.e., $\\phi(x_i, y_j)=0$. This leads to $\\lambda=0$ and $\\delta=0$, creating a singularity in the flux term $\\frac{1}{h\\delta}$. This is the \"small cell\" problem. The physically correct and numerically stable approach is to recognize that the pressure at this cell center is known by the Dirichlet condition. Therefore, for such a cell, we discard the flux balance equation and directly enforce $p_{i,j} = p^\\star(x_i, y_j)$. In the linear system $A\\mathbf{p}=\\mathbf{b}$, this is accomplished by setting the corresponding row of $A$ to the identity (1 on the diagonal, 0 elsewhere) and setting the corresponding element of $\\mathbf{b}$ to the known boundary value.\n\nThe overall algorithm is as follows:\n1.  Identify all fluid cells where $\\phi(x_i, y_j) \\ge 0$. Create a mapping from the 2D indices $(i,j)$ of these $M$ cells to a 1D index $k \\in [0, M-1]$.\n2.  Construct the $M \\times M$ sparse matrix $A$ and the $M \\times 1$ vector $\\mathbf{b}$.\n3.  For each fluid cell $(i,j)$, iterate through its four neighbors.\n4.  For each neighbor, apply the appropriate rule: standard five-point coupling for a fluid neighbor, or the boundary flux modification for an outer boundary or a solid (cut-cell) neighbor. Update the coefficients of $A$ and the entries of $\\mathbf{b}$ accordingly. Handle the $\\delta=0$ case by setting the Dirichlet condition directly.\n5.  Solve the resulting sparse linear system $A\\mathbf{p} = \\mathbf{b}$ for the vector of unknown pressures $\\mathbf{p}$.\n6.  Compute the RMS error by comparing the numerical solution $p_{i,j}$ to the exact manufactured solution $p^\\star(x_i, y_j)$ over all fluid cells.\n\nThis procedure is implemented for each of the three test cases specified in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef p_star(x: np.ndarray, y: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes the manufactured solution for pressure.\n    All mathematical entities are in LaTeX as required by the role, but not in code comments.\n    p_star(x,y) = sin(pi * x) * sin(pi * y)\n    \"\"\"\n    return np.sin(np.pi * x) * np.sin(np.pi * y)\n\ndef f_source(x: np.ndarray, y: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes the source term f(x,y) corresponding to the manufactured solution.\n    -nabla^2 p_star = 2 * pi^2 * sin(pi * x) * sin(pi * y)\n    \"\"\"\n    return 2.0 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n\ndef run_case(N: int, phi_func) - float:\n    \"\"\"\n    Sets up and solves the Poisson problem for a given test case configuration.\n\n    Args:\n        N: The number of grid cells in each dimension.\n        phi_func: A callable function phi(x,y) that defines the level set.\n\n    Returns:\n        The root-mean-square error of the numerical solution.\n    \"\"\"\n    h = 1.0 / N\n    h2 = h * h\n\n    # Create grid for cell centers\n    i_coords = np.arange(N)\n    j_coords = np.arange(N)\n    x_centers = (i_coords + 0.5) * h\n    y_centers = (j_coords + 0.5) * h\n    xx, yy = np.meshgrid(x_centers, y_centers, indexing='ij')\n\n    # Evaluate level set and identify fluid cells\n    phi_grid = phi_func(xx, yy)\n    is_fluid = phi_grid >= 0\n\n    # Map 2D fluid cell indices to a 1D linear system index\n    fluid_indices = np.where(is_fluid)\n    num_fluid_cells = len(fluid_indices[0])\n    \n    map_ij_to_k = -np.ones((N, N), dtype=int)\n    map_ij_to_k[fluid_indices] = np.arange(num_fluid_cells)\n\n    # Initialize sparse matrix A and vector b\n    A = lil_matrix((num_fluid_cells, num_fluid_cells))\n    b = np.zeros(num_fluid_cells)\n\n    # Iterate over all grid cells to build the linear system\n    for i in range(N):\n        for j in range(N):\n            if not is_fluid[i, j]:\n                continue\n\n            k = map_ij_to_k[i, j]\n            xi, yj = xx[i, j], yy[i, j]\n            \n            # Start with source term on RHS: ... = f_ij\n            b[k] = f_source(xi, yj)\n\n            p_center_phi = phi_grid[i, j]\n\n            # Special case: cell center lies on the boundary (phi_P = 0).\n            # This would lead to delta = 0, causing a singularity.\n            # We enforce the Dirichlet condition directly on this node.\n            if np.isclose(p_center_phi, 0.0):\n                A[k, :] = 0.0\n                A[k, k] = 1.0\n                b[k] = p_star(xi, yj)\n                continue  # Equation for this cell is now fixed.\n\n            # Process 4 neighbors (East, West, North, South)\n            # Tuple format: (di, dj) for index offset\n            neighbors = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n            \n            for di, dj in neighbors:\n                ni, nj = i + di, j + dj\n\n                # Case 1: Outer boundary of the [0,1]x[0,1] domain\n                if not (0 = ni  N and 0 = nj  N):\n                    delta = h / 2.0\n                    xb = xi + di * delta\n                    yb = yj + dj * delta\n                    pb = p_star(xb, yb)\n                    \n                    A[k, k] += 1.0 / (h * delta)\n                    b[k] += pb / (h * delta)\n\n                # Case 2  3: Internal neighbor (either fluid or solid)\n                else:\n                    # Case 2: Neighbor is a fluid cell\n                    if is_fluid[ni, nj]:\n                        nk = map_ij_to_k[ni, nj]\n                        A[k, k] += 1.0 / h2\n                        A[k, nk] -= 1.0 / h2\n                    \n                    # Case 3: Neighbor is a solid cell (cut-cell)\n                    else:\n                        p_neighbor_phi = phi_grid[ni, nj]\n                        phi_diff = p_center_phi - p_neighbor_phi\n                        \n                        # Since phi_P > 0 and phi_N  0, phi_diff is safely non-zero.\n                        lambda_frac = p_center_phi / phi_diff\n                        delta = lambda_frac * h\n                        \n                        # Interface point coordinates\n                        xb = xi + di * delta\n                        yb = yj + dj * delta\n                        pb = p_star(xb, yb)\n                        \n                        A[k, k] += 1.0 / (h * delta)\n                        b[k] += pb / (h * delta)\n\n    # Solve the linear system\n    A_csc = csc_matrix(A)\n    p_vec = spsolve(A_csc, b)\n\n    # Calculate RMS error\n    p_solution_grid = np.full((N, N), np.nan)\n    p_solution_grid[fluid_indices] = p_vec\n\n    p_exact_grid = p_star(xx, yy)\n    \n    squared_errors = (p_solution_grid[is_fluid] - p_exact_grid[is_fluid])**2\n    rms_error = np.sqrt(np.mean(squared_errors))\n    \n    return rms_error\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 64,\n            \"phi_func\": lambda x, y: np.sqrt((x - 0.5)**2 + (y - 0.5)**2) - 0.25\n        },\n        {\n            \"N\": 64,\n            \"phi_func\": lambda x, y: 0.5 - x\n        },\n        {\n            \"N\": 64,\n            \"phi_func\": lambda x, y: np.sqrt((x - 0.75)**2 + (y - 0.5)**2) - 0.24\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rms_error = run_case(case[\"N\"], case[\"phi_func\"])\n        results.append(rms_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2438357"}]}