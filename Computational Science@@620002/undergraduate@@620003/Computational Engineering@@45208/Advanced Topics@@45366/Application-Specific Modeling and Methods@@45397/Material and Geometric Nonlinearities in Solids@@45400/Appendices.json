{"hands_on_practices": [{"introduction": "Our first hands-on practice tackles the essence of material nonlinearity: plasticity. Many engineering materials, like metals, exhibit permanent deformation when loaded beyond a certain threshold. This exercise will guide you through the implementation of the cornerstone algorithm for computational plasticity—the radial return mapping method—for a one-dimensional model with isotropic hardening [@problem_id:2411414]. Mastering this implicit, backward Euler integration scheme provides a foundational understanding of how to numerically solve the evolution equations that govern path-dependent material behavior.", "problem": "Implement a one-dimensional implicit backward Euler stress update for a rate-independent von Mises plasticity model with isotropic hardening (radial return mapping), suitable for small-strain uniaxial loading. Begin from fundamental laws in solid mechanics. The implementation must update stress and internal variables for a single strain increment using backward Euler time discretization. Your program must be self-contained and compute, for each provided test case, the updated stress, plastic strain, accumulated plastic strain, and the consistent algorithmic tangent modulus.\n\nAssumptions and definitions:\n- Small strain kinematics. The total strain is denoted by $\\,\\varepsilon\\,$, the plastic strain by $\\,\\varepsilon^{p}\\,$, and the accumulated plastic strain by $\\,\\alpha\\,$.\n- Linear elastic constitutive relation in one dimension with Young’s modulus $\\,E\\,$: $\\,\\sigma = E\\left(\\varepsilon - \\varepsilon^{p}\\right)\\,$, where $\\,\\sigma\\,$ is the Cauchy stress.\n- Isotropic hardening with a constant hardening modulus $\\,H \\ge 0\\,$ and initial yield stress $\\,\\sigma_{y0} > 0\\,$. The current yield stress is $\\,\\sigma_{y}(\\alpha) = \\sigma_{y0} + H\\,\\alpha\\,$.\n- Von Mises yield function specialized to one dimension: $\\,f(\\sigma,\\alpha)=|\\sigma|-\\sigma_{y}(\\alpha)\\,$ with admissibility $\\,f \\le 0\\,$.\n- Associative flow with consistency. The plastic flow direction in one dimension is the sign of $\\,\\sigma\\,$.\n\nDiscretization goal:\n- Given the material parameters $\\,E\\,$ (in $\\mathrm{Pa}$), $\\,H\\,$ (in $\\mathrm{Pa}$), and $\\,\\sigma_{y0}\\,$ (in $\\mathrm{Pa}$), and the state at step $\\,n\\,$ consisting of $\\,\\varepsilon^{p}_{n}\\,$ and $\\,\\alpha_{n}\\,$ (both dimensionless), along with the prescribed total strain at step $\\,n+1\\,$, denoted $\\,\\varepsilon_{n+1}\\,$ (dimensionless), use an implicit backward Euler return-mapping scheme to compute the updated values $\\,\\sigma_{n+1}\\,$ (in $\\mathrm{Pa}$), $\\,\\varepsilon^{p}_{n+1}\\,$ (dimensionless), $\\,\\alpha_{n+1}\\,$ (dimensionless), and the consistent algorithmic tangent modulus $\\,E_{\\mathrm{tan},\\,n+1}\\,$ (in $\\mathrm{Pa}$).\n\nNumerical requirements:\n- Your algorithm must implement an elastic trial state and a radial return to the yield surface if the trial state violates admissibility. Use a numerically robust treatment of the yield condition to decide between elastic and plastic response.\n- Angles do not appear; no angle units are needed.\n- All stresses must be expressed in $\\mathrm{Pa}$ and strains are dimensionless.\n\nTest suite:\nFor each test, the input tuple is $\\,\\left(E,\\,H,\\,\\sigma_{y0},\\,\\varepsilon_{n+1},\\,\\varepsilon^{p}_{n},\\,\\alpha_{n}\\right)\\,$. Your program must compute the outputs $\\,\\left[\\sigma_{n+1},\\,\\varepsilon^{p}_{n+1},\\,\\alpha_{n+1},\\,E_{\\mathrm{tan},\\,n+1}\\right]\\,$.\n\nProvide results for the following six test cases:\n1. $\\,\\left( E=210\\times 10^{9}\\,\\mathrm{Pa},\\; H=2\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=400\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=1.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n2. $\\,\\left( E=200\\times 10^{9}\\,\\mathrm{Pa},\\; H=1\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=250\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=1.25\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n3. $\\,\\left( E=200\\times 10^{9}\\,\\mathrm{Pa},\\; H=1\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=250\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=2.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n4. $\\,\\left( E=210\\times 10^{9}\\,\\mathrm{Pa},\\; H=2\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=400\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=3.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=1.0\\times 10^{-3},\\; \\alpha_{n}=1.0\\times 10^{-3} \\right)\\,$\n5. $\\,\\left( E=210\\times 10^{9}\\,\\mathrm{Pa},\\; H=2\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=400\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=-5.0\\times 10^{-4},\\; \\varepsilon^{p}_{n}=1.0\\times 10^{-3},\\; \\alpha_{n}=1.0\\times 10^{-3} \\right)\\,$\n6. $\\,\\left( E=100\\times 10^{9}\\,\\mathrm{Pa},\\; H=0,\\; \\sigma_{y0}=100\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=2.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a list of lists:\n  $\\,\\bigl[\\,[\\sigma_{1},\\,\\varepsilon^{p}_{1},\\,\\alpha_{1},\\,E_{\\mathrm{tan},1}],\\;[\\sigma_{2},\\,\\varepsilon^{p}_{2},\\,\\alpha_{2},\\,E_{\\mathrm{tan},2}],\\;\\dotsc,\\;[\\sigma_{6},\\,\\varepsilon^{p}_{6},\\,\\alpha_{6},\\,E_{\\mathrm{tan},6}]\\,\\bigr]\\,$\n- Each $\\,\\sigma_{i}\\,$ and $\\,E_{\\mathrm{tan},i}\\,$ must be in $\\mathrm{Pa}$, and $\\,\\varepsilon^{p}_{i}\\,$ and $\\,\\alpha_{i}\\,$ must be dimensionless. Do not include any text or units in the output; only the numeric lists must be printed.", "solution": "The problem as stated is valid. It is a well-posed, scientifically grounded problem from the field of computational solid mechanics, with all necessary information provided. We shall proceed with the derivation and solution.\n\nThe problem requires the implementation of an implicit, one-dimensional, rate-independent elastoplasticity model with isotropic hardening. The core of the task is the stress update procedure for a single time increment using the backward Euler method, a technique commonly known as the radial return mapping algorithm.\n\n**$1$. Fundamental Constitutive Equations**\n\nWe begin by stating the governing equations for the one-dimensional model in their continuous, rate-based form.\n\n- **Strain Decomposition**: The total strain, $\\varepsilon$, is additively decomposed into an elastic part, $\\varepsilon^{e}$, and a plastic part, $\\varepsilon^{p}$:\n$$ \\varepsilon = \\varepsilon^{e} + \\varepsilon^{p} $$\nIn rate form:\n$$ \\dot{\\varepsilon} = \\dot{\\varepsilon}^{e} + \\dot{\\varepsilon}^{p} $$\n\n- **Elastic Law**: The stress, $\\sigma$, is related to the elastic strain through a linear-elastic (Hooke's) law with Young's modulus, $E$:\n$$ \\sigma = E \\varepsilon^{e} = E (\\varepsilon - \\varepsilon^{p}) $$\nThe rate form is:\n$$ \\dot{\\sigma} = E \\dot{\\varepsilon}^{e} = E (\\dot{\\varepsilon} - \\dot{\\varepsilon}^{p}) $$\n\n- **Yield Function**: The boundary of the elastic domain is defined by the von Mises yield function, $f$, specialized for one dimension. It depends on the stress, $\\sigma$, and an internal variable, the accumulated plastic strain, $\\alpha$:\n$$ f(\\sigma, \\alpha) = |\\sigma| - \\sigma_{y}(\\alpha) \\le 0 $$\nwhere $\\sigma_{y}(\\alpha)$ is the current yield stress.\n\n- **Isotropic Hardening Law**: The current yield stress, $\\sigma_{y}(\\alpha)$, evolves with the accumulated plastic strain, $\\alpha$, according to a linear isotropic hardening rule:\n$$ \\sigma_{y}(\\alpha) = \\sigma_{y0} + H\\alpha $$\nHere, $\\sigma_{y0}$ is the initial yield stress and $H$ is the constant hardening modulus.\n\n- **Flow Rule and Hardening Evolution**: The plastic flow is associative, meaning the plastic strain rate, $\\dot{\\varepsilon}^{p}$, is normal to the yield surface. The evolution of the internal variables is governed by the plastic multiplier rate, $\\dot{\\gamma}$:\n$$ \\dot{\\varepsilon}^{p} = \\dot{\\gamma} \\frac{\\partial f}{\\partial \\sigma} = \\dot{\\gamma} \\, \\mathrm{sgn}(\\sigma) $$\n$$ \\dot{\\alpha} = \\dot{\\gamma} \\sqrt{\\left(\\frac{\\partial f}{\\partial \\sigma}\\right)^2} = \\dot{\\gamma} |\\mathrm{sgn}(\\sigma)| = \\dot{\\gamma} $$\n\n- **Karush-Kuhn-Tucker (KKT) Loading/Unloading Conditions**: These conditions govern the plastic flow:\n$$ \\dot{\\gamma} \\ge 0, \\quad f(\\sigma, \\alpha) \\le 0, \\quad \\dot{\\gamma} f(\\sigma, \\alpha) = 0 $$\nIf plastic loading occurs ($\\dot{\\gamma} > 0$), the state must remain on the yield surface ($f=0$), which implies the consistency condition $\\dot{f}=0$.\n\n**$2$. Implicit Backward Euler Discretization**\n\nWe integrate the rate equations over a time increment from $t_{n}$ to $t_{n+1}$ using the implicit backward Euler scheme. This means all rate terms are evaluated at the end of the step, $t_{n+1}$. Given the state $(\\varepsilon^{p}_{n}, \\alpha_{n})$ at step $n$ and the total strain $\\varepsilon_{n+1}$ at step $n+1$, we must find $(\\sigma_{n+1}, \\varepsilon^{p}_{n+1}, \\alpha_{n+1})$.\n\nThe discretized evolution equations are:\n$$ \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\varepsilon^{p} = \\varepsilon^{p}_{n} + \\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}) $$\n$$ \\alpha_{n+1} = \\alpha_{n} + \\Delta\\alpha = \\alpha_{n} + \\Delta\\gamma $$\nwhere $\\Delta\\gamma = \\int_{t_n}^{t_{n+1}} \\dot{\\gamma} \\, dt$ is the finite plastic multiplier increment, which must be non-negative, $\\Delta\\gamma \\ge 0$.\n\nThe stress at the end of the step is:\n$$ \\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1}) $$\n\nThe KKT conditions in discrete form become:\n$$ \\Delta\\gamma \\ge 0, \\quad f_{n+1} = |\\sigma_{n+1}| - \\sigma_{y}(\\alpha_{n+1}) \\le 0, \\quad \\Delta\\gamma f_{n+1} = 0 $$\n\n**$3$. The Return-Mapping Algorithm**\n\nThis algorithm provides a robust method to solve the discretized system. It consists of an elastic prediction followed by a plastic correction if the prediction violates the yield condition.\n\n**Step $3.1$: Elastic Predictor**\n\nFirst, we assume the step is purely elastic, which implies $\\Delta\\gamma = 0$. This gives a \"trial\" state.\nThe plastic strain and accumulated plastic strain do not change:\n$$ \\varepsilon^{p, \\mathrm{trial}}_{n+1} = \\varepsilon^{p}_{n} $$\n$$ \\alpha^{\\mathrm{trial}}_{n+1} = \\alpha_{n} $$\nThe trial stress is computed from Hooke's law:\n$$ \\sigma^{\\mathrm{trial}}_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n}) $$\n\n**Step $3.2$: Yield Check**\n\nWe check if this trial state is admissible by evaluating the yield function. The yield stress for this check is based on the state at the beginning of the increment:\n$$ \\sigma_{y,n} = \\sigma_{y0} + H\\alpha_{n} $$\nThe trial yield function value is:\n$$ f^{\\mathrm{trial}}_{n+1} = |\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n} $$\n- If $f^{\\mathrm{trial}}_{n+1} \\le 0$, the elastic assumption is correct. The material response is elastic. The final state is the trial state:\n  $$ \\sigma_{n+1} = \\sigma^{\\mathrm{trial}}_{n+1}, \\quad \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n}, \\quad \\alpha_{n+1} = \\alpha_{n} $$\n- If $f^{\\mathrm{trial}}_{n+1} > 0$, the elastic assumption is violated. Plastic deformation occurs, and a plastic correction is necessary.\n\n**Step $3.3$: Plastic Corrector**\n\nFor a plastic step, we must find $\\Delta\\gamma > 0$ such that the final state $(\\sigma_{n+1}, \\alpha_{n+1})$ lies on the updated yield surface, i.e., $f_{n+1} = 0$.\n$$ |\\sigma_{n+1}| - (\\sigma_{y0} + H\\alpha_{n+1}) = 0 $$\nSubstitute the discretized evolution equations:\n$$ |\\sigma_{n+1}| = \\sigma_{y0} + H(\\alpha_{n} + \\Delta\\gamma) = (\\sigma_{y0} + H\\alpha_{n}) + H\\Delta\\gamma = \\sigma_{y,n} + H\\Delta\\gamma $$\nNow, express $\\sigma_{n+1}$ in terms of the trial stress and $\\Delta\\gamma$:\n$$ \\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1}) = E(\\varepsilon_{n+1} - (\\varepsilon^{p}_{n} + \\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}))) $$\n$$ \\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n}) - E\\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}) = \\sigma^{\\mathrm{trial}}_{n+1} - E\\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}) $$\nA key aspect of this algorithm is that the stress sign does not change during the return, so $\\mathrm{sgn}(\\sigma_{n+1}) = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})$. Taking the absolute value:\n$$ |\\sigma_{n+1}| = |\\sigma^{\\mathrm{trial}}_{n+1}| - E\\Delta\\gamma $$\nThis equation describes the \"return\" of the stress magnitude from the trial value back to the yield surface. Equating the two expressions for $|\\sigma_{n+1}|$:\n$$ |\\sigma^{\\mathrm{trial}}_{n+1}| - E\\Delta\\gamma = \\sigma_{y,n} + H\\Delta\\gamma $$\nSolving for the plastic multiplier increment, $\\Delta\\gamma$:\n$$ |\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n} = (E+H)\\Delta\\gamma $$\n$$ \\Delta\\gamma = \\frac{|\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n}}{E+H} = \\frac{f^{\\mathrm{trial}}_{n+1}}{E+H} $$\nSince we are in the plastic case, $f^{\\mathrm{trial}}_{n+1} > 0$. As $E > 0$ and $H \\ge 0$, we correctly find $\\Delta\\gamma > 0$.\n\nOnce $\\Delta\\gamma$ is known, we update the state variables:\n$$ \\alpha_{n+1} = \\alpha_{n} + \\Delta\\gamma $$\n$$ \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\gamma \\, \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) $$\nThe updated stress $\\sigma_{n+1}$ can be computed by returning from the trial stress or by using the final yield condition. Using the latter is often more robust:\n$$ \\sigma_{n+1} = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) \\times \\sigma_{y}(\\alpha_{n+1}) = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) \\times (\\sigma_{y,n} + H\\Delta\\gamma) $$\n\n**$4$. Consistent Algorithmic Tangent Modulus**\n\nThe consistent algorithmic tangent modulus, $E_{\\mathrm{tan},n+1}$, is defined as the derivative of the final stress with respect to the final total strain, $E_{\\mathrm{tan},n+1} = \\frac{d\\sigma_{n+1}}{d\\varepsilon_{n+1}}$. It is essential for implicit finite element methods.\n\n- **Elastic Case**: If the step is elastic, $\\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n})$.\n$$ E_{\\mathrm{tan},n+1} = \\frac{d}{d\\varepsilon_{n+1}} [E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n})] = E $$\n\n- **Plastic Case**: If the step is plastic, we differentiate the final stress expression. A convenient form for differentiation is:\n$$ \\sigma_{n+1} = \\frac{\\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})E\\sigma_{y,n} + HE(\\varepsilon_{n+1} - \\varepsilon^{p}_n)}{E+H} $$\nDifferentiating with respect to $\\varepsilon_{n+1}$ (and treating $\\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})$ as constant for an infinitesimal change in $\\varepsilon_{n+1}$):\n$$ E_{\\mathrm{tan},n+1} = \\frac{d\\sigma_{n+1}}{d\\varepsilon_{n+1}} = \\frac{d}{d\\varepsilon_{n+1}} \\left[ \\frac{\\mathrm{const} + HE\\varepsilon_{n+1}}{E+H} \\right] = \\frac{HE}{E+H} $$\nFor perfect plasticity ($H=0$), this correctly gives $E_{\\mathrm{tan},n+1} = 0$.\n\n**$5$. Algorithm Summary for Implementation**\n\nFor each input tuple $(E, H, \\sigma_{y0}, \\varepsilon_{n+1}, \\varepsilon^{p}_{n}, \\alpha_{n})$:\n1.  Calculate trial stress: $\\sigma^{\\mathrm{trial}}_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n})$.\n2.  Calculate yield stress based on previous state: $\\sigma_{y,n} = \\sigma_{y0} + H\\alpha_{n}$.\n3.  Evaluate trial yield function: $f^{\\mathrm{trial}}_{n+1} = |\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n}$.\n4.  **If $f^{\\mathrm{trial}}_{n+1} \\le 0$ (Elastic step):**\n    - $\\sigma_{n+1} = \\sigma^{\\mathrm{trial}}_{n+1}$\n    - $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n}$\n    - $\\alpha_{n+1} = \\alpha_{n}$\n    - $E_{\\mathrm{tan},n+1} = E$\n5.  **Else (Plastic step):**\n    - $\\Delta\\gamma = f^{\\mathrm{trial}}_{n+1} / (E+H)$.\n    - $\\alpha_{n+1} = \\alpha_{n} + \\Delta\\gamma$.\n    - $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\gamma \\cdot \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})$.\n    - $\\sigma_{n+1} = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) \\cdot (\\sigma_{y,n} + H\\Delta\\gamma)$.\n    - $E_{\\mathrm{tan},n+1} = (E \\cdot H) / (E+H)$.\n6.  Return the computed values $[\\sigma_{n+1}, \\varepsilon^{p}_{n+1}, \\alpha_{n+1}, E_{\\mathrm{tan},n+1}]$.\n\nThis algorithm is now ready for implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef update_stress(E, H, sig_y0, eps_n1, eps_p_n, alpha_n):\n    \"\"\"\n    Computes the updated stress, plastic strain, accumulated plastic strain,\n    and consistent tangent modulus for a 1D J2 plasticity model with\n    isotropic hardening using an implicit backward Euler return-mapping algorithm.\n\n    Args:\n        E (float): Young's modulus in Pa.\n        H (float): Hardening modulus in Pa.\n        sig_y0 (float): Initial yield stress in Pa.\n        eps_n1 (float): Total strain at step n+1 (dimensionless).\n        eps_p_n (float): Plastic strain at step n (dimensionless).\n        alpha_n (float): Accumulated plastic strain at step n (dimensionless).\n\n    Returns:\n        list: A list containing [sig_n1, eps_p_n1, alpha_n1, E_tan_n1].\n    \"\"\"\n    # Step 1: Elastic predictor (trial state)\n    sig_trial_n1 = E * (eps_n1 - eps_p_n)\n\n    # Step 2: Yield check\n    # Yield stress from the previous converged step n\n    sig_y_n = sig_y0 + H * alpha_n\n    \n    # Evaluate yield function at the trial state\n    f_trial_n1 = np.abs(sig_trial_n1) - sig_y_n\n\n    # Step 3: Determine if the step is elastic or plastic\n    if f_trial_n1 <= 0:\n        # Elastic step\n        sig_n1 = sig_trial_n1\n        eps_p_n1 = eps_p_n\n        alpha_n1 = alpha_n\n        E_tan_n1 = E\n    else:\n        # Plastic step (plastic corrector)\n        \n        # Calculate the plastic multiplier increment\n        # E > 0 and H >= 0, so E + H > 0.\n        delta_gamma = f_trial_n1 / (E + H)\n\n        # Update internal variables\n        alpha_n1 = alpha_n + delta_gamma\n        \n        # The sign of trial stress determines the direction of plastic flow.\n        # If sig_trial_n1 were 0, f_trial_n1 would be <= 0, so we would be\n        # in the elastic branch. Thus, sig_trial_n1 is non-zero here.\n        sign_sig_trial = np.sign(sig_trial_n1)\n        \n        eps_p_n1 = eps_p_n + delta_gamma * sign_sig_trial\n\n        # Update stress by returning to the updated yield surface.\n        # This form is numerically stable and directly enforces the yield condition.\n        sig_n1 = sign_sig_trial * (sig_y_n + H * delta_gamma)\n\n        # Calculate the consistent algorithmic tangent modulus for the plastic case\n        E_tan_n1 = (E * H) / (E + H)\n\n    return [sig_n1, eps_p_n1, alpha_n1, E_tan_n1]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (E, H, sigma_y0, epsilon_n+1, epsilon_p_n, alpha_n)\n    test_cases = [\n        (210e9, 2e9, 400e6, 1.0e-3, 0.0, 0.0),\n        (200e9, 1e9, 250e6, 1.25e-3, 0.0, 0.0),\n        (200e9, 1e9, 250e6, 2.0e-3, 0.0, 0.0),\n        (210e9, 2e9, 400e6, 3.0e-3, 1.0e-3, 1.0e-3),\n        (210e9, 2e9, 400e6, -5.0e-4, 1.0e-3, 1.0e-3),\n        (100e9, 0.0, 100e6, 2.0e-3, 0.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for the current test case\n        E, H, sig_y0, eps_n1, eps_p_n, alpha_n = case\n        \n        # Calculate the updated state\n        result = update_stress(E, H, sig_y0, eps_n1, eps_p_n, alpha_n)\n        results.append(result)\n\n    # Format the output string to be exactly as specified: [[r1,r2,...],[...],...]\n    # without extra spaces.\n    inner_lists = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output_str = f\"[{','.join(inner_lists)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```", "id": "2411414"}, {"introduction": "Next, we pivot from material response to how large changes in geometry influence a structure's stiffness. This is the domain of geometric nonlinearity. In this exercise, you will implement the geometric stiffness matrix, $\\mathbf{K}_{\\sigma}$, for a two-dimensional truss element [@problem_id:2411426]. This matrix is a fundamental concept in finite element analysis that accounts for the influence of the existing axial force on the element's stiffness, which is the root cause of effects like buckling. The practice includes a neat analytical verification, allowing you to confirm the correctness of your implementation from first principles.", "problem": "Implement a complete and runnable program that computes the geometric stiffness matrix $K_{\\sigma}$ for a two-dimensional ($2$D) straight truss element with two nodes undergoing large rotations and small axial strains, and verifies it on a set of prescribed configurations.\n\nThe geometric stiffness matrix $K_{\\sigma}$ is defined as the initial-stress contribution to the consistent tangent stiffness obtained from the principle of virtual work for a straight bar with two translational degrees of freedom (degrees of freedom (DOF)) per node. Let the element connect node $1$ at current position $\\mathbf{x}_1 = (x_1,y_1)$ and node $2$ at current position $\\mathbf{x}_2 = (x_2,y_2)$, with current length $l = \\|\\mathbf{x}_2 - \\mathbf{x}_1\\|$ and current unit tangent $\\mathbf{t} = (\\mathbf{x}_2 - \\mathbf{x}_1)/l$. Let the initial (reference) positions be $\\mathbf{X}_1 = (X_1,Y_1)$ and $\\mathbf{X}_2 = (X_2,Y_2)$ with initial length $L_0 = \\|\\mathbf{X}_2 - \\mathbf{X}_1\\|$. The material is linear elastic with Young’s modulus $E$ and constant cross-sectional area $A$. Assume small axial strain but allow arbitrarily large rigid-body rotation of the chord. The axial force $N$ is to be computed from the axial extension as $N = (EA/L_0)\\,(l - L_0)$ and used in the geometric stiffness. All forces must be expressed in newtons and all lengths in meters.\n\nYour program must:\n- For each test case, compute the axial force $N$ in newtons from the given $E$, $A$, $L_0$, and the current configuration.\n- Construct the geometric stiffness matrix $K_{\\sigma}$ in the global coordinates of size $4\\times 4$ corresponding to the DOF ordering $(x_1,y_1,x_2,y_2)$, expressed in newtons per meter.\n- For verification, compute the Frobenius norm $\\|K_{\\sigma}\\|_F$ and compare it against the scalar $2|N|/l$ (units: newtons per meter). Report, for each test case, the scalar difference $\\Delta = \\|K_{\\sigma}\\|_F - 2|N|/l$ in newtons per meter.\n\nAngles, when specified below, are in radians. All output values must be reported in newtons per meter and rounded to $9$ decimal places.\n\nTest suite (each case is independent):\n- Case A (rigid rotation, zero extension):\n  - $E = 2.10\\times 10^{11}\\,\\mathrm{Pa}$, $A = 3.0\\times 10^{-4}\\,\\mathrm{m}^2$.\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{X}_2 = (1,0)\\,\\mathrm{m}$, so $L_0 = 1.0\\,\\mathrm{m}$.\n  - Current configuration: pure rotation by angle $\\theta = \\pi/3$ about node $1$, that is $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{x}_2 = (L_0\\cos\\theta,\\,L_0\\sin\\theta)\\,\\mathrm{m}$.\n- Case B (pure axial tension, no rotation):\n  - $E = 7.0\\times 10^{10}\\,\\mathrm{Pa}$, $A = 1.2\\times 10^{-4}\\,\\mathrm{m}^2$.\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{X}_2 = (2,0)\\,\\mathrm{m}$, so $L_0 = 2.0\\,\\mathrm{m}$.\n  - Current configuration: $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{x}_2 = (2.02,\\,0)\\,\\mathrm{m}$.\n- Case C (large rotation with compression):\n  - $E = 2.00\\times 10^{11}\\,\\mathrm{Pa}$, $A = 2.5\\times 10^{-4}\\,\\mathrm{m}^2$.\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{X}_2 = (1.5,0)\\,\\mathrm{m}$, so $L_0 = 1.5\\,\\mathrm{m}$.\n  - Current configuration: rotation by $\\theta = 1.74532925199433$ and radial shortening by $\\delta = -0.01\\,\\mathrm{m}$, that is $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{x}_2 = ((L_0+\\delta)\\cos\\theta,\\,(L_0+\\delta)\\sin\\theta)\\,\\mathrm{m}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of cases A, B, C, for example $[\\Delta_A,\\Delta_B,\\Delta_C]$, where each $\\Delta$ is a float in newtons per meter rounded to $9$ decimal places.", "solution": "The user has submitted a problem for evaluation and solution. The first mandatory step is a critical validation of the problem statement.\n\n### Step 1: Extract Givens\n\nThe problem statement provides the following information:\n- **Element Definition**: A two-dimensional ($2$D) straight truss element with two nodes.\n- **Degrees of Freedom (DOF)**: Two translational DOFs per node. The global DOF vector is ordered as $(x_1, y_1, x_2, y_2)$.\n- **Kinematic Assumptions**: Large rigid-body rotations and small axial strains.\n- **Node Positions**:\n    - Reference (initial) positions: $\\mathbf{X}_1 = (X_1, Y_1)$, $\\mathbf{X}_2 = (X_2, Y_2)$\n    - Current positions: $\\mathbf{x}_1 = (x_1, y_1)$, $\\mathbf{x}_2 = (x_2, y_2)$\n- **Element Lengths**:\n    - Initial length: $L_0 = \\|\\mathbf{X}_2 - \\mathbf{X}_1\\|$\n    - Current length: $l = \\|\\mathbf{x}_2 - \\mathbf{x}_1\\|$\n- **Element Tangent Vector**: Current unit tangent $\\mathbf{t} = (\\mathbf{x}_2 - \\mathbf{x}_1)/l$.\n- **Material Properties**: Linear elastic with Young’s modulus $E$ and constant cross-sectional area $A$.\n- **Constitutive Law**: Axial force $N = (EA/L_0)\\,(l - L_0)$.\n- **Target Quantity**: The geometric stiffness matrix $\\mathbf{K}_{\\sigma}$ in global coordinates, defined as the initial-stress contribution to the consistent tangent stiffness. It is a $4 \\times 4$ matrix.\n- **Verification Task**: For each test case, compute the scalar difference $\\Delta = \\|K_{\\sigma}\\|_F - 2|N|/l$, where $\\|K_{\\sigma}\\|_F$ is the Frobenius norm of the geometric stiffness matrix.\n- **Units**: Forces in newtons (N), lengths in meters (m), pressures in pascals (Pa). Output $\\Delta$ in N/m.\n- **Output Precision**: All output values must be rounded to $9$ decimal places.\n\n- **Test Case A**:\n  - $E = 2.10 \\times 10^{11}\\,\\mathrm{Pa}$, $A = 3.0 \\times 10^{-4}\\,\\mathrm{m}^2$.\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{X}_2 = (1,0)\\,\\mathrm{m}$ ($L_0 = 1.0\\,\\mathrm{m}$).\n  - Current configuration: rotation by $\\theta = \\pi/3$ about node $1$, so $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{x}_2 = (L_0\\cos\\theta,\\,L_0\\sin\\theta)\\,\\mathrm{m}$.\n\n- **Test Case B**:\n  - $E = 7.0 \\times 10^{10}\\,\\mathrm{Pa}$, $A = 1.2 \\times 10^{-4}\\,\\mathrm{m}^2$.\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{X}_2 = (2,0)\\,\\mathrm{m}$ ($L_0 = 2.0\\,\\mathrm{m}$).\n  - Current configuration: $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{x}_2 = (2.02,\\,0)\\,\\mathrm{m}$.\n\n- **Test Case C**:\n  - $E = 2.00 \\times 10^{11}\\,\\mathrm{Pa}$, $A = 2.5 \\times 10^{-4}\\,\\mathrm{m}^2$.\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{X}_2 = (1.5,0)\\,\\mathrm{m}$ ($L_0 = 1.5\\,\\mathrm{m}$).\n  - Current configuration: rotation by $\\theta = 1.74532925199433\\,\\mathrm{rad}$ and radial shortening $\\delta = -0.01\\,\\mathrm{m}$, so $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{x}_2 = ((L_0+\\delta)\\cos\\theta,\\,(L_0+\\delta)\\sin\\theta)\\,\\mathrm{m}$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is evaluated against the required criteria:\n- **Scientifically Grounded**: The problem is rooted in the finite element analysis of structures, specifically in the context of geometric nonlinearity. The concept of a geometric stiffness matrix ($\\mathbf{K}_\\sigma$) is a standard and fundamental component in computational solid mechanics for capturing the influence of existing stress on the stiffness (e.g., stress stiffening or softening effects). The provided formula for the axial force, $N = (EA/L_0)(l - L_0)$, is a direct application of Hooke's law to the total extension of the bar, which is consistent with a co-rotational formulation or a total Lagrangian formulation under the small strain assumption. The problem is a standard exercise in this domain.\n- **Well-Posed**: The problem is well-posed. For each test case, all necessary data ($E, A$, initial and current coordinates) are provided. The definitions for all quantities to be computed ($L_0, l, N, \\mathbf{K}_\\sigma, \\|K_{\\sigma}\\|_F, \\Delta$) are unambiguous. The instructions lead to a unique, deterministic result for each case.\n- **Objective**: The language is entirely objective, employing precise mathematical and engineering terminology. There are no subjective or opinion-based statements. The inputs and desired outputs are quantifiable.\n\nThe problem does not exhibit any of the enumerated invalidity flaws. It is scientifically sound, relates directly to the specified topic, is complete, physically plausible, and well-structured.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A complete, reasoned solution will now be provided.\n\n### Solution Derivation\n\nThe analysis of structures undergoing large displacements but small strains requires consideration of geometric nonlinearity. The total tangent stiffness matrix, $\\mathbf{K}_T$, is the sum of the material stiffness matrix, $\\mathbf{K}_m$ (dependent on material properties and geometry), and the geometric stiffness matrix, $\\mathbf{K}_\\sigma$ (dependent on the current stress state).\n$$\n\\mathbf{K}_T = \\mathbf{K}_m + \\mathbf{K}_\\sigma\n$$\nThe problem focuses solely on the computation of $\\mathbf{K}_\\sigma$. This matrix arises from the variation of the internal force vector with respect to geometry changes. For a $2$D truss element subjected to an axial force $N$ (positive for tension, negative for compression), the geometric stiffness matrix in the global coordinate system is given by the well-established formula:\n$$\n\\mathbf{K}_{\\sigma} = \\frac{N}{l}\n\\begin{bmatrix}\n\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t} & -(\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}) \\\\\n-(\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}) & \\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}\n\\end{bmatrix}\n$$\nIn this expression, $l$ is the current length of the element, $N$ is the axial force, $\\mathbf{I}$ is the $2 \\times 2$ identity matrix, and $\\mathbf{t}$ is the unit vector along the element's axis in the current configuration, defined as $\\mathbf{t} = (t_x, t_y)^T = \\frac{1}{l}(\\mathbf{x}_2 - \\mathbf{x}_1)$. The symbol $\\otimes$ denotes the tensor product.\n\nThe $2 \\times 2$ submatrix $\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}$ can be expanded. Since $\\mathbf{t}$ is a unit vector, $t_x^2 + t_y^2 = 1$.\n$$\n\\mathbf{t} \\otimes \\mathbf{t} = \\begin{bmatrix} t_x \\\\ t_y \\end{bmatrix} \\begin{bmatrix} t_x & t_y \\end{bmatrix} = \\begin{bmatrix} t_x^2 & t_x t_y \\\\ t_x t_y & t_y^2 \\end{bmatrix}\n$$\nTherefore,\n$$\n\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t} = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} - \\begin{bmatrix} t_x^2 & t_x t_y \\\\ t_x t_y & t_y^2 \\end{bmatrix} = \\begin{bmatrix} 1 - t_x^2 & -t_x t_y \\\\ -t_x t_y & 1 - t_y^2 \\end{bmatrix} = \\begin{bmatrix} t_y^2 & -t_x t_y \\\\ -t_x t_y & t_x^2 \\end{bmatrix}\n$$\nLet us denote this submatrix as $\\mathbf{M}$. Then the full $4 \\times 4$ geometric stiffness matrix, corresponding to the global DOFs $(x_1, y_1, x_2, y_2)$, is:\n$$\n\\mathbf{K}_{\\sigma} = \\frac{N}{l} \\begin{bmatrix} \\mathbf{M} & -\\mathbf{M} \\\\ -\\mathbf{M} & \\mathbf{M} \\end{bmatrix} = \\frac{N}{l}\n\\begin{bmatrix}\nt_y^2 & -t_x t_y & -t_y^2 & t_x t_y \\\\\n-t_x t_y & t_x^2 & t_x t_y & -t_x^2 \\\\\n-t_y^2 & t_x t_y & t_y^2 & -t_x t_y \\\\\nt_x t_y & -t_x^2 & -t_x t_y & t_x^2\n\\end{bmatrix}\n$$\nThe problem requires the calculation of the Frobenius norm of this matrix, $\\|\\mathbf{K}_{\\sigma}\\|_F$. The squared Frobenius norm is the sum of the squares of all its elements.\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F^2 = \\text{tr}(\\mathbf{K}_{\\sigma}^T \\mathbf{K}_{\\sigma}) = \\sum_{i,j} (K_{\\sigma,ij})^2\n$$\nObserving the structure of $\\mathbf{K}_{\\sigma} = \\frac{N}{l} \\begin{bmatrix} \\mathbf{M} & -\\mathbf{M} \\\\ -\\mathbf{M} & \\mathbf{M} \\end{bmatrix}$, its squared Frobenius norm is:\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F^2 = \\left(\\frac{N}{l}\\right)^2 \\left( \\|\\mathbf{M}\\|_F^2 + \\|-\\mathbf{M}\\|_F^2 + \\|-\\mathbf{M}\\|_F^2 + \\|\\mathbf{M}\\|_F^2 \\right) = 4 \\left(\\frac{N}{l}\\right)^2 \\|\\mathbf{M}\\|_F^2\n$$\nLet us compute the squared Frobenius norm of the submatrix $\\mathbf{M}$:\n$$\n\\|\\mathbf{M}\\|_F^2 = (t_y^2)^2 + (-t_x t_y)^2 + (-t_x t_y)^2 + (t_x^2)^2 = t_y^4 + t_x^2 t_y^2 + t_x^2 t_y^2 + t_x^4\n$$\n$$\n\\|\\mathbf{M}\\|_F^2 = t_y^2(t_y^2 + t_x^2) + t_x^2(t_y^2 + t_x^2) = (t_y^2 + t_x^2)(t_x^2 + t_y^2) = (1)(1) = 1\n$$\nThis is because $\\mathbf{t}$ is a unit vector, so $t_x^2+t_y^2=1$.\nSubstituting this result back, we find:\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F^2 = 4 \\left(\\frac{N}{l}\\right)^2 (1) = 4 \\frac{N^2}{l^2}\n$$\nTaking the square root gives the Frobenius norm:\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F = \\sqrt{4 \\frac{N^2}{l^2}} = 2 \\frac{|N|}{l}\n$$\nThe problem asks for the computation of $\\Delta = \\|K_{\\sigma}\\|_F - 2|N|/l$. Based on this analytical derivation, the value of $\\Delta$ must be identically zero for any valid inputs. The computation serves as a numerical verification of this identity, and any non-zero result will be attributable to floating-point representation and arithmetic errors.\n\n### Computational Algorithm\n\nFor each test case, the following procedure is implemented:\n1.  Define the input parameters: $E, A$, initial nodal coordinates $\\mathbf{X}_1, \\mathbf{X}_2$, and current nodal coordinates $\\mathbf{x}_1, \\mathbf{x}_2$.\n2.  Calculate the initial length $L_0 = \\|\\mathbf{X}_2 - \\mathbf{X}_1\\|$.\n3.  Calculate the current length $l = \\|\\mathbf{x}_2 - \\mathbf{x}_1\\|$. If $l=0$, the element has collapsed, and subsequent steps are undefined. The test cases avoid this singularity.\n4.  Calculate the axial force $N = \\frac{EA}{L_0}(l - L_0)$.\n5.  Calculate the components of the current unit tangent vector, $t_x = (x_2 - x_1)/l$ and $t_y = (y_2 - y_1)/l$.\n6.  Construct the $4 \\times 4$ matrix $\\mathbf{K}_{\\sigma}$ using the derived formula.\n7.  Compute the Frobenius norm $\\|\\mathbf{K}_{\\sigma}\\|_F$ using a numerical library function.\n8.  Compute the verification scalar $V = 2|N|/l$.\n9.  Calculate the difference $\\Delta = \\|\\mathbf{K}_{\\sigma}\\|_F - V$.\n10. Store the resulting value of $\\Delta$, which is expected to be numerically close to zero.\n\nThis algorithm is applied to each of the three prescribed test cases. The final output will be a list of the computed $\\Delta$ values, rounded as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_delta(E, A, X1, X2, x1, x2):\n    \"\"\"\n    Computes the geometric stiffness matrix K_sigma and the verification difference Delta.\n\n    Args:\n        E (float): Young's modulus in Pa.\n        A (float): Cross-sectional area in m^2.\n        X1 (np.ndarray): Initial coordinates of node 1 (2-element array) in m.\n        X2 (np.ndarray): Initial coordinates of node 2 (2-element array) in m.\n        x1 (np.ndarray): Current coordinates of node 1 (2-element array) in m.\n        x2 (np.ndarray): Current coordinates of node 2 (2-element array) in m.\n\n    Returns:\n        float: The scalar difference Delta = ||K_sigma||_F - 2*|N|/l in N/m.\n    \"\"\"\n    # Calculate initial length\n    if not isinstance(X1, np.ndarray): X1 = np.array(X1, dtype=float)\n    if not isinstance(X2, np.ndarray): X2 = np.array(X2, dtype=float)\n    L0 = np.linalg.norm(X2 - X1)\n\n    # Calculate current length\n    if not isinstance(x1, np.ndarray): x1 = np.array(x1, dtype=float)\n    if not isinstance(x2, np.ndarray): x2 = np.array(x2, dtype=float)\n    dx = x2 - x1\n    l = np.linalg.norm(dx)\n\n    # Handle the case of zero current length to avoid division by zero\n    if l == 0.0:\n        # If length is zero, N is based on L0, K_sigma would be singular.\n        # As per problem context, this case is not expected.\n        # But for robustness, we can define N and state K_sigma is undefined.\n        # Here we assume it implies zero stiffness contribution.\n        return 0.0\n\n    # Calculate axial force N\n    N = (E * A / L0) * (l - L0)\n\n    # Calculate current unit tangent vector t\n    t = dx / l\n    tx, ty = t[0], t[1]\n\n    # Construct the geometric stiffness matrix K_sigma\n    # Submatrix M = [[ty^2, -tx*ty], [-tx*ty, tx^2]]\n    M = np.array([\n        [ty**2, -tx * ty],\n        [-tx * ty, tx**2]\n    ])\n    \n    # K_sigma = (N / l) * [[M, -M], [-M, M]]\n    K_sigma = (N / l) * np.block([\n        [M, -M],\n        [-M, M]\n    ])\n    \n    # Compute the Frobenius norm of K_sigma\n    norm_K_sigma = np.linalg.norm(K_sigma, 'fro')\n    \n    # Compute the verification scalar 2*|N|/l\n    verification_scalar = 2.0 * abs(N) / l\n    \n    # Compute the difference Delta\n    delta = norm_K_sigma - verification_scalar\n    \n    return delta\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, printing the results in the required format.\n    \"\"\"\n    # Case A: Rigid rotation, zero extension\n    theta_A = np.pi / 3.0\n    L0_A = 1.0\n    case_A = {\n        \"E\": 2.10e11, \"A\": 3.0e-4,\n        \"X1\": (0.0, 0.0), \"X2\": (1.0, 0.0),\n        \"x1\": (0.0, 0.0), \"x2\": (L0_A * np.cos(theta_A), L0_A * np.sin(theta_A))\n    }\n\n    # Case B: Pure axial tension, no rotation\n    case_B = {\n        \"E\": 7.0e10, \"A\": 1.2e-4,\n        \"X1\": (0.0, 0.0), \"X2\": (2.0, 0.0),\n        \"x1\": (0.0, 0.0), \"x2\": (2.02, 0.0)\n    }\n\n    # Case C: Large rotation with compression\n    L0_C = 1.5\n    delta_len_C = -0.01\n    l_C = L0_C + delta_len_C\n    theta_C = 1.74532925199433  # 100 degrees\n    case_C = {\n        \"E\": 2.00e11, \"A\": 2.5e-4,\n        \"X1\": (0.0, 0.0), \"X2\": (1.5, 0.0),\n        \"x1\": (0.0, 0.0), \"x2\": (l_C * np.cos(theta_C), l_C * np.sin(theta_C))\n    }\n\n    test_cases = [case_A, case_B, case_C]\n    \n    results = []\n    for case in test_cases:\n        delta_val = compute_delta(\n            case[\"E\"], case[\"A\"],\n            case[\"X1\"], case[\"X2\"],\n            case[\"x1\"], case[\"x2\"]\n        )\n        results.append(delta_val)\n\n    # Format the final output string as required\n    formatted_results = [f\"{res:.9f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver\nsolve()\n```", "id": "2411426"}, {"introduction": "Our final hands-on practice culminates in a problem that integrates both material and geometric nonlinearities to simulate a realistic engineering scenario: the indentation of a soft, hyperelastic block by a rigid sphere [@problem_id:2411424]. You will work with a compressible neo-Hookean material model, a classic example of hyperelasticity, and handle the geometric nonlinearities arising from large deformations and contact. By developing an algorithm that combines a numerical root-finder (Newton's method) with numerical quadrature, you will build a powerful tool to predict the force-indentation response, bridging the gap between fundamental theory and practical computational analysis.", "problem": "Consider the axisymmetric indentation of a soft hyperelastic block by a rigid spherical indenter. The block is modeled as a collection of independent vertical hyperelastic columns (a Winkler-type foundation with nonlinear material response) of initial height $H$ and lateral traction-free conditions. A rigid sphere of radius $R$ is pressed into the top surface by an indentation depth $\\delta$. Assume frictionless contact, quasistatic loading, and that the material is a compressible neo-Hookean solid with shear modulus $\\mu$ and bulk modulus $\\kappa$. All quantities must be expressed in International System of Units (SI): lengths in meters, forces in newtons, and moduli in pascals. Angles, if any, must be in radians.\n\nFundamental modeling ingredients:\n1. Kinematics and constitutive law for compressible neo-Hookean hyperelasticity. Let the principal stretches be $\\lambda_1$, $\\lambda_2$, $\\lambda_3$, the left Cauchy-Green tensor be $\\mathbf{B} = \\mathrm{diag}(\\lambda_1^2,\\lambda_2^2,\\lambda_3^2)$, and the volume ratio be $J = \\lambda_1 \\lambda_2 \\lambda_3$. Using the standard isochoric-volumetric split, the Cauchy stress for a compressible neo-Hookean material is\n$$\n\\boldsymbol{\\sigma} = \\frac{\\mu}{J}\\,\\mathrm{dev}(\\mathbf{B}) + \\kappa\\,(J-1)\\,\\mathbf{I},\n$$\nwhere $\\mathrm{dev}(\\mathbf{B}) = \\mathbf{B} - \\tfrac{1}{3}\\mathrm{tr}(\\mathbf{B})\\,\\mathbf{I}$ and $\\mathbf{I}$ is the identity tensor.\n2. Uniaxial compression of a column with lateral traction-free conditions. Under local vertical compression, assume principal stretches $\\lambda_1=\\lambda_2=\\lambda_t$ (lateral) and $\\lambda_3=\\lambda_z$ (vertical). The traction-free lateral boundary enforces the lateral Cauchy stress to vanish,\n$$\n\\sigma_t(\\lambda_t,\\lambda_z) = \\frac{\\mu}{J}\\,\\frac{1}{3}\\left(\\lambda_t^2 - \\lambda_z^2\\right) + \\kappa\\,(J-1) = 0,\\quad J = \\lambda_t^2 \\lambda_z.\n$$\nThe corresponding vertical Cauchy stress is\n$$\n\\sigma_z(\\lambda_t,\\lambda_z) = \\frac{2\\mu}{3J}\\left(\\lambda_z^2 - \\lambda_t^2\\right) + \\kappa\\,(J-1).\n$$\n3. Indentation geometry. For a rigid sphere pressed by $\\delta$ into the plane $z=0$, the exact surface profile relative to the undeformed plane is\n$$\nw(r) = \\delta - \\left( R - \\sqrt{R^2 - r^2} \\right),\\quad 0 \\le r \\le a,\\quad a = \\sqrt{2R\\delta - \\delta^2},\n$$\nwhere $r$ is the radial coordinate and $a$ is the contact radius (valid for $0<\\delta<2R$). Under the Winkler-column assumption, the local vertical stretch is\n$$\n\\lambda_z(r) = \\frac{H - w(r)}{H},\n$$\nand contact pressure is the compressive part of the vertical Cauchy stress,\n$$\np(r) = \\max\\left( 0,\\,-\\sigma_z\\big(\\lambda_t(r),\\lambda_z(r)\\big) \\right),\n$$\nwhere $\\lambda_t(r)$ solves the lateral traction-free condition $\\sigma_t(\\lambda_t(r),\\lambda_z(r))=0$ for each $r$.\n4. Total force. The total force is the axisymmetric integral of the contact pressure,\n$$\nF(\\delta) = 2\\pi \\int_0^{a} p(r)\\, r\\, dr.\n$$\n\nTask: Starting from the above fundamentals, derive a numerical algorithm that, for given $(R,H,\\mu,\\kappa)$ and a set of indentation depths, computes $F(\\delta)$ by:\n- Solving, at each radial position, the scalar nonlinear equation $\\sigma_t(\\lambda_t,\\lambda_z)=0$ for $\\lambda_t$ using Newton’s method derived from the constitutive equation, with a physically admissible initial guess and step control to maintain $\\lambda_t>0$.\n- Evaluating $\\sigma_z$ and thus $p(r)$.\n- Performing numerical quadrature of $2\\pi p(r) r$ over $[0,a]$ using a reliable composite rule.\n- Ensuring that $0 < \\delta < H$ so that $\\lambda_z(r)>0$ in the contact region.\n\nNumerical details:\n- Implement Newton’s method for $\\sigma_t(\\lambda_t,\\lambda_z)=0$ with the derivative $\\tfrac{\\partial \\sigma_t}{\\partial \\lambda_t}$ computed analytically from the above formulas.\n- Use a composite Simpson rule with an even number of subintervals for the radial integral. Choose a fixed number of subintervals that ensures reasonable accuracy for all test cases, and document that choice in the code.\n\nTest suite:\nFor each of the following cases, compute the force for each listed indentation depth. All inputs are in SI units, and forces must be returned in newtons. Ensure that for all cases, $0<\\delta<H$ and $0<\\delta<2R$.\n\n- Case 1 (happy path, nearly incompressible soft rubber): $R=5.0\\times 10^{-3}$, $H=1.0\\times 10^{-2}$, $\\mu=1.0\\times 10^{4}$, $\\kappa=1.0\\times 10^{6}$, $\\delta \\in \\{1.0\\times 10^{-4},\\,3.0\\times 10^{-4},\\,7.0\\times 10^{-4}\\}$.\n- Case 2 (small indentation boundary check): $R=1.0\\times 10^{-2}$, $H=1.0\\times 10^{-2}$, $\\mu=5.0\\times 10^{3}$, $\\kappa=5.0\\times 10^{5}$, $\\delta \\in \\{1.0\\times 10^{-6},\\,5.0\\times 10^{-6},\\,1.0\\times 10^{-5}\\}$.\n- Case 3 (more compressible material): $R=5.0\\times 10^{-3}$, $H=5.0\\times 10^{-3}$, $\\mu=2.0\\times 10^{4}$, $\\kappa=1.0\\times 10^{5}$, $\\delta \\in \\{1.0\\times 10^{-4},\\,4.0\\times 10^{-4},\\,8.0\\times 10^{-4}\\}$.\n- Case 4 (thinner block): $R=3.0\\times 10^{-3}$, $H=1.0\\times 10^{-3}$, $\\mu=1.5\\times 10^{4}$, $\\kappa=1.5\\times 10^{6}$, $\\delta \\in \\{1.0\\times 10^{-4},\\,3.0\\times 10^{-4},\\,5.0\\times 10^{-4}\\}$.\n\nFinal output format:\nYour program must produce a single line containing a list of four sublists, one per case, each sublist containing the forces for the specified indentation depths in newtons, rounded to six decimal places. The format must exactly be:\n[[F11,F12,F13],[F21,F22,F23],[F31,F32,F33],[F41,F42,F43]]\nwhere $Fij$ denotes the force for case $i$ at the $j$-th indentation depth, each as a decimal number in newtons with six digits after the decimal point.", "solution": "The problem statement has been subjected to rigorous validation and is deemed to be a valid, well-posed problem in computational solid mechanics. It outlines a simplified but consistent model for the axisymmetric contact between a rigid sphere and a hyperelastic block, based on the Winkler foundation assumption. All physical parameters, constitutive laws, and geometric constraints are clearly defined, permitting a unique numerical solution. We shall now construct this solution.\n\nThe objective is to compute the total indentation force $F(\\delta)$ for a set of given parameters $(R, H, \\mu, \\kappa)$ and indentation depths $\\delta$. The core of the problem lies in determining the local pressure distribution $p(r)$ under the indenter, which requires solving a nonlinear material constitution equation at each radial position $r$ within the contact zone $0 \\le r \\le a$.\n\nFirst, we analyze the state of a single vertical column, which is assumed to be in a state of uniaxial compression with lateral traction-free boundaries. The principal stretches are $\\lambda_1 = \\lambda_2 = \\lambda_t$ (transverse) and $\\lambda_3 = \\lambda_z$ (axial). The volume ratio is $J = \\lambda_t^2 \\lambda_z$. The lateral traction-free condition, $\\sigma_t=0$, provides the governing equation for $\\lambda_t$ at a given axial stretch $\\lambda_z$:\n$$ \\sigma_t(\\lambda_t, \\lambda_z) = \\frac{\\mu}{J}\\,\\frac{1}{3}\\left(\\lambda_t^2 - \\lambda_z^2\\right) + \\kappa\\,(J-1) = 0 $$\nFor a fixed $\\lambda_z$, this is a scalar nonlinear equation in $\\lambda_t$. Substituting $J = \\lambda_t^2\\lambda_z$, this equation becomes:\n$$ g(\\lambda_t) \\equiv \\frac{\\mu}{3\\lambda_t^2\\lambda_z} (\\lambda_t^2 - \\lambda_z^2) + \\kappa(\\lambda_t^2\\lambda_z - 1) = 0 $$\nTo solve this equation for $\\lambda_t$, we employ Newton's method, which requires the derivative of $g(\\lambda_t)$ with respect to $\\lambda_t$. For easier differentiation, we can rewrite $g(\\lambda_t)$ as:\n$$ g(\\lambda_t) = \\frac{\\mu}{3\\lambda_z}(1 - \\lambda_z^2 \\lambda_t^{-2}) + \\kappa(\\lambda_t^2\\lambda_z - 1) $$\nThe derivative, $g'(\\lambda_t) = \\frac{\\partial \\sigma_t}{\\partial \\lambda_t}$, is then:\n$$ g'(\\lambda_t) = \\frac{\\mu}{3\\lambda_z} ( - \\lambda_z^2 (-2) \\lambda_t^{-3}) + \\kappa(2\\lambda_t \\lambda_z) = \\frac{2\\mu\\lambda_z}{3\\lambda_t^3} + 2\\kappa\\lambda_z\\lambda_t $$\nGiven that material parameters $\\mu$ and $\\kappa$ are positive, and for any physically meaningful deformation $\\lambda_t>0$ and $\\lambda_z>0$, the derivative $g'(\\lambda_t)$ is strictly positive. This proves that $g(\\lambda_t)$ is a monotonically increasing function of $\\lambda_t$, guaranteeing that a unique positive root exists. The Newton-Raphson iteration is thus given by:\n$$ \\lambda_{t,k+1} = \\lambda_{t,k} - \\frac{g(\\lambda_{t,k})}{g'(\\lambda_{t,k})} $$\nA suitable initial guess $\\lambda_{t,0}$ is derived from the incompressible limit ($\\kappa \\to \\infty$), which enforces $J=1$. This gives $\\lambda_{t,0}^2 \\lambda_z = 1$, so $\\lambda_{t,0} = 1/\\sqrt{\\lambda_z}$. This is a physically sound starting point. To ensure robustness, step control must be used to prevent updates from yielding non-physical negative values for $\\lambda_t$.\n\nOnce the lateral stretch $\\lambda_t(r)$ is found, the corresponding axial Cauchy stress $\\sigma_z(r)$ is computed. The expression for $\\sigma_z$ is:\n$$ \\sigma_z(\\lambda_t,\\lambda_z) = \\frac{2\\mu}{3J}\\left(\\lambda_z^2 - \\lambda_t^2\\right) + \\kappa\\,(J-1) $$\nWe can simplify this expression by using the fact that $\\lambda_t$ satisfies $\\sigma_t=0$. From the $\\sigma_t=0$ condition, we have $\\kappa(J-1) = -\\frac{\\mu}{3J}(\\lambda_t^2-\\lambda_z^2) = \\frac{\\mu}{3J}(\\lambda_z^2-\\lambda_t^2)$. Substituting this into the equation for $\\sigma_z$:\n$$ \\sigma_z = \\frac{2\\mu}{3J}(\\lambda_z^2 - \\lambda_t^2) + \\frac{\\mu}{3J}(\\lambda_z^2 - \\lambda_t^2) = \\frac{\\mu}{J}(\\lambda_z^2 - \\lambda_t^2) $$\nThis simplified formula is computationally more efficient and stable. The contact pressure is then $p(r) = \\max(0, -\\sigma_z(r))$.\n\nThe overall numerical algorithm to compute the total force $F(\\delta)$ proceeds as follows:\n1.  For a given indentation depth $\\delta$ and sphere radius $R$, calculate the contact radius $a = \\sqrt{2R\\delta - \\delta^2}$.\n2.  Discretize the radial domain $[0, a]$ into an even number of subintervals, $N$, creating a set of $N+1$ radial points $r_i$, where $i=0, 1, \\dots, N$.\n3.  For each point $r_i$:\n    a. Determine the local vertical displacement from the indenter geometry: $w(r_i) = \\delta - (R - \\sqrt{R^2 - r_i^2})$.\n    b. Compute the local axial stretch: $\\lambda_z(r_i) = (H - w(r_i)) / H$. The condition $\\delta < H$ ensures $\\lambda_z(r_i) > 0$.\n    c. Solve the nonlinear equation $g(\\lambda_t) = 0$ for the local transverse stretch $\\lambda_t(r_i)$ using the Newton-Raphson scheme outlined above.\n    d. Calculate the axial stress $\\sigma_z(r_i)$ using the simplified expression $\\sigma_z = (\\mu/J)(\\lambda_z^2 - \\lambda_t^2)$.\n    e. Compute the contact pressure $p(r_i) = \\max(0, -\\sigma_z(r_i))$.\n    f. Evaluate the integrand for the force calculation: $f(r_i) = 2\\pi r_i p(r_i)$.\n4.  Compute the total force $F(\\delta)$ by numerically integrating the function $f(r)$ over $[0, a]$ using the composite Simpson's rule on the calculated values $f(r_i)$:\n$$ F(\\delta) = \\int_0^a 2\\pi r p(r) dr \\approx \\frac{h}{3} \\left(f(r_0) + 4\\sum_{j=1}^{N/2} f(r_{2j-1}) + 2\\sum_{j=1}^{N/2-1} f(r_{2j}) + f(r_N)\\right) $$\nwhere $h=a/N$ is the step size. This procedure is repeated for all specified values of $\\delta$ and for each set of material and geometric parameters. For the implementation, a reliable library function for the composite Simpson's rule is appropriate. We choose $N=1000$ subintervals for sufficient accuracy.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import simpson\n\ndef solve():\n    \"\"\"\n    Solves the hyperelastic indentation problem for the given test suite.\n    \"\"\"\n    \n    # Constants for the numerical methods\n    NEWTON_TOL = 1e-9\n    NEWTON_MAX_ITER = 20\n    NUM_SUBINTERVALS = 1000  # Must be an even number for Simpson's rule implementation\n\n    def solve_lambda_t(lambda_z, mu, kappa):\n        \"\"\"\n        Solves for the transverse stretch lambda_t using Newton's method.\n        The equation to solve is sigma_t(lambda_t, lambda_z) = 0.\n        \"\"\"\n        # Initial guess from the incompressible case (J=1)\n        if lambda_z <= 0:\n            return np.nan\n        lambda_t = 1.0 / np.sqrt(lambda_z)\n\n        for _ in range(NEWTON_MAX_ITER):\n            # Function g(lambda_t) corresponds to sigma_t\n            J = lambda_t**2 * lambda_z\n            # This form avoids potential floating point issues with very large/small J\n            g = (mu / (3.0 * lambda_z)) * (1.0 - lambda_z**2 / lambda_t**2) + kappa * (J - 1.0)\n\n            if abs(g) < NEWTON_TOL:\n                return lambda_t\n\n            # Derivative g'(lambda_t) = d(sigma_t)/d(lambda_t)\n            dg_dlt = (2.0 * mu * lambda_z) / (3.0 * lambda_t**3) + 2.0 * kappa * lambda_z * lambda_t\n            \n            if dg_dlt == 0: # Avoid division by zero\n                return np.nan\n\n            # Newton step with basic line search for robustness\n            step = g / dg_dlt\n            alpha = 1.0\n            lambda_t_new = lambda_t - alpha * step\n            \n            # Ensure next iterate is physically admissible (lambda_t > 0)\n            while lambda_t_new <= 0:\n                alpha /= 2.0\n                lambda_t_new = lambda_t - alpha * step\n                if alpha < 1e-8: # Line search failed\n                    return np.nan\n            \n            lambda_t = lambda_t_new\n\n        # Return best effort if max iterations are reached, check final residual\n        J = lambda_t**2 * lambda_z\n        g = (mu / (3.0 * lambda_z)) * (1.0 - lambda_z**2 / lambda_t**2) + kappa * (J - 1.0)\n        if abs(g) < 1e-6: # Looser tolerance for convergence at max_iter\n            return lambda_t\n        else:\n            return np.nan\n\n    def calculate_force(R, H, mu, kappa, delta):\n        \"\"\"\n        Calculates the total indentation force for a given set of parameters.\n        \"\"\"\n        # Problem constraints must be met\n        if not (0.0 < delta < 2.0 * R and 0.0 < delta < H):\n            return 0.0\n\n        # Contact radius\n        a = np.sqrt(2.0 * R * delta - delta**2)\n\n        # Radial points for numerical integration\n        num_points = NUM_SUBINTERVALS + 1\n        r_vals = np.linspace(0, a, num_points)\n        \n        integrand = np.zeros(num_points)\n\n        for i, ri in enumerate(r_vals):\n            # At r=0, the integrand 2*pi*r*p(r) is zero\n            if ri == 0:\n                integrand[i] = 0.0\n                continue\n            \n            # Indentation profile w(r)\n            w_r = delta - (R - np.sqrt(R**2 - ri**2))\n            \n            # Axial stretch lambda_z\n            lambda_z_r = (H - w_r) / H\n            \n            if lambda_z_r <= 0:\n                # This should not occur given delta < H\n                pressure = 0.0\n            else:\n                # Solve for transverse stretch lambda_t\n                lambda_t_r = solve_lambda_t(lambda_z_r, mu, kappa)\n                \n                if np.isnan(lambda_t_r):\n                    # If Newton solver fails, assume no pressure develops at this point\n                    pressure = 0.0\n                else:\n                    # Calculate axial stress sigma_z using the simplified formula\n                    J_r = lambda_t_r**2 * lambda_z_r\n                    sigma_z_r = (mu / J_r) * (lambda_z_r**2 - lambda_t_r**2)\n                    \n                    # Contact pressure (compressive stress is negative)\n                    pressure = max(0.0, -sigma_z_r)\n\n            integrand[i] = 2.0 * np.pi * ri * pressure\n            \n        # Integrate using Scipy's composite Simpson's rule implementation\n        force = simpson(integrand, r_vals)\n        \n        return force\n\n    # Test suite provided in the problem description\n    test_cases = [\n        {'R': 5.0e-3, 'H': 1.0e-2, 'mu': 1.0e4, 'kappa': 1.0e6, 'deltas': [1.0e-4, 3.0e-4, 7.0e-4]},\n        {'R': 1.0e-2, 'H': 1.0e-2, 'mu': 5.0e3, 'kappa': 5.0e5, 'deltas': [1.0e-6, 5.0e-6, 1.0e-5]},\n        {'R': 5.0e-3, 'H': 5.0e-3, 'mu': 2.0e4, 'kappa': 1.0e5, 'deltas': [1.0e-4, 4.0e-4, 8.0e-4]},\n        {'R': 3.0e-3, 'H': 1.0e-3, 'mu': 1.5e4, 'kappa': 1.5e6, 'deltas': [1.0e-4, 3.0e-4, 5.0e-4]}\n    ]\n    \n    all_results = []\n    for case in test_cases:\n        case_results = []\n        for delta in case['deltas']:\n            force = calculate_force(case['R'], case['H'], case['mu'], case['kappa'], delta)\n            # Format to 6 decimal places as required\n            case_results.append(f\"{force:.6f}\")\n        all_results.append(f\"[{','.join(case_results)}]\")\n    \n    # Print the final result in the specified format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2411424"}]}