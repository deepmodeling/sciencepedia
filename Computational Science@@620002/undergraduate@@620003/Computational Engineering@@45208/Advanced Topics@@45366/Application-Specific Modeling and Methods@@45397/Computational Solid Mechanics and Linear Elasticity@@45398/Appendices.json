{"hands_on_practices": [{"introduction": "Linearity is a powerful concept that underpins much of engineering analysis, including solid mechanics. It allows us to decompose complex problems into simpler, more manageable parts—a strategy known as the principle of superposition. This practice [@problem_id:2699170] provides a hands-on opportunity to formally justify this principle from first principles in thermoelasticity, and then apply it to a concrete problem, separating mechanical and thermal stresses to find the total response of a constrained bar.", "problem": "A homogeneous, linear thermoelastic solid obeys the constitutive relation $\\sigma = \\mathbb{C} : (\\varepsilon - \\alpha \\Delta T\\, I)$, where $\\sigma$ is the Cauchy stress tensor, $\\mathbb{C}$ is the fourth-order elasticity tensor, $\\varepsilon$ is the infinitesimal strain tensor, $\\alpha$ is the (isotropic) coefficient of thermal expansion, $\\Delta T$ is the temperature change field relative to a stress-free reference, and $I$ is the second-order identity tensor. Consider quasi-static conditions with no inertia. \n\nPart A (superposition principle): Starting from the balance of linear momentum in the absence of body forces, the infinitesimal strain-displacement relation, and the above constitutive law, argue from first principles why the stress field for a combined mechanical loading (prescribed tractions and/or displacements) and thermal loading $\\Delta T$ can be written as the sum of a purely mechanical stress field (obtained by setting $\\Delta T = 0$ and applying the mechanical load) and a purely thermal stress field (obtained by removing mechanical loading but enforcing the thermal field $\\Delta T$ with homogeneous mechanical boundary conditions). Your argument must not assume the conclusion but should follow from linearity of the governing operators and boundary conditions.\n\nPart B (one-dimensional computation): Specialize to a prismatic straight bar of length $L$ along the $x$-axis with constant cross-sectional area and constant Young’s modulus $E$ and a constant coefficient of thermal expansion $\\alpha$. Assume small strains and that the only nonzero stress component is the axial stress $\\sigma(x)$, with kinematics given by the axial displacement $u(x)$ and the axial strain $\\varepsilon(x) = du/dx$. The bar is clamped at $x=0$ with $u(0)=0$ and its end at $x=L$ is subjected to a prescribed axial displacement $u(L)=\\delta$ (positive $\\delta$ denotes tensile extension). There are no body forces. The temperature change is spatially varying as\n$$\n\\Delta T(x) = \\Delta T_0\\left(1 + \\gamma \\frac{x}{L}\\right),\n$$\nwhere $\\Delta T_0$ and $\\gamma$ are given constants. Using the principle argued in Part A and the one-dimensional field equations, compute the resulting uniform axial stress $\\sigma$ in the bar. Express your final answer as a single simplified closed-form symbolic expression in terms of $E$, $\\alpha$, $\\delta$, $L$, $\\Delta T_0$, and $\\gamma$. Do not include units in your final boxed answer. The stress is to be understood in Pascals (Pa). No numerical evaluation or rounding is required.", "solution": "The problem statement presented is subjected to rigorous validation.\n\n### Problem Validation\n\n**Step 1: Extracted Givens**\n- Constitutive Relation: $\\sigma = \\mathbb{C} : (\\varepsilon - \\alpha \\Delta T\\, I)$, where $\\sigma$ is the Cauchy stress tensor, $\\mathbb{C}$ is the fourth-order elasticity tensor, $\\varepsilon$ is the infinitesimal strain tensor, $\\alpha$ is the coefficient of thermal expansion, $\\Delta T$ is the temperature change field, and $I$ is the second-order identity tensor.\n- Equilibrium Equation (quasi-static, no body forces): $\\nabla \\cdot \\sigma = 0$.\n- Kinematics: Infinitesimal strain-displacement relation, $\\varepsilon = \\frac{1}{2}(\\nabla u + (\\nabla u)^T)$.\n- Part A Task: Argue for the principle of superposition for a combined mechanical and thermal loading problem.\n- Part B Specialization:\n  - Geometry: Prismatic bar, length $L$, constant cross-section.\n  - Material Properties: Constant Young’s modulus $E$, constant coefficient of thermal expansion $\\alpha$.\n  - Kinematics: Axial displacement $u(x)$, axial strain $\\varepsilon(x) = du/dx$.\n  - Stress State: Uniaxial stress $\\sigma(x)$.\n  - Boundary Conditions: $u(0)=0$ and $u(L)=\\delta$.\n  - Thermal Load: $\\Delta T(x) = \\Delta T_0\\left(1 + \\gamma \\frac{x}{L}\\right)$, where $\\Delta T_0$ and $\\gamma$ are constants.\n\n**Step 2: Validation Using Extracted Givens**\n- **Scientific Groundedness**: The problem is formulated within the well-established framework of linear thermoelasticity. The constitutive law, equilibrium equation, and kinematic relations are standard.\n- **Well-Posedness**: The problem is well-posed. The governing equations are linear partial differential equations, and the boundary conditions for both the general case (Part A) and the specific 1D case (Part B) are sufficient to ensure a unique solution.\n- **Objectivity**: The problem is stated using precise mathematical and physical terminology, free from any subjective or ambiguous language.\n- **Completeness**: All necessary physical constants, boundary conditions, and governing relations are provided. The problem is self-contained.\n- **Other Criteria**: The problem does not violate any other validation criteria. It is not trivial, as it requires a formal derivation and a specific calculation, testing fundamental understanding.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n### Part A: Superposition Principle in Linear Thermoelasticity\n\nThe governing equations for a quasi-static, linear thermoelastic solid in the absence of body forces are:\n1.  Balance of Linear Momentum (Equilibrium): $\\nabla \\cdot \\sigma = 0$\n2.  Strain-Displacement Relation (Kinematics): $\\varepsilon = \\mathcal{E}(u) \\equiv \\frac{1}{2}(\\nabla u + (\\nabla u)^T)$\n3.  Constitutive Law: $\\sigma = \\mathbb{C} : (\\varepsilon - \\varepsilon_{th})$, where the thermal strain is $\\varepsilon_{th} = \\alpha \\Delta T I$.\n\nThe kinematic operator $\\mathcal{E}$ is linear. The constitutive law is linear in its arguments $\\varepsilon$ and $\\varepsilon_{th}$.\nSubstituting (2) into (3), and then into (1), we obtain the governing partial differential equation for the displacement field $u$:\n$$ \\nabla \\cdot [\\mathbb{C} : (\\mathcal{E}(u) - \\alpha \\Delta T I)] = 0 $$\nLet us define a linear differential operator $\\mathcal{L}(u) \\equiv \\nabla \\cdot [\\mathbb{C} : \\mathcal{E}(u)]$. The governing equation becomes:\n$$ \\mathcal{L}(u) = \\nabla \\cdot [\\mathbb{C} : (\\alpha \\Delta T I)] $$\nThis is a linear, non-homogeneous partial differential equation. The boundary of the solid, $\\partial \\Omega$, is partitioned into $\\partial \\Omega_u$ and $\\partial \\Omega_t$, where displacements and tractions are prescribed, respectively.\n- Displacement BC: $u = \\bar{u}$ on $\\partial \\Omega_u$.\n- Traction BC: $\\sigma \\cdot n = \\bar{t}$ on $\\partial \\Omega_t$.\n\nThe complete problem, which we will call Problem (P), consists of solving the governing PDE subject to these boundary conditions for a given thermal field $\\Delta T$ and mechanical loads $(\\bar{u}, \\bar{t})$. Let the solution be $(u, \\varepsilon, \\sigma)$.\n\nWe decompose this problem into two simpler ones based on the principle of superposition for linear systems.\n\n**Problem (M): Purely Mechanical**\nThis problem considers only the mechanical loads, with zero thermal field ($\\Delta T = 0$).\n- Governing Equation: $\\mathcal{L}(u_M) = 0$.\n- Boundary Conditions: $u_M = \\bar{u}$ on $\\partial \\Omega_u$ and $\\sigma_M \\cdot n = \\bar{t}$ on $\\partial \\Omega_t$.\n- The stress is $\\sigma_M = \\mathbb{C} : \\mathcal{E}(u_M)$.\nLet the solution be $(u_M, \\varepsilon_M, \\sigma_M)$.\n\n**Problem (T): Purely Thermal**\nThis problem considers only the thermal field, with homogeneous (zero) mechanical boundary conditions.\n- Governing Equation: $\\mathcal{L}(u_T) = \\nabla \\cdot [\\mathbb{C} : (\\alpha \\Delta T I)]$.\n- Boundary Conditions: $u_T = 0$ on $\\partial \\Omega_u$ and $\\sigma_T \\cdot n = 0$ on $\\partial \\Omega_t$.\n- The stress is $\\sigma_T = \\mathbb{C} : (\\mathcal{E}(u_T) - \\alpha \\Delta T I)$.\nLet the solution be $(u_T, \\varepsilon_T, \\sigma_T)$.\n\nNow, we propose that the solution to the original combined Problem (P) is the sum of the solutions from (M) and (T):\n$u = u_M + u_T$\n$\\varepsilon = \\varepsilon_M + \\varepsilon_T$\n$\\sigma = \\sigma_M + \\sigma_T$\n\nWe must verify that this proposed solution satisfies the governing equation and boundary conditions of Problem (P).\n\n1.  **Verification of Governing Equation**:\n    We examine $\\mathcal{L}(u)$. Due to the linearity of the operator $\\mathcal{L}$:\n    $$ \\mathcal{L}(u) = \\mathcal{L}(u_M + u_T) = \\mathcal{L}(u_M) + \\mathcal{L}(u_T) $$\n    From the definitions of problems (M) and (T), this becomes:\n    $$ \\mathcal{L}(u) = 0 + \\nabla \\cdot [\\mathbb{C} : (\\alpha \\Delta T I)] = \\nabla \\cdot [\\mathbb{C} : (\\alpha \\Delta T I)] $$\n    This is precisely the governing equation for the combined Problem (P).\n\n2.  **Verification of Stress Relation**:\n    The stress for the combined problem is $\\sigma = \\mathbb{C} : (\\varepsilon - \\alpha \\Delta T I)$. Substituting $\\varepsilon = \\varepsilon_M + \\varepsilon_T = \\mathcal{E}(u_M) + \\mathcal{E}(u_T)$:\n    $$ \\sigma = \\mathbb{C} : (\\mathcal{E}(u_M) + \\mathcal{E}(u_T) - \\alpha \\Delta T I) $$\n    $$ \\sigma = (\\mathbb{C} : \\mathcal{E}(u_M)) + (\\mathbb{C} : (\\mathcal{E}(u_T) - \\alpha \\Delta T I)) $$\n    The first term is exactly $\\sigma_M$ and the second term is exactly $\\sigma_T$. Thus, $\\sigma = \\sigma_M + \\sigma_T$ is a direct consequence of the linearity of the constitutive law.\n\n3.  **Verification of Boundary Conditions**:\n    - On $\\partial \\Omega_u$: $u = u_M + u_T = \\bar{u} + 0 = \\bar{u}$. The displacement BC is satisfied.\n    - On $\\partial \\Omega_t$: $\\sigma \\cdot n = (\\sigma_M + \\sigma_T) \\cdot n = (\\sigma_M \\cdot n) + (\\sigma_T \\cdot n) = \\bar{t} + 0 = \\bar{t}$. The traction BC is satisfied.\n\nSince the superimposed solution $(u, \\varepsilon, \\sigma)$ satisfies the governing equation and all boundary conditions of the original problem, and since the solution to a linear elastostatic problem is unique, this sum must be the correct and only solution. The argument rests fundamentally on the linearity of the governing differential operator, the constitutive law, and the boundary condition operators.\n\n### Part B: One-Dimensional Stress Computation\n\nWe now apply this proven principle to the specified one-dimensional bar. The total stress $\\sigma$ is the sum of a purely mechanical stress $\\sigma_M$ and a purely thermal stress $\\sigma_T$: $\\sigma = \\sigma_M + \\sigma_T$.\n\nIn this 1D quasi-static problem with no body forces, the equilibrium equation $\\frac{d\\sigma}{dx} = 0$ dictates that the axial stress must be uniform along the bar's length.\n\n**1. Calculate Mechanical Stress ($\\sigma_M$)**\nFor this subproblem, we set $\\Delta T(x)=0$ and apply the mechanical boundary conditions $u_M(0)=0$ and $u_M(L)=\\delta$.\n- The stress $\\sigma_M$ is constant.\n- The constitutive law is $\\sigma_M = E \\varepsilon_M = E \\frac{du_M}{dx}$.\n- Since $\\sigma_M$ and $E$ are constant, the strain $\\varepsilon_M$ is also constant.\n- Integrating the strain gives the displacement: $u_M(x) = \\varepsilon_M x + C$.\n- Applying the boundary conditions:\n  - $u_M(0) = 0 \\implies \\varepsilon_M(0) + C = 0 \\implies C = 0$.\n  - $u_M(L) = \\delta \\implies \\varepsilon_M L = \\delta$.\n- The mechanical strain is $\\varepsilon_M = \\frac{\\delta}{L}$.\n- The resulting mechanical stress is $\\sigma_M = E \\varepsilon_M = \\frac{E \\delta}{L}$.\n\n**2. Calculate Thermal Stress ($\\sigma_T$)**\nFor this subproblem, we apply the thermal load $\\Delta T(x) = \\Delta T_0\\left(1 + \\gamma \\frac{x}{L}\\right)$ with homogeneous mechanical boundary conditions $u_T(0)=0$ and $u_T(L)=0$.\n- The stress $\\sigma_T$ is constant.\n- The constitutive law is $\\sigma_T = E (\\varepsilon_T - \\alpha \\Delta T(x)) = E (\\frac{du_T}{dx} - \\alpha \\Delta T(x))$.\n- Rearranging for the strain: $\\frac{du_T}{dx} = \\frac{\\sigma_T}{E} + \\alpha \\Delta T(x)$.\n- To find the total elongation, we integrate from $x=0$ to $x=L$:\n  $$ u_T(L) - u_T(0) = \\int_0^L \\frac{du_T}{dx} dx = \\int_0^L \\left(\\frac{\\sigma_T}{E} + \\alpha \\Delta T(x)\\right) dx $$\n- Applying the homogeneous boundary conditions $u_T(L)=0$ and $u_T(0)=0$:\n  $$ 0 = \\frac{\\sigma_T L}{E} + \\alpha \\int_0^L \\Delta T_0\\left(1 + \\gamma \\frac{x}{L}\\right) dx $$\n- Evaluating the integral:\n  $$ \\int_0^L \\Delta T_0\\left(1 + \\gamma \\frac{x}{L}\\right) dx = \\Delta T_0 \\left[x + \\frac{\\gamma x^2}{2L}\\right]_0^L = \\Delta T_0 \\left(L + \\frac{\\gamma L^2}{2L}\\right) = \\Delta T_0 L \\left(1 + \\frac{\\gamma}{2}\\right) $$\n- Substituting this back into the equation for $\\sigma_T$:\n  $$ 0 = \\frac{\\sigma_T L}{E} + \\alpha \\Delta T_0 L \\left(1 + \\frac{\\gamma}{2}\\right) $$\n- Solving for $\\sigma_T$:\n  $$ \\frac{\\sigma_T L}{E} = - \\alpha \\Delta T_0 L \\left(1 + \\frac{\\gamma}{2}\\right) $$\n  $$ \\sigma_T = -E \\alpha \\Delta T_0 \\left(1 + \\frac{\\gamma}{2}\\right) $$\n\n**3. Compute Total Stress ($\\sigma$)**\nThe total stress is the sum of the mechanical and thermal components:\n$$ \\sigma = \\sigma_M + \\sigma_T $$\n$$ \\sigma = \\frac{E \\delta}{L} - E \\alpha \\Delta T_0 \\left(1 + \\frac{\\gamma}{2}\\right) $$\nThis expression can be simplified by factoring out the Young's modulus $E$:\n$$ \\sigma = E \\left[ \\frac{\\delta}{L} - \\alpha \\Delta T_0 \\left(1 + \\frac{\\gamma}{2}\\right) \\right] $$\nThis is the final expression for the uniform axial stress in the bar.", "answer": "$$\n\\boxed{\nE \\left( \\frac{\\delta}{L} - \\alpha \\Delta T_0 \\left(1 + \\frac{\\gamma}{2}\\right) \\right)\n}\n$$", "id": "2699170"}, {"introduction": "In computational modeling, it is crucial to trust your tools. Before applying a finite element to analyze a complex engineering design, we must first verify that its fundamental formulation is correct—a failure to do so can lead to meaningless results. This exercise [@problem_id:2378079] guides you through the implementation of the patch test, a fundamental quality-control check that ensures a custom-built element can accurately represent basic physical states, forming the very foundation of its reliability for more complex simulations.", "problem": "You are asked to implement a complete, runnable program that checks whether a custom four-node isoparametric quadrilateral finite element passes the constant-strain patch test in the context of small-strain, linear-elasticity, plane-stress analysis. The program must be self-contained and produce a single line of output for a specified test suite. The purpose is to verify that the element reproduces an affine displacement field and yields constant strains within numerical tolerance.\n\nBegin from first principles suitable for computational solid mechanics:\n- The balance of linear momentum in statics without body forces is $\\,\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}\\,$ in a domain $\\,\\Omega\\,$, with $\\,\\boldsymbol{\\sigma}\\,$ the Cauchy stress tensor. Small-strain kinematics gives the infinitesimal strain tensor $\\,\\boldsymbol{\\varepsilon} = \\frac{1}{2}(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\mathsf{T}})\\,$, where $\\,\\mathbf{u}(\\mathbf{x})\\,$ is the displacement field.\n- For plane stress linear elasticity, the constitutive relation at each point is $\\,\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}\\,$, with $\\,\\mathbf{D}\\,$ the symmetric material matrix defined by Young’s modulus $\\,E\\,$ and Poisson’s ratio $\\,\\nu\\,$.\n- A Galerkin finite element discretization of the weak form leads to the linear system $\\,\\mathbf{K}\\mathbf{d} = \\mathbf{f}\\,$, where $\\,\\mathbf{K} = \\sum_{e} \\int_{A_e} \\mathbf{B}^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}\\,\\mathrm{d}A\\,$, $\\,\\mathbf{d}\\,$ is the vector of nodal displacements, $\\,\\mathbf{f}\\,$ is the external force vector, $\\,A_e\\,$ is the element area, and $\\,\\mathbf{B}\\,$ maps nodal displacements to engineering strains $\\,\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx},\\,\\varepsilon_{yy},\\,\\gamma_{xy}]^{\\mathsf{T}}\\,$ with $\\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}$. The mapping and integrals are to be carried out using isoparametric bilinear shape functions on a bi-unit square with standard two-by-two Gaussian quadrature.\n\nYour program must:\n- Implement a four-node quadrilateral isoparametric element with bilinear interpolation in natural coordinates $\\,(\\xi,\\eta)\\,$ and use $\\,2 \\times 2\\,$ Gaussian quadrature with points at $\\,\\xi,\\eta \\in \\{\\pm 1/\\sqrt{3}\\}\\,$ and unit weights. The Jacobian mapping from $\\,(\\xi,\\eta)\\,$ to physical coordinates $\\, (x,y)\\,$ must be computed per quadrature point to evaluate $\\,\\mathbf{B}\\,$ and $\\,\\det \\mathbf{J}\\,$.\n- Assemble the global stiffness matrix $\\,\\mathbf{K}\\,$ for each test-case mesh and impose Dirichlet boundary conditions by prescribing displacements on the outer boundary of the mesh. No body forces are present, and no Neumann tractions are applied. The program should determine the exterior boundary nodes algorithmically from the mesh connectivity by identifying edges that belong to only one element.\n- Prescribe an affine displacement field on the boundary of the computational domain\n  $$u(x,y) = \\gamma + \\alpha\\,x + \\beta\\,y,\\quad v(x,y) = \\zeta + \\delta\\,x + \\varepsilon\\,y,$$\n  where $\\,u\\,$ and $\\,v\\,$ are the $x$- and $y$-components of displacement, respectively. This field induces a constant strain\n  $$\\varepsilon_{xx} = \\alpha,\\quad \\varepsilon_{yy} = \\varepsilon,\\quad \\gamma_{xy} = \\beta + \\delta.$$\n  Use the constants $\\,\\alpha = 1.0\\times 10^{-3},\\,\\beta = -2.0\\times 10^{-4},\\,\\delta = 3.0\\times 10^{-4},\\,\\varepsilon = 5.0\\times 10^{-4},\\,\\gamma = 2.5\\times 10^{-3},\\,\\zeta = -1.1\\times 10^{-3}\\,$. Coordinates are in meters and displacements must be evaluated in meters.\n- Solve the linear system for free degrees of freedom and compute:\n  1. The maximum absolute nodal displacement error\n     $$e_u = \\max_{i}\\, \\left\\lvert d_i - d_i^{\\text{exact}} \\right\\rvert,$$\n     where $\\,d_i^{\\text{exact}}\\,$ are the exact nodal displacements from the affine field.\n  2. The maximum absolute deviation of computed engineering strains at Gaussian points from the target constant strain\n     $$e_{\\varepsilon} = \\max_{e,\\,g,\\,k} \\left\\lvert \\varepsilon_{k}^{(e,g)} - \\varepsilon_{k}^{\\text{target}} \\right\\rvert,$$\n     with $\\,k \\in \\{xx,yy,xy\\}\\,$, element index $\\,e\\,$, and Gauss point index $\\,g\\,$.\n- Material parameters for all test cases: Young’s modulus $\\,E = 210 \\times 10^{9}\\,$ pascals and Poisson’s ratio $\\,\\nu = 0.30\\,$ (plane stress). Although physical units are specified, the required outputs are dimensionless booleans.\n\nA test case is said to pass the constant-strain patch test if both $\\,e_u \\le 10^{-10}\\,$ and $\\,e_{\\varepsilon} \\le 10^{-10}\\,$.\n\nTest Suite (three meshes; all coordinates in meters; element connectivities use zero-based node indices in counterclockwise order):\n- Case $1$ (single distorted quadrilateral):\n  - Nodes:\n    - $0$: $(0.0,\\,0.0)$\n    - $1$: $(1.2,\\,0.1)$\n    - $2$: $(1.0,\\,1.1)$\n    - $3$: $(0.1,\\,0.9)$\n  - Elements:\n    - $[0,\\,1,\\,2,\\,3]$\n- Case $2$ ($2 \\times 2$ mesh of the unit square):\n  - Nodes:\n    - $0$: $(0.0,\\,0.0)$, $1$: $(0.5,\\,0.0)$, $2$: $(1.0,\\,0.0)$\n    - $3$: $(0.0,\\,0.5)$, $4$: $(0.5,\\,0.5)$, $5$: $(1.0,\\,0.5)$\n    - $6$: $(0.0,\\,1.0)$, $7$: $(0.5,\\,1.0)$, $8$: $(1.0,\\,1.0)$\n  - Elements:\n    - $[0,\\,1,\\,4,\\,3]$, $[1,\\,2,\\,5,\\,4]$, $[3,\\,4,\\,7,\\,6]$, $[4,\\,5,\\,8,\\,7]$\n- Case $3$ (parallelogram split into two quadrilaterals with an interior edge):\n  - Corner points: $\\mathrm{A}=(0.0,\\,0.0)$, $\\mathrm{B}=(2.0,\\,0.3)$, $\\mathrm{C}=(2.2,\\,1.2)$, $\\mathrm{D}=(0.2,\\,0.9)$.\n  - Additional points at mid-edge of $\\mathrm{AB}$ and $\\mathrm{DC}$: $\\mathrm{M}_{\\mathrm{AB}}=(1.0,\\,0.15)$, $\\mathrm{M}_{\\mathrm{DC}}=(1.2,\\,1.05)$.\n  - Nodes:\n    - $0$: $\\mathrm{A}$, $1$: $\\mathrm{M}_{\\mathrm{AB}}$, $2$: $\\mathrm{B}$, $3$: $\\mathrm{D}$, $4$: $\\mathrm{M}_{\\mathrm{DC}}$, $5$: $\\mathrm{C}$\n  - Elements:\n    - $[0,\\,1,\\,4,\\,3]$, $[1,\\,2,\\,5,\\,4]$\n\nYour program must, for each test case, compute the pass or fail boolean and produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, e.g., $[\\,\\text{True},\\text{False},\\text{True}\\,]$. No other output or text is permitted. The booleans reflect, respectively for the three cases, whether both $\\,e_u \\le 10^{-10}\\,$ and $\\,e_{\\varepsilon} \\le 10^{-10}\\,$ hold.\n\nAngle units are not applicable. If physical quantities are printed the units would be SI; however, the required outputs are booleans with no units. Ensure numerical computations are performed in a dimensionally consistent manner using meters for geometry and pascals for material stiffness. The program must be deterministic and not require any user input.", "solution": "The problem presented requires the implementation of a verification procedure known as the constant-strain patch test for a four-node isoparametric quadrilateral finite element. This test is a fundamental benchmark in computational mechanics, designed to ensure that a finite element formulation can exactly reproduce a constant strain state, which is a necessary condition for convergence. The analysis is framed within the context of two-dimensional, small-strain, linear-elastic, plane-stress theory. I will proceed by first outlining the theoretical foundations and then detailing the algorithmic steps required for the implementation.\n\nThe problem statement is scientifically sound and well-posed. It provides all necessary data, including geometric descriptions of three distinct meshes, material properties, a prescribed affine displacement field, and precise criteria for passing the test. It is a standard problem in the validation of finite element codes.\n\n**1. Theoretical Formulation**\n\nThe foundation of the finite element method (FEM) for solid mechanics lies in the discretization of the weak form of the equilibrium equations. For a static problem without body forces, the principle of virtual work states that for any kinematically admissible virtual displacement field $\\,\\delta\\mathbf{u}\\,$, the internal virtual work must equal the external virtual work. In the absence of body forces and surface tractions on the domain boundary, this reduces to:\n$$\n\\int_{\\Omega} \\boldsymbol{\\sigma} : \\delta\\boldsymbol{\\varepsilon} \\, \\mathrm{d}V = 0\n$$\nwhere $\\,\\boldsymbol{\\sigma}\\,$ is the Cauchy stress tensor and $\\,\\delta\\boldsymbol{\\varepsilon}\\,$ is the virtual strain tensor corresponding to $\\,\\delta\\mathbf{u}\\,$.\n\n**1.1. Isoparametric Element Formulation**\n\nWe employ a four-node quadrilateral element. The geometry and displacement field within the element are interpolated from nodal values using the same set of shape functions, hence the term \"isoparametric.\" The element is defined in a bi-unit square parent domain with natural coordinates $\\,(\\xi, \\eta)\\,$, where $\\,\\xi, \\eta \\in [-1, 1]\\,$.\n\nThe bilinear shape functions $\\,N_i(\\xi, \\eta)\\,$ for the four nodes $\\,(i=1, 2, 3, 4)\\,$ are:\n$$\nN_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta) \\quad\\quad N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)\n$$\n$$\nN_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) \\quad\\quad N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n$$\nThe physical coordinates $\\,(x, y)\\,$ of any point within the element are mapped from the natural coordinates:\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad\\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\nwhere $\\,(x_i, y_i)\\,$ are the coordinates of the element's nodes.\n\nSimilarly, the displacement field $\\,(u, v)\\,$ within the element is interpolated from the nodal displacements $\\,(u_i, v_i)\\,$:\n$$\nu(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_i \\quad\\quad v(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) v_i\n$$\n\n**1.2. Strain-Displacement Relationship**\n\nThe engineering strains $\\,\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\mathsf{T}}\\,$ are defined by spatial derivatives of the displacement field:\n$$\n\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x}, \\quad \\varepsilon_{yy} = \\frac{\\partial v}{\\partial y}, \\quad \\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}\n$$\nTo compute these, we need to relate derivatives with respect to physical coordinates $\\,(x, y)\\,$ to derivatives with respect to natural coordinates $\\,(\\xi, \\eta)\\,$ using the chain rule. This relationship is expressed via the Jacobian matrix $\\,\\mathbf{J}\\,$:\n$$\n\\begin{Bmatrix} \\frac{\\partial}{\\partial \\xi} \\\\ \\frac{\\partial}{\\partial \\eta} \\end{Bmatrix} = \n\\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta}  \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix} = \\mathbf{J}\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix}\n$$\nThe components of $\\,\\mathbf{J}\\,$ are found by differentiating the geometry mapping, for example $\\,\\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} x_i\\,$. Inverting $\\,\\mathbf{J}\\,$ yields:\n$$\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1}\n\\begin{Bmatrix} \\frac{\\partial}{\\partial \\xi} \\\\ \\frac{\\partial}{\\partial \\eta} \\end{Bmatrix}\n$$\nThe strains can now be expressed in terms of nodal displacements $\\,\\mathbf{d}^e = [u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4]^{\\mathsf{T}}\\,$ via the strain-displacement matrix $\\,\\mathbf{B}\\,$:\n$$\n\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}^e\n$$\nThe matrix $\\,\\mathbf{B}\\,$ is a $\\,3 \\times 8\\,$ matrix composed of four $\\,3 \\times 2\\,$ blocks, $\\,\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4]\\,$, where each block $\\,\\mathbf{B}_i\\,$ is given by:\n$$\n\\mathbf{B}_i = \n\\begin{bmatrix}\n\\frac{\\partial N_i}{\\partial x}  0 \\\\\n0  \\frac{\\partial N_i}{\\partial y} \\\\\n\\frac{\\partial N_i}{\\partial y}  \\frac{\\partial N_i}{\\partial x}\n\\end{bmatrix}\n$$\nThe spatial derivatives of the shape functions, e.g., $\\,\\frac{\\partial N_i}{\\partial x}\\,$, are computed using the inverse Jacobian:\n$$\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1}\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix}\n$$\n\n**1.3. Element Stiffness Matrix and System Assembly**\n\nThe element stiffness matrix $\\,\\mathbf{K}^e\\,$ relates nodal forces to nodal displacements for an element. It is derived by substituting the discrete formulations into the weak form integral:\n$$\n\\mathbf{K}^e = \\int_{A_e} \\mathbf{B}^{\\mathsf{T}} \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}A\n$$\nwhere $\\,A_e\\,$ is the element area and $\\,\\mathbf{D}\\,$ is the material constitutive matrix for plane stress:\n$$\n\\mathbf{D} = \\frac{E}{1-\\nu^2} \n\\begin{bmatrix} \n1  \\nu  0 \\\\ \n\\nu  1  0 \\\\ \n0  0  \\frac{1-\\nu}{2} \n\\end{bmatrix}\n$$\nwith $\\,E\\,$ being Young's modulus and $\\,\\nu\\,$ Poisson's ratio.\nThe integral is evaluated numerically using Gaussian quadrature. Transforming to the parent domain:\n$$\n\\mathbf{K}^e = \\int_{-1}^{1} \\int_{-1}^{1} \\mathbf{B}(\\xi, \\eta)^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}(\\xi, \\eta) \\det(\\mathbf{J}(\\xi, \\eta)) \\, \\mathrm{d}\\xi \\mathrm{d}\\eta\n$$\nUsing $\\,2 \\times 2\\,$ Gaussian quadrature, with points at $\\,(\\xi_g, \\eta_g) \\in \\{\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3}\\}\\,$ and unit weights $\\,(w_g = 1)\\,$:\n$$\n\\mathbf{K}^e \\approx \\sum_{g=1}^{4} \\mathbf{B}(\\xi_g, \\eta_g)^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}(\\xi_g, \\eta_g) \\det(\\mathbf{J}(\\xi_g, \\eta_g)) w_g\n$$\nThe global stiffness matrix $\\,\\mathbf{K}\\,$ for the entire mesh is formed by assembling the contributions from each element stiffness matrix $\\,\\mathbf{K}^e\\,$ into the appropriate global degrees of freedom. This results in the linear system $\\,\\mathbf{K}\\mathbf{d} = \\mathbf{f}\\,$.\n\n**2. Patch Test Procedure**\n\nThe patch test verifies if the element can exactly represent a state of constant strain. This is achieved by prescribing a displacement field on the boundary of a \"patch\" of elements that corresponds to a constant strain field. The FEM solution for the interior nodes is then computed and checked against the exact analytical solution.\n\n**2.1. Boundary Conditions and System Solution**\n\nAn affine displacement field is prescribed on the boundary nodes of the mesh:\n$$\nu(x,y) = \\gamma + \\alpha x + \\beta y \\quad\\quad v(x,y) = \\zeta + \\delta x + \\varepsilon y\n$$\nThis field corresponds to a constant engineering strain state:\n$$\n\\varepsilon_{xx}^{\\text{target}} = \\alpha, \\quad \\varepsilon_{yy}^{\\text{target}} = \\varepsilon, \\quad \\gamma_{xy}^{\\text{target}} = \\beta + \\delta\n$$\nThe program must first algorithmically identify the boundary nodes. This is done by iterating through all elements and counting the occurrences of each edge. Edges that belong to only one element are boundary edges, and their constituent nodes are boundary nodes.\n\nThe global system $\\,\\mathbf{K}\\mathbf{d} = \\mathbf{f}\\,$ is partitioned into free and prescribed degrees of freedom (DOFs), denoted by subscripts $\\,f\\,$ and $\\,p\\,$ respectively:\n$$\n\\begin{bmatrix} \\mathbf{K}_{ff}  \\mathbf{K}_{fp} \\\\ \\mathbf{K}_{pf}  \\mathbf{K}_{pp} \\end{bmatrix}\n\\begin{Bmatrix} \\mathbf{d}_f \\\\ \\mathbf{d}_p \\end{Bmatrix} =\n\\begin{Bmatrix} \\mathbf{f}_f \\\\ \\mathbf{f}_p \\end{Bmatrix}\n$$\nThe displacements $\\,\\mathbf{d}_p\\,$ for the boundary nodes are known from the prescribed affine field. Since there are no external nodal forces, the force vector for the free DOFs, $\\,\\mathbf{f}_f\\,$, is zero. The system to be solved for the unknown interior displacements $\\,\\mathbf{d}_f\\,$ is:\n$$\n\\mathbf{K}_{ff} \\mathbf{d}_f = - \\mathbf{K}_{fp} \\mathbf{d}_p\n$$\nThis smaller linear system is solved for $\\,\\mathbf{d}_f\\,$.\n\n**2.2. Error Evaluation**\n\nOnce the displacements $\\,\\mathbf{d}_f\\,$ are computed, the full displacement vector $\\,\\mathbf{d}\\,$ is assembled. Two error metrics are then calculated:\n1.  **Displacement Error $\\,e_u\\,$**: The maximum absolute difference between the computed nodal displacements and the exact analytical displacements from the affine field at all nodes.\n    $$\n    e_u = \\max_{i} \\left\\lvert d_i - d_i^{\\text{exact}} \\right\\rvert\n    $$\n    A correct formulation should reproduce the affine displacement field exactly, so $\\,e_u\\,$ should be on the order of machine precision.\n2.  **Strain Error $\\,e_{\\varepsilon}\\,$**: The maximum absolute difference between the computed strains at each Gauss point of every element and the target constant strains.\n    $$\n    e_{\\varepsilon} = \\max_{e,g,k} \\left\\lvert \\varepsilon_k^{(e,g)} - \\varepsilon_k^{\\text{target}} \\right\\rvert\n    $$\n    Here, $\\,\\varepsilon_k^{(e,g)}\\,$ is the $\\,k$-th component of strain (xx, yy, or xy) at Gauss point $\\,g\\,$ of element $\\,e\\,$, computed using $\\,\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}^e\\,$. This error should also be near zero.\n\nA test case passes if both $\\,e_u\\,$ and $\\,e_{\\varepsilon}\\,$ are below the specified tolerance of $\\,10^{-10}\\,$. This confirms the element's ability to satisfy the patch test. The implementation will now follow this rigorous procedure.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Main function to run the patch test for all specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: single distorted quadrilateral\n        {\n            \"nodes\": np.array([\n                [0.0, 0.0], [1.2, 0.1], [1.0, 1.1], [0.1, 0.9]\n            ]),\n            \"elements\": np.array([[0, 1, 2, 3]])\n        },\n        # Case 2: 2x2 mesh of the unit square\n        {\n            \"nodes\": np.array([\n                [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],\n                [0.0, 0.5], [0.5, 0.5], [1.0, 0.5],\n                [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]\n            ]),\n            \"elements\": np.array([\n                [0, 1, 4, 3], [1, 2, 5, 4],\n                [3, 4, 7, 6], [4, 5, 8, 7]\n            ])\n        },\n        # Case 3: parallelogram split into two quads\n        {\n            \"nodes\": np.array([\n                [0.0, 0.0], [1.0, 0.15], [2.0, 0.3],\n                [0.2, 0.9], [1.2, 1.05], [2.2, 1.2]\n            ]),\n            \"elements\": np.array([\n                [0, 1, 4, 3], [1, 2, 5, 4]\n            ])\n        }\n    ]\n\n    # Material parameters\n    E = 210.0e9  # Pascals\n    nu = 0.30\n\n    # Affine displacement field parameters\n    affine_coeffs = {\n        'alpha': 1.0e-3, 'beta': -2.0e-4, 'gamma': 2.5e-3,\n        'delta': 3.0e-4, 'epsilon': 5.0e-4, 'zeta': -1.1e-3\n    }\n    \n    # Pass/fail tolerance\n    tolerance = 1.0e-10\n\n    results = []\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        elements = case[\"elements\"]\n        passed = run_patch_test(nodes, elements, E, nu, affine_coeffs, tolerance)\n        results.append(passed)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_patch_test(nodes, elements, E, nu, affine_coeffs, tolerance):\n    \"\"\"\n    Performs the patch test for a single mesh configuration.\n    \"\"\"\n    num_nodes = nodes.shape[0]\n    num_dofs = 2 * num_nodes\n    \n    # 1. Material matrix for plane stress\n    D = (E / (1 - nu**2)) * np.array([[1, nu, 0],\n                                     [nu, 1, 0],\n                                     [0, 0, (1 - nu) / 2]])\n    \n    # 2. Gaussian quadrature points and weights (2x2)\n    gp = 1.0 / np.sqrt(3.0)\n    gauss_points = [(-gp, -gp), (gp, -gp), (gp, gp), (-gp, gp)]\n    gauss_weights = [1.0, 1.0, 1.0, 1.0]\n\n    # 3. Assemble global stiffness matrix K\n    K_global = np.zeros((num_dofs, num_dofs))\n    element_gauss_data = [] # To store B matrices and detJ for strain calculations\n\n    for el_nodes_indices in elements:\n        el_nodes_coords = nodes[el_nodes_indices]\n        K_element = np.zeros((8, 8))\n        gauss_data_for_element = []\n\n        for i, (xi, eta) in enumerate(gauss_points):\n            # Shape function derivatives w.r.t. natural coordinates\n            dN_dxi_eta = 0.25 * np.array([\n                [-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)],\n                [-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)]\n            ])\n            \n            # Jacobian matrix\n            J = dN_dxi_eta @ el_nodes_coords\n            detJ = np.linalg.det(J)\n            invJ = np.linalg.inv(J)\n            \n            # Shape function derivatives w.r.t. physical coordinates\n            dN_dxy = invJ @ dN_dxi_eta\n            \n            # Strain-displacement matrix B\n            B = np.zeros((3, 8))\n            for j in range(4):\n                B[0, 2*j] = dN_dxy[0, j]\n                B[1, 2*j+1] = dN_dxy[1, j]\n                B[2, 2*j] = dN_dxy[1, j]\n                B[2, 2*j+1] = dN_dxy[0, j]\n            \n            K_element += B.T @ D @ B * detJ * gauss_weights[i]\n            gauss_data_for_element.append({'B': B, 'detJ': detJ})\n        \n        element_gauss_data.append(gauss_data_for_element)\n\n        # Assemble into global K\n        dof_indices = np.array([[2*i, 2*i+1] for i in el_nodes_indices]).flatten()\n        K_global[np.ix_(dof_indices, dof_indices)] += K_element\n        \n    # 4. Apply boundary conditions\n    boundary_nodes = find_boundary_nodes(elements)\n    prescribed_dofs = []\n    for node_idx in boundary_nodes:\n        prescribed_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n    \n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, prescribed_dofs)\n\n    # 5. Calculate exact displacements and solve system\n    d_exact = calculate_exact_displacements(nodes, affine_coeffs)\n    d_p = d_exact[prescribed_dofs]\n    \n    K_ff = K_global[np.ix_(free_dofs, free_dofs)]\n    K_fp = K_global[np.ix_(free_dofs, prescribed_dofs)]\n\n    F_eff = -K_fp @ d_p\n    d_f = np.linalg.solve(K_ff, F_eff)\n    \n    d_solution = np.zeros(num_dofs)\n    d_solution[prescribed_dofs] = d_p\n    d_solution[free_dofs] = d_f\n\n    # 6. Calculate errors\n    # Displacement error\n    e_u = np.max(np.abs(d_solution - d_exact))\n    \n    # Strain error\n    alpha, beta, delta, epsilon = [affine_coeffs[k] for k in ['alpha', 'beta', 'delta', 'epsilon']]\n    strain_target = np.array([alpha, epsilon, beta + delta])\n    \n    e_strain = 0.0\n    for i, el_nodes_indices in enumerate(elements):\n        el_dof_indices = np.array([[2*j, 2*j+1] for j in el_nodes_indices]).flatten()\n        d_element = d_solution[el_dof_indices]\n        \n        for gauss_data in element_gauss_data[i]:\n            B = gauss_data['B']\n            strain_computed = B @ d_element\n            e_strain = max(e_strain, np.max(np.abs(strain_computed - strain_target)))\n\n    return e_u = tolerance and e_strain = tolerance\n\ndef find_boundary_nodes(elements):\n    \"\"\"\n    Identifies boundary nodes from an element connectivity list.\n    \"\"\"\n    edge_counts = collections.defaultdict(int)\n    for el in elements:\n        for i in range(4):\n            n1 = el[i]\n            n2 = el[(i + 1) % 4]\n            edge = tuple(sorted((n1, n2)))\n            edge_counts[edge] += 1\n            \n    boundary_edges = {edge for edge, count in edge_counts.items() if count == 1}\n    boundary_nodes = set()\n    for edge in boundary_edges:\n        boundary_nodes.update(edge)\n        \n    return boundary_nodes\n\ndef calculate_exact_displacements(nodes, coeffs):\n    \"\"\"\n    Calculates exact nodal displacements from the affine field.\n    \"\"\"\n    num_nodes = nodes.shape[0]\n    d_exact = np.zeros(2 * num_nodes)\n    alpha, beta, gamma = coeffs['alpha'], coeffs['beta'], coeffs['gamma']\n    delta, epsilon, zeta = coeffs['delta'], coeffs['epsilon'], coeffs['zeta']\n    \n    for i in range(num_nodes):\n        x, y = nodes[i, 0], nodes[i, 1]\n        d_exact[2*i] = gamma + alpha * x + beta * y  # u\n        d_exact[2*i+1] = zeta + delta * x + epsilon * y # v\n        \n    return d_exact\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2378079"}, {"introduction": "A successful finite element simulation yields a wealth of data, but raw numbers alone do not provide engineering insight. A crucial step is post-processing, where we transform this data into physically meaningful quantities to assess performance and safety. This exercise [@problem_id:2378068] focuses on a key post-processing task: calculating the principal stresses and their directions from a given Cauchy stress tensor, which is essential for predicting material failure according to various criteria.", "problem": "You are given a set of symmetric Cauchy stress tensors at selected points of a three-dimensional ($3$D) solid component subjected to static loading. Each stress state is represented by a real, symmetric $3\\times 3$ matrix $\\boldsymbol{\\sigma}$ with entries in Pascal (Pa). For each stress tensor, determine the first principal stress direction, defined as the unit vector $\\boldsymbol{v}_{1}\\in\\mathbb{R}^{3}$ associated with the maximum principal stress. The first principal stress direction is the direction $\\boldsymbol{v}_{1}$ for which the traction vector on a plane with unit normal $\\boldsymbol{n}=\\boldsymbol{v}_{1}$ is colinear with $\\boldsymbol{n}$ and the corresponding scalar traction (principal stress) is maximal among all such directions.\n\nAdopt the following convention so that the direction is uniquely reported:\n- Normalize the direction to have unit Euclidean norm.\n- To fix its sign, let $\\tau=10^{-12}$. Find the first component among $(v_{x},v_{y},v_{z})$ whose absolute value exceeds $\\tau$; if that component is negative, multiply the vector by $-1$. If no component exceeds $\\tau$ (which cannot occur for a nonzero unit vector), report $\\left[1,0,0\\right]$.\n\nReport each direction as a list of its Cartesian components $\\left[v_{x},v_{y},v_{z}\\right]$, each rounded to six decimal places. The components are dimensionless.\n\nTest Suite (each tensor is given in Pascal (Pa); entries are exact):\n- Case $1$:\n  $\\boldsymbol{\\sigma}_{1}=\\begin{bmatrix}\n  1.20\\times 10^{8}  3.0\\times 10^{7}  0.0\\\\\n  3.0\\times 10^{7}  8.0\\times 10^{7}  1.0\\times 10^{7}\\\\\n  0.0  1.0\\times 10^{7}  6.0\\times 10^{7}\n  \\end{bmatrix}$\n- Case $2$:\n  $\\boldsymbol{\\sigma}_{2}=\\begin{bmatrix}\n  5.0\\times 10^{7}  0.0  0.0\\\\\n  0.0  2.0\\times 10^{8}  0.0\\\\\n  0.0  0.0  1.0\\times 10^{8}\n  \\end{bmatrix}$\n- Case $3$:\n  $\\boldsymbol{\\sigma}_{3}=\\begin{bmatrix}\n  0.0  5.0\\times 10^{7}  0.0\\\\\n  5.0\\times 10^{7}  0.0  0.0\\\\\n  0.0  0.0  -1.0\\times 10^{7}\n  \\end{bmatrix}$\n- Case $4$:\n  $\\boldsymbol{\\sigma}_{4}=\\begin{bmatrix}\n  1.01\\times 10^{8}  1.0\\times 10^{6}  2.0\\times 10^{6}\\\\\n  1.0\\times 10^{6}  1.00\\times 10^{8}  1.5\\times 10^{6}\\\\\n  2.0\\times 10^{6}  1.5\\times 10^{6}  1.02\\times 10^{8}\n  \\end{bmatrix}$\n- Case $5$:\n  $\\boldsymbol{\\sigma}_{5}=\\begin{bmatrix}\n  -1.00\\times 10^{8}  0.0  0.0\\\\\n  0.0  -5.0\\times 10^{7}  0.0\\\\\n  0.0  0.0  -7.5\\times 10^{7}\n  \\end{bmatrix}$\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is itself a bracketed triple for the corresponding test case, with no spaces. For example, a valid format is $\\left[[0.577350,0.577350,0.577350],[\\dots]\\right]$.", "solution": "The problem as stated is subjected to validation.\n\n**Step 1: Extracted Givens**\n- The problem is set in the context of $3$D solid mechanics.\n- Input consists of a set of symmetric $3 \\times 3$ Cauchy stress tensors, $\\boldsymbol{\\sigma}$, with real entries in units of Pascals (Pa).\n- The task is to find the first principal stress direction, $\\boldsymbol{v}_{1} \\in \\mathbb{R}^{3}$, for each tensor.\n- The first principal stress direction is defined as the unit eigenvector associated with the maximum principal stress.\n- A uniqueness convention is prescribed:\n    1. The vector $\\boldsymbol{v}_{1}$ must be normalized to unit Euclidean norm.\n    2. A sign-fixing rule is given: with a tolerance $\\tau = 10^{-12}$, find the first component of the vector $(v_{x}, v_{y}, v_{z})$ whose absolute value exceeds $\\tau$. If this component is negative, the entire vector must be multiplied by $-1$.\n- The output for each direction is a list of its Cartesian components, $[v_{x}, v_{y}, v_{z}]$, with each component rounded to six decimal places.\n- Five specific stress tensors, $\\boldsymbol{\\sigma}_{1}$ through $\\boldsymbol{\\sigma}_{5}$, are provided as test cases.\n\n**Step 2: Validation of Givens**\nThe problem is evaluated against the validation criteria:\n- **Scientifically Grounded:** The problem is a fundamental exercise in linear elasticity and continuum mechanics. The Cauchy stress tensor, its symmetry, principal stresses, and principal directions are core, well-established concepts. The problem is scientifically sound.\n- **Well-Posed:** For any real symmetric matrix, such as the stress tensor $\\boldsymbol{\\sigma}$, there exist real eigenvalues (principal stresses) and a corresponding set of orthogonal eigenvectors (principal directions). The problem asks for the direction associated with the maximum eigenvalue. Since all provided test cases result in distinct eigenvalues, the principal directions are unique up to sign. The provided sign-fixing convention resolves this ambiguity, making the problem well-posed.\n- **Objective:** The problem is formulated with precise mathematical language and quantitative data. The procedure for determining the final vector is algorithmic and unambiguous. No subjective interpretation is required.\n- **Completeness and Consistency:** All necessary information, including the stress tensors and a clear rule for uniqueness, is provided. The setup is self-contained and free of contradictions. The units (Pa) and magnitudes of stress are physically plausible for engineering materials.\n\n**Step 3: Verdict and Action**\nThe problem is valid as it is scientifically grounded, well-posed, objective, and self-contained. A solution will be provided.\n\nThe task is to find the first principal direction for a given Cauchy stress tensor $\\boldsymbol{\\sigma}$. This is equivalent to finding the eigenvector corresponding to the largest eigenvalue of the matrix $\\boldsymbol{\\sigma}$. The relationship between a principal stress $\\sigma_{p}$ and its corresponding principal direction $\\boldsymbol{v}$ is defined by the eigenvalue problem:\n$$\n\\boldsymbol{\\sigma}\\boldsymbol{v} = \\sigma_{p}\\boldsymbol{v}\n$$\nHere, $\\sigma_{p}$ is an eigenvalue and $\\boldsymbol{v}$ is the corresponding eigenvector of $\\boldsymbol{\\sigma}$. Since the Cauchy stress tensor is, by the principle of conservation of angular momentum, a symmetric matrix ($\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{T}$), the spectral theorem for real symmetric matrices guarantees that it has three real eigenvalues (the principal stresses $\\sigma_{1}, \\sigma_{2}, \\sigma_{3}$) and a set of three mutually orthogonal eigenvectors (the principal directions $\\boldsymbol{v}_{1}, \\boldsymbol{v}_{2}, \\boldsymbol{v}_{3}$).\n\nThe first principal stress is defined as the algebraically largest eigenvalue, typically denoted $\\sigma_{1}$, where $\\sigma_{1} \\ge \\sigma_{2} \\ge \\sigma_{3}$. The corresponding first principal direction is its associated eigenvector, $\\boldsymbol{v}_{1}$.\n\nThe computational procedure to solve this for each given stress tensor is as follows:\nFirst, we solve the eigenvalue problem. This is a standard task in numerical linear algebra. We will employ a robust eigensolver, such as the one available in the `NumPy` library for Python, specifically `numpy.linalg.eigh`. This function is optimized for symmetric (or Hermitian) matrices and has the convenient property of returning the eigenvalues sorted in ascending order. Consequently, the maximum eigenvalue, $\\sigma_{1}$, will be the last element in the returned array of eigenvalues. The corresponding eigenvector, $\\boldsymbol{v}_{1}$, will be the last column in the returned matrix of eigenvectors.\n\nSecond, we must adhere to the problem's uniqueness convention. The `numpy.linalg.eigh` function returns eigenvectors that are already normalized to have a unit Euclidean norm, satisfying the first part of the convention. The second part is a sign-fixing rule. An eigenvector $\\boldsymbol{v}$ is equivalent to $-\\boldsymbol{v}$ as they both define the same direction (eigenspace). To ensure a single representation, we apply the specified procedure. Let the computed unit eigenvector be $\\boldsymbol{v} = [v_{x}, v_{y}, v_{z}]^{T}$, and let the tolerance be $\\tau = 10^{-12}$.\n1. Examine the first component, $v_{x}$. If $|v_{x}| > \\tau$, its sign determines the sign of the entire vector. If $v_{x}  0$, we set the final vector to $-\\boldsymbol{v}$. Otherwise, we use $\\boldsymbol{v}$ as is.\n2. If $|v_{x}| \\le \\tau$, we proceed to examine the second component, $v_{y}$. If $|v_{y}| > \\tau$, its sign determines the orientation. If $v_{y}  0$, we use $-\\boldsymbol{v}$. Otherwise, we use $\\boldsymbol{v}$.\n3. If both $|v_{x}| \\le \\tau$ and $|v_{y}| \\le \\tau$, we examine the third component, $v_{z}$. As the vector has unit norm, $|v_{z}|$ must be greater than $\\tau$. If $v_{z}  0$, we use $-\\boldsymbol{v}$. Otherwise, we use $\\boldsymbol{v}$.\nThis procedure ensures that the reported vector is unique.\n\nFinally, the components of the resulting unique direction vector are rounded to six decimal places, as required. This entire process is systematically applied to each of the five given stress tensors, $\\boldsymbol{\\sigma}_{1}$ through $\\boldsymbol{\\sigma}_{5}$. The results are then aggregated into the specified final output format.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the first principal stress direction for a set of Cauchy stress tensors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each stress tensor is given in units of Pascal (Pa).\n    test_cases = [\n        # Case 1\n        np.array([\n            [1.20e8, 3.0e7, 0.0],\n            [3.0e7, 8.0e7, 1.0e7],\n            [0.0, 1.0e7, 6.0e7]\n        ]),\n        # Case 2\n        np.array([\n            [5.0e7, 0.0, 0.0],\n            [0.0, 2.0e8, 0.0],\n            [0.0, 0.0, 1.0e8]\n        ]),\n        # Case 3\n        np.array([\n            [0.0, 5.0e7, 0.0],\n            [5.0e7, 0.0, 0.0],\n            [0.0, 0.0, -1.0e7]\n        ]),\n        # Case 4\n        np.array([\n            [1.01e8, 1.0e6, 2.0e6],\n            [1.0e6, 1.00e8, 1.5e6],\n            [2.0e6, 1.5e6, 1.02e8]\n        ]),\n        # Case 5\n        np.array([\n            [-1.00e8, 0.0, 0.0],\n            [0.0, -5.0e7, 0.0],\n            [0.0, 0.0, -7.5e7]\n        ])\n    ]\n\n    results = []\n    tau = 1e-12\n\n    for sigma in test_cases:\n        # For a symmetric matrix sigma, np.linalg.eigh returns eigenvalues in\n        # ascending order and the corresponding normalized eigenvectors as columns\n        # of the returned matrix.\n        eigenvalues, eigenvectors = np.linalg.eigh(sigma)\n\n        # The first principal stress is the maximum eigenvalue.\n        # Its direction is the corresponding eigenvector. Due to the ascending sort,\n        # this is the last column of the eigenvectors matrix.\n        v1 = eigenvectors[:, -1]\n\n        # Apply the uniqueness convention to fix the sign of the direction vector.\n        # The eigenvector is already of unit norm.\n        # Find the first component with an absolute value greater than tau.\n        # If this component is negative, flip the sign of the entire vector.\n        for i in range(3):\n            if abs(v1[i]) > tau:\n                if v1[i]  0:\n                    v1 = -v1\n                break\n        \n        # Format the components by rounding to six decimal places,\n        # ensuring trailing zeros are present.\n        v1_formatted = [f\"{comp:.6f}\" for comp in v1]\n\n        # Assemble the formatted vector into a string representation of a list.\n        result_str = f\"[{','.join(v1_formatted)}]\"\n        results.append(result_str)\n\n    # Print the final list of results in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2378068"}]}