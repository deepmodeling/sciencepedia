{"hands_on_practices": [{"introduction": "The best way to understand an algorithm is to implement it. This first practice challenges you to apply the velocity Verlet integrator to a classic physical system: a binary star system governed by Newtonian gravity [@problem_id:2414438]. By simulating the orbital dance of two masses, you will gain hands-on experience with the core update steps of the algorithm and learn to use total energy conservation as a vital tool for verifying the long-term stability and accuracy of your simulation.", "problem": "Consider a closed, isolated, planar two-body system governed by Newtonian gravity. Two point masses with masses $m_1$ and $m_2$ move in two spatial dimensions under their mutual gravitational attraction, with no other forces present and no external torques. Let the universal gravitational constant (in Astronomical Units, Solar Masses, and Years) be $G = 4\\pi^2$, where distance is measured in Astronomical Units (AU), mass in Solar Masses ($M_{\\odot}$), and time in Years (yr). Let the positions be $\\mathbf{r}_1(t), \\mathbf{r}_2(t) \\in \\mathbb{R}^2$, and velocities be $\\mathbf{v}_1(t), \\mathbf{v}_2(t) \\in \\mathbb{R}^2$. The equations of motion are defined by Newtonâ€™s second law and the law of universal gravitation. The total energy at time $t$ is given by\n$$\nE(t) = \\tfrac{1}{2} m_1 \\|\\mathbf{v}_1(t)\\|^2 + \\tfrac{1}{2} m_2 \\|\\mathbf{v}_2(t)\\|^2 - \\frac{G m_1 m_2}{\\|\\mathbf{r}_1(t) - \\mathbf{r}_2(t)\\|}.\n$$\nDefine the maximum relative energy deviation over a simulation interval $[0, T_{\\text{end}}]$ with time step $\\Delta t$ as\n$$\n\\varepsilon_{\\max} = \\max_{t_k \\in \\{0, \\Delta t, 2\\Delta t, \\dots\\}} \\frac{|E(t_k) - E(0)|}{|E(0)|}.\n$$\nSimulate the system for the following test suite. For each case, initialize the state at $t = 0$ with the given masses, positions (in AU), velocities (in AU/yr), time step $\\Delta t$ (in yr), and total simulation duration $T_{\\text{end}}$ (in yr). Compute $\\varepsilon_{\\max}$ as defined above. Express each result as a decimal float rounded to six significant digits (dimensionless).\n\nTest Suite (each line defines one case):\n- Case $1$ (equal-mass circular configuration, short step): $m_1 = 1.0$, $m_2 = 1.0$, $\\mathbf{r}_1(0) = (-0.5, 0.0)$, $\\mathbf{r}_2(0) = (0.5, 0.0)$, $\\mathbf{v}_1(0) = (0.0, 4.442882938)$, $\\mathbf{v}_2(0) = (0.0, -4.442882938)$, $\\Delta t = 0.001$, $T_{\\text{end}} = 0.707106781$.\n- Case $2$ (equal-mass circular configuration, larger step): $m_1 = 1.0$, $m_2 = 1.0$, $\\mathbf{r}_1(0) = (-0.5, 0.0)$, $\\mathbf{r}_2(0) = (0.5, 0.0)$, $\\mathbf{v}_1(0) = (0.0, 4.442882938)$, $\\mathbf{v}_2(0) = (0.0, -4.442882938)$, $\\Delta t = 0.01$, $T_{\\text{end}} = 0.707106781$.\n- Case $3$ (extreme mass ratio, wide separation circular configuration): $m_1 = 1.0$, $m_2 = 0.001$, $\\mathbf{r}_1(0) = (-0.005194805195, 0.0)$, $\\mathbf{r}_2(0) = (5.194805195, 0.0)$, $\\mathbf{v}_1(0) = (0.0, 0.002754177)$, $\\mathbf{v}_2(0) = (0.0, -2.754177)$, $\\Delta t = 0.01$, $T_{\\text{end}} = 11.86$.\n- Case $4$ (equal-mass circular configuration, long duration and coarse step): $m_1 = 1.0$, $m_2 = 1.0$, $\\mathbf{r}_1(0) = (-0.5, 0.0)$, $\\mathbf{r}_2(0) = (0.5, 0.0)$, $\\mathbf{v}_1(0) = (0.0, 4.442882938)$, $\\mathbf{v}_2(0) = (0.0, -4.442882938)$, $\\Delta t = 0.05$, $T_{\\text{end}} = 7.071067811$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite, for example, $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4]$, where each $\\varepsilon_i$ is $\\varepsilon_{\\max}$ for Case $i$ rounded to six significant digits.", "solution": "The problem presented is a well-posed and scientifically grounded task in computational mechanics. It requires the numerical simulation of a planar two-body system under mutual Newtonian gravitational attraction. The objective is to compute the maximum relative energy deviation over the course of the simulation, which serves as a metric for the numerical accuracy and energy conservation of the integration method.\n\nThe system is governed by Newton's second law and the law of universal gravitation. For two point masses $m_1$ and $m_2$ at positions $\\mathbf{r}_1$ and $\\mathbf{r}_2$, the force exerted on $m_1$ by $m_2$ is\n$$\n\\mathbf{F}_1 = \\frac{G m_1 m_2}{\\|\\mathbf{r}_2 - \\mathbf{r}_1\\|^3} (\\mathbf{r}_2 - \\mathbf{r}_1).\n$$\nBy Newton's third law, $\\mathbf{F}_2 = -\\mathbf{F}_1$. The accelerations are thus given by:\n$$\n\\mathbf{a}_1(t) = \\frac{\\mathbf{F}_1}{m_1} = \\frac{G m_2}{\\|\\mathbf{r}_2(t) - \\mathbf{r}_1(t)\\|^3} (\\mathbf{r}_2(t) - \\mathbf{r}_1(t))\n$$\n$$\n\\mathbf{a}_2(t) = \\frac{\\mathbf{F}_2}{m_2} = \\frac{G m_1}{\\|\\mathbf{r}_1(t) - \\mathbf{r}_2(t)\\|^3} (\\mathbf{r}_1(t) - \\mathbf{r}_2(t)).\n$$\nHere, $G = 4\\pi^2$ is the gravitational constant in the specified units of AU, Solar Masses, and Years.\n\nTo solve this system of ordinary differential equations numerically, a suitable integration scheme must be employed. The Velocity Verlet algorithm is an excellent choice for this type of problem. It is a time-reversible, symplectic integrator known for its superior long-term energy conservation compared to simpler methods like the Euler integrator. The algorithm updates positions and velocities from time $t$ to $t + \\Delta t$ as follows:\n\n1.  First, update the positions using the current velocities and accelerations:\n    $$\n    \\mathbf{r}_i(t + \\Delta t) = \\mathbf{r}_i(t) + \\mathbf{v}_i(t) \\Delta t + \\frac{1}{2} \\mathbf{a}_i(t) (\\Delta t)^2 \\quad \\text{for } i \\in \\{1, 2\\}.\n    $$\n\n2.  Next, compute the accelerations $\\mathbf{a}_i(t + \\Delta t)$ at the new positions $\\mathbf{r}_i(t + \\Delta t)$.\n\n3.  Finally, update the velocities using the average of the old and new accelerations:\n    $$\n    \\mathbf{v}_i(t + \\Delta t) = \\mathbf{v}_i(t) + \\frac{1}{2} (\\mathbf{a}_i(t) + \\mathbf{a}_i(t + \\Delta t)) \\Delta t \\quad \\text{for } i \\in \\{1, 2\\}.\n    $$\n\nThe simulation proceeds by iteratively applying these steps. The algorithm is as follows:\n\n1.  Initialize the state of the system at $t=0$ using the provided masses $m_1, m_2$, initial positions $\\mathbf{r}_1(0), \\mathbf{r}_2(0)$, and initial velocities $\\mathbf{v}_1(0), \\mathbf{v}_2(0)$.\n2.  Calculate the initial total energy $E(0)$. The total energy is the sum of the kinetic and potential energies:\n    $$\n    E(t) = \\frac{1}{2} m_1 \\|\\mathbf{v}_1(t)\\|^2 + \\frac{1}{2} m_2 \\|\\mathbf{v}_2(t)\\|^2 - \\frac{G m_1 m_2}{\\|\\mathbf{r}_1(t) - \\mathbf{r}_2(t)\\|}.\n    $$\n    If $E(0)=0$, the relative error is undefined. However, for the provided initial conditions corresponding to bound (circular) orbits, the total energy is negative, so this is not a concern.\n3.  Calculate the initial accelerations $\\mathbf{a}_1(0)$ and $\\mathbf{a}_2(0)$ using the initial positions.\n4.  Initialize the maximum relative energy deviation $\\varepsilon_{\\max}$ to $0$.\n5.  Begin a time-stepping loop from $t=0$ to $T_{\\text{end}}$ with a time step of $\\Delta t$. The number of steps is given by $N = \\text{round}(T_{\\text{end}} / \\Delta t)$.\n6.  In each step of the loop, update the positions and velocities of both masses using the Velocity Verlet algorithm.\n7.  After each update, calculate the new total energy $E(t_k)$ for the current time step $t_k = k\\Delta t$.\n8.  Compute the relative energy deviation for the current step: $\\varepsilon_k = \\frac{|E(t_k) - E(0)|}{|E(0)|}$.\n9.  Update $\\varepsilon_{\\max}$ such that $\\varepsilon_{\\max} = \\max(\\varepsilon_{\\max}, \\varepsilon_k)$.\n10. After the loop completes, the final value of $\\varepsilon_{\\max}$ is the result for the given test case.\n\nThis procedure is applied to each of the four test cases specified in the problem statement. The resulting values of $\\varepsilon_{\\max}$ are then formatted to six significant digits and presented in the required output format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the two-body problem for the given test cases and prints the results.\n    \"\"\"\n\n    # Define the gravitational constant in AU, M_sun, yr units.\n    G = 4.0 * np.pi**2\n\n    # Test suite from the problem statement.\n    test_cases = [\n        # Case 1: m1, m2, r1(0), r2(0), v1(0), v2(0), dt, T_end\n        (1.0, 1.0, [-0.5, 0.0], [0.5, 0.0], [0.0, 4.442882938], [0.0, -4.442882938], 0.001, 0.707106781),\n        # Case 2\n        (1.0, 1.0, [-0.5, 0.0], [0.5, 0.0], [0.0, 4.442882938], [0.0, -4.442882938], 0.01, 0.707106781),\n        # Case 3\n        (1.0, 0.001, [-0.005194805195, 0.0], [5.194805195, 0.0], [0.0, 0.002754177], [0.0, -2.754177], 0.01, 11.86),\n        # Case 4\n        (1.0, 1.0, [-0.5, 0.0], [0.5, 0.0], [0.0, 4.442882938], [0.0, -4.442882938], 0.05, 7.071067811),\n    ]\n\n    def run_simulation(m1, m2, r1_0, r2_0, v1_0, v2_0, dt, T_end):\n        \"\"\"\n        Runs a single two-body simulation using the Velocity Verlet integrator.\n        \"\"\"\n        r1, r2 = np.array(r1_0, dtype=float), np.array(r2_0, dtype=float)\n        v1, v2 = np.array(v1_0, dtype=float), np.array(v2_0, dtype=float)\n\n        def get_energy(cur_r1, cur_r2, cur_v1, cur_v2):\n            r_vec = cur_r1 - cur_r2\n            dist = np.linalg.norm(r_vec)\n            kinetic_energy = 0.5 * m1 * np.dot(cur_v1, cur_v1) + 0.5 * m2 * np.dot(cur_v2, cur_v2)\n            potential_energy = -G * m1 * m2 / dist\n            return kinetic_energy + potential_energy\n\n        def get_accelerations(cur_r1, cur_r2):\n            r_vec = cur_r2 - cur_r1\n            dist_cubed = np.linalg.norm(r_vec)**3\n            if dist_cubed == 0:\n                raise ValueError(\"Collision detected: distance between bodies is zero.\")\n            a1 = G * m2 * r_vec / dist_cubed\n            a2 = -G * m1 * r_vec / dist_cubed\n            return a1, a2\n\n        # Initial conditions\n        E0 = get_energy(r1, r2, v1, v2)\n        if E0 == 0:\n            return 0.0  # Relative error is undefined, but max deviation would be 0 if energy is conserved.\n\n        a1, a2 = get_accelerations(r1, r2)\n        \n        max_rel_error = 0.0\n        num_steps = int(round(T_end / dt))\n\n        for _ in range(num_steps):\n            # Velocity Verlet Integration\n            # 1. Update positions\n            r1_new = r1 + v1 * dt + 0.5 * a1 * dt**2\n            r2_new = r2 + v2 * dt + 0.5 * a2 * dt**2\n\n            # 2. Compute new accelerations\n            a1_new, a2_new = get_accelerations(r1_new, r2_new)\n\n            # 3. Update velocities\n            v1_new = v1 + 0.5 * (a1 + a1_new) * dt\n            v2_new = v2 + 0.5 * (a2 + a2_new) * dt\n            \n            # Update state for next iteration\n            r1, r2 = r1_new, r2_new\n            v1, v2 = v1_new, v2_new\n            a1, a2 = a1_new, a2_new\n\n            # Calculate energy and update max relative error\n            E_t = get_energy(r1, r2, v1, v2)\n            rel_error = abs((E_t - E0) / E0)\n            if rel_error > max_rel_error:\n                max_rel_error = rel_error\n\n        return max_rel_error\n\n    results = []\n    for case in test_cases:\n        epsilon_max = run_simulation(*case)\n        results.append(epsilon_max)\n\n    # Format results to six significant digits. The 'g' format specifier achieves this.\n    formatted_results = [f\"{res:.6g}\" for res in results]\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2414438"}, {"introduction": "The \"Verlet integrator\" is actually a family of related algorithms. This exercise invites you to explore two of its most prominent members: the position Verlet and velocity Verlet schemes, by deriving them from first principles [@problem_id:2414503]. You will then implement both to simulate a challenging, highly eccentric orbit, allowing you to critically compare their performance and understand the practical trade-offs involved in their implementation, particularly in how kinetic energy is computed.", "problem": "Consider the planar two-body problem in a non-dimensionalized setting commonly used in Molecular Dynamics (MD), where the test particle of mass $m$ orbits a fixed central mass via Newtonian gravity. Adopt the following fundamental model and definitions as the base of your derivation and implementation:\n\n- Newtonâ€™s Second Law: $m \\,\\dfrac{d^{2}\\mathbf{r}}{dt^{2}} = \\mathbf{F}(\\mathbf{r})$.\n- Gravitational Force: $\\mathbf{F}(\\mathbf{r}) = -\\,\\mu\\,m\\,\\dfrac{\\mathbf{r}}{\\|\\mathbf{r}\\|^{3}}$, where $\\mu$ is the gravitational parameter of the central mass and $\\|\\mathbf{r}\\|$ is the Euclidean norm of the position vector $\\mathbf{r}$.\n- Kinetic Energy: $T = \\dfrac{1}{2}\\,m\\,\\|\\mathbf{v}\\|^{2}$.\n- Potential Energy: $U = -\\,\\dfrac{\\mu\\,m}{\\|\\mathbf{r}\\|}$.\n- Total Energy: $E = T + U$.\n\nYou will compare the long-term energy drift between two second-order symplectic integrators that are standard in Molecular Dynamics (MD): the position Verlet integrator and the velocity Verlet integrator. Begin from the fundamental base above and derive both update rules to second order in the time step by using Taylor expansions consistent with Newtonâ€™s Second Law. Do not use any pre-given integration formulas; instead, derive the discrete-time recurrence relations that advance the state $\\left(\\mathbf{r},\\mathbf{v}\\right)$ and the associated acceleration $\\mathbf{a}(\\mathbf{r}) = \\mathbf{F}(\\mathbf{r})/m$.\n\nInitial condition construction for a Keplerian ellipse: Use a non-dimensional system with gravitational parameter $\\mu = 1$, mass $m = 1$, and semi-major axis $a = 1$. For a given eccentricity $e \\in [0,1)$, initialize the orbit at periapsis, i.e., set the initial position and velocity as follows:\n- Periapsis radius $r_{\\mathrm{p}} = a\\,(1 - e)$.\n- Position $\\mathbf{r}_{0} = (r_{\\mathrm{p}},\\,0)$.\n- Periapsis speed $v_{\\mathrm{p}} = \\sqrt{\\dfrac{\\mu\\,(1+e)}{a\\,(1-e)}}$.\n- Velocity $\\mathbf{v}_{0} = (0,\\,v_{\\mathrm{p}})$.\n\nEnergy drift metric: For a given integrator, time step $\\Delta t$, and number of steps $N$, simulate the system and record the total energy $E(t_{n})$ at discrete times $t_{n} = n\\,\\Delta t$. Define the energy drift as the absolute value of the best-fit slope $s$ from a least-squares linear fit of $E(t)$ versus $t$ over the recorded trajectory. That is, fit $E(t) \\approx s\\,t + b$ and take $\\lvert s \\rvert$ as the drift. Express all energies in the dimensionless units implied by $\\mu = 1$ and $m = 1$, and express the drift $s$ in these same energy units per unit time.\n\nAlgorithmic requirements:\n- Position Verlet: Derive and implement the second-order, time-reversible position-only update that uses positions $\\mathbf{r}_{n-1}$ and $\\mathbf{r}_{n}$ to compute $\\mathbf{r}_{n+1}$, with accelerations evaluated from positions. For computing kinetic energy at time $t_{n}$, use the centered finite-difference velocity $\\mathbf{v}_{n} \\approx \\dfrac{\\mathbf{r}_{n+1} - \\mathbf{r}_{n-1}}{2\\,\\Delta t}$.\n- Velocity Verlet: Derive and implement the second-order, time-reversible update that uses positions and velocities to advance $\\left(\\mathbf{r}_{n},\\mathbf{v}_{n}\\right)$ to $\\left(\\mathbf{r}_{n+1},\\mathbf{v}_{n+1}\\right)$ using accelerations $\\mathbf{a}(\\mathbf{r})$ evaluated at the appropriate stages.\n\nTest suite: Use the following three parameter sets, each characterized by $(e,\\Delta t,N)$, with $a = 1$, $\\mu = 1$, $m = 1$:\n- Case $1$: $e = 0.9$, $\\Delta t = 0.0015$, $N = 40000$.\n- Case $2$: $e = 0.9$, $\\Delta t = 0.003$, $N = 40000$.\n- Case $3$: $e = 0.0$, $\\Delta t = 0.01$, $N = 40000$.\n\nFor each case, compute two floats:\n- The absolute drift $\\lvert s_{\\mathrm{PV}} \\rvert$ for the position Verlet integrator.\n- The absolute drift $\\lvert s_{\\mathrm{VV}} \\rvert$ for the velocity Verlet integrator.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$[\\lvert s_{\\mathrm{PV}} \\rvert^{(1)},\\lvert s_{\\mathrm{VV}} \\rvert^{(1)},\\lvert s_{\\mathrm{PV}} \\rvert^{(2)},\\lvert s_{\\mathrm{VV}} \\rvert^{(2)},\\lvert s_{\\mathrm{PV}} \\rvert^{(3)},\\lvert s_{\\mathrm{VV}} \\rvert^{(3)}]$,\nwhere the superscript denotes the case index in the order above. All values must be printed as floating-point numbers in the non-dimensional energy-per-time unit implied by $\\mu = 1$, $m = 1$, and $a = 1$.", "solution": "The problem presented is a standard exercise in computational physics, requiring the derivation, implementation, and comparison of two fundamental symplectic integrators for the Kepler problem. The problem is well-defined, scientifically sound, and internally consistent. It is therefore deemed valid. We proceed with the solution.\n\nThe foundation of our analysis is Newton's second law of motion for a particle of mass $m$ under a central force $\\mathbf{F}(\\mathbf{r})$, given by\n$$ m \\frac{d^2\\mathbf{r}}{dt^2} = \\mathbf{F}(\\mathbf{r}) $$\nHere, $\\mathbf{r}(t) \\in \\mathbb{R}^2$ is the position vector. The acceleration is $\\mathbf{a}(\\mathbf{r}) = \\mathbf{F}(\\mathbf{r})/m$. For the gravitational force specified, the acceleration is\n$$ \\mathbf{a}(\\mathbf{r}) = -\\mu \\frac{\\mathbf{r}}{\\|\\mathbf{r}\\|^3} $$\nwhere $\\mu$ is the gravitational parameter of the central body.\n\nThe derivation of the numerical integration schemes proceeds from the Taylor series expansion of the position vector $\\mathbf{r}(t)$ about a time $t_n$. Let $\\Delta t$ be the discrete time step. The positions at times $t_{n+1} = t_n + \\Delta t$ and $t_{n-1} = t_n - \\Delta t$ are:\n$$ \\mathbf{r}(t_{n+1}) = \\mathbf{r}(t_n) + \\mathbf{v}(t_n)\\Delta t + \\frac{1}{2}\\mathbf{a}(t_n)(\\Delta t)^2 + \\frac{1}{6}\\frac{d\\mathbf{a}}{dt}(t_n)(\\Delta t)^3 + O((\\Delta t)^4) $$\n$$ \\mathbf{r}(t_{n-1}) = \\mathbf{r}(t_n) - \\mathbf{v}(t_n)\\Delta t + \\frac{1}{2}\\mathbf{a}(t_n)(\\Delta t)^2 - \\frac{1}{6}\\frac{d\\mathbf{a}}{dt}(t_n)(\\Delta t)^3 + O((\\Delta t)^4) $$\nLet $\\mathbf{r}_n = \\mathbf{r}(t_n)$, $\\mathbf{v}_n = \\mathbf{v}(t_n)$, and $\\mathbf{a}_n = \\mathbf{a}(\\mathbf{r}_n)$.\n\n**1. Derivation of the Position Verlet Integrator**\n\nAdding the two Taylor expansions yields:\n$$ \\mathbf{r}_{n+1} + \\mathbf{r}_{n-1} = 2\\mathbf{r}_n + \\mathbf{a}_n(\\Delta t)^2 + O((\\Delta t)^4) $$\nRearranging for $\\mathbf{r}_{n+1}$ gives the position Verlet (or StÃ¶rmer-Verlet) update rule:\n$$ \\mathbf{r}_{n+1} = 2\\mathbf{r}_n - \\mathbf{r}_{n-1} + \\mathbf{a}(\\mathbf{r}_n)(\\Delta t)^2 $$\nThis is a three-term recurrence relation for the position. The local error is $O((\\Delta t)^4)$, which leads to a global error of $O((\\Delta t)^2)$. The method is explicitly time-reversible.\n\nThis is a one-step method in form, but it requires two previous position values, $\\mathbf{r}_n$ and $\\mathbf{r}_{n-1}$. To initiate the simulation, we are given $\\mathbf{r}_0$ and $\\mathbf{v}_0$. The required first step, $\\mathbf{r}_{-1}$, is not given. We construct it using the Taylor expansion for $\\mathbf{r}(t_0 - \\Delta t)$:\n$$ \\mathbf{r}_{-1} \\approx \\mathbf{r}_0 - \\mathbf{v}_0 \\Delta t + \\frac{1}{2}\\mathbf{a}_0 (\\Delta t)^2 $$\nwhere $\\mathbf{a}_0 = \\mathbf{a}(\\mathbf{r}_0)$.\n\nThe velocity $\\mathbf{v}_n$ is not explicitly part of the integration state. To compute the kinetic energy $T = \\frac{1}{2}m\\|\\mathbf{v}\\|^2$, we require the velocity. Subtracting the two Taylor expansions provides a second-order accurate, centered finite-difference approximation for the velocity at time $t_n$:\n$$ \\mathbf{v}_n = \\frac{\\mathbf{r}_{n+1} - \\mathbf{r}_{n-1}}{2\\Delta t} + O((\\Delta t)^2) $$\nThe problem correctly mandates the use of this formula for energy calculations.\n\n**2. Derivation of the Velocity Verlet Integrator**\n\nThe velocity Verlet algorithm updates both position and velocity in a synchronized manner. We begin with the Taylor expansion for $\\mathbf{r}_{n+1}$:\n$$ \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n\\Delta t + \\frac{1}{2}\\mathbf{a}_n(\\Delta t)^2 + O((\\Delta t)^3) $$\nThis provides the position update rule. Next, we require an update for $\\mathbf{v}_{n+1}$. A simple forward Euler step would be first-order. To achieve second-order accuracy, we approximate the change in velocity using the average of the accelerations at the beginning and end of the time step:\n$$ \\mathbf{v}_{n+1} \\approx \\mathbf{v}_n + \\frac{\\mathbf{a}_n + \\mathbf{a}_{n+1}}{2}\\Delta t $$\nHere, $\\mathbf{a}_{n+1} = \\mathbf{a}(\\mathbf{r}_{n+1})$ is the acceleration at the newly computed position. This constitutes the velocity update rule. The complete velocity Verlet algorithm is a two-stage process:\n1. Update position: $\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n\\Delta t + \\frac{1}{2}\\mathbf{a}_n(\\Delta t)^2$\n2. Compute intermediate acceleration: $\\mathbf{a}_{n+1} = \\mathbf{a}(\\mathbf{r}_{n+1})$\n3. Update velocity: $\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{1}{2}(\\mathbf{a}_n + \\mathbf{a}_{n+1})\\Delta t$\n\nThis algorithm is also time-reversible, symplectic, and second-order accurate. It has the advantage over position Verlet that velocity is explicitly available at each full time step, simplifying analysis and diagnostics such as energy calculation.\n\n**3. Simulation Setup and Analysis**\n\nThe system is non-dimensionalized with $\\mu=1$, $m=1$, and the semi-major axis $a=1$. The initial conditions for an elliptical orbit of eccentricity $e$ are specified at periapsis, where the particle is at its closest approach to the central mass and its velocity is maximal and purely tangential.\n- Initial position: $\\mathbf{r}_0 = (a(1-e), 0)$\n- Initial velocity: $\\mathbf{v}_0 = (0, \\sqrt{\\mu(1+e)/(a(1-e))})$\n\nThe total energy of the system is the sum of kinetic and potential energies:\n$$ E = T + U = \\frac{1}{2}m\\|\\mathbf{v}\\|^2 - \\frac{\\mu m}{\\|\\mathbf{r}\\|} $$\nFor a Keplerian orbit, the analytical total energy is constant and given by $E = -\\frac{\\mu m}{2a}$. For the parameters specified ($\\mu=1, m=1, a=1$), the exact energy is $E = -0.5$.\n\nThe long-term energy drift is quantified by simulating the system for $N$ steps with a time step $\\Delta t$, recording the total energy $E_n$ at each time $t_n = n\\Delta t$. A linear model $E(t) \\approx s t + b$ is fitted to the time series of energy values using the method of least squares. The absolute value of the slope, $|s|$, is taken as the measure of energy drift per unit time.\n\nThe implementation will consist of two distinct functions, one for each integrator, which simulate the trajectory for the specified number of steps. A main routine will iterate through the given test cases, execute both simulations for each case, compute the respective energy drifts, and report the results in the specified format. The linear regression will be performed using standard numerical library functions.\nFor the position Verlet integrator, the simulation must be run for $N+1$ steps to generate positions up to $\\mathbf{r}_{N+1}$, which is required to compute the velocity $\\mathbf{v}_N$ using the centered-difference formula and thus the energy $E_N$. The energy will be calculated at $N+1$ time points from $t_0$ to $t_N$. The velocity Verlet simulation of $N$ steps naturally yields $N+1$ states from $(\\mathbf{r}_0, \\mathbf{v}_0)$ to $(\\mathbf{r}_N, \\mathbf{v}_N)$, allowing for energy calculation at the same $N+1$ time points. This ensures a consistent comparison.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants from the problem statement\nMU = 1.0\nM = 1.0\n\ndef get_initial_conditions(e, a=1.0, mu=MU):\n    \"\"\"\n    Computes initial position and velocity at periapsis for a Keplerian orbit.\n    \"\"\"\n    if e >= 1.0 or e  0.0:\n        raise ValueError(\"Eccentricity e must be in [0, 1).\")\n    if a = 0.0:\n        raise ValueError(\"Semi-major axis a must be positive.\")\n        \n    # Periapsis radius\n    r_p = a * (1.0 - e)\n    \n    # Periapsis speed\n    v_p = np.sqrt(mu * (1.0 + e) / (a * (1.0 - e)))\n    \n    # Initial position and velocity vectors\n    r0 = np.array([r_p, 0.0])\n    v0 = np.array([0.0, v_p])\n    \n    return r0, v0\n\ndef acceleration(r, mu=MU):\n    \"\"\"\n    Computes the gravitational acceleration vector.\n    a(r) = -mu * r / ||r||^3\n    \"\"\"\n    norm_r = np.linalg.norm(r)\n    if norm_r == 0:\n        raise ValueError(\"Position vector cannot be zero.\")\n    return -mu * r / (norm_r**3)\n\ndef total_energy(r, v, m=M, mu=MU):\n    \"\"\"\n    Computes the total energy (kinetic + potential) of the particle.\n    \"\"\"\n    kinetic_energy = 0.5 * m * np.dot(v, v)\n    potential_energy = -mu * m / np.linalg.norm(r)\n    return kinetic_energy + potential_energy\n\ndef run_position_verlet(e, dt, N, a=1.0, m=M, mu=MU):\n    \"\"\"\n    Simulates the two-body problem using the Position Verlet integrator\n    and calculates the energy drift.\n    \"\"\"\n    # 1. Initial conditions and startup\n    r0, v0 = get_initial_conditions(e, a, mu)\n    a0 = acceleration(r0, mu)\n    \n    # Compute r_{-1} to kickstart the integrator\n    r_minus_1 = r0 - v0 * dt + 0.5 * a0 * dt**2\n    \n    # Store all positions from r_{-1} to r_{N+1}\n    # We need r_{N+1} to compute v_N for the final energy E_N.\n    # Total positions: r_{-1}, r_0, ..., r_N, r_{N+1} (N+3 points)\n    positions = np.zeros((N + 3, 2))\n    positions[0] = r_minus_1\n    positions[1] = r0\n    \n    # 2. Main integration loop\n    for n in range(1, N + 2):\n        # n corresponds to the time index for pos[n]\n        # We compute pos[n+1] from pos[n] and pos[n-1]\n        r_curr = positions[n]\n        r_prev = positions[n-1]\n        a_curr = acceleration(r_curr, mu)\n        r_next = 2.0 * r_curr - r_prev + a_curr * dt**2\n        positions[n + 1] = r_next\n        \n    # 3. Calculate energies at each step\n    energies = np.zeros(N + 1)\n    times = np.arange(N + 1) * dt\n    \n    for n in range(N + 1):\n        # We want to compute E_n = E(r_n, v_n)\n        r_n = positions[n + 1]  # r_n is at index n+1\n        \n        # v_n = (r_{n+1} - r_{n-1}) / (2*dt)\n        r_n_plus_1 = positions[n + 2]\n        r_n_minus_1 = positions[n]\n        v_n = (r_n_plus_1 - r_n_minus_1) / (2.0 * dt)\n        \n        energies[n] = total_energy(r_n, v_n, m, mu)\n        \n    # 4. Compute energy drift via linear regression\n    slope, _ = np.polyfit(times, energies, 1)\n    return np.abs(slope)\n\ndef run_velocity_verlet(e, dt, N, a=1.0, m=M, mu=MU):\n    \"\"\"\n    Simulates the two-body problem using the Velocity Verlet integrator\n    and calculates the energy drift.\n    \"\"\"\n    # 1. Initial conditions\n    r, v = get_initial_conditions(e, a, mu)\n    a_curr = acceleration(r, mu)\n    \n    energies = np.zeros(N + 1)\n    times = np.arange(N + 1) * dt\n    \n    energies[0] = total_energy(r, v, m, mu)\n    \n    # 2. Main integration loop\n    for n in range(N):\n        # Update position\n        r_next = r + v * dt + 0.5 * a_curr * dt**2\n        \n        # Update acceleration\n        a_next = acceleration(r_next, mu)\n        \n        # Update velocity\n        v_next = v + 0.5 * (a_curr + a_next) * dt\n        \n        # Update state for next iteration\n        r, v, a_curr = r_next, v_next, a_next\n        \n        # 3. Calculate and store energy\n        energies[n + 1] = total_energy(r, v, m, mu)\n        \n    # 4. Compute energy drift via linear regression\n    slope, _ = np.polyfit(times, energies, 1)\n    return np.abs(slope)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (e, dt, N)\n        (0.9, 0.0015, 40000),  # Case 1\n        (0.9, 0.003, 40000),   # Case 2\n        (0.0, 0.01, 40000),    # Case 3\n    ]\n\n    results = []\n    for e, dt, N in test_cases:\n        # Calculate drift for Position Verlet\n        drift_pv = run_position_verlet(e, dt, N)\n        results.append(drift_pv)\n        \n        # Calculate drift for Velocity Verlet\n        drift_vv = run_velocity_verlet(e, dt, N)\n        results.append(drift_vv)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2414503"}, {"introduction": "While Verlet integration excels at conserving energy in ideal systems, many physical phenomena involve dissipative forces like friction. This practice extends the Verlet framework to non-conservative systems by tasking you with deriving and implementing an integrator for a damped harmonic oscillator [@problem_id:2414487]. This exercise demonstrates the algorithm's adaptability and provides a conceptual bridge to understanding how thermostats, which control temperature by adding or removing energy, are implemented in large-scale molecular dynamics simulations.", "problem": "Consider a single point particle of mass $m$ moving along a line under a harmonic potential $U(x) = \\tfrac{1}{2} k x^2$ and a linear drag force $F_{\\text{drag}} = - \\gamma v$. The total force is $F(x,v) = -k x - \\gamma v$. The motion is governed by Newton's second law $m \\ddot{x}(t) = F\\big(x(t), \\dot{x}(t)\\big)$. The mechanical energy is $E(t) = \\tfrac{1}{2} m \\, v(t)^2 + \\tfrac{1}{2} k \\, x(t)^2$. Use nondimensional units for all quantities.\n\nYour task is to derive from first principles a discrete-time update map $\\big(x_n, v_n\\big) \\mapsto \\big(x_{n+1}, v_{n+1}\\big)$ with a uniform time step $\\Delta t$ that is consistent with the given dynamics, reduces to the standard Verlet family of schemes when $\\gamma \\to 0$, and advances the system through time levels $t_n = n \\, \\Delta t$ for $n \\in \\{0,1,2,\\dots\\}$. Implement this update to simulate the system for the parameter sets listed below. The initial conditions are $x(0) = x_0$ and $v(0) = v_0$, which define $x_0 = x_{n=0}$ and $v_0 = v_{n=0}$.\n\nFor each simulation, compute the discrete mechanical energy $E_n = \\tfrac{1}{2} m \\, v_n^2 + \\tfrac{1}{2} k \\, x_n^2$ and evaluate the requested quantitative metric. All outputs are dimensionless. Angles do not appear. When computing any logarithm, use the natural logarithm.\n\nTest suite and required outputs:\n- Case A (energy dissipation rate estimation): $m = 1$, $k = 1$, $\\gamma = 0.1$, $x_0 = 1$, $v_0 = 0$, $\\Delta t = 0.01$, total time $T = 50$, so that the number of steps is $N = T / \\Delta t$. Form the time series $\\{(t_n, E_n)\\}_{n=0}^{N}$ with $t_n = n \\Delta t$. Perform an unweighted linear least-squares fit of $\\ln E_n$ versus $t_n$ over the subset $n \\ge N_b$ with burn-in $N_b = 200$ to obtain slope $s$. Output the float $|s + \\gamma/m|$.\n- Case B (conservative limit energy drift): $m = 1$, $k = 1$, $\\gamma = 0$, $x_0 = 1$, $v_0 = 0$, $\\Delta t = 0.01$, $T = 50$. Output the float $\\max_{0 \\le n \\le N} \\big|E_n - E_0\\big| / E_0$.\n- Case C (monotonic energy decrease under strong damping): $m = 1$, $k = 1$, $\\gamma = 5$, $x_0 = 1$, $v_0 = 0$, $\\Delta t = 0.001$, $T = 5$. Output the boolean indicating whether $E_{n+1} \\le E_n + \\varepsilon$ holds for all $0 \\le n  N$, with absolute tolerance $\\varepsilon = 10^{-12}$.\n- Case D (numerical stability under coarse time step): $m = 1$, $k = 1$, $\\gamma = 0.5$, $x_0 = 1$, $v_0 = 0$, $\\Delta t = 0.2$, $T = 100$. Output the boolean indicating whether all simulated states remain finite and bounded in magnitude, specifically $\\max_n \\{|x_n|, |v_n|\\}  B$ with $B = 10^3$, and all energies satisfy $E_n \\ge - \\delta$ with $\\delta = 10^{-12}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results for Cases A through D, in order, as a comma-separated list enclosed in square brackets, for example $[a,b,c,d]$, where $a$ and $b$ are floats and $c$ and $d$ are booleans. No other text should be printed.", "solution": "The provided problem statement is subjected to validation and is found to be scientifically grounded, well-posed, and objective. It describes a damped harmonic oscillator, a canonical system in classical mechanics, governed by the second-order linear ordinary differential equation $m \\ddot{x} + \\gamma \\dot{x} + kx = 0$. The task is to derive a suitable numerical integration scheme and apply it to several test cases. All parameters are provided, and the requested metrics are well-defined. The problem is valid.\n\nThe derivation of the discrete-time update map proceeds as follows. The equation of motion is $m \\ddot{x}(t) = -k x(t) - \\gamma \\dot{x}(t)$. Let $a(t) = \\ddot{x}(t)$ be the acceleration, $v(t) = \\dot{x}(t)$ be the velocity, and $x(t)$ be the position. The state of the system at time $t_n = n \\Delta t$ is given by the pair $(x_n, v_n)$. We seek a map $(x_n, v_n) \\mapsto (x_{n+1}, v_{n+1})$.\n\nA standard method for molecular dynamics is the Velocity Verlet algorithm. For a general time-dependent acceleration $a(t)$, its update rules are:\n$$\nx_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2\n$$\n$$\nv_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t\n$$\nIn our system, the acceleration $a(t)$ depends on both position and velocity: $a(t) = \\frac{1}{m}(-k x(t) - \\gamma v(t))$. Therefore, $a_n = \\frac{1}{m}(-k x_n - \\gamma v_n)$ and $a_{n+1} = \\frac{1}{m}(-k x_{n+1} - \\gamma v_{n+1})$.\n\nThe position update is explicit: $x_{n+1}$ can be computed directly from $x_n$ and $v_n$. However, the velocity update becomes implicit because $a_{n+1}$ depends on $v_{n+1}$, the quantity we wish to compute:\n$$\nv_{n+1} = v_n + \\frac{\\Delta t}{2} \\left( a_n + \\frac{-k x_{n+1} - \\gamma v_{n+1}}{m} \\right)\n$$\nThis equation can be rearranged to solve for $v_{n+1}$:\n$$\nv_{n+1} = v_n + \\frac{\\Delta t}{2} a_n - \\frac{k \\Delta t}{2m} x_{n+1} - \\frac{\\gamma \\Delta t}{2m} v_{n+1}\n$$\n$$\nv_{n+1} \\left(1 + \\frac{\\gamma \\Delta t}{2m}\\right) = v_n + \\frac{\\Delta t}{2} \\left( a_n - \\frac{k}{m} x_{n+1} \\right)\n$$\nSince the dependence is linear, we can find an explicit expression for $v_{n+1}$:\n$$\nv_{n+1} = \\left(1 + \\frac{\\gamma \\Delta t}{2m}\\right)^{-1} \\left[ v_n + \\frac{\\Delta t}{2} \\left( \\frac{-k x_n - \\gamma v_n}{m} - \\frac{k x_{n+1}}{m} \\right) \\right]\n$$\nThis can be simplified by regrouping terms involving $v_n$:\n$$\nv_{n+1} = \\left(1 + \\frac{\\gamma \\Delta t}{2m}\\right)^{-1} \\left[ v_n \\left(1 - \\frac{\\gamma \\Delta t}{2m}\\right) - \\frac{k \\Delta t}{2m} (x_n + x_{n+1}) \\right]\n$$\nThis scheme, often known as the BrÃ¼nger-Brooks-Karplus (BBK) integrator, provides a fully explicit update procedure. First, $x_{n+1}$ is calculated from $(x_n, v_n)$. Then, this new position $x_{n+1}$ is used along with $(x_n, v_n)$ to calculate $v_{n+1}$.\n\nWe must verify that this scheme reduces to the standard Velocity Verlet algorithm in the limit $\\gamma \\to 0$. If we set $\\gamma=0$, the equations become:\n$$\nx_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} \\left( \\frac{-k x_n}{m} \\right) \\Delta t^2 = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2\n$$\n$$\nv_{n+1} = (1+0)^{-1} \\left[ v_n(1-0) - \\frac{k \\Delta t}{2m}(x_n + x_{n+1}) \\right] = v_n + \\frac{\\Delta t}{2} \\left( \\frac{-k x_n}{m} + \\frac{-k x_{n+1}}{m} \\right) = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t\n$$\nThese are precisely the equations for Velocity Verlet in a conservative field with force $F(x) = -kx$. Thus, the derived integrator satisfies all the problem's requirements.\n\nThe simulation algorithm is as follows:\nGiven initial conditions $(x_0, v_0)$ and parameters $m, k, \\gamma, \\Delta t, T$. The number of steps is $N = \\text{round}(T/\\Delta t)$.\nInitialize arrays for position $x$, velocity $v$, and energy $E$ of size $N+1$. Set $x[0]=x_0, v[0]=v_0$.\nFor $n$ from $0$ to $N-1$:\n$1$. Compute the next position $x_{n+1}$:\n   $$\n   x_{n+1} = x_n + v_n \\Delta t + \\frac{\\Delta t^2}{2m}(-k x_n - \\gamma v_n)\n   $$\n$2$. Compute the next velocity $v_{n+1}$:\n   $$\n   c = \\frac{\\gamma \\Delta t}{2m}\n   $$\n   $$\n   v_{n+1} = \\frac{1}{1+c} \\left[ v_n(1-c) - \\frac{k \\Delta t}{2m}(x_n + x_{n+1}) \\right]\n   $$\n$3$. Store $x_{n+1}$ and $v_{n+1}$ in the arrays.\nAfter the loop, compute the energy time series $E_n = \\frac{1}{2} m v_n^2 + \\frac{1}{2} k x_n^2$ for all $n \\in \\{0, 1, \\dots, N\\}$.\nThis procedure is applied to each of the four test cases specified.\n\nFor Case A, an unweighted linear least-squares fit of $\\ln E_n$ vs $t_n$ is performed for $n \\geq N_b=200$. The slope $s$ is obtained. The analytical decay of energy for small damping is approximately $E(t) \\approx E_0 e^{-(\\gamma/m) t}$, implying $\\ln E(t) \\approx \\ln E_0 - (\\gamma/m)t$. We thus expect the slope $s$ to be close to $-\\gamma/m$. The metric is $|s + \\gamma/m|$.\n\nFor Case B, the system is conservative ($\\gamma = 0$), so energy should be conserved. The metric is the maximum relative deviation of energy from its initial value, $\\max_n |E_n - E_0|/E_0$.\n\nFor Case C, the system is strongly damped. Analytically, energy must be a non-increasing function of time since $\\frac{dE}{dt} = -\\gamma v^2 \\le 0$. The metric checks if $E_{n+1} \\le E_n + \\varepsilon$ for all steps, verifying that the numerical scheme preserves this property up to a small floating-point tolerance $\\varepsilon = 10^{-12}$.\n\nFor Case D, the stability of the integrator is tested with a large time step. The metric verifies that the trajectory remains bounded (i.e., $|x_n|, |v_n|  B = 10^3$) and that the energy remains non-negative (i.e., $E_n \\ge -\\delta = -10^{-12}$), which confirms the absence of numerical explosion or unphysical behavior.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    def simulate(m, k, gamma, x0, v0, dt, T):\n        \"\"\"\n        Simulates the damped harmonic oscillator using the derived integrator.\n        \n        Args:\n            m (float): Mass of the particle.\n            k (float): Spring constant.\n            gamma (float): Damping coefficient.\n            x0 (float): Initial position.\n            v0 (float): Initial velocity.\n            dt (float): Time step.\n            T (float): Total simulation time.\n            \n        Returns:\n            tuple: A tuple containing arrays for time, position, velocity, and energy.\n        \"\"\"\n        num_steps = int(round(T / dt))\n        ts = np.linspace(0, T, num_steps + 1)\n        xs = np.zeros(num_steps + 1)\n        vs = np.zeros(num_steps + 1)\n        \n        xs[0] = x0\n        vs[0] = v0\n\n        # Precompute constants for the loop\n        c = (gamma * dt) / (2.0 * m)\n        k_dt_2m = (k * dt) / (2.0 * m)\n\n        for n in range(num_steps):\n            # Current state\n            x_n, v_n = xs[n], vs[n]\n            \n            # 1. Update position\n            a_n = (-k * x_n - gamma * v_n) / m\n            x_n_plus_1 = x_n + v_n * dt + 0.5 * a_n * dt**2\n            \n            # 2. Update velocity\n            # The derived formula:\n            # v_{n+1} = (1/(1+c)) * [v_n*(1-c) - (k*dt/(2*m))*(x_n + x_{n+1})]\n            v_n_plus_1 = (1.0 / (1.0 + c)) * (v_n * (1.0 - c) - k_dt_2m * (x_n + x_n_plus_1))\n            \n            xs[n + 1] = x_n_plus_1\n            vs[n + 1] = v_n_plus_1\n            \n        Es = 0.5 * m * vs**2 + 0.5 * k * xs**2\n        return ts, xs, vs, Es\n\n    # --- Test Cases ---\n    test_cases = [\n        {'m': 1.0, 'k': 1.0, 'gamma': 0.1, 'x0': 1.0, 'v0': 0.0, 'dt': 0.01, 'T': 50.0}, # Case A\n        {'m': 1.0, 'k': 1.0, 'gamma': 0.0, 'x0': 1.0, 'v0': 0.0, 'dt': 0.01, 'T': 50.0}, # Case B\n        {'m': 1.0, 'k': 1.0, 'gamma': 5.0, 'x0': 1.0, 'v0': 0.0, 'dt': 0.001, 'T': 5.0}, # Case C\n        {'m': 1.0, 'k': 1.0, 'gamma': 0.5, 'x0': 1.0, 'v0': 0.0, 'dt': 0.2, 'T': 100.0} # Case D\n    ]\n    \n    results = []\n\n    # Case A: Energy dissipation rate estimation\n    pA = test_cases[0]\n    ts_A, _, _, Es_A = simulate(**pA)\n    N_b = 200\n    # Filter out any non-positive energies before taking the log to avoid warnings/errors\n    valid_indices = (Es_A[N_b:] > 0)\n    t_fit = ts_A[N_b:][valid_indices]\n    log_E_fit = np.log(Es_A[N_b:][valid_indices])\n    \n    # Perform linear least-squares fit (slope is the first element of the result)\n    if len(t_fit) > 1:\n        slope_s = np.polyfit(t_fit, log_E_fit, 1)[0]\n        result_A = abs(slope_s + pA['gamma'] / pA['m'])\n    else: # Handle case where no data is available for fit\n        result_A = np.nan\n    results.append(result_A)\n\n    # Case B: Conservative limit energy drift\n    pB = test_cases[1]\n    _, _, _, Es_B = simulate(**pB)\n    E0_B = Es_B[0]\n    if E0_B > 0:\n        result_B = np.max(np.abs(Es_B - E0_B)) / E0_B\n    else: # Avoid division by zero if initial energy is zero\n        result_B = 0.0 if np.all(Es_B == 0) else np.nan\n    results.append(result_B)\n\n    # Case C: Monotonic energy decrease under strong damping\n    pC = test_cases[2]\n    _, _, _, Es_C = simulate(**pC)\n    epsilon_C = 1e-12\n    result_C = np.all(Es_C[1:] = Es_C[:-1] + epsilon_C)\n    results.append(result_C)\n\n    # Case D: Numerical stability under coarse time step\n    pD = test_cases[3]\n    _, xs_D, vs_D, Es_D = simulate(**pD)\n    bound_B = 1e3\n    delta_D = 1e-12\n    is_bounded = np.max(np.abs(xs_D))  bound_B and np.max(np.abs(vs_D))  bound_B\n    is_energy_physical = np.all(Es_D >= -delta_D)\n    result_D = is_bounded and is_energy_physical\n    results.append(result_D)\n    \n    # Final print statement in the exact required format.\n    # We must explicitly convert booleans to lowercase 'true'/'false' as per common conventions\n    # although standard str() in Python would give 'True'/'False'. The problem is ambiguous.\n    # Assuming standard Python string conversion for bools.\n    results_str = [str(r).lower() if isinstance(r, bool) else f\"{r:.6g}\" for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\n\nsolve()\n```", "id": "2414487"}]}