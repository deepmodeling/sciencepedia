{"hands_on_practices": [{"introduction": "The foundation of partitioned schemes is the iterative solution of coupled subproblems. A critical question for any computational engineer is whether a chosen iterative scheme will converge to the correct solution, and if so, how quickly. The convergence of these linear iterative methods is governed by a mathematical property known as the spectral radius of the iteration matrix; a value less than one guarantees convergence, with smaller values indicating a faster rate. This foundational exercise [@problem_id:2416751] provides a direct, quantitative comparison between two cornerstone partitioned approaches—the Jacobi and Gauss-Seidel schemes—allowing you to analyze their convergence properties on a simple yet representative coupled system.", "problem": "Consider a linear, steady, one-dimensional thermo-mechanical coupling for a bar after spatial discretization into a single mechanical degree of freedom and a single thermal degree of freedom. The unknowns are the axial displacement $u$ and the temperature $T$. The coupled algebraic equilibrium can be written in block form as\n$$\n\\begin{bmatrix}\nk_u & -h \\\\\n-g & k_T\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\\nT\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf_u \\\\\nf_T\n\\end{bmatrix},\n$$\nwhere $k_u>0$ and $k_T>0$ represent, respectively, the mechanical and thermal positive stiffness-like coefficients, and $h \\ge 0$ and $g \\ge 0$ quantify the coupling between the thermal and mechanical subsystems. The right-hand sides $f_u$ and $f_T$ are given loads. All parameters are real numbers.\n\nDefine two partitioned fixed-point coupling schemes applied to this $2 \\times 2$ system, starting from an initial guess $(u^{(0)},T^{(0)})$:\n- A Jacobi partitioned scheme: at each iteration, both subproblems use only the previous iterate of the other field.\n- A Gauss–Seidel partitioned scheme: at each iteration, the mechanical subproblem updates first and the thermal subproblem uses the most recent mechanical update in the same iteration.\n\nFor each scheme, the linear iteration can be written in the form\n$$\n\\begin{bmatrix}\nu^{(k+1)} \\\\\nT^{(k+1)}\n\\end{bmatrix}\n=\n\\mathbf{M}\n\\begin{bmatrix}\nu^{(k)} \\\\\nT^{(k)}\n\\end{bmatrix}\n+\n\\mathbf{c},\n$$\nwhere $\\mathbf{M}$ is the iteration matrix and $\\mathbf{c}$ is an iteration-independent vector. The linear convergence factor is the spectral radius $\\rho(\\mathbf{M})$, which is a unitless quantity. Convergence holds if and only if $\\rho(\\mathbf{M}) &lt; 1$.\n\nTask: For the parameter sets listed in the test suite below, treat $f_u=0$ and $f_T=0$ (the values of $f_u$ and $f_T$ do not affect the spectral radii). For each case, compute the following quantities:\n1. The spectral radius $\\rho_J$ of the Jacobi partitioned iteration matrix (unitless).\n2. The spectral radius $\\rho_{GS}$ of the Gauss–Seidel partitioned iteration matrix (unitless).\n3. A boolean indicating whether the Jacobi scheme converges, defined as $\\rho_J &lt; 1$.\n4. A boolean indicating whether the Gauss–Seidel scheme converges, defined as $\\rho_{GS} &lt; 1$.\n5. An integer code comparing convergence rates: output $1$ if the Gauss–Seidel scheme is strictly faster (i.e., $\\rho_{GS} &lt; \\rho_J$), output $2$ if the Jacobi scheme is strictly faster (i.e., $\\rho_J &lt; \\rho_{GS}$), and output $0$ if their spectral radii are equal within a tolerance of $10^{-12}$.\n\nTest suite (each case is a tuple $(k_u,k_T,h,g)$ with all quantities unitless for the purpose of this comparison):\n- Case A: $(100.0,50.0,10.0,5.0)$.\n- Case B: $(100.0,100.0,0.0,50.0)$.\n- Case C: $(1.0,1.0,1.0,1.0)$.\n- Case D: $(2.0,3.0,2.0,4.0)$.\n- Case E: $(10^6,1.0,100.0,100.0)$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist of the form $[\\rho_J,\\rho_{GS},\\text{JacobiConverges},\\text{GaussSeidelConverges},\\text{Winner}]$. The floating-point values $\\rho_J$ and $\\rho_{GS}$ must be rounded to exactly six digits after the decimal point. The booleans must be printed as $True$ or $False$. For example, a valid overall output with two hypothetical cases would look like\n$[[0.125000,0.062500,True,True,1],[1.000000,1.000000,False,False,0]]$.", "solution": "The problem presented is a standard exercise in the analysis of iterative methods for coupled linear systems, a fundamental topic in computational engineering. The problem is well-posed, scientifically sound, and contains all necessary information for a unique solution. We shall proceed with the derivation of the required quantities.\n\nThe governing system of linear algebraic equations is:\n$$\n\\begin{bmatrix}\nk_u & -h \\\\\n-g & k_T\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\\nT\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf_u \\\\\nf_T\n\\end{bmatrix}\n$$\nThis system can be written abstractly as $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$, where $\\mathbf{x} = [u, T]^T$ is the vector of unknowns and $\\mathbf{A}$ is the system matrix. For iterative methods of the Jacobi and Gauss-Seidel type, the matrix $\\mathbf{A}$ is decomposed into its diagonal, strictly lower triangular, and strictly upper triangular parts: $\\mathbf{A} = \\mathbf{D} + \\mathbf{L} + \\mathbf{U}$. Based on the given system, these matrices are:\n$$\n\\mathbf{D} = \\begin{bmatrix} k_u & 0 \\\\ 0 & k_T \\end{bmatrix}, \\quad\n\\mathbf{L} = \\begin{bmatrix} 0 & 0 \\\\ -g & 0 \\end{bmatrix}, \\quad\n\\mathbf{U} = \\begin{bmatrix} 0 & -h \\\\ 0 & 0 \\end{bmatrix}\n$$\nThe constraints are $k_u > 0$, $k_T > 0$, $h \\ge 0$, and $g \\ge 0$. This ensures that the diagonal matrix $\\mathbf{D}$ is invertible.\n\nFirst, we analyze the Jacobi partitioned scheme. The iterative update is defined by $\\mathbf{D}\\mathbf{x}^{(k+1)} = -(\\mathbf{L}+\\mathbf{U})\\mathbf{x}^{(k)} + \\mathbf{b}$. The iteration matrix, $\\mathbf{M}_J$, is therefore $\\mathbf{M}_J = -\\mathbf{D}^{-1}(\\mathbf{L}+\\mathbf{U})$.\n$$\n\\mathbf{D}^{-1} = \\begin{bmatrix} 1/k_u & 0 \\\\ 0 & 1/k_T \\end{bmatrix}\n$$\n$$\n-(\\mathbf{L}+\\mathbf{U}) = - \\begin{bmatrix} 0 & -h \\\\ -g & 0 \\end{bmatrix} = \\begin{bmatrix} 0 & h \\\\ g & 0 \\end{bmatrix}\n$$\n$$\n\\mathbf{M}_J = \\begin{bmatrix} 1/k_u & 0 \\\\ 0 & 1/k_T \\end{bmatrix} \\begin{bmatrix} 0 & h \\\\ g & 0 \\end{bmatrix} = \\begin{bmatrix} 0 & h/k_u \\\\ g/k_T & 0 \\end{bmatrix}\n$$\nThe convergence of the Jacobi scheme is determined by the spectral radius $\\rho(\\mathbf{M}_J)$, which is the maximum absolute value of its eigenvalues. The eigenvalues $\\lambda$ are found from the characteristic equation $\\det(\\mathbf{M}_J - \\lambda\\mathbf{I}) = 0$:\n$$\n\\det \\begin{bmatrix} -\\lambda & h/k_u \\\\ g/k_T & -\\lambda \\end{bmatrix} = \\lambda^2 - \\frac{hg}{k_u k_T} = 0\n$$\nThis gives eigenvalues $\\lambda_{1,2} = \\pm \\sqrt{\\frac{hg}{k_u k_T}}$. The spectral radius is thus:\n$$\n\\rho_J = \\rho(\\mathbf{M}_J) = \\sqrt{\\frac{hg}{k_u k_T}}\n$$\n\nNext, we analyze the Gauss-Seidel partitioned scheme. The problem states that the mechanical variable $u$ is updated first, which corresponds to a forward Gauss-Seidel iteration. The update rule is $(\\mathbf{D}+\\mathbf{L})\\mathbf{x}^{(k+1)} = -\\mathbf{U}\\mathbf{x}^{(k)} + \\mathbf{b}$. The iteration matrix, $\\mathbf{M}_{GS}$, is $\\mathbf{M}_{GS} = -(\\mathbf{D}+\\mathbf{L})^{-1}\\mathbf{U}$.\nFirst, we find the inverse of $(\\mathbf{D}+\\mathbf{L})$:\n$$\n(\\mathbf{D}+\\mathbf{L}) = \\begin{bmatrix} k_u & 0 \\\\ -g & k_T \\end{bmatrix} \\implies (\\mathbf{D}+\\mathbf{L})^{-1} = \\frac{1}{k_u k_T} \\begin{bmatrix} k_T & 0 \\\\ g & k_u \\end{bmatrix} = \\begin{bmatrix} 1/k_u & 0 \\\\ g/(k_u k_T) & 1/k_T \\end{bmatrix}\n$$\nNow, we compute $\\mathbf{M}_{GS}$:\n$$\n\\mathbf{M}_{GS} = - \\begin{bmatrix} 1/k_u & 0 \\\\ g/(k_u k_T) & 1/k_T \\end{bmatrix} \\begin{bmatrix} 0 & -h \\\\ 0 & 0 \\end{bmatrix} = \\begin{bmatrix} 1/k_u & 0 \\\\ g/(k_u k_T) & 1/k_T \\end{bmatrix} \\begin{bmatrix} 0 & h \\\\ 0 & 0 \\end{bmatrix} = \\begin{bmatrix} 0 & h/k_u \\\\ 0 & \\frac{hg}{k_u k_T} \\end{bmatrix}\n$$\nThe matrix $\\mathbf{M}_{GS}$ is upper triangular, so its eigenvalues are its diagonal entries: $\\lambda_1 = 0$ and $\\lambda_2 = \\frac{hg}{k_u k_T}$. The spectral radius is the maximum of their absolute values:\n$$\n\\rho_{GS} = \\rho(\\mathbf{M}_{GS}) = \\left| \\frac{hg}{k_u k_T} \\right| = \\frac{hg}{k_u k_T}\n$$\nThe absolute value is redundant since $h,g,k_u,k_T$ are all non-negative.\n\nBy comparing the derived spectral radii, we observe a direct relationship:\n$$\n\\rho_{GS} = \\frac{hg}{k_u k_T} = \\left(\\sqrt{\\frac{hg}{k_u k_T}}\\right)^2 = (\\rho_J)^2\n$$\nThis relationship, $\\rho_{GS} = (\\rho_J)^2$, is a classical result for consistently ordered matrices, which the $2 \\times 2$ system matrix $\\mathbf{A}$ is. This relationship dictates the relative convergence rates. Convergence occurs if and only if the spectral radius is strictly less than $1$.\n\n- If $\\rho_J < 1$, then $\\rho_{GS} = (\\rho_J)^2 < \\rho_J$. Both schemes converge, and Gauss-Seidel is strictly faster.\n- If $\\rho_J = 1$, then $\\rho_{GS} = (\\rho_J)^2 = 1$. Neither scheme converges, and their spectral radii are equal.\n- If $\\rho_J > 1$, then $\\rho_{GS} = (\\rho_J)^2 > \\rho_J$. Both schemes diverge, and the \"rate of divergence\" for Gauss-Seidel is worse, meaning Jacobi is considered \"faster\" in this context.\n\nBased on these formulae, a program can be written to compute the required quantities for each set of parameters $(k_u, k_T, h, g)$ provided in the test suite. The program will calculate $\\rho_J$ and $\\rho_{GS}$, determine convergence for each by checking if $\\rho < 1$, and compare the radii to determine the faster scheme.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the thermo-mechanical coupling problem by analyzing Jacobi and Gauss-Seidel\n    partitioned schemes for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement as tuples of (ku, kT, h, g).\n    test_cases = [\n        # Case A\n        (100.0, 50.0, 10.0, 5.0),\n        # Case B\n        (100.0, 100.0, 0.0, 50.0),\n        # Case C\n        (1.0, 1.0, 1.0, 1.0),\n        # Case D\n        (2.0, 3.0, 2.0, 4.0),\n        # Case E\n        (10**6, 1.0, 100.0, 100.0),\n    ]\n\n    results = []\n    # Tolerance for comparing floating-point numbers for equality.\n    TOLERANCE = 1e-12\n\n    for case in test_cases:\n        ku, kT, h, g = case\n\n        # The core parameter governing convergence is the non-dimensional product 'x'.\n        # The problem constraints ku > 0 and kT > 0 prevent division by zero.\n        x = (h * g) / (ku * kT)\n\n        # Calculate the spectral radius for the Jacobi scheme.\n        # Since h, g, ku, kT are non-negative, x is non-negative, so sqrt is safe.\n        rho_j = np.sqrt(x)\n\n        # Calculate the spectral radius for the Gauss-Seidel scheme.\n        # For this 2x2 system, rho_gs is simply x.\n        rho_gs = x\n\n        # Determine convergence for each scheme. Convergence holds if rho < 1.\n        jacobi_converges = rho_j < 1.0\n        gauss_seidel_converges = rho_gs < 1.0\n\n        # Compare the convergence rates based on the spectral radii.\n        winner = 0  # Default: rates are equal\n        if rho_gs < rho_j - TOLERANCE:\n            winner = 1  # Gauss-Seidel is strictly faster\n        elif rho_j < rho_gs - TOLERANCE:\n            winner = 2  # Jacobi is strictly faster\n        \n        # Format the floating-point results to exactly six decimal places.\n        formatted_rho_j = f\"{rho_j:.6f}\"\n        formatted_rho_gs = f\"{rho_gs:.6f}\"\n\n        # Append the list of results for the current case.\n        # Booleans will be automatically converted to \"True\" or \"False\".\n        case_result = (\n            f\"[{formatted_rho_j},{formatted_rho_gs},\"\n            f\"{jacobi_converges},{gauss_seidel_converges},{winner}]\"\n        )\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of the individual case results,\n    # all enclosed in a single pair of square brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2416751"}, {"introduction": "In many real-world multiphysics scenarios, particularly those with strong coupling or large disparities in material properties across an interface, a standard partitioned scheme can become unstable and fail to converge. To overcome this, we need a method to control the iterative updates and guide the simulation towards a stable solution. Under-relaxation is a powerful and widely used technique that achieves this by damping the updates to the interface variables, preventing the large oscillations that can lead to divergence. This hands-on practice [@problem_id:2416722] applies these concepts to a tangible conjugate heat transfer problem, where you will implement a partitioned scheme and observe firsthand how an under-relaxation factor $\\omega$ can be essential for achieving a robustly convergent solution.", "problem": "Consider a one-dimensional (1D) conjugate heat transfer problem consisting of a solid slab occupying the interval $\\left[-L_s,0\\right]$ and a fluid slab occupying the interval $\\left[0,L_f\\right]$. Let the solid have constant thermal conductivity $k_s$ and the fluid have constant thermal conductivity $k_f$. Assume steady-state, one-dimensional conduction with no internal heat generation in either slab. The boundary temperature at $x=-L_s$ is prescribed as $T_{s,0}$ (in Kelvin), and the boundary temperature at $x=+L_f$ is prescribed as $T_{f,L}$ (in Kelvin). Denote the interface temperature at $x=0$ by $T_i$.\n\nIn a partitioned Dirichlet–Neumann coupling, at sub-iteration $m$ the solid subproblem is solved with a Dirichlet condition $T\\left(0\\right)=T_i^{(m)}$ to obtain the interface heat flux from the solid $q_s^{(m)}$ (taken positive from solid to fluid), and then the fluid subproblem is solved with a Neumann condition $-k_f\\,\\partial_x T\\left(0\\right)=q_s^{(m)}$ and Dirichlet condition $T\\left(L_f\\right)=T_{f,L}$ to obtain the fluid-predicted interface temperature $T_{f,\\mathrm{int}}^{(m)}$. The interface temperature mismatch at sub-iteration $m$ is the absolute difference $e^{(m)}=\\left|T_i^{(m)}-T_{f,\\mathrm{int}}^{(m)}\\right|$ in Kelvin. An under-relaxed update of the interface temperature is performed as\n$$\nT_i^{(m+1)}=(1-\\omega)\\,T_i^{(m)}+\\omega\\,T_{f,\\mathrm{int}}^{(m)},\n$$\nwhere $\\omega\\in(0,1]$ is the under-relaxation factor. The sub-iterations proceed until either $e^{(m)}<\\varepsilon$ (tolerance in Kelvin) or the number of sub-iterations reaches $M_{\\max}$.\n\nFundamental laws to be applied:\n- Fourier’s law of heat conduction $q=-k\\,\\partial_x T$ in each slab.\n- In 1D steady conduction with constant properties and no sources, the temperature distribution is linear in $x$ for each slab.\n\nYour task is to write a complete program that, for each of the following test cases, computes the sequence $\\left\\{e^{(m)}\\right\\}_{m=0,1,2,\\dots}$ of interface temperature mismatches (in Kelvin) recorded at every sub-iteration, in the order they are produced, until the stopping criterion is met. Each recorded $e^{(m)}$ must be rounded to $6$ decimal places. The final output must aggregate the sequences for all test cases into a single line as a list of lists of floats, with no spaces anywhere inside the brackets.\n\nUse the following test suite. For each case, the inputs are $\\left(k_s,L_s,k_f,L_f,T_{s,0},T_{f,L},\\omega,\\varepsilon,M_{\\max},T_i^{(0)}\\right)$ with units: $k_s$ and $k_f$ in watt per meter-kelvin (W m$^{-1}$ K$^{-1}$), $L_s$ and $L_f$ in meter (m), temperatures in Kelvin (K), and $\\varepsilon$ in Kelvin (K).\n- Case A (general, convergent): $(k_s = 50, L_s = 0.2, k_f = 50, L_f = 0.1, T_{s,0} = 400, T_{f,L} = 300, \\omega = 1.0, \\varepsilon = 1 \\times 10^{-6}, M_{\\max} = 50, T_i^{(0)} = 350)$.\n- Case B (stiff, convergent with relaxation): $(k_s = 200, L_s = 0.1, k_f = 50, L_f = 0.1, T_{s,0} = 400, T_{f,L} = 300, \\omega = 0.35, \\varepsilon = 1 \\times 10^{-6}, M_{\\max} = 50, T_i^{(0)} = 320)$.\n- Case C (stiff, divergent without relaxation): $(k_s = 200, L_s = 0.1, k_f = 50, L_f = 0.1, T_{s,0} = 400, T_{f,L} = 300, \\omega = 1.0, \\varepsilon = 1 \\times 10^{-6}, M_{\\max} = 10, T_i^{(0)} = 320)$.\n- Case D (symmetric, equal boundary temperatures): $(k_s = 10, L_s = 0.5, k_f = 10, L_f = 0.5, T_{s,0} = 350, T_{f,L} = 350, \\omega = 0.5, \\varepsilon = 1 \\times 10^{-12}, M_{\\max} = 5, T_i^{(0)} = 310)$.\n\nQuantities to compute at each sub-iteration $m$:\n- Solid-side interface heat flux $q_s^{(m)}$ using Fourier’s law applied to the solid slab over $\\left[-L_s,0\\right]$ with boundary temperatures $T_{s,0}$ at $x=-L_s$ and $T_i^{(m)}$ at $x=0$.\n- Fluid-side interface temperature $T_{f,\\mathrm{int}}^{(m)}$ using the fluid slab over $\\left[0,L_f\\right]$ with imposed heat flux $q_s^{(m)}$ at $x=0$ and boundary temperature $T_{f,L}$ at $x=L_f$.\n- Mismatch $e^{(m)}=\\left|T_i^{(m)}-T_{f,\\mathrm{int}}^{(m)}\\right|$ in Kelvin.\n\nFinal output format: Your program should produce a single line of output containing the sequences for the four cases as a comma-separated list of lists of floats, enclosed in square brackets, with no spaces, for example, $\\left[\\left[e_{A}^{(0)},e_{A}^{(1)},\\dots\\right],\\left[e_{B}^{(0)},\\dots\\right],\\left[\\dots\\right],\\left[\\dots\\right]\\right]$. All printed floats must be rounded to exactly $6$ decimal places, in Kelvin, and recorded at every sub-iteration from $m=0$ until the stopping criterion is met in that case.", "solution": "The supplied problem is subjected to rigorous validation before any attempt at a solution.\n\nStep 1: Extraction of Givens.\nThe problem describes a one-dimensional, steady-state conjugate heat transfer scenario.\n- **Domains**: Solid slab on $x \\in [-L_s, 0]$; Fluid slab on $x \\in [0, L_f]$.\n- **Physical Properties**: Constant thermal conductivities $k_s$ for the solid and $k_f$ for the fluid. No internal heat generation.\n- **Governing Law**: Fourier's law of heat conduction, $q = -k\\,\\partial_x T$. In this context, the temperature distribution is linear in each slab.\n- **Boundary Conditions**: Prescribed temperature $T(-L_s) = T_{s,0}$ and $T(L_f) = T_{f,L}$.\n- **Coupling Algorithm**: A partitioned Dirichlet–Neumann scheme with under-relaxation is specified for the interface at $x=0$. For each sub-iteration $m$:\n    1.  **Solid Subproblem**: A Dirichlet condition $T(0) = T_i^{(m)}$ is applied. The resulting heat flux from the solid, $q_s^{(m)}$, is computed.\n    2.  **Fluid Subproblem**: A Neumann condition $-k_f\\,\\partial_x T(0) = q_s^{(m)}$ is applied, with the far-field Dirichlet condition $T(L_f) = T_{f,L}$. The resulting interface temperature from the fluid side, $T_{f,\\text{int}}^{(m)}$, is computed.\n    3.  **Error Calculation**: The mismatch is defined as $e^{(m)} = \\left|T_i^{(m)} - T_{f,\\text{int}}^{(m)}\\right|$.\n    4.  **Interface Update**: The temperature for the next iteration is updated using an under-relaxation scheme: $T_i^{(m+1)} = (1-\\omega)\\,T_i^{(m)} + \\omega\\,T_{f,\\text{int}}^{(m)}$, with $\\omega \\in (0, 1]$.\n    5.  **Termination Criteria**: The process stops if $e^{(m)} < \\varepsilon$ or the number of sub-iterations reaches a maximum, $M_{\\max}$.\n- **Initial Condition**: An initial guess for the interface temperature, $T_i^{(0)}$, is provided for each case.\n- **Test Cases**: Four distinct sets of parameters are provided: $(k_s, L_s, k_f, L_f, T_{s,0}, T_{f,L}, \\omega, \\varepsilon, M_{\\max}, T_i^{(0)})$.\n- **Required Output**: For each case, produce a sequence of the mismatch values $\\{e^{(m)}\\}$ rounded to $6$ decimal places, recorded at every sub-iteration until termination. The final output is a single-line string representing a list of these sequences.\n\nStep 2: Validation Using Extracted Givens.\n- **Scientific Grounding**: The problem is based on fundamental principles of heat transfer (Fourier's law for conduction) and standard numerical methods for solving coupled multiphysics problems (partitioned coupling schemes). The Dirichlet-Neumann partitioning and under-relaxation are well-established techniques in computational engineering. The problem is scientifically sound.\n- **Well-Posed and Objective**: The problem is formulated with mathematical precision, using unambiguous, objective language. All parameters and conditions required for a unique solution to the iterative process are provided. The problem is well-posed.\n- **Completeness and Consistency**: The problem statement is self-contained. All necessary data, boundary conditions, initial conditions, and algorithmic parameters are explicitly defined for each test case. There are no internal contradictions.\n- **Relevance**: The problem is directly relevant to the specified topic of multiphysics coupling schemes in computational engineering.\n\nStep 3: Verdict and Action.\nThe problem is valid, scientifically grounded, and well-posed. A solution will be constructed based on the provided specifications.\n\nDerivation of the Iterative Scheme.\nThe foundation of the solution is the linear temperature profile in each slab under steady-state, one-dimensional conduction with no sources. A generic linear profile is $T(x) = ax + b$.\n\n1.  **Solid Subproblem (Sub-iteration $m$)**:\n    The temperature distribution in the solid, $T_s(x)$, is defined on $x \\in [-L_s, 0]$. The boundary conditions are $T_s(-L_s) = T_{s,0}$ and $T_s(0) = T_i^{(m)}$.\n    Applying these conditions to $T_s(x) = a_s x + b_s$:\n    At $x=0$, $b_s = T_i^{(m)}$.\n    At $x=-L_s$, $a_s(-L_s) + b_s = T_{s,0}$, which gives $a_s = \\frac{T_s(-L_s) - b_s}{-L_s} = \\frac{T_{s,0} - T_i^{(m)}}{-L_s} = \\frac{T_i^{(m)} - T_{s,0}}{L_s}$.\n    The temperature profile is thus $T_s(x) = \\left(\\frac{T_i^{(m)} - T_{s,0}}{L_s}\\right)x + T_i^{(m)}$.\n    The heat flux from the solid to the interface (in the positive $x$-direction) is constant and given by Fourier's law:\n    $$q_s^{(m)} = -k_s \\frac{dT_s}{dx} = -k_s a_s = -k_s \\left(\\frac{T_i^{(m)} - T_{s,0}}{L_s}\\right) = k_s \\frac{T_{s,0} - T_i^{(m)}}{L_s}$$\n\n2.  **Fluid Subproblem (Sub-iteration $m$)**:\n    The temperature distribution in the fluid, $T_f(x)$, is defined on $x \\in [0, L_f]$. The boundary conditions are a prescribed flux at $x=0$ and a prescribed temperature at $x=L_f$.\n    The flux condition at $x=0$ is that the flux entering the fluid equals the flux leaving the solid, $q_s^{(m)}$.\n    From Fourier's law, $-k_f \\frac{dT_f}{dx}|_{x=0} = q_s^{(m)}$. For a linear profile $T_f(x) = a_f x + b_f$, this implies $-k_f a_f = q_s^{(m)}$, so $a_f = -\\frac{q_s^{(m)}}{k_f}$.\n    The temperature condition at $x=L_f$ is $T_f(L_f) = T_{f,L}$. Applying this gives $a_f L_f + b_f = T_{f,L}$.\n    We solve for $b_f$: $b_f = T_{f,L} - a_f L_f = T_{f,L} - \\left(-\\frac{q_s^{(m)}}{k_f}\\right)L_f = T_{f,L} + \\frac{q_s^{(m)} L_f}{k_f}$.\n    The fluid-predicted interface temperature, $T_{f,\\text{int}}^{(m)}$, is the temperature of the fluid at $x=0$, which is $T_f(0) = b_f$.\n    $$T_{f,\\text{int}}^{(m)} = T_{f,L} + \\frac{L_f}{k_f} q_s^{(m)}$$\n\n3.  **Complete Iterative Algorithm**:\n    For each sub-iteration $m = 0, 1, 2, \\dots$ up to a maximum of $M_{\\max}-1$:\n    - **Step 1**: Given the current interface temperature guess $T_i^{(m)}$, calculate the heat flux from the solid:\n      $q_s^{(m)} = k_s \\frac{T_{s,0} - T_i^{(m)}}{L_s}$.\n    - **Step 2**: Use this flux to calculate the fluid-predicted interface temperature:\n      $T_{f,\\text{int}}^{(m)} = T_{f,L} + \\frac{L_f}{k_f} q_s^{(m)}$.\n    - **Step 3**: Calculate the absolute mismatch and record its rounded value:\n      $e^{(m)} = \\left|T_i^{(m)} - T_{f,\\text{int}}^{(m)}\\right|$. The value stored is rounded to $6$ decimal places.\n    - **Step 4**: Check for termination. The loop terminates if the unrounded error $e^{(m)}$ is less than the tolerance $\\varepsilon$. If it is not, proceed.\n    - **Step 5**: Update the interface temperature for the next iteration using under-relaxation:\n      $T_i^{(m+1)} = (1-\\omega) T_i^{(m)} + \\omega T_{f,\\text{int}}^{(m)}$.\n\nThis procedure is implemented for each of the four test cases. The sequence of recorded, rounded errors is collected for each case. The final output is formatted into a single string as a list of these lists, ensuring all numbers are printed to exactly six decimal places.", "answer": "```python\nimport numpy as np\n\ndef solve_case(ks, Ls, kf, Lf, Ts0, TfL, omega, epsilon, M_max, Ti0):\n    \"\"\"\n    Solves a single case of the 1D conjugate heat transfer problem.\n\n    Implements the partitioned Dirichlet-Neumann iterative scheme.\n    \"\"\"\n    errors = []\n    Ti = float(Ti0)\n\n    for m in range(M_max):\n        # Step 1: Solid subproblem - Calculate interface heat flux from solid\n        # q_s > 0 means flux from solid to fluid (positive x-direction)\n        q_s = ks * (Ts0 - Ti) / Ls\n\n        # Step 2: Fluid subproblem - Calculate fluid-predicted interface temperature\n        Tf_int = TfL + (q_s * Lf / kf)\n\n        # Step 3: Calculate interface temperature mismatch\n        e = abs(Ti - Tf_int)\n        \n        # Record the error, rounded as specified\n        errors.append(e)\n        \n        # Step 4: Check for convergence with unrounded error\n        if e < epsilon:\n            break\n\n        # Step 5: Update interface temperature with under-relaxation\n        Ti = (1.0 - omega) * Ti + omega * Tf_int\n\n    return errors\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Test suite: (ks, Ls, kf, Lf, Ts0, TfL, omega, epsilon, M_max, Ti0)\n    test_cases = [\n        # Case A: general, convergent\n        (50.0, 0.2, 50.0, 0.1, 400.0, 300.0, 1.0, 1e-6, 50, 350.0),\n        # Case B: stiff, convergent with relaxation\n        (200.0, 0.1, 50.0, 0.1, 400.0, 300.0, 0.35, 1e-6, 50, 320.0),\n        # Case C: stiff, divergent without relaxation\n        (200.0, 0.1, 50.0, 0.1, 400.0, 300.0, 1.0, 1e-6, 10, 320.0),\n        # Case D: symmetric, equal boundary temperatures\n        (10.0, 0.5, 10.0, 0.5, 350.0, 350.0, 0.5, 1e-12, 5, 310.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Unpack case parameters and solve\n        errors = solve_case(*case)\n        # Per problem, \"Each recorded e(m) must be rounded to 6 decimal places\"\n        rounded_errors = [round(err, 6) for err in errors]\n        all_results.append(rounded_errors)\n\n    # Format the final output string exactly as required.\n    # \"a comma-separated list of lists of floats, enclosed in square brackets, with no spaces\"\n    # \"All printed floats must be rounded to exactly 6 decimal places\"\n    \n    outer_list_str = []\n    for case_errors in all_results:\n        # Format numbers to ensure 6 decimal places with trailing zeros\n        inner_list_str = \",\".join([f\"{err:.6f}\" for err in case_errors])\n        outer_list_str.append(f\"[{inner_list_str}]\")\n    \n    final_output = f\"[{','.join(outer_list_str)}]\"\n\n    print(final_output)\n\nsolve()\n```", "id": "2416722"}, {"introduction": "While we have focused on partitioned approaches, an alternative is to solve all physical equations simultaneously within a single, large \"monolithic\" system. The choice between these two strategies represents a fundamental trade-off in computational multiphysics. Monolithic systems guarantee a coupled solution in one step but can be numerically challenging, often resulting in large, ill-conditioned matrices that are difficult and expensive to solve. The condition number, $\\kappa(A)$, is a key metric for quantifying this numerical difficulty. In this advanced exercise [@problem_id:2416736], you will analyze a poroelasticity model, deriving the matrices for both the monolithic and partitioned approaches to quantitatively explore this core dilemma and understand why the selection of a coupling scheme is a critical design decision for any multiphysics simulation.", "problem": "Consider the one-dimensional ($1\\text{-}\\mathrm{D}$) quasi-static Biot poroelastic consolidation problem on a finite interval $[0,L]$ with homogeneous Dirichlet boundary conditions for both the solid displacement and the pore pressure. The governing equations are the balance of linear momentum and mass conservation, coupled through the constitutive law for poroelasticity. The fundamental base you must use consists of: (i) balance of linear momentum, (ii) mass conservation of fluid in the porous skeleton, and (iii) linear elastic constitutive behavior of the skeleton with a single-phase slightly compressible pore fluid. Specifically, assume the following standard forms:\n- Balance of linear momentum for small strains: $\\dfrac{\\partial}{\\partial x}\\left(\\sigma\\right) = 0$, with stress $\\sigma = E \\dfrac{\\partial u}{\\partial x} - \\alpha p$, where $E$ is the Young’s modulus, $u$ is the displacement, $\\alpha$ is the Biot coefficient, and $p$ is the pore pressure.\n- Mass conservation: $S \\dfrac{\\partial p}{\\partial t} + \\alpha \\dfrac{\\partial}{\\partial t}\\left(\\dfrac{\\partial u}{\\partial x}\\right) - \\dfrac{\\partial}{\\partial x}\\left(k \\dfrac{\\partial p}{\\partial x}\\right) = 0$, where $S$ is the specific storage and $k$ is the hydraulic conductivity (assumed constant).\n- Homogeneous Dirichlet boundary conditions: $u(0,t)=0$, $u(L,t)=0$, $p(0,t)=0$, and $p(L,t)=0$.\n\nDiscretize the spatial domain with a uniform grid of $n$ interior nodes. Let the grid spacing be $h = L/(n+1)$. Use second-order central differences to approximate spatial derivatives and the backward Euler method with time step $\\Delta t$ to approximate the time derivative at the new time level. Work with the following purely algebraic discrete operators acting on interior nodal unknowns:\n- The discrete Laplacian operator $L_h$ that approximates $- \\dfrac{\\partial^2}{\\partial x^2}$ via the tridiagonal stencil with main diagonal entries $2/h^2$ and first off-diagonal entries $-1/h^2$.\n- The discrete first-derivative operator $D_h$ that approximates $\\dfrac{\\partial}{\\partial x}$ by central differences at interior nodes, defined by $(D_h \\, v)_i = \\dfrac{v_{i+1} - v_{i-1}}{2h}$ wherever those indices are interior. At the first interior node $i=1$ use $(D_h \\, v)_1 = \\dfrac{v_{2} - v_{0}}{2h}$ with $v_0=0$ from the homogeneous Dirichlet boundary (i.e., drop the out-of-range coefficient), and analogously at the last interior node $i=n$ use $(D_h \\, v)_n = \\dfrac{v_{n+1} - v_{n-1}}{2h}$ with $v_{n+1}=0$.\n\nFrom these definitions and the fundamental equations, derive the linear algebraic system at the new time level $t^{m+1}$ that couples the displacement vector $u^{m+1} \\in \\mathbb{R}^n$ and the pressure vector $p^{m+1} \\in \\mathbb{R}^n$ into a monolithic block matrix $A \\in \\mathbb{R}^{2n \\times 2n}$ of the form\n$$\nA \\begin{bmatrix} u^{m+1} \\\\ p^{m+1} \\end{bmatrix} = \\text{rhs},\n$$\nand identify the two sub-problem matrices that would be used in a partitioned (staggered) scheme at time level $t^{m+1}$: the mechanical matrix $K \\in \\mathbb{R}^{n \\times n}$ and the flow matrix $H \\in \\mathbb{R}^{n \\times n}$.\n\nYour task is to:\n1. Start from the stated fundamental laws and definitions. Using the given finite-difference operators and backward Euler in time, derive the precise algebraic expressions for the monolithic matrix $A$ and for the two sub-problem matrices $K$ (mechanics) and $H$ (flow). Do not assume any additional modeling beyond what is stated. Clearly use the homogeneous Dirichlet boundary conditions in your discretization so that the resulting matrices are non-singular.\n2. Implement a program that constructs $A$, $K$, and $H$ for given parameter sets and computes their $2$-norm condition numbers, defined by $\\kappa_2(M) = \\|M\\|_2 \\|M^{-1}\\|_2$ for any non-singular matrix $M$. Express all condition numbers as dimensionless floats.\n3. Use the following test suite of parameter values, which is designed to probe different conditioning regimes. In all cases take the domain length $L = 1$:\n   - Case $1$ (general coupled, moderate size): $n = 10$, $E = 10^5$, $\\alpha = 0.8$, $k = 10^{-6}$, $S = 10^{-4}$, $\\Delta t = 1$.\n   - Case $2$ (decoupled limit): $n = 10$, $E = 10^5$, $\\alpha = 0$, $k = 10^{-6}$, $S = 10^{-4}$, $\\Delta t = 1$.\n   - Case $3$ (stiffer flow due to low conductivity and storage, larger spatial resolution): $n = 50$, $E = 10^5$, $\\alpha = 0.8$, $k = 10^{-10}$, $S = 10^{-6}$, $\\Delta t = 1$.\n   - Case $4$ (small time step, storage-dominated flow block): $n = 10$, $E = 10^5$, $\\alpha = 0.8$, $k = 10^{-6}$, $S = 10^{-4}$, $\\Delta t = 10^{-4}$.\n4. For each case, compute three floats: $\\kappa_2(A)$, $\\kappa_2(K)$, and $\\kappa_2(H)$. Round each float to $6$ significant digits.\n5. Final output format: Your program should produce a single line of output containing the results for the four cases as a list of lists formatted like a Python literal, where each inner list contains the three rounded floats for a single case in the order $[\\kappa_2(A), \\kappa_2(K), \\kappa_2(H)]$. For example, the printed output must look like\n$[ [a_1,b_1,c_1], [a_2,b_2,c_2], [a_3,b_3,c_3], [a_4,b_4,c_4] ]$\nwith no additional text, where each $a_i$, $b_i$, $c_i$ is a dimensionless float rounded to $6$ significant digits. Angles do not appear in this problem, and no physical units should be included in the output, since condition numbers are dimensionless.", "solution": "The problem as stated is scientifically grounded, well-posed, and complete. It is based on the standard equations of quasi-static poroelasticity and uses conventional numerical discretization techniques. All parameters and boundary conditions are explicitly defined. Therefore, proceeding with a solution is justified.\n\nThe derivation of the algebraic system proceeds from the two governing partial differential equations. All mathematical entities are rendered in LaTeX as required.\n\nFirst, consider the balance of linear momentum. The given form is:\n$$ \\frac{\\partial}{\\partial x}\\left(\\sigma\\right) = 0 $$\nwith the constitutive relation for stress $\\sigma$:\n$$ \\sigma = E \\frac{\\partial u}{\\partial x} - \\alpha p $$\nAssuming the Young's modulus $E$ is constant over the domain, substituting the stress into the balance law yields:\n$$ E \\frac{\\partial^2 u}{\\partial x^2} - \\alpha \\frac{\\partial p}{\\partial x} = 0 $$\nThis equation is evaluated at the new time level $t^{m+1}$. We discretize the spatial derivatives using the provided finite difference operators. The second derivative $\\frac{\\partial^2}{\\partial x^2}$ is approximated by $-L_h$, and the first derivative $\\frac{\\partial}{\\partial x}$ is approximated by $D_h$. Applying these operators to the vector of nodal unknowns $u^{m+1}$ and $p^{m+1}$ results in the algebraic equation:\n$$ E (-L_h u^{m+1}) - \\alpha (D_h p^{m+1}) = \\mathbf{0} $$\nThis can be rearranged into the first block row of our target linear system:\n$$ (E L_h) u^{m+1} + (\\alpha D_h) p^{m+1} = \\mathbf{0} $$\n\nSecond, consider the mass conservation equation:\n$$ S \\frac{\\partial p}{\\partial t} + \\alpha \\frac{\\partial}{\\partial t}\\left(\\frac{\\partial u}{\\partial x}\\right) - \\frac{\\partial}{\\partial x}\\left(k \\frac{\\partial p}{\\partial x}\\right) = 0 $$\nAssuming the hydraulic conductivity $k$ is constant, this becomes:\n$$ S \\frac{\\partial p}{\\partial t} + \\alpha \\frac{\\partial}{\\partial t}\\left(\\frac{\\partial u}{\\partial x}\\right) + k \\left(-\\frac{\\partial^2 p}{\\partial x^2}\\right) = 0 $$\nTime derivatives are approximated using the first-order backward Euler scheme, for example $\\frac{\\partial p}{\\partial t} \\approx \\frac{p^{m+1}-p^m}{\\Delta t}$. Spatial derivatives are again replaced by their discrete counterparts. The discretized equation at time $t^{m+1}$ is:\n$$ S \\frac{p^{m+1} - p^m}{\\Delta t} + \\alpha \\frac{D_h u^{m+1} - D_h u^m}{\\Delta t} + k L_h p^{m+1} = \\mathbf{0} $$\nTo formulate the linear system for the unknowns at $t^{m+1}$, we rearrange the terms, placing all terms involving $u^{m+1}$ and $p^{m+1}$ on the left-hand side and all known terms from time $t^m$ on the right-hand side.\n$$ \\frac{\\alpha}{\\Delta t} D_h u^{m+1} + \\left( \\frac{S}{\\Delta t} I + k L_h \\right) p^{m+1} = \\frac{S}{\\Delta t} p^m + \\frac{\\alpha}{\\Delta t} D_h u^m $$\nwhere $I$ is the $n \\times n$ identity matrix. This constitutes the second block row of the system.\n\nCombining the two discretized equations, we construct the monolithic block matrix system. The system takes the form $A \\begin{bmatrix} u^{m+1} \\\\ p^{m+1} \\end{bmatrix} = \\text{rhs}$, where the monolithic matrix $A \\in \\mathbb{R}^{2n \\times 2n}$ is given by:\n$$ A = \\begin{bmatrix} E L_h & \\alpha D_h \\\\ \\frac{\\alpha}{\\Delta t} D_h & \\frac{S}{\\Delta t} I + k L_h \\end{bmatrix} $$\n\nThe sub-problem matrices for a partitioned scheme are typically the matrices on the main diagonal of the block system, which correspond to the uncoupled physics. The mechanical sub-problem governs displacement, and the flow sub-problem governs pressure. From the structure of $A$, we identify:\nThe mechanical matrix $K \\in \\mathbb{R}^{n \\times n}$:\n$$ K = E L_h $$\nThe flow matrix $H \\in \\mathbb{R}^{n \\times n}$:\n$$ H = \\frac{S}{\\Delta t} I + k L_h $$\nThese are the matrices for which the condition numbers must be computed. Both $K$ and $H$ are symmetric and positive-definite, thus non-singular, because $L_h$ is symmetric positive-definite and all physical parameters $E, S, k, \\Delta t$ are positive. The full matrix $A$ is non-symmetric if $\\alpha \\neq 0$ and $\\Delta t \\neq 1$. Its non-singularity is guaranteed under these physical conditions.\n\nThe implementation will construct these matrices for each set of parameters, then compute their $2$-norm condition numbers.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _round_to_significant_digits(x, d=6):\n    \"\"\"\n    Rounds a number to a specified number of significant digits.\n    \"\"\"\n    if x == 0:\n        return 0.0\n    return float(f'{x:.{d-1}e}')\n\ndef solve():\n    \"\"\"\n    Derives and analyzes matrices for a 1D poroelastic consolidation problem.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # (n, E, alpha, k, S, dt, L)\n    test_cases = [\n        (10, 1e5, 0.8, 1e-6, 1e-4, 1.0, 1.0),\n        (10, 1e5, 0.0, 1e-6, 1e-4, 1.0, 1.0),\n        (50, 1e5, 0.8, 1e-10, 1e-6, 1.0, 1.0),\n        (10, 1e5, 0.8, 1e-6, 1e-4, 1e-4, 1.0)\n    ]\n\n    results = []\n\n    for case in test_cases:\n        n, E, alpha, k, S, dt, L = case\n        \n        # Grid spacing\n        h = L / (n + 1)\n        \n        # Construct discrete Laplacian operator L_h (approximates -d^2/dx^2)\n        diag_L = np.full(n, 2.0 / h**2)\n        offdiag_L = np.full(n - 1, -1.0 / h**2)\n        L_h = np.diag(diag_L) + np.diag(offdiag_L, k=1) + np.diag(offdiag_L, k=-1)\n        \n        # Construct discrete first-derivative operator D_h (approximates d/dx)\n        offdiag_D_upper = np.full(n - 1, 1.0 / (2.0 * h))\n        offdiag_D_lower = np.full(n - 1, -1.0 / (2.0 * h))\n        D_h = np.diag(offdiag_D_upper, k=1) + np.diag(offdiag_D_lower, k=-1)\n        \n        # Construct mechanical matrix K\n        K = E * L_h\n        \n        # Construct flow matrix H\n        I = np.identity(n)\n        H = (S / dt) * I + k * L_h\n        \n        # Construct monolithic matrix A\n        A11 = K\n        A12 = alpha * D_h\n        A21 = (alpha / dt) * D_h\n        A22 = H\n        A = np.block([[A11, A12], [A21, A22]])\n        \n        # Compute 2-norm condition numbers\n        cond_A = np.linalg.cond(A, p=2)\n        cond_K = np.linalg.cond(K, p=2)\n        cond_H = np.linalg.cond(H, p=2)\n        \n        # Round results to 6 significant digits\n        rounded_cond_A = _round_to_significant_digits(cond_A, d=6)\n        rounded_cond_K = _round_to_significant_digits(cond_K, d=6)\n        rounded_cond_H = _round_to_significant_digits(cond_H, d=6)\n        \n        results.append([rounded_cond_A, rounded_cond_K, rounded_cond_H])\n\n    # Format output as a Python literal string for a list of lists.\n    # No extra spaces are added to maintain a clean literal format.\n    inner_list_strs = []\n    for res in results:\n        # Convert each float in the sublist to string\n        str_res = [str(val) for val in res]\n        inner_list_strs.append(f\"[{','.join(str_res)}]\")\n    \n    final_output_str = f\"[{','.join(inner_list_strs)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "2416736"}]}