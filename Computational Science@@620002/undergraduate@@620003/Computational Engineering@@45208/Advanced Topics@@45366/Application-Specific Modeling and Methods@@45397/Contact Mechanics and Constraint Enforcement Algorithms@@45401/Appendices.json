{"hands_on_practices": [{"introduction": "Before tackling complex multi-body contact, we begin with a foundational concept: enforcing simple bounds on a system. This exercise models a common engineering scenario—an electric motor with a maximum torque limit—to introduce the powerful idea of constraint projection. By first calculating an ideal, unconstrained torque and then clamping it to the actuator's physical limits, you will implement a core building block used in nearly all advanced constraint solvers [@problem_id:2380886].", "problem": "A single degree of freedom (SDOF) motor-driven revolute joint with rotational inertia $I$ about its axis is actuated by a motor torque and subjected to an external torque. The motor torque is bounded in magnitude by a maximum allowable value $\\tau_{\\max}$ due to actuator limits. The goal is to enforce this bound while driving the joint toward a specified target angular velocity $\\omega^{\\star}$ over a single time step of duration $h$ using a principled constraint enforcement approach. The physical units are as follows: inertia in $\\mathrm{kg \\cdot m^2}$, torque in $\\mathrm{N \\cdot m}$, angular velocity in $\\mathrm{rad/s}$, and time in $\\mathrm{s}$. All angles and angular velocities must be treated in radians and $\\mathrm{rad/s}$, respectively.\n\nBase the derivation on Newton’s second law for rotation and standard time-stepping ideas. Specifically, use the fundamental law $I \\, \\dot{\\omega} = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}}$, where $\\tau_{\\mathrm{ext}}$ is the external torque and $\\tau_{\\mathrm{motor}}$ is the motor torque, and a consistent discrete update of angular velocity over one step of duration $h$. Treat the motor action as a constraint-based velocity servo attempting to enforce the velocity-level condition $\\omega_{k+1} \\approx \\omega^{\\star}$ at the end of the step, with the motor torque represented as a decision variable that must obey the box constraint $-\\tau_{\\max} \\le \\tau_{\\mathrm{motor}} \\le \\tau_{\\max}$. Connect this to a physically motivated projection or Lagrange multiplier interpretation, but do not assume any pre-derived servo or projection formulas; instead, derive the appropriate expression for the torque decision that results from the discrete dynamics and the velocity-level target.\n\nImplement a program that, for each provided test case, computes the applied motor torque that respects the bound and the resulting next-step angular velocity $\\omega_{k+1}$ using the discrete dynamics. The final program must output only the resulting next-step angular velocities, one per test case, aggregated as a single list on one line as a comma-separated list enclosed in square brackets. Each result must be rounded to six decimal places and expressed in $\\mathrm{rad/s}$.\n\nTest suite to cover typical, boundary, and edge conditions:\n- Case 1 (unsaturated servo tracking in the presence of nonzero external torque): $I = 1.5 \\ \\mathrm{kg \\cdot m^2}$, $h = 0.02 \\ \\mathrm{s}$, $\\omega_k = 1.00 \\ \\mathrm{rad/s}$, $\\omega^{\\star} = 1.02 \\ \\mathrm{rad/s}$, $\\tau_{\\max} = 5.0 \\ \\mathrm{N \\cdot m}$, $\\tau_{\\mathrm{ext}} = 0.5 \\ \\mathrm{N \\cdot m}$.\n- Case 2 (strong positive saturation): $I = 0.5 \\ \\mathrm{kg \\cdot m^2}$, $h = 0.01 \\ \\mathrm{s}$, $\\omega_k = 0.00 \\ \\mathrm{rad/s}$, $\\omega^{\\star} = 10.00 \\ \\mathrm{rad/s}$, $\\tau_{\\max} = 2.0 \\ \\mathrm{N \\cdot m}$, $\\tau_{\\mathrm{ext}} = 0.0 \\ \\mathrm{N \\cdot m}$.\n- Case 3 (strong negative saturation opposing an external torque): $I = 1.2 \\ \\mathrm{kg \\cdot m^2}$, $h = 0.02 \\ \\mathrm{s}$, $\\omega_k = 5.00 \\ \\mathrm{rad/s}$, $\\omega^{\\star} = -5.00 \\ \\mathrm{rad/s}$, $\\tau_{\\max} = 1.0 \\ \\mathrm{N \\cdot m}$, $\\tau_{\\mathrm{ext}} = 0.2 \\ \\mathrm{N \\cdot m}$.\n- Case 4 (zero motor capability, external torque only): $I = 1.0 \\ \\mathrm{kg \\cdot m^2}$, $h = 0.05 \\ \\mathrm{s}$, $\\omega_k = 2.00 \\ \\mathrm{rad/s}$, $\\omega^{\\star} = 0.00 \\ \\mathrm{rad/s}$, $\\tau_{\\max} = 0.0 \\ \\mathrm{N \\cdot m}$, $\\tau_{\\mathrm{ext}} = -0.5 \\ \\mathrm{N \\cdot m}$.\n- Case 5 (boundary equality where the bound is just sufficient): $I = 2.0 \\ \\mathrm{kg \\cdot m^2}$, $h = 0.10 \\ \\mathrm{s}$, $\\omega_k = 1.00 \\ \\mathrm{rad/s}$, $\\omega^{\\star} = 1.50 \\ \\mathrm{rad/s}$, $\\tau_{\\max} = 10.0 \\ \\mathrm{N \\cdot m}$, $\\tau_{\\mathrm{ext}} = 0.0 \\ \\mathrm{N \\cdot m}$.\n\nYour program must:\n- For each case, compute the next-step angular velocity in $\\mathrm{rad/s}$ using a principled constraint enforcement that respects $-\\tau_{\\max} \\le \\tau_{\\mathrm{motor}} \\le \\tau_{\\max}$.\n- Aggregate the five next-step angular velocities into a single list.\n- Print exactly one line containing that list formatted as $[\\text{v}_1,\\text{v}_2,\\text{v}_3,\\text{v}_4,\\text{v}_5]$ with each $\\text{v}_i$ rounded to six decimal places and in $\\mathrm{rad/s}$.", "solution": "The problem is subjected to validation.\n\n**Step 1: Extracted Givens**\n- Governing differential equation: $I \\, \\dot{\\omega} = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}}$\n- Rotational inertia: $I$\n- Time step duration: $h$\n- Angular velocity at step $k$: $\\omega_k$\n- Target angular velocity: $\\omega^{\\star}$\n- Maximum motor torque magnitude: $\\tau_{\\max}$\n- External torque: $\\tau_{\\mathrm{ext}}$\n- Motor torque constraint: $-\\tau_{\\max} \\le \\tau_{\\mathrm{motor}} \\le \\tau_{\\max}$\n- Control objective: Achieve $\\omega_{k+1} \\approx \\omega^{\\star}$\n- Test Cases:\n    1. $I = 1.5 \\ \\mathrm{kg \\cdot m^2}$, $h = 0.02 \\ \\mathrm{s}$, $\\omega_k = 1.00 \\ \\mathrm{rad/s}$, $\\omega^{\\star} = 1.02 \\ \\mathrm{rad/s}$, $\\tau_{\\max} = 5.0 \\ \\mathrm{N \\cdot m}$, $\\tau_{\\mathrm{ext}} = 0.5 \\ \\mathrm{N \\cdot m}$.\n    2. $I = 0.5 \\ \\mathrm{kg \\cdot m^2}$, $h = 0.01 \\ \\mathrm{s}$, $\\omega_k = 0.00 \\ \\mathrm{rad/s}$, $\\omega^{\\star} = 10.00 \\ \\mathrm{rad/s}$, $\\tau_{\\max} = 2.0 \\ \\mathrm{N \\cdot m}$, $\\tau_{\\mathrm{ext}} = 0.0 \\ \\mathrm{N \\cdot m}$.\n    3. $I = 1.2 \\ \\mathrm{kg \\cdot m^2}$, $h = 0.02 \\ \\mathrm{s}$, $\\omega_k = 5.00 \\ \\mathrm{rad/s}$, $\\omega^{\\star} = -5.00 \\ \\mathrm{rad/s}$, $\\tau_{\\max} = 1.0 \\ \\mathrm{N \\cdot m}$, $\\tau_{\\mathrm{ext}} = 0.2 \\ \\mathrm{N \\cdot m}$.\n    4. $I = 1.0 \\ \\mathrm{kg \\cdot m^2}$, $h = 0.05 \\ \\mathrm{s}$, $\\omega_k = 2.00 \\ \\mathrm{rad/s}$, $\\omega^{\\star} = 0.00 \\ \\mathrm{rad/s}$, $\\tau_{\\max} = 0.0 \\ \\mathrm{N \\cdot m}$, $\\tau_{\\mathrm{ext}} = -0.5 \\ \\mathrm{N \\cdot m}$.\n    5. $I = 2.0 \\ \\mathrm{kg \\cdot m^2}$, $h = 0.10 \\ \\mathrm{s}$, $\\omega_k = 1.00 \\ \\mathrm{rad/s}$, $\\omega^{\\star} = 1.50 \\ \\mathrm{rad/s}$, $\\tau_{\\max} = 10.0 \\ \\mathrm{N \\cdot m}$, $\\tau_{\\mathrm{ext}} = 0.0 \\ \\mathrm{N \\cdot m}$.\n\n**Step 2: Validation Using Extracted Givens**\n- **Scientific Grounding:** The problem is based on Newton's second law for rotation, a fundamental principle of mechanics. The use of discrete time-stepping and actuator saturation is standard in computational dynamics and control. The physics is sound.\n- **Well-Posedness:** The problem is clearly defined with all necessary parameters provided for each case. The objective is unambiguous, leading to a unique solution.\n- **Objectivity:** The problem is stated in precise, quantitative terms, free from subjective or speculative content.\n- **Conclusion:** The problem is scientifically grounded, well-posed, objective, and complete. It is therefore valid.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be derived and provided.\n\nThe derivation commences from the fundamental principle of rotational dynamics, Newton's second law, which states that the net torque applied to a body equals its rotational inertia multiplied by its angular acceleration.\n$$ I \\dot{\\omega}(t) = \\tau_{\\text{total}}(t) $$\nThe total torque, $\\tau_{\\text{total}}$, is the sum of the external torque, $\\tau_{\\mathrm{ext}}$, and the control torque from the motor, $\\tau_{\\mathrm{motor}}$.\n$$ I \\dot{\\omega}(t) = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}} $$\nTo formulate a computational algorithm, we must discretize this continuous equation in time. A consistent and simple choice for a forward dynamics simulation is the explicit Euler integration scheme. The time derivative of angular velocity, $\\dot{\\omega}$, is approximated over a finite time step of duration $h$ as:\n$$ \\dot{\\omega} \\approx \\frac{\\omega_{k+1} - \\omega_k}{h} $$\nwhere $\\omega_k$ and $\\omega_{k+1}$ are the angular velocities at the start and end of the time step, respectively. Substituting this into the equation of motion yields the discrete-time dynamics:\n$$ I \\left( \\frac{\\omega_{k+1} - \\omega_k}{h} \\right) = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}} $$\nThe control objective is to select a motor torque, $\\tau_{\\mathrm{motor}}$, such that the resulting velocity, $\\omega_{k+1}$, matches the target velocity, $\\omega^{\\star}$. Let us first determine the ideal, unconstrained torque, denoted $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$, that would perfectly achieve this objective. We set $\\omega_{k+1} = \\omega^{\\star}$ in the discrete dynamics equation:\n$$ I \\left( \\frac{\\omega^{\\star} - \\omega_k}{h} \\right) = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}}^{\\text{ideal}} $$\nSolving for this ideal motor torque gives:\n$$ \\tau_{\\mathrm{motor}}^{\\text{ideal}} = \\frac{I}{h}(\\omega^{\\star} - \\omega_k) - \\tau_{\\mathrm{ext}} $$\nThis expression represents the torque required for the system to reach the target angular velocity in a single time step under the explicit Euler discretization.\n\nHowever, the motor is subject to physical limitations, expressed as the box constraint:\n$$ -\\tau_{\\max} \\le \\tau_{\\mathrm{motor}} \\le \\tau_{\\max} $$\nThe ideal torque, $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$, may exceed these limits. The physically correct approach is to apply the maximum possible torque in the direction of the ideal torque if saturation occurs. This corresponds to finding the torque $\\tau_{\\mathrm{motor}}$ within the allowable interval $[-\\tau_{\\max}, \\tau_{\\max}]$ that is closest to $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$. This is a projection of the ideal torque onto the valid set. Mathematically, this operation is a clamping or saturation function:\n$$ \\tau_{\\mathrm{motor}} = \\text{clamp}(\\tau_{\\mathrm{motor}}^{\\text{ideal}}, -\\tau_{\\max}, \\tau_{\\max}) \\equiv \\max(-\\tau_{\\max}, \\min(\\tau_{\\mathrm{motor}}^{\\text{ideal}}, \\tau_{\\max})) $$\nThis formulation is not ad-hoc; it is the correct solution to the constrained optimization problem of minimizing the deviation from the ideal torque, $J(\\tau) = (\\tau - \\tau_{\\mathrm{motor}}^{\\text{ideal}})^2$, subject to the inequality constraints $\\tau \\le \\tau_{\\max}$ and $-\\tau \\le \\tau_{\\max}$. The solution via Karush-Kuhn-Tucker (KKT) conditions confirms that this projection is the optimal choice.\n\nWith the constrained, realizable motor torque $\\tau_{\\mathrm{motor}}$ determined, we can now calculate the actual resulting angular velocity at the next time step, $\\omega_{k+1}$. We rearrange the discrete dynamics equation to solve for $\\omega_{k+1}$:\n$$ \\omega_{k+1} = \\omega_k + \\frac{h}{I} (\\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}}) $$\nIf $\\tau_{\\mathrm{motor}} = \\tau_{\\mathrm{motor}}^{\\text{ideal}}$ (i.e., no saturation), substituting this back into the equation correctly yields $\\omega_{k+1} = \\omega^{\\star}$. If saturation occurs, $\\tau_{\\mathrm{motor}}$ will be either $\\tau_{\\max}$ or $-\\tau_{\\max}$, and $\\omega_{k+1}$ will be the velocity achieved under maximum actuator effort.\n\nThe final algorithm is as follows:\n1. For a given set of parameters $\\{I, h, \\omega_k, \\omega^{\\star}, \\tau_{\\max}, \\tau_{\\mathrm{ext}}\\}$, calculate the ideal motor torque $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$.\n2. Apply the saturation constraint to find the actual motor torque $\\tau_{\\mathrm{motor}} = \\text{clamp}(\\tau_{\\mathrm{motor}}^{\\text{ideal}}, -\\tau_{\\max}, \\tau_{\\max})$.\n3. Calculate the new angular velocity $\\omega_{k+1}$ using the constrained torque $\\tau_{\\mathrm{motor}}$.\nThis procedure is applied to each test case to find the corresponding next-step angular velocity.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the next-step angular velocity for a motor-driven revolute joint,\n    enforcing motor torque limits using a principled constraint method.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (I, h, omega_k, omega_star, tau_max, tau_ext)\n    test_cases = [\n        # Case 1: Unsaturated servo tracking\n        (1.5, 0.02, 1.00, 1.02, 5.0, 0.5),\n        # Case 2: Strong positive saturation\n        (0.5, 0.01, 0.00, 10.00, 2.0, 0.0),\n        # Case 3: Strong negative saturation opposing external torque\n        (1.2, 0.02, 5.00, -5.00, 1.0, 0.2),\n        # Case 4: Zero motor capability, external torque only\n        (1.0, 0.05, 2.00, 0.00, 0.0, -0.5),\n        # Case 5: Boundary equality where the bound is just sufficient\n        (2.0, 0.10, 1.00, 1.50, 10.0, 0.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        I, h, omega_k, omega_star, tau_max, tau_ext = case\n\n        # Step 1: Calculate the ideal motor torque to reach omega_star in one step.\n        # This is derived from I * (omega_k+1 - omega_k) / h = tau_ext + tau_motor\n        # by setting omega_k+1 = omega_star and solving for tau_motor.\n        tau_motor_ideal = (I / h) * (omega_star - omega_k) - tau_ext\n        \n        # Step 2: Enforce the motor torque constraint. The applied torque is the\n        # ideal torque projected (clamped) onto the valid interval [-tau_max, tau_max].\n        tau_motor_actual = np.clip(tau_motor_ideal, -tau_max, tau_max)\n        \n        # Step 3: Calculate the actual next-step angular velocity using the\n        # constrained torque and the discrete dynamics equation.\n        # omega_k+1 = omega_k + (h / I) * (tau_ext + tau_motor)\n        omega_next = omega_k + (h / I) * (tau_ext + tau_motor_actual)\n        \n        results.append(omega_next)\n\n    # Format the final output as a single-line, comma-separated list of values\n    # rounded to six decimal places, enclosed in square brackets.\n    # The format string '{r:.6f}' ensures rounding to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2380886"}, {"introduction": "We now advance from simple bounds to the heart of our topic: modeling dry frictional contact. This practice guides you through implementing a Projected Gauss-Seidel (PGS) solver, a workhorse algorithm in modern physics engines for games and simulation [@problem_id:2380912]. You will translate the nonlinear, complementarity-based laws of Coulomb friction—unilateral non-penetration and the friction cone—into a robust iterative solver, providing direct, hands-on experience with the techniques used to make virtual objects interact realistically.", "problem": "You are to implement a Projected Gauss–Seidel (PGS) solver for a single-contact, three-dimensional frictional contact time-stepping problem formulated as a Linear Complementarity Problem (LCP) with Coulomb friction. The physical setting is a rigid block of mass $m$ moving in three-dimensional space under gravity, possibly contacting a horizontal plane whose unit normal is $\\mathbf{n} = [0,1,0]^{\\mathsf{T}}$. The block’s translational motion only is considered (rotations are ignored), and the time-stepping scheme is implicit in contact impulses and explicit in external forces over a time step of duration $h$.\n\nStart from the following fundamental principles and core definitions:\n- Newton’s Second Law in impulse form over a time step: $\\mathbf{M} (\\mathbf{v}^{+} - \\mathbf{v}^{-}) = h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{J}^{\\mathsf{T}} \\mathbf{p}$, where $\\mathbf{M}$ is the mass matrix, $\\mathbf{v}^{-}$ and $\\mathbf{v}^{+}$ are pre- and post-step velocities, $\\mathbf{f}_{\\mathrm{ext}}$ is the external force, $\\mathbf{J}$ is the contact Jacobian, and $\\mathbf{p}$ is the contact impulse.\n- Unilateral impenetrability with complementarity at the velocity level: $0 \\le p_{n} \\perp \\gamma_{n}^{+} \\ge 0$, where $p_{n}$ is the normal impulse and $\\gamma_{n}^{+}$ is the post-step normal relative velocity.\n- Coulomb friction model via a friction cone: $\\|\\mathbf{p}_{t}\\| \\le \\mu p_{n}$, with $\\mathbf{p}_{t}$ the tangential impulse and $\\mu$ the coefficient of friction, and the maximum dissipation principle enforcing sticking ($\\gamma_{t}^{+} = \\mathbf{0}$) when interior to the cone and sliding with projection when on the cone’s boundary.\n\nFor a single contact between the block and the plane, define a local contact frame with basis vectors $\\{\\mathbf{n}, \\mathbf{t}_{1}, \\mathbf{t}_{2}\\}$, where $\\mathbf{t}_{1} = [1,0,0]^{\\mathsf{T}}$ and $\\mathbf{t}_{2} = [0,0,1]^{\\mathsf{T}}$. The translational mass matrix is $\\mathbf{M} = m \\mathbf{I}_{3}$. Using impulse–momentum discretization, let $\\mathbf{v}^{+} = \\mathbf{v}^{-} + \\mathbf{M}^{-1} (h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{J}^{\\mathsf{T}} \\mathbf{p})$. The relative velocity at the contact in the local frame is $\\boldsymbol{\\gamma}^{+} = \\mathbf{J} \\mathbf{v}^{+}$. Show that, for this setting, the effective Delassus operator (also called the inverse mass at the contact) reduces to $\\mathbf{A} = \\mathbf{J}\\mathbf{M}^{-1}\\mathbf{J}^{\\mathsf{T}} = \\frac{1}{m}\\mathbf{I}_{3}$ and that the PGS iteration can be carried out on the $3 \\times 1$ impulse vector $\\mathbf{p} = [p_{n}, p_{t1}, p_{t2}]^{\\mathsf{T}}$ using:\n- A normal complementarity update: $p_{n} \\leftarrow \\max\\{0, p_{n} - \\gamma_{n} / A_{nn}\\}$,\n- A tangential unconstrained gradient step followed by projection onto the friction disk of radius $\\mu p_{n}$: $\\mathbf{p}_{t} \\leftarrow \\operatorname{Proj}_{\\|\\cdot\\| \\le \\mu p_{n}}(\\mathbf{p}_{t} - \\mathbf{A}_{tt}^{-1}\\boldsymbol{\\gamma}_{t})$,\nwhere $\\boldsymbol{\\gamma} = \\mathbf{A}\\mathbf{p} + \\mathbf{c}$, and $\\mathbf{c}$ aggregates known terms from pre-step velocities and external forces.\n\nUse gravity $\\mathbf{f}_{\\mathrm{ext}} = m \\mathbf{g}$ with $\\mathbf{g} = [0, -g, 0]^{\\mathsf{T}}$ and $g > 0$. The time step is $h > 0$. The local “free” contact velocity vector is $\\mathbf{c} = \\mathbf{J} \\left(\\mathbf{v}^{-} + \\mathbf{M}^{-1} h \\mathbf{f}_{\\mathrm{ext}}\\right)$, which in this setup evaluates to $\\mathbf{c} = [v_{y}^{-} - h g, v_{x}^{-}, v_{z}^{-}]^{\\mathsf{T}}$. After solving for $\\mathbf{p}$ using PGS, compute the post-step velocity\n$$\n\\mathbf{v}^{+} = \\mathbf{v}^{-} + \\mathbf{M}^{-1} h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{M}^{-1}\\mathbf{J}^{\\mathsf{T}}\\mathbf{p} = \\mathbf{v}^{-} + [0, -h g, 0]^{\\mathsf{T}} + \\frac{1}{m}[p_{t1}, p_{n}, p_{t2}]^{\\mathsf{T}}.\n$$\n\nYour task:\n- Implement a basic Projected Gauss–Seidel (PGS) solver for this single-contact problem as a complete program. Use a fixed iteration count (for example, $N_{\\mathrm{iter}} = 50$) and terminate early if the change in $\\mathbf{p}$ is below a small tolerance (for example, $10^{-12}$). Your implementation must be general enough to handle any admissible inputs for $m$, $h$, $g$, $\\mu$, and $\\mathbf{v}^{-}$, though for this problem you will only solve the specified test suite.\n- For each test case below, compute and report four quantities: the post-step normal velocity $v^{+}_{y}$ in $\\mathrm{m/s}$, the post-step tangential speed $\\sqrt{(v^{+}_{x})^{2} + (v^{+}_{z})^{2}}$ in $\\mathrm{m/s}$, the normal impulse $p_{n}$ in $\\mathrm{N\\cdot s}$, and the magnitude of the tangential impulse $\\sqrt{p_{t1}^{2} + p_{t2}^{2}}$ in $\\mathrm{N\\cdot s}$. Express all outputs in the specified units and round each reported number to exactly six decimal places.\n\nAngle units are not applicable. Percentages are not applicable.\n\nTest suite (all quantities in the International System of Units):\n- Case 1 (sliding): $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.5$, $\\mathbf{v}^{-} = [2.0,-1.0,0.0]^{\\mathsf{T}}$.\n- Case 2 (sticking): $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 1.0$, $\\mathbf{v}^{-} = [0.05,-0.01,0.0]^{\\mathsf{T}}$.\n- Case 3 (frictionless): $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.0$, $\\mathbf{v}^{-} = [1.0,-0.2,0.0]^{\\mathsf{T}}$.\n- Case 4 (separating, no contact): $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.5$, $\\mathbf{v}^{-} = [0.0,0.5,0.0]^{\\mathsf{T}}$.\n- Case 5 (heavy block, mixed): $m = 1000.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.6$, $\\mathbf{v}^{-} = [3.0,-0.3,4.0]^{\\mathsf{T}}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a list of four rounded floats in the order $[v^{+}_{y}, \\sqrt{(v^{+}_{x})^{2} + (v^{+}_{z})^{2}}, p_{n}, \\sqrt{p_{t1}^{2} + p_{t2}^{2}}]$. For example, an output with two hypothetical results would look like $[[a_{1},b_{1},c_{1},d_{1}],[a_{2},b_{2},c_{2},d_{2}]]$ with each entry rounded to six decimals.", "solution": "The problem is subjected to validation.\n\n### Step 1: Extract Givens\n- **Physical System**: A rigid block of mass $m$ undergoing translational motion in three-dimensional space, potentially contacting a horizontal plane.\n- **Contact Geometry**: The plane has a unit normal $\\mathbf{n} = [0,1,0]^{\\mathsf{T}}$. The local contact frame has basis vectors $\\{\\mathbf{n}, \\mathbf{t}_{1}, \\mathbf{t}_{2}\\}$ where $\\mathbf{t}_{1} = [1,0,0]^{\\mathsf{T}}$ and $\\mathbf{t}_{2} = [0,0,1]^{\\mathsf{T}}$.\n- **Dynamics**:\n    - Mass matrix: $\\mathbf{M} = m \\mathbf{I}_{3}$.\n    - External force: Gravity, $\\mathbf{f}_{\\mathrm{ext}} = m \\mathbf{g}$ with $\\mathbf{g} = [0, -g, 0]^{\\mathsf{T}}$ and $g > 0$.\n    - Time step: $h > 0$.\n- **Time-Stepping Formulation**:\n    - Impulse-momentum equation: $\\mathbf{M} (\\mathbf{v}^{+} - \\mathbf{v}^{-}) = h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{J}^{\\mathsf{T}} \\mathbf{p}$.\n    - Contact Jacobian $\\mathbf{J}$ maps global velocity $\\mathbf{v}$ to local relative velocity $\\boldsymbol{\\gamma}$.\n    - Contact impulse (local frame): $\\mathbf{p} = [p_{n}, p_{t1}, p_{t2}]^{\\mathsf{T}}$.\n- **Contact Laws**:\n    - Unilateral impenetrability: $0 \\le p_{n} \\perp \\gamma_{n}^{+} \\ge 0$.\n    - Coulomb friction: $\\|\\mathbf{p}_{t}\\| \\le \\mu p_{n}$, where $\\mathbf{p}_{t} = [p_{t1}, p_{t2}]^{\\mathsf{T}}$ and $\\mu$ is the coefficient of friction.\n- **Linear Complementarity Problem (LCP) Formulation**:\n    - Post-step relative velocity: $\\boldsymbol{\\gamma}^{+} = \\mathbf{A}\\mathbf{p} + \\mathbf{c}$.\n    - Delassus operator: $\\mathbf{A} = \\mathbf{J}\\mathbf{M}^{-1}\\mathbf{J}^{\\mathsf{T}} = \\frac{1}{m}\\mathbf{I}_{3}$.\n    - Free velocity term: $\\mathbf{c} = \\mathbf{J} \\left(\\mathbf{v}^{-} + \\mathbf{M}^{-1} h \\mathbf{f}_{\\mathrm{ext}}\\right) = [v_{y}^{-} - h g, v_{x}^{-}, v_{z}^{-}]^{\\mathsf{T}}$.\n- **Projected Gauss-Seidel (PGS) Update Rules**:\n    - Normal update: $p_{n} \\leftarrow \\max\\{0, p_{n} - \\gamma_{n} / A_{nn}\\}$.\n    - Tangential update: $\\mathbf{p}_{t} \\leftarrow \\operatorname{Proj}_{\\|\\cdot\\| \\le \\mu p_{n}}(\\mathbf{p}_{t} - \\mathbf{A}_{tt}^{-1}\\boldsymbol{\\gamma}_{t})$.\n- **Post-Step Velocity Calculation**:\n    - $\\mathbf{v}^{+} = \\mathbf{v}^{-} + [0, -h g, 0]^{\\mathsf{T}} + \\frac{1}{m}[p_{t1}, p_{n}, p_{t2}]^{\\mathsf{T}}$.\n- **Solver Parameters**:\n    - Fixed iteration count: $N_{\\mathrm{iter}} = 50$.\n    - Convergence tolerance: $\\epsilon = 10^{-12}$.\n- **Test Suite**:\n    - Case 1: $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.5$, $\\mathbf{v}^{-} = [2.0,-1.0,0.0]^{\\mathsf{T}}$.\n    - Case 2: $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 1.0$, $\\mathbf{v}^{-} = [0.05,-0.01,0.0]^{\\mathsf{T}}$.\n    - Case 3: $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.0$, $\\mathbf{v}^{-} = [1.0,-0.2,0.0]^{\\mathsf{T}}$.\n    - Case 4: $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.5$, $\\mathbf{v}^{-} = [0.0,0.5,0.0]^{\\mathsf{T}}$.\n    - Case 5: $m = 1000.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.6$, $\\mathbf{v}^{-} = [3.0,-0.3,4.0]^{\\mathsf{T}}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria:\n- **Scientifically Grounded**: The problem is based on fundamental principles of classical mechanics (Newton's laws) and standard models in computational contact mechanics (Coulomb friction, complementarity conditions, LCP formulation). The implicit time-stepping scheme and the PGS method are well-established techniques. The problem is scientifically sound.\n- **Well-Posed**: The problem asks for the implementation of a specific, well-defined algorithm (PGS) to solve a frictional contact problem. For the given setup (single contact, diagonal Delassus operator), the PGS method is guaranteed to converge to a unique solution. The problem is well-posed.\n- **Objective**: The problem statement uses precise, unambiguous mathematical and physical terminology. There are no subjective or opinion-based elements. The problem is objective.\n- **Complete and Consistent**: All necessary equations, parameters, and boundary conditions are provided. The derivations given in the problem statement for $\\mathbf{A}$ and $\\mathbf{c}$ are consistent with the underlying physics and definitions of $\\mathbf{J}$, $\\mathbf{M}$, and $\\mathbf{f}_{\\text{ext}}$. The setup is complete and internally consistent.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a standard, well-defined problem in computational mechanics. A solution will be provided.\n\nThe objective is to implement a Projected Gauss-Seidel (PGS) solver for a single-contact frictional problem. The problem is formulated as a Linear Complementarity Problem (LCP) where the unknown is the contact impulse $\\mathbf{p} = [p_n, p_{t1}, p_{t2}]^{\\mathsf{T}}$.\n\nFirst, we define the LCP system. The post-step relative contact velocity $\\boldsymbol{\\gamma}^{+}$ is related to the impulse $\\mathbf{p}$ by the affine relation $\\boldsymbol{\\gamma}^{+} = \\mathbf{A}\\mathbf{p} + \\mathbf{c}$, where $\\mathbf{A}$ is the Delassus operator and $\\mathbf{c}$ is the free-velocity term. The problem states that for this specific system, $\\mathbf{A} = \\frac{1}{m}\\mathbf{I}_3$, a diagonal matrix. The free velocity vector $\\mathbf{c}$ collects all terms independent of the unknown impulse $\\mathbf{p}$ and is given by $\\mathbf{c} = [v_{y}^{-} - h g, v_{x}^{-}, v_{z}^{-}]^{\\mathsf{T}}$. Let us denote the components of $\\mathbf{c}$ as $c_n = v_{y}^{-} - h g$, $c_{t1} = v_{x}^{-}$, and $c_{t2} = v_{z}^{-}$.\n\nThe PGS method is an iterative algorithm that solves the LCP by sequentially updating components of the solution vector $\\mathbf{p}$ and projecting them to satisfy the constraints. We initialize the impulse vector to zero, $\\mathbf{p}^{(0)} = \\mathbf{0}$. For each iteration $k$, we compute a new estimate $\\mathbf{p}^{(k+1)}$ based on $\\mathbf{p}^{(k)}$. The iteration uses a block-wise update strategy for the normal and tangential components.\n\n**1. Normal Impulse Update:**\nThe first step in the PGS sweep updates the normal impulse $p_n$. The complementarity condition for the normal direction is $0 \\le p_n \\perp \\gamma_n \\ge 0$. The PGS update performs a gradient-descent-like step and projects the result onto the feasible set, which for $p_n$ is the non-negative real line.\nThe update rule is $p_n^{(k+1)} = \\max\\{0, p_n^{(k)} - A_{nn}^{-1}\\gamma_n^{(k)}\\}$. The relative velocity $\\gamma_n$ is computed using the most recent impulse values available, but since $\\mathbf{A}$ is diagonal, this simplifies.\n$$ \\gamma_n = (\\mathbf{A}\\mathbf{p}^{(k)} + \\mathbf{c})_n = A_{nn}p_n^{(k)} + c_n = \\frac{1}{m}p_n^{(k)} + c_n $$\nSubstituting this into the update rule gives:\n$$ p_n^{(k+1)} = \\max\\left\\{0, p_n^{(k)} - \\frac{\\frac{1}{m}p_n^{(k)} + c_n}{1/m}\\right\\} = \\max\\left\\{0, p_n^{(k)} - (p_n^{(k)} + m c_n)\\right\\} = \\max\\{0, -m c_n\\} $$\nThis shows that for this diagonal system, the normal impulse converges to its final value in a single step. However, the implementation must follow the iterative form as specified.\n\n**2. Tangential Impulse Update:**\nNext, we update the tangential impulse vector $\\mathbf{p}_t = [p_{t1}, p_{t2}]^{\\mathsf{T}}$. The Coulomb friction law states that the tangential impulse must lie within a disk of radius $R = \\mu p_n$ in the tangential plane: $\\|\\mathbf{p}_t\\| \\le \\mu p_n$. In a Gauss-Seidel fashion, we use the most recently computed normal impulse, $p_n^{(k+1)}$, to define the radius of the friction disk for the current iteration. The update is performed via an unconstrained step followed by a projection onto this disk.\nThe unconstrained update for the tangential block is: $\\mathbf{p}_t^{unc} = \\mathbf{p}_t^{(k)} - \\mathbf{A}_{tt}^{-1}\\boldsymbol{\\gamma}_t^{(k)}$.\nThe tangential relative velocity is $\\boldsymbol{\\gamma}_t^{(k)} = \\mathbf{A}_{tt}\\mathbf{p}_t^{(k)} + \\mathbf{c}_t$. Given $\\mathbf{A}_{tt} = \\frac{1}{m}\\mathbf{I}_2$, its inverse is $\\mathbf{A}_{tt}^{-1} = m\\mathbf{I}_2$.\n$$ \\mathbf{p}_t^{unc} = \\mathbf{p}_t^{(k)} - m\\left(\\frac{1}{m}\\mathbf{p}_t^{(k)} + \\mathbf{c}_t\\right) = -m\\mathbf{c}_t $$\nThe final tangential impulse is obtained by projecting $\\mathbf{p}_t^{unc}$ onto the disk of radius $R = \\mu p_n^{(k+1)}$:\n$$ \\mathbf{p}_t^{(k+1)} = \\operatorname{Proj}_{\\|\\cdot\\| \\le R}(\\mathbf{p}_t^{unc}) $$\nThe projection is defined as:\n$$ \\mathbf{p}_t^{(k+1)} = \\begin{cases} \\mathbf{p}_t^{unc} & \\text{if } \\|\\mathbf{p}_t^{unc}\\| \\le R \\\\ R \\frac{\\mathbf{p}_t^{unc}}{\\|\\mathbf{p}_t^{unc}\\|} & \\text{if } \\|\\mathbf{p}_t^{unc}\\| > R \\end{cases} $$\nThis corresponds to sticking if the required frictional impulse is within the cone, and sliding otherwise.\n\nThe iterative process is repeated for a fixed number of iterations, $N_{\\mathrm{iter}}$, or until the change in the impulse vector, measured by the infinity norm $\\|\\mathbf{p}^{(k+1)} - \\mathbf{p}^{(k)}\\|_{\\infty}$, falls below a specified tolerance $\\epsilon$.\n\n**3. Post-processing:**\nAfter the PGS solver converges to the final impulse $\\mathbf{p}$, the post-step velocity $\\mathbf{v}^{+}$ is calculated using the impulse-momentum relation:\n$$ \\mathbf{v}^{+} = \\mathbf{v}^{-} + \\mathbf{M}^{-1} (h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{J}^{\\mathsf{T}} \\mathbf{p}) $$\nWith the provided definitions, this becomes:\n$$ \\begin{bmatrix} v_x^{+} \\\\ v_y^{+} \\\\ v_z^{+} \\end{bmatrix} = \\begin{bmatrix} v_x^{-} \\\\ v_y^{-} \\\\ v_z^{-} \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ -h g \\\\ 0 \\end{bmatrix} + \\frac{1}{m} \\begin{bmatrix} p_{t1} \\\\ p_n \\\\ p_{t2} \\end{bmatrix} $$\nFrom this, the required output quantities are computed:\n- Post-step normal velocity: $v_y^{+}$\n- Post-step tangential speed: $\\sqrt{(v_x^{+})^2 + (v_z^{+})^2}$\n- Normal impulse: $p_n$\n- Magnitude of tangential impulse: $\\sqrt{p_{t1}^2 + p_{t2}^2}$\n\nThe implementation will follow this logic for each test case provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the specified test cases for the frictional contact problem.\n    \"\"\"\n    \n    # Test suite (m, h, g, mu, v_minus)\n    # All quantities are in SI units.\n    test_cases = [\n        (1.0, 0.01, 9.81, 0.5, np.array([2.0, -1.0, 0.0])),  # Case 1 (sliding)\n        (1.0, 0.01, 9.81, 1.0, np.array([0.05, -0.01, 0.0])),  # Case 2 (sticking)\n        (1.0, 0.01, 9.81, 0.0, np.array([1.0, -0.2, 0.0])),    # Case 3 (frictionless)\n        (1.0, 0.01, 9.81, 0.5, np.array([0.0, 0.5, 0.0])),   # Case 4 (separating)\n        (1000.0, 0.01, 9.81, 0.6, np.array([3.0, -0.3, 4.0])),# Case 5 (heavy block, mixed)\n    ]\n\n    results = []\n    for case in test_cases:\n        m, h, g, mu, v_minus = case\n        result = run_pgs_solver(m, h, g, mu, v_minus)\n        # Round each number in the result to 6 decimal places\n        rounded_result = [round(x, 6) for x in result]\n        results.append(rounded_result)\n\n    # Format the final output string as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_pgs_solver(m, h, g, mu, v_minus):\n    \"\"\"\n    Implements the Projected Gauss-Seidel solver for a single-contact LCP.\n\n    Args:\n        m (float): Mass of the block.\n        h (float): Time step duration.\n        g (float): Acceleration due to gravity.\n        mu (float): Coefficient of friction.\n        v_minus (np.ndarray): Pre-step velocity vector [vx, vy, vz].\n\n    Returns:\n        list: A list of four floats:\n              [v_plus_y, tangential_speed_plus, p_n, p_t_magnitude].\n    \"\"\"\n    \n    # Solver parameters\n    N_iter = 50\n    tolerance = 1e-12\n\n    # Pre-computation of the free velocity vector 'c'\n    # c = [v_y^- - h*g, v_x^-, v_z^-]^T\n    c_n = v_minus[1] - h * g\n    c_t = np.array([v_minus[0], v_minus[2]])\n    \n    # Initialize impulse vector p = [p_n, p_t1, p_t2]^T\n    p = np.zeros(3)\n    \n    # Delassus operator is diagonal A = (1/m) * I\n    # inv_A_nn = m, inv_A_tt = m * I_2\n    inv_A_nn = m\n    \n    # PGS iteration loop\n    for _ in range(N_iter):\n        p_old = p.copy()\n        \n        # 1. Normal impulse update (component p_n)\n        # gamma_n = (1/m)*p_n + c_n\n        gamma_n = (1.0 / m) * p[0] + c_n\n        # p_n_new = max(0, p_n - inv_A_nn * gamma_n)\n        p[0] = max(0.0, p[0] - inv_A_nn * gamma_n)\n        \n        # 2. Tangential impulse update (block p_t)\n        # The update is based on the most recent p_n\n        friction_radius = mu * p[0]\n        \n        # Unconstrained tangential impulse: p_t_unc = -inv_A_tt * c_t = -m * c_t\n        p_t_unc = -m * c_t\n        norm_p_t_unc = np.linalg.norm(p_t_unc)\n        \n        # Project onto friction disk\n        if norm_p_t_unc = friction_radius:\n            # Sticking\n            p[1:] = p_t_unc\n        else:\n            # Sliding\n            if norm_p_t_unc > 1e-15: # Avoid division by zero\n                p[1:] = friction_radius * p_t_unc / norm_p_t_unc\n            else:\n                p[1:] = np.zeros(2)\n\n        # 3. Check for convergence\n        # The change is measured using the infinity norm\n        change = np.linalg.norm(p - p_old, np.inf)\n        if change  tolerance:\n            break\n            \n    p_n = p[0]\n    p_t = p[1:]\n    \n    # Post-processing: Compute post-step velocity v_plus\n    # v+ = v- + [0, -hg, 0]^T + (1/m)*[p_t1, p_n, p_t2]^T\n    v_plus = np.zeros(3)\n    v_plus[0] = v_minus[0] + p_t[0] / m\n    v_plus[1] = v_minus[1] - h * g + p_n / m\n    v_plus[2] = v_minus[2] + p_t[1] / m\n    \n    # Calculate required output quantities\n    v_plus_y = v_plus[1]\n    tangential_speed_plus = np.linalg.norm(np.array([v_plus[0], v_plus[2]]))\n    p_t_magnitude = np.linalg.norm(p_t)\n    \n    return [v_plus_y, tangential_speed_plus, p_n, p_t_magnitude]\n\nsolve()\n```", "id": "2380912"}, {"introduction": "Having learned to build a PGS solver, a crucial next step is to understand its limitations. This final exercise shifts from implementation to critical analysis, investigating why a seemingly robust algorithm can fail on certain classes of problems [@problem_id:2380870]. By examining a dry-stacked arch, you will explore the deep connection between a physical system's structure, the mathematical properties of its governing equations, and the convergence behavior of the iterative methods used to solve them.", "problem": "A system consists of $n$ identical rigid blocks of mass $m_b$ arranged to form a semicircular dry-stacked arch of radius $R$ supported by immovable abutments. The blocks interact through unilateral nonpenetration constraints with Coulomb friction at each contact. Gravity acts with acceleration $\\mathbf{g} = -g\\,\\mathbf{e}_y$. The discrete contact problem for a quasi-static load increment is posed in terms of unknown contact impulses $\\boldsymbol{\\lambda} \\in \\mathbb{R}^{q}$ (stacking normal and tangential components for all contacts) and uses the standard contact kinematics with constraint Jacobian $J \\in \\mathbb{R}^{q \\times d}$ and mass matrix $M \\in \\mathbb{R}^{d \\times d}$. The associated Delassus operator is $W = J M^{-1} J^\\top$. The unilateral normal contact conditions are of Signorini type, and tangential contact satisfies the Coulomb inequality $\\lVert \\boldsymbol{\\lambda}_t \\rVert \\le \\mu \\lambda_n$ at each contact with friction coefficient $\\mu0$. A Projected Gauss-Seidel (PGS) method (first defined here as the Projected Gauss-Seidel method) is applied to compute $\\boldsymbol{\\lambda}$ by sweeping sequentially over contacts and projecting local updates onto the Coulomb cone at each contact. In a particular load step, the PGS residual stagnates and the iteration fails to converge.\n\nWhich of the following statements correctly explain the failure and identify remedies consistent with first-principles analysis of the contact problem and the PGS iteration? Select all that apply.\n\nA. The closed contact loop in the arch yields redundant unilateral constraints that make $J$ rank-deficient on the active set, so $W = J M^{-1} J^\\top$ is singular or only positive semidefinite; classical Gauss-Seidel convergence requires positive definiteness, and its violation can cause stalling or cycling.\n\nB. The Coulomb friction set at a contact,\n$\\mathcal{K} = \\{(\\lambda_n,\\boldsymbol{\\lambda}_t) \\in \\mathbb{R} \\times \\mathbb{R}^{m_t} : \\lambda_n \\ge 0,\\ \\lVert \\boldsymbol{\\lambda}_t \\rVert \\le \\mu \\lambda_n\\}$, is nonconvex, so projections can jump between disconnected regions, causing divergence.\n\nC. Using an over-relaxation factor $\\omega1$ in the local projected update can destabilize the iteration in tightly coupled contact loops such as arches, whereas under-relaxation $\\omega \\in (0,1]$ can improve stability.\n\nD. Reordering the contacts to sweep along the presumed load path through the arch converts $W$ into a diagonally dominant matrix and therefore guarantees convergence of Gauss-Seidel.\n\nE. Introducing a small normal compliance (regularization) at contacts effectively replaces the hard constraints by a penalized relation that renders $W$ positive definite on the active set, improving conditioning and restoring convergence of the iteration.", "solution": "The problem statement is submitted to validation.\n\n### Step 1: Extract Givens\n- **System**: $n$ identical rigid blocks of mass $m_b$.\n- **Geometry**: Semicircular dry-stacked arch of radius $R$.\n- **Supports**: Immovable abutments.\n- **Interactions**: Unilateral nonpenetration constraints and Coulomb friction with coefficient $\\mu > 0$.\n- **Loading**: Gravity $\\mathbf{g} = -g\\,\\mathbf{e}_y$.\n- **Problem Formulation**: A quasi-static load increment is considered. The discrete contact problem is posed in terms of unknown contact impulses $\\boldsymbol{\\lambda} \\in \\mathbb{R}^{q}$.\n- **Mathematical Objects**:\n    - Constraint Jacobian: $J \\in \\mathbb{R}^{q \\times d}$.\n    - Mass matrix: $M \\in \\mathbb{R}^{d \\times d}$.\n    - Delassus operator: $W = J M^{-1} J^\\top$.\n- **Contact Laws**:\n    - Normal: Signorini type, implying normal impulse $\\lambda_n \\ge 0$.\n    - Tangential: Coulomb inequality, $\\lVert \\boldsymbol{\\lambda}_t \\rVert \\le \\mu \\lambda_n$.\n- **Numerical Method**: Projected Gauss-Seidel (PGS) method is applied to compute $\\boldsymbol{\\lambda}$.\n- **Observation**: The PGS iteration stagnates and fails to converge.\n\n### Step 2: Validate Using Extracted Givens\nThe problem describes a classical scenario in computational mechanics, specifically the analysis of a multi-body system with frictional contact constraints.\n- **Scientific Grounding**: The concepts presented—rigid bodies, unilateral constraints, Coulomb friction, constraint Jacobian ($J$), mass matrix ($M$), and Delassus operator ($W$)—are fundamental to the field of non-smooth mechanics. The PGS method is a standard iterative solver for the resulting complementarity problem. The structure, a dry-stacked arch, is a canonical example of a system with force chains and potentially redundant constraints. The problem is scientifically and factually sound.\n- **Well-Posedness**: The question asks for an explanation of a well-documented numerical phenomenon (convergence failure of PGS) in a specific, but representative, context. The problem is structured to test understanding of the interplay between physical system properties and numerical algorithm behavior. It is well-posed.\n- **Objectivity**: The problem is stated using precise and objective technical language. There are no subjective or opinion-based elements.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. It is a well-posed, scientifically grounded problem in computational engineering. I will proceed with the detailed analysis and solution.\n\nThe problem asks for an explanation of the convergence failure of the Projected Gauss-Seidel (PGS) method for a rigid-block arch. The PGS method solves the contact problem by iteratively updating the impulse at each contact and projecting the result onto the admissible set defined by the contact laws. The convergence of such a method is critically dependent on the properties of the system matrix, which in this context is the Delassus operator, $W = J M^{-1} J^\\top$.\n\nThe system is a semicircular arch, which forms a closed loop of interacting rigid bodies between two fixed abutments. This structural topology is the key to the analysis. A convergence failure, such as stagnation or cycling, points to a fundamental issue with applying a Gauss-Seidel-type iteration to this specific class of problem.\n\nNow, we evaluate each statement.\n\n**A. The closed contact loop in the arch yields redundant unilateral constraints that make $J$ rank-deficient on the active set, so $W = J M^{-1} J^\\top$ is singular or only positive semidefinite; classical Gauss-Seidel convergence requires positive definiteness, and its violation can cause stalling or cycling.**\n\nThis statement presents a chain of correct deductions.\n$1$. A closed kinematic loop of perfectly rigid bodies, such as in an arch, often leads to redundant constraints. The position and orientation of any block are constrained by its neighbors. In the fully assembled arch, the set of active contact constraints can be linearly dependent, meaning that the motion of the system is over-constrained.\n$2$. Linear dependence among the active constraints means that the rows of the constraint Jacobian matrix $J$ corresponding to these contacts are linearly dependent. By definition, this makes $J$ rank-deficient.\n$3$. The Delassus operator is $W = J M^{-1} J^\\top$. The mass matrix $M$ is symmetric and positive definite for a system of bodies with mass. Its inverse $M^{-1}$ is also symmetric and positive definite. The quadratic form for $W$ is $\\mathbf{x}^\\top W \\mathbf{x} = (J^\\top \\mathbf{x})^\\top M^{-1} (J^\\top \\mathbf{x}) \\ge 0$, which shows $W$ is always positive semidefinite. For $W$ to be positive definite, we must have $\\mathbf{x}^\\top W \\mathbf{x}  0$ for all non-zero $\\mathbf{x} \\in \\mathbb{R}^q$. This requires that $J^\\top \\mathbf{x} \\neq \\mathbf{0}$ for all $\\mathbf{x} \\neq \\mathbf{0}$, which is true only if $J$ has full row rank. If $J$ is rank-deficient, there exists a non-zero vector $\\mathbf{z}$ in its left null space such that $\\mathbf{z}^\\top J = \\mathbf{0}$, which implies $J^\\top \\mathbf{z} = \\mathbf{0}$. For this vector, $\\mathbf{z}^\\top W \\mathbf{z} = 0$, proving that $W$ is only positive semidefinite, and therefore singular.\n$4$. The convergence of the classical Gauss-Seidel method for a linear system $A\\mathbf{x} = \\mathbf{b}$ is guaranteed if the matrix $A$ is symmetric and positive definite. While PGS is a nonlinear, projected method, its convergence behavior is strongly tied to the properties of $W$. For a symmetric positive semidefinite matrix, convergence is not guaranteed and failure modes like stalling or oscillation are common.\nThis statement correctly identifies the fundamental cause of the numerical difficulty.\n\nVerdict: **Correct**.\n\n**B. The Coulomb friction set at a contact, $\\mathcal{K} = \\{(\\lambda_n,\\boldsymbol{\\lambda}_t) \\in \\mathbb{R} \\times \\mathbb{R}^{m_t} : \\lambda_n \\ge 0,\\ \\lVert \\boldsymbol{\\lambda}_t \\rVert \\le \\mu \\lambda_n\\}$, is nonconvex, so projections can jump between disconnected regions, causing divergence.**\n\nThis statement is factually incorrect. The set $\\mathcal{K}$, known as the Coulomb friction cone, is a convex set. To prove this, consider two arbitrary points $\\boldsymbol{\\lambda}_1 = (\\lambda_{n,1}, \\boldsymbol{\\lambda}_{t,1})$ and $\\boldsymbol{\\lambda}_2 = (\\lambda_{n,2}, \\boldsymbol{\\lambda}_{t,2})$ in $\\mathcal{K}$. We must show that for any $\\theta \\in [0, 1]$, the convex combination $\\boldsymbol{\\lambda} = (1-\\theta)\\boldsymbol{\\lambda}_1 + \\theta\\boldsymbol{\\lambda}_2$ is also in $\\mathcal{K}$.\nThe normal component is $\\lambda_n = (1-\\theta)\\lambda_{n,1} + \\theta\\lambda_{n,2}$. Since $\\lambda_{n,1} \\ge 0$, $\\lambda_{n,2} \\ge 0$, and $(1-\\theta), \\theta \\ge 0$, it follows that $\\lambda_n \\ge 0$.\nThe tangential component is $\\boldsymbol{\\lambda}_t = (1-\\theta)\\boldsymbol{\\lambda}_{t,1} + \\theta\\boldsymbol{\\lambda}_{t,2}$. Using the triangle inequality for the norm, we have:\n$$ \\lVert \\boldsymbol{\\lambda}_t \\rVert \\le \\lVert (1-\\theta)\\boldsymbol{\\lambda}_{t,1} \\rVert + \\lVert \\theta\\boldsymbol{\\lambda}_{t,2} \\rVert = (1-\\theta)\\lVert \\boldsymbol{\\lambda}_{t,1} \\rVert + \\theta\\lVert \\boldsymbol{\\lambda}_{t,2} \\rVert $$\nSince $\\boldsymbol{\\lambda}_1, \\boldsymbol{\\lambda}_2 \\in \\mathcal{K}$, we know $\\lVert \\boldsymbol{\\lambda}_{t,1} \\rVert \\le \\mu \\lambda_{n,1}$ and $\\lVert \\boldsymbol{\\lambda}_{t,2} \\rVert \\le \\mu \\lambda_{n,2}$. Substituting gives:\n$$ \\lVert \\boldsymbol{\\lambda}_t \\rVert \\le (1-\\theta)(\\mu \\lambda_{n,1}) + \\theta(\\mu \\lambda_{n,2}) = \\mu ((1-\\theta)\\lambda_{n,1} + \\theta\\lambda_{n,2}) = \\mu \\lambda_n $$\nBoth conditions for membership in $\\mathcal{K}$ are satisfied. Thus, the Coulomb friction cone is a convex set. The projection onto a closed convex set is a unique and non-expansive operator. The premise of this statement is false, and therefore its conclusion is baseless.\n\nVerdict: **Incorrect**.\n\n**C. Using an over-relaxation factor $\\omega1$ in the local projected update can destabilize the iteration in tightly coupled contact loops such as arches, whereas under-relaxation $\\omega \\in (0,1]$ can improve stability.**\n\nThis statement describes the behavior of Successive Over-Relaxation (SOR) applied to PGS. The standard PGS iteration corresponds to a relaxation factor $\\omega = 1$.\n- Over-relaxation ($\\omega > 1$) attempts to accelerate convergence by taking larger steps. In a system with strong coupling between constraints, such as the arch where an impulse at one contact affects all others, an aggressive update can easily cause the iteration to \"overshoot\" the solution. This leads to oscillations between constraints, which can prevent convergence or lead to outright divergence. This is a known issue for SOR-type methods on ill-conditioned or highly coupled problems.\n- Under-relaxation ($0  \\omega  1$) takes smaller, more conservative steps. This has a damping effect on the iteration, which can stabilize the process and prevent the oscillations caused by strong coupling. While it typically slows down the rate of convergence, it is a standard and effective technique to achieve a converged solution for difficult problems where the standard PGS fails.\nThe statement correctly identifies a common failure mode and a valid practical remedy.\n\nVerdict: **Correct**.\n\n**D. Reordering the contacts to sweep along the presumed load path through the arch converts $W$ into a diagonally dominant matrix and therefore guarantees convergence of Gauss-Seidel.**\n\nThis statement makes two strong claims, both of which are incorrect for this system.\n$1$. Reordering the contacts corresponds to a symmetric permutation of the rows and columns of the Delassus operator $W$. While reordering can affect the performance of a Gauss-Seidel iteration, it cannot change the fundamental properties of the matrix, such as its spectrum of eigenvalues. As established in the analysis of statement A, $W$ is singular for this rigid arch system. A singular matrix cannot be made strictly or irreducibly diagonally dominant, because a matrix with these properties is non-singular. Furthermore, for a dense matrix $W$ arising from a rigid-body system, achieving diagonal dominance through permutation is generally impossible.\n$2$. Because the premise (conversion to a diagonally dominant matrix) is false, the conclusion (\"therefore guarantees convergence\") is invalid. Reordering cannot fix the singularity problem that lies at the heart of the convergence failure.\n\nVerdict: **Incorrect**.\n\n**E. Introducing a small normal compliance (regularization) at contacts effectively replaces the hard constraints by a penalized relation that renders $W$ positive definite on the active set, improving conditioning and restoring convergence of the iteration.**\n\nThis statement accurately describes the method of regularization.\n$1$. Replacing the \"hard\" Signorini non-penetration constraint ($g_n \\ge 0$) with a \"soft,\" compliant law (e.g., a penalty formulation where $\\lambda_n = k_n g_n$ if penetration $g_n  0$) introduces elasticity into the contact model.\n$2$. Mathematically, this corresponds to adding a positive term to the diagonal of the Delassus operator. The modified operator becomes $W_{reg} \\approx W + C^{-1}$, where $C$ is a diagonal matrix of compliance values (the inverse of penalty stiffnesses).\n$3$. The original operator $W$ is symmetric and positive semidefinite. The regularization term $C^{-1}$ is a diagonal matrix with strictly positive entries, so it is positive definite. The sum of a symmetric positive semidefinite matrix and a symmetric positive definite matrix is symmetric and positive definite. Thus, $W_{reg}$ is positive definite.\n$4$. By making the system matrix positive definite, the regularization removes the singularity that was the root cause of the PGS failure. With a positive definite operator, the theoretical conditions for the convergence of PGS are much more favorable. This technique is widely used in practice to stabilize simulations of over-constrained systems.\n\nVerdict: **Correct**.\n\nIn summary, statements A, C, and E provide correct insights into the problem. Statement A correctly diagnoses the fundamental mathematical origin of the failure. Statements C and E correctly identify valid remedies, with E addressing the fundamental issue diagnosed in A, and C providing a procedural modification to the algorithm.", "answer": "$$\\boxed{ACE}$$", "id": "2380870"}]}