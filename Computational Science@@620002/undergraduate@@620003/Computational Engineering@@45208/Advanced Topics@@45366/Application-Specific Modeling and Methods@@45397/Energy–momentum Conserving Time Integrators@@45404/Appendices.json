{"hands_on_practices": [{"introduction": "Our first practice gets to the heart of why structure-preserving integrators are so crucial in scientific computing. We will simulate a classic elastic collision, a fundamental interaction in physics, using two different numerical methods. This exercise [@problem_id:2444593] directly contrasts a general-purpose Runge-Kutta method with the symplectic Velocity Verlet algorithm, allowing you to observe firsthand the critical differences in long-term energy conservation and time-reversibility. Understanding this distinction is the first step toward building reliable and physically faithful simulations.", "problem": "Consider a one-dimensional Hamiltonian system of two identical point particles with positions $x_1(t)$ and $x_2(t)$, velocities $v_1(t)$ and $v_2(t)$, and mass $m$. The interaction is a steep, repulsive barrier described by the potential\n$$\nV(r) \\;=\\; \\varepsilon \\left(\\frac{\\sigma}{\\sqrt{r^2+\\delta^2}}\\right)^{12},\n$$\nwhere $r = x_2 - x_1$ is the signed separation, $\\varepsilon > 0$ sets the energy scale, $\\sigma > 0$ sets the length scale, and $\\delta > 0$ is a small softening parameter ensuring that $V(r)$ remains finite for $r \\to 0$. The Hamiltonian is\n$$\nH \\;=\\; \\frac{p_1^2}{2m} + \\frac{p_2^2}{2m} + V(x_2 - x_1),\n$$\nwith canonical momenta $p_i = m v_i$. The equations of motion are Hamilton’s equations,\n$$\n\\dot{x}_i \\;=\\; \\frac{\\partial H}{\\partial p_i} \\;=\\; \\frac{p_i}{m}, \\qquad \\dot{p}_i \\;=\\; -\\frac{\\partial H}{\\partial x_i},\n$$\nwhich are equivalent to Newton’s second law with forces derived from the potential. For the given $V(r)$ with signed $r = x_2 - x_1$, the force on particle $1$ is\n$$\nF_1 \\;=\\; -\\frac{\\partial V}{\\partial x_1} \\;=\\; \\frac{\\mathrm{d}V}{\\mathrm{d}r}, \\quad \\text{and on particle } 2 \\text{ is } \\quad F_2 \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r},\n$$\nwhere\n$$\n\\frac{\\mathrm{d}V}{\\mathrm{d}r} \\;=\\; -12\\,\\varepsilon\\,\\sigma^{12}\\,\\frac{r}{\\left(r^2+\\delta^2\\right)^{7}}.\n$$\n\nUse reduced units where $\\varepsilon = 1$, $\\sigma = 1$, and $m = 1$, so that energies are dimensionless multiples of $\\varepsilon$, lengths are in units of $\\sigma$, and time is in units of $\\tau = \\sigma \\sqrt{m/\\varepsilon}$. Angles do not appear. Initialize the system at time $t = 0$ with\n$$\nx_1(0) = -2.0, \\quad x_2(0) = +2.0, \\quad v_1(0) = +0.8, \\quad v_2(0) = -0.8,\n$$\nand use $\\delta = 10^{-2}$. Let the total integration time be $T = 8.0$.\n\nYour program must perform two independent numerical time integrations of the above system for each specified time step $\\Delta t$: one using the velocity Verlet (symplectic, second-order) method and one using the classical explicit fourth-order Runge–Kutta method. For each integration, compute the following quantitative diagnostics:\n- The absolute terminal energy error $|H(T) - H(0)|$.\n- The maximum relative energy error over the trajectory $\\max_{0 \\le t \\le T} |H(t) - H(0)| / |H(0)|$.\n- The velocity swap error at the final time, defined by the Euclidean norm between the final velocities and the expected head-on elastic scattering outcome for identical masses under a central repulsion. In reduced units for this setup, the expected final velocities after the interaction and re-separation are $v_1^\\star = -0.8$ and $v_2^\\star = +0.8$. The velocity swap error is\n$$\nE_{\\mathrm{swap}} \\;=\\; \\sqrt{\\left(v_1(T) - v_1^\\star\\right)^2 + \\left(v_2(T) - v_2^\\star\\right)^2}.\n$$\n- A time-reversibility error, computed by integrating forward from the initial state for time $T$ with a fixed $\\Delta t$, then integrating backward for time $T$ with the same algorithm and step magnitude but negative step size $-\\Delta t$, and comparing the result to the initial state. Define the time-reversibility error as the Euclidean norm in phase space,\n$$\nE_{\\mathrm{rev}} \\;=\\; \\sqrt{\\left(x_1^{\\mathrm{back}} - x_1(0)\\right)^2 + \\left(x_2^{\\mathrm{back}} - x_2(0)\\right)^2 + \\left(v_1^{\\mathrm{back}} - v_1(0)\\right)^2 + \\left(v_2^{\\mathrm{back}} - v_2(0)\\right)^2 }.\n$$\n\nTest Suite:\nUse the following three time steps $\\Delta t$:\n- $\\Delta t = 0.02$,\n- $\\Delta t = 0.005$,\n- $\\Delta t = 0.0005$.\nFor each $\\Delta t$, perform both integrations (velocity Verlet and classical explicit fourth-order Runge–Kutta) and report, in this order, the list of eight floating-point numbers\n$$\n\\left[\\, |H(T) - H(0)|_{\\mathrm{Verlet}},\\; |H(T) - H(0)|_{\\mathrm{RK4}},\\; \\max\\frac{|H - H(0)|}{|H(0)|}_{\\mathrm{Verlet}},\\; \\max\\frac{|H - H(0)|}{|H(0)|}_{\\mathrm{RK4}},\\; E_{\\mathrm{swap}}^{\\mathrm{Verlet}},\\; E_{\\mathrm{swap}}^{\\mathrm{RK4}},\\; E_{\\mathrm{rev}}^{\\mathrm{Verlet}},\\; E_{\\mathrm{rev}}^{\\mathrm{RK4}} \\,\\right].\n$$\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain one element per test case, where each element is itself a comma-separated list of the eight requested floating-point values enclosed in square brackets. For example, the overall format must be\n$$\n\\big[\\, [a_{11},a_{12},\\dots,a_{18}],\\; [a_{21},\\dots,a_{28}],\\; [a_{31},\\dots,a_{38}] \\,\\big].\n$$\nAll values are dimensionless in the specified reduced units. Do not print any additional text. The answer must be the complete runnable program that performs these computations and prints the single required line.", "solution": "The problem presented is a canonical exercise in computational physics, specifically concerning the numerical integration of Hamiltonian systems. It requires a comparative analysis of two different integration algorithms: the Velocity Verlet method, which belongs to the class of second-order symplectic integrators, and the classical explicit fourth-order Runge-Kutta (RK4) method, a general-purpose non-symplectic scheme. The purpose is to evaluate their performance on a one-dimensional, two-particle system governed by a steep repulsive potential. The evaluation is based on standard metrics for numerical integrators: conservation of energy, accuracy of phase-space trajectory, and time-reversibility. The problem is well-posed, scientifically grounded, and provides all necessary parameters and initial conditions for a complete solution.\n\nThe system is described by the Hamiltonian in reduced units ($m=1, \\varepsilon=1, \\sigma=1$):\n$$\nH(x_1, x_2, p_1, p_2) \\;=\\; \\frac{1}{2}(p_1^2 + p_2^2) + V(x_2 - x_1)\n$$\nwhere $p_i = v_i$ are the canonical momenta (since $m=1$), and the potential energy is given by:\n$$\nV(r) \\;=\\; \\left(\\frac{1}{\\sqrt{r^2+\\delta^2}}\\right)^{12} \\;=\\; (r^2+\\delta^2)^{-6}\n$$\nwith $r=x_2-x_1$ being the signed separation and $\\delta=10^{-2}$ a softening parameter.\n\nHamilton's equations of motion are $\\dot{x}_i = \\partial H / \\partial p_i$ and $\\dot{p}_i = -\\partial H / \\partial x_i$. These yield:\n$$\n\\dot{x}_i \\;=\\; p_i\n$$\n$$\n\\dot{p}_1 \\;=\\; -\\frac{\\partial V}{\\partial x_1} \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r}\\frac{\\partial r}{\\partial x_1} \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r}(-1) \\;=\\; \\frac{\\mathrm{d}V}{\\mathrm{d}r}\n$$\n$$\n\\dot{p}_2 \\;=\\; -\\frac{\\partial V}{\\partial x_2} \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r}\\frac{\\partial r}{\\partial x_2} \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r}(1) \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r}\n$$\nThe derivative of the potential with respect to the separation $r$ is:\n$$\n\\frac{\\mathrm{d}V}{\\mathrm{d}r} \\;=\\; -12\\,r\\,(r^2+\\delta^2)^{-7}\n$$\nSince mass is unitary, the accelerations are $a_i = \\dot{p}_i$. Therefore:\n$$\na_1(r) = -12\\,r\\,(r^2+\\delta^2)^{-7} \\quad \\text{and} \\quad a_2(r) = 12\\,r\\,(r^2+\\delta^2)^{-7}\n$$\nThese equations of motion are integrated numerically from the initial state $(x_1(0), x_2(0), v_1(0), v_2(0)) = (-2.0, 2.0, 0.8, -0.8)$ up to a final time $T=8.0$.\n\nThe two numerical integration methods are implemented as follows:\n\n1.  **Velocity Verlet Algorithm**: This is a geometric integrator, specifically a second-order symplectic method, which is also time-reversible. Its key feature for Hamiltonian systems is the long-term conservation of a nearby \"shadow\" Hamiltonian, which prevents secular energy drift. For a time step $\\Delta t$, the state is advanced from time $t$ to $t+\\Delta t$ via three steps:\n    1.  Update velocities by half a step: $v_i(t + \\Delta t/2) = v_i(t) + \\frac{1}{2} a_i(\\mathbf{x}(t)) \\Delta t$.\n    2.  Update positions by a full step: $x_i(t + \\Delta t) = x_i(t) + v_i(t + \\Delta t/2) \\Delta t$.\n    3.  Compute new accelerations $a_i(\\mathbf{x}(t+\\Delta t))$ and update velocities for the second half-step: $v_i(t + \\Delta t) = v_i(t + \\Delta t/2) + \\frac{1}{2} a_i(\\mathbf{x}(t + \\Delta t)) \\Delta t$.\n\n2.  **Classical Fourth-Order Runge-Kutta (RK4) Algorithm**: This is a widely used, high-accuracy, general-purpose integrator. It is not symplectic and not time-reversible. It typically exhibits superior accuracy for a given step size over short integration periods but suffers from systematic energy drift in long-term simulations of Hamiltonian systems. For a system of ODEs $\\dot{\\mathbf{y}} = \\mathbf{f}(t, \\mathbf{y})$, where the state vector is $\\mathbf{y} = (x_1, x_2, v_1, v_2)^T$, the update from $\\mathbf{y}_n$ to $\\mathbf{y}_{n+1}$ is:\n    $$\n    \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n)\n    $$\n    $$\n    \\mathbf{k}_2 = \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1)\n    $$\n    $$\n    \\mathbf{k}_3 = \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2)\n    $$\n    $$\n    \\mathbf{k}_4 = \\mathbf{f}(t_n + \\Delta t, \\mathbf{y}_n + \\Delta t \\mathbf{k}_3)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n    $$\n    Here, the derivative function is $\\mathbf{f}(\\mathbf{y}) = (v_1, v_2, a_1(x_1,x_2), a_2(x_1,x_2))^T$.\n\nFor each integrator and for each specified time step $\\Delta t \\in \\{0.02, 0.005, 0.0005\\}$, four diagnostic quantities are computed:\n- **Absolute terminal energy error**: $|H(T) - H(0)|$. For a symplectic integrator, this is expected to be small but may not be minimal, as the error is oscillatory. For RK4, this error is expected to show drift, growing over time.\n- **Maximum relative energy error**: $\\max_{0 \\le t \\le T} |H(t) - H(0)| / |H(0)|$. This measures the peak deviation of energy over the entire trajectory.\n- **Velocity swap error**: $E_{\\mathrm{swap}} = \\sqrt{(v_1(T) - v_1^\\star)^2 + (v_2(T) - v_2^\\star)^2}$, where $(v_1^\\star, v_2^\\star)=(-0.8, 0.8)$ are the expected final velocities for an ideal elastic collision. This metric quantifies the accuracy of the phase-space trajectory.\n- **Time-reversibility error**: $E_{\\mathrm{rev}}$. This is computed by integrating forward to time $T$ and then backward to time $0$ using a negative step size $-\\Delta t$. The error is the norm of the deviation of the final state from the initial one. A time-reversible algorithm like Verlet should yield a very small error, close to machine precision, whereas a non-reversible algorithm like RK4 will show a significant error that scales with $\\Delta t$.\n\nThe calculations are performed according to these principles, and the results are aggregated as specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-particle collision problem using Velocity Verlet and RK4 integrators.\n    \"\"\"\n    \n    # System parameters in reduced units\n    m = 1.0\n    epsilon = 1.0\n    sigma = 1.0\n    delta = 1.0e-2\n\n    # Initial conditions\n    x1_0, x2_0 = -2.0, 2.0\n    v1_0, v2_0 = 0.8, -0.8\n    initial_state = np.array([x1_0, x2_0, v1_0, v2_0])\n\n    # Simulation parameters\n    T_final = 8.0\n    test_dts = [0.02, 0.005, 0.0005]\n    \n    v1_star, v2_star = -0.8, 0.8\n\n    # Helper functions\n    def get_potential(r):\n        return (r**2 + delta**2)**(-6)\n\n    def get_accelerations(x1, x2):\n        r = x2 - x1\n        common_factor = -12.0 * r * (r**2 + delta**2)**(-7.0)\n        a1 = common_factor / m\n        a2 = -common_factor / m\n        return a1, a2\n\n    def get_hamiltonian(state):\n        x1, x2, v1, v2 = state\n        kinetic = 0.5 * m * (v1**2 + v2**2)\n        potential = get_potential(x2 - x1)\n        return kinetic + potential\n\n    def step_verlet(state, dt):\n        x1, x2, v1, v2 = state\n        a1_t, a2_t = get_accelerations(x1, x2)\n        \n        v1_half = v1 + 0.5 * a1_t * dt\n        v2_half = v2 + 0.5 * a2_t * dt\n        \n        x1_new = x1 + v1_half * dt\n        x2_new = x2 + v2_half * dt\n        \n        a1_t_dt, a2_t_dt = get_accelerations(x1_new, x2_new)\n        \n        v1_new = v1_half + 0.5 * a1_t_dt * dt\n        v2_new = v2_half + 0.5 * a2_t_dt * dt\n        \n        return np.array([x1_new, x2_new, v1_new, v2_new])\n        \n    def f_ode(state):\n        x1, x2, v1, v2 = state\n        a1, a2 = get_accelerations(x1, x2)\n        return np.array([v1, v2, a1, a2])\n\n    def step_rk4(state, dt):\n        k1 = f_ode(state)\n        k2 = f_ode(state + 0.5 * dt * k1)\n        k3 = f_ode(state + 0.5 * dt * k2)\n        k4 = f_ode(state + dt * k3)\n        return state + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\n    def run_simulation(stepper, dt):\n        num_steps = int(round(T_final / dt))\n        state = np.copy(initial_state)\n        \n        H0 = get_hamiltonian(state)\n        max_rel_H_err = 0.0\n\n        for _ in range(num_steps):\n            state = stepper(state, dt)\n            H_t = get_hamiltonian(state)\n            rel_H_err = abs(H_t - H0) / abs(H0)\n            if rel_H_err > max_rel_H_err:\n                max_rel_H_err = rel_H_err\n        \n        H_T = get_hamiltonian(state)\n        abs_term_H_err = abs(H_T - H0)\n        \n        v1_T, v2_T = state[2], state[3]\n        swap_err = np.sqrt((v1_T - v1_star)**2 + (v2_T - v2_star)**2)\n\n        # Time-reversibility test\n        state_fwd = np.copy(state) # state at T from forward run\n        state_bwd = np.copy(state_fwd)\n        for _ in range(num_steps):\n            state_bwd = stepper(state_bwd, -dt)\n        \n        rev_err = np.linalg.norm(state_bwd - initial_state)\n\n        return abs_term_H_err, max_rel_H_err, swap_err, rev_err\n\n    all_results = []\n    for dt in test_dts:\n        verlet_diags = run_simulation(step_verlet, dt)\n        rk4_diags = run_simulation(step_rk4, dt)\n\n        case_results = [\n            verlet_diags[0], rk4_diags[0],\n            verlet_diags[1], rk4_diags[1],\n            verlet_diags[2], rk4_diags[2],\n            verlet_diags[3], rk4_diags[3]\n        ]\n        all_results.append(case_results)\n    \n    # Format output string exactly as required\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]' for res in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2444593"}, {"introduction": "Having seen the importance of preserving the energy of a system, we now add another layer of complexity: geometric constraints. Many real-world systems, from robotic arms to molecules, are not free to move anywhere in space. This practice [@problem_id:2389083] challenges you to model a particle constrained to a spherical surface, a model for many rotational dynamics problems. You will implement an integrator that, by leveraging the exact geometry of the motion, perfectly conserves not only the energy and angular momentum but also the constraint itself, preventing any unphysical drift off the sphere.", "problem": "You are given the motion of a point mass constrained to the surface of a unit sphere. Let the position be $q(t)\\in\\mathbb{R}^3$ and the velocity be $\\dot{q}(t)\\in\\mathbb{R}^3$. The holonomic constraint is $q(t)^{\\top}q(t)=1$ for all $t$. The mass is $m=1$ and there is no external potential. The mechanical energy is $E=\\tfrac{1}{2}\\,\\dot{q}^{\\top}\\dot{q}$. The angular momentum is $L=q\\times\\dot{q}$. The initial velocity must satisfy $q(0)^{\\top}\\dot{q}(0)=0$. Angles must be interpreted in radians. Use dimensionless units.\n\nTask. Write a complete program that advances the dynamics over $N$ fixed steps of size $h$ for each test case, using a time integrator that maintains the constraint $q^{\\top}q=1$ at every step and is energy–momentum conserving for this system. For each test case, compute the maximum, over all time steps including the initial state, of the following three deviations:\n- Constraint deviation $\\delta_c=\\left|\\lVert q\\rVert-1\\right|$,\n- Energy deviation $\\delta_e=\\left|E(t)-E(0)\\right|$,\n- Angular momentum deviation $\\delta_{\\ell}=\\left\\|L(t)-L(0)\\right\\|$.\nFor each test case, produce a single float equal to $\\varepsilon=\\max\\{\\delta_c,\\delta_e,\\delta_{\\ell}\\}$ over the whole trajectory.\n\nTest suite. Use the following initial conditions and parameters. All vectors are written as column vectors in $\\mathbb{R}^3$:\n- Test case $1$ (general case):\n$$q_0=\\begin{bmatrix}1\\\\0\\\\0\\end{bmatrix}, \\quad \\dot{q}_0=\\begin{bmatrix}0\\\\1\\\\0\\end{bmatrix}, \\quad h=0.01, \\quad N=100.$$\n- Test case $2$ (boundary case with zero velocity):\n$$q_0=\\begin{bmatrix}0\\\\1\\\\0\\end{bmatrix}, \\quad \\dot{q}_0=\\begin{bmatrix}0\\\\0\\\\0\\end{bmatrix}, \\quad h=0.1, \\quad N=50.$$\n- Test case $3$ (full revolution):\n$$q_0=\\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}, \\quad \\dot{q}_0=\\begin{bmatrix}\\pi\\\\0\\\\0\\end{bmatrix}, \\quad h=0.2, \\quad N=10.$$\n- Test case $4$ (skew-axis, long integration):\n$$q_0=\\dfrac{1}{\\sqrt{3}}\\begin{bmatrix}1\\\\1\\\\1\\end{bmatrix}, \\quad \\dot{q}_0=s\\,\\dfrac{1}{\\sqrt{2}}\\begin{bmatrix}1\\\\-1\\\\0\\end{bmatrix} \\text{ with } s=0.75, \\quad h=0.037, \\quad N=1000.$$\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite, for example, $\\left[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4\\right]$. Each $\\varepsilon_i$ must be a real number (float).", "solution": "The problem statement has been analyzed and is determined to be valid. It is a well-posed problem in computational mechanics, free of scientific or logical inconsistencies. It provides all necessary data and defines a clear, objective task.\n\nThe system under consideration is a point mass with mass $m=1$ constrained to move on the surface of a unit sphere, described by the holonomic constraint $g(q) = q(t)^{\\top}q(t) - 1 = 0$. There is no external potential, so the Lagrangian is purely kinetic: $L(q, \\dot{q}) = \\frac{1}{2}\\dot{q}^{\\top}\\dot{q}$. The equations of motion are derived from the Euler-Lagrange equations for a constrained system, $\\ddot{q} = \\lambda \\nabla_q g(q)$, where $\\lambda$ is a Lagrange multiplier enforcing the constraint. Differentiating the constraint twice with respect to time yields $q^{\\top}\\ddot{q} + \\dot{q}^{\\top}\\dot{q} = 0$. Substituting the equation of motion and using $q^{\\top} q=1$, we find the Lagrange multiplier to be $\\lambda = -\\dot{q}^{\\top}\\dot{q}$. Thus, the continuous equation of motion is:\n$$ \\ddot{q} = -(\\dot{q}^{\\top}\\dot{q}) q $$\nThis equation describes geodesic motion on the sphere. The trajectory of the point mass follows a great circle.\n\nThe problem requires a time integrator that exactly conserves three quantities:\n$1$. The geometric constraint: $\\lVert q(t) \\rVert = 1$.\n$2$. The mechanical energy: $E(t) = \\frac{1}{2}\\dot{q}(t)^{\\top}\\dot{q}(t) = E(0)$.\n$3$. The angular momentum vector: $L(t) = q(t) \\times \\dot{q}(t) = L(0)$.\n\nStandard numerical integrators like Euler or Verlet methods do not satisfy these strict conservation properties for this system. It is necessary to construct an integrator based on the exact solution of the equations of motion. The exact solution for geodesic flow on a sphere is a rotation.\n\nLet the state at time $t_n$ be $(q_n, \\dot{q}_n)$. Let $\\omega_n = \\lVert \\dot{q}_n \\rVert$ be the speed. The energy is $E_n = \\frac{1}{2}\\omega_n^2$. If $\\omega_n = 0$, the particle is at rest and will remain so for all future times. If $\\omega_n > 0$, the motion occurs in the plane spanned by the orthonormal vectors $q_n$ and $v_n = \\dot{q}_n / \\omega_n$. The initial condition $q(0)^{\\top}\\dot{q}(0)=0$ ensures these vectors are orthogonal, and the dynamics preserve this property, as $d/dt(q^{\\top}\\dot{q}) = \\dot{q}^{\\top}\\dot{q} + q^{\\top}\\ddot{q} = \\dot{q}^{\\top}\\dot{q} - q^{\\top}((\\dot{q}^{\\top}\\dot{q})q) = \\|\\dot{q}\\|^2 - \\|\\dot{q}\\|^2 \\|q\\|^2 = 0$.\n\nThe exact trajectory starting from $q_n$ with velocity $\\dot{q}_n$ is given by Rodrigues' rotation formula, describing a rotation along a great circle:\n$$ q(t_n + \\tau) = q_n \\cos(\\omega_n \\tau) + v_n \\sin(\\omega_n \\tau) $$\nThe velocity is its time derivative:\n$$ \\dot{q}(t_n + \\tau) = -\\omega_n \\sin(\\omega_n \\tau) q_n + \\omega_n \\cos(\\omega_n \\tau) v_n $$\nThis analytical solution provides an exact map from the state at $t_n$ to the state at $t_{n+1} = t_n + h$. By using this map as our integrator, we satisfy all conservation requirements by construction, up to the limits of floating-point precision.\n\nThe algorithm for advancing the state from step $n$ to $n+1$ is as follows:\n$1$. Given the state $(q_n, \\dot{q}_n)$, calculate the speed $\\omega_n = \\lVert \\dot{q}_n \\rVert$.\n$2$. If $\\omega_n$ is zero (or numerically indistinguishable from zero), the particle is stationary. The state does not change: $q_{n+1} = q_n$ and $\\dot{q}_{n+1} = \\dot{q}_n = 0$.\n$3$. If $\\omega_n > 0$, define the normalized velocity vector $v_n = \\dot{q}_n / \\omega_n$.\n$4$. Calculate the rotation angle for the time step $h$: $\\theta = \\omega_n h$.\n$5$. Update the position and velocity using the exact solution map:\n$$ q_{n+1} = q_n \\cos(\\theta) + v_n \\sin(\\theta) $$\n$$ \\dot{q}_{n+1} = -\\omega_n \\sin(\\theta) q_n + \\omega_n \\cos(\\theta) v_n $$\n\nThis method will be implemented for each test case. A trajectory of $N+1$ states (from $t=0$ to $t=Nh$) will be generated. For each state $(q_k, \\dot{q}_k)$ in the trajectory, the deviations $\\delta_c = |\\lVert q_k \\rVert-1|$, $\\delta_e = |E_k - E_0|$, and $\\delta_{\\ell} = \\lVert L_k - L_0 \\rVert$ will be calculated. The final result for each test case, $\\varepsilon$, will be the maximum of these three deviations over the entire trajectory. Any non-zero values for $\\varepsilon$ will be attributable only to floating-point arithmetic errors, as the chosen integrator is analytically exact.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of integrating the motion of a point mass on a unit sphere\n    using an energy-momentum conserving integrator and calculating deviations.\n    \"\"\"\n    # Test suite definition\n    # Format: (q0, v0, h, N) where q0 and v0 are lists.\n    test_cases = [\n        (\n            [1.0, 0.0, 0.0],\n            [0.0, 1.0, 0.0],\n            0.01,\n            100\n        ),\n        (\n            [0.0, 1.0, 0.0],\n            [0.0, 0.0, 0.0],\n            0.1,\n            50\n        ),\n        (\n            [0.0, 0.0, 1.0],\n            [np.pi, 0.0, 0.0],\n            0.2,\n            10\n        ),\n        (\n            [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)],\n            [0.75/np.sqrt(2), -0.75/np.sqrt(2), 0.0],\n            0.037,\n            1000\n        )\n    ]\n\n    results = []\n\n    for case in test_cases:\n        q0_list, v0_list, h, N = case\n        q0 = np.array(q0_list, dtype=np.float64)\n        v0 = np.array(v0_list, dtype=np.float64)\n\n        # Store trajectory of positions and velocities\n        qs = [q0]\n        vs = [v0]\n\n        q_curr = q0\n        v_curr = v0\n\n        # Time integration loop\n        for _ in range(N):\n            omega = np.linalg.norm(v_curr)\n\n            # Epsilon for checking if omega is close to zero\n            if omega  np.finfo(float).eps:\n                q_next = q_curr\n                v_next = v_curr\n            else:\n                unit_v = v_curr / omega\n                theta = h * omega\n                \n                cos_theta = np.cos(theta)\n                sin_theta = np.sin(theta)\n\n                # Exact flow map for geodesic motion on a sphere\n                q_next = q_curr * cos_theta + unit_v * sin_theta\n                v_next = -omega * sin_theta * q_curr + omega * cos_theta * unit_v\n            \n            qs.append(q_next)\n            vs.append(v_next)\n            q_curr = q_next\n            v_curr = v_next\n\n        # Calculate initial conserved quantities\n        E0 = 0.5 * np.dot(v0, v0)\n        L0 = np.cross(q0, v0)\n\n        max_delta_c = 0.0\n        max_delta_e = 0.0\n        max_delta_l = 0.0\n\n        # Calculate maximum deviations over the trajectory\n        for i in range(N + 1):\n            q_i = qs[i]\n            v_i = vs[i]\n\n            # Constraint deviation\n            delta_c = np.abs(np.linalg.norm(q_i) - 1.0)\n\n            # Energy deviation\n            E_i = 0.5 * np.dot(v_i, v_i)\n            delta_e = np.abs(E_i - E0)\n            \n            # Angular momentum deviation\n            L_i = np.cross(q_i, v_i)\n            delta_l = np.linalg.norm(L_i - L0)\n\n            if delta_c > max_delta_c:\n                max_delta_c = delta_c\n            if delta_e > max_delta_e:\n                max_delta_e = delta_e\n            if delta_l > max_delta_l:\n                max_delta_l = delta_l\n        \n        epsilon = max(max_delta_c, max_delta_e, max_delta_l)\n        results.append(epsilon)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\nsolve()\n```", "id": "2389083"}, {"introduction": "Our final practice moves from the ideal world of conserved energy to the more realistic realm of dissipative systems. While the total mechanical energy in a system with friction is not conserved, the process of energy dissipation itself follows a strict physical law: the work-energy theorem. This exercise [@problem_id:2389054] guides you to develop a sophisticated integrator for a mass-spring system with dry friction that respects this principle at the discrete level. This ensures that the simulated energy loss is a faithful representation of physical dissipation, not an uncontrolled numerical artifact, a crucial skill for realistic engineering analysis.", "problem": "Implement an energy-balanced time integrator for a single-degree-of-freedom mass attached to a linear spring subject to dry friction (Coulomb friction), and verify a discrete energy balance using a set of prescribed test cases. The mechanical model is given by Newton's second law, the spring force law, and the Coulomb friction law. The continuous-time equations are\n$$\nM \\,\\ddot{x}(t) + k \\, x(t) + f_{\\mathrm{fric}}(\\dot{x}(t)) = 0,\n$$\nwith\n$$\nf_{\\mathrm{fric}}(\\dot{x}) \\in \\mu N \\,\\mathrm{Sign}(\\dot{x}),\n$$\nwhere $M$ is the mass, $k$ is the spring stiffness, $\\mu$ is the coefficient of friction, $N$ is the normal load, and $\\mathrm{Sign}(\\cdot)$ is the set-valued sign function defined by\n$$\n\\mathrm{Sign}(v) = \n\\begin{cases}\n\\{\\mathrm{sign}(v)\\},  \\text{if } v \\ne 0,\\\\\n[-1,1],  \\text{if } v = 0.\n\\end{cases}\n$$\nStarting only from the laws above and the discrete work-energy principle, design a time-stepping method over uniform steps of size $\\Delta t$ that uses midpoint kinematics and forces for the conservative part and introduces a single-step friction impulse consistent with the Coulomb set-valued law. Your method must satisfy a discrete energy balance in the form\n$$\nE_{n+1} - E_n + W_{\\mathrm{fric}}^{(n)} = 0 \\quad \\text{for each step } n,\n$$\nwhere $E_n$ is the mechanical energy at time step $n$ and $W_{\\mathrm{fric}}^{(n)}$ is the work of friction over step $n$ computed within your scheme. The mechanical energy is\n$$\nE_n = \\tfrac{1}{2} M v_n^2 + \\tfrac{1}{2} k x_n^2,\n$$\nwhere $x_n$ and $v_n$ denote the position and velocity at step $n$. Use only standard floating-point arithmetic; no symbolic manipulation is required.\n\nYour program must implement your derived integrator and, for each test case, simulate the system and compute the maximum absolute violation of the discrete energy balance over all time steps,\n$$\n\\max_n \\left| E_{n+1} - E_n + W_{\\mathrm{fric}}^{(n)} \\right|.\n$$\nThe value for each test case must be a floating-point number. No physical unit conversions are needed; report the result as a dimensionless floating-point number.\n\nUse the following test suite. Each test case specifies $(M,k,\\mu,N,\\Delta t, \\text{steps}, x_0, v_0)$:\n- Test $1$ (general sliding and sticking): $(M,k,\\mu,N,\\Delta t,\\text{steps},x_0,v_0) = (1.0, 50.0, 0.2, 1.5, 0.005, 4000, 0.1, 0.0)$.\n- Test $2$ (purely conservative limit): $(M,k,\\mu,N,\\Delta t,\\text{steps},x_0,v_0) = (1.0, 50.0, 0.0, 1.0, 0.005, 4000, 0.1, 0.2)$.\n- Test $3$ (threshold edge in one step, no spring): $(M,k,\\mu,N,\\Delta t,\\text{steps},x_0,v_0) = (1.0, 0.0, 0.8, 1.0, 1.0, 1, 0.0, 0.4)$.\n- Test $4$ (friction-only glide and stop): $(M,k,\\mu,N,\\Delta t,\\text{steps},x_0,v_0) = (1.0, 0.0, 0.05, 1.0, 0.01, 1000, 0.0, 1.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$r_1,r_2,r_3,r_4$]\"), where $r_i$ is the maximum absolute discrete energy-balance violation for test $i$ as defined above. No other output is allowed.", "solution": "The problem statement is evaluated as valid. It is scientifically grounded, well-posed, and objective, presenting a standard problem in computational mechanics. We will now proceed with the derivation of the required numerical integrator.\n\nThe objective is to construct a time-stepping scheme for the equation of motion $M \\ddot{x}(t) + k x(t) + f_{\\mathrm{fric}}(\\dot{x}(t)) = 0$ that satisfies a discrete energy balance by design. The foundation of the derivation is the discrete work-energy principle over a time interval $[t_n, t_{n+1}]$, where $t_{n+1} = t_n + \\Delta t$.\n\nThe change in kinetic energy from time $t_n$ to $t_{n+1}$ is equal to the total work done by all forces.\n$$\n\\Delta K^{(n)} = K_{n+1} - K_n = W_{\\mathrm{cons}}^{(n)} + W_{\\mathrm{fric,force}}^{(n)}\n$$\nwhere $K_n = \\frac{1}{2} M v_n^2$ is the kinetic energy, $W_{\\mathrm{cons}}^{(n)}$ is the work done by the conservative spring force, and $W_{\\mathrm{fric,force}}^{(n)}$ is the work done by the friction force. The conservative work is the negative change in potential energy, $W_{\\mathrm{cons}}^{(n)} = -(U_{n+1} - U_n)$, where $U_n = \\frac{1}{2} k x_n^2$. The work of the friction force leads to energy dissipation. Let $W_{\\mathrm{fric}}^{(n)}$ be the energy dissipated by friction over the step, which is the negative of the work done by the friction force, $W_{\\mathrm{fric}}^{(n)} = -W_{\\mathrm{fric,force}}^{(n)}$. Substituting these definitions yields:\n$$\n(K_{n+1} + U_{n+1}) - (K_n + U_n) + W_{\\mathrm{fric}}^{(n)} = 0\n$$\n$$\nE_{n+1} - E_n + W_{\\mathrm{fric}}^{(n)} = 0\n$$\nThis is the target discrete energy balance equation. Our task is to define the integrator updates and $W_{\\mathrm{fric}}^{(n)}$ such that this equation holds true.\n\nWe employ midpoint approximations for kinematics, as specified. The state at the midpoint of the interval, denoted by subscript $n+1/2$, is defined as:\n$$\nx_{n+1/2} = \\frac{x_n + x_{n+1}}{2}, \\quad v_{n+1/2} = \\frac{v_n + v_{n+1}}{2}\n$$\nThese imply the update rule for position:\n$$\nx_{n+1} - x_n = \\int_{t_n}^{t_{n+1}} \\dot{x}(t) \\, dt \\approx v_{n+1/2} \\Delta t\n$$\nNow, we rewrite the energy balance equation by factoring the difference of squares:\n$$\n\\frac{1}{2} M (v_{n+1} - v_n)(v_{n+1} + v_n) + \\frac{1}{2} k (x_{n+1} - x_n)(x_{n+1} + x_n) + W_{\\mathrm{fric}}^{(n)} = 0\n$$\nSubstituting the midpoint kinematic definitions:\n$$\nM (v_{n+1} - v_n) v_{n+1/2} + k (v_{n+1/2} \\Delta t) x_{n+1/2} + W_{\\mathrm{fric}}^{(n)} = 0\n$$\nFactoring out the midpoint velocity $v_{n+1/2}$ gives:\n$$\nv_{n+1/2} \\left[ M(v_{n+1} - v_n) + k x_{n+1/2} \\Delta t \\right] + W_{\\mathrm{fric}}^{(n)} = 0\n$$\nThis equation links the energy balance to the momentum balance. The discrete momentum balance is obtained by integrating the equation of motion over the time step, using a midpoint rule for the conservative force and defining a friction impulse $I_f^{(n)}$:\n$$\nM(v_{n+1} - v_n) = \\int_{t_n}^{t_{n+1}} (-k x(t) - f_{\\mathrm{fric}}(\\dot{x}(t))) dt \\approx -k x_{n+1/2} \\Delta t - I_f^{(n)}\n$$\nwhere $I_f^{(n)} = \\int_{t_n}^{t_{n+1}} f_{\\mathrm{fric}}(\\dot{x}(t)) dt$. This gives the discrete momentum equation:\n$$\nM(v_{n+1} - v_n) + k x_{n+1/2} \\Delta t + I_f^{(n)} = 0\n$$\nThe term in the square brackets in the energy equation is precisely $-I_f^{(n)}$ from the momentum equation. Substituting this provides a definition for the dissipated energy:\n$$\nv_{n+1/2} [-I_f^{(n)}] + W_{\\mathrm{fric}}^{(n)} = 0 \\implies W_{\\mathrm{fric}}^{(n)} = I_f^{(n)} v_{n+1/2}\n$$\nWith this definition, the discrete energy balance is satisfied by construction. The remaining task is to solve for the unknowns at each step. The system is defined by the update rules and the friction law. We first express all unknowns in terms of the midpoint velocity $v_{n+1/2}$ and the friction impulse $I_f^{(n)}$.\nFrom midpoint kinematics, we have $v_{n+1} = 2 v_{n+1/2} - v_n$ and $x_{n+1/2} = x_n + \\frac{1}{2} v_{n+1/2} \\Delta t$. Substituting these into the momentum equation yields:\n$$\nM((2v_{n+1/2} - v_n) - v_n) + k (x_n + \\frac{1}{2} v_{n+1/2} \\Delta t) \\Delta t + I_f^{(n)} = 0\n$$\n$$\n2M(v_{n+1/2} - v_n) + k x_n \\Delta t + \\frac{1}{2} k (\\Delta t)^2 v_{n+1/2} + I_f^{(n)} = 0\n$$\nGrouping terms with $v_{n+1/2}$:\n$$\n\\left( 2M + \\frac{1}{2} k (\\Delta t)^2 \\right) v_{n+1/2} + I_f^{(n)} = 2M v_n - k x_n \\Delta t\n$$\nLet us define $A = 2M + \\frac{1}{2} k (\\Delta t)^2$ and $B = 2M v_n - k x_n \\Delta t$. The equation becomes a compact algebraic relation:\n$$\nA v_{n+1/2} + I_f^{(n)} = B\n$$\nThe friction impulse $I_f^{(n)}$ must be consistent with the set-valued Coulomb law, which we apply at the midpoint: $I_f^{(n)} \\in (\\mu N \\Delta t) \\cdot \\mathrm{Sign}(v_{n+1/2})$. Let $P_f = \\mu N \\Delta t$ be the magnitude of the limit friction impulse. The law becomes $I_f^{(n)} \\in P_f \\cdot \\mathrm{Sign}(v_{n+1/2})$, which implies:\n1.  If $v_{n+1/2} > 0$, then $I_f^{(n)} = P_f$.\n2.  If $v_{n+1/2}  0$, then $I_f^{(n)} = -P_f$.\n3.  If $v_{n+1/2} = 0$, then $I_f^{(n)} \\in [-P_f, P_f]$. This is the stick condition.\n\nWe can solve for $v_{n+1/2}$ and $I_f^{(n)}$ by analyzing these cases. The quantity $B$ represents the impulse required from friction to enforce a sticking condition ($v_{n+1/2}=0$).\n- If this required sticking impulse $B$ is greater than the available friction impulse $P_f$ (i.e., $B > P_f$), the system must slide. The trial motion is positive (since $A v_{n+1/2} = B > 0$ if friction were zero), so the kinetic friction impulse must be $I_f^{(n)} = P_f$. This gives $A v_{n+1/2} + P_f = B$, so $v_{n+1/2} = (B - P_f)/A$. The result is positive, which is consistent.\n- If $B  -P_f$, the system must slide in the negative direction. The friction impulse is $I_f^{(n)} = -P_f$. This gives $A v_{n+1/2} - P_f = B$, so $v_{n+1/2} = (B + P_f)/A$. The result is negative, which is consistent.\n- If $|B| \\le P_f$, the required sticking impulse is within the capacity of static friction. The system sticks, so $v_{n+1/2} = 0$. The momentum balance then gives $I_f^{(n)} = B$. This is consistent with the stick condition $I_f^{(n)} \\in [-P_f, P_f]$.\n\nThe complete algorithm for a single time step from state $(x_n, v_n)$ to $(x_{n+1}, v_{n+1})$ is as follows:\n1.  Calculate auxiliary constants: $A = 2M + \\frac{1}{2} k (\\Delta t)^2$ and $P_f = \\mu N \\Delta t$.\n2.  Calculate the trial impulse: $B = 2M v_n - k x_n \\Delta t$.\n3.  Determine the friction state and solve for $v_{n+1/2}$ and $I_f^{(n)}$:\n    - If $B > P_f$: $I_f^{(n)} = P_f$ and $v_{n+1/2} = (B - P_f) / A$.\n    - Else if $B  -P_f$: $I_f^{(n)} = -P_f$ and $v_{n+1/2} = (B + P_f) / A$.\n    - Else: $I_f^{(n)} = B$ and $v_{n+1/2} = 0$.\n4.  Update the state variables: $v_{n+1} = 2 v_{n+1/2} - v_n$ and $x_{n+1} = x_n + v_{n+1/2} \\Delta t$.\n5.  For verification, calculate the energy balance violation:\n    $E_n = \\frac{1}{2} M v_n^2 + \\frac{1}{2} k x_n^2$\n    $E_{n+1} = \\frac{1}{2} M v_{n+1}^2 + \\frac{1}{2} k x_{n+1}^2$\n    $W_{\\mathrm{fric}}^{(n)} = I_f^{(n)} v_{n+1/2}$\n    The violation is $|E_{n+1} - E_n + W_{\\mathrm{fric}}^{(n)}|$.\n\nThis algorithm is implemented for each test case to find the maximum violation over the simulation period. Due to the construction, this violation is expected to be close to machine precision.", "answer": "```python\nimport numpy as np\n\ndef run_simulation(case):\n    \"\"\"\n    Simulates the mass-spring-friction system for one test case.\n\n    Args:\n        case (tuple): A tuple containing the parameters for the simulation:\n                      (M, k, mu, N, dt, steps, x0, v0).\n\n    Returns:\n        float: The maximum absolute violation of the discrete energy balance.\n    \"\"\"\n    M, k, mu, N, dt, steps, x_n, v_n = case\n    max_violation = 0.0\n\n    # Pre-calculate constants that do not change during the simulation\n    Pf_mag = mu * N * dt\n    A_const = 2.0 * M + 0.5 * k * dt**2\n\n    for _ in range(steps):\n        # 1. Calculate energy at step n\n        E_n = 0.5 * M * v_n**2 + 0.5 * k * x_n**2\n\n        # 2. Calculate trial impulse B\n        B_impulse = 2.0 * M * v_n - k * x_n * dt\n\n        # 3. Determine friction state and solve for midpoint velocity and friction impulse\n        if B_impulse > Pf_mag:\n            # Sliding with positive velocity\n            I_f = Pf_mag\n            v_mid = (B_impulse - Pf_mag) / A_const\n        elif B_impulse  -Pf_mag:\n            # Sliding with negative velocity\n            I_f = -Pf_mag\n            v_mid = (B_impulse + Pf_mag) / A_const\n        else:\n            # Sticking\n            I_f = B_impulse\n            v_mid = 0.0\n\n        # 4. Update state variables to step n+1\n        v_np1 = 2.0 * v_mid - v_n\n        x_np1 = x_n + v_mid * dt\n\n        # 5. Compute energy at n+1 and dissipated work to verify balance\n        E_np1 = 0.5 * M * v_np1**2 + 0.5 * k * x_np1**2\n        W_fric = I_f * v_mid\n        \n        violation = abs(E_np1 - E_n + W_fric)\n        if violation > max_violation:\n            max_violation = violation\n            \n        # 6. Update state for the next iteration\n        x_n = x_np1\n        v_n = v_np1\n        \n    return max_violation\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (M, k, mu, N, dt, steps, x0, v0)\n        (1.0, 50.0, 0.2, 1.5, 0.005, 4000, 0.1, 0.0),\n        (1.0, 50.0, 0.0, 1.0, 0.005, 4000, 0.1, 0.2),\n        (1.0, 0.0, 0.8, 1.0, 1.0, 1, 0.0, 0.4),\n        (1.0, 0.0, 0.05, 1.0, 0.01, 1000, 0.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        max_energy_violation = run_simulation(case)\n        results.append(max_energy_violation)\n\n    # Format and print the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2389054"}]}