{"hands_on_practices": [{"introduction": "To truly grasp the QR algorithm, it's essential to move beyond a purely theoretical understanding and perform the core calculations by hand. This first practice exercise guides you through two steps of the basic, unshifted QR algorithm. By manually computing the QR factorization and then applying the similarity transformation, you will build a concrete feel for the iterative process that underpins this powerful method for finding eigenvalues. [@problem_id:1057107]", "problem": "The QR algorithm is an iterative method used to find the eigenvalues and eigenvectors of a matrix. The basic (unshifted) algorithm starts with a matrix $A_0$ and generates a sequence of matrices $\\{A_k\\}_{k=0}^\\infty$ defined by the following procedure:\n1. For a given matrix $A_k$, compute its QR factorization, $A_k = Q_k R_k$, where $Q_k$ is an orthogonal matrix and $R_k$ is an upper triangular matrix with non-negative diagonal entries.\n2. The next matrix in the sequence is given by $A_{k+1} = R_k Q_k$.\n\nIt can be shown that all matrices $A_k$ are similar to $A_0$, as $A_{k+1} = (Q_k^{-1} A_k) Q_k = Q_k^T A_k Q_k$. Under certain conditions, the sequence $A_k$ converges to an upper triangular or quasi-triangular matrix (Schur form), revealing the eigenvalues of $A_0$.\n\nConsider a linear operator on $\\mathbb{R}^2$ whose matrix representation in the standard basis is given by\n$$\nA_0 = \\begin{pmatrix} 1 & 4 \\\\ 1 & 1 \\end{pmatrix}\n$$\nPerform two successive steps of the unshifted QR algorithm to generate the sequence $A_0 \\to A_1 \\to A_2$, which involves the orthogonal matrices $Q_0$ and $Q_1$.\n\nYour task is to compute the trace of the product of these first two orthogonal matrices, $\\text{Tr}(Q_0 Q_1)$.", "solution": "We perform two unshifted QR steps on \n$$A_0=\\begin{pmatrix}1&4\\\\1&1\\end{pmatrix}.$$\n1. QR of $A_0$.  Let \n\n$$\na_1=(1,1)^T,\\quad\\|a_1\\|=\\sqrt{2},\\quad e_1=\\frac{a_1}{\\sqrt2}=(1/\\sqrt2,1/\\sqrt2)^T.\n$$\n\n\n$$\na_2=(4,1)^T,\\quad e_1^Ta_2=\\frac{5}{\\sqrt2},\\quad\n\\mathrm{proj}_{e_1}a_2=\\frac{5}{2}(1,1)^T,\n$$\n\n\n$$\nu_2=a_2-\\mathrm{proj}_{e_1}a_2=(3/2,-3/2)^T,\\quad\\|u_2\\|=\\frac{3}{\\sqrt2},\\quad\ne_2=\\frac{u_2}{\\|u_2\\|}=(1/\\sqrt2,-1/\\sqrt2)^T.\n$$\n\nHence\n\n$$\nQ_0=\\frac1{\\sqrt2}\\begin{pmatrix}1&1\\\\1&-1\\end{pmatrix},\\quad\nR_0=Q_0^TA_0=\\begin{pmatrix}2/\\sqrt2&5/\\sqrt2\\\\0&3/\\sqrt2\\end{pmatrix},\n$$\n\n\n$$\nA_1=R_0Q_0\n=\\begin{pmatrix}7/2&-3/2\\\\3/2&-3/2\\end{pmatrix}.\n$$\n\n\n2. QR of $A_1$.  Let\n\n$$\na_1'=(7/2,\\,3/2)^T,\\quad\\|a_1'\\|=\\frac{\\sqrt{58}}2,\\quad\ne_1'=\\frac{1}{\\sqrt{58}}(7,3)^T,\n$$\n\n\n$$\na_2'=(-3/2,-3/2)^T,\\quad\ne_1'^Ta_2'=-\\frac{15}{\\sqrt{58}},\\quad\n\\mathrm{proj}_{e_1'}a_2'=-\\frac{15}{58}(7,3)^T,\n$$\n\n\n$$\nu_2'=a_2'-\\mathrm{proj}_{e_1'}a_2'=\\bigl(9/29,-21/29\\bigr)^T,\\quad\n\\|u_2'\\|=\\frac{3\\sqrt{58}}{29},\\quad\ne_2'=\\frac{1}{\\sqrt{58}}(3,-7)^T.\n$$\n\nThus\n\n$$\nQ_1=\\frac1{\\sqrt{58}}\\begin{pmatrix}7&3\\\\3&-7\\end{pmatrix}.\n$$\n\n\n3. Trace of $Q_0Q_1$.  Compute\n\n$$\nQ_0Q_1\n=\\begin{pmatrix}1/\\sqrt2&1/\\sqrt2\\\\1/\\sqrt2&-1/\\sqrt2\\end{pmatrix}\n\\frac1{\\sqrt{58}}\\begin{pmatrix}7&3\\\\3&-7\\end{pmatrix}\n=\\begin{pmatrix}5/\\sqrt{29}&\\ast\\\\\\ast&5/\\sqrt{29}\\end{pmatrix},\n$$\n\nso\n\n$$\n\\mathrm{Tr}(Q_0Q_1)\n=\\frac{5}{\\sqrt{29}}+\\frac{5}{\\sqrt{29}}\n=\\frac{10}{\\sqrt{29}}.\n$$", "answer": "$$\\boxed{\\frac{10}{\\sqrt{29}}}$$", "id": "1057107"}, {"introduction": "The unshifted QR algorithm, while foundational, can converge slowly. The key to unlocking its practical power lies in the 'shifted QR' variant. This exercise serves as a critical thought experiment to explore the ideal case: what happens when the chosen shift is an exact eigenvalue? By working through the logic, you'll uncover the mechanism of 'deflation,' where an eigenvalue is precisely isolated, revealing the core principle that makes an intelligent shifting strategy so effective. [@problem_id:2445523]", "problem": "Let $A \\in \\mathbb{R}^{n\\times n}$ be an unreduced upper Hessenberg matrix, and consider performing one implicit single-shift Francis orthogonal-triangular (QR) step in exact arithmetic with a real shift $\\sigma \\in \\mathbb{R}$. By definition of the Francis step, one computes the orthogonal-triangular (QR) factorization\n$$A - \\sigma I = Q R,$$\nwith $Q \\in \\mathbb{R}^{n\\times n}$ orthogonal and $R \\in \\mathbb{R}^{n\\times n}$ upper triangular, and then forms the updated matrix\n$$A_{+} = R Q + \\sigma I = Q^{\\mathsf T} A Q,$$\nwhich is orthogonally similar to $A$ and maintains upper Hessenberg structure. Suppose that the chosen shift $\\sigma$ is exactly equal to an eigenvalue of $A$, that is, $\\det(A - \\sigma I) = 0$. In exact arithmetic, which of the following statements is true?\n\nA. After this single step, the updated matrix $A_{+}$ is orthogonally similar to $A$ and has its trailing subdiagonal entry $a^{(+)}_{n,n-1}$ exactly equal to $0$, so $A_{+}$ is block upper triangular with a trailing $1\\times 1$ block equal to $\\sigma$ (immediate deflation).\n\nB. The factorization $A - \\sigma I = Q R$ fails to exist because $A - \\sigma I$ is singular, so the Francis step is undefined.\n\nC. The updated matrix satisfies $A_{+} = A$, so the iteration stagnates and no progress is made.\n\nD. The step destroys the upper Hessenberg structure; $A_{+}$ is generally dense even in exact arithmetic.\n\nE. The matrix $Q$ obtained in $A - \\sigma I = Q R$ is not orthogonal, that is, $Q^{\\mathsf T} Q \\neq I$, because $A - \\sigma I$ is singular.", "solution": "The problem statement must first be validated for scientific soundness, self-consistency, and clarity before a solution is attempted.\n\n### Step 1: Extract Givens\n\nThe givens are:\n1.  $A \\in \\mathbb{R}^{n\\times n}$ is an unreduced upper Hessenberg matrix. This implies that $a_{i,j} = 0$ for $i > j+1$ and $a_{i+1,i} \\neq 0$ for all $i \\in \\{1, 2, \\dots, n-1\\}$.\n2.  A single Francis QR step with a real shift $\\sigma \\in \\mathbb{R}$ is performed in exact arithmetic.\n3.  The step is defined by the QR factorization $A - \\sigma I = Q R$, where $Q$ is orthogonal ($Q^{\\mathsf T} Q = I$) and $R$ is upper triangular.\n4.  The updated matrix is $A_{+} = R Q + \\sigma I$.\n5.  It is given that $A_{+} = Q^{\\mathsf T} A Q$, confirming orthogonal similarity and the preservation of the upper Hessenberg structure.\n6.  The shift $\\sigma$ is an exact eigenvalue of $A$: $\\det(A - \\sigma I) = 0$.\n7.  The task is to determine which of the provided statements is true under these conditions.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement describes a specific, well-known scenario in numerical linear algebra: the behavior of the QR algorithm when an exact eigenvalue is used as a shift. The concepts—unreduced Hessenberg matrices, QR factorization, Francis step, eigenvalues—are standard and precisely defined. The assumption of exact arithmetic is a common theoretical device used to analyze algorithms without the complication of floating-point errors. The premises are mutually consistent and sufficient to derive a unique conclusion. The problem is scientifically grounded, well-posed, and objective. It is therefore valid.\n\n### Step 3: Derivation of the Correct Answer\n\nThe core of the problem lies in the properties of the QR factorization of the singular matrix $M = A - \\sigma I$.\n\nFirst, let us analyze the structure of $M = A - \\sigma I$. Since $A$ is an unreduced upper Hessenberg matrix, its subdiagonal entries $a_{i+1,i}$ are all non-zero for $i = 1, \\dots, n-1$. The matrix $M$ is also upper Hessenberg, and its subdiagonal entries are identical to those of $A$, so $m_{i+1,i} = a_{i+1,i} \\neq 0$ for $i=1, \\dots, n-1$. Therefore, $M$ is also an unreduced upper Hessenberg matrix.\n\nA critical property of an $n \\times n$ unreduced upper Hessenberg matrix is that its first $n-1$ columns are linearly independent. We can prove this by contradiction. Suppose a non-trivial linear combination of the first $k$ columns is the zero vector, for some $k \\le n-1$: $\\sum_{j=1}^{k} c_j \\mathbf{m}_j = \\mathbf{0}$, where $\\mathbf{m}_j$ is the $j$-th column of $M$ and not all $c_j$ are zero. Let $k$ be the largest index for which $c_k \\neq 0$. Looking at the $(k+1)$-th row of this vector equation, we have $\\sum_{j=1}^{k} c_j m_{k+1,j} = 0$. Since $M$ is upper Hessenberg, $m_{k+1,j} = 0$ for $j < k$. The equation simplifies to $c_k m_{k+1,k} = 0$. As $M$ is unreduced, $m_{k+1,k} \\neq 0$. This forces $c_k=0$, which contradicts our assumption that $c_k \\neq 0$. Therefore, the first $n-1$ columns of $M$ must be linearly independent.\n\nWe are given that $\\sigma$ is an eigenvalue of $A$, which means the matrix $M = A - \\sigma I$ is singular, i.e., its rank is less than $n$. Since we have established that its first $n-1$ columns are linearly independent, the rank of $M$ must be exactly $n-1$. This implies that the last column, $\\mathbf{m}_n$, must be a linear combination of the preceding $n-1$ columns.\n\nNow, consider the QR factorization $M = QR$. The columns of $Q$, denoted $\\mathbf{q}_1, \\dots, \\mathbf{q}_n$, form an orthonormal basis. The relationship between $M$ and $R$ is given by $R = Q^{\\mathsf T} M$. The diagonal entries of the upper triangular matrix $R$ are $r_{kk} = \\mathbf{q}_k^{\\mathsf T} \\mathbf{m}_k$. In the context of the Gram-Schmidt process, $|r_{kk}|$ is the norm of the component of $\\mathbf{m}_k$ that is orthogonal to the subspace spanned by $\\{\\mathbf{m}_1, \\dots, \\mathbf{m}_{k-1}\\}$.\nSince the first $n-1$ columns of $M$ are linearly independent, $r_{kk} \\neq 0$ for $k=1, \\dots, n-1$.\nHowever, for the last column, $\\mathbf{m}_n$ is in the span of $\\{\\mathbf{m}_1, \\dots, \\mathbf{m}_{n-1}\\}$. The subspace spanned by $\\{\\mathbf{m}_1, \\dots, \\mathbf{m}_{n-1}\\}$ is identical to the subspace spanned by the orthonormal vectors $\\{\\mathbf{q}_1, \\dots, \\mathbf{q}_{n-1}\\}$. Therefore, $\\mathbf{m}_n$ is orthogonal to $\\mathbf{q}_n$. Consequently, the last diagonal entry of $R$ is $r_{nn} = \\mathbf{q}_n^{\\mathsf T} \\mathbf{m}_n = 0$.\n\nSince $R$ is an upper triangular matrix and its last diagonal element $r_{nn}$ is zero, the entire last row of $R$ must be zero. That is, $R_{n,j} = 0$ for all $j=1, \\dots, n$.\n\nNow we analyze the updated matrix $A_{+} = R Q + \\sigma I$. Let us examine its last row.\nThe last row of the product $RQ$ is the product of the last row of $R$ and the matrix $Q$. Since the last row of $R$ is a zero vector, the last row of $RQ$ is also a zero vector.\nThe last row of $\\sigma I$ is $[0, 0, \\dots, 0, \\sigma]$.\nTherefore, the last row of $A_{+}$ is the sum of these two rows, which gives $[0, 0, \\dots, 0, \\sigma]$.\n\nThis result for the last row of $A_{+}$ implies two things:\n1.  The entry $a^{(+)}_{n,n-1} = 0$.\n2.  The entry $a^{(+)}_{n,n} = \\sigma$.\n\nThe fact that $a^{(+)}_{n,n-1} = 0$ means the matrix $A_+$ is no longer unreduced. It has a block upper triangular structure:\n$$ A_{+} =\n\\begin{pmatrix}\nA'_{11} & A'_{12} \\\\\n\\mathbf{0} & \\sigma\n\\end{pmatrix}\n$$\nwhere $A'_{11}$ is an $(n-1) \\times (n-1)$ upper Hessenberg matrix. This phenomenon is known as deflation, as the eigenvalue $\\sigma$ has been successfully isolated, and the problem is reduced to finding the eigenvalues of the smaller matrix $A'_{11}$.\n\n### Evaluation of Options\n\n**A. After this single step, the updated matrix $A_{+}$ is orthogonally similar to $A$ and has its trailing subdiagonal entry $a^{(+)}_{n,n-1}$ exactly equal to $0$, so $A_{+}$ is block upper triangular with a trailing $1\\times 1$ block equal to $\\sigma$ (immediate deflation).**\nThis statement is a perfect summary of our derivation.\n- $A_{+} = Q^{\\mathsf T} A Q$, so it is orthogonally similar to $A$. Correct.\n- $a^{(+)}_{n,n-1} = 0$. Correct.\n- $A_{+}$ is block upper triangular with the trailing $1 \\times 1$ block $a^{(+)}_{n,n} = \\sigma$. Correct.\nThis process is called immediate deflation. Thus, the statement is entirely correct.\n**Verdict: Correct.**\n\n**B. The factorization $A - \\sigma I = Q R$ fails to exist because $A - \\sigma I$ is singular, so the Francis step is undefined.**\nA QR factorization exists for any real or complex matrix, regardless of its rank or whether it is singular. The singularity of the matrix only implies that at least one diagonal entry of the $R$ factor will be zero. The statement is fundamentally incorrect.\n**Verdict: Incorrect.**\n\n**C. The updated matrix satisfies $A_{+} = A$, so the iteration stagnates and no progress is made.**\n$A_{+} = R Q + \\sigma I$ and $A = Q R + \\sigma I$. $A_{+} = A$ would imply $RQ=QR$. In general, matrices do not commute. $Q$ and $R$ do not commute unless they have a very special structure, which is not the case here. As our derivation for A shows, $A_{+} \\neq A$, and significant progress (deflation) is made.\n**Verdict: Incorrect.**\n\n**D. The step destroys the upper Hessenberg structure; $A_{+}$ is generally dense even in exact arithmetic.**\nThis contradicts a fundamental property of the Francis QR step. As given in the problem statement and known from theory, if $A$ is upper Hessenberg, then $A_{+} = Q^{\\mathsf T} A Q$ is also upper Hessenberg. Citing the implicit Q theorem, the structure is preserved.\n**Verdict: Incorrect.**\n\n**E. The matrix $Q$ obtained in $A - \\sigma I = Q R$ is not orthogonal, that is, $Q^{\\mathsf T} Q \\neq I$, because $A - \\sigma I$ is singular.**\nThe QR factorization, by its very definition, produces an orthogonal matrix $Q$. Standard algorithms for computing it, such as those based on Householder reflections or Givens rotations, construct $Q$ as a product of orthogonal matrices, which is itself orthogonal. The singularity of the matrix being factorized affects the $R$ factor, not the orthogonality of the $Q$ factor.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "2445523"}, {"introduction": "Now it's time to synthesize the core iteration and the concept of shifting into a fully functional algorithm. This final practice challenges you to implement a complete QR eigenvalue solver for symmetric matrices, a cornerstone of computational engineering. You will translate theory into code, integrating a sophisticated shifting strategy (the Wilkinson shift) with a robust deflation criterion to build a practical and efficient numerical tool from first principles. [@problem_id:2445542]", "problem": "Implement a complete program that computes the real eigenvalues of real symmetric matrices using the orthogonal-triangular (QR) factorization with deflation. The core computational task is to design a robust similarity-iteration scheme based only on the following well-tested facts and core definitions:\n\n- For a real square matrix $A \\in \\mathbb{R}^{n \\times n}$, a scalar $\\lambda \\in \\mathbb{R}$ is an eigenvalue if there exists a nonzero vector $x \\in \\mathbb{R}^{n}$ such that $A x = \\lambda x$.\n- For any real square matrix $A$, there exists an orthogonal matrix $Q$ and an upper triangular matrix $R$ such that $A = Q R$.\n- Orthogonal similarity preserves eigenvalues: if $Q^{\\top} Q = I$ then $A$ and $Q^{\\top} A Q$ have the same multiset of eigenvalues.\n- If a real symmetric matrix is (exactly or approximately) block diagonal, the eigenvalues are the union of the eigenvalues of its diagonal blocks; this motivates deflation when a subdiagonal entry is sufficiently small.\n\nYour program must implement a shifted QR iteration with explicit deflation:\n\n- At each step on an active leading principal submatrix of size $m \\times m$, apply a single-shift QR step that uses a Wilkinson-type shift $\\mu$ constructed from the trailing $2 \\times 2$ principal submatrix.\n- Form $A_{k} - \\mu I = Q R$ and then update $A_{k+1} = R Q + \\mu I$, which is orthogonally similar to $A_{k}$.\n- Use a deflation criterion that regards the subdiagonal element $|a_{m,m-1}|$ as negligible when $|a_{m,m-1}| \\le \\tau \\cdot \\left(|a_{m-1,m-1}| + |a_{m,m}|\\right)$, for a user-specified tolerance $\\tau$. Upon deflation, lock $a_{m,m}$ as a converged eigenvalue, reduce $m \\leftarrow m - 1$, and continue on the reduced leading principal submatrix. When $m = 1$, lock the last diagonal entry.\n- Assume all input matrices are real symmetric. Angles do not appear in this task. No physical units are involved.\n\nNumerical requirements and constraints:\n\n- Use a relative deflation tolerance $\\tau = 10^{-12}$ and a hard iteration cap $K_{\\max} = 10000$ iterations for the entire run on a single matrix. If the iteration cap is reached before all deflations occur, return the current diagonal entries of the active block as the remaining eigenvalue estimates.\n- After each similarity step, you may enforce symmetry of the active block by averaging it with its transpose to counteract floating-point asymmetry.\n\nTest suite:\n\nYour program must run on the following matrices. Each matrix must be treated as a separate test case.\n\n- Test case $1$ (size $3 \\times 3$): \n  $$\n  A_{1} = \\begin{bmatrix}\n  4 & 1 & 0 \\\\\n  1 & 3 & 1 \\\\\n  0 & 1 & 2\n  \\end{bmatrix}.\n  $$\n- Test case $2$ (size $5 \\times 5$): a tridiagonal Toeplitz matrix with $2$ on the diagonal and $-1$ on the first sub- and super-diagonals,\n  $$\n  A_{2} = \\begin{bmatrix}\n  2 & -1 & 0 & 0 & 0 \\\\\n  -1 & 2 & -1 & 0 & 0 \\\\\n  0 & -1 & 2 & -1 & 0 \\\\\n  0 & 0 & -1 & 2 & -1 \\\\\n  0 & 0 & 0 & -1 & 2\n  \\end{bmatrix}.\n  $$\n- Test case $3$ (size $2 \\times 2$): nearly diagonal with immediately deflatable subdiagonal,\n  $$\n  A_{3} = \\begin{bmatrix}\n  2 & 10^{-12} \\\\\n  10^{-12} & 2\n  \\end{bmatrix}.\n  $$\n- Test case $4$ (size $1 \\times 1$): \n  $$\n  A_{4} = \\begin{bmatrix}\n  7\n  \\end{bmatrix}.\n  $$\n\nRequired output format:\n\n- For each test case, compute all real eigenvalues using the described QR iteration with deflation. Sort the eigenvalues in nondecreasing order and round each eigenvalue to $8$ decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list of rounded eigenvalues for one test case in the order $A_{1}, A_{2}, A_{3}, A_{4}$. For example, the overall shape must be \n  $$\n  [ [\\cdot,\\cdots,\\cdot], [\\cdot,\\cdots,\\cdot], [\\cdot,\\cdots,\\cdot], [\\cdot] ].\n  $$\n\nAnswer type:\n\n- Each test case’s answer is a list of floats. The final output is thus a list of lists of floats, printed on a single line in the exact format described above.", "solution": "The problem as stated is scientifically grounded, well-posed, objective, and self-contained. It describes a standard and important numerical algorithm from computational linear algebra, the QR iteration with Wilkinson shifts for finding eigenvalues of real symmetric matrices. All parameters, base principles, and test cases are provided with sufficient clarity and precision to permit a unique and verifiable solution. The problem is therefore valid.\n\nThe task is to compute the real eigenvalues of a given real symmetric matrix $A \\in \\mathbb{R}^{n \\times n}$. The prescribed method is the QR algorithm with a specific shifting strategy and a deflation criterion. This iterative algorithm generates a sequence of matrices, $A_0, A_1, A_2, \\dots$, that are all orthogonally similar to the original matrix $A_0 = A$, and which converge to a diagonal matrix whose diagonal entries are the eigenvalues of $A$.\n\nThe fundamental principle is that an orthogonal similarity transformation preserves eigenvalues. If $A = Q R$ where $Q$ is orthogonal ($Q^{\\top}Q = I$) and $R$ is upper triangular, the basic QR iteration defines the next matrix in the sequence as $A_1 = R Q$. This new matrix $A_1$ is orthogonally similar to $A$ because $A_1 = R Q = (Q^{\\top}A) Q = Q^{\\top}A Q$. For a symmetric matrix $A$, the sequence $\\{A_k\\}$ converges to a diagonal matrix.\n\nTo accelerate convergence, especially for symmetric matrices, a shift of origin $\\mu_k$ is introduced at each step $k$. The iteration becomes:\n$1$. Choose a shift $\\mu_k$.\n$2$. Factor the shifted matrix: $A_k - \\mu_k I = Q_k R_k$.\n$3$. Compute the next iterate: $A_{k+1} = R_k Q_k + \\mu_k I$.\nThis transformation also preserves eigenvalues: $A_{k+1} = R_k Q_k + \\mu_k I = (Q_k^{\\top}(A_k - \\mu_k I))Q_k + \\mu_k I = Q_k^{\\top}A_k Q_k - \\mu_k Q_k^{\\top}I Q_k + \\mu_k I = Q_k^{\\top}A_k Q_k - \\mu_k I + \\mu_k I = Q_k^{\\top}A_k Q_k$. Thus, $A_{k+1}$ is orthogonally similar to $A_k$. A good choice of shift $\\mu_k$ can dramatically improve the rate of convergence.\n\nThe algorithm as specified operates on a progressively smaller leading principal submatrix of size $m \\times m$, where $m$ initially equals $n$. The main process continues until all eigenvalues are found ($m=0$) or a maximum iteration count $K_{\\max} = 10000$ is reached.\n\nAt each stage, the algorithm first checks for deflation. This is a crucial step for efficiency. An eigenvalue is considered converged if the corresponding off-diagonal element becomes negligible. The problem specifies an explicit deflation strategy focused on the trailing element of the active submatrix. If the subdiagonal entry $|a_{m,m-1}|$ satisfies the condition\n$$\n|a_{m,m-1}| \\le \\tau \\cdot \\left(|a_{m-1,m-1}| + |a_{m,m}|\\right)\n$$\nwith a tolerance $\\tau = 10^{-12}$, then the trailing diagonal element $a_{m,m}$ is accepted as a converged eigenvalue. The active matrix size is then reduced by one ($m \\leftarrow m - 1$), and the process continues on the new, smaller $(m-1) \\times (m-1)$ submatrix. If $m=1$, the single element $a_{1,1}$ is immediately declared an eigenvalue.\n\nIf the deflation criterion is not met, a single shifted QR step is performed on the current $m \\times m$ active submatrix. The specified shift is the Wilkinson shift, a highly effective choice for symmetric matrices known to yield asymptotic cubic convergence. The Wilkinson shift $\\mu$ is determined by examining the trailing $2 \\times 2$ principal submatrix of the active block:\n$$\n\\begin{bmatrix}\na_{m-2,m-2} & a_{m-2,m-1} \\\\\na_{m-1,m-2} & a_{m-1,m-1}\n\\end{bmatrix}\n$$\nLetting $d = a_{m-1,m-1}$, $a = a_{m-2,m-2}$, $b = a_{m-1,m-2}$, and $\\delta = (a - d)/2$, the shift $\\mu$ is the eigenvalue of this $2 \\times 2$ matrix that is closer to $d$. A numerically stable formula for this shift is:\n$$\n\\mu = d - \\frac{b^2}{\\delta + \\operatorname{sgn}(\\delta) \\sqrt{\\delta^2 + b^2}}\n$$\nIf $\\delta = 0$, the formula simplifies to $\\mu = d - |b|$. After computing $\\mu$, the QR step $A_k - \\mu I = QR$ and update $A_{k+1} = RQ + \\mu I$ are performed on the $m \\times m$ submatrix.\n\nDue to floating-point arithmetic, the matrix may lose perfect symmetry after an update. To counteract this, symmetry is enforced after each step by averaging the matrix with its transpose: $A \\leftarrow (A + A^{\\top}) / 2$.\n\nIf the iteration count $K_{\\max}$ is exhausted before all eigenvalues have converged (i.e., $m>0$), the algorithm terminates, and the diagonal entries of the remaining $m \\times m$ active submatrix are returned as the estimates for the remaining eigenvalues.\n\nFinally, all computed eigenvalues for a given matrix are collected, sorted in nondecreasing order, and rounded to $8$ decimal places as required. This procedure is applied independently to each test case matrix.", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the eigenvalue computation on the test suite.\n    \"\"\"\n\n    def qr_eigenvalues(A_orig: np.ndarray, tol: float, max_iter: int):\n        \"\"\"\n        Computes the eigenvalues of a real symmetric matrix using the QR algorithm\n        with Wilkinson shifts and explicit deflation.\n\n        Args:\n            A_orig: The input real symmetric matrix.\n            tol: The relative tolerance for deflation.\n            max_iter: The maximum number of iterations allowed for the entire matrix.\n\n        Returns:\n            A list of computed eigenvalues, sorted in nondecreasing order.\n        \"\"\"\n        A = A_orig.copy().astype(np.float64)\n        n = A.shape[0]\n        m = n\n        eigenvalues = []\n        total_iters = 0\n\n        while m > 0:\n            if total_iters >= max_iter:\n                # Iteration cap reached, return current diagonal entries of active block.\n                for i in range(m):\n                    eigenvalues.append(A[i, i])\n                break\n\n            if m == 1:\n                eigenvalues.append(A[0, 0])\n                m = 0\n                continue\n\n            # Check for deflation at the bottom of the active submatrix\n            sub_diag_val = A[m - 1, m - 2]\n            diag1 = A[m - 2, m - 2]\n            diag2 = A[m - 1, m - 1]\n            \n            # The deflation criterion check. The epsilon is to prevent division by zero in rare cases.\n            if abs(sub_diag_val) <= tol * (abs(diag1) + abs(diag2)) + np.finfo(float).eps:\n                eigenvalues.append(diag2)\n                m -= 1\n                # After deflation, we might be able to deflate again, so continue the loop\n                continue\n\n            # No deflation, perform a shifted QR step on the active m x m submatrix\n            active_block = A[:m, :m]\n\n            # Calculate the Wilkinson shift from the trailing 2x2 submatrix\n            d = active_block[m - 1, m - 1]\n            a = active_block[m - 2, m - 2]\n            b = active_block[m - 1, m - 2]\n            \n            delta = (a - d) / 2.0\n            \n            if delta == 0.0:\n                 # Handle the case where the denominator in the main formula would be zero.\n                 # This can happen if delta is zero. Eigenvalues are d +/- |b|.\n                 # Convention is to pick one, e.g., the one further from d.\n                 mu = d - abs(b)\n            else:\n                 # Numerically stable formula for the eigenvalue of the 2x2 submatrix closer to d.\n                 mu = d - (b**2) / (delta + np.sign(delta) * np.sqrt(delta**2 + b**2))\n\n            # Perform the QR decomposition and update step\n            I = np.identity(m)\n            Q, R = scipy.linalg.qr(active_block - mu * I, mode='full')\n            \n            updated_block = R @ Q + mu * I\n            \n            # Enforce symmetry to counteract floating-point errors\n            A[:m, :m] = (updated_block + updated_block.T) / 2.0\n            \n            total_iters += 1\n            \n        return sorted(eigenvalues)\n\n    # Numerical requirements and constraints from the problem\n    tau = 1e-12\n    K_max = 10000\n\n    # Test suite\n    test_cases = [\n        np.array([[4, 1, 0], \n                  [1, 3, 1], \n                  [0, 1, 2]]),\n        \n        np.array([[2, -1, 0, 0, 0], \n                  [-1, 2, -1, 0, 0], \n                  [0, -1, 2, -1, 0], \n                  [0, 0, -1, 2, -1], \n                  [0, 0, 0, -1, 2]]),\n        \n        np.array([[2, 1e-12], \n                  [1e-12, 2]]),\n        \n        np.array([[7]])\n    ]\n\n    results = []\n    for A in test_cases:\n        eigs = qr_eigenvalues(A, tol=tau, max_iter=K_max)\n        rounded_eigs = [round(val, 8) for val in eigs]\n        results.append(rounded_eigs)\n\n    # Format the final output as a single-line string\n    print(f\"[[{', '.join(map(str, results[0]))}], [{', '.join(map(str, results[1]))}], [{', '.join(map(str, results[2]))}], [{', '.join(map(str, results[3]))}]]\")\n\nsolve()\n```", "id": "2445542"}]}