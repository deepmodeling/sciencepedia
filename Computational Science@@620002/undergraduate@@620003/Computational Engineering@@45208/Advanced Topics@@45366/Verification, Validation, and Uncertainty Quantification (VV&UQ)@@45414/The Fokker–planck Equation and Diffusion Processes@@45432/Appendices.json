{"hands_on_practices": [{"introduction": "The Fokker-Planck equation offers a macroscopic view of a system's probability density, while the Langevin stochastic differential equation (SDE) provides a microscopic description of individual particle trajectories. This practice solidifies the fundamental connection between these two perspectives. You will first analytically derive the ordinary differential equations governing the evolution of the mean and variance from the Fokker-Planck equation and then write a simulation to verify that an ensemble of particles following the SDE produces the exact same statistical moments, providing a concrete validation of this core theoretical link. [@problem_id:2444416]", "problem": "Consider the one-dimensional Itô stochastic differential equation (SDE) for a Langevin particle,\n$$\ndX_t = a(X_t)\\,dt + b\\,dW_t,\n$$\nwhere $W_t$ is a standard Wiener process, $a(x)$ is the drift, and $b$ is the diffusion amplitude. In this problem, restrict to the linear-drift, constant-diffusion model\n$$\na(x) = u - k x,\\quad b = \\sqrt{2D},\n$$\nwith parameters $k \\ge 0$, $u \\in \\mathbb{R}$, and $D \\ge 0$. The associated Fokker-Planck equation (FPE) for the probability density function $p(x,t)$ is\n$$\n\\frac{\\partial p}{\\partial t} = -\\frac{\\partial}{\\partial x}\\big(a(x)\\,p\\big) + D\\,\\frac{\\partial^2 p}{\\partial x^2}.\n$$\nAssume the initial distribution has finite moments and sufficiently fast decay so that all boundary terms from integration by parts vanish when evaluating moments.\n\nTask 1 (derivation): Starting from the Fokker-Planck equation and the definitions of the first and second moments,\n$$\n\\langle x \\rangle(t) = \\int_{-\\infty}^{\\infty} x\\,p(x,t)\\,dx,\\quad \\langle x^2 \\rangle(t) = \\int_{-\\infty}^{\\infty} x^2\\,p(x,t)\\,dx,\n$$\nderive the closed ordinary differential equations (ODEs) governing $\\langle x \\rangle(t)$ and $\\langle x^2 \\rangle(t)$ for the specified $a(x)$ and $D$. Then solve these ODEs to obtain explicit expressions for $\\langle x \\rangle(t)$ and $\\langle x^2 \\rangle(t)$ in terms of the initial mean $\\langle x \\rangle(0)$ and initial variance $\\mathrm{Var}(X_0)$, making sure to cover both the case $k>0$ and the limit $k \\to 0$. All quantities are dimensionless.\n\nTask 2 (computation): Implement a program that:\n- Simulates $N$ independent trajectories of the SDE using the Euler–Maruyama method with time step $\\Delta t$ from an initial ensemble $X_0$ having mean $m_0$ and variance $v_0$ (use a Gaussian initialization with mean $m_0$ and variance $v_0$, and when $v_0 = 0$, initialize all particles at the deterministic value $m_0$).\n- Advances the state to time $T$ and computes the empirical first and second moments from the simulated ensemble at time $T$.\n- Computes the theoretical $\\langle x \\rangle(T)$ and $\\langle x^2 \\rangle(T)$ from the derived moment solutions in Task $1$ using the same effective simulated time $T_{\\mathrm{eff}} = n_{\\mathrm{steps}}\\,\\Delta t$, where $n_{\\mathrm{steps}}$ is the integer number of steps performed.\n- Compares empirical and theoretical moments via absolute errors $e_1 = \\big|\\langle x \\rangle_{\\mathrm{emp}}(T_{\\mathrm{eff}}) - \\langle x \\rangle_{\\mathrm{theory}}(T_{\\mathrm{eff}})\\big|$ and $e_2 = \\big|\\langle x^2 \\rangle_{\\mathrm{emp}}(T_{\\mathrm{eff}}) - \\langle x^2 \\rangle_{\\mathrm{theory}}(T_{\\mathrm{eff}})\\big|$.\n- For each test case, outputs a boolean indicating whether both errors satisfy $e_1 \\le \\varepsilon$ and $e_2 \\le \\varepsilon$ for a specified tolerance $\\varepsilon$.\n\nUse the following test suite, where all quantities are dimensionless:\n- Test case $1$ (general Ornstein–Uhlenbeck with constant forcing): $k = 0.7$, $u = 0.3$, $D = 0.5$, $m_0 = 1.2$, $v_0 = 0.8$, $T = 2.3$, $\\Delta t = 0.005$, $N = 20000$.\n- Test case $2$ (pure diffusion boundary case): $k = 0$, $u = 0$, $D = 0.2$, $m_0 = 0.0$, $v_0 = 0.0$, $T = 1.5$, $\\Delta t = 0.003$, $N = 20000$.\n- Test case $3$ (stiff relaxation): $k = 5.0$, $u = 0.0$, $D = 0.4$, $m_0 = -0.7$, $v_0 = 0.3$, $T = 0.6$, $\\Delta t = 0.0005$, $N = 8000$.\n\nUse the tolerance $\\varepsilon = 0.03$ for all cases.\n\nYour program should produce a single line of output containing the boolean results as a comma-separated list enclosed in square brackets (e.g., $[{\\tt True},{\\tt False},{\\tt True}]$), in the same order as the test suite above. No additional text should be printed.", "solution": "The problem statement is subjected to validation before any attempt at a solution.\n\nGivens are extracted verbatim:\n- Stochastic differential equation (SDE): $dX_t = a(X_t)\\,dt + b\\,dW_t$\n- Drift: $a(x) = u - k x$\n- Diffusion amplitude: $b = \\sqrt{2D}$\n- Parameter constraints: $k \\ge 0$, $u \\in \\mathbb{R}$, $D \\ge 0$\n- Fokker-Planck equation (FPE): $\\frac{\\partial p}{\\partial t} = -\\frac{\\partial}{\\partial x}\\big(a(x)\\,p\\big) + D\\,\\frac{\\partial^2 p}{\\partial x^2}$\n- Moment definitions: $\\langle x \\rangle(t) = \\int_{-\\infty}^{\\infty} x\\,p(x,t)\\,dx$, $\\langle x^2 \\rangle(t) = \\int_{-\\infty}^{\\infty} x^2\\,p(x,t)\\,dx$\n- Boundary condition assumption: All boundary terms from integration by parts vanish due to sufficiently fast decay of $p(x,t)$ as $x \\to \\pm\\infty$.\n- Task $1$: Derive and solve ODEs for $\\langle x \\rangle(t)$ and $\\langle x^2 \\rangle(t)$.\n- Task $2$: Implement a numerical simulation using the Euler-Maruyama method and compare with the theoretical results derived in Task $1$.\n- Test cases and tolerance $\\varepsilon = 0.03$ are provided.\n\nValidation verdict: The problem is **valid**. It is scientifically grounded in the theory of stochastic processes, specifically the Ornstein-Uhlenbeck process, a cornerstone of statistical physics and related fields. The problem is well-posed, providing all necessary information, definitions, and constraints to derive a unique analytical solution and perform a corresponding numerical verification. The language is objective and precise. The problem is formalizable and directly relevant to the topic of Fokker-Planck equations in computational engineering. No scientific, logical, or structural flaws are found.\n\nWe proceed with the solution.\n\n**Task 1: Derivation of Moment Equations and Solutions**\n\nThe evolution of any moment $\\langle f(x) \\rangle(t) = \\int f(x) p(x,t) dx$ is governed by the FPE. Its time derivative is:\n$$\n\\frac{d}{dt}\\langle f(x) \\rangle = \\int f(x) \\frac{\\partial p}{\\partial t} dx = \\int f(x) \\left[ -\\frac{\\partial}{\\partial x}\\big(a(x)\\,p\\big) + D\\,\\frac{\\partial^2 p}{\\partial x^2} \\right] dx\n$$\n\n**First Moment $\\langle x \\rangle(t)$**\n\nLet $f(x) = x$. The time derivative of the mean, $\\langle x \\rangle(t)$, is:\n$$\n\\frac{d\\langle x \\rangle}{dt} = \\int x \\left[ -\\frac{\\partial}{\\partial x}\\big((u-kx)p\\big) + D\\,\\frac{\\partial^2 p}{\\partial x^2} \\right] dx\n$$\nWe evaluate the two terms in the integral separately.\n\nTerm $1$:\n$$\n-\\int_{-\\infty}^{\\infty} x \\frac{\\partial}{\\partial x}\\big((u-kx)p\\big) dx\n$$\nUsing integration by parts, $\\int v\\,du' = [vu']_{-\\infty}^{\\infty} - \\int v'u\\,dx$, with $v=x$ and $u'=\\frac{\\partial}{\\partial x}\\big((u-kx)p\\big)$:\n$$\n-\\left[ x(u-kx)p \\right]_{-\\infty}^{\\infty} + \\int_{-\\infty}^{\\infty} (u-kx)p \\, dx\n$$\nThe boundary term is zero by assumption. The remaining integral is:\n$$\n\\int (u-kx)p \\, dx = u \\int p \\, dx - k \\int xp \\, dx = u \\cdot 1 - k\\langle x \\rangle = u - k\\langle x \\rangle\n$$\nsince $\\int p(x,t) dx = 1$.\n\nTerm $2$:\n$$\n\\int_{-\\infty}^{\\infty} x D \\frac{\\partial^2 p}{\\partial x^2} dx\n$$\nWe integrate by parts twice. First, with $v=x$ and $u' = D \\frac{\\partial^2 p}{\\partial x^2}$:\n$$\n\\left[ xD\\frac{\\partial p}{\\partial x} \\right]_{-\\infty}^{\\infty} - \\int_{-\\infty}^{\\infty} D\\frac{\\partial p}{\\partial x} dx\n$$\nThe boundary term vanishes. The integral is $-D[p]_{-\\infty}^{\\infty}$, which also vanishes. Thus, this entire term is zero.\n\nCombining the results, we obtain the ODE for the first moment:\n$$\n\\frac{d\\langle x \\rangle}{dt} = u - k\\langle x \\rangle\n$$\n\n**Second Moment $\\langle x^2 \\rangle(t)$**\n\nLet $f(x) = x^2$. The time derivative of the second moment, $\\langle x^2 \\rangle(t)$, is:\n$$\n\\frac{d\\langle x^2 \\rangle}{dt} = \\int x^2 \\left[ -\\frac{\\partial}{\\partial x}\\big((u-kx)p\\big) + D\\,\\frac{\\partial^2 p}{\\partial x^2} \\right] dx\n$$\nTerm $1$:\n$$\n-\\int_{-\\infty}^{\\infty} x^2 \\frac{\\partial}{\\partial x}\\big((u-kx)p\\big) dx\n$$\nIntegrating by parts with $v=x^2$:\n$$\n-\\left[ x^2(u-kx)p \\right]_{-\\infty}^{\\infty} + \\int_{-\\infty}^{\\infty} 2x(u-kx)p \\, dx\n$$\nThe boundary term is zero. The remaining integral is:\n$$\n\\int (2ux - 2kx^2)p \\, dx = 2u \\int xp \\, dx - 2k \\int x^2p \\, dx = 2u\\langle x \\rangle - 2k\\langle x^2 \\rangle\n$$\n\nTerm $2$:\n$$\n\\int_{-\\infty}^{\\infty} x^2 D \\frac{\\partial^2 p}{\\partial x^2} dx\n$$\nIntegrating by parts with $v=x^2$:\n$$\n\\left[ x^2 D\\frac{\\partial p}{\\partial x} \\right]_{-\\infty}^{\\infty} - \\int_{-\\infty}^{\\infty} 2x D\\frac{\\partial p}{\\partial x} dx\n$$\nThe boundary term is zero. We are left with $-2D \\int x \\frac{\\partial p}{\\partial x} dx$. Integrating by parts again:\n$$\n-2D \\left( [xp]_{-\\infty}^{\\infty} - \\int p \\, dx \\right) = -2D(0 - 1) = 2D\n$$\nCombining the results gives the ODE for the second moment:\n$$\n\\frac{d\\langle x^2 \\rangle}{dt} = 2u\\langle x \\rangle - 2k\\langle x^2 \\rangle + 2D\n$$\nThe moments form a closed system of linear ODEs. It is more elegant to derive an equation for the variance, $\\mathrm{Var}(X_t) \\equiv V(t) = \\langle x^2 \\rangle(t) - \\langle x \\rangle(t)^2$.\n$$\n\\frac{dV}{dt} = \\frac{d\\langle x^2 \\rangle}{dt} - 2\\langle x \\rangle \\frac{d\\langle x \\rangle}{dt} = (2u\\langle x \\rangle - 2k\\langle x^2 \\rangle + 2D) - 2\\langle x \\rangle (u - k\\langle x \\rangle)\n$$\n$$\n\\frac{dV}{dt} = 2u\\langle x \\rangle - 2k\\langle x^2 \\rangle + 2D - 2u\\langle x \\rangle + 2k\\langle x \\rangle^2 = -2k(\\langle x^2 \\rangle - \\langle x \\rangle^2) + 2D\n$$\nThis simplifies to a self-contained ODE for the variance:\n$$\n\\frac{dV}{dt} = -2kV + 2D\n$$\n\n**Solving the ODEs**\n\nLet $m(t) = \\langle x \\rangle(t)$, $m_0 = \\langle x \\rangle(0)$, and $v_0 = \\mathrm{Var}(X_0)$.\n\nCase $1$: $k > 0$.\nThe ODE for the mean is $\\frac{dm}{dt} + km = u$. This is a first-order linear ODE with solution:\n$$\nm(t) = m_0 e^{-kt} + \\frac{u}{k}(1-e^{-kt})\n$$\nThe ODE for the variance is $\\frac{dV}{dt} + 2kV = 2D$. The solution is:\n$$\nV(t) = v_0 e^{-2kt} + \\frac{D}{k}(1-e^{-2kt})\n$$\n\nCase $2$: $k = 0$.\nThe ODE for the mean becomes $\\frac{dm}{dt} = u$, with solution:\n$$\nm(t) = m_0 + ut\n$$\nThe ODE for the variance becomes $\\frac{dV}{dt} = 2D$, with solution:\n$$\nV(t) = v_0 + 2Dt\n$$\nThese results for $k=0$ are consistent with the limit $k \\to 0$ of the expressions for $k>0$, as can be verified by Taylor expansion of the exponential function.\n\nThe second moment is recovered from the mean and variance:\n$$\n\\langle x^2 \\rangle(t) = V(t) + [m(t)]^2\n$$\nThis concludes the derivation for Task $1$.\n\n**Task 2: Computational Implementation**\n\nThe SDE $dX_t = (u - kX_t)dt + \\sqrt{2D}dW_t$ is simulated using the Euler-Maruyama method. The discretized update rule for a single particle's position $X_n$ at time step $n$ is:\n$$\nX_{n+1} = X_n + (u - kX_n)\\Delta t + \\sqrt{2D\\Delta t} Z_n\n$$\nwhere $\\Delta t$ is the time step and $Z_n$ is a random variable drawn from the standard normal distribution $N(0,1)$.\n\nThe algorithm proceeds as follows:\n$1$. For each test case, initialize $N$ independent particle trajectories. The initial positions $X_0$ form an ensemble drawn from a Gaussian distribution with mean $m_0$ and variance $v_0$. If $v_0 = 0$, all particles are initialized at the deterministic position $m_0$.\n$2$. Calculate the number of simulation steps as $n_{\\mathrm{steps}} = \\mathrm{round}(T/\\Delta t)$ to closely match the target time $T$. The effective total time is $T_{\\mathrm{eff}} = n_{\\mathrm{steps}} \\Delta t$.\n$3$. Iterate for $n_{\\mathrm{steps}}$, updating all $N$ particle positions at each step according to the Euler-Maruyama rule. A new set of $N$ random numbers $Z_n$ is generated at each step.\n$4$. At the final time $T_{\\mathrm{eff}}$, compute the empirical mean and second moment from the ensemble of $N$ final particle positions:\n$$\n\\langle x \\rangle_{\\mathrm{emp}} = \\frac{1}{N}\\sum_{i=1}^N X_i(T_{\\mathrm{eff}}) \\quad \\text{and} \\quad \\langle x^2 \\rangle_{\\mathrm{emp}} = \\frac{1}{N}\\sum_{i=1}^N [X_i(T_{\\mathrm{eff}})]^2\n$$\n$5$. Compute the theoretical moments $\\langle x \\rangle_{\\mathrm{theory}}(T_{\\mathrm{eff}})$ and $\\langle x^2 \\rangle_{\\mathrm{theory}}(T_{\\mathrm{eff}})$ using the analytical formulas derived above.\n$6$. Calculate the absolute errors $e_1 = |\\langle x \\rangle_{\\mathrm{emp}} - \\langle x \\rangle_{\\mathrm{theory}}|$ and $e_2 = |\\langle x^2 \\rangle_{\\mathrm{emp}} - \\langle x^2 \\rangle_{\\mathrm{theory}}|$.\n$7$. The test case passes if both errors are within the specified tolerance $\\varepsilon = 0.03$. The final output is a list of booleans indicating the pass/fail status for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by running simulations for each test case and comparing\n    empirical results with theoretical derivations.\n    \"\"\"\n\n    test_cases = [\n        # (k, u, D, m0, v0, T, dt, N)\n        (0.7, 0.3, 0.5, 1.2, 0.8, 2.3, 0.005, 20000),\n        (0.0, 0.0, 0.2, 0.0, 0.0, 1.5, 0.003, 20000),\n        (5.0, 0.0, 0.4, -0.7, 0.3, 0.6, 0.0005, 8000),\n    ]\n    epsilon = 0.03\n    results = []\n\n    for k, u, D, m0, v0, T, dt, N in test_cases:\n        # Run simulation to get empirical moments\n        emp_mean, emp_second_moment, eff_T = run_simulation(\n            k, u, D, m0, v0, T, dt, N\n        )\n\n        # Calculate theoretical moments\n        theory_mean, theory_second_moment = theoretical_moments(\n            k, u, D, m0, v0, eff_T\n        )\n\n        # Compare and check against tolerance\n        e1 = np.abs(emp_mean - theory_mean)\n        e2 = np.abs(emp_second_moment - theory_second_moment)\n        \n        is_within_tolerance = (e1 = epsilon) and (e2 = epsilon)\n        results.append(is_within_tolerance)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(k, u, D, m0, v0, T, dt, N):\n    \"\"\"\n    Simulates N trajectories of the Langevin SDE using Euler-Maruyama method.\n\n    Returns:\n        tuple: (empirical mean, empirical second moment, effective simulation time)\n    \"\"\"\n    num_steps = int(np.round(T / dt))\n    eff_T = num_steps * dt\n\n    # Initial ensemble generation from a Gaussian distribution\n    # np.random.normal's 'scale' parameter is standard deviation (sqrt of variance)\n    if v0 >= 0:\n        std_dev = np.sqrt(v0)\n        x = np.random.normal(loc=m0, scale=std_dev, size=N)\n    else:\n        # This case should not happen based on problem constraints but is good practice\n        raise ValueError(\"Initial variance v0 must be non-negative.\")\n\n    # Pre-calculate constant term for efficiency\n    sde_noise_term = np.sqrt(2 * D * dt)\n\n    # Simulation loop\n    for _ in range(num_steps):\n        # Generate standard normal random numbers for this step\n        Z = np.random.normal(size=N)\n        \n        # Euler-Maruyama step for all N particles\n        drift = (u - k * x) * dt\n        diffusion = sde_noise_term * Z\n        x += drift + diffusion\n    \n    # Compute empirical moments from the final state of the ensemble\n    emp_mean = np.mean(x)\n    emp_second_moment = np.mean(x**2)\n    \n    return emp_mean, emp_second_moment, eff_T\n\ndef theoretical_moments(k, u, D, m0, v0, t):\n    \"\"\"\n    Calculates the theoretical first and second moments at time t.\n\n    Returns:\n        tuple: (theoretical mean, theoretical second moment)\n    \"\"\"\n    if k > 0:\n        # Case for Ornstein-Uhlenbeck process (k > 0)\n        exp_kt = np.exp(-k * t)\n        exp_2kt = np.exp(-2 * k * t)\n        \n        mean_t = m0 * exp_kt + (u / k) * (1 - exp_kt)\n        var_t = v0 * exp_2kt + (D / k) * (1 - exp_2kt)\n    else: # k == 0\n        # Case for pure Wiener process with drift (k = 0)\n        mean_t = m0 + u * t\n        var_t = v0 + 2 * D * t\n    \n    # Second moment is Var(X) + E[X]^2\n    second_moment_t = var_t + mean_t**2\n    \n    return mean_t, second_moment_t\n\nsolve()\n\n```", "id": "2444416"}, {"introduction": "Beyond describing how a probability distribution spreads over time, the Fokker-Planck framework can answer crucial timing questions, such as how long it takes for a particle to exit a specific region. This exercise introduces the powerful concept of the Mean First Passage Time (MFPT) and its governing differential equation. By calculating the MFPT for a particle to leave an interval under different boundary conditions—reflecting versus absorbing—you will gain direct, quantitative insight into how physical boundaries fundamentally shape the escape dynamics of a diffusion process. [@problem_id:2444438]", "problem": "A one-dimensional particle undergoes overdamped diffusion with constant drift inside a closed interval. Its position $X_t$ evolves according to the Stochastic Differential Equation (SDE) $\\,\\mathrm{d}X_t = v\\,\\mathrm{d}t + \\sqrt{2D}\\,\\mathrm{d}W_t\\,$ on the interval $\\,[0,L]\\,$, where $v$ is a constant drift velocity, $D$ is a constant diffusion coefficient, and $W_t$ is a standard Wiener process. The particle starts at position $X_0 = x_0$ with $0 \\le x_0 \\le L$.\n\nDefine the mean first passage time (MFPT) $\\,T\\,$ as the expected value of the exit time $\\,\\tau\\,$ from $\\,[0,L]\\,$ under the following two boundary configurations:\n\n- Configuration $\\mathcal{R}\\mathcal{A}$: reflecting boundary at $x=0$ and absorbing boundary at $x=L$. In this configuration, the exit time is $\\tau = \\inf\\{t \\ge 0 : X_t = L\\}$ because reflections at $x=0$ prevent exit at $x=0$.\n- Configuration $\\mathcal{A}\\mathcal{A}$: absorbing boundaries at both $x=0$ and $x=L$. In this configuration, the exit time is $\\tau = \\inf\\{t \\ge 0 : X_t \\in \\{0,L\\}\\}$.\n\nFor each configuration, define the MFPT as $\\,T_{\\mathcal{R}\\mathcal{A}}(x_0)\\,$ and $\\,T_{\\mathcal{A}\\mathcal{A}}(x_0)\\,$ respectively. All times must be expressed in seconds.\n\nTask: For the parameter sets below, compute the triplet of results $[\\,T_{\\mathcal{R}\\mathcal{A}}(x_0),\\,T_{\\mathcal{A}\\mathcal{A}}(x_0),\\,T_{\\mathcal{R}\\mathcal{A}}(x_0)-T_{\\mathcal{A}\\mathcal{A}}(x_0)\\,]$ for each test case. All outputs must be expressed in seconds and rounded to six decimal places.\n\nUse the following test suite, where $L$ is in meters, $D$ is in square meters per second, $v$ is in meters per second, and $x_0$ is in meters:\n\n- Test case $1$: $L=1.0$, $D=0.1$, $v=0.5$, $x_0=0.2$.\n- Test case $2$: $L=1.0$, $D=0.1$, $v=0.0$, $x_0=0.3$.\n- Test case $3$: $L=1.0$, $D=0.05$, $v=-0.2$, $x_0=0.6$.\n- Test case $4$: $L=2.0$, $D=0.2$, $v=0.3$, $x_0=0.0$.\n- Test case $5$: $L=1.5$, $D=0.15$, $v=0.1$, $x_0=1.5$.\n\nFinal output format: Your program should produce a single line of output containing the results for all test cases as a comma-separated list of triplets, enclosed in a single pair of square brackets. Each triplet must be of the form $[\\,T_{\\mathcal{R}\\mathcal{A}},\\,T_{\\mathcal{A}\\mathcal{A}},\\,T_{\\mathcal{R}\\mathcal{A}}-T_{\\mathcal{A}\\mathcal{A}}\\,]$ with each entry rounded to six decimal places, for example $[\\, [\\,t_{1,\\mathcal{R}\\mathcal{A}},t_{1,\\mathcal{A}\\mathcal{A}},\\Delta_1\\,], [\\,t_{2,\\mathcal{R}\\mathcal{A}},t_{2,\\mathcal{A}\\mathcal{A}},\\Delta_2\\,], \\ldots \\,]$, where $t_{k,\\mathcal{R}\\mathcal{A}}$, $t_{k,\\mathcal{A}\\mathcal{A}}$, and $\\Delta_k$ denote the three rounded results for test case $k$.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It is based on the fundamental theory of diffusion processes and the mean first passage time, a standard topic in statistical physics and computational engineering. All parameters are clearly defined, and the premises are factually sound. We shall proceed with the formal derivation and solution.\n\nThe motion of the particle is described by the one-dimensional Langevin equation, or more formally, the stochastic differential equation (SDE):\n$$ \\mathrm{d}X_t = v\\,\\mathrm{d}t + \\sqrt{2D}\\,\\mathrm{d}W_t $$\nwhere $X_t$ is the position at time $t$, $v$ is the constant drift velocity, $D$ is the constant diffusion coefficient, and $W_t$ is a standard Wiener process.\n\nThe mean first passage time (MFPT), denoted by $T(x_0)$, is the expected value of the time $\\tau$ it takes for the particle, starting at $X_0 = x_0$, to first reach a boundary of a given domain. For a general one-dimensional Itô process $ \\mathrm{d}X_t = a(X_t)\\,\\mathrm{d}t + b(X_t)\\,\\mathrm{d}W_t $, the MFPT $T(x)$ as a function of the starting position $x$ satisfies the backward Kolmogorov equation, which is a second-order ordinary differential equation:\n$$ a(x) \\frac{\\mathrm{d}T}{\\mathrm{d}x} + \\frac{1}{2} b^2(x) \\frac{\\mathrm{d}^2T}{\\mathrm{d}x^2} = -1 $$\nFor the specific SDE given in the problem, the drift coefficient is $a(x) = v$ and the diffusion term is $b(x) = \\sqrt{2D}$, so $b^2(x) = 2D$. The backward Kolmogorov equation for our problem is therefore:\n$$ v \\frac{\\mathrm{d}T}{\\mathrm{d}x} + D \\frac{\\mathrm{d}^2T}{\\mathrm{d}x^2} = -1 $$\nWe must solve this ODE for the two specified boundary configurations on the interval $[0, L]$.\n\n**Configuration $\\mathcal{R}\\mathcal{A}$: Reflecting at $x=0$, Absorbing at $x=L$**\n\nThe domain is $[0, L]$. The MFPT, $T_{\\mathcal{R}\\mathcal{A}}(x)$, represents the time to reach the boundary at $x=L$.\nThe boundary conditions are:\n1.  Absorbing boundary at $x=L$: If the particle starts at the absorbing boundary, the exit time is zero. Thus, $T_{\\mathcal{R}\\mathcal{A}}(L) = 0$.\n2.  Reflecting boundary at $x=0$: A reflecting boundary imposes a zero-flux condition on the probability density, which translates to a zero-gradient condition for the MFPT. Thus, $\\frac{\\mathrm{d}T_{\\mathcal{R}\\mathcal{A}}}{\\mathrm{d}x}\\bigg|_{x=0} = 0$.\n\nLet us solve $D T'' + v T' = -1$.\nFirst, consider the case where $v \\neq 0$. Let $U(x) = T'(x)$. The equation for $U(x)$ is $D U' + v U = -1$, which is a first-order linear ODE. The general solution is $U(x) = C_1 e^{-vx/D} - 1/v$.\nUsing the condition $U(0) = T'(0) = 0$, we find $C_1 - 1/v = 0 \\Rightarrow C_1 = 1/v$.\nSo, $T'(x) = \\frac{1}{v}(e^{-vx/D} - 1)$.\nIntegrating with respect to $x$ gives $T(x) = \\int \\frac{1}{v}(e^{-vx/D} - 1) \\mathrm{d}x = \\frac{1}{v}(-\\frac{D}{v}e^{-vx/D} - x) + C_2$.\nUsing the condition $T(L)=0$, we solve for $C_2$: $0 = -\\frac{D}{v^2}e^{-vL/D} - \\frac{L}{v} + C_2 \\Rightarrow C_2 = \\frac{D}{v^2}e^{-vL/D} + \\frac{L}{v}$.\nSubstituting $C_2$ back, we obtain the solution for $v \\neq 0$:\n$$ T_{\\mathcal{R}\\mathcal{A}}(x_0) = \\frac{L-x_0}{v} + \\frac{D}{v^2} \\left( e^{-vL/D} - e^{-vx_0/D} \\right) $$\nFor the case $v=0$, the ODE becomes $D T'' = -1$. Integrating twice gives $T(x) = -x^2/(2D) + C_1 x + C_2$.\nThe boundary conditions are $T'(0)=0$ and $T(L)=0$.\n$T'(x) = -x/D + C_1$. From $T'(0)=0$, we get $C_1=0$.\nThen $T(L) = -L^2/(2D) + C_2 = 0$, so $C_2 = L^2/(2D)$.\nThe solution for $v = 0$ is:\n$$ T_{\\mathcal{R}\\mathcal{A}}(x_0) = \\frac{L^2 - x_0^2}{2D} $$\n\n**Configuration $\\mathcal{A}\\mathcal{A}$: Absorbing at $x=0$, Absorbing at $x=L$**\n\nThe domain is $[0, L]$. The MFPT, $T_{\\mathcal{A}\\mathcal{A}}(x)$, represents the time to reach either boundary at $x=0$ or $x=L$.\nThe boundary conditions are:\n1.  Absorbing boundary at $x=0$: $T_{\\mathcal{A}\\mathcal{A}}(0) = 0$.\n2.  Absorbing boundary at $x=L$: $T_{\\mathcal{A}\\mathcal{A}}(L) = 0$.\n\nWe solve the same ODE, $D T'' + v T' = -1$.\nFirst, consider the case where $v \\neq 0$. The general solution is $T(x) = C_1 + C_2 e^{-vx/D} - x/v$.\nApplying the boundary conditions:\n1.  $T(0) = C_1 + C_2 = 0 \\Rightarrow C_1 = -C_2$.\n2.  $T(L) = C_1 + C_2 e^{-vL/D} - L/v = 0$.\nSubstituting $C_1=-C_2$ into the second equation yields $-C_2 + C_2 e^{-vL/D} = L/v$, which gives $C_2 = \\frac{L/v}{e^{-vL/D}-1}$.\nThen $C_1 = -\\frac{L/v}{e^{-vL/D}-1}$.\nSubstituting the constants back into the general solution and simplifying gives:\n$$ T_{\\mathcal{A}\\mathcal{A}}(x_0) = \\frac{1}{v} \\left( L \\frac{1 - e^{-vx_0/D}}{1 - e^{-vL/D}} - x_0 \\right) $$\nFor the case $v=0$, the ODE is $D T'' = -1$, and the general solution is $T(x) = -x^2/(2D) + C_1 x + C_2$.\nThe boundary conditions are $T(0)=0$ and $T(L)=0$.\n$T(0) = C_2 = 0$.\n$T(L) = -L^2/(2D) + C_1 L = 0 \\Rightarrow C_1 = L/(2D)$.\nThe solution for $v = 0$ is:\n$$ T_{\\mathcal{A}\\mathcal{A}}(x_0) = \\frac{x_0(L-x_0)}{2D} $$\n\n**Summary of Formulas for Computation**\n\nFor each test case with parameters $(L, D, v, x_0)$:\n\n1.  **Mean First Passage Time for Configuration $\\mathcal{R}\\mathcal{A}$:**\n    - If $v=0$: $T_{\\mathcal{R}\\mathcal{A}}(x_0) = \\frac{L^2 - x_0^2}{2D}$\n    - If $v \\neq 0$: $T_{\\mathcal{R}\\mathcal{A}}(x_0) = \\frac{L-x_0}{v} + \\frac{D}{v^2} \\left( e^{-vL/D} - e^{-vx_0/D} \\right)$\n    - Note that if $x_0 = L$, the particle is already at the absorbing boundary, so $T_{\\mathcal{R}\\mathcal{A}}(L) = 0$.\n\n2.  **Mean First Passage Time for Configuration $\\mathcal{A}\\mathcal{A}$:**\n    - If $v=0$: $T_{\\mathcal{A}\\mathcal{A}}(x_0) = \\frac{x_0(L-x_0)}{2D}$\n    - If $v \\neq 0$: $T_{\\mathcal{A}\\mathcal{A}}(x_0) = \\frac{1}{v} \\left( L \\frac{1 - e^{-vx_0/D}}{1 - e^{-vL/D}} - x_0 \\right)$\n    - Note that if $x_0 = 0$ or $x_0 = L$, the particle is at an absorbing boundary, so $T_{\\mathcal{A}\\mathcal{A}}(0) = 0$ and $T_{\\mathcal{A}\\mathcal{A}}(L) = 0$.\n\nThese formulas are implemented to compute the required values for the given test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Mean First Passage Time (MFPT) for a particle in a 1D interval\n    with two different boundary configurations.\n    \"\"\"\n    test_cases = [\n        # (L, D, v, x_0)\n        (1.0, 0.1, 0.5, 0.2),\n        (1.0, 0.1, 0.0, 0.3),\n        (1.0, 0.05, -0.2, 0.6),\n        (2.0, 0.2, 0.3, 0.0),\n        (1.5, 0.15, 0.1, 1.5),\n    ]\n\n    results = []\n    for L, D, v, x0 in test_cases:\n        # Configuration RA: Reflecting at x=0, Absorbing at x=L\n        t_ra = 0.0\n        # If starting at the absorbing boundary, time is 0.\n        if np.isclose(x0, L):\n            t_ra = 0.0\n        elif np.isclose(v, 0.0):\n            # Formula for v=0\n            t_ra = (L**2 - x0**2) / (2 * D)\n        else:\n            # Formula for v!=0\n            term1 = (L - x0) / v\n            term2 = (D / v**2) * (np.exp(-v * L / D) - np.exp(-v * x0 / D))\n            t_ra = term1 + term2\n\n        # Configuration AA: Absorbing at x=0, Absorbing at x=L\n        t_aa = 0.0\n        # If starting at either absorbing boundary, time is 0.\n        if np.isclose(x0, 0.0) or np.isclose(x0, L):\n            t_aa = 0.0\n        elif np.isclose(v, 0.0):\n            # Formula for v=0\n            t_aa = x0 * (L - x0) / (2 * D)\n        else:\n            # Formula for v!=0\n            # Numerator and denominator of the probability term\n            num = 1 - np.exp(-v * x0 / D)\n            den = 1 - np.exp(-v * L / D)\n            term1 = L * (num / den)\n            t_aa = (1 / v) * (term1 - x0)\n        \n        delta_t = t_ra - t_aa\n        \n        # Format triplet as a string \"[val1,val2,val3]\"\n        triplet_str = f\"[{t_ra:.6f},{t_aa:.6f},{delta_t:.6f}]\"\n        results.append(triplet_str)\n\n    # Final print statement in the exact required format \"[triplet1,triplet2,...]\"\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2444438"}, {"introduction": "Building on the concept of mean first passage time, this advanced practice applies the formalism to a classic problem in computational science: calculating the rate of transition between the stable states of a system. You will model a particle diffusing in a double-well potential, which serves as a fundamental model for diverse phenomena from chemical reactions to bit flips in digital memory. By solving for the mean time required to escape one of the potential wells, you will compute the famous Kramers transition rate and explore its critical dependence on the system's noise level, $D$. [@problem_id:2444390]", "problem": "You are asked to design and implement a numerical method to estimate the inter-well transition rate for an overdamped diffusion process evolving in the one-dimensional double-well potential given by $V(x) = x^4 - 2x^2$. Work entirely in dimensionless units. The particle position $x(t)$ follows the Itô overdamped Langevin dynamics\n$$\ndx(t) = -V'(x(t))\\,dt + \\sqrt{2D}\\,dW_t,\n$$\nwhere $D \\gt 0$ is the (dimensionless) diffusion coefficient and $W_t$ is a standard Wiener process. The corresponding Fokker-Planck equation (FPE) for the probability density function $p(x,t)$ is the forward evolution equation associated with the above stochastic differential equation.\n\nStarting from the definitions of the Fokker-Planck equation and the backward (Kolmogorov) operator, derive a well-posed boundary-value problem for the mean first passage time $m(x)$ from a starting position $x \\in [x_{\\min}, x_{\\max}]$ to an absorbing boundary at the barrier top. Use the following physically consistent setup:\n- Potential: $V(x) = x^4 - 2x^2$ with minima near $x = \\pm 1$ and a saddle at $x = 0$.\n- Domain: $[x_{\\min}, x_{\\max}] = [-2.0, 0.0]$.\n- Initial position: $x_0 = -1.0$.\n- Boundary conditions: reflecting at $x_{\\min}$ and absorbing at $x_{\\max}$.\n\nAfter deriving the boundary-value problem for $m(x)$, implement a stable numerical solution strategy (for example, a second-order centered finite-difference discretization of the backward equation on a uniform grid with appropriate implementation of the reflecting and absorbing boundary conditions, or an analytically equivalent quadrature representation that follows from the same derivation). From the computed mean first passage time at the initial position $m(x_0)$, define the transition rate as $k = 1/m(x_0)$ in inverse dimensionless time units.\n\nYour program must compute and report the transition rate $k$ for each diffusion coefficient in the following test suite:\n- $D = 0.1$ (small noise, rare transitions; happy path).\n- $D = 0.2$ (moderate noise).\n- $D = 0.5$ (increased noise).\n- $D = 1.0$ (noise comparable to barrier height).\n- $D = 1.5$ (large noise; edge case).\n\nRequirements:\n- Treat all quantities as dimensionless. Report the transition rates $k$ in inverse dimensionless time units as floating-point numbers.\n- Your discretization must be sufficiently accurate to capture the trend of $k$ as a function of $D$ and numerically stable for all test cases above.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of the $D$ values above, with each number rounded to eight decimal places (e.g., \"[0.12345678,0.23456789,0.34567890,0.45678901,0.56789012]\").", "solution": "We begin from the overdamped Langevin equation\n$$\ndx(t) = -V'(x(t))\\,dt + \\sqrt{2D}\\,dW_t,\n$$\nwhich induces the forward Fokker-Planck equation\n$$\n\\partial_t p(x,t) = \\partial_x\\!\\left(V'(x)\\,p(x,t)\\right) + D\\,\\partial_{xx} p(x,t).\n$$\nFor functionals of the process, the backward (Kolmogorov) operator associated with the generator is\n$$\n\\mathcal{L} f(x) = -V'(x)\\,f'(x) + D\\,f''(x).\n$$\nLet $m(x)$ denote the mean first passage time (MFPT) from a starting point $x$ to an absorbing boundary at $x_{\\max}$, with a reflecting boundary at $x_{\\min}$. Standard first-passage theory states that $m(x)$ solves the boundary-value problem\n$$\n\\mathcal{L} m(x) = -1 \\quad \\text{for } x \\in (x_{\\min}, x_{\\max}),\n$$\nwith boundary conditions\n$$\nm'(x_{\\min}) = 0 \\quad \\text{(reflecting)}, \\qquad m(x_{\\max}) = 0 \\quad \\text{(absorbing)}.\n$$\nFor the present problem, we set $x_{\\min} = -2.0$, $x_{\\max} = 0.0$, and the initial position $x_0 = -1.0$. Substituting the operator into the backward equation yields the ordinary differential equation\n$$\nD\\,m''(x) - V'(x)\\,m'(x) = -1, \\quad x \\in (-2,0),\n$$\nwith\n$$\nm'(-2) = 0, \\qquad m(0) = 0.\n$$\n\nThere are two efficient and mathematically consistent numerical strategies to solve this one-dimensional boundary-value problem:\n\n1) Finite difference discretization. Discretize the interval $[x_{\\min}, x_{\\max}]$ with a uniform grid, approximate $m''(x)$ and $m'(x)$ using centered differences in the interior, impose the Neumann boundary condition at $x_{\\min}$ using a one-sided second-order formula, and impose the Dirichlet condition at $x_{\\max}$ directly. This yields a sparse linear system for the nodal values of $m(x)$, which can be solved by standard linear algebra solvers.\n\n2) Quadrature representation via integrating factors. The ordinary differential equation can be reduced analytically to nested integrals. Define $\\phi(x) = V(x)/D$. Rewrite the equation as\n$$\nm''(x) - \\phi'(x)\\,m'(x) = -\\frac{1}{D}.\n$$\nLet $y(x) = m'(x)$. Then\n$$\ny'(x) - \\phi'(x)\\,y(x) = -\\frac{1}{D}.\n$$\nMultiplying by the integrating factor $e^{-\\phi(x)}$ gives\n$$\n\\frac{d}{dx}\\!\\left(e^{-\\phi(x)} y(x)\\right) = -\\frac{1}{D} e^{-\\phi(x)}.\n$$\nIntegrating from $x_{\\min}$ to $x$ and using the reflecting boundary condition $m'(x_{\\min}) = 0$ yields\n$$\nm'(x) = -\\frac{e^{\\phi(x)}}{D}\\int_{x_{\\min}}^{x} e^{-\\phi(z)}\\,dz.\n$$\nIntegrating again from $x$ to $x_{\\max}$ and using $m(x_{\\max}) = 0$ gives the classic one-dimensional MFPT formula\n$$\nm(x) = \\frac{1}{D} \\int_{x}^{x_{\\max}} e^{\\phi(y)} \\left[\\int_{x_{\\min}}^{y} e^{-\\phi(z)}\\,dz \\right] dy.\n$$\nThis representation is analytically equivalent to the finite difference solution of the boundary problem and is numerically stable with standard quadrature rules on a uniform grid for the present potential and test parameters. Notably, on the interval $[x_0, x_{\\max}] = [-1,0]$, $V(y) \\le 0$, which keeps $e^{\\phi(y)} \\le 1$ and helps maintain numerical stability over the outer integral. The inner integral can grow as $D$ decreases, correctly reflecting the growth of the MFPT.\n\nAlgorithmic design:\n- Construct a uniform grid $x_i$ over $[x_{\\min}, x_{\\max}]$ with spacing $\\Delta x$.\n- Precompute $V(x_i) = x_i^4 - 2 x_i^2$.\n- For each $D$ in the test suite, compute $\\phi_i = V(x_i)/D$.\n- Compute the inner cumulative integral $A(y) = \\int_{x_{\\min}}^{y} e^{-\\phi(z)} dz$ via the trapezoidal rule using a cumulative sum to obtain all $A(x_i)$ in $\\mathcal{O}(N)$ time.\n- Form $B(y) = e^{\\phi(y)} A(y)$ on the grid.\n- Compute the outer integral $C(x) = \\int_{x}^{x_{\\max}} B(y) dy$ for all $x$ using a right-to-left cumulative trapezoidal sum. Then $m(x) = C(x)/D$.\n- Locate $x_0$ on the grid and evaluate $m(x_0)$. The transition rate is $k = 1/m(x_0)$.\n\nNumerical considerations:\n- The chosen grid size must balance accuracy and runtime; a uniform grid with $N = 10001$ points on $[-2,0]$ yields $\\Delta x = 2/10000$ and is sufficient for accurate evaluation of the nested trapezoidal integrals for all test diffusion coefficients.\n- All computations are in double precision; for the smallest $D$ in the test suite ($D = 0.1$), $e^{1/D}$ remains within safe floating-point bounds.\n- The algorithm is fully vectorized with cumulative sums to ensure efficiency.\n\nFinally, we compute and report $k$ for the test diffusion coefficients $D \\in \\{0.1, 0.2, 0.5, 1.0, 1.5\\}$ in inverse dimensionless time units. The program prints a single line with the five rates in the specified format, each rounded to eight decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef potential(x):\n    # V(x) = x^4 - 2 x^2\n    return x**4 - 2.0 * x**2\n\ndef compute_rate_via_quadrature(D, x_grid, Vx, x_min, x_max, x0):\n    # Compute phi = V/D\n    phi = Vx / D\n\n    # Grid spacing (assume uniform)\n    h = x_grid[1] - x_grid[0]\n    N = x_grid.size\n\n    # Inner integral A(y) = \\int_{x_min}^y exp(-phi(z)) dz using cumulative trapezoid\n    exp_neg_phi = np.exp(-phi)\n    # Trapezoidal cumulative integral: A[0] = 0; for i=1, A[i] = sum_{k=0..i-1} 0.5*(f[k]+f[k+1])*h\n    A = np.zeros(N)\n    if N  1:\n        A[1:] = h * np.cumsum(0.5 * (exp_neg_phi[:-1] + exp_neg_phi[1:]))\n\n    # Outer integrand B(y) = exp(phi(y)) * A(y)\n    exp_phi = np.exp(phi)\n    B = exp_phi * A\n\n    # Outer integral C(x) = \\int_{x}^{x_max} B(y) dy using right-to-left cumulative trapezoid\n    # Define mid-interval averages for trapezoid\n    mid = 0.5 * (B[:-1] + B[1:])  # length N-1\n    # Suffix cumulative sum via reversed cumsum\n    s_rev = np.cumsum(mid[::-1])  # length N-1\n    C = np.zeros(N)\n    if N  1:\n        # Map back: for node i in [0..N-2], C[i] = h * sum_{j=i}^{N-2} mid[j] = h * s_rev[N-2 - i]\n        C[:-1] = h * s_rev[::-1]\n        C[-1] = 0.0\n\n    # MFPT m(x) = C(x)/D\n    m = C / D\n\n    # Interpolate (or directly index) at x0\n    h_inv = 1.0 / h\n    idx_float = (x0 - x_min) * h_inv\n    idx = int(round(idx_float))\n    idx = max(0, min(N - 1, idx))\n    # If x0 is not exactly on a grid node due to rounding, do linear interpolation\n    x_idx = x_grid[idx]\n    if abs(x_idx - x0)  1e-12 or idx == 0 or idx == N - 1:\n        m_x0 = m[idx]\n    else:\n        if x_idx  x0 and idx + 1  N:\n            t = (x0 - x_idx) * h_inv\n            m_x0 = (1 - t) * m[idx] + t * m[idx + 1]\n        elif x_idx  x0 and idx - 1 = 0:\n            t = (x_idx - x0) * h_inv\n            m_x0 = (1 - t) * m[idx] + t * m[idx - 1]\n        else:\n            m_x0 = m[idx]\n\n    # Transition rate k = 1 / m(x0)\n    # Guard against zero or negative (should not occur for well-posed MFPT)\n    if m_x0 = 0:\n        return float('nan')\n    return 1.0 / m_x0\n\ndef solve():\n    # Domain and initial position (dimensionless)\n    x_min = -2.0\n    x_max = 0.0\n    x0 = -1.0\n\n    # Uniform grid with sufficient resolution for stable and accurate quadrature\n    N = 10001  # ensures x0 aligns exactly with grid for this domain\n    x_grid = np.linspace(x_min, x_max, N)\n    Vx = potential(x_grid)\n\n    # Test suite diffusion coefficients (dimensionless)\n    test_cases = [0.1, 0.2, 0.5, 1.0, 1.5]\n\n    results = []\n    for D in test_cases:\n        rate = compute_rate_via_quadrature(D, x_grid, Vx, x_min, x_max, x0)\n        # Round to eight decimals as specified\n        results.append(f\"{rate:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2444390"}]}