{"hands_on_practices": [{"introduction": "The class P/poly is remarkable because its non-uniform nature allows it to solve problems beyond the reach of standard Turing machines, including undecidable ones. This first practice serves as a foundational exercise to demystify this concept. By constructing a simple tally language based on the halting problem, you will see firsthand how a single bit of non-computable \"advice\" for each input length is sufficient to place an undecidable language squarely within P/poly [@problem_id:1423583].", "problem": "In computational complexity theory, we analyze the properties of languages to understand the limits of computation. This problem concerns a specific language constructed based on the behavior of Turing Machines.\n\nAssume a standard, computable enumeration of all deterministic Turing Machines (TMs), denoted $M_1, M_2, M_3, \\dots$. Consider the language $L$ over the alphabet $\\{0,1\\}$ defined as:\n$$L = \\{1^n \\mid n \\ge 1 \\text{ and the } n\\text{-th Turing Machine } M_n \\text{ halts on the empty string as input} \\}$$\nNote that the string $1^n$ is a sequence of $n$ consecutive '1's.\n\nFor context, we provide the following standard definitions:\n- **Decidable Language**: A language is decidable if there exists a Turing Machine that always halts and correctly determines for any given input string whether it belongs to the language. It is a well-known fact that the Halting Problem is undecidable.\n- **Sparse Language**: A language $S$ is sparse if there exists a polynomial $p(n)$ such that for all $n \\ge 1$, the number of strings in $S$ of length $n$ is at most $p(n)$. This is denoted as $|S \\cap \\{0,1\\}^n| \\le p(n)$.\n- **The Class P/poly**: A language $A$ belongs to the complexity class P/poly if there exists a sequence of Boolean circuits $\\{C_n\\}_{n \\ge 1}$ and a polynomial $q(n)$ such that for every $n \\ge 1$: (1) the size (number of gates) of circuit $C_n$ is at most $q(n)$, and (2) for any input string $x$ of length $n$, the circuit $C_n$ outputs 1 if and only if $x \\in A$.\n\nBased on these definitions, which one of the following statements about the language $L$ is a complete and correct characterization?\n\nA. $L$ is decidable, sparse, and in P/poly.\n\nB. $L$ is undecidable, sparse, and in P/poly.\n\nC. $L$ is undecidable, sparse, but not in P/poly.\n\nD. $L$ is undecidable, not sparse, and in P/poly.\n\nE. $L$ is decidable, not sparse, and not in P/poly.", "solution": "We analyze $L=\\{1^{n}\\mid n\\ge 1\\text{ and }M_{n}\\text{ halts on the empty input}\\}$ with respect to decidability, sparsity, and membership in P/poly.\n\nUndecidability: Let $K=\\{\\langle M,w\\rangle\\mid M\\text{ halts on }w\\}$ be the halting problem, which is undecidable. Because the enumeration $\\{M_{n}\\}_{n\\ge 1}$ is computable, there exists a computable mapping reduction from $K$ to the index set underlying $L$: given $\\langle M,w\\rangle$, effectively construct an index $n$ such that $M_{n}$ is a Turing Machine that, on empty input, simulates $M$ on $w$ and halts iff $M$ halts on $w$. Then $\\langle M,w\\rangle\\in K$ if and only if $1^{n}\\in L$. If $L$ were decidable, then $K$ would be decidable, a contradiction. Therefore, $L$ is undecidable.\n\nSparsity: For each length $n$, among strings in $\\{0,1\\}^{n}$ the language $L$ contains either $1^{n}$ or nothing. Hence $\\lvert L\\cap\\{0,1\\}^{n}\\rvert\\le 1$ for all $n\\ge 1$. Taking $p(n)=1$ witnesses that $L$ is sparse.\n\nMembership in P/poly: For each $n\\ge 1$, define the bit $b_{n}=1$ if $1^{n}\\in L$ and $b_{n}=0$ otherwise. Construct a Boolean circuit $C_{n}$ on $n$ inputs $x_{1},\\dots,x_{n}$ that computes\n$$\nE_{n}(x)=\\bigwedge_{i=1}^{n} x_{i},\n$$\nwhich outputs $1$ if and only if the input is exactly $1^{n}$. Define\n$$\nC_{n}(x)=b_{n}\\wedge E_{n}(x).\n$$\nThen for any $x\\in\\{0,1\\}^{n}$, $C_{n}(x)=1$ if and only if $x=1^{n}$ and $b_{n}=1$, i.e., if and only if $x\\in L$. The size of $C_{n}$ is $O(n)$, so there exists a polynomial $q(n)$ bounding the size of $C_{n}$ for all $n$. Thus $L\\in\\text{P/poly}$.\n\nCombining these three facts, $L$ is undecidable, sparse, and in P/poly. Therefore, the correct option is B.", "answer": "$$\\boxed{B}$$", "id": "1423583"}, {"introduction": "Having seen a concrete example of an undecidable language in P/poly, a natural question arises: is this a niche phenomenon tied only to the halting problem? This exercise demonstrates that the answer is a resounding 'no'. By leveraging the power of Rice's Theorem, we can generalize the construction to encompass any non-trivial semantic property of programs, showing that a vast landscape of undecidable problems can be encoded into tally languages within P/poly [@problem_id:1423599]. This practice deepens your understanding by moving from a specific example to a powerful, general principle.", "problem": "In computational complexity theory, the class P/poly consists of languages that can be decided by polynomial-time algorithms which are given a polynomial-sized \"advice string\" that depends only on the length of the input. While most common decidable problems reside in this class, P/poly is vast enough to contain even undecidable languages.\n\nConsider the following definitions:\n- A **tally language** is a language where all strings consist only of the symbol '1'. That is, it is a subset of $\\{1\\}^*$.\n- A property of Turing Machines (TMs) is **semantic** if it only depends on the language the machine accepts, not on the machine's specific implementation.\n- **Rice's Theorem** states that any non-trivial semantic property of recursively enumerable languages is undecidable. A property is non-trivial if there exists at least one Turing machine whose language has the property, and at least one whose language does not.\n\nLet's define a specific language. Consider the property $P_{\\text{FIN}}$ of a Turing machine's language being finite. This is a non-trivial semantic property. For any positive integer $n$, let $M_n$ be the Turing machine corresponding to the integer $n$ under a standard, fixed enumeration of all possible Turing machine encodings.\n\nWe define the tally language $L$ as:\n$$L = \\{ 1^n \\mid n \\in \\mathbb{Z}^+ \\text{ and } L(M_n) \\text{ is a finite language} \\}$$\n\nWhich of the following statements accurately describes the language $L$?\n\nA. $L$ is decidable and can be recognized by a standard Turing machine without advice.\n\nB. $L$ is undecidable, and it does not belong to the complexity class P/poly.\n\nC. $L$ is undecidable, and it does belong to the complexity class P/poly.\n\nD. $L$ is a regular language.\n\nE. The decidability of $L$ is an open problem in computer science.", "solution": "We first analyze decidability. The property $P_{\\text{FIN}}$ that the language recognized by a Turing machine is finite is a semantic property (it depends only on the language accepted, not the particular machine) and it is non-trivial (some Turing machines accept finite languages, some accept infinite ones). By Rice's Theorem, deciding, given an encoding of a Turing machine $M$, whether $L(M)$ is finite is undecidable.\n\nIn the definition of $L$, inputs are unary strings $1^{n}$ and the membership condition is that $1^{n} \\in L$ if and only if $L(M_{n})$ is finite, where $M_{n}$ is the $n$-th Turing machine in a fixed standard effective enumeration. Suppose, for the sake of contradiction, that $L$ were decidable. Given an arbitrary Turing machine $M$ (specified by its encoding), we can effectively compute its index $n$ in the fixed enumeration, because the enumeration is standard and effective. Then we could decide $P_{\\text{FIN}}$ for $M$ by deciding whether $1^{n} \\in L$. This would decide a non-trivial semantic property, contradicting Rice's Theorem. Therefore $L$ is undecidable. Consequently, $L$ cannot be regular, since every regular language is decidable.\n\nNext we analyze membership in $\\text{P/poly}$. By definition, $\\text{P/poly}$ consists of languages decidable by a polynomial-time Turing machine equipped with an advice string $a_{n}$ that depends only on the input length $n$ and has length polynomial in $n$. For unary languages, there is exactly one string of each length $n$, namely $1^{n}$. Define the advice function so that for each length $n$, the advice $a_{n}$ is a single bit $b_{n}$, where $b_{n} = 1$ if $1^{n} \\in L$ and $b_{n} = 0$ otherwise. The decider on input $x$ of length $n$ first checks in polynomial time whether $x$ is of the form $1^{n}$; if not, it rejects. If yes, it outputs the bit $b_{n}$ from the advice. The advice length is $1$, which is polynomial in $n$, and the running time is polynomial. Hence $L \\in \\text{P/poly}$.\n\nCombining the two conclusions, $L$ is undecidable and $L \\in \\text{P/poly}$. Among the options, this corresponds to statement C. Statements A and D are false since $L$ is undecidable, and statement B is false since $L$ is in $\\text{P/poly}$. Statement E is false because the status is not open; it is settled by Rice's Theorem and the standard characterization of unary languages in $\\text{P/poly}$.", "answer": "$$\\boxed{C}$$", "id": "1423599"}, {"introduction": "We have established that many undecidable languages belong to P/poly, but this does not mean they are all equally \"complex\" in terms of the non-uniform information they require. This final practice introduces a more nuanced perspective by exploring the concept of *advice complexity*. You will analyze and compare two different undecidable languages to demonstrate that the amount of advice needed can vary significantly, from a constant number of bits to an amount that grows with the input size [@problem_id:1423621]. This exercise sharpens your analytical skills by moving from existence proofs to quantitative measurement of non-uniformity.", "problem": "In computational complexity theory, the class P/poly consists of languages that can be decided by a polynomial-time algorithm that takes a \"small\" amount of extra information, called advice, which depends only on the length of the input. This framework allows us to study the complexity of even undecidable problems.\n\nA language $L \\subseteq \\Sigma^*$ is said to be decided in polynomial time with an advice function $a: \\mathbb{N} \\to \\Gamma^*$ if there exists a polynomial-time Turing Machine (TM) $M$ such that for any input string $x \\in \\Sigma^*$, $M$ on input $\\langle x, a(|x|) \\rangle$ correctly decides whether $x \\in L$. The length of the advice for inputs of size $n$ is $|a(n)|$. We denote the minimum possible advice length required to decide language $L$ in polynomial time for inputs of size $n$ as $f_L(n)$.\n\nLet $\\{M_i\\}_{i \\in \\mathbb{N}}$ be a standard enumeration of all Turing machines, where each integer $i$ is a unique description of a machine $M_i$. Let $K$ be the set of non-negative integers $i$ such that the Turing machine $M_i$ halts when given its own description $i$ as input. The set $K$ is undecidable.\n\nConsider the following two languages:\n1.  A tally language $L_1 \\subseteq \\{1\\}^*$ defined as $L_1 = \\{1^n \\mid n \\in K\\}$.\n2.  A language $L_2 \\subseteq \\{0,1\\}^*$. Let $\\chi_K$ be the infinite characteristic sequence of $K$, where the $i$-th bit (0-indexed) is 1 if $i \\in K$ and 0 otherwise. Let $\\chi_K[0..m-1]$ denote the prefix of length $m$ of $\\chi_K$. The language $L_2$ is defined as $L_2 = \\{w \\in \\{0,1\\}^* \\mid |w|=n, n \\geq 2, \\text{ and the prefix of } w \\text{ of length } \\lfloor \\log_2 n \\rfloor \\text{ is } \\chi_K[0..\\lfloor \\log_2 n \\rfloor - 1]\\}$. We consider $L_2$ to be empty for any string of length $n<2$.\n\nLet $f_1(n)$ and $f_2(n)$ be the minimum advice lengths, as a function of input length $n$, required to decide $L_1$ and $L_2$ in polynomial time, respectively. Which of the following options correctly describes the asymptotic growth of these functions?\n\nA. $f_1(n) = \\Theta(1)$ and $f_2(n) = \\Theta(1)$\n\nB. $f_1(n) = \\Theta(1)$ and $f_2(n) = \\Theta(\\log n)$\n\nC. $f_1(n) = \\Theta(\\log n)$ and $f_2(n) = \\Theta(\\log n)$\n\nD. $f_1(n) = \\Theta(1)$ and $f_2(n) = \\Theta(n)$\n\nE. $L_1$ and $L_2$ are undecidable, and thus cannot be decided in polynomial time, even with advice.", "solution": "We recall that an advice function $a:\\mathbb{N}\\to\\Gamma^{*}$ assigns to each input length $n$ a string $a(n)$, and a polynomial-time Turing machine $M$ must decide $L$ correctly on every input $x$ of length $n$ when given $\\langle x,a(n)\\rangle$. The function $f_{L}(n)$ is the minimum achievable $|a(n)|$ (over all pairs $(M,a)$ that decide $L$) for inputs of length $n$.\n\nLanguage $L_{1}$ (tally): $L_{1}=\\{1^{n}\\mid n\\in K\\}$.\nUpper bound: For any $n$, define the advice bit $a(n)=\\chi_{K}[n]$ (the $n$-th bit of the characteristic sequence of $K$). Then $|a(n)|=1$, and a polynomial-time $M$ can, on input $1^{n}$ and advice $a(n)$, accept iff $a(n)=1$. Hence $f_{1}(n)\\leq 1$, so $f_{1}(n)=O(1)$.\n\nLower bound: Suppose, for contradiction, that there exists a correct pair $(M,a)$ and $N\\in\\mathbb{N}$ such that for all $n\\geq N$, $|a(n)|=0$. Then $M$ with empty advice decides $L_{1}$ correctly on all inputs of length at least $N$. Hardcode the (finite) correct answers for lengths $<N$ into the code of a (still polynomial-time) machine $M'$, obtaining a decider for $L_{1}$ without advice. This contradicts the undecidability of $L_{1}$ (equivalently of $K$). Therefore, advice of length at least $1$ is needed for infinitely many large $n$, while the upper bound $1$ always suffices. It follows that $f_{1}(n)=\\Theta(1)$.\n\nLanguage $L_{2}$ (binary): For $n\\geq 2$, let $m=\\lfloor\\log_{2}(n)\\rfloor$ and define $L_{2}$ so that a string $w$ of length $n$ is in $L_{2}$ iff the length-$m$ prefix of $w$ equals $\\chi_{K}[0..m-1]$.\n\nUpper bound: For each $n$, take advice $a(n)=\\chi_{K}[0..m-1]$, so $|a(n)|=m=\\lfloor\\log_{2}(n)\\rfloor$. A polynomial-time $M$ checks that $|w|=n$, computes $m$, compares the first $m$ bits of $w$ to $a(n)$, and accepts iff they are equal. Hence $f_{2}(n)\\leq m=\\Theta(\\log n)$, giving $f_{2}(n)=O(\\log n)$.\n\nLower bound: Fix any correct pair $(M,a)$ for $L_{2}$. Let $m=\\lfloor\\log_{2}(n)\\rfloor$, and write $s_{m}=\\chi_{K}[0..m-1]$. Consider conditional Kolmogorov complexity with respect to a fixed universal machine; denote it $C(\\cdot\\mid\\cdot)$. It is a standard fact that the characteristic sequence of the halting set has prefixes of arbitrarily high complexity, i.e., there exists a constant $c$ (independent of $m$) such that for infinitely many $m$,\n$$\nC\\bigl(s_{m}\\mid m\\bigr)\\geq m-c.\n$$\nSince $M$ is fixed, conditioning on $M$ only changes the right-hand side by an additive constant, so for infinitely many $m$,\n$$\nC\\bigl(s_{m}\\mid m,M\\bigr)\\geq m-c'.\n$$\nFor such $m$, if $|a(n)|<m-c'$, then from $(m,M,a(n))$ one could describe $s_{m}$ with fewer than $m-c'$ bits, contradicting the above inequality. Therefore, for infinitely many $n$,\n$$\n|a(n)|\\geq m-c'=\\Theta(\\log n),\n$$\nwhich implies $f_{2}(n)=\\Omega(\\log n)$. Combined with the $O(\\log n)$ upper bound, we obtain $f_{2}(n)=\\Theta(\\log n)$.\n\nTherefore, $f_{1}(n)=\\Theta(1)$ and $f_{2}(n)=\\Theta(\\log n)$, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1423621"}]}