{"hands_on_practices": [{"introduction": "The first step in mastering monotone circuits is to translate a logical requirement into a physical design. This exercise grounds theory in practice by having you construct a circuit for a common real-world scenario—a majority-voting system. More importantly, it challenges you to optimize your design, introducing the crucial concepts of circuit size and depth, which are fundamental metrics of efficiency in both hardware design and computational complexity. [@problem_id:1432269]", "problem": "A safety-critical system for an autonomous vehicle relies on three independent sensors, $S_1, S_2,$ and $S_3$, to monitor an environmental condition. The system is designed with redundancy to ensure reliability. The system's control unit will engage a safety protocol if and only if at least two of the three sensors are triggered simultaneously.\n\nLet the state of each sensor be represented by a Boolean variable $x_i$, where $x_i=1$ if sensor $S_i$ is triggered, and $x_i=0$ otherwise. The decision to engage the safety protocol can be described by a Boolean function $f(x_1, x_2, x_3)$, which outputs 1 if the protocol should be engaged and 0 otherwise.\n\nThis logic must be implemented using a **monotone Boolean circuit**. For the purpose of this problem, a monotone Boolean circuit is a network of gates built under the following rules:\n-   The circuit inputs are the variables $x_1, x_2, x_3$.\n-   The circuit contains only AND ($\\land$) gates and OR ($\\lor$) gates. No other type of gate (like NOT) is permitted.\n-   Each gate must have exactly two inputs (i.e., a fan-in of 2).\n-   The circuit must have a single output that corresponds to the function $f(x_1, x_2, x_3)$.\n\nThe **size** of a circuit is defined as the total number of gates it contains. The **depth** of a circuit is the length of the longest path from any input variable to the final output gate.\n\nFind the size, $S$, and the depth, $D$, of the most efficient (i.e., smallest possible size) monotone Boolean circuit that implements the function $f$. Provide your answer as a pair of integers $(S, D)$.", "solution": "The problem asks for the size $S$ and depth $D$ of the smallest-size monotone circuit that computes a function $f(x_1, x_2, x_3)$ which is true if at least two of its inputs are true. This is also known as the Threshold-2 function on three variables, $Th_2^3$.\n\nFirst, we must express the function $f(x_1, x_2, x_3)$ in terms of Boolean operations. The condition \"at least two of $x_1, x_2, x_3$ are true\" can be written as a disjunction of all possible pairs being true:\n$(x_1 \\text{ is true AND } x_2 \\text{ is true}) \\text{ OR } (x_1 \\text{ is true AND } x_3 \\text{ is true}) \\text{ OR } (x_2 \\text{ is true AND } x_3 \\text{ is true})$.\nIn Boolean algebra notation, this is:\n$$f(x_1, x_2, x_3) = (x_1 \\land x_2) \\lor (x_1 \\land x_3) \\lor (x_2 \\land x_3)$$\nThis is the Disjunctive Normal Form (DNF) of the function.\n\nA straightforward way to construct a circuit is to directly implement this expression.\n1.  Compute the three AND terms:\n    -   $g_1 = x_1 \\land x_2$ (1 AND gate)\n    -   $g_2 = x_1 \\land x_3$ (1 AND gate)\n    -   $g_3 = x_2 \\land x_3$ (1 AND gate)\n2.  Combine these terms using OR gates. Since the gates are restricted to 2 inputs, we need two OR gates to combine the three terms:\n    -   $g_4 = g_1 \\lor g_2$ (1 OR gate)\n    -   $f = g_4 \\lor g_3$ (1 OR gate)\n\nCounting the gates, we have 3 AND gates and 2 OR gates, for a total size of 5. While this construction is valid, we must determine if it is the most efficient (smallest size). Let's investigate if we can simplify the Boolean expression to use fewer gates.\n\nWe can factor the expression. Let's factor out $x_1$ from the first two terms:\n$$f(x_1, x_2, x_3) = (x_1 \\land (x_2 \\lor x_3)) \\lor (x_2 \\land x_3)$$\nLet's verify this is the same function. By the distributive law, $x_1 \\land (x_2 \\lor x_3) = (x_1 \\land x_2) \\lor (x_1 \\land x_3)$. Substituting this back gives the original expression, so the factorization is correct.\n\nNow, let's construct a circuit based on this new expression, $f = (x_1 \\land (x_2 \\lor x_3)) \\lor (x_2 \\land x_3)$. We can build it as follows:\n1.  Compute the term in the innermost parenthesis: $g_1 = x_2 \\lor x_3$. This requires one OR gate.\n2.  Compute the second term in the final disjunction: $g_2 = x_2 \\land x_3$. This requires one AND gate.\n3.  Compute the first major term: $g_3 = x_1 \\land g_1 = x_1 \\land (x_2 \\lor x_3)$. This requires one AND gate, taking $x_1$ and the output of $g_1$ as its inputs.\n4.  Compute the final function: $f = g_3 \\lor g_2$. This requires one OR gate, taking the outputs of $g_3$ and $g_2$ as its inputs.\n\nIn total, this circuit uses 1 OR gate (for $g_1$), 1 AND gate (for $g_2$), 1 AND gate (for $g_3$), and 1 OR gate (for $f$). The total number of gates is $1+1+1+1 = 4$.\nSince this is smaller than the initial size of 5, this is a more efficient design. It can be shown (though is not required for this problem) that a size of 4 is indeed optimal for this function with 2-input monotone gates. Therefore, the minimal size is $S=4$.\n\nNext, we calculate the depth $D$ of this size-4 circuit. The depth is the longest path from an input to the output.\n-   The inputs $x_1, x_2, x_3$ are at depth 0.\n-   The gates $g_1 = x_2 \\lor x_3$ and $g_2 = x_2 \\land x_3$ take inputs directly from the source variables. Their depth is 1.\n-   The gate $g_3 = x_1 \\land g_1$ depends on an input variable $x_1$ (depth 0) and the output of gate $g_1$ (depth 1). Its depth is $1 + \\max(\\text{depth}(x_1), \\text{depth}(g_1)) = 1 + \\max(0, 1) = 2$.\n-   The final output gate $f = g_3 \\lor g_2$ depends on the outputs of $g_3$ (depth 2) and $g_2$ (depth 1). Its depth is $1 + \\max(\\text{depth}(g_3), \\text{depth}(g_2)) = 1 + \\max(2, 1) = 3$.\n\nThe longest path goes through gates $g_1$, then $g_3$, then $f$. For example, the path from $x_2$ to $f$ via $g_1$ and $g_3$ has a length of 3. Thus, the depth of the circuit is $D=3$.\n\nThe minimal size is $S=4$ and the corresponding depth is $D=3$. The answer is the pair $(4, 3)$.", "answer": "$$\\boxed{\\begin{pmatrix} 4 & 3 \\end{pmatrix}}$$", "id": "1432269"}, {"introduction": "Beyond a specific arrangement of gates, every monotone function has an essential \"fingerprint\" defined by its minimal true inputs—the smallest set of conditions that make the function true. This practice shifts the focus from circuit structure to the function's underlying algebraic form. By converting a function's expression into its minimal Disjunctive Normal Form (DNF), you will learn to identify these core requirements, gaining a deeper, implementation-independent understanding of the function's behavior. [@problem_id:1432217]", "problem": "In the study of computational complexity, a Boolean function $f: \\{0,1\\}^n \\to \\{0,1\\}$ is called **monotone** if for any two input vectors $u = (u_1, \\dots, u_n)$ and $v = (v_1, \\dots, v_n)$ such that $u_i \\le v_i$ for all $i=1, \\dots, n$, it holds that $f(u) \\le f(v)$. Informally, this means that changing an input from 0 to 1 can never change the function's output from 1 to 0. Such functions can be expressed using only the logical AND ($\\land$) and OR ($\\lor$) operators.\n\nA **minimal true input** for a monotone function $f$ is an input vector $v$ such that $f(v) = 1$, but for any vector $v'$ obtained by changing a single 1 to a 0 in $v$, we have $f(v') = 0$. The set of all minimal true inputs completely characterizes a monotone function.\n\nConsider the 4-variable monotone Boolean function $f(x_1, x_2, x_3, x_4)$ defined as:\n$$\nf(x_1, x_2, x_3, x_4) = (x_1 \\land x_2) \\lor (x_3 \\land (x_1 \\lor x_4))\n$$\nWhich of the following options represents the complete set of all minimal true inputs for the function $f$? The input vectors are represented as binary strings, where the $i$-th character corresponds to the value of $x_i$.\n\nA. {`1100`, `1010`}\n\nB. {`1100`, `1010`, `1110`}\n\nC. {`1100`, `1010`, `0011`}\n\nD. {`0100`, `0010`, `0001`}\n\nE. {`1100`, `1010`, `0011`, `1011`}", "solution": "The problem asks for the complete set of minimal true inputs for the monotone Boolean function $f(x_1, x_2, x_3, x_4) = (x_1 \\land x_2) \\lor (x_3 \\land (x_1 \\lor x_4))$.\n\nA standard method to find the minimal true inputs of a monotone function is to first express the function in its minimal Disjunctive Normal Form (DNF). For a monotone function, each term in its minimal DNF corresponds to exactly one minimal true input.\n\nFirst, let's expand the given expression for $f$ into its DNF by applying the distributive property of $\\land$ over $\\lor$. The distributive law states that $A \\land (B \\lor C) = (A \\land B) \\lor (A \\land C)$.\nApplying this to the second part of the function expression:\n$$\nx_3 \\land (x_1 \\lor x_4) = (x_3 \\land x_1) \\lor (x_3 \\land x_4)\n$$\nSubstituting this back into the expression for $f$:\n$$\nf(x_1, x_2, x_3, x_4) = (x_1 \\land x_2) \\lor \\left( (x_1 \\land x_3) \\lor (x_3 \\land x_4) \\right)\n$$\nSo, the DNF for $f$ is:\n$$\nf = (x_1 \\land x_2) \\lor (x_1 \\land x_3) \\lor (x_3 \\land x_4)\n$$\n\nNext, we need to ensure this is the minimal DNF. We can check for redundancy using the absorption law, which states that $P \\lor (P \\land Q) = P$. A term in a DNF is redundant if it is implied by another term. For monotone functions, this means checking if one term (conjunction of variables) is a superset of another. For example, $(x_1 \\land x_2 \\land x_3)$ is absorbed by $(x_1 \\land x_2)$.\nLet's examine the three terms in our DNF:\n1. $T_1 = x_1 \\land x_2$\n2. $T_2 = x_1 \\land x_3$\n3. $T_3 = x_3 \\land x_4$\n\nNone of these terms contains all the variables of another term. For instance, $T_1$ does not contain $x_3$ (from $T_2$) or $x_4$ (from $T_3$), so it cannot be absorbed. Similarly, $T_2$ cannot be absorbed by $T_1$ or $T_3$, and $T_3$ cannot be absorbed by $T_1$ or $T_2$. Therefore, the DNF $f = (x_1 \\land x_2) \\lor (x_1 \\land x_3) \\lor (x_3 \\land x_4)$ is minimal.\n\nEach term in this minimal DNF corresponds to a minimal true input. A term of the form $x_{i_1} \\land x_{i_2} \\land \\dots \\land x_{i_k}$ corresponds to an input vector where the variables $x_{i_1}, x_{i_2}, \\dots, x_{i_k}$ are set to 1 and all other variables are set to 0. This input is minimal because setting any one of these specified variables to 0 would make the term false, and since all other variables are already zero, the other terms in the DNF would also be false, resulting in the function evaluating to 0.\n\nLet's derive the minimal true inputs from the terms:\n- From the term $x_1 \\land x_2$: We set $x_1=1$, $x_2=1$, and the rest to 0. This gives the input vector $(1,1,0,0)$, which corresponds to the binary string `1100`.\n- From the term $x_1 \\land x_3$: We set $x_1=1$, $x_3=1$, and the rest to 0. This gives the input vector $(1,0,1,0)$, which corresponds to the binary string `1010`.\n- From the term $x_3 \\land x_4$: We set $x_3=1$, $x_4=1$, and the rest to 0. This gives the input vector $(0,0,1,1)$, which corresponds to the binary string `0011`.\n\nThus, the complete set of minimal true inputs is {`1100`, `1010`, `0011`}.\n\nComparing this with the given options:\n- A. {`1100`, `1010`} is incomplete; it is missing `0011`.\n- B. {`1100`, `1010`, `1110`} includes `1110`, which is not a minimal true input. For the input `1110`, we have $f(1,1,1,0) = (1\\land1)\\lor(1\\land(1\\lor0)) = 1$. However, if we change $x_3$ from 1 to 0, we get the input `1100`. For `1100`, $f(1,1,0,0)=(1\\land1)\\lor(0\\land(1\\lor0))=1$. Since changing a 1 to a 0 does not make the function 0, `1110` is not minimal. It is \"covered\" by the minimal true input `1100`.\n- C. {`1100`, `1010`, `0011`} is the correct set we derived.\n- D. {`0100`, `0010`, `0001`} represents inputs with a single 1. None of these make the function true. For example, $f(0,1,0,0) = (0\\land1)\\lor(0\\land(0\\lor0)) = 0$.\n- E. {`1100`, `1010`, `0011`, `1011`} includes the correct set but also `1011`. The input `1011` is not minimal. $f(1,0,1,1)=(1\\land0)\\lor(1\\land(1\\lor1))=1$. However, it contains two minimal true inputs as sub-vectors (in the component-wise order): `1010` and `0011`. For example, $f(1,0,1,0)=1$, so changing $x_4$ from 1 to 0 doesn't flip the function's output. Thus `1011` is not minimal.\n\nTherefore, the correct option is C.", "answer": "$$\\boxed{C}$$", "id": "1432217"}, {"introduction": "Why do we distinguish between circuit size and formula size in complexity theory? This exercise reveals the dramatic answer. It guides you through a classic example where a family of small, efficient monotone circuits corresponds to Disjunctive Normal Form (DNF) formulas of exponential size. By analyzing this conversion process, you will directly confront the powerful conciseness of the circuit model and understand one of the fundamental separations between different computational representations. [@problem_id:1432222]", "problem": "In computational complexity theory, a monotone Boolean circuit is a circuit constructed using only AND ($\\wedge$) and OR ($\\vee$) gates, with inputs from a set of variables $\\{x_1, x_2, \\ldots, x_n\\}$. Monotone circuits do not contain any NOT ($\\neg$) gates. The size of a circuit is defined as the total number of gates it contains.\n\nAny function computed by a monotone circuit can be represented by an equivalent monotone Disjunctive Normal Form (DNF) formula. A monotone DNF is an OR of one or more clauses, where each clause is an AND of one or more input variables (e.g., $(x_1 \\wedge x_3) \\vee (x_2 \\wedge x_5)$).\n\nA standard recursive procedure exists to convert a monotone circuit into its DNF representation. Let $D(g)$ denote the DNF formula for the function computed by a gate $g$.\n- If $g$ is an input variable $x_i$, then $D(g) = x_i$.\n- If $g$ is an OR gate with inputs $g_1$ and $g_2$, then $D(g) = D(g_1) \\vee D(g_2)$.\n- If $g$ is an AND gate with inputs $g_1$ and $g_2$, where $D(g_1) = \\bigvee_i A_i$ and $D(g_2) = \\bigvee_j B_j$, then $D(g) = \\bigvee_{i,j} (A_i \\wedge B_j)$ by applying the distributive law.\n\nConsider a specific family of monotone circuits, parameterized by an integer $k \\ge 1$, that is known to exhibit a significant increase in size when converted to DNF. The circuit has $2k$ distinct input variables: $\\{x_1, \\ldots, x_k, y_1, \\ldots, y_k\\}$. The circuit is constructed as follows:\n1. A first layer of $k$ OR gates, where the $i$-th gate (for $i=1, \\ldots, k$) computes $g_i = x_i \\vee y_i$. All gates are assumed to have a fan-in of 2.\n2. The outputs of these $k$ OR gates are then fed into a balanced binary tree of $k-1$ AND gates to produce a single final output.\n\nThe total size of this circuit, counting both the OR gates and the AND gates, is $s = 2k-1$.\n\nYour task is to determine the number of clauses in the final monotone DNF formula that is equivalent to this circuit. Express your answer as a function of the total circuit size $s$.", "solution": "The circuit computes the monotone function\n$$\nF=\\bigwedge_{i=1}^{k}(x_{i}\\vee y_{i}).\n$$\nDefine $C(g)$ as the number of clauses in the monotone DNF $D(g)$.\n\nBy the given recursive DNF construction:\n- For an input variable $x_{i}$, $D(x_{i})=x_{i}$ is a single clause, so $C(x_{i})=1$, and similarly $C(y_{i})=1$.\n- For an OR gate, $D(g_{1}\\vee g_{2})=D(g_{1})\\vee D(g_{2})$, hence clause counts add:\n$$\nC(g_{1}\\vee g_{2})=C(g_{1})+C(g_{2}).\n$$\n- For an AND gate, if $D(g_{1})=\\bigvee_{i}A_{i}$ and $D(g_{2})=\\bigvee_{j}B_{j}$, then $D(g_{1}\\wedge g_{2})=\\bigvee_{i,j}(A_{i}\\wedge B_{j})$, hence clause counts multiply:\n$$\nC(g_{1}\\wedge g_{2})=C(g_{1})\\,C(g_{2}).\n$$\n\nFor each first-layer gate $g_{i}=x_{i}\\vee y_{i}$, using additivity over OR and $C(x_{i})=C(y_{i})=1$,\n$$\nC(g_{i})=C(x_{i})+C(y_{i})=1+1=2.\n$$\nThe final output is the AND of the $k$ gates $g_{1},\\ldots,g_{k}$. Using multiplicativity over AND,\n$$\nC(F)=\\prod_{i=1}^{k}C(g_{i})=\\prod_{i=1}^{k}2=2^{k}.\n$$\nSince the total circuit size is $s=2k-1$, we solve for $k$ to get $k=\\frac{s+1}{2}$. Substituting,\n$$\nC(F)=2^{\\frac{s+1}{2}}.\n$$\nTherefore, the number of clauses in the final monotone DNF as a function of the circuit size $s$ is $2^{\\frac{s+1}{2}}$.", "answer": "$$\\boxed{2^{\\frac{s+1}{2}}}$$", "id": "1432222"}]}