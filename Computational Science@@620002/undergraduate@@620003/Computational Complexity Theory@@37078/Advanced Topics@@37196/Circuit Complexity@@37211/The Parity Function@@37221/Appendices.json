{"hands_on_practices": [{"introduction": "To truly understand the complexity of a function, we must first determine the minimum amount of information required to compute it. This thought experiment [@problem_id:1460431] frames this question as an intuitive 'Parity Puzzle'. By figuring out the winning strategy, you will establish a fundamental lower bound on the computational resources needed for the parity function, a concept known as query complexity.", "problem": "You are playing a game called the 'Parity Puzzle' against a game master. The game master secretly chooses a binary string $B$ of length $n$, where $B = b_1 b_2 \\dots b_n$ and each $b_i$ is either 0 or 1.\n\nYour goal is to determine the parity of the string $B$. The parity of a binary string is defined as 1 if the number of ones in the string is odd, and 0 if the number of ones is even.\n\nTo achieve this, you are allowed to make a specific type of query. In each query, you can choose an index $i$ (where $1 \\le i \\le n$) and ask the game master for the value of the bit $b_i$. The game master will truthfully reveal the value of $b_i$.\n\nWhat is the minimum number of queries you must make to be absolutely certain of the parity of the entire string $B$, regardless of the string the game master has chosen? Express your answer as a function of $n$.", "solution": "Let $B = b_{1}b_{2}\\dots b_{n}$ with each $b_{i} \\in \\{0,1\\}$. The parity of $B$ is the XOR of its bits, defined as\n$$\nP(B) = \\bigoplus_{i=1}^{n} b_{i},\n$$\nwhich equals $1$ if the number of ones is odd and $0$ otherwise.\n\nLower bound (necessity of $n$ queries): Consider any deterministic strategy that queries $k<n$ indices, possibly adaptively, and suppose the set of queried indices is $Q \\subset \\{1,\\dots,n\\}$ with $|Q|=k$. After $k$ answers, there remains at least one unqueried index $j \\notin Q$. Let $B$ be any string consistent with the $k$ revealed bits. Construct another string $B'$ that agrees with $B$ on all queried indices and on all unqueried indices except $j$, and at $j$ set $b'_{j} = b_{j} \\oplus 1$. Then\n$$\nP(B') = \\left(\\bigoplus_{i \\in Q} b_{i}\\right) \\oplus \\left(\\bigoplus_{i \\notin Q, i \\neq j} b_{i}\\right) \\oplus b'_{j}\n= \\left(\\bigoplus_{i=1}^{n} b_{i}\\right) \\oplus 1\n= P(B) \\oplus 1.\n$$\nThus, given the same $k$ query answers, both parities $0$ and $1$ are consistent, so one cannot be certain of $P(B)$. Therefore any correct strategy requires at least $n$ queries in the worst case.\n\nUpper bound (sufficiency of $n$ queries): Query all $n$ bits, compute $P(B) = \\bigoplus_{i=1}^{n} b_{i}$ using associativity and commutativity of XOR, and output the result. This uses exactly $n$ queries and is always correct.\n\nBy matching lower and upper bounds, the minimum number of queries required to be certain of the parity is $n$.", "answer": "$$\\boxed{n}$$", "id": "1460431"}, {"introduction": "Computing a function's output is one challenge; verifying that a given output is correct is another. This practice [@problem_id:1460461] introduces the concept of non-deterministic complexity, which measures the minimum information needed to *certify* an answer. You will discover a surprising and important property of the parity function: proving its value is just as difficult as computing it from scratch.", "problem": "In the field of computational complexity theory, a decision tree is a model of computation where an algorithm queries an input, one bit at a time, to determine the value of a function. The non-deterministic decision tree complexity of a function measures the minimum amount of information required to *certify* the function's output.\n\nConsider a Boolean function $f: \\{0, 1\\}^n \\to \\{0, 1\\}$ that takes an $n$-bit binary string $x = x_1x_2...x_n$ as input.\n\nA **1-certificate** for an input $x$ (where $f(x)=1$) is a partial assignment of values to a subset of the input bits, say at indices $I \\subseteq \\{1, 2, ..., n\\}$, such that any full $n$-bit string $y$ that agrees with the assignment on indices $I$ must satisfy $f(y)=1$. The size of the certificate is $|I|$. The **1-certificate complexity**, denoted $C_1(f)$, is the smallest integer $k$ such that for every input $x$ with $f(x)=1$, there exists a 1-certificate for $x$ of size at most $k$.\n\nSimilarly, a **0-certificate** is defined for inputs where $f(x)=0$, and the **0-certificate complexity** is denoted $C_0(f)$.\n\nThe overall **non-deterministic decision tree complexity** of the function $f$ is given by $N(f) = \\max \\left( C_0(f), C_1(f) \\right)$. This represents the minimum number of bits one must query in the worst case to be able to convince a verifier of the output value, given an oracle that suggests which bits to query.\n\nLet the $n$-bit parity function, $\\text{PARITY}_n: \\{0, 1\\}^n \\to \\{0, 1\\}$, be defined as:\n$$\n\\text{PARITY}_n(x) = \\begin{cases} 1 & \\text{if the number of 1s in } x \\text{ is odd} \\\\ 0 & \\text{if the number of 1s in } x \\text{ is even} \\end{cases}\n$$\nThis is equivalent to the exclusive OR (XOR) of the bits: $\\text{PARITY}_n(x) = x_1 \\oplus x_2 \\oplus \\dots \\oplus x_n$.\n\nDetermine the non-deterministic decision tree complexity, $N(\\text{PARITY}_n)$, for the $n$-bit parity function, where $n \\ge 2$.\n\nA. $1$\n\nB. $\\lfloor \\frac{n}{2} \\rfloor + 1$\n\nC. $n-1$\n\nD. $n$\n\nE. $2^n$", "solution": "We use the given definition that the non-deterministic decision tree complexity is $N(f)=\\max\\left(C_{0}(f),C_{1}(f)\\right)$, where $C_{b}(f)$ is the smallest integer $k$ such that every input $x$ with $f(x)=b$ has a $b$-certificate of size at most $k$.\n\nWe first prove a lower bound of $n$ on both $C_{0}(\\text{PARITY}_{n})$ and $C_{1}(\\text{PARITY}_{n})$. Fix any input $x \\in \\{0,1\\}^{n}$ and let $b=\\text{PARITY}_{n}(x) \\in \\{0,1\\}$. Consider any subset $I \\subseteq \\{1,2,\\dots,n\\}$ with $|I| \\leq n-1$. There exists an index $j \\in \\{1,2,\\dots,n\\} \\setminus I$. Define $y \\in \\{0,1\\}^{n}$ by $y_{i}=x_{i}$ for all $i \\neq j$ and $y_{j}=1-x_{j}$. Then $y$ agrees with $x$ on all indices in $I$, but since the parity function flips when a single bit is flipped, we have\n$$\n\\text{PARITY}_{n}(y)=1-\\text{PARITY}_{n}(x)=1-b.\n$$\nThus any partial assignment that fixes only the bits in $I$ cannot force the value $\\text{PARITY}_{n}=b$, because there exists a completion $y$ consistent with that assignment for which the value is $1-b$. Therefore no $b$-certificate for $x$ can have size at most $n-1$. Since $x$ and $b$ were arbitrary, this shows\n$$\nC_{0}(\\text{PARITY}_{n}) \\geq n \\quad \\text{and} \\quad C_{1}(\\text{PARITY}_{n}) \\geq n.\n$$\n\nWe next prove an upper bound of $n$ on both certificate complexities. For any input $x$, the full assignment that fixes all $n$ bits (i.e., $I=\\{1,2,\\dots,n\\}$ with the values given by $x$) is trivially a valid certificate of the correct value, because any string agreeing with $x$ on all $n$ positions is exactly $x$ and hence has the same parity. Therefore,\n$$\nC_{0}(\\text{PARITY}_{n}) \\leq n \\quad \\text{and} \\quad C_{1}(\\text{PARITY}_{n}) \\leq n.\n$$\n\nCombining the lower and upper bounds, we obtain\n$$\nC_{0}(\\text{PARITY}_{n})=C_{1}(\\text{PARITY}_{n})=n,\n$$\nand hence\n$$\nN(\\text{PARITY}_{n})=\\max\\left(C_{0}(\\text{PARITY}_{n}),C_{1}(\\text{PARITY}_{n})\\right)=n.\n$$\n\nTherefore, among the given options, the correct choice is $D$.", "answer": "$$\\boxed{D}$$", "id": "1460461"}, {"introduction": "Boolean functions can be analyzed using powerful algebraic tools by representing them as polynomials. This exercise [@problem_id:1460441] guides you through the process of finding the unique multilinear polynomial that represents the three-variable parity function. Mastering this technique provides a bridge from the discrete world of bits to the continuous world of real-valued polynomials, unlocking new methods for analyzing computational hardness.", "problem": "In the analysis of Boolean functions, it is often useful to represent them as real-valued polynomials. Consider the three-variable parity function, denoted as $PARITY_3: \\{0,1\\}^3 \\to \\{0,1\\}$. This function returns $1$ if the number of inputs equal to $1$ is odd, and $0$ otherwise. For example, $PARITY_3(1,0,0)=1$ and $PARITY_3(1,1,0)=0$.\n\nA polynomial $P(x_1, x_2, x_3)$ is said to be multilinear if in every term, each variable $x_i$ appears with a power of at most one. There exists a unique real-valued multilinear polynomial that exactly matches the output of the $PARITY_3$ function for all eight possible inputs from the domain $\\{0,1\\}^3$.\n\nFind this unique multilinear polynomial. Express your answer as a polynomial in terms of $x_1$, $x_2$, and $x_3$.", "solution": "We seek the unique real multilinear polynomial $P(x_{1},x_{2},x_{3})$ that equals $PARITY_{3}(x_{1},x_{2},x_{3})$ on all inputs in $\\{0,1\\}^{3}$. Any multilinear polynomial in three variables has the form\n$$\nP(x_{1},x_{2},x_{3})=a_{0}+a_{1}x_{1}+a_{2}x_{2}+a_{3}x_{3}+a_{12}x_{1}x_{2}+a_{13}x_{1}x_{3}+a_{23}x_{2}x_{3}+a_{123}x_{1}x_{2}x_{3}.\n$$\nWe determine the coefficients by enforcing $P$ to match $PARITY_{3}$ at each corner of the cube.\n\nUsing $PARITY_{3}(0,0,0)=0$ gives\n$$\nP(0,0,0)=a_{0}=0.\n$$\nUsing $PARITY_{3}(1,0,0)=1$, $PARITY_{3}(0,1,0)=1$, and $PARITY_{3}(0,0,1)=1$ gives\n$$\nP(1,0,0)=a_{0}+a_{1}=1 \\;\\Rightarrow\\; a_{1}=1,\n$$\n$$\nP(0,1,0)=a_{0}+a_{2}=1 \\;\\Rightarrow\\; a_{2}=1,\n$$\n$$\nP(0,0,1)=a_{0}+a_{3}=1 \\;\\Rightarrow\\; a_{3}=1.\n$$\nUsing $PARITY_{3}(1,1,0)=0$, $PARITY_{3}(1,0,1)=0$, and $PARITY_{3}(0,1,1)=0$ gives\n$$\nP(1,1,0)=a_{0}+a_{1}+a_{2}+a_{12}=0 \\;\\Rightarrow\\; 0+1+1+a_{12}=0 \\;\\Rightarrow\\; a_{12}=-2,\n$$\n$$\nP(1,0,1)=a_{0}+a_{1}+a_{3}+a_{13}=0 \\;\\Rightarrow\\; 0+1+1+a_{13}=0 \\;\\Rightarrow\\; a_{13}=-2,\n$$\n$$\nP(0,1,1)=a_{0}+a_{2}+a_{3}+a_{23}=0 \\;\\Rightarrow\\; 0+1+1+a_{23}=0 \\;\\Rightarrow\\; a_{23}=-2.\n$$\nFinally, using $PARITY_{3}(1,1,1)=1$ gives\n$$\nP(1,1,1)=a_{0}+a_{1}+a_{2}+a_{3}+a_{12}+a_{13}+a_{23}+a_{123}=1,\n$$\n$$\n0+1+1+1-2-2-2+a_{123}=1 \\;\\Rightarrow\\; -3+a_{123}=1 \\;\\Rightarrow\\; a_{123}=4.\n$$\nSubstituting all coefficients yields the unique multilinear polynomial\n$$\nP(x_{1},x_{2},x_{3})=x_{1}+x_{2}+x_{3}-2x_{1}x_{2}-2x_{1}x_{3}-2x_{2}x_{3}+4x_{1}x_{2}x_{3}.\n$$", "answer": "$$\\boxed{x_{1}+x_{2}+x_{3}-2x_{1}x_{2}-2x_{1}x_{3}-2x_{2}x_{3}+4x_{1}x_{2}x_{3}}$$", "id": "1460441"}]}