{"hands_on_practices": [{"introduction": "We begin our exploration of parallel computation with the most fundamental class in the NC hierarchy, $NC^0$. This class captures problems where each output can be determined by examining only a constant number of inputs, making them solvable with constant-depth circuits. This exercise [@problem_id:1459534] on converting binary numbers to Gray codes provides a perfect, concrete example of such a \"locally computable\" problem, helping you build an intuitive foundation for parallel complexity.", "problem": "In the field of computational complexity theory, the NC hierarchy (Nick's Class) is used to classify problems that are considered \"efficiently parallelizable.\" A problem is said to be in the class $NC^k$ if it can be solved by a uniform family of boolean circuits with a size that is polynomial in the input size $n$ and a depth that is polylogarithmic, specifically $O(\\log^k n)$. The class $NC^0$ corresponds to problems solvable with constant-depth, polynomial-size circuits, where each output bit can only depend on a constant number of input bits.\n\nConsider the problem of converting an $n$-bit binary integer into its corresponding $n$-bit reflected binary code, also known as the Gray code. Let the input binary representation be $B = b_{n-1}b_{n-2}...b_1b_0$ and the output Gray code be $G = g_{n-1}g_{n-2}...g_1g_0$. The conversion is defined by the following rules:\n- The most significant bit remains the same: $g_{n-1} = b_{n-1}$.\n- For all other bits (where $0 \\le i < n-1$), the Gray code bit is the exclusive OR (XOR) of the corresponding binary bit and the next more significant binary bit: $g_i = b_i \\oplus b_{i+1}$.\n\nBased on the provided definitions, determine the most precise classification for this conversion problem within the NC hierarchy.\n\nA. The problem is in $NC^0$.\n\nB. The problem is in $NC^1$, but not in $NC^0$.\n\nC. The problem is in $NC^2$, but not in $NC^1$.\n\nD. The problem is P-complete and is therefore believed not to be in any $NC^k$ class.\n\nE. The classification depends on whether $n$ is a power of two.", "solution": "We are asked to classify, within the NC hierarchy, the mapping from an $n$-bit binary number $B = b_{n-1}b_{n-2}\\dots b_{1}b_{0}$ to its $n$-bit Gray code $G = g_{n-1}g_{n-2}\\dots g_{1}g_{0}$ defined by\n$$\ng_{n-1} = b_{n-1}, \\quad g_{i} = b_{i} \\oplus b_{i+1} \\quad \\text{for } 0 \\leq i < n-1.\n$$\nBy definition, a language (or function) is in $NC^{k}$ if there exists a uniform family of Boolean circuits of polynomial size and depth $O\\!\\left((\\log n)^{k}\\right)$ computing it, with bounded fan-in. The class $NC^{0}$ consists of functions computable by uniform families of constant-depth, polynomial-size circuits with bounded fan-in, equivalently where each output bit depends on only $O(1)$ input bits.\n\nFor each $i$ with $0 \\leq i < n-1$, the output bit $g_{i}$ depends only on the two input bits $b_{i}$ and $b_{i+1}$, and for $i = n-1$ we have $g_{n-1}$ depending only on $b_{n-1}$. Thus each output bit depends on a constant number of inputs, independent of $n$. Moreover, each $g_{i}$ can be computed by a constant-depth bounded fan-in circuit over $\\{\\land,\\lor,\\neg\\}$, since the exclusive-or of two bits has the standard Boolean expression\n$$\nb_{i} \\oplus b_{i+1} \\;=\\; (b_{i} \\land \\neg b_{i+1}) \\;\\lor\\; (\\neg b_{i} \\land b_{i+1}).\n$$\nThis realization uses at most one layer of negations feeding a layer of binary $\\land$ gates, feeding a single binary $\\lor$ gate, giving constant depth (for example, depth $3$ with bounded fan-in $2$). The most significant bit $g_{n-1} = b_{n-1}$ is implemented by a wire. Therefore, computing all $n$ output bits in parallel yields a circuit of depth that is a fixed constant, independent of $n$, and of size $O(n)$, which is polynomial in $n$.\n\nRegarding uniformity, the wiring pattern is completely regular: for each $i$, the gates for $g_{i}$ connect only to $b_{i}$ and $b_{i+1}$ (or to $b_{n-1}$ alone when $i = n-1$). Hence a standard uniformity condition (such as DLOGTIME-uniformity) is satisfied, because a deterministic Turing machine can, given $n$ and gate indices encoded in binary, compute the connections in time $O(\\log n)$.\n\nThus the conversion mapping is computable by a uniform family of constant-depth, polynomial-size, bounded fan-in Boolean circuits in which each output bit depends on $O(1)$ input bits. Therefore the problem is in $NC^{0}$. Since $NC^{0} \\subseteq NC^{1} \\subseteq NC^{2} \\subseteq \\dots$, the most precise classification among the given options is that it is in $NC^{0}$.", "answer": "$$\\boxed{A}$$", "id": "1459534"}, {"introduction": "Many problems require integrating information across the entire input and thus cannot be solved in constant depth. The class $NC^1$ addresses this by allowing for logarithmic-depth circuits, introducing powerful algorithmic techniques for parallel processing. By analyzing the \"First-One\" problem [@problem_id:1459518], you will discover how a classic parallel prefix algorithm can transform a seemingly sequential search into an efficient, logarithmic-time parallel computation.", "problem": "In the field of parallel computing, understanding the inherent parallelism of a problem is crucial for designing efficient algorithms. The complexity class known as Nick's Class (NC) provides a framework for this analysis. A computational problem is said to belong to NC if it can be solved on a parallel computer in polylogarithmic time (i.e., time proportional to $O(\\log^k n)$ for some constant $k$, where $n$ is the input size) using a number of processors that is polynomial in $n$. More specifically, a problem is in NC$^k$ if its parallel time complexity is $O(\\log^k n)$.\n\nConsider the fundamental \"First-One\" problem, which is a common subroutine in parallel data processing. The problem is defined as follows: Given a binary string $S$ of length $n$, represented as an array of bits $S[1..n]$, find the smallest index $i$ such that $S[i]=1$. If the string contains no '1's, the output should be 0.\n\nBased on these definitions, determine the most precise classification for the \"First-One\" problem within the NC hierarchy.\n\nA. The problem is in NC$^1$.\n\nB. The problem is P-complete, which implies it is unlikely to be in NC.\n\nC. The problem requires $\\Omega(n)$ time to solve, even on a parallel machine, and thus is not in NC.\n\nD. The problem is in NC$^2$ but is not in NC$^1$.", "solution": "We recall the NC definition: a problem is in NC if it can be solved in time $O(\\log^{k} n)$ for some fixed $k \\in \\mathbb{N}$ using a number of processors polynomial in $n$. The class NC$^{1}$ consists of problems solvable with depth $O(\\log n)$ using polynomially many processors and bounded fan-in.\n\nWe construct an $O(\\log n)$-depth parallel algorithm for the First-One function. Let the input be $S[1],\\dots,S[n] \\in \\{0,1\\}$. Define the prefix-OR array $Q[1],\\dots,Q[n]$ by\n$$\nQ[i] \\equiv \\bigvee_{j=1}^{i} S[j].\n$$\nThe Boolean OR operation is associative, so we can compute all $Q[i]$ with a standard parallel prefix method in $O(\\log n)$ depth and polynomial work. One explicit method is recursive doubling: define $R^{(0)}[i] = S[i]$ for all $i$, and for $t=1,2,\\dots,\\lceil \\log_{2} n \\rceil$ set\n$$\nR^{(t)}[i] = \\begin{cases}\nR^{(t-1)}[i] \\lor R^{(t-1)}[i-2^{t-1}], & \\text{if } i>2^{t-1},\\\\\nR^{(t-1)}[i], & \\text{otherwise}.\n\\end{cases}\n$$\nEach stage uses only fan-in-$2$ OR gates, so has constant depth, and there are $\\lceil \\log_{2} n \\rceil$ stages. At the end, $Q[i] = R^{(\\lceil \\log_{2} n \\rceil)}[i]$ for all $i$, and the total depth is $O(\\log n)$ with $O(n)$ processors per stage, hence polynomially many processors overall.\n\nIntroduce $Q[0] \\equiv 0$ and define the marker array $M[1],\\dots,M[n]$ by\n$$\nM[i] \\equiv S[i] \\land \\lnot Q[i-1] = Q[i] \\land \\lnot Q[i-1].\n$$\nBy construction, $M[i]=1$ if and only if $i$ is the smallest index with $S[i]=1$; otherwise $M[i]=0$. If the string has no ones, then $Q[n]=0$ and thus $M[i]=0$ for all $i$.\n\nWe now encode the index as a binary number in the range $\\{0,1,\\dots,n\\}$. Let $L \\equiv \\lceil \\log_{2}(n+1) \\rceil$. For each bit position $b \\in \\{0,1,\\dots,L-1\\}$, define the $b$-th output bit $B[b]$ by\n$$\nB[b] \\equiv \\bigvee_{i=1}^{n} \\left( M[i] \\land \\mathrm{bit}_{b}(i) \\right),\n$$\nwhere $\\mathrm{bit}_{b}(i) \\in \\{0,1\\}$ is the $b$-th binary digit of $i$. Since at most one $M[i]$ equals $1$, these OR-reductions simply select the bits of that unique index; if all $M[i]=0$, then all $B[b]=0$, representing $0$. Each $B[b]$ is an OR over $n$ terms of fan-in $2$ OR gates arranged in a balanced binary tree, giving depth $O(\\log n)$. All $L$ bits are computed in parallel, so the depth for this stage remains $O(\\log n)$, and the number of processors is $O(n L)$, which is polynomial in $n$.\n\nCombining the stages, the total parallel time (circuit depth) is\n$$\nO(\\log n) + O(1) + O(\\log n) = O(\\log n),\n$$\nwith a number of processors polynomial in $n$ and bounded fan-in gates. Therefore, the First-One problem is in NC$^{1}$.\n\nThis shows option A is correct. Option B is false because the problem is not P-complete; it admits an NC$^{1}$ algorithm. Option C is false because the above algorithm runs in $O(\\log n)$ time on a parallel machine. Option D is false because we have exhibited an NC$^{1}$ algorithm; moreover, known separations do not place it outside NC$^{1}$.", "answer": "$$\\boxed{A}$$", "id": "1459518"}, {"introduction": "A crucial aspect of complexity theory is proving that a problem *cannot* be solved within a certain resource bound. This is often achieved through reductions, a method where you show that if a simple class could solve a \"hard\" problem, it would lead to a contradiction. Based on a hypothetical scenario involving oracle gates, this thought experiment [@problem_id:1459513] guides you to use the logic of reducibility to deduce the computational complexity of integer division relative to the class $TC^0$, a powerful skill for reasoning about the limits of computation.", "problem": "In computational complexity theory, circuit complexity classes categorize problems based on the resources required to solve them using Boolean circuits. One such class is $TC^0$, which contains problems solvable by circuit families of constant depth and polynomial size, built from unbounded fan-in AND, OR, and Threshold gates. A Threshold gate outputs 1 if the number of its inputs that are 1 exceeds a certain threshold, and 0 otherwise.\n\nConsider the following two computational problems for $n$-bit integers:\n1.  `DIVISION`: Given two $n$-bit integers, a dividend $A$ and a divisor $B \\neq 0$, compute the integer quotient $Q = \\lfloor A/B \\rfloor$ and remainder $R = A \\pmod B$.\n2.  `ITERATED_MULTIPLICATION`: Given $n$ integers $x_1, x_2, \\ldots, x_n$, each with $n$ bits, compute their product $P = \\prod_{i=1}^{n} x_i$.\n\nYou are given the following two statements, which are established results in the field:\n*   **Fact 1:** The `ITERATED_MULTIPLICATION` problem is not in $TC^0$.\n*   **Fact 2:** The `ITERATED_MULTIPLICATION` problem is $TC^0$-reducible to the `DIVISION` problem. This means a circuit for `ITERATED_MULTIPLICATION` can be constructed using only the components and structure allowed for a $TC^0$ circuit (constant depth, polynomial size), with the addition of a constant number of hypothetical oracle gates that can solve `DIVISION` in a single time step.\n\nBased *only* on these two facts, what is the strongest correct conclusion one can draw about the `DIVISION` problem?\n\nA) `DIVISION` is necessarily in $TC^0$, because the reduction from a harder problem confirms its own simplicity.\n\nB) `DIVISION` cannot be in $TC^0$, because if it were, the reduction would place `ITERATED_MULTIPLICATION` in $TC^0$, leading to a contradiction.\n\nC) `DIVISION` must be harder than `ITERATED_MULTIPLICATION` because problems that serve as oracles are always more complex.\n\nD) `DIVISION` and `ITERATED_MULTIPLICATION` must have the exact same complexity, but their relationship with $TC^0$ is undetermined.\n\nE) The provided information is insufficient, as the complexity of the reduction itself might place the combined circuit outside of $TC^0$.", "solution": "We are given two facts: (i) $ITERATED\\_MULTIPLICATION \\notin TC^{0}$, and (ii) $ITERATED\\_MULTIPLICATION$ is $TC^{0}$-reducible to $DIVISION$ via a constant-depth, polynomial-size circuit using a constant number $k$ of oracle gates for $DIVISION$.\n\nAssume, for the sake of contradiction, that $DIVISION \\in TC^{0}$. Let the $TC^{0}$ circuit computing $DIVISION$ have depth $d_{2}$ and polynomial size $p_{2}(n)$. Let the reduction circuit for $ITERATED\\_MULTIPLICATION$ using $DIVISION$-oracles have depth $d_{1}$, polynomial size $p_{1}(n)$, and at most $k$ oracle gates arranged in a fixed constant number of layers (so the number of oracle invocations along any path is at most $k$).\n\nReplace each oracle gate for $DIVISION$ by its $TC^{0}$ circuit. The resulting composed circuit has depth at most\n$$\nd_{1} + k \\cdot d_{2},\n$$\nwhich is a constant, since both $d_{1}$ and $d_{2}$ are constants and $k$ is a constant. Its size is at most\n$$\np_{1}(n) + k \\cdot p_{2}(n) \\cdot p_{1}(n),\n$$\nwhich is polynomial in $n$. Therefore, under the assumption $DIVISION \\in TC^{0}$, the reduction implies that $ITERATED\\_MULTIPLICATION \\in TC^{0}$.\n\nThis contradicts Fact 1, which states $ITERATED\\_MULTIPLICATION \\notin TC^{0}$. Hence the assumption is false, and we conclude\n$$\nDIVISION \\notin TC^{0}.\n$$\n\nEvaluating the options:\n- A is false.\n- B is exactly the contrapositive argument above and is true.\n- C is unjustified by the facts; oracle-use does not imply strictly greater complexity.\n- D is unsupported; only a one-way reducibility is given.\n- E is false because the reduction is explicitly within $TC^{0}$ with a constant number of oracle gates, and inlining a $TC^{0}$ oracle preserves $TC^{0}$.\n\nTherefore, the strongest correct conclusion is option B.", "answer": "$$\\boxed{B}$$", "id": "1459513"}]}