{"hands_on_practices": [{"introduction": "The core idea behind the complexity class P/poly is its non-uniformity, meaning we can use a different, specialized circuit for each input length. This first exercise explores this concept in its most direct form by considering a language where membership depends solely on the length of the input string. This practice will help you understand that if the decision for a given length $n$ is fixed, the corresponding circuit $C_n$ can be extremely simple, highlighting the power of length-specific design. [@problem_id:1454195]", "problem": "In computational complexity theory, the class of languages with polynomial-size circuits, denoted P/poly, plays a crucial role in understanding the limits of efficient computation. A language $L$ over the binary alphabet $\\{0, 1\\}$ is in P/poly if there exists a family of Boolean circuits $\\{C_n\\}_{n \\ge 0}$ and a polynomial $p(n)$ such that:\n1. For each non-negative integer $n$, the circuit $C_n$ has $n$ inputs.\n2. The size of each circuit $C_n$, defined as the total count of its AND, OR, and NOT gates, is at most $p(n)$.\n3. For any binary string $w$ of length $n$, the circuit $C_n$ outputs 1 if and only if $w \\in L$.\n\nConsider the language $L_{parity}$ defined as the set of all binary strings whose length is an even number.\n$L_{parity} = \\{ w \\in \\{0, 1\\}^* \\mid |w| \\text{ is an even number} \\}$\n\nFor this language $L_{parity}$, a circuit family $\\{C_n\\}_{n \\ge 1}$ must exist that decides it. Which of the following statements best describes the minimum possible size for the circuits $C_n$ for $n \\ge 1$?\n\nA. The size of $C_n$ must grow linearly with $n$, i.e., the size is $\\Theta(n)$.\n\nB. The size of $C_n$ can be a constant, independent of $n$.\n\nC. The size of $C_n$ must grow quadratically with $n$, i.e., the size is $\\Theta(n^2)$.\n\nD. The size of $C_n$ must grow exponentially with $n$, i.e., the size is $\\Theta(2^n)$.\n\nE. No such circuit family exists because the language is non-uniform.", "solution": "We are given the language $L_{parity} = \\{ w \\in \\{0,1\\}^{*} \\mid |w| \\text{ is even} \\}$. For a fixed input length $n$, the decision function computed by $C_{n}$ is\n$$\nf_{n}(w) =\n\\begin{cases}\n1 & \\text{if } n \\text{ is even},\\\\\n0 & \\text{if } n \\text{ is odd},\n\\end{cases}\n$$\nfor all $w \\in \\{0,1\\}^{n}$. Thus, for each fixed $n$, $f_{n}$ is a constant function on $\\{0,1\\}^{n}$, independent of the input bits.\n\nTo realize such a function by Boolean circuits with AND, OR, and NOT gates:\n- If $n$ is even, define $C_{n}$ to output the tautology $x_{1} \\vee \\neg x_{1}$, which always equals $1$. This uses one NOT gate and one OR gate, so the size is a constant (specifically $2$), independent of $n$.\n- If $n$ is odd, define $C_{n}$ to output the contradiction $x_{1} \\wedge \\neg x_{1}$, which always equals $0$. This uses one NOT gate and one AND gate, so again the size is a constant (specifically $2$), independent of $n$.\n\nTherefore, there exists a circuit family $\\{C_{n}\\}_{n \\ge 1}$ deciding $L_{parity}$ such that the size of $C_{n}$ is bounded by a constant independent of $n$. This shows that linear, quadratic, or exponential growth is unnecessary. Moreover, statement E is incorrect because P/poly explicitly allows non-uniform circuit families, and here a simple non-uniform constant-size family suffices.\n\nHence the correct choice is that the circuit size can be a constant, independent of $n$.", "answer": "$$\\boxed{B}$$", "id": "1454195"}, {"introduction": "Building on the basic principle of non-uniformity, we now explore how length-specific information can be integrated into circuit design. This problem asks you to consider a language where the decision rule for a given length $n$ depends on a specific but arbitrary \"threshold\" string $s_n$. This exercise demonstrates how such non-uniform \"advice\" can be hardwired directly into the structure of a polynomial-size circuit, clarifying the relationship between the circuit-family and advice-string models of P/poly. [@problem_id:1454160]", "problem": "In computational complexity theory, the class P/poly (non-uniform polynomial time) represents languages that can be decided by a family of polynomial-size Boolean circuits. More formally, a language $L \\subseteq \\{0,1\\}^*$ is in P/poly if there exists a polynomial $p(n)$ and a family of circuits $\\{C_n\\}_{n \\in \\mathbb{N}}$ such that for every natural number $n$:\n1. The circuit $C_n$ has at most $p(n)$ gates.\n2. For any string $x$ of length $n$, the circuit $C_n$ outputs 1 if $x \\in L$ and 0 if $x \\notin L$.\n\nNote that the circuit $C_n$ can be different for each input length $n$.\n\nConsider a language $L$ which is defined by an arbitrary, fixed sequence of \"threshold\" strings $\\{s_n\\}_{n \\in \\mathbb{N}}$, where each $s_n$ is a binary string of length $n$. The language $L$ is the union of all $L_n$ for $n \\in \\mathbb{N}$, where $L_n$ is defined as:\n$$L_n = \\{x \\in \\{0,1\\}^n \\mid x \\text{ is lexicographically smaller than } s_n\\}$$\nFor example, if for $n=3$, the fixed string is $s_3 = 101$, then the strings $000, 001, 010, 011, 100$ are in $L_3$, while $101, 110, 111$ are not.\n\nThe sequence of strings $\\{s_n\\}$ is arbitrary; it is not required to be computable in any way. Which of the following statements provides the correct justification for why the language $L$ must be in P/poly?\n\nA. The language is in P/poly because a single polynomial-time Turing machine can be constructed. This machine takes an input string $x$ and the corresponding string $s_{|x|}$, compares them lexicographically, and accepts or rejects accordingly.\n\nB. The language is not necessarily in P/poly because the sequence $\\{s_n\\}$ could be defined based on an uncomputable problem (e.g., where $s_n$ encodes information about the Halting Problem). P/poly circuit families cannot solve uncomputable problems.\n\nC. For each input length $n$, the specific string $s_n$ can be hardwired into the logic of a dedicated circuit, $C_n$. This circuit compares the input $x$ to the hardwired $s_n$ using a number of gates that is polynomial in $n$. The existence of such a family of circuits $\\{C_n\\}$ places the language in P/poly.\n\nD. The language is not necessarily in P/poly because to handle an aribtrary string $s_n$, the circuit $C_n$ would need to contain information about all $2^n$ possible threshold strings, which would require an exponential number of gates.", "solution": "To determine why the language $L$ is in P/poly, we must analyze the definition of P/poly and see how it applies to the given language $L$. The core of the P/poly class is its \"non-uniformity,\" which means we are allowed to use a different circuit $C_n$ for each input length $n$. This circuit $C_n$ only needs to work for inputs of length $n$ and can have information specific to the length $n$ \"built into\" its structure.\n\nLet's evaluate each option:\n\n**Option A:** This statement is incorrect. It describes a *uniform* model of computation, typical of the complexity class P. It presumes that a single Turing machine can obtain the string $s_{|x|}$ and then perform the comparison. However, the problem specifies that the sequence $\\{s_n\\}$ is arbitrary and may not be computable. If $\\{s_n\\}$ is an uncomputable sequence, no single Turing machine can generate $s_n$ for an arbitrary $n$. Therefore, this justification only works if $\\{s_n\\}$ is a P-computable sequence, which is not guaranteed.\n\n**Option B:** This statement is incorrect. It makes a false claim about the capabilities of P/poly. The non-uniform nature of P/poly allows it to contain uncomputable languages. For each length $n$, the circuit $C_n$ is supplied with \"advice\" in the form of its own structure. This advice can be an uncomputable sequence of bits. For example, the uncomputable language consisting of all strings $1^n$ such that the $n$-th Turing machine halts can be decided by a circuit family where the circuit $C_n$ is simply a wire to '1' or '0', depending on the pre-computed (but uncomputable) answer for $n$. Thus, the potential uncomputability of $\\{s_n\\}$ is not an obstacle for the language $L$ to be in P/poly.\n\n**Option D:** This statement is incorrect. It misunderstands how the circuit family works. For any given $n$, the language $L_n$ is defined by *one specific string* $s_n$. The circuit $C_n$ does not need to handle all possible choices of $s_n$; it only needs to work for the single, fixed $s_n$ that is part of the language's definition. Therefore, the circuit does not need to encode information about all $2^n$ possibilities, only about one.\n\n**Option C:** This statement is correct. It precisely captures the principle of non-uniformity. For each input size $n$, the string $s_n$ is fixed. We can design a circuit $C_n$ that has this specific string $s_n$ \"hardwired\" into its gates. The circuit takes an $n$-bit input $x$ and compares it to the hardwired $s_n$. A standard lexicographical comparison circuit for two $n$-bit strings can be built with a number of gates proportional to $n$ (i.e., size $O(n)$). This can be done by comparing the bits of $x$ and $s_n$ one by one, from most significant to least significant, and using logic gates to determine if $x$ is the first string to have a '0' where the other has a '1'. Since the size of this circuit is $O(n)$, it is bounded by a polynomial in $n$ (e.g., $p(n) = c \\cdot n$ for some constant $c$). Since we can construct such a polynomial-size circuit $C_n$ for each $n$, the language $L = \\bigcup_n L_n$ meets the definition of being in P/poly. The sequence of strings $\\{s_n\\}$ acts as the \"advice\" that is incorporated into the design of the circuit family $\\{C_n\\}$.", "answer": "$$\\boxed{C}$$", "id": "1454160"}, {"introduction": "We conclude with one of the most profound and surprising features of P/poly: its ability to contain undecidable languages. This exercise challenges you to analyze a language constructed by blending a simple, decidable problem (palindromes) with a provably undecidable one based on the Halting Problem. By determining how to classify this hybrid language, you will gain a deep appreciation for the power of non-uniform advice and see firsthand why P/poly includes problems that no standard algorithm can solve. [@problem_id:1454149]", "problem": "Let $\\Sigma = \\{0,1\\}$ be the alphabet. We will define a new language by combining a well-known language from the complexity class P with an undecidable language.\n\nFirst, let $L_P$ be the language of all palindromes over $\\Sigma$. A string $w$ is a palindrome if it reads the same forwards and backwards. Formally, $L_P = \\{ w \\in \\Sigma^* \\mid w = w^R \\}$, where $w^R$ is the reverse of $w$. It is known that $L_P \\in P$.\n\nSecond, let's define an undecidable tally language. A tally language is a subset of $\\{1\\}^*$. Let $M_i$ denote the Turing Machine corresponding to the integer $i$ under a standard, fixed enumeration of all valid Turing Machine encodings. Define the tally language $L_T$ as:\n$$L_T = \\{1^i \\mid \\text{the Turing Machine } M_i \\text{ halts on the empty string } \\epsilon \\}$$\nYou may assume the known result from computability theory that $L_T$ is an undecidable language.\n\nUsing these two languages, we construct a new language, $L_{new}$, over the alphabet $\\Sigma$. The membership of a string $x \\in \\Sigma^*$ in $L_{new}$ depends on its length, $|x|$, as follows:\n- If $|x|$ is odd, then $x \\in L_{new}$ if and only if $x$ is a palindrome (i.e., $x \\in L_P$).\n- If $|x|$ is even, then $x \\in L_{new}$ if and only if the tally string of that length is in $L_T$ (i.e., $1^{|x|} \\in L_T$).\n\nTo which of the following complexity classes does the language $L_{new}$ belong?\n\nA. $P$ (Polynomial time)\n\nB. $NP$ (Nondeterministic Polynomial time)\n\nC. $P/poly$ (Polynomial time with polynomial-size advice)\n\nD. $R$ (The class of all decidable languages)\n\nE. None of the above; the language is undecidable.", "solution": "The problem asks us to classify the language $L_{new}$ into one of the given complexity classes. The language $L_{new}$ is defined as:\n$L_{new} = \\{ x \\in \\{0,1\\}^* \\mid (|x| \\text{ is odd and } x \\in L_P) \\lor (|x| \\text{ is even and } 1^{|x|} \\in L_T) \\}$.\n\nLet's analyze the options.\n\nFirst, we must determine if $L_{new}$ is a decidable language (i.e., in class $R$). A language is decidable if there is a Turing Machine that halts on all inputs and correctly determines membership. Assume, for the sake of contradiction, that $L_{new}$ is decidable by some machine $M_{new}$. We could then use $M_{new}$ to solve an undecidable problem.\n\nConsider an input string $x$ where its length $|x| = i$ is an even number. According to the definition of $L_{new}$, $x \\in L_{new}$ if and only if $1^i \\in L_T$. This means our hypothetical decider $M_{new}$, when given any input string of an even length $i$, effectively decides whether the $i$-th Turing Machine halts on an empty input. This allows us to decide the language $L_{T, \\text{even}} = \\{1^i \\mid i \\text{ is even and } 1^i \\in L_T \\}$.\n\nHowever, the language $L_{T, \\text{even}}$ is itself undecidable. We can prove this by reducing the general Halting Problem (language $L_T$) to it. For any Turing Machine $M_k$, we can construct a new machine $M_i$ that has an even index $i$ and performs the exact same computation as $M_k$. (This is always possible, for instance by padding the description of $M_k$ to get an even index). Then, $M_k$ halts if and only if $M_i$ halts. A decider for $L_{T, \\text{even}}$ could therefore decide if $M_i$ halts, which in turn would decide if $M_k$ halts. Since this would work for any $k$, it would imply that $L_T$ is decidable, which is a known contradiction.\n\nTherefore, our initial assumption that $L_{new}$ is decidable must be false. $L_{new}$ is an undecidable language. This eliminates options A ($P$), B ($NP$), and D ($R$), because all of these classes contain only decidable languages.\n\nWe are left with option C ($P/poly$) and option E (undecidable). Note that \"undecidable\" in this context usually refers to Turing-decidability (uniform computation). The class $P/poly$ is a non-uniform complexity class, and it is known to contain undecidable languages. Let's check if $L_{new}$ fits the definition of $P/poly$.\n\nA language $L$ is in $P/poly$ if there exists a polynomial-time algorithm $A$ and a sequence of advice strings $\\{a_n\\}_{n \\in \\mathbb{N}}$ such that for every length $n$, the size of the advice $|a_n|$ is bounded by a polynomial in $n$, and for any input $x$ of length $n$, $A(x, a_n)$ correctly decides if $x \\in L$. The advice string $a_n$ depends only on the length of the input, $n$, not the input $x$ itself.\n\nLet's construct the algorithm and advice for $L_{new}$.\n\nDefine the advice sequence $\\{a_n\\}$ as follows:\nFor each natural number $n \\ge 0$, the advice $a_n$ will be a single bit.\n$$a_n = \\begin{cases} 1 & \\text{if } 1^n \\in L_T \\\\ 0 & \\text{if } 1^n \\notin L_T \\end{cases}$$\nThis advice sequence is well-defined mathematically, even though it is not computable (because $L_T$ is undecidable). The definition of $P/poly$ does not require the advice to be computable. The size of the advice is $|a_n| = 1$ for all $n$. This is bounded by a polynomial, for example $p(n)=1$.\n\nNow, we define the polynomial-time algorithm $A(x, a_{|x|})$. Let $n = |x|$ be the length of the input string $x$.\n1. Check if $n$ is odd or even.\n2. If $n$ is odd:\n   The algorithm ignores the advice $a_n$. It checks if $x$ is a palindrome. This can be done by comparing the first character with the last, the second with the second-to-last, and so on. This takes $O(n)$ time. If $x$ is a palindrome, the algorithm accepts. Otherwise, it rejects. This correctly decides membership for odd-length strings as per the definition of $L_{new}$.\n3. If $n$ is even:\n   The algorithm ignores the input string $x$ itself and only considers the advice bit $a_n$. If $a_n = 1$, the algorithm accepts. If $a_n = 0$, the algorithm rejects. By our definition of the advice, $a_n=1$ if and only if $1^n \\in L_T$. So, the algorithm correctly decides membership for even-length strings.\n\nThe total running time of algorithm $A$ is dominated by the palindrome check, which is $O(n)$. This is a polynomial-time algorithm.\n\nSince we have constructed a polynomial-time algorithm and a polynomial-size advice sequence that correctly decide $L_{new}$, we have shown that $L_{new} \\in P/poly$.\n\nTherefore, the correct classification is $P/poly$. Option E is incorrect because the language fits perfectly into the definition of a more specific (though non-uniform) class provided in the options.", "answer": "$$\\boxed{C}$$", "id": "1454149"}]}