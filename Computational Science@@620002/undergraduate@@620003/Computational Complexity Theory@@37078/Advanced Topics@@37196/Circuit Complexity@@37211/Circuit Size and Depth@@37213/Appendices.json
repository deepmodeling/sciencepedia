{"hands_on_practices": [{"introduction": "We begin our hands-on exploration by examining one of the most fundamental questions in circuit design: how does the number of inputs affect the minimum time required for a computation? This exercise uses the simple but crucial $n$-input AND function as a case study. By constructing a circuit with limited, 2-input gates, you will discover a logarithmic relationship between the number of inputs and the circuit's depth, a principle that forms the bedrock of understanding computational delay in parallel systems [@problem_id:1415173].", "problem": "In the study of computational complexity, a Boolean circuit is a formal model of a digital logic circuit. It is represented as a directed acyclic graph where nodes are either input nodes, which have no incoming edges, or gate nodes. The depth of a circuit is the length of the longest path from any input node to the single output node.\n\nConsider a family of Boolean functions, $\\{A_n\\}_{n \\ge 2}$, where each function $A_n: \\{0,1\\}^n \\to \\{0,1\\}$ takes $n$ binary inputs, denoted $x_1, x_2, \\ldots, x_n$. The function $A_n$ evaluates to 1 if and only if all of its inputs are 1; otherwise, it evaluates to 0.\n\nWe wish to construct a circuit family $\\{C_n\\}_{n \\ge 2}$ to compute $\\{A_n\\}$, using only 2-input AND gates. What is the minimum possible depth for such a circuit family as a function of $n$? Express your answer as a single closed-form analytic expression in terms of $n$.", "solution": "We want the minimum depth of any circuit over 2-input AND gates that computes the $n$-ary AND $A_{n}(x_{1},\\dots,x_{n}) = x_{1} \\wedge \\cdots \\wedge x_{n}$. Let the depth be $d$.\n\nLower bound: In any circuit whose gates have fan-in at most $2$, the number of distinct inputs that can influence a single gate at depth $k$ is at most $2^{k}$. This is proved by induction on $k$: for $k=0$, an output at depth $0$ is an input wire, so depends on at most $1=2^{0}$ input. If every signal at depth at most $k-1$ depends on at most $2^{k-1}$ inputs, then a gate at depth $k$ has two inputs, each depending on at most $2^{k-1}$ inputs; hence its output depends on at most $2 \\cdot 2^{k-1} = 2^{k}$ inputs. Therefore, the final output at depth $d$ can depend on at most $2^{d}$ inputs. Since $A_{n}$ depends on all $n$ inputs, we must have\n$$\n2^{d} \\geq n \\quad \\Rightarrow \\quad d \\geq \\log_{2}(n).\n$$\nBecause $d$ is an integer depth, this yields the lower bound\n$$\nd \\geq \\lceil \\log_{2}(n) \\rceil.\n$$\n\nUpper bound: Construct a balanced binary tree of 2-input AND gates. At level $1$, AND disjoint pairs of the $n$ inputs, producing $\\lceil n/2 \\rceil$ outputs; at level $2$, AND disjoint pairs of these, producing $\\lceil \\lceil n/2 \\rceil / 2 \\rceil$ outputs, and so on. After $k$ levels, the number of remaining signals is at most\n$$\n\\left\\lceil \\frac{n}{2^{k}} \\right\\rceil.\n$$\nWe stop when this equals $1$, i.e.,\n$$\n\\left\\lceil \\frac{n}{2^{k}} \\right\\rceil = 1 \\quad \\Longleftrightarrow \\quad \\frac{n}{2^{k}} \\leq 1 \\quad \\Longleftrightarrow \\quad 2^{k} \\geq n.\n$$\nThe minimal integer $k$ satisfying this is $k = \\lceil \\log_{2}(n) \\rceil$, which is exactly the achieved depth of the balanced construction. All gates are 2-input AND gates, and wires do not increase depth.\n\nCombining the lower and upper bounds, the minimum possible depth equals $\\lceil \\log_{2}(n) \\rceil$.", "answer": "$$\\boxed{\\lceil \\log_{2}(n) \\rceil}$$", "id": "1415173"}, {"introduction": "Moving from theory to application, we now tackle a problem straight from the world of digital logic design. Arithmetic circuits are the heart of any computer, and their efficiency is paramount. This practice challenges you to upgrade a simple 2-bit adder into a more versatile adder/subtractor, paying close attention to the trade-offs [@problem_id:1415212]. You will learn how a change in functionality impacts the core complexity metrics of size (the number of gates) and depth (the critical path delay), providing a tangible sense of how design choices translate to real-world performance.", "problem": "In the design of a simplified Arithmetic Logic Unit (ALU), circuits are built from fundamental logic gates. For this problem, we consider 2-input AND, 2-input OR, 2-input XOR, and 1-input NOT gates as the basic building blocks. The complexity of a circuit is measured by two metrics: its `size`, which is the total count of fundamental gates, and its `depth`, which is the longest path of sequential gates from any input to any output. Assume every fundamental gate has a size of 1 and a depth of 1.\n\nA Full Adder (FA) is a core component that adds three input bits ($A, B, C_{in}$) to produce a sum bit ($S$) and a carry-out bit ($C_{out}$). We will use a standard and efficient FA circuit defined by the Boolean expressions:\n$$S = (A \\oplus B) \\oplus C_{in}$$\n$$C_{out} = (A \\land B) \\lor ((A \\oplus B) \\land C_{in})$$\nNote that the term $(A \\oplus B)$ can be computed once and shared for both outputs.\n\nInitially, a 2-bit adder circuit is designed to compute the sum of two 2-bit numbers, $X = x_1x_0$ and $Y = y_1y_0$. This adder is implemented with a ripple-carry architecture as follows:\n1.  The first stage adds the least significant bits, $x_0$ and $y_0$. As the initial carry-in for this operation is fixed at 0, this stage is an optimized Half Adder, which computes $s_0 = x_0 \\oplus y_0$ and the first carry bit $c_1 = x_0 \\land y_0$.\n2.  The second stage uses a complete Full Adder, as defined above, to add the most significant bits, $x_1$ and $y_1$, along with the carry-in bit $c_1$ from the first stage.\n\nThe complete set of outputs for this 2-bit adder circuit consists of the sum bits $s_1$ and $s_0$, and the final carry-out bit $c_2$.\n\nYour task is to upgrade this initial 2-bit adder into a versatile 2-bit adder/subtractor. This new circuit will accept an additional control input, `SUB`.\n-   If `SUB` = 0, the circuit must compute the sum $X+Y$.\n-   If `SUB` = 1, the circuit must compute the difference $X-Y$ using two's complement representation, which is calculated as $X + (\\text{NOT } Y) + 1$.\n\nDetermine the minimal increase in `size` and `depth` required to transform the original adder into this new adder/subtractor. The inputs to the modified circuit are $x_1, x_0, y_1, y_0, \\text{and } \\text{SUB}$, and its outputs remain the two result bits and the final carry-out. Your answer should be the ordered pair (increase in size, increase in depth).", "solution": "We first summarize the original 2-bit ripple-carry adder and quantify its size and depth under the given gate model.\n\nOriginal adder:\n- Stage 1 (LSB): Half Adder on inputs $x_{0}, y_{0}$:\n  - $s_{0} = x_{0} \\oplus y_{0}$ (one XOR gate),\n  - $c_{1} = x_{0} \\land y_{0}$ (one AND gate).\n  - Size contribution: $2$ gates. Depth to $s_{0}$ and $c_{1}$: $1$.\n- Stage 2 (MSB): Full Adder on $(x_{1}, y_{1}, c_{1})$ using the shared-XOR implementation:\n  - Let $t_{1} = x_{1} \\oplus y_{1}$ (one XOR),\n  - $s_{1} = t_{1} \\oplus c_{1}$ (one XOR),\n  - $a_{1} = x_{1} \\land y_{1}$ (one AND),\n  - $a_{2} = t_{1} \\land c_{1}$ (one AND),\n  - $c_{2} = a_{1} \\lor a_{2}$ (one OR).\n  - Size contribution: $5$ gates. The longest path to $c_{2}$ is from $x_{0}$ (or $y_{0}$): $x_{0} \\to c_{1}$ (AND, depth $1$) $\\to a_{2}$ (AND, $+1$) $\\to c_{2}$ (OR, $+1$), hence overall depth $3$. Therefore, original size $=2+5=7$ and original depth $=3$.\n\nUpgrade to adder/subtractor:\nWe implement twoâ€™s complement subtraction by\n- bitwise conditioning $y_{i}' = y_{i} \\oplus \\mathrm{SUB}$ for $i \\in \\{0,1\\}$, and\n- using the initial carry-in $c_{0} = \\mathrm{SUB}$.\nThis realizes $X + (Y \\oplus \\mathrm{SUB}) + \\mathrm{SUB}$, which equals $X+Y$ if $\\mathrm{SUB}=0$ and $X-Y$ if $\\mathrm{SUB}=1$.\n\nGate implementation and sharing for minimal size:\n- LSB:\n  - The sum $s_{0}$ remains $s_{0} = x_{0} \\oplus y_{0}$, independent of $\\mathrm{SUB}$, so we reuse the original XOR gate for $s_{0}$ without change.\n  - The carry $c_{1}$ must be the FA carry for $(x_{0}, y_{0}', \\mathrm{SUB})$:\n    $$c_{1} = (x_{0} \\land y_{0}') \\lor \\big((x_{0} \\oplus y_{0}') \\land \\mathrm{SUB}\\big).$$\n    Implement this minimally by:\n    - computing $y_{0}' = y_{0} \\oplus \\mathrm{SUB}$ (one XOR),\n    - reusing the original AND gate as $a_{0} = x_{0} \\land y_{0}'$ (rewire its second input from $y_{0}$ to $y_{0}'$),\n    - computing $t_{0} = x_{0} \\oplus y_{0}'$ (one XOR),\n    - computing $a_{2}^{(0)} = t_{0} \\land \\mathrm{SUB}$ (one AND),\n    - outputting $c_{1} = a_{0} \\lor a_{2}^{(0)}$ (one OR).\n    Net additional gates at LSB: $1$ XOR ($y_{0}'$) $+$ $1$ XOR ($t_{0}$) $+$ $1$ AND ($a_{2}^{(0)}$) $+$ $1$ OR $=4$ new gates. The original $s_{0}$ XOR and the original AND are reused.\n- MSB:\n  - Precompute $y_{1}' = y_{1} \\oplus \\mathrm{SUB}$ (one XOR).\n  - Feed $(x_{1}, y_{1}', c_{1})$ into the same $5$-gate FA structure as before (reuse the same gate count; only inputs are rewired). Net additional gates at MSB: $1$ XOR.\n\nTherefore, the minimal size increase is\n$$\\Delta\\text{size} = 4\\ \\text{(LSB)} + 1\\ \\text{(MSB)} = 5.$$\n\nDepth analysis after the upgrade:\n- LSB:\n  - $s_{0}$ remains depth $1$.\n  - For $c_{1}$, along the longest path from $y_{0}$:\n    $y_{0} \\to y_{0}'$ (XOR, $1$) $\\to t_{0}$ (XOR, $+1$) $\\to a_{2}^{(0)}$ (AND, $+1$) $\\to c_{1}$ (OR, $+1$), total $4$.\n- MSB:\n  - Compute $y_{1}'$ (XOR, depth $1$) and then $t_{1}' = x_{1} \\oplus y_{1}'$ (XOR, depth $2$ from $y_{1}$).\n  - Sum output $s_{1} = t_{1}' \\oplus c_{1}$: from $y_{0}$ the path is $4$ (to $c_{1}$) $+1$ (final XOR) $=5$; from $y_{1}$ it is $2+1=3$. Hence $s_{1}$ depth is $5$.\n  - Carry $c_{2} = (x_{1} \\land y_{1}') \\lor \\big(t_{1}' \\land c_{1}\\big)$. The longest path is from $y_{0}$:\n    $y_{0} \\to c_{1}$ (depth $4$) $\\to$ AND with $t_{1}'$ (depth $+1$) $\\to$ final OR (depth $+1$), totaling $6$.\nThus the upgraded circuit has depth $6$. The original depth was $3$, so\n$$\\Delta\\text{depth} = 6 - 3 = 3.$$\n\nMinimality argument:\n- Size: Converting the LSB from a Half Adder (2 gates) to accept a variable carry-in necessarily requires Full Adder functionality (5 gates) relative to its two-input operands. With the requirement to condition $y_{0}$ by $\\mathrm{SUB}$, one extra XOR for $y_{0}'$ is unavoidable, yielding at least $+4$ gates at LSB. At MSB, conditioning $y_{1}$ by $\\mathrm{SUB}$ requires one XOR, adding $+1$. No further reduction is possible without violating the allowed gate types or losing sharing of the $A \\oplus B$ term within each FA.\n- Depth: Any correct $c_{1}$ must depend on $y_{0}$ and $\\mathrm{SUB}$, requiring at least one gate to mix $y_{0}$ with $\\mathrm{SUB}$ (e.g., XOR) and at least one more gate to combine with $x_{0}$ and/or $\\mathrm{SUB}$ to produce a proper FA carry. This forces the $y_{0}\\!\\to\\!c_{1}$ path to have depth at least $3$ or $4$ depending on structuring; with only $2$-input ORs, the optimal constructions attain depth $4$ from $y_{0}$ to $c_{1}$. The MSB stage then necessarily adds one XOR to form $s_{1}$ and two gates (AND then OR) to form $c_{2}$, making the longest input-to-output path reach depth $6$. Hence an increase of $3$ levels is unavoidable under the given gate constraints.\n\nTherefore, the minimal increases are\n- size increase: $5$,\n- depth increase: $3$.", "answer": "$$\\boxed{\\begin{pmatrix}5 & 3\\end{pmatrix}}$$", "id": "1415212"}, {"introduction": "Let's conclude by challenging a core assumption we've made so far: that gates have a small, fixed number of inputs. In this exercise, we explore the power of circuits with 'unbounded fan-in' AND and OR gates, which can process any number of inputs simultaneously. By designing a circuit to solve the 'exactly one' problem [@problem_id:1415168], you will see how this alternative model can solve complex problems in constant depth, offering a powerful lesson in how the computational model itself defines the boundaries of what is efficiently possible.", "problem": "In the design of a specialized arbiter for a multi-core processor, a crucial sub-component must check for a unique grant request. The system has $n$ parallel request lines, represented by the Boolean input variables $x_1, x_2, \\dots, x_n$. The arbiter circuit must output a signal that is 1 if and only if exactly one of the input lines is 1, and 0 otherwise.\n\nYou are to determine the minimum computational depth required to implement this function using a specific model of a logic circuit. The available components are single-input NOT gates, and unbounded fan-in AND and OR gates (meaning they can accept any number of inputs).\n\nThe depth of the circuit is defined in terms of layers:\n- The input variables $x_1, \\dots, x_n$ are considered to be at Layer 0.\n- A gate is at Layer $k$ (for $k \\ge 1$) if all of its inputs are connected to the outputs of gates from layers $j < k$, and at least one of its inputs is connected to the output of a gate from Layer $k-1$.\n- The depth of the entire circuit is the layer number of the final output gate.\n\nAssuming $n \\ge 2$, what is the minimum possible constant depth for a circuit that correctly implements the \"exactly one\" function?\n\nA. 1\n\nB. 2\n\nC. 3\n\nD. 4\n\nE. The depth is not constant and must depend on $n$.", "solution": "Let the function be $\\operatorname{EXACT1}(x_{1},\\dots,x_{n})$, which equals $1$ if and only if exactly one of $x_{1},\\dots,x_{n}$ is $1$, i.e., $\\sum_{i=1}^{n} x_{i}=1$.\n\nUpper bound (depth $\\le 3$): Construct a circuit of depth $3$ using NOT, unbounded fan-in AND, and OR as follows.\n- Layer $1$: For each $i \\in \\{1,\\dots,n\\}$, compute $\\bar{x}_{i}$ using a NOT gate.\n- Layer $2$: For each $i$, compute\n$$\ng_{i} \\;=\\; x_{i} \\land \\bigwedge_{j \\ne i} \\bar{x}_{j}.\n$$\nEach such AND gate takes inputs from Layer $0$ and Layer $1$, hence is at Layer $2$ by the given rule.\n- Layer $3$: Output\n$$\ny \\;=\\; \\bigvee_{i=1}^{n} g_{i}.\n$$\nThis OR takes inputs from Layer $2$; thus it is at Layer $3$.\n\nCorrectness: For any input, $g_{i}=1$ if and only if $x_{i}=1$ and all $x_{j}=0$ for $j \\ne i$. Hence $y=1$ if and only if exactly one input is $1$. Therefore $\\operatorname{EXACT1}$ is computable with depth $3$.\n\nLower bound (depth $<3$ is impossible):\n\n1) Depth $1$ is impossible. A single gate at Layer $1$ can only be one of:\n- A NOT of a single input $x_{i}$, which is $1$ on all assignments with $x_{i}=0$ and thus does not equal $\\operatorname{EXACT1}$.\n- An OR of a nonempty subset of inputs, which is $1$ on any assignment with at least one $1$, not just exactly one.\n- An AND of a nonempty subset of inputs, which is $1$ only when all inputs in that subset are $1$, never on exactly-one assignments unless the subset is a singleton, in which case it accepts all assignments where that single variable is $1$, including those with multiple ones.\nNone equals $\\operatorname{EXACT1}$.\n\n2) Depth $2$ is impossible. Consider the output gate at Layer $2$ and analyze both possibilities.\n\nCase A: The output gate is an OR. Every input to this OR must be the output of a Layer $1$ gate. A Layer $1$ gate can only be one of:\n- $\\bar{x}_{i}$ (NOT of a single variable),\n- $\\bigvee_{i \\in S} x_{i}$ for some nonempty $S \\subseteq \\{1,\\dots,n\\}$,\n- $\\bigwedge_{i \\in T} x_{i}$ for some nonempty $T \\subseteq \\{1,\\dots,n\\}$.\nTo avoid false positives on assignments with at least two $1$s, every such leaf must be $0$ on all multi-one assignments. This is impossible:\n- For $\\bar{x}_{i}$, choose any multi-one assignment with $x_{i}=0$; then $\\bar{x}_{i}=1$.\n- For $\\bigvee_{i \\in S} x_{i}$ with $S \\ne \\varnothing$, choose a multi-one assignment having a $1$ in $S$; then the OR leaf is $1$.\n- For $\\bigwedge_{i \\in T} x_{i}$ with $|T| \\ge 2$, the assignment with ones exactly on $T$ makes the leaf $1$. For $|T|=1$, say $T=\\{k\\}$, any multi-one assignment with $x_{k}=1$ also makes the leaf $1$.\nThus any such leaf outputs $1$ on some multi-one assignment, and the top OR would output $1$ there, contradicting correctness.\n\nCase B: The output gate is an AND. For the output to be $1$ on every one-hot assignment, every input leaf at Layer $1$ must be $1$ on all one-hot assignments. This forces:\n- No leaf can be $\\bar{x}_{i}$, since it is $0$ on the one-hot assignment where $x_{i}=1$.\n- No leaf can be $\\bigwedge_{i \\in T} x_{i}$ with $T \\ne \\varnothing$, since any one-hot assignment has at most one $1$ and would fail unless $T$ is a singleton $\\{k\\}$ with the hot index equal to $k$. But to be $1$ on all one-hot assignments, even singletons are disallowed.\n- A leaf $\\bigvee_{i \\in S} x_{i}$ is $1$ on a one-hot assignment with hot index $k$ if and only if $k \\in S$. To be $1$ for all one-hot assignments, $S$ must equal $\\{1,\\dots,n\\}$, i.e., the global OR. Any conjunction of such OR leaves is still $1$ on any assignment with at least one $1$, including those with two or more $1$s, so the top AND cannot reject multi-one assignments.\nTherefore depth $2$ is impossible.\n\nCombining the upper and lower bounds, the minimum possible constant depth is $3$ for all $n \\ge 2$. Hence the correct choice is C.", "answer": "$$\\boxed{C}$$", "id": "1415168"}]}