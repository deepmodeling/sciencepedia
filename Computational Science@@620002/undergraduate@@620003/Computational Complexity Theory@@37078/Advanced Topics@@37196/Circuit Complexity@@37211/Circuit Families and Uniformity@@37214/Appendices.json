{"hands_on_practices": [{"introduction": "The power of non-uniform circuit families, which define the class $P/poly$, lies in their ability to embed specific 'advice' for each input size directly into the hardware. This exercise makes this abstract concept tangible by challenging you to design the most efficient circuit possible for recognizing a single, specific access code. By determining the minimal number of gates needed, you'll gain a fundamental understanding of how information can be hardwired into a circuit's structure [@problem_id:1414500].", "problem": "A security system uses a special set of binary strings called 'access codes'. For any given positive integer length $n$, there exists exactly one valid access code of that length. A hardware verifier for a given length $n$ is implemented as a Boolean circuit, denoted $C_n$. This circuit takes an $n$-bit string as input and outputs 1 if the string is the valid access code of length $n$, and 0 otherwise.\n\nThese circuits are constructed using only the following standard gates: 2-input AND gates, 2-input OR gates, and 1-input NOT gates. The 'size' of a circuit is defined as the total number of gates it contains.\n\nFor the specific length $n=12$, the valid access code is given by the string $s = 110100101110$.\n\nCalculate the minimum possible size for the circuit $C_{12}$ that correctly identifies this access code.", "solution": "Let the input be $x=(x_{1},\\ldots,x_{12})$ and the unique accepting string be $s=110100101110$. The function to compute is the single minterm\n$$\nf(x)=\\bigwedge_{i=1}^{12} \\ell_{i}, \\quad \\text{where } \\ell_{i}=\\begin{cases}\nx_{i} & \\text{if } s_{i}=1,\\\\\n\\neg x_{i} & \\text{if } s_{i}=0.\n\\end{cases}\n$$\nA direct implementation uses a binary AND-tree over the $12$ literals and one NOT per variable where $s_{i}=0$. Since a $k$-input AND using only $2$-input AND gates needs at least $k-1$ gates, the conjunction requires $12-1=11$ AND gates. The string $s$ has zeros at positions $3,5,6,8,12$, hence exactly $5$ negated literals, so exactly $5$ NOT gates are needed. This gives a circuit of size $11+5=16$.\n\nTo see optimality:\n- Any circuit that outputs $1$ only when $x=s$ must enforce all $12$ literal constraints; combining $12$ independent inputs to one output with only $2$-input gates needs at least $11$ binary gates (each such gate can reduce the number of separate components by at most one).\n- For each index $i$ with $s_{i}=0$, the function is decreasing in $x_{i}$, so some occurrence of $\\neg x_{i}$ must appear on a path to the output; otherwise the circuit would be monotone in $x_{i}$ and could not distinguish $x_{i}=0$ from $x_{i}=1$ at the unique accepting assignment. Each such variable needs at least one NOT gate, and a single NOT can invert only one signal, so at least $5$ NOT gates are necessary.\n\nThus any implementation has size at least $11+5=16$, and the construction above achieves this bound. No use of OR gates can reduce this count, since the minimal representation already uses the minimal number of binary gates and negations for this unate minterm.\n\nTherefore, the minimum possible size is $16$.", "answer": "$$\\boxed{16}$$", "id": "1414500"}, {"introduction": "After learning to construct individual circuits, a key question in complexity theory is how different computational problems relate to each other. This practice explores a fundamental closure property by asking you to combine two existing circuits to solve a new problem involving their intersection. This exercise not only demonstrates that the class $P/poly$ is closed under intersection but also provides hands-on practice in analyzing the size of composite circuits built from modular components [@problem_id:1414484].", "problem": "In computational complexity theory, a language $L$ is a member of the complexity class P/poly (Polynomial-size circuits) if it can be decided by a family of Boolean circuits of polynomial size. This means there exists a polynomial $p(n)$ and a sequence of circuits $\\{C_n\\}_{n \\in \\mathbb{N}}$, where for each integer $n \\ge 0$, $C_n$ is a circuit with $n$ inputs and one output. For any binary string $x$ of length $n$, the circuit $C_n$ on input $x$ outputs a single bit, $C_n(x)$, such that $C_n(x)=1$ if and only if $x \\in L$. The size of a circuit is defined as the number of logic gates it contains, and the size of $C_n$ must be upper-bounded by the polynomial $p(n)$.\n\nConsider two languages, $L_A$ and $L_B$, which are used to classify scientific data models. Both languages are known to be in P/poly.\n- For an $n$-bit input string, the language $L_A$ is decided by a circuit, $C_{A,n}$, with a size of exactly $S_A(n) = n^3 + 6n^2 + 5n + 10$ gates.\n- For an $n$-bit input string, the language $L_B$ is decided by a circuit, $C_{B,n}$, with a size of exactly $S_B(n) = 2n^3 + 3n + 25$ gates.\n\nA data model is considered 'confirmed' only if its corresponding binary string belongs to both $L_A$ and $L_B$. This defines the language of confirmed models, $L_C = L_A \\cap L_B$. We want to build a circuit family $\\{C_{C,n}\\}$ to decide $L_C$. If we construct each circuit $C_{C,n}$ by using the existing circuits $C_{A,n}$ and $C_{B,n}$ as indivisible, black-box components, what is the total size of the resulting circuit $C_{C,n}$? Express your answer as a polynomial in $n$.", "solution": "The problem asks for the size of a circuit, $C_{C,n}$, that decides the language $L_C = L_A \\cap L_B$. We are given that this new circuit will be constructed using the circuits for $L_A$ and $L_B$, which are $C_{A,n}$ and $C_{B,n}$ respectively, as black-box components.\n\nThe language $L_C$ is the intersection of $L_A$ and $L_B$. By definition of intersection, a string $x$ of length $n$ is in $L_C$ if and only if $x$ is in $L_A$ and $x$ is in $L_B$.\n\nThe circuits $C_{A,n}$ and $C_{B,n}$ are deciders for their respective languages. This means:\n- $C_{A,n}(x) = 1$ if $x \\in L_A$, and $C_{A,n}(x) = 0$ otherwise.\n- $C_{B,n}(x) = 1$ if $x \\in L_B$, and $C_{B,n}(x) = 0$ otherwise.\n\nFor the circuit $C_{C,n}$ to decide $L_C$, it must output 1 if and only if $x \\in L_C$. Using the conditions above, this means $C_{C,n}(x)$ must be 1 if and only if both $C_{A,n}(x) = 1$ and $C_{B,n}(x) = 1$. This logical condition \"A AND B\" is implemented by a single AND gate.\n\nSo, we can construct the circuit $C_{C,n}$ as follows:\n1. The $n$ input bits of the string $x$ are fed simultaneously to the inputs of circuit $C_{A,n}$ and circuit $C_{B,n}$.\n2. The single-bit output of $C_{A,n}$ and the single-bit output of $C_{B,n}$ are then fed as the two inputs to a new AND gate.\n3. The output of this AND gate is the final output of the circuit $C_{C,n}$.\n\nThe total size of this composite circuit, $S_C(n)$, is the sum of the sizes of its components. Since we use $C_{A,n}$ and $C_{B,n}$ as black-box components, we sum their sizes and add the number of new gates. In this construction, we added exactly one AND gate.\n\nThe size of $C_{A,n}$ is given by $S_A(n) = n^3 + 6n^2 + 5n + 10$.\nThe size of $C_{B,n}$ is given by $S_B(n) = 2n^3 + 3n + 25$.\nThe number of additional gates is 1.\n\nTherefore, the total size of $C_{C,n}$ is:\n$S_C(n) = S_A(n) + S_B(n) + 1$\n$S_C(n) = (n^3 + 6n^2 + 5n + 10) + (2n^3 + 3n + 25) + 1$\n\nNow, we combine the terms of the polynomials:\n$S_C(n) = (1+2)n^3 + (6)n^2 + (5+3)n + (10+25+1)$\n$S_C(n) = 3n^3 + 6n^2 + 8n + 36$\n\nThis polynomial represents the exact size of the resulting circuit $C_{C,n}$ built by this construction method.", "answer": "$$\\boxed{3n^3 + 6n^2 + 8n + 36}$$", "id": "1414484"}, {"introduction": "The existence of a small circuit is one thing; being able to actually construct it efficiently is another. This final practice moves from the 'what' of non-uniform circuits to the 'how' of *uniform* circuit families, which are essential for practical computation. You will analyze the resource constraints—specifically, logarithmic space ($L$)—on an algorithm that generates a circuit family, learning to distinguish between the complexity of the circuit itself and the complexity of its construction [@problem_id:1414520].", "problem": "In computational complexity theory, a circuit family is a sequence of circuits $\\{C_n\\}_{n \\in \\mathbb{N}}$, where $C_n$ is a circuit designed for inputs of length $n$. A circuit family is said to be **log-space uniform** if a deterministic Turing machine, known as a log-space transducer, can generate a description of the circuit $C_n$ when given the input $1^n$ (a string of $n$ ones), using only a logarithmic amount of space on its work tape, i.e., $O(\\log n)$ space.\n\nThe description of a circuit is provided as a sequence of gates. The primary inputs to the circuit, $x_1, x_2, \\dots, x_n$, are assigned integer IDs from $1$ to $n$. Each subsequent gate in the circuit is described by a tuple, with gates being numbered sequentially starting from $n+1$. A `NOT` gate is described by `(gate_ID, NOT, input_ID)`, and a two-input gate is described by `(gate_ID, gate_type, input1_ID, input2_ID)`, where `gate_type` is either `AND` or `OR`. The `input_ID`s must refer to either one of the primary input IDs ($1, \\dots, n$) or the ID of a gate that has already been defined in the sequence. The final gate in the sequence is considered the circuit's single output gate.\n\nConsider the language $L_{=1}$, which contains all binary strings with exactly one '1'. We wish to design a log-space uniform family of circuits $\\{C_n\\}$ that decides $L_{=1}$.\n\nWhich of the following statements most accurately describes a key component or property of a log-space transducer that correctly generates the circuit description for $C_n$?\n\nA. To ensure all input variables are connected, the transducer must first load the entire input string $x_1x_2\\dots x_n$ onto its work tape, which takes $O(n)$ space.\n\nB. A sub-circuit to verify that there is at most one '1' in the input involves checking all pairs of inputs $(x_i, x_j)$. The transducer must therefore allocate work tape space proportional to $n^2$ to manage all $\\binom{n}{2}$ pairs.\n\nC. The circuit requires combining $\\Theta(n^2)$ intermediate signals. The transducer can achieve this by using counters, which require $O(\\log n)$ space, to systematically generate a regular, tree-like structure of gates connecting these signals.\n\nD. For a circuit family to be log-space uniform, the generated circuit $C_n$ must have a size that is logarithmic in $n$, i.e., of size $O(\\log n)$.\n\nE. The only way to build such a circuit is to construct a binary adder to sum the input bits. The transducer's log-space work tape must store the complete architectural plans for this adder for any given $n$.", "solution": "We must determine which statement correctly describes a key property or component of a log-space transducer that generates a circuit family $\\{C_{n}\\}$ deciding $L_{=1}$, the language of binary strings with exactly one '1'. A standard circuit construction for $L_{=1}$ is:\n1) Compute $S_{1}=\\bigvee_{i=1}^{n} x_{i}$ to ensure there is at least one '1'.\n2) Compute $S_{2}=\\bigvee_{1 \\leq i<j \\leq n} (x_{i} \\wedge x_{j})$ to detect whether there are at least two '1's.\n3) Output $S_{1} \\wedge \\lnot S_{2}$.\n\nThis construction uses $\\Theta(n)$ OR-gates for $S_{1}$ and $\\Theta(n^{2})$ pairwise AND-gates plus a combining OR-tree for $S_{2}$. Hence the circuit has size $\\Theta(n^{2})$, which is polynomial in $n$.\n\nLog-space uniformity requires a deterministic transducer that, on input $1^{n}$, outputs the gate list of $C_{n}$ using $O(\\log n)$ work space. Crucially, the transducer does not need to store the whole circuit; it can stream the description gate-by-gate while maintaining only counters and a small amount of state. In particular:\n- To enumerate all pairs $(i,j)$ with $1 \\leq i<j \\leq n$, the transducer uses two counters for $i$ and $j$, each requiring $O(\\log n)$ space, and a counter for the current gate ID, also $O(\\log n)$ space. This suffices to output all pairwise AND-gates sequentially.\n- To combine many intermediate signals (e.g., the $\\binom{n}{2}$ outputs of the pairwise AND-gates) into one via OR, the transducer can generate a balanced binary tree of OR-gates. The IDs of the leaves (the pairwise ANDs) form a contiguous block starting at $n+1$, with length $\\binom{n}{2}$; thus the transducer can compute the correct input IDs for each internal OR-gate using only $O(\\log n)$-bit counters and arithmetic. The same approach applies to the $\\Theta(n)$-ary OR for $S_{1}$.\n- The final combination $S_{1} \\wedge \\lnot S_{2}$ uses a single NOT and a final AND, again outputtable with the same counters.\n\nWe now evaluate the options:\nA. False. The transducer’s input is $1^{n}$; it does not need to load $x_{1}\\dots x_{n}$ (which are circuit variables) and certainly not using $O(n)$ space.\nB. False. Although there are $\\Theta(n^{2})$ pairs, the transducer can iterate through them with $O(\\log n)$-space counters; it does not need $O(n^{2})$ space.\nC. True. The circuit does combine $\\Theta(n^{2})$ intermediate signals, and a log-space transducer can use $O(\\log n)$-space counters to systematically generate a regular, tree-like structure connecting them.\nD. False. Log-space uniformity places a bound on the transducer’s space, not on circuit size; $C_{n}$ may be polynomial in $n$, not $O(\\log n)$.\nE. False. A binary adder is not the only method, and the transducer need not store a full blueprint; it can generate the circuit incrementally with $O(\\log n)$-space counters.\n\nTherefore, the correct choice is C.", "answer": "$$\\boxed{C}$$", "id": "1414520"}]}