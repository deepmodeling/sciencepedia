{"hands_on_practices": [{"introduction": "Understanding a new complexity class begins with a direct application of its definition. This first exercise provides a perfect entry point into $P/\\text{poly}$ by presenting a language whose membership rule depends on a specific property of the input's length—its primality. Your task is to determine how a small, pre-computed 'advice' string can enable a simple polynomial-time algorithm to solve this problem, illustrating the core concept of non-uniform computation. [@problem_id:1454162]", "problem": "In computational complexity theory, the class $P/\\text{poly}$ (non-uniform polynomial time) provides a model for computation that allows for a different piece of \"advice\" for each input length. A language $L \\subseteq \\{0,1\\}^*$ is in $P/\\text{poly}$ if there exists a polynomial $p(n)$ and a polynomial-time Turing machine $M$ such that for every natural number $n$, there is an advice string $a_n$ with length $|a_n| \\le p(n)$. For any input string $x$ of length $|x|=n$, the machine $M$ on input $(x, a_n)$ must correctly decide if $x$ is in $L$. Note that the advice string $a_n$ depends only on the length $n$ of the input, not the input string $x$ itself.\n\nConsider the language $L$ over the alphabet $\\Sigma = \\{0,1\\}$, defined as follows: A binary string $x$ is in $L$ if its first bit, $x_1$, is '1' when its length, $|x|$, is a prime number, and its first bit is '0' when its length is not a prime number. For the purposes of this problem, the numbers 0 and 1 are not considered prime.\n\nWhich of the following statements correctly evaluates whether the language $L$ belongs to the complexity class $P/\\text{poly}$?\n\nA. Yes, the language is in $P/\\text{poly}$. An advice string $a_n$ of length 1 can be used to inform a polynomial-time machine whether the input length $n$ is prime. The machine then compares the first bit of the input with the requirement indicated by the advice.\nB. No, the language is not in $P/\\text{poly}$. Although primality testing is known to be in $P$, a uniform polynomial-time algorithm must decide the language for all input lengths $n$ without special information for each $n$. The language's definition inherently violates this uniformity.\nC. No, the language is not in $P/\\text{poly}$. The advice string for an input of length $n$ would need to encode the primality of every number up to $n$, which requires a non-polynomial amount of information.\nD. No, the language is not in $P/\\text{poly}$. The advice string sequence itself is not required to be computable, but in this case, generating the advice requires primality testing for all integers, which is too computationally expensive to be allowed.", "solution": "We recall the definition: $L \\subseteq \\{0,1\\}^{*}$ is in $P/\\text{poly}$ if there exist a polynomial-time Turing machine $M$ and a family of advice strings $\\{a_{n}\\}_{n \\ge 0}$ with $|a_{n}| \\le p(n)$ for some polynomial $p$, such that for every input $x$ with $|x|=n$, $M(x,a_{n})$ decides membership in $L$ correctly.\n\nThe language $L$ is defined by the property: for $n=|x|$, if $n$ is prime then $x \\in L$ if and only if $x_{1}=1$, and if $n$ is not prime then $x \\in L$ if and only if $x_{1}=0$. For $n=0$, no string has a first bit, so no string of length $0$ satisfies the condition, and thus the empty string is not in $L$; this does not affect the construction below.\n\nConstruct advice and machine as follows.\n1. For each $n \\ge 0$, define the advice bit $a_{n} \\in \\{0,1\\}$ by\n$$\na_{n} =\n\\begin{cases}\n1 & \\text{if $n$ is prime},\\\\\n0 & \\text{if $n$ is not prime}.\n\\end{cases}\n$$\nThen $|a_{n}|=1$, so we may take $p(n)=1$.\n\n2. Define $M$ to run in time polynomial in $n=|x|$ and do:\n- Compute $n=|x|$ by scanning the input.\n- If $n=0$, reject (this matches $L$ as explained above).\n- Otherwise, read the first bit $x_{1}$. Accept if and only if $x_{1}=a_{n}$.\n\nThis $M$ runs in time $O(n)$ and uses only the single-bit advice $a_{n}$. For every $x$ of length $n \\ge 1$, $M$ accepts exactly those $x$ whose first bit equals $a_{n}$, which by construction is precisely the membership condition of $L$. Therefore $L \\in P/\\text{poly}$.\n\nMoreover, $L \\in P$ as well: a uniform polynomial-time machine can compute $n=|x|$, test primality of $n$ in time polynomial in $\\log n$ (after computing the binary representation of $n$ in time polynomial in $n$), and compare with $x_{1}$. Hence $L$ being in $P$ already implies $L \\in P/\\text{poly}$.\n\nEvaluating the options:\n- A is correct: a single-bit advice $a_{n}$ indicating primality of $n$ suffices, and $M$ compares $x_{1}$ with $a_{n}$ in polynomial time.\n- B is incorrect: there is no violation of uniformity in $P/\\text{poly}$, and in fact $L$ has a uniform polynomial-time decider, so the language is in $P$ and hence in $P/\\text{poly}$.\n- C is incorrect: the advice for length $n$ need only encode information about that length $n$ (one bit), not about all lengths up to $n$.\n- D is incorrect: $P/\\text{poly}$ does not require the advice sequence to be computable; furthermore, even if one insisted on computability, determining primality is in $P$, so generating $a_{n}$ is not prohibitively expensive.\n\nThus the correct choice is A.", "answer": "$$\\boxed{A}$$", "id": "1454162"}, {"introduction": "The power of $P/\\text{poly}$ comes from its 'non-uniformity,' meaning the advice string can be anything, even uncomputable. To truly appreciate this, it is helpful to consider the alternative: what if the advice *had* to be easily computable? This problem challenges you to analyze a variant of $P/\\text{poly}$ with this restriction, helping you forge a crucial link between non-uniform advice models and the fundamental complexity class $P$. [@problem_id:1411412]", "problem": "In computational complexity theory, we study the resources required to solve computational problems. A language is a set of strings over an alphabet, typically $\\{0, 1\\}$. A Turing Machine (TM) is a mathematical model of computation.\n\nThe complexity class $P$ is the set of all languages that can be decided by a deterministic TM running in time polynomial in the length of the input.\n\nA more powerful, \"non-uniform\" class is $P/\\text{poly}$. A language $L$ belongs to $P/\\text{poly}$ if there exists a polynomial-time TM $M$ and a sequence of \"advice strings\" $\\{a_n\\}_{n \\in \\mathbb{N}}$, where $|a_n|$ is bounded by a polynomial in $n$, such that for any input string $x$ of length $n$:\n$$x \\in L \\iff M(\\langle x, a_n \\rangle) \\text{ accepts}$$\nIn the standard definition of $P/\\text{poly}$, there is no restriction on how the advice sequence $\\{a_n\\}$ is generated; it can even be non-computable.\n\nConsider a variant of this class, which we will call $P_{\\text{COMP-ADV}}$, where the advice sequence must be generated in polynomial time. Specifically, a language $L$ is in $P_{\\text{COMP-ADV}}$ if there exist two polynomial-time deterministic TMs, a \"main\" machine $M$ and an \"advice generator\" $A$, such that for every natural number $n \\ge 0$, the following holds:\n1. The advice for inputs of length $n$ is $a_n = A(1^n)$, where $1^n$ is the string of $n$ ones.\n2. For any input string $x$ of length $n$, $x \\in L$ if and only if $M(\\langle x, a_n \\rangle)$ accepts.\n\nWhich of the following well-known complexity classes is equivalent to $P_{\\text{COMP-ADV}}$?\n\nA. $P$\nB. $L$, the class of languages decidable in logarithmic space.\nC. $P/\\text{poly}$\nD. $E = \\bigcup_{c>0} \\text{DTIME}(2^{cn})$\nE. $EXP = \\bigcup_{c>0} \\text{DTIME}(2^{n^c})$", "solution": "We compare $P_{\\text{COMP-ADV}}$ with $P$ by proving the two inclusions $P \\subseteq P_{\\text{COMP-ADV}}$ and $P_{\\text{COMP-ADV}} \\subseteq P$.\n\nFirst, $P \\subseteq P_{\\text{COMP-ADV}}$: Let $L \\in P$. Then there exists a deterministic TM $T$ and a polynomial $p$ such that on input $x$, $T$ decides whether $x \\in L$ in at most $p(|x|)$ steps. Define a polynomial-time advice generator $A$ by $A(1^{n}) = \\epsilon$ for all $n$, where $\\epsilon$ is the empty string, and define $M$ to simulate $T$ on $x$ while ignoring the advice. Then for every $x$, $x \\in L \\iff M(\\langle x, A(1^{|x|}) \\rangle)$ accepts. Since both $A$ and $M$ run in polynomial time, $L \\in P_{\\text{COMP-ADV}}$.\n\nSecond, $P_{\\text{COMP-ADV}} \\subseteq P$: Let $L \\in P_{\\text{COMP-ADV}}$. Then there exist deterministic TMs $A$ and $M$ and polynomials $p_{A}$ and $p_{M}$ such that:\n- For every $n \\ge 0$, $A(1^{n})$ halts within at most $p_{A}(n)$ steps and outputs $a_{n}$.\n- For every input pair $\\langle x, a \\rangle$, $M(\\langle x, a \\rangle)$ halts within at most $p_{M}(|\\langle x, a \\rangle|)$ steps and decides according to $x \\in L \\iff M(\\langle x, a_{|x|} \\rangle)$ accepts.\n\nBecause each output bit requires at least one computation step, the output length is bounded by the running time. Therefore, for all $n$,\n$$\n|a_{n}| \\le p_{A}(n).\n$$\nFor an input $x$ with $|x| = n$, consider the deterministic TM $T$ that on input $x$ computes $a_{n} := A(1^{n})$ and then runs $M(\\langle x, a_{n} \\rangle)$. The total running time of $T$ on inputs of length $n$ is at most\n$$\np_{A}(n) + p_{M}(|\\langle x, a_{n} \\rangle|).\n$$\nSince $|\\langle x, a_{n} \\rangle| \\le |x| + |a_{n}| + c \\le n + p_{A}(n) + c$ for some constant $c$, there exists a polynomial $q$ such that\n$$\np_{M}(|\\langle x, a_{n} \\rangle|) \\le q(n).\n$$\nHence the total time $p_{A}(n) + q(n)$ is polynomial in $n$, so $T$ decides $L$ in polynomial time. Therefore $L \\in P$.\n\nCombining both inclusions yields $P_{\\text{COMP-ADV}} = P$. Among the given options, this is option A.", "answer": "$$\\boxed{A}$$", "id": "1411412"}, {"introduction": "Complexity classes are often characterized by their 'closure properties'—whether combining languages from the class results in a new language that is also in the class. This hands-on problem asks you to investigate if $P/\\text{poly}$ is closed under the concatenation operation. You will not only reason about the structure of the combined advice but also perform a concrete calculation of its total length, providing a tangible understanding of why the polynomial bound on advice is preserved. [@problem_id:1454186]", "problem": "In computational complexity theory, the class $P/\\text{poly}$ (Polynomial-Time with Polynomial Advice) consists of decision problems that can be solved by a polynomial-time Turing machine which takes an additional \"advice\" string. This advice string depends only on the length of the input, not the input itself, and its length must be bounded by a polynomial in the input length.\n\nLet $L_1$ and $L_2$ be two languages in $P/\\text{poly}$.\n- For an input of length $n$, the language $L_1$ is decided by a Turing machine $M_1$ using an advice string $s_n^{(1)}$. The length of this advice string is given *exactly* by the polynomial $|s_n^{(1)}| = 2n^2 + 5$.\n- For an input of length $n$, the language $L_2$ is decided by a Turing machine $M_2$ using an advice string $s_n^{(2)}$. The length of this advice string is given *exactly* by the polynomial $|s_n^{(2)}| = n^3 + 3n + 1$.\n\nConsider the concatenation of these two languages, defined as $L_{concat} = L_1 \\circ L_2 = \\{xy \\mid x \\in L_1, y \\in L_2 \\}$. A string $w$ of length $n$ is in $L_{concat}$ if it can be split into a prefix $x$ of length $k$ and a suffix $y$ of length $n-k$, for some $k \\in \\{0, 1, \\dots, n\\}$, such that $x \\in L_1$ and $y \\in L_2$.\n\nTo decide membership in $L_{concat}$ for any string of length $n$, a new Turing machine $M_{concat}$ requires an advice string $c_n$ that contains all the necessary advice from $M_1$ and $M_2$ for all possible split points. Assume this composite advice string $c_n$ is formed by concatenating all required advice strings for subproblems of size from $0$ to $n$ as follows:\n$$c_n = s_0^{(1)} s_1^{(1)} \\dots s_n^{(1)} s_0^{(2)} s_1^{(2)} \\dots s_n^{(2)}$$\nThe length of this composite advice string, $|c_n|$, is a polynomial in $n$. If we write this length as $P(n) = C_4 n^4 + C_3 n^3 + C_2 n^2 + C_1 n + C_0$, what are the exact rational values of the coefficients $C_4, C_3, C_2, C_1, C_0$?\n\nPresent your answer as a single row matrix containing the five coefficients in the order $(C_4, C_3, C_2, C_1, C_0)$.", "solution": "We are given exact advice lengths for inputs of length $k$:\n- For $L_{1}$: $\\left|s_{k}^{(1)}\\right| = 2k^{2} + 5$.\n- For $L_{2}$: $\\left|s_{k}^{(2)}\\right| = k^{3} + 3k + 1$.\n\nThe composite advice for inputs of length $n$ is\n$$\nc_{n} = s_{0}^{(1)} s_{1}^{(1)} \\dots s_{n}^{(1)} s_{0}^{(2)} s_{1}^{(2)} \\dots s_{n}^{(2)},\n$$\nso its total length is\n$$\n|c_{n}| = \\sum_{k=0}^{n} \\left|s_{k}^{(1)}\\right| + \\sum_{k=0}^{n} \\left|s_{k}^{(2)}\\right| = \\sum_{k=0}^{n} (2k^{2}+5) + \\sum_{k=0}^{n} (k^{3}+3k+1).\n$$\n\nUse standard summation formulas:\n$$\n\\sum_{k=0}^{n} 1 = n+1,\\quad \\sum_{k=0}^{n} k = \\frac{n(n+1)}{2},\\quad \\sum_{k=0}^{n} k^{2} = \\frac{n(n+1)(2n+1)}{6},\\quad \\sum_{k=0}^{n} k^{3} = \\left(\\frac{n(n+1)}{2}\\right)^{2}.\n$$\n\nCompute the first sum:\n$$\n\\sum_{k=0}^{n} (2k^{2}+5) = 2 \\sum_{k=0}^{n} k^{2} + 5 \\sum_{k=0}^{n} 1 = 2 \\cdot \\frac{n(n+1)(2n+1)}{6} + 5(n+1).\n$$\nSimplify:\n$$\n\\frac{n(n+1)(2n+1)}{3} + 5(n+1) = \\left(\\frac{2}{3}n^{3} + n^{2} + \\frac{1}{3}n\\right) + 5n + 5 = \\frac{2}{3}n^{3} + n^{2} + \\frac{16}{3}n + 5.\n$$\n\nCompute the second sum:\n$$\n\\sum_{k=0}^{n} (k^{3}+3k+1) = \\sum_{k=0}^{n} k^{3} + 3 \\sum_{k=0}^{n} k + \\sum_{k=0}^{n} 1 = \\left(\\frac{n(n+1)}{2}\\right)^{2} + 3 \\cdot \\frac{n(n+1)}{2} + (n+1).\n$$\nExpand:\n$$\n\\left(\\frac{n(n+1)}{2}\\right)^{2} = \\frac{1}{4}\\left(n^{4} + 2n^{3} + n^{2}\\right),\\quad 3 \\cdot \\frac{n(n+1)}{2} = \\frac{3}{2}n^{2} + \\frac{3}{2}n,\n$$\nso\n$$\n\\sum_{k=0}^{n} (k^{3}+3k+1) = \\frac{1}{4}n^{4} + \\frac{1}{2}n^{3} + \\frac{1}{4}n^{2} + \\frac{3}{2}n^{2} + \\frac{3}{2}n + n + 1 = \\frac{1}{4}n^{4} + \\frac{1}{2}n^{3} + \\frac{7}{4}n^{2} + \\frac{5}{2}n + 1.\n$$\n\nAdd the two parts to obtain $P(n)$:\n$$\nP(n) = |c_{n}| = \\left(\\frac{2}{3}n^{3} + n^{2} + \\frac{16}{3}n + 5\\right) + \\left(\\frac{1}{4}n^{4} + \\frac{1}{2}n^{3} + \\frac{7}{4}n^{2} + \\frac{5}{2}n + 1\\right).\n$$\nCollect coefficients by powers of $n$:\n$$\nP(n) = \\frac{1}{4}n^{4} + \\left(\\frac{2}{3} + \\frac{1}{2}\\right)n^{3} + \\left(1 + \\frac{7}{4}\\right)n^{2} + \\left(\\frac{16}{3} + \\frac{5}{2}\\right)n + (5+1).\n$$\nCompute the sums of coefficients:\n$$\n\\frac{2}{3} + \\frac{1}{2} = \\frac{7}{6},\\quad 1 + \\frac{7}{4} = \\frac{11}{4},\\quad \\frac{16}{3} + \\frac{5}{2} = \\frac{32}{6} + \\frac{15}{6} = \\frac{47}{6},\\quad 5+1=6.\n$$\nTherefore,\n$$\nP(n) = \\frac{1}{4}n^{4} + \\frac{7}{6}n^{3} + \\frac{11}{4}n^{2} + \\frac{47}{6}n + 6,\n$$\nso the coefficients are\n$$\n(C_{4},C_{3},C_{2},C_{1},C_{0}) = \\left(\\frac{1}{4}, \\frac{7}{6}, \\frac{11}{4}, \\frac{47}{6}, 6\\right).\n$$", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1}{4} & \\frac{7}{6} & \\frac{11}{4} & \\frac{47}{6} & 6\\end{pmatrix}}$$", "id": "1454186"}]}