{"hands_on_practices": [{"introduction": "The fooling set method is a powerful combinatorial tool for establishing lower bounds on communication complexity. By identifying a set of input pairs that a protocol cannot distinguish without sufficient communication, we can prove how many bits are fundamentally required. This first practice problem [@problem_id:1465070] applies this method to a simple yet fundamental function: determining if two parties share the same coordinate, which is a form of the Equality problem.", "problem": "In a futuristic smart city, vehicle navigation is managed on a discrete grid of size $N \\times N$. The grid locations are represented by integer coordinates $(x, y)$ where $1 \\le x \\le N$ and $1 \\le y \\le N$. Alice Corp and Bob Inc. each operate an autonomous delivery vehicle. At a certain moment, Alice's vehicle is at position $(x_A, y_A)$ and Bob's vehicle is at $(x_B, y_B)$.\n\nTo manage traffic and communication channel allocation, they need to determine if their vehicles are on the same North-South street. This is equivalent to checking if their x-coordinates are identical. The two parent companies decide to use a two-party communication protocol to determine this. Alice only knows her vehicle's coordinate $(x_A, y_A)$, and Bob only knows his vehicle's coordinate $(x_B, y_B)$.\n\nThey want to compute the function $SVL_N((x_A, y_A), (x_B, y_B))$, which evaluates to 1 if $x_A = x_B$ and to 0 if $x_A \\neq x_B$. To establish a theoretical lower bound on the number of bits they must exchange, we can use the fooling set method.\n\nA set of input pairs $S = \\{ (a_1, b_1), (a_2, b_2), \\dots, (a_k, b_k) \\}$, where $a_i$ is Alice's input and $b_i$ is Bob's input, is called a **fooling set** for a function $f$ if it satisfies two conditions:\n1.  **Uniformity**: There is a constant value $c \\in \\{0, 1\\}$ such that for all pairs $(a_i, b_i) \\in S$, the function evaluates to this constant: $f(a_i, b_i) = c$.\n2.  **Fooling Property**: For any two distinct pairs $(a_i, b_i) \\in S$ and $(a_j, b_j) \\in S$ (i.e., $i \\neq j$), at least one of the \"crossed\" combinations of inputs gives a different result: $f(a_i, b_j) \\neq c$ or $f(a_j, b_i) \\neq c$.\n\nAssuming $N \\ge 4$, what is the size of the largest possible fooling set for the function $SVL_N$?\n\nA. 3\n\nB. $N-1$\n\nC. $N$\n\nD. $2N$\n\nE. $N^2$", "solution": "We formalize the function by\n$$\nSVL_{N}\\big((x_{A},y_{A}),(x_{B},y_{B})\\big)=\\begin{cases}\n1  \\text{if } x_{A}=x_{B},\\\\\n0  \\text{if } x_{A}\\neq x_{B}.\n\\end{cases}\n$$\nA fooling set $S=\\{(a_{i},b_{i})\\}_{i=1}^{k}$ for $SVL_{N}$ must satisfy:\n1) Uniformity: there exists a constant $c\\in\\{0,1\\}$ such that $SVL_{N}(a_{i},b_{i})=c$ for all $i$.\n2) Fooling property: for any $i\\neq j$, at least one of $SVL_{N}(a_{i},b_{j})\\neq c$ or $SVL_{N}(a_{j},b_{i})\\neq c$ holds.\n\nLower bound (achievability of size $N$ with $c=1$):\n- Impose $c=1$. Then for each pair $(a_{i},b_{i})=((x_{A}^{(i)},y_{A}^{(i)}),(x_{B}^{(i)},y_{B}^{(i)}))$ we must have $x_{A}^{(i)}=x_{B}^{(i)}$.\n- Consider the set\n$$\nS_{1}=\\left\\{\\big((x,1),(x,1)\\big): x\\in\\{1,2,\\dots,N\\}\\right\\}.\n$$\nUniformity holds since for every element of $S_{1}$, $x_{A}=x_{B}$, so $SVL_{N}=1$.\nFor any two distinct pairs with $x\\neq x'$, the crossed input $((x,1),(x',1))$ yields $x\\neq x'$, hence\n$$\nSVL_{N}\\big((x,1),(x',1)\\big)=0\\neq 1,\n$$\nwhich satisfies the fooling property. Therefore $|S_{1}|=N$ is a valid fooling set, so the largest possible size is at least $N$.\n\nUpper bound for any $c=1$ fooling set:\n- Let $S$ be any $c=1$ fooling set. Then for each $(a_{i},b_{i})$ we have $x_{A}^{(i)}=x_{B}^{(i)}$.\n- Suppose two distinct pairs $i\\neq j$ had the same $x$-coordinate, i.e., $x_{A}^{(i)}=x_{B}^{(i)}=x_{A}^{(j)}=x_{B}^{(j)}$. Then the crossed inputs satisfy\n$$\nSVL_{N}(a_{i},b_{j})=1 \\quad \\text{and} \\quad SVL_{N}(a_{j},b_{i})=1,\n$$\nviolating the fooling property (since neither crossed value differs from $c=1$). Hence all $x$-values across the pairs in $S$ must be distinct, which implies $|S|\\leq N$.\n\nGlobal upper bound for any fooling set (including $c=0$):\n- Let $S$ be a $c=0$ fooling set. Write $u_{i}=x_{A}^{(i)}$ and $v_{i}=x_{B}^{(i)}$. Uniformity implies $u_{i}\\neq v_{i}$ for all $i$.\n- Suppose there exist $i\\neq j$ with $v_{i}=v_{j}$. Consider the two required crossed checks:\n$$\nSVL_{N}(a_{i},b_{j})=1 \\iff u_{i}=v_{j}=v_{i},\n$$\nand\n$$\nSVL_{N}(a_{j},b_{i})=1 \\iff u_{j}=v_{i}=v_{j}.\n$$\nBoth equalities would force $u_{i}=v_{i}$ or $u_{j}=v_{j}$, contradicting $u_{i}\\neq v_{i}$ and $u_{j}\\neq v_{j}$. Therefore both crossed evaluations equal $0$, violating the fooling property. Hence all $v_{i}$ must be pairwise distinct, so $|S|\\leq N$.\n\nCombining the bounds: there exists a fooling set of size $N$ (as constructed with $c=1$) and no fooling set can have size larger than $N$. Therefore, the largest possible fooling set for $SVL_{N}$ has size $N$, which corresponds to option C.", "answer": "$$\\boxed{C}$$", "id": "1465070"}, {"introduction": "After mastering the basics of fooling sets, we can tackle a more complex, non-local function. This exercise [@problem_id:1465088] challenges you to analyze the 'Reversal' function, where the relationship between Alice's and Bob's strings depends on all bits. You will see how to construct a fooling set whose size grows exponentially with the input length, leading to a tight linear bound on communication and showcasing the method's power.", "problem": "In a distributed computing scenario, two parties, Alice and Bob, need to perform a data verification task. Alice possesses a binary string $x$ of length $n$, and Bob possesses a binary string $y$ of the same length $n$. They want to determine if Bob's string is the reversal of Alice's string. Let's define the function $REV(x,y)$ for this task. Given $x = x_1x_2...x_n$ and $y = y_1y_2...y_n$, the function is defined as:\n$$\nREV(x,y) = \\begin{cases} 1  \\text{if } y_i = x_{n-i+1} \\text{ for all } i \\in \\{1, 2, ..., n\\} \\\\ 0  \\text{otherwise} \\end{cases}\n$$\nAlice and Bob can communicate by sending bits to each other over a channel according to a pre-agreed deterministic protocol. The communication cost of a protocol is the maximum number of bits exchanged for any possible input pair $(x, y)$. What is the theoretical minimum number of bits they must exchange in the worst case to compute the function $REV(x,y)$? Your answer should be a closed-form expression in terms of $n$.", "solution": "Let $n \\in \\mathbb{N}$ and let $x,y \\in \\{0,1\\}^{n}$. Define $\\operatorname{rev}(x)$ by $\\operatorname{rev}(x)_{i}=x_{n-i+1}$ for all $i \\in \\{1,\\dots,n\\}$. The function is $REV(x,y)=1$ if and only if $y=\\operatorname{rev}(x)$ and $REV(x,y)=0$ otherwise.\n\nUpper bound: A deterministic protocol with cost $n$ bits exists. For example, Alice sends the $n$-bit string $x$ to Bob. Bob computes $\\operatorname{rev}(x)$ locally and compares it to his $y$. He outputs $1$ if $y=\\operatorname{rev}(x)$ and $0$ otherwise. Hence the communication cost of this protocol is $n$, so\n$$\nD(REV) \\leq n.\n$$\n\nLower bound: We use the fooling set method. Consider the set\n$$\nS=\\{(x,\\operatorname{rev}(x)) : x \\in \\{0,1\\}^{n}\\}.\n$$\nFor every $(x,\\operatorname{rev}(x)) \\in S$, by definition $REV(x,\\operatorname{rev}(x))=1$. Take any two distinct elements $(x,\\operatorname{rev}(x))$ and $(x',\\operatorname{rev}(x'))$ from $S$ with $x \\neq x'$. Then\n$$\nREV\\bigl(x,\\operatorname{rev}(x')\\bigr)=1 \\iff \\operatorname{rev}(x')=\\operatorname{rev}(x) \\iff x'=x,\n$$\nwhich is false, so $REV\\bigl(x,\\operatorname{rev}(x')\\bigr)=0$. Similarly, $REV\\bigl(x',\\operatorname{rev}(x)\\bigr)=0$. Thus $S$ is a fooling set of $1$-inputs of size $|S|=2^{n}$. By the standard fooling set lower bound, the deterministic communication complexity satisfies\n$$\nD(REV) \\geq \\log_{2}|S|=\\log_{2}(2^{n})=n.\n$$\n\nCombining the bounds gives $D(REV)=n$. Therefore, the theoretical minimum number of bits exchanged in the worst case is $n$.", "answer": "$$\\boxed{n}$$", "id": "1465088"}, {"introduction": "Beyond combinatorial arguments, communication complexity theory offers powerful algebraic techniques for proving lower bounds. This problem introduces the log-rank method, which connects the communication cost of a function to the rank of its associated communication matrix. By working through the \"Greater-Than\" function [@problem_id:61771], you will gain hands-on experience with this elegant method, which provides a different perspective by linking complexity theory with linear algebra.", "problem": "In the standard two-party model of communication complexity, two parties, Alice and Bob, hold inputs $x \\in X$ and $y \\in Y$ respectively. Their goal is to collaboratively compute the value of a function $f(x, y)$ by exchanging messages according to a deterministic protocol. The deterministic communication complexity, denoted $D(f)$, is the minimum number of bits exchanged in the worst-case input pair $(x, y)$ by the most efficient protocol for $f$.\n\nA powerful tool for lower-bounding $D(f)$ is the communication matrix $M_f$. This is a $|X| \\times |Y|$ matrix where the entry corresponding to row $x$ and column $y$ is given by $M_f[x, y] = f(x, y)$. A fundamental result connects the complexity to the rank of this matrix over the real numbers:\n$$\nD(f) \\ge \\lceil \\log_2(\\text{rank}_{\\mathbb{R}}(M_f)) \\rceil\n$$\nThis is known as the log-rank lower bound.\n\nConsider the 4-bit \"Greater Than\" function, $GT_4$. Alice is given a 4-bit unsigned integer $x \\in \\{0, 1, \\dots, 15\\}$, and Bob is given a 4-bit unsigned integer $y \\in \\{0, 1, \\dots, 15\\}$. The function is defined as:\n$$\nGT_4(x, y) = \\begin{cases} 1  \\text{if } x > y \\\\ 0  \\text{if } x \\le y \\end{cases}\n$$\n\nYour task is to compute the log-rank lower bound on the deterministic communication complexity of the $GT_4$ function. To achieve this, you must first determine the rank of the communication matrix $M_{GT_4}$.", "solution": "The communication matrix $M_{GT_4}$ for the 4-bit Greater Than function is a $16 \\times 16$ matrix, with rows and columns indexed by the inputs $x, y \\in \\{0, 1, \\dots, 15\\}$. The entries are defined as:\n\n$$\nM_{GT_4}[x, y] = \\begin{cases} \n1  \\text{if } x > y \\\\\n0  \\text{if } x \\le y \n\\end{cases}\n$$\n\n\nThis matrix is strictly lower triangular with zeros on and above the diagonal, and ones below the diagonal. Specifically:\n- The row for $x = 0$ is all zeros.\n- For $x = 1$, the row is $[1, 0, 0, \\dots, 0]$.\n- For $x = 2$, the row is $[1, 1, 0, \\dots, 0]$.\n- ...\n- For $x = 15$, the row is $[1, 1, \\dots, 1, 0]$ (15 ones followed by a zero).\n\nThe rank of this matrix over the real numbers, $\\text{rank}_{\\mathbb{R}}(M_{GT_4})$, is determined by the number of linearly independent rows. The rows for $x = 1$ to $x = 15$ are linearly independent, while the row for $x = 0$ is all zeros and does not contribute to the rank. To see this, consider the rows as vectors:\n- Row $x = 1$: $(1, 0, 0, \\dots, 0)$\n- Row $x = 2$: $(1, 1, 0, \\dots, 0)$\n- ...\n- Row $x = 15$: $(1, 1, \\dots, 1, 0)$\n\nThese rows form a basis for a 15-dimensional subspace. Any linear combination:\n\n$$\n\\sum_{k=1}^{15} a_k \\cdot \\text{row}_k = 0\n$$\n\nimplies $a_k = 0$ for all $k$, as shown by equating coefficients starting from the last non-zero entry. Thus, the rank is 15.\n\nThe log-rank lower bound for the deterministic communication complexity is:\n\n$$\nD(GT_4) \\ge \\lceil \\log_2(\\text{rank}_{\\mathbb{R}}(M_{GT_4})) \\rceil = \\lceil \\log_2(15) \\rceil\n$$\n\nSince $2^3 = 8  15  16 = 2^4$, $\\log_2(15)$ is between 3 and 4, and thus:\n\n$$\n\\lceil \\log_2(15) \\rceil = 4\n$$\n\nTherefore, the log-rank lower bound is 4.", "answer": "$$ \\boxed{4} $$", "id": "61771"}]}