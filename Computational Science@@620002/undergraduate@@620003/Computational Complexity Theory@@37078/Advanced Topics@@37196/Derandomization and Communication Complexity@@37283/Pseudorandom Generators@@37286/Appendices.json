{"hands_on_practices": [{"introduction": "A common first attempt at building a pseudorandom generator (PRG) is to extend a random seed by appending a simple, calculated value. This exercise explores what happens when there is a clear, predictable relationship between different parts of the output string. By constructing a simple distinguisher that checks this relationship [@problem_id:1439184], you will gain a concrete understanding of what it means to \"break\" a generator and how to quantify its insecurity by calculating the distinguisher's advantage.", "problem": "In computational complexity theory, a Pseudorandom Generator (PRG) is an efficient, deterministic algorithm that takes a short, truly random seed and expands it into a longer string that is computationally indistinguishable from a truly random string of the same length.\n\nLet's analyze a simple candidate for a PRG. Consider the generator $G: \\{0,1\\}^s \\to \\{0,1\\}^{s+1}$ defined for any integer $s \\ge 1$. For any input seed $x \\in \\{0,1\\}^s$, the generator produces the output $G(x) = x \\| \\text{parity}(x)$, where `\\|` denotes string concatenation and $\\text{parity}(x)$ is the sum of the bits of $x$ modulo 2. For instance, if $s=3$ and $x=101$, then $\\text{parity}(x) = (1+0+1) \\pmod 2 = 0$, so $G(101) = 1010$.\n\nA PRG is considered \"broken\" if there exists an efficient algorithm, called a distinguisher $D$, that can tell its output apart from a truly random string with a non-negligible advantage. A distinguisher $D$ is an algorithm that takes a string of length $s+1$ as input and outputs either 1 (guessing the input is from the PRG) or 0 (guessing the input is truly random).\n\nThe advantage of a distinguisher $D$ for a generator $G$ is defined as:\n$$ \\text{Adv}_G(D) = \\left| \\Pr_{x \\sim U_s}[D(G(x)) = 1] - \\Pr_{y \\sim U_{s+1}}[D(y) = 1] \\right| $$\nwhere $U_n$ denotes the uniform distribution over all binary strings of length $n$.\n\nYour task is to demonstrate that the generator $G(x) = x \\| \\text{parity}(x)$ is not a secure PRG. First, devise a simple, efficient algorithm for a distinguisher $D$. Then, calculate the exact advantage, $\\text{Adv}_G(D)$, of your proposed distinguisher. The final answer should be this single numerical value.", "solution": "Define an efficient distinguisher $D$ that, on input $y \\in \\{0,1\\}^{s+1}$, parses $y$ as $y=a\\|b$ with $a \\in \\{0,1\\}^{s}$ and $b \\in \\{0,1\\}$, computes $\\text{parity}(a)$ (the sum of the bits of $a$ modulo $2$), and outputs $1$ if and only if $b=\\text{parity}(a)$; otherwise it outputs $0$. This is efficient because computing parity and a single comparison are both polynomial-time operations.\n\nWhen $y$ is of the form $G(x)$ for $x \\sim U_{s}$, we have by definition $G(x)=x\\|\\text{parity}(x)$, so the last bit equals the parity of the first $s$ bits for every input. Therefore,\n$$\n\\Pr_{x \\sim U_{s}}[D(G(x))=1]=1.\n$$\nWhen $y \\sim U_{s+1}$ is truly uniform, write $y=a\\|b$ with $a \\in \\{0,1\\}^{s}$ and $b \\in \\{0,1\\}$. For any fixed $a$, $\\text{parity}(a)$ is fixed, while $b$ is uniform and independent, so\n$$\n\\Pr[b=\\text{parity}(a)\\mid a]=\\frac{1}{2}.\n$$\nBy the law of total probability and the uniformity of $a$,\n$$\n\\Pr_{y \\sim U_{s+1}}[D(y)=1]=\\sum_{a \\in \\{0,1\\}^{s}} \\Pr[a]\\Pr[b=\\text{parity}(a)\\mid a]=\\sum_{a \\in \\{0,1\\}^{s}} 2^{-s}\\cdot \\frac{1}{2}=\\frac{1}{2}.\n$$\nHence the distinguishing advantage is\n$$\n\\text{Adv}_{G}(D)=\\left|\\Pr_{x \\sim U_{s}}[D(G(x))=1]-\\Pr_{y \\sim U_{s+1}}[D(y)=1]\\right|=\\left|1-\\frac{1}{2}\\right|=\\frac{1}{2}.\n$$\nThis non-negligible advantage shows $G$ is not a secure PRG.", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "1439184"}, {"introduction": "A secure PRG must produce output that lacks any efficiently detectable structure or pattern. This practice moves beyond simple bit-wise correlations to examine a global structural property: symmetry. You will design a distinguisher that checks if an output string is a palindrome [@problem_id:1439190], demonstrating that even non-local patterns can represent a critical security vulnerability and be exploited to distinguish the generator's output from true randomness.", "problem": "In the field of computational complexity theory, a Pseudorandom Generator (PRG) is a deterministic algorithm that takes a short uniformly random seed and expands it into a longer string that appears random to any computationally bounded observer.\n\nFormally, a generator is a function $G: \\{0,1\\}^s \\to \\{0,1\\}^n$ with $n > s$, where $s$ is the seed length. A distinguisher is an algorithm $D: \\{0,1\\}^n \\to \\{0,1\\}$ that attempts to differentiate between the output of the generator and a truly random string.\n\nThe \"advantage\" of a distinguisher $D$ for a generator $G$, denoted $Adv_G(D)$, measures its success. It is defined as:\n$Adv_G(D) = \\left| \\Pr_{x \\leftarrow \\{0,1\\}^s}[D(G(x)) = 1] - \\Pr_{y \\leftarrow \\{0,1\\}^n}[D(y) = 1] \\right|$,\nwhere the notation $v \\leftarrow S$ means that $v$ is chosen uniformly at random from the set $S$. A generator is considered insecure if there exists an efficient (polynomial-time) distinguisher with a non-negligible advantage.\n\nConsider a specific, simple generator $G_{pal}: \\{0,1\\}^s \\to \\{0,1\\}^{2s}$, where $s$ is a positive integer. For a given seed $x \\in \\{0,1\\}^s$, the output is formed by concatenating the seed with its reverse. If $x^R$ denotes the reverse of the string $x$, then $G_{pal}(x) = x \\cdot x^R$.\n\nNow, consider a distinguisher $D_{test}$ that operates on strings of length $2s$. This distinguisher is designed to check for a specific structural property. On input $z \\in \\{0,1\\}^{2s}$, $D_{test}(z)$ outputs 1 if $z$ is a palindrome (i.e., $z$ reads the same forwards and backwards), and outputs 0 otherwise.\n\nYour task is to calculate the advantage $Adv_{G_{pal}}(D_{test})$ of this distinguisher. Express your answer as a function of the seed length $s$.", "solution": "By definition, the advantage of a distinguisher $D$ against a generator $G$ is\n$$\nAdv_{G}(D)=\\left|\\Pr_{x\\leftarrow\\{0,1\\}^{s}}\\left[D(G(x))=1\\right]-\\Pr_{y\\leftarrow\\{0,1\\}^{n}}\\left[D(y)=1\\right]\\right|.\n$$\nHere $G_{pal}:\\{0,1\\}^{s}\\to\\{0,1\\}^{2s}$ is given by $G_{pal}(x)=x\\cdot x^{R}$, and $D_{test}$ on $z\\in\\{0,1\\}^{2s}$ outputs $1$ if and only if $z$ is a palindrome.\n\nFirst, for any $x\\in\\{0,1\\}^{s}$, let $z=G_{pal}(x)=x\\cdot x^{R}$. Then the reverse of $z$ is\n$$\nz^{R}=(x\\cdot x^{R})^{R}=(x^{R})^{R}\\cdot x^{R}=x\\cdot x^{R}=z,\n$$\nso $z$ is a palindrome. Therefore,\n$$\n\\Pr_{x\\leftarrow\\{0,1\\}^{s}}\\left[D_{test}(G_{pal}(x))=1\\right]=1.\n$$\n\nSecond, for a uniformly random $y\\in\\{0,1\\}^{2s}$, the event that $y$ is a palindrome is determined entirely by the first $s$ bits; once these are fixed, the last $s$ bits must be their reverse. Hence the number of palindromes in $\\{0,1\\}^{2s}$ is $2^{s}$, and the total number of strings is $2^{2s}$. Thus,\n$$\n\\Pr_{y\\leftarrow\\{0,1\\}^{2s}}\\left[D_{test}(y)=1\\right]=\\frac{2^{s}}{2^{2s}}=2^{-s}.\n$$\n\nCombining these, the advantage is\n$$\nAdv_{G_{pal}}(D_{test})=\\left|1-2^{-s}\\right|=1-2^{-s},\n$$\nsince $1\\geq 2^{-s}$ for positive integer $s$.", "answer": "$$\\boxed{1-2^{-s}}$$", "id": "1439190"}, {"introduction": "After learning to identify flaws in insecure generators, it is equally important to understand how new secure constructions can be derived from existing ones. This exercise shifts the focus from breaking a generator to proving one secure, challenging you to determine if the security of a PRG is preserved under a simple transformation like a bitwise NOT operation [@problem_id:1439188]. You will use a fundamental cryptographic proof technique called a \"reduction\" to formally argue about the security of the new generator, illustrating how complex systems can be proven secure based on the properties of their components.", "problem": "In the theory of computational complexity, a Pseudorandom Generator (PRG) is a deterministic algorithm that takes a short, truly random seed and expands it into a longer, pseudorandom string. The output is considered pseudorandom if it is computationally indistinguishable from a truly random string of the same length.\n\nFormally, a function $G: \\{0,1\\}^n \\to \\{0,1\\}^m$, where the output length $m=m(n)$ is a polynomial in the seed length $n$ and $m(n) > n$, is a secure PRG if for every probabilistic polynomial-time (PPT) algorithm $D$ (called a distinguisher), the following inequality holds:\n$$\n|\\Pr_{x \\sim U_n}[D(G(x)) = 1] - \\Pr_{y \\sim U_m}[D(y) = 1]| \\le \\epsilon(n)\n$$\nwhere $x \\sim U_n$ denotes that the seed $x$ is chosen uniformly at random from $\\{0,1\\}^n$, $y \\sim U_m$ denotes that $y$ is chosen uniformly at random from $\\{0,1\\}^m$, and $\\epsilon(n)$ is a negligible function (a function that decreases faster than the reciprocal of any polynomial).\n\nSuppose you are given a function $G: \\{0,1\\}^n \\to \\{0,1\\}^m$ which is a secure PRG. Now, consider a new generator, $G_{neg}: \\{0,1\\}^n \\to \\{0,1\\}^m$, defined as $G_{neg}(x) = \\neg G(x)$, where $\\neg$ is the bitwise NOT operation (i.e., for a bit string $y=y_1y_2...y_m$, the operation $\\neg y$ results in a new string $z=z_1z_2...z_m$ such that $z_i = 1 - y_i$ for all $i$).\n\nWhich of the following statements is correct regarding the security of $G_{neg}$?\n\nA. $G_{neg}$ is always a secure PRG.\n\nB. $G_{neg}$ is never a secure PRG.\n\nC. The security of $G_{neg}$ depends on the specific construction of $G$ and cannot be determined in general.\n\nD. The security of $G_{neg}$ is a computationally undecidable problem.", "solution": "Let $G:\\{0,1\\}^{n}\\to\\{0,1\\}^{m}$ be a secure PRG and define $G_{neg}(x)=\\neg G(x)$, where $\\neg$ is the bitwise NOT on $\\{0,1\\}^{m}$. We show that $G_{neg}$ is also a secure PRG by reduction. Let $D$ be any PPT distinguisher attempting to distinguish $G_{neg}(U_{n})$ from $U_{m}$. Define a new PPT distinguisher $D':\\{0,1\\}^{m}\\to\\{0,1\\}$ by $D'(y)=D(\\neg y)$. The map $y\\mapsto\\neg y$ is a bijection on $\\{0,1\\}^{m}$ and is computable in polynomial time, and it preserves uniform measure: if $y\\sim U_{m}$ then $\\neg y\\sim U_{m}$.\n\nConsider the distinguishing advantage of $D$ against $G_{neg}$:\n$$\n\\Delta \\equiv \\left|\\Pr_{x\\sim U_{n}}[D(G_{neg}(x))=1]-\\Pr_{y\\sim U_{m}}[D(y)=1]\\right|.\n$$\nBy the definition of $G_{neg}$ and $D'$,\n$$\n\\Pr_{x\\sim U_{n}}[D(G_{neg}(x))=1]=\\Pr_{x\\sim U_{n}}[D(\\neg G(x))=1]=\\Pr_{x\\sim U_{n}}[D'(G(x))=1].\n$$\nMoreover, since $y\\sim U_{m}$ implies $\\neg y\\sim U_{m}$ and $\\neg$ is a permutation,\n$$\n\\Pr_{y\\sim U_{m}}[D(y)=1]=\\Pr_{y\\sim U_{m}}[D(\\neg y)=1]=\\Pr_{y\\sim U_{m}}[D'(y)=1].\n$$\nTherefore,\n$$\n\\Delta=\\left|\\Pr_{x\\sim U_{n}}[D'(G(x))=1]-\\Pr_{y\\sim U_{m}}[D'(y)=1]\\right|.\n$$\nSince $G$ is a secure PRG, for every PPT $D'$ this advantage is bounded by a negligible function $\\epsilon(n)$:\n$$\n\\left|\\Pr_{x\\sim U_{n}}[D'(G(x))=1]-\\Pr_{y\\sim U_{m}}[D'(y)=1]\\right|\\le \\epsilon(n).\n$$\nHence $\\Delta\\le \\epsilon(n)$ for every PPT $D$, proving that $G_{neg}$ is a secure PRG. Consequently, the correct statement is that $G_{neg}$ is always a secure PRG.", "answer": "$$\\boxed{A}$$", "id": "1439188"}]}