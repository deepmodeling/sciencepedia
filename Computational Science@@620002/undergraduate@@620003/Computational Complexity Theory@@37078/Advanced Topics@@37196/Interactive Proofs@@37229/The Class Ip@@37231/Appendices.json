{"hands_on_practices": [{"introduction": "To begin our hands-on exploration of interactive proofs, we start with the fundamentals: completeness and soundness. This first exercise [@problem_id:1452378] presents a simple, hypothetical protocol designed to be \"perfect,\" meaning it has zero probability of error. By analyzing how an all-powerful prover can always convince a verifier of a true statement, but can never fool them with a false one, you'll gain a concrete understanding of these two cornerstones of interactive proof systems.", "problem": "In the field of computational complexity theory, an interactive proof system involves two parties: an all-powerful prover (Merlin) and a computationally-limited verifier (Arthur). Merlin's goal is to convince Arthur that a given input string belongs to a certain language. The system's effectiveness is measured by two properties:\n\n*   **Completeness**: If a statement is true, an honest Merlin should be able to convince Arthur with high probability. The completeness of a protocol is the minimum probability that Arthur accepts a true statement.\n*   **Soundness**: If a statement is false, a cheating Merlin should not be able to convince Arthur. The soundness error is the maximum probability that Arthur accepts a false statement.\n\nConsider the language $\\text{NON-SQUARE}$, which consists of all positive integers greater than 1 that are not perfect squares (e.g., 2, 3, 5, 6, 7, 8, 10 are in NON-SQUARE, while 4, 9, 16 are not).\n\nMerlin and Arthur engage in the following one-round protocol to determine if a given integer $n > 1$ is in NON-SQUARE:\n\n1.  **Merlin's Move**: Merlin, who has unlimited computational power and thus knows the prime factorization of $n$, provides Arthur with a single positive integer, which we will call $p$.\n2.  **Arthur's Verification**: Arthur, a polynomial-time verifier, performs the following checks on the integer $p$ received from Merlin:\n    *   **Check A**: Arthur verifies that $p$ is a prime number and that $p$ divides $n$.\n    *   **Check B**: Arthur calculates the largest integer exponent $k$ such that $p^k$ divides $n$. He then checks if this exponent $k$ is an odd number.\n3.  **Arthur's Decision**: If both Check A and Check B pass, Arthur is convinced that $n$ is not a perfect square and accepts. If either check fails, or if Merlin fails to provide an integer $p$ that can pass the checks, Arthur rejects.\n\nFor the purpose of this problem, assume that Arthur has an efficient and perfect algorithm for primality testing.\n\nWhat are the completeness and soundness error probabilities for this protocol?\n\nA. Completeness = $1$, Soundness Error = $1$\n\nB. Completeness = $1$, Soundness Error = $1/2$\n\nC. Completeness = $1$, Soundness Error = $0$\n\nD. Completeness = $2/3$, Soundness Error = $1/3$\n\nE. Completeness = $1/2$, Soundness Error = $1/2$\n\nF. Completeness = $0$, Soundness Error = $1$", "solution": "Write the unique prime factorization of $n > 1$ as\n$$\nn=\\prod_{i=1}^{t} q_{i}^{e_{i}},\n$$\nwhere the $q_{i}$ are distinct primes and the $e_{i}\\in \\mathbb{N}$. A standard number-theoretic fact is:\n$$\nn \\text{ is a perfect square } \\Longleftrightarrow \\forall i,\\ e_{i} \\text{ is even},\n$$\nand equivalently,\n$$\nn \\in \\text{NON-SQUARE} \\Longleftrightarrow \\exists i \\text{ such that } e_{i} \\text{ is odd}.\n$$\n\nCompleteness: Suppose $n\\in \\text{NON-SQUARE}$. Then there exists an index $j$ with $e_{j}$ odd. Merlin can send $p=q_{j}$. Arthur verifies $p$ is prime and $p \\mid n$ (Check A), which holds since $q_{j} \\mid n$. Arthur then computes the largest $k$ with $p^{k} \\mid n$, which equals $k=e_{j}$ by definition of the factorization, and checks that $k$ is odd (Check B), which holds. All checks are deterministic and pass, so Arthur accepts with probability $1$. Therefore completeness equals $1$.\n\nSoundness: Suppose $n$ is a perfect square. Then every $e_{i}$ is even. Consider any message $p$ Merlin might send. If $p$ is not prime or $p \\nmid n$, Check A fails and Arthur rejects. If $p$ is a prime divisor of $n$, then the largest $k$ with $p^{k} \\mid n$ is even (equal to the corresponding $e_{i}$), so Check B fails and Arthur rejects. Hence no cheating strategy can make Arthur accept; the acceptance probability on false statements is $0$. Therefore the soundness error equals $0$.\n\nThus, completeness $=1$ and soundness error $=0$, corresponding to option C.", "answer": "$$\\boxed{C}$$", "id": "1452378"}, {"introduction": "While perfect protocols are ideal, many powerful interactive proofs involve randomness and have a small, non-zero probability of error. This practice [@problem_id:1452374] demonstrates a crucial technique for managing this uncertainty: probability amplification. You will calculate how repeating a protocol with a significant soundness error can exponentially reduce the chance of being deceived, making it reliable enough for even the most critical applications.", "problem": "An Interactive Proof (IP) system is a protocol where a powerful but untrustworthy Prover tries to convince a computationally limited Verifier of a statement's truth. The protocol for Graph Non-Isomorphism (GNI) is a classic example of such a system, used to demonstrate that two given graphs are not structurally identical.\n\nSuppose a verifier is using a specific IP protocol to determine if two given graphs, $G_0$ and $G_1$, are non-isomorphic. The protocol has the following properties:\n1.  **Perfect Completeness**: If the graphs are indeed non-isomorphic (the statement is true), the Prover can always convince the Verifier. The Verifier accepts with probability 1.\n2.  **Soundness Error**: If the graphs are isomorphic (the statement is false), a malicious Prover can trick the Verifier into accepting the false statement with a probability of at most $s = 1/2$.\n\nTo reduce the probability of being deceived, the Verifier decides to run the protocol $n$ times independently. The Verifier will only accept the claim that the graphs are non-isomorphic if the Prover successfully passes all $n$ independent trials. The cybersecurity policy for this task requires that the overall soundness error of this repeated protocol must be strictly less than the probability of a catastrophic system-wide failure, which is estimated to be $P_{fail} = 3.5 \\times 10^{-31}$.\n\nWhat is the minimum integer number of repetitions, $n$, required to satisfy this security policy?", "solution": "In an interactive proof with perfect completeness and soundness error $s$, if the verifier runs the protocol independently $n$ times and accepts only if all $n$ trials accept, the overall soundness error is bounded by $s^{n}$, because the malicious prover must succeed in all independent trials. Here $s=\\frac{1}{2}$, so the repeated soundness error is $\\left(\\frac{1}{2}\\right)^{n}$.\n\nThe security requirement is that the overall soundness error be strictly less than $P_{fail}=3.5 \\times 10^{-31}$. Therefore $n$ must satisfy\n$$\n\\left(\\frac{1}{2}\\right)^{n}  3.5 \\times 10^{-31}.\n$$\nTaking $\\log_{10}$ of both sides gives\n$$\nn \\log_{10}\\left(\\frac{1}{2}\\right)  \\log_{10}\\left(3.5 \\times 10^{-31}\\right).\n$$\nSince $\\log_{10}\\left(\\frac{1}{2}\\right)=-\\log_{10}(2)$, this becomes\n$$\n-n \\log_{10}(2)  \\log_{10}(3.5) - 31,\n$$\nand multiplying both sides by $-1$ (which reverses the inequality) yields\n$$\nn \\log_{10}(2) > 31 - \\log_{10}(3.5).\n$$\nHence the minimum integer $n$ is\n$$\nn = \\left\\lceil \\frac{31 - \\log_{10}(3.5)}{\\log_{10}(2)} \\right\\rceil.\n$$\nNumerically, $\\log_{10}(2) \\approx 0.30102999566$ and $\\log_{10}(3.5) \\approx 0.544068044$, so\n$$\n\\frac{31 - \\log_{10}(3.5)}{\\log_{10}(2)} \\approx \\frac{30.455931956}{0.30102999566} \\approx 101.1724\\ldots,\n$$\nand therefore the smallest integer $n$ satisfying the inequality is\n$$\nn=102.\n$$\nA quick check: $2^{-101} \\approx 3.94 \\times 10^{-31}$, which is not yet below $3.5 \\times 10^{-31}$, while $2^{-102} \\approx 1.97 \\times 10^{-31}  3.5 \\times 10^{-31}$.", "answer": "$$\\boxed{102}$$", "id": "1452374"}, {"introduction": "Now we move towards the advanced algebraic techniques that give interactive proofs their surprising power, famously showing that $IP = PSPACE$. This problem [@problem_id:1452382] provides a glimpse into the celebrated sum-check protocol, using the familiar context of a Sudoku puzzle to make it more accessible. By identifying the initial steps of this protocol, you will see how a complex counting problem can be systematically broken down into a series of simpler claims that a verifier can efficiently check.", "problem": "An all-powerful Prover, Peggy, wishes to convince a computationally-limited but skeptical Verifier, Victor, about the properties of a standard $9 \\times 9$ Sudoku puzzle. Specifically, Peggy claims that the given puzzle has a unique solution.\n\nTo formalize this, they agree on the following setup. The state of the Sudoku grid is represented by $m = 9 \\times 9 \\times 9 = 729$ boolean variables, denoted collectively as $Z = (z_1, z_2, \\dots, z_m)$. A specific assignment to these variables corresponds to filling each cell of the grid with a number from 1 to 9. The rules of Sudoku, along with the given puzzle's initial clues, can be encoded into a single boolean formula $\\phi(Z)$. This formula $\\phi(Z)$ evaluates to true (or 1) if and only if $Z$ represents a valid and complete solution to the puzzle.\n\nTo leverage algebraic techniques, the boolean formula $\\phi(Z)$ is converted into a multilinear polynomial $p(z_1, \\dots, z_m)$ over a large finite field $\\mathbb{F}_q$. The polynomial $p$ has the property that for any assignment $Z \\in \\{0,1\\}^m$, $p(Z) = \\phi(Z)$. The total number of solutions to the Sudoku puzzle is therefore given by the sum:\n$$N = \\sum_{z_1 \\in \\{0,1\\}} \\sum_{z_2 \\in \\{0,1\\}} \\cdots \\sum_{z_m \\in \\{0,1\\}} p(z_1, z_2, \\dots, z_m)$$\nPeggy's claim of a unique solution is equivalent to the claim that $N=1$.\n\nPeggy and Victor decide to use the sum-check interactive protocol to verify this claim. The protocol proceeds in rounds, where in each round the sum over one variable is evaluated and checked. The first round focuses on the variable $z_1$. Let the polynomial $g_1(Z_1)$ be defined as:\n$$g_1(Z_1) = \\sum_{z_2 \\in \\{0,1\\}} \\cdots \\sum_{z_m \\in \\{0,1\\}} p(Z_1, z_2, \\dots, z_m)$$\nThe protocol will begin by examining the claim $\\sum_{z_1 \\in \\{0,1\\}} g_1(z_1) = 1$.\n\nWhich of the following options correctly describes the first message sent by the Prover to the Verifier, and the first subsequent message sent by the Verifier to the Prover, during the first round of this sum-check protocol?\n\nA. Prover to Verifier: A cryptographic commitment to a randomly permuted version of the unique solution grid. Verifier to Prover: A random challenge bit $b \\in \\{0,1\\}$.\n\nB. Prover to Verifier: The polynomial $g_1(Z_1)$, specified by its coefficients. Verifier to Prover: A random element $r_1 \\in \\mathbb{F}_q$.\n\nC. Prover to Verifier: The two numerical values, $g_1(0)$ and $g_1(1)$. Verifier to Prover: A random element $r_1 \\in \\mathbb{F}_q$.\n\nD. Prover to Verifier: The complete, solved Sudoku grid. Verifier to Prover: An acceptance bit $b \\in \\{0,1\\}$.\n\nE. Prover to Verifier: A random element $r_1 \\in \\mathbb{F}_q$. Verifier to Prover: The polynomial $g_1(Z_1)$, specified by its coefficients.", "solution": "We formalize the claimed count as the sum over the Boolean hypercube:\n$$N=\\sum_{z_{1}\\in\\{0,1\\}}\\sum_{z_{2}\\in\\{0,1\\}}\\cdots\\sum_{z_{m}\\in\\{0,1\\}} p(z_{1},z_{2},\\dots,z_{m}),$$\nwith the claim being $N=1$.\n\nDefine the univariate polynomial for the first round:\n$$g_{1}(Z_{1})=\\sum_{z_{2}\\in\\{0,1\\}}\\cdots\\sum_{z_{m}\\in\\{0,1\\}} p(Z_{1},z_{2},\\dots,z_{m}).$$\nSince $p$ is multilinear (individual degree at most $1$ in each variable), $g_{1}$ is a univariate polynomial in $Z_{1}$ of degree at most $1$.\n\nIn the sum-check protocol, the Prover sends a claimed univariate polynomial $h_{1}(Z_{1})$ intended to equal $g_{1}(Z_{1})$. The Verifier checks the consistency of the claimed total by verifying\n$$h_{1}(0)+h_{1}(1)=1,$$\nand also enforces the known degree bound $\\deg(h_{1})\\le 1$. Next, to tie this round to the subsequent round via a random self-reduction, the Verifier samples a random field element\n$$r_{1}\\in\\mathbb{F}_{q}$$\nand sends $r_{1}$ to the Prover. In the next round, the Prover must produce\n$$g_{2}(Z_{2})=\\sum_{z_{3}\\in\\{0,1\\}}\\cdots\\sum_{z_{m}\\in\\{0,1\\}} p(r_{1},Z_{2},\\dots,z_{m}),$$\nand the Verifier will then check the consistency condition\n$$h_{1}(r_{1})=\\sum_{z_{2}\\in\\{0,1\\}} g_{2}(z_{2}).$$\n\nComparing to the options:\n- The Prover must send the univariate polynomial $g_{1}(Z_{1})$ (e.g., by its coefficients), not merely the two evaluations $g_{1}(0)$ and $g_{1}(1)$, since the Verifier needs to evaluate it at a random $r_{1}$ and enforce the degree bound. \n- The Verifier’s first message is a random element $r_{1}\\in\\mathbb{F}_{q}$.\n\nTherefore, the correct description is: Prover sends the polynomial $g_{1}(Z_{1})$ (by coefficients), and the Verifier responds with a random $r_{1}\\in\\mathbb{F}_{q}$, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1452382"}]}