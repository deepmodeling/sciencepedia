{"hands_on_practices": [{"introduction": "To navigate the landscape of interactive proofs, we must first master the basic vocabulary and structure of its foundational protocols. The Arthur-Merlin (AM) protocol is a cornerstone of this field, illustrating how a probabilistic verifier can leverage a powerful prover using public randomness. This first practice problem [@problem_id:1439640] challenges you to identify the correct sequence of operations in a simple two-message AM protocol, reinforcing the fundamental roles of Arthur, Merlin, and the public-coin mechanism.", "problem": "In the field of computational complexity theory, an interactive proof system involves a verifier, named Arthur, and a prover, named Merlin. Arthur is a probabilistic polynomial-time Turing machine, while Merlin possesses unbounded computational power but cannot be trusted. They engage in a protocol to determine if a given input string $x$ belongs to a language $L$.\n\nThe complexity class $\\mathrm{AM}[k]$ consists of all languages that have a $k$-message interactive proof system where Arthur makes the first move, and Arthur's random choices (coins) are \"public,\" meaning they are revealed to Merlin.\n\nConsider a language $L$ in the class $\\mathrm{AM}[2]$. Which of the following sequences of actions correctly describes the fundamental protocol for deciding if an input string $x$ is in $L$?\n\nA. Arthur receives input $x$, generates a random string $r$ of length polynomial in $|x|$, and sends $r$ to Merlin. Merlin computes and sends back a message $m$. Arthur then performs a deterministic polynomial-time computation on $(x, r, m)$ to decide whether to accept or reject.\n\nB. Arthur receives input $x$. Merlin, who also has access to $x$, computes a proof message $m$ and sends it to Arthur. Arthur then generates a random string $r$ and performs a deterministic polynomial-time computation on $(x, m, r)$ to decide whether to accept or reject.\n\nC. Arthur receives input $x$, generates a random string $r_1$, and sends it to Merlin. Merlin sends back a message $m$. Arthur then generates a second random string $r_2$ and sends it to Merlin, who provides a final response. Arthur then decides.\n\nD. Arthur receives input $x$. Merlin generates a string $r$ that he claims is random, along with a proof message $m$. Merlin sends the pair $(r, m)$ to Arthur. Arthur then performs a deterministic polynomial-time computation on $(x, r, m)$ to decide whether to accept or reject.\n\nE. Arthur receives input $x$, generates a random string $r$, and sends it to Merlin. Merlin computes and sends back a message $m$. Arthur then performs a probabilistic polynomial-time computation on $(x, r, m)$ using a new set of private random coins to decide whether to accept or reject.", "solution": "We recall the definition of an $\\mathrm{AM}[k]$ protocol: it is a public-coin interactive proof with $k$ messages where Arthur (a probabilistic polynomial-time verifier) moves first, and all of Arthur’s random choices are public, i.e., revealed to Merlin. For $\\mathrm{AM}[2]$ specifically, the canonical protocol consists of exactly two messages: Arthur sends a single public random challenge, and Merlin replies with a message; Arthur then decides based on a deterministic polynomial-time predicate of the input, the public randomness, and Merlin’s reply.\n\nWe analyze each option against this definition.\n\n1. In option A, Arthur on input $x$ generates a random string $r$ of length polynomial in $|x|$ and sends $r$ to Merlin. Merlin responds with a message $m$. Arthur then performs a deterministic polynomial-time computation on $(x, r, m)$ to accept or reject. This matches the standard $\\mathrm{AM}[2]$ model: two messages, Arthur moves first with public coins, and the final decision can be taken to be deterministic given the public coins since any additional public randomness could be folded into $r$ without changing the model.\n\n2. In option B, Merlin sends a proof $m$ first, then Arthur generates randomness $r$ and decides. This is the $\\mathrm{MA}$ pattern (Merlin first, Arthur second) with Arthur’s coins not necessarily public to Merlin at the time Merlin forms $m$. It does not fit $\\mathrm{AM}[2]$ because Arthur does not start.\n\n3. In option C, there are more than two messages: Arthur sends $r_{1}$, Merlin replies $m$, Arthur sends $r_{2}$, Merlin replies again, and then Arthur decides. This is not $\\mathrm{AM}[2]$ but a longer public-coin protocol (at least $\\mathrm{AM}[3]$).\n\n4. In option D, Merlin generates the “random” string $r$ and sends it with $m$ to Arthur. In a public-coin protocol, the randomness is generated by Arthur and made public; Merlin cannot be trusted to generate Arthur’s randomness. Hence this violates the model.\n\n5. In option E, Arthur sends a public random string $r$ to Merlin, Merlin replies $m$, and then Arthur uses a new set of private random coins to decide. This violates the public-coin condition because Arthur’s new coins are private. In the public-coin setting, any randomness used by Arthur must be public; moreover, even if Arthur used additional public randomness at the end, it can be folded into the initial $r$, making the final decision deterministic given $(x, r, m)$.\n\nTherefore, only option A correctly describes the fundamental $\\mathrm{AM}[2]$ protocol.", "answer": "$$\\boxed{A}$$", "id": "1439640"}, {"introduction": "Understanding a component's importance often comes from imagining its absence. In this exercise [@problem_id:1439656], we conduct a crucial thought experiment: what happens to the power of an Arthur-Merlin protocol if we strip Arthur of his randomness, making him completely deterministic? By exploring this question, you will connect the concept of interactive proofs back to the well-known class NP and gain a deeper appreciation for the essential role that public coins play in defining the AM complexity class.", "problem": "In computational complexity theory, interactive proof systems are abstract models that describe computations involving a verifier and a prover. The Arthur-Merlin (AM) protocol is a specific type of interactive proof system for a decision problem concerning a language $L$. It involves a probabilistic polynomial-time verifier, named Arthur, and an all-powerful, untrustworthy prover, named Merlin.\n\nFor an input string $x$ of length $n$, the standard AM protocol is defined as follows:\n1.  Arthur, the verifier, receives the input $x$. He generates a random string $r$ of length polynomial in $n$ and sends it to Merlin. This string is considered \"public\" as Merlin can see it.\n2.  Merlin, the prover, upon receiving $x$ and $r$, computes and sends a response string $y$, of length polynomial in $n$, back to Arthur.\n3.  Arthur then runs a deterministic polynomial-time algorithm, let's call its decision function $V(x, y, r)$, to either accept or reject the input $x$ based on the proof $y$ and his random string $r$.\n\nA language $L$ is in the complexity class AM if the following two conditions are met:\n- **Completeness:** For any string $x \\in L$, there exists a response $y$ from Merlin that makes Arthur accept with high probability. Formally: $\\forall x \\in L$, Merlin can choose a proof $y$ such that $\\Pr_{r}[V(x, y, r) = \\text{accept}] \\geq \\frac{2}{3}$.\n- **Soundness:** For any string $x \\notin L$, no matter what response $y$ Merlin provides, Arthur will accept with low probability. Formally: $\\forall x \\notin L$, for any proof $y$, $\\Pr_{r}[V(x, y, r) = \\text{accept}] \\leq \\frac{1}{3}$.\n\nNow, consider a modified version of this protocol where Arthur is stripped of his ability to use randomness. He becomes a purely deterministic polynomial-time verifier, meaning he does not generate or use any random string $r$. Which of the following well-known complexity classes is equivalent to the class of languages decidable by this modified, deterministic Arthur-Merlin protocol?\n\nA. P (Polynomial-Time)\nB. BPP (Bouned-error Probabilistic Polynomial-Time)\nC. NP (Nondeterministic Polynomial-Time)\nD. co-NP\nE. AM\nF. MA", "solution": "We restate the standard AM definition and then remove randomness to derive the resulting class.\n\nIn AM, the verifier uses a polynomial-length random string $r$ and a deterministic decision procedure $V(x,y,r)$. The completeness and soundness conditions are:\n$$\n\\forall x \\in L,\\ \\exists y \\text{ of length poly}(|x|):\\ \\Pr_{r}\\big[V(x,y,r)=\\text{accept}\\big] \\geq \\frac{2}{3},\n$$\n$$\n\\forall x \\notin L,\\ \\forall y \\text{ of length poly}(|x|):\\ \\Pr_{r}\\big[V(x,y,r)=\\text{accept}\\big] \\leq \\frac{1}{3}.\n$$\n\nNow remove Arthur’s randomness. This yields a deterministic polynomial-time verifier, so there is no $r$. Equivalently, let $r$ be the empty string $\\epsilon$, and define a deterministic decision predicate $V'(x,y) \\coloneqq V(x,y,\\epsilon)$. The probability over $r$ becomes trivial: for any fixed input and proof, the acceptance probability is either $0$ or $1$. Thus the two AM conditions collapse to:\n$$\n\\forall x \\in L,\\ \\exists y \\text{ of length poly}(|x|):\\ V'(x,y)=\\text{accept},\n$$\n$$\n\\forall x \\notin L,\\ \\forall y \\text{ of length poly}(|x|):\\ V'(x,y)=\\text{reject}.\n$$\n\nThese are exactly the verifier-based definition of $\\mathrm{NP}$: a language has a polynomial-length witness $y$ that a deterministic polynomial-time verifier accepts on yes-instances, and no such witness exists on no-instances.\n\nFormally, we show both inclusions.\n\n- Modified-AM $\\subseteq \\mathrm{NP}$: Given a language $L$ decided by the modified protocol with verifier $V'$, define the $\\mathrm{NP}$ verifier $W(x,y)=1$ iff $V'(x,y)=\\text{accept}$. By completeness there exists $y$ for $x \\in L$ making $W$ accept, and by soundness no $y$ makes $W$ accept for $x \\notin L$.\n\n- $\\mathrm{NP} \\subseteq$ Modified-AM: Given $L \\in \\mathrm{NP}$ with verifier $W(x,y)$ running in deterministic polynomial time, construct the modified protocol where Merlin sends $y$ and Arthur computes $V'(x,y) \\coloneqq W(x,y)$. Completeness and soundness follow directly from the definition of $\\mathrm{NP}$.\n\nHence the class obtained by removing verifier randomness from AM equals $\\mathrm{NP}$. Among the options, this is choice C.", "answer": "$$\\boxed{C}$$", "id": "1439656"}, {"introduction": "The distinction between public and private coins is central to the security and power of interactive proofs. This practice problem [@problem_id:1439683] presents a thought-provoking scenario that directly confronts this difference. By analyzing a flawed attempt to convert a private-coin system into a public one, you will uncover the critical security vulnerability that arises when a verifier's secret challenge is exposed, thereby solidifying your understanding of why the privacy of coins can be essential.", "problem": "In computational complexity theory, an Interactive Proof (IP) system involves a powerful Prover trying to convince a randomized Verifier about the truth of a statement. Consider a \"private-coin\" IP system for a language $L$. For a given input string $x$, the Verifier uses a private random string $r$, drawn uniformly from a set $\\mathcal{R}$ of $2^k$ possible strings, to conduct a dialogue with the Prover. At the end of the interaction, the Verifier decides whether to accept or reject.\n\nThis private-coin system is defined by two properties:\n1.  **Completeness:** If the input string $x$ is in the language $L$, there exists a strategy for an honest Prover that can always convince the Verifier to accept. The probability of acceptance is 1.\n2.  **Soundness:** If the input string $x$ is not in the language $L$, no Prover, regardless of its strategy, can convince the Verifier to accept with a probability greater than $s$, where $0 < s < 1$. The probability is taken over the Verifier's random choice of $r \\in \\mathcal{R}$.\n\nNow, consider a different, simpler proof system, which we will call a \"certificate-based\" system, $\\mathcal{P}_{cert}$. In this system, to prove that $x$ is in $L$, the Prover provides a single certificate to a deterministic Verifier. The proposed certificate is a pair $(r_{guess}, T)$, where $r_{guess}$ is a specific string from the set $\\mathcal{R}$, and $T$ is a full transcript of a conversation. The deterministic Verifier for $\\mathcal{P}_{cert}$ performs a single check: it verifies if the provided transcript $T$ represents an interaction that would cause the original private-coin Verifier to accept the input $x$, had its private random string been $r_{guess}$. If this check passes, the Verifier accepts; otherwise, it rejects.\n\nAssume that for a particular string $x_{false}$ which is not in $L$, the set of private random strings that would allow a malicious Prover to fool the original private-coin Verifier is non-empty. What is the probability that the Verifier in the certificate-based system $\\mathcal{P}_{cert}$ will accept the false statement \"$x_{false}$ is in $L$\" when presented with a certificate from an optimal, malicious Prover?\n\nA. $s$\nB. $s^k$\nC. $s/2^k$\nD. $1$\nE. $0$", "solution": "Let $\\mathcal{R}$ be the verifier’s randomness space with $|\\mathcal{R}|=2^{k}$. For $x_{false} \\notin L$, the soundness condition of the private-coin IP states that for any prover strategy, the acceptance probability over a uniformly random $r \\in \\mathcal{R}$ is at most $s$. Equivalently, there exists a set $S \\subseteq \\mathcal{R}$ of “accepting” random strings (those for which some interaction with a prover can lead the original verifier to accept) such that\n$$\n\\frac{|S|}{|\\mathcal{R}|} \\le s \\quad \\Longrightarrow \\quad |S| \\le s \\cdot 2^{k}.\n$$\nThe problem assumes $S \\neq \\emptyset$.\n\nIn the certificate-based system $\\mathcal{P}_{cert}$, the verifier is deterministic and performs a single check on a certificate $(r_{guess}, T)$. A malicious prover aiming to maximize acceptance can choose $r_{guess} \\in S$ (which exists by the assumption $S \\neq \\emptyset$) and provide a corresponding transcript $T$ that is accepting for the original verifier with randomness $r_{guess}$. The deterministic verifier then verifies that $T$ is a valid accepting transcript for $r_{guess}$ and accepts. There is no remaining randomness in this verification, so the acceptance is certain whenever such an $r_{guess}$ is used.\n\nTherefore, when presented with a certificate from an optimal, malicious prover under the assumption that $S \\neq \\emptyset$, the probability that the certificate-based verifier accepts the false statement is\n$$\n1.\n$$\nThis corresponds to option D.", "answer": "$$\\boxed{D}$$", "id": "1439683"}]}