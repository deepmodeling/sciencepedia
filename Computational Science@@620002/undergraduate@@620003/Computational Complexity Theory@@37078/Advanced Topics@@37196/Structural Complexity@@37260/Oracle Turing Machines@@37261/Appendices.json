{"hands_on_practices": [{"introduction": "Getting started with Oracle Turing Machines (OTMs) is best done through a concrete example. This first practice challenges you to think like an algorithm designer who has been given a magical black box. By using an oracle that instantly recognizes prime numbers, you will build an algorithm to solve a related problem—identifying semiprime numbers. This exercise ([@problem_id:1433319]) will help you develop the fundamental skill of breaking down a problem into steps that can be solved by a standard machine and steps that can be outsourced to an oracle.", "problem": "An oracle Turing machine (OTM) is a standard Turing machine equipped with a special \"oracle\" tape and three special states: `q_query`, `q_yes`, and `q_no`. Whenever the OTM enters `q_query`, the oracle instantaneously performs a computation. If the string currently on the oracle tape belongs to a predefined oracle language $L_{oracle}$, the machine transitions to state `q_yes`; otherwise, it transitions to `q_no`. This query-answer process is considered a single computational step.\n\nConsider an OTM, let's call it $M$, that has access to an oracle for the language `PRIME` = {$k \\mid k$ is a prime number, where $k$ is represented in binary}. The goal of machine $M$ is to decide the language `SEMIPRIME` = {$n \\mid n$ is a semiprime number, where $n$ is represented in binary}. A semiprime is a natural number that is the product of two prime numbers (the two primes are not necessarily distinct).\n\nWhich of the following descriptions accurately represents the high-level algorithm that machine $M$ should implement to correctly decide `SEMIPRIME` for any given integer input $n > 1$?\n\nA. Iterate through all integers $i$ from 2 to $n-1$. For each $i$, query the `PRIME` oracle on $i$. If the oracle accepts, check if $i$ divides $n$. If it does, halt and accept. If the loop completes without finding such an $i$, halt and reject.\n\nB. Query the `PRIME` oracle on the input $n$. If the oracle accepts, halt and reject. Otherwise, iterate through all integers $i$ from 2 to $\\lfloor \\sqrt{n} \\rfloor$. For each $i$, if $i$ divides $n$, query the `PRIME` oracle on $i$. If the oracle accepts, halt and accept. If the loop completes with no such factor found, halt and reject.\n\nC. Iterate through all integers $i$ from 2 to $\\lfloor \\sqrt{n} \\rfloor$. For each $i$, check if $i$ divides $n$. If it does, let $j = n/i$. Then, query the `PRIME` oracle on $i$ and query the `PRIME` oracle on $j$. If both queries are accepted, halt and accept. If the loop completes without finding such a pair $(i, j)$, halt and reject.\n\nD. Query the `PRIME` oracle on the input $n$. If the oracle accepts, halt and reject. Otherwise, halt and accept.\n\nE. Iterate through all integers $i$ from 2 to $\\lfloor \\sqrt{n} \\rfloor$. For each $i$, query the `PRIME` oracle on $i$. If the oracle accepts, check if $n$ is divisible by $i$ but not by $i^2$. If so, let $j=n/i$ and query the `PRIME` oracle on $j$. If this second query accepts, halt and accept. If the loop completes, reject.", "solution": "We must decide the language SEMIPRIME on input $n>1$ using an oracle for PRIME. By definition, $n$ is semiprime if and only if there exist primes $p$ and $q$ such that $n=pq$, allowing $p=q$. Let $p \\leq q$; then $p \\leq \\sqrt{n}$, since if $p>\\sqrt{n}$, then $pq > \\sqrt{n}\\cdot \\sqrt{n} = n$, a contradiction. Hence, $n$ is semiprime if and only if there exists an integer $i$ with $2 \\leq i \\leq \\lfloor \\sqrt{n} \\rfloor$, $i \\mid n$, and both $i$ and $j = n/i$ are prime.\n\nUsing a PRIME oracle, the correct high-level algorithm must therefore:\n- Iterate $i$ from $2$ to $\\lfloor \\sqrt{n} \\rfloor$.\n- For each $i$, test divisibility $i \\mid n$. If true, set $j=n/i$.\n- Query the oracle on $i$ and on $j$; accept if and only if both are prime.\n- If no such pair is found, reject.\n\nThis matches option C exactly. The other options are incorrect:\n- A accepts any $n$ having a prime divisor, e.g., $n=12$, where $i=2$ is prime and divides $n$, but $12$ is not semiprime.\n- B accepts composites with at least one small prime factor, e.g., $n=8$ with $i=2$, but $8$ is not semiprime.\n- D accepts all composites and thus misclassifies non-semiprime composites and prime squares.\n- E incorrectly excludes prime squares by requiring $i^{2} \\nmid n$, so it rejects $n=9$ where $n=3\\cdot 3$ is semiprime.\n\nTherefore, only option C correctly decides SEMIPRIME using the PRIME oracle.", "answer": "$$\\boxed{C}$$", "id": "1433319"}, {"introduction": "Oracles for decision problems, which give a simple 'yes' or 'no' answer, are surprisingly powerful. This practice demonstrates how a decision oracle for the famous Boolean Satisfiability ($SAT$) problem can be used to solve a much more complex search problem: finding a minimal set of contradictory statements within a logical formula. By carefully tracing the `ReduceCore` algorithm ([@problem_id:1433316]), you will learn a powerful technique for leveraging decision oracles to find specific solutions, a cornerstone of many advanced algorithms in computer science.", "problem": "In computational complexity theory, an oracle Turing machine is an abstract machine used to study decision problems. It can be thought of as a standard Turing machine with a \"black box,\" called an oracle, that is able to decide certain problems in a single operation. For this problem, we consider an oracle for the Boolean Satisfiability (SAT) problem. This oracle, denoted $\\mathcal{O}_{SAT}$, takes any Boolean formula in Conjunctive Normal Form (CNF) as input and returns `TRUE` if the formula is satisfiable, and `FALSE` otherwise.\n\nA CNF formula is a conjunction (AND) of one or more clauses, where each clause is a disjunction (OR) of literals (a variable or its negation). An unsatisfiable CNF formula $\\phi$ may contain a smaller subset of its clauses that is itself unsatisfiable. Such a subset is called an unsatisfiable core. A minimal unsatisfiable core is an unsatisfiable core with the property that if any single clause is removed from it, the remaining set of clauses becomes satisfiable.\n\nConsider the following algorithm, `ReduceCore`, which is designed to find a minimal unsatisfiable core of a given unsatisfiable CNF formula $\\phi = \\{C_1, C_2, \\ldots, C_m\\}$. The algorithm relies on the $\\mathcal{O}_{SAT}$ oracle.\n\n**Algorithm: `ReduceCore`**\n1. Initialize a working set of clauses, $S$, to be a copy of the input formula $\\phi$.\n2. Iterate through the clauses of the original formula $\\phi$, $C_1, C_2, \\ldots, C_m$, in their given indexed order.\n3. For each clause $C_i$ from the original formula, form a test set $S_{\\text{test}} = S \\setminus \\{C_i\\}$. Note that $S$ may have been modified by previous steps. The test is to see if $C_i$ is currently in $S$ and if it can be removed.\n4. If $C_i$ is in $S$, query the oracle with $S_{\\text{test}}$. If $\\mathcal{O}_{SAT}(S_{\\text{test}})$ returns `FALSE` (meaning the set is still unsatisfiable without $C_i$), then permanently remove $C_i$ from the working set $S$.\n5. After the iteration is complete, the algorithm returns the final working set $S$.\n\nYou are given the following unsatisfiable CNF formula $\\Phi$ over the variables $\\{a, b, c, d, e\\}$. The formula consists of 9 clauses, indexed as follows:\n- $C_1: (a \\lor b)$\n- $C_2: (a \\lor \\neg b)$\n- $C_3: (\\neg a \\lor c)$\n- $C_4: (\\neg a \\lor \\neg c)$\n- $C_5: (a \\lor d)$\n- $C_6: (\\neg a \\lor \\neg d)$\n- $C_7: (a \\lor c \\lor d)$\n- $C_8: (b \\lor c)$\n- $C_9: (\\neg b \\lor \\neg c \\lor e)$\n\nWhat is the number of clauses in the final set returned by the `ReduceCore` algorithm when executed on the input formula $\\Phi$?", "solution": "Initialize $S=\\{C_{1},\\ldots,C_{9}\\}$. The algorithm inspects $C_{1},\\ldots,C_{9}$ in order. For each $C_{i}$ still in $S$, it queries $\\mathcal{O}_{SAT}(S\\setminus\\{C_{i}\\})$ and removes $C_{i}$ if and only if the oracle returns FALSE (i.e., the reduced set is still unsatisfiable).\n\nTest $C_{1}$: Consider $S\\setminus\\{C_{1}\\}=\\{C_{2},\\ldots,C_{9}\\}$. The clauses $C_{3}:(\\neg a\\lor c)$ and $C_{4}:(\\neg a\\lor \\neg c)$ together forbid $a=\\text{true}$, so one may set $a=\\text{false}$. Then $C_{2}$ becomes $\\neg b$ so set $b=\\text{false}$; $C_{5}$ becomes $d$ so set $d=\\text{true}$; $C_{6}$ is satisfied by $\\neg a$; $C_{7}$ is satisfied by $c\\lor d$ (since $d=\\text{true}$); $C_{8}$ is satisfied by $b\\lor c$ (choose $c=\\text{true}$); $C_{9}$ is satisfied by $\\neg b$. Hence $S\\setminus\\{C_{1}\\}$ is satisfiable, so $\\mathcal{O}_{SAT}$ returns TRUE and $C_{1}$ is kept.\n\nTest $C_{2}$: Consider $S\\setminus\\{C_{2}\\}$. Again $a=\\text{false}$ from $C_{3}$ and $C_{4}$. Then $C_{1}$ becomes $b$ so set $b=\\text{true}$; $C_{5}$ becomes $d$ so set $d=\\text{true}$; $C_{6}$ is satisfied by $\\neg a$; $C_{7}$ is satisfied by $c\\lor d$; $C_{8}$ is satisfied by $b$; $C_{9}$ requires $\\neg c\\lor e$ when $b=\\text{true}$, so choose, for example, $e=\\text{true}$. Thus $S\\setminus\\{C_{2}\\}$ is satisfiable; the oracle returns TRUE and $C_{2}$ is kept.\n\nTest $C_{3}$: Consider $S\\setminus\\{C_{3}\\}=\\{C_{1},C_{2},C_{4},C_{5},C_{6},C_{7},C_{8},C_{9}\\}$. Set $a=\\text{true}$ and $c=\\text{false}$; then $C_{4}$ is satisfied by $\\neg c$, $C_{6}$ becomes $\\neg d$ so set $d=\\text{false}$, and $C_{1},C_{2},C_{5},C_{7}$ are satisfied by $a$. Set $b=\\text{true}$ so $C_{8}$ is satisfied; $C_{9}$ is satisfied by $\\neg c$. Hence satisfiable; the oracle returns TRUE and $C_{3}$ is kept.\n\nTest $C_{4}$: Consider $S\\setminus\\{C_{4}\\}$. Set $a=\\text{true}$ and $c=\\text{true}$; then $C_{3}$ is satisfied by $c$, $C_{6}$ becomes $\\neg d$ so set $d=\\text{false}$, and $C_{1},C_{2},C_{5},C_{7}$ are satisfied by $a$. Set, for instance, $e=\\text{true}$ so that $C_{9}$ is satisfied; $C_{8}$ is satisfied by $c$. Hence satisfiable; the oracle returns TRUE and $C_{4}$ is kept.\n\nTest $C_{5}$: Consider $S\\setminus\\{C_{5}\\}$. The pair $C_{3}$ and $C_{4}$ forbid $a=\\text{true}$, so $a=\\text{false}$. Then $C_{1}$ becomes $b$ and $C_{2}$ becomes $\\neg b$, which is a contradiction. Therefore $S\\setminus\\{C_{5}\\}$ is unsatisfiable; the oracle returns FALSE and $C_{5}$ is removed, so $S:=S\\setminus\\{C_{5}\\}$.\n\nTest $C_{6}$: Now consider $S\\setminus\\{C_{6}\\}$ with current $S$ not containing $C_{5}$. The same reasoning applies: $C_{3}$ and $C_{4}$ force $a=\\text{false}$, yielding $b$ and $\\neg b$ from $C_{1}$ and $C_{2}$, so unsatisfiable. The oracle returns FALSE and $C_{6}$ is removed.\n\nTest $C_{7}$: With $C_{5}$ and $C_{6}$ already removed, consider $S\\setminus\\{C_{7}\\}$. Again $C_{3}$ and $C_{4}$ force $a=\\text{false}$, producing $b$ and $\\neg b$ from $C_{1}$ and $C_{2}$, so unsatisfiable. The oracle returns FALSE and $C_{7}$ is removed.\n\nTest $C_{8}$: Consider $S\\setminus\\{C_{8}\\}$. As before, $C_{3}$ and $C_{4}$ force $a=\\text{false}$, so $C_{1}$ and $C_{2}$ contradict on $b$. Thus unsatisfiable; the oracle returns FALSE and $C_{8}$ is removed.\n\nTest $C_{9}$: Consider $S\\setminus\\{C_{9}\\}=\\{C_{1},C_{2},C_{3},C_{4}\\}$. With $C_{3}$ and $C_{4}$ forcing $a=\\text{false}$, $C_{1}$ becomes $b$ and $C_{2}$ becomes $\\neg b$, yielding a contradiction. Thus unsatisfiable; the oracle returns FALSE and $C_{9}$ is removed.\n\nAfter completing the iteration, the final set is $S=\\{C_{1},C_{2},C_{3},C_{4}\\}$, which has $4$ clauses and is inclusion-wise minimal unsatisfiable (removing any one of these four yields a satisfiable set).", "answer": "$$\\boxed{4}$$", "id": "1433316"}, {"introduction": "Oracle machines are not just tools for solving problems; they are theoretical lenses for exploring the very limits of computation. This final exercise ([@problem_id:1433334]) takes you into the realm of undecidability, where you will use oracles to compare problems that no ordinary computer can solve. You will construct a strict hierarchy between two undecidable languages, proving that one is demonstrably 'harder' than the other and introducing you to the profound concept of the Turing jump and relativized computation.", "problem": "In computability theory, an Oracle Turing Machine (OTM) is a variant of a standard Turing Machine (TM) that is augmented with a black-box component known as an \"oracle\". An OTM $M^L$ with an oracle for a language $L$ can, in a single computational step, determine whether any given string $s$ is a member of $L$. We say a language $A$ is Turing reducible to a language $B$, denoted $A \\le_T B$, if there exists an OTM with an oracle for $B$ that decides language $A$. If the OTM runs in polynomial time, we say $A$ is polynomial-time Turing reducible to $B$, denoted $A \\le_P^B$.\n\nThis concept allows us to compare the relative difficulty of undecidable problems. This problem asks you to identify a pair of languages that demonstrates a strict hierarchy in undecidability.\n\nLet the following languages be defined over the alphabet $\\{0,1\\}$:\n- **The Halting Problem ($H$)**: $H = \\{ \\langle M, w \\rangle \\mid M \\text{ is a TM that halts on input } w \\}$.\n- **The Relativized Halting Problem ($H^L$)**: For a given oracle language $L$, $H^L = \\{ \\langle M^L, w \\rangle \\mid M^L \\text{ is an OTM with oracle } L \\text{ that halts on input } w \\}$. Note that an ordinary TM can be considered a special case of an OTM that simply never queries its oracle.\n\nYour task is to identify the pair of languages $(A, B)$ from the options below that satisfies all four of the following conditions simultaneously:\n1. Language $A$ is undecidable.\n2. Language $B$ is undecidable.\n3. Language $A$ is decidable in polynomial time by a Turing machine with an oracle for language $B$ (i.e., $A \\le_P^B$).\n4. Language $B$ is **not** decidable by any Turing machine with an oracle for language $A$ (i.e., $B \\not\\le_T A$).\n\nWhich of the following pairs $(A, B)$ satisfies all four conditions?\n\nA. $A = H$ and $B = H^H$\nB. $A = H^H$ and $B = H$\nC. $A = H$ and $B = \\overline{H}$ (where $\\overline{H}$ is the complement of $H$)\nD. $A = \\{1^n \\mid n \\text{ is a prime number}\\}$ and $B = H$\nE. $A = H$ and $B = H$", "solution": "We analyze each option against the four required conditions, using standard facts about Turing reducibility, oracle machines, and the Turing jump.\n\nKey principles:\n- $H$ is undecidable.\n- For any language $L$, its relativized halting problem $H^{L}$ (the Turing jump $L'$) satisfies $L' \\not\\le_{T} L$ and $L \\le_{T} L'$. In particular, $H^{H} \\not\\le_{T} H$ and $H \\le_{T} H^{H}$. Moreover, $H^{L}$ is undecidable for every $L$.\n- If a language $C$ is decidable, then $C \\le_{T} D$ for every $D$ (the oracle can be ignored).\n- $H$ and its complement $\\overline{H}$ are Turing-equivalent: $H \\equiv_{T} \\overline{H}$.\n\nOption A: $A = H$, $B = H^{H}$.\n1. $A$ is undecidable: true.\n2. $B$ is undecidable: true, since $H^{H}$ is the jump of $H$, hence undecidable (if $H^{H}$ were decidable, then $H^{H} \\le_{T} H$ would hold vacuously by ignoring the oracle, contradicting $H^{H} \\not\\le_{T} H$).\n3. $A \\le_{P}^{B}$: construct a polynomial-time oracle TM with oracle $H^{H}$ that decides $H$. On input $\\langle M, w \\rangle$, build in polynomial time the description of an OTM $\\widetilde{M}^{H}$ that ignores its oracle and simulates $M$ on its input. Query the $H^{H}$-oracle on the instance $\\langle \\widetilde{M}^{H}, w \\rangle$. The oracle answers “yes” if and only if $M$ halts on $w$. This uses one oracle query and polynomial-time pre/post-processing, so $H \\le_{P}^{H^{H}}$.\n4. $B \\not\\le_{T} A$: by the jump theorem, $H^{H} \\not\\le_{T} H$.\n\nThus A satisfies all four conditions.\n\nFor completeness, the other options fail at least one condition:\n- B: $A = H^{H}$, $B = H$. This fails condition 3 since $H^{H} \\not\\le_{T} H$.\n- C: $A = H$, $B = \\overline{H}$. Both are undecidable and $H \\le_{P}^{\\overline{H}}$, but also $\\overline{H} \\le_{T} H$, so condition 4 fails.\n- D: $A = \\{1^{n} \\mid n \\text{ is prime}\\}$ is decidable (indeed in polynomial time), so condition 1 fails.\n- E: $A = H$, $B = H$ makes condition 4 false since $B \\le_{T} A$ trivially.\n\nTherefore, the correct choice is A.", "answer": "$$\\boxed{A}$$", "id": "1433334"}]}