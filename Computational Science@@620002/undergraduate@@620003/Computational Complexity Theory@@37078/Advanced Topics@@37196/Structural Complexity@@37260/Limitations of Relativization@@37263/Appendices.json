{"hands_on_practices": [{"introduction": "The concept of relativization is best understood by actively constructing oracles. This first exercise introduces diagonalization, a foundational technique for building an oracle that separates two complexity classes. By dissecting a hypothetical class, $\\mathrm{LOGQ}^A$, which is limited to a logarithmic number of oracle queries, you will strategize how to construct an oracle $A$ that systematically defeats every machine in this class, proving that $\\mathrm{P}^A \\neq \\mathrm{LOGQ}^A$ [@problem_id:1430207]. This practice reveals the core adversarial logic of these proofs, which exploit the specific resource limitations of a computational model.", "problem": "In computational complexity theory, an oracle Turing machine is a theoretical model of computation used to study the limits of proof techniques. It is an abstract machine with access to an \"oracle,\" which can solve a specific decision problem in a single step. For a given oracle language $A$ (a set of binary strings), $\\mathrm{P}^A$ denotes the class of decision problems solvable by a deterministic Turing machine in polynomial time with access to the oracle $A$.\n\nLet's define a new complexity class. We define $\\mathrm{LOGQ}^A$ as the class of languages decidable by a deterministic polynomial-time oracle Turing machine that, for any input of length $n$, is restricted to making at most $O(\\log n)$ queries to the oracle $A$. By definition, any language in $\\mathrm{LOGQ}^A$ is also in $\\mathrm{P}^A$, so $\\mathrm{LOGQ}^A \\subseteq \\mathrm{P}^A$.\n\nYour task is to explore whether this inclusion is strict. Consider the specific language $L_A$ defined as:\n$$L_A = \\{1^n \\mid A \\text{ contains at least one string of length } \\lfloor \\log_2 n \\rfloor \\}$$\nHere, $1^n$ represents a string of $n$ ones. A deterministic polynomial-time machine can decide if $1^n \\in L_A$ by querying the oracle for all possible strings of length $k = \\lfloor \\log_2 n \\rfloor$. The number of such strings is $2^k \\approx n$, which is a polynomial number of queries. Therefore, we know that for any oracle $A$, the language $L_A$ is in $\\mathrm{P}^A$.\n\nTo show that $\\mathrm{P}^A \\neq \\mathrm{LOGQ}^A$, one must construct an oracle $A$ for which $L_A \\notin \\mathrm{LOGQ}^A$. This is typically done using a diagonalization argument. Which of the following statements best describes the high-level strategy for constructing such an oracle $A$?\n\nA. Systematically go through an enumeration of all possible $LOGQ$ machines, $M_1, M_2, \\dots$. For each machine $M_i$, find a large input $1^{n_i}$ and simulate $M_i$ on it. Use the fact that $M_i$ can query only a logarithmic number of strings of the relevant length to ensure its final answer for \"Is $1^{n_i} \\in L_A$?\" is wrong, by carefully adding or not adding an un-queried string to $A$.\n\nB. Construct the oracle $A$ to be a language that is complete for a very large complexity class, such as PSPACE. The inherent computational difficulty of the oracle language itself will be too great for a machine with only a logarithmic number of queries to handle, thus separating the classes.\n\nC. Construct a \"random\" oracle $A$ where each string is included with a probability of 1/2. With high probability, any given $LOGQ$ machine will fail to decide $L_A$ because the information it can gather through a logarithmic number of queries is insufficient to determine if one of the polynomially many relevant strings is in the random oracle.\n\nD. Define the oracle $A$ to be identical to the target language $L_A$. A machine in $\\mathrm{P}^A$ could then decide membership in $L_A$ for an input $1^n$ with a single query, which a $\\mathrm{LOGQ}^A$ machine cannot for all languages.\n\nE. For each $LOGQ$ machine $M_i$, find an input $1^{n_i}$ that causes the machine's runtime to exceed its polynomial bound. The oracle $A$ would be constructed to contain information about specific inputs that cause this long runtime, which a $\\mathrm{P}^A$ machine could then use.", "solution": "We restate the setting. For a fixed oracle language $A \\subseteq \\{0,1\\}^{*}$, $P^{A}$ is the class of languages decidable by a deterministic polynomial-time oracle Turing machine with unrestricted polynomially many queries to $A$. The subclass $LOGQ^{A}$ consists of those decided with at most $O(\\log n)$ oracle queries on inputs of length $n$. The language\n$$\nL_{A}=\\{1^{n} \\mid \\text{$A$ contains at least one string of length } k=\\lfloor \\log_{2} n \\rfloor\\}\n$$\nis in $P^{A}$ for every $A$, because deciding $1^{n} \\in L_{A}$ can be done by querying all strings $x \\in \\{0,1\\}^{k}$: there are $2^{k}$ such strings, and since $k=\\lfloor \\log_{2} n \\rfloor$, we have $2^{k} \\leq n$, which is polynomial in $n$.\n\nTo separate $P^{A}$ from $LOGQ^{A}$, we need an oracle $A$ such that $L_{A} \\notin LOGQ^{A}$. The standard high-level strategy is diagonalization against all $LOGQ$ machines:\n1) Enumerate all deterministic polynomial-time oracle machines that on inputs of length $n$ make at most $c \\log n$ queries for some fixed constant $c$, denoted $(M_{1},M_{2},\\dots)$.\n2) For stage $i$, pick an $n_{i}$ so large that the associated $k_{i}=\\lfloor \\log_{2} n_{i} \\rfloor$ is strictly larger than all previously used lengths, ensuring that decisions about strings of length $k_{i}$ will not interfere with earlier stages.\n3) Simulate $M_{i}$ on input $1^{n_{i}}$, answering adaptively all its at most $q_{i} \\leq c \\log n_{i}$ oracle queries. While simulating, ensure that any query of length $k_{i}$ is answered consistently in a way that leaves many strings of length $k_{i}$ unqueried and undecided; since there are $2^{k_{i}} \\geq n_{i}$ possible strings and only $q_{i}=O(\\log n_{i})$ queries, the set of unqueried strings of length $k_{i}$ is nonempty and, in fact, overwhelmingly large.\n4) After $M_{i}$ halts and outputs a decision for whether $1^{n_{i}} \\in L_{A}$, fix the membership of strings of length $k_{i}$ in $A$ to force the opposite truth value. Concretely:\n- If $M_{i}$ outputs that $1^{n_{i}} \\notin L_{A}$, add one unqueried string of length $k_{i}$ to $A$, making the correct answer “yes.”\n- If $M_{i}$ outputs that $1^{n_{i}} \\in L_{A}$, ensure that no string of length $k_{i}$ is in $A$, making the correct answer “no.”\n5) Because later stages operate only on strictly larger lengths, they cannot change the truth of $L_{A}$ on $1^{n_{i}}$. Thus each $M_{i}$ is wrong on its designated input, and no $LOGQ^{A}$ machine decides $L_{A}$.\n\nThis strategy crucially exploits the information-theoretic gap: for inputs of length $n$, deciding whether “there exists some string of length $k=\\lfloor \\log_{2} n \\rfloor$ in $A$” depends on $2^{k}$ bits of oracle information, while a $LOGQ^{A}$ machine can only read $O(\\log n)$ of them; we can always adversarially set at least one unqueried string to flip the truth of the existential predicate. Ensuring disjoint lengths across stages guarantees global consistency.\n\nEvaluating the options:\n- A precisely describes this diagonalization: enumerate $LOGQ$ machines, pick large inputs, simulate with at most $O(\\log n)$ queries exposed, and then set an unqueried string’s membership to force an error.\n- B is irrelevant: making $A$ complete for a large class like PSPACE does not, by itself, separate $P^{A}$ from $LOGQ^{A}$ on this particular language; the obstacle is query scarcity, not inherent hardness of $A$.\n- C appeals to a random-oracle heuristic, but “with high probability” is insufficient to guarantee that no $LOGQ$ machine decides $L_{A}$ for all inputs; the proof requires an adversarial, stagewise construction guaranteeing failure for each machine on some input, not a probabilistic statement about typical behavior.\n- D is circular or ill-defined, since $L_{A}$ depends on $A$; setting $A=L_{A}$ does not yield a coherent or generally separating construction.\n- E is off-target: time bounds are already polynomial; the separation hinges on limiting the number of oracle queries, not causing super-polynomial runtime.\n\nTherefore, the correct high-level strategy is described by option A.", "answer": "$$\\boxed{A}$$", "id": "1430207"}, {"introduction": "After separating classes, we now explore the opposite phenomenon: oracle-induced collapse. The famous Baker-Gill-Solovay theorem established that oracles exist for which $\\mathrm{P}^A = \\mathrm{NP}^A$, demonstrating the two-sided nature of the relativization barrier. This practice challenges you to identify which types of powerful oracles, such as those complete for large complexity classes like $PSPACE$ or $EXPTIME$, cause this collapse [@problem_id:1430179]. Mastering this concept is essential for a full appreciation of why relativizing proof techniques are insufficient to resolve the $P$ versus $NP$ problem.", "problem": "The Baker-Gill-Solovay theorem is a foundational result in computational complexity theory that demonstrates the limitations of relativizing proof techniques. It shows that there exist oracles $A$ and $B$ such that $\\mathrm{P}^A = \\mathrm{NP}^A$ and $\\mathrm{P}^B \\neq \\mathrm{NP}^B$. This implies that any proof technique that is indifferent to the presence of an oracle (i.e., it \"relativizes\") cannot resolve the P versus NP problem.\n\nYour task is to explore the construction of an oracle that forces the collapse of the polynomial hierarchy at its first level. An oracle Turing machine is a standard Turing machine equipped with a special query tape and a query state. When the machine enters the query state, the string $q$ on its query tape is checked for membership in a fixed oracle language $A$. This query is considered to take a single computational step. We define $\\mathrm{P}^A$ as the class of languages decidable by a polynomial-time deterministic oracle Turing machine using oracle $A$, and $\\mathrm{NP}^A$ as the class of languages decidable by a polynomial-time non-deterministic oracle Turing machine using oracle $A$.\n\nSelect all of the following languages which, if used as an oracle $A$, would cause the relativized complexity classes $\\mathrm{P}^A$ and $\\mathrm{NP}^A$ to be equal. You may assume that all languages listed are decidable in exponential time (EXPTIME) and that their respective completeness properties hold under polynomial-time reductions.\n\nA. SAT: The language of all satisfiable Boolean formulas. This language is NP-complete.\nB. TQBF: The language of all true quantified Boolean formulas. This language is PSPACE-complete.\nC. PATH: The language of all tuples $\\langle G, s, t \\rangle$ where $G$ is a directed graph containing a path from vertex $s$ to vertex $t$. This language is P-complete.\nD. ALL_NFA: The language of all Non-deterministic Finite Automata (NFAs) $\\langle M \\rangle$ that accept every string over their input alphabet (i.e., $L(M) = \\Sigma^*$). This language is PSPACE-complete.\nE. An EXPTIME-complete language: Any language that is complete for the complexity class EXPTIME.", "solution": "We are asked to determine, for each proposed oracle language, whether using it as an oracle $A$ forces $P^{A} = NP^{A}$, i.e., collapses the relativized polynomial hierarchy at its first level. We use standard definitions: $P^{A}$ is deterministic polynomial time with oracle $A$, and $NP^{A}$ is nondeterministic polynomial time with oracle $A$. We rely on completeness under polynomial-time many-one reductions (as stated), and on standard closure properties.\n\nGeneral principles used:\n1) If $A$ is complete for a class $\\mathcal{C}$ under polynomial-time many-one reductions, then for every $L \\in \\mathcal{C}$ there is a polynomial-time computable reduction $f$ with $x \\in L$ iff $f(x) \\in A$. Hence $L \\in P^{A}$, so $\\mathcal{C} \\subseteq P^{A}$.\n2) If $A \\in \\mathcal{C}$ and $\\mathcal{C}$ is closed under polynomial-time Turing reductions, then $P^{A} \\subseteq \\mathcal{C}$ because a $P^{A}$ computation can be simulated by a $\\mathcal{C}$-machine answering each oracle query within $\\mathcal{C}$ and composing polynomially many such calls.\n3) For nondeterminism with a $\\mathcal{C}$-oracle where $\\mathcal{C}$ is at least PSPACE or EXPTIME, we use that $NPSPACE = PSPACE$ (Savitch) and that EXPTIME is closed under polynomial-time Turing reductions and can brute-force polynomially many nondeterministic branches without exceeding exponential time. Thus $NP^{A} \\subseteq \\mathcal{C}$ whenever $A \\in \\mathcal{C}$ with the stated closure.\n\nWe analyze each option.\n\nA. $A = SAT$ (NP-complete).\nBecause $SAT$ is NP-complete, $P^{SAT} = P^{NP} = \\Delta_{2}^{P}$ and $NP^{SAT} = NP^{NP} = \\Sigma_{2}^{P}$. It is not known whether $\\Delta_{2}^{P} = \\Sigma_{2}^{P}$. Therefore, using $SAT$ as the oracle does not provably cause $P^{A} = NP^{A}$, and we cannot select this option.\n\nB. $A = TQBF$ (PSPACE-complete).\nFirst, by completeness, for any $L \\in PSPACE$ there is a polynomial-time many-one reduction $f$ to $TQBF$, so $PSPACE \\subseteq P^{A}$. Next, since $A \\in PSPACE$ and $PSPACE$ is closed under polynomial-time Turing reductions, any $P^{A}$ computation can be simulated in $PSPACE$, so $P^{A} \\subseteq PSPACE$. Hence\n$$\nP^{A} = PSPACE.\n$$\nMoreover, $P^{A} \\subseteq NP^{A}$ implies $PSPACE \\subseteq NP^{A}$. For the reverse inclusion, simulate an $NP^{A}$ machine in polynomial space by depth-first traversal of its polynomial-depth computation tree while answering each oracle query to $A \\in PSPACE$ in polynomial space. Thus $NP^{A} \\subseteq PSPACE$. Therefore\n$$\nNP^{A} = PSPACE,\n$$\nand consequently $P^{A} = NP^{A}$.\n\nC. $A = PATH$ (P-complete).\nSince $A \\in P$, any $P^{A}$ machine’s oracle queries can be simulated in polynomial time, yielding $P^{A} = P$. Similarly, $NP^{A} = NP$. Therefore $P^{A} = NP^{A}$ would imply $P = NP$, which is unknown. Hence this oracle does not provably cause $P^{A} = NP^{A}$, so we do not select this option.\n\nD. $A = ALL\\_NFA$ (PSPACE-complete).\nExactly the same argument as for $TQBF$ applies. By completeness and closure, we obtain $P^{A} = PSPACE$ and $NP^{A} = PSPACE$, hence $P^{A} = NP^{A}$.\n\nE. $A$ is EXPTIME-complete.\nBy completeness, for any $L \\in EXPTIME$ there is a polynomial-time many-one reduction $f$ to $A$, so $EXPTIME \\subseteq P^{A}$. Conversely, simulate any $P^{A}$ computation deterministically: each of its polynomially many oracle queries to $A$ can be answered in exponential time on inputs of polynomial length, and the total time remains exponential, so $P^{A} \\subseteq EXPTIME$. Hence\n$$\nP^{A} = EXPTIME.\n$$\nFor $NP^{A}$, nondeterministic polynomial time with an $EXPTIME$ oracle can be simulated deterministically in exponential time by enumerating at most $\\exp(p(n))$ branches, each incurring at most $\\exp(p(n))$ time due to the oracle calls and polynomial work, keeping the total within $\\exp(q(n))$. Therefore $NP^{A} \\subseteq EXPTIME$, and since $P^{A} = EXPTIME \\subseteq NP^{A}$, we conclude\n$$\nNP^{A} = EXPTIME.\n$$\nThus $P^{A} = NP^{A}$.\n\nConclusion:\n- B and D (both PSPACE-complete oracles) yield $P^{A} = NP^{A} = PSPACE$.\n- E (EXPTIME-complete oracle) yields $P^{A} = NP^{A} = EXPTIME$.\n- A and C do not provably yield $P^{A} = NP^{A}$ under current knowledge.\n\nTherefore, the correct selections are B, D, and E.", "answer": "$$\\boxed{BDE}$$", "id": "1430179"}, {"introduction": "The power of diagonalization extends far beyond simple cases; it can be used to construct oracles that create an infinitely rich computational landscape. This exercise advances our study of separation by tackling the construction of an oracle $A$ that forces the Polynomial Hierarchy (PH) to be infinite, meaning $\\Sigma_k^{\\mathrm{P},A} \\neq \\Sigma_{k+1}^{\\mathrm{P},A}$ for all $k \\ge 0$. Your task is to pinpoint the crucial decision within this multi-stage diagonalization that ensures a machine from one level of the hierarchy is defeated by a language from the level above [@problem_id:1430202].", "problem": "In computational complexity theory, the relativization technique is used to explore the relationships between complexity classes by providing all computational models with access to an oracle—a helper function that can answer specific queries in a single step. The famous Baker-Gill-Solovay theorem demonstrates that there exist oracles $A$ and $B$ such that $\\mathrm{P}^A = \\mathrm{NP}^A$ and $\\mathrm{P}^B \\neq \\mathrm{NP}^B$. This implies that proof techniques that relativize (i.e., work regardless of the oracle) are insufficient to resolve the P versus NP problem.\n\nYour task is to analyze a key step in a similar but more general construction: building an oracle $A$ that forces the Polynomial Hierarchy (PH) to be infinite. An infinite PH means that for every integer $k \\ge 0$, the complexity class $\\Sigma_k^{\\mathrm{P},A}$ is strictly contained in $\\Sigma_{k+1}^{\\mathrm{P},A}$.\n\nThe construction of oracle $A$ proceeds in stages. At each stage, we aim to ensure that a language from a higher level of the hierarchy cannot be decided by any machine from a lower level. Let's focus on a single generic stage of this diagonalization argument.\n\n**Scenario:**\n\nLet $A_{current}$ be the finite portion of the oracle constructed in prior stages. At the current stage, our goal is to diagonalize a language $L_{k+1}(A) \\in \\Sigma_{k+1}^{\\mathrm{P},A}$ against a specific machine $M \\in \\Sigma_k^{\\mathrm{P},A}$. We pick a special input string $w$ whose properties depend on an integer $n$ chosen to be very large.\n\nThe membership of $w$ in our target language $L_{k+1}(A)$ is designed to depend on a single, currently undecided \"witness\" string, $s_w$. Specifically, the construction guarantees that:\n$$w \\in L_{k+1}(A) \\quad \\iff \\quad s_w \\in A$$\n\nTo achieve diagonalization, we must ensure that $M^A$ and $L_{k+1}(A)$ disagree on input $w$. The strategy is as follows:\n\n1.  We simulate the machine $M$ on input $w$. Since $M$ is a $\\Sigma_k^{\\mathrm{P},A}$ machine, its computation involves quantifiers and access to the oracle $A$.\n2.  During the simulation, if $M$ queries a string whose membership in $A$ is already determined by $A_{current}$, we use that answer. For any query about a new string (including $s_w$), we tentatively answer \"no\" (i.e., not in the oracle).\n3.  Let $Q$ be the set of all new strings queried during this simulation. The witness string $s_w$ is carefully chosen such that it is not in $Q$.\n4.  After the simulation completes, we decide whether to add $s_w$ to the oracle, thereby creating $A_{next}$. This decision is based on the simulation's outcome.\n\n**Question:**\n\nWhich of the following decision rules correctly ensures that $M^A$ and $L_{k+1}(A)$ disagree on the input $w$, thus successfully completing the diagonalization step?\n\nA. If the simulation of $M(w)$ rejects, we commit to never adding $s_w$ to the oracle. If the simulation accepts, we add $s_w$ to the oracle.\n\nB. If the simulation of $M(w)$ rejects, we add $s_w$ to the oracle. If the simulation accepts, we commit to never adding $s_w$ to the oracle.\n\nC. Regardless of the simulation's outcome, we add $s_w$ to the oracle, since this guarantees $w \\in L_{k+1}(A)$ and $L_{k+1}(A)$ is the more powerful class.\n\nD. We add $s_w$ to the oracle only if the simulation made an odd number of queries. Otherwise, we commit to never adding $s_w$ to the oracle.\n\nE. If the simulation of $M(w)$ accepts, we find a different string $s'_w \\in Q$ that was queried and add that to the oracle instead of $s_w$. If the simulation rejects, we add $s_w$ to the oracle.", "solution": "We formalize the diagonalization step for a fixed $k \\ge 0$, a finite oracle prefix $A_{current}$, a target language $L_{k+1}(A) \\in \\Sigma_{k+1}^{\\mathrm{P},A}$ constructed so that for a selected input $w$ there exists a single undecided witness $s_{w}$ with\n$$\nw \\in L_{k+1}(A) \\iff s_{w} \\in A,\n$$\nand a specific machine $M \\in \\Sigma_{k}^{\\mathrm{P},A}$ to be diagonalized against.\n\nStep 1: Simulate $M$ on input $w$ using the partial oracle answers as follows:\n- If $M$ queries a string $x$ whose membership in $A$ is already fixed by $A_{current}$, answer with that fixed value.\n- If $M$ queries a new string $x \\notin \\mathrm{dom}(A_{current})$, answer $x \\notin A$ tentatively.\nLet $Q$ be the set of all new strings queried during this simulation. By construction, choose $s_{w} \\notin Q$. Let the simulation outcome be a bit $b \\in \\{0,1\\}$, where $b=1$ denotes accept and $b=0$ denotes reject.\n\nStep 2: Relate the simulation to the true run under the eventual oracle update. Define the next oracle $A_{next}$ by possibly adding $s_{w}$ to $A_{current}$ and leaving all other strings outside $\\mathrm{dom}(A_{current})$ undefined except that we will not change any answer for strings in $Q$. Because $s_{w} \\notin Q$, adding or not adding $s_{w}$ does not change the answer to any query that $M$ issued in the simulation. Therefore the machine’s actual decision on $w$ with oracle $A_{next}$ equals the simulated outcome:\n$$\nL(M^{A_{next}})(w) = b.\n$$\n\nStep 3: Compute the target language membership after the oracle update. By the design of $L_{k+1}(A)$,\n$$\nw \\in L_{k+1}(A_{next}) \\iff s_{w} \\in A_{next}.\n$$\nThus, if we set $s_{w} \\in A_{next}$, then $w \\in L_{k+1}(A_{next})$, and if we set $s_{w} \\notin A_{next}$, then $w \\notin L_{k+1}(A_{next})$.\n\nStep 4: Choose the update rule to force disagreement. To ensure $L(M^{A_{next}})(w) \\neq L_{k+1}(A_{next})(w)$, we must set\n$$\ns_{w} \\in A_{next} \\iff b=0,\n$$\nthat is, add $s_{w}$ to the oracle if and only if the simulation rejects, and otherwise do not add $s_{w}$.\n\nVerification against the options:\n- Option A makes $s_{w} \\in A_{next} \\iff b=1$, which yields agreement, not diagonalization.\n- Option B makes $s_{w} \\in A_{next} \\iff b=0$, which yields disagreement as required.\n- Option C always adds $s_{w}$, which cannot guarantee disagreement.\n- Option D ties the decision to the parity of queries, which is unrelated to forcing disagreement.\n- Option E adds some $s'_{w} \\in Q$ when $M$ accepts; this changes an answer to a query $M$ actually made, so $L(M^{A_{next}})(w)$ may differ from the simulated $b$, breaking the control needed for diagonalization.\n\nTherefore, the correct rule is Option B.", "answer": "$$\\boxed{B}$$", "id": "1430202"}]}