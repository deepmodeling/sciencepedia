{"hands_on_practices": [{"introduction": "We begin our hands-on exploration by establishing a fundamental baseline for the power of oracles. What happens if our \"magic black box\" can only solve a problem that we could already solve efficiently on our own? This practice [@problem_id:1417408] investigates the scenario where a polynomial-time Turing machine is given access to an oracle for a language that is itself in $P$. By proving that this oracle access grants no additional computational power, you will solidify your understanding of the foundational rule that if a language $A$ is in $P$, then $P^A = P$.", "problem": "In the theory of computation, an oracle Turing machine (OTM) is an abstract machine used to study decision problems. It is a standard Turing machine augmented with a black-box component, known as an oracle. At any point in its computation, the OTM can write a query string $w$ to a special oracle tape and enter a query state. In a single computational step, the oracle provides a \"yes\" or \"no\" answer, indicating whether the query string $w$ is a member of a fixed language $A$, known as the oracle language.\n\nThe complexity class $P^A$ is defined as the set of all languages that can be decided by a deterministic OTM with oracle $A$ in a number of steps that is polynomial in the length of the input string. The standard complexity class $P$ is the set of languages decidable by a standard deterministic Turing machine (with no oracle) in polynomial time.\n\nLet the alphabet be $\\Sigma = \\{0, 1\\}$. Consider a specific oracle language $A$ which consists of all binary strings of odd length. That is, $A = \\{w \\in \\{0, 1\\}^* \\mid |w| \\text{ is odd}\\}$.\n\nWhich of the following statements correctly describes the relationship between the complexity class $P^A$ (using this specific oracle $A$) and the standard complexity class $P$?\n\nA. $P^A = P$\n\nB. $P \\subset P^A$ (meaning $P$ is a proper subset of $P^A$)\n\nC. $P^A \\subset P$ (meaning $P^A$ is a proper subset of $P$)\n\nD. $P^A$ and $P$ are incomparable (meaning neither class is a subset of the other)\n\nE. The relationship cannot be determined without knowing if $P = NP$.", "solution": "The problem asks for the relationship between the complexity classes $P$ and $P^A$, where the oracle $A$ is the language of all binary strings of odd length. To determine this relationship, we must check for subset inclusion in both directions: whether $P \\subseteq P^A$ and whether $P^A \\subseteq P$.\n\nFirst, let's prove that $P \\subseteq P^A$.\nLet $L$ be an arbitrary language in $P$. By the definition of $P$, there exists a standard deterministic Turing machine $M$ that decides $L$ in polynomial time. Let's say the running time of $M$ on an input of length $n$ is bounded by a polynomial $p(n)$. We can construct an oracle Turing machine $M^A$ that decides $L$. This machine $M^A$ simply simulates the steps of the standard machine $M$ on its input and completely ignores the oracle. Since $M$ never makes an oracle query, $M^A$ also never needs to use its oracle. The running time of $M^A$ is identical to that of $M$, which is $p(n)$. Therefore, $M^A$ is a polynomial-time oracle Turing machine that decides $L$. This implies that $L \\in P^A$. Since our choice of $L \\in P$ was arbitrary, we can conclude that $P \\subseteq P^A$. Note that this inclusion holds for any oracle language $A$.\n\nNext, let's prove that $P^A \\subseteq P$.\nLet $L'$ be an arbitrary language in $P^A$. By the definition of $P^A$, there exists a deterministic oracle Turing machine $M^A$ that decides $L'$ in polynomial time. Let the running time of $M^A$ on an input of length $n$ be bounded by a polynomial $q(n)$.\n\nThe key is to analyze the oracle $A$. The oracle language is $A = \\{w \\in \\{0, 1\\}^* \\mid |w| \\text{ is odd}\\}$. A query to this oracle for a given string $w$ is a request to determine if $w \\in A$. This is equivalent to asking if the length of the string $w$ is an odd number.\nThis check can be performed by a standard algorithm. A standard (non-oracle) Turing machine can take the string $w$ as input, read it from beginning to end to count its length $|w|$, and then determine if the number $|w|$ is odd. The time taken to count the length of $w$ is proportional to $|w|$, which is $O(|w|)$. Checking if the resulting integer is odd is computationally trivial. Therefore, the oracle query for a string $w$ can be simulated by a standard Turing machine in time polynomial in the length of the query string $w$. Specifically, the language $A$ is in $P$ (in fact, it's in linear time, DTIME(O(n))).\n\nNow, we can construct a standard deterministic Turing machine $M'$ that decides the language $L'$ without an oracle. $M'$ will simulate the execution of $M^A$.\n$M'$ operates as follows:\n1. It simulates each computational step of $M^A$.\n2. When the simulation reaches a point where $M^A$ would make an oracle query on a string $w$, $M'$ pauses the main simulation.\n3. It then runs a subroutine to decide if $w \\in A$. This subroutine, as described above, counts the length of $w$ and checks if it's odd.\n4. Based on the 'yes' or 'no' result from this subroutine, $M'$ resumes the simulation of $M^A$ from the corresponding state ('yes' state or 'no' state), just as $M^A$ would have done after receiving the answer from its oracle.\n\nFinally, let's analyze the running time of $M'$. The oracle machine $M^A$ runs in time $q(n)$ on an input of length $n$. In any single step, $M^A$ can at most write one symbol to its oracle tape. Therefore, any query string $w$ that $M^A$ produces must have a length $|w| \\le q(n)$.\nThe time for $M'$ to simulate a single oracle query on a string $w$ is polynomial in $|w|$, let's say $O(|w|)$. Since $|w| \\le q(n)$, the time to simulate one query is bounded by a polynomial in $n$, e.g., $O(q(n))$.\nIn the worst case, $M^A$ could make an oracle query at every step of its computation. The total number of steps is at most $q(n)$. So, the total time for $M'$ is the sum of the time for simulating the non-query steps of $M^A$ plus the total time for simulating all the queries.\nTotal runtime of $M' \\approx (\\text{number of non-query steps}) + (\\text{number of queries}) \\times (\\text{time per query simulation})$.\nThis is bounded above by $q(n) + q(n) \\times O(q(n)) = O(q(n)^2)$.\nSince $q(n)$ is a polynomial in $n$, $q(n)^2$ is also a polynomial in $n$. Thus, $M'$ is a polynomial-time standard deterministic Turing machine that decides the language $L'$.\nThis implies that $L' \\in P$. Since our choice of $L' \\in P^A$ was arbitrary, we can conclude that $P^A \\subseteq P$.\n\nSince we have shown that $P \\subseteq P^A$ and $P^A \\subseteq P$, it must be the case that the two classes are equal: $P^A = P$. This corresponds to option A.\nIn general, a useful theorem in complexity theory states that for any language $A$, if $A \\in P$, then $P^A = P$. Our specific oracle $A$ is decidable in linear time, so $A \\in P$, and the theorem directly yields the result.", "answer": "$$\\boxed{A}$$", "id": "1417408"}, {"introduction": "After seeing that an \"easy\" oracle offers no advantage, we now turn to the opposite extreme: what is the power of an oracle that can solve one of the hardest problems in a given complexity class? This exercise [@problem_id:1417452] equips a polynomial-time machine with an oracle for the TQBF problem, which is known to be $\\text{PSPACE}$-complete. Your task is to discover the profound relationship between $P^{\\text{TQBF}}$ and $\\text{PSPACE}$, illustrating a key principle: having polynomial-time access to a complete problem for a class $\\mathcal{C}$ often elevates your computational power to that entire class.", "problem": "A research group in theoretical computer science is exploring the power of \"black box\" computations. They are investigating a model where a standard polynomial-time computer is given access to a special hardware accelerator, an \"oracle,\" that can instantaneously solve any instance of the True Quantified Boolean Formula (TQBF) problem. The TQBF problem is known to be PSPACE-complete.\n\nLet's formalize this. An oracle Turing machine is a Turing machine with a special \"oracle tape\" and a \"query state.\" When the machine enters the query state, the string written on its oracle tape is replaced in a single computational step by a '1' if the string belongs to the oracle's language, and by a '0' otherwise.\n\nFor a complexity class $\\mathcal{C}$ and a language $A$, the class $\\mathcal{C}^A$ is defined as the set of languages that can be decided by an oracle Turing machine that runs within the resource bounds of $\\mathcal{C}$ and uses an oracle for the language $A$.\n\nGiven that TQBF is PSPACE-complete, which of the following statements correctly describes the relationship between the class $P^{\\text{TQBF}}$ (languages decidable in polynomial time with a TQBF oracle) and the class PSPACE (languages decidable in polynomial space)?\n\nA. $P^{\\text{TQBF}} = \\text{NP}$\n\nB. $P^{\\text{TQBF}} = \\text{PSPACE}$\n\nC. $P^{\\text{TQBF}} = \\text{EXPTIME}$\n\nD. $P^{\\text{TQBF}} = \\text{P}$\n\nE. The relationship cannot be determined from the information given.", "solution": "We use the definition of oracle Turing machines and the PSPACE-completeness of TQBF.\n\nFirst, recall that TQBF is PSPACE-complete under polynomial-time many-one reductions. That is, for every language $L \\in \\text{PSPACE}$ there exists a polynomial-time computable function $f$ such that for all inputs $x$,\n$$\nx \\in L \\quad \\Longleftrightarrow \\quad f(x) \\in \\text{TQBF}.\n$$\nThis immediately gives the containment $\\text{PSPACE} \\subseteq \\text{P}^{\\text{TQBF}}$: a deterministic polynomial-time oracle machine with oracle $\\text{TQBF}$ can decide $L$ by computing $f(x)$ in polynomial time and making a single oracle query to $\\text{TQBF}$. Formally,\n$$\n\\text{PSPACE} \\subseteq \\text{P}^{\\text{TQBF}}.\n$$\n\nFor the reverse containment, note that $\\text{TQBF} \\in \\text{PSPACE}$. Let $M$ be any deterministic polynomial-time oracle Turing machine with oracle $\\text{TQBF}$. We simulate $M$ by a deterministic Turing machine $S$ that uses only polynomial space. The simulator $S$ maintains the work tapes of $M$ and, whenever $M$ makes an oracle query on a string $y$, $S$ decides whether $y \\in \\text{TQBF}$ using a polynomial-space algorithm for $\\text{TQBF}$, writes the corresponding bit as the oracle answer, and resumes simulating $M$. Because:\n- $M$ runs in polynomial time, it makes at most polynomially many queries and each query string has length polynomial in the input size.\n- Deciding each oracle query uses polynomial space in $|y|$, hence polynomial space in the original input size.\n- Space can be reused across queries.\n\nthe total space used by $S$ is polynomial in the input size. Therefore every language in $\\text{P}^{\\text{TQBF}}$ is in $\\text{PSPACE}$, i.e.,\n$$\n\\text{P}^{\\text{TQBF}} \\subseteq \\text{PSPACE}.\n$$\n\nCombining the two containments yields\n$$\n\\text{P}^{\\text{TQBF}} = \\text{PSPACE}.\n$$\n\nAmong the options, this corresponds to choice B.", "answer": "$$\\boxed{B}$$", "id": "1417452"}, {"introduction": "The power of oracles isn't just about unlimited queries; often, the most insightful results come from using them strategically and sparingly. This final practice [@problem_id:1417455] shifts our focus to algorithmic techniques that leverage a limited number of oracle calls to solve problems that are otherwise out of reach. You will explore how just $O(\\log n)$ queries to a $SAT$ oracle can be used to determine properties of a solution, such as finding the precise size of a maximum clique, by employing powerful methods like binary search on the solution space.", "problem": "Let $SAT$ be the language of all satisfiable Boolean formulas. An oracle Turing machine is a Turing machine with a special \"oracle\" tape and query state. To query the oracle, the machine writes a string $q$ on its oracle tape and enters the query state. In a single computational step, the oracle mechanism replaces the content of the oracle tape with a '1' if $q \\in SAT$, or with a '0' if $q \\notin SAT$.\n\nConsider the complexity class, which we will denote as $\\mathcal{C}_{\\log}$, consisting of all languages $L$ for which there exists a deterministic polynomial-time oracle Turing machine $M$ that decides $L$ under the following condition: for any input $x$ of length $n = |x|$, the machine $M$ makes at most $c \\cdot \\log(n)$ queries to the $SAT$ oracle for some constant $c > 0$.\n\nWhich of the following languages belong to the class $\\mathcal{C}_{\\log}$? Select all that apply.\n\nA. `MAX-CLIQUE-SIZE-IS-EVEN`: The language of all strings that encode an undirected graph $G = (V, E)$, where the size of the largest clique in $G$ is an even number. For this problem, the input size $n$ is taken to be the number of vertices, $|V|$.\n\nB. `UNIQUE-SAT`: The language of all strings that encode a Boolean formula $\\phi$ which has exactly one satisfying assignment. For this problem, the input size $n$ is the length of the encoding of the formula, $|\\phi|$.\n\nC. `SAT-UNSAT`: The language of all strings that encode a pair of Boolean formulas $(\\phi_1, \\phi_2)$ such that $\\phi_1$ is satisfiable and $\\phi_2$ is unsatisfiable. For this problem, the input size $n$ is the length of the encoding of the pair, $|(\\phi_1, \\phi_2)|$.\n\nD. `MAJORITY-SAT`: The language of all strings that encode a Boolean formula $\\phi$ over $k$ variables, such that $\\phi$ has strictly more than $2^{k-1}$ satisfying assignments. For this problem, the input size $n$ is the length of the encoding of the formula, $|\\phi|$.", "solution": "We recall the definition: a language $L$ is in $\\mathcal{C}_{\\log}$ if there exists a deterministic polynomial-time oracle Turing machine $M$ and a constant $c>0$ such that, on every input $x$ with length $n=|x|$, $M$ decides whether $x\\in L$ while making at most $c\\cdot \\log(n)$ queries to the $SAT$ oracle. The logarithm can be taken to any fixed base, since multiplicative constants are absorbed into $c$.\n\nWe analyze each option by explicitly constructing a polynomial-time procedure that uses at most $O(\\log n)$ oracle queries to $SAT$ and decides the language.\n\nA. MAX-CLIQUE-SIZE-IS-EVEN.\nLet the input encode a graph $G=(V,E)$, and let $n=|V|$. Define the monotone predicate\n$$\nP(k)\\ \\equiv\\ \\text{``$G$ contains a clique of size at least $k$''}.\n$$\nFor each integer $k$ with $0\\leq k\\leq n$, there is a polynomial-time many-one reduction to $SAT$ producing a Boolean formula $\\Phi_{G,k}$ such that\n$$\n\\Phi_{G,k}\\in SAT\\ \\Longleftrightarrow\\ P(k).\n$$\nThe function $P(k)$ is monotone nonincreasing in $k$: if $P(k)$ holds, then $P(k')$ holds for all $k'\\leq k$; if $P(k)$ fails, then $P(k')$ fails for all $k'\\geq k$. Hence there exists a unique threshold $k^{\\star}\\in\\{0,1,\\dots,n\\}$ such that $P(k)$ holds exactly for $k\\leq k^{\\star}$, and $k^{\\star}$ is the maximum clique size.\n\nWe can recover $k^{\\star}$ exactly by binary search on the interval $[0,n]$ using the oracle for $P(k)$ via queries $\\Phi_{G,k}$. Concretely:\n- Initialize $\\ell\\leftarrow 0$, $r\\leftarrow n$.\n- While $\\ell<r$, set $m\\leftarrow \\left\\lfloor \\frac{\\ell+r+1}{2}\\right\\rfloor$, query the oracle on $\\Phi_{G,m}$.\n- If the oracle answers $1$ (meaning $P(m)$ holds), set $\\ell\\leftarrow m$; otherwise set $r\\leftarrow m-1$.\n- At termination, $\\ell=r=k^{\\star}$.\n\nThis loop makes at most $\\lceil \\log_{2}(n+1)\\rceil$ oracle queries. After obtaining $k^{\\star}$, we compute $k^{\\star}\\bmod 2$ in deterministic polynomial time and accept iff it is $0$. Therefore the language is decided in polynomial time with $O(\\log n)$ SAT-queries, so it belongs to $\\mathcal{C}_{\\log}$.\n\nB. UNIQUE-SAT.\nGiven a Boolean formula $\\phi$ over variables $x=(x_{1},\\dots,x_{k})$, we decide whether it has exactly one satisfying assignment using at most two $SAT$ queries:\n- First, query the oracle on $\\phi$ itself. If the oracle answers $0$, then $\\phi$ is unsatisfiable, hence not in UNIQUE-SAT; reject.\n- Otherwise, construct in polynomial time a formula over two disjoint copies of the variables, $x$ and $y$, defined by\n$$\n\\psi(x,y)\\ :=\\ \\phi(x)\\ \\wedge\\ \\phi(y)\\ \\wedge\\ \\left(\\bigvee_{i=1}^{k} (x_{i}\\oplus y_{i})\\right),\n$$\nwhere $x_{i}\\oplus y_{i}$ denotes the exclusive-or constraint, which can be encoded in conjunctive normal form by a polynomial-time transformation. The formula $\\psi$ is satisfiable if and only if $\\phi$ has at least two distinct satisfying assignments. Query the oracle on $\\psi$.\n- If the oracle answers $0$, then $\\phi$ has exactly one satisfying assignment; accept. If it answers $1$, then $\\phi$ has at least two satisfying assignments; reject.\n\nThis algorithm uses at most $2$ SAT queries, which is within $c\\cdot \\log(n)$ for a suitable constant $c$ (and for small $n$ the machine can hardwire a decision without queries). Hence UNIQUE-SAT is in $\\mathcal{C}_{\\log}$.\n\nC. SAT-UNSAT.\nGiven a pair $(\\phi_{1},\\phi_{2})$, decide whether $\\phi_{1}$ is satisfiable and $\\phi_{2}$ is unsatisfiable by two SAT queries:\n- Query the oracle on $\\phi_{1}$; if the answer is $0$, reject.\n- Query the oracle on $\\phi_{2}$; if the answer is $1$, reject; otherwise accept.\n\nThis is clearly a deterministic polynomial-time procedure with at most $2$ SAT queries, thus the language is in $\\mathcal{C}_{\\log}$.\n\nD. MAJORITY-SAT.\nThe language asks whether $\\phi$ over $k$ variables has strictly more than $2^{k-1}$ satisfying assignments. This is the canonical MAJSAT problem, which is PP-complete under polynomial-time many-one reductions. On the other hand, any language in $\\mathcal{C}_{\\log}$ lies in $P^{NP[O(\\log n)]}$, which is contained in the second level of the polynomial hierarchy (specifically within $\\Delta_{2}^{P}$ and often denoted by $\\Theta_{2}^{P}$). There is no known deterministic polynomial-time algorithm using $O(\\log n)$ queries to $SAT$ that decides MAJSAT, and, relative to oracles, PP is not contained in the polynomial hierarchy, whereas $\\mathcal{C}_{\\log}\\subseteq PH$ relativizes. Therefore, while we can exhibit explicit $O(\\log n)$-query algorithms for A, B, and C, no such algorithm is known for D, and standard complexity assumptions preclude its membership in $\\mathcal{C}_{\\log}$.\n\nConclusion: A, B, and C are in $\\mathcal{C}_{\\log}$; D is not known to be, and under standard assumptions it is not.", "answer": "$$\\boxed{ABC}$$", "id": "1417455"}]}