{"hands_on_practices": [{"introduction": "Mahaney's theorem has profound implications for the structure of complexity classes, particularly concerning the famous $P$ versus $NP$ problem. However, its power is rooted in precise logical statements, and misinterpreting its scope can lead to incorrect conclusions. This first practice problem challenges you to scrutinize a common logical error by carefully distinguishing between the definitions of NP-hard and NP-complete, a foundational skill for rigorous work in complexity theory [@problem_id:1431081].", "problem": "In computational complexity theory, we analyze the resources required to solve computational problems. This analysis relies on several key definitions:\n\n- A **language** is a set of strings over a finite alphabet. We can think of a language as representing a decision problem, where the strings in the language are the \"yes\" instances.\n- A language $S$ is called **sparse** if there exists a polynomial $p(n)$ such that the number of strings in $S$ of length at most $n$ is bounded by $p(n)$. Informally, sparse languages have a polynomially-bounded number of \"yes\" instances up to a given input size.\n- A language $L$ is **NP-hard** if every problem in the class of Non-deterministic Polynomial time (NP) problems can be reduced to $L$ in polynomial time. NP-hard problems are at least as hard as the hardest problems in NP.\n- A language $L$ is **NP-complete** if it is both NP-hard and is itself in the class NP.\n- **Mahaney's Theorem** states: If a sparse language is NP-complete, then P = NP.\n\nA student in an introductory complexity theory course makes the following argument based on these definitions:\n\n\"The overwhelming consensus among researchers is that P $\\neq$ NP. Let's proceed by accepting this as a working hypothesis. The contrapositive of Mahaney's Theorem is: If P $\\neq$ NP, then no sparse language can be NP-complete. This is a direct logical consequence. From this, we can conclude that, assuming P $\\neq$ NP, no sparse language can be NP-hard.\"\n\nThe student's final conclusion is logically flawed. Which of the following statements most accurately identifies the error in the student's reasoning?\n\nA. The student correctly states the contrapositive of Mahaney's Theorem but draws an incorrect final conclusion. A language that is not NP-complete is not necessarily not NP-hard; it might be NP-hard but not be a member of NP.\n\nB. The student's argument is invalid because the P $\\neq$ NP hypothesis is unproven, and therefore cannot be used as a premise in a valid logical argument.\n\nC. The concept of a sparse set is incompatible with NP-hardness. By definition, an NP-hard problem must have a dense set of instances to allow for reductions from all NP problems, so a sparse NP-hard language is a contradiction in terms.\n\nD. The student incorrectly formulated the contrapositive of Mahaney's Theorem. The correct contrapositive is: \"If P = NP, then there exists at least one sparse language that is not NP-complete.\"", "solution": "We begin from Mahaney’s Theorem: “If a sparse language is NP-complete, then $P=NP$.” The logically equivalent contrapositive is: “If $P \\neq NP$, then no sparse language is NP-complete.” The student’s statement of the contrapositive is correct.\n\nNext, recall the definition: a language is NP-complete if and only if it is both NP-hard and in $NP$. Therefore,\n- “not NP-complete” means “either not NP-hard or not in $NP$ (or both).”\n- Consequently, from “no sparse language is NP-complete,” one cannot conclude “no sparse language is NP-hard,” because it is logically possible that a sparse language is NP-hard but not in $NP$.\n\nThus, the student’s error is the invalid inference from “no sparse language is NP-complete” to “no sparse language is NP-hard.” The correct identification is that “not NP-complete” does not imply “not NP-hard,” since a language can be NP-hard without belonging to $NP$.\n\nEvaluating the options:\n- A correctly pinpoints this logical mistake: a language can fail to be NP-complete because it is not in $NP$, yet still be NP-hard.\n- B is incorrect: using $P \\neq NP$ as a working hypothesis in a conditional argument is logically fine.\n- C is false: sparsity and NP-hardness are not definitionally incompatible.\n- D gives an incorrect contrapositive; the student’s contrapositive was already correct.\n\nTherefore, the most accurate identification of the error is A.", "answer": "$$\\boxed{A}$$", "id": "1431081"}, {"introduction": "The central condition in Mahaney's theorem is that the NP-complete language in question must be \"sparse,\" meaning it contains a relatively small number of \"yes\" instances. This exercise moves from abstract logic to a concrete application of this definition. You will analyze the language `COMPOSITES`—the set of all composite numbers—to determine if it meets the sparseness requirement, providing a tangible understanding of why this precondition is so critical [@problem_id:1431120].", "problem": "In computational complexity theory, a language $L \\subseteq \\{0,1\\}^*$ is defined as **sparse** if there exists a polynomial $p(n)$ such that for all positive integers $n$, the number of strings in $L$ of length $n$ is at most $p(n)$. That is, $|L \\cap \\{0,1\\}^n| \\le p(n)$.\n\n**Mahaney's Theorem** states that if any sparse language is NP-complete, then P = NP.\n\nNow, consider the language `COMPOSITES`, defined as the set of all binary strings that represent a composite integer. For instance, the string \"110\" (representing the integer 6) is in `COMPOSITES`, while the string \"101\" (representing the integer 5) is not.\n\nSuppose, hypothetically, that a computer scientist proves that the `COMPOSITES` language is NP-complete. Based on this hypothetical proof, which of the following statements correctly explains why Mahaney's theorem could **not** be used to immediately conclude that P = NP?\n\nA. The language `COMPOSITES` is not a sparse language.\n\nB. The language `COMPOSITES` is known not to be in the class NP.\n\nC. Mahaney's theorem only applies to languages that are already known to be in the class P.\n\nD. The number of prime numbers is finite, which implies `COMPOSITES` is not sparse.\n\nE. Mahaney's theorem cannot be applied to number-theoretic problems.", "solution": "By definition, a language $L \\subseteq \\{0,1\\}^{*}$ is sparse if there exists a polynomial $p(n)$ such that for all positive integers $n$, one has $|L \\cap \\{0,1\\}^{n}| \\leq p(n)$.\n\nMahaney's theorem states: If there exists a sparse language that is NP-complete (under polynomial-time many-one reductions), then $\\mathrm{P}=\\mathrm{NP}$. Thus, to apply Mahaney's theorem to any specific NP-complete language $L$, it is necessary that $L$ be sparse.\n\nConsider $L=\\text{COMPOSITES}$. For each integer $n \\geq 3$, examine the subset of $\\{0,1\\}^{n}$ consisting of strings whose most significant bit is $1$ and least significant bit is $0$. There are exactly $2^{n-2}$ such strings because the first bit is fixed to $1$, the last bit is fixed to $0$, and the remaining $n-2$ bits are arbitrary. Each such string encodes an even integer in the interval $[2^{n-1},\\,2^{n}-2]$. Every even integer in this interval is greater than $2$, hence composite. Therefore,\n$$\n|\\text{COMPOSITES} \\cap \\{0,1\\}^{n}| \\;\\geq\\; 2^{n-2} \\quad \\text{for all } n \\geq 3.\n$$\nSince $2^{n-2}$ grows exponentially in $n$, for any polynomial $p(n)$ there exists $n$ such that $2^{n-2} > p(n)$. Consequently, there is no polynomial $p(n)$ that upper-bounds $|\\text{COMPOSITES} \\cap \\{0,1\\}^{n}|$ for all $n$, so $\\text{COMPOSITES}$ is not sparse.\n\nTherefore, even under the hypothetical that $\\text{COMPOSITES}$ is NP-complete, Mahaney's theorem cannot be invoked to conclude $\\mathrm{P}=\\mathrm{NP}$ because its prerequisite (that the NP-complete language be sparse) fails. Among the options, this is exactly statement A. Statements B, C, D, and E are incorrect: COMPOSITES is in NP; Mahaney's theorem does not require the language to be in P; the set of primes is infinite; and the theorem is not restricted away from number-theoretic languages.", "answer": "$$\\boxed{A}$$", "id": "1431120"}, {"introduction": "The proof of Mahaney's theorem is not just a theoretical curiosity; it's constructive, outlining an algorithm to solve an NP-complete problem in polynomial time if it reduces to a sparse set. This final practice places you at the heart of this algorithmic process, known as self-reduction. By tracing the decision-making steps for a 3-SAT formula and calculating the exact query sent to an oracle, you will gain hands-on experience with the mechanics that make the theorem's consequences possible [@problem_id:61717].", "problem": "In computational complexity theory, Mahaney's theorem states that if any sparse language is NP-complete, then P = NP. A language $L \\subseteq \\{0,1\\}^*$ is called sparse if there exists a polynomial $p(n)$ such that $|L \\cap \\{0,1\\}^n| \\le p(n)$ for all $n \\ge 0$. Many NP-complete problems, such as the Boolean satisfiability problem (SAT), possess a property called self-reduction. This property allows one to find a witness (a solution) for a given instance by making a polynomial number of queries to a decider (an oracle) for the same problem.\n\nConsider the 3-Satisfiability problem (3-SAT), which is NP-complete. We are given a Boolean formula in 3-Conjunctive Normal Form (3-CNF). Let's assume, contrary to the consequences of Mahaney's theorem, that there exists a sparse language $L_{SPARSE}$ which is NP-complete, and we have a polynomial-time reduction $f$ from 3-SAT to $L_{SPARSE}$. An oracle for $L_{SPARSE}$ can thus decide satisfiability for any 3-SAT formula $\\psi$ by checking if $f(\\psi) \\in L_{SPARSE}$.\n\nThe self-reduction algorithm for a formula $\\phi$ with $n_{orig}$ variables $\\{x_1, \\dots, x_{n_{orig}}\\}$ works as follows: it iterates from $i=1$ to $n_{orig}$, determining the value of each $x_i$. At step $i$, with values for $x_1, \\dots, x_{i-1}$ already fixed, the algorithm first tentatively sets $x_i=0$. It simplifies the formula and queries the oracle. If the oracle confirms the resulting formula is satisfiable, the assignment $x_i=0$ is fixed. Otherwise, the algorithm deduces that any valid solution must have $x_i=1$ and fixes that assignment.\n\n**The Reduction Function $f$:**\nLet $\\psi$ be a 3-CNF formula over a subset of the original $n_{orig}$ variables. Let $v$ be the number of free (unassigned) variables in $\\psi$ and $c$ be the number of clauses. The reduction $f(\\psi)$ produces a binary string defined as:\n$f(\\psi) = \\text{start} \\cdot \\text{header} \\cdot \\text{body} \\cdot \\text{end}$\n1.  $\\text{start} = 0$, $\\text{end} = 1$.\n2.  $\\text{header} = 1^v0$, where $1^v$ is a sequence of $v$ ones.\n3.  $\\text{body} = \\text{enc}(C_1) \\cdot 0 \\cdot \\text{enc}(C_2) \\cdot \\ldots \\cdot 0 \\cdot \\text{enc}(C_c)$, where clauses are separated by a $0$. If $c=1$, the body is just $\\text{enc}(C_1)$.\n4.  Each literal is encoded as a $(p+1)$-bit string. The parameter $p = \\lceil\\log_2(n_{orig}+1)\\rceil$ is fixed by the original formula. For a literal involving variable $x_i$, the encoding is $\\sigma \\cdot \\text{bin}_p(i)$, where:\n    *   $\\sigma=1$ if the literal is positive ($x_i$).\n    *   $\\sigma=0$ if the literal is negative ($\\neg x_i$).\n    *   $\\text{bin}_p(i)$ is the $p$-bit binary representation of the index $i$.\n5.  An encoded clause $\\text{enc}(C_j)$ is the concatenation of the encodings of its three literals.\n\n**Simplification Rule:**\nWhen a variable assignment simplifies a clause:\n*   If it reduces to two literals, e.g., $(A \\lor B)$, it is rewritten as $(A \\lor B \\lor B)$.\n*   If it reduces to one literal, e.g., $(A)$, it is rewritten as $(A \\lor A \\lor A)$.\n*   If it becomes True (contains $1 \\lor \\dots$), the clause is removed from the formula.\n\n**Problem:**\nConsider the following 3-CNF formula $\\phi$ with $n_{orig}=4$ variables:\n$$ \\phi = (x_1 \\lor \\neg x_2 \\lor x_3) \\land (\\neg x_1 \\lor x_2 \\lor x_4) \\land (x_1 \\lor x_2 \\lor \\neg x_3) \\land (\\neg x_2 \\lor \\neg x_3 \\lor \\neg x_4) $$\nThe self-reduction process begins. Assume the oracle for $L_{SPARSE}$ provides the following answers to the first two queries:\n1.  Query for $x_1=0$: The oracle indicates the resulting formula is **not** satisfiable.\n2.  Query for $x_2=0$ (after acting on the result of the first query): The oracle indicates the resulting formula **is** satisfiable.\n\nFollowing this path, the algorithm proceeds to the third decision for variable $x_3$. What is the decimal integer representation of the binary string query $f(\\psi_{query})$ that is generated for this third decision?", "solution": "1. Relevant definitions:\n   - A formula with $v$ free variables and $c$ clauses is encoded by\n     $$f(\\psi)=\\text{start}\\;\\|\\;\\text{header}\\;\\|\\;\\text{body}\\;\\|\\;\\text{end},$$\n     where\n     \\begin{align*}\n       \\text{start}&=0,\\quad \\text{end}=1,\\\\\n       \\text{header}&=1^v0,\\\\\n       \\text{body}&=\\bigl(\\enc(C_1)\\bigr)\\;0\\;\\bigl(\\enc(C_2)\\bigr)\\;\\cdots\\;0\\;\\bigl(\\enc(C_c)\\bigr).\n     \\end{align*}\n   - Each literal over variable $x_i$ is encoded as\n     $$\\sigma\\;\\|\\;\\bin_p(i),\\quad p=\\lceil\\log_2(n_{\\rm orig}+1)\\rceil,\\; \\sigma=1\\text{ (positive) or }0\\text{ (negative)}.$$\n2. After fixing $x_1=1$ (oracle “not satisfiable” for $x_1=0$) and $x_2=0$ (oracle “satisfiable”), we tentatively set $x_3=0$.  Simplify each clause of \n   $$\\phi=(x_1\\lor\\neg x_2\\lor x_3)\\land(\\neg x_1\\lor x_2\\lor x_4)\\land(x_1\\lor x_2\\lor\\neg x_3)\\land(\\neg x_2\\lor\\neg x_3\\lor\\neg x_4).$$\n   - $(x_1\\lor\\neg x_2\\lor x_3)$ becomes true (removed).\n   - $(x_1\\lor x_2\\lor\\neg x_3)$ becomes true (removed).\n   - $(\\neg x_2\\lor\\neg x_3\\lor\\neg x_4)$: $\\neg x_2=1\\implies$ removed.\n   - $(\\neg x_1\\lor x_2\\lor x_4)$: $\\neg x_1=0,\\;x_2=0\\implies(x_4)$, rewritten as $(x_4\\lor x_4\\lor x_4)$.\n   Thus the simplified $\\psi_{\\rm query}$ has $v=1$ free var. ($x_4$) and $c=1$ clause.\n3. Compute parameters:\n   $$n_{\\rm orig}=4\\implies p=\\lceil\\log_2(5)\\rceil=3,\\quad v=1,\\quad c=1.$$\n4. Build the encoding:\n   - start $=0$\n   - header $=1^v0=10$\n   - Each literal $x_4$ encoded as $\\sigma\\,\\|\\bin_3(4)=1\\,100=1100$.  \n     Clause encoding $\\enc(C_1)=1100\\,1100\\,1100$.\n   - body $=110011001100$\n   - end $=1$\n   Concatenate:\n   $$f(\\psi_{\\rm query})=0\\;\\|\\;10\\;\\|\\;110011001100\\;\\|\\;1=0101100110011001_2.$$\n5. Convert to decimal:\n   $$0101\\;1001\\;1001\\;1001_2 =5\\,9\\,9\\,9_{16}=0x5999_{16}\n     =5\\cdot4096+9\\cdot256+9\\cdot16+9=22937.$$", "answer": "$$\\boxed{22937}$$", "id": "61717"}]}