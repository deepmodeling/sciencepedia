{"hands_on_practices": [{"introduction": "The power of Alternating Turing Machines (ATMs) lies in their ability to directly model logical quantifiers. This first exercise provides a gentle introduction to this concept by tackling the problem of identifying non-palindromes [@problem_id:1411937]. A string is a non-palindrome if there *exists* at least one position where characters do not match their symmetric counterparts. This practice challenges you to map this simple \"there exists\" condition onto the operational logic of an ATM, using an existential state to elegantly solve the problem.", "problem": "An Alternating Turing Machine (ATM) is a type of non-deterministic Turing machine whose states are divided into two categories: *existential* states and *universal* states. For a given input, the computation of an ATM can be visualized as a tree of configurations.\n- If the current state is *existential*, the machine accepts if there exists at least one computation path (one branch in the tree) from the current configuration that leads to an accepting state.\n- If the current state is *universal*, the machine accepts if all computation paths (all branches in the tree) from the current configuration lead to an accepting state.\n\nA binary string is called a palindrome if it reads the same forwards and backwards. For example, \"1001\" is a palindrome, but \"1011\" is not. Let $w^R$ denote the reverse of a string $w$. A string $w$ is a palindrome if $w = w^R$.\n\nConsider the language $L$ of all binary strings that are **not** palindromes. Your task is to identify the correct high-level operational description for an ATM that decides this language $L$. The input string $w$ has a length of $n$, and its characters are indexed from $0$ to $n-1$.\n\nWhich of the following descriptions accurately outlines a strategy for an ATM that accepts an input string $w$ if and only if $w$ is **not** a palindrome?\n\nA. The ATM starts in an existential state. It existentially chooses an index $i$ (where $0 \\le i < n/2$). It then deterministically moves its tape head to read the character $w[i]$ and the character at the symmetric position $w[n-1-i]$. The machine enters an accepting state for this computation path if $w[i] \\neq w[n-1-i]$, and a rejecting state otherwise.\n\nB. The ATM starts in a universal state. It universally branches for every index $i$ (where $0 \\le i < n/2$). For each branch, it deterministically checks if $w[i] \\neq w[n-1-i]$. If they are not equal, the branch leads to an accepting state. The machine accepts the input string only if all branches lead to acceptance.\n\nC. The ATM starts in an existential state. It existentially chooses an index $i$ (where $0 \\le i < n/2$). It then deterministically moves its tape head to read the character $w[i]$ and the character at the symmetric position $w[n-1-i]$. The machine enters an accepting state for this computation path if $w[i] = w[n-1-i]$, and a rejecting state otherwise.\n\nD. The ATM starts in an existential state and chooses an index $i$. It then transitions to a universal state which branches into two parallel checks: (1) verify that $w[i]$ is '0', and (2) verify that $w[n-1-i]$ is '1'. The machine accepts if it can find an index $i$ for which both universal checks succeed.", "solution": "We formalize the target language. Let $w$ be a binary string of length $n$, indexed from $0$ to $n-1$. Define the set of symmetric index pairs as those of the form $(i,n-1-i)$ for $i$ with $0 \\le i < n/2$ (interpreting $n/2$ as integer division). Then $w$ is a palindrome if and only if for all such $i$, $w[i] = w[n-1-i]$. Hence $w$ is not a palindrome if and only if there exists at least one such $i$ with $w[i] \\ne w[n-1-i]$. Symbolically,\n$$\nw \\in L \\iff \\exists i \\in \\{0,1,\\dots,\\lfloor n/2 \\rfloor - 1\\} \\text{ such that } w[i] \\ne w[n-1-i].\n$$\nAn Alternating Turing Machine accepts from an existential state if there exists a computation branch that reaches acceptance, and accepts from a universal state if all computation branches reach acceptance. Therefore, to accept exactly $L$, the machine must realize the existential condition above: nondeterministically choose an index $i$ and accept if a mismatch is found at that symmetric pair.\n\nWe now evaluate the options by translating each to a logical condition:\n\nA. Starts existentially, chooses $i$ with $0 \\le i < n/2$, and accepts along that branch if $w[i] \\ne w[n-1-i]$. The overall acceptance condition is\n$$\n\\exists i \\text{ with } 0 \\le i < \\frac{n}{2} \\text{ such that } w[i] \\ne w[n-1-i],\n$$\nwhich matches exactly $w \\in L$. Thus A is correct.\n\nB. Starts universally, branches over all $i$ with $0 \\le i < n/2$, and each branch accepts only if $w[i] \\ne w[n-1-i]$. The overall acceptance condition is\n$$\n\\forall i \\text{ with } 0 \\le i < \\frac{n}{2},\\ w[i] \\ne w[n-1-i],\n$$\nwhich is strictly stronger than non-palindrome and fails for non-palindromes that have at least one equal symmetric pair. Hence B is incorrect.\n\nC. Starts existentially, chooses $i$, and accepts if $w[i] = w[n-1-i]$. The overall acceptance condition is\n$$\n\\exists i \\text{ with } 0 \\le i < \\frac{n}{2} \\text{ such that } w[i] = w[n-1-i],\n$$\nwhich accepts many palindromes (indeed all palindromes) and some non-palindromes; it does not characterize $L$. Hence C is incorrect.\n\nD. Starts existentially choosing $i$, then universally enforces both $w[i]=0$ and $w[n-1-i]=1$ on that branch. The overall acceptance condition is\n$$\n\\exists i \\text{ with } 0 \\le i < \\frac{n}{2} \\text{ such that } \\big(w[i]=0 \\land w[n-1-i]=1\\big),\n$$\nwhich captures only one direction of mismatch and fails whenever the mismatch is $w[i]=1$, $w[n-1-i]=0$. Hence D is incorrect.\n\nTherefore, only A correctly describes an ATM that accepts exactly the non-palindromes.", "answer": "$$\\boxed{A}$$", "id": "1411937"}, {"introduction": "Building on the idea of existential states, we now explore their dual: universal states. This exercise [@problem_id:1411930] asks you to design an ATM for the UNREACHABILITY problem, the complement of the well-known REACHABILITY problem. While a standard Nondeterministic Turing Machine (an existential model) can find if a path exists, proving that *no* path exists requires a different logic: you must show that *for all* possible steps from a vertex, none lead to the target. This \"for all\" condition is perfectly captured by an ATM's universal state, providing a clear illustration of the duality between existential (`∃`) and universal (`∀`) computation and the classes NP and co-NP.", "problem": "Consider a directed graph $G = (V, E)$, where $V$ is a finite set of vertices and $E$ is a set of ordered pairs of vertices representing directed edges. Let $s, t \\in V$ be distinct source and target vertices, respectively. The graph reachability problem, REACHABILITY, asks whether there exists a path from $s$ to $t$.\n\nA Nondeterministic Turing Machine (NTM) can solve REACHABILITY. The input on its tape is a description of the graph $G$ and the vertices $s$ and $t$. The NTM's logic is as follows: It maintains a \"current vertex\", initially $s$, and a step counter, initially 0. In a loop, it performs the following:\n1. If the current vertex $u$ is equal to $t$, the machine halts and accepts.\n2. If the step counter has reached $|V|$, a limit to prevent infinite loops on cycles, the machine halts and rejects on this path.\n3. Otherwise, the NTM uses its nondeterminism (an existential state) to guess a vertex $v$ such that $(u, v) \\in E$. It updates its current vertex to $v$, increments the step counter, and continues the loop. If $u$ has no outgoing edges, this branch rejects.\nThe machine as a whole accepts if any of its computational branches finds a path to $t$.\n\nNow, consider the complementary problem, UNREACHABILITY, which asks whether there is *no* path from $s$ to $t$. Your task is to describe the high-level computational logic of an Alternating Turing Machine (ATM) that solves UNREACHABILITY. An ATM is a generalization of an NTM that has both existential states (which accept if at least one subsequent computation accepts) and universal states (which accept if all subsequent computations accept).\n\nLet $N = |V|$ be the number of vertices in the graph. Which of the following statements correctly describes the core logic for an ATM that decides UNREACHABILITY?\n\nA. The ATM starts with the current vertex as $s$ and a step counter at 0. If the current vertex $u$ is $t$, it rejects. If the counter reaches $N$, it accepts. Otherwise, it enters a **universal state** to branch to all neighbors of $u$. For each neighbor $v$, a new computation is spawned with the current vertex as $v$ and an incremented counter. If a vertex $u \\neq t$ has no neighbors, that branch accepts. The machine accepts if all branches lead to acceptance.\n\nB. The ATM starts with the current vertex $s$. It enters an **existential state** to nondeterministically guess a sequence of vertices representing a path. If the path reaches $t$, the machine accepts. If all guessed paths of length less than $N$ do not reach $t$, the machine rejects.\n\nC. The ATM starts with the current vertex $s$. It enters a **universal state** and universally branches to every other vertex $v \\in V \\setminus \\{s,t\\}$. For each such branch, the ATM then enters an **existential state** to check if a path exists from $s$ to $v$ and a path exists from $v$ to $t$. If this is true for any $v$, the machine rejects.\n\nD. The ATM starts with the current vertex $s$ and a step counter at 0. In a loop, it enters an **existential state** to guess a neighbor $v$ of the current vertex $u$. Then, it enters a **universal state** to verify that $v$ is not $t$ and that the step counter is less than $N$. If these conditions hold for all choices, it continues. If it is possible to continue for $N$ steps, the machine accepts.", "solution": "We formalize the property needed to decide UNREACHABILITY using an inductive predicate over bounded path length. Let $G=(V,E)$ be a directed graph with $|V|=N$ and fixed vertices $s,t \\in V$. Define, for each vertex $u \\in V$ and integer $k \\geq 0$, the predicate $R_{k}(u)$ to mean: there is no path from $u$ to $t$ of length at most $k$.\n\nWe derive $R_{k}(u)$ by induction on $k$:\n1. Base case: A path of length at most $0$ exists from $u$ to $t$ if and only if $u=t$. Therefore,\n$$\nR_{0}(u) \\iff u \\neq t.\n$$\n2. Induction step: There is no path of length at most $k+1$ from $u$ to $t$ if and only if $u \\neq t$ and, for every outgoing neighbor $v$ with $(u,v) \\in E$, there is no path of length at most $k$ from $v$ to $t$. Therefore,\n$$\nR_{k+1}(u) \\iff \\bigl(u \\neq t\\bigr) \\land \\bigl(\\forall v \\in V \\text{ with } (u,v) \\in E,\\ R_{k}(v)\\bigr).\n$$\n\nIf $R_{N-1}(s)$ holds, then there is no path at all from $s$ to $t$, because any path from $s$ to $t$ can be shortened to a simple path, and any simple path in a graph with $N$ vertices has length at most $N-1$. Hence, deciding UNREACHABILITY reduces to deciding $R_{N-1}(s)$.\n\nAn Alternating Turing Machine naturally implements this induction:\n- The ATM configuration carries a current vertex $u$ and a counter $c$ representing the remaining length budget. Initialize with $(u,c)=(s,N-1)$.\n- If $u=t$, reject, matching $R_{0}(u) \\iff u \\neq t$ and the left conjunct in the induction step.\n- If $c=0$, accept, since $R_{0}(u)$ is exactly $u \\neq t$, which we ensured by the prior check.\n- Otherwise, enter a universal state that, for each outgoing neighbor $v$ with $(u,v) \\in E$, spawns a subcomputation on $(v,c-1)$. If $u$ has no outgoing neighbors and $u \\neq t$, then the universal quantification over an empty set is vacuously true, so the branch accepts. The overall acceptance requires that all spawned subcomputations accept, exactly as required by the induction step.\n\nThis behavior is equivalent to starting with $(u,c)=(s,0)$ and accepting when the counter reaches $N$, while at each step universally branching to all neighbors and rejecting if the current vertex equals $t$. Such a counter convention only shifts the index by one and preserves correctness because $N$ bounds the length of any simple path.\n\nComparing with the options:\n- Option A precisely implements the universal branching induction for $R_{k}(u)$ with a counter bounded by $N$, rejecting if $u=t$, accepting at the counter limit, universally exploring all neighbors, and accepting vacuously when no neighbors exist. This matches the correct ATM logic for UNREACHABILITY.\n- Option B uses an existential state to accept upon finding a path to $t$, which decides REACHABILITY rather than UNREACHABILITY. The acceptance criterion is inverted for the complement problem, so it is incorrect.\n- Option C misuses alternation: it universally branches over vertices and then existentially accepts if there exist paths $s \\to v$ and $v \\to t$. In a universal state, acceptance requires all children to accept; making a child accept when a witness exists would not force rejection when a witness exists, contradicting the intended logic. Thus, it is incorrect.\n- Option D existentially chooses neighbors and universally enforces only local conditions, accepting if it is possible to continue for $N$ steps while avoiding $t$. This would accept if there exists a long $t$-avoiding walk, which does not imply that $t$ is unreachable. Hence, it is incorrect.\n\nTherefore, the correct description is given by Option A.", "answer": "$$\\boxed{A}$$", "id": "1411930"}, {"introduction": "Having explored existential and universal states separately, we can now combine them to solve problems with more complex logical structures. This final practice [@problem_id:1411943] asks you to design an ATM that determines if a graph has *exactly one* perfect matching, a problem with deep implications in resource allocation and verification protocols. The logical structure of \"uniqueness\" requires two steps: first, showing that *there exists* at least one solution, and second, showing that *for all* other candidates, they are either not solutions or are identical to the first one. This `∃∀` pattern of quantifiers translates directly into an ATM that alternates from an existential to a universal state, showcasing the machine's ability to solve problems beyond NP and co-NP, in a class known as $\\Sigma_2^P$.", "problem": "The design of robust verification protocols is a central theme in computer science. Consider a scenario involving a task allocation system where there are $n$ tasks, represented by the set of vertices $U$, and $n$ computational resources, represented by the set of vertices $V$. The compatibility between tasks and resources is modeled as a bipartite graph $G=(U \\cup V, E)$, where an edge $(u, v) \\in E$ exists if task $u \\in U$ can be processed by resource $v \\in V$. A \"perfect allocation\" is a complete assignment of each task to a unique resource, which corresponds to a perfect matching in the graph $G$. A perfect matching is formally defined as a subset of edges $M \\subseteq E$ such that every vertex in the graph $U \\cup V$ is an endpoint of exactly one edge in $M$.\n\nYour objective is to design a high-level algorithm for an Alternating Turing Machine (ATM) that decides the language `UniquePerfectMatching`, which consists of all bipartite graphs that have exactly one perfect matching. An ATM is a non-deterministic Turing machine whose states are partitioned into existential states and universal states. From an existential state, the machine accepts if at least one computation path leads to an accepting state. From a universal state, the machine accepts only if all computation paths lead to an accepting state.\n\nWhich of the following high-level descriptions for an ATM correctly decides if a given bipartite graph $G=(U \\cup V, E)$ with $|U|=|V|=n$ has exactly one perfect matching?\n\nA. Start in an existential state to guess a set of edges $M_1$. The machine checks if $M_1$ is a perfect matching. If it is, the machine transitions to a universal state. From this universal state, it guesses another set of edges $M_2$. This universal path leads to acceptance if $M_2$ is not a perfect matching, or if $M_2$ is identical to $M_1$. The ATM as a whole accepts if the initial existential guess for $M_1$ was a valid perfect matching and all subsequent universal paths from that point led to acceptance.\n\nB. Start in a universal state to guess a set of edges $M_1$. The machine transitions to an existential state to guess another set of edges $M_2$. This path leads to acceptance if $M_1$ is a perfect matching, $M_2$ is a perfect matching, and $M_1$ is different from $M_2$. The ATM as a whole accepts if for every initial universal guess of $M_1$, there exists an existential guess of $M_2$ for which the path is accepted.\n\nC. Start in an existential state to guess two distinct sets of edges, $M_1$ and $M_2$. The machine accepts if both $M_1$ and $M_2$ are perfect matchings.\n\nD. Start in a universal state to guess a set of edges $M$. The machine accepts on this path if $M$ is not a perfect matching. The ATM as a whole accepts if this holds for all possible sets of edges $M$.\n\nE. Start in an existential state to guess a set of edges $M_1$. The machine checks if $M_1$ is a perfect matching. If not, this path rejects. If it is, the machine transitions to a universal state and guesses another set of edges $M_2$. This universal path leads to acceptance only if $M_2$ is a perfect matching and $M_2$ is different from $M_1$.", "solution": "To determine the correct Alternating Turing Machine (ATM) algorithm for the `UniquePerfectMatching` problem, we first need to express the condition \"a graph $G$ has exactly one perfect matching\" using formal logic with quantifiers. This logical structure can then be mapped directly to the computational steps of an ATM.\n\nA graph $G$ has exactly one perfect matching if two conditions are met simultaneously:\n1.  There exists at least one perfect matching.\n2.  There do not exist two distinct perfect matchings.\n\nLet's denote `IsPM(M)` as a predicate that is true if the edge set $M$ is a perfect matching in $G$. We can write the property of having a unique perfect matching as a logical formula:\n\n$$ \\exists M_1 \\left( \\text{IsPM}(M_1) \\land \\forall M_2 \\left( \\text{IsPM}(M_2) \\implies M_2 = M_1 \\right) \\right) $$\n\nThis formula reads: \"There exists a set of edges $M_1$ such that $M_1$ is a perfect matching, AND for all sets of edges $M_2$, if $M_2$ is a perfect matching, then $M_2$ must be equal to $M_1$.\"\n\nThe logical connective `P ⇒ Q` is equivalent to `¬P ∨ Q`. Applying this to the inner part of our formula, we get:\n\n$$ \\forall M_2 \\left( \\neg \\text{IsPM}(M_2) \\lor M_2 = M_1 \\right) $$\n\nThis reads: \"For all sets of edges $M_2$, either $M_2$ is not a perfect matching, or $M_2$ is equal to $M_1$.\"\n\nSo, the full logical statement for Unique Perfect Matching is:\n$$ \\exists M_1 \\left( \\text{IsPM}(M_1) \\land \\forall M_2 \\left( \\neg \\text{IsPM}(M_2) \\lor M_2 = M_1 \\right) \\right) $$\n\nNow we can translate this structure into an ATM algorithm:\n\n1.  **`∃ M₁`**: The computation starts in an existential state. In this state, the ATM non-deterministically \"guesses\" a set of edges $M_1$. This means the machine branches into multiple computation paths, one for each possible edge set $M_1$. The machine will accept if any of these branches ultimately accept.\n\n2.  **`IsPM(M₁)`**: After guessing $M_1$, the machine performs a deterministic check to verify if $M_1$ is indeed a perfect matching. This involves checking if $M_1$ contains $|U|=n$ edges and if every vertex in $U \\cup V$ has a degree of exactly one. This check can be done in polynomial time. If $M_1$ is not a perfect matching, this existential branch fails and rejects.\n\n3.  **`∧`**: If the `IsPM(M₁)` check passes, the machine proceeds to evaluate the second part of the conjunction.\n\n4.  **`∀ M₂`**: To evaluate the universally quantified part, the machine transitions from an existential state to a universal state. In this state, the machine non-deterministically \"guesses\" another set of edges $M_2$. Because the state is universal, all of these computation branches (one for each possible $M_2$) must lead to an accepting state for this part of the computation to be successful.\n\n5.  **`¬IsPM(M₂) ∨ M₂ = M₁`**: For each universally guessed $M_2$, the machine performs another deterministic check. It evaluates if `IsPM(M₂)` is false, or if `M₂` is identical to the initially guessed `M₁`. If this condition holds, the universal branch accepts. If the condition fails (meaning $M_2$ is a perfect matching and it is different from $M_1$), this universal branch rejects. A single rejection on any universal branch causes the entire universal computation (starting from the `∀ M₂` step) to reject.\n\nThis ATM accepts if and only if there's a way to choose a perfect matching $M_1$ such that for all other possible edge sets $M_2$, they are either not perfect matchings or are just $M_1$ itself. This exactly corresponds to the definition of a unique perfect matching.\n\nLet's analyze the given options:\n- **A**: This option precisely describes the algorithm we derived. It starts with an existential guess for $M_1$, verifies it's a perfect matching, switches to a universal state to guess $M_2$, and accepts on a universal path if `$M_2$ is not a perfect matching, or if $M_2$ is identical to $M_1$`. This is correct.\n- **B**: This describes a `∀∃` (or $\\Pi_2$) computation. The logic is incorrect and would check for a property different from unique perfect matching.\n- **C**: This existential-only machine checks for the existence of at least two perfect matchings. It decides a subset of the complement of our language.\n- **D**: This universal-only machine checks if there are no perfect matchings at all. This decides the language `NonPerfectMatching`, which is coNP-complete.\n- **E**: This option has the correct alternation structure (`∃∀`), but the logic in the universal part is flawed. It requires $M_2$ to be a *different* perfect matching for the path to accept which is the opposite of what is needed to prove uniqueness.\n\nTherefore, option A is the only one that correctly describes an ATM for deciding the `UniquePerfectMatching` language.", "answer": "$$\\boxed{A}$$", "id": "1411943"}]}