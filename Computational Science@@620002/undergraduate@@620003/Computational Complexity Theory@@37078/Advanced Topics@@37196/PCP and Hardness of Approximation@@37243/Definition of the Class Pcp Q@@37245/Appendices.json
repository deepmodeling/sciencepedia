{"hands_on_practices": [{"introduction": "To understand a new concept, it's often helpful to connect it to a familiar one. This first exercise bridges the gap between the well-known complexity class NP and the definition of a Probabilistically Checkable Proof (PCP). By thinking about a standard NP verifier as a \"naive\" PCP verifier that simply reads an entire certificate, you will see how NP naturally fits into the PCP framework and gain a concrete understanding of the randomness ($r(n)$) and query ($q(n)$) complexity parameters. [@problem_id:1420240]", "id": "1420240", "problem": "In computational complexity theory, the class NP, which stands for Nondeterministic Polynomial time, consists of all decision problems for which a 'yes' instance has a certificate that can be verified in polynomial time. Formally, a language $L$ is in NP if there exists a polynomial-time deterministic Turing machine $V$, called a verifier, and a polynomial $p$, such that for any input $x$ of length $n$:\n- If $x \\in L$, there exists a certificate string $c$ of length $|c| \\le p(n)$ such that $V(x, c)$ accepts.\n- If $x \\notin L$, for all certificates $c$ with $|c| \\le p(n)$, $V(x, c)$ rejects.\n\nSeparately, the class PCP($r(n), q(n)$), for Probabilistically Checkable Proofs, is defined. A language $L$ is in PCP($r(n), q(n)$) if there exists a probabilistic polynomial-time verifier $V$ that has oracle access to a proof string $\\pi$. For an input $x$ of length $n$, the verifier $V$ uses at most $O(r(n))$ random bits and makes at most $O(q(n))$ non-adaptive queries to the proof $\\pi$. The conditions are:\n- Completeness: If $x \\in L$, there exists a proof $\\pi$ such that $V^{\\pi}(x)$ accepts with probability 1.\n- Soundness: If $x \\notin L$, for all proofs $\\pi'$, $V^{\\pi'}(x)$ accepts with probability at most $1/2$.\n\nNow, consider a language $L \\in \\text{NP}$. We can model the standard NP verification process using the PCP framework. Let the NP certificate $c$ be treated as the PCP proof $\\pi$. Suppose we construct a special, \"naive\" PCP verifier that, for a given input $x$, simply emulates the original NP verifier. This naive verifier deterministically reads the *entire* proof $\\pi$ (of length at most $p(n)$) and then decides to accept or reject, exactly as the NP verifier $V$ would.\n\nWhich of the following choices correctly describes the randomness and query complexity, $(r(n), q(n))$, for this specific naive verifier?\n\nA. $r(n) = 0$, $q(n) = p(n)$\nB. $r(n) = O(\\log n)$, $q(n) = O(1)$\nC. $r(n) = p(n)$, $q(n) = 0$\nD. $r(n) = 0$, $q(n) = O(\\log n)$\nE. $r(n) = O(\\log p(n))$, $q(n) = O(1)$\n\n", "solution": "By definition of NP, there exists a deterministic polynomial-time verifier $V$ and a polynomial $p$ such that for any input $x$ of length $n$, a certificate $c$ of length $|c| \\le p(n)$ causes $V(x,c)$ to accept iff $x \\in L$. To model this in the PCP framework, we take the proof oracle $\\pi$ to be exactly the certificate $c$.\n\nConsider the described naive PCP verifier: on input $x$, it deterministically reads the entire proof $\\pi$ and emulates $V(x,\\pi)$. Since the verifier is deterministic and does not flip any coins, the number of random bits used is\n$$\nr(n) = 0.\n$$\nIn the PCP model, a query is an access to an index of the proof oracle $\\pi$. Reading the entire proof of length at most $p(n)$ requires querying each position of $\\pi$, hence the number of non-adaptive queries satisfies\n$$\nq(n) = p(n).\n$$\nThis verifier has completeness probability $1$ (if $x \\in L$, there exists $\\pi$ making it accept) and soundness probability $0$ (if $x \\notin L$, it rejects for all $\\pi$), which is consistent with the PCP definitionâ€™s soundness requirement of at most $\\frac{1}{2}$.\n\nTherefore, the correct choice for the randomness and query complexity is the pair $(r(n), q(n)) = (0, p(n))$, which corresponds to option A.", "answer": "$$\\boxed{A}$$"}, {"introduction": "Having established a baseline, we now explore the true power and elegance of this framework. The celebrated PCP theorem reveals a surprisingly efficient method for checking proofs for any problem in the class NP. This thought-provoking exercise asks you to apply the core statement of the PCP theorem, connecting a verifier with logarithmic randomness and constant query complexity to a major complexity class, highlighting the theorem's profound implications. [@problem_id:1420205]", "id": "1420205", "problem": "In the study of computational complexity, a Probabilistically Checkable Proof (PCP) system for a language $L$ provides a method for verifying a proof that a given string $x$ belongs to $L$. A verifier in such a system is a probabilistic algorithm that has access to the input string $x$ and a separate proof string $\\pi$. The complexity of the verifier is measured by its randomness complexity $r(n)$ and its query complexity $q(n)$, where $n$ is the size of the input $x$. The function $r(n)$ represents the number of random bits the verifier uses, and $q(n)$ represents the number of bits it reads from the proof string $\\pi$. The class of all languages that have a PCP system with these parameters is denoted PCP($r(n), q(n)$).\n\nConsider a specific type of PCP verifier designed for a class of problems. For any given input of size $n$, this verifier operates as follows:\n1.  It uses exactly $\\log_2 n$ random bits. These bits are used to uniquely and uniformly select an index from a set of $n$ possible starting locations within the proof string.\n2.  After selecting a starting location, the verifier reads a sequence of $c$ bits from the proof string, where $c$ is a fixed positive integer constant that does not depend on $n$.\n3.  The verifier then makes its decision to accept or reject based solely on the $c$ bits it has read.\n\nAccording to the celebrated PCP theorem, which relates such proof systems to standard complexity classes, the class of all languages that can be decided by a verifier with the behavior described above is equivalent to one of the following well-known complexity classes. Which one is it?\n\nA. P (Polynomial Time)\nB. NP (Nondeterministic Polynomial Time)\nC. PSPACE (Polynomial Space)\nD. L (Logarithmic Space)\nE. EXP (Exponential Time)\n\n", "solution": "We are given a verifier that, on inputs of length $n$, uses exactly $r(n)=\\log_{2} n$ random bits to choose uniformly one of $n$ starting locations in a proof string, then reads exactly $q(n)=c$ proof bits (with $c$ a fixed positive constant independent of $n$), and decides to accept or reject based solely on those $c$ bits. The collection of languages decidable by such verifiers is, by definition, $\\mathrm{PCP}(\\log_{2} n, c)$.\n\nBy the PCP theorem, there exist absolute constants $c_{0},d_{0}>0$ such that\n$$\n\\mathrm{NP}=\\mathrm{PCP}(d_{0}\\log_{2} n, c_{0}).\n$$\nIn particular, $\\mathrm{NP}\\subseteq \\mathrm{PCP}(O(\\log n),O(1))$ and, conversely, $\\mathrm{PCP}(O(\\log n),O(1))\\subseteq \\mathrm{NP}$. We now align the given verifier with these parameters and argue both inclusions to conclude equality with $\\mathrm{NP}$.\n\nFirst, observe that the number of possible random strings the verifier can use is\n$$\nR(n)=2^{r(n)}=2^{\\log_{2} n}=n.\n$$\nThus, there are exactly $n$ random choices. The verifier is polynomial-time by the definition of $\\mathrm{PCP}(r,q)$, and it queries only $q(n)=c$ bits per random choice.\n\nInclusion $\\mathrm{PCP}(\\log_{2} n,c)\\subseteq \\mathrm{NP}$: Let $L\\in \\mathrm{PCP}(\\log_{2} n,c)$ with completeness $a$ and soundness $b$, where $a,b\\in[0,1]$ are fixed constants and $a-b\\geq \\delta$ for some fixed $\\delta>0$. On input $x$ of length $n$, consider the nondeterministic algorithm that guesses a proof $\\pi$ containing all proof locations that might be read. Because the verifier selects one of $n$ starting positions and reads $c$ bits from each, the total set of queried positions over all random strings has size at most $n\\cdot c$, so the portion of $\\pi$ relevant to verification has length $O(n)$ and can be guessed in polynomial time. The algorithm then deterministically simulates the verifier on all $R(n)=n$ random strings, counting the number of accepting outcomes. It accepts if and only if at least $a\\cdot R(n)$ of these simulations accept. Each simulation uses time polynomial in $n$, and there are $n$ simulations, so the total deterministic verification time is polynomial in $n$. Therefore, membership in $L$ can be decided by an $\\mathrm{NP}$ machine, establishing $\\mathrm{PCP}(\\log_{2} n,c)\\subseteq \\mathrm{NP}$.\n\nInclusion $\\mathrm{NP}\\subseteq \\mathrm{PCP}(\\log_{2} n,c')$ for some constant $c'$ is exactly the content of the PCP theorem: every language in $\\mathrm{NP}$ has a polynomial-time probabilistic verifier using $O(\\log n)$ random bits and $O(1)$ queries. Adjusting constant factors and bases of the logarithm only changes $d_{0}$ and $c_{0}$ by constants, so the given form with exactly $\\log_{2} n$ random bits and a constant number of queries is covered.\n\nCombining both directions, the class of languages decidable by the described verifier is exactly $\\mathrm{NP}$. Among the options provided, this corresponds to B.", "answer": "$$\\boxed{B}$$"}, {"introduction": "The definitions in complexity theory often use specific constants, like a soundness probability of $1/2$, which might seem arbitrary. This practice allows you to investigate the robustness of the PCP model by changing the standard completeness and soundness probabilities. By analyzing the power of a verifier with a completeness of at least $2/3$ and a soundness of at most $1/3$, you will discover the fundamental principle that matters is the *gap* between these probabilities, not their exact values. [@problem_id:1420219]", "id": "1420219", "problem": "A Probabilistically Checkable Proof (PCP) system allows a randomized verifier to check a mathematical proof by only examining a few of its bits. For a language $L$, a verifier $V$ is a probabilistic polynomial-time algorithm that, for an input $x$ of length $n$, is given oracle access to a proof string $\\pi$. The verifier uses at most $r(n)$ random bits and queries at most $q(n)$ bits of the proof. The length of the proof $\\pi$ is assumed to be polynomial in $n$.\n\nThe standard complexity class $\\text{PCP}(r(n), q(n))$, formally denoted as $\\text{PCP}_{1, 1/2}(r(n), q(n))$, is the set of all languages $L$ that have a PCP system with the following properties:\n- **Completeness**: If $x \\in L$, there exists a proof $\\pi$ such that the verifier $V$ accepts with probability 1.\n- **Soundness**: If $x \\notin L$, for any proof $\\pi'$, the verifier $V$ accepts with probability at most $1/2$.\n\nThe celebrated PCP theorem establishes a deep connection between NP and PCPs, stating that $\\text{NP} = \\text{PCP}(O(\\log n), O(1))$.\n\nNow, let's consider a modified definition of a PCP class, which we will call $\\text{PCP}'(r(n), q(n))$. This class, more formally denoted as $\\text{PCP}_{2/3, 1/3}(r(n), q(n))$, is defined for languages having a PCP system with the following different probability thresholds:\n- **Modified Completeness**: If $x \\in L$, there exists a proof $\\pi$ such that $V$ accepts with probability at least $2/3$.\n- **Modified Soundness**: If $x \\notin L$, for any proof $\\pi'$, $V$ accepts with probability at most $1/3$.\n\nYour task is to analyze the computational power of this modified PCP system under the same resource constraints as in the PCP theorem. Specifically, identify the complexity class that is equal to $\\text{PCP}'(O(\\log n), O(1))$. Your answer should be the common name of a major, well-known complexity class.\n\n", "solution": "Let $r(n)$ and $q(n)$ denote the randomness and query bounds, respectively.\n\nFirst inclusion: $\\text{NP} \\subseteq \\text{PCP}'(O(\\log n), O(1))$.\nBy the PCP theorem, for every $L \\in \\text{NP}$ there exists a verifier $V$ with parameters $r(n) = O(\\log n)$ and $q(n) = O(1)$ such that\n- completeness: if $x \\in L$ then $\\exists \\pi$ with $\\Pr_{R}[V^{\\pi}(x; R)=1]=1$,\n- soundness: if $x \\notin L$ then $\\forall \\pi'$, $\\Pr_{R}[V^{\\pi'}(x; R)=1] \\le \\frac{1}{2}$.\nDefine $V'$ that runs two independent copies of $V$ on independent random strings $R_{1}, R_{2}$ and accepts iff both copies accept. Then\n- if $x \\in L$ and $\\pi$ is a witnessing proof, the acceptance probability is\n$$\n\\Pr[V'^{\\pi}(x; R_{1},R_{2})=1] \\;=\\; \\Pr[V^{\\pi}(x; R_{1})=1] \\cdot \\Pr[V^{\\pi}(x; R_{2})=1] \\;=\\; 1 \\cdot 1 \\;=\\; 1 \\;\\ge\\; \\frac{2}{3},\n$$\n- if $x \\notin L$, for every $\\pi'$,\n$$\n\\Pr[V'^{\\pi'}(x; R_{1},R_{2})=1] \\;\\le\\; \\left(\\frac{1}{2}\\right)^{2} \\;=\\; \\frac{1}{4} \\;\\le\\; \\frac{1}{3}.\n$$\nThe resource bounds satisfy $r'(n)=2r(n)=O(\\log n)$ and $q'(n)=2q(n)=O(1)$. Hence $L \\in \\text{PCP}'(O(\\log n), O(1))$ and therefore $\\text{NP} \\subseteq \\text{PCP}'(O(\\log n), O(1))$.\n\nSecond inclusion: $\\text{PCP}'(O(\\log n), O(1)) \\subseteq \\text{NP}$.\nLet $L \\in \\text{PCP}'(O(\\log n), O(1))$ with verifier $V$ using at most $r(n) \\le c_{r} \\log n$ random bits and at most $q(n) \\le c_{q}$ queries, and with proof length polynomial in $n=|x|$. For any fixed $x$ and proof $\\pi$, let\n$$\nT \\;=\\; 2^{r(n)} \\;\\le\\; 2^{c_{r} \\log n} \\;=\\; n^{c_{r}},\n$$\nand define\n$$\nA(x,\\pi) \\;=\\; \\left| \\{ R \\in \\{0,1\\}^{r(n)} : V^{\\pi}(x; R)=1 \\} \\right|.\n$$\nThen the acceptance probability is exactly $A(x,\\pi)/T$. A nondeterministic polynomial-time machine can guess $\\pi$ and compute $A(x,\\pi)$ by enumerating all $T$ random strings and simulating $V$, which takes time $T \\cdot \\text{poly}(n) = n^{O(1)}$. It accepts iff\n$$\n\\frac{A(x,\\pi)}{T} \\;\\ge\\; \\frac{2}{3} \\quad\\Longleftrightarrow\\quad 3A(x,\\pi) \\;\\ge\\; 2T.\n$$\nIf $x \\in L$, there exists $\\pi$ with acceptance probability at least $\\frac{2}{3}$, so the machine accepts. If $x \\notin L$, then for every $\\pi'$ the acceptance probability is at most $\\frac{1}{3}$, hence $3A(x,\\pi') \\le T < 2T$ and the machine rejects. Therefore $L \\in \\text{NP}$.\n\nCombining the two inclusions gives\n$$\n\\text{PCP}'(O(\\log n), O(1)) \\;=\\; \\text{NP}.\n$$", "answer": "$$\\boxed{\\text{NP}}$$"}]}