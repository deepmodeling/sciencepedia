{"hands_on_practices": [{"introduction": "The most direct way to understand a reduction is to see when two problems are simply different perspectives on the same underlying structure. This first practice invites you to explore such a scenario, connecting the practical problem of scheduling jobs on servers to the classic combinatorial problem of bin packing. By formalizing this connection, you will demonstrate how a reduction can sometimes be a straightforward translation that perfectly preserves the approximation gap [@problem_id:1425491].", "problem": "You are a software engineer at a cloud computing company. Your team is tasked with developing a service for scheduling customer jobs on a cluster of identical servers. Formally, this is the classic problem of scheduling jobs on parallel machines to minimize the makespan.\n\nYou are focusing on a promise-based decision version of the problem, which we will call `Gap-Makespan`. An instance of `Gap-Makespan` is defined by a set of $n$ jobs with known processing times $\\{p_1, p_2, \\dots, p_n\\}$, a number of identical servers $m$, and a target deadline $T$. The problem instance is guaranteed to satisfy one of two conditions:\n1.  (YES-Instance) The optimal makespan is less than or equal to the deadline $T$. That is, $C_{\\max}^{*} \\le T$.\n2.  (NO-Instance) The optimal makespan is strictly greater than $T \\cdot g_{MS}$, where $g_{MS} > 1$ is a performance gap parameter. That is, $C_{\\max}^{*} > T \\cdot g_{MS}$.\n\nYour task is to build a solver that can distinguish between these two cases.\n\nFortunately, your company has access to a proprietary software library, `CapacityOptimizer`. This library solves a gapped version of a bin packing problem, which we will call `Gap-Capacity`. An instance of `Gap-Capacity` is defined by a set of $n$ items with sizes $\\{s_1, s_2, \\dots, s_n\\}$, a fixed number of bins $k$, and a target bin capacity $C$. The `CapacityOptimizer` library is guaranteed to correctly distinguish between the following two cases:\n1.  (YES-Instance) The minimum bin capacity required to pack all items into the $k$ bins is less than or equal to the target capacity $C$.\n2.  (NO-Instance) The minimum bin capacity required to pack all items into the $k$ bins is strictly greater than $C \\cdot g_{CO}$, where $g_{CO} > 1$ is the library's built-in performance gap.\n\nFor any input that does not satisfy one of these two promises, the library's output is undefined.\n\nDescribe a procedure for solving an instance of the `Gap-Makespan` problem by making a call to the `CapacityOptimizer` library. Based on your procedure, if the `CapacityOptimizer` library guarantees a performance gap of $g_{CO}$, what is the corresponding performance gap, $g_{MS}$, that your new scheduling service can guarantee? Express your answer as a symbolic expression in terms of $g_{CO}$.", "solution": "We are given an instance of Gap-Makespan with jobs having processing times $\\{p_{1},\\dots,p_{n}\\}$, $m$ identical machines, and a target deadline $T$. Let the optimal makespan be $C_{\\max}^{*}$, defined as\n$$\nC_{\\max}^{*}=\\min_{\\{M_{1},\\dots,M_{m}\\}}\\max_{j\\in\\{1,\\dots,m\\}}\\sum_{i\\in M_{j}}p_{i},\n$$\nwhere $\\{M_{1},\\dots,M_{m}\\}$ is a partition of the jobs into $m$ disjoint sets assigned to the machines.\n\nConstruct a Gap-Capacity instance as follows:\n- Items: sizes $s_{i}=p_{i}$ for $i\\in\\{1,\\dots,n\\}$.\n- Number of bins: $k=m$.\n- Target capacity: $C=T$.\n\nThe packing feasibility for capacity $C$ is equivalent to the existence of a schedule with makespan at most $C$, because packing the items into $m$ bins of capacity $C$ means there exists a partition $\\{M_{1},\\dots,M_{m}\\}$ with $\\sum_{i\\in M_{j}}p_{i}\\leq C$ for all $j$, which is exactly a schedule with makespan at most $C$. Therefore, the minimum bin capacity sufficient to pack the items into $k=m$ bins equals the optimal makespan:\n$$\nC_{\\text{pack}}^{*}=C_{\\max}^{*}.\n$$\n\nNow call CapacityOptimizer on the constructed Gap-Capacity instance with capacity $C=T$. By the library’s guarantee, it distinguishes between:\n- YES: $C_{\\text{pack}}^{*}\\leq T$,\n- NO: $C_{\\text{pack}}^{*}>T\\cdot g_{CO}$.\n\nUsing $C_{\\text{pack}}^{*}=C_{\\max}^{*}$, this becomes:\n- YES: $C_{\\max}^{*}\\leq T$,\n- NO: $C_{\\max}^{*}>T\\cdot g_{CO}$.\n\nHence, the procedure is:\n- If CapacityOptimizer returns YES, output YES for Gap-Makespan.\n- If CapacityOptimizer returns NO, output NO for Gap-Makespan.\n\nBecause Gap-Makespan instances are promised to be either $C_{\\max}^{*}\\leq T$ or $C_{\\max}^{*}>T\\cdot g_{MS}$, and the constructed Gap-Capacity instance satisfies the corresponding promises with $g_{MS}=g_{CO}$, the solver correctly distinguishes the two promised cases. Therefore, the achievable performance gap for Gap-Makespan equals the library’s gap:\n$$\ng_{MS}=g_{CO}.\n$$", "answer": "$$\\boxed{g_{CO}}$$", "id": "1425491"}, {"introduction": "Reductions often involve actively constructing a new problem instance from an old one, a process that can alter the approximation gap in predictable ways. In this exercise, you will engineer a reduction from an unweighted graph problem to a weighted one by introducing new vertices and assigning them specific weights. Your task is to analyze how the parameters of your construction—the ratio of new vertices and the ratio of their weights—systematically compress the gap, providing a tangible example of how a reduction's design directly influences its properties [@problem_id:1425433].", "problem": "Consider the promise problem known as Gapped Maximum Independent Set, denoted Gap-MIS$[c,s]$. In this problem, given a graph $G$ with $n$ vertices, it is promised that the size of its Maximum Independent Set (MIS), $\\alpha(G)$, satisfies one of two conditions: either $\\alpha(G) \\geq c n$ (a \"YES\" instance) or $\\alpha(G) \\leq s n$ (a \"NO\" instance), for some fixed constants $0 < s < c < 1$.\n\nWe wish to perform a gap-preserving reduction from Gap-MIS$[c,s]$ to a gapped version of the Weighted Maximum Independent Set (WMIS) problem, Gap-WMIS$[c',s']$. An instance of Gap-WMIS is a pair $(G', w')$, where $G'$ is a graph and $w'$ is a weight function on its vertices. It is a \"YES\" instance if the maximum weight of an independent set, $\\alpha_{w'}(G')$, is at least $c' \\cdot W_{\\text{tot}}$, and a \"NO\" instance if $\\alpha_{w'}(G') \\leq s' \\cdot W_{\\text{tot}}$, where $W_{\\text{tot}}$ is the sum of the weights of all vertices in $G'$.\n\nThe proposed reduction transforms an unweighted graph $G=(V, E)$ with $|V|=n$ into a weighted graph $(G', w')$ as follows:\n1.  The new vertex set is $V' = V \\cup U$, where $U$ is a set of $k$ newly introduced vertices.\n2.  The new edge set is $E' = E$. The vertices in $U$ are isolated from all other vertices in $V'$ and from each other.\n3.  The weight function $w'$ is defined by assigning a weight $W_V$ to every vertex in $V$ and a weight $W_U$ to every vertex in $U$, where $W_V$ and $W_U$ are positive constants.\n\nThe parameters of this construction are fixed by two positive constant ratios: the ratio of new to original vertices, $k/n = K$, and the ratio of the vertex weights, $W_V/W_U = R$.\n\nThis reduction maps the original gap $[s, c]$ to a new gap $[s', c']$. The size of the original gap can be characterized by the difference $\\Delta = c - s$, and the new gap by $\\Delta' = c' - s'$. Your task is to determine the gap compression factor, defined as the ratio $\\frac{\\Delta'}{\\Delta}$. Express your answer as a closed-form analytic expression in terms of $K$ and $R$.", "solution": "Let the original unweighted instance be $G=(V,E)$ with $|V|=n$. The reduction produces $G'=(V',E')$ where $V'=V\\cup U$, $|U|=k$, and the vertices in $U$ are isolated. The weights are $w'(v)=W_{V}$ for $v\\in V$ and $w'(u)=W_{U}$ for $u\\in U$. The construction parameters are $K=k/n$ and $R=W_{V}/W_{U}$.\n\nSince the vertices in $U$ are isolated, any maximum weight independent set in $G'$ will contain all of $U$. The remainder of the set will be a maximum weight independent set of the subgraph induced by $V$. As all vertices in $V$ have the same weight $W_V$, this corresponds to a maximum independent set of $G$. Thus, the maximum weight of an independent set in $G'$ is:\n$$\n\\alpha_{w'}(G') = \\alpha(G) \\cdot W_{V} + k \\cdot W_{U}\n$$\nThe total vertex weight in $G'$ is:\n$$\nW_{\\text{tot}}=\\sum_{v\\in V'}w'(v)=n \\cdot W_{V}+k \\cdot W_{U}\n$$\nIn a \"YES\" instance of Gap-MIS, we have $\\alpha(G) \\geq c n$. The new ratio $c'$ is the maximum weight of the independent set divided by the total weight:\n$$\nc' = \\frac{(cn)W_V + kW_U}{nW_V + kW_U}\n$$\nIn a \"NO\" instance, we have $\\alpha(G) \\leq s n$. The new ratio $s'$ is:\n$$\ns' = \\frac{(sn)W_V + kW_U}{nW_V + kW_U}\n$$\nThe new gap width is $\\Delta' = c' - s'$:\n$$\n\\Delta' = \\frac{(cn)W_V + kW_U}{nW_V + kW_U} - \\frac{(sn)W_V + kW_U}{nW_V + kW_U} = \\frac{(c-s)nW_V}{nW_V + kW_U}\n$$\nSince $\\Delta = c - s$, we can write:\n$$\n\\Delta' = \\Delta \\cdot \\frac{nW_V}{nW_V + kW_U}\n$$\nThe gap compression factor is $\\frac{\\Delta'}{\\Delta}$:\n$$\n\\frac{\\Delta'}{\\Delta} = \\frac{nW_V}{nW_V + kW_U}\n$$\nTo express this in terms of $K$ and $R$, we can divide the numerator and denominator by $n \\cdot W_U$:\n$$\n\\frac{\\Delta'}{\\Delta} = \\frac{W_V/W_U}{W_V/W_U + (k/n)} = \\frac{R}{R+K}\n$$\nThis expression depends only on the chosen ratios $K$ and $R$, as required.", "answer": "$$\\boxed{\\frac{R}{R+K}}$$", "id": "1425433"}, {"introduction": "Not all reductions are straightforward, and even simple-looking transformations can have subtle and complex effects on the approximation gap. This final practice challenges you to analyze a seemingly simple reduction: adding a single \"universal\" vertex to a graph. You will discover that proving whether the reduction is truly gap-preserving requires a careful analysis across all possible inputs, revealing that the new gap may not be a simple constant multiple of the old one. This exercise highlights the rigor needed to validate a reduction and deepens your understanding of what it means for a gap to be \"preserved\" [@problem_id:1425471].", "problem": "In computational complexity theory, many optimization problems are studied in their gapped decision form. Consider the gapped decision version of the Minimum Vertex Cover (VC) problem, denoted `(1, s)`-GAP-VC. A vertex cover of an undirected graph is a subset of vertices such that every edge in the graph is incident to at least one vertex in the subset. For an instance `(G, k)` consisting of a graph `G` and an integer `k`, we are given the following promise:\n- **YES-instance**: The size of the minimum vertex cover of `G`, denoted `vc(G)`, satisfies `vc(G) <= k`.\n- **NO-instance**: The size of the minimum vertex cover of `G` satisfies `vc(G) > s * k`, for some constant gap factor `s > 1`.\n\nNow, consider a specific graph transformation, $T$. Given an undirected graph $G=(V, E)$ with $n$ vertices, the transformation $T(G)$ produces a new graph $G'=(V', E')$. The new graph $G'$ is constructed by adding a single new \"universal\" vertex, let's call it $u$, to the graph $G$ and connecting $u$ to all vertices that were originally in $V$. Formally, $V' = V \\cup \\{u\\}$ and $E' = E \\cup \\{(u,v) \\mid v \\in V\\}$.\n\nWe want to know if this transformation can be part of a polynomial-time gap-preserving reduction from `(1, s)`-GAP-VC on an instance `(G, k)` to `(1, s')`-GAP-VC on a corresponding instance `(G', k')`. Specifically, consider the reduction that maps an instance `(G, k)` to `(G', k+1)`. Assume that for any input instance `(G, k)`, we have `k < n-1`.\n\nWhich of the following statements correctly describes whether this mapping constitutes a valid gap-preserving reduction?\n\nA. Yes, this is a gap-preserving reduction that maintains the original gap factor, so `s' = s`.\n\nB. No, this is not a gap-preserving reduction. While a relationship exists, the new gap `s'` cannot be a fixed constant; it must depend on the parameter `k` from the original problem instance.\n\nC. No, this is not a gap-preserving reduction because the analysis shows that for any `s > 1`, the new gap factor `s'` would have to be less than or equal to 1.\n\nD. Yes, this is a gap-preserving reduction where the new gap factor `s'` is a constant that depends on `s` (for example, `s'=(s+1)/2`), and is strictly smaller than `s`.", "solution": "Let $G=(V,E)$ with $|V|=n$ and let $T(G)=G'=(V',E')$ be formed by adding a universal vertex $u$ adjacent to every $v \\in V$, so $V'=V \\cup \\{u\\}$ and $E'=E \\cup \\{(u,v): v \\in V\\}$. Consider mapping $(G,k) \\mapsto (G',k+1)$.\n\nFirst, compute $\\operatorname{vc}(G')$ in terms of $\\operatorname{vc}(G)$. Any vertex cover of $G'$ must cover:\n- all original edges $E$, and\n- all new edges $\\{(u,v): v \\in V\\}$.\n\nIf $u \\in$ the cover, then the new edges are all covered by $u$ and the remaining task is to cover $E$, which requires at least $\\operatorname{vc}(G)$ vertices from $V$. Thus there exists a cover of size $1+\\operatorname{vc}(G)$, and none smaller using $u$.\n\nIf $u \\notin$ the cover, then every edge $(u,v)$ must be covered by including $v$, hence all vertices of $V$ must be in the cover, yielding size $n$.\n\nTherefore\n$$\n\\operatorname{vc}(G')=\\min\\{1+\\operatorname{vc}(G),\\,n\\}.\n$$\nFor any $n$-vertex graph, $\\operatorname{vc}(G)=n-\\alpha(G)$, where $\\alpha(G)$ is the maximum independent set size. Since $\\alpha(G) \\ge 1$, we have $\\operatorname{vc}(G) \\le n-1$, hence $1+\\operatorname{vc}(G) \\le n$. Consequently,\n$$\n\\operatorname{vc}(G')=1+\\operatorname{vc}(G)\n$$\nfor all $G$.\n\nNow analyze the gap under $(G,k) \\mapsto (G',k+1)$.\n\nYES-instances: If $\\operatorname{vc}(G) \\le k$, then\n$$\n\\operatorname{vc}(G')=1+\\operatorname{vc}(G) \\le 1+k = k',\n$$\nso $(G',k')$ is a YES-instance.\n\nNO-instances: If $\\operatorname{vc}(G) > s\\,k$, then\n$$\n\\operatorname{vc}(G')=1+\\operatorname{vc}(G) > s\\,k + 1.\n$$\nTo ensure $(G',k')$ is a NO-instance for some constant $s' > 1$, we need\n$$\n\\operatorname{vc}(G') > s'(k+1),\n$$\nwhich is guaranteed if\n$$\ns'(k+1) \\le s\\,k + 1 \\quad \\text{for all allowed } k.\n$$\nEquivalently,\n$$\ns' \\le \\frac{s\\,k + 1}{k+1} = s - \\frac{s-1}{k+1}.\n$$\nThe function $f(k) = \\frac{sk+1}{k+1}$ is an increasing function for $k \\ge 0$ when $s > 1$. Therefore, to find a single constant $s'$ that works for all $k$, we must bound it by the minimum value of $f(k)$ over its allowed domain. Assuming standard problem constraints where $k \\ge 1$, the minimum occurs at $k=1$:\n$$\n\\min_{k \\ge 1} \\frac{s\\,k + 1}{k+1} = \\frac{s+1}{2}.\n$$\nTherefore we can choose a constant $s' = \\frac{s+1}{2}$. This choice ensures that for any $k \\ge 1$, if $\\operatorname{vc}(G) > sk$, then $\\operatorname{vc}(G') > sk+1 \\ge s'(k+1)$. Since $s>1$, we have $1  s'  s$.\n\nThe described mapping constitutes a valid polynomial-time gap-preserving reduction with a new constant gap factor $s'$ that is dependent on $s$ and strictly smaller than $s$.\n\nThus the correct choice is D.", "answer": "$$\\boxed{D}$$", "id": "1425471"}]}