{"hands_on_practices": [{"introduction": "The complexity class PP can seem abstract, but at its core, it is about counting. This exercise demystifies PP by framing a number-theoretic question as a decision problem for a Non-deterministic Turing Machine (NTM). By meticulously counting the accepting and rejecting computation paths for a specific input, you will gain a hands-on understanding of how the \"majority vote\" mechanism of PP operates in practice [@problem_id:1454741].", "problem": "A language $L$ is in the complexity class PP (Probabilistic Polynomial time) if there exists a polynomial-time non-deterministic Turing machine (NTM) such that for any input $x$, the input $x$ is in $L$ if and only if more than half of the computation paths of the NTM on input $x$ end in an accepting state.\n\nConsider a specific NTM, let's call it $M$, designed to operate on a positive integer input $N$. Let $n = \\lfloor \\log_2 N \\rfloor + 1$ be the number of bits in the standard binary representation of $N$. The machine $M$ performs the following steps:\n\n1.  It non-deterministically chooses a binary string $y$ of length $n$ and a bit $b \\in \\{0, 1\\}$. This process defines $2^{n+1}$ distinct computation paths, one for each unique pair $(y, b)$.\n2.  Let $d$ be the positive integer value represented by the binary string $y$.\n3.  The machine then applies the following logic to decide whether to accept or reject on a given computation path:\n    *   If $b=0$: The machine accepts if and only if ($d>0$, $d \\le N$, $d$ is a divisor of $N$, and $d$ is even). In all other cases for $b=0$, it rejects.\n    *   If $b=1$: The machine rejects if and only if ($d>0$, $d \\le N$, $d$ is a divisor of $N$, and $d$ is odd). In all other cases for $b=1$, it accepts.\n\nYour task is to calculate the total number of accepting computation paths for this machine $M$ when the input is $N = 90$.", "solution": "The input is $N=90$. The number of bits is $n=\\lfloor \\log_{2}(N) \\rfloor + 1$. Since $2^{6}=64 \\leq 90 < 128=2^{7}$, we have $\\lfloor \\log_{2}(90) \\rfloor=6$, hence\n$$\nn=7.\n$$\nThe machine nondeterministically chooses a pair $(y,b)$ with $y \\in \\{0,1\\}^{n}$ and $b \\in \\{0,1\\}$, yielding $2^{n+1}=2^{8}=256$ computation paths. The string $y$ represents an integer $d$ with $0 \\leq d \\leq 2^{n}-1=127$.\n\nDefine the following sets of $d$ values:\n- $E=\\{d: d>0,\\, d \\leq N,\\, d \\mid N,\\, d \\text{ even}\\}$, i.e., the positive even divisors of $N$.\n- $O=\\{d: d>0,\\, d \\leq N,\\, d \\mid N,\\, d \\text{ odd}\\}$, i.e., the positive odd divisors of $N$.\n- $C=\\{0,1,\\dots,127\\} \\setminus (E \\cup O)$, i.e., all remaining $d$ values.\n\nFactor $N$:\n$$\n90=2 \\cdot 3^{2} \\cdot 5.\n$$\nThe total number of positive divisors is $(1+1)(2+1)(1+1)=12$. Even divisors must include the factor $2$, so their count is\n$$\n|E|=1 \\cdot 3 \\cdot 2=6,\n$$\nand the odd divisors count is\n$$\n|O|=3 \\cdot 2=6.\n$$\nSince $d$ ranges over $128$ values, we have\n$$\n|C|=128-(|E|+|O|)=128-12=116.\n$$\n\nAcceptance by cases for each fixed $d$:\n- If $d \\in E$ (even divisor), then for $b=0$ the machine accepts, and for $b=1$ it also accepts (since the $b=1$ rejection condition requires $d$ odd). Thus, $2$ accepting paths per such $d$.\n- If $d \\in O$ (odd divisor), then for $b=0$ it rejects (not even), and for $b=1$ it rejects (explicit rejection condition). Thus, $0$ accepting paths per such $d$.\n- If $d \\in C$, then for $b=0$ it rejects (not an even divisor), and for $b=1$ it accepts (since $d$ is not a positive odd divisor of $N$). Thus, $1$ accepting path per such $d$.\n\nTherefore, the total number of accepting paths is\n$$\n2|E|+0|O|+1|C|=2 \\cdot 6+0 \\cdot 6+1 \\cdot 116=12+116=128.\n$$", "answer": "$$\\boxed{128}$$", "id": "1454741"}, {"introduction": "One of the best ways to grasp the scale of a complexity class is to see what famous problems it contains. This practice demonstrates the remarkable power of PP by showing that it includes the quintessential NP-complete problem, SAT. You will analyze a clever probabilistic construction that transforms the question of satisfiability into a probability gap, providing a clear proof that $\\text{NP} \\subseteq \\text{PP}$ [@problem_id:1454712].", "problem": "In computational complexity theory, the class PP (Probabilistic Polynomial Time) consists of decision problems solvable by a Probabilistic Turing Machine in polynomial time with an error probability of less than $1/2$. A Probabilistic Turing Machine (PTM) is a type of non-deterministic Turing machine where each transitional choice is augmented with a probability, typically a fair coin flip.\n\nLet's consider the Boolean Satisfiability Problem (SAT), which asks whether there exists a satisfying assignment for a given Boolean formula. Suppose we have a Boolean formula $\\phi$ with $n$ distinct variables. Let $S$ be the total number of unique assignments of truth values to these variables that make the formula $\\phi$ true.\n\nA PTM is constructed to work on the input $\\phi$. The PTM executes the following algorithm:\n1. It generates a variable assignment, denoted by $y$, by choosing a truth value (true or false) for each of the $n$ variables. Each of these $n$ choices is made uniformly and independently at random.\n2. It generates an additional random bit $b \\in \\{0, 1\\}$, where the probability of choosing $b=0$ is equal to the probability of choosing $b=1$. This choice is independent of the variable assignment.\n3. The PTM halts and accepts if the assignment $y$ satisfies the formula $\\phi$, OR if the random bit is $b=1$. If neither of these conditions is met, the PTM halts and rejects.\n\nYour task is to determine the exact probability that this PTM will accept. Express your answer as a single closed-form analytic expression in terms of $n$ and $S$.", "solution": "Let $A$ be the event that the random assignment $y$ satisfies $\\phi$, and let $B$ be the event that the random bit equals $1$. The PTM accepts if and only if $A \\cup B$ occurs.\n\nThere are $2^{n}$ possible assignments and exactly $S$ satisfying assignments, so\n$$\n\\Pr(A)=\\frac{S}{2^{n}}.\n$$\nThe bit is fair, so\n$$\n\\Pr(B)=\\frac{1}{2}.\n$$\nThe assignment and the bit are generated independently, hence\n$$\n\\Pr(A \\cap B)=\\Pr(A)\\Pr(B)=\\frac{S}{2^{n}} \\cdot \\frac{1}{2}=\\frac{S}{2^{n+1}}.\n$$\nBy the inclusion-exclusion principle,\n$$\n\\Pr(A \\cup B)=\\Pr(A)+\\Pr(B)-\\Pr(A \\cap B)=\\frac{S}{2^{n}}+\\frac{1}{2}-\\frac{S}{2^{n+1}}.\n$$\nCombine terms to obtain\n$$\n\\Pr(\\text{accept})=\\frac{1}{2}+\\frac{S}{2^{n+1}}=\\frac{2^{n}+S}{2^{n+1}}.\n$$", "answer": "$$\\boxed{\\frac{2^{n}+S}{2^{n+1}}}$$", "id": "1454712"}, {"introduction": "Not all probabilistic classes are created equal; the margin of error in the “majority vote” matters immensely. This exercise explores the critical difference between PP and the class BPP, which represents problems solvable by efficient and practical randomized algorithms. By examining a hypothetical class with a guaranteed wide probability gap, you'll discover why this gap is the defining feature that separates the two and what this implies about their respective computational power [@problem_id:1454728].", "problem": "In computational complexity theory, we study classes of problems based on the resources required to solve them. Consider a new complexity class we will call `StrongPP`. A language, which is a set of strings representing a decision problem, $L$ belongs to `StrongPP` if there exists a Probabilistic Polynomial-time Turing Machine (PPTM) $M$ that runs in time bounded by a polynomial in the input length, such that for any input string $x$:\n- If $x$ is in the language $L$ (i.e., $x \\in L$), the probability that $M$ accepts $x$ is at least $3/4$.\n- If $x$ is not in the language $L$ (i.e., $x \\notin L$), the probability that $M$ accepts $x$ is at most $1/4$.\n\nLet P, BPP (Bounded-error Probabilistic Polynomial time), and PP (Probabilistic Polynomial time) be the standard complexity classes. Which of the following statements accurately describes the relationship between `StrongPP` and these classes? (Note: `\\subset` denotes a proper subset, meaning the sets are not equal.)\n\nA. `StrongPP` = P\n\nB. `StrongPP` = PP\n\nC. `StrongPP` = BPP\n\nD. $P \\subset \\text{StrongPP} \\subset \\text{BPP}$\n\nE. $\\text{BPP} \\subset \\text{StrongPP} \\subset \\text{PP}$", "solution": "We compare the class defined as follows: a language $L$ is in StrongPP if there exists a probabilistic polynomial-time Turing machine $M$ such that for all inputs $x$, if $x \\in L$ then $\\Pr[M(x)\\text{ accepts}] \\geq \\frac{3}{4}$, and if $x \\notin L$ then $\\Pr[M(x)\\text{ accepts}] \\leq \\frac{1}{4}$.\n\nFirst, recall the standard definition of BPP: a language $L$ is in BPP if there exists a probabilistic polynomial-time Turing machine $M$ such that for all inputs $x$, if $x \\in L$ then $\\Pr[M(x)\\text{ accepts}] \\geq \\frac{2}{3}$, and if $x \\notin L$ then $\\Pr[M(x)\\text{ accepts}] \\leq \\frac{1}{3}$. It is standard that BPP is insensitive to the particular constant gap: any fixed constants $a,b$ with $a-b \\geq \\delta$ for some constant $\\delta>0$ and $a>\\frac{1}{2}>b$ yield the same class via error reduction by independent repetition and majority vote.\n\nInclusion StrongPP $\\subseteq$ BPP: The StrongPP thresholds already satisfy stronger bounds than the canonical BPP thresholds in the sense that $\\frac{3}{4} \\geq \\frac{2}{3}$ and $\\frac{1}{4} \\leq \\frac{1}{3}$. Therefore any language with a StrongPP witness machine also meets the BPP criterion directly, so StrongPP $\\subseteq$ BPP.\n\nInclusion BPP $\\subseteq$ StrongPP: Let $L \\in \\text{BPP}$. Then there exists a probabilistic polynomial-time machine $M$ such that\n$$\nx \\in L \\implies \\Pr[M(x)\\text{ accepts}] \\geq \\frac{2}{3}, \\quad x \\notin L \\implies \\Pr[M(x)\\text{ accepts}] \\leq \\frac{1}{3}.\n$$\nConstruct $M^{\\prime}$ that on input $x$ runs $M$ independently $k$ times and accepts iff strictly more than $\\frac{k}{2}$ runs accept (majority vote). Let $X_{1},\\dots,X_{k}$ be i.i.d. indicator variables for acceptance of each run, and $S=\\sum_{i=1}^{k} X_{i}$.\n\nFor $x \\in L$, we have $\\mathbb{E}[S] \\geq \\frac{2}{3}k$. The error event is $S \\leq \\frac{k}{2}$. By Hoeffding’s inequality for bounded independent variables in $[0,1]$,\n$$\n\\Pr\\left[S - \\mathbb{E}[S] \\leq -t\\right] \\leq \\exp\\left(-\\frac{2 t^{2}}{k}\\right).\n$$\nTaking $t = \\mathbb{E}[S] - \\frac{k}{2} \\geq \\frac{2}{3}k - \\frac{k}{2} = \\frac{k}{6}$, we get\n$$\n\\Pr\\left[S \\leq \\frac{k}{2}\\right] \\leq \\exp\\left(-\\frac{2 (\\frac{k}{6})^{2}}{k}\\right) = \\exp\\left(-\\frac{k}{18}\\right).\n$$\nThus for $x \\in L$, $\\Pr[M^{\\prime}(x)\\text{ accepts}] \\geq 1 - \\exp\\left(-\\frac{k}{18}\\right)$. Similarly, for $x \\notin L$, with $\\mathbb{E}[S] \\leq \\frac{1}{3}k$, the acceptance event $S \\geq \\frac{k}{2}$ is an upward deviation of at least $\\frac{k}{6}$, yielding\n$$\n\\Pr\\left[M^{\\prime}(x)\\text{ accepts}\\right] = \\Pr\\left[S \\geq \\frac{k}{2}\\right] \\leq \\exp\\left(-\\frac{k}{18}\\right).\n$$\nChoose any fixed integer $k$ satisfying\n$$\n\\exp\\left(-\\frac{k}{18}\\right) \\leq \\frac{1}{4} \\quad \\Longleftrightarrow \\quad k \\geq 18 \\ln 4.\n$$\nThis $k$ is a constant, so $M^{\\prime}$ runs in probabilistic polynomial time and achieves\n$$\nx \\in L \\implies \\Pr[M^{\\prime}(x)\\text{ accepts}] \\geq \\frac{3}{4}, \\quad x \\notin L \\implies \\Pr[M^{\\prime}(x)\\text{ accepts}] \\leq \\frac{1}{4}.\n$$\nHence $L \\in \\text{StrongPP}$, establishing BPP $\\subseteq$ StrongPP.\n\nCombining both inclusions gives StrongPP $=$ BPP. Therefore the correct choice among the options is C.\n\nFinally, observe why other options are incorrect or unsubstantiated: A would imply BPP $=$ P, which is open; B would imply BPP $=$ PP, which is not known and widely believed false; D and E assert proper containments that are not justified since we have equality StrongPP $=$ BPP.", "answer": "$$\\boxed{C}$$", "id": "1454728"}]}