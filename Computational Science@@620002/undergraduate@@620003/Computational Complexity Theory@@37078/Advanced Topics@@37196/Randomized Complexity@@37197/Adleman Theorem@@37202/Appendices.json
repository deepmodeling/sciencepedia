{"hands_on_practices": [{"introduction": "The proof of Adleman's theorem hinges on the existence of a single \"good\" random string that works for all inputs of a given length. This concept can feel abstract, so our first practice makes it tangible. By working through a small, concrete example, you will manually identify the valid advice strings for a toy algorithm, building a solid intuition for this powerful idea [@problem_id:1411206].", "problem": "In computational complexity theory, Adleman's theorem demonstrates a powerful connection between randomized and non-uniform computation, stating that any language in $BPP$ (Bounded-error Probabilistic Polynomial time) is also in $P/\\text{poly}$ (Polynomial time with advice). The core idea is that for a given input length $n$, there exists at least one \"good\" random string that can be used as an \"advice string\" to make a probabilistic algorithm deterministic and correct for all $2^n$ possible inputs of that length.\n\nThis problem asks you to explore this concept in a concrete setting. Consider a probabilistic algorithm, $A$, which takes a 2-bit input string $x \\in \\{0, 1\\}^2$ and uses a 3-bit random string $r \\in \\{0, 1\\}^3$. The algorithm is designed to decide membership in the language $L = \\{x \\in \\{0,1\\}^2 \\mid \\text{the two bits of } x \\text{ are different}\\}$. A return value of 1 signifies that the algorithm accepts the input (i.e., claims $x \\in L$), and 0 signifies rejection.\n\nThe behavior of algorithm $A$ is defined as follows for any input $x$ and random string $r$:\n- If $x = 00$, the algorithm returns 1 if $r \\in \\{011, 110\\}$; otherwise, it returns 0.\n- If $x = 01$, the algorithm returns 0 if $r \\in \\{010, 101\\}$; otherwise, it returns 1.\n- If $x = 10$, the algorithm returns 0 if $r \\in \\{001, 110\\}$; otherwise, it returns 1.\n- If $x = 11$, the algorithm returns 1 if $r \\in \\{001, 100\\}$; otherwise, it returns 0.\n\nAn \"advice string\" for this input length is a specific 3-bit string $r^*$ such that for that fixed string, the algorithm $A(x, r^*)$ produces the correct output for all four possible 2-bit inputs $x \\in \\{00, 01, 10, 11\\}$.\n\nIdentify all 3-bit strings that qualify as a valid advice string for algorithm $A$ at input length $n=2$. If there is more than one such string, provide them all.", "solution": "We require that for each input $x \\in \\{00,01,10,11\\}$, the fixed advice string $r^{\\ast} \\in \\{0,1\\}^{3}$ makes the deterministic computation $A(x,r^{\\ast})$ equal the correct language decision for $L=\\{01,10\\}$, namely output $0$ for $x \\in \\{00,11\\}$ and output $1$ for $x \\in \\{01,10\\}$.\n\nFrom the algorithm’s behavior:\n- For $x=00$, $A$ outputs $1$ if and only if $r \\in \\{011,110\\}$. Correctness requires output $0$, hence $r \\notin \\{011,110\\}$.\n- For $x=01$, $A$ outputs $0$ if and only if $r \\in \\{010,101\\}$. Correctness requires output $1$, hence $r \\notin \\{010,101\\}$.\n- For $x=10$, $A$ outputs $0$ if and only if $r \\in \\{001,110\\}$. Correctness requires output $1$, hence $r \\notin \\{001,110\\}$.\n- For $x=11$, $A$ outputs $1$ if and only if $r \\in \\{001,100\\}$. Correctness requires output $0$, hence $r \\notin \\{001,100\\}$.\n\nTherefore $r^{\\ast}$ must avoid the union of all forbidden sets:\n$$\nr^{\\ast} \\notin \\{011,110\\} \\cup \\{010,101\\} \\cup \\{001,110\\} \\cup \\{001,100\\}\n= \\{001,010,011,100,101,110\\}.\n$$\nSince $\\{0,1\\}^{3}=\\{000,001,010,011,100,101,110,111\\}$, the only candidates left are $000$ and $111$.\n\nVerification:\n- For $r^{\\ast}=000$: for $x=00$ the output is $0$; for $x=01$ the output is $1$; for $x=10$ the output is $1$; for $x=11$ the output is $0$—all correct.\n- For $r^{\\ast}=111$: the same evaluations yield outputs $0,1,1,0$ respectively—also all correct.\n\nHence the complete set of valid advice strings is exactly $\\{000,111\\}$.", "answer": "$$\\boxed{\\begin{pmatrix}000 & 111\\end{pmatrix}}$$", "id": "1411206"}, {"introduction": "Now that you have a concrete understanding of what an advice string is, let's examine how one is constructed. The proof of $BPP \\subseteq P/poly$ builds the advice string from the random bits used in many repeated trials of a probabilistic algorithm. This practice explores the quantitative relationship between the number of amplification runs, the random bits per run, and the total length of the resulting advice string, which must be polynomially bounded [@problem_id:1411176].", "problem": "In the context of computational complexity theory, Adleman's theorem shows that any problem solvable in Bounded-error Probabilistic Polynomial time ($BPP$) is also solvable in polynomial time with a polynomial-sized advice string (a class known as $P/\\text{poly}$). The proof of this theorem involves constructing a deterministic algorithm that uses a fixed 'good' random string as advice for a given input size.\n\nConsider a specific language $L$ in $BPP$. The probabilistic algorithm for $L$ is amplified by running it $k(n)$ times on an input of size $n$ and taking a majority vote of the outcomes. Each individual run of this algorithm requires $r(n)$ random bits. The advice string for the corresponding $P/\\text{poly}$ algorithm is formed by concatenating the random bits from all $k(n)$ runs.\n\nSuppose for this specific algorithm, the total length of the advice string, $A(n)$, is given by the polynomial $A(n) = 12n^4 - 3n^2$. It is also known that:\n1. The number of amplification runs, $k(n)$, is a linear function of $n$ with a positive integer coefficient, i.e., $k(n) = c \\cdot n$ for some integer $c > 0$.\n2. The number of random bits per run, $r(n)$, is a polynomial in $n$ of degree 3 with integer coefficients and a leading coefficient of 4.\n\nDetermine the polynomial expression for the number of runs, $k(n)$.", "solution": "For a $BPP$ algorithm amplified by $k(n)$ runs, each using $r(n)$ random bits, the total advice length equals the product of the number of runs and the number of random bits per run. Therefore,\n$$\nA(n)=k(n)\\,r(n).\n$$\nGiven $A(n)=12 n^{4}-3 n^{2}$, and $k(n)=c\\,n$ for some integer $c>0$, and $r(n)$ is a degree-$3$ polynomial with integer coefficients and leading coefficient $4$, write\n$$\nr(n)=4 n^{3}+\\alpha n^{2}+\\beta n+\\delta,\n$$\nwith $\\alpha,\\beta,\\delta\\in\\mathbb{Z}$. Then\n$$\nA(n)=k(n)\\,r(n)=c n\\left(4 n^{3}+\\alpha n^{2}+\\beta n+\\delta\\right)\n=4c\\,n^{4}+\\alpha c\\,n^{3}+\\beta c\\,n^{2}+\\delta c\\,n.\n$$\nEquate coefficients with $12 n^{4}-3 n^{2}$:\n- From $n^{4}$: $4c=12$, hence $c=3$.\n- From $n^{3}$: $\\alpha c=0$, hence $\\alpha=0$ since $c=3$.\n- From $n^{2}$: $\\beta c=-3$, hence $\\beta=-1$.\n- From $n^{1}$: $\\delta c=0$, hence $\\delta=0$.\n- The constant term matches as $0$.\n\nThus $k(n)=c\\,n=3n$, which is a linear function with positive integer coefficient as required.", "answer": "$$\\boxed{3n}$$", "id": "1411176"}, {"introduction": "The existence of a \"universally good\" advice string is not assumed; it is guaranteed by a probabilistic argument using the union bound. This argument only succeeds if the error probability on any single input is made exceptionally small through amplification. In this final practice, we will investigate a hypothetical scenario where this error reduction is insufficient, allowing you to pinpoint precisely why and where the proof of Adleman's theorem would fail [@problem_id:1411204].", "problem": "In computational complexity theory, Adleman's theorem states that the class of problems solvable by a Bounded-error Probabilistic Polynomial-time ($BPP$) algorithm is a subset of the class $P/\\text{poly}$ (problems solvable by a polynomial-time deterministic Turing machine given a polynomial-sized \"advice\" string that depends only on the input length).\n\nThe standard proof for $BPP \\subseteq P/\\text{poly}$ proceeds in two main stages. First, a $BPP$ algorithm with a constant error probability (e.g., $1/3$) is amplified by running it $k$ times and taking a majority vote. By choosing a sufficiently large polynomial $k(n)$, the error probability for any input $x$ of length $n$ can be reduced to be less than $2^{-n}$. Second, a probabilistic argument using the union bound is applied to show that for any input length $n$, there must exist at least one sequence of random bits that serves as a \"universally good\" advice string, yielding the correct answer for all $2^n$ possible inputs of that length. This is shown by demonstrating that the total probability of a random string failing on *at least one* input is less than 1.\n\nNow, consider a hypothetical complexity class, which we will call WeakBPP. A language is in WeakBPP if there exists a BPP-like algorithm for it, but due to some inherent limitations, the error probability $\\epsilon(n)$ after polynomial-time amplification can only be bounded by $\\epsilon(n) < 2^{-n/2}$ for any input of length $n$.\n\nIf we attempt to apply the standard proof of Adleman's theorem to show that WeakBPP $\\subseteq$ $P/\\text{poly}$, the argument fails. Identify the specific claim that is no longer valid or cannot be established under this weaker error bound of $2^{-n/2}$.\n\nA. The amplification step is invalid. It is impossible to reduce the error of a probabilistic algorithm to $\\epsilon(n) < 2^{-n/2}$ using a number of runs that is polynomial in $n$.\n\nB. The total length of the random bits required for the amplified computation on a single input grows exponentially with the input length $n$, and thus cannot serve as a polynomial-sized advice string.\n\nC. The union bound, which states that the probability of a union of events is less than or equal to the sum of their individual probabilities, is no longer a valid inequality to apply in this scenario.\n\nD. The conclusion that there must exist a \"universally good\" advice string for all inputs of length $n$ cannot be justified, because the upper bound calculated for the total probability of failure is not less than 1.\n\nE. The number of possible inputs of length $n$, which is $2^n$, is an exponential function. The argument fails because an exponential term cannot be part of a valid complexity-theoretic proof involving polynomial resources.", "solution": "Let $L$ be a language in WeakBPP. By definition, there exists a probabilistic polynomial-time algorithm $M$ and a polynomial $k(n)$ such that, after running $M$ independently $k(n)$ times on an input $x \\in \\{0,1\\}^{n}$ and taking the majority vote, the error probability satisfies\n$$\n\\epsilon(n) \\equiv \\Pr[\\text{$M$ errs on $x$ after amplification}] < 2^{-n/2}.\n$$\nFix an input length $n$ and let $R$ denote the set of all random strings used by the amplified computation; for concreteness, if one run of $M$ uses $s(n)$ random bits, then a $k(n)$-fold amplification uses $k(n)\\cdot s(n)$ random bits, so $|R| = 2^{k(n)\\cdot s(n)}$. For each $x \\in \\{0,1\\}^{n}$, define the event\n$$\nE_{x} = \\{\\text{the random string $r \\in R$ causes the amplified $M$ to err on input $x$}\\}.\n$$\nBy the amplification guarantee, for every fixed $x$,\n$$\n\\Pr_{r \\in R}[E_{x}] \\leq \\epsilon(n) < 2^{-n/2}.\n$$\nLet $E$ be the event that there exists at least one input of length $n$ on which $r$ causes an error:\n$$\nE = \\bigcup_{x \\in \\{0,1\\}^{n}} E_{x}.\n$$\nApplying the union bound,\n$$\n\\Pr_{r \\in R}[E] \\leq \\sum_{x \\in \\{0,1\\}^{n}} \\Pr_{r \\in R}[E_{x}] \\leq 2^{n} \\cdot \\epsilon(n) < 2^{n} \\cdot 2^{-n/2} = 2^{n/2}.\n$$\nIn Adleman’s proof for $BPP \\subseteq P/\\text{poly}$, one chooses $\\epsilon(n)$ so that $2^{n} \\cdot \\epsilon(n) < 1$, which implies $\\Pr_{r \\in R}[E] < 1$ and hence guarantees the existence of at least one random string $r$ that causes no error on any input of length $n$, yielding a valid advice string.\n\nUnder WeakBPP’s limitation $\\epsilon(n) < 2^{-n/2}$, the bound becomes\n$$\n\\Pr_{r \\in R}[E] < 2^{n/2},\n$$\nwhich is not less than $1$ for all sufficiently large $n$. Therefore, the argument cannot conclude that there exists an $r$ that works for all inputs of length $n$. The amplification step remains valid using polynomially many repetitions, the total random bits remain polynomial, and the union bound is still a valid inequality; however, the key conclusion that a “universally good” advice string must exist cannot be justified, because the computed upper bound for $\\Pr_{r \\in R}[E]$ is not strictly less than $1$.\n\nThus, the specific claim that fails is the existence of a universally good advice string via the union-bound estimate being less than $1$.", "answer": "$$\\boxed{D}$$", "id": "1411204"}]}