{"hands_on_practices": [{"introduction": "Understanding how complexity classes behave under standard operations like union is fundamental to mapping the landscape of computation. This practice explores whether the class $RP$ is closed under union, a key structural property. By analyzing a proposed algorithm for combining two separate $RP$ tests [@problem_id:1455470], you'll gain hands-on experience in constructing and verifying probabilistic polynomial-time machines.", "problem": "In the field of computational complexity theory, the class RP, which stands for Randomized Polynomial Time, characterizes decision problems solvable by a probabilistic Turing machine with one-sided error. A language $L$ is in RP if there exists a probabilistic, polynomial-time Turing machine $M$ such that for any input string $x$:\n1. If $x$ is in the language $L$, then the probability that $M$ outputs 1 (accepts) is at least $1/2$ ($x \\in L \\implies \\Pr(M(x) = 1) \\ge 1/2$).\n2. If $x$ is not in the language $L$, then the probability that $M$ outputs 1 (accepts) is exactly 0 ($x \\notin L \\implies \\Pr(M(x) = 1) = 0$).\n\nConsider a company that designs microchips. They have developed two separate probabilistic testing algorithms, $A_1$ and $A_2$, to detect different types of manufacturing flaws. Let $L_1$ be the set of all chips with a \"type-1\" flaw, and $L_2$ be the set of all chips with a \"type-2\" flaw. Both testing algorithms correspond to RP machines, meaning the languages $L_1$ and $L_2$ are both in the complexity class RP.\n\nA chip is considered \"globally defective\" if it has a type-1 flaw, or a type-2 flaw, or both. Let $L_{union}$ be the language of all globally defective chips, so $L_{union} = L_1 \\cup L_2$.\n\nTo create a unified test, an engineer proposes a new algorithm, $A_{union}$. On receiving a chip $x$ for testing, $A_{union}$ operates as follows:\n- First, run the algorithm $A_1$ on $x$.\n- If $A_1$ outputs 1, then $A_{union}$ immediately outputs 1 and halts.\n- If $A_1$ outputs 0, then $A_{union}$ proceeds to run algorithm $A_2$ on $x$ and outputs the result of $A_2$.\n\nBased on this construction, which of the following statements about the language $L_{union}$ is always true?\n\nA. $L_{union}$ is guaranteed to be in RP.\n\nB. $L_{union}$ is not guaranteed to be in RP, but it is guaranteed to be in co-RP.\n\nC. The classification of $L_{union}$ depends on the specific properties of $L_1$ and $L_2$; it is not guaranteed to be in RP.\n\nD. $L_{union}$ is guaranteed to be in P (Polynomial Time).\n\nE. $L_{union}$ is guaranteed to be in BPP (Bounded-error Probabilistic Polynomial Time), but not necessarily in RP.", "solution": "We are given two languages $L_{1},L_{2}$ in RP. By definition, there exist probabilistic polynomial-time algorithms $A_{1},A_{2}$ such that for all inputs $x$:\n- If $x \\in L_{i}$, then $\\Pr(A_{i}(x)=1) \\ge \\frac{1}{2}$.\n- If $x \\notin L_{i}$, then $\\Pr(A_{i}(x)=1)=0$.\nThe proposed unified algorithm $A_{\\text{union}}$ runs $A_{1}$ first and accepts immediately if $A_{1}$ accepts; otherwise it runs $A_{2}$ and outputs its result. We analyze the running time and correctness relative to the RP definition.\n\nPolynomial time: Let the running times be $T_{1}(n)$ and $T_{2}(n)$ for inputs of length $n$, both polynomial. Then the running time $T_{\\text{union}}(n)$ satisfies\n$$\nT_{\\text{union}}(n) \\le T_{1}(n) + T_{2}(n),\n$$\nwhich is polynomial; hence $A_{\\text{union}}$ runs in probabilistic polynomial time.\n\nOne-sided error (soundness on negatives): If $x \\notin L_{1} \\cup L_{2}$, then $x \\notin L_{1}$ and $x \\notin L_{2}$, so\n$$\n\\Pr(A_{1}(x)=1)=0 \\quad \\text{and} \\quad \\Pr(A_{2}(x)=1)=0.\n$$\nTherefore $A_{\\text{union}}$ accepts with probability\n$$\n\\Pr(A_{\\text{union}}(x)=1) = 0 + \\Pr(A_{1}(x)=0)\\cdot 0 = 0,\n$$\nso there are no false positives.\n\nAcceptance probability on positives: If $x \\in L_{1} \\cup L_{2}$, we consider cases.\n- If $x \\in L_{1} \\setminus L_{2}$, then $\\Pr(A_{1}(x)=1) \\ge \\frac{1}{2}$, so $A_{\\text{union}}$ accepts with probability at least $\\frac{1}{2}$ without needing $A_{2}$.\n- If $x \\in L_{2} \\setminus L_{1}$, then $\\Pr(A_{1}(x)=1)=0$ (since $x \\notin L_{1}$), hence $A_{\\text{union}}$ runs $A_{2}$ and accepts with probability\n$$\n\\Pr(A_{\\text{union}}(x)=1)=\\Pr(A_{2}(x)=1)\\ge \\frac{1}{2}.\n$$\n- If $x \\in L_{1} \\cap L_{2}$, then $\\Pr(A_{1}(x)=1) \\ge \\frac{1}{2}$, so $A_{\\text{union}}$ accepts with probability at least $\\frac{1}{2}$.\n\nIn all cases with $x \\in L_{1} \\cup L_{2}$, we have $\\Pr(A_{\\text{union}}(x)=1) \\ge \\frac{1}{2}$. Combined with the zero acceptance probability on negatives and polynomial time, this meets the RP definition. Therefore $L_{\\text{union}} \\in \\text{RP}$, and statement A is always true. The other options are unnecessary or false as general guarantees.\n\nThus, the correct choice is A.", "answer": "$$\\boxed{A}$$", "id": "1455470"}, {"introduction": "The definition of $RP$ specifies an acceptance probability of at least $\\frac{1}{2}$ for strings in the language. But is this constant crucial, or could it be something else? This thought experiment [@problem_id:1455479] challenges you to explore what happens when this probability is relaxed to be just $1/p(n)$ for some polynomial $p$. You will discover the powerful technique of probability amplification, revealing that the definition of $RP$ is far more robust than it might first appear.", "problem": "In computational complexity theory, a language is a set of strings over some alphabet. The complexity class RP (Randomized Polynomial time) is defined using a Probabilistic Polynomial-Time Machine (PPTM). A language $L$ is said to be in RP if there exists a PPTM, let's call it $M$, that runs in time polynomial in the input length $|x|$ and satisfies the following two conditions:\n1. For any string $x$ that is in the language $L$ (i.e., $x \\in L$), the machine $M$ accepts with a probability of at least $1/2$. Symbolically, $\\Pr[M(x) \\text{ accepts}] \\ge 1/2$.\n2. For any string $x$ that is not in the language $L$ (i.e., $x \\notin L$), the machine $M$ always rejects. Symbolically, $\\Pr[M(x) \\text{ accepts}] = 0$.\n\nNow, consider a new complexity class, which we will call $\\text{WEAK-RP}$. A language $L$ is in $\\text{WEAK-RP}$ if there exists a PPTM, let's call it $M'$, and a polynomial $p(n)$ such that for any input string $x$ of length $n = |x|$:\n1. If $x \\in L$, then $\\Pr[M'(x) \\text{ accepts}] \\ge 1/p(n)$.\n2. If $x \\notin L$, then $\\Pr[M'(x) \\text{ accepts}] = 0$.\n\nWhat is the relationship between the complexity classes RP and $\\text{WEAK-RP}$?\n\nA. $\\text{WEAK-RP}$ is a proper subset of RP (i.e., $\\text{WEAK-RP} \\subset \\text{RP}$ and $\\text{WEAK-RP} \\neq \\text{RP}$).\n\nB. $\\text{WEAK-RP}$ is a proper superset of RP (i.e., $\\text{RP} \\subset \\text{WEAK-RP}$ and $\\text{RP} \\neq \\text{WEAK-RP}$).\n\nC. $\\text{WEAK-RP}$ is equal to RP (i.e., $\\text{WEAK-RP} = \\text{RP}$).\n\nD. $\\text{WEAK-RP}$ and RP are incomparable (i.e., neither is a subset of the other).\n\nE. Every language in $\\text{WEAK-RP}$ is undecidable, whereas RP contains some decidable languages.", "solution": "We first restate the defining properties. RP consists of languages for which there exists a probabilistic polynomial-time machine that accepts every $x \\in L$ with probability at least $1/2$ and never accepts $x \\notin L$. The class $\\text{WEAK-RP}$ relaxes the acceptance probability on $x \\in L$ to be at least $1/p(n)$ for some polynomial $p(n)$ (depending only on the input length $n = |x|$), while still requiring zero acceptance probability on $x \\notin L$.\n\nStep 1 (RP is contained in WEAK-RP): Let $L \\in \\text{RP}$ with witness machine $M$ satisfying $\\Pr[M(x)\\text{ accepts}] \\ge 1/2$ for $x \\in L$ and $0$ for $x \\notin L$. Choose the constant polynomial $p(n) = 2$. Then $1/2 \\ge 1/p(n)$, so $M$ also witnesses that $L \\in \\text{WEAK-RP}$. Hence $\\text{RP} \\subseteq \\text{WEAK-RP}$.\n\nStep 2 (WEAK-RP is contained in RP via amplification): Let $L \\in \\text{WEAK-RP}$ with witness machine $M'$ and polynomial $p(n)$ such that for all $x$ with $n = |x|$,\n- if $x \\in L$ then $\\Pr[M'(x)\\text{ accepts}] \\ge 1/p(n)$,\n- if $x \\notin L$ then $\\Pr[M'(x)\\text{ accepts}] = 0$.\nWithout loss of generality, define $q(n) = \\max\\{1, \\lceil p(n) \\rceil\\}$ so that $q(n)$ is an integer polynomial and $q(n) \\ge 1$. Then for $x \\in L$ we still have $\\Pr[M'(x)\\text{ accepts}] \\ge 1/q(n)$ since $1/q(n) \\le 1/p(n)$.\n\nConstruct a new probabilistic polynomial-time machine $M$ that, on input $x$ of length $n$, performs $k(n) = \\lceil q(n)\\ln 2 \\rceil$ independent runs of $M'$ on $x$ and accepts if and only if at least one run accepts. This uses independent random bits across runs, so the runs are independent.\n\n- If $x \\notin L$, then each run accepts with probability $0$, so the probability that $M$ accepts is $0$. Thus the one-sided error condition is preserved.\n\n- If $x \\in L$, let $\\alpha(n) = \\Pr[M'(x)\\text{ accepts}]$, so $\\alpha(n) \\ge 1/q(n)$. By independence,\n$$\n\\Pr[M(x)\\text{ accepts}] \\;=\\; 1 - \\Pr[\\text{all }k(n)\\text{ runs reject}]\n\\;=\\; 1 - (1 - \\alpha(n))^{k(n)}.\n$$\nUsing $\\alpha(n) \\ge 1/q(n)$ and the monotonicity of $t \\mapsto (1-t)^{k}$ for $t \\in [0,1]$, we get\n$$\n\\Pr[M(x)\\text{ accepts}] \\;\\ge\\; 1 - \\left(1 - \\frac{1}{q(n)}\\right)^{k(n)} \\;\\ge\\; 1 - \\left(1 - \\frac{1}{q(n)}\\right)^{q(n)\\ln 2}.\n$$\nTo bound the latter term, use the inequality $\\ln(1 - z) \\le -z$ for $z \\in (0,1)$ to obtain\n$$\n\\left(1 - \\frac{1}{q(n)}\\right)^{q(n)\\ln 2}\n= \\exp\\!\\left(q(n)\\ln 2 \\cdot \\ln\\!\\left(1 - \\frac{1}{q(n)}\\right)\\right)\n\\le \\exp\\!\\left(q(n)\\ln 2 \\cdot \\left(-\\frac{1}{q(n)}\\right)\\right)\n= \\exp(-\\ln 2) = \\frac{1}{2}.\n$$\nTherefore,\n$$\n\\Pr[M(x)\\text{ accepts}] \\;\\ge\\; 1 - \\frac{1}{2} \\;=\\; \\frac{1}{2}.\n$$\nMachine $M$ runs in time polynomial in $n$ because it performs $k(n) = \\lceil q(n)\\ln 2 \\rceil$ independent executions of a PPTM with $k(n)$ polynomial in $n$. Thus $M$ witnesses that $L \\in \\text{RP}$.\n\nCombining Step 1 and Step 2 gives $\\text{WEAK-RP} = \\text{RP}$.\n\nHence the correct choice is C.", "answer": "$$\\boxed{C}$$", "id": "1455479"}, {"introduction": "Algorithms often solve problems by calling subroutines, a concept formalized by oracle machines and reductions. This practical exercise [@problem_id:1455492] models a scenario where a problem is solved via a polynomial-time reduction to a language in $RP$. Your goal is to determine how to use the $RP$ algorithm as a probabilistic subroutine and control its error, a process that illustrates how problems reducible to $RP$ belong to the class $BPP$.", "problem": "An oracle Turing Machine $M$ is designed to decide a language $L_1$. On any input $x$ of length $n$, machine $M$ is guaranteed to halt in polynomial time and makes at most $Q(n) = 2n$ calls to an oracle for a language $L_2$.\n\nThe language $L_2$ belongs to the complexity class Randomized Polynomial Time (RP). This means there is a probabilistic algorithm, $A_2$, that runs in polynomial time and for any input string $y$:\n- If $y \\in L_2$, the probability that $A_2(y)$ accepts is at least $1/2$.\n- If $y \\notin L_2$, the probability that $A_2(y)$ accepts is exactly $0$.\n\nWe construct a new probabilistic algorithm, $A_1$, to decide $L_1$ without an oracle. We do this by running the machine $M$ and simulating its oracle calls. When $M$ queries the oracle about a string $y$, our simulation runs the algorithm $A_2$ on $y$ for $k$ independent trials. If at least one of these $k$ trials results in acceptance, the simulation provides the answer 'yes' to $M$; otherwise, it provides the answer 'no'.\n\nConsider an input $x$ for $L_1$ of length $n=10$. What is the minimum integer value of $k$ that guarantees the overall probability of our algorithm $A_1$ producing an incorrect answer for the input $x$ is at most $1/24$?", "solution": "Machine $M$ makes at most $Q(n)=2n$ oracle calls, so for $n=10$ there are at most $Q(10)=20$ calls.\n\nAlgorithm $A_{2}$ for $L_{2}$ has one-sided error: for $y \\in L_{2}$, a single trial accepts with probability at least $1/2$, and for $y \\notin L_{2}$ it never accepts. When simulating an oracle call on input $y$, we run $k$ independent trials and answer 'yes' if any trial accepts. Thus, for $y \\in L_{2}$ the probability that the simulator incorrectly answers 'no' is at most\n$$\n(1-\\tfrac{1}{2})^{k} = 2^{-k},\n$$\nwhile for $y \\notin L_{2}$ the error probability is $0$.\n\nLet $E_{i}$ be the event that the $i$-th simulated oracle answer is wrong. Then for each possible query, $\\Pr[E_{i}] \\le 2^{-k}$. By the union bound over at most $Q(10)=20$ queries, the probability that any simulated oracle answer is wrong is at most\n$$\n\\sum_{i=1}^{20} \\Pr[E_{i}] \\le 20 \\cdot 2^{-k}.\n$$\nSince $M$ decides $L_{1}$ correctly given correct oracle answers, the overall error probability of $A_{1}$ is at most $20 \\cdot 2^{-k}$. To ensure this is at most $\\frac{1}{24}$, we require\n$$\n20 \\cdot 2^{-k} \\le \\frac{1}{24} \\quad \\Longleftrightarrow \\quad 2^{-k} \\le \\frac{1}{480} \\quad \\Longleftrightarrow \\quad k \\ge \\log_{2}(480).\n$$\nBecause $2^{8}=256$ and $2^{9}=512$, we have $\\log_{2}(480) \\in (8,9]$, so the minimum integer $k$ satisfying the inequality is $k=9$.", "answer": "$$\\boxed{9}$$", "id": "1455492"}]}