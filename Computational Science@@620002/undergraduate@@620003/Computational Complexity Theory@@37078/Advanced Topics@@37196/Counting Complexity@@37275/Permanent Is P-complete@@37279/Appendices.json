{"hands_on_practices": [{"introduction": "To truly understand a mathematical object, it helps to build one from scratch. This first exercise grounds the abstract formula for the permanent in a concrete calculation, asking you to compute it for a small matrix directly from its definition. By performing the same calculation for the determinant, you will gain a firsthand appreciation for the subtle-yet-profound difference a single sign can make to a problem's character [@problem_id:1435361].", "problem": "In computational complexity theory, the calculation of the permanent of a matrix is a canonical problem for the complexity class $\\text{\\#P}$. For an $n \\times n$ matrix $A = (a_{ij})$, the permanent is defined by the Leibniz-like formula:\n$$\n\\text{perm}(A) = \\sum_{\\sigma \\in S_n} \\prod_{i=1}^{n} a_{i, \\sigma(i)}\n$$\nwhere $S_n$ is the set of all permutations of the set $\\{1, 2, \\dots, n\\}$. This definition is structurally very similar to that of the determinant:\n$$\n\\det(A) = \\sum_{\\sigma \\in S_n} \\text{sgn}(\\sigma) \\prod_{i=1}^{n} a_{i, \\sigma(i)}\n$$\nwhere $\\text{sgn}(\\sigma)$ is the signature of the permutation $\\sigma$ ($+1$ if $\\sigma$ is an even permutation, and $-1$ if it is an odd permutation). Despite this similarity, computing the permanent is generally much harder than computing the determinant.\n\nConsider the following $3 \\times 3$ integer matrix $A$:\n$$\nA = \\begin{pmatrix}\n2 & 1 & 3 \\\\\n4 & 5 & 1 \\\\\n1 & 2 & 2\n\\end{pmatrix}\n$$\nCalculate the permanent of $A$, let's call it $p$, and the determinant of $A$, let's call it $d$.\n\nYour task is to provide the values of $p$ and $d$. Present your final answer as a single row matrix containing the two integer values $(p \\quad d)$.", "solution": "We use the definitions:\n$$\n\\text{perm}(A) = \\sum_{\\sigma \\in S_{3}} \\prod_{i=1}^{3} a_{i,\\sigma(i)}, \\qquad \\det(A) = \\sum_{\\sigma \\in S_{3}} \\text{sgn}(\\sigma) \\prod_{i=1}^{3} a_{i,\\sigma(i)}.\n$$\nFor $A=\\begin{pmatrix}2 & 1 & 3\\\\ 4 & 5 & 1\\\\ 1 & 2 & 2\\end{pmatrix}$, list all $\\sigma \\in S_{3}$ in one-line notation and compute the corresponding products:\n- $\\sigma=[1,2,3]$: $a_{1,1}a_{2,2}a_{3,3}=2\\cdot 5\\cdot 2=20$.\n- $\\sigma=[1,3,2]$: $a_{1,1}a_{2,3}a_{3,2}=2\\cdot 1\\cdot 2=4$.\n- $\\sigma=[2,1,3]$: $a_{1,2}a_{2,1}a_{3,3}=1\\cdot 4\\cdot 2=8$.\n- $\\sigma=[2,3,1]$: $a_{1,2}a_{2,3}a_{3,1}=1\\cdot 1\\cdot 1=1$.\n- $\\sigma=[3,1,2]$: $a_{1,3}a_{2,1}a_{3,2}=3\\cdot 4\\cdot 2=24$.\n- $\\sigma=[3,2,1]$: $a_{1,3}a_{2,2}a_{3,1}=3\\cdot 5\\cdot 1=15$.\n\nTherefore,\n$$\np=\\text{perm}(A)=20+4+8+1+24+15=72.\n$$\nFor the determinant, include the signs $\\text{sgn}(\\sigma)$: $\\text{sgn}([1,2,3])=+1$, $\\text{sgn}([1,3,2])=-1$, $\\text{sgn}([2,1,3])=-1$, $\\text{sgn}([2,3,1])=+1$, $\\text{sgn}([3,1,2])=+1$, $\\text{sgn}([3,2,1])=-1$. Hence,\n$$\nd=\\det(A)=20-4-8+1+24-15=18.\n$$\nAs a cross-check, compute $d$ by cofactor expansion along the first row:\n$$\nd=2\\,(5\\cdot 2-1\\cdot 2)-1\\,(4\\cdot 2-1\\cdot 1)+3\\,(4\\cdot 2-5\\cdot 1)=2\\cdot 8-1\\cdot 7+3\\cdot 3=16-7+9=18,\n$$\nwhich agrees with the permutation calculation.\n\nThus, the required pair is $(p\\ d)=(72\\ 18)$.", "answer": "$$\\boxed{\\begin{pmatrix} 72 & 18 \\end{pmatrix}}$$", "id": "1435361"}, {"introduction": "Having seen the computational effort involved even for a tiny matrix, we now explore a surprising shortcut that reveals a deep truth about the permanent's complexity. This practice investigates what happens when we only care about the permanent's parityâ€”its value modulo 2. You will discover a beautiful and unexpected connection to the determinant, which explains why this simplified version of the problem is dramatically easier to solve [@problem_id:1435370].", "problem": "In computational complexity theory, we study the resources required to solve computational problems. A central problem is computing the permanent of a square matrix. For an $n \\times n$ matrix $A = (a_{i,j})$, the permanent is defined as:\n$$ \\text{perm}(A) = \\sum_{\\sigma \\in S_n} \\prod_{i=1}^{n} a_{i, \\sigma(i)} $$\nwhere $S_n$ is the set of all permutations of the numbers $\\{1, 2, \\dots, n\\}$. This is very similar to the definition of the determinant, which is:\n$$ \\det(A) = \\sum_{\\sigma \\in S_n} \\text{sgn}(\\sigma) \\prod_{i=1}^{n} a_{i, \\sigma(i)} $$\nwhere $\\text{sgn}(\\sigma)$ is the sign of the permutation $\\sigma$.\n\nComputing the determinant is known to be in the complexity class P, meaning it can be solved by a deterministic algorithm in polynomial time. In contrast, computing the permanent is a much harder problem. It is the canonical complete problem for the complexity class #P (Sharp-P), the class of functions that count the number of accepting paths of a non-deterministic Turing machine. It is widely believed that P is a proper subset of #P.\n\nA computer science student is faced with the task of computing the permanent of a large $n \\times n$ matrix with entries being either 0 or 1. Knowing that this is a #P-complete problem, the student decides to simplify the problem by computing the permanent modulo 2, i.e., finding $\\text{perm}(A) \\pmod 2$. This simplified problem asks for the parity of the permanent.\n\nWhich of the following statements correctly describes the computational complexity of computing the permanent of a 0-1 matrix modulo 2?\n\nA. The problem remains #P-complete.\n\nB. The problem is NP-complete.\n\nC. The problem is in P (solvable in polynomial time).\n\nD. The problem is coNP-complete.\n\nE. The complexity is an open problem, but it is conjectured to be outside of P.", "solution": "We are asked for the computational complexity of computing the permanent of a 0-1 matrix modulo 2.\n\n1. By definition, for an $n \\times n$ matrix $A = (a_{i,j})$,\n$$\n\\text{perm}(A) = \\sum_{\\sigma \\in S_{n}} \\prod_{i=1}^{n} a_{i,\\sigma(i)}, \\quad\n\\det(A) = \\sum_{\\sigma \\in S_{n}} \\text{sgn}(\\sigma) \\prod_{i=1}^{n} a_{i,\\sigma(i)}.\n$$\n\n2. Consider these expressions modulo $2$. Over the field $\\mathbb{F}_{2}$, one has $-1 \\equiv 1 \\pmod{2}$. Therefore, for every permutation $\\sigma$, $\\text{sgn}(\\sigma) \\equiv 1 \\pmod{2}$ (since sgn is either 1 or -1).\n\n3. Reducing the determinant expression modulo $2$ removes the sign:\n$$\n\\det(A) \\bmod 2 \\;=\\; \\left(\\sum_{\\sigma \\in S_{n}} \\text{sgn}(\\sigma) \\prod_{i=1}^{n} a_{i,\\sigma(i)}\\right) \\bmod 2\n\\;=\\; \\sum_{\\sigma \\in S_{n}} \\left(\\prod_{i=1}^{n} a_{i,\\sigma(i)}\\right) \\bmod 2\n\\;=\\; \\text{perm}(A) \\bmod 2.\n$$\n\n4. Hence, for any integer matrix (in particular, any 0-1 matrix), \n$$\n\\text{perm}(A) \\equiv \\det(A) \\pmod{2}.\n$$\n\n5. Computing $\\det(A) \\bmod 2$ can be done in polynomial time by Gaussian elimination over $\\mathbb{F}_{2}$ (or any standard polynomial-time determinant algorithm). Therefore, computing $\\text{perm}(A) \\bmod 2$ is in P.\n\nThus, the correct choice is that the problem is solvable in polynomial time.", "answer": "$$\\boxed{C}$$", "id": "1435370"}, {"introduction": "Many computational problems can be viewed through different lenses, and the permanent is a prime example. This final exercise shifts our perspective from algebra to combinatorics, exploring the permanent's identity as a tool for counting perfect matchings in graphs. By analyzing cases where the underlying graph structure is simple, such as a forest, we can see how an otherwise intractable counting problem becomes efficiently solvable, a powerful theme in modern algorithm design [@problem_id:1435360].", "problem": "The permanent of an $n \\times n$ matrix $A = (a_{ij})$ is defined by the formula:\n$$ \\text{perm}(A) = \\sum_{\\sigma \\in S_n} \\prod_{i=1}^n a_{i, \\sigma(i)} $$\nwhere $S_n$ is the set of all permutations of $\\{1, 2, \\dots, n\\}$. While its definition is similar to the determinant, computing the permanent of a general 0/1 matrix is a #P-complete problem, a class of problems widely believed to be computationally intractable.\n\nFor any $n \\times n$ matrix $A$ with entries in $\\{0, 1\\}$, we can construct an associated bipartite graph $G_A = (U \\cup V, E)$. The two sets of vertices are $U = \\{u_1, \\dots, u_n\\}$ and $V = \\{v_1, \\dots, v_n\\}$, corresponding to the rows and columns of the matrix, respectively. An edge $(u_i, v_j)$ exists in the set of edges $E$ if and only if the matrix entry $a_{ij} = 1$. A key result in combinatorics states that the permanent of such a matrix $A$ is equal to the number of perfect matchings in its associated bipartite graph $G_A$.\n\nConsider a restricted version of this problem where we are given an $n \\times n$ matrix $A$ with entries in $\\{0, 1\\}$ and the promise that its associated bipartite graph $G_A$ is a forest (a graph with no cycles, which is equivalent to a collection of disjoint trees).\n\nWhich of the following complexity classes best describes the computational difficulty of computing the permanent for this specific subclass of matrices? Your goal is to identify the tightest well-known complexity class that contains this problem.\n\nFor context, here are informal descriptions of the relevant complexity classes for function (or counting) problems:\n- **P**: The class of problems solvable in polynomial time.\n- **NP-complete**: A class of the hardest *decision* problems in NP (Nondeterministic Polynomial time). This is typically not used for function problems, but relates to the difficulty of deciding if a solution exists.\n- **#P-complete**: A class of the hardest counting problems in #P (pronounced \"Sharp-P\").\n- **PSPACE-complete**: A class of the hardest *decision* problems solvable using a polynomial amount of memory.\n\nA. PSPACE-complete\n\nB. #P-complete\n\nC. NP-complete\n\nD. P", "solution": "We are given an $n \\times n$ $0/1$ matrix $A$ and the promise that its associated bipartite graph $G_{A}=(U \\cup V, E)$ is a forest (i.e., a disjoint union of trees). For $0/1$ matrices, the permanent equals the number of perfect matchings in $G_{A}$:\n$$\n\\operatorname{perm}(A)=\\left|\\{\\text{perfect matchings of }G_{A}\\}\\right|.\n$$\nThus the problem reduces to counting perfect matchings in a bipartite forest.\n\nSince a forest is a disjoint union of trees, the number of perfect matchings in the forest is the product of the numbers of perfect matchings in each connected component. Therefore it suffices to count perfect matchings in a single tree $T$. We present a polynomial-time dynamic programming algorithm on trees that computes this count exactly.\n\nRoot the tree $T$ at an arbitrary vertex $r$. For each vertex $u$, let $\\text{ch}(u)$ denote the set of children of $u$ in the rooted tree, and let $T_{u}$ denote the subtree rooted at $u$. Define two quantities for each $u$:\n- $P(u)$: the number of matchings that cover all vertices of $T_{u}$ (i.e., a perfect matching on $T_{u}$);\n- $Q(u)$: the number of matchings that cover all vertices of $T_{u}$ except $u$ (i.e., $u$ is left unmatched in $T_{u}$, to be potentially matched to its parent).\n\nThese satisfy the following base cases for a leaf $u$ (with $\\text{ch}(u)=\\emptyset$):\n$$\nP(u)=0, \\qquad Q(u)=1.\n$$\nFor an internal node $u$ with children $\\text{ch}(u)=\\{c_{1},\\dots,c_{k}\\}$, the recurrences follow from the structural constraints of a matching:\n- To leave $u$ unmatched within $T_{u}$ (contributing to $Q(u)$), no child may be matched to $u$, so each child subtree must be perfectly matched internally. Hence\n$$\nQ(u)=\\prod_{c \\in \\text{ch}(u)} P(c).\n$$\n- To perfectly cover $T_{u}$ (contributing to $P(u)$), the vertex $u$ must be matched to exactly one child $w$. For that chosen child $w$, its subtree must be covered except for $w$ (i.e., contribute $Q(w)$), while every other child $c \\neq w$ must be perfectly matched internally (i.e., contribute $P(c)$). Summing over the choice of $w$ gives\n$$\nP(u)=\\sum_{w \\in \\text{ch}(u)} \\left( Q(w) \\prod_{\\substack{c \\in \\text{ch}(u) \\\\ c \\neq w}} P(c) \\right).\n$$\n\nThese recurrences can be evaluated in a single postorder traversal of the tree. For a node with $k$ children, the expression for $P(u)$ can be computed in $O(k)$ time using prefix and suffix products of the $P(c)$ values, so the total time over the entire tree is $O(|V(T)|)$. For the root $r$, the number of perfect matchings of the whole tree is precisely $P(r)$, because the root has no parent and must be matched within its subtree.\n\nFor a forest with connected components $T_{1},\\dots,T_{m}$ and chosen roots $r_{1},\\dots,r_{m}$, the total number of perfect matchings equals\n$$\n\\prod_{j=1}^{m} P(r_{j}),\n$$\nwhich is computable in time polynomial in the size of the forest. Therefore, for the promised subclass where $G_{A}$ is a forest, computing $\\operatorname{perm}(A)$ is solvable in polynomial time.\n\nConsequently, the tightest well-known complexity class containing this problem is P, corresponding to option D.", "answer": "$$\\boxed{D}$$", "id": "1435360"}]}