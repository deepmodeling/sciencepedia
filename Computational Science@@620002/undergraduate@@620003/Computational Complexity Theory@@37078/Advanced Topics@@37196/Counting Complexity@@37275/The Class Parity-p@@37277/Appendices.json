{"hands_on_practices": [{"introduction": "To build an intuition for the complexity class $\\oplus$P, we start with a concrete, small-scale example. This problem models the core concept of parity-based decision making through a hypothetical Modular Constraint System with a Parity-Integrity test. By manually finding all valid configurations and checking if their count is odd, you will perform the exact type of calculation that defines membership in $\\oplus$P, grounding this abstract class in a direct hands-on counting exercise [@problem_id:1454442].", "problem": "A \"Modular Constraint System\" (MCS) is defined by a set of $n$ binary variables, $x_1, x_2, \\ldots, x_n$, where each $x_i \\in \\{0, 1\\}$. A specific assignment of values to these variables forms a configuration $(x_1, x_2, \\ldots, x_n)$. A configuration is deemed \"stable\" if it satisfies a given governing Boolean logical formula.\n\nThe system has a diagnostic test to check for a global property called Parity-Integrity. The test proceeds as follows: A special parity bit $P$, initialized to $0$, is flipped for every stable configuration that exists. The MCS is said to possess Parity-Integrity if the final value of the bit $P$ is $1$.\n\nConsider a base system $S_0$ with $n=3$ variables ($x_1, x_2, x_3$) whose stable configurations are those that satisfy the formula:\n$$ \\phi_0 = (x_1 \\lor x_2) \\land (\\neg x_1 \\lor \\neg x_3) $$\n\nNow, consider four modified systems, $S_A, S_B, S_C,$ and $S_D$, each created by adding exactly one new constraint to the base system $S_0$. Which of these modified systems possesses Parity-Integrity?\n\nA. System $S_A$: The constraint $(x_2 \\lor x_3)$ is added to $S_0$.\n\nB. System $S_B$: The constraint $(x_2 \\leftrightarrow x_3)$ is added to $S_0$. The symbol $\\leftrightarrow$ represents the logical biconditional (XNOR).\n\nC. System $S_C$: The constraint $(x_1 \\oplus x_2 \\oplus x_3 = 1)$ is added to $S_0$. The symbol $\\oplus$ represents the exclusive OR (XOR) operation.\n\nD. System $S_D$: The constraint $(\\neg x_2 \\lor x_3)$ is added to $S_0$.", "solution": "A configuration is stable if it satisfies $\\phi_{0}=(x_{1}\\lor x_{2})\\land(\\neg x_{1}\\lor \\neg x_{3})$. The Parity-Integrity test flips a bit $P$ once for each stable configuration; thus the system has Parity-Integrity if and only if the number of stable configurations is odd.\n\nFirst, enumerate the configurations satisfying $\\phi_{0}$ by cases on $x_{1}$.\n\n1) If $x_{1}=0$, then $(x_{1}\\lor x_{2})$ reduces to $x_{2}$, so $x_{2}=1$. The clause $(\\neg x_{1}\\lor \\neg x_{3})$ becomes $(1\\lor \\neg x_{3})=1$, imposing no condition on $x_{3}$. Hence the satisfying assignments with $x_{1}=0$ are $(0,1,0)$ and $(0,1,1)$.\n\n2) If $x_{1}=1$, then $(x_{1}\\lor x_{2})$ is $1$, imposing no condition on $x_{2}$, while $(\\neg x_{1}\\lor \\neg x_{3})$ becomes $\\neg x_{3}$, so $x_{3}=0$. Hence the satisfying assignments with $x_{1}=1$ are $(1,0,0)$ and $(1,1,0)$.\n\nTherefore the $\\phi_{0}$-stable configurations are exactly\n$$(0,1,0),\\quad (0,1,1),\\quad (1,0,0),\\quad (1,1,0).$$\n\nNow impose each added constraint and count the remaining configurations.\n\nA. Add $(x_{2}\\lor x_{3})$. Evaluate on the four configurations:\n- $(0,1,0)$: $1\\lor 0=1$ (kept).\n- $(0,1,1)$: $1\\lor 1=1$ (kept).\n- $(1,0,0)$: $0\\lor 0=0$ (discarded).\n- $(1,1,0)$: $1\\lor 0=1$ (kept).\nCount $=3$ (odd) $\\Rightarrow$ Parity-Integrity holds.\n\nB. Add $(x_{2}\\leftrightarrow x_{3})$, i.e., $x_{2}=x_{3}$. Evaluate:\n- $(0,1,0)$: $1\\neq 0$ (discarded).\n- $(0,1,1)$: $1=1$ (kept).\n- $(1,0,0)$: $0=0$ (kept).\n- $(1,1,0)$: $1\\neq 0$ (discarded).\nCount $=2$ (even) $\\Rightarrow$ Parity-Integrity fails.\n\nC. Add $(x_{1}\\oplus x_{2}\\oplus x_{3}=1)$, i.e., an odd number of ones. Evaluate:\n- $(0,1,0)$: one $1$ (kept).\n- $(0,1,1)$: two $1$'s (discarded).\n- $(1,0,0)$: one $1$ (kept).\n- $(1,1,0)$: two $1$'s (discarded).\nCount $=2$ (even) $\\Rightarrow$ Parity-Integrity fails.\n\nD. Add $(\\neg x_{2}\\lor x_{3})$, i.e., $x_{2}\\Rightarrow x_{3}$. Evaluate:\n- $(0,1,0)$: $\\neg 1\\lor 0=0\\lor 0=0$ (discarded).\n- $(0,1,1)$: $\\neg 1\\lor 1=0\\lor 1=1$ (kept).\n- $(1,0,0)$: $\\neg 0\\lor 0=1\\lor 0=1$ (kept).\n- $(1,1,0)$: $\\neg 1\\lor 0=0\\lor 0=0$ (discarded).\nCount $=2$ (even) $\\Rightarrow$ Parity-Integrity fails.\n\nOnly System $S_{A}$ yields an odd number of stable configurations, hence only $S_{A}$ possesses Parity-Integrity.", "answer": "$$\\boxed{A}$$", "id": "1454442"}, {"introduction": "Having developed an intuition for parity counting, we now apply this concept to a well-known problem from graph theory. This exercise asks you to classify the `PARITY-VC` problem, which deals with counting vertex covers, within the complexity landscape. To solve this, you must connect the combinatorial nature of the problem to the formal definition of $\\oplus$P, which is based on the number of accepting paths of a Non-deterministic Turing Machine [@problem_id:1454450].", "problem": "In graph theory, a **vertex cover** of an undirected graph $G=(V, E)$ is a subset of vertices $S \\subseteq V$ such that for every edge $(u, v) \\in E$, at least one of $u$ or $v$ is in $S$. The size of the vertex cover is the number of vertices in the set $S$.\n\nIn computational complexity theory, the class $\\oplus$P (read as \"Parity P\") is defined as the set of all languages $A$ for which there exists a polynomial-time Non-deterministic Turing Machine (NTM) $M$, such that for any input string $x$, $x$ is in $A$ if and only if the number of accepting computation paths of $M$ on input $x$ is odd.\n\nConsider the following language, which we will call PARITY-VC:\n$$L = \\{ \\langle G, k \\rangle \\mid G \\text{ is an undirected graph with an odd number of distinct vertex covers of size exactly } k \\}$$\nHere, $\\langle G, k \\rangle$ represents a suitable encoding of the graph $G$ and the integer $k$.\n\nWhich of the following statements most accurately describes the complexity of the language $L$?\n\nA. $L$ is in P (the class of problems solvable in polynomial time).\n\nB. $L$ is NP-complete.\n\nC. $L$ is in $\\oplus$P.\n\nD. Deciding membership in $L$ is undecidable.", "solution": "We need to characterize the complexity of the language\n$$L=\\{\\langle G,k\\rangle \\mid G \\text{ has an odd number of distinct vertex covers of size exactly } k\\}.$$\nBy the definition of $\\oplus$P, a language $A$ is in $\\oplus$P if there exists a polynomial-time nondeterministic Turing machine $M$ such that, for every input $x$, $x\\in A$ if and only if the number of accepting computation paths of $M$ on input $x$ is odd.\n\nTo show $L\\in\\oplus$P, we construct such an $M$ that on input $\\langle G=(V,E),k\\rangle$ does the following in polynomial time:\n\n1. Let $V=\\{v_{1},\\dots,v_{n}\\}$. Nondeterministically guess a binary string $b_{1}\\dots b_{n}$, which we interpret as the characteristic vector of a subset $S\\subseteq V$ where $v_{i}\\in S$ if and only if $b_{i}=1$.\n\n2. Deterministically compute $s=\\sum_{i=1}^{n} b_{i}$. If $s\\neq k$, reject on this path.\n\n3. If $s=k$, form $S=\\{v_{i}:b_{i}=1\\}$ and deterministically verify that $S$ is a vertex cover, i.e., for every edge $(u,v)\\in E$, check that $u\\in S$ or $v\\in S$. If this holds, accept; otherwise, reject.\n\nAll checks are polynomial in $|V|+|E|$. There is a one-to-one correspondence between subsets $S\\subseteq V$ and bitstrings $b_{1}\\dots b_{n}$, so each subset $S$ of size exactly $k$ yields exactly one computation path that reaches step 3 with $s=k$. Hence, the number of accepting paths of $M$ on input $\\langle G,k\\rangle$ is exactly the number of vertex covers of size $k$ in $G$. Therefore,\n$$\\langle G,k\\rangle\\in L \\iff \\text{the number of accepting paths of } M \\text{ on } \\langle G,k\\rangle \\text{ is odd},$$\nwhich by definition implies $L\\in \\oplus$P.\n\nConsequently, among the given options, the most accurate statement is that $L$ is in $\\oplus$P.\n\nFor completeness with respect to the other options: it is not known or expected to be in P, it is not an NP-complete language since it is not a standard NP decision predicate (it concerns parity rather than existence), and it is clearly decidable, so not undecidable. The correct choice is C.", "answer": "$$\\boxed{C}$$", "id": "1454450"}, {"introduction": "Understanding a complexity class fully requires exploring its boundaries and its relationship to other classes. This problem delves into the nuances of counting-based languages by contrasting $\\text{ODD-SAT}$, the canonical problem for $\\oplus$P, with the subtly different $\\text{EVEN-SAT}$ problem. By analyzing their relationship, you will practice using oracle reductions, a fundamental technique in complexity theory for comparing the relative difficulty of problems [@problem_id:1454447].", "problem": "In computational complexity theory, we often classify problems based on the resources required to solve them. Beyond decision problems, we can also consider counting problems. For a given Boolean formula $\\phi$, let $\\#\\text{SAT}(\\phi)$ denote the number of distinct satisfying assignments for $\\phi$. The complexity class of functions $\\#\\text{P}$ consists of functions that count the number of accepting paths of a non-deterministic Turing machine that runs in polynomial time. Computing $\\#\\text{SAT}$ is a canonical complete problem for this class.\n\nFrom counting classes, we can define new decision classes. One such class is Parity-P (⊕P), which contains all decision problems solvable by a polynomial-time non-deterministic Turing machine that accepts an input if and only if the number of its accepting computation paths is odd. The canonical complete problem for ⊕P is $\\text{ODD-SAT}$, the language of all Boolean formulas with an odd number of satisfying assignments.\n\nConsider a related language, $\\text{EVEN-SAT}$, defined as the set of all Boolean formulas that have a positive and even number of satisfying assignments. Formally:\n$$ \\text{EVEN-SAT} = \\{\\phi \\mid \\#\\text{SAT}(\\phi) > 0 \\text{ and } \\#\\text{SAT}(\\phi) \\equiv 0 \\pmod 2 \\} $$\n\nGiven these definitions, which of the following statements about the complexity of $\\text{EVEN-SAT}$ is correct?\n\nA. $\\text{EVEN-SAT}$ is in the class NP.\n\nB. $\\text{EVEN-SAT}$ is in the class co-NP.\n\nC. $\\text{EVEN-SAT}$ is the complement of $\\text{ODD-SAT}$.\n\nD. $\\text{ODD-SAT}$ can be solved in polynomial time by a deterministic Turing machine that has access to an oracle for $\\text{EVEN-SAT}$.", "solution": "The problem asks us to determine the correct statement regarding the complexity of the language $\\text{EVEN-SAT}$. We will analyze each option step-by-step.\n\nLet $\\phi$ be a Boolean formula with $n$ variables.\nThe language $\\text{ODD-SAT}$ is defined as $\\{\\phi \\mid \\#\\text{SAT}(\\phi) \\equiv 1 \\pmod 2\\}$.\nThe language $\\text{EVEN-SAT}$ is defined as $\\{\\phi \\mid \\#\\text{SAT}(\\phi) > 0 \\text{ and } \\#\\text{SAT}(\\phi) \\equiv 0 \\pmod 2\\}$.\n\n**Analysis of Option A: $\\text{EVEN-SAT}$ is in NP.**\nA language $L$ is in NP if for every instance $x \\in L$, there exists a polynomial-length certificate that can be verified in polynomial time. For $\\phi \\in \\text{EVEN-SAT}$, a potential certificate would be one of its satisfying assignments. A verifier can certainly check in polynomial time if a given assignment satisfies $\\phi$. However, this only proves that $\\#\\text{SAT}(\\phi) > 0$. It provides no information about whether the total number of satisfying assignments is even. To know the total count is even, one seemingly needs to count them all, which is a $\\#\\text{P}$-hard problem. There is no known polynomial-time verifiable, polynomial-length certificate for the \"evenness\" property. Therefore, $\\text{EVEN-SAT}$ is not known to be in NP.\n\n**Analysis of Option B: $\\text{EVEN-SAT}$ is in co-NP.**\nA language $L$ is in co-NP if its complement, $\\bar{L}$, is in NP. The complement of $\\text{EVEN-SAT}$ is the set of all formulas that are not in $\\text{EVEN-SAT}$.\n$$ \\overline{\\text{EVEN-SAT}} = \\{\\phi \\mid \\neg(\\#\\text{SAT}(\\phi) > 0 \\text{ and } \\#\\text{SAT}(\\phi) \\text{ is even})\\} $$\n$$ \\overline{\\text{EVEN-SAT}} = \\{\\phi \\mid \\#\\text{SAT}(\\phi) = 0 \\text{ or } \\#\\text{SAT}(\\phi) \\text{ is odd}\\} $$\nThis is the union of the language $\\text{UNSAT}$ (formulas with 0 solutions) and $\\text{ODD-SAT}$. To show that $\\overline{\\text{EVEN-SAT}}$ is in NP, we would need a certificate for any formula $\\phi$ that is either unsatisfiable or has an odd number of solutions. If $\\phi$ has an odd number of solutions, a single satisfying assignment could serve as a certificate, but the verifier would face the same problem as in Option A: it cannot confirm that the total number of solutions is odd. If $\\phi$ is unsatisfiable, there is no known short certificate (this is the essence of $\\text{UNSAT}$ being co-NP-complete). Since there is no known uniform certificate that works for all cases in $\\overline{\\text{EVEN-SAT}}$, it is not known to be in NP. Thus, $\\text{EVEN-SAT}$ is not known to be in co-NP.\n\n**Analysis of Option C: $\\text{EVEN-SAT}$ is the complement of $\\text{ODD-SAT}$.**\nThe language $\\text{ODD-SAT}$ is $\\{\\phi \\mid \\#\\text{SAT}(\\phi) \\text{ is odd}\\}$.\nIts complement, $\\overline{\\text{ODD-SAT}}$, is the set of all formulas that do not have an odd number of satisfying assignments.\n$$ \\overline{\\text{ODD-SAT}} = \\{\\phi \\mid \\#\\text{SAT}(\\phi) \\text{ is even}\\} $$\nThis includes formulas for which $\\#\\text{SAT}(\\phi) = 0$.\nThe language $\\text{EVEN-SAT}$ is $\\{\\phi \\mid \\#\\text{SAT}(\\phi) > 0 \\text{ and } \\#\\text{SAT}(\\phi) \\text{ is even}\\}$.\nThe two sets are different. For example, an unsatisfiable formula $\\phi$ (e.g., $x \\land \\neg x$) has $\\#\\text{SAT}(\\phi)=0$, which is an even number. So, $\\phi \\in \\overline{\\text{ODD-SAT}}$, but $\\phi \\notin \\text{EVEN-SAT}$ because the number of solutions is not positive. Therefore, $\\text{EVEN-SAT}$ is not the complement of $\\text{ODD-SAT}$.\n\n**Analysis of Option D: $\\text{ODD-SAT}$ can be solved in polynomial time by a deterministic Turing machine that has access to an oracle for $\\text{EVEN-SAT}$.**\nThis statement claims there is a polynomial-time reduction from $\\text{ODD-SAT}$ to $\\text{EVEN-SAT}$. Let's try to construct an algorithm for $\\text{ODD-SAT}$ that uses an oracle for $\\text{EVEN-SAT}$. Let the oracle be `isEvenSat(formula)`.\n\nAn algorithm to decide if a given formula $\\phi$ is in $\\text{ODD-SAT}$:\n1. Call the oracle `isEvenSat`($\\phi$).\n2. If `isEvenSat`($\\phi$) returns TRUE, it means $\\#\\text{SAT}(\\phi)$ is positive and even. Thus, $\\#\\text{SAT}(\\phi)$ is not odd. The algorithm returns FALSE.\n3. If `isEvenSat`($\\phi$) returns FALSE, the definition of `EVEN-SAT` implies that $\\#\\text{SAT}(\\phi) = 0$ or $\\#\\text{SAT}(\\phi)$ is odd. We must distinguish between these two cases.\n4. To distinguish them, we construct a new formula $\\phi'$. Let $\\phi$ have $n$ variables $x_1, \\dots, x_n$. Let's create $\\phi'$ with an additional new variable $y$:\n   $$ \\phi' = \\phi \\lor y $$\n   The variables of $\\phi'$ are $(x_1, \\dots, x_n, y)$. Let's count the satisfying assignments of $\\phi'$.\n   An assignment satisfies $\\phi'$ if it satisfies $\\phi$ or if it satisfies $y$. The assignments can be partitioned into two sets based on the value of $y$:\n   - If $y=1$: The formula $\\phi'$ becomes $\\phi \\lor 1$, which is always TRUE. Any assignment to $x_1, \\dots, x_n$ will satisfy $\\phi'$. There are $2^n$ such assignments.\n   - If $y=0$: The formula $\\phi'$ becomes $\\phi \\lor 0$, which is equivalent to $\\phi$. The number of satisfying assignments for $x_1, \\dots, x_n$ is $\\#\\text{SAT}(\\phi)$.\n   The total number of satisfying assignments for $\\phi'$ is the sum from these two disjoint cases:\n   $$ \\#\\text{SAT}(\\phi') = \\#\\text{SAT}(\\phi) + 2^n $$\n   Let's assume the number of variables $n \\ge 1$, so $2^n$ is a positive even integer.\n   \n5. Now, we analyze $\\#\\text{SAT}(\\phi')$ based on the two possibilities for $\\#\\text{SAT}(\\phi)$ from step 3:\n   - Case 3a: If $\\#\\text{SAT}(\\phi) = 0$, then $\\#\\text{SAT}(\\phi') = 0 + 2^n = 2^n$. Since $n \\ge 1$, $\\#\\text{SAT}(\\phi')$ is a positive even number. Thus, in this case, $\\phi' \\in \\text{EVEN-SAT}$.\n   - Case 3b: If $\\#\\text{SAT}(\\phi)$ is odd, then $\\#\\text{SAT}(\\phi') = \\text{odd} + \\text{even} = \\text{odd}$. An odd number can't be 0. So $\\#\\text{SAT}(\\phi')$ is a positive odd number. Thus, in this case, $\\phi' \\notin \\text{EVEN-SAT}$.\n   \n6. We can now use our oracle on $\\phi'$ to distinguish the cases.\n   Call `isEvenSat`($\\phi'$).\n   - If `isEvenSat`($\\phi'$) returns TRUE, we are in Case 3a, meaning $\\#\\text{SAT}(\\phi) = 0$. This is not odd. The algorithm returns FALSE.\n   - If `isEvenSat`($\\phi'$) returns FALSE, we are in Case 3b, meaning $\\#\\text{SAT}(\\phi)$ is odd. The algorithm returns TRUE.\n\nThis complete algorithm decides $\\text{ODD-SAT}$ in polynomial time. It makes two oracle calls to `EVEN-SAT` and involves a polynomial-time construction of $\\phi'$. Thus, the statement in Option D is correct.\n\nFinal conclusion: Options A, B, and C are incorrect. Option D is correct.", "answer": "$$\\boxed{D}$$", "id": "1454447"}]}