{"hands_on_practices": [{"introduction": "The practical impact of a fixed-parameter tractable (FPT) algorithm often depends on the specific function of the parameter $k$. This first exercise provides a concrete numerical comparison between two FPT algorithms that have different dependencies on $k$: one with a polynomial dependency ($k^2$) and one with an exponential dependency ($2^k$). By calculating the computational cost in a realistic bioinformatics scenario, you will develop an intuition for why the nature of the parameter function $f(k)$ is a critical factor in an algorithm's practical feasibility, even when both algorithms are in the class FPT. [@problem_id:1434347]", "problem": "A bioinformatics research team is developing algorithms to search for a specific functional motif within a very large Deoxyribonucleic acid (DNA) sequence. The size of the DNA sequence is denoted by $n$, and a key structural property of the motif is described by an integer parameter $k$. The team has two competing algorithms, `PolyScan` and `ExpoScan`.\n\nThe computational cost of each algorithm, measured in the total number of elementary operations, has been determined through theoretical analysis and experimental benchmarks.\n- The cost for `PolyScan`, $N_P$, is given by the function $N_P(n, k) = c_P k^2 n^2$.\n- The cost for `ExpoScan`, $N_E$, is given by the function $N_E(n, k) = c_E 2^k n^2$.\n\nFrom benchmarks on a particular high-performance computing cluster, the scaling constants have been estimated as $c_P = 1.0 \\times 10^{-12}$ operations/unit and $c_E = 8.0 \\times 10^{-16}$ operations/unit.\n\nThe team needs to process a newly sequenced genome where the main input size is $n = 5.0 \\times 10^6$ and the relevant motif parameter is $k = 20$. Calculate the ratio of the total number of operations required by `ExpoScan` to the total number of operations required by `PolyScan` for this specific task.\n\nRound your final answer to three significant figures.", "solution": "The goal is to find the ratio of the total number of operations for `ExpoScan` to that of `PolyScan`, which we can denote as $R = \\frac{N_E}{N_P}$.\n\nThe number of operations for each algorithm is given by the following functions:\nFor `PolyScan`:\n$$N_P(n, k) = c_P k^2 n^2$$\nFor `ExpoScan`:\n$$N_E(n, k) = c_E 2^k n^2$$\n\nWe are given the following values for the constants and parameters:\n- $c_P = 1.0 \\times 10^{-12}$\n- $c_E = 8.0 \\times 10^{-16}$\n- $n = 5.0 \\times 10^6$\n- $k = 20$\n\nNow, we can set up the ratio $R$:\n$$R = \\frac{N_E}{N_P} = \\frac{c_E 2^k n^2}{c_P k^2 n^2}$$\n\nNotice that the term $n^2$ appears in both the numerator and the denominator. We can cancel this term, which simplifies the expression for the ratio. This illustrates a key idea in parameterized complexity: for a fixed parameter $k$, the scaling with the input size $n$ might be the same, so the choice of algorithm depends critically on the behavior with respect to $k$.\n\nThe simplified ratio is:\n$$R = \\frac{c_E 2^k}{c_P k^2}$$\n\nNow, we substitute the given numerical values into this simplified expression:\n$$R = \\frac{(8.0 \\times 10^{-16}) \\cdot 2^{20}}{(1.0 \\times 10^{-12}) \\cdot 20^2}$$\n\nLet's evaluate the powers of $k$ and 2:\n- $k^2 = 20^2 = 400 = 4.0 \\times 10^2$\n- $2^{20} = (2^{10})^2 = (1024)^2 = 1048576 \\approx 1.048576 \\times 10^6$\n\nSubstitute these values back into the expression for $R$:\n$$R = \\frac{(8.0 \\times 10^{-16}) \\cdot (1.048576 \\times 10^6)}{(1.0 \\times 10^{-12}) \\cdot (4.0 \\times 10^2)}$$\n\nNow, let's group the numerical parts and the powers of 10:\n$$R = \\frac{8.0 \\cdot 1.048576}{1.0 \\cdot 4.0} \\times \\frac{10^{-16} \\cdot 10^6}{10^{-12} \\cdot 10^2}$$\n$$R = \\frac{8.388608}{4.0} \\times \\frac{10^{-10}}{10^{-10}}$$\n$$R = 2.097152 \\times 1$$\n$$R = 2.097152$$\n\nThe problem asks to round the final answer to three significant figures. The first three significant figures are 2, 0, and 9. The fourth digit is 7, which is 5 or greater, so we round up the third digit.\n$$R \\approx 2.10$$", "answer": "$$\\boxed{2.10}$$", "id": "1434347"}, {"introduction": "Many fixed-parameter tractable algorithms are based on the principle of a bounded-depth search tree, where the parameter limits the recursion depth. This practice guides you through the analysis of a classic recursive algorithm for the Hitting Set problem, a foundational problem in computer science. By determining the size of the search tree, you will directly see how the parameter $k$ controls the combinatorial explosion, a core technique in designing FPT algorithms. [@problem_id:1434298]", "problem": "The Hitting Set problem is a classic problem in computer science. An instance of the problem is defined by a universe of elements $U$, a collection $C = \\{S_1, S_2, \\ldots, S_m\\}$ of non-empty subsets of $U$, and a positive integer parameter $k$. The question is to determine if there exists a *hitting set* $H \\subseteq U$ with size at most $k$ (i.e., $|H| \\le k$) such that $H$ \"hits\" every set in $C$ (i.e., $H \\cap S_i \\ne \\emptyset$ for all $i=1, \\ldots, m$).\n\nConsider the following recursive algorithm, parameterized by the solution size $k$, designed to solve the Hitting Set problem.\n\n**Algorithm `RecursiveHittingSet(C_current, k_rem)`:**\n1.  If the collection of sets `C_current` is empty, it means all original sets have been hit. Return `true`.\n2.  If `k_rem` is 0 and `C_current` is not empty, the budget for a hitting set is exhausted without hitting all sets. Return `false`.\n3.  Select an arbitrary set $S$ from `C_current`.\n4.  For each element $x$ in $S$:\n    a. Let `C_next` be the sub-collection of `C_current` containing all sets that do not include the element $x$.\n    b. Make a recursive call: `RecursiveHittingSet(C_next, k_rem - 1)`.\n    c. If this recursive call returns `true`, a valid hitting set has been found. Stop and return `true`.\n5.  If the loop completes without any recursive call returning `true`, it is impossible to hit the set $S$ and the remaining sets with the given budget. Return `false`.\n\nThis algorithm's execution can be visualized as a search tree, where each node corresponds to a recursive call. The root represents the initial call, and a node branches out, creating a child for each element $x$ in the set $S$ chosen at that step.\n\nLet $d_{max}$ be the size of the largest set in the original input collection $C$. For a worst-case analysis, assume the algorithm might always need to process a set of size up to $d_{max}$. Which of the following expressions provides the tightest upper bound on the total number of nodes in this search tree, as a function of the parameter $k$ and the maximum set size $d_{max}$?\n\nA. $O(k \\cdot d_{max})$\n\nB. $O(k^{d_{max}})$\n\nC. $O((d_{max})^k)$\n\nD. $O(d_{max} \\log k)$", "solution": "At every recursive call, the algorithm selects a set $S$ with $|S| \\le d_{max}$ and branches once for each $x \\in S$. In each branch, it reduces the remaining budget by one, i.e., $k_{rem} \\mapsto k_{rem}-1$, and removes all sets containing $x$. Therefore, in the worst case:\n- The branching factor at each node is at most $d_{max}$.\n- The depth of the search tree is at most $k$, because after $k$ selections the parameter test in step 2 triggers if sets remain.\n\nLet $T(k)$ denote the maximum number of nodes in the search tree when the remaining budget is $k$. Then the worst-case recurrence satisfies\n$$\nT(k) \\le 1 + d_{max} \\, T(k-1), \\quad T(0) \\le 1.\n$$\nUnrolling this yields\n$$\nT(k) \\le \\sum_{i=0}^{k} d_{max}^{i} = \\frac{d_{max}^{k+1}-1}{d_{max}-1} = O\\!\\left(d_{max}^{k}\\right) \\quad \\text{for } d_{max} \\ge 2,\n$$\nand for $d_{max}=1$ we have $T(k) \\le k+1 = O(1) = O\\!\\left(d_{max}^{k}\\right)$ as well.\n\nMoreover, this bound is tight up to constant factors: for example, consider $k+1$ pairwise disjoint sets each of size $d_{max}$ and ask for a hitting set of size at most $k$. The algorithm may explore a full $d_{max}$-ary tree of depth $k$ before concluding, giving $\\Theta\\!\\left(d_{max}^{k}\\right)$ nodes.\n\nAmong the options, the tightest upper bound matching this behavior is $O\\!\\left((d_{max})^{k}\\right)$.", "answer": "$$\\boxed{C}$$", "id": "1434298"}, {"introduction": "Parameterized reductions are a cornerstone of complexity theory, allowing us to relate the difficulty of different problems and build hierarchies like the W-hierarchy. This final exercise demonstrates how to construct such a reduction, translating the structure of one problem into another while preserving the parameter. You will apply a standard reduction from the $k$-Vertex Cover problem to a special version of the Boolean Satisfiability problem, a process that is key to proving a problem's hardness within the parameterized framework. [@problem_id:1434317]", "problem": "An engineering team is tackling a network monitoring problem. The problem, known as $k$-VERTEX-COVER, is to determine if a given network graph $G=(V,E)$ can be \"monitored\" by placing at most $k$ sensors on a subset of nodes $V' \\subseteq V$, such that every link $(u, v) \\in E$ has at least one sensor on either node $u$ or $v$.\n\nThe team only has access to a specialized solver for a different type of problem, called $k$-BOUNDED-SAT. This solver takes a Boolean formula $\\phi$ in Conjunctive Normal Form (CNF)—a conjunction (AND) of clauses, where each clause is a disjunction (OR) of literals—and an integer $k$. It determines if there is a satisfying truth assignment for $\\phi$ that sets at most $k$ variables to TRUE.\n\nTo use their solver, the team needs to transform any instance $(G, k)$ of $k$-VERTEX-COVER into an instance $(\\phi, k)$ of $k$-BOUNDED-SAT. The transformation works as follows:\n1. For each vertex $v \\in V$ in the graph, a unique Boolean variable $x_v$ is created.\n2. For each edge $(u, v) \\in E$ in the graph, a single clause is constructed using the variables $x_u$ and $x_v$.\n3. The final formula $\\phi$ is the conjunction of all clauses generated in step 2.\n\nThis transformation is designed to have the property that the graph $G$ has a vertex cover of size at most $k$ if and only if the resulting formula $\\phi$ has a satisfying assignment with at most $k$ variables set to TRUE.\n\nConsider a specific graph $G$ with the set of vertices $V = \\{a, b, c, d\\}$ and the set of edges $E = \\{(a, b), (b, c), (c, d), (d, a)\\}$. Following the transformation described, which of the following CNF formulas is the correct output $\\phi$? The variables corresponding to vertices $a, b, c, d$ are $x_a, x_b, x_c, x_d$, respectively.\n\nA. $(x_a \\land x_b) \\lor (x_b \\land x_c) \\lor (x_c \\land x_d) \\lor (x_d \\land x_a)$\n\nB. $(\\neg x_a \\lor \\neg x_b) \\land (\\neg x_b \\lor \\neg x_c) \\land (\\neg x_c \\lor \\neg x_d) \\land (\\neg x_d \\lor \\neg x_a)$\n\nC. $(x_a \\lor x_b) \\land (x_b \\lor x_c) \\land (x_c \\lor x_d) \\land (x_d \\lor x_a)$\n\nD. $(x_a \\leftrightarrow x_b) \\land (x_b \\leftrightarrow x_c) \\land (x_c \\leftrightarrow x_d) \\land (x_d \\leftrightarrow x_a)$\n\nE. $(x_a \\land x_b \\land x_c \\land x_d)$", "solution": "The problem asks us to construct a specific Conjunctive Normal Form (CNF) formula, $\\phi$, from a given graph, $G=(V, E)$, according to a described transformation rule. This transformation bridges the $k$-VERTEX-COVER problem and the $k$-BOUNDED-SAT problem.\n\nThe core idea of the transformation is to establish a direct correspondence between the elements of the two problems. A vertex $v$ being in the vertex cover is mapped to its corresponding Boolean variable $x_v$ being assigned the value TRUE. The size constraint $k$ is kept the same for both problems.\n\nThe defining property of a vertex cover $V'$ is that for every edge $(u, v) \\in E$, at least one of its endpoints must be in the cover. In set-theoretic notation, this is $u \\in V'$ or $v \\in V'$.\n\nUsing the established correspondence, the condition \"$u \\in V'$ or $v \\in V'$\" translates into the logical condition \"$x_u$ is TRUE or $x_v$ is TRUE\". This is precisely the logical disjunction $(x_u \\lor x_v)$. To be a valid vertex cover, this condition must hold for *every* edge in the graph.\n\nThe transformation constructs the final formula $\\phi$ by ensuring this property for all edges simultaneously. It does this by creating one clause of the form $(x_u \\lor x_v)$ for each edge $(u, v) \\in E$. The final formula $\\phi$ is the conjunction (logical AND) of all these clauses, which is required for a CNF formula. Thus, the general form of the transformation is:\n$$ \\phi = \\bigwedge_{(u,v) \\in E} (x_u \\lor x_v) $$\n\nNow, we apply this general rule to the specific instance given in the problem.\nThe graph is $G=(V,E)$ where:\n- The set of vertices is $V = \\{a, b, c, d\\}$.\n- The set of edges is $E = \\{(a, b), (b, c), (c, d), (d, a)\\}$.\n\nThe corresponding Boolean variables are $x_a, x_b, x_c, x_d$. We generate one clause for each edge in $E$:\n1. The edge $(a, b)$ yields the clause $(x_a \\lor x_b)$.\n2. The edge $(b, c)$ yields the clause $(x_b \\lor x_c)$.\n3. The edge $(c, d)$ yields the clause $(x_c \\lor x_d)$.\n4. The edge $(d, a)$ yields the clause $(x_d \\lor x_a)$.\n\nThe final formula $\\phi$ is the conjunction of these four clauses:\n$$ \\phi = (x_a \\lor x_b) \\land (x_b \\lor x_c) \\land (x_c \\lor x_d) \\land (x_d \\lor x_a) $$\n\nLet's compare this result with the given choices:\n- A: $(x_a \\land x_b) \\lor (x_b \\land x_c) \\lor (x_c \\land x_d) \\lor (x_d \\land x_a)$ is in Disjunctive Normal Form (DNF), not CNF. It incorrectly swaps the roles of AND and OR.\n- B: $(\\neg x_a \\lor \\neg x_b) \\land (\\neg x_b \\lor \\neg x_c) \\land (\\neg x_c \\lor \\neg x_d) \\land (\\neg x_d \\lor \\neg x_a)$. The clauses $(\\neg x_u \\lor \\neg x_v)$ are equivalent to $\\neg(x_u \\land x_v)$, meaning that $u$ and $v$ cannot both be in the chosen set. This corresponds to the definition of an Independent Set, not a Vertex Cover.\n- C: $(x_a \\lor x_b) \\land (x_b \\lor x_c) \\land (x_c \\lor x_d) \\land (x_d \\lor x_a)$. This perfectly matches our derived formula.\n- D: This option uses biconditionals ($\\leftrightarrow$), which is not part of the described transformation logic.\n- E: This option is a single clause, which implies all edges are connected to all vertices in a specific way that is not true for the given graph. It would only be correct if the problem reduced to a single giant OR clause, which isn't the case.\n\nTherefore, the correct CNF formula is given in option C.", "answer": "$$\\boxed{C}$$", "id": "1434317"}]}