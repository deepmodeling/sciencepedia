{"hands_on_practices": [{"introduction": "The first step in leveraging parameterized complexity is understanding what makes an algorithm \"Fixed-Parameter Tractable\" (FPT). This exercise challenges you to apply the formal definition of FPT to an algorithm with a complex-looking runtime. It emphasizes the crucial idea that tractability depends on separating the complexity into a function of the parameter $k$ and a polynomial of the input size $n$, regardless of how rapidly the function of $k$ grows [@problem_id:1434065].", "problem": "A team of computational biologists is developing a new algorithm, \"Motif-Interaction-Finder,\" to analyze complex genomic data. The algorithm takes as input a DNA sequence of length $n$ and a set of $k$ distinct gene motifs whose interactions are to be studied. After a theoretical analysis, the team determined that the worst-case time complexity of their algorithm is $O(2^k k! \\cdot n^3)$.\n\nThe team needs to classify their algorithm based on the principles of parameterized complexity. An algorithm is defined as Fixed-Parameter Tractable (FPT) with respect to a parameter $k$ if its running time on an input of size $n$ can be bounded by $f(k) \\cdot p(n)$, where $f$ is any computable function that depends only on the parameter $k$, and $p(n)$ is a polynomial function of the input size $n$.\n\nBased on the provided running time and the definition of FPT, which of the following statements is the correct classification of the \"Motif-Interaction-Finder\" algorithm with respect to the parameter $k$?\n\nA. The algorithm is not FPT because the function of $k$, which is $2^k k!$, grows super-exponentially and is therefore not a computable function.\n\nB. The algorithm is FPT because its running time can be separated into a function $f(k) = 2^k k!$ and a polynomial function $p(n) = n^3$.\n\nC. The algorithm is not FPT because for an algorithm to be fixed-parameter tractable, its dependence on $k$ must be at most exponential (e.g., $c^k$), and the $k!$ term violates this.\n\nD. The algorithm is FPT only if the parameter $k$ is smaller than the input size $n$.\n\nE. The algorithm is not FPT because the entire running time expression $2^k k! \\cdot n^3$ is not a polynomial of $n$ and $k$.", "solution": "We are given a running time bound $T(n,k)=O(2^{k} k! \\cdot n^{3})$ and the FPT definition: an algorithm is fixed-parameter tractable with respect to parameter $k$ if there exist a computable function $f$ depending only on $k$ and a polynomial $p$ such that $T(n,k) \\leq f(k)\\,p(n)$ for all inputs of size $n$.\n\nTo classify the given algorithm, observe that the running time separates as\n$$\nT(n,k)=O\\big(f(k)\\cdot p(n)\\big),\n$$\nwith\n$$\nf(k)=2^{k} k! \\quad \\text{and} \\quad p(n)=n^{3}.\n$$\nThe function $f(k)=2^{k} k!$ depends only on $k$ and is computable, since both $k\\mapsto 2^{k}$ and $k\\mapsto k!$ are computable and the product of computable functions is computable. The factor $p(n)=n^{3}$ is a polynomial in $n$. Therefore, by the definition of FPT, the algorithm is fixed-parameter tractable with respect to $k$.\n\nNow evaluate the options:\n- A is false because $2^{k} k!$ is a computable function; its growth rate does not affect computability.\n- B is true because the running time separates as $f(k)=2^{k} k!$ and $p(n)=n^{3}$, matching the FPT form.\n- C is false because FPT allows any computable dependence on $k$, not only at-most-exponential; factorial is allowed.\n- D is false because FPT classification does not require any relation such as $k<n$; it concerns the form $f(k)\\,p(n)$.\n- E is false because FPT does not require the running time to be polynomial in both $n$ and $k$; only polynomial in $n$ with a multiplicative computable $f(k)$ is required.\n\nThus the correct classification is given by option B.", "answer": "$$\\boxed{B}$$", "id": "1434065"}, {"introduction": "With a firm grasp of the definition of FPT, we turn to algorithm design. This practice problem demonstrates the \"bounded search tree\" method, a core technique for creating FPT algorithms. By structuring a recursive solution for the Dominating Set problem, you'll see how systematically exploring choices can lead to a search tree whose size is bounded by a function of the parameter $k$, making an otherwise intractable problem solvable for small $k$ [@problem_id:1434030].", "problem": "A new telecommunications company plans to deploy a network of base stations in a city. The city's layout is modeled as a graph $G=(V, E)$, where the set of vertices $V$ represents key locations and the set of edges $E$ represents direct communication links. A base station placed at a location $v \\in V$ can provide service to $v$ itself and all directly connected locations (its neighbors). A location is considered \"covered\" if it either has a base station or is adjacent to a location with a base station.\n\nThe company wants to determine if it's possible to cover all locations in the city by deploying at most $k$ base stations. Due to municipal regulations, any single location is permitted to have direct communication links to at most $\\Delta$ other locations.\n\nTo solve this, an engineer proposes a recursive algorithm. The algorithm proceeds as follows:\n1. If all locations are covered, the algorithm's current exploration path terminates successfully.\n2. If the budget of $k$ base stations is exhausted ($k=0$) but some locations remain uncovered, this path of exploration fails.\n3. Otherwise, the algorithm identifies an arbitrary uncovered location $u$. To ensure $u$ becomes covered, a base station must be placed at $u$ or at one of its neighbors.\n4. The algorithm then explores each of these possibilities through separate, independent recursive calls. For each choice of placing a base station at a location $v$ (where $v$ is either $u$ or one of its neighbors), a new recursive call is made with a remaining budget of $k-1$ to cover the rest of the network.\n\nLet the total number of ways an exploration path can terminate (either successfully or in failure) be the number of \"outcomes.\" This corresponds to the number of leaves in the full tree of recursive calls.\n\nDetermine the tightest possible worst-case upper bound for the number of outcomes. Express your answer as a function of the budget $k$ and the maximum degree $\\Delta$.", "solution": "Let $T(k,\\Delta)$ denote the maximum possible number of outcomes (leaves) in the recursion tree, over all graphs with maximum degree at most $\\Delta$ and all choices made by the algorithm, given budget $k$.\n\nAt any recursive step with remaining budget $k>0$, the algorithm selects an uncovered vertex $u$. To cover $u$, it branches on placing a base station at one of the vertices in $\\{u\\}\\cup N(u)$, where $N(u)$ denotes the neighbors of $u$. The number of branches in this step is at most $|N(u)|+1\\leq \\Delta+1$. Each branch reduces the budget by $1$, so each subtree from this step is bounded by $T(k-1,\\Delta)$. Therefore,\n$$\nT(k,\\Delta)\\leq (\\Delta+1)\\,T(k-1,\\Delta).\n$$\nThe recursion terminates when $k=0$ or when all vertices are covered. In either case, the current node is a leaf. Thus the base case satisfies\n$$\nT(0,\\Delta)=1.\n$$\nBy unrolling the recurrence, we obtain\n$$\nT(k,\\Delta)\\leq (\\Delta+1)^{k}\\,T(0,\\Delta)=(\\Delta+1)^{k}.\n$$\n\nTo show tightness, construct a graph as the disjoint union of $k$ stars, each isomorphic to $K_{1,\\Delta}$ (one center of degree $\\Delta$ and $\\Delta$ leaves). If the algorithm always selects as $u$ the center of an uncovered star, then at each of the $k$ levels there are exactly $\\Delta+1$ branches (placing at the center or at any of the $\\Delta$ leaves of that star), and covering completes only after exactly one placement per star, i.e., after depth $k$. Hence the recursion tree is a full $(\\Delta+1)$-ary tree of depth $k$, yielding exactly $(\\Delta+1)^{k}$ leaves. Therefore, the bound $(\\Delta+1)^{k}$ is both a worst-case upper bound and tight.", "answer": "$$\\boxed{(\\Delta+1)^{k}}$$", "id": "1434030"}, {"introduction": "Beyond search trees, kernelization offers another powerful avenue for tackling hard problems. This practice explores the fundamental theorem connecting kernelization to FPT: a problem is fixed-parameter tractable if and only if it has a kernel. This problem guides you through the implications of finding a kernel and draws a critical distinction between having *any* kernel and the more desirable property of having a *polynomial kernel* [@problem_id:1434031].", "problem": "In the field of parameterized complexity, a central goal is to find efficient algorithms for problems that are computationally hard in general. This is often achieved by identifying a parameter $k$ related to the input and designing an algorithm whose complexity is exponential only in $k$, but polynomial in the total input size $n$.\n\nA parameterized problem is a language $L \\subseteq \\Sigma^* \\times \\mathbb{N}$, where for an instance $(x, k)$, $x$ is the main part of the input and $k$ is the parameter. A problem is called **Fixed-Parameter Tractable (FPT)** if it can be solved by an algorithm with a running time of $f(k) \\cdot |x|^c$, where $f$ is any computable function depending only on $k$, and $c$ is a constant independent of $k$ and $|x|$.\n\nA **kernelization algorithm** is a polynomial-time algorithm that takes an instance $(x, k)$ of a parameterized problem and returns an equivalent instance $(x', k')$, called the **kernel**. The key property of a kernel is that its size is bounded by a function of the parameter, i.e., $|x'| \\le g(k)$ and $k' \\le g(k)$ for some function $g$. If the size function $g(k)$ is a polynomial in $k$, the kernel is called a **polynomial kernel**.\n\nSuppose a researcher is studying a new parameterized problem and discovers a kernelization algorithm for it. The algorithm runs in time polynomial in the input size $|x|$ and produces a kernel of size bounded by the function $g(k) = k^{\\log k}$, where $k$ is the parameter.\n\nBased on this discovery, which of the following statements is definitively true?\n\nA. The problem is not in FPT because the kernel size $g(k)$ is super-polynomial.\n\nB. The problem has a polynomial kernel because $g(k) = k^{\\log k}$ grows much slower than a purely exponential function like $2^k$.\n\nC. The problem is in FPT, but this specific kernelization does not prove that the problem has a polynomial kernel.\n\nD. It is impossible to determine if the problem is in FPT without knowing the specific algorithm that would be used to solve instances within the kernel.\n\nE. The problem has a polynomial kernel because the kernelization algorithm itself runs in polynomial time.", "solution": "The solution requires a careful understanding of the definitions of Fixed-Parameter Tractability (FPT), kernelization, and polynomial kernels. We will analyze the given scenario step-by-step.\n\n1.  **Relationship between Kernelization and FPT:** A fundamental theorem in parameterized complexity states that a decidable parameterized problem is Fixed-Parameter Tractable (FPT) if and only if it is kernelizable. A problem is \"kernelizable\" if a kernelization algorithm, as described in the problem statement, exists for it. The theorem does not place any constraint on the size of the kernel, other than that its size must be bounded by some computable function $g(k)$ of the parameter $k$.\n\n2.  **Applying the Theorem to the Problem:** The problem statement explicitly states that a kernelization algorithm exists for the problem in question. This algorithm runs in polynomial time and reduces any instance $(x, k)$ to an equivalent kernel $(x', k')$. Therefore, by the theorem, the problem is guaranteed to be in FPT. The total running time to solve the problem would be the sum of the time for kernelization (which is polynomial in $|x|$, say $O(|x|^d)$) and the time to solve the kernel. Since the kernel's size $|x'|$ depends only on $k$ (i.e., $|x'| \\le k^{\\log k}$), any algorithm to solve the kernel, even a brute-force one, will have a running time that is purely a function of $k$. Let's call this time $h(|x'|) = h(k^{\\log k})$. Let $f(k) = h(k^{\\log k})$. The total time is $O(|x|^d) + f(k)$. An algorithm with this running time is, by definition, an FPT algorithm. Thus, the existence of the kernel, regardless of its size, proves the problem is in FPT.\n\n3.  **Analyzing the Kernel Size:** The problem now is to determine if this kernel is a *polynomial kernel*. A polynomial kernel requires the size function $g(k)$ to be a polynomial in $k$. A function $p(k)$ is a polynomial if it can be written as $p(k) = a_d k^d + a_{d-1} k^{d-1} + \\dots + a_0$ for some fixed, constant degree $d$. The given size function is $g(k) = k^{\\log k}$. To check if this is a polynomial, we can compare its growth rate to any arbitrary polynomial $p(k) = k^c$ for a constant $c$. We can analyze the exponent. The function is $k^{\\log k}$. A polynomial has the form $k^c$ where $c$ is a constant. In our case, the exponent is $\\log k$, which is not a constant; it grows with $k$. Therefore, $g(k) = k^{\\log k}$ is not a polynomial function of $k$. It grows faster than any polynomial. For example, for any constant $c > 0$, the ratio $\\frac{k^{\\log k}}{k^c} = k^{\\log k - c}$ goes to infinity as $k \\to \\infty$. This confirms that $k^{\\log k}$ is a super-polynomial function.\n\n4.  **Evaluating the Options:**\n    *   **A. The problem is not in FPT because the kernel size $g(k)$ is super-polynomial.** This is incorrect. As established in step 2, the existence of *any* kernel guarantees the problem is in FPT.\n    *   **B. The problem has a polynomial kernel because $g(k) = k^{\\log k}$ grows much slower than a purely exponential function like $2^k$.** This is incorrect. While it's true that $k^{\\log k}$ is sub-exponential, being \"not exponential\" is not the definition of being polynomial. As shown in step 3, $k^{\\log k}$ is super-polynomial.\n    *   **C. The problem is in FPT, but this specific kernelization does not prove that the problem has a polynomial kernel.** This is correct. The problem is in FPT because it is kernelizable (Step 2). This particular kernel is not a polynomial kernel because its size function $g(k) = k^{\\log k}$ is super-polynomial (Step 3). It's possible the problem might have another, different kernelization algorithm that yields a polynomial kernel, but the one presented does not demonstrate this.\n    *   **D. It is impossible to determine if the problem is in FPT without knowing the specific algorithm that would be used to solve instances within the kernel.** This is incorrect. The existence of the kernelization is sufficient to prove the problem is in FPT, as explained in step 2. We can always use a brute-force (or any) algorithm on the kernel.\n    *   **E. The problem has a polynomial kernel because the kernelization algorithm itself runs in polynomial time.** This is incorrect. It confuses two different properties. The definition of kernelization *requires* the reduction algorithm to run in polynomial time. The definition of a *polynomial kernel* relates to the *size of the output* of that algorithm, not its running time.\n\nTherefore, the only statement that is definitively true is C.", "answer": "$$\\boxed{C}$$", "id": "1434031"}]}