{"hands_on_practices": [{"introduction": "Descriptive complexity begins by framing computational problems as questions about logical properties of finite structures. This first exercise challenges you to translate a specific structural property of a graph—being a 'star graph'—into the precise language of first-order logic. Successfully writing this formula [@problem_id:1420782] requires careful handling of both required connections and forbidden ones, offering excellent practice in using quantifiers and logical connectives to define complex patterns.", "problem": "In the field of descriptive complexity, we study the logical resources needed to define properties of structures. Consider graphs described using the language of first-order logic. The set of all vertices, $V$, serves as the domain of discourse for the logic. The language consists of a single binary relation symbol $E$, where $E(u,v)$ is true if and only if there's an edge connecting vertices $u$ and $v$. The relation $E$ is symmetric, meaning $E(u,v)$ holds if and only if $E(v,u)$ holds. The standard equality symbol, $=$, is also part of the language.\n\nA non-empty graph is defined as a **star graph** if it possesses a unique structural property: there exists a special vertex, called the center, such that:\n1. Every vertex that is not the center is connected by an edge to the center.\n2. There are no other edges in the graph. Specifically, this means:\n    a. No edge connects two vertices if neither is the center.\n    b. No edge connects the center to itself (in fact, no vertex is connected to itself).\n\nWhich of the following first-order sentences correctly and completely expresses the property that a graph is a star graph?\n\nA. $\\exists c \\forall u \\forall v (E(u,v) \\rightarrow ((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c)))$\n\nB. $\\exists c \\forall u \\forall v (((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c)) \\rightarrow E(u,v))$\n\nC. $\\exists c \\forall u \\forall v (E(u,v) \\leftrightarrow (u=c \\lor v=c))$\n\nD. $\\exists c \\forall u \\forall v (E(u,v) \\leftrightarrow ((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c)))$", "solution": "To solve this problem, we must translate the English definition of a star graph into a precise first-order logic sentence. Let's analyze the definition piece by piece and then evaluate each of the given options.\n\nThe definition of a star graph has two main conditions, applied to a graph with at least one vertex, which is implicit in the semantics of first-order logic with a non-empty domain.\n\nFirst, \"there exists a special vertex, called the center...\" This translates to an existential quantifier for this central vertex, which we can call $c$:\n$\\exists c (\\dots)$\n\nNow let's formalize the two conditions that must hold for this center $c$.\n\nCondition 1: \"Every vertex that is not the center is connected by an edge to the center.\"\nThis can be written as: For every vertex $v$, if $v$ is not equal to $c$, then there is an edge between $c$ and $v$.\nIn formal logic: $\\forall v (v \\neq c \\rightarrow E(c,v))$.\n\nCondition 2: \"There are no other edges in the graph.\" This is broken down into two sub-conditions in the problem description.\n2a: \"No edge connects two vertices if neither is the center.\"\nThis means for any two vertices $u$ and $v$, if both are not the center, there is no edge between them. Since edges are between distinct vertices in a simple star graph, we should consider distinct $u$ and $v$.\nIn formal logic: $\\forall u \\forall v ((u \\neq c \\land v \\neq c \\land u \\neq v) \\rightarrow \\neg E(u,v))$.\n2b: \"No edge connects the center to itself (in fact, no vertex is connected to itself).\"\nThis means there are no self-loops.\nIn formal logic: $\\forall x (\\neg E(x,x))$.\n\nCombining all these conditions gives a long but correct formula:\n$\\exists c (\\forall v (v \\neq c \\rightarrow E(c,v)) \\land \\forall u \\forall v ((u \\neq c \\land v \\neq c \\land u \\neq v) \\rightarrow \\neg E(u,v)) \\land \\forall x (\\neg E(x,x)))$.\n\nA more concise way to express conditions 1 and 2 together is to state that an edge $E(u,v)$ exists *if and only if* one vertex is the center $c$ and the other is a distinct, non-center vertex. Let's analyze this biconditional statement, which is of the form $P \\leftrightarrow Q$. This is equivalent to $(P \\rightarrow Q) \\land (Q \\rightarrow P)$.\n\nThe statement is: An edge $E(u,v)$ exists if and only if one vertex is $c$ and the other is not $c$. This can be written as:\n$E(u,v) \\leftrightarrow ((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c))$.\n\nLet's see if this single statement under $\\exists c \\forall u \\forall v$ captures the full definition.\n\nThe \"if\" part ($\\leftarrow$): $((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c)) \\rightarrow E(u,v)$.\nThis says that for any vertex $v$ that is not $c$ (let $u=c$), an edge $E(c,v)$ must exist. This is exactly Condition 1.\n\nThe \"only if\" part ($\\rightarrow$): $E(u,v) \\rightarrow ((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c))$.\nThis says that for an edge $E(u,v)$ to exist, it is necessary that one of its endpoints is $c$ and the other is not. Let's see what this forbids:\n- Can there be an edge between two non-center vertices $u$ and $v$? If $u \\neq c$ and $v \\neq c$, the right-hand side of the implication is false. For the implication to be true, the left-hand side, $E(u,v)$, must also be false. This covers Condition 2a.\n- Can there be a self-loop on the center, $E(c,c)$? Let $u=c$ and $v=c$. The right-hand side is $((c=c \\land c \\neq c) \\lor (c=c \\land c \\neq c))$, which is false. Thus, $E(c,c)$ must be false. This covers the main part of Condition 2b.\n- Can there be a self-loop on a non-center vertex $v$? Let $u=v$ and $u \\neq c$. The right-hand side is $((u=c \\land u \\neq c) \\lor (u=c \\land u \\neq c))$, which is false. Thus, $E(u,u)$ must be false. This covers the rest of Condition 2b.\n\nSo, the sentence $\\exists c \\forall u \\forall v (E(u,v) \\leftrightarrow ((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c)))$ correctly and completely defines a star graph. This corresponds to option D.\n\nNow let's examine why the other options are incorrect.\n\nA. $\\exists c \\forall u \\forall v (E(u,v) \\rightarrow ((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c)))$\nThis is only the \"only if\" part of the correct biconditional. It states that *if* an edge exists, it must connect the center to a non-center vertex. It does not enforce that any edges *must* exist. For example, a graph on three vertices $\\{c, a, b\\}$ with only one edge $E(c,a)$ satisfies this formula, but it is not a star graph because vertex $b$ is not connected to the center $c$.\n\nB. $\\exists c \\forall u \\forall v (((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c)) \\rightarrow E(u,v))$\nThis is only the \"if\" part of the correct biconditional. It requires that the center $c$ be connected to all other vertices. However, it does not forbid other edges. For example, a complete graph on 3 or more vertices, $K_n$, satisfies this formula for any choice of $c$. Any vertex $c$ is connected to all other vertices. But $K_n$ for $n \\ge 3$ is not a star graph because there are edges between non-center vertices.\n\nC. $\\exists c \\forall u \\forall v (E(u,v) \\leftrightarrow (u=c \\lor v=c))$\nThis formula states that an edge exists between $u$ and $v$ if and only if at least one of them is the center $c$. Let's test this for the case $u=c$ and $v=c$. The right side $(c=c \\lor c=c)$ is true. Therefore, for the biconditional to hold, the left side $E(c,c)$ must also be true. This means the formula requires a self-loop on the center vertex, which violates the definition of a star graph (and simple graphs in general).\n\nTherefore, option D is the only one that captures all the necessary and sufficient conditions for a graph to be a star graph.", "answer": "$$\\boxed{D}$$", "id": "1420782"}, {"introduction": "While first-order logic is expressive, it has its limits, and the Ehrenfeucht-Fraïssé game is a powerful tool for understanding them. The game helps us determine if two structures are \"elementarily equivalent,\" meaning no first-order sentence can tell them apart. In this practice [@problem_id:1420779], you will take on the role of the Spoiler to demonstrate a structural difference between a path and a cycle, developing a winning strategy that reveals a property one graph has and the other lacks.", "problem": "Consider two simple, undirected graphs, $G_1$ and $G_2$.\nThe first graph, $G_1$, is a path graph with vertex set $V_1 = \\{p_1, p_2, p_3\\}$ and edge set $E_1 = \\{\\{p_1, p_2\\}, \\{p_2, p_3\\}\\}$.\nThe second graph, $G_2$, is a cycle graph with vertex set $V_2 = \\{c_1, c_2, c_3\\}$ and edge set $E_2 = \\{\\{c_1, c_2\\}, \\{c_2, c_3\\}, \\{c_3, c_1\\}\\}$.\n\nAn Ehrenfeucht-Fraïssé (EF) game is played on these two graphs by two players, Spoiler and Duplicator. We will consider a 2-round game.\nThe rules of the game are as follows:\n- The game proceeds in two rounds.\n- In each round $i$ (for $i=1, 2$), Spoiler chooses one vertex from either $G_1$ or $G_2$.\n- Duplicator must then respond by choosing a vertex in the other graph (the one Spoiler did not pick from).\n- Let the vertices chosen from $G_1$ after two rounds be $v_1, v_2 \\in V_1$, and the corresponding vertices chosen from $G_2$ be $u_1, u_2 \\in V_2$.\n\nDuplicator wins if the mapping between the chosen vertices preserves the structure of the graphs. That is, for any pair of chosen vertices in $G_1$, they are connected by an edge if and only if their corresponding vertices in $G_2$ are also connected by an edge. Spoiler wins if this condition is not met at the end of the game.\n\nSpoiler's goal is to choose vertices in a way that Duplicator cannot maintain this structural correspondence. Which of the following first-round moves for Spoiler guarantees a win for Spoiler in this 2-round game, regardless of Duplicator's responses?\n\nA. Spoiler chooses vertex $p_2$ in graph $G_1$.\n\nB. Spoiler chooses vertex $c_2$ in graph $G_2$.\n\nC. Spoiler chooses vertex $p_1$ in graph $G_1$.\n\nD. Duplicator has a winning strategy in a 2-round game, so no first-round move guarantees a win for Spoiler.", "solution": "We analyze the 2-round Ehrenfeucht-Fraïssé game between $G_{1}$ (a path on three vertices) and $G_{2}$ (a 3-cycle). In a standard EF game on graphs, Duplicator must maintain a partial isomorphism between the pebbled vertices, which requires preserving both equality and the edge relation. Formally, if after two rounds Spoiler has pebbled $v_{1},v_{2} \\in V_{1}$ and Duplicator has pebbled $u_{1},u_{2} \\in V_{2}$, then Duplicator wins only if for all $i,j \\in \\{1,2\\}$,\n$$\nv_{i}=v_{j} \\iff u_{i}=u_{j}, \\quad \\text{and} \\quad E_{1}(v_{i},v_{j}) \\iff E_{2}(u_{i},u_{j}).\n$$\n\nKey graph properties:\n- In $G_{1}$, $p_{2}$ has degree $2$ and $p_{1},p_{3}$ have degree $1$, with $E_{1}(p_{1},p_{3})$ false.\n- In $G_{2}$, every pair of distinct vertices is adjacent, so for distinct $x,y \\in V_{2}$, $E_{2}(x,y)$ is true.\n\nWe check each proposed first move.\n\nA. Spoiler chooses $p_{2}$ in $G_{1}$. Duplicator responds with any $c \\in V_{2}$. On the second move, any choice $v_{2} \\in V_{1} \\setminus \\{p_{2}\\}$ satisfies $E_{1}(p_{2},v_{2})$ true. Duplicator can pick $u_{2} \\in V_{2} \\setminus \\{c\\}$, for which $E_{2}(c,u_{2})$ is true, preserving both distinctness and adjacency. No violation can be forced in two rounds, so this first move does not guarantee a Spoiler win.\n\nB. Spoiler chooses $c_{2}$ in $G_{2}$. Duplicator can respond with $p_{2}$ in $G_{1}$. Then for any second move where Spoiler picks a vertex distinct from the first, both $c_{2}$ in $G_{2}$ and $p_{2}$ in $G_{1}$ are adjacent to all other distinct vertices. Duplicator can match adjacency and distinctness in the response, so Spoiler cannot force a violation in two rounds. Thus this first move does not guarantee a win.\n\nC. Spoiler chooses $p_{1}$ in $G_{1}$. Let Duplicator respond with any $u_{1} \\in V_{2}$. Spoiler then chooses $v_{2}=p_{3} \\neq p_{1}$ in $G_{1}$, for which $E_{1}(p_{1},p_{3})$ is false. To preserve both conditions, Duplicator must pick $u_{2} \\in V_{2}$ with $u_{2} \\neq u_{1}$ and $E_{2}(u_{1},u_{2})$ false. However, in $G_{2}$ every pair of distinct vertices is adjacent, so no such $u_{2}$ exists. If Duplicator instead sets $u_{2}=u_{1}$ to make $E_{2}(u_{1},u_{2})$ false, then equality fails to be preserved because $v_{2} \\neq v_{1}$ but $u_{2}=u_{1}$. Therefore Duplicator cannot maintain a partial isomorphism, and Spoiler wins. Hence this first move guarantees a Spoiler win.\n\nD. This is false because option C is a Spoiler-winning first move.\n\nTherefore, the correct choice is C.", "answer": "$$\\boxed{C}$$", "id": "1420779"}, {"introduction": "Many important graph properties, such as reachability, involve recursion and cannot be expressed in first-order logic alone. To capture these, we need more powerful logics, like those with fixed-point operators. This exercise [@problem_id:1420810] introduces Datalog, a query language whose recursive rules provide a concrete way to implement fixed-point logic, and asks you to write a program to find all nodes in a cycle, illustrating a concept that is beyond the reach of standard FO.", "problem": "In the analysis of computer networks, it is often necessary to identify cyclic dependencies. Consider a directed graph representing a network, where nodes are servers and edges represent one-way data links. The structure of this network is described by a single predicate `Edge(u, v)`, which is true if and only if there is a direct data link from server `u` to server `v`.\n\nA server is considered part of a \"feedback loop\" or cycle if there exists a path of one or more links starting from that server and eventually returning to it. Your task is to identify the correct Datalog program that defines a new predicate, `InCycle(x)`, which is true for every server `x` that is part of at least one cycle.\n\nIn Datalog syntax, `:-` represents logical implication (read as \"if\"), commas represent logical AND, and variables are denoted by uppercase letters (e.g., `X`, `Y`, `Z`).\n\nWhich of the following Datalog programs correctly identifies all servers that belong to a cycle?\n\nA.\n`Reaches(X, Y) :- Edge(X, Y).`\n`Reaches(X, Z) :- Reaches(X, Y), Edge(Y, Z).`\n`InCycle(X) :- Reaches(X, X).`\n\nB.\n`InCycle(X) :- Edge(X, X).`\n\nC.\n`Reaches(X, Y) :- Edge(X, Y).`\n`InCycle(X) :- Reaches(X, Y), Reaches(Y, X).`\n\nD.\n`InCycle(X) :- Edge(X, Y), InCycle(Y).`\n\nE.\n`Reaches(X, Y) :- Edge(X, Y).`\n`Reaches(X, Z) :- Reaches(X, Y), Edge(Y, Z).`\n`InCycle(X) :- Reaches(Y, X).`", "solution": "The problem asks for a Datalog program to find all nodes in a directed graph that are part of a cycle. A node `X` is in a cycle if there is a path of length one or more from `X` back to itself. Let's analyze the logic required and then evaluate each option.\n\n**Core Logic for Cycle Detection**\n\n1.  **Define Reachability:** First, we need to define the concept of a path or \"reachability\" between any two nodes. Let's create a predicate `Reaches(A, B)` that is true if there is a path of length at least one from node `A` to node `B`. This is a classic transitive closure problem.\n2.  **Base Case:** A path of length one exists between `X` and `Y` if there is a direct edge between them. In Datalog, this is:\n    `Reaches(X, Y) :- Edge(X, Y).`\n3.  **Recursive Step:** A path exists from `X` to `Z` if there is a path from `X` to some intermediate node `Y`, and a direct edge from `Y` to `Z`. This allows us to extend existing paths by one edge. In Datalog, this is:\n    `Reaches(X, Z) :- Reaches(X, Y), Edge(Y, Z).`\n    These two rules together correctly compute the transitive closure of the `Edge` relation, meaning `Reaches(A, B)` will be true for all pairs `(A, B)` where `B` is reachable from `A`.\n4.  **Define Cycle Membership:** With the `Reaches` predicate properly defined, a node `X` is in a cycle if it can reach itself. This is a simple query on our `Reaches` predicate:\n    `InCycle(X) :- Reaches(X, X).`\n\nCombining these steps gives us the complete program. Now let's analyze the given options based on this logic.\n\n**Analysis of Options**\n\n*   **Option A:**\n    `Reaches(X, Y) :- Edge(X, Y).`\n    `Reaches(X, Z) :- Reaches(X, Y), Edge(Y, Z).`\n    `InCycle(X) :- Reaches(X, X).`\n    This program exactly matches the logic derived above. The first two rules compute the reachability relation (transitive closure), and the third rule correctly identifies a node as being in a cycle if it can reach itself. This program is correct.\n\n*   **Option B:**\n    `InCycle(X) :- Edge(X, X).`\n    This program only identifies nodes that have a self-loop (an edge from the node to itself). This corresponds to a cycle of length 1. It fails to find nodes that are part of longer cycles (e.g., `A - B - A`). Therefore, it is incorrect.\n\n*   **Option C:**\n    `Reaches(X, Y) :- Edge(X, Y).`\n    `InCycle(X) :- Reaches(X, Y), Reaches(Y, X).`\n    This program is flawed because the `Reaches` predicate is not defined recursively. The only rule for `Reaches` is `Reaches(X, Y) :- Edge(X, Y)`, which means `Reaches` is identical to `Edge`. Substituting this into the `InCycle` rule gives `InCycle(X) :- Edge(X, Y), Edge(Y, X)`. This program only finds nodes that are part of a cycle of length exactly 2. It will miss cycles of length 1 and cycles of length 3 or more. Therefore, it is incorrect.\n\n*   **Option D:**\n    `InCycle(X) :- Edge(X, Y), InCycle(Y).`\n    This is an ill-formed recursive rule. Datalog evaluation works by starting with the known facts (the `Edge` predicate) and deriving new facts. This rule for `InCycle` requires an `InCycle` fact on the right-hand side to derive a new `InCycle` fact on the left-hand side. Since there is no \"base case\" rule that can produce the first `InCycle` fact from `Edge` facts alone, this program will never produce any output for `InCycle`. Therefore, it is incorrect.\n\n*   **Option E:**\n    `Reaches(X, Y) :- Edge(X, Y).`\n    `Reaches(X, Z) :- Reaches(X, Y), Edge(Y, Z).`\n    `InCycle(X) :- Reaches(Y, X).`\n    The `Reaches` predicate is defined correctly. However, the rule for `InCycle` is logically flawed. `InCycle(X) :- Reaches(Y, X)` states that a node `X` is in a cycle if *any* node `Y` can reach it. In a typical connected graph, this would label almost every node as being in a cycle, which is not the definition of being part of a cycle. For a node `X` to be in a cycle, it must be able to reach *itself*. This rule does not enforce this condition. Therefore, it is incorrect.\n\nBased on the analysis, Option A is the only program that correctly defines reachability and then uses it to identify nodes that can reach themselves.", "answer": "$$\\boxed{A}$$", "id": "1420810"}]}