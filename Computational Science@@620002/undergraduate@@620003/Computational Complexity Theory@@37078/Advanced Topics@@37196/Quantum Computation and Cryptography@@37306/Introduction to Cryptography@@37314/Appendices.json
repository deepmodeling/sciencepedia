{"hands_on_practices": [{"introduction": "To begin our hands-on exploration, we'll start with one of the oldest concepts in cryptanalysis: the brute-force attack. The security of any cipher fundamentally depends on the computational effort required to break it without possessing the secret key. This exercise [@problem_id:1428747] provides a concrete way to quantify the security of a simple cipher by analyzing the time complexity of trying every possible key, directly linking the size of the key space to its practical security.", "problem": "A company has developed a low-power, short-range communication system for autonomous environmental sensors. To provide a minimal level of data security against casual interception, the system employs a classical cryptographic algorithm known as a shift cipher.\n\nIn this system, a message is encrypted by substituting each character from a predefined alphabet with another character from the same alphabet. The substitution is determined by a secret integer key, $k$. Specifically, if the alphabet is treated as a circular sequence of characters, each character in the original message (plaintext) is replaced by the character found $k$ positions forward in the sequence. For example, with the English alphabet (A=0, B=1, ... Z=25) and a key $k=3$, 'A' would become 'D', 'B' would become 'E', and 'Z' would become 'C'.\n\nAn analyst is tasked with evaluating the system's vulnerability to a brute-force attack. A brute-force attack involves systematically decrypting a captured ciphertext with every possible unique key and then checking each resulting plaintext to see if it is valid (e.g., if it contains a known header or is grammatically correct).\n\nAssume the following:\n- The size of the alphabet used by the system is denoted by $|\\Sigma|$.\n- The length of the captured ciphertext message is $N$ characters.\n- The process of decrypting the entire $N$-character message with a single key takes time proportional to $N$.\n- The process of checking whether a decrypted message is valid also takes time proportional to $N$.\n\nDetermine the worst-case time complexity for a complete brute-force attack on a single captured message. Express your answer using Big-O notation as a function of the alphabet size $|\\Sigma|$ and the message length $N$.", "solution": "Let the alphabet have cardinality $|\\Sigma|$. For a classical shift cipher, the key space is the set of all possible shifts modulo $|\\Sigma|$, giving exactly $|\\Sigma|$ unique keys to try.\n\nBy assumption, decrypting an $N$-character ciphertext under a fixed key takes time proportional to $N$; denote this by $c_{1}N$. The validity check of the resulting plaintext also takes time proportional to $N$; denote this by $c_{2}N$. Therefore, the total time per key is\n$$\nT_{\\text{per-key}} = c_{1}N + c_{2}N = (c_{1}+c_{2})N = \\Theta(N).\n$$\n\nIn the worst case, a brute-force attack must try all $|\\Sigma|$ keys. Hence the total time is\n$$\nT_{\\text{total}}(|\\Sigma|,N) = |\\Sigma| \\cdot T_{\\text{per-key}} = |\\Sigma| \\cdot \\Theta(N) = \\Theta(|\\Sigma|\\,N).\n$$\nTherefore, the worst-case time complexity in Big-O notation is\n$$\nO(|\\Sigma|\\,N).\n$$", "answer": "$$\\boxed{O(|\\Sigma|\\,N)}$$", "id": "1428747"}, {"introduction": "Modern cryptography aims for a much stronger guarantee than simply resisting brute-force attacks: it seeks to prevent any partial information about the original message from being leaked, a property related to semantic security. This thought experiment [@problem_id:1428754] explores a critical weakness in deterministic encryption schemes. By analyzing the consequences of reusing a key, you will discover how an attacker can gain valuable insight without ever finding the key, highlighting why modern protocols must incorporate randomness to be truly secure.", "problem": "A technology startup, \"Innovate Inc.\", develops a new communication protocol for sending daily status updates between its servers. The daily update is always one of two possible messages: $M_{GOOD} = \\text{\"System nominal\"}$ or $M_{BAD} = \\text{\"Anomaly detected\"}$.\n\nTo protect these messages from a corporate rival, \"Specter Corp.\", Innovate Inc. employs a symmetric encryption scheme defined by a pair of algorithms, `Enc` (encryption) and `Dec` (decryption). This particular scheme is **deterministic**, meaning that for a given secret key $k$ and a plaintext message $m$, the encryption function `Enc(k, m)` will always produce the exact same ciphertext $c$. Innovate Inc. uses the same secret key $k$ every day to encrypt its daily status update.\n\nAn analyst at Specter Corp., named Eve, manages to intercept the encrypted messages for two consecutive days. Let $c_1$ be the ciphertext from Day 1 and $c_2$ be the ciphertext from Day 2. Eve does not know the secret key $k$, but she is aware of the encryption algorithm's deterministic nature and knows the set of possible plaintext messages $\\{M_{GOOD}, M_{BAD}\\}$.\n\nBased solely on her observation and comparison of $c_1$ and $c_2$, what is the most significant piece of information Eve can reliably deduce?\n\nA. Whether the system status on Day 1 was the same as on Day 2.\n\nB. The secret key $k$ used for encryption.\n\nC. The specific content of the Day 1 message (i.e., whether it was $M_{GOOD}$ or $M_{BAD}$).\n\nD. The specific content of the Day 2 message (i.e., whether it was $M_{GOOD}$ or $M_{BAD}$).\n\nE. Nothing of value, because the key remains secret.\n\nF. The specific content of both the Day 1 and Day 2 messages.", "solution": "The problem explores a fundamental weakness of deterministic encryption schemes when a key is reused. Let's analyze the scenario step-by-step.\n\nThe encryption scheme is defined by `Enc(k, m)`, where $k$ is the secret key and $m$ is the plaintext message. The crucial property is that the scheme is **deterministic**. This means that if you encrypt the same message with the same key multiple times, you will always get the same ciphertext.\n\nLet $m_1$ be the plaintext message on Day 1 and $m_2$ be the plaintext message on Day 2.\nThe corresponding ciphertexts intercepted by Eve are:\n$c_1 = \\text{Enc}(k, m_1)$\n$c_2 = \\text{Enc}(k, m_2)$\n\nEve's goal is to extract information by comparing $c_1$ and $c_2$.\n\nLet's consider two cases:\n\nCase 1: The system status was the same on both days.\nThis means $m_1 = m_2$.\nBecause the encryption function `Enc` is deterministic and the key $k$ is the same, applying `Enc` to the same input $(k, m_1)$ and $(k, m_2)$ must yield the same output.\nTherefore, if $m_1 = m_2$, it must be true that $\\text{Enc}(k, m_1) = \\text{Enc}(k, m_2)$, which implies $c_1 = c_2$.\n\nCase 2: The system status was different on the two days.\nThis means $m_1 \\neq m_2$.\nA valid encryption scheme must be invertible (otherwise decryption would be ambiguous). This means that for a fixed key $k$, two different plaintexts must map to two different ciphertexts. If $\\text{Enc}(k, m_1) = \\text{Enc}(k, m_2)$ for $m_1 \\neq m_2$, it would be impossible to know whether to decrypt the resulting ciphertext to $m_1$ or $m_2$.\nTherefore, if $m_1 \\neq m_2$, it must be true that $\\text{Enc}(k, m_1) \\neq \\text{Enc}(k, m_2)$, which implies $c_1 \\neq c_2$.\n\nCombining these two cases, we establish a direct equivalence:\n$m_1 = m_2 \\iff c_1 = c_2$\n\nEve can perform a simple string comparison on the two ciphertexts she has intercepted, $c_1$ and $c_2$.\n- If she finds that $c_1$ is identical to $c_2$, she can conclude with certainty that the plaintext messages were identical, i.e., $m_1 = m_2$.\n- If she finds that $c_1$ is different from $c_2$, she can conclude with certainty that the plaintext messages were different, i.e., $m_1 \\neq m_2$.\n\nThis is a significant leak of information. The property that an attacker cannot learn any information about the plaintext from the ciphertext (beyond its length) is known as semantic security. By learning the relationship between two plaintexts (whether they are equal or not), this deterministic scheme fails to provide semantic security for multiple messages.\n\nNow let's evaluate the given options:\n\nA. **Whether the system status on Day 1 was the same as on Day 2.** This is exactly what we have shown Eve can determine. By checking if $c_1 = c_2$, she learns if $m_1 = m_2$. This statement is correct.\n\nB. **The secret key $k$ used for encryption.** The problem states nothing that would allow Eve to reverse the encryption and find the key. Determinism is a property that does not, by itself, imply a weak encryption algorithm in terms of key recovery. This statement is incorrect.\n\nC. **The specific content of the Day 1 message.** Even if Eve knows $m_1=m_2$ (because $c_1=c_2$), she doesn't know if both messages were $M_{GOOD}$ or if both were $M_{BAD}$. She only knows they are the same. Without the key $k$, she cannot compute $m_1 = \\text{Dec}(k, c_1)$. This statement is incorrect.\n\nD. **The specific content of the Day 2 message.** For the same reason as C, this is incorrect.\n\nE. **Nothing of value, because the key remains secret.** This is incorrect. Eve learns a valuable piece of information: the relationship between the two messages. For example, if she knows that Day 1 was \"System nominal\", and she sees the same ciphertext on Day 2, she now knows Day 2 is also \"System nominal\", even without knowing the key. The information leak is real.\n\nF. **The specific content of both the Day 1 and Day 2 messages.** This is a stronger claim than C and D and is also incorrect for the same reasons. Eve cannot decrypt the messages without the key.\n\nTherefore, the most significant and reliable piece of information Eve can deduce is whether the status on the two days was the same or different.", "answer": "$$\\boxed{A}$$", "id": "1428754"}, {"introduction": "We now turn to public-key cryptography and a more sophisticated attack that goes beyond passive eavesdropping. This practice demonstrates how the elegant mathematical structure of the RSA algorithm, when implemented naively, can itself become a vulnerability. You will step into the shoes of an attacker to perform a chosen-ciphertext attack [@problem_id:1428770], exploiting RSA's homomorphic properties to recover a secret message, which powerfully illustrates why \"textbook\" algorithms require careful padding and implementation for real-world use.", "problem": "A corporation uses a simplified implementation of the Rivest-Shamir-Adleman (RSA) cryptosystem for securing internal communications. This \"textbook\" version of RSA encrypts messages directly without using any cryptographic padding schemes. The corporation's public key is $(n, e) = (2537, 13)$.\n\nAn attacker, Eve, intercepts an encrypted message sent to a manager. The ciphertext is $C = 2275$. Eve's goal is to determine the original plaintext message, which is an integer $M$.\n\nEve discovers a vulnerability in the company's decryption server. The server will decrypt any valid ciphertext submitted to it, providing the corresponding plaintext. However, as a basic security measure, it is hard-coded to refuse to decrypt the specific ciphertext $C = 2275$.\n\nTo circumvent this, Eve employs a chosen-ciphertext attack. She chooses an integer multiplier $r=2$. She then computes a new, altered ciphertext $C' = (C \\cdot r^e) \\pmod{n}$. Since $C' \\neq C$, the server will process her request. Eve submits $C'$ to the decryption server and receives the decrypted message $M' = 1706$.\n\nGiven the server's response $M'$, Eve's chosen multiplier $r$, and the public key, determine the original secret message $M$.", "solution": "The problem describes a chosen-ciphertext attack against textbook RSA, which is vulnerable due to its homomorphic properties. Specifically, RSA is multiplicatively homomorphic. Let's denote the encryption function as $E(m) = m^e \\pmod{n}$ and the decryption function as $D(c) = c^d \\pmod{n}$. The multiplicative property means that for any two plaintexts $m_1$ and $m_2$, the product of their ciphertexts, when decrypted, yields the product of the plaintexts:\n$D(E(m_1) \\cdot E(m_2)) \\equiv m_1 \\cdot m_2 \\pmod{n}$.\n\nIn this scenario, the attacker (Eve) has the original ciphertext $C = E(M) = M^e \\pmod{n}$. She cannot get $D(C)$ directly from the server.\nInstead, she creates a new ciphertext $C'$. She chooses a multiplier $r=2$ and computes its encryption $E(r) = r^e \\pmod{n}$. She then forms the new ciphertext $C'$ as the product of the original ciphertext and the encryption of her chosen multiplier:\n$C' \\equiv C \\cdot r^e \\pmod{n}$\n\nThis new ciphertext $C'$ is submitted to the decryption server. The server computes and returns $M'$, which is the decryption of $C'$:\n$M' = D(C') = D(C \\cdot r^e)$\n\nUsing the homomorphic property of RSA decryption:\n$M' \\equiv D(C) \\cdot D(r^e) \\pmod{n}$\n\nWe know that $D(C)$ is the original message $M$, and $D(r^e)$ is simply $r$:\n$D(C) = D(E(M)) = M$\n$D(r^e) = D(E(r)) = r$\n\nSubstituting these into the expression for $M'$, we get a relationship between the original message $M$, the returned message $M'$, and Eve's multiplier $r$:\n$M' \\equiv M \\cdot r \\pmod{n}$\n\nWe are given the values $M' = 1706$, $r=2$, and $n=2537$. Our goal is to solve for $M$.\n$1706 \\equiv M \\cdot 2 \\pmod{2537}$\n\nTo isolate $M$, we need to multiply both sides of the congruence by the modular multiplicative inverse of $r$ modulo $n$. That is, we need to find $r^{-1}$ such that $r \\cdot r^{-1} \\equiv 1 \\pmod{n}$. In our case, we need to find $2^{-1} \\pmod{2537}$. We can use the Extended Euclidean Algorithm to solve the equation $2x + 2537y = 1$.\n\nBy inspection, we can rearrange the equation for the Greatest Common Divisor (GCD):\n$2537 = 1268 \\cdot 2 + 1$\n$1 = 2537 - 1268 \\cdot 2$\n\nTaking this equation modulo 2537:\n$1 \\equiv (2537 - 1268 \\cdot 2) \\pmod{2537}$\n$1 \\equiv 0 - 1268 \\cdot 2 \\pmod{2537}$\n$1 \\equiv -1268 \\cdot 2 \\pmod{2537}$\n\nSo, the modular inverse of $2$ is $-1268$. To find the smallest positive integer equivalent, we add the modulus:\n$r^{-1} \\equiv -1268 + 2537 \\pmod{2537}$\n$r^{-1} \\equiv 1269 \\pmod{2537}$\n\nNow we can solve for $M$:\n$M \\equiv M' \\cdot r^{-1} \\pmod{n}$\n$M \\equiv 1706 \\cdot 1269 \\pmod{2537}$\n\nWe perform the multiplication:\n$1706 \\cdot 1269 = 2164914$\n\nFinally, we find the remainder of this product when divided by $n=2537$:\n$2164914 \\div 2537 = 853.336...$\nTo find the remainder, we can compute $2164914 - 853 \\cdot 2537$:\n$853 \\cdot 2537 = 2164061$\n$2164914 - 2164061 = 853$\n\nSo, $M \\equiv 853 \\pmod{2537}$.\nThe original secret message was $M=853$.", "answer": "$$\\boxed{853}$$", "id": "1428770"}]}