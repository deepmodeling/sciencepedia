{"hands_on_practices": [{"introduction": "To truly understand trapdoor one-way functions, we must move from abstract definitions to concrete examples. This first practice [@problem_id:1467639] challenges you to analyze a function built upon the hard problem of discrete logarithms, a cornerstone of public-key cryptography. Your task is to identify the specific piece of secret information—the trapdoor—that makes inverting the function computationally easy for an authorized user.", "problem": "In the study of public-key cryptography, the concept of a trapdoor one-way function is fundamental. A function is considered **one-way** if it is easy to compute for any given input, but computationally infeasible to determine the input from a given output. A **trapdoor one-way function** is a special type of one-way function where the inversion becomes easy if, and only if, one possesses a specific piece of secret information known as the trapdoor.\n\nConsider a finite cyclic group $G$ of a large prime order $q$, with a known generator $g$. The group operation is denoted by $\\cdot$. Let $h$ be a public element of $G$, constructed as $h=g^x$ for a secret integer $x \\in \\{1, 2, \\ldots, q-1\\}$. You can assume that solving the Discrete Logarithm Problem (DLP) in $G$ — that is, finding $x$ given $g$ and $h$ — is computationally infeasible.\n\nNow, analyze the function $f: G \\times \\mathbb{Z}_q \\to G \\times G$ defined by:\n$$f(m, r) = (g^r, m \\cdot h^r)$$\nwhere $m \\in G$ is a message and $r \\in \\mathbb{Z}_q$ is a randomly chosen integer. The primary goal of an authorized recipient, who knows the secret, upon receiving an output $(c_1, c_2) = f(m, r)$, is to recover the original message $m$.\n\nWhich of the following statements most accurately describes the properties of the function $f(m, r)$ under the assumption that the DLP is hard?\n\nA. The function is a trapdoor one-way function, and the trapdoor is the secret exponent $x$.\n\nB. The function is a trapdoor one-way function, and the trapdoor is the random integer $r$.\n\nC. The function is a trapdoor one-way function, and the trapdoor is the message $m$.\n\nD. The function is a one-way function but does not possess a trapdoor.\n\nE. The function is not a one-way function because it can be easily inverted by any party.", "solution": "We work in a finite cyclic group $G$ of prime order $q$ with generator $g$. The public key is $h=g^{x}$ for secret $x \\in \\{1,2,\\ldots,q-1\\}$. The function is $f(m,r)=(c_{1},c_{2})=(g^{r},\\,m \\cdot h^{r})$, where $m \\in G$ and $r \\in \\mathbb{Z}_{q}$.\n\nFirst, show how an authorized recipient who knows $x$ recovers $m$ from $(c_{1},c_{2})$. Using the definition $c_{1}=g^{r}$ and the trapdoor $x$, compute\n$$\ns=c_{1}^{x}=(g^{r})^{x}=g^{rx}=h^{r}.\n$$\nThis uses standard exponentiation in $G$ and the relation $h=g^{x}$. Then invert $c_{2}=m \\cdot h^{r}$ by multiplying by $s^{-1}=(h^{r})^{-1}$:\n$$\nm=c_{2}\\cdot s^{-1}=m \\cdot h^{r} \\cdot (h^{r})^{-1}=m.\n$$\nThus, given $x$, recovering $m$ from $(c_{1},c_{2})$ is efficient, establishing the existence of an efficient inversion algorithm with the trapdoor $x$.\n\nNext, argue that without $x$ inversion is infeasible under the stated hardness assumption. From $(c_{1},c_{2})$, to obtain $m$ one needs $h^{r}$. There are two natural routes:\n1. Recover $r$ from $c_{1}=g^{r}$ and then compute $h^{r}$; but finding $r$ is exactly the Discrete Logarithm Problem in $G$, which is assumed hard.\n2. Compute $h^{r}$ directly from $(g^{x},g^{r})$ by evaluating $g^{xr}$; this is the Computational Diffie–Hellman problem. While the problem statement only assumes DLP hardness, any algorithm that inverts $f$ by outputting $m$ for arbitrary $(c_{1},c_{2})$ would, in particular, allow recovery of $m$ when $m$ is unknown to the adversary, which requires computing $h^{r}$ from $(g^{x},g^{r})$; absent the trapdoor $x$, this is believed infeasible.\n\nTherefore, under the DLP hardness assumption, $f$ is one-way for parties lacking $x$, while a party possessing $x$ can efficiently invert to recover $m$. The random $r$ is ephemeral and not a fixed secret enabling inversion across all outputs; the message $m$ itself is not a trapdoor; and the function is not easily invertible by arbitrary parties.\n\nConsequently, the correct characterization is that $f$ is a trapdoor one-way function with trapdoor $x$.", "answer": "$$\\boxed{A}$$", "id": "1467639"}, {"introduction": "The \"hardness\" of inverting a one-way function is a deep concept rooted in computational complexity theory. This exercise [@problem_id:1467625] explores this connection through a fascinating thought experiment involving a SAT oracle, a hypothetical machine that can instantly solve the Boolean Satisfiability Problem. By constructing a way to break the one-wayness using this oracle, you will gain a practical understanding of how cryptographers formally reason about computational difficulty.", "problem": "A cryptographer is analyzing a newly proposed public-key cryptographic scheme. The security of the scheme relies on a family of trapdoor one-way permutations. This family is defined by a generation algorithm, `Gen`, which on input of a security parameter $n$, outputs a pair of keys $(pk, sk)$. The public key $pk$ defines a permutation $f_{pk}: \\{0,1\\}^{n} \\to \\{0,1\\}^{n}$, while the secret key $sk$ is the trapdoor that allows for efficient inversion of $f_{pk}$.\n\nThe public key $pk$ contains a complete description of a Boolean circuit, $C_{pk}$, which computes the function $f_{pk}$. The circuit $C_{pk}$ takes an $n$-bit input and produces an $n$-bit output. The size of the circuit, denoted $s(n)$, is defined as the total number of logic gates (e.g., AND, OR, NOT) it contains.\n\nAn adversary intercepts a value $y \\in \\{0,1\\}^{n}$ and has access to the public key $pk$, but not the secret key $sk$. The adversary's goal is to find the unique preimage $x \\in \\{0,1\\}^{n}$ such that $f_{pk}(x) = y$.\n\nThe adversary gains access to a powerful computational oracle, `O_SAT`. This oracle solves the Boolean Satisfiability Problem (SAT). When given a Boolean formula expressed in variables $v_1, v_2, \\ldots$, the oracle returns `TRUE` if there exists an assignment of `TRUE`/`FALSE` values to the variables that makes the entire formula `TRUE`, and `FALSE` otherwise. Crucially, if the formula is satisfiable, the oracle also provides one such satisfying assignment for all variables.\n\nTo find the preimage $x$, the adversary plans to construct a single Boolean formula, $\\Phi$, and query the `O_SAT` oracle just once. The variables of $\\Phi$ will represent the bits of the unknown input $x$ and the logical values on the internal wires of the circuit $C_{pk}$. What is the minimum total number of Boolean variables required for this formula $\\Phi$, expressed as a function of $n$ and $s(n)$?", "solution": "We want a single SAT instance that captures the constraint that $C_{pk}$, of size $s(n)$, maps an unknown input $x \\in \\{0,1\\}^{n}$ to the given output $y \\in \\{0,1\\}^{n}$. The variables must encode:\n- the $n$ unknown input bits of $x$, and\n- the logical values carried by the internal wires of $C_{pk}$.\n\nUse a standard circuit-to-SAT (Tseitin-style) encoding:\n1) Introduce $n$ variables $x_{1},\\dots,x_{n}$ for the primary inputs.\n2) For each of the $s(n)$ gates $g_{1},\\dots,g_{s(n)}$ in $C_{pk}$, introduce one variable $z_{j}$ representing the output wire (logical value) of gate $g_{j}$. Enforce the functionality of each gate by clauses that relate $z_{j}$ to the gate’s input literals. This introduces no additional variables beyond the single output variable per gate.\n3) For each circuit output bit, constrain the corresponding wire variable to equal the known bit of $y$. This is done with unit clauses (e.g., $z_{o(i)}$ or $\\lnot z_{o(i)}$), and therefore uses no new variables.\n\nThus, the total number of Boolean variables in the formula is exactly the number of primary input variables plus one variable for each gate output:\n$$\nn + s(n).\n$$\n\nMinimality: By the problem’s stipulation, variables of $\\Phi$ “represent the bits of the unknown input $x$ and the logical values on the internal wires of $C_{pk}$.” There are $n$ input bits and exactly $s(n)$ distinct internal gate-output signals whose logical values must be represented, so at least $n + s(n)$ variables are necessary. Moreover, outputs equal to $y$ can be enforced by unit clauses without creating additional variables. Therefore the minimum total number of variables required is $n + s(n)$.", "answer": "$$\\boxed{n+s(n)}$$", "id": "1467625"}, {"introduction": "Modern cryptography demands primitives with more subtle features than simple one-wayness. This final practice [@problem_id:1467641] introduces you to the clever concept of \"lossy\" functions, a family of functions that can be generated in two indistinguishable modes but with dramatically different properties. You will delve into the algebraic structure of such a function to quantify the \"lossiness,\" a property that is surprisingly useful for building advanced and secure cryptographic systems.", "problem": "In the study of modern cryptography, lossy functions are function families that can be generated in one of two computationally indistinguishable modes: a normal mode where the function behaves as expected (e.g., is injective or has a large image), and a \"lossy\" mode where the function's image is significantly smaller.\n\nConsider a cyclic group $G$ of a large prime order $q$. Let $n$ be an integer parameter with $n \\ge 2$. A public key, denoted $\\text{PK}$, is constructed as a pair of vectors $(\\mathbf{u}, \\mathbf{v})$, where $\\mathbf{u} = (u_1, \\dots, u_n)$ and $\\mathbf{v} = (v_1, \\dots, v_n)$ are vectors of elements from $G$.\n\nThe public key $\\text{PK}$ is generated in one of two modes, using a fixed, publicly known generator $g \\in G$:\n\n1.  **Normal Mode:** Two vectors of exponents, $\\mathbf{\\alpha} = (\\alpha_1, \\dots, \\alpha_n)$ and $\\mathbf{\\beta} = (\\beta_1, \\dots, \\beta_n)$, are chosen randomly from $(\\mathbb{Z}_q^*)^n$ subject to the condition that they are linearly independent over the finite field $\\mathbb{Z}_q$. The public key elements are then computed as $u_i = g^{\\alpha_i}$ and $v_i = g^{\\beta_i}$ for $i=1, \\dots, n$.\n\n2.  **Lossy Mode:** A single vector of exponents $\\mathbf{\\alpha} = (\\alpha_1, \\dots, \\alpha_n)$ is chosen randomly from $(\\mathbb{Z}_q^*)^n$, and a single random scalar $s$ is chosen from $\\mathbb{Z}_q^*$. The public key elements are then computed as $u_i = g^{\\alpha_i}$ and $v_i = (g^{\\alpha_i})^s = g^{s\\alpha_i}$ for $i=1, \\dots, n$.\n\nCorresponding to any given public key $\\text{PK} = (\\mathbf{u}, \\mathbf{v})$, we define a function $F_{\\text{PK}}$ that maps from the domain $\\mathbb{Z}_q^n$ to the codomain $G \\times G$. The function is defined as:\n$$F_{\\text{PK}}(\\mathbf{x}) = \\left( \\prod_{i=1}^n u_i^{x_i}, \\prod_{i=1}^n v_i^{x_i} \\right)$$\nwhere $\\mathbf{x} = (x_1, \\dots, x_n) \\in \\mathbb{Z}_q^n$.\n\nLet $S_N$ be the size (cardinality) of the image of the function $F_{\\text{PK}}$ when the public key $\\text{PK}$ is generated in Normal Mode. Let $S_L$ be the size of the image of $F_{\\text{PK}}$ when the public key is generated in Lossy Mode.\n\nDetermine the value of the ratio $S_N / S_L$. Your answer should be an expression in terms of the given parameters.", "solution": "Let $G$ be cyclic of prime order $q$ with generator $g$. The map $\\varphi:\\mathbb{Z}_{q}\\to G$ given by $\\varphi(y)=g^{y}$ is a bijection, because $g$ generates $G$ and $|G|=q$. Hence, for any public key $\\text{PK}=(\\mathbf{u},\\mathbf{v})$ with $u_{i}=g^{\\alpha_{i}}$ and $v_{i}=g^{\\beta_{i}}$, the image of\n$$\nF_{\\text{PK}}(\\mathbf{x})=\\left(\\prod_{i=1}^{n}u_{i}^{x_{i}},\\prod_{i=1}^{n}v_{i}^{x_{i}}\\right)=\\left(g^{\\sum_{i=1}^{n}\\alpha_{i}x_{i}},g^{\\sum_{i=1}^{n}\\beta_{i}x_{i}}\\right)\n$$\nhas the same cardinality as the image of the linear map over $\\mathbb{Z}_{q}$\n$$\nL:\\mathbb{Z}_{q}^{n}\\to\\mathbb{Z}_{q}^{2},\\quad \\mathbf{x}\\mapsto\\left(\\langle\\boldsymbol{\\alpha},\\mathbf{x}\\rangle,\\langle\\boldsymbol{\\beta},\\mathbf{x}\\rangle\\right),\n$$\nwhere $\\langle\\boldsymbol{\\alpha},\\mathbf{x}\\rangle=\\sum_{i=1}^{n}\\alpha_{i}x_{i}$ and $\\langle\\boldsymbol{\\beta},\\mathbf{x}\\rangle=\\sum_{i=1}^{n}\\beta_{i}x_{i}$. The size of the image of $L$ is $q^{r}$, where $r$ is the rank of $L$ (since $\\mathbb{Z}_{q}$ is a field and the image is a subspace of $\\mathbb{Z}_{q}^{2}$).\n\nIn Normal Mode, $\\boldsymbol{\\alpha},\\boldsymbol{\\beta}\\in(\\mathbb{Z}_{q}^{*})^{n}$ are linearly independent over $\\mathbb{Z}_{q}$, so the $2\\times n$ matrix with rows $\\boldsymbol{\\alpha}^{\\top}$ and $\\boldsymbol{\\beta}^{\\top}$ has rank $2$. Therefore,\n$$\nS_{N}=q^{2}.\n$$\n\nIn Lossy Mode, $\\boldsymbol{\\beta}=s\\boldsymbol{\\alpha}$ with $s\\in\\mathbb{Z}_{q}^{*}$, so the two rows are linearly dependent and the rank is $1$ (since $\\boldsymbol{\\alpha}\\neq\\mathbf{0}$ because each $\\alpha_{i}\\in\\mathbb{Z}_{q}^{*}$). Therefore,\n$$\nS_{L}=q.\n$$\n\nHence the ratio is\n$$\n\\frac{S_{N}}{S_{L}}=\\frac{q^{2}}{q}=q.\n$$", "answer": "$$\\boxed{q}$$", "id": "1467641"}]}