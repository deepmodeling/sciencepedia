{"hands_on_practices": [{"introduction": "The proof that TQBF is PSPACE-hard relies on translating a Turing Machine's computation into a giant Boolean formula. Before we can model the entire machine, we must first encode its fundamental components, such as the symbols in its tape alphabet. This exercise [@problem_id:1438399] addresses the most basic translation task: determining the \"bit cost\" of representing information, a crucial first step in building our logical simulation.", "problem": "In the study of computational complexity, theoretical models like Turing machines are fundamental. A key part of analyzing these machines involves representing their configurations using simpler logical systems.\n\nConsider a computer scientist designing a logical representation for a specific Turing machine. The tape alphabet of this machine, denoted by the set $\\Gamma$, contains all the symbols that can be written on its tape. For this particular machine, the alphabet $\\Gamma$ consists of a total of 12 distinct symbols. The task is to encode the content of a single tape cell. This encoding must be done using a set of Boolean variables, where each variable can only be in one of two states: true or false. A unique combination of the states of these variables must correspond to each of the 12 distinct symbols in $\\Gamma$.\n\nWhat is the minimum number of Boolean variables required to uniquely represent any symbol from the tape alphabet $\\Gamma$?\n\nA) 2\n\nB) 3\n\nC) 4\n\nD) 11\n\nE) 12", "solution": "A single Boolean variable can represent two states. With $n$ Boolean variables, by the product rule, the number of distinct encodings is $2^{n}$. To uniquely encode all symbols in the tape alphabet $\\Gamma$ with $|\\Gamma|=12$, we require\n$$\n2^{n} \\geq 12.\n$$\nTaking base-$2$ logarithms yields\n$$\nn \\geq \\log_{2}(12).\n$$\nWe seek the smallest integer $n$ satisfying this. Checking powers of $2$:\n$$\n2^{3}=8<12,\\quad 2^{4}=16\\geq 12.\n$$\nTherefore, the minimum number of Boolean variables is $n=4$, which corresponds to option C.", "answer": "$$\\boxed{C}$$", "id": "1438399"}, {"introduction": "Once the components of a Turing Machine configuration are represented by Boolean variables, the next challenge is to capture its dynamic behavior—a single computation step—as a static logical formula. This \"frame transition\" logic is encapsulated in a formula often called $\\phi_{next}$. This practical problem [@problem_id:1438359] has you construct a crucial piece of that formula, forcing a logical connection between two consecutive configurations by translating the machine's head movement into a precise implication.", "problem": "In the standard proof that the Quantified Boolean Formula (QBF) problem is PSPACE-complete, one provides a polynomial-time reduction from an arbitrary language decided by a polynomial-space Turing machine. A crucial part of this reduction involves constructing a Boolean formula, let's call it $\\phi_{next}$, that verifiably encodes a single computation step of the machine.\n\nConsider a single-tape deterministic Turing machine $M$ defined by a set of states $Q$, a tape alphabet $\\Gamma$, and a transition function $\\delta$. We analyze its computation on a tape of a fixed, finite length $N$, with cells indexed from $1$ to $N$.\n\nTo represent a configuration of $M$ with Boolean variables, we use the following propositions:\n- $S_q$: is true if and only if the machine's current state is $q \\in Q$.\n- $H_i$: is true if and only if the head is positioned at tape cell $i$, for $1 \\leq i \\leq N$.\n- $T_{i, \\sigma}$: is true if and only if tape cell $i$ contains the symbol $\\sigma \\in \\Gamma$, for $1 \\leq i \\leq N$.\n\nTo distinguish between two consecutive configurations, we use unprimed variables ($S_q, H_i, T_{i, \\sigma}$) for an initial configuration $C$ and primed variables ($S'_q, H'_i, T'_{i, \\sigma}$) for the subsequent configuration $C'$.\n\nThe transition function $\\delta$ maps a state-symbol pair to a new state, a symbol to write, and a head movement direction. A transition that moves the head to the right is of the form $\\delta(q, \\sigma) = (q', \\sigma', R)$. Let $\\Delta_R$ be the set of all pairs $(q, \\sigma)$ for which the transition function dictates a move to the right, i.e., $\\Delta_R = \\{ (q, \\sigma) \\mid \\exists q' \\in Q, \\sigma' \\in \\Gamma \\text{ such that } \\delta(q, \\sigma) = (q', \\sigma', R) \\}$.\n\nYour task is to construct the part of the formula $\\phi_{next}$ that ensures the head position is correctly updated in configuration $C'$ *if* a transition causing a rightward move occurs. Your formula must be a logical statement that is true for any valid evolution where a rightward move is executed. The formula should be constructed to hold for all possible head positions $i$ where a rightward move is possible without moving off the tape (i.e., for $i \\in \\{1, 2, ..., N-1\\}$). Express your answer using standard logical connectives ($\\land$ for conjunction, $\\lor$ for disjunction, $\\implies$ for implication) and large-scale operators ($\\bigwedge$ for conjunction over a set, $\\bigvee$ for disjunction over a set).", "solution": "We must encode the condition that, whenever a right-moving transition is applicable at the current head position, the head in the next configuration is at the cell to the right. A right-moving transition is applicable at cell index $i$ precisely when the head is at $i$ in the current configuration and the current state-symbol pair is one of those in $\\Delta_{R}$. Formally, the guard for a right move at position $i$ is\n$$\nH_{i} \\land \\bigvee_{(q,\\sigma)\\in \\Delta_{R}} \\left( S_{q} \\land T_{i,\\sigma} \\right).\n$$\nIf this guard holds, then the head position in the next configuration must be exactly at $i+1$, that is, we require\n$$\n\\left( H_{i} \\land \\bigvee_{(q,\\sigma)\\in \\Delta_{R}} \\left( S_{q} \\land T_{i,\\sigma} \\right) \\right) \\implies H'_{i+1}.\n$$\nSince a rightward move cannot occur from the rightmost cell without moving off the tape, we enforce this implication for all $i \\in \\{1,2,\\ldots,N-1\\}$, yielding the conjunction\n$$\n\\bigwedge_{i=1}^{N-1} \\left( \\left( H_{i} \\land \\bigvee_{(q,\\sigma)\\in \\Delta_{R}} \\left( S_{q} \\land T_{i,\\sigma} \\right) \\right) \\implies H'_{i+1} \\right).\n$$\nThis formula is true exactly when, for any valid configuration in which a right-moving transition is executed at position $i \\leq N-1$, the next configuration places the head at position $i+1$, thus correctly updating the head position under rightward moves.", "answer": "$$\\boxed{\\bigwedge_{i=1}^{N-1}\\left(\\left(H_{i}\\land\\bigvee_{(q,\\sigma)\\in\\Delta_{R}}\\left(S_{q}\\land T_{i,\\sigma}\\right)\\right)\\implies H'_{i+1}\\right)}$$", "id": "1438359"}, {"introduction": "The heart of the PSPACE-hardness proof is a recursive \"bisection\" technique that verifies reachability over an exponentially large number of steps using only polynomially many layers of quantifiers. This is captured by a formula, $\\text{REACH}(C_a, C_b, k)$, which checks for a path from configuration $C_a$ to $C_b$ in at most $2^k$ steps. This thought-provoking exercise [@problem_id:1438375] probes the semantics of this powerful construction, asking what it truly guarantees and how it elegantly handles non-determinism to confirm the existence of at least one valid computation path.", "problem": "In computational complexity theory, the proof that the True Quantified Boolean Formula (TQBF) problem is PSPACE-hard often involves a reduction from a language decided by a polynomial-space Turing Machine (TM). This reduction constructs a quantified Boolean formula that simulates the TM's computation.\n\nLet $M$ be a non-deterministic single-tape TM that operates in a space bounded by a polynomial $p(n)$ for an input of size $n$. A configuration of $M$ can be represented by a string of symbols encoding the state, tape contents, and head position. The total number of possible configurations is finite and can be described using $O(p(n))$ bits.\n\nThe reduction builds a formula $\\Phi$ that is satisfiable if and only if $M$ accepts its input string $w$. The core of this formula is a recursive predicate, let's call it $\\text{REACH}(C_1, C_2, k)$, which is true if configuration $C_2$ is reachable from configuration $C_1$ in at most $2^k$ steps. For $k > 0$, this is defined as:\n\n$\\text{REACH}(C_1, C_2, k) \\equiv \\exists C_M \\forall X \\forall Y \\left( \\left( (X=C_1 \\land Y=C_M) \\lor (X=C_M \\land Y=C_2) \\right) \\implies \\text{REACH}(X, Y, k-1) \\right)$\n\nHere, $C_1, C_2, C_M, X, Y$ are variables representing configurations. The base case, $\\text{REACH}(C_1, C_2, 0)$, is a simple Boolean formula (with no quantifiers) that is true if $C_1=C_2$ or if $C_2$ follows from $C_1$ in a single transition of $M$. The final formula $\\Phi$ asserts that an accepting configuration $C_{\\text{accept}}$ is reachable from the start configuration $C_{\\text{start}}$ in at most $2^{p(n)}$ steps.\n\nNow, consider a specific non-deterministic TM, $M'$, and an input $w$, for which there exist two entirely distinct sequences of configurations (i.e., two different computation paths) from $C_{\\text{start}}$ to $C_{\\text{accept}}$. Consequently, the TQBF formula $\\Phi$ constructed for $M'$ and $w$ evaluates to true.\n\nWhich of the following statements correctly interprets what the truth of the formula $\\Phi$ guarantees in this scenario?\n\nA. The formula $\\Phi$ is true only if the accepting computation path is unique. The presence of multiple paths would cause the universal quantifiers to fail.\n\nB. The formula $\\Phi$ is true, and its quantifiers are structured to algorithmically select and verify one single, canonical computation path among all possible options.\n\nC. The formula $\\Phi$ is true because at least one accepting computation path exists; the existential quantifiers work by asserting the existence of valid intermediate configurations for *some* path, not for all paths simultaneously.\n\nD. The structure of the formula implies that every possible non-deterministic choice must eventually lead to the accepting configuration $C_{\\text{accept}}$.\n\nE. The formula $\\Phi$ is true, but its structure is redundant for non-deterministic machines and is only strictly correct for deterministic TMs.", "solution": "We analyze the semantics of the recursive predicate and what it guarantees when there are multiple accepting computation paths.\n\nBy definition for $k>0$,\n$$\n\\text{REACH}(C_1,C_2,k)\\equiv \\exists C_M\\,\\forall X\\,\\forall Y\\left(\\left((X=C_1\\land Y=C_M)\\lor (X=C_M\\land Y=C_2)\\right)\\implies \\text{REACH}(X,Y,k-1)\\right).\n$$\nLet $\\phi(X,Y)$ denote $((X=C_1\\land Y=C_M)\\lor (X=C_M\\land Y=C_2))$. Then the universal part is\n$$\n\\forall X\\,\\forall Y\\left(\\phi(X,Y)\\implies \\text{REACH}(X,Y,k-1)\\right).\n$$\nBecause the implication must hold for all $X,Y$, in particular it must hold for the two assignments $(X,Y)=(C_1,C_M)$ and $(X,Y)=(C_M,C_2)$ where $\\phi(X,Y)$ is true. For all other $(X,Y)$ the antecedent is false and imposes no constraint. Hence the universal block is logically equivalent to requiring simultaneously\n$$\n\\text{REACH}(C_1,C_M,k-1) \\quad\\text{and}\\quad \\text{REACH}(C_M,C_2,k-1).\n$$\nTherefore the recursive clause is equivalent to\n$$\n\\text{REACH}(C_1,C_2,k)\\equiv \\exists C_M\\left(\\text{REACH}(C_1,C_M,k-1)\\land \\text{REACH}(C_M,C_2,k-1)\\right).\n$$\nThe base case is\n$$\n\\text{REACH}(C_1,C_2,0) \\text{ is true iff } C_1=C_2 \\text{ or } C_2 \\text{ is a one-step successor of }C_1.\n$$\nBy induction on $k$, the above equivalence shows that $\\text{REACH}(C_1,C_2,k)$ holds if and only if there exists a sequence of configurations (a computation path) from $C_1$ to $C_2$ of length at most $2^{k}$. The existential quantifier over $C_M$ at each level selects a midpoint that lies on some valid path; it does not require that a single $C_M$ work for all possible paths, nor does it enforce uniqueness of the path. The universal quantifiers serve only to enforce the conjunction that both halves of the chosen split must be valid; they do not require that all nondeterministic choices lead to acceptance.\n\nApplying this to $\\Phi$, which asserts $\\text{REACH}(C_{\\text{start}},C_{\\text{accept}},p(n))$, the formula is true exactly when there exists at least one accepting computation path of length at most $2^{p(n)}$. If there are two distinct accepting paths, the formula remains true, since the existential choices can witness one of them; uniqueness is not required, and the structure does not force all nondeterministic branches to accept. It is designed precisely to capture existence of an accepting path for nondeterministic machines.\n\nTherefore:\n- Statement A is false, because uniqueness is not required and multiple paths do not violate the universal block.\n- Statement B is false, because the quantifiers do not select a canonical path; they merely assert the existence of appropriate midpoints along some path.\n- Statement C is correct, as it captures the existential nature of the acceptance condition: at least one accepting path suffices, and existentials assert the existence of valid intermediate configurations for some path.\n- Statement D is false, because the structure does not require that every nondeterministic choice leads to acceptance.\n- Statement E is false, because the construction is appropriate for nondeterministic TMs; it is not restricted to deterministic ones.\n\nHence the correct interpretation is option C.", "answer": "$$\\boxed{C}$$", "id": "1438375"}]}