{"hands_on_practices": [{"introduction": "Mastering the 2-SAT algorithm begins with the fundamental skill of constructing its corresponding implication graph. This exercise provides direct, hands-on practice in translating logical clauses into a graph's directed edges. By following a specific path from a starting literal, you will explore the graph's structure and directly apply the concept of reachability, which is the cornerstone of determining satisfiability in logarithmic space. [@problem_id:1410675]", "problem": "A common problem in computer science is determining the satisfiability of a Boolean formula. For formulas in 2-Conjunctive Normal Form (2-CNF), which are formulas where each clause is a disjunction of at most two literals, there exists an efficient algorithm based on graph theory. This problem explores the behavior of the graph construction at the heart of such an algorithm.\n\nThe procedure is as follows: Given a 2-CNF formula $\\phi$ over a set of $n$ variables $\\{x_1, \\dots, x_n\\}$, we construct a directed graph. The vertex set of this graph consists of $2n$ vertices, with one distinct vertex for each literal (i.e., for each $x_i$ and its negation $\\neg x_i$). For every clause of the form $(a \\lor b)$ present in the formula $\\phi$, two directed edges are added to the graph: an edge from the vertex representing $\\neg a$ to the vertex representing $b$, and an edge from the vertex representing $\\neg b$ to the vertex representing $a$.\n\nConsider a specific 2-CNF formula $\\phi$ defined over the six variables $\\{x_1, x_2, x_3, x_4, x_5, x_6\\}$. This formula is given by the conjunction (AND) of the following seven clauses:\n1.  $(x_1 \\lor \\neg x_1)$\n2.  $(\\neg x_2 \\lor x_1)$\n3.  $(x_3 \\lor \\neg x_2)$\n4.  $(x_4 \\lor \\neg x_3)$\n5.  $(x_5 \\lor \\neg x_4)$\n6.  $(x_6 \\lor \\neg x_5)$\n7.  $(x_2 \\lor \\neg x_6)$\n\nApplying the procedure described above to this formula $\\phi$, determine the total number of distinct vertices that are reachable via a directed path of any length (including a path of length zero) starting from the vertex that represents the literal $\\neg x_1$.", "solution": "We construct the implication graph as prescribed: for each clause $(a \\lor b)$, add directed edges $\\neg a \\to b$ and $\\neg b \\to a$. The vertices are the $12$ literals $\\{x_{i}, \\neg x_{i} : i \\in \\{1,\\dots,6\\}\\}$.\n\nProcess each clause to list edges:\n1. $(x_{1} \\lor \\neg x_{1})$ gives $\\neg x_{1} \\to \\neg x_{1}$ and $x_{1} \\to x_{1}$.\n2. $(\\neg x_{2} \\lor x_{1})$ gives $x_{2} \\to x_{1}$ and $\\neg x_{1} \\to \\neg x_{2}$.\n3. $(x_{3} \\lor \\neg x_{2})$ gives $\\neg x_{3} \\to \\neg x_{2}$ and $x_{2} \\to x_{3}$.\n4. $(x_{4} \\lor \\neg x_{3})$ gives $\\neg x_{4} \\to \\neg x_{3}$ and $x_{3} \\to x_{4}$.\n5. $(x_{5} \\lor \\neg x_{4})$ gives $\\neg x_{5} \\to \\neg x_{4}$ and $x_{4} \\to x_{5}$.\n6. $(x_{6} \\lor \\neg x_{5})$ gives $\\neg x_{6} \\to \\neg x_{5}$ and $x_{5} \\to x_{6}$.\n7. $(x_{2} \\lor \\neg x_{6})$ gives $\\neg x_{2} \\to \\neg x_{6}$ and $x_{6} \\to x_{2}$.\n\nWe now compute the set of vertices reachable from the start vertex $\\neg x_{1}$ (paths of any length, including zero-length). Initialize the reachable set with the start: $\\{\\neg x_{1}\\}$.\n\nFrom $\\neg x_{1}$, the outgoing edges are $\\neg x_{1} \\to \\neg x_{1}$ (self-loop) and $\\neg x_{1} \\to \\neg x_{2}$. Thus we add $\\neg x_{2}$.\n\nFrom $\\neg x_{2}$, the only outgoing edge is $\\neg x_{2} \\to \\neg x_{6}$, so add $\\neg x_{6}$.\n\nFrom $\\neg x_{6}$, the only outgoing edge is $\\neg x_{6} \\to \\neg x_{5}$, so add $\\neg x_{5}$.\n\nFrom $\\neg x_{5}$, the only outgoing edge is $\\neg x_{5} \\to \\neg x_{4}$, so add $\\neg x_{4}$.\n\nFrom $\\neg x_{4}$, the only outgoing edge is $\\neg x_{4} \\to \\neg x_{3}$, so add $\\neg x_{3}$.\n\nFrom $\\neg x_{3}$, the only outgoing edge is $\\neg x_{3} \\to \\neg x_{2}$, which is already in the reachable set. Hence the exploration closes a cycle among $\\neg x_{2}, \\neg x_{3}, \\neg x_{4}, \\neg x_{5}, \\neg x_{6}$.\n\nNo edge from any of these negative literals goes to any positive literal, as seen from the edge list above; all edges from negative sources lead to negative targets. Therefore the full reachable set is\n$$\nR=\\{\\neg x_{1}, \\neg x_{2}, \\neg x_{3}, \\neg x_{4}, \\neg x_{5}, \\neg x_{6}\\},\n$$\nand the number of distinct reachable vertices is $|R|=6$.", "answer": "$$\\boxed{6}$$", "id": "1410675"}, {"introduction": "The power of the 2-SAT framework extends beyond simple OR-clauses. This practice problem challenges you to expand the model's reach by representing a different type of logical relationship—the exclusive-or (XOR) constraint. Learning to convert such constraints into an equivalent 2-CNF form is a vital modeling skill, demonstrating how the implication graph can be adapted to solve a broader class of problems. [@problem_id:1410702]", "problem": "In the study of computational complexity, the 2-Satisfiability (2-SAT) problem is a cornerstone, known to be complete for the complexity class NL (Nondeterministic Logarithmic Space). The standard algorithm for 2-SAT involves constructing an \"implication graph\" from a given 2-Conjunctive Normal Form (2-CNF) formula. For a formula $\\Phi$ over variables $x_1, \\dots, x_n$, the graph $G_{\\Phi}$ has $2n$ vertices, representing the literals $\\{x_1, \\neg x_1, \\dots, x_n, \\neg x_n\\}$. Every clause of the form $(l_i \\lor l_j)$ in $\\Phi$ is converted into two directed edges in $G_{\\Phi}$: an edge from $\\neg a$ to $b$ and an edge from $\\neg b$ to $a$. These edges represent the logical implications $(\\neg a \\implies b)$ and $(\\neg b \\implies a)$.\n\nConsider an extension to the standard 2-SAT problem where, in addition to standard clauses of the form $(l_i \\lor l_j)$, we introduce a new type of constraint: the \"exclusive-or\" (XOR) clause, denoted $(x_i \\oplus x_j)$. This clause is satisfied if and only if the boolean variables $x_i$ and $x_j$ have different truth values.\n\nTo solve this extended problem using the standard implication graph framework, one must first convert each XOR clause into an equivalent set of standard 2-CNF clauses. Which of the following sets of directed edges must be added to the implication graph to correctly model a single XOR clause $(x_i \\oplus x_j)$?\n\nA. $\\{\\neg x_i \\to x_j, \\neg x_j \\to x_i\\}$\n\nB. $\\{x_i \\to \\neg x_j, x_j \\to \\neg x_i\\}$\n\nC. $\\{x_i \\to x_j, \\neg x_i \\to \\neg x_j, x_j \\to x_i, \\neg x_j \\to \\neg x_i\\}$\n\nD. $\\{x_i \\to \\neg x_j, \\neg x_j \\to x_i, \\neg x_i \\to x_j, x_j \\to \\neg x_i\\}$\n\nE. $\\{x_i \\to x_j, x_j \\to \\neg x_i\\}$", "solution": "We begin with the logical meaning of the XOR constraint on boolean variables: $x_{i} \\oplus x_{j}$ is true exactly when $x_{i}$ and $x_{j}$ have different truth values. Equivalently,\n$$\nx_{i} \\oplus x_{j} \\equiv (x_{i} \\land \\neg x_{j}) \\lor (\\neg x_{i} \\land x_{j}).\n$$\nA standard 2-CNF representation of this condition is\n$$\n(x_{i} \\lor x_{j}) \\land (\\neg x_{i} \\lor \\neg x_{j}),\n$$\nwhich can be verified by checking the truth table or by observing that this enforces “at least one is true” and “at least one is false,” hence exactly one is true.\n\nIn the implication graph for 2-SAT, each clause $(a \\lor b)$ yields the implications $(\\neg a \\implies b)$ and $(\\neg b \\implies a)$, which are represented as directed edges $\\neg a \\to b$ and $\\neg b \\to a$.\n\nApplying this rule to the two clauses:\n1) For $(x_{i} \\lor x_{j})$, we add edges\n$$\n\\neg x_{i} \\to x_{j}, \\quad \\neg x_{j} \\to x_{i}.\n$$\n2) For $(\\neg x_{i} \\lor \\neg x_{j})$, set $a = \\neg x_{i}$ and $b = \\neg x_{j}$. Then $\\neg a = x_{i}$ and $\\neg b = x_{j}$, so we add edges\n$$\nx_{i} \\to \\neg x_{j}, \\quad x_{j} \\to \\neg x_{i}.\n$$\n\nCollecting all implications needed to model the single XOR clause $(x_{i} \\oplus x_{j})$, we obtain the set\n$$\n\\{\\, x_{i} \\to \\neg x_{j}, \\ \\neg x_{j} \\to x_{i}, \\ \\neg x_{i} \\to x_{j}, \\ x_{j} \\to \\neg x_{i} \\,\\},\n$$\nwhich matches option D.", "answer": "$$\\boxed{D}$$", "id": "1410702"}, {"introduction": "A \"yes\" or \"no\" answer to a satisfiability problem is useful, but often we need an actual solution. This final practice moves beyond the decision problem to the search problem, exploring how to construct a satisfying assignment for a formula known to be satisfiable. You will analyze different strategies to leverage a decision oracle, uncovering the powerful and common technique of self-reducibility to build a solution piece by piece. [@problem_id:1410686]", "problem": "The 2-Satisfiability (2-SAT) problem asks whether a given Boolean formula in 2-Conjunctive Normal Form (2-CNF) has a satisfying assignment. A 2-CNF formula is a conjunction (AND) of clauses, where each clause is a disjunction (OR) of at most two literals. A literal is a variable or its negation.\n\nFor any 2-CNF formula $\\phi$, we can construct an implication graph $G_\\phi$. The vertices of $G_\\phi$ are the literals of $\\phi$ (i.e., for each variable $x_i$, we have vertices for both $x_i$ and $\\neg x_i$). For each clause of the form $(\\alpha \\lor \\beta)$ in $\\phi$, we add two directed edges to $G_\\phi$: one representing the implication $\\neg \\alpha \\to \\beta$ and another for $\\neg \\beta \\to \\alpha$.\n\nA fundamental theorem states that a 2-CNF formula $\\phi$ is unsatisfiable if and only if there exists a variable $x_i$ such that $x_i$ and $\\neg x_i$ are in the same Strongly Connected Component (SCC) of $G_\\phi$. This is equivalent to the existence of a path from $x_i$ to $\\neg x_i$ and a path from $\\neg x_i$ to $x_i$ in $G_\\phi$.\n\nDeciding if a path exists between two vertices in a directed graph is a problem in the complexity class Nondeterministic Logarithmic Space (`NL`). Consequently, the decision problem for 2-SAT is in `coNL`, and by the Immerman-Szelepcsényi theorem (`NL = coNL`), it is also in `NL`. This means there is an efficient (polynomial-time) decision algorithm for 2-SAT.\n\nSuppose you are given a 2-CNF formula $\\phi$ over $n$ variables $\\{x_1, x_2, \\ldots, x_n\\}$ that is guaranteed to be satisfiable. You also have access to an oracle, `IS_SAT(psi)`, which takes any 2-CNF formula `psi` and returns `true` if `psi` is satisfiable and `false` otherwise. Which of the following iterative procedures is guaranteed to find a satisfying assignment for $\\phi$?\n\nA. Initialize an empty assignment. For $i$ from 1 to $n$: ask the oracle `IS_SAT`($\\phi \\land x_i$). If the result is `true`, permanently set $x_i$ to `true` and update $\\phi$ to be $\\phi \\land x_i$. Otherwise, permanently set $x_i$ to `false` and update $\\phi$ to be $\\phi \\land \\neg x_i$.\n\nB. For each variable $x_i$ from 1 to $n$: independently query the oracle `IS_SAT`($\\phi \\land x_i$). If the oracle returns `true`, assign $x_i = \\text{true}$. Otherwise, assign $x_i = \\text{false}$.\n\nC. For each variable $x_i$ from 1 to $n$: construct the implication graph for the original formula $\\phi$. If there is a path from the literal $x_i$ to the literal $\\neg x_i$ in this graph, assign $x_i = \\text{false}$. Otherwise, assign $x_i = \\text{true}$.\n\nD. Initialize all variables to unassigned. Pick an unassigned variable $x_i$. Assign $x_i = \\text{true}$ and check if this partial assignment violates any clauses. If it does, backtrack and assign $x_i = \\text{false}$. If a value is found that does not immediately cause a contradiction, make the assignment permanent and repeat for the next unassigned variable.", "solution": "We analyze each procedure and determine whether it is guaranteed to find a satisfying assignment for a satisfiable 2-CNF formula $\\phi$ using the given oracle.\n\nClaim for A: Guaranteed to find a satisfying assignment.\nProof by induction on the variables:\n- Invariant: After assigning values to $x_{1},\\dots,x_{i-1}$, let $\\phi_{i-1}$ denote $\\phi$ conjoined with these assignments. The invariant is that $\\phi_{i-1}$ is satisfiable.\n- Base case: $\\phi_{0}=\\phi$ is satisfiable by assumption.\n- Inductive step: At step $i$, the algorithm queries $\\text{IS\\_SAT}(\\phi_{i-1} \\land x_{i})$. If it returns true, then there exists an assignment extending $x_{i}=\\text{true}$ that satisfies $\\phi_{i-1}$, so setting $x_{i}=\\text{true}$ preserves satisfiability. Otherwise, since $\\phi_{i-1}$ is satisfiable, it must be that $\\text{IS\\_SAT}(\\phi_{i-1} \\land \\neg x_{i})$ is true (at least one of the two unit extensions is satisfiable), so setting $x_{i}=\\text{false}$ preserves satisfiability. Thus the invariant holds for $\\phi_{i}$.\n- After $n$ steps, $\\phi_{n}$ is satisfiable and fixes all variables, hence the chosen total assignment satisfies $\\phi$.\nTherefore, A is correct.\n\nCounterexample for B: Not guaranteed.\nLet\n$$\n\\phi \\;=\\; (x \\lor y)\\;\\land\\;(\\neg x \\lor z)\\;\\land\\;(\\neg y \\lor \\neg z).\n$$\nThis $\\phi$ is satisfiable (for example, $x=\\text{false},\\,y=\\text{true},\\,z=\\text{false}$ satisfies all clauses).\nIndependently querying the oracle on the original $\\phi$ yields:\n- $\\text{IS\\_SAT}(\\phi \\land x)=\\text{true}$ (e.g., $x=\\text{true},\\,y=\\text{false},\\,z=\\text{true}$ works),\n- $\\text{IS\\_SAT}(\\phi \\land y)=\\text{true}$ (e.g., $y=\\text{true},\\,x=\\text{false},\\,z=\\text{false}$ works),\n- $\\text{IS\\_SAT}(\\phi \\land z)=\\text{true}$ (e.g., $z=\\text{true},\\,y=\\text{false},\\,x=\\text{true}$ works).\nProcedure B would then set $x=y=z=\\text{true}$, but this assignment makes $(\\neg y \\lor \\neg z)$ false, so it does not satisfy $\\phi$. Hence B is not guaranteed.\n\nCounterexample and reduction for C: Not guaranteed.\nKey equivalence: For a 2-CNF $\\phi$ and variable $x_{i}$, there is a path from $x_{i}$ to $\\neg x_{i}$ in the implication graph $G_{\\phi}$ if and only if $\\phi \\land x_{i}$ is unsatisfiable.\n- If $x_{i}\\to\\neg x_{i}$ in $G_{\\phi}$, adding the unit clause $x_{i}$ adds the edge $\\neg x_{i}\\to x_{i}$, making $x_{i}$ and $\\neg x_{i}$ belong to the same SCC, which makes $\\phi \\land x_{i}$ unsatisfiable.\n- Conversely, if $\\phi \\land x_{i}$ is unsatisfiable, then in $G_{\\phi \\land x_{i}}$ the only new edge is $\\neg x_{i}\\to x_{i}$, and unsatisfiability implies $x_{i}$ and $\\neg x_{i}$ are in the same SCC; therefore there must already be a path $x_{i}\\to\\neg x_{i}$ in $G_{\\phi}$.\nThus C’s rule “assign $x_{i}=\\text{false}$ iff $x_{i}\\to\\neg x_{i}$ exists, else $x_{i}=\\text{true}$” is equivalent to “assign $x_{i}=\\text{true}$ iff $\\text{IS\\_SAT}(\\phi \\land x_{i})=\\text{true}$, else $x_{i}=\\text{false}$,” applied independently on the original $\\phi$. This is the same pitfall as B, so the same $\\phi$ above shows C can fail (it would set $x=y=z=\\text{true}$, which is not satisfying). Hence C is not guaranteed.\n\nCounterexample reasoning for D: Not guaranteed as stated.\nThe procedure only rejects an assignment when it immediately falsifies a clause and makes assignments “permanent” otherwise, with no provision to reconsider earlier choices if a later conflict arises. Consider\n$$\n\\phi \\;=\\; (\\neg x \\lor z)\\;\\land\\;(\\neg x \\lor \\neg z).\n$$\nThis $\\phi$ is satisfiable (e.g., $x=\\text{false}$ with any $z$). Procedure D might pick $x$ first and try $x=\\text{true}$, which causes no clause to be immediately false: the clauses become unit $z$ and unit $\\neg z$, which are not yet falsified under the partial assignment. The algorithm then makes $x=\\text{true}$ permanent and moves to $z$. Trying $z=\\text{true}$ immediately falsifies $(\\neg x \\lor \\neg z)$; backtracking to $z=\\text{false}$ immediately falsifies $(\\neg x \\lor z)$. Having tried both values for $z$ and with $x$ declared permanent earlier, the algorithm cannot proceed to find the satisfying assignment $x=\\text{false}$. Since the described procedure does not include revising earlier permanent assignments upon later conflicts, it is not guaranteed to succeed.\n\nConclusion: Only A is guaranteed to find a satisfying assignment for any satisfiable $\\phi$ using the oracle.", "answer": "$$\\boxed{A}$$", "id": "1410686"}]}