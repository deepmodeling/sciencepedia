{"hands_on_practices": [{"introduction": "Understanding closure properties often feels like working with building blocks. This first exercise demonstrates how we can combine established closure properties—specifically for concatenation ($L_1 L_2$) and the Kleene star ($L^*$)-to prove closure under a related and important operation, the positive closure ($L^+$). This practice, as outlined in [@problem_id:1415961], is key to developing fluency in reasoning about complexity classes without always resorting to low-level Turing machine constructions.", "problem": "In computational complexity theory, we study decision problems that can be solved by a Turing machine using a certain amount of computational resources. The complexity class PSPACE consists of all decision problems that can be decided by a deterministic Turing machine using an amount of space that is polynomial in the length of the input string.\n\nLet $L$, $L_1$, and $L_2$ be formal languages. We define the following standard operations on languages:\n- **Concatenation ($L_1 L_2$):** The set of strings formed by concatenating a string from $L_1$ with a string from $L_2$. Formally, $L_1 L_2 = \\{ w_1 w_2 \\mid w_1 \\in L_1, w_2 \\in L_2 \\}$.\n- **Kleene Star ($L^*$):** The set of all strings formed by concatenating zero or more strings from $L$. Formally, $L^* = \\bigcup_{i \\ge 0} L^i$, where $L^0 = \\{\\epsilon\\}$ (the language containing only the empty string) and $L^i = L L^{i-1}$ for $i \\ge 1$.\n- **Positive Closure ($L^+$):** The set of all strings formed by concatenating one or more strings from $L$. Formally, $L^+ = \\bigcup_{i \\ge 1} L^i$.\n\nIt is a known theorem that the class PSPACE is closed under both the concatenation and Kleene star operations. This means that if languages $L_1$ and $L_2$ are in PSPACE, then the language $L_1 L_2$ is also in PSPACE. Similarly, if a language $L$ is in PSPACE, then its Kleene star, $L^*$, is also in PSPACE.\n\nAn important identity relating these operations is $L^+ = L L^*$. Given that $L$ is an arbitrary language in PSPACE, which of the following statements provides the most direct and correct justification for why PSPACE must also be closed under the positive closure operation?\n\nA. To decide if a string $w$ is in $L^+$, a non-deterministic Turing machine can guess a split point in $w$ to form two substrings, $u$ and $v$, such that $w = uv$. The machine then verifies if $u \\in L$ and $v \\in L^*$. Because non-determinism can be simulated in polynomial space and both sub-problems are in PSPACE, the entire process runs in polynomial space.\n\nB. The positive closure $L^+$ is a subset of the Kleene star $L^*$ (specifically, $L^* = L^+ \\cup \\{\\epsilon\\}$). Since we are given that $L^*$ is in PSPACE, and $L^+$ is a subset of $L^*$, it must also be in PSPACE.\n\nC. The positive closure can be written as an infinite union $L^+ = L \\cup L^2 \\cup L^3 \\cup \\dots$. While each term $L^i$ is in PSPACE (by repeated application of concatenation closure), PSPACE is not closed under infinite union. Therefore, this construction is invalid, and we cannot conclude that PSPACE is closed under positive closure.\n\nD. We are given two facts: (1) if a language $L$ is in PSPACE, then $L^*$ is also in PSPACE, and (2) if languages $L_1$ and $L_2$ are in PSPACE, then their concatenation $L_1 L_2$ is in PSPACE. By applying the first fact to our language $L$, we know $L^*$ is in PSPACE. Now we have two languages, $L$ and $L^*$, that are both in PSPACE. Using the second fact, their concatenation, $L L^*$, must also be in PSPACE. Since $L^+ = L L^*$, this shows $L^+$ is in PSPACE.", "solution": "We are given that PSPACE is closed under concatenation and Kleene star, and that for any language $L$, the identity $L^{+} = L L^{*}$ holds.\n\nStart with an arbitrary language $L \\in \\text{PSPACE}$.\n\nBy the closure of PSPACE under Kleene star, applying this to $L$ yields\n$$\nL^{*} \\in \\text{PSPACE}.\n$$\nNow we have two languages, $L$ and $L^{*}$, each in PSPACE. By the closure of PSPACE under concatenation, we conclude\n$$\nL L^{*} \\in \\text{PSPACE}.\n$$\nUsing the identity relating positive closure to star and concatenation,\n$$\nL^{+} = L L^{*},\n$$\nwe obtain\n$$\nL^{+} \\in \\text{PSPACE}.\n$$\nTherefore, PSPACE is closed under positive closure, and the most direct justification is exactly to apply closure under star to get $L^{*}$, then closure under concatenation to get $L L^{*}$, and finally use $L^{+} = L L^{*}$.\n\nAssessment of options:\n- Option A invokes nondeterminism and simulation in polynomial space. While it can be made correct because $\\text{PSPACE} = \\text{NPSPACE}$, it is not the most direct use of the given closure properties and identity.\n- Option B is incorrect because being a subset of a PSPACE language does not imply membership testing for the subset is in PSPACE in general.\n- Option C is not a valid justification: although PSPACE is not closed under infinite unions, this does not prevent $L^{+}$ from being in PSPACE by other means; moreover, we already have a direct construction via $L L^{*}$.\n- Option D exactly applies the given closure properties and the identity $L^{+} = L L^{*}$, providing the most direct and correct justification.\n\nThus, the correct choice is D.", "answer": "$$\\boxed{D}$$", "id": "1415961"}, {"introduction": "We now shift from combining known properties to designing a simple algorithm from first principles. This problem [@problem_id:1415970] asks you to consider the symmetric difference of two languages, $L_1 \\Delta L_2$, and conceptualize how a polynomial-space Turing machine would decide membership. The key is to translate the logical definition of the operation—a string being in one language but not both—into a concrete sequence of computational steps that respect the given space constraints.", "problem": "In computational complexity theory, a complexity class is a set of computational problems of related resource-based complexity. PSPACE is the complexity class containing all decision problems that can be solved by a deterministic Turing Machine (TM) using an amount of memory space that is a polynomial function of the length of the input string. A language is a set of strings, and a TM that decides a language is one that halts on every input, either accepting it (if the string is in the language) or rejecting it (if it is not).\n\nA fundamental property of a complexity class is its closure under certain operations. A class is closed under an operation if applying that operation to any languages within the class results in a language that is also in the class. It is a known fact that PSPACE is closed under the operations of union ($L_1 \\cup L_2$), intersection ($L_1 \\cap L_2$), and complementation ($\\bar{L}$).\n\nSuppose you are given two languages, $L_1$ and $L_2$, both of which are in PSPACE. This means there exist polynomial-space decider TMs, which we can call $M_1$ and $M_2$, for $L_1$ and $L_2$ respectively. Your task is to design a new polynomial-space decider, $M_\\Delta$, for the symmetric difference of these two languages, defined as $L_\\Delta = L_1 \\Delta L_2$. The symmetric difference contains all strings that are in exactly one of the two languages, i.e., in $L_1$ or in $L_2$, but not in both.\n\nWhich of the following describes a correct high-level algorithm for the TM $M_\\Delta$ to decide if an input string $w$ is in $L_\\Delta$?\n\nA. On input $w$, run $M_1$ on $w$. If $M_1$ accepts, then $M_\\Delta$ accepts. Otherwise, run $M_2$ on $w$. If $M_2$ accepts, then $M_\\Delta$ accepts. Otherwise, $M_\\Delta$ rejects.\nB. On input $w$, run $M_1$ on $w$ and run $M_2$ on $w$. If both $M_1$ and $M_2$ accept, then $M_\\Delta$ accepts. Otherwise, $M_\\Delta$ rejects.\nC. On input $w$, run $M_1$ on $w$ and run $M_2$ on $w$. If exactly one of the two machines accepts, then $M_\\Delta$ accepts. Otherwise, $M_\\Delta$ rejects.\nD. On input $w$, run $M_1$ on $w$. If $M_1$ rejects, then $M_\\Delta$ accepts. Otherwise, run $M_2$ on $w$. If $M_2$ accepts, then $M_\\Delta$ rejects. Otherwise, $M_\\Delta$ accepts.\nE. On input $w$, run $M_1$ on $w$ and run $M_2$ on $w$. If at least one of the two machines rejects, then $M_\\Delta$ accepts. Otherwise, $M_\\Delta$ rejects.", "solution": "Let $L_{1},L_{2} \\subseteq \\Sigma^{*}$ be in PSPACE, with decider TMs $M_{1},M_{2}$ that halt on every input and use at most $p_{1}(|w|)$ and $p_{2}(|w|)$ space, respectively, for some polynomials $p_{1},p_{2}$. The symmetric difference is\n$$\nL_{\\Delta} \\;=\\; L_{1} \\Delta L_{2} \\;=\\; (L_{1}\\setminus L_{2}) \\cup (L_{2}\\setminus L_{1})\n\\;=\\; \\{\\, w \\mid (w\\in L_{1}) \\oplus (w\\in L_{2}) \\,\\},\n$$\ni.e., membership is the exclusive-or (XOR) of the two membership bits.\n\nA correct decider $M_{\\Delta}$ on input $w$ can proceed as follows: simulate $M_{1}$ on $w$ to completion, record a single bit $b_{1}\\in\\{0,1\\}$ indicating accept or reject, clear its work tape, then simulate $M_{2}$ on $w$ to completion and record $b_{2}$. Finally, compute $b_{1}\\oplus b_{2}$ in the finite control and accept iff $b_{1}\\oplus b_{2}=1$, otherwise reject. Because $M_{1}$ and $M_{2}$ are deciders, $M_{\\Delta}$ halts on all inputs. Its space usage is at most\n$$\n\\max\\{\\,p_{1}(|w|),\\,p_{2}(|w|)\\,\\} + c,\n$$\nfor a constant $c$ to store $(b_{1},b_{2})$ and control information, which is polynomial in $|w|$. Hence $M_{\\Delta}$ is a polynomial-space decider.\n\nMapping the options to set operations:\n- A accepts iff $(w\\in L_{1}) \\lor (w\\in L_{2})$, i.e., $L_{1}\\cup L_{2}$.\n- B accepts iff $(w\\in L_{1}) \\land (w\\in L_{2})$, i.e., $L_{1}\\cap L_{2}$.\n- C accepts iff exactly one of $M_{1},M_{2}$ accepts, i.e., XOR, which is $L_{1}\\Delta L_{2}$.\n- D accepts unless both accept, i.e., $\\overline{L_{1}\\cap L_{2}}$.\n- E accepts if at least one rejects, also $\\overline{L_{1}\\cap L_{2}}$.\n\nTherefore, the correct high-level algorithm for $M_{\\Delta}$ is given by option C.", "answer": "$$\\boxed{C}$$", "id": "1415970"}, {"introduction": "This final exercise showcases a hallmark of PSPACE's power: the ability to reuse space to perform a large number of checks. In this problem [@problem_id:1415944], you will design an algorithm for the $\\text{MIN}(L)$ language, which requires verifying a property for all proper prefixes of an input string. This scenario illustrates how PSPACE can solve problems that might naively seem to require exponential resources, a fundamental concept that distinguishes space complexity from time complexity.", "problem": "In computational complexity theory, we often study the closure properties of complexity classes under various language operations. Given a language $L$ over a finite alphabet $\\Sigma$, we can define a new language, $\\text{MIN}(L)$, which contains all strings from $L$ that are \"minimal\" in the sense that none of their proper prefixes are also in $L$. A string $v$ is defined as a proper prefix of a string $w$ if $w$ can be written as $w = vu$ for some non-empty string $u$.\n\nFormally, the language $\\text{MIN}(L)$ is defined as:\n$$ \\text{MIN}(L) = \\{ w \\in L \\mid \\text{for all proper prefixes } v \\text{ of } w, v \\notin L \\} $$\n\nSuppose a language $L$ is known to be in the complexity class PSPACE. The class PSPACE (Polynomial Space) is the set of all decision problems that can be decided by a deterministic Turing machine using an amount of memory space that is polynomial in the length of the input string.\n\nGiven that $L \\in \\text{PSPACE}$, which of the following complexity classes are **guaranteed** to contain the language $\\text{MIN}(L)$? Select all that apply.\n\nA. P (the class of languages decidable in polynomial time)\nB. NP (the class of languages decidable by a non-deterministic Turing machine in polynomial time)\nC. co-NP (the class of languages whose complements are in NP)\nD. PSPACE (the class of languages decidable in polynomial space)\nE. EXPTIME (the class of languages decidable in exponential time)", "solution": "Let $L \\subseteq \\Sigma^{*}$ be in PSPACE. Then there exists a deterministic Turing machine $M_{L}$ and a polynomial $s(n)$ such that on any input $x$ of length $|x|=n$, $M_{L}$ decides whether $x \\in L$ using at most $s(n)$ cells of work tape.\n\nBy definition,\n$$\n\\text{MIN}(L)=\\{w \\in L \\mid \\forall v \\text{ proper prefix of } w,\\, v \\notin L\\}.\n$$\nFix an input $w$ with $|w|=n$. Then $w \\in \\text{MIN}(L)$ if and only if the following two conditions hold:\n1) $w \\in L$.\n2) For every $i \\in \\{0,1,\\ldots,n-1\\}$, letting $v_{i}$ be the length-$i$ prefix of $w$, we have $v_{i} \\notin L$.\n\nWe give a polynomial-space decider for $\\text{MIN}(L)$:\n- First run $M_{L}$ on $w$. If it rejects, then reject (since $w \\notin L$).\n- Otherwise, for each $i$ from $0$ to $n-1$, construct $v_{i}$ on a work tape by copying the first $i$ symbols of $w$ (this uses $O(n)$ space), and run $M_{L}$ on $v_{i}$. If any such run accepts, then reject (since a proper prefix lies in $L$). If all runs reject, then accept.\n\nSpace analysis: Each run of $M_{L}$ on input $v_{i}$ uses at most $s(i) \\leq s(n)$ space. Constructing $v_{i}$ needs $O(n)$ space. Reusing work tape across iterations, the total space never exceeds $O(s(n)+n)$, which is polynomial in $n$. Therefore $\\text{MIN}(L) \\in \\text{PSPACE}$.\n\nSince PSPACE is contained in EXPTIME, we also have $\\text{MIN}(L) \\in \\text{EXPTIME}$. Specifically, any deterministic machine using at most $s(n)$ space has at most $\\exp(O(s(n)))$ distinct configurations, so it halts within $\\exp(O(s(n)))$ steps, yielding $DSPACE(s(n)) \\subseteq DTIME(\\exp(O(s(n))))$, and thus $\\text{PSPACE} \\subseteq \\text{EXPTIME}$.\n\nNo smaller class among $\\{\\text{P}, \\text{NP}, \\text{co-NP}\\}$ is guaranteed to contain $\\text{MIN}(L)$ for arbitrary $L \\in \\text{PSPACE}$, since that would imply unconditional inclusions $\\text{PSPACE} \\subseteq \\text{P}$ or $\\text{PSPACE} \\subseteq \\text{NP}$ or $\\text{PSPACE} \\subseteq \\text{co-NP}$, which are not known and are widely believed to be false.\n\nTherefore, the classes guaranteed to contain $\\text{MIN}(L)$ are PSPACE and EXPTIME.", "answer": "$$\\boxed{D, E}$$", "id": "1415944"}]}