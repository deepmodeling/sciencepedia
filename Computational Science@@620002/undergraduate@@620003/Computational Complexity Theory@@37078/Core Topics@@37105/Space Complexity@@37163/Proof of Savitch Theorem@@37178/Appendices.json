{"hands_on_practices": [{"introduction": "Before we can analyze the space efficiency of an algorithm that explores the computation graph of a Turing machine, we must first be able to quantify the size of that graph. This foundational exercise focuses on calculating the total number of distinct configurations a Nondeterministic Turing Machine (NTM) can assume given a specific space bound, $f(s) = c \\log_2 s$. Mastering this calculation is the first step toward understanding the scale of the reachability problem that Savitch's theorem elegantly solves [@problem_id:1437894].", "problem": "In the study of computational complexity, understanding the resource usage of abstract machines is fundamental. Consider a single-tape Nondeterministic Turing Machine (NTM). A configuration of such a machine at any point in time is completely described by three components: its current internal state, the entire content written on its work tape, and the current position of its tape head.\n\nLet this NTM have a set of states $Q$ and a tape alphabet $\\Sigma$. The machine is designed to have a space complexity of $f(s) = c \\log_2 s$ for an input of size $s$, where $c$ is a positive real constant. This means that for any input of size $s$, the machine uses at most $f(s)$ cells on its work tape.\n\nDerive a simplified, explicit formula for the maximum number of distinct configurations this NTM can be in. Express your answer as a function of the number of states $|Q|$, the size of the tape alphabet $|\\Sigma|$, the constant $c$, and the input size $s$.", "solution": "A configuration is determined by:\n- the current internal state (number of choices: $|Q|$),\n- the entire content on the work tape over the cells that may be used (each of at most $f(s)$ cells can contain any of $|\\Sigma|$ symbols, giving $|\\Sigma|^{f(s)}$ possibilities),\n- the head position on the work tape (at most $f(s)$ choices).\n\nThus, the maximum number of distinct configurations allowed by the space bound is\n$$\nN_{\\max}(s)=|Q|\\cdot f(s)\\cdot |\\Sigma|^{f(s)}.\n$$\nWith $f(s)=c\\log_{2}(s)$, this becomes\n$$\nN_{\\max}(s)=|Q|\\cdot c\\log_{2}(s)\\cdot |\\Sigma|^{c\\log_{2}(s)}.\n$$\nUsing the identity $a^{\\log_{b}(x)}=x^{\\log_{b}(a)}$ with $a=|\\Sigma|$ and $b=2$, we simplify\n$$\n|\\Sigma|^{c\\log_{2}(s)}=s^{c\\log_{2}(|\\Sigma|)}.\n$$\nTherefore, an explicit simplified expression is\n$$\nN_{\\max}(s)=|Q|\\cdot c\\log_{2}(s)\\cdot s^{c\\log_{2}(|\\Sigma|)}.\n$$", "answer": "$$\\boxed{|Q|\\cdot c\\log_{2}(s)\\cdot s^{c\\log_{2}(|\\Sigma|)}}$$", "id": "1437894"}, {"introduction": "At the heart of Savitch's theorem is a clever recursive algorithm that checks for a path between two configurations by searching for an intermediate configuration, effectively splitting the problem in two. To truly grasp how this 'divide and conquer' strategy works, it is essential to trace its execution path. This exercise guides you through the initial recursive calls of the `REACH` procedure, providing a concrete visualization of how a single large problem is broken down into a hierarchy of smaller subproblems [@problem_id:1437866].", "problem": "In computational complexity theory, Savitch's theorem is proven using a recursive algorithm that determines if a configuration $C_{final}$ is reachable from a configuration $C_{initial}$ in a non-deterministic computation. Consider a version of this algorithm, `REACH`($C_1$, $C_2$, $k$), which returns `true` if configuration $C_2$ is reachable from $C_1$ in at most $2^k$ steps, and `false` otherwise. The algorithm is defined as follows:\n\n**Algorithm: `REACH`($C_1$, $C_2$, $k$)**\n1.  If $k=0$, check if $C_1 = C_2$ or if $C_2$ can be reached from $C_1$ in a single computation step. If so, return `true`; otherwise, return `false`.\n2.  If $k > 0$, loop through all possible intermediate configurations $C_{mid}$. For each $C_{mid}$:\n    a. Call `REACH`($C_1$, $C_{mid}$, $k-1$).\n    b. Call `REACH`($C_{mid}$, $C_2$, $k-1$).\n    c. If both of these recursive calls return `true`, then stop and return `true`.\n3.  If the loop finishes without finding such a $C_{mid}$, return `false`.\n\nSuppose we initiate a check for reachability between a start configuration $C_{start}$ and an accepting configuration $C_{accept}$ within at most 16 steps, using the call `REACH`($C_{start}$, $C_{accept}$, 4). This initial call is considered Level 0 of the recursion. The recursive calls made directly by a Level 0 call are Level 1 calls. The recursive calls made directly by any Level 1 call are Level 2 calls.\n\nWhich of the following options correctly describes the complete set of generic forms for the recursive calls made at Level 2? In the options below, $C_i$, $C_j$, and $C_k$ represent existentially quantified intermediate configurations at different stages of the search.\n\nA. `REACH`($C_{start}$, $C_i$, 2) and `REACH`($C_i$, $C_{accept}$, 2)\n\nB. `REACH`($C_{start}$, $C_j$, 2), `REACH`($C_j$, $C_i$, 2), `REACH`($C_i$, $C_k$, 2), and `REACH`($C_k$, $C_{accept}$, 2)\n\nC. `REACH`($C_{start}$, $C_i$, 3) and `REACH`($C_i$, $C_{accept}$, 3)\n\nD. `REACH`($C_{start}$, $C_j$, 4) and `REACH`($C_j$, $C_i$, 4)\n\nE. `REACH`($C_{start}$, $C_{accept}$, 2)", "solution": "We start from the Level 0 call, which is the initial invocation `REACH`($C_{start}$, $C_{accept}$, 4). Since $k=4>0$, by the algorithm it loops over all intermediate configurations $C_{i}$ and, for each $C_{i}$, makes two recursive calls with parameter $k-1=3$. Therefore, the Level 1 calls generated by Level 0 are of the form `REACH`($C_{start}$, $C_{i}$, 3) and `REACH`($C_{i}$, $C_{accept}$, 3).\n\nEach Level 1 call itself has $k=3>0$, so it again loops over all intermediate configurations and makes two calls with parameter $k-1=2$. Thus, for a Level 1 call `REACH`($C_{start}$, $C_{i}$, 3), the Level 2 calls it makes are, for all intermediate $C_{j}$, `REACH`($C_{start}$, $C_{j}$, 2) and `REACH`($C_{j}$, $C_{i}$, 2). Similarly, for a Level 1 call `REACH`($C_{i}$, $C_{accept}$, 3), the Level 2 calls it makes are, for all intermediate $C_{k}$, `REACH`($C_{i}$, $C_{k}$, 2) and `REACH`($C_{k}$, $C_{accept}$, 2).\n\nCollecting all Level 2 calls produced by the two families of Level 1 calls, the complete set of generic forms at Level 2 is `REACH`($C_{start}$, $C_{j}$, 2), `REACH`($C_{j}$, $C_{i}$, 2), `REACH`($C_{i}$, $C_{k}$, 2), and `REACH`($C_{k}$, $C_{accept}$, 2), which matches option B.\n\nTo see why the other options are incorrect:\n- Option A lists `REACH`($C_{start}$, $C_{i}$, 2) and `REACH`($C_{i}$, $C_{accept}$, 2), but at Level 2 the calls use fresh intermediate configurations $C_{j}$ and $C_{k}$ within each Level 1 branch; the pair in A does not capture the cross-branch structure and is not the complete set.\n- Option C uses $k=3$, which corresponds to Level 1, not Level 2.\n- Option D uses $k=4$, which is the parameter of the Level 0 call, not Level 2.\n- Option E is a single special-case call that could occur only if an intermediate equals $C_{accept}$ or $C_{start}$, but it does not describe the complete set of generic forms.\n\nTherefore, the correct choice is B.", "answer": "$$\\boxed{B}$$", "id": "1437866"}, {"introduction": "A deep test of understanding comes not just from following a proof, but from reasoning about its variations. This thought experiment challenges the standard binary-splitting approach of the reachability algorithm by proposing a ternary split instead. By analyzing how this modification affects the overall space complexity, you will gain a more robust intuition for why the $O(S(n)^2)$ bound arises and how it is fundamentally linked to the logarithmic depth of the recursion, not the specific branching factor [@problem_id:1437849].", "problem": "In computational complexity theory, Savitch's theorem demonstrates that any problem solvable by a Nondeterministic Turing Machine (NTM) using a certain amount of space can also be solved by a Deterministic Turing Machine (DTM) using a quadratically larger amount of space. Specifically, it shows that $\\text{NSPACE}(S(n)) \\subseteq \\text{DSPACE}(S(n)^2)$ for any space-constructible function $S(n) \\ge \\log n$.\n\nThe proof relies on a recursive algorithm to determine if a configuration $c_2$ is reachable from a configuration $c_1$ in the NTM's computation graph. Let the maximum number of configurations of an NTM for an input of size $n$ be $N$. The standard algorithm, let's call it `CAN-REACH`($c_{start}$, $c_{end}$, $k$), checks for a path of length at most $2^k$ from $c_{start}$ to $c_{end}$. For $k>0$, it does this by iterating through every possible intermediate configuration $c_{mid}$ and recursively checking for paths from $c_{start}$ to $c_{mid}$ and from $c_{mid}$ to $c_{end}$, both of length at most $2^{k-1}$. This binary splitting of the path leads to the $O(S(n)^2)$ space complexity result, as the recursion depth is $O(\\log N)$ and storing a configuration requires $O(S(n))$ space, where $\\log N$ is proportional to $S(n)$.\n\nNow, consider a modified recursive algorithm, `TRI-REACH`($c_{start}$, $c_{end}$, $i$), designed to solve the same reachability problem. This new algorithm checks for a path of length at most $3^i$. For $i>0$, `TRI-REACH` works by iterating through all possible pairs of intermediate configurations, ($c_{mid1}$, $c_{mid2}$), and recursively verifying the following three sub-problems:\n1. A path exists from $c_{start}$ to $c_{mid1}$ of length at most $3^{i-1}$.\n2. A path exists from $c_{mid1}$ to $c_{mid2}$ of length at most $3^{i-1}$.\n3. A path exists from $c_{mid2}$ to $c_{end}$ of length at most $3^{i-1}$.\n\nIf for some pair ($c_{mid1}$, $c_{mid2}$) all three recursive checks succeed, the algorithm returns true. Otherwise, it returns false. Assume a DTM uses this `TRI-REACH` algorithm to simulate an NTM that has a space complexity of $S(n)$. What is the space complexity of this simulation, expressed in big-O notation in terms of $S(n)$?", "solution": "Let $S(n)$ be the space bound of the NTM and let $N$ be the number of distinct configurations on inputs of size $n$. For a fixed machine, there exists a constant $\\alpha>1$ such that\n$$\nN \\le \\alpha^{S(n)} \\cdot \\operatorname{poly}(n),\n$$\nhence\n$$\n\\log_{2} N = \\Theta(S(n)),\n$$\nusing the assumption $S(n) \\ge \\log_{2} n$.\n\nThe procedure `TRI-REACH`($c_{\\text{start}}$,$c_{\\text{end}}$,$i$) decides reachability within paths of length at most $3^{i}$. To cover all possible paths, it suffices to take\n$$\ni^{\\ast}=\\lceil \\log_{3} N \\rceil,\n$$\nso the recursion depth is\n$$\nd = i^{\\ast} = \\Theta(\\log_{3} N) = \\Theta(\\log_{2} N).\n$$\n\nAt any recursion level, the DTM must store:\n- The parameters $c_{\\text{start}}$ and $c_{\\text{end}}$ for that call.\n- The loop variables encoding the current pair ($c_{\\text{mid1}}$,$c_{\\text{mid2}}$).\n- The level parameter $i$.\n\nEach configuration requires $O(S(n))$ space to represent, and storing the loop indices costs $O(\\log_{2} N)=O(S(n))$ bits, which is dominated by storing a constant number of configurations. Therefore the space per recursion level is\n$$\nO(S(n)).\n$$\n\nBecause the recursive subcalls are performed depth-first and sequentially, the total space is the product of per-level space and recursion depth:\n$$\n\\text{Space}(n) = O\\big(S(n) \\cdot \\log_{3} N\\big).\n$$\nUsing $\\log_{3} N = \\frac{\\log_{2} N}{\\log_{2} 3} = \\Theta(\\log_{2} N)$ and $\\log_{2} N = \\Theta(S(n))$, we obtain\n$$\n\\text{Space}(n) = O\\big(S(n) \\cdot S(n)\\big) = O\\big(S(n)^{2}\\big).\n$$\n\nThus, despite splitting paths into three segments and iterating over pairs of intermediate configurations, the asymptotic space complexity remains the same as in Savitch’s original algorithm up to constant factors.", "answer": "$$\\boxed{O\\!\\left(S(n)^{2}\\right)}$$", "id": "1437849"}]}