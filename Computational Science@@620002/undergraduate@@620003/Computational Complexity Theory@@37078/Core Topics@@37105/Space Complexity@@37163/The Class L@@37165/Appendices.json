{"hands_on_practices": [{"introduction": "To begin, we tackle a classic problem in formal language theory that serves as a perfect entry point into log-space computation. This exercise [@problem_id:1452636] explores how to verify the language $\\{0^n 1^n\\}$, which consists of a block of '0's followed by an equal-sized block of '1's. The key skill you will develop is implementing a binary counter on the work tape, a fundamental technique that requires only logarithmic space, $O(\\log n)$, to count up to linear quantities.", "problem": "Consider a simplified model for a data validation protocol. A data packet stream is represented by a binary string. A valid \"burst\" is defined as a non-empty sequence of '0's (representing request-type packets) followed by a non-empty sequence of '1's (representing release-type packets). A burst is considered \"balanced\" if the number of '0's equals the number of '1's.\n\nYou are to analyze the computational resources required to decide if an incoming burst is balanced. This task is modeled by a deterministic Turing Machine (TM) with a read-only input tape and a separate read/write work tape. The space used by the TM on an input of length $N$ is the number of cells it accesses on its work tape. The complexity class **L**, also known as DLOGSPACE, is the set of all decision problems that can be solved by such a TM using $O(\\log N)$ work tape space.\n\nLet the language of balanced bursts be $L_{bal} = \\{0^n 1^n \\mid n \\ge 1\\}$. Assume any input string $w$ given to the TM is guaranteed to be a valid burst, meaning it has the form $0^k 1^m$ for some integers $k, m \\ge 1$. The question is whether $L_{bal}$ belongs to the class **L**.\n\nWhich one of the following statements provides the most accurate and fundamental reason that explains the space complexity of deciding $L_{bal}$?\n\nA. The TM can mark off one '0' on the input tape for every '1' it finds. Since this type of operation does not use the work tape, the algorithm runs in constant work space, which is a subset of logarithmic space.\n\nB. The language $L_{bal}$ is a deterministic context-free language (DCFL). All DCFLs are known to be decidable in logarithmic space, so $L_{bal}$ must be in **L**.\n\nC. The TM can use its work tape to maintain a binary counter. It can scan the input to count the number of '0's, store the result, and then compare this against a count of the '1's. The space required for a binary counter is logarithmic in the value it holds, which is at most the input length.\n\nD. This problem can be solved by a two-way deterministic finite automaton (2DFA), and the class of languages decided by 2DFAs is a known subset of **L**.\n\nE. The problem can be solved by a non-deterministic TM that guesses the midpoint of the string and verifies the two halves. Since it is known from the Immerman–Szelepcsényi theorem that non-deterministic logarithmic space (**NL**) is equal to **L**, the problem is in **L**.", "solution": "The correct statement is C. Let's analyze why it is correct and why the other options are incorrect.\n\nThe problem asks for an algorithm that decides the language $L_{bal} = \\{0^n 1^n \\mid n \\ge 1\\}$ using only $O(\\log N)$ space on a work tape, where $N$ is the length of the input string. For an input $w = 0^n 1^n$, the length is $N = 2n$.\n\n**Analysis of the Correct Option (C):**\n\nThis option describes a feasible logarithmic-space algorithm. A deterministic Turing machine with a read-only input tape and a work tape can implement this as follows:\n\n1.  Initialize a binary counter on the work tape to 0. Let's call this counter `C`.\n2.  Scan the input tape from left to right. For each '0' the read head encounters, increment the counter `C`.\n3.  The input is guaranteed to be of the form $0^k 1^m$. When the machine reads the first '1', it has finished counting the '0's. At this point, the value of the counter `C` is $k$.\n4.  The machine then continues scanning the input tape through the '1's. For each '1' it reads, it decrements the counter `C`.\n5.  After the read head passes the last character of the input, the machine checks the value of the counter `C`.\n    *   If `C` is 0, it means the number of '0's was equal to the number of '1's ($k=m$). The machine accepts.\n    *   If `C` is not 0, it means $k \\ne m$. The machine rejects.\n    *   An additional check can be made: if `C` becomes negative (or reaches 0 before all '1's are read), it implies $k < m$, and the machine can immediately reject.\n\nLet's analyze the space complexity of this algorithm. The maximum value stored on the counter is $k$, the number of '0's. To store an integer $k$ in binary, we need $\\lfloor \\log_2 k \\rfloor + 1$ bits (tape cells). The input length is $N = k+m$. Since the input must be balanced for acceptance ($k=m=n$), $N=2n$ and the space is $O(\\log n)$. In the general case of an input $0^k 1^m$, the space is $O(\\log k)$. Since $k < N$, the space required is bounded by $O(\\log N)$. Therefore, the language $L_{bal}$ is decidable in logarithmic space, and $L_{bal} \\in \\mathbf{L}$. Option C correctly describes this fundamental mechanism.\n\n**Analysis of Incorrect Options:**\n\n*   **A:** The standard definition of the complexity class **L** assumes a Turing machine with a *read-only* input tape. Therefore, marking off or modifying the input tape is not a valid operation in this model. Even if a different model were used where the input tape could be modified, the space used on that tape would contribute to the overall space complexity, making it a linear-space ($O(N)$) algorithm, not a logarithmic-space one.\n\n*   **B:** This statement contains two assertions. The first, \"$L_{bal}$ is a deterministic context-free language (DCFL),\" is true. It can be recognized by a deterministic pushdown automaton that pushes for every '0' and pops for every '1'. However, the second assertion, \"All DCFLs are known to be decidable in logarithmic space,\" is false. The class DCFL is not contained in **L**. There are DCFLs that are not known to be in **L**, and it is generally believed that $\\mathbf{L} \\subsetneq \\text{DCFL}$.\n\n*   **D:** This option claims the problem can be solved by a two-way deterministic finite automaton (2DFA), a finite automaton that can move its head left and right on the input tape. It is true that the class of languages decidable by a 2DFA is a subset of **L**. However, it is a long-standing open question whether a 2DFA can decide the language $\\{0^n 1^n\\}$. It is widely conjectured that it cannot. Therefore, one cannot use this as a valid reason for $L_{bal}$ being in **L**.\n\n*   **E:** This statement relies on the claim that **L** = **NL**, where **NL** is non-deterministic logarithmic space. This is one of the most famous unresolved problems in computational complexity theory. While the Immerman–Szelepcsényi theorem proved that **NL** = **co-NL**, it did not resolve the **L** vs **NL** question. It is widely believed that **L** $\\neq$ **NL**. Thus, assuming **L** = **NL** to prove a result is incorrect. The problem of deciding $L_{bal}$ does not require non-determinism anyway, as shown by the correct algorithm in C.", "answer": "$$\\boxed{C}$$", "id": "1452636"}, {"introduction": "Next, we will apply our understanding of log-space to a pattern-matching task. This problem [@problem_id:1452617] asks you to verify if a string is composed of repeating `01` units, a task that can be solved in constant space but provides a great opportunity to practice log-space techniques. The central challenge is to use a position pointer, which itself consumes $O(\\log n)$ space, to systematically inspect the input and enforce the required structure.", "problem": "A language is said to belong to the complexity class L (Logarithmic Space) if it can be decided by a deterministic Turing Machine (TM) using an amount of work-tape memory that is proportional to the logarithm of the input size, i.e., $O(\\log n)$ space for an input of length $n$. The standard model for this class assumes the TM has a read-only input tape and a separate read/write work tape.\n\nConsider the language $A = \\{w \\in \\{0,1\\}^* \\mid w = (01)^k \\text{ for some integer } k \\ge 1\\}$, which consists of strings formed by one or more concatenations of the substring \"01\".\n\nWhile this language is regular and can be decided in constant $O(1)$ space, we are interested in analyzing a general-purpose algorithmic strategy that relies on explicitly tracking positions within the input string. Which of the following statements accurately describes a valid algorithm for a deterministic TM to decide language $A$ within the logarithmic space constraint?\n\nA. The TM maintains a binary counter `i` on its work tape, starting from 1. For each `i` up to $n-1$, it moves its input head to position `i` and checks if the character `input[i]` is '0' and the character `input[i+1]` is '1'. The machine rejects if this condition ever fails for any `i`. If the loop completes, it accepts.\n\nB. The TM uses a work-tape counter `i`, starting at 1. In a loop from $i=1$ to $n$, it reads the character at position `i` on the input tape. It verifies that the character is '0' if `i` is odd, and '1' if `i` is even. If any check fails, it rejects. After the loop finishes, it performs a final check: if the total length `n` is odd, it rejects. Otherwise, it accepts.\n\nC. The TM makes two passes. In the first pass, it counts the total number of '0's and stores this count in binary on its work tape. In the second pass, it counts the total number of '1's. It accepts if and only if the count of '0's equals the count of '1's, the first character of the string is '0', and the last character is '1'.\n\nD. The TM operates as a two-state automaton, alternating between an 'expect 0' state and an 'expect 1' state. Because this method uses only constant space ($O(1)$), which is less than logarithmic space for non-constant $n$, the language $A$ is not considered to be in the class L.\n\nE. The TM only needs to check two conditions: the total length of the string, $n$, is even, and the character at position $n/2$ is '0' and the character at position $n/2 + 1$ is '1'. If both are true, it accepts.", "solution": "We must decide which statements describe a correct deterministic TM algorithm that decides the language $A=\\{(01)^{k}\\mid k\\ge 1\\}$ using at most $O(\\log n)$ work-tape space (standard read-only input tape and separate work tape). A work-tape counter that ranges over positions $1,\\dots,n$ and is stored in binary uses $O(\\log n)$ space, so any algorithm that maintains such a counter and otherwise only uses a constant number of auxiliary bits stays within the logarithmic space bound.\n\nAnalyze each option for both correctness (accepting exactly $A$) and space.\n\nA. The algorithm checks every adjacent pair $(\\text{input}[i],\\text{input}[i+1])$ equals $(0,1)$ for all $i$ from $1$ to $n-1$. Consider $w=0101$ with $n=4$. At $i=2$, the pair is $(1,0)$, so the machine rejects. However, $0101\\in A$. Thus, A is incorrect as a decision procedure, even though its space use is $O(\\log n)$.\n\nB. The algorithm checks that for each position $i$ from $1$ to $n$, the symbol is $0$ if $i$ is odd and $1$ if $i$ is even, and finally rejects if $n$ is odd and accepts otherwise. Correctness:\n- If $w\\in A$, then $w=(01)^{k}$ for some $k\\ge 1$, so for every odd $i$, $w[i]=0$, and for every even $i$, $w[i]=1$, and $n=2k$ is even. Hence the algorithm accepts.\n- Conversely, if the algorithm accepts, then for all $i$, the symbol pattern matches: odd positions are $0$, even positions are $1$, and $n$ is even. Therefore $w$ equals $(01)^{n/2}$ with $n/2\\ge 1$, so $w\\in A$.\nSpace: maintaining a binary counter $i$ and a constant number of flags uses $O(\\log n)$ space on the work tape. Hence B is a valid $O(\\log n)$-space algorithm deciding $A$.\n\nC. It accepts if and only if the counts of $0$ and $1$ match and the first symbol is $0$ and the last is $1$. This condition is not sufficient to enforce alternation. For example, $w=0011$ satisfies equal counts, first $0$, last $1$, but $w\\notin A$. Therefore, C is incorrect.\n\nD. It claims that using $O(1)$ space means the language is not in L. This is false because $O(1)\\subseteq O(\\log n)$. If a language is decidable in constant space, it is in L. Thus, D is incorrect.\n\nE. It checks only that $n$ is even and that the middle boundary satisfies $\\text{input}[n/2]=0$ and $\\text{input}[n/2+1]=1$. This does not enforce alternation across the whole string. The counterexample $w=0011$ (length $4$) satisfies these checks but is not in $A$. Hence, E is incorrect.\n\nTherefore, the only valid algorithm among the options that decides $A$ within $O(\\log n)$ space is B.", "answer": "$$\\boxed{B}$$", "id": "1452617"}, {"introduction": "Our final practice problem delves into a common data-integrity challenge: detecting duplicate entries in a sequence. This exercise [@problem_id:1452612] forces a confrontation with the fundamental trade-off between time and memory. You will discover that common, time-efficient algorithms are too memory-intensive for log-space constraints, pushing you to devise a solution that prioritizes space efficiency above all else.", "problem": "An embedded system is designed to monitor and verify the integrity of data logs from a network of sensors. This system has extremely limited Random Access Memory (RAM), but it has read-only access to a large storage device where the logs are kept. The log for a particular day is represented as a sequence of $n$ integer-valued sensor readings. A critical error is flagged if any sensor reading is recorded more than once.\n\nFormally, the input is a read-only array $A$ of $n$ integers. The values of the integers in the array are guaranteed to be within the range $[1, n^2]$. The total size of the input is considered to be $O(n \\log n)$ bits. Your task is to analyze algorithms that determine if there is at least one duplicate value in the array $A$. An algorithm is considered to be \"log-space\" if its auxiliary space complexity (the memory used besides the input storage) is $O(\\log n)$.\n\nWhich of the following proposed algorithms correctly determines if the array $A$ contains any duplicates and operates within the log-space constraint?\n\nA. Initialize an empty hash set. Iterate through the array $A$ from the first to the last element. For each element $A[i]$, check if it is already in the hash set. If it is, a duplicate has been found. If not, add $A[i]$ to the hash set. If the end of the array is reached without finding a duplicate, none exists.\n\nB. Use a nested loop structure. The outer loop iterates with an index $i$ from $0$ to $n-1$. The inner loop iterates with an index $j$ from $i+1$ to $n-1$. Inside the inner loop, read the values of $A[i]$ and $A[j]$ and compare them. If $A[i]$ equals $A[j]$, a duplicate has been found. If the loops complete without finding any match, no duplicates exist.\n\nC. First, make a mutable copy of the array $A$ in memory. Then, apply an in-place sorting algorithm, like Heapsort, to this copy. Finally, iterate through the sorted copy once, comparing each element to the one immediately following it. If any two adjacent elements are identical, a duplicate exists.\n\nD. Iterate through the array $A$ with an index $i$ from $0$ to $n-2$. In each iteration, compare the element $A[i]$ with the next element $A[i+1]$. If they are equal, a duplicate has been found and the algorithm terminates. If the loop completes, no duplicates exist.", "solution": "To solve this problem, we must analyze each proposed algorithm for two criteria: correctness (does it always find a duplicate if one exists?) and space complexity (does it run in $O(\\log n)$ auxiliary space?).\n\n**Analysis of Option A:**\nThis algorithm uses a hash set to keep track of the elements seen so far.\n*   **Correctness:** This algorithm is correct. If an element $A[i]$ is encountered that is already in the hash set, it must be a duplicate of a previously seen element. If the loop completes, it means every element was unique.\n*   **Space Complexity:** The space required is determined by the maximum size of the hash set. In the worst-case scenario, where all $n$ elements in the array $A$ are distinct, the hash set will need to store all $n$ elements. Each element is an integer up to $n^2$, requiring $O(\\log(n^2)) = O(\\log n)$ bits of storage. Therefore, the total space complexity is $O(n \\log n)$. This is polynomial space, not logarithmic space. So, this option violates the space constraint.\n\n**Analysis of Option B:**\nThis algorithm uses a pair of nested loops to compare every distinct pair of elements in the array.\n*   **Correctness:** This algorithm is correct. It performs a brute-force check of all pairs $(A[i], A[j])$ where $i < j$. If a duplicate pair exists in the array, say at indices $p$ and $q$ with $p < q$, the algorithm will eventually set $i=p$ and $j=q$, find that $A[p] = A[q]$, and correctly report the duplicate. If no duplicates exist, no such pair will be found.\n*   **Space Complexity:** The algorithm needs memory to store the state of the loops and the values being compared. The loop indices, $i$ and $j$, range from $0$ to $n-1$. To store an integer of this magnitude, we need approximately $\\log_2(n)$ bits, which is $O(\\log n)$ space. The algorithm also reads two values from the input array, $A[i]$ and $A[j]$, for comparison. The problem states that these values are in the range $[1, n^2]$. Storing such a value requires $\\log_2(n^2) = 2 \\log_2(n)$ bits, which is also $O(\\log n)$ space. The total auxiliary memory is the sum of the space for these few variables, which is $O(\\log n) + O(\\log n) = O(\\log n)$. Therefore, this algorithm satisfies the log-space constraint.\n\n**Analysis of Option C:**\nThis algorithm involves copying the array, sorting the copy, and then scanning for adjacent duplicates.\n*   **Correctness:** This algorithm is correct. Sorting brings all identical elements together, so a single pass over the sorted array to check adjacent elements is sufficient to find duplicates.\n*   **Space Complexity:** The first step is to \"make a mutable copy of the array $A$ in memory\". As established in the analysis of Option A, the array $A$ consists of $n$ elements, each requiring $O(\\log n)$ bits. A full copy therefore requires $O(n \\log n)$ space. This immediately violates the $O(\\log n)$ space constraint. The problem also specifies the input is on a read-only device, which makes an in-place sort of the original data impossible, reinforcing the need for a copy.\n\n**Analysis of Option D:**\nThis algorithm iterates through the array and only compares each element with the one immediately following it.\n*   **Correctness:** This algorithm is incorrect. The problem states that the array $A$ is unsorted. Duplicates are not guaranteed to be in adjacent positions. For example, consider the array $A = [10, 20, 30, 10]$ for $n=4$. The duplicate value is 10, but the two instances are not adjacent. This algorithm would compare $(10, 20)$, $(20, 30)$, and $(30, 10)$, find no equalities, and incorrectly conclude that there are no duplicates.\n*   **Space Complexity:** The algorithm uses an index $i$, which requires $O(\\log n)$ space. It is very space-efficient, but its failure to correctly solve the problem makes it invalid.\n\n**Conclusion:**\nOnly Algorithm B is both correct for an unsorted array and meets the stringent $O(\\log n)$ space complexity requirement.", "answer": "$$\\boxed{B}$$", "id": "1452612"}]}