{"hands_on_practices": [{"introduction": "The best way to understand an algorithm is often to trace its execution on a simple example. This first exercise provides a direct, hands-on opportunity to simulate the recursive calls of the algorithm from Savitch's theorem on a small, intuitive graph. By manually stepping through the process, you will see the \"divide-and-conquer\" or \"meet-in-the-middle\" strategy in action, building a solid foundation for how it determines reachability [@problem_id:1446438].", "problem": "The constructive proof of Savitch's theorem provides an algorithm to solve the st-connectivity problem for a directed graph $G=(V, E)$ in polynomial space. This algorithm recursively determines if a path exists between a `start` and `end` node within a certain maximum path length.\n\nConsider a directed graph with a set of nodes $V = \\{1, 2, 3, 4, 5\\}$. The edges are arranged to form a simple line: $E = \\{(1, 2), (2, 3), (3, 4), (4, 5)\\}$.\n\nWe use a recursive function, `REACH(start, end, max_len)`, which returns `True` if `end` is reachable from `start` via a path of length at most `max_len`, and `False` otherwise. The algorithm is defined as follows:\n\n1.  **Base Case**: If `max_len` is 1, the function returns `True` if `start == end` or if the direct edge `(start, end)` exists in $E$. Otherwise, it returns `False`.\n2.  **Recursive Step**: If `max_len > 1`, the function iterates through all nodes `mid` in $V$ in increasing numerical order (i.e., from 1 to 5). For each `mid`, it makes two recursive calls: `REACH(start, mid, ceil(max_len / 2))` and `REACH(mid, end, ceil(max_len / 2))`. If both of these calls return `True`, the function immediately stops its iteration and returns `True`.\n3.  **Failure**: If the loop over all possible `mid` nodes completes without both recursive calls ever returning `True`, the function returns `False`.\n\nYou are asked to trace the execution of the initial call `REACH(1, 5, 4)`. A \"pair of top-level recursive calls\" refers to the two calls, `(REACH(1, mid, ...), REACH(mid, 5, ...))`, made for a given `mid` directly within the `REACH(1, 5, 4)` execution.\n\nWhich of the following options correctly lists the sequence of *pairs* of top-level recursive calls that are made until the algorithm finds a successful path and the main call `REACH(1, 5, 4)` returns `True`?\n\nA. `[(REACH(1,1,2), REACH(1,5,2)), (REACH(1,2,2), REACH(2,5,2)), (REACH(1,3,2), REACH(3,5,2))]`\n\nB. `[(REACH(1,3,2), REACH(3,5,2))]`\n\nC. `[(REACH(1,2,1), REACH(2,3,1)), (REACH(3,4,1), REACH(4,5,1))]`\n\nD. `[(REACH(1,1,2), REACH(1,5,2)), (REACH(1,2,2), REACH(2,5,2)), (REACH(1,3,2), REACH(3,5,2)), (REACH(1,4,2), REACH(4,5,2)), (REACH(1,5,2), REACH(5,5,2))]`\n\nE. `[(REACH(1,5,2), REACH(5,5,2)), (REACH(1,4,2), REACH(4,5,2)), (REACH(1,3,2), REACH(3,5,2))]`", "solution": "The problem asks us to trace the sequence of top-level recursive calls made by the function `REACH(start, end, max_len)` for the initial call `REACH(1, 5, 4)`.\n\nThe initial parameters are `start = 1`, `end = 5`, and `max_len = 4`.\nSince `max_len = 4 > 1`, the algorithm enters the recursive step. The length for the subproblems will be $\\lceil \\text{max\\_len} / 2 \\rceil = \\lceil 4 / 2 \\rceil = 2$. The algorithm will iterate through `mid` from 1 to 5, and for each `mid`, it will test the pair of calls `(REACH(1, mid, 2), REACH(mid, 5, 2))`. The process stops as soon as a `mid` is found for which both calls return `True`.\n\nLet's trace the iteration over `mid`:\n\n**1. `mid = 1`:**\nThe first pair of top-level recursive calls is `(REACH(1, 1, 2), REACH(1, 5, 2))`.\n-   `REACH(1, 1, 2)`: To evaluate this, the algorithm seeks a midpoint `z` for a path of length at most 2. Let's try `z=1`. This sub-call will test `REACH(1, 1, 1)` and `REACH(1, 1, 1)`. The base case `REACH(1,1,1)` is `True` because `start == end`. Since both sub-calls are `True`, `REACH(1, 1, 2)` returns `True`.\n-   `REACH(1, 5, 2)`: This call checks for a path of length at most 2 from node 1 to node 5. By inspecting the graph edges $E = \\{(1, 2), (2, 3), (3, 4), (4, 5)\\}$, the shortest path from 1 to 5 is $1 \\to 2 \\to 3 \\to 4 \\to 5$, which has length 4. There is no path of length 2 or less. Therefore, `REACH(1, 5, 2)` will return `False`.\nSince one of the calls in the pair returned `False`, the algorithm continues to the next `mid`. The sequence of pairs so far is `[(REACH(1,1,2), REACH(1,5,2))]`.\n\n**2. `mid = 2`:**\nThe next pair of calls is `(REACH(1, 2, 2), REACH(2, 5, 2))`.\n-   `REACH(1, 2, 2)`: This checks for a path of length at most 2 from node 1 to 2. The path is $1 \\to 2$, which has length 1. The algorithm would find this. For instance, with a sub-midpoint `z=1`, it would check `REACH(1,1,1)` (True) and `REACH(1,2,1)` (True, as edge (1,2) exists). Thus, `REACH(1, 2, 2)` returns `True`.\n-   `REACH(2, 5, 2)`: This checks for a path of length at most 2 from 2 to 5. The shortest path is $2 \\to 3 \\to 4 \\to 5$, which has length 3. No path of length 2 exists. So, `REACH(2, 5, 2)` will return `False`.\nAgain, the pair does not consist of two `True` values. The algorithm continues. The sequence of pairs is now `[(REACH(1,1,2), REACH(1,5,2)), (REACH(1,2,2), REACH(2,5,2))]`.\n\n**3. `mid = 3`:**\nThe next pair of calls is `(REACH(1, 3, 2), REACH(3, 5, 2))`.\n-   `REACH(1, 3, 2)`: This checks for a path of length at most 2 from 1 to 3. The path $1 \\to 2 \\to 3$ exists and has length 2. The algorithm will discover this. Specifically, when it tries the sub-midpoint `z=2`, it will call `REACH(1, 2, 1)` (True, edge exists) and `REACH(2, 3, 1)` (True, edge exists). Since both are true, `REACH(1, 3, 2)` returns `True`.\n-   `REACH(3, 5, 2)`: This checks for a path of length at most 2 from 3 to 5. The path $3 \\to 4 \\to 5$ exists and has length 2. The algorithm will discover this. Specifically, when it tries sub-midpoint `z=4`, it will call `REACH(3, 4, 1)` (True, edge exists) and `REACH(4, 5, 1)` (True, edge exists). Since both are true, `REACH(3, 5, 2)` returns `True`.\n\nSince both `REACH(1, 3, 2)` and `REACH(3, 5, 2)` return `True`, the condition in the main loop of `REACH(1, 5, 4)` is met. The function immediately stops iterating and returns `True`.\n\nThe total sequence of top-level pairs anlyzed until the function returned `True` is the set of pairs for `mid=1`, `mid=2`, and `mid=3`.\nThis sequence is: `[(REACH(1,1,2), REACH(1,5,2)), (REACH(1,2,2), REACH(2,5,2)), (REACH(1,3,2), REACH(3,5,2))]`.\n\nThis matches option A.\n- Option B is incorrect because it only lists the successful pair, ignoring the failed attempts for `mid=1` and `mid=2`.\n- Option C is incorrect because it lists the second-level recursive calls for the successful case (`mid=3`), not the top-level calls.\n- Option D is incorrect because it lists the pairs for all possible midpoints, but the algorithm stops after the first success at `mid=3`.\n- Option E is incorrect because the algorithm iterates through `mid` in increasing order, not decreasing order.", "answer": "$$\\boxed{A}$$", "id": "1446438"}, {"introduction": "Now that you have seen how the algorithm operates, we turn to the crucial question of *why* it is so space-efficient. This problem abstracts away from a specific graph to focus on the core relationship between the size of the problem and the algorithm's memory usage [@problem_id:1446430]. By calculating the maximum recursion depth, you will explore the logarithmic scaling that allows Savitch's algorithm to solve problems in nondeterministic polynomial space using only deterministic polynomial space.", "problem": "Consider a distributed system whose state can be modeled as a directed graph $G = (V, E)$, where $V$ is the set of possible system configurations (vertices) and $E$ is the set of possible single-step transitions between configurations (edges). The total number of configurations is $N$. For a system of a certain complexity, indexed by a parameter $n$, this number is given by $N = 2^{s(n)}$, where $s(n)$ is a positive integer-valued function.\n\nTo verify if a target configuration $v$ is reachable from a starting configuration $u$, a recursive algorithm called `CheckPath` is used. The function `CheckPath(u, v, k)` returns `true` if $v$ is reachable from $u$ via a path of length at most $2^k$, and `false` otherwise. The algorithm is defined as follows:\n\n-   **Base Case ($k=0$):** `CheckPath(u, v, 0)` returns `true` if $u=v$ or if there is a direct edge $(u, v) \\in E$. Otherwise, it returns `false`.\n-   **Recursive Step ($k>0$):** `CheckPath(u, v, k)` returns `true` if there exists any intermediate configuration $w \\in V$ such that both `CheckPath(u, w, k-1)` and `CheckPath(w, v, k-1)` return `true`. If no such $w$ exists after checking all possibilities, it returns `false`.\n\nTo solve the general reachability problem (i.e., to determine if a path of any length exists from a starting configuration to a target configuration), the algorithm must be able to check for paths of a sufficient length. Any path that does not repeat a configuration can have a length of at most $N-1$. Therefore, to be safe, the check is configured for a maximum path length of up to $N$. The top-level call to the algorithm is thus `CheckPath(start, target, k_max)`, where `k_max` is the smallest integer chosen to satisfy the condition $2^{k_{max}} \\ge N$.\n\nGiven this setup, what is the maximum depth of the recursion stack during the execution of the algorithm for the general reachability problem? The recursion depth is defined as the maximum number of nested function calls active at any single point in time. Express your answer as a function of $s(n)$.", "solution": "We are given that the number of configurations is $N = 2^{s(n)}$. To handle the general reachability problem, the top-level call uses a parameter $k_{\\max}$ such that $2^{k_{\\max}} \\ge N$. The smallest such integer is\n$$\nk_{\\max} = \\lceil \\log_{2} N \\rceil.\n$$\nSince $N = 2^{s(n)}$, we have $\\log_{2} N = s(n)$ exactly, hence\n$$\nk_{\\max} = s(n).\n$$\n\nNow we determine the maximum recursion depth of the function CheckPath during this execution. The recursive rule reduces the third argument by $1$ at each recursive call until reaching the base case at $k=0$. Along any single active call chain, the parameter sequence is\n$$\nk_{\\max},\\, k_{\\max}-1,\\, k_{\\max}-2,\\, \\ldots,\\, 1,\\, 0,\n$$\nso the number of simultaneously active calls on the stack equals the number of terms in this sequence, which is $k_{\\max} + 1$.\n\nAlthough each call may trigger two recursive subcalls, these are evaluated sequentially: to check whether there exists a $w$ such that both subcalls return true, the algorithm first evaluates one subcall completely before invoking the other. Therefore, at any instant, only one branch’s recursive calls are on the stack in addition to the current frame. Thus, the maximum recursion depth is not doubled; it is exactly the height of a single branch, which is $k_{\\max} + 1$.\n\nSubstituting $k_{\\max} = s(n)$ yields the maximum recursion depth\n$$\ns(n) + 1.\n$$", "answer": "$$\\boxed{s(n)+1}$$", "id": "1446430"}, {"introduction": "The algorithm at the heart of Savitch's theorem is powerful for deciding if a path exists, but what are the properties of the path it implicitly finds? This final exercise challenges you to think critically about whether the algorithm's method of searching for an intermediate configuration guarantees finding the most efficient, or *shortest*, path [@problem_id:1446443]. Answering this question provides deeper insight into the algorithm's search strategy and highlights an important distinction between this method and classic shortest-path algorithms.", "problem": "In computational complexity theory, Savitch's theorem proves that any problem solvable by a Nondeterministic Turing Machine (NTM) using a polynomial amount of space can also be solved by a deterministic Turing machine using a polynomial amount of space, establishing that $\\mathrm{PSPACE} = \\mathrm{NPSPACE}$.\n\nThe core of the proof involves a deterministic algorithm to decide the `ST-REACH` problem: given a directed graph (representing the configuration graph of an NTM), a start vertex `c_start`, an end vertex `c_end`, and a maximum path length `N`, determine if there is a path from `c_start` to `c_end` of length at most `N`.\n\nLet's consider a simplified version of the recursive procedure at the heart of the proof. The function, which we will call `CanReach(c_1, c_2, k)`, determines if configuration `c_2` is reachable from configuration `c_1` in at most $2^k$ steps. The parameter `k` is an integer such that $2^k \\ge N$.\n\nThe algorithm is defined as follows:\n- **`CanReach(c_1, c_2, k)`:**\n  1. If $k = 0$: Return `true` if `c_1` is identical to `c_2`, or if `c_2` can be reached from `c_1` in a single step according to the NTM's transition function. Otherwise, return `false`.\n  2. If $k > 0$: Iterate through every possible intermediate configuration `c_mid`. For each `c_mid`:\n     a. If `CanReach(c_1, c_mid, k-1)` returns `true`, then:\n     b. If `CanReach(c_mid, c_2, k-1)` also returns `true`:\n     c. Then a path has been found. Return `true`.\n  3. If the loop completes without finding any such `c_mid`, return `false`.\n\nThe first path whose existence is successfully verified by this algorithm is implicitly defined by the first intermediate configuration `c_mid` (in the machine's fixed order of iteration) for which both recursive calls succeed, and so on for all sub-problems.\n\nIs this implicitly found path guaranteed to be a shortest path from `c_start` to `c_end` in the configuration graph?\n\nA. Yes, because the recursive bisection of the path length ensures an optimal substructure that is characteristic of shortest path algorithms.\n\nB. Yes, because the algorithm is a space-optimized implementation of a breadth-first search.\n\nC. No, because the algorithm systematically tries all possible intermediate configurations in a fixed order, and the first one that leads to a valid path is not necessarily on a shortest path.\n\nD. No, because the configuration graph may contain cycles, and shortest path algorithms are not well-defined on graphs with cycles.\n\nE. The question is ill-posed, as the algorithm only decides the existence of a path but is incapable of constructing or identifying any specific path.", "solution": "We formalize the setting. Let $G=(V,E)$ be the directed configuration graph of the nondeterministic Turing machine. For $c_{1},c_{2} \\in V$ and integer $k \\ge 0$, the procedure $\\mathrm{CanReach}(c_{1},c_{2},k)$ returns true if and only if there exists a path in $G$ from $c_{1}$ to $c_{2}$ of length at most $2^{k}$. Define the graph-theoretic distance $\\mathrm{dist}(u,v)$ as the length of a shortest path from $u$ to $v$ (with $\\mathrm{dist}(u,v)=\\infty$ if no path exists). The question asks whether the specific path implicitly determined by the first successful sequence of recursive midpoint choices is always a shortest path from $c_{\\mathrm{start}}$ to $c_{\\mathrm{end}}$.\n\nWe analyze the algorithm’s behavior. The base case $k=0$ tests whether $c_{1}=c_{2}$ or $(c_{1},c_{2}) \\in E$, i.e., $\\mathrm{dist}(c_{1},c_{2}) \\le 1$. For $k>0$, the algorithm loops over $c_{\\mathrm{mid}} \\in V$ in a fixed order, and returns true upon finding some $c_{\\mathrm{mid}}$ such that both $\\mathrm{CanReach}(c_{1},c_{\\mathrm{mid}},k-1)$ and $\\mathrm{CanReach}(c_{\\mathrm{mid}},c_{2},k-1)$ are true. By induction on $k$, correctness of the decision problem holds: if the procedure returns true, there exists a path of length at most $2^{k}$; if it returns false, no such path exists. However, this correctness criterion only concerns existence within the length bound, not minimality of the length of the particular path constructed by the sequence of midpoint choices.\n\nTo see that the first found path need not be shortest, construct an explicit counterexample. Let $V=\\{s,a,b,t\\}$ and $E=\\{(s,t),(s,a),(a,b),(b,t)\\}$. Then $\\mathrm{dist}(s,t)=1$ via the direct edge $(s,t)$, while there also exists a longer path $s \\to a \\to b \\to t$ of length $3$. Choose $k=2$ so that $2^{k}=4 \\ge 3$. Suppose the fixed iteration order over midpoints is $a,b,s,t$.\n\nConsider $\\mathrm{CanReach}(s,t,2)$. The procedure checks $c_{\\mathrm{mid}}=a$ first:\n- It evaluates $\\mathrm{CanReach}(s,a,1)$, which is true because there exists a path of length at most $2$ from $s$ to $a$ (indeed, $(s,a) \\in E$). Concretely, within $\\mathrm{CanReach}(s,a,1)$, picking $c_{\\mathrm{mid}}=a$ yields $\\mathrm{CanReach}(s,a,0)$ true (since $(s,a) \\in E$) and $\\mathrm{CanReach}(a,a,0)$ true (since $a=a$).\n- It then evaluates $\\mathrm{CanReach}(a,t,1)$, which is also true because there exists a path $a \\to b \\to t$ of length $2$. Concretely, within $\\mathrm{CanReach}(a,t,1)$, picking $c_{\\mathrm{mid}}=b$ yields $\\mathrm{CanReach}(a,b,0)$ true (since $(a,b) \\in E$) and $\\mathrm{CanReach}(b,t,0)$ true (since $(b,t) \\in E$).\n\nTherefore, $\\mathrm{CanReach}(s,t,2)$ returns true on the first midpoint $a$, establishing reachability via the path $s \\to a \\to b \\to t$ of length $3$. Note that the strictly shorter path $s \\to t$ of length $1$ exists, and would also be certified by the algorithm (e.g., by considering $c_{\\mathrm{mid}}=t$ and then $\\mathrm{CanReach}(s,t,1)$ splitting into two segments of length at most $1$), but because the midpoint iteration order is fixed and independent of distances, the algorithm returns as soon as it finds any valid midpoint that splits the path into two subpaths of length at most $2^{k-1}$. Hence the first successful path discovered need not be shortest; it is only guaranteed to have length at most $2^{k}$.\n\nThis directly refutes option A (no optimal-substructure-driven shortest path guarantee is enforced by the midpoint iteration order) and option B (the algorithm is not a breadth-first search; it does not explore states in nondecreasing distance order). Option D is incorrect because shortest path length is well-defined even in graphs with cycles; cycles do not preclude the notion of a shortest path. Option E is incorrect because, although Savitch’s algorithm is designed for decision, the recursive midpoint choices do implicitly define a specific path, and with minor bookkeeping one can output that path; even in the given description, the path is implicitly specified by the successful midpoints. Therefore, the correct choice is that the first found path is not guaranteed to be shortest precisely because the algorithm’s fixed-order search over midpoints can identify a longer valid path before a shorter one.", "answer": "$$\\boxed{C}$$", "id": "1446443"}]}