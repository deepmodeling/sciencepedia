{"hands_on_practices": [{"introduction": "To build an intuition for the class NL, we begin with a foundational problem: connectivity in an undirected graph. This practice invites you to analyze a simple non-deterministic \"random walk\" algorithm and calculate its memory usage. By focusing on the space required to store only the current location and a step counter, you'll discover firsthand why such a powerful graph exploration can be accomplished using only a logarithmic amount of space [@problem_id:1453163].", "problem": "A large-scale, decentralized data storage network is modeled as an undirected graph $G=(V, E)$, where the set of vertices $V$ represents $n$ distinct data servers, labeled from $1$ to $n$. The set of edges $E$ represents direct, bidirectional communication links between these servers. A crucial maintenance task is to determine if two specific servers, a source $s$ and a target $t$, are in the same connected component of the network, which means a data packet could theoretically be routed between them.\n\nA junior engineer proposes the following non-deterministic algorithm to check for connectivity:\n1. Initialize a variable `current_node` to the label of the source server $s$. Initialize an integer counter `steps_taken` to 0. These are stored on a work tape.\n2. If `current_node` is equal to $t$, the algorithm halts and accepts.\n3. If `steps_taken` is equal to $n$, the algorithm halts and rejects. This prevents a non-terminating computation.\n4. Increment `steps_taken` by one.\n5. Non-deterministically select a server `next_node` that is a neighbor of `current_node` in the graph.\n6. Update `current_node` to the value of `next_node`.\n7. Go to step 2.\n\nAssume this algorithm is implemented on a non-deterministic Turing machine. The graph's structure is provided on a read-only input tape (for instance, as an adjacency list), which does not contribute to the space complexity of the algorithm. Your task is to determine the space complexity on the writable work tape required to execute this algorithm. The complexity should be expressed using Big-O notation as a function of $n$, the total number of servers.\n\nWhich of the following represents the tightest upper bound on the work tape space complexity of this algorithm?\n\nA. $O(1)$\n\nB. $O(\\log n)$\n\nC. $O(n)$\n\nD. $O(n \\log n)$\n\nE. $O(n^2)$", "solution": "The problem asks for the space complexity of a given non-deterministic algorithm on a Turing machine's work tape. The space complexity is determined by the amount of memory needed to store the variables used by the algorithm during its execution. The input, representing the graph, is on a read-only tape and does not count towards this complexity. Let's analyze the memory requirements for each piece of information the algorithm needs to store on its work tape.\n\nThe algorithm uses two main variables: `current_node` and `steps_taken`.\n\nFirst, let's consider the variable `current_node`. This variable stores the label of the server the algorithm is currently visiting. The servers are labeled from $1$ to $n$. To store an integer value in the range $[1, n]$, we need a number of bits proportional to the logarithm of the range's size. Specifically, to represent any integer up to $n$ in binary, we need $\\lceil \\log_2 n \\rceil$ bits. In terms of Big-O notation, the space required to store `current_node` is $O(\\log n)$.\n\nSecond, let's analyze the space required for the counter `steps_taken`. This counter starts at 0 and is incremented at each step of the non-deterministic walk. The algorithm has a stopping condition (step 3) when `steps_taken` reaches $n$. Therefore, the maximum value this counter can hold is $n$. Similar to the `current_node` variable, storing an integer value up to $n$ requires $O(\\log n)$ space.\n\nThird, the algorithm at step 5 non-deterministically selects a neighbor, `next_node`. The machine might need some temporary scratch space to read a neighbor's ID from the input tape and hold it before overwriting `current_node`. The ID of any neighbor is also an integer between $1$ and $n$, so storing this temporary value also requires $O(\\log n)$ space.\n\nThe total space required on the work tape is the sum of the space needed for all the variables the algorithm must keep track of. This includes `current_node`, `steps_taken`, and any temporary variables used in the process.\n\nTotal space = Space for `current_node` + Space for `steps_taken` + Space for temporary variables\nTotal space = $O(\\log n) + O(\\log n) + O(\\log n)$\n\nThe sum of a constant number of $O(\\log n)$ terms is still $O(\\log n)$.\n\nTherefore, the total space complexity of the algorithm on the work tape is $O(\\log n)$. This means the problem of undirected s-t connectivity is in the complexity class NL (Non-deterministic Logarithmic space).\n\nLet's evaluate the given options:\nA. $O(1)$: This would imply constant space, regardless of the number of servers $n$. This is incorrect, as we need to store server labels, whose size depends on $n$.\nB. $O(\\log n)$: This matches our derivation.\nC. $O(n)$: This would be the case if, for example, the algorithm needed to store the entire path it has traversed. The described algorithm cleverly avoids this by only storing the current location.\nD. $O(n \\log n)$: This might correspond to storing a path of length up to $n$, where each node ID requires $O(\\log n)$ space. Again, the algorithm does not do this.\nE. $O(n^2)$: This might be the space required to store an adjacency matrix representation of the graph on the work tape, which is not what the algorithm does.\n\nThus, the tightest upper bound among the choices is $O(\\log n)$.", "answer": "$$\\boxed{B}$$", "id": "1453163"}, {"introduction": "Now that we've seen how to check for simple reachability, let's consider a more complex path property. This problem asks whether a path exists with an odd number of special \"switcher\" vertices, a task that seems to require remembering the entire path. The key insight here is to augment the machine's state with a tiny amount of extra information—a single bit for parity—to track this property without violating the logarithmic space limit, showcasing the power of state augmentation in algorithm design [@problem_id:1453142].", "problem": "In the field of computational complexity theory, we analyze the resources required to solve computational problems. Consider the following decision problem, which we will call `ODD-SWITCH-PATH`.\n\nAn instance of the problem is defined by a tuple $(G, S, s, t)$, where:\n- $G = (V, E)$ is a directed graph with a set of vertices $V$ and a set of directed edges $E$. Let $|V| = k$.\n- $S \\subseteq V$ is a designated non-empty subset of vertices, which we call \"switchers\".\n- $s \\in V$ is the start vertex.\n- $t \\in V$ is the target vertex.\n\nA path from $s$ to $t$ is a sequence of vertices $(v_0, v_1, \\ldots, v_m)$ such that $v_0 = s$, $v_m = t$, and for all $i \\in \\{0, 1, \\ldots, m-1\\}$, the directed edge $(v_i, v_{i+1})$ is in $E$. Note that the path includes both its start and end vertices. The number of switchers on a path is the count of vertices $v_i$ in the sequence that are also in the set $S$.\n\nThe `ODD-SWITCH-PATH` problem asks: given an instance $(G, S, s, t)$, does there exist at least one path from $s$ to $t$ that contains an odd number of switchers?\n\nWhich of the following represents the tightest, well-known complexity class that is proven to contain the `ODD-SWITCH-PATH` problem?\n\nA. L (Deterministic Logarithmic Space)\n\nB. NL (Non-deterministic Logarithmic Space)\n\nC. P (Polynomial Time)\n\nD. NP (Non-deterministic Polynomial Time)\n\nE. PSPACE (Polynomial Space)", "solution": "We first show containment in NL by giving a nondeterministic logarithmic-space algorithm that decides the language. Let the input be $(G, S, s, t)$ with $G = (V, E)$ and $|V| = k$. A nondeterministic Turing machine maintains:\n- the current vertex $v \\in V$ using $O(\\log k)$ bits,\n- a step counter $c$ initialized to $k$ and decremented at each move, using $O(\\log k)$ bits,\n- a single parity bit $b \\in \\{0,1\\}$ indicating the parity modulo $2$ of the number of visited switchers so far.\n\nInitialize $v := s$ and $b := 1$ if $s \\in S$, and $b := 0$ otherwise. Repeat the following until halting:\n- If $v = t$ and $b = 1$, accept.\n- If $c = 0$, reject.\n- Otherwise, nondeterministically choose a neighbor $u$ such that $(v,u) \\in E$, set $v := u$, set $b := b \\oplus [u \\in S]$, and set $c := c - 1$.\n\nThis uses $O(\\log k)$ space. Correctness: If there exists a path $(v_{0},\\ldots,v_{m})$ from $s$ to $t$ with an odd number of vertices in $S$, then there exists a simple such path with $m \\leq k-1$; the machine can guess it and accept when $v = t$ and $b = 1$. Conversely, any accepting computation path corresponds to a sequence of vertices from $s$ to $t$ whose parity bit $b$ is $1$ at $t$, meaning the number of switchers on that path is odd. Therefore, $\\text{ODD-SWITCH-PATH} \\in \\text{NL}$.\n\nWe now show NL-hardness by a logspace many-one reduction from the directed $s$-$t$ reachability problem $\\text{STCON}$, which is NL-complete. Given an instance $(G, s, t)$ of $\\text{STCON}$, map it to the instance $(G, S, s, t)$ of $\\text{ODD-SWITCH-PATH}$ where $S := \\{t\\}$. This mapping is computable in logarithmic space. We claim:\n$$\n(G,s,t) \\in \\text{STCON} \\iff (G, \\{t\\}, s, t) \\in \\text{ODD-SWITCH-PATH}.\n$$\n($\\Rightarrow$) If there is a path from $s$ to $t$, there is a simple such path that visits $t$ exactly once at the end. Since $S = \\{t\\}$, the number of switchers on that path is $1$, which is odd.\n($\\Leftarrow$) If there exists a path from $s$ to $t$ with an odd number of switchers under $S = \\{t\\}$, then in particular there is a path from $s$ to $t$. Hence the reduction is correct, establishing NL-hardness.\n\nTogether, containment in NL and NL-hardness imply that $\\text{ODD-SWITCH-PATH}$ is NL-complete. Therefore, the tightest well-known complexity class proven to contain the problem is NL.", "answer": "$$\\boxed{B}$$", "id": "1453142"}, {"introduction": "Our final practice explores the \"other side\" of decision problems and a landmark theorem in complexity theory. Instead of finding a path, we must verify that no cyclic path exists in a directed graph, a common problem in task scheduling. This exercise guides you to think about the complement of a problem, introducing the class co-NL, and culminates in understanding the profound implication of the Immerman-Szelepcsényi theorem, which states that $NL = coNL$ and establishes a beautiful symmetry in the power of non-deterministic log-space computation [@problem_id:1453166].", "problem": "Consider a computational problem called `TASK-ORDERING-VALIDATION`. In this problem, you are given a set of $n$ tasks, denoted by $T = \\{t_1, t_2, \\dots, t_n\\}$, and a set of $m$ prerequisite dependencies, $D$. Each dependency is an ordered pair $(t_i, t_j)$, which signifies that task $t_i$ must be completed before task $t_j$ can begin. This system can be modeled as a directed graph $G=(V, E)$, where the vertices $V$ correspond to the tasks $T$, and a directed edge from vertex $t_i$ to vertex $t_j$ exists if and only if $(t_i, t_j)$ is a dependency in $D$.\n\nA valid sequential ordering of all tasks is only possible if the dependency graph does not contain any circular dependencies (e.g., Task A requires Task B, Task B requires Task C, and Task C requires Task A). Such a circular dependency corresponds to a directed cycle in the graph, which is a path of one or more edges that starts and ends at the same vertex. The `TASK-ORDERING-VALIDATION` problem is to decide whether a given set of tasks and dependencies is free of circular dependencies. In graph-theoretic terms, this is equivalent to determining if the corresponding directed graph $G$ is a Directed Acyclic Graph (DAG).\n\nLet NL be the complexity class of decision problems solvable by a nondeterministic Turing machine using a logarithmic amount of memory space ($O(\\log |input|)$), and let co-NL be the class of problems whose complement is in NL. Based on the fundamental properties of these complexity classes, which of the following statements about the `TASK-ORDERING-VALIDATION` problem is correct?\n\nAssume the graph is represented in a standard format (e.g., an adjacency list) such that its input size is a polynomial in $n$ and $m$.\n\nA. `TASK-ORDERING-VALIDATION` is in NL, but it is not known whether it is in co-NL.\n\nB. `TASK-ORDERING-VALIDATION` is in co-NL, but it is not known whether it is in NL.\n\nC. `TASK-ORDERING-VALIDATION` is known to be in P, but it is not known whether it is in NL or co-NL.\n\nD. `TASK-ORDERING-VALIDATION` is in both NL and co-NL.\n\nE. `TASK-ORDERING-VALIDATION` is NP-hard.", "solution": "We model the instance as a directed graph $G=(V,E)$ with $|V|=n$ and $|E|=m$. The problem asks whether $G$ is acyclic, i.e., whether $G$ contains no directed cycle. Let $ACYCLIC$ denote this decision problem and let $CYCLE$ denote its complement, which asks whether $G$ contains a directed cycle. Formally, $ACYCLIC=\\overline{CYCLE}$.\n\nStep 1 (Show $CYCLE \\in \\mathrm{NL}$): We describe a nondeterministic log-space algorithm for $CYCLE$.\n- Nondeterministically choose a start vertex $v_{0} \\in V$ and store its index using $O(\\log n)$ bits.\n- Maintain a counter $c$ initialized to $1$ and bounded by $n$, stored in $O(\\log n)$ bits.\n- Maintain the current vertex $v$, initialized to $v_{0}$, stored in $O(\\log n)$ bits.\n- Repeat: nondeterministically choose an outgoing edge $(v,u) \\in E$ (by guessing a neighbor index and verifying it from the input), set $v \\leftarrow u$, and increment $c$. If at any step $v=v_{0}$ and $c \\geq 1$, accept. If $c$ exceeds $n$, reject on this branch.\nCorrectness: If $G$ has a directed cycle, then there exists a simple cycle of length $k$ with $1 \\leq k \\leq n$. The machine can guess that cycle by choosing $v_{0}$ on the cycle and the $k$ edges along it, thus reaching $v_{0}$ in at most $n$ steps and accepting. If $G$ has no cycle, then no sequence of at most $n$ edge traversals returns to $v_{0}$ after at least one step, so there is no accepting branch. Space: we store $v_{0}$, $v$, and the counter $c$, each in $O(\\log n)$ bits, plus constant workspace to scan the input and verify edges; hence total space is $O(\\log |input|)$. Therefore $CYCLE \\in \\mathrm{NL}$.\n\nStep 2 (Complement and co-NL): Since $ACYCLIC=\\overline{CYCLE}$ and $CYCLE \\in \\mathrm{NL}$, it follows that $ACYCLIC \\in \\mathrm{co\\text{-}NL}$ by definition of co-NL.\n\nStep 3 (Immerman–Szelepcsényi theorem): By the Immerman–Szelepcsényi theorem, $\\mathrm{NL}=\\mathrm{co\\text{-}NL}$. Therefore $ACYCLIC \\in \\mathrm{NL}$ as well.\n\nStep 4 (Consistency with known polynomial-time algorithms): Independently, $ACYCLIC \\in \\mathrm{P}$ via, for example, depth-first search or Kahn’s algorithm for topological sorting. This does not contradict the above and supports that the problem is not NP-hard under standard assumptions. Among the given choices, the only correct statement is that the problem lies in both $\\mathrm{NL}$ and $\\mathrm{co\\text{-}NL}$.\n\nHence the correct option is D.", "answer": "$$\\boxed{D}$$", "id": "1453166"}]}