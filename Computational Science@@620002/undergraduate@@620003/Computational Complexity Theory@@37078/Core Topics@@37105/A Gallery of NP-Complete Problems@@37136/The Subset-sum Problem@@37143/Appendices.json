{"hands_on_practices": [{"introduction": "To truly appreciate the complexity of the Subset-Sum problem, we first need to understand why simple, intuitive strategies are not sufficient. This first exercise provides a hands-on look at a common but flawed \"greedy\" approach. By working through a small example where this strategy fails, you will gain a deeper understanding of the problem's inherent difficulty and why more sophisticated algorithms, such as dynamic programming, are necessary. [@problem_id:1463403]", "problem": "A computer science student is investigating the Subset-Sum problem, which asks if a non-empty subset of a given set of integers sums to a specific target value. The student implements a greedy algorithm to solve this problem. The algorithm works as follows:\n\n1.  Start with an empty solution subset and the initial target value, $T$.\n2.  From the set of available integers, $S$, select the largest integer that is less than or equal to the remaining target value.\n3.  Add this integer to the solution subset and subtract its value from the remaining target.\n4.  Remove the selected integer from the available set $S$.\n5.  Repeat steps 2-4 until the remaining target value is zero (a solution is found) or no more integers can be selected (the algorithm fails).\n\nThe student tests this algorithm on the set of integers $S = \\{10, 7, 6, 5\\}$ with a target value $T = 12$. The greedy algorithm fails to find a solution. However, a valid subset that sums to $T$ does exist. Which of the following is the correct subset?\n\nA. $\\{10\\}$\n\nB. $\\{7, 6\\}$\n\nC. $\\{7, 5\\}$\n\nD. $\\{5, 6\\}$\n\nE. No such subset exists", "solution": "The problem asks us to identify the correct subset of $S = \\{10, 7, 6, 5\\}$ that sums to the target $T = 12$. We are told that a specific greedy algorithm fails to find this solution. Let's first trace the execution of the greedy algorithm to understand why it fails, and then we will check the given options to find the correct solution.\n\nFirst, let's trace the greedy algorithm described.\nThe set of integers is $S = \\{10, 7, 6, 5\\}$ and the target is $T = 12$. The integers in $S$ are already sorted in descending order, which is convenient for the greedy selection process.\n\nStep 1: The current target is 12. The largest integer in $S$ is 10. Since $10 \\le 12$, the algorithm selects 10.\n- The partial solution subset is now $\\{10\\}$.\n- The remaining target value becomes $12 - 10 = 2$.\n- The set of available integers becomes $\\{7, 6, 5\\}$.\n\nStep 2: The current target is 2. The available integers are $\\{7, 6, 5\\}$.\n- The largest available integer is 7. Since $7 > 2$, it cannot be chosen.\n- The next largest available integer is 6. Since $6 > 2$, it cannot be chosen.\n- The next largest available integer is 5. Since $5 > 2$, it cannot be chosen.\n\nStep 3: There are no integers left in the available set that are less than or equal to the remaining target of 2. The algorithm terminates without reducing the target to 0. The greedy approach only found the subset $\\{10\\}$, which sums to 10, not 12. Thus, the greedy algorithm fails, as stated in the problem.\n\nNow, we need to find the correct subset. We can do this by examining the provided multiple-choice options.\n\nA. The subset is $\\{10\\}$. The sum of its elements is 10. This is not equal to the target $T = 12$.\n\nB. The subset is $\\{7, 6\\}$. The sum of its elements is $7 + 6 = 13$. This is not equal to the target $T = 12$.\n\nC. The subset is $\\{7, 5\\}$. The sum of its elements is $7 + 5 = 12$. This is equal to the target $T = 12$. This is a valid solution.\n\nD. The subset is $\\{5, 6\\}$. The sum of its elements is $5 + 6 = 11$. This is not equal to the target $T = 12$.\n\nE. This option claims that no such subset exists. This is false, because we found a valid subset in option C.\n\nTherefore, the correct subset of $S$ that sums to $T=12$ is $\\{7, 5\\}$.", "answer": "$$\\boxed{C}$$", "id": "1463403"}, {"introduction": "While the general Subset-Sum problem is NP-complete, exploring special cases can yield powerful insights and surprisingly efficient solutions. This practice problem considers a fascinating variant where all numbers in the set are distinct powers of two. This exercise will challenge you to connect the problem to the fundamental concept of binary number representation, revealing an elegant polynomial-time solution and highlighting how specific problem constraints can dramatically reduce computational complexity. [@problem_id:1463440]", "problem": "The SUBSET-SUM problem is a classic question in computer science: given a finite set of integers $S = \\{s_1, s_2, \\dots, s_n\\}$ and a target integer $T$, determine if there exists a non-empty subset of $S$ whose elements sum exactly to $T$. In its general form, SUBSET-SUM is NP-complete, meaning there is no known algorithm that can solve every instance of the problem in time that is polynomial in the input size, and it is considered among the hardest problems in the class NP (Nondeterministic Polynomial time).\n\nConsider a special variant of this problem where the set $S$ contains only distinct, non-negative powers of two. For example, $S$ could be $\\{2^0, 2^2, 2^3, 2^7\\}$, which is $\\{1, 4, 8, 128\\}$.\n\nGiven this specific constraint that all elements in the set $S$ are distinct powers of two, what is the computational complexity of this variant of the SUBSET-SUM problem?\n\nA. It remains NP-complete.\n\nB. It is solvable in polynomial time and is therefore in the complexity class P.\n\nC. It is solvable, but only in exponential time, similar to the general problem's brute-force solution.\n\nD. The problem becomes undecidable.\n\nE. It is solvable in logarithmic time with respect to the input size.", "solution": "Let $S=\\{s_{1},\\dots,s_{n}\\}$ with each $s_{j}$ a distinct non-negative power of two. Hence there exist distinct exponents $e_{1},\\dots,e_{n}\\in\\mathbb{N}\\cup\\{0\\}$ such that\n$$\ns_{j}=2^{e_{j}} \\quad \\text{for } j=1,\\dots,n,\n$$\nand we define the exponent set $E=\\{e_{1},\\dots,e_{n}\\}$. For any subset $X\\subseteq S$, the sum of its elements is\n$$\n\\sum_{s\\in X}s=\\sum_{2^{e}\\in X}2^{e}.\n$$\nBecause the exponents in $X$ are distinct, the binary expansion of this sum has $1$-bits exactly at the positions $e$ that appear in $X$. This relies on the uniqueness of binary representation: every non-negative integer has a unique representation\n$$\nT=\\sum_{i\\in B(T)}2^{i},\n$$\nwhere $B(T)$ is the set of bit positions $i$ with the $i$th bit of $T$ equal to $1$. Therefore, for $T\\ge 0$ we have:\n$$\n\\exists\\,X\\subseteq S\\text{ with }\\sum_{s\\in X}s=T \\quad \\Longleftrightarrow \\quad B(T)\\subseteq E.\n$$\nMoreover, since the subset must be non-empty and all $s_{j}\\ge 0$ with at least one $s_{j}>0$, if $T=0$ there is no non-empty subset achieving $T$; if $T<0$ there is no subset at all, because all sums are non-negative. These conditions are checkable in time polynomial in the input size.\n\nAn explicit polynomial-time algorithm is:\n1. If $T<0$, answer NO. If $T=0$, answer NO due to the non-empty requirement.\n2. Compute $E=\\{e:\\,2^{e}\\in S\\}$ by, for each $s_{j}$, extracting its exponent $e_{j}$ (verifiable in time polynomial in the bit-length of $s_{j}$).\n3. Compute $B(T)$ from the binary expansion of $T$.\n4. Check whether $B(T)\\subseteq E$; if yes, answer YES, else NO.\n\nThe running time is $O\\!\\left(\\sum_{j=1}^{n}\\log s_{j}+\\log T\\right)$, which is polynomial in the input size under standard binary encoding. Hence this special case is solvable in polynomial time, so it lies in the class P.\n\nTherefore, among the options, the correct classification is B.", "answer": "$$\\boxed{B}$$", "id": "1463440"}, {"introduction": "Having seen that simple approaches can fail and special cases can be easy, we now turn to the standard method for solving the general Subset-Sum problem: dynamic programming. This technique is powerful but can be resource-intensive. This exercise guides you through analyzing the standard dynamic programming algorithm's space complexity and explores a classic optimization technique, forcing you to think critically about how the algorithm's state dependencies allow for significant memory savings. [@problem_id:1463442]", "problem": "The SUBSET-SUM problem is a classic question in computer science: given a set of non-negative integers $S = \\{s_1, s_2, \\ldots, s_n\\}$ and a target integer sum $t$, determine if there exists a non-empty subset of $S$ whose elements sum to exactly $t$.\n\nA standard approach to solve this problem is using Dynamic Programming (DP). We can construct a two-dimensional boolean table, let's call it `P`, of size $(n+1) \\times (t+1)$. An entry `P[i][j]` is `true` if a sum `j` can be formed using a subset of the first `i` elements $\\{s_1, \\ldots, s_i\\}$, and `false` otherwise. The table is filled using the recurrence relation:\n`P[i][j] = P[i-1][j] OR P[i-1][j - s_i]`\n(where the second term is only considered if $j \\ge s_i$). The base cases are typically `P[0][0] = true` and `P[0][j] = false` for $j > 0$. The final answer to the problem is given by `P[n][t]`.\n\nAnalyze the space complexity of this standard algorithm and the logic behind optimizing it. Consider the following statements:\n\nI. The space complexity of the standard two-dimensional dynamic programming algorithm described above is $O(n \\cdot t)$.\nII. The space complexity can be optimized to $O(n + t)$ by noticing that only the previous column's values are needed.\nIII. The space optimization is possible because the calculation for any state `(i, j)` (using the first `i` elements to form sum `j`) only depends on states from the previous row `i-1`.\nIV. To implement this optimization using a single one-dimensional array, the inner loop that iterates through the possible sums `j` must be processed in increasing order (e.g., from `j = s_i` to `j = t`).\n\nWhich of the above statements are correct?\n\nA. I only\n\nB. I and III only\n\nC. II and IV only\n\nD. I, III, and IV\n\nE. All of the above", "solution": "We define the dynamic programming table as follows: for integers $i \\in \\{0,1,\\ldots,n\\}$ and $j \\in \\{0,1,\\ldots,t\\}$, let $P[i][j]$ be a boolean indicating whether some subset of $\\{s_{1},\\ldots,s_{i}\\}$ sums to $j$. The recurrence relation is\n$$\nP[i][j] = P[i-1][j] \\lor \\bigl(j \\ge s_{i} \\land P[i-1][j - s_{i}]\\bigr),\n$$\nwith base cases $P[0][0] = \\text{true}$ and $P[0][j] = \\text{false}$ for all $j > 0$.\n\nStatement I: The table has $(n+1)(t+1)$ boolean entries. Hence the space used by the standard two-dimensional DP is $\\Theta(n t)$, i.e., $O(n \\cdot t)$. Therefore I is correct.\n\nStatement III: From the recurrence, every $P[i][j]$ depends only on $P[i-1][j]$ and $P[i-1][j - s_{i}]$, i.e., only on the previous row indexed by $i-1$. This locality in $i$ is exactly why space optimization is possible. Therefore III is correct.\n\nSpace optimization logic: Define a one-dimensional array $D[j]$ to represent the current row values for sums $j \\in \\{0,\\ldots,t\\}$. To simulate transition from row $i-1$ to row $i$ in-place, we must ensure that when computing the update\n$$\nD[j] \\leftarrow D[j] \\lor D[j - s_{i}],\n$$\nthe value $D[j - s_{i}]$ used comes from the previous row, not already updated in the current row. This is achieved by iterating $j$ in decreasing order from $t$ down to $s_{i}$. As a result, only $O(t)$ space is needed for $D$, plus constant extra space for indices and temporaries, so the optimized space is $O(t)$.\n\nStatement II: It claims the optimized space is $O(n + t)$ by using only the previous column, but the dependence is on the previous row, and the standard optimization uses a single array of length $t+1$, achieving $O(t)$ space, not $O(n + t)$. Therefore II is incorrect.\n\nStatement IV: It claims the inner loop must process $j$ in increasing order. As shown above, increasing order would permit reusing $s_{i}$ more than once because $D[j - s_{i}]$ could already include the contribution of $s_{i}$ from the current iteration. For example, after setting $D[s_{i}]$ to true, an increasing scan would allow $D[2 s_{i}] \\leftarrow D[2 s_{i}] \\lor D[s_{i}]$ to become true using $s_{i}$ twice, which is incorrect for the 0-1 subset problem. Thus we must iterate $j$ in decreasing order, and IV is false.\n\nTherefore, the correct statements are I and III only.", "answer": "$$\\boxed{B}$$", "id": "1463442"}]}