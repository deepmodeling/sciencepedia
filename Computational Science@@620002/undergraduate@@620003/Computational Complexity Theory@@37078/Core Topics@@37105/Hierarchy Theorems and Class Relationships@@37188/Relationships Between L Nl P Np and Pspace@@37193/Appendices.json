{"hands_on_practices": [{"introduction": "A core skill in computational complexity is classifying a problem based on the resources required by an algorithm that solves it. This exercise [@problem_id:1445945] challenges you to take a given algorithm's time and space complexity and identify the \"smallest,\" or most specific, complexity class it belongs to from a standard set. Mastering this helps solidify your understanding of the foundational definitions of classes from $L$ to $PSPACE$.", "problem": "In computational complexity theory, we classify problems based on the computational resources—primarily time and space—required to solve them. Let us consider the following standard complexity classes for decision problems, defined with respect to an input of size $n$:\n\n- **L (Logarithmic Space):** The class of problems solvable by a deterministic algorithm using an amount of memory that is logarithmic in the input size, i.e., $O(\\log n)$.\n- **NL (Nondeterministic Logarithmic Space):** The class of problems solvable by a nondeterministic algorithm using $O(\\log n)$ memory.\n- **P (Polynomial Time):** The class of problems solvable by a deterministic algorithm in a number of steps that is a polynomial function of the input size, i.e., $O(n^k)$ for some constant $k$.\n- **NP (Nondeterministic Polynomial Time):** The class of problems for which a proposed solution can be verified by a deterministic algorithm in polynomial time.\n- **PSPACE (Polynomial Space):** The class of problems solvable by a deterministic algorithm using an amount of memory that is a polynomial function of the input size.\n\nSuppose a computer scientist discovers a new deterministic algorithm that solves a particular decision problem. The algorithm's performance is analyzed and found to have a time complexity of $O(n^2)$ and a space complexity of $O(\\log n)$.\n\nBased strictly on this information, what is the smallest (most specific) complexity class from the list below that we can be certain the problem belongs to?\n\nA. PSPACE\n\nB. NP\n\nC. P\n\nD. NL\n\nE. L", "solution": "We are given a deterministic algorithm for a decision problem with time complexity $T(n)=O(n^{2})$ and space complexity $S(n)=O(\\log n)$.\n\n1) By the definition of the class P, a problem is in P if there exists a deterministic algorithm that solves it in polynomial time. Since $T(n)=O(n^{2})$, which is polynomial, the problem is in P.\n\n2) By the definition of the class L, a problem is in L if there exists a deterministic algorithm that solves it using logarithmic space. Since $S(n)=O(\\log n)$ and the algorithm is deterministic, the problem is in L.\n\n3) Using standard inclusions among the listed classes,\n$$\n\\mathrm{L} \\subseteq \\mathrm{NL} \\subseteq \\mathrm{P} \\subseteq \\mathrm{NP} \\subseteq \\mathrm{PSPACE}.\n$$\nBecause the problem is in L, it is also in each superset, but the smallest (most specific) class from the given options that we can be certain it belongs to is $\\mathrm{L}$.\n\nTherefore, the correct choice is E.", "answer": "$$\\boxed{E}$$", "id": "1445945"}, {"introduction": "Savitch's Theorem offers a remarkable bridge, establishing that any problem solvable with a certain amount of nondeterministic space can also be solved within a deterministically bounded amount of space. This practice problem [@problem_id:1445880] provides a direct application of this fundamental result, allowing you to calculate the deterministic space complexity for a problem given its nondeterministic space usage. It's a perfect example of how theoretical results provide concrete upper bounds on computational resources.", "problem": "In computational complexity theory, we classify problems based on the resources required to solve them. Let `DSPACE(s(n))` denote the class of decision problems that can be solved by a deterministic Turing machine using an amount of space on its work tape that is on the order of $s(n)$, where $n$ is the size of the input. Similarly, let `NSPACE(s(n))` denote the class of problems solvable by a non-deterministic Turing machine using $O(s(n))$ space.\n\nA fundamental result connecting these two types of space complexity is Savitch's Theorem, which states that for any function $s(n)$ that is space-constructible and satisfies $s(n) \\ge \\log n$, the following relationship holds: `NSPACE(s(n))` is a subset of `DSPACE(s(n)^2)`.\n\nSuppose a computer scientist develops an algorithm for a specific decision problem. This algorithm is designed for a non-deterministic Turing machine and is proven to use an amount of work-tape space that is proportional to $(\\log n)^2$ for an input of size $n$.\n\nBased on this information and Savitch's Theorem, what is the tightest conclusion one can draw about the space complexity of solving this problem on a *deterministic* Turing machine?\n\nA. The problem is solvable using $O(\\log n)$ deterministic space.\n\nB. The problem is solvable using $O((\\log n)^2)$ deterministic space.\n\nC. The problem is solvable using $O((\\log n)^3)$ deterministic space.\n\nD. The problem is solvable using $O((\\log n)^4)$ deterministic space.\n\nE. The problem requires polynomial space, but a more specific polylogarithmic bound cannot be determined from the given information.", "solution": "The problem statement provides that a new algorithm solves a decision problem on a non-deterministic Turing machine using work-tape space proportional to $(\\log n)^2$. In the language of complexity classes, this means the problem belongs to the class `NSPACE((\\log n)^2)`.\n\nWe are given Savitch's Theorem, which provides a relationship between non-deterministic space complexity and deterministic space complexity. The theorem states that for a space-constructible function $s(n)$ where $s(n) \\ge \\log n$, we have `NSPACE(s(n)) \\subseteq DSPACE(s(n)^2)`.\n\nTo apply this theorem, we must identify our space function $s(n)$ and verify that it meets the theorem's preconditions. In this case, the non-deterministic space usage is $O((\\log n)^2)$, so we set our space function $s(n) = (\\log n)^2$.\n\nFirst, we check the condition $s(n) \\ge \\log n$. For our function, this means we must check if $(\\log n)^2 \\ge \\log n$. Dividing both sides by $\\log n$ (for $n>1$, where $\\log n > 0$), we get $\\log n \\ge 1$. This inequality holds for all $n \\ge e$, where $e$ is Euler's number (approximately 2.718). Thus, for all non-trivially sized inputs, the condition is met. The function $s(n) = (\\log n)^2$ is also a standard space-constructible function. Therefore, Savitch's Theorem is applicable.\n\nNow, we apply the theorem by substituting $s(n) = (\\log n)^2$ into the inclusion `NSPACE(s(n)) \\subseteq DSPACE(s(n)^2)`.\nThis gives us:\n`NSPACE((\\log n)^2) \\subseteq DSPACE( ((\\log n)^2)^2 )`\n\nNext, we simplify the expression on the right-hand side. The space bound for the deterministic class is $(s(n))^2$, which in our case is $((\\log n)^2)^2$. Using the rule of exponents $(x^a)^b = x^{ab}$, we have:\n$((\\log n)^2)^2 = (\\log n)^{2 \\times 2} = (\\log n)^4$.\n\nSo, the inclusion becomes:\n`NSPACE((\\log n)^2) \\subseteq DSPACE((\\log n)^4)`\n\nThis result tells us that any problem in `NSPACE((\\log n)^2)` is also in `DSPACE((\\log n)^4)`. In other words, there must exist a deterministic algorithm that can solve the problem using space on the order of $O((\\log n)^4)$. This is the tightest upper bound that can be concluded directly from Savitch's Theorem.\n\nComparing this result with the given options:\nA. $O(\\log n)$ is incorrect.\nB. $O((\\log n)^2)$ is incorrect; this would imply `NSPACE` is equal to `DSPACE` for this function, which is not guaranteed by the theorem.\nC. $O((\\log n)^3)$ is incorrect; this results from an arithmetic error when squaring the space function.\nD. $O((\\log n)^4)$ matches our derived upper bound.\nE. This is incorrect because we were able to determine a specific polylogarithmic bound.\n\nTherefore, the correct conclusion is that the problem is solvable using $O((\\log n)^4)$ deterministic space.", "answer": "$$\\boxed{D}$$", "id": "1445880"}, {"introduction": "Sometimes, a special constraint or \"promise\" about a problem's instances can significantly impact its computational complexity. This practice [@problem_id:1445947] examines such a scenario with the `UPATH` problem, a version of directed graph reachability where paths are guaranteed to be unique. Analyzing this problem offers insight into more specialized complexity classes and demonstrates how problem structure relates to major open questions like $L = NL$.", "problem": "A company is designing a specialized, highly constrained communication network. The network's topology, represented as a directed graph $G = (V, E)$, has a crucial property enforced by its hardware routing protocols: for any pair of nodes $s, t \\in V$, there is either no possible communication path from $s$ to $t$, or there is exactly one unique simple path (a path with no repeated vertices) from $s$ to $t$.\n\nYour task is to analyze the computational complexity of the fundamental reachability problem within this network architecture. This problem, which we will call `UPATH`, is defined as follows:\n\n**Instance:** A directed graph $G=(V, E)$ and two vertices $s, t \\in V$.\n**Promise:** For the given $s$ and $t$, there is at most one simple path in $G$ from $s$ to $t$.\n**Question:** Does a path exist from $s$ to $t$?\n\nBased on established results in computational complexity theory, which of the following options provides the most accurate and tightest classification for the `UPATH` problem?\n\nA. `UPATH` is in `L` (Deterministic Logarithmic Space).\n\nB. `UPATH` is `NL-complete` under log-space reductions.\n\nC. `UPATH` is in `NL` (Nondeterministic Logarithmic Space), but it is not known to be in `L` and is widely believed not to be `NL-complete`.\n\nD. `UPATH` is in `P` (Polynomial Time) but is not known to be in `NL`.\n\nE. `UPATH` is `P-complete` under log-space reductions.", "solution": "We restate the promise problem: Given a directed graph $G=(V,E)$ and $s,t \\in V$, under the promise that there is at most one simple path from $s$ to $t$, decide whether there exists a path from $s$ to $t$.\n\nFirst, show containment in $NL$. The standard $NL$ algorithm for directed reachability guesses the next vertex along a path nondeterministically while maintaining the current vertex and a step counter up to $|V|$ in $O(\\log |V|)$ space. Specifically, a nondeterministic logspace machine starts at $s$, and for at most $|V|$ steps, guesses an outgoing edge to a next vertex; it accepts if it ever reaches $t$. This uses $O(\\log |V|)$ space to store a vertex index and a counter. Therefore, directed reachability is in $NL$, and since the promise only restricts instances, the promise problem $UPATH$ is in $NL$ as well:\n$$\nUPATH \\in NL.\n$$\n\nSecond, address membership in $L$. For undirected reachability, it is known that the problem is in $L$, but for directed reachability there is no known deterministic logspace algorithm. The unique-path promise does not currently yield a deterministic logspace algorithm in general. In fact, the problem is known to lie in the unambiguous logspace class $UL$ (and even in $UL \\cap coUL$ by refined results), but it is not known whether $UL=L$. Thus there is no established proof that $UPATH \\in L$.\n\nThird, consider $NL$-completeness. If $UPATH$ were $NL$-complete under log-space many-one reductions, then since $UPATH \\in UL \\subseteq NL$, it would imply $NL \\subseteq UL$, hence $NL=UL$. The equality $NL=UL$ is a major open question and is widely believed to be false. Therefore, it is widely believed that $UPATH$ is not $NL$-complete.\n\nFinally, options claiming only $P$-membership without $NL$-membership are incorrect because $NL \\subseteq P$ and we have already established $UPATH \\in NL$. Likewise, $P$-completeness is far too strong and contradicts the containment in $NL$ unless $NL=P$.\n\nCombining these points, the most accurate and tightest established classification among the options is that $UPATH$ is in $NL$, not known to be in $L$, and widely believed not to be $NL$-complete.", "answer": "$$\\boxed{C}$$", "id": "1445947"}]}