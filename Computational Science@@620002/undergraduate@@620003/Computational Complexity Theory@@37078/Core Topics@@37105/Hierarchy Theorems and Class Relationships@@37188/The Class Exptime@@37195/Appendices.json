{"hands_on_practices": [{"introduction": "Understanding a complexity class begins with mastering its definition. This first exercise focuses on the boundary that defines EXPTIME: algorithms with a runtime complexity of $O(2^{p(n)})$ for some polynomial $p(n)$. By comparing several common and not-so-common growth functions, you will develop a sharp intuition for which computational costs fall within this vast class and which lie beyond it [@problem_id:1452143].", "problem": "In computational complexity theory, decision problems are categorized into complexity classes based on the resources required to solve them. One such fundamental class is EXPTIME (Exponential Time). A decision problem is said to belong to the class EXPTIME if there exists a deterministic Turing machine that can solve it in a time complexity of $O(2^{p(n)})$, where $n$ is the size of the input and $p(n)$ is any polynomial function of $n$.\n\nA computer science student is analyzing a set of five different algorithms, each designed to solve a different problem. The worst-case time complexities for these algorithms have been determined as functions of their input size $n$.\n\n- Algorithm A: $O(2^{n^4})$\n- Algorithm B: $O(2^{\\sqrt{n}})$\n- Algorithm C: $O(1.5^n)$\n- Algorithm D: $O(2^{2^n})$\n- Algorithm E: $O(n^{1000})$\n\nWhich of the time complexities listed above corresponds to a problem that is **not** guaranteed to be in the class EXPTIME?", "solution": "EXPTIME is the class of decision problems solvable by a deterministic Turing machine in time $O(2^{p(n)})$ for some polynomial $p(n)$.\n\nEvaluate each algorithm against the form $2^{p(n)}$ with polynomial $p$:\n- Algorithm A has time $O(2^{n^{4}})$. Here $p(n)=n^{4}$ is a polynomial, hence $O(2^{n^{4}})\\subseteq\\text{EXPTIME}$.\n\n- Algorithm B has time $O(2^{\\sqrt{n}})$. Since $\\sqrt{n}\\le n$ for all $n\\ge 1$, we have $2^{\\sqrt{n}}\\le 2^{n}$, so $O(2^{\\sqrt{n}})\\subseteq O(2^{n})$ with $p(n)=n$ polynomial. Hence it is in EXPTIME.\n\n- Algorithm C has time $O(1.5^{n})$. Using $1.5^{n}=2^{(\\log_{2}(1.5))\\,n}$ with constant $\\log_{2}(1.5)\\le 1$, we have $1.5^{n}\\le 2^{n}$ for all $n\\ge 1$, so $O(1.5^{n})\\subseteq O(2^{n})$ with $p(n)=n$ polynomial. Hence it is in EXPTIME.\n\n- Algorithm E has time $O(n^{1000})$. Since exponential functions dominate polynomials, $\\lim_{n\\to\\infty}\\frac{n^{1000}}{2^{n}}=0$, so there exists $N$ such that for all $n\\ge N$, $n^{1000}\\le 2^{n}$. Thus $O(n^{1000})\\subseteq O(2^{n})$ with $p(n)=n$ polynomial, so it is in EXPTIME.\n\n- Algorithm D has time $O(2^{2^{n}})$. For any polynomial $p(n)$, we have $2^{n}>p(n)$ for all sufficiently large $n$, which implies $2^{2^{n}}>2^{p(n)}$ eventually. Hence $2^{2^{n}}\\notin O(2^{p(n)})$ for every polynomial $p$, so this bound is not guaranteed to lie in EXPTIME.\n\nTherefore, only the double-exponential time $O(2^{2^{n}})$ is not guaranteed to be in EXPTIME.", "answer": "$$\\boxed{D}$$", "id": "1452143"}, {"introduction": "Real-world algorithms are often built from smaller components, and their total runtime depends on the interplay between these parts. This practice moves from analyzing given functions to examining the structure of a common algorithmic strategy: brute-force search over an exponential space. It will help you dissect an algorithm's runtime and avoid the common pitfall of assuming that checking $2^n$ items automatically implies an EXPTIME complexity, reminding us that the cost of each check is critical [@problem_id:1452149].", "problem": "In computational complexity theory, the class EXPTIME (also known as EXP) is the set of all decision problems solvable by a deterministic Turing machine in $O(2^{p(n)})$ time, where $p(n)$ is a polynomial function of the input size $n$.\n\nA computer science student is designing an algorithm to solve a complex decision problem. The algorithm operates on an input of size $n$. The general strategy is a brute-force search that involves two stages:\n1.  **Generation**: The algorithm generates a complete set of candidate solutions. The total number of distinct candidates generated is exactly $2^n$.\n2.  **Verification**: For each of the $2^n$ candidates, the algorithm runs a verification subroutine to check if that candidate is a valid solution to the problem. Let us denote the time complexity of this verification subroutine as a function $V(n)$, which depends on the original input size $n$.\n\nThe total running time of the student's algorithm is therefore $T(n) = 2^n \\cdot V(n)$. The student claims their algorithm places the problem in EXPTIME. Which of the following statements presents the most accurate and general condition on the verification time $V(n)$ for this claim to be true?\n\nA. The algorithm is guaranteed to be in EXPTIME regardless of the function $V(n)$, because the number of candidates, $2^n$, is already exponential.\n\nB. The algorithm is guaranteed to be in EXPTIME if and only if $V(n)$ is a polynomial function of $n$, i.e., $V(n) = O(n^k)$ for some constant $k$.\n\nC. The algorithm is guaranteed to be in EXPTIME if $V(n)$ can be bounded by an exponential function of a polynomial in $n$, i.e., $V(n) = O(2^{q(n)})$ for some polynomial $q(n)$.\n\nD. The algorithm is guaranteed to be in EXPTIME if and only if the problem being solved is NP-complete, as all NP-complete problems are in EXPTIME.\n\nE. The algorithm cannot be in EXPTIME because the total runtime $T(n)$ involves a product with $2^n$, which will always grow faster than the $O(2^{p(n)})$ bound.", "solution": "By definition, a decision problem is in EXPTIME if there exists a polynomial $p(n)$ such that it can be solved in time $O(2^{p(n)})$ on a deterministic Turing machine. The algorithm described has total running time\n$$\nT(n)=2^{n}\\cdot V(n).\n$$\nFor the algorithm to place the problem in EXPTIME, there must exist a polynomial $p(n)$ and a constant $c>0$ such that\n$$\nT(n)\\leq c\\cdot 2^{p(n)}\n\\quad\\text{for all sufficiently large }n.\n$$\nSubstituting $T(n)=2^{n}V(n)$ gives the equivalent condition\n$$\n2^{n}V(n)\\leq c\\cdot 2^{p(n)}.\n$$\nDividing both sides by $2^{n}$ yields\n$$\nV(n)\\leq c\\cdot 2^{p(n)-n}.\n$$\nDefine $q(n)=p(n)-n$. Since $p(n)$ is a polynomial and $n$ is a polynomial of degree $1$, $q(n)$ is also a polynomial. Therefore the condition above is equivalent to\n$$\nV(n)=O\\!\\left(2^{q(n)}\\right)\\quad\\text{for some polynomial }q(n).\n$$\nThis shows sufficiency: if $V(n)=O(2^{q(n)})$ for a polynomial $q$, then\n$$\nT(n)=2^{n}V(n)=O\\!\\left(2^{n}\\cdot 2^{q(n)}\\right)=O\\!\\left(2^{n+q(n)}\\right),\n$$\nand $p(n)=n+q(n)$ is a polynomial, so $T(n)=O(2^{p(n)})$, placing the algorithm in EXPTIME.\n\nIt also shows necessity: if the algorithm is in EXPTIME, then there exists a polynomial $p(n)$ such that $2^{n}V(n)=O(2^{p(n)})$, which implies $V(n)=O(2^{p(n)-n})=O(2^{q(n)})$ for the polynomial $q(n)=p(n)-n$. Hence, if $V(n)$ grows faster than $2^{\\text{poly}(n)}$ (for example, $V(n)=2^{2^{n}}$), then $T(n)=2^{n}V(n)$ would not be bounded by $2^{\\text{poly}(n)}$ and the algorithm would not be in EXPTIME.\n\nEvaluating the options:\n- A is false because $V(n)$ could be superexponential, e.g., $V(n)=2^{2^{n}}$, making $T(n)$ not in $O(2^{\\text{poly}(n)})$.\n- B is too restrictive; polynomial $V(n)$ is sufficient but not necessary. For instance, $V(n)=2^{n}$ yields $T(n)=2^{2n}$, which is still in EXPTIME.\n- C matches the derived necessary and sufficient bound: $V(n)=O(2^{q(n)})$ for some polynomial $q(n)$.\n- D is false; EXPTIME membership does not hinge on NP-completeness, and the equivalence claimed is incorrect.\n- E is false; $2^{n}$ multiplied by $2^{\\text{poly}(n)}$ is still $2^{\\text{poly}(n)}$.\n\nTherefore, the most accurate and general condition is option C.", "answer": "$$\\boxed{C}$$", "id": "1452149"}, {"introduction": "Computational complexity theory isn't just about analyzing individual problems; it's about understanding the relationships between them. This final practice explores the powerful concept of a polynomial-time reduction, which allows us to compare the relative difficulty of different problems. By working through this scenario, you will see how reducing one problem to another that is known to be in EXPTIME provides a guaranteed upper bound on the first problem's complexity, demonstrating a fundamental structural property of this class [@problem_id:1452129].", "problem": "In computational complexity theory, problems are classified based on the resources (like time or memory) required to solve them. Let's define two important time complexity classes:\n\n1.  **P (Polynomial Time)**: A decision problem is in P if there exists an algorithm that solves it in time bounded by a polynomial in the input size $n$. That is, the running time is $O(n^k)$ for some constant $k$.\n2.  **EXPTIME (Exponential Time)**: A decision problem is in EXPTIME if there exists an algorithm that solves it in time bounded by an exponential function of a polynomial in the input size $n$. That is, the running time is $O(2^{p(n)})$ for some polynomial $p(n)$.\n\nA key concept for comparing the difficulty of problems is the polynomial-time reduction. A problem $A$ is said to be polynomial-time reducible to a problem $B$, denoted as $A \\leq_p B$, if an algorithm for problem $B$ can be used to solve problem $A$ with only a polynomial amount of additional work. More formally, there exists a function $f$, computable in polynomial time, that transforms an input $x$ for problem $A$ into an input $f(x)$ for problem $B$, such that an instance $x$ is a 'yes' instance of $A$ if and only if $f(x)$ is a 'yes' instance of $B$.\n\nSuppose we are investigating two problems, Problem `PHOTON_PATH` and Problem `QUANTUM_SIM`. We have established that `QUANTUM_SIM` is in the complexity class EXPTIME. A researcher then proves the existence of a polynomial-time reduction from `PHOTON_PATH` to `QUANTUM_SIM` (i.e., `PHOTON_PATH` $\\leq_p$ `QUANTUM_SIM`).\n\nBased solely on this information, which of the following represents the tightest **guaranteed** upper bound on the complexity class containing the `PHOTON_PATH` problem?\n\nA. P (Polynomial Time)\n\nB. NP (Nondeterministic Polynomial Time)\n\nC. PSPACE (Polynomial Space)\n\nD. EXPTIME (Exponential Time)\n\nE. The problem is undecidable.", "solution": "The problem asks for the tightest guaranteed upper-bound complexity class for a problem `PHOTON_PATH`, given that `PHOTON_PATH` $\\leq_p$ `QUANTUM_SIM` and `QUANTUM_SIM` $\\in$ EXPTIME.\n\nLet's analyze the implications of the polynomial-time reduction `PHOTON_PATH` $\\leq_p$ `QUANTUM_SIM`. This reduction means we can construct an algorithm to solve `PHOTON_PATH` using an algorithm for `QUANTUM_SIM` as a subroutine. Let's describe this process for an arbitrary input $x$ for the `PHOTON_PATH` problem.\n\nStep 1: The Reduction.\nThe reduction is a function $f$ that transforms the input $x$ for `PHOTON_PATH` into a new input, let's call it $y = f(x)$, for the `QUANTUM_SIM` problem. By definition of a polynomial-time reduction, this function $f$ must be computable in polynomial time. Let the size of input $x$ be $n$. The time to compute $y=f(x)$ is $O(n^c)$ for some constant $c$. An important consequence is that the size of the output $y$ must also be polynomial in $n$, because an algorithm running in $O(n^c)$ time can only produce an output of size at most $O(n^c)$. Let the size of $y$ be $m$. We have $m = |y| = |f(x)| \\leq O(n^c)$, which means $m$ is also a polynomial in $n$. We can write this as $m = q(n)$ where $q$ is a polynomial.\n\nStep 2: Solving the Reduced Instance.\nWe are given that the `QUANTUM_SIM` problem is in EXPTIME. This means there is an algorithm that solves any instance of `QUANTUM_SIM` in time $O(2^{p(s)})$, where $s$ is the size of the input to the `QUANTUM_SIM` algorithm and $p$ is some polynomial. In our case, the input to the `QUANTUM_SIM` algorithm is $y$, which has size $m$. Therefore, the time to solve `QUANTUM_SIM` for the input $y$ is $O(2^{p(m)})$.\n\nStep 3: Combining Time Complexities.\nThe total time to solve `PHOTON_PATH` for an input $x$ of size $n$ is the sum of the time for the reduction (Step 1) and the time for solving the `QUANTUM_SIM` instance (Step 2).\n\nTotal Time = (Time to compute $y=f(x)$) + (Time to solve `QUANTUM_SIM` on $y$)\n\nLet's express this in terms of the original input size $n$.\nTime to compute $y=f(x)$ is $O(n^c)$.\nTime to solve `QUANTUM_SIM` on $y$ is $O(2^{p(m)})$. Since $m = q(n)$ for some polynomial $q$, this becomes $O(2^{p(q(n))})$.\nA composition of two polynomials, $p(q(n))$, is itself a polynomial. Let's call this new polynomial $r(n) = p(q(n))$. So, the time to solve the `QUANTUM_SIM` part is $O(2^{r(n)})$.\n\nThe total time to solve `PHOTON_PATH` is therefore:\n$T_{total}(n) = O(n^c) + O(2^{r(n)})$\n\nWhen we analyze asymptotic complexity, an exponential term $O(2^{r(n)})$ grows much faster than any polynomial term $O(n^c)$. Therefore, the exponential term dominates the overall complexity.\n$T_{total}(n) = O(2^{r(n)})$\n\nThis resulting time complexity, $O(2^{\\text{poly}(n)})$, is by definition the complexity class EXPTIME. Therefore, the problem `PHOTON_PATH` is guaranteed to be in EXPTIME.\n\nThis is the tightest **guaranteed** upper bound. `PHOTON_PATH` could be a much simpler problem (e.g., in P), but the reduction only provides an upper bound. Since `PHOTON_PATH` could potentially be an EXPTIME-complete problem (which is just as hard as any other problem in EXPTIME), we cannot guarantee that it belongs to any smaller class like P, NP, or PSPACE based solely on the given information. Thus, the tightest guaranteed complexity class containing `PHOTON_PATH` is EXPTIME.\n\nComparing with the given options:\nA. P: Not guaranteed. `PHOTON_PATH` could be harder.\nB. NP: Not guaranteed.\nC. PSPACE: Not guaranteed. While PSPACE is contained in EXPTIME, we can't be sure `PHOTON_PATH` is in PSPACE.\nD. EXPTIME: Guaranteed by the line of reasoning above.\nE. The problem is undecidable: Incorrect, as we have just shown an algorithm that decides it.\n\nTherefore, the correct answer is EXPTIME.", "answer": "$$\\boxed{D}$$", "id": "1452129"}]}