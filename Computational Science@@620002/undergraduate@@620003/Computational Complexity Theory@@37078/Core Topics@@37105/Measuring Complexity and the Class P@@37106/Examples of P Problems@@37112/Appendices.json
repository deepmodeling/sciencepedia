{"hands_on_practices": [{"introduction": "Understanding the class P begins with the ability to analyze the efficiency of algorithms. This first exercise provides a direct, hands-on opportunity to do just that by counting the fundamental operations of a straightforward, brute-force algorithm. By formally quantifying the number of comparisons needed to find duplicate entries in a list, you will derive a polynomial expression that directly relates the input size, $N$, to the computational cost, illustrating a core principle of polynomial-time complexity. [@problem_id:1423352]", "problem": "A data integrity program is designed to test for the presence of duplicate entries within a dataset. The dataset is provided as a list containing $N$ elements. The program implements a brute-force comparison algorithm to determine if any duplicates exist.\n\nThe algorithm operates as follows:\n1. It selects the first element of the list and compares it with every subsequent element (i.e., the second, third, ..., up to the $N$-th element).\n2. It then selects the second element and compares it with every element that follows it (i.e., the third, fourth, ..., up to the $N$-th element).\n3. This process is repeated. For any given $i$-th element (where $i$ ranges from 1 to $N-1$), it is compared against all elements from the $(i+1)$-th position to the $N$-th position.\n4. The last operation is the comparison of the $(N-1)$-th element with the $N$-th element.\n\nWhat is the exact total number of comparisons the program will perform on a list of $N$ elements? Express your answer as a function of $N$.", "solution": "Let $C(N)$ denote the total number of comparisons performed on a list of $N$ elements by the described algorithm. For each index $i$ with $1 \\leq i \\leq N-1$, the $i$-th element is compared with each element from positions $i+1$ through $N$, yielding $N - i$ comparisons at step $i$. Therefore,\n$$\nC(N) = \\sum_{i=1}^{N-1} (N - i).\n$$\nThis sum can be simplified by separating terms:\n$$\nC(N) = \\sum_{i=1}^{N-1} N - \\sum_{i=1}^{N-1} i = N(N-1) - \\frac{(N-1)N}{2}.\n$$\nCombining like terms gives\n$$\nC(N) = \\frac{N(N-1)}{2}.\n$$\nEquivalently, this is the number of unordered pairs of distinct indices from $\\{1,2,\\ldots,N\\}$, which is $\\binom{N}{2}$, and evaluates to the same expression $\\frac{N(N-1)}{2}$.", "answer": "$$\\boxed{\\frac{N(N-1)}{2}}$$", "id": "1423352"}, {"introduction": "The class P encompasses not only problems solved by simple iterative algorithms but also those whose solutions can be counted efficiently due to their specific structure. This practice explores a conceptual problem related to Boolean satisfiability, a topic that contains some of the hardest problems in computer science. You will see how a highly constrained version of a typically difficult problem becomes simple to solve, reinforcing the critical idea that a problem's structure, rather than its general family, determines its complexity. [@problem_id:1422786]", "problem": "In computational complexity theory, the problem of counting the number of satisfying assignments for a given Boolean formula, known as #SAT (pronounced 'number-SAT'), serves as a canonical example for the complexity class #P. While solving #SAT for arbitrary formulas is a difficult task, the analysis of specific, structured families of formulas is a foundational exercise.\n\nConsider a family of Boolean formulas, denoted `F_N`, which is parameterized by an integer `N` where `N \\geq 2`. Each formula `F_N` is defined over a set of `N` Boolean variables, `{x_1, x_2, ..., x_N}`.\n\nAn assignment of truth values to these variables is defined as a satisfying assignment for `F_N` if and only if **exactly two** of the `N` variables are assigned the value `True`. All other `N-2` variables must be assigned `False`.\n\nYour task is to calculate the total number of satisfying assignments for the formula `F_N`. Express your answer as a function of `N`.", "solution": "We are asked to count the number of assignments to $N$ Boolean variables $\\{x_{1},x_{2},\\ldots,x_{N}\\}$ such that exactly two variables are assigned $True$ and the remaining $N-2$ are assigned $False$. Any such satisfying assignment is uniquely determined by the choice of which two variables among the $N$ are set to $True$; the rest are then forced to be $False$.\n\nSince the order of choosing the two variables does not matter, the number of such choices is the binomial coefficient $\\binom{N}{2}$. Using the factorial definition of binomial coefficients,\n$$\n\\binom{N}{2}=\\frac{N!}{2!\\,(N-2)!}.\n$$\nSimplifying with $N!/(N-2)! = N(N-1)$ and $2!=2$, we obtain\n$$\n\\binom{N}{2}=\\frac{N(N-1)}{2}.\n$$\nTherefore, the total number of satisfying assignments is $\\binom{N}{2}$ for $N\\geq 2$.", "answer": "$$\\boxed{\\binom{N}{2}}$$", "id": "1422786"}, {"introduction": "Efficient algorithms are not always discovered through straightforward iteration; sometimes, they emerge from elegant mathematical insights. This exercise challenges you to analyze the game of Nim, a classic problem in combinatorial game theory, to find a winning strategy. The solution does not involve brute-force search but rather a clever application of bitwise operations, demonstrating the diverse and often non-intuitive nature of polynomial-time solutions and showcasing how abstract mathematical properties can translate into powerful, fast algorithms. [@problem_id:1422800]", "problem": "In a strategic simulation, two autonomous agents are programmed to play the impartial game of Nim. The game consists of several piles of stones. On each turn, a player must choose one pile and remove at least one stone from it. The number of stones removed can be any amount from one up to the entire pile. The agent who takes the very last stone from the last remaining pile wins the game. This is known as normal play convention.\n\nA \"losing position\" in Nim is a state from which every possible move leads to a \"winning position\" for the other player. Conversely, a \"winning position\" is one from which there is at least one move that leads to a \"losing position\". An agent with an optimal strategy will always move to a losing position if possible.\n\nConsider a game state with four piles of stones. The sizes of the piles are 25, 20, 12, and 5. It is currently one agent's turn to move. To ensure a win, this agent must make a move that leaves the other agent in a losing position. How many distinct moves are available to the current agent to achieve this?\n\nA. 0\n\nB. 1\n\nC. 2\n\nD. 3\n\nE. 4", "solution": "In impartial Nim under normal play, a position is losing if and only if the nim-sum (bitwise xor) of the pile sizes is zero. A move is winning if it results in a position with nim-sum zero.\n\nLet the piles be of sizes $a_{1}=25$, $a_{2}=20$, $a_{3}=12$, $a_{4}=5$. Compute the nim-sum\n$$\nS \\equiv a_{1} \\oplus a_{2} \\oplus a_{3} \\oplus a_{4}.\n$$\nUsing binary representations,\n$$\n25=11001,\\quad 20=10100,\\quad 12=01100,\\quad 5=00101,\n$$\nso\n$$\nS=11001 \\oplus 10100 \\oplus 01100 \\oplus 00101=00100=4.\n$$\nSince $S \\neq 0$, the position is winning, and the winning moves are exactly those that change some $a_{i}$ to\n$$\na_{i}'=a_{i} \\oplus S\n$$\nwith $a_{i}'<a_{i}$. This guarantees the new nim-sum is zero because\n$$\nS' = S \\oplus a_{i} \\oplus a_{i}' = S \\oplus a_{i} \\oplus (a_{i} \\oplus S) = 0.\n$$\nThe condition $a_{i}'<a_{i}$ holds precisely for those piles whose binary expansion has the highest set bit of $S$ set. Here $S=4$ has only the $4$-bit set, so we count piles that contain the $4$-bit:\n- $25=11001$ does not have the $4$-bit set, so no winning move from this pile.\n- $20=10100$ has the $4$-bit; the winning move is $20 \\to 20 \\oplus 4 = 16$.\n- $12=01100$ has the $4$-bit; the winning move is $12 \\to 12 \\oplus 4 = 8$.\n- $5=00101$ has the $4$-bit; the winning move is $5 \\to 5 \\oplus 4 = 1$.\n\nThus, there are exactly $3$ distinct winning moves.\n\nTherefore, the correct choice is D.", "answer": "$$\\boxed{D}$$", "id": "1422800"}]}