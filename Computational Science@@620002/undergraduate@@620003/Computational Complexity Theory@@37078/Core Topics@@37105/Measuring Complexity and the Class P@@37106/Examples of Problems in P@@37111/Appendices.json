{"hands_on_practices": [{"introduction": "Many computational problems involve searching for pairs of elements that satisfy a certain condition. While a brute-force approach of checking every possible pair is straightforward, it is often inefficient. This exercise [@problem_id:1423318] introduces the elegant two-pointer technique, a classic algorithm that demonstrates how exploiting the structure of the input—in this case, a sorted list—can lead to a drastically more efficient, linear-time solution. Mastering this pattern is a first step toward thinking algorithmically about tractability and the nature of the complexity class P.", "problem": "A monitoring service for a distributed database system is designed to check for data corruption. The service periodically receives a batch of checksums from various data nodes. For a particular integrity check, the service needs to determine if any two distinct checksums in a given batch sum up to a specific master key. The checksums are always distinct positive integers and are provided as a sorted list in ascending order.\n\nAn engineer has implemented an efficient algorithm to perform this check. The algorithm is described as follows:\n1. Initialize two pointers: a `start` pointer at the beginning of the list (index 0) and an `end` pointer at the end of the list.\n2. While the `start` pointer is positioned before the `end` pointer, compute the sum of the numbers at the `start` and `end` positions.\n3. If this sum equals the master key, a pair has been found, and the algorithm terminates.\n4. If the sum is less than the master key, move the `start` pointer one position to the right (increment its index).\n5. If the sum is greater than the master key, move the `end` pointer one position to the left (decrement its index).\n6. If the `start` pointer and `end` pointer cross or meet, the algorithm terminates, as no pair has been found.\n\nConsider the following specific scenario:\n- The sorted list of checksums is `L = [3, 8, 11, 14, 19, 21, 26, 30, 33, 39]`.\n- The master key is `K = 44`.\n\nHow many sum computations does the described algorithm perform before it terminates for this specific input?\n\nA. 3\n\nB. 4\n\nC. 5\n\nD. 9\n\nE. 10\n\nF. 45", "solution": "We are given a sorted list `L = [3, 8, 11, 14, 19, 21, 26, 30, 33, 39]` and a target sum (master key) $K=44$. The algorithm initializes two pointers at the ends of the list and in each iteration computes exactly one sum $s=L_{\\text{start}}+L_{\\text{end}}$, then moves one pointer based on whether $s$ is less than or greater than $K$, or terminates if $s=K$. Let $c$ denote the number of sum computations performed.\n\nInitialize $\\text{start}=0$, $\\text{end}=9$, and $c=0$.\n- Iteration 1: Compute $s=L_{0}+L_{9}=3+39=42$. Increment $c \\leftarrow c+1$, so $c=1$. Since $4244$, increment $\\text{start} \\leftarrow 1$.\n- Iteration 2: Compute $s=L_{1}+L_{9}=8+39=47$. Increment $c \\leftarrow c+1$, so $c=2$. Since $47>44$, decrement $\\text{end} \\leftarrow 8$.\n- Iteration 3: Compute $s=L_{1}+L_{8}=8+33=41$. Increment $c \\leftarrow c+1$, so $c=3$. Since $4144$, increment $\\text{start} \\leftarrow 2$.\n- Iteration 4: Compute $s=L_{2}+L_{8}=11+33=44$. Increment $c \\leftarrow c+1$, so $c=4$. Since $44=K$, the algorithm terminates.\n\nTherefore, the algorithm performs exactly $c=4$ sum computations before terminating.", "answer": "$$\\boxed{B}$$", "id": "1423318"}, {"introduction": "Beyond simple lists, many real-world problems can be modeled as networks or graphs. A fundamental question in network analysis is identifying basic structural motifs, such as 'triangles' or 'closed trios'. This practice [@problem_id:1423320] explores a direct, systematic method for finding all such triangles in a graph, illustrating how problems involving complex connectivity can still be solved efficiently in polynomial time. This task serves as a gateway to the vast field of polynomial-time graph algorithms.", "problem": "A social network analytics company, \"SocioGraph Inc.\", models social interactions using an undirected graph where each person is a vertex and a mutual friendship is an edge. The company is developing a feature to identify \"closed trios,\" which are groups of three individuals who are all friends with each other. In graph theory, this structure is known as a triangle or a 3-cycle.\n\nYou have been given the data for a small network of six individuals, labeled with integers from 1 to 6. The set of vertices is $V = \\{1, 2, 3, 4, 5, 6\\}$. The friendships, representing the edges of the graph, are given as the following set of unordered pairs:\n$E = \\{\\{1, 2\\}, \\{1, 3\\}, \\{1, 4\\}, \\{2, 3\\}, \\{2, 5\\}, \\{3, 4\\}, \\{3, 5\\}, \\{4, 6\\}, \\{5, 6\\}\\}$.\n\nYour task is to determine the total number of distinct closed trios (triangles) present in this network. A distinct trio is defined by a unique set of three individuals.", "solution": "A closed trio (triangle) is a 3-vertex set $\\{a,b,c\\} \\subset V$ such that all three edges $\\{a,b\\}$, $\\{a,c\\}$, and $\\{b,c\\}$ belong to $E$. Equivalently, for a fixed vertex $v$, each triangle containing $v$ corresponds to an unordered pair of neighbors of $v$ that are adjacent.\n\nWe can systematically check for triangles by iterating through each vertex and examining the connections between its neighbors. Let $N(v)$ be the set of neighbors of a vertex $v$.\n- For vertex 1, $N(1)=\\{2,3,4\\}$. We check for edges between these neighbors: $\\{2,3\\} \\in E$ and $\\{3,4\\} \\in E$. This gives us two triangles: $\\{1,2,3\\}$ and $\\{1,3,4\\}$.\n- For vertex 2, $N(2)=\\{1,3,5\\}$. We check for edges between these neighbors: $\\{1,3\\} \\in E$ and $\\{3,5\\} \\in E$. This gives us two triangles, but one, $\\{1,2,3\\}$, has already been found. The new one is $\\{2,3,5\\}$.\n- For vertex 3, $N(3)=\\{1,2,4,5\\}$. We check for edges between its neighbors. The pairs $\\{1,2\\}$, $\\{1,4\\}$, and $\\{2,5\\}$ form edges. This confirms the triangles we've already found: $\\{1,2,3\\}$, $\\{1,3,4\\}$, and $\\{2,3,5\\}$.\n- For vertex 4, $N(4)=\\{1,3,6\\}$. The only edge between neighbors is $\\{1,3\\}$, which confirms triangle $\\{1,3,4\\}$.\n- For vertex 5, $N(5)=\\{2,3,6\\}$. The only edge between neighbors is $\\{2,3\\}$, which confirms triangle $\\{2,3,5\\}$.\n- For vertex 6, $N(6)=\\{4,5\\}$. The edge $\\{4,5\\}$ is not in $E$, so no triangle contains vertex 6.\n\nCollecting the unique sets of three vertices that form a triangle, we have: $\\{\\{1,2,3\\}, \\{1,3,4\\}, \\{2,3,5\\}\\}$.\n\nThe total number of distinct closed trios is 3.", "answer": "$$\\boxed{3}$$", "id": "1423320"}, {"introduction": "The principles of efficient computation extend into the abstract realm of formal languages, which form the bedrock of programming language compilers and parsers. Deciding whether a string conforms to a language's grammar is a critical task, and this exercise [@problem_id:1423341] demonstrates a powerful method for doing so: the Cocke-Younger-Kasami (CYK) algorithm. This application of dynamic programming systematically builds a solution from the bottom up, showcasing a sophisticated yet efficient polynomial-time approach to solving a complex recognition problem.", "problem": "In the study of formal languages, a Context-Free Grammar (CFG) provides a set of rules for generating strings in a language. A CFG is in Chomsky Normal Form (CNF) if all its production rules are of the form $A \\to BC$ or $A \\to a$, where $A, B, C$ are non-terminal symbols and $a$ is a terminal symbol.\n\nConsider a CFG, denoted by $G$, which is defined by the following components:\n- Non-terminal symbols: $\\{S, A, B, C\\}$\n- Terminal symbols: $\\{a, b\\}$\n- Start symbol: $S$\n- Production rules:\n    1. $S \\to AB$\n    2. $A \\to BA$\n    3. $A \\to a$\n    4. $B \\to CC$\n    5. $B \\to b$\n    6. $C \\to AB$\n    7. $C \\to a$\n\nDetermine which of the following strings can be generated by the grammar $G$.\n\nA. `aba`\n\nB. `baba`\n\nC. `aaab`\n\nD. `abaa`", "solution": "To determine if a string can be generated by a context-free grammar in Chomsky Normal Form (CNF), we can use the Cocke-Younger-Kasami (CYK) algorithm. This algorithm uses dynamic programming to fill a table that tells us which non-terminals can generate which substrings of the given string.\n\nLet the input string be $w = w_1 w_2 \\dots w_n$ of length $n$. We construct an $n \\times n$ table, $P$, where the entry $P[i,j]$ contains the set of non-terminal symbols that can generate the substring $w_i \\dots w_j$. The string $w$ is in the language of the grammar if and only if the start symbol $S$ is in the entry $P[1,n]$.\n\nThe table is filled for substrings of increasing length, $l$, from $1$ to $n$.\nFor $l=1$, the entries $P[i,i]$ (the diagonal) are filled with all non-terminals $A$ for which there is a rule $A \\to w_i$.\nFor $l > 1$, the entries $P[i,j]$ (where $j=i+l-1$) are filled by considering all possible splits of the substring $w_i \\dots w_j$ into two non-empty parts, $w_i \\dots w_k$ and $w_{k+1} \\dots w_j$, for $k$ from $i$ to $j-1$. A non-terminal $A$ is added to $P[i,j]$ if there is a production rule $A \\to BC$ and non-terminals $B \\in P[i,k]$ and $C \\in P[k+1,j]$ for some split point $k$.\n\nWe will test the string from option C, `aaab`. Here, $n=4$, so we need a $4 \\times 4$ table.\nThe string is $w_1=a, w_2=a, w_3=a, w_4=b$.\n\nThe grammar rules are:\n$S \\to AB$\n$A \\to BA | a$\n$B \\to CC | b$\n$C \\to AB | a$\n\n**Step 1: Substrings of length $l=1$**\nThis corresponds to the diagonal of the table, $P[i,i]$. We look for rules of the form $X \\to w_i$.\n- $P[1,1]$ (for $w_1 = a$): Rules are $A \\to a$ and $C \\to a$. So, $P[1,1] = \\{A, C\\}$.\n- $P[2,2]$ (for $w_2 = a$): Rules are $A \\to a$ and $C \\to a$. So, $P[2,2] = \\{A, C\\}$.\n- $P[3,3]$ (for $w_3 = a$): Rules are $A \\to a$ and $C \\to a$. So, $P[3,3] = \\{A, C\\}$.\n- $P[4,4]$ (for $w_4 = b$): Rule is $B \\to b$. So, $P[4,4] = \\{B\\}$.\n\n**Step 2: Substrings of length $l=2$**\n- $P[1,2]$ (for $w_1w_2 = aa$): Split at $k=1$. We check pairs from $P[1,1]P[2,2] = \\{A,C\\}\\{A,C\\}$. The possible pairs are $AA, AC, CA, CC$. The rule $B \\to CC$ exists. So, $P[1,2] = \\{B\\}$.\n- $P[2,3]$ (for $w_2w_3 = aa$): Split at $k=2$. We check pairs from $P[2,2]P[3,3] = \\{A,C\\}\\{A,C\\}$. The rule $B \\to CC$ exists. So, $P[2,3] = \\{B\\}$.\n- $P[3,4]$ (for $w_3w_4 = ab$): Split at $k=3$. We check pairs from $P[3,3]P[4,4] = \\{A,C\\}\\{B\\}$. The possible pairs are $AB, CB$. Rules $S \\to AB$ and $C \\to AB$ exist. So, $P[3,4] = \\{S,C\\}$.\n\n**Step 3: Substrings of length $l=3$**\n- $P[1,3]$ (for $w_1w_2w_3 = aaa$):\n  - Split at $k=1$: $P[1,1]P[2,3] = \\{A,C\\}\\{B\\}$. Pairs $AB, CB$. Rules $S \\to AB$ and $C \\to AB$ exist.\n  - Split at $k=2$: $P[1,2]P[3,3] = \\{B\\}\\{A,C\\}$. Pairs $BA, BC$. Rule $A \\to BA$ exists.\n  - Combining these, we get $P[1,3] = \\{S, C, A\\}$.\n- $P[2,4]$ (for $w_2w_3w_4 = aab$):\n  - Split at $k=2$: $P[2,2]P[3,4] = \\{A,C\\}\\{S,C\\}$. Pairs $AS, AC, CS, CC$. Rule $B \\to CC$ exists.\n  - Split at $k=3$: $P[2,3]P[4,4] = \\{B\\}\\{B\\}$. Pair $BB$. No rule.\n  - So, $P[2,4] = \\{B\\}$.\n\n**Step 4: Substrings of length $l=4$**\n- $P[1,4]$ (for $w_1w_2w_3w_4 = aaab$):\n  - Split at $k=1$: $P[1,1]P[2,4] = \\{A,C\\}\\{B\\}$. Pairs $AB, CB$. Rules $S \\to AB$ and $C \\to AB$ exist.\n  - Split at $k=2$: $P[1,2]P[3,4] = \\{B\\}\\{S,C\\}$. Pairs $BS, BC$. No rules.\n  - Split at $k=3$: $P[1,3]P[4,4] = \\{S,C,A\\}\\{B\\}$. Pairs $SB, CB, AB$. Rules $S \\to AB$ and $C \\to AB$ exist.\n  - Combining all results, $P[1,4] = \\{S, C\\}$.\n\nThe CYK table for 'aaab' would look like this:\n| $i \\setminus j$ | 1       | 2       | 3             | 4         |\n| :---: |:-------:|:-------:|:-------------:|:---------:|\n| **1** | {A,C}   | {B}     | {S,C,A}       | {S,C}     |\n| **2** |         | {A,C}   | {B}           | {B}       |\n| **3** |         |         | {A,C}         | {S,C}     |\n| **4** |         |         |               | {B}       |\n\nSince the start symbol $S$ is in the top-right cell $P[1,4]$, the string `aaab` can be generated by the grammar $G$.\n\nA similar analysis for the other strings would show that the start symbol $S$ does not appear in the final cell $P[1,n]$ for any of them. For instance, for string `aba`, $P[1,3]=\\{B\\}$, which does not contain $S$. For `baba`, $P[1,4]=\\{B\\}$. For `abaa`, $P[1,4]=\\{A\\}$. Therefore, none of the other strings can be generated by the grammar.", "answer": "$$\\boxed{C}$$", "id": "1423341"}]}