{"hands_on_practices": [{"introduction": "The Horn-satisfiability problem is decidable in polynomial time using an elegant and efficient marking algorithm. This exercise provides a practical scenario to help you build an intuition for how this algorithm works. By manually tracing the propagation of truth values through a set of logical rules, you will see how the system reaches a stable, minimal satisfying assignment in a step-by-step fashion [@problem_id:1427138].", "problem": "A system for managing software feature activation is defined by the state of six boolean features, represented by variables $x_1, x_2, x_3, x_4, x_5, x_6$. A value of 1 for a variable indicates the corresponding feature is `ON`, while a value of 0 means it is `OFF`.\n\nThe system's state is determined by an iterative activation algorithm that applies a set of rules. The process is as follows:\n1.  Initially, all features are set to `OFF` (all variables are 0).\n2.  The system then applies a set of activation rules. This is done in rounds. In each round, the algorithm checks every rule. If the prerequisites for a rule are met by the current set of `ON` features, the rule's target feature is turned `ON` (its variable is set to 1).\n3.  This process of applying rules in rounds continues until a full round completes with no new features being turned `ON`.\n\nThe activation rules for the system are:\n- **Rule 1:** Feature 1 is `ON`.\n- **Rule 2:** Feature 2 is `ON`.\n- **Rule 3:** If Feature 1 is `ON`, then Feature 3 is turned `ON`.\n- **Rule 4:** If Feature 3 and Feature 4 are `ON`, then Feature 5 is turned `ON`.\n- **Rule 5:** If Feature 5 is `ON`, then Feature 6 is turned `ON`.\n- **Rule 6:** If Feature 2 and Feature 6 are `ON`, then Feature 4 is turned `ON`.\n\nWhat is the final state of the features upon completion of the algorithm? The state should be represented as a vector $(x_1, x_2, x_3, x_4, x_5, x_6)$.\n\nA. (1, 1, 0, 0, 0, 0)\n\nB. (1, 1, 1, 0, 0, 0)\n\nC. (1, 1, 1, 1, 0, 0)\n\nD. (1, 1, 1, 1, 1, 1)\n\nE. (1, 0, 1, 0, 0, 0)", "solution": "We formalize the rules as implications over boolean variables $x_{1},\\dots,x_{6}$:\n- Rule 1: $x_{1}=1$.\n- Rule 2: $x_{2}=1$.\n- Rule 3: $x_{1}=1 \\Rightarrow x_{3}=1$.\n- Rule 4: $(x_{3}=1) \\land (x_{4}=1) \\Rightarrow x_{5}=1$.\n- Rule 5: $x_{5}=1 \\Rightarrow x_{6}=1$.\n- Rule 6: $(x_{2}=1) \\land (x_{6}=1) \\Rightarrow x_{4}=1$.\n\nThe algorithm starts from the all-zero state and repeatedly applies these implications until no new variables turn to $1$ in a full round. Let the state after round $t$ be denoted by $x^{(t)}=(x_{1}^{(t)},x_{2}^{(t)},x_{3}^{(t)},x_{4}^{(t)},x_{5}^{(t)},x_{6}^{(t)})$.\n\nInitialization gives\n$$\nx^{(0)}=(0,0,0,0,0,0).\n$$\n\nRound 1:\n- By Rule 1 and Rule 2, we set $x_{1}^{(1)}=1$ and $x_{2}^{(1)}=1$.\n- With $x_{1}^{(1)}=1$, Rule 3 applies, so $x_{3}^{(1)}=1$.\n- Rule 4 requires both $x_{3}=1$ and $x_{4}=1$, but $x_{4}^{(1)}=0$, so it does not apply.\n- Rule 5 requires $x_{5}=1$, which is not satisfied, so it does not apply.\n- Rule 6 requires $x_{2}=1$ and $x_{6}=1$, but $x_{6}^{(1)}=0$, so it does not apply.\nTherefore, at the end of Round 1,\n$$\nx^{(1)}=(1,1,1,0,0,0).\n$$\n\nRound 2:\n- Rules 1, 2, and 3 are already satisfied and make no changes beyond $x_{1}=1$, $x_{2}=1$, $x_{3}=1$.\n- Rule 4 still fails because it needs $x_{4}=1$ in addition to $x_{3}=1$, but $x_{4}=0$.\n- Rule 5 still fails because it needs $x_{5}=1$, which is false.\n- Rule 6 still fails because it needs $x_{6}=1$, which is false.\nNo new features are turned on in this round, so the algorithm terminates.\n\nThus the final state is\n$$\n(x_{1},x_{2},x_{3},x_{4},x_{5},x_{6})=(1,1,1,0,0,0),\n$$\nwhich corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1427138"}, {"introduction": "The efficiency of the Horn-SAT algorithm comes from the specific structure of Horn clauses, which allow for directed logical inference. But what happens if we try to apply the algorithm to a formula that violates this structure? This thought experiment demonstrates the limitations of the marking algorithm, revealing why the presence of a non-Horn clause, such as $(v_1 \\lor v_2)$, can lead to an incorrect result and highlighting the precise boundary where satisfiability becomes computationally hard [@problem_id:1427136].", "problem": "In computational logic, a Boolean formula is in Conjunctive Normal Form (CNF) if it is a conjunction (AND, $\\land$) of one or more clauses, where a clause is a disjunction (OR, $\\lor$) of literals. A literal is either a variable (a positive literal, e.g., $x$) or its negation (a negative literal, e.g., $\\neg x$). A Horn clause is a clause with at most one positive literal. For instance, $(\\neg v_1 \\lor \\neg v_2 \\lor v_3)$ and $(\\neg v_1 \\lor \\neg v_2)$ are Horn clauses, but $(v_1 \\lor v_2)$ is not. The Horn-Satisfiability (Horn-SAT) problem, which is solvable in polynomial time, involves determining if a formula consisting entirely of Horn clauses is satisfiable.\n\nA standard algorithm for Horn-SAT is the marking algorithm. Consider the following specific implementation of this algorithm:\n1.  Initialize an empty set, `marked_vars`, which will store variables determined to be TRUE.\n2.  For every \"unit clause\" of the form $(h)$ in the formula, add the variable $h$ to `marked_vars`.\n3.  Repeat the following until no new variables can be added to `marked_vars` in a full pass:\n    For each clause of the form $(\\neg l_1 \\lor \\neg l_2 \\lor \\dots \\lor \\neg l_k \\lor h)$, if the variables corresponding to all negative literals $l_1, l_2, \\dots, l_k$ are already in `marked_vars`, add the variable $h$ to `marked_vars`.\n4.  After the loop terminates, a potential satisfying assignment is proposed: all variables in `marked_vars` are set to TRUE, and all other variables are set to FALSE.\n5.  Finally, a consistency check is performed. For every clause consisting of only negative literals, such as $(\\neg l_1 \\lor \\neg l_2 \\lor \\dots \\lor \\neg l_k)$, if all variables $l_1, l_2, \\dots, l_k$ are in `marked_vars`, the algorithm reports the formula is UNSATISFIABLE. Otherwise, it outputs the proposed assignment from step 4.\n\nNow, consider the following Boolean formula $\\phi$, which contains a mix of Horn and non-Horn clauses:\n$$ \\phi = (v_1 \\lor v_2) \\land (\\neg v_1 \\lor v_3) \\land (\\neg v_2) $$\nWhat is the outcome when the marking algorithm described above is applied to the formula $\\phi$?\n\nA. The algorithm marks variables $v_1$ and $v_3$, proposes the assignment $(v_1, v_2, v_3) = (\\text{TRUE}, \\text{FALSE}, \\text{TRUE})$, and this assignment correctly satisfies $\\phi$.\n\nB. The algorithm fails to mark any variables, proposes the assignment $(v_1, v_2, v_3) = (\\text{FALSE}, \\text{FALSE}, \\text{FALSE})$, and this assignment fails to satisfy the clause $(v_1 \\lor v_2)$.\n\nC. The algorithm uses the clause $(\\neg v_2)$ to infer that $v_2$ must be FALSE, marks $v_1$ and $v_3$, and proposes the correct satisfying assignment.\n\nD. The algorithm fails to mark any variables, and because the clause $(\\neg v_2)$ exists, it reports that the formula is UNSATISFIABLE during the consistency check.\n\nE. The algorithm cannot process the non-Horn clause $(v_1 \\lor v_2)$ and therefore enters an infinite loop.", "solution": "Let the clauses of $\\phi$ be labeled as follows:\n$$C_{1}=(v_{1}\\lor v_{2}),\\quad C_{2}=(\\neg v_{1}\\lor v_{3}),\\quad C_{3}=(\\neg v_{2}).$$\nStep 1 initializes $\\mathrm{marked\\_vars}=\\varnothing$.\n\nIn Step 2, only unit clauses of the form $(h)$ add a variable $h$ to $\\mathrm{marked\\_vars}$. The clause $C_{3}$ is $(\\neg v_{2})$, which is not of the form $(h)$, and there is no positive unit clause in $\\phi$. Therefore, no variable is added and $\\mathrm{marked\\_vars}=\\varnothing$.\n\nIn Step 3, we iterate over clauses of the form $(\\neg l_{1}\\lor\\dots\\lor\\neg l_{k}\\lor h)$ and add $h$ if all $l_{i}$ are already in $\\mathrm{marked\\_vars}$. The clause $C_{2}$ matches this form with $k=1$, $l_{1}=v_{1}$, and $h=v_{3}$, but the condition requires $v_{1}\\in\\mathrm{marked\\_vars}$, which is false. The clause $C_{1}$ does not match the required form (it is not Horn of implication type), and $C_{3}$ has no positive head $h$. Hence, no new variables are added in a full pass, and the loop terminates with $\\mathrm{marked\\_vars}=\\varnothing$.\n\nIn Step 4, the proposed assignment sets all variables in $\\mathrm{marked\\_vars}$ to TRUE and all others to FALSE, yielding $(v_{1},v_{2},v_{3})=(\\text{FALSE},\\text{FALSE},\\text{FALSE})$.\n\nIn Step 5, the consistency check inspects clauses containing only negative literals. The only such clause is $C_{3}=(\\neg v_{2})$. The algorithm reports UNSAT only if all variables in such a clause are in $\\mathrm{marked\\_vars}$. Since $v_{2}\\notin\\mathrm{marked\\_vars}$, no UNSAT is reported, and the algorithm outputs the proposed assignment.\n\nFinally, we verify whether the proposed assignment satisfies $\\phi$. Evaluate $C_{1}$ under $(v_{1},v_{2})=(\\text{FALSE},\\text{FALSE})$:\n$$(v_{1}\\lor v_{2})=\\text{FALSE}\\lor\\text{FALSE}=\\text{FALSE}.$$\nThus the assignment fails to satisfy $\\phi$. This behavior corresponds exactly to option B.", "answer": "$$\\boxed{B}$$", "id": "1427136"}, {"introduction": "A hallmark of a powerful algorithm is its ability to serve as a building block for solving other complex problems. This problem challenges you to think like a complexity theorist by designing a new algorithm for a related query: can a specific variable be $\\text{TRUE}$ in *any* satisfying assignment? You will see how to solve this HORN-EXIST-TRUE problem by cleverly reducing it to the standard Horn-SAT problem you already know how to solve, a common and powerful technique in algorithm design [@problem_id:1427111].", "problem": "In the field of artificial intelligence, knowledge bases are often constructed from a set of logical rules. A particularly efficient and expressive class of rules can be modeled using Horn clauses. Consider a medical diagnostic system that uses such a knowledge base. The system's state is described by a set of propositional variables, where each variable might represent a symptom (e.g., `has_fever`) or a diagnosis (e.g., `has_flu`).\n\nLet's formally define the components:\n- A **literal** is a propositional variable (a positive literal, e.g., $x$) or its negation (a negative literal, e.g., $\\neg x$).\n- A **Horn clause** is a disjunction of literals containing at most one positive literal. Examples of Horn clauses and their common logical equivalences are:\n    1. A definite clause: $\\neg p_1 \\lor \\neg p_2 \\lor \\dots \\lor \\neg p_k \\lor q$, which is equivalent to $(p_1 \\land p_2 \\land \\dots \\land p_k) \\rightarrow q$. This represents a rule, e.g., \"If a patient has a fever and a cough, then they might have the flu.\"\n    2. A negative clause: $\\neg p_1 \\lor \\neg p_2 \\lor \\dots \\lor \\neg p_k$, which is equivalent to $(p_1 \\land p_2 \\land \\dots \\land p_k) \\rightarrow \\text{FALSE}$. This represents a constraint, e.g., \"A patient cannot have both Disease A and Disease B.\"\n    3. A fact: $q$, which is equivalent to $\\text{TRUE} \\rightarrow q$. This represents an observed fact, e.g., \"The patient has a fever.\"\n- A **Horn formula** $\\Phi$ is a conjunction (AND) of Horn clauses.\n- A **satisfying assignment** is a truth value assignment (TRUE/FALSE) to all variables that makes the entire formula $\\Phi$ evaluate to TRUE.\n\nA crucial query for the diagnostic system is to determine if a particular diagnosis is logically possible. Given a Horn formula $\\Phi$ representing the entire knowledge base and a specific variable $x$ representing a potential diagnosis, a developer needs an algorithm to solve the **HORN-EXIST-TRUE** problem: determine if there exists *any* satisfying assignment for $\\Phi$ in which the variable $x$ is assigned the value TRUE.\n\nWhich of the following statements correctly describes a polynomial-time method to solve the HORN-EXIST-TRUE problem for a given Horn formula $\\Phi$ and a variable $x$?\n\nA. The problem is equivalent to checking the satisfiability of $\\Phi$. If $\\Phi$ has any satisfying assignment, then for any variable $v$, there must exist some satisfying assignment where $v$ is TRUE.\n\nB. Find the minimal satisfying assignment for $\\Phi$ using the standard linear-time Horn-SAT algorithm. The variable $x$ can be set to TRUE in a satisfying assignment if and only if $x$ is assigned TRUE in this minimal assignment.\n\nC. Modify the formula $\\Phi$ by adding the clause $(\\neg x)$ and check if the resulting formula is satisfiable. If it is unsatisfiable, then it is possible to set $x$ to TRUE.\n\nD. The problem is NP-complete, a known hard variant of the general Boolean Satisfiability Problem (SAT), and thus no polynomial-time algorithm is believed to exist.\n\nE. Modify the formula $\\Phi$ by adding the clause $(x)$ to form a new formula $\\Phi'$. It is possible to satisfy $\\Phi$ with $x$ as TRUE if and only if this new formula $\\Phi'$ is satisfiable.", "solution": "The problem asks for a polynomial-time algorithm to determine if a variable $x$ can be set to TRUE in any satisfying assignment of a given Horn formula $\\Phi$. This is the HORN-EXIST-TRUE problem. We need to evaluate the proposed methods. The key is to relate this problem to the standard Horn Satisfiability (Horn-SAT) problem, which is known to be solvable in polynomial time (in fact, linear time).\n\nLet's analyze the relationship between HORN-EXIST-TRUE($\\Phi, x$) and Horn-SAT. We are looking for an assignment $A$ such that $A$ satisfies $\\Phi$ (written as $A \\models \\Phi$) and $A(x) = \\text{TRUE}$.\n\nConsider the proposal in option E. We construct a new formula $\\Phi' = \\Phi \\land (x)$.\nFirst, we observe that $\\Phi'$ is also a Horn formula. The original formula $\\Phi$ is a conjunction of Horn clauses. The new clause $(x)$ is a Horn clause itself (it contains exactly one positive literal and zero negative literals, equivalent to $\\text{TRUE} \\rightarrow x$). The conjunction of Horn clauses results in a Horn formula. Since Horn-SAT is solvable in polynomial time, checking the satisfiability of $\\Phi'$ can be done in polynomial time.\n\nNow, we must prove that this approach is correct. That is, we must show that \"there exists a satisfying assignment for $\\Phi$ with $x=\\text{TRUE}$\" if and only if \"$\\Phi'$ is satisfiable\".\n\n**Part 1: (⇒) Assume there exists a satisfying assignment for $\\Phi$ with $x=\\text{TRUE}$.**\nLet this assignment be $A$. By definition, we have:\n1. $A \\models \\Phi$ (A satisfies $\\Phi$)\n2. $A(x) = \\text{TRUE}$\n\nWe want to show that $\\Phi'$ is satisfiable. An assignment satisfies a conjunction if it satisfies every part of the conjunction.\nThe formula is $\\Phi' = \\Phi \\land (x)$.\n- Does $A$ satisfy $\\Phi$? Yes, by assumption (1).\n- Does $A$ satisfy the clause $(x)$? Yes, because an assignment satisfies a single-literal clause if it assigns that literal the value TRUE, and we know from (2) that $A(x) = \\text{TRUE}$.\nSince $A$ satisfies both $\\Phi$ and $(x)$, it is a satisfying assignment for their conjunction, $\\Phi'$. Therefore, $\\Phi'$ is satisfiable.\n\n**Part 2: (⇐) Assume $\\Phi' = \\Phi \\land (x)$ is satisfiable.**\nBy definition, this means there exists an assignment, let's call it $A'$, such that $A' \\models \\Phi'$.\nSince $A'$ satisfies the conjunction $\\Phi \\land (x)$, it must satisfy each part:\n1. $A' \\models \\Phi$\n2. $A' \\models (x)$\n\nFrom (2), for $A'$ to satisfy the clause $(x)$, it must be that $A'(x) = \\text{TRUE}$.\nFrom (1), we know that this same assignment $A'$ is a satisfying assignment for the original formula $\\Phi$.\nSo, we have found an assignment, namely $A'$, which satisfies $\\Phi$ and in which $x$ is assigned TRUE. This is precisely what the HORN-EXIST-TRUE problem asks for.\n\nThis establishes that checking the satisfiability of $\\Phi' = \\Phi \\land (x)$ is a correct, polynomial-time method for solving HORN-EXIST-TRUE($\\Phi, x$). Therefore, option E is correct.\n\nLet's briefly analyze why the other options are incorrect:\n- **A**: This is false. A formula can be satisfiable, yet some variables might be forced to be FALSE in all satisfying assignments. For example, $\\Phi = (x \\rightarrow \\text{FALSE})$ is a Horn formula (equivalent to $\\neg x$). It is satisfied by setting $x=\\text{FALSE}$. There is no satisfying assignment where $x=\\text{TRUE}$.\n- **B**: This is incorrect. The standard Horn-SAT algorithm finds the *minimal satisfying assignment*, where the set of TRUE variables is the smallest possible. This assignment tells us which variables *must* be TRUE in any satisfying assignment. A variable $x$ could be FALSE in the minimal model but could be set to TRUE in other, non-minimal satisfying assignments. For example, consider $\\Phi = (p \\rightarrow q)$. The minimal model is $\\{p=\\text{FALSE}, q=\\text{FALSE}\\}$. Here, $p$ is FALSE. However, the assignment $\\{p=\\text{TRUE}, q=\\text{TRUE}\\}$ also satisfies $\\Phi$. So, it is possible for $p$ to be true, even though it's false in the minimal model.\n- **C**: Modifying $\\Phi$ by adding $(\\neg x)$ tests the wrong property. $(\\neg x)$ is equivalent to $(x \\rightarrow \\text{FALSE})$, which is a Horn clause. The formula $\\Phi \\land (\\neg x)$ is satisfiable if and only if there's a satisfying assignment for $\\Phi$ where $x$ is FALSE. The option suggests that if this new formula is *unsatisfiable*, then it's possible to set $x$ to TRUE. This means that *every* satisfying assignment of $\\Phi$ must have $x=\\text{TRUE}$. This answers the question \"must $x$ be true?\", not \"can $x$ be true?\".\n- **D**: This is incorrect. As shown, the problem reduces in polynomial time to Horn-SAT, which is a classic problem in the complexity class P (solvable in polynomial time). Therefore, HORN-EXIST-TRUE is also in P, not NP-complete.\n\nBased on this analysis, option E provides the correct and computationally efficient method.", "answer": "$$\\boxed{E}$$", "id": "1427111"}]}