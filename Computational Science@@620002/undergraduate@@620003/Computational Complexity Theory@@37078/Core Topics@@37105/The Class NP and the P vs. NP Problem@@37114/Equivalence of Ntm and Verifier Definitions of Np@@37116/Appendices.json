{"hands_on_practices": [{"introduction": "The equivalence between verifiers and Nondeterministic Turing Machines (NTMs) hinges on a powerful idea: an NTM's ability to 'guess' can be used to generate the very certificate a verifier needs. This first exercise [@problem_id:1422203] explores the mechanics of this 'guess-and-verify' construction. By considering a verifier that requires two independent certificates, you will formalize how an NTM can nondeterministically produce a witness and then deterministically check its validity, a fundamental skill in translating between the two core definitions of $\\mathrm{NP}$.", "problem": "In computational complexity theory, the class NP can be defined in two equivalent ways: either as the set of languages decidable by a polynomial-time Nondeterministic Turing Machine (NTM), or as the set of languages that have a polynomial-time verifier.\n\nConsider a language $L$ over the alphabet $\\{0,1\\}$. A deterministic Turing machine $V$ acts as a verifier for $L$. For an input string $x$, the verifier $V$ takes two additional strings, $c_1$ and $c_2$, called certificates. The language $L$ is defined as the set of all strings $x$ for which there exist certificates $c_1$ and $c_2$ such that $V(x, c_1, c_2)$ accepts.\n\nWe are given the following properties:\n1.  The verifier $V$ always halts in time polynomial in the length of the input string $x$. Let this runtime be bounded by $T(|x|)$, where $T$ is a polynomial.\n2.  For any $x \\in L$, there exist certificates $c_1$ and $c_2$ such that $V(x, c_1, c_2)$ accepts, and the lengths of these certificates are bounded by polynomials in the length of $x$. Specifically, $|c_1| \\le p(|x|)$ and $|c_2| \\le q(|x|)$, where $p$ and $q$ are polynomials.\n\nBased on the equivalence between the verifier and NTM definitions of NP, an NTM, let's call it $N$, can be constructed to decide the language $L$. Which of the following options correctly describes the high-level algorithm for the NTM $N$ that decides $L$ on a given input $x$?\n\nA. The NTM $N$ nondeterministically writes a string of length at most $p(|x|)$ on its work tape, a special separator symbol, and then another string of length at most $q(|x|)$. It then deterministically simulates the verifier $V$ using the input $x$ and these two guessed strings as $c_1$ and $c_2$. $N$ accepts if and only if the simulation of $V$ accepts.\n\nB. The NTM $N$ nondeterministically writes a single string $c$ of length at most $p(|x|) + q(|x|)$ on its work tape. It then splits $c$ exactly in half to obtain two strings, which it uses as $c_1$ and $c_2$ to run a simulation of $V(x, c_1, c_2)$. $N$ accepts if and only if this simulation accepts.\n\nC. The NTM $N$ spawns two independent nondeterministic computations. One path guesses a certificate $c_1$ of length at most $p(|x|)$ and simulates $V(x, c_1, \\epsilon)$, where $\\epsilon$ is the empty string. The other path guesses a certificate $c_2$ of length at most $q(|x|)$ and simulates $V(x, \\epsilon, c_2)$. $N$ accepts if at least one of these computations accepts.\n\nD. The NTM $N$ deterministically searches through all possible pairs of certificates $(c_1, c_2)$ where $|c_1| \\le p(|x|)$ and $|c_2| \\le q(|x|)$. For each pair, it simulates $V(x, c_1, c_2)$. $N$ accepts if any of these simulations accept within a polynomial time limit.\n\nE. The NTM $N$ nondeterministically guesses a single certificate $c_1$ of length at most $p(|x|)$ and simulates the verifier as $V(x, c_1, c_1)$, using the same string for both required certificates. $N$ accepts if and only if this simulation accepts.", "solution": "The problem asks for the construction of a Nondeterministic Turing Machine (NTM) $N$ that decides a language $L$ defined by a verifier $V$ which takes two independent certificates, $c_1$ and $c_2$.\n\nThe definition of the language $L$ is:\n$$L = \\{x \\in \\{0,1\\}^* \\mid \\exists c_1, c_2 \\text{ such that } |c_1| \\le p(|x|), |c_2| \\le q(|x|), \\text{ and } V(x, c_1, c_2) \\text{ accepts}\\}$$\nHere, $V$ is a deterministic polynomial-time verifier, and $p, q$ are polynomials bounding the certificate lengths.\n\nAn NTM decides a language $L$ if for any input $x \\in L$, there is at least one computational path that accepts, and for any $x \\notin L$, all computational paths reject. The runtime of the NTM must be polynomial in $|x|$.\n\nThe standard construction to prove the equivalence of the verifier and NTM definitions of NP involves using the nondeterministic capability of the NTM to \"guess\" the certificate and then using its deterministic capability to run the verifier on the guessed certificate. We adapt this construction for the case of two certificates.\n\nThe NTM $N$ will work in two stages on an input $x$:\n\n**Stage 1: The Guessing Stage (Nondeterministic)**\nThe core task of this stage is to produce the required witness, which in this problem is the pair of certificates $(c_1, c_2)$. Since an NTM traditionally writes a single string on its work tape in a nondeterministic fashion, the NTM must guess a single string that encodes both $c_1$ and $c_2$. A robust and general way to do this is to concatenate them with a special separator symbol that is not in the alphabet of the certificates (or to use some other unambiguous encoding).\n\nThe NTM will:\n1.  Nondeterministically write a sequence of bits intended to be $c_1$. The machine makes a nondeterministic choice at each step whether to write a 0, a 1, or to stop writing $c_1$. This process is bounded to generate a string of length at most $p(|x|)$.\n2.  Write a special separator symbol, '#', on the tape.\n3.  Nondeterministically write a second sequence of bits intended to be $c_2$. This process is bounded to generate a string of length at most $q(|x|)$.\n\nThe total length of the string written on the tape is at most $p(|x|) + 1 + q(|x|)$, which is polynomial in $|x|$. This guessing stage takes polynomial time.\n\n**Stage 2: The Verification Stage (Deterministic)**\nAfter the guessing stage, the NTM transitions to a fully deterministic mode for the remainder of this computational path.\n1.  The NTM scans the string it just wrote on its work tape. It parses the string into two parts using the '#' separator, identifying $c_1$ and $c_2$.\n2.  It then simulates the deterministic verifier machine $V$. The simulation is performed on the input $(x, c_1, c_2)$, where $x$ is the original input to the NTM, and $c_1, c_2$ are the strings just guessed and parsed.\n3.  If the simulation of $V$ accepts, the NTM $N$ enters an accepting state. If the simulation of $V$ rejects, the NTM $N$ enters a rejecting state.\n\n**Correctness and Time Complexity Analysis:**\n-   **If $x \\in L$:** By definition, there exists at least one pair of certificates $(c_1^*, c_2^*)$ that causes $V$ to accept. The nondeterministic nature of the NTM ensures that there is a computational path where it guesses exactly $c_1 = c_1^*$ and $c_2 = c_2^*$. On this path, the deterministic verification stage will simulate $V(x, c_1^*, c_2^*)$, which will accept. Therefore, the NTM $N$ will accept.\n-   **If $x \\notin L$:** By definition, for all possible pairs of certificates $(c_1, c_2)$ within the allowed length bounds, $V(x, c_1, c_2)$ rejects. This means no matter what strings the NTM guesses in Stage 1, the subsequent simulation of $V$ in Stage 2 will reject. Thus, all computational paths of $N$ will reject, and the NTM $N$ correctly rejects.\n-   **Time Complexity:** The guessing stage takes $O(p(|x|) + q(|x|))$ time. The simulation of $V$ runs in time polynomial in the size of its total input, which is $|x|+|c_1|+|c_2|$. Since $|c_1|$ and $|c_2|$ are bounded by polynomials in $|x|$, the simulation time is also polynomial in $|x|$. The sum of two polynomials is a polynomial, so the entire process for NTM $N$ runs in polynomial time.\n\nNow, let's evaluate the given options:\n\n-   **A:** This option accurately describes the two-stage \"guess-and-verify\" process. It correctly handles the two independent certificates by guessing them sequentially (separated by a symbol) and then simulating the verifier. This matches our derived construction.\n\n-   **B:** This option is incorrect because it assumes the two certificates can be obtained by splitting a larger certificate exactly in half. This would fail if the required polynomial bounds are different (i.e., $p(|x|) \\neq q(|x|)$) or even if they are the same but the specific required certificates have different lengths. For example, if $x$ requires $c_1$ of length 5 and $c_2$ of length 10, this method could never find them.\n\n-   **C:** This option is fundamentally flawed. The language definition requires the *simultaneous* existence of a $c_1$ and a $c_2$ that work *together*. This option tests for the existence of a $c_1$ that works with an empty $c_2$, OR a $c_2$ that works with an empty $c_1$. This is a different logical condition and defines a different language.\n\n-   **D:** This option describes a *deterministic* algorithm, not a nondeterministic one. It is essentially brute-forcing the certificate space. While this would correctly decide the language, the number of possible certificates is exponential in $|x|$, so this algorithm would run in exponential time, not polynomial time. This describes a machine for a language in EXPTIME, not NP.\n\n-   **E:** This option wrongly assumes that the two certificates must be identical ($c_1 = c_2$). The problem states a verifier that takes two certificates, which are independent unless stated otherwise. This approach is not general enough to decide $L$.\n\nTherefore, option A provides the correct and general construction for the NTM $N$.", "answer": "$$\\boxed{A}$$", "id": "1422203"}, {"introduction": "Turning the tables, we now examine the other direction of the equivalence: constructing a verifier for a language decided by an NTM. The key is to define a certificate that acts as a 'proof' of an accepting computation. In this problem [@problem_id:1422200], you will analyze the efficiency of a verifier that checks a specific type of proof—a full transcript of the NTM's configurations. This hands-on analysis highlights how the structure of the certificate and the limitations of the verifier's own computational model (a single-tape Turing machine) directly influence the verification's time complexity.", "problem": "In computational complexity theory, the complexity class NP (Nondeterministic Polynomial time) can be defined in two equivalent ways. One definition states that a language $L$ is in NP if there exists a Nondeterministic Turing Machine (NTM) that decides $L$ in time bounded by a polynomial in the input size. Let's say for an input $x$ of size $n = |x|$, this NTM runs for a maximum of $p(n)$ steps on any computational branch, where $p$ is a polynomial.\n\nThe second definition states that a language $L$ is in NP if there exists a deterministic polynomial-time Turing machine $V$, called a verifier, and a polynomial $q$ such that for any input string $x$:\n$x \\in L \\iff \\text{there exists a certificate string } c \\text{ with } |c| \\le q(|x|) \\text{ such that } V(x, c) \\text{ accepts.}$\n\nIn the standard proof showing that the NTM definition implies the verifier definition, the certificate $c$ is typically chosen to be a string encoding the sequence of nondeterministic choices made by the NTM on one of its accepting computation paths.\n\nConsider an alternative construction for the verifier. Instead of using the sequence of choices, let the certificate, which we'll call $c'$, be a string that encodes the entire sequence of the NTM's configurations, $C_0, C_1, C_2, \\dots, C_k$, for an accepting computation path, where $k \\le p(n)$. Each configuration $C_i$ must encode the NTM's state, its tape head position, and the full content of its tape from the beginning up to the rightmost non-blank symbol at step $i$.\n\nAssuming the verifier $V$ is a **single-tape** deterministic Turing Machine, analyze the time complexity of this new verification procedure. Determine the tightest possible upper bound on the runtime of $V$ that is required to verify the certificate $c'$. Express your answer using Big-O notation as a function of $p(n)$.", "solution": "Let $x$ be the input, $n = |x|$, and let the given NTM run for at most $p(n)$ steps on any branch. Let $k \\leq p(n)$ be the number of configurations in the accepting path encoded by the certificate $c'$, and let the configurations be $C_{0},C_{1},\\dots,C_{k}$.\n\nStep 1: Bound the size of each configuration.\nAt step $i$, the head can have moved at most $i$ cells from its starting position, and at most $i$ new non-blank cells can have been introduced to the right of the original input. Hence, if we let $R_{i}$ denote the length of the tape prefix up to the rightmost non-blank in $C_{i}$, then\n$$\nR_{i} \\leq n + i \\leq n + p(n).\n$$\nLet $R \\coloneqq \\max_{0 \\leq i \\leq k} R_{i} \\leq n + p(n)$. The description of a configuration includes state, head position, and the tape content up to the rightmost non-blank, which is of length $O(R)$ (the state and head position contribute only logarithmic overhead). Therefore, each $C_{i}$ has length $O(R)$, and the entire certificate length satisfies\n$$\n|c'| = O\\big(k R\\big) = O\\big(p(n)\\,(n + p(n))\\big).\n$$\n\nStep 2: What the single-tape verifier must check.\nA correct verifier $V$ must check:\n- $C_{0}$ is the correct initial configuration for input $x$ (including that the tape content of $C_{0}$ matches $x$): this takes $O(n)$ time by a single left-to-right scan.\n- For each $i \\in \\{0,\\dots,k-1\\}$, that $C_{i+1}$ is obtained from $C_{i}$ by one valid NTM transition: this requires checking that state and head updates are consistent with the transition function and that, except possibly at the head cell (and possibly at the rightmost non-blank boundary), the tape contents of $C_{i}$ and $C_{i+1}$ agree at all other positions.\n- $C_{k}$ is accepting: this is $O(1)$ given the configuration’s encoding.\n\nStep 3: Cost to compare adjacent configurations on a single tape.\nFor a single-tape deterministic Turing machine, comparing two adjacent blocks of length $\\Theta(R)$ for equality (or equality except at a constant-size window) requires $\\Theta(R^{2})$ time in the worst case. The standard upper bound is realized by the usual crossing-off or shuttle algorithm that, for each position, moves back and forth across a distance $\\Theta(R)$; this yields an $O(R^{2})$ algorithm. Moreover, the language $\\{w \\# w : w \\in \\Sigma^{*}\\}$ is known to require $\\Omega(R^{2})$ time on single-tape machines, which implies a matching $\\Omega(R^{2})$ lower bound for such comparisons. Thus, verifying that $C_{i+1}$ matches $C_{i}$ everywhere except at the constant-size neighborhood affected by the transition takes\n$$\n\\Theta(R^{2})\n$$\ntime per adjacent pair $(C_{i},C_{i+1})$.\n\nStep 4: Total verification time.\nThere are $k \\leq p(n)$ adjacent pairs, so the total time to verify all transitions is\n$$\nO\\big(k \\cdot R^{2}\\big) = O\\big(p(n)\\,(n + p(n))^{2}\\big).\n$$\nIncluding the $O(n)$ cost to check $C_{0}$ against $x$ does not change the asymptotic bound. Hence,\n$$\nT_{V}(n) = O\\big(p(n)\\,(n + p(n))^{2}\\big).\n$$\n\nIf one wishes to express the bound purely as a function of $p(n)$, it is standard to normalize the NTM so that it first scans the input (forcing $p(n) \\geq n$ while preserving polynomial running time), yielding $R = \\Theta(p(n))$ and hence\n$$\nT_{V}(n) = O\\big(p(n) \\cdot p(n)^{2}\\big) = O\\big(p(n)^{3}\\big).\n$$\nThis is tight up to constant factors: there are NTM computations with $k = \\Theta(p(n))$ and $R = \\Theta(p(n))$ for which each adjacent-pair check requires $\\Omega(R^{2}) = \\Omega(p(n)^{2})$ time on a single tape, giving a total lower bound $\\Omega(p(n)^{3})$.\n\nTherefore, the tightest possible upper bound, as a function of $p(n)$, for a single-tape verifier of this configuration-sequence certificate is $O(p(n)^{3})$.", "answer": "$$\\boxed{O\\!\\left(p(n)^{3}\\right)}$$", "id": "1422200"}, {"introduction": "Having established the standard equivalence, this final practice challenges our understanding by modifying the definition of verification. This thought experiment [@problem_id:1422176] imagines a verifier with a seemingly much greater power: oracle access to a certificate of potentially exponential length, up to $2^{p(n)}$. By determining the true computational power of this hypothetical class, $\\mathrm{OracleNP}$, you will uncover the crucial role of the verifier's polynomial runtime, revealing that the total information it can process, not the size of the certificate it has access to, is what fundamentally defines the complexity class $\\mathrm{NP}$.", "problem": "In computational complexity theory, the class NP is often defined using polynomial-time verifiers. A language $L$ is in NP if there exists a polynomial $p(n)$ and a polynomial-time Deterministic Turing Machine (DTM), called a verifier $V$, such that for any input string $x$ of length $n = |x|$:\n1.  If $x \\in L$, there exists a certificate string $w$ of length at most $p(n)$ such that $V(x, w)$ accepts.\n2.  If $x \\notin L$, for all certificate strings $w$ of length at most $p(n)$, $V(x, w)$ rejects.\n\nConsider a new complexity class, which we will call `OracleNP`. This class is defined by modifying the verifier model. A language $L$ belongs to `OracleNP` if there exist two polynomials, $p(n)$ and $q(n)$, and a DTM, $V_O$, such that for any input string $x$ of length $n=|x|$:\n-   The verifier $V_O$ runs in time bounded by $q(n)$.\n-   $V_O$ has oracle access to a certificate string $y$. This means $V_O$ can, in a single computational step, write a binary index $i$ onto a special query tape and receive the $i$-th bit of $y$, denoted $y_i$.\n-   The certificate $y$ can have a length up to $2^{p(n)}$. Thus, the indices $i$ queried by $V_O$ can be values up to $2^{p(n)}$.\n\nThe acceptance and rejection conditions for `OracleNP` are:\n1.  If $x \\in L$, there exists a certificate string $y$ of length at most $2^{p(n)}$ such that $V_O$, given input $x$ and oracle access to $y$, accepts.\n2.  If $x \\notin L$, for all certificate strings $y$ of length at most $2^{p(n)}$, $V_O$, given input $x$ and oracle access to $y$, rejects.\n\nBased on these definitions, determine the relationship between the class `OracleNP` and other well-known complexity classes.\n\nA. `OracleNP` = P\nB. `OracleNP` = NP\nC. `OracleNP` = PSPACE\nD. `OracleNP` = EXPTIME\nE. `OracleNP` properly contains NP, but is contained in PSPACE.\nF. NP properly contains `OracleNP`.", "solution": "We compare the class defined by polynomial-time deterministic verifiers with oracle access to an exponentially long certificate string (random-access queries to individual bits) to standard NP.\n\nFirst, we formalize the model. For $L$ in OracleNP there exist polynomials $p(n)$ and $q(n)$ and a DTM $V_{O}$ such that, on input $x$ with $|x|=n$, $V_{O}$ runs in time at most $q(n)$ and may, at any step, issue a query index $i$ (in binary) and receive the bit $y_{i}$ of an auxiliary string $y$ of length at most $2^{p(n)}$. Acceptance is existential over $y$:\n1. If $x \\in L$, then there exists $y$ with $|y| \\leq 2^{p(n)}$ such that $V_{O}^{y}(x)$ accepts.\n2. If $x \\notin L$, then for all such $y$, $V_{O}^{y}(x)$ rejects.\n\nWe show OracleNP equals NP via two containments.\n\nContainment $\\mathrm{NP} \\subseteq \\mathrm{OracleNP}$: Let $L \\in \\mathrm{NP}$ with verifier $V$ running in time at most $r(n)$ and using a certificate $w$ of length at most $s(n)$ for polynomials $r$ and $s$. Define $V_{O}$ that, on input $x$, queries its oracle certificate $y$ only on the first $s(n)$ positions to read a putative $w$, and then simulates $V(x,w)$. Since $V_{O}$ runs in time polynomial in $n$, $L$ is in OracleNP. Thus $\\mathrm{NP} \\subseteq \\mathrm{OracleNP}$.\n\nContainment $\\mathrm{OracleNP} \\subseteq \\mathrm{NP}$: Let $L \\in \\mathrm{OracleNP}$ with polynomials $p,q$ and verifier $V_{O}$ as above. We construct a standard NP verifier $U$ with a polynomial-size certificate that encodes an accepting oracle interaction. Because $V_{O}$ runs in time at most $q(n)$, it can issue at most $q(n)$ queries. The sequence of its computation on input $x$ under a particular oracle $y$ is fully determined by $x$ and the answers to those queries.\n\nDefine the certificate $w$ to be a transcript of length at most $T \\leq q(n)$ consisting of the sequence of query-answer information encountered on the unique run: for $t=1,\\dots,T$, include the queried index $i_{t}$ (in binary, of length at most $p(n)$) and the answer bit $b_{t} \\in \\{0,1\\}$. Hence $|w| \\leq q(n)\\,(p(n)+1)$, which is polynomial in $n$.\n\nThe verifier $U$, on input $x$ and certificate $w$, simulates $V_{O}(x)$ step-by-step for at most $q(n)$ steps. Whenever $V_{O}$ writes a query index, call it $\\hat{i}_{t}$, the simulator reads the next pair $(i_{t},b_{t})$ from $w$ and checks that $i_{t}=\\hat{i}_{t}$. It maintains a dictionary of previously seen indices to enforce consistency: if an index repeats, it checks that the newly provided $b_{t}$ matches the recorded bit. It then feeds $b_{t}$ as the oracle answer, and continues the simulation. If at any point the index mismatches, the consistency check fails, or the simulation exceeds $q(n)$ steps, $U$ rejects. If the simulation halts in an accept state within $q(n)$ steps, $U$ accepts.\n\nCorrectness:\n- If $x \\in L$, there exists $y$ such that $V_{O}^{y}(x)$ accepts. Let $w$ be the transcript of that accepting run: the sequence of pairs $(i_{t},y_{i_{t}})$ in order. Then the simulation by $U$ exactly reproduces the run and accepts.\n- If $x \\notin L$, then for every $y$, $V_{O}^{y}(x)$ rejects. For any purported transcript $w$, either it is inconsistent with the deterministic behavior of $V_{O}$ (causing a mismatch or inconsistency that $U$ detects and rejects) or it faithfully simulates some oracle run, which necessarily ends in rejection; thus $U$ rejects.\n\nTherefore, $L \\in \\mathrm{NP}$ and $\\mathrm{OracleNP} \\subseteq \\mathrm{NP}$.\n\nCombining both containments yields $\\mathrm{OracleNP}=\\mathrm{NP}$. Consequently, among the listed options, the correct relationship is that OracleNP equals NP.", "answer": "$$\\boxed{B}$$", "id": "1422176"}]}