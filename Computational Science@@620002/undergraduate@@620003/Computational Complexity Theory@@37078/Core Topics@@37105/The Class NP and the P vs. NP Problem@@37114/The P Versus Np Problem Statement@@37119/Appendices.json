{"hands_on_practices": [{"introduction": "Many computational challenges, from logistics to network design, are initially framed as optimization problems where we seek the best possible solution. However, to formally analyze their difficulty within the $P$ versus $NP$ framework, we must first convert them into decision problems with a 'yes' or 'no' answer. This practice [@problem_id:1460192] will guide you through this fundamental transformation using the classic Independent Set problem, a cornerstone of graph theory and computational complexity.", "problem": "In computational complexity theory, problems are often categorized into classes like P and NP (Nondeterministic Polynomial time). To facilitate this classification, it is standard practice to work with decision problems, which are problems that have a \"yes\" or \"no\" answer. Many real-world problems, however, present themselves naturally as optimization problems, where the goal is to find the best possible solution.\n\nConsider the following scenario: A university is planning a large student conference and has a list of proposed presentations. Due to logistical constraints, certain pairs of presentations cannot be scheduled in the same time slot (e.g., they cover overlapping topics or require the same unique presentation room). We can model this situation with a graph $G=(V, E)$, where each vertex $v \\in V$ represents a presentation, and an edge $(u, v) \\in E$ exists if presentations $u$ and $v$ have a scheduling conflict.\n\nThe objective is to select the largest possible subset of presentations that can all be scheduled in the same time slot. This corresponds to finding a maximum \"independent set\" in the graph, which is a subset of vertices where no two vertices are connected by an edge. This is an optimization problem: \"Find the size of the largest independent set in a given graph $G$.\"\n\nTo analyze this problem's complexity, we must first convert it into its corresponding decision problem format. Which of the following statements correctly formulates the decision problem version of the Independent Set problem?\n\nA. Given a graph $G=(V, E)$ and an integer $k$, does there exist a subset of vertices of size $k$ where every vertex is connected to every other vertex in the subset?\n\nB. Given a graph $G=(V, E)$, what is the maximum number of vertices in a subset where no two vertices are connected by an edge?\n\nC. Given a graph $G=(V, E)$ and an integer $k$, does there exist a subset of vertices of size at least $k$ where no two vertices are connected by an edge?\n\nD. Given a graph $G=(V, E)$ and an integer $k$, is it true that for any chosen edge $(u,v)$, both $u$ and $v$ belong to an independent set of size at most $k$?\n\nE. Given a graph $G=(V, E)$ and an integer $k$, can all vertices be partitioned into $k$ disjoint independent sets?", "solution": "The task is to convert the optimization problem of finding the largest independent set into a decision problem. A decision problem is a question with a yes/no answer. An optimization problem seeks to find a minimum or maximum value.\n\nThe original optimization problem is: \"Given a graph $G$, find the maximum size of an independent set.\" Let's denote this maximum size by $\\alpha(G)$.\n\nThe standard method for converting a maximization optimization problem into a decision problem is to introduce a new parameter, typically an integer $k$, and ask whether a solution with a value of *at least* $k$ exists. This transforms the question from \"What is the best value?\" to \"Is a value of at least $k$ achievable? (yes/no)\". If one could solve this decision problem efficiently, one could find the optimal value $\\alpha(G)$ by using binary search on the possible values of $k$ (from $1$ to the number of vertices $|V|$).\n\nLet's analyze the given options based on this principle:\n\n**Option A:** \"Given a graph $G=(V, E)$ and an integer $k$, does there exist a subset of vertices of size $k$ where every vertex is connected to every other vertex in the subset?\"\nThis describes the CLIQUE problem. A clique is a subset of vertices where every two distinct vertices are adjacent. This is the opposite of an independent set, where no two vertices are adjacent. Therefore, this is an incorrect formulation.\n\n**Option B:** \"Given a graph $G=(V, E)$, what is the maximum number of vertices in a subset where no two vertices are connected by an edge?\"\nThis is the statement of the original optimization problem itself. It asks \"what is the maximum number,\" which requires a numerical answer, not a yes/no answer. Therefore, it is not a decision problem.\n\n**Option C:** \"Given a graph $G=(V, E)$ and an integer $k$, does there exist a subset of vertices of size at least $k$ where no two vertices are connected by an edge?\"\nThis correctly frames the problem as a yes/no question. It takes the graph $G$ and an integer threshold $k$ as input. It asks if an independent set of a certain minimum size exists. This perfectly fits the standard transformation from an optimization problem to a decision problem. This is the decision version of the Independent Set problem, often abbreviated as IND-SET.\n\n**Option D:** \"Given a graph $G=(V, E)$ and an integer $k$, is it true that for any chosen edge $(u,v)$, both $u$ and $v$ belong to an independent set of size at most $k$?\"\nThis is an unnecessarily complex and incorrect formulation. First, by definition, if an edge $(u,v)$ exists, $u$ and $v$ cannot belong to the *same* independent set. The statement is ill-formed and does not correspond to the original optimization problem.\n\n**Option E:** \"Given a graph $G=(V, E)$ and an integer $k$, can all vertices be partitioned into $k$ disjoint independent sets?\"\nThis describes the GRAPH COLORING problem (specifically, its decision version). Assigning each vertex to one of $k$ independent sets is equivalent to coloring the graph with $k$ colors such that no two adjacent vertices share the same color. Each independent set corresponds to all vertices of a single color. While it is a famous decision problem, it is not the decision version of the Independent Set problem.\n\nTherefore, the only correct transformation among the choices is Option C.", "answer": "$$\\boxed{C}$$", "id": "1460192"}, {"introduction": "Once a problem is framed as a decision question, we can investigate whether it belongs to the class $NP$. A key requirement for a problem to be in $NP$ is that any 'yes' instance can be verified efficiently if given the right piece of information, known as a certificate. This exercise [@problem_id:1460208] uses the famous Traveling Salesperson Problem to give you hands-on experience in not only formulating the decision problem but also identifying a valid certificate that makes verification possible in polynomial time.", "problem": "A technology company is designing a sophisticated scheduling system for a fleet of autonomous delivery drones. The drones must visit a set of $n$ distinct delivery locations. The system has access to the precise travel time $t(u, v)$ between any two locations $u$ and $v$. A key challenge is to find an optimal route that minimizes the total travel time. This is a variant of the well-known Traveling Salesperson Problem (TSP).\n\nIn computational complexity theory, to classify the difficulty of problems like TSP, we often convert them from *optimization problems* (which ask for the best solution) to *decision problems* (which have a \"yes\" or \"no\" answer). A problem is said to belong to the class NP (Nondeterministic Polynomial time) if any \"yes\" instance of its decision version can be efficiently verified. This verification process involves checking a proposed solution, known as a *certificate* or *witness*, in polynomial time relative to the size of the problem input.\n\nConsider the decision version of the drone routing problem. The input consists of the $n$ locations, the set of all travel times $t(u, v)$, and a maximum allowable total tour time, $K$. The question is whether a valid tour can be completed within this time limit.\n\nWhich of the following choices correctly identifies both the formal decision question for this problem and a valid certificate that would allow a \"yes\" answer to be verified in polynomial time?\n\nA. **Decision Question:** Does there exist a tour that visits each location exactly once and returns to the start, with a total travel time of at most $K$? **Certificate:** The numerical value of the tour's total travel time.\n\nB. **Decision Question:** What is the shortest possible travel time for a tour that visits each location exactly once and returns to the start? **Certificate:** A specific ordered sequence of the $n$ locations that forms a complete tour.\n\nC. **Decision Question:** Does there exist a tour that visits each location exactly once and returns to the start, with a total travel time of at most $K$? **Certificate:** A description of the computer algorithm that was used to find the tour.\n\nD. **Decision Question:** Does there exist a tour that visits each location exactly once and returns to the start, with a total travel time of at most $K$? **Certificate:** A specific ordered sequence of the $n$ locations that forms a complete tour (e.g., Location 1 -> Location 5 -> ... -> Location 1).", "solution": "To solve this problem, we must correctly identify two components: the decision version of the Traveling Salesperson Problem (TSP) and a valid certificate for a \"yes\" instance.\n\nFirst, let's analyze the formulation of the decision question. Computational complexity theory, particularly the study of the class NP, focuses on decision problems, which are questions with a \"yes\" or \"no\" answer. The original TSP is an optimization problem: it asks \"What is the *minimum* total distance/time for a tour?\" To convert this to a decision problem, we introduce a threshold, which is given as $K$ in the problem description. The corresponding decision question is not about finding the minimum value, but about determining if a solution exists that meets a certain criterion. Therefore, the correct decision question is: \"Does there exist a tour that visits each location exactly once and returns to the start, with a total travel time of at most $K$?\"\n\nLet's examine the decision questions presented in the options:\n- Option B asks, \"What is the shortest possible travel time...?\" This is the optimization version of the problem, not the decision version. Therefore, Option B is incorrect.\n- Options A, C, and D all present the correct decision question: \"Does there exist a tour... with a total travel time of at most $K$?\" So, we must now evaluate the certificate proposed in each of these options.\n\nSecond, let's analyze the concept of a certificate. For a problem to be in NP, a \"yes\" answer must be verifiable in polynomial time. This means that if someone claims the answer is \"yes,\" they must provide a piece of evidence (the certificate) that allows us to confirm their claim quickly. The certificate itself is not the method for finding the solution, but the solution itself or a representation of it. The verifier is an algorithm that takes the problem instance (locations, times, $K$) and the certificate as input and confirms in polynomial time whether the certificate proves the \"yes\" instance.\n\nLet's evaluate the certificates for the remaining options (A, C, and D):\n- **Option A Certificate:** \"The numerical value of the tour's total travel time.\"\nSuppose the certificate is the number `120.5`. To verify this, we would need to confirm that a tour with a total time of `120.5` (which is $\\le K$) actually exists. But just having the number doesn't help us. We would still need to search for a tour with that specific total time, which is just as hard as the original problem. A certificate must make verification easy. Therefore, a numerical value alone is not a valid certificate. This eliminates Option A.\n\n- **Option C Certificate:** \"A description of the computer algorithm that was used to find the tour.\"\nA certificate is a piece of data representing a solution, not the procedure used to find it. Verifying that an algorithm is correct and will indeed find such a tour is a much more complex problem (related to program verification) and is not what is meant by certificate verification in complexity theory. The verifier's task is to check a given solution, not a given solution method. Therefore, this is not a valid certificate. This eliminates Option C.\n\n- **Option D Certificate:** \"A specific ordered sequence of the $n$ locations that forms a complete tour (e.g., Location 1 -> Location 5 -> ... -> Location 1).\"\nThis is a valid certificate. Let's see how a verifier could use it. Given a sequence of $n$ locations, the verifier can perform the following steps in polynomial time:\n1.  Check if the sequence is a permutation of all $n$ locations (i.e., it visits each location exactly once). This can be done by sorting or using a hash table in time proportional to $n \\log n$ or $n$.\n2.  Calculate the total travel time of the tour defined by the sequence. This involves summing the $n$ travel times for the $n$ legs of the tour (e.g., $t(L_1, L_2) + t(L_2, L_3) + \\dots + t(L_n, L_1)$). This is a simple summation of $n$ numbers, which is a linear time operation, $O(n)$.\n3.  Compare the calculated total time with the threshold $K$. This is a single comparison, a constant time operation, $O(1)$.\nSince all verification steps can be performed in polynomial time (in fact, linear time with respect to the number of locations, $n$), this sequence is a valid certificate.\n\nBoth the decision question and the certificate in Option D are correct.", "answer": "$$\\boxed{D}$$", "id": "1460208"}, {"introduction": "In complexity theory, we rarely analyze problems in complete isolation; instead, we compare them to one another to understand their relative difficulty. The primary tool for this comparison is the polynomial-time reduction, which allows us to say that one problem is 'no harder than' another. This exercise [@problem_id:1460220] explores a crucial implication of this relationship, demonstrating how a reduction can prove a problem is 'easy' (in $P$) if it reduces to another known 'easy' problem.", "problem": "In computational complexity theory, we classify problems based on the resources required to solve them. The class P consists of all decision problems that can be solved by a deterministic Turing machine in polynomial time. A problem A is said to be polynomially reducible to a problem B, denoted as $A \\le_p B$, if there exists a polynomial-time algorithm that transforms any instance of problem A into an instance of problem B, such that the answer to the original instance of A is \"yes\" if and only if the answer to the transformed instance of B is \"yes\".\n\nSuppose you are given two decision problems, Problem A and Problem B. You are provided with the following two facts:\n1. Problem B is in the complexity class P.\n2. Problem A is polynomially reducible to Problem B ($A \\le_p B$).\n\nBased solely on this information, what is the most precise conclusion you can draw about the complexity of Problem A?\n\nA. Problem A is in P.\n\nB. Problem A is NP-complete.\n\nC. Problem A is in NP, but its membership in P cannot be determined.\n\nD. Problem A must be at least as hard as Problem B.\n\nE. No meaningful conclusion about the complexity of Problem A can be drawn.", "solution": "We are given that Problem B is in P and that Problem A is polynomial-time reducible to Problem B, denoted $A \\le_p B$. By definition of polynomial-time many-one reduction, there exists a function $f$ such that for every input $x$,\n$$x \\in A \\iff f(x) \\in B,$$\nand $f$ is computable by a deterministic Turing machine in time bounded by a polynomial in the input size. Concretely, there exists a polynomial $p$ such that $f$ can be computed in time at most $p(|x|)$. Furthermore, the size of the output is polynomially bounded, i.e., there exists a polynomial $s$ such that\n$$|f(x)| \\leq s(|x|) \\quad \\text{for all } x.$$\n\nSince B is in P, there exists a deterministic Turing machine $M_{B}$ that decides B in time bounded by a polynomial in the input size. That is, there exists a polynomial $q$ such that for any input $y$,\n$$T_{B}(|y|) \\leq q(|y|).$$\n\nWe construct a deterministic algorithm to decide A as follows: on input $x$, compute $y = f(x)$, then run $M_{B}$ on input $y$ and output its decision. Correctness follows from the reduction property $x \\in A \\iff f(x) \\in B$.\n\nFor the running time on an input $x$ with $|x| = n$, the total time $T_{A}(n)$ is bounded by the time to compute $f(x)$ plus the time to decide B on $y=f(x)$:\n$$T_{A}(n) \\leq p(n) + q(|f(x)|).$$\nUsing the size bound $|f(x)| \\leq s(n)$, we obtain\n$$T_{A}(n) \\leq p(n) + q(s(n)).$$\nSince $p$, $q$, and $s$ are polynomials, the composition $q \\circ s$ is a polynomial, and the sum of polynomials is a polynomial. Therefore there exists a polynomial $t$ such that\n$$T_{A}(n) \\leq t(n),$$\nwhich shows that A is decidable in polynomial time; that is, $A \\in \\text{P}$.\n\nThus, the most precise conclusion is that Problem A is in P. Options asserting NP-completeness, mere NP membership, or that A is at least as hard as B are not supported; indeed, $A \\le_p B$ indicates A is no harder than B.", "answer": "$$\\boxed{A}$$", "id": "1460220"}]}