{"hands_on_practices": [{"introduction": "A core aspect of understanding any complexity class is determining its closure propertiesâ€”that is, which operations can you apply to languages within the class without leaving it. This practice asks you to explore several fundamental operations on languages, such as union, concatenation, and Kleene star, and decide if they preserve membership in NP. By reasoning about how to construct new verifiers from old ones, you will build a foundational map of the structural properties of the class NP [@problem_id:1415409].", "problem": "In computational complexity theory, the complexity class Nondeterministic Polynomial-time (NP) is defined as the set of decision problems for which a 'yes' instance has a certificate that can be verified in polynomial time by a deterministic Turing machine. An important area of study involves understanding which operations on languages preserve membership in this class.\n\nLet $\\Sigma$ be a finite alphabet. For any language(s) $L, L_1, L_2$ over $\\Sigma$ that are in the class NP, consider the following operations that produce a new language:\n\n1.  **Union:** $L_1 \\cup L_2 = \\{w \\mid w \\in L_1 \\text{ or } w \\in L_2\\}$\n2.  **Concatenation:** $L_1 L_2 = \\{w_1 w_2 \\mid w_1 \\in L_1 \\text{ and } w_2 \\in L_2\\}$\n3.  **Kleene Star:** $L^* = \\bigcup_{i \\ge 0} L^i$, where $L^0 = \\{\\epsilon\\}$ (the language containing only the empty string) and $L^i = L L^{i-1}$ for $i \\ge 1$.\n4.  **Complement:** $\\overline{L} = \\{w \\in \\Sigma^* \\mid w \\notin L\\}$\n5.  **Cyclic Shift:** $CYCLE(L) = \\{vu \\mid uv \\in L \\text{ for some strings } u, v \\in \\Sigma^*\\}$\n\nWhich of the following statements are true? Select all that apply.\n\nA. The language $L_1 \\cup L_2$ is always in NP.\nB. The language $L_1 L_2$ is always in NP.\nC. The language $L^*$ is always in NP.\nD. The language $\\overline{L}$ is always in NP.\nE. The language $CYCLE(L)$ is always in NP.", "solution": "We use the verifier definition of NP. A language $L \\subseteq \\Sigma^{*}$ is in NP if there exist a deterministic polynomial-time verifier $V$ and a polynomial $p$ such that for every $x \\in \\Sigma^{*}$,\n$$\nx \\in L \\iff \\exists y \\in \\Sigma^{*} \\text{ with } |y| \\le p(|x|) \\text{ and } V(x,y)=1.\n$$\nWe will show closure under each operation, except for complement where such closure would imply $\\mathrm{NP}=\\mathrm{co-NP}$, which is not known.\n\nFor union, suppose $L_1, L_2 \\in \\mathrm{NP}$ with verifiers $V_1, V_2$ and polynomials $p_1, p_2$. Define a verifier $V$ for $L_1 \\cup L_2$ that on input $(w,b,y)$ first checks $b \\in \\{1,2\\}$, and if $b=1$ runs $V_1(w,y)$, if $b=2$ runs $V_2(w,y)$. If $w \\in L_1 \\cup L_2$, then there exists $b \\in \\{1,2\\}$ and a certificate $y$ with $|y| \\le \\max\\{p_1(|w|), p_2(|w|)\\}$ that causes $V$ to accept. The run time is polynomial in $|w|$, and the certificate length is polynomial, so $L_1 \\cup L_2 \\in \\mathrm{NP}$. Thus A is true.\n\nFor concatenation, suppose $L_1, L_2 \\in \\mathrm{NP}$ with verifiers $V_1, V_2$ and polynomials $p_1, p_2$. For $w \\in \\Sigma^{*}$, $w \\in L_1 L_2$ if and only if there exist strings $w_1, w_2$ with $w=w_1 w_2$, $w_1 \\in L_1$, and $w_2 \\in L_2$. Define a verifier $V$ that on input $(w,i,y_1,y_2)$ first parses $w$ as $w=w_1 w_2$ where $|w_1|=i$, then runs $V_1(w_1,y_1)$ and $V_2(w_2,y_2)$ and accepts if both accept. If $w \\in L_1 L_2$, then there is a split $i$ and certificates $y_1, y_2$ with $|y_1| \\le p_1(|w_1|) \\le p_1(|w|)$ and $|y_2| \\le p_2(|w_2|) \\le p_2(|w|)$ that cause $V$ to accept. The total certificate length is at most $|i|+|y_1|+|y_2|$, which is polynomial in $|w|$, and the verification runs in time polynomial in $|w|$. Hence $L_1 L_2 \\in \\mathrm{NP}$. Thus B is true.\n\nFor Kleene star, suppose $L \\in \\mathrm{NP}$ with verifier $V$ and polynomial $p$. For $w \\in \\Sigma^{*}$, $w \\in L^{*}$ if and only if there exists an integer $k \\ge 0$ and a partition $w=w_1 \\cdots w_k$ with each $w_i \\in L$ (with the convention $k=0$ only if $w=\\epsilon$). Define a verifier that on input $(w,k,i_1,\\dots,i_{k-1},y_1,\\dots,y_k)$ uses the cut positions $i_1,\\dots,i_{k-1}$ to parse $w$ into $w_1,\\dots,w_k$, checks $k \\le |w|+1$ (to rule out exponentially many empty pieces), and then runs $V(w_i,y_i)$ for each $i$ and accepts if all accept. If $w \\in L^{*}$, there exists some partition with $k \\le |w|+1$ and certificates $y_i$ with $|y_i| \\le p(|w_i|)$. Let $p(n) \\le C n^{d}$ for some constants $C,d \\in \\mathbb{N}$. Then the total certificate length is at most\n$$\nO(\\log |w|) + \\sum_{i=1}^{k} p(|w_i|) \\le O(\\log |w|) + C \\sum_{i=1}^{k} |w_i|^{d} \\le O(\\log |w|) + C |w|^{d},\n$$\nsince $\\sum_{i=1}^{k} |w_i|=|w|$ and for $d \\ge 1$, $\\sum_{i} |w_i|^{d} \\le |w|^{d}$. The verifier runs $k \\le |w|+1$ calls to $V$, each polynomial in $|w|$, so total time is polynomial in $|w|$. Therefore $L^{*} \\in \\mathrm{NP}$. Thus C is true.\n\nFor complement, if $\\overline{L} \\in \\mathrm{NP}$ for every $L \\in \\mathrm{NP}$, then $\\mathrm{NP}=\\mathrm{co-NP}$. This equality is not known to hold. Therefore it is not correct to assert closure under complement for NP in general. Thus D is false.\n\nFor cyclic shift, define $CYCLE(L)=\\{vu \\mid \\exists u,v \\in \\Sigma^{*} \\text{ with } uv \\in L\\}$. Suppose $L \\in \\mathrm{NP}$ with verifier $V$ and polynomial $p$. Define a verifier $V'$ for $CYCLE(L)$ as follows: on input $(x,s,y)$, where $x \\in \\Sigma^{*}$, let $s$ be a split position with $0 \\le s \\le |x|$, write $x=vu$ where $|v|=s$, form $uv$, and run $V(uv,y)$, accepting if $V$ accepts. If $x \\in CYCLE(L)$, then there exist $u,v$ with $x=vu$ and $uv \\in L$, hence there exists $y$ with $|y| \\le p(|uv|)=p(|x|)$ such that $V(uv,y)=1$. The certificate length is $|s|+|y|$, which is polynomial in $|x|$, and the verification runs in polynomial time. Therefore $CYCLE(L) \\in \\mathrm{NP}$. Thus E is true.\n\nCombining these, the true statements are A, B, C, and E.", "answer": "$$\\boxed{ABCE}$$", "id": "1415409"}, {"introduction": "After establishing that NP is closed under the Kleene star operation, it is instructive to see how this abstract property translates into a concrete algorithm design. This exercise challenges you to construct a specific polynomial-time verifier for $(SAT)^*$, the language of concatenated satisfiable Boolean formulas [@problem_id:1415399]. Successfully designing the certificate for this problem demonstrates a crucial skill: combining multiple NP \"proofs\" into a single, verifiable package.", "problem": "In computational complexity theory, the language $SAT$ consists of all strings that encode a satisfiable Boolean formula. A Boolean formula uses variables (e.g., $x_1, x_2, \\ldots$), parentheses, and logical connectives such as AND ($\\land$), OR ($\\lor$), and NOT ($\\neg$). A formula is satisfiable if there exists an assignment of TRUE or FALSE to its variables that makes the entire formula evaluate to TRUE.\n\nThe Kleene star of a language $L$, denoted $L^*$, is the set of all strings that can be formed by concatenating zero or more strings from $L$. The empty string is always in $L^*$.\n\nConsider the language $L_{SAT}^* = (SAT)^*$. A non-empty string $w$ is in $L_{SAT}^*$ if and only if $w$ can be parsed as a concatenation of one or more strings, $w = \\phi_1 \\phi_2 \\dots \\phi_k$, where each $\\phi_i$ is a string representation of a satisfiable Boolean formula. For example, if $\\phi_1 = (x_1 \\lor x_2)$ and $\\phi_2 = (x_3 \\land \\neg x_3)$, then $\\phi_1$ is in $SAT$ but $\\phi_2$ is not. The string \"$(x_1 \\lor x_2)$\" belongs to $L_{SAT}^*$, but the string \"$(x_1 \\lor x_2)(x_3 \\land \\neg x_3)$\" does not, as the second part is unsatisfiable.\n\nA language $L$ is in the complexity class NP if there exists a polynomial-time verifier for it. A verifier $V$ is an algorithm that takes an input string $w$ and a certificate string $c$. The verifier must satisfy two properties:\n1.  **Completeness**: For any string $w \\in L$, there must exist a certificate $c$ such that $V(w, c)$ accepts.\n2.  **Soundness**: For any string $w \\notin L$, $V(w, c)$ must reject for all possible certificates $c$.\nAdditionally, the verifier $V$ must run in time that is polynomial in the length of the input string, $|w|$. This implies that the length of the certificate, $|c|$, must also be polynomial in $|w|$.\n\nWhich of the following options correctly describes a valid polynomial-time verifier for the language $L_{SAT}^*$?\n\nA. The certificate $c$ is a concatenation of satisfying assignments, one for each formula believed to be in the input string $w$. The verifier non-deterministically guesses a partition of $w$ into sub-formulas $\\phi_1, \\dots, \\phi_k$, and then uses the certificate to check if each $\\phi_i$ is satisfied by its corresponding assignment.\n\nB. The certificate $c$ consists of two parts: first, a list of integers that specify the boundaries for partitioning the input string $w$ into sub-formulas $\\phi_1, \\dots, \\phi_k$; second, a concatenation of satisfying assignments $a_1, \\dots, a_k$. The verifier first uses the boundary information to parse $w$ into the sub-formulas. Then, for each sub-formula $\\phi_i$, it checks if the corresponding assignment $a_i$ from the certificate satisfies it. The verifier accepts if and only if every sub-formula is syntactically valid and satisfied by its assignment.\n\nC. The certificate $c$ consists of a list of integers that specify the boundaries for partitioning $w$ into sub-formulas $\\phi_1, \\dots, \\phi_k$, and a single global satisfying assignment for all variables that appear in $w$. The verifier parses $w$ and checks if this single assignment satisfies every sub-formula $\\phi_i$.\n\nD. The verifier requires no certificate. It works by trying every possible partition of the input string $w$ into substrings $\\phi_1, \\dots, \\phi_k$. For each partition, it then uses a SAT solver to check if every substring $\\phi_i$ is satisfiable. If it finds such a partition where all substrings are satisfiable, it accepts.\n\nE. The certificate $c$ is a single satisfying assignment for one of the sub-formulas. The verifier non-deterministically guesses a partition of $w$ into sub-formulas $\\phi_1, \\dots, \\phi_k$, and also non-deterministically guesses which sub-formula $\\phi_i$ the certificate applies to. It then verifies that this single $\\phi_i$ is satisfied by the certificate. If this check passes, it accepts.", "solution": "To determine the correct polynomial-time verifier for $L_{SAT}^* = (SAT)^*$, we must analyze the structure of the problem and the requirements for a verifier in the complexity class NP.\n\nA string $w$ is in $L_{SAT}^*$ if it can be decomposed into a sequence of satisfiable formulas, $w = \\phi_1 \\phi_2 \\dots \\phi_k$. A verifier for this language must confirm two things in polynomial time, given a suitable certificate:\n1.  The specific decomposition of $w$ into $\\phi_1, \\dots, \\phi_k$.\n2.  That every formula $\\phi_i$ in this decomposition is satisfiable.\n\nThe core difficulty in verifying membership in $L_{SAT}^*$ stems from these two points.\nFirst, the number of ways to partition a string $w$ of length $n$ into substrings is $2^{n-1}$, which is exponential. A polynomial-time verifier cannot try all possible partitions. Therefore, the information about the correct partition must be provided in the certificate.\nSecond, determining if a single Boolean formula $\\phi_i$ is satisfiable is the NP-complete problem $SAT$. A polynomial-time verifier cannot solve this problem on its own. The \"proof\" of satisfiability, which is a satisfying assignment, must be provided in the certificate for each formula $\\phi_i$.\n\nLet's construct a correct verifier based on these insights and then evaluate the given options.\n\n**Correct Verifier Design:**\n*   **Certificate ($c$)**: The certificate must provide all the non-deterministic information needed.\n    1.  **Partition Information**: A list of integers specifying the end-points of each sub-formula $\\phi_i$. For a string $w$ of length $n$, and a partition into $k$ formulas, this could be a list of $k-1$ indices. The length of this list is at most $n-1$, so its size is polynomial in $n$.\n    2.  **Satisfying Assignments**: For each sub-formula $\\phi_i$, a satisfying assignment $a_i$. The number of variables in any $\\phi_i$ is at most $|\\phi_i| \\le n$. The total length of the concatenated assignments $\\sum |a_i|$ is polynomial in $n$ (at most $O(n^2)$).\n    Therefore, the total certificate length is polynomial in $|w|$.\n\n*   **Verifier Algorithm ($V(w, c)$)**:\n    1.  Parse the certificate $c$ to extract the partition indices and the list of assignments $(a_1, a_2, \\dots, a_k)$. If the certificate is malformed, reject.\n    2.  Use the indices to partition the input string $w$ into substrings $\\phi_1, \\phi_2, \\dots, \\phi_k$. If the indices are invalid (e.g., not in increasing order, out of bounds), reject.\n    3.  Iterate from $i=1$ to $k$:\n        a. Check if the substring $\\phi_i$ is a syntactically well-formed Boolean formula. This can be done in time polynomial in $|\\phi_i|$. If not, reject.\n        b. Using the assignment $a_i$, evaluate the formula $\\phi_i$. This is also a polynomial-time operation in $|\\phi_i|$. If the result is FALSE, reject.\n    4.  If the loop finishes without rejecting, it means every sub-formula is syntactically valid and satisfied by its provided assignment. Therefore, accept.\n\n*   **Complexity Analysis**: The runtime of this verifier is the sum of the times for parsing, partitioning, and the loop. The loop runs $k$ times ($k \\le |w|$). The work inside the loop is polynomial in $|\\phi_i|$. The total time complexity is $\\sum_{i=1}^k \\text{poly}(|\\phi_i|)$, which is polynomial in the total length $|w| = \\sum |\\phi_i|$. This fulfills the polynomial-time requirement.\n\nNow let's evaluate the given options:\n\n**A. The certificate $c$ is a concatenation of satisfying assignments... The verifier non-deterministically guesses a partition...**\nThis is incorrect. A deterministic polynomial-time verifier cannot \"non-deterministically guess\". The verifier is a deterministic algorithm. The non-determinism is captured by the existential requirement on the certificate. If it were a deterministic verifier, it would have to try all exponential partitions, which is not polynomial time.\n\n**B. The certificate $c$ consists of two parts: first, a list of integers that specify the boundaries... second, a concatenation of satisfying assignments... The verifier first uses the boundary information to parse... Then, for each sub-formula $\\phi_i$, it checks if the corresponding assignment $a_i$... satisfies it.**\nThis option exactly matches our derived correct verifier design. The certificate provides both the partition and the individual proofs of satisfiability (the assignments). The verifier deterministically checks these proofs in polynomial time. This correctly describes a valid polynomial-time verifier.\n\n**C. The certificate $c$ consists of... a single global satisfying assignment for all variables that appear in $w$.**\nThis is incorrect. The individual formulas $\\phi_i$ are independent. It is possible for a string $w$ to be in $L_{SAT}^*$ even if no single assignment can satisfy all sub-formulas simultaneously. For example, consider $w = \\phi_1 \\phi_2$ where $\\phi_1$ is \"$x_1$\" and $\\phi_2$ is \"$\\neg x_1$\". Both $\\phi_1$ and $\\phi_2$ are in $SAT$. Thus, $w \\in L_{SAT}^*$. However, there is no single assignment for $x_1$ that satisfies both. One needs the assignment $\\{x_1=\\text{TRUE}\\}$ for $\\phi_1$ and $\\{x_1=\\text{FALSE}\\}$ for $\\phi_2$. Therefore, separate assignments are required.\n\n**D. The verifier requires no certificate. It works by trying every possible partition...**\nThis is incorrect. As discussed, there are $2^{n-1}$ possible partitions for a string of length $n$. Trying all of them would take exponential time, so this algorithm is not a polynomial-time verifier. Furthermore, for each partition, it would need to solve SAT for each sub-formula, which is itself an NP-complete problem.\n\n**E. The certificate $c$ is a single satisfying assignment for one of the sub-formulas... It then verifies that this single $\\phi_i$ is satisfied... If this check passes, it accepts.**\nThis is incorrect. The definition of $L_{SAT}^*$ requires that *all* sub-formulas in the partition be satisfiable. Verifying only one is insufficient and violates the soundness property. For example, if $w = \\phi_1\\phi_2$ where $\\phi_1$ is satisfiable and $\\phi_2$ is not, the verifier described here could incorrectly accept $w$ (which is not in $L_{SAT}^*$) by being given the assignment for $\\phi_1$.\n\nBased on this analysis, option B is the only one that correctly describes a valid polynomial-time verifier for $L_{SAT}^*$.", "answer": "$$\\boxed{B}$$", "id": "1415399"}, {"introduction": "New languages in NP can also be formed through a powerful operation that acts like existential quantification over a known NP language. This problem explores the closure of NP under projection, a fundamental technique for relating and simplifying problems [@problem_id:1415437]. Your task is to show that if a language $L$ of pairs $(x,y)$ is in NP, then the language of just the first components, $\\{x \\mid \\exists y \\text{ s.t. } (x,y) \\in L\\}$, is also in NP, which requires a clever bundling of certificates.", "problem": "In computational complexity theory, the class NP (Nondeterministic Polynomial time) consists of decision problems for which a proposed solution can be verified efficiently. Formally, a language $A$ over an alphabet $\\Sigma$ is in NP if there exists a deterministic polynomial-time Turing machine $V$, called a verifier, and a polynomial $p(n)$ such that for any string $s \\in \\Sigma^*$:\n$s \\in A$ if and only if there exists a certificate string $c \\in \\Sigma^*$ with $|c| \\le p(|s|)$ such that $V$ accepts the pair $(s, c)$.\n\nConsider a language of pairs, $L \\subseteq \\Sigma^* \\times \\Sigma^*$, which is known to be in NP. This means there is a polynomial-time verifier, $V_L$, and a polynomial $p_L$ such that for any pair of strings $(x,y)$:\n$(x,y) \\in L$ if and only if there exists a certificate $w$ with $|w| \\le p_L(|x|+|y|)$, such that $V_L$ accepts the input $((x,y), w)$.\nFurthermore, for any $(x,y) \\in L$, the length of the string $y$ is polynomially bounded by the length of the string $x$; that is, there exists a polynomial $q$ such that $|y| \\le q(|x|)$.\n\nNow, consider the projection of $L$ onto its first component, which defines a new language $L_1$:\n$$L_1 = \\{ x \\in \\Sigma^* \\mid \\exists y \\in \\Sigma^* \\text{ such that } (x,y) \\in L \\}$$\nTo demonstrate that $L_1$ is also in NP, one must construct a new polynomial-time verifier, let's call it $V_1$, and identify a suitable certificate for it. Which of the following options correctly describes the construction and operation of such a verifier $V_1$ for an input string $x$?\n\nA. $V_1$ takes the input $x$ and a certificate $w$. It nondeterministically guesses a string $y$ of polynomial length and then simulates the original verifier $V_L$ on the input $((x,y), w)$.\n\nB. $V_1$ takes the input $x$ and a certificate which consists of the string $y$. It then simulates the original verifier $V_L$ on the input $((x,y), \\epsilon)$, where $\\epsilon$ is the empty string, and accepts if $V_L$ accepts.\n\nC. $V_1$ takes the input $x$ and a certificate $c'$, which is an encoding of a pair of strings $\\langle y, w \\rangle$. $V_1$ first parses $c'$ to extract $y$ and $w$. It then simulates the original verifier $V_L$ on the input $((x,y), w)$ and accepts if and only if $V_L$ accepts.\n\nD. The language $L_1$ is not necessarily in NP because the length of the required string $y$ is not bounded, so a verifier cannot process it in polynomial time relative to the length of $x$.\n\nE. $V_1$ takes the input $x$ and a certificate $c'$, which is an encoding of a pair $\\langle y, w \\rangle$. It first verifies that $y$ is a member of some known NP-complete language and that $|w| \\le p_L(|x|+|y|)$, then simulates $V_L$ on the input $((x,y), w)$.", "solution": "We are given a language of pairs $L \\subseteq \\Sigma^{*} \\times \\Sigma^{*}$ in NP. Hence, there exists a deterministic polynomial-time verifier $V_L$ and a polynomial $p_L$ such that for any $(x,y)$,\n$$(x,y) \\in L \\iff \\exists w \\in \\Sigma^{*} \\text{ with } |w| \\le p_L(|x|+|y|) \\text{ and } V_L(((x,y),w)) \\text{ accepts}.$$\nWe are also given a polynomial bound on the second component: there exists a polynomial $q$ such that for all $(x,y) \\in L$, we have\n$$|y| \\le q(|x|).$$\nDefine the projected language\n$$L_1 = \\{ x \\in \\Sigma^{*} \\mid \\exists y \\in \\Sigma^{*} \\text{ such that } (x,y) \\in L \\}.$$\nTo show $L_1 \\in \\text{NP}$, we must construct a deterministic polynomial-time verifier $V_1$ and a polynomial $p_1$ such that for any $x$,\n$$x \\in L_1 \\iff \\exists c' \\in \\Sigma^{*} \\text{ with } |c'| \\le p_1(|x|) \\text{ and } V_1((x,c')) \\text{ accepts}.$$\n\nConstruction of the certificate and verifier:\n- Let the certificate for $x$ be a standard encoding $c' = \\langle y, w \\rangle$ of a pair of strings $(y,w)$. Use any fixed, polynomial-time-decodable pairing function with polynomially bounded length. Concretely, there exists a polynomial $r$ such that for all strings $y,w$,\n$$|\\langle y, w \\rangle| \\le r(|y| + |w|),$$\nand decoding $\\langle y, w \\rangle$ into $(y,w)$ is computable in time polynomial in $|\\langle y, w \\rangle|$.\n- The verifier $V_1$, on input $(x,c')$, performs:\n  1. Parse $c'$ to obtain $(y,w)$.\n  2. Simulate $V_L$ on input $((x,y),w)$.\n  3. Accept if and only if $V_L$ accepts.\n\nCorrectness:\n- Soundness: If $V_1$ accepts $(x,c')$, then the parsed $(y,w)$ cause $V_L$ to accept $((x,y),w)$. Hence, $(x,y) \\in L$, so $x \\in L_1$.\n- Completeness: If $x \\in L_1$, then there exists $y$ with $(x,y) \\in L$. By membership of $L$ in NP, there exists $w$ with $|w| \\le p_L(|x|+|y|)$ and $V_L$ accepts $((x,y),w)$. Then $c'=\\langle y,w \\rangle$ makes $V_1$ accept.\n\nPolynomial certificate size:\nLet $s = |x|$. Using the given bound $|y| \\le q(s)$ and the verifier bound $|w| \\le p_L(|x|+|y|)$, we have\n$$|w| \\le p_L(s + |y|) \\le p_L(s + q(s)).$$\nThus the certificate length satisfies\n$$|c'| = |\\langle y, w \\rangle| \\le r(|y| + |w|) \\le r\\big(q(s) + p_L(s + q(s))\\big).$$\nDefine the polynomial\n$$p_1(n) = r\\big(q(n) + p_L(n + q(n))\\big),$$\nso $|c'| \\le p_1(|x|)$.\n\nPolynomial-time verification:\nParsing $c'$ into $(y,w)$ is polynomial in $|c'|$, hence polynomial in $|x|$. The input size to $V_L$ is $|(x,y)| + |w| \\le |x| + |y| + |w| \\le s + q(s) + p_L(s + q(s))$, which is polynomial in $s$. Since $V_L$ runs in time polynomial in its input length, the total running time of $V_1$ is polynomial in $|x|$.\n\nTherefore, $L_1 \\in \\text{NP}$ with verifier $V_1$ as constructed above. Among the options, this exactly corresponds to the description in option C: the certificate encodes both $y$ and $w$, $V_1$ parses them and runs $V_L$ on $((x,y),w)$.\n\nWhy the other options are incorrect:\n- A: A verifier in the NP verification definition is deterministic; it must not rely on nondeterministic guessing of $y$. Instead, $y$ must be part of the certificate.\n- B: The original witness $w$ for $L$ may be nonempty; omitting $w$ breaks completeness in general.\n- D: This is false due to the given polynomial bound $|y| \\le q(|x|)$.\n- E: Verifying that $y$ is in some NP-complete language is irrelevant and, in general, not known to be doable in deterministic polynomial time unless $\\text{P}=\\text{NP}$; it is unnecessary for verifying membership in $L$.", "answer": "$$\\boxed{C}$$", "id": "1415437"}]}