{"hands_on_practices": [{"introduction": "A Nondeterministic Turing Machine's (NTM) ability to explore multiple computational paths simultaneously is its defining feature. To grasp the power and complexity of nondeterminism, we must first understand the scale of this exploration. This exercise [@problem_id:1417810] asks you to quantify the maximum size of a computation tree at a given depth, providing a foundational understanding of its potential for exponential growth based on the machine's branching factor.", "problem": "A Nondeterministic Turing Machine (NTM) can be thought of as a theoretical computer that explores multiple computational paths in parallel. The set of all possible computation sequences for an NTM on a given input can be represented by a computation tree. The root of this tree is the initial configuration (which includes the machine's starting state, the input on the tape, and the initial head position). A node at depth $d$ in the tree represents a configuration reachable after $d$ computational steps. The children of a node are all the configurations that can be reached from it in a single step according to the machine's transition function.\n\nConsider a particular NTM whose transition function is such that for any configuration, there are at most two possible configurations it can transition to in the next step. Let $k$ be a non-negative integer representing a specific depth in the computation tree.\n\nDetermine the maximum possible number of configurations that can exist at depth $k$ in the computation tree of this NTM. Express your answer as a closed-form analytic expression in terms of $k$.", "solution": "Let $N(k)$ denote the maximum number of configurations at depth $k$ in the computation tree. The transition function allows at most two possible next configurations from any configuration, so the branching factor is at most $2$.\n\nAt the root (depth $0$), there is exactly one configuration, so $N(0)=1$. From any configuration at depth $d$, there are at most $2$ children at depth $d+1$. Therefore, for the maximum case where every node branches to exactly two children at every step, the sequence satisfies the recurrence\n$$\nN(0)=1, \\quad N(k+1)=2\\,N(k).\n$$\nSolving this recurrence by iteration yields\n$$\nN(k)=2^{k}.\n$$\nAlternatively, by induction: the base case $N(0)=1=2^{0}$ holds. Assuming $N(k)=2^{k}$, then $N(k+1)\\leq 2\\,N(k)=2\\cdot 2^{k}=2^{k+1}$, with equality achieved when every node has two children. Hence the maximum possible number of configurations at depth $k$ is $2^{k}$.", "answer": "$$\\boxed{2^{k}}$$", "id": "1417810"}, {"introduction": "After grasping the potential exponential size of a computation tree, it's crucial to understand how it is constructed from a machine's formal definition. This hands-on problem [@problem_id:1417864] requires you to step into the role of the NTM and trace its execution for the first two steps. By manually applying the transition function, you will build a small section of the computation tree, making the abstract concepts of configurations and nondeterministic branching concrete.", "problem": "Consider a Nondeterministic Turing Machine (NTM) designed to decide the language $L = \\{w \\in \\{0,1\\}^* \\mid w \\text{ contains at least one '1'}\\}$. The machine is formally defined as follows:\n*   State set: $Q = \\{q_0, q_{\\text{move}}, q_{\\text{check}}, q_{\\text{acc}}, q_{\\text{rej}}\\}$\n*   Input alphabet: $\\Sigma = \\{0, 1\\}$\n*   Tape alphabet: $\\Gamma = \\{0, 1, \\sqcup\\}$, where $\\sqcup$ is the blank symbol.\n*   Initial state: $q_0$\n*   Accept state: $q_{\\text{acc}}$\n*   Reject state: $q_{\\text{rej}}$\n*   Transition function $\\delta$:\n    1.  $\\delta(q_0, c) = \\{(q_{\\text{move}}, c, R)\\}$ for any $c \\in \\{0, 1\\}$\n    2.  $\\delta(q_{\\text{move}}, c) = \\{(q_{\\text{move}}, c, R), (q_{\\text{check}}, c, S)\\}$ for any $c \\in \\{0, 1\\}$\n    3.  $\\delta(q_{\\text{move}}, \\sqcup) = \\{(q_{\\text{rej}}, \\sqcup, S)\\}$\n    4.  $\\delta(q_{\\text{check}}, 1) = \\{(q_{\\text{acc}}, 1, S)\\}$\n    5.  $\\delta(q_{\\text{check}}, 0) = \\{(q_{\\text{rej}}, 0, S)\\}$\n\nA configuration of the machine is described by the notation $uqv$, which represents that the current state is $q$, the tape contains the string $uv$, and the head is scanning the first symbol of $v$. The initial configuration for an input string $w$ is $q_0w$.\n\nThe computation of an NTM can be visualized as a computation tree, where the root is the initial configuration (level 0), and the nodes at level $k+1$ are all possible configurations reachable in one step from the configurations at level $k$.\n\nGiven the input string $w = 101$, what is the set of all distinct configurations of this NTM at level 2 of the computation tree?\n\nA. $\\{1q_{\\text{move}}01, 1q_{\\text{check}}01\\}$\n\nB. $\\{1q_{\\text{move}}01, q_{\\text{check}}101\\}$\n\nC. $\\{10q_{\\text{move}}1, 1q_{\\text{check}}01, q_{\\text{check}}101\\}$\n\nD. $\\{10q_{\\text{move}}1, 1q_{\\text{check}}01\\}$\n\nE. $\\{10q_{\\text{move}}1, 10q_{\\text{check}}1, 1q_{\\text{check}}01\\}$", "solution": "We use the configuration notation $uqv$, where the tape contains $uv$, the head scans the first symbol of $v$, and the current state is $q$. For input $w=101$, the initial configuration (level $0$) is $q_{0}101$.\n\nFrom $q_{0}$ reading $1$, rule $1$ applies: $\\delta(q_{0},1)=\\{(q_{\\text{move}},1,R)\\}$. Writing $1$ unchanged and moving right yields level $1$ configuration $1q_{\\text{move}}01$.\n\nAt level $2$, we expand from $1q_{\\text{move}}01$. Here, the head reads $0$, and rule $2$ applies: $\\delta(q_{\\text{move}},0)=\\{(q_{\\text{move}},0,R),(q_{\\text{check}},0,S)\\}$.\n- Choosing $(q_{\\text{move}},0,R)$ writes $0$, moves right, and stays in $q_{\\text{move}}$, giving $10q_{\\text{move}}1$.\n- Choosing $(q_{\\text{check}},0,S)$ writes $0$, stays, and switches to $q_{\\text{check}}$, giving $1q_{\\text{check}}01$.\n\nNo other transitions apply at this level (no blank is read, and acceptance from $q_{\\text{check}}$ requires reading $1$, which is not the current symbol in the branch that enters $q_{\\text{check}}$ at this level). Therefore, the set of all distinct configurations at level $2$ is $\\{10q_{\\text{move}}1, 1q_{\\text{check}}01\\}$, which corresponds to option D.", "answer": "$$\\boxed{D}$$", "id": "1417864"}, {"introduction": "Understanding the structure of a computation tree is the first step; the next is to analyze the difficulty of finding a solution within it. This problem [@problem_id:1417816] elevates the discussion by asking you to classify the complexity of a fundamental search problem: finding the lexicographically first accepting path in an NTM's computation tree. This exercise connects the structure of the tree to the sophisticated landscape of function-problem complexity classes, revealing deep truths about the power of oracle computation.", "problem": "Consider a Nondeterministic Turing Machine (NTM). An NTM's computation on a given input string $w$ can be visualized as a computation tree, where the root is the ainitial configuration and children of a node represent configurations reachable in a single step according to the NTM's transition function. A path from the root to a leaf represents a single, complete branch of the nondeterministic computation.\n\nWe make the following simplifying assumptions about the NTMs in this problem:\n1.  **Binary Choices**: At each step of the computation, the NTM has at most two possible moves. We label these choices '0' and '1'. Any path from the root can thus be uniquely described by a binary string representing the sequence of choices made.\n2.  **Polynomial Time**: The NTM is a polynomial-time NTM. This means there exists a polynomial $p(n)$ such that for any input $w$ of length $n=|w|$, every computation path in the tree has a length of at most $p(n)$.\n\nAn accepting path is a path in the computation tree that ends in an accepting state. We compare two paths by comparing their corresponding binary choice strings lexicographically. A binary string $s_1$ is lexicographically smaller than $s_2$ if, at the first position where they differ, $s_1$ has a '0' and $s_2$ has a '1'.\n\nWe define the function problem `LEX_FIRST_PATH` as follows:\n-   **Input**: The description of a polynomial-time NTM $M$ and an input string $w$.\n-   **Output**: The binary choice string corresponding to the lexicographically first accepting path of $M$ on input $w$. If no accepting path exists, the output is a special symbol, `NONE`.\n\nTo analyze the difficulty of this problem, we use the following standard computational complexity classes for function problems:\n-   **FP**: The class of function problems solvable by a deterministic Turing machine in polynomial time.\n-   **FNP**: The class of function problems where a candidate solution can be verified in polynomial time. Formally, a function $f$ is in FNP if there exists a polynomial-time deterministic verifier $V$ and a polynomial $q$ such that for any input $x$, $f(x) = y$ (with $|y| \\leq q(|x|)$) if and only if $V(x, y)$ accepts. The problem of finding a satisfying assignment for a Boolean formula is a canonical example of a problem in FNP.\n-   **FP$^{NP}$**: The class of function problems solvable by a deterministic polynomial-time Turing machine that has access to an oracle for an NP-complete decision problem (such as the Boolean Satisfiability Problem, SAT). The oracle can answer any \"yes/no\" query about membership in the NP-complete language in a single computational step.\n\nA problem is *complete* for a class if it is in that class and is also one of the hardest problems in that class (every other problem in the class can be reduced to it in polynomial time).\n\nWhich of the following statements most accurately describes the complexity of the `LEX_FIRST_PATH` problem?\n\nA. The `LEX_FIRST_PATH` problem is in FP.\n\nB. The `LEX_FIRST_PATH` problem is complete for the class FNP under polynomial-time reductions.\n\nC. The `LEX_FIRST_PATH` problem is complete for the class FP$^{NP}$ under polynomial-time reductions.\n\nD. The `LEX_FIRST_PATH` problem is not computable.\n\nE. The `LEX_FIRST_PATH` problem is in FNP, but is not known to be FNP-complete.", "solution": "We analyze the complexity of the function problem that, given a polynomial-time NTM $M$ and input $w$, outputs the lexicographically first accepting path’s binary choice string, or outputs NONE if no accepting path exists.\n\nMembership in FP$^{NP}$: Let $n=|w|$ and let $p(n)$ be the time bound for $M$; every computation path has length at most $p(n)$. Define the decision oracle language\n$$\nL_{\\mathrm{prefix}}=\\{(M,w,s)\\mid \\text{there exists an accepting path of }M\\text{ on }w\\text{ whose choice string has prefix }s\\}.\n$$\nThis language is in NP: a certificate can be the full accepting computation (or equivalently the full choice string extending $s$ along with the corresponding sequence of configurations), which can be verified in deterministic time polynomial in $|M|+|w|$ because $M$ runs in at most $p(n)$ steps.\n\nUsing this oracle, we can compute the lexicographically first accepting path in deterministic polynomial time as follows. First, query whether $(M,w,\\epsilon)\\in L_{\\mathrm{prefix}}$; if not, output NONE. Otherwise, construct the lexicographically least accepting prefix greedily: for $i=1,2,\\ldots$, given the current prefix $s$, query $(M,w,s0)$. If the oracle answers yes, set $s:=s0$. Otherwise, query $(M,w,s1)$; if yes, set $s:=s1$. If both are no, then no accepting path extends $s$, which can only occur if there is no accepting path at all (ruled out by the initial check). Stop once a full accepting path is determined; since the maximum depth is $p(n)$, this takes at most $2p(n)+1$ oracle queries and polynomial additional time. Thus the function is in FP$^{NP}$.\n\nHardness for FP$^{NP}$: We reduce from the canonical FP$^{NP}$-complete problem of computing the lexicographically first satisfying assignment of a Boolean formula. Given a Boolean formula $\\varphi$ over variables $x_{1},\\ldots,x_{m}$, construct an NTM $M_{\\varphi}$ that on input $w:=\\varphi$ nondeterministically makes exactly $m$ binary choices $b_{1},\\ldots,b_{m}$ (interpreted as an assignment to $(x_{1},\\ldots,x_{m})$), then deterministically evaluates $\\varphi(b_{1},\\ldots,b_{m})$ in polynomial time and accepts iff the evaluation is true. This $M_{\\varphi}$ is polynomial-time, has at most two choices at each step, and the lexicographically first accepting path’s choice string is exactly the lexicographically first satisfying assignment of $\\varphi$, with NONE produced iff $\\varphi$ is unsatisfiable. Therefore, the lex-first satisfying assignment problem many-one reduces in polynomial time to the given problem, showing FP$^{NP}$-hardness. Combined with membership, the problem is FP$^{NP}$-complete.\n\nIt is not in FP unless P=NP (since deciding whether the output is NONE would decide an NP language), it is not in FNP unless NP = co-NP (since verifying minimality requires ruling out any lexicographically smaller accepting path), and it is clearly computable. Hence the most accurate choice is completeness for FP$^{NP}$.", "answer": "$$\\boxed{C}$$", "id": "1417816"}]}