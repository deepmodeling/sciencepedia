{"hands_on_practices": [{"introduction": "Before diving into the complexities of primality, let's warm up with a fundamental exercise in computational thinking. This practice asks us to prove that identifying \"perfect powers\" (numbers like $8=2^3$ or $81=3^4$) is a problem in the class $NP$. The key is to find the most efficient and direct \"proof,\" or certificate, that a verifier can check quickly, which is the essence of designing an $NP$ verification process [@problem_id:1436744].", "problem": "In computational complexity theory, a language $L$ is in the class $NP$ (Non-deterministic Polynomial time) if a proposed solution (called a \"certificate\") for an instance of the problem can be verified in polynomial time.\n\nConsider the language of perfect powers, $L_{\\text{PP}}$, which consists of all positive integers $n$ that can be expressed as $a^k$ for integers $a, k \\ge 2$. An algorithm that determines membership in this language is given an integer $n$ as input. The size of this input is measured by the number of bits required to represent $n$, which we denote as $B = \\lfloor \\log_2 n \\rfloor + 1$. A verifier is considered to run in polynomial time if its runtime is bounded by a polynomial in $B$.\n\nA computer scientist is designing a verifier for $L_{\\text{PP}}$. She has four proposals, each consisting of a certificate to be provided and a verification algorithm. Which of the following proposals correctly and most directly demonstrates that $L_{\\text{PP}}$ is in the class $NP$?\n\nA. **Certificate:** An integer $k \\ge 2$. **Verifier:** Perform a binary search for an integer $a$ in the range $[2, n]$ to check if $a^k = n$.\n\nB. **Certificate:** An integer $a \\ge 2$. **Verifier:** Iterate through all integers $k$ from $2$ up to $n$ and check if $a^k = n$.\n\nC. **Certificate:** A pair of integers $\\langle a, k \\rangle$ where $a, k \\ge 2$. **Verifier:** Compute $a^k$ and check if it equals $n$.\n\nD. **Certificate:** The complete prime factorization of $n$ in the form $p_1^{e_1} p_2^{e_2} \\cdots p_m^{e_m}$. **Verifier:** Check that all $p_i$ are prime, that their powers multiply to $n$, and that the greatest common divisor of the exponents $\\{e_1, e_2, \\dots, e_m\\}$ is greater than 1.", "solution": "We recall the $NP$ verifier definition: there exists a polynomial $p$ such that for every input $x$ of length $|x|$, there exists a certificate $y$ with $|y| \\leq p(|x|)$ and a deterministic verifier $V$ that runs in time polynomial in $|x|$ and accepts if and only if $x$ is in the language. Here, the input is a positive integer $n$ with bit-length $B=\\lfloor \\log_{2} n \\rfloor + 1$. We denote by $M(B)$ the time to multiply two $B$-bit integers on the standard RAM model; $M(B)$ is polynomial in $B$. Fast exponentiation by repeated squaring uses $O(\\log k)$ multiplications.\n\nWe analyze each proposal for certificate length and verifier runtime in terms of $B$.\n\nA. Certificate: an integer $k \\geq 2$. Since $n=a^{k}$ with $a \\geq 2$ implies $2^{k} \\leq n$, any valid certificate satisfies $k \\leq \\log_{2} n$, hence its bit-length is $O(\\log k) \\leq O(\\log \\log n)=O(\\log B)$, which is polynomial in $B$. The verifier binary searches $a$ in $[2,n]$. The function $f(a)=a^{k}$ is strictly increasing in $a \\geq 1$, so binary search takes $O(\\log n)=O(B)$ iterations. In each iteration, computing $a^{k}$ by repeated squaring takes $O(\\log k)$ multiplications, and we can abort early if an intermediate value exceeds $n$, so all intermediates have at most $B$ bits. Thus a single exponentiation costs $O(M(B)\\log k) \\leq O(M(B)\\log B)$. The total time is $O(B \\cdot M(B) \\cdot \\log B)$, which is polynomial in $B$. Therefore A is a valid $NP$ verification procedure.\n\nB. Certificate: an integer $a \\geq 2$. The certificate length is $O(\\log a) \\leq O(B)$, but the verifier iterates $k$ from $2$ up to $n$, which is $\\Theta(n)$ iterations. Since $n$ has $B$ bits, $n$ can be as large as $2^{B}$, so a loop of length $\\Theta(n)$ is exponential in $B$ and not polynomial. Therefore B does not demonstrate membership in $NP$.\n\nC. Certificate: a pair $\\langle a,k \\rangle$ with $a,k \\geq 2$. Since $a^{k}=n$ and $a \\geq 2$ imply $a \\leq n$ and $k \\leq \\log_{2} n$, the certificate length is $O(\\log a + \\log k) \\leq O(B + \\log B)=O(B)$. The verifier computes $a^{k}$ by repeated squaring, aborting if an intermediate exceeds $n$, ensuring all intermediates have at most $B$ bits. This takes $O(\\log k)$ multiplications, so $O(M(B)\\log k) \\leq O(M(B) B)$ time, plus an $O(B)$ comparison with $n$. Hence the verification runs in time polynomial in $B$. This is the simplest and most direct $NP$ certificate: it supplies exactly the witness $\\langle a,k \\rangle$ and checks $a^{k}=n$.\n\nD. Certificate: the prime factorization $n=\\prod_{i=1}^{m} p_{i}^{e_{i}}$. The size of this certificate is $O\\!\\left(\\sum_{i=1}^{m} \\log p_{i} + \\sum_{i=1}^{m} \\log e_{i}\\right)$. Since $\\sum \\log p_{i} \\leq \\log n = O(B)$ and each $e_{i} \\leq \\log_{2} n$ with $m \\leq B$, we have $\\sum \\log e_{i} \\leq m \\log \\log n = O(B \\log B)$. Thus the certificate length is polynomial in $B$. The verifier checks primality of each $p_{i}$ deterministically in polynomial time (e.g., via AKS), multiplies $\\prod p_{i}^{e_{i}}$ and compares with $n$ in $O(B \\cdot M(B))$ time, and computes $\\gcd(e_{1},\\dots,e_{m})$ in time polynomial in $\\log \\max e_{i} \\leq O(\\log B)$. Therefore D is also a valid $NP$ verification procedure.\n\nAmong the valid proposals, C is the most direct demonstration that $L_{\\text{PP}} \\in \\text{NP}$ because it uses the natural witness $\\langle a,k \\rangle$ and a straightforward polynomial-time check $a^{k}=n$ without auxiliary heavy subroutines or additional search.", "answer": "$$\\boxed{C}$$", "id": "1436744"}, {"introduction": "Now, let's apply our understanding of certificates to a problem closer to primality. To show that the language of prime numbers is in $\\text{co-NP}$, we must first show that its complement, the language of composite numbers, is in $NP$. This practice focuses on a large subset of composite numbers: those with at least two distinct prime factors. Your task is to identify a valid certificate that proves a number $n$ fits this description, a crucial step in building a verifier for composite numbers [@problem_id:1436748].", "problem": "In computational complexity theory, a key concept is that of a \"certificate\" or \"witness.\" For a given language $L$ (a set of strings, or in this case, integers), a certificate for an input $n$ is a piece of information $y$ that allows a verifier algorithm to efficiently confirm that $n$ is indeed in $L$. A verifier $V(n, y)$ must run in time polynomial in the size of $n$ (i.e., polynomial in $\\log_2 n$) and must satisfy two conditions:\n1.  **Completeness**: For every $n \\in L$, there exists a certificate $y$ (of size polynomial in $\\log_2 n$) such that $V(n,y)$ accepts.\n2.  **Soundness**: For any $n \\notin L$, the verifier $V(n,y)$ must reject for all possible certificates $y$.\n\nConsider the language $L$ of positive integers that are composed of at least two distinct prime factors. For example, $12 = 2^2 \\cdot 3$ is in $L$, but $17$ (a prime) and $8 = 2^3$ (a prime power) are not.\n\nWhich of the following proposals for a certificate $y$ are valid for demonstrating that an integer $n$ belongs to the language $L$?\n\nA. Two integers $u,v$ such that $u > 1$, $v > 1$, and $n = uv$.\nB. A single integer $d$ such that $1 < d < n$ and $d$ divides $n$.\nC. Two integers $u,v$ such that $u > 1$, $v > 1$, $n = uv$, and their greatest common divisor $\\gcd(u,v) = 1$.\nD. A prime number $p$ that divides $n$, and an integer $m > 1$ such that $m$ also divides $n$ and $\\gcd(p,m) = 1$.\nE. Two distinct prime numbers $p_1, p_2$ that both divide $n$.\n\nSelect all valid options.", "solution": "We formalize the language $L$ as the set of positive integers $n$ whose prime factorization contains at least two distinct primes. Equivalently, $n \\in L$ if and only if there exist distinct primes $p_{1}$ and $p_{2}$ such that $p_{1} \\mid n$ and $p_{2} \\mid n$.\n\nA certificate $y$ for $n \\in L$ must allow a deterministic verifier $V(n,y)$ to check in time polynomial in $\\log_{2}(n)$ that $n$ indeed has at least two distinct prime factors. We evaluate each proposal both for soundness (it must never accept $n \\notin L$) and completeness (for every $n \\in L$, some such certificate exists), and we ensure that the verification work is polynomial in the bit-length of $n$.\n\nPreliminaries about efficient checks:\n- Divisibility checks “$a \\mid b$”, equality checks, and computing $\\gcd(a,b)$ via the Euclidean algorithm all run in time polynomial in the bit-lengths of the inputs, hence polynomial in $\\log_{2}(n)$.\n- Primality of a claimed prime can be verified deterministically in polynomial time in the bit-length (e.g., AKS primality test). Thus, checking that an integer is prime is feasible within the verifier’s time bound.\n- The certificate size must be polynomial in $\\log_{2}(n)$; all integers provided as factors or primes are at most $n$, hence their encodings are $O(\\log_{2}(n))$ bits.\n\nOption A: Two integers $u,v$ with $u>1$, $v>1$, and $n=uv$.\n- Verification: Check $u>1$, $v>1$, and $uv=n$. This is polynomial time.\n- Soundness: This fails. Consider $n$ a prime power, e.g., $n=2^{3}$. Taking $u=2$, $v=2^{2}$ satisfies $u>1$, $v>1$, and $uv=n$, yet $n \\notin L$. Hence there exist $n \\notin L$ with a certificate that would be accepted. Therefore A is not sound and is invalid.\n\nOption B: A single integer $d$ with $1<d<n$ and $d \\mid n$.\n- Verification: Check $1<d<n$ and $d \\mid n$. This is polynomial time.\n- Soundness: This fails for the same reason as A. If $n$ is a prime power, e.g., $n=2^{3}$, then $d=2$ is a valid divisor with $1<d<n$, yet $n \\notin L$. Therefore B is not sound and is invalid.\n\nOption C: Two integers $u,v$ with $u>1$, $v>1$, $n=uv$, and $\\gcd(u,v)=1$.\n- Verification: Check $u>1$, $v>1$, $uv=n$, and $\\gcd(u,v)=1$. All are polynomial time.\n- Soundness: Suppose the verifier accepts, i.e., $u>1$, $v>1$, $n=uv$, and $\\gcd(u,v)=1$. Since $u>1$ and $v>1$, each has at least one prime factor, say $p \\mid u$ and $q \\mid v$. The condition $\\gcd(u,v)=1$ implies $p \\neq q$. Because $p \\mid u$ and $u \\mid n$, we have $p \\mid n$, and similarly $q \\mid n$. Thus $n$ has at least two distinct prime divisors and hence $n \\in L$. Therefore soundness holds.\n- Completeness: If $n \\in L$, write $n=\\prod_{i=1}^{k} p_{i}^{\\alpha_{i}}$ with $k \\geq 2$ and distinct primes $p_{i}$. Choose any index $j$ and set $u=p_{j}^{\\alpha_{j}}$ and $v=n/u=\\prod_{i \\neq j} p_{i}^{\\alpha_{i}}$. Then $u>1$, $v>1$, $uv=n$, and $\\gcd(u,v)=1$ because they share no prime factor. Hence such a certificate exists. Therefore completeness holds. Thus C is valid.\n\nOption D: A prime $p$ with $p \\mid n$, and an integer $m>1$ with $m \\mid n$ and $\\gcd(p,m)=1$.\n- Verification: Check that $p$ is prime, $p \\mid n$, $m>1$, $m \\mid n$, and $\\gcd(p,m)=1$. All checks are polynomial time in $\\log_{2}(n)$ (primality via a polynomial-time primality test).\n- Soundness: If the verifier accepts, then $p \\mid n$ with $p$ prime, and $m \\mid n$ with $m>1$ and $\\gcd(p,m)=1$. Since $m>1$, $m$ has a prime divisor $q$. The condition $\\gcd(p,m)=1$ implies $q \\neq p$. Also, $q \\mid m$ and $m \\mid n$ imply $q \\mid n$. Thus $n$ has at least two distinct primes $p$ and $q$ dividing it, so $n \\in L$. Hence soundness holds.\n- Completeness: If $n \\in L$ has factorization $n=\\prod_{i=1}^{k} p_{i}^{\\alpha_{i}}$ with $k \\geq 2$, choose $p=p_{1}$ and $m=\\prod_{i=2}^{k} p_{i}^{\\alpha_{i}}$. Then $p \\mid n$, $m>1$, $m \\mid n$, and $\\gcd(p,m)=1$. Therefore completeness holds. Thus D is valid.\n\nOption E: Two distinct primes $p_{1},p_{2}$ that both divide $n$.\n- Verification: Check $p_{1}$ is prime, $p_{2}$ is prime, $p_{1} \\neq p_{2}$, and $p_{1} \\mid n$, $p_{2} \\mid n$. All are polynomial time.\n- Soundness: If accepted, then $n$ has two distinct prime divisors $p_{1}$ and $p_{2}$, so $n \\in L$. Thus soundness holds.\n- Completeness: If $n \\in L$, by definition there exist two distinct primes dividing $n$. Providing them yields acceptance. Thus completeness holds. Therefore E is valid.\n\nConclusion: Options C, D, and E are valid certificates; A and B are invalid due to lack of soundness.", "answer": "$$\\boxed{CDE}$$", "id": "1436748"}, {"introduction": "We now tackle the concept of $\\text{co-NP}$ head-on. A language $L$ is in $\\text{co-NP}$ if its complement, $\\bar{L}$, is in $NP$. This exercise guides you through this exact process by asking you to design a certificate for the complement of a given language related to prime factors. By successfully finding a witness for non-membership that can be verified in polynomial time, you will demonstrate that the original language belongs to $\\text{co-NP}$ [@problem_id:1436745].", "problem": "Consider the language $L$ defined over pairs of positive integers $\\langle n, k \\rangle$, where $n > 1$ and $k > 1$. An input string $\\langle n, k \\rangle$ is in the language $L$ if and only if all prime factors of $n$ are greater than or equal to $k$.\n\nThe complexity class $NP$ (Nondeterministic Polynomial time) consists of decision problems for which a 'yes' instance can be verified in polynomial time by a deterministic Turing machine, given a suitable string of information called a certificate or witness. The complexity class $\\text{co-NP}$ consists of languages whose complements are in $NP$.\n\nTo prove that the language $L$ is in $\\text{co-NP}$, one must show that its complement, $\\bar{L}$, belongs to $NP$. Demonstrating that $\\bar{L} \\in \\text{NP}$ requires identifying a certificate that proves membership in $\\bar{L}$, along with a verifier algorithm that runs in polynomial time with respect to the size of the input $\\langle n, k \\rangle$. Recall that an input $\\langle n, k \\rangle$ is in $\\bar{L}$ if and only if there exists at least one prime factor of $n$ that is strictly less than $k$.\n\nWhich of the following describes a valid certificate and the corresponding checks that a polynomial-time verifier must perform to confirm that an input $\\langle n, k \\rangle$ is a member of the language $\\bar{L}$?\n\nA. The certificate is an integer $p$. The verifier's algorithm checks if $p < k$ and if $n \\pmod p = 0$.\nB. The certificate is an integer $p$. The verifier's algorithm checks if $p < k$, if $n \\pmod p = 0$, and if $p$ is a prime number.\nC. The certificate is the complete prime factorization of $n$. The verifier's algorithm multiplies the factors to confirm they equal $n$ and then checks if at least one prime factor $p$ in the factorization satisfies $p < k$.\nD. The certificate is a pair of integers $\\langle p, a \\rangle$. The verifier's algorithm checks if $p < k$, if $p$ is a prime number, and if $p^a$ is the largest power of $p$ that divides $n$.\nE. No such polynomial-time verifiable certificate exists because the problem of finding the prime factors of an integer is believed to be computationally difficult, thus $\\bar{L}$ is not in $NP$.", "solution": "We are given the language $L=\\{\\langle n,k\\rangle: n>1, k>1, \\text{ and every prime factor of } n \\text{ is } \\geq k\\}$. Its complement is $\\bar{L}=\\{\\langle n,k\\rangle: n>1, k>1, \\text{ and there exists a prime factor } p \\text{ of } n \\text{ with } p<k\\}$.\n\nTo show $\\bar{L}\\in\\text{NP}$, we must exhibit a certificate and a polynomial-time verifier such that $\\langle n,k\\rangle\\in\\bar{L}$ if and only if there exists a certificate that the verifier accepts.\n\nThe natural certificate is a single prime $p$ with $p<k$ and $p\\mid n$. Given such a $p$, the verifier must:\n- Check $p<k$ by integer comparison, which runs in time polynomial in the input size.\n- Check $p\\mid n$ by computing $n\\bmod p$ and verifying it equals $0$, which is polynomial-time in the lengths of $n$ and $p$.\n- Check that $p$ is prime. Primality testing is in $P$ (for example, via the AKS algorithm), so this check is polynomial-time.\n\nTherefore, a certificate consisting of a prime $p$ together with the checks $p<k$, $p\\mid n$, and primality of $p$ suffices to place $\\bar{L}$ in $\\text{NP}$.\n\nNow evaluate the options:\n\n- Option A omits any condition ruling out $p=1$. Since $1<k$ and $n\\bmod 1=0$ for all $n>1$, this would cause the verifier to accept every input, so it is unsound as stated.\n\n- Option B specifies the certificate as an integer $p$ and has the verifier check $p<k$, $p\\mid n$, and that $p$ is prime. Each check is polynomial-time, and the existence of such a $p$ is exactly the definition of $\\langle n,k\\rangle\\in\\bar{L}$. Hence B is valid.\n\n- Option C proposes the complete prime factorization as the certificate and has the verifier multiply the factors to get $n$ and check that some listed prime $p$ satisfies $p<k$. As written, it does not include verifying that the listed factors are prime; a verifier may not trust that claim without checking. Thus the described checks are incomplete for soundness as stated.\n\n- Option D uses a pair $\\langle p,a\\rangle$ with checks that $p<k$, $p$ is prime, and $p^{a}$ is the largest power of $p$ dividing $n$. These checks are all polynomial-time, but the extra largest-power condition is unnecessary. Nevertheless, the option remains a valid certificate-verifier pair because it still ensures that a prime $p<k$ divides $n$.\n\n- Option E is incorrect because verification does not require finding the full factorization; exhibiting and checking a single small prime factor is sufficient, and primality testing is polynomial-time.\n\nAmong the listed options, the standard, minimal, and fully correct description is given by Option B.", "answer": "$$\\boxed{B}$$", "id": "1436745"}]}