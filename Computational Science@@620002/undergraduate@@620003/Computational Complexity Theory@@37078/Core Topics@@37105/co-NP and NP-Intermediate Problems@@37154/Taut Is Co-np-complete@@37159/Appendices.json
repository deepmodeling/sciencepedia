{"hands_on_practices": [{"introduction": "To understand the complexity of the Tautology problem (`TAUT`), we first need to connect it to known hard problems. This practice focuses on the fundamental relationship between a formula being unsatisfiable and its negation being a tautology, a cornerstone of co-NP theory. Mastering this transformation is the first step toward proving that `TAUT` is co-NP-complete [@problem_id:1449002].", "problem": "In computational complexity theory, showing that a problem is hard for a certain complexity class often involves a reduction from a known hard problem. A cornerstone of this field is the relationship between the satisfiability problem and the tautology problem.\n\nLet a boolean formula $\\phi$ be given in 3-Conjunctive Normal Form (3-CNF). A formula is in 3-CNF if it is a conjunction (AND) of clauses, where each clause is a disjunction (OR) of exactly three distinct literals (a variable or its negation).\n\nA boolean formula is said to be **unsatisfiable** if it evaluates to False for every possible assignment of truth values to its variables. The problem of determining if a 3-CNF formula is unsatisfiable is known as 3-UNSAT.\nA boolean formula is called a **tautology** if it evaluates to True for every possible assignment of truth values to its variables. The problem of determining if a formula is a tautology is known as TAUT.\n\nYour task is to find a general transformation that constructs a new formula, $\\psi$, from an arbitrary 3-CNF formula, $\\phi$, such that $\\phi$ is unsatisfiable if and only if $\\psi$ is a tautology. Which of the following constructions correctly defines such a $\\psi$?\n\nA. $\\psi = \\phi$\n\nB. $\\psi = \\neg \\phi$\n\nC. Let $\\phi = C_1 \\land C_2 \\land \\dots \\land C_k$, where each $C_i$ is a clause. The new formula is $\\psi = (\\neg C_1) \\land (\\neg C_2) \\land \\dots \\land (\\neg C_k)$.\n\nD. Let $\\phi = C_1 \\land C_2 \\land \\dots \\land C_k$, where each $C_i$ is a clause. The new formula is $\\psi = C_1 \\lor C_2 \\lor \\dots \\lor C_k$.\n\nE. Let $x$ be one of the boolean variables appearing in $\\phi$. The new formula is $\\psi = \\phi \\land (x \\lor \\neg x)$.", "solution": "We seek a transformation that, for any given 3-CNF formula $\\phi$, produces a formula $\\psi$ such that $\\phi$ is unsatisfiable if and only if $\\psi$ is a tautology.\n\nLet $\\sigma$ range over all truth assignments to the variables of $\\phi$. Write $\\phi[\\sigma]$ for the truth value of $\\phi$ under $\\sigma$. By definition:\n- $\\phi$ is unsatisfiable if and only if $\\forall \\sigma,\\ \\phi[\\sigma] = \\mathrm{False}$.\n- $\\psi$ is a tautology if and only if $\\forall \\sigma,\\ \\psi[\\sigma] = \\mathrm{True}$.\n\nConsider the transformation $\\psi = \\neg \\phi$. Boolean semantics of negation satisfy, for every $\\sigma$,\n$$(\\neg \\phi)[\\sigma] = \\neg\\big(\\phi[\\sigma]\\big).$$\nTherefore,\n$$\\phi \\text{ unsatisfiable} \\iff \\forall \\sigma,\\ \\phi[\\sigma] = \\mathrm{False} \\iff \\forall \\sigma,\\ \\neg\\big(\\phi[\\sigma]\\big) = \\mathrm{True} \\iff \\forall \\sigma,\\ (\\neg \\phi)[\\sigma] = \\mathrm{True} \\iff \\neg \\phi \\text{ is a tautology}.$$\nThus the correct construction is $\\psi = \\neg \\phi$, which is option B.\n\nTo confirm the other options are incorrect:\n- A: $\\psi = \\phi$ cannot satisfy the biconditional in general, since an unsatisfiable formula is never a tautology.\n- C: If $\\phi = \\bigwedge_{i=1}^{k} C_{i}$, then $\\psi = \\bigwedge_{i=1}^{k} \\neg C_{i} = \\neg\\big(\\bigvee_{i=1}^{k} C_{i}\\big)$ by De Morgan’s law, which is not $\\neg \\phi = \\bigvee_{i=1}^{k} \\neg C_{i}$; hence it does not implement the required equivalence.\n- D: $\\psi = \\bigvee_{i=1}^{k} C_{i}$ does not become a tautology exactly when $\\phi$ is unsatisfiable; unsatisfiability of $\\phi$ does not imply that every assignment makes at least one $C_{i}$ true, which would be required for this disjunction to be a tautology.\n- E: $\\psi = \\phi \\land (x \\lor \\neg x)$ is logically equivalent to $\\phi$ because $x \\lor \\neg x$ is a tautology, so it does not convert an arbitrary $\\phi$ into a tautology exactly when $\\phi$ is unsatisfiable.\n\nTherefore, the only correct transformation among the options is $\\psi = \\neg \\phi$ (option B).", "answer": "$$\\boxed{B}$$", "id": "1449002"}, {"introduction": "Complexity theory often reveals powerful connections between decision problems (answering \"yes\" or \"no\") and search problems (finding a solution). This exercise demonstrates a classic search-to-decision reduction, where we use a hypothetical oracle for the `TAUT` decision problem to solve a search problem. By following this algorithmic process, you will find a specific \"falsifying assignment\" for a non-tautological formula, making abstract concepts like oracles and reductions tangible and practical [@problem_id:1448990].", "problem": "In computational complexity theory, an oracle for a decision problem is a hypothetical black box that can solve that problem in a single step. Consider an oracle, `IS_TAUT`, which determines if a given Boolean formula is a tautology. A formula is a tautology if it evaluates to True for every possible truth assignment to its variables.\n\nSuppose you are given a Boolean formula $\\phi(x_1, x_2, \\ldots, x_n)$ in $n$ variables, and you know that $\\phi$ is *not* a tautology. This means there exists at least one \"falsifying assignment\"—a specific set of True/False values for the variables—that makes the formula $\\phi$ evaluate to False.\n\nThere exists a standard polynomial-time algorithm that finds one such falsifying assignment, given access to the `IS_TAUT` oracle. This algorithm operates by sequentially determining the truth value for each variable, from $x_1$ to $x_n$. To do this, it constructs new formulas by substituting truth values for variables and queries the oracle to decide which path preserves the possibility of a falsifying assignment.\n\nConsider the specific Boolean formula $\\phi(x_1, x_2, x_3, x_4)$ defined as:\n$$ \\phi = ((\\neg x_1) \\land x_2) \\lor (x_1 \\land (\\neg x_3)) \\lor (x_2 \\implies x_4) $$\nUsing the standard search-to-decision reduction algorithm that determines variable assignments in the order $x_1, x_2, x_3, x_4$, find the specific falsifying assignment that the algorithm outputs for this formula $\\phi$. In this standard algorithm, at each step to determine the value for a variable $x_i$, the algorithm first checks if a falsifying assignment can be found by setting $x_i$ to True.\n\nLet the truth values be represented by 1 for True and 0 for False. The final answer should be a sequence of four numbers representing the truth values for $(x_1, x_2, x_3, x_4)$.", "solution": "The goal is to find a falsifying assignment for the given Boolean formula $\\phi$ using an oracle for TAUT. A falsifying assignment is a set of truth values for $(x_1, x_2, x_3, x_4)$ that makes $\\phi$ evaluate to False (0). The specified algorithm determines the values for $x_1, x_2, x_3, x_4$ in order. For each variable $x_i$, it first tries setting $x_i=1$ (True). It constructs a new formula by substituting this value and asks the `IS_TAUT` oracle if the resulting formula is a tautology. If the oracle says `False`, it means a falsifying assignment exists with $x_i=1$, so we fix $x_i=1$. If the oracle says `True`, then any falsifying assignment for the original formula must have $x_i=0$, so we fix $x_i=0$.\n\nThe initial formula is $\\phi_0(x_1, x_2, x_3, x_4) = ((\\neg x_1) \\land x_2) \\lor (x_1 \\land (\\neg x_3)) \\lor (x_2 \\implies x_4)$.\nWe can simplify the implication: $x_2 \\implies x_4 \\equiv (\\neg x_2) \\lor x_4$.\nSo, $\\phi_0 = ((\\neg x_1) \\land x_2) \\lor (x_1 \\land (\\neg x_3)) \\lor ((\\neg x_2) \\lor x_4)$.\n\n**Step 1: Determine the value for $x_1$.**\nLet's try setting $x_1=1$. The new formula, $\\phi_1$, is $\\phi_0$ with $x_1=1$:\n$$ \\phi_1(x_2, x_3, x_4) = ((\\neg 1) \\land x_2) \\lor (1 \\land (\\neg x_3)) \\lor ((\\neg x_2) \\lor x_4) $$\n$$ \\phi_1 = (0 \\land x_2) \\lor (\\neg x_3) \\lor ((\\neg x_2) \\lor x_4) $$\n$$ \\phi_1 = 0 \\lor (\\neg x_3) \\lor (\\neg x_2) \\lor x_4 $$\n$$ \\phi_1 = (\\neg x_2) \\lor (\\neg x_3) \\lor x_4 $$\nWe query the oracle: `IS_TAUT`($\\phi_1$)? The formula $\\phi_1$ is not a tautology. For example, if $x_2=1, x_3=1, x_4=0$, then $\\phi_1 = (\\neg 1) \\lor (\\neg 1) \\lor 0 = 0 \\lor 0 \\lor 0 = 0$. Since a falsifying assignment exists for $\\phi_1$, it is not a tautology.\nThe oracle returns `False`.\nTherefore, the algorithm fixes $b_1 = 1$. Our working formula for the next steps is $\\phi_1$.\n\n**Step 2: Determine the value for $x_2$.**\nOur current formula is $\\phi_1(x_2, x_3, x_4) = (\\neg x_2) \\lor (\\neg x_3) \\lor x_4$.\nLet's try setting $x_2=1$. The new formula, $\\phi_2$, is $\\phi_1$ with $x_2=1$:\n$$ \\phi_2(x_3, x_4) = (\\neg 1) \\lor (\\neg x_3) \\lor x_4 $$\n$$ \\phi_2 = 0 \\lor (\\neg x_3) \\lor x_4 $$\n$$ \\phi_2 = (\\neg x_3) \\lor x_4 $$\nWe query the oracle: `IS_TAUT`($\\phi_2$)? The formula $\\phi_2$ is not a tautology, as it is false for $x_3=1, x_4=0$.\nThe oracle returns `False`.\nTherefore, the algorithm fixes $b_2 = 1$. Our working formula for the next step is $\\phi_2$.\n\n**Step 3: Determine the value for $x_3$.**\nOur current formula is $\\phi_2(x_3, x_4) = (\\neg x_3) \\lor x_4$.\nLet's try setting $x_3=1$. The new formula, $\\phi_3$, is $\\phi_2$ with $x_3=1$:\n$$ \\phi_3(x_4) = (\\neg 1) \\lor x_4 $$\n$$ \\phi_3 = 0 \\lor x_4 $$\n$$ \\phi_3 = x_4 $$\nWe query the oracle: `IS_TAUT`($\\phi_3$)? The formula $\\phi_3=x_4$ is not a tautology, as it is false for $x_4=0$.\nThe oracle returns `False`.\nTherefore, the algorithm fixes $b_3 = 1$. Our working formula is now $\\phi_3$.\n\n**Step 4: Determine the value for $x_4$.**\nOur current formula is $\\phi_3(x_4) = x_4$.\nLet's try setting $x_4=1$. The new formula, $\\phi_4$, is $\\phi_3$ with $x_4=1$:\n$$ \\phi_4 = 1 $$\nWe query the oracle: `IS_TAUT`($\\phi_4$)? The formula `1` (or True) is always true, so it is a tautology by definition.\nThe oracle returns `True`.\nBecause setting $x_4=1$ resulted in a tautology, any falsifying assignment for $\\phi_3$ must have $x_4 \\neq 1$.\nTherefore, the algorithm fixes $b_4 = 0$.\n\nCombining the results from all steps, the algorithm finds the falsifying assignment $(b_1, b_2, b_3, b_4) = (1, 1, 1, 0)$.\n\nLet's verify this result.\n$\\phi(1, 1, 1, 0) = ((\\neg 1) \\land 1) \\lor (1 \\land (\\neg 1)) \\lor (1 \\implies 0)$\n$= (0 \\land 1) \\lor (1 \\land 0) \\lor 0$\n$= 0 \\lor 0 \\lor 0$\n$= 0$\nThe assignment correctly falsifies the formula.", "answer": "$$\\boxed{\\begin{pmatrix} 1 & 1 & 1 & 0 \\end{pmatrix}}$$", "id": "1448990"}, {"introduction": "The difficulty of a problem often lies in subtle properties that simple heuristics fail to capture. This exercise challenges you to critically analyze a plausible but flawed algorithm for determining if a formula in Disjunctive Normal Form (DNF) is a tautology. By constructing counterexamples, you will explore why problems like `DNF-TAUT` are computationally hard and develop a deeper intuition for the gap between simple syntactic checks and true semantic understanding [@problem_id:1448991].", "problem": "In computational complexity theory, we study the resources required to solve problems. A central topic is the analysis of Boolean formulas. A Boolean formula is an expression involving variables that can be either TRUE or FALSE, and logical operators like AND ($\\land$), OR ($\\lor$), and NOT ($\\neg$). A *literal* is either a variable ($x_i$) or its negation ($\\neg x_i$). A formula is in *Conjunctive Normal Form (CNF)* if it is a conjunction (AND) of clauses, where each clause is a disjunction (OR) of literals. A formula is in *Disjunctive Normal Form (DNF)* if it is a disjunction (OR) of terms, where each term is a conjunction (AND) of literals.\n\nA formula is a *tautology* if it evaluates to TRUE for every possible assignment of TRUE/FALSE values to its variables. The problem of determining if a formula is a tautology is known as the TAUTOLOGY problem. The difficulty of this problem depends on the structure of the formula. For CNF formulas, checking for tautology is computationally easy (in the complexity class P). However, for DNF formulas, it is believed to be hard (it is co-NP-complete).\n\nA computer science student, unaware of the inherent difficulty, proposes a simple, efficient (polynomial-time) algorithm for the DNF-TAUTOLOGY problem. Given a DNF formula $\\psi$ over a set of variables $V = \\{x_1, x_2, \\dots, x_n\\}$, the student's algorithm is as follows:\n\n**Proposed Algorithm:**\n\"Declare the DNF formula $\\psi$ to be a tautology if and only if for every variable $x_i$ in the set $V$, the collection of all literals appearing anywhere in the formula $\\psi$ contains both the literal $x_i$ and its negation $\\neg x_i$.\"\n\nYour task is to analyze the correctness of this proposed algorithm. Which of the following statements accurately describes its performance?\n\nA. The algorithm is correct. It correctly identifies all DNF tautologies and rejects all non-tautologies.\n\nB. The algorithm is incorrect. It produces false negatives (i.e., it may reject a formula that is a tautology) but it never produces false positives.\n\nC. The algorithm is incorrect. It produces false positives (i.e., it may accept a formula that is not a tautology) but it never produces false negatives.\n\nD. The algorithm is incorrect. It can produce both false negatives and false positives.\n\nE. The algorithm cannot be correct because deciding tautology for DNF formulas is known to be in the complexity class P, and this algorithm is unnecessarily restrictive.", "solution": "We formalize the student’s condition. Let $\\psi$ be a DNF formula over variables $V=\\{x_{1},\\dots,x_{n}\\}$, i.e., $\\psi$ is a disjunction of terms, where each term is a conjunction of literals. Define the condition\n$$ C(\\psi):\\quad \\text{for every }x_{i}\\in V,\\text{ the set of literals occurring anywhere in }\\psi\\text{ contains both }x_{i}\\text{ and }\\neg x_{i}. $$\nThe proposed algorithm declares $\\psi$ a tautology if and only if $C(\\psi)$ holds. We analyze whether $C(\\psi)$ is necessary and/or sufficient for $\\psi$ to be a tautology.\n\nFirst, show $C(\\psi)$ is not necessary by giving a tautology that fails $C(\\psi)$. Consider\n$$ \\psi_{\\mathrm{FN}} = x_{1}\\vee\\neg x_{1}\\vee x_{2}. $$\nBy the law of excluded middle, for every assignment $\\alpha$ to $(x_{1},x_{2})$ we have $x_{1}(\\alpha)\\vee\\neg x_{1}(\\alpha)=1$, hence\n$$ \\psi_{\\mathrm{FN}}(\\alpha) = \\big(x_{1}(\\alpha)\\vee\\neg x_{1}(\\alpha)\\big)\\vee x_{2}(\\alpha) = 1. $$\nTherefore $\\psi_{\\mathrm{FN}}$ is a tautology. However, the set of literals appearing in $\\psi_{\\mathrm{FN}}$ is $\\{x_{1},\\neg x_{1},x_{2}\\}$, which does not contain $\\neg x_{2}$. Thus $C(\\psi_{\\mathrm{FN}})$ is false, so the algorithm rejects $\\psi_{\\mathrm{FN}}$ even though it is a tautology. This is a false negative.\n\nSecond, show $C(\\psi)$ is not sufficient by giving a non-tautology that satisfies $C(\\psi)$. Consider\n$$ \\psi_{\\mathrm{FP}} = (x_{1}\\wedge x_{2}) \\vee (\\neg x_{1}\\wedge x_{2}) \\vee (x_{1}\\wedge \\neg x_{2}). $$\nThe set of literals appearing in $\\psi_{\\mathrm{FP}}$ is $\\{x_{1},\\neg x_{1},x_{2},\\neg x_{2}\\}$, so $C(\\psi_{\\mathrm{FP}})$ holds and the algorithm accepts. But evaluate $\\psi_{\\mathrm{FP}}$ on the assignment $\\alpha$ with $x_{1}(\\alpha)=0$ and $x_{2}(\\alpha)=0$:\n$$ (x_{1}\\wedge x_{2})(\\alpha) = 0\\wedge 0 = 0, $$\n$$ (\\neg x_{1}\\wedge x_{2})(\\alpha) = 1\\wedge 0 = 0, $$\n$$ (x_{1}\\wedge \\neg x_{2})(\\alpha) = 0\\wedge 1 = 0, $$\nhence\n$$ \\psi_{\\mathrm{FP}}(\\alpha)=0\\vee 0\\vee 0=0. $$\nTherefore $\\psi_{\\mathrm{FP}}$ is not a tautology, yet the algorithm accepts it. This is a false positive.\n\nSince there exist both a tautology that the algorithm rejects and a non-tautology that it accepts, the algorithm is incorrect in both directions. Consequently, among the given options, the accurate description is that it can produce both false negatives and false positives.\n\nFor completeness, note that option E is factually incorrect about the complexity class: DNF-TAUTOLOGY is co-NP-complete, not in P (unless P=NP), and this does not by itself preclude correctness of any specific proposed algorithm; it is the explicit counterexamples above that refute correctness.", "answer": "$$\\boxed{D}$$", "id": "1448991"}]}