{"hands_on_practices": [{"introduction": "The journey into understanding graph isomorphism often begins by identifying properties, known as graph invariants, that must be identical for any two isomorphic graphs. This exercise challenges the common misconception that having the same number of vertices and edges is sufficient for two graphs to be structurally identical [@problem_id:1507594]. By working through this problem, you will learn the critical importance of using stronger invariants, such as connectivity, to definitively prove that two graphs are not isomorphic.", "problem": "In graph theory, a simple graph is an unweighted, undirected graph containing no loops or multiple edges. Two simple graphs $G_A = (V_A, E_A)$ and $G_B = (V_B, E_B)$ are said to be isomorphic if there exists a bijection (a one-to-one correspondence) $f: V_A \\to V_B$ such that any two vertices $u$ and $v$ in $V_A$ are adjacent if and only if the vertices $f(u)$ and $f(v)$ are adjacent in $G_B$. Essentially, isomorphic graphs are structurally identical, just with different vertex labels.\n\nA common misconception is that if two simple graphs have the same number of vertices (the same order) and the same number of edges (the same size), they must be isomorphic. Your task is to identify a counterexample that disproves this proposition.\n\nConsider the following four simple graphs, all defined on the vertex set $V = \\{1, 2, 3, 4, 5, 6\\}$.\n\n-   Graph $G_1 = (V, E_1)$, where $E_1 = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,5\\}, \\{5,6\\}, \\{6,1\\}\\}$.\n-   Graph $G_2 = (V, E_2)$, where $E_2 = \\{\\{1,2\\}, \\{2,3\\}, \\{3,1\\}, \\{4,5\\}, \\{5,6\\}, \\{6,4\\}\\}$.\n-   Graph $G_3 = (V, E_3)$, where $E_3 = \\{\\{1,3\\}, \\{3,5\\}, \\{5,2\\}, \\{2,4\\}, \\{4,6\\}, \\{6,1\\}\\}$.\n-   Graph $G_4 = (V, E_4)$, where $E_4 = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,5\\}, \\{5,6\\}\\}$.\n\nWhich of the following pairs of graphs provides a valid counterexample to the proposition: \"If two simple graphs have the same number of vertices and the same number of edges, then they are isomorphic\"?\n\nA. The pair $(G_1, G_2)$\n\nB. The pair $(G_1, G_3)$\n\nC. The pair $(G_2, G_4)$\n\nD. The pair $(G_1, G_4)$\n\nE. The pair $(G_3, G_4)$", "solution": "We use graph isomorphism invariants: number of vertices, number of edges, degree sequence, and number of connected components must be preserved by any isomorphism.\n\nFirst, count edges and note connectivity.\n- For $G_{1}$, the edges form a $6$-cycle, so $|E_{1}|=6$, each vertex has degree $2$, and the graph is connected (one connected component).\n- For $G_{2}$, the edges form two disjoint $3$-cycles, so $|E_{2}|=6$, each vertex has degree $2$, and the graph is disconnected (two connected components).\n- For $G_{3}$, the edges form a $6$-cycle (e.g., the cycle $1-3-5-2-4-6-1$), so $|E_{3}|=6$, each vertex has degree $2$, and the graph is connected.\n- For $G_{4}$, the edges form a path on $6$ vertices, so $|E_{4}|=5$ and the graph is connected with degree sequence $\\{1,2,2,2,2,1\\}$.\n\nEvaluate each option:\n- A: $(G_{1},G_{2})$ have the same number of vertices and edges ($|V|=6$, $|E|=6$), but $G_{1}$ is connected and $G_{2}$ is disconnected. Since connectedness (number of connected components) is an isomorphism invariant, $G_{1}$ and $G_{2}$ are not isomorphic. This pair is a valid counterexample.\n- B: $(G_{1},G_{3})$ are both $6$-cycles, hence they are isomorphic; not a counterexample.\n- C, D, E: Each involves $G_{4}$, which has $|E_{4}|=5$, while the other graph in the pair has $6$ edges. These pairs do not even satisfy the premise (same number of edges), so they cannot serve as counterexamples to the proposition.\n\nTherefore, only option A provides a valid counterexample.", "answer": "$$\\boxed{A}$$", "id": "1507594"}, {"introduction": "While the general Graph Isomorphism problem is computationally challenging, certain important classes of graphs, like trees, admit efficient solutions. This practice introduces a powerful algorithmic technique known as canonical labeling, where we generate a unique string representation for a rooted tree based on its structure [@problem_id:1425700]. This bottom-up, recursive approach demonstrates how reducing a problem to a well-defined sub-problem can yield elegant and efficient algorithms, a core concept in computer science.", "problem": "In a new data compression scheme for hierarchical data, rooted trees are encoded into a unique string representation. This \"Canonical String Label\" (CSL) is generated by a specific recursive procedure. The procedure is defined as follows:\n\n1.  The CSL for any leaf node (a node with no children) is the string `()`.\n2.  For any non-leaf node `v`, its CSL is constructed by first gathering the CSLs of all its immediate children. These child CSLs are then sorted lexicographically (i.e., in standard alphabetical order). The sorted strings are concatenated together in order to form a single string, `S`. The CSL for node `v` is then defined as `(` followed by `S` followed by `)`.\n\nConsider the following three rooted trees, defined by their node sets, root nodes, and edge sets. An edge `(u, v)` indicates that `v` is a child of `u`.\n\n**Tree T1:**\n*   Root: `A`\n*   Edges: `{(A, B), (A, C), (B, D), (B, E), (C, F)}`\n\n**Tree T2:**\n*   Root: `P`\n*   Edges: `{(P, Q), (P, R), (Q, S), (R, T), (R, U)}`\n\n**Tree T3:**\n*   Root: `X`\n*   Edges: `{(X, Y), (Y, Z), (Z, W), (Z, V), (Y, U)}`\n\nBased on the CSL generation procedure, which of the following statements is true?\n\nA. Tree T1 and Tree T2 have the same CSL for their respective roots.\n\nB. Tree T2 and Tree T3 have the same CSL for their respective roots.\n\nC. Tree T1 and Tree T3 have the same CSL for their respective roots.\n\nD. All three trees have different CSLs for their respective roots.\n\nE. All three trees have the same CSL for their respective roots.", "solution": "To solve this problem, we must compute the Canonical String Label (CSL) for the root of each tree, T1, T2, and T3, by applying the given procedure in a bottom-up fashion.\n\n**1. CSL for Tree T1**\n\nFirst, let's identify the structure of Tree T1 from its edge set `{(A, B), (A, C), (B, D), (B, E), (C, F)}` with root `A`.\n- The children of `A` are `B` and `C`.\n- The children of `B` are `D` and `E`.\n- The child of `C` is `F`.\n- The nodes `D`, `E`, and `F` have no children, so they are leaves.\n\nNow, we compute the CSLs starting from the leaves.\n- The CSLs for the leaves `D`, `E`, and `F` are `()`.\n- To compute the CSL for node `C`, we take the CSL of its only child, `F`, which is `()`. The list of child CSLs is `[()]`. This list is already sorted. Concatenating gives `()`. So, CSL(`C`) = `(())`.\n- To compute the CSL for node `B`, we take the CSLs of its children, `D` and `E`. Both are `()`. The list of child CSLs is `[(), ()]`. This list is already sorted lexicographically. Concatenating them gives `()()`. So, CSL(`B`) = `(()())`.\n- Finally, to compute the CSL for the root `A`, we take the CSLs of its children, `B` and `C`. We have CSL(`B`) = `(()())` and CSL(`C`) = `(())`. The list of child CSLs is `[(()()), (())]`.\n- We must sort this list lexicographically. Comparing `(())` and `(()())`, the string `(())` comes first because at the second character, `)` comes before `(`. The sorted list is `[(()), (()())]`.\n- Concatenating the sorted strings gives `(())` + `(()())` = `(())(()())`.\n- Therefore, the CSL for the root `A` is `((())(()()))`.\n\n**2. CSL for Tree T2**\n\nNext, let's analyze Tree T2 from its edge set `{(P, Q), (P, R), (Q, S), (R, T), (R, U)}` with root `P`.\n- The children of `P` are `Q` and `R`.\n- The child of `Q` is `S`.\n- The children of `R` are `T` and `U`.\n- The nodes `S`, `T`, and `U` are leaves.\n\nWe compute the CSLs bottom-up.\n- The CSLs for the leaves `S`, `T`, and `U` are `()`.\n- To compute the CSL for node `Q`, we take the CSL of its child `S`, which is `()`. CSL(`Q`) = `(())`.\n- To compute the CSL for node `R`, we take the CSLs of its children `T` and `U`, which are both `()`. The sorted list of child CSLs is `[(), ()]`. Concatenating gives `()()`. So, CSL(`R`) = `(()())`.\n- To compute the CSL for the root `P`, we take the CSLs of its children, `Q` and `R`. We have CSL(`Q`) = `(())` and CSL(`R`) = `(()())`. The list of child CSLs is `[(()), (()())]`.\n- Sorting this list lexicographically gives `[(()), (()())]`, same as for T1.\n- Concatenating the sorted strings gives `(())` + `(()())` = `(())(()())`.\n- Therefore, the CSL for the root `P` is `((())(()()))`.\n\n**3. CSL for Tree T3**\n\nFinally, let's analyze Tree T3 from its edge set `{(X, Y), (Y, Z), (Z, W), (Z, V), (Y, U)}` with root `X`.\n- The child of `X` is `Y`.\n- The children of `Y` are `Z` and `U`.\n- The children of `Z` are `W` and `V`.\n- The nodes `W`, `V`, and `U` are leaves.\n\nWe compute the CSLs bottom-up.\n- The CSLs for the leaves `W`, `V`, and `U` are `()`.\n- To compute the CSL for node `Z`, we use its children `W` and `V`. Their CSLs are `()` and `()`. The sorted list is `[(), ()]`. Concatenating gives `()()`. So, CSL(`Z`) = `(()())`.\n- To compute the CSL for node `Y`, we use its children `Z` and `U`. We have CSL(`Z`) = `(()())` and CSL(`U`) = `()`. The list of child CSLs is `[(()()), ()]`.\n- Sorting this list lexicographically, `()` comes before `(()())`. The sorted list is `[(), (()())]`.\n- Concatenating the sorted strings gives `()` + `(()())` = `()(()())`.\n- So, CSL(`Y`) = `(()(()()))`.\n- To compute the CSL for the root `X`, we take the CSL of its only child `Y`. The list is `[(()(()()))]`. Concatenating gives `()(()())`.\n- Therefore, the CSL for the root `X` is `((()(()())))`.\n\n**4. Comparison and Conclusion**\n\nLet's compare the CSLs for the roots of the three trees:\n- CSL(T1 root `A`) = `((())(()()))`\n- CSL(T2 root `P`) = `((())(()()))`\n- CSL(T3 root `X`) = `((()(()())))`\n\nWe can see that CSL(T1) is identical to CSL(T2), but CSL(T3) is different from both. This means that based on the canonical representation, T1 and T2 are structurally equivalent (isomorphic as rooted trees), while T3 has a different structure.\n\nEvaluating the given options:\nA. Tree T1 and Tree T2 have the same CSL for their respective roots. (True)\nB. Tree T2 and Tree T3 have the same CSL for their respective roots. (False)\nC. Tree T1 and Tree T3 have the same CSL for their respective roots. (False)\nD. All three trees have different CSLs for their respective roots. (False)\nE. All three trees have the same CSL for their respective roots. (False)\n\nThe only true statement is A.", "answer": "$$\\boxed{A}$$", "id": "1425700"}, {"introduction": "To tackle the general graph isomorphism problem, we often turn to powerful heuristics like the Weisfeiler-Leman (WL) test, also known as color refinement. This iterative algorithm is a cornerstone of both theoretical analysis and practical solvers for graph isomorphism. This exercise guides you through a classic example where the 1-dimensional WL test fails, proving that while powerful, it is not a complete solution [@problem_id:1425705]. Understanding this limitation is key to appreciating why Graph Isomorphism occupies a unique and fascinating place in the landscape of computational complexity.", "problem": "The 1-dimensional Weisfeiler-Leman (WL) test, also known as the color refinement algorithm, is a heuristic used to test for graph isomorphism. The algorithm iteratively refines a coloring of the vertices of a graph. If two graphs produce different final colorings (specifically, a different number of vertices for each final color), they are guaranteed to be non-isomorphic. If they produce the same final coloring, they might be isomorphic, but it is not guaranteed.\n\nThe algorithm proceeds as follows:\n1.  **Initialization (Iteration 0):** Assign the same initial color, $c_0$, to every vertex in the graph.\n2.  **Refinement (Iteration $k \\ge 1$):** For each vertex $v$, compute a signature based on the multiset of colors of its neighbors from the previous iteration, $k-1$. Formally, the signature of $v$ is the multiset $S_k(v) = \\{\\{ C_{k-1}(u) \\mid u \\text{ is a neighbor of } v \\}\\}$.\n3.  **Update Colors:** All vertices with the same signature $S_k(v)$ are assigned the same new color, $C_k(v)$. Vertices with different signatures are assigned different new colors. A common way to assign new colors is to map each unique signature string to a new unique color label.\n4.  **Termination:** The algorithm terminates when the partition of vertices into color classes does not change between two consecutive iterations. That is, if the number of vertices in each color class at step $k$ is the same as at step $k-1$, the algorithm has stabilized.\n\nThe \"final color signature\" of a graph is the multiset of the final colors of all its vertices.\n\nConsider two 3-regular graphs, $G_A$ and $G_B$, each with 6 vertices labeled $\\{1, 2, 3, 4, 5, 6\\}$.\n-   **Graph $G_A$** has the edge set $E_A = \\{(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6)\\}$.\n-   **Graph $G_B$** has the edge set $E_B = \\{(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4), (1, 4), (2, 5), (3, 6)\\}$.\n\nApply the 1-dimensional WL test to both $G_A$ and $G_B$. Based on the outcome of the algorithm and the properties of the graphs, which one of the following statements is correct?\n\nA. The algorithm produces the same final color signature for both graphs, proving they are isomorphic.\n\nB. The algorithm produces different final color signatures for the two graphs, proving they are non-isomorphic.\n\nC. The algorithm produces the same final color signature for both graphs, but this result is inconclusive regarding their isomorphism. The graphs are, in fact, non-isomorphic.\n\nD. The algorithm produces the same final color signature for both graphs, but this result is inconclusive regarding their isomorphism. The graphs are, in fact, isomorphic.\n\nE. The algorithm fails to terminate for at least one of the graphs.", "solution": "We apply the 1-dimensional Weisfeiler-Leman (WL) color refinement algorithm to both graphs starting from a uniform initial coloring.\n\nInitialization (iteration 0): Every vertex in each graph receives the same initial color, denote it by $c_{0}$. Thus, for each graph, the partition is a single color class of size $6$.\n\nRefinement at iteration $k=1$: For any vertex $v$ in either graph, the signature is the multiset of colors of its neighbors from iteration $k-1$. In both $G_{A}$ and $G_{B}$, every vertex has degree $3$ (both are $3$-regular). Since at iteration $0$ all neighbors of every vertex have color $c_{0}$, the signature for every vertex is\n$$\nS_{1}(v)=\\{c_{0},c_{0},c_{0}\\}.\n$$\nAll vertices share the same signature, so they are assigned the same new color at iteration $1$. Denote this color by $c_{1}$. Thus, for each graph, $C_{1}(v)=c_{1}$ for all vertices $v$, and the partition remains a single color class of size $6$.\n\nRefinement at iteration $k=2$ and termination: Repeating the same reasoning, at iteration $1$ all vertices have the same color $c_{1}$, so for every vertex $v$,\n$$\nS_{2}(v)=\\{c_{1},c_{1},c_{1}\\}.\n$$\nAgain, all vertices receive the same color at iteration $2$. Therefore, the partition does not change between iterations $1$ and $2$, and the algorithm stabilizes. The final color signature for each graph is the multiset consisting of a single color repeated $6$ times, namely $\\{c^{*},c^{*},c^{*},c^{*},c^{*},c^{*}\\}$, where $c^{*}$ is the stabilized color (e.g., $c_{1}$).\n\nConclusion about WL outcomes: The algorithm produces the same final color signature for both $G_{A}$ and $G_{B}$.\n\nGraph isomorphism status: Despite the identical WL signatures, $G_{A}$ and $G_{B}$ are not isomorphic. The graph $G_{A}$ is the complete bipartite graph $K_{3,3}$, which is bipartite and therefore contains no cycles of odd length. The graph $G_{B}$ contains a $3$-cycle, for example on vertices $\\{1,2,3\\}$ by edges $(1,2),(2,3),(3,1)$, hence it is not bipartite. Bipartiteness is an isomorphism invariant, so a bipartite graph cannot be isomorphic to a non-bipartite graph. Therefore, $G_{A}$ and $G_{B}$ are non-isomorphic.\n\nPutting these together, the correct statement is that the algorithm produces the same final color signature for both graphs, but this is inconclusive for isomorphism; in fact, the graphs are non-isomorphic.", "answer": "$$\\boxed{C}$$", "id": "1425705"}]}