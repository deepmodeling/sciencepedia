{"hands_on_practices": [{"introduction": "Proving a problem is NP-hard from first principles is a monumental task. Instead, computer scientists build upon a vast library of known NP-hard problems. This exercise [@problem_id:1420019] illustrates the fundamental technique used in this process: polynomial-time reduction. By showing how to transfer the \"hardness\" from a known difficult problem to a new one, you will practice the core logic that underpins almost all modern NP-hardness proofs.", "problem": "In the field of computational complexity theory, computer scientists classify problems based on their inherent difficulty. Two key concepts in this classification are NP-hardness and polynomial-time reductions.\n\nLet's define these terms formally:\n- A problem $A$ has a polynomial-time reduction to a problem $B$, denoted $A \\le_p B$, if there is an algorithm that can transform any instance of $A$ into an instance of $B$ in polynomial time, such that the solution to the $B$ instance allows one to determine the solution to the original $A$ instance.\n- A problem $H$ is defined as NP-hard if every problem $L$ in the class NP (Nondeterministic Polynomial time) has a polynomial-time reduction to $H$ (i.e., for all $L \\in \\text{NP}$, $L \\le_p H$). Intuitively, this means that an NP-hard problem is at least as hard as any problem in NP.\n\nImagine two research teams. Team Alpha is working on the \"Generalized Sudoku Puzzle\" (GSP) problem. It is a well-established fact in computer science that GSP is an NP-hard problem. Team Beta is working on a different problem called the \"Integer Linear Feasibility\" (ILF) problem. A brilliant researcher on Team Beta discovers a clever algorithm that can take any GSP instance of size $n$ and transform it into an instance of the ILF problem. This transformation algorithm runs in a time proportional to $n^3$. A solution to the resulting ILF instance directly tells them whether the original GSP instance had a solution.\n\nBased solely on this information, what is the strongest correct conclusion you can draw about the computational complexity of the ILF problem?\n\nA. The ILF problem is in the class NP.\n\nB. The ILF problem is solvable in polynomial time.\n\nC. The ILF problem is NP-complete.\n\nD. The ILF problem is NP-hard.\n\nE. No meaningful conclusion can be drawn about the ILF problem's complexity from the information provided.", "solution": "We are given two formal facts. First, the Generalized Sudoku Puzzle (GSP) is NP-hard, which means that for every language $L \\in \\text{NP}$, there exists a polynomial-time reduction from $L$ to GSP. Formally,\n$$\n\\forall L \\in \\text{NP},\\quad L \\le_{p} \\text{GSP}.\n$$\nSecond, there is a polynomial-time reduction from GSP to the Integer Linear Feasibility (ILF) problem running in time proportional to $n^{3}$, which is polynomial in the input size, so in reduction notation,\n$$\n\\text{GSP} \\le_{p} \\text{ILF}.\n$$\nA fundamental property of polynomial-time reductions is closure under composition: if $A \\le_{p} B$ and $B \\le_{p} C$, then $A \\le_{p} C$, since the composition of two polynomial-time computable transformations is polynomial-time. Applying this to the two facts above, for any $L \\in \\text{NP}$ we have\n$$\nL \\le_{p} \\text{GSP} \\le_{p} \\text{ILF} \\quad \\Longrightarrow \\quad L \\le_{p} \\text{ILF}.\n$$\nBy the definition of NP-hardness, this implies that ILF is NP-hard.\n\nNo stronger conclusion is justified from the given information. In particular, we are not given that $\\text{ILF} \\in \\text{NP}$, so we cannot conclude NP-completeness, and we have no basis to conclude polynomial-time solvability.", "answer": "$$\\boxed{D}$$", "id": "1420019"}, {"introduction": "In mathematical proofs, the direction of the argument is everything, and a reversed implication can lead to entirely false conclusions. This is especially true in complexity theory, where the direction of a reduction defines what we can claim about a problem's difficulty. This next exercise [@problem_id:1420029] presents a scenario with a common but critical flaw in reasoning, challenging you to pinpoint why a valid polynomial-time reduction fails to prove NP-hardness.", "problem": "In computational complexity theory, a decision problem $A$ is said to be polynomial-time reducible to a decision problem $B$, denoted $A \\le_p B$, if there exists an algorithm that solves $A$ by using a polynomial number of steps plus a polynomial number of calls to an oracle (a black box) that solves $B$. For the standard Karp reduction, this means there is a polynomial-time function $f$ that transforms any instance $x$ of problem $A$ into an instance $f(x)$ of problem $B$ such that $x$ is a \"yes\" instance of $A$ if and only if $f(x)$ is a \"yes\" instance of $B$.\n\nA student is tasked with determining the complexity of a new decision problem called INTEGER-FACTOR-BOUND (IFB). An instance of IFB is a pair of positive integers $(N, k)$, and the question is whether $N$ has a non-trivial factor less than or equal to $k$.\n\nThe student knows that the 3-Satisfiability problem (3-SAT) is NP-complete. To prove that IFB is NP-hard, the student constructs a valid polynomial-time algorithm that takes any given instance $(N, k)$ of IFB and transforms it into a specific 3-SAT formula $\\phi$ such that $\\phi$ is satisfiable if and only if $N$ has a non-trivial factor less than or equal to $k$. In other words, the student has successfully demonstrated that $\\text{IFB} \\le_p \\text{3-SAT}$. Based on this result, the student concludes that the IFB problem is NP-hard.\n\nWhich of the following statements correctly identifies the fundamental flaw in the student's logic?\n\nA. The student's proof is incomplete; they must also show that IFB is in the complexity class NP (Nondeterministic Polynomial time) before any conclusion can be made.\n\nB. The reduction is in the wrong direction. To prove IFB is NP-hard, one must reduce a known NP-hard problem *to* IFB, not the other way around.\n\nC. The conclusion is flawed because 3-SAT, being a logic problem, cannot be used to prove the hardness of a number theory problem like IFB. The reduction should have been from another number theory problem, such as SUBSET-SUM.\n\nD. The reduction itself is impossible. It is a well-known fact that IFB can be solved in polynomial time, whereas 3-SAT cannot (unless P=NP), so a reduction from IFB to 3-SAT cannot exist.\n\nE. The student has actually shown that IFB is in P, since they found a polynomial-time transformation to another problem.", "solution": "Define a polynomial-time many-one reduction as follows: for decision problems $A$ and $B$, $A \\le_{p} B$ means there exists a polynomial-time computable function $f$ such that for all inputs $x$, $x \\in A$ if and only if $f(x) \\in B$. \n\nA problem $H$ is NP-hard if for every language $L \\in \\mathrm{NP}$, $L \\le_{p} H$. A standard way to prove NP-hardness of $H$ is to reduce a known NP-complete problem $C$ to $H$, i.e., show $C \\le_{p} H$; since $C$ is at least as hard as every problem in $\\mathrm{NP}$, this implies $H$ is at least as hard as every problem in $\\mathrm{NP}$.\n\nThe student has established $\\mathrm{IFB} \\le_{p} \\text{3-SAT}$ by constructing a polynomial-time transformation from instances of IFB to instances of 3-SAT preserving yes/no answers. This shows that 3-SAT is at least as hard as IFB (equivalently, IFB is no harder than 3-SAT). However, to conclude that IFB is NP-hard, one must show that IFB is at least as hard as every problem in $\\mathrm{NP}$. A single sufficient step is to reduce a known NP-hard (indeed NP-complete) problem such as 3-SAT to IFB, i.e., to prove $\\text{3-SAT} \\le_{p} \\mathrm{IFB}$, not the reverse. Therefore, the fundamental flaw is the reduction direction.\n\nEvaluating the options:\n- A is incorrect because NP-hardness does not require showing membership in $\\mathrm{NP}$; that would be needed to conclude NP-completeness, not NP-hardness.\n- B is correct: the reduction is in the wrong direction for proving NP-hardness of IFB.\n- C is incorrect: cross-domain reductions (logic to number theory) are standard and valid.\n- D is incorrect: there is no known polynomial-time algorithm for IFB in general under the standard input size measure, and reductions from arbitrary problems to 3-SAT are common; the claimed impossibility does not hold.\n- E is incorrect: a polynomial-time reduction from IFB to an NP problem does not imply IFB is in $\\mathrm{P}$.\n\nThus, the flaw is the wrong reduction direction.", "answer": "$$\\boxed{B}$$", "id": "1420029"}, {"introduction": "After learning the mechanics of how to prove a problem is NP-hard, it is natural to ask: what is the ultimate significance of this classification? Labeling a problem as NP-hard is not just an academic exercise; it's a profound statement about its likely intractability. This thought experiment [@problem_id:1420041] explores the dramatic \"domino effect\" that would occur if a fast algorithm were found for just one NP-hard problem, a discovery that would reshape the landscape of computation and prove that $P = NP$.", "problem": "An independent computer scientist makes a groundbreaking claim: she has developed a new algorithm that can solve a known NP-hard problem in worst-case polynomial time with respect to the input size. She provides the algorithm's pseudocode and a rigorous proof of its polynomial time complexity, which are verified to be correct by the scientific community. Assuming her claim is true, which of the following statements describes the single most significant and direct implication for computational complexity theory?\n\nTo answer, you must understand the definitions of the following complexity classes and concepts:\n- **P (Polynomial time):** The class of decision problems solvable by a deterministic Turing machine in polynomial time.\n- **NP (Nondeterministic Polynomial time):** The class of decision problems for which a proposed solution can be verified as correct by a deterministic Turing machine in polynomial time.\n- **NP-hard:** A problem H is NP-hard if for every problem L in the class NP, there exists a polynomial-time reduction from L to H. A polynomial-time reduction is an algorithm that transforms an instance of problem L into an instance of problem H in polynomial time, such that the answer to the new instance is \"yes\" if and only if the answer to the original instance was \"yes\".\n\nSelect the best option from the list below.\n\nA. The complexity class P is proven to be equal to the complexity class NP.\n\nB. All problems in NP can now be verified in logarithmic time.\n\nC. The specific NP-hard problem she solved is now proven to be NP-complete.\n\nD. This discovery proves that the Traveling Salesperson Problem can be solved in linear time.\n\nE. There are no major implications for complexity theory, as the discovery only pertains to a single problem.", "solution": "Let $H$ be a known NP-hard problem under polynomial-time reductions as defined. By NP-hardness, for every language $L \\in \\mathrm{NP}$, there exists a polynomial-time computable reduction $f_{L}$ such that for all inputs $x$,\n$$\nx \\in L \\iff f_{L}(x) \\in H.\n$$\nAssume there exists a deterministic algorithm $\\mathcal{A}_{H}$ that decides $H$ in worst-case polynomial time. That is, there exists a polynomial $p_{H}$ such that for all inputs $y$,\n$$\n\\text{time}(\\mathcal{A}_{H}(y)) \\leq p_{H}(|y|).\n$$\nLet $q_{L}$ be a polynomial bounding the time to compute $f_{L}$, and let $r_{L}$ be a polynomial such that $|f_{L}(x)| \\leq r_{L}(|x|)$ for all $x$ (both exist because $f_{L}$ is computable in polynomial time).\n\nConstruct a deterministic algorithm for $L$ as follows: on input $x$, compute $y = f_{L}(x)$ in time at most $q_{L}(|x|)$, then run $\\mathcal{A}_{H}(y)$ in time at most $p_{H}(|y|) \\leq p_{H}(r_{L}(|x|))$. The total running time is thus bounded by the polynomial\n$$\nq_{L}(|x|) + p_{H}(r_{L}(|x|)),\n$$\nwhich is polynomial in $|x|$. Therefore, $L \\in \\mathrm{P}$. Since $L$ was an arbitrary language in $\\mathrm{NP}$, we have\n$$\n\\mathrm{NP} \\subseteq \\mathrm{P}.\n$$\nIt is a standard inclusion that $\\mathrm{P} \\subseteq \\mathrm{NP}$, hence\n$$\n\\mathrm{P} = \\mathrm{NP}.\n$$\nAssessing the options:\n- A states exactly $\\mathrm{P} = \\mathrm{NP}$, which follows as shown.\n- B is false; nothing here implies logarithmic-time verification.\n- C need not hold because NP-completeness additionally requires $H \\in \\mathrm{NP}$ (a decision problem); NP-hard problems need not be in $\\mathrm{NP}$.\n- D is false; the existence of a polynomial-time algorithm does not imply linear time for Traveling Salesperson Problem.\n- E is false; the implication $\\mathrm{P} = \\mathrm{NP}$ is a major foundational result.\n\nTherefore, A is the single most significant and direct implication.", "answer": "$$\\boxed{A}$$", "id": "1420041"}]}