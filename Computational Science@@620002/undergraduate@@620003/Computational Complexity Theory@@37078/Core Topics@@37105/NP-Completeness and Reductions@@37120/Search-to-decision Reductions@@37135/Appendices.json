{"hands_on_practices": [{"introduction": "We begin with a common scenario in computational biology: finding a known functional motif within a large protein interaction network. This exercise demonstrates the fundamental self-reduction technique, where a search problem is solved by iteratively making choices and using a decision oracle to confirm if a solution is still possible. Using a 'black box' that only tells us if a solution exists [@problem_id:1446692], we will develop an algorithm to pinpoint the exact vertices forming the motif by systematically testing the importance of each one.", "problem": "In the field of bioinformatics, researchers model Protein-Protein Interaction (PPI) networks as graphs, where proteins are vertices and a significant interaction between two proteins is an edge. A key task is to find functional \"motifs,\" which are small, recurring patterns of interactions.\n\nSuppose you are a computational biologist working with a large PPI network, represented by a graph $G=(V, E)$, where $|V|=n$. You are looking for a specific, known functional motif, represented by a smaller graph $H=(V_H, E_H)$, where $|V_H|=k$. The motif is expected to appear in $G$ as an *induced subgraph*. A subgraph of $G$ induced by a vertex subset $S \\subseteq V$ is a graph containing the vertices $S$ and all edges from $E$ that connect two vertices in $S$.\n\nYou have access to a hypothetical, sophisticated computational service called `HAS_MOTIF`. This service acts as a decision oracle: you provide it with any graph $G'$, and it instantly returns YES if $G'$ contains an induced subgraph isomorphic to $H$, and NO otherwise. The service is very expensive per use, but you have confirmed with a single initial call that `HAS_MOTIF`(G) returns YES.\n\nYour task is to devise an algorithm that uses the `HAS_MOTIF` oracle to find the actual set of $k$ vertices in $G$ that form an instance of the motif $H$. What is the maximum number of calls to the `HAS_MOTIF` oracle your algorithm needs to make to guarantee finding the vertex set of one such motif? Express your answer as a function of $n$ and $k$.", "solution": "We are given a decision oracle `HAS_MOTIF` that, for any input graph, returns YES if and only if the graph contains an induced subgraph isomorphic to a fixed pattern $H$ with $k$ vertices. We have already confirmed that `HAS_MOTIF`(G) returns YES for the initial graph $G=(V,E)$ with $|V|=n$. The goal is to find a specific vertex set $S \\subseteq V$ with $|S|=k$ that induces a copy of $H$ in $G$ while minimizing the number of additional oracle calls.\n\nWe design a self-reduction algorithm that shrinks the graph by deleting vertices one by one, always preserving the property that the current graph still contains an induced copy of $H$. The procedure is:\n1. Initialize $G_{0} := G$ and $V_{0} := V$.\n2. For $t = 0,1,2,\\dots$ while $|V_{t}| > k$, pick any vertex $v \\in V_{t}$ and query `HAS_MOTIF` on the induced subgraph $G_{t} - v$.\n   - If `HAS_MOTIF`($G_{t} - v$) returns YES, set $G_{t+1} := G_{t} - v$ and $V_{t+1} := V_{t} \\setminus \\{v\\}$. This preserves the existence of at least one induced copy of $H$.\n   - If `HAS_MOTIF`($G_{t} - v$) returns NO, keep $v$ (do not delete it) and try a different vertex.\n\nCorrectness: Suppose `HAS_MOTIF`($G_{t}$) is YES. If there exists an induced copy of $H$ on some $k$-set $S \\subseteq V_{t}$ with $v \\notin S$, then $G_{t} - v$ still contains that copy, so the oracle returns YES and removing $v$ is safe. If the oracle returns NO for $G_{t} - v$, then every induced copy of $H$ in $G_{t}$ must include $v$; thus $v$ is a forced vertex that must be in any solution of size $k$ for the current and all subsequent subgraphs. Repeating this ensures that as long as $|V_{t}| > k$, there exists at least one removable vertex, because any particular solution $S$ of size $k$ is contained in $V_{t}$ and any $v \\in V_{t} \\setminus S$ is removable. The process terminates when $|V_{T}|=k$. Since `HAS_MOTIF` remained YES after each removal, the final $k$-vertex graph $G_{T}$ necessarily contains an induced copy of $H$, and with exactly $k$ vertices total this implies $G_{T}$ itself is isomorphic to $H$; therefore $V_{T}$ is the desired vertex set.\n\nQuery complexity bound: Each successful deletion (YES outcome) reduces the vertex count by one. To go from $n$ vertices to $k$ vertices requires exactly $n-k$ deletions, and therefore at least $n-k$ YES answers and $n-k$ oracle calls of that type. Consider NO answers: if `HAS_MOTIF`($G_{t} - v$) is NO, then $v$ is in every solution for $G_{t}$. Once a vertex is forced at some stage, it remains forced in all later stages because the set of solutions can only shrink under further deletions, so we never need to retest it. Moreover, the total number of distinct forced vertices can never exceed $k$, because every solution has exactly $k$ vertices and all forced vertices must belong to every solution. Therefore the total number of NO answers over the whole execution is at most $k$.\n\nHence the total number of oracle calls made by the algorithm is at most\n$$(n-k) + k = n.$$\nThis count uses the prior knowledge that `HAS_MOTIF`(G) is YES and does not require reissuing that initial query. The algorithm thus guarantees finding a valid $k$-vertex instance of $H$ with at most $n$ calls to `HAS_MOTIF`.", "answer": "$$\\boxed{n}$$", "id": "1446692"}, {"introduction": "Many real-world problems require not just any solution, but an optimal one. In this practice, we tackle the problem of resolving circular dependencies in a project plan by removing the minimum number of tasks [@problem_id:1446683]. You will learn a powerful two-phase strategy that combines binary search with self-reduction: first, efficiently determine the size of the minimal solution, and then apply a reduction process, similar to the previous exercise, to construct that optimal set.", "problem": "A project manager at a large software company is overseeing a project with $N$ distinct programming tasks. These tasks are interdependent; for instance, task A might need to be completed before task B can begin. These dependencies can be represented as a directed graph $G$, where each task is a vertex and a directed edge from vertex $u$ to vertex $v$ means task $u$ must be completed before task $v$.\n\nUnfortunately, due to poor planning, the task dependency graph contains circular dependencies (i.e., directed cycles). For example, task A depends on B, B depends on C, and C depends on A. Such cycles make it impossible to determine a valid order for executing the tasks. To resolve this, the manager must \"outsource\" a subset of tasks, which is equivalent to removing the corresponding vertices (and their incident edges) from the graph. The goal is to outsource a set of tasks of the minimum possible size to break all cycles.\n\nThe manager has access to a specialized external consulting service, which acts as an oracle. This service provides a function `CAN_BREAK(G', k)`, which takes a task graph $G'$ and an integer $k$. The function returns `True` if it is possible to break all cycles in $G'$ by outsourcing at most $k$ tasks, and `False` otherwise.\n\nDevise an efficient algorithm that uses the `CAN_BREAK` oracle to find a specific set of tasks of minimal size that must be outsourced. What is the total number of calls to the `CAN_BREAK` oracle required by your algorithm in the worst case? Express your answer as a function of $N$, the total number of tasks.", "solution": "Let $G=(V,E)$ be the directed task graph with $|V|=N$. A feedback vertex set (FVS) is a set $S \\subseteq V$ such that $G-S$ is acyclic. The oracle predicate is\n$$\nP(k) \\equiv \\texttt{CAN\\_BREAK}(G,k),\n$$\nwhich is monotone non-decreasing in $k$: if $P(k)$ is true and $k' \\geq k$, then $P(k')$ is also true. Moreover, $P(N)$ is true without calling the oracle since removing all $N$ vertices yields an acyclic graph.\n\nStep 1 (find the minimum size $k^{*}$). Use binary search over $k \\in \\{0,1,\\ldots,N\\}$ to find the minimum $k^{*}$ such that $P(k^{*})$ is true. Because $P$ is monotone, a binary search over $N+1$ candidates requires at most $\\lceil \\log_{2}(N+1) \\rceil$ oracle calls in the worst case.\n\nStep 2 (self-reduction to construct an explicit FVS of size $k^{*}$). Maintain the current graph $H$ (initially $H:=G$), the remaining budget $r$ (initially $r:=k^{*}$), and the partial solution $S$ (initially empty). Process the vertices of $H$ in any fixed order while $r>0$. For each current vertex $v$:\n- Query the oracle on the instance $(H-v, r-1)$. If `CAN_BREAK`(H-v, r-1) is true, then there exists an FVS of size at most $r$ for $H$ that includes $v$; set $S:=S \\cup \\{v\\}$, update $H:=H-v$, and decrement $r:=r-1$.\n- If the oracle returns false, leave $v$ in $H$ and continue to the next vertex.\n\nCorrectness of the test: `CAN_BREAK`($H-v, r-1$) is true if and only if there exists a set $T$ with $|T| \\leq r-1$ such that $(H-v)-T$ is acyclic, which is equivalent to $H-(T \\cup \\{v\\})$ being acyclic with $|T \\cup \\{v\\}| \\leq r$. Thus the test exactly characterizes whether there exists an FVS of size at most $r$ that includes $v$.\n\nProgress and termination: Suppose at some iteration there exists an FVS $S'$ of size $r$ for the current $H$. Let $v$ be the first vertex in the fixed order that belongs to $S'$. Then `CAN_BREAK`($H-v, r-1$) is true, so the algorithm includes $v$ and reduces $r$ by one. Repeating, the algorithm selects exactly $k^{*}$ vertices and stops. Each vertex of the original $G$ is tested at most once, so this stage makes at most $N$ oracle calls in the worst case.\n\nTotal oracle calls: at most $N + \\lceil \\log_{2}(N+1) \\rceil$ in the worst case.", "answer": "$$\\boxed{N+\\lceil \\log_{2}(N+1)\\rceil}$$", "id": "1446683"}, {"introduction": "Search-to-decision reductions are not limited to finding subsets in graphs; they are versatile enough to solve problems in number theory as well. This final practice challenges you to find a set of integers whose squares sum to a target value $N$ [@problem_id:1446695]. Here, the search is not over a collection of objects to include or exclude, but over a range of possible numerical values, showcasing how to adapt the core reduction principle to different kinds of search spaces.", "problem": "In the field of computational complexity theory, a search-to-decision reduction is a method for solving a search problem using an oracle for the corresponding decision problem. A search problem requires finding a solution, while a decision problem only asks if a solution exists.\n\nConsider the problem of representing an integer as a sum of squares, a topic of interest in number theory and computer science. Suppose you have access to a specialized computational oracle, let's call it `DECIDE_SUM_SQUARES`. This oracle accepts two inputs: a non-negative integer $M$ and a positive integer $j$. It returns `True` if $M$ can be expressed as the sum of $j$ non-negative integer squares (i.e., if there exist non-negative integers $y_1, y_2, \\ldots, y_j$ such that $y_1^2 + y_2^2 + \\dots + y_j^2 = M$), and `False` otherwise. You can assume each call to this oracle takes a constant amount of time.\n\nYour task is to devise an algorithm that uses this oracle to solve the corresponding search problem: for a given non-negative integer $N$ and a positive integer $k$, find a set of $k$ non-negative integers $\\{x_1, x_2, \\ldots, x_k\\}$ such that $x_1^2 + x_2^2 + \\dots + x_k^2 = N$.\n\nAssuming that for the given inputs $N$ and $k$ a solution is always guaranteed to exist, determine the maximum number of calls to the `DECIDE_SUM_SQUARES` oracle required by your algorithm to find one such set of integers. Express your answer as a function of $N$ and $k$.", "solution": "We build a standard search-to-decision self-reduction that fixes one square at a time using the oracle. Maintain a residual sum and a remaining count of squares.\n\nAlgorithm:\n- Initialize the residual $R := N$ and the remaining count $j := k$.\n- For each position $i$ from $1$ to $k-1$ (equivalently, while $j \\geq 2$):\n  - For $t$ ranging from $0$ to $\\lfloor \\sqrt{R} \\rfloor$:\n    - Query `DECIDE_SUM_SQUARES`($R - t^{2}, j-1$).\n    - If the oracle returns True, set $x_{i} := t$, update $R := R - t^{2}$ and $j := j-1$, and break the inner loop to move to the next position.\n- When $j = 1$, the remaining $R$ must be a perfect square (by the invariant guaranteed by the oracle responses), so set $x_{k} := \\sqrt{R}$ without any further oracle calls.\n\nCorrectness follows by induction: at each stage, if the oracle returns True for some $t$, then the remainder $R - t^{2}$ is representable as a sum of $j-1$ squares, so continuing the process yields a full representation. Because a solution is guaranteed to exist for the given $N$ and $k$, at each stage at least one $t$ in $\\{0,1,\\ldots,\\lfloor \\sqrt{R} \\rfloor\\}$ will succeed.\n\nOracle-call complexity:\n- At a fixed stage with residual $R$ and remaining count $j \\geq 2$, we try $t$ in increasing order. In the worst case, the successful $t$ is the last one tried, so the number of oracle calls at that stage is at most $\\lfloor \\sqrt{R} \\rfloor + 1$.\n- Since $R \\leq N$ throughout, each stage uses at most $\\lfloor \\sqrt{N} \\rfloor + 1$ oracle calls.\n- There are exactly $k-1$ such stages (we do not need any call when $j=1$).\n\nTherefore, an absolute worst-case upper bound on the number of oracle calls used by this algorithm, expressed as a function of $N$ and $k$, is\n$$\n(k-1)\\bigl(\\lfloor \\sqrt{N} \\rfloor + 1\\bigr).\n$$\nThis bound is achieved by the algorithm as a guarantee independent of how the residuals evolve, and it matches the intuitive $O(k \\sqrt{N})$ behavior with an exact expression.", "answer": "$$\\boxed{(k-1)\\bigl(\\lfloor \\sqrt{N} \\rfloor + 1\\bigr)}$$", "id": "1446695"}]}