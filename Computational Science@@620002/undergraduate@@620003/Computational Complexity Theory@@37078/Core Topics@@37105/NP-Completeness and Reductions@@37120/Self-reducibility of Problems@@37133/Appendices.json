{"hands_on_practices": [{"introduction": "Our first exercise gets to the heart of self-reducibility with the canonical SAT problem. Once an oracle helps us find one satisfying assignment, a natural question arises: are there others? This practice demonstrates a fundamental technique for modifying a problem to exclude known solutions, allowing us to systematically explore the entire solution space [@problem_id:1446970].", "id": "1446970", "problem": "In computational complexity theory, the concept of an \"oracle\" is a useful abstraction. An oracle for a decision problem, such as the Boolean Satisfiability Problem (SAT), is a black box that can answer in a single step whether any given Boolean formula is satisfiable. The self-reducibility of SAT allows us to use such an oracle not just to decide satisfiability, but also to find a satisfying assignment if one exists.\n\nConsider the following Boolean formula $F$ in Conjunctive Normal Form (CNF) with four variables, $x_1, x_2, x_3, x_4$:\n$$ F = (x_1 \\lor x_3) \\land (\\neg x_2 \\lor x_4) \\land (\\neg x_1 \\lor \\neg x_3 \\lor x_4) $$\nYou are given that the assignment $A = (x_1 \\mapsto \\text{True}, x_2 \\mapsto \\text{True}, x_3 \\mapsto \\text{False}, x_4 \\mapsto \\text{True})$ is a satisfying assignment for $F$.\n\nYour task is to find a second, distinct satisfying assignment for $F$. The standard method to do this is to construct a new formula, let's call it $F'$, which is satisfiable if and only if there exists a satisfying assignment for $F$ that is different from $A$. Once $F'$ is constructed, one can use the SAT oracle in a standard self-reducibility search to find such an assignment.\n\nWhich of the following represents the correct formula $F'$ that must be constructed to begin this process?\n\nA. $ F \\land (\\neg x_1 \\lor \\neg x_2 \\lor x_3 \\lor \\neg x_4) $\nB. $ F \\land (x_1 \\land x_2 \\land \\neg x_3 \\land x_4) $\nC. $ F \\lor (\\neg x_1 \\lor \\neg x_2 \\lor x_3 \\lor \\neg x_4) $\nD. $ (\\neg x_1 \\lor \\neg x_2 \\lor x_3 \\lor \\neg x_4) $\nE. $ F \\land (x_1 \\lor x_2 \\lor \\neg x_3 \\lor x_4) $\n\n", "solution": "We are given the CNF formula $F$ and a known satisfying assignment $A$ with $x_{1}=\\text{True}$, $x_{2}=\\text{True}$, $x_{3}=\\text{False}$, $x_{4}=\\text{True}$. To find a second distinct satisfying assignment using a SAT oracle via self-reducibility, we must construct a formula $F'$ that is satisfiable if and only if there exists a satisfying assignment for $F$ different from $A$. The standard construction excludes exactly the assignment $A$ by conjoining $F$ with a clause that is false on $A$ and true on every other assignment.\n\nThe assignment $A$ can be represented as the conjunction that fixes all variables to their values in $A$:\n$$\nC_{A} \\equiv x_{1} \\land x_{2} \\land \\neg x_{3} \\land x_{4}.\n$$\nTo exclude exactly $A$, we add the negation of this conjunction. By De Morgan’s law,\n$$\n\\neg C_{A} \\equiv \\neg(x_{1} \\land x_{2} \\land \\neg x_{3} \\land x_{4}) = (\\neg x_{1} \\lor \\neg x_{2} \\lor x_{3} \\lor \\neg x_{4}).\n$$\nThis disjunction is a single clause that is false precisely on $A$ and true on every assignment that differs from $A$ in at least one variable. Therefore, the desired formula is\n$$\nF' \\equiv F \\land (\\neg x_{1} \\lor \\neg x_{2} \\lor x_{3} \\lor \\neg x_{4}).\n$$\nThis achieves the required equivalence: if $F'$ is satisfiable, then there exists an assignment that satisfies $F$ and differs from $A$; conversely, any satisfying assignment of $F$ that is not $A$ satisfies the added clause and thus satisfies $F'$.\n\nMatching this with the options, this is exactly option A. Options B and E do not exclude $A$ (B forces $A$ itself; E’s clause is true on $A$ but does not exclude it). Option C uses a disjunction with $F$, which does not ensure the result is a satisfying assignment of $F$. Option D drops $F$ entirely, allowing assignments that do not satisfy $F$.", "answer": "$$\\boxed{A}$$"}, {"introduction": "Building on the basic search for a satisfying assignment, we now introduce a more refined goal: finding a *minimal* assignment. This is more than an academic exercise; in many real-world scenarios, we seek the most efficient or simplest solution. This problem challenges you to think critically about how the very structure of your self-reduction algorithm determines the properties of the solution you find [@problem_id:1447155].", "id": "1447155", "problem": "In computational complexity theory, the Boolean Satisfiability Problem (SAT) is a foundational problem. Given a Boolean formula $\\phi$ in Conjunctive Normal Form (CNF) over a set of variables $\\{x_1, x_2, \\ldots, x_n\\}$, the problem is to determine if there exists an assignment of TRUE or FALSE values to the variables that makes the entire formula evaluate to TRUE.\n\nImagine you have access to a hypothetical device called a SAT oracle. This oracle, represented by the function `is_sat(ψ)`, takes any Boolean formula `ψ` as input and instantly returns TRUE if `ψ` is satisfiable, and FALSE otherwise. While such an oracle can tell you *if* a satisfying assignment exists, it does not directly provide one.\n\nA well-known procedure called self-reducibility uses this oracle to find a satisfying assignment for a given satisfiable formula $\\phi$. However, a formula can have many satisfying assignments. We are interested in a specific type of assignment known as a *minimal satisfying assignment*. A satisfying assignment $A$ is defined as **minimal** if for any variable $x_i$ that is assigned TRUE in $A$, flipping its value to FALSE (while keeping all other variable assignments the same) results in an assignment that no longer satisfies $\\phi$.\n\nYou are tasked with identifying a correct and guaranteed algorithm that uses a SAT oracle to find one such minimal satisfying assignment for a given satisfiable formula $\\phi$. The algorithms under consideration build the assignment variable by variable, from $x_1$ to $x_n$. In the descriptions below, $\\psi$ represents a formula that is progressively built upon, starting with $\\psi = \\phi$. The final assignment is denoted by $A$.\n\nWhich of the following algorithms correctly and guarantees to find a minimal satisfying assignment for any satisfiable input formula $\\phi$?\n\nA. Initialize $\\psi = \\phi$.\nFor $i = 1, \\ldots, n$:\n_    _If `is_sat`($\\psi \\land x_i$) is TRUE:\n_    _    _Set $A(x_i) = \\text{TRUE}$ and update $\\psi \\leftarrow \\psi \\land x_i$.\n_    _Else:\n_    _    _Set $A(x_i) = \\text{FALSE}$ and update $\\psi \\leftarrow \\psi \\land \\neg x_i$.\nReturn $A$.\n\nB. Initialize $\\psi = \\phi$.\nFor $i = 1, \\ldots, n$:\n_    _If `is_sat`($\\psi \\land \\neg x_i$) is TRUE:\n_    _    _Set $A(x_i) = \\text{FALSE}$ and update $\\psi \\leftarrow \\psi \\land \\neg x_i$.\n_    _Else:\n_    _    _Set $A(x_i) = \\text{TRUE}$ and update $\\psi \\leftarrow \\psi \\land x_i$.\nReturn $A$.\n\nC. First, find an arbitrary satisfying assignment $A_0$ using the standard self-reducibility method (Algorithm A).\nInitialize $A = A_0$.\nFor $i = 1, \\ldots, n$:\n_    _If $A(x_i)$ is TRUE:\n_    _    _Let $A'$ be the assignment identical to $A$ but with $x_i$ set to FALSE.\n_    _    _If $A'$ satisfies $\\phi$:\n_    _    _    _Update $A \\leftarrow A'$.\nReturn $A$.\n\nD. For $i = 1, \\ldots, n$:\n_    _Let $\\phi_T = \\phi \\land x_i$ and $\\phi_F = \\phi \\land \\neg x_i$.\n_    _If `is_sat`($\\phi_T$) is TRUE and `is_sat`($\\phi_F$) is TRUE:\n_    _    _Set $A(x_i) = \\text{FALSE}$.\n_    _Else if `is_sat`($\\phi_T$) is TRUE:\n_    _    _Set $A(x_i) = \\text{TRUE}$.\n_    _Else:\n_    _    _Set $A(x_i) = \\text{FALSE}$.\nReturn $A$.\n\n", "solution": "We want an algorithm that always returns a satisfying assignment and guarantees minimality, meaning that for every variable set to TRUE in the output, flipping it to FALSE while keeping all other variables fixed makes the formula unsatisfied.\n\nAlgorithm B:\n- Correctness (returns a satisfying assignment): Maintain the invariant that at the start of iteration $i$ the working formula $\\psi$ equals $\\phi$ conjoined with fixed values for $x_{1},\\ldots,x_{i-1}$ and is satisfiable. At step $i$, the algorithm queries $\\text{is\\_sat}(\\psi \\land \\neg x_{i})$. If TRUE, it sets $x_{i}=\\text{FALSE}$ and updates $\\psi \\leftarrow \\psi \\land \\neg x_{i}$, which remains satisfiable by the oracle’s answer. Otherwise it sets $x_{i}=\\text{TRUE}$ and $\\psi \\leftarrow \\psi \\land x_{i}$. This is safe because $\\psi$ is satisfiable and $\\psi \\equiv (\\psi \\land x_{i}) \\lor (\\psi \\land \\neg x_{i})$; if $\\psi \\land \\neg x_{i}$ is unsatisfiable, then $\\psi \\land x_{i}$ must be satisfiable (otherwise $\\psi$ would be unsatisfiable). By induction, after $n$ steps $\\psi$ includes assignments for all variables and is satisfiable, so the produced $A$ satisfies $\\phi$.\n\n- Minimality: Let $i$ be any index with $A(x_{i})=\\text{TRUE}$. This only occurs when $\\text{is\\_sat}(\\psi \\land \\neg x_{i})$ returned FALSE at step $i$, where $\\psi$ already included the fixed values for $x_{1},\\ldots,x_{i-1}$ as in $A$. The oracle’s FALSE answer means there is no assignment to $x_{i+1},\\ldots,x_{n}$ that can satisfy $\\psi \\land \\neg x_{i}$. In particular, if we take the final values of $x_{i+1},\\ldots,x_{n}$ used in $A$, then\n$$\n\\phi \\land \\bigwedge_{j<i}\\ell_{j} \\land \\neg x_{i} \\land \\bigwedge_{j>i}\\ell_{j}\n$$\nis unsatisfiable, where each $\\ell_{j}$ is $x_{j}$ or $\\neg x_{j}$ according to $A$. Therefore flipping $x_{i}$ to FALSE while keeping all other variables as in $A$ makes $\\phi$ false. Hence every TRUE in $A$ is necessary and $A$ is minimal. Thus B is correct.\n\nAlgorithm A:\n- Counterexample: Let $\\phi=(x_{1}\\lor x_{2})$. At $i=1$, $\\text{is\\_sat}(\\phi \\land x_{1})$ is TRUE, so set $x_{1}=\\text{TRUE}$. At $i=2$, $\\text{is\\_sat}(\\phi \\land x_{1} \\land x_{2})$ is TRUE, so set $x_{2}=\\text{TRUE}$. The result $A(x_{1})=\\text{TRUE}$, $A(x_{2})=\\text{TRUE}$ is not minimal, since flipping $x_{2}$ to FALSE still satisfies $\\phi$.\n\nAlgorithm C:\n- Counterexample: Let $\\phi=(\\neg x_{2}\\lor x_{1})$. Algorithm A yields $A_{0}(x_{1})=\\text{TRUE}$, $A_{0}(x_{2})=\\text{TRUE}$ because both $\\phi \\land x_{1}$ and $\\phi \\land x_{1} \\land x_{2}$ are satisfiable. Now Algorithm C: for $i=1$, try flipping $x_{1}$ to FALSE while keeping $x_{2}=\\text{TRUE}$; $(\\neg x_{2}\\lor x_{1})$ evaluates to FALSE, so keep $x_{1}=\\text{TRUE}$. For $i=2$, flip $x_{2}$ to FALSE; $(\\neg x_{2}\\lor x_{1})$ is TRUE, so set $x_{2}=\\text{FALSE}$ and return $A=(x_{1}=\\text{TRUE},x_{2}=\\text{FALSE})$. This $A$ is not minimal because flipping $x_{1}$ to FALSE yields $(x_{1}=\\text{FALSE},x_{2}=\\text{FALSE})$, which still satisfies $\\phi$. The flaw is that a single pass may miss further reducible TRUEs created by later flips.\n\nAlgorithm D:\n- Counterexample (incompatibility of independent choices): Let\n$$\n\\phi=(x_{1}\\lor x_{2}) \\land (x_{1}\\lor x_{3}) \\land (x_{2}\\lor x_{3}).\n$$\nFor each $i\\in\\{1,2,3\\}$, both $\\phi \\land x_{i}$ and $\\phi \\land \\neg x_{i}$ are satisfiable (e.g., $\\phi \\land \\neg x_{1}$ is satisfied by $x_{2}=\\text{TRUE},x_{3}=\\text{TRUE}$). Algorithm D therefore sets all variables to FALSE, yielding $A=(\\text{FALSE},\\text{FALSE},\\text{FALSE})$, which does not satisfy $\\phi$. Hence D does not even guarantee a satisfying assignment.\n\nConclusion: Only Algorithm B correctly and always returns a minimal satisfying assignment for any satisfiable input $\\phi$.", "answer": "$$\\boxed{B}$$"}, {"introduction": "The principles of self-reducibility are not confined to Boolean formulas; they are a general tool for a wide range of computational problems. Here, we apply the same pattern of thinking to a classic graph theory problem: finding a maximum clique. This exercise solidifies your understanding by showing how to combine an optimization search (using binary search to find the clique's size) with a constructive search (iteratively building the clique) [@problem_id:1447183].", "id": "1447183", "problem": "An engineer is tasked with analyzing the structure of a complex communication network, which can be modeled as an undirected graph $G=(V, E)$, where $V$ is the set of $n$ communication nodes and $E$ is the set of $m$ direct links between them. The engineer needs to identify a \"core communication hub,\" which is defined as a maximum clique in the graph. A clique is a subset of vertices where every two distinct vertices are connected by an edge, and a maximum clique is a clique of the largest possible size in the graph.\n\nTo assist in this task, the engineer has access to a specialized hardware oracle. This oracle provides a single function, `HAS_CLIQUE(G', k')`, which takes a graph $G'$ and an integer $k'$ as input. It returns `true` if $G'$ contains a clique of size at least $k'$, and `false` otherwise. Each call to this oracle is considered a single computational step.\n\nYour task is to devise an algorithm that uses this oracle to find the set of vertices forming one maximum clique in the graph $G$. What is the maximum number of calls to the `HAS_CLIQUE` oracle that your algorithm would require for a graph with $n$ vertices? Express your answer as a closed-form analytic expression in terms of $n$.\n\n", "solution": "The problem asks for an algorithm to find a maximum clique in a graph $G$ using a decision oracle, and to determine the maximum number of oracle calls needed. The solution can be broken down into two main stages: first, determining the size of the maximum clique, and second, identifying the vertices that form such a clique.\n\n**Stage 1: Determine the size of the maximum clique ($k_{\\max}$)**\n\nThe core property we can exploit is the monotonic nature of the clique problem. If a graph contains a clique of size $k$, it must also contain cliques of all sizes smaller than $k$. This property makes the problem amenable to binary search. We can search for the largest integer $k$ in the range $[1, n]$ for which the oracle `HAS_CLIQUE(G, k)` returns `true`.\n\nLet's define the binary search procedure:\n1. Initialize the search range: `low = 1`, `high = n`.\n2. Initialize a variable to store the size of the largest clique found so far: `k_max = 0`.\n3. While `low <= high`:\n    a. Calculate the midpoint: `mid = floor((low + high) / 2)`.\n    b. Call the oracle: `result = HAS_CLIQUE(G, mid)`.\n    c. If `result` is `true`, it means a clique of size `mid` exists. This could be our maximum clique, or an even larger one might exist. So, we record this size, `k_max = mid`, and try to find a larger one by adjusting our search space to the upper half: `low = mid + 1`.\n    d. If `result` is `false`, a clique of size `mid` does not exist. Therefore, any clique larger than `mid` also cannot exist. We must search for a smaller clique in the lower half: `high = mid - 1`.\n\nAfter the binary search loop terminates, `k_max` will hold the size of the maximum clique in the graph $G$. A binary search on a range of size $n$ requires a number of queries equal to $\\lceil \\log_{2}(n) \\rceil$.\n\n**Stage 2: Identify the vertices of a maximum clique**\n\nNow that we know the size of the maximum clique is $k_{\\max}$, we can use a self-reducibility approach to find the specific vertices that form one such clique. The most efficient method is an elimination process.\n\nThe algorithm proceeds as follows:\n1. Initialize a candidate set of vertices, `V_cand`, to be the entire vertex set of the original graph, `V`.\n2. Iterate through each vertex $v$ in the original vertex set $V$, one by one. For each $v$:\n    a. Create a temporary graph, $G'$, which is the subgraph of $G$ induced by the vertices in `V_cand \\setminus \\{v\\}`.\n    b. Call the oracle: `result = HAS_CLIQUE(G', k_max)`.\n    c. If `result` is `true`, it means that even after removing $v$ from our current set of candidates, a clique of size $k_{\\max}$ still exists. This implies that $v$ is not essential, so we can permanently discard it from our candidate set by updating `V_cand` to `V_cand \\setminus \\{v\\}`.\n    d. If `result` is `false`, it means that $v$ is essential to form any $k_{\\max}$-clique within the current candidate set. Therefore, we must keep $v$, and we do not modify `V_cand`.\n\nThis process is repeated for all $n$ vertices of the original graph $G$. For each of the $n$ vertices, we make exactly one call to the oracle to decide whether to keep or discard it from the candidate pool. After iterating through all $n$ vertices, the final set `V_cand` will contain exactly $k_{\\max}$ vertices. These vertices form a maximum clique because we have systematically eliminated all vertices that are not strictly necessary to form a clique of size $k_{\\max}$. The number of oracle calls in this stage is exactly $n$.\n\n**Total Oracle Calls**\n\nThe total number of oracle calls is the sum of the calls from Stage 1 and Stage 2.\nTotal calls = (Calls for finding $k_{\\max}$) + (Calls for finding vertices)\nTotal calls = $\\lceil \\log_{2}(n) \\rceil + n$\n\nThus, the maximum number of oracle calls required by this algorithm is $n + \\lceil \\log_{2}(n) \\rceil$.", "answer": "$$\\boxed{n + \\lceil \\log_{2}(n) \\rceil}$$"}]}