{"hands_on_practices": [{"introduction": "A core feature of a Turing reduction ($A \\le_T B$) is that the oracle machine must be a *decider*—it is guaranteed to halt on all inputs. This practice [@problem_id:1468144] invites you to explore a fundamental consequence of this property: closure under complementation. You will demonstrate how to construct a decider for the complement language $\\overline{A}$ by leveraging the existing decider for $A$, highlighting how the certainty of a final, definitive answer is crucial for this simple but powerful transformation.", "problem": "In the study of computational complexity, we often analyze the relationship between different decision problems using the concept of reducibility. Let $A$ and $B$ be two languages, which are sets of strings over a common alphabet $\\Sigma$. The complement of a language $A$, denoted $\\overline{A}$, is the set of all strings in $\\Sigma^*$ that are not in $A$.\n\nA language $A$ is said to be Turing-reducible to a language $B$, denoted $A \\le_T B$, if there exists an Oracle Turing Machine (OTM) that decides language $A$ by using an oracle for language $B$. A \"decider\" is a Turing machine that is guaranteed to halt on all inputs, always concluding in either an 'accept' or 'reject' state. The oracle for $B$ can be thought of as a black box that can instantaneously answer whether any given string $q$ is a member of the language $B$.\n\nSuppose you are given an OTM, which we will call $M_A$, that is a decider for language $A$ and uses an oracle for language $B$. This means that for any input string $w$:\n- If $w \\in A$, $M_A$ halts and accepts.\n- If $w \\notin A$, $M_A$ halts and rejects.\n\nYour task is to determine how to construct a new OTM, which we will call $M_{\\overline{A}}$, that decides the complement language $\\overline{A}$ using the same oracle for language $B$. Which of the following statements provides a correct and complete description of the behavior of such a machine $M_{\\overline{A}}$ for any given input string $w$?\n\nA. On input $w$, $M_{\\overline{A}}$ simulates $M_A$ on $w$. If the simulation of $M_A$ halts and accepts, then $M_{\\overline{A}}$ halts and rejects. If the simulation of $M_A$ halts and rejects, then $M_{\\overline{A}}$ halts and accepts.\n\nB. On input $w$, $M_{\\overline{A}}$ simulates $M_A$ on $w$. However, whenever the simulated $M_A$ makes an oracle query for a string $q$ to its oracle for $B$, the new machine $M_{\\overline{A}}$ first uses a separate subroutine to decide if $q \\in \\overline{B}$ and provides the opposite answer to the simulation. This requires an oracle for $\\overline{B}$.\n\nC. On input $w$, $M_{\\overline{A}}$ simulates $M_A$ on $w$. If $M_A$ would enter its accept state, $M_{\\overline{A}}$ enters its reject state. If $M_A$ would enter its reject state, $M_{\\overline{A}}$ enters its accept state. If $M_A$ were to loop infinitely on input $w$, $M_{\\overline{A}}$ would also loop infinitely.\n\nD. It is not possible to construct an oracle Turing machine $M_{\\overline{A}}$ that decides $\\overline{A}$ using only an oracle for $B$. The necessary information is not available.\n\nE. On input $w$, $M_{\\overline{A}}$ runs the simulation of $M_A$ on $w$. $M_{\\overline{A}}$ then accepts if the simulation of $M_A$ accepted, and rejects if the simulation of $M_A$ rejected, effectively copying the behavior of $M_A$.", "solution": "We are given an oracle Turing machine $M_{A}$ that decides $A$ using an oracle for $B$. By definition of a decider, for every input $w \\in \\Sigma^{*}$, the machine $M_{A}$ halts and accepts if $w \\in A$, and halts and rejects if $w \\notin A$.\n\nTo construct an oracle Turing machine $M_{\\overline{A}}$ that decides $\\overline{A}$ using the same oracle for $B$, proceed as follows on input $w$:\n- Simulate $M_{A}$ on input $w$, forwarding each oracle query $q$ exactly to the oracle for $B$ and using the oracle’s answer to continue the simulation. This uses only the oracle for $B$.\n- When the simulated $M_{A}$ halts, invert its decision: if it accepts, then reject; if it rejects, then accept.\n\nProof of correctness:\n- If $w \\in \\overline{A}$, then $w \\notin A$. Since $M_{A}$ decides $A$, it halts and rejects on $w$. Therefore, $M_{\\overline{A}}$ flips this to accept, so $M_{\\overline{A}}$ accepts exactly those $w \\in \\overline{A}$.\n- If $w \\notin \\overline{A}$, then $w \\in A$. Since $M_{A}$ decides $A$, it halts and accepts on $w$. Therefore, $M_{\\overline{A}}$ flips this to reject, so $M_{\\overline{A}}$ rejects exactly those $w \\notin \\overline{A}$.\n- Termination: Because $M_{A}$ halts on all inputs, the simulation halts on all inputs, and the inversion step also halts. Thus $M_{\\overline{A}}$ is a decider.\n\nAmong the options, this behavior is precisely described by option A. Option B incorrectly requires an oracle for $\\overline{B}$. Option C introduces an unnecessary and potentially misleading clause about infinite loops; while vacuously true under the given assumption that $M_{A}$ is a decider, it is not the clean characterization of a decider construction. Option D is false, and option E is incorrect since it does not invert the decision.", "answer": "$$\\boxed{A}$$", "id": "1468144"}, {"introduction": "Turing reductions are a primary tool for comparing the relative difficulty of computational problems, even famously undecidable ones. This exercise [@problem_id:1468089] delves into a classic example from computability theory, relating the standard Halting Problem ($A_{TM}$) to the problem of determining if a Turing machine halts on all possible inputs ($TOTAL_{TM}$). Your task is to design a new machine that correctly translates an instance of one problem into a query for the other, providing a hands-on look at how the logic of one problem can be encoded within the very structure of another.", "problem": "In the field of theoretical computer science, we often classify problems by their computational difficulty. Two famous undecidable problems relate to the behavior of a Turing Machine (TM), a mathematical model of computation.\n\nThe first is the Halting Problem, which asks whether a given TM $M$ will halt on a specific input string $w$. The language corresponding to this problem is denoted as $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ is a TM and } M \\text{ halts on input } w \\}$.\n\nThe second problem asks whether a TM halts for *every* possible input. The language for this problem is $TOTAL_{TM} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM and } M \\text{ halts on all inputs} \\}$.\n\nAlthough both languages are undecidable, it is possible to solve one using a hypothetical device called an \"oracle\" for the other. An oracle for $TOTAL_{TM}$ is a black-box subroutine that, when given the description of any TM $\\langle M' \\rangle$, can instantly and correctly determine if $\\langle M' \\rangle \\in TOTAL_{TM}$.\n\nYour task is to determine the correct design for a new TM, let's call it $M'$, which can be used in conjunction with a $TOTAL_{TM}$ oracle to decide the Halting Problem for an arbitrary instance $\\langle M, w \\rangle$. The overall decision procedure works as follows:\n1. Receive an input $\\langle M, w \\rangle$.\n2. Construct the description of a new TM, $M'$, based on $M$ and $w$.\n3. Query the $TOTAL_{TM}$ oracle with $\\langle M' \\rangle$.\n4. The oracle's YES/NO answer for $M'$ must correspond directly to the YES/NO answer for whether $M$ halts on $w$.\n\nWhich of the following descriptions for the behavior of $M'$ on an arbitrary input $x$ constitutes a correct design for this purpose?\n\nA. On any input $x$, the machine $M'$ ignores $x$ and simulates $M$ on the fixed string $w$. $M'$ halts if and only if this simulation of $M$ on $w$ halts.\n\nB. On any input $x$, the machine $M'$ simulates $M$ on that input $x$. $M'$ halts if and only if this simulation of $M$ on $x$ halts.\n\nC. On any input $x$, the machine $M'$ ignores $x$ and simulates $M$ on the fixed string $w$. If the simulation of $M$ halts, $M'$ enters an infinite loop. If the simulation of $M$ does not halt, $M'$ halts instantly.\n\nD. On any input $x$, the machine $M'$ first simulates $M$ on the fixed string $w$. If this simulation halts, $M'$ then proceeds to simulate $M$ on its own input $x$, and halts if and only if this second simulation halts.\n\nE. No such construction for $M'$ is possible because both $A_{TM}$ and $TOTAL_{TM}$ define undecidable languages.", "solution": "We are given an oracle for $TOTAL_{TM}=\\{\\langle N\\rangle\\mid N\\text{ halts on all inputs}\\}$. To decide $A_{TM}=\\{\\langle M,w\\rangle\\mid M\\text{ halts on }w\\}$ using this oracle, we must, for an arbitrary input $\\langle M,w\\rangle$, construct a Turing machine $M'$ such that\n$$\n\\langle M,w\\rangle\\in A_{TM}\\iff \\langle M'\\rangle\\in TOTAL_{TM}.\n$$\nThis requires that $M'$ be total if and only if $M$ halts on $w$.\n\nConsider the construction described in option A: define $M'$ so that on any input $x$, $M'$ ignores $x$ and simulates $M$ on the fixed input $w$, halting if and only if that simulation halts.\n\nWe verify the equivalence:\n- Suppose $M$ halts on $w$. Then the simulation of $M$ on $w$ performed by $M'$ halts. Because $M'$ ignores its input $x$, this same behavior occurs for every $x$. Therefore, for all $x$, $M'(x)$ halts, so $\\langle M'\\rangle\\in TOTAL_{TM}$.\n- Conversely, suppose $M$ does not halt on $w$. Then the simulation in $M'$ never halts, and because $M'$ ignores $x$, for every $x$, $M'(x)$ does not halt. Therefore, $\\langle M'\\rangle\\notin TOTAL_{TM}$.\n\nCombining these,\n$$\n\\langle M,w\\rangle\\in A_{TM}\\iff \\langle M'\\rangle\\in TOTAL_{TM}.\n$$\nThus querying the $TOTAL_{TM}$ oracle on $\\langle M'\\rangle$ yields YES if and only if $M$ halts on $w$, exactly matching the desired decision for $A_{TM}$.\n\nFor completeness, the other options fail to yield the required equivalence:\n- Option B makes $M'$ total if and only if $M$ is total, which does not reflect whether $M$ halts on the specific input $w$.\n- Option C inverts the correspondence: $M'$ is total if and only if $M$ does not halt on $w$, so the oracle’s YES answer would mean $M$ does not halt on $w$, not a direct correspondence.\n- Option D makes $M'$ total only if $M$ halts on $w$ and $M$ halts on all inputs; hence it decides whether $M$ is total after confirming $M$ halts on $w$, not the required property.\n- Option E is incorrect because an oracle reduction from $A_{TM}$ to $TOTAL_{TM}$ exists via the construction in option A.\n\nTherefore, the correct design is option A.", "answer": "$$\\boxed{A}$$", "id": "1468089"}, {"introduction": "Beyond classifying problem difficulty, Turing reductions provide a powerful framework for solving search problems using an oracle for a related decision problem. This hands-on practice [@problem_id:1468109] presents a tangible scenario where you must construct an optimal solution—a conflict-free schedule—using an oracle that only provides yes/no answers about the existence of a schedule of a given size. By tracing a deterministic algorithm, you will see firsthand how repeated, strategic queries to a decision oracle can be used to build a complete, correct solution piece by piece.", "problem": "In the field of computational complexity theory, a common technique is to use a subroutine that solves a decision problem (a \"yes/no\" question) to help solve a related search problem (a \"find an example\" question). This problem explores such a scenario.\n\nImagine you are a program manager at a funding agency. You have a list of grant proposals, each with a required start week and end week. Your task is to select the largest possible set of grants to fund, with the constraint that you, as the sole reviewer, cannot review two grants whose time intervals overlap.\n\nYou have access to a powerful, pre-existing computational subroutine called `HAS_SCHEDULE_OF_SIZE_K`. This subroutine takes two arguments: a set of grants `G` and an integer `k`. It returns `True` if there exists a conflict-free subset of `G` with size at least `k`, and `False` otherwise. Two grants conflict if their time intervals overlap. A time interval is defined as `[start_week, end_week)`, meaning it includes the start week but excludes the end week.\n\nYour goal is to use this `HAS_SCHEDULE_OF_SIZE_K` subroutine to find one specific, maximum-sized, conflict-free set of grants. You must use the following deterministic algorithm:\n\n1.  First, determine the maximum possible size, $k_{max}$, of a conflict-free schedule for the entire original set of grants, $T$.\n2.  Initialize an empty schedule, $S = \\emptyset$, and a set of candidate grants, $U = T$.\n3.  Iterate through each grant $g$ in the original set $T$, considered in increasing order of their index.\n    a. Let's call the current grant being considered $g_{current}$. If $g_{current}$ is not in the current candidate set $U$, skip it.\n    b. To decide whether to add $g_{current}$ to your solution, you must determine if it's a \"safe\" choice. A choice is safe if, after choosing $g_{current}$, it's still possible to form a complete schedule of the target size. To test this, form a temporary set $U_{test}$ containing all grants in $U \\setminus \\{g_{current}\\}$ that do not conflict with $g_{current}$.\n    c. Query the oracle: `HAS_SCHEDULE_OF_SIZE_K(U_{test}, |S| + k_{max} - 1)`. Wait, this line seems overly complex. Let's simplify the logic.\n\nLet's restate the core logic for the construction phase (steps 2 and 3) more clearly:\n\n2.  Initialize the final schedule $S = \\emptyset$ and the set of available grants for consideration $U = T$.\n3.  Iterate through the grants $g_1, g_2, \\dots, g_n$ from the original set $T$ in order of their index. For each grant $g_i$:\n    a. Check if choosing $g_i$ is a \"safe move\". A move is safe if, after committing to $g_i$, we can still form a maximum-sized schedule. To test this, we see if a schedule of size ($k_{max} - |S| - 1$) can be formed from the remaining compatible grants. Specifically, define $U_{compatible} = \\{ g' \\in U \\setminus \\{g_i\\} \\mid g' \\text{ does not conflict with } g_i \\}$. Query the oracle: `HAS_SCHEDULE_OF_SIZE_K(U_{compatible}, k_{max} - |S| - 1)`.\n    b. If the oracle returns `True`, then $g_i$ is a safe choice. Add $g_i$ to your schedule $S$ and update the set of available grants $U$ to be only those compatible with your new choice, i.e., $U = U_{compatible}$.\n    c. If the oracle returns `False`, then picking $g_i$ was a dead end. Do not add it to $S$. Simply remove $g_i$ from the set of available grants $U$ and continue to the next grant.\n\nGiven the following set of six grants, $T$, which of the options below represents the final schedule $S$ that your algorithm will construct? The grants are identified by their index.\n\n-   $g_1$: (index=1, start=1, end=5)\n-   $g_2$: (index=2, start=0, end=3)\n-   $g_3$: (index=3, start=4, end=7)\n-   $g_4$: (index=4, start=6, end=9)\n-   $g_5$: (index=5, start=2, end=4)\n-   $g_6$: (index=6, start=8, end=10)\n\nChoose the option that lists the indices of the grants in the final schedule $S$.\n\nA. {1, 4}\nB. {3, 5, 6}\nC. {1, 4, 6}\nD. {2, 3, 6}", "solution": "We are given intervals (half-open) for six grants:\n$g_{1}=[1,5)$, $g_{2}=[0,3)$, $g_{3}=[4,7)$, $g_{4}=[6,9)$, $g_{5}=[2,4)$, $g_{6}=[8,10)$.\nTwo intervals $[a,b)$ and $[c,d)$ conflict if they overlap, i.e., if not $(b \\leq c$ or $d \\leq a)$.\n\nFirst, determine the maximum possible size $k_{\\max}$ of a conflict-free subset of $T=\\{g_{1},\\dots,g_{6}\\}$. The set $\\{g_{2},g_{3},g_{6}\\}$ is conflict-free because $[0,3)$ ends before $[4,7)$ starts, and $[4,7)$ ends before $[8,10)$ starts, so a conflict-free set of size $3$ exists. To upper bound, note that among $\\{g_{1},g_{2},g_{5}\\}$ at most one can be chosen (each pair overlaps), and among $\\{g_{3},g_{4}\\}$ at most one can be chosen (they overlap), while $g_{6}$ overlaps with $g_{4}$ but not with $g_{3}$. Hence the total size is at most $1+1+1=3$. Therefore,\n$$\nk_{\\max}=3.\n$$\n\nNow run the construction with $S=\\emptyset$ and $U=T$, iterating $g_{1},g_{2},\\dots,g_{6}$ in index order. At each step, for current $g_{i}\\in U$, define $U_{\\text{compatible}}=\\{g'\\in U\\setminus\\{g_{i}\\}: g'\\text{ does not conflict with }g_{i}\\}$ and query\n$$\n\\text{HAS\\_SCHEDULE\\_OF\\_SIZE\\_K}\\big(U_{\\text{compatible}},\\,k_{\\max}-|S|-1\\big).\n$$\n\nConsider $g_{1}=[1,5)$. Its compatible grants in $U\\setminus\\{g_{1}\\}$ are $g_{4}=[6,9)$ and $g_{6}=[8,10)$, so $U_{\\text{compatible}}=\\{g_{4},g_{6}\\}$. Query with $k_{\\max}-|S|-1=3-0-1=2$ asks if there is a conflict-free subset of size at least $2$ in $\\{g_{4},g_{6}\\}$. Since $g_{4}$ and $g_{6}$ overlap, the largest conflict-free subset has size $1<2$, so the oracle returns False. Therefore $g_{1}$ is not added; remove $g_{1}$ from $U$.\n\nConsider $g_{2}=[0,3)$. With $U$ now $T\\setminus\\{g_{1}\\}$, the grants compatible with $g_{2}$ are $g_{3}$, $g_{4}$, and $g_{6}$, so $U_{\\text{compatible}}=\\{g_{3},g_{4},g_{6}\\}$. Query with $k_{\\max}-|S|-1=3-0-1=2$. In $\\{g_{3},g_{4},g_{6}\\}$, the subset $\\{g_{3},g_{6}\\}$ is conflict-free of size $2$, so the oracle returns True. Hence $g_{2}$ is safe; add it to $S$ and set $U=\\{g_{3},g_{4},g_{6}\\}$.\n\nConsider $g_{3}=[4,7)$. In $U\\setminus\\{g_{3}\\}=\\{g_{4},g_{6}\\}$, only $g_{6}$ is compatible with $g_{3}$, so $U_{\\text{compatible}}=\\{g_{6}\\}$. Query with $k_{\\max}-|S|-1=3-1-1=1$. Since $\\{g_{6}\\}$ has a conflict-free subset of size $1$, the oracle returns True. Add $g_{3}$ to $S$ and set $U=\\{g_{6}\\}$.\n\nConsider $g_{4}$. It is not in $U$, so skip.\n\nConsider $g_{5}$. It is not in $U$, so skip.\n\nConsider $g_{6}=[8,10)$. Now $U\\setminus\\{g_{6}\\}=\\emptyset$, so $U_{\\text{compatible}}=\\emptyset$. Query with $k_{\\max}-|S|-1=3-2-1=0$. A subset of size at least $0$ always exists (the empty set), so the oracle returns True. Add $g_{6}$ to $S$ and set $U=\\emptyset$.\n\nThe algorithm terminates with $S=\\{g_{2},g_{3},g_{6}\\}$, which corresponds to option D.", "answer": "$$\\boxed{D}$$", "id": "1468109"}]}