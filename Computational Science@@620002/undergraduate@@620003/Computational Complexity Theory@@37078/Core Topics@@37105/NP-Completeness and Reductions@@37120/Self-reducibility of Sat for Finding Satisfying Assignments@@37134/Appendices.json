{"hands_on_practices": [{"introduction": "The principle of self-reducibility lies at the heart of many concepts in complexity theory, demonstrating how the ability to solve a decision problem can be leveraged to find an actual solution. This first exercise [@problem_id:1447134] provides a clear, hands-on demonstration of this core mechanism. By working with a hypothetical formula that is guaranteed to have exactly one satisfying assignment, you can trace the step-by-step process of using a decision oracle to reveal this unique solution, variable by variable.", "problem": "A computer scientist, Ada, is working with a specialized computational device that functions as an oracle. This oracle is designed to solve a promise version of the Boolean Satisfiability Problem (SAT). It accepts a Boolean formula as input under the strict promise that the formula is either unsatisfiable or has exactly one satisfying assignment.\n- If the input formula is unsatisfiable, the oracle outputs `FALSE`.\n- If the input formula has a unique satisfying assignment, the oracle outputs `TRUE`.\nThe oracle's behavior is undefined for any formula with more than one satisfying assignment.\n\nA Boolean formula is in Conjunctive Normal Form (CNF) if it is a logical AND of one or more clauses, where each clause is a logical OR of one or more literals. A literal is a variable or its negation. A satisfying assignment is a specific combination of `TRUE`/`FALSE` values for the variables that makes the entire formula evaluate to `TRUE`.\n\nAda is given the following CNF formula $\\Phi_0$ over the three Boolean variables $x_1, x_2, x_3$:\n$$ \\Phi_0 = (x_1) \\land (x_1 \\lor x_2) \\land (\\neg x_1 \\lor \\neg x_2) \\land (\\neg x_1 \\lor x_3) $$\nShe is guaranteed that $\\Phi_0$ has exactly one satisfying assignment. Her goal is to determine this unique assignment by making a series of queries to the oracle.\n\nDescribe a procedure to find the unique satisfying assignment for $\\Phi_0$ using the oracle, and determine this assignment. Express your answer as a single row matrix representing the values for $(x_1, x_2, x_3)$ in that order, where `1` represents `TRUE` and `0` represents `FALSE`.", "solution": "We are given an oracle for the promise problem that, on any input formula guaranteed to be either unsatisfiable or to have exactly one satisfying assignment, outputs TRUE in the latter case and FALSE in the former; behavior is undefined otherwise. The original formula\n$$\n\\Phi_0 = (x_1) \\land (x_1 \\lor x_2) \\land (\\neg x_1 \\lor \\neg x_2) \\land (\\neg x_1 \\lor x_3)\n$$\nis promised to have exactly one satisfying assignment.\n\nGeneral procedure to determine the unique assignment using the oracle:\nFor each variable $x_i$ in order, maintain the partial assignment fixed so far. To determine $x_i$, query the oracle once on the formula obtained by conjoining the current partial assignment and $x_i$. If the oracle returns TRUE, set $x_i=1$; if it returns FALSE, set $x_i=0$. This respects the promise at every step because, given that $\\Phi_0$ has exactly one satisfying assignment $a$, for any tested $x_i$, exactly one of the two possibilities $x_i=1$ or $x_i=0$ is consistent with $a$. The tested formula is either uniquely satisfiable (if the tested value matches $a_i$) or unsatisfiable (if it does not).\n\nApplying this to $\\Phi_0$:\n\n1) Determine $x_1$. Query the oracle on\n$$\nF_1 \\equiv \\Phi_0 \\land x_1.\n$$\nSince $\\Phi_0$ includes the clause $(x_1)$, any satisfying assignment must have $x_1=1$, so $F_1$ has exactly one satisfying assignment. Therefore the oracle returns TRUE, and we set $x_1=1$.\n\n2) Determine $x_2$ given $x_1=1$. Query the oracle on\n$$\nF_2 \\equiv \\Phi_0 \\land x_1 \\land x_2.\n$$\nUnder $x_1=1$ and $x_2=1$, the clause $(\\neg x_1 \\lor \\neg x_2)$ evaluates to $0$, so $F_2$ is unsatisfiable. Therefore the oracle returns FALSE, and we set $x_2=0$.\n\n3) Determine $x_3$ given $x_1=1$ and $x_2=0$. Query the oracle on\n$$\nF_3 \\equiv \\Phi_0 \\land x_1 \\land \\neg x_2 \\land x_3.\n$$\nEvaluate each clause under $x_1=1$, $x_2=0$, $x_3=1$:\n- $(x_1)$ becomes $1$,\n- $(x_1 \\lor x_2)$ becomes $1 \\lor 0 = 1$,\n- $(\\neg x_1 \\lor \\neg x_2)$ becomes $0 \\lor 1 = 1$,\n- $(\\neg x_1 \\lor x_3)$ becomes $0 \\lor 1 = 1$.\nThus $F_3$ is satisfiable, and by the uniqueness promise it has exactly one satisfying assignment, so the oracle returns TRUE. Hence $x_3=1$.\n\nTherefore, the unique satisfying assignment is $(x_1,x_2,x_3)=(1,0,1).", "answer": "$$\\boxed{\\begin{pmatrix}1 & 0 & 1\\end{pmatrix}}$$", "id": "1447134"}, {"introduction": "A key skill in computational science is adapting general algorithms to solve specific, constrained problems. This often involves re-framing or reducing a new problem into a well-understood one for which we already have tools. This practice [@problem_id:1447152] explores this idea by presenting a variant of SAT with additional inequality constraints, challenging you to find a way to encode these new rules into a standard Conjunctive Normal Form (CNF) formula that a standard SAT oracle can understand.", "problem": "In computational complexity theory, the Boolean Satisfiability Problem (SAT) is a foundational problem. Given a Boolean formula in Conjunctive Normal Form (CNF), the problem is to determine if there exists an assignment of truth values (True/False) to its variables that makes the entire formula evaluate to True.\n\nA key property of SAT is its self-reducibility. This property implies that if we have a \"black box\" oracle that can solve the decision problem (i.e., answer 'Yes' or 'No' to whether a formula is satisfiable), we can use this oracle to find an actual satisfying assignment for any satisfiable formula. The standard algorithm proceeds as follows: for a satisfiable formula $\\phi$ with variables $x_1, x_2, \\ldots, x_n$, it iteratively determines the value of each variable. To find the value of $x_1$, it asks the oracle if the formula $\\phi$ with $x_1$ set to True is satisfiable. If it is, we fix $x_1 = \\text{True}$; otherwise, we must fix $x_1 = \\text{False}$. This process is repeated for $x_2, x_3, \\ldots, x_n$, at each step substituting the values of the variables already found.\n\nConsider a variant of SAT, which we'll call `UNEQUAL-SAT`. In an `UNEQUAL-SAT` instance, you are given a standard CNF formula $\\phi$ with variables $x_1, \\ldots, x_n$, and a set of additional pairwise inequality constraints, $C = \\{(i_1, j_1), (i_2, j_2), \\ldots, (i_k, j_k)\\}$, where each pair $(i, j)$ represents the constraint that variables $x_i$ and $x_j$ must have different truth values (i.e., $x_i \\neq x_j$).\n\nAssuming you have access to a standard SAT oracle (which only decides satisfiability for standard CNF formulas), which of the following describes the correct and complete procedure to find a satisfying assignment for a given `UNEQUAL-SAT` instance $(\\phi, C)$?\n\nA. Construct a new formula $\\phi'$ by taking the logical AND of the original formula $\\phi$ with the clauses $(x_i \\lor x_j)$ and $(\\neg x_i \\lor \\neg x_j)$ for each constraint $(i, j)$ in $C$. Then, apply the standard self-reducibility algorithm on the new formula $\\phi'$.\n\nB. First, use the standard self-reducibility algorithm to find a satisfying assignment for the original formula $\\phi$. Then, check this assignment against the constraints in $C$. If a constraint $x_i \\neq x_j$ is violated, flip the value of $x_i$. Repeat this flipping process until all constraints in $C$ are satisfied.\n\nC. During the self-reducibility loop for variable $x_k$, after the oracle suggests a value (e.g., $x_k = \\text{True}$), manually check if this assignment violates any inequality constraint $x_k \\neq x_j$ where $x_j$ has already been assigned in a previous step. If it does, ignore the oracle and set $x_k$ to the opposite value. Otherwise, accept the oracle's suggestion.\n\nD. The problem cannot be solved with a standard SAT oracle. An oracle capable of directly processing inequality constraints is necessary because the structure of the `UNEQUAL-SAT` problem is fundamentally different from that of SAT.", "solution": "We are given a CNF formula $\\phi$ over variables $x_{1},\\ldots,x_{n}$ and a set of inequality constraints $C=\\{(i_{1},j_{1}),\\ldots,(i_{k},j_{k})\\}$, where each $(i,j)\\in C$ enforces $x_{i}\\neq x_{j}$. The goal is to find a satisfying assignment for the instance $(\\phi,C)$ using only a standard SAT oracle.\n\nThe key observation is that each inequality constraint $x_{i}\\neq x_{j}$ can be expressed in CNF without introducing new variables. For Boolean variables, the equivalence\n$$\nx_{i}\\neq x_{j}\\iff (x_{i}\\lor x_{j})\\land(\\neg x_{i}\\lor \\neg x_{j})\n$$\nholds. To justify this equivalence, note that $x_{i}\\neq x_{j}$ means exactly one of $x_{i},x_{j}$ is true. The conjunction $(x_{i}\\lor x_{j})$ enforces that at least one is true, and $(\\neg x_{i}\\lor \\neg x_{j})$ enforces that at least one is false. Taken together, they force exactly one to be true, which is precisely the meaning of $x_{i}\\neq x_{j}$. Conversely, if both clauses hold, then it cannot be that both are false (ruled out by $x_{i}\\lor x_{j}$) nor that both are true (ruled out by $\\neg x_{i}\\lor \\neg x_{j}$), so exactly one must be true, and thus $x_{i}\\neq x_{j}$ holds.\n\nUsing this equivalence, we construct a standard CNF formula\n$$\n\\phi' \\;=\\; \\phi \\;\\land\\; \\bigwedge_{(i,j)\\in C}\\Big((x_{i}\\lor x_{j})\\land(\\neg x_{i}\\lor \\neg x_{j})\\Big).\n$$\nBy construction, an assignment satisfies $\\phi'$ if and only if it satisfies $\\phi$ and all inequalities in $C$. Therefore, $(\\phi,C)$ is satisfiable if and only if $\\phi'$ is satisfiable, and any satisfying assignment of $\\phi'$ is a satisfying assignment for $(\\phi,C)$, and vice versa.\n\nGiven only a standard SAT oracle for CNF formulas, we can now apply the standard SAT self-reducibility procedure directly to $\\phi'$. Let the variables be ordered as $x_{1},\\ldots,x_{n}$. Initialize an empty partial assignment. For each $k$ from $1$ to $n$, define the partially assigned formula by substituting the already fixed values $x_{1}=v_{1},\\ldots,x_{k-1}=v_{k-1}$ into $\\phi'$, and then query the oracle on the formula obtained by additionally setting $x_{k}=\\text{True}$. If the oracle answers that the resulting formula is satisfiable, set $x_{k}=\\text{True}$; otherwise, set $x_{k}=\\text{False}$. This is the standard self-reduction for SAT and guarantees that, if $\\phi'$ is satisfiable, the process yields a complete assignment that satisfies $\\phi'$. Because $\\phi'$ encodes both $\\phi$ and the inequalities in $C$, the final assignment satisfies the original UNEQUAL-SAT instance $(\\phi,C)$.\n\nOptions B and C are incorrect because they decouple the enforcement of $C$ from the satisfiability of $\\phi$, potentially breaking satisfiability when flipping assignments or overriding oracle-guided choices without rechecking satisfiability. Option D is incorrect because the inequality constraints are expressible in CNF, so a standard SAT oracle suffices.\n\nTherefore, the correct and complete procedure is to encode the inequality constraints into CNF clauses, form $\\phi'$, and then apply the standard SAT self-reducibility algorithm to $\\phi'$.", "answer": "$$\\boxed{A}$$", "id": "1447152"}, {"introduction": "Understanding the trade-offs between general-purpose and specialized algorithms is crucial for effective problem-solving. While self-reducibility provides a universal method for any SAT instance, certain subclasses of SAT are \"tractable\" and admit much more efficient, direct algorithms. This final exercise [@problem_id:1447164] offers a valuable perspective by directly comparing the oracle-based self-reducibility method with a fast, greedy algorithm for Horn-SAT, a notable tractable subclass, highlighting the important relationship between a problem's structure and its computational difficulty.", "problem": "In computational complexity theory, many decision problems have a property called self-reducibility, which allows us to use a hypothetical solver (an \"oracle\") for the decision problem to solve the corresponding search problem.\n\nConsider the Boolean Satisfiability (SAT) problem for a formula in Conjunctive Normal Form (CNF). The decision problem is to determine *if* there exists an assignment of `true`/`false` values to the variables that makes the entire formula `true`. The search problem is to *find* such an assignment.\n\nLet's compare two algorithms for finding a satisfying assignment for a given satisfiable CNF formula $\\Phi$ with variables $\\{x_1, x_2, \\dots, x_n\\}$.\n\n**Algorithm 1: General Self-Reducibility**\nThis algorithm uses a black-box oracle, `is_satisfiable(formula)`, which returns `true` if a formula is satisfiable and `false` otherwise. To find a satisfying assignment for $\\Phi$, the algorithm iterates through the variables in a fixed order, say $x_1, x_2, \\dots, x_n$. For each variable $x_i$, it decides its value as follows:\n1. It constructs a new formula $\\Phi' = \\Phi \\land (x_1=v_1) \\land \\dots \\land (x_{i-1}=v_{i-1}) \\land (x_i=\\text{true})$, where $v_1, \\dots, v_{i-1}$ are the values assigned in previous steps.\n2. It queries the oracle: `is_satisfiable`($\\Phi'$).\n3. If the oracle returns `true`, the algorithm permanently sets $x_i = \\text{true}$. Otherwise, it must be that setting $x_i = \\text{false}$ will lead to a satisfying assignment (since we assume $\\Phi$ is satisfiable), so the algorithm permanently sets $x_i = \\text{false}$.\n\n**Algorithm 2: Greedy Algorithm for Horn-SAT**\nThis algorithm works only for a special subclass of CNF formulas called Horn formulas. A Horn clause is a clause with at most one non-negated (positive) variable. For example, $(\\neg x_1 \\lor \\neg x_2 \\lor x_3)$ is a Horn clause, but $(\\neg x_1 \\lor x_2 \\lor x_3)$ is not. The algorithm finds the unique, minimal satisfying assignment (if one exists) without any oracle.\n1. Start with an initial assignment where all variables are set to `false`.\n2. Repeatedly scan all clauses of the formula. If a clause implies that a variable must be `true` based on the current assignments, update that variable's assignment. Specifically, for any clause of the form $(\\neg y_1 \\lor \\dots \\lor \\neg y_k \\lor z)$, if all variables $y_1, \\dots, y_k$ are currently assigned `true`, then the assignment of $z$ is changed to `true`. This also applies to simpler clauses like $(z)$, which immediately forces $z$ to be `true`.\n3. This process continues until a full pass over all clauses results in no new changes to the variable assignments.\nLet an \"update\" be defined as a single event of changing a variable's assignment from `false` to `true`.\n\n**Your Task:**\nYou are given the following satisfiable Horn-CNF formula $\\Phi$ over the variables $\\{x_1, x_2, x_3, x_4\\}$:\n$$ \\Phi = (x_1) \\land (\\neg x_1 \\lor x_2) \\land (\\neg x_1 \\lor \\neg x_2 \\lor x_3) \\land (\\neg x_3 \\lor x_4) $$\n\nLet $N_{SR}$ be the total number of calls to the `is_satisfiable` oracle required by Algorithm 1 to determine the full satisfying assignment for $\\Phi$, processing variables in the order $x_1, x_2, x_3, x_4$.\n\nLet $N_{G}$ be the total number of \"updates\" (variable changes from `false` to `true`) that occur when running Algorithm 2 on $\\Phi$.\n\nCalculate the values of $N_{SR}$ and $N_{G}$. Present your answer as a $1 \\times 2$ row matrix containing the values of $N_{SR}$ and $N_{G}$ in that order.", "solution": "We analyze both algorithms on the given Horn-CNF formula\n$$\n\\Phi=(x_{1})\\land(\\neg x_{1}\\lor x_{2})\\land(\\neg x_{1}\\lor\\neg x_{2}\\lor x_{3})\\land(\\neg x_{3}\\lor x_{4})\n$$\nover variables $\\{x_{1},x_{2},x_{3},x_{4}\\}$.\n\nAlgorithm 1 (general self-reducibility with oracle is\\_satisfiable):\nBy the described procedure, for each variable $x_{i}$ in the fixed order $x_{1},x_{2},x_{3},x_{4}$, the algorithm performs exactly one oracle call on the formula obtained by conjoining the prior fixed assignments and $x_{i}=\\text{true}$. If the oracle answers true, $x_{i}$ is set to true; otherwise, by satisfiability of $\\Phi$, $x_{i}$ is set to false. Hence, regardless of the outcomes, there is exactly one oracle call per variable. Therefore,\n$$\nN_{SR}=4.\n$$\nConcretely for this $\\Phi$, the calls for $x_{1},x_{2},x_{3},x_{4}$ with $x_{i}=\\text{true}$ each return true because $(x_{1})$ forces $x_{1}=\\text{true}$, then $(\\neg x_{1}\\lor x_{2})$ forces $x_{2}=\\text{true}$, then $(\\neg x_{1}\\lor\\neg x_{2}\\lor x_{3})$ forces $x_{3}=\\text{true}$, and finally $(\\neg x_{3}\\lor x_{4})$ forces $x_{4}=\\text{true}$, so one call per variable suffices.\n\nAlgorithm 2 (greedy Horn-SAT algorithm counting updates from false to true):\nStart with all variables false.\n- Clause $(x_{1})$ forces $x_{1}=\\text{true}$: one update.\n- With $x_{1}=\\text{true}$, clause $(\\neg x_{1}\\lor x_{2})$ forces $x_{2}=\\text{true}$: second update.\n- With $x_{1}=\\text{true}$ and $x_{2}=\\text{true}$, clause $(\\neg x_{1}\\lor\\neg x_{2}\\lor x_{3})$ forces $x_{3}=\\text{true}$: third update.\n- With $x_{3}=\\text{true}$, clause $(\\neg x_{3}\\lor x_{4})$ forces $x_{4}=\\text{true}$: fourth update.\nAfter these four updates, a pass yields no further changes, so the process halts. Therefore,\n$$\nN_{G}=4.\n$$\n\nThus the requested $1\\times 2$ row matrix is $\\begin{pmatrix}4 & 4\\end{pmatrix}$.", "answer": "$$\\boxed{\\begin{pmatrix}4 & 4\\end{pmatrix}}$$", "id": "1447164"}]}