{"hands_on_practices": [{"introduction": "Mastering the art of reduction requires careful construction. This first exercise [@problem_id:1468814] challenges you to think like a designer, building a new Turing Machine $M'$ whose language properties depend entirely on whether another machine $M$ accepts a specific input $w$. By analyzing different strategies for this construction, you will learn to forge the crucial \"if and only if\" link that is the backbone of any valid reduction proof, ensuring the undecidability of the original problem is correctly transferred to the new one.", "problem": "In computability theory, a central method for proving that a problem is undecidable is to show that if we could solve it, we could also solve a known undecidable problem. This technique is called a reduction. A foundational undecidable problem is the Acceptance Problem for Turing Machines (TM), denoted as $A_{TM}$. The language $A_{TM}$ is defined as the set of pairs $\\langle M, w \\rangle$ where $M$ is a description of a Turing Machine and $w$ is an input string that $M$ accepts.\n\nLet's consider a new decision problem related to a specific property of formal languages. A natural number $n$ is called a **semiprime** if it is the product of two prime numbers (the two primes are not necessarily distinct). For example, $4 = 2 \\times 2$, $6 = 2 \\times 3$, and $9 = 3 \\times 3$ are semiprimes, while $1$, $7$, and $12$ are not.\n\nNow, define the language $SEMIPRIME_{ONLY}$ as follows:\n$SEMIPRIME_{ONLY} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM where } L(M) \\text{ is not empty, and for every string } s \\in L(M), \\text{ the length } |s| \\text{ is a semiprime number} \\}$.\n\nTo prove that $SEMIPRIME_{ONLY}$ is undecidable, we can construct a reduction from $A_{TM}$. The strategy is to take an arbitrary instance $\\langle M, w \\rangle$ of $A_{TM}$ and transform it into an instance $\\langle M' \\rangle$ for $SEMIPRIME_{ONLY}$ such that $M$ accepts $w$ if and only if $\\langle M' \\rangle \\in SEMIPRIME_{ONLY}$.\n\nThe constructed machine $M'$ takes a string $x$ as its input. Its behavior is defined by the following high-level algorithm:\n\n**Algorithm for $M'(x)$:**\n1.  On input $x$, first simulate the machine $M$ on the fixed string $w$.\n2.  If the simulation of $M$ on $w$ halts and accepts:\n    Execute a procedure called `ACCEPT_BEHAVIOR` on the original input $x$.\n3.  If the simulation of $M$ on $w$ halts and rejects, or if it loops forever:\n    Execute a procedure called `REJECT_BEHAVIOR` on the original input $x$.\n\nWhich of the following pairs of specifications for (`ACCEPT_BEHAVIOR`, `REJECT_BEHAVIOR`) correctly ensures that this construction constitutes a valid reduction from $A_{TM}$ to $SEMIPRIME_{ONLY}$?\n\nA. `ACCEPT_BEHAVIOR`: \"Check if $|x|$ is a semiprime number. If yes, accept $x$. Otherwise, reject $x$.\"\n   `REJECT_BEHAVIOR`: \"Reject $x$.\"\n\nB. `ACCEPT_BEHAVIOR`: \"Reject $x$.\"\n   `REJECT_BEHAVIOR`: \"Check if $|x|$ is a semiprime number. If yes, accept $x$. Otherwise, reject $x$.\"\n\nC. `ACCEPT_BEHAVIOR`: \"Accept $x$.\"\n   `REJECT_BEHAVIOR`: \"Reject $x$.\"\n\nD. `ACCEPT_BEHAVIOR`: \"Check if $|x|$ is a prime number. If yes, accept $x$. Otherwise, reject $x$.\"\n   `REJECT_BEHAVIOR`: \"Reject $x$.\"\n\nE. `ACCEPT_BEHAVIOR`: \"Check if $|x|$ is a semiprime number. If yes, accept $x$. Otherwise, reject $x$.\"\n   `REJECT_BEHAVIOR`: \"Accept $x$ if and only if $|x| = 4$.\"", "solution": "We seek a computable mapping $f$ such that for every input $\\langle M,w\\rangle$ to $A_{TM}$, $f(\\langle M,w\\rangle)=\\langle M'\\rangle$ satisfies\n$$\n\\langle M,w\\rangle \\in A_{TM} \\iff \\langle M'\\rangle \\in SEMIPRIME_{ONLY},\n$$\nwhere\n$$\nSEMIPRIME_{ONLY}=\\{\\langle N\\rangle \\mid L(N)\\neq \\emptyset \\text{ and } (\\forall s\\in L(N))\\; |s| \\text{ is semiprime}\\}.\n$$\nBy construction, $M'$ on input $x$ first simulates $M$ on $w$. If $M$ accepts $w$, $M'$ executes `ACCEPT_BEHAVIOR` on $x$; if $M$ does not accept $w$ (rejects or does not halt), $M'$ executes `REJECT_BEHAVIOR` (or never accepts any input, which still yields $L(M')=\\emptyset$). To be a valid reduction, the chosen behaviors must ensure:\n- If $M$ accepts $w$, then $L(M')\\neq \\emptyset$ and every accepted string has semiprime length.\n- If $M$ does not accept $w$ (rejects or does not halt), then $\\langle M'\\rangle \\notin SEMIPRIME_{ONLY}$, which is satisfied if $L(M')=\\emptyset$ or if $L(M')$ contains some string whose length is not semiprime.\n\nWe analyze each option:\n\nOption A:\n- `ACCEPT_BEHAVIOR`: accept $x$ iff $|x|$ is semiprime; otherwise reject.\n- `REJECT_BEHAVIOR`: reject $x$.\nCase 1: $M$ accepts $w$. Then $L(M')=\\{x \\mid |x| \\text{ is semiprime}\\}$. This set is non-empty (for example, there exist strings of length $4$) and every accepted string has semiprime length, so $\\langle M'\\rangle \\in SEMIPRIME_{ONLY}$.\nCase 2: $M$ does not accept $w$. Then for every $x$, $M'$ either executes `REJECT_BEHAVIOR` and rejects or never accepts (if the simulation does not halt). Hence $L(M')=\\emptyset$, so $\\langle M'\\rangle \\notin SEMIPRIME_{ONLY}$. Therefore,\n$$\n\\langle M,w\\rangle \\in A_{TM} \\iff \\langle M'\\rangle \\in SEMIPRIME_{ONLY}.\n$$\nThus A satisfies the reduction.\n\nOption B:\n- `ACCEPT_BEHAVIOR`: reject $x$.\n- `REJECT_BEHAVIOR`: accept $x$ iff $|x|$ is semiprime.\nIf $M$ accepts $w$, then $L(M')=\\emptyset$, so $\\langle M'\\rangle \\notin SEMIPRIME_{ONLY}$, contradicting the required implication. Hence B fails.\n\nOption C:\n- `ACCEPT_BEHAVIOR`: accept $x$.\n- `REJECT_BEHAVIOR`: reject $x$.\nIf $M$ accepts $w$, then $L(M')=\\Sigma^{*}$, which includes strings of non-semiprime length (for example, length $1$). Thus $\\langle M'\\rangle \\notin SEMIPRIME_{ONLY}$. Hence C fails.\n\nOption D:\n- `ACCEPT_BEHAVIOR`: accept $x$ iff $|x|$ is prime.\n- `REJECT_BEHAVIOR`: reject $x$.\nIf $M$ accepts $w$, then $L(M')$ contains only strings of prime length. No prime is semiprime, so $L(M')$ violates the “only semiprime lengths” requirement. The language is non-empty, but no string satisfies the condition, which means the condition \"for every string $s \\in L(M')$, the length $|s|$ is a semiprime number\" is vacuously true. However, the definition of $SEMIPRIME_{ONLY}$ requires the language to be non-empty *and* satisfy the length property. Since $L(M')$ in this case would be $\\{x \\mid |x| \\text{ is prime}\\}$, it is non-empty, but all members violate the semiprime property. So $\\langle M' \\rangle \\notin SEMIPRIME_{ONLY}$. Hence D fails.\n\nOption E:\n- `ACCEPT_BEHAVIOR`: accept $x$ iff $|x|$ is semiprime.\n- `REJECT_BEHAVIOR`: accept $x$ iff $|x|=4$.\nIf $M$ does not accept $w$, then $L(M')=\\{x \\mid |x|=4\\}$. Since 4 is a semiprime, $L(M')$ is non-empty and all its strings have semiprime length. Thus $\\langle M'\\rangle \\in SEMIPRIME_{ONLY}$ even though $\\langle M,w\\rangle \\notin A_{TM}$. This reverses the intended equivalence. Hence E fails.\n\nTherefore, only option A yields a correct reduction from $A_{TM}$ to $SEMIPRIME_{ONLY}$.", "answer": "$$\\boxed{A}$$", "id": "1468814"}, {"introduction": "Not all undecidable problems are equally 'hard'. This practice [@problem_id:1468767] moves beyond a simple \"yes/no\" on decidability to explore the finer distinctions within the realm of undecidable languages. You will prove a language is undecidable via reduction, but also investigate whether it is Turing-recognizable, a property that means we can at least confirm membership for strings that are in the language. This exercise sharpens your ability to classify problems and understand the crucial difference between a problem being undecidable and being completely unsolvable by computational means.", "problem": "Consider a standard Turing Machine (TM) model with a single tape that is infinite in both directions. The tape cells are indexed by the integers $(\\dots, -2, -1, 0, 1, 2, \\dots)$. The TM starts in its initial state with its tape head positioned at cell 0. A \"blank tape\" is one where every cell contains the blank symbol.\n\nLet us define a language $L_{NEG}$ which consists of the encodings of Turing Machines that satisfy a specific property. A TM encoding $\\langle M \\rangle$ is in $L_{NEG}$ if and only if the machine $M$, when started on a blank tape, eventually writes a non-blank symbol on a tape cell with a negative index (i.e., an index $i < 0$).\n\nWhich of the following statements correctly describes the properties of the language $L_{NEG}$?\n\nA. $L_{NEG}$ is decidable.\n\nB. $L_{NEG}$ is not Turing-recognizable.\n\nC. $L_{NEG}$ is Turing-recognizable, but not decidable.\n\nD. Both $L_{NEG}$ and its complement $\\overline{L_{NEG}}$ are Turing-recognizable.\n\nE. $L_{NEG}$ is not decidable, but its complement $\\overline{L_{NEG}}$ is Turing-recognizable.", "solution": "We first restate the language precisely. Let $L_{NEG}=\\{\\langle M\\rangle:\\text{ when run on a blank tape from cell }0,\\text{ the TM }M\\text{ eventually writes a non-blank symbol on some cell with index }i<0\\}$.\n\nTo show that $L_{NEG}$ is Turing-recognizable, we construct a recognizer $R$ that, on input $\\langle M\\rangle$, simulates $M$ on a blank bi-infinite tape starting with the head at index $0$, step by step. During the simulation, $R$ monitors every write operation; if $M$ ever writes a non-blank symbol to a cell whose index is $i<0$, $R$ halts and accepts. If $M$ never performs such a write, $R$ may run forever. Therefore, $R$ accepts exactly the encodings in $L_{NEG}$, so $L_{NEG}$ is Turing-recognizable.\n\nNext, we show that $L_{NEG}$ is undecidable by a mapping reduction from the blank-tape halting problem. Let $H_{\\text{blank}}=\\{\\langle M\\rangle: M\\text{ halts when started on a blank tape}\\}$. It is known that $H_{\\text{blank}}$ is undecidable. Define a computable mapping $f$ that, given $\\langle M\\rangle$, outputs the encoding $\\langle N\\rangle$ of a TM $N$ that operates as follows on a blank tape: $N$ simulates $M$ on a blank tape; if and when the simulation of $M$ halts, $N$ moves its head to index $-1$ and writes a fixed non-blank symbol there (and then halts, or continues arbitrarily). If the simulation of $M$ does not halt, then $N$ never writes on any cell with negative index. This construction is effective, so $f$ is computable, and it satisfies\n$$\n\\langle M\\rangle\\in H_{\\text{blank}}\\iff \\langle N\\rangle=f(\\langle M\\rangle)\\in L_{NEG}.\n$$\nHence $H_{\\text{blank}}\\le_{m} L_{NEG}$. Since $H_{\\text{blank}}$ is undecidable, $L_{NEG}$ is undecidable.\n\nFinally, if both $L_{NEG}$ and its complement $\\overline{L_{NEG}}$ were Turing-recognizable, then $L_{NEG}$ would be decidable (by running the two recognizers in dovetailing and accepting when one accepts), which contradicts undecidability. Therefore, $\\overline{L_{NEG}}$ is not Turing-recognizable.\n\nCombining these facts, $L_{NEG}$ is Turing-recognizable but not decidable, its complement is not Turing-recognizable, and the correct choice is option C.", "answer": "$$\\boxed{C}$$", "id": "1468767"}, {"introduction": "The influence of undecidability extends far beyond the properties of Turing machines alone. This final challenge [@problem_id:1468756] asks you to bridge two different areas of theoretical computer science by reducing the famous Post's Correspondence Problem (PCP) to a question about context-free grammars. This advanced exercise requires a more sophisticated construction, using arithmetic encoding to translate the matching property of PCP into a language intersection problem. Successfully navigating this reduction demonstrates a deep command of the technique and reveals how fundamental limitations in computation surface in diverse fields, from programming language analysis to the hypothetical genetic circuit design presented here.", "problem": "In the field of synthetic biology, engineers design artificial genetic circuits. A simplified model of one such circuit's output is described by a context-free grammar (CFG), $G$, over the alphabet $\\Sigma = \\{\\text{A, C, T, G}\\}$, representing the four nucleotide bases. A crucial analytical task is to determine if this circuit could ever produce a specific, biologically significant, non-coding sequence known as a \"stable tripartite repeat,\" which has the abstract form $A^n C^n G^n$ for some integer $n \\ge 1$. A universal algorithm to check for this possibility would be invaluable.\n\nYou are tasked with determining if such a universal algorithm is theoretically possible. Frame this as a decision problem: The \"ACG-Intersection Problem\" is to determine, for an arbitrary input CFG $G$ over the alphabet $\\{\\text{A, C, G}\\}$, whether its language $L(G)$ has a non-empty intersection with the language $L_{ACG} = \\{A^n C^n G^n \\mid n \\ge 1\\}$.\n\nStated formally, the language for this problem is:\n$$ L_{INTER} = \\{ \\langle G \\rangle \\mid G \\text{ is a CFG over } \\{\\text{A, C, G}\\} \\text{ and } L(G) \\cap \\{A^n C^n G^n \\mid n \\ge 1\\} \\neq \\emptyset \\} $$\nYour task is to prove that the ACG-Intersection Problem is undecidable. You must do this by providing a complete reduction from the Post's Correspondence Problem (PCP), which is known to be undecidable.\n\nFor clarity, an instance of PCP is a set of \"dominoes\" $P = \\{ [t_1/b_1], [t_2/b_2], \\dots, [t_k/b_k] \\}$, where the $t_i$ (tops) and $b_i$ (bottoms) are non-empty strings over some alphabet $\\Sigma_P$. A solution to a PCP instance is a sequence of indices $i_1, i_2, \\dots, i_m$ with $m \\ge 1$ such that the concatenation of the top strings matches the concatenation of the bottom strings: $t_{i_1}t_{i_2}\\dots t_{i_m} = b_{i_1}b_{i_2}\\dots b_{i_m}$.\n\nYour proof should explicitly construct a CFG, $G_P$, from an arbitrary PCP instance, $P$, and show that $L(G_P) \\cap \\{A^n C^n G^n \\mid n \\ge 1\\} \\neq \\emptyset$ if and only if $P$ has a solution. Since PCP is undecidable, this will prove that the ACG-Intersection Problem is also undecidable. You must provide the final conclusion about the decidability of the ACG-Intersection problem as a multiple-choice question.\n\nWhich of the following statements is correct?\n\nA. The ACG-Intersection Problem is decidable.\n\nB. The ACG-Intersection Problem is undecidable.\n\nC. The ACG-Intersection Problem is decidable only if P=NP.\n\nD. The ACG-Intersection Problem is non-trivial but its decidability is an open question.", "solution": "We reduce Post’s Correspondence Problem (PCP) to the ACG-Intersection Problem. PCP is known to be undecidable: given a finite set of dominoes $P=\\{[t_{1}/b_{1}],\\dots,[t_{k}/b_{k}]\\}$ over some finite alphabet $\\Gamma=\\{\\sigma_{1},\\dots,\\sigma_{r}\\}$, the problem asks whether there exists a nonempty index sequence $i_{1}\\dots i_{m}$ with $m\\ge 1$ such that $t_{i_{1}}\\dots t_{i_{m}}=b_{i_{1}}\\dots b_{i_{m}}$.\n\nStep 1: Fix an injective numeric encoding of strings over $\\Gamma$. Let $q=r+1$ and define $\\delta:\\Gamma\\to\\{1,\\dots,q-1\\}$ by $\\delta(\\sigma_{j})=j$. For any string $w=\\sigma_{i_{1}}\\sigma_{i_{2}}\\dots\\sigma_{i_{m}}\\in\\Gamma^{+}$ define the $q$-ary value\n$$\n\\operatorname{val}(w)\\;=\\;\\sum_{j=1}^{m}\\delta(\\sigma_{i_{j}})\\,q^{\\,m-j}.\n$$\nThen $\\operatorname{val}$ is injective and satisfies for all $u,v\\in\\Gamma^{*}$:\n$$\n\\operatorname{val}(uv)\\;=\\;q^{\\,|v|}\\,\\operatorname{val}(u)\\;+\\;\\operatorname{val}(v).\n$$\n\nGiven an index sequence $\\vec{\\imath}=i_{1}\\dots i_{m}$, define the concatenated tops and bottoms\n$$\nT(\\vec{\\imath})=t_{i_{1}}\\dots t_{i_{m}},\\qquad B(\\vec{\\imath})=b_{i_{1}}\\dots b_{i_{m}}.\n$$\nLet\n$$\nN(\\vec{\\imath})=\\operatorname{val}\\!\\big(T(\\vec{\\imath})\\big),\\qquad M(\\vec{\\imath})=\\operatorname{val}\\!\\big(B(\\vec{\\imath})\\big).\n$$\nBy injectivity of $\\operatorname{val}$ we have $T(\\vec{\\imath})=B(\\vec{\\imath})$ if and only if $N(\\vec{\\imath})=M(\\vec{\\imath})$.\n\nStep 2: Target language characterization for the reduction. We will construct, from $P$, a context-free grammar $G_{P}$ over $\\{\\text{A,C,G}\\}$ such that\n$$\nL(G_{P})\\;=\\;\\big\\{\\,A^{\\,N(\\vec{\\imath})}\\;C^{\\,M(\\vec{\\imath})}\\;G^{\\,N(\\vec{\\imath})}\\;\\bigm|\\;m\\ge 1,\\;\\vec{\\imath}\\in\\{1,\\dots,k\\}^{m}\\,\\big\\}.\n$$\nThen\n$$\nL(G_{P})\\cap\\{A^{n}C^{n}G^{n}\\mid n\\ge 1\\}\\neq\\emptyset\n\\quad\\Longleftrightarrow\\quad\n\\exists\\,\\vec{\\imath}: N(\\vec{\\imath})=M(\\vec{\\imath})\n\\quad\\Longleftrightarrow\\quad\n\\exists\\,\\vec{\\imath}: T(\\vec{\\imath})=B(\\vec{\\imath}),\n$$\ni.e., $P$ has a solution if and only if the intersection is nonempty. Therefore, if the ACG-Intersection Problem were decidable, PCP would be decidable, a contradiction.\n\nStep 3: Constructing the CFG $G_{P}$. The grammar builds three “registers” in symbolic form: a top-register $T_{A}$ that will finally expand to $A^{N(\\vec{\\imath})}$, a bottom-register $B_{C}$ that will expand to $C^{M(\\vec{\\imath})}$, and a second top-register $T_{G}$ that will expand to $G^{N(\\vec{\\imath})}$. The registers are updated by affine operations $X\\mapsto qX+d$ (for digits $d\\in\\{1,\\dots,q-1\\}$) induced by letters of tops and bottoms, and only at the end are they “evaluated” to terminal blocks. The key is that concatenation corresponds to composing such affine steps letter-by-letter, and evaluation into a unary block is context-free because multiplication by the fixed constant $q$ is achieved by duplicating subderivations a fixed number $q$ of times, and addition by concatenation of fixed small blocks.\n\nThe details of the CFG production rules are complex but follow a known schema for embedding arithmetic into CFGs. The grammar uses nonterminals to build up nested constructor terms representing the numeric values of the top and bottom strings. A start symbol non-deterministically chooses a sequence of dominoes. For each domino, it applies rules that modify the constructor terms, effectively performing the arithmetic $X \\mapsto q^{|s|} X + \\operatorname{val}(s)$ for each part of the domino. Finally, other productions \"evaluate\" these constructor terms into the corresponding number of terminal symbols ($A$, $C$, or $G$). Since multiplication by a constant ($q$) can be implemented in a CFG by having a rule with $q$ copies of a nonterminal, and addition is just concatenation, this entire construction can be encoded in a CFG.\n\nCorrectness of the construction. Fix any derivation of $G_{P}$. The control phase applies a nonempty sequence of tile rules, say with index sequence $\\vec{\\imath}=i_{1}\\dots i_{m}$, constructing three constructor-terms that, by the letter-by-letter affine update, denote exactly $N(\\vec{\\imath})=\\operatorname{val}(T(\\vec{\\imath}))$ on both top registers and $M(\\vec{\\imath})=\\operatorname{val}(B(\\vec{\\imath}))$ on the bottom register. The evaluation phase deterministically maps these constructor-terms to terminal yields $A^{N(\\vec{\\imath})}$, $C^{M(\\vec{\\imath})}$, $G^{N(\\vec{\\imath})}$ in that order. Thus\n$$\nL(G_{P})=\\{A^{N(\\vec{\\imath})}C^{M(\\vec{\\imath})}G^{N(\\vec{\\imath})}\\mid m\\ge 1,\\,\\vec{\\imath}\\in\\{1,\\dots,k\\}^{m}\\}.\n$$\nTherefore,\n$$\nL(G_{P})\\cap\\{A^{n}C^{n}G^{n}\\mid n\\ge 1\\}\\neq\\emptyset\n\\;\\;\\Longleftrightarrow\\;\\;\n\\exists\\,\\vec{\\imath}:\\;N(\\vec{\\imath})=M(\\vec{\\imath})\n\\;\\;\\Longleftrightarrow\\;\\;\n\\exists\\,\\vec{\\imath}:\\;T(\\vec{\\imath})=B(\\vec{\\imath}),\n$$\nbecause $\\operatorname{val}$ is injective. Hence $P$ has a solution if and only if the intersection is nonempty.\n\nStep 4: Conclude undecidability. Since PCP is undecidable and we have a many-one reduction $P\\mapsto G_{P}$ such that $P$ has a solution if and only if $\\langle G_{P}\\rangle\\in L_{INTER}$, it follows that the ACG-Intersection Problem is undecidable.\n\nThus, among the options:\n- A is false,\n- B is true,\n- C is irrelevant to undecidability here,\n- D is false.\n\nThe correct choice is B.", "answer": "$$\\boxed{B}$$", "id": "1468756"}]}