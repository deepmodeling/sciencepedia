{"hands_on_practices": [{"introduction": "The diagonalization method is a powerful proof technique first introduced by Georg Cantor to show that the real numbers are uncountable. At its heart, the method provides a recipe for constructing an object that is guaranteed not to be on a predefined infinite list. This first practice invites you to apply this core logic in the context of computable functions, building a new function that systematically differs from every function in an enumerated list, thereby proving its novelty [@problem_id:1456293].", "problem": "Let $\\mathbb{N} = \\{1, 2, 3, \\ldots\\}$ be the set of natural numbers. Consider an effective enumeration $f_1, f_2, f_3, \\ldots$ which is a list containing all total computable functions that map from $\\mathbb{N}$ to $\\mathbb{N}$. A function is \"total\" if it is defined for every input in its domain. A function is \"computable\" if an algorithm exists that can compute its output for any given input and is guaranteed to halt. The enumeration being \"effective\" means that for any index $i$, we can retrieve the algorithm corresponding to the function $f_i$.\n\nOur goal is to construct a new function $g: \\mathbb{N} \\to \\mathbb{N}$ that is also total and computable, but is guaranteed *not* to be on the list $f_1, f_2, f_3, \\ldots$.\n\nWhich of the following proposed definitions for $g(i)$ successfully constructs a function that meets all three required properties: being total, being computable, and being distinct from every function $f_j$ in the given enumeration? Select all valid options.\n\nA. $g(i) = f_i(i) + 1$\n\nB. $g(i) = f_i(i+1)$\n\nC. $g(i) = (f_i(i))^2 + 1$\n\nD. $g(i) = f_{i+1}(i)$\n\nE. $g(i) = \\begin{cases} 1  \\text{if } f_i(i) = 1 \\\\ f_i(i) - 1  \\text{if } f_i(i) > 1 \\end{cases}$", "solution": "We are given an effective enumeration $f_{1}, f_{2}, f_{3}, \\ldots$ of total computable functions $f_{i} : \\mathbb{N} \\to \\mathbb{N}$, where for each $i$ we can retrieve and run a program computing $f_{i}$. For each proposed definition of $g(i)$, we must check three properties:\n- Totality: For every $i \\in \\mathbb{N}$, $g(i)$ is defined and the computation halts.\n- Computability: There is an algorithm to compute $g(i)$ for each $i$.\n- Distinctness: For every $j \\in \\mathbb{N}$, $g \\neq f_{j}$ as functions. A standard way to guarantee this is to force $g(i) \\neq f_{i}(i)$ for each $i$, which by diagonalization implies $g \\neq f_{j}$ for all $j$.\n\nBecause each $f_{i}$ is total computable, for any $i$ and any input used inside $g(i)$ (such as $i$ or $i+1$), $f_{i}$ halts and yields a value in $\\mathbb{N}$. Thus any $g$ that is a fixed arithmetic or bounded-case transformation of these values is total and computable. The key distinction between the options is whether $g$ is guaranteed to differ from every $f_{j}$.\n\nAnalyze each option:\n\nA. $g(i) = f_{i}(i) + 1$.\n- Totality: For each $i$, $f_{i}(i)$ halts and is in $\\mathbb{N}$, so $g(i)$ is defined.\n- Computability: Given $i$, compute $f_{i}(i)$ and add $1$.\n- Distinctness: For each $i$, $g(i) \\neq f_{i}(i)$ because $f_{i}(i) + 1 \\neq f_{i}(i)$. Hence $g \\neq f_{i}$ for every $i$, so $g$ is not equal to any function on the list. This is the standard diagonalization.\n\nTherefore A succeeds.\n\nB. $g(i) = f_{i}(i+1)$.\n- Totality: For each $i$, $f_{i}(i+1)$ halts since $f_{i}$ is total.\n- Computability: Given $i$, compute $f_{i}(i+1)$.\n- Distinctness: There is no guaranteed index at which $g$ must differ from a given $f_{j}$. In particular, for $j=i$, it is possible that $f_{i}(i+1) = f_{i}(i)$ (for example if $f_{i}$ is constant), so we do not force $g(i) \\neq f_{i}(i)$. More generally, since $g$ is a total computable function, and the list contains all total computable functions, it is consistent that $g = f_{k}$ for some $k$. Thus this definition does not guarantee $g$ is distinct from every $f_{j}$.\n\nTherefore B fails the distinctness guarantee.\n\nC. $g(i) = (f_{i}(i))^{2} + 1$.\n- Totality: For each $i$, $f_{i}(i)$ halts in $\\mathbb{N}$, so $(f_{i}(i))^{2} + 1$ is defined in $\\mathbb{N}$.\n- Computability: Given $i$, compute $f_{i}(i)$, square it, and add $1$.\n- Distinctness: For every integer $n$, the equation $n^{2} + 1 = n$ has no solution (since $n^{2} - n + 1 = 0$ has negative discriminant), so $g(i) \\neq f_{i}(i)$ for all $i$. Hence $g \\neq f_{i}$ for every $i$, guaranteeing that $g$ is not on the list.\n\nTherefore C succeeds.\n\nD. $g(i) = f_{i+1}(i)$.\n- Totality: For each $i$, $f_{i+1}(i)$ halts since $f_{i+1}$ is total.\n- Computability: Given $i$, compute $f_{i+1}(i)$.\n- Distinctness: For $j = i+1$, we have $g(i) = f_{i+1}(i)$, so at the specific input $i$ the outputs of $g$ and $f_{i+1}$ are equal. There is no forced disagreement at any fixed coordinate with any fixed $f_{j}$, so no diagonal contradiction is obtained. Thus it is not guaranteed that $g$ differs from every $f_{j}$.\n\nTherefore D fails the distinctness guarantee.\n\nE. \n$$\ng(i) = \n\\begin{cases}\n1  \\text{if } f_{i}(i) = 1 \\\\\nf_{i}(i) - 1  \\text{if } f_{i}(i) > 1\n\\end{cases}\n$$\n- Totality: For each $i$, $f_{i}(i)$ halts and is in $\\mathbb{N} = \\{1,2,3,\\ldots\\}$, so either $f_{i}(i)=1$ or $f_{i}(i)>1$, and $g(i)$ is defined in $\\mathbb{N}$.\n- Computability: Given $i$, compute $f_{i}(i)$ and apply the case rule.\n- Distinctness: If $f_{i}(i) = 1$, then $g(i) = 1 = f_{i}(i)$, so we do not force $g(i) \\neq f_{i}(i)$ at index $i$. Hence there is no guaranteed diagonal disagreement, and it is not ensured that $g$ differs from every $f_{j}$.\n\nTherefore E fails the distinctness guarantee.\n\nConclusion: The definitions that guarantee all three properties (total, computable, and provably not equal to any $f_{j}$) are A and C.", "answer": "$$\\boxed{AC}$$", "id": "1456293"}, {"introduction": "Having grasped the basic diagonal argument, we can now apply it to the world of computation to prove fundamental limitations. This exercise demonstrates that the power of diagonalization extends beyond simple functions to entire classes of languages. You will use a self-referential argument to show that a specific language, defined based on how Deterministic Finite Automata (DFAs) act on their own encodings, cannot itself be regular [@problem_id:1456281]. This illustrates how the method can establish sharp boundaries on the capabilities of computational models.", "problem": "In the theory of computation, we often use encoding schemes to represent computational models like automata as strings. This allows us to ask questions about the properties of the models themselves.\n\nLet the alphabet be $\\Sigma = \\{0, 1\\}$. Consider a fixed, reasonable encoding scheme where any Deterministic Finite Automaton (DFA), a finite-state machine that accepts or rejects a given string of symbols, can be represented as a unique string $\\langle D \\rangle \\in \\Sigma^*$. Let $\\mathcal{D}$ be the set of all such valid encodings. For any string $w \\in \\mathcal{D}$, let $D_w$ be the DFA that $w$ encodes, and let $L(D_w)$ be the language accepted by the DFA $D_w$.\n\nNow, consider the special \"diagonal\" language $L_{DIAG}$ defined as:\n$$L_{DIAG} = \\{ w \\in \\mathcal{D} \\mid w \\notin L(D_w) \\}$$\nThis language consists of all valid DFA encodings that are *not* accepted by the very DFA they encode.\n\nWhich of the following statements accurately describes the language $L_{DIAG}$?\n\nA. $L_{DIAG}$ is a regular language.\n\nB. $L_{DIAG}$ is not a regular language.\n\nC. The regularity of $L_{DIAG}$ is undecidable.\n\nD. $L_{DIAG}$ is an empty language because no such string $w$ can exist.\n\nE. Whether $L_{DIAG}$ is regular or not depends on the specific encoding scheme used for the DFAs.", "solution": "We define the set of valid DFA encodings as $\\mathcal{D} \\subseteq \\Sigma^{*}$ with a unique correspondence $w \\mapsto D_{w}$, and the diagonal language\n$$\nL_{DIAG}=\\{w \\in \\mathcal{D} \\mid w \\notin L(D_{w})\\}.\n$$\nWe prove $L_{DIAG}$ is not regular by contradiction.\n\nAssume $L_{DIAG}$ is regular. Then there exists a DFA, call it $D^{*}$, such that\n$$\nL(D^{*})=L_{DIAG}.\n$$\nLet $w^{*}$ be the unique encoding of $D^{*}$, so $D_{w^{*}}=D^{*}$ by definition of the encoding scheme. Consider the membership of $w^{*}$.\n\nBy the definition of $L_{DIAG}$,\n$$\nw^{*} \\in L_{DIAG} \\iff w^{*} \\notin L(D_{w^{*}}).\n$$\nSince $D_{w^{*}}=D^{*}$, this rewrites as\n$$\nw^{*} \\in L_{DIAG} \\iff w^{*} \\notin L(D^{*}).\n$$\nBut we also have $L(D^{*})=L_{DIAG}$, hence\n$$\nw^{*} \\in L(D^{*}) \\iff w^{*} \\in L_{DIAG}.\n$$\nCombining the two equivalences yields\n$$\nw^{*} \\in L(D^{*}) \\iff w^{*} \\notin L(D^{*}),\n$$\na contradiction. Therefore, no DFA recognizes $L_{DIAG}$, and $L_{DIAG}$ is not regular.\n\nTo rule out other options: $L_{DIAG}$ is not empty, since if $D_{\\text{rej}}$ is a DFA that rejects all inputs and $w_{\\text{rej}}$ is its encoding, then $w_{\\text{rej}} \\notin L(D_{w_{\\text{rej}}})$, so $w_{\\text{rej}} \\in L_{DIAG}$. The argument is independent of the specific reasonable, unique encoding scheme because it only uses the existence of the self-encoding $w^{*}$ of $D^{*}$. Hence the correct description is that $L_{DIAG}$ is not a regular language.", "answer": "$$\\boxed{B}$$", "id": "1456281"}, {"introduction": "This final practice showcases diagonalization in its most impactful role within complexity theory: separating complexity classes. Here, we add the crucial ingredient of computational resources, specifically time, to the diagonal argument. By constructing a language that diagonalizes against all linear-time Turing machines, you will prove that there are problems solvable in quadratic time that are fundamentally beyond the reach of any linear-time algorithm, laying the groundwork for the famous Time Hierarchy Theorems [@problem_id:1456284].", "problem": "In the study of computational complexity, the diagonalization method is a powerful proof technique used to separate complexity classes. This problem asks you to apply the core logic of diagonalization to identify a language with specific properties.\n\nYou are given the following standard assumptions:\n1.  There exists a fixed, reasonable binary encoding scheme for deterministic Turing Machines (TMs). The binary string encoding for a TM `M` is denoted by $\\langle M \\rangle$. We assume that any binary string can be tested in polynomial time to determine if it is a valid encoding of a TM.\n2.  There exists a Universal Turing Machine (UTM) capable of simulating any given TM `M` on any given input `w`. The overhead for this simulation is such that simulating `T` steps of `M` takes at most $k \\cdot T \\log T$ steps on the UTM, where `k` is a universal constant.\n3.  For a function $f: \\mathbb{N} \\to \\mathbb{N}$, $DTIME(f(n))$ is the class of all languages that can be decided by a deterministic TM in at most $c \\cdot f(|w|)$ steps for any input `w`, where `c` is some positive constant.\n4.  Let $\\mathcal{C}_{linear}$ be the complexity class corresponding to linear time, defined as $\\mathcal{C}_{linear} = \\bigcup_{d \\in \\mathbb{N}, d>0} DTIME(d \\cdot n)$.\n\nYour task is to identify which of the following language definitions describes a language $L$ that satisfies **both** of the following conditions:\n1.  $L \\in DTIME(n^2)$\n2.  $L \\notin \\mathcal{C}_{linear}$\n\nAssume that if a string `w` is not a valid encoding $\\langle M \\rangle$ for some TM `M`, then `w` is not in any of the languages defined below.\n\nWhich of the following defines such a language $L$?\n\nA. $L = \\{w \\mid w = \\langle M \\rangle \\text{, and the TM } M \\text{ accepts the input } w \\text{ within } |w| \\text{ steps.}\\}$\n\nB. $L = \\{w \\mid w = \\langle M \\rangle \\text{, and the TM } M \\text{ does not accept the input } w \\text{ within } |w| \\text{ steps.}\\}$\n\nC. $L = \\{w \\mid w = \\langle M \\rangle \\text{, and the TM } M \\text{ does not accept the input } w \\text{ within } |w|^{1.5} \\text{ steps.}\\}$\n\nD. $L = \\{w \\mid w = \\langle M \\rangle \\text{, and the TM } M \\text{ does not accept the input } w \\text{ (with no time limit).}\\}$\n\nE. $L = \\{w \\mid w = \\langle M \\rangle \\text{, and the TM } M \\text{ does not accept the input } w \\text{ within } |w|^3 \\text{ steps.}\\}$", "solution": "We analyze each candidate and identify one language that is decidable in quadratic time but not in linear time by a diagonalization argument. Throughout, let the input length be $n = |w|$ and let $k>0$ be the universal constant from the UTM simulation overhead: simulating $T$ steps of a TM takes at most $k T \\log T$ steps.\n\nKey diagonalization template. For a threshold function $t(n)$, consider\n$$\nL_{t} \\;=\\; \\{\\, \\langle M \\rangle \\mid \\text{TM } M \\text{ does not accept } \\langle M \\rangle \\text{ within } t(n) \\text{ steps}\\,\\}.\n$$\nTwo properties make this template useful:\n- Decidability within time roughly that needed to simulate $t(n)$ steps: a decider can simulate $M$ on $\\langle M \\rangle$ for at most $t(n)$ steps and accept iff acceptance does not occur within that bound. On the given UTM, this costs at most $k\\,t(n)\\,\\log t(n)$ steps. For $t(n)$ subquadratic, this falls within $DTIME(n^{2})$ because there exists a constant $c$ such that $k\\,t(n)\\,\\log t(n) \\leq c\\,n^{2}$ for all $n$ (adjust $c$ to cover finitely many small $n$).\n- Separation from linear time: if $t(n)$ dominates every linear function $d n$ eventually (i.e., for all $d>0$ there exists $N$ with $d n \\leq t(n)$ for all $n \\geq N$), then $L_{t} \\notin \\mathcal{C}_{linear}$. Indeed, suppose $L_{t} \\in DTIME(d n)$ for some $d>0$ via a decider $N$. For sufficiently large $n$ and input $w=\\langle N \\rangle$ with $|w|=n$, we have $d n \\leq t(n)$, hence $N$ halts within $t(n)$ steps on $w$. By the definition of $L_{t}$, $w \\in L_{t}$ iff $N$ does not accept $w$ within $t(n)$ steps, which is equivalent to $N$ does not accept $w$ at all. Thus $N(w)=1$ iff $N(w)=0$, a contradiction. Hence $L_{t} \\notin DTIME(d n)$ for every $d>0$, so $L_{t} \\notin \\mathcal{C}_{linear}$.\n\nNow evaluate the options:\n\nA. Threshold $t(n)=n$ with acceptance condition rather than the diagonal negation. The straightforward decider simulates for $n$ steps and accepts iff acceptance occurs, costing at most $k n \\log n$, so $A \\in DTIME(n \\log n) \\subseteq DTIME(n^{2})$. However, the diagonalization argument above that rules out all linear times requires using the negation and a threshold that strictly dominates $d n$ for all $d$, which $t(n)=n$ does not. Therefore option A does not ensure the separation $L \\notin \\mathcal{C}_{linear}$.\n\nB. Threshold $t(n)=n$ with the diagonal negation. Deciding B by simulating for $n$ steps costs at most $k n \\log n$, so $B \\in DTIME(n \\log n) \\subseteq DTIME(n^{2})$. But $t(n)=n$ does not eventually dominate $d n$ for arbitrary constants $d>0$. Thus the standard diagonal contradiction against all linear-time bounds does not go through, and we cannot conclude $B \\notin \\mathcal{C}_{linear}$ from the given setup.\n\nC. Threshold $t(n)=n^{1.5}$ with the diagonal negation. Define\n$$\nL_{C} \\;=\\; \\{\\; \\langle M \\rangle \\mid \\text{TM } M \\text{ does not accept } \\langle M \\rangle \\text{ within } n^{1.5} \\text{ steps}\\;\\}.\n$$\nMembership in $DTIME(n^{2})$: Decide $L_{C}$ by simulating $M$ on $\\langle M \\rangle$ for at most $n^{1.5}$ steps and accepting iff no acceptance occurs within that bound. The UTM overhead yields a running time at most\n$$\nk\\,n^{1.5}\\,\\log(n^{1.5}) \\;=\\; \\tfrac{3}{2}k\\,n^{1.5}\\,\\log n \\;\\leq\\; c\\,n^{2}\n$$\nfor a suitable constant $c>0$, since $\\frac{n^{1.5}\\log n}{n^{2}}=\\frac{\\log n}{n^{0.5}} \\to 0$ as $n \\to \\infty$, so a global bound exists after adjusting $c$ to cover finitely many small inputs. Thus $L_{C} \\in DTIME(n^{2})$.\n\nNot in linear time: Assume for contradiction that $L_{C} \\in DTIME(d n)$ for some $d>0$ via a decider $N$. For $n$ sufficiently large, $d n \\leq n^{1.5}$. Let $w=\\langle N \\rangle$ with $|w|=n$. Then $N$ halts on $w$ within $n^{1.5}$ steps, so by the definition of $L_{C}$,\n$$\nw \\in L_{C} \\;\\;\\Longleftrightarrow\\;\\; N \\text{ does not accept } w \\text{ within } n^{1.5} \\text{ steps}\n\\;\\;\\Longleftrightarrow\\;\\; N \\text{ does not accept } w.\n$$\nBut $N$ decides $L_{C}$, so $N(w)=1$ iff $w \\in L_{C}$, which equals $1$ iff $N(w)=0$, a contradiction. Therefore $L_{C} \\notin \\mathcal{C}_{linear}$.\n\nHence option C satisfies both required conditions.\n\nD. No time bound (“does not accept with no time limit”) is the complement of the self-acceptance problem and is undecidable by standard diagonalization, so it is not in $DTIME(n^{2})$.\n\nE. Threshold $t(n)=n^{3}$ with the diagonal negation. The direct simulation-based decider requires time at most $k n^{3} \\log n$, which is superquadratic, so there is no demonstration that $E \\in DTIME(n^{2})$ here; thus E does not meet condition 1 as stated.\n\nConclusion: Only option C defines a language that is in $DTIME(n^{2})$ and not in $\\mathcal{C}_{linear}$ by a standard diagonalization argument with a superlinear time cutoff.", "answer": "$$\\boxed{C}$$", "id": "1456284"}]}