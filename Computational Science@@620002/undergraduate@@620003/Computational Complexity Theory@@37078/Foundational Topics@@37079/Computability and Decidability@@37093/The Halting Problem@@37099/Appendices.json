{"hands_on_practices": [{"introduction": "The Halting Problem is famously undecidable, but what happens when we impose a simple constraint? This first exercise explores the crucial boundary between decidable and undecidable problems by introducing a finite step-limit, $k$. This practice helps you understand that the source of undecidability is the *unbounded* nature of Turing machine computations and builds intuition by tackling a decidable variant first [@problem_id:1457071].", "problem": "In the study of computability theory, a central concept is the Turing Machine (TM), a mathematical model of computation. A standard one-tape deterministic Turing Machine is formally defined by its set of states, its input and tape alphabets, a transition function, a start state, an accept state, and a reject state. A TM \"halts\" on a given input string if its computation eventually enters either the accept state or the reject state.\n\nThe famous halting problem asks whether a given TM $M$ will halt on a given input string $w$. The language corresponding to this problem, often denoted $A_{TM} = \\{\\langle M, w \\rangle \\mid M \\text{ is a TM and } M \\text{ accepts } w \\}$, is known to be undecidable.\n\nConsider a modified version of this problem. Let's define a new language, $HALT_{\\text{bounded}}$, as the set of all triples $\\langle M, w, k \\rangle$ such that $M$ is a TM, $w$ is an input string, and $M$ halts on input $w$ in at most $k$ steps of computation. Here, $k$ is a non-negative integer represented in unary (e.g., the number 3 is represented as the string '111').\n\nWhich of the following statements correctly classifies the language $HALT_{\\text{bounded}}$?\n\nA. $HALT_{\\text{bounded}}$ is decidable.\n\nB. $HALT_{\\text{bounded}}$ is undecidable, but it is Turing-recognizable.\n\nC. $HALT_{\\text{bounded}}$ is not Turing-recognizable.\n\nD. The decidability of $HALT_{\\text{bounded}}$ is an open problem in theoretical computer science.\n\nE. $HALT_{\\text{bounded}}$ is decidable if and only if the Turing Machine $M$ has only a single state besides the halt states.", "solution": "We are given the language $HALT_{\\text{bounded}} = \\{\\langle M, w, k \\rangle \\mid \\text{$M$ halts on input $w$ in at most $k$ steps}\\}$ where $k$ is encoded in unary. We need to classify its decidability status.\n\nKey principle: A Turing machine can be simulated step-by-step by a universal Turing machine. For any Turing machine $M$, input $w$, and integer $k \\geq 0$, one can explicitly simulate the first $k$ steps of $M$ on $w$. This simulation is effective because the transition function of $M$ is finite and computable, so each simulated step is a mechanical application of the transition rule to the current configuration.\n\nAlgorithm (decider) construction:\n- On input $\\langle M, w, k \\rangle$, parse $k$ from its unary representation to obtain the integer value, which we denote by $|k|$ (the number of $1$ symbols).\n- Initialize a simulated configuration $C_{0}$ as the start configuration of $M$ on input $w$.\n- For $t$ from $1$ to $|k|$ do:\n  - If the current configuration $C_{t-1}$ is in an accept or reject state of $M$, then halt and accept (since $M$ halts within at most $t-1 \\leq |k|$ steps).\n  - Otherwise, compute the next configuration $C_{t}$ by applying the transition function of $M$ to $C_{t-1}$.\n- After completing the loop (i.e., after simulating exactly $|k|$ steps without entering a halting state), if no accept or reject state has been reached, halt and reject.\n\nTermination: The above machine always halts because it executes a loop of exactly $|k|$ iterations and performs a finite, effective computation in each iteration. Therefore, it is a decider.\n\nCorrectness:\n- Soundness: If the algorithm accepts, then at some iteration $t \\leq |k|$ it observed that $M$ had entered an accept or reject state on $w$, which means $M$ halts on $w$ within at most $k$ steps. Thus, $\\langle M, w, k \\rangle \\in HALT_{\\text{bounded}}$.\n- Completeness: If $\\langle M, w, k \\rangle \\in HALT_{\\text{bounded}}$, then there exists $t \\leq k$ such that $M$ halts on $w$ in exactly $t$ steps. The simulation will detect this at or before the $t$-th iteration and accept.\n\nTherefore, $HALT_{\\text{bounded}}$ is decidable. The unary encoding of $k$ ensures that this decider runs in time at most polynomial in the input length, but even if $k$ were encoded in binary, the above decider would still terminate (albeit possibly requiring time exponential in the length of $k$), so decidability holds regardless of the encoding. Consequently, the correct classification is that the language is decidable, making options stating undecidability or non-recognizability false, and it is not an open problem. The additional condition in option E is unnecessary for decidability.\n\nHence the correct choice is A.", "answer": "$$\\boxed{A}$$", "id": "1457071"}, {"introduction": "Having established that a bounded version of the Halting Problem is solvable, we now confront the classic proof of why the general case is not. The proof rests on a beautiful and powerful argument called diagonalization, which this thought experiment guides you through by having you construct a paradoxical machine that cannot exist. By tracing the behavior of this \"diagonal machine,\" you will gain a deep, intuitive grasp of the self-referential contradiction at the heart of computability theory [@problem_id:1457066].", "problem": "In the study of computability theory, we often analyze the behavior of hypothetical computing machines, known as Turing Machines. For this problem, consider a set of Turing Machines, denoted $M_1, M_2, M_3, \\dots$. Each machine can be uniquely described by a finite string of symbols, denoted $\\langle M_i \\rangle$. We can feed the description of one machine, say $\\langle M_j \\rangle$, as the input to another machine, $M_i$. The result of this computation, denoted $M_i(\\langle M_j \\rangle)$, is that the machine $M_i$ either eventually halts (`HALT`) or runs forever (`LOOP`).\n\nThe behavior of the first three such machines on the first three inputs is summarized in the table below:\n\n| | Input $\\langle M_1 \\rangle$ | Input $\\langle M_2 \\rangle$ | Input $\\langle M_3 \\rangle$ |\n| :--- | :--- | :--- | :--- |\n| **Machine $M_1$** | `LOOP` | `HALT` | `HALT` |\n| **Machine $M_2$** | `HALT` | `LOOP` | `HALT` |\n| **Machine $M_3$** | `LOOP` | `LOOP` | `LOOP` |\n\nFor example, the entry in the second row and third column indicates that machine $M_2$ when given the input string $\\langle M_3 \\rangle$ will eventually halt: $M_2(\\langle M_3 \\rangle) \\to \\text{`HALT`}$. The entry in the first row and first column indicates that $M_1(\\langle M_1 \\rangle) \\to \\text{`LOOP`}$.\n\nNow, let's define a new Turing Machine, called the \"Diagonal Machine\" $D$. The behavior of $D$ is defined for *any* machine description $\\langle M_i \\rangle$ as input:\n1.  Upon receiving an input $\\langle M_i \\rangle$, machine $D$ first determines the result of running machine $M_i$ on its own description, $M_i(\\langle M_i \\rangle)$. This is equivalent to looking at the diagonal entries of the (infinitely large version of the) table above.\n2.  If the result of $M_i(\\langle M_i \\rangle)$ is `HALT`, then machine $D$ is defined to enter an infinite `LOOP`.\n3.  If the result of $M_i(\\langle M_i \\rangle)$ is `LOOP`, then machine $D$ is defined to `HALT`.\n\nIn essence, $D$ is constructed to behave oppositely to the diagonal entries. Since $D$ is a Turing Machine, it must also have its own string description, $\\langle D \\rangle$.\n\nWhat is the resulting behavior of the machine $D$ when it is run with its own description, $\\langle D \\rangle$, as input?\n\nA. $D$ on input $\\langle D \\rangle$ will HALT.\n\nB. $D$ on input $\\langle D \\rangle$ will LOOP.\n\nC. The behavior is undefined because $D$ is not one of the machines in the original table ($M_1, M_2, M_3$).\n\nD. The machine $D$ as described is self-contradictory and thus cannot be constructed.", "solution": "We are given a countable list of Turing machines $\\{M_{1},M_{2},\\dots\\}$ with encodings $\\langle M_{i}\\rangle$, and a definition of a machine $D$ that, on input $\\langle M_{i}\\rangle$, first determines the outcome of $M_{i}(\\langle M_{i}\\rangle)$ and then does the opposite: if $M_{i}(\\langle M_{i}\\rangle)$ halts then $D$ loops, and if $M_{i}(\\langle M_{i}\\rangle)$ loops then $D$ halts.\n\nFormally, for each $i$,\n$$\nD(\\langle M_{i}\\rangle)=\\text{HALT} \\iff M_{i}(\\langle M_{i}\\rangle)=\\text{LOOP},\n$$\nand equivalently,\n$$\nD(\\langle M_{i}\\rangle)=\\text{LOOP} \\iff M_{i}(\\langle M_{i}\\rangle)=\\text{HALT}.\n$$\n\nSince $D$ is a Turing machine, it has an encoding $\\langle D\\rangle$. Substituting $M_{i}=D$ yields the self-application condition\n$$\nD(\\langle D\\rangle)=\\text{HALT} \\iff D(\\langle D\\rangle)=\\text{LOOP}.\n$$\nThis equivalence cannot be satisfied by any outcome in the two-valued setting: assuming $D(\\langle D\\rangle)=\\text{HALT}$ forces $D(\\langle D\\rangle)=\\text{LOOP}$, and assuming $D(\\langle D\\rangle)=\\text{LOOP}$ forces $D(\\langle D\\rangle)=\\text{HALT}$. Hence no consistent behavior can be assigned to $D$ on input $\\langle D\\rangle$.\n\nTherefore, the specification of $D$ presupposes the ability to decide $M_{i}(\\langle M_{i}\\rangle)$ for arbitrary $i$, which leads to a contradiction when applied to $i$ such that $M_{i}=D$. In standard computability theory, this shows that such a $D$ cannot be constructed as a Turing machine. The correct choice is that the described $D$ is self-contradictory and cannot be constructed.", "answer": "$$\\boxed{D}$$", "id": "1457066"}, {"introduction": "The undecidability of the Halting Problem is more than a theoretical curiosity; it's a fundamental tool for proving other problems are also unsolvable. This exercise challenges you to apply this knowledge through a technique called reduction, where you will design a new Turing Machine that links the fate of a known impossible problem to a new one. This hands-on construction demonstrates how to formally establish the undecidability of the language $HALT_{\\epsilon}$ by reducing the known undecidable problem $A_{TM}$ to it, a cornerstone skill in computational theory [@problem_id:1457092].", "problem": "In theoretical computer science, a key result is the undecidability of the Acceptance Problem for Turing Machines. Let a Turing Machine (TM) be a formal model of computation, analogous to a computer program. The language corresponding to the Acceptance Problem is denoted as $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ is a TM that accepts the input string } w \\}$. It is a foundational theorem that no algorithm exists that can decide for all pairs $\\langle M, w \\rangle$ whether $M$ accepts $w$. In other words, $A_{TM}$ is an undecidable language.\n\nNow, consider a related but seemingly simpler problem. Let's define the language $HALT_{\\epsilon} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM that halts on the empty input string } \\epsilon \\}$. A computer scientist conjectures that $HALT_{\\epsilon}$ is also undecidable. To investigate this, she attempts to show that if a hypothetical algorithm existed that could decide $HALT_{\\epsilon}$, it could be used as a subroutine to build an algorithm that decides the impossible problem $A_{TM}$, leading to a contradiction.\n\nThe strategy is as follows: to decide if a given TM $M$ accepts a string $w$ (i.e., to solve an instance $\\langle M, w \\rangle$ of $A_{TM}$), we first construct a new TM, let's call it $M_{construct}$. The behavior of $M_{construct}$ is specifically engineered based on $M$ and $w$. Then, we feed the description of $M_{construct}$ to our hypothetical decider for $HALT_{\\epsilon}$. The output of this decider (whether $M_{construct}$ halts on $\\epsilon$ or not) should tell us definitively whether $M$ accepts $w$.\n\nWhich of the following correctly describes the necessary behavior of the machine $M_{construct}$ when it is run on the empty string $\\epsilon$, such that this strategy successfully proves that $HALT_{\\epsilon}$ is undecidable?\n\nA. On input $\\epsilon$, $M_{construct}$ simulates $M$ on input $w$. If the simulation shows that $M$ accepts $w$, $M_{construct}$ halts. If the simulation shows that $M$ rejects $w$, $M_{construct}$ enters an infinite loop.\n\nB. On input $\\epsilon$, $M_{construct}$ simulates $M$ on input $w$. If the simulation shows that $M$ halts on $w$ (for any reason, accepting or rejecting), $M_{construct}$ halts. Otherwise, it enters an infinite loop.\n\nC. On input $\\epsilon$, $M_{construct}$ simulates $M$ on the empty string $\\epsilon$. If the simulation shows that $M$ accepts $\\epsilon$, $M_{construct}$ halts. If the simulation shows that $M$ rejects $\\epsilon$, $M_{construct}$ enters an infinite loop.\n\nD. On input $\\epsilon$, $M_{construct}$ simulates $M$ on input $w$. If the simulation shows that $M$ accepts $w$, $M_{construct}$ enters an infinite loop. If the simulation shows that $M$ rejects $w$, $M_{construct}$ halts.\n\nE. On input $\\epsilon$, $M_{construct}$ simulates $M$ on input $w$. It is designed to enter an accept state if and only if $M$ accepts $w$.", "solution": "We aim to show that a hypothetical decider for $HALT_{\\epsilon}=\\{\\langle M\\rangle\\mid M\\text{ halts on }\\epsilon\\}$ could be used to decide $A_{TM}=\\{\\langle M,w\\rangle\\mid M\\text{ accepts }w\\}$. This requires a computable transformation $f$ that maps any pair $\\langle M,w\\rangle$ to a machine $\\langle M_{construct}\\rangle$ such that the following equivalence holds:\n$$\n\\langle M,w\\rangle\\in A_{TM}\\iff \\langle M_{construct}\\rangle\\in HALT_{\\epsilon}.\n$$\nIf such $f$ exists, then given a decider for $HALT_{\\epsilon}$ we could decide $A_{TM}$ by applying $f$ and running the decider on $\\langle M_{construct}\\rangle$. Since $A_{TM}$ is undecidable, this would imply $HALT_{\\epsilon}$ is undecidable.\n\nTherefore, $M_{construct}$ must be defined so that it halts on input $\\epsilon$ if and only if $M$ accepts $w$. A correct construction is:\n- On input $\\epsilon$, simulate $M$ on input $w$.\n- If the simulation shows that $M$ accepts $w$, then halt (e.g., accept).\n- If the simulation shows that $M$ rejects $w$, then loop forever.\n- If $M$ does not halt on $w$, the simulation never finishes, so $M_{construct}$ also does not halt.\n\nThis ensures the exact equivalence\n$$\n\\langle M,w\\rangle\\in A_{TM}\\iff M\\text{ accepts }w\\iff M_{construct}\\text{ halts on }\\epsilon\\iff \\langle M_{construct}\\rangle\\in HALT_{\\epsilon}.\n$$\nThus a decider for $HALT_{\\epsilon}$ would decide $A_{TM}$ via the mapping $\\langle M,w\\rangle\\mapsto \\langle M_{construct}\\rangle$, which is a contradiction. Hence $HALT_{\\epsilon}$ is undecidable.\n\nAmong the options:\n- A matches the required construction precisely.\n- B makes halting on $\\epsilon$ correspond to $M$ halting on $w$ for any reason, which reduces to the general halting problem rather than acceptance; it does not decide $A_{TM}$ as required by the strategy.\n- C simulates $M$ on $\\epsilon$ instead of $w$, breaking the needed correspondence to the given instance $\\langle M,w\\rangle$.\n- D makes halting on $\\epsilon$ correspond to $M$ rejecting $w$, which does not decide $A_{TM}$ as stated.\n- E is ambiguous: entering an accept state implies halting, but it does not preclude also halting by rejection when $M$ rejects $w$, so it does not guarantee the required iff condition for halting versus acceptance.\n\nTherefore, the correct description is A.", "answer": "$$\\boxed{A}$$", "id": "1457092"}]}