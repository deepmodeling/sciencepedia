{"hands_on_practices": [{"introduction": "Before designing our own abstract machines, it is crucial to understand how they operate at a fundamental level. This first practice exercise grounds the concept of a Turing Machine in a concrete, step-by-step process. By meticulously tracing the machine's execution on a given input string, you will gain a tangible feel for how an algorithm is realized through tape manipulation, state transitions, and symbol-writing.", "problem": "Consider a single-tape Turing Machine (TM) that is designed to be a decider for the language $L = \\{w \\in \\{0, 1\\}^* \\mid n_0(w) = 2 \\cdot n_1(w)\\}$, where $n_0(w)$ is the count of '0's in the string $w$ and $n_1(w)$ is the count of '1's.\n\nThe TM has an input alphabet $\\Sigma = \\{0, 1\\}$ and a tape alphabet $\\Gamma = \\{0, 1, X, Y, \\sqcup\\}$, where $\\sqcup$ is the blank symbol. The machine begins its computation with the input string $w$ on an otherwise blank tape, with its head positioned on the leftmost symbol of $w$.\n\nThe TM follows this deterministic algorithm:\n1.  Scan the tape from left to right to find the first unmarked '1'.\n2.  If an unmarked '1' is found, replace it with an 'X' and return the tape head to the leftmost position of the initial input string. Then, proceed to step 3. If no unmarked '1's are found, proceed to step 4.\n3.  From the beginning of the tape, scan to the right to find the first two unmarked '0's. Replace each of these '0's with a 'Y'. If two unmarked '0's cannot be found during this process, the machine immediately halts and enters a reject state. After successfully marking two '0's, return the tape head to the beginning and go back to step 1.\n4.  If the scan in step 1 reveals no more unmarked '1's, the machine performs a final check. It scans the entire non-blank portion of the tape. If any unmarked '0's are found, the machine halts and enters a reject state. If no unmarked '0's are found, the machine halts and enters an accept state.\n\nGiven the input string $w = 001010$, what is the final content of the tape's non-blank portion when the machine halts?\n\nA. `YYXYXY`\n\nB. `YYYYXX`\n\nC. `001010`\n\nD. `XYYXYY`\n\nE. The machine halts and rejects before marking all symbols, leaving the tape as `YYX0Y0`.\n\nF. The machine enters an infinite loop.", "solution": "The problem asks for the final state of a Turing Machine's tape for the input string $w = 001010$. The TM is designed to decide the language $L = \\{w \\in \\{0, 1\\}^* \\mid n_0(w) = 2 \\cdot n_1(w)\\}$. For the input $w = 001010$, we have $n_0(w) = 4$ and $n_1(w) = 2$. Since $4 = 2 \\cdot 2$, the string is in the language $L$, and the TM should halt and accept. Let's trace the execution of the TM step by step.\n\nThe initial tape is `001010`, with the head at the start.\n\n**Iteration 1:**\n1.  **Step 1 & 2**: The TM scans from the left and finds the first '1' at index 2 (0-indexed). It replaces this '1' with an 'X'. The tape head returns to the start.\n    - Tape content: `00X010`\n2.  **Step 3**: The TM scans from the left to find two '0's.\n    - It finds the first '0' at index 0 and replaces it with 'Y'. Tape: `Y0X010`.\n    - It continues scanning and finds the next '0' at index 1 and replaces it with 'Y'. Tape: `YYX010`.\n    - Having found and marked two '0's, the TM returns its head to the start and goes back to step 1.\n    - Tape at the end of Iteration 1: `YYX010`\n\n**Iteration 2:**\n1.  **Step 1 & 2**: The TM, starting from the left, scans for the next unmarked '1'. It finds it at index 4. It replaces this '1' with an 'X', and the head returns to the start.\n    - Tape content: `YYX0X0`\n2.  **Step 3**: The TM scans from the left to find two unmarked '0's.\n    - It finds the first unmarked '0' at index 3 and replaces it with 'Y'. Tape: `YYXYX0`.\n    - It continues scanning and finds the next unmarked '0' at index 5 and replaces it with 'Y'. Tape: `YYXYXY`.\n    - Having found and marked two '0's, the TM returns its head to the start and goes back to step 1.\n    - Tape at the end of Iteration 2: `YYXYXY`\n\n**Iteration 3:**\n1.  **Step 1**: The TM scans the tape from the left for an unmarked '1'. The current tape is `YYXYXY`. There are no unmarked '1's.\n2.  **Step 2**: Since no '1's were found, the TM proceeds to step 4.\n\n**Final Check (Step 4):**\n1.  The machine scans the non-blank tape `YYXYXY` for any unmarked '0's.\n2.  No unmarked '0's are found.\n3.  The machine halts and enters the accept state.\n\nThe final content on the tape's non-blank portion when the machine halts is `YYXYXY`. This corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1442187"}, {"introduction": "Now that you have seen a Turing Machine in action, we shift our focus from simulation to design strategy. A critical distinction in computability theory is between recognizing a language and deciding it, which hinges on how the machine behaves for inputs not in the language. This exercise challenges you to evaluate different high-level strategies for a Turing Machine, homing in on the specific requirements for a machine to be a correct recognizer [@problem_id:1442190].", "problem": "In the theory of computation, a formal language is a set of strings over a finite alphabet. A language is said to be *recognizable* if there exists a Turing Machine (TM) that can identify strings belonging to that language. Specifically, a TM recognizes a language $L$ if, for any given input string $w$:\n1. If $w$ is in $L$, the TM halts and enters an `accept` state.\n2. If $w$ is not in $L$, the TM either halts and enters a `reject` state, or it runs forever (never halts).\n\nConsider the language $L$ over the alphabet $\\Sigma = \\{a\\}$, defined as the set of all strings of 'a's whose length is a perfect square. Formally, this is $L = \\{ a^k \\mid k = n^2 \\text{ for some integer } n \\ge 0 \\}$. This includes the empty string, for which $k=0$ since $0^2=0$.\n\nBelow are four distinct strategies for a Turing Machine designed to operate on an input string $w=a^k$. Which of the following strategies correctly describes a TM that recognizes the language $L$?\n\nA. The TM operates in stages. In stage $n$ (for $n=0, 1, 2, 3, \\dots$), the TM computes the value $s = n^2$. It then compares the length of the input string, $k$, with $s$. If $k=s$, the TM halts and accepts. If $k \\ne s$, it proceeds to the next stage, $n+1$.\n\nB. The TM operates in stages. In stage $n$ (for $n=0, 1, 2, 3, \\dots$), the TM computes the value $s = n^2$. It then compares the length of the input string, $k$, with $s$. If $s > k$, the TM determines that $k$ cannot be a perfect square and halts and rejects. If $s = k$, the TM enters a specially designed infinite loop. If $s < k$, it proceeds to the next stage, $n+1$.\n\nC. The TM has a large, fixed integer $M$ hardcoded into its state machine (e.g., $M=1,000,000$). The TM generates and tests every perfect square $s=n^2$ for all $n$ from $0$ to $M$. If the input string's length $k$ matches any of these squares, the TM halts and accepts. If no match is found after checking all squares up to $M^2$, the TM halts and rejects.\n\nD. The TM non-deterministically guesses an integer $m$ such that $1 \\le m^2 < k$, where $k$ is the length of the input string. It then checks if the remainder, $k - m^2$, is also a perfect square (including 0). If it finds such an $m$ for which this condition is true, it halts and accepts. If no such $m$ can be found across all possible non-deterministic paths, the machine rejects.", "solution": "We use the definition: a Turing Machine (TM) recognizes a language $L$ if, for any input $w$, it halts and accepts when $w \\in L$, and when $w \\notin L$ it either halts and rejects or runs forever. The language here is unary squares $L = \\{ a^{k} \\mid \\exists n \\ge 0 \\text{ with } k = n^{2} \\}$.\n\nAnalyze each strategy:\n\n- Option A: In stage $n = 0,1,2,\\dots$, compute $s = n^{2}$ and compare to $k$. If $k = s$, halt and accept; else continue. If $k \\in L$, there exists $n$ with $k = n^{2}$, so the machine halts and accepts at that stage (including $n=0$ for $k=0$). If $k \\notin L$, then $k \\ne n^{2}$ for all $n$, so the machine never halts (runs forever). This satisfies the recognizer condition: accept exactly members; for non-members, non-halting is allowed. Therefore, A is a correct recognizer.\n\n- Option B: In stage $n$, compute $s = n^{2}$. If $s > k$, halt and reject; if $s = k$, enter an infinite loop; otherwise continue. For $k \\in L$, there exists $n$ such that $s = k$, but then the machine loops and does not accept, violating the requirement that members be accepted. Hence B is not a recognizer for $L$.\n\n- Option C: Test $n^{2}$ only up to a fixed bound $M^{2}$. If $k$ matches some tested square, accept; otherwise reject. For any $k = n^{2} > M^{2}$, the machine halts and rejects even though $k \\in L$, violating recognition. Hence C is not a recognizer for $L$.\n\n- Option D: Nondeterministically guess $m$ with $1 \\le m^{2} < k$ and accept if $k - m^{2}$ is a perfect square (including $0$). A correct recognizer must accept all $k = n^{2}$. However, for many squares (e.g., $k=4$ or $k=9$), there is no $m$ with $1 \\le m^{2} < k$ such that $k - m^{2}$ is a perfect square; the only decomposition is $k = n^{2} + 0^{2}$ with $m = n$ disallowed by $m^{2} < k$. Thus the machine fails to accept all members of $L$. Hence D is not a recognizer for $L$.\n\nConclusion: Only A correctly recognizes $L$.", "answer": "$$\\boxed{A}$$", "id": "1442190"}, {"introduction": "The distinction between recognizable and decidable languages is not merely a theoretical subtlety; it lies at the heart of what computers can and cannot do. This final practice uses the intuitive scenario of software verification to explore a profound concept: some problems are fundamentally unsolvable (undecidable), yet we can still build programs that confirm 'yes' instances (recognizable). This problem [@problem_id:1442181] illustrates why the Acceptance Problem is a canonical example of a language that is recognizable but not decidable, revealing the inherent limits of computation.", "problem": "In the theory of computation, we analyze the power of abstract machines by studying the languages they can process. A *language* is a set of strings over some alphabet. A language is called *decidable* if there exists an algorithm (a Turing Machine) that halts on every input string and correctly determines whether the string belongs to the language. A language is called *recognizable* if there exists an algorithm that halts and accepts if the input string is in the language, but may halt and reject or loop forever if the string is not in the language. Every decidable language is also recognizable, but the converse is not always true.\n\nConsider a hypothetical project to build a \"Universal Program Verifier\". We model programs and their inputs as strings. Let an encoded program be denoted by $P$ and its input by $I$. We represent a program-input pair as a single string $\\langle P, I \\rangle$.\n\nLet's define two specific languages related to this verifier:\n\n1.  $L_{SYNTAX}$: The language of all strings $\\langle P, I \\rangle$ where the string $P$ represents a syntactically valid program according to a specific programming language's grammar, and $I$ is a valid input for that program. We can assume that a compiler can always parse a string $\\langle P, I \\rangle$ and definitively determine in a finite amount of time whether it is syntactically well-formed.\n\n2.  $L_{ACCEPT}$: The language of all strings $\\langle P, I \\rangle$ such that $P$ is a syntactically valid program, $I$ is a valid input, and the program $P$, when executed with input $I$, eventually halts and enters an \"accept\" state.\n\nBased on these definitions and the fundamental principles of computability theory, which of the following statements accurately describes the relationship and properties of $L_{SYNTAX}$ and $L_{ACCEPT}$?\n\nA. $L_{ACCEPT}$ is decidable because it is a subset of $L_{SYNTAX}$, which is a decidable language.\n\nB. $L_{ACCEPT}$ is not a decidable language, and it is not a subset of $L_{SYNTAX}$.\n\nC. $L_{ACCEPT}$ is a proper subset of $L_{SYNTAX}$, and while $L_{SYNTAX}$ is decidable, $L_{ACCEPT}$ is recognizable but not decidable.\n\nD. Both $L_{SYNTAX}$ and $L_{ACCEPT}$ are recognizable, but neither is decidable.\n\nE. $L_{ACCEPT}$ is not a recognizable language.", "solution": "We first restate the relevant definitions in computability-theoretic terms. A language is decidable if there exists a Turing machine that halts on every input and correctly decides membership. A language is recognizable if there exists a Turing machine that halts and accepts on members, and either rejects or loops on nonmembers.\n\nConsider $L_{SYNTAX} = \\{\\langle P, I \\rangle : P \\text{ is a syntactically valid program and } I \\text{ is a valid input for } P\\}$. By assumption, there exists a compiler or parser that can determine in finite time whether a given $\\langle P, I \\rangle$ is syntactically well-formed. Therefore there exists a decider for $L_{SYNTAX}$ that halts on all inputs and accepts exactly those strings in $L_{SYNTAX}$. Hence $L_{SYNTAX}$ is decidable. Since every decidable language is recognizable, $L_{SYNTAX}$ is also recognizable.\n\nNow consider $L_{ACCEPT} = \\{\\langle P, I \\rangle : P \\text{ is syntactically valid, } I \\text{ is valid, and } P \\text{ halts and accepts on } I\\}$. By its definition, if $\\langle P, I \\rangle \\in L_{ACCEPT}$, then $P$ is syntactically valid and $I$ is a valid input. Thus we have the set-theoretic implication\n$$\n\\langle P, I \\rangle \\in L_{ACCEPT} \\implies \\langle P, I \\rangle \\in L_{SYNTAX},\n$$\nwhich yields the subset relation\n$$\nL_{ACCEPT} \\subseteq L_{SYNTAX}.\n$$\nMoreover, the inclusion is proper because there exist syntactically valid programs and inputs for which the program does not accept (it may reject or loop), so these pairs lie in $L_{SYNTAX}$ but not in $L_{ACCEPT}$. Therefore\n$$\nL_{ACCEPT} \\subset L_{SYNTAX}.\n$$\n\nNext, we analyze recognizability and decidability of $L_{ACCEPT}$. To show recognizability, define a Turing machine $U$ that on input $\\langle P, I \\rangle$ simulates $P$ on $I$: if the simulation ever reaches an accept state, $U$ accepts. If $P$ rejects or loops, $U$ may reject or loop, respectively. This is precisely a recognizer for $L_{ACCEPT}$, so $L_{ACCEPT}$ is recognizable.\n\nTo show that $L_{ACCEPT}$ is not decidable, we reduce the halting problem to it. Let $HALT = \\{\\langle P, I \\rangle : P \\text{ halts on } I\\}$. Suppose, for contradiction, that there exists a decider $D$ for $L_{ACCEPT}$. Given an arbitrary instance $\\langle P, I \\rangle$ of $HALT$, construct a new program $P^{\\dagger}$ that on any input $x$ simulates $P$ on $I$ and, if the simulation halts (whether $P$ would accept or reject), $P^{\\dagger}$ enters an accept state. Formally, $P^{\\dagger}$ ignores $x$ and implements: simulate $P$ on $I$; upon $P$ halting, accept. This construction is effective and yields a syntactically valid program with a valid input. Then\n$$\n\\langle P, I \\rangle \\in HALT \\iff \\langle P^{\\dagger}, x \\rangle \\in L_{ACCEPT}\n$$\nfor any fixed valid input $x$ to $P^{\\dagger}$. If $D$ decided $L_{ACCEPT}$, we could decide $HALT$ by mapping $\\langle P, I \\rangle$ to $\\langle P^{\\dagger}, x \\rangle$ and running $D$, contradicting the known undecidability of $HALT$. Therefore $L_{ACCEPT}$ is not decidable.\n\nCombining these facts:\n- $L_{SYNTAX}$ is decidable (hence recognizable).\n- $L_{ACCEPT}$ is a proper subset of $L_{SYNTAX}$, is recognizable, but is not decidable.\n\nAmong the given options, this is exactly described by option C.", "answer": "$$\\boxed{C}$$", "id": "1442181"}]}