{"hands_on_practices": [{"introduction": "This first practice introduces one of the most fundamental strategies in computability theory. To prove that the language $ONE_{TM}$, which contains machines accepting exactly one string, is undecidable, we will construct a new machine $M'$. The behavior of $M'$ will be carefully engineered to accept a single, predetermined string if and only if a given Turing machine $M$ accepts an input $w$, a logic that forms the blueprint for countless reduction proofs [@problem_id:1431361]. This \"all or nothing\" approach perfectly isolates the undecidable question within a simple, testable property.", "problem": "In computability theory, a central method for proving that a language is undecidable is to show a mapping reduction from a known undecidable language. Let $A_{TM}$ be the acceptance problem for Turing Machines (TMs), defined as $A_{TM} = \\{\\langle M, w \\rangle \\mid M \\text{ is a TM and } M \\text{ accepts string } w\\}$. The language $A_{TM}$ is known to be undecidable.\n\nConsider the language $ONE_{TM}$, defined as the set of all TMs that accept a language containing exactly one string:\n$$ONE_{TM} = \\{\\langle M \\rangle \\mid M \\text{ is a TM and } |L(M)| = 1\\}$$\nwhere $L(M)$ is the language of machine $M$ and $|L(M)|$ denotes the number of strings in that language.\n\nTo prove that $ONE_{TM}$ is undecidable, one can construct a computable function $f$ that takes an input $\\langle M, w \\rangle$ and outputs the description of a new TM, $M'$. This function must satisfy the condition for a mapping reduction: $\\langle M, w \\rangle \\in A_{TM}$ if and only if $\\langle M' \\rangle \\in ONE_{TM}$.\n\nLet $s_0$ be a fixed, non-empty string (e.g., $s_0 = \\text{\"computation\"}$). The function $f$ constructs $M'$ based on $M$ and $w$. Which of the following descriptions for the behavior of $M'$ on an arbitrary input string $x$ correctly implements this reduction?\n\nA. On input $x$, $M'$ simulates $M$ on $w$. If this simulation accepts, $M'$ accepts $x$. Otherwise, $M'$ rejects $x$.\n\nB. On input $x$, $M'$ simulates $M$ on $x$. If this simulation accepts, $M'$ also accepts $x$. The machine $M'$ is also hard-coded to accept the string $s_0$ regardless of the behavior of $M$.\n\nC. On input $x$, $M'$ first checks if $x = s_0$. If $x \\neq s_0$, $M'$ immediately rejects. If $x = s_0$, $M'$ then proceeds to simulate $M$ on $w$. If this simulation accepts, $M'$ accepts its input $s_0$. Otherwise, $M'$ rejects.\n\nD. On input $x$, $M'$'s behavior is independent of $M$. It checks if $x = w$. If it is, $M'$ accepts. If $x \\neq w$, $M'$ rejects.", "solution": "We are to construct a computable function $f$ mapping inputs $\\langle M,w \\rangle$ to a TM $M'$ such that\n$$\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in ONE_{TM}.$$\nBy definition, $\\langle M' \\rangle \\in ONE_{TM}$ means $|L(M')|=1$. We fix a specific non-empty string $s_{0}$.\n\nDefine $f$ as follows: on input $\\langle M,w \\rangle$, output the encoding of the TM $M'$ that on input $x$ performs:\n1. If $x \\neq s_{0}$, reject.\n2. If $x = s_{0}$, simulate $M$ on $w$; if the simulation accepts, accept $s_{0}$; if the simulation halts and rejects, reject $s_{0}$; if the simulation does not halt, then $M'$ does not halt on $s_{0}$.\n\nThis $f$ is computable because the description of $M'$ is effectively constructed from the code of $M$, the string $w$, and the fixed string $s_{0}$ by hard-coding a comparison to $s_{0}$ and a simulation of $M$ on $w$.\n\nCorrectness:\n- If $\\langle M,w \\rangle \\in A_{TM}$, then $M$ accepts $w$. Therefore, on input $x=s_{0}$, $M'$ accepts, and on all $x \\neq s_{0}$, $M'$ rejects. Hence $L(M')=\\{s_{0}\\}$ and $|L(M')|=1$, so $\\langle M' \\rangle \\in ONE_{TM}$.\n- If $\\langle M,w \\rangle \\notin A_{TM}$, then $M$ does not accept $w$ (either rejects or does not halt). Thus, for $x=s_{0}$, $M'$ does not accept; for $x \\neq s_{0}$, $M'$ rejects. Therefore $L(M')=\\varnothing$ and $|L(M')|=0$, so $\\langle M' \\rangle \\notin ONE_{TM}$.\n\nHence $\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in ONE_{TM}$, which matches description C.\n\nWhy the other options fail:\n- Option A makes $L(M')=\\Sigma^{*}$ if $M$ accepts $w$, and $L(M')=\\varnothing$ otherwise; $|L(M')|$ is never $1$.\n- Option B ensures $s_{0} \\in L(M')$ regardless of $M$ and may include additional strings depending on $M$, so $|L(M')|$ is rarely $1$ and does not encode whether $M$ accepts $w$.\n- Option D ignores $M$ entirely and always yields a singleton language $\\{w\\}$, breaking the required equivalence with $A_{TM}$.\n\nTherefore, the correct implementation is option C.", "answer": "$$\\boxed{C}$$", "id": "1431361"}, {"introduction": "Building on the foundational pattern, this exercise explores a slightly more complex target property and reveals the flexibility inherent in designing reductions. Here, we must ensure our constructed machine $M'$ accepts at least one string from the infinite language $\\{0^n1^n \\mid n \\ge 0\\}$ if and only if $M$ accepts $w$ [@problem_id:1431363]. As you will discover by evaluating the different proposed strategies, there is often more than one correct way to build a reduction, underscoring that proof construction is a creative, problem-solving activity.", "problem": "In computability theory, one of the fundamental techniques to prove that a problem is undecidable is through a mapping reduction. To prove a language $L_{new}$ is undecidable, we can take a known undecidable language $L_{known}$ and show that $L_{known}$ is mapping reducible to $L_{new}$ (denoted $L_{known} \\le_m L_{new}$). This involves constructing a computable function $f$ that transforms an instance $x$ of $L_{known}$ into an instance $f(x)$ of $L_{new}$, such that $x \\in L_{known}$ if and only if $f(x) \\in L_{new}$.\n\nLet's consider the acceptance problem for Turing Machines (TMs), which is known to be undecidable. It is defined as the language:\n$$A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ is a TM and } M \\text{ accepts input string } w \\}$$\nNow, consider a different language related to TMs, which we will call $L_{01}$:\n$$L_{01} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM and its language } L(M) \\text{ contains at least one string of the form } 0^n1^n \\text{ for some integer } n \\ge 0 \\}$$\nIn other words, $\\langle M \\rangle \\in L_{01}$ if and only if $L(M) \\cap \\{0^n1^n \\mid n \\ge 0\\} \\neq \\emptyset$.\n\nYour task is to select all valid strategies for proving that $L_{01}$ is undecidable via a mapping reduction from $A_{TM}$. The reduction involves defining a computable function that takes an arbitrary instance $\\langle M, w \\rangle$ of $A_{TM}$ and outputs the description of a new TM, $\\langle M' \\rangle$.\n\nWhich of the following descriptions for the behavior of a new Turing Machine $M'$, constructed from $M$ and $w$, would constitute a valid reduction to prove that $L_{01}$ is undecidable? You may select one or more options.\n\nA. On input $x$, machine $M'$ first checks if $x$ has the form $0^k1^k$ for some integer $k \\ge 0$. If it does not, $M'$ rejects. If it does, $M'$ proceeds to simulate machine $M$ on the (fixed) input $w$. If the simulation of $M$ on $w$ accepts, $M'$ accepts its input $x$. If the simulation of $M$ on $w$ rejects or loops, $M'$ also rejects or loops, respectively.\n\nB. On input $x$, machine $M'$ ignores its input and simulates machine $M$ on the (fixed) input $w$. If the simulation of $M$ on $w$ accepts, $M'$ accepts its input $x$. Otherwise, $M'$ rejects its input $x$.\n\nC. On input $x$, machine $M'$ first checks if $x$ has the form $0^k1^k$ for some integer $k \\ge 0$. If it does, $M'$ rejects. If it does not, $M'$ proceeds to simulate machine $M$ on the (fixed) input $w$. If the simulation of $M$ on $w$ accepts, $M'$ accepts its input $x$.\n\nD. On input $x$, machine $M'$ simulates machine $M$ on the input $x$. If $M$ accepts $x$, and $x$ has the form $0^k1^k$ for some integer $k \\ge 0$, then $M'$ accepts $x$. In all other cases, $M'$ rejects.\n\nE. On input $x$, machine $M'$ first simulates machine $M$ on the (fixed) input $w$. If this simulation accepts, $M'$ then checks if its own input $x$ has the form $0^k1^k$ for some integer $k \\ge 0$, accepting $x$ if it does and rejecting if it does not. If the simulation of $M$ on $w$ rejects or loops, $M'$ rejects or loops on its input $x$ without checking it.", "solution": "To prove that $L_{01}$ is undecidable, we perform a mapping reduction from the known undecidable language $A_{TM}$. We need to construct a computable function $f$ which takes an input $\\langle M, w \\rangle$ and produces the description of a new Turing Machine, $\\langle M' \\rangle$, such that the following condition holds:\n$\\langle M, w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in L_{01}$.\nThis is equivalent to saying: $M$ accepts $w$ if and only if $L(M') \\cap \\{0^n1^n \\mid n \\ge 0\\} \\neq \\emptyset$.\nWe will analyze each option to see if the proposed construction for $M'$ satisfies this condition.\n\nAnalysis of Option A:\nThe machine $M'$ operates on an input $x$.\nCase 1: $M$ accepts $w$.\nAccording to the construction, $M'$ first checks if its input $x$ is of the form $0^k1^k$. If it is, $M'$ simulates $M$ on $w$. Since $M$ accepts $w$, this simulation halts and accepts, causing $M'$ to accept $x$. If $x$ is not of the form $0^k1^k$, $M'$ rejects. Therefore, the language of $M'$, $L(M')$, is exactly the set of all strings of the form $0^k1^k$. So, $L(M') = \\{0^k1^k \\mid k \\ge 0\\}$.\nIn this case, $L(M') \\cap \\{0^n1^n \\mid n \\ge 0\\}$ is the entire set $\\{0^n1^n \\mid n \\ge 0\\}$, which is non-empty. Thus, $\\langle M' \\rangle \\in L_{01}$.\nCase 2: $M$ does not accept $w$ (it either rejects or loops).\n$M'$ first checks if its input $x$ is of the form $0^k1^k$. If it is not, $M'$ rejects. If it is, $M'$ simulates $M$ on $w$. Since $M$ does not accept $w$, this simulation either rejects or loops. Consequently, $M'$ will also reject or loop, and in neither case does it accept $x$.\nThus, $M'$ accepts no strings. Its language is empty: $L(M') = \\emptyset$.\nIn this case, $L(M') \\cap \\{0^n1^n \\mid n \\ge 0\\} = \\emptyset \\cap \\{0^n1^n \\mid n \\ge 0\\} = \\emptyset$. Thus, $\\langle M' \\rangle \\notin L_{01}$.\nSince the condition ($M$ accepts $w \\iff \\langle M' \\rangle \\in L_{01}$) holds, option A describes a valid reduction.\n\nAnalysis of Option B:\nThe machine $M'$ operates on an input $x$.\nCase 1: $M$ accepts $w$.\n$M'$ ignores its input $x$ and simulates $M$ on $w$. The simulation accepts, so $M'$ accepts $x$. This is true for any input $x$. Therefore, the language of $M'$ is the set of all possible strings, $L(M') = \\Sigma^*$.\nIn this case, $L(M') \\cap \\{0^n1^n \\mid n \\ge 0\\} = \\Sigma^* \\cap \\{0^n1^n \\mid n \\ge 0\\} = \\{0^n1^n \\mid n \\ge 0\\}$, which is non-empty. Thus, $\\langle M' \\rangle \\in L_{01}$.\nCase 2: $M$ does not accept $w$.\n$M'$ ignores its input $x$ and simulates $M$ on $w$. The simulation does not accept (it rejects or loops), so $M'$ rejects or loops on its input $x$. In either case, $M'$ does not accept $x$. This is true for any input $x$. Therefore, $M'$ accepts no strings, so $L(M') = \\emptyset$.\nIn this case, $L(M') \\cap \\{0^n1^n \\mid n \\ge 0\\} = \\emptyset$, so $\\langle M' \\rangle \\notin L_{01}$.\nThe condition holds, so option B also describes a valid reduction.\n\nAnalysis of Option C:\nThe machine $M'$ operates on an input $x$.\nCase 1: $M$ accepts $w$.\n$M'$ checks if $x$ has the form $0^k1^k$. If it does, $M'$ rejects. If it does not, $M'$ simulates $M$ on $w$. Since $M$ accepts $w$, $M'$ accepts $x$. So, $L(M')$ is the set of all strings that are *not* of the form $0^k1^k$.\nIn this case, $L(M') \\cap \\{0^n1^n \\mid n \\ge 0\\} = \\emptyset$. So $\\langle M' \\rangle \\notin L_{01}$.\nCase 2: $M$ does not accept $w$.\n$M'$ checks if $x$ has the form $0^k1^k$. If yes, it rejects. If no, it simulates $M$ on $w$. Since $M$ does not accept $w$, $M'$ also does not accept $x$. Therefore, $M'$ accepts no strings, and $L(M') = \\emptyset$.\nIn this case, $L(M') \\cap \\{0^n1^n \\mid n \\ge 0\\} = \\emptyset$. So $\\langle M' \\rangle \\notin L_{01}$.\nThe reduction fails because if $M$ accepts $w$, $\\langle M' \\rangle$ is not in $L_{01}$. The required equivalence does not hold. Option C is incorrect.\n\nAnalysis of Option D:\nThe machine $M'$ operates on an input $x$. The construction of $M'$ depends only on $\\langle M \\rangle$, not on $w$. The function $f(\\langle M, w \\rangle)$ is supposed to produce $\\langle M' \\rangle$. Here, the behavior of $M'$ does not depend on $w$ at all.\nThe language of the constructed machine is $L(M') = L(M) \\cap \\{0^k1^k \\mid k \\ge 0\\}$.\nThe reduction requires: $M$ accepts $w \\iff L(M') \\cap \\{0^n1^n \\mid n \\ge 0\\} \\neq \\emptyset$.\nSubstituting the definition of $L(M')$, this becomes: $M$ accepts $w \\iff (L(M) \\cap \\{0^k1^k\\}) \\cap \\{0^n1^n\\} \\neq \\emptyset$, which is simplified to $M$ accepts $w \\iff L(M) \\cap \\{0^n1^n\\} \\neq \\emptyset$.\nThis statement is not generally true. For example, let $M$ be a TM that accepts all strings, and let $w = \\text{\"abc\"}$. Then $M$ accepts $w$. Also, $L(M) \\cap \\{0^n1^n\\}$ is non-empty. Now let $w = \\text{\"xyz\"}$. $M$ still accepts $w$. The condition still holds. But consider a TM $M_0$ that accepts only the string \"hello\". Let $w=$ \"hello\". $M_0$ accepts $w$. But $L(M_0) \\cap \\{0^n1^n\\} = \\emptyset$. The right side of the equivalence is false while the left side is true. The reduction is invalid. Option D is incorrect.\n\nAnalysis of Option E:\nThe machine $M'$ operates on an input $x$.\nCase 1: $M$ accepts $w$.\n$M'$ first simulates $M$ on $w$. This simulation halts and accepts. Then, $M'$ checks its own input $x$. If $x$ is of the form $0^k1^k$, $M'$ accepts $x$. Otherwise, it rejects $x$. Therefore, $L(M') = \\{0^k1^k \\mid k \\ge 0\\}$.\nIn this case, $L(M') \\cap \\{0^n1^n \\mid n \\ge 0\\}$ is non-empty. Thus, $\\langle M' \\rangle \\in L_{01}$.\nCase 2: $M$ does not accept $w$ (it either rejects or loops).\n$M'$ first simulates $M$ on $w$. This simulation either rejects or loops. In either scenario, $M'$ also rejects or loops without ever checking its input $x$. Thus, $M'$ accepts no strings, so $L(M') = \\emptyset$.\nIn this case, $L(M') \\cap \\{0^n1^n \\mid n \\ge 0\\} = \\emptyset$. Thus, $\\langle M' \\rangle \\notin L_{01}$.\nThe condition holds. The logic is functionally identical to Option A, just with the steps reordered. Therefore, option E also describes a valid reduction.\n\nIn summary, constructions A, B, and E all correctly establish the mapping reduction $A_{TM} \\le_m L_{01}$.", "answer": "$$\\boxed{ABE}$$", "id": "1431363"}, {"introduction": "This final practice demonstrates the true power and versatility of mapping reducibility by applying it to a non-standard model of computation. Your task is to prove that a behavioral property of a two-headed Turing machine (2-HTM) is undecidable by reducing from the halting problem, $HALT_{TM}$ [@problem_id:1431410]. This involves a creative leap: translating the abstract concept of a computation halting into a concrete, observable event—a \"head collision\"—within this new machine model, showcasing how reduction serves as a universal tool for analyzing computational limits.", "problem": "In computability theory, a standard Turing Machine (TM) is a model of computation with a single infinite tape and a single read/write head. A two-headed, single-tape Turing machine (2-HTM) is a variant that possesses a single infinite tape but features two independent read/write heads, let's call them $H_1$ and $H_2$. The machine's transition function is of the form $\\delta: Q \\times \\Gamma^2 \\to Q \\times \\Gamma^2 \\times \\{L, R, S\\}^2$, where $Q$ is the set of states, $\\Gamma$ is the tape alphabet, and $\\{L, R, S\\}$ represents the head movements Left, Right, and Stay, respectively. This means the machine's next move is determined by its current state and the symbols read by both heads.\n\nA 2-HTM $T$ is said to experience a \"head collision\" if, at any point during its computation, its two heads $H_1$ and $H_2$ come to occupy the same cell on the tape.\n\nLet's define two languages. First, the well-known undecidable halting problem for TMs:\n$HALT_{TM} = \\{\\langle M, w \\rangle \\mid M \\text{ is a TM that halts on input string } w\\}$.\n\nSecond, a language concerning the behavior of 2-HTMs:\n$HEAD_{COLLIDE} = \\{\\langle T \\rangle \\mid T \\text{ is a 2-HTM that, when started on a completely blank tape, eventually has a head collision}\\}$.\n\nTo prove that $HEAD_{COLLIDE}$ is undecidable, we can construct a mapping reduction from $HALT_{TM}$. This requires defining a computable function $f$ that transforms any given input $\\langle M, w \\rangle$ into the description of a specific 2-HTM, denoted as $T = f(\\langle M, w \\rangle)$. This transformation must satisfy the core property of mapping reducibility: $M$ halts on $w$ if and only if $T$ has a head collision when started on a blank tape.\n\nWhich of the following statements provides the most effective and direct strategy for constructing the 2-HTM $T$ in a way that correctly implements the reduction $HALT_{TM} \\le_m HEAD_{COLLIDE}$?\n\nA. The machine $T$ positions its heads $H_1$ and $H_2$ at opposite ends of a tape segment. $H_1$ simulates the run of $M$ on $w$, while $H_2$ moves one step towards $H_1$ for each step of the simulation. A collision is guaranteed to happen if and only if $M$ runs forever.\n\nB. One head of $T$, say $H_1$, is used to carry out a simulation of the TM $M$ on input $w$ on one section of the tape. The other head, $H_2$, is kept stationary at a designated \"target\" cell, away from the simulation area. If and only if the simulation of $M$ reaches a halting state, $T$ enters a special state where it directs $H_1$ to move to the target cell, thus causing a collision.\n\nC. The two heads of $T$, $H_1$ and $H_2$, start at the same cell. $H_1$ remains stationary, while $H_2$ writes the input $w$ and then travels infinitely to the right. The simulation of $M$ on $w$ is encoded entirely within the finite state control of $T$. A collision occurs at the very first step, making membership in $HEAD_{COLLIDE}$ trivial and independent of the behavior of $M$.\n\nD. Both heads $H_1$ and $H_2$ are used to simulate the computation of $M$ on $w$. $H_1$ simulates the left half of the tape of $M$, and $H_2$ simulates the right half. The heads collide at the tape's center point if $M$'s computation requires its head to cross from one half to the other, an event which is engineered to correspond to $M$ halting.\n\nE. The machine $T$ simulates $M$ on $w$ using head $H_1$. Head $H_2$ perfectly mirrors the movements of $H_1$ (e.g., if $H_1$ moves left, $H_2$ moves left) but on a separate, parallel track of symbols on the same tape. If the simulation of $M$ halts, $T$ enters a cleanup phase where $H_2$ is moved onto $H_1$'s track to cause a collision.", "solution": "We seek a computable mapping $f$ from pairs $\\langle M,w \\rangle$ to encodings $\\langle T \\rangle$ of two-headed, single-tape TMs such that\n$$\n\\langle M,w \\rangle \\in HALT_{TM} \\iff \\langle T \\rangle \\in HEAD_{COLLIDE}.\n$$\nThe most direct construction is to let one head simulate $M$ on $w$ and keep the other head fixed at a designated target cell. Only when the simulated computation halts do we send the simulating head to the target cell to force a head collision.\n\nFormalizing this strategy: given $\\langle M,w \\rangle$, define $T=f(\\langle M,w \\rangle)$ as follows.\n\n1. Initialization on a blank tape. Using its two heads $H_1$ and $H_2$, $T$ performs a finite setup:\n- Choose a designated target cell (e.g., physical tape position $0$). Write a unique marker symbol $\\#$ at that cell. Place $H_2$ at this target cell and keep it stationary forever thereafter; this is enforced by the transition function by always outputting the movement $S$ for $H_2$.\n- Choose a simulation region disjoint from the target cell. To ensure disjointness forever, fix a computable bijection $g:\\mathbb{Z}\\to\\mathbb{N}$ and represent the simulated tape cell $i\\in\\mathbb{Z}$ at the physical tape position $p(i)=-g(i)-1$. Thus every simulated cell is stored at a strictly negative physical position. Place $H_1$ in the simulation region (e.g., at $p(0)$) and ensure the target cell at position $0$ is never used by the simulation.\n\n2. Encoding the input. Program $T$ so that the simulated initial tape of $M$ on input $w$ is written by $H_1$ into the simulation region: for each $i$ corresponding to a symbol of $w$, write that symbol at $p(i)$, and write blanks elsewhere. This is a finite, computable initialization.\n\n3. Simulation phase. While the simulated machine $M$ has not reached a halting state, $T$ uses $H_1$ to simulate one step of $M$:\n- Maintain within the finite control the current simulated state of $M$ and the current simulated head index $i\\in\\mathbb{Z}$.\n- To read or write the simulated cell $i$, move $H_1$ to physical position $p(i)$, read or write the symbol stored there, update the simulated state according to $M$’s transition function, and update $i$ to $i-1$, $i$, or $i+1$ accordingly. Because $p(i)$ is always strictly negative, $H_1$ never visits the target cell at position $0$ during this simulation phase. Meanwhile, $H_2$ stays stationary at the target cell.\n\n4. Collision-on-halting phase. If and only if the simulated $M$ enters a halting state, $T$ transitions to a special phase in which it ignores the simulation data and repeatedly moves $H_1$ to the right until it reaches the target cell at position $0$, where $H_2$ is stationary. The first time $H_1$ reaches position $0$, the two heads occupy the same cell, i.e., a head collision occurs.\n\nCorrectness of the reduction:\n- If $M$ halts on $w$, then the simulation phase reaches a halting simulated state in finite time, and $T$ enters the collision-on-halting phase. In that phase, $H_1$ moves right to the target cell and collides with $H_2$. Hence $\\langle T \\rangle \\in HEAD_{COLLIDE}$.\n- If $M$ does not halt on $w$, then the simulation phase never halts. Throughout the simulation, $H_1$ is confined to strictly negative positions and $H_2$ remains stationary at position $0$. Therefore no collision ever occurs, and $\\langle T \\rangle \\notin HEAD_{COLLIDE}$.\n\nComputability of $f$: Given $\\langle M,w \\rangle$, the description of $T$ is produced effectively by hardwiring $M$ and $w$ into $T$’s finite control and using the fixed computable $g$ to locate simulated cells. Thus $f$ is computable and satisfies the required bi-implication.\n\nTherefore the reduction $HALT_{TM} \\le_m HEAD_{COLLIDE}$ is achieved by the strategy described above, which matches option B.\n\nWhy the other options fail or are inferior:\n- A inverts the condition (it suggests collision iff $M$ runs forever), which does not realize the required mapping to $HEAD_{COLLIDE}$.\n- C makes collision immediate and independent of $M$ and $w$, yielding no reduction.\n- D ties collision to a head-crossing event rather than halting, which does not, in general, correspond to $M$ halting.\n- E could be engineered but introduces unnecessary complexity and ambiguities about “separate tracks” on a single tape; B is the direct, standard construction that cleanly enforces collision iff halting.\n\nHence the most effective and direct strategy is B.", "answer": "$$\\boxed{B}$$", "id": "1431410"}]}