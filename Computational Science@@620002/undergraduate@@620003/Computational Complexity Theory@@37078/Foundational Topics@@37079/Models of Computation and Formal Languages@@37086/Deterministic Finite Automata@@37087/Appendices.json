{"hands_on_practices": [{"introduction": "A core principle in designing Deterministic Finite Automata (DFAs) is that each state must encapsulate all the necessary history of the input string to make future acceptance decisions. This exercise [@problem_id:1421354] challenges you to apply this principle to a language defined by two independent properties: the parity of one symbol and the parity of another. By determining the minimum number of states, you will discover a fundamental construction method where states represent combinations of properties, a technique essential for building more complex machines.", "problem": "Consider the alphabet $\\Sigma = \\{a, b\\}$. Let $L$ be the language consisting of all strings over $\\Sigma$ that contain an even number of 'a's and an odd number of 'b's. A Deterministic Finite Automaton (DFA) is a finite-state machine that accepts or rejects strings of characters by processing them through a sequence of states. What is the minimum number of states required for a DFA to recognize the language $L$?\n\nA. 2\n\nB. 3\n\nC. 4\n\nD. 5\n\nE. 6", "solution": "To solve this problem, we need to determine the essential information that a Deterministic Finite Automaton (DFA) must remember as it processes a string character by character to decide if it belongs to the language $L$. The acceptance condition for a string depends on two independent properties: the parity of the count of 'a's and the parity of the count of 'b's.\n\nLet's analyze the properties the machine needs to track:\n1.  Has the machine seen an even or an odd number of 'a's so far?\n2.  Has the machine seen an even or an odd number of 'b's so far?\n\nA state in the DFA must encode the answers to these two questions. We can represent the state of the machine by an ordered pair $(P_a, P_b)$, where $P_a$ is the parity of the number of 'a's seen, and $P_b$ is the parity of the number of 'b's seen. Each parity can be either 'even' or 'odd'.\n\nThis gives us four possible combinations of parities, which will correspond to the minimum number of states required:\n1.  State $q_0$: (even 'a's, even 'b's)\n2.  State $q_1$: (even 'a's, odd 'b's)\n3.  State $q_2$: (odd 'a's, even 'b's)\n4.  State $q_3$: (odd 'a's, odd 'b's)\n\nLet's define the transitions and states more formally:\nThe set of states is $Q = \\{q_0, q_1, q_2, q_3\\}$.\nThe alphabet is $\\Sigma = \\{a, b\\}$.\n\nThe start state must correspond to the properties of the empty string. The empty string has zero 'a's and zero 'b's. Since zero is an even number, the initial state represents an even number of 'a's and an even number of 'b's. Thus, the start state is $q_0$.\n\nThe accepting state(s) must correspond to the definition of the language $L$, which requires an even number of 'a's and an odd number of 'b's. Therefore, the only accepting state is $q_1$.\n\nNow, let's consider the transitions between these states:\n- From state $q_0$ (even 'a's, even 'b's):\n  - On reading 'a', the parity of 'a's changes to odd, while the parity of 'b's remains even. The machine moves to state $q_2$ (odd 'a's, even 'b's).\n  - On reading 'b', the parity of 'b's changes to odd, while the parity of 'a's remains even. The machine moves to state $q_1$ (even 'a's, odd 'b's).\n\n- From state $q_1$ (even 'a's, odd 'b's):\n  - On reading 'a', the parity of 'a's changes to odd. The machine moves to state $q_3$ (odd 'a's, odd 'b's).\n  - On reading 'b', the parity of 'b's changes back to even. The machine moves to state $q_0$ (even 'a's, even 'b's).\n\n- From state $q_2$ (odd 'a's, even 'b's):\n  - On reading 'a', the parity of 'a's changes back to even. The machine moves to state $q_0$ (even 'a's, even 'b's).\n  - On reading 'b', the parity of 'b's changes to odd. The machine moves to state $q_3$ (odd 'a's, odd 'b's).\n\n- From state $q_3$ (odd 'a's, odd 'b's):\n  - On reading 'a', the parity of 'a's changes back to even. The machine moves to state $q_1$ (even 'a's, odd 'b's).\n  - On reading 'b', the parity of 'b's changes back to even. The machine moves to state $q_2$ (odd 'a's, even 'b's).\n\nAll four states are reachable from the start state $q_0$. For example:\n- $q_0$ is the start state.\n- $q_1$ is reached by reading 'b'.\n- $q_2$ is reached by reading 'a'.\n- $q_3$ is reached by reading 'ab'.\n\nFurthermore, all four states are distinguishable. For example, from state $q_0$, the string 'b' leads to an accepting state ($q_1$), but from state $q_2$, the string 'b' leads to a non-accepting state ($q_3$). This means $q_0$ and $q_2$ must be distinct states. Similar arguments can be made for all pairs of states. Since all four states are necessary to distinguish the different parity combinations, the minimal DFA must have exactly 4 states.", "answer": "$$\\boxed{C}$$", "id": "1421354"}, {"introduction": "Once a DFA is designed, we can analyze its structure to deduce fundamental properties of the language it accepts. This practice [@problem_id:1362810] shifts our focus from construction to analysis, asking whether a given DFA accepts a finite or an infinite set of strings. The key to solving this lies in examining the DFA's state transition graph for a specific pattern: a cycle that is reachable from the start state and from which an accepting state can be reached.", "problem": "A team of network engineers is designing a simple validation protocol for a control system. The protocol accepts sequences of binary signals, represented by the alphabet $\\Sigma = \\{0, 1\\}$. The validity of a sequence is checked by a Deterministic Finite Automaton (DFA). A sequence is considered valid if and only if the DFA finishes in an accepting state after processing the entire sequence.\n\nThe DFA, denoted as $M$, is formally defined by the 5-tuple $(Q, \\Sigma, \\delta, q_0, F)$, where:\n- The set of states is $Q = \\{S_0, S_1, S_2, S_3, S_4, S_5\\}$.\n- The input alphabet is $\\Sigma = \\{0, 1\\}$.\n- The initial state is $q_0 = S_0$.\n- The set of accepting states is $F = \\{S_4\\}$.\n- The transition function, $\\delta: Q \\times \\Sigma \\to Q$, is given by the following table:\n\n| Current State | Input '0' | Input '1' |\n| :-----------: | :-------: | :-------: |\n|    $S_0$      |   $S_1$   |   $S_2$   |\n|    $S_1$      |   $S_0$   |   $S_3$   |\n|    $S_2$      |   $S_5$   |   $S_4$   |\n|    $S_3$      |   $S_3$   |   $S_4$   |\n|    $S_4$      |   $S_5$   |   $S_5$   |\n|    $S_5$      |   $S_5$   |   $S_5$   |\n\nLet $L(M)$ be the language of all valid signal sequences accepted by this DFA. Your task is to determine the nature of this language. Which of the following statements is correct?\n\nA. The language $L(M)$ is finite.\n\nB. The language $L(M)$ is infinite.\n\nC. The language $L(M)$ is empty (contains no strings).\n\nD. It is undecidable whether the language $L(M)$ is finite or infinite.", "solution": "We analyze acceptance in the given DFA $M=(Q, \\Sigma, \\delta, q_0, F)$ with $Q=\\{S_0, S_1, S_2, S_3, S_4, S_5\\}$, $\\Sigma=\\{0,1\\}$, $q_0=S_0$, $F=\\{S_4\\}$, and transitions as specified. A string is accepted if the run ends in $S_4$. From the table, once the automaton enters $S_4$, any further input leads to $S_5$, and $S_5$ is a non-accepting sink: $\\delta(S_4,0)=S_5$, $\\delta(S_4,1)=S_5$, and $\\delta(S_5,0)=\\delta(S_5,1)=S_5$. Therefore, any accepted string must end exactly at the first visit to $S_4$; no symbols can follow after entering $S_4$ if the string is to be accepted.\n\nTo determine whether $L(M)$ is finite or infinite, it suffices to check whether there is a reachable cycle disjoint from $S_4$ from which $S_4$ is reachable. If such a cycle exists, we can pump along the cycle an arbitrary number of times and then take a final transition to $S_4$, yielding infinitely many accepted strings.\n\nFrom the transition table, $S_3$ is reachable from the start: \n$$S_0 \\xrightarrow{0} S_1 \\xrightarrow{1} S_3.$$\nAt $S_3$ there is a self-loop on input $0$:\n$$\\delta(S_3,0)=S_3,$$\nand from $S_3$ an input $1$ goes to the accepting state:\n$$\\delta(S_3,1)=S_4.$$\nHence, for every integer $k \\ge 0$, the string\n$$w_k = 010^k1$$\nis accepted, because the run is\n$$S_0 \\xrightarrow{0} S_1 \\xrightarrow{1} S_3 \\xrightarrow{0^k} S_3 \\xrightarrow{1} S_4.$$\nThese strings are all distinct for different $k$, so there are infinitely many accepted strings. Therefore $L(M)$ is infinite. It is neither empty nor finite, and since the DFA is fully specified, the question is decidable; thus option D is false.\n\nConsequently, the correct choice is B.", "answer": "$$\\boxed{B}$$", "id": "1362810"}, {"introduction": "A central question in computer science is how to formally verify that two different systems or models, say two DFAs $M_A$ and $M_B$, are functionally identical. This exercise [@problem_id:1421345] explores this concept by asking for the bounds on string length required to test for equivalence. The solution lies not in an infinite number of tests, but in a clever construction that creates a single DFA to recognize all strings that would distinguish the two machines, proving that this complex question has a decidable and finite answer.", "problem": "Two computer scientists, Alice and Bob, have independently designed a parser for a new communication protocol. Each researcher models their parser as a Deterministic Finite Automaton (DFA). A DFA is formally defined as a 5-tuple $(Q, \\Sigma, \\delta, q_0, F)$, where $Q$ is a finite set of states, $\\Sigma$ is the input alphabet, $\\delta: Q \\times \\Sigma \\to Q$ is the transition function, $q_0 \\in Q$ is the start state, and $F \\subseteq Q$ is the set of final (or accepting) states. An input string is accepted if the DFA ends in a state from $F$ after processing the entire string.\n\nThe first researcher's DFA, $M_A$, has 4 states. The second researcher's DFA, $M_B$, has 5 states. Both DFAs operate over the same alphabet. Two DFAs are considered equivalent if they accept the exact same language (i.e., the same set of input strings).\n\nTo verify if their designs are equivalent, they plan to test both DFAs on all possible input strings up to a certain length. If both DFAs give the same result (i.e., both accept or both reject) for all tested strings, they will conclude the DFAs are equivalent. They want to find the minimum testing bound that guarantees this conclusion is correct.\n\nWhat is the maximum possible length of a *shortest* string that could distinguish two non-equivalent DFAs, one with 4 states and the other with 5 states? This length represents the upper bound on string lengths they must test to be certain of equivalence. Provide this maximum length as your answer.", "solution": "Let $M_A=(Q_A,\\Sigma,\\delta_A,q_A,F_A)$ with $|Q_A|=m$ and $M_B=(Q_B,\\Sigma,\\delta_B,q_B,F_B)$ with $|Q_B|=n$. Consider the standard product DFA recognizing the symmetric difference of their languages:\n- State set $Q=Q_A \\times Q_B$, so $|Q|=mn$.\n- Start state $(q_A,q_B)$.\n- Transition $\\delta((p,q),a)=(\\delta_A(p,a),\\delta_B(q,a))$ for $a \\in \\Sigma$.\n- Accepting set $D=(F_A \\times (Q_B \\setminus F_B)) \\cup ((Q_A \\setminus F_A) \\times F_B)$.\n\nBy construction, a string $w \\in \\Sigma^*$ is accepted by this product DFA if and only if it distinguishes $M_A$ and $M_B$, that is, exactly one of $M_A$ or $M_B$ accepts $w$. Therefore, if $M_A$ and $M_B$ are not equivalent, then the language of the product DFA is nonempty.\n\nClaim: In any DFA with $N$ states, if its language is nonempty, then there exists an accepted string of length at most $N-1$. Proof: Let $w$ be a shortest accepted string and consider the unique computation path on $w$ from the start state to an accepting state. This path visits $|w|+1$ states. If any state repeats along this path, say the $i$-th and $j$-th states coincide with $0 \\le i  j \\le |w|$, then removing the loop between these occurrences shortens $w$ while preserving the final state (and hence acceptance), contradicting minimality. Thus all visited states are distinct, so $|w|+1 \\le N$, hence $|w| \\le N-1$.\n\nApplying the claim to the product DFA gives that the length of a shortest distinguishing string is at most $mn-1$. This bound is tight in general (there exist pairs of DFAs for which the product automaton forms a simple path of length $mn-1$ from the start to the first accepting state), so the maximum possible length of a shortest distinguishing string is $mn-1$.\n\nWith $m=4$ and $n=5$, the maximum possible length is $4 \\cdot 5-1=19$.", "answer": "$$\\boxed{19}$$", "id": "1421345"}]}