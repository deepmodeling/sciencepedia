{"hands_on_practices": [{"introduction": "Before we can design our own automata, it is essential to understand precisely how they operate. This first practice focuses on the core mechanic of Nondeterministic Finite Automata (NFA) computation: tracking the set of all possible current states as an input string is processed. By simulating an NFA's execution, including handling $\\epsilon$-transitions which allow state changes without consuming input, you will build a concrete feel for the dynamics of nondeterminism. Mastering this step-by-step simulation is a fundamental skill for debugging NFA designs and for understanding more advanced concepts like the subset construction algorithm. [@problem_id:1388210]", "problem": "A computer scientist is designing a simple lexical analysis tool based on a Nondeterministic Finite Automaton (NFA) to detect a specific pattern in a binary data stream. The NFA is formally defined with the following components:\n- A set of states $Q = \\{q_0, q_1, q_2, q_3\\}$.\n- An input alphabet $\\Sigma = \\{0, 1\\}$.\n- A start state $q_{start} = q_0$.\n- A set of accept states $F = \\{q_3\\}$.\n\nThe transition function, $\\delta: Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\to \\mathcal{P}(Q)$, where $\\mathcal{P}(Q)$ is the power set of $Q$ and $\\epsilon$ denotes the empty string, is given by the following table of rules. Note that if a state-input pair is not listed, its transition leads to the empty set $\\emptyset$.\n\n- $\\delta(q_0, 0) = \\{q_0\\}$\n- $\\delta(q_0, 1) = \\{q_0, q_1\\}$\n- $\\delta(q_1, 0) = \\{q_2\\}$\n- $\\delta(q_1, \\epsilon) = \\{q_2\\}$\n- $\\delta(q_2, 1) = \\{q_3\\}$\n- $\\delta(q_3, 0) = \\{q_3\\}$\n- $\\delta(q_3, 1) = \\{q_3\\}$\n\nGiven the input string `101`, determine the set of all possible states the machine could be in after processing the entire string. Select the correct set from the options below.\n\nA. $\\{q_0, q_1, q_3\\}$\n\nB. $\\{q_0, q_1, q_2, q_3\\}$\n\nC. $\\{q_3\\}$\n\nD. $\\{q_0, q_2\\}$\n\nE. $\\{q_0, q_1, q_2\\}$", "solution": "For an NFA with $\\epsilon$-transitions, at each step we compute the $\\epsilon$-closure of the current set of states, then move on the input symbol, and finally take the $\\epsilon$-closure again. Let $\\text{E}(S)$ denote the $\\epsilon$-closure of a set $S$. Unspecified transitions go to the empty set.\n\nInitial closure:\n$$\nS_{0}=\\text{E}(\\{q_{0}\\})=\\{q_{0}\\}\n$$\n\nAfter reading the first symbol $1$:\n$$\nT_{1}=\\bigcup_{q\\in S_{0}}\\delta(q,1)=\\delta(q_{0},1)=\\{q_{0},q_{1}\\}\n$$\n$$\nS_{1}=\\text{E}(T_{1})=\\{q_{0},q_{1}\\}\\cup\\delta(q_{1},\\epsilon)=\\{q_{0},q_{1},q_{2}\\}\n$$\n\nAfter reading the second symbol $0$:\n$$\nT_{2}=\\bigcup_{q\\in S_{1}}\\delta(q,0)=\\delta(q_{0},0)\\cup\\delta(q_{1},0)\\cup\\delta(q_{2},0)=\\{q_{0}\\}\\cup\\{q_{2}\\}\\cup\\emptyset=\\{q_{0},q_{2}\\}\n$$\n$$\nS_{2}=\\text{E}(T_{2})=\\{q_{0},q_{2}\\}\n$$\n\nAfter reading the third symbol $1$:\n$$\nT_{3}=\\bigcup_{q\\in S_{2}}\\delta(q,1)=\\delta(q_{0},1)\\cup\\delta(q_{2},1)=\\{q_{0},q_{1}\\}\\cup\\{q_{3}\\}=\\{q_{0},q_{1},q_{3}\\}\n$$\n$$\nS_{3}=\\text{E}(T_{3})=\\{q_{0},q_{1},q_{3}\\}\\cup\\delta(q_{1},\\epsilon)=\\{q_{0},q_{1},q_{2},q_{3}\\}\n$$\n\nTherefore, after processing the entire string $101$, the set of possible states is $\\{q_{0},q_{1},q_{2},q_{3}\\}$, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1388210"}, {"introduction": "With a solid grasp of how an NFA processes a string, we can now move to designing one. A common and illustrative task for an NFA is to recognize strings that end with a specific pattern. This exercise challenges you to construct an NFA for such a language, leveraging the power of nondeterminism where the automaton can \"guess\" that a particular character begins the desired suffix. This practice will sharpen your ability to translate a language description into a formal NFA structure and help you appreciate how nondeterminism can greatly simplify machine design. [@problem_id:1388241]", "problem": "In the field of theoretical computer science, a Nondeterministic Finite Automaton (NFA) is a model of computation used to recognize patterns in strings of text. An NFA is formally defined by a 5-tuple $M = (Q, \\Sigma, \\delta, q_0, F)$, where:\n- $Q$ is a finite set of states.\n- $\\Sigma$ is a finite set of input symbols, called the alphabet.\n- $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$ is the transition function, where $\\mathcal{P}(Q)$ is the power set of $Q$.\n- $q_0 \\in Q$ is the start state.\n- $F \\subseteq Q$ is the set of final (or accepting) states.\n\nAn NFA accepts a string if there exists at least one sequence of transitions, starting from $q_0$, that leads to a state in $F$ after processing the entire string.\n\nConsider the language $L$ consisting of all strings over the alphabet $\\Sigma = \\{a, b\\}$ that end with the substring 'ab'. Which of the following formal descriptions correctly represents an NFA that accepts exactly the language $L$? In all options, the set of states is $Q=\\{q_0, q_1, q_2\\}$, the alphabet is $\\Sigma = \\{a, b\\}$, and the start state is $q_0$. Transitions not explicitly defined are assumed to map to the empty set, $\\emptyset$.\n\nA. $F = \\{q_2\\}$, and the transition function $\\delta$ is defined as:\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n\nB. $F = \\{q_2\\}$, and the transition function $\\delta$ is defined as:\n   - $\\delta(q_0, a) = \\{q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n\nC. $F = \\{q_2\\}$, and the transition function $\\delta$ is defined as:\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n   - $\\delta(q_2, a) = \\{q_2\\}$\n   - $\\delta(q_2, b) = \\{q_2\\}$\n\nD. $F = \\{q_0, q_2\\}$, and the transition function $\\delta$ is defined as:\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$", "solution": "The problem asks us to identify the Nondeterministic Finite Automaton (NFA) that accepts the language $L$ of all strings over $\\Sigma = \\{a, b\\}$ ending with the substring 'ab'. Let's analyze the properties of this language and then evaluate each option.\n\nThe language $L$ includes strings like \"ab\", \"aab\", \"bab\", and \"abbab\". It does not include strings like the empty string $\\epsilon$, \"a\", \"b\", \"ba\", or \"aba\". An NFA for this language must be able to process an arbitrary prefix and then recognize the final 'ab' sequence.\n\nLet's analyze each option:\n\n**Analysis of Option A:**\n- $Q = \\{q_0, q_1, q_2\\}$, start state $q_0$, $F = \\{q_2\\}$.\n- Transitions: $\\delta(q_0, a) = \\{q_0, q_1\\}$, $\\delta(q_0, b) = \\{q_0\\}$, $\\delta(q_1, b) = \\{q_2\\}$.\n\nThe logic of this NFA can be interpreted as follows:\n- State $q_0$ is the initial state and also a \"searching\" state. It consumes any sequence of 'a's and 'b's. The loops $\\delta(q_0, a) \\ni q_0$ and $\\delta(q_0, b) = \\{q_0\\}$ allow the machine to remain in this state for any prefix.\n- The transition $\\delta(q_0, a) \\ni q_1$ is nondeterministic. When the NFA reads an 'a' in state $q_0$, it can \"guess\" that this 'a' might be the start of the desired \"ab\" suffix. It spawns a new computation path that moves to state $q_1$.\n- State $q_1$ represents the hypothesis that the last character seen was the 'a' in \"ab\".\n- If the next character is 'b', the transition $\\delta(q_1, b) = \\{q_2\\}$ takes this path to the final state $q_2$. If the string ends here, it is accepted.\n- If any other character is read in state $q_1$ (e.g., an 'a'), or any character is read in state $q_2$, the path dies as there are no defined transitions.\n\nLet's test this NFA with some strings:\n- String \"aab\":\n    1. Start in $q_0$. Read 'a'. $\\delta(q_0, a) = \\{q_0, q_1\\}$. The NFA is now in the set of states $\\{q_0, q_1\\}$.\n    2. Read 'a'. From $q_0$, $\\delta(q_0, a) = \\{q_0, q_1\\}$. From $q_1$, $\\delta(q_1, a) = \\emptyset$. The union of resulting states is $\\{q_0, q_1\\} \\cup \\emptyset = \\{q_0, q_1\\}$. The NFA is in states $\\{q_0, q_1\\}$.\n    3. Read 'b'. From $q_0$, $\\delta(q_0, b) = \\{q_0\\}$. From $q_1$, $\\delta(q_1, b) = \\{q_2\\}$. The union of resulting states is $\\{q_0\\} \\cup \\{q_2\\} = \\{q_0, q_2\\}$.\n    4. The string ends. The final set of states is $\\{q_0, q_2\\}$. Since this set contains a final state ($q_2 \\in F$), the string \"aab\" is accepted. Correct.\n- String \"aba\":\n    1. Start in $q_0$. Read 'a'. States are $\\{q_0, q_1\\}$.\n    2. Read 'b'. From $q_0 \\to \\{q_0\\}$, from $q_1 \\to \\{q_2\\}$. States are $\\{q_0, q_2\\}$.\n    3. Read 'a'. From $q_0 \\to \\{q_0, q_1\\}$, from $q_2 \\to \\emptyset$. States are $\\{q_0, q_1\\}$.\n    4. The string ends. The final set of states is $\\{q_0, q_1\\}$. This set does not contain any state from $F$. The string \"aba\" is rejected. Correct.\nThis construction correctly accepts all strings ending in \"ab\" and rejects all others. Therefore, Option A is the correct answer.\n\n**Analysis of Option B:**\n- $F = \\{q_2\\}$, $\\delta(q_0, a) = \\{q_1\\}$, $\\delta(q_0, b) = \\{q_0\\}$, $\\delta(q_1, b) = \\{q_2\\}$.\nThis NFA is deterministic in its transitions (each maps to a singleton set or empty set). The issue is the transition $\\delta(q_0, a) = \\{q_1\\}$. Once an 'a' is read, the machine must move to $q_1$ and can never return to $q_0$.\n- Let's test \"aab\". Start in $q_0$. Read 'a'. Go to $q_1$. Read 'a'. $\\delta(q_1, a) = \\emptyset$. The computation path halts without reaching a final state. The string \"aab\" is rejected, but it should be accepted. Therefore, Option B is incorrect. This NFA only accepts strings of the form $b^k ab$ for $k \\ge 0$.\n\n**Analysis of Option C:**\n- $F = \\{q_2\\}$. This NFA is similar to A, but with added self-loops on the final state $q_2$: $\\delta(q_2, a) = \\{q_2\\}$ and $\\delta(q_2, b) = \\{q_2\\}$.\nThese loops mean that once the machine reaches the final state $q_2$ (i.e., once it has seen an \"ab\" substring), it will remain in that final state no matter what characters follow.\n- Let's test \"aba\".\n    1. Start in $q_0$. Read 'a'. States are $\\{q_0, q_1\\}$.\n    2. Read 'b'. From $q_0 \\to \\{q_0\\}$, from $q_1 \\to \\{q_2\\}$. States are $\\{q_0, q_2\\}$.\n    3. Read 'a'. From $q_0 \\to \\{q_0, q_1\\}$, from $q_2 \\to \\{q_2\\}$. States are $\\{q_0, q_1, q_2\\}$.\n    4. The string ends. The final set of states contains $q_2 \\in F$. The string \"aba\" is accepted. This is incorrect, as \"aba\" does not end with \"ab\". This NFA accepts any string *containing* \"ab\" as a substring. Therefore, Option C is incorrect.\n\n**Analysis of Option D:**\n- $F = \\{q_0, q_2\\}$. This NFA has the same transitions as the correct NFA in Option A, but the set of final states is different. Here, the start state $q_0$ is also a final state.\nBecause $q_0$ is a final state, the empty string $\\epsilon$ is accepted, which is incorrect. Furthermore, consider the transitions $\\delta(q_0, a) \\ni q_0$ and $\\delta(q_0, b) = \\{q_0\\}$. There is a path for *any* input string that simply remains in state $q_0$. Since $q_0$ is an accepting state, this path will cause the string to be accepted. For example, for the string \"b\", the machine can follow the path $q_0 \\xrightarrow{b} q_0$, ending in a final state. So, \"b\" is accepted. This is incorrect. This NFA accepts all strings in $\\Sigma^*$. Therefore, Option D is incorrect.\n\nBased on the analysis, only Option A correctly describes an NFA for the specified language.", "answer": "$$\\boxed{A}$$", "id": "1388241"}, {"introduction": "Let's conclude by exploring a problem where the advantages of an NFA over its deterministic counterpart, the DFA, become strikingly clear. This classic challenge involves checking for a property at a fixed position from the end of an input string, a task for which NFAs are particularly well-suited. An NFA can nondeterministically \"guess\" which symbol is the one it's looking for and then simply verify its position by counting the remaining characters. By analyzing the minimum number of states required, you will gain a deeper appreciation for the computational elegance and efficiency that nondeterminism brings to pattern recognition. [@problem_id:1432804]", "problem": "In the design of simple network packet filters, a common task is to check for specific patterns in a data stream to classify incoming data. Consider a simplified model where a filter processor monitors a stream of binary data. The processor must raise a flag if a data packet, represented as a binary string, has a '1' as its third-to-last bit. Any sequence of bits from the start of the stream to the current point can be considered a data packet.\n\nLet the language $L$ be the set of all binary strings over the alphabet $\\Sigma = \\{0, 1\\}$ where the third symbol from the end is a '1'. For example, the string `10110` is in $L$ because its third-to-last symbol is '1', but `10010` is not in $L$.\n\nWhat is the minimum number of states required for a Nondeterministic Finite Automaton (NFA) to recognize the language $L$?\n\nA. 3\n\nB. 4\n\nC. 5\n\nD. 8", "solution": "We formalize the language as $L = \\{\\, u 1 a b \\mid u \\in \\{0,1\\}^{*},\\, a \\in \\{0,1\\},\\, b \\in \\{0,1\\} \\,\\}$, i.e., the set of binary strings whose third symbol from the end is $1$. Equivalently, for $w \\in \\{0,1\\}^{*}$, $w \\in L$ if and only if $|w| \\geq 3$ and the $(|w|-2)$-th symbol of $w$ equals $1$.\n\nUpper bound (existence of a $4$-state NFA): Construct an NFA with states $\\{q_{0}, q_{1}, q_{2}, q_{3}\\}$, start state $q_{0}$, and accepting state $q_{3}$, with transitions:\n- From $q_{0}$ on input $0$ go to $q_{0}$; on input $1$ go to both $q_{0}$ and $q_{1}$. This nondeterministically guesses that a seen $1$ is the third-from-last symbol.\n- From $q_{1}$ on input $0$ or $1$ go to $q_{2}$.\n- From $q_{2}$ on input $0$ or $1$ go to $q_{3}$.\n- $q_{3}$ has no outgoing transitions.\nAcceptance is by being in $q_{3}$ exactly at end of input. If a string $w$ has a $1$ exactly three positions from the end, then there exists a run that moves from $q_{0}$ to $q_{1}$ upon reading that $1$, then consumes exactly two more symbols to reach $q_{3}$ at the end, hence accepts. If $w \\notin L$, then no run can align so that after guessing at a $1$, exactly two symbols remain; thus no run finishes in $q_{3}$ at end. Therefore $4$ states suffice.\n\nLower bound (at least $4$ states are necessary): We use the extended fooling set method for NFAs. A set $S \\subseteq \\Sigma^{*} \\times \\Sigma^{*}$ is an extended fooling set for $L$ if for all $(x,y) \\in S$ we have $xy \\in L$, and for any distinct $(x_{1},y_{1}),(x_{2},y_{2}) \\in S$, at least one of $x_{1}y_{2}$ or $x_{2}y_{1}$ is not in $L$. Any NFA for $L$ must have at least $|S|$ states.\n\nDefine\n$$\nS \\;=\\; \\{\\, (\\epsilon,\\, 1 0 0),\\; (1,\\, 0 0),\\; (1 0,\\, 0),\\; (1 0 0,\\, \\epsilon) \\,\\}.\n$$\nFor each $(x,y) \\in S$, $xy = 1 0 0 \\in L$ since its third-from-last symbol is $1$. For distinct pairs, at least one cross-concatenation yields a string of length less than $3$, hence not in $L$ (by definition, strings with $|w|<3$ have no third-from-last symbol and are not in $L$). Concretely:\n- $\\epsilon \\cdot 0 0 = 0 0$, $1 \\cdot 0 = 1 0$, $1 0 \\cdot \\epsilon = 1 0$, and $\\epsilon \\cdot \\epsilon = \\epsilon$ all have length less than $3$, thus are not in $L$.\nTherefore $S$ is an extended fooling set of size $4$, implying any NFA for $L$ needs at least $4$ states.\n\nCombining the upper bound and the lower bound, the minimum number of states required for an NFA recognizing $L$ is $4$, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1432804"}]}