{"hands_on_practices": [{"introduction": "To understand the power and elegance of the Random Access Machine model, we begin at the most fundamental level: the instruction set. Theoretical models often use a minimal set of instructions to demonstrate computational principles. This exercise [@problem_id:1440626] challenges you to think like a computer architect by synthesizing a core arithmetic operation, subtraction, using only addition and bitwise logic. By mastering how to implement $a - b$ using the two's complement identity $-b = \\sim b + 1$, you will gain a deeper appreciation for how modern processors perform arithmetic and the efficiency of their design.", "problem": "Consider a simplified Random Access Machine (RAM) model used in theoretical computer science to analyze algorithms. This machine has a bank of registers, `R0, R1, R2, ...`, each capable of holding a $w$-bit integer. All arithmetic is performed using two's complement representation.\n\nThe machine's instruction set is limited. It supports the following operations, where `Ri`, `Rj`, and `Rk` are any registers, and `k` is an integer constant:\n\n*   `ADD Ri, Rj, Rk`: Computes the sum of the values in registers `Ri` and `Rj`, and stores the result in register `Rk`. This operation is equivalent to $Rk \\leftarrow Ri + Rj$.\n*   `NOT Ri, Rj`: Performs a bitwise NOT operation on the value in register `Ri` and stores the result in register `Rj`. This is equivalent to $Rj \\leftarrow \\sim Ri$.\n*   `LOADC k, Ri`: Loads the integer constant `k` into register `Ri`. This is equivalent to $Ri \\leftarrow k$.\n*   `COPY Ri, Rj`: Copies the value from register `Ri` into register `Rj`. This is equivalent to $Rj \\leftarrow Ri$.\n\nNoticeably, the machine lacks a subtraction instruction. Your task is to implement the operation $R1 \\leftarrow R2 - R3$ using only the available instructions. You may use registers other than `R1`, `R2`, and `R3` as temporary storage.\n\nWhich of the following sequences of instructions correctly computes the value of `R2 - R3` and stores the final result in `R1`?\n\nA.\n1. `NOT R3, R4`\n2. `ADD R2, R4, R1`\n\nB.\n1. `LOADC 1, R4`\n2. `NOT R2, R5`\n3. `ADD R5, R4, R5`\n4. `ADD R3, R5, R1`\n\nC.\n1. `LOADC 1, R4`\n2. `ADD R3, R4, R5`\n3. `NOT R5, R5`\n4. `ADD R2, R5, R1`\n\nD.\n1. `LOADC 1, R4`\n2. `NOT R3, R5`\n3. `ADD R5, R4, R5`\n4. `ADD R2, R5, R1`", "solution": "Goal: implement $R1 \\leftarrow R2 - R3$ using only ADD, NOT, LOADC, COPY on a $w$-bit two's complement RAM.\n\nKey two's complement identities (all arithmetic modulo $2^{w}$):\n$$-x = \\operatorname{NOT}(x) + 1,\\qquad \\operatorname{NOT}(x) = -x - 1.$$\nTherefore,\n$$R2 - R3 = R2 + (-R3) = R2 + \\big(\\operatorname{NOT}(R3) + 1\\big).$$\nSo the correct sequence must compute $\\operatorname{NOT}(R3)$, add $1$, then add $R2$.\n\nCheck each option:\n\nOption A:\n1. After NOT, $R4 = \\operatorname{NOT}(R3) = -R3 - 1$.\n2. Then $R1 = R2 + R4 = R2 + \\operatorname{NOT}(R3) = R2 - R3 - 1$.\nThis is off by $-1$, so incorrect.\n\nOption B:\n1. $R4 = 1$.\n2. $R5 = \\operatorname{NOT}(R2) = -R2 - 1$.\n3. $R5 = R5 + R4 = (-R2 - 1) + 1 = -R2$.\n4. $R1 = R3 + R5 = R3 - R2$.\nThis computes $R3 - R2$, not $R2 - R3$, so incorrect.\n\nOption C:\n1. $R4 = 1$.\n2. $R5 = R3 + 1$.\n3. $R5 = \\operatorname{NOT}(R5) = -(R3 + 1) - 1 = -R3 - 2$.\n4. $R1 = R2 + R5 = R2 - R3 - 2$.\nThis is off by $-2$, so incorrect.\n\nOption D:\n1. $R4 = 1$.\n2. $R5 = \\operatorname{NOT}(R3) = -R3 - 1$.\n3. $R5 = R5 + R4 = (-R3 - 1) + 1 = -R3$.\n4. $R1 = R2 + R5 = R2 + (-R3) = R2 - R3$.\nThis matches the target exactly, so correct.\n\nTherefore, the correct sequence is option D.", "answer": "$$\\boxed{D}$$", "id": "1440626"}, {"introduction": "Moving from single operations to program logic, our next practice focuses on control flow. Any non-trivial algorithm relies on making decisions, and in a RAM model, this is accomplished through conditional jumps. This problem [@problem_id:1440594] asks you to write the shortest possible program to compute the absolute value of a number. It's a classic puzzle that forces you to translate a simple `if-then` condition into the primitive instructions of a machine, providing essential practice in algorithmic thinking at the hardware level.", "problem": "A simple Random Access Machine (RAM) model operates on a set of registers, `R1, R2, R3, ...`, which can hold integer values. A program is a sequence of instructions numbered starting from 1. The machine supports the following instruction set:\n\n- `COPY Ri Rj`: Copies the integer from register `Ri` to register `Rj`.\n- `ADD Ri Rj Rk`: Calculates the sum of the integers in `Ri` and `Rj`, storing the result in `Rk`. ($Rk \\leftarrow Ri + Rj$)\n- `SUB Ri Rj Rk`: Calculates the difference by subtracting the integer in `Rj` from the integer in `Ri`, storing the result in `Rk`. ($Rk \\leftarrow Ri - Rj$)\n- `JGTZ Ri L`: If the integer in register `Ri` is strictly greater than 0, the program jumps to line `L`. Otherwise, it proceeds to the next instruction in sequence.\n\nThe program terminates when the instruction pointer moves to a line number greater than the total number of instructions in the program.\n\nAssume that initially, an arbitrary integer $x$ is placed in register `R1`. All other registers (`R2`, `R3`, `...`) are initialized to the value 0. Your task is to determine the shortest possible program that ensures the absolute value of $x$, denoted $|x|$, is stored in register `R1` upon termination, regardless of the initial value of $x$.\n\nWhat is the minimum number of instructions required for such a program?", "solution": "The goal is to write a program for the specified Random Access Machine (RAM) model that computes the absolute value of an integer $x$ initially stored in register `R1`. We need to find the minimum number of instructions required.\n\nThe definition of the absolute value $|x|$ is:\n- If $x \\geq 0$, then $|x| = x$.\n- If $x < 0$, then $|x| = -x$.\n\nThis definition is conditional. The operation performed depends on the sign of $x$. Therefore, our program must implement this conditional logic. The only conditional instruction available in our RAM model is `JGTZ Ri L`, which stands for \"Jump if Greater Than Zero\". This instruction can distinguish between positive numbers ($x > 0$) and non-positive numbers ($x \\leq 0$).\n\nLet's analyze the cases based on the `JGTZ` instruction applied to `R1` (which holds $x$).\n\n**Case 1: $x > 0$**\nIn this case, $|x| = x$. The value in `R1` is already correct. The program should do nothing to `R1`. The `JGTZ R1 L` instruction will trigger a jump. We can use this jump to skip over any instructions that would modify `R1`.\n\n**Case 2: $x \\leq 0$**\nIn this case, `JGTZ R1 L` will not cause a jump, and the program will proceed to the next instruction.\n- If $x = 0$, then $|x| = 0$. The value in `R1` is already correct.\n- If $x < 0$, then $|x| = -x$. The program must compute $-x$ and store it in `R1`.\n\nThe operation $-x$ can be expressed as $0 - x$. According to the problem statement, all registers except `R1` are initialized to 0. We can use any other register, say `R2`, which initially holds 0. The subtraction $0 - x$ can be implemented with the instruction `SUB R2 R1 R1`. This instruction computes `$R2 - R1$` and stores the result in `R1`. Since `R2` is 0 and `R1` is $x$, this results in `$R1 \\leftarrow 0 - x$`, which is $-x$.\n\nNote that if $x$ was 0, `SUB R2 R1 R1` would compute `$R1 \\leftarrow 0 - 0 = 0$`, which is also correct for $|0|$. So, the single instruction `SUB R2 R1 R1` correctly handles all non-positive cases ($x \\leq 0$).\n\nNow we can construct a program. We need a conditional jump to handle the $x > 0$ case, and a subtraction to handle the $x \\leq 0$ case.\n\nLet's try to build the shortest possible program.\nCan we do it in 1 instruction?\n- A `SUB`, `ADD`, or `COPY` instruction would execute unconditionally. For instance, `SUB R2 R1 R1` would incorrectly change $x=5$ to $-5$.\n- A `JGTZ` instruction only changes the program flow; it does not modify the data in `R1`.\nTherefore, a single instruction is not sufficient.\n\nLet's try to build a 2-instruction program.\nWe need the first instruction to be the conditional jump. If $x > 0$, we want to skip the next instruction and terminate. A program terminates if it jumps to a line number greater than the total number of instructions. For a 2-instruction program, jumping to line 3 would cause termination.\n\nConsider the following program:\n1. `JGTZ R1 3`\n2. `SUB R2 R1 R1`\n\nLet's trace its execution for the three possibilities for $x$:\n\n- **If $x > 0$ (e.g., $x = 5$):**\n  - Line 1: `JGTZ R1 3` is executed. Since `$R1 > 0$`, the program jumps to line 3.\n  - Since there is no line 3, the program terminates.\n  - The value in `R1` remains $x$. The final value is $x$, which is $|x|$. This is correct.\n\n- **If $x  0$ (e.g., $x = -5$):**\n  - Line 1: `JGTZ R1 3` is executed. Since `R1` is not greater than 0, the jump is not taken.\n  - Line 2: `SUB R2 R1 R1` is executed. `R1` gets `$R2 - R1$`. Initially, `$R2=0$` and `$R1=x$`. So `R1` becomes `$0 - x = -x$`. For $x=-5$, `R1` becomes `5`.\n  - The program then tries to proceed to line 3. Since there is no line 3, it terminates.\n  - The final value in `R1` is $-x$, which is $|x|$. This is correct.\n\n- **If $x = 0$:**\n  - Line 1: `JGTZ R1 3` is executed. Since `R1` is not greater than 0, the jump is not taken.\n  - Line 2: `SUB R2 R1 R1` is executed. `R1` gets `$R2 - R1$`, which is `$0 - 0 = 0$`.\n  - The program terminates.\n  - The final value in `R1` is `0`, which is $|0|$. This is correct.\n\nThe 2-instruction program correctly computes the absolute value for any integer $x$. Since we have argued that 1 instruction is insufficient, the minimum number of instructions required is 2.", "answer": "$$\\boxed{2}$$", "id": "1440594"}, {"introduction": "This final practice synthesizes our understanding of instructions, logic, and memory into a single, compelling scenario. We will trace the execution of a program involving a function call, which introduces the critical concepts of the call stack, return addresses, and local variable allocation. This exercise [@problem_id:1440630] demonstrates the real-world consequences of memory management by simulating a stack buffer overflow. By carefully tracking the machine's state, you will see how a seemingly small bug can overwrite a crucial piece of data—the return address—and ultimately hijack the program's control flow, a foundational concept in computer systems and security.", "problem": "Consider a hypothetical Random Access Machine (RAM) with a simplified architecture designed for theoretical analysis. The machine has the following specifications:\n\n**Architecture:**\n*   **Memory:** A byte-addressable memory array, `M`, indexed from 0. For this problem, assume each integer value occupies one memory address.\n*   **Registers:** Four general-purpose integer registers `r0, r1, r2, r3`.\n*   **Special Registers:** A Program Counter (`PC`) that holds the address of the next instruction to execute, and a Stack Pointer (`SP`) that points to the top element of the stack.\n*   **Stack:** The stack grows downwards, from higher memory addresses to lower ones. The `SP` register always points to the memory address of the most recently pushed value.\n\n**Instruction Set:**\n*   `CONST r_i, val`: Assigns the integer constant `val` to register `r_i`.\n*   `MOV r_i, r_j`: Copies the value from register `r_j` to `r_i`.\n*   `ADD r_i, r_j, r_k`: Computes `r_j + r_k` and stores the result in `r_i`.\n*   `SUB r_i, r_j, r_k`: Computes `r_j - r_k` and stores the result in `r_i`.\n*   `LOAD r_i, r_j`: Loads the value from memory at the address specified by `r_j` into `r_i`. ($r_i \\leftarrow M[r_j]$).\n*   `STORE r_i, r_j`: Stores the value from register `r_j` into memory at the address specified by `r_i`. ($M[r_i] \\leftarrow r_j$).\n*   `CALL addr`: Pushes the return address (`PC+1`) onto the stack (decrements `SP`, then sets $M[SP] \\leftarrow PC+1$) and then jumps to `addr` (sets $PC \\leftarrow addr$).\n*   `RET`: Pops the return address from the stack into the `PC` (sets $PC \\leftarrow M[SP]$, then increments `SP`).\n*   `PUSH r_i`: Pushes the value of `r_i` onto the stack (decrements `SP`, then sets $M[SP] \\leftarrow r_i$).\n*   `POP r_i`: Pops the value from the top of the stack into `r_i` (sets $r_i \\leftarrow M[SP]$, then increments `SP`).\n*   `HALT`: Terminates a program's execution.\n\n**Scenario:**\nA program is loaded into the machine's memory. The initial state of the machine is:\n*   `PC = 100`\n*   `SP = 1024`\n*   `r0 = 0`, `r1 = 0`, `r2 = 0`, `r3 = 0`\n*   All other memory locations are initialized to 0.\n\nThe program code stored in memory is as follows:\n\n```\n// Main function\n100: CALL 200\n101: HALT\n\n// Subroutine\n200: PUSH r1         // Function prologue: save caller's context\n201: MOV r1, SP      // Use r1 as a frame pointer\n202: CONST r2, 3\n203: SUB SP, SP, r2  // Allocate a 3-element buffer on the stack\n204: CONST r2, 4     // Buggy index for buffer access\n205: CONST r3, 300   // Value to write\n206: ADD r0, SP, r2  // Calculate target address: base of buffer + index\n207: STORE r0, r3    // Write value to calculated address\n208: MOV SP, r1      // Function epilogue: deallocate buffer\n209: POP r1          // Restore caller's context\n210: RET             // Return to caller\n\n// Unrelated code block\n300: CONST r0, 999\n301: HALT\n```\n\nTrace the execution of this program from its initial state. What is the value stored in register `r0` at the moment the `HALT` instruction is executed?", "solution": "We will trace the execution of the program step-by-step, keeping track of the Program Counter (`PC`), Stack Pointer (`SP`), relevant registers (`r0`, `r1`, `r2`, `r3`), and key memory locations.\n\n**Initial State:**\n*   `PC = 100`\n*   `SP = 1024`\n*   `r0=0, r1=0, r2=0, r3=0`\n\n**Execution Trace:**\n\n**1. `MAIN` function execution:**\n*   `PC=100`: `CALL 200`\n    *   The `CALL` instruction first pushes the return address ($PC+1 = 101$) onto the stack.\n    *   `SP` is decremented: $SP = 1024 - 1 = 1023$.\n    *   The return address is stored: $M[1023] = 101$.\n    *   The `PC` is set to the subroutine's address: $PC = 200$.\n*   **State:** `PC=200`, `SP=1023`, `$M[1023]=101$`.\n\n**2. `SUB` function prologue:**\n*   `PC=200`: `PUSH r1`\n    *   `SP` is decremented: $SP = 1023 - 1 = 1022$.\n    *   The value of `r1` (which is 0) is stored: $M[1022] = 0$.\n*   `PC=201`: `MOV r1, SP`\n    *   The value of `SP` (1022) is copied into `r1`. `r1` will now act as a frame pointer for this function call. $r1 = 1022$.\n*   `PC=202`: `CONST r2, 3`\n    *   Register `r2` is set to 3. $r2 = 3$.\n*   `PC=203`: `SUB SP, SP, r2`\n    *   `SP` is updated: $SP = SP - r2 = 1022 - 3 = 1019$. This allocates a 3-element buffer on the stack.\n*   **Stack Layout after Prologue:**\n    *   `SP = 1019`.\n    *   Buffer: `M[1019]`, `M[1020]`, `M[1021]`.\n    *   Saved `r1`: `M[1022]` (at `r1`, the frame pointer).\n    *   Return Address: `M[1023]` (at $r1+1$).\n*   **State:** `PC=204`, `SP=1019`, `$r1=1022$`, `$r2=3$`, `$M[1022]=0$`, `$M[1023]=101$`.\n\n**3. `SUB` function body (The Overflow):**\n*   `PC=204`: `CONST r2, 4`\n    *   Register `r2` is overwritten with the value 4. This is the buggy index. $r2 = 4$.\n*   `PC=205`: `CONST r3, 300`\n    *   Register `r3` is set to 300. This is the value that will be written. $r3 = 300$.\n*   `PC=206`: `ADD r0, SP, r2`\n    *   The target memory address is calculated. The code intends to access an element in the buffer, whose base address is `SP`.\n    *   $r0 = SP + r2 = 1019 + 4 = 1023$.\n*   `PC=207`: `STORE r0, r3`\n    *   The value of `r3` (300) is stored at the memory address specified by `r0` (1023).\n    *   $M[1023] = 300$.\n    *   **Crucially, this instruction overwrites the original return address (`101`) stored at $M[1023]$ with the new value `300`.**\n*   **State:** `PC=208`, `$r0=1023$`, `$r3=300$`, `$M[1023]=300$`.\n\n**4. `SUB` function epilogue and `RET`:**\n*   `PC=208`: `MOV SP, r1`\n    *   The `SP` is reset to the value of the frame pointer, deallocating the local buffer. $SP = r1 = 1022$.\n*   `PC=209`: `POP r1`\n    *   The saved value of `r1` is restored from the stack.\n    *   $r1 = M[SP] = M[1022] = 0$.\n    *   `SP` is incremented: $SP = 1022 + 1 = 1023$.\n*   `PC=210`: `RET`\n    *   The `RET` instruction pops the return address from the top of the stack into the `PC`.\n    *   $PC = M[SP] = M[1023]$.\n    *   Because of the overwrite at step 3, $M[1023]$ is `300`.\n    *   Therefore, $PC = 300$.\n    *   `SP` is incremented: $SP = 1023 + 1 = 1024$.\n*   **State:** Control has been hijacked. Instead of returning to address `101`, the program jumps to address `300`. `PC=300`, `SP=1024`, `$r1=0$`.\n\n**5. Hijacked Code Execution:**\n*   `PC=300`: `CONST r0, 999`\n    *   The value `999` is assigned to register `r0`. $r0 = 999$.\n*   `PC=301`: `HALT`\n    *   The program terminates.\n\n**Conclusion:**\nAt the moment of termination, the final value in register `r0` is 999.", "answer": "$$\\boxed{999}$$", "id": "1440630"}]}