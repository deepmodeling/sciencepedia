{"hands_on_practices": [{"introduction": "The power of Deterministic Finite Automata (DFAs) lies in their ability to recognize patterns with finite memory. This first exercise bridges the gap between abstract mathematical properties and concrete machine design. You will construct a DFA that recognizes binary strings representing numbers with a specific modular arithmetic property, demonstrating how each state can cleverly encode the 'memory' needed to track the running calculation[@problem_id:1444116].", "problem": "In the theory of computation, a language is a set of strings over a given alphabet. Consider the alphabet $\\Sigma = \\{0, 1\\}$. We can interpret any non-empty binary string $w = b_k b_{k-1} \\dots b_1 b_0$ (where each $b_i \\in \\{0, 1\\}$) as a positive integer $N(w)$ using the standard base-2 representation:\n$$N(w) = \\sum_{i=0}^{k} b_i \\cdot 2^i$$\nFor example, the string \"101\" represents the number $1\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 = 4 + 0 + 1 = 5$.\n\nLet $L$ be the language consisting of all non-empty binary strings $w$ such that the integer $N(w)$ they represent satisfies the condition $N(w) \\equiv 2 \\pmod{3}$. For instance, the string \"10\" is in $L$ because it represents the number 2, and $2 \\equiv 2 \\pmod{3}$. The string \"101\" is also in $L$ because it represents the number 5, and $5 \\equiv 2 \\pmod{3}$. The string \"11\" is not in $L$ because it represents 3, and $3 \\equiv 0 \\pmod{3}$. The empty string is not in $L$.\n\nWhat is the minimum number of states required for a Deterministic Finite Automaton (DFA) that accepts the language $L$?", "solution": "To solve this problem, we need to find the number of states in the minimal Deterministic Finite Automaton (DFA) for the language $L$. The language $L$ consists of binary strings $w$ representing a number $N(w)$ such that $N(w) \\equiv 2 \\pmod{3}$.\n\nA DFA processes a string from left to right. To determine if a string is in $L$, the DFA must effectively calculate the value of the number represented by the string modulo 3. The states of our DFA can represent the running value of the number modulo 3. Since there are three possible remainders when dividing by 3 (0, 1, and 2), we can design a DFA with three states, let's call them $q_0, q_1, q_2$. State $q_i$ will correspond to the set of strings processed so far that represent a number congruent to $i \\pmod{3}$.\n\nLet's define the components of the DFA:\nStates $Q = \\{q_0, q_1, q_2\\}$.\nAlphabet $\\Sigma = \\{0, 1\\}$.\nStart-State: The process begins before any characters are read. This corresponds to the empty string, which we can consider as representing the number 0. Since $0 \\equiv 0 \\pmod{3}$, the start state must be $q_0$.\n\nTransition Function $\\delta$: Let's analyze how the value of the number (modulo 3) changes as we append a bit. Suppose we have already processed a string $w$ which represents the number $N(w)$, and the DFA is in state $q_i$, meaning $N(w) \\equiv i \\pmod{3}$.\nIf we read a '0', the new string is $w0$. Its value is $N(w0) = 2 \\cdot N(w) + 0$. Modulo 3, this is $N(w0) \\equiv 2 \\cdot N(w) \\pmod{3}$. If $N(w) \\equiv i \\pmod{3}$, then $N(w0) \\equiv 2i \\pmod{3}$.\nIf we read a '1', the new string is $w1$. Its value is $N(w1) = 2 \\cdot N(w) + 1$. Modulo 3, this is $N(w1) \\equiv 2 \\cdot N(w) + 1 \\pmod{3}$. If $N(w) \\equiv i \\pmod{3}$, then $N(w1) \\equiv 2i + 1 \\pmod{3}$.\n\nUsing these rules, we can define the transitions:\n- State $q_0$ ($i=0$):\n  - On input '0': the new state is $q_{(2 \\cdot 0) \\pmod{3}} = q_0$. So, $\\delta(q_0, 0) = q_0$.\n  - On input '1': the new state is $q_{(2 \\cdot 0 + 1) \\pmod{3}} = q_1$. So, $\\delta(q_0, 1) = q_1$.\n- State $q_1$ ($i=1$):\n  - On input '0': the new state is $q_{(2 \\cdot 1) \\pmod{3}} = q_2$. So, $\\delta(q_1, 0) = q_2$.\n  - On input '1': the new state is $q_{(2 \\cdot 1 + 1) \\pmod{3}} = q_0$. So, $\\delta(q_1, 1) = q_0$.\n- State $q_2$ ($i=2$):\n  - On input '0': the new state is $q_{(2 \\cdot 2) \\pmod{3}} = q_{4 \\pmod{3}} = q_1$. So, $\\delta(q_2, 0) = q_1$.\n  - On input '1': the new state is $q_{(2 \\cdot 2 + 1) \\pmod{3}} = q_{5 \\pmod{3}} = q_2$. So, $\\delta(q_2, 1) = q_2$.\n\nAccepting States $F$: The language $L$ accepts strings $w$ where $N(w) \\equiv 2 \\pmod{3}$. Therefore, the only accepting state is $q_2$. So, $F = \\{q_2\\}$.\n\nThe problem statement specifies that the empty string is not in $L$. Our start state is $q_0$, which is not an accepting state. Thus, the empty string is rejected, which is correct.\n\nWe have constructed a 3-state DFA. Now we must confirm that it is minimal. A DFA is minimal if all its states are reachable from the start state and all pairs of states are distinguishable.\n\n1.  Reachability:\n    - $q_0$ is the start state, so it's reachable.\n    - $q_1$ is reachable from $q_0$ on input \"1\".\n    - $q_2$ is reachable from $q_0$ on input \"10\" ($\\delta(q_0, 1) = q_1$, $\\delta(q_1, 0) = q_2$).\n    All three states are reachable.\n\n2.  Distinguishability: Two states are distinguishable if there is a string that leads one to an accepting state and the other to a non-accepting state.\n    - $q_0$ and $q_2$: $q_2$ is an accepting state while $q_0$ is not. They are distinguishable by the empty string.\n    - $q_1$ and $q_2$: $q_2$ is an accepting state while $q_1$ is not. They are distinguishable by the empty string.\n    - $q_0$ and $q_1$: From $q_0$, the input \"0\" leads to $q_0$ (non-accepting). From $q_1$, the input \"0\" leads to $q_2$ (accepting). Thus, $q_0$ and $q_1$ are distinguishable.\n\nSince all three states are reachable and pairwise distinguishable, the DFA we constructed is minimal. The minimal number of states required is 3.\nThis result is also predicted by the Myhill-Nerode theorem, which states that the number of states in a minimal DFA for a language is equal to the number of equivalence classes of the Nerode relation. For this language, the equivalence classes correspond to the three possible remainders modulo 3.", "answer": "$$\\boxed{3}$$", "id": "1444116"}, {"introduction": "While many DFAs might accept the same language, there is always a unique minimal DFA with the fewest possible states. This practice provides a hands-on look at the table-filling algorithm, a systematic method for achieving this optimization[@problem_id:1444129]. By applying the logic of state distinguishability, you will take a direct role in simplifying a state machine, a crucial skill in both theoretical analysis and practical implementation.", "problem": "Consider a state machine with a set of states $Q = \\{A, B, C, D, E, F\\}$ that processes strings over the alphabet $\\Sigma = \\{0, 1\\}$. The states $C$ and $F$ are designated as accepting states, while all other states are non-accepting. The transitions between states are defined as follows:\n- From state $A$: on input 0 go to $B$, on input 1 go to $C$.\n- From state $B$: on input 0 go to $A$, on input 1 go to $D$.\n- From state $C$: on input 0 go to $E$, on input 1 go to $F$.\n- From state $D$: on input 0 go to $E$, on input 1 go to $F$.\n- From state $E$: on input 0 go to $E$, on input 1 go to $F$.\n- From state $F$: on input 0 go to $F$, on input 1 go to $F$.\n\nTo optimize the machine, an algorithm is applied to identify pairs of states that are distinguishable. In its initial step, the algorithm marks all pairs $\\{p, q\\}$ where one state is accepting and the other is not. This results in the following set of initially marked pairs:\n$\\{\\{A,C\\}, \\{A,F\\}, \\{B,C\\}, \\{B,F\\}, \\{D,C\\}, \\{D,F\\}, \\{E,C\\}, \\{E,F\\}\\}$.\n\nThe algorithm then proceeds to its next iteration. In this step, a currently unmarked pair $\\{p, q\\}$ is marked as distinguishable if, for any input symbol $s \\in \\Sigma$, the pair of resulting states $\\{\\delta(p, s), \\delta(q, s)\\}$ is already marked. Here, $\\delta(x, s)$ denotes the state reached from state $x$ on input $s$.\n\nWhich of the following options represents the complete set of *additional* pairs that are marked as distinguishable in this second step?\n\nA. $\\{\\{A,B\\}, \\{B,D\\}, \\{B,E\\}, \\{C,F\\}\\}$\n\nB. $\\{\\{D,E\\}\\}$\n\nC. $\\{\\{A,D\\}, \\{A,E\\}\\}$\n\nD. $\\{\\{A,B\\}, \\{B,D\\}, \\{B,E\\}, \\{C,F\\}, \\{A,D\\}, \\{A,E\\}\\}$\n\nE. $\\{\\{A,C\\}, \\{B,F\\}, \\{D,E\\}\\}$", "solution": "We consider the deterministic finite automaton with $Q=\\{A,B,C,D,E,F\\}$, accepting states $\\{C,F\\}$, and transition function $\\delta$ given by:\n- $\\delta(A,0)=B$, $\\delta(A,1)=C$\n- $\\delta(B,0)=A$, $\\delta(B,1)=D$\n- $\\delta(C,0)=E$, $\\delta(C,1)=F$\n- $\\delta(D,0)=E$, $\\delta(D,1)=F$\n- $\\delta(E,0)=E$, $\\delta(E,1)=F$\n- $\\delta(F,0)=F$, $\\delta(F,1)=F$\n\nThe initially marked pairs (accepting vs non-accepting) are:\n$$\\{\\{A,C\\}, \\{A,F\\}, \\{B,C\\}, \\{B,F\\}, \\{D,C\\}, \\{D,F\\}, \\{E,C\\}, \\{E,F\\}\\}.$$\nThe unmarked pairs after this initial step are:\n$$\\{A,B\\}, \\{A,D\\}, \\{A,E\\}, \\{B,D\\}, \\{B,E\\}, \\{D,E\\}, \\{C,F\\}.$$\n\nIn the second step, a currently unmarked pair $\\{p,q\\}$ is marked if there exists $s\\in\\{0,1\\}$ such that $\\{\\delta(p,s),\\delta(q,s)\\}$ is already marked from the initial step. We check each unmarked pair:\n\n- For $\\{A,B\\}$:\n  - On $0$: $\\{\\delta(A,0),\\delta(B,0)\\}=\\{B,A\\}=\\{A,B\\}$, not initially marked.\n  - On $1$: $\\{\\delta(A,1),\\delta(B,1)\\}=\\{C,D\\}$, and since $C$ is accepting and $D$ is not, $\\{C,D\\}$ is initially marked. Hence $\\{A,B\\}$ is marked in this step.\n\n- For $\\{A,D\\}$:\n  - On $0$: $\\{\\delta(A,0),\\delta(D,0)\\}=\\{B,E\\}$, both non-accepting, not initially marked.\n  - On $1$: $\\{\\delta(A,1),\\delta(D,1)\\}=\\{C,F\\}$, both accepting, not initially marked.\n  Hence $\\{A,D\\}$ remains unmarked in this step.\n\n- For $\\{A,E\\}$:\n  - On $0$: $\\{\\delta(A,0),\\delta(E,0)\\}=\\{B,E\\}$, not initially marked.\n  - On $1$: $\\{\\delta(A,1),\\delta(E,1)\\}=\\{C,F\\}$, not initially marked.\n  Hence $\\{A,E\\}$ remains unmarked in this step.\n\n- For $\\{B,D\\}$:\n  - On $0$: $\\{\\delta(B,0),\\delta(D,0)\\}=\\{A,E\\}$, not initially marked.\n  - On $1$: $\\{\\delta(B,1),\\delta(D,1)\\}=\\{D,F\\}$, where $F$ is accepting and $D$ is not, so initially marked. Hence $\\{B,D\\}$ is marked.\n\n- For $\\{B,E\\}$:\n  - On $0$: $\\{\\delta(B,0),\\delta(E,0)\\}=\\{A,E\\}$, not initially marked.\n  - On $1$: $\\{\\delta(B,1),\\delta(E,1)\\}=\\{D,F\\}$, initially marked. Hence $\\{B,E\\}$ is marked.\n\n- For $\\{D,E\\}$:\n  - On $0$: $\\{\\delta(D,0),\\delta(E,0)\\}=\\{E,E\\}$, which is not a marked pair between distinct states.\n  - On $1$: $\\{\\delta(D,1),\\delta(E,1)\\}=\\{F,F\\}$, likewise not a marked pair.\n  Hence $\\{D,E\\}$ remains unmarked.\n\n- For $\\{C,F\\}$:\n  - On $0$: $\\{\\delta(C,0),\\delta(F,0)\\}=\\{E,F\\}$, initially marked (accepting vs non-accepting).\n  Hence $\\{C,F\\}$ is marked.\n\nCollecting the additional pairs marked in this second step, we obtain:\n$$\\{\\{A,B\\}, \\{B,D\\}, \\{B,E\\}, \\{C,F\\}\\}.$$\nThis corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1444129"}, {"introduction": "Our exploration culminates in using automata theory to solve high-level decision problems, a task central to formal verification and system analysis. This problem asks you to design an algorithm for checking if the language of one DFA is a subset of another's—a property known as language inclusion. You'll master this by combining DFAs using closure properties and checking for emptiness, transforming a potentially infinite problem into a finite, algorithmic one[@problem_id:1444096].", "problem": "A software engineering team at a cybersecurity firm is tasked with verifying the behavior of a new, highly-optimized firewall module. The firewall's rules for identifying malicious network packets are modeled by a Deterministic Finite Automaton (DFA). Let $\\Sigma$ be the alphabet of all possible bytes in a packet header.\n\nThe company has a trusted, legacy firewall whose behavior is well-understood. The set of all packet headers it correctly identifies as malicious is a regular language $L(M_{legacy})$, where $M_{legacy}$ is a DFA. The new, optimized firewall implements a different set of rules, represented by another DFA, $M_{new}$, which accepts the language $L(M_{new})$.\n\nA critical requirement for deployment is \"no false negatives.\" That is, any packet header identified as malicious by the new firewall must also be identified as malicious by the trusted legacy firewall. Formally, this requires that the language accepted by the new firewall is a subset of the language accepted by the legacy firewall, i.e., $L(M_{new}) \\subseteq L(M_{legacy})$.\n\nYour task is to identify the correct algorithmic procedure to decide if this inclusion property holds for any two given DFAs, $M_{new}$ and $M_{legacy}$. The procedure must be composed of standard, decidable operations on finite automata.\n\nWhich of the following describes a correct and complete algorithm to decide if $L(M_{new}) \\subseteq L(M_{legacy})$?\n\nA. Construct a DFA $M_{A}$ for the language $L(M_{legacy})^c \\cap L(M_{new})$. Then, check if $L(M_{A})$ is empty. The inclusion holds if and only if $L(M_{A})$ is empty.\n\nB. Construct a DFA $M_{B}$ for the language $L(M_{legacy}) \\cap L(M_{new})$. Then, check if $L(M_{B})$ is empty. The inclusion holds if and only if $L(M_{B})$ is empty.\n\nC. For every string $w$ in the infinite set $L(M_{new})$, simulate both DFAs to check if $w$ is also in $L(M_{legacy})$. The inclusion holds if this is true for all such strings $w$.\n\nD. Construct a DFA $M_{D}$ for the language $L(M_{new})^c \\cap L(M_{legacy})$. Then, check if $L(M_{D})$ is empty. The inclusion holds if and only if $L(M_{D})$ is empty.\n\nE. Construct a DFA $M_{E}$ for the language $L(M_{legacy}) \\cup L(M_{new})$. Then, check if this new automaton is equivalent to $M_{new}$ by comparing their state diagrams. The inclusion holds if and only if they are equivalent.", "solution": "We must decide whether $L(M_{new}) \\subseteq L(M_{legacy})$. By a standard set-theoretic equivalence, for any languages $A$ and $B$ over the same alphabet,\n$$\nA \\subseteq B \\iff A \\cap B^{c} = \\varnothing.\n$$\nApplying this with $A = L(M_{new})$ and $B = L(M_{legacy})$, we obtain\n$$\nL(M_{new}) \\subseteq L(M_{legacy}) \\iff L(M_{new}) \\cap \\left(L(M_{legacy})\\right)^{c} = \\varnothing.\n$$\n\nDFAs are closed under complement and intersection, and the corresponding constructions are effective:\n- Complement: Given a complete DFA $M_{legacy} = (Q_{\\ell}, \\Sigma, \\delta_{\\ell}, q_{0,\\ell}, F_{\\ell})$, its complement DFA is $M_{\\ell}^{c} = (Q_{\\ell}, \\Sigma, \\delta_{\\ell}, q_{0,\\ell}, Q_{\\ell} \\setminus F_{\\ell})$, which recognizes $\\Sigma^{*} \\setminus L(M_{legacy})$. If $M_{legacy}$ is not complete, first add a sink state to make it total.\n- Intersection: Given $M_{new} = (Q_{n}, \\Sigma, \\delta_{n}, q_{0,n}, F_{n})$ and $M_{\\ell}^{c}$ as above, construct the product DFA\n$$\nM_{A} = \\left(Q_{n} \\times Q_{\\ell}, \\Sigma, \\delta, (q_{0,n}, q_{0,\\ell}), F_{n} \\times (Q_{\\ell} \\setminus F_{\\ell})\\right),\n$$\nwhere $\\delta\\left((q_{n}, q_{\\ell}), a\\right) = \\left(\\delta_{n}(q_{n}, a), \\delta_{\\ell}(q_{\\ell}, a)\\right)$ for all $a \\in \\Sigma$. Then $L(M_{A}) = L(M_{new}) \\cap \\left(L(M_{legacy})\\right)^{c}$.\n\nEmptiness of a DFA language is decidable: $L(M)$ is empty if and only if no accepting state is reachable from the start state. This is checked by a graph reachability search on the finite transition graph of $M$.\n\nTherefore, the algorithm is:\n1. Construct $M_{\\ell}^{c}$, the complement of $M_{legacy}$.\n2. Construct the product DFA $M_{A}$ recognizing $L(M_{new}) \\cap \\left(L(M_{legacy})\\right)^{c}$.\n3. Decide if $L(M_{A})$ is empty via reachability. If empty, inclusion holds; otherwise, a reachable accepting state (and corresponding word) is a counterexample to inclusion.\n\nThis procedure exactly matches option A. The other options are incorrect for the following reasons:\n- B checks $L(M_{legacy}) \\cap L(M_{new})$ for emptiness, which tests disjointness, not inclusion.\n- C requires checking all strings in an infinite set and does not yield a general decision procedure that halts in all cases.\n- D checks emptiness of $L(M_{new})^{c} \\cap L(M_{legacy})$, which is equivalent to $L(M_{legacy}) \\subseteq L(M_{new})$, the reverse inclusion.\n- E tests whether $L(M_{legacy}) \\cup L(M_{new}) = L(M_{new})$, which is also equivalent to $L(M_{legacy}) \\subseteq L(M_{new})$, the reverse inclusion, and “comparing state diagrams” is not, in general, a correct equivalence test without a formal method such as product construction or minimization and is unnecessary here.", "answer": "$$\\boxed{A}$$", "id": "1444096"}]}