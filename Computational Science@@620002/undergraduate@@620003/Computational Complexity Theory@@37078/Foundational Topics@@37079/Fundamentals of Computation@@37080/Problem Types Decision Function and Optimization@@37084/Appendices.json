{"hands_on_practices": [{"introduction": "This first practice illustrates the fundamental relationship between optimization and decision problems. We explore how having a \"magic box\" or oracle that solves an optimization problem—finding the absolute maximum bandwidth in a network—allows us to effortlessly solve a related decision problem: can the network support a certain minimum bandwidth? This exercise [@problem_id:1437415] forms the bedrock of understanding how different problem types are interconnected.", "problem": "In the field of network engineering and computational theory, we often distinguish between optimization problems and decision problems.\n\nConsider the following optimization problem:\n- **Problem Name**: `MAX_BANDWIDTH`\n- **Input**: A network represented as a graph $G$, where nodes are servers and weighted edges represent direct connection capacities.\n- **Output**: A single real number representing the maximum achievable data bandwidth between *any* pair of distinct nodes in the entire network.\n\nNow, consider the related decision problem:\n- **Problem Name**: `CAN_SUPPORT_SERVICE`\n- **Input**: A network graph $G$ and a required bandwidth threshold $B > 0$.\n- **Output**: 'YES' if there exists at least one pair of nodes in the network that can support a communication bandwidth of at least $B$. Otherwise, the output is 'NO'.\n\nImagine you have access to a hypothetical \"oracle\"—a black-box computational device that can instantly solve the `MAX_BANDWIDTH` problem for any network graph $G$ you provide as input. Your task is to design an algorithm that uses this oracle to solve the `CAN_SUPPORT_SERVICE` decision problem.\n\nWhich of the following procedures correctly and most efficiently solves the `CAN_SUPPORT_SERVICE(G, B)` problem using the `MAX_BANDWIDTH` oracle?\n\nA.\n1. Provide the network graph $G$ as input to the `MAX_BANDWIDTH` oracle.\n2. Let the oracle's numerical output be $M$.\n3. If $M \\geq B$, the algorithm returns 'YES'.\n4. Otherwise, the algorithm returns 'NO'.\n\nB.\n1. Provide both the network graph $G$ and the threshold $B$ as input to the `MAX_BANDWIDTH` oracle.\n2. If the oracle returns a value greater than 0, the algorithm returns 'YES'.\n3. Otherwise, the algorithm returns 'NO'.\n\nC.\n1. Identify all unique pairs of nodes $(u, v)$ in the network graph $G$.\n2. For each pair, call the `MAX_BANDWIDTH` oracle with the graph $G$ as input.\n3. If any of these calls returns a value $M \\geq B$, the algorithm immediately returns 'YES'.\n4. If all pairs are checked and this condition is never met, the algorithm returns 'NO'.\n\nD.\n1. Provide the network graph $G$ as input to the `MAX_BANDWIDTH` oracle.\n2. Let the oracle's numerical output be $M$.\n3. If $M < B$, the algorithm returns 'YES'.\n4. Otherwise, the algorithm returns 'NO'.\n\nE.\n1. First, check if the number of edges in the graph $G$ is greater than or equal to the threshold $B$.\n2. If it is, call the `MAX_BANDWIDTH` oracle. If the oracle returns a positive number, the algorithm returns 'YES'.\n3. Otherwise, the algorithm returns 'NO'.", "solution": "We formalize the optimization oracle and the decision predicate to derive the correct reduction.\n\nLet $\\text{bw}(u,v)$ denote the maximum achievable bandwidth between nodes $u$ and $v$ in graph $G$. The optimization oracle for $\\text{MAX\\_BANDWIDTH}$ returns\n$$\nM^{\\ast}=\\max_{u\\neq v}\\text{bw}(u,v).\n$$\nThe decision problem $\\text{CAN\\_SUPPORT\\_SERVICE}(G,B)$ asks whether\n$$\n\\exists\\,(u,v)\\text{ with }u\\neq v\\text{ such that }\\text{bw}(u,v)\\geq B.\n$$\nBy the fundamental property of the maximum over a finite set, the following equivalence holds:\n$$\n\\left(\\exists\\,(u,v):\\text{bw}(u,v)\\geq B\\right)\\quad\\Longleftrightarrow\\quad \\max_{u\\neq v}\\text{bw}(u,v)\\geq B,\n$$\nthat is,\n$$\n\\exists\\,(u,v):\\text{bw}(u,v)\\geq B\\quad\\Longleftrightarrow\\quad M^{\\ast}\\geq B.\n$$\nTherefore, an algorithm that calls the $\\text{MAX\\_BANDWIDTH}$ oracle once to obtain $M^{\\ast}$ and returns 'YES' iff $M^{\\ast}\\geq B$ is correct.\n\nAmong the given procedures:\n- A implements exactly this single-call comparison $M\\geq B$, so it is correct and uses the oracle once, which is most efficient.\n- B is invalid because the oracle takes only $G$ as input, and it checks $M>0$ instead of $M\\geq B$, which fails when $0<M<B$.\n- C redundantly calls the same oracle on the same $G$ for each pair, yielding the same $M$ each time; while it can return the correct answer, it is strictly less efficient than A.\n- D inverts the comparison (it returns 'YES' when $M<B$), so it is incorrect.\n- E uses an unrelated edge-count heuristic and again checks $M>0$, so it is incorrect.\n\nThus, the correct and most efficient procedure is A.", "answer": "$$\\boxed{A}$$", "id": "1437415"}, {"introduction": "Building on the previous concept, this problem takes us into the domain of graph theory to reinforce the connection between optimization and decision. You will use an oracle that calculates a graph's chromatic number, $\\chi(G)$, which is the solution to an optimization problem (finding the minimum number of colors for a valid vertex coloring). Your task [@problem_id:1437433] is to leverage this oracle to solve a classic decision problem: determining if a graph is bipartite, showcasing the versatility of this theoretical link.", "problem": "In the field of computational network analysis, you are given access to a proprietary software library. This library provides a single, powerful function, `CalculateChromaticValue(G)`, which takes a simple, undirected graph `G` as input and returns its chromatic number, denoted as $\\chi(G)$. The chromatic number is the minimum number of colors needed to color the vertices of `G` such that no two adjacent vertices share the same color. You can assume the input graph `G` is non-empty, meaning it contains at least one vertex.\n\nYour task is to use this function to build a new decision algorithm, `IsGraphBipartite(G)`, that returns `TRUE` if the graph `G` is bipartite, and `FALSE` otherwise. A graph is defined as bipartite if its vertices can be divided into two disjoint and independent sets, `U` and `V`, such that every edge connects a vertex in `U` to one in `V`.\n\nWhich of the following logical conditions correctly implements the `IsGraphBipartite(G)` algorithm using the `CalculateChromaticValue(G)` function?\n\nA. The algorithm returns `TRUE` if `CalculateChromaticValue(G) == 1`, and `FALSE` otherwise.\nB. The algorithm returns `TRUE` if `CalculateChromaticValue(G) == 2`, and `FALSE` otherwise.\nC. The algorithm returns `TRUE` if `CalculateChromaticValue(G) <= 2`, and `FALSE` otherwise.\nD. The algorithm returns `TRUE` if `CalculateChromaticValue(G) >= 2`, and `FALSE` otherwise.\nE. The algorithm returns `TRUE` if `CalculateChromaticValue(G)` is an even number, and `FALSE` otherwise.\nF. The correctness of `IsGraphBipartite(G)` cannot be determined from `CalculateChromaticValue(G)` alone.", "solution": "We are given a function returning the chromatic number $\\chi(G)$ of a simple, undirected, non-empty graph $G$. By definition, $\\chi(G)$ is the minimum number of colors in any proper vertex coloring. A graph $G$ is bipartite if its vertex set can be partitioned into two disjoint independent sets $U$ and $V$ such that every edge has one endpoint in $U$ and the other in $V$.\n\nKey equivalence used:\nA graph $G$ is bipartite if and only if it is $2$-colorable, which is equivalent to $\\chi(G) \\leq 2$.\nProof of the equivalence proceeds in both directions:\n1) If $G$ is bipartite with partition $(U,V)$, then color all vertices in $U$ with color $1$ and all vertices in $V$ with color $2$. Since no edge has both endpoints in the same part, this is a proper coloring using at most two colors. Hence $\\chi(G) \\leq 2$.\n2) Conversely, if $\\chi(G) \\leq 2$, then there exists a proper coloring using either one color or two colors. Let $U$ be the set of vertices assigned color $1$ and $V$ be the set of vertices assigned color $2$ (one of these sets may be empty, which is permitted by the given definition). Properness of the coloring implies both $U$ and $V$ are independent sets and every edge has endpoints in different sets, so $G$ is bipartite.\n\nTherefore, the correct decision condition for bipartiteness using $\\chi(G)$ is\n$$\nG \\text{ is bipartite} \\iff \\chi(G) \\leq 2.\n$$\n\nNow evaluate the options:\n- A tests $\\chi(G)=1$, which fails for bipartite graphs with at least one edge where $\\chi(G)=2$.\n- B tests $\\chi(G)=2$, which fails for edgeless non-empty bipartite graphs where $\\chi(G)=1$.\n- C tests $\\chi(G) \\leq 2$, which matches the equivalence above and is correct.\n- D tests $\\chi(G) \\geq 2$, which incorrectly includes non-bipartite graphs (for example, graphs with $\\chi(G)=3$).\n- E tests whether $\\chi(G)$ is even, which fails on edgeless bipartite graphs with $\\chi(G)=1$ and accepts some non-bipartite graphs with even chromatic number.\n- F is false because $\\chi(G)$ alone suffices to decide bipartiteness via $\\chi(G) \\leq 2$.\n\nThus, the correct choice is the condition $\\chi(G) \\leq 2$.", "answer": "$$\\boxed{C}$$", "id": "1437433"}, {"introduction": "This advanced practice demonstrates the most powerful aspect of the relationship between problem types: using a decision oracle to solve a function problem. Here, you are given a tool that only answers \"yes\" or \"no\" to whether a system has a bug within a certain number of steps. Your challenge [@problem_id:1437398] is to design an algorithm around this simple oracle to reconstruct the exact sequence of events—the \"violating trace\"—that leads to the bug, a common and critical task in software and hardware verification.", "problem": "In the field of formal verification, model checking is a technique used to automatically verify if a model of a system meets a given specification. A common type of specification is a safety property, which asserts that \"something bad never happens.\"\n\nConsider a system modeled as a finite transition system, which can be formally described by a tuple $M = (S, s_{init}, T, B)$, where:\n- $S$ is a finite set of states.\n- $s_{init} \\in S$ is the initial state.\n- $T \\subseteq S \\times S$ is the transition relation. A pair $(s, s') \\in T$ means the system can transition from state $s$ to state $s'$.\n- $B \\subseteq S$ is a set of \"bad\" or unsafe states.\n\nA trace (or execution path) of the system is a sequence of states $\\pi = (\\pi_0, \\pi_1, \\dots, \\pi_m)$ where $\\pi_0 = s_{init}$ and for all $0 \\le i < m$, $(\\pi_i, \\pi_{i+1}) \\in T$. The length of this trace is $m$.\n\nA trace is called a \"violating trace\" if it contains at least one state from the set $B$. A model checker's task is often to find such a trace, which serves as a counterexample to the safety property.\n\nYou are given access to a black-box decision oracle, `CheckViolation(M, k)`. This oracle takes a system model $M = (S, s_{init}, T, B)$ and a non-negative integer $k$ as input. It returns `true` if there exists a violating trace of length at most $k$ starting from $s_{init}$ in the model $M$, and `false` otherwise. You can call this oracle as many times as you need, with any valid model and any integer $k$.\n\nYour task is to devise a procedure that uses this oracle to find a concrete counterexample.\n\nConsider the following specific transition system, $M_{spec}$:\n- Set of States $S = \\{s_0, s_1, s_2, s_3, s_4, s_5, s_6\\}$\n- Initial State $s_{init} = s_0$\n- Set of Bad States $B = \\{s_6\\}$\n- Transition Relation $T = \\{(s_0, s_1), (s_0, s_2), (s_1, s_3), (s_2, s_4), (s_3, s_5), (s_4, s_0), (s_5, s_6)\\}$\n\nDescribe a general algorithm that uses the `CheckViolation` oracle to find a shortest violating trace for any given finite transition system (assuming one exists). Then, apply your algorithm to the system $M_{spec}$ to find the shortest violating trace. Your final answer should be the sequence of state labels that constitute this trace.", "solution": "We first formalize what it means to search for a shortest counterexample using only the decision oracle. Let $M=(S,s_{init},T,B)$ be a finite transition system and define the predicate $V(k)$ as the oracle result $V(k)=\\text{CheckViolation}(M,k)$, which returns true if and only if there exists a violating trace of length at most $k$ from $s_{init}$. The predicate $V(k)$ is monotone in $k$, specifically if $V(k)$ is true then $V(k')$ is true for all $k'\\geq k$. Moreover, if any violating trace exists, then there exists a shortest violating trace whose length is at most $\\lvert S\\rvert-1$, because given any violating trace, if a state repeats before reaching $B$ then the intervening cycle can be removed without losing violation; any simple path in a graph with $\\lvert S\\rvert$ nodes has length at most $\\lvert S\\rvert-1$.\n\nGeneral algorithm to find a shortest violating trace:\n1. Length discovery (binary search). Define $U=\\lvert S\\rvert-1$ and first query $V(U)$. If $V(U)$ is false, then no violating trace exists. Otherwise, perform binary search on the interval $[0,U]$ to find the minimal $k^{\\ast}$ such that $V(k^{\\ast})$ is true. Correctness follows from the monotonicity of $V(k)$ and the upper bound on the shortest violating length.\n2. Path reconstruction by prefix extension using restricted initial states. Having determined $k^{\\ast}$, reconstruct a concrete path of length exactly $k^{\\ast}$ as follows. Maintain a current state $s$ and a remaining budget $r$, initialized as $s:=s_{init}$ and $r:=k^{\\ast}$. While $r>0$ and $s\\notin B$, do:\n   - Enumerate $\\text{Post}(s)=\\{s'\\in S:(s,s')\\in T\\}$.\n   - For each $s'\\in\\text{Post}(s)$, form a modified model $M'=(S,s',T,B)$ that is identical to $M$ except with the initial state set to $s'$. Query $\\text{CheckViolation}(M',r-1)$.\n   - If for some $s'$ the oracle returns true, then there exists a violating trace of length at most $r-1$ from $s'$, hence there exists a shortest violating trace of length exactly $r$ from $s$ whose next state is $s'$. Append $s'$ to the path prefix, update $s:=s'$ and $r:=r-1$, and continue.\nThis procedure must succeed at each step because by definition of $k^{\\ast}$ there exists a length-$r$ violating suffix from $s$, so its immediate successor $s'$ at the next position will pass the oracle test with budget $r-1$. The loop terminates with $r=0$ and the current state in $B$, yielding a shortest violating trace.\n\nApplication to $M_{spec}$:\nWe have $S=\\{s_{0},s_{1},s_{2},s_{3},s_{4},s_{5},s_{6}\\}$, $s_{init}=s_{0}$, $B=\\{s_{6}\\}$, and $T=\\{(s_{0},s_{1}),(s_{0},s_{2}),(s_{1},s_{3}),(s_{2},s_{4}),(s_{3},s_{5}),(s_{4},s_{0}),(s_{5},s_{6})\\}$. The bound is $U=\\lvert S\\rvert-1=6$. Evaluate the oracle to find $k^{\\ast}$:\n- $\\text{CheckViolation}(M_{spec},3)$ is false, because any path from $s_{0}$ to $s_{6}$ must go through $s_{5}$, then $s_{3}$, then $s_{1}$, which requires at least $4$ transitions.\n- $\\text{CheckViolation}(M_{spec},5)$ is true, since there exists a path of length $4\\leq 5$ to $s_{6}$ (exhibited below).\n- By bisection, test $\\text{CheckViolation}(M_{spec},4)$, which is true; hence the minimal violating length is $k^{\\ast}=4$.\n\nReconstruct the path for $k^{\\ast}=4$:\n- Initialize $s:=s_{0}$ and $r:=4$. Compute $\\text{Post}(s_{0})=\\{s_{1},s_{2}\\}$.\n  - For $s_{1}$, form $M'=(S,s_{1},T,B)$ and query $\\text{CheckViolation}(M',3)$. This is true because $s_{1}\\to s_{3}\\to s_{5}\\to s_{6}$ reaches $B$ in $3$ steps. Choose $s_{1}$, set $s:=s_{1}$ and $r:=3$.\n- Now $s=s_{1}$, $r=3$, and $\\text{Post}(s_{1})=\\{s_{3}\\}$. For $s_{3}$, $\\text{CheckViolation}((S,s_{3},T,B),2)$ is true via $s_{3}\\to s_{5}\\to s_{6}$. Choose $s_{3}$, update $s:=s_{3}$, $r:=2$.\n- Now $s=s_{3}$, $r=2$, and $\\text{Post}(s_{3})=\\{s_{5}\\}$. For $s_{5}$, $\\text{CheckViolation}((S,s_{5},T,B),1)$ is true via $s_{5}\\to s_{6}$. Choose $s_{5}$, update $s:=s_{5}$, $r:=1$.\n- Now $s=s_{5}$, $r=1$, and $\\text{Post}(s_{5})=\\{s_{6}\\}$. For $s_{6}$, $\\text{CheckViolation}((S,s_{6},T,B),0)$ is true since $s_{6}\\in B$. Choose $s_{6}$, update $s:=s_{6}$, $r:=0$ and terminate.\nThe reconstructed shortest violating trace is $(s_{0},s_{1},s_{3},s_{5},s_{6})$.", "answer": "$$\\boxed{\\begin{pmatrix}s_{0} & s_{1} & s_{3} & s_{5} & s_{6}\\end{pmatrix}}$$", "id": "1437398"}]}