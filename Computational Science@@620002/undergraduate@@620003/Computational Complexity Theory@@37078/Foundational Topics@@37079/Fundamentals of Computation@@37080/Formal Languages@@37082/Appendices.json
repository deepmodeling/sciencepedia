{"hands_on_practices": [{"introduction": "Determining whether a language is regular is a fundamental task in formal language theory. While some languages that require counting are clearly non-regular, others can be deceptive. This exercise challenges you to look past the surface complexity of a language defined by counting substrings and apply a clever analytical approach to reveal its true, surprisingly simple nature [@problem_id:1424580].", "problem": "Consider a formal language $L$ defined over the alphabet $\\Sigma = \\{0, 1\\}$. A string $w$ is in $L$ if and only if the number of occurrences of the substring \"01\" in $w$ is equal to the number of occurrences of the substring \"10\". For example, the string `0110` is in $L$ because it contains one \"01\" substring and one \"10\" substring. The string `0101` is not in $L$ because it contains two \"01\" substrings and one \"10\" substring.\n\nWhich of the following statements about the language $L$ is correct?\n\nA. $L$ is not a regular language because determining membership requires unbounded memory to count the occurrences of \"01\" and \"10\".\n\nB. $L$ is a regular language, and it is equivalent to the set of all strings that either are empty, have a single symbol, or start and end with the same symbol.\n\nC. $L$ is a regular language, but it only contains strings of even length.\n\nD. $L$ is not a regular language because it fails the Pumping Lemma for the string $s = (01)^p$, where $p$ is the pumping length.\n\nE. $L$ is a context-free language but not a regular language.", "solution": "Let $w$ be a binary string over $\\Sigma=\\{0,1\\}$ and write it as $w=x_{1}x_{2}\\ldots x_{n}$ with $x_{i}\\in\\{0,1\\}$. Define $c_{01}(w)$ as the number of indices $i$ with $1\\leq i\\leq n-1$ such that $(x_{i},x_{i+1})=(0,1)$, and $c_{10}(w)$ similarly for $(x_{i},x_{i+1})=(1,0)$.\n\nFor each adjacent pair $(x_{i},x_{i+1})$, define\n$$\nh(x_{i},x_{i+1})=\\begin{cases}\n1  \\text{if }(x_{i},x_{i+1})=(0,1),\\\\\n-1  \\text{if }(x_{i},x_{i+1})=(1,0),\\\\\n0  \\text{if }(x_{i},x_{i+1})\\in\\{(0,0),(1,1)\\}.\n\\end{cases}\n$$\nSince $x_{i},x_{i+1}\\in\\{0,1\\}$, we have the identity $h(x_{i},x_{i+1})=x_{i+1}-x_{i}$, because $x_{i+1}-x_{i}$ equals $1$ for $(0,1)$, equals $-1$ for $(1,0)$, and equals $0$ for $(0,0)$ or $(1,1)$.\n\nTherefore,\n$$\nc_{01}(w)-c_{10}(w)=\\sum_{i=1}^{n-1}h(x_{i},x_{i+1})=\\sum_{i=1}^{n-1}(x_{i+1}-x_{i})=x_{n}-x_{1}.\n$$\nConsequently,\n$$\nc_{01}(w)=c_{10}(w)\\quad\\Longleftrightarrow\\quad x_{n}-x_{1}=0\\quad\\Longleftrightarrow\\quad x_{n}=x_{1}.\n$$\nFor $n=0$ (the empty string) and $n=1$ (a single symbol), there are no adjacent pairs, so $c_{01}(w)=c_{10}(w)=0$, and the condition holds. For $n\\geq 2$, the condition is equivalent to the first and last symbols being equal.\n\nHence the language $L$ is exactly the set of all strings that are either empty, or that start and end with the same symbol. This set is regular; for example, it is recognized by a finite automaton that remembers the first symbol and compares it with the last symbol, accepting if they match (and also accepting the empty string), or equivalently described by the regular expression $\\epsilon \\mid 0 \\mid 1 \\mid 0(0|1)^*0 \\mid 1(0|1)^*1$.\n\nTherefore, option B is correct. The remaining options are incorrect: A is false because membership depends only on the first and last symbol and does not require unbounded memory; C is false since strings of odd length such as $010$ are in $L$; D is false because $L$ is regular and thus cannot fail the Pumping Lemma; E is false for the same reason.", "answer": "$$\\boxed{B}$$", "id": "1424580"}, {"introduction": "While finite automata are powerful, they lack the memory to recognize many important patterns, such as palindromes. To handle such context-free languages, we need a more sophisticated machine: the pushdown automaton (PDA). This practice will guide you through the essential mechanics of a PDA, focusing on how non-determinism and a stack are used to recognize a classic non-regular language [@problem_id:1424576].", "problem": "Consider the language $L$ of all palindromes over the alphabet $\\Sigma = \\{a, b\\}$. A palindrome is a string that reads the same forwards and backwards. Formally, $L = \\{w \\in \\{a,b\\}^* \\mid w = w^R\\}$, where $w^R$ denotes the reverse of string $w$.\n\nA non-deterministic Pushdown Automaton (PDA), denoted $M$, is being designed to accept this language $L$. The PDA is defined by the tuple $M = (Q, \\Sigma, \\Gamma, \\delta, q_0, Z_0, F)$, with the following components:\n- States $Q = \\{q_0, q_1, q_2\\}$\n- Input alphabet $\\Sigma = \\{a, b\\}$\n- Stack alphabet $\\Gamma = \\{a, b, Z_0\\}$, where $Z_0$ is the initial stack symbol.\n- Start state $q_0$\n- Set of final states $F = \\{q_2\\}$\n\nThe intended logic of the PDA is as follows:\n1. In state $q_0$, read the first half of the input string and push corresponding symbols onto the stack.\n2. Non-deterministically guess the middle of the string and transition to state $q_1$. This transition may or may not consume an input symbol, to account for both even and odd length palindromes.\n3. In state $q_1$, read the second half of the input string, matching each symbol with the symbol at the top of the stack and popping it.\n4. If the entire input string has been read and the stack contains only the initial symbol $Z_0$, transition to the final state $q_2$.\n\nSome of the transition rules, $\\delta$, are already defined. The transitions are written in the format $\\delta(\\text{current\\_state}, \\text{input\\_symbol}, \\text{stack\\_top}) = \\{(\\text{next\\_state}, \\text{string\\_to\\_push})\\}$.\n- **Pushing Rules (in state $q_0$):**\n    - $\\delta(q_0, a, X) = \\{(q_0, aX)\\}$ for any stack symbol $X \\in \\Gamma$\n    - $\\delta(q_0, b, X) = \\{(q_0, bX)\\}$ for any stack symbol $X \\in \\Gamma$\n- **Acceptance Rule:**\n    - $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\nYour task is to identify the correct set of additional transition rules required to complete the PDA so that it correctly accepts the language $L$. Which of the following sets of rules correctly represents the \"middle-guess\" and \"popping\" phases? Note that $\\epsilon$ denotes the empty string.\n\nA.\n- $\\delta(q_0, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_0, b, b) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$\n\nB.\n- $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$\n- $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$\n\nC.\n- $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$\n- $\\delta(q_0, a, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$\n- $\\delta(q_0, b, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$\n- $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$\n\nD.\n- $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$\n- $\\delta(q_0, a, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$\n- $\\delta(q_0, b, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$\n- $\\delta(q_1, a, b) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, a) = \\{(q_1, \\epsilon)\\}$", "solution": "The goal is to construct a Pushdown Automaton (PDA) that recognizes the language of palindromes $L = \\{w \\mid w=w^R\\}$ over $\\Sigma=\\{a,b\\}$. The PDA must correctly handle palindromes of both even and odd lengths, as well as the empty string.\n\nThe given structure of the PDA uses three states: $q_0$ for the pushing phase, $q_1$ for the popping phase, and $q_2$ as the final (accept) state.\n\nLet's analyze the necessary logic step-by-step:\n\n1.  **Pushing Phase:** The PDA starts in state $q_0$. For the first half of the input string $w$, it should read the symbols and push them onto the stack. This creates a reversed record of the first half. The provided rules $\\delta(q_0, a, X) = \\{(q_0, aX)\\}$ and $\\delta(q_0, b, X) = \\{(q_0, bX)\\}$ for any $X \\in \\Gamma$ correctly implement this. For an input symbol $c$, it is pushed on top of whatever is already on the stack ($X$), resulting in the stack content becoming $cX$.\n\n2.  **Guessing the Middle:** This is the crucial non-deterministic step. The PDA must guess when it has reached the middle of the string.\n    *   **Even-length palindromes:** For a string like `abba`, the middle occurs between the two `b`'s. After reading `ab`, the stack contains `baZ_0` (from bottom to top). The PDA must transition from the pushing state ($q_0$) to the popping state ($q_1$) without consuming any input symbol. The rule for this is $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ for any stack symbol $X$. This rule leaves the stack unchanged and moves to state $q_1$ to begin the matching phase.\n    *   **Odd-length palindromes:** For a string like `aba`, the middle is the symbol `b`. After reading `a`, the stack contains `aZ_0`. The PDA needs to read the middle symbol `b` but *not* perform any stack operation, as this central character does not have a counterpart. Then it must transition to state $q_1$. The rules for this are $\\delta(q_0, a, X) = \\{(q_1, X)\\}$ and $\\delta(q_0, b, X) = \\{(q_1, X)\\}$ for any symbol $X$ on the stack. These rules consume one input symbol (the middle one) but leave the stack as it is, before moving to the popping state $q_1$.\n\n3.  **Popping Phase:** Once in state $q_1$, the PDA reads the second half of the string. For each input symbol it reads, it must match the symbol on top of the stack. If they match, the stack symbol is popped. For example, if the input is `a` and the top of the stack is `a`, the machine should pop `a` and remain in state $q_1$. The required rules are $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$ and $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$. The $\\epsilon$ in the output signifies that nothing is pushed back onto the stack, effectively a pop operation.\n\n4.  **Acceptance:** After the entire string has been read, if the machine successfully matched all symbols in the second half, the stack should contain only the initial symbol $Z_0$. The given acceptance rule $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$ allows the machine to transition to the final state $q_2$ at this point, thereby accepting the string. The empty string is also a palindrome. The machine can handle this by starting in $q_0$ and immediately taking the $\\epsilon$-transition $\\delta(q_0, \\epsilon, Z_0) = \\{(q_1, Z_0)\\}$ to get to $q_1$, and then taking the acceptance transition $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$ to accept.\n\nNow, let's evaluate the given options:\n\n*   **Option A:** The rules $\\delta(q_0, a, a) = \\{(q_1, \\epsilon)\\}$ and $\\delta(q_0, b, b) = \\{(q_1, \\epsilon)\\}$ are incorrect for the \"middle-guess\". They imply that to transition to state $q_1$, the machine must read an input symbol that matches the top of the stack and pop it. This is not the logic for pushing the first half of a string before matching the second half.\n\n*   **Option B:** This option only includes the rule $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ for the middle guess. This correctly handles even-length palindromes but provides no way to handle the middle character of odd-length palindromes. An odd-length palindrome like `aba` would be rejected because the PDA would have no defined transition for reading the middle `b`.\n\n*   **Option C:** This option provides the complete set of rules needed for both the middle-guess and the popping phase.\n    *   $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ handles the even-length case.\n    *   $\\delta(q_0, a, X) = \\{(q_1, X)\\}$ and $\\delta(q_0, b, X) = \\{(q_1, X)\\}$ handle the odd-length case by consuming the middle symbol without altering the stack.\n    *   $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$ and $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$ correctly implement the matching and popping for the second half of the string.\n    This set of rules is correct.\n\n*   **Option D:** This option has the correct rules for guessing the middle, but its popping rules are wrong. The rule $\\delta(q_1, a, b) = \\{(q_1, \\epsilon)\\}$ means \"if the input is `a`, pop `b`\". This would not match a palindrome. For the palindrome `aba`, after pushing `a` and reading the central `b`, the stack contains `aZ_0`. The next input is `a`. This rule set provides no transition for $(q_1, a, a)$, so the machine would get stuck and reject.\n\nTherefore, the only correct and complete set of rules is provided in Option C.", "answer": "$$\\boxed{C}$$", "id": "1424576"}, {"introduction": "Just as pushdown automata provide a machine-based model for recognizing context-free languages, context-free grammars (CFGs) offer a generative one. To make these grammars useful for applications like parsing, we often convert them into a standardized format. This exercise provides hands-on practice with the essential algorithm for converting a CFG into Chomsky Normal Form (CNF), a critical skill for both theoretical proofs and practical compiler design [@problem_id:1424566].", "problem": "A context-free grammar (CFG) is a formal grammar in which every production rule is of the form $V \\rightarrow w$, where $V$ is a single non-terminal symbol, and $w$ is a string of terminals and/or non-terminals.\n\nA CFG is in Chomsky Normal Form (CNF) if every production rule is in one of the following forms:\n1. $A \\rightarrow BC$, where $A, B, C$ are non-terminal symbols.\n2. $A \\rightarrow a$, where $A$ is a non-terminal symbol and $a$ is a terminal symbol.\nAdditionally, if the empty string $\\epsilon$ is in the language, the rule $S \\rightarrow \\epsilon$ is allowed, where $S$ is the start symbol, provided that $S$ does not appear on the right-hand side of any rule.\n\nConsider the following context-free grammar $G$ with the set of non-terminal symbols $V = \\{S, A, B\\}$, the set of terminal symbols $\\Sigma = \\{a, b\\}$, and $S$ as the start symbol. The production rules $P$ are given as:\n$S \\rightarrow aSA$\n$A \\rightarrow bB$\n$B \\rightarrow S \\mid \\epsilon$\n\nYour task is to convert the grammar $G$ into an equivalent grammar $G'$ in Chomsky Normal Form. From the options below, select the one that correctly represents the set of production rules for $G'$. In the options, $S'$ is the new start symbol, and any other new non-terminal symbols are denoted by $V_x$ or $X_y$.\n\nA.\n- $S' \\rightarrow V_a X_1$\n- $S \\rightarrow V_a X_1$\n- $A \\rightarrow V_b B$\n- $B \\rightarrow V_a X_1$\n- $X_1 \\rightarrow S A$\n- $V_a \\rightarrow a$\n- $V_b \\rightarrow b$\n\nB.\n- $S' \\rightarrow V_a X_1$\n- $S \\rightarrow V_a X_1$\n- $A \\rightarrow V_b B$\n- $A \\rightarrow b$\n- $B \\rightarrow S$\n- $B \\rightarrow V_a X_1$\n- $X_1 \\rightarrow S A$\n- $V_a \\rightarrow a$\n- $V_b \\rightarrow b$\n\nC.\n- $S' \\rightarrow V_a X_1$\n- $S \\rightarrow V_a X_1$\n- $A \\rightarrow V_b B$\n- $A \\rightarrow b$\n- $B \\rightarrow V_a X_1$\n- $X_1 \\rightarrow S A$\n- $V_a \\rightarrow a$\n- $V_b \\rightarrow b$\n\nD.\n- $S \\rightarrow V_a X_1$\n- $A \\rightarrow V_b B$\n- $A \\rightarrow b$\n- $B \\rightarrow V_a X_1$\n- $X_1 \\rightarrow S A$\n- $V_a \\rightarrow a$\n- $V_b \\rightarrow b$\n\nE.\n- $S' \\rightarrow V_a S A$\n- $S \\rightarrow V_a S A$\n- $A \\rightarrow V_b B$\n- $A \\rightarrow b$\n- $B \\rightarrow V_a S A$\n- $V_a \\rightarrow a$\n- $V_b \\rightarrow b$", "solution": "We start from the given grammar with nonterminals $V=\\{S,A,B\\}$, terminals $\\Sigma=\\{a,b\\}$, start symbol $S$, and productions\n$$ S \\rightarrow aSA,\\quad A \\rightarrow bB,\\quad B \\rightarrow S \\mid \\epsilon $$\nStep 1: Identify nullable nonterminals. Since $B \\rightarrow \\epsilon$, $B$ is nullable. Because $A \\rightarrow bB$, $A$ can derive $b$ but not $\\epsilon$, so $A$ is not nullable. Also $S$ is not nullable because its rule $S \\rightarrow aSA$ contains the terminal $a$ and no nullable-only right-hand side.\n\nStep 2: Eliminate $\\epsilon$-productions. Remove $B \\rightarrow \\epsilon$ and add the variant of any production containing $B$ with $B$ omitted. The only such production is $A \\rightarrow bB$, which yields an additional $A \\rightarrow b$. Thus, after $\\epsilon$-elimination we have\n$$ S \\rightarrow aSA,\\quad A \\rightarrow bB \\mid b,\\quad B \\rightarrow S $$\nStep 3: Eliminate unit productions. The only unit production is $B \\rightarrow S$. Replace it by $B$ adopting the productions of $S$, namely $B \\rightarrow aSA$, and remove $B \\rightarrow S$. We get\n$$ S \\rightarrow aSA,\\quad A \\rightarrow bB \\mid b,\\quad B \\rightarrow aSA $$\nStep 4: Prepare for Chomsky Normal Form by isolating terminals in long right-hand sides and binarizing. Introduce new nonterminals for terminals that appear in right-hand sides of length greater than $1$:\n$$ V_{a} \\rightarrow a,\\quad V_{b} \\rightarrow b $$\nReplace terminals in long right-hand sides and binarize any right-hand sides of length greater than $2$ by introducing a new variable $X_{1}$ with\n$$ X_{1} \\rightarrow SA $$\nThen transform\n$$ S \\rightarrow aSA \\Rightarrow S \\rightarrow V_{a}SA \\Rightarrow S \\rightarrow V_{a}X_{1}, $$\n$$ B \\rightarrow aSA \\Rightarrow B \\rightarrow V_{a}SA \\Rightarrow B \\rightarrow V_{a}X_{1}, $$\nand\n$$ A \\rightarrow bB \\Rightarrow A \\rightarrow V_{b}B,\\quad A \\rightarrow b\\ \\text{(keep as terminal rule)}. $$\nStep 5: Introduce a new start symbol $S'$ that does not appear on any right-hand side. To avoid the unit production $S' \\rightarrow S$, define $S'$ to mirror $S$’s production directly:\n$$ S' \\rightarrow V_{a}X_{1}. $$\nCollecting all productions in CNF, we obtain\n$$ S' \\rightarrow V_{a}X_{1},\\quad S \\rightarrow V_{a}X_{1},\\quad A \\rightarrow V_{b}B \\mid b,\\quad B \\rightarrow V_{a}X_{1},\\quad X_{1} \\rightarrow SA,\\quad V_{a} \\rightarrow a,\\quad V_{b} \\rightarrow b $$\nwhich matches option C.\n\nWhy the other options are invalid:\n- A omits $A \\rightarrow b$, which is required after eliminating $B \\rightarrow \\epsilon$, thus changing the language.\n- B retains the unit production $B \\rightarrow S$, which is not allowed in CNF.\n- D lacks the new start symbol $S'$ as specified in the options’ description.\n- E contains right-hand sides of length $3$ (e.g., $S' \\rightarrow V_{a}SA$), violating CNF’s binary form requirement.\n\nTherefore, the correct choice is C.", "answer": "$$\\boxed{C}$$", "id": "1424566"}]}