{"hands_on_practices": [{"introduction": "This first practice provides a foundational exercise in building a complete heap allocator from first principles. You will implement a `first-fit` strategy where the free list is maintained in strictly increasing address order, a choice that greatly simplifies the process of coalescing adjacent free blocks. By simulating allocation and deallocation requests and analyzing performance under a defined cost model, you will gain direct insight into the algorithmic trade-offs inherent in dynamic memory management [@problem_id:3239179].", "problem": "Consider a heap memory allocator whose free list is maintained in strictly increasing address order. You will implement a simulator for this allocator and empirically analyze its performance under a precisely specified unit-cost model. All addresses and sizes are integer units, the heap starts at address $0$, and the capacity is a fixed integer $C$. The free list initially contains one block covering the entire heap. Allocation requests and deallocation requests are processed sequentially.\n\nDefinitions and rules:\n- The heap has capacity $C \\in \\mathbb{N}$ addressable units.\n- A free block is a pair $(a,s)$ with starting address $a \\in \\mathbb{N}$ and size $s \\in \\mathbb{N}$, representing the half-open interval $[a,a+s)$.\n- The free list is a sequence of free blocks sorted by strictly increasing $a$ with no overlap or adjacency among distinct blocks.\n- Allocation request alloc$(x)$ with $x \\in \\mathbb{N}$ uses the first-fit policy: scan the free list in address order to find the first block $(a,s)$ with $s \\ge x$. If found, allocate the lowest addresses, returning an allocated block $[a,a+x)$ and splitting the free block to $(a+x, s-x)$ if $s > x$, or removing it if $s = x$. If no block fits, the allocation fails.\n- Deallocation request free$(i)$ releases the previously returned block for handle $i \\in \\mathbb{N}$ back into the free list. Insertion is performed so that the free list remains sorted by starting address, followed by immediate coalescing with predecessor and/or successor if and only if they are exactly adjacent (that is, $(a_{\\text{pred}}, s_{\\text{pred}})$ where $a_{\\text{pred}} + s_{\\text{pred}} = a_{\\text{new}}$, and similarly for the successor).\n- Each successful allocation is assigned a distinct handle $i \\in \\mathbb{N}$, starting at $i=1$ and increasing by $1$ for each success. Subsequent free$(i)$ refers to this handle. No request will attempt to free a handle that was never successfully allocated.\n\nUnit-cost step model:\n- For alloc$(x)$: each visited free block during the left-to-right scan counts as exactly $1$ step, including the block that satisfies the request or the last examined block in case of failure. Splitting and updates do not add steps.\n- For free$(i)$: each move from a free block to the next while searching for the insertion position counts as exactly $1$ step. Additionally, checking adjacency with the predecessor (if it exists) counts as $1$ step, and checking adjacency with the successor (if it exists) counts as $1$ step. The actual merges do not add steps beyond these adjacency checks.\n\nExternal fragmentation:\n- After all operations of a test case complete, let $F$ be the set of free blocks. Define $T = \\sum_{(a,s) \\in F} s$ and $L = \\max\\{s : (a,s) \\in F\\}$, with the convention $T=0$ implies external fragmentation $0$. Otherwise, the external fragmentation ratio is $1 - \\frac{L}{T}$, a real number in $[0,1]$.\n\nYour task:\n- Implement a complete program that simulates this allocator, processes the specified test suite, and reports quantitative metrics from the unit-cost model.\n\nRequired outputs for each test case:\n- The average number of steps per alloc$(\\cdot)$ request over all allocation attempts (including failed attempts), as a real number.\n- The average number of steps per free$(\\cdot)$ request over all deallocations, as a real number.\n- The final number of free blocks, as an integer.\n- The final external fragmentation ratio, as a real number in $[0,1]$.\n\nRounding and final output format:\n- Round all real numbers to exactly $6$ decimal places using standard rounding to nearest, ties to even are acceptable as in typical floating-point formatting.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the values for all test cases concatenated in order. For example, if a single test produced $4$ values $r_1, r_2, r_3, r_4$, and there are multiple tests, the final output should be of the form $[r_{1,1}, r_{1,2}, r_{1,3}, r_{1,4}, r_{2,1}, r_{2,2}, \\dots]$, where commas separate adjacent numbers and there are no spaces.\n\nTest suite:\n- Test $1$ (happy path with splitting and coalescing): capacity $C = 64$, operations in order using the notation alloc$(x)$ and free$(i)$:\n  - alloc$(8)$, alloc$(8)$, alloc$(8)$, free$(2)$, alloc$(4)$, alloc$(4)$, alloc$(16)$, free$(1)$, free$(3)$, free$(4)$.\n- Test $2$ (boundary exact fit): capacity $C = 32$, operations:\n  - alloc$(32)$, free$(1)$.\n- Test $3$ (fragmentation shaping and partial fits): capacity $C = 64$, operations:\n  - alloc$(12)$, alloc$(12)$, alloc$(12)$, alloc$(12)$, free$(2)$, free$(4)$, alloc$(10)$, alloc$(10)$, free$(1)$, free$(3)$, alloc$(24)$.\n- Test $4$ (adverse scan for first-fit): capacity $C = 128$, operations:\n  - alloc$(16)$, alloc$(16)$, alloc$(16)$, alloc$(16)$, alloc$(16)$, alloc$(16)$, free$(2)$, free$(4)$, free$(6)$, alloc$(32)$, free$(1)$, free$(3)$, free$(5)$, free$(7)$.\n- Test $5$ (stochastic workload with a Pseudo-Random Number Generator (PRNG)): capacity $C = 256$. Generate a sequence of $N = 200$ operations using the following rule with seed $S = 123456$:\n  - At each step, choose alloc with probability $p = 0.6$ and free with probability $1-p$. If free is chosen when there are no live handles, force alloc instead.\n  - For alloc, draw a size $x$ uniformly from the integers in $[1,32]$. Attempt alloc$(x)$; if it fails, it still counts as one allocation attempt with its step cost, and no handle is created.\n  - For free, choose one currently live handle uniformly at random and free it.\n  - Use the PRNG only to determine the operation type, the allocation size, and the choice of handle to free. The PRNG must be initialized with the given seed $S$ so results are reproducible.\n\nWhat to implement:\n- A simulator that maintains the free list in address order, supports first-fit alloc, address-ordered insertion with immediate coalescing on free, counts steps according to the unit-cost model, and computes external fragmentation. Apply it to the test suite above and print the final flat list of results in the specified order and rounding.", "solution": "We begin from core definitions of heap allocation and list scanning in a comparison-based, unit-cost model. The heap is a contiguous array of $C$ integer-sized units, initially entirely free as a single block. A free list maintains disjoint free blocks sorted by increasing starting address. The allocator uses first-fit, which is a fundamental approach relying on a sequential scan of the free list to find the first block large enough to satisfy a request.\n\nDesign of data structures:\n- Represent the free list as a sequence of pairs $(a,s)$, strictly ordered by $a$. This ensures that predecessor and successor in the list are exactly the immediate neighbors by address among free blocks.\n- Maintain a dictionary mapping each allocated handle $i$ to its block $(a,s)$ to support free$(i)$.\n\nAllocation algorithm (first-fit) from definitions:\n- To allocate a request of size $x$, scan the free list left to right until encountering the first $(a,s)$ with $s \\ge x$. If such a block exists, return the subinterval $[a,a+x)$ to the client, and update the free block to $(a+x, s-x)$ if $s > x$, or remove it entirely if $s = x$.\n- If no such block exists, the request fails.\n- Under the unit-cost model, each visited block in the scan is counted as exactly $1$ step, including the final visited block whether or not the request succeeds. This follows from the basic cost model of sequential search, where each node visitation is one step.\n\nDeallocation algorithm (address-ordered insertion with coalescing):\n- For free$(i)$, recover $(a,s)$ from the handle $i$ and insert it back into the free list at the unique index that preserves address order. Because the list is sorted by $a$, insertion point can be found by a left-to-right scan. Each advance to the next list node contributes $1$ step in the cost model.\n- After insertion, check at most two adjacencies for coalescing:\n  - Check predecessor adjacency: if there is a predecessor $(a_p,s_p)$ and $a_p + s_p = a$, merge to $(a_p, s_p + s)$ by replacing the two blocks with the single merged block. The check itself is counted as one step.\n  - Check successor adjacency: if there is a successor $(a_s,s_s)$ and $a + s = a_s$, merge to $(a, s + s_s)$ similarly. The check is counted as one step. If both predecessor and successor are adjacent, both merges occur, yielding a single combined block.\n- Actual merges do not incur additional steps beyond adjacency checks, reflecting the principle that comparisons and pointer moves dominate in this list-based model.\n\nExternal fragmentation:\n- After completing a test case, compute $T = \\sum_{(a,s) \\in F} s$ and $L = \\max\\{s : (a,s) \\in F\\}$ if $F \\ne \\emptyset$, with the convention that if $T=0$ then the fragmentation is $0$. Otherwise, the external fragmentation ratio is $1 - \\frac{L}{T}$, which lies in $[0,1]$ due to $L \\le T$.\n\nComplexity derivation from first principles:\n- Let $k$ be the current number of free blocks. A sequential scan over the address-ordered list to find the first fit touches up to $k$ blocks in the worst case, so the worst-case cost is $\\Theta(k)$ steps by the unit-cost model. This follows directly from the definition of sequential search: each block visitation contributes exactly one step and up to all $k$ blocks can be examined.\n- For free$(i)$, finding the insertion point in address order is again a sequential search over up to $k$ blocks, so the search cost is $\\Theta(k)$. Coalescing requires at most two adjacency checks (predecessor and successor), contributing at most $2$ additional steps. Therefore, the overall worst-case free cost is $\\Theta(k)$.\n- The address-ordered list allows coalescing in $O(1)$ additional comparisons once the insertion point is known, because adjacency can be determined using only the immediate neighbor blocks as a consequence of the total order by $a$. This eliminates the need to search for potentially adjacent blocks elsewhere.\n\nEmpirical measurement plan and correctness:\n- Implement the allocator and instrumentation that accumulates step counts according to the specified model: for alloc$(\\cdot)$, count one step per visited free block; for free$(\\cdot)$, count steps for each advancement while searching, plus up to two adjacency checks. These definitions are directly applied as the fundamental rules used to implement the counters.\n- For each test case, maintain counters for the number of allocation attempts and deallocations, and the total steps for each. At the end of each test, compute the averages as rational numbers $\\frac{\\text{total steps}}{\\text{count}}$, rounded to $6$ decimals.\n- Compute the final number of free blocks $|F|$ and the external fragmentation ratio $1 - \\frac{L}{T}$.\n\nTest suite coverage rationale:\n- Test $1$ exercises splitting, freeing a middle block, subsequent allocations that partially fill holes, and coalescing when freeing neighboring allocated blocks.\n- Test $2$ checks the boundary case of an exact fit that consumes the entire heap and freeing it back to a single block.\n- Test $3$ constructs fragmentation through partial fits to measure external fragmentation and the impact on first-fit scans.\n- Test $4$ creates alternating allocated and free blocks to force a long scan for a larger request, then frees to test full coalescing back to a single block.\n- Test $5$ uses a reproducible stochastic workload generated by a Pseudo-Random Number Generator (PRNG) with a fixed seed, covering varied interleavings, sizes, successes, and failures to provide an aggregate view of performance.\n\nThe program implements these definitions precisely and outputs, for each test in order, four values: the average steps per allocation attempt, the average steps per deallocation, the final count of free blocks, and the final external fragmentation ratio, all in a single flat list and with real numbers rounded to $6$ decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass AddressOrderedAllocator:\n    def __init__(self, capacity: int):\n        # Free list: list of (start, size), sorted by start address\n        self.free_list = [(0, capacity)] if capacity > 0 else []\n        # Allocated blocks by handle -> (start, size)\n        self.allocated = {}\n        self.next_handle = 1\n\n    def alloc(self, size: int):\n        \"\"\"\n        First-fit allocation from address-ordered free list.\n        Returns (handle or None, steps).\n        Steps: 1 per visited free block.\n        \"\"\"\n        steps = 0\n        if size <= 0:\n            return None, steps  # Ignore nonsensical requests; no steps.\n\n        for idx, (start, fsize) in enumerate(self.free_list):\n            steps += 1  # visiting this free block\n            if fsize >= size:\n                handle = self.next_handle\n                self.next_handle += 1\n                # allocate from the start of this block\n                alloc_start = start\n                alloc_size = size\n                self.allocated[handle] = (alloc_start, alloc_size)\n                # adjust free block\n                if fsize == size:\n                    # remove the block\n                    del self.free_list[idx]\n                else:\n                    # shrink the block at the front\n                    self.free_list[idx] = (start + size, fsize - size)\n                return handle, steps\n\n        # No fitting block found\n        return None, steps\n\n    def free(self, handle: int):\n        \"\"\"\n        Free a previously allocated handle.\n        Returns steps.\n        Steps: 1 per move while finding insertion point,\n               +1 for predecessor-adjacency check (if predecessor exists),\n               +1 for successor-adjacency check (if successor exists).\n        \"\"\"\n        steps = 0\n        if handle not in self.allocated:\n            return steps  # no steps per the model (invalid free won't occur in tests)\n\n        start, size = self.allocated.pop(handle)\n\n        # Find insertion index to keep address order\n        i = 0\n        n = len(self.free_list)\n        # Advance while current free block starts before the new block's start\n        while i < n and self.free_list[i][0] < start:\n            steps += 1  # moving to next free block during search\n            i += 1\n\n        # Insert the new free block at index i\n        self.free_list.insert(i, (start, size))\n        # Coalesce with predecessor if adjacent\n        # Check predecessor adjacency if exists\n        if i - 1 >= 0 and len(self.free_list) >= 2:\n            steps += 1  # predecessor adjacency check\n            pred_start, pred_size = self.free_list[i - 1]\n            cur_start, cur_size = self.free_list[i]\n            if pred_start + pred_size == cur_start:\n                # Merge predecessor and current\n                merged = (pred_start, pred_size + cur_size)\n                # Replace predecessor with merged and remove current\n                self.free_list[i - 1] = merged\n                del self.free_list[i]\n                i = i - 1  # merged block now at i-1\n        else:\n            # If no predecessor, no check cost\n            pass\n\n        # Coalesce with successor if adjacent\n        if i + 1 < len(self.free_list):\n            steps += 1  # successor adjacency check\n            cur_start, cur_size = self.free_list[i]\n            succ_start, succ_size = self.free_list[i + 1]\n            if cur_start + cur_size == succ_start:\n                merged = (cur_start, cur_size + succ_size)\n                self.free_list[i] = merged\n                del self.free_list[i + 1]\n        else:\n            # If no successor, no check cost\n            pass\n\n        return steps\n\n    def external_fragmentation(self):\n        if not self.free_list:\n            return 0.0\n        total = sum(sz for _, sz in self.free_list)\n        if total == 0:\n            return 0.0\n        largest = max(sz for _, sz in self.free_list)\n        return 1.0 - (largest / total)\n\ndef run_scripted_test(capacity, ops):\n    \"\"\"\n    ops: list of tuples, ('A', size) or ('F', handle)\n    Allocation handles start at 1 and increment per successful allocation.\n    \"\"\"\n    alloc = AddressOrderedAllocator(capacity)\n    total_malloc_steps = 0\n    total_free_steps = 0\n    count_mallocs = 0\n    count_frees = 0\n\n    for op in ops:\n        if op[0] == 'A':\n            size = int(op[1])\n            handle, steps = alloc.alloc(size)\n            total_malloc_steps += steps\n            count_mallocs += 1\n            # If allocation succeeded, handle is recorded by allocator internally.\n            # Free operations refer to handle numbers as assigned in order,\n            # so scripted frees must match the created handles.\n        elif op[0] == 'F':\n            handle = int(op[1])\n            steps = alloc.free(handle)\n            total_free_steps += steps\n            count_frees += 1\n        else:\n            raise ValueError(\"Unknown operation\")\n\n    avg_malloc = (total_malloc_steps / count_mallocs) if count_mallocs > 0 else 0.0\n    avg_free = (total_free_steps / count_frees) if count_frees > 0 else 0.0\n    free_blocks = len(alloc.free_list)\n    frag = alloc.external_fragmentation()\n    return avg_malloc, avg_free, free_blocks, frag\n\ndef run_random_test(capacity, n_ops, p_alloc, size_low, size_high, seed):\n    \"\"\"\n    Generate operations using a PRNG with given seed.\n    - At each step: alloc with probability p_alloc, else free.\n    - If free but no live handles, force alloc.\n    - For alloc: size uniform integer in [size_low, size_high].\n    - For free: choose a live handle uniformly at random to free.\n    Count steps per the model for both alloc and free.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    alloc = AddressOrderedAllocator(capacity)\n    total_malloc_steps = 0\n    total_free_steps = 0\n    count_mallocs = 0\n    count_frees = 0\n\n    live_handles = []  # list of currently live handles\n\n    for _ in range(n_ops):\n        do_alloc = bool(rng.random() < p_alloc) or (len(live_handles) == 0)\n        if do_alloc:\n            size = int(rng.integers(size_low, size_high + 1))\n            handle, steps = alloc.alloc(size)\n            total_malloc_steps += steps\n            count_mallocs += 1\n            if handle is not None:\n                live_handles.append(handle)\n        else:\n            # Free: choose uniformly one live handle\n            idx = int(rng.integers(0, len(live_handles)))\n            handle = live_handles.pop(idx)\n            steps = alloc.free(handle)\n            total_free_steps += steps\n            count_frees += 1\n\n    avg_malloc = (total_malloc_steps / count_mallocs) if count_mallocs > 0 else 0.0\n    avg_free = (total_free_steps / count_frees) if count_frees > 0 else 0.0\n    free_blocks = len(alloc.free_list)\n    frag = alloc.external_fragmentation()\n    return avg_malloc, avg_free, free_blocks, frag\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: capacity 64, scripted operations\n        (\"scripted\", {\n            \"capacity\": 64,\n            \"ops\": [\n                ('A', 8), ('A', 8), ('A', 8), ('F', 2),\n                ('A', 4), ('A', 4), ('A', 16), ('F', 1),\n                ('F', 3), ('F', 4),\n            ]\n        }),\n        # Test 2: capacity 32, exact fit\n        (\"scripted\", {\n            \"capacity\": 32,\n            \"ops\": [\n                ('A', 32), ('F', 1),\n            ]\n        }),\n        # Test 3: fragmentation shaping\n        (\"scripted\", {\n            \"capacity\": 64,\n            \"ops\": [\n                ('A', 12), ('A', 12), ('A', 12), ('A', 12),\n                ('F', 2), ('F', 4), ('A', 10), ('A', 10),\n                ('F', 1), ('F', 3), ('A', 24),\n            ]\n        }),\n        # Test 4: adverse scan for first-fit\n        (\"scripted\", {\n            \"capacity\": 128,\n            \"ops\": [\n                ('A', 16), ('A', 16), ('A', 16), ('A', 16), ('A', 16), ('A', 16),\n                ('F', 2), ('F', 4), ('F', 6), ('A', 32),\n                ('F', 1), ('F', 3), ('F', 5), ('F', 7),\n            ]\n        }),\n        # Test 5: stochastic workload\n        (\"random\", {\n            \"capacity\": 256,\n            \"n_ops\": 200,\n            \"p_alloc\": 0.6,\n            \"size_low\": 1,\n            \"size_high\": 32,\n            \"seed\": 123456\n        }),\n    ]\n\n    results = []\n    for kind, params in test_cases:\n        if kind == \"scripted\":\n            avg_malloc, avg_free, free_blocks, frag = run_scripted_test(\n                params[\"capacity\"], params[\"ops\"]\n            )\n        elif kind == \"random\":\n            avg_malloc, avg_free, free_blocks, frag = run_random_test(\n                params[\"capacity\"], params[\"n_ops\"], params[\"p_alloc\"],\n                params[\"size_low\"], params[\"size_high\"], params[\"seed\"]\n            )\n        else:\n            raise ValueError(\"Unknown test kind\")\n\n        # Round real numbers to 6 decimals as strings; integers as-is\n        results.append(f\"{avg_malloc:.6f}\")\n        results.append(f\"{avg_free:.6f}\")\n        results.append(str(int(free_blocks)))\n        results.append(f\"{frag:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3239179"}, {"introduction": "Building upon the sequential search concept, this exercise explores the `next-fit` allocation strategy, a common variation of `first-fit` that uses a roving pointer to resume its search from where the previous allocation ended. While this can improve average allocation speed, it introduces a distinct performance characteristic related to memory fragmentation. Through this implementation, you will develop and use a precise metric to quantify the tendency of `next-fit` to leave small, unusable free blocks at the beginning of the heap, a classic trade-off in allocator design [@problem_id:3239067].", "problem": "Implement a complete, runnable program that simulates a next-fit heap allocator with a roving pointer and measures the fragmentation of the beginning of the heap. The simulation must adhere to the following formal model and rules.\n\nModel and fundamental base: The heap is a contiguous linear memory of size $H$ measured in abstract units. It is represented as an ordered partition of the interval $[0,H)$ into blocks, where each block has a start address $s$ and a length $\\ell$, with $s \\in \\mathbb{Z}_{\\ge 0}$, $\\ell \\in \\mathbb{Z}_{>0}$, and $s + \\ell \\le H$. Each block is either free or allocated. The allocator maintains a roving pointer $\\rho \\in [0,H]$ that marks the start address from which the next search for a free block begins. Initially, the heap consists of a single free block of length $H$ starting at $0$, and the roving pointer is set to $\\rho = 0$.\n\nAllocation rule (next-fit with splitting): Upon an allocation request of size $r \\in \\mathbb{Z}_{>0}$, the allocator searches blocks in increasing order of start address, beginning at the first block whose start address $s$ satisfies $s \\ge \\rho$, and wrapping to $s = 0$ after reaching the end. The first free block with length $\\ell \\ge r$ is selected. If such a block is found, it is split into two blocks: an allocated block of length $r$ beginning at its start address $s$, and, if $\\ell > r$, a free remainder block of length $\\ell - r$ beginning at address $s + r$. After a successful allocation, the roving pointer $\\rho$ is updated to the start address of the block immediately following the allocated portion: specifically, $\\rho \\leftarrow s + r$ if there is a free remainder block; otherwise, $\\rho$ becomes the start address of the next block in the heap order, wrapping to $0$ if the allocation consumed the final block. If no suitable free block exists, the allocation fails silently and leaves the heap unchanged.\n\nDeallocation rule (coalescing): Upon a deallocation of an allocated block identified by its unique identifier, the block becomes free. If its immediate predecessor or successor in memory order are free, the allocator coalesces all adjacent free blocks into a single free block by merging their intervals. The roving pointer $\\rho$ remains unchanged during deallocation.\n\nFragmentation metric of the beginning of the heap: For a given prefix length $P \\in \\mathbb{Z}_{\\ge 0}$, define the prefix interval $I_P = [0,P) \\cap [0,H)$. Let the set of free blocks after all operations be $\\{[s_i, s_i + \\ell_i)\\}_{i=1}^m$. For each free block, define its overlap with the prefix as $u_i(P) = \\max\\{0, \\min\\{s_i + \\ell_i, P\\} - \\max\\{s_i, 0\\}\\}$. The total free units in the prefix is\n$$\nS(P) = \\sum_{i=1}^m u_i(P).\n$$\nThe number of free fragments in the prefix is the count\n$$\nk(P) = \\left|\\left\\{ i \\in \\{1,\\dots,m\\} \\ \\middle| \\ u_i(P) > 0 \\right\\}\\right|.\n$$\nDefine the fragmentation index of the prefix as\n$$\nF(P) = \n\\begin{cases}\n\\dfrac{k(P)}{S(P)} & \\text{if } S(P) > 0, \\\\\n0 & \\text{if } S(P) = 0.\n\\end{cases}\n$$\nThis index is a unitless decimal quantity and must be reported as a decimal number, not as a percentage.\n\nProgram requirements: Implement the next-fit allocator with splitting and coalescing exactly as specified. Simulate each test case by applying a sequence of operations, then compute the fragmentation index $F(P)$ of the specified prefix $I_P$.\n\nTest suite: Your program must execute the following four test cases in order. Each operation is a tuple where the first component is either the string $\\text{\"alloc\"}$ with a size $r$ and identifier $\\text{id}$, or the string $\\text{\"free\"}$ with the identifier $\\text{id}$.\n\nTest case $1$:\n- Heap size $H = 64$.\n- Prefix length $P = 16$.\n- Operations in order:\n  $$(\\text{\"alloc\"}, 1, 16), (\\text{\"alloc\"}, 2, 24), (\\text{\"free\"}, 1), (\\text{\"alloc\"}, 3, 8), (\\text{\"alloc\"}, 4, 8), (\\text{\"alloc\"}, 5, 8), (\\text{\"alloc\"}, 6, 8), (\\text{\"alloc\"}, 7, 4), (\\text{\"free\"}, 6), (\\text{\"alloc\"}, 8, 2).$$\n\nTest case $2$ (boundary of zero-length prefix):\n- Heap size $H = 32$.\n- Prefix length $P = 0$.\n- Operations in order:\n  $$(\\text{\"alloc\"}, 1, 32), (\\text{\"free\"}, 1).$$\n\nTest case $3$ (happy path with wrapping and low prefix fragmentation due to coalescing):\n- Heap size $H = 64$.\n- Prefix length $P = 32$.\n- Operations in order:\n  $$(\\text{\"alloc\"}, 1, 32), (\\text{\"alloc\"}, 2, 16), (\\text{\"alloc\"}, 3, 8), (\\text{\"free\"}, 1), (\\text{\"alloc\"}, 4, 4), (\\text{\"alloc\"}, 5, 4), (\\text{\"alloc\"}, 6, 8), (\\text{\"free\"}, 6).$$\n\nTest case $4$ (edge case showing multiple small free fragments near the beginning due to next-fit bias and selective freeing):\n- Heap size $H = 40$.\n- Prefix length $P = 20$.\n- Operations in order:\n  $$(\\text{\"alloc\"}, 1, 10), (\\text{\"alloc\"}, 2, 10), (\\text{\"alloc\"}, 3, 10), (\\text{\"alloc\"}, 4, 10), (\\text{\"free\"}, 1), (\\text{\"alloc\"}, 5, 5), (\\text{\"alloc\"}, 6, 5), (\\text{\"free\"}, 2), (\\text{\"alloc\"}, 7, 4), (\\text{\"free\"}, 6).$$\n\nFinal output format: Your program should produce a single line of output containing the four fragmentation indices for the test cases, in order, as a comma-separated list enclosed in square brackets. For example, it should look like\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4],\n$$\nwhere each $\\text{result}_i$ is a decimal number corresponding to $F(P)$ for the $i$th test case. No other text should be printed.", "solution": "The problem statement has been validated and is deemed valid. It provides a self-contained, scientifically grounded, and well-posed description of a next-fit heap allocation simulation. The rules for allocation, deallocation, and the fragmentation metric are formally and unambiguously defined, permitting a unique and verifiable solution.\n\nThe solution will be implemented in Python by creating a class to model the heap allocator. The core of this model is a dynamic list of objects, each representing a block of memory.\n\n**1. Data Structures**\n\nThe heap is a contiguous memory space of size $H$. We can model its state by maintaining a list of blocks, sorted by their starting address. Each block must store its starting address $s$, its length $\\ell$, and its status (free or allocated). A unique identifier is also associated with each allocated block. A Python class, let's name it `` `Block` ``, is a suitable representation for this:\n- `` `start` ``: An integer representing the block's starting address, $s$.\n- `` `size` ``: A positive integer for the block's length, $\\ell$.\n- `` `is_free` ``: A boolean flag indicating if the block is free.\n- `` `id` ``: An identifier for the allocated block, or `None` if free.\n\nThe main `` `NextFitAllocator` `` class will manage the heap's overall state:\n- `` `H` ``: The total size of the heap.\n- `` `blocks` ``: A Python list of `Block` objects, always kept sorted by the `` `start` `` attribute. Initially, this list contains a single free block with `` `start` `` $=0$ and `` `size` `` $=H$.\n- `` `rho` ``: The roving pointer, $\\rho$, an integer storing the starting address for the next allocation search. It is initialized to $0$.\n- `` `allocated_map` ``: A dictionary mapping unique block identifiers (`` `id` ``) to their corresponding `Block` objects. This allows for $O(1)$ average-time lookup during deallocation requests.\n\n**2. Allocation Logic (`` `allocate` `` method)**\n\nThe allocation process for a request of size $r$ follows the next-fit strategy.\n\n- **Search Initiation**: The search begins from the position of the roving pointer $\\rho$. We first find the index of the first block in our sorted list whose start address $s$ is greater than or equal to $\\rho$. Let this be `` `start_idx` ``.\n- **Search Execution**: The search for a suitable free block proceeds from `` `start_idx` `` to the end of the `` `blocks` `` list. If no block is found, the search wraps around and continues from the beginning of the list up to `` `start_idx` `` - 1.\n- **Block Selection**: The first free block encountered with a size $\\ell \\ge r$ is selected for allocation.\n- **Splitting**: If the selected block's size $\\ell$ is strictly greater than the requested size $r$, the block is split. The original block is resized to $r$, marked as allocated, and assigned the given identifier. A new free block is created with start address $s+r$ and size $\\ell-r$, and inserted into the `` `blocks` `` list immediately after the newly allocated block to maintain the sorted order.\n- **Roving Pointer Update**:\n    - If the block was split, a new free block is created. The roving pointer $\\rho$ is updated to the start address of this new remainder block, i.e., $\\rho \\leftarrow s+r$.\n    - If the allocation was an exact fit ($\\ell=r$), the roving pointer $\\rho$ is moved to the start address of the next block in memory order. If the allocated block was the last one in the heap, $\\rho$ wraps around to $0$.\n- **Failure**: If the search completes without finding any suitable free block, the allocation request fails silently, and the heap state remains unchanged, as specified.\n\n**3. Deallocation Logic (`` `free` `` method)**\n\nDeallocation involves freeing a block and coalescing it with adjacent free blocks.\n\n- **Block Identification**: The block to be freed is located efficiently using the `` `allocated_map` `` and its given `` `id` ``.\n- **Freeing**: The block's `` `is_free` `` flag is set to `True`, and its `` `id` `` is set back to `None`.\n- **Coalescing**: To maintain a memory model with the largest possible contiguous free blocks, we must check for adjacent free neighbors.\n    1.  **Successor Coalescing**: The block immediately following the newly freed block in the `` `blocks` `` list (if one exists) is checked. If it is also free, it is merged into the current block. The current block's size is increased by the successor's size, and the successor block is removed from the list.\n    2.  **Predecessor Coalescing**: The block immediately preceding the newly freed block (if one exists) is checked. If it is also free, the current block is merged into its predecessor. The predecessor's size is increased by the current block's size, and the current block is removed from the list.\nThe order of operations is important; checking the successor before the predecessor simplifies index management. The roving pointer $\\rho$ is not affected by deallocation.\n\n**4. Fragmentation Metric Calculation (`` `calculate_fragmentation` `` method)**\n\nAfter all operations for a test case are complete, the fragmentation index $F(P)$ for a given prefix length $P$ is computed.\n\n- **Initialization**: Two accumulators are initialized: `` `S_P` `` (for total free units in the prefix, $S(P)$) to $0$, and `` `k_P` `` (for the number of free fragments in the prefix, $k(P)$) to $0$.\n- **Iteration**: The method iterates through all blocks in the final heap configuration.\n- **Overlap Calculation**: For each free block $[s_i, s_i + \\ell_i)$, its overlap $u_i(P)$ with the prefix interval $[0, P)$ is calculated using the formula $u_i(P) = \\max\\{0, \\min\\{s_i + \\ell_i, P\\} - \\max\\{s_i, 0\\}\\}$.\n- **Accumulation**: If the calculated overlap $u_i(P)$ is greater than $0$, it means the block contributes to the free space within the prefix. `` `S_P` `` is incremented by $u_i(P)$, and `` `k_P` `` is incremented by $1$.\n- **Final Calculation**: The fragmentation index $F(P)$ is computed as the ratio $k_P / S_P$. If `` `S_P` `` is $0$ (i.e., no free space in the prefix), $F(P)$ is defined to be $0$.\n\nThis structured approach ensures a correct and robust implementation that adheres precisely to the formal model provided in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Block:\n    \"\"\"Represents a block of memory in the heap.\"\"\"\n    def __init__(self, start, size, is_free=True, block_id=None):\n        self.start = start\n        self.size = size\n        self.is_free = is_free\n        self.id = block_id\n\n    def __repr__(self):\n        state = \"F\" if self.is_free else \"A\"\n        return f\"Block(s={self.start}, l={self.size}, {state}, id={self.id})\"\n\nclass NextFitAllocator:\n    \"\"\"Implements a next-fit heap allocator with a roving pointer.\"\"\"\n    def __init__(self, H):\n        self.H = H\n        self.blocks = [Block(0, H)]\n        self.rho = 0\n        self.allocated_map = {}\n\n    def allocate(self, req_id, req_size):\n        \"\"\"Allocates a block of memory using the next-fit algorithm.\"\"\"\n        start_idx = 0\n        for i, block in enumerate(self.blocks):\n            if block.start >= self.rho:\n                start_idx = i\n                break\n        \n        # Create a search order that wraps around\n        search_order = list(range(start_idx, len(self.blocks))) + list(range(0, start_idx))\n        \n        found_block_idx = -1\n        for i in search_order:\n            block = self.blocks[i]\n            if block.is_free and block.size >= req_size:\n                found_block_idx = i\n                break\n\n        if found_block_idx == -1:\n            return  # Silent failure\n\n        block_to_alloc = self.blocks[found_block_idx]\n        original_start = block_to_alloc.start\n        original_size = block_to_alloc.size\n\n        if original_size > req_size:\n            # Split the block\n            block_to_alloc.size = req_size\n            block_to_alloc.is_free = False\n            block_to_alloc.id = req_id\n            \n            new_free_block = Block(original_start + req_size, original_size - req_size)\n            self.blocks.insert(found_block_idx + 1, new_free_block)\n            \n            # Update rho to start of the new free remainder block\n            self.rho = new_free_block.start\n        else:  # Exact fit: original_size == req_size\n            block_to_alloc.is_free = False\n            block_to_alloc.id = req_id\n            \n            # Update rho to the start of the next block, wrapping if necessary\n            next_block_idx = (found_block_idx + 1) % len(self.blocks)\n            self.rho = self.blocks[next_block_idx].start\n        \n        self.allocated_map[req_id] = block_to_alloc\n\n    def free(self, req_id):\n        \"\"\"Frees an allocated block and coalesces with adjacent free blocks.\"\"\"\n        if req_id not in self.allocated_map:\n            return\n\n        block_to_free = self.allocated_map.pop(req_id)\n        block_to_free.is_free = True\n        block_to_free.id = None\n\n        try:\n            current_idx = self.blocks.index(block_to_free)\n        except ValueError:\n            return # Should not happen in a correct simulation\n\n        # 1. Coalesce with successor\n        if current_idx + 1 < len(self.blocks) and self.blocks[current_idx + 1].is_free:\n            successor = self.blocks[current_idx + 1]\n            block_to_free.size += successor.size\n            self.blocks.pop(current_idx + 1)\n\n        # 2. Coalesce with predecessor\n        if current_idx > 0 and self.blocks[current_idx - 1].is_free:\n            predecessor = self.blocks[current_idx - 1]\n            predecessor.size += block_to_free.size\n            self.blocks.pop(current_idx)\n\n    def calculate_fragmentation(self, P):\n        \"\"\"Calculates the fragmentation index F(P) for a given prefix length P.\"\"\"\n        total_free_units_in_prefix = 0\n        num_free_fragments_in_prefix = 0\n\n        for block in self.blocks:\n            if block.is_free:\n                # Calculate overlap: u_i(P) = max(0, min(s_i + l_i, P) - max(s_i, 0))\n                overlap_start = max(block.start, 0)\n                overlap_end = min(block.start + block.size, P)\n                \n                overlap_size = max(0, overlap_end - overlap_start)\n\n                if overlap_size > 0:\n                    total_free_units_in_prefix += overlap_size\n                    num_free_fragments_in_prefix += 1\n        \n        if total_free_units_in_prefix == 0:\n            return 0.0\n        \n        return num_free_fragments_in_prefix / total_free_units_in_prefix\n\ndef solve():\n    test_cases = [\n        {\n            \"H\": 64, \"P\": 16, \"ops\": [\n                (\"alloc\", 1, 16), (\"alloc\", 2, 24), (\"free\", 1), (\"alloc\", 3, 8),\n                (\"alloc\", 4, 8), (\"alloc\", 5, 8), (\"alloc\", 6, 8), (\"alloc\", 7, 4),\n                (\"free\", 6), (\"alloc\", 8, 2)\n            ]\n        },\n        {\n            \"H\": 32, \"P\": 0, \"ops\": [\n                (\"alloc\", 1, 32), (\"free\", 1)\n            ]\n        },\n        {\n            \"H\": 64, \"P\": 32, \"ops\": [\n                (\"alloc\", 1, 32), (\"alloc\", 2, 16), (\"alloc\", 3, 8), (\"free\", 1),\n                (\"alloc\", 4, 4), (\"alloc\", 5, 4), (\"alloc\", 6, 8), (\"free\", 6)\n            ]\n        },\n        {\n            \"H\": 40, \"P\": 20, \"ops\": [\n                (\"alloc\", 1, 10), (\"alloc\", 2, 10), (\"alloc\", 3, 10), (\"alloc\", 4, 10),\n                (\"free\", 1), (\"alloc\", 5, 5), (\"alloc\", 6, 5), (\"free\", 2),\n                (\"alloc\", 7, 4), (\"free\", 6)\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        allocator = NextFitAllocator(case[\"H\"])\n        for op in case[\"ops\"]:\n            if op[0] == \"alloc\":\n                allocator.allocate(req_id=op[1], req_size=op[2])\n            elif op[0] == \"free\":\n                allocator.free(req_id=op[1])\n        \n        result = allocator.calculate_fragmentation(case[\"P\"])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3239067"}, {"introduction": "This final practice moves beyond simple sequential-fit strategies to a more advanced and practical design: the segregated-fit allocator. You will implement a `buddy system`, a classic algorithm that manages memory in power-of-two size classes, each with its own free list. This structure allows for extremely fast splitting and coalescing of memory blocks using clever bitwise operations. This exercise will deepen your understanding of how structured memory management can significantly improve performance and mitigate fragmentation [@problem_id:3239041].", "problem": "You are to implement a segregated-fit heap allocator with separate free lists for object sizes that are powers of two. The allocator operates on pages of fixed size and uses the splitting and coalescing principles of the buddy system. The allocator must support allocation and deallocation of objects in a simulated heap and maintain free lists segregated by size class. All sizes are measured in bytes, and all reported quantities must be in bytes unless they are explicitly handles.\n\nFundamental base and core definitions:\n- Memory is modeled as a discrete address space segmented into pages of size $2^{12}$ bytes. Each page is identified by an integer page index and has byte offsets in $\\{0, 1, 2, \\dots, 2^{12}-1\\}$.\n- The allocator maintains disjoint free lists for size classes $C = \\{2^4, 2^5, \\dots, 2^{12}\\}$ bytes. Each free list for class $s \\in C$ contains free blocks of exactly $s$ bytes.\n- Requests are rounded up to the nearest power of two at least $2^4$, that is, given a requested size $n$, the allocator computes $r = 2^{\\lceil \\log_2(\\max(n, 2^4)) \\rceil}$ and enforces $r \\le 2^{12}$. A request $n$ with $n \\le 0$ or $n > 2^{12}$ must fail.\n- Allocation uses segregated-fit with splitting: If a free block of size $r$ exists, allocate it. If not, choose the smallest size $S \\in C$ with $S \\ge r$ for which a free block is available; split it repeatedly into halves until producing one block of size $r$. Specifically, splitting a block of size $S$ at offset $o$ produces two buddy blocks at offsets $o$ and $o + S/2$, each of size $S/2$. Reinsert the unused halves into their corresponding free lists.\n- Deallocation uses buddy coalescing: Given a block of size $s$ at offset $o$, its buddy is at offset $b = o \\oplus s$ (bitwise exclusive-or). If the buddy exists and is free in the same page, remove both from their free lists and combine them into a block of size $2s$ at offset $o' = o \\wedge \\neg s$ (bitwise and with the complement of $s$), then repeat upward until no free buddy exists or the page size $2^{12}$ is reached.\n- Handles: The allocator returns a handle $h = p \\cdot 2^{12} + o$ for a block allocated at page index $p$ and offset $o$. This uniquely identifies the allocation within the simulated heap. A failed allocation returns the sentinel $-1$.\n- Operations: Implement functions $\\mathrm{alloc}(n)$ and $\\mathrm{free}(h)$. The function $\\mathrm{alloc}(n)$ returns a handle $h$ or $-1$. The function $\\mathrm{free}(h)$ returns a boolean indicating success (true) or failure (false), where failure includes invalid handles, double free, or non-existent page references.\n\nScientific realism and constraints:\n- The allocator starts with no pages. It must create a new page (of size $2^{12}$ bytes) when necessary to satisfy allocation requests. Each newly created page contributes a single free block of size $2^{12}$ bytes to the largest free list.\n- The allocator must never allocate more than $2^{12}$ bytes in a single request; there is no mechanism for multi-block contiguous allocations.\n- The free list invariants must be preserved: every free block belongs to exactly one free list for its size class, and no block appears in multiple lists.\n\nTest suite:\nFor each test case, apply the operations specified and compute the required outputs. All sizes are in bytes. The following test cases must be implemented:\n\n- Test case $1$ (happy path, rounding to classes):\n  - Operations: $\\mathrm{alloc}(20)$, $\\mathrm{alloc}(30)$, $\\mathrm{alloc}(100)$, $\\mathrm{alloc}(2000)$.\n  - Output: The list of actual allocated class sizes for each request, i.e., the sizes of the blocks that were assigned for each allocation, in bytes. The expected sizes follow from rounding to powers of two no less than $2^4$.\n\n- Test case $2$ (splitting and full coalescing back to a page):\n  - Operations: $\\mathrm{alloc}(1000)$, $\\mathrm{alloc}(1000)$, then $\\mathrm{free}$ of the first handle, then $\\mathrm{free}$ of the second handle.\n  - Output: The integer count of free blocks of size $2^{12}$ left in the allocator. Given correct buddy coalescing, this should result in a single $2^{12}$-byte free block for the page used.\n\n- Test case $3$ (allocation failure beyond maximum class):\n  - Operations: $\\mathrm{alloc}(5000)$.\n  - Output: A boolean indicating whether the allocation failed (true for failure because $5000 > 2^{12}$).\n\n- Test case $4$ (multi-page creation under many small allocations):\n  - Operations: Perform $260$ allocations of $\\mathrm{alloc}(16)$.\n  - Output: The integer number of pages created by the allocator. Since each page of size $2^{12}$ can be split into $2^{12} / 2^4 = 256$ blocks of $16$ bytes, $260$ allocations force the creation of $2$ pages.\n\n- Test case $5$ (double free detection):\n  - Operations: $h \\leftarrow \\mathrm{alloc}(32)$, then $\\mathrm{free}(h)$, then $\\mathrm{free}(h)$ again.\n  - Output: A boolean indicating whether the second $\\mathrm{free}$ failed (true for failure).\n\n- Test case $6$ (invalid handle free detection):\n  - Operations: $\\mathrm{free}(123456)$ on a fresh allocator.\n  - Output: A boolean indicating whether the $\\mathrm{free}$ failed (true for failure).\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to a test case result in order: $[\\text{result}_1, \\text{result}_2, \\dots, \\text{result}_6]$. Entries may be integers, booleans, or lists of integers, as specified above. There must be no extra text before or after the line.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in the principles of memory management algorithms, specifically the buddy system. The problem is well-posed, with all necessary constants, algorithms, and boundary conditions clearly defined. It is objective and provides a set of formalizable and verifiable test cases.\n\nThe task is to implement a segregated-fit heap allocator based on the buddy system. Memory is managed in pages of size $2^{12}$ bytes. Allocation requests are rounded up to the nearest power of two, from a minimum of $2^4$ bytes to a maximum of $2^{12}$ bytes. The core of the allocator relies on two fundamental operations: splitting larger blocks to satisfy smaller requests and coalescing adjacent free \"buddy\" blocks to form larger blocks, thus mitigating external fragmentation.\n\nA class-based design will be employed to encapsulate the state and logic of the allocator.\n\n**1. Data Structures**\n\nThe allocator's state is managed by three primary data structures:\n\n- **Free Lists (`` `free_lists` ``)**: The allocator uses a segregated-fit strategy, which requires separate lists of free blocks for each size class. The size classes are powers of two, $C = \\{2^4, 2^5, \\dots, 2^{12}\\}$. A dictionary is a natural choice to implement this, mapping each size $s \\in C$ to a collection of handles for free blocks of that size. To ensure efficient buddy lookups during coalescing, the collection of handles for each size class will be a set, providing average $O(1)$ time complexity for insertion, deletion, and membership testing. A block is identified by its handle, an integer computed as $h = p \\cdot 2^{12} + o$, where $p$ is the page index and $o$ is the byte offset within the page.\n\n- **Allocated Blocks (`` `allocated_blocks` ``)**: A separate dictionary is required to track currently allocated blocks. This structure maps an allocated block's handle $h$ to its size $s$. This is crucial for the `` `free(h)` `` operation, which needs to know the size of the block being deallocated to find its buddy. This dictionary also serves as the authoritative record for validating handles and detecting attempts to free an already free block (a double free).\n\n- **Page Management (`` `next_page_idx` ``)**: The allocator begins with no memory pages. Pages are created on demand. A simple integer counter, `` `next_page_idx` ``, tracks the number of pages created, with the next new page having an index of `` `next_page_idx` ``. When a new page is created, `` `next_page_idx` `` is incremented, and a single free block of size $2^{12}$ is added to the corresponding free list.\n\n**2. Algorithm Design: Allocation `` `alloc(n)` ``**\n\nThe allocation process follows a sequence of well-defined steps:\n\n- **Request Validation and Sizing**: An incoming request for $n$ bytes is first validated. Requests for $n \\le 0$ or $n > 2^{12}$ are invalid and fail immediately. For valid requests, the size is rounded up to the nearest power of two, $r$, that is at least $2^4$. This is computed via the formula $r = 2^{\\lceil \\log_2(\\max(n, 2^4)) \\rceil}$. This can be implemented efficiently using `` `numpy.log2` `` and `` `numpy.ceil` ``.\n\n- **Block Search**: The allocator searches its `` `free_lists` `` for an available block. It starts by checking the free list for the exact required size $r$. If this list is non-empty, a block is taken from it. If not, the search proceeds to the next larger size classes ($2r, 4r, \\dots, 2^{12}$) until a non-empty free list is found.\n\n- **Page Provisioning**: If the search fails to find any free block large enough to satisfy the request (i.e., all free lists are empty or only contain blocks smaller than $r$), the allocator must provision a new page. A new page of size $2^{12}$ is created, and its corresponding block handle (at page `` `next_page_idx` ``, offset $0$) is added to the free list for size $2^{12}$. The search for a block to split then resumes, now guaranteed to succeed with this new full-page block.\n\n- **Splitting**: Once a block of size $S \\ge r$ is found and removed from its free list, it is split recursively if $S > r$. Splitting a block of size $S$ at offset $o$ yields two buddy blocks of size $S/2$: one at offset $o$ and its buddy at offset $o + S/2$. The buddy block is immediately added to the free list for size $S/2$. The first block (at offset $o$) is retained and the process repeats, halving its size until a block of the required size $r$ is obtained. This block is then allocated.\n\n- **Finalization**: The handle of the final $r$-sized block is recorded in the `` `allocated_blocks` `` map along with its size, and the handle is returned to the caller. A failed allocation returns $-1$.\n\n**3. Algorithm Design: Deallocation `` `free(h)` ``**\n\nDeallocation reverses the allocation process through coalescing:\n\n- **Handle Validation**: The first and most critical step is to validate the handle $h$. The function checks if $h$ exists as a key in the `` `allocated_blocks` `` map. If not, the handle is invalid (it was never allocated, or it has already been freed). In this case, the operation fails and returns `` `false` ``.\n\n- **Buddy Identification and Coalescing**: If the handle is valid, its size $s$ is retrieved. The block is removed from the `` `allocated_blocks` `` map. The core coalescing loop begins. For a block of size $s$ at offset $o$ within page $p$, its unique buddy of the same size is located at offset $o \\oplus s$ in the same page. The allocator checks if the buddy's handle exists in the free list for size $s$.\n  - If the buddy is free, it is removed from its free list. The two blocks are merged into a single block of size $2s$. The offset of this new parent block is given by $o' = o \\wedge \\neg s$, which effectively clears the bit corresponding to size $s$, yielding the base address of the aligned $2s$-sized block. The coalescing process is then repeated with this new, larger block.\n  - If the buddy is not free (i.e., it is allocated), coalescing stops.\n\n- **Finalization**: The loop terminates when either a buddy is found to be allocated or the block size reaches the page size $2^{12}$. The final resulting block (which may be the original block or a larger, coalesced one) is added to the appropriate free list. The function returns `` `true` `` to indicate success. This systematic coalescing is the buddy system's mechanism for combating external fragmentation by actively reconstructing larger free blocks.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass BuddyAllocator:\n    \"\"\"\n    Implements a segregated-fit heap allocator with a buddy system for splitting and coalescing.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initializes the allocator with no pages.\"\"\"\n        self.PAGE_SIZE = 2**12\n        self.MIN_ALLOC_SIZE = 2**4\n        self.MAX_ALLOC_SIZE = self.PAGE_SIZE\n\n        # Size classes are powers of two from MIN_ALLOC_SIZE to MAX_ALLOC_SIZE.\n        self.size_classes = [2**i for i in range(int(np.log2(self.MIN_ALLOC_SIZE)), int(np.log2(self.MAX_ALLOC_SIZE)) + 1)]\n\n        # Free lists: a dictionary mapping size class to a set of handles of free blocks.\n        self.free_lists = {s: set() for s in self.size_classes}\n\n        # Allocated blocks: a dictionary mapping handle to its size.\n        self.allocated_blocks = {}\n\n        # Page management.\n        self.next_page_idx = 0\n\n    def _get_handle(self, page_idx, offset):\n        \"\"\"Computes a handle from a page index and offset.\"\"\"\n        return page_idx * self.PAGE_SIZE + offset\n\n    def _parse_handle(self, handle):\n        \"\"\"Decomposes a handle into its page index and offset.\"\"\"\n        page_idx = handle // self.PAGE_SIZE\n        offset = handle % self.PAGE_SIZE\n        return page_idx, offset\n\n    def _calculate_rounded_size(self, n):\n        \"\"\"Rounds up a request size to the nearest valid power of two.\"\"\"\n        if not (0 < n <= self.MAX_ALLOC_SIZE):\n            return None\n        \n        req_size = max(n, self.MIN_ALLOC_SIZE)\n        \n        # Use numpy for direct implementation of the formula: 2^ceil(log2(size))\n        power = np.ceil(np.log2(req_size))\n        return 2**int(power)\n\n    def alloc(self, n):\n        \"\"\"Allocates a block of memory of size n.\"\"\"\n        rounded_size = self._calculate_rounded_size(n)\n        if rounded_size is None:\n            return -1\n\n        target_size = rounded_size\n        \n        # Find the smallest available block size that fits the request.\n        alloc_size = -1\n        for s in self.size_classes:\n            if s >= target_size and len(self.free_lists[s]) > 0:\n                alloc_size = s\n                break\n        \n        # If no block is available, create a new page.\n        if alloc_size == -1:\n            page_idx = self.next_page_idx\n            self.next_page_idx += 1\n            \n            new_block_handle = self._get_handle(page_idx, 0)\n            self.free_lists[self.MAX_ALLOC_SIZE].add(new_block_handle)\n            alloc_size = self.MAX_ALLOC_SIZE\n        \n        # Get a block from the selected free list.\n        block_handle = self.free_lists[alloc_size].pop()\n        current_page, current_offset = self._parse_handle(block_handle)\n        \n        # Split the block down to the required size.\n        current_size = alloc_size\n        while current_size > target_size:\n            current_size //= 2\n            buddy_offset = current_offset + current_size\n            buddy_handle = self._get_handle(current_page, buddy_offset)\n            self.free_lists[current_size].add(buddy_handle)\n            \n        # Allocate the final block.\n        final_handle = self._get_handle(current_page, current_offset)\n        self.allocated_blocks[final_handle] = target_size\n        return final_handle\n\n    def free(self, handle):\n        \"\"\"Frees a previously allocated block of memory.\"\"\"\n        # 1. Validate handle against the map of allocated blocks.\n        if handle not in self.allocated_blocks:\n            return False\n            \n        page_idx, offset = self._parse_handle(handle)\n        if page_idx >= self.next_page_idx:\n            return False\n\n        # 2. Retrieve size and remove from allocated map.\n        size = self.allocated_blocks.pop(handle)\n        \n        current_page = page_idx\n        current_offset = offset\n        current_size = size\n\n        # 3. Coalesce with buddy if buddy is free.\n        while current_size < self.MAX_ALLOC_SIZE:\n            buddy_offset = current_offset ^ current_size\n            buddy_handle = self._get_handle(current_page, buddy_offset)\n            \n            if buddy_handle in self.free_lists[current_size]:\n                self.free_lists[current_size].remove(buddy_handle)\n                current_offset = current_offset & (~current_size)\n                current_size *= 2\n            else:\n                break\n        \n        # 4. Add the final (possibly coalesced) block to the free list.\n        final_handle = self._get_handle(current_page, current_offset)\n        self.free_lists[current_size].add(final_handle)\n        \n        return True\n\ndef run_test_case_1():\n    allocator = BuddyAllocator()\n    requests = [20, 30, 100, 2000]\n    allocated_sizes = []\n    for req in requests:\n        handle = allocator.alloc(req)\n        if handle != -1:\n            allocated_sizes.append(allocator.allocated_blocks[handle])\n    return allocated_sizes\n\ndef run_test_case_2():\n    allocator = BuddyAllocator()\n    h1 = allocator.alloc(1000)\n    h2 = allocator.alloc(1000)\n    allocator.free(h1)\n    allocator.free(h2)\n    return len(allocator.free_lists[allocator.MAX_ALLOC_SIZE])\n\ndef run_test_case_3():\n    allocator = BuddyAllocator()\n    handle = allocator.alloc(5000)\n    return handle == -1\n\ndef run_test_case_4():\n    allocator = BuddyAllocator()\n    for _ in range(260):\n        allocator.alloc(16)\n    return allocator.next_page_idx\n\ndef run_test_case_5():\n    allocator = BuddyAllocator()\n    h = allocator.alloc(32)\n    allocator.free(h)\n    second_free_success = allocator.free(h)\n    return not second_free_success\n\ndef run_test_case_6():\n    allocator = BuddyAllocator()\n    free_success = allocator.free(123456)\n    return not free_success\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        run_test_case_1,\n        run_test_case_2,\n        run_test_case_3,\n        run_test_case_4,\n        run_test_case_5,\n        run_test_case_6,\n    ]\n\n    results = [test() for test in test_cases]\n\n    # The problem asks for the standard string representation of Python objects.\n    # str([1, 2]) -> '[1, 2]' (with space)\n    # str(True) -> 'True' (capitalized)\n    # The default behavior of map(str,...) is the most faithful interpretation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3239041"}]}