{"hands_on_practices": [{"introduction": "A memory allocator's primary job is to find a free block of memory that satisfies a request. This exercise explores two of the most fundamental strategies for this task: First-Fit and Best-Fit. By simulating these algorithms, you will gain hands-on experience with the trade-offs between decision-making speed and memory utilization, a core challenge in systems design [@problem_id:3251611].", "problem": "Consider a finite set of shelves represented by a sequence of nonnegative integer capacities $S = (s_1, s_2, \\dots, s_n)$ and a sequence of pallets represented by nonnegative integer sizes $P = (p_1, p_2, \\dots, p_m)$. Each shelf can hold at most one pallet. A pallet of size $p_j$ can be placed into a shelf of capacity $s_i$ if and only if $s_i \\ge p_j$. Once a pallet is placed into a shelf, that shelf becomes unavailable for any other pallet. The internal fragmentation incurred by placing a pallet $p_j$ into shelf $s_i$ is defined as $s_i - p_j$. The allocation fails for pallet $p_j$ if there is no available shelf with capacity at least $p_j$.\n\nTwo allocation strategies are to be compared:\n\n- First-fit: For each pallet $p_j$ in order $j = 1, 2, \\dots, m$, scan shelves in increasing index order $i = 1, 2, \\dots, n$ and place $p_j$ into the first available shelf with $s_i \\ge p_j$.\n- Best-fit: For each pallet $p_j$ in order $j = 1, 2, \\dots, m$, among all available shelves with $s_i \\ge p_j$, choose the shelf whose capacity $s_i$ is minimal; in case of a tie, choose the shelf with the smallest index.\n\nStarting from the core definitions of sequence processing and deterministic selection rules, and without assuming any pre-existing specialized formula, derive a programmatic simulation that, for each given test case, executes both strategies on the same inputs $(S, P)$ and reports the following integer metrics for each strategy:\n- The number of pallets successfully allocated, denoted $A$.\n- The number of allocation failures, denoted $F$.\n- The total internal fragmentation, denoted $W$, computed as $\\sum (s_i - p_j)$ over all allocated pairs under the strategy.\n\nYour program must implement both strategies exactly as defined, with the tie-breaking rule in best-fit selecting the smallest index when minimal capacities are equal. The final output must be a single line containing a comma-separated list enclosed in square brackets. For each test case, append the six integers in the order $[A_{\\text{FF}}, F_{\\text{FF}}, W_{\\text{FF}}, A_{\\text{BF}}, F_{\\text{BF}}, W_{\\text{BF}}]$, where the subscripts $\\text{FF}$ and $\\text{BF}$ denote first-fit and best-fit respectively. Concatenate the results across all test cases into one flat list, preserving test case order.\n\nUse the following test suite, designed to probe different aspects of allocation behavior:\n- Test case $1$: $S = [9,8,10]$, $P = [8,10,9]$ (difference between strategies due to shelf order and tie-breaking).\n- Test case $2$: $S = [5,5,5]$, $P = [5,5,5,5]$ (boundary with exact fits and more pallets than shelves).\n- Test case $3$: $S = [4,4]$, $P = [5,6]$ (all pallets too large).\n- Test case $4$: $S = [12,3]$, $P = []$ (empty pallet sequence).\n- Test case $5$: $S = [5,9,6]$, $P = [6,5,9]$ (difference between strategies due to future exact matches).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with integers in the precise order specified and no additional text.", "solution": "The problem statement has been validated and is deemed sound. It presents a well-defined simulation task rooted in fundamental concepts of computer science, specifically deterministic resource allocation algorithms. The problem is self-contained, logically consistent, and free of ambiguity.\n\nThe core of this problem is the simulation of two distinct memory allocation strategies, first-fit and best-fit, applied to a discrete set of resources (shelves) and requests (pallets). We will formally derive the steps for each simulation and then implement them to calculate the required performance metrics.\n\nLet the set of shelf capacities be represented by a sequence $S = (s_1, s_2, \\dots, s_n)$, where $n$ is the number of shelves and $s_i \\in \\mathbb{Z}_{\\ge 0}$ is the capacity of the $i$-th shelf. Let the set of pallet sizes be a sequence $P = (p_1, p_2, \\dots, p_m)$, where $m$ is the number of pallets and $p_j \\in \\mathbb{Z}_{\\ge 0}$ is the size of the $j$-th pallet.\n\nThe state of the system can be tracked by a boolean availability vector $U = (u_1, u_2, \\dots, u_n)$, where $u_i = 1$ if shelf $i$ is available and $u_i = 0$ if it is occupied. Initially, all shelves are available, so $u_i = 1$ for all $i \\in \\{1, 2, \\dots, n\\}$.\n\nFor each strategy, we will process the pallets in their given order, from $j=1$ to $m$. The metrics to be computed for each strategy are:\n- $A$: The total number of successfully allocated pallets.\n- $F$: The total number of allocation failures.\n- $W$: The total internal fragmentation, defined as the sum $W = \\sum (s_{i^*} - p_j)$ over all allocated pairs $(p_j, s_{i^*})$.\n\n**1. First-Fit (FF) Strategy**\n\nThe first-fit algorithm is a sequential search heuristic. For each pallet $p_j$, we scan the shelves from the first to the last and place the pallet in the first shelf that is large enough.\n\nThe algorithm proceeds as follows for each $j \\in \\{1, 2, \\dots, m\\}$:\n- Initialize a flag, `placed_j = false`.\n- Iterate through the shelves with index $i$ from $1$ to $n$.\n- At each shelf $i$, check for two conditions:\n    1. The shelf is available: $u_i = 1$.\n    2. The shelf has sufficient capacity: $s_i \\ge p_j$.\n- If both conditions are met, this is the first fit. We perform the allocation:\n    - Designate this shelf as the chosen one: $i^* = i$.\n    - Update the system state by marking the shelf as occupied: $u_{i^*} \\leftarrow 0$.\n    - Increment the allocated pallet count: $A \\leftarrow A + 1$.\n    - Add the resulting internal fragmentation to the total: $W \\leftarrow W + (s_{i^*} - p_j)$.\n    - Set `placed_j = true` and break the inner loop over $i$, proceeding to the next pallet $p_{j+1}$.\n- If the loop over all shelves $i$ completes and `placed_j` remains `false`, it signifies that no suitable shelf was found. The allocation for pallet $p_j$ fails.\n- Increment the failure count: $F \\leftarrow F + 1$.\n\nThis process is repeated for all pallets. The initial state for the simulation is $A=0$, $F=0$, $W=0$, and $u_i=1$ for all $i$.\n\n**2. Best-Fit (BF) Strategy**\n\nThe best-fit algorithm attempts to be more efficient in its use of space. For each pallet $p_j$, it searches all available shelves to find the one that fits the pallet most snugly, i.e., the one with the smallest capacity that is still large enough. This strategy aims to leave larger-capacity shelves available for potentially larger future pallets.\n\nThe algorithm proceeds as follows for each $j \\in \\{1, 2, \\dots, m\\}$:\n- Identify the set of all candidate shelves, $C_j$, that are both available and have sufficient capacity:\n$$ C_j = \\{ i \\in \\{1, \\dots, n\\} \\mid u_i = 1 \\land s_i \\ge p_j \\} $$\n- If this set $C_j$ is empty, no allocation is possible for pallet $p_j$.\n    - Increment the failure count: $F \\leftarrow F + 1$.\n- If $C_j$ is non-empty, a best-fit shelf must be chosen.\n    - First, find the minimum capacity among all candidate shelves:\n    $$ s_{\\min} = \\min_{i \\in C_j} \\{s_i\\} $$\n    - Next, identify the subset of candidates that have this minimum capacity, $B_j \\subseteq C_j$:\n    $$ B_j = \\{ i \\in C_j \\mid s_i = s_{\\min} \\} $$\n    - The problem provides a tie-breaking rule: if multiple shelves have the same minimal capacity $s_{\\min}$, the one with the smallest index is chosen.\n    $$ i^* = \\min_{i \\in B_j} \\{i\\} $$\n    - The pallet $p_j$ is allocated to shelf $s_{i^*}$.\n    - Update the system state: $u_{i^*} \\leftarrow 0$.\n    - Increment the allocated pallet count: $A \\leftarrow A + 1$.\n    - Add the fragmentation to the total: $W \\leftarrow W + (s_{i^*} - p_j)$.\n\nThis process is repeated for all pallets, starting from the same initial state ($A=0, F=0, W=0, u_i=1$) as the first-fit simulation.\n\n**Implementation Design**\n\nA programmatic solution will consist of two distinct functions, one for each strategy. Each function will take the shelf capacities $S$ and pallet sizes $P$ as input. Inside each function, an availability array corresponding to $U$ will be initialized. The function will then loop through the pallets, applying the respective logic to find a shelf or declare a failure, and update the metrics $A$, $F$, and $W$. Finally, the function will return these three metrics. The main program will execute these two functions for each test case and format the results as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef first_fit_strategy(shelves, pallets):\n    \"\"\"\n    Simulates the first-fit allocation strategy.\n\n    Args:\n        shelves (list): A list of nonnegative integer shelf capacities.\n        pallets (list): A list of nonnegative integer pallet sizes.\n\n    Returns:\n        tuple: A tuple containing (A, F, W) where A is the number of\n               allocations, F is the number of failures, and W is the\n               total internal fragmentation.\n    \"\"\"\n    num_shelves = len(shelves)\n    available_shelves = np.ones(num_shelves, dtype=bool)\n    \n    allocated_count = 0\n    failed_count = 0\n    total_fragmentation = 0\n\n    for pallet_size in pallets:\n        pallet_placed = False\n        for i in range(num_shelves):\n            if available_shelves[i] and shelves[i] >= pallet_size:\n                # Place the pallet in the first available-and-fitting shelf\n                available_shelves[i] = False\n                allocated_count += 1\n                total_fragmentation += shelves[i] - pallet_size\n                pallet_placed = True\n                break  # Move to the next pallet\n        \n        if not pallet_placed:\n            failed_count += 1\n            \n    return allocated_count, failed_count, total_fragmentation\n\ndef best_fit_strategy(shelves, pallets):\n    \"\"\"\n    Simulates the best-fit allocation strategy.\n\n    Args:\n        shelves (list): A list of nonnegative integer shelf capacities.\n        pallets (list): A list of nonnegative integer pallet sizes.\n\n    Returns:\n        tuple: A tuple containing (A, F, W) where A is the number of\n               allocations, F is the number of failures, and W is the\n               total internal fragmentation.\n    \"\"\"\n    num_shelves = len(shelves)\n    available_shelves = np.ones(num_shelves, dtype=bool)\n\n    allocated_count = 0\n    failed_count = 0\n    total_fragmentation = 0\n\n    for pallet_size in pallets:\n        best_shelf_index = -1\n        # Using a large number for initial minimum capacity\n        min_capacity = float('inf')\n\n        for i in range(num_shelves):\n            if available_shelves[i] and shelves[i] >= pallet_size:\n                # Found a potential shelf. Check if it's a better fit.\n                if shelves[i]  min_capacity:\n                    min_capacity = shelves[i]\n                    best_shelf_index = i\n        \n        if best_shelf_index != -1:\n            # A best-fit shelf was found, place the pallet\n            available_shelves[best_shelf_index] = False\n            allocated_count += 1\n            total_fragmentation += shelves[best_shelf_index] - pallet_size\n        else:\n            # No suitable shelf found\n            failed_count += 1\n\n    return allocated_count, failed_count, total_fragmentation\n\ndef solve():\n    \"\"\"\n    Runs the allocation simulations for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1: S = [9,8,10], P = [8,10,9]\n        ([9, 8, 10], [8, 10, 9]),\n        # Test case 2: S = [5,5,5], P = [5,5,5,5]\n        ([5, 5, 5], [5, 5, 5, 5]),\n        # Test case 3: S = [4,4], P = [5,6]\n        ([4, 4], [5, 6]),\n        # Test case 4: S = [12,3], P = []\n        ([12, 3], []),\n        # Test case 5: S = [5,9,6], P = [6,5,9]\n        ([5, 9, 6], [6, 5, 9]),\n    ]\n\n    all_results = []\n    for s_capacities, p_sizes in test_cases:\n        # Each strategy must run on a fresh set of shelves\n        shelves_copy = list(s_capacities)\n        pallets_copy = list(p_sizes)\n        \n        # Run first-fit\n        ff_results = first_fit_strategy(shelves_copy, pallets_copy)\n        all_results.extend(ff_results)\n        \n        # Run best-fit\n        bf_results = best_fit_strategy(shelves_copy, pallets_copy)\n        all_results.extend(bf_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3251611"}, {"introduction": "Real-world allocators use sophisticated strategies to manage memory efficiently. This practice moves beyond simple search heuristics to quantitatively analyze the overhead of two popular designs: the Buddy System and Segregated Free Lists. You will calculate how different block sizing policies lead to varying amounts of internal fragmentation and total memory waste, providing a deeper understanding of allocator performance [@problem_id:3251579].", "problem": "You are tasked with implementing a self-contained program that quantifies and compares total memory overhead due to allocator metadata versus internal fragmentation for two allocation strategies: the buddy system and a segregated free list. The program must use the parameter sets provided in the test suite and produce results with no user input. The comparison must be grounded in core definitions from memory management and alignment rules, not ad hoc formulas.\n\nBegin from the following fundamental base and core definitions:\n- In dynamic memory allocators, each allocated block carries allocator metadata. Let the per-block allocator header be $h$ bytes. For a request of $r$ bytes of payload, the allocator must supply a block of total size $s$ bytes on the heap. The metadata overhead is the sum over all allocated blocks of $h$; the internal fragmentation is the sum over all allocated blocks of $s - h - r$, which is the unused payload-able space within the block after accounting for the header.\n- The buddy system returns blocks whose sizes are powers of two. Concretely, the block size must be the smallest power of two that is not less than the demand for total size, subject to a minimum block size constraint. If the smallest power of two less than the demand is too small to fit $r + h$, the next larger power of two is chosen. Let the minimum buddy block size be $B_{\\min}$ bytes.\n- A segregated free list (SFL) allocator returns blocks according to predefined size classes (bins). In this problem, bins are uniform multiples of a quantum. Let the quantum be $q$ bytes, and the allowable bin sizes range from $L_{\\min}$ up to $L_{\\max}$, inclusive. The SFL selected block size is the smallest bin size in that range that is not less than the demand for total size.\n\nYour program must implement both allocation strategies as follows for each allocation request $r$ in a given test case:\n- Compute the buddy-system block size $s_{\\mathrm{buddy}}$ as the smallest power of two greater than or equal to $\\max(r + h, B_{\\min})$. Then compute the per-request internal fragmentation $f_{\\mathrm{buddy}} = s_{\\mathrm{buddy}} - h - r$. Metadata overhead per request is $h$.\n- Compute the SFL block size $s_{\\mathrm{SFL}}$ as the smallest multiple of $q$ in the closed interval $\\left[L_{\\min}, L_{\\max}\\right]$ that is greater than or equal to $\\max(r + h, L_{\\min})$. Then compute the per-request internal fragmentation $f_{\\mathrm{SFL}} = s_{\\mathrm{SFL}} - h - r$. Metadata overhead per request is $h$.\n\nFor each allocator in each test case:\n- Total metadata overhead is $\\sum h$ over all requests.\n- Total internal fragmentation overhead is $\\sum f$ over all requests.\n- Total overhead is the sum of metadata overhead and internal fragmentation overhead.\n- Validate capacity feasibility: the total allocated heap footprint is the sum of the chosen block sizes $\\sum s$. This sum must not exceed the test case memory capacity $M$. All provided test cases satisfy feasibility; no special handling for infeasible cases is required.\n\nUnits: Report all overheads in bytes.\n\nYour program must process the following test suite. Each test case specifies $(M, B_{\\min}, h, q, L_{\\min}, L_{\\max}, R)$, where $R$ is the list of requested payload sizes in bytes.\n\n- Test case $1$ (general mixed sizes):\n  - $M = 1024$\n  - $B_{\\min} = 16$\n  - $h = 8$\n  - $q = 16$\n  - $L_{\\min} = 16$\n  - $L_{\\max} = 256$\n  - $R = [13, 24, 7, 100, 33]$\n- Test case $2$ (boundary alignment near powers of two):\n  - $M = 2048$\n  - $B_{\\min} = 32$\n  - $h = 16$\n  - $q = 16$\n  - $L_{\\min} = 32$\n  - $L_{\\max} = 1024$\n  - $R = [32, 63, 64, 127, 128]$\n- Test case $3$ (requests below minimum block):\n  - $M = 512$\n  - $B_{\\min} = 64$\n  - $h = 8$\n  - $q = 32$\n  - $L_{\\min} = 64$\n  - $L_{\\max} = 256$\n  - $R = [1, 2, 3]$\n- Test case $4$ (near capacity with repeated large requests):\n  - $M = 4096$\n  - $B_{\\min} = 16$\n  - $h = 16$\n  - $q = 32$\n  - $L_{\\min} = 32$\n  - $L_{\\max} = 2048$\n  - $R = [1000, 1000, 1000]$\n\nFinal output format specification:\n- For each test case, compute six integers in bytes in the exact order: buddy total overhead, buddy metadata overhead, buddy internal fragmentation overhead, SFL total overhead, SFL metadata overhead, SFL internal fragmentation overhead.\n- Aggregate the results of all test cases into a single line containing a comma-separated list enclosed in square brackets. The list is flattened by concatenating the six integers from test case $1$, then test case $2$, then test case $3$, then test case $4$. For example, the output must look like $[x_{1,1},x_{1,2},x_{1,3},x_{1,4},x_{1,5},x_{1,6},x_{2,1},\\dots,x_{4,6}]$, where each $x_{i,j}$ is an integer in bytes.", "solution": "The problem is to quantify and compare memory overhead for two dynamic memory allocation strategies: the buddy system and a segregated free list (SFL). The analysis is based on fundamental definitions of allocator metadata and internal fragmentation.\n\nFirst, we establish the formal definitions provided. Let `$r$` be the requested payload size in bytes. The allocator adds a metadata header of size `$h$` bytes to each block. The total size demanded from the heap for a single request is `$d = r + h$`. The allocator provides a block of size `$s \\ge d$`. The overhead for this block is composed of two parts:\n1.  Metadata Overhead: The fixed size of the header, `$h$`.\n2.  Internal Fragmentation: The unused space within the allocated block, given by `$f = s - d = s - (r + h)$`.\n\nThe total overheads for a sequence of requests are the sums of these individual components. For a set of `$N$` requests, the total metadata overhead is `$O_{meta} = \\sum_{i=1}^{N} h_i = N \\cdot h$`, and the total internal fragmentation is `$O_{frag} = \\sum_{i=1}^{N} f_i$`. The total memory overhead is `$O_{total} = O_{meta} + O_{frag}$`.\n\nThe core of the problem lies in determining the allocated block size `$s$` for each strategy.\n\n**Buddy System Allocation**\nThe buddy system allocates blocks whose sizes are powers of $2$. For a given request `$r$`, the allocator must find a block large enough to hold the payload plus the header, `$r+h$`. The chosen block size, `$s_{\\mathrm{buddy}}$`, must also be at least the system's minimum block size, `$B_{\\min}$`. Therefore, the effective demand is `$d_{\\mathrm{eff}} = \\max(r + h, B_{\\min})$`. The allocated block size is the smallest power of $2$ that is greater than or equal to `$d_{\\mathrm{eff}}$`. This can be expressed mathematically as:\n$$s_{\\mathrm{buddy}} = 2^{\\lceil \\log_2(d_{\\mathrm{eff}}) \\rceil}$$\nThe logarithm base $2$ finds the exact (possibly fractional) exponent required to produce `$d_{\\mathrm{eff}}$`. The ceiling function, `$\\lceil \\cdot \\rceil$`, rounds this exponent up to the nearest integer, which guarantees that when used as a power of $2$, the result `$s_{\\mathrm{buddy}}$` is the smallest power of $2$ that satisfies `$s_{\\mathrm{buddy}} \\ge d_{\\mathrm{eff}}$`.\n\n**Segregated Free List (SFL) Allocation**\nThe SFL allocator uses a set of predefined block sizes (bins), which are multiples of a quantum, `$q$`, within a given range `$[L_{\\min}, L_{\\max}]$`. Similar to the buddy system, the allocation must satisfy the demand `$r+h$` and the minimum block size `$L_{\\min}$`. The effective demand is thus `$d_{\\mathrm{eff}} = \\max(r + h, L_{\\min})$`. The allocated block size, `$s_{\\mathrm{SFL}}$`, is the smallest multiple of `$q$` that is greater than or equal to `$d_{\\mathrm{eff}}$` (and within the `$[L_{\\min}, L_{\\max}]$` range, which is guaranteed for the provided test cases). This size can be calculated as:\n$$s_{\\mathrm{SFL}} = q \\cdot \\lceil d_{\\mathrm{eff}} / q \\rceil$$\nDividing `$d_{\\mathrm{eff}}$` by the quantum `$q$` determines how many quanta are needed. The ceiling function rounds this requirement up to the next whole number of quanta. Multiplying by `$q$` gives the final block size. In integer arithmetic, this is efficiently computed as `$s_{\\mathrm{SFL}} = ((d_{\\mathrm{eff}} + q - 1) / q) \\cdot q$`, where the division is integer division.\n\n**Algorithmic Procedure**\nFor each test case, specified by the parameters `$(M, B_{\\min}, h, q, L_{\\min}, L_{\\max}, R)$`, we perform the following calculations:\n1.  Initialize total internal fragmentation accumulators for both systems to zero: `$O_{\\mathrm{frag, buddy}} = 0$` and `$O_{\\mathrm{frag, SFL}} = 0$`.\n2.  The total metadata overhead is constant for both systems and is calculated once: `$O_{\\mathrm{meta}} = \\text{length}(R) \\cdot h$`.\n3.  Iterate through each request size `$r$` in the list `$R$`:\n    a.  For the buddy system, calculate `$d_{\\mathrm{eff, buddy}} = \\max(r + h, B_{\\min})$` and find the corresponding block size `$s_{\\mathrm{buddy}}}$` using the power-of-two rule. The internal fragmentation for this request is `$f_{\\mathrm{buddy}} = s_{\\mathrm{buddy}} - (r+h)$`. Add this value to `$O_{\\mathrm{frag, buddy}}$`.\n    b.  For the SFL system, calculate `$d_{\\mathrm{eff, SFL}} = \\max(r + h, L_{\\min})$` and find the block size `$s_{\\mathrm{SFL}}}$` using the multiple-of-quantum rule. The internal fragmentation is `$f_{\\mathrm{SFL}} = s_{\\mathrm{SFL}} - (r+h)$`. Add this value to `$O_{\\mathrm{frag, SFL}}$`.\n4.  After iterating through all requests, calculate the total overhead for each system:\n    - `$O_{\\mathrm{total, buddy}} = O_{\\mathrm{meta}} + O_{\\mathrm{frag, buddy}}$`\n    - `$O_{\\mathrm{total, SFL}} = O_{\\mathrm{meta}} + O_{\\mathrm{frag, SFL}}$`\n5.  Assemble the six required integer values for the test case in the specified order: buddy total overhead, buddy metadata overhead, buddy internal fragmentation overhead, SFL total overhead, SFL metadata overhead, and SFL internal fragmentation overhead. The results from all test cases are then concatenated into a single list for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates and compares memory overhead for Buddy System and Segregated Free List\n    allocators based on a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (M, B_min, h, q, L_min, L_max, R) where R is a list of requests.\n    test_cases = [\n        (1024, 16, 8, 16, 16, 256, [13, 24, 7, 100, 33]),\n        (2048, 32, 16, 16, 32, 1024, [32, 63, 64, 127, 128]),\n        (512, 64, 8, 32, 64, 256, [1, 2, 3]),\n        (4096, 16, 16, 32, 32, 2048, [1000, 1000, 1000]),\n    ]\n\n    all_results = []\n\n    for M, B_min, h, q, L_min, L_max, R in test_cases:\n        \n        # --- Buddy System Calculation ---\n        buddy_total_frag = 0\n        for r in R:\n            # Total size needed for payload and header\n            demand = r + h\n            # Apply the minimum block size constraint from the buddy system rules\n            effective_demand = max(demand, B_min)\n            # Find the smallest power of two that is >= effective_demand\n            # s_buddy = 2^(ceil(log2(effective_demand)))\n            s_buddy = int(2**np.ceil(np.log2(effective_demand)))\n            # Internal fragmentation is the unused space within the allocated block\n            frag_buddy = s_buddy - demand\n            buddy_total_frag += frag_buddy\n            \n        buddy_total_meta = len(R) * h\n        buddy_total_overhead = buddy_total_meta + buddy_total_frag\n\n        # --- Segregated Free List (SFL) Calculation ---\n        sfl_total_frag = 0\n        for r in R:\n            # Total size needed for payload and header\n            demand = r + h\n            # Apply the minimum block size constraint from the SFL rules\n            effective_demand = max(demand, L_min)\n            # Find the smallest multiple of the quantum q that is >= effective_demand\n            # This is equivalent to q * ceil(effective_demand / q)\n            s_sfl = ((effective_demand + q - 1) // q) * q\n            # Internal fragmentation is the unused space\n            frag_sfl = s_sfl - demand\n            sfl_total_frag += frag_sfl\n\n        sfl_total_meta = len(R) * h\n        sfl_total_overhead = sfl_total_meta + sfl_total_frag\n        \n        # Assemble the 6 result values for the current test case\n        case_results = [\n            buddy_total_overhead, buddy_total_meta, buddy_total_frag,\n            sfl_total_overhead, sfl_total_meta, sfl_total_frag\n        ]\n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3251579"}, {"introduction": "The memory management lifecycle extends beyond allocation to include deallocation, a phase where dangerous bugs like \"use-after-free\" can arise. This exercise puts you in the role of a systems developer building a debugging tool to catch such errors. By implementing an allocator that \"poisons\" freed memory, you will see firsthand how a fundamental understanding of the heap state can be leveraged to detect and prevent critical software vulnerabilities [@problem_id:3239152].", "problem": "You are asked to design and implement a deterministic simulator of heap memory allocation with a use-after-free detector that poisons freed memory with a specific bit pattern and checks this poison on subsequent allocations. The simulator must model a contiguous heap of bytes, a sequence of variable-size allocations, frees, and writes, and it must report whether a use-after-free was detected at the moment a freed block is reused. The detector works by writing a fixed repeating poison pattern into the contents of a block when it is freed and later verifying that the pattern is still intact when the block is reused. If any byte in a reused block differs from what the poison dictates, a use-after-free is flagged.\n\nStart from a fundamental base consistent with data structures and algorithms. Model memory as a finite array with random access: a heap $\\mathcal{H}$ is a finite array of bytes of length $C$, indexed from $0$ to $C-1$. An allocator manages a set of blocks, each represented by a tuple $(b_s, b_n, b_a)$, where $b_s$ is the starting index, $b_n$ is the block size in bytes, and $b_a$ is a boolean indicating whether the block is currently allocated. A first-fit allocator that reuses freed blocks with exactly matching size is considered: when allocating $n$ bytes, if there exists a free block with $b_n = n$, reuse the first one found by increasing start address; otherwise, create a new block at the end of the currently used heap region if sufficient capacity remains. When freeing a block, write a poison pattern $P$ into its contents, repeated cyclically across $b_n$ bytes. Define the poison pattern as $P[0] = \\text{0xDE}$, $P[1] = \\text{0xAD}$, $P[2] = \\text{0xBE}$, $P[3] = \\text{0xEF}$ and let its length be $L = 4$ bytes.\n\nA use-after-free bug is the event that memory belonging to a block after it has been freed is written to by a stale reference, violating the allocator’s safety constraints. The detector verifies the invariant upon reuse: when an allocation request of size $n$ reuses a previously freed block $(b_s, n, \\text{false})$, compute\n$$\n\\mathsf{UAF} = \\neg \\left( \\forall i \\in \\{0,1,\\dots,n-1\\},\\; \\mathcal{H}[b_s + i] = P[i \\bmod L] \\right).\n$$\nIf $\\mathsf{UAF}$ is true, the simulator records that a use-after-free was detected for that allocation operation; otherwise it records false. Allocations that create new blocks at the heap’s tail do not trigger the check (they are always recorded as false), since they do not reuse freed memory.\n\nImplement a complete program that constructs such a simulator and executes the test suite described below. There is no external input; the program must print exactly one line as output, containing the results for each test case in a comma-separated list enclosed in square brackets, with boolean values produced by the program’s logic. For example, a valid output format is $[\\text{True},\\text{False},\\text{True}]$.\n\nTest Suite:\nEach test case initializes a heap of capacity $C = 64$ bytes and runs a sequence of operations. An operation can be “allocate $n$ bytes,” “free handle $h$,” or “write value $v$ at offset $o$ within handle $h$,” where all offsets and sizes are non-negative integers and values are byte values in the range $0$ to $255$. The “write” operation is permitted on both allocated and freed blocks to simulate stale writes; it overwrites the corresponding byte in $\\mathcal{H}$. The reported result for each test case is the boolean value $\\mathsf{UAF}$ recorded for the final allocation operation executed in that test case.\n\n- Test Case $1$:\n  - Allocate $n = 16$ bytes, producing handle $h_1$.\n  - Free $h_1$.\n  - Allocate $n = 16$ bytes again; report the detector’s boolean for this allocation as the test case result.\n\n- Test Case $2$:\n  - Allocate $n = 8$ bytes, producing handle $h_1$.\n  - Free $h_1$.\n  - Write value $v = \\text{0x00}$ at offset $o = 2$ within handle $h_1$ (this is a stale write).\n  - Allocate $n = 8$ bytes again; report the detector’s boolean for this allocation as the test case result.\n\n- Test Case $3$ (boundary condition across the entire heap):\n  - Allocate $n = 64$ bytes, producing handle $h_1$.\n  - Free $h_1$.\n  - Write value $v = \\text{0x11}$ at offset $o = 63$ within handle $h_1$ (last byte).\n  - Allocate $n = 64$ bytes again; report the detector’s boolean for this allocation as the test case result.\n\n- Test Case $4$ (size mismatch followed by exact reuse):\n  - Allocate $n = 12$ bytes, producing handle $h_1$.\n  - Free $h_1$.\n  - Write value $v = \\text{0x22}$ at offset $o = 5$ within handle $h_1$ (stale write).\n  - Allocate $n = 8$ bytes (new block at heap tail because no exact free block of size $8$ exists; detector records false internally, but this is not the final result).\n  - Allocate $n = 12$ bytes (this reuses $h_1$); report the detector’s boolean for this allocation as the test case result.\n\nYour program must implement the described simulator and execute these four test cases in order. Your program should produce a single line of output containing the four results in the form $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$, where each $\\text{result}_i$ is a boolean produced by the simulator for the final allocation operation of the corresponding test case, with no spaces in the output line.", "solution": "The problem requires the design and implementation of a deterministic heap memory allocation simulator. This simulator must incorporate a specific mechanism for detecting use-after-free (UAF) memory corruption. We begin by formalizing the components of the system as described.\n\nThe heap, denoted $\\mathcal{H}$, is modeled as a contiguous block of memory, which can be represented by a zero-indexed array of bytes. The capacity of the heap is given as $C = 64$ bytes. The state of the heap is managed by an allocator.\n\nThe allocator maintains a list of memory blocks. Each block is characterized by a tuple $(b_s, b_n, b_a)$, where $b_s$ is the starting index (address) of the block within $\\mathcal{H}$, $b_n$ is its size in bytes, and $b_a$ is a boolean flag indicating its allocation status (`true` for allocated, `false` for free). A \"handle\" serves as a unique identifier for a block, which we can implement as its index in the allocator's list of blocks. A variable, let's call it $H_{top}$, tracks the end of the utilized portion of the heap, initialized to $0$.\n\nThe operations are defined as follows:\n\n1.  **Allocation**: A request to allocate $n$ bytes triggers the following \"first-fit with exact size match\" policy:\n    *   The allocator scans its list of blocks in order of increasing starting address $b_s$. It searches for the first block that is currently free ($b_a = \\text{false}$) and has an exact size match ($b_n = n$).\n    *   **Reuse Path**: If such a block $(b_s, n, \\text{false})$ is found, it is reused. Before marking it as allocated, the UAF detector performs its check.\n        *   The detector verifies the integrity of the poison pattern written when the block was freed. The check is defined by the formula:\n            $$\n            \\mathsf{UAF} = \\neg \\left( \\forall i \\in \\{0, 1, \\dots, n-1\\},\\; \\mathcal{H}[b_s + i] = P[i \\bmod L] \\right)\n            $$\n            where the poison pattern is $P = \\{\\text{0xDE}, \\text{0xAD}, \\text{0xBE}, \\text{0xEF}\\}$ with length $L = 4$. If the condition inside the parentheses is false (meaning at least one byte does not match the expected poison value), $\\mathsf{UAF}$ evaluates to `true`, indicating a use-after-free was detected. Otherwise, $\\mathsf{UAF}$ is `false`.\n        *   The block's status is then updated to allocated ($b_a = \\text{true}$). The $\\mathsf{UAF}$ boolean is recorded for this operation.\n    *   **New Allocation Path**: If no suitable free block is found, the allocator attempts to create a new block at the end of the heap.\n        *   It checks if there is sufficient capacity: $H_{top} + n \\le C$.\n        *   If so, a new block $(H_{top}, n, \\text{true})$ is created and added to the allocator's list. $H_{top}$ is then updated to $H_{top} + n$.\n        *   For new allocations, there is no reuse, so the UAF check is not performed. The recorded result for this operation is defined to be `false`.\n\n2.  **Free**: When a block identified by handle $h$ is freed, the corresponding block's status is set to free ($b_a = \\text{false}$). Subsequently, its memory region within $\\mathcal{H}$ must be \"poisoned.\" For each byte index $i$ from $0$ to $b_n-1$, the value $P[i \\pmod L]$ is written to the memory location $\\mathcal{H}[b_s + i]$.\n\n3.  **Write**: A write operation to a block $h$ at offset $o$ with value $v$ directly modifies the heap array: $\\mathcal{H}[b_s + o] \\leftarrow v$. This operation is permitted regardless of the block's allocation status, thereby simulating a \"stale write\" to a freed block, which is the cause of a use-after-free bug.\n\nWe now trace the execution for each test case to determine the expected results. Each test case begins with an empty heap of capacity $C=64$ and an empty block list.\n\n**Test Case 1:**\n1.  `allocate 16`: No free blocks exist. A new block $h_1$ is created: $(b_s=0, b_n=16, b_a=\\text{true})$. $H_{top}$ becomes $16$. The recorded UAF status is `false`.\n2.  `free h_1`: Block $h_1$ is marked as free. The memory region $\\mathcal{H}[0 \\dots 15]$ is poisoned with the repeating pattern `0xDE, 0xAD, 0xBE, 0xEF, ...`.\n3.  `allocate 16`: The allocator finds the free block $h_1$ (exact size match). The UAF detector checks $\\mathcal{H}[0 \\dots 15]$. Since no stale writes have occurred, every byte matches the poison pattern. The condition $\\forall i, \\mathcal{H}[i] = P[i \\pmod 4]$ is true. Therefore, $\\mathsf{UAF} = \\neg(\\text{true}) = \\text{false}$.\n    *   **Result 1**: `False`\n\n**Test Case 2:**\n1.  `allocate 8`: A new block $h_1$ is created: $(b_s=0, b_n=8, b_a=\\text{true})$. $H_{top}$ becomes $8$. UAF is `false`.\n2.  `free h_1`: Block $h_1$ is marked as free. $\\mathcal{H}[0 \\dots 7]$ is poisoned with `0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF`.\n3.  `write v=0x00 at o=2 in h_1`: This is a stale write. It modifies memory at address $b_s+o = 0+2=2$. So, $\\mathcal{H}[2]$ becomes `0x00`. The expected poison value was $P[2 \\pmod 4] = P[2] = \\text{0xBE}$.\n4.  `allocate 8`: The allocator finds and reuses free block $h_1$. The UAF detector checks $\\mathcal{H}[0 \\dots 7]$. At index $i=2$, it finds $\\mathcal{H}[2] = \\text{0x00}$, but expects $P[2] = \\text{0xBE}$. The condition $\\forall i, \\dots$ is false. Therefore, $\\mathsf{UAF} = \\neg(\\text{false}) = \\text{true}$.\n    *   **Result 2**: `True`\n\n**Test Case 3:**\n1.  `allocate 64`: A new block $h_1$ is created: $(b_s=0, b_n=64, b_a=\\text{true})$. $H_{top}$ becomes $64$. UAF is `false`.\n2.  `free h_1`: Block $h_1$ is marked free. The entire heap $\\mathcal{H}[0 \\dots 63]$ is poisoned.\n3.  `write v=0x11 at o=63 in h_1`: A stale write modifies $\\mathcal{H}[63]$ to `0x11`. The expected poison value was $P[63 \\pmod 4] = P[3] = \\text{0xEF}$.\n4.  `allocate 64`: The allocator reuses $h_1$. During the check, at index $i=63$, it finds $\\mathcal{H}[63] = \\text{0x11}$, which is not equal to the expected $P[3] = \\text{0xEF}$. The condition $\\forall i, \\dots$ is false. Therefore, $\\mathsf{UAF} = \\neg(\\text{false}) = \\text{true}$.\n    *   **Result 3**: `True`\n\n**Test Case 4:**\n1.  `allocate 12`: A new block $h_1$ is created: $(b_s=0, b_n=12, b_a=\\text{true})$. $H_{top}$ becomes $12$. UAF is `false`.\n2.  `free h_1`: Block $h_1$ is marked free and its memory region $\\mathcal{H}[0 \\dots 11]$ is poisoned.\n3.  `write v=0x22 at o=5 in h_1`: A stale write modifies $\\mathcal{H}[5]$ to `0x22`. The expected poison value was $P[5 \\pmod 4] = P[1] = \\text{0xAD}$.\n4.  `allocate 8`: The allocator searches for a free block of size $8$. It finds $h_1$, which has size $12$, so there is no exact match. It proceeds to the new allocation path. A new block $h_2$ is created: $(b_s=12, b_n=8, b_a=\\text{true})$. $H_{top}$ becomes $12+8=20$. The UAF result for this operation is `false`, but it is not the final operation.\n5.  `allocate 12`: The allocator searches for a free block of size $12$. It finds $h_1$, which is an exact match. The UAF detector checks $\\mathcal{H}[0 \\dots 11]$. At index $i=5$, it compares $\\mathcal{H}[5] = \\text{0x22}$ to the expected $P[1] = \\text{0xAD}$. They are not equal. The condition $\\forall i, \\dots$ is false. Therefore, $\\mathsf{UAF} = \\neg(\\text{false}) = \\text{true}$.\n    *   **Result 4**: `True`\n\nThe final expected results for the four test cases are `[False, True, True, True]`. The implementation will follow this logic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Block:\n    \"\"\"Represents a block of memory in the heap.\"\"\"\n    def __init__(self, start_idx, size, is_allocated):\n        self.start_idx = start_idx\n        self.size = size\n        self.is_allocated = is_allocated\n\nclass HeapSimulator:\n    \"\"\"\n    Simulates heap memory allocation with a use-after-free detector.\n    \"\"\"\n    def __init__(self, capacity):\n        self._capacity = capacity\n        # Define the poison pattern as specified in the problem.\n        self._poison_pattern = np.array([0xDE, 0xAD, 0xBE, 0xEF], dtype=np.uint8)\n        self._poison_len = len(self._poison_pattern)\n        # Initialize the heap state for each new simulation.\n        self.reset()\n\n    def reset(self):\n        \"\"\"Resets the simulator to its initial state.\"\"\"\n        self._heap = np.zeros(self._capacity, dtype=np.uint8)\n        self._blocks = []\n        self._heap_top = 0\n\n    def allocate(self, n):\n        \"\"\"\n        Allocates a block of size n, returning a handle and a UAF detection flag.\n        \"\"\"\n        # First-fit with exact size match policy\n        for i, block in enumerate(self._blocks):\n            if not block.is_allocated and block.size == n:\n                # Reuse path: found a suitable free block\n                uaf_detected = self._check_poison(block.start_idx, block.size)\n                block.is_allocated = True\n                handle = i\n                return handle, uaf_detected\n        \n        # New allocation path: no suitable free block found\n        if self._heap_top + n = self._capacity:\n            start_idx = self._heap_top\n            new_block = Block(start_idx, n, is_allocated=True)\n            self._blocks.append(new_block)\n            self._heap_top += n\n            handle = len(self._blocks) - 1\n            # UAF check is not performed for new blocks, result is False by definition\n            uaf_detected = False\n            return handle, uaf_detected\n        else:\n            # Out of memory case (not expected in test suite)\n            raise MemoryError(f\"Failed to allocate {n} bytes.\")\n\n    def free(self, handle):\n        \"\"\"Frees the block associated with the given handle and poisons it.\"\"\"\n        if handle  0 or handle >= len(self._blocks):\n            raise ValueError(\"Invalid handle.\")\n        \n        block = self._blocks[handle]\n        if not block.is_allocated:\n            # Freeing an already-freed block might indicate a bug, but problem spec doesn't say to handle it.\n            return\n            \n        block.is_allocated = False\n        self._poison_memory(block.start_idx, block.size)\n\n    def write(self, handle, offset, value):\n        \"\"\"Writes a byte value to a given offset within a block.\"\"\"\n        if handle  0 or handle >= len(self._blocks):\n            raise ValueError(\"Invalid handle.\")\n            \n        block = self._blocks[handle]\n        if offset  0 or offset >= block.size:\n            raise IndexError(\"Write offset is out of bounds for the block.\")\n\n        address = block.start_idx + offset\n        self._heap[address] = value\n\n    def _poison_memory(self, start_idx, size):\n        \"\"\"Writes the poison pattern into a region of the heap.\"\"\"\n        for i in range(size):\n            self._heap[start_idx + i] = self._poison_pattern[i % self._poison_len]\n\n    def _check_poison(self, start_idx, size):\n        \"\"\"\n        Checks if a memory region matches the poison pattern.\n        Returns True if a mismatch (UAF) is found, False otherwise.\n        \"\"\"\n        for i in range(size):\n            if self._heap[start_idx + i] != self._poison_pattern[i % self._poison_len]:\n                # Mismatch found. The universal quantifier is false.\n                # UAF = not(False) = True.\n                return True\n        # No mismatch found. The universal quantifier is true.\n        # UAF = not(True) = False.\n        return False\n\ndef solve():\n    \"\"\"\n    Executes the test suite and prints the final results.\n    \"\"\"\n    C = 64\n    all_results = []\n\n    # --- Test Case 1 ---\n    sim = HeapSimulator(C)\n    h1, _ = sim.allocate(16)\n    sim.free(h1)\n    _, final_uaf_result = sim.allocate(16)\n    all_results.append(final_uaf_result)\n\n    # --- Test Case 2 ---\n    sim.reset()\n    h1, _ = sim.allocate(8)\n    sim.free(h1)\n    sim.write(h1, offset=2, value=0x00)\n    _, final_uaf_result = sim.allocate(8)\n    all_results.append(final_uaf_result)\n\n    # --- Test Case 3 ---\n    sim.reset()\n    h1, _ = sim.allocate(64)\n    sim.free(h1)\n    sim.write(h1, offset=63, value=0x11)\n    _, final_uaf_result = sim.allocate(64)\n    all_results.append(final_uaf_result)\n\n    # --- Test Case 4 ---\n    sim.reset()\n    h1, _ = sim.allocate(12)\n    sim.free(h1)\n    sim.write(h1, offset=5, value=0x22)\n    # This allocation is not the final one for the test case's result\n    sim.allocate(8) \n    # This is the final allocation, its result is the one we report\n    _, final_uaf_result = sim.allocate(12)\n    all_results.append(final_uaf_result)\n\n    # Format and print the final output exactly as required.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3239152"}]}