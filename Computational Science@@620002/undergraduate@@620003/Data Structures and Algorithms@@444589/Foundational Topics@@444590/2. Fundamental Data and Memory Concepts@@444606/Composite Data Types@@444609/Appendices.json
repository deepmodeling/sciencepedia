{"hands_on_practices": [{"introduction": "This first practice delves into the memory layout of data at the bit level, challenging you to perform a common low-level optimization known as pointer tagging. By taking advantage of memory alignment guarantees—a fundamental property in many system architectures—you can pack multiple pieces of information into a single machine word. This exercise will sharpen your bitwise manipulation skills and reveal how high-performance systems make every bit count [@problem_id:3223001].", "problem": "You are asked to design a composite data type representation that packs a memory pointer and three independent boolean flags into a single $64$-bit word. The context is a $64$-bit system where dynamic memory allocation guarantees that any heap pointer is aligned to $8$ bytes. Alignment to $8$ bytes means that the pointer value $p$ is always divisible by $8$, equivalently $p \\bmod 8 = 0$, so the least significant three bits are zero.\n\nFundamental base and definitions to use:\n- Binary integers occupy a fixed-width bit-vector representation; a $64$-bit word represents integers in the range $[0,2^{64}-1]$.\n- Bitwise logic follows well-tested rules: bitwise and, bitwise or, bitwise exclusive-or, and bit shifts operate per bit position. In particular, if two sets of bits occupy disjoint positions, their bitwise or aggregates them without interference.\n- Memory alignment to $2^{a}$ bytes implies that the lowest $a$ bits of any aligned address are zero.\n- Boolean values can be represented as bits where $0$ encodes logical false and $1$ encodes logical true.\n\nTask:\n1. Construct an encoding function that, given an aligned pointer $p$ and a triple of boolean flags $(b_0,b_1,b_2)$, produces a single $64$-bit word $w$ that stores both without loss of information.\n2. Construct a decoding function that, given $w$, recovers the original pointer $p$ and the flags $(b_0,b_1,b_2)$ exactly.\n3. Prove, using only the alignment guarantee and the properties of bitwise operations, that your encoding and decoding are inverses on the valid domain. You must ensure that the pointer bits and flag bits do not interfere.\n4. If the input pointer $p$ is not aligned to $8$ bytes, the encoding must signal an invalid case. For the purpose of this program, return the integer $-1$ for such cases.\n\nDomain and constraints:\n- Treat pointers as unsigned integers with $p \\in \\{0,8,16,\\dots,2^{61}-8\\}$, which ensures there is room for three lowest bits to store flags while keeping the result within a $64$-bit word.\n- Use only integer and bitwise operations; do not rely on floating-point or string manipulation to perform the packing and unpacking.\n\nTest suite:\nImplement your solution and run it on the following parameter sets, each consisting of a pointer $p$ and flags $(b_0,b_1,b_2)$:\n- Case A (general case): $p = 4096$, $(b_0,b_1,b_2) = (1,0,1)$.\n- Case B (all flags false, zero pointer): $p = 0$, $(b_0,b_1,b_2) = (0,0,0)$.\n- Case C (all flags true, high pointer): $p = 2^{60}$, $(b_0,b_1,b_2) = (1,1,1)$.\n- Case D (boundary pointer near the maximum representable under the domain): $p = 2^{61} - 8$, $(b_0,b_1,b_2) = (1,0,0)$.\n- Case E (invalid unaligned pointer): $p = 12345$, $(b_0,b_1,b_2) = (1,1,0)$.\n\nRequired output format:\n- For each case, output a single integer: the packed $64$-bit word $w$ for valid cases and $-1$ for invalid cases.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC,resultD,resultE]\").\n- No physical units are involved in this problem.", "solution": "The problem requires the design of a composite data type that packs a $64$-bit memory pointer $p$ and three boolean flags $(b_0, b_1, b_2)$ into a single $64$-bit word. The fundamental principle that enables this is the explicit guarantee that any such pointer $p$ is aligned to $8$ bytes.\n\nA memory address, or pointer value, $p$ being aligned to $8$ bytes implies that $p$ is an integer multiple of $8$. Mathematically, this is expressed as $p \\equiv 0 \\pmod{8}$. In the binary number system, any integer multiple of $8 = 2^3$ must have its three least significant bits (LSBs), corresponding to positions $0$, $1$, and $2$, equal to zero. These three bits are therefore available for storage without interfering with the pointer's value, as the alignment property ensures they are predictable. We can leverage these \"free\" bits to store the three boolean flags.\n\n### Encoding Function\nThe encoding function, let's call it $\\text{encode}(p, (b_0, b_1, b_2))$, takes as input a pointer $p$ (represented as a $64$-bit unsigned integer) and a triple of boolean flags. It produces a single $64$-bit word $w$.\n\nFirst, the function must validate the input pointer $p$. The alignment is a critical precondition. The check is performed by verifying that $p$ is a multiple of $8$. This can be computed arithmetically as $p \\pmod{8} = 0$, or more efficiently using bitwise operations as $p \\ \\& \\ 7 = 0$. If the pointer is not aligned, it is considered an invalid input, and the function must return the integer value $-1$ as specified by the problem.\n\nIf the pointer is valid, the encoding proceeds. The boolean flags $(b_0, b_1, b_2)$ are represented by integers $f_0, f_1, f_2 \\in \\{0, 1\\}$. We establish a direct mapping where flag $b_i$ is stored in bit position $i$. These flags are combined into a single $3$-bit integer, denoted $\\text{flags\\_val}$, which lies in the range $[0, 7]$:\n$$\n\\text{flags\\_val} = (f_2 \\ll 2) \\ | \\ (f_1 \\ll 1) \\ | \\ f_0\n$$\nThis expression is equivalent to the arithmetic sum $4f_2 + 2f_1 + f_0$.\n\nSince the three LSBs of a valid pointer $p$ are guaranteed to be zero, we can merge $p$ and $\\text{flags\\_val}$ using a bitwise OR operation. This places the flag bits into the zeroed LSBs of the pointer's binary representation without disturbing any of the more significant bits that define the pointer's value. The final encoded word $w$ is:\n$$\nw = p \\ | \\ \\text{flags\\_val}\n$$\n\n### Decoding Function\nThe decoding function, $\\text{decode}(w)$, performs the inverse operation. It takes a $64$-bit word $w$ created by our encoding scheme and recovers the original pointer $p$ and the three flags $(b_0, b_1, b_2)$.\n\nTo recover the original pointer $p$, we must clear the three LSBs of $w$, which now hold the flag data. This is achieved by performing a bitwise AND operation between $w$ and a mask where the three LSBs are $0$ and all other bits are $1$. This mask is the bitwise complement of $7$ (i.e., $\\sim 7$), which corresponds to the $64$-bit hexadecimal value $0xFFFFFFFFFFFFFFF8$.\n$$\np_{\\text{recovered}} = w \\ \\& \\ (\\sim 7)\n$$\nThis operation zeroes out bits $0$, $1$, and $2$, restoring the pointer to its original aligned value.\n\nTo recover the flags, we must isolate each of the three LSBs from the word $w$:\n- The integer value for flag $b_0$, $f_0$, is stored in bit $0$ of $w$:\n  $$\n  f_0 = w \\ \\& \\ 1\n  $$\n- The value for flag $b_1$, $f_1$, is in bit $1$. We isolate it and normalize it by right-shifting:\n  $$\n  f_1 = (w \\ \\& \\ 2) \\gg 1\n  $$\n- The value for flag $b_2$, $f_2$, is in bit $2$:\n  $$\n  f_2 = (w \\ \\& \\ 4) \\gg 2\n  $$\nThese operations successfully extract the individual flag values as either $0$ or $1$.\n\n### Proof of Correctness\nWe will now prove that for any valid pointer $p$ and any set of flags $(f_0, f_1, f_2)$, the decoding process perfectly inverts the encoding. Let $w = \\text{encode}(p, (f_0, f_1, f_2))$ and $(p', (f'_0, f'_1, f'_2)) = \\text{decode}(w)$. We must show that $p' = p$ and $f'_i = f_i$ for $i \\in \\{0, 1, 2\\}$.\n\n1.  **Premises**:\n    - The input pointer $p$ is aligned to $8$ bytes, meaning $p \\bmod 8 = 0$. Its binary representation must end in three zeros: $p = (p_{63} \\dots p_3 000)_2$.\n    - The flags are combined into an integer $f_{\\text{val}} = 4f_2 + 2f_1 + f_0$. Its binary representation has bits $3$ through $63$ as zero: $f_{\\text{val}} = (0 \\dots 0 f_2 f_1 f_0)_2$.\n\n2.  **Encoding Analysis**:\n    The encoded word $w$ is calculated as $w = p \\ | \\ f_{\\text{val}}$.\n    $$\n    w = (p_{63} \\dots p_3 000)_2 \\ | \\ (0 \\dots 0 f_2 f_1 f_0)_2 = (p_{63} \\dots p_3 f_2 f_1 f_0)_2\n    $$\n    Because the bit positions being set by $f_{\\text{val}}$ (bits $0, 1, 2$) are guaranteed to be clear in $p$, the bitwise OR operations simply fill in these bits. The upper $61$ bits of $w$ are identical to the upper $61$ bits of $p$, and the lower $3$ bits of $w$ hold the flag values.\n\n3.  **Decoding Analysis**:\n    - **Pointer Recovery**: The recovered pointer $p'$ is computed as $p' = w \\ \\& \\ (\\sim 7)$. The mask $(\\sim 7)$ has a binary representation of $(1 \\dots 1000)_2$.\n      $$\n      p' = (p_{63} \\dots p_3 f_2 f_1 f_0)_2 \\ \\& \\ (1 \\dots 11111000)_2 = (p_{63} \\dots p_3 000)_2\n      $$\n      This result is bit-for-bit identical to the original pointer $p$. Thus, $p' = p$.\n\n    - **Flag Recovery**: The recovered flags $f'_0, f'_1, f'_2$ are extracted as follows:\n      $$\n      f'_0 = (w \\ \\& \\ 1) = ((p_{63} \\dots f_0)_2 \\ \\& \\ (0 \\dots 001)_2) = (0 \\dots 0 f_0)_2 = f_0\n      $$\n      $$\n      f'_1 = ((w \\ \\& \\ 2) \\gg 1) = (((p_{63} \\dots f_0)_2 \\ \\& \\ (0 \\dots 010)_2) \\gg 1) = ((0 \\dots f_1 0)_2 \\gg 1) = (0 \\dots 0 f_1)_2 = f_1\n      $$\n      $$\n      f'_2 = ((w \\ \\& \\ 4) \\gg 2) = (((p_{63} \\dots f_0)_2 \\ \\& \\ (0 \\dots 100)_2) \\gg 2) = ((0 \\dots f_2 00)_2 \\gg 2) = (0 \\dots 0 f_2)_2 = f_2\n      $$\n      The recovered flags $(f'_0, f'_1, f'_2)$ are identical to the original flags $(f_0, f_1, f_2)$.\n\n**Conclusion**: The defined encoding and decoding functions are lossless inverses for the specified domain of valid inputs. This system of pointer tagging is correct and robust, relying solely on the guaranteed memory alignment and the fundamental properties of bitwise logic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pointer packing problem for the given test suite.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: p = 4096, (b0,b1,b2) = (1,0,1)\n        (4096, (1, 0, 1)),\n        # Case B: p = 0, (b0,b1,b2) = (0,0,0)\n        (0, (0, 0, 0)),\n        # Case C: p = 2^60, (b0,b1,b2) = (1,1,1)\n        (2**60, (1, 1, 1)),\n        # Case D: p = 2^61 - 8, (b0,b1,b2) = (1,0,0)\n        (2**61 - 8, (1, 0, 0)),\n        # Case E: p = 12345, (b0,b1,b2) = (1,1,0)\n        (12345, (1, 1, 0)),\n    ]\n\n    def encode(p, flags):\n        \"\"\"\n        Packs a memory pointer and three boolean flags into a single 64-bit word.\n        \n        Args:\n            p (int): The pointer value, treated as an unsigned integer.\n            flags (tuple): A tuple of three integers (0 or 1) representing (b0, b1, b2).\n            \n        Returns:\n            int: The packed 64-bit word, or -1 if the pointer is not aligned.\n        \"\"\"\n        # A pointer is aligned to 8 bytes if its value is divisible by 8.\n        # This can be checked efficiently using the modulo operator or bitwise AND.\n        # p % 8 == 0 is equivalent to (p & 7) == 0.\n        if p % 8 != 0:\n            return -1\n        \n        # Unpack the flag tuple. The problem uses (b0, b1, b2), so we map\n        # b0 to bit 0, b1 to bit 1, and b2 to bit 2.\n        b0, b1, b2 = flags\n        \n        # Combine the boolean flags (represented as 0 or 1) into a single\n        # integer value where each flag corresponds to a bit position.\n        flags_val = (b2 << 2) | (b1 << 1) | b0\n        \n        # Since the 3 least significant bits of an aligned pointer are zero,\n        # we can use a bitwise OR to merge the pointer and the flags without\n        # corrupting the pointer's original value.\n        return p | flags_val\n\n    results = []\n    for p, flags in test_cases:\n        result = encode(p, flags)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3223001"}, {"introduction": "Moving from single-word optimization to managing larger collections, this exercise asks you to model a dynamic array from first principles. You will use a `struct` to bundle metadata, such as $length$ and $capacity$, with a data payload, effectively creating a self-contained, resizable data structure. This practice demystifies how fundamental structures like C++'s `std::vector` work under the hood and provides hands-on experience with memory management and amortized analysis [@problem_id:3223151].", "problem": "Design and analyze a composite data type that models a C dynamic array with a flexible array member. Consider a C definition that uses a structure with a flexible array member to store a resizable sequence of bytes: a structure with two header fields and a trailing array of elements, specifically, a header containing two fields of type $size\\_t$ (each of size $8$ bytes) named $length$ and $capacity$, and a flexible array member of type $char$ named $data[]$. The total size of an allocation is the sum of the header and the number of data bytes. In this model, one element occupies $1$ byte. Therefore, the header has a constant size of $16$ bytes and an allocation for $capacity$ elements occupies $16 + capacity$ bytes. The dynamic array is an instance of a composite data type because it aggregates multiple fields and an array into a single logical entity. The task is to simulate manual memory management and resizing rules, and calculate quantitative metrics about the resulting memory operations.\n\nStart from the following fundamental base:\n- The definition of an array and structure composition in memory: contiguous layout with a header followed by an array makes a single composite memory block.\n- A sequence of operations updates the logical length of the array via insertions and deletions, while $capacity$ determines the size of the allocated block.\n- Copying cost during reallocation measures the amount of data moved when the array grows or shrinks.\n\nYou must implement the following behavior rules precisely:\n- Initialization: The array is created with an initial $capacity$ of $c\\_0 \\ge 1$, $length = 0$, and a single initial allocation of $16 + c\\_0$ bytes.\n- Push operation of $n$ elements: Perform $n$ single-element insertions. For each single insertion, if $length = capacity$, grow the array by doubling capacity, that is, set $capacity \\leftarrow 2 \\cdot capacity$, and perform a reallocation. A reallocation incurs a copying cost equal to the number of elements currently stored, which is $length$ bytes. After any necessary growth, append one element, increasing $length$ by $1$.\n- Pop operation of $n$ elements: Perform $n$ single-element deletions with the following rule. For each single deletion, if $length > 0$, decrement $length$ by $1$ and then, while $capacity > 1$ and $length \\le \\left\\lfloor \\frac{capacity}{4} \\right\\rfloor$, shrink by halving capacity, that is, set $capacity \\leftarrow \\left\\lfloor \\frac{capacity}{2} \\right\\rfloor$. Each shrink incurs a reallocation and a copying cost equal to the current $length$ in bytes. If $length = 0$, the pop does nothing and no shrink is triggered. Capacity never falls below $1$.\n- Reallocation counting: Count a reallocation event whenever $capacity$ changes due to growth or shrink. The initial allocation at creation is not counted as a reallocation event.\n- Copying cost: Accumulate the total number of bytes copied across all reallocation events during the lifetime of the array.\n- Current memory: At the end of processing a test case, the currently allocated bytes equal $16 + capacity$.\n\nFrom these rules, compute for each test case:\n- Final logical length $L$.\n- Final capacity $C$.\n- Number of reallocations $R$.\n- Total bytes copied during reallocations $K$.\n- Amortized copy cost per push $A$, defined as $A = \\frac{K}{N\\_{\\text{push}}}$ where $N\\_{\\text{push}}$ is the total number of single-element push operations executed in the test case. If $N\\_{\\text{push}} = 0$, define $A = 0$.\n- Final currently allocated bytes $M = 16 + C$.\n\nAll quantities $L$, $C$, $R$, $K$, and $M$ are integers measured in bytes where applicable; $A$ is a real number and must be expressed as a decimal rounded to $6$ places. No physical units beyond bytes are involved in this problem. Angles are not involved. Percentages are not involved.\n\nTest suite:\nUse the following parameter sets, each described by an initial capacity and an ordered sequence of operations, where “$+$” denotes a push of the given cardinality and “$-$” denotes a pop of the given cardinality. Each push or pop cardinality applies to single-element operations repeated that many times.\n- Case $1$: Initial capacity $c\\_0 = 4$. Operations: $+10$, $-3$, $+5$.\n- Case $2$: Initial capacity $c\\_0 = 1$. Operations: $-5$, $+1$, $-1$.\n- Case $3$: Initial capacity $c\\_0 = 3$. Operations: $+7$, $-4$, $+2$, $-1$, $-1$.\n- Case $4$: Initial capacity $c\\_0 = 8$. Operations: $-2$, $-2$, $-2$, $-2$.\n- Case $5$: Initial capacity $c\\_0 = 2$. Operations: $+100$, $-60$, $+20$.\n\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, with each test case’s result encoded as a list in the order $[L,C,R,K,A,M]$. For example, the overall format is $[[L\\_1,C\\_1,R\\_1,K\\_1,A\\_1,M\\_1],[L\\_2,C\\_2,R\\_2,K\\_2,A\\_2,M\\_2],\\dots]$ with no spaces.", "solution": "The problem statement is evaluated to be **valid**. It is self-contained, scientifically grounded in the principles of data structures and algorithms, and mathematically well-posed. The rules for the dynamic array simulation are unambiguous and can be formalized into a deterministic algorithm. We will proceed with a detailed analysis and solution.\n\nThe problem requires us to simulate a dynamic array, a composite data type, whose memory is manually managed according to specific rules for growth and shrinkage. We must track several key metrics throughout a sequence of push and pop operations. The state of the array at any point is characterized by its logical length, denoted as $length$, and its allocated capacity, denoted as $capacity$. We will also track the total number of reallocations $R$, the total bytes copied $K$, and the total number of push operations $N_{\\text{push}}$.\n\nThe header of the data structure has a fixed size of $16$ bytes. An element is of type $char$ and occupies $1$ byte. The total memory allocated for an array with capacity $C$ is $M = 16 + C$ bytes.\n\nThe rules for modifying the array state are as follows:\n- **Initialization**: Given an initial capacity $c_0$, the state is initialized as $length \\leftarrow 0$, $capacity \\leftarrow c_0$, $R \\leftarrow 0$, $K \\leftarrow 0$, and $N_{\\text{push}} \\leftarrow 0$. The initial memory allocation is not counted as a reallocation event.\n- **Single Push Operation**:\n    1. Increment the total push count: $N_{\\text{push}} \\leftarrow N_{\\text{push}} + 1$.\n    2. Check for growth: If $length = capacity$, a reallocation is triggered.\n        - The capacity is doubled: $capacity \\leftarrow 2 \\cdot capacity$.\n        - The number of reallocations is incremented: $R \\leftarrow R + 1$.\n        - The copy cost is updated by the number of elements being moved: $K \\leftarrow K + length$.\n    3. The length is incremented to accommodate the new element: $length \\leftarrow length + 1$.\n- **Single Pop Operation**:\n    1. Check if the array is empty: If $length = 0$, the operation has no effect.\n    2. If $length > 0$, the length is first decremented: $length \\leftarrow length - 1$.\n    3. After decrementing, check for shrinkage. The condition is checked repeatedly in a loop: While $capacity > 1$ and $length \\le \\lfloor \\frac{capacity}{4} \\rfloor$, a reallocation is triggered.\n        - The capacity is halved: $capacity \\leftarrow \\lfloor \\frac{capacity}{2} \\rfloor$.\n        - The number of reallocations is incremented: $R \\leftarrow R + 1$.\n        - The copy cost is updated by the number of elements being moved: $K \\leftarrow K + length$. Note that $length$ has already been decremented.\n\nWe will now apply these rules to each test case.\n\n**Case 1: Initial capacity $c_0 = 4$. Operations: $+10, -3, +5$.**\n\n- **Initial State**: $length=0$, $capacity=4$, $R=0$, $K=0$, $N_{\\text{push}}=0$.\n- **Operation $+10$**: Perform $10$ single push operations.\n    - Pushes $1-4$: $length$ increments from $1$ to $4$. State: $length=4, capacity=4$.\n    - Push $5$: $length=capacity$. Grow. $R \\leftarrow 1$, $K \\leftarrow 0+4=4$. $capacity \\leftarrow 2 \\cdot 4 = 8$. Then, $length \\leftarrow 5$. State: $length=5, capacity=8, R=1, K=4$.\n    - Pushes $6-8$: $length$ increments from $6$ to $8$. State: $length=8, capacity=8, R=1, K=4$.\n    - Push $9$: $length=capacity$. Grow. $R \\leftarrow 2$, $K \\leftarrow 4+8=12$. $capacity \\leftarrow 2 \\cdot 8 = 16$. Then, $length \\leftarrow 9$. State: $length=9, capacity=16, R=2, K=12$.\n    - Push $10$: $length \\leftarrow 10$.\n    - After $+10$: $N_{\\text{push}}=10$. State: $length=10, capacity=16, R=2, K=12$.\n- **Operation $-3$**: Perform $3$ single pop operations.\n    - Pop $1$: $length \\leftarrow 9$. Check shrink: $9 > \\lfloor 16/4 \\rfloor = 4$. No shrink.\n    - Pop $2$: $length \\leftarrow 8$. Check shrink: $8 > 4$. No shrink.\n    - Pop $3$: $length \\leftarrow 7$. Check shrink: $7 > 4$. No shrink.\n    - After $-3$: State: $length=7, capacity=16, R=2, K=12$.\n- **Operation $+5$**: Perform $5$ single push operations.\n    - Pushes $1-5$: $length$ increments from $8$ to $12$. No growth needed as $capacity=16$.\n    - After $+5$: $N_{\\text{push}} \\leftarrow 10+5=15$. State: $length=12, capacity=16, R=2, K=12$.\n- **Final Metrics**:\n    - $L = 12$\n    - $C = 16$\n    - $R = 2$\n    - $K = 12$\n    - $A = K/N_{\\text{push}} = 12/15 = 0.8$\n    - $M = 16+C = 16+16 = 32$\n\n**Case 2: Initial capacity $c_0 = 1$. Operations: $-5, +1, -1$.**\n\n- **Initial State**: $length=0$, $capacity=1$, $R=0$, $K=0$, $N_{\\text{push}}=0$.\n- **Operation $-5$**: Perform $5$ single pop operations. Since $length=0$ initially, these operations have no effect.\n- **Operation $+1$**: Perform $1$ single push operation.\n    - Push $1$: $length=0 < capacity=1$. No growth. $length \\leftarrow 1$.\n    - After $+1$: $N_{\\text{push}}=1$. State: $length=1, capacity=1, R=0, K=0$.\n- **Operation $-1$**: Perform $1$ single pop operation.\n    - Pop $1$: $length \\leftarrow 0$. Check shrink: The condition $capacity > 1$ is false. No shrink.\n    - After $-1$: State: $length=0, capacity=1, R=0, K=0$.\n- **Final Metrics**:\n    - $L = 0$\n    - $C = 1$\n    - $R = 0$\n    - $K = 0$\n    - $A = K/N_{\\text{push}} = 0/1 = 0.0$\n    - $M = 16+C = 16+1 = 17$\n\n**Case 3: Initial capacity $c_0 = 3$. Operations: $+7, -4, +2, -1, -1$.**\n\n- **Initial State**: $length=0$, $capacity=3$, $R=0, K=0, N_{\\text{push}}=0$.\n- **Operation $+7$**:\n    - Pushes $1-3$: $length \\rightarrow 3$.\n    - Push $4$: Grow. $R \\leftarrow 1, K \\leftarrow 0+3=3, capacity \\leftarrow 6$. $length \\rightarrow 4$.\n    - Pushes $5-6$: $length \\rightarrow 6$.\n    - Push $7$: Grow. $R \\leftarrow 2, K \\leftarrow 3+6=9, capacity \\leftarrow 12$. $length \\rightarrow 7$.\n    - After $+7$: $N_{\\text{push}}=7$. State: $length=7, capacity=12, R=2, K=9$.\n- **Operation $-4$**:\n    - Pop $1$: $length \\rightarrow 6$. Check shrink: $6 > \\lfloor 12/4 \\rfloor = 3$. No.\n    - Pop $2$: $length \\rightarrow 5$. Check shrink: $5 > 3$. No.\n    - Pop $3$: $length \\rightarrow 4$. Check shrink: $4 > 3$. No.\n    - Pop $4$: $length \\rightarrow 3$. Check shrink: $3 \\le 3$. Yes. Shrink. $R \\leftarrow 3, K \\leftarrow 9+3=12, capacity \\leftarrow \\lfloor 12/2 \\rfloor = 6$. Check again: $length=3$, $capacity=6$. $3 > \\lfloor 6/4 \\rfloor=1$. Stop shrinking.\n    - After $-4$: State: $length=3, capacity=6, R=3, K=12$.\n- **Operation $+2$**: $length \\rightarrow 5$. No growth. $N_{\\text{push}} \\leftarrow 7+2=9$. State: $length=5, capacity=6$.\n- **Operation $-1$**: $length \\rightarrow 4$. Check shrink: $4 > \\lfloor 6/4 \\rfloor = 1$. No. State: $length=4, capacity=6$.\n- **Operation $-1$**: $length \\rightarrow 3$. Check shrink: $3 > 1$. No. State: $length=3, capacity=6$.\n- **Final Metrics**:\n    - $L = 3$\n    - $C = 6$\n    - $R = 3$\n    - $K = 12$\n    - $A = K/N_{\\text{push}} = 12/9 \\approx 1.333333$\n    - $M = 16+C = 16+6 = 22$\n\n**Case 4: Initial capacity $c_0 = 8$. Operations: $-2, -2, -2, -2$.**\n\n- **Initial State**: $length=0$, $capacity=8$, $R=0, K=0, N_{\\text{push}}=0$.\n- **All operations**: All are pop operations on an empty array. They have no effect.\n- **Final Metrics**:\n    - $L = 0$\n    - $C = 8$\n    - $R = 0$\n    - $K = 0$\n    - $N_{\\text{push}} = 0$, so $A = 0.0$ by definition.\n    - $M = 16+C = 16+8 = 24$\n\n**Case 5: Initial capacity $c_0 = 2$. Operations: $+100, -60, +20$.**\n\n- **Initial State**: $length=0$, $capacity=2$, $R=0, K=0, N_{\\text{push}}=0$.\n- **Operation $+100$**:\n    - Growth at $length=2$: $R=1, K=2, c=4$.\n    - Growth at $length=4$: $R=2, K=2+4=6, c=8$.\n    - Growth at $length=8$: $R=3, K=6+8=14, c=16$.\n    - Growth at $length=16$: $R=4, K=14+16=30, c=32$.\n    - Growth at $length=32$: $R=5, K=30+32=62, c=64$.\n    - Growth at $length=64$: $R=6, K=62+64=126, c=128$.\n    - After $100$ pushes, $length = 100$.\n    - After $+100$: $N_{\\text{push}}=100$. State: $length=100, capacity=128, R=6, K=126$.\n- **Operation $-60$**:\n    - $length$ decreases from $100$ to $40$.\n    - The shrink condition is $length \\le \\lfloor capacity/4 \\rfloor = \\lfloor 128/4 \\rfloor = 32$.\n    - Since the minimum $length$ reached is $40$, this condition is never met. No shrinks occur.\n    - After $-60$: State: $length=40, capacity=128, R=6, K=126$.\n- **Operation $+20$**:\n    - $length$ increases from $40$ to $60$. The capacity is $128$, so no growth is needed.\n    - $N_{\\text{push}} \\leftarrow 100+20=120$.\n    - After $+20$: State: $length=60, capacity=128, R=6, K=126$.\n- **Final Metrics**:\n    - $L = 60$\n    - $C = 128$\n    - $R = 6$\n    - $K = 126$\n    - $A = K/N_{\\text{push}} = 126/120 = 1.05$\n    - $M = 16+C = 16+128 = 144$\n\nThis completes the step-by-step analysis for all test cases. The implementation will codify this logic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates a dynamic array for a series of test cases and computes performance metrics.\n    \"\"\"\n\n    class DynamicArray:\n        \"\"\"\n        Models a dynamic array with specific growth and shrink rules.\n        \"\"\"\n        def __init__(self, initial_capacity):\n            self.length = 0\n            self.capacity = initial_capacity\n            self.reallocations = 0\n            self.copy_cost = 0\n            self.push_count = 0\n\n        def push(self):\n            \"\"\"\n            Appends a single element, growing the array if necessary.\n            \"\"\"\n            self.push_count += 1\n            if self.length == self.capacity:\n                self.reallocations += 1\n                self.copy_cost += self.length\n                self.capacity *= 2\n            self.length += 1\n\n        def pop(self):\n            \"\"\"\n            Removes a single element, shrinking the array if it becomes sparse enough.\n            \"\"\"\n            if self.length == 0:\n                return\n\n            self.length -= 1\n            \n            # The 'while' loop handles cases where multiple shrinks might be needed.\n            while self.capacity > 1 and self.length <= (self.capacity // 4):\n                self.reallocations += 1\n                # Copy cost is based on the new, smaller length.\n                self.copy_cost += self.length\n                self.capacity = self.capacity // 2\n\n        def get_metrics(self):\n            \"\"\"\n            Calculates and returns the final metrics for the array's lifetime.\n            \"\"\"\n            L = self.length\n            C = self.capacity\n            R = self.reallocations\n            K = self.copy_cost\n            \n            if self.push_count == 0:\n                A = 0.0\n            else:\n                A = K / self.push_count\n            \n            M = 16 + C\n            \n            # Format A to 6 decimal places as a string.\n            return [L, C, R, K, f\"{A:.6f}\", M]\n\n    test_cases = [\n        (4, ['+10', '-3', '+5']),\n        (1, ['-5', '+1', '-1']),\n        (3, ['+7', '-4', '+2', '-1', '-1']),\n        (8, ['-2', '-2', '-2', '-2']),\n        (2, ['+100', '-60', '+20']),\n    ]\n\n    results = []\n    for c0, operations in test_cases:\n        array = DynamicArray(c0)\n        for op in operations:\n            op_type = op[0]\n            count = int(op[1:])\n            \n            if op_type == '+':\n                for _ in range(count):\n                    array.push()\n            elif op_type == '-':\n                for _ in range(count):\n                    array.pop()\n        \n        results.append(array.get_metrics())\n\n    # Format the final output string as specified, with no spaces.\n    # e.g., [[L1,C1,...],[L2,C2,...]]\n    result_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3223151"}, {"introduction": "This practice explores the `union`, a composite type where members share the same memory location, and the associated dangers of \"type punning.\" You will analyze a hypothetical scenario where reinterpreting a block of memory as both an integer and a floating-point number introduces a critical security vulnerability. This exercise highlights the profound impact of data representation, demonstrating how the same bit pattern can yield vastly different values and why strict type discipline is essential for robust software [@problem_id:3223153].", "problem": "You are given a specification of a buggy parser that uses a union-like composite data type to type-pun a $4$-byte field as both an unsigned $32$-bit integer and a single-precision floating-point number. A union is a composite data type that overlays multiple member types on the same memory, so all members share the same underlying bytes. The bug arises because the code validates the field by interpreting the bytes as a floating-point number, but then uses the same bytes as an unsigned integer for a length without consistent interpretation rules. You must formalize, simulate, and assess this bug on a well-chosen set of test inputs.\n\nFundamental base and assumptions:\n- A union has a single storage region, and each member occupies the same addresses. Reading through a member returns an interpretation of the same underlying bitstring.\n- The machine model is as follows.\n  - Byte order is little-endian, meaning the least significant byte is stored at the lowest memory address. If the in-memory bytes are $(b_0,b_1,b_2,b_3)$ at increasing addresses, then the unsigned $32$-bit integer value $n$ is\n    $$\n    n \\;=\\; b_0 + 2^8 b_1 + 2^{16} b_2 + 2^{24} b_3.\n    $$\n  - The floating-point interpretation follows the Institute of Electrical and Electronics Engineers (IEEE) $754$ single-precision format: $1$ sign bit, $8$ exponent bits, and $23$ fraction bits. The interpretation of $(b_0,b_1,b_2,b_3)$ as a $\\text{float32}$ value $f$ is obtained by treating the $4$ bytes as the $32$ bits of the IEEE $754$ representation in little-endian order.\n- Lengths are expressed in bytes. Define the maximum allowed payload length $L_{\\max} = 10^6$ bytes.\n\nBuggy parser logic to simulate:\n1. Let $(b_0,b_1,b_2,b_3)$ be the four in-memory bytes of the field. Compute the floating-point reinterpretation $f$ and the unsigned integer reinterpretation $n$ of the same bytes, both in little-endian order.\n2. The parser considers the field valid if and only if $0 \\le f \\le 1$. If valid, it uses $n$ as the payload length. Otherwise, it rejects the message.\n3. A message is said to be exploitable if the parser considers the field valid but the selected length $n$ exceeds the maximum allowed, that is, if $0 \\le f \\le 1$ and $n > L_{\\max}$.\n\nYour task:\n- Implement a program that, for each provided test case below, computes whether the message is exploitable according to the above rules, outputting $1$ for exploitable and $0$ for not exploitable. All computations must respect little-endian layout and IEEE $754$ single-precision rules.\n- Your program must not read any input and must embed the test suite below.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces. For example: $\\texttt{[1,0,1]}$.\n\nTest suite (each test case is a $4$-tuple $(b_0,b_1,b_2,b_3)$ of bytes in increasing memory address order, where each $b_i$ is an integer in $\\{0,\\dots,255\\}$):\n- Case $1$: $(0x00, 0x00, 0x00, 0x00)$.\n- Case $2$: $(0x00, 0x00, 0x00, 0x3F)$, which is the bit pattern for $f = 0.5$ and for $n = 0x3F000000$.\n- Case $3$: $(0x10, 0x00, 0x00, 0x00)$, a small integer length with a subnormal positive $f$.\n- Case $4$: $(0x0A, 0xD7, 0x7F, 0x3F)$, which is the bit pattern for $f \\approx 0.99999994$ and $n = 0x3F7FD70A$.\n- Case $5$: $(0x00, 0x00, 0x80, 0xBF)$, which is the bit pattern for $f = -1.0$ and $n = 0xBF800000$.\n- Case $6$: $(0x00, 0x00, 0x80, 0x3F)$, which is the bit pattern for $f = 1.0$ and $n = 0x3F800000$.\n- Case $7$: $(0x00, 0x00, 0xC0, 0x7F)$, which is a quiet Not-a-Number under IEEE $754$, hence not comparable.\n- Case $8$: $(0x40, 0x42, 0x0F, 0x00)$, which is the little-endian encoding of $n = 1{,}000{,}000$ and a very small positive subnormal $f$.\n\nOutput specification:\n- Let the results for the $8$ cases be $r_1,\\dots,r_8 \\in \\{0,1\\}$ in that order. Your program should print exactly one line with the single string $[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8]$.", "solution": "The user-provided problem has been validated and is determined to be a well-posed, scientifically grounded problem in computer science. It requires the analysis of a type confusion vulnerability arising from reinterpreting a $4$-byte memory region as both an unsigned integer and a single-precision floating-point number. We will proceed with a formal solution.\n\nThe core of the problem is to simulate a buggy parser's logic for a given set of test cases. For each input, a $4$-tuple of bytes $(b_0, b_1, b_2, b_3)$ stored in little-endian order, we must determine if the message is \"exploitable\". This requires two main reinterpretations of the same underlying $32$ bits.\n\nLet the four bytes in memory, starting from the lowest address, be $(b_0, b_1, b_2, b_3)$, where each $b_i$ is an $8$-bit value from $0$ to $255$.\n\n**Step 1: Unsigned Integer Reinterpretation**\n\nAccording to the problem's little-endian specification, the $4$ bytes are interpreted as a $32$-bit unsigned integer, denoted by $n$. The value of $n$ is calculated as:\n$$\nn = b_0 \\cdot 2^0 + b_1 \\cdot 2^8 + b_2 \\cdot 2^{16} + b_3 \\cdot 2^{24} = \\sum_{i=0}^{3} b_i 2^{8i}\n$$\nThis corresponds to constructing a $32$-bit word where $b_0$ is the least significant byte and $b_3$ is the most significant byte.\n\n**Step 2: Floating-Point Reinterpretation**\n\nThe same $32$-bit word is reinterpreted as a single-precision floating-point number, $f$, conforming to the IEEE $754$ standard. A $32$-bit IEEE $754$ number consists of three fields:\n- A $1$-bit sign ($S$)\n- An $8$-bit biased exponent ($E$)\n- A $23$-bit fraction ($F$)\n\nThe value $f$ is determined as follows:\n- If $E = 255$ and $F \\neq 0$, $f$ is Not-a-Number (NaN).\n- If $E = 255$ and $F = 0$, $f$ is $\\pm\\infty$ depending on $S$.\n- If $0 < E < 255$, $f$ is a normalized number: $f = (-1)^S \\times (1.F) \\times 2^{(E-127)}$.\n- If $E = 0$ and $F \\neq 0$, $f$ is a subnormal number: $f = (-1)^S \\times (0.F) \\times 2^{(-126)}$.\n- If $E = 0$ and $F = 0$, $f$ is $\\pm 0$ depending on $S$.\n\nThe little-endian memory layout $(b_0, b_1, b_2, b_3)$ corresponds to the same $32$-bit pattern used for calculating $n$.\n\n**Step 3: Applying Parser Logic**\n\nThe parser's logic defines two conditions for each message:\n1.  **Validity Condition:** The field is valid if and only if its floating-point interpretation $f$ satisfies the inequality $0 \\le f \\le 1$. Crucially, any comparison involving a NaN value evaluates to false, so a NaN value for $f$ will render the field invalid.\n2.  **Exploitability Condition:** A message is exploitable if it is deemed valid *and* its unsigned integer interpretation $n$ exceeds the maximum allowed payload length, $L_{\\max} = 10^6$.\n\nTherefore, a message is exploitable if and only if ($0 \\le f \\le 1$) AND ($n > 10^6$). The result for each test case will be $1$ if exploitable and $0$ otherwise.\n\n**Analysis of Test Cases**\n\nWe now apply this procedure to each test case.\n\n**Case 1:** Input bytes $(0x00, 0x00, 0x00, 0x00)$.\n- Integer $n$: $n = 0x00000000 = 0$.\n- Float $f$: The bit pattern is all zeros, which represents $f = 0.0$.\n- Validity: $0 \\le 0.0 \\le 1$. This is true.\n- Exploitability: $n > 10^6 \\implies 0 > 10^6$. This is false.\n- **Result:** $0$.\n\n**Case 2:** Input bytes $(0x00, 0x00, 0x00, 0x3F)$.\n- Integer $n$: $n = 0x3F000000 = 1,056,964,608$.\n- Float $f$: The bit pattern is $00111111000000000000000000000000$. This represents $f = 0.5$.\n- Validity: $0 \\le 0.5 \\le 1$. This is true.\n- Exploitability: $n > 10^6 \\implies 1,056,964,608 > 10^6$. This is true.\n- **Result:** $1$.\n\n**Case 3:** Input bytes $(0x10, 0x00, 0x00, 0x00)$.\n- Integer $n$: $n = 0x00000010 = 16$.\n- Float $f$: The bit pattern is non-zero with a zero exponent field, representing a positive subnormal number. Its value is $f \\approx 2.24 \\times 10^{-44}$.\n- Validity: $0 \\le f \\le 1$. This is true.\n- Exploitability: $n > 10^6 \\implies 16 > 10^6$. This is false.\n- **Result:** $0$.\n\n**Case 4:** Input bytes $(0x0A, 0xD7, 0x7F, 0x3F)$.\n- Integer $n$: $n = 0x3F7FD70A = 1,065,359,114$.\n- Float $f$: The bit pattern corresponds to a normalized number $f \\approx 0.99948$.\n- Validity: $0 \\le 0.99948 \\le 1$. This is true.\n- Exploitability: $n > 10^6 \\implies 1,065,359,114 > 10^6$. This is true.\n- **Result:** $1$.\n\n**Case 5:** Input bytes $(0x00, 0x00, 0x80, 0xBF)$.\n- Integer $n$: $n = 0xBF800000 = 3,212,836,864$.\n- Float $f$: The bit pattern is $10111111100000000000000000000000$. This represents $f = -1.0$.\n- Validity: $0 \\le -1.0 \\le 1$. This is false because $0 \\le -1.0$ is false.\n- **Result:** $0$.\n\n**Case 6:** Input bytes $(0x00, 0x00, 0x80, 0x3F)$.\n- Integer $n$: $n = 0x3F800000 = 1,065,353,216$.\n- Float $f$: The bit pattern is $00111111100000000000000000000000$. This represents $f = 1.0$.\n- Validity: $0 \\le 1.0 \\le 1$. This is true.\n- Exploitability: $n > 10^6 \\implies 1,065,353,216 > 10^6$. This is true.\n- **Result:** $1$.\n\n**Case 7:** Input bytes $(0x00, 0x00, 0xC0, 0x7F)$.\n- Integer $n$: $n = 0x7FC00000 = 2,143,289,344$.\n- Float $f$: The bit pattern has an exponent of all ones ($E=255$) and a non-zero fraction, which represents a quiet Not-a-Number (NaN).\n- Validity: Any comparison with NaN (e.g., $0 \\le \\text{NaN}$ or $\\text{NaN} \\le 1$) is false. Therefore, the validity check fails.\n- **Result:** $0$.\n\n**Case 8:** Input bytes $(0x40, 0x42, 0x0F, 0x00)$.\n- Integer $n$: $n = 0x000F4240 = 1,000,000$.\n- Float $f$: The bit pattern represents a positive subnormal number, $f \\approx 1.40 \\times 10^{-45}$.\n- Validity: $0 \\le f \\le 1$. This is true.\n- Exploitability: $n > 10^6 \\implies 1,000,000 > 1,000,000$. This is false due to the strict inequality.\n- **Result:** $0$.\n\nThe final sequence of results for the test suite is $[0, 1, 0, 1, 0, 1, 0, 0]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates a buggy parser to determine if messages are exploitable based on type-punning.\n    \n    A 4-byte field is interpreted as both a little-endian unsigned 32-bit integer (n)\n    and a little-endian IEEE 754 single-precision float (f).\n    A message is valid if 0 <= f <= 1.\n    A message is exploitable if it is valid AND n > L_max.\n    \"\"\"\n    \n    # Define the maximum allowed payload length from the problem statement.\n    L_max = 10**6\n\n    # Define the test suite from the problem statement.\n    # Each case is a 4-tuple of bytes (b0, b1, b2, b3) in little-endian order.\n    test_cases = [\n        (0x00, 0x00, 0x00, 0x00), # Case 1\n        (0x00, 0x00, 0x00, 0x3F), # Case 2\n        (0x10, 0x00, 0x00, 0x00), # Case 3\n        (0x0A, 0xD7, 0x7F, 0x3F), # Case 4\n        (0x00, 0x00, 0x80, 0xBF), # Case 5\n        (0x00, 0x00, 0x80, 0x3F), # Case 6\n        (0x00, 0x00, 0xC0, 0x7F), # Case 7\n        (0x40, 0x42, 0x0F, 0x00), # Case 8\n    ]\n\n    results = []\n    for case in test_cases:\n        # Create a numpy array of 8-bit unsigned integers from the byte tuple.\n        # This represents the in-memory layout of the 4 bytes.\n        byte_array = np.array(case, dtype=np.uint8)\n\n        # Reinterpret the 4-byte buffer as a single 32-bit unsigned integer.\n        # The '<u4' dtype specifies little-endian ('<'), unsigned ('u'), 4 bytes ('4').\n        n = byte_array.view(dtype='<u4')[0]\n\n        # Reinterpret the same 4-byte buffer as a single-precision float.\n        # The '<f4' dtype specifies little-endian ('<'), float ('f'), 4 bytes ('4').\n        f = byte_array.view(dtype='<f4')[0]\n\n        # Check the parser's validity condition.\n        # For f=NaN, comparisons like 0 <= f or f <= 1 are False, correctly\n        # handling the NaN case as specified by IEEE 754.\n        is_valid = (f >= 0) and (f <= 1)\n        \n        # Check the exploitability condition.\n        is_exploitable = n > L_max\n\n        # The message is exploitable if and only if both conditions are met.\n        if is_valid and is_exploitable:\n            results.append(1)\n        else:\n            results.append(0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3223153"}]}