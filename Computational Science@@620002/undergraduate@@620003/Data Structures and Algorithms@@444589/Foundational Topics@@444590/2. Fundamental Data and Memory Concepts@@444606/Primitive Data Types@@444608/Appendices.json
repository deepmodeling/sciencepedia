{"hands_on_practices": [{"introduction": "Swapping the values of two variables is a common operation, typically accomplished with a third temporary variable. This practice challenges that convention, pushing you to manipulate data at its most fundamental level: the bits. By leveraging the algebraic properties of the bitwise exclusive OR (XOR) operation, you will discover how it is possible to perform a swap in-place, offering insights into memory efficiency and the logical foundations of computation [@problem_id:3260585].", "problem": "You are to write a complete program that defines and uses a function to swap two primitive integers without using any temporary variable, using only bitwise operations. The goal is to justify from first principles why such a swap is possible and correct. The program must implement the function, run it on the provided test suite, and print the aggregated results in the specified format.\n\nDefinitions to be used as the fundamental base in your reasoning and algorithm design: integers are represented in binary as sequences of bits, and bitwise operations act independently on each bit. Bitwise exclusive OR (XOR) will be denoted by $\\oplus$, bitwise AND will be denoted by $\\land$, and bitwise OR will be denoted by $\\lor$. No other assumptions beyond these representations and operations should be required.\n\nConstraints for the swap function:\n- The function must accept two integers $a$ and $b$ and return the swapped values.\n- The function must not allocate or use any additional temporary variables.\n- The function must use only bitwise operations; no arithmetic operations (such as $+$, $-$, $\\times$, $\\div$), no tuple unpacking, and no library or language-specific swap constructs are permitted within the swap function.\n- The function must execute in time $\\mathcal{O}(1)$ and use space $\\mathcal{O}(1)$.\n\nTest suite to be executed by your program:\n- Case $1$: $a = 3$, $b = 5$.\n- Case $2$: $a = 0$, $b = 0$.\n- Case $3$: $a = 0$, $b = 42$.\n- Case $4$: $a = -7$, $b = 13$.\n- Case $5$: $a = 2^{63} - 1$, $b = -2^{63}$.\n- Case $6$: $a = 123456789$, $b = 987654321$.\n- Case $7$: $a = 1$, $b = 1$.\n\nYour program must apply the swap function to each test case and produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of the list must itself be a two-integer list $[a',b']$ representing the swapped values for the corresponding test case, where $a'$ is the new value of $a$ (formerly $b$) and $b'$ is the new value of $b$ (formerly $a$). For example, the output format should look like $[[b_1,a_1],[b_2,a_2],\\dots]$ with no spaces.", "solution": "The problem is valid. It presents a well-defined task in computational logic which is grounded in the fundamental algebraic properties of bitwise operations. All constraints are consistent and the objective is clear.\n\nThe task is to swap the values of two integer variables, let us call them $a$ and $b$, without using an auxiliary temporary variable. The constraints limit the permissible operations to only bitwise operations. The solution hinges on the properties of the bitwise exclusive OR (XOR) operation, denoted by the symbol $\\oplus$.\n\nThe justification from first principles relies on the algebraic structure that the set of integers forms under the bitwise XOR operation. Since bitwise operations act independently on each bit in the binary representation of the integers, we can analyze the properties at the single-bit level. The set $\\{0, 1\\}$ with the XOR operation forms an abelian group. The key properties are:\n\n1.  **Commutativity**: $x \\oplus y = y \\oplus x$. The order of operands does not matter.\n2.  **Associativity**: $(x \\oplus y) \\oplus z = x \\oplus (y \\oplus z)$. Grouping of operations does not matter.\n3.  **Identity Element**: There exists an identity element, $0$, such that $x \\oplus 0 = x$.\n4.  **Self-Inverse**: Every element is its own inverse, meaning $x \\oplus x = 0$.\n\nThese properties, established for single bits, extend to integers of any bit length because the operations are applied bit-by-bit.\n\nLet the initial values of the variables be $a_0$ and $b_0$. The swap is achieved through a sequence of three assignments using the XOR operation.\n\n**Step 1:** The value of $a$ is updated by XORing it with $b$.\n$$a \\leftarrow a \\oplus b$$\nAfter this step, the variable $a$ holds the value $a_1 = a_0 \\oplus b_0$. The variable $b$ still holds its original value, $b_0$. The state of the variables is now $(a_1, b_0)$.\n\n**Step 2:** The value of $b$ is updated by XORing it with the new value of $a$.\n$$b \\leftarrow a \\oplus b$$\nSubstituting the current values of the variables ($a=a_1$, $b=b_0$), we get:\n$$b \\leftarrow a_1 \\oplus b_0$$\nNow, substitute the expression for $a_1$ from Step 1:\n$$b \\leftarrow (a_0 \\oplus b_0) \\oplus b_0$$\nUsing the associativity property, we can regroup the terms:\n$$b \\leftarrow a_0 \\oplus (b_0 \\oplus b_0)$$\nUsing the self-inverse property ($b_0 \\oplus b_0 = 0$):\n$$b \\leftarrow a_0 \\oplus 0$$\nFinally, using the identity property ($a_0 \\oplus 0 = a_0$):\n$$b \\leftarrow a_0$$\nAfter this step, the variable $b$ correctly holds the original value of $a$, which is $a_0$. The variable $a$ still holds the value $a_1 = a_0 \\oplus b_0$. The state is now $(a_1, a_0)$.\n\n**Step 3:** The value of $a$ is updated one last time by XORing it with the new value of $b$.\n$$a \\leftarrow a \\oplus b$$\nSubstituting the current values ($a=a_1$, $b=a_0$):\n$$a \\leftarrow a_1 \\oplus a_0$$\nNow, substitute the expression for $a_1$ from Step 1:\n$$a \\leftarrow (a_0 \\oplus b_0) \\oplus a_0$$\nUsing the commutativity property to reorder the terms:\n$$a \\leftarrow (b_0 \\oplus a_0) \\oplus a_0$$\nUsing the associativity property to regroup:\n$$a \\leftarrow b_0 \\oplus (a_0 \\oplus a_0)$$\nUsing the self-inverse property ($a_0 \\oplus a_0 = 0$):\n$$a \\leftarrow b_0 \\oplus 0$$\nFinally, using the identity property ($b_0 \\oplus 0 = b_0$):\n$$a \\leftarrow b_0$$\nAfter this final step, the variable $a$ now holds the original value of $b$, which is $b_0$. The variable $b$ continues to hold $a_0$.\n\nThe final state of the variables is $(b_0, a_0)$. The values have been successfully swapped. This algorithm adheres to all stated constraints: it uses no temporary variables, relies exclusively on bitwise operations, and consists of a fixed number of operations, thus having a time complexity of $\\mathcal{O}(1)$ and a space complexity of $\\mathcal{O}(1)$.\n\nThe implementation will define a function that takes two integers and applies this three-step XOR sequence, returning the new values. This function will then be executed for each case in the provided test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of swapping integers using bitwise XOR and\n    prints the results for a given test suite.\n    \"\"\"\n\n    def xor_swap(a, b):\n        \"\"\"\n        Swaps two integers using only bitwise XOR operations.\n\n        This function implements the classic XOR swap algorithm, which swaps the\n        values of two variables without using a temporary variable. The logic\n        relies on the algebraic properties of the XOR operation.\n\n        Args:\n            a: The first integer.\n            b: The second integer.\n\n        Returns:\n            A tuple (a, b) with the swapped values.\n        \"\"\"\n        # Let initial values be a_0 and b_0.\n        # Step 1: a becomes a_0 ^ b_0. b is still b_0.\n        a = a ^ b\n        # Step 2: b becomes (a_0 ^ b_0) ^ b_0 = a_0 ^ (b_0 ^ b_0) = a_0 ^ 0 = a_0.\n        # So b now holds the original value of a.\n        b = a ^ b\n        # Step 3: a becomes (a_0 ^ b_0) ^ a_0 = (a_0 ^ a_0) ^ b_0 = 0 ^ b_0 = b_0.\n        # So a now holds the original value of b.\n        a = a ^ b\n        return a, b\n\n    # Define the test cases from the problem statement.\n    # Python integers have arbitrary precision, which correctly models\n    # the behavior of two's complement arithmetic for bitwise operations\n    # on fixed-width integers, including the large integer case.\n    test_cases = [\n        (3, 5),                       # Case 1\n        (0, 0),                       # Case 2\n        (0, 42),                      # Case 3\n        (-7, 13),                     # Case 4\n        (2**63 - 1, -2**63),          # Case 5\n        (123456789, 987654321),       # Case 6\n        (1, 1),                       # Case 7\n    ]\n\n    results = []\n    for a_val, b_val in test_cases:\n        swapped_a, swapped_b = xor_swap(a_val, b_val)\n        results.append((swapped_a, swapped_b))\n\n    # Format the output exactly as specified: [[b1,a1],[b2,a2],...]\n    # with no spaces.\n    result_strings = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3260585"}, {"introduction": "While modern CPUs perform multiplication and division with dedicated hardware, these operations are fundamentally rooted in simpler bit shifts. This exercise explores this deep connection by asking you to implement multiplication and division by powers of two using only bit shift operators [@problem_id:3260707]. By reasoning from the binary positional system and the two's complement representation, you will gain a first-principles understanding of how shifting bits left or right corresponds to scaling integer values, a technique crucial for performance optimization and understanding low-level code.", "problem": "You are given the task of implementing integer multiplication and division by powers of two using only the semantics of bit shift operators as defined on signed integers. The goal is to reason from the positional binary numeral system and the two's complement representation to derive and implement correct operations without relying on explicit multiplication, division, or exponentiation operators.\n\nFundamental base to use:\n- Binary positional numeral system: any nonnegative integer $n$ can be expressed as $n = \\sum_{i=0}^{m} b_i \\cdot 2^i$, where each $b_i \\in \\{0,1\\}$ and $m$ is a nonnegative integer. Negative integers in two's complement representation extend the sign bit indefinitely under arithmetic right shift, preserving algebraic structure.\n- Bit shift operator semantics on signed integers: left shift moves every bit position $i$ to position $i+k$ for a nonnegative integer shift amount $k$, while arithmetic right shift moves every bit position $i$ to $i-k$ and replicates the sign bit for negative values.\n\nTask:\n- Implement two functions over signed mathematical integers:\n  1. $f_{\\text{mul}}(n,k)$ that returns the product $n \\cdot 2^k$ using only the left shift operator semantics.\n  2. $f_{\\text{div\\_floor}}(n,k)$ that returns the floor division result $\\left\\lfloor \\dfrac{n}{2^k} \\right\\rfloor$ using only the arithmetic right shift operator semantics.\n- Constraints:\n  - Inputs $n$ and $k$ are mathematical integers with $k \\ge 0$.\n  - The implementations must not use multiplication, division, or exponentiation operators. Use only bit shift operators to realize the required operations.\n  - Operate over unbounded precision signed integers as mathematical objects; do not assume a fixed word size.\n\nTest suite:\n- Use the following parameter pairs $(n,k)$ to validate the correctness and edge behavior:\n  - $(13, 2)$ meaning $n = 13$, $k = 2$.\n  - $(-13, 2)$ meaning $n = -13$, $k = 2$.\n  - $(0, 5)$ meaning $n = 0$, $k = 5$.\n  - $(1, 0)$ meaning $n = 1$, $k = 0$.\n  - $(-1, 1)$ meaning $n = -1$, $k = 1$.\n  - $(123456789, 3)$ meaning $n = 123456789$, $k = 3$.\n  - $(-1073741824, 5)$ meaning $n = -1073741824$, $k = 5$.\n  - $(7, 63)$ meaning $n = 7$, $k = 63$.\n- For each test case, compute two integers: $f_{\\text{mul}}(n,k)$ and $f_{\\text{div\\_floor}}(n,k)$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is itself a two-element list of integers with no whitespace, in the order of the test suite, for example:\n- The exact format is $[[a_1,b_1],[a_2,b_2],\\dots,[a_8,b_8]]$, where $a_i = f_{\\text{mul}}(n_i,k_i)$ and $b_i = f_{\\text{div\\_floor}}(n_i,k_i)$ for the $i$-th test case.", "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of binary arithmetic and two's complement representation, well-posed with clear objectives and constraints, and formulated with objective, unambiguous language. The task is to derive and implement integer multiplication and division by powers of two using only the semantic equivalents of bit shift operations, starting from first principles.\n\nWe will derive the solutions for the two required functions, $f_{\\text{mul}}(n,k)$ and $f_{\\text{div\\_floor}}(n,k)$, based on the provided fundamental principles.\n\n### Derivation of $f_{\\text{mul}}(n,k) = n \\cdot 2^k$\n\nThe problem is to compute the product of an integer $n$ and a power of two, $2^k$, for $k \\ge 0$, using only left bit shift semantics.\n\nFirst, consider a non-negative integer $n$. According to the binary positional numeral system, $n$ can be expressed as a sum of powers of two:\n$$n = \\sum_{i=0}^{m} b_i \\cdot 2^i$$\nwhere $b_i \\in \\{0, 1\\}$ are the binary digits (bits) of $n$ at positions $i$, and $m$ is the highest power of two needed to represent $n$.\n\nMultiplying $n$ by $2^k$ gives:\n$$n \\cdot 2^k = \\left( \\sum_{i=0}^{m} b_i \\cdot 2^i \\right) \\cdot 2^k$$\nBy the distributive property of multiplication over addition and the law of exponents ($a^x \\cdot a^y = a^{x+y}$), we can rewrite this as:\n$$n \\cdot 2^k = \\sum_{i=0}^{m} (b_i \\cdot 2^i \\cdot 2^k) = \\sum_{i=0}^{m} b_i \\cdot 2^{i+k}$$\nThis resulting sum represents a new integer where each original bit $b_i$ that was at position $i$ (contributing a value of $b_i \\cdot 2^i$) is now at position $i+k$ (contributing a value of $b_i \\cdot 2^{i+k}$). This describes precisely the operation of a logical left shift by $k$ positions. The new low-order bits from position $0$ to $k-1$ are filled with zeros.\n\nFor negative integers, we rely on the two's complement representation. In this system, performing a left bit shift on a signed integer (where newly introduced bits on the right are zeros) is arithmetically equivalent to multiplication by $2^k$, provided no significant bits are lost due to overflow. The problem specifies the use of unbounded precision integers, which corresponds to Python's arbitrary-precision integer type. This abstraction ensures that no overflow occurs. Therefore, the left shift operation remains valid for all integers $n$.\n\nThus, the function $f_{\\text{mul}}(n, k)$ can be implemented using a left bit shift operation, which is denoted by `` in many programming languages, including Python.\n$$f_{\\text{mul}}(n,k) \\equiv n \\ll k$$\n\n### Derivation of $f_{\\text{div\\_floor}}(n,k) = \\lfloor \\frac{n}{2^k} \\rfloor$\n\nThe problem is to compute the floor of the division of an integer $n$ by a power of two, $2^k$, for $k \\ge 0$, using only arithmetic right bit shift semantics.\n\nFirst, consider a non-negative integer $n$, represented as $n = \\sum_{i=0}^{m} b_i \\cdot 2^i$.\nDividing $n$ by $2^k$ gives:\n$$\\frac{n}{2^k} = \\frac{1}{2^k} \\sum_{i=0}^{m} b_i \\cdot 2^i = \\sum_{i=0}^{m} b_i \\cdot 2^{i-k}$$\nWe can split this sum at the index $i=k$:\n$$\\frac{n}{2^k} = \\sum_{i=k}^{m} b_i \\cdot 2^{i-k} + \\sum_{i=0}^{k-1} b_i \\cdot 2^{i-k}$$\nThe first term, $\\sum_{i=k}^{m} b_i \\cdot 2^{i-k}$, is an integer. It corresponds to the binary representation of $n$ shifted right by $k$ positions, with bits from positions $0$ to $k-1$ being discarded.\nThe second term, $\\sum_{i=0}^{k-1} b_i \\cdot 2^{i-k}$, is a sum of non-negative terms. Its value is $0 \\le \\sum_{i=0}^{k-1} b_i \\cdot 2^{i-k}  1$. This term represents the fractional part of the division.\n\nThe floor of a number is the greatest integer less than or equal to that number. Since the second term is a non-negative fraction less than $1$, the floor of the entire expression is simply the integer part:\n$$\\left\\lfloor \\frac{n}{2^k} \\right\\rfloor = \\sum_{i=k}^{m} b_i \\cdot 2^{i-k}$$\nThis operation is precisely an arithmetic right shift. For non-negative numbers, an arithmetic right shift is identical to a logical right shift: bits are shifted to the right by $k$ positions, and the $k$ most significant bits are filled with $0$, which is the sign bit for a non-negative number.\n\nNow, consider a negative integer $n$. The floor division $\\lfloor \\frac{n}{d} \\rfloor$ rounds towards negative infinity. For example, $\\lfloor \\frac{-13}{4} \\rfloor = \\lfloor -3.25 \\rfloor = -4$. This is distinct from truncation (rounding towards zero), which would yield $-3$. The problem explicitly requests floor division, and an arithmetic right shift on a two's complement number is defined to produce this exact result. In an arithmetic right shift, the bits are shifted right, and the vacated high-order bits are filled with copies of the original sign bit. For a negative number, the sign bit is $1$, so the new bits are $1$s. This process correctly preserves the sign and rounds the magnitude towards negative infinity.\n\nPython's right shift operator `` on integers implements an arithmetic right shift. This behavior is guaranteed for both positive and negative integers and directly corresponds to floor division by a power of two.\n\nThus, the function $f_{\\text{div\\_floor}}(n, k)$ can be implemented using an arithmetic right bit shift operation.\n$$f_{\\text{div\\_floor}}(n,k) \\equiv n \\gg k$$\n\nThe implementation will apply these two derived equivalences to the provided test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of implementing multiplication and floor division by powers\n    of two using only bit shift operators, based on first principles of binary\n    arithmetic and two's complement representation.\n    \"\"\"\n    \n    # Define the functions based on the derived principles.\n    # f_mul(n, k) computes n * 2**k using the left shift operator.\n    # The derivation showed that n  k is equivalent to n * 2**k for all integers n\n    # and non-negative integers k, within an unbounded integer model.\n    f_mul = lambda n, k: n  k\n\n    # f_div_floor(n, k) computes floor(n / 2**k) using the arithmetic right shift operator.\n    # The derivation showed that n  k (arithmetic right shift) is equivalent to\n    # floor(n / 2**k) for all integers n and non-negative integers k.\n    f_div_floor = lambda n, k: n  k\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (13, 2),\n        (-13, 2),\n        (0, 5),\n        (1, 0),\n        (-1, 1),\n        (123456789, 3),\n        (-1073741824, 5),\n        (7, 63)\n    ]\n\n    results = []\n    for n, k in test_cases:\n        # Calculate the multiplication and division results for the current case.\n        mul_result = f_mul(n, k)\n        div_result = f_div_floor(n, k)\n        \n        # Append the pair of results to the list.\n        results.append([mul_result, div_result])\n\n    # Format the final output string exactly as specified:\n    # A comma-separated list of two-element lists, with no whitespace.\n    # e.g., [[a_1,b_1],[a_2,b_2],...]\n    output_str = f\"[{','.join(f'[{res[0]},{res[1]}]' for res in results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "3260707"}, {"introduction": "Reversing the bits of an integer is a non-trivial task with important applications in algorithms like the Fast Fourier Transform (FFT) and in certain communication protocols. A simple loop is inefficient, so this practice challenges you to devise a method that operates in a constant number of steps for a fixed-width integer [@problem_id:3260780]. You will implement a divide-and-conquer strategy, using bitwise masks and shifts to swap progressively smaller adjacent blocks of bits, providing a powerful demonstration of parallel computation at the bit level.", "problem": "You are given the primitive data type \"unsigned integer\" with fixed width of $32$ bits. By definition, a $32$-bit unsigned integer is any integer $x$ satisfying $0 \\le x \\le 2^{32}-1$, represented in binary as a sequence of bits $b_{31}b_{30}\\dots b_{1}b_{0}$, where each $b_{i} \\in \\{0,1\\}$ and $x = \\sum_{i=0}^{31} b_{i} \\cdot 2^{i}$. The bit-reversal of $x$ is the integer $y$ whose binary representation is $b_{0}b_{1}\\dots b_{30}b_{31}$, equivalently $y = \\sum_{i=0}^{31} b_{i} \\cdot 2^{31-i}$.\n\nTask: Implement a function that computes the bit-reversal of a $32$-bit unsigned integer efficiently from first principles and output the results for a given test suite. Use only word-level bitwise operations and fixed-width arithmetic on $32$-bit words, namely bitwise conjunction ($AND$), bitwise disjunction ($OR$), bitwise exclusive-or ($XOR$), bitwise negation ($NOT$), and logical shifts ($\\ll$ and $\\gg$). The algorithmic design must operate in $O(1)$ word operations on a standard word random-access machine with word size $w = 32$, and must not iterate over all individual bits. The function must return an unsigned $32$-bit result, that is, the result reduced modulo $2^{32}$.\n\nFundamental base that you must rely on in your reasoning and design:\n- The binary positional representation $x = \\sum_{i=0}^{31} b_{i} \\cdot 2^{i}$ with $b_{i} \\in \\{0,1\\}$.\n- The semantics of word-level bitwise operations $AND$, $OR$, $XOR$, $NOT$, and fixed-width logical shifts $\\ll$ and $\\gg$ on $32$-bit words.\n- The algebraic facts that masking selects subsets of bits and shifting by $k$ positions multiplies or divides by $2^{k}$ within the fixed-width word, discarding overflowed bits.\n\nInput: There is no external input. Your program must embed and process the following test suite of $32$-bit unsigned integers:\n- $0$\n- $1$\n- $2^{32}-1$ (that is, $4294967295$)\n- $43261596$\n- $2863311530$ (that is, $0xAAAAAAAA$)\n- $15$\n- $2147483649$ (that is, $0x80000001$)\n- $65535$ (that is, $0x0000FFFF$)\n- $4042322160$ (that is, $0xF0F0F0F0$)\n\nOutput: For each test value $x$ in the order listed above, compute its bit-reversal $y$ as defined, interpreted as a $32$-bit unsigned integer. Your program should produce a single line of output containing the results as a comma-separated list of decimal integers enclosed in square brackets, with no spaces, for example $[r_1,r_2,\\dots,r_9]$ for the nine test values in order.\n\nAnswer type: Each item is an integer. There are no physical units or angles in this problem.\n\nRequirements and constraints summary:\n- Implement a function that maps $x \\mapsto y$ where $y$ is the $32$-bit bit-reversal of $x$.\n- Use only word-level bitwise operations and fixed-width logical shifts on $32$-bit words.\n- The algorithm must run in $O(1)$ word operations and must not iterate per bit.\n- Apply modulo $2^{32}$ semantics to ensure the final result is a $32$-bit unsigned integer.", "solution": "The problem is valid. It is a well-defined computational task based on the fundamental principles of binary arithmetic and bitwise operations in computer science. All provided definitions, constraints, and data are consistent, complete, and formalizable into a solvable problem.\n\nThe task is to compute the bit-reversal of a $32$-bit unsigned integer $x$. An integer $x$ with binary representation $b_{31}b_{30}\\dots b_{1}b_{0}$, defined as $x = \\sum_{i=0}^{31} b_{i} \\cdot 2^{i}$, must be transformed into an integer $y$ with the reversed binary representation $b_{0}b_{1}\\dots b_{30}b_{31}$, defined as $y = \\sum_{i=0}^{31} b_{i} \\cdot 2^{31-i}$. The implementation is constrained to use only word-level bitwise operations ($AND$, $OR$, $XOR$, $NOT$) and logical shifts ($\\ll, \\gg$) and must function in $O(1)$ word operations for a $32$-bit word size, precluding algorithms that iterate through bits individually.\n\nA naive approach would be to iterate $i$ from $0$ to $31$, extract the $i$-th bit of $x$, and place it at the $(31-i)$-th position of a result variable. This requires a loop of $32$ iterations, making it an $O(w)$ algorithm where $w=32$ is the word width. This method is explicitly forbidden by the problem's constraints.\n\nThe required efficient algorithm operates on the principle of divide-and-conquer, performing the reversal in stages by swapping progressively smaller, adjacent blocks of bits. For a $32$-bit word, this takes $\\log_2(32) = 5$ stages. Each stage uses a a constant number of bitwise shifts, masks, and logical operations, thus the total complexity is $O(\\log_2 w)$, which is constant for a fixed word size $w=32$. The operations are performed on the entire $32$-bit word simultaneously.\n\nThe algorithm proceeds as follows, starting with the input integer $x$:\n\n1.  **Stage 1: Swap adjacent 16-bit blocks.**\n    The most significant $16$ bits ($b_{31}\\dots b_{16}$) are swapped with the least significant $16$ bits ($b_{15}\\dots b_{0}$). This is achieved by logically shifting the number right by $16$ positions to move the upper half down, and left by $16$ positions to move the lower half up, then combining the results with a bitwise $OR$. For a $32$-bit word, this can be written as:\n    $$x \\leftarrow (x \\gg 16) \\lor (x \\ll 16)$$\n    After this step, the bit order is $b_{15}b_{14}\\dots b_{0}b_{31}b_{30}\\dots b_{16}$.\n\n2.  **Stage 2: Swap adjacent 8-bit blocks.**\n    Within each of the now-swapped $16$-bit segments, the adjacent $8$-bit blocks are swapped. This operation is performed across the entire $32$-bit word. We use a mask to isolate the bits that need to be moved. The mask $0x00FF00FF$ selects the $8$-bit blocks that are in the correct final position after a right shift, and its bitwise complement, $0xFF00FF00$, selects the blocks for the left shift.\n    $$x \\leftarrow ((x \\gg 8) \\land 0x00FF00FF) \\lor ((x \\ll 8) \\land 0xFF00FF00)$$\n    The bit order becomes $b_{7}\\dots b_{0}b_{15}\\dots b_{8}b_{23}\\dots b_{16}b_{31}\\dots b_{24}$.\n\n3.  **Stage 3: Swap adjacent 4-bit blocks (nybbles).**\n    This stage swaps adjacent $4$-bit blocks within each $8$-bit segment, again operating on the full word. The masks $0x0F0F0F0F$ and $0xF0F0F0F0$ are used.\n    $$x \\leftarrow ((x \\gg 4) \\land 0x0F0F0F0F) \\lor ((x \\ll 4) \\land 0xF0F0F0F0)$$\n\n4.  **Stage 4: Swap adjacent 2-bit blocks.**\n    This stage swaps adjacent pairs of bits within each $4$-bit segment. The masks $0x33333333$ (binary $0011\\dots$) and $0xCCCCCCCC$ (binary $1100\\dots$) are used.\n    $$x \\leftarrow ((x \\gg 2) \\land 0x33333333) \\lor ((x \\ll 2) \\land 0xCCCCCCCC)$$\n\n5.  **Stage 5: Swap adjacent 1-bit blocks.**\n    The final stage swaps all adjacent bits (odd-indexed with even-indexed bits). The masks $0x55555555$ (binary $0101\\dots$) and $0xAAAAAAAA$ (binary $1010\\dots$) are used.\n    $$x \\leftarrow ((x \\gg 1) \\land 0x55555555) \\lor ((x \\ll 1) \\land 0xAAAAAAAA)$$\n\nAfter these five stages, the bits of the original integer $x$ are fully reversed, yielding the desired result $y$. The implementation will use `numpy.uint32` to ensure all operations conform to the semantics of fixed-width $32$-bit unsigned arithmetic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes bit-reversals for a test suite of 32-bit unsigned integers\n    and prints the results in the specified format.\n    \"\"\"\n\n    def reverse_bits(x: int) - int:\n        \"\"\"\n        Computes the bit-reversal of a 32-bit unsigned integer using a\n        5-stage divide-and-conquer algorithm with word-level bitwise operations.\n        This algorithm runs in O(1) word operations for a fixed word size.\n\n        Args:\n            x: An integer to be treated as a 32-bit unsigned value.\n\n        Returns:\n            The bit-reversed integer as a 32-bit unsigned value.\n        \"\"\"\n        # Convert to numpy.uint32 to enforce 32-bit unsigned arithmetic.\n        # This correctly handles shifts and overflows as per a 32-bit word,\n        # which is fundamental to the algorithm's correctness.\n        n = np.uint32(x)\n\n        # Stage 1: Swap adjacent 16-bit blocks.\n        # The expression (n  16) moves the upper 16 bits to the lower half,\n        # and (n  16) moves the lower 16 bits to the upper half.\n        # The bitwise OR combines them.\n        n = (n  np.uint32(16)) | (n  np.uint32(16))\n\n        # Stage 2: Swap adjacent 8-bit blocks within each 16-bit block.\n        # The mask 0x00FF00FF isolates the even-indexed 8-bit blocks after a right shift.\n        # The mask 0xFF00FF00 isolates the odd-indexed 8-bit blocks after a left shift.\n        n = ((n  np.uint32(8))  np.uint32(0x00FF00FF)) | ((n  np.uint32(8))  np.uint32(0xFF00FF00))\n\n        # Stage 3: Swap adjacent 4-bit blocks (nybbles) within each 8-bit block.\n        # The masks select alternating nybbles for shifting and merging.\n        n = ((n  np.uint32(4))  np.uint32(0x0F0F0F0F)) | ((n  np.uint32(4))  np.uint32(0xF0F0F0F0))\n\n        # Stage 4: Swap adjacent 2-bit blocks.\n        # The masks 0x33333333 (0011...b) and 0xCCCCCCCC (1100...b) facilitate the swap.\n        n = ((n  np.uint32(2))  np.uint32(0x33333333)) | ((n  np.uint32(2))  np.uint32(0xCCCCCCCC))\n\n        # Stage 5: Swap adjacent 1-bit blocks.\n        # The masks 0x55555555 (0101...b) and 0xAAAAAAAA (1010...b) swap odd/even bits.\n        n = ((n  np.uint32(1))  np.uint32(0x55555555)) | ((n  np.uint32(1))  np.uint32(0xAAAAAAAA))\n\n        # Convert back to a standard Python int for the final list formatting.\n        return int(n)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0,\n        1,\n        4294967295,  # 2**32 - 1\n        43261596,\n        2863311530,  # 0xAAAAAAAA\n        15,\n        2147483649,  # 0x80000001\n        65535,       # 0x0000FFFF\n        4042322160,  # 0xF0F0F0F0\n    ]\n\n    results = []\n    for case in test_cases:\n        result = reverse_bits(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3260780"}]}