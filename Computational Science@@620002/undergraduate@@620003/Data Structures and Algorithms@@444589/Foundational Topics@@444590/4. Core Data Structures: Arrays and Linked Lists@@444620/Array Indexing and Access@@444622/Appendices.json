{"hands_on_practices": [{"introduction": "To truly master array indexing, it's essential to understand how multidimensional arrays are flattened into the one-dimensional reality of computer memory. This practice challenges you to work like a systems programmer or debugger, deducing an array's structure from a raw sequence of memory addresses. By analyzing the memory \"stride\"—the address gap between adjacent elements along each dimension—you will reverse-engineer the array's dimensions and determine whether it uses a row-major or column-major layout [@problem_id:3208033].", "problem": "Consider a three-dimensional array $A$ with zero-based indices $(i,j,k)$, stored contiguously in memory either in row-major order or in column-major order. The dimensions $(D_1,D_2,D_3)$ are unknown positive integers. The element type is fixed-width of $s$ bytes, with $s=8$. There is no padding between elements, rows, planes, or any higher-level slices. Let the base address of $A(0,0,0)$ be $B$, with $B=100000$.\n\nA probe records the following sequences of memory addresses when varying one index at a time while holding the other two fixed:\n\n1. Varying $i$ with $(j,k)=(0,0)$, the addresses observed for $A(0,0,0)$, $A(1,0,0)$, $A(2,0,0)$ are $100000$, $100160$, $100320$.\n2. Varying $j$ with $(i,k)=(0,0)$, the addresses observed for $A(0,0,0)$, $A(0,1,0)$, $A(0,2,0)$ are $100000$, $100032$, $100064$.\n3. Varying $k$ with $(i,j)=(0,0)$, the addresses observed for $A(0,0,0)$, $A(0,0,1)$, $A(0,0,2)$ are $100000$, $100008$, $100016$.\n\nAdditionally, a complete scan of the array over all valid $(i,j,k)$ values reports that the last element encountered has address $100472$.\n\nUsing only the fundamental definitions of contiguous array layout and the distinctions between row-major and column-major storage orders, deduce the dimensions $(D_1,D_2,D_3)$ and identify the storage order. Then, compute the single code value\n$$ C = 10^3 O + 10^2 D_3 + 10^1 D_2 + D_1 $$\nwhere $O=0$ if the array is row-major and $O=1$ if the array is column-major. Provide $C$ as your final answer. No rounding is required, and the answer is unitless.", "solution": "The problem requires deducing the storage order (row-major or column-major) and dimensions $(D_1, D_2, D_3)$ of a three-dimensional array $A$, and then computing a specific code value $C$.\n\n**Step 1: Problem Validation**\n\nThe givens are extracted verbatim:\n- A three-dimensional array $A$ with zero-based indices $(i,j,k)$.\n- Dimensions are $(D_1, D_2, D_3)$, which are unknown positive integers.\n- The array is stored contiguously in memory in either row-major or column-major order.\n- The element size is $s=8$ bytes.\n- There is no padding.\n- The base address is $B = \\text{Address}(A(0,0,0)) = 100000$.\n- Probe 1 (varying $i$ with $(j,k)=(0,0)$): addresses for $A(0,0,0)$, $A(1,0,0)$, $A(2,0,0)$ are $100000$, $100160$, $100320$.\n- Probe 2 (varying $j$ with $(i,k)=(0,0)$): addresses for $A(0,0,0)$, $A(0,1,0)$, $A(0,2,0)$ are $100000$, $100032$, $100064$.\n- Probe 3 (varying $k$ with $(i,j)=(0,0)$): addresses for $A(0,0,0)$, $A(0,0,1)$, $A(0,0,2)$ are $100000$, $100008$, $100016$.\n- The address of the last element, $A(D_1-1, D_2-1, D_3-1)$, is $100472$.\n- The target expression is $C = 10^{3}O + 10^{2}D_3 + 10^{1}D_2 + D_1$, with $O=0$ for row-major and $O=1$ for column-major.\n\nThe problem is scientifically grounded in the principles of data structures and memory layout. It is well-posed, providing sufficient and consistent information to determine a unique solution. The language is objective and precise. Therefore, the problem is valid.\n\n**Step 2: Formalize Address Calculation**\n\nThe memory address of an element $A(i,j,k)$ is calculated based on its indices, the array dimensions, the element size $s$, and the base address $B$. The indices are in the ranges $0 \\le i  D_1$, $0 \\le j  D_2$, and $0 \\le k  D_3$.\n\nIn **row-major order**, the last index, $k$, varies the fastest. The address formula is:\n$$ \\text{Address}(i,j,k)_{\\text{row}} = B + (i \\cdot D_2 \\cdot D_3 + j \\cdot D_3 + k) \\cdot s $$\n\nIn **column-major order**, the first index, $i$, varies the fastest. The address formula is:\n$$ \\text{Address}(i,j,k)_{\\text{col}} = B + (k \\cdot D_1 \\cdot D_2 + j \\cdot D_1 + i) \\cdot s $$\n\n**Step 3: Analyze Probe Data to Determine Strides**\n\nThe stride for a particular index is the difference in memory address when that index is incremented by one, holding other indices constant. We can calculate the strides from the provided probe data.\n\n- **Stride for index $i$ ($S_i$):**\nThis is the address difference between $A(i+1,j,k)$ and $A(i,j,k)$.\nFrom the first probe, we have:\n$S_i = \\text{Address}(A(1,0,0)) - \\text{Address}(A(0,0,0)) = 100160 - 100000 = 160$ bytes.\nThe difference is consistent: $\\text{Address}(A(2,0,0)) - \\text{Address}(A(1,0,0)) = 100320 - 100160 = 160$.\n\n- **Stride for index $j$ ($S_j$):**\nThis is the address difference between $A(i,j+1,k)$ and $A(i,j,k)$.\nFrom the second probe:\n$S_j = \\text{Address}(A(0,1,0)) - \\text{Address}(A(0,0,0)) = 100032 - 100000 = 32$ bytes.\nThe difference is consistent: $\\text{Address}(A(0,2,0)) - \\text{Address}(A(0,1,0)) = 100064 - 100032 = 32$.\n\n- **Stride for index $k$ ($S_k$):**\nThis is the address difference between $A(i,j,k+1)$ and $A(i,j,k)$.\nFrom the third probe:\n$S_k = \\text{Address}(A(0,0,1)) - \\text{Address}(A(0,0,0)) = 100008 - 100000 = 8$ bytes.\nThe difference is consistent: $\\text{Address}(A(0,0,2)) - \\text{Address}(A(0,0,1)) = 100016 - 100008 = 8$.\n\nWe have the empirical strides: $S_i = 160$, $S_j = 32$, and $S_k = 8$. The element size is given as $s=8$.\n\n**Step 4: Deduce Storage Order and Dimensions**\n\nWe now compare the empirical strides with the theoretical strides derived from the address formulas.\n\nFor **row-major order**:\n- $S_i = (\\text{Address}(i+1,j,k) - \\text{Address}(i,j,k)) = ((i+1)D_2 D_3 - i D_2 D_3)s = D_2 D_3 s$\n- $S_j = (\\text{Address}(i,j+1,k) - \\text{Address}(i,j,k)) = ((j+1)D_3 - j D_3)s = D_3 s$\n- $S_k = (\\text{Address}(i,j,k+1) - \\text{Address}(i,j,k)) = ((k+1) - k)s = s$\n\nFor **column-major order**:\n- $S_i = (\\text{Address}(i+1,j,k) - \\text{Address}(i,j,k)) = ((i+1) - i)s = s$\n- $S_j = (\\text{Address}(i,j+1,k) - \\text{Address}(i,j,k)) = ((j+1)D_1 - j D_1)s = D_1 s$\n- $S_k = (\\text{Address}(i,j,k+1) - \\text{Address}(i,j,k)) = ((k+1)D_1 D_2 - k D_1 D_2)s = D_1 D_2 s$\n\nLet's test the two possibilities:\n\n- **Hypothesis 1: The array is in row-major order.**\n  - $S_k = s$. The data gives $S_k = 8$ and $s=8$. This is consistent.\n  - $S_j = D_3 s \\implies 32 = D_3 \\cdot 8 \\implies D_3 = 4$.\n  - $S_i = D_2 D_3 s \\implies 160 = D_2 \\cdot 4 \\cdot 8 \\implies 160 = 32 \\cdot D_2 \\implies D_2 = 5$.\n  This hypothesis is fully consistent with the stride data. We have found $D_2=5$ and $D_3=4$.\n\n- **Hypothesis 2: The array is in column-major order.**\n  - $S_i = s$. The data gives $S_i = 160$ and $s=8$. Since $160 \\neq 8$, this is a contradiction.\n  Therefore, the column-major hypothesis is false.\n\nThe storage scheme must be **row-major order**. This means the parameter $O$ for the final calculation is $O=0$. We have also determined two of the dimensions: $D_2 = 5$ and $D_3 = 4$.\n\n**Step 5: Determine Dimension $D_1$**\n\nThe final piece of information is the address of the last element in the array, which is $A(D_1-1, D_2-1, D_3-1)$. Its address is given as $100472$.\nUsing the row-major address formula:\n$$ \\text{Address}(D_1-1, D_2-1, D_3-1) = B + ((D_1-1)D_2 D_3 + (D_2-1)D_3 + (D_3-1))s $$\nThis expression can be simplified. The total number of elements in the array is $N = D_1 D_2 D_3$. In a zero-based, contiguous 1D representation, the index of the last element is $N-1$.\nThe address of the last element is simply $B + (N-1)s$.\n$$ \\text{Address}(D_1-1, D_2-1, D_3-1) = B + (D_1 D_2 D_3 - 1)s $$\nSubstituting the known values:\n$$ 100472 = 100000 + (D_1 \\cdot 5 \\cdot 4 - 1) \\cdot 8 $$\n$$ 100472 - 100000 = (20 D_1 - 1) \\cdot 8 $$\n$$ 472 = (20 D_1 - 1) \\cdot 8 $$\nDivide both sides by $8$:\n$$ \\frac{472}{8} = 20 D_1 - 1 $$\n$$ 59 = 20 D_1 - 1 $$\n$$ 60 = 20 D_1 $$\n$$ D_1 = \\frac{60}{20} = 3 $$\nSo, the first dimension is $D_1=3$. The dimensions are $(D_1, D_2, D_3) = (3, 5, 4)$. All are positive integers as required.\n\n**Step 6: Compute the Final Code Value $C$**\n\nThe problem asks for the value of $C = 10^{3}O + 10^{2}D_3 + 10^{1}D_2 + D_1$.\nWe have determined:\n- Storage order is row-major, so $O=0$.\n- $D_1 = 3$.\n- $D_2 = 5$.\n- $D_3 = 4$.\n\nSubstituting these values into the expression for $C$:\n$$ C = 10^3 \\cdot 0 + 10^2 \\cdot 4 + 10^1 \\cdot 5 + 3 $$\n$$ C = 0 + 100 \\cdot 4 + 10 \\cdot 5 + 3 $$\n$$ C = 400 + 50 + 3 $$\n$$ C = 453 $$\nThe final code value is $453$.", "answer": "$$\\boxed{453}$$", "id": "3208033"}, {"introduction": "Standard dense arrays can be wasteful for data structures like triangular matrices where many elements are predictably zero. This exercise guides you through designing an efficient, compact storage scheme that avoids storing the unused half of the matrix. You will derive the indexing formula from first principles, a crucial skill for implementing custom data structures and optimizing memory usage [@problem_id:3208085].", "problem": "You are given an $n \\times n$ upper-triangular matrix $M$ with zero-based indexing, where entries $M[i,j]$ may be nonzero only when $i \\leq j$. The matrix is stored compactly in a one-dimensional array $A$ using row-major compaction as follows: for each row $r$ from $r=0$ to $r=n-1$, the elements $M[r,c]$ with $c$ ranging from $c=r$ to $c=n-1$ are stored contiguously in $A$ in increasing order of $c$, and elements with $ij$ are not stored at all. The function $get(i,j)$, for indices $i,j$ with $0 \\leq i \\leq j \\leq n-1$, retrieves $M[i,j]$ by reading a single position of $A$ determined by an index mapping $p(i,j)$ that depends only on $i$, $j$, and $n$.\n\nStarting only from the foundational definitions of zero-based array indexing and row-major compaction, and using well-tested facts about finite sums of arithmetic progressions, derive a closed-form analytic expression for the unique index mapping $p(i,j)$ such that $A[p(i,j)]$ is exactly the stored location of $M[i,j]$ for all $0 \\leq i \\leq j \\leq n-1$. Your final answer should be the expression for $p(i,j)$ as a function of $i$, $j$, and $n$. No approximation or rounding is required.", "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- An $n \\times n$ upper-triangular matrix $M$.\n- Zero-based indexing is used, with indices $i, j$ such that $0 \\leq i, j \\leq n-1$.\n- Matrix entries $M[i,j]$ may be nonzero only for $i \\leq j$.\n- The matrix is stored in a one-dimensional array $A$.\n- The storage scheme is row-major compaction.\n- For each row $r$ from $r=0$ to $r=n-1$, the elements $M[r,c]$ for $c$ from $c=r$ to $c=n-1$ are stored contiguously in $A$.\n- Elements with $i  j$ are not stored.\n- A function `get(i,j)` for $0 \\leq i \\leq j \\leq n-1$ retrieves $M[i,j]$ by accessing $A[p(i,j)]$.\n- The index mapping $p(i,j)$ depends only on $i$, $j$, and $n$.\n- The task is to derive a closed-form analytic expression for $p(i,j)$.\n- The derivation must be from foundational principles and use facts about arithmetic progressions.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem is a standard exercise in computer science, dealing with the memory layout of sparse matrices. It is based on discrete mathematics and algorithmic principles. It is scientifically sound.\n- **Well-Posed:** The storage scheme is unambiguously defined. As the storage order is deterministic, a unique mapping function $p(i,j)$ exists. The problem is self-contained and has a unique, stable solution.\n- **Objective:** The problem is stated using precise, formal language. There are no subjective or ambiguous terms.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a well-posed, formal problem in data structures and algorithm analysis. A solution will be derived.\n\nThe derivation of the index mapping function $p(i,j)$ proceeds from first principles. The array $A$ uses zero-based indexing, meaning its indices run from $0$ up to the total number of stored elements minus $1$. The index $p(i,j)$ of the element $M[i,j]$ is the sum of two components:\n$1$. The total number of elements stored from all rows that precede row $i$.\n$2$. The zero-based offset of the element at column $j$ within row $i$.\n\nLet us formalize and calculate each component.\n\nFirst, we determine the number of elements stored for an arbitrary row $r$, where $0 \\leq r \\leq n-1$. According to the storage scheme, for row $r$, the elements $M[r,c]$ are stored for columns $c$ from $r$ to $n-1$. The number of such columns is $(n-1) - r + 1 = n-r$. Therefore, row $r$ contributes $n-r$ elements to the array $A$.\n\nNext, we calculate the total number of elements stored from all rows preceding row $i$. These are the rows $r=0, 1, \\dots, i-1$. The total count is the sum of the number of elements in each of these rows:\n$$ \\sum_{r=0}^{i-1} (n-r) $$\nThis sum can be evaluated as follows:\n$$ \\sum_{r=0}^{i-1} (n-r) = \\sum_{r=0}^{i-1} n - \\sum_{r=0}^{i-1} r $$\nThe first term is the sum of a constant $n$ over $i$ terms, which is $ni$. The second term is the sum of the first $i-1$ non-negative integers. Using the well-known formula for the sum of an arithmetic progression, $\\sum_{k=0}^{m-1} k = \\frac{(m-1)m}{2}$, with $m=i$, we have:\n$$ \\sum_{r=0}^{i-1} r = \\frac{(i-1)i}{2} $$\nTherefore, the total number of elements from rows $0$ to $i-1$ is:\n$$ ni - \\frac{i(i-1)}{2} $$\nThis value represents the number of elements that come before the first element of row $i$. Since array $A$ is zero-based, the block of elements for row $i$ begins at index $ni - \\frac{i(i-1)}{2}$.\n\nNow, we determine the offset within row $i$. The elements of row $i$ are stored in increasing order of their column index, starting from column $c=i$. The sequence of stored elements is $M[i,i], M[i,i+1], M[i,i+2], \\dots, M[i,j], \\dots$. The first element, $M[i,i]$, has a zero-based offset of $0$ within its row's block. The element $M[i,i+1]$ has an offset of $1$, and so on. The element $M[i,j]$ corresponds to a column index $j$. The zero-based offset of this element relative to the start of its row's data is given by the difference in column indices:\n$$ \\text{offset} = j - i $$\n\nThe final index $p(i,j)$ is the starting index of row $i$'s block plus the offset within that block.\n$$ p(i,j) = \\left( ni - \\frac{i(i-1)}{2} \\right) + (j-i) $$\nWe can simplify this expression algebraically to obtain a more compact closed form.\n$$ p(i,j) = ni + j - i - \\frac{i(i-1)}{2} $$\n$$ p(i,j) = ni + j - \\left( i + \\frac{i^2-i}{2} \\right) $$\n$$ p(i,j) = ni + j - \\left( \\frac{2i + i^2 - i}{2} \\right) $$\n$$ p(i,j) = ni + j - \\left( \\frac{i^2 + i}{2} \\right) $$\n$$ p(i,j) = ni + j - \\frac{i(i+1)}{2} $$\nThis expression represents the unique index mapping $p(i,j)$ for any valid pair of indices $(i,j)$ where $0 \\leq i \\leq j \\leq n-1$.", "answer": "$$\n\\boxed{ni + j - \\frac{i(i+1)}{2}}\n$$", "id": "3208085"}, {"introduction": "What if you could swap two entire rows of a massive matrix almost instantly? This practice introduces the powerful concept of indirection, where a layer of pointers or indices separates the logical structure of an array from its physical storage. By manipulating this \"indirection vector,\" you will implement a data structure that achieves constant-time, $O(1)$, row swaps—an operation that would be prohibitively slow in a conventional row-major layout [@problem_id:3208065].", "problem": "Consider a two-dimensional array abstraction over Random Access Memory (RAM) where accessing any entry by its index is constant time, denoted by $O(1)$. In the conventional row-major representation, the address of element $A[i][j]$ is computed from the base address and the linear offset using the stride (number of columns). Specifically, the linear offset under row-major layout is $i \\cdot m + j$, where $i$ is the row index, $j$ is the column index, and $m$ is the number of columns. In languages and systems with explicit pointers, one can represent a two-dimensional array as an array of pointers to row blocks. In such a design, swapping entire rows can be achieved by swapping the corresponding pointers in the pointer array rather than moving the row data, which in principle is $O(1)$.\n\nYour task is to design a two-dimensional array data structure that supports constant-time row swaps by manipulating an internal array of row references, while preserving $O(1)$ indexing. You will then implement this design as a complete, runnable program that executes a deterministic test suite and outputs the results in the specified format.\n\nRequirements and constraints:\n- The data structure must maintain:\n  - A storage of $n$ row blocks, each of length $m$, containing the actual values.\n  - A row indirection vector $R$ of length $n$ such that the value at logical coordinates $\\langle i, j \\rangle$ is retrieved as the value in the physical storage row indexed by $R[i]$ at column $j$.\n- The operations to support are:\n  - `get(i,j)`: return the logical value at row $i$ and column $j$ in $O(1)$.\n  - `set(i,j,v)`: set the logical value at row $i$ and column $j$ to $v$ in $O(1)$.\n  - `row_swap(i,k)`: swap entire logical rows $i$ and $k$ in $O(1)$ by updating the indirection vector $R$.\n  - `sum_row(i)`: return the sum of all values in the logical row $i$; this operation may take $O(m)$ time.\n- You must justify, in your solution, why each of `get(i,j)`, `set(i,j,v)`, and `row_swap(i,k)` is $O(1)$ under the unit-cost RAM model.\n\nInitialization rule for the test suite:\n- For each test case, initialize the storage rows so that the value at physical storage row $i$ and column $j$ is defined by a function $f(i,j)$ given per case.\n\nTest suite specification:\n- Implement the following four test cases to probe different facets of correctness:\n\n  Case $1$ (general case):\n  - Parameters: $n = 3$, $m = 4$, and $f(i,j) = 10 \\cdot i + j$.\n  - Operations and recorded results:\n    - $r_1$: `get(1,2)` before any swaps.\n    - Perform `row_swap(0,2)`.\n    - $r_2$: `get(0,3)` after the swap.\n    - Perform `set(2,1,999)`.\n    - $r_3$: `get(2,1)` after the set.\n    - $r_4$: `sum_row(0)` after all operations.\n\n  Case $2$ (single row boundary):\n  - Parameters: $n = 1$, $m = 5$, and $f(i,j) = i + j$.\n  - Operations and recorded results:\n    - $r_1$: `get(0,4)` before any swaps.\n    - Perform `row_swap(0,0)`.\n    - $r_2$: `get(0,4)` after the swap.\n    - Perform `set(0,2,50)`.\n    - $r_3$: `get(0,2)` after the set.\n    - $r_4$: `sum_row(0)` after all operations.\n\n  Case $3$ (single column boundary):\n  - Parameters: $n = 4$, $m = 1$, and $f(i,j) = 100 \\cdot i + j$.\n  - Operations and recorded results:\n    - $r_1$: `get(3,0)` before any swaps.\n    - Perform `row_swap(3,0)`.\n    - $r_2$: `get(3,0)` after the swap.\n    - Perform `set(0,0,7)`.\n    - $r_3$: `get(0,0)` after the set.\n    - $r_4$: `sum_row(0)` after all operations.\n\n  Case $4$ (composition of multiple swaps):\n  - Parameters: $n = 5$, $m = 3$, and $f(i,j) = i \\cdot m + j$.\n  - Operations and recorded results:\n    - $r_1$: `get(2,1)` before any swaps.\n    - Perform `row_swap(0,4)`, then `row_swap(1,3)`, then `row_swap(0,1)`.\n    - $r_2$: `get(2,1)` after the swaps.\n    - Perform `set(4,2,12345)`.\n    - $r_3$: `get(4,2)` after the set.\n    - $r_4$: `sum_row(0)` after all operations.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all four cases as a comma-separated list enclosed in square brackets with no whitespace. Each case’s results must be a bracketed comma-separated list of four integers. For example, the output must look like `[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],[c_1,c_2,c_3,c_4],[d_1,d_2,d_3,d_4]]` where each symbol denotes an integer produced by the specified operations in its case.", "solution": "The problem requires the design and implementation of a two-dimensional array data structure that supports constant-time row swaps. This is achieved by using a layer of indirection, where logical row indices are mapped to physical row indices.\n\nThe proposed data structure consists of two primary components:\n$1$. A physical storage array, denoted as $S$, of dimensions $n \\times m$. This array holds the actual data elements. In our implementation, this will be a `NumPy` array.\n$2$. A row indirection vector, denoted as $R$, of length $n$. This vector stores the mapping from logical row indices to physical row indices. Initially, for all logical row indices $i$ from $0$ to $n-1$, $R[i]$ is set to $i$, representing a direct one-to-one mapping.\n\nThe logical value at coordinates $\\langle i, j \\rangle$ is accessed by first finding the physical row index from the indirection vector, `physical_row_index = R[i]`, and then accessing the element at `S[physical_row_index][j]`.\n\nThe operations are implemented as follows:\n\n- `get(i, j)`: To retrieve the value at logical row $i$ and logical column $j$, the data structure performs two lookups. First, it accesses the indirection vector $R$ at index $i$ to find the physical row index, let's call it $p_i = R[i]$. Second, it accesses the physical storage $S$ at row $p_i$ and column $j$. The value is $S[p_i][j]$.\n  - **Complexity Justification**: Under the unit-cost Random Access Memory (RAM) model, accessing an element of an array by its index is a constant-time operation, denoted as $O(1)$. The `get` operation consists of two such array accesses: one on $R$ and one on $S$. A constant number of $O(1)$ operations results in an overall time complexity of $O(1)$.\n\n- `set(i, j, v)`: To set the value at logical row $i$ and logical column $j$ to a new value $v$, the procedure is analogous to `get`. It first resolves the physical row index $p_i = R[i]$ and then assigns the new value to the element at `S[p_i][j]`.\n  - **Complexity Justification**: This operation involves one array lookup on $R$ and one array write to $S$. Both are $O(1)$ operations in the RAM model. Therefore, the `set` operation has a time complexity of $O(1)$.\n\n- `row_swap(i, k)`: To swap the logical rows $i$ and $k$, the data structure manipulates only the indirection vector $R$. It swaps the values stored at indices $i$ and $k$ within $R$. That is, the values $R[i]$ and $R[k]$ are exchanged. The physical storage $S$, which contains the bulk of the data, remains untouched.\n  - **Complexity Justification**: Swapping two elements in an array requires a fixed number of operations (typically three assignments using a temporary variable). Since the number of operations is independent of the size of the array ($n$) or the rows ($m$), the `row_swap` operation has a time complexity of $O(1)$. This is the key advantage of the indirection-based design.\n\n- `sum_row(i)`: To calculate the sum of all elements in logical row $i$, the structure first finds the corresponding physical row index $p_i = R[i]$ in $O(1)$ time. It then needs to iterate through all $m$ elements of the physical row $S[p_i]$ and accumulate their sum.\n  - **Complexity Analysis**: This operation involves one $O(1)$ lookup followed by a loop that performs $m-1$ additions. The total time is proportional to the number of columns, $m$. Therefore, the `sum_row` operation has a time complexity of $O(m)$.\n\nLet us trace the execution for Case $1$ to demonstrate the mechanics.\n- Parameters: $n = 3$, $m = 4$, and $f(i,j) = 10 \\cdot i + j$.\n- Initial state:\n  - The physical storage $S$ is a $3 \\times 4$ matrix where $S_{i,j} = 10 \\cdot i + j$:\n  $$S = \\begin{pmatrix} 0  1  2  3 \\\\ 10  11  12  13 \\\\ 20  21  22  23 \\end{pmatrix}$$\n  - The indirection vector $R$ is initialized to `[0, 1, 2]`.\n- Operation $1$: $r_1 = \\text{get}(1,2)$.\n  - The logical row is $i=1$. The physical row is $R[1]=1$.\n  - The value is $S[1][2] = 12$. Thus, $r_1=12$.\n- Operation $2$: Perform `row_swap(0,2)`.\n  - Swap $R[0]$ and $R[2]$.\n  - $R$ was `[0, 1, 2]`. Now $R = [2, 1, 0]$.\n- Operation $3$: $r_2 = \\text{get}(0,3)$.\n  - The logical row is $i=0$. The physical row is $R[0]=2$.\n  - The value is $S[2][3] = 23$. Thus, $r_2=23$.\n- Operation $4$: Perform `set(2,1,999)`.\n  - The logical row is $i=2$. The physical row is $R[2]=0$.\n  - Set $S[0][1]$ to $999$. The first row of $S$ becomes `[0, 999, 2, 3]`.\n- Operation $5$: $r_3 = \\text{get}(2,1)$.\n  - The logical row is $i=2$. The physical row is $R[2]=0$.\n  - The value is $S[0][1] = 999$. Thus, $r_3=999$.\n- Operation $6$: $r_4 = \\text{sum_row}(0)$.\n  - The logical row is $i=0$. The physical row is $R[0]=2$.\n  - Sum the elements of row $2$ in $S$: $20+21+22+23 = 86$. Thus, $r_4=86$.\n- The results for Case $1$ are `[12, 23, 999, 86]`. The other cases are solved by applying the same logic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass IndirectionArray:\n    \"\"\"\n    A 2D array supporting O(1) row swaps via an indirection vector.\n    \"\"\"\n    def __init__(self, n, m, f):\n        \"\"\"\n        Initializes the data structure.\n\n        Args:\n            n (int): The number of rows.\n            m (int): The number of columns.\n            f (callable): A function f(i, j) to populate the initial storage.\n        \"\"\"\n        self.n = n\n        self.m = m\n        \n        # Physical storage for the array data.\n        self.storage = np.zeros((n, m), dtype=np.int64)\n        if n > 0: # Handle n=0 case\n            for i in range(n):\n                for j in range(m):\n                    self.storage[i, j] = f(i, j)\n        \n        # Indirection vector mapping logical rows to physical rows.\n        # Initially, it's a direct mapping: logical row i -> physical row i.\n        self.row_indices = np.arange(n)\n\n    def get(self, i, j):\n        \"\"\"\n        Returns the value at logical row i and column j in O(1).\n        \"\"\"\n        physical_row = self.row_indices[i]\n        return self.storage[physical_row, j]\n\n    def set(self, i, j, v):\n        \"\"\"\n        Sets the value at logical row i and column j to v in O(1).\n        \"\"\"\n        physical_row = self.row_indices[i]\n        self.storage[physical_row, j] = v\n\n    def row_swap(self, i, k):\n        \"\"\"\n        Swaps logical rows i and k in O(1).\n        \"\"\"\n        self.row_indices[i], self.row_indices[k] = self.row_indices[k], self.row_indices[i]\n\n    def sum_row(self, i):\n        \"\"\"\n        Returns the sum of values in logical row i in O(m).\n        \"\"\"\n        physical_row = self.row_indices[i]\n        return np.sum(self.storage[physical_row, :])\n\n\ndef solve():\n    \"\"\"\n    Executes the deterministic test suite and prints the final result.\n    \"\"\"\n    all_results = []\n\n    # Case 1 (general case)\n    case1_params = {'n': 3, 'm': 4, 'f': lambda i, j: 10 * i + j}\n    arr1 = IndirectionArray(**case1_params)\n    results1 = []\n    results1.append(arr1.get(1, 2))\n    arr1.row_swap(0, 2)\n    results1.append(arr1.get(0, 3))\n    arr1.set(2, 1, 999)\n    results1.append(arr1.get(2, 1))\n    results1.append(arr1.sum_row(0))\n    all_results.append(results1)\n\n    # Case 2 (single row boundary)\n    case2_params = {'n': 1, 'm': 5, 'f': lambda i, j: i + j}\n    arr2 = IndirectionArray(**case2_params)\n    results2 = []\n    results2.append(arr2.get(0, 4))\n    arr2.row_swap(0, 0)\n    results2.append(arr2.get(0, 4))\n    arr2.set(0, 2, 50)\n    results2.append(arr2.get(0, 2))\n    results2.append(arr2.sum_row(0))\n    all_results.append(results2)\n\n    # Case 3 (single column boundary)\n    case3_params = {'n': 4, 'm': 1, 'f': lambda i, j: 100 * i + j}\n    arr3 = IndirectionArray(**case3_params)\n    results3 = []\n    results3.append(arr3.get(3, 0))\n    arr3.row_swap(3, 0)\n    results3.append(arr3.get(3, 0))\n    arr3.set(0, 0, 7)\n    results3.append(arr3.get(0, 0))\n    results3.append(arr3.sum_row(0))\n    all_results.append(results3)\n\n    # Case 4 (composition of multiple swaps)\n    case4_params = {'n': 5, 'm': 3, 'f': lambda i, j: i * 3 + j}\n    arr4 = IndirectionArray(**case4_params)\n    results4 = []\n    results4.append(arr4.get(2, 1))\n    arr4.row_swap(0, 4)\n    arr4.row_swap(1, 3)\n    arr4.row_swap(0, 1)\n    results4.append(arr4.get(2, 1))\n    arr4.set(4, 2, 12345)\n    results4.append(arr4.get(4, 2))\n    results4.append(arr4.sum_row(0))\n    all_results.append(results4)\n\n    # Format the final output string as specified.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3208065"}]}