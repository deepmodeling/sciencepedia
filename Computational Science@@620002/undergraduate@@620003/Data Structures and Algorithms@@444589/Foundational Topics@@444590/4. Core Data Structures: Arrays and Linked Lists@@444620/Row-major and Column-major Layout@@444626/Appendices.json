{"hands_on_practices": [{"introduction": "Before we can calculate memory addresses, we must first visualize how a matrix is \"unrolled\" into a one-dimensional sequence, a process known as vectorization. This exercise [@problem_id:29608] solidifies the fundamental difference between row-major and column-major order by having you manually construct the linearized versions of a simple matrix. Mastering this visualization is the first step toward understanding the performance implications of memory layout.", "problem": "In linear algebra, the vectorization of a matrix is a linear transformation that converts the matrix into a column vector. This process is fundamental in various areas, including matrix calculus and machine learning. There are two common ways to vectorize a matrix: row-major order and column-major order.\n\n**Definitions:**\n\n1.  **Row-Major Vectorization**: For an $m \\times n$ matrix $A$, its row-major vectorization, denoted as $\\text{vec}_r(A)$, is the $mn \\times 1$ column vector obtained by stacking the rows of the matrix one after another. If $A = [a_{ij}]$, the elements of $\\text{vec}_r(A)$ are ordered as:\n    $$ \\text{vec}_r(A) = [a_{11}, a_{12}, \\dots, a_{1n}, a_{21}, a_{22}, \\dots, a_{2n}, \\dots, a_{m1}, a_{m2}, \\dots, a_{mn}]^T $$\n\n2.  **Column-Major Vectorization**: For an $m \\times n$ matrix $A$, its column-major vectorization, denoted as $\\text{vec}_c(A)$, is the $mn \\times 1$ column vector obtained by stacking the columns of the matrix one after another. If $A = [a_{ij}]$, the elements of $\\text{vec}_c(A)$ are ordered as:\n    $$ \\text{vec}_c(A) = [a_{11}, a_{21}, \\dots, a_{m1}, a_{12}, a_{22}, \\dots, a_{m2}, \\dots, a_{1n}, a_{2n}, \\dots, a_{mn}]^T $$\n\n**Problem:**\n\nConsider the following $2 \\times 3$ matrix $A$ with symbolic entries:\n$$ A = \\begin{pmatrix} a & b & c \\\\ d & e & f \\end{pmatrix} $$\nLet $\\mathbf{v}_r = \\text{vec}_r(A)$ and $\\mathbf{v}_c = \\text{vec}_c(A)$ be the row-major and column-major vectorizations of $A$, respectively.\n\n**Task:**\n\nDerive a simplified, factored expression for the scalar product (or dot product) $S = \\mathbf{v}_r^T \\mathbf{v}_c$.", "solution": "The problem asks for the scalar product of the row-major and column-major vectorizations of a given $2 \\times 3$ matrix $A$. We will first determine each vectorized form and then compute their scalar product.\n\n**Step 1: Determine the row-major vectorization $\\mathbf{v}_r$.**\n\nThe matrix is given by:\n$$ A = \\begin{pmatrix} a & b & c \\\\ d & e & f \\end{pmatrix} $$\nAccording to the definition of row-major vectorization, we stack the rows of the matrix.\nThe first row is $[a, b, c]$.\nThe second row is $[d, e, f]$.\nStacking the second row after the first gives the column vector $\\mathbf{v}_r$:\n$$ \\mathbf{v}_r = \\begin{pmatrix} a \\\\ b \\\\ c \\\\ d \\\\ e \\\\ f \\end{pmatrix} $$\n\n**Step 2: Determine the column-major vectorization $\\mathbf{v}_c$.**\n\nAgain, starting with the matrix $A$:\n$$ A = \\begin{pmatrix} a & b & c \\\\ d & e & f \\end{pmatrix} $$\nAccording to the definition of column-major vectorization, we stack the columns of the matrix.\nThe first column is $\\begin{pmatrix} a \\\\ d \\end{pmatrix}$.\nThe second column is $\\begin{pmatrix} b \\\\ e \\end{pmatrix}$.\nThe third column is $\\begin{pmatrix} c \\\\ f \\end{pmatrix}$.\nStacking these columns sequentially gives the column vector $\\mathbf{v}_c$:\n$$ \\mathbf{v}_c = \\begin{pmatrix} a \\\\ d \\\\ b \\\\ e \\\\ c \\\\ f \\end{pmatrix} $$\n\n**Step 3: Compute the scalar product $S = \\mathbf{v}_r^T \\mathbf{v}_c$.**\n\nThe scalar product is the sum of the products of the corresponding components of the two vectors.\n$$ S = \\mathbf{v}_r^T \\mathbf{v}_c = \\begin{pmatrix} a & b & c & d & e & f \\end{pmatrix} \\begin{pmatrix} a \\\\ d \\\\ b \\\\ e \\\\ c \\\\ f \\end{pmatrix} $$\nPerforming the matrix multiplication gives:\n$$ S = (a)(a) + (b)(d) + (c)(b) + (d)(e) + (e)(c) + (f)(f) $$\nSimplifying the products, we get:\n$$ S = a^2 + bd + bc + de + ec + f^2 $$\nTo obtain a simplified, factored expression, we can rearrange the terms. Let's group the squared terms and the cross-terms:\n$$ S = a^2 + f^2 + (bc + bd) + (de + ec) $$\nNow, we can factor out common terms from the parenthesized expressions:\n$$ S = a^2 + f^2 + b(c + d) + e(c + d) $$\nFinally, we can factor out the common term $(c+d)$:\n$$ S = a^2 + f^2 + (b+e)(c+d) $$\nThis is the final simplified and factored expression for the scalar product.", "answer": "$$ \\boxed{a^2 + f^2 + (b+e)(c+d)} $$", "id": "29608"}, {"introduction": "Understanding the theory of memory layouts is one thing; implementing it is another, and a robust data structure must be able to correctly locate elements regardless of the chosen storage scheme. This practice [@problem_id:3267656] challenges you to move from theory to implementation by deriving the offset calculation formulas from first principles. You will build a layout-aware matrix abstraction that correctly handles both row-major and column-major ordering, as well as crucial edge cases like bounds checking.", "problem": "You are tasked with formalizing and implementing a layout-aware matrix indexing scheme based on fundamental definitions of array storage. Consider a two-dimensional ($2$-D) array (matrix) with $R$ rows and $C$ columns stored in contiguous memory as a single linear sequence of elements. The core definitions to use are: contiguous memory stores elements in a one-dimensional sequence; bounds on valid indices are $0 \\leq i < R$ and $0 \\leq j < C$ for row index $i$ and column index $j$; and a layout determines which dimension is contiguous in memory. In a row-major layout, entire rows are contiguous; in a column-major layout, entire columns are contiguous. There is no provided formula for mapping two-dimensional indices to linear offsets.\n\nYour task is to derive, from the above definitions alone, a correct method for mapping a matrix element at coordinate $(i,j)$ to its linear memory offset based on a parameterized layout flag $L \\in \\{\\text{RowMajor}, \\text{ColMajor}\\}$, and to implement a complete program that emulates a template class $\\text{Matrix}\\langle T, R, C, L \\rangle$ with layout-dependent indexing. The program must construct a matrix-like abstraction that:\n- Stores $R$ and $C$ as its shape and a layout flag $L$ determining whether rows or columns are contiguous.\n- Computes a linear offset function for a given $(i,j)$ that returns an integer offset if the indices are within bounds or a sentinel value of $-1$ for out-of-bounds indices.\n- Provides methods consistent with the concept of an indexing operator that rely on this offset function, without relying on any external hints or pre-derived formulas.\n\nThe program must not read any input. Instead, it must execute a fixed test suite of parameter values and report the computed offsets. Use the following test suite, where each test case is a tuple $(R,C,L,i,j)$:\n- Test case $1$: $(R,C,L,i,j) = (3,4,\\text{RowMajor},2,1)$.\n- Test case $2$: $(R,C,L,i,j) = (3,4,\\text{ColMajor},2,1)$.\n- Test case $3$: $(R,C,L,i,j) = (1,5,\\text{RowMajor},0,3)$.\n- Test case $4$: $(R,C,L,i,j) = (5,1,\\text{ColMajor},4,0)$.\n- Test case $5$: $(R,C,L,i,j) = (3,4,\\text{RowMajor},-1,0)$.\n- Test case $6$: $(R,C,L,i,j) = (3,4,\\text{RowMajor},3,0)$.\n- Test case $7$: $(R,C,L,i,j) = (2,2,\\text{RowMajor},1,1)$.\n- Test case $8$: $(R,C,L,i,j) = (4,3,\\text{ColMajor},3,2)$.\n\nDesign your solution to reflect different facets:\n- A general case in which both dimensions exceed $1$ and the indices are interior.\n- Boundary conditions including the first and last valid elements.\n- Edge cases such as a single row ($R=1$) or a single column ($C=1$).\n- Out-of-bounds indices including negative indices and indices equal to a dimension size.\n\nYour program should produce a single line of output containing the results of all test cases as a comma-separated list enclosed in square brackets, for example, $\\texttt{[result1,result2,\\dots]}$. The results must be integers as defined above and appear in the same order as the test suite.", "solution": "The problem statement has been meticulously reviewed and is determined to be valid. It is scientifically grounded in the fundamental principles of data structures, is well-posed with sufficient information for a unique solution, and is expressed in objective, formal language. The task is to derive and implement a mapping from $2$-dimensional array indices to a $1$-dimensional memory offset without recourse to pre-existing formulas, which is a standard and valuable exercise in computer science.\n\nThe derivation proceeds from the first principles provided. A $2$-D array of $R$ rows and $C$ columns is stored as a contiguous $1$-D block of memory. We seek a function $\\text{offset}(i, j)$ that maps the row index $i$ and column index $j$, where $0 \\le i < R$ and $0 \\le j < C$, to a unique $0$-based linear memory offset. The mapping is determined by the storage layout, specified by the parameter $L$.\n\nFirst, a necessary condition for a valid offset is that the indices $(i,j)$ must be within the defined bounds of the matrix. If either $i  0$, $i \\ge R$, $j  0$, or $j \\ge C$ is true, the access is out-of-bounds. In such cases, the function must return the specified sentinel value of $-1$.\n\nFor in-bounds indices, we consider the two possible layouts: $L \\in \\{\\text{RowMajor}, \\text{ColMajor}\\}$.\n\n**Row-Major Layout**\nThe definition of row-major layout states that entire rows are stored contiguously in memory. This means the elements of row $0$ are followed by the elements of row $1$, and so on. The memory is structured as a sequence of row blocks: $[\\text{Row}_0, \\text{Row}_1, \\dots, \\text{Row}_{i}, \\dots, \\text{Row}_{R-1}]$.\nTo locate the element at $(i, j)$, we must first traverse all rows preceding row $i$. There are $i$ such rows (from row $0$ to row $i-1$). Each row contains $C$ elements (one for each column). Therefore, the number of elements in these preceding $i$ rows is $i \\times C$. This value constitutes the base offset to reach the beginning of row $i$.\nWithin row $i$, elements are stored by their column index from $0$ to $C-1$. The element at column $j$ is the $j$-th element (using $0$-based indexing) inside this row block. Thus, we add an additional offset of $j$ to the base offset.\nCombining these, the total linear offset for an element at $(i,j)$ in a row-major layout is given by the sum of the offset from preceding rows and the offset within the current row:\n$$\n\\text{offset}_{\\text{row-major}}(i, j) = (i \\times C) + j\n$$\n\n**Column-Major Layout**\nThe definition of column-major layout states that entire columns are stored contiguously. This implies the memory is structured as a sequence of column blocks: $[\\text{Col}_0, \\text{Col}_1, \\dots, \\text{Col}_j, \\dots, \\text{Col}_{C-1}]$.\nTo locate the element at $(i, j)$, we must first traverse all columns preceding column $j$. There are $j$ such columns (from column $0$ to column $j-1$). Each column contains $R$ elements (one for each row). Therefore, the number of elements in these preceding $j$ columns is $j \\times R$. This value is the base offset to reach the beginning of column $j$.\nWithin column $j$, elements are stored by their row index from $0$ to $R-1$. The element at row $i$ is the $i$-th element (using $0$-based indexing) inside this column block. We add an additional offset of $i$ to the base offset.\nCombining these, the total linear offset for an element at $(i,j)$ in a column-major layout is given by:\n$$\n\\text{offset}_{\\text{col-major}}(i, j) = (j \\times R) + i\n$$\n\nThis completes the derivation from first principles. The implementation will encapsulate this logic, first performing the bounds check and then applying the appropriate formula based on the layout parameter $L$.\n\nThe test cases in the problem statement serve to verify this logic across various scenarios:\n- **General Case**: Test cases $1$ and $2$ use a matrix of size $3 \\times 4$ and interior indices $(2,1)$, demonstrating the fundamental difference between the two layouts.\n- **Last Element**: Test cases $7$ and $8$ check the calculation for the very last element in the memory block, which is $(1,1)$ for a $2 \\times 2$ row-major matrix and $(3,2)$ for a $4 \\times 3$ column-major matrix.\n- **Edge Cases**: Test cases $3$ and $4$ examine matrices that are effectively $1$-D vectors (a single row or a single column), confirming the formulas generalize correctly.\n- **Out-of-Bounds Indices**: Test cases $5$ and $6$ validate the mandatory bounds checking, using both a negative index ($-1$) and an index equal to a dimension size ($3$ for a dimension of size $3$), both of which are invalid.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Matrix:\n    \"\"\"\n    Emulates a matrix-like abstraction to compute linear memory offsets\n    based on a parameterized layout (RowMajor or ColMajor).\n    \n    The offset calculation is derived from first principles of data layout.\n    \"\"\"\n    def __init__(self, R: int, C: int, L: str):\n        \"\"\"\n        Initializes the Matrix with its dimensions and layout.\n        \n        Args:\n            R (int): The number of rows.\n            C (int): The number of columns.\n            L (str): The memory layout, \"RowMajor\" or \"ColMajor\".\n        \"\"\"\n        self.R = R\n        self.C = C\n        self.layout = L\n\n    def get_offset(self, i: int, j: int) -> int:\n        \"\"\"\n        Computes the linear memory offset for an element at coordinate (i, j).\n        \n        Args:\n            i (int): The row index.\n            j (int): The column index.\n            \n        Returns:\n            int: The 0-based linear offset if indices are valid,\n                 or -1 if indices are out-of-bounds.\n        \"\"\"\n        # Step 1: Validate index bounds as per the problem definition (0 = index  dimension).\n        if not (0 = i  self.R and 0 = j  self.C):\n            return -1\n\n        # Step 2: Apply the derived formula based on the layout.\n        if self.layout == \"RowMajor\":\n            # Formula: offset = (i * C) + j\n            # Derived from skipping 'i' full rows of 'C' elements each,\n            # then moving 'j' elements into the current row.\n            return i * self.C + j\n        elif self.layout == \"ColMajor\":\n            # Formula: offset = (j * R) + i\n            # Derived from skipping 'j' full columns of 'R' elements each,\n            # then moving 'i' elements into the current column.\n            return j * self.R + i\n        else:\n            # This case should not be reached given the problem constraints.\n            # It is included for robustness.\n            raise ValueError(\"Invalid layout specified. Must be 'RowMajor' or 'ColMajor'.\")\n\ndef solve():\n    \"\"\"\n    Executes the fixed test suite and prints the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (R, C, Layout, i, j)\n    test_cases = [\n        (3, 4, \"RowMajor\", 2, 1),\n        (3, 4, \"ColMajor\", 2, 1),\n        (1, 5, \"RowMajor\", 0, 3),\n        (5, 1, \"ColMajor\", 4, 0),\n        (3, 4, \"RowMajor\", -1, 0),\n        (3, 4, \"RowMajor\", 3, 0),\n        (2, 2, \"RowMajor\", 1, 1),\n        (4, 3, \"ColMajor\", 3, 2),\n    ]\n\n    results = []\n    for R, C, L, i, j in test_cases:\n        # Instantiate the Matrix abstraction for the current test case.\n        matrix = Matrix(R, C, L)\n        # Compute the offset using the derived logic.\n        offset = matrix.get_offset(i, j)\n        results.append(offset)\n\n    # Final print statement in the exact required format: [result1,result2,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver function.\nsolve()\n```", "id": "3267656"}, {"introduction": "In systems programming and debugging, you often encounter situations where you must infer the properties of a data structure from limited information, like memory dumps or pointer values. This final exercise [@problem_id:3267817] puts your understanding to the test in a practical, reverse-engineering scenario. Using just two memory addresses, you must deduce an array's storage layout and its base address, demonstrating a deep, applicable knowledge of how data is organized in memory.", "problem": "A two-dimensional array $A$ of $4$-byte integers is stored contiguously in memory with zero-based indexing for both dimensions. The array is rectangular with a fixed, unknown number of rows $R$ and columns $C$, and there is no padding between rows or columns. Two observed memory addresses are given: the address of $A[2][1]$ is $1024$ and the address of $A[3][3]$ is $1048$, measured in bytes from a fixed origin. The storage order is either row-major (rows laid out one after another; consecutive elements within the same row are adjacent in memory) or column-major (columns laid out one after another; consecutive elements within the same column are adjacent in memory). Assume all addresses are exact and that $R$ and $C$ are positive integers.\n\nUsing only these foundational definitions, determine whether the layout must be row-major or column-major, assess whether this determination is certain under the stated assumptions, and then compute the base address $B$ of $A[0][0]$ in bytes. Express the final base address in bytes. No rounding is required.", "solution": "The problem requires us to determine the storage layout (row-major or column-major) and the base address of a two-dimensional array $A$ given the memory addresses of two of its elements.\n\nLet the givens be formally stated:\n- The array is $A[R][C]$, where $R$ is the number of rows and $C$ is the number of columns.\n- $R$ and $C$ are positive integers.\n- Indexing is zero-based, so for an element $A[i][j]$, the row index $i$ ranges from $0$ to $R-1$ and the column index $j$ ranges from $0$ to $C-1$.\n- The size of each element (a $4$-byte integer) is $S = 4$ bytes.\n- The base address, which is the address of the first element $A[0][0]$, is denoted by $B$.\n- We are given two data points:\n  1. The address of $A[2][1]$ is $1024$.\n  2. The address of $A[3][3]$ is $1048$.\n\nThe existence of elements $A[2][1]$ and $A[3][3]$ implies that the array dimensions must be at least $R \\ge 4$ and $C \\ge 4$.\n\nWe will analyze two mutually exclusive hypotheses: the array is stored in row-major order, or it is stored in column-major order.\n\n**Hypothesis 1: Row-Major Order**\n\nIn row-major order, the address of an element $A[i][j]$ is calculated by the formula:\n$$ \\text{address}(A[i][j]) = B + (i \\cdot C + j) \\cdot S $$\nwhere $i$ is the row index, $j$ is the column index, $C$ is the total number of columns, and $S$ is the element size.\n\nSubstituting the given values into this formula:\nFor $A[2][1]$:\n$$ \\text{address}(A[2][1]) = B + (2 \\cdot C + 1) \\cdot 4 = 1024 \\quad (1) $$\nFor $A[3][3]$:\n$$ \\text{address}(A[3][3]) = B + (3 \\cdot C + 3) \\cdot 4 = 1048 \\quad (2) $$\n\nWe have a system of two linear equations with two unknowns, $B$ and $C$. To solve for $C$, we can subtract equation $(1)$ from equation $(2)$:\n$$ [B + (3C + 3) \\cdot 4] - [B + (2C + 1) \\cdot 4] = 1048 - 1024 $$\n$$ B + 12C + 12 - B - 8C - 4 = 24 $$\n$$ 4C + 8 = 24 $$\n$$ 4C = 16 $$\n$$ C = 4 $$\n\nThe result $C=4$ is a positive integer, which is consistent with the problem's constraints. It also satisfies the condition $C \\ge 4$ derived from the given indices.\n\nNow, we can substitute $C=4$ back into equation $(1)$ to find the base address $B$:\n$$ B + (2 \\cdot 4 + 1) \\cdot 4 = 1024 $$\n$$ B + (8 + 1) \\cdot 4 = 1024 $$\n$$ B + 9 \\cdot 4 = 1024 $$\n$$ B + 36 = 1024 $$\n$$ B = 1024 - 36 $$\n$$ B = 988 $$\n\nThus, the row-major hypothesis yields a valid solution: $C=4$ and $B=988$ bytes.\n\n**Hypothesis 2: Column-Major Order**\n\nIn column-major order, the address of an element $A[i][j]$ is calculated by the formula:\n$$ \\text{address}(A[i][j]) = B + (j \\cdot R + i) \\cdot S $$\nwhere $i$ is the row index, $j$ is the column index, $R$ is the total number of rows, and $S$ is the element size.\n\nSubstituting the given values into this formula:\nFor $A[2][1]$:\n$$ \\text{address}(A[2][1]) = B + (1 \\cdot R + 2) \\cdot 4 = 1024 \\quad (3) $$\nFor $A[3][3]$:\n$$ \\text{address}(A[3][3]) = B + (3 \\cdot R + 3) \\cdot 4 = 1048 \\quad (4) $$\n\nWe now have a system of two linear equations with two unknowns, $B$ and $R$. To solve for $R$, we subtract equation $(3)$ from equation $(4)$:\n$$ [B + (3R + 3) \\cdot 4] - [B + (R + 2) \\cdot 4] = 1048 - 1024 $$\n$$ B + 12R + 12 - B - 4R - 8 = 24 $$\n$$ 8R + 4 = 24 $$\n$$ 8R = 20 $$\n$$ R = \\frac{20}{8} = \\frac{5}{2} = 2.5 $$\n\nThe result $R=2.5$ is not an integer. This contradicts the premise that the number of rows $R$ must be a positive integer. Therefore, the column-major hypothesis is invalid.\n\n**Conclusion**\n\nThe analysis shows that only the row-major layout hypothesis is consistent with the given information and constraints. The column-major layout leads to a contradiction. Therefore, the determination that the storage order is row-major is certain. The unique solution derived from the row-major model gives the number of columns as $C=4$ and the base address of the array $A[0][0]$ as $B=988$ bytes.\n\nThe question asks for the base address $B$ of $A[0][0]$. Based on our definitive reasoning, this value is $988$.", "answer": "$$\\boxed{988}$$", "id": "3267817"}]}