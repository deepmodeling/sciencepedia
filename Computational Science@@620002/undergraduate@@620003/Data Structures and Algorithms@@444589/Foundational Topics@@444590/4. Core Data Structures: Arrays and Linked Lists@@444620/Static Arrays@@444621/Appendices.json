{"hands_on_practices": [{"introduction": "Static arrays are not limited to one dimension, and many real-world applications involve manipulating 2D data. This practice explores the in-place manipulation of a two-dimensional static array, or matrix, by implementing a 90-degree clockwise rotationâ€”a common operation in fields like image processing. This exercise [@problem_id:3275330] hones your ability to reason about coordinate transformations and implement efficient cyclic swaps, a fundamental technique for algorithms that must operate with minimal memory.", "problem": "You are given a square two-dimensional static array (an array with fixed size and contiguous storage semantics) of dimension $N \\times N$. The task is to design and implement a complete program that rotates this array by $90$ degrees clockwise in-place, using only array indexing operations and a constant number of temporary variables. The angle unit is degrees. The program must implement the rotation without allocating any auxiliary arrays whose size depends on $N$.\n\nFundamental base and constraints: Use the core definition of a static array, namely that for a two-dimensional array with $N$ rows and $N$ columns, there is a constant-time mapping from an index pair $(i,j)$ to the corresponding element, and indexing does not change the physical arrangement of memory. The result should be derived from first principles about array indexing and the geometric relation between the original coordinate $(i,j)$ and its location after a clockwise rotation by $90$ degrees in a square grid. No shortcut formulas and no hints are to be provided in the problem statement for the rotation; correctness must follow from the fundamental properties of static arrays and discrete coordinate transformations. The final program must execute the rotation in-place, ensuring the number of temporary variables used does not grow with $N$.\n\nYour program must apply the rotation to each of the following test matrices, then output the row-major flattened result for each test case. Use the following test suite, designed to cover a general case, boundary conditions, and significant edge cases:\n- Test case $1$ (boundary: $N = 1$): $$\\begin{bmatrix} 5 \\end{bmatrix}$$\n- Test case $2$ (small even $N = 2$): $$\\begin{bmatrix} 1 & 2 \\\\ 3 & 4 \\end{bmatrix}$$\n- Test case $3$ (odd $N = 3$ with negatives): $$\\begin{bmatrix} -1 & -2 & -3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{bmatrix}$$\n- Test case $4$ (even $N = 4$ with repeated values): $$\\begin{bmatrix} 1 & 1 & 2 & 2 \\\\ 3 & 3 & 4 & 4 \\\\ 5 & 5 & 6 & 6 \\\\ 7 & 7 & 8 & 8 \\end{bmatrix}$$\n- Test case $5$ (odd $N = 5$ with zeros distributed on a diagonal): $$\\begin{bmatrix} 0 & 1 & 2 & 3 & 4 \\\\ 5 & 0 & 7 & 8 & 9 \\\\ 10 & 11 & 0 & 13 & 14 \\\\ 15 & 16 & 17 & 0 & 19 \\\\ 20 & 21 & 22 & 23 & 0 \\end{bmatrix}$$\n\nFor each test case, after performing the rotation, flatten the matrix in row-major order into a list of integers (for example, for a rotated $2 \\times 2$ matrix $\\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}$, the flattened list is $[a,b,c,d]$). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the flattened list for one test case, in order from test case $1$ through test case $5$. For example, the output format must be like: \"[[x1,x2,...],[y1,y2,...],[z1,z2,...],[u1,u2,...],[v1,v2,...]]\" where each inner list corresponds to one test case and contains integers only.\n\nThe answers for each test case are the flattened lists of integers described above. No other textual output is permitted.", "solution": "The user-provided problem has been analyzed and is deemed **valid**. It is a well-posed, scientifically grounded problem in the domain of data structures and algorithms, with all necessary information provided and no internal contradictions.\n\nThe task is to rotate a square two-dimensional static array of dimensions $N \\times N$ by $90$ degrees clockwise, in-place. An in-place algorithm must perform the rotation without allocating auxiliary memory proportional to the size of the input array. The constraint further specifies that only a constant number of temporary variables, independent of $N$, may be used. The solution must be derived from first principles.\n\nLet the array be denoted by $A$. An element at row $i$ and column $j$ is $A[i,j]$, where the indices $i$ and $j$ range from $0$ to $N-1$.\n\n**1. Coordinate Transformation for Clockwise Rotation**\n\nThe fundamental step is to determine the destination coordinates for each element after a $90$-degree clockwise rotation. A common method to derive this transformation is to consider it as a composition of two simpler operations: a transpose followed by a reversal of each row.\n\n1.  **Transpose**: An element at position $(i, j)$ moves to position $(j, i)$. So, the value at $A[i,j]$ moves to the location previously occupied by $A[j,i]$.\n2.  **Row Reversal**: After the transpose, the element now at position $(j, i)$ is in row $j$. Reversing this row moves it from column $i$ to column $N-1-i$.\n\nCombining these two steps, the element originally at $A[i,j]$ is ultimately moved to the position $(j, N-1-i)$. This gives us the mapping for the destination of each element's value: the value at the initial position $(i,j)$ moves to the final position $(j, N-1-i)$.\n\n**2. Cyclic Element Swapping**\n\nTo perform the rotation in-place, we must move elements without overwriting values that have not yet been moved. This can be achieved by identifying and permuting closed cycles of elements. Let's trace the path of an element starting at an arbitrary position $(i,j)$.\n\n-   Position 1: $(i, j)$\n-   The element at Position 1 moves to Position 2: $(j, N-1-i)$.\n-   The element at Position 2 moves to Position 3. Applying the mapping to $(j, N-1-i)$: the new row is $(N-1-i)$, and the new column is $N-1-j$. So, Position 3 is $(N-1-i, N-1-j)$.\n-   The element at Position 3 moves to Position 4. Applying the mapping to $(N-1-i, N-1-j)$: the new row is $(N-1-j)$, and the new column is $N-1-(N-1-i) = i$. So, Position 4 is $(N-1-j, i)$.\n-   Applying the mapping to Position 4, $(N-1-j, i)$, gives a new row $i$ and new column $N-1-(N-1-j) = j$. This is $(i,j)$, which brings us back to the starting position.\n\nThis reveals that the rotation permutes elements in cycles of four distinct positions (unless the position is the exact center of the matrix):\n$$(i, j) \\to (j, N-1-i) \\to (N-1-i, N-1-j) \\to (N-1-j, i) \\to (i, j)$$\n\nBy systematically performing a cyclic swap for each such group of four elements, the entire matrix can be rotated. A single temporary variable is sufficient to perform a $4$-element cyclic swap.\n\n**3. Algorithmic Layer-by-Layer Approach**\n\nTo ensure that every element is moved exactly once, we can process the matrix in concentric square layers or \"shells\". The number of such layers is $\\lfloor N/2 \\rfloor$.\n\n-   An outer loop iterates through the layers, from the outermost layer $L=0$ to the innermost layer $L = \\lfloor N/2 \\rfloor - 1$.\n-   For each layer $L$, an inner loop iterates along the elements of one of its edges, for example, the top edge. The top edge of layer $L$ runs from column $L$ to $N-1-L$. We only need to iterate up to the second-to-last element of this edge, as the last element is a corner that will be handled as part of a cycle initiated by an element on a different edge. Thus, the inner loop variable, let's call it $k$, runs from $L$ to $N-1-L-1$.\n\nFor each pair of $(L, k)$, we identify a unique 4-element cycle. Let the first element of the cycle correspond to the position on the top edge of the layer defined by our loops, so its coordinates are $(i,j) = (L, k)$. The other three positions in the cycle are then determined by the transformation derived above:\n-   Position 1 (top): $(L, k)$\n-   Position 2 (right): $(k, N-1-L)$\n-   Position 3 (bottom): $(N-1-L, N-1-k)$\n-   Position 4 (left): $(N-1-k, L)$\n\n**4. In-Place Cyclic Swap Implementation**\n\nThe clockwise rotation requires moving the value from Position 1 to 2, 2 to 3, 3 to 4, and 4 to 1. This is implemented by storing one value in a temporary variable and then moving the other three in the reverse direction of the value flow.\n\nLet `temp` be a temporary variable. The sequence of assignments is:\n1.  `temp` $\\leftarrow A[L, k]$ (Save the top element's value)\n2.  $A[L, k] \\leftarrow A[N-1-k, L]$ (Move left element to top)\n3.  $A[N-1-k, L] \\leftarrow A[N-1-L, N-1-k]$ (Move bottom element to left)\n4.  $A[N-1-L, N-1-k] \\leftarrow A[k, N-1-L]$ (Move right element to bottom)\n5.  $A[k, N-1-L] \\leftarrow$ `temp` (Move saved top element to right)\n\nThis sequence of operations, nested within the two loops for layers and elements, will correctly rotate the entire matrix in-place using only one temporary variable, thus satisfying all problem constraints. The space complexity is $O(1)$ and the time complexity is $O(N^2)$, as each element is accessed a constant number of times.\n\nThe final algorithm is as follows:\n1.  Input: $N \\times N$ matrix $A$.\n2.  Calculate the number of layers: `num_layers = N // 2`.\n3.  For $L$ from $0$ to `num_layers - 1`:\n4.      For $k$ from $L$ to $N-L-2$:\n5.          Perform the 4-way cyclic swap described above for the elements at the cycle defined by $(L, k)$.\n6.  Return the modified matrix $A$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotate_matrix_in_place(matrix: np.ndarray):\n    \"\"\"\n    Rotates a square NxN matrix by 90 degrees clockwise in-place.\n    \n    The algorithm works by processing the matrix in concentric square layers.\n    For each layer, it performs a cyclic swap of 4 elements at a time.\n    \n    - The outer loop `L` iterates through the layers, from 0 to floor(N/2) - 1.\n    - The inner loop `k` iterates through the elements on one edge of the current layer.\n    - For each element on the top edge of a layer, we identify a 4-element cycle.\n      The positions in the cycle are:\n      - top: (L, k)\n      - right: (k, N-1-L)\n      - bottom: (N-1-L, N-1-k)\n      - left: (N-1-k, L)\n    - A single temporary variable is used to perform the clockwise cyclic swap:\n      left -> top, bottom -> left, right -> bottom, top -> right.\n    \"\"\"\n    n = matrix.shape[0]\n    if n = 1:\n        return\n\n    # Iterate through layers from outermost to innermost\n    for L in range(n // 2):\n        # Iterate through elements in the current layer's top edge\n        # The range is from the start of the layer to the element before the corner\n        for k in range(L, n - 1 - L):\n            # Save the top element\n            temp = matrix[L, k]\n            \n            # Move left element to top\n            matrix[L, k] = matrix[n - 1 - k, L]\n            \n            # Move bottom element to left\n            matrix[n - 1 - k, L] = matrix[n - 1 - L, n - 1 - k]\n            \n            # Move right element to bottom\n            matrix[n - 1 - L, n - 1 - k] = matrix[k, n - 1 - L]\n            \n            # Move saved top element to right\n            matrix[k, n - 1 - L] = temp\n\ndef solve():\n    \"\"\"\n    Solves the matrix rotation problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement using numpy arrays.\n    test_cases = [\n        np.array([[5]]),\n        np.array([[1, 2], [3, 4]]),\n        np.array([[-1, -2, -3], [4, 5, 6], [7, 8, 9]]),\n        np.array([[1, 1, 2, 2], [3, 3, 4, 4], [5, 5, 6, 6], [7, 7, 8, 8]]),\n        np.array([[0, 1, 2, 3, 4], \n                  [5, 0, 7, 8, 9], \n                  [10, 11, 0, 13, 14], \n                  [15, 16, 17, 0, 19], \n                  [20, 21, 22, 23, 0]])\n    ]\n\n    results_as_strings = []\n    for matrix in test_cases:\n        # Perform the in-place rotation\n        rotate_matrix_in_place(matrix)\n        \n        # Flatten the rotated matrix in row-major order\n        flattened_list = matrix.flatten().tolist()\n        \n        # Format the flattened list into the required string format \"[x,y,z]\"\n        list_str = f\"[{','.join(map(str, flattened_list))}]\"\n        results_as_strings.append(list_str)\n\n    # Final print statement in the exact required format: \"[[...],[...]]\"\n    final_output = f\"[{','.join(results_as_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3275330"}, {"introduction": "Beyond simple storage, a static array's indexed structure can be cleverly repurposed for computation, saving significant space. This problem challenges you to find the smallest missing positive integer in an unsorted array in linear time and with constant extra space, a non-trivial constraint. The key to solving this efficiently [@problem_id:3275160] is to treat the array's indices as a hash map, rearranging elements in-place to mark which numbers from a target range are present.", "problem": "You are given multiple independent test cases, each consisting of an unsorted static array of integers. For each array, compute the smallest missing positive integer. The algorithmic requirements are that, for an array of length $N$, your method must run in $O(N)$ time and use $O(1)$ additional space beyond the given static array. A static array is a fixed-length, contiguous block of memory that supports constant-time random access and in-place updates.\n\nUse only the following fundamental base: the definition and properties of static arrays (constant-time indexing and assignment), the notion of in-place updates via a constant number of assignments (including element swaps), and the standard definitions of time complexity $O(\\cdot)$ and space complexity $O(\\cdot)$. Do not resize arrays, allocate auxiliary arrays proportional to $N$, or use hashing structures whose size depends on $N$.\n\nImplement a program that applies your algorithm to the following test suite of arrays:\n- $[3,4,-1,1]$\n- $[1,1,0,-1,-2,2]$\n- $[1,2,3]$\n- $[-5,-1,-3]$\n- $[7,8,9,11,12]$\n- $[2,3,4,5,6,7]$\n- $[]$\n- $[2]$\n- $[1]$\n\nFor each array, the answer is a single integer: the smallest missing positive integer in that array. Your program must hard-code the above test suite, must not read any input, and must not write any extraneous output.\n\nFinal output format: Your program should produce a single line of output containing the results for the test suite, in order, as a comma-separated list enclosed in square brackets, for example, $[a,b,c,\\dots]$, where each entry is the integer result for the corresponding test case.", "solution": "The problem as stated is valid. It is a well-defined algorithmic challenge from the field of computer science, grounded in the formal properties of static arrays and complexity theory. The problem is self-contained, objective, and its constraints are stringent but achievable.\n\nThe task is to find the smallest missing positive integer in an unsorted static array of length $N$. The solution must achieve a time complexity of $O(N)$ and a space complexity of $O(1)$ (constant additional space).\n\nThe core principle behind an efficient solution lies in the observation that the smallest missing positive integer must be in the range $[1, N+1]$. If the array contains all integers from $1$ to $N$, the answer is $N+1$. Otherwise, the answer is the smallest integer from the set $\\{1, 2, \\dots, N\\}$ that is not present in the array. This insight narrows the search space considerably.\n\nGiven the $O(1)$ space constraint, we cannot use auxiliary data structures like a hash map or a boolean array of size $N$ to track the presence of numbers. We must repurpose the input array itself to store this information. The strategy is to treat the array's indices as a hash table and the values as the elements to be placed. Specifically, we aim to place the integer $k$ at index $k-1$ for all $k \\in \\{1, \\dots, N\\}$ that are present in the array.\n\nThe algorithm proceeds in two main phases:\n\n**Phase 1: In-Place Cyclical Placement**\n\nThe goal of this phase is to rearrange the array such that if an integer $k$ (where $1 \\le k \\le N$) is present, it is moved to the index $k-1$.\n\nWe iterate through the array from index $i=0$ to $N-1$. For each element $A[i]$, we check its value, which we can call $v$. An inner `while` loop is used to handle the placement of $v$:\n1.  The value $v = A[i]$ is a candidate for placement only if it falls within the valid range, i.e., $1 \\le v \\le N$.\n2.  To prevent infinite loops when duplicate values are present, we must also ensure that the value $v$ is not already at its target location. The target location for value $v$ is index $v-1$, which should contain the value $v$. So, the swap should only occur if $A[v-1] \\neq v$.\n\nIf both conditions are met ($1 \\le A[i] \\le N$ and $A[A[i]-1] \\neq A[i]$), we swap the element $A[i]$ with the element at its target index, $A[A[i]-1]$. After a swap, the element at index $i$ is new, and we must re-evaluate it in the inner `while` loop. This cyclical process continues until the value at $A[i]$ is no longer a candidate for moving (either because it is out of the $[1, N]$ range or because it is a duplicate of a value already correctly placed).\n\nThis phase has a time complexity of $O(N)$. Although there is a nested loop structure, each swap places at least one integer into its correct final position. An integer is never moved again once it reaches its correct index. Since there are at most $N$ integers to place, the total number of swaps across all iterations of the outer loop is bounded by $N$.\n\n**Phase 2: First Mismatch Detection**\n\nAfter the placement phase, the array has been rearranged. For any integer $k \\in \\{1, \\dots, N\\}$, if $k$ was in the original array, we now have $A[k-1] = k$. There might be \"junk\" values (negative numbers, zeros, or numbers greater than $N$) in positions corresponding to missing integers.\n\nWe perform a single linear scan of the modified array from index $j = 0$ to $N-1$. We check if $A[j] = j+1$. The first index $j$ for which this condition fails ($A[j] \\neq j+1$) tells us that $j+1$ is the smallest positive integer that was missing from the original array. We can then return $j+1$.\n\nIf the loop completes without finding any such mismatch, it means that for every $j \\in [0, N-1]$, we found $A[j] = j+1$. This implies that the array contained all integers from $1$ to $N$. In this case, the smallest missing positive integer is $N+1$.\n\nThis two-phase approach correctly identifies the smallest missing positive integer while adhering to the strict $O(N)$ time and $O(1)$ space complexity requirements. It correctly handles edge cases such as empty arrays, arrays with all negative numbers, arrays with duplicates, and arrays that are already sorted.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the smallest missing positive integer for a list of test cases,\n    adhering to O(N) time and O(1) space complexity.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # We convert them to numpy arrays to better model the concept of a 'static array'.\n    test_cases_lists = [\n        [3,4,-1,1],\n        [1,1,0,-1,-2,2],\n        [1,2,3],\n        [-5,-1,-3],\n        [7,8,9,11,12],\n        [2,3,4,5,6,7],\n        [],\n        [2],\n        [1],\n    ]\n    \n    test_cases = [np.array(tc, dtype=np.int64) for tc in test_cases_lists]\n\n    results = []\n    for nums in test_cases:\n        result = find_smallest_missing_positive(nums)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_smallest_missing_positive(nums: np.ndarray) -> int:\n    \"\"\"\n    Finds the smallest missing positive integer in a static array.\n    The algorithm rearranges the array in-place to use indices as a hash map.\n\n    Args:\n        nums: A numpy array of integers. The array is modified in-place.\n\n    Returns:\n        The smallest positive integer not present in the array.\n    \"\"\"\n    n = nums.size\n\n    # Phase 1: In-place cyclical placement.\n    # The goal is to place each number k (in [1, n]) at index k-1.\n    for i in range(n):\n        # Continue swapping nums[i] into its correct place as long as it's a\n        # valid candidate and not already in its correct place.\n        # Condition 1: The value must be in the range [1, n].\n        # Condition 2: The value at the target index must not already be the correct value.\n        # This prevents infinite loops on duplicate entries.\n        while 1 = nums[i] = n and nums[nums[i] - 1] != nums[i]:\n            target_idx = nums[i] - 1\n            # Swap the current number to its correct position.\n            nums[i], nums[target_idx] = nums[target_idx], nums[i]\n\n    # Phase 2: Find the first missing positive.\n    # After rearrangement, the first index i where nums[i] != i + 1\n    # indicates that i + 1 is the smallest missing positive number.\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    \n    # If the loop completes, it means all integers from 1 to n were present.\n    # The smallest missing positive is therefore n + 1.\n    return n + 1\n\nsolve()\n```", "id": "3275160"}, {"introduction": "This final practice elevates our perspective on static arrays, treating them not just as data containers but as abstract mathematical structures. Given a read-only array containing a guaranteed duplicate number, your task is to find that duplicate using only constant extra space. The elegant solution to this puzzle [@problem_id:3275310] involves modeling the array as a functional graph and applying Floyd's cycle-finding algorithm, a powerful technique with applications far beyond arrays.", "problem": "Consider a static array, defined as a fixed-size, contiguous block of memory that supports constant-time random access, storing integers without any in-place modification once constructed. Let there be an array of length $N+1$ containing integers constrained to the closed interval $[1,N]$. By definition, a static array does not permit element insertion, deletion, or value changes; only read operations are allowed. The task is to determine a duplicate value that must exist due to the cardinality constraint, without modifying the array and using only constant extra space, while executing in a time bounded above by a linear function of $N$.\n\nBase facts to use for reasoning and design:\n- The Pigeonhole Principle: If $N+1$ items are placed into $N$ containers, at least one container holds at least $2$ items.\n- A static array of length $N+1$ with entries in $[1,N]$ can be treated as a function $f$ from indices to values, where $f(i)=A[i]$ for an index $i$ and array $A$.\n- In a directed functional graph where each node has out-degree $1$, any sufficiently long traversal must eventually enter a cycle.\n\nDesign a program that, given several such static arrays, returns the duplicate value for each array using constant additional space and without altering any array. The program must be entirely self-contained and must not read input from any external source. It must process the following test suite and produce the results in the specified final output format.\n\nTest suite arrays to process, each complying with the constraints:\n- Array $A_1 = [1,3,4,2,2,5]$ with $N=5$.\n- Array $A_2 = [1,1]$ with $N=1$.\n- Array $A_3 = [3,1,3,4,2,5,6]$ with $N=6$.\n- Array $A_4 = [7,2,4,3,5,6,1,7]$ with $N=7$.\n- Array $A_5 = [1,5,4,3,2,6,7,8,9,10,5]$ with $N=10$.\n- Array $A_6 = [2,5,1,1,4,3,6,8,7]$ with $N=8$.\n\nFor each array $A_i$, the required output is a single integer in $[1,N]$ equal to the duplicated value in $A_i$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $A_1$ through $A_6$, for example, $[r_1,r_2,r_3,r_4,r_5,r_6]$, where each $r_i$ is the integer duplicate found for array $A_i$.", "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of discrete mathematics and algorithm theory, well-posed with sufficient constraints for a unique algorithmic solution, and expressed in objective, formal language. All provided data and constraints are self-consistent and formalizable.\n\nThe task is to find a duplicate integer in a static array $A$ of length $N+1$ whose elements are drawn from the set $\\{1, 2, \\dots, N\\}$. The solution must operate in time linear in $N$, use constant extra space, and not modify the input array.\n\nThe existence of at least one duplicate value is guaranteed by the Pigeonhole Principle. We have $N+1$ items (the elements of the array $A$) to be placed in $N$ containers (the possible integer values from $1$ to $N$). Therefore, at least one value must be present more than once.\n\nThe provided constraints guide us toward an algorithm based on cycle detection in a functional graph. Let us model the array as a directed graph where the nodes are the indices of the array, $\\{0, 1, \\dots, N\\}$. A directed edge exists from each index $i$ to the index specified by the value $A[i]$. Since array indices are 0-based in standard implementations, we must be precise about the mapping. The array values are in the range $[1, N]$, which are all valid indices within the set $\\{0, 1, \\dots, N\\}$. Thus, we can define a successor function $s(i) = A[i]$ that maps an index $i$ to a successor index $A[i]$.\n\nThe structure of this functional graph is key. The set of nodes is $V = \\{0, 1, \\dots, N\\}$, a set of cardinality $N+1$. The set of possible successor nodes, determined by the values in the array, is $A[V] \\subseteq \\{1, 2, \\dots, N\\}$. This means that no edge in the graph points to node $0$. Consequently, the node corresponding to index $0$ must have an in-degree of $0$.\n\nAny node with an in-degree of $0$ cannot be part of a cycle. Therefore, node $0$ must be the starting point of a path that is not part of a cycle. Since the graph is finite, any path starting from node $0$ must eventually enter a cycle. This structure, a path leading into a cycle, is known as a rho-shape ($\\rho$).\n\nThe algorithm to find the duplicate value leverages this structure by applying Floyd's Tortoise and Hare cycle-finding algorithm. Let's trace the sequence of indices starting from node $0$: $x_0 = 0$, $x_1 = A[x_0]$, $x_2 = A[x_1]$, and so on, with $x_{k+1} = A[x_k]$. The algorithm proceeds in two phases.\n\nPhase 1: Finding an intersection point within the cycle.\nWe use two pointers, a \"tortoise\" ($t$) and a \"hare\" ($h$). Both start at index $0$. In each step, the tortoise advances one position ($t \\to A[t]$), while the hare advances two positions ($h \\to A[A[h]]$). Since the sequence starting from $0$ enters a cycle, the hare, moving faster, will eventually lap the tortoise. They are guaranteed to meet at some index within the cycle.\n\nLet $t_0 = A[0]$ and $h_0 = A[A[0]]$.\nThe sequence of positions is:\n$t_{k+1} = A[t_k]$\n$h_{k+1} = A[A[h_k]]$\n\nWe iterate until $t_k = h_k$ for some $k > 0$. Let this meeting index be $m$.\n\nPhase 2: Finding the entrance to the cycle.\nThe theory behind Floyd's algorithm states that the length of the initial path from the start node ($0$) to the cycle's entrance is equal to the distance from the meeting point ($m$) to the cycle's entrance (modulo the cycle's length). Therefore, to find the cycle's entrance, we reset one pointer ($p_1$) to the start ($0$) and keep the other pointer ($p_2$) at the meeting point ($m$). We then advance both pointers one step at a time ($p_1 \\to A[p_1]$ and $p_2 \\to A[p_2]$). The index where they meet is the first node of the cycle.\n\nLet $p_{1,0} = 0$ and $p_{2,0} = m$.\nThe sequence of positions is:\n$p_{1, k+1} = A[p_{1,k}]$\n$p_{2, k+1} = A[p_{2,k}]$\n\nWe iterate until $p_{1,k} = p_{2,k}$. This common index is the entrance to the cycle. Let this entrance index be $d$.\n\nJustification: Why is the cycle entrance index the duplicate value?\nThe entrance to the cycle is the index $d$. By definition of being the cycle entrance for the path starting at $0$, there must be a predecessor index $p$ on the path such that $A[p] = d$. Since $d$ is also part of a cycle, there must be another predecessor index $q$ that is part of the cycle, such that $A[q] = d$. The index $p$ is on the non-cyclic path, while $q$ is in the cycle. Therefore, $p \\neq q$. We have found two distinct indices, $p$ and $q$, that both map to the index $d$. This means $A[p] = d$ and $A[q] = d$. Since the value stored at an index is used to determine the next index in the path, the index $d$ is the value that is duplicated.\n\nThis algorithm fulfills all requirements:\n1.  It is non-destructive, only performing read operations on the array.\n2.  It uses constant extra space for a few pointer variables ($t, h, p_1, p_2$).\n3.  Its time complexity is linear, as both phases of the algorithm traverse a number of nodes proportional to the length of the path and cycle, which is bounded by $N+1$.\n\nThe implementation will follow these two phases to find the cycle entrance index for each given array, which corresponds to the duplicate value.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding a duplicate number in a static array.\n    \"\"\"\n\n    def find_duplicate(arr: np.ndarray) -> int:\n        \"\"\"\n        Finds a duplicate number in a static array using Floyd's Tortoise and Hare algorithm.\n\n        The array is modeled as a functional graph where indices are nodes and the\n        value at an index is the pointer to the next node. The problem constraints\n        (array of length N+1 with values in [1,N]) guarantee that index 0 has an\n        in-degree of 0, serving as the start of a path that must lead into a cycle.\n        The entrance to this cycle is the duplicate number.\n\n        Args:\n            arr: A numpy array of length N+1 containing integers in [1,N].\n\n        Returns:\n            The duplicate integer value.\n        \"\"\"\n        # Phase 1: Find the intersection point of the two runners.\n        # Tortoise moves one step at a time. Hare moves two steps.\n        # Both start by taking their first step(s) from a virtual node '0'.\n        tortoise = arr[0]\n        hare = arr[arr[0]]\n        while tortoise != hare:\n            tortoise = arr[tortoise]\n            hare = arr[arr[hare]]\n\n        # Phase 2: Find the entrance to the cycle.\n        # Move one pointer to the start of the list (index 0) and keep the other at the\n        # intersection point. Move them both one step at a time until they meet.\n        # The meeting point is the start of the cycle, which is the duplicate number.\n        p1 = 0\n        p2 = tortoise\n        while p1 != p2:\n            p1 = arr[p1]\n            p2 = arr[p2]\n        \n        return p1\n\n    # Define the test cases from the problem statement.\n    test_suite = [\n        ([1, 3, 4, 2, 2, 5], 5),\n        ([1, 1], 1),\n        ([3, 1, 3, 4, 2, 5, 6], 6),\n        ([7, 2, 4, 3, 5, 6, 1, 7], 7),\n        ([1, 5, 4, 3, 2, 6, 7, 8, 9, 10, 5], 10),\n        ([2, 5, 1, 1, 4, 3, 6, 8, 7], 8)\n    ]\n\n    results = []\n    for arr_list, n_val in test_suite:\n        # Convert list to numpy array for processing.\n        arr_np = np.array(arr_list, dtype=int)\n        duplicate = find_duplicate(arr_np)\n        results.append(duplicate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3275310"}]}