{"hands_on_practices": [{"introduction": "This first exercise explores how to find a specific \"pivot\" point in a linked list that is sorted and then rotated. While the linear nature of a linked list prevents us from using efficient algorithms like binary search, the underlying sorted structure still provides a crucial clue. This practice sharpens your ability to detect a specific pattern—a break in the monotonic order where a value is strictly greater than the next—during a straightforward traversal. [@problem_id:3246366]", "problem": "You are given the abstract definition of a singly linked list of integers: each node stores a single integer key and a pointer to the next node, and the last node points to null. Consider a finite nonempty sequence of integers that is sorted in nondecreasing order and then rotated by some number of positions. Formally, start from a nondecreasing sequence of length $n$ with elements $a_0 \\le a_1 \\le \\dots \\le a_{n-1}$, choose an integer $k$ with $0 \\le k < n$, and construct a rotated sequence by moving the last $k$ elements to the front while preserving the relative order within the moved block and within the remaining block. Then construct a singly linked list by chaining nodes in this rotated order from head to tail.\n\nDefine the pivot node to be the unique node at index $p$ (using $0$-based indexing along next pointers) such that either $p = n-1$ and the list is nondecreasing along every next pointer, or the key at index $p$ is strictly greater than the key at index $p+1$. Intuitively, the pivot node is the last node before the sorted order wraps around; for example, in the linked list with keys $8 \\rightarrow 9 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3$, the pivot node is the one containing $9$.\n\nFundamental base assumptions:\n- A singly linked list admits traversal from head to tail following next pointers, visiting each node exactly once when desired.\n- A sequence is nondecreasing if for all indices $i$ with $0 \\le i < n-1$, one has $a_i \\le a_{i+1}$.\n- Rotating a nondecreasing sequence by $k$ positions yields a sequence with at most one index $p$ where a strict decrease occurs, namely at the rotation boundary, and none if $k = 0$.\n- Algorithmic complexity is measured using Big O notation (Big-O), where $\\mathcal{O}(n)$ denotes linear in the number of nodes $n$ and $\\mathcal{O}(1)$ denotes constant extra space.\n\nYour task is to write a complete program that:\n- Constructs several singly linked lists from given arrays of integers.\n- For each list, returns the index $p$ of the pivot node as defined above.\n- Handles the empty list by returning $-1$ by convention.\n- Uses a single forward traversal per list and constant additional space, that is, time complexity $\\mathcal{O}(n)$ and auxiliary space $\\mathcal{O}(1)$ for a list of length $n$, and does not convert the list to any random-access container.\n- Assumes the inputs obey the construction described above (nondecreasing then rotated), but must be robust to equal keys; equal adjacency does not constitute a strict decrease.\n\nTest suite to implement within your program:\n- Case A: keys $[8, 9, 1, 2, 3]$; expected pivot index is the index of the node containing $9$.\n- Case B: keys $[1, 2, 3, 4]$; not rotated ($k = 0$), so the pivot is the tail node at index $3$.\n- Case C: keys $[5]$; single node, pivot index $0$.\n- Case D: keys $[]$; empty list, pivot index $-1$ by convention.\n- Case E: keys $[7, 7, 7, 7]$; all keys equal, no strict decrease, pivot is the tail at index $3$.\n- Case F: keys $[3, 4, 5, 1, 2]$; pivot is the node containing $5$ at index $2$.\n- Case G: keys $[2, 1]$; pivot is the node containing $2$ at index $0$.\n- Case H: keys $[1, 2]$; not rotated, pivot index $1$.\n- Case I: keys $[1, 1, 2, 2, 3, 3, 0, 1]$; pivot is the last node with key $3$ before the strict drop to $0$, at index $5$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- For the above nine cases in the stated order, the line must be of the form \"[rA,rB,rC,rD,rE,rF,rG,rH,rI]\" where each $rX$ is the integer pivot index for case $X$.\n\nNo external input should be read; all data must be defined within the program. There are no physical quantities, angles, or percentages in this problem, so no unit specification is needed. Ensure the program is self-contained and runnable as provided, and obeys the stated complexity constraints.", "solution": "The problem statement is subjected to a rigorous validation process before any attempt at a solution is made.\n\n### Step 1: Extract Givens\n\nThe problem provides the following definitions, constraints, and data:\n\n- **Data Structure**: A singly linked list of integers, where each node contains an integer `key` and a `next` pointer. The list is constructed from a sequence of integers that is first sorted in nondecreasing order and then rotated.\n- **Sequence Construction**: A nondecreasing sequence $a_0 \\le a_1 \\le \\dots \\le a_{n-1}$ of length $n$ is rotated by $k$ positions, where $0 \\le k < n$. This moves the last $k$ elements to the front.\n- **Pivot Node Definition**: The pivot node is the unique node at a $0$-based index $p$ satisfying one of two conditions:\n    1.  The key at index $p$ is strictly greater than the key at index $p+1$.\n    2.  If Condition 1 is never met (i.e., the list is entirely nondecreasing), then the pivot is the last node, at index $p = n-1$.\n- **Fundamental Assumptions**:\n    - Singly linked lists support forward traversal.\n    - A nondecreasing sequence implies $a_i \\le a_{i+1}$ for all valid $i$.\n    - A rotated nondecreasing sequence has at most one index $p$ where a strict decrease occurs ($a_p > a_{p+1}$).\n- **Task**:\n    - Write a program to find the index $p$ of the pivot node for several given lists.\n    - Return $-1$ for an empty list.\n- **Algorithmic Constraints**:\n    - Time Complexity: $\\mathcal{O}(n)$, where $n$ is the number of nodes.\n    - Auxiliary Space Complexity: $\\mathcal{O}(1)$.\n    - The algorithm must not convert the linked list into a random-access container.\n- **Test Suite**:\n    - Case A: keys $[8, 9, 1, 2, 3]$\n    - Case B: keys $[1, 2, 3, 4]$\n    - Case C: keys $[5]$\n    - Case D: keys $[]$\n    - Case E: keys $[7, 7, 7, 7]$\n    - Case F: keys $[3, 4, 5, 1, 2]$\n    - Case G: keys $[2, 1]$\n    - Case H: keys $[1, 2]$\n    - Case I: keys $[1, 1, 2, 2, 3, 3, 0, 1]$\n- **Output Format**: A single-line comma-separated list of pivot indices enclosed in square brackets, e.g., `[rA,rB,...]`.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is assessed against the required criteria.\n\n- **Scientifically Grounded**: The problem is well-grounded in the field of computer science, specifically data structures and algorithms. The concepts of linked lists, sorted sequences, rotation, and complexity analysis are standard and mathematically rigorous. The problem is free of any scientific or factual unsoundness.\n- **Well-Posed**: The problem is well-posed. The definition of the pivot node is precise and exhaustive. The structure of the input—a rotated, nondecreasing sequence—guarantees that there is at most one location of strict decrease, which ensures the pivot node is unique. The definition explicitly handles the cases of a non-rotated list (where the pivot is the tail) and special cases such as single-node lists. Additionally, the convention for an empty list (return $-1$) is clearly specified.\n- **Objective**: The problem is stated in objective, formal language. Terms like \"nondecreasing,\" \"strictly greater than,\" and \"0-based indexing\" are unambiguous. The task is to compute a numerical index, which is an objective outcome.\n\nBased on this analysis, the problem does not exhibit any of the invalidating flaws:\n1.  **Scientific/Factual Unsoundness**: None.\n2.  **Non-Formalizable/Irrelevant**: None. The problem is a classic algorithmic challenge directly concerning linked list traversal.\n3.  **Incomplete/Contradictory Setup**: None. All necessary information and definitions are provided and are consistent.\n4.  **Unrealistic/Infeasible**: None. The problem deals with abstract data structures and has no physical constraints.\n5.  **Ill-Posed/Poorly Structured**: None. A unique, meaningful solution exists for any valid input.\n6.  **Pseudo-Profound/Trivial**: None. The problem requires a careful implementation to respect the $\\mathcal{O}(n)$ time and $\\mathcal{O}(1)$ space constraints, making it a substantive exercise.\n7.  **Outside Scientific Verifiability**: None. The correctness and efficiency of the resulting algorithm are mathematically verifiable.\n\n### Step 3: Verdict and Action\n\nThe problem is deemed **valid**. A solution will be developed.\n\n### Solution Derivation\n\nThe objective is to devise an algorithm that identifies the pivot node's index in a singly linked list of length $n$, conforming to the time complexity of $\\mathcal{O}(n)$ and auxiliary space complexity of $\\mathcal{O}(1)$. The list is guaranteed to be a rotated, nondecreasing sequence of integers.\n\nThe definition of the pivot node provides a direct path to the solution. The pivot is located at index $p$ if either `node[p].key > node[p+1].key`, or if no such strict decrease exists, the pivot is the final node at index $p = n-1$. This definition suggests a linear scan of the list.\n\nThe algorithm proceeds as follows:\n\n1.  **Handle the Empty List**: The problem specifies that for an empty list, the function should return $-1$. This is the primary edge case. If the head of the list is null, we return $-1$ immediately.\n\n2.  **Traversal Setup**: We need to traverse the list from head to tail while keeping track of the current node's index. We initialize a pointer, let's call it `current_node`, to the `head` of the list, and an integer variable, `index`, to $0$.\n\n3.  **Iterative Search for the Pivot**: The core of the algorithm is a single forward traversal. We iterate through the list as long as the current node is not the last node. The condition for the loop is `current_node.next != null`.\n\n4.  **Pivot Condition Check**: Inside the loop, at each node, we check for the primary pivot condition. Let the key of the current node be $K_{curr}$ and the key of the next node be $K_{next}$. We test if $K_{curr} > K_{next}$.\n    - If this condition is true, we have found the point of \"wrap-around\" in the rotated sorted sequence. The current node is the pivot. We terminate the traversal and return the current value of `index`.\n    - If the condition is false (i.e., $K_{curr} \\le K_{next}$), the current node is not the pivot. We advance our traversal by updating `current_node` to `current_node.next` and incrementing `index` by $1$.\n\n5.  **Handling the Non-Rotated Case**: If the loop completes, it means the condition $K_{curr} > K_{next}$ was never met for any pair of adjacent nodes. This occurs when the list is perfectly nondecreasing (i.e., it was rotated by $k=0$ positions, or all elements are identical). According to the problem definition, in this scenario, the pivot is the last node of the list. When the loop terminates, `current_node` is pointing to the last node, and `index` holds its index, which is $n-1$. Therefore, after the loop concludes, we simply return the final value of `index`.\n\nThis single algorithm correctly handles all cases:\n- **Rotated List (e.g., $[8, 9, 1, 2, 3]$)**: The loop will find the node with key $9$ at index $1$. The condition `9 > 1` is true, so the algorithm returns $1$.\n- **Non-Rotated List (e.g., $[1, 2, 3, 4]$)**: The loop will run to completion without finding any strict decrease. The final value of `index` will be $3$, which corresponds to the last node. The algorithm returns $3$.\n- **Single-Node List (e.g., $[5]$)**: The `head` is not null. The loop condition `current_node.next != null` is immediately false. The loop does not execute. The function returns the initial `index`, which is $0$. This is correct, as the single node is also the last node.\n- **All Equal Elements (e.g., $[7, 7, 7, 7]$)**: This behaves like a non-rotated list. The condition `7 > 7` is always false. The loop finishes, and the algorithm returns the index of the last node, $3$.\n\n**Complexity Analysis**:\n- **Time Complexity**: The algorithm performs a single pass through the linked list. In the worst case, it visits every node once. Thus, for a list with $n$ nodes, the execution time is proportional to $n$. The time complexity is $\\mathcal{O}(n)$.\n- **Auxiliary Space Complexity**: The algorithm uses a fixed number of variables (`current_node`, `index`) to manage the traversal. The memory required for these variables is constant and does not scale with the size of the list. Therefore, the auxiliary space complexity is $\\mathcal{O}(1)$.\n\nThe proposed algorithm satisfies all problem constraints.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nfrom typing import List, Optional\n\nclass Node:\n    \"\"\"\n    Represents a node in a singly linked list.\n    \"\"\"\n    def __init__(self, key: int, next_node: Optional['Node'] = None):\n        self.key = key\n        self.next = next_node\n\ndef create_linked_list(keys: List[int]) -> Optional[Node]:\n    \"\"\"\n    Helper function to create a singly linked list from a list of keys.\n    \"\"\"\n    if not keys:\n        return None\n    \n    head = Node(keys[0])\n    current = head\n    for i in range(1, len(keys)):\n        current.next = Node(keys[i])\n        current = current.next\n    return head\n\ndef find_pivot_index(head: Optional[Node]) -> int:\n    \"\"\"\n    Finds the index of the pivot node in a given singly linked list.\n    The list is assumed to be a rotated, nondecreasing sequence of integers.\n\n    Args:\n        head: The head node of the singly linked list.\n\n    Returns:\n        The 0-based index of the pivot node. Returns -1 for an empty list.\n    \"\"\"\n    # Per the problem's convention for an empty list.\n    if not head:\n        return -1\n\n    # For a single-node list, the pivot is the node itself at index 0.\n    # The loop below correctly handles this case by not executing\n    # and returning the initial index of 0.\n\n    current_node = head\n    index = 0\n    \n    # Traverse the list until the second to last node.\n    while current_node.next:\n        # Check for the primary pivot condition: a strict decrease in key value.\n        if current_node.key > current_node.next.key:\n            return index\n        \n        # If no pivot is found, advance to the next node.\n        current_node = current_node.next\n        index += 1\n        \n    # If the loop completes without finding a strict decrease, the list\n    # is nondecreasing. By definition, the pivot is the last node.\n    # At this point, 'index' correctly holds the index of the last node.\n    return index\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [8, 9, 1, 2, 3],        # Case A\n        [1, 2, 3, 4],           # Case B\n        [5],                    # Case C\n        [],                     # Case D\n        [7, 7, 7, 7],           # Case E\n        [3, 4, 5, 1, 2],        # Case F\n        [2, 1],                 # Case G\n        [1, 2],                 # Case H\n        [1, 1, 2, 2, 3, 3, 0, 1]  # Case I\n    ]\n\n    results = []\n    for keys in test_cases:\n        # Construct the linked list for the current test case.\n        head = create_linked_list(keys)\n        \n        # Find the pivot index.\n        pivot_index = find_pivot_index(head)\n        \n        results.append(pivot_index)\n\n    # Final print statement in the exact required format.\n    # For the given test cases, the expected output is:\n    # A: index of 9 is 1\n    # B: index of 4 is 3\n    # C: index of 5 is 0\n    # D: empty list is -1\n    # E: index of last 7 is 3\n    # F: index of 5 is 2\n    # G: index of 2 is 0\n    # H: index of 2 is 1\n    # I: index of last 3 is 5\n    # Expected: [1, 3, 0, -1, 3, 2, 0, 1, 5]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3246366"}, {"introduction": "Next, we tackle a classic problem: finding the $k$-th to last element in a single pass, as if reading from a data stream that cannot be rewound. This scenario challenges you to think about how to solve problems that seem to require looking backward by instead using a clever memory structure. The solution introduces the powerful \"sliding window\" technique, demonstrating how a fixed-size buffer can maintain a history of recently seen elements. [@problem_id:3246395]", "problem": "You are given a singly linked list whose elements are only accessible through a sequential, read-once interface that yields node values in order and does not allow rewinding, random access, or multiple passes. The task is to determine, for each specified $k$, the $k$-th to last element of the list according to the following definition: the $1$-st to last element is the final element, the $2$-nd to last element is the element just before the final element, and so on. You must design a one-pass algorithm that uses space proportional to $k$ and justify its correctness from first principles.\n\nFundamental base for derivation:\n- Definition of a singly linked list: a sequence of nodes where each node stores a value and a reference to the next node; traversal proceeds from head to tail by following the next references.\n- Streaming (read-once) access: the interface exposes elements in order; each element is seen at most once; there is no ability to move backward.\n- First-In First-Out (FIFO) queue: a container that maintains insertion order and supports removing the oldest element first.\n\nConstraints and requirements:\n- Let the list length be $n \\in \\mathbb{Z}_{\\ge 0}$ and the target index be $k \\in \\mathbb{Z}_{\\ge 1}$. You must compute the $k$-th to last element using a single pass over the stream of node values, storing at most a number of values proportional to $k$ (that is, extra space $O(k)$), and time $O(n)$.\n- If $k &gt; n$, there is no $k$-th to last element; in this case, output the integer $-1$.\n- All node values are integers in the range $\\left[0, 10^{9}\\right]$; therefore, returning $-1$ unambiguously signals the invalid-$k$ condition.\n\nTest suite:\nFor each pair, the first component is the stream of node values in head-to-tail order, and the second is $k$.\n1. Stream $[\\;7, 1, 3, 9, 2, 4, 8\\;]$, $k = 3$.\n2. Stream $[\\;5\\;]$, $k = 1$.\n3. Stream $[\\;10, 20, 30, 40, 50\\;]$, $k = 5$.\n4. Stream $[\\;1, 2, 3\\;]$, $k = 4$.\n5. Stream $[\\;0, 0, 0, 0\\;]$, $k = 2$.\n6. Stream $[\\;2, 9, 1, 8, 7\\;]$, $k = 1$.\n7. Stream $[\\;42, 99\\;]$, $k = 2$.\n8. Stream $[\\; \\;]$ (empty stream), $k = 1$.\n\nOutput specification:\n- Implement a complete, runnable program that evaluates the above eight cases in order and produces a single line of output containing the eight integer results in order, as a comma-separated list enclosed in square brackets. For example, the format is $[\\;\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_8\\;]$.", "solution": "We begin from the core definitions. A singly linked list exposes elements in a fixed order from head to tail. Under a read-once streaming model, each element can be consumed exactly once in that order; there is no ability to revisit earlier elements. We want the $k$-th to last element: the element whose position from the tail is $k$, where $k \\in \\mathbb{Z}_{\\ge 1}$.\n\nDesign principle from first principles:\n- Since we cannot look back, any decision about the $k$-th to last element must be deferred until the end of the stream, because the identity of the last $k$ elements is only fully determined after observing all $n$ items.\n- To retain only the information necessary for this decision, we can store precisely the last $k$ elements seen so far as we sweep forward. This suggests maintaining a First-In First-Out (FIFO) queue of capacity $k$: when a new element arrives, we append it; if the queue exceeds size $k$, we remove the oldest element. After consuming the entire stream, if the stream length $n \\ge k$, the queue contains exactly the last $k$ elements in order, and the oldest element among them is the $k$-th to last element of the full list.\n\nAlgorithmic invariant:\nLet $Q_i$ denote the contents of the queue after processing the prefix of length $i$, where $i \\in \\{0,1,\\dots,n\\}$. We maintain the invariant:\n- $Q_i$ contains the last $\\min(i,k)$ elements of the length-$i$ prefix, in the same order they appeared.\nThis is established by induction:\n- Base case $i=0$: $Q_0$ is empty; it contains the last $\\min(0,k) = 0$ elements, vacuously true.\n- Inductive step $i \\to i+1$: Let the $(i+1)$-st element be $x_{i+1}$. Before insertion, $Q_i$ holds the last $\\min(i,k)$ elements of the prefix. Appending $x_{i+1}$ yields a container with the last $\\min(i,k)+1$ elements of the $(i+1)$-length prefix. If $\\min(i,k)+1 \\le k$, no eviction occurs and $\\min(i+1,k) = \\min(i,k)+1$, so the invariant holds. If $\\min(i,k)+1 = k+1$, we evict the oldest element; the container now holds exactly the last $k = \\min(i+1,k)$ elements, again preserving the invariant.\n\nCorrectness:\nAt the end of the stream ($i = n$), by the invariant $Q_n$ contains the last $\\min(n,k)$ elements of the full list in order. If $n \\ge k$, then $Q_n$ has size $k$ and its oldest element is the $k$-th to last element of the entire list, so returning the front element is correct. If $n &lt; k$, then there is no $k$-th to last element; in this case the algorithm detects that $|Q_n| &lt; k$ and reports $-1$, as specified.\n\nLower bound on space in the one-pass streaming model:\nWe argue that any one-pass algorithm must use at least $\\Omega(k)$ additional space in the worst case. Consider two streams $S$ and $S'$ that are identical on their first $n-k$ elements and differ on their last $k$ elements so that their $k$-th to last elements differ. Any algorithm that stores fewer than $k$ elements worth of information cannot, after reading only the first $n-k$ elements, retain sufficient information to distinguish all possible continuations of the last $k$ elements. By an adversary argument, if the algorithm retains fewer than $k$ elements, there exist two completions of the stream that lead to identical internal states but different correct answers for the $k$-th to last element, implying the algorithm must err on at least one of them. Therefore, in the worst case, any correct one-pass algorithm requires $\\Omega(k)$ space, matching the $O(k)$ space of the queue approach up to constant factors.\n\nComplexity:\nEach of the $n$ elements is enqueued once and, when necessary, causes at most one eviction, each operation taking $O(1)$ time in a standard FIFO queue implementation. Thus the total time is $O(n)$ and the extra space is $O(k)$.\n\nEdge cases:\n- If $k \\le 0$, the query is ill-posed relative to the definition of $k$-th to last with $k \\in \\mathbb{Z}_{\\ge 1}$; we map such cases to the specified error indicator $-1$.\n- If the stream is empty ($n = 0$) or $k &gt; n$, we return $-1$.\n- If $k = 1$, we return the last element; if $k = n$, we return the head element.\n\nApplication to the test suite:\n1. For $[\\;7, 1, 3, 9, 2, 4, 8\\;]$ with $k = 3$, the final queue is $[\\;2, 4, 8\\;]$, so answer $2$.\n2. For $[\\;5\\;]$ with $k = 1$, the final queue is $[\\;5\\;]$, so answer $5$.\n3. For $[\\;10, 20, 30, 40, 50\\;]$ with $k = 5$, the final queue is $[\\;10, 20, 30, 40, 50\\;]$, so answer $10$.\n4. For $[\\;1, 2, 3\\;]$ with $k = 4$, the final queue has size $3 &lt; 4$, so answer $-1$.\n5. For $[\\;0, 0, 0, 0\\;]$ with $k = 2$, the final queue is $[\\;0, 0\\;]$, so answer $0$.\n6. For $[\\;2, 9, 1, 8, 7\\;]$ with $k = 1$, the final queue is $[\\;7\\;]$, so answer $7$.\n7. For $[\\;42, 99\\;]$ with $k = 2$, the final queue is $[\\;42, 99\\;]$, so answer $42$.\n8. For $[\\; \\;]$ with $k = 1$, the final queue is empty, so answer $-1$.\n\nThe implementation below follows this design, treating the linked list as a stream and maintaining a FIFO queue of capacity $k$ to capture exactly the last $k$ elements in one pass.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nfrom collections import deque\nfrom typing import Iterable, List, Tuple\n\ndef kth_to_last_stream(stream: Iterable[int], k: int) -> int:\n    \"\"\"\n    Compute the k-th to last element from a read-once stream of integers.\n    Returns -1 if k <= 0 or if the stream has fewer than k elements.\n    The algorithm uses a fixed-capacity FIFO buffer of size k.\n    \"\"\"\n    if k <= 0:\n        return -1\n    buffer = deque(maxlen=k)  # holds at most the last k seen elements\n    for value in stream:\n        buffer.append(value)\n    if len(buffer) < k:\n        return -1\n    # The k-th to last element is the oldest among the last k elements.\n    return buffer[0]\n\ndef solve():\n    # Define the test cases from the problem statement as (stream_values, k).\n    test_cases: List[Tuple[List[int], int]] = [\n        ([7, 1, 3, 9, 2, 4, 8], 3),   # expected 2\n        ([5], 1),                     # expected 5\n        ([10, 20, 30, 40, 50], 5),    # expected 10\n        ([1, 2, 3], 4),               # expected -1 (k > n)\n        ([0, 0, 0, 0], 2),            # expected 0\n        ([2, 9, 1, 8, 7], 1),         # expected 7\n        ([42, 99], 2),                # expected 42\n        ([], 1),                      # expected -1 (empty stream)\n    ]\n\n    results: List[int] = []\n    for values, k in test_cases:\n        # Convert the list to an iterator to emphasize single-pass streaming usage.\n        result = kth_to_last_stream(iter(values), k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3246395"}, {"introduction": "Our final practice illustrates a fundamental limitation of sequential-access data structures when dealing with global properties. The goal is to find the node whose value is closest to the list's arithmetic mean, a value that can only be calculated after seeing all elements. This problem highlights why a single pass is sometimes insufficient and how a multi-pass algorithm becomes necessary: one pass to gather aggregate data, and a second to perform the search using that data. [@problem_id:3246418]", "problem": "You are given a singly linked list whose nodes store integer values. Let the list have length $n \\geq 0$, with node values denoted by $x_0, x_1, \\dots, x_{n-1}$, where $x_i \\in \\mathbb{Z}$ and $x_0$ is the head of the list. The arithmetic mean $\\mu$ of the values is defined by $\\mu = \\frac{1}{n}\\sum_{i=0}^{n-1} x_i$ for $n > 0$. Define the absolute deviation of a node at index $i$ as $d_i = \\lvert x_i - \\mu \\rvert$. Your task is to implement a program that traverses the linked list and returns the index $k$ such that $d_k$ is minimized. In the case of ties where multiple indices achieve the same minimal deviation, select the smallest such index. If the list is empty (that is, $n = 0$), return $-1$.\n\nYou must construct a singly linked list data structure and perform the necessary traversal and search operations without converting the list to a random-access structure. Assume all arithmetic is performed in standard double-precision floating point for the mean computation. Indices are zero-based, so the head node has index $0$.\n\nFundamental base and constraints to use:\n- A singly linked list consists of nodes, each storing a value $x \\in \\mathbb{Z}$ and a pointer to the next node, with traversal performed by following next pointers from the head.\n- The arithmetic mean is defined as $\\mu = \\frac{1}{n}\\sum_{i=0}^{n-1} x_i$ for $n > 0$.\n- Absolute deviation is defined by $d_i = \\lvert x_i - \\mu \\rvert$.\n\nYour program must implement this logic and apply it to the following test suite of lists, where each list is provided as a sequence to be converted into a singly linked list:\n- Test $1$: $\\left[5, 2, 9, -3, 7\\right]$\n- Test $2$: $\\left[10\\right]$\n- Test $3$: $\\left[-1, 1\\right]$\n- Test $4$: $\\left[8, 8, 8, 8\\right]$\n- Test $5$: $\\left[-5, -4, -3, -2, -1\\right]$\n- Test $6$: $\\left[\\right]$ (the empty list)\n- Test $7$: $\\left[3, 4, 5\\right]$\n- Test $8$: $\\left[1000000000, -1000000000\\right]$\n\nFor each test, output a single integer: the index $k$ of the node whose value is closest to the mean $\\mu$ as defined above, with the tie-breaking rule of choosing the smallest index in case of equal deviations. For the empty list, output $-1$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the tests above (for example, $\\left[\\text{result}_1, \\text{result}_2, \\dots\\right]$).", "solution": "The problem is valid. It is scientifically grounded in standard definitions from mathematics and computer science, well-posed with a unique solution guaranteed by the tie-breaking rule, and expressed in objective, formal language. All necessary conditions and data are provided, and there are no internal contradictions.\n\nThe task is to find the index $k$ of a node in a singly linked list whose value $x_k$ is closest to the arithmetic mean $\\mu$ of all values in the list. The absolute deviation is given by $d_i = \\lvert x_i - \\mu \\rvert$, and we seek to find the index $k$ that minimizes $d_k$.\n\nThe core of the problem's design is dictated by two fundamental principles: the definition of the arithmetic mean and the traversal constraint of a singly linked list.\n\n1.  **Computation of the Mean $\\mu$**: The arithmetic mean is defined as $\\mu = \\frac{1}{n}\\sum_{i=0}^{n-1} x_i$ for a list of length $n > 0$. To calculate $\\mu$, we need two aggregate quantities: the total sum of the node values, $\\sum_{i=0}^{n-1} x_i$, and the total number of nodes, $n$.\n\n2.  **Singly Linked List Traversal**: A singly linked list is a sequential-access data structure. Traversal can only proceed in one direction, from the head node to its successor, until the end of the list is reached. It is not possible to access an arbitrary node by its index without traversing all preceding nodes.\n\nThese two principles necessitate a two-pass algorithm. A single pass is insufficient because the value of $\\mu$ is required to calculate the deviation $d_i$ for any given node $x_i$, but $\\mu$ itself can only be computed after all nodes have been visited to find the total sum and count.\n\nThe algorithm proceeds as follows:\n\n**Step 1: Handle the Empty List Case**\nFirst, we check if the list is empty (i.e., its head is `None`). If so, $n=0$. As stipulated by the problem, we return $-1$.\n\n**Step 2: First Pass - Calculate Sum and Count**\nWe traverse the linked list from the head to the tail to compute the total sum of its values and the number of nodes.\n- Initialize a sum variable, $S$, to $0$.\n- Initialize a count variable, $n$, to $0$.\n- Starting with a pointer `current` at the head of the list, we iterate until `current` is `None`:\n  - Add the value of the `current` node to $S$: $S \\leftarrow S + \\text{current.value}$.\n  - Increment the node count: $n \\leftarrow n + 1$.\n  - Advance the pointer: `current` $\\leftarrow$ `current.next`.\n\nAfter this pass, if $n > 0$, we have the necessary components to calculate the mean.\n\n**Step 3: Calculate the Mean**\nThe arithmetic mean $\\mu$ is calculated using floating-point arithmetic as $\\mu = S / n$.\n\n**Step 4: Second Pass - Find the Index of Minimum Deviation**\nWe must traverse the list a second time to compare each node's value against the now-known mean $\\mu$.\n- Initialize a variable `min_deviation` to positive infinity, $\\infty$. This ensures that the deviation of the first node will be smaller.\n- Initialize a variable `result_index` to a placeholder value (e.g., $-1$ or $0$).\n- Initialize a `current_index` to $0$.\n- Reset the `current` pointer back to the head of the list.\n- We iterate through the list again:\n  - For the node at `current_index` with value $x_i$, calculate its absolute deviation: $d_i = \\lvert x_i - \\mu \\rvert$.\n  - Compare this deviation to `min_deviation`. If $d_i < \\text{min\\_deviation}$:\n    - A new minimum deviation has been found. Update `min_deviation` to $d_i$.\n    - Update `result_index` to `current_index`.\n  - The tie-breaking rule states that if multiple indices have the same minimal deviation, the smallest such index should be chosen. The strict inequality ($<$) in our comparison naturally handles this. If a later node has a deviation equal to the current `min_deviation`, its index will not be chosen, preserving the smaller index already stored in `result_index`.\n  - Increment `current_index`.\n  - Advance the `current` pointer.\n\n**Step 5: Return the Result**\nAfter the second pass is complete, `result_index` holds the smallest index $k$ that minimizes the deviation $d_k$. This value is returned. For a non-empty list, this will be an integer greater than or equal to $0$.\n\nThe implementation will require a `Node` class to represent the elements of the linked list and a main function to orchestrate the two-pass traversal and calculations for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\nclass Node:\n    \"\"\"\n    Represents a node in a singly linked list.\n    Each node stores an integer value and a reference to the next node.\n    \"\"\"\n    def __init__(self, value: int):\n        self.value = value\n        self.next = None\n\nclass SinglyLinkedList:\n    \"\"\"\n    Represents a singly linked list.\n    \"\"\"\n    def __init__(self):\n        self.head = None\n    \n    def append(self, value: int):\n        \"\"\"Appends a new node with the given value to the end of the list.\"\"\"\n        new_node = Node(value)\n        if not self.head:\n            self.head = new_node\n            return\n        \n        last_node = self.head\n        while last_node.next:\n            last_node = last_node.next\n        last_node.next = new_node\n\ndef find_closest_to_mean(linked_list: SinglyLinkedList) -> int:\n    \"\"\"\n    Finds the index of the node whose value is closest to the arithmetic mean\n    of all values in a singly linked list.\n    \n    Args:\n        linked_list: The singly linked list to search.\n        \n    Returns:\n        The 0-based index of the node with the minimum absolute deviation from the mean.\n        If there's a tie, the smallest index is returned.\n        Returns -1 if the list is empty.\n    \"\"\"\n    # Step 1: Handle the empty list case\n    if not linked_list.head:\n        return -1\n\n    # Step 2: First pass - Calculate sum and count.\n    # Mathematical variables: S (total_sum), n (node_count)\n    total_sum = 0\n    node_count = 0\n    current = linked_list.head\n    while current:\n        total_sum += current.value\n        node_count += 1\n        current = current.next\n\n    # Step 3: Calculate the mean.\n    # Mathematical variable: mu (mean)\n    # The problem specifies using standard double-precision floating point.\n    # Python's default float is double-precision.\n    if node_count > 0:\n        mean = total_sum / node_count\n    else: # This case is already handled by the initial check but included for completeness.\n        return -1\n\n    # Step 4: Second pass - Find the index of minimum deviation.\n    # Mathematical variables: d_i (deviation), min_deviation\n    min_deviation = float('inf')\n    result_index = -1\n    current_index = 0\n    current = linked_list.head\n    \n    while current:\n        deviation = abs(current.value - mean)\n        \n        if deviation < min_deviation:\n            min_deviation = deviation\n            result_index = current_index\n        \n        current_index += 1\n        current = current.next\n\n    # Step 5: Return the result.\n    return result_index\n\n\ndef solve():\n    \"\"\"\n    Main execution function to run the defined test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [5, 2, 9, -3, 7],\n        [10],\n        [-1, 1],\n        [8, 8, 8, 8],\n        [-5, -4, -3, -2, -1],\n        [],\n        [3, 4, 5],\n        [1000000000, -1000000000]\n    ]\n\n    results = []\n    for case in test_cases:\n        # Create and populate the singly linked list for the current test case.\n        ll = SinglyLinkedList()\n        for value in case:\n            ll.append(value)\n        \n        # Find the index of the node closest to the mean.\n        result = find_closest_to_mean(ll)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3246418"}]}