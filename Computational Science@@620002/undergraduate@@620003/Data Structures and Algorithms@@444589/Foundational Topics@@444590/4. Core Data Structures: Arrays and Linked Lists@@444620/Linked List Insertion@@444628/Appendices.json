{"hands_on_practices": [{"introduction": "This first practice exercise moves beyond simple list appends to a more constrained and complex scenario. Here, we will work with a circular, doubly linked list that must always maintain its elements in sorted order. This task reinforces the core mechanics of pointer manipulation within a data structure governed by multiple invariants: non-decreasing order, circularity, and bidirectional links [@problem_id:3229897]. Successfully completing this implementation requires careful, case-by-case analysis, a fundamental skill for any developer working with linked data structures.", "problem": "You are to implement a circular Doubly Linked List (DLL) that supports sorted insertion while maintaining the nondecreasing order invariant over the node keys. A circular DLL consists of nodes where each node stores a key, a pointer to the next node, and a pointer to the previous node. The list is circular: if the list is nonempty, the previous pointer of the head points to the tail, and the next pointer of the tail points to the head. The head pointer must always refer to a node whose key equals the minimum key in the list. A sorted insertion must place a new key into a position that preserves the nondecreasing order under forward traversal starting from the head.\n\nDefinitions and invariants to maintain:\n- Each node stores a single integer key, denoted by $k \\in \\mathbb{Z}$.\n- For a nonempty list with head $H$, let $H = v_0$. A complete forward traversal visits nodes $v_0, v_1, \\dots, v_{n-1}$ exactly once and returns to $v_0$. The nondecreasing order invariant requires $v_i.\\text{key} \\le v_{i+1}.\\text{key}$ for all $i \\in \\{0,1,\\dots,n-2\\}$. Circularity requires $v_{n-1}.\\text{next} = v_0$ and $v_0.\\text{prev} = v_{n-1}$.\n- The head pointer must always point to a node whose key is the minimum in the set of keys currently stored. If the list is empty, the head pointer is null.\n\nYour task:\n- Implement a circular DLL with a method SortedInsert that takes an integer key $x \\in \\mathbb{Z}$ and inserts a new node with key $x$ so that the nondecreasing order invariant is preserved. The algorithm must be correct for all cases including:\n  - Inserting into an empty list.\n  - Inserting as the new minimum (becoming the new head).\n  - Inserting as the new maximum (at the tail).\n  - Inserting between two existing keys.\n  - Inserting when duplicate keys exist (the final order must remain nondecreasing; any valid position among equal keys is acceptable).\n- After each series of insertions for a given test case, perform a forward traversal starting at the head to produce the final sequence of keys. This sequence will be the result for that test case.\n\nFundamental base from which to design and reason:\n- Node-level pointer invariants: For any two adjacent nodes under forward traversal, say nodes $u$ and $v$, the doubly linked structure must satisfy $u.\\text{next} = v$ and $v.\\text{prev} = u$.\n- Circularity constraints: For a nonempty list with head $H$ and tail $T$, we must have $T.\\text{next} = H$ and $H.\\text{prev} = T$.\n- Order relation: Nondecreasing order means for the forward traversal $v_0, v_1, \\dots, v_{n-1}$, we require $v_i.\\text{key} \\le v_{i+1}.\\text{key}$ for all applicable $i$.\n- Termination condition on traversal: A complete pass has occurred when a moving pointer revisits the head $H$.\n\nInput specification:\n- There is no external input. Your program must internally construct and process the following test suite. Each test case is a sequence of integer keys to be inserted, in the given order, into an initially empty circular DLL:\n  1. Insert the single element $[5]$.\n  2. Insert the ascending sequence $[1, 2, 3, 4]$.\n  3. Insert the descending sequence $[4, 3, 2, 1]$.\n  4. Insert the mixed sequence with duplicates $[3, 1, 2, 2, 5, 4, 0, 3]$.\n  5. Insert negative and nonnegative keys $[-1, -3, 2, -2, 0, 2]$.\n  6. Insert all equal keys $[2, 2, 2, 2]$.\n\nOutput specification:\n- For each test case, after all its insertions, produce the forward traversal sequence from the head as a list of integers.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this top-level list corresponds to one test case’s result and is itself a list of integers. There must be no spaces anywhere in the output. For example, if there were two test cases with forward sequences $[1, 2]$ and $[3]$, the output format must be exactly \"[[1,2],[3]]\".\n\nComputational requirements:\n- The SortedInsert operation must run in time $O(n)$ in the worst case for a list of size $n$, and it must preserve the DLL pointer invariants and circularity for all cases.\n\nAngle units, physical units, and percentage formatting are not applicable here.\n\nThe final answer type for each test case is a list of integers. The program’s single-line output is thus a list of lists of integers, formatted exactly as specified above.", "solution": "The problem statement has been validated and is deemed sound. It is a well-defined, self-contained, and formalizable problem within the domain of data structures and algorithms. There are no scientific or factual unsoundness, contradictions, or ambiguities. All invariants and requirements are clearly specified.\n\nThe task is to design and implement a `SortedInsert` method for a circular doubly linked list (DLL) that maintains a nondecreasing order of keys. The implementation must respect several invariants: the circular nature of the list, the doubly-linked pointer integrity, and the constraint that the `head` pointer always references the node with the minimum key.\n\nFirst, we define the fundamental data structure, the node. Each node, denoted as $v$, is an object containing three fields: an integer key $v.\\text{key} \\in \\mathbb{Z}$, a pointer to the next node $v.\\text{next}$, and a pointer to the previous node $v.\\text{prev}$.\n\nThe circular DLL itself is managed by a class that maintains a single pointer, `head`. If the list is empty, `head` is null. Otherwise, `head` points to the node $v_0$ where $v_0.\\text{key}$ is the minimum among all keys in the list. For a non-empty list with head $H$ and tail $T$, the circularity invariant requires $T.\\text{next} = H$ and $H.\\text{prev} = T$.\n\nThe core of the problem is the implementation of the `SortedInsert(x)` method, which inserts a new node with key $x \\in \\mathbb{Z}$ into the list while preserving all invariants. The logic can be systematically decomposed into distinct cases. Let $N$ be the new node to be created, such that $N.\\text{key} = x$.\n\nCase 1: Insertion into an empty list.\nIf the list's `head` pointer is null, the list is empty. The new node $N$ becomes the sole element. To maintain circularity, its `next` and `prev` pointers must point to itself.\n$$N.\\text{next} \\leftarrow N$$\n$$N.\\text{prev} \\leftarrow N$$\nThe `head` pointer of the list is then updated to point to $N$.\n$$\\text{head} \\leftarrow N$$\n\nCase 2: Insertion into a non-empty list.\nLet $H$ be the current head node of the list. Two sub-cases arise based on the value of the new key $x$ relative to the existing minimum, $H.\\text{key}$.\n\nSubcase 2a: The new key is the new minimum.\nThis occurs if $x \\le H.\\text{key}$. According to the head-invariant, the new node $N$ must become the new head of the list. $N$ must be inserted immediately before $H$. The tail of the list, $T$, can be found via $T = H.\\text{prev}$. The pointers must be updated to establish the links $T \\leftrightarrow N \\leftrightarrow H$.\nThe required pointer assignments are:\n$1$. $N.\\text{next} \\leftarrow H$\n$2$. $N.\\text{prev} \\leftarrow T$\n$3$. $H.\\text{prev} \\leftarrow N$\n$4$. $T.\\text{next} \\leftarrow N$\nFinally, the list's `head` pointer must be updated to $N$:\n$$\\text{head} \\leftarrow N$$\n\nSubcase 2b: The new key is not the new minimum.\nThis occurs if $x  H.\\text{key}$. The new node $N$ must be inserted at some position after the head. We must traverse the list to find the correct position. The goal is to find two adjacent nodes, $u$ and $v = u.\\text{next}$, such that $u.\\text{key} \\le x$ and insertion of $N$ between them preserves the nondecreasing order. We can achieve this by searching for the last node $u$ whose key is less than $x$.\nWe initialize a traversal pointer, `current`, to `head`. We then advance `current` forward as long as the next node's key is less than $x$. Critically, the traversal must also handle the wrap-around condition of the circular list. The loop condition is `current.next != head` AND `current.next.key  x`.\nThe loop terminates when `current` is the node that should immediately precede $N$. Let this predecessor node be $P = \\text{current}$ and its successor be $S = P.\\text{next}$. The node $N$ is to be inserted between $P$ and $S$. The pointer updates are:\n$1$. $N.\\text{next} \\leftarrow S$\n$2$. $N.\\text{prev} \\leftarrow P$\n$3$. $P.\\text{next} \\leftarrow N$\n$4$. $S.\\text{prev} \\leftarrow N$\nThis single logic block correctly handles insertion into the middle of the list as well as insertion at the end (i.e., when $x$ is greater than or equal to all existing keys). In the latter case, the traversal loop will complete a full circle, and `current` will be the tail node $T$, with `current.next` being the head $H$. The new node will be correctly inserted between $T$ and $H$, becoming the new tail.\n\nTo produce the required output, a forward traversal method is needed. This method starts at the `head` node. If the list is not empty, it iterates through the list using the `next` pointers, collecting the keys in sequence, until the traversal pointer returns to the `head`. A do-while loop is the natural construct for this, as the body must execute at least once for the head node.\n\nThe computational complexity of the `SortedInsert` operation is determined by the traversal step. In the worst-case scenario (inserting a key that is the new maximum), the algorithm must traverse the entire list of size $n$. Therefore, the time complexity is $O(n)$. The space complexity is $O(1)$ as it only requires a fixed number of pointers and a new node.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in a doubly linked list.\n    Each node stores an integer key and pointers to the next and previous nodes.\n    \"\"\"\n    def __init__(self, key: int):\n        self.key = key\n        self.next = None\n        self.prev = None\n\nclass CircularDLL:\n    \"\"\"\n    Implements a circular doubly linked list that maintains keys in nondecreasing order.\n    The head pointer always points to the node with the minimum key.\n    \"\"\"\n    def __init__(self):\n        self.head = None\n\n    def sorted_insert(self, key: int):\n        \"\"\"\n        Inserts a new node with the given key into the list while maintaining\n        the sorted, circular, and doubly linked properties.\n        \"\"\"\n        new_node = Node(key)\n\n        # Case 1: The list is empty.\n        if self.head is None:\n            new_node.next = new_node\n            new_node.prev = new_node\n            self.head = new_node\n            return\n\n        # Case 2: The new key is less than or equal to the head's key.\n        # The new node becomes the new head.\n        if key = self.head.key:\n            tail = self.head.prev\n            \n            new_node.next = self.head\n            new_node.prev = tail\n            \n            tail.next = new_node\n            self.head.prev = new_node\n            \n            self.head = new_node\n            return\n\n        # Case 3: The new key must be inserted in the middle or at the end.\n        # Traverse to find the correct insertion point.\n        current = self.head\n        # Find the node after which the new node should be inserted.\n        while current.next != self.head and current.next.key  key:\n            current = current.next\n        \n        # 'current' is now the predecessor. 'next_node' is the successor.\n        next_node = current.next\n        \n        new_node.next = next_node\n        new_node.prev = current\n        \n        current.next = new_node\n        next_node.prev = new_node\n\n    def get_list_as_array(self) - list[int]:\n        \"\"\"\n        Performs a forward traversal from the head and returns the keys as a list.\n        \"\"\"\n        if self.head is None:\n            return []\n        \n        result = []\n        current = self.head\n        # Emulate a do-while loop to traverse the circular list\n        while True:\n            result.append(current.key)\n            current = current.next\n            if current == self.head:\n                break\n        return result\n\ndef solve():\n    \"\"\"\n    Runs the test suite as specified in the problem statement and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [5],\n        [1, 2, 3, 4],\n        [4, 3, 2, 1],\n        [3, 1, 2, 2, 5, 4, 0, 3],\n        [-1, -3, 2, -2, 0, 2],\n        [2, 2, 2, 2],\n    ]\n\n    results = []\n    for insertions in test_cases:\n        dll = CircularDLL()\n        for key in insertions:\n            dll.sorted_insert(key)\n        results.append(dll.get_list_as_array())\n\n    # Format the final output string to be exactly \"[[...],[...]]\" with no spaces.\n    # The default str() for lists includes spaces, which violates the output requirement.\n    # We construct the string manually for precise formatting.\n    list_of_list_strs = []\n    for res_list in results:\n        list_str = f\"[{','.join(map(str, res_list))}]\"\n        list_of_list_strs.append(list_str)\n    \n    final_output_str = f\"[{','.join(list_of_list_strs)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```", "id": "3229897"}, {"introduction": "Having mastered sequential insertion, we now explore what can go wrong in a concurrent environment. This thought experiment examines a seemingly correct tail-insertion algorithm when executed by multiple threads without any protective locks. The exercise reveals the critical concept of a race condition, where the final state of the data structure depends on the unpredictable interleaving of operations from different threads [@problem_id:3245948]. By diagnosing a specific failure mode, you will gain a deeper appreciation for why atomicity is essential and why synchronization primitives are required in multithreaded programming.", "problem": "Consider a singly linked list with pointers $head$ and $tail$, where the representation invariant is that the list is a finite sequence of nodes $n_0, n_1, \\dots, n_k$ with $head = n_0$, $tail = n_k$, $n_i.next = n_{i+1}$ for all $i$ with $0 \\le i  k$, and $n_k.next = \\varnothing$. The insertion routine at the tail is implemented as the following compound, non-atomic sequence executed by a thread on a new node $x$:\n- Step $1$: set $x.next \\leftarrow \\varnothing$,\n- Step $2$: read $t \\leftarrow tail$,\n- Step $3$: set $t.next \\leftarrow x$,\n- Step $4$: set $tail \\leftarrow x$.\nAssume all pointer reads and writes are individually atomic and the memory model is Sequential Consistency (SC), meaning all threads observe operations as some interleaving that preserves program order per thread. There are two concurrent threads, $T_1$ and $T_2$, both performing tail insertion using the above routine without mutual exclusion.\n\nA bug has been reported in stress testing where, under concurrent tail insertions, the $tail$ pointer is lost or becomes inconsistent with the actual last node in the chain, violating the invariant $tail = n_k$. You are asked to diagnose a plausible bug pattern that can cause this under the stated assumptions and to design a stress test schedule that deterministically triggers the failure by aligning operations into a precise timing window using barriers or latches (for example, each thread busy-waits on a shared flag until a condition is met).\n\nWhich option correctly identifies a bug mechanism consistent with Sequential Consistency (SC) and provides a deterministic two-thread schedule that triggers the loss of $tail$?\n\nA. Diagnosis: The compound tail advancement is non-atomic, so two threads can race on the shared predecessor’s $next$ field; the last write to $t.next$ “wins,” and if the earlier thread later writes $tail$ with its own node, $tail$ can end up pointing to a node that is not linked at the end of the list. Deterministic schedule:\n- Initialize with a single node $a$ such that $head = tail = a$.\n- Thread $T_1$: allocate $x_1$, perform Step $1$, Step $2$ reading $t = a$, perform Step $3$ writing $a.next \\leftarrow x_1$, then block on barrier $b_1$ before Step $4$.\n- Thread $T_2$: allocate $x_2$, perform Step $1$, Step $2$ reading $t = a$ (since $tail$ is still $a$), perform Step $3$ writing $a.next \\leftarrow x_2$ (overwriting $x_1$), then perform Step $4$ writing $tail \\leftarrow x_2$, then signal $b_1$ to release $T_1$.\n- Resume Thread $T_1$: perform Step $4$ writing $tail \\leftarrow x_1$.\nPostcondition: $a.next = x_2$, $tail = x_1$, violating $tail = n_k$ because $x_1$ is not at the end of the chain; the invariant is broken deterministically.\n\nB. Diagnosis: Instruction reordering causes $tail \\leftarrow x$ (Step $4$) to occur before $t.next \\leftarrow x$ (Step $3$), creating a temporal window where $tail$ points to an unlinked node and another thread reads and updates $tail$ incorrectly. Deterministic schedule: force $T_1$’s Step $4$ to execute before its Step $3$ via processor reordering, then have $T_2$ read $tail$ and perform Step $3$ and Step $4$ rapidly.\n  \nC. Diagnosis: The “ABA problem” on $tail$ when using Compare-And-Swap (CAS) to update $tail$ without protecting the $next$ field; a node can temporarily become $tail$, then not, then the same node value appears again, confusing CAS-based logic. Deterministic schedule: interleave three insertions so that $tail$ cycles through $x_1$, $x_2$, $x_1$, making a CAS on $tail$ succeed spuriously and losing the final $next$ link.\n\nD. Diagnosis: Traversal-based tail discovery races with concurrent insertions because the last node’s $next$ is not set to $\\varnothing$, so traversal continues past the intended end; simultaneous updates cause the traversal to skip nodes and land on a stale tail. Deterministic schedule: start with a list where the last node’s $next$ is non-$\\varnothing$, then run one inserter and one traverser to the tail, pausing the inserter between Step $2$ and Step $3$ to cause the traverser to misidentify the tail and the inserter to write through a stale node.\n\nSelect the correct option.", "solution": "The user has provided a problem concerning a race condition in a concurrent, non-atomic, tail-insertion algorithm for a singly linked list. The task is to validate the problem, derive a correct failure mechanism under Sequential Consistency, and evaluate the given options.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n-   **Data Structure:** A singly linked list with `$head$` and `$tail$` pointers.\n-   **Representation Invariant:** The list is a sequence `$n_0, n_1, \\dots, n_k$`, where `$head = n_0$`, `$tail = n_k$`, `$n_i.next = n_{i+1}$` for `$0 \\le i  k$`, and `$n_k.next = \\varnothing$`.\n-   **Tail Insertion Routine for a new node `$x$`:**\n    1.  `$x.next \\leftarrow \\varnothing$`\n    2.  `$t \\leftarrow tail$`\n    3.  `$t.next \\leftarrow x$`\n    4.  `$tail \\leftarrow x$`\n-   **Concurrency Model:**\n    -   Two threads, `$T_1$` and `$T_2$`, concurrently execute the tail insertion routine.\n    -   No mutual exclusion is used.\n    -   Pointer reads and writes are individually atomic.\n    -   The memory model is Sequential Consistency (SC).\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientifically Grounded:** The problem is a classic example in concurrent data structures, illustrating a race condition due to a non-atomic read-modify-write sequence on a shared data structure. The concepts used (linked lists, pointers, atomicity, Sequential Consistency) are fundamental and correctly defined in computer science.\n-   **Well-Posed:** The problem provides a precise algorithm, a specific concurrency model (SC), and a clear objective: to identify a failure mode (violation of the `$tail$` invariant) and a deterministic schedule to trigger it. A unique, verifiable answer is possible.\n-   **Objective:** The problem is stated using precise, unambiguous technical terminology.\n\nThe problem statement is found to be **valid**. It is a well-defined problem in concurrent algorithm analysis without any scientific, logical, or structural flaws.\n\n### Derivation of the Bug Mechanism\n\nThe core of the problem lies in the non-atomic nature of the four-step sequence. Specifically, the operation is a \"read-modify-write\" pattern on the list's tail, but broken into two distinct parts: updating the link from the old tail (`$t.next \\leftarrow x$`) and updating the global `$tail$` pointer itself (`$tail \\leftarrow x$`). Under a concurrent setting, threads can interleave their operations between these steps.\n\nLet the initial list contain a single node `$a$`, such that `$head = a$` and `$tail = a$`. Let thread `$T_1$` be inserting node `$x_1$` and thread `$T_2$` be inserting node `$x_2$`. A failure that violates the `$tail = n_k$` invariant can be constructed as follows:\n\n1.  **Both threads read the old tail:**\n    -   `$T_1$` executes Step $2$: `$t_1 \\leftarrow tail$`. So `$t_1$` holds the address of `$a$`.\n    -   `$T_2$` executes Step $2$: `$t_2 \\leftarrow tail$`. So `$t_2$` also holds the address of `$a$`. At this point, both threads intend to append their new node after `$a$`.\n\n2.  **Both threads update the `next` pointer of the old tail:**\n    -   `$T_1$` executes Step $3$: `$t_1.next \\leftarrow x_1$`. This sets `$a.next \\leftarrow x_1$`. The list becomes `$a \\rightarrow x_1$`.\n    -   `$T_2$` executes Step $3$: `$t_2.next \\leftarrow x_2$`. This sets `$a.next \\leftarrow x_2$`. This write overwrites `$T_1$`'s write. The list is now `$a \\rightarrow x_2$`, and node `$x_1$` is no longer reachable from the head of the list; it has been \"lost\".\n\n3.  **Threads update the global `tail` pointer:** The order of these updates is critical. Let's assume the following interleaving:\n    -   `$T_2$` executes Step $4$: `$tail \\leftarrow x_2$`. The `$tail$` pointer now correctly points to `$x_2$`, which is the actual last node of the list `$a \\rightarrow x_2$`. At this specific moment, the invariant holds.\n    -   `$T_1$` executes its final Step $4$: `$tail \\leftarrow x_1$`. This write overwrites the `$tail$` pointer.\n\n4.  **Final State Analysis:**\n    -   The list structure, as traversed from `$head$`, is `$a \\rightarrow x_2 \\rightarrow \\varnothing$`. The last node, `$n_k$`, is `$x_2$`.\n    -   The global `$tail$` pointer stores the address of `$x_1$`.\n    -   Therefore, `$tail \\neq n_k$`, which is a violation of the representation invariant. The `$tail$` pointer now points to a node that is not part of the linked list accessible from `$head$`.\n\nThis specific interleaving demonstrates how the non-atomic update sequence leads to an inconsistent state.\n\n### Option-by-Option Analysis\n\n**A. Diagnosis: The compound tail advancement is non-atomic... Deterministic schedule: ...**\n-   **Diagnosis:** The diagnosis correctly identifies that the non-atomic sequence allows two threads to race on the predecessor's `$next$` field. It also correctly predicts that a subsequent, out-of-order update to the `$tail$` pointer can corrupt the invariant. This matches our derivation precisely.\n-   **Schedule:** The proposed schedule enforces the exact interleaving required to produce the failure:\n    1.  `$T_1$` reads `$tail = a$` and links `$a.next \\leftarrow x_1$`.\n    2.  `$T_1$` is then paused.\n    3.  `$T_2$` reads the same `$tail = a$`, overwrites the link (`$a.next \\leftarrow x_2$`), and then updates the `$tail$` pointer (`$tail \\leftarrow x_2$`). At this point, the list is consistent: `$a \\rightarrow x_2$` and `$tail = x_2$`.\n    4.  `$T_1$` is resumed and executes its final step: `$tail \\leftarrow x_1$`.\n-   **Postcondition:** The final state is `$a.next = x_2$` and `$tail = x_1$`. The list ends at `$x_2$`, but the `$tail$` pointer points to the orphaned node `$x_1$`. This violates the invariant as described.\n-   **Verdict:** This option provides a correct diagnosis and a valid, deterministic schedule that triggers the specific bug under the SC model. **Correct**.\n\n**B. Diagnosis: Instruction reordering causes `$tail \\leftarrow x$` (Step $4$) to occur before `$t.next \\leftarrow x$` (Step $3$)...**\n-   **Analysis:** The problem explicitly specifies the Sequential Consistency (SC) memory model. Under SC, while a processor might reorder its own instructions internally, these reorderings are not observable by other threads. The operations of each thread must appear to all other threads to execute in the specified program order. Therefore, having Step $4$ become globally visible before Step $3$ is a violation of the SC model. This diagnosis is applicable to weaker memory models (like relaxed or TSO), but not to SC.\n-   **Verdict:** The diagnosis is inconsistent with the specified memory model. **Incorrect**.\n\n**C. Diagnosis: The “ABA problem” on `$tail$` when using Compare-And-Swap (CAS)...**\n-   **Analysis:** The algorithm described in the problem statement uses simple atomic reads and writes (`t \\leftarrow tail`, `$t.next \\leftarrow x$`). It does not use the Compare-And-Swap (CAS) atomic primitive. The ABA problem is a well-known issue specific to CAS-based algorithms where a memory location is read (A), modified by another thread (B), then restored to the original value (A), fooling a subsequent CAS. Since the given algorithm does not use CAS, this diagnosis is irrelevant.\n-   **Verdict:** The diagnosis pertains to a mechanism not present in the problem's algorithm. **Incorrect**.\n\n**D. Diagnosis: Traversal-based tail discovery races with concurrent insertions...**\n-   **Analysis:** The insertion routine in the problem is not traversal-based. Step $2$ (`$t \\leftarrow tail$`) directly accesses the last node via the `$tail$` pointer. The algorithm does not iterate from the `$head$` to find the end of the list. Therefore, a diagnosis based on a \"traversal-based tail discovery\" race is inapplicable. The problem also states that two threads are performing tail insertion, not one inserter and one traverser.\n-   **Verdict:** The diagnosis describes a different scenario and a different algorithm than what is given in the problem. **Incorrect**.", "answer": "$$\\boxed{A}$$", "id": "3245948"}, {"introduction": "Building on our understanding of concurrency-related bugs, this final challenge asks you to design a solution using modern techniques. You will implement a lock-free insertion algorithm for a doubly linked list, a method often employed in high-performance systems to avoid the overhead of traditional locks. This practice introduces the powerful Compare-And-Swap (CAS) atomic instruction, a hardware primitive for building non-blocking algorithms [@problem_id:3229884]. Designing and simulating this algorithm will provide you with hands-on experience in defining a clear linearization point and ensuring data integrity in a lock-free context.", "problem": "You are asked to design and implement, from first principles, a lock-free insertion operation for a doubly linked list using only atomic compare-and-swap on stamped references. Begin from core definitions and properties of doubly linked lists and the semantics of Compare-And-Swap (CAS). The objective is to produce a complete, runnable program that simulates the algorithm under controlled interleavings and verifies correctness invariants.\n\nDefinitions and foundational base:\n- A doubly linked list consists of nodes, each storing a payload and two references: $prev$ and $next$. For any two adjacent nodes $x$ and $y$ in the forward direction, the invariants must hold: $x.next = y$ and $y.prev = x$.\n- The list has two sentinel nodes, a head $H$ and a tail $T$, which are not part of the user payload. The invariants at the boundaries are $H.next = n_1$ when the list is non-empty, and $T.prev = n_k$ where $n_1, \\dots, n_k$ are the payload nodes in order. When the list is empty, $H.next = T$ and $T.prev = H$.\n- Compare-And-Swap (CAS): Compare-And-Swap (CAS) is an atomic instruction that, for a memory location storing a pair $(p, v)$, compares both the pointer $p$ and a version counter $v$ to expected values $(p_e, v_e)$. If they match, CAS writes a new pointer $p_n$ and increments the version to $v_e + 1$, returning $true$; otherwise it returns $false$ and does not modify the memory location. This stamped-pointer convention prevents the \"ABA problem\" by ensuring that even if the pointer cycles back to the same address, the version counter $v$ reveals intervening changes.\n- Lock-freedom: An operation is lock-free if, under a fair scheduler where steps are interleaved arbitrarily, the system guarantees that in a finite number of steps at least one thread completes its method call. This property does not require wait-freedom (every thread completes) but forbids global blocking.\n\nTask:\n- Implement a doubly linked list with sentinel head $H$ and tail $T$, where each $prev$ and $next$ is a stamped reference $(ptr, ver)$ updated only via CAS.\n- Design the insertion operation $InsertAfter(p, x)$ that attempts to insert a new node $n$ with payload $x$ immediately after node $p$. The operation must:\n  1. Read a snapshot successor $s$ as $p.next$ and record its version.\n  2. Initialize $n.prev$ to $p$ and $n.next$ to $s$.\n  3. Attempt an atomic CAS on $p.next$ from $(s, v)$ to $(n, v + 1)$ using the recorded version $v$; upon failure, retry by reading the current $p.next$ and version again.\n  4. After successfully publishing $n$ via the CAS on $p.next$, finalize by attempting CAS on $s.prev$ from $(p, v')$ to $(n, v' + 1)$. If this CAS fails due to interference (for example, another insertion between $p$ and $s$), retry until $s.prev = n$ or until a subsequent successful CAS makes it so.\n- Concurrency is modeled via a stepwise simulation. Each insertion is represented as a sequence of small steps: reading snapshots, attempting CAS on $p.next$, and attempting CAS on $s.prev$. You must simulate interleavings where two insertions race to insert after the same $p$, demonstrating that the algorithm remains linearizable and preserves the doubly linked invariants.\n\nScientific realism and constraints:\n- Only the two stamped references $p.next$ and $s.prev$ may be modified with CAS. Ordinary writes are permitted only to fields of the new node $n$ before it becomes reachable via CAS on $p.next$, since these writes are thread-local and do not violate atomicity.\n- No locks or blocking primitives may be used.\n- The linearization point of $InsertAfter$ must be the first successful CAS on $p.next$ that publishes the new node $n$.\n\nTest suite and final output format:\n- Use an initial list with payload values $[1, 2, 3]$ and sentinels $H$ and $T$.\n- Define the following test cases, each resulting in a boolean indicating whether both the invariants and the final order match the expected outcome. Your program must output a single line containing the list of booleans, comma-separated and enclosed in square brackets.\n  1. Happy path insertion: insert value $99$ after payload node $2$. Expected final order: $[1, 2, 99, 3]$.\n  2. Boundary insertion at the head: insert value $0$ immediately after $H$. Expected final order: $[0, 1, 2, 3]$.\n  3. Concurrent insertion after the same node: two insertions race to insert values $21$ and $22$ after payload node $2$. Use the interleaving schedule that models the following steps: thread $t_1$ reads successor $s$ and successfully CAS-es $p.next$ to its node, thread $t_2$ reads $s$ and fails its CAS on $p.next$, then re-reads the updated successor and successfully CAS-es $p.next$ to its own node, finalizing both insertions by CAS-ing the appropriate $prev$ fields. The expected final order under this schedule is $[1, 2, 22, 21, 3]$.\n  4. Version-mismatch edge case: insert value $-1$ after $H$, but artificially bump the version counter on $H.next$ between the read and CAS (using a CAS to the same pointer that only increments the version), forcing a CAS failure and retry. Expected final order: $[-1, 1, 2, 3]$.\n- The final program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[true,false,true,true]$ where Python booleans are printed as $True$ or $False$).\n- Answers have no physical units, and no angles are involved. All outputs are booleans. The algorithm and simulation must be universal and purely logical, assuming a modern programming language implementing the described CAS semantics on stamped references.\n\nYour deliverable must be a single, complete, runnable program that constructs the initial list, executes the defined test suite with the specified schedules, checks the invariants and final orders, and prints the final boolean results in the specified single-line format.", "solution": "The user has requested the design and implementation of a lock-free insertion operation for a doubly linked list using atomic compare-and-swap (CAS) on stamped references. The problem statement is a valid, well-posed computer science problem grounded in the principles of concurrent data structures. It requires demonstrating the algorithm's correctness through a series of controlled simulations.\n\n**1. Foundational Principles and Data Structures**\n\nFirst, we define the necessary data structures and the atomic primitive, CAS, as specified.\n\n- **`Node`**: A node in the list contains a payload (`value`) and two references, `next` and `prev`.\n- **`StampedRef`**: Each reference, `next` and `prev`, is a stamped reference, which we model as a mutable list `[pointer, version]`. The `pointer` refers to another `Node` object, and the `version` is an integer counter. The version is crucial for preventing the ABA problem, where a pointer is read, modified by other threads, and then restored to its original value, misleading a CAS operation that only checks the pointer. The version stamp ensures such intervening modifications are detected.\n- **`cas(target, expected_ptr, expected_ver, new_ptr)`**: This function simulates the atomic CAS operation. It checks if the `target` reference (e.g., `a_node.next`) currently holds the `expected_ptr` and `expected_ver`. If and only if both match, it updates the `target`'s pointer to `new_ptr` and increments the version. This entire operation is atomic.\n- **`DoublyLinkedList`**: This class encapsulates the list, maintaining `head` and `tail` sentinel nodes. It provides helper methods to initialize the list (`populate`), find nodes (`find_node`), verify structural integrity (`verify_invariants`), and represent the list's contents for validation (`to_list`). The `verify_invariants` method is critical; it iterates through the list to confirm that for every node $n$, the core invariants $n.next.prev = n$ and $n.prev.next = n$ hold true.\n\n**2. Lock-Free Insertion Algorithm: `InsertAfter(p, x)`**\n\nThe insertion of a new node $n$ with value $x$ after a node $p$ proceeds in two main phases. The linearization point of the operation is the successful completion of the first phase.\n\n- **Phase 1: Forward Link Insertion (Linearization)**\n  The core of the insertion is a retry loop that attempts to atomically insert the new node $n$ into the `next` pointer chain.\n  1.  **Snapshot**: Read the current successor of $p$, let's call it $s$, and its version $v_s$. So, we have a snapshot $(s, v_s) = p.next$.\n  2.  **Initialization**: Create the new node $n$. Its `next` pointer is set to $s$, and its `prev` pointer is tentatively set to $p$. These are local writes and are not visible to other threads until $n$ is published.\n  3.  **Atomic Update**: Attempt to change $p.next$ from its expected value $(s, v_s)$ to the new value $(n, v_s+1)$ using CAS.\n      - **Success**: If the CAS succeeds, node $n$ is now part of the list, logically positioned between $p$ and $s$. This successful CAS is the **linearization point**; the insertion is now considered to have taken effect. The algorithm can proceed to Phase 2.\n      - **Failure**: If the CAS fails, it means another thread modified $p.next$ between our read (Step 1) and our CAS attempt (Step 3). The loop restarts from Step 1 to get the new state of $p.next$ and retry. This retry mechanism ensures progress and is fundamental to the lock-free property.\n\n- **Phase 2: Backward Link Finalization (Fix-up)**\n  After the forward link is established, the backward link from the original successor $s$ must be updated. Initially, $s.prev$ points to $p$. It must be changed to point to our newly inserted node $n$.\n  1.  **Attempted Correction**: The inserting thread attempts to atomically change $s.prev$ from $(p, v_p)$ to $(n, v_p+1)$ using CAS, where $v_p$ is the version of the $s.prev$ reference at the time of the attempt.\n  2.  **Interference**: This second CAS is not guaranteed to succeed. Another thread might have inserted a node between $n$ and $s$, or another thread might have already \"helped\" and fixed the pointer. The problem description simplifies this by requiring only a single attempt for the simulation. In a fully robust implementation, any thread traversing the list could detect and correct inconsistent `prev` pointers, ensuring eventual consistency. For our purposes, the finalization step is a \"best-effort\" attempt that is sufficient for the controlled test cases.\n\n**3. Simulation and Verification**\n\nTo validate the algorithm, we execute a suite of tests that simulate specific, controlled interleavings of operations, as required by the problem. Each test case configures an initial list, executes a sequence of atomic steps representing one or more concurrent threads, and then verifies two conditions:\n1.  The final list order matches the expected outcome for that test's schedule.\n2.  The list's structural invariants (`verify_invariants`) are preserved.\n\nThe test cases cover a standard insertion, a boundary case (inserting after the head), a race condition between two threads inserting after the same node, and an edge case where a CAS fails due to a version change even though the pointer remains the same (demonstrating protection against the ABA problem). A test is successful only if both the final order and the invariants are correct. The program aggregates the boolean result of each test and prints them in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the lock-free doubly linked list insertion problem by simulating\n    the algorithm under various test scenarios and verifying correctness.\n    \"\"\"\n\n    # Definition for a stamped reference Compare-And-Swap.\n    # target_ref is a list [pointer, version]\n    def cas(target_ref, expected_ptr, expected_ver, new_ptr):\n        \"\"\"\n        Simulates an atomic compare-and-swap operation on a stamped reference.\n        A stamped reference is represented as a mutable list [pointer, version].\n        \"\"\"\n        current_ptr, current_ver = target_ref\n        if current_ptr is expected_ptr and current_ver == expected_ver:\n            target_ref[0] = new_ptr\n            target_ref[1] += 1\n            return True\n        return False\n\n    # Node in the doubly linked list.\n    class Node:\n        def __init__(self, value):\n            self.value = value\n            self.next = [None, 0]  # Stamped reference: [pointer, version]\n            self.prev = [None, 0]  # Stamped reference: [pointer, version]\n        \n        def __repr__(self):\n            return f\"Node({self.value})\"\n\n    # Doubly Linked List implementation.\n    class DoublyLinkedList:\n        def __init__(self):\n            self.head = Node(\"HEAD\")\n            self.tail = Node(\"TAIL\")\n            self.head.next = [self.tail, 0]\n            self.tail.prev = [self.head, 0]\n\n        def populate(self, values):\n            \"\"\"Populates the list with an initial set of values.\"\"\"\n            curr = self.head\n            for val in values:\n                new_node = Node(val)\n                new_node.next[0] = self.tail\n                new_node.prev[0] = curr\n                curr.next[0] = new_node\n                self.tail.prev[0] = new_node\n                curr = new_node\n            \n            # Reset versions to 0 for a clean state before each test\n            node = self.head\n            while node is not None:\n                node.next[1] = 0\n                node.prev[1] = 0\n                if node.next[0] is None: break\n                node = node.next[0]\n\n\n        def find_node(self, value):\n            \"\"\"Finds the first node with the given value.\"\"\"\n            curr = self.head.next[0]\n            while curr is not self.tail:\n                if curr.value == value:\n                    return curr\n                curr = curr.next[0]\n            return None\n\n        def to_list(self):\n            \"\"\"Returns the list contents as a standard Python list of values.\"\"\"\n            res = []\n            curr = self.head.next[0]\n            while curr is not self.tail:\n                res.append(curr.value)\n                curr = curr.next[0]\n            return res\n\n        def verify_invariants(self):\n            \"\"\"\n            Verifies the doubly-linked list invariants for all nodes.\n            \"\"\"\n            # Check boundary invariants\n            if self.head.next[0].prev[0] is not self.head: return False\n            if self.tail.prev[0].next[0] is not self.tail: return False\n            \n            # Check internal node invariants\n            curr = self.head.next[0]\n            while curr is not self.tail:\n                if curr.next[0].prev[0] is not curr: return False\n                if curr.prev[0].next[0] is not curr: return False\n                curr = curr.next[0]\n\n            return True\n\n    test_results = []\n\n    # Test Case 1: Happy path insertion\n    def test_case_1():\n        dll = DoublyLinkedList()\n        dll.populate([1, 2, 3])\n        p = dll.find_node(2)\n        n = Node(99)\n\n        # Core insertion logic: read, CAS p.next, then CAS s.prev\n        s, s_ver = p.next\n        n.next[0], n.prev[0] = s, p\n        \n        cas_p_next_ok = cas(p.next, s, s_ver, n)\n        if cas_p_next_ok:\n            s_prev_ptr, s_prev_ver = s.prev\n            if s_prev_ptr == p:\n                cas(s.prev, p, s_prev_ver, n)\n\n        final_order = dll.to_list()\n        invariants_hold = dll.verify_invariants()\n        expected_order = [1, 2, 99, 3]\n        return invariants_hold and final_order == expected_order\n\n    test_results.append(test_case_1())\n\n    # Test Case 2: Boundary insertion at the head\n    def test_case_2():\n        dll = DoublyLinkedList()\n        dll.populate([1, 2, 3])\n        p = dll.head\n        n = Node(0)\n\n        s, s_ver = p.next\n        n.next[0], n.prev[0] = s, p\n\n        cas_p_next_ok = cas(p.next, s, s_ver, n)\n        if cas_p_next_ok:\n            s_prev_ptr, s_prev_ver = s.prev\n            if s_prev_ptr == p:\n                cas(s.prev, p, s_prev_ver, n)\n\n        final_order = dll.to_list()\n        invariants_hold = dll.verify_invariants()\n        expected_order = [0, 1, 2, 3]\n        return invariants_hold and final_order == expected_order\n        \n    test_results.append(test_case_2())\n\n    # Test Case 3: Concurrent insertion after the same node\n    def test_case_3():\n        dll = DoublyLinkedList()\n        dll.populate([1, 2, 3])\n        p = dll.find_node(2)\n        n1 = Node(21)\n        n2 = Node(22)\n        \n        # Simulate specified interleaving\n        # t1 reads successor s (node 3)\n        s1, s1_ver = p.next\n        n1.next[0], n1.prev[0] = s1, p\n        \n        # t2 also reads successor s (node 3) before t1's CAS\n        s2, s2_ver = p.next\n        n2.next[0], n2.prev[0] = s2, p\n\n        # t1 successfully CAS-es p.next, publishing n1\n        cas(p.next, s1, s1_ver, n1)\n\n        # t2 fails its CAS on p.next because p.next changed\n        cas(p.next, s2, s2_ver, n2)\n\n        # t2 re-reads the updated successor (now n1) and retries\n        s2_new, s2_new_ver = p.next\n        n2.next[0] = s2_new\n        cas(p.next, s2_new, s2_new_ver, n2)\n        \n        # Finalization steps for both threads\n        # t1 finalizes its original successor s1 (node 3)\n        s1_prev_ptr, s1_prev_ver = s1.prev\n        cas(s1.prev, p, s1_prev_ver, n1)\n        \n        # t2 finalizes its successor (which is now n1)\n        n1_prev_ptr, n1_prev_ver = n1.prev\n        cas(n1.prev, p, n1_prev_ver, n2)\n\n        final_order = dll.to_list()\n        invariants_hold = dll.verify_invariants()\n        expected_order = [1, 2, 22, 21, 3]\n        return invariants_hold and final_order == expected_order\n\n    test_results.append(test_case_3())\n\n    # Test Case 4: Version-mismatch edge case\n    def test_case_4():\n        dll = DoublyLinkedList()\n        dll.populate([1, 2, 3])\n        p = dll.head\n        n = Node(-1)\n\n        # Step 1: Thread reads snapshot of p.next\n        s, s_ver = p.next\n        \n        # Artificially bump version counter without changing pointer\n        cas(p.next, s, s_ver, s)\n        \n        # Step 2: Thread attempts CAS with its stale version, which must fail\n        n.next[0], n.prev[0] = s, p\n        cas_failed = not cas(p.next, s, s_ver, n)\n        \n        # Step 3: Thread retries with a fresh read, which must succeed\n        s_new, s_new_ver = p.next\n        n.next[0] = s_new\n        cas_succeeded = cas(p.next, s_new, s_new_ver, n)\n\n        # Finalization of original successor's prev pointer\n        if cas_succeeded:\n            s_prev_ptr, s_prev_ver = s.prev\n            cas(s.prev, p, s_prev_ver, n)\n\n        final_order = dll.to_list()\n        invariants_hold = dll.verify_invariants()\n        expected_order = [-1, 1, 2, 3]\n        \n        return cas_failed and cas_succeeded and invariants_hold and final_order == expected_order\n\n    test_results.append(test_case_4())\n    \n    print(f\"[{','.join(map(str, test_results))}]\")\n\nsolve()\n```", "id": "3229884"}]}