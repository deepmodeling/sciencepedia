{"hands_on_practices": [{"introduction": "Mastering linked lists begins with confident pointer traversal. This first exercise moves beyond simple iteration to teach the crucial technique of \"looking ahead\" in the list structure. By learning to inspect the node that follows the next one, you develop the fundamental skill needed to identify specific positions relative to the end of the list, a cornerstone of many list algorithms [@problem_id:3255694].", "problem": "You are given the definition of a singly linked list: each node consists of a value and a pointer to the next node. Formally, a node stores an integer value and a reference to the next node; the last node’s next reference is $\\varnothing$. The head of the list is a reference to the first node, denoted by $head$. All node values in this task are guaranteed to be non-negative integers, and no node value will be equal to the sentinel $-1$.\n\nDesign and implement a single-pass algorithm that, given $head$, returns the value stored in the second-to-last node of the list if it exists; otherwise, return the sentinel $-1$. The algorithm must use at most $O(1)$ additional space, may not modify the list, and may traverse the list at most once. You may assume a standard computational model where reading a node’s value and following a next pointer each take $O(1)$ time.\n\nDerive the algorithm from first principles using the core definitions:\n- A singly linked list is a sequence of nodes connected by directed edges, each node having exactly one outgoing pointer to its successor except the last, whose successor is $\\varnothing$.\n- A single traversal means visiting nodes by following the successor pointers monotonically from $head$ until termination, without restarting or rewinding.\n\nYour program must hard-code and process the following test suite of input lists, in this exact order:\n- Input list: $\\varnothing$ (the empty list).\n- Input list: $[42]$.\n- Input list: $[1,2]$.\n- Input list: $[3,5,8]$.\n- Input list: $[9,9,9,9]$.\n- Input list: $[0,1,2,3,4,5]$.\n- Input list: $[100,200,300,400,500,600,700,800,900]$.\n\nFor each input list, compute a single integer result: the value of the second-to-last node, or $-1$ if no such node exists. The final output format must aggregate the results for all test cases into a single line printed to standard output as a comma-separated list enclosed in square brackets, with no spaces, in the exact form\n$[r_1,r_2,\\dots,r_7]$\nwhere $r_i$ is the integer result for test case $i$.", "solution": "The problem of finding the second-to-last node in a singly linked list under the constraints of a single pass and constant extra space is a fundamental exercise in pointer manipulation and algorithmic thinking. We shall derive the solution from first principles.\n\nLet a singly linked list be represented by a sequence of nodes $N_1, N_2, \\dots, N_n$, where $n \\geq 0$ is the number of nodes in the list. The head of the list, $head$, is a reference to the first node, $N_1$. If the list is empty ($n=0$), then $head = \\varnothing$. Each node $N_i$ for $1 \\leq i < n$ contains a reference, $N_i.\\text{next}$, to its successor node $N_{i+1}$. The last node, $N_n$, is defined by the property $N_n.\\text{next} = \\varnothing$.\n\nThe task is to find the value of the second-to-last node, $N_{n-1}$. This node is defined only if the list contains at least two nodes, i.e., $n \\geq 2$.\n\nLet us analyze the conditions under which a second-to-last node does not exist:\n1.  **Empty List**: If $n=0$, the list is empty ($head = \\varnothing$). There are no nodes, and thus no second-to-last node.\n2.  **Single-Node List**: If $n=1$, the list contains only one node, $N_1$. This node is the last node, as $N_1.\\text{next} = \\varnothing$. There is no second-to-last node.\n\nCombining these two cases, if the list has fewer than two nodes ($n < 2$), the required node does not exist. This can be checked by examining the head pointer. If $head = \\varnothing$ or $head.\\text{next} = \\varnothing$, the list has $0$ or $1$ nodes, respectively. In these cases, the algorithm must return the specified sentinel value, $-1$.\n\nNow, consider the case where $n \\geq 2$. A second-to-last node is guaranteed to exist. Let this node be denoted by $p$. By definition, $p$ is the node that immediately precedes the last node. The last node, $q$, is characterized by $q.\\text{next} = \\varnothing$. Therefore, the second-to-last node $p$ is characterized by the condition $p.\\text{next} = q$ and $q.\\text{next} = \\varnothing$. Substituting $q$ gives the defining property of the second-to-last node $p$:\n$$\np.\\text{next}.\\text{next} = \\varnothing\n$$\nThe problem is now reduced to finding the node $p$ that satisfies this condition. The constraints demand a single traversal and $O(1)$ additional space. This means we must locate $p$ by advancing one or more pointers monotonically from $head$ to the end of the list, using only a constant number of auxiliary pointers.\n\nA straightforward algorithm can be constructed based on this property.\n1.  First, handle the base cases. If $head$ is $\\varnothing$ or $head.\\text{next}$ is $\\varnothing$, return $-1$.\n2.  If the list has at least two nodes, we can start a traversal from the head. Let's use a single pointer, which we will name `current`, initialized to `head`.\n    $$\n    \\text{current} \\leftarrow head\n    $$\n3.  We need to advance `current` until it points to the node $p$ satisfying $p.\\text{next}.\\text{next} = \\varnothing$. This means we should continue advancing `current` as long as `current.next.next` is *not* $\\varnothing$.\n4.  The traversal loop can be formulated as:\n    $$\n    \\text{while } \\text{current.next.next} \\neq \\varnothing \\text{ do} \\\\\n    \\quad \\text{current} \\leftarrow \\text{current.next} \\\\\n    \\text{end while}\n    $$\n5.  Let us trace this logic. The loop terminates when `current.next.next` is $\\varnothing$. At this point, `current.next` is the last node, which means `current` must be the second-to-last node. The initial check for $n < 2$ ensures that the expression `current.next.next` is safe to evaluate within the loop's condition, as we are guaranteed that both `current` and `current.next` are non-$\\varnothing$ upon entering the loop for the first time. For a list with exactly two nodes, $N_1$ and $N_2$, `head.next.next` is $\\varnothing$, so the loop condition is immediately false, `current` remains at `head`, and the algorithm correctly identifies $N_1$ as the second-to-last node.\n6.  Once the loop terminates, the pointer `current` references the second-to-last node. The required output is the value stored in this node, `current.value`.\n\nThis algorithm adheres to all constraints:\n-   **Single Pass**: The `current` pointer moves strictly forward.\n-   **$O(1)$ Space**: It uses one auxiliary pointer, `current`.\n-   **No Modification**: The list structure is only read, not altered.\n-   **Single Traversal**: The list is traversed once.\n\nApplying the logic to the given test cases:\n-   Input: $\\varnothing$. $head = \\varnothing$. Condition `head == null` is true. Return $-1$.\n-   Input: $[42]$. $head \\neq \\varnothing$, but $head.\\text{next} = \\varnothing$. Condition `head.next == null` is true. Return $-1$.\n-   Input: $[1,2]$. $head$ and $head.\\text{next}$ are not $\\varnothing$. Initialize `current` to node $1$. The loop condition `current.next.next != null` is false since `node(1).next.next` is $\\varnothing$. The loop is skipped. Return `current.value`, which is $1$.\n-   Input: $[3,5,8]$. Initialize `current` to node $3$. Loop condition `current.next.next != null` (i.e., `node(3).next.next` which is `node(8)`) is true. `current` advances to node $5$. Now, `current.next.next` is $\\varnothing$. The loop terminates. Return `current.value`, which is $5$.\n-   Input: $[9,9,9,9]$. `current` starts at node $9_1$. It advances to $9_2$, then to $9_3$. At $9_3$, `current.next.next` is $\\varnothing$. Loop terminates. Return `current.value`, which is $9$.\n-   Input: $[0,1,2,3,4,5]$. `current` advances four times, ending at node $4$. Return $4$.\n-   Input: $[100, ..., 900]$. `current` advances seven times, ending at node $800$. Return $800$.\n\nThe expected sequence of results is $[-1, -1, 1, 5, 9, 4, 800]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Definition for singly-linked list node.\nclass Node:\n    def __init__(self, val=0, next_node=None):\n        \"\"\"\n        Initializes a node for a singly linked list.\n\n        Args:\n            val (int): The integer value stored in the node.\n            next_node (Node, optional): A reference to the next node in the list. Defaults to None.\n        \"\"\"\n        self.value = val\n        self.next = next_node\n\ndef build_linked_list(values):\n    \"\"\"\n    Builds a singly linked list from a list of values.\n\n    Args:\n        values (list[int]): A list of integer values for the nodes.\n\n    Returns:\n        Node: The head of the newly created linked list, or None if the input list is empty.\n    \"\"\"\n    if not values:\n        return None\n    \n    head = Node(values[0])\n    current = head\n    for val in values[1:]:\n        current.next = Node(val)\n        current = current.next\n    return head\n\ndef find_second_to_last_value(head):\n    \"\"\"\n    Finds the value of the second-to-last node in a singly linked list.\n\n    The algorithm is single-pass, uses O(1) additional space, and does not modify the list.\n\n    Args:\n        head (Node): The head of the singly linked list.\n\n    Returns:\n        int: The value of the second-to-last node, or -1 if the list has fewer than 2 nodes.\n    \"\"\"\n    sentinel = -1\n\n    # According to the problem definition, a second-to-last node exists only if the list\n    # contains at least two nodes.\n    # Case 1: The list is empty (head is None).\n    # Case 2: The list has only one node (head.next is None).\n    if not head or not head.next:\n        return sentinel\n\n    # If the list has at least two nodes, we can safely start traversal.\n    # Let 'current' be a pointer that we will advance through the list.\n    # We want to stop when 'current' points to the second-to-last node.\n    # A node 'p' is the second-to-last node if its successor, 'p.next', is the last node.\n    # The last node 'q' is defined by q.next == None.\n    # Therefore, the second-to-last node 'p' satisfies the condition p.next.next == None.\n    current = head\n    \n    # We advance 'current' as long as its successor has a successor.\n    # This loop terminates when current.next.next is None, which means\n    # current.next is the last node, and thus 'current' is the second-to-last node.\n    while current.next.next:\n        current = current.next\n        \n    # At this point, 'current' is the second-to-last node.\n    return current.value\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the algorithm on each case, and prints the results.\n    \"\"\"\n    # The problem statement defines the test suite of input lists.\n    test_cases = [\n        [],                            # Case 1: Empty list\n        [42],                          # Case 2: Single node\n        [1, 2],                        # Case 3: Two nodes\n        [3, 5, 8],                     # Case 4: Three nodes\n        [9, 9, 9, 9],                  # Case 5: Four nodes\n        [0, 1, 2, 3, 4, 5],            # Case 6: Six nodes\n        [100, 200, 300, 400, 500, 600, 700, 800, 900] # Case 7: Nine nodes\n    ]\n\n    results = []\n    for case_values in test_cases:\n        # Construct the linked list from the list of values.\n        head_node = build_linked_list(case_values)\n        \n        # Calculate the result for the current test case.\n        result = find_second_to_last_value(head_node)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3255694"}, {"introduction": "This next practice introduces a powerful and elegant two-pointer technique to solve problems involving two separate lists. The challenge is to find where two paths merge without knowing their lengths ahead of time, all while using constant extra memory. The solution to this problem is a classic algorithm that demonstrates how to synchronize pointers in a clever way, a pattern that proves invaluable in many different contexts [@problem_id:3255668].", "problem": "You are given two singly linked lists, each formed from nodes where each node contains a value and a pointer to the next node. A singly linked list is defined by a head node, and each node has a field pointing to the next node or to a null sentinel. Two lists are said to intersect if, from some node onward, they share the exact same node instances by identity (not just equal values) along the remainder of their tails. The merging node is defined as the first node that is common to both lists by identity. The fundamental base for this problem is the definition of a singly linked list node with a next pointer, the property that list traversal by following next pointers visits nodes in order, and the identity-based notion of intersection that implies a shared suffix from the merging node onward.\n\nDesign and implement a program that, for each provided test case, returns the value of the merging node as an integer if it exists, and returns the integer $-1$ if there is no intersection. The algorithm must not use any external storage proportional to the lengths of the lists; it must use $O(1)$ additional space, must not modify the input lists, and should be able to operate without knowing the lengths of the lists in advance. Express any time complexity discussion in terms of the number of nodes $n$ and $m$ in the two lists.\n\nThe program must implement the reasoning from the definitions of singly linked lists and intersection by identity, and from these derive an algorithm that correctly finds the merging node under the stated constraints.\n\nTest Suite:\nConstruct the following four test cases inside your program. In each case, explicitly build the lists such that intersections (or lack thereof) occur by node identity, not merely by equal values.\n\n$1$. Happy path with unequal lengths and intersection in the interior:\n- List $A$ consists of nodes with values $[3,7]$ followed by a shared suffix $[8,10]$.\n- List $B$ consists of nodes with values $[99,1]$ followed by the same shared suffix $[8,10]$ as list $A$.\n\n$2$. Boundary case with intersection at the head:\n- List $A$ and list $B$ are the exact same list from the head node onward with values $[1,2,3]$.\n\n$3$. Edge case with intersection only at the last node:\n- List $A$ has values $[5,6]$ followed by a shared tail node with value $[7]$.\n- List $B$ has values $[9]$ followed by the same shared tail node with value $[7]$.\n\n$4$. Edge case with no intersection:\n- List $A$ has values $[1,2,3]$.\n- List $B$ has values $[4,5,6]$.\n- There must be no shared node instances between these lists.\n\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets, for example $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$, where each $\\text{result}_i$ is the integer value of the merging node for test case $i$, or $-1$ if there is no intersection. The output must be exactly one line, with no additional text.\n\nNo physical units or angles are involved, and no percentages are required. Any complexity claims must be expressed using the Big $O$ notation $O(\\cdot)$ and must refer to $n$ and $m$ as the lengths of the two lists.", "solution": "The problem statement has been validated and is deemed sound. It is a well-posed problem in the domain of data structures and algorithms, grounded in formal definitions of singly linked lists and node identity. The constraints are self-consistent and require a specific class of algorithmic solution.\n\nThe problem asks for an algorithm to find the first common node, by identity, of two singly linked lists. This common node is the start of a shared suffix. The key constraints are that the algorithm must operate in $O(1)$ auxiliary space and must not modify the lists. The lengths of the lists, denoted as $n$ and $m$, are not known in advance.\n\nA naive approach would be to iterate through every node in the first list, and for each of these nodes, iterate through every node in the second list, checking for identity equality (e.g., `nodeA is nodeB` in Python). This approach would have a time complexity of $O(n \\cdot m)$, which is inefficient for large lists, though it would satisfy the $O(1)$ space constraint.\n\nA more efficient method would involve storing the node identities of the first list in a hash set and then iterating through the second list to check for membership. The first node from the second list found in the hash set would be the intersection point. This has a time complexity of $O(n+m)$ but requires $O(n)$ or $O(m)$ space for the hash set, violating the space constraint.\n\nThe required solution must reconcile the need for linear time complexity with the constraint of constant space. This can be achieved with a two-pointer technique that elegantly circumvents the need for explicit length calculation.\n\nLet the two lists be $A$ and $B$. Let the two pointers be $p_A$ and $p_B$, initialized to the heads of lists $A$ and $B$, respectively. The algorithm proceeds by advancing both pointers one step at a time through their respective lists. The crucial insight lies in how to handle the case when a pointer reaches the end of its list (a `null` pointer). When a pointer, say $p_A$, reaches the end of list $A$, it is redirected to the head of list $B$. Similarly, when $p_B$ reaches the end of list $B$, it is redirected to the head of list $A$.\n\nLet us analyze why this guarantees a meeting at the intersection node, if one exists.\nAssume list $A$ has a non-shared prefix of length $L_A$ and list $B$ has a non-shared prefix of length $L_B$. Let the shared suffix have length $C$. The total length of list $A$ is $n = L_A + C$, and the total length of list $B$ is $m = L_B + C$.\n\nPointer $p_A$ will traverse the path of list $A$ (length $n = L_A + C$) and then be redirected to the head of list $B$. To reach the intersection node from the head of list $B$, it must travel an additional distance of $L_B$. The total distance traveled by $p_A$ to reach the intersection node is $(L_A + C) + L_B$.\n\nPointer $p_B$ will traverse the path of list $B$ (length $m = L_B + C$) and then be redirected to the head of list $A$. To reach the intersection node from the head of list $A$, it must travel an additional distance of $L_A$. The total distance traveled by $p_B$ to reach the intersection node is $(L_B + C) + L_A$.\n\nSince $(L_A + C) + L_B = (L_B + C) + L_A$, the total path lengths traveled by both pointers to reach the intersection node are identical. Because they move at the same speed (one node per step), they are guaranteed to arrive at the intersection node in the same number of steps. The first time their identity is the same ($p_A$ is $p_B$), they must be at the merging node.\n\nNow, consider the case where the lists do not intersect. In this scenario, the common part length $C=0$. The length of list $A$ is $n=L_A$ and the length of list $B$ is $m=L_B$.\nPointer $p_A$ will travel its entire list (length $n$) and then be redirected to traverse all of list $B$ (length $m$). Its total journey covers $n+m$ nodes before it becomes `null`.\nPointer $p_B$ will travel its entire list (length $m$) and then be redirected to traverse all of list $A$ (length $n$). Its total journey also covers $m+n$ nodes before it becomes `null`.\nBoth pointers will simultaneously become `null` after traversing a total of $n+m$ nodes. The loop condition `while p_A is not p_B` will terminate because `null` is identical to `null`. In this case, the final pointer value is `null`, indicating no intersection was found, and the function should return $-1$.\n\nThe algorithm is therefore as follows:\n$1$. Initialize two pointers, $p_A$ to `headA` and $p_B$ to `headB`.\n$2$. Loop as long as $p_A$ is not identical to $p_B$.\n$3$. Inside the loop, advance $p_A$ to its next node. If $p_A$ becomes `null`, reset it to `headB`.\n$4. $ Inside the loop, advance $p_B$ to its next node. If $p_B$ becomes `null`, reset it to `headA`.\n$5$. When the loop terminates, the pointers are equal. If this pointer is not `null`, its value is the result. If it is `null`, there is no intersection, and the result is $-1$.\n\nThis algorithm has a time complexity of $O(n+m)$ because, in the worst case, each pointer traverses at most the sum of the lengths of the two lists. The space complexity is $O(1)$, as it only uses two additional pointers, regardless of the list sizes. This fulfills all problem constraints.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    A node in a singly linked list.\n    Each node contains a value and a pointer to the next node.\n    \"\"\"\n    def __init__(self, val, next_node=None):\n        self.val = val\n        self.next = next_node\n\ndef find_intersection_value(headA: 'Node', headB: 'Node') -> int:\n    \"\"\"\n    Finds the intersection node of two singly linked lists and returns its value.\n\n    This implementation uses the two-pointer technique with constant space complexity O(1)\n    and linear time complexity O(n+m), where n and m are the lengths of the two lists.\n    It does not require prior knowledge of the list lengths.\n\n    Args:\n        headA: The head node of the first linked list.\n        headB: The head node of the second linked list.\n\n    Returns:\n        The integer value of the merging node if an intersection exists.\n        Returns -1 if there is no intersection.\n    \"\"\"\n    if not headA or not headB:\n        return -1\n\n    pA = headA\n    pB = headB\n\n    # Loop until the pointers meet.\n    # If the lists intersect, they will meet at the intersection node.\n    # If they don't intersect, they will both become None after traversing\n    # a total of (lengthA + lengthB) nodes, and the loop will terminate\n    # because (None is None) is True.\n    while pA is not pB:\n        # If pointer pA reaches the end of its list, switch it to the head of the other list.\n        pA = pA.next if pA is not None else headB\n        # If pointer pB reaches the end of its list, switch it to the head of the other list.\n        pB = pB.next if pB is not None else headA\n    \n    # If the loop terminated because pA and pB are both None, there is no intersection.\n    # Otherwise, they point to the intersection node.\n    return pA.val if pA is not None else -1\n\ndef solve():\n    \"\"\"\n    Constructs the test cases as described in the problem and finds the intersection\n    for each case, printing the results in the specified format.\n    \"\"\"\n    test_cases = []\n\n    # Test Case 1: Happy path with unequal lengths and intersection in the interior\n    # List A: [3, 7] -> [8, 10]\n    # List B: [99, 1] -> [8, 10]\n    shared_suffix_1 = Node(8, Node(10))\n    headA1 = Node(3, Node(7, shared_suffix_1))\n    headB1 = Node(99, Node(1, shared_suffix_1))\n    test_cases.append((headA1, headB1))\n\n    # Test Case 2: Boundary case with intersection at the head\n    # List A: [1, 2, 3]\n    # List B: [1, 2, 3] (same list instance)\n    headA2 = Node(1, Node(2, Node(3)))\n    headB2 = headA2\n    test_cases.append((headA2, headB2))\n\n    # Test Case 3: Edge case with intersection only at the last node\n    # List A: [5, 6] -> [7]\n    # List B: [9] -> [7]\n    shared_tail_3 = Node(7)\n    headA3 = Node(5, Node(6, shared_tail_3))\n    headB3 = Node(9, shared_tail_3)\n    test_cases.append((headA3, headB3))\n\n    # Test Case 4: Edge case with no intersection\n    # List A: [1, 2, 3]\n    # List B: [4, 5, 6]\n    headA4 = Node(1, Node(2, Node(3)))\n    headB4 = Node(4, Node(5, Node(6)))\n    test_cases.append((headA4, headB4))\n\n    results = []\n    for headA, headB in test_cases:\n        result = find_intersection_value(headA, headB)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3255668"}, {"introduction": "Our final exercise is a comprehensive challenge that synthesizes several advanced pointer manipulation skills into a single, efficient algorithm. To solve it, you must find the list's midpoint, reverse half of the list in-place, and then carefully compare the two halves—all without using extra space. This practice is an excellent test of your ability to perform complex structural modifications and then restore the list to its original state, demonstrating a deep mastery of node-based data structures [@problem_id:3255584].", "problem": "Consider a singly linked structure where each node contains an integer value and a pointer to the next node. A singly linked list is defined by a head node and a sequence of nodes where each node has a field that stores the value and a field that references the next node; the final node references no further node. A finite sequence is called a palindrome if it reads the same forward and backward. Formally, a sequence of length $n$ with elements $a_0, a_1, \\ldots, a_{n-1}$ is a palindrome if and only if for all indices $i$ such that $0 \\leq i < n$, it holds that $a_i = a_{n-1-i}$. Your task is to implement a program that constructs linked lists for a given test suite and, for each list, decides whether it is a palindrome using a method derived from core definitions of singly linked lists and the palindrome property. The method must operate in linear asymptotic time, that is, $\\mathcal{O}(n)$, and constant auxiliary space, that is, $\\mathcal{O}(1)$, where $n$ is the number of nodes in the list. The program must not assume prior knowledge of list length and must rely only on local node references. After performing any in-place transformations to check the palindrome property, the program must restore the linked list to its original structure to maintain structural integrity for potential subsequent operations. For the purposes of this problem, an empty sequence is considered a palindrome. There are no physical units or angle units involved. The test suite you must implement consists of the following linked lists, given as sequences of node values: case $1$: $\\langle \\rangle$, case $2$: $\\langle 7 \\rangle$, case $3$: $\\langle 1, 2, 2, 1 \\rangle$, case $4$: $\\langle 1, 2, 3, 2, 1 \\rangle$, case $5$: $\\langle 1, 2 \\rangle$, case $6$: $\\langle 10, -1, -1, 10 \\rangle$, case $7$: $\\langle 3, 4, 5, 4, 6 \\rangle$, case $8$: $\\langle 1, 0, 0, 1 \\rangle$, case $9$: $\\langle 9, 9, 9, 9 \\rangle$, case $10$: $\\langle 2147483647, -2147483648, -2147483648, 2147483647 \\rangle$. Your program should process these $10$ cases in order and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[True, False, ...]$, where each entry is $\\text{True}$ if the corresponding list is a palindrome and $\\text{False}$ otherwise.", "solution": "The problem requires determining if a singly linked list represents a palindrome. A sequence $a_0, a_1, \\ldots, a_{n-1}$ of length $n$ is a palindrome if $a_i = a_{n-1-i}$ for all valid indices $i$. The solution must adhere to strict performance constraints: linear time complexity, $\\mathcal{O}(n)$, and constant auxiliary space complexity, $\\mathcal{O}(1)$, where $n$ is the number of nodes in the list. Furthermore, the original structure of the list must be restored after the check.\n\nA naive approach, such as copying the list values into an array and using two pointers to check for palindromic symmetry, would violate the $\\mathcal{O}(1)$ space constraint, as the array would require $\\mathcal{O}(n)$ space. Similarly, a recursive solution would use the call stack, which also constitutes $\\mathcal{O}(n)$ auxiliary space in the worst case.\n\nThe specified constraints necessitate an in-place algorithm that manipulates the list's pointers. A well-established method that satisfies these requirements involves a four-step process: finding the midpoint of the list, reversing the second half, comparing the first and reversed second halves, and finally, restoring the original list structure.\n\n**Step 1: Finding the Midpoint**\nTo find the middle of the list in a single pass without knowing its length $n$, we employ the \"tortoise and hare\" algorithm. Two pointers, a $slow$ pointer and a $fast$ pointer, are initialized to the head of the list. The pointers are advanced through the list in a loop: the $slow$ pointer moves one node at a time ($slow = slow.next$), while the $fast$ pointer moves two nodes at a time ($fast = fast.next.next$). The loop continues as long as $fast.next$ and $fast.next.next$ are not $None$.\n\nWhen this loop terminates, the $slow$ pointer will be positioned correctly to demarcate the first and second halves of the list.\n- For a list with an even number of nodes, $n = 2k$, the $slow$ pointer will stop at the $k$-th node (the end of the first half).\n- For a list with an odd number of nodes, $n = 2k+1$, the $slow$ pointer will stop at the $k$-th node, which is the node just before the central element. The central element itself does not need to be compared, as it is its own counterpart.\n\nThe head of the second half of the list is therefore always found at $slow.next$.\n\n**Step 2: Reversing the Second Half**\nOnce the midpoint is found, the second half of the list, starting from $slow.next$, must be reversed in-place. This is a standard procedure for linked lists that can be accomplished in linear time and with constant space. We use three pointers: $previous$, $current$, and $next\\_node$.\n1. Initialize $previous = None$ and $current$ to the head of the sub-list to be reversed (i.e., $slow.next$).\n2. Iterate while $current$ is not $None$:\n   a. Store the next node: $next\\_node = current.next$.\n   b. Reverse the pointer of the current node: $current.next = previous$.\n   c. Move the $previous$ and $current$ pointers one step forward: $previous = current$ and $current = next\\_node$.\nAfter the loop, $previous$ will point to the new head of the now-reversed second half of the list. Before performing the reversal, it is crucial to sever the link between the first and second halves by setting $slow.next = None$.\n\n**Step 3: Comparing the two Halves**\nWith the second half reversed, we can now compare it with the first half. We use two pointers: one starting from the original $head$ of the list ($first\\_half\\_ptr$) and another starting from the head of the reversed second half ($second\\_half\\_ptr$). These two pointers are advanced simultaneously, and their corresponding node values are compared at each step.\n- $first\\_half\\_ptr = head$\n- $second\\_half\\_ptr = head\\_of\\_reversed\\_second\\_half$\nThe traversal continues as long as $second\\_half\\_ptr$ is not $None$. If at any point $first\\_half\\_ptr.val \\neq second\\_half\\_ptr.val$, we conclude that the list is not a palindrome and can stop the comparison. If the loop completes without finding any mismatches, the list is a palindrome.\n\n**Step 4: Restoring the Original List Structure**\nA critical requirement of the problem is to leave the list in its original state. This is achieved by reversing the second half of the list again, which will restore its original order. The same reversal algorithm from Step $2$ is applied to the head of the reversed second half. The head of this newly re-reversed list is then linked back to the end of the first half, i.e., $slow.next$ is set to point to the head of the restored second half. This seamlessly reconstructs the original linked list.\n\n**Edge Cases**\n- An empty list ($head$ is $None$) is a palindrome.\n- A list with a single node ($head.next$ is $None$) is also a palindrome.\nThese cases are handled at the beginning of the function to simplify the main logic.\n\n**Complexity Analysis**\n- **Time Complexity**: Finding the midpoint takes $\\mathcal{O}(n/2)$ time. Reversing the second half takes $\\mathcal{O}(n/2)$ time. The comparison takes $\\mathcal{O}(n/2)$ time. Restoring the list takes another $\\mathcal{O}(n/2)$ time. The total time complexity is the sum of these parts, which is $\\mathcal{O}(n)$.\n- **Space Complexity**: The algorithm uses a fixed number of pointers ($slow$, $fast$, $previous$, $current$, etc.) regardless of the list size $n$. All manipulations are done in-place. Therefore, the auxiliary space complexity is $\\mathcal{O}(1)$.\n\nThis algorithm correctly determines the palindrome property while satisfying all problem constraints.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom typing import Optional, List\n\nclass Node:\n    \"\"\"\n    Represents a node in a singly linked list.\n    \"\"\"\n    def __init__(self, val: int, next_node: Optional['Node'] = None):\n        self.val = val\n        self.next = next_node\n\ndef create_linked_list(values: List[int]) -> Optional[Node]:\n    \"\"\"\n    Helper function to create a singly linked list from a list of values.\n    \"\"\"\n    if not values:\n        return None\n    head = Node(values[0])\n    current = head\n    for val in values[1:]:\n        current.next = Node(val)\n        current = current.next\n    return head\n\ndef is_palindrome(head: Optional[Node]) -> bool:\n    \"\"\"\n    Checks if a singly linked list is a palindrome in O(n) time and O(1) space.\n    The list is restored to its original state after the check.\n    \"\"\"\n    # Edge cases: an empty list or a list with a single node are palindromes.\n    if not head or not head.next:\n        return True\n\n    # Step 1: Find the middle of the list using the slow/fast pointer technique.\n    slow = head\n    fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Step 2: Reverse the second half of the list.\n    def reverse_list(node: Optional[Node]) -> Optional[Node]:\n        prev = None\n        curr = node\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev\n\n    # slow.next is the head of the second half.\n    second_half_head = reverse_list(slow.next)\n    \n    # Detach the first half from the second half for comparison.\n    # Note: this link will be restored later.\n    slow.next = None\n    \n    # Step 3: Compare the first half with the reversed second half.\n    is_pal = True\n    first_half_ptr = head\n    second_half_ptr = second_half_head\n    while second_half_ptr:\n        if first_half_ptr.val != second_half_ptr.val:\n            is_pal = False\n            break\n        first_half_ptr = first_half_ptr.next\n        second_half_ptr = second_half_ptr.next\n\n    # Step 4: Restore the original list by reversing the second half again\n    # and re-attaching it to the first half.\n    # The head of the re-reversed list will be the original start of the second half.\n    restored_second_half_head = reverse_list(second_half_head)\n    slow.next = restored_second_half_head\n    \n    return is_pal\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],                            # case 1\n        [7],                           # case 2\n        [1, 2, 2, 1],                  # case 3\n        [1, 2, 3, 2, 1],               # case 4\n        [1, 2],                        # case 5\n        [10, -1, -1, 10],              # case 6\n        [3, 4, 5, 4, 6],               # case 7\n        [1, 0, 0, 1],                  # case 8\n        [9, 9, 9, 9],                  # case 9\n        [2147483647, -2147483648, -2147483648, 2147483647] # case 10\n    ]\n\n    results = []\n    for case_values in test_cases:\n        # Construct the linked list for the current test case.\n        head = create_linked_list(case_values)\n        \n        # Check if it is a palindrome and store the result.\n        result = is_palindrome(head)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3255584"}]}