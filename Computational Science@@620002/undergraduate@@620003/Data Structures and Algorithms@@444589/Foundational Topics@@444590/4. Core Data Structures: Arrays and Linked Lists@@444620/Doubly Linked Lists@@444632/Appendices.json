{"hands_on_practices": [{"introduction": "One of the principal advantages of a doubly linked list over its singly linked counterpart is the ability to traverse in both directions. This exercise leverages this feature to solve a classic problem: determining if the sequence of data in a list forms a palindrome. By using a two-pointer approach—one starting at the head and one at the tail—you can efficiently compare elements without needing extra memory, a task that would be far less efficient with a singly linked list. This practice reinforces the core benefit of bidirectional pointers and develops your ability to devise elegant, space-efficient algorithms [@problem_id:3229848].", "problem": "You are tasked with writing a complete, runnable program that decides, for each of several finite sequences of integers, whether the data stored in a doubly linked list built from that sequence forms a palindrome. The program must construct a doubly linked list for each given sequence, then determine whether reading the node data from head to tail yields the same sequence as reading from tail to head.\n\nFundamental base. A doubly linked list is a finite sequence of nodes where each node contains an integer payload and two references: a forward reference `next` to its successor and a backward reference `prev` to its predecessor. A sequence $(a_0, a_1, \\dots, a_{n-1})$ of length $n$ is a palindrome if and only if for all indices $i$ with $0 \\le i < \\lfloor n/2 \\rfloor$ it holds that $a_i = a_{n-1-i}$. In particular, the empty sequence (length $n = 0$) satisfies the palindrome property by this definition.\n\nRequirements and constraints. Your algorithm must be derived from these core definitions and obey the following constraints, which are to be justified by first principles in your solution:\n- Time complexity must be linear in the number of nodes $n$, that is, $\\mathcal{O}(n)$.\n- Additional space usage must be constant with respect to $n$, that is, $\\mathcal{O}(1)$, excluding the space needed to store the input doubly linked list itself. In particular, do not allocate auxiliary arrays, stacks, or lists whose size grows with $n$.\n- Do not mutate the node payloads or the `next`/`prev` topology of the list. You may traverse by following `next` and `prev` references and compare payloads.\n\nTest suite. Your program must evaluate the palindrome predicate on the following sequences, each to be interpreted as the data values in order from the head node to the tail node of a doubly linked list:\n- Test $1$: $\\langle 1, 2, 3, 2, 1 \\rangle$\n- Test $2$: $\\langle 4, 5, 5, 4 \\rangle$\n- Test $3$: $\\langle 1, 2, 3, 4, 5 \\rangle$\n- Test $4$: $\\langle 7 \\rangle$\n- Test $5$: $\\langle \\rangle$ (the empty list)\n- Test $6$: $\\langle 10, -1, -1, 10 \\rangle$\n- Test $7$: $\\langle 2, 2, 2, 2, 2, 2 \\rangle$\n- Test $8$: $\\langle 1, 2, 2, 3, 2, 2, 1 \\rangle$\n- Test $9$: $\\langle 1, 2 \\rangle$\n- Test $10$: $\\langle 0, 1, 0, 1 \\rangle$\n\nAnswer type. For each test, your program must produce a Boolean value indicating whether the corresponding list is a palindrome under the definition above.\n\nFinal output format. Your program should produce a single line of output containing the results for Tests $1$ through $10$ in order as a comma-separated list enclosed in square brackets, with each Boolean written as the literal token True or False, and with no spaces. For example, a valid output looks like [True,False,True]. Your program must be self-contained and must not read any input; it must construct the lists for the tests internally and print the single required output line.", "solution": "The problem requires the creation and validation of an algorithm to determine if the data in a doubly linked list forms a palindrome. The algorithm must adhere to strict complexity constraints: $\\mathcal{O}(n)$ time complexity and $\\mathcal{O}(1)$ auxiliary space complexity, where $n$ is the number of nodes in the list.\n\n### Problem Validation\n\nFirst, a validation of the problem statement is conducted.\n- **Givens**:\n    1.  A doubly linked list node has an integer payload, a `next` reference, and a `prev` reference.\n    2.  A sequence $(a_0, a_1, \\dots, a_{n-1})$ is a palindrome if $a_i = a_{n-1-i}$ for all $i$ where $0 \\le i < \\lfloor n/2 \\rfloor$.\n    3.  The empty sequence ($n=0$) is a palindrome.\n    4.  The algorithm's time complexity must be $\\mathcal{O}(n)$.\n    5.  The algorithm's auxiliary space complexity must be $\\mathcal{O}(1)$.\n    6.  The list structure and its data must not be mutated.\n    7.  A specific suite of ten test cases is provided.\n- **Analysis**:\n    -   The problem is **scientifically grounded** in the established principles of data structures and algorithms. The definitions of a doubly linked list and a palindrome are standard and mathematically precise.\n    -   The problem is **well-posed**. It provides clear definitions, constraints, and test cases, leading to a unique, verifiable boolean outcome for each test.\n    -   The problem is **objective**, free of ambiguity or subjective claims.\n    -   The constraints are self-consistent and a known, efficient algorithm exists that satisfies them.\n- **Verdict**: The problem is valid.\n\n### Principle-Based Algorithmic Design\n\nThe solution is derived directly from the definition of a palindrome and the structural properties of a doubly linked list.\n\n1.  **Core Principle**: The definition of a palindrome, $a_i = a_{n-1-i}$, necessitates comparing elements symmetrically positioned around the center of the sequence. The $0$-th element must match the $(n-1)$-th, the $1$-st must match the $(n-2)$-th, and so on, up to the middle of the sequence.\n\n2.  **Algorithmic Strategy**: A doubly linked list is uniquely suited for this comparison. It allows traversal from both ends simultaneously. We can employ a two-pointer technique. Let one pointer, $p_{head}$, start at the head of the list and traverse forwards using the `next` reference. Let a second pointer, $p_{tail}$, start at the tail of the list and traverse backwards using the `prev` reference. At each step, we compare the data payloads of the nodes indicated by $p_{head}$ and $p_{tail}$.\n\n3.  **Algorithm Formalization**:\n    *   **Initialization**: To begin, we require access to both the `head` and `tail` of the list. We initialize two pointers: $p_{head} \\leftarrow head$ and $p_{tail} \\leftarrow tail$.\n    *   **Edge Cases**:\n        *   If the list is empty (`head` is null, corresponds to $n=0$), it is a palindrome by definition. The algorithm should return `True`.\n        *   If the list has one element (`head` == `tail`, corresponds to $n=1$), it is also a palindrome. The main loop logic, as designed below, will correctly handle this.\n    *   **Iterative Comparison**: The algorithm proceeds in a loop. In each iteration:\n        1.  The data payloads are compared: if $p_{head}.data \\ne p_{tail}.data$, a mismatch is found. The sequence is not a palindrome, and the algorithm can immediately terminate and return `False`.\n        2.  The pointers are advanced towards the center: $p_{head} \\leftarrow p_{head}.next$ and $p_{tail} \\leftarrow p_{tail}.prev$.\n    *   **Termination Conditions**: The loop continues until the pointers meet or cross, signifying that all necessary pairs have been checked. This is detected by one of two conditions:\n        1.  $p_{head} == p_{tail}$: This occurs when the pointers meet at the central node of a list with an odd number of elements.\n        2.  $p_{head}.prev == p_{tail}$: This occurs just after the pointers have crossed in a list with an even number of elements. The `while` loop condition checks `p_head != p_tail` and `p_head.prev != p_tail` to handle both cases elegantly. A simpler approach is to detect when the two pointers are adjacent (`p_head.next == p_tail`) *before* advancing them, which marks the last comparison for an even-length list.\n    *   **Final Outcome**: If the loop completes without finding any mismatches, it confirms that $a_i = a_{n-1-i}$ for all required $i$. The algorithm returns `True`.\n\nA robust sequence of checks within the loop is:\n```\nwhile True:\n    if $p_{head}.data \\ne p_{tail}.data$: return False\n    if $p_{head} == p_{tail}$: break  // Middle of odd-length list reached\n    if $p_{head}.next == p_{tail}$: break // Middle of even-length list reached\n    $p_{head} \\leftarrow p_{head}.next$\n    $p_{tail} \\leftarrow p_{tail}.prev$\nreturn True\n```\n\n4.  **Complexity Justification**:\n    *   **Time Complexity**: The pointers $p_{head}$ and $p_{tail}$ start at opposite ends and move towards each other. Each pointer traverses approximately $n/2$ nodes. Since the work done per node is constant (one comparison and one pointer update), the total time taken is proportional to $n$. This yields a time complexity of $\\mathcal{O}(n)$, satisfying the constraint.\n    *   **Space Complexity**: The algorithm uses only a fixed number of variables (two pointers: $p_{head}$ and $p_{tail}$). The amount of memory used does not scale with the list size $n$. Thus, the auxiliary space complexity is $\\mathcal{O}(1)$, satisfying the constraint.\n    *   **Immutability**: The algorithm only reads data from nodes (`.data`) and follows existing references (`.next`, `.prev`). It does not modify any node payloads or the list's topology, adhering to the immutability constraint.\n\nThis two-pointer approach is therefore a correct, optimal, and principled solution to the stated problem.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to construct doubly linked lists from test cases,\n    check for the palindrome property, and print the results.\n    \"\"\"\n\n    class Node:\n        \"\"\"\n        Represents a node in a doubly linked list.\n        Each node contains an integer payload, a 'next' reference,\n        and a 'prev' reference.\n        \"\"\"\n        def __init__(self, data=0, prev=None, next=None):\n            self.data = data\n            self.prev = prev\n            self.next = next\n\n    def build_doubly_linked_list(data_list):\n        \"\"\"\n        Constructs a doubly linked list from a Python list of integers.\n\n        Args:\n            data_list: A list of integers.\n\n        Returns:\n            A tuple (head, tail) representing the head and tail nodes\n            of the newly created list. Returns (None, None) for an empty list.\n        \"\"\"\n        if not data_list:\n            return None, None\n\n        # Create the head node\n        head = Node(data=data_list[0])\n        previous_node = head\n\n        # Create subsequent nodes and link them\n        for i in range(1, len(data_list)):\n            new_node = Node(data=data_list[i], prev=previous_node)\n            previous_node.next = new_node\n            previous_node = new_node\n        \n        # The last node created is the tail\n        tail = previous_node\n        return head, tail\n\n    def is_palindrome(head, tail):\n        \"\"\"\n        Determines if a doubly linked list is a palindrome.\n\n        The algorithm uses a two-pointer approach, one starting from the head and\n        one from the tail, moving towards the center and comparing node data.\n        This respects the O(n) time and O(1) space constraints.\n\n        Args:\n            head: The head node of the list.\n            tail: The tail node of the list.\n\n        Returns:\n            True if the list is a palindrome, False otherwise.\n        \"\"\"\n        # An empty list (n=0) is a palindrome by definition.\n        if head is None:\n            return True\n\n        p_head = head\n        p_tail = tail\n\n        while True:\n            # Compare data from both ends. If they differ, it's not a palindrome.\n            if p_head.data != p_tail.data:\n                return False\n\n            # Termination condition for odd-length lists: pointers meet at the center.\n            if p_head == p_tail:\n                break\n\n            # Termination condition for even-length lists: pointers are adjacent.\n            if p_head.next == p_tail:\n                break\n\n            # Move pointers towards the center.\n            p_head = p_head.next\n            p_tail = p_tail.prev\n        \n        return True\n\n    # The test suite provided in the problem statement.\n    test_cases = [\n        [1, 2, 3, 2, 1],        # Test 1\n        [4, 5, 5, 4],           # Test 2\n        [1, 2, 3, 4, 5],        # Test 3\n        [7],                    # Test 4\n        [],                     # Test 5\n        [10, -1, -1, 10],       # Test 6\n        [2, 2, 2, 2, 2, 2],     # Test 7\n        [1, 2, 2, 3, 2, 2, 1],  # Test 8\n        [1, 2],                 # Test 9\n        [0, 1, 0, 1],           # Test 10\n    ]\n\n    results = []\n    for data_list in test_cases:\n        list_head, list_tail = build_doubly_linked_list(data_list)\n        result = is_palindrome(list_head, list_tail)\n        results.append(result)\n\n    # Format and print the final output as a single string.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3229848"}, {"introduction": "Moving beyond simple traversal, this challenge tackles a more complex structural modification: flattening a multi-level doubly linked list. The problem requires you to splice child lists into the main list in a specific depth-first order, a task that demands meticulous pointer manipulation. Mastering this in-place \"splicing\" technique is crucial for understanding how to manage hierarchical data and perform complex, non-linear reorganizations of linked structures, all while maintaining the integrity of the `prev` and `next` pointers [@problem_id:3229789].", "problem": "You are given the formal definition of a doubly linked list with possible multi-level nesting. Each node stores an integer value and three pointers: a previous pointer, a next pointer, and a child pointer. The foundational base is the core definition of a doubly linked list and pointer manipulation laws: for any two consecutive nodes in the same level, if a node $u$ immediately precedes a node $v$, then the invariants $u.\\text{next} = v$ and $v.\\text{prev} = u$ hold. In a multi-level doubly linked list, a node may have an additional pointer $u.\\text{child}$ that points to the head of another doubly linked list, forming a hierarchical structure. All pointers are either valid references or null.\n\nImplement a procedure to flatten such a multi-level doubly linked list into a single-level doubly linked list by splicing each child list between the node and its original next node. The flattening order must be depth-first preorder on child lists: for any node $u$, if $u.\\text{child}$ is non-null, then all nodes in the child list (recursively flattened) must immediately follow $u$ before resuming at $u.\\text{next}$. After flattening:\n- The resulting structure must be a single-level doubly linked list obeying the invariants $u.\\text{next} = v$ and $v.\\text{prev} = u$ for each consecutive pair.\n- Every $u.\\text{child}$ must be set to null.\n- The node values in the flattened list must appear in the specified depth-first order.\n- No new nodes may be allocated, and no cycles may be introduced.\n\nYour program must construct the following test suite of multi-level lists internally and flatten each one, producing the sequence of node values in the flattened list for each case.\n\nTest Suite (values are integers, indices are zero-based within each level):\n1. Happy path with multiple children and nested child:\n   - Main level values: $[10,20,30,40]$.\n   - Child relationships:\n     - Node at index $1$ (value $20$) has child with values $[5,6]$, and within that child list, the node at index $1$ (value $6$) has its child with values $[99]$.\n     - Node at index $2$ (value $30$) has child with values $[7]$.\n2. Boundary case of an empty list:\n   - Main level values: $[]$.\n3. Single node with a deep linear child chain:\n   - Main level values: $[1]$.\n   - Child relationships:\n     - Node at index $0$ (value $1$) has child $[2]$, the node at index $0$ (value $2$) has child $[3]$, and the node at index $0$ (value $3$) has child $[4]$.\n4. Multiple consecutive nodes having children, with nested children inside those child lists:\n   - Main level values: $[3,14,15]$.\n   - Child relationships:\n     - Node at index $0$ (value $3$) has child $[9,2]$, and within that child list, node at index $0$ (value $9$) has child $[1]$.\n     - Node at index $2$ (value $15$) has child $[26,53]$, and within that child list, node at index $1$ (value $53$) has child $[58]$.\n5. Head has a child, and the child list itself contains multiple nodes with their own children:\n   - Main level values: $[100]$.\n   - Child relationships:\n     - Node at index $0$ (value $100$) has child $[200,300]$.\n     - Within that child list, node at index $0$ (value $200$) has child $[400]$, and node at index $1$ (value $300$) has child $[500]$.\n\nYour algorithmic design must be derived from first principles: use the core invariants of doubly linked lists and pointer splicing, and reason about traversal order and stack discipline in Depth-First Search (DFS). Provide no shortcut formula; derive correctness from maintaining the invariants at each splice. Target time complexity must be $\\mathcal{O}(n)$ in the number of nodes $n$, with auxiliary space $\\mathcal{O}(d)$ where $d$ is the maximum nesting depth, if using an explicit stack, or $\\mathcal{O}(1)$ auxiliary space if using in-place traversal without an explicit stack and careful pointer threading.\n\nFinal Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the flattened sequence of values for a test case. For example, the format must be $\\left[ [1,2], [3], [] \\right]$ but without spaces, i.e., $\\left[[1,2],[3],[]\\right]$.\n\nThe answer for each test case must be a list of integers. No physical units or angle units are involved in this problem. Your program must not read input; it must construct the specified test suite internally and print the aggregated results in the exact format described above.", "solution": "## PROBLEM VALIDATION\n\n### Step 1: Extract Givens\n\n- **Data Structure Definition**: A multi-level doubly linked list where each node contains an integer value and three pointers: `prev`, `next`, and `child`.\n- **Base Invariants**: For any two consecutive nodes `u` and `v` on the same level, `u.next = v` and `v.prev = u`.\n- **Hierarchy**: A node's `child` pointer can point to the head of another doubly linked list. All pointers are either valid references or null.\n- **Task**: Flatten the multi-level list into a single-level doubly linked list.\n- **Flattening Rule**: Splice each child list between the node `u` and its original next node `u.next`.\n- **Flattening Order**: Depth-first preorder on child lists. If `u.child` is non-null, the recursively flattened child list must immediately follow `u`.\n- **Post-Flattening Conditions**:\n    1. The result is a single-level doubly linked list.\n    2. The invariants `u.next = v` and `v.prev = u` hold for all consecutive pairs.\n    3. All `child` pointers must be set to null.\n    4. Node values in the flattened list must appear in depth-first order.\n    5. No new nodes may be allocated.\n    6. No cycles may be introduced.\n- **Performance Targets**:\n    - Time Complexity: $\\mathcal{O}(n)$, where $n$ is the total number of nodes.\n    - Space Complexity: $\\mathcal{O}(d)$ for an explicit stack approach (where $d$ is max depth), or $\\mathcal{O}(1)$ for an in-place iterative approach.\n- **Test Suite**:\n    1. Main: `[10,20,30,40]`. Children: `20` -> `[5,6]`; `6` -> `[99]`; `30` -> `[7]`.\n    2. Main: `[]`.\n    3. Main: `[1]`. Children: `1` -> `[2]`; `2` -> `[3]`; `3` -> `[4]`.\n    4. Main: `[3,14,15]`. Children: `3` -> `[9,2]`; `9` -> `[1]`; `15` -> `[26,53]`; `53` -> `[58]`.\n    5. Main: `[100]`. Children: `100` -> `[200,300]`; `200` -> `[400]`; `300` -> `[500]`.\n- **Output Format**: A single-line string representing a list of lists of integers, e.g., `[[1,2],[3],[]]`.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is subjected to validation against the specified criteria.\n\n- **Scientifically Grounded (Critical)**: The problem is rooted in computer science, specifically the domain of data structures and algorithms. The concepts of doubly linked lists, pointers, and traversal algorithms (Depth-First Search) are well-established and mathematically rigorous. The problem is factually and logically sound.\n- **Well-Posed**: The problem is clearly defined. The structure of the input is specified, the transformation rules are unambiguous (depth-first preorder splicing), and the desired properties of the output are explicitly listed. For any valid input, a unique flattened list exists.\n- **Objective (Critical)**: The problem is stated in precise, formal language, free of subjectivity or opinion.\n- **Completeness**: The problem provides all necessary definitions, constraints, and test cases to formulate and verify a solution. It is self-contained.\n- **Consistency**: The constraints are not contradictory. The depth-first order rule is consistent with the in-place splicing operation.\n- **Realism**: The problem is an abstract algorithmic challenge and does not involve physical phenomena. Its constraints are computationally feasible.\n- **Other Flaws**: The problem is not trivial, metaphorical, or tautological. It represents a standard, substantive challenge in pointer-based data structure manipulation. Its correctness is verifiable.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. It is a well-posed, formal, and verifiable problem in the field of data structures and algorithms. I will proceed with providing a complete solution.\n\n## ALGORITHMIC DESIGN AND DERIVATION\n\nThe objective is to flatten a multi-level doubly linked list into a single-level list in-place, with the nodes ordered according to a depth-first preorder traversal. We must maintain the doubly linked list invariants throughout the process. The most efficient solution will achieve this with $\\mathcal{O}(1)$ auxiliary space.\n\n**Core Principle: In-Place Splicing**\nThe fundamental operation is splicing a child list into the main list. Consider a node $u$ with a successor $v = u.\\text{next}$ and a child list starting at $c_{\\text{head}} = u.\\text{child}$. Let the tail of this child list be $c_{\\text{tail}}$. To insert the child list between $u$ and $v$, the following pointer reassignments are necessary, preserving the list's integrity:\n1. The link from $u$ must now point to $c_{\\text{head}}$: $u.\\text{next} \\leftarrow c_{\\text{head}}$.\n2. The back-link from $c_{\\text{head}}$ must point to $u$: $c_{\\text{head}}.\\text{prev} \\leftarrow u$.\n3. The link from the child list's tail, $c_{\\text{tail}}$, must point to $u$'s original successor, $v$: $c_{\\text{tail}}.\\text{next} \\leftarrow v$.\n4. If $v$ exists (i.e., is not null), its back-link must point to $c_{\\text{tail}}$: $v.\\text{prev} \\leftarrow c_{\\text{tail}}$.\n5. Finally, the problem requires that the child pointer be nullified: $u.\\text{child} \\leftarrow \\text{null}$.\n\n**Algorithm Derivation: Iterative Traversal with $\\mathcal{O}(1)$ Space**\nAn iterative approach traversing the list with a single main pointer provides an elegant and space-efficient solution. The key insight is that by modifying the `.next` pointers as we traverse, the traversal path itself can be made to follow the desired depth-first order.\n\nLet's define the algorithm:\n1. Initialize a pointer, `curr`, to the `head` of the list. If `head` is null, the list is empty and the process terminates.\n2. Iterate while `curr` is not null. In each iteration, we examine `curr`:\n   a. **Case 1: `curr` has no child (`curr.child` is null).** The list is already locally flat at this node. We simply advance the pointer to the next node in the current level: `curr \\leftarrow curr.next`.\n   b. **Case 2: `curr` has a child (`curr.child` is non-null).** We must perform the splicing operation.\n      i. First, we need to locate the tail of the sublist starting at `curr.child`. We use a temporary pointer, `child_tail`, initialized to `curr.child`, and traverse its `.next` pointers until we reach the last node: `while (child_tail.next is not null) child_tail \\leftarrow child_tail.next`. **It is crucial to note that this finds the tail of the immediate child list; any nested children within it are handled later as the main `curr` pointer naturally traverses into the newly spliced segment.**\n      ii. Let `original_next = curr.next` be the node that will eventually follow the spliced-in child list.\n      iii. We now execute the splice as per the core principle. We connect `child_tail` to `original_next`: `child_tail.next \\leftarrow original_next`. If `original_next` is not null, we update its `prev` pointer: `original_next.prev \\leftarrow child_tail`.\n      iv. Next, we connect `curr` to its child list: `curr.next \\leftarrow curr.child` and `curr.child.prev \\leftarrow curr`.\n      v. Finally, we set the child pointer to null as required: `curr.child \\leftarrow \\text{null}`.\n   c. After handling both cases, the `while` loop proceeds. If we performed a splice, `curr.next` now points to the head of the child list. Thus, when we eventually advance `curr \\leftarrow curr.next` (in the next iteration, if we don't advance it at the end of the current one), we naturally descend into the sub-problem, producing the required depth-first order. The loop structure handles this automatically. For simplicity and correctness, we advance `curr` at the end of every loop iteration.\n\n**Complexity Analysis**\n- **Time Complexity**: The primary pointer `curr` visits each node of the entire structure exactly once. The inner `while` loop to find `child_tail` traverses the `next` pointers of a child list. Since each such list is immediately integrated into the main list and not traversed again by an inner loop, each `next` edge across the entire structure is traversed a small, constant number of times. Therefore, the total runtime is linear in the number of nodes, $n$, yielding a complexity of $\\mathcal{O}(n)$.\n- **Space Complexity**: The algorithm uses a fixed number of pointer variables (`curr`, `original_next`, `child_tail`) regardless of the size or depth of the list. No recursion stack or auxiliary data structure is used. Thus, the auxiliary space complexity is $\\mathcal{O}(1)$.\n\nThis algorithm is correct, meets all problem constraints, and is optimally efficient in terms of space.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in a multi-level doubly linked list.\n    \"\"\"\n    def __init__(self, val: int, prev: 'Node' = None, next: 'Node' = None, child: 'Node' = None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n\ndef flatten(head: 'Node') -> 'Node':\n    \"\"\"\n    Flattens a multi-level doubly linked list into a single level in-place.\n    The algorithm uses an iterative approach with O(1) auxiliary space.\n\n    Args:\n        head: The head node of the multi-level list.\n\n    Returns:\n        The head of the flattened list.\n    \"\"\"\n    if not head:\n        return None\n\n    curr = head\n    while curr:\n        # If there is no child, we just move on to the next node.\n        if not curr.child:\n            curr = curr.next\n            continue\n\n        # If a child exists, we need to splice it in.\n        child_node = curr.child\n\n        # 1. Find the tail of the child list.\n        child_tail = child_node\n        while child_tail.next:\n            child_tail = child_tail.next\n        \n        # 2. Store the original next node of curr.\n        original_next = curr.next\n\n        # 3. Connect the child_tail to the original_next.\n        child_tail.next = original_next\n        if original_next:\n            original_next.prev = child_tail\n\n        # 4. Connect curr to its child list.\n        curr.next = child_node\n        child_node.prev = curr\n\n        # 5. Nullify the child pointer.\n        curr.child = None\n\n        # 6. Advance the current pointer.\n        curr = curr.next\n    \n    return head\n\ndef build_list_from_spec(spec: tuple) -> 'Node':\n    \"\"\"\n    Helper function to build a multi-level list from a specification tuple.\n    The spec is of the form (values: list, children: dict), where the children\n    dict maps parent index to another spec tuple.\n    \"\"\"\n    values, child_map = spec\n    if not values:\n        return None\n    \n    nodes = [Node(val) for val in values]\n    for i in range(len(nodes)):\n        if i > 0:\n            nodes[i].prev = nodes[i-1]\n        if i < len(nodes) - 1:\n            nodes[i].next = nodes[i+1]\n            \n    for parent_idx, child_spec in child_map.items():\n        child_head = build_list_from_spec(child_spec)\n        if child_head:\n            nodes[parent_idx].child = child_head\n            \n    return nodes[0] if nodes else None\n\ndef get_list_values(head: 'Node') -> list[int]:\n    \"\"\"\n    Traverses a flattened list and returns a list of its node values.\n    \"\"\"\n    if not head:\n        return []\n    \n    values = []\n    curr = head\n    while curr:\n        values.append(curr.val)\n        curr = curr.next\n    return values\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the flatten algorithm on each, and prints results.\n    \"\"\"\n    # Define the test suite of multi-level lists as specifications.\n    test_specs = [\n        # 1. Happy path with multiple children and nested child\n        ([10, 20, 30, 40], {\n            1: ([5, 6], {1: ([99], {})}),\n            2: ([7], {})\n        }),\n        # 2. Boundary case of an empty list\n        ([], {}),\n        # 3. Single node with a deep linear child chain\n        ([1], {0: ([2], {0: ([3], {0: ([4], {})})})}),\n        # 4. Multiple consecutive nodes having children\n        ([3, 14, 15], {\n            0: ([9, 2], {0: ([1], {})}),\n            2: ([26, 53], {1: ([58], {})})\n        }),\n        # 5. Head has a child, child list has children\n        ([100], {\n            0: ([200, 300], {\n                0: ([400], {}),\n                1: ([500], {})\n            })\n        })\n    ]\n\n    results = []\n    for spec in test_specs:\n        head = build_list_from_spec(spec)\n        flattened_head = flatten(head)\n        result_values = get_list_values(flattened_head)\n        results.append(result_values)\n\n    # Format the final output string exactly as required.\n    # e.g., [[1,2],[3],[]]\n    output_str = \"[\" + \",\".join([str(res).replace(\" \", \"\") for res in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3229789"}, {"introduction": "This final practice serves as a capstone exercise, combining advanced algorithmic design with the nuances of linked list manipulation. You are tasked with implementing a stable merge sort entirely in-place, a significant challenge that highlights how fundamental algorithms are adapted for non-contiguous data structures. This problem will deepen your understanding of the divide-and-conquer paradigm and force you to reason carefully about pointer-based splitting and merging, demonstrating how to achieve an efficient $O(n \\log n)$ sort with only a logarithmic amount of stack space [@problem_id:3229904].", "problem": "You are to design and implement, from first principles and core definitions, an in-place, stable merge sort for a doubly linked list. A doubly linked list is defined as a sequence of nodes where each node stores a key and has two pointers: a forward pointer to the next node and a backward pointer to the previous node. Formally, each node stores an integer key $k \\in \\mathbb{Z}$, an integer identifier $i \\in \\mathbb{Z}$ used only to test stability, and two references $prev$ and $next$ such that for any interior node $x$, $x.prev.next = x$ and $x.next.prev = x$. The head node $h$ has $h.prev = \\varnothing$ and the tail node $t$ has $t.next = \\varnothing$. Your algorithm must satisfy the following properties derived from fundamental definitions of sorting and linked list invariants:\n\n- Stability: If two nodes have equal keys $k$, their relative order in the output must match their relative order in the input. Stability is defined with respect to the identifiers $i$; the algorithm must not compare or otherwise use $i$ for ordering, only $k$.\n- Time complexity: The algorithm must run in $O(n \\log n)$ time on a list of length $n$, using the well-known divide-and-conquer recurrence grounded in the definition of merge sort and the cost of merging two sorted linked sequences via pointer manipulation.\n- Additional space complexity: The algorithm must use $O(1)$ additional heap space beyond the storage for the list itself. Call stack space of $O(\\log n)$ due to recursion is permitted. All merging must be done by relinking existing nodes in place; no new nodes may be allocated during sorting.\n- List integrity: After sorting, forward and backward pointers must be mutually consistent across the entire list. Specifically, if the sorted head is $h'$, then $h'.prev = \\varnothing$, the sorted tail $t'$ has $t'.next = \\varnothing$, and for every node $x$ reachable from $h'$ via $next$, if $x.next = y$ then $y.prev = x$, and if $x.prev = z$ then $z.next = x$.\n\nTask: Implement a function that sorts such a doubly linked list in place using merge sort and returns the head pointer of the sorted list. You must not use array-based sorting or convert the list to an array as part of the algorithm. You must adhere to pointer-based list operations.\n\nTest suite and required outputs: Your program must hard-code the following test cases, build the corresponding doubly linked lists, sort them, and report three outputs per test case: the sorted list as a list of pairs $\\big[(k,i)\\big]$ in forward traversal order, a boolean indicating whether list integrity holds as defined above, and a boolean indicating whether stability holds as defined above. Use the exact sequences below, where identifiers $i$ are the original $0$-based positions in the given sequence.\n\n- Test case $1$ (general case with duplicates and negatives): keys $\\langle 3, 1, 2, 3, -1, 2, 3 \\rangle$ with identifiers $\\langle 0, 1, 2, 3, 4, 5, 6 \\rangle$.\n- Test case $2$ (empty list): keys $\\langle \\rangle$.\n- Test case $3$ (single element): keys $\\langle 5 \\rangle$ with identifier $\\langle 0 \\rangle$.\n- Test case $4$ (already sorted with duplicates): keys $\\langle -2, -1, -1, 0, 0, 5 \\rangle$ with identifiers $\\langle 0, 1, 2, 3, 4, 5 \\rangle$.\n- Test case $5$ (reverse sorted): keys $\\langle 5, 4, 3, 2, 1, 0, -1 \\rangle$ with identifiers $\\langle 0, 1, 2, 3, 4, 5, 6 \\rangle$.\n- Test case $6$ (all equal keys): keys $\\langle 7, 7, 7, 7, 7 \\rangle$ with identifiers $\\langle 0, 1, 2, 3, 4 \\rangle$.\n\nFinal output format: Your program should produce a single line of output containing the results as a JavaScript Object Notation (JSON) array with no spaces, where the $j$-th element (using $0$-based indexing) corresponds to test case $j+1$ and is itself a JSON array of the form $[S, I, B]$ where $S$ is the list of $\\big[(k,i)\\big]$ pairs in forward order, $I$ is the boolean list-integrity result, and $B$ is the boolean stability result. For example, the overall output must have the shape\n$[[S_1, I_1, B_1],[S_2, I_2, B_2],\\dots,[S_6, I_6, B_6]]$\non a single line, with commas separating elements and no whitespace characters.", "solution": "The problem requires the design and implementation of an in-place, stable merge sort for a doubly linked list. The solution must adhere to strict complexity constraints ($O(n \\log n)$ time and $O(1)$ additional heap space) and ensure data integrity.\n\n### Principle-Based Design\n\nThe solution is founded upon the divide-and-conquer paradigm, which is the definitional basis of merge sort. The algorithm recursively divides the linked list into two halves, sorts them independently, and then merges the sorted halves. The key challenges lie in performing the split and merge operations in-place on a doubly linked list while maintaining stability and pointer consistency.\n\n#### 1. Data Representation\nA `Node` class is defined to represent an element in the doubly linked list. As per the problem definition, each node contains an integer key $k$, an integer identifier $i$, a `prev` pointer to the preceding node, and a `next` pointer to the subsequent node.\n\n```python\nclass Node:\n    def __init__(self, key, identifier):\n        self.key = key\n        self.id = identifier\n        self.prev = None\n        self.next = None\n```\n\n#### 2. Recursive Structure: `merge_sort`\nThe main `merge_sort` function implements the recursive divide-and-conquer strategy.\n\n- **Base Case**: A list is considered sorted if it is empty (head is `None`) or contains a single node (head's `next` is `None`). In these cases, the function returns the head immediately, terminating the recursion. This corresponds to the base case in the recurrence relation for the algorithm's complexity.\n\n- **Recursive Step**: For a list of length $n > 1$:\n    1.  **Divide**: The list is split into two sublists of approximately equal size ($ \\lceil n/2 \\rceil $ and $ \\lfloor n/2 \\rfloor $). This is achieved using the classic \"slow and fast pointer\" technique. A `slow` pointer advances one node at a time, while a `fast` pointer advances two nodes. When the `fast` pointer reaches the end of the list, the `slow` pointer is at the node marking the end of the first sublist. The list is then split by severing the link between the two halves (`slow.next = None` and `second_half_head.prev = None`). This operation takes $O(n)$ time.\n    2.  **Conquer**: The `merge_sort` function is called recursively on both sublists.\n    3.  **Combine**: The two sorted sublists returned from the recursive calls are merged into a single sorted list by the `merge` function. This operation also takes $O(n)$ time.\n\nThe time complexity of this structure is described by the recurrence relation $T(n) = 2T(n/2) + O(n)$, which resolves to $T(n) = O(n \\log n)$ by the Master Theorem. The space complexity is $O(\\log n)$ due to the recursion depth on the call stack, which is explicitly permitted.\n\n#### 3. In-Place Merge: `merge`\nThe `merge` function is the core of the implementation, responsible for combining two sorted doubly linked lists in-place.\n\n- **Initialization**: Pointers are initialized to the heads of the two input lists. The head of the final merged list is determined by comparing the keys of the two initial heads. To ensure **stability**, if the keys are equal, the node from the first list is chosen. This is the fundamental principle for maintaining relative order for equal elements. A `tail` pointer is maintained to track the end of the merged list, allowing for efficient $O(1)$ appends.\n\n- **Merging Loop**: The function iterates while both lists have nodes. In each step, it compares the keys of the current nodes from each list. The node with the smaller key (or from the first list in case of a tie) is appended to the `tail` of the merged list. This involves a constant number of pointer reassignments to link the chosen node and update the `tail`. Specifically, for a chosen `node`, the operations are `tail.next = node` and `node.prev = tail`.\n\n- **Appending Remainder**: Once one list is exhausted, the remaining portion of the other list, which is already sorted, is appended to the `tail` of the merged list in a single step.\n\n- **Space Complexity**: This process uses a constant number of auxiliary pointers (`head1`, `head2`, `tail`, `head`), regardless of list size. It modifies the `next` and `prev` pointers of the existing nodes without allocating any new nodes, thus satisfying the $O(1)$ additional heap space constraint.\n\n#### 4. Verification\nTo validate the implementation against the problem's strict requirements, two helper functions are used:\n\n- **`check_integrity`**: This function verifies that the sorted list is a structurally valid doubly linked list. It checks that `head.prev` and `tail.next` are `None`. It then performs two full traversals, one forward from the head and one backward from the tail, ensuring all `next` and `prev` pointers are mutually consistent (i.e., `node.next.prev == node` and `node.prev.next == node` for all applicable nodes).\n\n- **`check_stability`**: This function confirms that the sort is stable. It records the sequences of identifiers for each key in the original list and the sorted list. Stability holds if and only if, for every key with multiple occurrences, the sequence of corresponding identifiers is identical in both the original and sorted lists.\n\nBy adhering to these principles, the resulting implementation provides a correct, efficient, and robust solution that satisfies all stated constraints.", "answer": "```python\nimport numpy as np\nimport json\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to run test cases for in-place stable merge sort on a doubly linked list.\n    \"\"\"\n\n    class Node:\n        \"\"\"Represents a node in a doubly linked list.\"\"\"\n        def __init__(self, key, identifier):\n            self.key = key\n            self.id = identifier\n            self.prev = None\n            self.next = None\n\n        def __repr__(self):\n            return f\"Node(key={self.key}, id={self.id})\"\n\n    def build_list(keys, ids):\n        \"\"\"Constructs a doubly linked list from keys and ids.\"\"\"\n        if not keys:\n            return None\n        head = Node(keys[0], ids[0])\n        current = head\n        for i in range(1, len(keys)):\n            new_node = Node(keys[i], ids[i])\n            current.next = new_node\n            new_node.prev = current\n            current = new_node\n        return head\n\n    def find_mid_and_split(head):\n        \"\"\"\n        Splits the list into two halves and returns the head of the second half.\n        Uses the slow and fast pointer method. The list is modified in-place.\n        \"\"\"\n        if not head or not head.next:\n            return None\n        \n        slow = head\n        fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n            \n        second_half_head = slow.next\n        if second_half_head:\n            second_half_head.prev = None\n        slow.next = None\n        \n        return second_half_head\n\n    def merge(head1, head2):\n        \"\"\"Merges two sorted doubly linked lists in-place and returns the new head.\"\"\"\n        if not head1:\n            return head2\n        if not head2:\n            return head1\n\n        if head1.key <= head2.key:\n            head = head1\n            head1 = head1.next\n        else:\n            head = head2\n            head2 = head2.next\n        \n        tail = head\n        \n        while head1 and head2:\n            if head1.key <= head2.key:\n                tail.next = head1\n                head1.prev = tail\n                tail = head1\n                head1 = head1.next\n            else:\n                tail.next = head2\n                head2.prev = tail\n                tail = head2\n                head2 = head2.next\n\n        if head1:\n            tail.next = head1\n            head1.prev = tail\n        elif head2:\n            tail.next = head2\n            head2.prev = tail\n            \n        return head\n\n    def merge_sort(head):\n        \"\"\"Sorts a doubly linked list using in-place stable merge sort.\"\"\"\n        if not head or not head.next:\n            return head\n\n        second_half_head = find_mid_and_split(head)\n        \n        left = merge_sort(head)\n        right = merge_sort(second_half_head)\n        \n        return merge(left, right)\n\n    def check_integrity(head):\n        \"\"\"Checks if the doubly linked list pointers are consistent.\"\"\"\n        if not head:\n            return True\n        \n        if head.prev is not None:\n            return False\n\n        fwd_nodes = []\n        curr = head\n        tail = None\n        while curr:\n            if curr.next and curr.next.prev is not curr:\n                return False\n            fwd_nodes.append(curr)\n            tail = curr\n            curr = curr.next\n        \n        if tail.next is not None:\n            return False\n            \n        bwd_nodes = []\n        curr = tail\n        while curr:\n            if curr.prev and curr.prev.next is not curr:\n                return False\n            bwd_nodes.append(curr)\n            curr = curr.prev\n        \n        return fwd_nodes == bwd_nodes[::-1]\n\n    def check_stability(original_pairs, sorted_pairs):\n        \"\"\"Checks if the sort was stable.\"\"\"\n        original_map = defaultdict(list)\n        for k, i in original_pairs:\n            original_map[k].append(i)\n            \n        sorted_map = defaultdict(list)\n        for k, i in sorted_pairs:\n            sorted_map[k].append(i)\n        \n        if original_map.keys() != sorted_map.keys():\n            return False\n        \n        for k in original_map:\n            if original_map[k] != sorted_map[k]:\n                return False\n                \n        return True\n\n    test_cases_data = [\n        ([3, 1, 2, 3, -1, 2, 3], [0, 1, 2, 3, 4, 5, 6]),\n        ([], []),\n        ([5], [0]),\n        ([-2, -1, -1, 0, 0, 5], [0, 1, 2, 3, 4, 5]),\n        ([5, 4, 3, 2, 1, 0, -1], [0, 1, 2, 3, 4, 5, 6]),\n        ([7, 7, 7, 7, 7], [0, 1, 2, 3, 4]),\n    ]\n    \n    all_results = []\n    \n    for keys, ids in test_cases_data:\n        original_pairs = list(zip(keys, ids))\n        head = build_list(keys, ids)\n        \n        sorted_head = merge_sort(head)\n        \n        sorted_pairs = []\n        curr = sorted_head\n        while curr:\n            sorted_pairs.append([curr.key, curr.id])\n            curr = curr.next\n        \n        integrity = check_integrity(sorted_head)\n        \n        # for stability check, convert the list of lists back to list of tuples\n        stability = check_stability(original_pairs, [tuple(p) for p in sorted_pairs])\n\n        all_results.append([sorted_pairs, integrity, stability])\n        \n    print(json.dumps(all_results, separators=(',', ':')))\n\nsolve()\n```", "id": "3229904"}]}