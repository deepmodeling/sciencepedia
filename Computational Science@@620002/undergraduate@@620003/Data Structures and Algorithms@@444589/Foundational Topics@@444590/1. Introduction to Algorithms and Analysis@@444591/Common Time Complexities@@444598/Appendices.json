{"hands_on_practices": [{"introduction": "This first practice problem bridges the gap between the abstract concept of time complexity and its concrete impact on system performance. In many real-world applications, such as video processing or embedded systems, algorithms must execute within a strict time budget. This exercise challenges you to determine the maximum input size an algorithm can handle given its exact operation count and the hardware's performance characteristics, reinforcing the practical consequences of a given complexity class. [@problem_id:3221840]", "problem": "A production augmented-reality pipeline must sustain a frame rate of $60$ frames per second, so the processing budget per frame is $16$ milliseconds. A particular stage uses an algorithm whose exact operation count for input size $n$ is given by $T(n) = 5n^{2} + 100n$ primitive steps under the Random Access Machine (RAM) model. On the target Central Processing Unit (CPU), microbenchmarking shows that the average time per primitive step is $40$ nanoseconds under steady-state load.\n\nAssuming the entire $16$ millisecond budget is available to this algorithm stage, determine the largest integer input size $n$ for which the algorithm completes within the per-frame budget. Express your final answer as an integer with no units.", "solution": "The user wants to find the largest integer input size $n$ for an algorithm, such that its execution time does not exceed a given time budget.\n\n### Step 1: Extract Givens\nThe problem provides the following information:\n- Processing budget per frame, $\\tau_{budget} = 16$ milliseconds.\n- Operation count as a function of input size $n$: $T(n) = 5n^2 + 100n$.\n- Average time per primitive operation: $\\tau_{step} = 40$ nanoseconds.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, using standard concepts from algorithm analysis (operation count, time complexity) and computer architecture (processing time, nanoseconds). The problem is well-posed, as it seeks the largest integer $n$ satisfying a specific inequality, which has a unique solution because the time complexity function is monotonically increasing for $n > 0$. The language is objective and quantitative. No inconsistencies or missing information are present. The problem is therefore deemed valid.\n\n### Step 3: Formulate and Solve the Governing Inequality\nThe total execution time of the algorithm for an input of size $n$, denoted as $\\tau_{exec}(n)$, is the product of the number of operations $T(n)$ and the time per operation $\\tau_{step}$.\n$$\n\\tau_{exec}(n) = T(n) \\cdot \\tau_{step}\n$$\nThe problem requires that this execution time be within the per-frame budget:\n$$\n\\tau_{exec}(n) \\le \\tau_{budget}\n$$\nSubstituting the given expressions for $T(n)$, $\\tau_{step}$, and $\\tau_{budget}$:\n$$\n(5n^2 + 100n) \\cdot \\tau_{step} \\le \\tau_{budget}\n$$\nBefore solving, we must ensure all units are consistent. Let's convert all time units to seconds.\n- $\\tau_{budget} = 16 \\text{ ms} = 16 \\times 10^{-3} \\text{ s}$\n- $\\tau_{step} = 40 \\text{ ns} = 40 \\times 10^{-9} \\text{ s}$\n\nSubstituting these values into the inequality:\n$$\n(5n^2 + 100n) \\cdot (40 \\times 10^{-9}) \\le 16 \\times 10^{-3}\n$$\nTo solve for $n$, we first isolate the polynomial term:\n$$\n5n^2 + 100n \\le \\frac{16 \\times 10^{-3}}{40 \\times 10^{-9}}\n$$\n$$\n5n^2 + 100n \\le \\frac{16}{40} \\times 10^{(-3 - (-9))}\n$$\n$$\n5n^2 + 100n \\le 0.4 \\times 10^6\n$$\n$$\n5n^2 + 100n \\le 400000\n$$\nTo simplify the quadratic inequality, we can divide all terms by $5$:\n$$\nn^2 + 20n \\le 80000\n$$\nThis can be rewritten in standard quadratic form as:\n$$\nn^2 + 20n - 80000 \\le 0\n$$\nTo find the range of $n$ for which this inequality holds, we first find the roots of the corresponding equation $n^2 + 20n - 80000 = 0$ using the quadratic formula, $n = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$, with $a=1$, $b=20$, and $c=-80000$.\n$$\nn = \\frac{-20 \\pm \\sqrt{20^2 - 4(1)(-80000)}}{2(1)}\n$$\n$$\nn = \\frac{-20 \\pm \\sqrt{400 + 320000}}{2}\n$$\n$$\nn = \\frac{-20 \\pm \\sqrt{320400}}{2}\n$$\nThe value of the discriminant is calculated as $\\sqrt{320400} \\approx 566.038867$.\nThe two roots, $n_1$ and $n_2$, are:\n$$\nn_1 = \\frac{-20 + 566.038867}{2} = \\frac{546.038867}{2} \\approx 273.0194\n$$\n$$\nn_2 = \\frac{-20 - 566.038867}{2} = \\frac{-586.038867}{2} \\approx -293.0194\n$$\nThe quadratic function $f(n) = n^2 + 20n - 80000$ represents an upward-opening parabola. Therefore, the inequality $f(n) \\le 0$ is satisfied for values of $n$ between the two roots:\n$$\n-293.0194 \\le n \\le 273.0194\n$$\nSince the input size $n$ must be a non-negative integer, we have the constraint $n \\ge 0$. Combining this with the derived inequality, we get:\n$$\n0 \\le n \\le 273.0194\n$$\nThe largest integer value of $n$ that satisfies this condition is $273$.\n\nTo verify, we can compute the execution time for $n=273$:\n$T(273) = 5(273)^2 + 100(273) = 5(74529) + 27300 = 372645 + 27300 = 399945$ operations.\n$\\tau_{exec}(273) = 399945 \\times (40 \\times 10^{-9} \\text{ s}) = 15997800 \\times 10^{-9} \\text{ s} = 15.9978 \\text{ ms}$. This is less than or equal to the budget of $16 \\text{ ms}$.\n\nFor $n=274$:\n$T(274) = 5(274)^2 + 100(274) = 5(75076) + 27400 = 375380 + 27400 = 402780$ operations.\n$\\tau_{exec}(274) = 402780 \\times (40 \\times 10^{-9} \\text{ s}) = 16111200 \\times 10^{-9} \\text{ s} = 16.1112 \\text{ ms}$. This exceeds the budget of $16 \\text{ ms}$.\n\nThus, the largest integer input size is $273$.", "answer": "$$\\boxed{273}$$", "id": "3221840"}, {"introduction": "While Big-O notation is excellent for comparing the long-term scalability of algorithms, it often hides the influence of constants and lower-order terms that can dominate performance for small-to-medium input sizes. This problem explores the crucial concept of a \"crossover point\"â€”the specific input size at which an algorithm with better asymptotic complexity actually becomes more efficient than one with a seemingly worse complexity. Solving this requires moving beyond asymptotic analysis to work with complete runtime functions, providing a more nuanced view of algorithm selection. [@problem_id:3221856]", "problem": "A research team is comparing two implementations of the same task. One implementation uses a divide-and-conquer strategy with asymptotic growth on the order of Big-O notation class $O(n \\ln n)$, and the other uses a geometry-based batching strategy with asymptotic growth on the order of $O(n^{3/2})$. To make a decision for deployment, they model the full step-count functions, including constants and lower-order terms, as follows:\n- Divide-and-conquer implementation: $T_1(n) = 5\\,n \\ln n + 10\\bigl(1 - \\ln 2\\bigr)\\,n + 11$.\n- Batching implementation: $T_2(n) = 5\\,n^{3/2} + 11$.\n\nHere $n$ denotes input size and $\\ln$ denotes the natural logarithm.\n\nUsing the foundational definition that the exact crossover input size $n_0$ is the positive solution to $T_1(n) = T_2(n)$, determine the exact value of $n_0$ in closed form. Your final answer must be a single exact value. Do not approximate or round.", "solution": "The problem requires finding the exact positive crossover input size, denoted as $n_0$, where the step-count functions of two different algorithm implementations are equal.\n\nThe two step-count functions are given as:\n1. Divide-and-conquer implementation: $T_1(n) = 5\\,n \\ln n + 10\\bigl(1 - \\ln 2\\bigr)\\,n + 11$.\n2. Batching implementation: $T_2(n) = 5\\,n^{3/2} + 11$.\n\nThe crossover point $n_0$ is the positive solution to the equation $T_1(n) = T_2(n)$. We begin by setting up this equality:\n$$5\\,n \\ln n + 10\\bigl(1 - \\ln 2\\bigr)\\,n + 11 = 5\\,n^{3/2} + 11$$\n\nWe can simplify this equation by first subtracting $11$ from both sides:\n$$5\\,n \\ln n + 10\\bigl(1 - \\ln 2\\bigr)\\,n = 5\\,n^{3/2}$$\n\nSince $n$ represents the input size, it must be a positive quantity ($n > 0$). This allows us to divide the entire equation by $5n$ without risk of division by zero:\n$$\\frac{5\\,n \\ln n}{5n} + \\frac{10\\bigl(1 - \\ln 2\\bigr)\\,n}{5n} = \\frac{5\\,n^{3/2}}{5n}$$\n$$\\ln n + 2\\bigl(1 - \\ln 2\\bigr) = n^{3/2 - 1}$$\n$$\\ln n + 2 - 2 \\ln 2 = n^{1/2}$$\n\nTo facilitate solving this transcendental equation, we rearrange the terms to isolate the constant part:\n$$n^{1/2} - \\ln n = 2 - 2 \\ln 2$$\n\nUsing the property of logarithms that $k \\ln x = \\ln(x^k)$, we can write $2 \\ln 2 = \\ln(2^2) = \\ln 4$. The equation becomes:\n$$n^{1/2} - \\ln n = 2 - \\ln 4$$\n\nTo analyze this equation, let us define a function $f(n)$ for $n>0$:\n$$f(n) = n^{1/2} - \\ln n$$\n\nOur goal is to find the value of $n$ for which $f(n) = 2 - \\ln 4$. We can analyze the behavior of $f(n)$ using calculus to find its extrema. First, we compute the derivative of $f(n)$ with respect to $n$:\n$$f'(n) = \\frac{d}{dn} \\left( n^{1/2} - \\ln n \\right) = \\frac{1}{2}n^{-1/2} - \\frac{1}{n} = \\frac{1}{2\\sqrt{n}} - \\frac{1}{n}$$\n\nTo find critical points, we set the first derivative equal to zero:\n$$f'(n) = 0$$\n$$\\frac{1}{2\\sqrt{n}} - \\frac{1}{n} = 0$$\n$$\\frac{1}{2\\sqrt{n}} = \\frac{1}{n}$$\n\nAssuming $n \\neq 0$, we can cross-multiply to get:\n$$n = 2\\sqrt{n}$$\n\nTo solve for $n$, we square both sides of the equation. This is a valid step as $n > 0$ implies $\\sqrt{n}$ is real and positive.\n$$n^2 = (2\\sqrt{n})^2$$\n$$n^2 = 4n$$\n$$n^2 - 4n = 0$$\n$$n(n - 4) = 0$$\n\nThis yields two possible solutions: $n=0$ and $n=4$. Since the domain of our function $f(n)$ is $n>0$ (as $\\ln n$ is undefined for $n \\le 0$), the only critical point in the valid domain is $n=4$.\n\nTo determine the nature of this critical point, we employ the second derivative test. The second derivative of $f(n)$ is:\n$$f''(n) = \\frac{d}{dn} \\left( \\frac{1}{2}n^{-1/2} - n^{-1} \\right) = \\frac{1}{2}\\left(-\\frac{1}{2}\\right)n^{-3/2} - (-1)n^{-2} = -\\frac{1}{4}n^{-3/2} + n^{-2}$$\n\nNow, we evaluate $f''(n)$ at the critical point $n=4$:\n$$f''(4) = -\\frac{1}{4}(4)^{-3/2} + (4)^{-2} = -\\frac{1}{4(\\sqrt{4})^3} + \\frac{1}{16} = -\\frac{1}{4(2)^3} + \\frac{1}{16} = -\\frac{1}{4(8)} + \\frac{1}{16} = -\\frac{1}{32} + \\frac{2}{32} = \\frac{1}{32}$$\n\nSince $f''(4) = \\frac{1}{32} > 0$, the function $f(n)$ has a local minimum at $n=4$. As this is the only critical point in the domain $(0, \\infty)$, this local minimum is also the global minimum of the function.\n\nLet us evaluate the function $f(n)$ at this minimum point $n=4$:\n$$f(4) = (4)^{1/2} - \\ln 4 = 2 - \\ln 4$$\n\nWe observe that the minimum value of the function $f(n)$ is exactly the constant term in our equation $f(n) = 2 - \\ln 4$. This means that the equation is satisfied only at the point where the function reaches its global minimum.\n\nTherefore, the unique positive solution $n_0$ to the equation $T_1(n) = T_2(n)$ is the value of $n$ at which this minimum occurs.\n$$n_0 = 4$$", "answer": "$$\\boxed{4}$$", "id": "3221856"}, {"introduction": "Real-world inputs rarely conform perfectly to the assumptions of pure average-case or worst-case analysis. This advanced problem delves into the more realistic scenario of a \"mixture distribution,\" where an algorithm might face an adversarial input with some small probability. By analyzing a hash table's performance under this mixed model, you will practice using the law of total expectation to derive a precise cost function, developing a sophisticated understanding of how data structures behave under imperfect conditions. [@problem_id:3221921]", "problem": "Consider a hash table that uses separate chaining with linked lists, with $M$ buckets. A set of $n$ keys is stored; each key is a string of fixed length $L$ over a finite alphabet. The cost model is as follows: computing the hash of a string of length $L$ costs $c_h \\cdot L$ primitive steps, and each key comparison while traversing a chain costs $c_c$ primitive steps. Assume pointer dereferences and link traversals have negligible cost compared to hashing and comparisons.\n\nDefine the following mixture input distribution that models both typical and adversarial behaviors:\n\n- With probability $1 - \\alpha$, the hash function behaves as Uniform Random Hashing (URH), meaning that each key is independently assigned to a bucket chosen uniformly at random from $\\{0, 1, \\dots, M-1\\}$.\n- With probability $\\alpha$, an adversarial hash function $h_{\\mathrm{adv}}$ maps every key to the same bucket (take bucket $0$ without loss of generality): $h_{\\mathrm{adv}}(s) = 0$ for all strings $s$.\n\nAssume the table is sized so that $M = n$ (load factor $1$), and that a lookup query selects uniformly at random one of the stored keys and performs a successful search. Assume that within any chain, the relative order of keys is equally likely to be any permutation.\n\nSet the mixture parameter to $\\alpha = \\frac{1}{n}$. Starting from the fundamental definition of expected value and the bucket occupancy induced by URH, derive the exact expected number of primitive steps required for a successful lookup under this mixture distribution, expressed as a closed-form analytic function of $n$, $L$, $c_h$, and $c_c$.\n\nYour final answer must be the exact expression, fully simplified, with no rounding.", "solution": "The user wants me to solve a problem about the expected cost of a successful lookup in a hash table.\n\nHere's my plan:\n1.  **Validate the problem statement**: I will first meticulously check the problem for any logical, scientific, or structural flaws.\n2.  **Deconstruct the problem**: I will break down the calculation of the expected cost into its constituent parts, based on the provided mixture model.\n3.  **Solve for each part**: I will calculate the expected cost for both the Uniform Random Hashing (URH) scenario and the adversarial scenario.\n4.  **Combine and simplify**: I will combine the results using the law of total expectation and simplify the final expression.\n\n### Step 1: Extract Givens\n- Data structure: Hash table using separate chaining with linked lists.\n- Number of buckets (slots): $M$.\n- Number of keys: $n$.\n- Key structure: String of fixed length $L$.\n- Cost model:\n    - Cost of hashing a string of length $L$: $c_h \\cdot L$.\n    - Cost of one key comparison: $c_c$.\n- Hash function behavior (mixture model):\n    - With probability $1 - \\alpha$: The hash function is a Uniform Random Hash function (URH), where each key is mapped to a bucket in $\\{0, 1, \\dots, M-1\\}$ uniformly and independently at random.\n    - With probability $\\alpha$: The hash function is adversarial ($h_{\\mathrm{adv}}$), mapping all keys to bucket $0$.\n- Table sizing: $M = n$.\n- Query model: A successful search for a key chosen uniformly at random from the $n$ stored keys.\n- Intra-chain ordering: The relative order of keys within any given chain is equally likely to be any permutation.\n- Mixture parameter value: $\\alpha = \\frac{1}{n}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded (Critical)**: The problem is rooted in the standard theoretical framework of algorithm analysis, specifically for hashing. The concepts of separate chaining, uniform random hashing, adversarial models, and cost analysis are all standard and well-established in computer science. The problem is scientifically sound.\n- **Well-Posed**: The problem is clearly defined and provides all necessary information to derive a solution. The data structure, cost model, input distribution (via the mixture model), and query type are all specified unambiguously. A unique, meaningful solution exists.\n- **Objective (Critical)**: The problem is stated in precise, objective mathematical language, free from any subjectivity or ambiguity.\n\nAdditional checks:\n- **Incomplete or Contradictory Setup**: The problem is self-contained and free of contradictions. The constraint $M=n$ and the value of $\\alpha = 1/n$ are consistent with the setup.\n- **Unrealistic or Infeasible**: The scenario is a theoretical model but is not physically impossible or scientifically implausible within its defined context.\n- **Ill-Posed or Poorly Structured**: The structure is clear, leading to a single derivable quantity.\n- All other criteria for a valid problem are met.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. I will proceed to derive the solution.\n\n### Derivation of the Solution\n\nLet $C$ be the random variable representing the total number of primitive steps for a successful lookup. The total cost is the sum of the hashing cost, $C_{\\text{hash}}$, and the comparison cost, $C_{\\text{comp}}$.\n$$C = C_{\\text{hash}} + C_{\\text{comp}}$$\nThe cost to compute the hash of a key of length $L$ is given as $c_h L$. This cost is incurred for every lookup, regardless of which hash function (URH or adversarial) is active. Therefore, the expected hashing cost is constant:\n$$E[C_{\\text{hash}}] = c_h L$$\nThe total expected cost is:\n$$E[C] = E[C_{\\text{hash}}] + E[C_{\\text{comp}}] = c_h L + E[C_{\\text{comp}}]$$\nWe need to find the expected comparison cost, $E[C_{\\text{comp}}]$. We use the law of total expectation based on the mixture model for the hash function:\n$$E[C_{\\text{comp}}] = P(\\text{URH}) \\cdot E[C_{\\text{comp}} | \\text{URH}] + P(\\text{adv}) \\cdot E[C_{\\text{comp}} | \\text{adv}]$$\nGiven $P(\\text{URH}) = 1 - \\alpha$ and $P(\\text{adv}) = \\alpha$, this becomes:\n$$E[C_{\\text{comp}}] = (1 - \\alpha) E[C_{\\text{comp}} | \\text{URH}] + \\alpha E[C_{\\text{comp}} | \\text{adv}]$$\n\nWe will now calculate the expected comparison cost for each case separately.\n\n**1. Expected Comparison Cost under Uniform Random Hashing ($E[C_{\\text{comp}} | \\text{URH}]$)**\n\nFor a successful search, we are looking for one of the $n$ keys, chosen uniformly at random. Let $N_j$ be the number of keys that hash to bucket $j$. Since the keys in any chain are randomly permuted, the total number of comparisons required to find each of the $N_j$ keys in bucket $j$ exactly once is $c_c \\cdot (1 + 2 + \\dots + N_j) = c_c \\frac{N_j(N_j+1)}{2}$.\nThe total number of comparisons to find all $n$ keys in the table is the sum over all buckets: $\\sum_{j=0}^{M-1} c_c \\frac{N_j(N_j+1)}{2}$.\nSince the search query is for a uniformly random key, the expected number of comparisons is the expectation of this total cost divided by $n$:\n$$E[C_{\\text{comp}} | \\text{URH}] = E\\left[ \\frac{1}{n} \\sum_{j=0}^{M-1} c_c \\frac{N_j(N_j+1)}{2} \\right]$$\nBy linearity of expectation:\n$$E[C_{\\text{comp}} | \\text{URH}] = \\frac{c_c}{2n} \\sum_{j=0}^{M-1} E[N_j^2 + N_j] = \\frac{c_c}{2n} \\sum_{j=0}^{M-1} (E[N_j^2] + E[N_j])$$\nUnder URH, the number of keys $N_j$ landing in bucket $j$ follows a binomial distribution $N_j \\sim \\text{Bin}(n, p=\\frac{1}{M})$.\nThe expectation and variance are $E[N_j] = np = \\frac{n}{M}$ and $\\text{Var}(N_j) = np(1-p) = \\frac{n}{M}(1-\\frac{1}{M})$.\nFrom the relation $\\text{Var}(N_j) = E[N_j^2] - (E[N_j])^2$, we find $E[N_j^2]$:\n$$E[N_j^2] = \\text{Var}(N_j) + (E[N_j])^2 = \\frac{n}{M}\\left(1-\\frac{1}{M}\\right) + \\left(\\frac{n}{M}\\right)^2 = \\frac{n}{M} - \\frac{n}{M^2} + \\frac{n^2}{M^2}$$\nSubstituting these into the sum:\n$$ \\sum_{j=0}^{M-1} (E[N_j^2] + E[N_j]) = \\sum_{j=0}^{M-1} \\left( \\left(\\frac{n}{M} - \\frac{n}{M^2} + \\frac{n^2}{M^2}\\right) + \\frac{n}{M} \\right) $$\nSince this term is identical for all $M$ buckets:\n$$ = M \\left( \\frac{2n}{M} - \\frac{n}{M^2} + \\frac{n^2}{M^2} \\right) = 2n - \\frac{n}{M} + \\frac{n^2}{M} = 2n + \\frac{n(n-1)}{M} $$\nNow, we substitute this back into the expression for $E[C_{\\text{comp}} | \\text{URH}]$:\n$$E[C_{\\text{comp}} | \\text{URH}] = \\frac{c_c}{2n} \\left( 2n + \\frac{n(n-1)}{M} \\right) = c_c \\left( 1 + \\frac{n-1}{2M} \\right)$$\nUsing the problem's constraint $M=n$:\n$$E[C_{\\text{comp}} | \\text{URH}] = c_c \\left( 1 + \\frac{n-1}{2n} \\right) = c_c \\left( \\frac{2n + n - 1}{2n} \\right) = c_c \\left( \\frac{3n-1}{2n} \\right)$$\n\n**2. Expected Comparison Cost under Adversarial Hashing ($E[C_{\\text{comp}} | \\text{adv}]$)**\n\nIn the adversarial case, all $n$ keys are hashed to the same bucket (bucket $0$). This creates a single linked list of length $n$. The search is for a uniformly random key among these $n$ keys. Since the keys are in a random permutation, the position of the desired key is uniformly distributed in $\\{1, 2, \\dots, n\\}$.\nThe expected number of comparisons is $c_c$ times the expected position:\n$$E[C_{\\text{comp}} | \\text{adv}] = c_c \\cdot E[\\text{position}] = c_c \\cdot \\left(\\frac{1}{n} \\sum_{i=1}^n i\\right) = c_c \\cdot \\left(\\frac{1}{n} \\frac{n(n+1)}{2}\\right) = c_c \\frac{n+1}{2}$$\n\n**3. Combining the Results**\n\nNow we combine the two cases using the mixture parameter $\\alpha = \\frac{1}{n}$.\n$E[C_{\\text{comp}}] = \\left(1 - \\frac{1}{n}\\right) E[C_{\\text{comp}} | \\text{URH}] + \\frac{1}{n} E[C_{\\text{comp}} | \\text{adv}]$\n$E[C_{\\text{comp}}] = \\left(\\frac{n-1}{n}\\right) c_c \\left(\\frac{3n-1}{2n}\\right) + \\frac{1}{n} c_c \\left(\\frac{n+1}{2}\\right)$\n$E[C_{\\text{comp}}] = c_c \\left[ \\frac{(n-1)(3n-1)}{2n^2} + \\frac{n+1}{2n} \\right]$\nTo combine these terms, we use a common denominator of $2n^2$:\n$E[C_{\\text{comp}}] = c_c \\left[ \\frac{3n^2 - 3n - n + 1}{2n^2} + \\frac{n(n+1)}{2n^2} \\right]$\n$E[C_{\\text{comp}}] = c_c \\left[ \\frac{3n^2 - 4n + 1}{2n^2} + \\frac{n^2 + n}{2n^2} \\right]$\n$E[C_{\\text{comp}}] = c_c \\left[ \\frac{(3n^2 - 4n + 1) + (n^2 + n)}{2n^2} \\right]$\n$E[C_{\\text{comp}}] = c_c \\left[ \\frac{4n^2 - 3n + 1}{2n^2} \\right]$\nThis expression can be simplified by dividing each term in the numerator by the denominator:\n$E[C_{\\text{comp}}] = c_c \\left( \\frac{4n^2}{2n^2} - \\frac{3n}{2n^2} + \\frac{1}{2n^2} \\right) = c_c \\left( 2 - \\frac{3}{2n} + \\frac{1}{2n^2} \\right)$\n\n**4. Final Expression for Total Expected Cost**\n\nFinally, the total expected cost $E[C]$ is the sum of the expected hashing cost and the expected comparison cost:\n$$E[C] = c_h L + c_c \\left( 2 - \\frac{3}{2n} + \\frac{1}{2n^2} \\right)$$\nThis is the final, fully simplified, closed-form analytic function.", "answer": "$$\n\\boxed{c_h L + c_c \\left( 2 - \\frac{3}{2n} + \\frac{1}{2n^2} \\right)}\n$$", "id": "3221921"}]}