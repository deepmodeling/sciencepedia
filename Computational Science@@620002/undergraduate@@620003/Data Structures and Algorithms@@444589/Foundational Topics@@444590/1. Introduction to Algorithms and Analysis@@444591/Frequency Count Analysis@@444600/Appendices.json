{"hands_on_practices": [{"introduction": "We begin with a foundational exercise in frequency counting. This practice focuses on tracking the occurrences of specific items—in this case, vowels—within a string, which is a common task in text processing and data analysis [@problem_id:3236059]. You will implement a straightforward counting mechanism and apply a tie-breaking rule based on the first appearance of a character, a crucial skill for producing deterministic and well-defined results.", "problem": "You are given a finite character string $S$ over the standard American Standard Code for Information Interchange (ASCII) character set. Define the vowel set $V = \\{a,e,i,o,u\\}$. Consider the lowercase normalization function $\\mathrm{lower}(\\cdot)$ that maps uppercase letters to their lowercase counterparts and leaves other characters unchanged. For each vowel $v \\in V$, define the frequency function\n$$\nf_S(v) = \\left|\\{\\, i \\in \\{0,1,\\dots,|S|-1\\} \\mid \\mathrm{lower}(S[i]) = v \\,\\}\\right|.\n$$\nAlso define, for any vowel $v$ with $f_S(v) > 0$, the first-occurrence index\n$$\n\\iota_S(v) = \\min\\{\\, i \\in \\{0,1,\\dots,|S|-1\\} \\mid \\mathrm{lower}(S[i]) = v \\,\\}.\n$$\nYour task is to determine, for each provided test string $S$, a vowel $c \\in V$ that maximizes $f_S(c)$. If there are multiple vowels tying for the maximum frequency, break ties by selecting the vowel with the smallest $\\iota_S(\\cdot)$ (that is, the earliest occurrence in $S$ when scanned from left to right). If $f_S(v) = 0$ for all $v \\in V$ (that is, $S$ contains no vowels from $V$), then there is no such $c$.\n\nTo make the output numeric and unambiguous, define the function $\\mathrm{code}(x)$ to be the Unicode code point of the character $x$, which for vowels in $V$ coincides with its ASCII code. For each input $S$, your program must output either:\n- a two-integer list $[\\mathrm{code}(c), f_S(c)]$ if there exists at least one vowel in $S$, or\n- the two-integer list $[-1, 0]$ if $S$ contains no vowels from $V$.\n\nDesign an algorithm starting from the fundamental definitions of counting and sequence scanning to compute these values efficiently. You should analyze and justify the time and space complexity in terms of $|S|$.\n\nInput is not read from standard input. Instead, your program must internally use the following test suite of $S$ values, in this exact order:\n- $S =$ \"Data Structures and Algorithms\"\n- $S =$ \"eagle arena\"\n- $S =$ \"rhythms\"\n- $S =$ \"OOO!!!aaa111\"\n- $S =$ \"\" (the empty string)\n\nOutput specification:\n- Your program should produce a single line of output containing the results for all the above test cases aggregated into a single list. For $k$ test cases (here $k = 5$), output a list of length $k$ where each element is the two-integer list for the corresponding test case, in order. The printed line must be exactly a bracketed, comma-separated list of the $k$ results with no spaces, for example a list of the form [[xA,yA],[xB,yB],...], where each $x\\cdot$ and $y\\cdot$ is an integer as defined above.\n\nAssumptions and constraints:\n- Only the vowels in $V = \\{a,e,i,o,u\\}$ count as vowels for this problem; the letter $y$ is not considered a vowel.\n- The analysis is case-insensitive due to $\\mathrm{lower}(\\cdot)$.\n- All characters not in $V$ after normalization are ignored for counting.\n- The algorithm should be designed to run in time $\\mathcal{O}(|S|)$ with additional space $\\mathcal{O}(1)$ relative to $|S|$ (treating the size of $V$ as a constant).", "solution": "The problem statement has been rigorously evaluated and is determined to be valid. It is scientifically grounded in the domain of computer science and algorithm design, mathematically well-posed with clear definitions and constraints, and presented objectively. All necessary information is provided, the constraints are consistent and feasible, and the objectives are unambiguous, leading to a unique, verifiable solution for any given input string.\n\nThe task is to design an algorithm to find a specific vowel in a string $S$. The target vowel, $c$, must have the highest frequency of occurrence. In case of a tie in frequency, the vowel that appears earliest in the string (i.e., has the minimum first-occurrence index) is chosen. The algorithm must operate with a time complexity of $\\mathcal{O}(|S|)$ and additional space complexity of $\\mathcal{O}(1)$, where $|S|$ is the length of the string.\n\nOur approach is based on a two-phase process that adheres to these constraints: a data collection phase followed by an analysis phase. This design ensures that we process the input string in a single pass while keeping memory usage constant, independent of the string's length.\n\n**Phase 1: Data Collection via a Single Pass**\n\nThe core of an efficient solution is to gather all required information in a single scan of the input string $S$. The problem requires two pieces of data for each vowel $v$ in the predefined set $V = \\{a, e, i, o, u\\}$: its frequency, $f_S(v)$, and its first-occurrence index, $\\iota_S(v)$.\n\nTo store this information, we will use a fixed-size data structure, specifically a hash map (or dictionary), which we can call $D$. The keys of this map will be the vowels from the set $V$. The value associated with each vowel key $v$ will be a pair of numbers, $(count, index)$, representing the frequency and first-occurrence index, respectively. The size of this map is $|V| = 5$, which is a constant, thus satisfying the $\\mathcal{O}(1)$ space complexity requirement.\n\nThe algorithm for this phase is as follows:\n$1$. Initialize the map $D$. For each vowel $v \\in V$, create an entry $D[v]$ and initialize its associated pair to $(0, -1)$. The frequency count starts at $0$, and the index is set to a sentinel value of $-1$ to indicate that the vowel has not yet been encountered.\n$2$. Iterate through the string $S$ from the first character to the last, keeping track of the current index $i$, where $i$ ranges from $0$ to $|S|-1$.\n$3$. For each character $S[i]$ at index $i$:\n    a. Apply the lowercase normalization function: $c' = \\mathrm{lower}(S[i])$.\n    b. Check if $c'$ is a member of the vowel set $V$.\n    c. If $c'$ is a vowel, update its entry in the map $D$. Let $c' = v$.\n        i. Increment the frequency count: $D[v].count \\leftarrow D[v].count + 1$.\n        ii. If the first-occurrence index is still the sentinel value (i.e., $D[v].index = -1$), update it to the current index $i$: $D[v].index \\leftarrow i$. Since we are scanning from left to right, the first time we encounter a vowel guarantees that we are recording its minimum index.\n\nAfter this single pass is complete, the map $D$ will contain the final frequency $f_S(v)$ and first-occurrence index $\\iota_S(v)$ for every vowel $v \\in V$.\n\n**Phase 2: Analysis of Collected Data**\n\nWith the data collection complete, the next phase is to analyze the contents of the map $D$ to identify the vowel $c$ that satisfies the problem's criteria.\n\n$1$. Initialize variables to track the winning vowel and its properties. Let $c_{best}$ be the best vowel found so far, $f_{max}$ be the maximum frequency, and $\\iota_{min}$ be the minimum index for tie-breaking. Initialize $f_{max} = 0$ and $c_{best} = \\mathrm{null}$.\n\n$2$. Iterate through the vowels $v \\in V$ (e.g., in their alphabetical order: 'a', 'e', 'i', 'o', 'u'). For each vowel $v$, retrieve its statistics $(f_v, \\iota_v)$ from the map $D$, where $f_v = D[v].count$ and $\\iota_v = D[v].index$.\n\n$3$. We apply the selection logic. For each vowel $v$:\n    a. If its frequency $f_v$ is greater than the current maximum frequency $f_{max}$, then $v$ becomes the new best candidate. Update $f_{max} \\leftarrow f_v$, $\\iota_{min} \\leftarrow \\iota_v$, and $c_{best} \\leftarrow v$.\n    b. If its frequency $f_v$ is equal to the current maximum frequency $f_{max}$, we must apply the tie-breaking rule. The tie is broken by the smaller first-occurrence index. If $\\iota_v < \\iota_{min}$, then $v$ wins the tie and becomes the new best candidate. Update $\\iota_{min} \\leftarrow \\iota_v$ and $c_{best} \\leftarrow v$.\n\n$4$. After iterating through all $5$ vowels, the analysis is complete.\n    a. If $f_{max}$ is still $0$ (its initial value), it means no vowels were found in the string $S$. In this case, the specified output is the list $[-1, 0]$.\n    b. Otherwise, the winning vowel is $c_{best}$ and its frequency is $f_{max}$. The output is the list $[\\mathrm{code}(c_{best}), f_{max}]$.\n\n**Complexity Analysis**\n\n- **Time Complexity**: The first phase involves a single iteration over the string $S$, where each character operation (lowercase, hash map lookup, and update) takes constant time. This phase has a time complexity of $\\mathcal{O}(|S|)$. The second phase involves a single iteration over the fixed-size vowel set $V$. This takes $\\mathcal{O}(|V|)$ time, which is $\\mathcal{O}(1)$ since $|V| = 5$. Therefore, the total time complexity is dominated by the first phase, resulting in $\\mathcal{O}(|S|)$, which meets the problem requirement.\n\n- **Space Complexity**: The algorithm uses a map $D$ to store statistics for the $|V|$ vowels. As $|V|$ is a constant ($5$), the space required for this map is constant. No other data structures dependent on the size of $S$ are used. Thus, the additional space complexity is $\\mathcal{O}(1)$, also meeting the problem requirement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the vowel frequency analysis problem for a predefined suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        \"Data Structures and Algorithms\",\n        \"eagle arena\",\n        \"rhythms\",\n        \"OOO!!!aaa111\",\n        \"\"\n    ]\n    \n    # Define the vowel set as per the problem.\n    VOWELS = {'a', 'e', 'i', 'o', 'u'}\n    \n    results = []\n\n    for s in test_cases:\n        # Phase 1: Data Collection\n        # The data structure stores frequency and first-occurrence index for each vowel.\n        # Format: {vowel: {'freq': count, 'first_idx': index}}\n        stats = {v: {'freq': 0, 'first_idx': -1} for v in VOWELS}\n        \n        for i, char in enumerate(s):\n            # Normalize character to lowercase for case-insensitive comparison.\n            norm_char = char.lower()\n            \n            if norm_char in VOWELS:\n                # Increment frequency for the vowel.\n                stats[norm_char]['freq'] += 1\n                \n                # If this is the first time seeing the vowel, record its index.\n                if stats[norm_char]['first_idx'] == -1:\n                    stats[norm_char]['first_idx'] = i\n\n        # Phase 2: Analysis of Collected Data\n        best_vowel = None\n        max_freq = 0\n        # Initialize min_first_idx to a value larger than any possible index.\n        min_first_idx = float('inf')\n        \n        # Iterate through the vowels in a deterministic order (alphabetical).\n        # This helps in predictable behavior, though the logic handles any order.\n        for vowel in sorted(VOWELS):\n            v_freq = stats[vowel]['freq']\n            v_idx = stats[vowel]['first_idx']\n            \n            # Skip vowels that were not found in the string.\n            if v_freq == 0:\n                continue\n            \n            # Check for a new maximum frequency.\n            if v_freq > max_freq:\n                max_freq = v_freq\n                min_first_idx = v_idx\n                best_vowel = vowel\n            # If frequencies are tied, break ties with the first-occurrence index.\n            elif v_freq == max_freq:\n                if v_idx  min_first_idx:\n                    min_first_idx = v_idx\n                    best_vowel = vowel\n        \n        # Format the result based on whether a vowel was found.\n        if best_vowel is None:\n            # Case where the string has no vowels.\n            results.append([-1, 0])\n        else:\n            # Case where a best vowel was determined.\n            # ord() gives the Unicode code point (ASCII for these characters).\n            results.append([ord(best_vowel), max_freq])\n\n    # Final print statement in the exact required format.\n    # custom string formatting to avoid spaces inside the lists\n    formatted_results = [f\"[{x},{y}]\" for x, y in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3236059"}, {"introduction": "Moving beyond simple counting, this problem requires you to analyze an entire frequency distribution to find an element that satisfies a unique condition [@problem_id:3236040]. By identifying the 'anti-majority' element, you practice a common two-phase pattern in data analysis: first, gather frequency data for all items, and second, process this frequency data to uncover specific patterns or outliers. This exercise sharpens your ability to translate a logical definition into an efficient algorithmic search.", "problem": "You are given a finite sequence of integers $A = \\langle a_1, a_2, \\ldots, a_n \\rangle$. For an integer $x$, define the frequency function $f(x)$ on $A$ as the cardinality of the set $\\{ i \\mid a_i = x \\}$, that is, $f(x)$ counts how many times $x$ appears in $A$. An element $m$ is called an anti-majority element of $A$ if it satisfies $f(m) = 1$ and for every $y \\neq m$ with $y$ appearing in $A$, $f(y) \\geq 2$. The sequence may or may not possess an anti-majority element. Your task is to design an algorithm that, given $A$, returns $m$ if there exists exactly one element $m$ with $f(m) = 1$ and all other appearing elements have frequencies at least $2$, and returns $-1$ otherwise.\n\nThe fundamental base for this problem is the definition of a frequency function over a multiset and the canonical data structure operations for counting frequencies in an associative map (also called a dictionary). Your solution should start from these definitions and reason about how to compute, validate, and return the anti-majority element using frequency count analysis.\n\nFormally, the required behavior of your program for a given $A$ is:\n- If there exists exactly one element $m$ such that $f(m) = 1$ and for all $y \\in \\{ a_1, \\ldots, a_n \\}$ with $y \\neq m$ we have $f(y) \\geq 2$, output $m$.\n- Otherwise, output $-1$.\n\nNote that when $n = 1$, the sole element $a_1$ vacuously satisfies the condition $f(a_1) = 1$ and for all other elements (of which there are none) the frequency condition holds; therefore, $a_1$ is the anti-majority element.\n\nYour program must implement this logic and apply it to the following test suite of sequences:\n- Test $1$: $A = \\langle 4, 7, 7, 4, 5, 4, 4 \\rangle$.\n- Test $2$: $A = \\langle -1, -1, 0, 0, 0, 2 \\rangle$.\n- Test $3$: $A = \\langle 9, 9, 9, 8, 8 \\rangle$.\n- Test $4$: $A = \\langle 1, 2, 2, 3 \\rangle$.\n- Test $5$: $A = \\langle 42 \\rangle$.\n- Test $6$: $A = \\langle 5, 5, 7, 8, 8 \\rangle$.\n- Test $7$: $A = \\langle 1000000, 1000000, -1000000, -1000000, 123456789 \\rangle$.\n\nFor each test, your program must compute the corresponding result as an integer as specified above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, `[result1,result2,...]`.\n\nNo physical units or angles are involved. All outputs are integers.\n\nYour program must be a complete, runnable program that performs the computations for the given test suite without requiring any user input and prints only the final aggregated line as described.", "solution": "The problem statement has been analyzed and validated against the specified criteria.\n\n### Step 1: Extracted Givens\n- **Input Sequence:** A finite sequence of integers $A = \\langle a_1, a_2, \\ldots, a_n \\rangle$.\n- **Frequency Function:** $f(x)$ is defined as the number of occurrences of an integer $x$ in the sequence $A$. Formally, $f(x) = |\\{ i \\mid a_i = x \\}|$.\n- **Anti-Majority Element Definition:** An element $m$ is an anti-majority element if $f(m) = 1$ and for every other element $y$ that appears in $A$ ($y \\neq m$), the condition $f(y) \\geq 2$ holds.\n- **Task:** The algorithm must return the element $m$ if there is exactly one such anti-majority element. Otherwise, it must return $-1$.\n- **Special Case:** For a sequence of length $n=1$, e.g., $A = \\langle a_1 \\rangle$, the element $a_1$ is the anti-majority element.\n- **Test Suite:** The algorithm must be applied to a specific set of $7$ test sequences.\n- **Output:** A single line of text containing a comma-separated list of integer results enclosed in square brackets.\n\n### Step 2: Validation\nThe problem is well-defined, mathematically sound, and objective. It is grounded in the fundamental concepts of combinatorics (counting) and computer science (data structures and algorithms), specifically frequency count analysis. The definitions are precise, and the requirements are unambiguous. The problem is self-contained and does not contain any scientific inaccuracies, contradictions, or ill-posed structures.\n\n### Step 3: Verdict\nThe problem is **valid**. A solution will be developed.\n\n### Principle-Based Algorithmic Design\n\nThe problem requires determining the frequency of each element in a sequence and then applying a specific set of conditions. This is a classic frequency counting problem. The foundational principle for solving this efficiently is the use of an associative map (also known as a dictionary or hash map) to store the frequency of each unique element.\n\n**Step 1: Frequency Analysis**\nFirst, we must compute the frequency function $f(x)$ for all unique elements $x$ in the input sequence $A = \\langle a_1, a_2, \\ldots, a_n \\rangle$. An associative map, let's call it `freq_map`, is the ideal data structure for this task. We iterate through the sequence $A$ one element at a time. For each element $a_i$, we update its count in `freq_map`. If $a_i$ is not yet a key in the map, it is added with a count of $1$. If it already exists, its count is incremented. This process takes a total of $O(n)$ time on average, where $n$ is the length of the sequence, because each of the $n$ hash map operations (insertion or update) takes $O(1)$ average time. The space complexity required is $O(k)$, where $k$ is the number of unique elements in $A$, to store the map.\n\n**Step 2: Identification of the Anti-Majority Element**\nThe core of the task is to interpret the condition for the existence of an anti-majority element. The condition is: \"there exists exactly one element $m$ such that $f(m) = 1$ and for all $y \\in \\{ a_1, \\ldots, a_n \\}$ with $y \\neq m$ we have $f(y) \\geq 2$\".\n\nLet's analyze this condition. Let $S$ be the set of all unique elements present in the sequence $A$. The condition can be stated formally as: there exists a unique element $m \\in S$ such that $f(m) = 1$, and for every other element $y \\in S \\setminus \\{m\\}$, it holds that $f(y) \\geq 2$.\n\nThis condition can be simplified. The frequencies $f(y)$ for any element $y \\in S$ must be positive integers. If we find that there is exactly one element $m$ in $S$ with frequency $f(m)=1$, it logically follows that every other element $y \\in S \\setminus \\{m\\}$ must have a frequency that is a positive integer not equal to $1$. Therefore, for all such $y$, their frequencies must be $f(y) \\geq 2$.\n\nConsequently, the two parts of the condition are linked, and the problem reduces to finding the number of elements with a frequency of exactly $1$.\n- If zero elements have a frequency of $1$, the condition fails. The output must be $-1$.\n- If more than one element has a frequency of $1$, the \"exactly one\" part of the condition fails. The output must be $-1$.\n- If exactly one element has a frequency of $1$, that element is the anti-majority element, and it should be returned.\n\n**Step 3: Final Algorithm**\nBased on the analysis, a complete and efficient algorithm is as follows:\n1. Construct the frequency map from the input sequence $A$.\n2. Create a list of `candidates` for the anti-majority element by iterating through the frequency map and collecting all elements whose frequency is exactly $1$.\n3. Check the number of elements in the `candidates` list.\n   - If the list contains exactly one element, this element is the anti-majority element. Return it.\n   - If the list is empty or contains more than one element, no unique anti-majority element exists. Return $-1$.\n\n**Example Walkthrough (Test Case 1):**\n- Input: $A = \\langle 4, 7, 7, 4, 5, 4, 4 \\rangle$.\n- Step 1: Construct frequency map. `freq_map` = $\\{4: 4, 7: 2, 5: 1\\}$.\n- Step 2: Identify candidates with frequency $1$. The only such element is $5$, since $f(5)=1$. So, `candidates` = $[5]$.\n- Step 3: Check candidate count. The list `candidates` has one element. Thus, $5$ is the anti-majority element. The result is $5$.\n\n**Example Walkthrough (Test Case 4):**\n- Input: $A = \\langle 1, 2, 2, 3 \\rangle$.\n- Step 1: Construct frequency map. `freq_map` = $\\{1: 1, 2: 2, 3: 1\\}$.\n- Step 2: Identify candidates with frequency $1$. Here, $f(1)=1$ and $f(3)=1$. So, `candidates` = $[1, 3]$.\n- Step 3: Check candidate count. The list `candidates` has two elements. Since this is not exactly one, the condition is not met. The result is $-1$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_anti_majority(A: list[int]) - int:\n    \"\"\"\n    Finds the anti-majority element in a sequence A.\n\n    An anti-majority element m is an element that appears exactly once (f(m) = 1),\n    while all other distinct elements in the sequence appear at least twice.\n    The function returns m if a unique anti-majority element exists, and -1 otherwise.\n\n    Args:\n        A: A list of integers.\n\n    Returns:\n        The unique anti-majority element, or -1 if none exists.\n    \"\"\"\n    # If the input sequence is empty, no elements exist, so no anti-majority element can be found.\n    # The problem implies n >= 1, but this handles the edge case.\n    if not A:\n        return -1\n\n    # Use numpy.unique to efficiently get unique elements and their corresponding counts.\n    # This forms the basis of our frequency count analysis.\n    input_array = np.array(A, dtype=np.int64)\n    unique_elements, counts = np.unique(input_array, return_counts=True)\n\n    # The condition for an anti-majority element implies we are looking for an element\n    # with a frequency of exactly 1. All other elements must have frequencies >= 2.\n    # This is equivalent to finding if there is exactly one element with a count of 1.\n    \n    # We use boolean array indexing to filter for elements where the count is 1.\n    candidates = unique_elements[counts == 1]\n\n    # According to the problem definition, we must return the element if there is\n    # 'exactly one' such element.\n    if len(candidates) == 1:\n        # The result must be a standard Python int, not a numpy integer type.\n        return int(candidates[0])\n    else:\n        # If there are zero or more than one elements with a count of 1,\n        # the condition is not met.\n        return -1\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the find_anti_majority function on each case,\n    and prints the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [4, 7, 7, 4, 5, 4, 4],                             # Test 1\n        [-1, -1, 0, 0, 0, 2],                               # Test 2\n        [9, 9, 9, 8, 8],                                    # Test 3\n        [1, 2, 2, 3],                                       # Test 4\n        [42],                                               # Test 5\n        [5, 5, 7, 8, 8],                                    # Test 6\n        [1000000, 1000000, -1000000, -1000000, 123456789],   # Test 7\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_anti_majority(case)\n        results.append(result)\n\n    # Final print statement in the exact required format: [result1,result2,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3236040"}, {"introduction": "This advanced practice demonstrates how frequency analysis can be powerfully combined with knowledge of data structures. The challenge is to find the most frequent element (the mode) in an array that is sorted but has been rotated [@problem_id:3236126]. The key to an elegant and efficient solution lies in understanding how the rotation affects runs of identical elements, especially how a single block of elements might be split across the array's boundaries.", "problem": "You are given a finite sequence of integers $A$ of length $n \\geq 1$. The sequence $A$ is obtained by rotating a non-decreasingly sorted array $S$ by an unknown amount. Formally, there exists an integer $k$ with $0 \\leq k  n$ such that $A[i] = S[(i + k) \\bmod n]$ for all indices $i$ with $0 \\leq i  n$. For any integer $x$, define the frequency count $f_A(x)$ as the number of indices $i$ with $A[i] = x$. Your task is to design and implement an algorithm that finds a value $x^\\star$ in $A$ that maximizes $f_A(x)$ and returns both $x^\\star$ and $f_A(x^\\star)$, with the following deterministic tie-breaking rule: if multiple distinct values achieve the same maximum frequency, return the smallest such value. The algorithm must be derived from fundamental properties of non-decreasing sequences and the rotation operation, and it must run in worst-case time $\\mathcal{O}(n)$ using a single pass over $A$ and additional space $\\mathcal{O}(d)$ where $d$ is the number of distinct values in $A$. The output must be reported without any units, as the problem is purely mathematical.\n\nFundamental base to use in your derivation:\n- A non-decreasing sequence has the property that equal values appear in contiguous blocks, that is, there exist disjoint index intervals partitioning $[0, n-1]$ such that within each interval the sequence value is constant and across intervals it does not decrease.\n- Rotation by $k$ positions preserves contiguity of each constant block except possibly one block that may be split across the boundary, creating two runs that together form the original block. The only value that can appear both at the beginning and at the end of $A$ is the value whose block was split by the rotation, and therefore wrap-around counting must merge those two runs (for $n>1$).\n\nDesign constraints:\n- You must count frequencies by analyzing runs of equal values in a single left-to-right pass over $A$ and, if a block is split due to rotation, correctly merge the counts of the first and last runs for that value.\n- You must ensure that the worst-case time complexity is $\\mathcal{O}(n)$ and additional space complexity is $\\mathcal{O}(d)$.\n\nTest suite:\nUse the following six test cases, which cover typical behavior, boundary conditions, and edge cases. In each case the array $A_i$ is non-decreasingly sorted and then rotated, and duplicates may be present.\n- $A_1 = \\langle 4, 4, 5, 5, 5, 5, 1, 1, 2, 2, 2, 3 \\rangle$ (typical case where the mode is a middle block that does not wrap).\n- $A_2 = \\langle 0, 0, 1, 1, 2, 3, 3, 0 \\rangle$ (case where the mode’s block wraps and must be merged).\n- $A_3 = \\langle 2, 2, 3, 3, 1, 1 \\rangle$ (tie case among several values; the smallest value must be selected).\n- $A_4 = \\langle 7 \\rangle$ (single-element boundary case).\n- $A_5 = \\langle 5, 5, 5, 5, 5 \\rangle$ (all elements equal).\n- $A_6 = \\langle 3, 1, 1, 1, 2, 2, 2, 2, 3 \\rangle$ (wrap-around exists but the mode is a non-wrapping block elsewhere).\n\nRequired final output format:\nYour program should produce a single line of output containing the results for $A_1$ through $A_6$ as a comma-separated list enclosed in square brackets, where each result is itself a two-element list $[x^\\star, f_A(x^\\star)]$ for the corresponding test case. For example, the printed output must have the form $[[x_1^\\star, f_{A_1}(x_1^\\star)], [x_2^\\star, f_{A_2}(x_2^\\star)], \\ldots, [x_6^\\star, f_{A_6}(x_6^\\star)]]$, with no additional text before or after the list.", "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- **Input Sequence:** A finite sequence of integers $A$ of length $n \\geq 1$.\n- **Sequence Property:** $A$ is a rotation of a non-decreasingly sorted array $S$.\n- **Formal Definition of Rotation:** There exists an integer $k$ with $0 \\leq k  n$ such that $A[i] = S[(i + k) \\bmod n]$ for all indices $i$ with $0 \\leq i  n$.\n- **Frequency Count Definition:** For any integer $x$, a function $f_A(x)$ gives the number of indices $i$ where $A[i] = x$.\n- **Objective:** Find a value $x^\\star$ in $A$ that maximizes $f_A(x)$ and return both $x^\\star$ and its frequency $f_A(x^\\star)$.\n- **Tie-Breaking Rule:** If multiple distinct values achieve the same maximum frequency, the smallest such value must be returned.\n- **Algorithmic Constraints:**\n    - The algorithm must be derived from the specified fundamental properties.\n    - Time Complexity: Worst-case $\\mathcal{O}(n)$.\n    - Space Complexity: Additional space of $\\mathcal{O}(d)$, where $d$ is the count of distinct values in $A$.\n    - Pass Constraint: Must use a single left-to-right pass over $A$.\n- **Fundamental Base Principles:**\n    1.  In a non-decreasing sequence, identical values form contiguous blocks.\n    2.  Rotation preserves the contiguity of these blocks, except for at most one block which may be split. This split block would appear as a run at the beginning of $A$ and another run at the end of $A$. The value of this split block is the only one that can simultaneously be at $A[0]$ and $A[n-1]$ (for $n>1$).\n- **Test Suite:**\n    - $A_1 = \\langle 4, 4, 5, 5, 5, 5, 1, 1, 2, 2, 2, 3 \\rangle$\n    - $A_2 = \\langle 0, 0, 1, 1, 2, 3, 3, 0 \\rangle$\n    - $A_3 = \\langle 2, 2, 3, 3, 1, 1 \\rangle$\n    - $A_4 = \\langle 7 \\rangle$\n    - $A_5 = \\langle 5, 5, 5, 5, 5 \\rangle$\n    - $A_6 = \\langle 3, 1, 1, 1, 2, 2, 2, 2, 3 \\rangle$\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria.\n- **Scientifically Grounded:** The problem is rooted in the well-defined mathematical and computer science concepts of arrays, sorting, modular arithmetic, and frequency analysis. It is entirely formal and factual. This criterion is met.\n- **Well-Posed:** The problem provides a clear objective (find the mode), a unique existence of a solution is guaranteed for a finite set, and a deterministic tie-breaking rule ensures the solution is unique. The constraints on algorithmic complexity are precise. This criterion is met.\n- **Objective:** The language is formal and unambiguous. No subjective claims are made. This criterion is met.\n\nThe problem does not exhibit any of the specified flaws. It is not scientifically unsound, is formalizable, is complete, is not unrealistic, is well-posed, and is not trivial due to the specific constraints regarding the single pass and the wrap-around condition.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be developed in accordance with the specified constraints.\n\n### Solution Derivation\nThe objective is to find the mode (the value with the highest frequency, $x^\\star$) of a rotated sorted integer sequence $A$ of length $n$. The key constraints are a single pass over $A$, a time complexity of $\\mathcal{O}(n)$, and an auxiliary space complexity of $\\mathcal{O}(d)$, where $d$ is the number of distinct elements.\n\nThe fundamental principle provided is that in the original non-decreasing sequence $S$, all identical values are contiguous. When $S$ is rotated to form $A$, at most one block of identical values can be split. Such a split would result in one part of the block appearing as a run at the beginning of $A$ and the other part as a run at the end of $A$. All other blocks of identical values remain as single contiguous runs within $A$.\n\nA robust algorithm can be designed by using a hash map (a dictionary in Python) to store the frequency of each distinct value. This approach elegantly handles the potentially split block.\n\nThe algorithm proceeds as follows:\n1.  Initialize an empty hash map, which we will call `freq_map`, to store pairs of (value, frequency).\n2.  Perform a single pass over the input array $A$ from left to right (from index $i=0$ to $n-1$). This pass is structured to identify and process runs of identical consecutive elements.\n3.  We use an index $i$ to traverse the array. At each position $i$, we identify the end of the current run of a value $v = A[i]$. Let the run extend from index $i$ to $j$. The length of this run is $c = j - i + 1$.\n4.  For each run of value $v$ and calculated length $c$, we update its frequency in `freq_map`. We update the count for $v$ by adding $c$ to its existing count in the map: `freq_map[v] = freq_map.get(v, 0) + c`. This operation correctly accumulates counts. If a value appears in only one run (the non-split case), its count is added once. If a value's block is split, it appears in two separate runs (at the start and end of $A$). This logic ensures that the counts from both runs are summed together, yielding the correct total frequency.\n5.  After the pass through $A$ is complete, `freq_map` contains the final frequency for every distinct value in $A$. The number of entries in `freq_map` is $d$.\n6.  The final step is to determine the mode $x^\\star$ from `freq_map`. We iterate through the $(v, c)$ pairs in the map. We maintain two variables: `max_freq` for the highest frequency found so far, and `mode_val` for the corresponding value.\n    - Initialize `max_freq = -\\infty$` and `mode_val = \\infty$.\n    - For each value $v$ with frequency $c$ in the map:\n        - If $c > \\text{max\\_freq}$, we have found a new mode. We update `max_freq = c` and `mode_val = v`.\n        - If $c == \\text{max\\_freq}$, we apply the tie-breaking rule. We update `mode_val = \\min(\\text{mode\\_val}, v)`.\n7.  After iterating through all entries in `freq_map`, `mode_val` will hold the value $x^\\star$ and `max_freq` will hold its frequency $f_A(x^\\star)$.\n\nLet us trace with test case $A_2 = \\langle 0, 0, 1, 1, 2, 3, 3, 0 \\rangle$:\n- Pass 1: Run of $0$ at indices $0,1$. Length $2$. `freq_map` becomes $\\{0: 2\\}$.\n- Pass 2: Run of $1$ at indices $2,3$. Length $2$. `freq_map` becomes $\\{0: 2, 1: 2\\}$.\n- Pass 3: Run of $2$ at index $4$. Length $1$. `freq_map` becomes $\\{0: 2, 1: 2, 2: 1\\}$.\n- Pass 4: Run of $3$ at indices $5,6$. Length $2$. `freq_map` becomes $\\{0: 2, 1: 2, 2: 1, 3: 2\\}$.\n- Pass 5: Run of $0$ at index $7$. Length $1$. The map is updated: `freq_map[0] = freq_map.get(0, 2) + 1 = 3$. The map is now $\\{0: 3, 1: 2, 2: 1, 3: 2\\}$.\n- The single pass over $A$ is complete.\n- Now, find the mode from `freq_map`: The maximum frequency is $3$, which corresponds to the value $0$. The result is $[0, 3]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_mode_in_rotated_sorted_array(A):\n    \"\"\"\n    Finds the mode (most frequent element) in a rotated sorted array.\n\n    The algorithm performs a single pass to identify runs of identical elements\n    and uses a dictionary to store frequencies. This correctly handles the case\n    of a single value's block being split by the rotation. After populating\n    the frequency map, it finds the mode according to the problem's\n    tie-breaking rule.\n\n    Args:\n        A (np.ndarray): A 1D numpy array of integers, representing the\n                        rotated non-decreasingly sorted sequence.\n\n    Returns:\n        list: A two-element list [x_star, f_A(x_star)], where x_star is the\n              mode and f_A(x_star) is its frequency.\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        return None  # Or handle as per an extended specification for empty arrays.\n    \n    # Per the problem statement, n >= 1\n    if n == 1:\n        return [A[0], 1]\n\n    freq_map = {}\n    \n    # Single pass over the array A to count runs and populate the frequency map.\n    # The `while` loop structure naturally processes the array run by run.\n    i = 0\n    while i  n:\n        current_val = A[i]\n        run_start_index = i\n        \n        # Find the end of the current run of identical elements\n        while i + 1  n and A[i + 1] == current_val:\n            i += 1\n        \n        run_end_index = i\n        count = run_end_index - run_start_index + 1\n        \n        # Accumulate the count for the current value. This correctly merges\n        # the counts if a value's block was split into two runs.\n        freq_map[current_val] = freq_map.get(current_val, 0) + count\n        \n        i += 1\n\n    # After the single pass, find the mode from the populated frequency map.\n    # Initialize with a valid entry to simplify comparisons.\n    # Note: dicts in Python 3.7+ preserve insertion order, but we should not rely on it.\n    # A robust way to apply the tie-breaker is to iterate through the map\n    # and update the mode based on the rules.\n    \n    mode_val = -1\n    max_freq = -1\n\n    # To ensure the tie-breaking rule (smallest value) is met deterministically,\n    # it's best to iterate through the values in sorted order.\n    # Alternatively, a two-pass approach on the dictionary works just as well\n    # with O(d) complexity and is simpler to read.\n    # First pass to find the max frequency.\n    if freq_map:\n        max_freq = max(freq_map.values())\n        \n        # Second pass to find the smallest key with that frequency.\n        # Initialize mode_val to a value larger than any possible candidate.\n        mode_val = float('inf')\n        for val, freq in freq_map.items():\n            if freq == max_freq:\n                if val  mode_val:\n                    mode_val = val\n\n    return [mode_val, max_freq]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the find_mode_in_rotated_sorted_array function.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # A1: typical case where the mode is a middle block that does not wrap.\n        np.array([4, 4, 5, 5, 5, 5, 1, 1, 2, 2, 2, 3]),\n        # A2: case where the mode’s block wraps and must be merged.\n        np.array([0, 0, 1, 1, 2, 3, 3, 0]),\n        # A3: tie case among several values; the smallest value must be selected.\n        np.array([2, 2, 3, 3, 1, 1]),\n        # A4: single-element boundary case.\n        np.array([7]),\n        # A5: all elements equal.\n        np.array([5, 5, 5, 5, 5]),\n        # A6: wrap-around exists but the mode is a non-wrapping block elsewhere.\n        np.array([3, 1, 1, 1, 2, 2, 2, 2, 3]),\n    ]\n\n    results = []\n    for A in test_cases:\n        result = find_mode_in_rotated_sorted_array(A)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Using str() on a list of lists produces the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3236126"}]}