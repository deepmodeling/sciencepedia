{"hands_on_practices": [{"introduction": "Understanding space complexity begins with distinguishing between the memory occupied by the input and the *auxiliary* memory used by the algorithm. This first practice sharpens that distinction by challenging you to analyze a classic in-place algorithm. You will calculate the precise number of auxiliary bits required for an in-place matrix transposition, focusing on the space needed for temporary variables and index pointers, which are fundamental components of an algorithm's memory overhead [@problem_id:3272578].", "problem": "Consider an array-based representation of a non-square matrix of size $M \\times N$ ($M, N \\in \\mathbb{N}$, $M \\neq N$) stored in row-major order in contiguous memory. Each matrix entry occupies exactly $w$ bits. You are given an in-place transposition algorithm that, without allocating any $M \\times N$ auxiliary matrix, performs the transpose by decomposing the permutation induced by the index mapping into cycles and rotating each cycle using a single temporary variable to hold one matrix entry during moves.\n\nAssume the following computational model and constraints:\n- Space complexity is defined as the maximum number of bits of auxiliary memory (that is, any memory not part of the input array itself) used at any point during execution, expressed as a function of $M$, $N$, and $w$.\n- The algorithm uses only a constant number of scalar variables in addition to the input array:\n  1. One temporary variable to hold a single matrix entry during cycle rotation.\n  2. A constant number of index variables to track the cycle leader and the current and next positions while traversing a cycle.\n- Each index variable must be able to address any position in the array, that is, any integer in $\\{0, 1, \\dots, MN - 1\\}$, and is stored in binary using exactly the minimum number of bits necessary to represent any such index.\n- Ignore fixed, implementation-dependent overhead (such as return addresses or constant-sized frame pointers), and do not count the $MN \\cdot w$ bits of the input array itself in the space complexity.\n\nUsing only the fundamental definitions of space complexity and binary representation size for integers, derive the exact worst-case number of auxiliary bits used by this algorithm at any time, expressed in closed form in terms of $M$, $N$, and $w$. Your final answer must be a single analytic expression. Do not round.", "solution": "The problem statement is subjected to validation prior to attempting a solution.\n\n### Step 1: Extract Givens\n- **Matrix properties**: An $M \\times N$ matrix, where $M, N \\in \\mathbb{N}$ and $M \\neq N$.\n- **Storage**: Array-based, row-major order, contiguous memory.\n- **Element size**: Each entry occupies $w$ bits.\n- **Algorithm**: In-place transposition via cycle decomposition and rotation. No auxiliary $M \\times N$ matrix is allocated.\n- **Auxiliary memory definition**: The space complexity is the maximum number of bits of auxiliary memory used, which is any memory external to the $M N \\cdot w$ bits of the input array.\n- **Auxiliary memory components**:\n    1. One temporary variable for a single matrix entry.\n    2. A constant number of index variables.\n- **Index variable properties**:\n    1. Roles: Tracking the cycle leader, current position, and next position.\n    2. Range: Must be able to represent any integer in $\\{0, 1, \\dots, MN - 1\\}$.\n    3. Size: Stored using the minimum number of bits necessary for its range.\n- **Exclusions**: Fixed, implementation-dependent overhead (e.g., return addresses, frame pointers) and the input array itself.\n- **Objective**: Derive the exact worst-case number of auxiliary bits used, expressed as a closed-form function of $M$, $N$, and $w$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is analyzed against the validation criteria.\n\n- **Scientific Grounding**: The problem is well-grounded in the field of computer science, specifically algorithm analysis. The concepts of space complexity, in-place algorithms, matrix transposition, cycle decomposition, and binary representation of integers are fundamental and well-established.\n- **Well-Posedness**: The problem is well-posed. It provides a clear definition of what constitutes auxiliary space and gives sufficient constraints to calculate its size. The objective is to find a unique analytical expression based on the given parameters. The phrase \"a constant number of index variables\" is specified by the enumerated roles (\"cycle leader,\" \"current,\" and \"next positions\"), which implies a specific, small integer constant, conventionally 3 for this type of algorithm. This makes the problem solvable for an \"exact\" expression.\n- **Objectivity**: The language is precise, formal, and free of any subjective or ambiguous terminology.\n\nThe problem does not exhibit any flaws such as scientific unsoundness, incompleteness, contradiction, or vagueness. It presents a standard, formal problem in algorithm analysis.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be derived as follows.\n\nThe total auxiliary space complexity, denoted by $S(M, N, w)$, is the sum of the space required for all auxiliary variables used by the algorithm. Based on the problem statement, this memory is composed of two distinct parts: the space for a single temporary variable to hold a matrix entry, and the space for a constant number of index variables.\n\nLet $S_{temp}$ be the space for the temporary variable and $S_{index}$ be the total space for the index variables. The total auxiliary space is:\n$$ S(M, N, w) = S_{temp} + S_{index} $$\n\nWe will now derive the size of each component.\n\nFirst, we determine $S_{temp}$. The problem states the algorithm uses \"one temporary variable to hold a single matrix entry\". It is also given that \"each matrix entry occupies exactly $w$ bits\". Therefore, the amount of memory required for this temporary variable is precisely $w$ bits.\n$$ S_{temp} = w $$\n\nNext, we determine $S_{index}$. This requires calculating two quantities: the number of index variables used and the number of bits required to store each one.\nThe problem states the algorithm uses \"a constant number of index variables to track the cycle leader and the current and next positions\". A standard implementation of a cycle-following algorithm requires a minimum of three such variables:\n1. An index to store the starting position of the current cycle (the \"cycle leader\"), which is needed to detect when the cycle is complete.\n2. An index to keep track of the \"current\" position whose element is to be replaced.\n3. An index to store the \"next\" position from which to fetch the new element.\nThus, the constant number of index variables is $3$.\n\nNow, we must determine the size of each index variable. The problem specifies that \"each index variable must be able to address any position in the array, that is, any integer in $\\{0, 1, \\dots, MN - 1\\}$\". The total number of elements in the matrix is $MN$. To represent an integer in the range $[0, MN-1]$, we need to be able to represent $MN$ distinct values. The minimum number of bits, $b$, required to represent $K$ distinct values is given by the ceiling of the base-2 logarithm of $K$.\n$$ b = \\lceil \\log_2(K) \\rceil $$\nIn our case, $K = MN$. Therefore, the number of bits required for a single index variable, $b_{idx}$, is:\n$$ b_{idx} = \\lceil \\log_2(MN) \\rceil $$\nThe problem further specifies that each index is \"stored in binary using exactly the minimum number of bits necessary\", which confirms this calculation.\n\nThe total space for the index variables, $S_{index}$, is the number of index variables ($3$) multiplied by the number of bits per variable ($b_{idx}$).\n$$ S_{index} = 3 \\cdot b_{idx} = 3 \\lceil \\log_2(MN) \\rceil $$\n\nFinally, we combine the space for the temporary variable and the index variables to obtain the total auxiliary space complexity. The use of this memory is concurrent, so the maximum space used at any point is the sum of the sizes of all allocated auxiliary variables.\n$$ S(M, N, w) = S_{temp} + S_{index} = w + 3 \\lceil \\log_2(MN) \\rceil $$\nThis expression represents the exact worst-case number of auxiliary bits used by the algorithm, as defined by the problem statement. The space usage does not fluctuate with the input data's values, only with its dimensions, so the worst-case, average-case, and best-case space complexities are all identical.", "answer": "$$\\boxed{w + 3 \\lceil \\log_2(MN) \\rceil}$$", "id": "3272578"}, {"introduction": "While analyzing static algorithms is crucial, many real-world applications rely on dynamic data structures that grow and shrink. This practice moves from analyzing auxiliary space to calculating the total memory footprint of a dynamic structure, accounting for its specific resizing policy. By modeling an auction system's order book, you will derive an exact formula for the memory usage of an array-based heap, considering factors like metadata, initial capacity, and a power-of-two growth strategy [@problem_id:3272546].", "problem": "An electronic auction matching engine maintains a limit order book using two Binary Heaps (BH), one heap for buy orders and one heap for sell orders. Each BH is implemented as a contiguous dynamic array that stores order records inline. The dynamic array has the following resizing policy: it starts with an initial capacity of $16$ elements and, whenever full, doubles its capacity. At any moment, the capacity is a power of two and at least the current number of elements in the heap. The dynamic array metadata per heap consists of exactly three $64$-bit fields: a pointer to the underlying buffer, the logical size, and the capacity, for a total of $24$ bytes per heap in metadata. The system runs on Random Access Memory (RAM) with byte addressing, and all memory use should be measured in bytes.\n\nEach order record stored in the heap is a plain old data (POD) struct with the following fields:\n- $64$-bit order identifier ($8$ bytes).\n- $64$-bit timestamp ($8$ bytes).\n- $64$-bit price in integer tick units ($8$ bytes).\n- $32$-bit quantity ($4$ bytes).\n- $32$-bit trader tag ($4$ bytes).\n\nAssume there is no per-element pointer overhead, no external fragmentation to account for, and no allocator bookkeeping beyond the described heap metadata. Suppose there are exactly $N$ buy orders in the buy heap and exactly $M$ sell orders in the sell heap at a given snapshot.\n\nUsing only fundamental definitions of space complexity for array-based heaps and the above implementation details, derive a single closed-form analytical expression for the total memory in bytes used to store both heaps as a function of $N$ and $M$. Express your final answer in bytes. Do not provide inequalities; provide the exact expression. No rounding is required.", "solution": "The problem requires the derivation of a closed-form analytical expression for the total memory consumed by two binary heaps, one for buy orders and one for sell orders, as a function of the number of orders they contain, denoted by $N$ and $M$ respectively. The derivation will proceed by first determining the memory footprint of a single order record, then establishing the memory usage of a single heap, and finally summing the memory usage for both heaps.\n\nFirst, we determine the size of a single order record. The problem specifies that each record is a plain old data (POD) struct composed of five fields. The total size of one record, which we denote as $S_{rec}$, is the sum of the sizes of its constituent fields.\nThe fields are:\n- $64$-bit order identifier: $64 \\text{ bits} / 8 \\frac{\\text{bits}}{\\text{byte}} = 8$ bytes\n- $64$-bit timestamp: $8$ bytes\n- $64$-bit price: $8$ bytes\n- $32$-bit quantity: $32 \\text{ bits} / 8 \\frac{\\text{bits}}{\\text{byte}} = 4$ bytes\n- $32$-bit trader tag: $4$ bytes\n\nSumming these sizes gives the total size of a single order record:\n$$S_{rec} = 8 + 8 + 8 + 4 + 4 = 32 \\text{ bytes}$$\nThe problem states to assume no padding, which is consistent with the standard alignment of these data types on a $64$-bit architecture, resulting in a total size of $32$ bytes.\n\nNext, we analyze the memory usage of a single heap structure. The total memory for one heap is the sum of the memory used for its metadata and the memory allocated for its underlying dynamic array buffer.\nThe problem states that the metadata for each heap consists of three $64$-bit fields, for a total of $3 \\times 8 = 24$ bytes. Let us denote this fixed metadata size as $S_{meta}$.\n$$S_{meta} = 24 \\text{ bytes}$$\n\nThe size of the dynamic array buffer depends on its capacity, not its logical size (the number of elements it currently holds). The capacity is governed by a specific set of rules:\n1.  The initial capacity is $16$ elements.\n2.  The capacity is always a power of two.\n3.  The capacity is always at least the number of elements in the heap.\n4.  When the array is full, its capacity doubles.\n\nLet $k$ be the number of elements in a given heap. We must find an expression for the capacity, $C(k)$, that satisfies all these conditions. The problem asks for an exact expression, which implies that the capacity is the minimum possible value that satisfies all constraints, a standard assumption in space complexity analysis of such data structures.\nThe capacity must be a power of two, $C(k) = 2^p$ for some integer $p$.\nThe capacity must be at least $k$, so $C(k) \\ge k$.\nThe capacity must also be at least the initial capacity of $16$, so $C(k) \\ge 16$.\nCombining these, the capacity must be the smallest power of two that is greater than or equal to both $k$ and $16$. This can be expressed as finding the smallest power of two that is greater than or equal to $\\max(k, 16)$.\n\nThis can be formulated mathematically. For any positive integer $x$, the smallest power of two greater than or equal to $x$ is given by the expression $2^{\\lceil \\log_2(x) \\rceil}$. This formula holds for our capacity function. We must handle the case where the argument to the logarithm is zero. Let's analyze the behavior of $\\max(k, 16)$ for $k \\ge 0$:\n- If $k=0$, $\\max(0, 16) = 16$.\n- If $1 \\le k \\le 16$, $\\max(k, 16) = 16$.\n- If $k > 16$, $\\max(k, 16) = k$.\nThe argument to the logarithm, $\\max(k, 16)$, is always at least $16$, so it is always positive. The capacity function $C(k)$ is therefore:\n$$C(k) = 2^{\\lceil \\log_2(\\max(k, 16)) \\rceil}$$\nThis single expression correctly captures the capacity for any number of elements $k \\ge 0$.\n\nThe memory allocated for the buffer, $S_{buffer}(k)$, is the capacity multiplied by the size of each element:\n$$S_{buffer}(k) = C(k) \\times S_{rec} = 32 \\times 2^{\\lceil \\log_2(\\max(k, 16)) \\rceil}$$\n\nThe total memory for a single heap with $k$ elements, $M_{heap}(k)$, is the sum of the metadata and buffer sizes:\n$$M_{heap}(k) = S_{meta} + S_{buffer}(k) = 24 + 32 \\times 2^{\\lceil \\log_2(\\max(k, 16)) \\rceil}$$\n\nFinally, we calculate the total memory, $M_{total}$, for both the buy heap with $N$ orders and the sell heap with $M$ orders. This is the sum of the memory used by each heap.\n$$M_{total}(N, M) = M_{heap}(N) + M_{heap}(M)$$\n$$M_{total}(N, M) = \\left( 24 + 32 \\times 2^{\\lceil \\log_2(\\max(N, 16)) \\rceil} \\right) + \\left( 24 + 32 \\times 2^{\\lceil \\log_2(\\max(M, 16)) \\rceil} \\right)$$\nCombining terms, we arrive at the final closed-form analytical expression:\n$$M_{total}(N, M) = 48 + 32 \\left( 2^{\\lceil \\log_2(\\max(N, 16)) \\rceil} + 2^{\\lceil \\log_2(\\max(M, 16)) \\rceil} \\right)$$\nThis expression represents the exact total memory in bytes as a function of $N$ and $M$, conforming to all specifications of the problem.", "answer": "$$\\boxed{48 + 32 \\left( 2^{\\lceil \\log_2(\\max(N, 16)) \\rceil} + 2^{\\lceil \\log_2(\\max(M, 16)) \\rceil} \\right)}$$", "id": "3272546"}, {"introduction": "The ultimate goal of studying space complexity is to design memory-efficient algorithms. This final practice shifts our focus from analysis to design, tackling a common problem: counting distinct elements in a stream under a strict memory budget. You will implement a solution using a bitmap, a fundamental technique that leverages bit-level manipulation to track element presence with remarkable space savings, demonstrating the trade-offs involved when the input domain is bounded [@problem_id:3272560].", "problem": "You are given a stream of integers drawn from a known, fixed range $[1,K]$, where $K$ is a positive integer. The task is to design and implement an algorithm that counts the number of distinct integers that occur in the stream using at most $K/8 + O(1)$ bytes of memory, in the sense of the Random Access Machine (RAM) model (Random Access Machine (RAM) defined as a model of computation where memory is a linear array of cells and basic operations on words take constant time). Your algorithm must be derived from first principles, starting from the basic definitions of space complexity, bits and bytes, and the constraints of the RAM model. You must justify the memory usage bound and the correctness of the counting method.\n\nFundamental principles to use:\n- Space complexity is defined as the function $S(n)$ that maps an input size $n$ to the number of memory cells used by an algorithm, independent of constant-time registers.\n- A bit is the basic unit of information that can take values $0$ or $1$; a byte is exactly $8$ bits.\n- In the Random Access Machine (RAM) model, reading and writing a word are constant-time operations, and memory usage is counted by the number of words (or, when using sub-word packing, by the number of bits or bytes) allocated.\n\nAlgorithmic requirements:\n- Assume each element of the stream is guaranteed to be an integer in $[1,K]$, although the stream may contain duplicates and the stream length is arbitrary and unknown in advance.\n- Design a method that uses an array of bits to track presence, where each bit corresponds to exactly one value in $[1,K]$.\n- The total auxiliary memory allocated to represent the presence structure must be exactly $\\lceil K/8 \\rceil$ bytes, plus $O(1)$ additional variables. You must explain why this satisfies $K/8 + O(1)$ bytes.\n- After processing the stream, the number of distinct integers must be computed by summing the number of bits set to $1$ in the presence structure.\n- The mapping from a value $x \\in [1,K]$ to its bit position must be clearly specified and justified.\n\nProgram requirements:\n- Implement the algorithm in a single, complete program that runs without user input.\n- Use a compact byte-level structure to store the bits, where the number of bytes allocated for the presence structure is $\\lceil K/8 \\rceil$.\n- For counting the number of bits set to $1$, use a method that operates at the byte granularity and sums the number of ones per byte.\n\nTest suite:\nYour program must embed and process the following test cases. For each test case, the input is a pair $(K,\\text{stream})$ where $K$ is the known maximum value and $\\text{stream}$ is the sequence to process. For each case, output the count of distinct integers observed.\n1. $K=20$, $\\text{stream}=[1,3,3,5,20,20,2,2,2]$.\n2. $K=1$, $\\text{stream}=[1,1,1]$.\n3. $K=10$, $\\text{stream}=[10,9,8,1,2,2]$.\n4. $K=16$, $\\text{stream}=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1,2,3,4]$.\n5. $K=32$, $\\text{stream}=[]$ (empty stream).\n6. $K=1000$, $\\text{stream}=[1,1000,500,500,250,750,250,999,2,2,3,4,4,10]$.\n\nFinal output format:\nYour program should produce a single line of output containing the results of all test cases as a comma-separated list enclosed in square brackets, in the same order as the test cases above. For example, the output must look like $[\\text{result}_1,\\text{result}_2,\\ldots,\\text{result}_6]$, where each $\\text{result}_i$ is an integer.", "solution": "The user-provided problem statement is subjected to critical validation.\n\n### Step 1: Extract Givens\n- **Input:** A stream of integers.\n- **Data Domain:** Integers are drawn from a known, fixed range $[1,K]$, where $K$ is a positive integer.\n- **Task:** Count the number of distinct integers that occur in the stream.\n- **Memory Constraint:** The algorithm must use at most $K/8 + O(1)$ bytes of memory.\n- **Computational Model:** Random Access Machine (RAM), where memory is a linear array and basic operations take constant time.\n- **Definitions:**\n    - Space complexity $S(n)$: number of memory cells used by an algorithm for an input of size $n$, excluding constant-time registers.\n    - $1$ byte is exactly $8$ bits.\n- **Algorithmic Requirements:**\n    1. An array of bits must be used to track the presence of each integer.\n    2. Each bit must correspond to exactly one value in $[1,K]$.\n    3. Total auxiliary memory for the presence structure must be exactly $\\lceil K/8 \\rceil$ bytes.\n    4. Total memory usage must be $\\lceil K/8 \\rceil$ bytes plus $O(1)$ additional variables.\n    5. The final count is computed by summing the bits set to $1$ after processing the stream.\n    6. The mapping from an integer $x \\in [1,K]$ to its bit position must be explicitly defined.\n- **Program Requirements:**\n    1. Implement in a single, self-contained program.\n    2. Use a compact byte-level structure of size $\\lceil K/8 \\rceil$ bytes.\n    3. Count set bits at the byte granularity.\n- **Test Suite:** A set of six test cases with associated parameters $(K, \\text{stream})$ is provided.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding:** The problem is firmly located within the domain of computer science, specifically in data structures and algorithms. The concepts of bit vectors (or bitmaps), space complexity, the RAM model, and bitwise operations are standard and well-established principles. The problem is scientifically and mathematically sound.\n- **Well-Posedness:** The problem is well-posed. It specifies the input, the output, and a clear, verifiable constraint on the solution's resources (memory). A unique integer count exists for any given input stream.\n- **Objectivity:** The problem statement is objective and uses precise, unambiguous technical language. There are no subjective or opinion-based components.\n- **Completeness and Consistency:** The problem is self-contained. The memory constraint is specified as both \"at most $K/8 + O(1)$ bytes\" and \"exactly $\\lceil K/8 \\rceil$ bytes, plus $O(1)$ additional variables.\" These are consistent. Since for any integer $K > 0$, the ceiling function $\\lceil K/8 \\rceil$ satisfies the inequality $K/8 < \\lceil K/8 \\rceil \\le K/8 + 1$, the quantity $\\lceil K/8 \\rceil$ is indeed equal to $K/8 + c$ for some constant $c \\in (0, 1]$. This is a specific form of $K/8 + O(1)$. The setup is therefore consistent and complete.\n- **Realism and Feasibility:** The problem is computationally feasible and grounded in the practical realities of memory management, where bit-level packing is a common optimization technique.\n- **Structure and Triviality:** The problem is well-structured and non-trivial. It requires a correct implementation of bit manipulation and a formal justification of the memory usage, which tests fundamental understanding. It is a canonical problem for demonstrating space-efficient data structures.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. It is a well-defined, standard problem in algorithm design that is consistent, complete, and grounded in established computer science principles. A solution will be provided.\n\n### Principled Solution Derivation\n\nThe objective is to count the number of distinct integers in a stream, where each integer $x$ is guaranteed to be in the range $[1,K]$. The primary constraint is the memory usage, which must not exceed $K/8 + O(1)$ bytes.\n\n**1. Foundational Principle: Presence Tracking**\n\nTo count distinct elements, we must record which elements have been seen. A natural way to represent this is to maintain a set of boolean flags, one for each possible integer in the range $[1,K]$. Let us denote this set of flags as $S$. For each integer $i \\in [1,K]$, we can have a flag $s_i$ such that $s_i$ is true if $i$ has been seen in the stream, and false otherwise. Initially, all flags are false. When an integer $x$ arrives from the stream, we set its corresponding flag $s_x$ to true. The number of distinct elements is then the total number of flags that are true after the stream has been fully processed.\n\n**2. Data Structure Design and Space Complexity Analysis**\n\nA direct implementation using a standard boolean array would require $K$ boolean variables. In many programming languages, a boolean variable occupies at least one full byte ($8$ bits) of memory. This would lead to a total memory usage of at least $K$ bytes, which grossly violates the specified memory constraint of $K/8 + O(1)$ bytes.\n\nThe core of the problem lies in implementing these $K$ flags with maximum space efficiency. A single bit is the smallest unit of information capable of representing a binary state (true/false, or $1$/$0$). Therefore, the most space-efficient representation for our $K$ flags is an array of $K$ bits, often called a bit vector or bitmap.\n\nAccording to the specified RAM model, memory is addressable at the byte level. To store $K$ bits, we must allocate a contiguous block of bytes. Since each byte contains $8$ bits, the total number of bytes required is the smallest integer number of bytes that can contain $K$ bits. This quantity is precisely $\\lceil K/8 \\rceil$.\n\nLet's formally analyze this memory usage. The memory for the bit vector is $M_{vec} = \\lceil K/8 \\rceil$ bytes. We know that for any real number $z$, $\\lceil z \\rceil \\le z+1$. Applying this, we have:\n$$M_{vec} \\le \\frac{K}{8} + 1$$\nThe term $1$ is a constant, which is $O(1)$. Therefore, the memory usage for the bit vector is $M_{vec} \\in O(K/8)$. More specifically, it satisfies the required bound of $K/8 + O(1)$ bytes. The algorithm will also require a small, constant number of auxiliary variables for loop indices and processing the current stream element. This memory is constant with respect to $K$ and the stream length, and is captured by the $O(1)$ term in the overall space complexity, making the total space usage $\\lceil K/8 \\rceil + O(1)$ bytes.\n\n**3. Integer-to-Bit Mapping**\n\nWe must define a deterministic, one-to-one mapping from each integer $x \\in [1,K]$ to a unique bit in our bit vector. The bit vector can be viewed as a 0-indexed sequence of $K$ bits. A natural mapping is to associate the integer $x$ with the $(x-1)$-th bit. Let $i_x = x-1$ be the 0-indexed bit position for integer $x$.\n\nTo access this bit, we must identify its location within our byte array. Let the byte array be `bit_vector`.\n- The index of the byte containing the desired bit is given by integer division: $j = \\lfloor i_x / 8 \\rfloor = (x-1) \\text{ div } 8$.\n- The position of the bit within that byte (from least significant bit, $0$, to most significant bit, $7$) is given by the remainder: $p = i_x \\pmod 8 = (x-1) \\pmod 8$.\n\n**4. Algorithmic Steps**\n\n**Initialization:**\n1.  Calculate the required number of bytes: $N_{bytes} = \\lceil K/8 \\rceil$.\n2.  Allocate a byte array, `bit_vector`, of size $N_{bytes}$ and initialize all its elements to $0$. This ensures all $K$ logical bits are initially $0$, signifying that no integers have been seen.\n\n**Stream Processing:**\nFor each integer $x$ in the input stream:\n1.  Calculate the bit's 0-indexed position: $i_x = x - 1$.\n2.  Determine the byte index: $j = i_x // 8$.\n3.  Determine the bit position within the byte: $p = i_x % 8$.\n4.  To set the bit to $1$, we use a bitwise OR operation. A mask is created by left-shifting $1$ by $p$ positions: $mask = 1 \\ll p$.\n5.  Update the byte in the vector: `bit_vector[j] |= mask`. This operation is idempotent, meaning repeated operations with the same $x$ do not change the state of the bit once it is set to $1$.\n\n**Final Counting:**\nAfter the entire stream has been processed:\n1.  Initialize a total count: `distinct_count = 0`.\n2.  Iterate through each byte `b` in the `bit_vector` from index $0$ to $N_{bytes}-1$.\n3.  For each byte, compute its population count (the number of bits set to $1$). This can be done efficiently using built-in functions or bit-twiddling hacks.\n4.  Add this per-byte count to `distinct_count`.\n5.  The final value of `distinct_count` is the total number of distinct integers observed in the stream.\n\nThis algorithm correctly counts the distinct elements while adhering strictly to the memory constraints and principles laid out in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the distinct integer counting problem for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases as specified in the problem statement.\n    # Each case is a tuple (K, stream).\n    test_cases = [\n        (20, [1, 3, 3, 5, 20, 20, 2, 2, 2]),\n        (1, [1, 1, 1]),\n        (10, [10, 9, 8, 1, 2, 2]),\n        (16, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1, 2, 3, 4]),\n        (32, []),\n        (1000, [1, 1000, 500, 500, 250, 750, 250, 999, 2, 2, 3, 4, 4, 10]),\n    ]\n\n    results = []\n\n    for K, stream in test_cases:\n        # 1. Initialization\n        # Calculate the number of bytes needed to store K bits.\n        # This is equivalent to ceil(K / 8).\n        # np.ceil returns a float, so we cast to int.\n        num_bytes = int(np.ceil(K / 8))\n\n        # Allocate the bit vector as an array of 8-bit unsigned integers (bytes),\n        # initialized to all zeros.\n        bit_vector = np.zeros(num_bytes, dtype=np.uint8)\n\n        # 2. Stream Processing\n        for x in stream:\n            # The problem guarantees x is in [1, K].\n            # Map the integer x to a 0-indexed bit position.\n            bit_index = x - 1\n\n            # Determine the byte in the vector that contains this bit.\n            byte_index = bit_index // 8\n\n            # Determine the position of the bit within the byte (0-7).\n            bit_in_byte = bit_index % 8\n\n            # Create a mask to set the specific bit.\n            # (1 << bit_in_byte) creates an integer with only the target bit set.\n            mask = np.uint8(1 << bit_in_byte)\n\n            # Use bitwise OR to set the bit, marking the integer as seen.\n            # This operation is idempotent.\n            bit_vector[byte_index] |= mask\n        \n        # 3. Final Counting\n        distinct_count = 0\n        # Iterate through each byte of the bit vector.\n        for byte_val in bit_vector:\n            # Count the number of set bits (population count) in the current byte.\n            # int.bit_count() is a highly efficient method available in Python 3.10+.\n            distinct_count += int(byte_val).bit_count()\n        \n        results.append(distinct_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3272560"}]}