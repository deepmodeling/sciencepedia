{"hands_on_practices": [{"introduction": "We begin our practice with a foundational skill: using a loop invariant to confirm the correctness of a familiar algorithm. This exercise challenges you to apply the three pillars of an invariant proof—initialization, maintenance, and termination—to a standard factorial loop [@problem_id:3248254]. By stepping through this verification process, you will solidify your understanding of how these properties work together to guarantee a correct result.", "problem": "You are given the following pseudocode fragment intended to compute the factorial of a nonnegative integer $n$:\n- Input: $n \\in \\mathbb{Z}_{\\ge 0}$\n- Initialization: $result := 1$\n- For-loop: for $i$ from $1$ to $n$ (inclusive) do $result := result \\cdot i$\n\nA proof of correctness is attempted using the loop invariant: at the beginning of each iteration with current loop index $i$, the assertion $result = (i-1)!$ holds. Assume standard for-loop semantics where the invariant is evaluated at loop entry, and the loop iterates through $i = 1, 2, \\dots, n$ in order.\n\nWhich of the following best identifies the bug, if any, in this code-invariant pair that would prevent a correct proof of partial correctness and final postcondition $result = n!$?\n\nA. The invariant is false at loop entry for $i = 1$ because $0! \\ne 1$.\n\nB. The loop body $result := result \\cdot i$ violates the invariant since it changes $result$ to $i!$, so the same invariant cannot hold after the body.\n\nC. Upon termination, the loop exits with $i = n$, so the invariant only yields $result = (n-1)!$, an off-by-one error.\n\nD. There is no bug, provided $result$ is initialized to $1$ before the loop; the invariant holds at each loop entry and implies $result = n!$ at termination.\n\nE. The initialization should be $result := 0$ to reflect the base case $0! = 0$.\n\nChoose the single best answer.", "solution": "The problem requires an analysis of a pseudocode fragment and a proposed loop invariant for proving its correctness. The goal is to compute the factorial of a non-negative integer $n$, which is denoted $n!$. The algorithm is as follows:\n\n- Input: $n \\in \\mathbb{Z}_{\\ge 0}$\n- Initialization: $result := 1$\n- Loop: for $i$ from $1$ to $n$ do $result := result \\cdot i$\n\nThe proposed loop invariant is: at the beginning of each iteration with loop index $i$, the assertion $P(i): result = (i-1)!$ holds. The final postcondition to be proven is $result = n!$.\n\nTo verify the correctness of a loop using a loop invariant, we must establish three properties:\n\n1.  **Initialization:** The invariant is true before the first iteration of the loop.\n2.  **Maintenance:** If the invariant is true at the beginning of an iteration, it remains true at the beginning of the next iteration.\n3.  **Termination:** When the loop terminates, the invariant, combined with the termination condition, implies the correctness of the algorithm (i.e., the postcondition holds).\n\nLet's analyze these three properties for the given code and invariant.\n\n**1. Initialization**\nThe loop begins with $i = 1$. Before the first iteration, the variable $result$ is initialized to $1$. We must check if the invariant $P(1)$ holds at this point.\nThe invariant for $i=1$ is $result = (1-1)! = 0!$.\nBy the standard definition of the factorial function, $0! = 1$.\nSince the initialized value of $result$ is $1$, the assertion $1 = 1$ is true.\nThus, the initialization property holds.\n\n**2. Maintenance**\nWe assume that the invariant holds at the beginning of an arbitrary iteration $i$ where $1 \\le i \\le n$. This is the inductive hypothesis: assume $result = (i-1)!$.\nInside the loop body, the statement $result := result \\cdot i$ is executed.\nThe value of $result$ after this statement becomes $(i-1)! \\cdot i$.\nBy the recursive definition of the factorial function, $(i-1)! \\cdot i = i!$.\nThe next iteration of the loop will start with the index $i+1$ (assuming $i  n$). The invariant for this next iteration is $P(i+1): result = ((i+1)-1)! = i!$.\nSince the value of $result$ at the end of iteration $i$ is indeed $i!$, the invariant holds at the beginning of iteration $i+1$.\nThus, the maintenance property holds.\n\n**3. Termination**\nThe `for` loop `for i from 1 to n` terminates after the iteration for $i=n$ is completed. At this point, the loop counter is incremented to $n+1$, and the loop condition (which is implicitly $i \\le n$) becomes false.\nSo, the loop terminates when $i = n+1$.\nWe use the loop invariant and this termination condition to prove the postcondition.\nThe invariant is $result = (i-1)!$.\nSubstituting the value of $i$ at termination, $i = n+1$, into the invariant gives:\n$result = ((n+1)-1)! = n!$.\nThis is exactly the desired postcondition. The value of $result$ after the final iteration (when $i=n$) was updated to $(n-1)! \\cdot n = n!$, which is consistent with the deduction from the invariant at termination.\n\nLet's also consider the base case where $n=0$. The loop `for i from 1 to 0` does not execute. The code initializes $result := 1$ and then terminates. The final value is $result = 1$, which is correct since $0! = 1$. The loop invariant proof framework handles this case correctly, as the postcondition is met without any iterations.\n\nSince all three properties (Initialization, Maintenance, and Termination) hold, the code-invariant pair is correct and constitutes a valid proof of partial correctness.\n\nNow, we evaluate each option:\n\n**A. The invariant is false at loop entry for $i = 1$ because $0! \\ne 1$.**\nThis statement is factually incorrect. By definition, $0! = 1$. As demonstrated in the Initialization step of our analysis, the invariant holds for $i=1$. Therefore, this option is **Incorrect**.\n\n**B. The loop body $result := result \\cdot i$ violates the invariant since it changes $result$ to $i!$, so the same invariant cannot hold after the body.**\nThis option misinterprets the meaning of \"maintenance\". The invariant $P(i)$ states `$result = (i-1)!$`. After the body executes, `result` becomes `$i!$`. This does not violate the maintenance property; it is the crucial step that ensures the invariant for the *next* iteration, $P(i+1)$, will hold. The invariant is not required to hold throughout the execution of the loop body. It must hold at the boundaries (entry) of the iterations. Therefore, this option is **Incorrect**.\n\n**C. Upon termination, the loop exits with $i = n$, so the invariant only yields $result = (n-1)!$, an off-by-one error.**\nThis statement is based on a flawed understanding of for-loop termination. The loop executes for $i=1, 2, \\dots, n$. It terminates when the loop counter becomes greater than $n$. In standard semantics, this occurs when $i$ is $n+1$. Applying the invariant with the termination condition $i = n+1$ yields the correct postcondition $result = ((n+1)-1)! = n!$. The premise that the loop exits \"with $i=n$\" is wrong, leading to an incorrect conclusion. Therefore, this option is **Incorrect**.\n\n**D. There is no bug, provided $result$ is initialized to $1$ before the loop; the invariant holds at each loop entry and implies $result = n!$ at termination.**\nThis statement accurately summarizes our analysis. The Initialization, Maintenance, and Termination properties all hold for the given code and invariant. The `code-invariant pair` is a valid combination for proving the correctness of the factorial algorithm. Therefore, this option is **Correct**.\n\n**E. The initialization should be $result := 0$ to reflect the base case $0! = 0$.**\nThis statement contains a factual error: $0! = 1$, not $0$. Furthermore, initializing $result$ to $0$ would cause the final result to be $0$ for any $n \\ge 1$ due to multiplication by $0$, which is incorrect. Therefore, this option is **Incorrect**.", "answer": "$$\\boxed{D}$$", "id": "3248254"}, {"introduction": "Loop invariants are not just for formal proofs; they are powerful diagnostic tools for debugging. In this practice, you are presented with a buggy implementation of binary search [@problem_id:3248327]. Your task is to use the stated invariant as a lens to identify precisely where and why the code fails, demonstrating that a violation of the invariant maintenance property is a direct pointer to the source of the error.", "problem": "You are given a procedure intended to search a strictly increasing sorted array $A[0 \\ldots n-1]$ for a target value $t$. The intended loop invariant is the closed-interval claim: at the start of each loop iteration, if there exists an index $k$ such that $A[k] = t$, then $low \\le k \\le high$; equivalently, the index of $t$, if it exists, lies in the subarray $A[low \\ldots high]$. The algorithm is:\n\nInitialize $low \\leftarrow 0$, $high \\leftarrow n-1$.\nWhile $low \\le high$:\n- Let $mid \\leftarrow \\left\\lfloor \\dfrac{low + high}{2} \\right\\rfloor$.\n- If $A[mid] = t$, return $mid$.\n- Else if $A[mid]  t$, set $high \\leftarrow mid - 1$.\n- Else, set $low \\leftarrow mid + 1$.\nIf the loop terminates, return that $t$ is not present.\n\nAssume standard integer arithmetic with exact floor for division and no overflow. Use only the core facts about strictly increasing arrays (for all indices $i$ and $j$, if $i  j$ then $A[i]  A[j]$) and the definition of the invariant. Your task is to determine which step causes the algorithm to sometimes miss an existing target by violating the stated invariant, and to justify your choice by identifying exactly how the invariant fails to be preserved.\n\nWhich option best identifies the flaw with respect to the invariant and why?\n\nA. Initialization violates the invariant because $high$ should be set to $n$ instead of $n-1$, so the initial subarray $A[low \\ldots high]$ does not cover all candidates.\n\nB. The maintenance of the invariant is broken in the branch $A[mid]  t$: updating $high \\leftarrow mid - 1$ can exclude the only region where $t$ can reside in an ascending array, so after this update it may no longer be true that if $t$ is present then $low \\le k \\le high$ for some $k$ with $A[k] = t$.\n\nC. The maintenance of the invariant is broken in the branch $A[mid]  t$: updating $low \\leftarrow mid + 1$ can exclude the only region where $t$ can reside in an ascending array, so after this update it may no longer be true that if $t$ is present then $low \\le k \\le high$ for some $k$ with $A[k] = t$.\n\nD. The invariant is misstated; it should use a half-open range, namely that if $t$ is present then $t$ must be in $A[low \\ldots high)$, and using a closed interval is why the algorithm can miss $t$.", "solution": "The problem statement is a valid exercise in algorithmic analysis, specifically the verification of algorithm correctness using a loop invariant. The task is to analyze a flawed binary search implementation against a given invariant. The problem is well-posed, scientifically grounded in computer science principles, and objective.\n\nThe core of the analysis rests on the three properties of a loop invariant: initialization, maintenance, and termination. Let the stated loop invariant be denoted by $P$.\n$P$: At the start of each loop iteration, if an index $k$ exists such that $A[k] = t$, then $low \\le k \\le high$.\n\n**1. Initialization**\n\nThe algorithm initializes $low \\leftarrow 0$ and $high \\leftarrow n-1$. The loop invariant $P$ must hold before the first iteration. The initial search space is the entire array, $A[0 \\ldots n-1]$. If the target value $t$ exists in the array at some index $k$, then by definition of array indexing, $k$ must be within the bounds $[0, n-1]$. Therefore, the condition $low \\le k \\le high$ (i.e., $0 \\le k \\le n-1$) is true. The initialization step correctly establishes the invariant.\n\n**2. Maintenance**\n\nWe assume the invariant $P$ holds at the beginning of a `while` loop iteration. That is, if $A[k] = t$ for some $k$, then $low \\le k \\le high$. We must show that $P$ holds at the beginning of the next iteration.\n\nThe algorithm calculates $mid \\leftarrow \\left\\lfloor \\dfrac{low + high}{2} \\right\\rfloor$.\nThere are three cases in the loop body:\n\nCase 1: $A[mid] = t$. The algorithm finds the target and returns $mid$, terminating. The loop does not continue, so the maintenance property is not tested further for this path. The outcome is correct.\n\nCase 2: $A[mid]  t$. The array $A$ is strictly increasing, meaning for any indices $i  j$, we have $A[i]  A[j]$. If $A[mid]  t$, then for any index $j \\le mid$, we have $A[j] \\le A[mid]  t$. This implies that if the target $t$ exists in the array at index $k$, its index must be greater than $mid$. That is, $k > mid$.\nCombining our assumption ($low \\le k \\le high$) and this deduction ($k > mid$), the target index $k$, if it exists, must lie in the range $[mid + 1, high]$.\nTo maintain the invariant, the next search interval $[low_{new}, high_{new}]$ must contain $[mid + 1, high]$. The correct update would be $low \\leftarrow mid + 1$.\nThe algorithm, however, executes $high \\leftarrow mid - 1$. The new search interval becomes $[low, mid-1]$. An index $k$ known to be greater than $mid$ cannot possibly be in this new interval. Thus, if the target exists, the new state violates the invariant $low_{new} \\le k \\le high_{new}$.\n\nCase 3: `Else`. This case is triggered when $A[mid] \\ne t$ and $A[mid] \\not t$, which implies $A[mid] > t$. Since the array is strictly increasing, if $A[mid] > t$, then for any index $j \\ge mid$, we have $A[j] \\ge A[mid] > t$. This implies that if the target $t$ exists in the array at index $k$, its index must be less than $mid$. That is, $k  mid$.\nCombining our assumption ($low \\le k \\le high$) and this deduction ($k  mid$), the target index $k$, if it exists, must lie in the range $[low, mid - 1]$.\nTo maintain the invariant, the new search interval $[low_{new}, high_{new}]$ must contain $[low, mid - 1]$. The correct update would be $high \\leftarrow mid - 1$.\nThe algorithm, however, executes $low \\leftarrow mid + 1$. The new search interval becomes $[mid+1, high]$. An index $k$ known to be less than $mid$ cannot possibly be in this new interval. Thus, if the target exists, the new state violates the invariant $low_{new} \\le k \\le high_{new}$.\n\nBoth update branches of the algorithm for when $A[mid] \\ne t$ are incorrect and violate the maintenance property of the loop invariant. The logic for the two cases appears to have been swapped.\n\nNow, we evaluate the given options:\n\n**A. Initialization violates the invariant because $high$ should be set to $n$ instead of $n-1$, so the initial subarray $A[low \\ldots high]$ does not cover all candidates.**\nAs demonstrated in the initialization analysis, setting $low \\leftarrow 0$ and $high \\leftarrow n-1$ correctly establishes the invariant. This range fully covers all valid indices of the array $A[0 \\ldots n-1]$. Setting $high \\leftarrow n$ would be incorrect for a closed-interval invariant on a $0$-indexed array of size $n$, as it could lead to accessing $A[n]$ which is out of bounds. This option is **Incorrect**.\n\n**B. The maintenance of the invariant is broken in the branch $A[mid]  t$: updating $high \\leftarrow mid - 1$ can exclude the only region where $t$ can reside in an ascending array, so after this update it may no longer be true that if $t$ is present then $low \\le k \\le high$ for some $k$ with $A[k] = t$.**\nOur analysis of the maintenance step for the case $A[mid]  t$ confirms this statement precisely. If $A[mid]  t$, the target must be in the upper half of the current search space ($k  mid$). The update $high \\leftarrow mid-1$ discards this half and confines the search to the lower half, thus breaking the invariant. This option accurately describes a critical flaw in the algorithm. This option is **Correct**.\n\n**C. The maintenance of the invariant is broken in the branch $A[mid]  t$: updating $low \\leftarrow mid + 1$ can exclude the only region where $t$ can reside in an ascending array, so after this update it may no longer be true that if $t$ is present then $low \\le k \\le high$ for some $k$ with $A[k] = t$.**\nOur analysis of the maintenance step for the `Else` case ($A[mid]  t$) also confirms this statement. If $A[mid]  t$, the target must be in the lower half of the search space ($k  mid$). The update $low \\leftarrow mid+1$ discards this half and confines the search to the upper half, breaking the invariant. This option also accurately describes a critical flaw in the algorithm. This option is **Correct**.\n\n**D. The invariant is misstated; it should use a half-open range, namely that if $t$ is present then $t$ must be in $A[low \\ldots high)$, and using a closed interval is why the algorithm can miss $t$.**\nThe choice of a closed-interval $[low, high]$ invariant is a standard and valid approach for binary search. The presented algorithm is flawed because its update logic does not correctly maintain this invariant. A correct algorithm *can* be written using this invariant. The problem lies with the code, not the statement of the invariant. This option is **Incorrect**.\n\n**Conclusion:**\nBoth options B and C describe valid, fatal flaws in the algorithm's maintenance step. The algorithm incorrectly swaps the update logic for the cases $A[mid]  t$ and $A[mid]  t$. However, the question asks for the single best option. In the provided pseudocode, the `Else if A[mid]  t` branch appears textually before the final `Else` branch (which handles $A[mid]  t$). The flaw described in option B is associated with the first of the two incorrect update statements in the control flow of the code. Therefore, it can be argued that B identifies the most immediate flaw encountered when analyzing the conditional logic sequence.", "answer": "$$\\boxed{B}$$", "id": "3248327"}, {"introduction": "Having used invariants for verification and debugging, we now arrive at their most constructive application: algorithm design. This final practice flips the usual script [@problem_id:3248351]. Instead of being given code, you are given the invariant itself and tasked with reverse-engineering the loop body, illustrating how an invariant can serve as a blueprint for writing code that is correct by construction.", "problem": "You are given an integer base $x$ and a nonnegative integer exponent $n$. Consider an algorithm that builds $x^n$ by maintaining three integer variables $p$, $k$, and $y$ with the following initialization and loop guard:\n- Initialization: $p \\leftarrow 1$, $k \\leftarrow 0$, $y \\leftarrow n$, and $n_{\\text{original}} \\leftarrow n$.\n- Loop guard: continue while $y > 0$.\n- Loop invariant to be preserved at the start of every iteration: $p = x^k$ and $k + y = n_{\\text{original}}$.\n\nYour task is to reverse engineer a correct loop body, that is, determine the assignment statements that must be executed in the loop body to maintain the loop invariant and to ensure that upon termination the postcondition $p = x^{n_{\\text{original}}}$ holds.\n\nYour derivation must start from the following fundamental bases:\n- The definition of exponentiation on the natural numbers: $x^0 = 1$ and $x^{k+1} = x^k \\cdot x$ for all integers $x$ and all integers $k \\ge 0$.\n- The principle of mathematical induction on the natural numbers and the well-foundedness of the usual order on the natural numbers.\n- The standard definition of a loop invariant for partial correctness and a natural-number variant for total correctness in imperative programs.\n\nAssume the following domain and conventions:\n- $x$ is any integer and $n$ is any integer satisfying $n \\ge 0$.\n- For this problem, define $x^0 = 1$ for every integer $x$, including the case $x = 0$, so $0^0$ is taken to be $1$.\n\nTasks:\n1. Derive a minimal loop body (consisting only of assignments to $p$, $k$, and $y$) that preserves the invariant $p = x^k$ and $k + y = n_{\\text{original}}$ at the start of each iteration, decreases a natural-number variant to ensure termination, and yields the postcondition $p = x^{n_{\\text{original}}}$ when the loop terminates.\n2. Justify partial correctness and total correctness of your loop using the loop invariant method, starting only from the fundamental bases above.\n3. Implement a program that, for a suite of test cases, executes your loop and returns for each test case:\n   - The computed value $p$ on termination.\n   - A boolean indicating whether the invariant held at the start of every iteration and the postcondition $p = x^{n_{\\text{original}}}$ held at termination.\n\nTest suite:\n- $(x, n) = (2, 10)$\n- $(x, n) = (5, 0)$\n- $(x, n) = (0, 7)$\n- $(x, n) = (0, 0)$\n- $(x, n) = (-3, 4)$\n- $(x, n) = (-3, 5)$\n- $(x, n) = (2, 50)$\n- $(x, n) = (1, 100)$\n\nAnswer specification and output format:\n- For each test case, output a two-element list $[p, b]$ where $p$ is the computed integer $x^n$ using your derived loop and $b$ is a boolean that is $\\text{True}$ if and only if the invariant held at the start of every iteration and the final state satisfies $p = x^{n_{\\text{original}}}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example: $[\\,[p_1, b_1],[p_2, b_2],\\dots]$.\n- No user input is required. The program must be self-contained and use only integer arithmetic and control flow; do not call any built-in exponentiation function to compute $p$ inside the loop body. For verification of the invariant in your implementation, you may compute $x^k$ using the defining recurrence $x^0 = 1$ and $x^{k+1} = x^k \\cdot x$.", "solution": "The problem of designing a loop body to compute $x^n$ based on a given loop invariant is a standard exercise in program verification and reverse engineering of algorithms. I will first validate the problem statement and then proceed with a formal derivation and proof of correctness.\n\n### Step 1: Problem Validation\n\nI begin by extracting the given information and conditions as stated in the problem.\n\n- **Inputs**: An integer base $x$ and a non-negative integer exponent $n$.\n- **Algorithm Variables**: Three integer variables $p$, $k$, and $y$.\n- **Initialization**: $p \\leftarrow 1$, $k \\leftarrow 0$, $y \\leftarrow n$, and a constant $n_{\\text{original}} \\leftarrow n$.\n- **Loop Guard**: The loop continues as long as $y > 0$.\n- **Loop Invariant**: The proposition $I(p, k, y) \\equiv (p = x^k) \\land (k + y = n_{\\text{original}})$ must hold at the start of every loop iteration.\n- **Postcondition**: Upon termination, the final value of $p$ must be $x^{n_{\\text{original}}}$.\n- **Fundamental Bases**: The derivation must be grounded in:\n    1. The recursive definition of exponentiation: $x^0 = 1$ and $x^{k+1} = x^k \\cdot x$ for $k \\ge 0$.\n    2. The principle of mathematical induction.\n    3. The theory of loop invariants for proving partial and total correctness.\n- **Domain Conventions**: $x$ is any integer, $n$ is an integer with $n \\ge 0$, and for the purpose of this problem, $x^0=1$ for all integers $x$, including $0^0=1$.\n\nThe problem is scientifically and mathematically sound, well-posed, and objective. It is a standard problem in computer science concerning algorithm design and correctness, specifically focusing on loop invariants. The premises are consistent, and all necessary information for a derivation is provided. The problem is not trivial, as it requires a systematic application of the principles of program verification. Therefore, the problem is deemed valid.\n\n### Step 2: Derivation of the Loop Body\n\nLet the state of the variables at the start of an arbitrary loop iteration be $(p, k, y)$. By hypothesis (the loop invariant), we assume that at this point:\n1. $p = x^k$\n2. $k + y = n_{\\text{original}}$\n\nThe loop guard is $y > 0$, so we can also assume $y$ is a positive integer.\nThe goal is to find a sequence of assignments to $p$, $k$, and $y$ that results in a new state $(p', k', y')$ which also satisfies the invariant, i.e., $p' = x^{k'}$ and $k' + y' = n_{\\text{original}}$. Additionally, we must ensure the loop terminates.\n\n**Ensuring Termination**:\nThe loop terminates if $y$ eventually becomes less than or equal to $0$. Since $y$ is an integer that is positive inside the loop, a simple way to guarantee progress towards termination is to decrement $y$ in each iteration. Let's propose the update:\n$$y' \\leftarrow y - 1$$\nThis defines a variant function $V(y) = y$, which is a non-negative integer that strictly decreases with each iteration, thus guaranteeing termination.\n\n**Preserving the Invariant**:\nNow, we must determine the updates for $k$ and $p$ that preserve the invariant, given the update to $y$.\n\nFirst, consider the second part of the invariant, $k + y = n_{\\text{original}}$. We need the new state $(k', y')$ to satisfy $k' + y' = n_{\\text{original}}$.\nSubstituting our proposed update $y' = y - 1$:\n$$k' + (y - 1) = n_{\\text{original}}$$\nFrom the invariant holding at the start of the iteration, we know $y = n_{\\text{original}} - k$. Substituting this into the previous equation:\n$$k' + (n_{\\text{original}} - k - 1) = n_{\\text{original}}$$\n$$k' - k - 1 = 0$$\n$$k' = k + 1$$\nThis gives us the required assignment for $k$:\n$$k' \\leftarrow k + 1$$\n\nNext, consider the first part of the invariant, $p = x^k$. We need the new state $(p', k')$ to satisfy $p' = x^{k'}$.\nSubstituting our derived update $k' = k + 1$:\n$$p' = x^{k+1}$$\nUsing the fundamental definition of exponentiation, $x^{k+1} = x^k \\cdot x$. So, we must have:\n$$p' = x^k \\cdot x$$\nFrom the invariant holding at the start of the iteration, we know $p = x^k$. Substituting this into the equation for $p'$:\n$$p' = p \\cdot x$$\nThis provides the required assignment for $p$:\n$$p' \\leftarrow p \\cdot x$$\n\nThus, the derived minimal loop body consists of the following three assignments:\n1. $p \\leftarrow p \\cdot x$\n2. $k \\leftarrow k + 1$\n3. $y \\leftarrow y - 1$\n\nThe order of these assignments does not matter as long as they all use the values of $p, k, y$ from the start of the iteration. The proposed sequential execution achieves this.\n\n### Step 3: Proof of Correctness\n\nWe use the loop invariant method to prove total correctness.\n\n- **Loop Invariant ($I$)**: $(p = x^k) \\land (k + y = n_{\\text{original}})$.\n- **Variant ($V$)**: $V(y) = y$.\n\n**1. Initialization (Base Case)**:\nWe must show that the invariant $I$ holds before the first iteration of the loop.\n- The initial state is $p \\leftarrow 1$, $k \\leftarrow 0$, $y \\leftarrow n$, and $n_{\\text{original}} \\leftarrow n$.\n- Check first conjunct: Is $p = x^k$? This means checking if $1 = x^0$. By the problem's definition of exponentiation, this is true for all integers $x$.\n- Check second conjunct: Is $k + y = n_{\\text{original}}$? This means checking if $0 + n = n$. This is true.\n- Both parts of the invariant hold. The initialization is correct.\n\n**2. Preservation (Inductive Step)**:\nAssume at the start of an iteration that the invariant $I$ holds and the loop guard $y > 0$ is true. Let the state be $(p, k, y)$. We must show that after executing the loop body, the invariant still holds for the new state $(p', k', y')$.\n- **Hypothesis**: $p = x^k$, $k + y = n_{\\text{original}}$, and $y > 0$.\n- **Loop Body**: $p' \\leftarrow p \\cdot x$, $k' \\leftarrow k + 1$, $y' \\leftarrow y - 1$.\n- **Proof for first conjunct ($p' = x^{k'}$)**:\n  - $p' = p \\cdot x$ (by assignment)\n  - $p' = (x^k) \\cdot x$ (by hypothesis $p = x^k$)\n  - $p' = x^{k+1}$ (by definition of exponentiation)\n  - Since $k' = k + 1$, we have $p' = x^{k'}$. The first conjunct holds.\n- **Proof for second conjunct ($k' + y' = n_{\\text{original}}$)**:\n  - $k' + y' = (k + 1) + (y - 1)$ (by assignment)\n  - $k' + y' = k + y$\n  - Since $k + y = n_{\\text{original}}$ by hypothesis, we have $k' + y' = n_{\\text{original}}$. The second conjunct holds.\n- The loop body preserves the invariant. This establishes partial correctness: if the loop terminates, its result is correct.\n\n**3. Termination and Postcondition**:\n- **Termination**: The variant is $V(y) = y$. At initialization, $y=n \\ge 0$. The loop condition is $y > 0$. Inside the loop, $y$ is strictly positive. The update is $y' \\leftarrow y - 1$, so $y'  y$. A strictly decreasing sequence of non-negative integers must be finite. Therefore, the loop must terminate.\n- **Postcondition**: The loop terminates when the guard $y > 0$ becomes false. Since $y$ is an integer decremented by $1$ at each step, termination occurs precisely when $y = 0$.\n  - At this point, the invariant still holds (it was true at the start of the final, non-executing check).\n  - From $k + y = n_{\\text{original}}$, with $y=0$, we get $k = n_{\\text{original}}$.\n  - From $p = x^k$, substituting $k = n_{\\text{original}}$, we get $p = x^{n_{\\text{original}}}$.\n- This is the desired postcondition.\n\nThe combination of initialization, preservation, and termination proves the total correctness of the algorithm with the derived loop body.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the problem by running the derived algorithm on a suite of test cases\n    and verifying the loop invariant and postcondition for each case.\n    \"\"\"\n\n    def power_for_verification(base, exp):\n        \"\"\"\n        Computes base^exp using the fundamental recursive definition.\n        Handles the special case 0^0 = 1 as per the problem statement.\n        This function is used only for verifying the invariant and postcondition,\n        not in the main computation of p.\n        \"\"\"\n        if exp  0:\n            raise ValueError(\"Exponent must be non-negative.\")\n        if exp == 0:\n            return 1\n        \n        # Using integer arithmetic to avoid potential floating point issues\n        # and to handle large numbers.\n        result = 1\n        for _ in range(exp):\n            result *= base\n        return result\n\n    def execute_and_verify(x, n):\n        \"\"\"\n        Executes the derived exponentiation algorithm for a given base x and exponent n.\n        It checks if the loop invariant holds at the start of every iteration and\n        if the postcondition holds upon termination.\n\n        Returns:\n            A list [p, b], where p is the computed result and b is a boolean\n            indicating if all checks passed.\n        \"\"\"\n        # Initialization\n        p = 1\n        k = 0\n        y = n\n        n_original = n\n\n        all_checks_passed = True\n\n        # Check invariant after initialization and before the first iteration.\n        # This is a crucial step, especially for the n=0 case where the loop is skipped.\n        try:\n            p_check = (p == power_for_verification(x, k))\n            ky_check = (k + y == n_original)\n            if not (p_check and ky_check):\n                all_checks_passed = False\n        except Exception:\n            all_checks_passed = False\n\n        # Loop\n        while y > 0:\n            # Check invariant at the start of the current iteration\n            try:\n                p_check = (p == power_for_verification(x, k))\n                ky_check = (k + y == n_original)\n                if not (p_check and ky_check):\n                    all_checks_passed = False\n            except Exception:\n                all_checks_passed = False\n\n            # Loop body derived from the invariant\n            p = p * x\n            k = k + 1\n            y = y - 1\n        \n        # Check postcondition upon termination\n        try:\n            postcondition_check = (p == power_for_verification(x, n_original))\n            if not postcondition_check:\n                all_checks_passed = False\n        except Exception:\n            all_checks_passed = False\n\n        return [p, all_checks_passed]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, 10),\n        (5, 0),\n        (0, 7),\n        (0, 0),\n        (-3, 4),\n        (-3, 5),\n        (2, 50),\n        (1, 100),\n    ]\n\n    results = []\n    for case in test_cases:\n        x, n = case\n        result = execute_and_verify(x, n)\n        # Convert Python boolean to string 'True'/'False' for final output format\n        result[1] = 'True' if result[1] else 'False'\n        results.append(str(result).replace(\"'\", \"\"))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3248351"}]}