{"hands_on_practices": [{"introduction": "Mastering data structures begins with building them from the ground up. This first practice challenges you to implement a fully-featured, resizable circular queue, a cornerstone of efficient data management [@problem_id:3209149]. You will apply modular arithmetic to manage the wrap-around behavior of the array indices and implement dynamic resizing strategies for both growth and shrinkage, laying a robust foundation for understanding amortized $O(1)$ time complexity.", "problem": "Design and implement a first-in-first-out queue using a circular, resizable array that can store elements of any data type. The core of the design must follow from the fundamental definition of a queue and modular arithmetic on array indices. Specifically, use the following fundamental base: a queue is an abstract data type that enforces first-in-first-out order, and circular buffer indexing advances indices by replacing an index $i$ with $(i+1) \\bmod C$ where $C$ is the current capacity of the underlying array.\n\nImplementation requirements:\n- Maintain an array of current capacity $C$, a head index $h$, a tail index $t$, and a size $s$ (the number of elements). The head index $h$ points to the position of the logical front of the queue, and the tail index $t$ points to the position where the next element will be inserted.\n- Enqueue operation: before inserting a new element, if $s = C$ then allocate a new array of capacity $2C$ and copy the current $s$ elements in logical order starting at index $0$. After copying, set $h \\leftarrow 0$ and $t \\leftarrow s$, and then insert the new element at index $t$, advance $t \\leftarrow (t+1) \\bmod C$, and increase the size $s \\leftarrow s+1$.\n- Dequeue operation: remove and return the front element at index $h$, clear that slot, advance $h \\leftarrow (h+1) \\bmod C$, and decrease the size $s \\leftarrow s-1$. After removal, if $s \\le \\lfloor C/4 \\rfloor$ and $C$ is strictly greater than the initial capacity $C_0$, then allocate a new array of capacity $\\max(C_0,\\lfloor C/2 \\rfloor)$, copy the $s$ elements in logical order starting at index $0$, and set $h \\leftarrow 0$, $t \\leftarrow s$.\n- Never shrink the capacity below the initial capacity $C_0$. Assume no operations will attempt to dequeue or peek from an empty queue.\n- The implementation must be logically generic: it must preserve the order of arbitrary elements and must not depend on operations specific to a particular data type. In a statically typed language, this is naturally achieved with templates or generics; in a dynamically typed language, the same behavior is achieved by not restricting the element type.\n\nCorrectness requirement:\n- Maintain the invariants that after any finite sequence of operations, the logical content of the queue is exactly the sequence of enqueued elements that have not been dequeued, in the same order; the head index $h$ always indicates the position of the current front (when $s gt; 0$); and the tail index $t$ always indicates the position immediately after the last element. All operations must run in worst-case time $O(C)$ when resizing occurs and $O(1)$ otherwise, with amortized time $O(1)$ over any sequence of $m$ operations.\n\nYour program must implement this queue and run the following test suite. For each test, compute the specified integer or floating-point results.\n\nTest case A (wrap-around and growth with integers):\n- Parameters: initial capacity $C_0 = 4$.\n- Operations in order: enqueue $10$, enqueue $20$, enqueue $30$, dequeue, dequeue, enqueue $40$, enqueue $50$, enqueue $60$, enqueue $70$.\n- Required result for this test: a list $[s, C, f, S_{\\text{dq}}]$ where $s$ is the final size, $C$ is the final capacity, $f$ is the final front element, and $S_{\\text{dq}}$ is the sum of all values dequeued in this test.\n\nTest case B (growth followed by shrink with integers):\n- Parameters: initial capacity $C_0 = 2$.\n- Operations in order: enqueue the integers $0,1,2,\\dots,15$ (inclusive), then perform exactly $13$ dequeues.\n- Required result for this test: a list $[s, C, f, S_{\\text{dq}}]$ as above, where $f$ is the current front element after the last dequeue, and $S_{\\text{dq}}$ is the sum of all dequeued integers.\n\nTest case C (strings with growth and shrink; aggregate by length):\n- Parameters: initial capacity $C_0 = 3$.\n- Operations in order: enqueue the strings \"x\", \"yy\", \"zzz\", \"wwww\", then dequeue twice, then enqueue \"vv\", then enqueue \"u\", then dequeue repeatedly until empty.\n- Required result for this test: a list $[s, C, L]$ where $s$ is the final size, $C$ is the final capacity, and $L$ is the sum of lengths of all strings dequeued during this test.\n\nTest case D (floats with wrap-around, no growth):\n- Parameters: initial capacity $C_0 = 5$.\n- Operations in order: enqueue $1.5$, enqueue $2.5$, enqueue $3.5$, dequeue once, enqueue $4.5$, enqueue $5.5$, dequeue twice, enqueue $6.5$, enqueue $7.5$, enqueue $8.5$.\n- Required result for this test: a list $[s, C, f, S_{\\text{dq}}]$ where $s$ is the final size, $C$ is the final capacity, $f$ is the final front element, and $S_{\\text{dq}}$ is the sum (as a floating-point number) of all dequeued values.\n\nFinal output format:\n- Your program should produce a single line of output containing the results of the four tests as a comma-separated list enclosed in square brackets. Each test result itself must appear as a bracketed, comma-separated list. For example, the overall shape must be of the form $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$ with no additional text. There are no physical units, and no angles or percentages are involved in this problem.", "solution": "The problem requires the design and implementation of a first-in-first-out (FIFO) queue using a resizable, circular array. The design must be derived from fundamental principles of data structures and modular arithmetic.\n\n### Principle-Based Design\n\n**1. The Queue Abstract Data Type (ADT)**\nA queue is an abstract data type defined by its behavior: it stores a collection of elements and enforces a First-In-First-Out (FIFO) access policy. Elements are added to one end (the \"tail\" or \"rear\") via an `enqueue` operation and removed from the other end (the \"head\" or \"front\") via a `dequeue` operation. This strict ordering is the core principle guiding the design.\n\n**2. Array-Based Implementation and Circular Indexing**\nA simple array can be used to store the queue's elements. A naive implementation might shift all elements one position to the left upon every `dequeue` to keep the head at index $0$. This, however, results in an $O(s)$ time complexity for `dequeue`, where $s$ is the number of elements, which is inefficient.\n\nTo achieve constant-time $O(1)$ operations, we treat the array as a circular buffer. This is accomplished using modular arithmetic. We maintain two indices: a head index $h$ pointing to the first logical element, and a tail index $t$ pointing to the next available slot. When an index advances past the end of the array (at capacity $C-1$), it \"wraps around\" to the beginning ($0$). This is mathematically expressed as advancing an index $i$ to $(i+1) \\bmod C$. With this scheme, `enqueue` and `dequeue` operations simply involve updating the $h$ or $t$ index, achieving $O(1)$ time complexity. To disambiguate between a full and an empty queue (which can both occur when $h=t$), we explicitly maintain a size counter, $s$. An `enqueue` operation increments $s$ and a `dequeue` decrements it. The queue is empty if $s=0$ and full if $s=C$.\n\n**3. Dynamic Resizing and Amortized Analysis**\nA fixed-capacity array is limiting. To support an arbitrary number of elements, the underlying array must be resizable. The specified strategy is a common and efficient one:\n- **Growth (on `enqueue` when $s=C$):** The capacity is doubled ($C \\to 2C$). A new, larger array is allocated. The existing $s$ elements, which may be wrapped around in the old array, are copied into the new array in their logical order, starting from index $0$. The head and tail indices are then reset to $h \\leftarrow 0$ and $t \\leftarrow s$.\n- **Shrinkage (on `dequeue` when $s \\le \\lfloor C/4 \\rfloor$):** To conserve memory, the array shrinks if its occupancy falls to a quarter or less of its capacity. The capacity is halved ($C \\to \\lfloor C/2 \\rfloor$), with the constraint that it never falls below the initial capacity $C_0$. The copy and index reset procedure is the same as for growth.\n\nWhile a single `enqueue` or `dequeue` that triggers a resize takes time proportional to the current capacity, $O(C)$, these events are infrequent. The cost of resizing is amortized over the sequence of operations. After a growth to capacity $2C$, at least $C$ more `enqueue` operations must occur before the next growth. Similarly, after a shrink to capacity $C/2$, at least $C/4$ `dequeue` operations are needed to trigger another shrink. This ensures that the total work for $m$ operations remains proportional to $m$, leading to an amortized time complexity of $O(1)$ per operation.\n\n**4. Implementation Structure**\nThe implementation encapsulates this logic within a class. This class maintains the state variables: the data array, the current capacity $C$, the initial capacity $C_0$, the head index $h$, the tail index $t$, and the size $s$.\nThe method for copying elements during a resize (`_resize`) is critical. It must iterate through the elements in their logical FIFO order, starting from the physical index $h$ in the old array and wrapping around using the modulo operator, and place them into the first $s$ positions of the new array. Specifically, the $k$-th logical element (where $k \\in \\{0, 1, \\dots, s-1\\}$) is located at physical index $(h+k) \\bmod C_{\\text{old}}$ and is copied to index $k$ in the new array.\n\nThis design is logically generic as it does not perform any operations on the elements themselves, other than storage and retrieval. It thus preserves the integrity and order of elements of any data type, as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests the ResizableCircularQueue as per the problem statement.\n    \"\"\"\n\n    class ResizableCircularQueue:\n        \"\"\"\n        A FIFO queue implemented with a resizable, circular numpy array.\n        \"\"\"\n        def __init__(self, initial_capacity: int):\n            \"\"\"\n            Initializes an empty queue with a given initial capacity.\n            \"\"\"\n            if initial_capacity  1:\n                raise ValueError(\"Initial capacity must be at least 1.\")\n            self._C0 = initial_capacity\n            self._C = self._C0\n            # dtype=object allows storing elements of any type.\n            self._data = np.full(self._C, None, dtype=object)\n            self._h = 0  # Head index (points to the front element)\n            self._t = 0  # Tail index (points to the next available slot)\n            self._s = 0  # Number of elements in the queue\n\n        @property\n        def size(self) - int:\n            \"\"\"Returns the number of elements in the queue.\"\"\"\n            return self._s\n\n        @property\n        def capacity(self) - int:\n            \"\"\"Returns the current capacity of the underlying array.\"\"\"\n            return self._C\n        \n        def get_front(self):\n            \"\"\"Returns the front element of the queue without removing it.\"\"\"\n            if self.size == 0:\n                # Per problem statement, this will not be called on an empty queue.\n                return None\n            return self._data[self._h]\n\n        def _resize(self, new_capacity: int):\n            \"\"\"\n            Resizes the underlying array to new_capacity and copies elements.\n            \"\"\"\n            old_data = self._data\n            old_capacity = self._C\n            \n            self._data = np.full(new_capacity, None, dtype=object)\n            \n            # Copy elements from the old (circular) array to the new (linear) one.\n            walk = self._h\n            for k in range(self._s):\n                self._data[k] = old_data[walk]\n                walk = (walk + 1) % old_capacity\n            \n            # Reset indices and update capacity\n            self._C = new_capacity\n            self._h = 0\n            self._t = self._s\n\n        def enqueue(self, element):\n            \"\"\"\n            Adds an element to the tail of the queue.\n            \"\"\"\n            if self._s == self._C:\n                # Grow array if it is full.\n                self._resize(2 * self._C)\n            \n            self._data[self._t] = element\n            self._t = (self._t + 1) % self._C\n            self._s += 1\n\n        def dequeue(self):\n            \"\"\"\n            Removes and returns the element from the head of the queue.\n            Assumes the queue is not empty, as per problem statement.\n            \"\"\"\n            element = self._data[self._h]\n            self._data[self._h] = None  # Clear the slot\n            self._h = (self._h + 1) % self._C\n            self._s -= 1\n            \n            # Shrink array if it is sparsely populated, but not below C0.\n            if self._s = self._C // 4 and self._C  self._C0:\n                new_capacity = max(self._C0, self._C // 2)\n                self._resize(new_capacity)\n\n            return element\n\n    # --- Test Cases ---\n    all_results = []\n\n    # Test Case A\n    q_a = ResizableCircularQueue(initial_capacity=4)\n    dequeued_vals_a = []\n    q_a.enqueue(10)\n    q_a.enqueue(20)\n    q_a.enqueue(30)\n    dequeued_vals_a.append(q_a.dequeue())\n    dequeued_vals_a.append(q_a.dequeue())\n    q_a.enqueue(40)\n    q_a.enqueue(50)\n    q_a.enqueue(60)\n    q_a.enqueue(70)\n    result_a = [q_a.size, q_a.capacity, q_a.get_front(), sum(dequeued_vals_a)]\n    all_results.append(result_a)\n\n    # Test Case B\n    q_b = ResizableCircularQueue(initial_capacity=2)\n    dequeued_vals_b = []\n    for i in range(16):\n        q_b.enqueue(i)\n    for _ in range(13):\n        dequeued_vals_b.append(q_b.dequeue())\n    result_b = [q_b.size, q_b.capacity, q_b.get_front(), sum(dequeued_vals_b)]\n    all_results.append(result_b)\n\n    # Test Case C\n    q_c = ResizableCircularQueue(initial_capacity=3)\n    dequeued_vals_c = []\n    q_c.enqueue(\"x\")\n    q_c.enqueue(\"yy\")\n    q_c.enqueue(\"zzz\")\n    q_c.enqueue(\"wwww\")\n    dequeued_vals_c.append(q_c.dequeue())\n    dequeued_vals_c.append(q_c.dequeue())\n    q_c.enqueue(\"vv\")\n    q_c.enqueue(\"u\")\n    while q_c.size  0:\n        dequeued_vals_c.append(q_c.dequeue())\n    L_c = sum(len(s) for s in dequeued_vals_c)\n    result_c = [q_c.size, q_c.capacity, L_c]\n    all_results.append(result_c)\n    \n    # Test Case D\n    q_d = ResizableCircularQueue(initial_capacity=5)\n    dequeued_vals_d = []\n    q_d.enqueue(1.5)\n    q_d.enqueue(2.5)\n    q_d.enqueue(3.5)\n    dequeued_vals_d.append(q_d.dequeue())\n    q_d.enqueue(4.5)\n    q_d.enqueue(5.5)\n    dequeued_vals_d.append(q_d.dequeue())\n    dequeued_vals_d.append(q_d.dequeue())\n    q_d.enqueue(6.5)\n    q_d.enqueue(7.5)\n    q_d.enqueue(8.5)\n    f_d = q_d.get_front()\n    # Ensure float precision is handled correctly for output\n    S_dq_d = float(sum(dequeued_vals_d))\n    result_d = [q_d.size, q_d.capacity, f_d, S_dq_d]\n    all_results.append(result_d)\n\n    # Format the final output string exactly as specified.\n    results_str_list = []\n    for res in all_results:\n        # Convert each item in a result list to string\n        res_items_as_str = [str(item) for item in res]\n        # Join items with a comma and enclose in brackets\n        results_str_list.append(f\"[{','.join(res_items_as_str)}]\")\n    \n    # Join all test case results with a comma and enclose in brackets\n    final_output = f\"[{','.join(results_str_list)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3209149"}, {"introduction": "While the strict First-In-First-Out discipline of a standard queue is powerful, many real-world systems require more flexibility. This practice models a call center waiting line where priority customers can \"jump the queue,\" effectively requiring an insertion at the front [@problem_id:3208994]. By implementing an `enqueue_front` operation, you will evolve your queue into a double-ended queue (deque) and gain a deeper understanding of how both head and tail pointers are manipulated in a dynamic circular buffer.", "problem": "Implement an array-backed queue that models a call center waiting line using a circular buffer and then modify it to support inserting \"priority customers\" at the front. The required operations are: enqueue at back for standard arrivals, enqueue at front for priority arrivals, and dequeue from front for service. The implementation must be array-based (no linked structures), maintain a circular layout, and automatically resize the underlying array by doubling its capacity when the array is full just before an insertion. The objective is to derive the correctness and complexity of these operations from the abstract definition of a queue and the properties of modular arithmetic over array indices, and to confirm behavior through a fixed test suite.\n\nUse the following fundamental base:\n- A queue is an abstract data type defined by First-In-First-Out (FIFO), meaning the item that has been in the queue the longest is served first.\n- An array supports constant-time random access by index.\n- Circular layout on an array uses modular arithmetic; if the head index is $h$, tail index is $t$, and capacity is $C$, then advancing by one position corresponds to adding $1$ modulo $C$. Specifically, $i \\mapsto (i+1) \\bmod C$.\n- Resizing an array by allocating a new array of size $2C$ and copying existing items in logical order $0,1,2,\\dots$ preserves item order and enables amortized constant time per insertion.\n\nYour task:\n- Design and implement an array-based queue with the following operations using a circular buffer with dynamic resizing:\n  - Standard arrival enqueue_back: append customer identifier $x$ at the back.\n  - Priority arrival enqueue_front: insert customer identifier $x$ at the front.\n  - Serve dequeue_front: remove and return the identifier at the front; if the queue is empty, no identifier is returned for that serve step.\n- Maintain indices $h$ (head), $t$ (tail), size $s$, and capacity $C$ such that the logical order of items is at positions $(h + k) \\bmod C$ for $k \\in \\{0,1,\\dots,s-1\\}$.\n- When inserting into a full buffer where $s = C$, first resize to capacity $2C$ by relocating the $s$ items to positions $0,1,\\dots,s-1$ in order, and then perform the pending insertion. Do not shrink the buffer.\n\nEvent model:\n- Each test case consists of an initial capacity $C$ and a sequence of events of three kinds:\n  - Standard arrival $A(x)$ meaning enqueue_back with identifier $x$.\n  - Priority arrival $P(x)$ meaning enqueue_front with identifier $x$.\n  - Serve $S(k)$ meaning perform dequeue_front up to $k$ times; if fewer than $k$ customers are available, serve as many as available. Collect the sequence of all served identifiers, in order, across all $S(\\cdot)$ events of the test case.\n\nRequired output:\n- For each test case, the program must output the list of served identifiers, in order, as a list of integers.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result itself is a list, and lists must be printed without spaces, for example: $[[1,2],[3],[4,5,6]]$.\n\nTest suite:\n- Use exactly the following five test cases. Each test case is a pair $(C, \\text{events})$, where $C$ is the initial capacity and $\\text{events}$ is the finite sequence of events.\n  - Test $1$: $C = 4$, events $[A(1), A(2), A(3), S(2), A(4), P(99), S(3)]$.\n  - Test $2$: $C = 3$, events $[S(1), P(5), S(2), S(1)]$.\n  - Test $3$: $C = 5$, events $[A(10), A(11), A(12), A(13), S(3), A(14), A(15), A(16), P(7), S(4)]$.\n  - Test $4$: $C = 2$, events $[A(1), A(2), P(3), A(4), A(5), S(5)]$.\n  - Test $5$: $C = 4$, events $[P(1), P(2), P(3), A(4), A(5), S(5)]$.\n\nNotes and constraints:\n- All customer identifiers and $k$ values are nonnegative integers.\n- Correctness must follow from the abstract definition of a queue and the semantics of the additional priority operation, with indices updated via modular arithmetic. Ensure that enqueue_front and enqueue_back both run in $\\mathcal{O}(1)$ time in the absence of resizing and that resizing yields amortized $\\mathcal{O}(1)$ time per insertion over any sequence of $n$ insertions.\n- The program must be fully self-contained and produce the required single-line output with no user input and no external files.", "solution": "The problem statement is valid. It presents a well-defined task in the domain of data structures and algorithms, grounded in established computer science principles. The problem is self-contained, objective, and its requirements are internally consistent and formalizable.\n\nThe core task is to implement a double-ended queue (deque) using a circular array that supports dynamic resizing. The deque must provide three operations: `enqueue_back` (standard append), `enqueue_front` (priority prepend), and `dequeue_front` (serve). The solution must be validated against a specific test suite.\n\nThe implementation will be encapsulated within a class, which we can name `CircularDeque`. This class will manage the state of the queue through four primary attributes:\n- An underlying `numpy` array, `data`, which stores the queue elements.\n- The capacity of this array, $C$, which we will call `capacity`.\n- The index of the first element in the queue, $h$, which we will call `head`.\n- The number of elements currently in the queue, $s$, which we will call `size`.\n\nAn empty queue is defined by $s=0$. A full queue is defined by $s=C$. The problem statement also mentions a tail index $t$. This index is not an independent state variable but can be derived from the others. It points to the first available slot at the back of the queue and is given by $t = (h+s) \\pmod C$. We will use $h$ and $s$ as the canonical state variables for managing the queue's structure.\n\nThe logical sequence of elements in the queue, indexed from $0$ to $s-1$, is mapped to the physical array indices using modular arithmetic. The $k$-th logical element (where $k \\in \\{0, 1, \\dots, s-1\\}$) is stored at the physical index $(h+k) \\pmod C$.\n\nLet us detail the design of each required operation.\n\n**1. Initialization `__init__(self, capacity)`**\nThis constructor initializes an empty queue with a given initial capacity $C$.\n- The `capacity` is set to the provided value.\n- The `data` array is created as a `numpy` array of size $C$, initialized to zeros.\n- The `head` index $h$ is initialized to $0$.\n- The `size` $s$ is initialized to $0$.\n\n**2. `enqueue_back(self, x)`**\nThis operation adds an element $x$ to the rear of the queue.\n- First, it checks if the queue is full ($s=C$). If so, it must resize the underlying array by calling a helper method, `_resize()`.\n- The physical index for the new element is the tail position, calculated as $t = (h+s) \\pmod C$.\n- The element $x$ is placed at `data[t]`.\n- The size of the queue, $s$, is incremented by $1$.\nThis operation has a time complexity of $\\mathcal{O}(1)$ when no resizing occurs.\n\n**3. `enqueue_front(self, x)`**\nThis operation adds a priority element $x$ to the front of the queue.\n- Similar to `enqueue_back`, it first checks for and handles overflow by calling `_resize()` if $s=C$.\n- To insert at the front, the `head` index $h$ must be moved one position backward (circularly). The new head index is calculated as $h' = (h - 1 + C) \\pmod C$.\n- The `head` is updated to $h'$.\n- The new element $x$ is placed at `data[h']`.\n- The size of the queue, $s$, is incremented by $1$.\nThis operation also has a time complexity of $\\mathcal{O}(1)$ when no resizing occurs.\n\n**4. `dequeue_front(self)`**\nThis operation removes and returns the element at the front of the queue.\n- It first checks if the queue is empty ($s=0$). If so, it returns an indicator (e.g., `None`) signifying that no element was served, as per the problem description.\n- If the queue is not empty, the element to be returned is `data[h]`.\n- The `head` index is advanced one position forward (circularly): $h' = (h+1) \\pmod C$.\n- The `head` is updated to $h'$.\n- The size of the queue, $s$, is decremented by $1$.\n- The retrieved element is returned.\nThis operation is always $\\mathcal{O}(1)$.\n\n**5. Resizing `_resize(self)`**\nThis helper method is invoked by the enqueue operations when $s=C$.\n- A new capacity $C_{new}$ is set to $2C$.\n- A new `numpy` array, `new_data`, is allocated with capacity $C_{new}$.\n- The crucial step is copying the elements from the old array to the new one. The problem specifies that elements should be relocated to occupy indices $0, 1, \\dots, s-1$ in the new array. This process \"unrolls\" the circular buffer. For each logical element $k$ from $0$ to $s-1$:\n    - Its index in the old array is $i_{old} = (h+k) \\pmod C$.\n    - The element `data[i_old]` is copied to `new_data[k]`.\n- After the copy is complete, the `data` array is replaced with `new_data`, and the `capacity` is updated to $C_{new}$.\n- Because the elements are now at the start of the new array in their logical order, the `head` index $h$ is reset to $0$. The `size` $s$ remains unchanged by the resize operation itself.\n\n**Correctness and Complexity Analysis**\nThe correctness of this design is rooted in the consistent application of modular arithmetic for all index calculations, which correctly implements the circular nature of the buffer. The resizing procedure, by explicitly unrolling the elements into a linear sequence at the start of the new, larger array, correctly preserves the FIFO order and simplifies the state by resetting $h$ to $0$.\n\nThe complexity meets the problem's requirements. In the absence of resizing, both `enqueue_front` and `enqueue_back` perform a constant number of arithmetic operations and a single array access, making them $\\mathcal{O}(1)$. The `dequeue_front` operation is always $\\mathcal{O}(1)$. The `_resize` operation takes $\\mathcal{O}(C)$ time, where $C$ is the current capacity. According to standard amortized analysis for dynamic arrays that grow geometrically, this $\\mathcal{O}(C)$ cost is distributed over the next $C$ insertions (in this case, doubling capacity from $C$ to $2C$ allows for at least $C$ new insertions). This yields an amortized time complexity of $\\mathcal{O}(1)$ per insertion operation over a long sequence of operations.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass CircularDeque:\n    \"\"\"\n    An array-backed queue (deque) implemented with a circular buffer\n    and dynamic resizing.\n    \"\"\"\n    def __init__(self, capacity):\n        \"\"\"\n        Initializes the deque with a given capacity.\n        \"\"\"\n        if capacity  1:\n            raise ValueError(\"Capacity must be at least 1\")\n        self.capacity = capacity\n        # Using a numpy array of a specific dtype as required.\n        # Initializing with 0s is fine as we track size separately.\n        self.data = np.zeros(self.capacity, dtype=int)\n        self.head = 0  # Index of the front element\n        self.size = 0  # Number of elements in the deque\n\n    def _resize(self):\n        \"\"\"\n        Doubles the capacity of the deque when it is full.\n        The elements are unrolled into the new array starting from index 0.\n        \"\"\"\n        old_capacity = self.capacity\n        self.capacity *= 2\n        new_data = np.zeros(self.capacity, dtype=int)\n        \n        # Unroll the circular buffer into a linear layout in the new array\n        for k in range(self.size):\n            old_index = (self.head + k) % old_capacity\n            new_data[k] = self.data[old_index]\n        \n        self.data = new_data\n        self.head = 0\n\n    def enqueue_back(self, value):\n        \"\"\"\n        Adds an element to the back of the deque.\n        \"\"\"\n        if self.size == self.capacity:\n            self._resize()\n        \n        # Calculate the index for the new element at the tail\n        tail_index = (self.head + self.size) % self.capacity\n        self.data[tail_index] = value\n        self.size += 1\n\n    def enqueue_front(self, value):\n        \"\"\"\n        Adds an element to the front of the deque.\n        \"\"\"\n        if self.size == self.capacity:\n            self._resize()\n            \n        # Move head one step backwards (circularly)\n        self.head = (self.head - 1 + self.capacity) % self.capacity\n        self.data[self.head] = value\n        self.size += 1\n\n    def dequeue_front(self):\n        \"\"\"\n        Removes and returns the element from the front of the deque.\n        Returns None if the deque is empty.\n        \"\"\"\n        if self.size == 0:\n            return None\n        \n        value = self.data[self.head]\n        # Advance head one step forward (circularly)\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return value\n\ndef solve():\n    \"\"\"\n    Runs the full test suite as defined in the problem statement.\n    \"\"\"\n    # Test suite definition: (Initial Capacity, [Events])\n    # Events are tuples: ('A', value), ('P', value), ('S', count)\n    test_cases = [\n        (4, [('A', 1), ('A', 2), ('A', 3), ('S', 2), ('A', 4), ('P', 99), ('S', 3)]),\n        (3, [('S', 1), ('P', 5), ('S', 2), ('S', 1)]),\n        (5, [('A', 10), ('A', 11), ('A', 12), ('A', 13), ('S', 3), ('A', 14), ('A', 15), ('A', 16), ('P', 7), ('S', 4)]),\n        (2, [('A', 1), ('A', 2), ('P', 3), ('A', 4), ('A', 5), ('S', 5)]),\n        (4, [('P', 1), ('P', 2), ('P', 3), ('A', 4), ('A', 5), ('S', 5)]),\n    ]\n\n    all_results = []\n\n    for capacity, events in test_cases:\n        queue = CircularDeque(capacity)\n        served_identifiers = []\n        \n        for event_type, value in events:\n            if event_type == 'A':\n                queue.enqueue_back(value)\n            elif event_type == 'P':\n                queue.enqueue_front(value)\n            elif event_type == 'S':\n                for _ in range(value):\n                    served = queue.dequeue_front()\n                    if served is not None:\n                        served_identifiers.append(served)\n        \n        all_results.append(served_identifiers)\n\n    # Format the final output string as per the problem requirements.\n    # e.g., [[1,2,99,3,4],[5],[10,11,12,7,13,14,15],[3,1,2,4,5],[3,2,1,4,5]]\n    result_strings = []\n    for res_list in all_results:\n        # Create string for each inner list, e.g., \"[1,2,3]\"\n        list_str = f\"[{','.join(map(str, res_list))}]\"\n        result_strings.append(list_str)\n    \n    # Join all list strings into the final output format\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3208994"}, {"introduction": "The true power of a data structure is revealed when it elegantly solves a complex problem. This final practice demonstrates the utility of a double-ended queue (deque) by applying it to the classic palindrome-checking algorithm [@problem_id:3208992]. You will see firsthand how the deque's ability to provide $O(1)$ access to both its front and back elements is a perfect match for problems that require comparing elements symmetrically from the outside in, connecting abstract data structure theory to tangible problem-solving.", "problem": "Implement an array-based double-ended queue (deque) and use it to design an efficient palindrome-checking algorithm that explicitly tracks and reports the relative movements of the front and rear pointers. Your implementation must be based on a circular buffer (ring buffer) and must expose operations that run in constant time. Then, use the deque to process a small set of test strings, returning for each test case whether the string is a palindrome and how many times the front and rear pointers moved during the check.\n\nFundamental base and constraints:\n- A double-ended queue (deque) is a finite sequence supporting insertion and deletion at both ends in constant time. You must implement it using a fixed-size array and modular arithmetic.\n- Let the capacity be denoted by $C$, the front index by $f$, the rear index by $r$, and the current size by $s$. Maintain the invariant\n$s \\equiv (r - f) \\bmod C, \\quad \\text{with } 0 \\le s  C.$\n- Use the standard circular-buffer discipline that stores elements in a contiguous wrap-around segment from index $f$ to index $r-1$ modulo $C$. The rear index $r$ always denotes the position one past the last element, while the front index $f$ denotes the position of the first element when $s  0$.\n- To avoid ambiguity between full and empty states, leave one array slot unused at all times. Hence, when inserting $n$ elements, choose $C = n + 1$, which guarantees $s \\le n \\lt C$.\n- Define the following operations with the stated effects on indices and size:\n  - push_back: store at index $r$, then update $r \\leftarrow (r + 1) \\bmod C$, and $s \\leftarrow s + 1$.\n  - push_front: update $f \\leftarrow (f - 1) \\bmod C$, store at index $f$, and $s \\leftarrow s + 1$.\n  - pop_front: read at index $f$, update $f \\leftarrow (f + 1) \\bmod C$, and $s \\leftarrow s - 1$.\n  - pop_back: update $r \\leftarrow (r - 1) \\bmod C$, read at index $r$, and $s \\leftarrow s - 1$.\n  - peek_front: read at index $f$ when $s  0$.\n  - peek_back: read at index $(r - 1) \\bmod C$ when $s  0$.\n- The palindrome check must proceed as follows for a string of length $n$:\n  - Initialize an empty deque with capacity $C = n + 1$.\n  - Push the characters of the string from left to right using push_back.\n  - Repeatedly compare the front and back characters using peek_front and peek_back. If they are equal, remove both using pop_front and pop_back; otherwise, stop. Let $m_f$ be the number of successful pop_front operations executed, and $m_r$ the number of successful pop_back operations executed.\n  - The string is a palindrome if and only if all front–back comparisons succeed until $s \\le 1$. When the string is a palindrome, the number of successful pair removals is $m_f = m_r = \\left\\lfloor \\frac{n}{2} \\right\\rfloor$; when it is not, the process stops at the first mismatch, and $m_f = m_r = t$ for the number $t$ of successful matched pairs before the mismatch.\n\nAlgorithmic goals and requirements:\n- Derive the algorithm from the ring-buffer invariant $s \\equiv (r - f) \\bmod C$ and the operational effects on $f$, $r$, and $s$.\n- Reason about correctness by linking matched removals to pointer movement counts $m_f$ and $m_r$, and by relating the stopping condition $s \\le 1$ to palindromicity.\n- The time complexity must be linear in the string length $n$, with $O(1)$ amortized time per deque operation.\n\nTest suite you must implement and run:\n- Use the following fixed set of test strings, in this order:\n  - \"racecar\"\n  - \"abccba\"\n  - \"abca\"\n  - \"\" (the empty string)\n  - \"x\"\n  - \"ab\"\n\nFor each test string, the program must compute and return a list of four items:\n- A boolean indicating whether the string is a palindrome.\n- The integer $m_f$, the number of times the front pointer advanced due to pop_front during the check.\n- The integer $m_r$, the number of times the rear pointer retreated due to pop_back during the check.\n- The integer $s$ remaining in the deque when the process stops.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each element is itself a list of the four values $[b, m_f, m_r, s]$ for a test case. In symbols, the required format is\n  $$ [[b_1, m_{f,1}, m_{r,1}, s_1], [b_2, m_{f,2}, m_{r,2}, s_2], \\ldots, [b_k, m_{f,k}, m_{r,k}, s_k]] $$\n  with $k = 6$ for the specified test suite. The line must contain exactly this bracketed structure with commas and no additional text.\n\nUnits and angles:\n- No physical quantities or angles are involved; no unit specification is required.\n\nAnswer types:\n- All outputs are booleans and integers, which satisfy the requirement to return booleans, integers, floats, or lists of these types.", "solution": "The problem is valid as it provides a complete, consistent, and formalizable specification for implementing a data structure and an algorithm within the domain of computer science. All terms are well-defined, and the task is a standard, verifiable exercise in data structures and algorithms.\n\nThe solution proceeds in two stages. First, we design and implement a double-ended queue (deque) based on a circular array, adhering strictly to the provided specifications. Second, we use this deque to construct the specified palindrome-checking algorithm.\n\n### Part 1: Deque Implementation with a Circular Buffer\n\nA double-ended queue is implemented using a fixed-size array, serving as a circular buffer. The state of the deque is defined by four components: the underlying array `_data` of capacity $C$, a front pointer $f$, a rear pointer $r$, and the current number of elements $s$.\n\n**State and Invariants:**\n- Capacity $C$: The maximum number of slots in the array. For a string of length $n$, we set $C = n + 1$ to ensure at least one slot is always vacant, which prevents ambiguity between a full and an empty state when size $s$ is not tracked separately. Although we do track $s$, we will adhere to this capacity rule.\n- Front index $f$: The index of the first element in the deque.\n- Rear index $r$: The index of the first available slot *after* the last element.\n- Size $s$: The number of elements currently in the deque, $0 \\le s  C$.\n- The core invariant relating these variables is $s \\equiv (r - f) \\pmod{C}$.\n\nInitially, for an empty deque, we set $f=0$, $r=0$, and $s=0$. This state satisfies the invariant since $0 \\equiv (0 - 0) \\pmod{C}$.\n\n**Deque Operations:**\nThe behavior of each operation is defined by its effect on $f$, $r$, and $s$. All indices are computed modulo $C$.\n\n- **`push_back(item)`**: Adds an element to the rear. This operation requires space, so it is valid only if $s  C-1$.\n    1. Check for fullness: if $s = C-1$, raise an error.\n    2. Store the item at the current rear position: `_data`$[r] \\leftarrow \\text{item}$.\n    3. Advance the rear pointer: $r \\leftarrow (r + 1) \\pmod{C}$.\n    4. Increment the size: $s \\leftarrow s + 1$.\n    The invariant is maintained: $(r_{new} - f) \\pmod{C} = ((r_{old}+1)-f) \\pmod{C} \\equiv (s_{old}+1) \\pmod{C} = s_{new} \\pmod{C}$.\n\n- **`pop_front()`**: Removes and returns the element from the front. This is valid only if the deque is not empty ($s  0$).\n    1. Check for emptiness: if $s=0$, raise an error.\n    2. Retrieve the item from the front position: item $\\leftarrow$ `_data`$[f]$.\n    3. Advance the front pointer: $f \\leftarrow (f + 1) \\pmod{C}$.\n    4. Decrement the size: $s \\leftarrow s - 1$.\n    The invariant is maintained: $(r - f_{new}) \\pmod{C} = (r - (f_{old}+1)) \\pmod{C} \\equiv (s_{old}-1) \\pmod{C} = s_{new} \\pmod{C}$.\n\n- **`pop_back()`**: Removes and returns the element from the rear. This is valid only if the deque is not empty ($s  0$).\n    1. Check for emptiness: if $s=0$, raise an error.\n    2. Retreat the rear pointer: $r \\leftarrow (r - 1 + C) \\pmod{C}$. The addition of $C$ ensures a non-negative result before the modulo operation.\n    3. Retrieve the item from the new rear position: item $\\leftarrow$ `_data`$[r]$.\n    4. Decrement the size: $s \\leftarrow s - 1$.\n    The invariant is maintained: $(r_{new} - f) \\pmod{C} = ((r_{old}-1)-f) \\pmod{C} \\equiv (s_{old}-1) \\pmod{C} = s_{new} \\pmod{C}$.\n\n- **`peek_front()`**: Returns the front element without removing it. Valid if $s  0$.\n    1. Check for emptiness.\n    2. Return `_data`$[f]$.\n\n- **`peek_back()`**: Returns the rear element without removing it. Valid if $s  0$.\n    1. Check for emptiness.\n    2. The last element is at index $(r-1)$ wrapped around. The index is computed as $(r - 1 + C) \\pmod{C}$.\n    3. Return `_data`$[(r-1+C) \\pmod C]$.\n\nThese operations all involve a constant number of arithmetic calculations and array accesses, thus they each have a time complexity of $O(1)$.\n\n### Part 2: Palindrome-Checking Algorithm\n\nThe palindrome-checking algorithm utilizes the deque to efficiently compare characters from the beginning and end of a string.\n\n**Algorithm Steps:**\nFor a given input string of length $n$:\n1. **Initialization**: Create an empty deque with capacity $C = n + 1$. Initialize two counters, $m_f \\leftarrow 0$ for successful `pop_front` operations and $m_r \\leftarrow 0$ for successful `pop_back` operations.\n2. **Loading**: Iterate through the input string from left to right. For each character, call `push_back` to add it to the deque. After this step, the deque contains all $n$ characters in order, and its size is $s=n$.\n3. **Comparison and Removal**: Enter a loop that continues as long as the number of elements in the deque is greater than 1 (i.e., $s  1$). In each iteration:\n    a. Use `peek_front()` and `peek_back()` to access the characters at the two ends of the deque.\n    b. **If the characters match**: The string is still potentially a palindrome. Remove both characters by calling `pop_front()` and `pop_back()`. Increment both counters: $m_f \\leftarrow m_f + 1$ and $m_r \\leftarrow m_r + 1$.\n    c. **If the characters do not match**: The string is not a palindrome. The process terminates immediately.\n4. **Result Determination**: The string is a palindrome if and only if the comparison loop completes without finding any mismatches. This occurs when the loop condition $s  1$ becomes false. The final results are:\n    - A boolean indicating if the string is a palindrome.\n    - The final count $m_f$.\n    - The final count $m_r$.\n    - The final size $s$ of the deque.\n\nFor a palindrome of length $n$, the process removes $\\lfloor n/2 \\rfloor$ pairs of characters, resulting in $m_f = m_r = \\lfloor n/2 \\rfloor$. The final size will be $s = n \\pmod{2}$, which is $0$ for even $n$ and $1$ for odd $n$. If the string is not a palindrome, the process stops at the first mismatch, and $m_f$ and $m_r$ will record the number of matched pairs before the mismatch.\n\n**Complexity Analysis:**\n- The loading phase involves $n$ `push_back` operations, each taking $O(1)$ time, for a total of $O(n)$.\n- The comparison phase runs at most $\\lfloor n/2 \\rfloor$ times. Each iteration involves a constant number of $O(1)$ deque operations. This phase also takes $O(n)$ time.\n- Therefore, the total time complexity of the algorithm is $O(n) + O(n) = O(n)$. The space complexity is $O(n)$ to store the string's characters in the deque of capacity $C = n+1$. This meets the problem's requirements.", "answer": "```python\nimport numpy as np\n\nclass Deque:\n    \"\"\"\n    An array-based double-ended queue (deque) implementation using a circular buffer.\n    \n    This implementation adheres to the problem's specifications, including the\n    capacity rule C = n + 1, and the operational effects on the front (f),\n    rear (r), and size (s) attributes.\n    \"\"\"\n    def __init__(self, capacity: int):\n        \"\"\"\n        Initializes an empty deque with a given capacity.\n        _data is initialized using numpy.empty as required.\n        \"\"\"\n        if capacity  1:\n            raise ValueError(\"Capacity must be at least 1.\")\n        self._capacity = capacity\n        # The problem requires numpy. We use it here to create the array.\n        self._data = np.empty(self._capacity, dtype=object)\n        self._front = 0\n        self._rear = 0\n        self._size = 0\n\n    def __len__(self) - int:\n        \"\"\"Returns the current number of elements in the deque.\"\"\"\n        return self._size\n\n    def is_empty(self) - bool:\n        \"\"\"Returns True if the deque is empty, False otherwise.\"\"\"\n        return self._size == 0\n\n    def is_full(self) - bool:\n        \"\"\"\n        Returns True if the deque is full.\n        Fullness is defined as size reaching capacity - 1, leaving one slot unused.\n        \"\"\"\n        return self._size == self._capacity - 1\n        \n    def push_back(self, item):\n        \"\"\"Adds an item to the rear of the deque.\"\"\"\n        if self.is_full():\n            raise IndexError(\"Deque is full\")\n        self._data[self._rear] = item\n        self._rear = (self._rear + 1) % self._capacity\n        self._size += 1\n\n    def pop_front(self):\n        \"\"\"Removes and returns the item from the front of the deque.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        item = self._data[self._front]\n        self._data[self._front] = None  # Optional: clear the slot\n        self._front = (self._front + 1) % self._capacity\n        self._size -= 1\n        return item\n\n    def pop_back(self):\n        \"\"\"Removes and returns the item from the rear of the deque.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        # Per problem spec: update r, then read at new r\n        self._rear = (self._rear - 1 + self._capacity) % self._capacity\n        item = self._data[self._rear]\n        self._data[self._rear] = None  # Optional: clear the slot\n        self._size -= 1\n        return item\n\n    def peek_front(self):\n        \"\"\"Returns the item at the front of the deque without removing it.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        return self._data[self._front]\n\n    def peek_back(self):\n        \"\"\"Returns the item at the rear of the deque without removing it.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        # Rear pointer r is one past the last element, so we look at (r-1)\n        idx = (self._rear - 1 + self._capacity) % self._capacity\n        return self._data[idx]\n\ndef check_palindrome(input_str: str) - list:\n    \"\"\"\n    Checks if a string is a palindrome using the Deque data structure.\n\n    Args:\n        input_str: The string to check.\n\n    Returns:\n        A list containing:\n        - A boolean indicating if the string is a palindrome.\n        - An integer (m_f) for the number of pop_front operations.\n        - An integer (m_r) for the number of pop_back operations.\n        - An integer (s) for the final size of the deque.\n    \"\"\"\n    n = len(input_str)\n    capacity = n + 1\n    dq = Deque(capacity)\n\n    for char in input_str:\n        dq.push_back(char)\n\n    m_f = 0\n    m_r = 0\n    is_palindrome = True\n\n    while len(dq)  1:\n        front_char = dq.peek_front()\n        back_char = dq.peek_back()\n\n        if front_char == back_char:\n            dq.pop_front()\n            dq.pop_back()\n            m_f += 1\n            m_r += 1\n        else:\n            is_palindrome = False\n            break\n            \n    final_s = len(dq)\n    return [is_palindrome, m_f, m_r, final_s]\n\ndef solve():\n    \"\"\"\n    Runs the palindrome check on the specified test suite and prints the result.\n    \"\"\"\n    test_cases = [\n        \"racecar\",\n        \"abccba\",\n        \"abca\",\n        \"\",\n        \"x\",\n        \"ab\"\n    ]\n\n    results = []\n    for s in test_cases:\n        result = check_palindrome(s)\n        results.append(result)\n\n    # Format the final output string as per the problem specification.\n    # e.g., [[True, 3, 3, 1], [True, 3, 3, 0], ...]\n    output_str = \"[\" + \",\".join(map(str, results)).replace(\" \", \"\") + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3208992"}]}