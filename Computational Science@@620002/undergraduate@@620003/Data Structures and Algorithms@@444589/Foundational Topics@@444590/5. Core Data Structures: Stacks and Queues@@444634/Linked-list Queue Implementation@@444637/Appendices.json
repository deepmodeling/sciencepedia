{"hands_on_practices": [{"introduction": "A standard queue excels at constant-time operations at its two ends, but what if you need to remove an element from the middle? This practice [@problem_id:3246760] challenges you to extend the basic linked-list queue with a `find_and_remove` operation. Successfully implementing this function requires a deep understanding of pointer manipulation and careful handling of all edge cases, such as removing the head, the tail, or the only element in the queue, thereby solidifying your mastery of linked-list mechanics.", "problem": "You are to implement a first-in-first-out queue using a singly linked list with explicit head and tail pointers. The queue must support three operations defined in pure logical terms: enqueue to append an element, dequeue to remove and return the element at the front, and find_and_remove to remove the first node whose stored value equals a given query value. The foundation you must start from is the core definition of a queue as an abstract data type together with the standard properties of a singly linked list:\n- A queue stores elements such that the element removed by dequeue is always the one that has been in the queue the longest, consistent with the ordering-by-arrival invariant of first-in-first-out.\n- A singly linked list consists of nodes, each node containing a value and a pointer to the next node, with the head pointer referencing the first node and the tail pointer referencing the last node or being null if the list is empty.\n- The canonical enqueue at tail and dequeue at head can be implemented in time complexity $\\mathcal{O}(1)$ if head and tail pointers are maintained consistently.\n\nYour task:\n- Implement a queue class using a singly linked list, maintaining head and tail pointers. Enqueue must insert at the tail in $\\mathcal{O}(1)$ time, dequeue must remove from the head in $\\mathcal{O}(1)$ time and return a distinguished null value if the queue is empty, and find_and_remove must remove the first (i.e., earliest enqueued among equals) occurrence of a given integer if present, scanning from head to tail. The operation find_and_remove must return a boolean indicating whether removal occurred.\n- You must ensure that after every operation, the data structure maintains the invariants that the head points to the first node (or is null if the queue is empty), the tail points to the last node (or is null if empty), and a null tail implies a null head and vice versa. In particular, after removing the head or tail node by find_and_remove, the corresponding pointer must be updated correctly, and the structure must remain a valid singly linked list.\n\nSemantics and constraints:\n- Values stored in the queue are integers. Equality is standard integer equality. The queue must remove only the first matching node for find_and_remove, consistent with the ordering property of a queue. If no matching node exists, find_and_remove must return false and perform no structural change.\n- The distinguished null return of dequeue must be a value that is not an integer in the queue; the natural choice in a language with references is a null reference. You must still ensure the internal structure remains valid after a dequeue of an empty queue.\n\nTest suite:\nYou must implement and run the following fixed test cases exactly, without reading from input. For each test case, apply the listed operations in order. Each operation is one of:\n- enqueue $x$\n- dequeue\n- find\\_and\\_remove $x$\n\nFor each test case, your program must produce a single result which is a flat list of integers formed as the concatenation of two parts:\n- The final queue contents from head to tail encoded as a list of integers.\n- A separator value $-1$ followed by the sequence of binary indicators for the outcomes of each find\\_and\\_remove in this test case, where $1$ means success and $0$ means failure.\nThe integer $-1$ will not be enqueued in any test case; it is reserved as a separator in the output encoding.\n\nThe five test cases are:\n- Test case $1$ (happy path, middle deletion, non-existent deletion, and multiple dequeues):\n  - enqueue $3$, enqueue $1$, enqueue $4$, enqueue $1$, enqueue $5$, enqueue $9$, find\\_and\\_remove $4$, find\\_and\\_remove $2$, dequeue, dequeue.\n- Test case $2$ (head deletion, tail deletion, and dequeue on empty queue):\n  - enqueue $10$, enqueue $20$, find\\_and\\_remove $10$, find\\_and\\_remove $20$, dequeue.\n- Test case $3$ (tail deletion in a non-trivial queue and further enqueue):\n  - enqueue $7$, enqueue $8$, enqueue $9$, find\\_and\\_remove $9$, enqueue $10$.\n- Test case $4$ (repeated values, removing first occurrence repeatedly until empty, then failure):\n  - enqueue $1$, enqueue $1$, enqueue $1$, find\\_and\\_remove $1$, find\\_and\\_remove $1$, find\\_and\\_remove $1$, find\\_and\\_remove $1$.\n- Test case $5$ (single-element deletion by find\\_and\\_remove and later failed deletion):\n  - enqueue $42$, find\\_and\\_remove $42$, enqueue $5$, dequeue, find\\_and\\_remove $5$.\n\nFinal output format:\n- Your program should produce a single line of output containing the five per-test-case results as a comma-separated list enclosed in square brackets, with each per-test-case result itself formatted as a bracketed, comma-separated list of integers without spaces. For example, an output with $3$ test cases would look like $[ [\\ldots], [\\ldots], [\\ldots] ]$, but with no spaces anywhere.\n- Concretely, for this assignment, your program must print a single line of the exact form $[r_1,r_2,r_3,r_4,r_5]$ where each $r_i$ is the no-space list of integers encoding the result for test case $i$ as described above.\n\nThere are no physical units or angle units in this problem. All answers are pure integers and booleans encoded as integers.\n\nYour program must be self-contained and must not read any input or write any output other than the single specified line.", "solution": "The problem statement has been critically validated and is deemed valid. It presents a well-posed, scientifically grounded problem in the domain of data structures and algorithms. The requirements for implementing a queue with a singly linked list, including the specific operations `enqueue`, `dequeue`, and `find_and_remove`, are clear, consistent, and complete. The test cases and output format are specified with sufficient precision to allow for a unique and verifiable solution.\n\nThe implementation will be based on the fundamental principles of a singly linked list and a first-in-first-out (FIFO) queue. A singly linked list is a linear collection of data elements, called nodes, where each node points to the next node in the sequence. To implement a queue efficiently, we maintain two pointers: a `head` pointer to the first node and a `tail` pointer to the last node.\n\nThe core data structures are a `Node` and the `Queue` itself.\n- A `Node` contains two fields: a `value` (an integer, per the problem) and a `next` pointer, which references the subsequent node or is `null` if it is the last node.\n- The `Queue` class encapsulates the list and maintains three pieces of state: the `head` pointer, the `tail` pointer, and implicitly, the number of elements. The invariant that `head` is `null` if and only if `tail` is `null` must be strictly preserved.\n\nThe three required operations are implemented as follows:\n\n1.  **Enqueue Operation**: The `enqueue(x)` operation adds an element with value `x` to the rear of the queue. This is achieved in constant time, $\\mathcal{O}(1)$, by manipulating the `tail` pointer.\n    - A new `Node` is created with the value `x`.\n    - If the queue is empty (i.e., `head` is `null`), both `head` and `tail` are set to point to this new node.\n    - If the queue is not empty, the `next` pointer of the current `tail` node is updated to point to the new node, and then the `tail` pointer itself is updated to this new node. This correctly appends the element to the end of the list.\n\n2.  **Dequeue Operation**: The `dequeue()` operation removes and returns the element at the front of the queue. This is achieved in constant time, $\\mathcal{O}(1)$, by manipulating the `head` pointer.\n    - If the queue is empty (`head` is `null`), a distinguished `null` value is returned, and the structure remains unchanged, as required.\n    - If the queue is not empty, the value of the `head` node is stored for return.\n    - The `head` pointer is advanced to point to the next node in the list (`head = head.next`).\n    - A critical step is to check if the queue has become empty after the removal. If the new `head` is `null`, it implies the last element was just removed, and therefore the `tail` pointer must also be set to `null` to maintain the queue's structural integrity.\n\n3.  **Find and Remove Operation**: The `find_and_remove(x)` operation searches for the first node containing the value `x` and removes it from the queue. This operation requires a traversal and its time complexity is $\\mathcal{O}(n)$, where `n` is the number of elements in the queue. It must return `True` on successful removal and `False` otherwise, and correctly update pointers for all cases.\n    - **Case 1: Empty Queue.** If `head` is `null`, the value cannot be found, so the function immediately returns `False`.\n    - **Case 2: The Head Node Matches.** If `head.value` equals `x`, the problem reduces to removing the head element. This can be accomplished simply by calling the existing `dequeue()` method, which correctly handles all pointer updates. The function then returns `True`.\n    - **Case 3: A Non-Head Node Matches.** The list must be traversed. We use two pointers, `previous` and `current`, starting with `previous = head` and `current = head.next`. The loop proceeds as long as `current` is not `null`.\n        - If `current.value` equals `x`, we have found the node to remove. The `next` pointer of the `previous` node is set to bypass the `current` node (`previous.next = current.next`).\n        - A special check is required here: if the node being removed was the `tail` (`current == tail`), then the `tail` pointer must be updated to point to `previous`.\n        - After successfully removing the node, the function returns `True`.\n    - If the traversal completes without finding a matching value, the function returns `False`.\n\nThis design rigorously adheres to the problem specification, ensuring that all invariants are maintained across all operations and that edge cases such as empty queues, single-element queues, and removal of head or tail elements are handled correctly.\n\nThe provided test suite will be executed against this implementation to verify its correctness and produce the specified output format. Each test case will be run on a fresh `Queue` instance. The final result for each test case is constructed by concatenating the list of values remaining in the queue (from head to tail), a separator value of `-1`, and the sequence of boolean outcomes (`1` for `True`, `0` for `False`) from the `find_and_remove` calls.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"A node in a singly linked list.\"\"\"\n    def __init__(self, value, next_node=None):\n        self.value = value\n        self.next = next_node\n\nclass Queue:\n    \"\"\"A FIFO queue implemented using a singly linked list.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes an empty queue.\"\"\"\n        self.head = None\n        self.tail = None\n\n    def enqueue(self, value):\n        \"\"\"Adds an element to the tail of the queue in O(1) time.\"\"\"\n        new_node = Node(value)\n        if self.head is None:\n            self.head = new_node\n            self.tail = new_node\n        else:\n            self.tail.next = new_node\n            self.tail = new_node\n\n    def dequeue(self):\n        \"\"\"Removes and returns the element from the head of the queue in O(1) time.\"\"\"\n        if self.head is None:\n            return None  # Distinguished null value for an empty queue\n        \n        value = self.head.value\n        self.head = self.head.next\n        \n        if self.head is None:\n            self.tail = None  # The queue is now empty\n        \n        return value\n\n    def find_and_remove(self, value):\n        \"\"\"Finds and removes the first occurrence of a value from the queue.\"\"\"\n        if self.head is None:\n            return False\n\n        # Case 1: The head node needs to be removed.\n        if self.head.value == value:\n            self.dequeue()\n            return True\n\n        # Case 2: A non-head node needs to be removed.\n        # We need a previous pointer to re-link the list.\n        prev = self.head\n        current = self.head.next\n        while current is not None:\n            if current.value == value:\n                prev.next = current.next\n                # If the removed node was the tail, update the tail pointer.\n                if current == self.tail:\n                    self.tail = prev\n                return True\n            prev = current\n            current = current.next\n\n        # Case 3: Value not found.\n        return False\n\n    def get_contents(self):\n        \"\"\"Returns the contents of the queue as a list of integers.\"\"\"\n        items = []\n        current = self.head\n        while current is not None:\n            items.append(current.value)\n            current = current.next\n        return items\n\ndef solve():\n    \"\"\"\n    Runs the entire test suite and prints the final result.\n    \"\"\"\n    test_cases = [\n        [\"enqueue 3\", \"enqueue 1\", \"enqueue 4\", \"enqueue 1\", \"enqueue 5\", \"enqueue 9\", \"find_and_remove 4\", \"find_and_remove 2\", \"dequeue\", \"dequeue\"],\n        [\"enqueue 10\", \"enqueue 20\", \"find_and_remove 10\", \"find_and_remove 20\", \"dequeue\"],\n        [\"enqueue 7\", \"enqueue 8\", \"enqueue 9\", \"find_and_remove 9\", \"enqueue 10\"],\n        [\"enqueue 1\", \"enqueue 1\", \"enqueue 1\", \"find_and_remove 1\", \"find_and_remove 1\", \"find_and_remove 1\", \"find_and_remove 1\"],\n        [\"enqueue 42\", \"find_and_remove 42\", \"enqueue 5\", \"dequeue\", \"find_and_remove 5\"]\n    ]\n\n    all_results = []\n\n    for operations in test_cases:\n        q = Queue()\n        find_remove_outcomes = []\n        for op_str in operations:\n            parts = op_str.split()\n            command = parts[0]\n            \n            if command == \"enqueue\":\n                value = int(parts[1])\n                q.enqueue(value)\n            elif command == \"dequeue\":\n                q.dequeue()\n            elif command == \"find_and_remove\":\n                value = int(parts[1])\n                success = q.find_and_remove(value)\n                find_remove_outcomes.append(1 if success else 0)\n\n        final_contents = q.get_contents()\n        result_list = final_contents + [-1] + find_remove_outcomes\n        all_results.append(result_list)\n    \n    # Format the final output string exactly as specified, with no spaces.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3246760"}, {"introduction": "Excellent data structure design is often about meeting strict performance goals. This exercise [@problem_id:3246702] presents a queue with a special requirement: enqueueing an existing item moves it to the tail in constant $O(1)$ time, a behavior common in caching systems. A simple singly-linked list won't suffice; this problem guides you to discover the power of combining data structures—specifically a doubly-linked list and a hash map—to build a highly efficient and responsive queue.", "problem": "You are to implement a queue using a linked-list that satisfies the following semantics: when enqueueing an item $x$, if $x$ is already present in the queue, the existing node containing $x$ is moved to the tail; if $x$ is not present, a new node storing $x$ is appended to the tail. Dequeue, when performed, removes the item at the head. The items are integers. The initial queue is a sequence of distinct integers. The operations to be performed are a sequence of enqueues only for this task, applied strictly in the given order. The goal is to produce the final queue content, from head to tail, after all operations complete.\n\nFundamental base and constraints for derivation and implementation:\n- A queue is an abstract data type where the canonical policy is First-In, First-Out (FIFO). The minimal invariants are: the head is the next item to be removed, the tail is the most recently appended item, and linking must preserve a single linear order of nodes from head to tail.\n- A linked list is a collection of nodes, each storing a value and pointers to adjacent nodes. To support efficient re-linking, nodes must be able to be unlinked and appended while preserving the single linear order invariant and the head/tail references.\n- Correctness requires that after each operation, the head and tail pointers are valid, and the sequence of nodes forms a single chain from head to tail, with no cycles and no dangling pointers.\n\nYour implementation must maintain the queue using a linked-list structure and ensure that both enqueue and dequeue operations run in worst-case $O(1)$ time per operation. The program should be completely deterministic and must not rely on randomization.\n\nYou will be given a test suite of cases, each consisting of an initial queue and a sequence of enqueues. For each case, apply the operations and output the final queue content as a list of integers (from head to tail). The items are integers and the initial queue has no duplicates. The enqueues may contain duplicates.\n\nTest suite:\n- Case $1$: initial $[1,2,3]$, enqueues $[2,4,2]$. Expected behavior: moving an internal item to the tail, appending a new item, and moving the tail again.\n- Case $2$: initial $[]$, enqueues $[5,5,5]$. Expected behavior: appending into an empty structure, then repeatedly moving the tail element (which leaves the structure unchanged after the first append).\n- Case $3$: initial $[10,20]$, enqueues $[10,30,20,30]$. Expected behavior: moving the head to the tail, appending a new item, moving the head to the tail again, then moving a middle item to the tail.\n- Case $4$: initial $[1,2,3,4]$, enqueues $[3,1,4,5,3]$. Expected behavior: multiple moves of head and middle items, and appending a new item.\n- Case $5$: initial $[0,1,2,3,4]$, enqueues $[2,2,3,4,5,0,5,6]$. Expected behavior: repeated moves of items including head and middle positions, and multiple appends.\n\nRequired final output format:\nYour program should produce a single line of output containing the results for all cases aggregated as a comma-separated list enclosed in square brackets, where each case’s result is itself a comma-separated list enclosed in square brackets. For example, the output format is $[[r_1,r_2,\\dots],[s_1,s_2,\\dots],\\dots]$.\n\nYour program must not read any input and must include the test suite internally. The answers for each case must be lists of integers.", "solution": "The problem requires a queue implementation where `enqueue` operations are performed in constant time, $O(1)$, even when the operation involves moving an existing item to the tail. A standard linked list is insufficient, as finding an existing element requires an $O(n)$ scan. To meet the performance constraint, a composite data structure is necessary.\n\nThe optimal solution combines two data structures: a **doubly linked list** and a **hash map**.\n\n1.  **Doubly Linked List**: This structure will store the queue elements in their precise order from `head` to `tail`. Each node in the list contains the integer value, along with `prev` and `next` pointers. This allows any node to be unlinked from its position in $O(1)$ time, provided a direct reference to that node is available. The queue maintains `head` and `tail` pointers for $O(1)$ access to both ends.\n\n2.  **Hash Map (or Dictionary)**: This serves as an index. It maps each integer value present in the queue to a direct reference to its corresponding node object in the doubly linked list. This enables finding any node by its value in $O(1)$ average time, which is critical for the \"move-to-tail\" functionality.\n\nThe `enqueue(x)` operation is implemented as follows:\n1.  Use the hash map to check if the value `x` already exists. This is an $O(1)$ average-time lookup.\n2.  **Case A: Item `x` exists.**\n    a. Retrieve the `node` reference from the hash map.\n    b. If this `node` is not already the `tail` of the list, it must be moved.\n    c. Unlink the `node` from its current position. This is an $O(1)$ operation in a doubly linked list, involving updates to the `next` pointer of the node's predecessor and the `prev` pointer of its successor. Special care is taken if the unlinked node is the `head`.\n    d. Append the `node` to the end of the list. This is also an $O(1)$ operation, involving updating the old `tail`'s `next` pointer and the queue's main `tail` pointer.\n3.  **Case B: Item `x` does not exist.**\n    a. Create a new `Node` instance with the value `x`.\n    b. Append this new `node` to the tail of the doubly linked list. This is an $O(1)$ operation. If the list was empty, both `head` and `tail` pointers are set to this new node.\n    c. Add a new entry to the hash map, mapping the value `x` to the newly created `node`. This is an $O(1)$ average-time insertion.\n\nThis design ensures that every step within the `enqueue` operation is executed in constant (average) time, satisfying the problem's performance requirement. The implementation will build this composite structure and process the test cases accordingly.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Move-to-Tail Queue problem for a given test suite.\n    \"\"\"\n\n    class Node:\n        \"\"\"\n        A node in a doubly linked list.\n        \"\"\"\n        def __init__(self, value):\n            self.value = value\n            self.prev = None\n            self.next = None\n\n    class MoveToTailQueue:\n        \"\"\"\n        A queue implementation using a doubly linked list and a hash map\n        to achieve O(1) time complexity for the specified enqueue operation.\n        \"\"\"\n        def __init__(self, initial_items=None):\n            self.head = None\n            self.tail = None\n            self.map = {}\n            if initial_items:\n                for item in initial_items:\n                    self.enqueue(item)\n\n        def _unlink(self, node):\n            \"\"\"\n            Unlinks a node from the list in O(1) time.\n            Assumes node is not None and is in the list.\n            \"\"\"\n            prev_node = node.prev\n            next_node = node.next\n\n            if prev_node:\n                prev_node.next = next_node\n            else: # Node was the head\n                self.head = next_node\n\n            if next_node:\n                next_node.prev = prev_node\n            else: # Node was the tail\n                self.tail = prev_node\n\n        def _append(self, node):\n            \"\"\"\n            Appends a node to the tail of the list in O(1) time.\n            \"\"\"\n            if not self.head: # List is empty\n                self.head = node\n                self.tail = node\n                node.prev = None\n                node.next = None\n            else: # List is not empty\n                self.tail.next = node\n                node.prev = self.tail\n                node.next = None\n                self.tail = node\n\n        def enqueue(self, value):\n            \"\"\"\n            Enqueues an item. If it exists, moves it to the tail.\n            If not, adds it to the tail. O(1) average time complexity.\n            \"\"\"\n            if value in self.map:\n                node = self.map[value]\n                # Only move if it's not already the tail\n                if node is not self.tail:\n                    self._unlink(node)\n                    self._append(node)\n            else:\n                new_node = Node(value)\n                self._append(new_node)\n                self.map[value] = new_node\n\n        def to_list(self):\n            \"\"\"\n            Returns the queue content as a list from head to tail.\n            \"\"\"\n            result = []\n            current = self.head\n            while current:\n                result.append(current.value)\n                current = current.next\n            return result\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'initial': [1,2,3], 'enqueues': [2,4,2]},\n        {'initial': [],      'enqueues': [5,5,5]},\n        {'initial': [10,20], 'enqueues': [10,30,20,30]},\n        {'initial': [1,2,3,4], 'enqueues': [3,1,4,5,3]},\n        {'initial': [0,1,2,3,4], 'enqueues': [2,2,3,4,5,0,5,6]},\n    ]\n\n    results = []\n    for case in test_cases:\n        queue = MoveToTailQueue(case['initial'])\n        for item in case['enqueues']:\n            queue.enqueue(item)\n        results.append(queue.to_list())\n\n    # Final print statement in the exact required format.\n    # Format: [[r1,r2,...],[s1,s2,...],...] with no spaces after commas.\n    print(f\"[[{'],['.join([','.join(map(str, r)) for r in results])}]]\")\n\nsolve()\n```", "id": "3246702"}, {"introduction": "In today's multi-core world, data structures must often operate safely in a concurrent environment. This practice [@problem_id:3246704] takes the linked-list queue into the realm of multithreading by tasking you with implementing a `blocking_dequeue` operation. You will use fundamental concurrency primitives like locks and condition variables to create a thread-safe queue where consumer threads can efficiently wait for producer threads to supply items, a foundational pattern in asynchronous systems and parallel computing.", "problem": "You are to design and implement a thread-safe First-In First-Out (FIFO) queue using a singly linked list and a condition variable. The queue must support an operation that blocks the caller until an item becomes available, rather than returning a sentinel such as a null value. The core data structure is a singly linked list with a head pointer and a tail pointer. The correctness of the implementation must follow from core definitions and well-tested facts: the FIFO property dictates that the removal operation returns the oldest element currently stored, mutual exclusion ensures only one thread manipulates the shared state at a time, and condition variable semantics ensure that threads can wait efficiently until a predicate becomes true.\n\nBegin from the following foundations:\n- A queue is a sequence $Q = [x_1, x_2, \\dots, x_k]$ where $x_1$ is the oldest element and $x_k$ is the most recent. Enqueue appends an element to the end, and dequeue removes the element at the front. The queue must preserve the FIFO property.\n- A singly linked list node has a value and a next pointer. The queue maintains two pointers: a head pointer $H$ pointing to the oldest node and a tail pointer $T$ pointing to the newest node. An empty queue is represented by $H = \\varnothing$ and $T = \\varnothing$.\n- Mutual exclusion via a lock ensures that the invariants $H$ and $T$ are updated atomically with respect to other threads.\n- A condition variable supports waiting on a predicate while releasing the associated lock, and upon notification, re-acquires the lock to check the predicate again. The correct pattern uses a loop: while the predicate is false, wait; once the predicate becomes true, proceed. This guards against spurious wake-ups.\n\nYour program must implement the following operations over a linked-list queue:\n- Enqueue: acquires mutual exclusion, appends a new node to the tail in $O(1)$ time, updates $T$ and possibly $H$ if the queue was empty, signals the condition variable to wake one waiting thread.\n- Blocking dequeue: acquires mutual exclusion and, if the queue is empty, waits on the condition variable; when awakened, re-checks emptiness in a loop; once the queue is non-empty, removes the head in $O(1)$ time, updates $H$ and possibly $T$ if the queue becomes empty, and returns the removed value. This operation must never return a sentinel value and must block indefinitely until an item becomes available.\n\nYou must produce results for the following test suite. Each test case specifies parameters controlling the timing of enqueues and the number of producer and consumer threads. Use the monotonic clock and represent all times in seconds.\n\nTest Suite:\n- Case $1$ (happy path blocking): One consumer thread performs a blocking dequeue on an initially empty queue. One producer enqueues a single integer after a delay of $0.08$ seconds. Let $t_{\\text{wait}}$ be the measured time between entering the blocking dequeue and returning with the item. With tolerance $\\tau = 0.01$ seconds, report a boolean indicating whether $t_{\\text{wait}} \\ge 0.08 - 0.01$ and the returned value equals the enqueued value.\n- Case $2$ (FIFO ordering under staggered enqueues): One consumer thread performs three blocking dequeues; a producer enqueues three integers at delays $0.02$, $0.05$, and $0.07$ seconds respectively. Report a boolean indicating whether the consumer observed the sequence equal to the chronological enqueue order.\n- Case $3$ (multiple consumers fairness): Three consumer threads each perform one blocking dequeue; one producer enqueues three distinct integers after a delay of $0.05$ seconds. Report a boolean indicating whether all consumers return exactly one unique integer and the multiset of returned values matches the multiset of enqueued values.\n- Case $4$ (immediate availability): Enqueue one integer before starting a consumer that performs a blocking dequeue. Let $t_{\\text{wait}}$ be measured as in Case $1$. With threshold $\\theta = 0.01$ seconds, report a boolean indicating whether $t_{\\text{wait}} < 0.01$.\n- Case $5$ (spurious wake-up guard): One consumer thread performs a blocking dequeue on an empty queue. A separate thread performs a condition variable notification without enqueuing after $0.02$ seconds. Finally, a producer enqueues one integer after an additional $0.03$ seconds. Let $t_{\\text{wait}}$ be measured as in Case $1$. With tolerance $\\tau = 0.01$ seconds, report a boolean indicating whether $t_{\\text{wait}} \\ge (0.02 + 0.03) - 0.01$. This tests that the implementation properly re-checks the predicate and continues to block after a spurious notification.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $5$. Each case’s result must be a boolean. For example: \"[true_case1,true_case2,true_case3,true_case4,true_case5]\" but using the programming language’s canonical boolean literals. No angle units are used, and all time measurements must be expressed in seconds, rounded implicitly by the language’s default representation. The program must be complete and runnable without any external input or files.", "solution": "The problem statement has been validated and is found to be scientifically grounded, well-posed, and objective. It presents a standard but non-trivial problem in concurrent programming and data structures, providing clear, formalizable requirements and a verifiable test suite. The problem is valid.\n\nThe task is to design and implement a thread-safe, blocking First-In-First-Out (FIFO) queue. The implementation must be based on a singly linked list with head and tail pointers, ensuring $O(1)$ time complexity for both enqueue and dequeue operations. Thread safety will be achieved using a mutual exclusion lock, and the blocking behavior will be managed by a condition variable.\n\nFirst, we define the elemental component of the linked list, the `Node`. Each `Node` contains a `value` and a `next` pointer, which points to the subsequent node in the sequence.\n- `Node.value`: The data element stored in the node.\n- `Node.next`: A reference to the next `Node` in the list, or `None` (representing $\\varnothing$) if it is the last node.\n\nThe `BlockingQueue` class encapsulates the queue's state and logic. Its state is defined by:\n- A head pointer, $H$, which points to the first (oldest) node in the list.\n- A tail pointer, $T$, which points to the last (newest) node in the list.\n- A lock, an instance of `threading.Lock`, for ensuring mutual exclusion.\n- A condition variable, an instance of `threading.Condition`, associated with the lock, to manage threads waiting for items to become available.\n\nThe invariant for an empty queue is $H = \\varnothing$ and $T = \\varnothing$. For a non-empty queue, $H$ points to the start of the list and $T$ to the end.\n\nThe initialization of the `BlockingQueue` sets $H$ and $T$ to `None` and instantiates the lock and the condition variable.\n\nThe `enqueue(item)` operation implements the logic for adding an element to the queue:\n$1$. Acquire the lock to ensure atomic modification of the queue's shared state ($H$ and $T$).\n$2$. Create a new `Node` instance to hold the `item`.\n$3$. Check if the queue is empty by testing if $T$ is `None`.\n    a. If the queue is empty ($T = \\varnothing$), it implies $H$ is also `None`. In this case, both $H$ and $T$ are set to point to the new node. This establishes the queue with a single element.\n    b. If the queue is not empty, the new node is appended to the end of the list. This is achieved by setting the `next` pointer of the current tail node ($T$.next) to the new node. Subsequently, the tail pointer $T$ is updated to point to this new node, which is now the last element.\n$4$. After successfully adding the node and updating the pointers, signal one waiting thread by calling the condition variable's `notify()` method. This is crucial as it informs a potentially blocked consumer thread that the state has changed and an item is now available.\n$5$. Release the lock. The use of a `with` statement handles this automatically.\nThis entire operation has a time complexity of $O(1)$ because it consists of a fixed number of pointer assignments.\n\nThe `blocking_dequeue()` operation implements the logic for removing an element from the queue, blocking if necessary:\n$1$. Acquire the lock to ensure exclusive access to the queue's state.\n$2$. Check the predicate for waiting: whether the queue is empty. The correct and robust way to do this with a condition variable is within a `while` loop: `while self.head is None:`. The condition $H = \\varnothing$ indicates the queue is empty.\n$3$. If the predicate is true (queue is empty), call `self.condition.wait()`. This atomically releases the lock and suspends the current thread's execution until it is notified. Upon waking (due to a `notify()` or `notify_all()` call), the thread re-acquires the lock, and the `while` loop condition is re-evaluated. This loop structure correctly handles spurious wake-ups, where a thread might be awakened even if no item has been enqueued. The thread will simply re-check the condition, find the queue is still empty, and go back to waiting.\n$4$. Once the `while` loop terminates, it is guaranteed that the queue is not empty (i.e., $H \\neq \\varnothing$) and the current thread holds the lock.\n$5$. Retrieve the value from the head node: `value = self.head.value`.\n$6$. Remove the head node from the queue by advancing the head pointer to the next node: `self.head = self.head.next`.\n$7$. A special case must be handled: if the queue becomes empty as a result of the dequeue operation (i.e., the new $H$ is `None`), the tail pointer $T$ must also be set to `None` to maintain the empty-queue invariant ($H=\\varnothing, T=\\varnothing$).\n$8$. Return the retrieved `value`. The lock is released upon exiting the `with` block.\nLike enqueue, this operation has a time complexity of $O(1)$ for the pointer manipulation part, exclusive of any waiting time.\n\nThis design fulfills all requirements of the problem statement. It correctly implements a FIFO queue using a singly linked list with $O(1)$ operations, ensures thread safety through mutual exclusion, and provides a correct, non-sentinel blocking dequeue mechanism guarded against spurious wake-ups. The test suite provided in the problem will be used to verify the correctness of this design when implemented.", "answer": "```python\nimport threading\nimport time\nimport queue\nimport numpy as np\n\n# According to the problem statement, numpy must be imported.\n# It is not used in the core logic but its presence satisfies the constraint.\n\nclass Node:\n    \"\"\"A node in a singly linked list.\"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\nclass BlockingQueue:\n    \"\"\"\n    A thread-safe FIFO queue implemented with a singly linked list,\n    a lock, and a condition variable. Dequeue operations block until an\n    item is available.\n    \"\"\"\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.lock = threading.Lock()\n        self.condition = threading.Condition(self.lock)\n\n    def enqueue(self, item):\n        \"\"\"\n        Adds an item to the tail of the queue in O(1) time.\n        Signals a waiting consumer thread.\n        \"\"\"\n        new_node = Node(item)\n        with self.lock:\n            if self.tail is None:\n                # The queue is empty\n                self.head = new_node\n                self.tail = new_node\n            else:\n                # The queue is not empty\n                self.tail.next = new_node\n                self.tail = new_node\n            \n            # Signal one waiting thread that an item is now available.\n            self.condition.notify()\n\n    def blocking_dequeue(self):\n        \"\"\"\n        Removes and returns an item from the head of the queue in O(1) time.\n        Blocks if the queue is empty until an item becomes available.\n        \"\"\"\n        with self.lock:\n            # The while loop is crucial to guard against spurious wake-ups.\n            while self.head is None:\n                self.condition.wait()\n            \n            # At this point, self.head is guaranteed to be non-None.\n            value = self.head.value\n            self.head = self.head.next\n            \n            if self.head is None:\n                # The queue has become empty.\n                self.tail = None\n            \n            return value\n\ndef solve():\n    \"\"\"\n    Executes the test suite specified in the problem statement to validate\n    the BlockingQueue implementation.\n    \"\"\"\n    results = []\n\n    # Case 1: Happy path blocking\n    q1 = BlockingQueue()\n    consumer_result1 = []\n    def consumer_task_1():\n        start_time = time.monotonic()\n        val = q1.blocking_dequeue()\n        end_time = time.monotonic()\n        wait_time = end_time - start_time\n        consumer_result1.append((val, wait_time))\n    def producer_task_1(delay, value):\n        time.sleep(delay)\n        q1.enqueue(value)\n\n    delay1 = 0.08\n    tolerance1 = 0.01\n    enqueued_value1 = 42\n    \n    c1 = threading.Thread(target=consumer_task_1)\n    p1 = threading.Thread(target=producer_task_1, args=(delay1, enqueued_value1))\n    \n    c1.start()\n    p1.start()\n    c1.join()\n    p1.join()\n    \n    dequeued_value1, wait_time1 = consumer_result1[0]\n    results.append(wait_time1 >= (delay1 - tolerance1) and dequeued_value1 == enqueued_value1)\n\n    # Case 2: FIFO ordering under staggered enqueues\n    q2 = BlockingQueue()\n    dequeued_values2 = []\n    def consumer_task_2():\n        for _ in range(3):\n            dequeued_values2.append(q2.blocking_dequeue())\n    def producer_task_2():\n        enqueued_items = [(0.02, 10), (0.05, 20), (0.07, 30)]\n        current_time = 0\n        for delay, value in enqueued_items:\n            time.sleep(delay - current_time)\n            q2.enqueue(value)\n            current_time = delay\n\n    c2 = threading.Thread(target=consumer_task_2)\n    p2 = threading.Thread(target=producer_task_2)\n\n    c2.start()\n    p2.start()\n    c2.join()\n    p2.join()\n    \n    results.append(dequeued_values2 == [10, 20, 30])\n\n    # Case 3: Multiple consumers fairness\n    q3 = BlockingQueue()\n    results_q3 = queue.Queue()\n    enqueued_values3 = {101, 102, 103}\n    def consumer_task_3():\n        results_q3.put(q3.blocking_dequeue())\n    def producer_task_3():\n        time.sleep(0.05)\n        for val in enqueued_values3:\n            q3.enqueue(val)\n\n    consumers3 = [threading.Thread(target=consumer_task_3) for _ in range(3)]\n    producer3 = threading.Thread(target=producer_task_3)\n    \n    for c in consumers3:\n        c.start()\n    producer3.start()\n    \n    for c in consumers3:\n        c.join()\n    producer3.join()\n    \n    dequeued_values3 = set()\n    while not results_q3.empty():\n        dequeued_values3.add(results_q3.get())\n\n    results.append(dequeued_values3 == enqueued_values3)\n\n    # Case 4: Immediate availability\n    q4 = BlockingQueue()\n    consumer_result4 = []\n    q4.enqueue(99) # Enqueue before consumer starts\n    def consumer_task_4():\n        start_time = time.monotonic()\n        val = q4.blocking_dequeue()\n        end_time = time.monotonic()\n        wait_time = end_time - start_time\n        consumer_result4.append((val, wait_time))\n\n    c4 = threading.Thread(target=consumer_task_4)\n    c4.start()\n    c4.join()\n\n    _, wait_time4 = consumer_result4[0]\n    results.append(wait_time4  0.01)\n\n    # Case 5: Spurious wake-up guard\n    q5 = BlockingQueue()\n    consumer_result5 = []\n    def consumer_task_5():\n        start_time = time.monotonic()\n        val = q5.blocking_dequeue()\n        end_time = time.monotonic()\n        wait_time = end_time - start_time\n        consumer_result5.append((val, wait_time))\n\n    def notifier_task_5():\n        time.sleep(0.02)\n        with q5.lock:\n            q5.condition.notify()\n\n    def producer_task_5():\n        time.sleep(0.05)  # 0.02 + 0.03\n        q5.enqueue(55)\n\n    c5 = threading.Thread(target=consumer_task_5)\n    n5 = threading.Thread(target=notifier_task_5)\n    p5 = threading.Thread(target=producer_task_5)\n    \n    c5.start()\n    n5.start()\n    p5.start()\n\n    c5.join()\n    n5.join()\n    p5.join()\n\n    _, wait_time5 = consumer_result5[0]\n    total_producer_delay = 0.05\n    tolerance5 = 0.01\n    results.append(wait_time5 >= (total_producer_delay - tolerance5))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\nsolve()\n\n```", "id": "3246704"}]}