{"hands_on_practices": [{"introduction": "This first exercise challenges you to determine if a singly linked list is a palindrome. Due to the list's unidirectional nature, this problem provides a classic showcase for the contrasting strengths of recursive and iterative solutions. You will explore how recursion's implicit call stack can elegantly solve the problem of backward traversal, while an iterative approach demands clever pointer manipulation to achieve the same goal in $\\mathcal{O}(1)$ space [@problem_id:3265361].", "problem": "You are given the task of designing and implementing two algorithms to determine whether a finite singly linked list of integers is a palindrome, in the context of recursion versus iteration in data structures and algorithms. A palindrome is a sequence that reads the same forward and backward. Formally, for a sequence of node values $\\{a_1, a_2, \\dots, a_n\\}$, the sequence is palindromic if and only if $a_i = a_{n+1-i}$ for all $i \\in \\{1, 2, \\dots, n\\}$, where $n$ is the number of nodes. The linked list is singly linked, meaning each node contains a single pointer to its successor.\n\nFundamental base for reasoning:\n- Definition of a singly linked list: a collection of nodes where each node stores a value and a pointer to the next node; the last node points to null.\n- Definition of a palindrome: a sequence $\\{a_1, a_2, \\dots, a_n\\}$ that satisfies $a_i = a_{n+1-i}$ for all valid indices $i$.\n- Recursion uses the process of solving a problem by reducing it to subproblems of the same form until reaching a base case. Recursion leverages the call stack, which is Last-In, First-Out (LIFO), to remember state across calls.\n- Iteration uses explicit loops and pointer manipulation; in a singly linked list, backward traversal is not directly supported.\n\nYour program must implement and compare two distinct approaches:\n1. A recursive solution that uses the call stack to simulate a reverse traversal: the recursive function must descend to the end of the list and, on unwinding, compare node values from the tail with a forward-moving pointer from the head. This approach must operate in time complexity $\\mathcal{O}(n)$ and space complexity $\\mathcal{O}(n)$ due to the call stack.\n2. An iterative solution that does not rely on recursion. It must operate in time complexity $\\mathcal{O}(n)$ and may require either a second pass over the list or extra space. One valid approach is to use two pointers to locate the midpoint, reverse the second half in-place, and then compare corresponding nodes from the first half and the reversed second half; this uses a second pass for reversal and comparison and operates in space complexity $\\mathcal{O}(1)$ auxiliary memory.\n\nInput model and test suite specification:\n- There is no external input. The program must internally construct singly linked lists from the following test suite of arrays (each array denotes the sequence of node values from head to tail):\n  - Test case $1$: $\\left[\\,\\right]$ (empty list)\n  - Test case $2$: $\\left[\\,42\\,\\right]$\n  - Test case $3$: $\\left[\\,1, 2, 2, 1\\,\\right]$\n  - Test case $4$: $\\left[\\,1, 2, 3, 2, 1\\,\\right]$\n  - Test case $5$: $\\left[\\,1, 2, 3, 4\\,\\right]$\n  - Test case $6$: $\\left[\\,3, 4, 5, 4, 6\\,\\right]$\n  - Test case $7$: $\\left[\\,0, 0\\,\\right]$\n  - Test case $8$: $\\left[\\,{-1}, 2, {-1}\\,\\right]$\n- For each test case, construct two separate linked lists (to avoid interference between the methods) and run both the iterative and the recursive algorithms.\n\nAnswer specification:\n- For each test case $i$, produce two boolean results: the iterative method’s result followed by the recursive method’s result. The final output is a single flat list aggregating all results across all test cases in order, so the output has $2 \\times 8 = 16$ entries.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$). As an example of formatting, booleans are printed as $\\text{True}$ or $\\text{False}$.\n- The only allowed types in the final aggregate list are booleans.\n\nScientific realism and constraints:\n- Treat the empty list as palindromic.\n- Handle both even-length and odd-length lists correctly.\n- Ensure the algorithms adhere to the specified time and space complexity constraints for their respective approaches.", "solution": "The validity of the problem statement has been confirmed. It is a well-posed, scientifically grounded problem from the domain of data structures and algorithms, with clear and complete specifications. I will now proceed with the solution.\n\nThe problem requires the implementation of two distinct algorithms to determine if a singly linked list is a palindrome. A sequence $\\{a_1, a_2, \\dots, a_n\\}$ is a palindrome if $a_i = a_{n+1-i}$ for all $i \\in \\{1, \\dots, n\\}$. The core challenge stems from the unidirectional nature of a singly linked list, which prohibits trivial backward traversal.\n\n### 1. Iterative Approach\n\nThe iterative solution must operate with a time complexity of $\\mathcal{O}(n)$ and an auxiliary space complexity of $\\mathcal{O}(1)$. This is achieved through a multi-pass algorithm that manipulates the list's pointers in-place.\n\n**Principle:** The fundamental idea is to compare the first half of the list with the reversed second half.\n1.  **Midpoint Finding:** The first step is to locate the middle of the linked list. This is efficiently done using the \"slow and fast pointer\" technique. Two pointers, `slow` and `fast`, are initialized to the head of the list. In each iteration of a loop, `slow` advances by one node, while `fast` advances by two. When the `fast` pointer reaches the end of the list (or the node just before the end), the `slow` pointer will be positioned at the last node of the first half. This pass takes $\\mathcal{O}(n)$ time.\n2.  **Reversing the Second Half:** The sublist corresponding to the second half, which begins at the node immediately following the `slow` pointer, is reversed in-place. This is a standard list reversal algorithm that iterates through the sublist, changing each node's `next` pointer to refer to its predecessor. This operation also requires $\\mathcal{O}(n)$ time as it traverses half the list.\n3.  **Comparison:** Two pointers are initialized: one at the head of the original list (the start of the first half) and the other at the head of the newly reversed second half. These pointers are advanced simultaneously, and their corresponding node values are compared. If a mismatch is found at any point, the list is not a palindrome. If the traversal completes without mismatches, the list is a palindrome. This comparison pass takes $\\mathcal{O}(n)$ time.\n4.  **Restoration (Optional):** To be a non-destructive function, the list's original structure can be restored by reversing the second half again and re-linking it to the end of the first half. This step has the same $\\mathcal{O}(n)$ complexity as the first reversal.\n\nThe overall time complexity is the sum of these linear passes, which remains $\\mathcal{O}(n)$. The space complexity is $\\mathcal{O}(1)$ as only a few extra pointers are used, irrespective of the list's size $n$.\n\n### 2. Recursive Approach\n\nThe recursive solution must meet a time complexity of $\\mathcal{O}(n)$ and a space complexity of $\\mathcal{O}(n)$, with the space usage attributed to the function call stack.\n\n**Principle:** This approach leverages the LIFO (Last-In, First-Out) property of the function call stack to simulate a backward traversal. The comparison logic is executed as the recursion unwinds.\n1.  **Forward Pointer:** A pointer, let's call it `front_pointer`, is maintained to traverse the list from head to tail. This pointer is defined in a scope accessible to all recursive calls (e.g., as a `nonlocal` variable in Python, or an instance variable in a class).\n2.  **Recursive Traversal:** A recursive function, let's call it `check(current_node)`, is defined. It first calls itself with `check(current_node.next)`, effectively traversing to the end of the list. The base case for the recursion is when `current_node` is null (i.e., we are past the tail).\n3.  **Comparison on Unwind:** After the recursive call returns, the execution is at the \"unwinding\" phase. At this point, `current_node` represents a node from the second half of the list, moving from tail to middle, while `front_pointer` points to a node from the first half, moving from head to middle. The values of the nodes pointed to by `current_node` and `front_pointer` are compared.\n4.  **State Propagation:** If the values match, `front_pointer` is advanced to its next node, and the function returns `True`. If there is a mismatch, or if a deeper recursive call returned `False`, the function immediately propagates `False` up the call stack, halting further comparisons.\n\nThe time complexity is $\\mathcal{O}(n)$ because each node is visited once during the recursive descent and once during the unwind. The space complexity is $\\mathcal{O}(n)$ because the maximum depth of the recursion call stack is equal to the number of nodes, $n$.\n\nBoth algorithms correctly solve the problem within the specified constraints, offering a clear contrast between iterative, pointer-manipulation techniques and recursive, stack-based logic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\nclass ListNode:\n    \"\"\"\n    Definition for a singly-linked list node.\n    \"\"\"\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n    def __repr__(self):\n        return f\"ListNode({self.val})\"\n\ndef build_linked_list(arr):\n    \"\"\"\n    Constructs a singly linked list from a Python list of values.\n    \"\"\"\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef is_palindrome_iterative(head: ListNode | None) -> bool:\n    \"\"\"\n    Determines if a linked list is a palindrome using an iterative approach.\n    Time complexity: O(n), Space complexity: O(1).\n    \"\"\"\n    if not head or not head.next:\n        return True\n\n    # 1. Find the end of the first half using the slow/fast pointer method.\n    slow = head\n    fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # 2. Reverse the second half of the list.\n    def reverse_list(node: ListNode | None) -> ListNode | None:\n        prev_node = None\n        curr_node = node\n        while curr_node:\n            next_temp = curr_node.next\n            curr_node.next = prev_node\n            prev_node = curr_node\n            curr_node = next_temp\n        return prev_node\n\n    second_half_head = reverse_list(slow.next)\n    \n    # 3. Compare the first half with the reversed second half.\n    first_half_ptr = head\n    second_half_ptr = second_half_head\n    is_palindrome = True\n    while second_half_ptr:\n        if first_half_ptr.val != second_half_ptr.val:\n            is_palindrome = False\n            break\n        first_half_ptr = first_half_ptr.next\n        second_half_ptr = second_half_ptr.next\n        \n    # 4. Restore the list (optional, but good practice).\n    slow.next = reverse_list(second_half_head)\n    \n    return is_palindrome\n\ndef is_palindrome_recursive(head: ListNode | None) -> bool:\n    \"\"\"\n    Determines if a linked list is a palindrome using a recursive approach.\n    Time complexity: O(n), Space complexity: O(n) for the call stack.\n    \"\"\"\n    front_pointer = head\n\n    def check_recursively(current_node: ListNode | None) -> bool:\n        nonlocal front_pointer\n        if current_node:\n            # Recurse to the end of the list.\n            if not check_recursively(current_node.next):\n                return False\n            \n            # On unwind, compare the current node with the front pointer.\n            if front_pointer.val != current_node.val:\n                return False\n            \n            # Advance the front pointer.\n            front_pointer = front_pointer.next\n        return True\n\n    return check_recursively(head)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        [],\n        [42],\n        [1, 2, 2, 1],\n        [1, 2, 3, 2, 1],\n        [1, 2, 3, 4],\n        [3, 4, 5, 4, 6],\n        [0, 0],\n        [-1, 2, -1],\n    ]\n\n    results = []\n    for case_arr in test_cases:\n        # Create two separate lists for each method to avoid interference.\n        list_for_iterative = build_linked_list(case_arr)\n        list_for_recursive = build_linked_list(case_arr)\n\n        # Run the iterative algorithm.\n        result_iterative = is_palindrome_iterative(list_for_iterative)\n        results.append(result_iterative)\n\n        # Run the recursive algorithm.\n        result_recursive = is_palindrome_recursive(list_for_recursive)\n        results.append(result_recursive)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3265361"}, {"introduction": "Moving from a simple linear structure to a tree-like one, this practice involves \"flattening\" a multi-level linked list into a single-level list. This task requires a depth-first traversal, a natural fit for recursion. By implementing both a recursive solution and an iterative one using an explicit stack, you will gain a concrete understanding of how the function call stack's mechanism can be simulated manually, making the \"magic\" of recursion transparent [@problem_id:3265439].", "problem": "You are given a multi-level singly linked list where each node contains an integer value and up to two pointers: a next pointer and a child pointer. The next pointer links nodes along a primary level, and the child pointer may point to the head of another singly linked list (whose nodes may themselves have child pointers), forming a finite directed acyclic structure. The task is to implement two functions to flatten the entire structure into a single-level singly linked list in depth-first pre-order, one using recursion and the other using an explicit stack for iteration, and then to verify that both methods produce identical output.\n\nStart from the following fundamental base:\n- A singly linked list is a sequence of nodes, where each node contains a value and a pointer to the next node. In this problem, a node may also contain a pointer to a child list. There are no cycles; therefore, traversal terminates.\n- A depth-first traversal processes a node before its descendants and ensures that the traversal respects Last-In First-Out (LIFO) order among outstanding next pointers when descending into children. This is equivalent to using an implicit call stack in recursion or an explicit stack in iteration.\n\nFormally, define the flattening semantics as follows. Let the multi-level list be a finite directed acyclic graph of nodes with at most one outgoing edge of type next and at most one outgoing edge of type child. The flatten operation produces a single-level list by:\n- Visiting a node $x$, outputting $x$’s value.\n- If $x$ has a child pointer to the head of a child list, completely flatten the child list next, in order, before continuing with $x$’s original next successor.\n- After flattening, all child pointers must be set to null, and the next pointers must form the single-level list that matches the described depth-first pre-order.\nThis is a strict pre-order traversal on the implicit tree-like expansion induced by child edges, with the invariant that a node’s child list is spliced immediately after the node and the original next successor resumes after the tail of the spliced child list.\n\nImplement two functions:\n- A recursion-based flattener that uses the implicit call stack to descend into child lists and returns the head of the flattened list.\n- An iteration-based flattener that uses an explicit stack data structure to simulate the LIFO behavior of the call stack.\n\nConstraints and assumptions:\n- Node values are integers. All values are unique within a test case for clarity.\n- There are no cycles; each pointer graph is finite and acyclic.\n- Both implementations must perform the flatten in-place, adjusting pointers without allocating new nodes, and must set all child pointers to null.\n\nTest suite and parameters to cover multiple facets:\n- Case $1$ (boundary: empty structure): top-level chain is empty, i.e., head is null. Expected flattened order is the empty list $[]$.\n- Case $2$ (boundary: single node): top-level next chain $1$. No children. Expected flattened order is $[1]$.\n- Case $3$ (general case with multiple children and nested children): top-level next chain $1 \\to 2 \\to 3 \\to 4$. Children: node $2$ has child $7 \\to 8$, node $8$ has child $11$, node $3$ has child $9 \\to 10$. Expected flattened order, by definition, is $[1,2,7,8,11,3,9,10,4]$.\n- Case $4$ (deep nesting): top-level next chain $1 \\to 2 \\to 3$. Children: node $1$ has child $4$, node $4$ has child $5$, node $5$ has child $6$. Expected flattened order is $[1,4,5,6,2,3]$.\n- Case $5$ (multiple children at different positions): top-level next chain $1 \\to 2 \\to 3 \\to 4 \\to 5$. Children: node $2$ has child $6$, node $4$ has child $7 \\to 8 \\to 9$. Expected flattened order is $[1,2,6,3,4,7,8,9,5]$.\n\nYour program must:\n- Construct the test structures exactly as specified.\n- Produce the flattened sequence using the recursion-based method and, independently, using the iteration-based method with an explicit stack.\n- Verify that both sequences are identical for each test case.\n- Final output format: a single line containing a comma-separated list enclosed in square brackets, where each element corresponds to one test case. For test case $i$, output the flattened sequence as a list of integers (using the recursion-based method) if and only if it matches the sequence produced by the iteration-based method; otherwise, output the singleton list $[-1]$ for that case. For example, the output should look like $[ [a_1], [a_2], [a_3], [a_4], [a_5] ]$ concatenated without spaces, e.g., $[[a_1],[a_2],[a_3],[a_4],[a_5]]$, where each $[a_i]$ is a list of integers.\n\nNo external input or files are permitted; the program must be fully self-contained and runnable.", "solution": "The problem requires the implementation and verification of two distinct methods—one recursive and one iterative—for flattening a multi-level singly linked list. This structure is a finite directed acyclic graph where each node possesses an integer value, a `next` pointer defining a primary chain, and a `child` pointer to the head of a sub-chain. The flattening must conform to a strict depth-first pre-order traversal, resulting in a single-level linked list. The implementations must be in-place, meaning they modify the existing pointers without allocating new nodes, and must set all `child` pointers to `null`.\n\nFirst, we define the structure of a node, which we denote as $N$. Each node $N$ comprises three components: an integer value $v$, a pointer to the next node $N_{next}$, and a pointer to a child node $N_{child}$.\n\n$$N = (v, N_{next}, N_{child})$$\n\nThe flattening operation transforms the multi-level structure into a linear sequence by splicing child lists immediately after their parent nodes. If a node $N_i$ has a child list headed by $N_c$ and a successor node $N_j$, the structure $... \\to N_i \\to N_j \\to ...$ with $N_i$ having child $N_c$ is transformed. The child list starting at $N_c$ is flattened into a linear segment from $N_c$ to its tail, $T_c$. This segment is then inserted between $N_i$ and $N_j$, resulting in the sequence $... \\to N_i \\to N_c \\to ... \\to T_c \\to N_j \\to ...$. All $N_{child}$ pointers are set to `null` during this process.\n\n### Recursive Flattening\n\nThe recursive approach is a natural fit for this problem, as the definition of flattening is itself recursive. A function to flatten a list can call itself to flatten any child lists encountered. A robust recursive implementation involves a helper function that takes the head of a list, flattens it, and returns the tail of the now-flattened list. This returned tail is essential for correctly splicing the list segments.\n\nLet's define a function $\\text{FlattenRecursive}(h)$, where $h$ is the head of a list segment. This function returns the tail of the flattened segment.\nThe algorithm proceeds as follows:\n1.  Initialize a pointer `current` to the head node $h$.\n2.  Traverse the list level by level using the `current` pointer.\n3.  At each `current` node:\n    a. If a child pointer $N_{child}$ exists:\n        i.  Store the original next pointer, $N_{next} = \\text{current.next}$.\n        ii. Recursively call the function on the child list: $T_c = \\text{FlattenRecursive}(\\text{current.child})$. $T_c$ is the tail of the flattened child list.\n        iii. Splice the flattened child list into the main list:\n            - Set $\\text{current.next} = \\text{current.child}$.\n            - Set $\\text{current.child} = \\text{null}$.\n            - Link the tail of the child list to the original next node: $T_c.\\text{next} = N_{next}$.\n        iv. To continue the traversal, update the `current` pointer to the end of the newly inserted segment, which is $T_c$. This ensures that the next iteration of the loop correctly processes the part of the list that follows the spliced segment.\n    b. If `current.next` is null, it means we have reached the end of the current traversal path. This `current` node is the tail of the flattened list up to this point, so it is returned.\n    c. Advance `current` to `current.next`.\n\nThe base case for the recursion is a list segment with no children, in which case the traversal simply finds and returns the tail of that linear segment.\n\n### Iterative Flattening\n\nThe iterative approach must simulate the LIFO (Last-In, First-Out) behavior of the recursive call stack. An explicit stack data structure is used for this purpose. The stack will store pointers to nodes that must be processed later. Specifically, when we descend into a child list, the original `next` pointer of the parent node must be saved to be attached later.\n\nThe iterative algorithm, $\\text{FlattenIterative}(h)$, operates as follows:\n1.  If the head $h$ is `null`, the list is empty, so we return.\n2.  Initialize an empty stack, $S$.\n3.  Initialize a pointer `current` to the head node $h$.\n4.  Begin a loop that continues as long as `current` is not `null`.\n5.  Inside the loop, at the `current` node:\n    a. If a child pointer $\\text{current.child}$ exists:\n        i.  If a `next` pointer $\\text{current.next}$ also exists, push it onto the stack $S$. This saves the rest of the current level's list to be processed after the entire child branch is flattened and attached.\n        ii. Promote the child list to be the next part of the main list: $\\text{current.next} = \\text{current.child}$.\n        iii. Nullify the child pointer: $\\text{current.child} = \\text{null}$.\n    b. If the `current` node is now at the end of a chain (i.e., $\\text{current.next}$ is `null`) and the stack $S$ is not empty, it signifies that we have finished processing a (possibly nested) child branch. We must now connect this branch back to a previously saved list segment.\n        i.  Pop a node from the stack $S$ and set it as the next node: $\\text{current.next} = S.\\text{pop()}$.\n    c. Advance `current` to the next node: $\\text{current} = \\text{current.next}$.\n\nThis iterative process systematically explores the structure in a depth-first manner. Pushing `next` pointers onto the stack and processing `child` pointers immediately ensures the pre-order traversal. When a branch is exhausted, the stack provides the continuation point, perfectly mimicking the return from a recursive call.\n\n### Verification\nTo verify correctness, for each test case, we must create two identical copies of the initial structure. One copy is passed to the recursive function, and the other to the iterative function. After both functions complete, the resulting single-level lists are traversed, and their node values are collected into two sequences. These sequences are then compared. If they are identical, the verification is successful. Otherwise, there is a discrepancy between the implementations. This comparison validates the logical equivalence of the two implemented algorithms.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\nclass Node:\n    \"\"\"Node definition for the multi-level singly linked list.\"\"\"\n    def __init__(self, val, next_node=None, child=None):\n        self.val = val\n        self.next = next_node\n        self.child = child\n\n    def __repr__(self):\n        return f\"Node({self.val})\"\n\ndef _flatten_recursive(current):\n    \"\"\"\n    Recursive helper that flattens the list starting at `current`\n    and returns the tail of the flattened list.\n    \"\"\"\n    if not current:\n        return None\n\n    tail = current\n    while tail.next:\n        tail = tail.next\n\n    it = current\n    while it:\n        if it.child:\n            original_next = it.next\n            child_tail = _flatten_recursive(it.child)\n            \n            # Splice the flattened child list\n            it.next = it.child\n            it.child = None\n            \n            child_tail.next = original_next\n            \n            # Update the main tail if the new segment is at the end\n            if original_next is None:\n                tail = child_tail\n            \n            # Continue traversal from the end of the spliced segment\n            it = child_tail\n        else:\n            it = it.next\n            \n    return tail\n\ndef flatten_recursive(head):\n    \"\"\"\n    Main recursive function to flatten the list.\n    It calls a helper that performs the actual an-place flattening.\n    \"\"\"\n    if head:\n        _flatten_recursive(head)\n    return head\n\ndef flatten_iterative(head):\n    \"\"\"\n    Iterative function to flatten the list in-place using a stack.\n    \"\"\"\n    if not head:\n        return None\n\n    stack = []\n    current = head\n    \n    while current:\n        if current.child:\n            # If there's a next node, save it to the stack to process later\n            if current.next:\n                stack.append(current.next)\n            \n            # Promote child to be the next node\n            current.next = current.child\n            current.child = None\n            \n        # If we reach the end of a chain and the stack has saved pointers\n        if not current.next and stack:\n            # Pop from stack to connect the chain\n            current.next = stack.pop()\n        \n        # Move to the next node\n        current = current.next\n        \n    return head\n\ndef build_structure(nodes_def):\n    \"\"\"\n    Helper to build the list structure from a dictionary definition.\n    `nodes_def` is a dict of val -> (next_val, child_val).\n    \"\"\"\n    if not nodes_def:\n        return None\n        \n    nodes = {val: Node(val) for val in nodes_def}\n    for val, (next_val, child_val) in nodes_def.items():\n        if next_val is not None:\n            nodes[val].next = nodes[next_val]\n        if child_val is not None:\n            nodes[val].child = nodes[child_val]\n            \n    # Find head (node with no incoming edges, assumed to be the smallest value for simplicity)\n    # This is a simplification; a more robust way would be to pass the head's value.\n    in_degrees = {val: 0 for val in nodes}\n    for _, (next_val, child_val) in nodes_def.items():\n        if next_val is not None:\n            in_degrees[next_val] += 1\n        if child_val is not None:\n            in_degrees[child_val] += 1\n    \n    head_val = min([val for val, deg in in_degrees.items() if deg == 0 and val in nodes_def])\n    return nodes.get(head_val)\n\n\ndef build_from_case(case_def):\n    \"\"\"\n    Builds the test case structure. \n    case_def is a tuple: (head_val, definition_dict).\n    \"\"\"\n    if not case_def:\n        return None\n    head_val, nodes_def = case_def\n    if not nodes_def:\n        return None if head_val is None else Node(head_val)\n\n    nodes = {val: Node(val) for val in nodes_def}\n    for val, connections in nodes_def.items():\n        next_val, child_val = connections\n        if next_val in nodes:\n            nodes[val].next = nodes[next_val]\n        if child_val in nodes:\n            nodes[val].child = nodes[child_val]\n    return nodes.get(head_val)\n\ndef deepcopy_structure(head):\n    \"\"\"\n    Performs a deep copy of the graph structure to ensure tests are independent.\n    Uses a memoization dictionary to handle DAGs correctly.\n    \"\"\"\n    if not head:\n        return None\n    \n    memo = {}\n\n    def copy_node(node):\n        if not node:\n            return None\n        if id(node) in memo:\n            return memo[id(node)]\n        \n        new_node = Node(node.val)\n        memo[id(node)] = new_node\n        \n        new_node.next = copy_node(node.next)\n        new_node.child = copy_node(node.child)\n        \n        return new_node\n        \n    return copy_node(head)\n\ndef get_list_values(head):\n    \"\"\"Converts a flattened linked list to a Python list of values.\"\"\"\n    values = []\n    current = head\n    while current:\n        values.append(current.val)\n        current = current.next\n    return values\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run flatteners, and verify results.\n    \"\"\"\n    # Test cases defined as (head_value, {node_val: (next_val, child_val)})\n    test_cases = [\n        # Case 1: Empty structure\n        (None, {}),\n        # Case 2: Single node\n        (1, {1: (None, None)}),\n        # Case 3: General case\n        (1, {\n            1: (2, None), 2: (3, 7), 3: (4, 9), 4: (None, None),\n            7: (8, None), 8: (None, 11), 11: (None, None),\n            9: (10, None), 10: (None, None)\n        }),\n        # Case 4: Deep nesting\n        (1, {\n            1: (2, 4), 2: (3, None), 3: (None, None),\n            4: (None, 5), 5: (None, 6), 6: (None, None)\n        }),\n        # Case 5: Multiple children\n        (1, {\n            1: (2, None), 2: (3, 6), 3: (4, None), 4: (5, 7), 5: (None, None),\n            6: (None, None),\n            7: (8, None), 8: (9, None), 9: (None, None)\n        })\n    ]\n\n    results = []\n    for case_def in test_cases:\n        # Build two identical copies for recursive and iterative functions\n        head1 = build_from_case(case_def)\n        head2 = deepcopy_structure(head1)\n\n        # Flatten using both methods\n        result_head_rec = flatten_recursive(head1)\n        result_head_iter = flatten_iterative(head2)\n\n        # Convert to lists for comparison\n        list_rec = get_list_values(result_head_rec)\n        list_iter = get_list_values(result_head_iter)\n        \n        # Verify and store result\n        if list_rec == list_iter:\n            results.append(list_rec)\n        else:\n            results.append([-1])\n\n    # Final print statement in the exact required format\n    # The format is a string representation of a list of lists.\n    # Ex: [[1, 2], [3, 4], [-1]]\n    formatted_results = [f\"[{','.join(map(str, res))}]\" if res != [-1] else \"[-1]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3265439"}, {"introduction": "Our final practice generalizes the traversal problem to arbitrary directed graphs, which may contain cycles. Your task is to create a \"deep copy\" of a graph, a fundamental operation in many applications. This exercise demonstrates that for complex structures with cycles, both recursive and iterative depth-first traversals rely on a similar core logic—tracking visited nodes—to ensure correctness and termination, highlighting their underlying algorithmic equivalence [@problem_id:3265351].", "problem": "Consider a directed graph $G=(V,E)$ where $V$ is a finite set of vertex identifiers and $E \\subseteq V \\times V$ is a finite set of directed edges. A graph can contain cycles and self-loops. A deep copy of $G$ is a new graph $G'=(V',E')$ constructed such that there exists a bijection $f:V \\to V'$ preserving vertex labels and adjacencies: if $(u,v) \\in E$ then $(f(u),f(v)) \\in E'$, and every element of $V'$ and $E'$ is disjoint in identity from the corresponding elements of $V$ and $E$. Recursion is defined as a procedure that invokes itself on subproblems, whereas iteration performs repeated computation using explicit control structures and data structures (such as stacks or queues) without self-invocation.\n\nStarting from the following foundational facts:\n- A graph traversal that visits each vertex and each edge at most once runs in time proportional to the size of the graph, specifically $\\mathcal{O}(|V|+|E|)$.\n- Depth-First Search (DFS) and Breadth-First Search (BFS) are canonical traversal strategies that can be implemented both recursively (using the call stack) and iteratively (using an explicit stack for DFS or queue for BFS).\n- To prevent non-termination when traversing cycles or self-loops, a traversal must record whether a vertex has been processed, for example via a mapping $M:V \\to V'$ that marks a vertex as visited once it has been cloned.\n\nTask. Implement two functions to deep-copy a directed graph that may contain cycles and may be disconnected:\n- A recursive function that uses a mapping to track visited original vertices and returns references to the corresponding copied vertices. The recursion must never process any vertex more than once.\n- An iterative function that uses an explicit stack (or queue) together with the same mapping to ensure each vertex is processed at most once.\n\nGraph representation. Use a node-based adjacency list. Each node has a unique integer label $\\ell \\in \\mathbb{Z}$ and a list of neighbor references. The input to each copy function is a list of node references that together cover all vertices of the graph (to handle disconnected components). The output of each copy function must be a list of node references corresponding to the deep-copied graph, preserving the original labels.\n\nVerification. For each test case, compute the following boolean results:\n- $b_1$: whether the recursive copy is structurally equal to the original (there exists a label-preserving bijection that preserves adjacencies).\n- $b_2$: whether the iterative copy is structurally equal to the original.\n- $b_3$: whether all copied nodes from the recursive method are distinct in identity from their original counterparts (no original node is reused).\n- $b_4$: whether all copied nodes from the iterative method are distinct in identity from their original counterparts.\n- $b_5$: whether the recursive copy and the iterative copy are structurally equal to each other.\n\nTest suite. Hard-code the following adjacency mappings, each defining a directed graph. For an adjacency mapping $A$, $A[u]$ is the list of neighbors of vertex $u$.\n- Case $1$ (empty graph): $A_1 = \\{\\}$, so $V=\\varnothing$ and $E=\\varnothing$.\n- Case $2$ (single node with a self-loop): $A_2 = \\{\\, 1 : [\\,1\\,] \\,\\}$.\n- Case $3$ (single cyclic component): $A_3 = \\{\\, 1 : [\\,2\\,],\\; 2 : [\\,3\\,],\\; 3 : [\\,1\\,] \\,\\}$.\n- Case $4$ (disconnected, one $3$-cycle plus a path): $A_4 = \\{\\, 1 : [\\,2\\,],\\; 2 : [\\,3\\,],\\; 3 : [\\,1\\,],\\; 4 : [\\,5\\,],\\; 5 : [\\,] \\,\\}$.\n\nOutput specification. Your program must construct the graphs for the four cases above, run both the recursive and iterative deep-copy functions, compute the five booleans $(b_1,b_2,b_3,b_4,b_5)$ for each case in that order, and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list $[b_1,b_2,b_3,b_4,b_5]$ for one case. For example, the output format must be of the form $[\\, [b_1,b_2,b_3,b_4,b_5],\\; [b_1,b_2,b_3,b_4,b_5],\\; [b_1,b_2,b_3,b_4,b_5],\\; [b_1,b_2,b_3,b_4,b_5] \\,]$.\n\nNo physical units, angle units, or percentage formats are involved; all outputs are booleans. The program must be complete, runnable, and require no input. The correctness should derive from the foundational facts stated at the beginning, without relying on any shortcut formulas.", "solution": "The problem requires the implementation and verification of two distinct deep-copying algorithms for a directed graph: one recursive and one iterative. The graph may be disconnected and may contain cycles. The solution must be robust, and its correctness must be verifiable against a provided test suite.\n\nThe fundamental principle underlying the deep-copying of a graph $G=(V, E)$ into a new graph $G'=(V', E')$ is that of a graph traversal. Simply creating new nodes is insufficient; the adjacency relationships must be recreated with respect to the newly created nodes. The primary challenges are handling cycles, which could lead to infinite recursion or loops, and ensuring that each unique node in the original graph is copied exactly once.\n\nTo address these challenges, a state-tracking mechanism is essential. We employ a mapping, let's call it $M$, from original vertices to their newly created copies, so $M: V \\to V'$. This map serves a dual purpose:\n$1$. It acts as a \"visited\" set. Before processing a vertex $u \\in V$, we check if it is already a key in $M$. If it is, we know its copy $u' = M(u)$ has already been created, and we can reuse this copy without reprocessing the vertex. This prevents infinite loops when traversing cycles.\n$2$. It ensures a one-to-one correspondence between original vertices and their copies. Any vertex $u$ is copied only once, upon its first encounter, and its copy $M(u)$ is stored. All subsequent references to $u$ during the traversal will resolve to the same copy $M(u)$, correctly preserving the graph's structure, including shared nodes.\n\nThe provided algorithms are implemented based on a standard node-based adjacency list representation, where each node object holds a unique integer label $\\ell \\in \\mathbb{Z}$ and a list of references to its neighbors.\n\n**Recursive Implementation**\nThe recursive approach naturally models a Depth-First Search (DFS) traversal. The program's call stack is implicitly used to manage the state of the traversal.\n\nThe top-level function `copy_recursive` initializes the visited map $M$ and iterates through the list of all nodes in the graph. This outer loop ensures that all disconnected components are copied. For each node not yet in $M$, it initiates a recursive helper function, `_copy_recursive_helper(u, M)`.\n\nThis helper function operates as follows:\n$1$. **Base Case**: If the input node $u$ is in the map $M$, it means a copy for this node exists. The function immediately returns the existing copy, $M(u)$.\n$2$. **Recursive Step**: If $u$ is not in $M$:\n    a. A new node, $u'$, is created with the same label as $u$.\n    b. The map $M$ is immediately updated with the new correspondence: $M(u) = u'$. This step is critical. Placing the new copy in the map *before* the recursive calls for its neighbors ensures that if a neighbor points back to $u$ (a cycle), the recursive call for that neighbor will find $u$ in the map and correctly use the reference to $u'$, terminating the recursion.\n    c. The function is called recursively for each neighbor $v$ of $u$. The result of each call is the copied neighbor, $v'$.\n    d. The adjacency list of $u'$ is populated with the returned copied neighbors, $\\{v'\\}$.\n    e. The newly created node $u'$ is returned.\n\nThis process correctly constructs a deep copy, with the call stack managing the traversal's path.\n\n**Iterative Implementation**\nThe iterative approach replaces the implicit call stack with an explicit data structure, such as a stack (for a DFS-like traversal) or a queue (for a BFS-like traversal). Here, we use a stack to mirror the recursive DFS approach.\n\nThe function `copy_iterative` also initializes a visited map $M$. It iterates through all nodes provided in the input list to handle disconnected components.\n$1$. For a starting node $u$ of a component (i.e., a node not yet in $M$):\n    a. A copy $u'$ is created, and the mapping $M(u) = u'$ is established.\n    b. The original node $u$ is pushed onto a stack.\n$2$. A `while` loop continues as long as the stack is not empty. In each iteration:\n    a. A node, `current_original`, is popped from the stack. Its corresponding copy, `current_copy`, is retrieved from $M$.\n    b. For each neighbor `original_neighbor` of `current_original`:\n        i. If `original_neighbor` is not in $M$, it means this neighbor has not been seen before. A new copy, `neighbor_copy`, is created, the mapping $M(\\text{original\\_neighbor}) = \\text{neighbor\\_copy}$ is added, and `original_neighbor` is pushed onto the stack to be processed later.\n        ii. The adjacency list of `current_copy` is updated by appending the appropriate copied neighbor, which is guaranteed to be in $M$ either from a previous step or the current one. This is done by looking up $M(\\text{original\\_neighbor})$.\n\nThis iterative process systematically explores the graph component, creating node copies and wiring their adjacencies without using function recursion.\n\n**Verification Methodology**\nThe correctness of the implementations is verified against three criteria for each test case:\n\n$1$. **Structural Equality ($b_1, b_2, b_5$):** This check confirms that a copied graph is structurally isomorphic to the original (or to another copy). This is implemented by a function `are_structurally_equal`. It first establishes a bijection between the nodes of the two graphs based on their unique labels. Then, for each pair of corresponding nodes $(u, u')$, it verifies that their adjacency lists are equivalent by comparing the sorted lists of their neighbors' labels. Sorting ensures the check is independent of the order of neighbors in the adjacency lists.\n\n$2$. **Identity Disjointness ($b_3, b_4$):** This check verifies that the copy is \"deep\"—that is, the copied nodes are new objects in memory, not mere references to the original nodes. The function `are_identities_distinct` accomplishes this by creating a set of the memory addresses (using Python's `id()` function) of all original nodes and ensuring that the memory address of any copied node does not appear in this set.\n\nThe conjunction of these verification steps provides a robust confirmation that the implemented functions produce a correct, deep copy of the given graph structure. For all specified test cases, both algorithms are expected to pass all five boolean checks, yielding `True` for $b_1$ through $b_5$.", "answer": "```python\nimport sys\n\n# Setting a higher recursion limit for potentially deep or large graphs,\n# though not strictly necessary for the given test cases.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"Represents a node in a directed graph.\"\"\"\n    def __init__(self, label: int):\n        self.label = label\n        self.neighbors = []\n\n    def __repr__(self) -> str:\n        return f\"Node({self.label})\"\n\ndef build_graph(adj_map: dict[int, list[int]]) -> list[Node]:\n    \"\"\"Constructs a graph from an adjacency map.\"\"\"\n    all_labels = set(adj_map.keys())\n    for neighbors in adj_map.values():\n        for neighbor_label in neighbors:\n            all_labels.add(neighbor_label)\n\n    nodes = {label: Node(label) for label in sorted(list(all_labels))}\n\n    for label, neighbor_labels in adj_map.items():\n        node = nodes[label]\n        node.neighbors = [nodes[neighbor_label] for neighbor_label in neighbor_labels]\n\n    return list(nodes.values())\n\ndef copy_recursive(nodes: list[Node]) -> list[Node]:\n    \"\"\"Deep copies a graph using recursion (DFS).\"\"\"\n    visited = {}  # Maps original node to its copy\n\n    def _copy_recursive_helper(node: Node) -> Node:\n        if node in visited:\n            return visited[node]\n\n        new_node = Node(node.label)\n        visited[node] = new_node\n\n        new_neighbors = []\n        for neighbor in node.neighbors:\n            new_neighbors.append(_copy_recursive_helper(neighbor))\n        new_node.neighbors = new_neighbors\n\n        return new_node\n\n    # This loop handles disconnected components.\n    for node in nodes:\n        if node not in visited:\n            _copy_recursive_helper(node)\n\n    if not nodes:\n        return []\n\n    # Return copies corresponding to the input node list order.\n    return [visited[node] for node in nodes]\n\n\ndef copy_iterative(nodes: list[Node]) -> list[Node]:\n    \"\"\"Deep copies a graph using an explicit stack (DFS).\"\"\"\n    visited = {}  # Maps original node to its copy\n    \n    # This loop handles disconnected components.\n    for node in nodes:\n        if node not in visited:\n            # Start a new traversal for a new component\n            stack = [node]\n            visited[node] = Node(node.label)\n            \n            while stack:\n                current_original = stack.pop()\n                current_copy = visited[current_original]\n\n                for neighbor in current_original.neighbors:\n                    if neighbor not in visited:\n                        visited[neighbor] = Node(neighbor.label)\n                        stack.append(neighbor)\n                    current_copy.neighbors.append(visited[neighbor])\n\n    if not nodes:\n        return []\n        \n    return [visited[node] for node in nodes]\n\n\ndef are_structurally_equal(nodes1: list[Node], nodes2: list[Node]) -> bool:\n    \"\"\"Checks if two graphs are structurally equal.\"\"\"\n    if len(nodes1) != len(nodes2):\n        return False\n    \n    map1 = {node.label: node for node in nodes1}\n    map2 = {node.label: node for node in nodes2}\n\n    if map1.keys() != map2.keys():\n        return False\n\n    for label in map1:\n        node1 = map1[label]\n        node2 = map2[label]\n        \n        neighbor_labels1 = sorted([n.label for n in node1.neighbors])\n        neighbor_labels2 = sorted([n.label for n in node2.neighbors])\n\n        if neighbor_labels1 != neighbor_labels2:\n            return False\n            \n    return True\n\ndef are_identities_distinct(original_nodes: list[Node], copied_nodes: list[Node]) -> bool:\n    \"\"\"Checks if copied nodes are new objects in memory.\"\"\"\n    if not original_nodes and not copied_nodes:\n        return True\n    \n    original_ids = {id(n) for n in original_nodes}\n    copied_ids = {id(n) for n in copied_nodes}\n    \n    return original_ids.isdisjoint(copied_ids)\n\ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        {},  # Case 1: Empty graph\n        {1: [1]},  # Case 2: Single node with self-loop\n        {1: [2], 2: [3], 3: [1]},  # Case 3: Single cyclic component\n        {1: [2], 2: [3], 3: [1], 4: [5], 5: []},  # Case 4: Disconnected graph\n    ]\n\n    all_results = []\n\n    for adj_map in test_cases:\n        original_graph = build_graph(adj_map)\n        \n        rec_copy = copy_recursive(original_graph)\n        iter_copy = copy_iterative(original_graph)\n\n        b1 = are_structurally_equal(original_graph, rec_copy)\n        b2 = are_structurally_equal(original_graph, iter_copy)\n        b3 = are_identities_distinct(original_graph, rec_copy)\n        b4 = are_identities_distinct(original_graph, iter_copy)\n        b5 = are_structurally_equal(rec_copy, iter_copy)\n        \n        all_results.append([b1, b2, b3, b4, b5])\n\n    # Format the output exactly as specified.\n    print(f\"[{', '.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3265351"}]}