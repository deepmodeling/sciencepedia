{"hands_on_practices": [{"introduction": "Our first practice explores an algorithm where tail recursion arises naturally. We will implement a function to check if a string is a palindrome—a sequence that reads the same forwards and backwards. This exercise demonstrates how a divide-and-conquer approach can lead to a recursive call being the final action, providing a clear and intuitive example of a tail call in action. [@problem_id:3278431]", "problem": "You are given the formal definition of a palindrome over a finite string. Let a finite string over a finite alphabet be denoted by $s$, with length $n = |s|$. Define the reversal operator $\\operatorname{rev}(s)$ that produces the string with characters in reverse order. A string $s$ is a palindrome if and only if $s = \\operatorname{rev}(s)$, which is equivalent to the pointwise condition $\\forall i \\in \\{0,1,\\dots,n-1\\},\\ s[i] = s[n-1-i]$. Your task is to design and implement a tail-recursive algorithm that decides whether a given string is a palindrome after normalization, where normalization is defined as mapping the input string $s$ to $\\nu(s)$ by removing all characters that are not alphanumeric (letters or digits) and converting the remaining characters to lowercase, preserving order. Formally, if $s = s_0 s_1 \\dots s_{n-1}$, then\n$$\n\\nu(s) = \\text{concat} \\left( \\left\\{ \\operatorname{lower}(s_i) \\mid s_i \\text{ is alphanumeric} \\right\\} \\right),\n$$\nwhere $\\operatorname{lower}(\\cdot)$ maps uppercase letters to lowercase and leaves digits unchanged, and concat appends characters in their original order.\n\nStarting from the fundamental definitions of recursion, a tail-recursive function is a recursive function in which the recursive call is the final operation in the function’s execution path. Formulate the palindrome decision problem on the normalized string $\\nu(s)$ using a predicate $P(l,r)$ over indices $l$ and $r$ of $\\nu(s)$, where $0 \\le l \\le r < |\\nu(s)|$, that returns a boolean indicating whether the substring bounded by $l$ and $r$ is a palindrome. The function $P(l,r)$ must be tail-recursive in the sense that the recursive call (if any) is the last action taken by the function. The base case must ensure termination, and the recursive step must strictly reduce the problem size.\n\nYour program must implement this tail-recursive predicate on $\\nu(s)$ and apply it to the following test suite of input strings:\n- $s_1 =$ \"racecar\"\n- $s_2 =$ \"\"\n- $s_3 =$ \"a\"\n- $s_4 =$ \"A man, a plan, a canal: Panama\"\n- $s_5 =$ \"No 'x' in Nixon\"\n- $s_6 =$ \"abca\"\n- $s_7 =$ \"abc\"\n- $s_8 =$ \"!!!\"\n- $s_9 =$ \"Was it a car or a cat I saw?\"\n- $s_{10} =$ \"abcbaX\"\n\nDesign for coverage:\n- The case $s_1$ tests a straightforward palindrome with only lowercase letters.\n- The case $s_2$ tests the empty string, which after normalization remains empty and should be considered a palindrome by the definition (vacuously true).\n- The case $s_3$ tests a single-character string, which is always a palindrome.\n- The cases $s_4$, $s_5$, and $s_9$ test palindromes under normalization, including mixed case and punctuation, where only alphanumeric characters are considered and letters are compared case-insensitively.\n- The cases $s_6$, $s_7$, and $s_{10}$ test clear non-palindromes after normalization.\n- The case $s_8$ tests a string that becomes empty after normalization.\n\nEach test case must yield a boolean result. Your program should produce a single line of output containing the results for $[s_1,s_2,\\dots,s_{10}]$ as a comma-separated list enclosed in square brackets, using the literal boolean representation of the programming language (for Python, this is \"True\" and \"False\"). For example, the output format must be exactly of the form $[b_1,b_2,\\dots,b_{10}]$ where each $b_i$ is either the literal \"True\" or \"False\". No inputs are read; the program must be self-contained and use the specified test suite embedded in the code.", "solution": "The problem requires the design and implementation of a tail-recursive algorithm to determine if a given string is a palindrome after a specific normalization process. The solution is developed in two main stages: first, defining the string normalization, and second, formulating the tail-recursive predicate for the palindrome check.\n\n### Step 1: String Normalization\n\nThe problem defines a normalization function, $\\nu(s)$, which prepares the input string $s$ for the palindrome check. This process consists of two operations performed in order:\n1.  **Filtering**: All characters that are not alphanumeric (i.e., not letters from 'a'-'z', 'A'-'Z', or digits from '0'-'9') are removed from the string.\n2.  **Case Conversion**: All remaining characters, which are guaranteed to be alphanumeric, are converted to their lowercase equivalents. Uppercase letters are mapped to lowercase, while digits remain unchanged.\n\nFormally, for a string $s = s_0 s_1 \\dots s_{n-1}$, the normalized string $\\nu(s)$ is given by:\n$$\n\\nu(s) = \\text{concat} \\left( \\left\\{ \\operatorname{lower}(s_i) \\mid s_i \\text{ is alphanumeric} \\right\\} \\right)\n$$\nFor example, applying this to the string $s_4 = \\text{\"A man, a plan, a canal: Panama\"}$:\n1.  Filtering out spaces, commas, and the colon yields `\"AmanaplanacanalPanama\"`.\n2.  Converting to lowercase yields the normalized string $\\nu(s_4) = \\text{\"amanaplanacanalpanama\"}$.\n\nFor a string like $s_8 = \\text{\"!!!\"}$, all characters are non-alphanumeric, so they are all removed. The resulting normalized string is the empty string, $\\nu(s_8) = \\text{\"\"}$.\n\n### Step 2: Tail-Recursive Palindrome Predicate\n\nA palindrome is a sequence that reads the same forwards and backwards. For a normalized string $s' = \\nu(s)$ of length $m = |s'|$, this is equivalent to the condition $s'[i] = s'[m-1-i]$ for all $i \\in \\{0, 1, \\dots, m-1\\}$. We can formulate a decision algorithm for this property using a recursive predicate, $P(l, r)$, which evaluates whether the substring of $s'$ from index $l$ to index $r$ (inclusive) forms a palindrome. The initial check for the entire string $s'$ is invoked as $P(0, m-1)$.\n\nThe design of $P(l, r)$ must be tail-recursive, meaning the recursive call, if one is made, must be the absolute final operation performed by the function.\n\n**Base Case:** The recursion must terminate. A palindrome check can stop when the \"outside\" pointers (represented by indices $l$ and $r$) meet or cross each other.\n- If $l = r$, the substring has one character, which is always a palindrome.\n- if $l > r$, the substring is empty (e.g., the original string had an even number of characters and all pairs matched). The empty string is vacuously a palindrome.\nCombining these, the base case for termination is $l \\ge r$. In this situation, the predicate $P(l,r)$ must return $\\text{True}$.\n\n**Recursive Step:** For the case where $l < r$, we compare the characters at the ends of the current substring, $s'[l]$ and $s'[r]$.\n1.  If $s'[l] \\neq s'[r]$, the substring is not a palindrome. There is no need to check further. The function must terminate and return $\\text{False}$. This is a non-recursive terminal path.\n2.  If $s'[l] = s'[r]$, the outer characters match. The problem is reduced to determining if the inner substring, from index $l+1$ to $r-1$, is also a palindrome. The function must then find the value of $P(l+1, r-1)$. To satisfy the tail-recursion constraint, the function must directly return the result of this recursive call, without any further computation.\n\nThis logic is formally captured by the following piecewise definition for the predicate $P(l,r)$ on a string $s'$:\n$$\nP(l,r) =\n\\begin{cases}\n\\text{True} & \\text{if } l \\ge r \\\\\n\\text{False} & \\text{if } l < r \\text{ and } s'[l] \\neq s'[r] \\\\\nP(l+1, r-1) & \\text{if } l < r \\text{ and } s'[l] = s'[r]\n\\end{cases}\n$$\n\n**Example Walkthrough:**\nLet's analyze $s_{10} = \\text{\"abcbaX\"}$.\n1.  **Normalization**: $\\nu(s_{10}) = s' = \\text{\"abcbax\"}$. The length is $m=6$.\n2.  **Initial Call**: We evaluate $P(0, 5)$.\n    - $P(0, 5)$: $l=0, r=5$. We check $s'[0] \\overset{?}{=} s'[5]$. This is $\\text{'a'} \\overset{?}{=} \\text{'x'}$. The condition is false. The function returns $\\text{False}$. The process terminates.\n\nLet's analyze $s_9 = \\text{\"Was it a car or a cat I saw?\"}$.\n1.  **Normalization**: $\\nu(s_9) = s' = \\text{\"wasitacaroracatisaw\"}$. The length is $m=19$.\n2.  **Initial Call**: We evaluate $P(0, 18)$.\n    - $P(0, 18)$: $l=0, r=18$. $s'[0]=\\text{'w'}, s'[18]=\\text{'w'}$. They match. Return $P(1, 17)$.\n    - $P(1, 17)$: $l=1, r=17$. $s'[1]=\\text{'a'}, s'[17]=\\text{'a'}$. They match. Return $P(2, 16)$.\n    - ... This continues until the center is reached.\n    - $P(8, 10)$: $l=8, r=10$. $s'[8]=\\text{'r'}, s'[10]=\\text{'r'}$. They match. Return $P(9, 9)$.\n    - $P(9, 9)$: $l=9, r=9$. The base case $l \\ge r$ is met. The function returns $\\text{True}$.\n\nThis final $\\text{True}$ result propagates back up the chain of tail calls, becoming the final result for the initial call. Thus, $s_9$ is a palindrome after normalization.\n\nThis structured, recursive formulation correctly solves the problem and adheres to the tail-recursion requirement. The implementation will consist of a normalization function and a function for the predicate $P(l,r)$ that calls itself recursively.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the palindrome problem for a given test suite using a \n    tail-recursive approach on normalized strings.\n    \"\"\"\n\n    # The test suite of input strings as per the problem statement.\n    test_cases = [\n        \"racecar\",                          # s_1\n        \"\",                                 # s_2\n        \"a\",                                # s_3\n        \"A man, a plan, a canal: Panama\",   # s_4\n        \"No 'x' in Nixon\",                  # s_5\n        \"abca\",                             # s_6\n        \"abc\",                              # s_7\n        \"!!!\",                             # s_8\n        \"Was it a car or a cat I saw?\",     # s_9\n        \"abcbaX\",                           # s_10\n    ]\n\n    def normalize_string(s: str) -> str:\n        \"\"\"\n        Applies the normalization function nu(s).\n        Removes non-alphanumeric characters and converts to lowercase.\n        \"\"\"\n        return \"\".join(char.lower() for char in s if char.isalnum())\n\n    def is_palindrome_tail_recursive(s_prime: str, l: int, r: int) -> bool:\n        \"\"\"\n        Implements the tail-recursive predicate P(l, r) to check if the\n        substring of s_prime from index l to r is a palindrome.\n        \n        Args:\n            s_prime: The normalized string.\n            l: The left index of the substring.\n            r: The right index of the substring.\n        \n        Returns:\n            True if the substring is a palindrome, False otherwise.\n        \"\"\"\n        # Base Case: If indices cross or meet, the substring is a palindrome.\n        # This handles empty strings (l=0, r=-1) and single-char strings (l=r=0).\n        if l >= r:\n            return True\n        \n        # Recursive Step:\n        # 1. Check if the outer characters are different.\n        if s_prime[l] != s_prime[r]:\n            return False\n        \n        # 2. If they are the same, the result depends on the inner substring.\n        #    This is a tail call as it's the final action of the function.\n        return is_palindrome_tail_recursive(s_prime, l + 1, r - 1)\n\n    results = []\n    for s in test_cases:\n        # 1. Normalize the input string s.\n        normalized_s = normalize_string(s)\n        \n        # 2. Apply the tail-recursive predicate P(l, r) to the normalized string.\n        # The initial call covers the entire string.\n        is_pal = is_palindrome_tail_recursive(normalized_s, 0, len(normalized_s) - 1)\n        \n        results.append(is_pal)\n\n    # Format the final output as a comma-separated list of booleans in brackets.\n    # The map(str, ...) ensures Python's \"True\" and \"False\" literals are used.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3278431"}, {"introduction": "While some problems are naturally tail-recursive, many require a specific transformation. This exercise introduces the powerful accumulator pattern to convert a standard recursive process—list reversal—into a tail-recursive one. By instrumenting our code to track stack depth, we will directly observe the critical benefit of tail recursion: its ability to run in constant stack space when optimized, preventing stack overflows on large inputs. [@problem_id:3278410]", "problem": "You are asked to design from first principles and implement a tail-recursive list reversal pattern using an accumulator. The fundamental base you must rely on consists of: (i) the definition of a singly linked list where the constructor that adds an element to the front (often called “cons”) runs in constant time $O(1)$, (ii) the definition of a tail call as a recursive invocation that is the last operation of a function, and (iii) the standard cost model of the Random Access Machine (RAM), where each primitive operation on constant-sized data costs $O(1)$, and running time is the sum of the costs of all executed primitive operations. You must also reason about the call stack space usage with and without Tail Call Optimization (TCO) where TCO denotes the transformation in which the runtime system reuses the current stack frame for a tail call, thereby preventing additional stack growth. Your program must implement the algorithm in a way that is faithful to the singly linked list model (constant-time front insertion), and must instrument the implementation to count the number of element-transfer steps and the maximum call stack depth reached by the reversing function.\n\nTask requirements are as follows:\n1. Construct a tail-recursive reversal using an accumulator $R$ on a singly linked list representation. Let $X$ denote the input list and $n$ denote $|X|$. The algorithm must be of the shape: strip the head $h$ of the input and set $R \\leftarrow \\mathrm{cons}(h,R)$ in each step, then tail-call on the remainder, so that when the input is empty, $R$ is the result. Use a representation that allows $O(1)$ front insertion (you must not rely on dynamic arrays where inserting at the front costs more than $O(1)$).\n2. Implement two variants of the reversal:\n   - A plain tail-recursive function (no TCO assumed by the language runtime).\n   - A TCO-simulated variant using a trampoline or equivalent iterative transformation that guarantees $O(1)$ call stack usage regardless of $n$.\n3. Instrument both variants to record:\n   - The number of element-transfer steps, which by construction should equal $n$.\n   - The maximum recursion depth attributable to the reversing function. For the plain variant without TCO, this should be $n+1$ (including the base-call frame). For the TCO-simulated variant, this should be $1$.\n4. Use the host language’s recursion depth limit $L$ to prevent a crash. For a test whose list length $m$ satisfies $m+1 > L$, do not run the plain recursive variant; instead, report a sentinel for fields that would be unavailable due to the predicted overflow.\n5. Time and space reasoning: Argue from the cost model why the total work is $O(n)$ and why the call stack consumption is $O(n)$ without TCO and $O(1)$ with TCO.\n\nTest suite:\nProvide results for the following input lists $X$:\n- $X_1 = [\\,]$.\n- $X_2 = [7]$.\n- $X_3 = [1,2,3,4,5]$.\n- $X_4 = [0,1,2,\\dots,799]$ (length $800$).\n- $X_5 = [0,1,2,\\dots,(L+49)]$ where $L$ is the host language recursion limit at runtime, and the length is $L+50$. For this last case, you must skip executing the plain recursive variant and treat it as a predicted overflow.\n\nFor each test case with input list $X$ of length $n$, you must produce a single result record of the form\n$[ \\text{ok\\_tramp}, \\text{plain\\_status}, \\text{steps}, \\text{stack\\_plain}, \\text{stack\\_tramp}, \\text{overflow\\_predicted} ]$\nwith the following semantics:\n- $\\text{ok\\_tramp}$ is a boolean indicating whether the TCO-simulated variant returns the exact reversal of $X$.\n- $\\text{plain\\_status}$ is an integer: it is $1$ if the plain variant was executed and returned the correct reversal, $0$ if it was executed and returned an incorrect result, and $-1$ if it was skipped due to predicted overflow.\n- $\\text{steps}$ is the integer number of element-transfer steps observed in the executed variant whose count is reported (report the TCO-simulated variant’s count when the plain variant is skipped). This should equal $n$.\n- $\\text{stack\\_plain}$ is the maximum call stack depth attributable to the reversing function for the plain variant if executed, else $-1$ if skipped.\n- $\\text{stack\\_tramp}$ is the maximum call stack depth attributable to the reversing function for the TCO-simulated variant (expected $1$).\n- $\\text{overflow\\_predicted}$ is a boolean indicating whether $n+1 > L$.\n\nFinal output format:\nYour program should produce a single line of output containing the list of the result records for $X_1$ through $X_5$ as a comma-separated list enclosed in square brackets (e.g., \"[[...],[...],...]\"). No additional text should be printed. All numbers used or reported are unitless. There are no angles or percentages in this problem; no unit specification is required beyond unitless integers and booleans.", "solution": "We begin from the foundational definitions and the cost model.\n\nA singly linked list is either empty or a pair $(h,t)$ where $h$ is the head value and $t$ is the remainder list. Constructing $\\mathrm{cons}(h,R)$ is $O(1)$, and destructuring a node into $h$ and $t$ is $O(1)$. A tail call is a call that is syntactically in the final position of the function; no further work follows it in the caller. Under the Random Access Machine (RAM) cost model, each primitive operation on constant-sized data is $O(1)$.\n\nWe construct the reversal function with an explicit accumulator $R$:\n- State invariant to maintain: after processing $k$ elements of the input list $X$ from the front, the accumulator $R$ equals the reversal of the processed prefix, i.e., $R = \\mathrm{rev}(X[0..k-1])$.\n- Transition: if the input is non-empty with head $h$ and tail $t$, define $R' \\leftarrow \\mathrm{cons}(h,R)$ and recur (tail-call) on $(t,R')$.\n- Base case: when the input is empty, return $R$.\n\nProof of correctness proceeds by induction on $n = |X|$.\nBase case ($n=0$): the input is empty. The invariant gives $R = \\mathrm{rev}([]) = []$, so returning $R$ is correct.\nInductive step: assume correctness for lists of length $n-1$. Let $X = [h] \\cdot T$ with $|T| = n-1$. One step of the algorithm sets $R' \\leftarrow \\mathrm{cons}(h,R)$ and recurs on $(T,R')$. By the induction hypothesis applied to $T$, the recursive call returns $\\mathrm{rev}(T)$ accumulated onto $R'$, which equals $\\mathrm{rev}([h] \\cdot T)$ by the invariant construction. Therefore, the algorithm returns $\\mathrm{rev}(X)$.\n\nTime complexity follows from the RAM model. Each of the $n$ elements is examined exactly once, and each step performs a constant amount of work: destructuring the node and constructing one new node via $\\mathrm{cons}$. Therefore, the total running time is $O(n)$.\n\nSpace complexity on the call stack depends on Tail Call Optimization (TCO). Without TCO, each tail call still allocates a new frame, so the recursion depth reaches $n+1$ including the final base call; call stack space is thus $O(n)$. With TCO, the runtime reuses the current frame for the tail call, so the call stack depth stays constant, $O(1)$. In a language such as Python that does not apply TCO, we can simulate it using a trampoline or an equivalent iterative transformation: instead of making a tail call, we update the state variables $(X,R)$ in a loop and iterate. This preserves the $O(n)$ running time and reduces the call stack usage to $O(1)$.\n\nImplementation details to respect the $O(1)$ per-step model:\n- We represent the list as a singly linked structure where the empty list is a distinguished sentinel (such as $\\text{None}$) and a non-empty list is a pair $(h,t)$. This makes $\\mathrm{cons}$ be $O(1)$ and matches the theoretical analysis. We provide converters to and from host language arrays solely for input and output.\n- The plain tail-recursive function takes $(X,R)$ and an explicit $d$ recording the current recursion depth; it updates the maximum observed depth upon entry. Each non-empty step increments a counter of steps and tail-calls on $(t,\\mathrm{cons}(h,R))$ with depth $d+1$. The base returns $R$.\n- The TCO-simulated variant enacts the same state transitions within a loop. It similarly counts steps but performs no recursive calls, so its maximum call depth contribution is $1$.\n- To avoid a crash in environments with a recursion limit $L$, we predict overflow when $n+1 > L$. For such cases we skip executing the plain recursive variant and report a sentinel $-1$ for fields that would otherwise be measured on the plain variant, and we set an overflow-predicted boolean to $\\text{True}$. For other cases we execute both variants and report their measurements. In all cases, we check that the TCO-simulated result equals the true reversal.\n\nFor the test suite, let $X_1 = [\\,]$ so $n=0$, $X_2 = [7]$ so $n=1$, $X_3 = [1,2,3,4,5]$ so $n=5$, $X_4 = [0,1,2,\\dots,799]$ so $n=800$, and $X_5 = [0,1,2,\\dots,(L+49)]$ so $n=L+50$. For $X_1$ through $X_4$, the plain variant should run and exhibit maximum depth $n+1$ and step count $n$, while the TCO-simulated variant should show maximum depth $1$ and step count $n$. For $X_5$, we predict overflow for the plain variant since $n+1 > L$, skip it, and report its fields as $-1$ with overflow-predicted set to $\\text{True}$; the TCO-simulated variant still executes in $O(n)$ time and $O(1)$ stack.\n\nFinally, the program aggregates one record per test in the order $X_1$ to $X_5$ and prints a single line containing the outer list of these records, complying with the required output format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\nimport numpy as np  # permitted; not strictly required\n\n# Singly linked list representation:\n# Empty list is None; node is a tuple (head, tail)\n\ndef cons(h, t):\n    return (h, t)\n\ndef from_pylist(lst):\n    head = None\n    for x in reversed(lst):\n        head = cons(x, head)\n    return head\n\ndef to_pylist(node):\n    out = []\n    while node is not None:\n        out.append(node[0])\n        node = node[1]\n    return out\n\ndef reverse_tail_plain(node, acc, depth, metrics):\n    # metrics: dict with keys 'steps', 'max_depth'\n    # Record call depth on entry.\n    if depth > metrics['max_depth']:\n        metrics['max_depth'] = depth\n    if node is None:\n        return acc\n    # Transfer one element: move head to front of acc.\n    metrics['steps'] += 1\n    h, t = node\n    return reverse_tail_plain(t, cons(h, acc), depth + 1, metrics)\n\ndef reverse_tail_trampoline(node, acc, metrics):\n    # metrics: dict with keys 'steps', 'max_depth'\n    # Simulate TCO by iterative loop; only one call frame.\n    # We record the function's call depth contribution as 1.\n    if metrics['max_depth'] < 1:\n        metrics['max_depth'] = 1\n    while node is not None:\n        metrics['steps'] += 1\n        h, t = node\n        acc = cons(h, acc)\n        node = t\n    return acc\n\ndef solve():\n    # Define the recursion limit L from the runtime.\n    L = sys.getrecursionlimit()\n\n    # Define the test cases from the problem statement.\n    X1 = []\n    X2 = [7]\n    X3 = [1, 2, 3, 4, 5]\n    X4 = list(range(800))\n    X5 = list(range(L + 50))  # length L+50 triggers overflow if using plain recursion\n\n    test_cases = [X1, X2, X3, X4, X5]\n\n    results = []\n    for xs in test_cases:\n        n = len(xs)\n        linked = from_pylist(xs)\n        expected = list(reversed(xs))\n\n        # Trampoline/TCO-simulated variant\n        metrics_tramp = {'steps': 0, 'max_depth': 0}\n        tramp_result_linked = reverse_tail_trampoline(linked, None, metrics_tramp)\n        tramp_result = to_pylist(tramp_result_linked)\n        ok_tramp = (tramp_result == expected)\n        stack_tramp = metrics_tramp['max_depth']\n        steps_tramp = metrics_tramp['steps']\n\n        # Decide if plain recursion is safe to run\n        overflow_predicted = (n + 1) > L\n\n        if not overflow_predicted:\n            metrics_plain = {'steps': 0, 'max_depth': 0}\n            plain_result_linked = reverse_tail_plain(linked, None, 1, metrics_plain)\n            plain_result = to_pylist(plain_result_linked)\n            ok_plain = (plain_result == expected)\n            plain_status = 1 if ok_plain else 0\n            stack_plain = metrics_plain['max_depth']\n            steps_plain = metrics_plain['steps']\n            # Steps should match n; report from either; choose plain's count\n            steps_report = steps_plain\n        else:\n            # Skip executing plain recursion to avoid overflow\n            plain_status = -1\n            stack_plain = -1\n            steps_report = steps_tramp  # report trampoline steps\n\n        result_record = [ok_tramp, plain_status, steps_report, stack_plain, stack_tramp, overflow_predicted]\n        results.append(result_record)\n\n    # Final print statement in the exact required format.\n    # Single line with the list of result records.\n    def fmt(item):\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        elif isinstance(item, list):\n            return \"[\" + \",\".join(fmt(x) for x in item) + \"]\"\n        else:\n            return str(item)\n\n    print(fmt(results))\n\nsolve()\n```", "id": "3278410"}, {"introduction": "To solidify your understanding of the accumulator pattern, our final practice applies it to a classic numerical algorithm: converting an integer to its string representation in a given base. The standard division algorithm generates digits in reverse order, providing a perfect scenario to use an accumulator to construct the final string correctly during the forward recursive calls. This exercise demonstrates the flexibility of tail recursion in handling algorithmic challenges beyond simple data structure manipulation. [@problem_id:3278420]", "problem": "You are tasked with designing, implementing, and validating a tail-recursive function that converts any integer to its string representation in a given base. The required function must adhere to the constraints of tail recursion: in the recursive branch, the recursive call must be the last operation performed. No loops are allowed. The alphabet of digits for bases above $10$ must be the uppercase sequence $0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ$, where the digit values $10$ through $35$ are represented by $A$ through $Z$. The base $b$ is restricted to the inclusive range $2 \\leq b \\leq 36$.\n\nYour implementation should be grounded in the Division Algorithm: for any integers $n$ and $b$ with $b \\geq 2$, there exist unique integers $q$ and $r$ such that $n = q \\cdot b + r$ with $0 \\leq r < b$. Using this, every nonzero integer $n$ can be represented as a finite sequence of base-$b$ digits $d_k, d_{k-1}, \\dots, d_0$ such that $n = \\sum_{i=0}^{k} d_i \\cdot b^i$ and each $d_i \\in \\{0,1,\\dots,b-1\\}$. Your function must use tail recursion to accumulate the correct string without performing any work after the recursive call returns in the non-base case.\n\nRequirements and rules:\n- Implement a tail-recursive core that accumulates digits in the correct left-to-right order. Use an accumulator that is passed forward and modified before the recursive call, ensuring the last operation in the recursive branch is the recursive call itself. For negative $n$, use a separate prefix accumulator for the sign and apply the Division Algorithm to $|n|$. The representation for $n=0$ must be the single digit string $0$ with no sign.\n- The function must validate $b$ and handle all integers $n$ (positive, negative, and zero) in a mathematically consistent way.\n- Do not use any iterative constructs such as for-loops or while-loops.\n\nTest suite:\nEvaluate your program on the following ordered pairs $(n,b)$, covering typical and edge scenarios:\n1. $(0,2)$\n2. $(12345,10)$\n3. $(-255,16)$\n4. $(987654321,36)$\n5. $(1,2)$\n6. $(35,36)$\n\nFinal output format:\n- For each test case, compute the base-$b$ string representation and then convert that string into a list of integer digit values according to the mapping: $'0' \\mapsto 0$, $'1' \\mapsto 1$, $\\dots$, $'9' \\mapsto 9$, $'A' \\mapsto 10$, $\\dots$, $'Z' \\mapsto 35$. If the representation is negative, include a leading $-1$ in the list to denote the negative sign.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a comma-separated list of integers describing one test case’s digit values. For example, the format must be like $[[a_1,a_2], [b_1,b_2,b_3]]$ but with no spaces after commas in the outer list (the exact printing must be handled by your program).", "solution": "The problem of converting an integer to its string representation in a given base is a fundamental task in computer science, rooted in the principles of number theory. The solution must be implemented using tail recursion, a specific recursive pattern where the recursive call is the final operation in the function.\n\nThe mathematical foundation for this conversion is the **Division Algorithm**. For any integer $n$ (the number to be converted) and an integer base $b \\geq 2$, there exist unique integers $q$ (the quotient) and $r$ (the remainder) such that:\n$$n = q \\cdot b + r \\quad \\text{where} \\quad 0 \\leq r < b$$\nThis algorithm allows us to systematically extract the digits of $n$ in base $b$. The remainder $r$ corresponds to the least significant digit. The subsequent digits are found by repeatedly applying the same algorithm to the quotient $q$. For example, if $n_0 = n$, we find $n_0 = q_0 \\cdot b + d_0$. Then for $n_1 = q_0$, we find $n_1 = q_1 \\cdot b + d_1$, and so on. This process continues until the quotient becomes $0$. The sequence of remainders $d_0, d_1, d_2, \\dots$ represents the digits of $n$ in base $b$ from right to left (least significant to most significant).\n\nTo satisfy the requirement of tail recursion, we design a core recursive function that takes the current number, the base, and an accumulator as arguments. The accumulator's role is to build the final string representation. Since the Division Algorithm produces digits from right to left, each new digit must be prepended to the accumulator to construct the final string in the correct left-to-right order.\n\nThe structure of the tail-recursive helper function, let's call it $\\text{convert\\_recursive}(num, base, acc)$, is as follows:\n1.  **Base Case**: If $num = 0$, the process is complete. The string built in the accumulator $acc$ is the final result, which is then returned. If the initial number was $0$, the accumulator will be empty, which must be handled as a special case to return \"0\".\n2.  **Recursive Step**: If $num > 0$:\n    a. Calculate the quotient $q = \\lfloor num / base \\rfloor$ and the remainder $r = num \\pmod{base}$.\n    b. Convert the remainder $r$ to its corresponding character representation. We use the character set `$0123456789\\text{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$` for this mapping. Let this character be $c_r$.\n    c. Prepend this character to the accumulator: $acc_{new} = c_r + acc_{old}$.\n    d. Make the tail-recursive call: $\\text{return convert\\_recursive}(q, base, acc_{new})$. Because this call is the last action, the function is tail-recursive.\n\nA main wrapper function will handle preliminary checks and special cases before initiating the recursion:\n-   **Base Validation**: It first validates that the base $b$ is within the allowed range $2 \\leq b \\leq 36$.\n-   **Zero Handling**: If the input integer $n$ is $0$, the function immediately returns the string \"$0$\", bypassing the recursive logic.\n-   **Sign Handling**: If $n$ is negative, the negative sign is stored, and the recursive conversion is applied to the absolute value $|n|$. The sign is prepended to the final result after the recursion completes.\n\nThe final step is to process the generated string representation into the specified output format. This involves:\n1.  Creating a character-to-value map (e.g., $'0' \\to 0, \\dots, '9' \\to 9, 'A' \\to 10, \\dots, 'Z' \\to 35$).\n2.  Iterating through the characters of the base-$b$ string.\n3.  If the string represents a negative number (indicated by a leading `'-'` character), the output list begins with $-1$.\n4.  Each subsequent character is converted to its integer value using the map and appended to the list.\n\nThis complete, principle-based process ensures correctness, adheres to all constraints of the problem, and produces the required output format for the given test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the integer-to-base-string conversion problem using tail recursion for the given test suite.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 2),\n        (12345, 10),\n        (-255, 16),\n        (987654321, 36),\n        (1, 2),\n        (35, 36),\n    ]\n\n    # The alphabet of digits for bases up to 36.\n    DIGITS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \n    # Pre-computed map for converting character digits to integer values.\n    DIGIT_MAP = {char: val for val, char in enumerate(DIGITS)}\n\n    def _int_to_base_str_recursive(num, base, acc):\n        \"\"\"\n        The core tail-recursive helper function. This function must not be called directly.\n        It builds the string representation by prepending digits to an accumulator.\n        \"\"\"\n        if num == 0:\n            # Base case: when the number is reduced to 0, return the accumulated string.\n            return acc\n        \n        quotient = num // base\n        remainder = num % base\n        \n        # Prepend the new digit to the accumulator and make the tail call.\n        return _int_to_base_str_recursive(quotient, base, DIGITS[remainder] + acc)\n\n    def int_to_base_str(n, b):\n        \"\"\"\n        Main function to convert an integer to its base-b string representation.\n        It handles validation, special cases (zero), and sign before calling the\n        tail-recursive helper.\n        \"\"\"\n        if not isinstance(b, int) or not (2 <= b <= 36):\n            raise ValueError(\"Base must be an integer between 2 and 36.\")\n        \n        if n == 0:\n            return \"0\"\n            \n        sign = \"\"\n        if n < 0:\n            sign = \"-\"\n            n = -n\n        \n        # Initial call to the recursive helper with an empty accumulator.\n        # If the number was initially 0, this part is skipped. The _recursive\n        # function needs a non-empty result, so this initial empty string\n        # is fine because n>0 here.\n        num_str = _int_to_base_str_recursive(n, b, \"\")\n        \n        return sign + num_str\n\n    def format_output_string(s):\n        \"\"\"\n        Converts the string representation (e.g., \"-FF\") into the required\n        list of integer values (e.g., [-1, 15, 15]).\n        \"\"\"\n        result_list = []\n        is_negative = s.startswith('-')\n        \n        if is_negative:\n            result_list.append(-1)\n            s = s[1:]\n            \n        for char in s:\n            result_list.append(DIGIT_MAP[char])\n            \n        return result_list\n\n    results = []\n    for n, b in test_cases:\n        base_str = int_to_base_str(n, b)\n        formatted_result = format_output_string(base_str)\n        results.append(formatted_result)\n\n    # Format the final output string exactly as required.\n    # e.g., [[0],[1,2,3,4,5],[-1,15,15],...]\n    inner_parts = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output_str = f\"[{','.join(inner_parts)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "3278420"}]}