{"hands_on_practices": [{"introduction": "To begin, let's ground our understanding of recursion in the physical constraints of a computer system. This first practice problem illustrates the direct relationship between the depth of recursion and the consumption of a finite resource: the call stack memory. By calculating the maximum recursion depth based on memory size, you will develop a concrete intuition for why unbounded recursion leads to a \"stack overflow\" error. [@problem_id:3274462]", "problem": "Consider a single-threaded program running on an operating system that enforces a fixed stack size limit per thread. A recursive function is compiled without tail-call optimization and, on each invocation, allocates a local object of size $1 \\text{ kilobyte}$ on its stack frame. Assume that there are no other local variables and that any constant per-frame overhead (such as a saved return address and frame pointer) is negligible relative to the allocated object, so that the dominant per-call stack usage is the $1 \\text{ kilobyte}$ object. The stack for this thread is limited to $2 \\text{ megabytes}$ and is otherwise unused.\n\nUsing first principles about stack frame allocation in recursion and the binary definitions $1 \\text{ kilobyte} = 2^{10} \\text{ bytes}$ and $1 \\text{ megabyte} = 2^{20} \\text{ bytes}$, determine the maximum recursion depth (the number of simultaneously active recursive calls) that can be achieved without causing a stack overflow.\n\nProvide your answer as a single integer. No rounding is required.", "solution": "The problem asks for the maximum recursion depth of a function given specific constraints on stack usage. We are given the total available stack size and the amount of stack space consumed by each recursive call. The solution requires calculating how many of these stack frames can fit into the total available stack space.\n\nLet $S_{\\text{total}}$ be the total stack size limit for the thread.\nLet $S_{\\text{frame}}$ be the stack space allocated for each recursive function call (i.e., the size of one stack frame).\nLet $D_{\\text{max}}$ be the maximum recursion depth.\n\nFrom the problem statement, we are given:\nThe total stack size is $S_{\\text{total}} = 2 \\text{ megabytes}$.\nThe stack usage per call is dominated by a local object of size $S_{\\text{frame}} = 1 \\text{ kilobyte}$. The problem states to neglect any other overhead.\nThe binary definitions for the units are provided:\n$1 \\text{ kilobyte} = 2^{10} \\text{ bytes}$\n$1 \\text{ megabyte} = 2^{20} \\text{ bytes}$\n\nTo find the maximum recursion depth, we must first express both the total stack size and the per-frame stack usage in the same unit, which we will choose to be bytes.\n\nFirst, we convert the total stack size $S_{\\text{total}}$ to bytes:\n$$S_{\\text{total}} = 2 \\text{ megabytes} = 2 \\times (1 \\text{ megabyte}) = 2 \\times (2^{20} \\text{ bytes})$$\nUsing the property of exponents $a^m \\times a^n = a^{m+n}$, with $a=2$, $m=1$, and $n=20$:\n$$S_{\\text{total}} = 2^1 \\times 2^{20} \\text{ bytes} = 2^{1+20} \\text{ bytes} = 2^{21} \\text{ bytes}$$\n\nNext, we convert the per-frame stack usage $S_{\\text{frame}}$ to bytes:\n$$S_{\\text{frame}} = 1 \\text{ kilobyte} = 1 \\times (1 \\text{ kilobyte}) = 1 \\times (2^{10} \\text{ bytes}) = 2^{10} \\text{ bytes}$$\n\nThe maximum recursion depth, $D_{\\text{max}}$, is the total number of stack frames that can be allocated before the total stack size limit is exceeded. Since the problem specifies that the stack is otherwise unused and per-frame overhead is negligible, we can find $D_{\\text{max}}$ by dividing the total available stack size by the size of a single stack frame.\n$$D_{\\text{max}} = \\frac{S_{\\text{total}}}{S_{\\text{frame}}}$$\n\nSubstituting the values in bytes:\n$$D_{\\text{max}} = \\frac{2^{21} \\text{ bytes}}{2^{10} \\text{ bytes}}$$\n\nUsing the property of exponents $\\frac{a^m}{a^n} = a^{m-n}$, with $a=2$, $m=21$, and $n=10$:\n$$D_{\\text{max}} = 2^{21-10} = 2^{11}$$\n\nFinally, we calculate the integer value of $2^{11}$:\n$$2^{11} = 2 \\times 2^{10} = 2 \\times 1024 = 2048$$\n\nTherefore, the maximum recursion depth that can be achieved without causing a stack overflow is $2048$. This represents the total number of simultaneously active recursive calls.", "answer": "$$\\boxed{2048}$$", "id": "3274462"}, {"introduction": "Having established that the stack is a finite resource, we now turn to analyzing how a recursive algorithm's design impacts its stack usage. This exercise explores the relationship between an algorithm's input size and its maximum stack depth, a crucial aspect of its space complexity. By tracing a function that recursively divides its problem size, you will discover the mathematical principles that govern the stack's growth and learn to predict its behavior. [@problem_id:3274586]", "problem": "Consider a deterministic procedure operating on the set of nonnegative integers that uses the standard Last In, First Out (LIFO) call stack. The runtime system does not perform tail-call optimization, so each procedure call pushes one new activation record (AR) onto the stack, and an AR remains on the stack until its call returns. Define a function $f$ on inputs $x \\in \\mathbb{Z}_{\\ge 0}$ as follows: if $x = 0$ then $f$ immediately returns without making any further calls; if $x > 0$ then $f$ makes exactly one recursive call to $f(\\lfloor x/2 \\rfloor)$ and returns after that call returns. The maximum stack depth is defined to be the greatest number of activation records simultaneously present on the stack during the execution of a single call to $f(x)$, counting both the initial invocation and any recursive invocations, including the base-case frame if it is reached. Starting from the core definitions of integer division, the floor function, and the behavior of a call stack under recursion, determine the exact maximum stack depth for the input $x = 10^{9}$. Give your final answer as a single exact integer. No rounding is required.", "solution": "Let $D(x)$ denote the maximum stack depth for a call to the function $f(x)$, where $x \\in \\mathbb{Z}_{\\ge 0}$. The problem defines the behavior of the function $f$ and the call stack.\n\nAccording to the problem description:\n1.  A call to $f(x)$ pushes one new activation record (AR) onto the stack.\n2.  If $x=0$, the function returns. The maximum number of ARs on the stack during this call is $1$ (for $f(0)$ itself). Thus, the base case for the maximum depth is $D(0) = 1$.\n3.  If $x > 0$, the function $f(x)$ makes a single recursive call to $f(\\lfloor x/2 \\rfloor)$. The AR for $f(x)$ remains on the stack while the call to $f(\\lfloor x/2 \\rfloor)$ executes. The maximum stack depth for the execution of $f(x)$ will be the $1$ AR for $f(x)$ itself, plus the maximum depth achieved during the nested call to $f(\\lfloor x/2 \\rfloor)$.\n\nThis gives us the following recurrence relation for the maximum stack depth $D(x)$:\n$$\nD(x) = \\begin{cases}\n1 & \\text{if } x = 0 \\\\\n1 + D(\\lfloor x/2 \\rfloor) & \\text{if } x > 0\n\\end{cases}\n$$\n\nTo find the maximum stack depth for $x = 10^9$, we need to solve this recurrence. We can unroll the recurrence for an arbitrary $x > 0$. Let $x_0 = x$, and define the sequence $x_{i+1} = \\lfloor x_i/2 \\rfloor$ for $i \\ge 0$. Since $x$ is a positive integer, this sequence will strictly decrease until it reaches $0$. Let $m$ be the number of steps required for the argument to become $0$, such that $x_m = 0$ and $x_{m-1} > 0$.\n\nUnrolling the recurrence:\n$$\n\\begin{aligned}\nD(x) &= 1 + D(x_1) \\\\\n&= 1 + (1 + D(x_2)) \\\\\n&= 1 + 1 + (1 + D(x_3)) \\\\\n&\\vdots \\\\\n&= \\underbrace{1 + 1 + \\cdots + 1}_{m \\text{ times}} + D(x_m) \\\\\n&= m + D(0)\n\\end{aligned}\n$$\nUsing the base case $D(0) = 1$, we find:\n$$D(x) = m + 1$$\nHere, $m$ is the number of times we must apply the transformation $n \\to \\lfloor n/2 \\rfloor$ to get from $x$ to $0$.\n\nThe operation $n \\to \\lfloor n/2 \\rfloor$ for an integer $n$ is equivalent to a right bit shift of its binary representation. The number of such operations required to reduce a positive integer $x$ to $0$ is equal to the number of bits in the binary representation of $x$.\n\nFor any positive integer $x$, the number of bits in its binary representation, let's call it $k$, is given by $k = \\lfloor \\log_2(x) \\rfloor + 1$.\nSo, we have $m = k = \\lfloor \\log_2(x) \\rfloor + 1$.\n\nSubstituting this into our expression for $D(x)$:\n$$D(x) = m + 1 = (\\lfloor \\log_2(x) \\rfloor + 1) + 1 = \\lfloor \\log_2(x) \\rfloor + 2$$\nThis formula is valid for any integer $x > 0$.\n\nWe need to calculate the maximum stack depth for the input $x = 10^9$. Using the derived formula:\n$$D(10^9) = \\lfloor \\log_2(10^9) \\rfloor + 2$$\nTo evaluate $\\lfloor \\log_2(10^9) \\rfloor$, we need to find the integer $k$ such that $2^k \\le 10^9 < 2^{k+1}$.\nLet's analyze the powers of $2$ relative to powers of $10$. We know that $2^{10} = 1024$, which is slightly greater than $10^3 = 1000$.\n\nFrom $10^3 < 2^{10}$, we can raise both sides to the power of $3$:\n$$(10^3)^3 < (2^{10})^3$$\n$$10^9 < 2^{30}$$\nTaking the base-$2$ logarithm, we get $\\log_2(10^9) < 30$. This implies that $\\lfloor \\log_2(10^9) \\rfloor \\le 29$.\n\nNow we must check if $\\log_2(10^9)$ is greater than or equal to $29$. This is equivalent to checking if $10^9 \\ge 2^{29}$.\n$$2^{29} = \\frac{2^{30}}{2} = \\frac{(2^{10})^3}{2} = \\frac{(1024)^3}{2}$$\nWe are comparing $10^9$ with $\\frac{1024^3}{2}$. Let's rearrange this comparison:\n$$2 \\cdot 10^9 \\quad \\text{vs} \\quad 1024^3$$\n$$2 \\cdot (1000)^3 \\quad \\text{vs} \\quad (1024)^3$$\nDivide both sides by $(1000)^3$:\n$$2 \\quad \\text{vs} \\quad \\left(\\frac{1024}{1000}\\right)^3$$\n$$2 \\quad \\text{vs} \\quad (1.024)^3$$\nLet's compute $(1.024)^3$:\n$(1.024)^2 = 1.048576$\n$(1.024)^3 = 1.048576 \\times 1.024 = 1.073741824$\nThe comparison is now:\n$$2 \\quad \\text{vs} \\quad 1.073741824$$\nClearly, $2 > 1.073741824$.\nThis implies that $2 \\cdot 10^9 > 1024^3$, which means $10^9 > \\frac{1024^3}{2} = 2^{29}$.\n\nSo we have established the inequality:\n$$2^{29} < 10^9 < 2^{30}$$\nTaking the base-$2$ logarithm of all parts:\n$$\\log_2(2^{29}) < \\log_2(10^9) < \\log_2(2^{30})$$\n$$29 < \\log_2(10^9) < 30$$\nTherefore, the floor of $\\log_2(10^9)$ is $29$:\n$$\\lfloor \\log_2(10^9) \\rfloor = 29$$\nFinally, we can compute the maximum stack depth:\n$$D(10^9) = \\lfloor \\log_2(10^9) \\rfloor + 2 = 29 + 2 = 31$$\nThe exact maximum stack depth for the input $x = 10^9$ is $31$.", "answer": "$$\\boxed{31}$$", "id": "3274586"}, {"introduction": "Finally, let's zoom in from the overall stack size to the inner workings of a single stack frame. Each recursive call creates its own isolated environment with its own parameters and local variables, a concept managed by the call stack. This thought experiment uses a hypothetical function with \"variable shadowing\" to test your understanding of lexical scoping and how the stack maintains separate variable bindings for each active function call. [@problem_id:3274515]", "problem": "Consider a language with lexical (static) scoping, pass-by-value parameter passing, and block-level identifier shadowing as in the Rust programming language. Each function call creates a new activation record on a Last-In-First-Out (LIFO) call stack, and variable lookup resolves to the nearest (most recently introduced) binding in the current scope. Shadowing “introduces” a new binding for the same identifier that hides the outer binding for the remainder of the inner scope. In this language, an initialization of a newly shadowed variable may reference the outer binding that it shadows.\n\nDefine a recursive function $\\mathrm{rec}(x,n)$ that behaves as follows:\n\n- Step $1$: Print the label $\\mathrm{P}$ followed by the current value of $x$.\n- Step $2$: Introduce a new local variable named $x$ via shadowing with the statement “let $x = x + n$.” This new $x$ is initialized using the previous binding of $x$ and the current $n$.\n- Step $3$: Print the label $\\mathrm{Q}$ followed by the current value of (the new, shadowing) $x$.\n- Step $4$: If $n > 0$, recursively call $\\mathrm{rec}(x - 1, n - 1)$, where the argument $x - 1$ uses the currently visible (shadowing) $x$.\n- Step $5$: After the recursive call returns (or immediately if the condition in Step $4$ was false), print the label $\\mathrm{R}$ followed by the current value of (the shadowing) $x$.\n\nAssume all prints occur immediately and in the order specified. What is the exact sequence of labels and numbers printed when the initial call $\\mathrm{rec}(2,2)$ is executed?\n\nChoose the correct option:\n\nA. $\\mathrm{P}\\,\\,2,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,3,\\, \\mathrm{R}\\,\\,3,\\, \\mathrm{R}\\,\\,4,\\, \\mathrm{R}\\,\\,4$\n\nB. $\\mathrm{P}\\,\\,2,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,1,\\, \\mathrm{Q}\\,\\,2,\\, \\mathrm{P}\\,\\,1,\\, \\mathrm{Q}\\,\\,1,\\, \\mathrm{R}\\,\\,1,\\, \\mathrm{R}\\,\\,2,\\, \\mathrm{R}\\,\\,4$\n\nC. $\\mathrm{P}\\,\\,2,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,4,\\, \\mathrm{Q}\\,\\,5,\\, \\mathrm{P}\\,\\,5,\\, \\mathrm{Q}\\,\\,5,\\, \\mathrm{R}\\,\\,5,\\, \\mathrm{R}\\,\\,5,\\, \\mathrm{R}\\,\\,4$\n\nD. $\\mathrm{P}\\,\\,2,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,3,\\, \\mathrm{R}\\,\\,4,\\, \\mathrm{R}\\,\\,4,\\, \\mathrm{R}\\,\\,3$", "solution": "We will trace the execution of `rec(2,2)$ step-by-step, keeping track of the call stack and the values of variables in each activation record (scope). The key is to correctly identify which binding of the variable $x$ is visible at each step, especially due to the shadowing rule.\n\n**Call 1: `rec(2, 2)`**\n-   **State:** An activation record for `rec(2, 2)` is pushed onto the call stack. Within this scope, the parameter `x` is initialized to $2$ and `n` is initialized to $2$.\n-   **Step 1:** Print `P` and the current value of `x`. The visible `x` is the parameter, value $2$.\n    -   **Output:** $\\mathrm{P}\\,\\,2$\n-   **Step 2:** A new local variable `x` is declared and initialized: `let x = x + n`. The `x` on the right-hand side refers to the outer binding (the parameter, value $2$), and `n` is $2$. The new, shadowing `x` is initialized to $2 + 2 = 4$. For the remainder of this function's scope, this new `x` (value $4$) is the one that is visible.\n-   **Step 3:** Print `Q` and the current value of `x`. The visible `x` is the new, shadowing one, value $4$.\n    -   **Output:** $\\mathrm{P}\\,\\,2,\\, \\mathrm{Q}\\,\\,4$\n-   **Step 4:** Check if `n > 0`. Since $2 > 0$ is true, a recursive call is made: `rec(x - 1, n - 1)`. The arguments are evaluated using the currently visible variables: `x` is the shadowing variable with value $4$, and `n` is $2$. The arguments passed are $4 - 1 = 3$ and $2 - 1 = 1$.\n-   **Execution pauses** pending the return of `rec(3, 1)`.\n\n**Call 2: `rec(3, 1)`**\n-   **State:** An activation record for `rec(3, 1)` is pushed onto the stack. Within this new scope, the parameter `x` is initialized to $3$ and `n` is initialized to $1$.\n-   **Step 1:** Print `P` and the current value of `x`. The visible `x` is the parameter, value $3$.\n    -   **Output:** $\\mathrm{P}\\,\\,2,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3$\n-   **Step 2:** A new local variable `x` is declared and initialized: `let x = x + n`. The `x` on the right-hand side refers to the outer binding in this scope (the parameter, value $3$), and `n` is $1$. The new, shadowing `x` is initialized to $3 + 1 = 4$.\n-   **Step 3:** Print `Q` and the current value of `x`. The visible `x` is the new, shadowing one, value $4$.\n    -   **Output:** $\\mathrm{P}\\,\\,2,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,4$\n-   **Step 4:** Check if `n > 0$. Since $1 > 0$ is true, a recursive call is made: `rec(x - 1, n - 1)`. The arguments are evaluated using the currently visible variables: `x` is the shadowing variable with value $4$, and `n` is $1$. The arguments passed are $4 - 1 = 3$ and $1 - 1 = 0$.\n-   **Execution pauses** pending the return of `rec(3, 0)`.\n\n**Call 3: `rec(3, 0)` (Base Case)**\n-   **State:** An activation record for `rec(3, 0)` is pushed onto the stack. Within this scope, the parameter `x` is initialized to $3$ and `n` is initialized to $0$.\n-   **Step 1:** Print `P` and the current value of `x`. The visible `x` is the parameter, value $3$.\n    -   **Output:** $\\mathrm{P}\\,\\,2,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3$\n-   **Step 2:** A new local variable `x` is declared and initialized: `let x = x + n`. The `x` on the right-hand side refers to the parameter `x` (value $3$), and `n` is $0$. The new, shadowing `x` is initialized to $3 + 0 = 3$.\n-   **Step 3:** Print `Q` and the current value of `x`. The visible `x` is the new, shadowing one, value $3$.\n    -   **Output:** $\\mathrm{P}\\,\\,2,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,3$\n-   **Step 4:** Check if `n > 0$. Since $0 > 0$ is false, the recursive call is skipped.\n-   **Step 5:** Print `R` and the current value of `x`. The `let` statement in Step $2$ introduced a new scope for the shadowing `x` that persists until the function returns. The visible `x` is this shadowing variable, value $3$.\n    -   **Output:** $\\mathrm{P}\\,\\,2,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,3,\\, \\mathrm{R}\\,\\,3$\n-   **Execution of `rec(3, 0)` finishes.** The activation record is popped from the stack, and control returns to the caller (`rec(3, 1)`).\n\n**Return to `rec(3, 1)`**\n-   **State:** Execution resumes in `rec(3, 1)` after the recursive call in Step $4$.\n-   **Step 5:** Print `R` and the current value of `x`. Within the scope of `rec(3, 1)`, the visible `x` is still the one introduced by its own `let` statement (Step $2$ of `Call 2`). This `x` has the value $4$.\n    -   **Output:** $\\mathrm{P}\\,\\,2,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,3,\\, \\mathrm{R}\\,\\,3,\\, \\mathrm{R}\\,\\,4$\n-   **Execution of `rec(3, 1)` finishes.** The activation record is popped, and control returns to the caller (`rec(2, 2)`).\n\n**Return to `rec(2, 2)`**\n-   **State:** Execution resumes in `rec(2, 2)` after the recursive call in Step $4$.\n-   **Step 5:** Print `R` and the current value of `x`. Within the scope of `rec(2, 2)`, the visible `x` is the one introduced by its own `let` statement (Step $2$ of `Call 1`). This `x` has the value $4$.\n    -   **Output:** $\\mathrm{P}\\,\\,2,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,3,\\, \\mathrm{R}\\,\\,3,\\, \\mathrm{R}\\,\\,4,\\, \\mathrm{R}\\,\\,4$\n-   **Execution of `rec(2, 2)` finishes.** The program terminates.\n\nThe final, complete sequence of prints is: $\\mathrm{P}\\,\\,2,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,4,\\, \\mathrm{P}\\,\\,3,\\, \\mathrm{Q}\\,\\,3,\\, \\mathrm{R}\\,\\,3,\\, \\mathrm{R}\\,\\,4,\\, \\mathrm{R}\\,\\,4$.\n\nThis sequence matches option A exactly.", "answer": "$$\\boxed{A}$$", "id": "3274515"}]}