{"hands_on_practices": [{"introduction": "This exercise provides a practical application of recursion to a classic combinatorial problem. You will implement a solution to the coin change problem by partitioning the solution space at each recursive step. This \"include-exclude\" pattern, where you consider solutions with a specific coin versus those without it, is a fundamental technique in designing recursive algorithms and provides a clear path from a complex problem to manageable subproblems [@problem_id:3213512].", "problem": "You are to design and implement a recursive procedure that counts the number of distinct ways to form a nonnegative integer total using an unlimited number of coin types, where order does not matter. Let $S$ be an array of $m$ positive integers representing coin denominations, and let $n$ be the target sum. The counting function must be based on first principles of combinatorial enumeration and recursive decomposition, and it must correctly handle all base cases that prevent infinite descent and ensure correctness.\n\nFormally, define a function $count(S, m, n)$ that returns the number of distinct multisets of the first $m$ coin types in $S$ that sum to $n$. Two representations that differ only by the ordering of the same multiset of coins must be considered the same (for example, using coins $[1,2,2]$ and $[2,1,2]$ are not different). Each coin type may be used any nonnegative number of times.\n\nYour design must start from the fundamental definitions of combinatorial counting and must use a recursive step that partitions the solution space into disjoint subproblems. The function must implement and justify the following base cases:\n- $n = 0$ should return $1$, corresponding to the empty multiset as the one valid way to make zero.\n- $n < 0$ should return $0$, since no multiset of positive denominations can sum to a negative target.\n- $m \\le 0$ and $n > 0$ should return $0$, since with no available coin types there is no way to make a positive sum.\n\nYour program must implement $count(S, m, n)$ using recursion consistent with these base cases and a logically sound recursive step derived from the combinatorial counting principle. The implementation must not rely on any non-recursive shortcuts; any optimization must preserve the recursive structure.\n\nNo physical units, angles, or percentages are involved. All outputs are integers.\n\nTest Suite:\nCompute $count(S, m, n)$ for the following parameter sets in the exact order given:\n- Case 1: $S = [2, 3, 5, 6]$, $m = 4$, $n = 10$.\n- Case 2: $S = [2, 3, 5, 6]$, $m = 4$, $n = 0$.\n- Case 3: $S = [2, 3]$, $m = 0$, $n = 7$.\n- Case 4: $S = [1, 2, 3]$, $m = 3$, $n = 4$.\n- Case 5: $S = [1, 2, 5]$, $m = 2$, $n = 5$.\n- Case 6: $S = [2]$, $m = 1$, $n = -5$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order of the test suite (for example, [$r_1$,$r_2$,$r_3$,$r_4$,$r_5$,$r_6$], where each $r_i$ is the integer result for Case $i$).", "solution": "The user-provided problem is a classic exercise in combinatorial enumeration and algorithm design, commonly known as the coin change problem (or a variation of the integer partition problem). The task is to formulate a recursive function, $count(S, m, n)$, that calculates the number of distinct ways to achieve a sum of $n$ using the first $m$ coin denominations given in an array $S$. The problem requires a solution built from first principles, specifically recursive decomposition and the explicit handling of specified base cases.\n\nThe design of the recursive solution is founded on the principle of partitioning a problem's solution space into a collection of smaller, disjoint subproblems. The total number of solutions is then the sum of the solutions to these subproblems. Let $C(m, n)$ denote the function $count(S, m, n)$, representing the number of ways to form the sum $n$ using coins from the set $\\{S[0], S[1], \\dots, S[m-1]\\}$.\n\nThe core of the recursive step is to consider the last coin in the available set, which is $S[m-1]$ (assuming zero-based indexing for the array $S$). Every possible way to form the sum $n$ either uses this coin at least once, or it does not use it at all. These two categories are mutually exclusive and exhaustive, forming a perfect partition of the solution space.\n\n1.  **Solutions that exclude the $m$-th coin ($S[m-1]$):** If we decide not to use the coin $S[m-1]$, the problem reduces to finding the number of ways to form the sum $n$ using only the remaining $m-1$ coins, i.e., $\\{S[0], \\dots, S[m-2]\\}$. The number of ways to do this is, by definition, $C(m-1, n)$.\n\n2.  **Solutions that include the $m$-th coin ($S[m-1]$) at least once:** If we commit to using the coin $S[m-1]$ at least once, we can set one such coin aside. The remaining sum to be formed is $n - S[m-1]$. This remaining sum must be formed using coins from the available set. Since coin reuse is unlimited, the set of available coins remains $\\{S[0], \\dots, S[m-1]\\}$. Therefore, the number of ways to form this remaining sum is $C(m, n - S[m-1])$.\n\nBy the sum rule of combinatorics, the total number of ways to form the sum $n$ with the first $m$ coins is the sum of the number of solutions in these two disjoint sets. This gives the fundamental recurrence relation:\n$$C(m, n) = C(m-1, n) + C(m, n - S[m-1])$$\n\nThis recurrence relation must be anchored by base cases that terminate the recursion. The problem statement provides these, and their justification is as follows:\n\n-   **Base Case 1: $n = 0$**\n    The function must return $1$. A target sum of $0$ can be achieved in exactly one way: by selecting no coins (the empty multiset). This holds regardless of the coins available, so $C(m, 0) = 1$ for any $m \\ge 0$.\n\n-   **Base Case 2: $n < 0$**\n    The function must return $0$. It is impossible to form a negative sum using coin denominations that are all positive integers. This case is typically reached when the recursive step subtracts a coin value, $S[m-1]$, that is larger than the remaining target, $n$. Thus, $C(m, n) = 0$ for $n < 0$.\n\n-   **Base Case 3: $m \\le 0$ and $n > 0$**\n    The function must return $0$. If there are no coins available ($m \\le 0$) and the target sum is positive ($n > 0$), it is impossible to form the sum. This case is reached when the recursive step $C(m-1, n)$ has decremented $m$ to zero. The condition $n > 0$ is crucial, as the case $n=0$ takes precedence.\n\nCombining the recurrence relation and the base cases yields the complete recursive algorithm for $count(S, m, n)$:\n1.  If $n = 0$, return $1$.\n2.  If $n < 0$, return $0$.\n3.  If $m \\le 0$ and $n > 0$, return $0$.\n4.  Otherwise, return $count(S, m-1, n) + count(S, m, n - S[m-1])$.\n\nThis formulation correctly implements the required logic based on first principles and satisfies all conditions of the problem statement. The implementation will directly translate this logic into a recursive Python function.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count(S, m, n):\n    \"\"\"\n    Recursively counts the number of ways to form the sum n using the first m coins from S.\n\n    Args:\n        S (list[int]): The array of coin denominations.\n        m (int): The number of coin types to consider from the start of S.\n        n (int): The target sum.\n\n    Returns:\n        int: The number of distinct ways to make the sum.\n    \"\"\"\n    # Base Case 1: If the target sum is 0, there is one solution (the empty set).\n    if n == 0:\n        return 1\n\n    # Base Case 2: If the target sum is negative, no solution is possible.\n    if n < 0:\n        return 0\n\n    # Base Case 3: If there are no coins (m <= 0) and the sum is positive (n > 0),\n    # no solution is possible.\n    if m <= 0 and n > 0:\n        return 0\n\n    # Recursive Step:\n    # The total number of solutions is the sum of two disjoint sets:\n    # 1. Solutions that do not include the m-th coin (S[m-1]).\n    #    This is count(S, m - 1, n).\n    # 2. Solutions that include at least one m-th coin (S[m-1]).\n    #    This is count(S, m, n - S[m-1]).\n    # Note that S is 0-indexed, so the m-th coin is at index m-1.\n    return count(S, m - 1, n) + count(S, m, n - S[m - 1])\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the coin change problem.\n    \"\"\"\n    # The test cases are defined as tuples of (S, m, n).\n    test_cases = [\n        # Case 1: S = [2,3,5,6], m = 4, n = 10\n        ([2, 3, 5, 6], 4, 10),\n        # Case 2: S = [2,3,5,6], m = 4, n = 0\n        ([2, 3, 5, 6], 4, 0),\n        # Case 3: S = [2,3], m = 0, n = 7\n        ([2, 3], 0, 7),\n        # Case 4: S = [1,2,3], m = 3, n = 4\n        ([1, 2, 3], 3, 4),\n        # Case 5: S = [1,2,5], m = 2, n = 5\n        ([1, 2, 5], 2, 5),\n        # Case 6: S = [2], m = 1, n = -5\n        ([2], 1, -5)\n    ]\n\n    results = []\n    for S, m, n in test_cases:\n        result = count(S, m, n)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3213512"}, {"introduction": "Moving from numerical problems to structural recursion, this practice tackles the \"word break\" problem on strings. The recursive insight here is to decompose the string into a prefix (a potential dictionary word) and a suffix, then recurse on the suffix. This exercise not only reinforces the core concepts of base cases and recursive steps but also introduces the essential optimization technique of memoization to handle overlapping subproblems efficiently [@problem_id:3213661].", "problem": "You are to implement a recursive solution to the word break decision problem grounded in the principles of recursion on strings. Let the alphabet be denoted by $\\Sigma$, let the dictionary be a finite set $\\mathcal{D} \\subseteq \\Sigma^{\\ast}$, and let the input string be $s \\in \\Sigma^{\\ast}$. The recursive design must be based on the following fundamental notions: every string $s$ admits a decomposition into a prefix $p$ and a suffix $t$ such that $s = p \\cdot t$, the empty string is denoted by $\\epsilon$, and recursion proceeds on strictly shorter suffixes until it reaches $\\epsilon$. The base case is when $s = \\epsilon$. The recursive step checks whether a dictionary word $w \\in \\mathcal{D}$ is a prefix of $s$, and if so, it recurses on the corresponding suffix $t$.\n\nDefine the following two quantities for any $s \\in \\Sigma^{\\ast}$ with respect to $\\mathcal{D}$:\n- The segmentation count $C(s)$, which is the number of distinct ways to split $s$ into a sequence of words from $\\mathcal{D}$ that concatenates to $s$.\n- The minimal word count $M(s)$, which is the smallest number of words in any valid segmentation of $s$ using $\\mathcal{D}$, with the convention that if there is no valid segmentation then $M(s) = -1$.\n\nYour program must compute three outputs per test case:\n- A boolean $B(s)$ indicating if at least one valid segmentation exists, that is, $B(s)$ is $\\text{True}$ if and only if $C(s) > 0$ and $\\text{False}$ otherwise.\n- The integer $C(s)$.\n- The integer $M(s)$.\n\nThe recursion must adhere to the following design constraints:\n- Base case: for $s = \\epsilon$, $C(\\epsilon) = 1$ and $M(\\epsilon) = 0$.\n- Recursive step: for $s \\neq \\epsilon$, consider all $w \\in \\mathcal{D}$ such that $w$ is a prefix of $s$. For each such $w$, let the suffix be $t$ satisfying $s = w \\cdot t$, and recurse on $t$. For $C(s)$, sum the contributions across all valid prefixes. For $M(s)$, take the minimum of $1 + M(t)$ over all suffixes $t$ that admit a valid segmentation. If no valid prefix leads to a valid segmentation, then $C(s) = 0$ and $M(s) = -1$.\n- Use memoization to ensure that the recursion runs in time bounded by a polynomial in $|s|$ times $|\\mathcal{D}|$, by avoiding redundant recomputation over overlapping subproblems. State the measure that guarantees termination and ensures the well-foundedness of the recursion.\n\nTest suite. Your program must compute results for the following set of test cases, each being a pair $(s, \\mathcal{D})$:\n- Case $1$: $s = \\text{\"catsanddog\"}$, $\\mathcal{D} = \\{\\text{\"cat\"}, \\text{\"cats\"}, \\text{\"and\"}, \\text{\"sand\"}, \\text{\"dog\"}\\}$.\n- Case $2$: $s = \\text{\"\"}$ (the empty string), $\\mathcal{D} = \\{\\text{\"a\"}\\}$.\n- Case $3$: $s = \\text{\"abc\"}$, $\\mathcal{D} = \\{\\text{\"ab\"}, \\text{\"ac\"}\\}$.\n- Case $4$: $s = \\text{\"leetcode\"}$, $\\mathcal{D} = \\{\\text{\"leet\"}, \\text{\"code\"}, \\text{\"leetcode\"}\\}$.\n- Case $5$: $s = \\text{\"aaaaaaa\"}$, $\\mathcal{D} = \\{\\text{\"a\"}, \\text{\"aa\"}, \\text{\"aaaa\"}\\}$.\n\nOutput specification. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the result for each test case is itself a list of the form $[\\;B(s),\\;C(s),\\;M(s)\\;]$. For example, the output format must be $[\\,[\\;B(s_1),C(s_1),M(s_1)\\;],\\,[\\;B(s_2),C(s_2),M(s_2)\\;],\\ldots\\,]$. No physical units are involved and no angles or percentages appear in this problem.", "solution": "The problem requires the implementation of a recursive algorithm to solve the word break problem, augmented with counting the number of possible segmentations and finding the minimum number of words in a valid segmentation. The solution must employ memoization to achieve polynomial-time performance.\n\nThe core of the solution is a recursive function that operates on a given string $s \\in \\Sigma^{\\ast}$ and a dictionary $\\mathcal{D} \\subseteq \\Sigma^{\\ast}$. This function computes three quantities: a boolean $B(s)$ indicating if any valid segmentation exists, an integer $C(s)$ for the total count of distinct segmentations, and an integer $M(s)$ for the minimum number of words in a segmentation.\n\nThe recursive structure is defined by the decomposition of a string $s$ into a prefix $w$ and a suffix $t$, such that $s = w \\cdot t$. The recursion proceeds by finding all prefixes $w$ of $s$ that are present in the dictionary $\\mathcal{D}$ and then recursively solving the problem for the corresponding suffixes $t$.\n\nThe recursive relations and base cases are formally defined as follows:\n\nLet $s$ be the input string and $\\mathcal{D}$ be the dictionary.\n\nBase Case: For the empty string $s = \\epsilon$:\n- The empty string is considered a valid segmentation of itself, consisting of zero words.\n- The number of ways to segment the empty string is $1$: $C(\\epsilon) = 1$.\n- The minimum number of words in this segmentation is $0$: $M(\\epsilon) = 0$.\n- Since $C(\\epsilon) > 0$, a segmentation exists: $B(\\epsilon) = \\text{True}$.\n\nRecursive Step: For a non-empty string $s \\neq \\epsilon$:\nThe quantities are computed by considering all words $w \\in \\mathcal{D}$ that are prefixes of $s$. For each such $w$, we find the corresponding suffix $t$ where $s = w \\cdot t$ and make a recursive call on $t$.\n\n1.  Segmentation Count, $C(s)$: The total number of segmentations for $s$ is the sum of the number of segmentations for all possible suffixes $t$ that result from stripping a valid dictionary-word prefix $w$.\n    $$\n    C(s) = \\sum_{w \\in \\mathcal{D} \\mid s \\text{ starts with } w} C(s[|w|..])\n    $$\n    where $s[|w|..]$ denotes the suffix of $s$ after removing the prefix $w$ of length $|w|$. If no such $w$ exists, the sum is empty and $C(s) = 0$.\n\n2.  Minimal Word Count, $M(s)$: The minimal word count for $s$ is one plus the minimum of the minimal word counts of all its validly segmentable suffixes.\n    $$\n    M(s) = \\min \\{1 + M(t) \\mid s = w \\cdot t, w \\in \\mathcal{D}, C(t) > 0\\}\n    $$\n    If the set of such suffixes $t$ is empty (i.e., no prefix $w \\in \\mathcal{D}$ leads to a suffix $t$ that can be segmented), then there is no valid segmentation for $s$. In this case, we adhere to the convention $M(s) = -1$.\n\n3.  Existence of Segmentation, $B(s)$: This boolean value is directly determined by the segmentation count.\n    $$\n    B(s) = (C(s) > 0)\n    $$\n\nTermination and Well-Foundedness: The recursion is guaranteed to terminate. The measure that ensures termination is the length of the string, $|s|$, which is a non-negative integer. Each recursive call is made on a suffix $t$ of $s$, where the corresponding prefix $w$ is a word from the dictionary and is thus non-empty. This implies $|t| < |s|$. A strictly decreasing sequence of non-negative integers must be finite. Therefore, the recursion is well-founded and will always terminate at the base case where $|s| = 0$ (i.e., $s = \\epsilon$).\n\nMemoization: A naive recursive implementation would have an exponential time complexity due to recomputing results for the same substrings multiple times (overlapping subproblems). To optimize this, we use memoization, a technique characteristic of dynamic programming. A cache (e.g., a hash map) stores the results $(B(s'), C(s'), M(s'))$ for each substring $s'$ that has been processed. Before computing the result for any string $s'$, the cache is checked. If the result is present, it is returned immediately. Otherwise, the computation proceeds, and the newly computed result is stored in the cache before being returned. This ensures that the subproblem for each unique suffix is solved only once. The time complexity becomes polynomial, roughly proportional to $|s|^2 \\cdot |\\mathcal{D}|$ in a straightforward implementation, or more precisely, determined by the number of subproblems (one for each suffix of $s$, which is $|s|+1$) times the work per subproblem (iterating through $\\mathcal{D}$).\n\nAlgorithmic Implementation: A single recursive function is designed to compute the triplet $(B(s), C(s), M(s))$ to avoid redundant traversals of the recursion tree.\n- The function takes the string $s$, the dictionary $\\mathcal{D}$, and the memoization cache as arguments.\n- It first checks the cache for $s$. If found, it returns the cached value.\n- It then checks for the base case $s = \\epsilon$, returning $(\\text{True}, 1, 0)$ if true.\n- For the recursive step, it initializes `total_count` to $0$ and `min_words` to a value representing infinity (e.g., `float('inf')`).\n- It iterates through each word $w$ in $\\mathcal{D}$. If $w$ is a prefix of $s$, it recursively calls itself on the suffix $t$.\n- If the recursive call for $t$ returns a result indicating a valid segmentation (i.e., $B(t)$ is True), it aggregates the results: `total_count` is incremented by $C(t)$, and `min_words` is updated with $\\min(\\text{min\\_words}, 1 + M(t))$.\n- After checking all prefixes, if `total_count` is still $0$, no segmentation was found. The result for $s$ is $(\\text{False}, 0, -1)$.\n- Otherwise, the result is $(\\text{True}, \\text{total\\_count}, \\text{min\\_words})$.\n- Finally, this result is stored in the cache for $s$ and returned.\nThis integrated approach correctly computes all three required quantities in a single, efficient recursive process.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print results.\n    \"\"\"\n\n    test_cases = [\n        (\"catsanddog\", {\"cat\", \"cats\", \"and\", \"sand\", \"dog\"}),\n        (\"\", {\"a\"}),\n        (\"abc\", {\"ab\", \"ac\"}),\n        (\"leetcode\", {\"leet\", \"code\", \"leetcode\"}),\n        (\"aaaaaaa\", {\"a\", \"aa\", \"aaaa\"}),\n    ]\n\n    results = []\n    for s, word_dict in test_cases:\n        memo = {}\n        b_s, c_s, m_s = _solve_recursive(s, word_dict, memo)\n        results.append([b_s, c_s, m_s])\n\n    # Final print statement in the exact required format.\n    # str() on a list gives a good representation, e.g., \"[True, 2, 3]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_recursive(s: str, word_dict: set, memo: dict):\n    \"\"\"\n    Recursively solves the word break problem with memoization.\n\n    Args:\n        s (str): The input string to segment.\n        word_dict (set): The dictionary of valid words.\n        memo (dict): The memoization cache.\n\n    Returns:\n        tuple[bool, int, int]: A tuple containing (B(s), C(s), M(s)).\n            - B(s): True if a segmentation exists, False otherwise.\n            - C(s): The number of distinct valid segmentations.\n            - M(s): The minimum number of words in a segmentation (-1 if none).\n    \"\"\"\n    if s in memo:\n        return memo[s]\n\n    # Base case: The empty string has one segmentation (the empty one)\n    # with zero words.\n    if not s:\n        # C(epsilon) = 1, M(epsilon) = 0\n        return True, 1, 0\n\n    total_count = 0\n    min_words = float('inf')\n\n    # Recursive step: Iterate through all dictionary words as potential prefixes.\n    for word in word_dict:\n        if s.startswith(word):\n            suffix = s[len(word):]\n            \n            # Recurse on the suffix.\n            b_suffix, c_suffix, m_suffix = _solve_recursive(suffix, word_dict, memo)\n\n            # If the suffix can be segmented, aggregate the results.\n            if b_suffix:\n                # Add the number of segmentations of the suffix.\n                total_count += c_suffix\n                \n                # Update the minimum words count for the current string.\n                min_words = min(min_words, 1 + m_suffix)\n\n    # After checking all possible prefixes, finalize the result for s.\n    if total_count == 0:\n        # No valid segmentation found for s.\n        result = (False, 0, -1)\n    else:\n        # A valid segmentation was found.\n        result = (True, total_count, int(min_words))\n    \n    # Cache the result before returning.\n    memo[s] = result\n    return result\n\n# Execute the solution.\nsolve()\n```", "id": "3213661"}, {"introduction": "This final practice moves beyond counting or decision problems to the task of generating all possible solutions. You will design a recursive algorithm to generate all unique permutations of a string, a fundamental task in computer science. The challenge is amplified by the need to handle duplicate characters correctly within the recursive logic, which requires a deeper understanding of how to manage state at each level of the recursion to avoid redundant work and ensure unique results [@problem_id:3213530].", "problem": "You are asked to implement and reason about a purely recursive algorithm that generates all permutations of a given string by repeatedly choosing a character to be first. The algorithm must adhere to the following recursive shape: the base case is when the input string has length $1$, and the recursive step constructs solutions for length $n$ from solutions for length $n-1$ by fixing a first character and recursing on the remaining characters. You must also correctly handle input strings that contain repeated characters so that the generated permutations are unique, without using non-recursive global deduplication.\n\nFundamental base and constraints:\n- Let $s$ be a non-empty string of lowercase English letters, and let $|s| = n$.\n- The algorithm must be defined by structural recursion on $n$:\n  - Base case: if $n = 1$, return the list containing only $s$.\n  - Recursive step: if $n \\ge 2$, for each index $i$ with $0 \\le i < n$, choose the character $s_i$ to be first, recursively generate all permutations of the remaining string $s$ with the $i$-th character removed, and prepend $s_i$ to each of those sub-permutations.\n- To ensure uniqueness when $s$ has repeated characters, at each recursive call you must avoid choosing the same first character more than once at that call depth. This must be accomplished by tracking which first characters have been used at the current depth and skipping repetitions. Do not use library permutation utilities or iterative algorithms to replace the recursive structure.\n- The function must generate the permutations; however, for testability, your program should output only the count of unique permutations generated for each test case.\n\nInput specification:\n- There is no external input. You must hard-code the test suite described below inside your program.\n\nOutput specification:\n- For each test case in the test suite, compute the number of unique permutations produced by your recursive algorithm and collect these counts in order.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, \"[1,2,3]\". The elements must be integers.\n\nTest suite:\n- Use the following strings as test cases, in this order, to exercise general behavior, base cases, and handling of repeated characters:\n  - $s_1 = \\text{\"a\"}$.\n  - $s_2 = \\text{\"ab\"}$.\n  - $s_3 = \\text{\"aba\"}$.\n  - $s_4 = \\text{\"abcd\"}$.\n  - $s_5 = \\text{\"aabb\"}$.\n  - $s_6 = \\text{\"aaa\"}$.\n\nDesign for coverage:\n- $s_1$ checks the base case $n=1$.\n- $s_2$ checks a minimal non-trivial case with all distinct characters.\n- $s_3$ checks proper uniqueness control when a character repeats.\n- $s_4$ checks a larger case with all distinct characters.\n- $s_5$ checks multiple repeated characters with more complex deduplication.\n- $s_6$ checks the extreme case where all characters are identical.\n\nYour task:\n- Implement the recursive permutation generator exactly following the base case $n=1$ and the recursive step of choosing a first character, with per-depth skipping of duplicate first choices.\n- Apply it to the test suite, compute the count of unique permutations for each case, and print the list of counts in the required format.", "solution": "The problem has been analyzed and is deemed valid. It is a well-posed, self-contained, and scientifically grounded problem in the domain of algorithms and computer science. The problem statement is clear, objective, and provides all necessary information to construct a unique and verifiable solution.\n\nThe task is to implement a purely recursive algorithm for generating all unique permutations of a string $s$, which may contain repeated characters. The uniqueness must be enforced during the recursive generation process, not by post-processing. The core of the algorithm is specified by its recursive structure.\n\nLet $P(s)$ be the function that generates the set of unique permutations of a string $s$ of length $n = |s|$. The algorithm is defined by structural recursion on $n$.\n\n**Base Case:**\nFor a string $s$ of length $n = 1$, there is only one permutation: the string itself.\n$$P(s) = \\{s\\}, \\quad \\text{if } |s| = 1$$\nFor example, $P(\\text{\"a\"}) = \\{\\text{\"a\"}\\}$. The count of permutations is $1$.\n\n**Recursive Step:**\nFor a string $s$ of length $n \\ge 2$, the set of permutations is constructed by selecting each unique character from $s$ to be the first character of the new permutations. For each such unique first character, we recursively generate the permutations of the remaining characters and prepend the chosen first character to them.\n\nTo handle duplicate characters correctly and avoid generating duplicate permutations, we must ensure that at any given level of recursion, we do not initiate a recursive sub-problem with the same first character more than once. We can achieve this by maintaining a set of characters that have already been chosen as the first character at the current recursive call.\n\nLet $s = s_0s_1\\dots s_{n-1}$. Let $U$ be a set used to track the characters at the current recursion depth that have been selected as the leading character. Initially, $U$ is empty. We iterate through $s$ from index $i=0$ to $n-1$.\n\nFor each index $i$:\n1. Let the candidate first character be $c = s_i$.\n2. Check if $c$ is already in the set $U$.\n   - If $c \\in U$, we have already processed this character as a leading character at this depth. We skip this iteration to avoid redundant computation and duplicate results.\n   - If $c \\notin U$, we proceed. Add $c$ to $U$ (i.e., $U := U \\cup \\{c\\}$).\n3. Construct the remaining substring, $s'$, by removing the character $s_i$ from $s$. This can be expressed as $s' = s_0\\dots s_{i-1}s_{i+1}\\dots s_{n-1}$.\n4. Recursively call the permutation function on the remaining string: $P(s')$.\n5. For each permutation $p$ in the returned set $P(s')$, form a new permutation by prepending $c$: $c \\cdot p$.\n6. Collect all such generated permutations from all unique choices of $c$.\n\nThe final result for $P(s)$ is the union of all permutations generated for each unique first character:\n$$P(s) = \\bigcup_{c \\in \\text{unique_chars}(s)} \\{c \\cdot p \\mid p \\in P(s' \\text{ where } s' \\text{ is } s \\text{ with one instance of } c \\text{ removed})\\}$$\n\nLet's trace the execution for $s = \\text{\"aba\"}$, where $n = 3$.\n$P(\\text{\"aba\"})$:\n- Initialize $U = \\emptyset$.\n- **Iteration $i=0$**: $c = s_0 = \\text{'a'}$. Since $\\text{'a'} \\notin U$, add it: $U = \\{\\text{'a'}\\}$.\n  - The remaining string is $s' = \\text{\"ba\"}$.\n  - Recursively call $P(\\text{\"ba\"})$.\n    - $P(\\text{\"ba\"})$ will generate $\\{\\text{\"ba\"}, \\text{\"ab\"}\\}$.\n  - Prepend $\\text{'a'}$ to each: $\\{\\text{\"aba\"}, \\text{\"aab\"}\\}$.\n- **Iteration $i=1$**: $c = s_1 = \\text{'b'}$. Since $\\text{'b'} \\notin U$, add it: $U = \\{\\text{'a'}, \\text{'b'}\\}$.\n  - The remaining string is $s' = \\text{\"aa\"}$.\n  - Recursively call $P(\\text{\"aa\"})$.\n    - $P(\\text{\"aa\"})$: Initialize $U' = \\emptyset$.\n      - Iteration $i=0$: $c' = \\text{'a'}$. Add to $U'$. Remaining is $\\text{\"a\"}$. $P(\\text{\"a\"})$ returns $\\{\\text{\"a\"}\\}$. Prepend $c'$ to get $\\{\\text{\"aa\"}\\}$.\n      - Iteration $i=1$: $c' = \\text{'a'}$. Since $\\text{'a'} \\in U'$, skip.\n    - $P(\\text{\"aa\"})$ returns $\\{\\text{\"aa\"}\\}$.\n  - Prepend $\\text{'b'}$ to each: $\\{\\text{\"baa\"}\\}$.\n- **Iteration $i=2$**: $c = s_2 = \\text{'a'}$. Since $\\text{'a'} \\in U$, skip.\n- The final set of permutations is the union of the results from the valid iterations: $\\{\\text{\"aba\"}, \\text{\"aab\"}\\} \\cup \\{\\text{\"baa\"}\\} = \\{\\text{\"aba\"}, \\text{\"aab\"}, \\text{\"baa\"}\\}$.\n- The number of unique permutations is $3$.\n\nThis count matches the combinatorial formula for permutations of a multiset. If a string of length $n$ has $k$ distinct characters with multiplicities $n_1, n_2, \\dots, n_k$ (where $\\sum_{j=1}^{k} n_j = n$), the number of unique permutations is given by the multinomial coefficient:\n$$ \\frac{n!}{n_1! n_2! \\dots n_k!} $$\n\nLet's verify the test cases against this formula:\n- $s_1 = \\text{\"a\"}$: $n=1, n_a=1$. Count = $\\frac{1!}{1!} = 1$.\n- $s_2 = \\text{\"ab\"}$: $n=2, n_a=1, n_b=1$. Count = $\\frac{2!}{1!1!} = 2$.\n- $s_3 = \\text{\"aba\"}$: $n=3, n_a=2, n_b=1$. Count = $\\frac{3!}{2!1!} = \\frac{6}{2} = 3$.\n- $s_4 = \\text{\"abcd\"}$: $n=4$. Distinct characters. Count = $\\frac{4!}{1!1!1!1!} = 24$.\n- $s_5 = \\text{\"aabb\"}$: $n=4, n_a=2, n_b=2$. Count = $\\frac{4!}{2!2!} = \\frac{24}{4} = 6$.\n- $s_6 = \\text{\"aaa\"}$: $n=3, n_a=3$. Count = $\\frac{3!}{3!} = 1$.\n\nThe algorithm described correctly implements this combinatorial principle through recursion. The 'used characters' set at each depth prevents redundant branches in the recursion tree, which is equivalent to dividing by the factorials of the counts of repeated characters in the combinatorial formula.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the number of unique permutations for a given\n    set of test strings using a specified recursive algorithm.\n    \"\"\"\n\n    def get_unique_permutations(s: str) -> list[str]:\n        \"\"\"\n        Generates all unique permutations of a string using a recursive approach.\n\n        The algorithm adheres to the specified recursive structure:\n        - Base Case: If the string length is 1, return the string itself.\n        - Recursive Step: For each unique character in the string, fix it as the\n          first character, and recursively find all permutations of the remaining\n          characters. Prepend the fixed character to each of these sub-permutations.\n\n        Uniqueness is handled by tracking which characters have been used as the\n        first character at each level of the recursion to avoid redundant computations.\n\n        Args:\n            s: The input string.\n\n        Returns:\n            A list of unique permutation strings.\n        \"\"\"\n        # Base case: if |s| = 1, there is only one permutation.\n        # This matches the problem specification.\n        n = len(s)\n        if n == 1:\n            return [s]\n\n        # Recursive step: for |s| >= 2.\n        result_permutations = []\n        \n        # used_first_chars tracks characters already chosen to be first at this depth.\n        # This is the key to ensuring uniqueness without global deduplication.\n        used_first_chars = set()\n\n        for i in range(n):\n            first_char = s[i]\n            \n            # If this character has already been used as a starting point at this\n            # level of recursion, skip it to prevent duplicate permutations.\n            if first_char in used_first_chars:\n                continue\n            \n            # Mark this character as used for this recursion depth.\n            used_first_chars.add(first_char)\n\n            # Construct the remaining string by removing the character at index i.\n            remaining_s = s[:i] + s[i+1:]\n\n            # Recursively find all permutations of the remaining substring.\n            sub_permutations = get_unique_permutations(remaining_s)\n\n            # Prepend the current first_char to each sub-permutation and add to results.\n            for p in sub_permutations:\n                result_permutations.append(first_char + p)\n                \n        return result_permutations\n\n    # The test suite provided in the problem statement.\n    test_cases = [\n        \"a\",      # s_1: Base case n=1\n        \"ab\",     # s_2: Simple distinct case\n        \"aba\",    # s_3: Repeated character\n        \"abcd\",   # s_4: Larger distinct case\n        \"aabb\",   # s_5: Multiple repeated characters\n        \"aaa\",    # s_6: All characters identical\n    ]\n\n    results = []\n    for s_test in test_cases:\n        # The problem asks for the *count* of unique permutations.\n        permutations = get_unique_permutations(s_test)\n        count = len(permutations)\n        results.append(count)\n\n    # Final print statement must be in the exact required format.\n    # e.g., \"[1,2,3,24,6,1]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution.\nsolve()\n```", "id": "3213530"}]}