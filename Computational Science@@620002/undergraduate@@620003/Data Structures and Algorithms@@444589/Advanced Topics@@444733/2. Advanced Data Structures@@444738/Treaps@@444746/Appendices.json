{"hands_on_practices": [{"introduction": "One of the primary motivations for using a treap over a standard binary search tree is its resilience to sorted or adversarial insertion orders. This exercise challenges you to formalize this intuition by analyzing the treap's performance under a specific, non-random insertion pattern [@problem_id:3280465]. By correctly identifying the outcome, you will solidify your understanding of the treap's fundamental guarantee: its final structure is determined by the set of key-priority pairs, rendering its expected performance robust regardless of the insertion sequence.", "problem": "Consider a treap, which is a binary search tree on keys that simultaneously satisfies the heap property on an independently drawn real-valued priority for each key. Specifically, for each key $k$ we draw a priority $p_k$ independently from a continuous distribution on $\\mathbb{R}$, and the tree maintains both the binary search tree property on the keys and the min-heap property on the priorities (the parent’s priority is less than the child’s priority). The keys are the distinct integers $\\{1, 2, \\dots, n\\}$, and they are inserted in the interleaved order $1, n, 2, n-1, 3, n-2, \\dots$ until all $n$ keys have been inserted. Let $h_n$ denote the final height of the treap and let $C_n$ denote the total number of key comparisons performed over all $n$ insertions by the standard treap insertion algorithm (place the new node as a binary search tree leaf by key comparisons, then perform rotations to restore the heap property on priorities).\n\nWhich of the following statements best characterizes the asymptotic performance and structural distribution of the treap resulting from this insertion sequence?\n\nA. Regardless of this interleaved key order, the joint distribution of the final treap shape is identical to that of a binary search tree built by inserting the keys in a uniformly random permutation induced by the random priorities; consequently, $\\mathbb{E}[h_n] = \\Theta(\\log n)$ and $\\mathbb{E}[C_n] = \\Theta(n \\log n)$, and the insertion order does not change these expectations.\n\nB. Because the key order is nearly sorted, the treap degenerates: $\\mathbb{E}[h_n] = \\Theta(n)$ and $\\mathbb{E}[C_n] = \\Theta(n^2)$.\n\nC. The alternation between extremal keys increases path oscillation and forces extra adjustments: $\\mathbb{E}[h_n] = \\Theta(\\log n)$ but with a strictly larger constant than if the keys were inserted in a random order, and $\\mathbb{E}[C_n] = \\Theta(n \\log n)$ with a strictly larger leading constant for this interleaved order.\n\nD. The final treap shape is determined solely by the key insertion order and not by the priorities; in particular, after the given sequence, $h_n$ equals the height of the plain binary search tree that would be built by inserting keys in the order $1, n, 2, n-1, \\dots$, so $h_n$ is linear in $n$.", "solution": "The user wants a critical analysis of a problem concerning treaps, followed by a solution.\n\n### Step 1: Extract Givens\n- **Data Structure**: A treap, which is a binary tree.\n- **Properties**:\n    1.  Binary Search Tree (BST) property on keys. The keys are the distinct integers $\\{1, 2, \\dots, n\\}$.\n    2.  Min-heap property on priorities. The parent's priority is less than or equal to its children's priorities.\n- **Priorities**: For each key $k$, a priority $p_k$ is drawn independently from a continuous distribution on $\\mathbb{R}$. This ensures that all priorities are distinct with probability $1$.\n- **Insertion Order**: The keys are inserted in the specific interleaved sequence: $1, n, 2, n-1, 3, n-2, \\dots$.\n- **Insertion Algorithm**: The standard treap insertion algorithm is used. A new key-priority pair is first inserted into the tree as if it were a standard BST (following a search path based on key comparisons), placing it as a new leaf. Then, rotations are performed to move the new node upwards as long as its priority is less than its parent's priority, restoring the min-heap property.\n- **Metrics**:\n    -   $h_n$: The height of the final treap after all $n$ keys are inserted.\n    -   $C_n$: The total number of key comparisons performed over the course of all $n$ insertions.\n- **Question**: To find the statement that best characterizes the asymptotic performance ($\\mathbb{E}[h_n]$, $\\mathbb{E}[C_n]$) and structural distribution of the resulting treap.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is well-defined and grounded in the established theory of data structures and algorithms.\n- **Scientifically Grounded**: The definition of a treap, its properties (BST on keys, heap on priorities), and the standard insertion algorithm are all standard concepts in computer science. The analysis of expected height and cost is a central topic in randomized algorithms. The problem is scientifically and mathematically sound.\n- **Well-Posed**: The problem is clearly stated. It provides all necessary information to reason about the properties of the resulting data structure. The use of a continuous distribution for priorities is a standard assumption that guarantees uniqueness of priorities and simplifies analysis. The question asks for a characterization, which is a standard form of inquiry in asymptotic analysis.\n- **Objective**: The language is precise and free of subjective claims. All terms are standard in the field.\n\nThe problem does not exhibit any of the invalidity flaws. It is a valid, formalizable problem in the analysis of algorithms.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. I will proceed to derive the solution and evaluate the options.\n\n### Principle-Based Derivation\n\nThe analysis of the treap's properties hinges on a fundamental theorem regarding its structure.\n\n**1. Structure of the Final Treap**\nA treap is defined by two ordering properties: the BST property on keys and the heap property on priorities. For any given set of $n$ distinct key-priority pairs $\\{(k_1, p_1), (k_2, p_2), \\dots, (k_n, p_n)\\}$, the structure of the treap is uniquely determined.\n\nTo see this, consider the key-priority pair $(k_m, p_m)$ with the minimum priority among all $n$ pairs. Due to the min-heap property, this node must be the root of the tree, as no other node can have a smaller priority to be its parent. The BST property then dictates that all keys smaller than $k_m$ must reside in the left subtree, and all keys larger than $k_m$ must reside in the right subtree. The left subtree is, recursively, the unique treap formed by the key-priority pairs with keys less than $k_m$. Similarly, the right subtree is the unique treap on the remaining pairs. This recursive argument demonstrates that the final structure is uniquely determined by the set of key-priority pairs, and is **independent of the order of insertion**.\n\n**2. Equivalence to Randomized Binary Search Trees**\nThe process described above is equivalent to building a standard BST by inserting keys in an order determined by their priorities. Since the priorities $p_k$ are drawn independently from a continuous distribution, sorting the nodes by priority yields a uniformly random permutation of the keys $\\{1, 2, \\dots, n\\}$. Therefore, the distribution of the final treap's shape is identical to the distribution of the shape of a BST built by inserting the keys in a uniformly random order.\n\n**3. Analysis of Expected Height, $\\mathbb{E}[h_n]$**\nThe height $h_n$ is a property of the final tree structure. Since the distribution of the final structure is independent of the key insertion order, the distribution of $h_n$ and its expectation $\\mathbb{E}[h_n]$ are also independent of the key insertion order. It is a classic result in the analysis of algorithms that the expected height of a BST built from a random permutation of $n$ keys is $\\Theta(\\log n)$.\nTherefore, for any insertion order, including the interleaved one specified, $\\mathbb{E}[h_n] = \\Theta(\\log n)$.\n\n**4. Analysis of Total Comparison Cost, $\\mathbb{E}[C_n]$**\nThe total number of key comparisons, $C_n$, is the sum of the costs of each of the $n$ insertions. The cost of inserting the $i$-th key, let's call it $k_i$, into the treap $T_{i-1}$ (containing the first $i-1$ keys) is determined by the number of key comparisons needed to find the leaf position for $k_i$. Rotations to restore the heap property involve *priority* comparisons, not key comparisons.\nSo, $C_n = \\sum_{i=1}^n (\\text{number of key comparisons to insert } k_i)$. This cost is $1 + \\text{depth of insertion position in } T_{i-1}$.\n\nThe structure of the intermediate treap $T_{i-1}$ is itself random (due to the random priorities of its constituent keys) and is equivalent to a random BST on $i-1$ nodes. The expected search depth for any key in such a tree is $O(\\log(i-1))$. Therefore, the expected cost of the $i$-th insertion is $O(\\log i)$.\nBy linearity of expectation, the total expected cost is:\n$$ \\mathbb{E}[C_n] = \\sum_{i=1}^n \\mathbb{E}[\\text{cost of } i\\text{-th insertion}] = \\sum_{i=1}^n O(\\log i) = O(n \\log n) $$\nThis asymptotic bound holds regardless of the insertion order of the keys.\n\nHowever, the exact value of $\\mathbb{E}[C_n]$ (including the leading constant) *does* depend on the insertion order. This can be shown by analyzing the probability that any two keys are compared during the construction. This probability depends on the set of keys already present when one of the keys is inserted, which is determined by the insertion order. A simple calculation for $n=3$ shows that the insertion order $(1, 2, 3)$ gives $\\mathbb{E}[C_3]=2.5$, whereas the order $(1, 3, 2)$ (which matches the problem's interleaved pattern) gives $\\mathbb{E}[C_3]=3$. Thus, the exact expectation changes.\n\n### Option-by-Option Analysis\n\n**A. Regardless of this interleaved key order, the joint distribution of the final treap shape is identical to that of a binary search tree built by inserting the keys in a uniformly random permutation induced by the random priorities; consequently, $\\mathbb{E}[h_n] = \\Theta(\\log n)$ and $\\mathbb{E}[C_n] = \\Theta(n \\log n)$, and the insertion order does not change these expectations.**\n\n-   The first clause about the distribution of the final treap shape being identical to a random BST is correct. This is the fundamental property of treaps.\n-   The consequence that $\\mathbb{E}[h_n] = \\Theta(\\log n)$ is correct, as it flows directly from the first clause.\n-   The consequence that $\\mathbb{E}[C_n] = \\Theta(n \\log n)$ is also correct, as the expected cost of each insertion into a randomized structure of size $i$ is $O(\\log i)$.\n-   The final clause, \"and the insertion order does not change these expectations\", is partially incorrect. The expectation $\\mathbb{E}[h_n]$ is indeed unchanged. However, as demonstrated, the expectation $\\mathbb{E}[C_n]$ *is* dependent on the insertion order. So, this statement is a slight oversimplification.\n-   However, the question asks for the statement that *best characterizes* the performance. This option correctly identifies the core principle: randomization from priorities makes the treap's structure and performance robust against specific key insertion orders, guaranteeing logarithmic height and $n \\log n$ construction cost asymptotically. The other options contain more fundamental errors.\n\n**Verdict**: **Correct**. Despite the minor inaccuracy in the final clause regarding $\\mathbb{E}[C_n]$, this statement provides the best and most accurate high-level characterization of treap behavior among the choices. The core message is that the treap is efficient regardless of the insertion order, which is true.\n\n**B. Because the key order is nearly sorted, the treap degenerates: $\\mathbb{E}[h_n] = \\Theta(n)$ and $\\mathbb{E}[C_n] = \\Theta(n^2)$.**\n\n-   This statement incorrectly assumes the treap behaves like a standard BST. While a sorted or nearly-sorted insertion order can cause a standard BST to degenerate into a linear-height structure, the random priorities in a treap prevent this. The structure is randomized, leading to an expected height of $\\Theta(\\log n)$. This statement fundamentally misunderstands the role of priorities in a treap.\n\n**Verdict**: **Incorrect**.\n\n**C. The alternation between extremal keys increases path oscillation and forces extra adjustments: $\\mathbb{E}[h_n] = \\Theta(\\log n)$ but with a strictly larger constant than if the keys were inserted in a random order, and $\\mathbb{E}[C_n] = \\Theta(n \\log n)$ with a strictly larger leading constant for this interleaved order.**\n\n-   This statement correctly identifies the asymptotic bounds for height and cost.\n-   However, it incorrectly claims that the constant for $\\mathbb{E}[h_n]$ is strictly larger. As established, the distribution of the final height $h_n$ and its expectation are independent of the insertion order. Therefore, the expected height is exactly the same for any insertion order. The claim that the constant is larger is false.\n-   The claim that the leading constant for $\\mathbb{E}[C_n]$ is strictly larger is plausible and likely true, as the interleaved order tends to increase the number of comparisons. However, because the first part of the conjunction is false, the entire statement is incorrect.\n\n**Verdict**: **Incorrect**.\n\n**D. The final treap shape is determined solely by the key insertion order and not by the priorities; in particular, after the given sequence, $h_n$ equals the height of the plain binary search tree that would be built by inserting keys in the order $1, n, 2, n-1, \\dots$, so $h_n$ is linear in $n$.**\n\n-   The premise that the shape is determined by insertion order and not priorities is diametrically opposed to the definition and properties of a treap. The priorities are essential in determining the structure.\n-   While it is true that a plain BST built with the interleaved order `1, n, 2, n-1, ...` would degenerate to a height of $\\Theta(n)$, this is not the structure of the treap.\n\n**Verdict**: **Incorrect**.", "answer": "$$\\boxed{A}$$", "id": "3280465"}, {"introduction": "Having established that a treap's structure is governed by probability, we can now make precise, quantitative predictions about its shape. This practice asks you to calculate the exact probability of a specific structural configuration: the nodes with the smallest and largest keys being direct siblings [@problem_id:3280387]. Successfully deriving this result from first principles requires you to skillfully combine the treap's deterministic BST property with its probabilistic heap property, offering a deep dive into the mathematical underpinnings of randomized data structures.", "problem": "Consider a treap built over a totally ordered set of $n$ distinct keys, labeled by their sorted order as $1,2,\\dots,n$, with $n \\ge 3$. Each key $i$ is assigned an independent priority $P_i$ drawn from a continuous distribution, and the treap is the unique binary tree that is simultaneously a Binary Search Tree (BST) on the keys and a heap (min-heap) on the priorities. In other words, the root holds the key whose priority is the minimum among all $n$ priorities, and recursively the left and right subtrees are treaps over the keys to the left and right of the root in the key order.\n\nTwo nodes are called direct siblings if they share the same parent. Using only the foundational definitions of treaps (independent and identically distributed continuous priorities, BST order on keys, and heap order on priorities) and basic probability, derive from first principles the exact probability, as a function of $n$, that the nodes with the smallest and the largest keys (that is, keys $1$ and $n$) are direct siblings in the treap.\n\nExpress your final answer as a closed-form analytic expression in terms of $n$ using standard mathematical functions and, if needed, harmonic numbers. No numerical approximation or rounding is required.", "solution": "The problem asks for the probability that the nodes with the smallest key, $1$, and the largest key, $n$, are direct siblings in a treap of $n$ keys, where $n \\ge 3$.\n\nLet the set of keys be $K = \\{1, 2, \\dots, n\\}$. Each key $i \\in K$ is associated with a priority $P_i$. The priorities are independent and identically distributed (i.i.d.) random variables drawn from a continuous distribution. The treap structure is a binary tree that is a Binary Search Tree (BST) on the keys and a min-heap on the priorities.\n\nFor two nodes to be direct siblings, they must share the same parent node. Let the key of the parent of nodes $1$ and $n$ be $k$.\nAccording to the BST property, all keys in the left subtree of a node $k$ must be smaller than $k$, and all keys in the right subtree must be larger than $k$. For $k$ to be a parent of both $1$ and $n$, node $1$ must be a descendant of $k$'s left child and node $n$ must be a descendant of $k$'s right child. This implies that the key $k$ must satisfy $1  k  n$. Therefore, the possible keys for the parent node are $k \\in \\{2, 3, \\dots, n-1\\}$.\n\nThe event that nodes $1$ and $n$ are siblings can be expressed as the disjoint union of events $E_k$ for $k \\in \\{2, 3, \\dots, n-1\\}$, where $E_k$ is the event that node $k$ is the parent of both node $1$ and node $n$. The total probability is then $P(\\text{siblings}) = \\sum_{k=2}^{n-1} P(E_k)$.\n\nLet's establish the conditions for the event $E_k$ to occur.\nFor node $k$ to be the parent of nodes $1$ and $n$, it must be their lowest common ancestor (LCA).\nA fundamental property of a treap is that the LCA of any two nodes with keys $i$ and $j$ (assuming $i  j$) is the node with key $x$ such that $i \\le x \\le j$ and $P_x$ is the minimum among all priorities $\\{P_y \\mid i \\le y \\le j\\}$.\nFor nodes $1$ and $n$, their LCA must be the node with key $k \\in \\{1, 2, \\dots, n\\}$ that has the minimum priority among all priorities $\\{P_1, P_2, \\dots, P_n\\}$. This means that the LCA of nodes $1$ and $n$ is the root of the entire treap.\n\nSo, for nodes $1$ and $n$ to be siblings, their parent must be the root of the treap. Let the key of this root node be $k$.\nThe event $E_k$ that $k$ is the parent of $1$ and $n$ requires three conditions to be met simultaneously:\n1.  Node $k$ must be the root of the entire treap. This means its priority, $P_k$, must be the minimum of all priorities in the treap: $P_k = \\min\\{P_1, P_2, \\dots, P_n\\}$.\n\n2.  Node $1$ must be the direct left child of $k$. The left child of the root $k$ is the root of the sub-treap constructed from the set of keys $\\{1, 2, \\dots, k-1\\}$. For node $1$ to be the root of this sub-treap, its priority, $P_1$, must be the minimum among the priorities of this set: $P_1 = \\min\\{P_1, P_2, \\dots, P_{k-1}\\}$.\n\n3.  Node $n$ must be the direct right child of $k$. The right child of the root $k$ is the root of the sub-treap constructed from the set of keys $\\{k+1, k+2, \\dots, n\\}$. For node $n$ to be the root of this sub-treap, its priority, $P_n$, must be the minimum among the priorities of this set: $P_n = \\min\\{P_{k+1}, P_{k+2}, \\dots, P_n\\}$.\n\nWe can now calculate the probability of the event $E_k$ for a fixed $k \\in \\{2, 3, \\dots, n-1\\}$. Since the priorities are i.i.d. from a continuous distribution, for any finite set of priorities, each one has an equal chance of being the minimum.\n\nLet $A$ be the event for condition 1, $B$ for condition 2, and $C$ for condition 3. We need to find $P(E_k) = P(A \\cap B \\cap C)$. We use the chain rule of probability: $P(A \\cap B \\cap C) = P(A) P(B|A) P(C|A \\cap B)$.\n\n-   $P(A)$: The probability that $P_k$ is the minimum among $n$ i.i.d. random variables is $P(A) = \\frac{1}{n}$.\n\n-   $P(B|A)$: Given that $P_k$ is the overall minimum, we need the probability that $P_1$ is the minimum among the set $\\{P_1, P_2, \\dots, P_{k-1}\\}$. The condition $A$ ($P_k$ is the minimum of all $n$ priorities) does not provide any information about the relative ordering of priorities within the set $\\{P_1, \\dots, P_{k-1}\\}$. Any of these $k-1$ priorities is still equally likely to be the minimum of this set. Thus, $P(B|A) = \\frac{1}{k-1}$. This is valid for $k \\ge 2$.\n\n-   $P(C|A \\cap B)$: Given events $A$ and $B$, we need the probability that $P_n$ is the minimum among the set $\\{P_{k+1}, \\dots, P_n\\}$. The events $A$ and $B$ involve the priorities of keys in the set $\\{1, 2, \\dots, k\\}$. The event $C$ involves priorities of keys in the set $\\{k+1, \\dots, n\\}$. Since these two sets of keys are disjoint and all priorities are independent, the conditions on the first set of priorities do not influence the probabilities concerning the second set. Therefore, $P(C|A \\cap B) = P(C) = \\frac{1}{n-k}$. This is valid for $k \\le n-1$.\n\nCombining these probabilities, we get the probability of event $E_k$:\n$$P(E_k) = P(A) P(B|A) P(C|A \\cap B) = \\frac{1}{n} \\cdot \\frac{1}{k-1} \\cdot \\frac{1}{n-k} = \\frac{1}{n(k-1)(n-k)}$$\nThis holds for any $k \\in \\{2, 3, \\dots, n-1\\}$.\n\nTo find the total probability that nodes $1$ and $n$ are siblings, we sum $P(E_k)$ over all possible parent keys $k$:\n$$P(\\text{siblings}) = \\sum_{k=2}^{n-1} P(E_k) = \\sum_{k=2}^{n-1} \\frac{1}{n(k-1)(n-k)} = \\frac{1}{n} \\sum_{k=2}^{n-1} \\frac{1}{(k-1)(n-k)}$$\nWe can evaluate the sum using partial fraction decomposition on the term $\\frac{1}{(k-1)(n-k)}$.\n$$\\frac{1}{(k-1)(n-k)} = \\frac{A}{k-1} + \\frac{B}{n-k}$$\nMultiplying by the denominator gives $1 = A(n-k) + B(k-1)$.\nSetting $k=1$, we get $1 = A(n-1)$, so $A = \\frac{1}{n-1}$.\nSetting $k=n$, we get $1 = B(n-1)$, so $B = \\frac{1}{n-1}$.\nThus, the decomposition is:\n$$\\frac{1}{(k-1)(n-k)} = \\frac{1}{n-1} \\left( \\frac{1}{k-1} + \\frac{1}{n-k} \\right)$$\nSubstituting this back into the summation:\n$$P(\\text{siblings}) = \\frac{1}{n} \\cdot \\frac{1}{n-1} \\sum_{k=2}^{n-1} \\left( \\frac{1}{k-1} + \\frac{1}{n-k} \\right)$$\nThe summation can be split into two parts:\n$$\\sum_{k=2}^{n-1} \\frac{1}{k-1} = \\frac{1}{1} + \\frac{1}{2} + \\dots + \\frac{1}{n-2} = H_{n-2}$$\nwhere $H_m = \\sum_{i=1}^m \\frac{1}{i}$ is the $m$-th harmonic number.\nFor the second part of the sum, let $j = n-k$. As $k$ goes from $2$ to $n-1$, $j$ goes from $n-2$ down to $1$.\n$$\\sum_{k=2}^{n-1} \\frac{1}{n-k} = \\sum_{j=1}^{n-2} \\frac{1}{j} = \\frac{1}{1} + \\frac{1}{2} + \\dots + \\frac{1}{n-2} = H_{n-2}$$\nThe total sum is therefore $H_{n-2} + H_{n-2} = 2H_{n-2}$.\nFinally, the probability is:\n$$P(\\text{siblings}) = \\frac{1}{n(n-1)} (2H_{n-2}) = \\frac{2H_{n-2}}{n(n-1)}$$\nThe condition $n \\ge 3$ ensures that $n-2 \\ge 1$, so $H_{n-2}$ is well-defined and positive.", "answer": "$$\\boxed{\\frac{2H_{n-2}}{n(n-1)}}$$", "id": "3280387"}, {"introduction": "Theory is essential, but mastery comes from implementation. This final practice moves from analysis to construction, tasking you with implementing one of the treap's most intricate core operations: non-recursive deletion [@problem_id:3280508]. By using rotations to \"bubble down\" a target node until it becomes a leaf and a stack to manage the traversal path, you will gain a profound, low-level command of the dynamic algorithms that maintain a treap's invariants.", "problem": "A treap is a data structure that combines the Binary Search Tree (BST) property and the heap property. In a treap, each node stores a key and an independent priority. The BST property requires that for any node with key $k$, all keys in its left subtree are strictly less than $k$ and all keys in its right subtree are strictly greater than $k$. The heap property (min-heap in this problem) requires that for any node with priority $p$, the priorities of its children are strictly greater than $p$. A treap can be viewed as the unique tree that simultaneously satisfies these two properties for a given set of key-priority pairs.\n\nFundamental definitions and facts for this problem are:\n- The Binary Search Tree (BST) property: for each node with key $k$, for all keys $x$ in the left subtree, $x  k$, and for all keys $y$ in the right subtree, $y  k$.\n- The heap property (min-heap on priorities): for each node with priority $p$, for any child priority $p_c$, $p \\le p_c$.\n- A tree rotation is a local transformation that preserves the BST property while modifying parent-child relationships. Rotations are the fundamental operation used to restore the heap property after structural changes.\n\nYour task is to derive, implement, and validate a non-recursive delete operation in a treap. The delete must use a stack to manage the path from the root to the target node. The design must be grounded in the fundamental properties above and must avoid recursion for the delete operation. The high-level steps you must implement are:\n- Search for the node with key $k$ using BST-guided traversal, recording the path in a stack.\n- If the node is found, repeatedly \"bubble it down\" via rotations so that the node to delete eventually has at most one child. At each step, select the child with the smaller priority to rotate with so that the heap property remains valid. Use the stack to keep and update ancestral links deterministically and non-recursively.\n- Remove the node by reconnecting its parent to its single child (or to the empty child if it is a leaf).\n- Verify that the resulting tree retains the BST and heap properties.\n\nIn addition to delete, you may implement insertion by any method. However, deletion must be non-recursive and must explicitly use a stack to manage the path.\n\nVerification requirements:\n- Implement a function that checks the BST property by performing an in-order traversal and confirming the sequence is strictly increasing.\n- Implement a function that checks the heap property (min-heap on priorities) by confirming for each node that its priority is less than or equal to its children's priorities.\n- Implement a function that returns the in-order sequence of keys.\n\nComplexity requirements:\n- For a treap built from $n$ nodes with independent priorities, the expected height is $O(\\log n)$, and the delete operation must run in $O(h)$ time where $h$ is the height of the treap.\n\nTest suite:\nFor determinism, you will be given explicit key-priority pairs rather than randomized priorities. For each test case, build the treap by inserting the given pairs, then perform one delete operation with the specified key. For each test case, your program must output a list containing:\n- A boolean indicating whether a node with the given key was found and deleted.\n- A boolean indicating whether the resulting structure satisfies the BST property.\n- A boolean indicating whether the resulting structure satisfies the heap property.\n- The in-order traversal list of keys after deletion.\n\nUse the following test cases:\n- Test case $1$: pairs $\\{(5,10),(3,20),(8,30)\\}$, delete key $3$.\n- Test case $2$: pairs $\\{(5,10),(3,20),(4,15)\\}$, delete key $4$.\n- Test case $3$: pairs $\\{(5,10),(3,20),(7,15),(6,25)\\}$, delete key $5$.\n- Test case $4$: pairs $\\{(5,10),(3,20),(7,15)\\}$, delete key $42$.\n- Test case $5$: pairs $\\{\\}$, delete key $1$.\n- Test case $6$: pairs $\\{(50,5),(20,15),(70,10),(10,25),(30,40),(60,35),(80,20),(25,30),(35,45)\\}$, delete key $50$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case result and is itself a list of four elements as specified above. For example: \"[$[r_1], [r_2], \\dots$]\" where each $[r_i]$ has the structure $[\\text{deleted}, \\text{bst\\_ok}, \\text{heap\\_ok}, \\text{inorder}]$. No units are involved in this problem.", "solution": "A treap is a randomized binary search tree that balances itself with high probability. Its name is a portmanteau of \"tree\" and \"heap\". Each node in a treap holds a key, which satisfies the binary search tree (BST) property, and a randomly assigned priority, which satisfies the heap property. This dual-structure ensures that for any given set of key-priority pairs, the shape of the treap is unique.\n\n**Fundamental Properties:**\n1.  **Binary Search Tree (BST) Property:** For any node with key $k$, all keys in its left subtree are strictly less than $k$, and all keys in its right subtree are strictly greater than $k$. This property allows for efficient searching, insertion, and deletion, similar to a standard BST.\n2.  **Min-Heap Property:** For any node with priority $p$, the priorities of its children, $p_c$, must be greater than or equal to $p$ (i.e., $p \\le p_c$). This means the node with the minimum priority in any subtree is always the root of that subtree. Consequently, the node with the overall minimum priority in the treap is the root of the entire tree.\n\n**Deletion by Rotation:**\nTo delete a node with key $k$, we first locate it using the BST property. A naive removal analogous to BST deletion can disrupt the heap property. The canonical method for deletion in a treap involves a series of rotations to \"bubble down\" the target node until it becomes a leaf or a node with a single child. At this point, it can be spliced out of the tree without complex restructuring. This process is conceptually equivalent to setting the priority of the target node to infinity and letting it sink down the tree.\n\nThe core of the operation lies in choosing the correct rotations. If the node to be deleted has two children, we compare their priorities. We rotate the node with the child that has the smaller priority. For example, if the left child has a smaller priority, we perform a right rotation on the target node. This brings the left child up, becoming the new parent, while the target node moves down. This specific choice of rotation is crucial because it preserves the heap property among the involved nodes (the new parent has a smaller priority than its new child, the target node). Since rotations are designed to preserve the BST property, the tree remains a valid BST throughout the process.\n\n**Non-Recursive Implementation with a Stack:**\nThe problem mandates a non-recursive implementation of the delete operation, explicitly using a stack. The stack is instrumental for managing the path from the root to the node being manipulated.\n\n**Step-by-Step Algorithm:**\n1.  **Search and Path Tracking:** We traverse the tree from the root to find the node with the target key $k$. During this traversal, we use a stack to store the path taken. Each element on the stack represents a parent and the direction of the traversal (e.g., as a tuple `(parent_node, is_left_child)`). This path information is essential for updating parent-child links after rotations.\n\n2.  **Iterative \"Bubble-Down\":** If the target node is found and has two children, we enter a loop. In each iteration:\n    a. We compare the priorities of the left and right children.\n    b. If the left child's priority is less than the right's, we perform a right rotation on the target node. Otherwise, we perform a left rotation.\n    c. After the rotation, the target node has moved one level down. Its original parent must now point to the new root of the rotated subtree. We use the information from our path stack to find this parent and update its `left` or `right` child pointer.\n    d. The stack is then updated to reflect the new parent-child relationship for the target node, preparing for the next iteration if the node still has two children.\n\n3.  **Final Node Removal:** The loop terminates when the target node has at most one child. At this point, it can be removed by making its parent point directly to its single child (or to `None` if it is a leaf). The path stack provides the final parent needed for this pointer manipulation.\n\n**Verification:**\nTo ensure the correctness of the implementation, two verification functions are implemented:\n- `check_bst()`: This function performs an in-order traversal of the treap. If the treap is a valid BST, the resulting sequence of keys must be strictly increasing.\n- `check_heap()`: This function performs a traversal (e.g., BFS or DFS) of the treap. For each node, it verifies that its priority is less than or equal to the priorities of its children, as per the min-heap property.\n\nThis principled, step-by-step approach ensures that the non-recursive delete operation correctly maintains both the BST and heap invariants, and its correctness can be rigorously verified. The time complexity is proportional to the height of the tree, which for a treap is expected to be $O(\\log n)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\nclass Node:\n    \"\"\"A class to represent a node in the treap.\"\"\"\n    def __init__(self, key, priority):\n        self.key = int(key)\n        self.priority = int(priority)\n        self.left = None\n        self.right = None\n\nclass Treap:\n    \"\"\"A class to represent a treap data structure.\"\"\"\n    def __init__(self):\n        self.root = None\n\n    def _rotate_left(self, y):\n        \"\"\"Performs a left rotation on the subtree rooted at y.\"\"\"\n        x = y.right\n        T2 = x.left\n        x.left = y\n        y.right = T2\n        return x\n\n    def _rotate_right(self, y):\n        \"\"\"Performs a right rotation on the subtree rooted at y.\"\"\"\n        x = y.left\n        T2 = x.right\n        x.right = y\n        y.left = T2\n        return x\n\n    def _insert_recursive(self, node, key, priority):\n        \"\"\"Recursive helper for insertion, maintaining treap properties.\"\"\"\n        if not node:\n            return Node(key, priority)\n\n        if key  node.key:\n            node.left = self._insert_recursive(node.left, key, priority)\n            # If heap property is violated, rotate right\n            if node.left.priority  node.priority:\n                node = self._rotate_right(node)\n        elif key > node.key:\n            node.right = self._insert_recursive(node.right, key, priority)\n            # If heap property is violated, rotate left\n            if node.right.priority  node.priority:\n                node = self._rotate_left(node)\n        \n        return node\n\n    def insert(self, key, priority):\n        \"\"\"Public method for insertion.\"\"\"\n        self.root = self._insert_recursive(self.root, key, priority)\n\n    def delete(self, key):\n        \"\"\"\n        Non-recursive deletion using a stack to manage the path.\n        \"\"\"\n        # Step 1: Find the node and store the path to it.\n        # The stack stores tuples of (parent_node, is_left_child_bool).\n        path_stack = []\n        node = self.root\n        \n        while node and node.key != key:\n            parent = node\n            if key  node.key:\n                path_stack.append((parent, True))\n                node = node.left\n            else:\n                path_stack.append((parent, False))\n                node = node.right\n        \n        if not node:\n            return False  # Key not found\n\n        # Step 2: \"Bubble down\" the node using rotations until it has at most one child.\n        while node.left and node.right:\n            # Decide rotation based on child priorities.\n            if node.left.priority  node.right.priority:\n                new_sub_root = self._rotate_right(node)\n            else:\n                new_sub_root = self._rotate_left(node)\n\n            # Update the parent of the rotated subtree.\n            if not path_stack:\n                self.root = new_sub_root\n            else:\n                parent, is_left = path_stack[-1]\n                if is_left:\n                    parent.left = new_sub_root\n                else:\n                    parent.right = new_sub_root\n            \n            # The node to delete has moved down. Update path_stack for the next iteration.\n            # a new parent-child relation is established for the node we are deleting.\n            path_stack.append((new_sub_root, node is new_sub_root.left))\n\n        # Step 3: Remove the node, which now has at most one child.\n        child = node.left if node.left else node.right\n        \n        if not path_stack:\n            self.root = child\n        else:\n            parent, is_left = path_stack[-1]\n            if is_left:\n                parent.left = child\n            else:\n                parent.right = child\n        \n        return True\n\n    def get_in_order_keys(self):\n        \"\"\"Returns a list of keys from an in-order traversal.\"\"\"\n        if not self.root:\n            return []\n        \n        result = []\n        stack = []\n        current = self.root\n        while current or stack:\n            while current:\n                stack.append(current)\n                current = current.left\n            current = stack.pop()\n            result.append(current.key)\n            current = current.right\n        return result\n\n    def check_bst(self):\n        \"\"\"Checks if the tree satisfies the BST property (strictly increasing keys in-order).\"\"\"\n        keys = self.get_in_order_keys()\n        for i in range(1, len(keys)):\n            if keys[i] = keys[i-1]:\n                return False\n        return True\n\n    def check_heap(self):\n        \"\"\"Checks if the tree satisfies the min-heap property on priorities.\"\"\"\n        if not self.root:\n            return True\n        \n        q = deque([self.root])\n        while q:\n            node = q.popleft()\n            if node.left:\n                if node.priority > node.left.priority:\n                    return False\n                q.append(node.left)\n            if node.right:\n                if node.priority > node.right.priority:\n                    return False\n                q.append(node.right)\n        return True\n\ndef solve():\n    test_cases = [\n        ({'pairs': {(5,10),(3,20),(8,30)}, 'delete_key': 3}),\n        ({'pairs': {(5,10),(3,20),(4,15)}, 'delete_key': 4}),\n        ({'pairs': {(5,10),(3,20),(7,15),(6,25)}, 'delete_key': 5}),\n        ({'pairs': {(5,10),(3,20),(7,15)}, 'delete_key': 42}),\n        ({'pairs': set(), 'delete_key': 1}),\n        ({'pairs': {(50,5),(20,15),(70,10),(10,25),(30,40),(60,35),(80,20),(25,30),(35,45)}, 'delete_key': 50}),\n    ]\n\n    results = []\n    for case in test_cases:\n        treap = Treap()\n        for key, priority in case['pairs']:\n            treap.insert(key, priority)\n        \n        deleted = treap.delete(case['delete_key'])\n        bst_ok = treap.check_bst()\n        heap_ok = treap.check_heap()\n        inorder = treap.get_in_order_keys()\n        \n        results.append([deleted, bst_ok, heap_ok, inorder])\n\n    # Final print statement in the exact required format.\n    # Using str() and replace() to ensure no spaces in the list representation\n    # e.g., [1,2] instead of [1, 2]\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3280508"}]}