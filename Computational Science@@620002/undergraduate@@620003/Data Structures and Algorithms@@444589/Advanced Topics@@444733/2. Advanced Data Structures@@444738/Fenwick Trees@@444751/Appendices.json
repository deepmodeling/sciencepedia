{"hands_on_practices": [{"introduction": "Most textbook examples of Fenwick trees use 1-based indexing to simplify the bitwise logic. However, in practical programming, 0-based arrays are the norm. This first exercise challenges you to bridge this gap by deriving the traversal rules for a 0-based Fenwick tree from first principles, building a deep, fundamental understanding of its structure. [@problem_id:3234121]", "problem": "You are tasked with designing and implementing a Binary Indexed Tree (Fenwick Tree), defined formally as a data structure that maintains an array of real numbers and supports point updates and prefix sum queries in logarithmic time. The implementation must use $0$-based indexing throughout. You must derive and justify the bitwise parent/child traversal logic required for $0$-based indexing starting from foundational principles rather than from any pre-memorized formula.\n\nBegin from the following base definitions:\n- Let $A$ be an array of length $n$, with indices $i \\in \\{0,1,\\dots,n-1\\}$.\n- The prefix sum function is defined as $P(i) = \\sum_{k=0}^{i} A[k]$ for $i \\ge 0$, and $P(-1) = 0$ by convention.\n- The Fenwick Tree stores partial sums over ranges of lengths that are powers of two, aligned by index boundaries, enabling $O(\\log n)$ updates and queries by moving between nodes determined by bit-level properties of indices.\n- The Least Significant Bit (LSb) of an integer $x$ in two's complement representation is the value of the lowest power of two present in $x$, that is $2^{j}$ where $j$ is the smallest index such that the $j$-th bit of $x$ is $1$.\n\nYour implementation must provide the following operations on a Fenwick Tree with $0$-based indexing:\n- A constructor that initializes an internal tree of length $n$.\n- A method that builds the structure from an initial array by a sequence of point updates.\n- A method that applies a point update at index $i$ by adding a value $\\Delta$ to $A[i]$.\n- A method that returns the prefix sum $P(i)$.\n- A method that returns the range sum $\\sum_{k=\\ell}^{r} A[k]$ for $0 \\le \\ell \\le r \\le n-1$.\n\nYou must implement the $0$-based traversal rules for both upward movement during updates and downward movement during prefix sum accumulation, derived from the bit properties of the indices and the definitions above. Explicitly justify, in your solution, how the $0$-based traversals differ from the traditional $1$-based Fenwick Tree traversals and why the bitwise operations you use are correct for $0$-based indexing.\n\nDesign and run your program on the following test suite. For every test case, perform the operations in the exact order given and record the outputs of the query operations. Queries are the prefix sums and range sums specified; point updates do not directly yield outputs.\n\nTest Case $1$ (general case, mixed signs):\n- Initial array $A = [3,-1,4,1,5,-9,2,6]$ with $n=8$.\n- Query $P(3)$.\n- Query $\\sum_{k=2}^{5} A[k]$.\n- Update $A[5] \\leftarrow A[5] + 9$.\n- Query $P(5)$.\n- Query $\\sum_{k=0}^{7} A[k]$.\n\nTest Case $2$ (boundary length $1$):\n- Initial array $A = [7]$ with $n=1$.\n- Query $P(0)$.\n- Update $A[0] \\leftarrow A[0] - 3$.\n- Query $\\sum_{k=0}^{0} A[k]$.\n- Update $A[0] \\leftarrow A[0] + 10$.\n- Query $P(0)$.\n\nTest Case $3$ (all zeros with edge indices):\n- Initial array $A = [0,0,0,0,0,0,0,0,0,0]$ with $n=10$.\n- Update $A[0] \\leftarrow A[0] + 5$.\n- Update $A[9] \\leftarrow A[9] - 2$.\n- Query $P(0)$.\n- Query $P(9)$.\n- Query $\\sum_{k=1}^{8} A[k]$.\n\nTest Case $4$ (off-by-one checks and range queries):\n- Initial array $A = [1,2,3,4,5]$ with $n=5$.\n- Query $\\sum_{k=2}^{2} A[k]$.\n- Query $\\sum_{k=0}^{4} A[k]$.\n- Update $A[2] \\leftarrow A[2] - 3$.\n- Query $P(2)$.\n- Query $\\sum_{k=3}^{4} A[k]$.\n\nYour program should produce a single line of output containing the results of all queries from Test Case $1$, then Test Case $2$, then Test Case $3$, then Test Case $4$, concatenated in order, as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,\\dots]$). All outputs must be integers. There are no physical units or angles involved in this problem. The expected time complexity per update and per query is $O(\\log n)$, and the extra space usage is $O(n)$ for the internal tree array.", "solution": "The problem requires the design and implementation of a Binary Indexed Tree, or Fenwick Tree, that operates on a $0$-based array. A critical part of the task is to derive the traversal logic for point updates and prefix sum queries from foundational principles, rather than citing established formulas without justification.\n\nA Fenwick Tree is a data structure that enables efficient calculation of prefix sums and updates of individual element values in an array. Its efficiency, with a time complexity of $O(\\log n)$ for both operations, is achieved by storing partial sums in an auxiliary array, conventionally named `tree`. Each element `tree[i]` represents the sum of a specific range of elements from the original array $A$. The core of the data structure's design lies in the specific mapping between an index $i$ and the range for which `tree[i]` is responsible.\n\nLet the original array be $A$ of length $n$, with indices $i \\in \\{0, 1, \\dots, n-1\\}$. The prefix sum is $P(i) = \\sum_{k=0}^{i} A[k]$.\n\n### Derivation of the $0$-Based Fenwick Tree Structure\n\nThe conventional Fenwick Tree is formulated for $1$-based indexing. The adaptation to $0$-based indexing requires a re-evaluation of the underlying index partitioning. A direct translation by mapping index $k$ to $k+1$ is possible, but a more fundamental approach is to define a new partitioning scheme that is inherently suited for $0$-based indices.\n\nLet our Fenwick tree be an array `tree` of length $n$. We must define the responsibility of each element `tree[i]`. Let `tree[i]` store the sum of elements of $A$ over a specific range ending at index $i$:\n$$ \\text{tree}[i] = \\sum_{k=g(i)}^{i} A[k] $$\nThe function $g(i)$ defines the start of the range. For logarithmic performance, the ranges must have lengths that are powers of two and be structured such that any prefix sum can be represented as a sum over a small number of these ranges.\n\nA robust choice for $g(i)$ in a $0$-based system is $g(i) = (i \\ \\& \\ (i+1))$, where `&` is the bitwise AND operator. Let's analyze this definition.\nIf the binary representation of $i$ ends with a block of $k > 0$ ones, i.e., $i = \\dots 01\\dots1_2$ ($k$ ones), then $i+1 = \\dots 10\\dots0_2$ ($k$ zeros). In this case, $i \\ \\& \\ (i+1) = \\dots 00\\dots0_2$. More formally, if the least significant bit of $i+1$ is $2^k$, then $i$ has the form $m \\cdot 2^{k+1} + (2^k - 1)$ for some integer $m$, and $i+1$ has the form $m \\cdot 2^{k+1} + 2^k$. Then $i \\ \\& \\ (i+1)$ is not straightforward.\n\nLet's use an alternative viewpoint. The range for `tree[i]` should start after the range of its \"parent\" in the query path. This suggests defining the parent first.\nThe prefix sum $P(i)$ can be computed as a sum of a few `tree` entries.\n$P(i) = \\text{tree}[i] + P(g(i)-1)$. This recursive definition forms the basis of the query operation. The sequence of indices $i, g(i)-1, g(g(i)-1)-1, \\dots$ constitutes the query path.\n\nLet's define the traversal rule for queries (downward movement):\nThe next index in the prefix sum decomposition of $P(i)$ is $p(i) = (i \\ \\& \\ (i+1)) - 1$.\nLet's verify this.\n- If $i=6$ ($110_2$): $p(6) = (6 \\ \\& \\ 7) - 1 = (110_2 \\ \\& \\ 111_2) - 1 = 6 - 1 = 5$.\n- If $i=5$ ($101_2$): $p(5) = (5 \\ \\& \\ 6) - 1 = (101_2 \\ \\& \\ 110_2) - 1 = 4 - 1 = 3$.\n- If $i=3$ ($011_2$): $p(3) = (3 \\ \\& \\ 4) - 1 = (011_2 \\ \\& \\ 100_2) - 1 = 0 - 1 = -1$.\nThe sequence for querying $P(6)$ is $6 \\rightarrow 5 \\rightarrow 3 \\rightarrow -1$. This implies $P(6) = \\text{tree}[6] + \\text{tree}[5] + \\text{tree}[3]$.\n\nThis decomposition implies the following range responsibilities for `tree[i]`:\n- $\\text{tree}[3] = \\sum_{k=p(3)+1}^{3} A[k] = \\sum_{k=0}^{3} A[k]$\n- $\\text{tree}[5] = \\sum_{k=p(5)+1}^{5} A[k] = \\sum_{k=4}^{5} A[k]$\n- $\\text{tree}[6] = \\sum_{k=p(6)+1}^{6} A[k] = \\sum_{k=6}^{6} A[k]$\nSumming these indeed gives $\\sum_{k=0}^{6} A[k] = P(6)$.\nThe starting index of the range for `tree[i]` is $p(i)+1 = (i \\ \\& \\ (i+1))$. Thus, we arrive at our definition:\n$$ \\text{tree}[i] = \\sum_{k=(i \\ \\& \\ (i+1))}^{i} A[k] $$\nThis definition is self-consistent and works for all $i \\geq 0$, including $i=0$ where the range is $[(0 \\ \\& \\ 1), 0] = [0,0]$.\n\nWith this structure, we can formalize the operations.\n\n### Operations on the $0$-Based Fenwick Tree\n\n**1. Prefix Sum Query: `prefix_sum(i)`**\nTo compute $P(i) = \\sum_{k=0}^{i} A[k]$, we sum `tree` values along the downward path.\n$$ P(i) = \\sum_{j=i, \\ p(j), \\ p(p(j)), \\dots \\geq 0} \\text{tree}[j] $$\nThe iterative algorithm is:\n- Initialize `sum = 0`.\n- Start with index `j = i`.\n- While `j >= 0`:\n    - Add `tree[j]` to `sum`.\n    - Update `j` to its parent: $j \\leftarrow (j \\ \\& \\ (j+1)) - 1$.\n- Return `sum`.\n\n**2. Point Update: `update(i, delta)`**\nWhen a value $A[i]$ is changed by $\\Delta$, we must add $\\Delta$ to every `tree[j]` whose range contains index $i$. That is, we must update all `j` such that $(j \\ \\& \\ (j+1)) \\le i \\le j$.\nThis corresponds to an upward traversal in the implicit tree structure. The first index to update is $j=i$ itself. The next index, or child, must be the smallest $j' > j$ whose range contains the range of $j$. This \"child\" function is the inverse of the \"parent\" function from the query logic.\nThe upward traversal rule is $j \\leftarrow j \\ | \\ (j+1)$, where `|` is the bitwise OR operator.\n\nLet's justify this rule. Let $j_0 = i$. Let $j_{k+1} = j_k \\ | \\ (j_k+1)$.\nConsider $i=3$ ($011_2$). The update path is:\n- $j=3$.\n- $j \\leftarrow 3 \\ | \\ 4 = 7$ ($111_2$).\n- $j \\leftarrow 7 \\ | \\ 8 = 15$ ($1111_2$).\nThe ranges for these indices are:\n- `tree[3]`: range $[0, 3]$, contains $i=3$.\n- `tree[7]`: range $[0, 7]$, contains $i=3$.\n- `tree[15]`: range $[0, 15]$, contains $i=3$.\nThe rule correctly identifies all containing ranges in an efficient, structured manner. The algorithm is:\n- Start with index `j = i`.\n- While `j < n`:\n    - Add `delta` to `tree[j]`.\n    - Update `j` to its child: $j \\leftarrow j \\ | \\ (j+1)$.\n\n**Comparison with $1$-Based Indexing**\nThe traditional $1$-based Fenwick Tree uses the following traversal rules on an index $k \\in \\{1, \\dots, n\\}$:\n- **Query (downward):** $k \\leftarrow k - (k \\ \\& \\ (-k))$\n- **Update (upward):** $k \\leftarrow k + (k \\ \\& \\ (-k))$\nHere, $k \\ \\& \\ (-k)$ isolates the least significant bit (LSb) of $k$. This logic fundamentally relies on the property that any positive integer has a unique LSb. It breaks down for index $0$, as $0$ has no set bits. Our derived $0$-based rules, $j \\leftarrow (j \\ \\& \\ (j+1)) - 1$ for query and $j \\leftarrow j \\ | \\ (j+1)$ for update, provide a different but equally valid way to partition the prefix sum ranges that naturally incorporates index $0$. The core principle of decomposing prefixes into a logarithmic number of power-of-two-sized ranges remains the same, but the specific ranges and traversal logic are adapted to the $0$-based index space.\n\n**3. Range Sum Query: `range_sum(l, r)`**\nThe sum of elements in a range $[\\ell, r]$ can be computed using prefix sums:\n$$ \\sum_{k=\\ell}^{r} A[k] = \\sum_{k=0}^{r} A[k] - \\sum_{k=0}^{\\ell-1} A[k] = P(r) - P(\\ell-1) $$\nUsing our `prefix_sum` function, this is `prefix_sum(r) - prefix_sum(l-1)`. The provided convention $P(-1) = 0$ is naturally handled if our `prefix_sum(i)` function returns $0$ for any $i < 0$.\n\n**4. Construction: `build(initial_array)`**\nThe Fenwick Tree can be initialized from an existing array $A$ by treating it as a sequence of point updates. We start with a zero-filled `tree` array and for each element `A[i]`, we call `update(i, A[i])`. While a more optimized $O(n)$ build method exists, this $O(n \\log n)$ approach is straightforward and sufficient.\n\nThe implementation will follow these derived principles.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass FenwickTree:\n    \"\"\"\n    A Fenwick Tree (Binary Indexed Tree) implementation using 0-based indexing.\n    The traversal logic is derived from first principles for 0-based systems.\n    \"\"\"\n\n    def __init__(self, n: int):\n        \"\"\"\n        Initializes a Fenwick Tree for an array of size n.\n        \n        Args:\n            n: The number of elements.\n        \"\"\"\n        if not isinstance(n, int) or n < 0:\n            raise ValueError(\"Size n must be a non-negative integer.\")\n        self.n = n\n        # Use a numpy array to handle real numbers as per problem description.\n        self.tree = np.zeros(n, dtype=np.float64)\n\n    def build(self, initial_array: list):\n        \"\"\"\n        Builds the Fenwick tree from an initial array.\n        This is done by applying a point update for each element.\n        Complexity: O(n log n)\n        \n        Args:\n            initial_array: The list of numbers to build the tree from.\n        \"\"\"\n        if len(initial_array) != self.n:\n            raise ValueError(\"Initial array length must match tree size.\")\n        for i, val in enumerate(initial_array):\n            self.update(i, val)\n\n    def update(self, i: int, delta: float):\n        \"\"\"\n        Adds delta to the element at index i.\n        Complexity: O(log n)\n\n        Args:\n            i: The 0-based index to update.\n            delta: The value to add to A[i].\n        \"\"\"\n        if not (0 <= i < self.n):\n            # To maintain robustness, ignore out-of-bounds updates silently\n            # or raise an error. For this context, we ignore.\n            return\n            \n        j = i\n        while j < self.n:\n            self.tree[j] += delta\n            j = j | (j + 1)\n\n    def prefix_sum(self, i: int) -> float:\n        \"\"\"\n        Calculates the prefix sum P(i) = sum(A[0]...A[i]).\n        Complexity: O(log n)\n\n        Args:\n            i: The 0-based index of the end of the prefix.\n\n        Returns:\n            The prefix sum up to index i. Returns 0 if i < 0.\n        \"\"\"\n        if i < 0:\n            return 0.0\n        \n        # Ensure query index is within bounds\n        i = min(i, self.n - 1)\n\n        s = 0.0\n        j = i\n        while j >= 0:\n            s += self.tree[j]\n            j = (j & (j + 1)) - 1\n        return s\n\n    def range_sum(self, l: int, r: int) -> float:\n        \"\"\"\n        Calculates the sum of elements in the range [l, r].\n        Complexity: O(log n)\n        \n        Args:\n            l: The 0-based starting index of the range.\n            r: The 0-based ending index of the range.\n            \n        Returns:\n            The sum of A[l] through A[r].\n        \"\"\"\n        if l > r:\n            return 0.0\n        return self.prefix_sum(r) - self.prefix_sum(l - 1)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    results = []\n\n    def run_test_case(initial_array, operations):\n        n = len(initial_array)\n        fenwick_tree = FenwickTree(n)\n        fenwick_tree.build(initial_array)\n        \n        case_results = []\n        for op in operations:\n            op_type = op[0]\n            params = op[1:]\n            \n            if op_type == 'update':\n                i, delta = params\n                fenwick_tree.update(i, delta)\n            elif op_type == 'prefix_sum':\n                i = params[0]\n                res = fenwick_tree.prefix_sum(i)\n                case_results.append(int(round(res)))\n            elif op_type == 'range_sum':\n                l, r = params\n                res = fenwick_tree.range_sum(l, r)\n                case_results.append(int(round(res)))\n        return case_results\n\n    # Test Case 1\n    tc1_array = [3, -1, 4, 1, 5, -9, 2, 6]\n    tc1_ops = [\n        ('prefix_sum', 3),\n        ('range_sum', 2, 5),\n        ('update', 5, 9),\n        ('prefix_sum', 5),\n        ('range_sum', 0, 7),\n    ]\n    results.extend(run_test_case(tc1_array, tc1_ops))\n    \n    # Test Case 2\n    tc2_array = [7]\n    tc2_ops = [\n        ('prefix_sum', 0),\n        ('update', 0, -3),\n        ('range_sum', 0, 0),\n        ('update', 0, 10),\n        ('prefix_sum', 0),\n    ]\n    results.extend(run_test_case(tc2_array, tc2_ops))\n\n    # Test Case 3\n    tc3_array = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    tc3_ops = [\n        ('update', 0, 5),\n        ('update', 9, -2),\n        ('prefix_sum', 0),\n        ('prefix_sum', 9),\n        ('range_sum', 1, 8),\n    ]\n    results.extend(run_test_case(tc3_array, tc3_ops))\n\n    # Test Case 4\n    tc4_array = [1, 2, 3, 4, 5]\n    tc4_ops = [\n        ('range_sum', 2, 2),\n        ('range_sum', 0, 4),\n        ('update', 2, -3),\n        ('prefix_sum', 2),\n        ('range_sum', 3, 4),\n    ]\n    results.extend(run_test_case(tc4_array, tc4_ops))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3234121"}, {"introduction": "With a robust Fenwick tree implementation in hand, we can now tackle a classic algorithmic problem: counting inversions. This practice demonstrates how the structure excels at managing cumulative frequencies, especially when combined with coordinate compression to handle arbitrary data values. You will then extend this to a sliding window scenario, learning how to efficiently update aggregates as elements enter and leave the window. [@problem_id:3234116]", "problem": "You are to design and implement an algorithm based on the core definitions of cumulative frequency and inversion counting, then justify its efficiency from first principles. An inversion in an array is defined as follows: for an array $A$ of length $n$, the inversion count $I(A)$ is the number of index pairs $(i,j)$ such that $0 \\le i < j < n$ and $A_i > A_j$. The fundamental base consists of the definition of an inversion, the concept of a prefix sum and cumulative frequency over a discrete domain, and the ability to represent these cumulative frequencies by a data structure that supports point updates and prefix sum queries in logarithmic complexity, namely the Binary Indexed Tree (Fenwick tree). A Binary Indexed Tree (BIT) is an array-backed data structure that encodes cumulative frequencies such that a point update at an index and a prefix sum query up to an index both run in $O(\\log m)$ time, where $m$ is the size of the domain.\n\nPart $1$: Counting inversions with repeated values via coordinate compression. When values are not restricted to a small integer domain and may repeat, one must compress values to a dense rank domain. The method of coordinate compression maps distinct values in $A$ to ranks in $\\{1,2,\\dots,m\\}$, where $m$ is the number of distinct values. Using the frequency interpretation, the inversion count $I(A)$ is equivalent to summing, for each position $j$ scanned from left to right, the number of previously seen elements strictly greater than $A_j$. This can be expressed through cumulative frequencies of ranks by prefix sums and updates. You must implement a function that computes $I(A)$ for general integer arrays, using coordinate compression and a Binary Indexed Tree.\n\nPart $2$: Extending to sliding windows. Consider a fixed window size $k$ with $1 \\le k \\le n$ and the sequence of contiguous subarrays $A[0:k], A[1:k+1], \\dots, A[n-k:n]$. Define $I(A[i:i+k])$ to be the inversion count within the window of length $k$ starting at index $i$, where indices are taken relative to the window, so pairs are counted with respect to order inside the window. Derive a method to compute all window inversion counts efficiently by maintaining cumulative frequencies inside the current window and updating the inversion count when moving the window by one position. The update from window $W$ to the next window involves removing the leftmost element and adding the next element to the right; the change in inversion count can be expressed using strictly-less-than and strictly-greater-than counts in the maintained cumulative frequencies. Use coordinate compression over the entire array and a Binary Indexed Tree to maintain frequencies, and implement a function that returns the list $\\left[ I(A[0:k]), I(A[1:k+1]), \\dots, I(A[n-k:n]) \\right]$.\n\nPart $3$: Analyze amortized complexity. Provide a clear derivation of the amortized running time per window in Part $2$ and the total time in terms of $n$ and $m$, stating assumptions explicitly.\n\nYour program must implement these computations and produce results for the following test suite. Each test case is independent and should yield either an integer inversion count or a list of integer inversion counts for sliding windows:\n\n- Test case $1$: Compute $I(A)$ for $A = [3,3,2,1,2]$.\n- Test case $2$: Compute $I(A)$ for $A = []$ (the empty array).\n- Test case $3$: Compute $I(A)$ for $A = [1,2,3,4]$.\n- Test case $4$: Compute $\\left[ I(A[0:3]), I(A[1:4]), I(A[2:5]) \\right]$ for $A = [3,3,2,1,2]$ and $k = 3$.\n- Test case $5$: Compute $\\left[ I(A[0:2]), I(A[1:3]), I(A[2:4]) \\right]$ for $A = [1,2,3,4]$ and $k = 2$.\n- Test case $6$: Compute $\\left[ I(A[0:3]), I(A[1:4]) \\right]$ for $A = [5,5,5,5]$ and $k = 3$.\n- Test case $7$: Compute $\\left[ I(A[0:4]), I(A[1:5]), I(A[2:6]), I(A[3:7]) \\right]$ for $A = [5,4,4,3,2,2,1]$ and $k = 4$.\n- Test case $8$: Compute the full list of window inversion counts for $A = [3,3,2,1,2]$ with $k = 1$.\n\nFinal output format: Your program should produce a single line of output containing the results of the test cases as a comma-separated list enclosed in square brackets. For list-valued test cases, each list must itself be in bracketed comma-separated form, without spaces. For example, a valid output could look like $[7,0,0,[2,3,1],[0,0,0],[0,0],[5,5,5,5],[0,0,0,0,0]]$ corresponding to the eight test cases above.", "solution": "The problem requires the design, implementation, and analysis of algorithms for counting inversions in an array, both for the entire array and for sliding windows. The solution is founded upon the principles of cumulative frequency, coordinate compression, and the efficient query/update capabilities of the Binary Indexed Tree (BIT) data structure.\n\nA Binary Indexed Tree (or Fenwick Tree) is a data structure that can efficiently update element frequencies and calculate prefix sums in a domain of size $m$. Specifically, both `update` (incrementing the frequency of an element) and `query` (summing frequencies up to a certain element) operations are completed in $O(\\log m)$ time. For our purposes, the elements will be integer ranks derived from coordinate compression.\n\n### Part 1: Inversion Counting for a General Array\n\nAn inversion is a pair of indices $(i, j)$ such that $i < j$ and $A_i > A_j$. A naive approach of checking all pairs results in an $O(n^2)$ complexity, which is inefficient for large arrays. A more efficient method involves processing the array elements sequentially and, for each element, counting how many preceding elements form an inversion with it.\n\n**Algorithm Derivation:**\nWe iterate through the array $A$ from left to right, from index $j = 0$ to $n-1$. At each element $A_j$, we need to count the number of elements $A_i$ with $i < j$ such that $A_i > A_j$. This count is added to our total inversion count.\n\nTo perform this counting efficiently, we maintain a BIT that stores the frequencies of the values of the elements encountered so far (i.e., for $i < j$). If the values in $A$ are large or non-contiguous, we first apply **coordinate compression**. This technique maps each unique value in $A$ to a dense, 1-based integer rank from $1$ to $m$, where $m$ is the number of unique values. Let's denote the rank of a value $v$ as $\\text{rank}(v)$.\n\nThe algorithm proceeds as follows:\n1.  **Coordinate Compression**:\n    a. Extract all unique values from $A$.\n    b. Sort these unique values: $u_1 < u_2 < \\dots < u_m$.\n    c. Create a mapping from each value $u_k$ to its rank $k$.\n    d. Create a new array $A'$ where each $A'_j = \\text{rank}(A_j)$.\n2.  **BIT-based Counting**:\n    a. Initialize a BIT of size $m+1$ to all zeros. The BIT will store frequencies of ranks.\n    b. Initialize total inversions, $I(A) = 0$.\n    c. Iterate through $A$ from $j=0$ to $n-1$:\n        i. Let $r_j = \\text{rank}(A_j)$.\n        ii. The number of elements $A_i$ seen so far (with $i < j$) is $j$.\n        iii. We query the BIT to find the number of these $j$ elements whose rank is less than or equal to $r_j$. Let this be $C_{le} = \\text{BIT.query}(r_j)$.\n        iv. The number of elements seen so far whose rank is strictly greater than $r_j$ (and thus value is strictly greater than $A_j$) is $j - C_{le}$. These are precisely the elements that form an inversion with $A_j$.\n        v. Add this count to the total: $I(A) \\leftarrow I(A) + (j - \\text{BIT.query}(r_j))$.\n        vi. Update the BIT to include the current element: $\\text{BIT.update}(r_j, 1)$. This increments the frequency count for rank $r_j$.\n\nThe total complexity is dominated by coordinate compression, which requires sorting and is $O(n \\log n)$. The scanning phase involves $n$ steps, each with one BIT query and one BIT update, both taking $O(\\log m)$ time. Thus, the scanning phase is $O(n \\log m)$. Since $m \\le n$, the total time complexity is $O(n \\log n + n \\log m) = O(n \\log n)$.\n\n### Part 2: Sliding Window Inversion Counting\n\nThe task is to compute the inversion count for every contiguous subarray of length $k$. A naive application of the Part 1 algorithm to each of the $n-k+1$ windows would be inefficient, resulting in a total time of $O((n-k) \\cdot k \\log k)$. We can do much better by updating the inversion count as the window slides.\n\n**Algorithm Derivation:**\nLet $W_{i-1} = A[i-1:i-1+k]$ be the window at step $i-1$, and $W_i = A[i:i+k]$ be the next window. $W_i$ is obtained from $W_{i-1}$ by removing the leftmost element, $A_{old} = A[i-1]$, and adding the new rightmost element, $A_{new} = A[i+k-1]$. The core of the window, $C = A[i:i-1+k]$, is common to both.\n\nThe change in inversion count, $I(W_i) - I(W_{i-1})$, is due to the removal of $A_{old}$ and addition of $A_{new}$.\n1.  **Loss from removing $A_{old}$**: When $A_{old}$ is removed, we lose all inversions it formed with elements in $C$. Since $A_{old}$ was the first element, these are pairs $(A_{old}, x)$ where $x \\in C$ and $A_{old} > x$. The number of such pairs is the count of elements in $C$ that are strictly smaller than $A_{old}$. Let this count be `loss`.\n2.  **Gain from adding $A_{new}$**: When $A_{new}$ is added, we gain new inversions. Since $A_{new}$ is the last element, these are pairs $(x, A_{new})$ where $x \\in C$ and $x > A_{new}$. The number of such pairs is the count of elements in $C$ that are strictly greater than $A_{new}$. Let this count be `gain`.\n\nThe updated inversion count is $I(W_i) = I(W_{i-1}) - \\text{loss} + \\text{gain}$.\n\nWe can compute `loss` and `gain` efficiently using a BIT that maintains the rank frequencies of elements *inside the current window*.\n\nThe full algorithm is:\n1.  **Coordinate Compression**: Perform coordinate compression on the entire array $A$ to get ranks for all values. Let $m$ be the max rank.\n2.  **Initialization**:\n    a. Compute the inversion count for the first window $W_0 = A[0:k]$ using the algorithm from Part 1. Let this be `current_inversions`.\n    b. During this computation, populate a BIT of size $m+1$ with the rank frequencies of the elements in $W_0$.\n    c. Store `current_inversions` as the first result.\n3.  **Sliding**: Iterate from $i=1$ to $n-k$:\n    a. Let $A_{old} = A[i-1]$ and $A_{new} = A[i+k-1]$. Get their ranks, $r_{old}$ and $r_{new}$.\n    b. **Calculate `loss`**:\n        i. First, \"remove\" $A_{old}$ from the window's frequency counts: $\\text{BIT.update}(r_{old}, -1)$. The BIT now represents the elements in $C = A[i:k+i-1]$.\n        ii. The number of elements in $C$ smaller than $A_{old}$ is the sum of frequencies of ranks less than $r_{old}$. This is $\\text{loss} = \\text{BIT.query}(r_{old} - 1)$.\n        iii. Update the count: `current_inversions` $\\leftarrow$ `current_inversions` - `loss`.\n    c. **Calculate `gain`**:\n        i. The BIT still represents $C$. The number of elements in $C$ is $k-1$.\n        ii. The number of elements in $C$ greater than $A_{new}$ is $(k-1) - (\\text{number of elements in } C \\le A_{new})$. This is $\\text{gain} = (k-1) - \\text{BIT.query}(r_{new})$.\n        iii. Update the count: `current_inversions` $\\leftarrow$ `current_inversions` + `gain`.\n    d. **Update BIT**: \"Add\" $A_{new}$ to the window's frequency counts for the next iteration: $\\text{BIT.update}(r_{new}, 1)$. The BIT now represents $W_i$.\n    e. Store the new `current_inversions` in the results list.\n\n### Part 3: Amortized Complexity Analysis\n\nWe analyze the complexity of the sliding window algorithm in terms of $n$ (length of $A$) and $m$ (number of unique values).\n\n1.  **Setup Phase**:\n    *   Coordinate Compression: This involves sorting the unique elements of $A$, which takes $O(n \\log n)$ time. Creating the rank map and the ranked array takes $O(n \\log m)$ or $O(n)$, dominated by the sort. Total: $O(n \\log n)$.\n    *   First Window Calculation: Processing the first $k$ elements to get the initial inversion count and populate the BIT requires $k$ iterations, each with $O(\\log m)$ work. Total: $O(k \\log m)$.\n    *   Total Setup Cost: $C_{setup} = O(n \\log n + k \\log m)$.\n\n2.  **Sliding Phase**:\n    *   There are $n-k$ sliding steps.\n    *   Each step involves a constant number of BIT updates and queries (one update for remove, one query for loss, one query for gain, one update for add). Each BIT operation costs $O(\\log m)$.\n    *   Cost per slide: $O(\\log m)$.\n    *   Total Sliding Cost: $C_{slide} = (n-k) \\cdot O(\\log m) = O((n-k) \\log m)$.\n\n3.  **Total Complexity**:\n    *   The total time complexity is the sum of setup and sliding costs:\n        $$ T(n, k, m) = O(n \\log n + k \\log m + (n-k) \\log m) = O(n \\log n + n \\log m) $$\n    *   Since the number of unique elements $m \\le n$, we have $\\log m \\le \\log n$. Therefore, the total complexity is dominated by the initial coordinate compression step:\n        $$ T(n,k) = O(n \\log n) $$\n\n4.  **Amortized Complexity Per Window**:\n    *   The algorithm computes results for $N_w = n-k+1$ windows.\n    *   Amortized cost per window is the total cost divided by the number of windows.\n        $$ \\text{Cost}_{\\text{amortized}} = \\frac{T(n,k)}{N_w} = \\frac{O(n \\log n)}{n-k+1} $$\n    *   Assuming $k$ is not close to $n$ (e.g., $k \\le \\alpha n$ for some constant $\\alpha < 1$), the number of windows $n-k+1$ is $O(n)$.\n    *   In this common case, the amortized cost per window is $\\frac{O(n \\log n)}{O(n)} = O(\\log n)$.\n    *   This reflects that the expensive $O(n \\log n)$ setup cost is spread across many windows, and the incremental work for each subsequent window is a much smaller $O(\\log m)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass FenwickTree:\n    \"\"\"A 1-indexed Fenwick Tree (Binary Indexed Tree).\"\"\"\n\n    def __init__(self, size: int):\n        \"\"\"Initializes a Fenwick Tree of a given size, filled with zeros.\"\"\"\n        if not isinstance(size, int) or size < 0:\n            raise ValueError(\"Size must be a non-negative integer.\")\n        self.tree = np.zeros(size + 1, dtype=int)\n\n    def update(self, index: int, delta: int):\n        \"\"\"Adds delta to the element at the given index.\"\"\"\n        if not (1 <= index < len(self.tree)):\n            # Silently ignore out-of-bounds updates for simplicity.\n            # In a real scenario, this might raise an error.\n            return\n        while index < len(self.tree):\n            self.tree[index] += delta\n            index += index & -index\n\n    def query(self, index: int) -> int:\n        \"\"\"Computes the prefix sum up to the given index (inclusive).\"\"\"\n        if index < 1:\n            return 0\n        if index >= len(self.tree):\n            index = len(self.tree) - 1\n\n        s = 0\n        while index > 0:\n            s += self.tree[index]\n            index -= index & -index\n        return s\n\ndef _get_rank_map(arr):\n    \"\"\"Performs coordinate compression.\"\"\"\n    if not arr:\n        return {}, 0\n    unique_sorted_vals = sorted(list(set(arr)))\n    rank_map = {val: i + 1 for i, val in enumerate(unique_sorted_vals)}\n    return rank_map, len(unique_sorted_vals)\n\ndef count_inversions(A):\n    \"\"\"Computes the inversion count for a general integer array.\"\"\"\n    n = len(A)\n    if n == 0:\n        return 0\n\n    rank_map, m = _get_rank_map(A)\n    ranked_A = [rank_map[val] for val in A]\n    \n    bit = FenwickTree(m)\n    inversions = 0\n    \n    for i in range(n):\n        rank = ranked_A[i]\n        # Inversions = (elements seen so far) - (elements seen <= current)\n        # Elements seen so far = i\n        # Elements seen with rank > current rank = i - (elements seen with rank <= current rank)\n        inversions += i - bit.query(rank)\n        bit.update(rank, 1)\n        \n    return inversions\n\ndef sliding_window_inversions(A, k):\n    \"\"\"Computes inversion counts for all sliding windows of size k.\"\"\"\n    n = len(A)\n    if k <= 0 or k > n:\n        return []\n    if k == 1:\n        return [0] * n\n\n    rank_map, m = _get_rank_map(A)\n    ranked_A = [rank_map[val] for val in A]\n\n    results = []\n    bit = FenwickTree(m)\n    current_inversions = 0\n\n    # Calculate inversions for the first window\n    for i in range(k):\n        rank = ranked_A[i]\n        current_inversions += i - bit.query(rank)\n        bit.update(rank, 1)\n    results.append(current_inversions)\n\n    # Slide the window\n    for i in range(1, n - k + 1):\n        # Element to remove from the left\n        old_rank = ranked_A[i-1]\n        \n        # Element to add to the right\n        new_rank = ranked_A[i + k - 1]\n\n        # 1. Account for removing the old element.\n        # It formed inversions with elements smaller than it in the rest of the window.\n        # First, remove its contribution from the frequency count.\n        bit.update(old_rank, -1)\n        # Loss = count of elements in A[i:i+k-1] with rank < old_rank\n        loss = bit.query(old_rank - 1)\n        current_inversions -= loss\n\n        # 2. Account for adding the new element.\n        # It forms inversions with elements larger than it in the window A[i:i+k-1].\n        # Gain = count of elements in A[i:i+k-1] with rank > new_rank\n        # = (k-1) - (count of elements with rank <= new_rank)\n        gain = (k - 1) - bit.query(new_rank)\n        current_inversions += gain\n\n        # 3. Add the new element's frequency for the next iteration.\n        bit.update(new_rank, 1)\n        \n        results.append(current_inversions)\n\n    return results\n\ndef solve():\n    \"\"\"Runs all test cases and prints the final result.\"\"\"\n    test_cases = [\n        {'type': 'count', 'A': [3, 3, 2, 1, 2]},\n        {'type': 'count', 'A': []},\n        {'type': 'count', 'A': [1, 2, 3, 4]},\n        {'type': 'sliding', 'A': [3, 3, 2, 1, 2], 'k': 3},\n        {'type': 'sliding', 'A': [1, 2, 3, 4], 'k': 2},\n        {'type': 'sliding', 'A': [5, 5, 5, 5], 'k': 3},\n        {'type': 'sliding', 'A': [5, 4, 4, 3, 2, 2, 1], 'k': 4},\n        {'type': 'sliding', 'A': [3, 3, 2, 1, 2], 'k': 1}\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'count':\n            result = count_inversions(case['A'])\n        else: # 'sliding'\n            result = sliding_window_inversions(case['A'], case['k'])\n        results.append(result)\n\n    def format_result(res):\n        if isinstance(res, list):\n            return f\"[{','.join(map(str, res))}]\"\n        return str(res)\n\n    final_output_str = f\"[{','.join(map(format_result, results))}]\"\n    print(final_output_str)\n\nsolve()\n\n```", "id": "3234116"}, {"introduction": "Our final practice moves beyond standard prefix sum queries to unlock a more advanced capability of the Fenwick tree. Instead of just querying sums, you will learn to efficiently search for an index whose cumulative sum surpasses a specific threshold, a technique sometimes called 'walking the tree'. This powerful $O(\\log n)$ search pattern is a key optimization for a wide range of problems involving non-decreasing sequences. [@problem_id:3234174]", "problem": "You are given the task of designing and implementing a program that, for multiple test cases, uses a Fenwick tree (Binary Indexed Tree) to return the smallest index $i$ such that the cumulative frequency $S(i)$ strictly exceeds a given threshold $T$, where $S(i)$ is the prefix sum $S(i) = \\sum_{k=1}^{i} A[k]$. All arrays consist of nonnegative integers so that $S(i)$ is nondecreasing in $i$. If no such index exists because $T$ is greater than or equal to the total sum $\\sum_{k=1}^{n} A[k]$, the program must return $-1$ for that query. The goal is to derive, justify, and implement an algorithm that performs this search in time $\\mathcal{O}(\\log n)$ by exploiting only the internal structure of a Fenwick tree and its well-known update and query primitives. You must not use any external search over $i$ that is asymptotically slower than $\\mathcal{O}(\\log n)$.\n\nFundamental base you may use:\n- The definition of the Fenwick tree over an array $A[1\\ldots n]$ storing partial sums that enable point updates and prefix sums in $\\mathcal{O}(\\log n)$ time using the least significant set bit function $lsb(x)$, where $lsb(x)$ can be computed as $x \\ \\& \\ (-x)$.\n- The invariants that each internal tree cell aggregates a range whose length is a power of two and that these ranges form a disjoint cover for any prefix.\n\nYour program must construct a Fenwick tree for each test case from the initial array and must implement:\n- Point update $A[i] \\leftarrow A[i] + \\Delta$ with $\\Delta \\ge -A[i]$ to preserve nonnegativity.\n- Search operation: given $T$, return the minimum $i$ such that $S(i) > T$, or $-1$ if no such index exists.\n\nYour program should run the following test suite and output the results in the exact required format. For each test case, report the results of the search queries in the order given. For any test case that includes updates, apply the updates in order and report only the search results.\n\nTest suite:\n- Test case $1$ (happy path, mixed thresholds):\n  - Array $A = [2,1,3,4,5]$.\n  - Thresholds $T$ to query: $[-1,0,2,3,9,10,14]$.\n- Test case $2$ (boundary where $T$ equals the total sum):\n  - Array $A = [5,0,0]$.\n  - Thresholds $T$ to query: $[4,5]$.\n- Test case $3$ (internal zeros and negative threshold):\n  - Array $A = [0,0,5,0,0]$.\n  - Thresholds $T$ to query: $[-1,0,1,4]$.\n- Test case $4$ (dynamic updates and queries):\n  - Initial array $A = [1,2,3,4]$.\n  - Operations in sequence (apply updates in order; output only for queries):\n    - Query with $T=0$.\n    - Point update add $\\Delta=-2$ at index $i=2$.\n    - Query with $T=1$.\n    - Point update add $\\Delta=5$ at index $i=1$.\n    - Query with $T=5$.\n    - Point update set index $i=4$ to value $0$.\n    - Query with $T=8$.\n    - Query with $T=9$.\n- Test case $5$ (larger $n$ to exercise bit traversal):\n  - Array $A = [0,1,0,2,0,3,0,4,5,0,0,6,0,7,8,0]$.\n  - Thresholds $T$ to query: $[0,1,2,9,14,20,27,35,36]$.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case’s results reported as a list of integers (using $-1$ where appropriate). For example, produce an output like $[\\,[\\cdots],[\\cdots],\\ldots\\,]$ with no additional spaces. The output must be precisely the program’s computed answers for the given test suite, and each item must be a boolean, an integer, a float, or a list of these fundamental types. No physical units are involved, and no angles or percentages are involved.\n\nScientific realism and constraints:\n- All values are integers and nonnegative in arrays; updates maintain nonnegativity. All operations run in finite time. The algorithm must rely on the Fenwick tree’s structure and properties to achieve $\\mathcal{O}(\\log n)$ per operation.", "solution": "The user wants to solve a problem regarding Fenwick trees.\n\n### Step 1: Extract Givens\n- **Task**: Find the smallest index $i$ such that the cumulative frequency $S(i) = \\sum_{k=1}^{i} A[k]$ strictly exceeds a given threshold $T$.\n- **Data Constraints**: Arrays consist of nonnegative integers. This implies $S(i)$ is a non-decreasing function of $i$. Point updates must preserve nonnegativity, i.e., for an update $\\Delta$ at index $i$, $\\Delta \\ge -A[i]$.\n- **Return Value**: If a valid index $i$ exists, return $i$. Otherwise, if $T \\ge \\sum_{k=1}^{n} A[k]$, return $-1$.\n- **Performance Constraint**: The search algorithm must have a time complexity of $\\mathcal{O}(\\log n)$ and must achieve this by exploiting the internal structure of the Fenwick tree, not by an external search over indices.\n- **Primitives**: The solution can use the standard Fenwick tree (or Binary Indexed Tree, BIT) point update and prefix sum query primitives, which operate in $\\mathcal{O}(\\log n)$ time. The least significant bit function, $lsb(x) = x \\ \\& \\ (-x)$, is a fundamental component.\n- **Test Suite**: Five test cases are provided, including initial arrays, thresholds for querying, and a sequence of dynamic updates mixed with queries.\n    - Test Case 1: $A = [2,1,3,4,5]$, $T \\in [-1,0,2,3,9,10,14]$.\n    - Test Case 2: $A = [5,0,0]$, $T \\in [4,5]$.\n    - Test Case 3: $A = [0,0,5,0,0]$, $T \\in [-1,0,1,4]$.\n    - Test Case 4: Initial $A = [1,2,3,4]$, followed by a sequence of updates and queries.\n    - Test Case 5: $A = [0,1,0,2,0,3,0,4,5,0,0,6,0,7,8,0]$, $T \\in [0,1,2,9,14,20,27,35,36]$.\n- **Output Format**: A single line `[[...],[...],...]` containing a list of lists of integer results, with no spaces.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is evaluated against the validation criteria.\n\n- **Scientifically Grounded**: The problem is rooted in the well-established domain of data structures and algorithms. Fenwick trees, prefix sums, and logarithmic time complexity are standard concepts in computer science. The problem is mathematically and algorithmically sound.\n- **Well-Posed**: The problem is well-posed. Since the array elements are nonnegative, the prefix sum function $S(i)$ is non-decreasing. Therefore, the set of indices $i$ for which $S(i) > T$ is a contiguous block at the end of the range $[1, n]$. The request for the *smallest* such index is unambiguous. The condition for returning $-1$ is also clearly defined. A unique, stable, and meaningful solution exists for any given input.\n- **Objective**: The problem is stated using precise, objective, and formal mathematical language (e.g., \"smallest index $i$,\" \"strictly exceeds,\" \"cumulative frequency\"). There is no subjective or ambiguous terminology.\n- **Completeness and Consistency**: The problem is self-contained. It provides all necessary definitions, constraints (nonnegativity), performance requirements ($\\mathcal{O}(\\log n)$), and a complete test suite to verify an implementation. The nonnegativity constraint is consistent with the non-decreasing nature of $S(i)$, which is essential for the search problem's structure.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-defined, standard algorithmic challenge that requires a specific, non-trivial technique for an efficient solution. I will proceed with providing a complete, reasoned solution.\n\n### Principle-Based Solution\n\nThe problem requires finding the smallest integer index $i$ in a $1$-based array $A$ of size $n$ such that the prefix sum $S(i) = \\sum_{k=1}^{i} A[k]$ is strictly greater than a threshold $T$. This search must be performed in $\\mathcal{O}(\\log n)$ time using a Fenwick tree.\n\nA standard Fenwick tree, also known as a Binary Indexed Tree (BIT), is a data structure that can compute prefix sums and perform point updates in $\\mathcal{O}(\\log n)$ time. Let the BIT be represented by an array `bit`. The element `bit[k]` stores the sum of elements of $A$ in the range $(k - \\text{lsb}(k), k]$, where $\\text{lsb}(k)$ is the least significant set bit of $k$.\n\nA naive approach to the search problem would be to perform a binary search on the index $i \\in [1, n]$. For each guessed index $i_{guess}$, we would compute $S(i_{guess})$ using the Fenwick tree's query operation. This would take $\\mathcal{O}(\\log n)$ time per query. Since a binary search requires $\\mathcal{O}(\\log n)$ probes, the total time complexity would be $\\mathcal{O}(\\log^2 n)$. This is explicitly forbidden by the problem's constraints.\n\nTo achieve an $\\mathcal{O}(\\log n)$ search, we must leverage the internal structure of the Fenwick tree more directly. The key insight is to build the target index bit by bit, from the most significant bit to the least significant bit. This is analogous to a binary search on the prefix sums themselves, or a walk down an implicit binary tree where nodes represent blocks of summed values.\n\nThe algorithm proceeds as follows:\nFirst, we handle the edge case where no solution exists. This occurs if the total sum of the array, $S(n)$, is not strictly greater than $T$. We can compute $S(n)$ with a single $\\mathcal{O}(\\log n)$ query. If $S(n) \\le T$, we return $-1$.\n\nIf a solution is guaranteed to exist, we find the index. We are searching for the smallest $i$ with $S(i)>T$. This is equivalent to finding the largest index $j$ such that $S(j) \\le T$, and our answer will be $j+1$.\n\nLet's find this index $j$. We can construct $j$ by determining its binary representation. We start with an index `idx` = $0$ and a `current_sum` = $0$. We iterate downwards from the largest power of two, $p$, that is less than or equal to $n$.\nIn each step, we consider extending our current prefix. The potential new index would be `idx + p`. The Fenwick tree is structured such that `bit[idx + p]` stores the sum of a contiguous block of the original array $A$ that immediately follows the prefix ending at `idx`.\n\nThe core logic is: if we can add this next block of values without exceeding the threshold $T$, we take it. That is, if `idx + p` is a valid index (i.e., `idx + p <= n`) and `current_sum + bit[idx + p] \\le T`, we are sure that the target index $j$ is at least `idx + p`. So we update `current_sum` by adding `bit[idx + p]` and update our position by setting `idx = idx + p`.\n\nIf `current_sum + bit[idx + p] > T`, we cannot take this block, as doing so would already violate the condition $S(j) \\le T$. In this case, we do not update `idx` or `current_sum`, and we proceed to check the next smaller power of two.\n\nThis process is repeated for all powers of two from the largest down to $1$. After the loop finishes, `idx` will hold the largest index $j$ such that $S(j) \\le T$. The smallest index $i$ satisfying $S(i) > T$ is therefore `idx + 1`.\n\nLet's formalize the search algorithm:\n1.  Check if $S(n) \\le T$. If so, return $-1$.\n2.  Initialize `idx = 0` and `current_sum = 0$.\n3.  Determine the largest power of two less than or equal to $n$, let's say $p_{max} = 2^{\\lfloor \\log_2 n \\rfloor}$.\n4.  Iterate with $p$ from $p_{max}$ down to $1$ (in powers of two).\n    a. Test the potential next index `next_idx = idx + p`.\n    b. If `next_idx \\le n` and `current_sum + bit[next_idx] \\le T`:\n        i.  `current_sum \\leftarrow current_sum + bit[next_idx]`\n        ii. `idx \\leftarrow next_idx`\n5.  Return `idx + 1`.\n\nThis procedure involves a single pass over the $\\log_2 n$ bits of the index, with constant time work inside the loop, resulting in an overall time complexity of $\\mathcal{O}(\\log n)$ for the search, as required. Updates are handled by the standard Fenwick tree update algorithm, also in $\\mathcal{O}(\\log n)$.\n\nFor updating a value at a specific index from an old value to a new value, the change $\\Delta$ is `new_value - old_value`. The `update` primitive of the Fenwick tree is then called with this `delta`. To facilitate this, we can store a copy of the array values alongside the Fenwick tree.", "answer": "```python\nimport math\n\nclass FenwickTree:\n    \"\"\"\n    Fenwick Tree (Binary Indexed Tree) for sum operations.\n    It uses 1-based indexing internally for the BIT array,\n    but accepts 0-based indices in its public methods.\n    \"\"\"\n    def __init__(self, values):\n        \"\"\"\n        Initializes the Fenwick Tree from a list of values.\n        \"\"\"\n        self.n = len(values)\n        # Store original values to calculate deltas for updates\n        self.values = list(values)\n        # Internal bit is 1-indexed, so size is n+1\n        self.bit = [0] * (self.n + 1)\n        # Build the tree\n        for i in range(self.n):\n            self._update(i + 1, self.values[i])\n\n    def _update(self, idx, delta):\n        \"\"\"Internal update using 1-based index.\"\"\"\n        while idx <= self.n:\n            self.bit[idx] += delta\n            idx += idx & -idx\n\n    def update_value(self, idx, new_val):\n        \"\"\"\n        Adds `new_val` (delta) to the value at a 0-based index.\n        \"\"\"\n        if not (0 <= idx < self.n):\n            raise ValueError(\"Index out of bounds\")\n        delta = new_val\n        self.values[idx] += delta\n        self._update(idx + 1, delta)\n\n    def set_value(self, idx, new_val):\n        \"\"\"\n        Sets the value at a 0-based index to new_val.\n        \"\"\"\n        if not (0 <= idx < self.n):\n            raise ValueError(\"Index out of bounds\")\n        delta = new_val - self.values[idx]\n        self.values[idx] = new_val\n        self._update(idx + 1, delta)\n\n    def _query(self, idx):\n        \"\"\"Internal query for prefix sum S(idx) using 1-based index.\"\"\"\n        s = 0\n        while idx > 0:\n            s += self.bit[idx]\n            idx -= idx & -idx\n        return s\n\n    def query_prefix_sum(self, idx):\n        \"\"\"\n        Public method for prefix sum S(idx) using 0-based index.\n        Returns sum of values[0]...values[idx].\n        \"\"\"\n        if idx < 0:\n            return 0\n        if idx >= self.n:\n            idx = self.n - 1\n        return self._query(idx + 1)\n\n    def find_first_greater(self, T):\n        \"\"\"\n        Finds the smallest 1-based index i such that S(i) > T\n        in O(log n) time. Returns -1 if no such index exists.\n        \"\"\"\n        total_sum = self._query(self.n)\n        if total_sum <= T:\n            return -1\n\n        # Binary search on the Fenwick tree structure\n        idx = 0\n        current_sum = 0\n        \n        # Find the largest power of 2 less than or equal to n\n        if self.n == 0:\n            return -1\n        \n        log_n = self.n.bit_length() - 1\n        \n        # Iterate from the most significant bit downwards\n        for p_power in range(log_n, -1, -1):\n            p = 1 << p_power\n            if idx + p <= self.n:\n                # Check if taking this block keeps the sum <= T\n                if current_sum + self.bit[idx + p] <= T:\n                    current_sum += self.bit[idx + p]\n                    idx += p\n        \n        # The result is the index right after the largest prefix with sum <= T\n        return idx + 1\n\ndef solve():\n    test_cases = [\n        {\n            \"array\": [2, 1, 3, 4, 5],\n            \"ops\": [(\"query\", t) for t in [-1, 0, 2, 3, 9, 10, 14]]\n        },\n        {\n            \"array\": [5, 0, 0],\n            \"ops\": [(\"query\", t) for t in [4, 5]]\n        },\n        {\n            \"array\": [0, 0, 5, 0, 0],\n            \"ops\": [(\"query\", t) for t in [-1, 0, 1, 4]]\n        },\n        {\n            \"array\": [1, 2, 3, 4],\n            \"ops\": [\n                (\"query\", 0),\n                (\"add\", 1, -2),\n                (\"query\", 1),\n                (\"add\", 0, 5),\n                (\"query\", 5),\n                (\"set\", 3, 0),\n                (\"query\", 8),\n                (\"query\", 9),\n            ]\n        },\n        {\n            \"array\": [\n                0, 1, 0, 2, 0, 3, 0, 4, 5, 0, 0, 6, 0, 7, 8, 0\n            ],\n            \"ops\": [(\"query\", t) for t in [0, 1, 2, 9, 14, 20, 27, 35, 36]]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # The problem text describes 1-based arrays, but Python is 0-based.\n        # We work with 0-based arrays and the Fenwick Tree class handles the conversion.\n        ft = FenwickTree(case[\"array\"])\n        case_results = []\n        for op in case[\"ops\"]:\n            op_type = op[0]\n            if op_type == \"query\":\n                T = op[1]\n                result = ft.find_first_greater(T)\n                case_results.append(result)\n            elif op_type == \"add\":\n                # Problem uses 1-based indices, so we subtract 1 for 0-based code.\n                idx_0_based, val = op[1], op[2]\n                ft.update_value(idx_0_based, val)\n            elif op_type == \"set\":\n                # Problem uses 1-based indices, so we subtract 1 for 0-based code.\n                idx_0_based, val = op[1], op[2]\n                ft.set_value(idx_0_based, val)\n        all_results.append(case_results)\n\n    # Format output to be a single line, list of lists, with no spaces\n    results_str = \",\".join([str(res).replace(\" \", \"\") for res in all_results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```", "id": "3234174"}]}