{"hands_on_practices": [{"introduction": "To truly master the B+ tree, one must understand its structural limits. This exercise [@problem_id:3212380] challenges you to think algorithmically about how to construct a \"pessimal\" treeâ€”one that has a specific height but holds the minimum possible number of keys. By devising a sequence of insertions and deletions to achieve this state, you will gain a profound understanding of the rebalancing rules that guarantee a B+ tree's efficiency.", "problem": "Consider a B+ tree of order $m$ over an ordered universe of integer keys, with the following standard properties. Every internal node has at most $m$ children and, except for the root, at least $\\left\\lceil \\frac{m}{2} \\right\\rceil$ children; if the root is not a leaf, it has at least $2$ children. Every leaf stores only data keys (all keys in the tree live in leaves) and can hold between $\\left\\lceil \\frac{m}{2} \\right\\rceil$ and $m$ keys. An internal node with $c$ children holds exactly $c-1$ separator keys. Insertions and deletions use the standard B+ tree rebalancing semantics: on overflow, nodes split; on underflow, redistribution from siblings is attempted, and if not possible, a merge is performed; in all cases parent separators and possibly higher ancestors are updated as required by the standard algorithms.\n\nStarting from an empty tree, construct a concrete, explicit sequence of insertions and deletions of integer keys that, for any prescribed height $h \\geq 1$ (root at depth $0$, leaves at depth $h$), transitions the tree to a configuration of height $h$ in which every internal node other than the root has exactly $\\left\\lceil \\frac{m}{2} \\right\\rceil$ children, the root has exactly $2$ children, and every leaf has exactly $\\left\\lceil \\frac{m}{2} \\right\\rceil$ keys. Your construction must be finite for each $h$ and must rely only on the standard B+ tree operations defined above. Justify why your construction attains and preserves the stated minimum-occupancy configuration at the end of the constructed sequence.\n\nThen, in terms of $m$ and $h$, determine a closed-form expression $N_{\\min}(h,m)$ for the minimum possible total number of keys stored in the tree when the height is exactly $h$ and the tree is in the minimum-occupancy configuration described above. Provide your final answer as a single closed-form analytic expression for $N_{\\min}(h,m)$. No rounding is required.", "solution": "The problem is evaluated to be valid. It is a well-posed problem in the domain of data structures and algorithms, based on standard definitions of a B+ tree. The premises are internally consistent and scientifically sound.\n\nThe problem consists of two parts. First, to devise a constructive procedure to create a B+ tree of a specified height $h$ in a minimal configuration. Second, to derive a closed-form expression for the number of keys in such a tree.\n\nLet the order of the B+ tree be $m$. The minimum number of children for an internal node (except the root) is $k = \\left\\lceil \\frac{m}{2} \\right\\rceil$. The minimum number of keys in a leaf is also $k$. For a non-leaf root, the minimum number of children is $2$. We assume $m \\geq 3$, which ensures $k \\geq 2$.\n\n**Part 1: Construction of the Minimal Tree**\n\nThe target configuration for a tree of height $h \\geq 1$ is as follows:\n- The root, at depth $0$, has exactly $2$ children.\n- Every internal node at depths $i \\in \\{1, 2, \\ldots, h-1\\}$ has exactly $k = \\left\\lceil \\frac{m}{2} \\right\\rceil$ children.\n- Every leaf node, at depth $h$, contains exactly $k = \\left\\lceil \\frac{m}{2} \\right\\rceil$ keys.\n\nA sequence of operations to achieve this state can be described algorithmically. The general strategy is to first construct a B+ tree of the required height $h$, and then to systematically \"trim\" this tree using deletion-based operations (redistribution and merging) until all nodes reach their specified minimal occupancy.\n\nThe construction procedure for a given height $h \\geq 1$:\n\n1.  **Height Growth Phase:** The initial goal is to create any valid B+ tree of height $h$. This is accomplished by forcing a series of root splits.\n    a.  Start with an empty tree. Insert $m+1$ distinct integer keys. According to the standard B+ tree insertion algorithm, the initial leaf node will overflow and split. A new root is created with $2$ children (the two new leaves), and the tree's height becomes $1$.\n    b.  To increase the height from $i-1$ to $i$, the root of the height $i-1$ tree must be split. A root node with $c$ children contains $c-1$ separator keys. To overflow, it needs to be forced to accommodate $m+1$ children, which means it must contain $m$ separator keys before splitting.\n    c.  Assume we have a tree of height $i-1$. Its root possesses some number of children, say $c_{root}$. To make this root split, we must cause $m+1 - c_{root}$ splits to occur among its descendant nodes, with the resulting new separators being promoted up to the root. This can be achieved by a targeted sequence of insertions. For example, repeatedly inserting keys larger than any existing key will cause a cascade of splits along the rightmost path of the tree. By orchestrating a sufficient number of such insertions, we can cause enough separators to be promoted to the root, filling it until it has $m$ separators and then splitting upon the next promotion.\n    d.  This process is repeated until a tree of height $h$ is formed. When the root of a height-$h-1$ tree splits, the new root has $2$ children, and the overall tree height becomes $h$.\n\n2.  **Trimming Phase:** After the growth phase, we have a valid B+ tree of height $h$. The root has $2$ children, as it was just formed by a split. However, other nodes in the tree are not guaranteed to be in the minimal configuration. We now trim the tree, typically in a bottom-up fashion.\n    a.  **Trim Leaves:** For every leaf node $L$ at depth $h$ that contains $n_L$ keys where $n_L > k$: delete $n_L - k$ keys from $L$. Since $k$ is the minimum allowed number of keys, these deletions will not cause an underflow in $L$ itself.\n    b.  **Trim Internal Nodes:** For every internal node $N$ at depths $i \\in \\{1, \\ldots, h-1\\}$ that has $c_N > k$ children: we must reduce its number of children to $k$. This is accomplished by forcing $c_N - k$ merge operations among its children.\n        i.  To force a merge between two adjacent children, $C_1$ and $C_2$, of node $N$, one must underflow while its sibling cannot provide a key/child via redistribution. This can be carefully arranged. We ensure all nodes in the subtrees rooted at $C_1$ and $C_2$ are already trimmed to their minimal size (by applying this procedure bottom-up).\n        ii.  Then, we select a leaf in the subtree of $C_1$ and delete a key, causing it to underflow (it now has $k-1$ keys). Since its sibling leaf is minimal (with $k$ keys), redistribution is not possible, forcing a merge.\n        iii. This merge at the leaf level removes a child from the parent node. This effect propagates up. A merge of two nodes at depth $j$ results in their parent at depth $j-1$ losing a child.\n        iv. By systematically triggering such merges, we can reduce the number of children of node $N$ from $c_N$ down to $k$. This is repeated for all internal nodes that are not the root and are over-occupied.\n\nThis two-phase construction is guaranteed to produce the desired minimal configuration. Every operation used (insertion, deletion, split, merge, redistribution) is a standard part of B+ tree maintenance algorithms. The target occupancies ($2$ for the root's children, $k$ for all other nodes) are at or above the minimums required by the B+ tree properties, so this state is a valid, stable configuration.\n\n**Part 2: Derivation of $N_{\\min}(h,m)$**\n\nWe now calculate the total number of keys, $N_{\\min}(h,m)$, stored in this minimally configured B+ tree of height $h$. In a B+ tree, data keys are exclusively stored in the leaf nodes. Therefore, we need to find the total number of leaves and multiply it by the number of keys in each leaf.\n\nLet $k = \\left\\lceil \\frac{m}{2} \\right\\rceil$. The structure of the minimal tree is as follows:\n- The root is at depth $0$ and has $2$ children. This gives $2$ nodes at depth $1$.\n- Each internal node at depth $i$, where $1 \\leq i  h$, has $k$ children.\n- The nodes at depth $h-1$ are the parents of the leaves and also have $k$ children each.\n\nLet's count the number of nodes at each depth $i$:\n- Number of nodes at depth $0$: $1$ (the root).\n- Number of nodes at depth $1$: $2$ (children of the root).\n- Number of nodes at depth $2$: The $2$ nodes at depth $1$ each have $k$ children, so there are $2 \\times k$ nodes at depth $2$.\n- Number of nodes at depth $3$: The $2k$ nodes at depth $2$ each have $k$ children, so there are $(2k) \\times k = 2k^2$ nodes at depth $3$.\n\nBy induction, the number of nodes at depth $i$, for $1 \\leq i \\leq h$, is $2 \\times k^{i-1}$.\n\nTo find the number of leaves, we evaluate this for depth $i=h$.\nNumber of leaves = Number of nodes at depth $h = 2 \\times k^{h-1}$.\n\nAccording to the specified minimal configuration, each leaf node contains exactly $k$ keys.\nTotal number of keys $N_{\\min}(h,m)$ is the product of the number of leaves and the number of keys per leaf.\n$$N_{\\min}(h,m) = (\\text{Number of leaves}) \\times (\\text{Keys per leaf})$$\n$$N_{\\min}(h,m) = (2 \\times k^{h-1}) \\times k$$\n$$N_{\\min}(h,m) = 2 \\times k^h$$\n\nSubstituting the definition of $k$ back into the expression, we get the final closed-form formula in terms of $h$ and $m$:\n$$N_{\\min}(h,m) = 2 \\left( \\left\\lceil \\frac{m}{2} \\right\\rceil \\right)^h$$\n\nThis formula represents the minimum possible number of keys in a B+ tree of order $m$ and height $h$.", "answer": "$$\n\\boxed{2 \\left( \\left\\lceil \\frac{m}{2} \\right\\rceil \\right)^h}\n$$", "id": "3212380"}, {"introduction": "The choice between a B-tree and a B+ tree often involves a trade-off between search speed and storage space. This practice [@problem_id:3212355] guides you through a formal derivation to quantify this trade-off in terms of space efficiency. You will develop a symbolic expression that, based on parameters like key size $k$, data size $d$, and block size $B$, determines which structure consumes fewer disk blocks, providing a powerful tool for architectural decision-making.", "problem": "Consider two disk-resident search trees built over $n$ records, each record consisting of a key of size $k$ and associated data of size $d$, all sizes measured in bytes. Each disk block has capacity $B$ bytes. Pointers have size $p$ bytes and point to child nodes; assume that pointer sizes are uniform regardless of level. Assume the following canonical node layouts, with no per-node header beyond what is stated:\n\n1. In a B-tree, each internal node contains child pointers and actual records; each leaf node contains only records. Internal nodes have no leaf-to-leaf sibling pointers; leaf nodes have no sibling pointers either.\n2. In a B$+$ tree, each internal node contains only separator keys and child pointers (no data), while each leaf node contains records and exactly one right-sibling pointer of size $p$.\n\nAssume every node in both trees is perfectly full at its maximum allowable occupancy given by the block capacity constraint. In particular, assume $B  p + k + d$ and $B  p + k$ and $B  k + d$, so that all relevant occupancies and fanouts are at least $2$ where needed. Define space-efficiency to mean the asymptotic number of blocks consumed per stored record in the limit $n \\to \\infty$.\n\nStarting only from the definitions of node contents and the block capacity constraint, and the standard counting identity for full rooted trees that if every internal node has exactly $g$ children then the number of internal nodes equals $(L - 1)/(g - 1)$ where $L$ is the number of leaves, derive a single symbolic expression $\\Delta(k,p,d,B)$ such that:\n\n- If $\\Delta(k,p,d,B)  0$, then the B$+$ tree is more space-efficient than the B-tree (fewer blocks per record asymptotically).\n- If $\\Delta(k,p,d,B)  0$, then the B-tree is more space-efficient.\n- If $\\Delta(k,p,d,B) = 0$, then they are asymptotically tied.\n\nExpress your final answer as a single closed-form analytic expression in terms of $k$, $p$, $d$, and $B$ using only algebraic operations and the floor function. Do not include $n$ in your final expression. No numerical evaluation is required for this problem. The final answer must be a single expression; do not present an inequality or an equation to be solved.", "solution": "The user wants me to validate the problem statement and, if it is valid, to provide a detailed, reasoned solution.\n\n### Step 1: Problem Validation\n\n**1.1. Extraction of Givens:**\n- Data records: $n$ records, each with a key of size $k$ and data of size $d$. All sizes are in bytes.\n- Disk block size: $B$ bytes.\n- Pointer size: $p$ bytes.\n- B-tree structure:\n    - Internal nodes: Contain child pointers and actual records (key+data).\n    - Leaf nodes: Contain only records.\n    - No sibling pointers.\n- B+ tree structure:\n    - Internal nodes: Contain separator keys and child pointers (no data).\n    - Leaf nodes: Contain records and one right-sibling pointer of size $p$.\n- Fullness assumption: All nodes are perfectly full.\n- Basic feasibility assumptions: $B  p + k + d$, $B  p + k$, and $B  k + d$, ensuring occupancies and fanouts are at least 2 where necessary.\n- Definition of space-efficiency: Asymptotic number of blocks consumed per stored record in the limit $n \\to \\infty$.\n- Counting identity: For a full tree where every internal node has fanout $g$, the number of internal nodes is given by $N_{int} = (L - 1)/(g - 1)$, where $L$ is the number of leaves.\n- Objective: Derive an expression $\\Delta(k,p,d,B)$ such that its sign indicates which tree is more space-efficient. $\\Delta  0$ implies the B+ tree is more efficient (fewer blocks per record).\n\n**1.2. Validation using Extracted Givens:**\n- **Scientific Grounding**: The problem is well-grounded in the theory of data structures, specifically the analysis of B-trees and B+ trees. The model, though idealized (perfectly full nodes), is a standard approach for asymptotic analysis.\n- **Well-Posedness**: The problem is well-posed. The parameters are clearly defined, and the objective is to derive a specific symbolic expression. The asymptotic analysis for $n \\to \\infty$ is a standard technique that leads to a unique, stable result independent of the specific number of records.\n- **Objectivity**: The problem is stated in precise, objective language.\n- **Flaw Check**:\n    1. **Scientific Unsoundness**: No violations. The definitions of the tree structures, while specific, are consistent and plausible variants of standard B-tree family structures.\n    2. **Non-Formalizable**: The problem is fully formalizable.\n    3. **Incomplete/Contradictory**: The problem is self-contained. The \"perfectly full\" assumption and explicit node definitions provide all necessary information. The provided assumptions like $B  p+k+d$ and that fanouts are at least $2$ prevent trivial or ill-defined cases.\n    4. **Unrealistic**: The assumption of perfectly full nodes is an idealization but is standard for this type of theoretical analysis.\n    5. **Ill-Posed**: The problem is well-structured and leads to a unique solution.\n    6. **Trivial/Tautological**: The derivation is non-trivial, requiring careful calculation of node capacities and application of asymptotic analysis.\n    7. **Unverifiable**: The result is mathematically derivable and verifiable.\n\n**1.3. Verdict:**\nThe problem is valid.\n\n### Step 2: Solution Derivation\n\nThe goal is to find an expression $\\Delta(k, p, d, B)$ such that its sign compares the space-efficiency of a B-tree and a B+ tree. Space-efficiency is defined as the asymptotic number of blocks per record, which we denote by $S$. A lower value of $S$ is better. The problem requires that if $\\Delta  0$, the B+ tree is more efficient, meaning $S_{B+}  S_B$. Therefore, we define $\\Delta = S_B - S_{B+}$.\n\nFirst, we derive the space-efficiency $S_B$ for the B-tree.\nAn internal B-tree node with fanout $m$ contains $m$ child pointers and $m-1$ records (key-data pairs). Under the \"perfectly full\" assumption, the node occupies a full block of size $B$. The number of pointers $m$ is maximized subject to the constraint:\n$$m \\cdot p + (m-1)(k+d) \\leq B$$\n$$m(p+k+d) \\leq B+k+d$$\nThe maximum fanout, which is the fanout $g_B$ for all internal nodes, is:\n$$g_B = \\left\\lfloor \\frac{B+k+d}{p+k+d} \\right\\rfloor$$\nA full internal node stores $g_B - 1$ records.\n\nA B-tree leaf node contains only records. A full leaf node contains $c_B$ records, where $c_B$ is maximized subject to:\n$$c_B(k+d) \\leq B$$\n$$c_B = \\left\\lfloor \\frac{B}{k+d} \\right\\rfloor$$\n\nLet $L_B$ be the number of leaf nodes and $N_{int,B}$ be the number of internal nodes. The total number of blocks is $N_{total,B} = N_{int,B} + L_B$. For a large tree, the given identity $N_{int,B} = (L_B - 1)/(g_B - 1)$ approximates to $N_{int,B} \\approx L_B / (g_B - 1)$.\nThe total number of records $n_B$ is the sum of records in internal nodes and leaf nodes:\n$$n_B = N_{int,B}(g_B - 1) + L_B \\cdot c_B \\approx \\frac{L_B}{g_B - 1}(g_B - 1) + L_B \\cdot c_B = L_B(1+c_B)$$\nThe total number of blocks is:\n$$N_{total,B} = N_{int,B} + L_B \\approx \\frac{L_B}{g_B - 1} + L_B = L_B \\left( \\frac{1}{g_B - 1} + 1 \\right) = L_B \\frac{g_B}{g_B - 1}$$\nThe asymptotic space-efficiency $S_B$ (blocks per record) is the ratio $\\frac{N_{total,B}}{n_B}$ as $n_B \\to \\infty$ (which implies $L_B \\to \\infty$):\n$$S_B = \\lim_{L_B\\to\\infty} \\frac{L_B \\frac{g_B}{g_B - 1}}{L_B(1+c_B)} = \\frac{g_B}{(g_B - 1)(1+c_B)}$$\n\nNext, we derive the space-efficiency $S_{B+}$ for the B+ tree.\nAn internal B+ tree node with fanout $m$ contains $m$ pointers and $m-1$ separator keys. The constraint is:\n$$m \\cdot p + (m-1)k \\leq B$$\n$$m(p+k) \\leq B+k$$\nThe maximum fanout $g_{B+}$ is:\n$$g_{B+} = \\left\\lfloor \\frac{B+k}{p+k} \\right\\rfloor$$\nA full internal node stores $0$ data records.\n\nA B+ tree leaf node contains records and one sibling pointer. A full leaf contains $c_{B+}$ records, where $c_{B+}$ is maximized subject to:\n$$c_{B+}(k+d) + p \\leq B$$\n$$c_{B+} = \\left\\lfloor \\frac{B-p}{k+d} \\right\\rfloor$$\n\nIn a B+ tree, all records are in the leaves. Let $L_{B+}$ be the number of leaves. The total number of records is $n_{B+} = L_{B+} \\cdot c_{B+}$.\nThe number of internal nodes is $N_{int,B+} \\approx L_{B+} / (g_{B+} - 1)$.\nThe total number of blocks is $N_{total,B+} = N_{int,B+} + L_{B+} \\approx L_{B+} \\frac{g_{B+}}{g_{B+} - 1}$.\nThe asymptotic space-efficiency $S_{B+}$ is:\n$$S_{B+} = \\lim_{L_{B+}\\to\\infty} \\frac{L_{B+} \\frac{g_{B+}}{g_{B+} - 1}}{L_{B+} \\cdot c_{B+}} = \\frac{g_{B+}}{(g_{B+} - 1)c_{B+}}$$\n\nFinally, we construct the expression for $\\Delta(k,p,d,B) = S_B - S_{B+}$:\n$$\\Delta(k,p,d,B) = \\frac{g_B}{(g_B - 1)(1+c_B)} - \\frac{g_{B+}}{(g_{B+} - 1)c_{B+}}$$\nSubstituting the expressions for $g_B$, $c_B$, $g_{B+}$, and $c_{B+}$:\n$$\\Delta(k,p,d,B) = \\frac{\\left\\lfloor \\frac{B+k+d}{p+k+d} \\right\\rfloor}{\\left(\\left\\lfloor \\frac{B+k+d}{p+k+d} \\right\\rfloor - 1\\right)\\left(\\left\\lfloor \\frac{B}{k+d} \\right\\rfloor + 1\\right)} - \\frac{\\left\\lfloor \\frac{B+k}{p+k} \\right\\rfloor}{\\left(\\left\\lfloor \\frac{B+k}{p+k} \\right\\rfloor - 1\\right) \\left\\lfloor \\frac{B-p}{k+d} \\right\\rfloor}$$\nThe problem assumptions ensure that all denominators in this expression are non-zero. For instance, the assumption that fanouts are at least $2$ ensures that $\\lfloor \\dots \\rfloor - 1 \\neq 0$.\n\nThis is the final expression for $\\Delta(k,p,d,B)$.", "answer": "$$\n\\boxed{\n\\frac{\\left\\lfloor \\frac{B+k+d}{p+k+d} \\right\\rfloor}{\\left(\\left\\lfloor \\frac{B+k+d}{p+k+d} \\right\\rfloor - 1\\right)\\left(\\left\\lfloor \\frac{B}{k+d} \\right\\rfloor + 1\\right)} - \\frac{\\left\\lfloor \\frac{B+k}{p+k} \\right\\rfloor}{\\left(\\left\\lfloor \\frac{B+k}{p+k} \\right\\rfloor - 1\\right) \\left\\lfloor \\frac{B-p}{k+d} \\right\\rfloor}\n}\n$$", "id": "3212355"}, {"introduction": "Theory comes to life through implementation. In this hands-on coding challenge [@problem_id:3212331], you will not only build a B+ tree from the ground up but also implement an advanced \"finger search\" optimization. This exercise highlights the practical power of the B+ tree's leaf-level linked list, demonstrating how it can dramatically accelerate searches that exhibit locality of reference.", "problem": "You are to implement a B$+$ tree that supports insertion, a baseline search, and a \"finger search\" that leverages the leaf-level linked list to accelerate searches near a recent result. The implementation must be guided from the following foundational base and core definitions without relying on shortcuts.\n\nStart from the following fundamental laws and core definitions for balanced multiway search trees that are standard in data structures and algorithms:\n\n1. A B-tree of order $b$ is a rooted tree in which every internal node has between $\\lceil b/2 \\rceil$ and $b$ children, except possibly the root, and stores between $\\lceil b/2 \\rceil - 1$ and $b - 1$ separator keys, with all leaves at the same depth.\n2. A B$+$ tree modifies the B-tree so that all search keys and associated records reside in the leaves, while internal nodes store only separator keys and pointers. Leaves form a linked list via \"next\" pointers (and optionally \"previous\" pointers), providing order-preserving sequential access.\n3. In a B$+$ tree with maximum children $b$, each internal node stores at most $b - 1$ keys and exactly one fewer keys than its number of children. Each leaf stores at most $b - 1$ keys. When a node overflows, it splits into two nodes and a separator key is promoted into the parent. When the parent overflows, it recursively splits up to the root, potentially increasing the tree height by $1$.\n\nYou must implement the following operations on a B$+$ tree with parameter $b$:\n\n- Insertion $\\text{insert}(k)$: insert a key $k$ into the tree while maintaining all B$+$ tree invariants described above, including leaf-level linkage and separator promotion on split.\n- Baseline search $\\text{standard\\_search}(k)$: starting at the root, navigate down internal nodes (each decision based on separator keys) to reach the leaf that would contain $k$; report whether $k$ is present. Count node accesses as follows: every internal node visited counts as $1$ and the final leaf visited counts as $1$.\n- Finger search $\\text{finger\\_search}(k)$: given a current \"finger\" pointing to a leaf node (or `None` initially), attempt to locate the leaf containing $k$ by scanning leaf-level pointers. Specifically, start at the finger leaf; if $k$ lies within the range from the smallest to largest key stored in that leaf, use that leaf. Otherwise, move left via the previous pointer while $k$ is smaller than the smallest key of the current leaf, or move right via the next pointer while $k$ is larger than the largest key of the current leaf, counting each leaf visited as $1$. If the finger is `None`, fall back to the baseline search. After each query, update the finger to the leaf where the search concluded (the leaf containing $k$ if present, otherwise the leaf where the search would place $k$).\n- For both $\\text{standard\\_search}(k)$ and $\\text{finger\\_search}(k)$, you must measure \"node accesses\" as the sum of internal nodes and leaves visited. In $\\text{standard\\_search}(k)$, this equals the number of internal nodes on the root-to-leaf path plus $1$ for the leaf. In $\\text{finger\\_search}(k)$, this equals the number of leaves traversed starting from the finger leaf, plus $0$ internal nodes, unless the finger is `None` in which case it uses the standard search.\n\nYour program must build a B$+$ tree per test case, run a sequence of queries both by the baseline search and by the finger search (with the evolving finger as specified), and aggregate the difference in node accesses over the query sequence for each test case:\n$$\nD \\;=\\; \\sum_{q \\in Q} \\left( c_{\\text{std}}(q) \\;-\\; c_{\\text{finger}}(q) \\right),\n$$\nwhere $Q$ is the sequence of queries, $c_{\\text{std}}(q)$ is the node access count under $\\text{standard\\_search}(q)$, and $c_{\\text{finger}}(q)$ is the node access count under $\\text{finger\\_search}(q)$. A positive $D$ indicates that finger search performed fewer node accesses in aggregate; a negative $D$ indicates worse performance than the baseline.\n\nTest Suite:\nYou must hard-code the following test cases, each specified by $(b, K, Q)$ where $b$ is the maximum number of children per internal node, $K$ is the sequence of keys to insert, and $Q$ is the sequence of search queries. All keys are integers in ascending order for $K$ but may be arbitrary for $Q$.\n\n- Test case $1$: $b = 4$, $K = [\\,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32\\,]$, $Q = [\\,6,7,8,9,10\\,]$.\n- Test case $2$: $b = 4$, $K = [\\,1,2,3,\\dots,64\\,]$ (that is, all integers from $1$ through $64$), $Q = [\\,5,60,4,58\\,]$.\n- Test case $3$: $b = 3$, $K = [\\,10,20,30,40,50,60\\,]$, $Q = [\\,35,30,25,10,5\\,]$.\n- Test case $4$: $b = 5$, $K = [\\,5,15,25,35,45,55,65,75,85,95\\,]$, $Q = [\\,75,76,77,78,80,85\\,]$.\n\nFor each test case, construct the tree using the specified $b$ and insert all keys in $K$ in sequence. Then process each query $q$ in $Q$ by computing $c_{\\text{std}}(q)$ via $\\text{standard\\_search}(q)$ and $c_{\\text{finger}}(q)$ via $\\text{finger\\_search}(q)$, updating the finger as described, and accumulate the difference $D$.\n\nAnswer Specification:\nYour program must produce a single line of output containing the values $D$ for the four test cases as a comma-separated list enclosed in square brackets, in the order the test cases are given. For example, a valid format is [$d_1$,$d_2$,$d_3$,$d_4$], where each $d_i$ is an integer.\n\nThere are no physical units, angles, or percentages involved in this problem. The outputs are integers and must be printed exactly in the specified list format on a single line.", "solution": "The user's request is to implement a B$+$ tree with specific insertion and search functionalities, then use it to evaluate the performance difference between a standard top-down search and a \"finger\" search that leverages the leaf-level linked list. The problem is well-defined, scientifically grounded in the theory of data structures, and provides sufficient detail to construct a deterministic solution. It is therefore deemed a valid problem.\n\n### I. Data Structure Design\n\nA B$+$ tree will be implemented using a set of classes to represent the nodes and the tree itself, adhering to the provided definitions.\n\n1.  **`BPlusTreeNode`**: A base class for all nodes, containing a list of `keys` and a reference to a `parent` node.\n2.  **`BPlusTreeInternalNode`**: A subclass for internal nodes. It inherits from `BPlusTreeNode` and adds a list of `children` pointers. Internal nodes store separator keys to guide searches.\n3.  **`BPlusTreeLeafNode`**: A subclass for leaf nodes. It also inherits from `BPlusTreeNode` and stores all data keys. Crucially, it contains `prev_leaf` and `next_leaf` pointers to form the doubly-linked list at the leaf level, enabling sequential traversal for the finger search.\n4.  **`BPlusTree`**: The main class that encapsulates the tree structure. It holds a reference to the `root` node, the order parameter $b$, and the `finger` pointer, which is a reference to a `BPlusTreeLeafNode` used in `finger_search`.\n\n### II. Algorithmic Implementation\n\nThe operations are implemented based on standard B$+$ tree algorithms, refined to match the problem's specifications.\n\n#### Insertion (`insert(k)`)\nInsertion follows a two-phase process:\n1.  **Search Phase**: Traverse the tree from the root to find the appropriate leaf node where the key $k$ should be inserted. This traversal is identical to a standard search.\n2.  **Insertion and Splitting Phase**:\n    a. The key $k$ is inserted into the sorted `keys` list of the target leaf.\n    b. If the leaf node's capacity is exceeded (i.e., it holds $b$ keys), it must be split. The leaf's keys are divided into two sets. The first $\\lfloor b/2 \\rfloor$ keys remain in the original leaf, and the remaining keys form a new leaf node. The first key of the new leaf is \"copied up\" to be inserted into the parent internal node as a new separator. The new leaf is integrated into the leaf-level linked list.\n    c. The insertion of the separator key into the parent node is a recursive process. If the parent internal node also overflows (i.e., it has more than $b$ children), it too is split. For an internal node with $b$ keys (and $b+1$ children), the key at index $\\lceil b/2 \\rceil - 1$ is \"pushed up\" to its parent, and the remaining keys and children are distributed between the original node and a new internal node. This process can propagate up to the root. If the root itself splits, a new root is created, and the tree's height increases by one.\n\n#### Standard Search (`standard_search(k)`)\nThis is a straightforward top-down search.\n1.  Start at the `root`.\n2.  If the current node is internal, compare the search key $k$ with the node's separator keys to determine which child pointer to follow. Each internal node visited adds $1$ to the access cost.\n3.  Repeat until a leaf node is reached. The leaf visit adds a final $1$ to the cost. The total cost is thus the height of the tree. The search concludes at the leaf that either contains $k$ or would contain $k$ if it existed.\n\n#### Finger Search (`finger_search(k)`)\nThis search leverages the \"locality of reference\" principle, assuming subsequent searches might be near the location of a previous search.\n1.  A `finger` points to the leaf where the last search concluded. If the `finger` is `None` (e.g., for the first query), the search defaults to `standard_search`.\n2.  If a `finger` exists, the search begins at the leaf it points to. The access cost starts at $1$.\n3.  If $k$ is not within the key range of the current leaf, the search traverses the leaf-level linked list.\n    - If $k$ is smaller than the smallest key in the current leaf, the search moves leftward using the `prev_leaf` pointer.\n    - If $k$ is larger than the largest key in the current leaf, the search moves rightward using the `next_leaf` pointer.\n4.  Each leaf traversed (including the start and end leaves) adds $1$ to the access cost. The traversal stops when the current leaf is one where $k$ is no longer strictly outside its bounds, as per the problem's specified stopping condition.\n5.  After any search (`standard_search` or `finger_search`), the `finger` is updated to point to the leaf where that search terminated.\n\n### III. Execution and Calculation\n\nFor each test case $(b, K, Q)$, the program first constructs the B$+$ tree by sequentially inserting all keys from the list $K$. Then, for each query key $q$ in the list $Q$, it performs both a `standard_search` and a `finger_search`. The node access costs, $c_{\\text{std}}(q)$ and $c_{\\text{finger}}(q)$, are recorded. The difference, $c_{\\text{std}}(q) - c_{\\text{finger}}(q)$, is accumulated into a total difference $D$. The `finger` is updated after each query. The final list of $D$ values for all test cases constitutes the solution.\n\nThe implementation relies on Python's `bisect` module for efficient searching within the sorted key lists of the nodes.", "answer": "```python\nimport bisect\nimport math\nimport numpy as np\n\nclass BPlusTreeNode:\n    \"\"\"Base class for B+ Tree nodes.\"\"\"\n    def __init__(self, parent=None, is_leaf=False):\n        self.parent = parent\n        self.keys = []\n        self.is_leaf = is_leaf\n\nclass BPlusTreeInternalNode(BPlusTreeNode):\n    \"\"\"Internal node for a B+ Tree.\"\"\"\n    def __init__(self, parent=None):\n        super().__init__(parent, is_leaf=False)\n        self.children = []\n\n    def find_child(self, key):\n        \"\"\"Find the child to follow for a given key.\"\"\"\n        idx = bisect.bisect_right(self.keys, key)\n        return self.children[idx]\n\nclass BPlusTreeLeafNode(BPlusTreeNode):\n    \"\"\"Leaf node for a B+ Tree.\"\"\"\n    def __init__(self, parent=None):\n        super().__init__(parent, is_leaf=True)\n        self.prev_leaf = None\n        self.next_leaf = None\n\nclass BPlusTree:\n    \"\"\"\n    B+ Tree implementation supporting insertion and two search methods.\n    \n    Attributes:\n        b (int): Maximum number of children for internal nodes.\n        root (BPlusTreeNode): The root of the tree.\n        finger (BPlusTreeLeafNode): Pointer to the last accessed leaf for finger search.\n    \"\"\"\n    def __init__(self, b):\n        if b  3:\n            raise ValueError(\"B-Tree order b must be at least 3\")\n        self.b = b\n        self.root = BPlusTreeLeafNode()\n        self.finger = None\n\n    def _find_leaf(self, key):\n        \"\"\"Traverse to a leaf, counting node accesses.\"\"\"\n        node = self.root\n        cost = 0\n        while not node.is_leaf:\n            cost += 1\n            node = node.find_child(key)\n        cost += 1  # For the leaf itself\n        return node, cost\n\n    def _find_leaf_no_cost(self, key):\n        \"\"\"Traverse to a leaf without counting cost.\"\"\"\n        node = self.root\n        while not node.is_leaf:\n            node = node.find_child(key)\n        return node\n\n    def insert(self, key):\n        \"\"\"Insert a key into the B+ tree.\"\"\"\n        leaf = self._find_leaf_no_cost(key)\n        \n        # Avoid duplicates for simplicity as per implicit problem setup\n        if key in leaf.keys:\n            return\n\n        bisect.insort_left(leaf.keys, key)\n\n        # A leaf overflows if it has b keys.\n        if len(leaf.keys) == self.b:\n            self._split_leaf(leaf)\n\n    def _split_leaf(self, leaf):\n        \"\"\"Split a full leaf node.\"\"\"\n        mid_idx = self.b // 2\n        \n        new_leaf = BPlusTreeLeafNode(parent=leaf.parent)\n        new_leaf.keys = leaf.keys[mid_idx:]\n        leaf.keys = leaf.keys[:mid_idx]\n\n        new_leaf.next_leaf = leaf.next_leaf\n        if leaf.next_leaf:\n            leaf.next_leaf.prev_leaf = new_leaf\n        leaf.next_leaf = new_leaf\n        new_leaf.prev_leaf = leaf\n        \n        promotion_key = new_leaf.keys[0]\n        self._insert_in_parent(leaf, promotion_key, new_leaf)\n\n    def _insert_in_parent(self, left_child, key, right_child):\n        \"\"\"Recursively insert a key and a new child into a parent node.\"\"\"\n        parent = left_child.parent\n        if parent is None:\n            new_root = BPlusTreeInternalNode()\n            new_root.keys = [key]\n            new_root.children = [left_child, right_child]\n            left_child.parent = new_root\n            right_child.parent = new_root\n            self.root = new_root\n            return\n\n        idx = bisect.bisect_left(parent.keys, key)\n        parent.keys.insert(idx, key)\n        parent.children.insert(idx + 1, right_child)\n        right_child.parent = parent\n        \n        # An internal node overflows if it has more than b children.\n        if len(parent.children)  self.b:\n            self._split_internal(parent)\n\n    def _split_internal(self, node):\n        \"\"\"Split a full internal node.\"\"\"\n        # For b children, there are b-1 keys. For b+1 children, b keys.\n        mid_idx = self.b // 2\n\n        promoted_key = node.keys[mid_idx]\n        \n        new_node = BPlusTreeInternalNode(parent=node.parent)\n        new_node.keys = node.keys[mid_idx + 1:]\n        new_node.children = node.children[mid_idx + 1:]\n        \n        node.keys = node.keys[:mid_idx]\n        node.children = node.children[:mid_idx + 1]\n\n        for child in new_node.children:\n            child.parent = new_node\n            \n        self._insert_in_parent(node, promoted_key, new_node)\n\n    def standard_search(self, key):\n        \"\"\"Perform a standard top-down search.\"\"\"\n        leaf, cost = self._find_leaf(key)\n        return leaf, cost\n\n    def finger_search(self, key):\n        \"\"\"Perform a finger search starting from the last accessed leaf.\"\"\"\n        if self.finger is None:\n            return self.standard_search(key)\n\n        current_leaf = self.finger\n        cost = 1\n\n        if not current_leaf.keys or key  current_leaf.keys[0]:\n            while current_leaf.prev_leaf and key  current_leaf.keys[0]:\n                current_leaf = current_leaf.prev_leaf\n                cost += 1\n        elif key  current_leaf.keys[-1]:\n            while current_leaf.next_leaf and key  current_leaf.keys[-1]:\n                current_leaf = current_leaf.next_leaf\n                cost += 1\n        \n        return current_leaf, cost\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute the performance difference D.\n    \"\"\"\n    test_cases = [\n        (4, list(range(1, 33)), [6, 7, 8, 9, 10]),\n        (4, list(range(1, 65)), [5, 60, 4, 58]),\n        (3, [10, 20, 30, 40, 50, 60], [35, 30, 25, 10, 5]),\n        (5, [5, 15, 25, 35, 45, 55, 65, 75, 85, 95], [75, 76, 77, 78, 80, 85]),\n    ]\n\n    results = []\n    for b, K, Q in test_cases:\n        tree = BPlusTree(b=b)\n        for key in K:\n            tree.insert(key)\n        \n        total_diff = 0\n        for q in Q:\n            # Standard search (finger is not updated by this)\n            std_leaf, c_std = tree.standard_search(q)\n            \n            # Finger search (uses and then updates finger)\n            finger_leaf, c_finger = tree.finger_search(q)\n            tree.finger = finger_leaf\n            \n            total_diff += (c_std - c_finger)\n            \n        results.append(total_diff)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3212331"}]}