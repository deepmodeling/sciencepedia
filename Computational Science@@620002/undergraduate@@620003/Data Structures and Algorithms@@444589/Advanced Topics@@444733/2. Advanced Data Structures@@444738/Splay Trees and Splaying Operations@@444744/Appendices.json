{"hands_on_practices": [{"introduction": "Before we can appreciate the amortized efficiency of splay trees, it is crucial to understand that a single operation can be costly. This exercise ([@problem_id:3269554]) challenges you to construct a scenario that leads to a linear-time splay operation, with a cost of $\\Omega(N)$. By deriving the exact number of rotations required, you will gain a concrete understanding of how `zig-zig` steps work on a degenerate tree structure and see why amortized analysis is necessary to justify the use of splay trees.", "problem": "A self-balancing Binary Search Tree (BST) is a binary search tree that performs structural adjustments during operations to maintain favorable height bounds without storing explicit balance information at each node. A splay tree is a canonical example: it performs a sequence of rotations called splaying to move an accessed node to the root. The fundamental primitives are single rotations and the three splay steps, defined on a node $x$ with parent $p$ and grandparent $g$: zig (applied when $x$ has no grandparent), zig-zig (applied when $x$ and $p$ are both left children or both right children), and zig-zag (applied when $x$ and $p$ are on opposite sides). Each rotation is a constant-time pointer rearrangement. Consider the following sequence of operations on a splay tree that uses the classical bottom-up splaying after inserts and searches, and has no duplicate keys:\n\n- Start with an empty tree.\n- Insert keys in strictly decreasing order $N,N-1,\\dots,2,1$, where after each insertion of a key $k$ the splay operation is immediately applied to $k$ (which is standard for splay tree insertion).\n- Then perform a search for the key $N$, applying the splay operation to $N$ at the end of the search.\n\nDerive, from first principles and the definitions of splay steps, the exact number of single rotations performed during the final search-and-splay of $N$ as a function of $N$. Express your final answer as a closed-form expression in $N$. No rounding is required and no units are involved. Your derivation must begin from the BST property and the splay step definitions (zig, zig-zig, zig-zag), and must not appeal to unproven shortcuts about splay tree amortized bounds. The correctness of the sequence shape prior to the final search must be justified using these primitives and the BST order properties. The final answer must be a single analytic expression in $N$.", "solution": "The problem requires the derivation of the exact number of single rotations performed during the search and subsequent splay of the key $N$ in a splay tree, following a specific sequence of insertions. The derivation must be from first principles.\n\nThe solution is divided into two main parts. First, we determine the precise structure of the splay tree after the specified insertion sequence. Second, we analyze the search for $N$ and the splaying of node $N$ based on this structure to count the rotations.\n\n**Part 1: Determining the Structure of the Splay Tree**\n\nThe initial state is an empty tree. The keys $N, N-1, \\dots, 2, 1$ are inserted in sequence. After each insertion of a key $k$, the node containing $k$ is splayed to the root.\n\nWe will prove by induction that after inserting the keys $N, N-1, \\dots, k$ (for $1 \\le k \\le N$), the resulting tree is a right-leaning chain (a \"stick\") with root $k$. The nodes in the tree are $\\{k, k+1, \\dots, N\\}$, and for any node $i$ in this set where $i < N$, its right child is $i+1$ and its left child is null.\n\n**Base Case:** The first key inserted is $N$.\n- The tree contains a single node, $N$. Splaying this node has no effect as it is already the root.\n- The tree is a right-leaning chain of length $1$ with root $N$. The proposition holds for $k=N$.\n\n**Inductive Hypothesis:** Assume that after inserting the keys $N, N-1, \\dots, k+1$, the tree is a right-leaning chain with root $k+1$. The structure is:\n$$(k+1) \\rightarrow_R (k+2) \\rightarrow_R \\dots \\rightarrow_R N$$\nwhere $\\rightarrow_R$ denotes a right-child link.\n\n**Inductive Step:** We now insert the key $k$.\n1.  According to the Binary Search Tree (BST) property, to insert $k$, we start at the root, which is $k+1$. Since $k < k+1$, we must proceed to the left.\n2.  The root $k+1$ has no left child under the inductive hypothesis. Thus, the new node $k$ is inserted as the left child of $k+1$.\n3.  The tree structure immediately after insertion, but before splaying $k$, is a root $k+1$ with a left child $k$ and its original right subtree.\n4.  The next step is to splay the newly inserted node $k$. Node $k$ has parent $p = k+1$. The parent $p$ is the root of the tree, so $k$ has no grandparent.\n5.  According to the definition of splay steps, when the node to be splayed ($x=k$) has a parent but no grandparent, a **Zig** step is performed. This consists of a single rotation that makes $x$ the new root.\n6.  In this case, $k$ is a left child of $k+1$. A single right rotation is performed on the edge between $k+1$ and $k$.\n7.  After the rotation, $k$ becomes the new root. Its former parent, $k+1$, becomes the right child of $k$. The original right subtree of $k$ (which was null) becomes the left child of $k+1$. The original right subtree of $k+1$ remains its right subtree.\n8.  The resulting tree has root $k$, whose right child is $k+1$, whose right child is $k+2$, and so on. The structure is:\n$$k \\rightarrow_R (k+1) \\rightarrow_R (k+2) \\rightarrow_R \\dots \\rightarrow_R N$$\nThis is a right-leaning chain with root $k$. The induction is complete.\n\nBy this inductive argument, after inserting all keys from $N$ down to $1$, the final structure of the tree (for $k=1$) is a right-leaning chain with root $1$:\n$$1 \\rightarrow_R 2 \\rightarrow_R 3 \\rightarrow_R \\dots \\rightarrow_R (N-1) \\rightarrow_R N$$\n\n**Part 2: Analyzing the Final Search and Splay Operation**\n\nThe final operation is to search for the key $N$ and then splay its node to the root.\n\n**Search Path:**\n- The search for $N$ begins at the root, which is the node with key $1$.\n- Since $N > 1$, we traverse to the right child, which is node $2$.\n- Since $N > 2$, we traverse to the right child, node $3$.\n- This process continues down the right-leaning chain until we reach the node with key $N$.\n- The path of traversal is $1 \\rightarrow 2 \\rightarrow \\dots \\rightarrow N$.\n- The depth of a node is the number of edges on the path from the root to that node. The path to $N$ has $N-1$ edges. Therefore, the depth of node $N$ is $d = N-1$.\n\n**Splay Operation:**\nWe now splay the node $N$ from its position at depth $d=N-1$. The path from the root to $N$ consists entirely of right-child links. Let $x$ be the node being splayed, initially $x=N$.\n\n- Any time $x$ has a grandparent $g$, its parent is $p$. In our tree, $x$ is the right child of $p$, and $p$ is the right child of $g$. This configuration calls for a **Zig-Zig** step.\n- A Zig-Zig step consists of two single rotations. It has the effect of moving $x$ up by two levels in the tree, replacing its grandparent.\n\n- The splay process on a node at depth $d$ on a straight path proceeds as follows:\n  1.  Repeatedly apply the Zig-Zig step as long as the node has a grandparent. Each Zig-Zig step costs $2$ rotations and reduces the node's depth by $2$. The number of Zig-Zig steps possible is $\\lfloor d/2 \\rfloor$.\n  2.  Total rotations from these steps: $2 \\times \\lfloor d/2 \\rfloor$.\n  3.  After these steps, the remaining depth of the node is $d_{rem} = d - 2 \\times \\lfloor d/2 \\rfloor$. This is equivalent to $d \\pmod 2$.\n  4.  If $d_{rem} = 1$ (which occurs if and only if $d$ is odd), the node is now a child of the root. It has a parent but no grandparent. A final **Zig** step is required. A Zig step costs $1$ rotation and makes the node the root.\n  5.  If $d_{rem} = 0$ (which occurs if and only if $d$ is even), the node has become the root, and the operation is complete.\n\nThe total number of single rotations is the sum of rotations from all Zig-Zig steps and the final Zig step (if any).\nTotal Rotations $= (2 \\times \\text{number of Zig-Zig steps}) + (1 \\times \\text{number of Zig steps})$\nTotal Rotations $= 2 \\times \\lfloor d/2 \\rfloor + (d \\pmod 2)$.\n\nFor any non-negative integer $d$, the expression $2 \\lfloor d/2 \\rfloor + (d \\pmod 2)$ is identically equal to $d$.\n- If $d$ is even, $d=2k$ for some integer $k \\ge 0$. The expression becomes $2 \\times \\lfloor 2k/2 \\rfloor + (2k \\pmod 2) = 2 \\times k + 0 = 2k = d$.\n- If $d$ is odd, $d=2k+1$ for some integer $k \\ge 0$. The expression becomes $2 \\times \\lfloor (2k+1)/2 \\rfloor + ((2k+1) \\pmod 2) = 2 \\times k + 1 = 2k+1 = d$.\n\nSo, the total number of rotations to splay a node from a straight-line path of depth $d$ is exactly $d$.\n\nIn our problem, the node to be splayed is $N$, and its depth is $d = N-1$.\nSubstituting this into our result, the total number of single rotations is $N-1$.\n\nThis holds for all $N \\ge 1$.\n- If $N=1$, the tree is just node $1$. The search finds it at the root (depth $d=0$). The number of rotations is $0$. Our formula gives $1-1=0$.\n- If $N>1$, the depth $d=N-1 \\ge 1$, and the derived count holds.\n\nTherefore, the exact number of single rotations performed during the final search-and-splay of $N$ is $N-1$.", "answer": "$$\\boxed{N-1}$$", "id": "3269554"}, {"introduction": "While individual operations can be slow, splay trees often perform well on sequences of accesses due to their self-adjusting nature. This practice ([@problem_id:3273374]) explores one of the most fundamental access patterns: sequential access. Starting from a degenerate tree structure, you will analyze the total cost of accessing every element in order, revealing how the tree dynamically adapts to this pattern and achieves remarkable overall efficiency.", "problem": "Consider an initially fixed Binary Search Tree (BST) containing the keys $1,2,3,\\dots,n$ arranged as a strictly right-leaning path: the root is the key $1$, and for each $i \\in \\{1,2,\\dots,n-1\\}$, the node with key $i$ has no left child and its right child is the node with key $i+1$. Assume the standard bottom-up splaying operation is applied after each successful access in the Splay Tree: for a node $x$ with parent $p$ and grandparent $g$, the splay operation consists of repeated rotations classified as follows until $x$ becomes the root:\n- a single rotation ($\\text{zig}$) when $p$ is the root;\n- two rotations ($\\text{zig-zig}$) when $x$ and $p$ are both left children or both right children of their respective ancestors (same-side case);\n- two rotations ($\\text{zig-zag}$) when $x$ and $p$ are on opposite sides (opposite-side case).\nEach rotation counts as one unit in the total rotation count.\n\nYou perform a full sequential access of the keys in increasing order, i.e., you access the sequence $(1,2,3,\\dots,n)$, and after each successful access, you splay the accessed node to the root using the above rules.\n\nStarting only from the fundamental definitions of BST ordering and bottom-up splaying rotations, derive the exact closed-form expression, in terms of $n$, for the total number of rotations executed over the entire sequence of $n$ accesses. Express your final answer as an exact symbolic expression in $n$ with no inequalities. No rounding is required.", "solution": "Let's denote the initial tree as $T_0$. According to the problem statement, $T_0$ is a strictly right-leaning path. The root is the node with key $1$. The right child of node $i$ is node $i+1$ for $i \\in \\{1, 2, \\dots, n-1\\}$. The node with key $n$ is a leaf. Let $C_k$ be the number of rotations performed when splaying the key $k$. The total number of rotations is $C_{total} = \\sum_{k=1}^{n} C_k$.\n\nLet's analyze the sequence of accesses and splaying operations step by step.\n\n**Step 1: Access key $k=1$**\nThe access is on key $1$. In the initial tree $T_0$, the node with key $1$ is the root. The splaying operation on the root node does nothing. Therefore, the number of rotations is $C_1 = 0$.\nThe tree structure remains unchanged. Let's call the tree after this step $T_1$. So, $T_1$ is identical to $T_0$.\n\n**Step 2: Access key $k=2$**\nThe access is on key $2$. We are working with the tree $T_1$. In $T_1$, the node with key $2$ is the right child of the root (key $1$).\nThe node to be splayed is $x=2$. Its parent is $p=1$. Since the parent $p$ is the root of the tree, this situation corresponds to a `zig` operation. A `zig` operation consists of a single rotation. Since $x$ is a right child, a single left rotation is performed on the edge between $p$ and $x$.\nThis single rotation costs $1$ unit. So, $C_2 = 1$.\nAfter the left rotation at node $1$, node $2$ becomes the new root. Node $1$ becomes the left child of node $2$. The original right subtree of node $2$, which was the path $3 \\to 4 \\to \\dots \\to n$, remains as the right subtree of the new root $2$.\nThe resulting tree, $T_2$, has root $2$, left child $1$, and right child $3$ (which is the root of the right-leaning path $3 \\to \\dots \\to n$).\n\n**Step 3: Access key $k=3$**\nThe access is on key $3$. We are working with the tree $T_2$. In $T_2$, the node with key $3$ is the right child of the root (key $2$).\nThe node to be splayed is $x=3$. Its parent is $p=2$. Since the parent $p$ is the root, this is again a `zig` operation. It involves a single left rotation on the edge between $p$ and $x$.\nThe number of rotations is $C_3 = 1$.\nAfter the left rotation at node $2$, node $3$ becomes the new root. Node $2$ (with its left subtree rooted at $1$) becomes the left child of node $3$. The original right subtree of node $3$ (the path $4 \\to \\dots \\to n$) remains as the right subtree of the new root $3$.\nThe resulting tree, $T_3$, has root $3$. Its left subtree is rooted at $2$, which has a left child $1$. Its right subtree is the path $4 \\to \\dots \\to n$.\n\n**Generalizing the Process**\nWe can observe a pattern. Let's formulate an inductive hypothesis for $k \\ge 2$.\nHypothesis: At the beginning of the access for key $k$, the tree $T_{k-1}$ (the state after splaying key $k-1$) has the key $k-1$ as its root. The key $k$ is the right child of the root.\n\nBase Case ($k=2$): We established that for the access on key $2$, the tree is $T_1$, where the root is $1$ and its right child is $2$. The hypothesis holds.\n\nInductive Step: Assume the hypothesis is true for some integer $k \\ge 2$. That is, just before accessing key $k$, the tree $T_{k-1}$ has root $k-1$ and its right child is $k$.\nNow, we perform the access on key $k$.\nThe node to be splayed is $x=k$. Its parent is $p=k-1$. Since the parent $p$ is the root of $T_{k-1}$, the splay operation is a `zig` step, which consists of a single rotation. Thus, the cost is $C_k = 1$.\nA left rotation is performed at the root $k-1$. This makes $k$ the new root. The old root $k-1$ becomes the left child of $k$. The original right subtree of $k$ remains its right subtree. In tree $T_{k-1}$, the right child of $k$ was $k+1$. So, in the new tree $T_k$, $k$ is the root and its right child is $k+1$.\nThis configuration matches the hypothesis for the next step, $k+1$. Thus, the inductive hypothesis holds for all $k \\in \\{2, 3, \\dots, n\\}$.\n\n**Calculating the Total Rotations**\nBased on this analysis, we can determine the cost for each access in the sequence $(1, 2, \\dots, n)$.\n- For $k=1$: The node $1$ is the root, so $C_1 = 0$ rotations.\n- For $k \\in \\{2, 3, \\dots, n\\}$: The node $k$ is always the right child of the root (which is $k-1$). The splay operation is a single `zig` step, which costs $1$ rotation. So, $C_k = 1$.\n\nThe total number of rotations, $C_{total}$, is the sum of the rotations for each access:\n$$C_{total} = \\sum_{k=1}^{n} C_k = C_1 + \\sum_{k=2}^{n} C_k$$\nSubstituting the costs we found:\n$$C_{total} = 0 + \\sum_{k=2}^{n} 1$$\nThe sum $\\sum_{k=2}^{n} 1$ contains $n-1$ terms, each equal to $1$.\n$$C_{total} = n-1$$\nThis is the exact closed-form expression for the total number of rotations.\nThe derived formula is consistent for small values of $n$.", "answer": "$$\n\\boxed{n-1}\n$$", "id": "3273374"}, {"introduction": "The true power of splay trees lies in their ability to adapt to the \"locality of reference\" in an access sequence, a property that static data structures cannot exploit. This final practice ([@problem_id:3273326]) moves from theoretical derivation to hands-on programming and empirical analysis. By implementing a splay tree and testing it against various access patterns—from highly structured to pseudo-random—you will directly observe how different kinds of locality affect performance and develop an intuition for when splay trees are most effective.", "problem": "You are given the task of constructing and evaluating a family of access permutations on an ordered set of keys using two search tree models: a static balanced Binary Search Tree (BST) and a Splay Tree with standard splaying operations. Binary Search Tree (BST) is defined as a rooted binary tree where an in-order traversal yields keys in sorted order; Splay Tree is a self-adjusting BST that, after each access, performs splaying rotations to move the accessed node to the root using the operations known as zig, zig-zig, and zig-zag. The fundamental base for reasoning must start from core definitions: a balanced BST has height $\\Theta(\\log n)$, so searching any key requires $\\Theta(\\log n)$ comparisons, while a Splay Tree performs rotations to dynamically reorganize itself, and its performance is governed by structural properties such as locality of reference and working set size. The goal is to construct a family of permutations where the static greedy search on a balanced BST achieves $O(m \\log n)$ in the unit-cost model while the Splay Tree empirically outperforms it; then hypothesize properties of the permutations causing this gap.\n\nFormally, consider the ordered set of keys $\\{1,2,\\dots,n\\}$ and an access sequence that is a permutation of these keys, so the number of accesses is $m=n$. Initialize two trees on the same set of keys:\n- A perfectly balanced BST built over $\\{1,2,\\dots,n\\}$ via median recursion, which remains static throughout all accesses.\n- A Splay Tree initialized to the same perfectly balanced structure, which performs standard splaying rotations (zig, zig-zig, zig-zag) to move the accessed node to the root after each access.\n\nUse the following unit-cost model to quantify the cost of processing a single access:\n- Static balanced BST cost: the cost equals the number of nodes visited during the root-to-key search path. Because the BST is balanced, the height is $\\Theta(\\log n)$, so each search costs $\\Theta(\\log n)$ node visits, and the total cost is $O(m \\log n)$.\n- Splay Tree cost: the cost equals the number of nodes visited during the root-to-key search path plus the number of rotations performed during splaying (count each single rotation as cost $1$). For splaying operations, treat zig as one rotation and each of zig-zig and zig-zag as two rotations, reflecting the actual pointer changes performed.\n\nYour program must construct the following family of permutations and, for each, compute the ratio of total static balanced BST cost to total Splay Tree cost, both computed under the unit-cost model described above. Use $n=64$ for all cases and build the initial trees over keys $\\{1,\\dots,64\\}$:\n- Case $1$ (Ascending permutation): the access sequence is $[1,2,\\dots,64]$.\n- Case $2$ (Stride-$4$ permutation): partition indices by residue modulo $4$, and visit in column-major order: $[1,5,9,\\dots,61,2,6,10,\\dots,62,3,7,11,\\dots,63,4,8,12,\\dots,64]$.\n- Case $3$ (Stride-$32$ permutation): analogous to Case $2$ with stride $32$.\n- Case $4$ (Bit-reversal permutation): interpret indices $0$ through $63$ in binary with $6$ bits, reverse the bits of each index, then add $1$ to map back to the key space $\\{1,\\dots,64\\}$.\n- Case $5$ (Alternating extremes, or zigzag): the access sequence is $[64,1,63,2,62,3,\\dots]$ alternating the largest remaining and smallest remaining key.\n\nFor each case, compute:\n- The total cost on the static balanced BST, which is the sum of node visits for all $n$ accesses under the static tree.\n- The total cost on the Splay Tree, which is the sum over all $n$ accesses of node visits plus rotations performed during splaying the accessed node to the root.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the $i$-th element is the ratio of static balanced BST total cost to Splay Tree total cost for Case $i$, rounded to $6$ decimal places. For example, the output format must be exactly like $[r_1,r_2,r_3,r_4,r_5]$ where each $r_i$ is a floating-point number rounded to $6$ decimal places. No inputs should be read; the test suite is fixed as specified above. The hypotheses on properties causing the performance gap must be discussed in the solution, derived from the fundamental definitions and empirical outcomes measured by the program.", "solution": "The problem requires a comparative analysis of a static, balanced Binary Search Tree (BST) and a dynamic Splay Tree. This analysis will be conducted by simulating their performance on a set of five distinct access permutations on the keys $\\{1, 2, \\dots, n\\}$ for $n=64$. The core of the task is to implement the specified data structures and cost models, compute the total operational cost for each permutation, and derive the ratio of the static BST's cost to the Splay Tree's cost. This will be followed by a hypothesis on the properties of these permutations that account for the observed performance differences, grounded in the theoretical principles of data structures.\n\n### 1. Model Definitions\n\nLet $S = \\{1, 2, \\dots, n\\}$ be the set of keys, with $n=64$. The number of accesses is $m=n=64$.\n\n**Static Balanced BST**:\nThe static BST is constructed once over the key set $S$ and remains unchanged. The construction method is specified as \"median recursion\": for a range of keys `[low, high]`, the key at index `mid = floor((low + high) / 2)` is chosen as the root of the subtree, and the process is applied recursively to the sub-ranges `[low, mid-1]` and `[mid+1, high]`. While referred to as \"perfectly balanced,\" for $n=64$ which is not of the form $2^k-1$, this construction yields a tree that is nearly balanced but not a complete binary tree in the strictest sense. The structure is, however, uniquely determined.\n\nThe cost of a single access is defined as the number of nodes visited on the path from the root to the node containing the accessed key. The depth of the root is $1$. The total cost for an access sequence is the sum of the costs for each individual access. Since the specified access sequences are permutations of all keys in $S$, the total cost for the static BST is the sum of the depths of all nodes in the tree, i.e., $\\sum_{k=1}^{n} \\text{depth}(k)$. This total cost is constant for any of the five permutations.\n\n**Splay Tree**:\nThe Splay Tree is a self-adjusting BST. It is initialized with the exact same structure as the static BST. After each key access, a \"splaying\" operation is performed on the accessed node to move it to the root of the tree. This operation consists of a sequence of rotations. The standard splaying steps are:\n- **Zig**: Performed when the accessed node's parent is the root. It involves one rotation.\n- **Zig-Zig**: Performed when the accessed node and its parent are both left children or both right children. It involves two rotations.\n- **Zig-Zag**: Performed when the accessed node is a right child and its parent is a left child, or vice versa. It involves two rotations.\n\nThe cost model for the Splay Tree is more complex, accounting for both search and restructuring. The cost of a single access is the sum of:\n$1.$ The number of nodes visited during the search for the key (i.e., the depth of the node before splaying).\n$2.$ The number of rotations performed during the subsequent splaying operation. Each zig step costs $1$, while zig-zig and zig-zag steps cost $2$, reflecting the number of elementary rotations.\n\nThe total cost is the sum of these single-access costs over the entire permutation.\n\n### 2. Analysis of Access Permutations and Performance Hypotheses\n\nThe performance of Splay Trees is largely dictated by the principles of locality of reference. Access patterns with high temporal or spatial locality allow the splay tree to adapt its structure to keep frequently or recently accessed elements near the root, thereby reducing subsequent access times. The chosen permutations are designed to exhibit a range of locality properties.\n\n**Case 1: Ascending Permutation $[1, 2, \\dots, 64]$**\nThis sequence exhibits strong spatial locality in the key space but is a known pathological case for splay trees. Accessing the smallest key, $1$, makes it the root and arranges all other nodes in a long chain as its right descendants. Subsequently accessing key $2$ involves traversing this chain, making $2$ the new root, and re-forming another long chain. Each access essentially requires a traversal of a linear-time path. The cost for the $i$-th access is approximately proportional to $i$, leading to a total cost of $O(n^2)$. The static BST maintains a logarithmic access time, resulting in a total cost of $O(n \\log n)$.\n*Hypothesis*: The Splay Tree will perform significantly worse than the static BST. The cost ratio (BST/Splay) is expected to be much less than $1$.\n\n**Case 2: Stride-$4$ Permutation $[1, 5, \\dots, 61, 2, 6, \\dots]$**\nThis pattern accesses keys with a fixed stride, effectively interleaving four ascending sequences. While it breaks simple sequential locality, it possesses a different kind of regularity. Accessing keys like $1, 5, 9, \\dots$ might exhibit some locality in the tree structure, as splaying one key may bring other keys from the same residue class closer to the root. This is a classic example of testing how well splay trees handle strided memory access patterns.\n*Hypothesis*: This pattern has moderate locality. The Splay Tree's self-adjusting nature may or may not be beneficial, depending on how the splaying operations interact with the strided accesses. Performance is expected to be comparable to, or perhaps slightly better than, the static BST. The ratio should be close to $1$.\n\n**Case 3: Stride-$32$ Permutation $[1, 33, 2, 34, \\dots]$**\nThis permutation repeatedly alternates between two keys, $i$ and $i+32$, for $i=1, \\dots, 32$. This pattern presents a small, shifting \"working set\" of keys $\\{i, i+32\\}$. The Splay Tree's amortized analysis guarantees efficient performance when the set of recently accessed keys is small. After accessing $i$, key $i+32$ is accessed. Splaying $i$ restructures the tree; then, splaying $i+32$ does the same. This frequent access to a pair of keys should allow the Splay Tree to keep them relatively near the root.\n*Hypothesis*: The Splay Tree is expected to adapt well to this small working set. Its performance should be superior to the static BST's fixed logarithmic cost per access. The ratio should be greater than $1$.\n\n**Case 4: Bit-Reversal Permutation**\nThis permutation is generated by reversing the bits of the binary representation of indices $0, \\dots, 63$. It is known to exhibit poor locality; consecutive elements in the access sequence tend to be far apart in the key space (e.g., index $0 \\to$ key $1$, index $1 \\to$ key $33$). This pseudo-random access pattern provides little regularity for the Splay Tree to exploit.\n*Hypothesis*: With no discernible locality, the self-adjusting heuristic of the Splay Tree is unlikely to provide a significant advantage. The cost of restructuring may offset any incidental benefits. Performance is expected to be very similar to the static BST. The ratio should be close to $1$.\n\n**Case 5: Alternating Extremes (Zigzag) Permutation $[64, 1, 63, 2, \\dots]$**\nThis sequence repeatedly accesses the largest and smallest available keys. The \"Dynamic Finger Theorem\" for Splay Trees states that the cost to access key $x$ after accessing key $y$ is proportional to $O(\\log |x-y|)$. In this case, the distance $|x-y|$ between consecutive accesses is always large. This suggests that each access will be expensive. The tree will be drastically restructured in each step (e.g., moving the maximum element to the root, then moving the minimum element to the root).\n*Hypothesis*: This pattern forces maximum restructuring with each access. The high cost associated with accessing distant keys suggests that the Splay Tree will not outperform the static BST and may perform worse due to the overhead of splaying. The ratio is expected to be less than or equal to $1$.\n\n### 3. Empirical Validation\nThe provided Python program implements the simulation as described. It calculates the total costs for both tree types across all five permutations and computes the specified performance ratios. These empirical results serve to validate or refute the hypotheses presented above, providing concrete data on the behavior of Splay Trees under these varied access patterns.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np # Imported as per spec, but not strictly necessary for this logic.\n\nclass Node:\n    \"\"\"A node in a binary search tree.\"\"\"\n    def __init__(self, key, parent=None, left=None, right=None):\n        self.key = key\n        self.parent = parent\n        self.left = left\n        self.right = right\n\n    def __repr__(self):\n        return f\"Node({self.key})\"\n\nclass SplayTree:\n    \"\"\"Implementation of a Splay Tree.\"\"\"\n    def __init__(self, keys):\n        self.root = self._build_balanced_tree(keys)\n\n    def _build_balanced_tree(self, keys):\n        \"\"\"Builds a balanced BST using median recursion and sets parent pointers.\"\"\"\n        sorted_keys = sorted(keys)\n        return self._build_recursive(sorted_keys, 0, len(sorted_keys) - 1, None)\n\n    def _build_recursive(self, keys, low, high, parent):\n        if low > high:\n            return None\n        mid = (low + high) // 2\n        node = Node(keys[mid], parent=parent)\n        node.left = self._build_recursive(keys, low, mid - 1, node)\n        node.right = self._build_recursive(keys, mid + 1, high, node)\n        return node\n    \n    def _left_rotate(self, x):\n        y = x.right\n        x.right = y.left\n        if y.left is not None:\n            y.left.parent = x\n        y.parent = x.parent\n        if x.parent is None:\n            self.root = y\n        elif x == x.parent.left:\n            x.parent.left = y\n        else:\n            x.parent.right = y\n        y.left = x\n        x.parent = y\n\n    def _right_rotate(self, x):\n        y = x.left\n        x.left = y.right\n        if y.right is not None:\n            y.right.parent = x\n        y.parent = x.parent\n        if x.parent is None:\n            self.root = y\n        elif x == x.parent.right:\n            x.parent.right = y\n        else:\n            x.parent.left = y\n        y.right = x\n        x.parent = y\n\n    def _splay(self, x):\n        \"\"\"Splays node x to the root and returns the number of rotations.\"\"\"\n        rotations = 0\n        while x.parent is not None:\n            p = x.parent\n            g = p.parent\n            if g is None:  # Zig\n                if x == p.left:\n                    self._right_rotate(p)\n                else:\n                    self._left_rotate(p)\n                rotations += 1\n            elif x == p.left and p == g.left:  # Zig-Zig\n                self._right_rotate(g)\n                self._right_rotate(p)\n                rotations += 2\n            elif x == p.right and p == g.right:  # Zig-Zig\n                self._left_rotate(g)\n                self._left_rotate(p)\n                rotations += 2\n            elif x == p.right and p == g.left:  # Zig-Zag\n                self._left_rotate(p)\n                self._right_rotate(g)\n                rotations += 2\n            else:  # Zig-Zag (x is left child, p is right child)\n                self._right_rotate(p)\n                self._left_rotate(g)\n                rotations += 2\n        return rotations\n\n    def access(self, key):\n        \"\"\"Accesses a key, splays it, and returns the total cost.\"\"\"\n        # 1. Search for the key and find depth (search cost)\n        node = self.root\n        search_cost = 0\n        if node is None:\n            return 0\n        \n        while node is not None and node.key != key:\n            search_cost += 1\n            if key  node.key:\n                node = node.left\n            else:\n                node = node.right\n        \n        if node is None: # Should not happen for this problem's permutations\n            return search_cost \n\n        search_cost += 1 # Count the node itself\n\n        # 2. Splay the node and find rotation cost\n        rotation_cost = self._splay(node)\n\n        return search_cost + rotation_cost\n\ndef get_static_bst_cost(n):\n    \"\"\"Calculates the total cost for a static BST for a permutation of all keys.\"\"\"\n    depths = {}\n    \n    def build_and_get_depths(low, high, depth):\n        if low > high:\n            return\n        mid = (low + high) // 2\n        depths[mid] = depth\n        build_and_get_depths(low, mid - 1, depth + 1)\n        build_and_get_depths(mid + 1, high, depth + 1)\n\n    build_and_get_depths(1, n, 1)\n    # The total cost is the sum of depths for all nodes, as the permutation accesses each key once.\n    return sum(depths.values())\n\ndef generate_permutations(n):\n    \"\"\"Generates the five specified access permutations for n keys.\"\"\"\n    perms = {}\n    \n    # Case 1: Ascending\n    perms[1] = list(range(1, n + 1))\n    \n    # Case 2: Stride-4\n    perms[2] = [j for i in range(1, 5) for j in range(i, n + 1, 4)]\n    \n    # Case 3: Stride-32\n    perms[3] = [j for i in range(1, 33) for j in range(i, n + 1, 32)]\n    \n    # Case 4: Bit-reversal\n    seq = []\n    num_bits = (n - 1).bit_length()\n    for i in range(n):\n        binary_i = f'{i:0{num_bits}b}'\n        rev_binary_i = binary_i[::-1]\n        rev_i = int(rev_binary_i, 2)\n        seq.append(rev_i + 1)\n    perms[4] = seq\n\n    # Case 5: Alternating extremes\n    keys_list = list(range(1, n + 1))\n    seq = []\n    while keys_list:\n        seq.append(keys_list.pop())\n        if keys_list:\n            seq.append(keys_list.pop(0))\n    perms[5] = seq\n    \n    return perms\n\ndef solve():\n    \"\"\"Main function to run the simulation and produce the output.\"\"\"\n    n = 64\n    keys = list(range(1, n + 1))\n    \n    # Calculate static BST cost (this is constant for all cases)\n    static_bst_total_cost = get_static_bst_cost(n)\n    \n    # Generate the 5 test permutations\n    permutations = generate_permutations(n)\n    \n    results = []\n    for case_num in sorted(permutations.keys()):\n        perm = permutations[case_num]\n        \n        # Initialize a new splay tree for each case\n        splay_tree = SplayTree(keys)\n        \n        splay_total_cost = 0\n        for key in perm:\n            cost = splay_tree.access(key)\n            splay_total_cost += cost\n            \n        ratio = static_bst_total_cost / splay_total_cost\n        results.append(f\"{ratio:.6f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3273326"}]}