{"hands_on_practices": [{"introduction": "The heart of a scapegoat tree's rebalancing strategy is its ability to identify a single \"scapegoat\" node responsible for imbalance. This exercise challenges you to implement the fundamental detection mechanism based on the $\\alpha$-weight-balance condition. By writing the code to traverse an insertion path and check the sizes of subtrees, you will gain a practical, hands-on understanding of how the tree pinpoints the source of imbalance before triggering a rebuild. [@problem_id:3216147]", "problem": "You are given the task of implementing the logic to detect an imbalanced subtree according to the scapegoat tree criterion, within a binary tree that has just undergone a single insertion. The detection must be performed along the specific insertion path. Begin from the following fundamental definitions and facts:\n\n- A binary tree is a data structure in which each node has at most two children, usually designated as a left child and a right child.\n- For any node, define the subtree size function $s(v)$ as the total number of nodes in the subtree rooted at node $v$, including $v$ itself.\n- For a real parameter $\\alpha$ with $ \\frac{1}{2} < \\alpha < 1$, a node $u$ is considered $\\alpha$-weight-balanced if both its left and right child subtrees have sizes at most $\\alpha \\cdot s(u)$. That is, if $L(u)$ denotes the size of the left child subtree of $u$ and $R(u)$ denotes the size of the right child subtree of $u$, then $u$ is $\\alpha$-weight-balanced if $L(u) \\le \\alpha \\cdot s(u)$ and $R(u) \\le \\alpha \\cdot s(u)$. A node $u$ is an $\\alpha$-scapegoat if it is not $\\alpha$-weight-balanced, meaning either $L(u) > \\alpha \\cdot s(u)$ or $R(u) > \\alpha \\cdot s(u)$.\n\nYou must implement a program that, given a binary tree, a parameter $\\alpha$, and a specified insertion path ending at the newly inserted node, detects the first $\\alpha$-scapegoat ancestor when traversing upward from the parent of the newly inserted node along the given path. If no ancestor along this path violates the $\\alpha$-weight-balance condition, return $-1$. The detection must be based on exact subtree sizes after the insertion is applied.\n\nRepresentation details to be used within the program:\n- Each tree is specified by a list of triples $(\\text{id}, \\text{left}, \\text{right})$ where $\\text{id}$, $\\text{left}$, and $\\text{right}$ are integers, and $-1$ denotes a null child.\n- The insertion path is given as a list $[p_0, p_1, \\dots, p_k]$, where $p_0$ is the root identifier and $p_k$ is the newly inserted node identifier. The insertion attaches $p_k$ as the left or right child of $p_{k-1}$ as specified by an explicit side indicator.\n- After applying the insertion, compute $s(v)$ for all nodes reachable from the root, and detect the deepest ancestor on the path $[p_0, p_1, \\dots, p_{k-1}]$ (closest to $p_k$) that satisfies the violation $L(u) > \\alpha \\cdot s(u)$ or $R(u) > \\alpha \\cdot s(u)$.\n\nYour program must embed and process the following five test cases exactly as specified:\n\n- Test Case $1$:\n  - Nodes: $(8, 4, 12)$, $(4, 2, -1)$, $(12, 10, 14)$, $(2, -1, -1)$, $(6, -1, -1)$, $(10, -1, -1)$, $(14, -1, -1)$.\n  - Root: $8$.\n  - Parameter: $\\alpha = 0.7$.\n  - Insertion path: $[8, 12, 14, 15]$ with side $R$ at parent $14$, meaning attach node $15$ as the right child of $14$.\n  - Expected detection: compute $s(v)$ after insertion and determine the first $\\alpha$-scapegoat ancestor along the path, or $-1$ if none.\n\n- Test Case $2$:\n  - Nodes: $(10, 5, -1)$, $(5, 3, -1)$, $(3, -1, -1)$.\n  - Root: $10$.\n  - Parameter: $\\alpha = 0.6$.\n  - Insertion path: $[10, 5, 3, 2]$ with side $L$ at parent $3$, meaning attach node $2$ as the left child of $3$.\n  - Expected detection: compute $s(v)$ after insertion and determine the first $\\alpha$-scapegoat ancestor along the path, or $-1$ if none.\n\n- Test Case $3$:\n  - Nodes: $(50, 40, -1)$, $(40, 30, -1)$, $(30, 20, -1)$, $(20, 10, -1)$, $(10, -1, -1)$.\n  - Root: $50$.\n  - Parameter: $\\alpha = 0.8$.\n  - Insertion path: $[50, 40, 30, 20, 10, 5]$ with side $L$ at parent $10$, meaning attach node $5$ as the left child of $10$.\n  - Expected detection: compute $s(v)$ after insertion and determine the first $\\alpha$-scapegoat ancestor along the path, or $-1$ if none.\n\n- Test Case $4$:\n  - Nodes: $(1, -1, -1)$.\n  - Root: $1$.\n  - Parameter: $\\alpha = 0.6$.\n  - Insertion path: $[1, 2]$ with side $L$ at parent $1$, meaning attach node $2$ as the left child of $1$.\n  - Expected detection: compute $s(v)$ after insertion and determine the first $\\alpha$-scapegoat ancestor along the path, or $-1$ if none.\n\n- Test Case $5$:\n  - Nodes: $(9, 4, 13)$, $(4, -1, 6)$, $(6, 5, 7)$, $(5, -1, -1)$, $(7, -1, -1)$, $(13, -1, -1)$.\n  - Root: $9$.\n  - Parameter: $\\alpha = 0.6$.\n  - Insertion path: $[9, 4, 6, 7, 8]$ with side $R$ at parent $7$, meaning attach node $8$ as the right child of $7$.\n  - Expected detection: compute $s(v)$ after insertion and determine the first $\\alpha$-scapegoat ancestor along the path, or $-1$ if none.\n\nYour program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, in the same order as the test cases (for example, $[r_1, r_2, r_3, r_4, r_5]$). Each $r_i$ must be an integer equal to the detected scapegoat node identifier, or $-1$ if no scapegoat is detected for that case.", "solution": "The problem requires us to identify the first \"scapegoat\" ancestor on the insertion path in a binary tree, based on the definition of $\\alpha$-weight-balance from scapegoat tree theory. A node becomes a scapegoat if the size of one of its child subtrees exceeds a certain fraction $\\alpha$ of its own total subtree size.\n\nThe solution proceeds systematically through four main steps for each test case:\n1.  **Tree Construction**: The tree is represented in memory using a more convenient graph-like structure than the provided list of triples. Each node is an object containing its identifier, references to its left child, right child, and parent, and an attribute to store its subtree size. We first create all node objects from the input list and store them in a dictionary mapping their integer identifiers to the objects. Then, we iterate through the list again to establish the parent-child links between these objects, forming the complete tree structure rooted at the specified root node.\n\n2.  **Simulating Insertion**: The problem specifies that an insertion has just occurred. We simulate this by creating a new node for the inserted element and attaching it as a child to its specified parent. The parent is the second-to-last node in the given insertion path, and the side of attachment (left or right) is explicitly provided. The `parent` pointer of the new node is also set accordingly.\n\n3.  **Subtree Size Calculation**: After the insertion, the subtree sizes of all ancestors of the newly inserted node are altered. To ensure correctness, we must re-calculate the size for every node in the tree. The subtree size $s(v)$ of a node $v$ is defined as $1$ (for the node itself) plus the sizes of its left and right subtrees: $s(v) = 1 + s(\\text{v.left}) + s(\\text{v.right})$. This recursive definition naturally leads to a post-order traversal (a form of Depth-First Search) for computation. The algorithm recursively calculates the sizes of a node's children before calculating its own size. This process is initiated from the root of the tree, guaranteeing that by the time we evaluate a node $v$, the sizes for all nodes in its subtrees have already been computed and stored.\n\n4.  **Scapegoat Detection**: The core task is to find the first ancestor of the inserted node that violates the $\\alpha$-weight-balance condition. The condition for a node $u$ to be $\\alpha$-weight-balanced is $L(u) \\le \\alpha \\cdot s(u)$ and $R(u) \\le \\alpha \\cdot s(u)$, where $L(u)$ and $R(u)$ are the sizes of the left and right child subtrees, respectively. A violation, making $u$ a scapegoat, occurs if $L(u) > \\alpha \\cdot s(u)$ or $R(u) > \\alpha \\cdot s(u)$.\nTo find the \"deepest\" such ancestor (the one closest to the new leaf), we traverse the insertion path upwards, starting from the parent of the newly added node and moving towards the root. The insertion path is given as $[p_0, p_1, \\dots, p_{k-1}, p_k]$, so the ancestor path to check is $[p_{k-1}, p_{k-2}, \\dots, p_0]$. For each ancestor $u$ on this path, we retrieve the pre-computed sizes of its children, $L(u)$ and $R(u)$, and its own size, $s(u)$. We then apply the scapegoat test. The first node along this upward traversal that fails the test is the required scapegoat. If the traversal completes without finding any such node, it means no ancestor on the path is a scapegoat, and we return $-1$ as per the problem's requirement.\n\nLet's apply this logic to Test Case 2:\n- **Given**: Root $10$, $\\alpha = 0.6$, insertion path $[10, 5, 3, 2]$ with side L.\n- **Initial Tree**: A linear chain: $10 \\to 5 \\to 3$.\n- **Insertion**: Node $2$ is attached as the left child of node $3$. The tree becomes $10 \\to 5 \\to 3 \\to 2$.\n- **Size Calculation**: A post-order traversal yields: $s(2) = 1$, $s(3) = 1 + s(2) = 2$, $s(5) = 1 + s(3) = 3$, $s(10) = 1 + s(5) = 4$.\n- **Scapegoat Detection**: The ancestor path to check, from bottom up, is $[3, 5, 10]$.\n  1.  **Check node $3$**: $s(3) = 2$. Its left child is $2$, with size $L(3) = s(2) = 1$. Its right child is null, so $R(3) = 0$. The balance condition is checked against $\\alpha \\cdot s(3) = 0.6 \\cdot 2 = 1.2$. Since $L(3) = 1 \\ngtr 1.2$ and $R(3) = 0 \\ngtr 1.2$, node $3$ is balanced.\n  2.  **Check node $5$**: $s(5) = 3$. Its left child is $3$, with size $L(5) = s(3) = 2$. Its right child is null, so $R(5) = 0$. The balance condition is checked against $\\alpha \\cdot s(5) = 0.6 \\cdot 3 = 1.8$. Here, $L(5) = 2 > 1.8$. The condition is violated.\n- **Result**: Node $5$ is the first scapegoat encountered. The algorithm terminates and returns $5$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\nclass Node:\n    \"\"\"Represents a node in the binary tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.size = 0\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": [(8, 4, 12), (4, 2, -1), (12, 10, 14), (2, -1, -1), (6, -1, -1), (10, -1, -1), (14, -1, -1)],\n            \"root\": 8,\n            \"alpha\": 0.7,\n            \"path\": [8, 12, 14, 15],\n            \"side\": 'R'\n        },\n        {\n            \"nodes\": [(10, 5, -1), (5, 3, -1), (3, -1, -1)],\n            \"root\": 10,\n            \"alpha\": 0.6,\n            \"path\": [10, 5, 3, 2],\n            \"side\": 'L'\n        },\n        {\n            \"nodes\": [(50, 40, -1), (40, 30, -1), (30, 20, -1), (20, 10, -1), (10, -1, -1)],\n            \"root\": 50,\n            \"alpha\": 0.8,\n            \"path\": [50, 40, 30, 20, 10, 5],\n            \"side\": 'L'\n        },\n        {\n            \"nodes\": [(1, -1, -1)],\n            \"root\": 1,\n            \"alpha\": 0.6,\n            \"path\": [1, 2],\n            \"side\": 'L'\n        },\n        {\n            \"nodes\": [(9, 4, 13), (4, -1, 6), (6, 5, 7), (5, -1, -1), (7, -1, -1), (13, -1, -1)],\n            \"root\": 9,\n            \"alpha\": 0.6,\n            \"path\": [9, 4, 6, 7, 8],\n            \"side\": 'R'\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(process_case(case))\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(case_data):\n    \"\"\"\n    Processes a single test case: builds the tree, performs insertion,\n    calculates sizes, and finds the scapegoat.\n    \"\"\"\n    node_list = case_data[\"nodes\"]\n    root_id = case_data[\"root\"]\n    alpha = case_data[\"alpha\"]\n    insertion_path = case_data[\"path\"]\n    insertion_side = case_data[\"side\"]\n\n    nodes = {}\n\n    # First pass: create all node objects\n    all_node_ids = set()\n    for key, left, right in node_list:\n        all_node_ids.add(key)\n        if left != -1: all_node_ids.add(left)\n        if right != -1: all_node_ids.add(right)\n    \n    for key in all_node_ids:\n        if key in nodes: continue\n        nodes[key] = Node(key)\n\n    # Second pass: link nodes\n    for key, left_key, right_key in node_list:\n        node = nodes[key]\n        if left_key != -1:\n            node.left = nodes[left_key]\n            nodes[left_key].parent = node\n        if right_key != -1:\n            node.right = nodes[right_key]\n            nodes[right_key].parent = node\n\n    # Perform insertion\n    parent_key = insertion_path[-2]\n    new_node_key = insertion_path[-1]\n\n    parent_node = nodes[parent_key]\n    new_node = Node(new_node_key)\n    nodes[new_node_key] = new_node\n    new_node.parent = parent_node\n\n    if insertion_side == 'L':\n        parent_node.left = new_node\n    else: # 'R'\n        parent_node.right = new_node\n    \n    # Calculate subtree sizes using post-order traversal (DFS)\n    root_node = nodes[root_id]\n    compute_sizes(root_node)\n\n    # Traverse up the insertion path to find the scapegoat\n    ancestor_path = insertion_path[:-1]\n    scapegoat_id = -1\n\n    for node_key in reversed(ancestor_path):\n        current_node = nodes[node_key]\n        \n        left_size = current_node.left.size if current_node.left else 0\n        right_size = current_node.right.size if current_node.right else 0\n        total_size = current_node.size\n        \n        # Check for alpha-weight-balance violation\n        if left_size > alpha * total_size or right_size > alpha * total_size:\n            scapegoat_id = current_node.key\n            break\n            \n    return scapegoat_id\n\n\ndef compute_sizes(node):\n    \"\"\"\n    Recursively computes the size of the subtree rooted at `node`.\n    Uses post-order traversal logic.\n    \"\"\"\n    if node is None:\n        return 0\n    \n    left_size = compute_sizes(node.left)\n    right_size = compute_sizes(node.right)\n    \n    node.size = 1 + left_size + right_size\n    return node.size\n\nsolve()\n```", "id": "3216147"}, {"introduction": "Intuition can sometimes be misleading when analyzing data structures. This practice presents a thought experiment: what happens when a worst-case insertion occurs in a perfectly balanced tree? By carefully applying the depth-based trigger rule, you will explore the precise conditions that initiate a rebuild, revealing that even seemingly disruptive operations may not be enough to trigger rebalancing if the tree is sufficiently healthy, which helps to solidify your understanding of the algorithm's nuances. [@problem_id:3268448]", "problem": "Consider a Scapegoat Tree (SGT) parameterized by a balance constant $\\alpha \\in \\left(\\frac{1}{2}, 1\\right)$, built on a Binary Search Tree (BST). The SGT maintains the following core definitions during insertions: (i) after inserting a key using the standard BST rule, if the depth of the newly inserted node exceeds a maximum allowed depth $H_{\\alpha}(q) = \\left\\lfloor \\log_{1/\\alpha} q \\right\\rfloor$, where $q$ is the current upper bound on the number of keys and is incremented to $q \\leftarrow q + 1$ on each insertion, then the algorithm climbs ancestors to find the first node $w$ on the insertion path whose heavier child has size strictly greater than $\\alpha \\cdot \\mathrm{size}(w)$; the subtree rooted at $w$ is then rebuilt into a perfectly balanced BST; and (ii) if no such depth violation occurs, no rebuilding happens. Assume the starting tree is a perfectly balanced full BST on $n = 2^{h+1} - 1$ distinct keys, so its height is $h$ (root at depth $0$ and all leaves at depth $h$). A single insertion is performed with a key that yields the longest possible search path (for example, the new minimum or maximum), so the new node is attached as a child of a leaf at depth $h$.\n\nWhich of the following statements about this single insertion are correct?\n\nA. For any $\\alpha \\in \\left(\\frac{1}{2}, 1\\right)$, no subtree is rebuilt; the insertion runs in $\\Theta(\\log n)$ time, and the tree’s height increases by exactly $1$.\n\nB. If $\\alpha$ is chosen arbitrarily close to $\\frac{1}{2}$, the insertion forces a rebuild of the entire tree in $\\Theta(n)$ time, and the height remains $h$.\n\nC. For every $\\alpha \\in \\left(\\frac{1}{2}, 1\\right)$, the insertion triggers a rebuild of some proper ancestor subtree whose size is $\\Theta(n^{\\alpha})$.\n\nD. There exists a key whose insertion causes a rebuild of size $\\Theta(n)$ in this scenario, even though the tree starts perfectly balanced.\n\nE. If the inserted key is the new minimum or maximum, the depth bound is violated and the root is rebuilt.", "solution": "### Problem Validation\n\nThe problem statement describes a specific scenario involving a Scapegoat Tree (SGT), a well-defined data structure in computer science.\n\n**Step 1: Extract Givens**\n-   Data Structure: Scapegoat Tree (SGT) with balance constant $\\alpha \\in \\left(\\frac{1}{2}, 1\\right)$.\n-   Initial State: A perfectly balanced full Binary Search Tree (BST) with $n = 2^{h+1} - 1$ nodes. Its height is $h$, with the root at depth $0$.\n-   Operation: A single insertion of a key that results in the longest possible search path. The new node is attached as a child of a leaf at depth $h$.\n-   Rebuild Trigger: A rebuild process is initiated if the depth of the newly inserted node, let's call it $d_{\\text{new}}$, exceeds a maximum allowed depth $H_{\\alpha}(q) = \\left\\lfloor \\log_{1/\\alpha} q \\right\\rfloor$.\n-   Size Counter: $q$ is an upper bound on the number of keys. After the insertion, its value is $q = n+1$.\n-   Scapegoat Search: If the depth bound is violated, the algorithm finds the first ancestor $w$ on the insertion path such that the size of its heavier child is strictly greater than $\\alpha \\cdot \\mathrm{size}(w)$. The subtree at $w$ is rebuilt.\n-   No Rebuild: If the depth bound is not violated, no rebuilding occurs.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientifically Grounded:** The problem is based on the established principles and definitions of Scapegoat Trees from the field of data structures and algorithms. The definitions of $\\alpha$-balance and the depth-based trigger for rebalancing are standard components of SGT theory.\n-   **Well-Posed:** All necessary parameters ($n$, $h$, $\\alpha$) and conditions (initial tree state, insertion type, SGT rules) are provided. The question is specific and leads to a determinable outcome.\n-   **Objective:** The problem is formulated with precise, objective, and technical language, free from ambiguity or subjective claims.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid, self-contained, and scientifically sound. It presents a well-posed question within the domain of theoretical computer science. I will proceed with the solution derivation.\n\n### Solution Derivation\n\nThe core of the problem is to determine if the specified insertion triggers a rebuild operation in the Scapegoat Tree. This depends on the depth condition.\n\n1.  **Analyze the State After Insertion**\n    *   The initial tree has $n = 2^{h+1} - 1$ nodes and height $h$. All leaves are at depth $h$.\n    *   An insertion with the longest search path means the new key is either smaller than the minimum or larger than the maximum key in the tree. This new node will be attached to the leftmost or rightmost leaf, which is at depth $h$.\n    *   The depth of the newly inserted node is therefore $d_{\\text{new}} = h+1$.\n    *   The number of nodes in the tree becomes $n+1$. The problem states that the size counter $q$ is updated to reflects this new size, so $q = n+1$.\n    *   Using the given formula for $n$, we have $q = (2^{h+1} - 1) + 1 = 2^{h+1}$.\n\n2.  **Check the Depth Condition**\n    *   A rebuild is triggered if $d_{\\text{new}} > H_{\\alpha}(q)$. We must check if this inequality holds.\n    *   We have $d_{\\text{new}} = h+1$.\n    *   $H_{\\alpha}(q) = \\left\\lfloor \\log_{1/\\alpha} q \\right\\rfloor = \\left\\lfloor \\log_{1/\\alpha} (2^{h+1}) \\right\\rfloor$.\n    *   Using the logarithm property $\\log_b(x^y) = y \\log_b(x)$, we get:\n        $$H_{\\alpha}(q) = \\left\\lfloor (h+1) \\log_{1/\\alpha} 2 \\right\\rfloor$$\n    *   The condition to check is:\n        $$h+1 > \\left\\lfloor (h+1) \\log_{1/\\alpha} 2 \\right\\rfloor$$\n    *   Let's analyze the term $C = \\log_{1/\\alpha} 2$. The balance constant $\\alpha$ is in the range $\\left(\\frac{1}{2}, 1\\right)$.\n    *   This implies that $1/\\alpha$ is in the range $(1, 2)$.\n    *   Since the base of the logarithm, $1/\\alpha$, is greater than $1$, the logarithm is an increasing function.\n    *   Therefore, $\\log_{1/\\alpha} 2 > \\log_{1/\\alpha} (1/\\alpha) = 1$. So, we have $C > 1$.\n    *   The inequality is $h+1 > \\lfloor (h+1)C \\rfloor$ where $C > 1$.\n    *   Since $h$ is a non-negative integer (height of a non-empty tree is $\\ge 0$), $h+1$ is a positive integer.\n    *   Because $C > 1$, the product $(h+1)C$ is strictly greater than $h+1$. Let $(h+1)C = h+1+\\delta$ for some $\\delta > 0$.\n    *   The inequality becomes $h+1 > \\lfloor h+1+\\delta \\rfloor$.\n    *   Since $h+1$ is an integer and $\\delta > 0$, the floor expression $\\lfloor h+1+\\delta \\rfloor$ will be an integer greater than or equal to $h+1$.\n    *   Thus, we are checking if $h+1 > (\\text{an integer} \\ge h+1)$. This is a contradiction. The strict inequality can never hold.\n\n3.  **Conclusion of Analysis**\n    *   The depth condition $d_{\\text{new}} > H_{\\alpha}(q)$ is not met for any $\\alpha \\in \\left(\\frac{1}{2}, 1\\right)$.\n    *   According to the problem's rule (ii), if no depth violation occurs, no rebuilding happens.\n    *   Therefore, the insertion is simply a standard BST insertion.\n    *   The insertion path has length $h$, so the time complexity is $O(h)$. Since $n = 2^{h+1}-1$, we have $h = \\log_2(n+1)-1 = \\Theta(\\log n)$. The insertion time is $\\Theta(\\log n)$.\n    *   The initial height was $h$. The new node at depth $h+1$ increases the tree's height by exactly $1$, to $h+1$.\n\n### Option-by-Option Analysis\n\n**A. For any $\\alpha \\in \\left(\\frac{1}{2}, 1\\right)$, no subtree is rebuilt; the insertion runs in $\\Theta(\\log n)$ time, and the tree’s height increases by exactly $1$.**\n-   My derivation shows that for any $\\alpha$ in the given range, the depth condition is not met, so no subtree is rebuilt.\n-   My derivation shows the insertion time is $\\Theta(\\log n)$.\n-   My derivation shows the height increases from $h$ to $h+1$, an increase of exactly $1$.\n-   **Verdict: Correct.**\n\n**B. If $\\alpha$ is chosen arbitrarily close to $\\frac{1}{2}$, the insertion forces a rebuild of the entire tree in $\\Theta(n)$ time, and the height remains $h$.**\n-   The statement claims a rebuild is forced. My analysis shows no rebuild occurs, even for $\\alpha$ arbitrarily close to $\\frac{1}{2}$. As $\\alpha \\to (1/2)^+$, the value $C = \\log_{1/\\alpha} 2 \\to 1^+$. Let $C = 1+\\epsilon$ for a small $\\epsilon>0$. The condition is $h+1 > \\lfloor h+1+\\epsilon(h+1) \\rfloor$. For any given $h$, we can choose $\\alpha$ close enough to $1/2$ such that $\\epsilon(h+1)  1$. In that case, $\\lfloor h+1+\\epsilon(h+1) \\rfloor = h+1$, and the condition $h+1 > h+1$ is false. Thus no rebuild is triggered. The claim is incorrect.\n-   The claim of $\\Theta(n)$ time and height remaining $h$ are also consequential fallacies.\n-   **Verdict: Incorrect.**\n\n**C. For every $\\alpha \\in \\left(\\frac{1}{2}, 1\\right)$, the insertion triggers a rebuild of some proper ancestor subtree whose size is $\\Theta(n^{\\alpha})$.**\n-   The statement claims that for every $\\alpha$, a rebuild is triggered. This contradicts the primary finding that no rebuild occurs for any $\\alpha$ in the specified scenario.\n-   **Verdict: Incorrect.**\n\n**D. There exists a key whose insertion causes a rebuild of size $\\Theta(n)$ in this scenario, even though the tree starts perfectly balanced.**\n-   The problem specifies the scenario: the initial tree is a perfectly balanced full BST with $n=2^{h+1}-1$ nodes, and the insertion creates the longest possible path. The question asked is about this specific scenario. \"There exists a key whose insertion...\" refers to this type of key. This option essentially asks if there exists an $\\alpha \\in (\\frac{1}{2}, 1)$ that would trigger a rebuild. As demonstrated, no such $\\alpha$ exists for this specific tree structure and insertion.\n-   **Verdict: Incorrect.**\n\n**E. If the inserted key is the new minimum or maximum, the depth bound is violated and the root is rebuilt.**\n-   \"the depth bound is violated\": As proven above, this is false.\n-   \"the root is rebuilt\": This would require two conditions: (1) the depth bound is violated (which it is not), and (2) the root is identified as the scapegoat. The scapegoat condition for the root would be $\\mathrm{size}(\\text{heavier child}) > \\alpha \\cdot \\mathrm{size}(\\text{root})$. After insertion, the root has size $n+1 = 2^{h+1}$. The original children subtrees had size $2^h-1$. The insertion adds $1$ node to one of them, making its size $2^h$. The condition is $2^h > \\alpha \\cdot 2^{h+1}$, which simplifies to $1 > 2\\alpha$, or $\\alpha  1/2$. This contradicts the given $\\alpha \\in (\\frac{1}{2}, 1)$. So, even if the depth bound were violated, the root would not be the scapegoat.\n-   **Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "3268448"}, {"introduction": "The efficiency of a scapegoat tree hinges on a critical trade-off: the cost of letting the tree become imbalanced versus the cost of rebuilding it. This advanced problem asks you to model this trade-off mathematically and find the optimal value for the balance parameter $\\alpha$ that minimizes the long-term, amortized cost per operation. This exercise will take you to the core design principle of the scapegoat tree, demonstrating how theoretical analysis can guide the tuning of an algorithm for best performance. [@problem_id:3219094]", "problem": "Consider a Binary Search Tree (BST) that supports search, insert, and delete operations. The BST is rebuilt into a perfectly balanced tree whenever its height exceeds a threshold proportional to its current size. Specifically, after each update, if the height $h$ exceeds $\\alpha \\log_{2} n$, the entire tree is rebuilt into a perfectly balanced BST, where $n$ is the number of nodes at that moment, $\\alpha > 1$ is a tunable parameter, and $\\log_{2}(\\cdot)$ denotes the base-$2$ logarithm. Assume the following model of cost:\n- Each comparison on a node costs exactly $1$ time unit.\n- The cost of any search, insert, or delete is the number of nodes visited on its root-to-leaf path, which is at most the current height $h$ at the time of the operation.\n- A full rebuild of the tree into a perfectly balanced BST costs exactly $\\gamma n$ time units for some fixed constant $\\gamma > 0$ (this aggregates linear-time traversal and reconstruction into a single constant-factor model).\n- Immediately following a rebuild, the height becomes exactly $\\log_{2} n$.\n\nDerive from first principles an amortized upper bound on the per-operation cost under a worst-case adversarial sequence that maximizes the cost subject to the above rules. Assume the adversary can choose keys to increase the height by at most $1$ per operation (by forcing insertions along a single path) and that during one rebuild cycle, $n$ remains approximately constant so that $\\log_{2} n$ is a stable baseline. Your derivation must begin from the core definitions of BST height and the accounting interpretation of amortized cost (total cost divided by the number of operations in a phase), without invoking shortcut results from balanced-tree schemes.\n\nThen, choose the value of $\\alpha$ that minimizes the derived amortized cost bound as a function of $n$ and $\\gamma$. Express the optimal $\\alpha$ as an exact closed-form analytic expression. Do not approximate and do not round; your final answer must be an exact expression with no units.", "solution": "We begin with the core definitions relevant to the Binary Search Tree (BST) and amortized analysis:\n- The height $h$ of a BST is the maximum number of nodes on any root-to-leaf path. A search, insert, or delete visits at most $h$ nodes, so its cost is at most $h$ time units, given that each node comparison costs $1$ time unit.\n- A perfectly balanced BST on $n$ nodes has height exactly $\\log_{2} n$.\n- In our rebuild policy, whenever $h > \\alpha \\log_{2} n$, we rebuild the entire tree into a perfectly balanced BST, paying a cost of $\\gamma n$ time units. Immediately after rebuild, the height resets to $\\log_{2} n$.\n\nWe perform an amortized analysis under a worst-case adversarial sequence, using the accounting viewpoint: the amortized cost per operation in a phase is the total cost incurred in that phase divided by the number of operations in the phase, where a phase begins right after a rebuild and ends when the next rebuild triggers.\n\nFrom the fundamental structure of BSTs, an adversary can increase the height by at most $1$ per operation by inserting keys that continue to extend the deepest path (for instance, inserting keys in strictly increasing order to generate a right-spine). Since immediately after rebuild the height is $\\log_{2} n$, to trigger the next rebuild the height must reach $\\alpha \\log_{2} n$. Therefore, the height must increase by\n$$\n\\Delta h \\;=\\; \\alpha \\log_{2} n \\;-\\; \\log_{2} n \\;=\\; (\\alpha - 1)\\log_{2} n.\n$$\nUnder the assumption that the adversary increases height by at most $1$ per operation, the minimum number of operations between rebuilds is thus\n$$\nL(\\alpha, n) \\;=\\; (\\alpha - 1)\\log_{2} n.\n$$\n\nWithin such a phase, the adversary keeps the tree as close to the rebuild threshold as possible to maximize per-operation path length. Hence, a conservative upper bound on the per-operation traversal cost throughout the phase is $\\alpha \\log_{2} n$. The total rebuild cost in the phase is $\\gamma n$, paid once at the end when the height threshold is exceeded. Amortizing this rebuild cost evenly over the $L(\\alpha, n)$ operations in the phase gives a rebuild cost per operation of\n$$\n\\frac{\\gamma n}{L(\\alpha, n)} \\;=\\; \\frac{\\gamma n}{(\\alpha - 1)\\log_{2} n}.\n$$\nTherefore, the amortized cost per operation, as a function of $\\alpha$, $n$, and $\\gamma$, is\n$$\nA(\\alpha; n, \\gamma) \\;=\\; \\underbrace{\\alpha \\log_{2} n}_{\\text{traversal}} \\;+\\; \\underbrace{\\frac{\\gamma n}{(\\alpha - 1)\\log_{2} n}}_{\\text{amortized rebuild}}.\n$$\n\nWe now choose $\\alpha$ to minimize $A(\\alpha; n, \\gamma)$ subject to $\\alpha > 1$. Define $L \\equiv \\log_{2} n$ and substitute $\\alpha = 1 + x$ with $x > 0$ to simplify the expression:\n$$\nA(1+x; n, \\gamma) \\;=\\; (1+x)L \\;+\\; \\frac{\\gamma n}{x L}\n\\;=\\; L \\;+\\; \\left( xL \\;+\\; \\frac{\\gamma n}{xL} \\right).\n$$\nThe term $L$ is constant with respect to $x$, so minimizing $A$ reduces to minimizing\n$$\ng(x) \\;=\\; xL \\;+\\; \\frac{\\gamma n}{xL}, \\quad x > 0.\n$$\nThis is a standard convex expression in $x$ (sum of a linear and a reciprocal term), whose minimum occurs when the two terms are equal:\n$$\nxL \\;=\\; \\frac{\\gamma n}{xL}.\n$$\nSolving for $x$ gives\n$$\nx^{2} L^{2} \\;=\\; \\gamma n\n\\quad\\Rightarrow\\quad\nx \\;=\\; \\frac{\\sqrt{\\gamma n}}{L} \\;=\\; \\frac{\\sqrt{\\gamma n}}{\\log_{2} n}.\n$$\nRecalling $\\alpha = 1 + x$, the optimal choice is\n$$\n\\alpha^{\\star}(n, \\gamma) \\;=\\; 1 \\;+\\; \\frac{\\sqrt{\\gamma n}}{\\log_{2} n}.\n$$\n\nWe can also compute the minimized amortized cost by substituting $x^{\\star}L = \\sqrt{\\gamma n}$ into $A$:\n$$\nA_{\\min}(n, \\gamma)\n\\;=\\;\nL \\;+\\; \\left( x^{\\star}L \\;+\\; \\frac{\\gamma n}{x^{\\star}L} \\right)\n\\;=\\;\nL \\;+\\; \\left( \\sqrt{\\gamma n} \\;+\\; \\sqrt{\\gamma n} \\right)\n\\;=\\;\n\\log_{2} n \\;+\\; 2\\sqrt{\\gamma n}.\n$$\nHowever, the problem requests the exact expression for the optimizer $\\alpha$, not the minimized value. Thus, the optimal $\\alpha$ is\n$$\n\\alpha^{\\star}(n, \\gamma) \\;=\\; 1 \\;+\\; \\frac{\\sqrt{\\gamma n}}{\\log_{2} n}.\n$$\nThis choice balances the linear-in-$\\alpha$ traversal term against the inverse-in-$(\\alpha-1)$ amortized rebuild term, achieving the unique minimizer over $\\alpha > 1$.", "answer": "$$\\boxed{1+\\frac{\\sqrt{\\gamma n}}{\\log_{2} n}}$$", "id": "3219094"}]}