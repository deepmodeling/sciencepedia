{"hands_on_practices": [{"introduction": "Before we can trust a data structure to perform correctly, we must be able to verify its integrity. This first practice challenges you to implement a function that checks if an array genuinely represents a binary min-heap. By translating the formal definition of the heap invariant into code with a time complexity of $O(n)$ and analyzing its fundamental limits, you will build a foundational skill for testing and debugging any data structure [@problem_id:3226029].", "problem": "You are given an array $A$ of length $n$ with zero-based indexing that is intended to represent a binary heap over a totally ordered set, where the heap property invariant for a binary min-heap requires that for every index $i$ such that the left child index $2i+1$ is less than $n$, the inequality $A[i] \\le A[2i+1]$ holds, and for every index $i$ such that the right child index $2i+2$ is less than $n$, the inequality $A[i] \\le A[2i+2]$ holds. Using the standard array representation of a binary heap, where the parent index of a node at index $j$ is $\\lfloor (j-1)/2 \\rfloor$, design and implement a function $\\texttt{is\\_heap}(A)$ that checks whether $A$ satisfies the binary min-heap invariant in time $O(n)$, where $n$ is the length of $A$. The check must be exhaustive and correct for all arrays of real numbers without missing violations; you may assume that all elements of $A$ are real numbers and that there are no special non-numeric values.\n\nYour task is to:\n- Derive from first principles why the check can be performed in time $O(n)$ and specify an algorithm that achieves this bound, starting from the core definition of the binary heap invariant and the array-based parent-child index relationships.\n- Argue rigorously why no algorithm can correctly decide this property asymptotically faster than $O(n)$ in the worst case, by appealing to a sound lower-bound reasoning from the comparison model of computation.\n\nFor implementation and testing, write a complete, runnable program that:\n- Defines $\\texttt{is\\_heap}(A)$ and returns a boolean indicating whether the input array $A$ satisfies the binary min-heap invariant.\n- Uses zero-based indexing, and checks both left and right child inequalities where the corresponding child indices exist within bounds.\n- Runs on the provided test suite below, producing a single-line output in the exact required format.\n\nTest suite (each $A$ is a list of integers, interpreted as real numbers):\n- Case $1$: $A = []$.\n- Case $2$: $A = [42]$.\n- Case $3$: $A = [1,3,2,7,8,9]$.\n- Case $4$: $A = [1,2,3,4,5,0]$.\n- Case $5$: $A = [2,1,3]$.\n- Case $6$: $A = [0,0,0,0,0]$.\n- Case $7$: $A = [-5,-3,-4,-2,-1]$.\n- Case $8$: $A = [0,1,1,2,2,2,2]$.\n- Case $9$: $A = [0,1,2,3,4,5,6,7,8,9,-1]$.\n- Case $10$: $A = [1,1]$.\n- Case $11$: $A = [1,0]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite, for example, \"[$r_1,r_2,\\dots,r_{11}$]\" where each $r_i$ is $\\texttt{True}$ or $\\texttt{False}$ as appropriate. No physical units are involved in this problem, and no angle units or percentage formats are needed. The final output format must be exactly one line with no extra spaces or text.", "solution": "The problem requires the design, analysis, and implementation of a function to validate if a given array, $A$, of length $n$, adheres to the binary min-heap invariant.\n\n### 1. Problem Formalization and First Principles\n\nA binary heap is a complete binary tree structure, commonly stored in an array format. For an array $A$ of length $n$ with zero-based indexing, the parent-child relationships are defined as follows:\n- The children of a node at index $i$ are at indices $2i+1$ (left child) and $2i+2$ (right child).\n- The parent of a node at index $j > 0$ is at index $\\lfloor (j-1)/2 \\rfloor$.\n\nThe binary min-heap invariant mandates that for any node, its value must be less than or equal to the values of its children. Formally, for every index $i$ in the array:\n- If a left child exists (i.e., its index $2i+1 < n$), the inequality $A[i] \\le A[2i+1]$ must hold.\n- If a right child exists (i.e., its index $2i+2 < n$), the inequality $A[i] \\le A[2i+2]$ must hold.\n\nNodes that have no children are called leaf nodes. For leaf nodes, the heap invariant is vacuously true. Therefore, we only need to perform checks on non-leaf (parent) nodes.\n\n### 2. Algorithm Design and Upper-Bound Analysis\n\nOur goal is to design an algorithm that verifies the min-heap invariant for all applicable nodes in $O(n)$ time.\n\n**Identifying Non-Leaf Nodes:**\nA node at index $i$ is a non-leaf node if and only if it has at least one child. Since the left child index $2i+1$ is always less than or equal to the right child index $2i+2$, a node $i$ is a parent if its left child is within the array bounds. That is, $2i+1 < n$.\nThis inequality can be rearranged to find the range of indices for parent nodes:\n$2i < n-1$\n$i < (n-1)/2$\nSince the index $i$ must be an integer, the largest index for a parent node is $\\lfloor (n-1-1)/2 \\rfloor = \\lfloor (n-2)/2 \\rfloor$. The parent nodes thus occupy the indices $i$ from $0$ to $\\lfloor (n-2)/2 \\rfloor$.\n\n**Algorithm:**\nBased on this, we can formulate a direct algorithm:\n1. Iterate through all possible parent node indices $i$ from $0$ up to and including $\\lfloor (n-2)/2 \\rfloor$.\n2. For each index $i$:\n   a. Define the left child index as $l = 2i+1$ and the right child index as $r = 2i+2$.\n   b. Check the left child: if $A[i] > A[l]$, the invariant is violated. The algorithm can immediately terminate and return `False`.\n   c. Check the right child: if the right child exists (i.e., $r < n$) and $A[i] > A[r]$, the invariant is violated. Terminate and return `False`.\n3. If the loop completes without finding any violations, it means the invariant holds for all non-leaf nodes. The array represents a valid min-heap, so return `True`.\n4. Special cases: If $n \\le 1$, the array contains at most one node. There are no parent-child relationships to check, so such an array is a valid heap by definition.\n\n**Time Complexity Analysis (Upper Bound):**\nThe algorithm iterates through a loop from $i=0$ to $i=\\lfloor (n-2)/2 \\rfloor$. The number of iterations is $\\lfloor (n-2)/2 \\rfloor + 1$. For $n>1$, this number is proportional to $n$. For $n=0$ or $n=1$, the loop body is not entered, which takes constant time, consistent with the analysis. Inside the loop, a constant number of operations are performed: two index calculations, up to two boundary checks, and up to two value comparisons.\nThe total number of operations is proportional to the number of iterations, which is approximately $n/2$. Thus, the time complexity of this algorithm is $O(n)$.\n\n### 3. Lower-Bound Analysis and Optimality\n\nWe will now argue that any comparison-based algorithm that correctly determines if an array is a min-heap must take $\\Omega(n)$ time in the worst case.\n\n**Adversary Argument:**\nThe argument proceeds by showing that any algorithm that runs in sub-linear time, i.e., $o(n)$, must fail on some inputs. An algorithm running in $o(n)$ time cannot inspect all $n$ elements of the array.\n1. Assume there exists an algorithm that correctly decides the heap property but does not examine the element at some index $k$ for a particular input array $A_1$. The algorithm must return `True` or `False` based on the elements it did examine.\n2. Let's construct a worst-case scenario. Suppose the adversary provides an input array $A_1$ that is a valid min-heap (e.g., all elements are $0$). Let the algorithm run on $A_1$. Since $A_1$ is a heap, the algorithm must return `True`. Suppose in this run, the algorithm does not read the value at index $k$, where $k>0$.\n3. The parent of node $k$ is at index $p = \\lfloor (k-1)/2 \\rfloor$. In array $A_1$, the heap property $A_1[p] \\le A_1[k]$ is satisfied.\n4. Now, the adversary constructs a new array, $A_2$, which is identical to $A_1$ in all positions except $k$. At index $k$, the adversary sets $A_2[k] = A_1[p] - 1$.\n5. In array $A_2$, the heap invariant is violated because $A_2[p] = A_1[p]$, and thus $A_2[p] > A_2[k]$. So, $A_2$ is not a valid min-heap.\n6. When the assumed algorithm is run on $A_2$, it follows the exact same execution path as on $A_1$. This is because all the values it compares are identical in both arrays, as it never reads the value at index $k$, the only position where they differ.\n7. Consequently, the algorithm must produce the same output for $A_2$ as for $A_1$, which is `True`. This is an incorrect result for $A_2$.\n8. This contradiction proves that to be correct, any algorithm must, in the worst case, read every element $A[k]$ for $k \\in \\{1, \\dots, n-1\\}$. By a similar argument for $k=0$ (by changing its value to be larger than one of its children), $A[0]$ must also be read.\n9. Therefore, any correct algorithm must read all $n$ elements of the array in the worst case. The act of reading $n$ elements from memory requires at least $n$ operations, so the time complexity is bounded from below by $\\Omega(n)$.\n\n**Conclusion on Optimality:**\nSince we have an algorithm with an upper bound of $O(n)$ and we have established a lower bound of $\\Omega(n)$ for the problem, our algorithm is asymptotically optimal. The complexity of verifying the min-heap property is $\\Theta(n)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_heap(A: list[float]) -> bool:\n    \"\"\"\n    Checks if an array A satisfies the binary min-heap invariant.\n    Time complexity: O(n), where n is the length of A.\n    Space complexity: O(1).\n    \"\"\"\n    n = len(A)\n    # An empty or single-element array is trivially a min-heap.\n    if n <= 1:\n        return True\n\n    # The last parent node is at index floor((n-2)/2).\n    # We iterate through all parent nodes from the root down to this last parent.\n    # The Python range() function correctly handles the upper bound.\n    last_parent_index = (n - 2) // 2\n    for i in range(last_parent_index + 1):\n        # The index of the left child is 2*i + 1.\n        # This child is guaranteed to be within the array bounds because\n        # i <= (n-2)/2 implies 2*i + 1 <= n-1.\n        left_child_index = 2 * i + 1\n\n        # Check the min-heap property with the left child.\n        if A[i] > A[left_child_index]:\n            return False\n\n        # The index of the right child is 2*i + 2.\n        # This child may be out of bounds, so we must check.\n        right_child_index = 2 * i + 2\n        if right_child_index < n:\n            # If the right child exists, check the min-heap property with it.\n            if A[i] > A[right_child_index]:\n                return False\n\n    # If the loop completes, no violations were found.\n    return True\n\ndef solve():\n    \"\"\"\n    Runs the is_heap function on a predefined test suite and prints the results.\n    \"\"\"\n    # Test suite as provided in the problem statement.\n    test_cases = [\n        [],                            # Case 1\n        [42],                          # Case 2\n        [1, 3, 2, 7, 8, 9],            # Case 3\n        [1, 2, 3, 4, 5, 0],            # Case 4\n        [2, 1, 3],                     # Case 5\n        [0, 0, 0, 0, 0],               # Case 6\n        [-5, -3, -4, -2, -1],          # Case 7\n        [0, 1, 1, 2, 2, 2, 2],         # Case 8\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1], # Case 9\n        [1, 1],                        # Case 10\n        [1, 0],                        # Case 11\n    ]\n\n    results = []\n    for case in test_cases:\n        result = is_heap(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3226029"}, {"introduction": "Data structure invariants are not just for validation; they are powerful tools for diagnostics and repair. In this exercise, you are presented with a binary heap where a single value has been corrupted, and your task is to locate and fix it in logarithmic time, $O(\\log n)$. This problem demonstrates how auxiliary information, derived from the structure's properties, can be used to create highly efficient debugging and data recovery algorithms [@problem_id:3226005].", "problem": "You are given a binary min-heap stored in an array representation with $0$-based indexing. The fundamental invariant of a binary min-heap states that for every node at index $i$, if its left child index is $\\ell = 2i+1$ and its right child index is $r = 2i+2$, then the keys satisfy $A[i] \\le A[\\ell]$ and $A[i] \\le A[r]$ whenever those child indices exist. The shape invariant is the complete binary tree property, which ensures that for $n$ elements, the height $h$ of the heap satisfies $h = \\lfloor \\log_2 n \\rfloor$, and thus any root-to-leaf path has length $O(\\log n)$.\n\nIn addition to the min-heap invariant, define for each index $i$ the subtree sum function $T(i)$ as the sum of all keys in the subtree rooted at node $i$ (including $i$ itself). You are provided two arrays of subtree sums:\n- $S^{\\text{orig}}$, the trusted subtree sums of the original, correct heap (before corruption).\n- $S^{\\text{curr}}$, the subtree sums computed from the current, corrupted heap array.\n\nExactly one element’s key in the heap array $H$ has been corrupted; all other positions are unchanged. No reordering of nodes has occurred. Your task is to exploit the invariants to locate the corrupted index and restore its original key in $O(\\log n)$ time by traversing a single root-to-leaf path. At each step, you must use subtree sums to decide which child contains the corruption, and upon reaching the corrupted node, compute its original key by subtracting its children’s trusted subtree sums from its own trusted subtree sum. Formally, if the corrupted index is $j$, its original key $x_j$ must satisfy\n$$\nx_j = S^{\\text{orig}}[j] \\;-\\; \\left( \\text{child exists? } S^{\\text{orig}}[\\ell] \\text{ else } 0 \\right) \\;-\\; \\left( \\text{child exists? } S^{\\text{orig}}[r] \\text{ else } 0 \\right),\n$$\nwhere $\\ell = 2j+1$ and $r = 2j+2$.\n\nImplement a program that, for each test case, performs the following:\n- Given $H$, $S^{\\text{orig}}$, and $S^{\\text{curr}}$, find the unique corrupted index $j$ by starting at index $0$ and repeatedly descending into the unique child whose $S^{\\text{curr}}$ disagrees with $S^{\\text{orig}}$ (if neither child disagrees at some node, that node is the corrupted index).\n- Compute $x_j$ using the formula above and set $H[j] := x_j$ to fix the heap.\n\nYou must not scan the entire array; the logic must rely on $O(1)$ checks per level and traverse only one path of length $O(\\log n)$.\n\nTest Suite:\nProvide solutions for the following parameter sets. For each case, arrays are listed in plain order, and all numbers are integers.\n\n- Case $1$:\n  - $H = [3,7,10,12,14,40,25]$\n  - $S^{\\text{orig}} = [88,33,52,12,14,17,25]$\n  - $S^{\\text{curr}} = [111,33,75,12,14,40,25]$\n- Case $2$:\n  - $H = [20,4,3,8,9,7,5]$\n  - $S^{\\text{orig}} = [37,21,15,8,9,7,5]$\n  - $S^{\\text{curr}} = [56,21,15,8,9,7,5]$\n- Case $3$:\n  - $H = [2,4,6,9,10,-1]$\n  - $S^{\\text{orig}} = [43,23,18,9,10,12]$\n  - $S^{\\text{curr}} = [30,23,5,9,10,-1]$\n- Case $4$:\n  - $H = [99]$\n  - $S^{\\text{orig}} = [5]$\n  - $S^{\\text{curr}} = [99]$\n- Case $5$:\n  - $H = [2,6,4,7,8,9,10]$\n  - $S^{\\text{orig}} = [43,18,23,7,8,9,10]$\n  - $S^{\\text{curr}} = [46,21,23,7,8,9,10]$\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must be the corrected heap array after fixing the corrupted element, printed in Python list syntax. For example, an output over five cases should look like $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$ on a single line.\n\nAll answers in the output are pure integers; no physical units, no angles, and no percentages are involved.", "solution": "### 1. Problem Analysis and Invariant Exploitation\n\nThe problem states that a single key in a heap array $H$ has been corrupted. We are given two arrays of pre-computed subtree sums: $S^{\\text{orig}}$ for the correct, original heap and $S^{\\text{curr}}$ for the current, corrupted heap. The subtree sum $T(i)$ is the sum of all keys in the subtree rooted at $i$.\n\nThe core insight comes from how the corruption affects the subtree sums. A change in the key at index $j$ will alter the value of $S^{\\text{curr}}[j]$. This change will propagate upwards: the subtree sum of its parent, $S^{\\text{curr}}[\\text{parent}(j)]$, will also be affected, and so on, all the way to the root. Consequently, $S^{\\text{curr}}[k]$ will differ from $S^{\\text{orig}}[k]$ if and only if node $k$ is an ancestor of the corrupted node $j$ (or is $j$ itself). Subtree sums for nodes that are not on the path from $j$ to the root will remain unchanged.\n\nThis provides us with a critical invariant for our search: at any node $i$ on the search path, if its subtree sum $S^{\\text{curr}}[i]$ is incorrect, the corruption must lie within the subtree rooted at $i$.\n\n### 2. Algorithm Design and Logarithmic-Time Path Traversal\n\nWe can leverage this property to devise an efficient top-down search algorithm that runs in $O(\\log n)$ time.\n\n**Algorithm:**\n1. Initialize the current index `current_idx` to $0$ (the root).\n2. Enter a loop that continues as long as `current_idx` is a valid index:\n   a. Get the indices of the left child, $\\ell = 2 \\cdot \\text{current\\_idx} + 1$, and the right child, $r = 2 \\cdot \\text{current\\_idx} + 2$.\n   b. Check the left child's subtree sum. If the left child exists ($\\ell < n$) and $S^{\\text{curr}}[\\ell] \\neq S^{\\text{orig}}[\\ell]$, the corruption must be in the left subtree. Update `current_idx = l` and continue the loop.\n   c. Else, check the right child's subtree sum. If the right child exists ($r < n$) and $S^{\\text{curr}}[r] \\neq S^{\\text{orig}}[r]$, the corruption is in the right subtree. Update `current_idx = r` and continue the loop.\n   d. If neither child's subtree sum is incorrect, it implies the corruption is not in any of their subtrees. Since we know the corruption is in the subtree rooted at `current_idx` (from the previous step), the key at `current_idx` itself must be the corrupted one. Break the loop.\n3. The corrupted index is now `current_idx`.\n4. Restore the original key value. The original key $x_j$ at a corrupted index $j$ can be recovered from the trusted sums using the recursive definition of the subtree sum: $S^{\\text{orig}}[j] = x_j + S^{\\text{orig}}[\\ell] + S^{\\text{orig}}[r]$. Rearranging this gives the formula from the problem statement:\n   $$x_j = S^{\\text{orig}}[j] - (\\text{if } \\ell < n \\text{ then } S^{\\text{orig}}[\\ell] \\text{ else } 0) - (\\text{if } r < n \\text{ then } S^{\\text{orig}}[r] \\text{ else } 0)$$\n5. Calculate $x_j$ and update $H[j]$ with this value.\n\n### 3. Complexity Analysis\n\n- **Time Complexity:** The heap has a height of $h = \\lfloor \\log_2 n \\rfloor$. The algorithm traverses a single path from the root to the corrupted node. At each level of the tree, it performs a constant number of checks and index calculations. The length of this path is at most $h+1$. Therefore, the time complexity is $O(\\log n)$.\n- **Space Complexity:** The algorithm uses a few variables to store the current index and child indices. It does not use any auxiliary data structures that scale with the input size. Therefore, the space complexity is $O(1)$.\n\nThis design meets all the requirements of the problem.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_and_correct(H, S_orig, S_curr):\n    \"\"\"\n    Finds the single corrupted element in a heap and restores its original value.\n\n    Args:\n        H (list): The corrupted heap array.\n        S_orig (list): The trusted subtree sums of the original heap.\n        S_curr (list): The subtree sums of the current (corrupted) heap.\n\n    Returns:\n        list: The corrected heap array.\n    \"\"\"\n    H_arr = np.array(H)\n    S_orig_arr = np.array(S_orig)\n    S_curr_arr = np.array(S_curr)\n    n = len(H_arr)\n\n    if n == 0:\n        return []\n\n    current_idx = 0\n    while current_idx < n:\n        l_child_idx = 2 * current_idx + 1\n        r_child_idx = 2 * current_idx + 2\n        \n        found_in_child = False\n        \n        # Check if corruption is in the left subtree\n        if l_child_idx < n and S_curr_arr[l_child_idx] != S_orig_arr[l_child_idx]:\n            current_idx = l_child_idx\n            found_in_child = True\n        # If not in left, check if corruption is in the right subtree\n        elif r_child_idx < n and S_curr_arr[r_child_idx] != S_orig_arr[r_child_idx]:\n            current_idx = r_child_idx\n            found_in_child = True\n        \n        # If corruption is in neither child's subtree, it must be the current node\n        if not found_in_child:\n            break\n            \n    corrupted_idx = current_idx\n    \n    # Restore the original value using the trusted subtree sum array\n    l_child_idx = 2 * corrupted_idx + 1\n    r_child_idx = 2 * corrupted_idx + 2\n    \n    s_orig_at_j = S_orig_arr[corrupted_idx]\n    \n    s_orig_of_l_child = 0\n    if l_child_idx < n:\n        s_orig_of_l_child = S_orig_arr[l_child_idx]\n        \n    s_orig_of_r_child = 0\n    if r_child_idx < n:\n        s_orig_of_r_child = S_orig_arr[r_child_idx]\n        \n    original_key = s_orig_at_j - s_orig_of_l_child - s_orig_of_r_child\n    \n    H_arr[corrupted_idx] = original_key\n    \n    return H_arr.tolist()\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([3,7,10,12,14,40,25], [88,33,52,12,14,17,25], [111,33,75,12,14,40,25]),\n        ([20,4,3,8,9,7,5], [37,21,15,8,9,7,5], [56,21,15,8,9,7,5]),\n        ([2,4,6,9,10,-1], [43,23,18,9,10,12], [30,23,5,9,10,-1]),\n        ([99], [5], [99]),\n        ([2,6,4,7,8,9,10], [43,18,23,7,8,9,10], [46,21,23,7,8,9,10])\n    ]\n\n    results = []\n    for case in test_cases:\n        H, S_orig, S_curr = case\n        corrected_H = find_and_correct(H, S_orig, S_curr)\n        results.append(corrected_H)\n\n    # Final print statement in the exact required format.\n    print(f'[{\",\".join(map(str, results))}]')\n\nsolve()\n```", "id": "3226005"}, {"introduction": "The true power of invariants shines when they become the cornerstone of algorithmic design. This final practice moves beyond verifying and repairing to creating a novel, efficient solution for the classic Longest Increasing Subsequence problem. Your challenge is to devise an algorithm whose speed is guaranteed by a clever invariant you must identify and maintain, illustrating how this concept drives the development of advanced algorithms with performance of $O(n \\log n)$ [@problem_id:3226049].", "problem": "You are tasked with designing and implementing an online algorithm that maintains the length of the Longest Increasing Subsequence (LIS) of a stream of integers with logarithmic update time per arrival. The algorithm must be grounded in fundamental definitions of sequences and subsequences and must rely on a precise data structure invariant that guarantees correctness and efficiency.\n\nStart from the following base definitions:\n- A subsequence of a sequence is obtained by deleting zero or more elements without reordering the remaining elements.\n- An increasing subsequence is a subsequence whose elements are strictly increasing.\n- The length of the Longest Increasing Subsequence (LIS) of a sequence is the maximum length of any of its increasing subsequences.\n\nDesign a data structure that, upon receiving each new integer from the stream, updates its internal state in time proportional to $\\log n$, where $n$ is the number of elements seen so far, and can at any moment report the LIS length of the seen prefix. Your design must be justified by a single, precise invariant about an internal helper sequence or tree that is maintained after processing each element. The invariant must be sufficient to prove correctness and the $\\log n$ update time. The algorithm must treat “increasing” as strictly increasing.\n\nImplement this design as a program that processes a fixed suite of test streams and, for each stream, reports the final LIS length after consuming the entire stream. The implementation must reflect the invariant-driven design.\n\nTest suite streams:\n- Stream A: $\\left[\\,1,5,2,3,4\\,\\right]$\n- Stream B: $\\left[\\,5,4,3,2,1\\,\\right]$\n- Stream C: $\\left[\\,2,2,2,2\\,\\right]$\n- Stream D: $\\left[\\,\\,\\right]$ (empty stream)\n- Stream E: $\\left[\\,10,9,2,5,3,7,101,18\\,\\right]$\n- Stream F: $\\left[\\,0,-1,-2,-3\\,\\right]$\n- Stream G: $\\left[\\,1,3,5,4,7\\,\\right]$\n- Stream H: $\\left[\\,1,2,3,4,5\\,\\right]$\n- Stream I: $\\left[\\,3,3,3,3,4\\,\\right]$\n- Stream J: $\\left[\\,3,1,2,1,8,5,6\\,\\right]$\n\nAdditional requirements and clarifications:\n- The LIS must be strictly increasing; equal consecutive values do not increase the length.\n- All integers are within a standard $32$-bit signed range.\n- There are no physical units involved.\n- Your algorithm’s update must be $\\mathcal{O}(\\log n)$ per element using only array-based binary search or an equivalent balanced-tree structure justified by the invariant you choose. The overall time per stream should be $\\mathcal{O}(n \\log n)$ and the auxiliary space $\\mathcal{O}(n)$ in the worst case.\n- Edge cases must be handled correctly, including duplicates, negative numbers, and the empty stream.\n\nFinal output specification:\n- Your program should produce a single line of output containing the final LIS lengths for the streams A through J, in order, as a comma-separated list enclosed in square brackets, for example, $\\left[\\text{resultA},\\text{resultB},\\dots,\\text{resultJ}\\right]$.", "solution": "The problem requires the design and implementation of an online algorithm to find the length of the Longest Increasing Subsequence (LIS) of a stream of integers. The algorithm must have an update time of $\\mathcal{O}(\\log n)$ per element, where $n$ is the number of elements processed. This performance constraint necessitates a more sophisticated approach than the standard $\\mathcal{O}(n^2)$ dynamic programming solution. The required algorithm is based on a specific data structure invariant.\n\nLet the input stream be a sequence $X = \\left[\\,x_1, x_2, \\dots, x_m\\,\\right]$. We process the elements of $X$ one by one, from $i=1$ to $m$. To achieve the desired time complexity, we maintain an auxiliary array, which we denote as $T$. This array does not store the LIS itself, but rather information that allows us to determine its length efficiently.\n\nThe core of the algorithm is encapsulated in the following invariant:\n\n**Invariant:** After processing the first $i$ elements of the input stream, the auxiliary array $T$ of current length $L$ is strictly sorted, and for each $k$ from $0$ to $L-1$, the element $T[k]$ is the smallest value that can terminate a strictly increasing subsequence of length $k+1$ among the elements $x_1, \\dots, x_i$.\n\nThe length of the LIS of the prefix $x_1, \\dots, x_i$ is therefore equal to the current length of $T$, which is $L$.\n\nWe now demonstrate how this invariant is maintained and how it leads to the correct LIS length.\n\n**Proof of Correctness by Induction:**\n\n**Base Case:** Before processing any elements ($i=0$), the stream is empty. Our auxiliary array $T$ is also empty. The LIS length is $0$, which is equal to the length of $T$. The invariant holds vacuously.\n\n**Inductive Step:** Assume the invariant holds after processing the first $i-1$ elements. Let the state of the array be $T_{i-1}$ of length $L_{i-1}$. We now process the next element, $x_i$. We wish to find a place for $x_i$ in our structure. Specifically, we want to find an increasing subsequence that $x_i$ can extend. An increasing subsequence of length $k$ ends with the value $T_{i-1}[k-1]$. For $x_i$ to extend this subsequence, we must have $x_i > T_{i-1}[k-1]$.\n\nSince the array $T_{i-1}$ is sorted (by the invariant), we can use binary search to find the smallest element in $T_{i-1}$ that is greater than or equal to $x_i$. This is equivalent to finding the insertion point for $x_i$ in $T_{i-1}$ that would maintain its sorted order. Let this be index $j$. Formally, $j$ is the smallest index such that $T_{i-1}[j] \\ge x_i$. In a zero-indexed array of length $L_{i-1}$, $j$ can range from $0$ to $L_{i-1}$.\n\nWe consider two cases for the value of $j$:\n\n**Case 1: $x_i$ is greater than all elements in $T_{i-1}$.**\nIn this case, the binary search will return an index $j$ equal to the current length of the array, $L_{i-1}$. This signifies that $x_i$ can extend the longest increasing subsequence found so far. The LIS up to element $x_{i-1}$ had length $L_{i-1}$ and ended with the value $T_{i-1}[L_{i-1}-1]$. Since $x_i > T_{i-1}[L_{i-1}-1]$, we can form a new, longer increasing subsequence of length $L_{i-1}+1$ by appending $x_i$. This new subsequence is the first of its length to be discovered, so its ending element, $x_i$, is by definition the smallest possible ending element for any increasing subsequence of this new length.\nTo maintain the invariant, we append $x_i$ to $T$. The new array $T_i$ has length $L_i = L_{i-1}+1$. The LIS length has increased by $1$.\n\n**Case 2: $x_i$ is not greater than all elements in $T_{i-1}$.**\nThe binary search returns an index $j < L_{i-1}$. This means there is at least one element in $T_{i-1}$ that is greater than or equal to $x_i$, and $T_{i-1}[j]$ is the smallest among them. This tells us that $x_i$ cannot extend the longest known increasing subsequence of length $L_{i-1}$. However, $x_i$ can be used to form an increasing subsequence of length $j+1$.\nBy the definition of index $j$, we have $T_{i-1}[j-1] < x_i \\le T_{i-1}[j]$ (for $j>0$). This means $x_i$ can extend any increasing subsequence of length $j$ that ends in a value less than $x_i$ (such as the one ending in $T_{i-1}[j-1]$). By doing so, we form an increasing subsequence of length $j+1$ ending in $x_i$. According to our invariant, $T_{i-1}[j]$ was the smallest end-element for any increasing subsequence of length $j+1$. Since we have found a new subsequence of length $j+1$ ending in $x_i$, and $x_i \\le T_{i-1}[j]$, we have found a \"better\" subsequence of this length—one with a smaller tail. A smaller tail is more desirable as it increases the potential for future elements to extend this subsequence.\nTo maintain the invariant, we update $T$ by setting $T_i[j] = x_i$. The length of $T$ does not change, so $L_i = L_{i-1}$. The LIS length remains the same, but the internal state $T$ is updated to reflect the new, smallest tail for subsequences of length $j+1$.\n\nIn both cases, after updating $T$, it remains strictly sorted and upholds the invariant. After processing all $m$ elements of the stream, the final length of $T$ is the length of the LIS for the entire stream.\n\n**Algorithmic Complexity Analysis:**\n- **Time Complexity:** For each of the $n$ elements in the input stream, the algorithm performs a single binary search on the array $T$. The length of $T$ is at most $n$. A binary search takes $\\mathcal{O}(\\log k)$ time, where $k$ is the length of $T$. Thus, the time for processing each element is bounded by $\\mathcal{O}(\\log n)$. The total time complexity for a stream of length $n$ is $\\mathcal{O}(n \\log n)$.\n- **Space Complexity:** The auxiliary array $T$ stores at most one element for each element of the input in the worst case (a strictly increasing stream). Therefore, the auxiliary space complexity is $\\mathcal{O}(n)$.\n\nThis design satisfies all requirements of the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Processes a suite of test streams to find the length of the Longest Increasing Subsequence (LIS) for each.\n    The final results are printed in a single formatted line as specified.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Stream A\n        [1, 5, 2, 3, 4],\n        # Stream B\n        [5, 4, 3, 2, 1],\n        # Stream C\n        [2, 2, 2, 2],\n        # Stream D\n        [],\n        # Stream E\n        [10, 9, 2, 5, 3, 7, 101, 18],\n        # Stream F\n        [0, -1, -2, -3],\n        # Stream G\n        [1, 3, 5, 4, 7],\n        # Stream H\n        [1, 2, 3, 4, 5],\n        # Stream I\n        [3, 3, 3, 3, 4],\n        # Stream J\n        [3, 1, 2, 1, 8, 5, 6],\n    ]\n\n    results = []\n    for stream in test_cases:\n        result = calculate_lis_length(stream)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_lis_length(stream):\n    \"\"\"\n    Calculates the length of the Longest Increasing Subsequence (LIS)\n    of an integer stream using an O(n log n) algorithm.\n\n    The algorithm maintains an auxiliary array, conventionally named 'tails'.\n    The invariant is that 'tails[k]' stores the smallest ending element of all\n    strictly increasing subsequences of length k+1 found so far.\n\n    Args:\n        stream (list[int]): A list of integers representing the stream.\n\n    Returns:\n        int: The length of the LIS.\n    \"\"\"\n    if not stream:\n        return 0\n\n    # 'tails' will store the smallest tail of all increasing subsequences\n    # with length i+1 at tails[i].\n    tails = []\n\n    for num in stream:\n        # We need to find the first element in 'tails' that is >= num.\n        # This is equivalent to finding the insertion point for 'num'\n        # to maintain sorted order. np.searchsorted provides an efficient\n        # binary search implementation for this (lower_bound behavior).\n        # It operates on Python lists as well as numpy arrays.\n        idx = np.searchsorted(tails, num)\n\n        if idx == len(tails):\n            # 'num' is greater than all elements in 'tails'. This means we can\n            # extend the longest subsequence found so far. We append 'num',\n            # which starts a new, longer subsequence of length len(tails)+1.\n            tails.append(num)\n        else:\n            # We found an element tails[idx] >= num. We can form an increasing\n            # subsequence of length idx+1 that ends with 'num', which is smaller\n            # than or equal to the previous best (tails[idx]). A smaller tail is\n            # better as it leaves more room for future elements to extend it.\n            # We replace tails[idx] with 'num' to maintain the invariant.\n            tails[idx] = num\n            \n    return len(tails)\n\n# Execute the main function.\nsolve()\n```", "id": "3226049"}]}