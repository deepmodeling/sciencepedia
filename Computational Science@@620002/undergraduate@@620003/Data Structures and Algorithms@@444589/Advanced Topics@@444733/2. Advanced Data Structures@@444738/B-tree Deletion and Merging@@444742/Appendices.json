{"hands_on_practices": [{"introduction": "This exercise explores the worst-case performance of a B-tree deletion, a crucial aspect for understanding its performance guarantees. By analyzing the maximum number of merge operations a single key deletion can trigger, you will construct a \"pessimal\" tree where a deficiency at a leaf propagates up to the root. This practice provides a clear illustration of the cascading merge mechanism and its relationship with the tree's height, $h$ [@problem_id:3211412].", "problem": "A balanced multiway search tree known as a B-tree is parameterized by a minimum degree $t \\geq 2$. In a B-tree of minimum degree $t$, every internal node (except possibly the root) contains between $t-1$ and $2t-1$ keys, and hence has between $t$ and $2t$ children; the root contains between $1$ and $2t-1$ keys unless it is also a leaf, in which case it may contain $0$ keys. Define the height $h$ of the B-tree to be the number of edges on a longest simple path from the root to any leaf, so that a tree consisting of just the root has height $0$.\n\nConsider the standard deletion operation from B-trees based on the following well-tested facts and core definitions: nodes must not underflow (drop below $t-1$ keys) except possibly the root; if an underflow would occur in a child during deletion, the algorithm either redistributes a key from a sibling by rotating through the parent or combines (merges) the child with an adjacent sibling by moving exactly one separator key from the parent into the combined node. A single combine step merges exactly $2$ sibling nodes into $1$ node and reduces the parentâ€™s key-count by $1$.\n\nSuppose you perform a single key deletion in a B-tree of minimum degree $t$ and height $h$, measured as above. You are to count only the number of node merge operations that combine two siblings into one node; do not count redistributions (rotations), and do not count the final act of replacing the root by its only child as a merge (if that occurs), though any merge that immediately precedes that replacement should be counted.\n\nUnder an adversarial but valid arrangement of keys consistent with the B-tree invariants prior to the deletion, what is the theoretical maximum number of node merges that a single key deletion can cause, expressed in terms of $t$ and $h$? Express your answer as a closed-form analytic expression in the variables $t$ and $h$. No rounding is required.", "solution": "The user wants me to determine the theoretical maximum number of node merge operations caused by a single key deletion in a B-tree of minimum degree $t$ and height $h$.\n\n### Problem Validation\nThe problem statement provides a correct and standard definition of a B-tree, including the minimum degree $t$, key counts for nodes, and the definition of height $h$. The description of the B-tree deletion algorithm, specifically the handling of node underflow via redistribution (rotation) or merging, is also standard. The problem asks for the maximum number of merges under an \"adversarial but valid arrangement,\" which is a standard way of phrasing a worst-case analysis problem in algorithmics. The problem is self-contained, scientifically grounded in the theory of data structures, and well-posed. Therefore, the problem is valid and a solution can be derived.\n\n### Solution Derivation\n\nTo determine the maximum number of merge operations, we must construct a worst-case scenario. A merge operation is triggered when a node's key count drops below the minimum of $t-1$, and a key cannot be redistributed from an adjacent sibling. This happens when the node underflows to $t-2$ keys and its neighbors are also at the minimum, i.e., they have exactly $t-1$ keys. A cascade of merges, which would yield the maximum number, occurs if a merge at one level induces an underflow in the parent node, which in turn needs to be resolved by a merge, and so on up the tree.\n\nLet us define the adversarial B-tree structure that facilitates this maximum-merge cascade.\nThe height $h$ is the number of edges from the root to a leaf. This implies there are $h+1$ levels of nodes, which we can index from level $0$ (the root) to level $h$ (the leaves).\nThe worst-case scenario is a \"skinny\" B-tree where all nodes along a specific path from the root to a leaf are minimally filled.\n1.  We select a path of nodes $N_0, N_1, \\dots, N_h$, where $N_0$ is the root, $N_1$ is a child of $N_0$, and so on, until the leaf $N_h$.\n2.  For the cascade to propagate fully, every node $N_i$ for $i \\in \\{0, 1, \\dots, h-1\\}$ on this path must have the minimum number of keys for its type. For an internal node other than the root, this is $t-1$ keys. For the root, the minimum is $1$ key. So we assume $N_i$ has $t-1$ keys for $i \\in \\{1, \\dots, h-1\\}$ and the root $N_0$ has $1$ key.\n3.  The leaf node $N_h$ where the deletion will occur must also be minimal, containing $t-1$ keys.\n4.  Crucially, to force a merge at each level instead of a rotation, the siblings of the nodes on our path must also be minimal. That is, for each node $N_i$ that will underflow, its adjacent sibling $S_i$ must have exactly $t-1$ keys.\n\nWith this B-tree configuration, let's trace the effects of deleting a single key from the leaf node $N_h$.\n\n**Deletion from Leaf and Initial Merge (Level $h$)**\nWe delete one key from the leaf node $N_h$.\n*   Initial state of $N_h$: $t-1$ keys.\n*   State after deletion: $t-2$ keys. Since $t \\geq 2$, $t-2  t-1$, so the node $N_h$ underflows.\n*   To fix the underflow, we examine an adjacent sibling of $N_h$, let's call it $S_h$. By our adversarial design, $S_h$ is also minimal with $t-1$ keys. A rotation is not possible.\n*   A merge operation is performed. The node $N_h$, its sibling $S_h$, and the separator key from their parent $N_{h-1}$ are combined into a single new node. This constitutes the **first merge**. The new merged node contains $(t-2) + (t-1) + 1 = 2t-2$ keys, which is a valid number of keys (since $2t-2 \\leq 2t-1$).\n\n**Propagation of Underflow and Cascade of Merges**\nThe merge at level $h$ required pulling a separator key down from the parent node, $N_{h-1}$.\n*   Initial state of $N_{h-1}$: $t-1$ keys (by our adversarial design).\n*   State after its key is pulled down: $(t-1)-1 = t-2$ keys. The node $N_{h-1}$ at level $h-1$ now underflows.\n*   To fix this underflow, we examine a sibling of $N_{h-1}$, say $S_{h-1}$. This sibling is also minimal with $t-1$ keys. A rotation is impossible.\n*   A merge is performed between $N_{h-1}$ and $S_{h-1}$, pulling down a separator key from their parent, $N_{h-2}$. This is the **second merge**.\n\nThis process continues to propagate up the tree. A merge operation at level $i$ (where $1  i \\leq h$) is caused by an underflow at that level. This merge consumes a key from the parent at level $i-1$, causing it to underflow in turn, because it was also minimal. This triggers a merge at level $i-1$.\n\n**Final Merge (Level 1)**\nThe cascade proceeds up the ancestor path of the original deletion.\n*   An underflow is triggered at level $1$ in node $N_1$.\n*   Node $N_1$ had $t-1$ keys, but the merge at level $2$ caused it to have $t-2$ keys.\n*   Its sibling, $S_1$, also has $t-1$ keys. They must merge.\n*   This merge operation pulls a key from their parent, the root node $N_0$. This is a merge between two children of the root.\n\n**Counting the Merges**\nA merge operation occurs at each level, starting from the leaf level ($h$) and cascading up to the level of the root's children (level $1$).\n*   Merge 1: Occurs at level $h$.\n*   Merge 2: Occurs at level $h-1$.\n*   ...\n*   Merge $i$: Occurs at level $h-i+1$.\n*   ...\n*   Final Merge: Occurs at level $1$.\n\nThe total number of merges is the number of levels from $1$ to $h$, inclusive. The count is $h - 1 + 1 = h$.\n\nAfter the final merge at level $1$, the root node $N_0$ loses a key. In our worst-case setup, the root had only $1$ key. This key is pulled down into the merged node. The root is now left with $0$ keys and a single child. The B-tree structure then requires the empty root to be removed, and its single child to become the new root. The problem statement explicitly says not to count this final tree-height reduction step as a merge. Thus, the chain of merge operations stops after the one at level $1$.\n\nThe maximum number of merges is therefore equal to the number of merges in this cascade. This number is exactly $h$. This holds for any $t \\geq 2$. For instance, if $h=1$, the deletion from a minimal leaf causes one merge with its sibling, and the root loses a key. The total is $1$ merge. If $h=0$, the tree is a single node, no merges are possible, so the count is $0$. The formula holds.\n\nThe maximum number of merges depends only on the height $h$ and not on the minimum degree $t$. The parameter $t$ defines the condition for being minimal, but the length of the potential cascade is determined by the height of the tree.\n\nTherefore, the theoretical maximum number of node merges is $h$.", "answer": "$$\n\\boxed{h}\n$$", "id": "3211412"}, {"introduction": "While a single deletion can be costly, B-trees are generally resilient due to flexible rebalancing strategies. This problem challenges you to analyze the tipping point between redistribution and merging by determining how many keys must be removed from a saturated tree to guarantee a merge must occur. This thought experiment illuminates the role of node occupancy and the minimum degree, $t$, in maintaining balance and provides insight into the tree's overall robustness [@problem_id:3211371].", "problem": "Consider a perfectly balanced B-tree of minimum degree $t$, meaning every node except the root contains at least $t-1$ keys and at most $2t-1$ keys, while the root contains at least $1$ key (unless it is a leaf) and at most $2t-1$ keys. The tree is full and saturated: every internal node has exactly $2t$ children and every node initially contains exactly $2t-1$ keys. Let the height of the tree be $h \\geq 1$, where height counts edges on a longest root-to-leaf path.\n\nA deletion in a B-tree is followed by standard rebalancing: if a node becomes deficient (fewer than $t-1$ keys for a non-root node), the algorithm first attempts to fix the deficiency by borrowing a key from an adjacent sibling through the parent, provided that sibling has at least $t$ keys (so it can donate while respecting the minimum). If no sibling can donate (i.e., all siblings have exactly $t-1$ keys), the algorithm merges the deficient node with an adjacent sibling, moving a separator key down from the parent to form a single node; this is called a merge.\n\nSuppose an adversary chooses deletions one by one to postpone merges as long as possible by taking advantage of redistributions whenever they are available. Derive, in closed form, the minimum number of key deletions $N$ (as a function of $t$ and $h$) that guarantees at least one merge must occur at some point in the deletion process, regardless of the adversaryâ€™s choices. Your answer must be a single symbolic expression in terms of $t$ and $h$.", "solution": "The problem statement is deemed valid. It is scientifically grounded within the domain of computer science, specifically data structures and algorithms. The definitions for the B-tree, its initial state, and the rules for deletion and rebalancing are consistent with standard literature. The problem is well-posed, objective, and self-contained, admitting a unique, derivable solution.\n\nThe problem asks for the minimum number of key deletions, $N$, that guarantees at least one merge operation will occur in a specific, initially saturated B-tree. This is a worst-case analysis problem. The number $N$ is one greater than the maximum number of deletions an adversary can perform *without* triggering a merge. Let this maximum number of deletions be $M$. Then, $N = M + 1$.\n\nFirst, we characterize the initial state of the B-tree.\nThe tree has a minimum degree of $t$ and a height of $h \\geq 1$. The height $h$ is the number of edges on the longest root-to-leaf path, which implies there are $h+1$ levels of nodes, from level $0$ (the root) to level $h$ (the leaves).\nThe tree is \"full and saturated,\" meaning every internal node has the maximum number of children, $2t$, and every node in the tree contains the maximum number of keys, $2t-1$.\nThe number of nodes at level $l$ is $(2t)^l$. The total number of nodes in the tree, $N_{\\text{total}}$, is the sum over all levels from $0$ to $h$:\n$$N_{\\text{total}} = \\sum_{l=0}^{h} (2t)^l = \\frac{(2t)^{h+1}-1}{2t-1}$$\nThis is the formula for a geometric series.\n\nNext, we analyze the conditions for a merge. A merge operation is part of the rebalancing procedure that is triggered when a node becomes deficient. The problem states that a node is \"deficient (fewer than $t-1$ keys for a non-root node)\". A merge is performed on a deficient node if redistribution is not possible. Redistribution requires an adjacent sibling to have at least $t$ keys (i.e., more than the minimum). A merge is therefore forced if a non-root node becomes deficient and all of its adjacent siblings have exactly $t-1$ keys.\n\nThe adversary's strategy to postpone a merge is to perform deletions in such a way that if a node becomes deficient, it always has a sibling with at least $t$ keys available for redistribution. The problem asks for the number of deletions that guarantees a merge *regardless* of the adversary's choices. This threshold is reached when the tree is depleted to a state where the next deletion will inevitably create a deficient node whose siblings are all at their minimum capacity.\n\nTo find the maximum number of deletions possible without a merge, $M$, we must identify the maximum number of keys that can be removed from the tree before any non-root node becomes deficient. A non-root node is not deficient as long as it contains at least $t-1$ keys. The root node can, by the standard definition of a B-tree of minimum degree $t$, contain as few as $1$ key (as long as it is not a leaf, a condition satisfied since $h \\ge 1$). The definition of \"deficient\" in the problem is explicitly given for non-root nodes, so we apply the standard minimum for the root.\n\nInitially, every node has $2t-1$ keys. We can calculate the \"deletable capacity\" for each node, which is the number of keys that can be removed before it reaches its minimum allowed count without triggering a rebalancing.\n1.  For the single root node: The minimum number of keys is $1$. The deletable capacity is $(2t-1) - 1 = 2t-2$ keys.\n2.  For any non-root node: The minimum number of keys is $t-1$. The deletable capacity is $(2t-1) - (t-1) = t$ keys.\n\nThe adversary can perform deletions up to this capacity for every node in the tree without any node becoming deficient, and thus without triggering any rebalancing (neither redistribution nor merge). The total number of such deletions, $M$, is the sum of the deletable capacities of all nodes.\n\nThe number of non-root nodes is $N_{\\text{non-root}} = N_{\\text{total}} - 1$.\nSo, the maximum number of deletions without a guaranteed merge is:\n$$M = (\\text{deletable capacity of root}) + (\\text{number of non-root nodes}) \\times (\\text{deletable capacity of a non-root node})$$\n$$M = (2t-2) + (N_{\\text{total}} - 1) \\times t$$\nSubstituting the expression for $N_{\\text{total}}$:\n$$M = 2t - 2 + t \\left( \\frac{(2t)^{h+1}-1}{2t-1} - 1 \\right)$$\nLet's simplify this expression:\n$$M = 2t - 2 + t \\cdot N_{\\text{total}} - t$$\n$$M = t \\cdot N_{\\text{total}} + t - 2$$\n$$M = t \\left( \\frac{(2t)^{h+1}-1}{2t-1} \\right) + t - 2$$\nAfter these $M$ deletions, the tree is in a critical state: the root has $1$ key, and every other node has exactly $t-1$ keys. No merge has occurred yet.\n\nNow, consider the $(M+1)$-th deletion. Let an arbitrary key be chosen for deletion.\n-   Case 1: The key is in a leaf node $L$. Deleting the key reduces $L$'s key count from $t-1$ to $t-2$. Since $L$ is a non-root node (as $h \\ge 1$), it is now deficient. All of its siblings are also non-root nodes and, in this critical state, possess exactly $t-1$ keys. None have $\\ge t$ keys, so redistribution is impossible. A merge is therefore guaranteed.\n-   Case 2: The key is in an internal node $I$. The key must be replaced by its in-order predecessor (or successor), which resides in a leaf node, say $L'$. This operation is equivalent to deleting the key from $L'$. The leaf $L'$ now has its key count reduced from $t-1$ to $t-2$, making it deficient. As in Case 1, its siblings all have $t-1$ keys, forcing a merge.\n\nIn every possible scenario, the $(M+1)$-th deletion forces a merge. Therefore, the minimum number of deletions to guarantee a merge is $N = M+1$.\n$$N = M + 1 = \\left( t \\left( \\frac{(2t)^{h+1}-1}{2t-1} \\right) + t - 2 \\right) + 1$$\n$$N = t \\left( \\frac{(2t)^{h+1}-1}{2t-1} \\right) + t - 1$$\nThis is the final closed-form expression for the minimum number of deletions that guarantees a merge.", "answer": "$$\\boxed{t \\left( \\frac{(2t)^{h+1}-1}{2t-1} \\right) + t - 1}$$", "id": "3211371"}, {"introduction": "Moving from analysis to design, this final practice requires you to implement an optimized strategy for batch deletions from a single leaf node. Real-world applications often involve bulk operations, where naive, one-by-one deletions are inefficient. By designing a rebalancing algorithm that intelligently performs multiple rotations based on sibling capacity before resorting to a merge, you will apply theoretical knowledge to build a more performant B-tree, bridging the gap between abstract concepts and practical implementation [@problem_id:3211492].", "problem": "You must design and implement a complete program that models a $B$-tree supporting a \"batch deletion\" operation in which $k$ keys are deleted from the same leaf node in one step, and then optimizes the subsequent merging and rebalancing process. Use the following foundational base for $B$-trees, and derive your algorithm from these principles rather than shortcut formulas.\n\nFundamental base and invariants:\n- A $B$-tree of minimum degree $t$ stores sorted keys in nodes, with each non-root node containing between $t-1$ and $2t-1$ keys, and each internal node containing between $t$ and $2t$ children. The root node may contain between $1$ and $2t-1$ keys if it is internal, and may be a leaf containing between $1$ and $2t-1$ keys or be empty if the tree has no keys.\n- All leaves reside at the same depth. Keys in the subtree of a child between two adjacent parent keys must be strictly within the corresponding interval defined by those parent keys.\n- Insertion splits when a node would exceed $2t-1$ keys, moving the median key up. Deletion from a leaf may create an underflow when a node falls below $t-1$ keys, requiring rotations (borrows) from siblings via parent separators when possible, or merging with a sibling via a parent separator when borrowing cannot fix the deficiency. Merging can propagate a deficiency upward to the parent, repeating the process.\n\nTask:\n- Implement a $B$-tree with minimum degree $t$ that supports insertion of integer keys and a batch deletion operation restricted to deleting $k$ keys that are all in the same leaf node. You must implement an optimized batch rebalancing strategy that, after removing $k$ keys from the leaf, performs multi-rotation (borrowing) from siblings when possible before merging, selecting the number of rotations based on sibling surplus capacities so as to minimize the number of merges. If rotations cannot satisfy the deficiency, perform a single merge with an adjacent sibling and then recursively fix any deficiency that propagates upward. For rotations, apply the standard $B$-tree rotation semantics: borrowing from the left replaces the parent separator with the left siblingâ€™s largest key and moves the parent separator down into the underflowing node; borrowing from the right replaces the parent separator with the right siblingâ€™s smallest key and moves the parent separator down into the underflowing node. For merging, move the parent separator down between the two nodes being merged and concatenate keys (and children if internal).\n- Your program must also verify that, after batch deletion and rebalancing, the $B$-tree invariants hold: key counts per node are within bounds, keys are sorted, internal nodes have one more child than keys, all leaves have the same depth, and the key ranges are respected.\n\nInterface design for test suite:\n- The program must construct initial $B$-trees by inserting given integer sequences, then perform the batch deletion on the leaf containing a specified pivot key. For the batch deletion, delete the $k$ smallest keys currently in that leaf. A boolean flag may request pre-reduction of both immediate siblings of the target leaf to the minimum key count $t-1$ before the batch deletion, to exercise merge-heavy behavior.\n- For each test case, your program must report the following as a list: the total number of merges performed (an integer), the total number of rotations performed (an integer), the final height of the $B$-tree (an integer, where a tree with a single leaf has height $1$), and a boolean indicating whether the $B$-tree invariants hold after all operations.\n\nTest suite:\n- Case $1$: $t=3$, insert the integers from $1$ to $30$, pivot key $11$, delete $k=3$ keys from that leaf, with pre-reduction disabled.\n- Case $2$: $t=3$, insert the integers from $1$ to $30$, pivot key $11$, delete $k=4$ keys from that leaf, with pre-reduction disabled.\n- Case $3$: $t=3$, insert the integers from $1$ to $30$, pivot key $11$, delete $k=4$ keys from that leaf, with pre-reduction enabled (reduce both siblings of the target leaf to $t-1$ keys before the batch deletion).\n- Case $4$: $t=2$, insert the integers from $1$ to $10$, pivot key $6$, delete $k=3$ keys from that leaf, with pre-reduction enabled.\n\nRequired output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and must itself be a list in the order $[$merges, rotations, height, valid$]$. For example: $[[m_1,r_1,h_1,v_1],[m_2,r_2,h_2,v_2],\\dots]$.", "solution": "The design must begin from the core invariants of a $B$-tree of minimum degree $t$. Each non-root node must contain at least $t-1$ keys and at most $2t-1$ keys, and internal nodes must have one more child than keys. The root must have at least $1$ key unless the tree is empty. All leaves are at the same depth, and key intervals per child are dictated by the parent separators. Any algorithm for deletion must restore these bounds whenever a node underflows.\n\nWhen deleting $k$ keys from a single leaf at once, the first step is to remove those $k$ keys from the leaf. Let the leaf initially have $m$ keys. After deletion, it has $m-k$ keys. If $m-k \\ge t-1$ (and the leaf is not the root), there is no underflow and we are done. Otherwise, there is a deficiency $d = (t-1) - (m-k) > 0$ that must be corrected by either borrowing from siblings via parent rotations or merging with a sibling and applying recursive fixes upward.\n\nOptimizing rebalancing after a batch deletion relies on analyzing sibling surplus capacities in one local computation rather than performing $k$ separate deletions. If the parent index of the leaf is $i$, define the left sibling $L$ (if $i>0$) and right sibling $R$ (if $i\\text{degree}-1$). For a sibling $S$ with $\\ell_S$ keys, its surplus over the minimum is $\\max(0, \\ell_S-(t-1))$. The total available surplus for borrowing is the sum of the left and right surpluses. Each borrow operation corresponds to a standard $B$-tree rotation:\n\n- Borrowing from the left sibling uses the parent key $K_p = \\text{parent.keys}[i-1]$: move $K_p$ down into the underflowing node, and replace $K_p$ in the parent with the left siblingâ€™s largest key; in an internal node case, also transfer the left siblingâ€™s rightmost child pointer to become the new leftmost child of the underflowing node.\n- Borrowing from the right sibling uses the parent key $K_p = \\text{parent.keys}[i]$: move $K_p$ down into the underflowing node, and replace $K_p$ in the parent with the right siblingâ€™s smallest key; in an internal node case, also transfer the right siblingâ€™s leftmost child pointer to become the new rightmost child of the underflowing node.\n\nIf the sum of available surplus exceeds or equals the deficiency $d$, then a multi-rotation sequence that consumes the needed number of keys can restore the leaf to the minimum without any merge. Borrow greedily first from the left sibling (up to its surplus) and then from the right sibling to satisfy $d$, because rotations are strictly cheaper than merges: a rotation is a local constant-time operation $O(1)$, whereas a merge reduces the number of children of the parent and may cause parent underflow that must be repaired recursively up the tree.\n\nIf the total surplus is insufficient to satisfy $d$, perform a single merge with an adjacent sibling. Choose the side that exists; a single merge maximizes the number of keys added to the underflowing node with minimal structural changes. A merge involves moving the appropriate parent separator key down between the two nodes and concatenating the keys (and children if internal), then removing the separator and the redundant child from the parent. After a merge, the parent loses one key and one child; if the parent now underflows (has fewer than $t-1$ keys, or fewer than $1$ key if it is the root and internal), we must recursively apply the same borrow-or-merge logic at the parent level. This can cascade up to the root. If the root becomes empty and has a single child, collapse the root into its child, reducing the height by $1$.\n\nCorrectness follows from maintaining the $B$-tree invariants at each step. Rotations preserve sortedness within nodes and the global key interval property because the parent separators maintain their role and the borrowed keys move through the parent exactly as in standard $B$-tree deletion. Merging preserves the interval property because the parent separator moved down sequences keys between two adjacent children. Recursion upward ensures that any parent underflow is repaired in a manner consistent with $B$-tree rules. Because all operations occur along a single root-to-leaf path and potentially cascade upward, the time complexity of one batch deletion is $O(h + r + m)$ where $h$ is the tree height, $r$ is the number of rotations, and $m$ is the number of merges; with the optimization, the number of merges is minimized subject to the sibling surplus constraints, and rotations are bounded by the surplus available. Structurally, each rotation is $O(1)$ and each merge is $O(1)$ at a node, making the total work $O(h)$ in typical balanced scenarios.\n\nFor the test suite, the program constructs the $B$-tree via insertion of integers, locates the leaf containing the specified pivot key, and deletes the $k$ smallest keys inside that leaf. A flag optionally reduces both immediate siblings of the target leaf to exactly $t-1$ keys before the batch deletion to ensure borrowing is impossible and a merge is required, stressing the upward propagation logic. After each case, the program outputs the number of merges, the number of rotations, the final height (counting the root level as height $1$), and a boolean for validity. The final output aggregates the four cases into a single line list as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass BTreeNode:\n    def __init__(self, t, leaf=False):\n        self.t = t\n        self.keys = []\n        self.children = []\n        self.leaf = leaf\n\n    def __repr__(self):\n        return f\"Node(keys={self.keys}, leaf={self.leaf})\"\n\n\nclass BTree:\n    def __init__(self, t):\n        self.t = t\n        self.root = BTreeNode(t, leaf=True)\n        self.rotations = 0\n        self.merges = 0\n\n    # Standard B-tree insertion (CLRS style)\n    def insert(self, k):\n        root = self.root\n        if len(root.keys) == 2*self.t - 1:\n            s = BTreeNode(self.t, leaf=False)\n            s.children.append(root)\n            self._split_child(s, 0)\n            self.root = s\n            self._insert_nonfull(s, k)\n        else:\n            self._insert_nonfull(root, k)\n\n    def _insert_nonfull(self, x, k):\n        i = len(x.keys) - 1\n        if x.leaf:\n            # insert in sorted order\n            x.keys.append(k)\n            i = len(x.keys) - 2\n            while i >= 0 and x.keys[i] > k:\n                x.keys[i+1] = x.keys[i]\n                i -= 1\n            x.keys[i+1] = k\n        else:\n            while i >= 0 and k  x.keys[i]:\n                i -= 1\n            i += 1\n            if len(x.children[i].keys) == 2*self.t - 1:\n                self._split_child(x, i)\n                if k > x.keys[i]:\n                    i += 1\n            self._insert_nonfull(x.children[i], k)\n\n    def _split_child(self, x, i):\n        t = self.t\n        y = x.children[i]\n        z = BTreeNode(t, leaf=y.leaf)\n        # median key at index t-1\n        median = y.keys[t-1]\n        # distribute keys\n        z.keys = y.keys[t:]\n        y.keys = y.keys[:t-1]\n        if not y.leaf:\n            z.children = y.children[t:]\n            y.children = y.children[:t]\n        x.children.insert(i+1, z)\n        x.keys.insert(i, median)\n\n    # Search returns node containing key or leaf where it would be inserted\n    def search(self, k):\n        return self._search_node(self.root, k)\n\n    def _search_node(self, x, k):\n        i = 0\n        while i  len(x.keys) and k > x.keys[i]:\n            i += 1\n        if i  len(x.keys) and k == x.keys[i]:\n            return x, i\n        if x.leaf:\n            return x, None\n        else:\n            return self._search_node(x.children[i], k)\n\n    # Find parent of a given node and child's index\n    def find_parent(self, current, target):\n        if current.leaf:\n            return None, None\n        for i, child in enumerate(current.children):\n            if child is target:\n                return current, i\n            if not child.leaf:\n                p, idx = self.find_parent(child, target)\n                if p is not None:\n                    return p, idx\n            else:\n                # continue\n                pass\n        # Try descending anyway based on key ranges to find parent in deeper subtrees\n        for i, child in enumerate(current.children):\n            if child is target:\n                return current, i\n            p, idx = self.find_parent(child, target)\n            if p is not None:\n                return p, idx\n        return None, None\n\n    # Helpers for rotations\n    def rotate_from_left(self, parent, idx):\n        # Borrow from left sibling into child at idx\n        left = parent.children[idx-1]\n        node = parent.children[idx]\n        # Move parent separator down into node, replace parent separator with left's max key\n        # Also move child pointer for internal nodes\n        if node.leaf:\n            # insert parent key at beginning\n            node.keys.insert(0, parent.keys[idx-1])\n            # replace parent key with left's last key\n            parent.keys[idx-1] = left.keys.pop()\n        else:\n            # node gains parent.sep at beginning\n            node.keys.insert(0, parent.keys[idx-1])\n            # node must take left's last child to the front\n            child_to_move = left.children.pop()\n            node.children.insert(0, child_to_move)\n            # parent sep replaced with left's last key\n            parent.keys[idx-1] = left.keys.pop()\n        self.rotations += 1\n\n    def rotate_from_right(self, parent, idx):\n        right = parent.children[idx+1]\n        node = parent.children[idx]\n        if node.leaf:\n            # append parent key\n            node.keys.append(parent.keys[idx])\n            # replace parent key with right's first key\n            parent.keys[idx] = right.keys.pop(0)\n        else:\n            node.keys.append(parent.keys[idx])\n            child_to_move = right.children.pop(0)\n            node.children.append(child_to_move)\n            parent.keys[idx] = right.keys.pop(0)\n        self.rotations += 1\n\n    # Merge helpers\n    def merge_with_left(self, parent, idx):\n        # Merge child at idx with left sibling at idx-1\n        left = parent.children[idx-1]\n        node = parent.children[idx]\n        # move parent separator down\n        left.keys.append(parent.keys[idx-1])\n        # concatenate node\n        left.keys.extend(node.keys)\n        if not left.leaf:\n            left.children.extend(node.children)\n        # remove from parent\n        parent.keys.pop(idx-1)\n        parent.children.pop(idx)\n        self.merges += 1\n        return left  # merged node reference\n\n    def merge_with_right(self, parent, idx):\n        node = parent.children[idx]\n        right = parent.children[idx+1]\n        # move parent separator down\n        node.keys.append(parent.keys[idx])\n        node.keys.extend(right.keys)\n        if not node.leaf:\n            node.children.extend(right.children)\n        parent.keys.pop(idx)\n        parent.children.pop(idx+1)\n        self.merges += 1\n        return node\n\n    # Fix underflow after deletions\n    def fix_underflow(self, node):\n        # If node is root, handle special cases\n        while True:\n            if node is self.root:\n                # If root is internal and empty with one child, collapse\n                if not node.leaf and len(node.keys) == 0 and len(node.children) == 1:\n                    self.root = node.children[0]\n                # Leaf root may be empty if tree emptied; nothing else to do\n                return\n            parent, idx = self.find_parent(self.root, node)\n            if parent is None:\n                # Should not happen\n                return\n            min_keys = (self.t - 1)\n            if len(node.keys) >= min_keys:\n                return\n            deficiency = min_keys - len(node.keys)\n            # calculate available surplus from siblings\n            # Try left\n            if idx - 1 >= 0:\n                left = parent.children[idx-1]\n                avail_left = len(left.keys) - (self.t - 1)\n            else:\n                left = None\n                avail_left = 0\n            # Try right\n            if idx + 1  len(parent.children):\n                right = parent.children[idx+1]\n                avail_right = len(right.keys) - (self.t - 1)\n            else:\n                right = None\n                avail_right = 0\n            # Borrow as much as possible\n            borrow_left = min(deficiency, max(0, avail_left))\n            for _ in range(borrow_left):\n                self.rotate_from_left(parent, idx)\n                deficiency -= 1\n                if deficiency == 0:\n                    break\n            if deficiency > 0:\n                borrow_right = min(deficiency, max(0, avail_right))\n                for _ in range(borrow_right):\n                    self.rotate_from_right(parent, idx)\n                    deficiency -= 1\n                    if deficiency == 0:\n                        break\n            # If still deficient, merge\n            if len(node.keys)  min_keys:\n                if left is not None:\n                    merged = self.merge_with_left(parent, idx)\n                    # After merge, set node to parent to check if parent underflows\n                    node = parent\n                    continue\n                elif right is not None:\n                    merged = self.merge_with_right(parent, idx)\n                    node = parent\n                    continue\n                else:\n                    # No siblings? Should not happen in B-tree except at root\n                    node = parent\n                    continue\n            else:\n                return\n\n    # Batch delete k smallest keys from leaf containing pivot key\n    def batch_delete_from_leaf_by_pivot(self, pivot_key, k, pre_reduce_siblings_to_min=False):\n        # Find leaf containing pivot key\n        node, idx = self.search(pivot_key)\n        # Ensure node is the leaf containing the key\n        # If the found node is internal (unlikely since search returns leaf when not found),\n        # traverse to leaf containing pivot_key\n        if not node.leaf:\n            # descend to the child where pivot would be\n            x = node\n            i = 0\n            while i  len(x.keys) and pivot_key > x.keys[i]:\n                i += 1\n            node = x.children[i]\n            while not node.leaf:\n                i = 0\n                while i  len(node.keys) and pivot_key > node.keys[i]:\n                    i += 1\n                node = node.children[i]\n        # Optionally pre-reduce siblings to minimum keys\n        if pre_reduce_siblings_to_min:\n            parent, child_idx = self.find_parent(self.root, node)\n            if parent is not None:\n                # Reduce left sibling\n                if child_idx - 1 >= 0:\n                    left = parent.children[child_idx-1]\n                    # delete from left to reach t-1 keys\n                    excess = len(left.keys) - (self.t - 1)\n                    if excess > 0:\n                        # delete excess smallest keys in left\n                        to_delete = left.keys[:excess]\n                        for key in to_delete:\n                            # Remove key from left\n                            left.keys.remove(key)\n                        # Fix underflow if created (shouldn't create underflow by removing surplus)\n                        # But if we removed too many due to earlier structure, still fix\n                        self.fix_underflow(left)\n                # Reduce right sibling\n                if child_idx + 1  len(parent.children):\n                    right = parent.children[child_idx+1]\n                    excess = len(right.keys) - (self.t - 1)\n                    if excess > 0:\n                        to_delete = right.keys[:excess]\n                        for key in to_delete:\n                            right.keys.remove(key)\n                        self.fix_underflow(right)\n        # Now delete k smallest keys in the target leaf\n        to_remove = node.keys[:min(k, len(node.keys))]\n        for key in to_remove:\n            # Remove key\n            node.keys.remove(key)\n        # Fix potential underflow\n        self.fix_underflow(node)\n\n    # Validation of B-tree invariants\n    def validate(self):\n        if self.root is None:\n            return True\n        # Check leaf depths\n        leaf_depths = []\n\n        def dfs(node, depth):\n            # keys sorted\n            if any(node.keys[i] >= node.keys[i+1] for i in range(len(node.keys)-1)):\n                return False\n            # bounds\n            if node is self.root:\n                # root can be leaf or internal\n                if node.leaf:\n                    # allow empty root leaf or between 1 and 2t-1 keys\n                    if len(node.keys)  0 or len(node.keys) > 2*self.t - 1:\n                        return False\n                else:\n                    if len(node.keys)  1 or len(node.keys) > 2*self.t - 1:\n                        return False\n            else:\n                if len(node.keys)  self.t - 1 or len(node.keys) > 2*self.t - 1:\n                    return False\n            if not node.leaf:\n                if len(node.children) != len(node.keys) + 1:\n                    return False\n                for child in node.children:\n                    if child is None:\n                        return False\n            else:\n                leaf_depths.append(depth)\n            # recurse\n            if not node.leaf:\n                for child in node.children:\n                    if not dfs(child, depth+1):\n                        return False\n            return True\n\n        ok = dfs(self.root, 1)\n        if not ok:\n            return False\n        # All leaves same depth\n        if len(leaf_depths) == 0:\n            return True\n        return all(d == leaf_depths[0] for d in leaf_depths)\n\n    def height(self):\n        h = 0\n        node = self.root\n        while node is not None:\n            h += 1\n            if node.leaf:\n                break\n            node = node.children[0]\n        return h\n\n\ndef build_btree_with_range(t, start, end):\n    bt = BTree(t)\n    for k in range(start, end+1):\n        bt.insert(k)\n    return bt\n\n\ndef run_test_case(t, insert_range, pivot, k, pre_reduce=False):\n    bt = build_btree_with_range(t, insert_range[0], insert_range[1])\n    # perform batch deletion\n    bt.batch_delete_from_leaf_by_pivot(pivot, k, pre_reduce_siblings_to_min=pre_reduce)\n    # collect results\n    merges = bt.merges\n    rotations = bt.rotations\n    height = bt.height()\n    valid = bt.validate()\n    return [merges, rotations, height, valid]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: t=3, insert 1..30, pivot 11, k=3, no pre-reduction\n        (3, (1, 30), 11, 3, False),\n        # Case 2: t=3, insert 1..30, pivot 11, k=4, no pre-reduction\n        (3, (1, 30), 11, 4, False),\n        # Case 3: t=3, insert 1..30, pivot 11, k=4, pre-reduction enabled\n        (3, (1, 30), 11, 4, True),\n        # Case 4: t=2, insert 1..10, pivot 6, k=3, pre-reduction enabled\n        (2, (1, 10), 6, 3, True),\n    ]\n\n    results = []\n    for case in test_cases:\n        t, insert_range, pivot, k, pre_reduce = case\n        result = run_test_case(t, insert_range, pivot, k, pre_reduce)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3211492"}]}