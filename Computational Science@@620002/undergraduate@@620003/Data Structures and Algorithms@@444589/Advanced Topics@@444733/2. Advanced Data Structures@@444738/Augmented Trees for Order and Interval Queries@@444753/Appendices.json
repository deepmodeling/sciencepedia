{"hands_on_practices": [{"introduction": "This first exercise provides a gentle yet powerful introduction to the concept of tree augmentation. You will tackle the problem of finding the farthest pair of points in a dynamic one-dimensional set, which simplifies to finding the minimum and maximum values. By augmenting each node to store the minimum and maximum keys within its subtree, you will see how a query over the entire dataset can be answered in constant $O(1)$ time, demonstrating the core principle of making global properties locally available at the root [@problem_id:3210318].", "problem": "You are given a dynamic finite set of one-dimensional integer points on the real line. The goal is to support three operations on the set: insert a point, delete a point, and query the two points in the current set that are farthest apart. You must design and implement a data structure based on an augmented balanced Binary Search Tree (BST) to achieve query time $O(\\log n)$ for a set of size $n$, under arbitrary sequences of insertions and deletions.\n\nStart from the following foundational base:\n- A Binary Search Tree (BST) maintains the invariant that for any node with key $k$, all keys in its left subtree are < k and all keys in its right subtree are >= k.\n- A balanced BST maintains height $O(\\log n)$, which yields $O(\\log n)$ search, insertion, and deletion via tree rotations and structural adjustments.\n- In a totally ordered set on the real line, the difference between any two points is monotonic with respect to ordering.\n\nYour task is to derive and implement an augmented tree that maintains, at each node, enough information to answer the farthest pair query on the current set in $O(\\log n)$ time. The augmentation must be maintained under insertions and deletions, and the resulting operations must preserve the asymptotic complexity guarantees consistent with balanced BST design.\n\nAssume the following rules for the dynamic set:\n- Points are integers, and the set contains no duplicates. An insertion of an already present point leaves the set unchanged.\n- Deleting a point that is not present leaves the set unchanged.\n- When the set has at least two points, the \"farthest apart\" pair is the pair of points with minimum and maximum value. When the set has exactly one point $x$, the farthest pair is defined as $x$ and $x$, with distance $0$. When the set is empty, define the farthest pair result as the triple $[0,0,0]$.\n\nYour program must implement the data structure and process the following test suite of operation sequences. For each test case, apply all operations to an initially empty set, and then output the farthest pair result as a list $[m,M,d]$, where $m$ is the minimum point in the final set, $M$ is the maximum point in the final set, and $d = M - m$ is the distance. If the final set is empty, output $[0,0,0]$.\n\nTest suite (each bullet is a test case that starts from an empty set):\n- Insert $3$, insert $-2$, insert $5$.\n- Insert $10$.\n- (No operations; the set remains empty.)\n- Insert $-100$, insert $-50$, insert $-75$, delete $-75$, insert $-60$, delete $-100$, insert $-10$.\n- Insert $-1000000000$, insert $1000000000$, insert $0$, delete $0$.\n- Insert $4$, insert $4$, delete $7$, insert $-1$, insert $9$, delete $4$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must itself be a list $[m,M,d]$. For example, a valid output format is $[[m_1,M_1,d_1],[m_2,M_2,d_2],\\dots]$ with no extra whitespace or text.", "solution": "We begin by establishing a mathematical foundation for the farthest pair on the real line. Let $S$ be a finite subset of $\\mathbb{Z}$ (integers considered as points on the real line). Define the distance between two points $a,b \\in S$ as $|b-a|$. Since the set is totally ordered, enumerate $S$ in nondecreasing order as $x_1 \\le x_2 \\le \\dots \\le x_n$. For any pair $x_i, x_j$ with $i \\le j$, observe that $|x_j - x_i| = x_j - x_i$ because $x_j \\ge x_i$. By monotonicity, for fixed $x_i$, $x_j - x_i$ is maximized at $x_j = x_n$, and for fixed $x_j$, $x_j - x_i$ is maximized at $x_i = x_1$. Therefore, the farthest pair is always $(x_1, x_n)$, and its distance is $x_n - x_1$. This conclusion derives directly from the ordered structure of the real line and does not rely on any shortcut formula; it follows from comparing all possible pairs and the monotone increase of difference with respect to extremes.\n\nTo answer farthest pair queries quickly under dynamic updates, we rely on a balanced Binary Search Tree (BST), specifically a randomized balanced BST known as a Treap (Tree + Heap). A Treap maintains the BST invariant on keys and a heap invariant on randomly assigned priorities. The expected height is $O(\\log n)$, giving $O(\\log n)$ expected time for search, insert, and delete.\n\nAugmentation principle: To answer farthest pair queries, it suffices to be able to obtain the minimum and maximum keys in the current set. In a naive BST, finding minimum or maximum requires descending to the leftmost or rightmost node, which takes $O(h)$ time where $h$ is the height; under balancing $h = O(\\log n)$. We can make the query $O(1)$ by augmenting each node with the minimum and maximum keys present in its subtree. Specifically, for a node with key $k$ and children $L$ and $R$, define the augmented fields:\n- $\\text{sub\\_min} = \\min\\left(\\{k\\} \\cup (\\{L.\\text{sub\\_min}\\} \\text{ if } L \\ne \\varnothing) \\cup (\\{R.\\text{sub\\_min}\\} \\text{ if } R \\ne \\varnothing)\\right)$,\n- $\\text{sub\\_max} = \\max\\left(\\{k\\} \\cup (\\{L.\\text{sub\\_max}\\} \\text{ if } L \\ne \\varnothing) \\cup (\\{R.\\text{sub\\_max}\\} \\text{ if } R \\ne \\varnothing)\\right)$.\n\nCorrectness of augmentation: We argue by structural induction on the tree. For a leaf, $\\text{sub\\_min} = \\text{sub\\_max} = k$ is correct. Assume the fields are correct for subtrees $L$ and $R$. Then the minimum element in the current node’s subtree is the minimum among $k$, the minimum in $L$, and the minimum in $R$; similarly for the maximum. Therefore, the formulas maintain correct values. Upon insertions, deletions, and rotations (used to maintain treap heap property), we recompute these augmented fields from children to parent. Because a rotation only changes local parent-child relationships while preserving the in-order sequence, recomputation via the above formulas preserves correctness.\n\nComplexity analysis: Treap insertion and deletion perform a constant expected number of rotations along the search path of expected length $O(\\log n)$. Each node update of $\\text{sub\\_min}$ and $\\text{sub\\_max}$ is $O(1)$. Therefore, both insertion and deletion run in expected $O(\\log n)$ time. The farthest pair query reduces to reading the root’s $\\text{sub\\_min}$ and $\\text{sub\\_max}$ in $O(1)$ time if the tree is nonempty. Under the problem’s required complexity bound $O(\\log n)$, this design meets and exceeds the requirement.\n\nEdge cases and definitions:\n- When the set is empty, there is no minimum or maximum. We define the query result as $[0,0,0]$.\n- When the set has exactly one element $x$, the minimum and maximum are $x$, and the farthest distance is $0$, yielding $[x,x,0]$.\n- Duplicate insertions are ignored (set semantics) because allowing duplicates is not necessary for the farthest pair, which depends only on extremes. Deleting a non-existent element does nothing.\n\nImplementation plan:\n- Represent nodes with fields: key $k$, priority $p$, pointers to left and right children, and augmentation $\\text{sub\\_min}$, $\\text{sub\\_max}$.\n- Implement treap operations: insert (recursive with rotations), delete (recursive with rotations), and update (recompute augmentation from children).\n- Implement query: if root is $\\varnothing$, return $[0,0,0]$; else return $[\\text{root.sub\\_min}, \\text{root.sub\\_max}, \\text{root.sub\\_max} - \\text{root.sub\\_min}]$.\n\nTest suite interpretation aligned with the problem statement:\n- After inserts of $3$, $-2$, $5$: $m = -2$, $M = 5$, $d = 7$.\n- After insert of $10$: $m = 10$, $M = 10$, $d = 0$.\n- No operations: empty set $\\Rightarrow [0,0,0]$.\n- After operations on negatives with interleaved deletes: final set $\\{-60,-50,-10\\}$, so $m=-60$, $M=-10$, $d=50$.\n- Large magnitudes: final set $\\{-1000000000, 1000000000\\}$, $m=-1000000000$, $M=1000000000$, $d=2000000000$.\n- Duplicate insert and delete non-existent: final set $\\{-1,9\\}$, $m=-1$, $M=9$, $d=10$.\n\nThe program constructs the treap, executes the test suite, and prints a single line with the aggregated list of per-test-case results in the exact format specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport random\n\nclass TreapNode:\n    __slots__ = (\"key\", \"prio\", \"left\", \"right\", \"sub_min\", \"sub_max\")\n    def __init__(self, key, prio):\n        self.key = key\n        self.prio = prio\n        self.left = None\n        self.right = None\n        self.sub_min = key\n        self.sub_max = key\n\ndef update(node: TreapNode):\n    \"\"\"Recompute augmented fields for a node from its children.\"\"\"\n    if node is None:\n        return\n    min_val = node.key\n    max_val = node.key\n    if node.left is not None:\n        if node.left.sub_min < min_val:\n            min_val = node.left.sub_min\n        if node.left.sub_max > max_val:\n            max_val = node.left.sub_max\n    if node.right is not None:\n        if node.right.sub_min < min_val:\n            min_val = node.right.sub_min\n        if node.right.sub_max > max_val:\n            max_val = node.right.sub_max\n    node.sub_min = min_val\n    node.sub_max = max_val\n\ndef rotate_right(y: TreapNode) -> TreapNode:\n    \"\"\"Right rotation around y.\"\"\"\n    x = y.left\n    y.left = x.right\n    x.right = y\n    update(y)\n    update(x)\n    return x\n\ndef rotate_left(x: TreapNode) -> TreapNode:\n    \"\"\"Left rotation around x.\"\"\"\n    y = x.right\n    x.right = y.left\n    y.left = x\n    update(x)\n    update(y)\n    return y\n\ndef insert(node: TreapNode, key: int, prio_func) -> TreapNode:\n    \"\"\"Insert key into treap rooted at node using prio_func to assign priority.\n       Set semantics: if key already exists, no change.\"\"\"\n    if node is None:\n        return TreapNode(key, prio_func(key))\n    if key == node.key:\n        # Duplicate insert ignored (set semantics)\n        return node\n    if key < node.key:\n        node.left = insert(node.left, key, prio_func)\n        update(node)\n        if node.left is not None and node.left.prio > node.prio:\n            node = rotate_right(node)\n    else:\n        node.right = insert(node.right, key, prio_func)\n        update(node)\n        if node.right is not None and node.right.prio > node.prio:\n            node = rotate_left(node)\n    update(node)\n    return node\n\ndef delete(node: TreapNode, key: int) -> TreapNode:\n    \"\"\"Delete key from treap rooted at node. If key not present, no change.\"\"\"\n    if node is None:\n        return None\n    if key < node.key:\n        node.left = delete(node.left, key)\n    elif key > node.key:\n        node.right = delete(node.right, key)\n    else:\n        # Found node to delete\n        if node.left is None and node.right is None:\n            return None\n        elif node.left is None:\n            node = rotate_left(node)\n            node.left = delete(node.left, key)\n        elif node.right is None:\n            node = rotate_right(node)\n            node.right = delete(node.right, key)\n        else:\n            # Rotate the higher-priority child up\n            if node.left.prio > node.right.prio:\n                node = rotate_right(node)\n                node.right = delete(node.right, key)\n            else:\n                node = rotate_left(node)\n                node.left = delete(node.left, key)\n    update(node)\n    return node\n\nclass AugmentedTreap:\n    def __init__(self, seed: int = 42):\n        # Use a deterministic pseudo-random priority function seeded for reproducibility.\n        random.seed(seed)\n        # Pre-generate a map from keys to priorities lazily to keep deterministic.\n        self.root = None\n        self.prio_cache = {}\n        self.rng = random.Random(seed)\n\n    def prio_func(self, key: int) -> float:\n        # Deterministic priority per key using a simple hash-like transform.\n        # This keeps reproducibility while providing reasonable randomization for balance.\n        if key not in self.prio_cache:\n            # Use a combination of random and key to avoid collisions.\n            # Assign a random float in (0,1) scaled by a deterministic function of the key.\n            # But final value is determined solely by the seeded RNG on first use.\n            self.prio_cache[key] = self.rng.random()\n        return self.prio_cache[key]\n\n    def insert(self, key: int):\n        self.root = insert(self.root, key, self.prio_func)\n\n    def delete(self, key: int):\n        self.root = delete(self.root, key)\n\n    def farthest_pair(self):\n        \"\"\"Return [min, max, distance] for current set; [0,0,0] if empty.\"\"\"\n        if self.root is None:\n            return [0, 0, 0]\n        m = self.root.sub_min\n        M = self.root.sub_max\n        return [m, M, M - m]\n\ndef run_case(ops):\n    treap = AugmentedTreap(seed=123456)  # fixed seed for deterministic structure\n    for op in ops:\n        cmd = op[0]\n        if cmd == 'ins':\n            treap.insert(op[1])\n        elif cmd == 'del':\n            treap.delete(op[1])\n        else:\n            # ignore unknown commands\n            pass\n    return treap.farthest_pair()\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [('ins', 3), ('ins', -2), ('ins', 5)],\n        [('ins', 10)],\n        [],\n        [('ins', -100), ('ins', -50), ('ins', -75), ('del', -75), ('ins', -60), ('del', -100), ('ins', -10)],\n        [('ins', -1000000000), ('ins', 1000000000), ('ins', 0), ('del', 0)],\n        [('ins', 4), ('ins', 4), ('del', 7), ('ins', -1), ('ins', 9), ('del', 4)],\n    ]\n\n    results = []\n    for ops in test_cases:\n        result = run_case(ops)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3210318"}, {"introduction": "Building upon the basics, this practice introduces a more complex and common task: answering aggregation queries over arbitrary ranges. You will design a tree that can calculate the sum of all keys within a given interval $[low, high]$ in logarithmic time. The key insight you'll implement is the decomposition of a range query into two prefix queries, a powerful pattern in algorithm design, supported by augmenting each node with the sum of its subtree's keys [@problem_id:3210369].", "problem": "Design and implement an augmented Balanced Binary Search Tree (BBST) that supports integer keys, allows duplicate keys as multiple insertions of the same value, and answers range-sum queries in asymptotic time $O(\\log n)$ per operation, where $n$ is the number of inserted elements counting multiplicities. Start from the fundamental base that a Binary Search Tree maintains the invariant that for any node with key $k$, all keys in the left subtree are strictly less than $k$ and all keys in the right subtree are strictly greater than $k$, and that a balanced tree ensures height $O(\\log n)$. Augmentation is permitted, provided it is derived from the BBST structure and its invariants.\n\nYour program must construct and maintain such a tree under the following operations on integer keys:\n\n- Insert a key $x$ into the tree. Inserting a key equal to an existing key increases its multiplicity by $1$.\n- Delete a key $x$ from the tree. Deleting a key reduces its multiplicity by $1$, and if the multiplicity becomes $0$, the key is removed from the tree.\n- Compute the sum of all keys (counting multiplicities) that lie in a closed interval $[low, high]$.\n\nYou must design the augmentation so that a range-sum query over $[low, high]$ can be answered in asymptotic time $O(\\log n)$ on a BBST. The solution must be derived from the Binary Search Tree invariant and the balanced-height property, without assuming any specialized built-in data structure.\n\nTest Suite. Your program must execute the following scenarios in order and aggregate the outputs of all queries:\n\nScenario $\\mathsf{A}$ (general case, insertion, deletion, and query):\n- Initialize the tree by inserting the keys in the order $[5,3,8,1,4,7,9]$.\n- Query the sum over $[3,8]$.\n- Delete the key $4$.\n- Query the sum over $[3,8]$.\n\nScenario $\\mathsf{B}$ (boundary conditions: empty tree, negative values, and invalid range):\n- Initialize an empty tree.\n- Query the sum over $[0,10]$.\n- Insert the key $-2$.\n- Query the sum over $[-5,-1]$.\n- Query the sum over $[2,1]$ (note that this is an invalid range since $low > high$; define the result to be $0$).\n\nScenario $\\mathsf{C}$ (duplicates and selective deletion):\n- Initialize the tree by inserting the keys in the order $[2,2,2,3,3,10]$.\n- Query the sum over $[2,3]$.\n- Delete the key $2$ once.\n- Query the sum over $[2,2]$.\n\nScenario $\\mathsf{D}$ (range fully covering current set, and deletion effect):\n- Initialize the tree by inserting the keys in the order $[0,-5,5,1]$.\n- Query the sum over $[-10,10]$.\n- Delete the key $1$.\n- Query the sum over $[-10,10]$.\n\nFinal Output Format. Your program should produce a single line of output containing the results of all queries in order, as a comma-separated list enclosed in square brackets, for example $[result\\_1,result\\_2,\\dots]$. The outputs for each query must be integers. No physical units are involved, and no angles or percentages are present in this problem.", "solution": "The user-provided problem is assessed to be **valid**. It is a well-posed, scientifically grounded problem from the field of data structures and algorithms, containing no contradictions, ambiguities, or unsound premises. The problem can be solved by formally deriving and implementing an augmented Balanced Binary Search Tree (BBST).\n\nThe task is to design a BBST that supports insertion, deletion, and range-sum queries for integer keys, all with an asymptotic time complexity of $O(\\log n)$, where $n$ is the total number of elements including duplicates.\n\n### Principle and Design\n\nA standard Binary Search Tree (BST) maintains the invariant that for any node with key $k$, all keys in the left subtree are less than $k$ and all keys in the right subtree are greater than $k$. To handle duplicate keys, we can augment each node to store a multiplicity or count. A Balanced BST (e.g., an AVL tree or Red-Black tree) further guarantees that the tree height remains $O(\\log n)$, ensuring that traversal-based operations like search, insertion, and deletion are efficient.\n\nTo answer a range-sum query for a closed interval $[low, high]$ in $O(\\log n)$ time, a standard BST is insufficient as it would require an in-order traversal, taking $O(k + \\log n)$ time where $k$ is the number of elements in the range. The key is to augment the tree nodes with additional information that allows for the sum to be computed without visiting every node in the range.\n\nThe query for the sum in $[low, high]$ can be decomposed into two more fundamental queries:\n$$ \\text{RangeSum}(low, high) = \\text{Sum}(\\le high) - \\text{Sum}(\\le low - 1) $$\nwhere $\\text{Sum}(\\le k)$ is the sum of all keys in the tree that are less than or equal to $k$. If we can compute $\\text{Sum}(\\le k)$ in $O(\\log n)$ time, then the range-sum query can also be solved in $O(\\log n)$.\n\nTo achieve this, we augment each node $v$ in the BBST with the following information:\n1. $v.key$: The integer key stored at the node.\n2. $v.count$: The multiplicity of the key $v.key$.\n3. $v.left$, $v.right$: Pointers to the left and right children.\n4. $v.height$: The height of the subtree rooted at $v$ (for balancing, e.g., in an AVL tree).\n5. $v.subtree\\_sum$: The sum of all keys in the subtree rooted at $v$, accounting for multiplicities.\n\nThe crucial augmentation is $v.subtree\\_sum$. This value can be maintained recursively. For any node $v$, its $subtree\\_sum$ is defined as:\n$$ v.subtree\\_sum = (v.key \\times v.count) + (v.left.subtree\\_sum \\text{ if } v.left) + (v.right.subtree\\_sum \\text{ if } v.right) $$\nwhere the child subtree sum is $0$ if the child is null.\n\nThis augmented property can be maintained during insertion and deletion operations. When a node is inserted or deleted, or when a rotation is performed for rebalancing, the `subtree_sum` of the affected nodes and their ancestors must be updated. Since these operations modify a single path from the root to the leaf (and involve a constant number of nodes during rotation), the updates take $O(\\log n)$ time, thus preserving the overall time complexity of insertion and deletion.\n\n### Algorithm for $\\text{Sum}(\\le k)$\n\nWith the `subtree_sum` augmentation, we can compute $\\text{Sum}(\\le k)$ in $O(\\log n)$ time by traversing a single path from the root. Let the current node be `curr` and initialize a running total `sum = 0`.\n\nStarting from the root:\n- If $k < curr.key$: All keys in the current node and its right subtree are greater than $k$. The answer must be entirely within the left subtree. We proceed to the left child: `curr = curr.left`.\n- If $k > curr.key$: All keys in the left subtree are less than or equal to $k$, as is the key at the current node. We add the sum of the left subtree (`curr.left.subtree_sum`) and the sum of the keys at the current node (`curr.key \\times curr.count`) to our running total. Then, we continue searching for more keys in the right subtree: `sum += curr.left.subtree_sum + (curr.key \\times curr.count)`, then `curr = curr.right`.\n- If $k == curr.key$: All keys in the left subtree and at the current node are less than or equal to $k$. All keys in the right subtree are greater. Thus, we add the sum of the left subtree and the sum from the current node and terminate. `sum += curr.left.subtree_sum + (curr.key \\times curr.count)`.\n\nThis process traverses a single path, taking $O(\\text{height}) = O(\\log n)$ time.\n\n### Implementation using an AVL Tree\n\nWe will use an AVL tree as the underlying BBST. An AVL tree maintains balance by ensuring that for any node, the heights of its two children differ by at most $1$. This is maintained through rotations (left and right rotations) during insertions and deletions. The `height` and `subtree_sum` attributes of each node are updated after every modification and rotation.\n\nThe `insert` operation will find the correct position for the key. If the key already exists, its `count` is incremented. If not, a new node is created. The tree is then rebalanced by performing rotations as needed while traversing back up to the root.\n\nThe `delete` operation will find the key. If its `count > 1`, the count is decremented. If `count == 1`, the node is removed using the standard BST deletion algorithm (e.g., replacing it with its in-order successor). The tree is then rebalanced.\n\nThe `range_sum` method will implement the logic $\\text{Sum}(\\le high) - \\text{Sum}(\\le low - 1)$. The problem states that if $low > high$, the result should be $0$; this is handled as a base case.\n\nThe following Python implementation encapsulates this design. A `Node` class holds the key, count, height, sum, and child pointers. An `AugmentedAVLTree` class implements the described operations and balancing logic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"Node for the Augmented AVL Tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.count = 1\n        self.height = 1\n        self.subtree_sum = key\n        self.left = None\n        self.right = None\n\nclass AugmentedAVLTree:\n    \"\"\"\n    Augmented AVL Tree to support range-sum queries.\n    - Handles duplicate keys via a `count` attribute in each node.\n    - Augments nodes with `subtree_sum` for O(log n) range sum queries.\n    \"\"\"\n\n    def __init__(self):\n        self.root = None\n        self.query_results = []\n\n    def _get_height(self, node):\n        return node.height if node else 0\n\n    def _get_sum(self, node):\n        return node.subtree_sum if node else 0\n\n    def _update_node_attributes(self, node):\n        \"\"\"Updates height and subtree_sum of a node based on its children.\"\"\"\n        if not node:\n            return\n        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))\n        node.subtree_sum = (node.key * node.count) + self._get_sum(node.left) + self._get_sum(node.right)\n\n    def _get_balance(self, node):\n        return self._get_height(node.left) - self._get_height(node.right) if node else 0\n\n    def _right_rotate(self, y):\n        x = y.left\n        T2 = x.right\n        x.right = y\n        y.left = T2\n        self._update_node_attributes(y)\n        self._update_node_attributes(x)\n        return x\n\n    def _left_rotate(self, x):\n        y = x.right\n        T2 = y.left\n        y.left = x\n        x.right = T2\n        self._update_node_attributes(x)\n        self._update_node_attributes(y)\n        return y\n\n    def _rebalance(self, node, key):\n        \"\"\"Rebalances the node and returns the new root of the subtree.\"\"\"\n        self._update_node_attributes(node)\n        balance = self._get_balance(node)\n\n        # Left Left Case\n        if balance > 1 and key < node.left.key:\n            return self._right_rotate(node)\n        # Right Right Case\n        if balance < -1 and key > node.right.key:\n            return self._left_rotate(node)\n        # Left Right Case\n        if balance > 1 and key > node.left.key:\n            node.left = self._left_rotate(node.left)\n            return self._right_rotate(node)\n        # Right Left Case\n        if balance < -1 and key < node.right.key:\n            node.right = self._right_rotate(node.right)\n            return self._left_rotate(node)\n        \n        return node\n\n    def insert(self, key):\n        self.root = self._insert_recursive(self.root, key)\n\n    def _insert_recursive(self, node, key):\n        if not node:\n            return Node(key)\n        \n        if key < node.key:\n            node.left = self._insert_recursive(node.left, key)\n        elif key > node.key:\n            node.right = self._insert_recursive(node.right, key)\n        else:\n            node.count += 1\n            # Only sum needs update if key exists, height and balance don't change\n            self._update_node_attributes(node)\n            return node\n        \n        return self._rebalance(node, key)\n\n    def delete(self, key):\n        self.root = self._delete_recursive(self.root, key)\n\n    def _delete_recursive(self, node, key):\n        if not node:\n            return node\n        \n        if key < node.key:\n            node.left = self._delete_recursive(node.left, key)\n        elif key > node.key:\n            node.right = self._delete_recursive(node.right, key)\n        else:\n            if node.count > 1:\n                node.count -= 1\n                self._update_node_attributes(node)\n                return node\n            \n            if not node.left or not node.right:\n                temp = node.left if node.left else node.right\n                node = None\n                return temp\n            else:\n                temp = self._get_min_value_node(node.right)\n                node.key = temp.key\n                node.count = temp.count\n                # Set count to 1 to ensure standard deletion of successor\n                temp.count = 1\n                node.right = self._delete_recursive(node.right, temp.key)\n        \n        if not node:\n            return node # Tree was empty or node became null\n\n        # Rebalance the node\n        self._update_node_attributes(node)\n        balance = self._get_balance(node)\n\n        # Left Left Case\n        if balance > 1 and self._get_balance(node.left) >= 0:\n            return self._right_rotate(node)\n        # Left Right Case\n        if balance > 1 and self._get_balance(node.left) < 0:\n            node.left = self._left_rotate(node.left)\n            return self._right_rotate(node)\n        # Right Right Case\n        if balance < -1 and self._get_balance(node.right) <= 0:\n            return self._left_rotate(node)\n        # Right Left Case\n        if balance < -1 and self._get_balance(node.right) > 0:\n            node.right = self._right_rotate(node.right)\n            return self._left_rotate(node)\n        \n        return node\n\n    def _get_min_value_node(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n\n    def range_sum(self, low, high):\n        if low > high:\n            return 0\n        sum_high = self._sum_le(high)\n        sum_low_minus_1 = self._sum_le(low - 1)\n        return sum_high - sum_low_minus_1\n\n    def _sum_le(self, k):\n        \"\"\"Returns the sum of all keys less than or equal to k.\"\"\"\n        current = self.root\n        total_sum = 0\n        while current:\n            if k < current.key:\n                current = current.left\n            elif k > current.key:\n                total_sum += self._get_sum(current.left) + (current.key * current.count)\n                current = current.right\n            else: # k == current.key\n                total_sum += self._get_sum(current.left) + (current.key * current.count)\n                break\n        return total_sum\n    \n    def process_query(self, low, high):\n        result = self.range_sum(low, high)\n        self.query_results.append(result)\n\ndef solve():\n    all_results = []\n\n    # Scenario A\n    tree_a = AugmentedAVLTree()\n    for key in [5, 3, 8, 1, 4, 7, 9]:\n        tree_a.insert(key)\n    tree_a.process_query(3, 8)\n    tree_a.delete(4)\n    tree_a.process_query(3, 8)\n    all_results.extend(tree_a.query_results)\n\n    # Scenario B\n    tree_b = AugmentedAVLTree()\n    tree_b.process_query(0, 10)\n    tree_b.insert(-2)\n    tree_b.process_query(-5, -1)\n    tree_b.process_query(2, 1) # Invalid range\n    all_results.extend(tree_b.query_results)\n\n    # Scenario C\n    tree_c = AugmentedAVLTree()\n    for key in [2, 2, 2, 3, 3, 10]:\n        tree_c.insert(key)\n    tree_c.process_query(2, 3)\n    tree_c.delete(2)\n    tree_c.process_query(2, 2)\n    all_results.extend(tree_c.query_results)\n\n    # Scenario D\n    tree_d = AugmentedAVLTree()\n    for key in [0, -5, 5, 1]:\n        tree_d.insert(key)\n    tree_d.process_query(-10, 10)\n    tree_d.delete(1)\n    tree_d.process_query(-10, 10)\n    all_results.extend(tree_d.query_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3210369"}, {"introduction": "This final practice moves into the domain of computational geometry, where augmented trees are indispensable. You will implement a dynamic interval tree capable of finding all stored intervals that overlap with a query interval. This involves augmenting nodes with the maximum endpoint in their subtrees, a clever technique that allows for efficient pruning of the search space and demonstrates how to query a dataset based on a secondary property not used for the primary sorting of the tree [@problem_id:3210424].", "problem": "You are to design and implement an augmented binary search tree that maintains a dynamic set of closed intervals on the integer line. Each interval is associated with a unique identifier. The tree must support inserting a new interval, resizing an existing interval by modifying its endpoints, and querying for all intervals that overlap a given closed query interval. The final program must be a complete, runnable program that executes a fixed test suite and prints the aggregated results on a single line.\n\nBegin from the following fundamental base: a binary search tree keyed by the left endpoint of an interval, augmented with subtree information sufficient to answer overlap queries efficiently; the notion of overlap between two closed intervals; and a balanced tree design ensuring logarithmic expected running time for updates and searches. You must derive your design and implementation by carefully defining invariants and proving how they are preserved by every operation.\n\nDefinitions and requirements:\n\n- Let an interval be a closed interval $[\\ell,r]$ on the integer line with $\\ell \\le r$ and endpoints $\\ell,r \\in \\mathbb{Z}$. Each interval has a unique identifier $i \\in \\mathbb{Z}$.\n- The tree must be a balanced binary search tree keyed by $(\\ell,i)$ in lexicographic order, and every node must be augmented to store the maximum right endpoint across its subtree. Specifically, for a node storing interval $[\\ell,r]$ with identifier $i$, define the augmented field $$\\mathrm{max\\_end} = \\max\\left(r, \\mathrm{max\\_end}\\left(\\text{left subtree}\\right), \\mathrm{max\\_end}\\left(\\text{right subtree}\\right)\\right).$$\n- Two closed intervals $[\\ell_1,r_1]$ and $[\\ell_2,r_2]$ overlap if and only if $$\\ell_1 \\le r_2 \\quad \\text{and} \\quad \\ell_2 \\le r_1.$$\n- The tree must support the following operations:\n  1. $\\mathrm{insert}(i,\\ell,r)$: insert a new interval with identifier $i$ and endpoints $\\ell,r$ with the rule $\\ell \\le r$.\n  2. $\\mathrm{resize}(i,\\ell',r')$: change the endpoints of the existing interval identified by $i$ to the new endpoints $\\ell',r'$ with the rule $\\ell' \\le r'$, while preserving the identity $i$. This operation must correctly update all augmentations and maintain the balanced tree invariants.\n  3. $\\mathrm{query}(q_\\ell,q_r)$: return the list of identifiers of all intervals in the tree that overlap the query interval $[q_\\ell,q_r]$. The list must be sorted in ascending order of identifiers.\n- Target time bounds: Each operation must run in expected $O(\\log n)$ time, where $n$ is the number of intervals in the tree, by using a balanced binary search tree with appropriate augmentation.\n\nYour program must implement the above specifications, run the following test suite, and produce the results of all queries in the exact final output format described later.\n\nTest Suite:\n\n- Test case $1$ (general functionality and resizing both shrinking and shifting):\n  1. $\\mathrm{insert}(1,1,5)$\n  2. $\\mathrm{insert}(2,4,7)$\n  3. $\\mathrm{insert}(3,10,12)$\n  4. $\\mathrm{insert}(4,6,6)$\n  5. $\\mathrm{insert}(5,0,2)$\n  6. $\\mathrm{query}(5,6)$\n  7. $\\mathrm{resize}(1,2,3)$\n  8. $\\mathrm{query}(1,2)$\n  9. $\\mathrm{resize}(4,7,9)$\n  10. $\\mathrm{query}(8,10)$\n  The expected outputs for the three queries are the sorted lists of identifiers that overlap the respective query intervals.\n\n- Test case $2$ (boundary conditions including zero-length intervals and negative endpoints):\n  1. $\\mathrm{insert}(10,-5,-1)$\n  2. $\\mathrm{insert}(11,-1,0)$\n  3. $\\mathrm{insert}(12,0,0)$\n  4. $\\mathrm{insert}(13,0,1)$\n  5. $\\mathrm{query}(0,0)$\n  6. $\\mathrm{resize}(11,-2,-2)$\n  7. $\\mathrm{query}(-2,-2)$\n  8. $\\mathrm{resize}(12,-1,1)$\n  9. $\\mathrm{query}(-1,0)$\n  The expected outputs for the three queries are the sorted lists of identifiers that overlap the respective query intervals.\n\n- Test case $3$ (multiple intervals with the same left endpoint, resizing that changes order, and comprehensive overlap):\n  1. $\\mathrm{insert}(20,5,10)$\n  2. $\\mathrm{insert}(21,5,5)$\n  3. $\\mathrm{insert}(22,5,7)$\n  4. $\\mathrm{insert}(23,2,3)$\n  5. $\\mathrm{query}(4,5)$\n  6. $\\mathrm{resize}(23,6,12)$\n  7. $\\mathrm{query}(8,9)$\n  8. $\\mathrm{resize}(21,4,6)$\n  9. $\\mathrm{query}(6,6)$\n  The expected outputs for the three queries are the sorted lists of identifiers that overlap the respective query intervals.\n\nFinal Output Format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of query results, and each query result is itself a list of identifiers. For example, the format must be $$\\left[\\text{result\\_case\\_1},\\text{result\\_case\\_2},\\text{result\\_case\\_3}\\right],$$ where each $\\text{result\\_case\\_k}$ is a list of lists of integers corresponding to the queries in test case $k$. No additional text, spaces are optional, and there must be exactly one line of output.", "solution": "The problem requires the design and implementation of a dynamic data structure for storing and querying closed intervals on the integer line. The structure must be a balanced binary search tree, augmented to support efficient overlap queries. The required operations are insertion of a new interval, resizing of an existing interval, and querying for all intervals that overlap a given query interval. All operations must achieve an expected time complexity of $O(\\log n)$, where $n$ is the number of intervals.\n\nTo meet these requirements, we will implement an augmented Treap. A Treap is a randomized binary search tree that maintains balance with high probability, thus providing expected logarithmic time for search, insertion, and deletion operations.\n\n### Data Structure: Augmented Treap Node\nEach node in the Treap will represent a single interval. The node structure contains the following fields:\n- **Key**: A tuple $(\\ell, i)$ representing the interval's left endpoint $\\ell$ and its unique identifier $i$. The tree is ordered lexicographically by this key. This ensures a unique position for each interval, even if multiple intervals share the same left endpoint.\n- **Identifier**: The unique integer identifier $i$.\n- **Interval**: The endpoints $(\\ell, r)$ of the closed interval $[\\ell, r]$.\n- **Priority**: A randomly assigned integer used to maintain the heap property of the Treap.\n- **Children**: Pointers to the left and right children, `left` and `right`.\n- **Augmentation**: A field `max_end`, which stores the maximum right endpoint of any interval in the subtree rooted at this node.\n\n### Invariants of the Augmented Treap\nThe correctness of our data structure relies on maintaining three invariants for every node $x$ in the tree:\n\n$1$. **Binary Search Tree (BST) Invariant**: For any node $x$, all keys in the left subtree of $x$ are less than the key of $x$, and all keys in the right subtree of $x$ are greater than the key of $x$. That is, for any node $y$ in $x$'s left subtree, $y.key < x.key$, and for any node $z$ in $x$'s right subtree, $z.key > x.key$.\n\n$2$. **Heap Invariant**: The priority of node $x$ is greater than or equal to the priorities of its children. That is, if $y$ is a child of $x$, then $x.priority \\ge y.priority$.\n\n$3$. **Augmentation Invariant**: The `max_end` field of node $x$ is the maximum of its own interval's right endpoint and the `max_end` values of its children. Let `x.interval` be $[\\ell, r]$. Then,\n$$x.\\text{max\\_end} = \\max(r, x.\\text{left}.\\text{max\\_end}, x.\\text{right}.\\text{max\\_end})$$\nwhere the `max_end` of a non-existent child (i.e., `None`) is taken to be $-\\infty$.\n\n### Maintaining Invariants\nThe BST and heap invariants are maintained using standard Treap operations involving rotations. After any structural modification to the tree (insertion, deletion, rotation), the augmentation invariant must be restored. This is achieved by a helper function `_update_max_end(node)`, which recalculates `node.max_end` based on the definition. This function is called on all affected nodes in a bottom-up fashion. Rotations are the fundamental operations for rebalancing, and they must correctly update the `max_end` fields.\n\n- `_rotate_left(y)`: Let $x$ be the right child of $y$. The rotation makes $x$ the new root of this subtree and $y$ its left child. The `max_end` fields must be updated first for $y$ (the new child) and then for $x$ (the new parent), as $x$'s new value depends on $y$'s updated value.\n- `_rotate_right(x)`: Let $y$ be the left child of $x$. The rotation makes $y$ the new root and $x$ its right child. The `max_end` fields are updated first for $x$ and then for $y$.\n\n### Operation Implementation\nTo facilitate the `resize` operation, which requires finding a node by its identifier $i$, we use an auxiliary dictionary that maps each identifier $i$ to its corresponding node object in the tree.\n\n$1$. **$\\mathrm{insert}(i, \\ell, r)$**:\n- A new node is created with key $(\\ell, i)$, interval $[\\ell, r]$, and a randomly generated priority.\n- The node is inserted into the tree following the standard BST insertion logic, placing it at a leaf position based on its key.\n- The tree is then rebalanced by performing rotations up the path from the new node to the root, restoring the heap invariant wherever it is violated (i.e., where a child has a higher priority than its parent).\n- During the recursive unwinding of the insertion path, the `max_end` values of all ancestor nodes are updated.\n- The auxiliary dictionary is updated with the mapping from $i$ to the newly created node.\nThis process takes expected $O(\\log n)$ time.\n\n$2$. **$\\mathrm{resize}(i, \\ell', r')$**:\nThe `resize` operation modifies the interval associated with identifier $i$ to $[\\ell', r']$. If the left endpoint $\\ell$ changes to $\\ell'$, the node's key $(\\ell, i)$ changes, requiring its physical relocation within the tree to maintain the BST invariant. The most robust way to handle this is to perform a deletion followed by an insertion.\n- The node to be modified is located in $O(1)$ time using the auxiliary dictionary. Let its current interval be $[\\ell, r]$.\n- The node with key $(\\ell, i)$ is deleted from the Treap. Deletion in a Treap involves rotating the target node down until it becomes a leaf, then removing it. Throughout this process, `max_end` values on the path are updated.\n- A new interval with identifier $i$ and endpoints $[\\ell', r']$ is inserted into the tree using the `insert` operation described above.\nSince both deletion and insertion take expected $O(\\log n)$ time, the entire `resize` operation also takes expected $O(\\log n)$ time.\n\n$3$. **$\\mathrm{query}(q_\\ell, q_r)$**:\nThe query operation finds all intervals $[\\ell, r]$ in the tree that overlap with the query interval $[q_\\ell, q_r]$. Two intervals $[\\ell_1, r_1]$ and $[\\ell_2, r_2]$ overlap if $\\ell_1 \\le r_2$ and $\\ell_2 \\le r_1$. The query algorithm recursively traverses the tree, using the `max_end` augmentation to prune search paths.\n\nThe search procedure at a given node $x$ storing interval $[\\ell, r]$ is as follows:\n- **Check the current node**: Test if the interval $[\\ell, r]$ overlaps with $[q_\\ell, q_r]$. If $\\ell \\le q_r$ and $q_\\ell \\le r$, add the identifier $i$ to the result set.\n- **Search the left subtree**: The search must proceed to the left subtree if it might contain an overlapping interval. An interval $[l_{sub}, r_{sub}]$ in the left subtree could overlap with $[q_\\ell, q_r]$ only if $r_{sub} \\ge q_\\ell$. The `max_end` field of the left child, `x.left.max_end`, represents the maximum possible $r_{sub}$ in that entire subtree. Therefore, we only need to search the left subtree if `x.left` is not `None` and `x.left.max_end \\ge q_\\ell$. If this condition is not met, the entire left subtree can be pruned.\n- **Search the right subtree**: Due to the BST invariant, all intervals in the right subtree have a left endpoint greater than or equal to $\\ell$. If $\\ell > q_r$, then any interval in the right subtree will also have its left endpoint greater than $q_r$, making overlap impossible. Thus, we only search the right subtree if `x.right` is not `None` and $\\ell \\le q_r$.\n\nThis search strategy traverses a limited number of paths, leading to an efficient query time of $O(k + \\log n)$, where $k$ is the number of reported overlapping intervals. The problem statement's target is $O(\\log n)$, which is typically used as a shorthand for this complexity class in the context of range and interval queries. Finally, the collected identifiers are sorted in ascending order.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass IntervalTree:\n    \"\"\"\n    An augmented Treap for managing and querying dynamic sets of closed intervals.\n    The tree is keyed by (left_endpoint, identifier) and augmented with the\n    maximum right endpoint in each subtree.\n    \"\"\"\n\n    class Node:\n        def __init__(self, id, l, r, priority):\n            self.id = id\n            self.l = l\n            self.r = r\n            self.key = (l, id)\n            self.priority = priority\n            self.max_end = r\n            self.left = None\n            self.right = None\n\n    def __init__(self, seed=None):\n        self.root = None\n        self.id_to_node = {}\n        if seed is not None:\n            self._rng = np.random.RandomState(seed)\n        else:\n            self._rng = np.random\n        # Using a fixed seed for reproducibility across runs.\n        np.random.seed(42)\n\n    def _get_max_end(self, node):\n        return node.max_end if node else -float('inf')\n\n    def _update_max_end(self, node):\n        if node:\n            node.max_end = max(node.r, self._get_max_end(node.left), self._get_max_end(node.right))\n\n    def _rotate_right(self, y):\n        x = y.left\n        y.left = x.right\n        x.right = y\n        self._update_max_end(y)\n        self._update_max_end(x)\n        return x\n\n    def _rotate_left(self, x):\n        y = x.right\n        x.right = y.left\n        y.left = x\n        self._update_max_end(x)\n        self._update_max_end(y)\n        return y\n\n    def _insert(self, root, node):\n        if not root:\n            return node\n        \n        if node.key < root.key:\n            root.left = self._insert(root.left, node)\n            if root.left.priority > root.priority:\n                root = self._rotate_right(root)\n        else:\n            root.right = self._insert(root.right, node)\n            if root.right.priority > root.priority:\n                root = self._rotate_left(root)\n        \n        self._update_max_end(root)\n        return root\n\n    def insert(self, i, l, r):\n        if i in self.id_to_node:\n            raise ValueError(f\"Identifier {i} already exists.\")\n        \n        priority = self._rng.randint(0, 2**32 - 1)\n        node = self.Node(i, l, r, priority)\n        self.id_to_node[i] = node\n        self.root = self._insert(self.root, node)\n\n    def _delete(self, root, key):\n        if not root:\n            return None\n        \n        if key < root.key:\n            root.left = self._delete(root.left, key)\n        elif key > root.key:\n            root.right = self._delete(root.right, key)\n        else:\n            if not root.left:\n                return root.right\n            if not root.right:\n                return root.left\n            \n            if root.left.priority > root.right.priority:\n                root = self._rotate_right(root)\n                root.right = self._delete(root.right, key)\n            else:\n                root = self._rotate_left(root)\n                root.left = self._delete(root.left, key)\n        \n        self._update_max_end(root)\n        return root\n\n    def resize(self, i, l_new, r_new):\n        if i not in self.id_to_node:\n            raise ValueError(f\"Identifier {i} not found for resizing.\")\n        \n        # Delete the old node\n        old_node = self.id_to_node[i]\n        self.root = self._delete(self.root, old_node.key)\n        del self.id_to_node[i]\n        \n        # Insert the new version\n        self.insert(i, l_new, r_new)\n\n    def _query(self, node, q_l, q_r, results):\n        if not node:\n            return\n\n        # Prune left subtree if no interval can possibly overlap the query's start\n        if node.left and node.left.max_end >= q_l:\n            self._query(node.left, q_l, q_r, results)\n        \n        # Check current node for overlap\n        if node.l <= q_r and q_l <= node.r:\n            results.add(node.id)\n\n        # Prune right subtree if its intervals start after the query ends\n        if node.l <= q_r:\n            self._query(node.right, q_l, q_r, results)\n\n    def query(self, q_l, q_r):\n        results = set()\n        self._query(self.root, q_l, q_r, results)\n        return sorted(list(results))\n\ndef solve():\n    test_suite = [\n        [ # Test case 1\n            (\"insert\", (1, 1, 5)),\n            (\"insert\", (2, 4, 7)),\n            (\"insert\", (3, 10, 12)),\n            (\"insert\", (4, 6, 6)),\n            (\"insert\", (5, 0, 2)),\n            (\"query\", (5, 6)),\n            (\"resize\", (1, 2, 3)),\n            (\"query\", (1, 2)),\n            (\"resize\", (4, 7, 9)),\n            (\"query\", (8, 10)),\n        ],\n        [ # Test case 2\n            (\"insert\", (10, -5, -1)),\n            (\"insert\", (11, -1, 0)),\n            (\"insert\", (12, 0, 0)),\n            (\"insert\", (13, 0, 1)),\n            (\"query\", (0, 0)),\n            (\"resize\", (11, -2, -2)),\n            (\"query\", (-2, -2)),\n            (\"resize\", (12, -1, 1)),\n            (\"query\", (-1, 0)),\n        ],\n        [ # Test case 3\n            (\"insert\", (20, 5, 10)),\n            (\"insert\", (21, 5, 5)),\n            (\"insert\", (22, 5, 7)),\n            (\"insert\", (23, 2, 3)),\n            (\"query\", (4, 5)),\n            (\"resize\", (23, 6, 12)),\n            (\"query\", (8, 9)),\n            (\"resize\", (21, 4, 6)),\n            (\"query\", (6, 6)),\n        ]\n    ]\n\n    all_results = []\n    for case_ops in test_suite:\n        tree = IntervalTree()\n        case_results = []\n        for op, args in case_ops:\n            if op == \"insert\":\n                tree.insert(*args)\n            elif op == \"resize\":\n                tree.resize(*args)\n            elif op == \"query\":\n                result = tree.query(*args)\n                case_results.append(result)\n        all_results.append(case_results)\n    \n    # Format the output string precisely as required, with no spaces.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3210424"}]}