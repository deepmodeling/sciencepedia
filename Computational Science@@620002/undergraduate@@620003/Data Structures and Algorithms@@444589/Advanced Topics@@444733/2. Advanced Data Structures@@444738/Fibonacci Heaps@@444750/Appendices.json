{"hands_on_practices": [{"introduction": "A core feature that gives a Fibonacci heap its efficiency is its \"lazy\" approach to maintaining structure. Unlike more rigid data structures, many operations defer cleanup work, allowing for temporarily messy but valid states. This first exercise [@problem_id:3234527] challenges you to explore this laziness by finding a minimal counterexample to the false claim that no two roots in the root list ever share the same degree. Successfully identifying the simplest operation that violates this claim will solidify your understanding of which operations are lazy and why the `consolidate` step in `extract-min` is so crucial.", "problem": "A Fibonacci heap is a collection of heap-ordered trees maintained in a circular doubly linked root list. The degree of a node is the number of its children. Standard Fibonacci heap operations obey the following core definitions: the insert operation adds a single-node tree to the root list and does not perform consolidation; the union (meld) operation concatenates the two root lists and does not perform consolidation; the extract-min operation removes the minimum root, moves its children to the root list, and then consolidates the root list by repeatedly linking pairs of roots of equal degree until no two roots share a degree; the decrease-key operation, when lowering a key of a non-root node, cuts the node from its parent and adds it to the root list, and may trigger cascading cuts of marked ancestors, but it does not perform consolidation. Consider the false claim: “After any operation, no two roots share the same degree.” Among the following scenarios, choose the one that gives a minimal counterexample to this claim, where “minimal” means it uses the smallest total number of nodes across the involved heap(s) and consists of a single operation.\n\nA. Start from an empty Fibonacci heap. Perform one insert of a new key $k$. \n\nB. Start from a Fibonacci heap whose root list contains exactly two trees with distinct degrees $0$ and $1$, and the minimum key is in the degree-$0$ root. Perform one extract-min.\n\nC. Start from two separate Fibonacci heaps $H_1$ and $H_2$, each consisting of a single-node tree of keys $x$ and $y$ respectively (both nodes have degree $0$). Perform one union (meld) of $H_1$ and $H_2$.\n\nD. Start from a Fibonacci heap consisting of a single heap-ordered tree whose root $r$ has degree $3$ and one of $r$’s children $c$ is a leaf (degree $0$). Let $\\text{key}(c)$ be greater than $\\text{key}(r)$. Perform one decrease-key on $c$ to a value strictly less than $\\text{key}(r)$ so that $c$ is cut and moved to the root list; no ancestor other than $r$ exists, so no cascading cut occurs.", "solution": "The problem statement has been validated and is sound, well-posed, and objective. It presents a clear question about the properties of Fibonacci heaps based on standard operational definitions.\n\nThe task is to identify the minimal counterexample to the false claim: \"After any operation, no two roots share the same degree.\" A counterexample is a scenario where a single Fibonacci heap operation results in a state where at least two roots in the root list have the same degree. Minimality is defined by using the smallest total number of nodes and a single operation.\n\nThe defining characteristic of a Fibonacci heap that leads to the falsity of this claim is its \"laziness.\" Most operations, such as `insert`, `union`, and `decrease-key`, do not perform consolidation of the root list. Consolidation is the process of linking roots of equal degree until all roots have unique degrees. This process is exclusively performed as the final step of the `extract-min` operation. Therefore, any operation other than `extract-min` that adds new trees to the root list is a candidate for creating a counterexample.\n\nLet's analyze each option:\n\n**A. Start from an empty Fibonacci heap. Perform one insert of a new key $k$.**\n- **Initial State**: An empty heap with $0$ nodes.\n- **Operation**: One `insert` of a new key $k$.\n- **Final State**: The heap's root list contains a single node corresponding to key $k$. This node is a root and has a degree of $0$.\n- **Analysis**: Since the root list contains only one tree, it is impossible for two roots to share the same degree. This scenario is not a counterexample.\n- **Verdict**: Incorrect.\n\n**B. Start from a Fibonacci heap whose root list contains exactly two trees with distinct degrees $0$ and $1$, and the minimum key is in the degree-$0$ root. Perform one extract-min.**\n- **Initial State**: A Fibonacci heap with two roots. One root has degree $0$ (a single node) and is the minimum. The other root has degree $1$ (a tree with at least $2$ nodes). The total number of nodes is at least $1+2=3$.\n- **Operation**: One `extract-min`.\n- **Final State**: The `extract-min` operation removes the minimum root (the one with degree $0$). Since this root has no children, no new trees are added to the root list. The root list now contains only the single remaining tree of degree $1$. The operation then calls for consolidation, but with only one root, no linking occurs. After the operation, the root list contains a single root of degree $1$.\n- **Analysis**: The final state has only one root. The claim that no two roots share the same degree holds true. In fact, the `extract-min` operation is defined to conclude with a consolidation step that *enforces* this very property. Thus, a completed `extract-min` operation cannot serve as a counterexample.\n- **Verdict**: Incorrect.\n\n**C. Start from two separate Fibonacci heaps $H_1$ and $H_2$, each consisting of a single-node tree of keys $x$ and $y$ respectively (both nodes have degree $0$). Perform one union (meld) of $H_1$ and $H_2$.**\n- **Initial State**: Two heaps, $H_1$ and $H_2$. $H_1$ contains a single node $x$, which is a root of degree $0$. $H_2$ contains a single node $y$, which is a root of degree $0$. The total number of nodes across both heaps is $1+1=2$.\n- **Operation**: One `union` of $H_1$ and $H_2$.\n- **Final State**: The `union` operation concatenates the root lists of the two heaps. The new, combined heap has a root list containing two nodes, $x$ and $y$. Both $x$ and $y$ are roots, and both have a degree of $0$.\n- **Analysis**: In the final state, there are two roots, and both have a degree of $0$. This directly violates the claim. Thus, this is a valid counterexample. To be a counterexample, a heap must have at least two roots of the same degree. The smallest possible degree is $0$. This requires a minimum of two nodes. This scenario uses exactly $2$ nodes, making it minimal in terms of node count. It also uses a single operation.\n- **Verdict**: Correct.\n\n**D. Start from a Fibonacci heap consisting of a single heap-ordered tree whose root $r$ has degree $3$ and one of $r$’s children $c$ is a leaf (degree $0$). Let $\\text{key}(c)$ be greater than $\\text{key}(r)$. Perform one decrease-key on $c$ to a value strictly less than $\\text{key}(r)$ so that $c$ is cut and moved to the root list; no ancestor other than $r$ exists, so no cascading cut occurs.**\n- **Initial State**: A heap with a single tree. The root $r$ has degree $3$. A node of degree $k$ must have at least $k$ children, so this tree has a minimum of $1$ (root) $+ 3$ (children) $= 4$ nodes.\n- **Operation**: One `decrease-key` on node $c$.\n- **Final State**: The key of node $c$ is lowered below its parent $r$'s key, causing $c$ to be cut from $r$. Node $c$ is then added to the root list as a new tree. The degree of $c$ (which was a leaf) is $0$. The degree of its former parent, $r$, is decremented from $3$ to $2$. The heap's root list now contains two trees: the original tree now rooted at $r$ with degree $2$, and the new single-node tree rooted at $c$ with degree $0$.\n- **Analysis**: The final roots have degrees $2$ and $0$. Since these degrees are distinct, the claim holds. This scenario is not a counterexample.\n- **Verdict**: Incorrect.\n\nIn summary, only option C presents a valid counterexample. It is also minimal, as a counterexample requires at least two nodes, and this scenario uses exactly two nodes.", "answer": "$$\\boxed{C}$$", "id": "3234527"}, {"introduction": "Moving from theory to practice, the true test of understanding a complex data structure lies in its implementation and verification. This exercise [@problem_id:3234524] simulates a realistic debugging scenario where you will implement both a correct and a deliberately faulty version of a Fibonacci heap's `decrease-key` operation. By crafting specific sequences of operations to expose the bugs, you will gain a profound, hands-on appreciation for the critical role of the heap-order and minimum-pointer invariants in ensuring the data structure's integrity.", "problem": "Consider a Fibonacci heap, which is a collection of trees satisfying the heap-order property. The heap-order property states that for every node $u$ with key $k(u)$ and every child $v$ of $u$ with key $k(v)$, the relation $k(u) \\leq k(v)$ holds. A standard Fibonacci heap maintains a pointer $min(H)$ to the root with the smallest key among all roots in the heap $H$. The fundamental base for this exercise is the core definition of the heap-order property and the invariant that the minimum element of the heap must be a root, which follows from the heap-order property.\n\nImplement two versions of a Fibonacci heap:\n- A correct version that adheres to the usual definitions and invariants.\n- A faulty version whose $decrease\\text{-}key$ operation sets a node’s key to the new value but does not perform any cuts (even when the new key violates the heap-order property by becoming strictly smaller than its parent’s key) and does not update the global minimum pointer $min(H)$ after the decrease. This faulty behavior must be implemented intentionally.\n\nYou must validate the following invariants on a heap $H$:\n- Heap-order invariant: for every edge $(u,v)$ with $v$ a child of $u$, $k(u) \\leq k(v)$.\n- Minimum-pointer invariant: $min(H)$ points to a root whose key equals the minimum key across all nodes in $H$.\n\nDesign a test suite consisting of three operation sequences. For each sequence, apply it to both the correct and the faulty heap and produce a boolean indicating whether the sequence reveals the bug by violating at least one of the invariants on the faulty heap, while the correct heap maintains all invariants. The sequences are:\n\n- Sequence $S_1$ (general case revealing heap-order violation):\n  1. Insert keys $20$, $7$, $25$, $17$, $26$, $18$ into an initially empty heap $H$.\n  2. Perform $extract\\text{-}min$ once.\n  3. Choose any non-root node $x$ (a node with $parent(x) \\neq \\varnothing$). Let $p$ be its parent and $k(p)$ its key. Perform $decrease\\text{-}key(x, k(p) - 5)$.\n\n- Sequence $S_2$ (root decrease revealing minimum-pointer violation):\n  1. Insert keys $30$, $10$, $40$ into an initially empty heap $H$.\n  2. Let $r$ be the root whose current key is $30$. Perform $decrease\\text{-}key(r, 5)$.\n\n- Sequence $S_3$ (boundary case preserving invariants):\n  1. Insert keys $50$, $60$, $70$, $80$ into an initially empty heap $H$.\n  2. Perform $extract\\text{-}min$ once.\n  3. Choose any non-root node $x$ with parent $p$. Perform $decrease\\text{-}key(x, k(p))$.\n\nFor each sequence $S_i$, your program must compute a boolean result that is $true$ if and only if the faulty heap violates at least one of the stated invariants and the correct heap does not, and $false$ otherwise. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[true,false,true]$.\n\nAll numeric values given in this problem are dimensionless integers; no physical units are involved. Angles are not applicable. Percentages are not applicable.\n\nYour solution must be a complete, runnable program that constructs both the correct and faulty heaps, executes the specified sequences, checks the invariants, and outputs the aggregated boolean results for the three test cases in the exact format described.", "solution": "The user-provided problem statement has been analyzed and validated. It is scientifically grounded in the established principles of data structures and algorithms, specifically concerning Fibonacci heaps. The problem is well-posed, objective, and contains a complete, consistent set of specifications for implementation and testing. No flaws related to scientific soundness, formalizability, completeness, feasibility, or structure were identified. Therefore, the problem is deemed **valid**.\n\nA complete solution follows, designed according to the problem's requirements. This involves the implementation of a `Node` class, a `BaseFibHeap` class containing shared functionality, and two subclasses: `CorrectFibHeap` and `FaultyFibHeap`, which differ in their `decrease_key` method. Invariant-checking methods are included to validate heap properties post-operation. Finally, three test sequences are executed on both heap variants to determine if the faulty implementation's bugs are revealed.\n\n### Data Structures\n\nA `Node` class is defined to represent an element in the heap. Each node stores its `key`, pointers `parent`, `child`, `left`, and `right` for structuring the trees and lists. It also maintains its `degree` (number of children) and a boolean `mark` for the `decrease_key` operation. An `initial_key` attribute is added to uniquely identify nodes for retrieval, as required by the test sequences.\n\nThe `BaseFibHeap` class encapsulates the common logic for both heap implementations. This includes `insert`, `extract_min`, and the `consolidate` helper function, which are identical for both versions. It also contains methods to verify the two critical invariants:\n1.  **Heap-order Invariant**: `_check_heap_order` traverses all nodes to ensure that for every node `u` and its child `v`, `k(u) \\leq k(v)`.\n2.  **Minimum-pointer Invariant**: `_check_min_pointer` verifies that the `min_node` pointer references a root node whose key is the minimum among all keys in the heap.\n\n### Heap Implementations\n\n1.  **`CorrectFibHeap`**: This class implements the standard Fibonacci heap algorithms. Its `decrease_key` method correctly handles violations of the heap-order property by performing `cut` and `cascading_cut` operations, and it updates the heap's minimum pointer if a new minimum is created.\n\n2.  **`FaultyFibHeap`**: This class inherits from `BaseFibHeap` but overrides `decrease_key` with the intentionally buggy behavior specified in the problem. This version simply changes the node's key and performs no subsequent structural adjustments (no cuts) or updates to the minimum pointer.\n\n### Test Sequences and Analysis\n\nThe solution proceeds by defining a function for each of the three test sequences ($S_1$, $S_2$, $S_3$). Each function instantiates a `CorrectFibHeap` and a `FaultyFibHeap`, applies the specified sequence of operations, and then evaluates the invariants on both heaps. A sequence is considered to have revealed the bug if the correct heap remains valid while the faulty heap becomes invalid.\n\n-   **Sequence $S_1$ (Heap-order violation)**: After insertions and one `extract_min`, a non-root node's key is decreased to a value less than its parent's key.\n    -   **Correct Heap**: The `decrease_key` operation triggers a `cut`, moving the node to the root list to restore the heap-order property. The minimum pointer is updated to this new, smaller root. All invariants are maintained.\n    -   **Faulty Heap**: The key is decreased, but no cut occurs. This creates an edge $(p, x)$ where $k(p) > k(x)$, violating the heap-order invariant. The minimum pointer is not updated, also violating the minimum-pointer invariant.\n    -   **Result**: The bug is revealed. The outcome is `true`.\n\n-   **Sequence $S_2$ (Minimum-pointer violation)**: A root node's key is decreased to a value smaller than the current minimum.\n    -   **Correct Heap**: Since the node is a root, no cut is necessary. The minimum pointer is updated to this node. All invariants are maintained.\n    -   **Faulty Heap**: The key is decreased, but the minimum pointer is not updated. The pointer continues to reference a node that is no longer the minimum, violating the minimum-pointer invariant.\n    -   **Result**: The bug is revealed. The outcome is `true`.\n\n-   **Sequence $S_3$ (Boundary case)**: A non-root node's key is decreased to a value equal to its parent's key.\n    -   **Correct Heap**: The new key is not strictly less than the parent's key ($k(p) \\leq k(x)$ holds as $k(p) = k(x)$), so no cut is required. The minimum is not changed. All invariants are maintained.\n    -   **Faulty Heap**: The key is decreased. Since this change does not violate the heap-order property and does not create a new overall minimum, both invariants remain intact by coincidence.\n    -   **Result**: The bug is not revealed because the faulty heap remains valid. The outcome is `false`.\n\nThe final program collates these boolean results into the required output format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Note: numpy is imported to adhere to the specified environment but is not used.\nimport math\n\nclass Node:\n    \"\"\"Represents a node in the Fibonacci heap.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.initial_key = key  # For stable node lookup\n        self.degree = 0\n        self.parent = None\n        self.child = None\n        self.left = self\n        self.right = self\n        self.mark = False\n\n    def __repr__(self):\n        return f\"Node({self.key})\"\n\nclass BaseFibHeap:\n    \"\"\"Base class with common Fibonacci heap functionality.\"\"\"\n    def __init__(self):\n        self.min_node = None\n        self.num_nodes = 0\n        self.nodes_by_initial_key = {}\n\n    def insert(self, key):\n        \"\"\"Inserts a new key into the heap.\"\"\"\n        node = Node(key)\n        self.nodes_by_initial_key[key] = node\n        self._add_to_root_list(node)\n        if self.min_node is None or node.key < self.min_node.key:\n            self.min_node = node\n        self.num_nodes += 1\n        return node\n    \n    def _add_to_root_list(self, node):\n        \"\"\"Adds a node to the circular doubly-linked root list.\"\"\"\n        if self.min_node is None:\n            self.min_node = node\n        else:\n            node.right = self.min_node.right\n            node.left = self.min_node\n            self.min_node.right.left = node\n            self.min_node.right = node\n\n    def _remove_from_list(self, node):\n        \"\"\"Removes a node from a circular doubly-linked list.\"\"\"\n        node.left.right = node.right\n        node.right.left = node.left\n\n    def extract_min(self):\n        \"\"\"Extracts the node with the minimum key.\"\"\"\n        z = self.min_node\n        if z is not None:\n            if z.child is not None:\n                child = z.child\n                while True:\n                    next_child = child.right\n                    child.parent = None\n                    self._add_to_root_list(child)\n                    if next_child == z.child:\n                        break\n                    child = next_child\n            \n            self._remove_from_list(z)\n\n            if z == z.right:\n                self.min_node = None\n            else:\n                self.min_node = z.right\n                self.consolidate()\n            self.num_nodes -= 1\n        return z\n\n    def consolidate(self):\n        \"\"\"Consolidates the root list to reduce the number of trees.\"\"\"\n        degree_table = {}\n        roots = []\n        if self.min_node is None:\n            return\n            \n        curr = self.min_node\n        while True:\n            roots.append(curr)\n            if curr.right == self.min_node:\n                break\n            curr = curr.right\n\n        for w in roots:\n            x = w\n            d = x.degree\n            while d in degree_table:\n                y = degree_table[d]\n                if x.key > y.key:\n                    x, y = y, x\n                self._link(y, x)\n                del degree_table[d]\n                d += 1\n            degree_table[d] = x\n\n        self.min_node = None\n        for d in degree_table:\n            node = degree_table[d]\n            node.left = node\n            node.right = node\n            self._add_to_root_list(node)\n            if self.min_node is None or node.key < self.min_node.key:\n                self.min_node = node\n\n    def _link(self, y, x):\n        \"\"\"Links tree rooted at y to tree rooted at x.\"\"\"\n        self._remove_from_list(y)\n        y.parent = x\n        if x.child is None:\n            x.child = y\n            y.right = y\n            y.left = y\n        else:\n            y.left = x.child\n            y.right = x.child.right\n            x.child.right.left = y\n            x.child.right = y\n        x.degree += 1\n        y.mark = False\n\n    def _iter_nodes(self):\n        \"\"\"Generator to iterate over all nodes in the heap.\"\"\"\n        if not self.min_node:\n            return\n        \n        q = []\n        visited = set()\n\n        curr = self.min_node\n        while True:\n            q.append(curr)\n            if curr.right == self.min_node:\n                break\n            curr = curr.right\n            \n        while q:\n            node = q.pop(0)\n            if node in visited: continue\n            visited.add(node)\n            yield node\n            if node.child:\n                child = node.child\n                while True:\n                    q.append(child)\n                    if child.right == node.child:\n                        break\n                    child = child.right\n\n    def check_invariants(self):\n        \"\"\"Checks both heap invariants.\"\"\"\n        return self._check_heap_order() and self._check_min_pointer()\n\n    def _check_heap_order(self):\n        \"\"\"Checks if k(parent) <= k(child) for all nodes.\"\"\"\n        for node in self._iter_nodes():\n            if node.child:\n                child = node.child\n                while True:\n                    if node.key > child.key:\n                        return False\n                    if child.parent != node:\n                        return False # Parent pointer check\n                    if child.right == node.child:\n                        break\n                    child = child.right\n        return True\n\n    def _check_min_pointer(self):\n        \"\"\"Checks if min_node points to a root with the minimum key.\"\"\"\n        if self.num_nodes == 0:\n            return self.min_node is None\n        \n        if self.min_node is None:\n            return False\n            \n        if self.min_node.parent is not None:\n            return False # Min node must be a root\n\n        actual_min_key = float('inf')\n        for node in self._iter_nodes():\n            actual_min_key = min(actual_min_key, node.key)\n\n        return self.min_node.key == actual_min_key\n    \n    def get_any_non_root(self):\n        for node in self._iter_nodes():\n            if node.parent is not None:\n                return node\n        return None\n\nclass CorrectFibHeap(BaseFibHeap):\n    \"\"\"A correct implementation of a Fibonacci heap.\"\"\"\n    def decrease_key(self, x, k):\n        if k > x.key:\n            raise ValueError(\"New key is greater than current key\")\n        x.key = k\n        p = x.parent\n        if p is not None and x.key < p.key:\n            self._cut(x, p)\n            self._cascading_cut(p)\n        if x.key < self.min_node.key:\n            self.min_node = x\n\n    def _cut(self, x, p):\n        self._remove_from_list(x)\n        if x.right == x:\n            p.child = None\n        else:\n            p.child = x.right\n        p.degree -= 1\n        self._add_to_root_list(x)\n        x.parent = None\n        x.mark = False\n\n    def _cascading_cut(self, p):\n        pp = p.parent\n        if pp is not None:\n            if not p.mark:\n                p.mark = True\n            else:\n                self._cut(p, pp)\n                self._cascading_cut(pp)\n\nclass FaultyFibHeap(BaseFibHeap):\n    \"\"\"A faulty implementation of a Fibonacci heap for testing.\"\"\"\n    def decrease_key(self, x, k):\n        if k > x.key:\n            raise ValueError(\"New key is greater than current key\")\n        x.key = k\n        # Intentionally does not perform cuts or update min_node\n\ndef run_sequence(sequence_id):\n    \"\"\"Runs a test sequence on both correct and faulty heaps.\"\"\"\n    correct_heap = CorrectFibHeap()\n    faulty_heap = FaultyFibHeap()\n\n    if sequence_id == 1:\n        keys_to_insert = [20, 7, 25, 17, 26, 18]\n        for key in keys_to_insert:\n            correct_heap.insert(key)\n            faulty_heap.insert(key)\n        \n        correct_heap.extract_min()\n        faulty_heap.extract_min()\n        \n        node_c = correct_heap.get_any_non_root()\n        node_f = faulty_heap.nodes_by_initial_key[node_c.initial_key]\n        \n        parent_key = node_c.parent.key\n        new_key = parent_key - 5\n        \n        correct_heap.decrease_key(node_c, new_key)\n        faulty_heap.decrease_key(node_f, new_key)\n\n    elif sequence_id == 2:\n        keys_to_insert = [30, 10, 40]\n        for key in keys_to_insert:\n            correct_heap.insert(key)\n            faulty_heap.insert(key)\n        \n        node_c = correct_heap.nodes_by_initial_key[30]\n        node_f = faulty_heap.nodes_by_initial_key[30]\n        \n        correct_heap.decrease_key(node_c, 5)\n        faulty_heap.decrease_key(node_f, 5)\n\n    elif sequence_id == 3:\n        keys_to_insert = [50, 60, 70, 80]\n        for key in keys_to_insert:\n            correct_heap.insert(key)\n            faulty_heap.insert(key)\n        \n        correct_heap.extract_min()\n        faulty_heap.extract_min()\n\n        node_c = correct_heap.get_any_non_root()\n        node_f = faulty_heap.nodes_by_initial_key[node_c.initial_key]\n\n        new_key = node_c.parent.key\n\n        correct_heap.decrease_key(node_c, new_key)\n        faulty_heap.decrease_key(node_f, new_key)\n        \n    correct_valid = correct_heap.check_invariants()\n    faulty_valid = faulty_heap.check_invariants()\n\n    return correct_valid and not faulty_valid\n\ndef solve():\n    \"\"\"\n    Main function to execute the test sequences and print results.\n    \"\"\"\n    results = [\n        run_sequence(1),\n        run_sequence(2),\n        run_sequence(3)\n    ]\n    \n    # Format the final output as a comma-separated list of lowercase booleans\n    # e.g., [true,false,true]\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```", "id": "3234524"}, {"introduction": "Once you have mastered the fundamental operations and invariants of a data structure, you can begin using it as a powerful building block for more advanced algorithms. This practice problem [@problem_id:3234478] asks you to extend the Fibonacci heap's functionality by designing and implementing a `split` operation, which partitions the heap's elements into two new heaps based on a threshold value $x$. This task requires you to orchestrate a full traversal of the heap's trees and leverage the basic `insert` operation to construct new, valid heaps, thereby demonstrating a comprehensive command of the data structure's mechanics.", "problem": "Design and implement a complete, runnable program that realizes a split operation on a Fibonacci heap (FH). A Fibonacci heap is a collection of heap-ordered trees that supports a set of operations with low amortized time. The fundamental base for the design must be the heap-order property: for every parent node with key value $k_p$ and any of its child nodes with key value $k_c$, the relation $k_p \\le k_c$ holds. The heap is represented as a circular, doubly linked list of roots, each root being the entry point to one heap-ordered tree. The key structural invariants to preserve in any algorithm are: the heap-order property, the circular doubly linked list structure among roots, correct parent-child relationships, and a pointer to a minimum-key root in the heap.\n\nYour task is to:\n- Derive, from the heap-order property, a correct algorithm to split a given Fibonacci heap $H$ into two Fibonacci heaps $(H_{\\le}, H_{>})$ according to a threshold $x \\in \\mathbb{Z}$, such that $H_{\\le}$ contains exactly the elements of $H$ whose keys $k$ satisfy $k \\le x$, and $H_{>}$ contains exactly the elements whose keys $k$ satisfy $k > x$.\n- Implement the algorithm in a program that constructs Fibonacci heaps from given sequences of integer keys, optionally performs a specified number of minimum extractions to create nontrivial tree structures, and then applies the split to produce $(H_{\\le}, H_{>})$.\n- For each test case, compute and return quantifiable results that allow automatic verification:\n  - $c_{\\le}$: the count of keys in $H_{\\le}$ (an integer).\n  - $c_{>}$: the count of keys in $H_{>}$ (an integer).\n  - $s_{\\le}$: the sum of keys in $H_{\\le}$ (an integer).\n  - $s_{>}$: the sum of keys in $H_{>}$ (an integer).\n  - $m_{\\le}$: the minimum key in $H_{\\le}$, or $-1$ if $H_{\\le}$ is empty (an integer).\n  - $m_{>}$: the minimum key in $H_{>}$, or $-1$ if $H_{>}$ is empty (an integer).\n  - $v$: a boolean flag that is true if and only if all the following hold:\n    - Every key in $H_{\\le}$ satisfies $k \\le x$, and every key in $H_{>}$ satisfies $k > x$.\n    - The multiset union of keys in $H_{\\le}$ and $H_{>}$ equals the original multiset of keys in $H$.\n    - Both $H_{\\le}$ and $H_{>}$ satisfy the heap-order property and have correct minimum pointers (if nonempty), i.e., the stored minimum equals the smallest key present.\n\nProgram requirements:\n- Represent Fibonacci heaps with explicit nodes having fields for key, degree, mark, parent, one child pointer, and left and right sibling pointers forming circular doubly linked lists.\n- Use only logically sound, standard operations derived from the definition: insertion, union (meld), and extract-min with consolidation by repeated linking of equal-degree trees.\n- The split algorithm must be derived from the heap-order property, and may be implemented by traversing all nodes of $H$ exactly once and inserting each key into the appropriate target heap. Insertion into a Fibonacci heap runs in amortized $O(1)$ time; traversal visits each node a constant number of times, so the total amortized time is $O(n)$ where $n$ is the number of nodes.\n\nTest suite and construction protocol:\n- For each test case, the heap $H$ is constructed by inserting keys in the given sequence. Then, perform exactly $e$ extract-min operations (if $H$ becomes empty before $e$ extractions, ignore further extractions). Finally, execute split at threshold $x$.\n- Use the following test suite, where each test case is a triple $(\\langle k_1, k_2, \\dots, k_m \\rangle, x, e)$:\n  - Test $1$: $\\left(\\langle 7, 3, 18, 39, 52, 41, 17, 30, 24, 26, 46 \\rangle, x = 30, e = 1\\right)$.\n  - Test $2$: $\\left(\\langle 1, 2, 2, 2, 3 \\rangle, x = 3, e = 0\\right)$.\n  - Test $3$: $\\left(\\langle 10, 11, 12 \\rangle, x = 5, e = 0\\right)$.\n  - Test $4$: $\\left(\\langle -5, -1, 0, 0, 6, 6, 7 \\rangle, x = 0, e = 2\\right)$.\n  - Test $5$: $\\left(\\langle \\rangle, x = 0, e = 0\\right)$ (empty heap).\n  - Test $6$: $\\left(\\langle 5, 5, 5 \\rangle, x = 5, e = 1\\right)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the per-test-case list $[c_{\\le}, c_{>}, s_{\\le}, s_{>}, m_{\\le}, m_{>}, v]$. For example, a line of the form $[[\\dots],[\\dots],\\dots]$.\n- No input is read from standard input. All computations are determined by the compiled-in test suite.\n- There are no physical units or angles involved; all keys and outputs are unitless integers or booleans.", "solution": "The problem requires the design and implementation of a `split` operation for a Fibonacci heap. A given Fibonacci heap $H$ is to be partitioned into two new Fibonacci heaps, $H_{\\le}$ and $H_{>}$, based on a specified integer threshold $x$. $H_{\\le}$ must contain all elements from $H$ with keys $k \\le x$, and $H_{>}$ must contain all elements with keys $k > x$. The algorithm must be derived from the fundamental heap-order property, and the solution must include a complete, runnable program that implements the heap, the split operation, and computes several verification metrics for a given test suite.\n\nA Fibonacci heap is a specific implementation of a priority queue that consists of a collection of heap-ordered trees. The roots of these trees are maintained in a circular, doubly linked list. The defining characteristic is the **heap-order property**: for any node $p$ with key $k_p$ and any of its children $c$ with key $k_c$, the inequality $k_p \\le k_c$ must hold. This property implies that keys along any path from a root to a leaf are non-decreasing. The heap maintains a pointer, `min_node`, to the root with the minimum key, allowing for $O(1)$ access to the minimum element. The primary operations are insertion, finding the minimum, extracting the minimum, decreasing a key, and merging (union). The efficiency of a Fibonacci heap stems from its \"lazy\" nature, where structural work is deferred until an `extract-min` operation is performed.\n\nThe task is to design a `split(H, x)` algorithm. To partition the set of keys in $H$, every key must be inspected to determine if it is less than or equal to $x$ or greater than $x$. Therefore, a complete traversal of all nodes in the heap $H$ is necessary, which takes $O(n)$ time where $n$ is the number of nodes in $H$. Let a node in this traversal be denoted by $u$.\n\nThe core of the derivation relates to the heap-order property. The resulting structures, $H_{\\le}$ and $H_{>}$, must themselves be valid Fibonacci heaps, which means they must satisfy all structural invariants, chief among them being the heap-order property. A robust and straightforward method to guarantee this is to construct $H_{\\le}$ and $H_{>}$ from the ground up using a sequence of valid heap operations.\n\nThe proposed algorithm is as follows:\n1. Initialize two new, empty Fibonacci heaps, $H_{\\le}$ and $H_{>}$.\n2. Traverse every node $u$ in the original heap $H$. This can be accomplished with a breadth-first or depth-first search starting from the roots in the root list.\n3. For each node $u$ with key $k$, compare $k$ with the threshold $x$.\n   - If $k \\le x$, insert the key $k$ into $H_{\\le}$ using its standard `insert` operation.\n   - If $k > x$, insert the key $k$ into $H_{>}$ using its `insert` operation.\n4. After all nodes from $H$ have been processed, the heaps $H_{\\le}$ and $H_{>}$ contain the partitioned key sets and are, by construction, valid Fibonacci heaps.\n\nThis algorithm's correctness is directly \"derived from the heap-order property\" because the `insert` operation is fundamentally designed to preserve this property. By building the new heaps exclusively through `insert`, we ensure that the resulting structures are valid. While more complex in-place algorithms involving cutting subtrees and restructuring could be conceived, they offer no asymptotic time complexity advantage for this partitioning task and introduce significant opportunities for error. The traversal and re-insertion method leverages the proven correctness of the fundamental `insert` operation, which runs in $O(1)$ amortized time. Since the traversal visits each of the $n$ nodes once, the total amortized time complexity of the split operation is $O(n)$.\n\nThe implementation requires a complete Fibonacci heap data structure. A `Node` class encapsulates the fields: `key`, `degree` (number of children), `mark` (for `decrease-key` operations, though not central to this problem), `parent`, `child`, `left`, and `right` sibling pointers. The `FibonacciHeap` class manages the collection of nodes, maintaining a pointer to the minimum-key root `min_node` and a count of total nodes `num_nodes`. The key operations to implement are:\n- `insert(key)`: Creates a new single-node tree and adds it to the root list in $O(1)$ time.\n- `extract_min()`: Removes the minimum node, promotes its children to the root list, and calls `consolidate()` to restructure the heap. This is the most complex operation.\n- `consolidate()`: Merges trees in the root list so that no two trees have the same degree. This is achieved by iteratively linking trees of equal degree. It ensures the logarithmic bound on the maximum degree of any node.\n- `get_all_nodes()`: A traversal function to visit every node in the heap, necessary for both the `split` operation and for verification.\n- `split(x)`: Implements the traversal and re-insertion algorithm described above.\n\nFinally, for each test case, the program constructs a heap, performs a specified number of `extract-min` operations, and then executes the `split`. The results are verified by:\n1. Traversing the final heaps $H_{\\le}$ and $H_{>}$ to gather their keys.\n2. Computing the required metrics: counts ($c_{\\le}, c_{>}$), sums ($s_{\\le}, s_{>}$), and minima ($m_{\\le}, m_{>}$).\n3. Performing a series of checks for the boolean flag $v$:\n   - **Partitioning correctness**: Every key in $H_{\\le}$ must be $\\le x$, and every key in $H_{>}$ must be $> x$.\n   - **Key conservation**: The multiset union of keys in $H_{\\le}$ and $H_{>}$ must be identical to the multiset of keys in the original heap $H$ just before the split.\n   - **Heap validity**: Both $H_{\\le}$ and $H_{>}$ must be structurally valid Fibonacci heaps, which is verified by checking the heap-order property for all parent-child pairs and confirming that the `min_node` pointer is correct.\nThe collection of these metrics provides a comprehensive and automatically verifiable assessment of the algorithm's correctness.", "answer": "```python\nimport numpy as np\n\n# A meticulous and complete implementation of a Fibonacci Heap.\nclass FibonacciHeap:\n    \"\"\"\n    Implements a Fibonacci Heap data structure supporting insert, extract-min,\n    and a custom split operation.\n    \"\"\"\n    class Node:\n        \"\"\"Represents a node in the heap.\"\"\"\n        def __init__(self, key):\n            self.key = key\n            self.degree = 0\n            self.parent = None\n            self.child = None\n            self.left = self\n            self.right = self\n            self.mark = False\n\n    def __init__(self):\n        \"\"\"Initializes an empty Fibonacci Heap.\"\"\"\n        self.min_node = None\n        self.num_nodes = 0\n\n    def is_empty(self):\n        \"\"\"Returns True if the heap is empty, False otherwise.\"\"\"\n        return self.min_node is None\n\n    def insert(self, key):\n        \"\"\"Inserts a new key into the heap.\"\"\"\n        node = self.Node(key)\n        if self.min_node is None:\n            self.min_node = node\n        else:\n            # Add node to the root list\n            node.right = self.min_node.right\n            node.left = self.min_node\n            self.min_node.right.left = node\n            self.min_node.right = node\n            if key < self.min_node.key:\n                self.min_node = node\n        self.num_nodes += 1\n        return node\n\n    def get_min(self):\n        \"\"\"Returns the minimum key in the heap.\"\"\"\n        return self.min_node.key if self.min_node is not None else None\n\n    def _link(self, y, x):\n        \"\"\"Makes node y a child of node x.\"\"\"\n        # Remove y from root list\n        y.left.right = y.right\n        y.right.left = y.left\n        \n        # Make y a child of x\n        y.parent = x\n        if x.child is None:\n            x.child = y\n            y.right = y\n            y.left = y\n        else:\n            y.left = x.child\n            y.right = x.child.right\n            x.child.right.left = y\n            x.child.right = y\n        x.degree += 1\n        y.mark = False\n\n    def _consolidate(self):\n        \"\"\"Consolidates the root list to enforce the property of unique degrees.\"\"\"\n        if self.num_nodes <= 1:\n            return\n        \n        # The max degree is bounded by log_phi(n)\n        max_degree = int(np.floor(np.log(self.num_nodes) / np.log((1 + np.sqrt(5)) / 2))) + 2\n        A = [None] * max_degree\n        \n        roots = []\n        curr = self.min_node\n        start = self.min_node\n        if curr is None: return\n        while True:\n            roots.append(curr)\n            curr = curr.right\n            if curr == start:\n                break\n        \n        for root in roots:\n            x = root\n            d = x.degree\n            while A[d] is not None:\n                y = A[d]\n                if x.key > y.key:\n                    x, y = y, x\n                self._link(y, x)\n                A[d] = None\n                d += 1\n            A[d] = x\n\n        self.min_node = None\n        for node in A:\n            if node is not None:\n                if self.min_node is None:\n                    self.min_node = node\n                    node.left = node.right = node\n                else:\n                    node.left = self.min_node\n                    node.right = self.min_node.right\n                    self.min_node.right.left = node\n                    self.min_node.right = node\n                    if node.key < self.min_node.key:\n                        self.min_node = node\n\n    def extract_min(self):\n        \"\"\"Extracts the minimum node from the heap.\"\"\"\n        z = self.min_node\n        if z is not None:\n            # Add children to the root list\n            if z.child is not None:\n                child = z.child\n                while True:\n                    next_child = child.right\n                    child.parent = None\n                    # Add child to root list next to z\n                    child.left = z\n                    child.right = z.right\n                    z.right.left = child\n                    z.right = child\n                    if next_child == z.child:\n                        break\n                    child = next_child\n\n            # Remove z from the root list\n            z.left.right = z.right\n            z.right.left = z.left\n\n            if z == z.right:\n                self.min_node = None\n            else:\n                self.min_node = z.right\n                self._consolidate()\n            \n            self.num_nodes -= 1\n        return z\n\n    def get_all_nodes(self):\n        \"\"\"Returns a list of all nodes in the heap via a traversal.\"\"\"\n        if self.is_empty():\n            return []\n        \n        all_nodes = []\n        queue = []\n        visited_roots = set()\n\n        # Add all roots to the queue to start traversal\n        start_node = self.min_node\n        curr = start_node\n        while True:\n            if curr in visited_roots: break\n            visited_roots.add(curr)\n            queue.append(curr)\n            curr = curr.right\n            if curr == start_node: break\n        \n        head = 0\n        while head < len(queue):\n            node = queue[head]\n            head += 1\n            all_nodes.append(node)\n            \n            if node.child is not None:\n                child_start = node.child\n                curr_child = child_start\n                while True:\n                    queue.append(curr_child)\n                    curr_child = curr_child.right\n                    if curr_child == child_start: break\n        \n        return all_nodes\n\n    def split(self, x):\n        \"\"\"Splits the heap into two heaps based on threshold x.\"\"\"\n        nodes = self.get_all_nodes()\n        h_le = FibonacciHeap()\n        h_gt = FibonacciHeap()\n        for node in nodes:\n            if node.key <= x:\n                h_le.insert(node.key)\n            else:\n                h_gt.insert(node.key)\n        return h_le, h_gt\n\n    def is_valid(self):\n        \"\"\"Verifies the heap-order property and the min_node pointer.\"\"\"\n        if self.min_node is None:\n            return self.num_nodes == 0\n        \n        all_nodes = self.get_all_nodes()\n        if len(all_nodes) != self.num_nodes:\n            return False\n\n        if not all_nodes:\n            return self.num_nodes == 0\n\n        actual_min_key = float('inf')\n        for node in all_nodes:\n            actual_min_key = min(actual_min_key, node.key)\n            if node.parent is None: # It's a root\n                pass # No parent to check against\n            \n            if node.child is not None:\n                child_start = node.child\n                curr_child = child_start\n                while True:\n                    if curr_child.key < node.key: return False # Heap-order violation\n                    if curr_child.parent != node: return False # Parent pointer mismatch\n                    curr_child = curr_child.right\n                    if curr_child == child_start: break\n        \n        return self.min_node.key == actual_min_key\n\ndef solve():\n    \"\"\"\n    Runs the test suite for the Fibonacci heap split operation and prints results.\n    \"\"\"\n    test_cases = [\n        (tuple([7, 3, 18, 39, 52, 41, 17, 30, 24, 26, 46]), 30, 1),\n        (tuple([1, 2, 2, 2, 3]), 3, 0),\n        (tuple([10, 11, 12]), 5, 0),\n        (tuple([-5, -1, 0, 0, 6, 6, 7]), 0, 2),\n        (tuple([]), 0, 0),\n        (tuple([5, 5, 5]), 5, 1)\n    ]\n\n    final_results = []\n    for keys, x, e in test_cases:\n        h = FibonacciHeap()\n        for k in keys:\n            h.insert(k)\n\n        for _ in range(e):\n            if h.is_empty():\n                break\n            h.extract_min()\n\n        original_keys_after_extraction = sorted([node.key for node in h.get_all_nodes()])\n\n        h_le, h_gt = h.split(x)\n\n        keys_le = [node.key for node in h_le.get_all_nodes()]\n        keys_gt = [node.key for node in h_gt.get_all_nodes()]\n\n        c_le = len(keys_le)\n        c_gt = len(keys_gt)\n        s_le = sum(keys_le) if c_le > 0 else 0\n        s_gt = sum(keys_gt) if c_gt > 0 else 0\n        m_le = h_le.get_min() if c_le > 0 else -1\n        m_gt = h_gt.get_min() if c_gt > 0 else -1\n\n        v = True\n        # 1. Partition correctness\n        if not all(k <= x for k in keys_le): v = False\n        if not all(k > x for k in keys_gt): v = False\n        # 2. Key conservation\n        if sorted(keys_le + keys_gt) != original_keys_after_extraction: v = False\n        # 3. Heap validity\n        if not h_le.is_valid(): v = False\n        if not h_gt.is_valid(): v = False\n\n        final_results.append([c_le, c_gt, s_le, s_gt, m_le, m_gt, v])\n\n    print(f\"[{','.join(f'[{\",\".join(map(str, res))}]' for res in final_results)}]\")\n\nsolve()\n```", "id": "3234478"}]}