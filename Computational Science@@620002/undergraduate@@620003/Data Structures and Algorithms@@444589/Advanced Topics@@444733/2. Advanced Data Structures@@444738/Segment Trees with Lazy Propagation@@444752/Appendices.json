{"hands_on_practices": [{"introduction": "We begin with a foundational exercise that introduces the core mechanics of lazy propagation in a clear and intuitive setting. In this problem, you will implement range bit-flips on a binary array, where the update operation is an involution, meaning it is its own inverse. This unique property simplifies the logic for managing lazy tags, providing an excellent starting point for understanding how updates are deferred and composed [@problem_id:3269161].", "problem": "You are to design and implement a Segment Tree with lazy propagation supporting range bit-flips and ones-count queries on a binary array. The operations and their semantics are defined as follows: given an array $A$ of length $n$ with entries $A[i] \\in \\{0,1\\}$ for indices $i$ in $[0,n-1]$, a range bit-flip on an interval $[l,r]$ applies the map $x \\mapsto 1 - x$ to each entry $A[i]$ with $i \\in [l,r]$, and a ones-count query on an interval $[l,r]$ returns the value $\\sum_{i=l}^{r} A[i]$. You must start from the fundamental definitions of a segment tree (a complete binary tree over array intervals aggregating segment values) and lazy propagation (deferral of updates via tags that represent functions to be applied later). Your implementation must compute the ones-count query correctly after any sequence of range bit-flips, with each operation executed in worst-case time $O(\\log n)$.\n\nIn addition to the implementation, you must provide a clear derivation, starting from the core definitions, that the lazy flip tag is its own inverse and that the tag composition satisfies $flip \\circ flip = id$ when viewed as function composition on elements of $\\{0,1\\}$. This derivation must be grounded in the properties of the flip map $f(x) = 1 - x$, the additive nature of the ones-count aggregate over an interval, and the algebra of composing such functions on the binary set.\n\nYour program must be self-contained, take no input, and run the following test suite. For each test case, apply the operations in order; for each ones-count query, append the resulting integer to the final results list. At the end, produce a single line of output containing the results as a comma-separated list enclosed in square brackets. No physical units are involved and no angles are used, so no unit specification is required. All indices are zero-based and all ranges are inclusive.\n\nTest Suite:\n- Test Case $1$ (general behavior with mixed updates and queries):\n  - Initial array $A = [\\,1,0,1,1,0,0,1,0,1,0\\,]$ with $n = 10$.\n  - Operations:\n    - $count([0,9])$\n    - $flip([2,7])$\n    - $count([0,9])$\n    - $flip([4,4])$\n    - $count([4,6])$\n    - $flip([0,9])$\n    - $count([0,9])$\n- Test Case $2$ (boundary: single element and involution check):\n  - Initial array $A = [\\,1\\,]$ with $n = 1$.\n  - Operations:\n    - $count([0,0])$\n    - $flip([0,0])$\n    - $count([0,0])$\n    - $flip([0,0])$\n    - $count([0,0])$\n- Test Case $3$ (double flip on a subrange and full-range flip):\n  - Initial array $A = [\\,0,0,0,0,0\\,]$ with $n = 5$.\n  - Operations:\n    - $count([1,3])$\n    - $flip([1,3])$\n    - $count([1,3])$\n    - $flip([1,3])$\n    - $count([1,3])$\n    - $flip([0,4])$\n    - $count([0,4])$\n- Test Case $4$ (overlapping flips on an all-ones array):\n  - Initial array $A = [\\,1,1,1,1,1,1,1,1\\,]$ with $n = 8$.\n  - Operations:\n    - $flip([0,3])$\n    - $flip([2,5])$\n    - $count([0,7])$\n    - $flip([0,7])$\n    - $count([0,7])$\n- Test Case $5$ (alternating pattern with multiple flips and queries):\n  - Initial array $A = [\\,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1\\,]$ with $n = 16$.\n  - Operations:\n    - $count([0,15])$\n    - $flip([0,7])$\n    - $count([0,15])$\n    - $flip([8,15])$\n    - $count([0,15])$\n    - $flip([4,11])$\n    - $count([3,12])$\n\nFinal Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,\\dots,r_k]$, where each $r_i$ is the integer answer to a ones-count query in the order encountered across all test cases.", "solution": "The problem requires the design of a data structure to support two operations on a binary array $A$ of length $n$: a range bit-flip and a range ones-count query. The bit-flip operation on a range $[l,r]$ transforms each element $A[i]$ to $1 - A[i]$ for $i \\in [l,r]$. The ones-count query on $[l,r]$ computes $\\sum_{i=l}^{r} A[i]$. All operations must be performed in $O(\\log n)$ time complexity. This is a classic application of a Segment Tree with Lazy Propagation.\n\nWe begin with the foundational principles.\n\nA Segment Tree is a complete binary tree used for storing information about intervals or segments of an array. Each node in the segment tree represents an interval. The root node represents the entire array, i.e., the interval $[0, n-1]$. Each internal node has two children, representing the two halves of its interval. A node representing interval $[s, e]$ will have a left child representing $[s, (s+e)/2]$ and a right child representing $[(s+e)/2 + 1, e]$. The leaf nodes represent individual elements of the array, corresponding to intervals of length $1$.\n\nFor the ones-count query, each node in the segment tree will store the sum of the elements in its corresponding interval. Let $C(v)$ be the ones-count for the node $v$. If $v_L$ and $v_R$ are the left and right children of an internal node $v$, then the aggregation property is additive:\n$$\nC(v) = C(v_L) + C(v_R)\n$$\nBuilding the tree involves recursively computing these sums from the leaves up to the root, which takes $O(n)$ time. A query for the sum over a range $[l,r]$ can be answered by summing the values of a set of $O(\\log n)$ nodes that perfectly cover the query range. This takes $O(\\log n)$ time.\n\nThe challenge lies in the range bit-flip update. A naive update would require modifying all $O(n)$ leaf nodes in the worst case, leading to an unacceptable $O(n)$ time complexity for a single update. To achieve the required $O(\\log n)$ complexity, we employ lazy propagation.\n\nLazy propagation is a technique to defer updates. We introduce a \"lazy tag\" for each node in the segment tree. This tag represents an update operation that is pending for the node's entire interval but has not yet been applied to its children. For our problem, the update is a bit-flip.\n\nLet us formally analyze the bit-flip operation. It is a map $f: \\{0,1\\} \\to \\{0,1\\}$ defined by $f(x) = 1 - x$. We must analyze the composition of this function with itself. Let's compute $(f \\circ f)(x)$:\n$$\n(f \\circ f)(x) = f(f(x)) = f(1 - x) = 1 - (1 - x) = 1 - 1 + x = x\n$$\nThis shows that $f \\circ f = id$, where $id$ is the identity function. Applying the flip operation twice is equivalent to doing nothing. This property means the operation is an involution. This algebraic structure suggests that the state of pending flips can be modeled using arithmetic modulo $2$. A flip is pending, or it is not. We can use a lazy tag $L(v) \\in \\{0, 1\\}$ for each node $v$. $L(v) = 1$ signifies a pending flip on the interval of $v$, and $L(v) = 0$ signifies no pending flip. When a new flip is to be applied to a node that already has a pending flip, we are composing $f \\circ f$. The new state should be \"no flip\", which corresponds to updating the lazy tag via the XOR operation: $L(v) \\leftarrow L(v) \\oplus 1$.\n\nWhen a flip is applied to a node $v$ covering an interval of length $|I_v|$, the number of ones, $C(v)$, changes. If there were $C(v)$ ones, there were $|I_v| - C(v)$ zeros. A flip converts all ones to zeros and all zeros to ones. The new count of ones will be:\n$$\nC(v)' = |I_v| - C(v)\n$$\n\nThe core of lazy propagation is the `push_down` operation. Before visiting the children of a node $v$ (during an update or query), we must propagate any pending update from $v$ to its children. If $L(v) = 1$, we apply the flip to its children $v_L$ and $v_R$:\n$1$. Update the aggregate values of the children: $C(v_L) \\leftarrow |I_{v_L}| - C(v_L)$ and $C(v_R) \\leftarrow |I_{v_R}| - C(v_R)$.\n$2$. Update the lazy tags of the children: $L(v_L) \\leftarrow L(v_L) \\oplus 1$ and $L(v_R) \\leftarrow L(v_R) \\oplus 1$.\n$3$. Reset the lazy tag of the parent node: $L(v) \\leftarrow 0$.\n\nNow, we can define the full algorithms. A segment tree is implemented using an array, typically of size $4n$. Let `tree[i]` be the aggregate value (ones-count) and `lazy[i]` be the lazy tag for node `i`.\n\n**Range Flip Update on $[l,r]$:**\nThis is a recursive function, starting at the root (node $1$, interval $[0, n-1]$). For a node $v$ covering interval $[s, e]$:\n$1$. First, apply and propagate any pending lazy tag at $v$ using the `push_down` procedure.\n$2$. If the node's interval $[s,e]$ is completely outside the update range $[l,r]$, do nothing.\n$3$. If the node's interval $[s,e]$ is completely inside the update range $[l,r]$:\n    a. Update its aggregate value: `tree[v]` becomes $(e-s+1) - \\text{tree}[v]$.\n    b. Update its lazy tag: `lazy[v]` is flipped (`lazy[v] ^= 1`).\n    c. Stop recursion for this path.\n$4$. If the node's interval $[s,e]$ partially overlaps $[l,r]$:\n    a. Recurse on the left child.\n    b. Recurse on the right child.\n    c. After recursion returns, update the current node's value based on its children's new values: `tree[v] = tree[left_child] + tree[right_child]`.\nThis process visits at most $O(\\log n)$ nodes, resulting in an $O(\\log n)$ time complexity.\n\n**Range Ones-Count Query on $[l,r]$:**\nThis is also a recursive function, starting at the root. For a node $v$ covering $[s, e]$:\n$1$. Apply and propagate any pending lazy tag at $v$ using the `push_down` procedure.\n$2$. If the node's interval $[s,e]$ is completely outside the query range $[l,r]$, return $0$.\n$3$. If the node's interval $[s,e]$ is completely inside the query range $[l,r]$, return its aggregate value `tree[v]`.\n$4$. If the node's interval $[s,e]$ partially overlaps $[l,r]$:\n    a. Recurse on the left child and the right child for their respective intersections with $[l,r]$.\n    b. Return the sum of the results from the recursive calls.\nSimilar to the update, this query also takes $O(\\log n)$ time.\n\nThis design satisfies all requirements of the problem, providing a correct and efficient solution grounded in the principles of segment trees and lazy propagation.", "answer": "```python\nimport sys\n\n# It is good practice to increase recursion limit for deep recursive structures like segment trees.\nsys.setrecursionlimit(2000)\n\nclass SegmentTreeLazy:\n    \"\"\"\n    Segment Tree with Lazy Propagation for range bit-flips and range sum queries.\n    The aggregate value stored is the count of ones.\n    \"\"\"\n    def __init__(self, data):\n        \"\"\"\n        Initializes the segment tree from the input array.\n        \"\"\"\n        self.n = len(data)\n        self.data = data\n        # Tree size is 4*n for a complete binary tree representation in an array\n        self.tree = [0] * (4 * self.n)\n        # Lazy array to store pending flips. 0 = no flip, 1 = flip pending.\n        self.lazy = [0] * (4 * self.n)\n        self._build(1, 0, self.n - 1)\n\n    def _build(self, node, start, end):\n        \"\"\"\n        Recursively builds the segment tree.\n        node: current node index in the tree array.\n        start, end: interval for the current node.\n        \"\"\"\n        if start == end:\n            # Leaf node: corresponds to a single element of the array\n            self.tree[node] = self.data[start]\n            return\n        \n        mid = (start + end) // 2\n        left_child = 2 * node\n        right_child = 2 * node + 1\n        \n        self._build(left_child, start, mid)\n        self._build(right_child, mid + 1, end)\n        \n        # Internal node's value is the sum of its children's values\n        self.tree[node] = self.tree[left_child] + self.tree[right_child]\n\n    def _push(self, node, start, end):\n        \"\"\"\n        Propagates lazy updates from a node to its children.\n        \"\"\"\n        if self.lazy[node] == 1:\n            # The length of the interval for the current node\n            interval_length = end - start + 1\n            # Apply the flip to the current node's value.\n            # Number of ones becomes (length - number of ones)\n            self.tree[node] = interval_length - self.tree[node]\n            \n            if start != end:  # Not a leaf node, so propagate to children\n                left_child = 2 * node\n                right_child = 2 * node + 1\n                # XOR toggles the lazy state of children\n                self.lazy[left_child] ^= 1\n                self.lazy[right_child] ^= 1\n            \n            # Reset the lazy flag for the current node\n            self.lazy[node] = 0\n\n    def _update(self, node, start, end, l, r):\n        \"\"\"\n        Recursive helper for range updates (flips).\n        l, r: the update range.\n        \"\"\"\n        self._push(node, start, end)\n        \n        # If current node's interval is outside the update range, do nothing\n        if start > end or start > r or end  l:\n            return\n            \n        # If current node's interval is completely inside the update range\n        if l = start and end = r:\n            # The length of the interval\n            interval_length = end - start + 1\n            # Apply the flip\n            self.tree[node] = interval_length - self.tree[node]\n            if start != end:\n                # Mark children as lazy\n                self.lazy[2 * node] ^= 1\n                self.lazy[2 * node + 1] ^= 1\n            return\n\n        # If current node's interval partially overlaps, recurse\n        mid = (start + end) // 2\n        left_child = 2 * node\n        right_child = 2 * node + 1\n        \n        self._update(left_child, start, mid, l, r)\n        self._update(right_child, mid + 1, end, l, r)\n        \n        # Update parent's value from its children\n        self.tree[node] = self.tree[left_child] + self.tree[right_child]\n\n    def update(self, l, r):\n        \"\"\"Public method for range flip.\"\"\"\n        self._update(1, 0, self.n - 1, l, r)\n\n    def _query(self, node, start, end, l, r):\n        \"\"\"\n        Recursive helper for range queries (ones-count).\n        l, r: the query range.\n        \"\"\"\n        if start > end or start > r or end  l:\n            return 0  # Outside range, contribution is 0\n            \n        self._push(node, start, end)\n            \n        if l = start and end = r:\n            return self.tree[node] # Completely inside range\n            \n        mid = (start + end) // 2\n        left_child = 2 * node\n        right_child = 2 * node + 1\n        \n        p1 = self._query(left_child, start, mid, l, r)\n        p2 = self._query(right_child, mid + 1, end, l, r)\n        \n        return p1 + p2\n\n    def query(self, l, r):\n        \"\"\"Public method for range ones-count query.\"\"\"\n        return self._query(1, 0, self.n - 1, l, r)\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"array\": [1, 0, 1, 1, 0, 0, 1, 0, 1, 0],\n            \"ops\": [(\"count\", 0, 9), (\"flip\", 2, 7), (\"count\", 0, 9), (\"flip\", 4, 4), (\"count\", 4, 6), (\"flip\", 0, 9), (\"count\", 0, 9)]\n        },\n        {\n            \"array\": [1],\n            \"ops\": [(\"count\", 0, 0), (\"flip\", 0, 0), (\"count\", 0, 0), (\"flip\", 0, 0), (\"count\", 0, 0)]\n        },\n        {\n            \"array\": [0, 0, 0, 0, 0],\n            \"ops\": [(\"count\", 1, 3), (\"flip\", 1, 3), (\"count\", 1, 3), (\"flip\", 1, 3), (\"count\", 1, 3), (\"flip\", 0, 4), (\"count\", 0, 4)]\n        },\n        {\n            \"array\": [1, 1, 1, 1, 1, 1, 1, 1],\n            \"ops\": [(\"flip\", 0, 3), (\"flip\", 2, 5), (\"count\", 0, 7), (\"flip\", 0, 7), (\"count\", 0, 7)]\n        },\n        {\n            \"array\": [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\n            \"ops\": [(\"count\", 0, 15), (\"flip\", 0, 7), (\"count\", 0, 15), (\"flip\", 8, 15), (\"count\", 0, 15), (\"flip\", 4, 11), (\"count\", 3, 12)]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        st = SegmentTreeLazy(case[\"array\"])\n        for op_type, l, r in case[\"ops\"]:\n            if op_type == \"flip\":\n                st.update(l, r)\n            elif op_type == \"count\":\n                result = st.query(l, r)\n                all_results.append(result)\n\n    # The problem specifies that numpy is available, but it is not needed for the core logic.\n    # The final output format must be a comma-separated list in brackets.\n    # Example: [r1,r2,r3]\n    # np is imported in the template but unused here to demonstrate adherence to standard library capability.\n    import numpy as np\n    \n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3269161"}, {"introduction": "Building upon the basics, this practice shifts the focus from the update operation to the aggregate data stored in each node. You will handle range additions while querying for both the minimum value in a range and the number of times it appears. This task requires you to design a more complex node structure and carefully define the logic for combining aggregates from child nodes and applying a lazy update to this composite data [@problem_id:3269202].", "problem": "Consider an array $A$ of $n$ integers indexed from $0$ to $n-1$ (zero-based indexing). Define a segment tree as a binary tree data structure where each node represents a contiguous subarray $A[\\ell \\dots r]$ and stores an aggregate summary of that subarray. You will implement a segment tree that supports two operations: range addition and range minimum queries with the count of indices achieving the minimum. Specifically, for any interval $[\\ell,r]$ and integer $\\Delta$, the range addition operation transforms each $A_i$ for $i \\in [\\ell,r]$ to $A_i + \\Delta$. For any interval $[\\ell,r]$, the range minimum query returns a pair $(m,c)$ where $m = \\min\\{A_i \\mid i \\in [\\ell,r]\\}$ and $c = \\left|\\{i \\in [\\ell,r] \\mid A_i = m\\}\\right|$.\n\nYour implementation must use lazy propagation. In lazy propagation, each node keeps a deferred update value that has not yet been pushed to its children, so that range updates can be applied in $O(\\log n)$ time without immediately updating all affected leaves. Your task is to derive, from first principles, how a pending range addition affects the node’s stored minimum and count, and to prove the correctness of the approach by induction on the height of the segment tree.\n\nFundamental base to use:\n- Definition of a segment tree node as representing a contiguous subarray $A[\\ell \\dots r]$ and storing a summary computed from its children.\n- The algebraic properties of minimum and addition over integers: for any integer $x$ and any set $S \\subset \\mathbb{Z}$, $\\min\\{s + x \\mid s \\in S\\} = \\min\\{s \\mid s \\in S\\} + x$, and if $T = \\{s \\in S \\mid s = \\min S\\}$ then $|T|$ remains unchanged by adding a constant to all elements of $S$.\n\nYou must implement a complete, runnable program that constructs the segment tree for each test case, performs the specified sequence of operations, and outputs the answers to the queries as specified. Indices are integers, all ranges $[\\ell,r]$ are inclusive, and all additions $\\Delta$ are integers. There are no physical units involved.\n\nThe test suite comprises five test cases that probe general behavior, boundaries, and edge scenarios. For each test case, you are given an initial array and a sequence of operations. The program must execute the operations in order and collect the results of each query operation.\n\nTest Case $1$:\n- Initial array $A^{(1)} = [\\,3,1,4,1,5,9,2,6\\,]$.\n- Operations:\n  - Query on $[\\,0,7\\,]$.\n  - Range add $\\Delta = +3$ on $[\\,2,5\\,]$.\n  - Query on $[\\,0,7\\,]$.\n  - Range add $\\Delta = -2$ on $[\\,0,7\\,]$.\n  - Query on $[\\,0,7\\,]$.\n  - Query on $[\\,6,7\\,]$.\n\nTest Case $2$:\n- Initial array $A^{(2)} = [\\,0\\,]$.\n- Operations:\n  - Query on $[\\,0,0\\,]$.\n  - Range add $\\Delta = +5$ on $[\\,0,0\\,]$.\n  - Query on $[\\,0,0\\,]$.\n  - Range add $\\Delta = -5$ on $[\\,0,0\\,]$.\n  - Query on $[\\,0,0\\,]$.\n\nTest Case $3$:\n- Initial array $A^{(3)} = [\\,0,0,0,0,0,0,0,0,0,0\\,]$.\n- Operations:\n  - Range add $\\Delta = +1$ on $[\\,0,9\\,]$.\n  - Range add $\\Delta = +2$ on $[\\,3,6\\,]$.\n  - Range add $\\Delta = -1$ on $[\\,5,9\\,]$.\n  - Query on $[\\,0,9\\,]$.\n  - Query on $[\\,0,4\\,]$.\n  - Query on $[\\,5,6\\,]$.\n  - Range add $\\Delta = -2$ on $[\\,0,2\\,]$.\n  - Query on $[\\,0,9\\,]$.\n  - Query on $[\\,0,2\\,]$.\n\nTest Case $4$:\n- Initial array $A^{(4)} = [\\,-10,-10,-10,-10,-10\\,]$.\n- Operations:\n  - Query on $[\\,0,4\\,]$.\n  - Range add $\\Delta = +10$ on $[\\,1,3\\,]$.\n  - Query on $[\\,0,4\\,]$.\n  - Range add $\\Delta = +10$ on $[\\,0,4\\,]$.\n  - Query on $[\\,0,4\\,]$.\n  - Range add $\\Delta = -5$ on $[\\,2,2\\,]$.\n  - Query on $[\\,1,3\\,]$.\n\nTest Case $5$:\n- Initial array $A^{(5)} = [\\,7,2,5,2,9,2,4,2,6,2,8,2\\,]$.\n- Operations:\n  - Query on $[\\,0,11\\,]$.\n  - Range add $\\Delta = -1$ on $[\\,0,11\\,]$.\n  - Query on $[\\,0,11\\,]$.\n  - Range add $\\Delta = +3$ on $[\\,1,10\\,]$.\n  - Query on $[\\,0,11\\,]$.\n  - Range add $\\Delta = -2$ on $[\\,0,0\\,]$.\n  - Query on $[\\,0,5\\,]$.\n  - Range add $\\Delta = -3$ on $[\\,7,11\\,]$.\n  - Query on $[\\,6,11\\,]$.\n\nYour program should produce a single line of output containing the results aggregated across all test cases as one outer list. For each test case, output an inner list of all query results in the order they occur. Each query result must be a two-element list $[\\,m,c\\,]$ where $m$ is the minimum value and $c$ is the count of indices achieving that minimum. The final output format must be exactly one line of the form $[\\,\\text{case}_1,\\text{case}_2,\\dots,\\text{case}_5\\,]$ where each $\\text{case}_k$ is a list $[\\, [\\,m_1,c_1\\,], [\\,m_2,c_2\\,], \\dots \\,]$.", "solution": "The problem requires the design and implementation of a segment tree with lazy propagation to support two operations on an array $A$ of $n$ integers: range addition and range minimum query with a count of occurrences. We must first formally derive the update and query logic and prove its correctness.\n\nA segment tree is a binary tree used for storing information about intervals or segments. Each node in the segment tree represents an interval. Let a node $u$ in the tree correspond to the contiguous subarray $A[\\ell \\dots r]$. This node must store an aggregate summary of this subarray. For this problem, the summary is a pair $(m, c)$, where $m = \\min\\{A_i \\mid i \\in [\\ell, r]\\}$ is the minimum value in the subarray and $c = |\\{i \\in [\\ell, r] \\mid A_i = m\\}|$ is the number of times this minimum value appears.\n\nLet the left child of node $u$ represent the subarray $A[\\ell \\dots k]$ and the right child represent $A[k+1 \\dots r]$, where $k = \\lfloor (\\ell+r)/2 \\rfloor$. Let the summaries stored in the left and right children be $(m_L, c_L)$ and $(m_R, c_R)$, respectively. The summary $(m_P, c_P)$ for the parent node $u$ can be computed by combining the children's summaries:\n$$m_P = \\min(m_L, m_R)$$\n$$c_P = \n\\begin{cases} \nc_L  \\text{if } m_L  m_R \\\\\nc_R  \\text{if } m_R  m_L \\\\\nc_L + c_R  \\text{if } m_L = m_R\n\\end{cases}\n$$\nThis combination rule forms the basis of the `pull` operation, which updates a parent's summary from its children's. The base cases for this recursion are the leaf nodes, where for a node representing the subarray $A[i \\dots i]$, the summary is $(A_i, 1)$.\n\nRange updates are handled efficiently using lazy propagation. Each node $u$ will have an additional field, `lazy`, which stores a pending update value $\\Delta$ that needs to be applied to the entire range $A[\\ell \\dots r]$ corresponding to node $u$. An update operation for adding a value $\\Delta_{op}$ to a range $[\\ell_{q} \\dots r_{q}]$ proceeds as follows:\nWhen traversing the tree, for a node $u$ with range $[\\ell \\dots r]$:\n$1$. If $[\\ell \\dots r]$ is completely outside $[\\ell_{q} \\dots r_{q}]$, no action is taken.\n$2$. If $[\\ell \\dots r]$ is completely inside $[\\ell_{q} \\dots r_{q}]$, we update the node's lazy tag by adding $\\Delta_{op}$ to it. We then update the node's stored minimum based on this lazy value. According to the given algebraic property, $\\min\\{s + x \\mid s \\in S\\} = \\min\\{s \\mid s \\in S\\} + x$. All elements in the range $[\\ell \\dots r]$ are increased by $\\Delta_{op}$, so the minimum value also increases by $\\Delta_{op}$. The count of the minimum is invariant. Thus, we update $u.m \\to u.m + \\Delta_{op}$ and $u.c$ remains unchanged. We do not proceed to the children, embodying the \"lazy\" aspect.\n$3$. If $[\\ell \\dots r]$ partially overlaps with $[\\ell_{q} \\dots r_{q}]$, we must first propagate the pending updates at node $u$ to its children. This is the `push` operation. Then, we recursively call the update on the children. Finally, we update the summary of node $u$ by pulling the (potentially modified) summaries from its children.\n\nThe `push` operation for a node $u$ with lazy value $\\Delta_u \\neq 0$ entails:\n$1$. For each child $v$ (left and right), add $\\Delta_u$ to its lazy tag: $v.\\text{lazy} \\to v.\\text{lazy} + \\Delta_u$.\n$2$. Update the child's summary. Its stored minimum is increased by $\\Delta_u$: $v.m \\to v.m + \\Delta_u$. The count $v.c$ is unchanged.\n$3$. Reset the parent's lazy tag to the identity element for addition, which is $0$: $u.\\text{lazy} \\to 0$.\n\nRange queries are performed similarly. A query for range $[\\ell_{q} \\dots r_{q}]$ proceeds as follows for a node $u$ with range $[\\ell \\dots r]$:\n$1$. If $[\\ell \\dots r]$ is outside $[\\ell_{q} \\dots r_{q}]$, return an identity summary, $(\\infty, 0)$, which will not affect the combination.\n$2$. If $[\\ell \\dots r]$ is inside $[\\ell_{q} \\dots r_{q}]$, return the node's stored summary $(u.m, u.c)$.\n$3$. If partial overlap, first `push` the lazy tag of node $u$ to its children. Then, recursively query the left and right children and combine their results using the combination rule defined earlier.\n\n**Proof of Correctness by Induction**\n\nWe prove the correctness of the lazy propagation scheme for maintaining the summaries.\n**Claim:** For any node $u$ in the segment tree corresponding to range $[\\ell \\dots r]$, the effective state of the subarray $A[\\ell \\dots r]$ is correctly represented. Specifically, the true minimum of the subarray is given by $u.m + \\sum_{v \\in \\text{Path}(\\text{root}, u)} v.\\text{lazy}$, and the count $u.c$ is the correct count for this minimum. By design, our `push` operation moves the lazy tag of a node $v$ to its children, while simultaneously applying its effect to their stored minimums, thus preserving this invariant. We can simplify the claim by stating that after all lazy values on the path from the root down to a node's children have been pushed, the node's stored pair $(m,c)$ is correct for its range.\n\n**Base Case (Height $h=0$, leaf nodes):**\nA leaf node $u$ represents a single element $A[i]$. Its summary is $(A[i], 1)$. During a range update on $[\\ell_q \\dots r_q]$ with value $\\Delta$, if $i \\in [\\ell_q \\dots r_q]$, the update algorithm will eventually reach a node whose range is fully contained in the update range. This node (an ancestor of $u$, or $u$ itself) has its lazy tag updated. Let's trace the effect on $u$. Before any query or further update involving the range of $u$, any lazy tag on an ancestor of $u$ will be pushed down. Eventually, $\\Delta$ will be added to $u$'s lazy tag. Let's say we apply this effect directly. The leaf's value becomes $A[i] + \\Delta$. The stored minimum becomes $m_u + \\Delta$, and the count remains $1$. This is correct. The `push` mechanism ensures this accumulated effect is correctly passed down.\n\n**Inductive Hypothesis (IH):**\nAssume for all nodes at a height less than $h$ (i.e., in subtrees of height $ h$), the query and update operations correctly maintain the stored summaries $(m, c)$ and lazy tags, preserving the invariant.\n\n**Inductive Step (Height $h$):**\nConsider a node $u$ at height $h$ with children $v_L$ and $v_R$ at height $h-1$. Its range is $[\\ell_u \\dots r_u]$, while its children's ranges are $[\\ell_u \\dots k]$ and $[k+1 \\dots r_u]$. By the IH, operations on the subtrees rooted at $v_L$ and $v_R$ are correct.\n\nConsider an operation (update or query) on a range $[\\ell_q \\dots r_q]$.\n- If $[\\ell_u \\dots r_u]$ is fully contained in $[\\ell_q \\dots r_q]$:\n    - For an update by $\\Delta$: $u.\\text{lazy} \\to u.\\text{lazy} + \\Delta$, and $u.m \\to u.m + \\Delta$. The count $u.c$ is unchanged. This is correct based on the given algebraic property $\\min\\{s+x\\} = \\min\\{s\\}+x$. The modification is deferred correctly.\n    - For a query: the value $(u.m, u.c)$ is returned. Since all lazy tags from ancestors have been pushed down to this level before the query recursed here, this value, representing the minimum over the range $[\\ell_u \\dots r_u]$, is correct.\n\n- If $[\\ell_q \\dots r_q]$ partially overlaps with $[\\ell_u \\dots r_u]$:\n    1. The `push(u)` operation is called. The lazy tag $\\Delta_u$ is added to the children's lazy tags, and their minimums are updated: $v_L.m \\to v_L.m + \\Delta_u$ and $v_R.m \\to v_R.m + \\Delta_u$. Their counts are unchanged. By the IH, the children's subtrees were in a correct state. Applying this uniform addition preserves the correctness of their summaries relative to the now-updated lazy values. The logic is sound due to the distributive nature of addition over minimums. After this, $u.\\text{lazy}$ is reset to $0$.\n    2. The operation recursively proceeds to the children $v_L$ and $v_R$. By the IH, these operations will correctly update the subtrees rooted at $v_L$ and $v_R$.\n    3. The `pull` operation `u.summary = combine(v_L.summary, v_R.summary)` is performed. Since, by the IH, the summaries of $v_L$ and $v_R$ are now correct for their respective ranges (with all lazy effects accounted for), the `combine` logic correctly computes the summary for the range of $u$.\n\nThe logic for handling full containment, partial overlap, and no overlap, combined with the `push` and `pull` operations, correctly maintains the invariants at every node. By induction, the scheme is correct for the entire tree.\n\nThe implementation will follow this derived structure.", "answer": "```python\nimport numpy as np\nimport sys\n\n# It is good practice to increase recursion limit for deep recursion in segment trees.\nsys.setrecursionlimit(200000)\n\nclass SegmentTree:\n    \"\"\"\n    Segment Tree with Lazy Propagation for Range Addition and Range Minimum/Count Query.\n    \"\"\"\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.arr = arr\n        # Use numpy arrays for performance. 4*n is a safe upper bound for tree size.\n        self.tree_min = np.full(4 * self.n, np.inf, dtype=np.int64)\n        self.tree_count = np.zeros(4 * self.n, dtype=np.int64)\n        self.lazy = np.zeros(4 * self.n, dtype=np.int64)\n        \n        if self.n > 0:\n            self._build(1, 0, self.n - 1)\n\n    def _combine(self, left_res, right_res):\n        \"\"\"\n        Combines results from two children nodes.\n        left_res: (min_val, min_count) from the left child.\n        right_res: (min_val, min_count) from the right child.\n        \"\"\"\n        min_l, count_l = left_res\n        min_r, count_r = right_res\n\n        if min_l  min_r:\n            return min_l, count_l\n        elif min_r  min_l:\n            return min_r, count_r\n        else: # min_l == min_r\n            # If both are infinity, the count is 0. Otherwise, sum counts.\n            if min_l == np.inf:\n                return np.inf, 0\n            return min_l, count_l + count_r\n    \n    def _apply_lazy(self, v, val):\n        \"\"\"Applies a lazy value to a node.\"\"\"\n        if val != 0:\n            self.tree_min[v] += val\n            self.lazy[v] += val\n\n    def _push(self, v):\n        \"\"\"Pushes the lazy value from node v to its children.\"\"\"\n        if self.lazy[v] != 0:\n            # Apply to left child (2*v) and right child (2*v+1)\n            self._apply_lazy(2 * v, self.lazy[v])\n            self._apply_lazy(2 * v + 1, self.lazy[v])\n            self.lazy[v] = 0\n\n    def _build(self, v, tl, tr):\n        \"\"\"Recursively builds the segment tree.\"\"\"\n        if tl == tr:\n            self.tree_min[v] = self.arr[tl]\n            self.tree_count[v] = 1\n        else:\n            tm = (tl + tr) // 2\n            self._build(2 * v, tl, tm)\n            self._build(2 * v + 1, tm + 1, tr)\n            \n            # Pull information from children\n            combined_min, combined_count = self._combine(\n                (self.tree_min[2 * v], self.tree_count[2 * v]),\n                (self.tree_min[2 * v + 1], self.tree_count[2 * v + 1])\n            )\n            self.tree_min[v] = combined_min\n            self.tree_count[v] = combined_count\n\n    def _update_range(self, v, tl, tr, l, r, addval):\n        \"\"\"Recursively performs range update.\"\"\"\n        if l > r:\n            return\n        \n        # Current segment is fully within update range\n        if l == tl and r == tr:\n            self._apply_lazy(v, addval)\n            return\n\n        self._push(v) # Push lazy value before recursing\n        \n        tm = (tl + tr) // 2\n        # Recurse on children, splitting the update range\n        self._update_range(2 * v, tl, tm, l, min(r, tm), addval)\n        self._update_range(2 * v + 1, tm + 1, tr, max(l, tm + 1), r, addval)\n        \n        # Pull information back up\n        combined_min, combined_count = self._combine(\n            (self.tree_min[2*v], self.tree_count[2*v]),\n            (self.tree_min[2*v+1], self.tree_count[2*v+1])\n        )\n        self.tree_min[v] = combined_min\n        self.tree_count[v] = combined_count\n\n    def update(self, l, r, addval):\n        \"\"\"Public method for range update.\"\"\"\n        if self.n > 0:\n            self._update_range(1, 0, self.n - 1, l, r, addval)\n\n    def _query_range(self, v, tl, tr, l, r):\n        \"\"\"Recursively performs range query.\"\"\"\n        if l > r:\n            # Sentinel value for an empty range\n            return np.inf, 0\n        \n        # Current segment is fully within query range\n        if l == tl and r == tr:\n            return self.tree_min[v], self.tree_count[v]\n\n        self._push(v) # Push lazy value before querying\n\n        tm = (tl + tr) // 2\n        # Recurse on children, splitting the query range\n        left_res = self._query_range(2 * v, tl, tm, l, min(r, tm))\n        right_res = self._query_range(2 * v + 1, tm + 1, tr, max(l, tm + 1), r)\n        \n        return self._combine(left_res, right_res)\n\n    def query(self, l, r):\n        \"\"\"Public method for range query.\"\"\"\n        if self.n == 0:\n            return [float('inf'), 0]\n        min_val, count = self._query_range(1, 0, self.n - 1, l, r)\n        return [int(min_val), int(count)]\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"array\": [3, 1, 4, 1, 5, 9, 2, 6],\n            \"ops\": [\n                ('q', 0, 7), ('u', 2, 5, 3), ('q', 0, 7), \n                ('u', 0, 7, -2), ('q', 0, 7), ('q', 6, 7)\n            ]\n        },\n        {\n            \"array\": [0],\n            \"ops\": [\n                ('q', 0, 0), ('u', 0, 0, 5), ('q', 0, 0), \n                ('u', 0, 0, -5), ('q', 0, 0)\n            ]\n        },\n        {\n            \"array\": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            \"ops\": [\n                ('u', 0, 9, 1), ('u', 3, 6, 2), ('u', 5, 9, -1),\n                ('q', 0, 9), ('q', 0, 4), ('q', 5, 6),\n                ('u', 0, 2, -2), ('q', 0, 9), ('q', 0, 2)\n            ]\n        },\n        {\n            \"array\": [-10, -10, -10, -10, -10],\n            \"ops\": [\n                ('q', 0, 4), ('u', 1, 3, 10), ('q', 0, 4),\n                ('u', 0, 4, 10), ('q', 0, 4), ('u', 2, 2, -5), ('q', 1, 3)\n            ]\n        },\n        {\n            \"array\": [7, 2, 5, 2, 9, 2, 4, 2, 6, 2, 8, 2],\n            \"ops\": [\n                ('q', 0, 11), ('u', 0, 11, -1), ('q', 0, 11),\n                ('u', 1, 10, 3), ('q', 0, 11), ('u', 0, 0, -2),\n                ('q', 0, 5), ('u', 7, 11, -3), ('q', 6, 11)\n            ]\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        st = SegmentTree(case[\"array\"])\n        case_results = []\n        for op_info in case[\"ops\"]:\n            op_type = op_info[0]\n            if op_type == 'q':\n                _, l, r = op_info\n                result = st.query(l, r)\n                case_results.append(result)\n            elif op_type == 'u':\n                _, l, r, val = op_info\n                st.update(l, r, val)\n        all_results.append(case_results)\n\n    # Manual formatting to match the exact string representation required.\n    # This avoids adding spaces after commas, which `json.dumps` or `str` might do.\n    outer_parts = []\n    for case_res in all_results:\n        inner_parts = []\n        for res_pair in case_res:\n            inner_parts.append(f\"[{res_pair[0]},{res_pair[1]}]\")\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    \n    final_output = f\"[{','.join(outer_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3269202"}, {"introduction": "This advanced practice explores the powerful algebraic structure that underpins lazy propagation. You will implement range affine updates, where each element is transformed by a function $f(x) = ax+b$. Since these updates do not commute, their order matters, forcing you to treat lazy tags as functions and correctly handle their composition. This problem solidifies the concept that lazy propagation is fundamentally about composing functions on segments of an array, a key insight for solving a wide variety of complex problems [@problem_id:3269114].", "problem": "You are tasked with designing and implementing a program that supports range affine updates and range sum queries on an integer array using a Segment Tree (ST) with Lazy Propagation. The array consists of elements $x_i$. A range affine update applies a function $f(x) = a x + b$ to every element $x_i$ in an index range $[L, R]$. A range sum query returns $\\sum_{i=L}^{R} x_i$. The fundamental base you should use consists of the linearity of summation, the algebra of affine functions, and the definition of lazy propagation in a tree structure.\n\nBegin from the following foundational facts and definitions:\n- Affine function: for real parameters $a$ and $b$, define $f(x) = a x + b$.\n- Linearity of summation: for any scalars $a$, $b$, and elements $x_i$, the sum under an affine transformation is $$\\sum_{i=L}^{R} f(x_i) = \\sum_{i=L}^{R} (a x_i + b) = a \\sum_{i=L}^{R} x_i + b \\cdot \\ell,$$ where $\\ell = R - L + 1$ is the segment length.\n- Composition of affine functions: for $f(x) = \\alpha x + \\beta$ and $g(x) = \\gamma x + \\delta$, the composition is $$g(f(x)) = g(\\alpha x + \\beta) = \\gamma (\\alpha x + \\beta) + \\delta = (\\gamma \\alpha) x + (\\gamma \\beta + \\delta).$$\n- Segment Tree (ST): a binary tree where each node represents a contiguous segment $[l, r]$ of the array and stores the aggregate (here, the sum) over that segment.\n- Lazy Propagation: defers application of updates to children by storing a \"lazy tag\" at a node that represents the pending transformation for all elements in that node’s segment.\n\nYour tasks are:\n1. Derive, from the above base, the push-up rule for the ST aggregation and the push-down rule for lazy tags:\n   - Push-up: given a node with children storing sums $S_L$ and $S_R$, derive the formula for the parent node’s sum $S$.\n   - Push-down: suppose a parent has a lazy tag $F(x) = \\alpha x + \\beta$ and a child has a lazy tag $G(x) = \\gamma x + \\delta$. When pushing the parent’s tag to the child, derive the correct composition order and the explicit formulas for the child’s new tag and sum, expressed only using $\\alpha$, $\\beta$, $\\gamma$, $\\delta$, and the child segment length $\\ell$.\n2. Implement a Segment Tree supporting:\n   - Range update applying $f(x) = a x + b$ to all $x_i$ in $[L, R]$.\n   - Range sum query returning $\\sum_{i=L}^{R} x_i$.\n   The ST must store at each node the segment sum $S$ and a lazy tag represented by parameters $(\\text{la}, \\text{lb})$, which encode an affine function $x \\mapsto \\text{la} \\cdot x + \\text{lb}$ pending on that segment. The identity tag must be $x \\mapsto 1 \\cdot x + 0$, i.e., $(\\text{la}, \\text{lb}) = (1, 0)$.\n3. Validate the implementation using a naive baseline that directly applies updates to the array and computes sums by iteration. Construct the following adversarial test suite. For each test case, start with the given initial array and execute the listed operations in order. Use zero-based indexing, and interpret update parameters $a$ and $b$ as in $f(x) = a x + b$. For each query, collect the sum result. Compare the list of query results produced by your ST with those produced by the naive baseline, and report whether they match exactly.\n\nTest suite:\n- Test case $1$:\n  - Initial array: $[1, 2, 3, 4, 5]$.\n  - Operations:\n    - Update on $[1, 3]$ with $a = 2$, $b = 1$.\n    - Query on $[0, 4]$.\n    - Update on $[0, 4]$ with $a = 1$, $b = -3$.\n    - Query on $[2, 2]$.\n    - Update on $[2, 2]$ with $a = 0$, $b = 7$.\n    - Query on $[0, 4]$.\n- Test case $2$:\n  - Initial array: $[-5, 0, 5]$.\n  - Operations:\n    - Update on $[0, 2]$ with $a = -1$, $b = 0$.\n    - Update on $[1, 1]$ with $a = 3$, $b = 2$.\n    - Query on $[0, 2]$.\n    - Update on $[0, 0]$ with $a = 2$, $b = 5$.\n    - Query on $[0, 1]$.\n    - Update on $[2, 2]$ with $a = 1$, $b = -4$.\n    - Query on $[2, 2]$.\n- Test case $3$:\n  - Initial array: $[10, -2, 7, 3, 0, 5]$.\n  - Operations:\n    - Update on $[0, 5]$ with $a = 2$, $b = 1$.\n    - Update on $[2, 4]$ with $a = 3$, $b = -2$.\n    - Update on $[1, 3]$ with $a = -1$, $b = 4$.\n    - Query on $[0, 5]$.\n    - Query on $[2, 3]$.\n    - Update on $[0, 0]$ with $a = 5$, $b = 0$.\n    - Update on $[0, 5]$ with $a = 0$, $b = 1$.\n    - Query on $[0, 5]$.\n    - Update on $[3, 5]$ with $a = 10$, $b = -10$.\n    - Query on $[3, 5]$.\n- Test case $4$:\n  - Initial array: $[1, 1, 1, 1]$.\n  - Operations:\n    - Update on $[0, 3]$ with $a = 1$, $b = 0$.\n    - Query on $[0, 3]$.\n    - Update on $[1, 2]$ with $a = 1$, $b = 5$.\n    - Query on $[0, 3]$.\n    - Update on $[1, 1]$ with $a = 1$, $b = -5$.\n    - Query on $[0, 3]$.\n- Test case $5$:\n  - Initial array: $[1000000, -1000000, 123456, -654321, 42]$.\n  - Operations:\n    - Update on $[0, 4]$ with $a = 2$, $b = 3$.\n    - Query on $[0, 4]$.\n    - Update on $[2, 4]$ with $a = 0$, $b = -7$.\n    - Query on $[0, 4]$.\n    - Update on $[1, 3]$ with $a = -3$, $b = 11$.\n    - Query on $[1, 3]$.\n\nFinal output format:\n- Your program must produce a single line of output containing a comma-separated list enclosed in square brackets. Each element corresponds to a test case and equals a boolean value indicating whether the Segment Tree’s query results match exactly the naive baseline for that test case, for example, $[ \\text{True}, \\text{False}, \\text{True} ]$.", "solution": "The problem requires the design and implementation of a Segment Tree with Lazy Propagation to handle range affine updates ($x \\mapsto a x + b$) and range sum queries on an array. The solution must be derived from first principles as specified.\n\nThe core of the problem lies in defining how aggregate information (sum) and pending updates (lazy tags) are managed within the tree structure. An affine transformation is not distributive over addition in the same way simple addition is, so a more complex lazy propagation scheme is necessary. The foundation is the composition of affine functions and the linearity of summation.\n\nLet a node in the segment tree correspond to a segment of length $\\ell$. This node stores the sum of its elements, $S$, and a lazy tag representing a pending affine transformation, $f(x) = \\text{la} \\cdot x + \\text{lb}$. The identity transformation is $f(x) = 1 \\cdot x + 0$, so the identity lazy tag is $(\\text{la}, \\text{lb}) = (1, 0)$.\n\n**1. Derivation of Tree Operations**\n\n**Push-Up Rule (Aggregation):**\nA non-leaf node represents the union of the disjoint segments of its two children. Therefore, the sum of the elements in the parent's segment is the direct sum of the sums from its children. Given a left child with sum $S_L$ and a right child with sum $S_R$, the parent's sum $S$ is:\n$$ S = S_L + S_R $$\n\n**Push-Down Rule (Lazy Propagation):**\nThis rule defines how a parent node's pending update is propagated to its children. Suppose a parent node has a lazy tag $(\\alpha, \\beta)$, representing the function $F(x) = \\alpha x + \\beta$. A child node has its own existing lazy tag $(\\gamma, \\delta)$, representing $G(x) = \\gamma x + \\delta$.\n\n*   **Composition of Lazy Tags**: Updates are chronological. The parent's update $F$ is more recent than the child's existing update $G$. Thus, when the true value of an element $x_i$ in the child's segment is calculated, $G$ is applied first, then $F$. The composed transformation is $H(x) = F(G(x))$. Based on the provided formula for composition:\n    $$ H(x) = F(G(x)) = \\alpha(\\gamma x_i + \\delta) + \\beta = (\\alpha\\gamma)x_i + (\\alpha\\delta + \\beta) $$\n    This is a new affine function. Therefore, when pushing the parent's tag $(\\alpha, \\beta)$ to a child with tag $(\\gamma, \\delta)$, the child's new lazy tag $(\\gamma', \\delta')$ becomes:\n    $$ \\gamma' = \\alpha \\gamma $$\n    $$ \\delta' = \\alpha \\delta + \\beta $$\n\n*   **Updating the Child's Sum**: Let the child node's current stored sum be $S_{\\text{child}}$ and its segment length be $\\ell_{\\text{child}}$. This sum reflects the state of the segment *before* the parent's lazy tag $(\\alpha, \\beta)$ is applied. To update the sum, we apply the transformation $F(x) = \\alpha x + \\beta$ to every element that contributes to $S_{\\text{child}}$. Using the provided linearity of summation principle:\n    $$ S_{\\text{child}}^{\\text{new}} = \\sum_{i=1}^{\\ell_{\\text{child}}} (\\alpha y_i + \\beta) = \\alpha \\left(\\sum_{i=1}^{\\ell_{\\text{child}}} y_i\\right) + \\sum_{i=1}^{\\ell_{\\text{child}}} \\beta = \\alpha S_{\\text{child}} + \\beta \\ell_{\\text{child}} $$\n    where $y_i$ are the current values in the child's segment.\n\n**2. Algorithmic Design**\n\nThe Segment Tree is implemented as a class. A node at index $k$ in an array-based tree represents a segment $[s, e]$. It stores its sum $S$ in `tree[k]` and its lazy tag $(\\text{la}, \\text{lb})$ in `lazy_a[k]` and `lazy_b[k]`.\n\nThe key methods are:\n*   `_apply_lazy(k, s, e, a, b)`: Applies an incoming transformation $(a, b)$ to the node $k$. It updates `tree[k]` using the sum update rule and composes $(a, b)$ with the existing lazy tag `(lazy_a[k], lazy_b[k])` using the composition rule.\n*   `_push(k, s, e)`: Propagates the lazy tag from node $k$ to its children ($2k$ and $2k+1$). It calls `_apply_lazy` on each child with the parent's tag `(lazy_a[k], lazy_b[k])` and then resets the parent's lazy tag to identity $(1, 0)$.\n*   `_update(k, s, e, l, r, a, b)`: Applies an affine update $(a, b)$ to the range $[l, r]$. If the node's range $[s, e]$ is fully contained in $[l, r]$, it calls `_apply_lazy` on node $k$. If there's partial overlap, it first calls `_push(k, s, e)` to clear its lazy state, then recursively calls `_update` on its children. Finally, it calls a `_pull` operation (equivalent to $S=S_L+S_R$) to update its own sum from the potentially modified children.\n*   `_query(k, s, e, l, r)`: Computes the sum over range $[l, r]$. If the node's range is fully contained in $[l, r]$, it returns `tree[k]`. For a partial overlap, it first calls `_push(k, s, e)`, then recursively queries its children and sums their results.\n\nThis design ensures that at any point, the sum `tree[k]` is the correct value for its segment $[s, e]$ considering all updates applied directly to it or its ancestors, which have been propagated down to it.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and validate the Segment Tree implementation.\n    \"\"\"\n\n    class NaiveBaseline:\n        \"\"\"\n        A naive implementation for verification. It directly manipulates an array.\n        \"\"\"\n        def __init__(self, data):\n            # Use dtype=object to allow for arbitrary-precision integers,\n            # preventing overflow issues.\n            self.data = np.array(data, dtype=object)\n\n        def update(self, l, r, a, b):\n            \"\"\"Applies affine update f(x) = a*x + b to range [l, r].\"\"\"\n            for i in range(l, r + 1):\n                self.data[i] = a * self.data[i] + b\n\n        def query(self, l, r):\n            \"\"\"Computes the sum of elements in range [l, r].\"\"\"\n            if l > r:\n                return 0\n            return np.sum(self.data[l:r + 1])\n\n    class SegmentTreeAffine:\n        \"\"\"\n        Segment Tree with Lazy Propagation for range affine updates and range sum queries.\n        \"\"\"\n        def __init__(self, data):\n            self.n = len(data)\n            # Use Python lists for tree storage to leverage arbitrary-precision integers.\n            self.tree = [0] * (4 * self.n)\n            self.lazy_a = [1] * (4 * self.n)\n            self.lazy_b = [0] * (4 * self.n)\n            self._build(data, 1, 0, self.n - 1)\n\n        def _build(self, data, node, start, end):\n            if start == end:\n                self.tree[node] = data[start]\n                return\n            mid = (start + end) // 2\n            self._build(data, 2 * node, start, mid)\n            self._build(data, 2 * node + 1, mid + 1, end)\n            self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]\n\n        def _apply_lazy(self, node, start, end, a, b):\n            # Update sum based on the formula: S_new = a * S_old + b * length\n            self.tree[node] = a * self.tree[node] + b * (end - start + 1)\n            # Compose lazy tags: new_lazy = compose((a, b), old_lazy)\n            # new_lazy_a = a * old_lazy_a\n            # new_lazy_b = a * old_lazy_b + b\n            self.lazy_a[node] = a * self.lazy_a[node]\n            self.lazy_b[node] = a * self.lazy_b[node] + b\n        \n        def _push(self, node, start, end):\n            # If no pending update (identity tag), do nothing.\n            if self.lazy_a[node] == 1 and self.lazy_b[node] == 0:\n                return\n            \n            mid = (start + end) // 2\n            a, b = self.lazy_a[node], self.lazy_b[node]\n\n            # Propagate to left child\n            self._apply_lazy(2 * node, start, mid, a, b)\n            # Propagate to right child\n            self._apply_lazy(2 * node + 1, mid + 1, end, a, b)\n\n            # Reset the parent's lazy tag to identity\n            self.lazy_a[node] = 1\n            self.lazy_b[node] = 0\n\n        def _update(self, node, start, end, l, r, a, b):\n            # No overlap\n            if start > r or end  l:\n                return\n\n            # Full overlap: apply the update and store as lazy tag\n            if l = start and end = r:\n                self._apply_lazy(node, start, end, a, b)\n                return\n            \n            # Partial overlap: push down, recurse, then pull up\n            self._push(node, start, end)\n\n            mid = (start + end) // 2\n            self._update(2 * node, start, mid, l, r, a, b)\n            self._update(2 * node + 1, mid + 1, end, l, r, a, b)\n\n            self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]\n\n        def _query(self, node, start, end, l, r):\n            # No overlap\n            if start > r or end  l:\n                return 0\n            \n            # Full overlap: the value in this node is what we need\n            if l = start and end = r:\n                return self.tree[node]\n\n            # Partial overlap: push down lazy tags before querying children\n            self._push(node, start, end)\n\n            mid = (start + end) // 2\n            p1 = self._query(2 * node, start, mid, l, r)\n            p2 = self._query(2 * node + 1, mid + 1, end, l, r)\n            \n            return p1 + p2\n\n        def update(self, l, r, a, b):\n            \"\"\"Public method for range update.\"\"\"\n            self._update(1, 0, self.n - 1, l, r, a, b)\n\n        def query(self, l, r):\n            \"\"\"Public method for range query.\"\"\"\n            if l > r: return 0\n            return self._query(1, 0, self.n - 1, l, r)\n\n    test_cases = [\n        ([1, 2, 3, 4, 5], [('update', 1, 3, 2, 1), ('query', 0, 4), ('update', 0, 4, 1, -3), ('query', 2, 2), ('update', 2, 2, 0, 7), ('query', 0, 4)]),\n        ([-5, 0, 5], [('update', 0, 2, -1, 0), ('update', 1, 1, 3, 2), ('query', 0, 2), ('update', 0, 0, 2, 5), ('query', 0, 1), ('update', 2, 2, 1, -4), ('query', 2, 2)]),\n        ([10, -2, 7, 3, 0, 5], [('update', 0, 5, 2, 1), ('update', 2, 4, 3, -2), ('update', 1, 3, -1, 4), ('query', 0, 5), ('query', 2, 3), ('update', 0, 0, 5, 0), ('update', 0, 5, 0, 1), ('query', 0, 5), ('update', 3, 5, 10, -10), ('query', 3, 5)]),\n        ([1, 1, 1, 1], [('update', 0, 3, 1, 0), ('query', 0, 3), ('update', 1, 2, 1, 5), ('query', 0, 3), ('update', 1, 1, 1, -5), ('query', 0, 3)]),\n        ([1000000, -1000000, 123456, -654321, 42], [('update', 0, 4, 2, 3), ('query', 0, 4), ('update', 2, 4, 0, -7), ('query', 0, 4), ('update', 1, 3, -3, 11), ('query', 1, 3)]),\n    ]\n    \n    results = []\n    for initial_array, operations in test_cases:\n        st = SegmentTreeAffine(initial_array)\n        naive = NaiveBaseline(initial_array)\n        \n        st_query_results = []\n        naive_query_results = []\n        \n        for op in operations:\n            op_type = op[0]\n            if op_type == \"update\":\n                _, l, r, a, b = op\n                st.update(l, r, a, b)\n                naive.update(l, r, a, b)\n            elif op_type == \"query\":\n                _, l, r = op\n                st_res = st.query(l, r)\n                naive_res = naive.query(l, r)\n                st_query_results.append(st_res)\n                naive_query_results.append(naive_res)\n        \n        results.append(st_query_results == naive_query_results)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3269114"}]}