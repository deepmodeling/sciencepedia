{"hands_on_practices": [{"introduction": "To truly appreciate the design of B-trees, we must start with their primary use case: minimizing I/O operations on block-based storage devices like disks. This means packing as much useful information into a single node (or disk page) as possible. This first exercise [@problem_id:3212035] dives into the core space trade-offs within a B+ tree node, a popular variant of the B-tree. You will model the relationship between the space consumed by navigational keys and the space used for child pointers, providing a quantitative basis for understanding how the tree's order, $m$, interacts with physical data sizes.", "problem": "Consider a Balanced Plus Tree (B+ tree) of order $m$, where each internal node with $m$ children stores exactly $m-1$ separator keys that duplicate user keys already stored in the leaves. Let the size of each key be $s_k$ bytes and the size of each child pointer be $s_p$ bytes. Assume the following conditions hold:\n- Internal nodes under consideration are full, containing exactly $m$ child pointers and $m-1$ separator keys.\n- Ignore any per-node headers, alignment padding, or auxiliary metadata; count only the bytes for keys and child pointers.\n- Interpret the phrase “redundant key storage” to mean that internal-node keys duplicate information already present in the leaves and would be unnecessary in a hypothetical baseline that used only child pointers for navigation.\n\nDefine the space overhead of redundant key storage in an internal node as the ratio\n$$\\text{overhead} \\equiv \\frac{\\text{bytes used by internal-node keys}}{\\text{bytes used by internal-node child pointers}}.$$\nUsing only the structural definition of a B+ tree internal node and the sizes $s_k$, $s_p$, and the order $m$, derive a closed-form analytic expression for the overhead as a function of $m$, $s_k$, and $s_p$. Express your final answer as a single simplified expression with no units.", "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- **Data Structure**: Balanced Plus Tree (B+ tree).\n- **Order**: $m$.\n- **Internal Node Contents**: For a full node, there are exactly $m$ children and $m-1$ separator keys.\n- **Key Property**: Internal-node keys are duplicates of keys present in the leaves.\n- **Size of Key**: $s_k$ bytes.\n- **Size of Child Pointer**: $s_p$ bytes.\n- **Simplifying Assumptions**:\n    - All internal nodes under consideration are full.\n    - Per-node headers, alignment padding, and auxiliary metadata are to be ignored.\n- **Definition of Overhead**: The ratio of bytes used by internal-node keys to bytes used by internal-node child pointers.\n    $$ \\text{overhead} \\equiv \\frac{\\text{bytes used by internal-node keys}}{\\text{bytes used by internal-node child pointers}} $$\n- **Objective**: Derive a closed-form analytic expression for the overhead as a function of $m$, $s_k$, and $s_p$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria.\n\n- **Scientifically Grounded**: The problem is based on the standard and well-established definition of a B+ tree, a fundamental data structure in computer science. The description of an internal node with $m$ child pointers and $m-1$ keys is correct for a tree of order $m$. The concept of separator keys in internal nodes being duplicates of keys in the leaves is the defining characteristic of a B+ tree that distinguishes it from a B-tree. The problem is scientifically sound.\n- **Well-Posed**: The problem provides all necessary variables ($m$, $s_k$, $s_p$) and a precise, unambiguous definition of the quantity to be calculated (overhead). The simplifications (full nodes, no metadata) are standard in theoretical analysis and ensure a unique solution can be derived.\n- **Objective**: The language is formal and free of subjective or opinion-based statements.\n\nThe problem does not exhibit any flaws such as scientific unsoundness, incompleteness, contradiction, ambiguity, or being ill-posed.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be derived.\n\n### Solution Derivation\nThe objective is to derive an expression for the space overhead, which is defined as:\n$$ \\text{overhead} = \\frac{\\text{bytes used by internal-node keys}}{\\text{bytes used by internal-node child pointers}} $$\n\nWe will calculate the numerator and the denominator separately based on the provided parameters for a single, full internal node.\n\nFirst, let us calculate the total bytes consumed by the keys in a full internal node. According to the problem statement, a full internal node of order $m$ contains exactly $m-1$ separator keys. The size of each key is given as $s_k$ bytes. Therefore, the total space occupied by keys is the product of the number of keys and the size of each key.\n\n$$ \\text{Bytes for keys} = (m-1) \\times s_k $$\n\nNext, we calculate the total bytes consumed by the child pointers in the same full internal node. A full internal node of order $m$ points to exactly $m$ children. The size of each child pointer is given as $s_p$ bytes. Consequently, the total space occupied by the child pointers is the product of the number of pointers and the size of each pointer.\n\n$$ \\text{Bytes for child pointers} = m \\times s_p $$\n\nNow, we substitute these two expressions into the definition of overhead provided in the problem statement.\n\n$$ \\text{overhead} = \\frac{(m-1)s_k}{m s_p} $$\n\nThis expression is a closed-form solution in terms of the given parameters $m$, $s_k$, and $s_p$. The expression can be written in an alternative form to highlight the dependence on the $m-1$ to $m$ ratio:\n$$ \\text{overhead} = \\left(\\frac{m-1}{m}\\right) \\frac{s_k}{s_p} = \\left(1 - \\frac{1}{m}\\right) \\frac{s_k}{s_p} $$\nHowever, the form $\\frac{(m-1)s_k}{m s_p}$ is already fully simplified and directly represents the relationship derived from the problem's definitions. This is the final expression for the requested overhead.", "answer": "$$\\boxed{\\frac{(m-1)s_k}{m s_p}}$$", "id": "3212035"}, {"introduction": "While theoretical worst-case guarantees are a hallmark of B-trees, their practical efficiency often hinges on the tree's average node occupancy. A sparse tree wastes space and can grow taller than necessary, increasing I/O costs. This hands-on coding practice [@problem_id:3212087] allows you to see this effect firsthand by building B-trees from the same set of keys but with different insertion orders. By implementing a standard insertion algorithm and comparing metrics like height and node occupancy, you will develop a concrete intuition for why random-seeming insertions typically yield better-balanced and more compact trees than inserting keys in sorted order.", "problem": "You are given the task of implementing a builder and analyzer for a B-tree of minimum degree $t$ over a set of distinct integer keys. The B-tree must be constructed using the standard top-down insertion algorithm that splits full nodes before descent, maintains all invariants of B-trees, and ignores duplicate keys if any are presented (no duplicates occur in the provided test suite). After building a B-tree from a specified insertion order, you must compute quantitative metrics of its structure that reflect how insertion order can affect the occupancy of nodes and the height $h$.\n\nFundamental base and invariants to use:\n- A B-tree of minimum degree $t$ is a rooted, balanced, multiway search tree in which every node (except possibly the root) contains between $t-1$ and $2t-1$ keys, and has between $t$ and $2t$ children if it is internal. The root contains between $1$ and $2t-1$ keys unless the tree is empty.\n- All leaves are at the same depth. The height $h$ is defined as the number of edges on any root-to-leaf path. Thus, a single-node tree (root is a leaf) has $h=0$.\n- The maximum number of keys in any node is $2t-1$. The node occupancy fraction for a node is the ratio of the number of keys in the node to $2t-1$.\n- The standard top-down insertion procedure for B-trees splits any full node encountered on the descent before continuing, ensuring that when insertion reaches a leaf, that leaf is not full.\n\nFor each B-tree built from a given insertion order, compute the following metrics:\n- The height $h$.\n- The total number of nodes.\n- The minimum node occupancy fraction across all nodes.\n- The maximum node occupancy fraction across all nodes.\n- The average node occupancy fraction across all nodes.\n\nYou will compare two B-trees built from the same key set under two different insertion orders and quantify differences in the above metrics.\n\nImplementation constraints:\n- Use only the structural invariants above and the standard top-down B-tree insertion method; do not use any precomputed formulas for final structure.\n- All keys are distinct integers; duplicates are to be ignored if they arise (they do not in the provided data).\n- There are no physical units involved in this problem.\n- All floating-point results must be rounded to exactly $6$ decimal places in the final output.\n\nTest suite:\nFor each test case, you are given $t$ and two insertion orders $A$ and $B$ for the same key set. Build two B-trees, one from $A$ and one from $B$, and compute the metrics for each.\n\n- Test case $1$:\n  - $t = 5$\n  - $A = [11,7,19,3,5,13,17]$\n  - $B = [3,5,7,11,13,17,19]$\n- Test case $2$:\n  - $t = 2$\n  - $A = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]$\n  - $B = [15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]$\n- Test case $3$:\n  - $t = 3$\n  - $A = [8,16,24,32,40,48,56,64,72,80,88,96,7,15,23,31,39,47,55,63]$\n  - $B = [63,55,47,39,31,23,15,7,96,88,80,72,64,56,48,40,32,24,16,8]$\n\nRequired output per test case:\nFor each test case, produce the following $10$ values in order, where the subscript denotes the tree built from order $A$ or $B$:\n- $h_A$, $h_B$,\n- $\\text{avgOcc}_A$, $\\text{avgOcc}_B$,\n- $\\text{minOcc}_A$, $\\text{minOcc}_B$,\n- $\\text{maxOcc}_A$, $\\text{maxOcc}_B$,\n- $\\text{nodes}_A$, $\\text{nodes}_B$.\n\nHere, $\\text{avgOcc}$, $\\text{minOcc}$, and $\\text{maxOcc}$ are the average, minimum, and maximum node occupancy fractions, respectively, computed across all nodes in the tree, using the denominator $2t-1$ for all nodes. Heights $h_A$ and $h_B$ are integers; node counts are integers; all occupancies must be printed as floating-point numbers rounded to exactly $6$ decimal places.\n\nFinal output format:\nYour program should produce a single line of output containing all of the values for the three test cases concatenated into a single comma-separated list enclosed in square brackets. The order is test case $1$'s $10$ values, followed by test case $2$'s $10$ values, followed by test case $3$'s $10$ values. For example, your output must look like\n\"[v1,v2,v3,...,v30]\"\nwith no spaces. All floating-point values must be rounded to exactly $6$ decimal places. All integers must appear without decimal points.", "solution": "The user-provided problem is valid. It is a well-defined task in the field of data structures and algorithms, grounded in established principles of B-tree construction and analysis. All necessary parameters, definitions, and constraints are provided, making the problem self-contained, consistent, and solvable. The task is to implement a B-tree data structure, populate it according to specified insertion orders, and analyze its structural properties.\n\nThe solution proceeds by first designing and implementing the B-tree data structure, then creating a function to analyze its properties, and finally applying these tools to the test cases provided.\n\n### Principle-Based Design\n\nThe solution is based on the following principles and algorithmic components:\n\n**1. B-Tree Node and Tree Structure**\n\nA B-tree is a balanced multi-way search tree. Its structure is defined by a minimum degree, denoted by $t \\ge 2$.\n\n- **Node Structure (`BTreeNode`)**: Each node in the tree stores:\n    - `keys`: A sorted list of keys. The number of keys, $n$, in any node must satisfy $t-1 \\le n \\le 2t-1$, except for the root, which can have $1 \\le n \\le 2t-1$.\n    - `children`: A list of pointers to child nodes. An internal node with $n$ keys has $n+1$ children.\n    - `leaf`: A boolean flag indicating whether the node is a leaf (has no children) or an internal node.\n    - `t`: The minimum degree of the tree.\n\n- **Tree Structure (`BTree`)**: The overall tree is managed by a class that holds a reference to the `root` node and the parameter `t`.\n\n**2. Insertion Algorithm: Top-Down with Proactive Splitting**\n\nThe problem specifies the standard top-down insertion algorithm where any full node encountered during the descent is split *before* recursing into it. This ensures that when the insertion point is reached at a leaf, the leaf is guaranteed to be non-full, simplifying the process.\n\n- **`insert(k)`**: This is the main entry point for insertion.\n    1.  If the tree is empty, a new root node is created and the key $k$ is inserted.\n    2.  If the root node is full (i.e., contains $2t-1$ keys), it must be split. A new empty root is created, the old root becomes its child, and the `split_child` operation is performed on this new root to split its only child (the old root). The median key of the old root moves up to the new root, which now has two children. The insertion then proceeds by calling a helper function, `insert_nonfull`, starting from this new, non-full root.\n    3.  If the root is not full, `insert_nonfull` is called directly on the root.\n\n- **`split_child(x, i)`**: This function splits the $i$-th child of a non-full node $x$. Let the child to be split be $y = x.\\text{children}[i]$. Since $y$ is full, it has $2t-1$ keys.\n    1.  A new node, $z$, is created.\n    2.  The median key of $y$ (the key at index $t-1$) is moved up into the parent node $x$.\n    3.  The $t-1$ keys from $y$ that are greater than the median are moved into $z$.\n    4.  If $y$ is an internal node, its corresponding $t$ children are moved to $z$.\n    5.  The new node $z$ is inserted into the children list of $x$ immediately after $y$.\n\n- **`insert_nonfull(x, k)`**: This recursive function inserts a key $k$ into a non-full node $x$.\n    1.  **If $x$ is a leaf**: Find the correct position for $k$ in the sorted `keys` list and insert it.\n    2.  **If $x$ is an internal node**:\n        a. Find the child subtree, $x.\\text{children}[i]$, to which the key $k$ belongs.\n        b. If that child, $x.\\text{children}[i]$, is full, first call `split_child(x, i)` to split it. This promotes a median key to $x$ and creates a new sibling. After the split, we must re-evaluate whether $k$ belongs in the original child or the new sibling, adjusting the index $i$ if necessary.\n        c. Recursively call `insert_nonfull` on the appropriate (and now guaranteed non-full) child.\n\nA check to ignore duplicate keys is incorporated: before inserting into a leaf or descending to a child, we check if the key already exists at the current node.\n\n**3. Analysis Algorithm: Tree Traversal for Metrics Calculation**\n\nOnce a B-tree is constructed, its structural metrics are computed by traversing all its nodes. A recursive depth-first traversal is employed for this analysis.\n\n- **`analyze_tree(tree)`**: This function orchestrates the analysis.\n    1.  It handles the edge case of an empty tree.\n    2.  It initiates a recursive traversal starting from the root at depth $0$.\n    3.  The traversal function, `_analyze_recursive(node, depth)`, visits every node and collects primary data: the total number of nodes, the depth of the leaves (which gives the height $h$), and the occupancy of each node.\n    4.  Node occupancy is calculated as defined: (number of keys in the node) / ($2t-1$).\n    5.  After the traversal gathers a list of all node occupancies, the minimum, maximum, and average values are computed.\n    6.  The final metrics ($h$, total nodes, and occupancy statistics) are returned.\n\nThe height $h$ is defined as the number of edges on a root-to-leaf path. A tree with a single node (root is a leaf) is at depth $0$, so its height is $h=0$. This is naturally handled by the recursive depth-tracking approach.\n\nBy applying this implementation to the given test cases, we can programmatically construct the B-trees for insertion orders $A$ and $B$, compute the required metrics for each, and present the results in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a B-tree builder and analyzer, and runs the provided test suite.\n    \"\"\"\n\n    class BTreeNode:\n        \"\"\"A B-tree node.\"\"\"\n        def __init__(self, t, leaf=False):\n            self.t = t\n            self.leaf = leaf\n            self.keys = []\n            self.children = []\n            # n is implicitly len(self.keys)\n\n        @property\n        def n(self):\n            return len(self.keys)\n\n    class BTree:\n        \"\"\"A B-tree.\"\"\"\n        def __init__(self, t):\n            if t < 2:\n                raise ValueError(\"B-tree minimum degree t must be at least 2.\")\n            self.t = t\n            self.root = None\n\n        def insert(self, k):\n            \"\"\"Inserts a key into the B-tree.\"\"\"\n            if self.root is None:\n                self.root = BTreeNode(self.t, leaf=True)\n                self.root.keys.append(k)\n                return\n\n            # If root is full, split it before inserting.\n            if self.root.n == 2 * self.t - 1:\n                old_root = self.root\n                new_root = BTreeNode(self.t, leaf=False)\n                self.root = new_root\n                new_root.children.append(old_root)\n                self._split_child(new_root, 0)\n                self._insert_non_full(new_root, k)\n            else:\n                self._insert_non_full(self.root, k)\n\n        def _insert_non_full(self, x, k):\n            \"\"\"Inserts a key into a non-full node.\"\"\"\n            i = len(x.keys) - 1\n            if x.leaf:\n                # Find position and insert key.\n                # First, check for duplicates.\n                pos_check = np.searchsorted(x.keys, k)\n                if pos_check < x.n and x.keys[pos_check] == k:\n                    return # Ignore duplicate\n\n                x.keys.append(0)  # Make space\n                while i >= 0 and k < x.keys[i]:\n                    x.keys[i + 1] = x.keys[i]\n                    i -= 1\n                x.keys[i + 1] = k\n            else:\n                # Find the child to descend into.\n                # First, check for duplicates.\n                pos_check = np.searchsorted(x.keys, k)\n                if pos_check < x.n and x.keys[pos_check] == k:\n                    return # Ignore duplicate\n\n                while i >= 0 and k < x.keys[i]:\n                    i -= 1\n                i += 1\n\n                # If child is full, split it.\n                if len(x.children[i].keys) == 2 * self.t - 1:\n                    self._split_child(x, i)\n                    # Key might now belong to the new sibling.\n                    if k > x.keys[i]:\n                        i += 1\n                self._insert_non_full(x.children[i], k)\n\n        def _split_child(self, x, i):\n            \"\"\"Splits the i-th child of node x.\"\"\"\n            t = self.t\n            y = x.children[i]\n            z = BTreeNode(t, y.leaf)\n\n            # Move median key of y to x.\n            x.keys.insert(i, y.keys[t - 1])\n            x.children.insert(i + 1, z)\n\n            # Move upper half of y's keys to z.\n            z.keys = y.keys[t:]\n            y.keys = y.keys[:t - 1]\n            \n            # If y is not a leaf, move its upper half children to z.\n            if not y.leaf:\n                z.children = y.children[t:]\n                y.children = y.children[:t]\n\n    def analyze_tree(tree):\n        \"\"\"Computes metrics for a given B-tree.\"\"\"\n        if tree.root is None:\n            return {\n                'h': -1, 'nodes': 0, 'minOcc': 0.0,\n                'maxOcc': 0.0, 'avgOcc': 0.0\n            }\n        \n        occupancies = []\n        node_count = 0\n        max_depth = 0\n        max_keys = 2 * tree.t - 1\n\n        q = [(tree.root, 0)] # (node, depth)\n        visited = {tree.root}\n\n        while q:\n            curr_node, depth = q.pop(0)\n            node_count += 1\n            max_depth = max(max_depth, depth)\n            \n            occupancy = curr_node.n / max_keys if max_keys > 0 else 0\n            occupancies.append(occupancy)\n            \n            if not curr_node.leaf:\n                for child in curr_node.children:\n                    if child not in visited:\n                        q.append((child, depth + 1))\n                        visited.add(child)\n\n        return {\n            'h': max_depth,\n            'nodes': node_count,\n            'minOcc': min(occupancies) if occupancies else 0.0,\n            'maxOcc': max(occupancies) if occupancies else 0.0,\n            'avgOcc': np.mean(occupancies) if occupancies else 0.0\n        }\n\n    test_cases = [\n        {\n            \"t\": 5,\n            \"A\": [11, 7, 19, 3, 5, 13, 17],\n            \"B\": [3, 5, 7, 11, 13, 17, 19]\n        },\n        {\n            \"t\": 2,\n            \"A\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n            \"B\": [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n        },\n        {\n            \"t\": 3,\n            \"A\": [8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 7, 15, 23, 31, 39, 47, 55, 63],\n            \"B\": [63, 55, 47, 39, 31, 23, 15, 7, 96, 88, 80, 72, 64, 56, 48, 40, 32, 24, 16, 8]\n        }\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        t = case[\"t\"]\n        keys_A = case[\"A\"]\n        keys_B = case[\"B\"]\n        \n        tree_A = BTree(t)\n        for key in keys_A:\n            tree_A.insert(key)\n        metrics_A = analyze_tree(tree_A)\n        \n        tree_B = BTree(t)\n        for key in keys_B:\n            tree_B.insert(key)\n        metrics_B = analyze_tree(tree_B)\n        \n        case_results = [\n            metrics_A['h'], metrics_B['h'],\n            metrics_A['avgOcc'], metrics_B['avgOcc'],\n            metrics_A['minOcc'], metrics_B['minOcc'],\n            metrics_A['maxOcc'], metrics_B['maxOcc'],\n            metrics_A['nodes'], metrics_B['nodes']\n        ]\n        all_results.extend(case_results)\n\n    formatted_results = []\n    for val in all_results:\n        if isinstance(val, float):\n            formatted_results.append(f\"{val:.6f}\")\n        else:\n            formatted_results.append(str(val))\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "3212087"}, {"introduction": "A deep understanding of a data structure is best demonstrated by reasoning about its behavior when its core assumptions are violated. This advanced problem [@problem_id:3212077] challenges you to design a search algorithm for a B-tree that has been \"corrupted\"—its separator keys no longer reliably guide the search to the correct child. To succeed, you must move beyond the textbook search algorithm and reason from first principles, identifying which properties of the tree remain invariant and can be trusted. This exercise in fault-tolerant thinking solidifies your grasp of what makes a B-tree fundamentally searchable.", "problem": "You are given the mathematical definition of a B-tree (a balanced multiway search tree) that satisfies the following core properties for a minimum degree parameter $t$: \n- Every node except the root contains between $t-1$ and $2t-1$ sorted keys.\n- Every internal node with $m$ keys contains exactly $m+1$ children.\n- Keys in each node are sorted in nondecreasing order.\n- In a correct tree, for an internal node with keys $k_0,k_1,\\dots,k_{m-1}$ and children $c_0,c_1,\\dots,c_m$, all keys in subtree $c_i$ lie in the interval delimited by $k_{i-1}$ and $k_{i}$ in the sorted order, with suitable infinities for the ends.\n\nConsider a corrupted B-tree in which some parent separation keys no longer correctly partition the value sets of their child subtrees. That is, there exist internal nodes whose child subtrees contain values that lie outside the nominal intervals implied by the parent’s keys. The only guarantees you may assume are:\n- The keys stored inside each node (both internal and leaf) are sorted in nondecreasing order.\n- All keys stored in the leaves are the ground truth data elements of the set represented by the tree.\n- Structural arity constraints (the counts of keys and children per node) are still within valid bounds for some minimum degree $t$, but you are not provided $t$ and you may not rely on it.\n- Parent separation keys may be incorrect and therefore must not be trusted to uniquely determine a single child for search.\n\nTask: Design and implement a robust search algorithm that, given a key $x$, returns whether $x$ is present in the corrupted B-tree. Your algorithm must be correct under arbitrary corruption of separation boundaries, as long as node-local key order is preserved and the leaf keys are accurate. You should reason from first principles and observable facts about the tree. The algorithm must:\n- Check for $x$ in the current node’s stored keys.\n- Use only verifiable information about subtrees, derivable from the current tree instance, to choose which child subtrees to traverse.\n- Avoid excluding any child subtree that could plausibly contain $x$.\n- Terminate with a boolean answer indicating whether $x$ is present.\n\nFundamental base to use in your derivation and design:\n- Definition of a B-tree’s node invariants (sorted node-local keys, arity bounds).\n- The search principle that any value present in the tree must appear in some leaf, and any leaf value is bounded by the minimum and maximum values within its path’s subtrees.\n\nYou must produce a complete, runnable program that constructs three small B-trees (represented in memory) and executes the robust search on specified queries. The trees and queries form the test suite and are as follows.\n\nDefine the following trees:\n\n- Tree $\\mathrm{T}_1$ (correctly separated): root has keys $\\{10,20\\}$ and children:\n    - Child $c_0$ is a leaf with keys $\\{2,5,9\\}$.\n    - Child $c_1$ is a leaf with keys $\\{12,15,19\\}$.\n    - Child $c_2$ is a leaf with keys $\\{21,25,28\\}$.\n\n- Tree $\\mathrm{T}_2$ (corrupted separation at root): identical to $\\mathrm{T}_1$ except the root keys are changed to $\\{14,20\\}$ while the children remain:\n    - Child $c_0$ leaf keys $\\{2,5,9\\}$.\n    - Child $c_1$ leaf keys $\\{12,15,19\\}$.\n    - Child $c_2$ leaf keys $\\{21,25,28\\}$.\n\n- Tree $\\mathrm{T}_3$ (overlapping ranges due to corruption): root has keys $\\{15,30\\}$ and children:\n    - Child $c_0$ is a leaf with keys $\\{5,10,25\\}$.\n    - Child $c_1$ is a leaf with keys $\\{16,18\\}$.\n    - Child $c_2$ is a leaf with keys $\\{31,34\\}$.\n\nExecute the robust search for the following queries:\n- On $\\mathrm{T}_1$, search for $x=25$.\n- On $\\mathrm{T}_2$, search for $x=12$.\n- On $\\mathrm{T}_2$, search for $x=13$.\n- On $\\mathrm{T}_2$, search for $x=2$.\n- On $\\mathrm{T}_3$, search for $x=25$.\n- On $\\mathrm{T}_3$, search for $x=18$.\n- On $\\mathrm{T}_3$, search for $x=29$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases (for example, $\\mathrm{[}\\mathrm{result}_1,\\mathrm{result}_2,\\dots\\mathrm{]}$). Each result must be a boolean indicating whether the queried value is present in the corresponding tree. No physical units, angle units, or percentages are involved; all outputs are pure booleans.", "solution": "The problem requires the design and implementation of a robust search algorithm for a B-tree structure where the defining property of key-based separation between child subtrees is corrupted. The algorithm must correctly determine the presence of a queried key $x$ using only the information that is guaranteed to be valid.\n\n### Problem Validation\n\nFirst, we perform a validation of the problem statement.\n\n**Step 1: Extracted Givens**\n- **Standard B-tree definition:** A balanced multiway search tree with minimum degree $t$, where nodes have between $t-1$ and $2t-1$ keys, an internal node with $m$ keys has $m+1$ children, and keys are sorted. Correct separation implies keys in child subtree $c_i$ are bounded by parent keys $k_{i-1}$ and $k_i$.\n- **Corrupted B-tree guarantees:**\n    1. Parent separator keys are unreliable and must not be used to select a child subtree for searching.\n    2. Keys within any single node are sorted in nondecreasing order.\n    3. The set of all keys stored in all leaf nodes constitutes the complete and correct set of data elements.\n    4. Structural arity constraints (number of keys and children per node) are valid for some unknown minimum degree $t$.\n- **Task:** Design a robust search algorithm for a key $x$ that returns a boolean indicating its presence. The algorithm must:\n    - Check for $x$ in the current node.\n    - Use only verifiable information to decide which children to traverse.\n    - Avoid excluding any child subtree that could plausibly contain $x$.\n- **Test cases:** Three specific tree structures ($T_1$, $T_2$, $T_3$) and seven specific search queries are provided for implementation and verification.\n\n**Step 2: Validation Using Extracted Givens**\nThe problem is scientifically and algorithmically sound. It presents a variation of a standard data structure problem, focusing on robustness in the face of data corruption. This is a valid topic in computer science, particularly in the study of fault-tolerant systems and data recovery.\n- **Scientifically Grounded:** The problem is based on the formal definition of a B-tree, a fundamental concept in data structures. The \"corruption\" is a well-defined modification of the standard invariants, leading to a new but formalizable problem.\n- **Well-Posed:** The problem provides a clear objective (find key $x$) and a complete set of constraints (what is reliable vs. unreliable). A solution exists (e.g., a brute-force search of all leaves is a valid, though inefficient, solution), and the challenge is to design a more principled and efficient algorithm. The provided test cases make the success criteria unambiguous.\n- **Objective:** The language is precise and free of subjectivity.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. We may proceed with deriving a solution.\n\n### Derivation of the Robust Search Algorithm\n\nThe fundamental challenge is that a standard B-tree search relies on the property: if $k_{i-1} < x < k_i$ in a parent node, then $x$ can only be in the child subtree $c_i$. Since this property is violated, comparing the search key $x$ with the parent's keys provides no reliable guidance for pruning the search to a single child.\n\n**1. Identifying Verifiable Information**\n\nWe must base our search strategy exclusively on the stated guarantees. The most critical guarantees are:\n- Keys within any given node are sorted.\n- The complete set of values is located in the leaves.\n\nFrom these principles, we can deduce a necessary condition for a key $x$ to exist within any subtree rooted at a node $N$. If $x$ is in the subtree, it must be greater than or equal to the true minimum value in that subtree and less than or equal to the true maximum value. Let us denote the true minimum and maximum values in the subtree rooted at $N$ as $\\min_{true}(N)$ and $\\max_{true}(N)$, respectively.\n\nThe search key $x$ can exist in the subtree of $N$ only if $x \\in [\\min_{true}(N), \\max_{true}(N)]$.\n\n**2. Computing the True Value Range of a Subtree**\n\nSince all data elements reside in the leaves, the true value range of any subtree is determined by the keys in its descendant leaves. We can compute this range for every node in the tree. This computation can be performed once as a pre-processing step and the results cached at each node. A post-order traversal is the natural way to achieve this.\n\nThe algorithm to compute and cache these true bounds for a node $N$ is as follows:\n- **Base Case:** If $N$ is a leaf node, its keys are guaranteed to be sorted. Thus, $\\min_{true}(N)$ is the first key in the node, and $\\max_{true}(N)$ is the last key. If the leaf is empty, its range is vacuous; we can use $[\\infty, -\\infty]$.\n- **Recursive Step:** If $N$ is an internal node with children $\\{C_0, C_1, \\dots, C_m\\}$, we first recursively compute the true ranges for all its children. The problem statement does not guarantee any ordering of key ranges among the children subtrees (e.g., it is not guaranteed that $\\max_{true}(C_i) < \\min_{true}(C_{i+1})$). Therefore, to be robust, we must find the minimum and maximum across all its children.\n$$ \\min_{true}(N) = \\min_{i=0}^{m} \\{\\min_{true}(C_i)\\} $$\n$$ \\max_{true}(N) = \\max_{i=0}^{m} \\{\\max_{true}(C_i)\\} $$\nThis pre-computation augments each node with a verifiable `min_val` and `max_val` attribute that represents the true bounds of all keys contained within its entire subtree.\n\n**3. The Robust Search Algorithm**\n\nWith the true value ranges pre-computed, the robust search for a key $x$ starting at a node $N$ proceeds as follows:\n\n1.  **Check Current Node:** Perform a search for $x$ within the sorted keys of the current node $N$. Given the sorted nature of keys, a binary search is efficient. If $x$ is found, the algorithm terminates, returning `true`.\n2.  **Leaf Node Termination:** If $N$ is a leaf node and $x$ was not found in its keys (step 1), then $x$ cannot be in this subtree. The algorithm returns `false` for this path.\n3.  **Internal Node Recurson:** If $N$ is an internal node, the algorithm must explore all children whose true value ranges could possibly contain $x$. It iterates through each child $C_i$ of $N$.\n4.  **Plausibility Check:** For each child $C_i$, it checks if $x$ falls within its pre-computed true range: $\\min_{true}(C_i) \\le x \\le \\max_{true}(C_i)$.\n5.  **Recursive Search:** If the condition in the previous step is met, the child subtree $C_i$ is a plausible location for $x$. The algorithm recursively calls itself on $C_i$. If this recursive call returns `true`, it means $x$ has been found, and the main search can terminate by returning `true`.\n6.  **Exhaustion:** If the algorithm iterates through all plausible children and none of the recursive calls finds $x$, it can be concluded that $x$ is not in any subtree of $N$. The function returns `false`.\n\nThis algorithm is correct because it never relies on the corrupted parent separator keys for navigation. Instead, it builds its search path dynamically based on the verifiable ground truth of what value ranges are contained in which subtrees, ensuring no plausible path is ever prematurely pruned.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in the B-tree.\n    Each node stores its keys, children, and pre-computed true min/max values\n    of the subtree rooted at this node.\n    \"\"\"\n    def __init__(self, keys, children=None):\n        \"\"\"\n        Initializes a Node.\n        \n        Args:\n            keys (list[int]): A list of keys stored in the node.\n            children (list[Node], optional): A list of child nodes. Defaults to None.\n        \"\"\"\n        # Ensure keys are stored in a sorted NumPy array for efficient search.\n        self.keys = np.array(keys, dtype=np.int64)\n        self.children = children if children else []\n        self.is_leaf = not bool(self.children)\n        \n        # These will be populated by compute_bounds.\n        self.min_val = None\n        self.max_val = None\n\ndef compute_bounds(node):\n    \"\"\"\n    Performs a post-order traversal to compute and cache the true minimum and\n    maximum key values for the subtree rooted at each node.\n    \n    Args:\n        node (Node): The root of the subtree to process.\n    \"\"\"\n    if node.is_leaf:\n        if node.keys.size > 0:\n            node.min_val = node.keys[0]\n            node.max_val = node.keys[-1]\n        else:\n            # An empty leaf has an invalid range.\n            node.min_val = float('inf')\n            node.max_val = float('-inf')\n        return\n\n    # Post-order: process children first.\n    child_min_vals = []\n    child_max_vals = []\n    for child in node.children:\n        compute_bounds(child)\n        child_min_vals.append(child.min_val)\n        child_max_vals.append(child.max_val)\n    \n    # The true range of an internal node is the union of the ranges of all its children.\n    # This robustly handles any child ordering.\n    if child_min_vals:\n        node.min_val = min(child_min_vals)\n    if child_max_vals:\n        node.max_val = max(child_max_vals)\n\ndef robust_search(node, x):\n    \"\"\"\n    Searches for a key 'x' in a potentially corrupted B-tree.\n    \n    Args:\n        node (Node): The current node to search in.\n        x (int): The key to search for.\n    \n    Returns:\n        bool: True if the key is found, False otherwise.\n    \"\"\"\n    # 1. Check if x is in the current node's keys.\n    # np.searchsorted gives the index where x would be inserted to maintain order.\n    # If the element at that index is x, we have found the key.\n    idx = np.searchsorted(node.keys, x)\n    if idx < len(node.keys) and node.keys[idx] == x:\n        return True\n\n    # 2. If this is a leaf node and x was not found, the search path ends here.\n    if node.is_leaf:\n        return False\n\n    # 3. For an internal node, recurse on all plausible children.\n    # A child is plausible if x is within its pre-computed true value range.\n    for child in node.children:\n        # The node must have a valid range to be considered.\n        if child.min_val is not None and child.max_val is not None:\n            if child.min_val <= x <= child.max_val:\n                # If found in any plausible subtree, the overall result is True.\n                if robust_search(child, x):\n                    return True\n    \n    # 4. If x was not found in the node or any plausible child subtree.\n    return False\n\ndef solve():\n    \"\"\"\n    Main function to define trees, run queries, and print results.\n    \"\"\"\n    # --- Define Tree T1 (correctly separated) ---\n    t1_c0 = Node(keys=[2, 5, 9])\n    t1_c1 = Node(keys=[12, 15, 19])\n    t1_c2 = Node(keys=[21, 25, 28])\n    t1_root = Node(keys=[10, 20], children=[t1_c0, t1_c1, t1_c2])\n    compute_bounds(t1_root)\n\n    # --- Define Tree T2 (corrupted separation) ---\n    # Children are identical to T1, but root keys are different.\n    t2_c0 = Node(keys=[2, 5, 9])\n    t2_c1 = Node(keys=[12, 15, 19])\n    t2_c2 = Node(keys=[21, 25, 28])\n    t2_root = Node(keys=[14, 20], children=[t2_c0, t2_c1, t2_c2])\n    compute_bounds(t2_root)\n\n    # --- Define Tree T3 (overlapping ranges) ---\n    t3_c0 = Node(keys=[5, 10, 25])\n    t3_c1 = Node(keys=[16, 18])\n    t3_c2 = Node(keys=[31, 34])\n    t3_root = Node(keys=[15, 30], children=[t3_c0, t3_c1, t3_c2])\n    compute_bounds(t3_root)\n\n    # Define the test cases from the problem statement.\n    queries = [\n        (t1_root, 25),\n        (t2_root, 12),\n        (t2_root, 13),\n        (t2_root, 2),\n        (t3_root, 25),\n        (t3_root, 18),\n        (t3_root, 29),\n    ]\n\n    results = []\n    for tree_root, key_to_find in queries:\n        result = robust_search(tree_root, key_to_find)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Python's str() of a boolean is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3212077"}]}