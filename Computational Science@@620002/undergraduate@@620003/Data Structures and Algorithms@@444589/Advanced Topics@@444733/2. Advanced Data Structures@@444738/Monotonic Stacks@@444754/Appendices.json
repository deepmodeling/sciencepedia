{"hands_on_practices": [{"introduction": "This first practice is the cornerstone for understanding the monotonic stack. It directly addresses the canonical problem of finding the Next Greater Element (NGE) and Previous Greater Element (PGE) for every item in a sequence. Mastering this exercise involves implementing two independent passes over the data, each utilizing a monotonic stack, which is a fundamental technique applicable to a wide array of more complex problems. [@problem_id:3254179]", "problem": "You must write a complete program that, for each element of an integer array, computes the product of its Next Greater Element and its Previous Greater Element, using only the definitions given below and fundamental properties of arrays, integer order, and stacks. No input is read; instead, the program must internally evaluate a fixed test suite of arrays specified in this statement and produce a single aggregated output as described.\n\nDefinitions to be used as the fundamental base:\n- Let $A$ be an array of integers of length $n$. Indices are $0$-based, that is, the valid indices are $0, 1, \\dots, n-1$.\n- For each index $i$ with $0 \\le i \\le n-1$, define the Next Greater Element $\\mathrm{NGE}(i)$ as follows. If there exists an index $j$ with $j  i$ and $A[j]  A[i]$, let $\\mathrm{NGE}(i) = A[j^{\\ast}]$ where $j^{\\ast}$ is the smallest index greater than $i$ such that $A[j^{\\ast}]  A[i]$. If no such $j$ exists, define $\\mathrm{NGE}(i) = -1$.\n- For each index $i$ with $0 \\le i \\le n-1$, define the Previous Greater Element $\\mathrm{PGE}(i)$ as follows. If there exists an index $k$ with $k  i$ and $A[k]  A[i]$, let $\\mathrm{PGE}(i) = A[k^{\\ast}]$ where $k^{\\ast}$ is the largest index less than $i$ such that $A[k^{\\ast}]  A[i]$. If no such $k$ exists, define $\\mathrm{PGE}(i) = -1$.\n- For each index $i$ with $0 \\le i \\le n-1$, define the product $P[i] = \\mathrm{NGE}(i) \\times \\mathrm{PGE}(i)$.\n\nYour task is to compute, for each provided test array $A$, the list $P$ of length $n$ containing these products, in the order of indices from $0$ to $n-1$.\n\nScientific realism and constraints:\n- Arrays may contain any integers (including negative values), duplicates, and may be of length $0$ or greater.\n- The strict inequality $$ governs the definitions of \"greater,\" so equal values do not count as greater.\n- If an array has length $0$, it yields an empty list as output for that case.\n\nTest suite to be evaluated by your program:\n- Case $1$: $A = [\\,5, 1, 3, 2, 4\\,]$.\n- Case $2$: $A = [\\,1, 2, 3, 4\\,]$.\n- Case $3$: $A = [\\,4, 3, 2, 1\\,]$.\n- Case $4$: $A = [\\,2, 2, 2\\,]$.\n- Case $5$: $A = [\\,7\\,]$.\n- Case $6$: $A = [\\,\\,]$ (the empty array).\n\nRequired final output format:\n- Your program should produce a single line of output containing the results for all cases as a single list, where each element is itself the list $P$ for that case, in the same order as the cases above.\n- The line must be a comma-separated list enclosed in square brackets, with no spaces anywhere, including within inner lists. For example, if there were two cases with results $[\\,x_1, x_2\\,]$ and $[\\,y_1\\,]$, the output format would be exactly \"[[x_1,x_2],[y_1]]\" with each $x_1, x_2, y_1$ replaced by their integer values and no spaces at all.\n\nThe answer for each case is a list of integers. The program must be correct for the provided test suite and should be designed using principles appropriate to advanced undergraduate study of data structures and algorithms, such as exploiting order properties and stack behavior, rather than ad hoc enumeration.", "solution": "The problem statement has been validated and is deemed valid. It is self-contained, mathematically well-posed, and free of contradictions or ambiguities. The definitions for Next Greater Element ($\\mathrm{NGE}$) and Previous Greater Element ($\\mathrm{PGE}$) are precise, ensuring a unique solution exists for any given integer array. The problem is a standard exercise in algorithm design, suitable for analysis with data structures.\n\nA complete, reasoned solution is provided below.\n\nThe problem requires us to compute, for each element $A[i]$ in a given array $A$ of length $n$, the product $P[i] = \\mathrm{NGE}(i) \\times \\mathrm{PGE}(i)$. The Next Greater Element, $\\mathrm{NGE}(i)$, is the first element to the right of $A[i]$ that is strictly greater than $A[i]$. The Previous Greater Element, $\\mathrm{PGE}(i)$, is the first element to the left of $A[i]$ that is strictly greater than $A[i]$. If no such element exists, the respective value is defined as $-1$.\n\nA straightforward, yet inefficient, approach would be to iterate through the array for each element. To find $\\mathrm{NGE}(i)$, one would scan all elements $A[j]$ with $j  i$. To find $\\mathrm{PGE}(i)$, one would scan all elements $A[k]$ with $k  i$. This method involves nested loops, resulting in a time complexity of $O(n^2)$ for an array of length $n$. For large arrays, this approach is computationally expensive. The problem hints at a more sophisticated method, and a linear-time $O(n)$ solution can be achieved using a monotonic stack.\n\nThe principle behind the monotonic stack is to maintain a data structure (a stack) where the elements are always in a specific sorted order (either increasing or decreasing). This structure allows for the efficient determination of the next or previous greater/smaller elements for all elements in a single pass.\n\nThe overall algorithm consists of three main steps:\n1. Compute the $\\mathrm{NGE}$ for every element in the array $A$.\n2. Compute the $\\mathrm{PGE}$ for every element in the array $A$.\n3. Compute the final product array $P$ from the results of the previous two steps.\n\n**1. Computing the Next Greater Element ($\\mathrm{NGE}$)**\n\nTo compute the $\\mathrm{NGE}$ for all elements, we can iterate through the array $A$ from right to left (from index $i = n-1$ down to $0$) and use a stack to store values of elements encountered so far. The stack will maintain a strictly decreasing order of elements from bottom to top.\n\nThe algorithm is as follows:\n- Initialize an empty stack, $s$, and a result array, $nge\\_arr$, of size $n$, with all values initialized to $-1$.\n- For each index $i$ from $n-1$ down to $0$:\n    a. While the stack $s$ is not empty and the element at the top of the stack is less than or equal to $A[i]$ (i.e., $s.\\text{top}() \\le A[i]$), pop elements from the stack. Any such popped element, say $A[k]$ where $ki$, cannot be the $\\mathrm{NGE}$ for $A[i]$ or any element to the left of $A[i]$ because $A[i]$ itself is closer and greater.\n    b. After the while loop, if the stack is not empty, its top element is the first element to the right of $A[i]$ that is greater than $A[i]$. We set $nge\\_arr[i] = s.\\text{top}()$.\n    c. If the stack is empty, no greater element was found to the right, so $nge\\_arr[i]$ remains $-1$.\n    d. Push the current element $A[i]$ onto the stack. This operation preserves the monotonic (strictly decreasing) property of the stack.\n\nEach element of $A$ is pushed onto and popped from the stack at most once. Therefore, this pass has a time complexity of $O(n)$.\n\n**2. Computing the Previous Greater Element ($\\mathrm{PGE}$)**\n\nThe logic for computing the $\\mathrm{PGE}$ is symmetric to the $\\mathrm{NGE}$ computation. We iterate through the array $A$ from left to right (from index $i = 0$ to $n-1$) and use a similar monotonic stack.\n\nThe algorithm is as follows:\n- Initialize an empty stack, $s$, and a result array, $pge\\_arr$, of size $n$, with all values initialized to $-1$.\n- For each index $i$ from $0$ to $n-1$:\n    a. While the stack $s$ is not empty and the element at the top of the stack is less than or equal to $A[i]$ (i.e., $s.\\text{top}() \\le A[i]$), pop elements from the stack. The reasoning is analogous to the $\\mathrm{NGE}$ case: these popped elements cannot be the $\\mathrm{PGE}$ for the current element or any subsequent elements.\n    b. If the stack is not empty after the loop, its top element is the nearest greater element to the left of $A[i]$. We set $pge\\_arr[i] = s.\\text{top}()$.\n    c. If the stack is empty, no greater element exists to the left, so $pge\\_arr[i]$ remains $-1$.\n    d. Push the current element $A[i]$ onto the stack.\n\nThis pass also has a time complexity of $O(n)$.\n\n**3. Final Product Calculation**\n\nAfter computing the $nge\\_arr$ and $pge\\_arr$ arrays, the final product array $P$ is obtained by an element-wise multiplication: for each index $i$ from $0$ to $n-1$, calculate $P[i] = nge\\_arr[i] \\times pge\\_arr[i]$. This final step also takes $O(n)$ time.\n\nThe total time complexity of this approach is $O(n) + O(n) + O(n) = O(n)$, and the space complexity is $O(n)$ to store the stack and the result arrays. This design is efficient and directly utilizes the structural properties of the problem as intended. For an empty input array, the result is an empty list as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_products(A: list[int]) - list[int]:\n    \"\"\"\n    Computes the product of the Next Greater Element and Previous Greater Element\n    for each element in an array using a monotonic stack approach.\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        return []\n\n    # Initialize result arrays for NGE and PGE with -1.\n    # We use numpy for efficient array operations as permitted.\n    nge_arr = np.full(n, -1, dtype=np.int64)\n    pge_arr = np.full(n, -1, dtype=np.int64)\n\n    # 1. Compute Next Greater Element (NGE) for each element.\n    # We iterate from right-to-left. The stack stores elements from the right\n    # that are candidates for being an NGE.\n    stack = []\n    for i in range(n - 1, -1, -1):\n        # Pop elements from the stack that are less than or equal to the current element.\n        # They cannot be the NGE for A[i] or any elements to the left of A[i].\n        while stack and stack[-1] = A[i]:\n            stack.pop()\n        \n        # If the stack is not empty, the top element is the NGE.\n        if stack:\n            nge_arr[i] = stack[-1]\n        \n        # Push the current element onto the stack for subsequent elements to the left.\n        stack.append(A[i])\n\n    # 2. Compute Previous Greater Element (PGE) for each element.\n    # We iterate from left-to-right. The logic is symmetric to the NGE computation.\n    stack = []\n    for i in range(n):\n        # Pop elements from the stack that are less than or equal to the current element.\n        while stack and stack[-1] = A[i]:\n            stack.pop()\n        \n        # If the stack is not empty, the top element is the PGE.\n        if stack:\n            pge_arr[i] = stack[-1]\n            \n        # Push the current element onto the stack for subsequent elements to the right.\n        stack.append(A[i])\n\n    # 3. Compute the element-wise product of NGE and PGE arrays.\n    products = np.multiply(nge_arr, pge_arr)\n    \n    # Return the result as a standard Python list of integers.\n    return products.tolist()\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the computation for each case,\n    and prints the aggregated results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [5, 1, 3, 2, 4],  # Case 1\n        [1, 2, 3, 4],      # Case 2\n        [4, 3, 2, 1],      # Case 3\n        [2, 2, 2],         # Case 4\n        [7],               # Case 5\n        [],                # Case 6\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_products(case)\n        results.append(result)\n\n    # Format the final output string as a list of lists with no spaces.\n    # E.g., [[r1_1,r1_2],[r2_1],[],...]\n    string_parts = []\n    for res_list in results:\n        # Format each inner list as \"[el1,el2,...]\"\n        string_parts.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    # Join the inner list strings and wrap with outer brackets.\n    final_output = f\"[{','.join(string_parts)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3254179"}, {"introduction": "Building on the foundational pattern from the previous exercise, this problem introduces a more nuanced query that requires synthesis. Instead of just finding any greater element, you must find the one that is *closest* in terms of index distance. This task elegantly demonstrates how the results from two separate monotonic stack passes—one for the nearest greater element to the left and one for the right—can be combined to answer a more sophisticated question, highlighting the pattern's versatility. [@problem_id:3254259]", "problem": "You are given an array $A$ of length $n$ over a totally ordered domain (for example, the integers with the usual order). For each index $i$ with $0 \\le i  n$, define the target index $j$ to be the index that minimizes the absolute index distance $|i - j|$ subject to the strict inequality $A[j]  A[i]$. If no such index $j$ exists, return $-1$ for that position. In the case of a tie, that is, when there exist indices $j_\\ell$ and $j_r$ with $j_\\ell  i  j_r$, $A[j_\\ell]  A[i]$, $A[j_r]  A[i]$, and $|i - j_\\ell| = |j_r - i|$, choose the smaller index (the one on the left), namely $j_\\ell$.\n\nYour task is to implement a program that, for a given array $A$, computes a list $B$ of length $n$ where $B[i]$ is the chosen index $j$ as defined above, or $-1$ if no such index exists.\n\nDesign your solution from first principles using only fundamental definitions of arrays and stacks, and the well-tested fact that a stack data structure supports operations of push and pop in last-in-first-out order. Do not assume or quote any pre-derived specialized formulas for nearest-greater queries; instead justify the data-structural invariants that lead to a linear-time method.\n\nTest suite and required output:\n- Use the following arrays as test cases:\n    1. $[2,1,3,2,4]$\n    2. $[1,2,3,4]$\n    3. $[4,3,2,1]$\n    4. $[2,2,2,2]$\n    5. $[5,1,5,1,5]$\n    6. $[2,1,1,3]$\n    7. $[7]$\n- For each test case, compute the corresponding list $B$ of indices as integers. The final program output must aggregate the results of all test cases into a single line containing a comma-separated list of the per-test-case results, each result itself being a list of integers, and the entire aggregate enclosed in square brackets. For example, if there were three test cases with results $R_1$, $R_2$, and $R_3$, the output format would be $[R_1,R_2,R_3]$, where each $R_k$ is printed as a list in the form $[\\dots]$ without spaces.", "solution": "The problem is valid as it is self-contained, mathematically well-posed, and grounded in the principles of computer science and discrete mathematics. It presents a clear, objective algorithmic challenge without any scientific inconsistencies or ambiguities.\n\nThe task is to find, for each element $A[i]$ in an array $A$ of length $n$, the index $j$ of an element $A[j]$ that is strictly greater than $A[i]$ and is closest to $i$ in terms of index distance, $|i - j|$. A specific tie-breaking rule favors the smaller index (the one to the left) when two such elements exist at equal distances.\n\nA direct, brute-force approach would be, for each index $i$ from $0$ to $n-1$, to search outwards from $i$ in both directions, left and right, to find the first index $j$ satisfying $A[j]  A[i]$. This would involve, for each $i$, a search of up to $O(n)$ other indices, leading to an overall time complexity of $O(n^2)$. We can design a more efficient solution with a linear time complexity, $O(n)$, by leveraging a stack data structure.\n\nThe core idea is to decompose the problem into two independent subproblems:\n$1$. For each index $i$, find the \"Nearest Greater to the Left\", which we denote as $j_\\ell(i)$. This is the index $k  i$ that is closest to $i$ (i.e., maximal $k$) such that $A[k]  A[i]$. If no such index exists, we define $j_\\ell(i) = -1$.\n$2$. For each index $i$, find the \"Nearest Greater to the Right\", which we denote as $j_r(i)$. This is the index $k  i$ that is closest to $i$ (i.e., minimal $k$) such that $A[k]  A[i]$. If no such index exists, we define $j_r(i) = -1$.\n\nOnce we have computed the arrays $J_\\ell = [j_\\ell(0), j_\\ell(1), \\dots, j_\\ell(n-1)]$ and $J_r = [j_r(0), j_r(1), \\dots, j_r(n-1)]$, we can determine the final result $B[i]$ for each index $i$ by comparing the candidates $j_\\ell(i)$ and $j_r(i)$:\n- If both $j_\\ell(i)$ and $j_r(i)$ are $-1$, no such greater element exists, so $B[i] = -1$.\n- If only one of them exists (is not $-1$), that one is the answer. For instance, if $j_\\ell(i) \\ne -1$ and $j_r(i) = -1$, then $B[i] = j_\\ell(i)$.\n- If both exist, we compare the distances. The distance to the left is $d_\\ell = i - j_\\ell(i)$ and to the right is $d_r = j_r(i) - i$. According to the problem's tie-breaking rule, if $d_\\ell \\le d_r$, we choose the left index. Thus, $B[i] = j_\\ell(i)$ if $i - j_\\ell(i) \\le j_r(i) - i$, and $B[i] = j_r(i)$ otherwise.\n\nThe main challenge is to compute $J_\\ell$ and $J_r$ in linear time. We can achieve this using a monotonic stack. Let us derive the algorithm for computing $J_\\ell$ from first principles. The logic for $J_r$ is symmetric.\n\nTo compute $J_\\ell$, we iterate through the array $A$ from left to right, from $i=0$ to $n-1$. We use a stack, `st`, to store indices of the elements we have processed. The crucial step is to maintain a specific invariant on this stack.\n\n**Invariant**: The stack `st` will contain a sequence of indices $p_1, p_2, \\dots, p_k$ (from bottom to top) such that their corresponding values in the array $A$ are strictly decreasing: $A[p_1]  A[p_2]  \\dots  A[p_k]$. This is known as a monotonically decreasing stack.\n\n**Algorithm for finding Nearest Greater to the Left ($J_\\ell$):**\nWe initialize an empty stack `st` and a result array $J_\\ell$ of size $n$ filled with $-1$. We then iterate with index $i$ from $0$ to $n-1$:\n$1$. For the current element $A[i]$, we look at the index $p$ at the top of the stack.\n$2$. While the stack is not empty and the element at the top index is less than or equal to the current element ($A[st.\\text{top}()] \\le A[i]$), we pop from the stack. The reason this is correct is that if $A[st.\\text{top}()] \\le A[i]$, then the index $st.\\text{top}()$ can never be the \"Nearest Greater to the Left\" for any future element $A[k]$ with $ki$, because $i$ is a closer index to $k$ and $A[i]$ is at least as great a value, making $st.\\text{top}()$ a suboptimal candidate.\n$3$. After the popping loop, the stack is either empty or its top element is an index $p$ where $A[p]  A[i]$. Because we popped all indices of smaller or equal elements that were to the right of $p$, this index $p$ is the nearest one to the left of $i$ with a value strictly greater than $A[i]$. Thus, we set $j_\\ell(i) = st.\\text{top}()$. If the stack becomes empty, it means no element to the left is greater than $A[i]$, and $j_\\ell(i)$ remains $-1$.\n$4$. Finally, we push the current index $i$ onto the stack. This operation preserves the monotonically decreasing invariant, as all elements with values less than or equal to $A[i]$ have been removed.\n\nThis process visits each element of the array once. Each index is pushed onto the stack exactly once and popped at most once. Therefore, the time complexity for computing the entire $J_\\ell$ array is $O(n)$.\n\nThe computation of the $J_r$ array follows a symmetric logic. We can iterate through the array $A$ from right to left, from $i=n-1$ down to $0$, applying the same monotonic stack principle.\n\nThe complete algorithm is as follows:\n$1$. Compute the $J_\\ell$ array in $O(n)$ time using a left-to-right pass and a monotonic stack.\n$2$. Compute the $J_r$ array in $O(n)$ time using a right-to-left pass and a monotonic stack.\n$3$. Combine the results into the final array $B$ in $O(n)$ time by iterating from $i=0$ to $n-1$ and applying the distance comparison and tie-breaking logic.\n\nThe total time complexity is $O(n) + O(n) + O(n) = O(n)$, and the space complexity is $O(n)$ to store the stack and the intermediate arrays $J_\\ell$ and $J_r$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nearest greater element problem for a list of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [2, 1, 3, 2, 4],\n        [1, 2, 3, 4],\n        [4, 3, 2, 1],\n        [2, 2, 2, 2],\n        [5, 1, 5, 1, 5],\n        [2, 1, 1, 3],\n        [7]\n    ]\n\n    results = []\n    for a in test_cases:\n        n = len(a)\n        if n == 0:\n            results.append([])\n            continue\n\n        # 1. Compute Nearest Greater to the Left (ngl)\n        # We iterate from left to right. The stack stores indices of elements\n        # in a monotonically decreasing value order.\n        ngl = [-1] * n\n        stack = []\n        for i in range(n):\n            # While stack is not empty and the element at the index on top of the stack\n            # is less than or equal to the current element, pop.\n            while stack and a[stack[-1]] = a[i]:\n                stack.pop()\n            # If the stack is not empty after popping, the top element is the NGL.\n            if stack:\n                ngl[i] = stack[-1]\n            # Push the current index onto the stack.\n            stack.append(i)\n\n        # 2. Compute Nearest Greater to the Right (ngr)\n        # We iterate from right to left. The logic is symmetric to NGL.\n        ngr = [-1] * n\n        stack = []\n        for i in range(n - 1, -1, -1):\n            # Pop elements from stack that are less than or equal to current element.\n            while stack and a[stack[-1]] = a[i]:\n                stack.pop()\n            # If stack is not empty, its top is the NGR.\n            if stack:\n                ngr[i] = stack[-1]\n            # Push current index.\n            stack.append(i)\n\n        # 3. Combine ngl and ngr to find the final result\n        result = [-1] * n\n        for i in range(n):\n            j_left, j_right = ngl[i], ngr[i]\n\n            # Case 1: No greater element exists\n            if j_left == -1 and j_right == -1:\n                result[i] = -1\n            # Case 2: Only greater element is to the right\n            elif j_left == -1:\n                result[i] = j_right\n            # Case 3: Only greater element is to the left\n            elif j_right == -1:\n                result[i] = j_left\n            # Case 4: Greater elements exist on both sides\n            else:\n                dist_left = i - j_left\n                dist_right = j_right - i\n                # Tie-breaking rule: choose left if distances are equal or left is closer.\n                if dist_left = dist_right:\n                    result[i] = j_left\n                else:\n                    result[i] = j_right\n        \n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Each result list is formatted as a string \"[i1,i2,...]\"\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3254259"}, {"introduction": "After learning to implement the monotonic stack algorithm, it is vital to develop a deeper intuition for its operational dynamics. This \"minds-on\" practice challenges you to move beyond coding and analyze the algorithm's behavior by tracing its execution on carefully chosen boundary cases. By predicting the stack's depth and evolution for strictly increasing, decreasing, and other structured arrays, you will solidify your understanding of how the stack's invariant is maintained and how input structure impacts performance. [@problem_id:3254304]", "problem": "Consider the standard left-to-right algorithm for computing the Next Greater Element (NGE) to the right for each position in an array $A[1..n]$. The algorithm maintains a stack of indices and processes elements in order of increasing index. On each iteration $i$, it performs the following steps: while the stack is non-empty and $A[\\text{top}]  A[i]$, it pops the stack, assigning $A[i]$ as the NGE for each popped index; then it pushes $i$ onto the stack. This invariant implies that, after each push, the sequence of values $A$ at the indices in the stack is monotonically non-increasing. The stack depth at step $i$ is defined as the size of the stack after finishing the processing of element $A[i]$ (including any pops and the subsequent push of $i$).\n\nDesign a test suite that exercises boundary behaviors using the following concrete arrays (each array is to be processed independently by the algorithm described above):\n\n- Strictly increasing: $A^{(1)} = [1,2,3,4,5]$ with $n=5$.\n- Strictly decreasing: $A^{(2)} = [5,4,3,2,1]$ with $n=5$.\n- All equal: $A^{(3)} = [3,3,3,3,3]$ with $n=5$.\n- Alternating peaks and valleys: $A^{(4)} = [3,1,4,2,5,3]$ with $n=6$.\n\nWhich option correctly predicts, for each array $A^{(k)}$, both the per-iteration stack depth sequence (a list of depths after processing each element in order) and the maximum stack depth encountered during the entire run?\n\nA. \n- For $A^{(1)}$: depth sequence $[1,1,1,1,1]$, maximum depth $1$.\n- For $A^{(2)}$: depth sequence $[1,2,3,4,5]$, maximum depth $5$.\n- For $A^{(3)}$: depth sequence $[1,2,3,4,5]$, maximum depth $5$.\n- For $A^{(4)}$: depth sequence $[1,2,1,2,1,2]$, maximum depth $2$.\n\nB.\n- For $A^{(1)}$: depth sequence $[1,2,3,4,5]$, maximum depth $5$.\n- For $A^{(2)}$: depth sequence $[1,1,1,1,1]$, maximum depth $1$.\n- For $A^{(3)}$: depth sequence $[1,1,1,1,1]$, maximum depth $1$.\n- For $A^{(4)}$: depth sequence $[1,2,3,2,3,2]$, maximum depth $3$.\n\nC.\n- For $A^{(1)}$: depth sequence $[1,1,1,1,1]$, maximum depth $1$.\n- For $A^{(2)}$: depth sequence $[1,2,3,4,5]$, maximum depth $5$.\n- For $A^{(3)}$: depth sequence $[1,1,1,1,1]$, maximum depth $1$.\n- For $A^{(4)}$: depth sequence $[1,2,1,2,1,2]$, maximum depth $2$.\n\nD.\n- For $A^{(1)}$: depth sequence $[1,1,1,1,1]$, maximum depth $1$.\n- For $A^{(2)}$: depth sequence $[1,2,3,3,3]$, maximum depth $3$.\n- For $A^{(3)}$: depth sequence $[1,2,3,4,5]$, maximum depth $5$.\n- For $A^{(4)}$: depth sequence $[1,2,1,1,2,1]$, maximum depth $2$.", "solution": "The problem is well-defined and asks for a careful trace of a specific monotonic stack algorithm on four boundary-case arrays. The algorithm's logic is clearly stated: for each element $A[i]$, pop from the stack while $A[\\text{top}]  A[i]$, then push $i$. We must track the stack's depth after each element from $i=0$ to $n-1$ is processed.\n\nLet's perform a step-by-step trace for each of the four arrays.\n\n**Case 1: $A^{(1)} = [1,2,3,4,5]$ (Strictly increasing)**\n- **i=0 (A[0]=1):** Stack is empty. Push 0. Stack: `[0]`. Depth: 1.\n- **i=1 (A[1]=2):** $A[0]=1  2$. Pop 0. Stack: `[]`. Push 1. Stack: `[1]`. Depth: 1.\n- **i=2 (A[2]=3):** $A[1]=2  3$. Pop 1. Stack: `[]`. Push 2. Stack: `[2]`. Depth: 1.\n- **i=3 (A[3]=4):** $A[2]=3  4$. Pop 2. Stack: `[]`. Push 3. Stack: `[3]`. Depth: 1.\n- **i=4 (A[4]=5):** $A[3]=4  5$. Pop 3. Stack: `[]`. Push 4. Stack: `[4]`. Depth: 1.\n*   **Depth Sequence:** $[1, 1, 1, 1, 1]$\n*   **Maximum Depth:** 1\n\n**Case 2: $A^{(2)} = [5,4,3,2,1]$ (Strictly decreasing)**\n- **i=0 (A[0]=5):** Stack is empty. Push 0. Stack: `[0]`. Depth: 1.\n- **i=1 (A[1]=4):** $A[0]=5$ is not less than 4. No pop. Push 1. Stack: `[0, 1]`. Depth: 2.\n- **i=2 (A[2]=3):** $A[1]=4$ is not less than 3. No pop. Push 2. Stack: `[0, 1, 2]`. Depth: 3.\n- **i=3 (A[3]=2):** $A[2]=3$ is not less than 2. No pop. Push 3. Stack: `[0, 1, 2, 3]`. Depth: 4.\n- **i=4 (A[4]=1):** $A[3]=2$ is not less than 1. No pop. Push 4. Stack: `[0, 1, 2, 3, 4]`. Depth: 5.\n*   **Depth Sequence:** $[1, 2, 3, 4, 5]$\n*   **Maximum Depth:** 5\n\n**Case 3: $A^{(3)} = [3,3,3,3,3]$ (All equal)**\nThe pop condition is a strict inequality: $A[\\text{top}]  A[i]$. Since all elements are equal, $A[\\text{top}] = A[i]$ for any $i$, so the condition is never met. The behavior is identical to the strictly decreasing case where no elements are popped.\n- **i=0 (A[0]=3):** Push 0. Stack: `[0]`. Depth: 1.\n- **i=1 (A[1]=3):** $A[0]=3$ is not less than 3. Push 1. Stack: `[0, 1]`. Depth: 2.\n- **i=2 (A[2]=3):** $A[1]=3$ is not less than 3. Push 2. Stack: `[0, 1, 2]`. Depth: 3.\n- **i=3 (A[3]=3):** $A[2]=3$ is not less than 3. Push 3. Stack: `[0, 1, 2, 3]`. Depth: 4.\n- **i=4 (A[4]=3):** $A[3]=3$ is not less than 3. Push 4. Stack: `[0, 1, 2, 3, 4]`. Depth: 5.\n*   **Depth Sequence:** $[1, 2, 3, 4, 5]$\n*   **Maximum Depth:** 5\n\n**Case 4: $A^{(4)} = [3,1,4,2,5,3]$ (Alternating)**\n- **i=0 (A[0]=3):** Push 0. Stack: `[0]`. Depth: 1.\n- **i=1 (A[1]=1):** $A[0]=3$ is not less than 1. Push 1. Stack: `[0, 1]`. Depth: 2.\n- **i=2 (A[2]=4):** $A[1]=1  4$, pop 1. Stack: `[0]`. $A[0]=3  4$, pop 0. Stack: `[]`. Push 2. Stack: `[2]`. Depth: 1.\n- **i=3 (A[3]=2):** $A[2]=4$ is not less than 2. Push 3. Stack: `[2, 3]`. Depth: 2.\n- **i=4 (A[4]=5):** $A[3]=2  5$, pop 3. Stack: `[2]`. $A[2]=4  5$, pop 2. Stack: `[]`. Push 4. Stack: `[4]`. Depth: 1.\n- **i=5 (A[5]=3):** $A[4]=5$ is not less than 3. Push 5. Stack: `[4, 5]`. Depth: 2.\n*   **Depth Sequence:** $[1, 2, 1, 2, 1, 2]$\n*   **Maximum Depth:** 2\n\n**Conclusion:**\nBased on the step-by-step trace, the results are:\n- For $A^{(1)}$: depth sequence $[1,1,1,1,1]$, maximum depth $1$.\n- For $A^{(2)}$: depth sequence $[1,2,3,4,5]$, maximum depth $5$.\n- For $A^{(3)}$: depth sequence $[1,2,3,4,5]$, maximum depth $5$.\n- For $A^{(4)}$: depth sequence $[1,2,1,2,1,2]$, maximum depth $2$.\n\nThese results exactly match the predictions listed in Option A. The other options contain incorrect predictions for one or more cases. Therefore, Option A is the correct answer.", "answer": "$$\n\\boxed{A}\n$$", "id": "3254304"}]}