{"hands_on_practices": [{"introduction": "A key feature of a B-tree is its guaranteed logarithmic height, which ensures efficient operations. This efficiency stems from its strict structural invariants, particularly the minimum number of keys and children each node must have. This practice challenges you to explore the limits of these invariants by deriving the minimum number of keys required to construct a B-tree of a specific height $h$, providing a foundational understanding of the tree's worst-case space utilization. [@problem_id:3211646]", "problem": "A balanced multiway search tree known as a B-tree of order $m$ is defined by the following invariants: every node has at most $m$ children;\nevery non-root internal node has at least $\\lceil \\frac{m}{2} \\rceil$ children;\nthe root, if it is not a leaf, has between $2$ and $m$ children;\nand a node with $c$ children stores exactly $c-1$ keys. Leaves store between $\\lceil \\frac{m}{2} \\rceil - 1$ and $m-1$ keys. The height $h$ of the tree is the number of edges on a longest path from the root to any leaf. Consider that the tree is built by successive insertions starting from empty, without deletions, and suppose that the final tree has height $h \\in \\mathbb{Z}_{\\ge 1}$ so that at some point a root split must have occurred to create a non-leaf root. Assume $m \\in \\mathbb{Z}$ with $m \\ge 3$.\n\nUsing only these invariants and the definition of insertion and splitting in B-trees, derive, in closed form as a function of $m$ and $h$, the minimum possible total number of keys stored in the entire tree among all B-trees of order $m$ and height $h$ that could arise from insertions and must have resulted from a root split. Express your final answer as a single symbolic expression in $m$ and $h$ with no numerical approximation.", "solution": "The problem is first validated to ensure it is well-posed, scientifically grounded, and objective.\n\n### Step 1: Extract Givens\n- A B-tree of order $m$.\n- Every node has at most $m$ children.\n- Every non-root internal node has at least $\\lceil \\frac{m}{2} \\rceil$ children.\n- The root, if it is not a leaf, has between $2$ and $m$ children.\n- A node with $c$ children stores exactly $c-1$ keys.\n- Leaves store between $\\lceil \\frac{m}{2} \\rceil - 1$ and $m-1$ keys.\n- The height $h$ is the number of edges on a longest path from the root to any leaf.\n- The tree is built by successive insertions from empty.\n- A root split must have occurred, implying the root is not a leaf.\n- The height is an integer $h \\ge 1$.\n- The order is an integer $m \\ge 3$.\n- The goal is to find the minimum possible total number of keys in such a tree, as a function of $m$ and $h$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem concerns B-trees, a standard topic in computer science and data structures. The properties listed are consistent with the standard definition of a B-tree (e.g., as defined by Cormen et al.). The constraint $m \\ge 3$ is also standard to avoid degenerate cases.\n- **Well-Posed**: The problem asks for the minimum of a quantity (total keys) under a clear set of constraints. This is a well-defined optimization problem. The information provided is sufficient to determine a unique solution.\n- **Objective**: The problem is stated using precise mathematical and algorithmic terminology, with no subjective or ambiguous elements.\n\n### Step 3: Verdict and Action\nThe problem is valid. A reasoned solution will be derived.\n\nTo find the minimum possible total number of keys in a B-tree of order $m$ and height $h$, we must construct a tree that satisfies the given invariants while minimizing the number of keys. This is achieved by minimizing the number of nodes at each level and minimizing the number of keys within each node.\n\nLet the levels of the tree be numbered from $0$ (the root) to $h$ (the leaves). The height $h$ being the number of edges from the root to a leaf implies there are $h+1$ levels of nodes.\n\n1.  **Keys per Node**: The number of keys in an internal node with $c$ children is $c-1$. To minimize the keys in a node, we must minimize its number of children, $c$. For a leaf node, we must choose the minimum allowed number of keys.\n\n2.  **Root Node (Level 0)**: The problem states that a root split must have occurred. A B-tree starts as a single node (the root, which is also a leaf). Keys are inserted until this node is full (it has $m-1$ keys). The next insertion causes the node to temporarily hold $m$ keys, triggering a split. The median key is promoted to a new root node, and the remaining keys are split between two new child nodes. This process creates a tree of height $h=1$. The new root has exactly $1$ key and $2$ children. For any tree of height $h \\ge 1$ that arose from a root split, the root must have at least $2$ children. To minimize the total number of keys, the root node of our minimal tree must have the minimum possible number of children, which is $2$.\n    - Number of children of the root: $c_{root} = 2$.\n    - Number of keys in the root: $c_{root} - 1 = 1$.\n\n3.  **Non-Root Internal Nodes (Levels 1 to $h-1$)**: For any non-root internal node, the minimum number of children allowed is $\\lceil \\frac{m}{2} \\rceil$. To minimize the key count, every internal node at these levels must have exactly this minimum number of children.\n    - Number of children per non-root internal node: $c_{internal} = \\lceil \\frac{m}{2} \\rceil$.\n    - Number of keys per non-root internal node: $c_{internal} - 1 = \\lceil \\frac{m}{2} \\rceil - 1$.\n    This applies for $h>1$. If $h=1$, there are no non-root internal nodes.\n\n4.  **Leaf Nodes (Level $h$)**: The minimum number of keys a leaf node can store is $\\lceil \\frac{m}{2} \\rceil - 1$. To minimize the total key count, every leaf node must store this minimum number of keys.\n    - Number of keys per leaf node: $k_{leaf} = \\lceil \\frac{m}{2} \\rceil - 1$.\n\nNow, we count the number of nodes at each level to sum the total keys. Let $n_i$ be the number of nodes at level $i$.\n\n- Level $0$: There is exactly one root node, so $n_0 = 1$.\n- Level $1$: The root has $2$ children, so $n_1 = 2$.\n- Level $2$: Each of the $n_1=2$ nodes at level $1$ is a non-root internal node and thus has $\\lceil \\frac{m}{2} \\rceil$ children. So, $n_2 = n_1 \\times \\lceil \\frac{m}{2} \\rceil = 2 \\lceil \\frac{m}{2} \\rceil$.\n- Level $i$ ($1 \\le i \\le h$): The number of nodes at level $i$ is the number of nodes at level $i-1$ multiplied by the number of children each has.\n  - $n_i = n_{i-1} \\times \\lceil \\frac{m}{2} \\rceil = 2 \\left(\\lceil \\frac{m}{2} \\rceil\\right)^{i-1}$.\n\nThe total number of keys, $N_{min}$, is the sum of keys in all nodes from level $0$ to $h$.\n$N_{min} = (\\text{keys in root}) + (\\text{keys in non-root internal nodes}) + (\\text{keys in leaves})$.\n\nLet $k = \\lceil \\frac{m}{2} \\rceil$.\n- The root at level $0$ has $1$ key.\n- All non-root nodes (at levels $1$ to $h$) have $k-1$ keys each. This is because non-root internal nodes have $k$ children and thus $k-1$ keys, and leaf nodes are specified to have a minimum of $k-1$ keys.\n\nThe total number of non-root nodes is $\\sum_{i=1}^{h} n_i$.\n$$ \\sum_{i=1}^{h} n_i = \\sum_{i=1}^{h} 2 k^{i-1} = 2 \\sum_{j=0}^{h-1} k^j $$\nThis is a geometric series. Since $m \\ge 3$, $k = \\lceil \\frac{m}{2} \\rceil \\ge \\lceil \\frac{3}{2} \\rceil = 2$, so $k-1 \\neq 0$. The sum of the geometric series is $\\frac{k^h-1}{k-1}$.\n$$ \\text{Total non-root nodes} = 2 \\left( \\frac{k^h - 1}{k-1} \\right) $$\nThe number of keys in all these non-root nodes is:\n$$ (\\text{Total non-root nodes}) \\times (\\text{keys per node}) = 2 \\left( \\frac{k^h - 1}{k-1} \\right) \\times (k-1) = 2(k^h - 1) $$\nTo get the total number of keys in the entire tree, we add the number of keys in the root:\n$$ N_{min} = 1 + 2(k^h - 1) = 1 + 2k^h - 2 = 2k^h - 1 $$\nSubstituting back $k = \\lceil \\frac{m}{2} \\rceil$:\n$$ N_{min}(m, h) = 2 \\left( \\left\\lceil \\frac{m}{2} \\right\\rceil \\right)^h - 1 $$\nThis formula holds for any $h \\ge 1$. For $h=1$, the non-root nodes are the leaves. The set of non-root internal nodes is empty. The calculation remains consistent.\nTotal keys for $h=1$: $1$ (root) + $2 \\times (\\text{keys per leaf}) = 1 + 2(k-1) = 2k-1$.\nThe formula gives $2k^1 - 1 = 2k-1$. It is correct.\n\nThe minimum total number of keys stored in such a B-tree is $2 \\left( \\lceil \\frac{m}{2} \\rceil \\right)^h - 1$.", "answer": "$$\\boxed{2 \\left(\\left\\lceil \\frac{m}{2} \\right\\rceil\\right)^h - 1}$$", "id": "3211646"}, {"introduction": "Understanding the rules of a data structure is one thing; understanding the dynamic process of its creation is another. This exercise acts as a 'forensic investigation', presenting you with a final B-tree structure and asking if it could have been formed through a specific sequence of events—namely, a single root split. To solve this, you must think backward and reason about the insertion and splitting algorithm's procedural steps, testing your grasp of how B-trees evolve over time. [@problem_id:3211681]", "problem": "Consider a B-tree of minimum degree $t$ where every node (except possibly the root) must contain between $t-1$ and $2t-1$ keys, and where each internal node with $k$ keys has exactly $k+1$ children. Insertion is performed using the standard algorithm: when descending to insert a new key into a full node, that node is split immediately, promoting its median to its parent;\nif the root overflows, it is split and a new root is created, increasing the tree’s level by $1$. All leaves reside at the same depth in the final tree. Starting from an empty B-tree, a sequence of insertions of distinct keys produces the final tree described below. The minimum degree is $t=3$.\n\nFinal tree structure:\n- Root contains keys $[30, 50]$ and has $3$ children, each of which is a leaf.\n- Child $0$ (leaf) contains keys $[7, 12, 20, 25]$.\n- Child $1$ (leaf) contains keys $[35, 40, 45]$.\n- Child $2$ (leaf) contains keys $[55, 60, 67, 70, 72]$.\n\nAssume all keys are distinct and all node-ordering constraints hold (that is, every key in Child $0$ is less than $30$, every key in Child $1$ is strictly between $30$ and $50$, and every key in Child $2$ is greater than $50$). The question is whether there exists an insertion order of the given keys, starting from the empty tree and using the standard splitting-on-descent insertion, that results in the above final structure and causes only a single split of the root over the entire sequence.\n\nWhich option is correct?\n\nA. Yes;\na single root split suffices because the root’s immediate children are leaves, all non-root nodes obey the bounds for $t=3$, and promotions to the root can be scheduled so the root never exceeds $2t-1$ keys.\n\nB. No;\nthe presence of a leaf with $5$ keys implies that leaf must split and promote a key to the root, thereby forcing the root to split at least twice.\n\nC. Yes;\nbut only if temporary violations of node-capacity constraints are allowed during insertion and are repaired afterwards.\n\nD. No;\nbecause the root has fewer than $t-1$ keys, which contradicts the B-tree definition for non-empty trees.", "solution": "The user wants me to validate the problem statement and then find the correct option regarding the formation of a specific B-tree.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- B-tree minimum degree is $t=3$.\n- Any node (except the root) must contain between $t-1$ and $2t-1$ keys.\n- An internal node with $k$ keys has $k+1$ children.\n- Insertion uses the standard algorithm: a full node is split on descent.\n- A root overflow causes a root split, increasing the tree's level by $1$.\n- Start from an empty B-tree.\n- The final tree structure is:\n    - Root: keys $[30, 50]$, with $3$ children.\n    - Child $0$ (leaf): keys $[7, 12, 20, 25]$.\n    - Child $1$ (leaf): keys $[35, 40, 45]$.\n    - Child $2$ (leaf): keys $[55, 60, 67, 70, 72]$.\n- The question is whether an insertion order exists that produces this final tree and causes only a single split of the root.\n\n**Step 2: Validate Using Extracted Givens**\nFirst, I will verify the stated properties for $t=3$.\n- Minimum degree $t=3$.\n- Maximum number of keys per node: $2t-1 = 2(3)-1 = 5$.\n- Minimum number of keys per non-root node: $t-1 = 3-1 = 2$.\n- Minimum number of keys for a non-leaf root: $1$.\n\nNow, I will check if the final tree structure adheres to these properties.\n- Root: Contains $2$ keys ($[30, 50]$). This is valid, as $1 \\le 2 \\le 5$. It has $2+1=3$ children, which is consistent.\n- Child $0$: Contains $4$ keys. This is a valid number for a non-root node, as $2 \\le 4 \\le 5$.\n- Child $1$: Contains $3$ keys. This is valid, as $2 \\le 3 \\le 5$.\n- Child $2$: Contains $5$ keys. This is valid, as $2 \\le 5 \\le 5$. This node is full.\n\nThe problem statement describes a valid B-tree structure according to its own definitions. The question asks about the existence of an insertion sequence under a standard algorithm. This is a well-posed question within the domain of data structures and algorithms. The problem is scientifically grounded, objective, and internally consistent.\n\n**Step 3: Verdict and Action**\nThe problem is valid. I will proceed to derive the solution.\n\n### Solution Derivation\n\nThe central question is whether the target B-tree can be formed from an empty tree with the constraint of undergoing exactly one root split.\n\n1.  **Understanding a Root Split:** A B-tree starts as a single node, which is both the root and a leaf. Keys are inserted into this node. For $t=3$, this node becomes full when it contains $2t-1=5$ keys. The standard insertion algorithm with splitting on descent dictates that when an attempt is made to insert a key into a full node, that node must be split. When the root itself is this full node, a **root split** occurs. This is the only event that increases the height of the B-tree.\n    - The full root node, which is a leaf, contains $5$ keys. Let's say a $6$-th key is to be inserted.\n    - Before proceeding, the insertion algorithm detects the root is full. a) A new, empty root is created. b) The old full root is made a child of this new root. c) The `split-child` procedure is called on the new root to split its now-full child (the old root).\n    - The median key of the full node (the $3$-rd of $5$ keys in the node, or the median of the conceptual $6$-key set) is promoted to the newly created root.\n    - The remaining keys are partitioned into two new nodes, each with $t-1=2$ keys. These two nodes become the children of the new root.\n    - Therefore, immediately after the **single root split**, the tree has a height of $1$. The root contains exactly $1$ key, and it has $2$ children (leaves), each containing $2$ keys.\n\n2.  **Reaching the Final State:** The final tree has a root with $2$ keys: $[30, 50]$.\n    - Our analysis shows that after the single allowed root split, the root contains only $1$ key. Let's call this key $K_1$.\n    - To get a second key, $K_2$, into the root, another key promotion must occur.\n    - A key is promoted to the root when one of its children splits. A child split is **not** a root split. A root split is the specific event where the root itself is the subject of the split operation, increasing the tree height. A child split merely adds a key to the existing root, which does not change the tree's height.\n    - Thus, the path to the final tree must involve one root split followed by at least one split of a child of the root. This is consistent with the problem's constraint of \"only a single split of the root\".\n\n3.  **Constructing a Plausible Sequence of Events:**\n    - Let's assume the root split promoted the key $30$. The tree state was: Root=`[30]`, Left Child=`[k_1, k_2]`, Right Child=`[k_3, k_4]`, where $k_1, k_2 < 30$ and $k_3, k_4 > 30$.\n    - To get to the final root `[30, 50]`, the key $50$ must have been promoted from a subsequent child split. Since $50 > 30$, the right child must have split.\n    - For the right child to split, it must have first become full ($5$ keys). These keys would all be greater than $30$. Let's say insertions led to the right child containing the keys $\\{k_A, k_B, 50, k_C, k_D\\}$. Per the standard algorithm, the median key, $50$, is the one that would be promoted.\n    - Upon splitting this node, $50$ moves to the root, which becomes `[30, 50]`. The node that split is replaced by two new nodes: a leaf with keys $\\{k_A, k_B\\}$ and a leaf with keys $\\{k_C, k_D\\}$. Keys $\\{k_A, k_B\\}$ must be in the range $(30, 50)$, and keys $\\{k_C, k_D\\}$ must be $> 50$.\n    - The resulting tree has a root `[30, 50]` and three children:\n        - Child 0: The original left child, which after further insertions becomes `[7, 12, 20, 25]`.\n        - Child 1: The new node with keys $\\{k_A, k_B\\}$, which after further insertions becomes `[35, 40, 45]`.\n        - Child 2: The new node with keys $\\{k_C, k_D\\}$, which after further insertions becomes `[55, 60, 67, 70, 72]`.\n    - This sequence is entirely feasible. For example, after the split that promoted $50$, Child 1 has $2$ keys, and one more is inserted to reach the final count of $3$. Child 2 has $2$ keys, and three more are inserted to reach the final count of $5$, making it full. The existence of a full leaf (Child 2) only means that after it became full, no subsequent key insertions were directed to it, which is possible if the remaining keys to be inserted were all smaller than $55$.\n    - A symmetric argument shows that it is also plausible if $50$ were promoted at the root split and $30$ were promoted later from a left-child split.\n    - Therefore, an insertion sequence that produces the final tree with only a single root split exists.\n\n### Option-by-Option Analysis\n\n**A. Yes; a single root split suffices because the root’s immediate children are leaves, all non-root nodes obey the bounds for $t=3$, and promotions to the root can be scheduled so the root never exceeds $2t-1$ keys.**\n- Verdict: **Correct**. A single root split creates a root with $1$ key. A subsequent child split promotes a second key, resulting in the $2$-key root. At no point does the root need to hold more than $2$ keys, which is well below the maximum of $5$. The other conditions mentioned (children are leaves, nodes obey bounds) are properties of the final tree that make the construction possible. This is a correct high-level description of why the process is possible.\n\n**B. No; the presence of a leaf with $5$ keys implies that leaf must split and promote a key to the root, thereby forcing the root to split at least twice.**\n- Verdict: **Incorrect**. This option's reasoning is flawed in two ways. First, a node with $5$ keys is full, but it only splits if the insertion algorithm attempts to descend to it to place a new key. If subsequent insertions go into other leaves, this full leaf will not be on the search path and will not split. Second, even if this leaf did split, it would promote a key to its parent (the root). This adds a key to the root node; it does not \"force the root to split\" unless the root was already full with $5$ keys, which is not the case here. A child split and a root split are distinct events.\n\n**C. Yes; but only if temporary violations of node-capacity constraints are allowed during insertion and are repaired afterwards.**\n- Verdict: **Incorrect**. This option correctly states that a sequence exists (\"Yes\"), but the condition is false. The standard B-tree insertion algorithm is designed specifically to *prevent* any node from exceeding the $2t-1$ key limit. The splitting operation is an integral part of the algorithm, not an after-the-fact \"repair\" of a \"violation\". The required tree can be constructed using the standard algorithm without any such temporary violations.\n\n**D. No; because the root has fewer than $t-1$ keys, which contradicts the B-tree definition for non-empty trees.**\n- Verdict: **Incorrect**. This option's premise is factually incorrect. For $t=3$, the minimum key count for a non-root node is $t-1 = 2$. The final root has $2$ keys ($[30, 50]$), so the number of keys is not \"fewer than $t-1$\". Furthermore, even if the root had only $1$ key, it would not contradict the definition, as the root node is exempt from the $t-1$ minimum key rule and is permitted to have as few as $1$ key (unless it is a leaf, and the tree is empty).", "answer": "$$\\boxed{A}$$", "id": "3211681"}, {"introduction": "Moving from textbook theory to real-world applications often introduces complexities like duplicate data. This problem explores how a B+ tree, a common variant used in database indexing, handles massive numbers of duplicate keys. You will analyze how a seemingly minor implementation detail—the tie-breaking rule during searches—has a dramatic and predictable effect on where new keys are inserted and how splits propagate through the tree. [@problem_id:3211649]", "problem": "Consider a B-plus tree (B+ tree) used to index records by a sortable key. By definition, a B-plus tree stores all records in the leaf level, maintains all leaves at the same height, and uses internal nodes containing separator keys to guide searches. Assume the following fundamental properties and policies are in effect:\n- Each leaf node can store at most $B$ record entries (where $B \\ge 2$ is a fixed capacity).\n- Duplicated keys are allowed and are stored as separate record entries in leaf nodes;\nduplicates appear contiguously when sorted by key.\n- During search and insertion, when comparing a search key $k$ to an internal separator key $s$, if $k < s$ the search goes to the left child;\nif $k \\ge s$ the search goes to the right child (a right-bias tie-breaking rule on equality).\n- Standard insertion is used: locate the target leaf for the key, insert the new record in sorted position, and if the leaf overflows beyond $B$ entries, split the leaf into two leaves and push an appropriate separator up to the parent;\nsplitting may cascade upward if internal nodes overflow.\n\nSuppose the tree already contains $N = 10^6$ occurrences of a particular key $k$, spread contiguously across a run of adjacent leaf nodes due to prior insertions and splits. Now, consider inserting $M$ additional occurrences of the same key $k$, one by one, using the described search and insertion policies, with $M$ sufficiently large that additional splits are possible.\n\nWhich statement best characterizes the leaf-level splitting behavior caused specifically by these $M$ insertions of the existing key $k$?\n\nA. Under the stated right-bias tie-breaking rule and duplicate storage policy, all $M$ insertions of $k$ are routed to the rightmost leaf in the contiguous run of $k$ at the leaf level. Leaf splits therefore occur only at this right boundary as it overflows, yielding a count of leaf splits on the order of $\\Theta(M/B)$ concentrated on successive right siblings;\nearlier leaves containing $k$ do not split due solely to these new inserts.\n\nB. Because the key $k$ already spans multiple leaves, new occurrences of $k$ are evenly balanced among all leaves containing $k$;\nleaf splits are spread uniformly across the run, and the total number of leaf splits grows as $\\Theta(\\log M)$ due to the tree height.\n\nC. Since $k$ already appears $10^6$ times, each additional insertion of $k$ immediately triggers a rebalancing that redistributes the entire run of $k$ across all leaves, causing every leaf in the run to split on each insertion to preserve perfect uniformity.\n\nD. If duplicates are represented by a per-key count field in each leaf rather than stored as individual record entries, then no leaf splits occur when inserting the $M$ new instances of $k$, regardless of the magnitude of $M$.", "solution": "The user wants me to follow the role of a meticulous STEM professor to solve a problem about B+ tree insertion behavior.\n\n### Problem Validation\n\nFirst, I must validate the problem statement to ensure it is scientifically sound, well-posed, and objective.\n\n**Step 1: Extract Givens**\n\nThe problem statement provides the following definitions, parameters, and policies for a B-plus tree:\n-   **Structure**: It is a B-plus tree where all records are in leaf nodes, and all leaves are at the same height. Internal nodes contain separator keys.\n-   **Leaf Capacity**: Each leaf node can store at most `$B$` record entries, with `$B \\ge 2$`.\n-   **Duplicate Keys**: Duplicated keys are permitted and are stored as separate, individual record entries.\n-   **Sorting**: Duplicate keys appear contiguously in a sorted scan of the leaves.\n-   **Search/Insertion Tie-Breaking Rule**: When comparing a search key `$k$` to an internal separator key `$s$`:\n    -   If `$k < s$`, the search proceeds to the left child.\n    -   If `$k \\ge s$`, the search proceeds to the right child. This is a \"right-bias\" rule.\n-   **Insertion Procedure**: Standard insertion is used (locate leaf, insert, split on overflow, propagate split upwards if necessary).\n-   **Initial State**: The tree already contains `$N = 10^6$` occurrences of a specific key, `$k$`. These records are located in a contiguous run of adjacent leaf nodes.\n-   **Operation**: `$M$` additional occurrences of the same key `$k$` are inserted one by one. `$M$` is large enough to potentially cause splits.\n-   **Question**: The task is to characterize the leaf-level splitting behavior resulting from these `$M$` insertions.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientific Grounding**: The problem is fully grounded in the established principles of computer science, specifically the theory of data structures and algorithms. The B+ tree is a standard, well-defined structure, and its insertion algorithm is deterministic and rigorously specified. All terms used are standard in the field.\n-   **Well-Posedness**: The problem is well-posed. The initial state is clearly described. The insertion algorithm, including the critical tie-breaking rule, is explicitly defined. This determinism ensures that a unique, predictable behavior results from the described operations, leading to a single valid characterization.\n-   **Objectivity**: The problem is stated in an objective, technical language, free from ambiguity or subjective claims.\n-   **Completeness and Consistency**: The problem provides all necessary information to determine the search path for the duplicate key `$k$` and the subsequent insertion and splitting behavior. The `right-bias` rule is the crucial piece of information that dictates the outcome. There are no internal contradictions. For instance, the contiguous storage of existing keys is a natural consequence of prior insertions of the same key. The capacity of internal nodes is not specified, but it is not required to analyze the *leaf-level* splitting phenomenon in question.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. It is a clear, consistent, and well-posed question based on standard computer science principles. I will now proceed to derive the solution.\n\n### Solution Derivation\n\nThe core of this problem lies in understanding how the B+ tree's search algorithm, particularly the tie-breaking rule, directs the insertion of a new record when its key is a duplicate of many existing keys.\n\n1.  **Search Path for a Duplicate Key**: The insertion process for a new record with key `$k$` begins with a search to find the appropriate leaf node. This search starts at the root and descends the tree. At each internal node, the search key `$k$` is compared against the separator keys `$s_1, s_2, \\ldots$`. The given tie-breaking rule is: if `$k < s$`, go left; if `$k \\ge s$`, go right.\n\n2.  **Impact of the Right-Bias Rule**: Consider a run of leaves `$L_1, L_2, \\ldots, L_p$` that contain records with the key `$k$`. For this to be possible, the parent and higher-level internal nodes must have separator keys that partition the key space accordingly. After a leaf `$L_i$` filled with key `$k$` split to create a new leaf `$L_{i+1}$`, the key pushed up to the parent as a separator would be the first key in the new leaf `$L_{i+1}$`, which is `$k$`. Therefore, the internal nodes guiding the search to this region of leaves will contain separator keys equal to `$k$`.\n\n    When our search for where to insert a new instance of `$k$` encounters an internal separator key `$s = k$`, the tie-breaking rule `$k \\ge s$` is satisfied. This forces the search to proceed to the **right child**. This will happen repeatedly at every level of the tree where a separator key `$k$` is used to distinguish between two subtrees that both contain keys equal to `$k$`. The search path is therefore systematically pushed to the rightmost branch of the tree that is associated with the key `$k$`.\n\n3.  **Target Leaf for Insertion**: This deterministic, right-biased pathing leads the search to the single, unique leaf node that is at the \"end\" of the range of key `$k$`. This will be the rightmost leaf node in the contiguous run of leaves that contain records with key `$k$`. Let us call this leaf `$L_{end}$`.\n\n4.  **Insertion and Splitting Dynamics**:\n    -   All `$M$` insertions of the new key `$k$` are routed to this same leaf, `$L_{end}$`. The earlier leaves in the run (`$L_1, L_2, \\ldots, L_{p-1}$`) are never reached by the search algorithm for inserting `$k$`.\n    -   Initially, the `$M$` insertions will fill any available space in `$L_{end}$`. Let's say `$L_{end}$` has `$\\text{count} < B$` entries. The first `$B - \\text{count}$` insertions will fill this leaf without causing a split.\n    -   The next insertion of `$k$` will cause `$L_{end}$` to overflow, as it now has `$B+1$` entries. This triggers a split. `$L_{end}$` is divided into two leaves. Let's call them `$L_{end}'$` (the new left sibling) and `$L_{new\\_end}$` (the new right sibling). Both will contain only keys `$k$`. A copy of the first key of `$L_{new\\_end}$`, which is `$k$`, is pushed up to the parent node.\n    -   After this split, the rightmost leaf containing key `$k$` is now `$L_{new\\_end}$`.\n    -   The subsequent insertion of `$k$` will again follow the right-biased search path and be directed to this new rightmost leaf, `$L_{new\\_end}$`.\n    -   This process repeats: all insertions are concentrated at the ever-advancing right boundary of the key run. A split occurs, creating a new rightmost leaf, which becomes the new \"hot spot\" for all subsequent insertions.\n\n5.  **Quantifying the Splits**: A leaf split is triggered by an overflow. After a split of a node with `$B+1$` items, the newly created rightmost leaf will contain approximately `$B/2$` items (more precisely, `$\\lfloor (B+1)/2 \\rfloor$` items). To cause this new leaf to split, it must be filled to capacity (`$B$` items) and then receive one more. This requires approximately `$B-B/2 = B/2$` additional insertions (more precisely, `$B - \\lfloor (B+1)/2 \\rfloor + 1 = \\lceil (B+1)/2 \\rceil$` insertions). Since `$B$` is a fixed constant, each split is caused by `$\\Theta(B)$` insertions.\n    Therefore, for a total of `$M$` insertions, the total number of leaf splits will be on the order of `$M / \\Theta(B)`, which is `$\\Theta(M/B)$`.\n\n### Option-by-Option Analysis\n\n**A. Under the stated right-bias tie-breaking rule and duplicate storage policy, all `$M$` insertions of `$k$` are routed to the rightmost leaf in the contiguous run of `$k$` at the leaf level. Leaf splits therefore occur only at this right boundary as it overflows, yielding a count of leaf splits on the order of `$\\Theta(M/B)$` concentrated on successive right siblings; earlier leaves containing `$k$` do not split due solely to these new inserts.**\n-   **Verdict**: **Correct**. This statement perfectly matches the derivation above. The right-bias rule (`$k \\ge s$`) funnels all insertions for `$k$` to the rightmost leaf. This concentration of insertions at the right boundary causes splits to occur exclusively there. The number of splits is proportional to the number of insertions (`$M$`) and inversely proportional to the leaf capacity (`$B$`), giving a `$\\Theta(M/B)$` dependency. The earlier leaves in the run are unaffected.\n\n**B. Because the key `$k$` already spans multiple leaves, new occurrences of `$k$` are evenly balanced among all leaves containing `$k$`; leaf splits are spread uniformly across the run, and the total number of leaf splits grows as `$\\Theta(\\log M)$` due to the tree height.**\n-   **Verdict**: **Incorrect**. The B+ tree insertion algorithm is deterministic, not a load-balancing scheme that distributes duplicates \"evenly\". The search path is fixed by the tie-breaking rule, leading to one specific leaf. Furthermore, the number of splits is linearly related to `$M$` (and inversely to `$B$`), not logarithmically. The `$\\log$` factor in B-trees typically relates to the cost of a single operation (search/insert/delete) due to the tree's height, not the number of splits from bulk insertions.\n\n**C. Since `$k$` already appears `$10^6$` times, each additional insertion of `$k$` immediately triggers a rebalancing that redistributes the entire run of `$k$` across all leaves, causing every leaf in the run to split on each insertion to preserve perfect uniformity.**\n-   **Verdict**: **Incorrect**. This describes a process that is not part of the standard B+ tree algorithm. B+ trees handle overflow with local splits that may propagate vertically to the parent. They do not perform a global, horizontal \"rebalancing\" that redistributes keys across multiple sibling leaves upon a single insertion. The idea of every leaf splitting on each insertion is fantastically inefficient and factually wrong.\n\n**D. If duplicates are represented by a per-key count field in each leaf rather than stored as individual record entries, then no leaf splits occur when inserting the `$M$` new instances of `$k$`, regardless of the magnitude of `$M$`.**\n-   **Verdict**: **Incorrect**. This option proposes an alternative data structure design. The problem statement explicitly specifies that \"Duplicated keys are allowed and are stored as separate record entries\". The question is about the behavior of the tree *as defined*. While the premise of this option (using a counter would prevent splits) might be true for that alternative design, it is irrelevant to the problem at hand. We must analyze the system as it was given, not as it could have been designed differently.", "answer": "$$\\boxed{A}$$", "id": "3211649"}]}