{"hands_on_practices": [{"introduction": "Understanding complexity classes often begins with appreciating the vast gap between problems in $\\mathrm{P}$ and those that are $\\mathrm{NP}$-complete. This exercise contrasts two problems on bipartite graphs that might seem related at first glance: finding a large matching, which is efficiently solvable, and finding a large balanced biclique, which is famously hard. By analyzing the relationship between them, you will explore the fundamental structural differences that place them in different complexity classes and understand why a simple reduction from the hard problem to the easy one is bound to fail [@problem_id:3222980].", "problem": "Consider the following decision problems on a bipartite graph $G = (L,R,E)$ and an integer $k \\in \\mathbb{N}$.\n\n1. $\\text{BIPARTITE-CLIQUE (balanced)}$: Decide whether there exist subsets $S \\subseteq L$ and $T \\subseteq R$ such that $|S| = |T| = k$ and $S \\times T \\subseteq E$, that is, whether $G$ contains a complete bipartite subgraph $K_{k,k}$.\n\n2. $\\text{BIPARTITE-MATCHING}$: Decide whether there exists a matching $M \\subseteq E$ with $|M| \\geq k$, where a matching is a set of pairwise vertex-disjoint edges.\n\nUse the following foundational definitions and facts as the base for reasoning:\n\n- A polynomial-time many-one reduction from a language $A$ to a language $B$ is a function $f$ computable in time polynomial in the input size such that for every instance $x$, $x \\in A$ if and only if $f(x) \\in B$.\n- The complexity class $\\mathrm{P}$ is the set of languages decidable in polynomial time by a deterministic Turing machine.\n- The complexity class $\\mathrm{NP}$ is the set of languages for which membership certificates can be verified in polynomial time.\n- $\\text{BIPARTITE-MATCHING}$ is solvable in polynomial time (for example, via a reduction to maximum flow).\n- $\\text{BIPARTITE-CLIQUE (balanced)}$ (existence of $K_{k,k}$) is $\\mathrm{NP}$-complete.\n\nSelect all statements that are correct about whether $\\text{BIPARTITE-CLIQUE (balanced)}$ reduces to $\\text{BIPARTITE-MATCHING}$ and the structural reasons behind the relationship:\n\nA. There is a polynomial-time many-one reduction $f$ that maps an instance $(G,k)$ of $\\text{BIPARTITE-CLIQUE (balanced)}$ to the same instance $(G,k)$ of $\\text{BIPARTITE-MATCHING}$, because $G$ has a matching of size $k$ if and only if $G$ contains $K_{k,k}$.\n\nB. Unless $\\mathrm{P}=\\mathrm{NP}$, there is no polynomial-time many-one reduction from $\\text{BIPARTITE-CLIQUE (balanced)}$ to $\\text{BIPARTITE-MATCHING}$, since the former is $\\mathrm{NP}$-complete while the latter is in $\\mathrm{P}$.\n\nC. A structural reason a straightforward reduction fails is that matchings enforce a local constraint of at most one selected edge incident on any vertex, whereas balanced bicliques require a global “all-to-all” adjacency between two $k$-vertex subsets; this global constraint cannot be captured by a single matching instance without additional gadgets.\n\nD. If $G$ contains a balanced biclique $K_{k,k}$, then $G$ necessarily has a matching of size $k$.\n\nE. Passing to the line graph $L(G)$ converts the $\\text{BIPARTITE-CLIQUE (balanced)}$ instance into a clique instance of size $k^{2}$, which can then be solved via a matching computation on $L(G)$; therefore a polynomial-time reduction exists through $L(G)$.", "solution": "The core of the problem is the relationship between the complexity classes $\\mathrm{P}$ and $\\mathrm{NP}$. We are given that $\\text{BIPARTITE-MATCHING}$ is in $\\mathrm{P}$ and $\\text{BIPARTITE-CLIQUE (balanced)}$ is $\\mathrm{NP}$-complete. A fundamental theorem of complexity theory states that if a language $A$ has a polynomial-time many-one reduction to a language $B$ (denoted $A \\le_p B$), and if $B \\in \\mathrm{P}$, then it must be that $A \\in \\mathrm{P}$.\n\nIn this context, let $A$ be $\\text{BIPARTITE-CLIQUE (balanced)}$ and $B$ be $\\text{BIPARTITE-MATCHING}$. If a polynomial-time reduction from $A$ to $B$ existed, it would imply that $\\text{BIPARTITE-CLIQUE (balanced)} \\in \\mathrm{P}$. Since $\\text{BIPARTITE-CLIQUE (balanced)}$ is $\\mathrm{NP}$-complete, this would mean that every problem in $\\mathrm{NP}$ can be solved in polynomial time, which is the statement $\\mathrm{P}=\\mathrm{NP}$. As $\\mathrm{P}=\\mathrm{NP}$ is a major unresolved conjecture widely believed to be false, any claim of such a reduction is extraordinary and, in the context of standard complexity assumptions, false.\n\nWith this foundational understanding, I will now evaluate each statement individually.\n\nA. **There is a polynomial-time many-one reduction $f$ that maps an instance $(G,k)$ of $\\text{BIPARTITE-CLIQUE (balanced)}$ to the same instance $(G,k)$ of $\\text{BIPARTITE-MATCHING}$, because $G$ has a matching of size $k$ if and only if $G$ contains $K_{k,k}$.**\nThis statement makes two claims: 1) an identity reduction works, and 2) the reason is a structural equivalence. For an identity mapping to be a valid reduction, it must be that for any instance $(G, k)$, \"$G$ contains $K_{k,k}$\" is true if and only if \"$G$ has a matching of size at least $k$\" is true.\nLet's analyze the biconditional claim.\n- Implication $(\\Rightarrow)$: If $G$ contains a $K_{k,k}$ subgraph on partitions $S \\subseteq L$ and $T \\subseteq R$ where $|S|=|T|=k$, then for any enumeration $S=\\{s_1, \\dots, s_k\\}$ and $T=\\{t_1, \\dots, t_k\\}$, the set of edges $M = \\{(s_1, t_1), \\dots, (s_k, t_k)\\}$ exists in $G$ (due to the all-to-all connectivity of $K_{k,k}$) and forms a matching of size $k$. So, this implication is true.\n- Implication $(\\Leftarrow)$: If $G$ has a matching of size $k$, must it contain a $K_{k,k}$? Consider a graph $G$ with $L=\\{u_1, u_2\\}$, $R=\\{v_1, v_2\\}$, and edges $E = \\{(u_1,v_1), (u_2,v_2)\\}$. Let $k=2$. This graph has a matching of size $2$, namely $M=E$. However, it does not contain a $K_{2,2}$ because the edges $(u_1, v_2)$ and $(u_2, v_1)$ are missing.\nSince the \"if and only if\" condition is false, the reasoning is invalid, and the proposed identity reduction fails.\nVerdict on A: **Incorrect**.\n\nB. **Unless $\\mathrm{P}=\\mathrm{NP}$, there is no polynomial-time many-one reduction from $\\text{BIPARTITE-CLIQUE (balanced)}$ to $\\text{BIPARTITE-MATCHING}$, since the former is $\\mathrm{NP}$-complete while the latter is in $\\mathrm{P}$.**\nThis statement is a direct and correct application of core complexity theory. As established in the preamble, a polynomial-time reduction from an $\\mathrm{NP}$-complete problem to a problem in $\\mathrm{P}$ would prove that $\\mathrm{P}=\\mathrm{NP}$. Therefore, assuming $\\mathrm{P} \\neq \\mathrm{NP}$, no such reduction can exist. The statement correctly qualifies this conclusion with \"Unless $\\mathrm{P}=\\mathrm{NP}$\" and provides the correct reasoning based on the given complexity classes of the two problems.\nVerdict on B: **Correct**.\n\nC. **A structural reason a straightforward reduction fails is that matchings enforce a local constraint of at most one selected edge incident on any vertex, whereas balanced bicliques require a global “all-to-all” adjacency between two $k$-vertex subsets; this global constraint cannot be captured by a single matching instance without additional gadgets.**\nThis statement provides a structural and intuitive explanation for the complexity-theoretic conclusion in B. A matching is a set of $k$ independent edges, representing a sparse structure. A $K_{k,k}$ biclique is a set of $k^2$ edges arranged in a very specific dense, \"all-to-all\" pattern. The properties are fundamentally different. A matching only requires that no two selected edges share a vertex (a local property for each pair of edges). A biclique requires that for two specific sets of vertices $S$ and $T$, *all* $k^2$ possible edges between them must be present (a global property of the sets). It is not obvious how to encode this global, dense requirement using a problem that looks for a sparse set of independent edges. The statement accurately captures this structural chasm, which is the underlying reason why simple reductions do not work.\nVerdict on C: **Correct**.\n\nD. **If $G$ contains a balanced biclique $K_{k,k}$, then $G$ necessarily has a matching of size $k$.**\nThis is the forward implication $(\\Rightarrow)$ analyzed in option A. Let the $K_{k,k}$ subgraph exist on vertex partitions $S \\subseteq L$ and $T \\subseteq R$, with $|S|=|T|=k$. By definition of a complete bipartite graph, every vertex in $S$ is connected to every vertex in $T$. We can construct a perfect matching within this subgraph. For example, if we label the vertices $S = \\{s_1, \\dots, s_k\\}$ and $T = \\{t_1, \\dots, t_k\\}$, the set of edges $\\{(s_i, t_i) \\mid i=1, \\dots, k\\}$ is a valid matching of size $k$ in the $K_{k,k}$ subgraph, and therefore also in $G$. So, the existence of a $K_{k,k}$ is a sufficient condition for the existence of a matching of size $k$.\nVerdict on D: **Correct**.\n\nE. **Passing to the line graph $L(G)$ converts the $\\text{BIPARTITE-CLIQUE (balanced)}$ instance into a clique instance of size $k^{2}$, which can then be solved via a matching computation on $L(G)$; therefore a polynomial-time reduction exists through $L(G)$.**\nThis statement proposes a specific reduction strategy and is flawed in multiple ways.\n1. A $K_{k,k}$ subgraph in $G$ consists of $k^2$ edges. In the line graph $L(G)$, these $k^2$ edges become $k^2$ vertices. For these vertices to form a clique of size $k^2$ in $L(G)$, every pair of corresponding edges in $G$ must be incident (share a vertex). This is false. For example, in a $K_{2,2}$ on partitions $\\{s_1,s_2\\}$ and $\\{t_1,t_2\\}$, the edges $(s_1,t_1)$ and $(s_2,t_2)$ are not incident. Therefore, the $k^2$ vertices in $L(G)$ do not form a clique.\n2. The statement then claims the resulting problem \"can then be solved via a matching computation on $L(G)$.\" This is nonsensical. Finding a clique in a graph and finding a matching in the same graph are two entirely different problems. CLIQUE is $\\mathrm{NP}$-complete, whereas (Maximum) MATCHING is in $\\mathrm{P}$. One cannot be solved \"via\" the other in this direct sense.\nThe entire proposed reduction is based on incorrect graph-theoretic premises.\nVerdict on E: **Incorrect**.\n\nIn summary, statements B, C, and D are correct. B states the formal complexity conclusion, C gives the structural intuition for it, and D correctly describes a one-way structural implication between the two properties. All are correct statements pertaining to the problem.", "answer": "$$\\boxed{BCD}$$", "id": "3222980"}, {"introduction": "After seeing why some reductions are impossible, let's dissect a classic example of one that works: the reduction from 3-SAT to the directed Hamiltonian Path problem. The genius of a polynomial-time reduction lies in its intricate construction, where every component is essential for preserving the problem's logical integrity. This practice challenges you to act as a proof-checker by analyzing a seemingly clever 'optimization' to the standard construction, forcing you to pinpoint the subtle but critical flaw it introduces [@problem_id:1442713].", "problem": "In the study of computational complexity, polynomial-time reductions are a cornerstone for proving that a problem is NP-complete. A classic example is the reduction from the 3-Satisfiability problem (3-SAT) to the directed Hamiltonian Path problem (HAM-PATH).\n\nConsider the standard textbook reduction from 3-SAT to HAM-PATH. Given a 3-CNF formula $\\phi$ with $n$ variables $x_1, \\dots, x_n$ and $m$ clauses $c_1, \\dots, c_m$, a directed graph $G$ is constructed as follows:\n\n1.  **Variable Gadgets**: For each variable $x_i$, a \"diamond-like\" structure is created between a pair of nodes, $a_i$ and $b_i$. This structure contains two distinct, parallel paths of internal nodes from $a_i$ to $b_i$. A traversal of the first path (the 'true' path) corresponds to assigning the value true to $x_i$, while a traversal of the second path (the 'false' path) corresponds to assigning it the value false. These variable gadgets are then linked in series by adding directed edges from $b_i$ to $a_{i+1}$ for $i=1, \\dots, n-1$. A global start node $s$ is connected to $a_1$, and a global end node $t$ receives an edge from $b_n$.\n\n2.  **Clause Gadgets**: For each clause $c_j$, a single node, also denoted as $c_j$, is added to the graph.\n\n3.  **Connecting Edges**: For each clause $c_j$, edges are added to allow \"detours\" from the variable gadgets. If the literal $x_i$ (the variable $x_i$ unnegated) appears in $c_j$, a pair of edges is added allowing a path to divert from an intermediate node on the 'true' path of the $x_i$ gadget, visit the node $c_j$, and return to the next node on that same 'true' path. If the literal $\\neg x_i$ appears in $c_j$, a similar pair of detour edges is added, but connecting to the 'false' path of the $x_i$ gadget instead. A Hamiltonian path from $s$ to $t$ must visit every variable gadget and every clause node exactly once.\n\nThis standard construction correctly ensures that the graph $G$ has a Hamiltonian path from $s$ to $t$ if and only if the formula $\\phi$ is satisfiable.\n\nNow, consider a proposed modification to this reduction. To reduce the number of nodes in the graph, an engineer suggests merging the nodes for two distinct clauses, say $c_k$ and $c_l$, into a single shared node, which we can call $c_{kl}$. All the connecting edges that would have originally gone to or from the individual nodes $c_k$ and $c_l$ are now redirected to this new merged node $c_{kl}$. So, for any literal in either $c_k$ or $c_l$, a detour is created to and from $c_{kl}$.\n\nWhich of the following statements correctly analyzes the primary logical flaw introduced by this modification?\n\nA. The reduction remains correct. The total number of nodes is reduced, but the satisfiability equivalence is preserved.\n\nB. The reduction fails because a satisfiable formula could now result in a graph with no Hamiltonian path. This is known as a 'false negative'.\n\nC. The reduction fails because an unsatisfiable formula could now result in a graph with a Hamiltonian path. This is known as a 'false positive'.\n\nD. The reduction fails because merging clause nodes corresponding to clauses with no common variables will disconnect the graph, making a Hamiltonian path impossible regardless of the formula.\n\nE. The reduction becomes computationally intractable because checking for Hamiltonian paths in the modified graph is exponentially harder than in the graph from the standard reduction.", "solution": "Define the standard invariant of the reduction from 3-SAT to directed HAM-PATH: the constructed graph $G$ has a Hamiltonian path from $s$ to $t$ if and only if the 3-CNF formula $\\phi$ is satisfiable. The correctness relies on two key properties.\n\nFirst, for each variable $x_{i}$, the variable gadget forces the Hamiltonian path to choose exactly one of two disjoint directed tracks from $a_{i}$ to $b_{i}$: the 'true' track encodes $x_{i}=\\text{true}$ and the 'false' track encodes $x_{i}=\\text{false}$. Thus, any Hamiltonian path induces a consistent truth assignment.\n\nSecond, for each clause $c_{j}$, there is a distinct clause node (also denoted $c_{j}$), and the only way to visit $c_{j}$ while maintaining Hamiltonicity is to take exactly one detour from a variable gadget’s chosen track corresponding to a literal that appears in $c_{j}$. If a clause $c_{j}$ is satisfied by the induced assignment, at least one such detour is available along the chosen track(s), so $c_{j}$ can be visited exactly once. If $c_{j}$ is not satisfied by the induced assignment, then all detours leading to $c_{j}$ come from the tracks not chosen by the path, and thus $c_{j}$ cannot be visited without violating Hamiltonicity. Therefore, in the standard construction, visiting all distinct clause nodes exactly once is equivalent to satisfying all clauses.\n\nNow consider the modification that merges two distinct clause nodes $c_{k}$ and $c_{l}$ into a single node $c_{kl}$. All detour edges that previously targeted either $c_{k}$ or $c_{l}$ now target $c_{kl}$. Analyze the logical effect:\n\n- In the standard construction, the path must visit $c_{k}$ and $c_{l}$ separately, so both $c_{k}$ and $c_{l}$ must be individually satisfiable under the chosen assignment. This enforces a logical conjunction: both clauses must be satisfied.\n- After merging, there is only one node $c_{kl}$ to visit exactly once. The path can visit $c_{kl}$ by taking any one available detour corresponding to a literal from either $c_{k}$ or $c_{l}$ along the chosen tracks. Because a Hamiltonian path cannot visit $c_{kl}$ twice, at most one of those detours can be used. Thus, the requirement to visit two separate clause nodes has been weakened to visiting a single node, which can be achieved if at least one of $c_{k}$ or $c_{l}$ has a satisfied literal along the chosen tracks. This alters the logical condition from a conjunction to a disjunction: it suffices that at least one of the two clauses aligns with the chosen assignment to enable visiting the merged node.\n\nThis weakening creates false positives: there exist unsatisfiable formulas whose merged-graph instance admits a Hamiltonian path. A concrete counterexample demonstrates this.\n\nConsider $\\phi=(x_{1})\\land(\\neg x_{1})$, which is unsatisfiable. In the standard reduction, the path must choose either the 'true' track or the 'false' track for $x_{1}$. If the path chooses the 'true' track, it can detour to visit the clause node for $(x_{1})$, but it cannot visit the clause node for $(\\neg x_{1})$, since the detours to that node lie on the unchosen 'false' track. Symmetrically, choosing the 'false' track lets the path visit only the $(\\neg x_{1})$ clause node, not the $(x_{1})$ clause node. Hence there is no Hamiltonian path.\n\nAfter merging the two clause nodes into a single node $c_{12}$, the path that chooses the 'true' track can use the detour associated with $(x_{1})$ to visit $c_{12}$ once and still traverse all other vertices exactly once. The same holds if the path chooses the 'false' track, using the detour associated with $(\\neg x_{1})$. Therefore, in the merged graph, there exists a Hamiltonian path even though $\\phi$ is unsatisfiable. This is precisely a false positive: the modified reduction maps an unsatisfiable formula to a graph that has a Hamiltonian path.\n\nThus, the primary logical flaw is that merging clause nodes can make an unsatisfiable instance appear satisfiable in the graph, invalidating the reduction in the completeness direction.", "answer": "$$\\boxed{C}$$", "id": "1442713"}, {"introduction": "The boundary between tractable and intractable problems can be razor-thin, a prime example being the jump in complexity from $\\text{2-SAT}$, which is in $\\text{P}$, to $\\text{3-SAT}$, which is $\\text{NP}$-complete. This final exercise focuses on why we can't simply 'reduce away' the hardness of $\\text{3-SAT}$ by breaking down its clauses. By evaluating a hypothetical reduction from $\\text{3-SAT}$ to $\\text{2-SAT}$, you will uncover the unique implicational structure that makes $\\text{2-SAT}$ efficiently solvable and grasp why this powerful property does not extend to clauses with three or more literals [@problem_id:3222990].", "problem": "You are considering a hypothetical plan to reduce the problem $\\text{CNF\\text{-}SAT}$ to $\\text{2\\text{-}SAT}$ by replacing each clause of length $k\\ge 3$ with a conjunction of $2$-literal clauses augmented by a polynomial number of auxiliary variables and fixed-size gadgets, with the goal of preserving equisatisfiability. The plan claims that this clause-length reduction can be applied independently to each clause in a formula, yielding a polynomial-time many-one reduction.\n\nUsing only foundational definitions and facts of decision problems, complexity classes, and reductions, evaluate the following statements about why such an attempt fails and what structural property makes $\\text{2\\text{-}SAT}$ solvable in polynomial time. Select all statements that are correct.\n\n- A. Any equisatisfiable gadget-based transformation that replaces a clause of length $k\\ge 3$ by a polynomial-size conjunction of $2$-literal clauses implies a polynomial-time many-one reduction from $\\text{CNF\\text{-}SAT}$ to $\\text{2\\text{-}SAT}$. Since $\\text{2\\text{-}SAT}\\in \\text{P}$, this would yield $\\text{P}=\\text{NP}$.\n- B. The failure of these gadgets is tied to the implication-graph characterization of $\\text{2\\text{-}SAT}$: each $2$-clause $(x\\lor y)$ is equivalent to implications $(\\lnot x\\to y)$ and $(\\lnot y\\to x)$, and unsatisfiability arises if and only if some variable $v$ and $\\lnot v$ lie in the same strongly connected component. This implicational structure cannot enforce the $3$-way disjunction $(a\\lor b\\lor c)$ without introducing $3$-literal clauses.\n- C. $\\text{2\\text{-}SAT}$ is solvable in polynomial time because a $\\text{2\\text{-}CNF}$ formula is satisfiable if and only if the maximum matching in an associated undirected graph exceeds a certain threshold; computing this matching guarantees satisfiability.\n- D. It is possible to reduce $\\text{3\\text{-}SAT}$ to $\\text{2\\text{-}SAT}$ by replacing each $3$-clause $(a\\lor b\\lor c)$ with $(a\\lor z)\\land (b\\lor z)\\land (c\\lor z)\\land (\\lnot z)$ for a fresh variable $z$, preserving equisatisfiability.\n- E. The structural reason that $\\text{2\\text{-}SAT}$ is in $\\text{P}$ is that satisfiability reduces to reachability and strongly connected components in the directed implication graph, which can be decided in time $O(n+m)$ for $n$ variables and $m$ clauses.\n\nChoose all correct options.", "solution": "We proceed from foundational definitions and well-tested facts.\n\nFirst, recall the core definitions:\n- A decision problem $L$ is a subset of $\\{0,1\\}^\\star$ where each input $x$ has a yes/no answer. The class $\\text{Deterministic Polynomial time (P)}$ consists of decision problems decidable in time polynomial in the input size on a deterministic machine. The class $\\text{Nondeterministic Polynomial time (NP)}$ consists of decision problems whose yes-instances have certificates verifiable in polynomial time.\n- A polynomial-time many-one reduction from problem $A$ to problem $B$, denoted $A\\le_p B$, is a function $f$ computable in polynomial time such that for all inputs $x$, $x\\in A$ if and only if $f(x)\\in B$. If $A\\le_p B$ and $B\\in \\text{P}$, then $A\\in \\text{P}$.\n- The problem $\\text{CNF\\text{-}SAT}$ asks whether a Boolean formula in conjunctive normal form (CNF), with clauses of arbitrary length, is satisfiable. It is $\\text{NP}$-complete.\n- The problem $\\text{2\\text{-}SAT}$ is the restriction of satisfiability (SAT) to CNF formulas where every clause has exactly $2$ literals.\n\nA key structural property of $\\text{2\\text{-}SAT}$ is its implication-graph characterization. Each clause $(x\\lor y)$ is logically equivalent to two implications $(\\lnot x\\to y)$ and $(\\lnot y\\to x)$. Construct the directed graph whose vertices are the literals and whose edges are these implications. The formula is satisfiable if and only if, for every variable $v$, the literals $v$ and $\\lnot v$ do not lie in the same strongly connected component (SCC). This can be checked via linear-time algorithms for SCC, such as Kosaraju or Tarjan, giving an $O(n+m)$ time decision procedure for a formula with $n$ variables and $m$ clauses.\n\nWe now analyze the gadget attempt conceptually. The desired clause gadget for $(a_1\\lor a_2\\lor a_3\\lor \\cdots \\lor a_k)$ must be a conjunction $G$ of $2$-literal clauses (possibly with auxiliary variables) such that, for all assignments to the original variables, the clause $(a_1\\lor \\cdots \\lor a_k)$ is satisfied if and only if there exists an extension to the auxiliary variables satisfying $G$. If such gadgets existed of polynomial size and could be applied independently to all clauses, they would define a polynomial-time many-one reduction $f$ such that $\\Phi\\in \\text{CNF\\text{-}SAT}$ if and only if $f(\\Phi)\\in \\text{2\\text{-}SAT}$.\n\nHowever, $\\text{2\\text{-}SAT}$ constraints are purely implicational. Unsatisfiability of a $2$-CNF arises precisely from the presence of a directed cycle forcing a literal to imply its negation and vice versa, placing a variable and its negation in the same SCC. To enforce the semantics of a disjunction of three independent literals $(a\\lor b\\lor c)$—namely, ruling out only the single assignment $a=b=c=\\text{false}$ while allowing all others—the gadget must create a contradiction in the implication graph exactly when all three literals are false, and no contradiction otherwise. Because $2$-clauses only contribute binary implications, any contradiction in the implication graph among auxiliary literals that is triggered when all three originals are false will be a structural cycle among implications that does not inherently encode the dependence on all three being false without also introducing unintended contradictions under some assignment where one of $a,b,c$ is true. In effect, the restriction to binary implications cannot selectively forbid only the simultaneous falsity of three independent literals; encoding such a constraint requires at least one clause of arity $3$ or more. This limitation is a manifestation of the expressive boundary that places $\\text{2\\text{-}SAT}$ in $\\text{P}$ while $\\text{3\\text{-}SAT}$ is $\\text{NP}$-complete.\n\nWith these bases, we evaluate the options:\n\n- Option A: Any equisatisfiable gadget of polynomial size for a clause of length $k\\ge 3$, when applied clause-by-clause, yields a polynomial-time many-one reduction from $\\text{CNF\\text{-}SAT}$ to $\\text{2\\text{-}SAT}$. By the reduction definition, if $f$ is polynomial-time and preserves yes/no, and since $\\text{2\\text{-}SAT}\\in \\text{P}$, it follows that $\\text{CNF\\text{-}SAT}\\in \\text{P}$. Because $\\text{CNF\\text{-}SAT}$ is $\\text{NP}$-complete, this would imply $\\text{P}=\\text{NP}$. Verdict: Correct.\n\n- Option B: This statement correctly identifies the implication-graph structure and SCC criterion for $\\text{2\\text{-}SAT}$. It also correctly asserts that this structure cannot enforce the $3$-way disjunction $(a\\lor b\\lor c)$ without resorting to $3$-literal clauses. The reason is that $2$-clauses yield only binary implications; creating a contradiction in the implication graph precisely conditioned on three independent literals being simultaneously false requires arity beyond $2$. Verdict: Correct.\n\n- Option C: This claims a matching-based characterization with a threshold for satisfiability. While graph matching is a powerful polynomial-time tool, $\\text{2\\text{-}SAT}$ does not reduce to checking a maximum matching size exceeding a threshold in an associated undirected graph; its standard and structurally faithful characterizations are via the directed implication graph and SCCs (or equivalently, via linear-time resolution or unit-propagation frameworks specific to $2$-CNF). There is no general matching threshold that characterizes $2$-CNF satisfiability. Verdict: Incorrect.\n\n- Option D: The proposed gadget $(a\\lor z)\\land (b\\lor z)\\land (c\\lor z)\\land (\\lnot z)$ does not preserve equisatisfiability. Substituting $z=\\text{false}$ (enforced by $(\\lnot z)$) simplifies $(a\\lor z)$ to $a$, $(b\\lor z)$ to $b$, and $(c\\lor z)$ to $c$, yielding $a\\land b\\land c$, which is strictly stronger than $(a\\lor b\\lor c)$. Assignments with exactly one of $a,b,c$ true would satisfy $(a\\lor b\\lor c)$ but would falsify $a\\land b\\land c$. Verdict: Incorrect.\n\n- Option E: This correctly states the structural reason for tractability: satisfiability reduces to reachability and strongly connected components in the directed implication graph, and SCC computation is linear-time in the size of the graph. For a formula with $n$ variables and $m$ clauses, the graph has $O(n)$ vertices and $O(m)$ edges, and the decision procedure runs in $O(n+m)$ time. Verdict: Correct.\n\nTherefore, the correct options are A, B, and E.", "answer": "$$\\boxed{ABE}$$", "id": "3222990"}]}