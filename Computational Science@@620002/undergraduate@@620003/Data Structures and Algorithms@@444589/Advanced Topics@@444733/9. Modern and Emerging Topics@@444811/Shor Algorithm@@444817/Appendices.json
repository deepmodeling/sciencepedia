{"hands_on_practices": [{"introduction": "The heart of Shor's algorithm lies in its ability to efficiently find the period of a modular exponentiation function, a task that is classically intractable for large numbers. Before we can appreciate the quantum speedup, it is essential to understand the underlying mathematical structure. This first exercise [@problem_id:1447896] grounds you in this core concept by asking you to find the period of a function manually, giving you a tangible feel for the periodic nature that the quantum computer exploits.", "problem": "Consider a function $f$ that maps non-negative integers to a finite set of integers, defined by the rule $f(x) = a^x \\pmod{N}$, where $a$ and $N$ are positive integers such that the greatest common divisor of $a$ and $N$ is 1. This function is periodic. The period, denoted by $r$, is the smallest positive integer for which $a^r \\equiv 1 \\pmod{N}$.\n\nFor the specific case where the base is $a=7$ and the modulus is $N=15$, determine the period $r$ of the function $f(x) = 7^x \\pmod{15}$ by direct computation.", "solution": "We are asked to find the period (multiplicative order) $r$ of $a=7$ modulo $N=15$, defined as the smallest positive integer $r$ such that $7^{r} \\equiv 1 \\pmod{15}$. Since $\\gcd(7,15)=1$, powers of $7$ modulo $15$ are well-defined in the multiplicative group modulo $15$. By Euler's theorem, $7^{\\varphi(15)} \\equiv 1 \\pmod{15}$, where $\\varphi(15)=\\varphi(3)\\varphi(5)=2 \\cdot 4 = 8$, so the order $r$ must divide $8$. We proceed by direct computation to find the smallest such $r$.\n\nCompute successive powers of $7$ modulo $15$ using the property that if $x \\equiv y \\pmod{15}$, then $7x \\equiv 7y \\pmod{15}$:\n\n$7^{1} \\equiv 7 \\pmod{15}$, which is not congruent to $1$.\n\n$7^{2} \\equiv 7 \\cdot 7 = 49 \\equiv 49 - 45 = 4 \\pmod{15}$, which is not congruent to $1$.\n\n$7^{3} \\equiv 7 \\cdot 7^{2} \\equiv 7 \\cdot 4 = 28 \\equiv 28 - 15 = 13 \\pmod{15}$, which is not congruent to $1$.\n\n$7^{4} \\equiv 7 \\cdot 7^{3} \\equiv 7 \\cdot 13 = 91 \\equiv 91 - 90 = 1 \\pmod{15}$.\n\nThus the smallest positive integer $r$ such that $7^{r} \\equiv 1 \\pmod{15}$ is $r=4$. This also aligns with the fact that the order must divide $8$, and we have verified that no smaller positive exponent among $1,2,3$ yields $1$ modulo $15$.", "answer": "$$\\boxed{4}$$", "id": "1447896"}, {"introduction": "The quantum part of Shor's algorithm provides a measurement that is a very good approximation of a fraction involving the period $r$. It does not, however, output $r$ directly. This is where classical computation takes over again, using a powerful mathematical tool to bridge the gap. In this practice [@problem_id:132580], you will use the continued fraction algorithm to process a simulated quantum measurement outcome and recover the true period, a critical step in the overall algorithm.", "problem": "In Shor's algorithm for factoring an integer $N$, a key subroutine involves finding the period, or order, $r$ of a chosen integer $a$ modulo $N$. The period $r$ is the smallest positive integer such that $a^r \\equiv 1 \\pmod N$. This is achieved by preparing a quantum state and performing a measurement, which results in an integer $s$ between $0$ and $Q-1$, where $Q=2^L$ is the size of a computational register. The measured value $s$ is related to the period $r$ by the approximation $\\frac{s}{Q} \\approx \\frac{k}{r}$ for some unknown integer $k$.\n\nTo find $r$ from this approximation, one can use the continued fraction algorithm. This algorithm finds a sequence of rational numbers, called convergents, that are successively better approximations to a given value. The denominators of these convergents are candidates for the period $r$.\n\nConsider an application of Shor's algorithm to factor the number $N=35$ using the base $a=13$. The quantum measurement part of the algorithm is performed with a register of size $Q=1024$. The measurement outcome yields the fraction $\\frac{s}{Q} = \\frac{192}{1024}$.\n\nYour task is to find the fundamental period $r$ of the function $f(x) = 13^x \\mod 35$. Use the continued fraction algorithm on the measured ratio $\\frac{s}{Q}$ to determine a set of candidate periods. By testing these candidates, identify the one that is a multiple of the true period, and from it, determine the fundamental period $r$.", "solution": "We are given the measurement ratio $\\frac{s}{Q} = \\frac{192}{1024}$, which simplifies to $\\frac{3}{16}$. The continued fraction algorithm is used to find denominators that are candidates for the period $r$.\n\n1.  **Find Candidate Periods from Convergents**: The continued fraction expansion of $\\frac{3}{16}$ is $[0; 5, 3]$. The denominators of its convergents, $\\frac{1}{5}$ and $\\frac{3}{16}$, give us the non-trivial candidates for the period: $r' = 5$ and $r' = 16$.\n\n2.  **Test the Candidates**: We check if $13^{r'} \\equiv 1 \\pmod{35}$ for each candidate.\n    - Test $r'=5$: $13^4 \\equiv 1 \\pmod{35}$, so $13^5 \\equiv 13 \\cdot 1 \\equiv 13 \\not\\equiv 1 \\pmod{35}$. This candidate is incorrect.\n    - Test $r'=16$: Since $13^4 \\equiv 1 \\pmod{35}$, we have $13^{16} = (13^4)^4 \\equiv 1^4 \\equiv 1 \\pmod{35}$. This confirms the true period $r$ must be a divisor of 16.\n\n3.  **Find the Fundamental Period**: We find the smallest positive divisor of 16 that is the period. We test the divisors {1, 2, 4, 8, 16}:\n    - $13^1 \\not\\equiv 1$, $13^2 \\equiv 29 \\not\\equiv 1$, but $13^4 \\equiv 1 \\pmod{35}$.\n    The smallest divisor that works is 4. Thus, the fundamental period is $r=4$.", "answer": "$$\\boxed{4}$$", "id": "132580"}, {"introduction": "To truly master the logic of Shor's algorithm, it is invaluable to build a working model of its classical components. This advanced practice [@problem_id:3256587] challenges you to write a program that emulates the entire classical workflow of the algorithm: from selecting a base to finding its order and finally using that order to compute factors. By implementing these number-theoretic subroutines from first principles, you will gain a deep, operational understanding of how period-finding unlocks factorization.", "problem": "You are asked to design and implement a fully deterministic, classical computation program that emulates the period-finding subroutine of Shor's algorithm to attempt factoring an integer. The aim is to probe number-theoretic algorithm design using modular arithmetic and variants of the Greatest Common Divisor (GCD). The program must operate solely on the basis of first principles and fundamental definitions in modular arithmetic, without using built-in number theory primitives.\n\nStarting point definitions and facts:\n- For a positive integer $N \\geq 2$, define the ring of integers modulo $N$, denoted $\\mathbb{Z}_N = \\{0,1,2,\\dots,N-1\\}$ with addition and multiplication performed modulo $N$.\n- The set of units modulo $N$, denoted $\\mathbb{Z}_N^\\times$, is the set of elements $a \\in \\mathbb{Z}_N$ such that $\\gcd(a,N) = 1$, where $\\gcd$ denotes the Greatest Common Divisor (GCD).\n- For $a \\in \\mathbb{Z}_N^\\times$, the multiplicative order of $a$ modulo $N$, denoted by $\\operatorname{ord}_N(a)$, is the smallest positive integer $r$ such that $a^r \\equiv 1 \\pmod{N}$.\n\nTask description:\n- For a given integer $N$, your program must deterministically select candidate bases $a$ with $1 < a < N$ and $\\gcd(a,N)$ computed via the Binary Greatest Common Divisor (Binary GCD) algorithm (also known as Stein's algorithm). No randomness is allowed; iterate $a$ in increasing order.\n- For each candidate $a$ with $\\gcd(a,N)=1$, compute the multiplicative order $r = \\operatorname{ord}_N(a)$ using only modular arithmetic from first principles. Implement modular exponentiation via repeated squaring to efficiently compute powers modulo $N$.\n- Based on first-principles reasoning, derive and apply conditions under which the discovered period $r$ can be used to obtain nontrivial factors of $N$ using only integer arithmetic and GCD computations. If a nontrivial factor is discovered, stop and output a factor pair.\n- If a nontrivial factor is obtained for some $a$, output a list containing the two factors in nondecreasing order. If no such $a$ succeeds, output the trivial pair $[1,N]$.\n\nAlgorithmic constraints:\n- You must implement the Binary GCD algorithm to compute $\\gcd(x,y)$ and must not use any built-in Euclidean algorithm or greatest common divisor function.\n- You must implement modular exponentiation by repeated squaring and must not use any built-in modular exponentiation function (e.g., no usage of a built-in $a^b \\bmod N$ operator).\n- You must not use any random number generator; the selection of $a$ must be purely deterministic.\n- You must base the program only on the above definitions and widely accepted facts from modular arithmetic. No external number theory library calls are permitted.\n\nInput and units:\n- There is no external input. No physical units or angles are involved; all values are integers in $\\mathbb{Z}$.\n\nTest suite:\n- Your program must internally evaluate the following eight test cases, in order, with values of $N$:\n  - $N = 15$\n  - $N = 21$\n  - $N = 33$\n  - $N = 35$\n  - $N = 91$\n  - $N = 16$\n  - $N = 13$\n  - $N = 2$\n\nOutput specification:\n- For each $N$, produce one list $[p,q]$ of integers representing a factor pair in nondecreasing order. For cases where no nontrivial factor is found, output $[1,N]$.\n- Your program should produce a single line of output containing the results for all test cases, aggregated as a comma-separated list of these lists with no spaces, enclosed in square brackets. For example, the output must look like\n  $$[[p_1,q_1],[p_2,q_2],\\dots,[p_8,q_8]]$$\n  where each $[p_i,q_i]$ corresponds to the factor pair for the $i$-th $N$ in the test suite, in order.", "solution": "The problem requires the design and implementation of a deterministic, classical algorithm that emulates the core logic of Shor's algorithm to find factors of an integer $N$. This involves number-theoretic concepts, specifically modular arithmetic and the greatest common divisor (GCD). The solution is constructed from first principles as specified.\n\nThe core idea is to find a non-trivial square root of $1$ in the ring of integers modulo $N$, denoted $\\mathbb{Z}_N$. A non-trivial square root of $1$ is an integer $x$ such that $x^2 \\equiv 1 \\pmod{N}$ but $x \\not\\equiv \\pm 1 \\pmod{N}$. If such an $x$ can be found, then $x^2 - 1 = (x-1)(x+1)$ is a multiple of $N$. Since $x \\not\\equiv \\pm 1 \\pmod{N}$, neither $(x-1)$ nor $(x+1)$ is a multiple of $N$. This implies that the factors of $N$ must be split between $(x-1)$ and $(x+1)$. Consequently, computing $\\gcd(x-1, N)$ will yield a non-trivial factor of $N$.\n\nThe algorithm to find such an $x$ proceeds as follows:\nFor a given integer $N \\geq 2$ to be factored, we deterministically iterate through candidate bases $a$ in the range $1 < a < N$. For each $a$, we first compute $g = \\gcd(a, N)$. If $g > 1$, we have found a non-trivial factor of $N$, and the algorithm terminates, returning the factor pair $[g, N/g]$. As per the problem constraints, this GCD computation must be performed using the Binary GCD algorithm (Stein's algorithm), which operates using bitwise shifts, comparisons, and subtractions, avoiding division.\n\nIf $\\gcd(a, N) = 1$, then $a$ is an element of the multiplicative group of integers modulo $N$, denoted $\\mathbb{Z}_N^\\times$. We then compute the multiplicative order of $a$ modulo $N$, which is the smallest positive integer $r$ such that $a^r \\equiv 1 \\pmod{N}$. This is found by sequentially computing $a^1, a^2, a^3, \\dots$ modulo $N$ until the result is $1$. Let this be `power = (power * a) % N`.\n\nOnce the order $r$ is found, we check if it can be used to find a factor. This occurs if two conditions are met:\n1.  The order $r$ must be an even number.\n2.  The value of $a^{r/2} \\pmod{N}$ must not be equal to $-1 \\pmod{N}$ (which is $N-1$).\n\nIf $r$ is even, we can set $x = a^{r/2}$. The relation $a^r \\equiv 1 \\pmod{N}$ becomes $x^2 \\equiv 1 \\pmod{N}$. By the definition of order, $r$ is the *smallest* positive integer for which $a^r \\equiv 1 \\pmod{N}$, so $x = a^{r/2} \\not\\equiv 1 \\pmod{N}$. If we are also \"lucky\" enough that $x \\not\\equiv -1 \\pmod{N}$, then $x$ is a non-trivial square root of $1$ modulo $N$. We can then find a non-trivial factor $p$ by computing $p = \\gcd(x-1, N)$. The other factor is $q = N/p$. The algorithm then terminates and returns the sorted factor pair $[p, q]$.\n\nThe computation of powers $a^k \\pmod{N}$, specifically for $x=a^{r/2}$, is required to be implemented using modular exponentiation by repeated squaring. This is an efficient algorithm that computes $a^k \\pmod{N}$ in $O(\\log k)$ time.\n\nIf for a given $a$, either $r$ is odd or $a^{r/2} \\equiv -1 \\pmod{N}$, that choice of $a$ fails to produce a factor, and the algorithm proceeds to the next candidate $a$. If the loop over all possible values of $a$ from $2$ to $N-1$ completes without finding any non-trivial factors, the algorithm concludes that $N$ is likely prime (or the method failed for the composite $N$) and returns the trivial factor pair $[1, N]$.\n\nThis entire procedure is deterministic. The main steps encapsulated in the program are:\n1.  An outer loop iterating through test cases $N$.\n2.  An inner function that takes $N$ and iterates through bases $a$ from $2$ to $N-1$.\n3.  A custom implementation of the Binary GCD algorithm.\n4.  A custom implementation of modular exponentiation by repeated squaring.\n5.  Logic within the loop over $a$ to test $\\gcd(a,N)$, find the order $r$, and apply the factoring conditions based on $r$.\n\nThe solution for each of the specified test cases ($N \\in \\{15, 21, 33, 35, 91, 16, 13, 2\\}$) is derived by applying this deterministic algorithm.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It orchestrates the factorization for each N and prints the final result.\n    \"\"\"\n\n    def binary_gcd(u, v):\n        \"\"\"\n        Computes the greatest common divisor of two non-negative integers u and v\n        using the Binary GCD algorithm (Stein's algorithm).\n        \"\"\"\n        u, v = abs(u), abs(v)\n        if u == 0:\n            return v\n        if v == 0:\n            return u\n\n        # Find k, the greatest power of 2 that divides both u and v.\n        shift = 0\n        while ((u | v)  1) == 0:\n            u >>= 1\n            v >>= 1\n            shift += 1\n\n        # From here on, u is always odd.\n        while (u  1) == 0:\n            u >>= 1\n\n        while v != 0:\n            # v can be even, so remove all factors of 2.\n            while (v  1) == 0:\n                v >>= 1\n\n            # Now both u and v are odd. Swap if necessary so u = v.\n            if u > v:\n                u, v = v, u\n            \n            # v is now guaranteed to be v' >= u', and v' - u' is even.\n            v = v - u\n        \n        # Restore the common factors of 2.\n        return u  shift\n\n    def mod_exp(base, exp, mod):\n        \"\"\"\n        Computes (base^exp) % mod using the method of repeated squaring.\n        \"\"\"\n        result = 1\n        base %= mod\n        while exp > 0:\n            if exp % 2 == 1:\n                result = (result * base) % mod\n            exp >>= 1\n            base = (base * base) % mod\n        return result\n\n    def factor_shor_emulator(N):\n        \"\"\"\n        Performs factorization of N using a deterministic classical emulation\n        of Shor's algorithm's period-finding subroutine.\n        \"\"\"\n        if N = 1:\n            # Problem statement implies N >= 2, but handle defensively.\n            return [1, N]\n        if N % 2 == 0:\n            # If N is even, the first choice of a=2 will have gcd(2,N)=2.\n            # Except if N=2 itself, where the loop range is empty.\n            if N == 2:\n                return [1, 2]\n            return [2, N // 2]\n\n        # Iterate through candidate bases a deterministically.\n        for a in range(2, N):\n            # Step 1: Check for a trivial factor using GCD.\n            g = binary_gcd(a, N)\n            if g > 1:\n                p = g\n                q = N // p\n                return sorted([p, q])\n\n            # Step 2: If gcd(a, N) = 1, find the order r of a modulo N.\n            # We find the order using simple repeated multiplication.\n            power = a\n            r = 1\n            while power != 1:\n                power = (power * a) % N\n                r += 1\n\n            # Step 3: Use the order r to find factors.\n            # This is possible if r is even and a^(r/2) is not -1 mod N.\n            if r % 2 == 0:\n                x = mod_exp(a, r // 2, N)\n                if x != (N - 1):\n                    # Found a non-trivial square root of 1.\n                    p = binary_gcd(x - 1, N)\n                    q = N // p\n                    return sorted([p, q])\n\n        # If the loop completes without finding factors, return the trivial pair.\n        return [1, N]\n\n    # Define the test cases from the problem statement.\n    test_cases = [15, 21, 33, 35, 91, 16, 13, 2]\n\n    results = []\n    for N in test_cases:\n        result = factor_shor_emulator(N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[3, 5],[3, 7],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3256587"}]}