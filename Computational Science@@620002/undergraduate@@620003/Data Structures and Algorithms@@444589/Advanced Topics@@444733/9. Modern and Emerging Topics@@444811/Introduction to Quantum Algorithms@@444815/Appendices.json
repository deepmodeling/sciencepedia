{"hands_on_practices": [{"introduction": "Before diving into the intricacies of quantum algorithms, it's crucial to understand *why* we need quantum computers in the first place. This first exercise provides a powerful motivation by quantifying the challenge of simulating quantum systems on classical hardware. By calculating the memory required to store the state of even a modest number of qubits, you will gain a tangible appreciation for the exponential nature of quantum state space and the 'exponential wall' that limits classical approaches [@problem_id:3242197].", "problem": "Consider simulating a pure state of an $n$-qubit register on a classical computer. A pure state is a unit vector in a complex Hilbert space of dimension $2^{n}$, and in the computational basis it can be written as a column vector of $2^{n}$ complex probability amplitudes. To store this state vector exactly on a classical machine, you record each complex amplitude as two real-valued floating-point numbers of $b$ bytes each. Assume double precision, so $b = 8$.\n\nYou are given a machine with Random Access Memory (RAM) capacity $M = 256 \\times 2^{30}$ bytes (that is, $256$ gibibytes expressed in bytes). Ignore any additional overhead and assume the memory can be entirely devoted to storing the state vector.\n\nStarting only from the definition that the state space dimension is $2^{n}$ for $n$ qubits and that each complex amplitude consists of two real numbers, derive:\n\n- An expression, as a function of $n$, for the total number of real-valued floating-point numbers required to store the full state vector.\n- The maximum integer number of qubits $n$ such that the exact state vector fits in the given RAM.\n\nProvide your final answer as a row matrix, with the first entry being the expression for the number of floating-point numbers as a function of $n$, and the second entry being the maximum $n$ that fits under the memory constraint. No rounding is needed.", "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded, well-posed, objective, and contains all necessary information to derive a unique solution.\n\nThe problem asks for two quantities: first, an expression for the total number of real-valued floating-point numbers needed to store the state vector of an $n$-qubit system, and second, the maximum integer number of qubits, $n$, that can be simulated given a specific memory capacity.\n\nLet's begin by deriving the expression for the number of floating-point numbers.\nA pure quantum state of an $n$-qubit register is described by a state vector $|\\psi\\rangle$ in a complex Hilbert space $\\mathcal{H}$. The dimension of this space, $D$, is given by $D = 2^n$. This is because each of the $n$ qubits has a $2$-dimensional state space, and the state space of the composite system is the tensor product of the individual spaces, so the dimension is $2 \\times 2 \\times \\dots \\times 2$ ($n$ times), which equals $2^n$.\n\nIn the computational basis, the state vector $|\\psi\\rangle$ is represented as a linear combination of the $2^n$ basis vectors:\n$$|\\psi\\rangle = \\sum_{k=0}^{2^n - 1} c_k |k\\rangle$$\nwhere the coefficients $c_k$ are complex numbers known as probability amplitudes. The state is fully specified by the set of these $2^n$ complex amplitudes.\n\nTo store this state vector on a classical computer, we must store each of these $2^n$ complex numbers. A complex number $c_k$ can be written as $c_k = a_k + i b_k$, where $a_k$ and $b_k$ are real numbers representing the real and imaginary parts, respectively. The problem states that each complex amplitude is stored as two real-valued floating-point numbers.\n\nLet $N_{fp}(n)$ be the total number of real-valued floating-point numbers required. This is the product of the number of complex amplitudes and the number of real numbers required per complex amplitude.\n$$N_{fp}(n) = (\\text{Number of complex amplitudes}) \\times (\\text{Real numbers per complex amplitude})$$\nThe number of complex amplitudes is the dimension of the state space, which is $2^n$. The number of real numbers per complex amplitude is given as $2$.\nTherefore, the expression for the total number of floating-point numbers as a function of $n$ is:\n$$N_{fp}(n) = 2^n \\times 2 = 2^{n+1}$$\n\nNext, we determine the maximum integer number of qubits, $n_{max}$, that can be stored in the given RAM.\nThe total memory size required to store the state vector, let's call it $S(n)$, is the total number of floating-point numbers multiplied by the memory size of each number.\nThe problem specifies that each floating-point number is of size $b=8$ bytes (double precision).\nSo, the total memory required in bytes is:\n$$S(n) = N_{fp}(n) \\times b = 2^{n+1} \\times 8$$\nSince $8 = 2^3$, we can express $S(n)$ as a single power of $2$:\n$$S(n) = 2^{n+1} \\times 2^3 = 2^{n+4} \\text{ bytes}$$\nThe available RAM capacity is given as $M = 256 \\times 2^{30}$ bytes. We need to express $M$ as a power of $2$ for easier comparison. The number $256$ is $2^8$.\n$$M = 256 \\times 2^{30} = 2^8 \\times 2^{30} = 2^{38} \\text{ bytes}$$\nTo find the maximum number of qubits $n$, we must find the largest integer $n$ for which the required memory $S(n)$ does not exceed the available memory $M$. This can be expressed as the inequality:\n$$S(n) \\le M$$\nSubstituting the expressions for $S(n)$ and $M$:\n$$2^{n+4} \\le 2^{38}$$\nSince the base of the exponential function, $2$, is greater than $1$, the inequality holds for the exponents as well:\n$$n+4 \\le 38$$\nSolving for $n$:\n$$n \\le 38 - 4$$\n$$n \\le 34$$\nSince $n$ must be an integer, the maximum number of qubits that can be simulated under the given memory constraint is $n_{max} = 34$.\n\nThe two results are:\n1. The expression for the number of floating-point numbers is $2^{n+1}$.\n2. The maximum integer number of qubits is $34$.", "answer": "$$\\boxed{\\begin{pmatrix} 2^{n+1} & 34 \\end{pmatrix}}$$", "id": "3242197"}, {"introduction": "Having seen the immense scale of a quantum state vector, let's now explore the mechanics of how it evolves. This practice challenges you to build a classical simulator for a small quantum circuit, translating the abstract principles of quantum gates into concrete code [@problem_id:3242157]. By implementing the matrix-vector operations that define single-qubit and two-qubit gates, you will demystify the process of quantum computation and gain an intuitive feel for how states of superposition and entanglement are created and manipulated.", "problem": "Design and implement a classical state-vector simulator for a quantum circuit on exactly $3$ qubits using explicit matrix-vector multiplication on the complex state vector. The computational basis is $\\{\\lvert 000\\rangle,\\lvert 001\\rangle,\\ldots,\\lvert 111\\rangle\\}$, and a pure state on $n$ qubits is represented as a complex vector in $\\mathbb{C}^{2^n}$ with $\\ell_2$-norm equal to $1$. A single-qubit gate acting on qubit index $t$ (where the least significant bit is qubit index $0$) is represented by a $2\\times 2$ unitary matrix $U$ extended to the whole register by the Kronecker product with identities, and applied to the state by a matrix-vector product. A two-qubit controlled-NOT gate (control $c$, target $t$) permutes amplitudes as a linear operation that can also be realized by appropriate index swaps.\n\nFundamental base to use:\n- The state-update rule is linear: if a gate with matrix $G$ acts on the register, then the new state is $G\\psi$, where $\\psi\\in\\mathbb{C}^{2^n}$ is the current state.\n- The computational basis state $\\lvert q_{n-1}\\ldots q_1 q_0\\rangle$ corresponds to the integer index $\\sum_{k=0}^{n-1} q_k 2^k$ in little-endian order, where $q_k\\in\\{0,1\\}$.\n- Single-qubit gates act locally as $2\\times 2$ matrix-vector multiplications over disjoint pairs of amplitudes that differ only in the target qubit.\n\nYour tasks:\n1. Implement a simulator that:\n   - Initializes the state to $\\lvert 000\\rangle$.\n   - Applies a sequence of gates specified as a circuit description. The supported gates are the Hadamard gate $H=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 & 1\\\\ 1 & -1\\end{pmatrix}$ on a specified qubit, the Pauli $X$ gate $X=\\begin{pmatrix}0 & 1\\\\ 1 & 0\\end{pmatrix}$ on a specified qubit, and the controlled-NOT gate on specified control and target qubits $(\\mathrm{CNOT}(c\\to t))$.\n   - Uses explicit matrix-vector multiplication semantics for single-qubit gates by updating each affected two-amplitude pair $\\begin{pmatrix}\\alpha\\\\ \\beta\\end{pmatrix}\\mapsto U\\begin{pmatrix}\\alpha\\\\ \\beta\\end{pmatrix}$.\n   - For $\\mathrm{CNOT}(c\\to t)$, updates amplitudes by swapping those basis indices where the control bit is $1$ and the target bit is $0$ with their counterparts where the target bit is $1$.\n2. Count primitive arithmetic operations performed by your implementation under the following uniform cost model:\n   - For each application of a single-qubit gate on $n$ qubits, count $4\\cdot 2^{n-1}$ complex multiplications and $2\\cdot 2^{n-1}$ complex additions.\n   - For each application of a controlled-NOT on $n$ qubits, count $3\\cdot 2^{n-2}$ scalar assignments due to swaps. Treat each swap as $3$ assignments.\n   - Report these counts accumulated over the whole circuit.\n3. For each test case below, compute the probability of measuring the basis state $\\lvert 111\\rangle$ from the final state, which is the squared magnitude of the amplitude at index $7$ (in little-endian indexing as specified above).\n\nTest suite:\n- Case A (edge case, empty circuit): $n=3$, circuit depth $d=0$, no gates. Query probability of $\\lvert 111\\rangle$.\n- Case B (uniform superposition): $n=3$, apply $H$ on qubits $0$, $1$, and $2$ in that order. Query probability of $\\lvert 111\\rangle$.\n- Case C (entangling to a Greenberger–Horne–Zeilinger state): $n=3$, apply $H$ on qubit $0$, then $\\mathrm{CNOT}(0\\to 1)$, then $\\mathrm{CNOT}(1\\to 2)$. Query probability of $\\lvert 111\\rangle$.\n- Case D (cancellation by involution): $n=3$, apply $X$ on qubit $2$ twice. Query probability of $\\lvert 111\\rangle$.\n\nAnswer specification and final output format:\n- For each test case, your program must produce a list with six entries in this exact order:\n  - The probability of $\\lvert 111\\rangle$ as a real number.\n  - The total number of complex multiplications counted.\n  - The total number of complex additions counted.\n  - The total number of scalar assignments due to swaps counted.\n  - The number of qubits $n$ used.\n  - The circuit depth $d$ (the number of gates in the circuit).\n- Aggregate the four per-case lists into a single list. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, in the shape $[\\text{caseA},\\text{caseB},\\text{caseC},\\text{caseD}]$, where each case is itself a list as defined above.\n\nYour analysis goal:\n- From first principles, derive the asymptotic runtime as a function of the number of qubits $n$ and the circuit depth $d$ under the stated cost model, without assuming any outcome. Interpret the per-case counts to justify an exponential dependence in $n$ and linear dependence in $d$ for circuits composed of $O(1)$-qubit gates. Do not provide shortcut formulas in the problem statement; show your reasoning in the solution. No physical units or angles are involved. All angles, if any, would be in radians, but none are used here.", "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded in the principles of quantum computation, well-posed with a clear objective and sufficient data, and free from ambiguity or contradiction. We may proceed with the solution.\n\nThe task is to design a classical state-vector simulator for a $3$-qubit quantum system and analyze its performance for specific circuits. The simulation proceeds by explicitly updating a complex vector representing the quantum state.\n\nA pure quantum state of $n$ qubits is represented by a state vector $\\psi$ in a complex Hilbert space of dimension $2^n$, i.e., $\\psi \\in \\mathbb{C}^{2^n}$. The vector is normalized such that its $\\ell_2$-norm is $1$, $\\|\\psi\\|_2 = 1$. The computational basis states are denoted by $\\lvert q_{n-1} \\ldots q_1 q_0 \\rangle$, where each $q_k \\in \\{0, 1\\}$. The problem specifies a little-endian mapping from these basis states to the indices of the state vector $\\psi$. The basis state $\\lvert q_{n-1} \\ldots q_1 q_0 \\rangle$ corresponds to the integer index $i = \\sum_{k=0}^{n-1} q_k 2^k$. For our case of $n=3$, the state vector $\\psi$ has $2^3 = 8$ complex components, indexed from $0$ to $7$. The basis state $\\lvert q_2 q_1 q_0 \\rangle$ maps to index $i = 4q_2 + 2q_1 + q_0$. The initial state is specified as $\\lvert 000 \\rangle$, which corresponds to index $0$. The initial state vector is therefore $\\psi_{initial} = [1, 0, 0, 0, 0, 0, 0, 0]^T$.\n\nThe evolution of the state under a quantum gate with matrix representation $G$ is given by the matrix-vector product $\\psi' = G\\psi$. For an $n$-qubit system, $G$ is a $2^n \\times 2^n$ unitary matrix. We implement the gate applications as specified.\n\nThe cost of simulation is measured by counting primitive arithmetic operations according to the provided uniform cost model:\n- For a single-qubit gate on $n$ qubits: $4 \\cdot 2^{n-1}$ complex multiplications and $2 \\cdot 2^{n-1}$ complex additions.\n- For a $\\mathrm{CNOT}$ gate on $n$ qubits: $3 \\cdot 2^{n-2}$ scalar assignments.\n\nThe probability of measuring a specific basis state, e.g., $\\lvert 111 \\rangle$ (which corresponds to index $i=7$), is given by the squared magnitude of the corresponding amplitude in the final state vector: $P(\\lvert 111 \\rangle) = |\\psi_{final}[7]|^2$.\n\n**Single-Qubit Gate Application**\nA single-qubit gate with matrix $U = \\begin{pmatrix} U_{00} & U_{01} \\\\ U_{10} & U_{11} \\end{pmatrix}$ acting on qubit $t$ is represented by the $2^n \\times 2^n$ matrix $G = I^{\\otimes(n-1-t)} \\otimes U \\otimes I^{\\otimes t}$. Applying this large matrix directly is inefficient. Instead, we use the specified local update rule. The gate only affects pairs of amplitudes corresponding to basis states that differ only in qubit $t$.\nFor each integer index $i$ from $0$ to $2^n-1$ where the $t$-th bit is $0$, we find its paired index $j = i + 2^t$, where the $t$-th bit is $1$. The amplitudes at these indices, $\\psi_i$ and $\\psi_j$, are updated according to the $2 \\times 2$ matrix $U$:\n$$\n\\begin{pmatrix} \\psi'_i \\\\ \\psi'_j \\end{pmatrix} = \\begin{pmatrix} U_{00} & U_{01} \\\\ U_{10} & U_{11} \\end{pmatrix} \\begin{pmatrix} \\psi_i \\\\ \\psi_j \\end{pmatrix} = \\begin{pmatrix} U_{00}\\psi_i + U_{01}\\psi_j \\\\ U_{10}\\psi_i + U_{11}\\psi_j \\end{pmatrix}\n$$\nThere are $2^{n-1}$ such pairs of indices. The update for each pair requires $4$ complex multiplications and $2$ complex additions. This gives a total of $4 \\cdot 2^{n-1}$ complex multiplications and $2 \\cdot 2^{n-1}$ complex additions per single-qubit gate application, perfectly matching the specified cost model. For $n=3$, this is $4 \\cdot 2^2 = 16$ multiplications and $2 \\cdot 2^2 = 8$ additions.\n\nThe specific single-qubit gates are the Hadamard gate $H = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 & 1 \\\\ 1 & -1 \\end{pmatrix}$ and the Pauli-X gate $X = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}$.\n\n**Controlled-NOT (CNOT) Gate Application**\nThe $\\mathrm{CNOT}(c \\to t)$ gate flips the target qubit $t$ if and only if the control qubit $c$ is $1$. In the computational basis, this translates to a permutation: $\\mathrm{CNOT} \\lvert \\dots q_c \\dots q_t \\dots \\rangle = \\lvert \\dots q_c \\dots (q_t \\oplus q_c) \\dots \\rangle$. This only has an effect when $q_c=1$. Therefore, the operation swaps the amplitudes of basis states $\\lvert \\dots 1_c \\dots 0_t \\dots \\rangle$ and $\\lvert \\dots 1_c \\dots 1_t \\dots \\rangle$.\nIn terms of state vector indices, we must identify all indices $i$ that have the $c$-th bit set to $1$ and the $t$-th bit set to $0$. For each such $i$, the corresponding index $j$ is $i + 2^t$. The simulation then swaps the amplitudes $\\psi_i$ and $\\psi_j$. The number of such pairs to swap is the number of ways to choose the remaining $n-2$ bits, which is $2^{n-2}$. For $n=3$, this is $2^{3-2}=2$ pairs.\nThe cost model specifies that a swap requires $3$ scalar assignments. Thus, a $\\mathrm{CNOT}$ gate costs $3 \\cdot 2^{n-2}$ assignments. For $n=3$, this is $3 \\cdot 2^1 = 6$ assignments.\n\n**Asymptotic Runtime Analysis**\nThe state vector has a size of $N=2^n$. The cost of applying a single-qubit gate is $O(2^n)$. The cost of applying a two-qubit $\\mathrm{CNOT}$ gate is also $O(2^n)$. In general, simulating any gate acting on a constant number of qubits, $k$, requires updating tuples of $2^k$ amplitudes, across $2^{n-k}$ such tuples, leading to a computational cost of $O(2^n)$.\nFor a circuit with depth $d$ (here interpreted as total number of gates), the total simulation cost is the sum of costs for each gate. This results in a total runtime of $O(d \\cdot 2^n)$. This confirms the expected exponential dependence on the number of qubits $n$ and linear dependence on the circuit depth $d$.\n\n**Test Case Analysis**\n\n**Case A: Empty Circuit**\n- Circuit: None. $n=3$, $d=0$.\n- Initial state: $\\psi = \\lvert 000 \\rangle = [1, 0, 0, 0, 0, 0, 0, 0]^T$.\n- Final state: Unchanged, $\\psi_{final} = [1, 0, 0, 0, 0, 0, 0, 0]^T$.\n- Probability of $\\lvert 111 \\rangle$: $P(\\lvert 111 \\rangle) = |\\psi_{final}[7]|^2 = |0|^2 = 0$.\n- Operation Counts: No gates are applied.\n  - Complex multiplications: $0$.\n  - Complex additions: $0$.\n  - Swap assignments: $0$.\n- Result: $[0.0, 0, 0, 0, 3, 0]$.\n\n**Case B: Uniform Superposition**\n- Circuit: $H$ on qubit $0$, then $H$ on qubit $1$, then $H$ on qubit $2$. $n=3$, $d=3$.\n- State evolution:\n  - $\\psi_0 = \\lvert 000 \\rangle$.\n  - $\\psi_1 = H_0 \\psi_0 = \\frac{1}{\\sqrt{2}}(\\lvert 000 \\rangle + \\lvert 001 \\rangle)$.\n  - $\\psi_2 = H_1 \\psi_1 = \\frac{1}{2}(\\lvert 000 \\rangle + \\lvert 001 \\rangle + \\lvert 010 \\rangle + \\lvert 011 \\rangle)$.\n  - $\\psi_{final} = H_2 \\psi_2 = \\frac{1}{2\\sqrt{2}} \\sum_{i=0}^{7} \\lvert i \\rangle$.\n- In the final state, all amplitudes are $\\frac{1}{\\sqrt{8}}$.\n- Probability of $\\lvert 111 \\rangle$: $P(\\lvert 111 \\rangle) = |\\psi_{final}[7]|^2 = |\\frac{1}{\\sqrt{8}}|^2 = \\frac{1}{8} = 0.125$.\n- Operation Counts: $3$ single-qubit gates are applied.\n  - Cost per gate: $16$ mults, $8$ adds.\n  - Total mults: $3 \\times 16 = 48$.\n  - Total adds: $3 \\times 8 = 24$.\n  - Total swaps: $0$.\n- Result: $[0.125, 48, 24, 0, 3, 3]$.\n\n**Case C: GHZ State Preparation**\n- Circuit: $H$ on qubit $0$, then $\\mathrm{CNOT}(0 \\to 1)$, then $\\mathrm{CNOT}(1 \\to 2)$. $n=3$, $d=3$.\n- State evolution:\n  - $\\psi_0 = \\lvert 000 \\rangle$.\n  - $\\psi_1 = H_0 \\psi_0 = \\frac{1}{\\sqrt{2}}(\\lvert 000 \\rangle + \\lvert 001 \\rangle)$.\n  - $\\psi_2 = \\mathrm{CNOT}(0 \\to 1) \\psi_1 = \\frac{1}{\\sqrt{2}}(\\lvert 000 \\rangle + \\lvert 011 \\rangle)$. This is because the $\\lvert 001 \\rangle$ component has control bit $0$ equal to $1$, so the target bit $1$ is flipped.\n  - $\\psi_{final} = \\mathrm{CNOT}(1 \\to 2) \\psi_2 = \\frac{1}{\\sqrt{2}}(\\lvert 000 \\rangle + \\lvert 111 \\rangle)$. The $\\lvert 000 \\rangle$ component is unchanged (control bit $1$ is $0$). The $\\lvert 011 \\rangle$ component has control bit $1$ equal to $1$, so target bit $2$ is flipped ($\\lvert 011 \\rangle \\to \\lvert 111 \\rangle$).\n- The final state vector has non-zero amplitudes $\\psi_{final}[0] = \\frac{1}{\\sqrt{2}}$ and $\\psi_{final}[7] = \\frac{1}{\\sqrt{2}}$.\n- Probability of $\\lvert 111 \\rangle$: $P(\\lvert 111 \\rangle) = |\\psi_{final}[7]|^2 = |\\frac{1}{\\sqrt{2}}|^2 = \\frac{1}{2} = 0.5$.\n- Operation Counts: $1$ single-qubit gate and $2$ $\\mathrm{CNOT}$ gates.\n  - $H(0)$: $16$ mults, $8$ adds.\n  - $\\mathrm{CNOT}(0 \\to 1)$: $6$ swap assignments.\n  - $\\mathrm{CNOT}(1 \\to 2)$: $6$ swap assignments.\n  - Total mults: $16$.\n  - Total adds: $8$.\n  - Total swaps: $6 + 6 = 12$.\n- Result: $[0.5, 16, 8, 12, 3, 3]$.\n\n**Case D: Involution**\n- Circuit: $X$ on qubit $2$, then $X$ on qubit $2$. $n=3$, $d=2$.\n- State evolution: Since $X^2=I$ (the identity matrix), applying the gate twice is equivalent to doing nothing.\n  - $\\psi_0 = \\lvert 000 \\rangle$.\n  - $\\psi_1 = X_2 \\psi_0 = \\lvert 100 \\rangle$.\n  - $\\psi_{final} = X_2 \\psi_1 = X_2 \\lvert 100 \\rangle = \\lvert 000 \\rangle$.\n- The final state is the initial state $\\lvert 000 \\rangle$.\n- Probability of $\\lvert 111 \\rangle$: $P(\\lvert 111 \\rangle) = |\\psi_{final}[7]|^2 = |0|^2 = 0$.\n- Operation Counts: $2$ single-qubit gates are applied.\n  - Cost per gate: $16$ mults, $8$ adds.\n  - Total mults: $2 \\times 16 = 32$.\n  - Total adds: $2 \\times 8 = 16$.\n  - Total swaps: $0$.\n- Result: $[0.0, 32, 16, 0, 3, 2]$.", "answer": "[[0.0, 0, 0, 0, 3, 0], [0.125, 48, 24, 0, 3, 3], [0.5, 16, 8, 12, 3, 3], [0.0, 32, 16, 0, 3, 2]]", "id": "3242157"}, {"introduction": "Quantum algorithms are built from sequences of fundamental operations called quantum gates. While there are many different types of gates, they are not all independent; a small 'universal' set can be used to construct any quantum computation. This exercise explores a fundamental relationship between two crucial two-qubit gates: the Controlled-NOT ($\\mathrm{CNOT}$) and the Controlled-Z ($\\mathrm{CZ}$) [@problem_id:3242137]. By showing how one can be built from the other using only single-qubit Hadamard gates, you will uncover an elegant piece of the underlying mathematical structure that makes quantum circuit design a versatile and powerful endeavor.", "problem": "You are designing low-level building blocks for quantum circuits used in introductory quantum algorithms. Work in the standard two-qubit computational basis {$|00\\rangle, |01\\rangle, |10\\rangle, |11\\rangle$}, and use only the following fundamental gate definitions.\n\nThe Pauli matrices are\n$$\nX \\;=\\; \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}, \n\\qquad\nZ \\;=\\; \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}.\n$$\nThe Hadamard gate (denoted $H$) is\n$$\nH \\;=\\; \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 & 1 \\\\ 1 & -1 \\end{pmatrix},\n$$\nwhich obeys $H|0\\rangle = |+\\rangle$ and $H|1\\rangle = |-\\rangle$ with $|+\\rangle = \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}$ and $|-\\rangle = \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}$.\n\nThe Controlled-Z gate (Controlled-Z (CZ)) with the first qubit as control is the two-qubit unitary\n$$\n\\mathrm{CZ} \\;=\\; |0\\rangle\\langle 0| \\otimes I \\;+\\; |1\\rangle\\langle 1| \\otimes Z \\;=\\; \\mathrm{diag}(1,1,1,-1).\n$$\nThe Controlled-NOT gate (Controlled-NOT (CNOT)) with the first qubit as control is the two-qubit unitary that maps $|c,t\\rangle \\mapsto |c, t \\oplus c\\rangle$ for $c,t \\in \\{0,1\\}$, where $\\oplus$ denotes addition modulo $2$.\n\nConsider the unitary\n$$\nU \\;=\\; (I \\otimes H)\\,\\mathrm{CZ}\\,(I \\otimes H).\n$$\n\nStarting only from the above definitions and the linearity of quantum operations, derive the action of $U$ on the computational basis states and use it to determine the unique global phase $\\phi \\in \\mathbb{R}$ for which\n$$\nU \\;=\\; \\exp(i \\phi)\\,\\mathrm{CNOT}.\n$$\nReport the value of $\\phi$ in radians as a single real number. No numerical approximation is needed, and no rounding is required. State your final answer in radians.", "solution": "The objective is to find the global phase $\\phi$ relating the unitary operator $U$ to the $\\mathrm{CNOT}$ gate. The defining relation is $U = \\exp(i \\phi)\\,\\mathrm{CNOT}$. The operator $U$ is given by the circuit identity $U = (I \\otimes H)\\,\\mathrm{CZ}\\,(I \\otimes H)$.\n\nFirst, let us express the $\\mathrm{CNOT}$ gate in a form that is structurally similar to the given form of the $\\mathrm{CZ}$ gate. The $\\mathrm{CNOT}$ gate with the first qubit as control and the second as target applies the identity operator $I$ to the target qubit if the control is $|0\\rangle$, and the Pauli-$X$ operator to the target qubit if the control is $|1\\rangle$. This can be written using projection operators as:\n$$\n\\mathrm{CNOT} = |0\\rangle\\langle 0| \\otimes I + |1\\rangle\\langle 1| \\otimes X\n$$\nThe problem defines the $\\mathrm{CZ}$ gate as:\n$$\n\\mathrm{CZ} = |0\\rangle\\langle 0| \\otimes I + |1\\rangle\\langle 1| \\otimes Z\n$$\nNow, let's analyze the expression for $U$:\n$$\nU = (I \\otimes H)\\,\\mathrm{CZ}\\,(I \\otimes H)\n$$\nSubstituting the operator form of $\\mathrm{CZ}$:\n$$\nU = (I \\otimes H) \\left( |0\\rangle\\langle 0| \\otimes I + |1\\rangle\\langle 1| \\otimes Z \\right) (I \\otimes H)\n$$\nWe distribute the $(I \\otimes H)$ factors across the sum. Using the property of tensor products $(A \\otimes B)(C \\otimes D) = (AC) \\otimes (BD)$, we can rewrite the expression. The single-qubit operators $|0\\rangle\\langle 0|$ and $|1\\rangle\\langle 1|$ act on the first qubit, and $I$, $Z$, and $H$ act on the second.\n$$\nU = (I \\otimes H)(|0\\rangle\\langle 0| \\otimes I)(I \\otimes H) + (I \\otimes H)(|1\\rangle\\langle 1| \\otimes Z)(I \\otimes H)\n$$\nApplying the tensor product multiplication rule:\n$$\nU = (I|0\\rangle\\langle 0|I) \\otimes (HIH) + (I|1\\rangle\\langle 1|I) \\otimes (HZH)\n$$\nSince $I$ is the identity operator, $I|0\\rangle\\langle 0|I = |0\\rangle\\langle 0|$ and $I|1\\rangle\\langle 1|I = |1\\rangle\\langle 1|$. The expression simplifies to:\n$$\nU = |0\\rangle\\langle 0| \\otimes (H I H) + |1\\rangle\\langle 1| \\otimes (H Z H)\n$$\nThe Hadamard gate $H$ is its own inverse, meaning $H^2 = I$. This can be explicitly verified:\n$$\nH^2 = \\left( \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 & 1 \\\\ 1 & -1 \\end{pmatrix} \\right) \\left( \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 & 1 \\\\ 1 & -1 \\end{pmatrix} \\right) = \\frac{1}{2} \\begin{pmatrix} 1+1 & 1-1 \\\\ 1-1 & 1+1 \\end{pmatrix} = \\frac{1}{2}\\begin{pmatrix} 2 & 0 \\\\ 0 & 2 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} = I\n$$\nThus, the term $HIH = H^2 = I$.\n\nNext, we evaluate the term $HZH$.\n$$\nHZH = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 & 1 \\\\ 1 & -1 \\end{pmatrix} \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix} \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 & 1 \\\\ 1 & -1 \\end{pmatrix}\n$$\n$$\nHZH = \\frac{1}{2} \\begin{pmatrix} 1 & 1 \\\\ 1 & -1 \\end{pmatrix} \\begin{pmatrix} 1 & 1 \\\\ -1 & 1 \\end{pmatrix}\n$$\n$$\nHZH = \\frac{1}{2} \\begin{pmatrix} (1)(1) + (1)(-1) & (1)(1) + (1)(1) \\\\ (1)(1) + (-1)(-1) & (1)(1) + (-1)(1) \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 0 & 2 \\\\ 2 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix} = X\n$$\nThis is a fundamental identity relating the Pauli matrices $X$ and $Z$ via the Hadamard gate.\n\nSubstituting $HIH = I$ and $HZH = X$ back into our expression for $U$:\n$$\nU = |0\\rangle\\langle 0| \\otimes I + |1\\rangle\\langle 1| \\otimes X\n$$\nThis is precisely the operator expression for the $\\mathrm{CNOT}$ gate we derived earlier.\nTherefore, we have demonstrated that $U = \\mathrm{CNOT}$.\n\nThe problem requires us to find the phase $\\phi$ in the relation $U = \\exp(i\\phi)\\mathrm{CNOT}$. Substituting our result $U = \\mathrm{CNOT}$:\n$$\n\\mathrm{CNOT} = \\exp(i\\phi)\\mathrm{CNOT}\n$$\nSince $\\mathrm{CNOT}$ is an invertible operator, we can multiply by its inverse from the right on both sides, which yields:\n$$\nI = \\exp(i\\phi)I\n$$\nwhere $I$ is the $4 \\times 4$ identity matrix. This implies that the scalar factor $\\exp(i\\phi)$ must be equal to $1$.\n$$\n\\exp(i\\phi) = 1\n$$\nThis equation is satisfied for any $\\phi$ that is an integer multiple of $2\\pi$, i.e., $\\phi = 2k\\pi$ for $k \\in \\mathbb{Z}$. The problem asks for the \"unique\" global phase $\\phi$. By convention in physics and engineering, when a phase is requested, the principal value is implied. The standard interval for the principal value of an angle is $(-\\pi, \\pi]$. The only value within this interval that satisfies the condition is $\\phi = 0$.\n\nThus, the required global phase is $0$ radians.", "answer": "$$\n\\boxed{0}\n$$", "id": "3242137"}]}