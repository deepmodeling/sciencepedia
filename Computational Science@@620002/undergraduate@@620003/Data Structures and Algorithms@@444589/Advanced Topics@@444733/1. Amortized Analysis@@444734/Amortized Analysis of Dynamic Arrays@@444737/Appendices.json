{"hands_on_practices": [{"introduction": "To begin our hands-on exploration, we will look at the cost of dynamic arrays from a different angle. Instead of immediately calculating the total cost over all operations, let's consider the \"experience\" of a single element. The problem in [@problem_id:3206830] asks us to find the maximum number of times any one element is copied, which forces us to trace the history of resizes and understand how often the most \"long-lived\" element must be moved.", "problem": "Consider a dynamic array that initially has capacity $1$ and is empty. The array supports an append operation that places a new element at the end in constant time when unused capacity is available. When an append finds the array full, the array performs a resize: it allocates a new contiguous block whose capacity is exactly double the current capacity, and then copies all current elements from the old block into the new block in order, after which the new element is appended. Assume no deletions occur. Define a “copy” of an element to mean a movement of that element during a resize (the initial placement of an element when it is appended does not count as a copy).\n\nAfter performing exactly $N \\ge 1$ appends, determine, as a closed-form expression in terms of $N$, the maximum possible number of times that any single element has been copied due solely to resizes during this sequence of $N$ appends. Provide your answer as an exact expression; no numerical approximation or rounding is required.", "solution": "The user wants me to solve a problem about dynamic arrays.\n\n### Step 1: Extract Givens\n- Initial array capacity: $1$.\n- Initial array size: $0$.\n- Append operation: Places a new element at the end.\n- Resize condition: Occurs when an append is attempted on a full array.\n- Resize mechanism:\n    1. New capacity is allocated as $2 \\times$ current capacity.\n    2. All existing elements are copied to the new block.\n    3. The new element is then appended.\n- Definition of \"copy\": Movement of an element during a resize. The initial insertion of an element is not a copy.\n- Total operations: Exactly $N$ appends are performed, with $N \\ge 1$.\n- Objective: Determine the maximum possible number of times any single element has been copied.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is a standard exercise in the analysis of algorithms, specifically concerning the amortized analysis of a dynamic array (also known as a vector or ArrayList). The model described (doubling capacity on resize) is a classic implementation strategy. The problem is scientifically and mathematically sound.\n- **Well-Posedness**: The problem is well-posed. The initial conditions, the rules for operation, and the quantity to be determined are all specified precisely. A unique, deterministic solution exists.\n- **Objectivity**: The problem statement is objective and uses formal, unambiguous language.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-defined question in the field of computer science about data structures and algorithms. I will now proceed with a formal solution.\n\n### Solution Derivation\nThe problem asks for the maximum number of times any single element has been copied after a sequence of $N$ append operations. To maximize the number of copies for an element, we should consider an element that has been present in the array for the longest possible duration, as it would be subject to every resize operation that occurs after its insertion. The first element to be appended, let us call it $E_1$, satisfies this condition. Therefore, the maximum number of copies for any element is the number of times $E_1$ is copied.\n\nLet's analyze the state of the dynamic array, specifically its capacity. The capacity, let's denote it by $C$, changes only during resize operations. According to the problem statement, the initial capacity is $C_0 = 1$. A resize operation doubles the capacity. Thus, the sequence of capacities the array can have are powers of $2$: $1, 2, 4, 8, \\dots, 2^k$ for non-negative integers $k$. A capacity of $C=2^k$ can hold up to $2^k$ elements.\n\nA resize is triggered when an append operation is attempted on an array that is full. That is, if the array has a capacity of $C$ and already contains $C$ elements, the next append causes a resize.\n\nLet us trace the process:\n1.  **Initial State**: Capacity $C=1$, size $S=0$.\n2.  **Append 1**: We append element $E_1$. The array has space, so no resize occurs. The state becomes $C=1$, $S=1$. The number of copies for $E_1$ is $0$.\n3.  **Append 2**: We try to append $E_2$. The array is full ($S=C=1$). A resize is triggered.\n    - A new array of capacity $2 \\times 1 = 2$ is allocated.\n    - Element $E_1$ is copied from the old array to the new one. This is the **first copy** of $E_1$.\n    - Element $E_2$ is appended.\n    - The state becomes $C=2$, $S=2$.\n4.  **Append 3**: We try to append $E_3$. The array is full ($S=C=2$). A resize is triggered.\n    - A new array of capacity $2 \\times 2 = 4$ is allocated.\n    - Elements $E_1$ and $E_2$ are copied. This is the **second copy** of $E_1$.\n    - Element $E_3$ is appended.\n    - The state becomes $C=4$, $S=3$.\n5.  **Append 4**: We append $E_4$. The array is not full ($S=3, C=4$). No resize. State becomes $C=4, S=4$. $E_1$ has still been copied twice.\n6.  **Append 5**: We try to append $E_5$. The array is full ($S=C=4$). A resize is triggered to capacity $2 \\times 4 = 8$. This involves the **third copy** of $E_1$.\n\nFrom this analysis, it is clear that $E_1$ is copied on every resize event that happens after its initial placement. The number of times $E_1$ is copied is therefore equal to the total number of resizes that occur during the $N$ appends.\n\nAfter $N$ appends, the array must hold $N$ elements. The capacity of the array, $C_N$, must be at least $N$. Since capacities are powers of two, $C_N$ must be the smallest power of two that is greater than or equal to $N$. Let this capacity be $C_N = 2^k$.\nThe condition $C_N = 2^k \\ge N$ with $k$ being the smallest such integer implies that the previous capacity, $2^{k-1}$, was insufficient, i.e., $2^{k-1} < N$.\nSo, we have the inequality:\n$$2^{k-1} < N \\le 2^k$$\nThis inequality holds for $N > 1$. If $N=1$, the capacity is $1=2^0$, so $k=0$.\nFor $N > 1$, we can take the logarithm base $2$ of the inequality:\n$$\\log_2(2^{k-1}) < \\log_2(N) \\le \\log_2(2^k)$$\n$$k-1 < \\log_2(N) \\le k$$\nThis relationship is the definition of the ceiling function. Thus, for $N > 1$, the exponent $k$ of the final capacity is given by:\n$$k = \\lceil \\log_2(N) \\rceil$$\nLet's check this for $N=1$. The final capacity is $1 = 2^0$, so $k=0$. The formula gives $\\lceil \\log_2(1) \\rceil = \\lceil 0 \\rceil = 0$. So the formula holds for all $N \\ge 1$.\n\nThe sequence of capacities that the array must adopt to reach a capacity of $2^k$ is $2^0, 2^1, 2^2, \\ldots, 2^k$.\nEach step in this sequence from $2^j$ to $2^{j+1}$ for $j=0, 1, \\ldots, k-1$ corresponds to one resize operation.\nThe first element, $E_1$, is present in the array from the point where the capacity is $C=2^0$. It will be copied in every subsequent resize. The resizes are:\n- from $2^0 \\to 2^1$\n- from $2^1 \\to 2^2$\n- ...\n- from $2^{k-1} \\to 2^k$\n\nThe total number of these resize events is $(k-1) - 0 + 1 = k$.\nTherefore, the maximum number of times any single element is copied is $k$. Substituting the expression for $k$:\n$$\\text{Maximum copies} = \\lceil \\log_2(N) \\rceil$$\nThis expression is a closed form in terms of $N$ and is valid for all $N \\ge 1$.", "answer": "$$\\boxed{\\lceil \\log_2(N) \\rceil}$$", "id": "3206830"}, {"introduction": "The constant amortized cost of dynamic array appends is a celebrated result, but it hinges on a crucial assumption: the cost to copy $k$ elements is linear, or $O(k)$. What happens if this assumption does not hold? The exercise in [@problem_id:3206794] presents a hypothetical scenario where the copy cost is quadratic ($k^2$), allowing us to rigorously test the boundaries of the doubling strategy's efficiency and understand why the linear copy cost is so important.", "problem": "You are given a dynamic array that stores items contiguously. The array starts empty with initial capacity $1$. Every time an append operation would overflow the current capacity, the array resizes by allocating a new array with capacity doubled to $2$ times the current capacity and then migrates all existing elements into the new array in order.\n\nThe cost model is as follows: each append operation that writes a single element into an available slot costs $1$ unit; when a resize occurs, copying $k$ existing elements into the new array costs $k^2$ units (in addition to the $1$ unit cost for the append that triggers the resize). You perform exactly $n$ append operations, where $n$ is a power of $2$ (that is, $n = 2^t$ for some integer $t \\ge 0$).\n\nUsing only the fundamental definition that the amortized cost per operation equals the total cost divided by the number of operations, and the specified resizing policy, derive the exact amortized cost per append as a function of $n$. Provide your final answer as a single simplified closed-form analytic expression in terms of $n$. Do not include units in your final answer. No rounding is required.", "solution": "The problem asks for the exact amortized cost per append operation for a sequence of $n$ appends into a dynamic array, where $n$ is a power of $2$ ($n = 2^t$ for some integer $t \\ge 0$). The amortized cost is defined as the total cost divided by the number of operations.\n\nFirst, we must calculate the total cost for performing $n$ append operations. The total cost, $C_{total}$, is the sum of two components: the total cost of all append operations and the total cost of all resize-and-copy operations.\n\nThe cost model is specified as:\n1.  Base append cost: Each append operation costs $1$ unit to write the element into an available slot.\n2.  Resize cost: When a resize is triggered, copying $k$ existing elements costs $k^2$ units. This is in addition to the $1$ unit for the append that triggers it.\n\nTotal base append cost:\nSince there are exactly $n$ append operations, and each has a base cost of $1$, the total base append cost is $n \\times 1 = n$.\n\nTotal resize cost:\nA resize occurs when an append is attempted on a full array. The array starts with an initial capacity of $1$. The capacity doubles upon each resize.\nLet's trace the state of the array, specifically its size (number of elements) and capacity.\n-   Initially, size is $0$ and capacity is $1$.\n-   Append #$1$: The size becomes $1$. The array is now full.\n-   Append #$2$: This triggers the first resize because size ($1$) equals capacity ($1$). The number of elements to copy is $k=1$. The new capacity will be $2 \\times 1 = 2$. The cost for this copy is $k^2 = 1^2 = 1$.\n-   Append #$3$: The size is $2$ and capacity is $2$. This triggers a resize. The number of elements to copy is $k=2$. The new capacity will be $2 \\times 2 = 4$. The cost for this copy is $k^2 = 2^2 = 4$.\n-   Append #$5$: The size is $4$ and capacity is $4$. This triggers a resize. The number of elements to copy is $k=4$. The new capacity will be $2 \\times 4 = 8$. The cost for this copy is $k^2 = 4^2 = 16$.\n\nFrom this pattern, we can generalize. A resize is triggered when the number of elements in the array is a power of $2$, say $2^j$, and we need to append a new element. The number of elements to copy is $k=2^j$. The cost of this single resize operation is $k^2 = (2^j)^2 = 4^j$.\n\nWe are performing $n=2^t$ append operations in total. The sizes of the array that will trigger a resize are $1, 2, 4, \\dots, 2^{t-1}$.\n-   When size is $1=2^0$, the next append triggers a resize. Copy cost is $(2^0)^2 = 4^0$. This happens for $j=0$.\n-   When size is $2=2^1$, the next append triggers a resize. Copy cost is $(2^1)^2 = 4^1$. This happens for $j=1$.\n-   This continues until the size is $2^{t-1}$. The next append (operation number $2^{t-1}+1$) triggers a resize to a capacity of $2 \\times 2^{t-1} = 2^t$. The number of elements to copy is $k=2^{t-1}$, and the cost is $(2^{t-1})^2 = 4^{t-1}$. This corresponds to $j=t-1$.\n\nAfter the final append operation, number $n=2^t$, the array will have a size of $2^t$ and a capacity of $2^t$. No further resize is performed within this sequence of $n$ operations. Therefore, the resizes correspond to $j$ from $0$ to $t-1$.\n\nThe total resize cost, $C_{resize}$, is the sum of the costs of all these resize operations:\n$$C_{resize} = \\sum_{j=0}^{t-1} (2^j)^2 = \\sum_{j=0}^{t-1} 4^j$$\nThis is a finite geometric series with $t$ terms, a first term of $4^0=1$, and a common ratio of $4$. The sum is given by the formula $\\frac{r^{\\text{number of terms}} - 1}{r-1}$.\n$$C_{resize} = \\frac{4^t - 1}{4 - 1} = \\frac{4^t - 1}{3}$$\nThis calculation is valid for $t \\ge 1$. If $t=0$, then $n=1$, the sum is empty and its value is $0$. Our formula gives $\\frac{4^0-1}{3}=0$, so it holds for $t=0$ as well.\n\nNow, we can find the total cost, $C_{total}$, by adding the total base append cost and the total resize cost:\n$$C_{total} = (\\text{Total Append Cost}) + (\\text{Total Resize Cost}) = n + \\frac{4^t - 1}{3}$$\n\nTo express this purely in terms of $n$, we use the given relation $n=2^t$. Squaring both sides gives $n^2 = (2^t)^2 = 2^{2t} = (2^2)^t = 4^t$.\nSubstituting $4^t = n^2$ into the expression for $C_{total}$:\n$$C_{total} = n + \\frac{n^2 - 1}{3}$$\n\nFinally, the amortized cost per append, $A(n)$, is the total cost divided by the number of operations, $n$.\n$$A(n) = \\frac{C_{total}}{n} = \\frac{n + \\frac{n^2 - 1}{3}}{n}$$\nWe can simplify this expression:\n$$A(n) = \\frac{n}{n} + \\frac{n^2 - 1}{3n} = 1 + \\frac{n^2 - 1}{3n}$$\nTo write this as a single fraction, we find a common denominator:\n$$A(n) = \\frac{3n}{3n} + \\frac{n^2 - 1}{3n} = \\frac{3n + n^2 - 1}{3n}$$\nReordering the terms in the numerator gives the final simplified expression:\n$$A(n) = \\frac{n^2 + 3n - 1}{3n}$$\nThis is the exact amortized cost per append as a single simplified closed-form analytic expression in terms of $n$.", "answer": "$$ \\boxed{\\frac{n^2 + 3n - 1}{3n}} $$", "id": "3206794"}, {"introduction": "Efficient data structures must perform well not just during growth, but also when operations are mixed. This final practice problem explores a critical performance pitfall known as \"thrashing.\" By analyzing a dynamic array with an overly aggressive shrinking policy under a sequence of alternating appends and pops [@problem_id:3206841], we can see how poor design choices can lead to a pathological state where the array spends nearly all its time resizing, resulting in extremely high amortized costs.", "problem": "Consider a dynamic array implementing two operations: append and pop. The array maintains a capacity $C$ and a current size $S$, where $0 \\leq S \\leq C$. The array uses the following resizing policy:\n- On append, if $S = C$, the array grows by allocating a new array of capacity $\\lambda C$ for a fixed constant growth factor $\\lambda > 1$, and copies all $S$ existing elements into it before appending the new element.\n- On pop, after the element is removed (so the new size is $S-1$), the array shrinks by allocating a new array with capacity exactly equal to the new size, i.e., $C := S-1$, and copies all $S-1$ existing elements into it.\n\nUse the following cost model: copying a single element during any resize costs $1$ unit, and performing append or pop without resizing costs $1$ unit. Copying cost during resizing is linear in the number of elements moved.\n\nAssume the array starts in a steady state with size $s_0 \\geq 1$ and capacity $c_0 = s_0$. Consider a sequence of $2m$ operations that alternates append and pop, beginning with append, so the size toggles between $s_0$ and $s_0+1$ throughout. Using first-principles aggregate amortized analysis, derive the exact closed-form expression for the amortized cost per operation as a function of $m$ and $s_0$, and report the steady-state amortized cost per operation as $m \\to \\infty$ in terms of $s_0$. Express your final answer as a single closed-form analytic expression. No rounding is required.", "solution": "The problem asks for the amortized cost per operation for a specific sequence of $2m$ operations using the aggregate method. The aggregate method calculates the total cost of the sequence of operations and divides by the number of operations.\n\nLet $S$ be the number of elements in the dynamic array (its size), and let $C$ be its capacity.\nThe initial state of the array is given as size $s_0 \\geq 1$ and capacity $c_0 = s_0$.\nThe sequence of $2m$ operations is an alternating sequence of `append` and `pop`, starting with `append`.\n\nLet us analyze the cost and the state of the array for a single pair of `append` followed by `pop` operations. This corresponds to operations $2k-1$ and $2k$ for any $k \\in \\{1, 2, \\dots, m\\}$.\n\nLet the state before the first operation be $(S, C) = (s_0, s_0)$.\n\n**Operation 1: Append**\n- The current state is $(S, C) = (s_0, s_0)$.\n- The condition for resizing on append is $S = C$, which is met.\n- A resize operation is performed.\n    - All $S = s_0$ elements are copied to a new array. The cost of this copy is $s_0$.\n    - The new capacity is $C' = \\lambda C = \\lambda s_0$.\n- The new element is then appended. The intrinsic cost of the append operation is $1$.\n- The total cost of this append operation is the sum of the copy cost and the operation cost: $s_0 + 1$.\n- After appending, the new size is $S' = s_0 + 1$.\n- The state of the array is now $(S, C) = (s_0 + 1, \\lambda s_0)$.\n\n**Operation 2: Pop**\n- The current state is $(S, C) = (s_0 + 1, \\lambda s_0)$.\n- An element is removed. The size becomes $S' = S - 1 = (s_0 + 1) - 1 = s_0$.\n- The resizing policy for a `pop` operation is to always shrink the array.\n    - A new array is allocated with capacity equal to the new size. The new capacity is $C' = s_0$.\n    - All $s_0$ remaining elements are copied to this new array. The cost of this copy is $s_0$.\n- The intrinsic cost of the `pop` operation is $1$.\n- The total cost of this `pop` operation is the sum of the copy cost and the operation cost: $s_0 + 1$.\n- After popping and resizing, the final state is $(S, C) = (s_0, s_0)$.\n\nAfter one pair of `append-pop` operations, the array's state $(S, C)$ has returned to its initial state $(s_0, s_0)$. The cost incurred for the `append` was $s_0 + 1$ and the cost for the `pop` was also $s_0 + 1$.\n\nThis establishes a cycle. For every subsequent pair of `append-pop` operations, the process and costs will be identical. The growth factor $\\lambda$ influences the intermediate capacity after an `append`, but this capacity is immediately discarded by the subsequent `pop` operation's resizing policy. Therefore, the value of $\\lambda$ does not affect the total cost for this specific sequence of operations.\n\nThe sequence consists of $m$ such `append-pop` cycles.\n- There are $m$ `append` operations, each costing $s_0 + 1$.\n- There are $m$ `pop` operations, each costing $s_0 + 1$.\n\nThe total number of operations is $2m$.\nThe total cost, $C_{total}$, for the entire sequence of $2m$ operations is:\n$$ C_{total} = m \\times (\\text{cost of append}) + m \\times (\\text{cost of pop}) $$\n$$ C_{total} = m(s_0 + 1) + m(s_0 + 1) = 2m(s_0 + 1) $$\n\nThe first task is to find the exact closed-form expression for the amortized cost per operation, $A(m, s_0)$. This is the total cost divided by the number of operations:\n$$ A(m, s_0) = \\frac{C_{total}}{2m} = \\frac{2m(s_0 + 1)}{2m} = s_0 + 1 $$\nThis expression is the amortized cost as a function of $m$ and $s_0$. It is constant with respect to $m$.\n\nThe second task is to find the steady-state amortized cost as $m \\to \\infty$. This is the limit of $A(m, s_0)$ as $m$ approaches infinity:\n$$ \\lim_{m \\to \\infty} A(m, s_0) = \\lim_{m \\to \\infty} (s_0 + 1) $$\nSince $s_0 + 1$ does not depend on $m$, the limit is simply:\n$$ \\lim_{m \\to \\infty} (s_0 + 1) = s_0 + 1 $$\n\nThe steady-state amortized cost per operation is $s_0 + 1$.", "answer": "$$\\boxed{s_0 + 1}$$", "id": "3206841"}]}