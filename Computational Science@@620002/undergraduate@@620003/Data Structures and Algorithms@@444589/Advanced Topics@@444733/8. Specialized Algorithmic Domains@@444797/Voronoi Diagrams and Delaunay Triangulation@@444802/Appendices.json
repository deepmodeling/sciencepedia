{"hands_on_practices": [{"introduction": "The intersections of boundaries in a Voronoi diagram are special points known as Voronoi vertices, each equidistant from three or more generator sites. This exercise provides foundational practice in calculating the precise location of such a vertex, which is geometrically equivalent to finding the circumcenter of the triangle formed by the three generators. Mastering this core calculation is the first step toward constructing and analyzing Voronoi diagrams from the ground up [@problem_id:2175770].", "problem": "In computational astrophysics, Voronoi diagrams are employed to model regions of influence around celestial objects. An astronomer is analyzing a newly surveyed region of space and has identified three distinct, non-collinear pulsars: PSR-A, PSR-B, and PSR-C. On a 2D Cartesian coordinate chart where the units are in light-years, the locations of these pulsars are given as $P_A = (1, 7)$, $P_B = (9, 1)$, and $P_C = (-3, -3)$.\n\nA theoretical model suggests the existence of a unique point in this plane that is equidistant from all three pulsars. This point is geometrically significant as it represents the single Voronoi vertex defined by these three generator points. The identification of this point is crucial for calibrating a new type of gravitational wave detector.\n\nDetermine the coordinates $(x_V, y_V)$ of this Voronoi vertex.", "solution": "The Voronoi vertex is the point $(x_V, y_V)$ that is equidistant from the three given points $P_A = (1, 7)$, $P_B = (9, 1)$, and $P_C = (-3, -3)$. This point is the circumcenter of the triangle formed by $P_A$, $P_B$, and $P_C$. The circumcenter can be found by determining the intersection of the perpendicular bisectors of the sides of the triangle. We only need to find the equations for two of these bisectors and then solve the resulting system of linear equations.\n\nLet's find the equation of the perpendicular bisector of the segment $P_A P_B$.\nFirst, we find the midpoint $M_{AB}$ of the segment connecting $P_A$ and $P_B$:\n$$\nM_{AB} = \\left( \\frac{x_A + x_B}{2}, \\frac{y_A + y_B}{2} \\right) = \\left( \\frac{1 + 9}{2}, \\frac{7 + 1}{2} \\right) = (5, 4)\n$$\nNext, we determine the slope $m_{AB}$ of the segment $P_A P_B$:\n$$\nm_{AB} = \\frac{y_B - y_A}{x_B - x_A} = \\frac{1 - 7}{9 - 1} = \\frac{-6}{8} = -\\frac{3}{4}\n$$\nThe slope of the perpendicular bisector, $m_{\\perp AB}$, is the negative reciprocal of $m_{AB}$:\n$$\nm_{\\perp AB} = -\\frac{1}{m_{AB}} = -\\frac{1}{-3/4} = \\frac{4}{3}\n$$\nUsing the point-slope form of a linear equation with point $M_{AB}=(5,4)$ and slope $m_{\\perp AB} = 4/3$, we get the equation of the first perpendicular bisector:\n$$\ny - 4 = \\frac{4}{3}(x - 5)\n$$\n$$\ny = \\frac{4}{3}x - \\frac{20}{3} + 4 = \\frac{4}{3}x - \\frac{20}{3} + \\frac{12}{3}\n$$\n$$\ny = \\frac{4}{3}x - \\frac{8}{3}\n$$\nTo eliminate fractions, we can write this as $3y = 4x - 8$, or $4x - 3y = 8$. (Equation 1)\n\nNow, let's find the equation of the perpendicular bisector of the segment $P_B P_C$.\nFirst, we find the midpoint $M_{BC}$ of the segment connecting $P_B = (9,1)$ and $P_C = (-3,-3)$:\n$$\nM_{BC} = \\left( \\frac{x_B + x_C}{2}, \\frac{y_B + y_C}{2} \\right) = \\left( \\frac{9 + (-3)}{2}, \\frac{1 + (-3)}{2} \\right) = \\left( \\frac{6}{2}, \\frac{-2}{2} \\right) = (3, -1)\n$$\nNext, we determine the slope $m_{BC}$ of the segment $P_B P_C$:\n$$\nm_{BC} = \\frac{y_C - y_B}{x_C - x_B} = \\frac{-3 - 1}{-3 - 9} = \\frac{-4}{-12} = \\frac{1}{3}\n$$\nThe slope of the perpendicular bisector, $m_{\\perp BC}$, is the negative reciprocal of $m_{BC}$:\n$$\nm_{\\perp BC} = -\\frac{1}{m_{BC}} = -\\frac{1}{1/3} = -3\n$$\nUsing the point-slope form with point $M_{BC}=(3,-1)$ and slope $m_{\\perp BC} = -3$, we get the equation of the second perpendicular bisector:\n$$\ny - (-1) = -3(x - 3)\n$$\n$$\ny + 1 = -3x + 9\n$$\n$$\ny = -3x + 8\n$$\n(Equation 2)\n\nFinally, we find the intersection point $(x_V, y_V)$ by solving the system of two linear equations:\n1. $4x - 3y = 8$\n2. $y = -3x + 8$\n\nSubstitute Equation 2 into Equation 1:\n$$\n4x - 3(-3x + 8) = 8\n$$\n$$\n4x + 9x - 24 = 8\n$$\n$$\n13x = 32\n$$\n$$\nx_V = \\frac{32}{13}\n$$\nNow substitute the value of $x_V$ back into Equation 2 to find $y_V$:\n$$\ny_V = -3\\left(\\frac{32}{13}\\right) + 8 = -\\frac{96}{13} + \\frac{8 \\cdot 13}{13} = -\\frac{96}{13} + \\frac{104}{13} = \\frac{8}{13}\n$$\nThus, the coordinates of the Voronoi vertex are $\\left(\\frac{32}{13}, \\frac{8}{13}\\right)$.", "answer": "$$\\boxed{\\left(\\frac{32}{13}, \\frac{8}{13}\\right)}$$", "id": "2175770"}, {"introduction": "Moving from Voronoi diagrams to their dual, Delaunay triangulations, the focus shifts from partitioning space to creating optimal connections between points. A triangulation is considered Delaunay if it satisfies the 'empty circle' property for every triangle. This practice problem challenges you to apply this criterion to a single interior edge, a local test that forms the basis of powerful algorithms for building and optimizing triangulations [@problem_id:2175772].", "problem": "In an effort to monitor a remote ecological zone, four autonomous sensor stations, denoted $S_1, S_2, S_3,$ and $S_4$, are deployed. Their positions on a 2D Cartesian plane are given by the coordinates $S_1(0, 0)$, $S_2(8, 2)$, $S_3(6, 9)$, and $S_4(-2, 5)$. The coordinates are given in meters.\n\nTo establish a communication network, the stations are initially connected to form a triangulation. The connections form the perimeter of the quadrilateral $S_1S_2S_3S_4$, plus a single interior link, $S_1S_3$, which divides the area into two triangles: $\\triangle S_1S_2S_3$ and $\\triangle S_1S_3S_4$.\n\nFor optimal signal triangulation, the network must satisfy the Delaunay condition. A triangulation is Delaunay if for every triangle in the network, its circumscribing circle (the unique circle passing through its three vertices) contains no other station in its interior. For an interior edge shared by two triangles, this condition is violated if the fourth vertex (not part of the edge) lies inside the circumcircle of the triangle formed by the edge and the other vertex. If an edge violates this condition, it is considered non-Delaunay and must be \"flipped\" to the other diagonal of the quadrilateral to improve the triangulation.\n\nGiven the initial setup, which of the following statements correctly describes the status of the interior edge $S_1S_3$ and the required action?\n\nA) The edge $S_1S_3$ is Delaunay, and no changes are needed.\n\nB) The edge $S_1S_3$ is not Delaunay and should be replaced by flipping it to the edge $S_2S_4$.\n\nC) The alternative edge $S_2S_4$ would be non-Delaunay, while the current edge $S_1S_3$ is Delaunay.\n\nD) The four stations are collinear and cannot form a valid triangulation.\n\nE) The four stations form a concave quadrilateral, which cannot be resolved by a simple edge flip.", "solution": "We are given $S_{1}(0,0)$, $S_{2}(8,2)$, $S_{3}(6,9)$, and $S_{4}(-2,5)$. The current triangulation uses the interior edge $S_{1}S_{3}$, forming triangles $\\triangle S_{1}S_{2}S_{3}$ and $\\triangle S_{1}S_{3}S_{4}$.\n\nFirst, verify that the polygon $S_{1}S_{2}S_{3}S_{4}$ is strictly convex (to rule out options D and E and to ensure a valid local Delaunay flip test applies). Compute signed areas (orientations) for successive triples:\n- For $(S_{1},S_{2},S_{3})$, using $(S_{2}-S_{1}) \\times (S_{3}-S_{1})$: $(8,2) \\times (6,9)$ gives $8\\cdot 9 - 2\\cdot 6 = 60 > 0$.\n- For $(S_{2},S_{3},S_{4})$: $(S_{3}-S_{2})=(-2,7)$, $(S_{4}-S_{2})=(-10,3)$, cross is $(-2)\\cdot 3 - 7\\cdot(-10) = 64 > 0$.\n- For $(S_{3},S_{4},S_{1})$: $(S_{4}-S_{3})=(-8,-4)$, $(S_{1}-S_{3})=(-6,-9)$, cross is $(-8)\\cdot(-9) - (-4)\\cdot(-6) = 48 > 0$.\n- For $(S_{4},S_{1},S_{2})$: $(S_{1}-S_{4})=(2,-5)$, $(S_{2}-S_{4})=(10,-3)$, cross is $2\\cdot(-3) - (-5)\\cdot 10 = 44 > 0$.\nAll four are positive, hence the quadrilateral is strictly convex in the given order.\n\nThe local Delaunay condition for the interior edge $S_{1}S_{3}$ requires that the opposite vertex of each adjacent triangle lies outside the circumcircle of the other. It suffices to test whether $S_{2}$ lies inside the circumcircle of $\\triangle S_{1}S_{3}S_{4}$ (or equivalently whether $S_{4}$ lies inside the circumcircle of $\\triangle S_{1}S_{2}S_{3}$). We use the in-circle determinant with a counterclockwise ordering of the reference triangle.\n\nFirst, confirm the orientation of $\\triangle S_{1}S_{3}S_{4}$ is counterclockwise:\n$$(S_{3}-S_{1}) \\times (S_{4}-S_{1}) = (6,9) \\times (-2,5) = 6\\cdot 5 - 9\\cdot(-2) = 48 > 0,$$\nso $(S_{1},S_{3},S_{4})$ is counterclockwise.\n\nDefine $r_{i} = x_{i}^{2} + y_{i}^{2}$. Compute\n$$r_{1} = 0^{2} + 0^{2} = 0,\\quad r_{3} = 6^{2} + 9^{2} = 117,\\quad r_{4} = (-2)^{2} + 5^{2} = 29,\\quad r_{2} = 8^{2} + 2^{2} = 68.$$\nThe in-circle determinant for testing whether $S_{2}$ is inside the circumcircle of $\\triangle S_{1}S_{3}S_{4}$ is\n$$\\Delta = \n\\begin{vmatrix}\nx_{1} & y_{1} & r_{1} & 1 \\\\\nx_{3} & y_{3} & r_{3} & 1 \\\\\nx_{4} & y_{4} & r_{4} & 1 \\\\\nx_{2} & y_{2} & r_{2} & 1\n\\end{vmatrix}\n=\n\\begin{vmatrix}\n0 & 0 & 0 & 1 \\\\\n6 & 9 & 117 & 1 \\\\\n-2 & 5 & 29 & 1 \\\\\n8 & 2 & 68 & 1\n\\end{vmatrix}.$$\nExpanding along the first row gives\n$$\\Delta = -\\begin{vmatrix}\n6 & 9 & 117 \\\\\n-2 & 5 & 29 \\\\\n8 & 2 & 68\n\\end{vmatrix}.$$\nCompute the $3\\times 3$ determinant:\n\\begin{align*}\n\\begin{vmatrix}\n6 & 9 & 117 \\\\\n-2 & 5 & 29 \\\\\n8 & 2 & 68\n\\end{vmatrix}\n&= 6\\,(5\\cdot 68 - 29\\cdot 2) - 9\\,((-2)\\cdot 68 - 29\\cdot 8) + 117\\,((-2)\\cdot 2 - 5\\cdot 8) \\\\\n&= 6\\,(340 - 58) - 9\\,(-136 - 232) + 117\\,(-4 - 40) \\\\\n&= 6\\cdot 282 - 9\\cdot(-368) + 117\\cdot(-44) \\\\\n&= 1692 + 3312 - 5148 \\\\\n&= -144.\n\\end{align*}\nHence $\\Delta = -(-144) = 144 > 0$. Since the triangle ordering is counterclockwise and the determinant is positive, $S_{2}$ lies inside the circumcircle of $\\triangle S_{1}S_{3}S_{4}$.\n\nTherefore, the interior edge $S_{1}S_{3}$ violates the Delaunay condition and must be flipped to the other diagonal $S_{2}S_{4}$. This corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "2175772"}, {"introduction": "The previous exercise demonstrated how to test a single edge for the Delaunay property. This capstone practice asks you to scale that concept into a complete, efficient algorithm. You are tasked with designing a method to verify if an entire triangulation of $n$ points is Delaunay in linear time, or $O(n)$. This problem bridges the gap between geometric theory and algorithmic performance, a crucial skill in computational geometry and data structure design [@problem_id:3281906].", "problem": "Design and implement an algorithm that, given a finite set of planar points and a triangulation over these points, verifies in linear time whether the triangulation is a Delaunay triangulation. Use the following foundational base: the definition of the Delaunay triangulation as the triangulation in which, for every triangle, the open circumcircle contains no other input point; the equivalence between the Delaunay triangulation and the straight-line dual graph of the Voronoi diagram; and the well-tested local Delaunay edge legality criterion derived from the empty circumcircle property. The objective is to derive, from these foundations, an $O(n)$ test where $n$ is the number of points.\n\nYou must reason from first principles, starting with the definition of the Delaunay triangulation. The derivation must not assume shortcut formulas not justified from the base. The triangulation is represented as a list of triangles, where each triangle is a triple of zero-based indices into the point array, and each point is represented by its Cartesian coordinates. Angles, when discussed, must be understood in radians; however, the algorithm should be based on the empty circumcircle property and operate without explicitly computing angles. No physical units are required.\n\nAlgorithmic requirements:\n- Input model inside the program: a list of test cases, each test case consisting of an array of points $\\{(x_i,y_i)\\}$ and an array of triangles $\\{(a_j,b_j,c_j)\\}$, where $a_j,b_j,c_j$ are integer indices referring to the points.\n- Verification method: build adjacency for edges shared by two triangles, and apply a constant-time local test per interior edge that determines whether the edge is Delaunay-legal using the in-circle predicate based on the empty circumcircle property. Boundary edges require no test. Use a numerical tolerance $\\varepsilon$ such that values with magnitude at most $\\varepsilon$ are treated as co-circular and hence legal.\n- Complexity target: $O(n)$ in the number of points $n$ (equivalently linear in the number of triangles and edges for a planar triangulation), by ensuring constant work per edge and using hashing for adjacency construction.\n\nTest suite:\nProvide the following four test cases inside your program:\n1. Case A (co-circular hull, either diagonal legal): points $[(0.0,0.0),(1.0,0.0),(1.0,1.0),(0.0,1.0)]$, triangles $[(0,1,2),(0,2,3)]$.\n2. Case B (non-Delaunay due to an illegal interior edge): points $[(0.0,0.0),(2.0,0.0),(2.0,2.0),(0.0,1.1)]$, triangles $[(0,1,2),(0,2,3)]$.\n3. Case C (Delaunay for the same points with the other diagonal): points $[(0.0,0.0),(2.0,0.0),(2.0,2.0),(0.0,1.1)]$, triangles $[(0,1,3),(1,2,3)]$.\n4. Case D (single triangle, trivially Delaunay): points $[(0.0,0.0),(2.0,0.0),(1.0,1.7)]$, triangles $[(0,1,2)]$.\n\nFinal output specification:\nYour program should produce a single line of output containing the verification results for the four test cases as a comma-separated list enclosed in square brackets, where each result is a boolean indicating whether the triangulation is Delaunay for that case (e.g., $[{\\tt True},{\\tt False},{\\tt True},{\\tt True}]$). No other output is permitted.", "solution": "The problem requires designing and implementing a linear-time algorithm to verify if a given planar triangulation is a Delaunay triangulation.\n\n### Step 1: Foundational Principles and Derivation of the Method\n\nA triangulation of a point set $P$ is defined as a Delaunay triangulation if and only if it satisfies the **empty circumcircle property**: for every triangle $T$ in the triangulation, the open circumscribing circle of $T$ contains no point from the set $P$.\n\nA direct verification of this global property would require checking every point in $P$ against the circumcircle of every triangle in the triangulation. Given $n$ points and $O(n)$ triangles, this approach would lead to an $O(n^2)$ complexity, which is too slow for the stated requirement of $O(n)$.\n\nTo achieve linear time complexity, we must leverage a local property that is equivalent to the global Delaunay property. A fundamental theorem in computational geometry states that a triangulation is Delaunay if and only if every interior edge of the triangulation is **locally Delaunay** (or \"legal\"). An edge on the boundary of the triangulation (i.e., on the convex hull of the point set) is always considered legal.\n\nThis reduces the problem to testing the legality of each interior edge. An interior edge $\\overline{ab}$ is shared by two adjacent triangles, say $\\triangle abc$ and $\\triangle abd$, which together form a convex quadrilateral $acbd$. The edge $\\overline{ab}$ is locally Delaunay if the point $d$ does not lie inside the circumcircle of $\\triangle abc$. By symmetry, this is equivalent to the condition that point $c$ does not lie inside the circumcircle of $\\triangle abd$. If the four points $a, b, c, d$ are co-circular, the edge is also considered legal, as either diagonal of the quadrilateral is permissible.\n\nThe test of whether a point $d=(x_d, y_d)$ lies inside, on, or outside the circumcircle of a triangle $\\triangle abc$ with vertices $a=(x_a, y_a)$, $b=(x_b, y_b)$, and $c=(x_c, y_c)$ can be performed without explicitly computing the circle's center or radius. This is achieved using the `in-circle` predicate, which evaluates the sign of a determinant. Assuming the vertices $a, b, c$ are ordered counter-clockwise (CCW), point $d$ is inside the circumcircle if the following determinant is positive:\n\n$$\n\\text{InCircle}(a,b,c,d) = \n\\begin{vmatrix}\nx_a & y_a & x_a^2 + y_a^2 & 1 \\\\\nx_b & y_b & x_b^2 + y_b^2 & 1 \\\\\nx_c & y_c & x_c^2 + y_c^2 & 1 \\\\\nx_d & y_d & x_d^2 + y_d^2 & 1\n\\end{vmatrix} > 0\n$$\n\nTo improve numerical stability, this $4 \\times 4$ determinant is typically reformulated as a $3 \\times 3$ determinant by subtracting the coordinates of point $d$ from the other three points:\n\n$$\n\\text{InCircle}(a,b,c,d) = \n\\begin{vmatrix}\nx_a - x_d & y_a - y_d & (x_a-x_d)^2 + (y_a-y_d)^2 \\\\\nx_b - x_d & y_b - y_d & (x_b-x_d)^2 + (y_b-y_d)^2 \\\\\nx_c - x_d & y_c - y_d & (x_c-x_d)^2 + (y_c-y_d)^2\n\\end{vmatrix}\n$$\n\nThe sign of this determinant depends on the orientation (clockwise or counter-clockwise) of the triangle $\\triangle abc$. Let the orientation be determined by:\n$$\n\\text{orientation}(a,b,c) = (x_b - x_a)(y_c - y_a) - (y_b - y_a)(x_c - x_a)\n$$\nA positive value indicates CCW order, a negative value indicates CW order, and zero indicates collinearity.\n\nAn edge $\\overline{ab}$ shared by $\\triangle abc$ and $\\triangle abd$ is illegal if point $d$ is strictly inside the circumcircle of $\\triangle abc$. This condition holds if and only if the product $\\text{orientation}(a,b,c) \\times \\text{InCircle}(a,b,c,d)$ is positive. To account for floating-point arithmetic, we check if this product is greater than a small positive tolerance $\\varepsilon$. If it is, the edge is illegal, and the entire triangulation is not Delaunay.\n\n### Step 2: Algorithmic Design for $O(n)$ Complexity\n\nBased on the principles above, the linear-time verification algorithm is as follows:\n\n1.  **Adjacency Mapping**: The first step is to identify all interior edges. An interior edge is one that is shared by exactly two triangles. To find these efficiently, we construct a hash map (a dictionary in Python) where keys represent edges and values are lists of the indices of the triangles containing that edge. An edge can be canonically represented by a sorted tuple of its endpoint indices, e.g., `(min(i,j), max(i,j))`, to ensure that the edge from $i$ to $j$ is treated the same as the edge from $j$ to $i$. We iterate through all input triangles. For each of the three edges of a triangle, we add the triangle's index to the list associated with that edge's canonical key in the hash map. Since a planar triangulation with $n$ vertices has $O(n)$ triangles and $O(n)$ edges, this construction process takes $O(n)$ time.\n\n2.  **Edge Legality Testing**: We then iterate through the hash map. For each edge key, we examine its corresponding list of triangle indices.\n    *   If the list contains only one index, the edge is a boundary edge and requires no test.\n    *   If the list contains two indices, say `t1` and `t2`, the edge is an interior edge. Let this edge connect vertices $u$ and $v$. The triangle `t1` will have vertices $(u, v, c)$ and triangle `t2` will have vertices $(u, v, d)$ for some other vertices $c$ and $d$. The points $c$ and $d$ are the vertices opposite the shared edge.\n\n3.  **Local Delaunay Test**: For each interior edge $(u,v)$ with opposite vertices $c$ and $d$, we perform the `in-circle` test. Let the four points be $P_u, P_v, P_c, P_d$. We test if $P_d$ is inside the circumcircle of $\\triangle P_u P_v P_c$.\n    *   We compute the orientation of $(P_u, P_v, P_c)$.\n    *   We compute the value of the $3 \\times 3$ `in-circle` determinant for the points $(P_u, P_v, P_c, P_d)$.\n    *   If the product of the orientation and the determinant is greater than a small numerical tolerance $\\varepsilon$, the edge is illegal. We can immediately conclude the triangulation is not Delaunay and terminate, returning `False`.\n\n4.  **Conclusion**: If the algorithm iterates through all interior edges without finding any illegal ones, the triangulation is locally Delaunay everywhere. By the equivalence theorem, it is globally a Delaunay triangulation, and we return `True`.\n\nThis algorithm performs a constant number of operations (lookups, determinant calculations) for each of the $O(n)$ edges in the triangulation. The total time complexity is dominated by the initial adjacency mapping and the subsequent edge iteration, both of which are $O(n)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Delaunay verification on a suite of test cases.\n    \"\"\"\n\n    TOLERANCE = 1e-9\n\n    def is_delaunay(points: np.ndarray, triangles: list[tuple[int, int, int]]) -> bool:\n        \"\"\"\n        Verifies if a given triangulation is a Delaunay triangulation in O(n) time.\n\n        Args:\n            points: A numpy array of shape (n, 2) representing n points.\n            triangles: A list of triples of point indices representing the triangulation.\n\n        Returns:\n            True if the triangulation is Delaunay, False otherwise.\n        \"\"\"\n        if not triangles:\n            return True # An empty triangulation is trivially Delaunay\n\n        # Step 1: Build an adjacency map for edges.\n        # Key: a sorted tuple of point indices representing an edge.\n        # Value: a list of triangle indices that share this edge.\n        edge_to_triangles = {}\n        for i, tri in enumerate(triangles):\n            p1, p2, p3 = tri\n            edges = [tuple(sorted((p1, p2))), tuple(sorted((p2, p3))), tuple(sorted((p3, p1)))]\n            for edge in edges:\n                if edge not in edge_to_triangles:\n                    edge_to_triangles[edge] = []\n                edge_to_triangles[edge].append(i)\n\n        # Step 2: Iterate through all interior edges and check for local Delaunay property.\n        for edge, tri_indices in edge_to_triangles.items():\n            if len(tri_indices) == 2:  # Interior edge shared by two triangles\n                # Identify the two triangles and their vertices\n                tri1_idx, tri2_idx = tri_indices\n                tri1_verts = triangles[tri1_idx]\n                tri2_verts = triangles[tri2_idx]\n                \n                # Find the vertex in tri1 opposite to the shared edge\n                p_c_idx = next(v for v in tri1_verts if v not in edge)\n                \n                # Find the vertex in tri2 opposite to the shared edge (the test point)\n                p_d_idx = next(v for v in tri2_verts if v not in edge)\n                \n                # The vertices of the first triangle for the circumcircle test\n                p_u_idx, p_v_idx = edge\n                \n                # Get point coordinates\n                p_c = points[p_c_idx]\n                p_d = points[p_d_idx]\n                p_u = points[p_u_idx]\n                p_v = points[p_v_idx]\n\n                # We will test if point p_d is inside the circumcircle of (p_u, p_v, p_c).\n                # To do this robustly, we use a determinant-based in-circle test.\n                \n                # The vertices for the test are a, b, c, d\n                a, b, c, d = p_u, p_v, p_c, p_d\n\n                # Calculate the orientation of triangle (a, b, c)\n                # orient > 0 for CCW, < 0 for CW, = 0 for collinear\n                orient = (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\n\n                # Calculate the 3x3 determinant for the in-circle test.\n                # The matrix is formed using coordinates relative to point d.\n                mat = np.array([\n                    [a[0] - d[0], a[1] - d[1], (a[0] - d[0])**2 + (a[1] - d[1])**2],\n                    [b[0] - d[0], b[1] - d[1], (b[0] - d[0])**2 + (b[1] - d[1])**2],\n                    [c[0] - d[0], c[1] - d[1], (c[0] - d[0])**2 + (c[1] - d[1])**2]\n                ])\n                \n                det = np.linalg.det(mat)\n                \n                # An edge is illegal if the fourth point is strictly inside the circumcircle.\n                # This occurs if `orient * det > 0`.\n                # We use a tolerance to handle floating point inaccuracies for co-circular points.\n                if orient * det > TOLERANCE:\n                    return False\n\n        return True\n\n\n    # Test suite provided in the problem statement\n    test_cases = [\n        # Case A (co-circular hull, either diagonal legal)\n        (np.array([(0.0,0.0),(1.0,0.0),(1.0,1.0),(0.0,1.0)]), \n         [(0,1,2),(0,2,3)]),\n\n        # Case B (non-Delaunay due to an illegal interior edge)\n        (np.array([(0.0,0.0),(2.0,0.0),(2.0,2.0),(0.0,1.1)]), \n         [(0,1,2),(0,2,3)]),\n\n        # Case C (Delaunay for the same points with the other diagonal)\n        (np.array([(0.0,0.0),(2.0,0.0),(2.0,2.0),(0.0,1.1)]), \n         [(0,1,3),(1,2,3)]),\n\n        # Case D (single triangle, trivially Delaunay)\n        (np.array([(0.0,0.0),(2.0,0.0),(1.0,1.7)]), \n         [(0,1,2)])\n    ]\n\n    results = []\n    for points, triangles in test_cases:\n        result = is_delaunay(points, triangles)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output format requires boolean literals to be capitalized\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```", "id": "3281906"}]}