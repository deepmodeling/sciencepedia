{"hands_on_practices": [{"introduction": "Effective problem-solving in number theory often involves transforming a problem into a more manageable form. This exercise [@problem_id:3256445] presents a system of simultaneous congruences that appears complex at first glance. By applying the fundamental definition of modular arithmetic, you can uncover a simple underlying structure, reducing the problem to finding a least common multiple (LCM).", "problem": "A positive integer $x$ is required to satisfy the simultaneous modular relations\n$x \\equiv 1 \\pmod{2}$, $x \\equiv 2 \\pmod{3}$, $x \\equiv 3 \\pmod{4}$, and so on up to $x \\equiv 9 \\pmod{10}$. Using only core definitions from modular arithmetic and divisibility, together with the Euclidean algorithm for the greatest common divisor (gcd) and the definition of least common multiple (lcm), determine the least positive integer $x$ that satisfies all these relations. You may invoke the generalized form of the Chinese Remainder Theorem (CRT) only at the level that it characterizes compatibility and uniqueness modulo an appropriate modulus. Report the exact integer; no rounding is required.", "solution": "The problem requires finding the least positive integer $x$ that satisfies a system of simultaneous linear congruences:\n$x \\equiv 1 \\pmod{2}$\n$x \\equiv 2 \\pmod{3}$\n$x \\equiv 3 \\pmod{4}$\n...\n$x \\equiv 9 \\pmod{10}$\n\nThis system can be expressed more generally as $x \\equiv k \\pmod{k+1}$ for integers $k$ from $1$ to $9$.\n\nFirst, we analyze the structure of each individual congruence. The relation $x \\equiv k \\pmod{k+1}$ is, by definition, equivalent to stating that $k+1$ divides the difference $x-k$.\nWe can manipulate the expression $x-k$ by adding and subtracting $1$:\n$x-k = x+1 - 1 - k = (x+1) - (k+1)$.\nSo, the condition that $k+1$ divides $x-k$ becomes the condition that $k+1$ divides $(x+1) - (k+1)$.\nSince any integer $m$ divides itself, it is always true that $k+1$ divides $k+1$.\nFor $k+1$ to divide the difference of two terms, one of which is a multiple of $k+1$, the other term must also be a multiple of $k+1$.\nTherefore, it must be that $k+1$ divides $x+1$.\nThis is equivalent to the congruence $x+1 \\equiv 0 \\pmod{k+1}$, which can be rewritten as $x \\equiv -1 \\pmod{k+1}$.\n\nApplying this simplification to each congruence in the original system, we obtain an equivalent system:\n$x \\equiv -1 \\pmod{2}$\n$x \\equiv -1 \\pmod{3}$\n$x \\equiv -1 \\pmod{4}$\n...\n$x \\equiv -1 \\pmod{10}$\n\nThis system states that $x$ has a remainder of $-1$ when divided by any integer $m$ in the set $\\{2, 3, 4, 5, 6, 7, 8, 9, 10\\}$. This is equivalent to stating that $x+1$ is divisible by every integer in this set.\nIn other words, $x+1$ must be a common multiple of the integers $2, 3, 4, 5, 6, 7, 8, 9, 10$.\n\nThe problem asks for the *least positive integer* $x$. This requires us to find the smallest positive value for $x+1$ that satisfies the divisibility conditions. The smallest positive common multiple of a set of integers is their least common multiple (lcm).\nLet $L = \\text{lcm}(2, 3, 4, 5, 6, 7, 8, 9, 10)$.\nThe least positive value for $x+1$ is $L$. Thus, the least positive integer $x$ will be $L-1$.\n\nTo compute the lcm, we use the fundamental theorem of arithmetic. We find the prime factorization of each number in the set:\n$2 = 2^1$\n$3 = 3^1$\n$4 = 2^2$\n$5 = 5^1$\n$6 = 2 \\times 3$\n$7 = 7^1$\n$8 = 2^3$\n$9 = 3^2$\n$10 = 2 \\times 5$\n\nThe lcm is the product of the highest power of each prime factor present in any of the factorizations. The prime factors involved are $2$, $3$, $5$, and $7$.\nThe highest power of $2$ is $2^3$ (from the factorization of $8$).\nThe highest power of $3$ is $3^2$ (from the factorization of $9$).\nThe highest power of $5$ is $5^1$ (from the factorizations of $5$ and $10$).\nThe highest power of $7$ is $7^1$ (from the factorization of $7$).\n\nNow we compute the value of $L$:\n$$L = 2^3 \\times 3^2 \\times 5^1 \\times 7^1$$\n$$L = 8 \\times 9 \\times 5 \\times 7$$\n$$L = 72 \\times 35$$\n$$L = 2520$$\n\nSo, the least common multiple is $2520$. This is the least positive value for $x+1$.\nTherefore, the least positive integer $x$ is given by:\n$$x = L - 1 = 2520 - 1 = 2519$$\n\nThe generalized Chinese Remainder Theorem confirms that a solution exists because for any pair of congruences $x \\equiv -1 \\pmod{n_i}$ and $x \\equiv -1 \\pmod{n_j}$, the condition $-1 \\equiv -1 \\pmod{\\gcd(n_i, n_j)}$ is trivially satisfied. The set of all integer solutions is given by $x \\equiv -1 \\pmod{L}$, which is $x \\equiv -1 \\pmod{2520}$. The solutions are of the form $x = 2520k - 1$ for any integer $k$. The least positive solution occurs when $k=1$, which gives $x = 2519$.", "answer": "$$\\boxed{2519}$$", "id": "3256445"}, {"introduction": "The principles of modular arithmetic are the bedrock of classical cryptography and its analysis. This practice problem [@problem_id:3256441] challenges you to act as a cryptanalyst and recover the secret key of an affine cipher from intercepted messages. To do this, you will translate the ciphertext into a system of linear congruences and apply the Extended Euclidean Algorithm to find the modular inverse, a critical step in \"breaking\" the code.", "problem": "An affine cipher over the English alphabet maps a plaintext letter, encoded as an integer, to a ciphertext letter via a linear congruence. The alphabet is encoded using the standard mapping where $A \\mapsto 0$, $B \\mapsto 1$, $\\dots$, $Z \\mapsto 25$. The encryption function is $E(x) \\equiv a x + b \\pmod{26}$, where $x$ is the plaintext integer, $E(x)$ is the ciphertext integer, and the key $(a,b)$ satisfies $\\gcd(a,26)=1$ to ensure invertibility. You are given the following plaintext-ciphertext pairs observed from a single message encrypted under one fixed key:\n- $N \\mapsto R$\n- $U \\mapsto G$\n- $E \\mapsto U$\n- $D \\mapsto D$\n\nUsing the foundational properties of modular arithmetic and the invertibility criterion for linear congruences, recover the unique key $(a,b)$ with $0 \\leq a < 26$ and $0 \\leq b < 26$. Express your final answer as a row matrix $\\begin{pmatrix} a & b \\end{pmatrix}$. No rounding is required, and no units are involved.", "solution": "The problem requires the recovery of the key $(a,b)$ for an affine cipher over the English alphabet of $26$ letters. The encryption function is given as $E(x) \\equiv a x + b \\pmod{26}$, where $x$ is the integer representation of the plaintext letter and $E(x)$ is the integer representation of the ciphertext letter. The alphabet is encoded as $A \\mapsto 0, B \\mapsto 1, \\dots, Z \\mapsto 25$. The key must satisfy the condition $\\gcd(a, 26) = 1$ to ensure the existence of a unique decryption function. The key parameters are constrained by $0 \\leq a < 26$ and $0 \\leq b < 26$.\n\nFirst, we translate the given plaintext-ciphertext letter pairs into their corresponding integer representations:\n\\begin{itemize}\n    \\item $N \\mapsto R$: The plaintext letter $N$ is the $14$-th letter, so its integer representation is $x_1 = 13$. The ciphertext letter $R$ is the $18$-th letter, so its integer representation is $E(x_1) = 17$.\n    \\item $U \\mapsto G$: The plaintext letter $U$ corresponds to $x_2 = 20$. The ciphertext letter $G$ corresponds to $E(x_2) = 6$.\n    \\item $E \\mapsto U$: The plaintext letter $E$ corresponds to $x_3 = 4$. The ciphertext letter $U$ corresponds to $E(x_3) = 20$.\n    \\item $D \\mapsto D$: The plaintext letter $D$ corresponds to $x_4 = 3$. The ciphertext letter $D$ corresponds to $E(x_4) = 3$.\n\\end{itemize}\n\nThese pairs yield a system of four linear congruences in the two unknown variables $a$ and $b$:\n\\begin{enumerate}\n    \\item $E(13) = 17 \\implies a(13) + b \\equiv 17 \\pmod{26}$\n    \\item $E(20) = 6 \\implies a(20) + b \\equiv 6 \\pmod{26}$\n    \\item $E(4) = 20 \\implies a(4) + b \\equiv 20 \\pmod{26}$\n    \\item $E(3) = 3 \\implies a(3) + b \\equiv 3 \\pmod{26}$\n\\end{enumerate}\n\nTo solve for $a$ and $b$, we can select any two of these congruences. Let us use the first two.\n$$13a + b \\equiv 17 \\pmod{26}$$\n$$20a + b \\equiv 6 \\pmod{26}$$\nSubtracting the second congruence from the first gives:\n$$(13a + b) - (20a + b) \\equiv 17 - 6 \\pmod{26}$$\n$$-7a \\equiv 11 \\pmod{26}$$\nSince $-7 \\equiv 19 \\pmod{26}$, we can write:\n$$19a \\equiv 11 \\pmod{26}$$\nTo solve for $a$, we must find the multiplicative inverse of $19$ modulo $26$. This inverse exists if and only if $\\gcd(19, 26) = 1$. We apply the Extended Euclidean Algorithm:\n\\begin{align*} 26 &= 1 \\cdot 19 + 7 \\\\ 19 &= 2 \\cdot 7 + 5 \\\\ 7 &= 1 \\cdot 5 + 2 \\\\ 5 &= 2 \\cdot 2 + 1 \\end{align*}\nThe greatest common divisor is $1$, so the inverse exists. Now, we express $1$ as a linear combination of $19$ and $26$:\n\\begin{align*} 1 &= 5 - 2 \\cdot 2 \\\\ &= 5 - 2 \\cdot (7 - 1 \\cdot 5) = 5 - 2 \\cdot 7 + 2 \\cdot 5 = 3 \\cdot 5 - 2 \\cdot 7 \\\\ &= 3 \\cdot (19 - 2 \\cdot 7) - 2 \\cdot 7 = 3 \\cdot 19 - 6 \\cdot 7 - 2 \\cdot 7 = 3 \\cdot 19 - 8 \\cdot 7 \\\\ &= 3 \\cdot 19 - 8 \\cdot (26 - 1 \\cdot 19) = 3 \\cdot 19 - 8 \\cdot 26 + 8 \\cdot 19 \\\\ &= 11 \\cdot 19 - 8 \\cdot 26 \\end{align*}\nFrom the equation $11 \\cdot 19 - 8 \\cdot 26 = 1$, we deduce that $11 \\cdot 19 \\equiv 1 \\pmod{26}$. Thus, the multiplicative inverse of $19$ modulo $26$ is $11$.\n\nNow we multiply both sides of the congruence $19a \\equiv 11 \\pmod{26}$ by $11$:\n$$11 \\cdot (19a) \\equiv 11 \\cdot 11 \\pmod{26}$$\n$$1a \\equiv 121 \\pmod{26}$$\nTo simplify $121 \\pmod{26}$, we perform the division: $121 = 4 \\times 26 + 17$. Therefore, $121 \\equiv 17 \\pmod{26}$.\nSo, we have $a \\equiv 17 \\pmod{26}$. Given the constraint $0 \\leq a < 26$, we find $a = 17$.\nWe must verify that this value for $a$ satisfies the invertibility condition $\\gcd(a, 26) = 1$. Indeed, $\\gcd(17, 26) = 1$ since $17$ is a prime number and does not divide $26 = 2 \\times 13$.\n\nNext, we substitute $a = 17$ into one of the original congruences to find $b$. Using the first congruence, $13a + b \\equiv 17 \\pmod{26}$:\n$$13(17) + b \\equiv 17 \\pmod{26}$$\n$$221 + b \\equiv 17 \\pmod{26}$$\nWe evaluate $221 \\pmod{26}$: $221 = 8 \\times 26 + 13$, so $221 \\equiv 13 \\pmod{26}$.\nThe congruence becomes:\n$$13 + b \\equiv 17 \\pmod{26}$$\n$$b \\equiv 17 - 13 \\pmod{26}$$\n$$b \\equiv 4 \\pmod{26}$$\nGiven the constraint $0 \\leq b < 26$, we find $b = 4$.\n\nThe candidate key is $(a,b) = (17,4)$. We must verify that this key satisfies the two remaining congruences to ensure the provided data is consistent.\nFor congruence (3), $4a + b \\equiv 20 \\pmod{26}$:\n$$4(17) + 4 = 68 + 4 = 72$$\nWe check if $72 \\equiv 20 \\pmod{26}$. $72 = 2 \\times 26 + 20 = 52 + 20$. This is true.\nFor congruence (4), $3a + b \\equiv 3 \\pmod{26}$:\n$$3(17) + 4 = 51 + 4 = 55$$\nWe check if $55 \\equiv 3 \\pmod{26}$. $55 = 2 \\times 26 + 3 = 52 + 3$. This is also true.\n\nAll four plaintext-ciphertext pairs are consistent with the key $(a,b) = (17,4)$. The key satisfies all the conditions of the problem.\nThe recovered key is $(a,b) = (17,4)$.", "answer": "$$\\boxed{\\begin{pmatrix} 17 & 4 \\end{pmatrix}}$$", "id": "3256441"}, {"introduction": "The security of modern cryptosystems like RSA relies on the difficulty of factoring large numbers. However, specific weaknesses can be exploited if keys are not generated carefully, as this hands-on coding challenge [@problem_id:3256532] demonstrates. You will implement an attack based on Fermat's factorization method, which is highly effective when the prime factors of the RSA modulus $N$ are close, and use it to recover the full private key and decrypt a message.", "problem": "You are given a public Rivest–Shamir–Adleman (RSA) key composed of a modulus $N$ and a public exponent $e$. The modulus $N$ is the product of two odd integers, typically two large primes $p$ and $q$. In this task, you must design and implement an attack that is effective when $p$ and $q$ are very close, using only the following foundational facts and definitions:\n- In modular arithmetic, for integers $a$, $b$, and $n$, the relation $a \\equiv b \\pmod{n}$ means $n$ divides $a-b$.\n- The greatest common divisor (gcd) of two integers $x$ and $y$, denoted $\\gcd(x,y)$, is the largest integer that divides both $x$ and $y$.\n- An odd integer can be represented as the difference of two squares under suitable conditions.\n- The multiplicative inverse of $e$ modulo $\\varphi(N)$, where $\\varphi(N)$ is Euler’s totient function, is an integer $d$ such that $ed \\equiv 1 \\pmod{\\varphi(N)}$.\n- For a modulus $N=pq$ with distinct primes $p$ and $q$, $\\varphi(N)=(p-1)(q-1)$. For a prime power $N=p^2$, $\\varphi(N)=p(p-1)$.\n\nYour program must:\n1. Factor $N$ by building from the difference-of-squares observation when $p$ and $q$ are close, and recover $p$ and $q$.\n2. Compute $\\varphi(N)$ according to the structure of $N$ discovered by your factorization.\n3. Compute the modular inverse $d$ of $e$ modulo $\\varphi(N)$ using the Extended Euclidean Algorithm (EEA), and verify $ed \\equiv 1 \\pmod{\\varphi(N)}$.\n4. For each test case, construct a ciphertext $c$ from a given message $m$ using $c \\equiv m^e \\pmod{N}$, then use the recovered $d$ to decrypt and recover $m$ by computing $m_{\\text{recovered}} \\equiv c^d \\pmod{N}$.\n5. Use an iteration budget $B=5000$ for your factorization step; if factorization does not succeed within $B$ iterations, treat the test case as a failure.\n\nYou must not rely on any special-purpose factorization libraries or black-box routines; all logic must be derived from the listed foundational facts. Use integer arithmetic only.\n\nTest Suite:\n- Case 1 (happy path, large $N$ with close primes):\n  - $N=1000036000099$, $e=65537$, $m=123456789$.\n- Case 2 (boundary path, primes differing by $2$):\n  - $N=10403$, $e=11$, $m=1234$.\n- Case 3 (edge case, square modulus $N=p^2$):\n  - $N=100140049$, $e=17$, $m=67890$.\n- Case 4 (failure path, primes not close enough for budget $B$):\n  - $N=200250077$, $e=65537$, $m=424242$.\n\nOutput Specification:\n- For each test case, if factorization succeeds within the iteration budget $B$, output the four-integer list $[p,q,d,m_{\\text{recovered}}]$ in that order.\n- If factorization fails within the budget $B$, output the boolean $False$.\n- Your program should produce a single line of output containing the results for all test cases, aggregated as a comma-separated list enclosed in square brackets. For example, it should look like $[ [p_1,q_1,d_1,m_1], False, [p_3,q_3,d_3,m_3], [p_4,q_4,d_4,m_4] ]$ but with no spaces: $[[p_1,q_1,d_1,m_1],False,[p_3,q_3,d_3,m_3],[p_4,q_4,d_4,m_4]]$.", "solution": "The problem requires the implementation of a specific cryptographic attack against RSA, effective when the two prime factors of the modulus $N$ are close to each other. This attack is based on Fermat's factorization method. The solution involves several steps: factoring $N$, computing Euler's totient function $\\varphi(N)$, finding the private exponent $d$, and finally demonstrating decryption.\n\n### Step 1: Factorization of $N$ using Fermat's Method\n\nThe core of the attack relies on the fact that the modulus $N$ is a product of two close, odd integers $p$ and $q$. Let $p \\le q$. Since they are close, their arithmetic mean, $a = \\frac{p+q}{2}$, will be an integer slightly larger than their geometric mean, $\\sqrt{pq} = \\sqrt{N}$.\n\nLet's define two integers, $a$ and $b$:\n$$ a = \\frac{q+p}{2} $$\n$$ b = \\frac{q-p}{2} $$\nSince $p$ and $q$ are both odd, their sum ($q+p$) and difference ($q-p$) are even, ensuring that $a$ and $b$ are integers.\n\nFrom these definitions, we can express $p$ and $q$ in terms of $a$ and $b$:\n$$ p = a-b $$\n$$ q = a+b $$\n\nSubstituting these into the expression for $N$:\n$$ N = pq = (a-b)(a+b) = a^2 - b^2 $$\nThis equation can be rearranged as:\n$$ a^2 - N = b^2 $$\n\nThis identity is the foundation of Fermat's factorization method. To factor $N$, we search for an integer $a$ such that $a^2 - N$ is a perfect square, say $b^2$. Once such a pair $(a, b)$ is found, the factors of $N$ are immediately recovered as $p = a-b$ and $q = a+b$.\n\nThe search for $a$ starts from the smallest possible integer value it could take. Since $a = \\frac{p+q}{2}$ and from the AM-GM inequality $\\frac{p+q}{2} \\ge \\sqrt{pq}$, we know $a \\ge \\sqrt{N}$. Therefore, the search for $a$ can begin at $a_0 = \\lceil\\sqrt{N}\\rceil$.\n\nThe algorithm is as follows:\n1.  Initialize the search value $a$ to $\\lceil\\sqrt{N}\\rceil$. In integer arithmetic, this is `math.isqrt(N)` if $N$ is a perfect square, or `math.isqrt(N) + 1` otherwise.\n2.  Iterate for a maximum of $B$ times, where $B$ is the given iteration budget ($B=5000$).\n3.  In each iteration, calculate $b^2 = a^2 - N$.\n4.  Check if $b^2$ is a perfect square. This can be verified using integer arithmetic by computing $b = \\text{isqrt}(b^2)$ and checking if $b \\times b = b^2$.\n5.  If $b^2$ is a perfect square, we have found our solution. The factors are $p = a - b$ and $q = a + b$. The iteration stops.\n6.  If $b^2$ is not a perfect square, increment $a$ by $1$ and continue to the next iteration.\n7.  If the loop completes without finding a solution, the factorization has failed within the given budget.\n\nA special case is when $N$ is a perfect square, i.e., $N=p^2$. In this situation, the first value of $a$ tested will be $a = \\sqrt{N} = p$. This results in $b^2 = a^2 - N = p^2 - p^2 = 0$, which is a perfect square. Thus, $b=0$, and the factors are correctly identified as $p=a-b=p$ and $q=a+b=p$.\n\n### Step 2: Computation of Euler's Totient Function $\\varphi(N)$\n\nAfter successfully factoring $N$ into $p$ and $q$, we compute Euler's totient function, $\\varphi(N)$. The formula for $\\varphi(N)$ depends on whether the factors are distinct.\n-   If $p$ and $q$ are distinct ($p \\neq q$), then $\\varphi(N) = (p-1)(q-1)$.\n-   If $p=q$ (i.e., $N=p^2$), then $\\varphi(N) = p(p-1)$.\n\nThis value is crucial for the next step, as it defines the modulus for the private exponent calculation.\n\n### Step 3: Computation of the Private Exponent $d$\n\nThe RSA private exponent $d$ is the multiplicative inverse of the public exponent $e$ modulo $\\varphi(N)$. This is defined by the congruence relation:\n$$ ed \\equiv 1 \\pmod{\\varphi(N)} $$\nTo find $d$, we use the Extended Euclidean Algorithm (EEA). The EEA finds integers $x$ and $y$ that satisfy Bézout's identity for two integers $e$ and $\\varphi(N)$:\n$$ ex + \\varphi(N)y = \\gcd(e, \\varphi(N)) $$\nFor a valid RSA key, $\\gcd(e, \\varphi(N))$ must be $1$. In this case, taking the equation modulo $\\varphi(N)$, we get:\n$$ ex \\equiv 1 \\pmod{\\varphi(N)} $$\nThus, the integer $x$ returned by the EEA is a modular inverse of $e$. The value of $x$ might be negative, so the final value for $d$ is taken as $x \\pmod{\\varphi(N)}$, typically in the range $[1, \\varphi(N)-1]$.\n\n### Step 4: Encryption and Decryption\n\nWith all components of the private key materialized, we can perform decryption.\nFirst, a given message $m$ is encrypted to produce ciphertext $c$ using the public key $(N, e)$:\n$$ c \\equiv m^e \\pmod{N} $$\nThen, the ciphertext $c$ is decrypted back to the original message using the private key $(N, d)$:\n$$ m_{\\text{recovered}} \\equiv c^d \\pmod{N} $$\nModular exponentiation (e.g., binary exponentiation) is used for efficient computation of these large powers. The final result should be $m_{\\text{recovered}} = m$, confirming the correctness of the recovered private key.\nFor each test case, the final output is either the list $[p, q, d, m_{\\text{recovered}}]$ or, if factorization fails, the boolean value `False`.", "answer": "```python\nimport math\nimport numpy as np\n\ndef extended_euclidean_algorithm(a, b):\n    \"\"\"\n    Returns (gcd, x, y) such that a*x + b*y = gcd(a, b).\n    Handles large integers.\n    \"\"\"\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x1, y1 = extended_euclidean_algorithm(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n\ndef mod_inverse(e, phi):\n    \"\"\"\n    Computes the modular multiplicative inverse of e modulo phi.\n    \"\"\"\n    gcd, x, _ = extended_euclidean_algorithm(e, phi)\n    if gcd != 1:\n        # This case should not be reached for valid RSA parameters\n        # but is a safeguard.\n        raise ValueError('Modular inverse does not exist')\n    return (x % phi + phi) % phi\n\ndef is_perfect_square(n):\n    \"\"\"\n    Checks if n is a perfect square using integer arithmetic.\n    Returns (bool, integer_sqrt)\n    \"\"\"\n    if n < 0:\n        return False, -1\n    if n == 0:\n        return True, 0\n    x = math.isqrt(n)\n    return x * x == n, x\n\ndef factorize_fermats(N, B):\n    \"\"\"\n    Factors N using Fermat's factorization method within a budget B.\n    \"\"\"\n    # N must be odd for this method to be defined with integer a, b.\n    # The problem statement guarantees this.\n    \n    a_start = math.isqrt(N)\n\n    # Handle the case where N is a perfect square.\n    if a_start * a_start == N:\n        return a_start, a_start\n\n    # If not a perfect square, start search from ceil(sqrt(N)).\n    a_start += 1\n    \n    for i in range(B):\n        a = a_start + i\n        b_squared = a * a - N\n        \n        is_sq, b = is_perfect_square(b_squared)\n        if is_sq:\n            p = a - b\n            q = a + b\n            # A final check to ensure factors are correct.\n            if p * q == N:\n                # Return factors sorted, as per convention.\n                return min(p, q), max(p, q)\n    \n    # Return None if factorization fails within budget\n    return None, None\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, large N with close primes)\n        (1000036000099, 65537, 123456789),\n        # Case 2 (boundary path, primes differing by 2)\n        (10403, 11, 1234),\n        # Case 3 (edge case, square modulus N=p^2)\n        (100140049, 17, 67890),\n        # Case 4 (failure path, primes not close enough)\n        (200250077, 65537, 424242),\n    ]\n    budget_B = 5000\n    results = []\n\n    for N, e, m in test_cases:\n        p, q = factorize_fermats(N, budget_B)\n\n        if p is None:\n            results.append(False)\n            continue\n\n        phi_N = 0\n        if p == q:\n            # Case N = p^2\n            phi_N = p * (p - 1)\n        else:\n            # Case N = p*q with distinct p, q\n            phi_N = (p - 1) * (q - 1)\n        \n        # Compute private exponent d\n        d = mod_inverse(e, phi_N)\n        \n        # Encrypt the message m\n        c = pow(m, e, N)\n        \n        # Decrypt the ciphertext c\n        m_recovered = pow(c, d, N)\n        \n        results.append([p, q, d, m_recovered])\n\n    # Format the final output string exactly as specified\n    formatted_results = []\n    for res in results:\n        if isinstance(res, list):\n            formatted_results.append(f\"[{','.join(map(str, res))}]\")\n        else:\n            formatted_results.append(str(res).lower()) # For 'False' to be 'false' if needed, but problem implies False\n    \n    # Python's bool `str(False)` is `False` which is perfect.\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3256532"}]}