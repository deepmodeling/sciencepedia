{"hands_on_practices": [{"introduction": "A cornerstone of computational geometry is the plane sweep algorithm, a powerful paradigm that solves two-dimensional problems by reducing them to a series of one-dimensional ones. This exercise challenges you to apply this technique to a classic problem: calculating the area of the union of multiple axis-aligned rectangles. Successfully solving this problem requires not only understanding the plane sweep concept but also implementing an efficient data structure, like a segment tree, to manage the changing state on the sweep line [@problem_id:3223497].", "problem": "You are given a finite collection of axis-aligned rectangles in the Euclidean plane. Each rectangle is specified by four integers $(x_1, y_1, x_2, y_2)$ with $x_1 \\le x_2$ and $y_1 \\le y_2$, representing the lower-left corner $(x_1, y_1)$ and the upper-right corner $(x_2, y_2)$. A rectangle with $x_1 = x_2$ or $y_1 = y_2$ has zero area and does not contribute to the union area. The task is to compute the area of the union of these rectangles efficiently, using a plane sweep algorithm grounded in first principles from computational geometry.\n\nFundamental base and requirements:\n- The area of a union of sets in the plane is the two-dimensional Lebesgue measure of the union. For axis-aligned rectangles, the union area is finite and well-defined under the usual Euclidean metric.\n- Rectangles are closed sets, but the union area is invariant under any choice of closed, open, or half-open boundary conventions for axis-aligned rectangles, provided all rectangles use the same convention, because boundaries have measure zero.\n- A valid approach is to conceptually sweep a vertical line across the $x$-axis, maintaining the total length of the union of the currently active $y$-intervals. The area accumulated between two successive $x$-positions equals the horizontal distance times the covered $y$-length over that slab.\n\nYour program must implement an efficient plane sweep along the $x$-axis and maintain the union length of $y$-intervals using an appropriate data structure such as a Segment Tree (ST) with coordinate compression. The asymptotic time complexity target is $O(n \\log n)$ for $n$ rectangles. You must handle duplicates, nested rectangles, disjoint rectangles, touching edges, zero-area rectangles, negative coordinates, and large coordinate values without overflow beyond typical $64$-bit integer ranges.\n\nTest suite:\nCompute the union area for each of the following independent test cases. In each test case, the input is a list of rectangles given as $(x_1,y_1,x_2,y_2)$ quadruples.\n\n- Test case $1$: $\\big((0,0,3,2),(2,1,5,4),(1,3,4,5)\\big)$\n- Test case $2$: $\\big((0,0,2,1),(2,0,4,1)\\big)$\n- Test case $3$: $\\big((0,0,10,10),(2,2,8,8)\\big)$\n- Test case $4$: $\\big((0,0,1,1),(3,3,4,5)\\big)$\n- Test case $5$: $\\big((0,0,2,2),(1,1,1,5),(2,2,5,2)\\big)$\n- Test case $6$: $\\big((-3,-1,-1,2),(-2,1,1,3)\\big)$\n- Test case $7$: $\\big((0,0,100000000,1),(50000000,0,150000000,1)\\big)$\n- Test case $8$: $\\big((0,0,3,1),(0,1,3,2),(0,2,3,3),(1,-1,2,4)\\big)$\n\nOutput specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The $i$-th entry is the union area for test case $i$, expressed as an integer. For example, the format must be exactly like $\\texttt{[a_1,a_2,\\dots,a_8]}$, where $a_i$ denotes the computed area for test case $i$.", "solution": "The problem of finding the union area of axis-aligned rectangles is solved efficiently using a plane sweep algorithm. A conceptual vertical line is swept across the plane from left to right. The \"events\" for the sweep line are the x-coordinates of the left and right edges of the rectangles.\n\nBetween any two consecutive event x-coordinates, the set of \"active\" rectangles (those intersected by the sweep line) remains constant. The core task is to determine the total length of the vertical segments covered by these active rectangles. This total covered length, when multiplied by the horizontal distance between the two event x-coordinates, yields the area of a vertical \"slab\". The total union area is the sum of the areas of all such slabs.\n\nTo efficiently calculate the total covered vertical length at each step, we use a specialized data structure, a Segment Tree. First, all unique y-coordinates from the rectangles are collected and sorted. These sorted coordinates define a set of elementary y-intervals. The Segment Tree operates on these intervals. Each node in the tree corresponds to a range of y-intervals and stores two key pieces of information: a `count` (how many active rectangles completely cover this node's range) and a `length` (the total length of the y-intervals within this node's range that are covered by at least one rectangle).\n\nAs the sweep line moves from one event to the next:\n1.  The area of the slab between the previous and current event is calculated using the total covered length stored at the root of the Segment Tree.\n2.  The Segment Tree is updated based on the current event. If it's a left edge of a rectangle, the `count` is incremented for all y-intervals corresponding to that rectangle. If it's a right edge, the `count` is decremented.\n\nThis approach, combining a plane sweep with a segment tree and coordinate compression, solves the problem in $O(n \\log n)$ time, where $n$ is the number of rectangles.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the union area of rectangles problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        [(0, 0, 3, 2), (2, 1, 5, 4), (1, 3, 4, 5)],\n        # Test case 2\n        [(0, 0, 2, 1), (2, 0, 4, 1)],\n        # Test case 3\n        [(0, 0, 10, 10), (2, 2, 8, 8)],\n        # Test case 4\n        [(0, 0, 1, 1), (3, 3, 4, 5)],\n        # Test case 5\n        [(0, 0, 2, 2), (1, 1, 1, 5), (2, 2, 5, 2)],\n        # Test case 6\n        [(-3, -1, -1, 2), (-2, 1, 1, 3)],\n        # Test case 7\n        [(0, 0, 100000000, 1), (50000000, 0, 150000000, 1)],\n        # Test case 8\n        [(0, 0, 3, 1), (0, 1, 3, 2), (0, 2, 3, 3), (1, -1, 2, 4)],\n    ]\n\n    results = []\n    for rectangles in test_cases:\n        area = calculate_union_area(rectangles)\n        results.append(area)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_union_area(rectangles):\n    \"\"\"\n    Calculates the area of the union of a list of axis-aligned rectangles.\n    \n    This function implements a plane sweep algorithm with a segment tree.\n    \"\"\"\n    events = []\n    y_coords = set()\n\n    for x1, y1, x2, y2 in rectangles:\n        # Per the problem statement, zero-area rectangles do not contribute.\n        if x1  x2 and y1  y2:\n            events.append((x1, y1, y2, 1))  # 1 for enter\n            events.append((x2, y1, y2, -1)) # -1 for leave\n            y_coords.add(y1)\n            y_coords.add(y2)\n\n    if not events:\n        return 0\n\n    # Sort events by x-coordinate\n    events.sort()\n\n    # Coordinate compression for y-coordinates\n    all_y = sorted(list(y_coords))\n    y_map = {y: i for i, y in enumerate(all_y)}\n    \n    num_y_intervals = len(all_y) - 1\n    if num_y_intervals = 0:\n        return 0\n\n    # Segment tree represented by numpy arrays.\n    # The size 4 * num_y_intervals is a safe upper bound for a segment tree.\n    counts = np.zeros(4 * num_y_intervals, dtype=int)\n    lengths = np.zeros(4 * num_y_intervals, dtype=int)\n\n\n    def update_segment_tree(node_idx, node_start, node_end, update_start, update_end, value):\n        \"\"\"Recursively update the segment tree.\"\"\"\n        # The range this node represents is [node_start, node_end].\n        # The range to update is [update_start, update_end].\n\n        # If the update range is outside the node's range, do nothing.\n        if update_start > node_end or update_end  node_start:\n            return\n\n        # If the node's range is completely within the update range.\n        if update_start = node_start and node_end = update_end:\n            counts[node_idx] += value\n        # Otherwise, recurse on children.\n        else:\n            mid = (node_start + node_end) // 2\n            left_child_idx = 2 * node_idx + 1\n            right_child_idx = 2 * node_idx + 2\n            update_segment_tree(left_child_idx, node_start, mid, update_start, update_end, value)\n            update_segment_tree(right_child_idx, mid + 1, node_end, update_start, update_end, value)\n        \n        # After updating counts, recalculate the covered length for this node.\n        if counts[node_idx] > 0:\n            # This node's entire y-interval range is covered.\n            lengths[node_idx] = all_y[node_end + 1] - all_y[node_start]\n        elif node_start == node_end:\n            # Leaf node with count 0 has 0 covered length.\n            lengths[node_idx] = 0\n        else:\n            # Internal node with count 0: covered length is sum of children's.\n            left_child_idx = 2 * node_idx + 1\n            right_child_idx = 2 * node_idx + 2\n            lengths[node_idx] = lengths[left_child_idx] + lengths[right_child_idx]\n\n\n    total_area = 0\n    last_x = events[0][0]\n\n    for event in events:\n        current_x, y1, y2, type_val = event\n        \n        # Calculate the area of the slab between last_x and current_x\n        dx = current_x - last_x\n        if dx > 0:\n            covered_length = lengths[0]  # Root of the segment tree\n            total_area += covered_length * dx\n        \n        # Process the current event by updating the segment tree\n        y1_idx = y_map[y1]\n        y2_idx = y_map[y2]\n\n        # The update is for the range of intervals [y1_idx, y2_idx - 1]\n        if y1_idx  y2_idx:\n            update_segment_tree(0, 0, num_y_intervals - 1, y1_idx, y2_idx - 1, type_val)\n\n        last_x = current_x\n        \n    return total_area\n\n# Execute the solution\nsolve()\n\n```", "id": "3223497"}, {"introduction": "Moving beyond axis-aligned shapes, this practice explores proximity queries for general convex polygons, a common task in fields like robotics and collision detection. You are asked to find the shortest \"bridge\" connecting two disjoint convex polygons by developing a solution from first principles [@problem_id:3223483]. This exercise will sharpen your skills in geometric decomposition, reducing a complex problem to a series of well-defined calculations between simpler primitives like line segments.", "problem": "You are given two closed, strictly disjoint, convex polygons in the Euclidean plane. For each pair, you must compute a shortest connecting line segment (a \"bridge\") that has one endpoint on the boundary of polygon $A$ and the other endpoint on the boundary of polygon $B$. The problem must be solved from first principles of computational geometry without relying on any specialized third-party libraries beyond basic vector arithmetic.\n\nFundamental base and definitions to be used are as follows. A convex polygon $P$ is a compact convex subset of $\\mathbb{R}^2$ given as the convex hull of finitely many points; it can be represented by a cyclic sequence of vertices in counterclockwise (CCW) order, with consecutive vertices connected by straight line segments, and the last vertex connected back to the first. The Euclidean norm of a vector $x$ is $\\lVert x \\rVert_2 = \\sqrt{x_1^2 + x_2^2}$. The distance between two nonempty sets $X,Y \\subset \\mathbb{R}^2$ is $d(X,Y) = \\inf\\{\\lVert x - y \\rVert_2 : x \\in X, y \\in Y\\}$. For closed, disjoint, convex sets, this infimum is attained by at least one pair of points. A line segment between points $p$ and $q$ is the set $\\{(1 - t)p + tq : t \\in [0,1]\\}$.\n\nYour task. For each test case below, do the following:\n- Compute a pair of points $(p^\\star, q^\\star)$ with $p^\\star \\in \\partial A$ and $q^\\star \\in \\partial B$ that minimizes the Euclidean distance $\\lVert p - q \\rVert_2$ over all $p \\in \\partial A$, $q \\in \\partial B$. Here $\\partial A$ and $\\partial B$ denote the polygon boundaries.\n- Among all minimizing pairs, break ties as follows: choose the pair where the point on $A$ is lexicographically smallest, and then, if still tied, the point on $B$ is lexicographically smallest, where lexicographic order on points uses $(x_1,y_1) \\prec (x_2,y_2)$ if either $x_1  x_2$ or $(x_1 = x_2$ and $y_1  y_2)$.\n- Report the bridge endpoints and its length.\n\nAngle units are not needed. No physical units are involved. The required numeric output must be rounded to $6$ decimal places.\n\nInput model for this problem is fixed within the program; do not read any external input. You must use the following test suite of convex polygons, each given as an ordered list of vertices in CCW order and without repeating the first vertex at the end.\n\nTest suite:\n- Test case $1$:\n  - Polygon $A$: $[(-2,-1),(-2,1),(-1,1),(-1,-1)]$.\n  - Polygon $B$: $[(1,-0.5),(1,0.5),(2,0.5),(2,-0.5)]$.\n- Test case $2$:\n  - Polygon $A$: $[(0,0),(1,1),(0,2)]$.\n  - Polygon $B$: $[(3,0.5),(3,1.5),(5,1.5),(5,0.5)]$.\n- Test case $3$:\n  - Polygon $A$: $[(0,0),(0,1),(4,1),(4,0)]$.\n  - Polygon $B$: $[(1,3),(1,4),(5,4),(5,3)]$.\n- Test case $4$:\n  - Polygon $A$: $[(0,0),(0,1),(1,1),(1,0)]$.\n  - Polygon $B$: $[(1.001,0),(1.001,1),(2.001,1),(2.001,0)]$.\n- Test case $5$:\n  - Polygon $A$: $[(0,0),(0,1),(1,1),(1,0)]$.\n  - Polygon $B$: $[(3,3),(3,4),(4,4),(4,3)]$.\n\nRequirements:\n- For each test case, output the coordinates of the selected bridge endpoints $(p^\\star_x,p^\\star_y)$ on $A$ and $(q^\\star_x,q^\\star_y)$ on $B$, followed by the bridge length $\\ell^\\star = \\lVert p^\\star - q^\\star \\rVert_2$, all rounded to $6$ decimal places.\n- The final output format must be a single line containing a JSON-like list of lists, one per test case, in order. Each inner list must be of the form $[p^\\star_x,p^\\star_y,q^\\star_x,q^\\star_y,\\ell^\\star]$ with all numbers rounded to $6$ decimal places. For example, a list with two results would look like $[[x_1,y_1,x_2,y_2,\\ell_1],[x_3,y_3,x_4,y_4,\\ell_2]]$.\n\nDesign constraints and guidance:\n- Base your reasoning on fundamental definitions: convexity, Euclidean norm, and properties of continuous functions on compact sets.\n- You may assume a well-known and verifiable fact from elementary geometry: the distance between two disjoint closed convex polygons is achieved by a pair of points lying on their boundaries, and for polygons, the minimizers occur on edges or vertices. However, you must not use any pre-derived \"shortcut\" formula for the final distance. Instead, derive the distance between two line segments by minimizing a quadratic form subject to box constraints on segment parameters.\n- To ensure full coverage, the given test suite includes cases where the closest points lie vertex-to-edge, edge-to-edge with parallel supporting lines, vertex-to-vertex, and a near-contact situation.\n\nYour program should produce a single line of output containing the results as a comma-separated list of the inner lists, enclosed in square brackets, exactly as specified above.", "solution": "The problem requires us to find the shortest connecting line segment, or \"bridge\", between two disjoint closed convex polygons, $A$ and $B$, in the Euclidean plane. For each pair of polygons, we must identify the pair of points $(p^\\star, q^\\star)$ on their respective boundaries, $\\partial A$ and $\\partial B$, that minimizes the Euclidean distance $\\lVert p - q \\rVert_2$.\n\nThe solution is founded on fundamental principles of geometry and optimization. Since the polygons are convex and compact (closed and bounded), the existence of at least one such minimizing pair of points is guaranteed by the Weierstrass extreme value theorem. The distance between the two polygons $d(A, B)$ is the minimum of the distances between all possible pairs of features (vertices and edges) of the two polygons. This can be expressed as:\n$$\nd(A, B) = \\min_{i,j} d(e_i, f_j)\n$$\nwhere $e_i$ is an edge of polygon $A$ and $f_j$ is an edge of polygon $B$. This approach is comprehensive as the distance between an edge and another feature implicitly covers vertex-to-feature distances, since vertices are endpoints of edges.\n\nThe core of the problem, as guided by the prompt, is to determine the distance between two line segments. Let a line segment $e_A$ be defined by its endpoints $p_1, p_2$ and another segment $e_B$ by $q_1, q_2$. Any point on $e_A$ can be parameterized as $p(s) = p_1 + s(p_2 - p_1)$ for $s \\in [0,1]$, and any point on $e_B$ as $q(t) = q_1 + t(q_2 - q_1)$ for $t \\in [0,1]$.\n\nWe aim to minimize the squared Euclidean distance $D^2(s,t) = \\lVert p(s) - q(t) \\rVert_2^2$, subject to $s,t \\in [0,1]$. Let $u = p_2 - p_1$, $v = q_2 - q_1$, and $w_0 = p_1 - q_1$. The squared distance is:\n$$\nD^2(s,t) = \\lVert w_0 + su - tv \\rVert_2^2 = (w_0+su-tv) \\cdot (w_0+su-tv)\n$$\nThis is a quadratic function of $s$ and $t$:\n$$\nF(s,t) = (u \\cdot u)s^2 - 2(u \\cdot v)st + (v \\cdot v)t^2 + 2(w_0 \\cdot u)s - 2(w_0 \\cdot v)t + (w_0 \\cdot w_0)\n$$\nSince this function is convex, its minimum over the domain $[0,1] \\times [0,1]$ occurs either at an interior critical point where the gradient is zero, or on the boundary of the domain.\n\nThe critical point $(s_0, t_0)$ is found by solving the linear system $\\nabla F(s,t) = 0$:\n$$\n\\begin{cases}\n(u \\cdot u) s - (u \\cdot v) t = -w_0 \\cdot u \\\\\n-(u \\cdot v) s + (v \\cdot v) t = w_0 \\cdot v\n\\end{cases}\n$$\nThe determinant of the system matrix is $(u \\cdot u)(v \\cdot v) - (u \\cdot v)^2$, which is non-negative by the Cauchy-Schwarz inequality. If the determinant is positive (the segments are not parallel), a unique solution $(s_0, t_0)$ exists.\n- If $(s_0, t_0) \\in [0,1] \\times [0,1]$, the shortest distance is between the interior points $p(s_0)$ and $q(t_0)$.\n- Otherwise, the minimum must lie on the boundary of the parameter space (i.e., $s \\in \\{0,1\\}$ or $t \\in \\{0,1\\}$). This corresponds to finding the distance from an endpoint of one segment to the entirety of the other segment.\n\nThis suggests a robust strategy for finding the distance between two segments:\n1.  Calculate the distance for the interior-to-interior case, valid only if solved parameters $(s_0, t_0)$ are in $[0,1]^2$.\n2.  Calculate the four endpoint-to-segment distances: $d(p_1, e_B)$, $d(p_2, e_B)$, $d(q_1, e_A)$, and $d(q_2, e_A)$.\n3.  The minimal of these potential distances is the true minimum distance between the segments. This covers all cases: vertex-vertex, vertex-edge, and edge-edge.\n\nThe overall algorithm proceeds in two passes:\n**Pass 1: Determine the minimum distance.**\nIterate through all pairs of edges $(e_i, f_j)$ from polygons $A$ and $B$, respectively. For each pair, compute their minimum squared distance using the segment-segment distance method described above. The global minimum squared distance, $\\ell^{\\star 2}$, is the minimum of these values over all edge pairs.\n\n**Pass 2: Identify all optimal point pairs.**\nIterate through all edge pairs again. For each pair $(e_i, f_j)$, find all pairs of points $(p,q)$ on these segments that achieve the distance $\\ell^\\star$. This requires careful handling:\n-   If the minimum is realized by an endpoint of one segment and a point on another, multiple edge pairs might identify the same optimal point pair (since a vertex is shared by two edges).\n-   If the segments are parallel and their projections overlap, there is a continuum of optimal pairs. For this special case, we must directly apply the tie-breaking rule. The lexicographically smallest point on an edge segment is chosen, which corresponds to one of its endpoints. This determines a unique optimal pair from the continuum.\n\n**Tie-breaking:**\nAfter collecting all point pairs $(p,q)$ that achieve the minimum distance $\\ell^\\star$, we apply the specified tie-breaking rule. The set of candidate pairs is sorted first by the lexicographical order of point $p \\in \\partial A$, and then, for ties, by the lexicographical order of point $q \\in \\partial B$. The first pair in the sorted list is the final answer $(p^\\star, q^\\star)$. This two-pass approach ensures that we correctly identify the global minimum distance before resolving any ambiguities or multiple solutions according to the problem's criteria.\n\nThe final implementation uses `numpy` for vector operations and adheres strictly to the described logic, with careful handling of floating-point comparisons using a small tolerance, $\\epsilon$.", "answer": "```python\nimport numpy as np\n\n# A small tolerance for floating-point comparisons\nEPSILON = 1e-9\n\ndef solve():\n    \"\"\"\n    Main function to solve the computational geometry problem for all test cases.\n    \"\"\"\n\n    def dist_point_segment_sq(p, a, b):\n        \"\"\"\n        Calculates the squared Euclidean distance from a point p to a line segment [a, b].\n        Returns the squared distance and the closest point on the segment.\n        \"\"\"\n        ab = b - a\n        ap = p - a\n        \n        len_sq = np.dot(ab, ab)\n        if len_sq  EPSILON:\n            return np.dot(ap, ap), a\n\n        t = np.dot(ap, ab) / len_sq\n        \n        if t  0.0:\n            closest_point = a\n        elif t > 1.0:\n            closest_point = b\n        else:\n            closest_point = a + t * ab\n            \n        dist_sq = np.dot(p - closest_point, p - closest_point)\n        return dist_sq, closest_point\n\n    def get_segment_pair_min_dist_sq(p1, p2, q1, q2):\n        \"\"\"\n        Calculates the minimum squared distance between two line segments [p1,p2] and [q1,q2].\n        \"\"\"\n        u = p2 - p1\n        v = q2 - q1\n        w = p1 - q1\n\n        a = np.dot(u, u)\n        b = np.dot(u, v)\n        c = np.dot(v, v)\n        d = np.dot(u, w)\n        e = np.dot(v, w)\n        \n        det = a * c - b * b\n        \n        # Start with a very large number\n        min_dist_sq = float('inf')\n\n        # Case 1: Interior to Interior (if not parallel)\n        if det > EPSILON:\n            s = (b * e - c * d) / det\n            t = (a * e - b * d) / det\n            if 0.0 = s = 1.0 and 0.0 = t = 1.0:\n                dist_sq = np.dot((p1 + s * u) - (q1 + t * v), (p1 + s * u) - (q1 + t * v))\n                min_dist_sq = min(min_dist_sq, dist_sq)\n        \n        # Case 2: Endpoint to Segment\n        dist_sq, _ = dist_point_segment_sq(p1, q1, q2)\n        min_dist_sq = min(min_dist_sq, dist_sq)\n        \n        dist_sq, _ = dist_point_segment_sq(p2, q1, q2)\n        min_dist_sq = min(min_dist_sq, dist_sq)\n        \n        dist_sq, _ = dist_point_segment_sq(q1, p1, p2)\n        min_dist_sq = min(min_dist_sq, dist_sq)\n        \n        dist_sq, _ = dist_point_segment_sq(q2, p1, p2)\n        min_dist_sq = min(min_dist_sq, dist_sq)\n        \n        return min_dist_sq\n\n    def find_segment_pair_optimal_points(p1, p2, q1, q2, target_dist_sq):\n        \"\"\"\n        Finds all pairs of points between two segments that achieve the target squared distance.\n        \"\"\"\n        optimal_pairs = []\n        \n        u = p2 - p1\n        v = q2 - q1\n        w = p1 - q1\n\n        a = np.dot(u, u)\n        b = np.dot(u, v)\n        c = np.dot(v, v)\n        d = np.dot(u, w)\n        e = np.dot(v, w)\n        det = a * c - b * b\n\n        # Case 1: Parallel Segments with Overlap\n        if det  EPSILON and b > 0: # Ensure they are not collinear and opposing\n            # Distance between parallel lines\n            dist_lines_sq = float('inf')\n            if c > EPSILON:\n                proj_p1_on_line_q = q1 + (np.dot(p1 - q1, v) / c) * v\n                dist_lines_sq = np.dot(p1 - proj_p1_on_line_q, p1 - proj_p1_on_line_q)\n\n            if abs(dist_lines_sq - target_dist_sq)  EPSILON:\n                # Find overlap interval\n                s_of_q1 = np.dot(q1 - p1, u) / a if a > EPSILON else 0.0\n                s_of_q2 = np.dot(q2 - p1, u) / a if a > EPSILON else 0.0\n                \n                s_overlap_min = max(0.0, min(s_of_q1, s_of_q2))\n                s_overlap_max = min(1.0, max(s_of_q1, s_of_q2))\n\n                if s_overlap_min = s_overlap_max + EPSILON:\n                    p1_lex_smaller = (p1[0]  p2[0]) or (abs(p1[0] - p2[0])  EPSILON and p1[1]  p2[1])\n                    s_best = s_overlap_min if p1_lex_smaller else s_overlap_max\n                    p_best = p1 + s_best * u\n                    t_best = np.dot(p_best - q1, v) / c if c > EPSILON else 0.0\n                    q_best = q1 + t_best * v\n                    optimal_pairs.append((p_best, q_best))\n                    \n        # Case 2: Interior to Interior (non-parallel)\n        if det > EPSILON:\n            s_opt = (b * e - c * d) / det\n            t_opt = (a * e - b * d) / det\n            if 0.0 = s_opt = 1.0 and 0.0 = t_opt = 1.0:\n                p_cand = p1 + s_opt * u\n                q_cand = q1 + t_opt * v\n                dist_sq = np.dot(p_cand - q_cand, p_cand - q_cand)\n                if abs(dist_sq - target_dist_sq)  EPSILON:\n                    optimal_pairs.append((p_cand, q_cand))\n        \n        # Case 3: Endpoint to Segment\n        dist_sq, q_on_seg = dist_point_segment_sq(p1, q1, q2)\n        if abs(dist_sq - target_dist_sq)  EPSILON:\n            optimal_pairs.append((p1, q_on_seg))\n            \n        dist_sq, q_on_seg = dist_point_segment_sq(p2, q1, q2)\n        if abs(dist_sq - target_dist_sq)  EPSILON:\n            optimal_pairs.append((p2, q_on_seg))\n            \n        dist_sq, p_on_seg = dist_point_segment_sq(q1, p1, p2)\n        if abs(dist_sq - target_dist_sq)  EPSILON:\n            optimal_pairs.append((p_on_seg, q1))\n            \n        dist_sq, p_on_seg = dist_point_segment_sq(q2, p1, p2)\n        if abs(dist_sq - target_dist_sq)  EPSILON:\n            optimal_pairs.append((p_on_seg, q2))\n            \n        return optimal_pairs\n\n    test_cases = [\n        {'A': [(-2,-1),(-2,1),(-1,1),(-1,-1)], 'B': [(1,-0.5),(1,0.5),(2,0.5),(2,-0.5)]},\n        {'A': [(0,0),(1,1),(0,2)], 'B': [(3,0.5),(3,1.5),(5,1.5),(5,0.5)]},\n        {'A': [(0,0),(0,1),(4,1),(4,0)], 'B': [(1,3),(1,4),(5,4),(5,3)]},\n        {'A': [(0,0),(0,1),(1,1),(1,0)], 'B': [(1.001,0),(1.001,1),(2.001,1),(2.001,0)]},\n        {'A': [(0,0),(0,1),(1,1),(1,0)], 'B': [(3,3),(3,4),(4,4),(4,3)]}\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        poly_A_verts = [np.array(v) for v in case['A']]\n        poly_B_verts = [np.array(v) for v in case['B']]\n\n        edges_A = [(poly_A_verts[i], poly_A_verts[(i + 1) % len(poly_A_verts)]) for i in range(len(poly_A_verts))]\n        edges_B = [(poly_B_verts[i], poly_B_verts[(i + 1) % len(poly_B_verts)]) for i in range(len(poly_B_verts))]\n        \n        # Pass 1: Find the minimum distance\n        min_dist_sq = float('inf')\n        for p1, p2 in edges_A:\n            for q1, q2 in edges_B:\n                dist_sq = get_segment_pair_min_dist_sq(p1, p2, q1, q2)\n                min_dist_sq = min(min_dist_sq, dist_sq)\n\n        # Pass 2: Collect all pairs achieving the minimum distance\n        candidate_pairs = []\n        for p1, p2 in edges_A:\n            for q1, q2 in edges_B:\n                pairs = find_segment_pair_optimal_points(p1, p2, q1, q2, min_dist_sq)\n                candidate_pairs.extend(pairs)\n        \n        # Apply tie-breaking rules\n        candidate_pairs.sort(key=lambda item: (item[0][0], item[0][1], item[1][0], item[1][1]))\n        \n        # Filter for unique pairs\n        unique_candidates = []\n        if candidate_pairs:\n            unique_candidates.append(candidate_pairs[0])\n            for i in range(1, len(candidate_pairs)):\n                p_curr, q_curr = candidate_pairs[i]\n                p_last, q_last = unique_candidates[-1]\n                if np.linalg.norm(p_curr - p_last) > EPSILON or np.linalg.norm(q_curr - q_last) > EPSILON:\n                    unique_candidates.append(candidate_pairs[i])\n\n        p_star, q_star = unique_candidates[0]\n        length = np.sqrt(min_dist_sq)\n\n        result = [\n            round(p_star[0], 6), round(p_star[1], 6),\n            round(q_star[0], 6), round(q_star[1], 6),\n            round(length, 6)\n        ]\n        final_results.append(result)\n\n    # Format output as a JSON-like string\n    output_str = \"[\" + \",\".join([f\"[{','.join(f'{x:.6f}' for x in r)}]\" for r in final_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3223483"}, {"introduction": "Theoretical algorithms often assume perfect precision, but real-world computers use finite-precision floating-point arithmetic, which can lead to catastrophic failures. This final practice is a crucial thought experiment that delves into the vital topic of numerical robustness in computational geometry [@problem_id:3223470]. By analyzing a hypothetical scenario where the standard Andrew's monotone chain algorithm for convex hulls fails, you will gain a deeper appreciation for the subtle but critical challenges of implementing geometric algorithms in practice.", "problem": "A central primitive used by the classic Andrew monotone chain algorithm for computing the convex hull in the Euclidean plane is the orientation predicate. For points $P=(x_{1},y_{1})$, $Q=(x_{2},y_{2})$, and $R=(x_{3},y_{3})$, the algorithm uses the sign of\n$$\n(x_{2}-x_{1})(y_{3}-y_{1})-(y_{2}-y_{1})(x_{3}-x_{1})\n$$\nto decide whether to keep or discard the most recently added point on the current hull. The algorithm assumes that orientation signs are computed correctly; with limited floating-point precision, these signs can be misclassified.\n\nAssume input coordinates are stored in Institute of Electrical and Electronics Engineers (IEEE) $754$ single-precision floating-point before any computation, and all subsequent arithmetic is performed in single precision. Model rounding to nearest representable number with unit roundoff $u=2^{-24}$, and recall that for normalized single-precision numbers with exponent $e$, the spacing between adjacent representable values (the unit in the last place, abbreviated as ulp) is $2^{e-23}$.\n\nConsider the following candidate point sets. In each set, let $M$ be as specified, and the four points are listed in the order they would naturally be fed to the algorithm after sorting by increasing $x$-coordinate and breaking ties by increasing $y$-coordinate. The true convex hull for each set, in exact arithmetic, is the four vertices of an axis-aligned square.\n\nWhich of the following point sets, when processed by the monotone chain algorithm under the stated single-precision model, can cause the algorithm to fail by omitting at least one true extreme vertex due to misclassification of the orientation predicate? Select all that apply.\n\nA. $M=2^{27}$. Points:\n$P=(M,M)$, $Q=(M+1,M)$, $R=(M,M+1)$, $S=(M+1,M+1)$.\n\nB. $M=2^{27}$. Points:\n$P=(M,M)$, $Q=(M+32,M)$, $R=(M,M+32)$, $S=(M+32,M+32)$.\n\nC. $M=2^{20}$. Points:\n$P=(M,M)$, $Q=(M+1,M)$, $R=(M,M+1)$, $S=(M+1,M+1)$.\n\nD. $M=2^{27}$. Points:\n$P=(M,M)$, $Q=(M+16,M)$, $R=(M+16,M+16)$, $S=(M,M+16)$.\n\nJustify your choice based on first principles, starting from the definitions of convex hull and orientation, the floating-point spacing model, and the algorithm’s rule that any non-left turn (orientation less than or equal to zero) triggers the removal of the most recent point from the working hull.", "solution": "The problem explores how finite-precision arithmetic can cause a geometric algorithm to fail. The failure mode analyzed here is **input quantization**, where the initial coordinates cannot be represented exactly in the floating-point system, leading to a distorted geometric configuration before any calculations are even performed.\n\nAccording to the IEEE 754 single-precision model, a number has a 24-bit significand. The spacing between adjacent representable numbers, known as the \"unit in the last place\" (ulp), depends on the number's magnitude. For a number $X$ on the order of $2^e$, the ulp is $2^{e-23}$. Any value between two representable numbers is rounded to the nearest one. This means an offset added to a large number might be \"lost\" if it is smaller than half the ulp of that large number.\n\nLet's analyze the critical orientation test for the lower hull, which involves the first three points in the sorted list: $P_1=(M,M)$, $P_2=(M,M+k)$, and $P_3=(M+k,M)$. In exact arithmetic, these three points form a right turn, and the algorithm correctly pops the middle point $P_2$. A failure occurs if this orientation is miscalculated.\n\n- **Case A: $M=2^{27}$, $k=1$**\n  - The magnitude of the coordinates is determined by $M = 2^{27}$. The exponent is $e=27$.\n  - The spacing between representable numbers near $M$ is $\\text{ulp}(M) = 2^{27-23} = 2^4 = 16$.\n  - We need to represent the coordinate $M+k = M+1$. Rounding to the nearest representable number occurs. A number is rounded up only if it is greater than or equal to the midpoint between two representable values. The midpoint above $M$ is $M + \\text{ulp}(M)/2 = M+8$.\n  - Since the offset $k=1$ is less than 8, the value $M+1$ will be rounded down to $M$. That is, `fl(M+1) = M`.\n  - Consequently, all four conceptual vertices of the square—$(M,M), (M,M+1), (M+1,M), (M+1,M+1)$—are quantized to the single point $(M,M)$ in single-precision representation.\n  - The algorithm is fed four identical points. It will compute a convex hull consisting of a single point, thus omitting three of the true vertices. This is a failure.\n\n- **Case B: $M=2^{27}$, $k=32$**\n  - $\\text{ulp}(M) = 16$. The offset $k=32$ is an integer multiple of the ulp ($32 = 2 \\times 16$). The coordinate $M+32$ is exactly representable in single precision. All input coordinates are exact, and subsequent arithmetic on them also happens to be exact, preserving the correct orientation sign. No failure.\n\n- **Case C: $M=2^{20}$, $k=1$**\n  - The magnitude is $M=2^{20}$. The exponent is $e=20$.\n  - The spacing is $\\text{ulp}(M) = 2^{20-23} = 2^{-3} = 0.125$.\n  - The offset $k=1$ is a multiple of the ulp ($1 = 8 \\times 0.125$). The coordinate $M+1$ is exactly representable. No coordinates are lost to quantization. No failure.\n\n- **Case D: $M=2^{27}$, $k=16$**\n  - $\\text{ulp}(M)=16$. The offset $k=16$ is exactly equal to the ulp. The coordinate $M+16$ is the next representable number after $M$ and is stored exactly. All calculations proceed correctly. No failure.\n\nTherefore, only case A causes the algorithm to fail. The failure is not due to arithmetic error in the orientation formula itself, but due to the loss of precision during the initial representation of the input coordinates. The small geometric features of the square are completely erased by the large scale of its location.", "answer": "$$\\boxed{A}$$", "id": "3223470"}]}