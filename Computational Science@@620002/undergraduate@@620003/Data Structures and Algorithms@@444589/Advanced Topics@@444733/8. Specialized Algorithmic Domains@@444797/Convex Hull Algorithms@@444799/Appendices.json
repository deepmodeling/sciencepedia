{"hands_on_practices": [{"introduction": "This exercise guides you through implementing one of the most elegant and efficient convex hull algorithms, the Monotone Chain, also known as Andrew's algorithm. By starting with fundamental principles like lexicographical sorting and the orientation test, you will build the algorithm from the ground up, reinforcing your understanding of how geometric invariants directly translate into code [@problem_id:3205841]. This practice is essential for developing the skill of transforming geometric theory into a robust computational solution.", "problem": "You are to design, specify, and implement, in code, a function that computes the convex hull of a finite set of two-dimensional points using the Monotone Chain algorithm. The foundational base for your reasoning must begin with the following: the definition of convexity in the plane $\\mathbb{R}^2$, the definition of the convex hull of a finite set as the smallest convex set containing it, the notion of a lexicographic order on pairs $(x,y)$, and the concept of orientation of triples of points as a criterion for maintaining convexity during incremental construction. Do not use any shortcut formulas or pre-given algorithmic templates; instead, derive the algorithmic steps you will specify from these fundamental definitions and facts. Your specification must be a clear pseudo-code function with a precise contract and must be implementable directly.\n\nGiven a finite set $P \\subset \\mathbb{R}^2$ with integer coordinates, define a pseudo-code function that, for input $P$, returns the vertices of the convex hull polygon ordered counterclockwise, starting from the lexicographically smallest point (ordered first by $x$ and then by $y$), with duplicate points removed and with strictly interior collinear points excluded from the returned vertex list. The returned polygon must not repeat the first vertex at the end. If the input has fewer than $2$ distinct points, return the input set of distinct points ordered lexicographically. If all points are collinear, return only the two extreme endpoints in lexicographic order.\n\nYour final program should implement your pseudo-code and run against the following explicit test suite of point sets. Each test case is a list of points written as ordered pairs, and each coordinate pair is provided in mathematical notation. The angle unit is not applicable in this problem. There are no physical units. The required output type for each test case is a list of lists of integers.\n\nTest suite:\n- Test case $1$ (general case with interior points): $[(0,0),(2,0),(2,2),(0,2),(1,1)]$\n- Test case $2$ (empty set): $[]$\n- Test case $3$ (single point): $[(5,5)]$\n- Test case $4$ (collinear points with duplicates): $[(0,0),(1,1),(2,2),(3,3),(1,1),(2,2)]$\n- Test case $5$ (all points on the boundary with boundary collinear points included): $[(0,0),(3,0),(3,3),(0,3),(1,0),(2,0),(3,1),(3,2),(2,3),(1,3),(0,2),(0,1)]$\n- Test case $6$ (two identical points): $[(7,7),(7,7)]$\n- Test case $7$ (diamond with interior points and negative coordinates): $[(-2,0),(0,2),(2,0),(0,-2),(-1,0),(0,1),(1,0),(0,-1)]$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must be the convex hull of the corresponding input, represented as a list of points, where each point is a two-integer list $[x,y]$, and the hull is ordered counterclockwise starting from the lexicographically smallest vertex. For example, an output for three cases might look like $[[x_1,y_1],[x_2,y_2]],[[u_1,v_1],[u_2,v_2],[u_3,v_3]],[]$ aggregated as a single list: $[[[x_1,y_1],[x_2,y_2]],[[u_1,v_1],[u_2,v_2],[u_3,v_3]],[]]$.\n- Your program must be completely self-contained and must not read any input; it must use the test suite above exactly as provided.", "solution": "The user requires the design and implementation of the Monotone Chain algorithm for computing the convex hull of a set of 2D points. The derivation must be based on first principles: convexity, the definition of a convex hull, lexicographic ordering, and the orientation of point triples.\n\n### Step 1: Problem Validation\n\n**1.1. Extract Givens**\n\n*   **Input**: A finite set of two-dimensional points $P \\subset \\mathbb{R}^2$ with integer coordinates.\n*   **Algorithm**: Monotone Chain.\n*   **Fundamental Concepts**:\n    *   Definition of convexity in $\\mathbb{R}^2$.\n    *   Definition of the convex hull of a finite set.\n    *   Lexicographic order on pairs $(x,y)$.\n    *   Orientation of triples of points.\n*   **Output Constraints**:\n    *   Return a list of vertices of the convex hull polygon.\n    *   The vertices must be ordered counter-clockwise.\n    *   The ordering must start from the lexicographically smallest point.\n    *   Duplicate input points must be removed.\n    *   Strictly interior collinear points on an edge must be excluded.\n    *   The returned polygon must not repeat the start vertex at the end.\n*   **Edge Cases**:\n    *   If there are fewer than $2$ distinct points, return the distinct points ordered lexicographically.\n    *   If all points are collinear, return only the two extreme endpoints in lexicographic order.\n*   **Test Suite**: Seven specific test cases are provided.\n*   **Final Output Format**: A single line representing a list of the results for the test suite, where each result is a list of points (each point being a two-integer list).\n\n**1.2. Validate Using Extracted Givens**\n\n*   **Scientifically Grounded**: The problem is a standard, well-established problem in computational geometry. All concepts (convex hull, Monotone Chain algorithm, lexicographic order, orientation test) are fundamental and mathematically sound.\n*   **Well-Posed**: The problem is well-posed. The input is defined, the desired output is precisely specified, and the constraints (ordering, handling of collinear points) are clear. A unique solution exists for any given finite set of points.\n*   **Objective**: The problem is stated in precise, objective mathematical language. There are no subjective or ambiguous terms.\n*   **Completeness**: The problem provides all necessary information, including the algorithm to be used, foundational principles for derivation, and a comprehensive test suite. The constraints, such as how to handle collinear points and small inputs, are explicitly defined, removing ambiguity.\n\n**1.3. Verdict and Action**\n\nThe problem is deemed **valid**. It is a formal, self-contained, and well-posed problem from the field of data structures and algorithms. I will proceed with a principled derivation and solution.\n\n### Step 2: Principled Derivation and Algorithm Specification\n\n**2.1. Foundational Principles**\n\n1.  **Convexity**: A set $S \\subset \\mathbb{R}^2$ is convex if for any two points $p_1, p_2 \\in S$, the line segment connecting them is entirely contained within $S$.\n2.  **Convex Hull**: The convex hull of a finite set of points $P$, denoted $CH(P)$, is the smallest convex set that contains all points in $P$. For a finite set, $CH(P)$ is a convex polygon whose vertices are a subset of $P$.\n3.  **Lexicographic Order**: For two points $p_1 = (x_1, y_1)$ and $p_2 = (x_2, y_2)$, we say $p_1$ is lexicographically smaller than $p_2$, denoted $p_1  p_2$, if and only if $(x_1  x_2)$ or $(x_1 = x_2 \\text{ and } y_1  y_2)$. This total ordering allows us to uniquely sort all points. The lexicographically smallest and largest points are guaranteed to be vertices of the convex hull.\n4.  **Orientation Test**: The orientation of an ordered triple of points $(p_1, p_2, p_3)$ determines whether the path from $p_1$ to $p_2$ to $p_3$ constitutes a \"left turn\" (counter-clockwise, CCW), a \"right turn\" (clockwise, CW), or if the points are collinear. This can be computed using the 2D cross product of the vectors $\\vec{p_1p_2}$ and $\\vec{p_1p_3}$. Let $p_1=(x_1,y_1)$, $p_2=(x_2,y_2)$, and $p_3=(x_3,y_3)$. The orientation value $O$ is:\n    $$O(p_1, p_2, p_3) = (x_2 - x_1)(y_3 - y_1) - (y_2 - y_1)(x_3 - x_1)$$\n    *   $O  0$: Counter-clockwise (left turn).\n    *   $O  0$: Clockwise (right turn).\n    *   $O = 0$: Collinear.\n\n**2.2. Derivation of the Monotone Chain Algorithm**\n\nThe core idea of the Monotone Chain algorithm is to construct the convex hull by building its upper and lower boundaries (chains) separately.\n\n1.  **Sorting**: The first step is to sort the set of unique points $P$ lexicographically. This arranges the points from left to right, breaking ties by moving from bottom to top. Let the sorted points be $p_1, p_2, \\ldots, p_n$. The points $p_1$ and $p_n$ are the absolute \"leftmost\" and \"rightmost\" points and must be on the hull.\n\n2.  **Hull Construction**: The convex hull is a polygon whose vertices are ordered counter-clockwise. As we traverse the perimeter of a convex polygon in CCW order, every turn we make at a vertex must be a \"left turn\". This is the key insight for building the hull.\n\n3.  **Lower and Upper Hulls**: We can decompose the CCW path of the hull into two sections:\n    *   The **lower hull**, which is the path from $p_1$ to $p_n$ along the \"bottom\" of the point set.\n    *   The **upper hull**, which is the path from $p_n$ back to $p_1$ along the \"top\" of the point set.\n\n4.  **Incremental Construction**: We will use a stack-based approach to build each hull. We iterate through the sorted points and maintain a list (the \"chain\") of points that currently form a convex path. When considering a new point, we check if adding it maintains convexity.\n    *   Let the current chain be a list of points, and we are considering adding a new point $p_i$. Let the last two points on the chain be $p_{last-1}$ and $p_{last}$. The triple $(p_{last-1}, p_{last}, p_i)$ must form a left turn to maintain the CCW convexity of the overall polygon.\n    *   If the orientation $O(p_{last-1}, p_{last}, p_i)$ is a right turn ($O  0$), it means the point $p_{last}$ creates a concavity and cannot be on the hull. Thus, we must pop $p_{last}$ from our chain and repeat the check.\n    *   If the orientation is collinear ($O = 0$), the point $p_{last}$ is a \"strictly interior collinear point\" on the segment from $p_{last-1}$ to $p_i$. The problem specifies that such points must be excluded. Therefore, we also pop $p_{last}$ in this case.\n    *   The condition to pop the last point from the chain is thus $O(p_{last-1}, p_{last}, p_i) \\leq 0$. We continue popping until this condition is false or the chain has fewer than two points. Then, we add the new point $p_i$ to the chain.\n\n5.  **Building Both Hulls**:\n    *   To build the **lower hull**, we iterate through the sorted points from $p_1$ to $p_n$, applying the logic above. This produces the lower chain of the hull, ordered from left to right.\n    *   To build the **upper hull**, we can apply the exact same logic but iterate through the points in reverse order, from $p_n$ down to $p_1$. This produces the upper chain, ordered from right to left.\n\n6.  **Combining Hulls**: The final convex hull is the concatenation of the lower and upper hulls. The lower hull contains vertices from $p_1$ to $p_n$. The upper hull contains vertices from $p_n$ back to $p_1$. To avoid duplicating the endpoints $p_1$ and $p_n$, we concatenate the lower hull (excluding its last point, $p_n$) and the upper hull (excluding its last point, $p_1$).\n\n**2.3. Pseudo-code**\n\n`FUNCTION MonotoneChain(Points):`\n    `// Input: A list of 2D points, P.`\n    `// Output: A list of points forming the convex hull, ordered CCW.`\n\n    `// Step 0: Preprocessing and edge cases`\n    `1. unique_points = Remove duplicate points from Points.`\n    `2. n = number of unique_points.`\n    `3. IF n  3:`\n    `4.   Sort unique_points lexicographically.`\n    `5.   RETURN unique_points.`\n    `6. Sort unique_points lexicographically. Let them be p_1, p_2, ..., p_n.`\n\n    `// Helper function for orientation`\n    `FUNCTION orientation(p1, p2, p3):`\n    `  RETURN (p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x)`\n\n    `// Step 1: Build the lower hull`\n    `7. lower_hull = []`\n    `8. FOR each point p_i in p_1, ..., p_n:`\n    `9.   WHILE length of lower_hull = 2 AND orientation(lower_hull[-2], lower_hull[-1], p_i) = 0:`\n    `10.    Pop last point from lower_hull.`\n    `11.  Push p_i onto lower_hull.`\n\n    `// Step 2: Build the upper hull`\n    `12. upper_hull = []`\n    `13. FOR each point p_i in p_n, ..., p_1 (reverse order):`\n    `14.  WHILE length of upper_hull = 2 AND orientation(upper_hull[-2], upper_hull[-1], p_i) = 0:`\n    `15.    Pop last point from upper_hull.`\n    `16.  Push p_i onto upper_hull.`\n\n    `// Step 3: Combine hulls`\n    `17. // Remove the last point of each hull because they are the same as`\n    `    // the first point of the other hull.`\n    `18. hull = lower_hull[:-1] + upper_hull[:-1]`\n    `19. RETURN hull`", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the convex hull for a predefined suite of test cases\n    and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general case with interior points)\n        [(0,0), (2,0), (2,2), (0,2), (1,1)],\n        # Test case 2 (empty set)\n        [],\n        # Test case 3 (single point)\n        [(5,5)],\n        # Test case 4 (collinear points with duplicates)\n        [(0,0), (1,1), (2,2), (3,3), (1,1), (2,2)],\n        # Test case 5 (all points on the boundary with boundary collinear points included)\n        [(0,0), (3,0), (3,3), (0,3), (1,0), (2,0), (3,1), (3,2), (2,3), (1,3), (0,2), (0,1)],\n        # Test case 6 (two identical points)\n        [(7,7), (7,7)],\n        # Test case 7 (diamond with interior points and negative coordinates)\n        [(-2,0), (0,2), (2,0), (0,-2), (-1,0), (0,1), (1,0), (0,-1)]\n    ]\n\n    results = []\n    for case in test_cases:\n        hull = compute_convex_hull(case)\n        results.append(hull)\n\n    # Convert results to the required string representation for the final output.\n    # The format is a list of lists, e.g., [[[x1,y1],[x2,y2]], [[u1,v1]], ...].\n    # Using np.array(pt).tolist() ensures points are lists, not tuples.\n    # The outer list comprehension handles conversion of each hull.\n    # repr() is used to get the string representation of the list of lists.\n    # However, repr() adds spaces, so we build the string manually.\n    \n    result_strings = []\n    for hull in results:\n        point_strings = [f\"[{p[0]},{p[1]}]\" for p in hull]\n        result_strings.append(f\"[{','.join(point_strings)}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\n\ndef compute_convex_hull(points):\n    \"\"\"\n    Computes the convex hull of a set of 2D points using the Monotone Chain algorithm.\n\n    Args:\n        points: A list of (x, y) tuples representing the points.\n\n    Returns:\n        A list of [x, y] lists representing the vertices of the convex hull,\n        ordered counter-clockwise starting from the lexicographically smallest point.\n    \"\"\"\n    # Step 0: Preprocessing and edge cases\n    # Use a set of tuples to efficiently remove duplicate points.\n    unique_points = sorted(list(set(points)))\n    n = len(unique_points)\n    \n    # If there are fewer than 3 points, they form the \"hull\" themselves.\n    # The problem specifies returning points for n  2, but the logic extends\n    # correctly to n  3 as no polygon can be formed.\n    if n  3:\n        # Convert tuples to lists as per output format\n        return [list(p) for p in unique_points]\n\n    # Helper function for orientation based on 2D cross product.\n    # O  0: counter-clockwise (left turn)\n    # O  0: clockwise (right turn)\n    # O = 0: collinear\n    def orientation(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    # Step 1: Build the lower hull\n    lower_hull = []\n    for p in unique_points:\n        # Pop from the hull if the new point creates a right turn or is collinear.\n        # This maintains a strictly counter-clockwise (left-turning) chain.\n        while len(lower_hull) >= 2 and orientation(lower_hull[-2], lower_hull[-1], p) = 0:\n            lower_hull.pop()\n        lower_hull.append(p)\n\n    # Step 2: Build the upper hull\n    upper_hull = []\n    for p in reversed(unique_points):\n        # The logic is identical for the upper hull, iterating in reverse.\n        while len(upper_hull) >= 2 and orientation(upper_hull[-2], upper_hull[-1], p) = 0:\n            upper_hull.pop()\n        upper_hull.append(p)\n\n    # Step 3: Combine hulls\n    # The final hull is the lower hull followed by the upper hull.\n    # The first and last points of each hull are the same (the lexicographically\n    # smallest and largest points), so we exclude them from the concatenation\n    # to avoid duplicates.\n    full_hull_tuples = lower_hull[:-1] + upper_hull[:-1]\n    \n    # Convert tuples to lists for the final output format.\n    return [list(p) for p in full_hull_tuples]\n\nsolve()\n```", "id": "3205841"}, {"introduction": "While the Graham Scan algorithm is conceptually straightforward, its initial sorting step presents a critical practical challenge: how does one compare polar angles without resorting to slow and potentially imprecise floating-point trigonometry? This practice focuses on solving that exact problem by using the cross product to create a robust, integer-only comparator [@problem_id:3224274]. Mastering this technique is key to writing efficient and numerically stable computational geometry code, a valuable skill for any programmer working with geometric data.", "problem": "You are given finite sets of points in the two-dimensional plane, each set represented by integer coordinate pairs. The goal is to implement the angle-sorting step used by the Graham Scan convex hull algorithm for each set, subject to strict constraints: Do not use any trigonometric functions, do not use any floating-point division, and rely only on integer arithmetic and cross products to compare angles. The sorting must be defined with respect to a pivot point chosen deterministically from the set. The final program must produce a single line of output encoding the sorted orders for all provided test cases.\n\nFundamental base definitions to use:\n- A point is a pair of integers $(x, y)$ representing a location on the plane.\n- Given points $\\mathbf{a} = (x_a, y_a)$ and $\\mathbf{b} = (x_b, y_b)$, and a pivot $\\mathbf{p} = (x_p, y_p)$, define translated vectors $\\mathbf{u} = \\mathbf{a} - \\mathbf{p} = (x_a - x_p, y_a - y_p)$ and $\\mathbf{v} = \\mathbf{b} - \\mathbf{p} = (x_b - x_p, y_b - y_p)$.\n- The cross product (signed area of the parallelogram spanned by $\\mathbf{u}$ and $\\mathbf{v}$) is given by $\\mathbf{u} \\times \\mathbf{v} = (x_a - x_p)(y_b - y_p) - (y_a - y_p)(x_b - x_p)$, which is an integer when coordinates are integers.\n- The Euclidean distance squared from $\\mathbf{p}$ to $\\mathbf{a}$ is $d^2(\\mathbf{p}, \\mathbf{a}) = (x_a - x_p)^2 + (y_a - y_p)^2$, which is an integer when coordinates are integers.\n\nRequired angle-sorting behavior:\n- Choose the pivot $\\mathbf{p}$ as the point with minimal $y$-coordinate; in case of ties, choose among those the one with minimal $x$-coordinate.\n- Exclude the pivot from the sorting.\n- Sort all remaining points by their polar angle around $\\mathbf{p}$ in counterclockwise order starting from the positive $x$-axis. For two points $\\mathbf{a}$ and $\\mathbf{b}$, this ordering must be determined entirely using integer comparisons and the cross product $\\mathbf{u} \\times \\mathbf{v}$ of their translated vectors $\\mathbf{u}$ and $\\mathbf{v}$ relative to $\\mathbf{p}$. You must determine which vector lies earlier by angle using only:\n  - The half-plane classification relative to the positive $x$-axis: a vector $\\mathbf{w} = (x_w, y_w)$ lies in the upper half-plane if $y_w  0$ or $y_w = 0$ and $x_w \\ge 0$, otherwise it lies in the lower half-plane.\n  - The sign of the cross product $\\mathbf{u} \\times \\mathbf{v}$. If the two vectors lie in the same half-plane and $\\mathbf{u} \\times \\mathbf{v}  0$, then $\\mathbf{u}$ has smaller angle than $\\mathbf{v}$; if $\\mathbf{u} \\times \\mathbf{v}  0$, then $\\mathbf{v}$ has smaller angle than $\\mathbf{u}$.\n- In case of colinearity relative to $\\mathbf{p}$, where $\\mathbf{u} \\times \\mathbf{v} = 0$, break ties by increasing Euclidean distance squared $d^2(\\mathbf{p}, \\cdot)$, placing the nearer point first.\n\nIndices and output:\n- Index points in each input set from $0$ to $n-1$ in the given order.\n- For each test case, output the list of indices of points sorted by the rule above, excluding the pivot’s index.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each per-case result itself being a comma-separated list enclosed in square brackets. For example, the final output format must be like $[[i_{0,0},i_{0,1},\\dots],[i_{1,0},i_{1,1},\\dots],\\dots]$, with no spaces.\n\nTest suite:\n- Test case $1$: Points $[(0,0),(2,1),(1,2),(-1,1),(-2,0),(-1,-1),(1,-2),(2,-1),(0,2),(0,-2)]$.\n- Test case $2$: Points $[(-3,0),(-1,0),(0,0),(2,0),(5,0)]$.\n- Test case $3$: Points $[(1,1),(2,2),(2,2),(3,3),(0,0)]$.\n- Test case $4$: Points $[(4,0),(0,4),(-4,0),(0,-4),(1,-3),(2,-2),(-2,-2),(-1,-3),(3,3),(-3,3)]$.\n\nAnswer specification:\n- For each test case, produce a list of integers corresponding to the indices sorted by the required angle order with respect to its pivot.\n- The final answer must be a program that prints the single line described above and performs only integer computations without any trigonometric functions or floating-point division.", "solution": "The user-provided problem is a well-posed task in computational geometry, specifically related to the sorting phase of the Graham Scan algorithm for finding a convex hull. The problem is algorithmically sound, self-contained, and provides all necessary definitions and constraints for a unique solution. The core challenge is to sort a set of points by their polar angle with respect to a pivot, using only integer arithmetic. This is accomplished by leveraging the geometric properties of the cross product and squared Euclidean distance, thereby avoiding the use of trigonometric functions and floating-point computations.\n\nThe solution proceeds in a sequence of logical steps for each given test case:\n\n**1. Pivot Point Identification**\n\nFirst, a pivot point $\\mathbf{p}$ must be deterministically selected from the input set of points. The problem specifies a clear rule: the pivot is the point with the minimum $y$-coordinate. In the event of a tie, the point among those with the minimum $x$-coordinate is chosen. If a set of points is denoted by $S = \\{\\mathbf{p}_0, \\mathbf{p}_1, \\dots, \\mathbf{p}_{n-1}\\}$, where each $\\mathbf{p}_i = (x_i, y_i)$, the pivot $\\mathbf{p} = (x_p, y_p)$ is the point such that for any other point $\\mathbf{p}_j = (x_j, y_j)$ in $S$, either $y_p  y_j$ or ($y_p = y_j$ and $x_p  x_j$). This guarantees a unique pivot for any non-empty set of points. The pivot itself is excluded from the sorting process.\n\n**2. The Comparison Function for Sorting**\n\nThe fundamental task is to establish a total ordering on the remaining points based on their polar angle relative to the pivot $\\mathbf{p}$. This requires a comparison function that, for any two points $\\mathbf{a}$ and $\\mathbf{b}$, determines which one has a smaller polar angle in a counter-clockwise direction starting from the ray parallel to the positive $x$-axis originating from $\\mathbf{p}$. This comparison is implemented using exclusively integer arithmetic.\n\nLet $\\mathbf{a} = (x_a, y_a)$ and $\\mathbf{b} = (x_b, y_b)$ be two points to compare, and let the pivot be $\\mathbf{p} = (x_p, y_p)$. We define their corresponding translated vectors as $\\mathbf{u} = \\mathbf{a} - \\mathbf{p} = (x_a - x_p, y_a - y_p) = (u_x, u_y)$ and $\\mathbf{v} = \\mathbf{b} - \\mathbf{p} = (x_b - x_p, y_b - y_p) = (v_x, v_y)$. The comparison logic is as follows:\n\n**2.1. Half-Plane Classification**\nThe plane is divided into two half-planes relative to the pivot $\\mathbf{p}$ to handle angles spanning across $\\pi$ radians (or $180^\\circ$). The \"upper\" half-plane contains vectors whose angles are in the range $[0, \\pi)$, and the \"lower\" half-plane contains those with angles in $[\\pi, 2\\pi)$.\nA vector $\\mathbf{w} = (w_x, w_y)$ is in the upper half-plane if $w_y  0$, or if $w_y = 0$ and $w_x  0$. The condition $w_x \\ge 0$ is specified, but since the pivot is excluded from sorting, the translated vector $\\mathbf{w}$ cannot be the zero vector $(0,0)$, so for $w_y=0$, $w_x$ must be non-zero.\n- If vector $\\mathbf{u}$ is in the upper half-plane and $\\mathbf{v}$ is in the lower, $\\mathbf{u}$ has a smaller polar angle.\n- If vector $\\mathbf{v}$ is in the upper half-plane and $\\mathbf{u}$ is in the lower, $\\mathbf{v}$ has a smaller polar angle.\n\n**2.2. Cross Product for Angle Comparison**\nIf both vectors $\\mathbf{u}$ and $\\mathbf{v}$ lie in the same half-plane, their relative angular order is determined by the sign of their $2$D cross product. The cross product is defined as $\\mathbf{u} \\times \\mathbf{v} = u_x v_y - u_y v_x$.\n- If $\\mathbf{u} \\times \\mathbf{v}  0$, the turn from $\\mathbf{u}$ to $\\mathbf{v}$ is counter-clockwise, meaning the angle of $\\mathbf{u}$ is smaller than the angle of $\\mathbf{v}$.\n- If $\\mathbf{u} \\times \\mathbf{v}  0$, the turn is clockwise, meaning the angle of $\\mathbf{v}$ is smaller than the angle of $\\mathbf{u}$.\n\n**2.3. Tie-Breaking for Colinear Points**\nIf the cross product $\\mathbf{u} \\times \\mathbf{v} = 0$, the points $\\mathbf{a}$ and $\\mathbf{b}$ are colinear with the pivot $\\mathbf{p}$. The tie is broken by sorting based on their distance from the pivot. To avoid using square roots and floating-point numbers, we compare their squared Euclidean distances.\nThe squared distance from $\\mathbf{p}$ to $\\mathbf{a}$ is $d^2(\\mathbf{p}, \\mathbf{a}) = u_x^2 + u_y^2$.\n- If $d^2(\\mathbf{p}, \\mathbf{a})  d^2(\\mathbf{p}, \\mathbf{b})$, point $\\mathbf{a}$ is closer and thus comes first in the sorted order.\n- If $d^2(\\mathbf{p}, \\mathbf{a})  d^2(\\mathbf{p}, \\mathbf{b})$, point $\\mathbf{b}$ is closer and comes first.\nIf the squared distances are also equal (and the points are colinear), the points are identical. Their relative order is maintained as per the stability of the sorting algorithm.\n\n**3. Algorithmic Implementation**\n\nThe overall algorithm for each test case is:\n1.  Enumerate the input points with their original indices from $0$ to $n-1$.\n2.  Find the pivot $\\mathbf{p}$ and its index.\n3.  Create a list of all other points, each stored as a tuple containing the point's coordinates and its original index.\n4.  Sort this list using a standard sorting algorithm. The sorting key must be a custom comparison function that rigorously implements the logic described in step $2$. In Python, this is conveniently done using `functools.cmp_to_key`.\n5.  After sorting, extract the original indices from the sorted list of points.\n6.  Collect the resulting list of indices for each test case and format them into the specified single-line string output.\n\nThis procedure yields a correctly sorted list of point indices according to the specified rules, fulfilling all requirements of the problem statement.", "answer": "```python\nimport sys\nfrom functools import cmp_to_key\n\ndef solve():\n    \"\"\"\n    Solves the angle-sorting problem for the given test cases using only\n    integer arithmetic as specified.\n    \"\"\"\n    test_cases = [\n        [(0,0),(2,1),(1,2),(-1,1),(-2,0),(-1,-1),(1,-2),(2,-1),(0,2),(0,-2)],\n        [(-3,0),(-1,0),(0,0),(2,0),(5,0)],\n        [(1,1),(2,2),(2,2),(3,3),(0,0)],\n        [(4,0),(0,4),(-4,0),(0,-4),(1,-3),(2,-2),(-2,-2),(-1,-3),(3,3),(-3,3)],\n    ]\n\n    all_results = []\n\n    for points in test_cases:\n        # 1. Find the pivot point (min y, then min x).\n        min_y = sys.maxsize\n        min_x_at_min_y = sys.maxsize\n        pivot_idx = -1\n        \n        for i, (x, y) in enumerate(points):\n            if y  min_y:\n                min_y = y\n                min_x_at_min_y = x\n                pivot_idx = i\n            elif y == min_y:\n                if x  min_x_at_min_y:\n                    min_x_at_min_y = x\n                    pivot_idx = i\n        \n        pivot_point = points[pivot_idx]\n\n        # 2. Collect points to be sorted (all except the pivot)\n        # along with their original indices.\n        points_to_sort = []\n        for i, p in enumerate(points):\n            if i != pivot_idx:\n                points_to_sort.append((p, i))\n\n        # 3. Define the comparison function based on the problem rules.\n        def compare_points(item1, item2):\n            \"\"\"\n            Compares two points based on their polar angle relative to the pivot.\n            Returns -1 if item1  item2, 1 if item1  item2, 0 if equal.\n            \"\"\"\n            p1 = item1[0]\n            p2 = item2[0]\n\n            # Translate points to vectors relative to the pivot\n            u_x, u_y = p1[0] - pivot_point[0], p1[1] - pivot_point[1]\n            v_x, v_y = p2[0] - pivot_point[0], p2[1] - pivot_point[1]\n\n            # Half-plane classification\n            is_upper_u = (u_y  0) or (u_y == 0 and u_x  0)\n            is_upper_v = (v_y  0) or (v_y == 0 and v_x  0)\n\n            if is_upper_u != is_upper_v:\n                return -1 if is_upper_u else 1\n\n            # Both in the same half-plane, use cross product\n            cross_product = u_x * v_y - u_y * v_x\n            if cross_product != 0:\n                return -1 if cross_product  0 else 1\n\n            # Collinear, use squared Euclidean distance for tie-breaking\n            dist_sq_u = u_x**2 + u_y**2\n            dist_sq_v = v_x**2 + v_y**2\n            \n            if dist_sq_u  dist_sq_v:\n                return -1\n            elif dist_sq_u  dist_sq_v:\n                return 1\n            \n            return 0\n\n\n        # 4. Sort the points using the custom comparator.\n        points_to_sort.sort(key=cmp_to_key(compare_points))\n\n        # 5. Extract the original indices of the sorted points.\n        sorted_indices = [item[1] for item in points_to_sort]\n        all_results.append(sorted_indices)\n\n    # 6. Format the final output string.\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, r))}]' for r in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3224274"}, {"introduction": "An algorithm's efficiency is not just about its average performance but also its behavior in the worst case. This problem challenges you to think like an adversary and construct an input that maximizes the internal work of the Graham Scan algorithm, specifically the number of \"pop\" operations from its stack [@problem_id:3224243]. Through this exercise in amortized analysis, you will gain a deeper appreciation for why an algorithm with a nested loop can still be fundamentally linear in its total operations, proving its efficiency even under stress.", "problem": "You are given the classical Graham scan convex hull algorithm defined as follows. Let the input be a finite set of distinct points in the Euclidean plane, with cardinality $n \\ge 3$. Let $p_0$ denote the point with minimum $y$-coordinate, breaking ties by minimum $x$-coordinate. Sort the remaining $n-1$ points by their polar angle around $p_0$ in strictly increasing order; for points with identical polar angle around $p_0$, the algorithm leaves their relative order unspecified. Then initialize an empty stack $S$ and perform:\n- Push $p_0$, push the first angle-sorted point.\n- For each subsequent angle-sorted point $p_i$, with $i$ increasing, repeatedly pop the top of $S$ while the last two points $a$ and $b$ on $S$ together with $p_i$ do not make a left turn, and then push $p_i$. Here, the orientation predicate returns left turn, right turn, or collinear according to the sign of the two-dimensional cross product of direction vectors: for three points $a$, $b$, $c$, let\n$$\n\\operatorname{orient}(a,b,c) = \\operatorname{sign}\\big((b_x - a_x)(c_y - a_y) - (b_y - a_y)(c_x - a_x)\\big),\n$$\nso that a non-left turn corresponds to $\\operatorname{orient}(a,b,c) \\le 0$.\n\nAn adversary is allowed to choose both the input set of $n$ points and, subject to the global polar-angle ordering around $p_0$, the relative order of any points that share exactly the same polar angle with respect to $p_0$. The adversary’s goal is to maximize the total number of pop operations performed by the Graham scan’s while-loop due to non-left turns (i.e., right turns or collinearity).\n\nTask:\n- Construct, in terms of $n$, an explicit adversarial input and tie-breaking order that maximizes the number of such pop operations, while remaining consistent with the stated sorting rule.\n- Using only first principles about the stack evolution and the orientation predicate, derive a tight, exact expression $R(n)$ for the maximum possible total number of pop operations incurred by the while-loop over the entire execution on any adversarial input and tie-breaking consistent with the angle sort.\n- Your final answer must be $R(n)$ as a closed-form expression in $n$. No asymptotic notation (such as $O(\\cdot)$) is permitted in the final answer.\n\nExpress the final answer as a single analytic expression in $n$. No units are required.", "solution": "The user wants me to analyze the Graham scan algorithm and determine the maximum number of pop operations an adversary can force.\n\n### Step 1: Extract Givens\n- **Input**: A set of $n$ distinct points in the plane, where $n \\ge 3$.\n- **Algorithm**: A specific version of Graham scan.\n    1.  Select pivot $p_0$ as the point with the minimum $y$-coordinate, with ties broken by minimum $x$-coordinate.\n    2.  Sort the remaining $n-1$ points ($p_1, \\dots, p_{n-1}$) by strictly increasing polar angle around $p_0$.\n    3.  The relative order of points with the same polar angle is not specified by the algorithm.\n    4.  Initialize stack $S$. Push $p_0$, then push $p_1$.\n    5.  For each subsequent point $p_i$ (for $i=2, \\dots, n-1$):\n        - While the orientation of the top two points on the stack ($a, b$) and $p_i$ is not a left turn (i.e., $\\operatorname{orient}(a,b,p_i) \\le 0$), pop from the stack.\n        - Push $p_i$ onto the stack.\n- **Orientation Predicate**: $\\operatorname{orient}(a,b,c) = \\operatorname{sign}\\big((b_x - a_x)(c_y - a_y) - (b_y - a_y)(c_x - a_x)\\big)$. A value of $\\le 0$ corresponds to a right turn or collinear arrangement.\n- **Adversary**: Can choose the set of $n$ points and can specify the relative order of points that are collinear with $p_0$.\n- **Objective**: Maximize the total number of pop operations.\n- **Required Output**: An explicit adversarial input, a derivation of the maximum number of pops $R(n)$, and the closed-form expression for $R(n)$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem describes a variant of the Graham scan algorithm, a fundamental algorithm in computational geometry. The orientation test is based on the standard 2D cross product. The problem is mathematically and algorithmically sound.\n- **Well-Posed**: The problem asks for the maximum number of pops in a worst-case scenario. This is a well-defined objective in algorithm analysis. The conditions are specified, and a unique answer is expected.\n- **Objective**: The problem is stated in precise, objective language. The algorithm's steps and the adversary's capabilities are clearly defined.\n\nThe problem is valid as it is a well-posed, formal problem in the analysis of algorithms.\n\n### Step 3: Proceed to Solution\n\nThe solution involves determining the maximum possible number of pop operations, $R(n)$, that an adversary can induce.\n\nLet's analyze the total number of stack operations. The algorithm processes a sequence of $n$ points, which we label $p_0, p_1, \\dots, p_{n-1}$ according to the specified sorting order.\nEach of these $n$ points is pushed onto the stack exactly once during the execution of the algorithm.\n- $p_0$ and $p_1$ are pushed during initialization.\n- For $i=2, \\dots, n-1$, the point $p_i$ is pushed at the end of the $i$-th iteration of the main loop.\n\nA point that is on the stack can either remain there until the algorithm terminates or be removed by a single `pop` operation. A point, once popped, is never pushed again.\nLet $S_{final}$ be the set of points remaining on the stack when the algorithm finishes. Let $h = |S_{final}|$ be the number of vertices in the convex hull as determined by the algorithm.\nLet $P_{popped}$ be the set of all points that were popped from the stack during the execution. The total number of pop operations is $R(n) = |P_{popped}|$.\nThe initial set of all $n$ points, $P = \\{p_0, p_1, \\dots, p_{n-1}\\}$, is partitioned into two disjoint sets: those that remain on the stack at the end and those that were popped.\n$$P = S_{final} \\cup P_{popped}$$\nThus, the number of points satisfies $|P| = |S_{final}| + |P_{popped}|$, which gives:\n$$n = h + R(n)$$\nFrom this identity, the total number of pops is:\n$$R(n) = n - h$$\nTo maximize the number of pops $R(n)$, the adversary must choose an input configuration of points that minimizes the final number of points on the stack, $h$.\n\nNext, we establish a lower bound on $h$. The problem specifies $n \\ge 3$. The stack is initialized with $p_0$ and $p_1$, so its size is initially $2$. The main loop, which iterates from $i=2$ to $n-1$, performs some number of pops (possibly zero) and always concludes with one push ($p_i$). In any given step, if the stack has size $m$ and $k$ pops occur, its size becomes $m-k$. Then, a push occurs, and the size becomes $m-k+1$. The stack can never be empty, as $p_0$ is never popped (it can never be the top element of the stack). In fact, after initialization, the stack size is always at least $2$. Therefore, the final number of points on the stack, $h$, must be at least $2$.\n$$h \\ge 2$$\nThis implies an upper bound on the number of pops:\n$$R(n) = n - h \\le n - 2$$\n\nTo demonstrate that this upper bound is tight, we must construct an adversarial input for which the algorithm performs exactly $n-2$ pops. This requires finding a configuration of $n$ points for which the algorithm terminates with $h=2$.\n\n**Adversarial Input Construction:**\nLet the adversary choose a set of $n$ collinear points. A simple choice is:\n$$P_k = (k, 0) \\quad \\text{for } k = 0, 1, \\dots, n-1$$\n1.  **Pivot Selection**: The point with the minimum $y$-coordinate is not unique. The tie-breaking rule specifies choosing the one with the minimum $x$-coordinate. This uniquely selects $p_0 = P_0 = (0,0)$.\n\n2.  **Angular Sort**: The remaining $n-1$ points, $P_1, \\dots, P_{n-1}$, all lie on the positive $x$-axis relative to $p_0$. Their polar angle with respect to $p_0$ is consistently $0$.\n\n3.  **Adversarial Tie-Breaking**: The problem states that for points with an identical polar angle, their relative order is unspecified, and the adversary can choose this order. To maximize pops, the adversary arranges these points in order of *decreasing* distance from $p_0$. The sorted list of points to be processed is $p_1, p_2, \\dots, p_{n-1}$, where:\n    $$p_i = P_{n-i} = (n-i, 0) \\quad \\text{for } i = 1, \\dots, n-1$$\n    So, $p_1 = (n-1, 0)$, $p_2 = (n-2, 0)$, and so on, until $p_{n-1} = (1, 0)$.\n\n**Execution Analysis:**\n- **Initialization**: The stack $S$ is initialized by pushing $p_0 = (0,0)$ and then $p_1 = (n-1,0)$. So, $S = [ (0,0), (n-1,0) ]$.\n\n- **Main Loop (for $i=2, \\dots, n-1$):**\n  Consider the iteration for a general $i$. The point to be processed is $p_i = (n-i, 0)$.\n  At the start of this iteration, the stack from the previous iteration contains $S = [p_0, p_{i-1}] = [(0,0), (n-(i-1), 0)]$.\n  Let $a$ be the second-to-last element and $b$ be the top element on the stack.\n  $b = p_{i-1} = (n-i+1, 0)$.\n  $a = p_0 = (0,0)$.\n  The algorithm checks the condition $\\operatorname{orient}(a, b, p_i) \\le 0$.\n  $$\\operatorname{orient}(p_0, p_{i-1}, p_i) = \\operatorname{sign}\\Big( ((n-i+1)_x - 0_x)((n-i)_y - 0_y) - ((n-i+1)_y - 0_y)((n-i)_x - 0_x) \\Big)$$\n  $$= \\operatorname{sign}\\Big( (n-i+1)(0) - (0)(n-i) \\Big) = \\operatorname{sign}(0) = 0$$\n  The condition is satisfied ($0 \\le 0$). Thus, a `pop` operation is performed. The top element, $b = p_{i-1}$, is popped.\n  After the pop, the stack contains only one element, $p_0$. The `while` loop's condition requires two elements to check an orientation, so the loop terminates.\n  Finally, the point $p_i$ is pushed onto the stack. The stack becomes $S = [p_0, p_i]$.\n\nThis sequence of events occurs for each iteration of the loop, from $i=2$ to $i=n-1$. In each of these iterations, exactly one pop operation occurs.\nThe total number of iterations is $(n-1) - 2 + 1 = n-2$.\nTherefore, the total number of pop operations is:\n$$R(n) = \\sum_{i=2}^{n-1} 1 = n-2$$\nThis construction achieves the upper bound of $n-2$ pops. At the end of the algorithm, the stack contains $S = [p_0, p_{n-1}] = [(0,0), (1,0)]$. The size of the final hull is $h=2$, which is consistent with our derived formula $R(n) = n-h = n-2$.\n\nThe maximum number of pop operations is therefore $n-2$. This result is exact and tight.", "answer": "$$\n\\boxed{n-2}\n$$", "id": "3224243"}]}