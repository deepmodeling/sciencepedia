{"hands_on_practices": [{"introduction": "At the heart of line segment intersection lies the orientation test, a simple determinant calculation. While mathematically straightforward, its implementation on a computer reveals the critical gap between abstract real numbers and finite-precision floating-point arithmetic. This practice [@problem_id:3244227] guides you through constructing adversarial test cases to demonstrate precisely how and why naive floating-point approaches can fail, thereby cementing the importance of exact geometric predicates for creating robust software.", "problem": "You are to design and implement a complete program that constructs adversarial collections of pairs of planar line segments and evaluates the robustness of a naive floating-point line-segment intersection test against an exact-predicate line-segment intersection test. The mathematical foundation must start from first principles: the definition of planar orientation via the determinant of translated vectors and the resulting logical conditions for segment intersection. Specifically, given three points $p=(p_x,p_y)$, $q=(q_x,q_y)$, and $r=(r_x,r_y)$ in the plane, the signed area of the triangle determined by these points is defined by the two-dimensional cross product\n$$\n\\operatorname{orient}(p,q,r) = (q_x - p_x)\\cdot(r_y - p_y) - (q_y - p_y)\\cdot(r_x - p_x).\n$$\nThe sign of $\\operatorname{orient}(p,q,r)$ yields the orientation: positive for counterclockwise, zero for collinear, negative for clockwise. Two line segments $[p_1,q_1]$ and $[p_2,q_2]$ intersect if and only if their orientations satisfy the general-case crossing condition and the boundary collinearity cases, derived from these definitions. The naive predicate computes $\\operatorname{orient}$ and all comparisons in double-precision floating point, while the exact predicate computes all values using integers, thereby guaranteeing exactness when all input coordinates are integers.\n\nYou must implement two intersection predicates grounded in the above definitions:\n- A naive floating-point predicate that evaluates all arithmetic in double-precision floating point as provided by the programming language's default $64$-bit floating type.\n- An exact predicate that evaluates all arithmetic using integer operations, leveraging exact integer arithmetic when coordinates are integers.\n\nThen, you must generate adversarial test inputs designed to stress numerical robustness:\n- Near-parallel or parallel segments with very large coordinate magnitudes and small separations, so that differences below the Unit in the Last Place ($ULP$) at the given magnitude are lost under floating-point rounding.\n- Segments that share endpoints to test boundary handling.\n- Overlapping collinear segments and non-overlapping collinear segments to test collinearity and on-segment logic.\n\nUse the following test suite. Each test case is a set of pairs of segments, and all coordinates must be integers. Let $B = 2^{60}$.\n\n1. Happy-path moderate scale ($N=12$ pairs): For $i=0,1,2,3,4,5$, include the pairs\n   - $[p_1,q_1]=[(i,0),(i,10)]$, $[p_2,q_2]=[(i-1,5),(i+1,5)]$,\n   which intersect. For $i=6,7,8,9,10,11$, include the pairs\n   - $[p_1,q_1]=[(i,0),(i,10)]$, $[p_2,q_2]=[(i-1,15),(i+1,15)]$,\n   which do not intersect. These exercise the general crossing logic at moderate magnitudes where floating-point arithmetic is expected to be reliable.\n\n2. Adversarial near-parallel at large scale ($N=16$ pairs): For $i=0,1,\\dots,15$, include the pairs\n   - $[p_1,q_1]=[(B+i,B),(B+i,B+10)]$ and $[p_2,q_2]=[(B+i+10,B),(B+i+10,B+10)]$.\n   These are two vertical segments separated by a horizontal gap of $10$. At magnitude $B=2^{60}$, the $ULP$ of double precision is $2^{8}=256$, so adding $10$ or any value less than $256$ is not represented in the floating-point format; differences like $(B+i+10)-(B+i)$ will be rounded to $0$ when cast to floating point. This creates severe rounding that can cause the naive predicate to misclassify non-intersecting segments.\n\n3. Shared endpoints at moderate scale ($N=10$ pairs): For $i=0,1,\\dots,9$, include the pairs\n   - $[p_1,q_1]=[(i,i),(i+5,i+5)]$ and $[p_2,q_2]=[(i+5,i+5),(i+10,i)]$.\n   These pairs share the endpoint $(i+5,i+5)$, forming a boundary intersection case.\n\n4. Collinear overlapping and non-overlapping at large scale ($N=12$ pairs): Include $6$ overlapping pairs and $6$ non-overlapping pairs on the horizontal line $y=B$:\n   - Overlapping ($6$ pairs): $[p_1,q_1]=[(B,B),(B+5,B)]$, $[p_2,q_2]=[(B+2,B),(B+7,B)]$.\n   - Non-overlapping ($6$ pairs): $[p_1,q_1]=[(B,B),(B+5,B)]$, $[p_2,q_2]=[(B+6,B),(B+10,B)]$.\n   At magnitude $B=2^{60}$, adding any integer less than $256$ to $B$ will be rounded away in floating-point, so the naive predicate may conflate distinct points or segments, misclassifying non-overlapping segments as overlapping.\n\nFor each test case, compute the failure rate of the naive predicate relative to the exact predicate as a decimal number $f = \\frac{\\text{number of mismatches}}{\\text{number of pairs}}$. Also compute the overall failure rate across all pairs in the entire suite. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order: $[\\text{rate\\_happy},\\text{rate\\_near\\_parallel},\\text{rate\\_shared\\_endpoint},\\text{rate\\_collinear},\\text{rate\\_overall}]$. No input is required; all data must be generated by the program internally. The only acceptable output types for the entries are decimal numbers (floating point), integers, booleans, or lists of these; here you must use decimal numbers for the rates. No physical units or angles appear in this task.", "solution": "The problem is valid as it is scientifically grounded in the principles of computational geometry, is well-posed with a unique deterministic solution, and is stated using objective, formal language. The task is to implement and compare an exact-arithmetic line segment intersection predicate against a naive floating-point predicate, using adversarial test cases designed to highlight the pitfalls of finite-precision arithmetic.\n\nThe mathematical foundation for determining the intersection of two line segments is the orientation test. Given three ordered points $p=(p_x, p_y)$, $q=(q_x, q_y)$, and $r=(r_x, r_y)$ in a plane, the orientation can be determined by computing the sign of the two-dimensional cross product of the vectors $\\vec{pq}$ and $\\vec{pr}$. This is given by the determinant:\n$$\n\\operatorname{orient}(p,q,r) = \\det(\\vec{pq}, \\vec{pr}) = (q_x - p_x)(r_y - p_y) - (q_y - p_y)(r_x - p_x)\n$$\nThe sign of this expression determines the orientation:\n- If $\\operatorname{orient}(p,q,r) > 0$, the sequence of points $p \\to q \\to r$ constitutes a counter-clockwise (left) turn.\n- If $\\operatorname{orient}(p,q,r) < 0$, it is a clockwise (right) turn.\n- If $\\operatorname{orient}(p,q,r) = 0$, the three points are collinear.\n\nTwo line segments, $[p_1, q_1]$ and $[p_2, q_2]$, intersect if and only if one of two conditions holds:\n1.  **General Case:** The segments properly cross each other. This occurs if the endpoints of each segment lie on opposite sides of the line containing the other segment. This condition is met if and only if the orientations $(\\operatorname{orient}(p_1, q_1, p_2), \\operatorname{orient}(p_1, q_1, q_2))$ and $(\\operatorname{orient}(p_2, q_2, p_1), \\operatorname{orient}(p_2, q_2, q_1))$ are both pairs of opposite signs (one positive, one negative).\n2.  **Special Case (Collinear):** An endpoint of one segment lies on the other segment. This covers cases of shared endpoints and overlapping collinear segments. This occurs if an orientation test yields zero (e.g., $\\operatorname{orient}(p_1, q_1, p_2)=0$) and the point involved in that test (here, $p_2$) lies within the bounding box of the segment (here, $[p_1, q_1]$). A point $r$ is on a segment $[p,q]$ if it is collinear with $p$ and $q$ and its coordinates lie between those of $p$ and $q$:\n    $$\n    (\\min(p_x, q_x) \\le r_x \\le \\max(p_x, q_x)) \\land (\\min(p_y, q_y) \\le r_y \\le \\max(p_y, q_y))\n    $$\n\nThe program will implement two versions of this intersection algorithm:\n-   **Exact Predicate:** This predicate operates on integer coordinates. Since all inputs are specified as integers, the orientation formula involves only integer subtractions and multiplications. Python's arbitrary-precision integers guarantee that these operations are performed without loss of precision, leading to a mathematically exact result for the sign of the determinant.\n-   **Naive Predicate:** This predicate uses standard $64$-bit double-precision floating-point arithmetic (the language's `float` type, here explicitly `numpy.float64`). Input integer coordinates are first cast to floating-point numbers.\n\nThe adversarial test cases are designed to exploit the inherent limitations of floating-point representation. A standard $64$-bit float has a finite precision (a $52$-bit mantissa). This leads to two primary failure modes in geometric computations:\n-   **Precision Loss at Large Magnitudes:** For a large number $x$, the gap between it and the next representable floating-point number, known as the Unit in the Last Place ($ULP$), becomes large. For $x = B = 2^{60}$, the $ULP$ is $2^{60-52} = 2^8 = 256$. Consequently, adding a small integer $\\delta$ where $|\\delta| < ULP/2 = 128$ to $B$ results in a value that rounds back to the original floating-point representation of $B$. That is, $fl(B+\\delta) = fl(B)$. The adversarial tests use this by defining coordinates like $(B+i, B)$ and $(B+i+10, B)$, which are distinct in integer arithmetic but collapse to identical points in floating-point arithmetic, causing the naive predicate to fail.\n-   **Catastrophic Cancellation:** The orientation formula involves subtractions. When two nearly equal large numbers are subtracted, the leading significant digits cancel out, and the result is dominated by rounding errors. This can cause the computed orientation value to have an incorrect sign or to be erroneously zero, leading to incorrect intersection results.\n\nThe solution program follows these steps:\n1.  Implement the exact and naive orientation and intersection predicates.\n2.  Generate the four specified test suites: a \"happy path\" with moderate coordinates, a case with shared endpoints, and two adversarial cases using the large magnitude $B=2^{60}$ to test near-parallel non-intersecting segments and collinear segments.\n3.  For each pair of segments in each test suite, the results of the naive and exact predicates are compared. A mismatch is recorded if they differ.\n4.  The failure rate for each suite is computed as the ratio of mismatches to the total number of pairs in that suite. An overall failure rate across all test cases is also computed.\n5.  The final results are formatted and printed as a comma-separated list.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs, implements, and evaluates naive vs. exact line segment intersection predicates.\n    \"\"\"\n\n    # --- PREDICATE IMPLEMENTATIONS ---\n\n    def orient_exact(p, q, r):\n        \"\"\"\n        Computes the orientation of ordered triplet (p, q, r) using exact integer arithmetic.\n        Returns:\n            > 0 for counter-clockwise turn,\n            < 0 for clockwise turn,\n            = 0 for collinear points.\n        \"\"\"\n        # Python's `int` type supports arbitrary precision, ensuring exactness.\n        val = (q[0] - p[0]) * (r[1] - p[1]) - \\\n              (q[1] - p[1]) * (r[0] - p[0])\n        if val == 0:\n            return 0  # Collinear\n        return 1 if val > 0 else -1  # CCW or CW\n\n    def orient_naive(p, q, r):\n        \"\"\"\n        Computes the orientation using 64-bit floating-point arithmetic.\n        Coordinates are cast to np.float64, which may introduce rounding errors.\n        \"\"\"\n        px, py = np.float64(p[0]), np.float64(p[1])\n        qx, qy = np.float64(q[0]), np.float64(q[1])\n        rx, ry = np.float64(r[0]), np.float64(r[1])\n        \n        val = (qx - px) * (ry - py) - (qy - py) * (rx - px)\n        \n        if val == 0.0:\n            return 0\n        return 1 if val > 0.0 else -1\n\n    def on_segment(p, q, r):\n        \"\"\"\n        Given three collinear points p, q, r, this function checks\n        if point q lies on line segment 'pr'.\n        This works for both integer and float coordinate types.\n        \"\"\"\n        return (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n                q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]))\n\n    def intersects_exact(s1, s2):\n        \"\"\"\n        Returns true if line segment 's1' and 's2' intersect, using exact predicates.\n        s1 = (p1, q1), s2 = (p2, q2)\n        \"\"\"\n        p1, q1 = s1\n        p2, q2 = s2\n        \n        o1 = orient_exact(p1, q1, p2)\n        o2 = orient_exact(p1, q1, q2)\n        o3 = orient_exact(p2, q2, p1)\n        o4 = orient_exact(p2, q2, q1)\n\n        # General case (proper intersection) and T-junctions\n        if o1 != o2 and o3 != o4:\n            return True\n\n        # Special Cases (Collinear):\n        # An endpoint of one segment lies on the other segment.\n        if o1 == 0 and on_segment(p1, p2, q1): return True\n        if o2 == 0 and on_segment(p1, q2, q1): return True\n        if o3 == 0 and on_segment(p2, p1, q2): return True\n        if o4 == 0 and on_segment(p2, q1, q2): return True\n            \n        return False\n\n    def intersects_naive(s1, s2):\n        \"\"\"\n        Returns true if line segment 's1' and 's2' intersect, using naive predicates.\n        \"\"\"\n        p1, q1 = s1\n        p2, q2 = s2\n        \n        o1 = orient_naive(p1, q1, p2)\n        o2 = orient_naive(p1, q1, q2)\n        o3 = orient_naive(p2, q2, p1)\n        o4 = orient_naive(p2, q2, q1)\n\n        # General case (proper intersection) and T-junctions\n        if o1 != o2 and o3 != o4:\n            return True\n\n        # Special case: float coordinates must be used for on_segment check\n        p1_f, q1_f = (np.float64(p1[0]), np.float64(p1[1])), (np.float64(q1[0]), np.float64(q1[1]))\n        p2_f, q2_f = (np.float64(p2[0]), np.float64(p2[1])), (np.float64(q2[0]), np.float64(q2[1]))\n        \n        if o1 == 0 and on_segment(p1_f, p2_f, q1_f): return True\n        if o2 == 0 and on_segment(p1_f, q2_f, q1_f): return True\n        if o3 == 0 and on_segment(p2_f, p1_f, q2_f): return True\n        if o4 == 0 and on_segment(p2_f, q1_f, q2_f): return True\n        \n        return False\n\n    # --- TEST CASE GENERATION ---\n\n    def generate_test_cases():\n        B = 2**60\n        \n        # Case 1: Happy-path moderate scale\n        happy_path = []\n        for i in range(6):  # Intersecting\n            p1, q1 = (i, 0), (i, 10)\n            p2, q2 = (i - 1, 5), (i + 1, 5)\n            happy_path.append(((p1, q1), (p2, q2)))\n        for i in range(6, 12):  # Non-intersecting\n            p1, q1 = (i, 0), (i, 10)\n            p2, q2 = (i - 1, 15), (i + 1, 15)\n            happy_path.append(((p1, q1), (p2, q2)))\n\n        # Case 2: Adversarial near-parallel\n        near_parallel = []\n        for i in range(16):\n            p1, q1 = (B + i, B), (B + i, B + 10)\n            p2, q2 = (B + i + 10, B), (B + i + 10, B + 10)\n            near_parallel.append(((p1, q1), (p2, q2)))\n            \n        # Case 3: Shared endpoints\n        shared_endpoint = []\n        for i in range(10):\n            p1, q1 = (i, i), (i + 5, i + 5)\n            p2, q2 = (i + 5, i + 5), (i + 10, i)\n            shared_endpoint.append(((p1, q1), (p2, q2)))\n\n        # Case 4: Collinear large scale\n        collinear = []\n        # Overlapping (6 pairs)\n        p1_o, q1_o = (B, B), (B + 5, B)\n        p2_o, q2_o = (B + 2, B), (B + 7, B)\n        for _ in range(6):\n            collinear.append(((p1_o, q1_o), (p2_o, q2_o)))\n        # Non-overlapping (6 pairs)\n        p1_n, q1_n = (B, B), (B + 5, B)\n        p2_n, q2_n = (B + 6, B), (B + 10, B)\n        for _ in range(6):\n            collinear.append(((p1_n, q1_n), (p2_n, q2_n)))\n            \n        return [happy_path, near_parallel, shared_endpoint, collinear]\n\n    # --- MAIN EXECUTION LOGIC ---\n\n    test_suites = generate_test_cases()\n    failure_rates = []\n    total_mismatches = 0\n    total_pairs = 0\n\n    for suite in test_suites:\n        mismatches = 0\n        num_pairs = len(suite)\n        if num_pairs == 0:\n            failure_rates.append(0.0)\n            continue\n            \n        for s1, s2 in suite:\n            exact_result = intersects_exact(s1, s2)\n            naive_result = intersects_naive(s1, s2)\n            if exact_result != naive_result:\n                mismatches += 1\n        \n        rate = mismatches / num_pairs\n        failure_rates.append(rate)\n        \n        total_mismatches += mismatches\n        total_pairs += num_pairs\n        \n    overall_rate = total_mismatches / total_pairs if total_pairs > 0 else 0.0\n    failure_rates.append(overall_rate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, failure_rates))}]\")\n\nsolve()\n```", "id": "3244227"}, {"introduction": "Building on a robust segment intersection test, we now apply this tool to a more complex geometric structure: a polygon. Determining if a polygon is \"simple\" or \"self-intersecting\" is a classic problem in computer graphics and computational geometry. This practice [@problem_id:3244246] challenges you to design an algorithm that correctly distinguishes between allowed intersections at shared vertices of adjacent edges and invalid intersections between non-adjacent edges, a crucial skill for processing geometric data.", "problem": "You are given a planar polygon defined by an ordered list of vertices. Let the vertices be denoted by $p_0, p_1, \\dots, p_{n-1}$, where each $p_i$ is a point in the Euclidean plane with integer coordinates $p_i = (x_i, y_i)$. The polygon edges are the line segments $e_i = [p_i, p_{(i+1) \\bmod n}]$ for $i = 0, 1, \\dots, n-1$. A polygon is called self-intersecting if there exists a pair of edges $e_i$ and $e_j$ with $i \\neq j$ that have a nonempty intersection, except that intersections at shared endpoints of consecutive edges are allowed. Intersections between nonconsecutive edges that occur at endpoints or interiors are considered self-intersections. Degenerate edges, where $p_i = p_{(i+1) \\bmod n}$, are permitted. A degenerate edge alone does not make the polygon self-intersecting, but if a degenerate edge lies on or touches any nonadjacent edge, this counts as a self-intersection.\n\nStarting from the core definitions of planar geometry and orientation, design an algorithm that determines whether a given polygon is self-intersecting. Use only integer arithmetic. Your algorithm must be based on the following fundamental definitions and facts of planar geometry:\n\n- For points $a = (x_a, y_a)$, $b = (x_b, y_b)$, and $c = (x_c, y_c)$, the oriented area (signed cross product) of the triangle $(a, b, c)$ is\n$$\n\\Delta(a, b, c) = (x_b - x_a)(y_c - y_a) - (y_b - y_a)(x_c - x_a).\n$$\n- The orientation of $(a, b, c)$ is counterclockwise if $\\Delta(a, b, c) > 0$, clockwise if $\\Delta(a, b, c) < 0$, and collinear if $\\Delta(a, b, c) = 0$.\n- A point $b$ lies on the closed segment $[a, c]$ if and only if $b$ is collinear with $(a, c)$ and $x_b$ lies between $\\min(x_a, x_c)$ and $\\max(x_a, x_c)$, and $y_b$ lies between $\\min(y_a, y_c)$ and $\\max(y_a, y_c)$.\n\nYour program must implement an intersection test for two closed segments $[p_1, q_1]$ and $[p_2, q_2]$ that correctly handles the general case and the collinear special cases. Two edges are considered adjacent if their indices are consecutive modulo $n$ (that is, $j = (i+1) \\bmod n$ or $i = (j+1) \\bmod n$). Adjacent edge intersections at their shared endpoint must be ignored.\n\nYour task is to write a complete program that evaluates the following test suite of polygons, each given as a list of integer coordinate pairs in order, and outputs whether each polygon is self-intersecting:\n\n- Test $1$ (simple convex quadrilateral): $[(0, 0), (3, 0), (3, 3), (0, 3)]$.\n- Test $2$ (simple triangle): $[(0, 0), (5, 0), (2, 4)]$.\n- Test $3$ (bow-tie polygon with a proper crossing): $[(0, 0), (4, 4), (0, 4), (4, 0)]$.\n- Test $4$ (nonadjacent endpoint touch due to repeated vertex): $[(0, 0), (3, 0), (3, 3), (0, 3), (0, 0)]$.\n- Test $5$ (collinear overlapping nonadjacent edges): $[(0, 0), (2, 0), (3, 0), (1, 0)]$.\n- Test $6$ (zero-length edge that does not create a nonadjacent intersection): $[(0, 0), (2, 0), (2, 0), (2, 2), (0, 2)]$.\n- Test $7$ (interior crossing between nonadjacent edges): $[(0, 0), (2, 0), (1, 1), (1, -1)]$.\n- Test $8$ (concave but simple polygon): $[(0, 0), (4, 0), (4, 3), (2, 5), (0, 3)]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must be a boolean. For example, the output format must be exactly like $[r_1, r_2, \\dots, r_8]$, where each $r_i$ is either $True$ or $False$ corresponding to Test $i$ in order.", "solution": "The user wants to solve a computational geometry problem.\n\nThe problem is to determine if a polygon, defined by an ordered list of vertices, is self-intersecting. The solution must be based on fundamental geometric primitives provided in the problem statement and must use only integer arithmetic.\n\n### Step 1: Extract Givens\n- **Vertices**: An ordered list of points $p_0, p_1, \\dots, p_{n-1}$, where each $p_i = (x_i, y_i)$ has integer coordinates.\n- **Edges**: Line segments $e_i = [p_i, p_{(i+1) \\bmod n}]$ for $i = 0, 1, \\dots, n-1$.\n- **Self-Intersection Definition**: A polygon is self-intersecting if there exists a pair of edges $e_i$ and $e_j$ with $i \\neq j$ that have a nonempty intersection.\n- **Exception to Self-Intersection**: Intersections at shared endpoints of consecutive edges are allowed (i.e., not considered self-intersections).\n- **Rule for Self-Intersection**: Intersections between nonconsecutive edges, whether at an endpoint or in the interior of an edge, are considered self-intersections.\n- **Degenerate Edges**: Edges where $p_i = p_{(i+1) \\bmod n}$ are permitted. A degenerate edge does not by itself cause a self-intersection, but it is counted if it intersects a nonadjacent edge.\n- **Adjacent Edges Definition**: Edges $e_i$ and $e_j$ are adjacent if their indices are consecutive modulo $n$, i.e., $j = (i+1) \\bmod n$ or $i = (j+1) \\bmod n$.\n- **Orientation Formula**: For points $a = (x_a, y_a)$, $b = (x_b, y_b)$, and $c = (x_c, y_c)$, the signed cross product is $\\Delta(a, b, c) = (x_b - x_a)(y_c - y_a) - (y_b - y_a)(x_c - x_a)$. The orientation is determined by the sign of $\\Delta(a, b, c)$: positive for counterclockwise, negative for clockwise, and zero for collinear.\n- **On-Segment Condition**: A point $b$ lies on the closed segment $[a, c]$ if and only if it is collinear with $a$ and $c$ (i.e., $\\Delta(a, b, c) = 0$) and its coordinates lie within the bounding box of the segment: $x_b \\in [\\min(x_a, x_c), \\max(x_a, x_c)]$ and $y_b \\in [\\min(y_a, y_c), \\max(y_a, y_c)]$.\n- **Test Cases**: The problem provides eight specific polygons to be tested.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to a rigorous validation process.\n\n- **Scientifically Grounded**: The problem is well-rooted in standard Euclidean and computational geometry. The definitions for orientation (cross product), collinearity, and segment intersection are fundamental and mathematically sound.\n- **Well-Posed**: The problem is clearly defined. The definitions of polygon, edge, adjacency, and self-intersection are precise and unambiguous. This structure guarantees a unique, deterministic boolean answer for any given polygon.\n- **Objective**: The language is formal and objective. It provides mathematical definitions and avoids any subjective or opinion-based statements.\n- **Completeness and Consistency**: The problem is self-contained. All necessary definitions and formulas are provided. The rules for handling general cases, special collinear cases, degenerate edges, and adjacency are explicit and consistent.\n- **Feasibility**: The constraints are realistic. All coordinates are integers, and the required calculations can be performed using integer arithmetic, thus avoiding floating-point precision issues.\n\nThe problem has no identifiable flaws. It is a standard, albeit subtle, problem in computational geometry. The definitions are rigorous and must be followed precisely, especially concerning the distinction between consecutive and non-consecutive edges, which is based on vertex indices, not just geometric adjacency.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be constructed based on the provided principles.\n\n### Algorithmic Design\n\nThe core of the algorithm is to check every pair of non-consecutive edges for intersection. This can be broken down into three main components.\n\n1.  **Geometric Primitives**: We first implement helper functions for the fundamental geometric tests based on the provided definitions.\n    -   `orientation(p, q, r)`: This function will take three points $p$, $q$, and $r$ and compute the value of $\\Delta(p, q, r)$. The sign of this value determines if the turn from segment $[p, q]$ to $[q, r]$ is counterclockwise ($> 0$), clockwise ($< 0$), or if the points are collinear ($= 0$).\n    -   `on_segment(p, q, r)`: This function checks if a point $q$ lies on the line segment $[p, r]$. It will be used only when it is already known that the three points are collinear. It verifies that the coordinates of $q$ are within the minimum and maximum coordinates of $p$ and $r$.\n\n2.  **Segment Intersection Test**: A function `segments_intersect(p1, q1, p2, q2)` will determine if two closed line segments, $[p1, q1]$ and $[p2, q2]$, intersect. This function must handle two categories of cases:\n    -   **General Case**: The segments cross each other properly. This occurs if the endpoints of each segment lie on opposite sides of the line containing the other segment. This can be tested by computing four orientations: $\\Delta(p1, q1, p2)$, $\\Delta(p1, q1, q2)$, $\\Delta(p2, q2, p1)$, and $\\Delta(p2, q2, q1)$. An intersection occurs if the first two orientations have opposite signs, and the last two also have opposite signs. Using integer arithmetic, this is checked by seeing if the product of the orientations is negative (e.g., $\\Delta_1 \\cdot \\Delta_2 < 0$).\n    -   **Special (Collinear) Cases**: An endpoint of one segment lies on the other segment. This covers cases where segments touch at an endpoint (a T-junction) or overlap along a line. For each of the four orientation calculations, if the result is $0$, it signifies that three points are collinear. We must then use the `on_segment` function to check if this collinear point lies on the relevant segment. For example, if $\\Delta(p1, q1, p2) = 0$, we check if $p2$ lies on the segment $[p1, q1]$. An intersection exists if any of these four collinear conditions are met.\n\n3.  **Polygon Self-Intersection Check**: The main function `is_self_intersecting(polygon)` iterates through all unique pairs of edges $(e_i, e_j)$ of the polygon and checks for intersection.\n    -   The number of vertices is $n$. The edges are $e_0, e_1, \\dots, e_{n-1}$.\n    -   We use nested loops to iterate through all pairs of indices $(i, j)$ such that $0 \\le i < j < n$.\n    -   For each pair $(i, j)$, we must first determine if the edges $e_i$ and $e_j$ are consecutive. According to the problem, edges are consecutive if their indices are consecutive modulo $n$. For a pair $(i, j)$ where $i < j$, this means we must skip the check if $j = i+1$ (standard adjacency) or if $i=0$ and $j=n-1$ (wrap-around adjacency).\n    -   If the edges are not consecutive, we call `segments_intersect` on them.\n    -   If `segments_intersect` returns true for any pair of non-consecutive edges, we have found a self-intersection. The function can immediately return `True`.\n    -   If the loops complete without finding any such intersections, the polygon is simple, and the function returns `False`.\n\nThis algorithmic structure systematically and correctly implements all rules specified in the problem statement, including the careful handling of non-consecutive edge intersections at endpoints, which can arise from repeated vertices in the polygon's definition.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the polygon self-intersection problem for a suite of test cases.\n    \"\"\"\n\n    # Helper function to compute the orientation of an ordered triplet (p, q, r).\n    # The orientation determines if the turn from segment pq to qr is\n    # counter-clockwise, clockwise, or collinear.\n    # Returns:\n    # > 0 for counter-clockwise\n    # < 0 for clockwise\n    # = 0 for collinear\n    def orientation(p, q, r):\n        # Using the formula: (q_x - p_x)(r_y - p_y) - (q_y - p_y)(r_x - p_x)\n        # All coordinates are integers, so the result is a guaranteed integer.\n        val = (q[0] - p[0]) * (r[1] - p[1]) - \\\n              (q[1] - p[1]) * (r[0] - p[0])\n        return val\n\n    # Helper function to check if point q lies on the closed segment [p, r].\n    # This function assumes p, q, and r are already known to be collinear.\n    def on_segment(p, q, r):\n        # Checks if q's coordinates are within the bounding box of p and r.\n        return (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n                q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]))\n\n    # Function to check if line segment [p1, q1] and [p2, q2] intersect.\n    def segments_intersect(p1, q1, p2, q2):\n        # Calculate the four orientations needed for general and special cases.\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n\n        # General case: The segments cross each other.\n        # This happens if the orientations (p1,q1,p2) and (p1,q1,q2) are different,\n        # and (p2,q2,p1) and (p2,q2,q1) are also different.\n        if o1 * o2 < 0 and o3 * o4 < 0:\n            return True\n\n        # Special Cases (Collinear):\n        # An endpoint of one segment lies on the other segment.\n        # o1 = 0: p1, q1, p2 are collinear. Check if p2 is on segment [p1, q1].\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        # o2 = 0: p1, q1, q2 are collinear. Check if q2 is on segment [p1, q1].\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        # o3 = 0: p2, q2, p1 are collinear. Check if p1 is on segment [p2, q2].\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        # o4 = 0: p2, q2, q1 are collinear. Check if q1 is on segment [p2, q2].\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n\n        # If none of the above, the segments do not intersect.\n        return False\n\n    # Main function to determine if a polygon is self-intersecting.\n    def is_self_intersecting(polygon):\n        n = len(polygon)\n        if n < 3:\n            # A polygon must have at least 3 vertices to potentially self-intersect.\n            return False\n\n        # Iterate through all unique pairs of edges (e_i, e_j).\n        for i in range(n):\n            for j in range(i + 1, n):\n                # According to the problem, adjacent edges are defined by consecutive indices.\n                # We must skip pairs of adjacent edges.\n                # Case 1: Standard adjacency (e.g., e_i and e_{i+1})\n                if j == i + 1:\n                    continue\n                # Case 2: Wrap-around adjacency (e.g., e_{n-1} and e_0)\n                if i == 0 and j == n - 1:\n                    continue\n\n                # Get the endpoints of the two edges e_i and e_j.\n                p1 = polygon[i]\n                q1 = polygon[(i + 1) % n]\n                p2 = polygon[j]\n                q2 = polygon[(j + 1) % n]\n\n                # Check for intersection between these non-adjacent edges.\n                # Any intersection (endpoint or interior) counts as a self-intersection.\n                if segments_intersect(p1, q1, p2, q2):\n                    return True\n        \n        # If no intersections between non-adjacent edges are found, the polygon is simple.\n        return False\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: simple convex quadrilateral\n        [(0, 0), (3, 0), (3, 3), (0, 3)],\n        # Test 2: simple triangle\n        [(0, 0), (5, 0), (2, 4)],\n        # Test 3: bow-tie polygon with a proper crossing\n        [(0, 0), (4, 4), (0, 4), (4, 0)],\n        # Test 4: nonadjacent endpoint touch due to repeated vertex\n        [(0, 0), (3, 0), (3, 3), (0, 3), (0, 0)],\n        # Test 5: collinear overlapping nonadjacent edges\n        [(0, 0), (2, 0), (3, 0), (1, 0)],\n        # Test 6: non-consecutive edges touching due to a repeated vertex\n        [(0, 0), (2, 0), (2, 0), (2, 2), (0, 2)],\n        # Test 7: interior crossing between nonadjacent edges\n        [(0, 0), (2, 0), (1, 1), (1, -1)],\n        # Test 8: concave but simple polygon\n        [(0, 0), (4, 0), (4, 3), (2, 5), (0, 3)],\n    ]\n\n    results = []\n    for polygon in test_cases:\n        result = is_self_intersecting(polygon)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output format is a string representation of a Python list of booleans.\n    # Using map(str, ...) and join handles the True/False capitalization correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244246"}, {"introduction": "Real-world applications often involve geometric data enriched with attributes, such as layers in a GIS map or component types in a CAD model. This exercise [@problem_id:3244190] extends the basic intersection problem by introducing the concept of color, asking you to count only the intersections that occur between segments of different colors. This practice illustrates how a core geometric primitive can be integrated with application-specific logic to answer more nuanced questions about a dataset.", "problem": "You are given a finite set of closed line segments in the Two-Dimensional (2D) Euclidean plane. Each segment is labeled with a color from a small set of color names. A closed line segment between two points is the set of all points obtained by convex combination of its endpoints. Formally, a segment with endpoints $(x_1,y_1)$ and $(x_2,y_2)$ is the set $\\{(x,y)\\mid (x,y)=\\lambda(x_1,y_1)+(1-\\lambda)(x_2,y_2),\\ \\lambda\\in[0,1]\\}$. Two closed segments are said to intersect if they share at least one point. Intersections at endpoints are considered intersections. Colinear overlapping segments are considered intersecting, and for such a pair, the intersection should be counted once. You must count only intersections between segments whose colors differ; intersections between segments of the same color are to be ignored.\n\nFundamental base and definitions to use:\n- The vector cross product in two dimensions of vectors $(a_1,a_2)$ and $(b_1,b_2)$ is the scalar $a_1b_2-a_2b_1$. Given three points $p=(p_x,p_y)$, $q=(q_x,q_y)$, and $r=(r_x,r_y)$, the signed area (twice the oriented area of triangle $pqr$) equals the cross product of $(q-p)$ and $(r-p)$, namely $(q_x-p_x)(r_y-p_y)-(q_y-p_y)(r_x-p_x)$. Its sign determines the orientation: positive for counterclockwise, negative for clockwise, and zero for colinear.\n- A point $r$ lies on the closed segment defined by $p$ and $q$ if and only if the three points are colinear and both $r_x$ and $r_y$ lie within the closed intervals formed by $p_x,q_x$ and $p_y,q_y$, respectively.\n\nStarting from these definitions, design an algorithm that, for each provided test case, counts the number of intersecting unordered pairs of segments where the two segments have different colors. The algorithm must be correct for all general positions and degeneracies, including:\n- Proper crossings where segments intersect at an interior point.\n- Endpoint touching where segments meet at a single endpoint.\n- Colinear overlaps where segments share infinitely many points, to be counted once per pair.\n- Degenerate segments of zero length (a point) that may lie on another segment or coincide with another degenerate segment.\n\nYour program must be a complete, runnable program that evaluates the following test suite. Each test case is a list of segments, and each segment is specified by its endpoints and a color label. Endpoints are given as integer coordinates; all mathematical entities are defined in the plane $\\mathbb{R}^2$.\n\nTest suite:\n- Test case $1$:\n  - Segments: red $((0,0),(5,5))$, blue $((0,5),(5,0))$, red $((6,0),(6,5))$, green $((3,3),(7,3))$.\n- Test case $2$:\n  - Segments: red $((0,0),(2,0))$, red $((2,0),(4,0))$, blue $((2,0),(2,2))$.\n- Test case $3$:\n  - Segments: green $((0,1),(4,1))$, blue $((1,1),(3,1))$, green $((0,0),(4,0))$.\n- Test case $4$:\n  - Segments: red $((1,1),(1,1))$, blue $((0,0),(2,2))$, blue $((1,1),(1,1))$.\n- Test case $5$:\n  - Segments: red $((0,0),(5,0))$, green $((2,-1),(2,1))$, blue $((3,-1),(3,1))$, red $((1,-1),(1,1))$, blue $((0,0),(5,0))$, green $((5,0),(6,0))$.\n\nDesign for coverage:\n- Test case $1$ exercises a general crossing, endpoint touching, and a non-intersecting pair.\n- Test case $2$ exercises endpoint touching and excludes same-color touching.\n- Test case $3$ exercises colinear overlap across different colors and parallel non-intersections.\n- Test case $4$ exercises degenerate point segments and their intersections.\n- Test case $5$ exercises multiple intersections, overlaps across colors, endpoint touching across different colors, and exclusion of same-color intersections.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets. For example, if the counts for the test cases were $a_1,a_2,a_3,a_4,a_5$, the output must be exactly in the format $[a_1,a_2,a_3,a_4,a_5]$ with no spaces.\n\nThere are no physical units involved in this problem. All angles, if any arise, should be treated as purely geometric without a unit, but your algorithm must not depend on angle measurements explicitly. The answer for each test case must be an integer. The program must be self-contained and require no input; it must compute and print the results for the given test suite upon execution.", "solution": "The problem requires us to count the number of intersections between pairs of line segments of different colors. The solution must be robust and handle all geometric configurations, including general crossings, endpoint-to-segment contact, and colinear overlaps. The determination of an intersection between two closed line segments, say $S_1$ defined by endpoints $p_1$ and $q_1$, and $S_2$ defined by endpoints $p_2$ and $q_2$, can be framed algorithmically using orientation tests.\n\nThe fundamental tool is the orientation function, $o(p, q, r)$, which determines the orientation of an ordered triplet of points $(p, q, r)$. As defined in the problem, this is based on the sign of the $2D$ cross product of the vectors $(q-p)$ and $(r-p)$. Let $p=(p_x, p_y)$, $q=(q_x, q_y)$, and $r=(r_x, r_y)$. The cross product is given by $(q_x-p_x)(r_y-p_y) - (q_y-p_y)(r_x-p_x)$. The sign of this value determines the orientation:\n-   $o(p, q, r) > 0$: The points form a counter-clockwise (or \"left\") turn. Point $r$ is to the left of the directed line from $p$ to $q$.\n-   $o(p, q, r) < 0$: The points form a clockwise (or \"right\") turn. Point $r$ is to the right of the directed line from $p$ to $q$.\n-   $o(p, q, r) = 0$: The points $p$, $q$, and $r$ are colinear.\n\nThe intersection logic is divided into two main categories: the general case and special cases involving colinearity.\n\n1.  **General Case: Proper Intersection**\n    Two segments $S_1=p_1q_1$ and $S_2=p_2q_2$ have a proper intersection (they cross at a single point interior to both) if and only if the endpoints of each segment lie on opposite sides of the line containing the other segment. This condition can be translated into orientation tests:\n    -   The endpoints $p_2$ and $q_2$ must lie on opposite sides of the line containing $p_1q_1$. This means the orientations $o(p_1, q_1, p_2)$ and $o(p_1, q_1, q_2)$ must be different and non-zero.\n    -   Simultaneously, the endpoints $p_1$ and $q_1$ must lie on opposite sides of the line containing $p_2q_2$. This means the orientations $o(p_2, q_2, p_1)$ and $o(p_2, q_2, q_1)$ must be different and non-zero.\n    If both these conditions hold, the segments intersect.\n\n2.  **Special Cases: Colinearities**\n    If any of the four orientation tests from the general case yields zero, it signifies that three points are colinear. This covers scenarios where segments touch at an endpoint, one segment lies on the other (colinear overlap), or a degenerate point-segment lies on another segment. An intersection occurs if a point that is colinear with another segment also lies *within the bounds* of that segment. For a point $r$ to lie on the closed segment defined by $p$ and $q$, it must be colinear with them and its coordinates $(r_x, r_y)$ must satisfy $r_x \\in [\\min(p_x, q_x), \\max(p_x, q_x)]$ and $r_y \\in [\\min(p_y, q_y), \\max(p_y, q_y)]$. This gives rise to four specific checks:\n    -   If $o(p_1, q_1, p_2) = 0$ and point $p_2$ lies on segment $p_1q_1$, they intersect.\n    -   If $o(p_1, q_1, q_2) = 0$ and point $q_2$ lies on segment $p_1q_1$, they intersect.\n    -   If $o(p_2, q_2, p_1) = 0$ and point $p_1$ lies on segment $p_2q_2$, they intersect.\n    -   If $o(p_2, q_2, q_1) = 0$ and point $q_1$ lies on segment $p_2q_2$, they intersect.\n\n    These conditions correctly handle all degenerate cases. For instance, if $S_1$ is a point-segment ($p_1=q_1$), the orientations $o(p_1, q_1, p_2)$ and $o(p_1, q_1, q_2)$ will be zero. The intersection test then correctly reduces to checking if point $p_1$ lies on segment $p_2q_2$ via the test $o(p_2, q_2, p_1)=0$ and the coordinate bounds check. Similarly, colinear overlapping segments will be detected because an endpoint of one segment will necessarily lie on the other.\n\nThe overall algorithm proceeds as follows:\nInitialize an intersection count to $0$. Iterate through all unique unordered pairs of segments $(S_i, S_j)$ from the input set. For each pair, first check if their colors are different. If they are, apply the comprehensive intersection test described above. If the test evaluates to true, increment the intersection count. After checking all pairs, the final count is the result for the given test case. This procedure is repeated for each test case in the suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import namedtuple\n\n# Use a namedtuple for points for clarity and immutability.\nPoint = namedtuple('Point', ['x', 'y'])\n\ndef orientation(p, q, r):\n    \"\"\"\n    Computes the orientation of the ordered triplet (p, q, r).\n    The function uses the cross-product method as specified in the problem statement.\n    \n    Returns:\n     0 --> p, q, and r are colinear.\n     1 --> Counter-clockwise turn (left turn).\n    -1 --> Clockwise turn (right turn).\n    \"\"\"\n    # Cross product of vectors (q-p) and (r-p).\n    val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x)\n    if val == 0:\n        return 0\n    return 1 if val > 0 else -1\n\ndef on_segment(p, q, r):\n    \"\"\"\n    Given three colinear points p, q, r, this function checks if point r lies on segment pq.\n    This check is valid only if orientation(p, q, r) is 0.\n    \"\"\"\n    return (r.x <= max(p.x, q.x) and r.x >= min(p.x, q.x) and\n            r.y <= max(p.y, q.y) and r.y >= min(p.y, q.y))\n\ndef intersects(s1_geom, s2_geom):\n    \"\"\"\n    Determines if two line segments intersect.\n    s1_geom and s2_geom are tuples of endpoint tuples, e.g., ((x1,y1), (x2,y2)).\n    \"\"\"\n    p1, q1 = Point(*s1_geom[0]), Point(*s1_geom[1])\n    p2, q2 = Point(*s2_geom[0]), Point(*s2_geom[1])\n\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case: a proper intersection.\n    # The endpoints of each segment are on opposite sides of the other.\n    if o1 * o2 == -1 and o3 * o4 == -1:\n        return True\n    \n    # Special Cases: one or more points are colinear with another segment.\n    # These checks handle endpoint touching, colinear overlap, and point-on-segment cases.\n    if o1 == 0 and on_segment(p1, q1, p2):\n        return True\n\n    if o2 == 0 and on_segment(p1, q1, q2):\n        return True\n\n    if o3 == 0 and on_segment(p2, q2, p1):\n        return True\n\n    if o4 == 0 and on_segment(p2, q2, q1):\n        return True\n\n    return False\n\ndef solve():\n    \"\"\"\n    Main function to run the algorithm on the provided test suite.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        [\n            (((0, 0), (5, 5)), 'red'), \n            (((0, 5), (5, 0)), 'blue'), \n            (((6, 0), (6, 5)), 'red'), \n            (((3, 3), (7, 3)), 'green')\n        ],\n        # Test case 2\n        [\n            (((0, 0), (2, 0)), 'red'), \n            (((2, 0), (4, 0)), 'red'), \n            (((2, 0), (2, 2)), 'blue')\n        ],\n        # Test case 3\n        [\n            (((0, 1), (4, 1)), 'green'), \n            (((1, 1), (3, 1)), 'blue'), \n            (((0, 0), (4, 0)), 'green')\n        ],\n        # Test case 4\n        [\n            (((1, 1), (1, 1)), 'red'), \n            (((0, 0), (2, 2)), 'blue'),\n            (((1, 1), (1, 1)), 'blue')\n        ],\n        # Test case 5\n        [\n            (((0, 0), (5, 0)), 'red'), \n            (((2, -1), (2, 1)), 'green'),\n            (((3, -1), (3, 1)), 'blue'),\n            (((1, -1), (1, 1)), 'red'),\n            (((0, 0), (5, 0)), 'blue'),\n            (((5, 0), (6, 0)), 'green')\n        ]\n    ]\n\n    results = []\n    for case in test_cases:\n        count = 0\n        num_segments = len(case)\n        for i in range(num_segments):\n            for j in range(i + 1, num_segments):\n                s1_geom, s1_color = case[i]\n                s2_geom, s2_color = case[j]\n                \n                # Count intersections only between segments of different colors.\n                if s1_color != s2_color:\n                    if intersects(s1_geom, s2_geom):\n                        count += 1\n        results.append(count)\n\n    # The final print statement must follow the exact format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244190"}]}