{"hands_on_practices": [{"introduction": "This first practice challenges you to build a complete AI that plays a variant of k-in-a-row on a toroidal board. By implementing the minimax algorithm with alpha-beta pruning, you will gain hands-on experience with the entire pipeline of an adversarial search agent: representing the game state, generating legal moves, and applying the recursive search logic. The unique wrap-around geometry of the board adds an interesting twist to implementing the game's rules and win-detection logic. [@problem_id:3204320]", "problem": "Design and implement a complete program that performs adversarial search using the minimax principle with Alpha-Beta Pruning (ABP) on a deterministic, perfect-information, two-player, zero-sum game played on a toroidal board. A toroidal board is a discrete grid in which indices wrap around at the edges. The game is a variant of placing marks, where players alternately place their marks, and a player wins by creating a line of length $k$ consisting entirely of their mark along any of the four fundamental directions: horizontal, vertical, southeast diagonal, or southwest diagonal. The edges of the board wrap, so stepping off one edge reappears on the opposite edge.\n\nFundamental base and core definitions:\n- A two-player zero-sum game has a utility function $u(s)$ for a state $s$ such that one player's gain is the other's loss. The maximizer seeks to maximize $u(s)$ and the minimizer seeks to minimize $u(s)$. Let the two players be denoted by $X$ (maximizer) and $O$ (minimizer).\n- Minimax defines the value of a state $s$ recursively as $V(s) = \\max_{a \\in A(s)} V(T(s,a))$ if it is $X$'s turn, and $V(s) = \\min_{a \\in A(s)} V(T(s,a))$ if it is $O$'s turn, where $A(s)$ is the set of legal actions in state $s$ and $T(s,a)$ is the deterministic transition function.\n- Alpha-Beta Pruning maintains bounds $\\alpha$ and $\\beta$ such that, for any node in the game tree, if the current best value for the maximizer is at least $\\beta$, or the current best value for the minimizer is at most $\\alpha$, then further exploration of siblings can be pruned without affecting the final minimax value.\n- The toroidal wrap-around is implemented by modular arithmetic on indices. For a board of size $n \\times n$, stepping from cell $(r,c)$ in direction $(\\Delta r, \\Delta c)$ leads to the next cell $(r', c')$ given by $r' = (r + \\Delta r) \\bmod n$ and $c' = (c + \\Delta c) \\bmod n$. The four directions are $(\\Delta r, \\Delta c) \\in \\{(0,1), (1,0), (1,1), (1,-1)\\}$.\n\nGame rules:\n- The board is an $n \\times n$ grid with $n \\in \\mathbb{Z}_{\\ge 2}$.\n- Each cell contains either $X$, $O$, or the empty symbol `.`.\n- Players alternate placing their mark in an empty cell.\n- A player wins when there exists a sequence of $k$ cells, each step taken along one of the four directions listed above, such that all $k$ cells contain the same player's mark. Indices wrap modulo $n$.\n- The terminal utility is defined as $u(s) = +1$ if $X$ has a winning line, $u(s) = -1$ if $O$ has a winning line, and $u(s) = 0$ if the board is full and there is no winning line. If both $X$ and $O$ simultaneously have winning lines (which cannot occur under legal play but may occur in arbitrary inputs), define $u(s) = 0$.\n- The program must implement minimax with ABP to compute the optimal utility and an optimal move from the current state for the current player.\n\nMathematical formulation of win detection:\n- For each starting cell $(r,c)$ and each direction $(\\Delta r, \\Delta c)$, check whether the cells $\\{(r + t \\Delta r \\bmod n, c + t \\Delta c \\bmod n) \\mid t \\in \\{0,1,\\dots,k-1\\}\\}$ all contain $X$ or all contain $O$.\n\nInput and output specification for this problem:\n- There is no user input. Hardcode the test suite described below directly in the program.\n- The program must compute, for each test case, the pair consisting of:\n  - The optimal minimax utility for the current player, denoted by an integer in $\\{-1,0,+1\\}$.\n  - One optimal move as a coordinate $(r,c)$ using zero-based indexing. If the position is already terminal or if there is no legal move, output the sentinel $(r,c) = (-1,-1)$.\n- The final output format is a single line containing a list of results for all test cases. Each individual result must be a list of three integers of the form $[u,r,c]$, and the entire output must be a single list in the format $[[u_1,r_1,c_1],[u_2,r_2,c_2],\\dots]$ with commas and no spaces.\n\nTest suite:\nEach test case is specified as a tuple $(n,k,\\text{board},P)$, where $n$ is the board size, $k$ is the win length, $\\text{board}$ is a list of $n$ strings of length $n$ using the alphabet $\\{X,O,.\\}$, and $P \\in \\{X,O\\}$ is the current player to move.\n\n- Test case $1$ (wrap-around southeast diagonal immediate win for $X$):\n  - $n = 3$, $k = 3$, $P = X$.\n  - $\\text{board} = [\".OO\", \".X.\", \"..X\"]$.\n  - The optimal move is expected to involve the wrap-around diagonal $(2,2) \\to (0,0) \\to (1,1)$.\n\n- Test case $2$ (immediate horizontal completion for $O$):\n  - $n = 3$, $k = 3$, $P = O$.\n  - $\\text{board} = [\"O.O\", \"X.X\", \"X..\"]$.\n  - The optimal move completes the top row.\n\n- Test case $3$ (already terminal with $X$ winning on a wrap-around diagonal):\n  - $n = 3$, $k = 3$, $P = O$.\n  - $\\text{board} = [\"XOO\", \"OXO\", \"..X\"]$.\n  - The southeast diagonal $(0,0) \\to (1,1) \\to (2,2)$ contains all $X$.\n\n- Test case $4$ (size $4$, $k=4$, immediate row completion for $O$):\n  - $n = 4$, $k = 4$, $P = O$.\n  - $\\text{board} = [\".OOO\", \"XX..\", \"....\", \"....\"]$.\n\n- Test case $5$ (size $4$, $k=3$, wrap-around southeast diagonal win for $X$ with a nontrivial pattern):\n  - $n = 4$, $k = 3$, $P = X$.\n  - $\\text{board} = [\"....\", \"X...\", \"....\", \"..X.\"]$.\n  - The winning move completes the wrap-around diagonal $(3,2) \\to (0,3) \\to (1,0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[[u1,r1,c1],[u2,r2,c2],...]\"), with no spaces anywhere in the output line. All indices $(r,c)$ must be zero-based integers, and the utilities must be integers in $\\{-1,0,+1\\}$.", "solution": "The problem requires the implementation of the minimax algorithm with Alpha-Beta Pruning (ABP) to find the optimal move in a two-player, zero-sum game on a toroidal grid. The solution is designed by formalizing the game's rules and states and then applying the principles of adversarial search.\n\nThe overall approach involves a recursive exploration of the game tree from the current state. The value of each state is determined by the minimax principle, which assumes both players play optimally. The maximizer, player $X$, aims to reach states with the highest possible utility, while the minimizer, player $O$, aims for states with the lowest utility. Alpha-Beta Pruning is used to optimize this search by eliminating branches of the game tree that cannot influence the final decision.\n\nThe implementation is structured into four primary components:\n1.  **State Evaluation**: A function to determine if a game state is terminal and to compute its utility.\n2.  **Move Generation**: A function to identify all legal moves from a given state.\n3.  **Recursive Search**: The core Alpha-Beta search function that recursively computes the minimax value of a state.\n4.  **Top-Level Driver**: A function that orchestrates the search for the initial state to identify the optimal move and its corresponding utility.\n\n**1. State Representation and Terminal Evaluation**\nA game state $s$ is defined by the $n \\times n$ board configuration and the player whose turn it is. The board is represented as a two-dimensional array where cells can be occupied by $X$, $O$, or be empty (`.`).\n\nA state is terminal if a player has formed a winning line or if the board is full. The utility function $u(s)$ is defined as:\n- $u(s) = +1$ if player $X$ has a winning line.\n- $u(s) = -1$ if player $O$ has a winning line.\n- $u(s) = 0$ if the board is full and there is no winner (a draw).\n- $u(s) = 0$ if both players have a winning line simultaneously.\n\nThe win detection logic is critical. A player wins by forming a line of $k$ of their marks. Due to the board's toroidal nature, lines can wrap around the edges. To check for a win, we must examine every cell $(r,c)$ on the board as a potential start of a winning line. For each starting cell, we check in each of the four fundamental directions $(\\Delta r, \\Delta c) \\in \\{(0,1), (1,0), (1,1), (1,-1)\\}$. A winning line exists for a given player if all $k$ cells in the sequence\n$$ \\{(r + t \\Delta r \\pmod n, c + t \\Delta c \\pmod n) \\mid t \\in \\{0, 1, \\dots, k-1\\}\\} $$\nare occupied by that player's mark. The modulo operator handles the toroidal wrap-around. The evaluation function first checks for a win for $X$, then for $O$, and finally checks if the board is full to determine the state's utility. If the state is not terminal, no utility is returned.\n\n**2. Move Generation**\nThe set of available actions $A(s)$ from a non-terminal state $s$ consists of all empty cells on the board. A simple iteration over the board grid identifies all coordinates $(r,c)$ where the cell's content is the empty symbol.\n\n**3. The Alpha-Beta Search Algorithm**\nThe core of the solution is a recursive function, `alpha_beta_search(state, player, alpha, beta)`, which computes the minimax value of a given state. The parameters $\\alpha$ and $\\beta$ represent the bounds on the possible utility values found so far in the search tree.\n- $\\alpha$: The best value (highest utility) found so far for the maximizer on the path to the root.\n- $\\beta$: The best value (lowest utility) found so far for the minimizer on the path to the root.\n\nThe function operates as follows:\nFirst, it evaluates the input state. If the state is terminal, it returns the corresponding utility ($+1, -1, 0$). If the board is full with no winner, it is a draw with utility $0$.\n\nIf the state is not terminal, the function proceeds based on the current player:\n- **If `player` is $X$ (Maximizer):** The goal is to maximize the outcome. The function initializes a value $v = -\\infty$. It then iterates through each legal move, applies it to create a new successor state, and recursively calls `alpha_beta_search` for the minimizer's turn (`player` = $O$). The value $v$ is updated with the maximum utility found among the children: $v = \\max(v, \\text{recursive\\_result})$. The maximizer's lower bound, $\\alpha$, is updated: $\\alpha = \\max(\\alpha, v)$. The search of this branch is terminated (pruned) if at any point $\\alpha \\ge \\beta$, as this means the minimizer has a better alternative move further up the tree.\n\n- **If `player` is $O$ (Minimizer):** The goal is to minimize the outcome. The function initializes a value $v = +\\infty$. It iterates through legal moves, creates successor states, and recursively calls `alpha_beta_search` for the maximizer's turn (`player` = $X$). The value $v$ is updated with the minimum utility: $v = \\min(v, \\text{recursive\\_result})$. The minimizer's upper bound, $\\beta$, is updated: $\\beta = \\min(\\beta, v)$. Pruning occurs if $\\beta \\le \\alpha$, as this means the maximizer has a better option elsewhere.\n\n**4. Top-Level Driver Routine**\nA main driver function initiates the process. It takes the initial game state $(n, k, \\text{board}, P)$ as input.\n1. It first checks if the initial state is already terminal or has no legal moves. If so, it returns the state's utility and a sentinel move of $(-1,-1)$.\n2. Otherwise, it iterates through all legal moves available to the current player $P$.\n3. For each potential move, it generates the resulting board state and calls the `alpha_beta_search` function to determine the utility of that move, assuming optimal play from the opponent. The initial call to the search function uses $\\alpha = -\\infty$ and $\\beta = +\\infty$.\n4. It tracks the move that leads to the best possible utility for the current player ($P$). For player $X$, this is the move with the maximum resulting utility; for player $O$, it is the move with the minimum resulting utility.\n5. The function returns the calculated optimal utility and the corresponding optimal move $(r,c)$.\nThis comprehensive, principle-based design ensures a correct and efficient determination of the optimal move according to the minimax theorem.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass ToroidalGame:\n    \"\"\"\n    Implements the logic for a toroidal k-in-a-row game and its solution\n    using minimax with alpha-beta pruning.\n    \"\"\"\n    def __init__(self, n, k, board_str, current_player):\n        self.n = int(n)\n        self.k = int(k)\n        self.board = np.array([list(row) for row in board_str])\n        self.current_player = current_player\n        self.directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n\n    def _check_win(self, board, player_mark):\n        \"\"\"Checks if a given player has a winning line on the board.\"\"\"\n        for r in range(self.n):\n            for c in range(self.n):\n                for dr, dc in self.directions:\n                    is_win = True\n                    for t in range(self.k):\n                        nr, nc = (r + t * dr) % self.n, (c + t * dc) % self.n\n                        if board[nr, nc] != player_mark:\n                            is_win = False\n                            break\n                    if is_win:\n                        return True\n        return False\n\n    def _evaluate_terminal(self, board):\n        \"\"\"\n        Evaluates a board state. Returns utility if terminal, else None.\n        Utility: +1 for X win, -1 for O win, 0 for draw or simultaneous win.\n        \"\"\"\n        win_X = self._check_win(board, 'X')\n        win_O = self._check_win(board, 'O')\n\n        if win_X and win_O:\n            return 0\n        if win_X:\n            return 1\n        if win_O:\n            return -1\n        if np.all(board != '.'):\n            return 0\n        return None  # Not terminal\n\n    def _get_legal_moves(self, board):\n        \"\"\"Returns a list of legal moves (empty cells).\"\"\"\n        return [(r, c) for r, c in zip(*np.where(board == '.'))]\n\n    def _alpha_beta_search(self, board, player, alpha, beta):\n        \"\"\"\n        Recursive core of the minimax algorithm with alpha-beta pruning.\n        \"\"\"\n        utility = self._evaluate_terminal(board)\n        if utility is not None:\n            return utility\n\n        moves = self._get_legal_moves(board)\n        if not moves:\n            return 0  # Draw if no moves and not a win state\n\n        if player == 'X':  # Maximizer\n            max_eval = -np.inf\n            for r, c in moves:\n                new_board = board.copy()\n                new_board[r, c] = 'X'\n                eval_child = self._alpha_beta_search(new_board, 'O', alpha, beta)\n                max_eval = max(max_eval, eval_child)\n                alpha = max(alpha, eval_child)\n                if beta = alpha:\n                    break\n            return max_eval\n        else:  # Minimizer (player == 'O')\n            min_eval = np.inf\n            for r, c in moves:\n                new_board = board.copy()\n                new_board[r, c] = 'O'\n                eval_child = self._alpha_beta_search(new_board, 'X', alpha, beta)\n                min_eval = min(min_eval, eval_child)\n                beta = min(beta, eval_child)\n                if beta = alpha:\n                    break\n            return min_eval\n\n    def find_best_move(self):\n        \"\"\"\n        Top-level driver to find the optimal move and utility for the current player.\n        \"\"\"\n        utility = self._evaluate_terminal(self.board)\n        if utility is not None:\n            return utility, -1, -1\n\n        moves = self._get_legal_moves(self.board)\n        if not moves:\n            return 0, -1, -1\n\n        best_move = (-1, -1)\n        if self.current_player == 'X':\n            best_val = -np.inf\n            for r, c in moves:\n                new_board = self.board.copy()\n                new_board[r, c] = 'X'\n                val = self._alpha_beta_search(new_board, 'O', -np.inf, np.inf)\n                if val > best_val:\n                    best_val = val\n                    best_move = (r, c)\n                # Optimization: if a winning move is found, no need to search further.\n                if best_val == 1:\n                    break\n        else:  # self.current_player == 'O'\n            best_val = np.inf\n            for r, c in moves:\n                new_board = self.board.copy()\n                new_board[r, c] = 'O'\n                val = self._alpha_beta_search(new_board, 'X', -np.inf, np.inf)\n                if val  best_val:\n                    best_val = val\n                    best_move = (r, c)\n                # Optimization: if a winning move is found, no need to search further.\n                if best_val == -1:\n                    break\n        \n        return int(best_val), int(best_move[0]), int(best_move[1])\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (3, 3, [\".OO\", \".X.\", \"..X\"], 'X'),\n        (3, 3, [\"O.O\", \"X.X\", \"X..\"], 'O'),\n        (3, 3, [\"XOO\", \"OXO\", \"..X\"], 'O'),\n        (4, 4, [\".OOO\", \"XX..\", \"....\", \"....\"], 'O'),\n        (4, 3, [\"....\", \"X...\", \"....\", \"..X.\"], 'X'),\n    ]\n\n    results = []\n    for n, k, board_str, player in test_cases:\n        game = ToroidalGame(n, k, board_str, player)\n        utility, r, c = game.find_best_move()\n        results.append([utility, r, c])\n\n    output_str = f\"[{','.join([f'[{u},{r},{c}]' for u, r, c in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3204320"}, {"introduction": "To make adversarial search efficient for large state spaces, we must avoid re-computing the value of positions we have already seen, a process managed with a transposition table. This exercise guides you through implementing Zobrist hashing, a method that generates a unique signature, or hash, for each game state. Mastering this technique provides the foundational component for building high-performance game engines that can remember and reuse past computations. [@problem_id:3204243]", "problem": "You are to design and implement a Zobrist hashing function for a two-player connection game played on a hexagonal grid whose state can be represented as an $n \\times n$ rhombus of cells, as in the game Hex. The goal is to compute a $64$-bit hash for a given board position. The solution must be grounded in core principles from data structures and algorithms that underlie adversarial search and basic game theory, namely the definition of a hash function, properties of bitwise operations, and the requirements for incremental and uniform hashing suitable for transposition tables.\n\nFundamental base:\n- A hash function is a mapping from a large domain (here, game states) to a fixed-size codomain (here, $64$-bit integers), aiming to spread inputs uniformly to reduce collisions.\n- The bitwise exclusive OR (XOR) operator, denoted by $\\oplus$, is associative and commutative, and each $x$ is its own inverse with respect to $\\oplus$ (that is, $x \\oplus x = 0$ and $x \\oplus 0 = x$). These properties enable incremental updates suitable for adversarial search.\n\nSpecification to implement:\n- Board representation: An $n \\times n$ rhombus with row indices $r \\in \\{0,\\dots,n-1\\}$ and column indices $c \\in \\{0,\\dots,n-1\\}$. Flatten a cell $(r,c)$ to a position index $p = r \\cdot n + c$, where $p \\in \\{0,\\dots,n^2 - 1\\}$.\n- Players and pieces: Two players, Black and White. Each occupied cell contains exactly one stone, either Black or White. Empty cells are not represented in the hash input.\n- Zobrist key table:\n  - For each position index $p \\in \\{0,\\dots,n^2-1\\}$ and each piece type $t \\in \\{\\text{Black}, \\text{White}\\}$, there is a $64$-bit key $K[p,t]$.\n  - There is also a single $64$-bit side-to-move key $K_{\\text{turn}}$ that is used if and only if it is Black to move.\n- Pseudorandom key generation:\n  - Keys must be generated by the SplitMix64 sequence seeded with a fixed unsigned $64$-bit integer $s$.\n  - SplitMix64 state update and output are defined over unsigned $64$-bit arithmetic as follows:\n    1. Update state: $x \\leftarrow x + \\text{0x9E3779B97F4A7C15}$.\n    2. Let $z \\leftarrow x$.\n    3. $z \\leftarrow \\left(z \\oplus (z \\gg 30)\\right) \\cdot \\text{0xBF58476D1CE4E5B9}$.\n    4. $z \\leftarrow \\left(z \\oplus (z \\gg 27)\\right) \\cdot \\text{0x94D049BB133111EB}$.\n    5. $z \\leftarrow z \\oplus (z \\gg 31)$.\n    6. The value $z$ is the next $64$-bit output.\n  - Initialize the state with $x \\leftarrow s$. Then generate keys in the following order: for $p$ from $0$ to $n^2-1$, first $K[p,\\text{Black}]$, then $K[p,\\text{White}]$, and finally $K_{\\text{turn}}$.\n- Hash computation for a given position:\n  - Given a list of occupied cells $S = \\{(r_i,c_i,t_i)\\}$ with $t_i \\in \\{\\text{Black}, \\text{White}\\}$ and side to move $\\text{side} \\in \\{\\text{Black}, \\text{White}\\}$, the Zobrist hash $H$ is computed as\n    $$ H \\;=\\; \\left( \\bigoplus_{(r_i,c_i,t_i) \\in S} K[r_i \\cdot n + c_i, t_i] \\right) \\;\\oplus\\; \\begin{cases}\n    K_{\\text{turn}},  \\text{if side is Black} \\\\\n    0,  \\text{if side is White}\n    \\end{cases}. $$\n  - The output must be interpreted as an unsigned $64$-bit integer in decimal notation.\n\nInput for your program is fixed by this problem statement and must be embedded in your code. No external input is allowed.\n\nUse the following fixed seed for key generation: $s = 1$.\n\nTest suite:\n- Case $1$: $n = 3$, stones $S = [\\,]$, side to move $=$ Black.\n- Case $2$: $n = 3$, stones $S = [\\,($1$, $1$, Black)$\\,]$, side to move $=$ White.\n- Case $3$: $n = 3$, stones $S = [\\,($1$, $1$, Black)$\\,]$, side to move $=$ Black.\n- Case $4$: $n = 3$, stones $S = [\\,($0$, $0$, Black), ($0$, $2$, White), ($2$, $0$, White), ($2$, $2$, Black)$\\,]$, side to move $=$ White.\n- Case $5$: $n = 5$, stones $S = [\\,($0$, $4$, Black), ($4$, $0$, White), ($2$, $2$, Black), ($1$, $3$, White)$\\,]$, side to move $=$ Black.\n- Case $6$: $n = 5$, stones $S = [\\,($0$, $4$, Black), ($4$, $0$, White), ($2$, $2$, Black), ($1$, $3$, White)$\\,]$, side to move $=$ Black. This duplicates Case $5$ to verify identical positions produce identical hashes.\n\nYour program must compute the hash for each test case exactly as specified above and produce a single line of output containing the hashes as a comma-separated list enclosed in square brackets. For example, the output format must be exactly of the form\n- $[h_1,h_2,h_3,h_4,h_5,h_6]$\nwhere each $h_i$ is the unsigned decimal representation of the corresponding $64$-bit hash. No units are involved in this problem. Angles and percentages do not apply.", "solution": "The problem requires the implementation of Zobrist hashing, a technique to generate a unique, fixed-size signature (hash) for each state in a game, which is essential for implementing efficient transposition tables in adversarial search. The solution is built upon three core components: a pseudorandom number generator (PRNG) to create a table of keys, a key generation process to populate this table, and a hash computation function that combines these keys based on the board state.\n\n**1. Pseudorandom Key Generation**\nThe foundation of Zobrist hashing is a table of high-quality, unique random numbers. The problem specifies the **SplitMix64** algorithm for this purpose. This generator maintains a single 64-bit unsigned integer state. To generate each new random number, the state is first incremented by a large constant (`0x9E3779B97F4A7C15`). The new state is then passed through a series of bitwise shift, XOR, and multiplication operations. These \"avalanche\" operations ensure that small changes in the state lead to large, unpredictable changes in the output, a crucial property for good hash functions. This process is deterministic, meaning the same seed will always produce the same sequence of random numbers.\n\n**2. Zobrist Key Table Population**\nBefore any hashing can occur, we must generate and store a unique random number for every possible feature of a game state. According to the specification:\n- For a board of size $n \\times n$, there are $n^2$ positions. For each position, we need a unique key for each of the two piece types (Black and White). This requires $2 \\times n^2$ keys.\n- An additional key is needed to represent whose turn it is to move (the `side-to-move` key). This key is XORed into the hash only when it is Black's turn.\n\nThe key generation process initializes the SplitMix64 PRNG with a fixed seed ($s=1$) and then calls it repeatedly to fill the key table in a precise order: iterate through each position index $p$ from $0$ to $n^2 - 1$, generating the key for a Black piece at $p$, then a White piece at $p$. Finally, the side-to-move key is generated. A separate key table must be generated for each unique board size $n$ in the test suite (i.e., one for $n=3$ and one for $n=5$), each starting from a fresh PRNG initialized with the same seed.\n\n**3. Hash Computation**\nThe Zobrist hash of a given board state is the XOR sum of the keys corresponding to every feature present in that state. The process is as follows:\n1. Initialize a 64-bit hash variable to $0$.\n2. For each piece $(r_i, c_i, t_i)$ on the board:\n   - Convert the 2D coordinate $(r_i, c_i)$ to a 1D position index $p_i = r_i \\cdot n + c_i$.\n   - Look up the corresponding random key for piece type $t_i$ at position $p_i$ from the pre-computed table.\n   - XOR this key into the current hash value: $H \\leftarrow H \\oplus K[p_i, t_i]$.\n3. After accounting for all pieces, check the side to move. If it is Black's turn, XOR the special `side-to-move` key into the hash: $H \\leftarrow H \\oplus K_{\\text{turn}}$. If it is White's turn, nothing is done.\n\nThis procedure, due to the properties of XOR ($a \\oplus b \\oplus b = a$), allows for efficient incremental updates. If a piece is moved, the hash can be updated by XORing out the key for the old position and XORing in the key for the new position, which is much faster than recomputing from scratch. The final 64-bit unsigned integer value of $H$ is the Zobrist hash for the state.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Zobrist hashes for a series of board states according to the problem specification.\n    \"\"\"\n    \n    # Define constants for players and sides to improve readability\n    BLACK = 0\n    WHITE = 1\n\n    class SplitMix64:\n        \"\"\"\n        Implements the SplitMix64 pseudorandom number generator for 64-bit unsigned integers.\n        NumPy with dtype=np.uint64 is used to correctly handle 64-bit unsigned arithmetic.\n        \"\"\"\n        def __init__(self, seed: int):\n            self.state = np.uint64(seed)\n\n        def next(self) -> np.uint64:\n            \"\"\"Generates the next 64-bit unsigned integer in the sequence.\"\"\"\n            # All arithmetic is performed on np.uint64, which handles wrap-around correctly.\n            self.state += np.uint64(0x9E3779B97F4A7C15)\n            z = self.state\n            z = (z ^ (z >> np.uint64(30))) * np.uint64(0xBF58476D1CE4E5B9)\n            z = (z ^ (z >> np.uint64(27))) * np.uint64(0x94D049BB133111EB)\n            z = z ^ (z >> np.uint64(31))\n            return z\n\n    class ZobristHasher:\n        \"\"\"\n        Manages Zobrist keys and computes hashes for game states.\n        \"\"\"\n        def __init__(self, n: int, seed: int):\n            self.n = n\n            num_positions = n * n\n            # Table for piece-position keys: K[p, t]\n            self.piece_keys = np.zeros((num_positions, 2), dtype=np.uint64)\n            # Single key for side to move\n            self.turn_key = np.uint64(0)\n            self._generate_keys(seed)\n\n        def _generate_keys(self, seed: int):\n            \"\"\"\n            Generates and populates the Zobrist key table using SplitMix64.\n            \"\"\"\n            prng = SplitMix64(seed)\n            num_positions = self.n * self.n\n            for p in range(num_positions):\n                # As per spec: first K[p, Black], then K[p, White]\n                self.piece_keys[p, BLACK] = prng.next()\n                self.piece_keys[p, WHITE] = prng.next()\n            # Finally, the turn key\n            self.turn_key = prng.next()\n\n        def compute_hash(self, stones: list[tuple[int, int, int]], side_to_move: int) -> np.uint64:\n            \"\"\"\n            Computes the Zobrist hash for a given board state.\n            \"\"\"\n            hash_val = np.uint64(0)\n            \n            # XOR keys for each piece on the board\n            for r, c, piece_type in stones:\n                pos_index = r * self.n + c\n                hash_val ^= self.piece_keys[pos_index, piece_type]\n            \n            # XOR turn key if it is Black's move\n            if side_to_move == BLACK:\n                hash_val ^= self.turn_key\n                \n            return hash_val\n\n    # Define the test cases from the problem statement.\n    # Player and side are represented by the integer constants BLACK and WHITE.\n    test_cases = [\n        {'n': 3, 'stones': [], 'side': BLACK},\n        {'n': 3, 'stones': [(1, 1, BLACK)], 'side': WHITE},\n        {'n': 3, 'stones': [(1, 1, BLACK)], 'side': BLACK},\n        {'n': 3, 'stones': [(0, 0, BLACK), (0, 2, WHITE), (2, 0, WHITE), (2, 2, BLACK)], 'side': WHITE},\n        {'n': 5, 'stones': [(0, 4, BLACK), (4, 0, WHITE), (2, 2, BLACK), (1, 3, WHITE)], 'side': BLACK},\n        {'n': 5, 'stones': [(0, 4, BLACK), (4, 0, WHITE), (2, 2, BLACK), (1, 3, WHITE)], 'side': BLACK},\n    ]\n\n    results = []\n    # Cache ZobristHasher instances to avoid re-generating keys for the same board size 'n'.\n    # A new hasher (and thus a new set of keys from a fresh PRNG) is created for each unique 'n'.\n    hashers = {}\n    seed = 1\n\n    for case in test_cases:\n        n = case['n']\n        \n        if n not in hashers:\n            hashers[n] = ZobristHasher(n=n, seed=seed)\n        \n        hasher = hashers[n]\n        h = hasher.compute_hash(case['stones'], case['side'])\n        results.append(str(h))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3204243"}, {"introduction": "With a robust hashing scheme in place, we can now build the data structure that stores our search results: the transposition table. This practice focuses on the critical logic for managing table entries, including a depth-aware replacement strategy and the correct interpretation of stored scores as exact values or bounds relative to the search window $[\\alpha, \\beta]$. Mastering this component is key to transforming a basic search algorithm into a powerful and efficient one by maximizing the benefits of memoization. [@problem_id:3204274]", "problem": "You are to implement a Transposition Table (TT) for adversarial game-tree search that respects probed depths and bound semantics. The TT must support insertion and probing governed by a depth-aware replacement policy used in alpha-beta pruning. You will design and implement the data structure, then run it against a fixed test suite. The final output must be a single line containing a list of results as specified below.\n\nFundamental base: The problem builds on the following core definitions in adversarial search and game theory basics:\n- Minimax search computes the value of a game state by recursively applying optimal play assumptions at alternating levels of the game tree, using evaluation values for leaves. Alpha-beta pruning maintains an interval $\\left[\\alpha,\\beta\\right]$ of provable bounds on the true minimax value of a position, where $\\alpha$ is a lower bound guaranteed to be achievable by the maximizing player and $\\beta$ is an upper bound guaranteed to be enforceable by the minimizing player.\n- A Transposition Table (TT) is a memoization map keyed by a representation of the game state, often a $64$-bit integer Zobrist hash. Each stored entry includes a searched depth $d$ (the number of plies remaining at the node during the search), a score $v$, and a flag indicating whether $v$ is an exact minimax value or a bound relative to the $\\left[\\alpha,\\beta\\right]$ window in which it was obtained.\n\nYou must adhere to the following rules:\n1. Replacement policy: On storing an entry for a key, only replace an existing entry if the new search depth $d_{\\text{new}}$ is strictly greater than the stored depth $d_{\\text{old}}$. That is, replacement occurs if and only if $d_{\\text{new}} > d_{\\text{old}}$. If $d_{\\text{new}} \\le d_{\\text{old}}$, do not modify the existing entry.\n2. Bound semantics: Each entry stores a flag in $\\{ \\text{EXACT}, \\text{LOWER}, \\text{UPPER} \\}$, encoded as integers $\\text{EXACT} = 0$, $\\text{LOWER} = 1$, $\\text{UPPER} = 2$. Let the stored triple be $(d_s, v_s, f_s)$ and let a probe request provide $(d_r, \\alpha, \\beta)$. A stored entry is usable for pruning or returning a value only if $d_s \\ge d_r$ and one of the following holds:\n   - If $f_s = \\text{EXACT}$, then the value $v_s$ is usable as the exact minimax value at the probed depth $d_r$.\n   - If $f_s = \\text{LOWER}$, then $v_s$ is a lower bound, which is usable for a cutoff if $v_s \\ge \\beta$.\n   - If $f_s = \\text{UPPER}$, then $v_s$ is an upper bound, which is usable for a cutoff if $v_s \\le \\alpha$.\n   If none of these conditions hold, the entry is not usable for the probe request.\n3. Probed depth: The stored depth $d_s$ and the requested depth $d_r$ are nonnegative integers counting the number of plies remaining from the node during search. Only reuse a stored entry when $d_s \\ge d_r$.\n\nInterface to implement in your program:\n- Store operation: $\\text{store}(k, d, v, f)$ inserts $(d,v,f)$ at key $k$. If a prior entry exists at $k$, replace it if and only if $d$ is strictly greater than the prior stored depth; otherwise leave the entry unchanged. The function should return a boolean indicating whether an existing entry was replaced by this call (true if replaced, false otherwise).\n- Probe operation: $\\text{probe}(k, d_r, \\alpha, \\beta)$ returns a pair $(u, w)$ where $u$ is a boolean indicating whether the stored entry at $k$ is usable under the rules above for the request $(d_r,\\alpha,\\beta)$, and $w$ is the integer value returned if usable and $0$ otherwise.\n\nTest suite: Your program must execute exactly the following six test cases in order. Each test case consists of two store operations followed by one probe. Keys are arbitrary small integers used as unique identifiers of positions in this test.\n\n- Test case $1$:\n  - $\\text{store}(k=1, d=3, v=10, f=\\text{LOWER})$\n  - $\\text{store}(k=1, d=2, v=9, f=\\text{EXACT})$; record whether this second store replaced the prior entry.\n  - $\\text{probe}(k=1, d_r=2, \\alpha=-1, \\beta=9)$\n- Test case $2$:\n  - $\\text{store}(k=2, d=1, v=5, f=\\text{UPPER})$\n  - $\\text{store}(k=2, d=4, v=7, f=\\text{LOWER})$; record whether this second store replaced the prior entry.\n  - $\\text{probe}(k=2, d_r=3, \\alpha=6, \\beta=8)$\n- Test case $3$:\n  - $\\text{store}(k=3, d=2, v=13, f=\\text{EXACT})$\n  - $\\text{store}(k=3, d=2, v=20, f=\\text{LOWER})$; record whether this second store replaced the prior entry.\n  - $\\text{probe}(k=3, d_r=2, \\alpha=-100, \\beta=100)$\n- Test case $4$:\n  - $\\text{store}(k=4, d=2, v=5, f=\\text{UPPER})$\n  - $\\text{store}(k=4, d=1, v=100, f=\\text{LOWER})$; record whether this second store replaced the prior entry.\n  - $\\text{probe}(k=4, d_r=3, \\alpha=7, \\beta=200)$\n- Test case $5$:\n  - $\\text{store}(k=5, d=3, v=4, f=\\text{EXACT})$\n  - $\\text{store}(k=5, d=3, v=10, f=\\text{LOWER})$; record whether this second store replaced the prior entry.\n  - $\\text{probe}(k=5, d_r=3, \\alpha=-100, \\beta=100)$\n- Test case $6$:\n  - $\\text{store}(k=6, d=5, v=12, f=\\text{UPPER})$\n  - $\\text{store}(k=6, d=3, v=20, f=\\text{EXACT})$; record whether this second store replaced the prior entry.\n  - $\\text{probe}(k=6, d_r=4, \\alpha=12, \\beta=100)\n\nRequired final output format: Your program must produce a single line of output containing a list of six results, one per test case, with no spaces. Each result is the list $[r,u,w]$ where:\n- $r$ is $1$ if the second store replaced an existing entry and $0$ otherwise,\n- $u$ is $1$ if the probe was usable and $0$ otherwise,\n- $w$ is the integer value returned if usable, or $0$ otherwise.\nThus the overall output must be of the form\n$[[r_1,u_1,w_1],[r_2,u_2,w_2],[r_3,u_3,w_3],[r_4,u_4,w_4],[r_5,u_5,w_5],[r_6,u_6,w_6]]$.\n\nYour program must be self-contained, must not read any input, and must follow the replacement and probing semantics exactly as specified.", "solution": "The problem statement is valid. It presents a well-defined and scientifically sound task within the domain of adversarial search algorithms, specifically the implementation of a Transposition Table (TT). The rules for storage, replacement, and probing are unambiguous and consistent with established practices in game-playing AI. We shall proceed to formulate a solution.\n\nThe solution requires designing a data structure and two associated functions, $\\text{store}$ and $\\text{probe}$, that adhere to a specific set of rules. The final program will execute a series of test cases using this implementation.\n\n**Data Structure**\nThe Transposition Table is a form of memoization cache. A Python dictionary provides a natural and efficient implementation, mapping a game state key to its computed data. Each key $k$, an integer in this problem, will map to a tuple containing the search information for that state: $(d, v, f)$.\n- $d$: An integer representing the depth (number of plies remaining) of the search that produced this entry.\n- $v$: An integer representing the score derived from that search.\n- $f$: An integer flag that specifies the nature of the score, drawn from $\\{\\text{EXACT}, \\text{LOWER}, \\text{UPPER}\\}$, which are encoded as $\\{0, 1, 2\\}$, respectively.\n\n**Store Operation: $\\text{store}(k, d, v, f)$**\nThis function handles the insertion and replacement of entries in the TT. The governing principle is a depth-first replacement policy. Given a key $k$, a new depth $d$, value $v$, and flag $f$:\n1. If no entry exists for key $k$, a new one $(d, v, f)$ is created. The function signals that no replacement occurred, returning `false`.\n2. If an entry $(d_{\\text{old}}, v_{\\text{old}}, f_{\\text{old}})$ already exists for key $k$, its depth $d_{\\text{old}}$ is compared to the new depth $d$.\n3. The replacement rule is strict: the new entry replaces the old one if and only if $d > d_{\\text{old}}$.\n   - If $d > d_{\\text{old}}$, the entry for $k$ is updated to $(d, v, f)$, and the function returns `true`.\n   - If $d \\le d_{\\text{old}}$, the existing entry is preserved, and the function returns `false`.\n\n**Probe Operation: $\\text{probe}(k, d_r, \\alpha, \\beta)$**\nThis function queries the TT for stored information about state $k$ that is applicable to a search at a requested depth $d_r$ within an alpha-beta search window $[\\alpha, \\beta]$. The function returns a pair $(u, w)$, where $u$ indicates usability and $w$ is the corresponding value.\n1. If no entry for key $k$ is found in the table, the probe fails. The result is `(false, 0)`.\n2. If an entry $(d_s, v_s, f_s)$ exists, its stored depth $d_s$ must be sufficient for the current request. The usability condition requires $d_s \\ge d_r$. If this condition is not met ($d_s  d_r$), the stored information is from a shallower search and is not applicable. The probe fails, returning `(false, 0)`.\n3. If the depth condition $d_s \\ge d_r$ is met, the usability is determined by the flag $f_s$:\n   - If $f_s = \\text{EXACT}$ (value $0$): The score $v_s$ is the exact minimax value. It is always usable. The result is `(true, v_s)`.\n   - If $f_s = \\text{LOWER}$ (value $1$): The score $v_s$ is a lower bound. It is considered usable if it can produce a $\\beta$-cutoff, which occurs when $v_s \\ge \\beta$. If this holds, the result is `(true, v_s)`. Otherwise, the entry is not considered usable for this probe.\n   - If $f_s = \\text{UPPER}$ (value $2$): The score $v_s$ is an upper bound. It is considered usable if it can produce an $\\alpha$-cutoff, meaning $v_s \\le \\alpha$. If this holds, the result is `(true, v_s)`. Otherwise, it is not usable.\n4. If the depth check passes but none of the flag-specific conditions for usability are met, the probe fails, returning `(false, 0)`.\n\n**Test Suite Analysis**\nApplying this logic to the provided test cases yields the following step-by-step results. Each test case starts with a new, empty TT. The result for each case is $[r, u, w]$, where $r=1$ if the second store was a replacement, $u=1$ if the probe was usable, and $w$ is the returned value.\n\n- **Test Case 1**: `store(k=1,d=3,v=10,f=1)`; `store(k=1,d=2,v=9,f=0)` (no replacement, $2 \\le 3$, $r=0$); `probe(k=1,d_r=2,a=-1,b=9)`. Entry is $(3,10,1)$. $d_s=3 \\ge d_r=2$. Flag is $\\text{LOWER}$, $v_s=10 \\ge \\beta=9$. Usable. Result: `(u=1, w=10)`. Final: $[0,1,10]$.\n- **Test Case 2**: `store(k=2,d=1,v=5,f=2)`; `store(k=2,d=4,v=7,f=1)` (replace, $4 > 1$, $r=1$); `probe(k=2,d_r=3,a=6,b=8)`. Entry is $(4,7,1)$. $d_s=4 \\ge d_r=3$. Flag is $\\text{LOWER}$, $v_s=7 \\ge \\beta=8$ is false. Not usable. Result: `(u=0, w=0)`. Final: $[1,0,0]$.\n- **Test Case 3**: `store(k=3,d=2,v=13,f=0)`; `store(k=3,d=2,v=20,f=1)` (no replacement, $2 \\le 2$, $r=0$); `probe(k=3,d_r=2,a=-100,b=100)`. Entry is $(2,13,0)$. $d_s=2 \\ge d_r=2$. Flag is $\\text{EXACT}$. Usable. Result: `(u=1, w=13)`. Final: $[0,1,13]$.\n- **Test Case 4**: `store(k=4,d=2,v=5,f=2)`; `store(k=4,d=1,v=100,f=1)` (no replacement, $1 \\le 2$, $r=0$); `probe(k=4,d_r=3,a=7,b=200)`. Entry is $(2,5,2)$. $d_s=2 \\ge d_r=3$ is false. Not usable. Result: `(u=0, w=0)`. Final: $[0,0,0]$.\n- **Test Case 5**: `store(k=5,d=3,v=4,f=0)`; `store(k=5,d=3,v=10,f=1)` (no replacement, $3 \\le 3$, $r=0$); `probe(k=5,d_r=3,a=-100,b=100)`. Entry is $(3,4,0)$. $d_s=3 \\ge d_r=3$. Flag is $\\text{EXACT}$. Usable. Result: `(u=1, w=4)`. Final: $[0,1,4]$.\n- **Test Case 6**: `store(k=6,d=5,v=12,f=2)`; `store(k=6,d=3,v=20,f=0)` (no replacement, $3 \\le 5$, $r=0$); `probe(k=6,d_r=4,a=12,b=100)`. Entry is $(5,12,2)$. $d_s=5 \\ge d_r=4$. Flag is $\\text{UPPER}$, $v_s=12 \\le \\alpha=12$. Usable. Result: `(u=1, w=12)`. Final: $[0,1,12]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass TranspositionTable:\n    \"\"\"\n    Implements a Transposition Table for adversarial search with a depth-aware\n    replacement policy and specific bound semantics for alpha-beta pruning.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initializes an empty transposition table.\"\"\"\n        self.table = {}\n        # Define flags as specified in the problem statement.\n        self.EXACT = 0\n        self.LOWER = 1\n        self.UPPER = 2\n\n    def store(self, k, d, v, f):\n        \"\"\"\n        Stores an entry (d, v, f) for key k.\n        Replaces an existing entry only if the new depth d is strictly greater\n        than the old depth.\n        \n        Args:\n            k (int): The key representing the game state.\n            d (int): The search depth for this entry.\n            v (int): The score of the entry.\n            f (int): The flag (EXACT, LOWER, or UPPER).\n            \n        Returns:\n            bool: True if an existing entry was replaced, False otherwise.\n        \"\"\"\n        if k not in self.table:\n            self.table[k] = (d, v, f)\n            return False  # No replacement occurred.\n        else:\n            d_old, _, _ = self.table[k]\n            if d > d_old:\n                self.table[k] = (d, v, f)\n                return True  # Replacement occurred.\n            else:\n                return False  # Did not replace due to depth policy.\n\n    def probe(self, k, d_r, alpha, beta):\n        \"\"\"\n        Probes the table for a usable entry for key k.\n        \n        An entry is usable if its stored depth is sufficient (>= d_r) and\n        it satisfies the bound semantics (EXACT, or a bound that causes a cutoff).\n        \n        Args:\n            k (int): The key to probe.\n            d_r (int): The requested search depth.\n            alpha (int): The current alpha value of the search window.\n            beta (int): The current beta value of the search window.\n            \n        Returns:\n            tuple[bool, int]: A pair (usable, value). `usable` is True if a\n            valid entry was found, False otherwise. `value` is the stored score\n            if usable, and 0 otherwise.\n        \"\"\"\n        if k not in self.table:\n            return (False, 0)\n        \n        d_s, v_s, f_s = self.table[k]\n\n        # Rule 3: Stored depth must be greater than or equal to requested depth.\n        if d_s  d_r:\n            return (False, 0)\n\n        # Rule 2: Check bound semantics for usability.\n        if f_s == self.EXACT:\n            return (True, v_s)\n        elif f_s == self.LOWER:\n            # Usable if it causes a beta-cutoff.\n            if v_s >= beta:\n                return (True, v_s)\n        elif f_s == self.UPPER:\n            # Usable if it causes an alpha-cutoff.\n            if v_s = alpha:\n                return (True, v_s)\n\n        # Entry exists and depth is sufficient, but it's not usable for this\n        # alpha-beta window according to the problem's strict rules.\n        return (False, 0)\n\ndef solve():\n    \"\"\"\n    Executes the six test cases defined in the problem statement and prints\n    the results in the specified format.\n    \"\"\"\n    # Test cases defined as tuples of:\n    # (k, d1, v1, f1, d2, v2, f2, dr, alpha, beta)\n    test_cases = [\n        (1, 3, 10, 1, 2, 9, 0, 2, -1, 9),      # Test Case 1\n        (2, 1, 5, 2, 4, 7, 1, 3, 6, 8),      # Test Case 2\n        (3, 2, 13, 0, 2, 20, 1, 2, -100, 100),# Test Case 3\n        (4, 2, 5, 2, 1, 100, 1, 3, 7, 200),  # Test Case 4\n        (5, 3, 4, 0, 3, 10, 1, 3, -100, 100),# Test Case 5\n        (6, 5, 12, 2, 3, 20, 0, 4, 12, 100) # Test Case 6\n    ]\n\n    all_results = []\n    # Flag values as constants, matching the class attributes.\n    EXACT, LOWER, UPPER = 0, 1, 2\n\n    for case in test_cases:\n        k, d1, v1, f1, d2, v2, f2, dr, alpha, beta = case\n        \n        # A new TT is created for each test case to ensure isolation.\n        tt = TranspositionTable()\n        \n        # First store operation.\n        tt.store(k, d1, v1, f1)\n        \n        # Second store operation. a boolean is returned.\n        replaced = tt.store(k, d2, v2, f2)\n        r = 1 if replaced else 0\n        \n        # Probe operation.\n        usable, w = tt.probe(k, dr, alpha, beta)\n        u = 1 if usable else 0\n        # w is already 0 if not usable, as per probe's return contract.\n        \n        all_results.append([r, u, w])\n\n    # Manually construct the output string to match the required format\n    # exactly, with no spaces.\n    result_str_parts = [f\"[{r},{u},{w}]\" for r, u, w in all_results]\n    final_output = f\"[{','.join(result_str_parts)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3204274"}]}