{"hands_on_practices": [{"introduction": "The best way to grasp a divide-and-conquer algorithm is to build it from the ground up. This first exercise guides you through a direct implementation of Karatsuba's method, focusing on its core recursive structure. By translating the famous algebraic identity into code, you will solidify your understanding of how the algorithm cleverly reduces four multiplications to three [@problem_id:3213594].", "problem": "You are asked to design and implement a recursive integer multiplication procedure that explicitly demonstrates both the base cases and the recursive step of a divide-and-conquer algorithm. The method must operate on nonnegative integers represented in an arbitrary positional base and must reduce the number of recursive multiplications below the naive approach by using algebraic recombination.\n\nFundamental base. Use only these foundational facts as the starting point:\n- Any nonnegative integer $n$ can be represented in base $B$ (with $B \\in \\mathbb{Z}, B \\ge 2$) as $$n = \\sum_{i=0}^{k-1} d_i B^i$$ where each digit $d_i$ is an integer with $0 \\le d_i \\le B-1$.\n- For two integers $x$ and $y$ and any base $B$, if $m \\in \\mathbb{Z}$ with $m \\ge 1$, then the numbers can be split as $x = x_1 B^m + x_0$ and $y = y_1 B^m + y_0$ with $0 \\le x_0  B^m$ and $0 \\le y_0  B^m$.\n- Algebraic identities on integers hold under the usual ring operations.\n\nDefine the recursive algorithm `Multiply(x,y,B,t)` with the following requirements:\n1. Inputs: integers $x \\ge 0$, $y \\ge 0$, base $B \\ge 2$, and a cutoff threshold $t \\ge 1$ representing a number of base-$B$ digits.\n2. Base case: if $\\min(\\text{digits}_B(x), \\text{digits}_B(y)) \\le t$ or if $x = 0$ or $y = 0$, return the exact product $xy$ using a direct method. Here, $\\text{digits}_B(n)$ denotes the number of base-$B$ digits of $n$ (by definition, $\\text{digits}_B(0) = 1$).\n3. Recursive step: otherwise, choose $m = \\lceil \\max(\\text{digits}_B(x), \\text{digits}_B(y)) / 2 \\rceil$, split $x = x_1 B^m + x_0$ and $y = y_1 B^m + y_0$ with $0 \\le x_0, y_0  B^m$, and compute the result using exactly three recursive multiplications on combinations of $(x_0,x_1)$ and $(y_0,y_1)$ together with a constant number of additions, subtractions, and multiplications by powers of $B$. The recombination must produce the exact product $xy$.\n\nYour task:\n- Implement `Multiply(x,y,B,t)` recursively, obeying the base-case and recursive-step constraints above.\n- Use this routine to compute the products for the following test suite of parameter values:\n  - Case A: $x = 123456789012345$, $y = 987654321098765$, $B = 10$, $t = 3$.\n  - Case B: $x = 99$, $y = 99$, $B = 10$, $t = 2$.\n  - Case C: $x = 0$, $y = 987654321$, $B = 10$, $t = 3$.\n  - Case D: $x = 123456$, $y = 789012$, $B = 2$, $t = 16$.\n  - Case E: $x = 10^{20} + 12345$, $y = 10^{10} + 678$, $B = 10$, $t = 3$.\n- The answers are unitless exact integers. No physical units are involved.\n\nFinal output format:\n- Your program must produce a single line of output containing the results for Cases A through E, in order, as a comma-separated list enclosed in square brackets. For example, the format must be [$r_A,r_B,r_C,r_D,r_E$], where each $r_\\cdot$ is the integer product for the corresponding case, written in base $10$ without any additional whitespace or text.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to derive a unique, verifiable solution. The problem describes the Karatsuba algorithm for fast multiplication, a standard topic in computer science algorithms.\n\nThe task is to design and implement a recursive integer multiplication algorithm, designated as $\\text{Multiply}(x, y, B, t)$, which reduces the number of recursive calls compared to a naive approach. This is a classic application of the divide-and-conquer paradigm. The core principle lies in an algebraic manipulation that allows the product of two large integers to be computed using three multiplications of smaller integers, rather than the four required by direct expansion.\n\nLet the two non-negative integers to be multiplied be $x$ and $y$. Their product is $x \\cdot y$.\nThe integers are represented in a positional base $B \\ge 2$. Following the problem, we can split them into higher-order and lower-order parts. Let $n_x = \\text{digits}_B(x)$ and $n_y = \\text{digits}_B(y)$ be the number of base-$B$ digits of $x$ and $y$ respectively. Let $n = \\max(n_x, n_y)$. We choose a splitting point $m = \\lceil n / 2 \\rceil$.\n\nUsing this $m$, we can write $x$ and $y$ as:\n$$x = x_1 B^m + x_0$$\n$$y = y_1 B^m + y_0$$\nwhere $x_1 = \\lfloor x / B^m \\rfloor$, $x_0 = x \\pmod{B^m}$, and similarly for $y_1$ and $y_0$. By construction, $x_0$ and $y_0$ are integers with at most $m$ digits in base $B$.\n\nThe product $x \\cdot y$ can be expanded as:\n$$x \\cdot y = (x_1 B^m + x_0) (y_1 B^m + y_0)$$\n$$x \\cdot y = x_1 y_1 B^{2m} + x_1 y_0 B^m + x_0 y_1 B^m + x_0 y_0$$\n$$x \\cdot y = (x_1 y_1) B^{2m} + (x_1 y_0 + x_0 y_1) B^m + (x_0 y_0)$$\n\nA naive recursive implementation would compute the four products $x_1 y_1$, $x_1 y_0$, $x_0 y_1$, and $x_0 y_0$ recursively. The problem requires a method using only three recursive multiplications. This is achieved by the algebraic identity discovered by Anatoly Karatsuba.\n\nLet us define three intermediate products:\n$z_2 = x_1 y_1$\n$z_0 = x_0 y_0$\n$z_1 = (x_1 + x_0)(y_1 + y_0)$\n\nThe key insight is to express the middle term, $(x_1 y_0 + x_0 y_1)$, using these three products. Expanding $z_1$:\n$$z_1 = x_1 y_1 + x_1 y_0 + x_0 y_1 + x_0 y_0$$\n$$z_1 = z_2 + (x_1 y_0 + x_0 y_1) + z_0$$\n\nFrom this, we can isolate the middle term:\n$$x_1 y_0 + x_0 y_1 = z_1 - z_2 - z_0$$\n\nSubstituting this back into the expression for $x \\cdot y$:\n$$x \\cdot y = z_2 B^{2m} + (z_1 - z_2 - z_0) B^m + z_0$$\n\nThis final expression for the product requires only three multiplications to find $z_0, z_1$, and $z_2$, along with several additions, subtractions, and multiplications by powers of the base $B$ (which are computationally inexpensive shifts). These three products are computed via recursive calls to the multiplication algorithm itself.\n\nThe implementation of `Multiply(x, y, B, t)` will follow this structure:\n\n1.  **Helper Function $\\text{digits}_B(n, B)$**: A function is required to compute the number of digits of an integer $n$ in base $B$. As specified, $\\text{digits}_B(0) = 1$. For $n > 0$, this can be computed robustly using integer division in a loop to avoid potential floating-point precision issues with large numbers, where $\\text{digits}_B(n) = \\lfloor \\log_B n \\rfloor + 1$.\n\n2.  **Base Case**: The recursion must terminate. The problem specifies two conditions for the base case:\n    -   If $x=0$ or $y=0$, the product is $0$.\n    -   If the number of digits of either operand is small enough, i.e., $\\min(\\text{digits}_B(x), \\text{digits}_B(y)) \\le t$, we stop recursing and compute the product $x \\cdot y$ directly. This avoids excessive recursion on small numbers where the overhead of the recursive calls outweighs the benefits.\n\n3.  **Recursive Step**: If the base case is not met:\n    -   Calculate $n = \\max(\\text{digits}_B(x), \\text{digits}_B(y))$.\n    -   Calculate the split point $m = \\lceil n / 2 \\rceil$. In integer arithmetic, this is `(n + 1) // 2`.\n    -   Compute $B_m = B^m$.\n    -   Split $x$ into $x_1 = x // B_m$ and $x_0 = x \\% B_m$.\n    -   Split $y$ into $y_1 = y // B_m$ and $y_0 = y \\% B_m$.\n    -   Make three recursive calls:\n        -   $z_2 = \\text{Multiply}(x_1, y_1, B, t)$\n        -   $z_0 = \\text{Multiply}(x_0, y_0, B, t)$\n        -   $z_1 = \\text{Multiply}(x_1 + x_0, y_1 + y_0, B, t)$\n    -   Recombine the results using the derived formula:\n        $xy = z_2 \\cdot B^{2m} + (z_1 - z_2 - z_0) \\cdot B^m + z_0$. The term $B^{2m}$ can be efficiently computed as $B_m \\cdot B_m$.\n\nThis design fulfills all requirements of the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef digits_B(n, B):\n    \"\"\"\n    Calculates the number of digits of a non-negative integer n in a given base B.\n    As per the problem, digits_B(0) is defined as 1.\n    For n  0, this is equivalent to floor(log_B(n)) + 1.\n    This implementation uses integer arithmetic to avoid floating point precision issues.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    count = 0\n    temp_n = n\n    while temp_n  0:\n        temp_n //= B\n        count += 1\n    return count\n\ndef Multiply(x, y, B, t):\n    \"\"\"\n    Recursively computes the product of two non-negative integers x and y using\n    the Karatsuba algorithm, as specified in the problem statement.\n\n    Args:\n        x (int): A non-negative integer.\n        y (int): A non-negative integer.\n        B (int): The base for number representation (B = 2).\n        t (int): The digit count threshold for the base case (t = 1).\n\n    Returns:\n        int: The exact product x * y.\n    \"\"\"\n    # Base case: if one of the numbers is zero.\n    if x == 0 or y == 0:\n        return 0\n\n    # Determine the number of digits for x and y in base B.\n    num_digits_x = digits_B(x, B)\n    num_digits_y = digits_B(y, B)\n    \n    # Base case: if the number of digits in the smaller number is below the threshold.\n    if min(num_digits_x, num_digits_y) = t:\n        return x * y\n\n    # Recursive step:\n    # 1. Determine the split point m.\n    n_digits = max(num_digits_x, num_digits_y)\n    m = (n_digits + 1) // 2  # This is equivalent to ceil(n_digits / 2)\n\n    # 2. Split the numbers x and y into higher and lower parts.\n    Bm = B**m\n    x1 = x // Bm\n    x0 = x % Bm\n    y1 = y // Bm\n    y0 = y % Bm\n\n    # 3. Make three recursive calls as per the Karatsuba algorithm.\n    z2 = Multiply(x1, y1, B, t)\n    z0 = Multiply(x0, y0, B, t)\n    z1 = Multiply(x1 + x0, y1 + y0, B, t)\n\n    # 4. Recombine the results to get the final product.\n    # The formula is: z2 * B^(2m) + (z1 - z2 - z0) * B^m + z0\n    # To avoid re-calculating powers of B, we can reuse Bm.\n    B2m = Bm * Bm\n    result = z2 * B2m + (z1 - z2 - z0) * Bm + z0\n    \n    return result\n\ndef solve():\n    \"\"\"\n    Solves the problem by running the specified test cases through the\n    recursive multiplication algorithm and printing the results in the\n    required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: x = 123456789012345, y = 987654321098765, B = 10, t = 3\n        (123456789012345, 987654321098765, 10, 3),\n        # Case B: x = 99, y = 99, B = 10, t = 2\n        (99, 99, 10, 2),\n        # Case C: x = 0, y = 987654321, B = 10, t = 3\n        (0, 987654321, 10, 3),\n        # Case D: x = 123456, y = 789012, B = 2, t = 16\n        (123456, 789012, 2, 16),\n        # Case E: x = 10**20 + 12345, y = 10**10 + 678, B = 10, t = 3\n        (10**20 + 12345, 10**10 + 678, 10, 3)\n    ]\n\n    results = []\n    for case in test_cases:\n        x, y, B, t = case\n        result = Multiply(x, y, B, t)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3213594"}, {"introduction": "A correct final answer doesn't always guarantee a correct algorithm, especially in recursion. This practice introduces a powerful debugging technique: validating the algorithm's logic at every step using an invariant check. You will implement a self-verifying Karatsuba function that, at each level of recursion, confirms its recombination step against the trusted grade-school method, building confidence in your implementation's correctness from the inside out [@problem_id:3243186].", "problem": "You are to implement and validate a recursive integer multiplication algorithm based on Karatsuba multiplication using base decomposition, and to embed a debugging strategy that checks a recombination invariant at every recursive level. The debugging invariant states that the recombination of three subproducts must equal the grade-school product computed in the same base at that level. Your task must be derived from first principles and tested on a mixed suite of deterministic inputs.\n\nStart from the following base concepts.\n\n- The base-$B$ representation of a non-negative integer $x$ is the unique expansion $x = \\sum_{i=0}^{n-1} d_i B^i$ with digits $d_i \\in \\{0, 1, \\ldots, B-1\\}$.\n- The distributive property of multiplication over addition for polynomials implies that if $x = x_1 B^m + x_0$ and $y = y_1 B^m + y_0$ for some non-negative integers $x_0, x_1, y_0, y_1$, then $xy$ equals the product of these two binomials expanded and regrouped using standard algebraic rules.\n- The grade-school multiplication algorithm in base $B$ multiplies two numbers by digit-wise convolution with carries and is equivalent to multiplying the associated polynomials in $B$ with coefficient digits, followed by carry normalization.\n\nYour program must implement the following components.\n\n- A function that computes the grade-school product of two (possibly signed) integers $x$ and $y$ in base $B$ by operating on base-$B$ digits. The function must return an exact integer result equal to $xy$. This will serve both as a correct baseline and as the invariant reference.\n- A Karatsuba multiplication routine for non-negative integers based on recursively splitting each operand $x$ and $y$ at a midpoint $m = \\lceil n/2 \\rceil$, where $n$ is the maximum of the base-$B$ digit lengths of the current pair of operands. At each non-base case recursion level, compute:\n  - $z_0$ as the product of the low parts,\n  - $z_2$ as the product of the high parts,\n  - $z_1$ as the product of the sums of low and high parts,\n  and then form the recombination\n  $$z_2 B^{2m} + \\left(z_1 - z_2 - z_0\\right) B^m + z_0.$$\n  Use a small-digit-count cutoff for the base case and delegate to the grade-school algorithm at or below that cutoff.\n- A debugging invariant check that, at every recursive level, compares the recombined value\n  $$z_2 B^{2m} + \\left(z_1 - z_2 - z_0\\right) B^m + z_0$$\n  against the grade-school product of the same operands at that level. This invariant must be checked at all internal nodes of the recursion tree. The check must be applied to the absolute values of the operands inside the recursion; the overall sign can be applied at the outermost level. The routine must aggregate a boolean that is true if and only if all invariant checks at all levels passed and the final product equals the grade-school product for the original pair.\n\nDesign constraints and clarifications.\n\n- All integers in the computations must be exact; no floating-point arithmetic is permitted.\n- The base $B$ must be an integer with $B \\ge 2$.\n- The algorithm must handle zero and unequal-length operands correctly. If negative inputs are provided, handle the sign outside the recursion by factoring it out, and run the recursion on absolute values.\n- The invariant checks are intended for small operand sizes, so do not attempt to optimize them away; they should run as specified for the provided test suite.\n\nTest suite.\n\nYour program must run the following test cases, each specified as a quadruple $(B, x, y, c)$, where $c$ is the base-case cutoff in base-$B$ digits.\n\n- $T_1$: $(10, 12345678, 87654321, 2)$, a general case with multi-digit operands in base $10$.\n- $T_2$: $(10, 0, 987654321, 1)$, a boundary case involving zero in base $10$.\n- $T_3$: $(10, 9, 7, 1)$, a single-digit case in base $10$.\n- $T_4$: $(10, 9999, 9999, 1)$, a boundary case near a power-of-base split in base $10$.\n- $T_5$: $(10, 10^{12} + 345678, 10^{5} + 90123, 2)$, unequal lengths in base $10$.\n- $T_6$: $(2, \\text{binary } 10110100101101001010, \\text{binary } 11100101000101101, 2)$, different base with bit-level operands; interpret the binary literals as integers.\n- $T_7$: $(16, \\text{hex } 1234\\text{abcd}, \\text{hex } 00ff00ff, 2)$, a case in base $16$; interpret the hexadecimal literals as integers.\n- $T_8$: $(10, 123456789012, 34567, 2)$, unequal lengths with a larger base-$10$ operand.\n\nFor clarity, the literal values in $T_6$ and $T_7$ must be taken as the integers represented by the given base-$2$ and base-$16$ strings, respectively.\n\nRequired output format.\n\n- For each test case, compute the Karatsuba product with invariant checks enabled and aggregate a boolean that is true if and only if all invariant checks passed at every recursion level and the final product equals the grade-school product for that test case's parameters. Produce a single line of output containing the $8$ boolean results as a comma-separated list enclosed in square brackets, for example, $[true,false,\\ldots]$. Use the canonical Python boolean string forms $True$ and $False$ for each element in the output list.", "solution": "The problem requires the implementation and validation of the Karatsuba multiplication algorithm for arbitrarily large integers in a specified base $B$. The implementation must include a recursive structure with a base-case cutoff, proper handling of signs and zero, and a built-in debugging invariant. This invariant check must verify, at every level of recursion, that the result from Karatsuba's recombination formula matches the product computed by a standard \"grade-school\" algorithm for the same inputs at that level.\n\nThe solution is developed from first principles, starting with the representation of integers and culminating in the complete, validated algorithm.\n\n### Principle 1: Base-$B$ Representation and Grade-School Multiplication\n\nAn integer $x$ can be uniquely represented in base $B$ as a sum of powers of $B$, weighted by digits $d_i \\in \\{0, 1, \\ldots, B-1\\}$:\n$$x = \\sum_{i=0}^{n-1} d_i B^i$$\nThe product of two integers, $x = \\sum_{i=0}^{n-1} a_i B^i$ and $y = \\sum_{j=0}^{m-1} b_j B^j$, can be viewed as the product of two polynomials in the variable $B$. Using the distributive property, the product $z = xy$ is:\n$$z = \\left(\\sum_{i=0}^{n-1} a_i B^i\\right) \\left(\\sum_{j=0}^{m-1} b_j B^j\\right) = \\sum_{k=0}^{n+m-2} c_k B^k$$\nwhere $c_k = \\sum_{i+j=k} a_i b_j$. The grade-school multiplication algorithm is a procedural implementation of this polynomial product, followed by normalization of the coefficients $c_k$ through a process of carrying over values that exceed the base $B-1$.\n\nFor the purpose of this problem, which requires exact integer arithmetic, the most robust and correct implementation of a \"grade-school\" product is to use the native arbitrary-precision integer multiplication provided by the host language (Python). This operation is itself a highly optimized and correct implementation of these principles, providing an exact integer result equal to $xy$. It will serve as the ground-truth reference for our invariant checks.\n\n### Principle 2: Karatsuba's Recursive Decomposition\n\nThe standard polynomial multiplication requires $n \\times m$ elementary multiplications. Karatsuba's algorithm reduces this complexity. Let two $n$-digit numbers, $x$ and $y$, be split into high and low parts. We choose a split point $m = \\lceil n/2 \\rceil$.\n$$x = x_1 B^m + x_0$$\n$$y = y_1 B^m + y_0$$\nwhere $x_0, y_0  B^m$. The product $xy$ is:\n$$xy = (x_1 B^m + x_0)(y_1 B^m + y_0) = (x_1 y_1) B^{2m} + (x_1 y_0 + x_0 y_1) B^m + (x_0 y_0)$$\nThis expansion appears to require four multiplications: $x_1 y_1$, $x_1 y_0$, $x_0 y_1$, and $x_0 y_0$. Karatsuba's key insight is to compute the middle term $(x_1 y_0 + x_0 y_1)$ using only one additional multiplication. Let:\n- $z_2 = x_1 y_1$\n- $z_0 = x_0 y_0$\n- $z_1 = (x_0 + x_1)(y_0 + y_1) = x_0 y_0 + x_1 y_0 + x_0 y_1 + x_1 y_1 = z_0 + (x_1 y_0 + x_0 y_1) + z_2$\n\nFrom this, we can isolate the middle term coefficient:\n$$(x_1 y_0 + x_0 y_1) = z_1 - z_2 - z_0$$\nSubstituting back into the product expansion gives Karatsuba's recombination formula, which uses only three smaller multiplications ($z_0$, $z_1$, $z_2$):\n$$xy = z_2 B^{2m} + (z_1 - z_2 - z_0) B^m + z_0$$\nThis decomposition forms the basis of a recursive algorithm. The recursion continues until the number of digits in the operands is small enough to be handled by a simpler, non-recursive method (the base case).\n\n### Algorithmic Implementation and Invariant Check\n\nThe algorithm is implemented as a recursive function that takes two non-negative integers $x$ and $y$, a base $B$, a cutoff digit count $c$, and a list to aggregate the results of the invariant checks.\n\n1.  **Sign Handling**: A top-level wrapper function handles the signs of the inputs. It determines the sign of the final product, performs the Karatsuba multiplication on the absolute values of the inputs, and applies the correct sign to the final result.\n\n2.  **Number of Digits**: A helper function is required to calculate the number of digits of an integer $n$ in a given base $B$. For $n>0$, this is $\\lfloor \\log_B n \\rfloor + 1$. For $n=0$, it is $1$. A simple iterative division is used for robustness with large integers.\n\n3.  **Recursive Function `karatsuba_multiply_recursive(x, y, B, c, checks)`**:\n    -   **Base Case**: The recursion terminates if the maximum number of digits of $x$ or $y$ in base $B$ is less than or equal to the cutoff $c$. In this case, the product is computed directly using the grade-school reference (i.e., native multiplication $x \\times y$) and returned.\n    -   **Recursive Step**:\n        a. Calculate $n = \\max(\\text{digits}_B(x), \\text{digits}_B(y))$.\n        b. Define the split point $m = \\lceil n/2 \\rceil$.\n        c. Split the numbers: $x_1 = x // B^m$, $x_0 = x \\pmod{B^m}$. Similarly for $y$.\n        d. Recursively compute the three sub-products:\n           - $z_0 = \\text{karatsuba\\_multiply\\_recursive}(x_0, y_0, B, c, \\text{checks})$\n           - $z_2 = \\text{karatsuba\\_multiply\\_recursive}(x_1, y_1, B, c, \\text{checks})$\n           - $z_1 = \\text{karatsuba\\_multiply\\_recursive}(x_0 + x_1, y_0 + y_1, B, c, \\text{checks})$\n        e. **Invariant Check**: This is the critical debugging step.\n           i. Recombine the sub-products: `recombined_product` $= z_2 B^{2m} + (z_1 - z_2 - z_0) B^m + z_0$.\n           ii. Compute the ground-truth product for the current level's inputs: `ground_truth` $= x \\times y$.\n           iii. Compare them and append the boolean result to the `checks` list: `checks.append(recombined_product == ground_truth)`.\n        f. Return the `recombined_product`.\n\n4.  **Final Validation**: The overall result for a given test case is `True` if and only if two conditions are met:\n    a. All invariant checks at every level of the recursion tree are `True`.\n    b. The final Karatsuba product for the top-level inputs matches the grade-school product for those same inputs.\n\nThis structured approach ensures correctness by continuous self-verification throughout the computation, providing a high degree of confidence in the final result.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_num_digits_in_base(n, base):\n    \"\"\"\n    Calculates the number of digits of a non-negative integer n in a given base.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    if base = 1:\n        raise ValueError(\"Base must be = 2\")\n\n    num_digits = 0\n    temp_n = n\n    while temp_n  0:\n        temp_n //= base\n        num_digits += 1\n    return num_digits\n\ndef karatsuba_multiply_recursive(x, y, base, cutoff, invariant_checks):\n    \"\"\"\n    Performs recursive Karatsuba multiplication on non-negative integers\n    and runs an invariant check at each recursive step.\n    \"\"\"\n    # Determine the number of digits for the current operands.\n    n_x = get_num_digits_in_base(x, base)\n    n_y = get_num_digits_in_base(y, base)\n    n = max(n_x, n_y)\n\n    # Base case: if the number of digits is below or at the cutoff,\n    # use standard multiplication.\n    if n = cutoff:\n        return x * y\n\n    # Recursive step\n    # m is the split point, ceiling of n/2\n    m = (n + 1) // 2\n    \n    # B^m\n    b_m = base ** m\n\n    # Split numbers into high and low parts.\n    x1, x0 = divmod(x, b_m)\n    y1, y0 = divmod(y, b_m)\n\n    # Three recursive calls.\n    z0 = karatsuba_multiply_recursive(x0, y0, base, cutoff, invariant_checks)\n    z2 = karatsuba_multiply_recursive(x1, y1, base, cutoff, invariant_checks)\n    z1 = karatsuba_multiply_recursive(x0 + x1, y0 + y1, base, cutoff, invariant_checks)\n\n    # Karatsuba recombination formula.\n    recombined_product = z2 * (base ** (2 * m)) + (z1 - z2 - z0) * b_m + z0\n\n    # The invariant check: compare recombination vs grade-school at this level.\n    # The grade-school product is simulated by Python's exact integer multiplication.\n    ground_truth = x * y\n    invariant_checks.append(recombined_product == ground_truth)\n    \n    return recombined_product\n\ndef run_karatsuba_test(B, x, y, c):\n    \"\"\"\n    A wrapper to handle signs and perform the final validation check.\n    \"\"\"\n    if B  2:\n        raise ValueError(\"Base must be = 2\")\n\n    invariant_checks = []\n    \n    original_x, original_y = x, y\n    \n    # Handle signs outside the recursion.\n    sign = 1\n    if x  0:\n        sign *= -1\n        x = -x\n    if y  0:\n        sign *= -1\n        y = -y\n\n    # Run the recursive algorithm on absolute values.\n    # Note: x and y are now guaranteed to be non-negative.\n    karatsuba_result = karatsuba_multiply_recursive(x, y, B, c, invariant_checks)\n    \n    # Apply the sign to the final result.\n    final_karatsuba_product = karatsuba_result * sign\n    \n    # Final validation: check if the top-level result is correct.\n    final_ground_truth = original_x * original_y\n    final_check_passed = (final_karatsuba_product == final_ground_truth)\n    \n    # The test passes if ALL invariant checks passed AND the final result is correct.\n    return all(invariant_checks) and final_check_passed\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the validation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # T1: (B, x, y, c)\n        (10, 12345678, 87654321, 2),\n        # T2:\n        (10, 0, 987654321, 1),\n        # T3:\n        (10, 9, 7, 1),\n        # T4:\n        (10, 9999, 9999, 1),\n        # T5:\n        (10, 10**12 + 345678, 10**5 + 90123, 2),\n        # T6: (binary literals interpreted as integers)\n        (2, 0b10110100101101001010, 0b11100101000101101, 2),\n        # T7: (hex literals interpreted as integers)\n        (16, 0x1234abcd, 0x00ff00ff, 2),\n        # T8:\n        (10, 123456789012, 34567, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        B, x, y, c = case\n        is_valid = run_karatsuba_test(B, x, y, c)\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3243186"}, {"introduction": "The true power of Karatsuba's algorithm lies in its sub-quadratic time complexity of $O(n^{\\log_2 3})$. This final practice moves from implementation to empirical analysis, offering a chance to connect theory with observation. You will design a computational experiment to measure the algorithm's performance, use regression analysis on the collected data to estimate its scaling exponent, and see how closely your empirical results match the celebrated theoretical prediction [@problem_id:3243158].", "problem": "You are tasked with designing and executing a self-contained computational experiment that empirically recovers the exponent in the asymptotic time complexity of the Karatsuba multiplication algorithm using only first principles from divide-and-conquer analysis and elementary statistical fitting. The experiment must be implemented as a complete, runnable program that performs no input or output beyond printing a single aggregated line described below.\n\nBegin from the following base elements:\n- The asymptotic time of an algorithm on inputs of “size” $n$ is modeled as a function $t(n)$ counting a fixed proxy for the work performed. In a unit-cost Random Access Machine (RAM) model, one may proxy “runtime” by counting elementary operations such as single-digit multiplications. The Karatsuba algorithm reduces a multiplication of two $n$-digit numbers into a fixed number of multiplications on roughly half-sized inputs, in addition to linear-time overhead for additions and shifts. The grade-school algorithm performs a multiplication for two $n$-digit numbers using a quadratic number of single-digit multiplications.\n- To empirically estimate an exponent $\\alpha$ in a hypothesized law $t(n) = c\\,n^{\\alpha}$ with constant $c>0$, it suffices to apply a logarithm and fit a line $y = \\alpha x + b$ where $x = \\ln n$, $y = \\ln t(n)$, and $b = \\ln c$. The slope $\\alpha$ can be estimated by Ordinary Least Squares (OLS).\n\nYour program must:\n1) Implement a counting model for two multiplication strategies over length-$n$ digit strings (in any fixed base) that returns a proxy “time” $t(n)$ equal to the number of single-digit multiplications performed by the algorithm on worst-case inputs of length $n$.\n   - For the grade-school algorithm, use the fundamental fact that it performs $n^2$ single-digit multiplications; set $t_{\\text{grade}}(n) = n^2$.\n   - For Karatsuba, implement a recurrence that counts single-digit multiplications under divide-and-conquer with a tunable base-case threshold $b$. Specifically, for $n \\le b$, use the grade-school cost $n^2$ as the base case; for $n > b$, split $n$ into two parts $n_{\\text{high}} = \\lceil n/2 \\rceil$ and $n_{\\text{low}} = \\lfloor n/2 \\rfloor$, and count three recursive multiplications on subproblem sizes $n_{\\text{high}}$, $n_{\\text{low}}$, and $\\max(n_{\\text{high}}, n_{\\text{low}})$. This models the three submultiplications performed after the divide-and-conquer rearrangement, while additions and shifts are not counted in $t(n)$ (they do not change the fitted exponent when using sufficiently large $n$). The recurrence is\n   $$\n   t_{\\text{kara}}(n) = \n   \\begin{cases}\n   n^2,  n \\le b,\\\\\n   t_{\\text{kara}}(n_{\\text{high}}) + t_{\\text{kara}}(n_{\\text{low}}) + t_{\\text{kara}}(\\max\\{n_{\\text{high}}, n_{\\text{low}}\\}),  n > b,\n   \\end{cases}\n   $$\n   with $n_{\\text{high}} = \\lceil n/2 \\rceil$ and $n_{\\text{low}} = \\lfloor n/2 \\rfloor$.\n\n2) For each provided test case, generate a sequence of input sizes $\\{n_i\\}$, compute the corresponding counts $\\{t(n_i)\\}$ for the specified algorithm, then estimate $\\alpha$ by OLS on the pairs $(\\ln n_i, \\ln t(n_i))$. Use the natural logarithm. The fitted slope is the estimate $\\widehat{\\alpha}$.\n\n3) For comparison with theory, compute the absolute error of the estimate relative to the theoretical exponent obtained by solving the standard divide-and-conquer recurrence using the Master Theorem framework. For the Karatsuba method, the theoretical exponent is the unique $\\alpha$ satisfying the homogeneous recurrence solution for the case of three subproblems of half size and lower-order work; for the grade-school method, the theoretical exponent is that of the quadratic work law.\n\nThe test suite to be executed by your program is as follows. Each test case specifies the algorithm, the base-case threshold $b$ (only for Karatsuba), and the list of sizes $\\{n_i\\}$ on which to fit the model:\n- Test $1$ (happy path, powers of two with moderate threshold): Karatsuba with $b = 16$ on sizes $[16, 32, 64, 128, 256]$.\n- Test $2$ (happy path, larger threshold): Karatsuba with $b = 32$ on sizes $[32, 64, 128, 256, 512]$.\n- Test $3$ (edge case, aggressive recursion): Karatsuba with $b = 1$ on sizes $[8, 16, 32, 64, 128]$.\n- Test $4$ (control, quadratic baseline): grade-school on sizes $[16, 32, 64, 128, 256]$.\n- Test $5$ (non-power-of-two sizes to test uneven splits): Karatsuba with $b = 8$ on sizes $[30, 60, 120, 240, 480]$.\n\nFor each test case, your program must output two floating-point numbers:\n- The fitted exponent $\\widehat{\\alpha}$.\n- The absolute error $|\\widehat{\\alpha} - \\alpha_{\\text{theory}}|$, where for Karatsuba, $\\alpha_{\\text{theory}}$ is the theoretical exponent that solves the three-way half-size recurrence, and for grade-school, $\\alpha_{\\text{theory}}$ is the quadratic exponent.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, the pair for Test $1$, then Test $2$, then Test $3$, then Test $4$, then Test $5$. For example, the output should have the form\n$[\\widehat{\\alpha}_1,\\text{err}_1,\\widehat{\\alpha}_2,\\text{err}_2,\\widehat{\\alpha}_3,\\text{err}_3,\\widehat{\\alpha}_4,\\text{err}_4,\\widehat{\\alpha}_5,\\text{err}_5]$.\nAll numbers must be printed as decimal floating-point values. No physical units are involved in this problem.", "solution": "The objective of this problem is to conduct a computational experiment to empirically validate the theoretical time complexity of the Karatsuba multiplication algorithm. This involves implementing a counting model for the number of elementary multiplications, performing a statistical analysis on the generated data, and comparing the empirical results with the established theoretical exponents derived from divide-and-conquer analysis.\n\n### 1. Theoretical Framework and Estimation Method\n\nThe time complexity of many algorithms, particularly those based on divide-and-conquer, can be modeled for an input of size $n$ by a power law of the form:\n$$\nt(n) \\approx c \\cdot n^{\\alpha}\n$$\nwhere $t(n)$ represents the number of fundamental operations (a proxy for runtime), $c$ is a constant related to implementation details and overhead, and $\\alpha$ is the asymptotic scaling exponent that characterizes the algorithm's efficiency.\n\nTo empirically estimate the exponent $\\alpha$, we can transform this power-law relationship into a linear one by taking the natural logarithm of both sides:\n$$\n\\ln(t(n)) = \\ln(c \\cdot n^{\\alpha}) = \\ln(c) + \\alpha \\ln(n)\n$$\nThis equation is in the form of a straight line, $y = b + \\alpha x$, where $y = \\ln(t(n))$, $x = \\ln(n)$, and the y-intercept is $b = \\ln(c)$. Given a set of data points $(n_i, t(n_i))$ from the computational experiment, we can generate a set of transformed points $(x_i, y_i) = (\\ln(n_i), \\ln(t(n_i)))$. The exponent $\\alpha$ can then be estimated as the slope of the best-fit line through these points using Ordinary Least Squares (OLS).\n\nFor a set of $N$ data points $\\{(x_i, y_i)\\}_{i=1}^N$, the OLS estimate for the slope, denoted $\\widehat{\\alpha}$, is given by the formula:\n$$\n\\widehat{\\alpha} = \\frac{\\sum_{i=1}^{N} (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^{N} (x_i - \\bar{x})^2}\n$$\nwhere $\\bar{x}$ and $\\bar{y}$ are the sample means of the $x_i$ and $y_i$ values, respectively.\n\n### 2. Algorithmic Models and Theoretical Exponents\n\nThe experiment considers two multiplication algorithms:\n\n**Grade-School Multiplication:**\nThe standard grade-school method for multiplying two $n$-digit numbers performs $n \\times n = n^2$ single-digit multiplications. The counting function is therefore:\n$$\nt_{\\text{grade}}(n) = n^2\n$$\nFrom this quadratic relationship, the theoretical exponent is precisely $\\alpha_{\\text{grade}} = 2$.\n\n**Karatsuba Multiplication:**\nThe Karatsuba algorithm is a divide-and-conquer strategy. The problem specifies a precise recurrence relation for counting the number of single-digit multiplications, which includes a base-case threshold $b$. For an input of size $n$:\n$$\nt_{\\text{kara}}(n, b) = \n\\begin{cases}\nn^2,  \\text{if } n \\le b \\\\\nt_{\\text{kara}}(n_{\\text{high}}, b) + t_{\\text{kara}}(n_{\\text{low}}, b) + t_{\\text{kara}}(\\max\\{n_{\\text{high}}, n_{\\text{low}}\\}, b),  \\text{if } n > b\n\\end{cases}\n$$\nwhere $n_{\\text{high}} = \\lceil n/2 \\rceil$ and $n_{\\text{low}} = \\lfloor n/2 \\rfloor$. Since $n_{\\text{high}} \\ge n_{\\text{low}}$ by definition, the term $\\max\\{n_{\\text{high}}, n_{\\text{low}}\\}$ simplifies to $n_{\\text{high}}$. The recurrence becomes:\n$$\nt_{\\text{kara}}(n, b) = 2 \\cdot t_{\\text{kara}}(\\lceil n/2 \\rceil, b) + t_{\\text{kara}}(\\lfloor n/2 \\rfloor, b)\n$$\nThe standard asymptotic analysis of Karatsuba's algorithm considers the simplified recurrence $T(n) = 3T(n/2) + O(n)$, which neglects the ceiling/floor functions and additive lower-order terms. Applying the Master Theorem to this recurrence (with $a=3, b=2$), the complexity is dominated by the recursive calls, yielding $T(n) = \\Theta(n^{\\log_b a}) = \\Theta(n^{\\log_2 3})$. Thus, the theoretical exponent is:\n$$\n\\alpha_{\\text{kara}} = \\log_2 3 \\approx 1.58496\n$$\nThis theoretical value serves as the benchmark against which our empirical estimate $\\widehat{\\alpha}$ will be compared.\n\n### 3. Experimental Design and Procedure\n\nThe program will execute a series of tests as defined in the problem statement. For each test, the following steps are performed:\n1.  The appropriate counting function ($t_{\\text{grade}}$ or a memoized $t_{\\text{kara}}$) is used to generate the operation counts $\\{t(n_i)\\}$ for the given list of input sizes $\\{n_i\\}$. For the recursive $t_{\\text{kara}}$ function, memoization (caching) is employed to avoid redundant computations and ensure efficiency.\n2.  The data is transformed into a log-log scale, producing points $(x_i, y_i) = (\\ln(n_i), \\ln(t(n_i)))$.\n3.  The OLS formula is applied to the transformed points to calculate the estimated exponent $\\widehat{\\alpha}$.\n4.  The absolute error is computed as $|\\widehat{\\alpha} - \\alpha_{\\text{theory}}|$, where $\\alpha_{\\text{theory}}$ is $2$ for the grade-school algorithm and $\\log_2 3$ for the Karatsuba algorithm.\n5.  The resulting pair $(\\widehat{\\alpha}, |\\widehat{\\alpha} - \\alpha_{\\text{theory}}|)$ is stored.\n\nThe final output aggregates these pairs from all test cases into a single, formatted list. The test cases are designed to explore the behavior of the algorithms under different conditions, such as varying base-case thresholds, input sizes that are powers of two, and input sizes that are not powers of two, which test the handling of uneven splits in the recurrence.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment and print the results.\n    \"\"\"\n\n    def get_kara_counter(b):\n        \"\"\"\n        Creates a memoized recursive function to count multiplications for Karatsuba.\n        A closure is used to maintain a private cache for a given base-case threshold b.\n        \"\"\"\n        memo = {}\n\n        def t_kara(n):\n            if n in memo:\n                return memo[n]\n            \n            if n = b:\n                result = n * n\n                memo[n] = result\n                return result\n\n            n_high = (n + 1) // 2  # Integer equivalent of math.ceil(n / 2)\n            n_low = n // 2         # Integer equivalent of math.floor(n / 2)\n            \n            # The recurrence given is t(n) = t(n_high) + t(n_low) + t(max(n_high, n_low)).\n            # Since n_high = n_low, this simplifies to 2 * t(n_high) + t(n_low).\n            result = 2 * t_kara(n_high) + t_kara(n_low)\n            memo[n] = result\n            return result\n\n        return t_kara\n\n    def t_grade(n):\n        \"\"\"\n        Counts multiplications for the grade-school algorithm.\n        \"\"\"\n        return n * n\n\n    def estimate_exponent_ols(n_values, t_values):\n        \"\"\"\n        Estimates the exponent alpha from (n, t) data using OLS on log-log data.\n        \"\"\"\n        if len(n_values)  2:\n            return np.nan # Cannot fit a line to fewer than 2 points\n\n        x = np.log(n_values)\n        y = np.log(t_values)\n        \n        x_mean = np.mean(x)\n        y_mean = np.mean(y)\n        \n        numerator = np.sum((x - x_mean) * (y - y_mean))\n        denominator = np.sum((x - x_mean)**2)\n        \n        if denominator == 0:\n            return np.nan # all n_values were the same\n            \n        alpha_hat = numerator / denominator\n        return alpha_hat\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'id': 1, 'algo': 'karatsuba', 'b': 16, 'n': [16, 32, 64, 128, 256]},\n        {'id': 2, 'algo': 'karatsuba', 'b': 32, 'n': [32, 64, 128, 256, 512]},\n        {'id': 3, 'algo': 'karatsuba', 'b': 1,  'n': [8, 16, 32, 64, 128]},\n        {'id': 4, 'algo': 'grade-school', 'n': [16, 32, 64, 128, 256]},\n        {'id': 5, 'algo': 'karatsuba', 'b': 8,  'n': [30, 60, 120, 240, 480]},\n    ]\n    \n    # Theoretical exponents\n    alpha_theory_kara = np.log(3) / np.log(2)\n    alpha_theory_grade = 2.0\n    \n    all_results = []\n\n    for case in test_cases:\n        n_values = np.array(case['n'])\n        \n        if case['algo'] == 'karatsuba':\n            b = case['b']\n            counter_func = get_kara_counter(b)\n            t_values = np.array([counter_func(n) for n in n_values])\n            alpha_theory = alpha_theory_kara\n        else: # grade-school\n            t_values = np.array([t_grade(n) for n in n_values])\n            alpha_theory = alpha_theory_grade\n\n        # Estimate exponent and calculate error\n        alpha_hat = estimate_exponent_ols(n_values, t_values)\n        error = np.abs(alpha_hat - alpha_theory)\n        \n        all_results.extend([alpha_hat, error])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3243158"}]}