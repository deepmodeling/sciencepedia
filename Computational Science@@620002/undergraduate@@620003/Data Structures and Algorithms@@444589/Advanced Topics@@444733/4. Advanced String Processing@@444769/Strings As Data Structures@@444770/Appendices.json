{"hands_on_practices": [{"introduction": "Analyzing substrings for specific compositional properties is a frequent challenge in text processing and computational biology. This problem asks you to determine if a permutation of a pattern string $T$ exists as a contiguous substring within a larger string $S$. Rather than inefficiently checking each substring from scratch, this exercise guides you to use the sliding window technique, a fundamental pattern in algorithm design. Mastering this approach is crucial, as it allows you to maintain and update a character frequency map in constant time per step, leading to an elegant and efficient linear-time solution.", "problem": "You are given two finite strings $S$ and $T$ over an arbitrary finite alphabet $\\Sigma$. Let $|S|=n$ and $|T|=m$. A substring of $S$ is any contiguous block `S[i..j]` for integers $0 \\le i \\le j  n$. A permutation of $T$ is any string that has exactly the same multiset of characters as $T$. The task is to decide, for each provided pair $(S,T)$, whether there exists an index $i$ with $0 \\le i \\le n-m$ such that the substring `S[i..i+m-1]` is a permutation of $T$.\n\nFormulate your answer purely in terms of the definitions above. In particular, use the fundamental fact that two strings are permutations of one another if and only if their character frequency maps (viewed as functions from $\\Sigma$ to $\\mathbb{Z}_{\\ge 0}$) are equal. No other pre-derived shortcut formulas are allowed. You should reason from the definitions of string, substring, permutation, and character frequency.\n\nEdge-case conventions to use:\n- The empty string, denoted by $\\varepsilon$, is a substring of every string (including itself). Therefore, when $m=0$, the answer must be $1$ for any $S$ (including the case $S=\\varepsilon$).\n- If $m>n$, the answer must be $0$.\n\nYour program must not read any input. Instead, it must compute the results for the following fixed test suite of $(S,T)$ pairs:\n- $S$: \"cbaebabacd\", $T$: \"abc\"\n- $S$: \"abab\", $T$: \"ab\"\n- $S$: \"abcd\", $T$: \"e\"\n- $S$: \"aaab\", $T$: \"aab\"\n- $S$: \"aab\", $T$: \"aaa\"\n- $S$: \"\", $T$: \"a\"\n- $S$: \"anything\", $T$: \"\"\n- $S$: \"\", $T$: \"\"\n- $S$: \"a\", $T$: \"a\"\n\nFor each pair, output $1$ if some permutation of $T$ is a substring of $S$, and $0$ otherwise.\n\nFinal output format: Your program should produce a single line of output containing the results for the test suite, aggregated as a comma-separated list of integers in $\\{0,1\\}$ enclosed in square brackets, with no spaces. For example, a valid output looks like $[1,0,1]$ (this is only an example format, not the answer for the above test suite).", "solution": "The problem is to determine if any permutation of a given string $T$ appears as a contiguous substring within another string $S$. The lengths of the strings are given as $|S|=n$ and $|T|=m$.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- Two finite strings $S$ and $T$ over an arbitrary finite alphabet $\\Sigma$.\n- $|S|=n$, $|T|=m$.\n- A substring of $S$ is a contiguous block `S[i..j]` for integers $0 \\le i \\le j  n$.\n- A permutation of $T$ is a string with the same multiset of characters as $T$.\n- Task: Decide if there exists an index $i$ ($0 \\le i \\le n-m$) such that `S[i..i+m-1]` is a permutation of $T$.\n- Fundamental Principle: Two strings are permutations of one another if and only if their character frequency maps are equal. A character frequency map is a function from $\\Sigma$ to the non-negative integers $\\mathbb{Z}_{\\ge 0}$.\n- Edge-case conventions:\n    - If $m=0$, the answer is $1$.\n    - If $m>n$, the answer is $0$.\n- Test Suite: A fixed set of nine $(S,T)$ pairs is provided.\n- Output Format: For each pair, output $1$ for true and $0$ for false, collated into a single comma-separated list like `[1,0,...]`.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is assessed against the validation criteria:\n- **Scientifically Grounded**: The problem is a standard exercise in algorithm design and string manipulation, a core topic in computer science. The concepts of strings, substrings, permutations, and frequency analysis are mathematically well-defined. The problem is sound.\n- **Well-Posed**: The problem is clearly stated. For any input pair $(S,T)$, the question has a decidable yes/no answer, leading to a unique result.\n- **Objective**: The problem uses precise, unambiguous terminology and avoids any subjective claims.\n- **Completeness and Consistency**: The problem is self-contained. It provides all necessary definitions, constraints, and edge-case handling rules, which are consistent with standard definitions in the field.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is a well-defined algorithmic challenge. A solution will be constructed based on the fundamental principles laid out in the problem statement.\n\n### Algorithmic Solution\n\nThe core of the problem lies in the provided principle: two strings are permutations of each other if and only if their character frequency maps are identical. Let $f_X: \\Sigma \\to \\mathbb{Z}_{\\ge 0}$ denote the frequency map of a string $X$, where $f_X(c)$ is the count of character $c$ in $X$. The task is to find if there exists an index $i$ such that $0 \\le i \\le n-m$ where the substring $W_i = S[i..i+m-1]$ satisfies $f_{W_i} = f_T$.\n\nWe will structure the solution by first addressing the specified edge cases, and then developing an efficient algorithm for the general case.\n\n**1. Edge Cases**\n\n- **Case 1: $m > n$**\n  If the length of $T$ is greater than the length of $S$, it is impossible to form a substring of $S$ that has length $m$. Therefore, no such substring exists, and the condition can never be met. The result is $0$.\n\n- **Case 2: $m = 0$**\n  In this case, $T$ is the empty string, $\\varepsilon$. Its character frequency map, $f_\\varepsilon$, maps every character $c \\in \\Sigma$ to $0$. The problem states that the empty string is a substring of every string. An empty substring also has a frequency map where all character counts are $0$. Thus, a permutation of $T$ (which is just $T$ itself) is a substring of $S$. The condition is met, and the result is $1$.\n\n**2. General Case: $0  m \\le n$**\n\nFor the main case, we must check each substring of $S$ of length $m$. A naive approach would be to iterate through all $n-m+1$ possible substrings, generate the frequency map for each one, and compare it to the frequency map of $T$. This is computationally inefficient as it involves redundant counting.\n\nA more efficient method is the **sliding window algorithm**. This algorithm maintains a \"window\" of length $m$ that slides across the string $S$. The character frequency map of the window is updated incrementally at each step, avoiding a full recount.\n\n**Algorithm Steps:**\n\n1.  **Initialization:**\n    - Compute the character frequency map for the target string $T$, denoted as $f_T$. This requires a single pass over $T$, taking $O(m)$ time.\n    - Compute the character frequency map for the initial window in $S$, which is the substring $W_0 = S[0..m-1]$. Let this map be $f_W$. This also takes $O(m)$ time.\n    - Compare $f_W$ and $f_T$. If they are identical (i.e., $f_W(c) = f_T(c)$ for all $c \\in \\Sigma$), a match is found at index $i=0$. The algorithm can terminate and return $1$. The comparison takes $O(|\\Sigma|)$ time, where $|\\Sigma|$ is the size of the alphabet.\n\n2.  **Sliding the Window:**\n    - Iterate from $i = 1$ to $n-m$. In each iteration $i$, the window slides one position to the right, from `S[i-1..i+m-2]` to `S[i..i+m-1]`.\n    - To update the frequency map $f_W$ from the window at $i-1$ to the window at $i$, we perform two constant-time operations:\n        a. **Decrement:** The character `S[i-1]` is no longer in the window. We decrement its count in $f_W$: $f_W(S[i-1]) \\leftarrow f_W(S[i-1]) - 1$.\n        b. **Increment:** The character `S[i+m-1]` is newly included in the window. We increment its count in $f_W$: $f_W(S[i+m-1]) \\leftarrow f_W(S[i+m-1]) + 1$.\n    - After updating $f_W$, compare it with $f_T$. If they are identical, a match is found at index $i$. The algorithm can terminate and return $1$.\n\n3.  **Termination:**\n    - If the loop completes without finding any match, it means no substring of $S$ is a permutation of $T$. The algorithm returns $0$.\n\n**Complexity Analysis**\nThe initialization phase takes $O(m + |\\Sigma|)$ time. The sliding phase consists of $n-m$ iterations. Each iteration involves two $O(1)$ updates to the frequency map and one $O(|\\Sigma|)$ comparison. Therefore, the total time complexity is $O(m + |\\Sigma| + (n-m) \\cdot |\\Sigma|)$, which can be simplified to $O(m + n \\cdot |\\Sigma|)$. If the alphabet size $|\\Sigma|$ is treated as a constant (e.g., $256$ for ASCII), the complexity is linear, $O(n+m)$. This is an efficient way to solve the problem based on the provided first principles.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the substring permutation problem for a fixed test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"cbaebabacd\", \"abc\"),\n        (\"abab\", \"ab\"),\n        (\"abcd\", \"e\"),\n        (\"aaab\", \"aab\"),\n        (\"aab\", \"aaa\"),\n        (\"\", \"a\"),\n        (\"anything\", \"\"),\n        (\"\", \"\"),\n        (\"a\", \"a\"),\n    ]\n\n    results = []\n    for s_str, t_str in test_cases:\n        results.append(check_inclusion(s_str, t_str))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef check_inclusion(s: str, t: str) - int:\n    \"\"\"\n    Checks if a permutation of string T is a substring of string S.\n\n    Args:\n        s: The string to search within.\n        t: The string whose permutations are sought.\n\n    Returns:\n        1 if a permutation of T is found in S, 0 otherwise.\n    \"\"\"\n    n, m = len(s), len(t)\n\n    # Handle edge cases as per the problem description.\n    # If m=0, the empty string is a substring of any string.\n    if m == 0:\n        return 1\n    # If mn, it's impossible for a permutation of T to be a substring of S.\n    if m  n:\n        return 0\n\n    # The problem is defined over an \"arbitrary finite alphabet\".\n    # We use a fixed-size array assuming an ASCII-like character set of 256 symbols.\n    # This is a common and efficient implementation for this type of problem.\n    alphabet_size = 256\n\n    # Create character frequency maps for T and the first window of S.\n    # f_t will store the frequency map of the pattern string T.\n    # f_window will store the frequency map of the current sliding window in S.\n    f_t = np.zeros(alphabet_size, dtype=int)\n    f_window = np.zeros(alphabet_size, dtype=int)\n\n    # Populate the frequency maps for T and the initial window S[0...m-1].\n    for i in range(m):\n        f_t[ord(t[i])] += 1\n        f_window[ord(s[i])] += 1\n    \n    # Check the first window.\n    if np.array_equal(f_t, f_window):\n        return 1\n\n    # Slide the window across the rest of the string S.\n    # The window is S[i-m+1 ... i].\n    for i in range(m, n):\n        # Add the new character entering the window from the right.\n        f_window[ord(s[i])] += 1\n        # Remove the old character leaving the window from the left.\n        f_window[ord(s[i - m])] -= 1\n\n        # Check if the frequency maps are identical.\n        if np.array_equal(f_t, f_window):\n            return 1\n\n    # If the loop finishes without a match, no such substring exists.\n    return 0\n\nsolve()\n```", "id": "3276196"}, {"introduction": "Many problems in sequence analysis involve splitting a string and comparing the properties of the resulting parts. A naive approach, re-calculating properties for every possible split, is often too slow. This exercise introduces the powerful strategy of precomputation, where initial passes are used to gather data that makes the final analysis trivial. You will calculate the number of \"good splits\" in a string, where a split is good if the count of unique characters is the same in the left and right partitions. This practice demonstrates a core principle of dynamic programming: solve a complex problem by first computing and storing solutions to simpler subproblems.", "problem": "You are given a finite string $S$ over a finite alphabet. Let the length of $S$ be $n$, with $0$-based indices from $0$ to $n-1$. For an index $i$ with $1 \\le i \\le n-1$, define a split at $i$ to partition $S$ into a left part $S[0:i]$ and a right part $S[i:n]$. A split at index $i$ is called good if the number of distinct characters in the left part equals the number of distinct characters in the right part. Formally, define the distinct-character-count function on a substring as $D(T) = |\\{c \\mid c \\text{ appears in } T\\}|$. Then the split at $i$ is good if and only if $D(S[0:i]) = D(S[i:n])$. The task is to compute, for a given $S$, the number of good splits, which is the number of indices $i$ with $1 \\le i \\le n-1$ satisfying $D(S[0:i]) = D(S[i:n])$.\n\nFundamental base and constraints are as follows.\n- A string is a finite sequence of symbols, and a set is a collection of distinct elements; the cardinality of a set $A$ is denoted $|A|$.\n- The distinct-character-count function $D(\\cdot)$ is the cardinality of the set of symbols present in the argument substring.\n- All indices are $0$-based, and all substrings $S[a:b]$ are half-open intervals including $a$ and excluding $b$, where $0 \\le a \\le b \\le n$.\n- Characters can be assumed to be standard printable characters; all provided test cases use lowercase English letters.\n- There are no physical quantities in this problem.\n\nYour program must be a complete, runnable program that computes the number of good splits for each string in the following test suite and outputs all results in a single line.\n\nTest suite (each element is a string $S$):\n1. $S = \\text{\"aacaba\"}$\n2. $S = \\text{\"abcd\"}$\n3. $S = \\text{\"aaaaa\"}$\n4. $S = \\text{\"\"}$ (the empty string; here $n = 0$)\n5. $S = \\text{\"a\"}$\n6. $S = \\text{\"ababa\"}$\n7. $S = \\text{\"zzzyyx\"}$\n8. $S = \\text{\"bbaaccdd\"}$\n\nAnswer specification:\n- For each test string, the answer is an integer equal to the number of good splits.\n- The final output format must be a single line containing a comma-separated list of the answers in the given order, enclosed in square brackets, with no spaces. For example, if the answers were $x_1, x_2, \\dots, x_8$, the program must print exactly the line $[x_1,x_2,\\dots,x_8]$.\n\nYour solution should be derived from first principles based on the definitions above and must be logically consistent and implementable for any modern programming language. No interactive input is required; the program should directly compute answers for the provided test suite.", "solution": "The user wants me to act as a meticulous STEM professor and solve the given problem.\n\n### Problem Validation\n\nFirst, I will validate the problem statement.\n\n**1. Extract Givens:**\n- **Input:** A finite string $S$ over a finite alphabet.\n- **String Length:** $n = |S|$.\n- **Indices:** $0$-based, from $0$ to $n-1$.\n- **Split Definition:** A partition of $S$ at an index $i$ ($1 \\le i \\le n-1$) into a left part $S[0:i]$ and a right part $S[i:n]$.\n- **Distinct Character Count:** $D(T) = |\\{c \\mid c \\text{ appears in } T\\}|$.\n- **Good Split Condition:** A split at $i$ is good if $D(S[0:i]) = D(S[i:n])$.\n- **Objective:** Compute the total number of good splits for a given string $S$.\n- **Constraints  Definitions:** Standard definitions for strings, sets, and substrings (half-open intervals $S[a:b]$).\n- **Test Suite:** A list of 8 strings is provided: $S_1 = \\text{\"aacaba\"}$, $S_2 = \\text{\"abcd\"}$, $S_3 = \\text{\"aaaaa\"}$, $S_4 = \\text{\"\"}$, $S_5 = \\text{\"a\"}$, $S_6 = \\text{\"ababa\"}$, $S_7 = \\text{\"zzzyyx\"}$, $S_8 = \\text{\"bbaaccdd\"}$.\n\n**2. Validation using Extracted Givens:**\n- **Scientific Grounding:** The problem is based on well-defined mathematical and computer science concepts (strings, sets, counting). It is scientifically sound.\n- **Well-Posedness:** All terms are defined formally and precisely. The range of possible splits is explicitly given ($1 \\le i \\le n-1$), which means for $n  2$, no splits are possible, yielding a count of $0$. This is consistent. For any given string, the number of good splits is a unique, determinable integer.\n- **Objectivity:** The problem statement is objective and free of subjective or ambiguous language.\n- **Flaw Check:** The problem does not violate any of the invalidity criteria. It is a standard, formalizable algorithmic problem, complete, consistent, and verifiable.\n\n**3. Verdict and Action:**\n- **Verdict:** The problem is **valid**.\n- **Action:** I will now proceed with a formal solution.\n\n### Formal Solution\n\nThe problem requires us to count the number of indices $i$ in a string $S$ of length $n$ such that $1 \\le i \\le n-1$ and the number of distinct characters in the prefix $S[0:i]$ is equal to the number of distinct characters in the suffix $S[i:n]$.\n\nLet $S$ be a string of length $n$. The set of possible split points is the set of integers $\\{i \\mid 1 \\le i \\le n-1\\}$. For a split at index $i$, we define the left part as the prefix $L_i = S[0:i]$ and the right part as the suffix $R_i = S[i:n]$. Let $D(T)$ denote the number of unique characters in a string $T$. A split at $i$ is \"good\" if and only if $D(L_i) = D(R_i)$. Our goal is to calculate $\\left| \\{i \\mid 1 \\le i \\le n-1 \\text{ and } D(S[0:i]) = D(S[i:n]) \\} \\right|$.\n\nA direct but inefficient approach would be to iterate through each possible split index $i$ from $1$ to $n-1$. For each $i$, we would construct the substrings $S[0:i]$ and $S[i:n]$, convert each to a set of characters, and compare the cardinalities of these sets. The construction of substrings and sets at each step would lead to a total time complexity of $O(n^2)$, which is computationally suboptimal for large $n$.\n\nA more principled and efficient algorithm can be designed by pre-calculating the distinct character counts for all relevant prefixes and suffixes. This avoids redundant computations. We can achieve this in linear time, $O(n)$.\n\nThe algorithm proceeds as follows:\n\n1.  **Prefix Distinct Character Counts:** We define an array, let's call it $P$, of length $n$. For each index $j$ from $0$ to $n-1$, $P[j]$ will store the number of distinct characters in the prefix $S[0:j+1]$.\n    This array can be computed in a single pass from left to right. We maintain a set of characters encountered so far.\n    - Initialize an empty set, `seen_chars`.\n    - For $j$ from $0$ to $n-1$:\n        - Add the character $S[j]$ to `seen_chars`.\n        - Set $P[j] = |\\text{seen\\_chars}|$.\n    This computation takes $O(n)$ time, assuming set insertion has an average time complexity of $O(1)$.\n\n2.  **Suffix Distinct Character Counts:** Similarly, we define an array, $Q$, of length $n$. For each index $j$ from $0$ to $n-1$, $Q[j]$ will store the number of distinct characters in the suffix $S[j:n]$.\n    This array is best computed in a single pass from right to left.\n    - Initialize an empty set, `seen_chars`.\n    - For $j$ from $n-1$ down to $0$:\n        - Add the character $S[j]$ to `seen_chars`.\n        - Set $Q[j] = |\\text{seen\\_chars}|$.\n    This computation also takes $O(n)$ time.\n\n3.  **Counting Good Splits:** With arrays $P$ and $Q$ computed, we can find the number of good splits in a final linear scan. A split at index $i$ involves the prefix $S[0:i]$ and the suffix $S[i:n]$.\n    - The number of distinct characters in the prefix $S[0:i]$ (which ends at index $i-1$) is given by $P[i-1]$.\n    - The number of distinct characters in the suffix $S[i:n]$ (which starts at index $i$) is given by $Q[i]$.\n    - Therefore, a split at $i$ is good if $P[i-1] = Q[i]$.\n\n    We can count the number of such occurrences:\n    - Initialize `count = 0`.\n    - For $i$ from $1$ to $n-1$:\n        - If $P[i-1] = Q[i]$, increment `count`.\n    This final step takes $O(n-1)$, which is $O(n)$.\n\nThe overall time complexity of this algorithm is $O(n) + O(n) + O(n) = O(n)$. The space complexity is $O(n)$ to store the two arrays $P$ and $Q$. This is an asymptotically optimal solution.\n\nFor strings where $n  2$, the range of split indices $1 \\le i \\le n-1$ is empty. Thus, the number of good splits is correctly evaluated as $0$. This holds for the test cases $S = \\text{\"\"}$ ($n=0$) and $S = \\text{\"a\"}$ ($n=1$).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the good splits problem for the given test suite.\n    A split at index i is \"good\" if the number of distinct characters\n    in the left part S[0:i] equals that in the right part S[i:n].\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        \"aacaba\",\n        \"abcd\",\n        \"aaaaa\",\n        \"\",\n        \"a\",\n        \"ababa\",\n        \"zzzyyx\",\n        \"bbaaccdd\"\n    ]\n\n    results = []\n    for s in test_cases:\n        n = len(s)\n\n        # For a split to exist at index i, we must have 1 = i = n-1.\n        # This requires n to be at least 2. If n  2, no splits are possible.\n        if n  2:\n            results.append(0)\n            continue\n\n        # P[j] = number of distinct characters in the prefix S[0:j+1]\n        prefix_distinct = np.zeros(n, dtype=int)\n        seen_chars = set()\n        for i in range(n):\n            seen_chars.add(s[i])\n            prefix_distinct[i] = len(seen_chars)\n\n        # Q[j] = number of distinct characters in the suffix S[j:n]\n        suffix_distinct = np.zeros(n, dtype=int)\n        seen_chars.clear()\n        for i in range(n - 1, -1, -1):\n            seen_chars.add(s[i])\n            suffix_distinct[i] = len(seen_chars)\n        \n        good_splits_count = 0\n        # A split is at index i, for 1 = i = n-1.\n        # The left part is S[0:i], ending at index i-1. Its distinct char count is prefix_distinct[i-1].\n        # The right part is S[i:n], starting at index i. Its distinct char count is suffix_distinct[i].\n        for i in range(1, n):\n            if prefix_distinct[i - 1] == suffix_distinct[i]:\n                good_splits_count += 1\n        \n        results.append(good_splits_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3276135"}, {"introduction": "Effective problem-solving often involves not just applying standard algorithms, but reframing a question into a more manageable form. This practice challenges you to determine if one string is a cyclic shift of another, a task that seems to require checking every possible rotation. However, this exercise reveals a classic and beautiful insight in string theory: a string $B$ is a cyclic shift of string $A$ if and only if $B$ is a substring of the concatenation $A \\cdot A$. This clever transformation reduces the problem to a standard substring search, which can be solved with remarkable efficiency.", "problem": "You are given two finite strings $A$ and $B$ over a finite alphabet $\\Sigma$. A cyclic shift of a string is defined by the following fundamental base: for a string $A$ of length $n$, a string $B$ of length $n$ is a cyclic shift of $A$ if and only if there exists an integer shift $s$ with $0 \\le s  n$ such that for all indices $i$ with $0 \\le i  n$, $B[i] = A[(i + s) \\bmod n]$. The core operations on strings are concatenation, denoted $X \\cdot Y$, and substring search, which asks whether a pattern $P$ occurs contiguously within a text $T$. Using only these definitions, design and implement a single-pass algorithm that determines whether $B$ is a cyclic shift of $A$ in time $O(|A| + |B|)$, where $|A|$ and $|B|$ denote lengths. You may use either a single string search (for example, the Knuth–Morris–Pratt algorithm) or a single rolling-hash pass (for example, the Rabin–Karp algorithm) to achieve the time bound.\n\nYour program must:\n- Accept no input and use the fixed test suite specified below.\n- For each test case $(A, B)$, return a boolean indicating whether $B$ is a cyclic shift of $A$ according to the formal definition above.\n- Operate in time $O(|A| + |B|)$ for each test case using a single search over the concatenated string $A \\cdot A$ or a single rolling-hash pass, and must not perform multiple independent searches that would increase the asymptotic complexity.\n- Handle boundary conditions rigorously, including the case $|A|=0$ and $|B|=0$.\n\nThe required output format is a single line containing a comma-separated list of the booleans for all test cases, enclosed in square brackets, with no spaces; for example, $[x_1,x_2,\\dots,x_k]$ where each $x_i$ is either True or False.\n\nUse the following test suite of $(A,B)$ pairs:\n- (\"abcde\", \"cdeab\")\n- (\"abcde\", \"abced\")\n- (\"aaaa\", \"aaaa\")\n- (\"aaaa\", \"aaab\")\n- (\"\", \"\")\n- (\"a\", \"a\")\n- (\"abc\", \"abcd\")\n- (\"abab\", \"baba\")\n- (\"rotation\", \"tionrota\")\n- (\"abcdef\", \"faebcd\")\n- (\"abcdef\", \"fabcde\")\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\").", "solution": "The problem of determining if a string $B$ is a cyclic shift of another string $A$ is a classic problem in computer science, specifically in the domain of string algorithms. The solution hinges on a simple but elegant property related to string concatenation.\n\n### Step 1: Problem Validation\n\nThe first step, as per rigorous scientific practice, is to validate the problem statement.\n\n#### Extracted Givens\n- **Inputs**: Two finite strings, $A$ and $B$, over a finite alphabet $\\Sigma$.\n- **Definition of Cyclic Shift**: For strings $A$ and $B$ of equal length $n$, $B$ is a cyclic shift of $A$ if and only if there exists an integer $s$ where $0 \\le s  n$ such that for all indices $i$ with $0 \\le i  n$, the equality $B[i] = A[(i + s) \\bmod n]$ holds.\n- **Allowed Operations**: Concatenation ($X \\cdot Y$) and substring search.\n- **Performance Constraint**: The algorithm must operate in $O(|A| + |B|)$ time.\n- **Implementation Constraint**: The algorithm must use a single search pass, either via a string searching algorithm like Knuth-Morris-Pratt (KMP) or a rolling-hash method like Rabin-Karp.\n- **Boundary Conditions**: The cases where $|A| = 0$ and $|B| = 0$ must be handled.\n\n#### Validation\nThe problem is well-posed and scientifically grounded in the established theory of algorithms and formal languages.\n1.  **Scientific Soundness**: The definitions of strings, cyclic shifts, concatenation, and substring search are standard and mathematically precise. The time complexity notation $O(\\cdot)$ is also a cornerstone of algorithm analysis. No principles of mathematics or computer science are violated.\n2.  **Completeness and Consistency**: The problem provides all necessary information. The definition of a cyclic shift is formally stated and applies only when the strings have equal length, i.e., $|A| = |B|$. This implies that if $|A| \\neq |B|$, $B$ cannot be a cyclic shift of $A$. This observation is a direct logical consequence of the definition, not a contradiction. The boundary case of empty strings ($|A|=|B|=0$) needs careful interpretation. The definition requires the existence of a shift $s$ in the range $0 \\le s  0$. Since this range is empty, no such $s$ exists, and a strict interpretation of the existential quantifier (\"there exists\") would yield `False`. However, the provided hint to use concatenation ($A \\cdot A$) and substring search suggests a standard algorithmic interpretation. For $A = B = \\text{\"\"}$ (the empty string), $A \\cdot A$ is also the empty string. The empty string is a substring of itself. This more practical interpretation, which is standard in algorithm libraries, implies that the empty string is a cyclic shift of itself. This is not a flaw in the problem but a point of clarification that will be adopted in the solution.\n3.  **Objectivity and Solvability**: The problem is stated objectively and asks for a verifiable boolean result. A clear algorithmic path is suggested and is known to exist.\n\n#### Verdict\nThe problem is **valid**. We may proceed with designing a solution.\n\n### Step 2: Algorithmic Design and Justification\n\nThe solution is constructed based on a primary theorem of cyclic shifts and a subsequent efficient algorithm.\n\n#### Foundational Principle\nThe core of the solution lies in the following theorem:\n_For two non-empty strings $A$ and $B$ of the same length $n$, $B$ is a cyclic shift of $A$ if and only if $B$ is a substring of the concatenation $A \\cdot A$._\n\n**Proof**:\n- **(Forward direction)**: Assume $B$ is a cyclic shift of $A$. By definition, there exists a shift $s$ ($0 \\le s  n$) such that $B = A[s..n-1] \\cdot A[0..s-1]$, where $A[i..j]$ denotes the substring of $A$ from index $i$ to $j$. Let's consider the string $C = A \\cdot A = A[0..n-1] \\cdot A[0..n-1]$. The substring of $C$ starting at index $s$ with length $n$ is $C[s..s+n-1]$. This substring is precisely $A[s..n-1] \\cdot A[0..s-1]$, which is equal to $B$. Thus, $B$ is a substring of $A \\cdot A$.\n\n- **(Backward direction)**: Assume $B$ is a substring of $A \\cdot A$. Since $|A| = |B| = n$, $B$ must be a substring of length $n$ starting at some index $s$ in $A \\cdot A$, where $0 \\le s  n$. (If $s \\ge n$, the remaining part of $A \\cdot A$ has length less than $n$). The substring of $A \\cdot A$ starting at index $s$ is $A[s..n-1] \\cdot A[0..s-1]$. This is, by definition, the cyclic shift of $A$ by amount $s$. Therefore, if $B$ is a substring of $A \\cdot A$, it must be equal to one of the cyclic shifts of $A$.\n\nThis theorem reduces the problem of checking all possible cyclic shifts to a single substring search problem.\n\n#### Algorithm\nBased on the principle above, we can formulate a complete and efficient algorithm. Let the input strings be $A$ and $B$.\n\n1.  **Length Check**: The first and most fundamental condition for a cyclic shift is that the strings must have equal length. If $|A| \\neq |B|$, we can immediately conclude that $B$ is not a cyclic shift of $A$. The algorithm returns `False`.\n    \n2.  **Empty String Check**: If the lengths are equal and are $0$, i.e., $|A| = |B| = 0$, both are empty strings. As resolved during validation, we consider the empty string to be a cyclic shift of itself. The algorithm returns `True`. This case is naturally handled by the next step in most modern programming languages.\n    \n3.  **Concatenation and Substring Search**: If $|A| = |B| = n > 0$, we construct the string $S = A \\cdot A$. The length of $S$ is $2n$. We then perform a search for the string $B$ (the pattern) within the string $S$ (the text). If $B$ is found, it is a cyclic shift of $A$, and the algorithm returns `True`. Otherwise, it returns `False`.\n\n#### Time Complexity Analysis\nLet $n = |A|$ and $m = |B|$.\n- The length comparison is an $O(1)$ operation.\n- If $n \\neq m$, the algorithm terminates.\n- If $n = m$, we proceed. The concatenation $A \\cdot A$ creates a new string of length $2n$, which takes $O(n)$ time.\n- The substring search for pattern $B$ (length $n$) in text $A \\cdot A$ (length $2n$) can be performed in $O(\\text{length of text} + \\text{length of pattern})$ time using efficient algorithms like KMP, Boyer-Moore, or Rabin-Karp. In this case, the time complexity is $O(2n + n) = O(n)$.\n- The total time complexity is therefore $O(n)$, which is equivalent to $O(|A| + |B|)$ since $|A|=|B|=n$. This satisfies the problem's performance requirement. Python's `in` operator for strings is highly optimized and achieves this linear time performance.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_cyclic_shift(A: str, B: str) - bool:\n    \"\"\"\n    Determines if string B is a cyclic shift of string A.\n\n    The function follows these logical steps:\n    1. A cyclic shift requires the strings to be of equal length. If not,\n       it's impossible, so we return False.\n    2. If the lengths are equal and greater than 0, B is a cyclic shift\n       of A if and only if B is a substring of the concatenated\n       string A + A.\n    3. The case of empty strings (A=\"\", B=\"\") is handled correctly by this\n       logic, as len(A) == len(B), and \"\" is a substring of \"\" + \"\",\n       so it correctly returns True.\n\n    Args:\n        A: The first string.\n        B: The second string.\n\n    Returns:\n        A boolean: True if B is a cyclic shift of A, False otherwise.\n    \"\"\"\n    # Step 1: Length Validation\n    # A necessary condition for a cyclic shift is that strings have equal length.\n    if len(A) != len(B):\n        return False\n\n    # Step 2: Concatenation and Substring Search\n    # This single check handles all cases where lengths are equal:\n    # - If A and B are empty (\"\"), A+A is \"\" and \"\" is in \"\", returning True.\n    # - If A and B are non-empty, it checks if B exists in the doubled string A+A,\n    #   which is the core of the efficient algorithm.\n    # Python's `in` operator for strings leverages highly optimized search\n    # algorithms (like a hybrid of Boyer-Moore and Horspool), achieving\n    # O(|A| + |B|) complexity.\n    return B in (A + A)\n\ndef solve():\n    \"\"\"\n    Runs the predefined test suite for the cyclic shift problem\n    and prints the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"abcde\", \"cdeab\"),    # True\n        (\"abcde\", \"abced\"),    # False\n        (\"aaaa\", \"aaaa\"),      # True\n        (\"aaaa\", \"aaab\"),      # False\n        (\"\", \"\"),              # True (by convention and algorithmic property)\n        (\"a\", \"a\"),              # True\n        (\"abc\", \"abcd\"),       # False (different lengths)\n        (\"abab\", \"baba\"),      # True\n        (\"rotation\", \"tionrota\"), # True\n        (\"abcdef\", \"faebcd\"),  # False\n        (\"abcdef\", \"fabcde\"),  # False - A cyclic shift must be contiguous. 'fabcde' is not a contiguous rotation.\n    ]\n\n    results = []\n    for A, B in test_cases:\n        result = is_cyclic_shift(A, B)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # map(str, ...) converts boolean True/False to \"True\"/\"False\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3276275"}]}