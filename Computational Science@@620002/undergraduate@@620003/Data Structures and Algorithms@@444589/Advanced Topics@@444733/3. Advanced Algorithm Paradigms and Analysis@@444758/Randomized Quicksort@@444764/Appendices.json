{"hands_on_practices": [{"introduction": "A common intuition is that sorting an \"almost sorted\" array should be faster than sorting a completely random one. This exercise challenges that assumption in the context of randomized quicksort. By analyzing an array where only $k$ elements are out of place, we uncover a profound property of the algorithm: its expected performance is independent of the initial input order [@problem_id:3263621]. This practice is fundamental to understanding why randomization is so powerful, as it guarantees efficiency on average, no matter how adversarial the input data might seem.", "problem": "Consider an array of $n$ distinct keys drawn from a totally ordered set. Construct an \"almost sorted\" input as follows: begin with the keys in increasing order and then relocate exactly $k$ distinct keys to arbitrary positions, producing an array in which exactly $k$ keys are not in their final sorted ranks. Run the classic randomized quicksort that, at each recursive call on a subarray, selects the pivot uniformly at random from that subarray and partitions by comparing every other element in the subarray once against the pivot.\n\nLet $C_{n,k}$ denote the total number of key-to-key comparisons performed by this randomized quicksort on such an input. Take the expectation with respect to the algorithm’s internal randomness only; the particular locations of the $k$ misplaced elements are fixed but otherwise arbitrary. Derive, from first principles, a closed-form expression for $\\mathbb{E}[C_{n,k}]$ as a function of $n$ and $k$. Express your final answer in terms of the $n$th harmonic number $H_n$, where $H_n = \\sum_{i=1}^{n} \\frac{1}{i}$.\n\nYour answer must be a single analytic expression. Do not provide inequalities or asymptotic notation, and do not include any units. If simplification is performed, keep $H_n$ symbolic and exact.", "solution": "The user-provided problem has been validated and is deemed **valid**. It is a well-posed problem in the analysis of algorithms that tests a fundamental property of randomized quicksort. The introduction of the parameter $k$ for an \"almost sorted\" array serves to test the understanding that the expected number of comparisons in randomized quicksort is independent of the initial permutation of the input elements, as the expectation is taken over the algorithm's internal random choices.\n\nWe proceed to derive the expected number of comparisons, $\\mathbb{E}[C_{n,k}]$, from first principles.\n\nLet the set of $n$ distinct keys be denoted by their sorted order as $\\{z_1, z_2, \\dots, z_n\\}$, where $z_1  z_2  \\dots  z_n$. The total number of key-to-key comparisons, $C_{n,k}$, can be expressed as a sum of indicator random variables:\n$$C_{n,k} = \\sum_{1 \\le i  j \\le n} X_{ij}$$\nwhere $X_{ij}$ is an indicator random variable such that $X_{ij} = 1$ if key $z_i$ and key $z_j$ are compared at some point during the execution of the algorithm, and $X_{ij} = 0$ otherwise.\n\nBy the linearity of expectation, the expected total number of comparisons is the sum of the expected values of these indicator variables:\n$$\\mathbb{E}[C_{n,k}] = \\mathbb{E}\\left[\\sum_{1 \\le i  j \\le n} X_{ij}\\right] = \\sum_{1 \\le i  j \\le n} \\mathbb{E}[X_{ij}]$$\nThe expectation of an indicator random variable is the probability of the event it indicates. Therefore, $\\mathbb{E}[X_{ij}] = P(X_{ij} = 1)$, which is the probability that keys $z_i$ and $z_j$ are compared.\n\nTo determine this probability, we analyze the conditions under which a comparison between $z_i$ and $z_j$ occurs. Consider the set of keys $S_{ij} = \\{z_i, z_{i+1}, \\dots, z_j\\}$. The size of this set is $|S_{ij}| = j - i + 1$.\nTwo keys $z_i$ and $z_j$ are compared if and only if the very first pivot selected by the algorithm from the set $S_{ij}$ is either $z_i$ or $z_j$.\nTo see why, consider two cases for the first pivot $p$ selected from $S_{ij}$:\n1.  If the pivot $p$ is such that $z_i  p  z_j$, then $z_i$ will be placed in the \"less than $p$\" partition, and $z_j$ will be placed in the \"greater than $p$\" partition. They will reside in different subarrays for all subsequent recursive calls and will never be compared to each other.\n2.  If the pivot $p$ is $z_i$ or $z_j$, then $z_i$ and $z_j$ are compared during the partitioning step (as every other element in the subarray is compared to the pivot).\n\nThe randomized quicksort algorithm selects a pivot uniformly at random from the elements of the current subarray. At the moment the first pivot is chosen from the set $S_{ij}$, all elements of $S_{ij}$ are present in the same subarray. Therefore, any element in $S_{ij}$ has an equal probability of being the first pivot chosen from that set. This probability is $\\frac{1}{|S_{ij}|} = \\frac{1}{j-i+1}$.\n\nThis crucial observation is independent of the initial physical arrangement of the keys in the input array. The probability calculation depends only on the relative ranks of the keys. The specific permutation of the input, described by the parameter $k$, has no bearing on this probability. The \"averaging\" is done over the algorithm's random choices, not over a distribution of inputs.\n\nThe event \"$z_i$ and $z_j$ are compared\" corresponds to the first pivot from $S_{ij}$ being either $z_i$ or $z_j$. Since these are two distinct outcomes, each with probability $\\frac{1}{j-i+1}$, the total probability is:\n$$P(X_{ij} = 1) = \\frac{2}{j-i+1}$$\nSince this probability is independent of the input permutation, the expected number of comparisons $\\mathbb{E}[C_{n,k}]$ is independent of $k$. We can denote it as $\\mathbb{E}[C_n]$. We now compute the sum:\n$$\\mathbb{E}[C_n] = \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{2}{j-i+1}$$\nWe can re-index the summation. Let's fix $i$ and introduce a new index $d = j-i$. As $j$ ranges from $i+1$ to $n$, $d$ ranges from $1$ to $n-i$.\n$$\\mathbb{E}[C_n] = 2 \\sum_{i=1}^{n-1} \\sum_{d=1}^{n-i} \\frac{1}{d+1}$$\nNext, we swap the order of summation. The summation region is defined by $1 \\le i \\le n-1$ and $1 \\le d \\le n-i$. This is equivalent to $1 \\le d \\le n-1$ and $1 \\le i \\le n-d$.\n$$\\mathbb{E}[C_n] = 2 \\sum_{d=1}^{n-1} \\sum_{i=1}^{n-d} \\frac{1}{d+1}$$\nThe inner sum is over $i$, and the term $\\frac{1}{d+1}$ is constant with respect to $i$. The sum $\\sum_{i=1}^{n-d} 1$ evaluates to $n-d$.\n$$\\mathbb{E}[C_n] = 2 \\sum_{d=1}^{n-1} \\frac{n-d}{d+1}$$\nTo evaluate this sum, we perform an algebraic manipulation on the term inside:\n$$\\frac{n-d}{d+1} = \\frac{(n+1) - (d+1)}{d+1} = \\frac{n+1}{d+1} - 1$$\nSubstituting this back into the expression for the expectation:\n$$\\mathbb{E}[C_n] = 2 \\sum_{d=1}^{n-1} \\left(\\frac{n+1}{d+1} - 1\\right)$$\nUsing the linearity of summation:\n$$\\mathbb{E}[C_n] = 2 \\left( \\sum_{d=1}^{n-1} \\frac{n+1}{d+1} - \\sum_{d=1}^{n-1} 1 \\right) = 2 \\left( (n+1) \\sum_{d=1}^{n-1} \\frac{1}{d+1} - (n-1) \\right)$$\nThe first sum can be related to the harmonic numbers, $H_n = \\sum_{i=1}^{n} \\frac{1}{i}$. Let $m = d+1$. As $d$ goes from $1$ to $n-1$, $m$ goes from $2$ to $n$.\n$$\\sum_{d=1}^{n-1} \\frac{1}{d+1} = \\sum_{m=2}^{n} \\frac{1}{m} = \\left(\\sum_{m=1}^{n} \\frac{1}{m}\\right) - \\frac{1}{1} = H_n - 1$$\nSubstituting this result back into our expression for $\\mathbb{E}[C_n]$:\n$$\\mathbb{E}[C_n] = 2 \\left( (n+1)(H_n - 1) - (n-1) \\right)$$\nExpanding and simplifying the terms inside the parentheses:\n$$\\mathbb{E}[C_n] = 2 \\left( (n+1)H_n - (n+1) - (n-1) \\right)$$\n$$\\mathbb{E}[C_n] = 2 \\left( (n+1)H_n - n - 1 - n + 1 \\right)$$\n$$\\mathbb{E}[C_n] = 2 \\left( (n+1)H_n - 2n \\right)$$\nThis gives the final closed-form expression:\n$$\\mathbb{E}[C_{n,k}] = 2(n+1)H_n - 4n$$\nThis result is the well-known expected number of comparisons for randomized quicksort on any array of $n$ distinct elements, confirming that the structure of the initial permutation does not affect the outcome.", "answer": "$$\\boxed{2(n+1)H_n - 4n}$$", "id": "3263621"}, {"introduction": "While randomization protects against worst-case inputs, the choice of partitioning strategy still has a significant impact, especially on arrays with many duplicate keys. This exercise explores such a scenario using a simple array of boolean values [@problem_id:3263576]. By comparing the performance of standard 2-way partitioning against a 3-way \"Dutch National Flag\" approach, you will gain practical insight into how tailoring the partition method to the data's characteristics can lead to substantial efficiency gains.", "problem": "You are given an array of $n$ Boolean keys containing exactly $k$ occurrences of the key value $1$ and $n-k$ occurrences of the key value $0$, where $1 \\le k \\le n-1$. The array is in an arbitrary order. Consider two variants of randomized quicksort applied to this array:\n\n- Variant A (standard $2$-way partitioning): Each recursive call chooses a pivot uniformly at random from the subarray, and partitions the subarray into the two groups “less than pivot” and “greater than or equal to pivot,” then recurses on both groups.\n- Variant B (Dutch National Flag style $3$-way partitioning): Each recursive call chooses a pivot uniformly at random from the subarray, and partitions the subarray into the three groups “less than pivot,” “equal to pivot,” and “greater than pivot,” then recurses only on the “less than” and “greater than” groups.\n\nIn both variants, measure cost as the total number of key comparisons against the pivot across the entire execution. Use a trichotomic comparator that, in a single comparison of an element with the pivot, determines whether it is less than, equal to, or greater than the pivot; thus, partitioning a subarray of size $m$ performs exactly $m-1$ key comparisons. The only source of randomness is the uniformly random choice of the pivot at each recursive call.\n\nDerive from first principles closed-form expressions, as functions of $n$ and $k$, for the expected total number of key comparisons performed by Variant A and by Variant B on this input model. Express your final answer as two explicit formulas in terms of $n$ and $k$. No rounding is required. Provide your two formulas in a single row vector in the order [Variant A, Variant B].", "solution": "The problem asks for the expected total number of key comparisons for two variants of randomized quicksort on an array of $n$ Boolean keys, consisting of $n-k$ zeros and $k$ ones, where $1 \\le k \\le n-1$. The cost of partitioning a subarray of size $m$ is given as $m-1$ comparisons.\n\nWe can solve this problem by using the method of indicator random variables. The total number of comparisons, $C$, is the sum of comparisons over all distinct pairs of elements in the array. Let $S$ be the set of $n$ keys. The total expected number of comparisons is given by:\n$$\nE[C] = \\sum_{\\{u, v\\} \\subseteq S, u \\neq v} P(u \\text{ and } v \\text{ are compared})\n$$\nBy linearity of expectation, we can calculate the expected number of comparisons by summing the probabilities that any two elements are compared. The array contains two distinct key values, $0$ and $1$. We can therefore classify the pairs of elements $\\{u, v\\}$ into three types:\n1.  Both keys are $0$. The number of such pairs is $\\binom{n-k}{2}$.\n2.  Both keys are $1$. The number of such pairs is $\\binom{k}{2}$.\n3.  One key is $0$ and the other is $1$. The number of such pairs is $(n-k)k$.\n\nWe will now analyze the probability of comparison for each pair type under each quicksort variant. A comparison between two elements $u$ and $v$ occurs if one of them is chosen as a pivot while the other is still in the same subarray. They are separated, and thus will never be compared, if a pivot $p$ is chosen that places them into different recursive subproblems.\n\n### Variant A: Standard 2-way Partitioning\n\nIn this variant, a subarray is partitioned into two groups: \"less than pivot\" ($p$) and \"greater than or equal to pivot\" ($\\ge p$). The pivot itself is removed, and recursion proceeds on both groups.\n\n1.  **Pair of two zeros $(\\{z_1, z_2\\})$**: Let the chosen pivot be $p$.\n    -   If $p=0$, both $z_1$ and $z_2$ are greater than or equal to the pivot, so they both go into the second partition. They are not separated.\n    -   If $p=1$, both $z_1$ and $z_2$ are less than the pivot, so they both go into the first partition. They are not separated.\n    Since no pivot value can separate two zeros, they will always remain in the same subproblem. Eventually, one of them must be chosen as a pivot while the other is in the same subarray, at which point they will be compared. Therefore, any two zeros are compared with probability $1$.\n    The expected number of comparisons for these pairs is $\\binom{n-k}{2} \\times 1 = \\frac{(n-k)(n-k-1)}{2}$.\n\n2.  **Pair of two ones $(\\{o_1, o_2\\})$**:\n    -   If $p=0$, both $o_1$ and $o_2$ are greater than or equal to the pivot. They are not separated.\n    -   If $p=1$, both $o_1$ and $o_2$ are greater than or equal to the pivot. They are not separated.\n    Similar to the case of two zeros, two ones are never separated. Thus, they are compared with probability $1$.\n    The expected number of comparisons for these pairs is $\\binom{k}{2} \\times 1 = \\frac{k(k-1)}{2}$.\n\n3.  **Pair of a zero and a one $(\\{z, o\\})$**:\n    -   If a pivot $p=0$ is chosen, both $z$ and $o$ are $\\ge p$. They remain in the same partition.\n    -   If a pivot $p=1$ is chosen, $z$ goes to the $p$ partition and $o$ goes to the $\\ge p$ partition. They are separated.\n    The pair $\\{z, o\\}$ is compared if and only if either $z$ or $o$ is chosen as pivot before any other element with value $1$ is chosen as pivot from a subproblem containing them. Let $S_1$ be the set of all $k$ ones. The set of \"relevant\" elements for the fate of the pair $\\{z, o\\}$ is the set $R = \\{z\\} \\cup S_1$, which has size $k+1$. Any pivot chosen from outside this set is a zero, which does not separate $z$ and $o$. The pair is compared if the first pivot chosen from the set $R$ is either $z$ or $o$. If any other element from $R$ (which must be a one, say $o'$) is chosen first, $z$ and $o$ are separated without being compared. Since the pivot is chosen uniformly at random, any element in $R$ is equally likely to be the first one chosen from $R$.\n    The probability of comparison is $P(z \\text{ or } o \\text{ is chosen first from } R) = \\frac{2}{|R|} = \\frac{2}{k+1}$.\n    The expected number of comparisons for these pairs is $(n-k)k \\times \\frac{2}{k+1}$.\n\nSumming the expected comparisons for all pair types, we get the total expected number of comparisons for Variant A:\n$$ E_A(n, k) = \\frac{(n-k)(n-k-1)}{2} + \\frac{k(k-1)}{2} + \\frac{2k(n-k)}{k+1} $$\n\n### Variant B: 3-way Partitioning (Dutch National Flag)\n\nIn this variant, a subarray is partitioned into three groups: \"less than pivot\" ($p$), \"equal to pivot\" ($=p$), and \"greater than pivot\" ($p$). Recursion proceeds only on the \"less than\" and \"greater than\" groups. Elements equal to the pivot are eliminated from further consideration.\n\n1.  **Pair of two zeros $(\\{z_1, z_2\\})$**:\n    -   If a pivot $p=1$ is chosen, both zeros go into the $p$ partition. They are not separated.\n    -   If a pivot $p=0$ is chosen, and this pivot is an element other than $z_1$ or $z_2$, then both $z_1$ and $z_2$ go into the $=p$ partition. They are eliminated and never compared.\n    -   If the pivot is $z_1$ or $z_2$, they are compared.\n    So, $z_1$ and $z_2$ are compared if and only if one of them is chosen as a pivot before any other zero is chosen as a pivot from a subproblem containing them. Let $S_0$ be the set of all $n-k$ zeros. The choice of a one as a pivot does not separate them. Thus, we only need to consider the first pivot chosen from the set $S_0$. The probability that this pivot is from the set $\\{z_1, z_2\\}$ is $\\frac{2}{|S_0|} = \\frac{2}{n-k}$ (for $n-k \\ge 2$).\n    The expected number of comparisons is $\\binom{n-k}{2} \\times \\frac{2}{n-k} = \\frac{(n-k)(n-k-1)}{2} \\times \\frac{2}{n-k} = n-k-1$. This holds for $n-k \\ge 2$. If $n-k2$, the number of pairs is $0$.\n\n2.  **Pair of two ones $(\\{o_1, o_2\\})$**: The logic is symmetric to the case of two zeros. They are compared if and only if one of them is chosen as pivot before any other one. The probability of comparison is $\\frac{2}{k}$ (for $k \\ge 2$).\n    The expected number of comparisons is $\\binom{k}{2} \\times \\frac{2}{k} = k-1$. This holds for $k \\ge 2$. If $k2$, the number of pairs is $0$.\n\n3.  **Pair of a zero and a one $(\\{z, o\\})$**:\n    -   If a pivot $p=z$ or $p=o$ is chosen, they are compared.\n    -   If any other pivot $p \\neq z, o$ is chosen, they are separated. If $p$ is a zero, $p=z'$, then $z$ goes to the $=p$ partition and $o$ goes to the $p$ partition. If $p$ is a one, $p=o'$, then $z$ goes to the $p$ partition and $o$ goes to the $=p$ partition. In either case, they are separated without comparison.\n    Therefore, $z$ and $o$ are compared if and only if either $z$ or $o$ is the first pivot chosen from the set of all $n$ elements.\n    The probability of this is $P(\\text{pivot is } z) + P(\\text{pivot is } o) = \\frac{1}{n} + \\frac{1}{n} = \\frac{2}{n}$.\n    The expected number of comparisons for these pairs is $(n-k)k \\times \\frac{2}{n}$.\n\nSumming the expected comparisons for Variant B ($1 \\le k \\le n-1$, which implies $n-k \\ge 1, k \\ge 1$):\n$$ E_B(n, k) = (n-k-1) + (k-1) + \\frac{2k(n-k)}{n} = n-2 + \\frac{2k(n-k)}{n} $$\n(Note that if $n-k=1$, $n-k-1=0$, and if $k=1$, $k-1=0$, which is consistent with there being no pairs.)\n\nThe final expressions for the expected number of comparisons are:\nFor Variant A: $E_A(n, k) = \\frac{(n-k)(n-k-1)}{2} + \\frac{k(k-1)}{2} + \\frac{2k(n-k)}{k+1}$\nFor Variant B: $E_B(n, k) = n-2 + \\frac{2k(n-k)}{n}$", "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{(n-k)(n-k-1)}{2} + \\frac{k(k-1)}{2} + \\frac{2k(n-k)}{k+1}  n-2 + \\frac{2k(n-k)}{n} \\end{pmatrix} } $$", "id": "3263576"}, {"introduction": "The divide-and-conquer strategy at the heart of quicksort is more versatile than it first appears. It's not just a tool for sorting but a powerful paradigm for solving other computational problems. This exercise asks you to adapt the quicksort framework to a completely different task: counting the number of inversions in an array [@problem_id:3263559]. This practice will stretch your algorithmic thinking, showing you how to embed new calculations within the partitioning step to solve complex problems efficiently.", "problem": "You are given the task of designing and implementing a randomized divide-and-conquer procedure that modifies the classical randomized quicksort to compute the exact inversion count of an input array of integers. An inversion is defined as a pair of indices $(i,j)$ with $0 \\le i  j  n$ such that $A[i]  A[j]$. The randomized quicksort base selects a pivot uniformly at random from the current subarray, performs a partition in linear time, and recurses on the strict subproblems. Your modification must compute the inversion count for the original array using only the partition-and-recurse structure of randomized quicksort, without introducing any balanced tree, Fenwick tree, merge-based counting, or multiple independent passes beyond what is necessary to partition. The method must be exact.\n\nStart from the following fundamentals:\n- The definition of inversions as pairs $(i,j)$ with $ij$ and $A[i]A[j]$.\n- The linear-time cost of a single partition step in randomized quicksort on a subarray of length $n$.\n- Uniform random pivot selection from the current subarray and the fact that randomized quicksort in expectation produces balanced subproblems.\n- Linearity of expectation for analyzing average-case recurrences.\n\nYour program must implement this modified algorithm and apply it to the following test suite of arrays:\n- $[]$\n- [$1$]\n- [$1$,$2$,$3$,$4$,$5$]\n- [$5$,$4$,$3$,$2$,$1$]\n- [$2$,$3$,$2$,$3$,$2$]\n- [$3$,$-1$,$2$,$2$,$-1$,$3$]\n- [$7$,$1$,$5$,$3$,$6$,$4$,$2$]\n- [$5$,$5$,$5$,$5$]\n\nRequirements:\n- Implement a procedure that uses the randomized quicksort structure to accumulate the inversion count during partitioning and recurses on strict subproblems, ensuring that each inversion is counted exactly once. The randomness used for pivot selection must be uniform over the current subarray and may be seeded for reproducibility, but the returned inversion counts must be exact and independent of the seed.\n- The program must produce a single line of output containing the results as a comma-separated list of integers enclosed in square brackets, in the same order as the test suite, for example, [$a_1$,$a_2$,$\\dots$,$a_k$].\n- There are no physical units or angles involved.\n- The answer type for each test case is an integer.\n\nYour deliverables in this program are the exact inversion counts for the specified arrays, printed in the final output format described above on a single line.", "solution": "The problem requires the design of an algorithm to count the number of inversions in an array of integers, adhering to the structural framework of the randomized quicksort algorithm. An inversion is a pair of indices $(i, j)$ such that $i  j$ and $A[i]  A[j]$, where $A$ is the input array. The solution must be exact and must not use methods such as merge-sort-based counting or auxiliary data structures like Fenwick trees.\n\nThe fundamental principle of a divide-and-conquer algorithm is to break a problem into smaller, independent subproblems, solve them recursively, and then combine their results to obtain the solution to the original problem. For counting inversions, let $I(A)$ be the total number of inversions in an array $A$. If we select a pivot element $p$ from $A$, we can partition the elements of $A$ into three subsets: $S_L = \\{x \\in A \\mid x  p\\}$, $S_E = \\{x \\in A \\mid x = p\\}$, and $S_G = \\{x \\in A \\mid x > p\\}$.\n\nThe total number of inversions can be expressed as the sum of inversions within each of these subsets and the inversions between elements from different subsets:\n$$I(A) = I(S_L) + I(S_E) + I(S_G) + I_{\\text{cross}}$$\nwhere $I(S_L)$, $I(S_E)$, and $I(S_G)$ represent inversions where both elements of the pair belong to the same subset, and $I_{\\text{cross}}$ represents inversions where the two elements belong to different subsets.\n\nThe recursive structure of quicksort naturally handles the inversions within subsets. If we construct arrays $A_L$ and $A_G$ containing the elements of $S_L$ and $S_G$ while preserving their relative order from the original array $A$, their inversion counts can be found by recursive calls: $I(S_L) = \\text{CountInversions}(A_L)$ and $I(S_G) = \\text{CountInversions}(A_G)$. The inversions within $S_E$, $I(S_E)$, must be $0$, as all elements are equal.\n\nThe core of the problem is to count $I_{\\text{cross}}$ efficiently during the partition step. A cross-inversion involves a pair of elements $(u, v)$ such that $u$ and $v$ are separated by the pivot $p$. For an inversion, we must have $u  v$. Given the definitions of $S_L, S_E, S_G$, this can only occur in the following cases for a pair of values $(u, v)$:\n$1$. $u \\in S_G$ and $v \\in S_L$ (since $u  p  v$)\n$2$. $u \\in S_E$ and $v \\in S_L$ (since $u = p  v$)\n$3$. $u \\in S_G$ and $v \\in S_E$ (since $u  p = v$)\n\nA pair of values $(u, v)$ satisfying one of these conditions forms an inversion in the array $A$ if and only if the element $u$ appears at an index $i$ and the element $v$ appears at an index $j$ with $i  j$. A simple multiplication of set sizes like $|S_L| \\times |S_G|$ is incorrect because it does not account for the original positions of the elements.\n\nTo correctly count $I_{\\text{cross}}$, we can perform a single linear scan through the array $A$. During this scan, we can count for each element $A[i]$ how many inversion pairs $(A[j], A[i])$ it forms with preceding elements ($j  i$) that will be separated from it by the pivot.\n\nLet's maintain counts of elements seen so far that are equal to the pivot ($c_E$) and greater than the pivot ($c_G$). As we iterate through the array $A$ from left to right with index $i=0, 1, \\dots, n-1$:\n- If $A[i]  p$: The element $A[i]$ is smaller than any element previously seen that was equal to or greater than $p$. Thus, $A[i]$ forms an inversion with each of these. The number of such inversions is $c_E + c_G$.\n- If $A[i] = p$: The element $A[i]$ is smaller than any element previously seen that was greater than $p$. It forms an inversion with each of these. The number of such inversions is $c_G$. We then increment $c_E$.\n- If $A[i]  p$: The element $A[i]$ is greater than any element previously seen that was less than or equal to $p$, so it cannot form a cross-pivot inversion of the form $(A[j], A[i])$ with $ji$. We then increment $c_G$.\n\nBy summing these counts over the single pass, we compute the total cross-inversion count, $I_{\\text{cross}}$, precisely.\n\nThe complete algorithm is as follows:\n\n`Count-Inversions(A)`\n$1$. If the length of $A$ is less than or equal to $1$, return $0$.\n$2$. Select a pivot $p$ uniformly at random from the elements in $A$.\n$3$. Initialize $I_{\\text{cross}} = 0$, $c_E = 0$, $c_G = 0$.\n$4$. Initialize empty lists $A_L$, $A_G$.\n$5$. For each element $x$ in $A$:\n   a. If $x  p$: $I_{\\text{cross}} \\leftarrow I_{\\text{cross}} + c_E + c_G$. Append $x$ to $A_L$.\n   b. If $x = p$: $I_{\\text{cross}} \\leftarrow I_{\\text{cross}} + c_G$. Increment $c_E$.\n   c. If $x  p$: Increment $c_G$. Append $x$ to $A_G$.\n$6$. Recursively compute $I_L = \\text{Count-Inversions}(A_L)$ and $I_G = \\text{Count-Inversions}(A_G)$.\n$7$. The total number of inversions is $I_L + I_G + I_{\\text{cross}}$. Return this value.\n\nThis algorithm correctly partitions the problem based on a random pivot, mirrors the recursive divide-and-conquer structure of randomized quicksort, and computes the exact inversion count without violating the specified constraints. The average-case time complexity is $O(n \\log n)$, where $n$ is the number of elements in the array, consistent with randomized quicksort.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count_inversions_quicksort(arr: list[int]) - int:\n    \"\"\"\n    Computes the inversion count of an array using a randomized quicksort-based\n    divide-and-conquer approach.\n\n    An inversion is a pair of indices (i, j) such that i  j and arr[i]  arr[j].\n\n    The algorithm works by:\n    1. Selecting a random pivot.\n    2. Partitioning the array into elements less than, equal to, and greater than the pivot.\n    3. Counting \"cross-inversions\" during a single linear scan. A cross-inversion is\n       a pair (u, v) where u and v are separated by the pivot (e.g., u  pivot  v).\n    4. Recursively counting inversions in the \"less than\" and \"greater than\" subarrays.\n    5. Summing the counts from the recursive calls and the cross-inversions.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The total number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n = 1:\n        return 0\n\n    # Step 2: Select a random pivot.\n    # Using np.random.choice as per the execution environment.\n    pivot = np.random.choice(arr)\n\n    # Step 3, 4: Initialize counters and lists for subproblems.\n    cross_inversions = 0\n    count_equal = 0\n    count_greater = 0\n    \n    less_arr = []\n    greater_arr = []\n\n    # Step 5: Perform a single pass to count cross-inversions and create sub-arrays.\n    for x in arr:\n        if x  pivot:\n            # This element x forms an inversion with any preceding element  x that\n            # is separated by the pivot. These are precisely the elements previously\n            # seen that are equal to or greater than the pivot.\n            cross_inversions += count_equal + count_greater\n            less_arr.append(x)\n        elif x == pivot:\n            # This element x forms an inversion with any preceding element  x that\n            # is separated by the pivot. These are the elements greater than the pivot.\n            cross_inversions += count_greater\n            count_equal += 1\n        else:  # x  pivot\n            # This element cannot form a cross-inversion (u, v) with u preceding v,\n            # as any preceding element v belongs to a different partition group only if v = pivot  u.\n            count_greater += 1\n            greater_arr.append(x)\n\n    # Step 6: Recursive calls on strict subproblems.\n    inversions_less = count_inversions_quicksort(less_arr)\n    inversions_greater = count_inversions_quicksort(greater_arr)\n\n    # Step 7: Combine results.\n    return cross_inversions + inversions_less + inversions_greater\n\ndef solve():\n    \"\"\"\n    Runs the inversion counting algorithm on the specified test suite\n    and prints the results in the required format.\n    \"\"\"\n    # Seed for reproducibility. The algorithm is exact and its output\n    # does not depend on the sequence of random pivots.\n    np.random.seed(42)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],\n        [1],\n        [1, 2, 3, 4, 5],\n        [5, 4, 3, 2, 1],\n        [2, 3, 2, 3, 2],\n        [3, -1, 2, 2, -1, 3],\n        [7, 1, 5, 3, 6, 4, 2],\n        [5, 5, 5, 5],\n    ]\n\n    results = []\n    for case in test_cases:\n        # Convert to list for broader compatibility, though the logic works on tuples.\n        arr_list = list(case)\n        result = count_inversions_quicksort(arr_list)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3263559"}]}