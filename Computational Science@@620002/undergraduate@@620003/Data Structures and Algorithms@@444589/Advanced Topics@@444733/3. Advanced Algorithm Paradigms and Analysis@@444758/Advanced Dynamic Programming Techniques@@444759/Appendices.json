{"hands_on_practices": [{"introduction": "Our first practice problem tackles a classic combinatorial task: counting subsets with a specific sum. When the number of elements is small, we can explore every possible subset. This exercise introduces the powerful technique of bitmask DP, where each integer from $0$ to $2^N-1$ represents a unique subset, allowing for a systematic and elegant enumeration to find the solution. [@problem_id:3203681]", "problem": "You are given a finite list of integers $S$ satisfying $|S| \\le 20$. Interpret $S$ as an ordered sequence $S=(s_1,s_2,\\dots,s_n)$ with $n=|S|$, where indices are used to distinguish elements even if their values are equal. An integer target $T$ is also given. Define a subset by its index set $X\\subseteq\\{1,2,\\dots,n\\}$. A subset $X$ is said to realize $T$ if $\\sum_{i\\in X}s_i=T$. Your task is to compute the number of index-distinct subsets $X$ that realize $T$, where each $s_i$ can be used at most once. The input for this task is fixed within the program via a test suite; there is no user input. This is a purely mathematical and algorithmic problem, so no physical units apply.\n\nFundamental base to be used in reasoning: the dynamic programming principle, which starts from the well-tested facts that combinatorial counting over independent choices can be decomposed into subproblems, and that subproblems can be structured by partitioning the choice space. In particular, the relevant base includes the definitions of state spaces, the principle of optimal substructure, and the existence of overlapping subproblems when counting subsets by partial sums.\n\nYour program must evaluate a test suite composed of the following parameter sets $(S,T)$, where $S$ is written as a list and $T$ is written as an integer:\n- Test case $1$: $S=[3,34,4,12,5,2]$, $T=9$.\n- Test case $2$: $S=[0,0,0]$, $T=0$.\n- Test case $3$: $S=[-1,1,2,-2,3]$, $T=0$.\n- Test case $4$: $S=[1,1,1,1]$, $T=2$.\n- Test case $5$: $S=[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]$ (that is, $|S|=20$ and every entry equals $1$), $T=10$.\n- Test case $6$: $S=[5,6,7]$, $T=1$.\n\nYour program should produce a single line of output containing the results for the test suite as a comma-separated list enclosed in square brackets. The $i$-th entry must be the number of index-distinct subsets of $S$ that sum to $T$ for test case $i$. For example, the format must be $[r_1,r_2,r_3,r_4,r_5,r_6]$ where each $r_i$ is an integer.", "solution": "The provided problem is a well-defined combinatorial counting task. It asks for the number of index-distinct subsets of a given sequence of integers $S = (s_1, s_2, \\dots, s_n)$ whose elements sum to a target value $T$. The elements of $S$ are distinguished by their indices, even if their numerical values are identical.\n\nFirst, the problem statement is validated.\n**Step 1: Extracted Givens**\n- An ordered sequence of integers $S=(s_1,s_2,\\dots,s_n)$ with $n=|S|\\le 20$.\n- An integer target $T$.\n- A subset is defined by its index set $X\\subseteq\\{1,2,\\dots,n\\}$.\n- A subset $X$ realizes $T$ if $\\sum_{i\\in X}s_i=T$.\n- The task is to compute the number of such index-distinct subsets $X$.\n- The fundamental base for reasoning is specified as the dynamic programming principle.\n- A fixed test suite of $6$ cases is provided.\n\n**Step 2: Validation of Givens**\nThe problem is scientifically and mathematically sound. It is a variant of the classic Subset Sum Problem, a well-known problem in computer science and mathematics. The problem is self-contained, objective, and unambiguous. The constraint $n \\le 20$ is a critical piece of information that guides the choice of a suitable algorithm. All terms are formally defined. Therefore, the problem is deemed valid.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A reasoned solution follows.\n\n**Principle-Based Solution Derivation**\nThe problem is to count subsets, which suggests a combinatorial approach. For each element $s_i$ in the sequence $S$, we can make a binary choice: either include $s_i$ in our subset or exclude it. This structure of independent choices is a hallmark of problems amenable to dynamic programming.\n\nLet us define a function $C(i, t)$ as the number of subsets of the suffix sequence $(s_i, s_{i+1}, \\dots, s_n)$ that sum to a value $t$. Our goal is to compute $C(1, T)$.\n\nThe decision for element $s_i$ leads to the following recurrence relation:\n1.  **Exclude $s_i$**: If we do not include $s_i$ in our subset, we must find a subset of the remaining elements $(s_{i+1}, \\dots, s_n)$ that sums to the same target $t$. The number of ways to do this is $C(i+1, t)$.\n2.  **Include $s_i$**: If we include $s_i$, we must find a subset of the remaining elements $(s_{i+1}, \\dots, s_n)$ that sums to the adjusted target $t - s_i$. The number of ways is $C(i+1, t - s_i)$.\n\nBy the principle of addition for disjoint choices, the total number of ways is the sum of these two cases:\n$$C(i, t) = C(i+1, t) + C(i+1, t - s_i)$$\n\nThe base cases for the recursion are:\n-   If $t=0$, we have found a valid combination of elements. We count this as $1$ solution. This signifies that the choices made up to this point result in the desired sum. (Note: A more rigorous base case is at the end of the sequence).\n-   A more formal set of base cases occurs when we have considered all elements (i.e., when $i > n$):\n    -   $C(n+1, 0) = 1$ (The empty set sums to $0$, representing a successful path).\n    -   $C(n+1, t) = 0$ for $t \\neq 0$ (We have failed to reach the target sum of $0$).\n\nThis recursive formulation has overlapping subproblems, as the same state $(i, t)$ can be reached through different sequences of choices. A direct implementation would be inefficient. We can use memoization (a top-down dynamic programming approach) to store and reuse the results for each state $(i, t)$. The complexity of this approach is proportional to the number of states, which is approximately $O(n \\cdot \\Delta)$, where $\\Delta$ is the range of possible intermediate target values. While often efficient, this pseudo-polynomial complexity can be problematic if the values in $S$, and thus $\\Delta$, are large.\n\nHowever, the problem provides a crucial constraint: $|S| = n \\le 20$. This constraint makes an exponential-time complexity solution in $n$ feasible. Specifically, an algorithm with complexity $O(n \\cdot 2^n)$ is acceptable. For $n=20$, $2^{20} \\approx 10^6$, and $20 \\cdot 2^{20} \\approx 2 \\cdot 10^7$, which is well within the limits of modern processors.\n\nThis leads to a second, more direct approach that leverages the small value of $n$, often categorized under \"bitmask DP\". We can represent each of the $2^n$ possible subsets of indices using an $n$-bit integer, called a bitmask. For a mask $m$, if the $j$-th bit is set to $1$, it signifies that the element $s_{j+1}$ is included in the subset; if the bit is $0$, it is excluded.\n\nThe algorithm is as follows:\n1.  Initialize a counter for valid subsets to $0$.\n2.  Iterate through all integers $m$ from $0$ to $2^n - 1$. Each integer $m$ is a bitmask representing a unique subset of $S$.\n3.  For each mask $m$, calculate the sum of the corresponding subset. This is done by iterating from $j=0$ to $n-1$: if the $j$-th bit of $m$ is set, add $s_{j+1}$ to a running `current_sum`.\n4.  If the `current_sum` equals the target $T$, increment the counter.\n5.  After checking all $2^n$ masks, the value of the counter is the final answer.\n\nThis approach exhaustively checks every subset. It can be viewed as a bottom-up dynamic programming approach where we compute the sum for every possible subset. The sum for a subset (mask) can be derived from the sum of a smaller subset (sub-mask), e.g., $\\text{sum}[\\text{mask}] = \\text{sum}[\\text{mask\\_without\\_lowest\\_bit}] + s[\\text{lowest\\_bit\\_index}]$. However, a direct loop-based calculation of each sum is just as efficient and simpler to implement. Given the problem's hint towards \"bitmask dp\" and the constraint $n \\le 20$, this bitmask-based enumeration is the most direct and robust method.\n\nFor example, for $S=[1,1,1,1]$ and $T=2$ ($n=4$), we need to find subsets that sum to $2$. This is equivalent to choosing exactly two elements since all values are $1$. The number of ways to choose $2$ indices from $4$ is $\\binom{4}{2}=6$. The bitmask approach will iterate from $m=0$ (`0000` in binary) to $m=15$ (`1111`). It will find that the masks with exactly two bits set (`0011`, `0101`, `0110`, `1001`, `1010`, `1100`) correspond to subsets whose elements sum to $2$, yielding the correct count of $6$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # S (list of integers), T (target integer)\n        ([3, 34, 4, 12, 5, 2], 9),\n        ([0, 0, 0], 0),\n        ([-1, 1, 2, -2, 3], 0),\n        ([1, 1, 1, 1], 2),\n        ([1] * 20, 10),\n        ([5, 6, 7], 1),\n    ]\n\n    results = []\n    for s_list, t_target in test_cases:\n        # Calculate the number of subsets for the current case.\n        result = count_subsets_with_sum(s_list, t_target)\n        results.append(result)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef count_subsets_with_sum(S, T):\n    \"\"\"\n    Computes the number of index-distinct subsets of S that sum to T.\n\n    This function uses a bitmasking approach to iterate through all possible\n    subsets of S. Given that |S| is at most 20, the total number of subsets\n    is at most 2^20, which is computationally feasible.\n\n    Args:\n        S: A list of integers.\n        T: The target integer sum.\n\n    Returns:\n        The number of subsets of S that sum to T.\n    \"\"\"\n    n = len(S)\n    if n > 20:\n        # This implementation is only efficient for n = 20.\n        # A different DP approach would be needed for larger n.\n        raise ValueError(\"Input list S is too large for this method.\")\n\n    count = 0\n    num_subsets = 1  n  # This is equivalent to 2**n\n\n    # Iterate through all possible subsets using a bitmask from 0 to 2^n - 1.\n    for i in range(num_subsets):\n        current_sum = 0\n        # For each subset, calculate its sum.\n        for j in range(n):\n            # Check if the j-th element is in the current subset.\n            # This is done by checking if the j-th bit of i is set.\n            if (i >> j)  1:\n                current_sum += S[j]\n        \n        # If the sum of the subset equals the target, increment the count.\n        if current_sum == T:\n            count += 1\n            \n    return count\n\n# Run the solver.\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3203681"}, {"introduction": "Next, we shift our focus from simple sets to the hierarchical structure of trees. This problem asks us to count valid colorings, a task perfectly suited for Tree DP. By rooting the tree and performing a post-order traversal, we can compute the number of ways to color each subtree, with the solution for a parent node being a function of the combined solutions from its children. [@problem_id:3203686]", "problem": "You are given a finite, simple, connected, undirected graph that is a tree with $N$ vertices labeled $1$ through $N$. Let the set of edges be a collection of unordered pairs $\\{(u,v)\\}$ with $u \\in \\{1,\\dots,N\\}$ and $v \\in \\{1,\\dots,N\\}$ such that the graph contains exactly $N-1$ edges, is connected, and has no cycles. You are also given an integer $K \\ge 1$ representing the number of available colors, with color indices taken as $\\{0,1,\\dots,K-1\\}$. For each vertex $i$, you are given an allowed color set encoded as a nonnegative integer mask $M_i$ in which the $j$-th bit (the bit for color $j$) is $1$ if and only if color $j$ is allowed at vertex $i$ and is $0$ otherwise. A vertex coloring function is a mapping $c:\\{1,\\dots,N\\} \\to \\{0,1,\\dots,K-1\\}$. A coloring is proper if for every edge $(u,v)$, the property $c(u) \\ne c(v)$ holds, and is admissible if for every vertex $i$, the assigned color $c(i)$ is allowed by its mask $M_i$ (i.e., the $c(i)$-th bit of $M_i$ is 1). Your task is to compute the number of colorings $c$ that are both proper and admissible, under modular arithmetic with modulus $10^9 + 7$, denoted as $1000000007$, and to output the value as an integer.\n\nThe fundamental base for this computation is the definition of a tree, the definition of a proper coloring, and the counting principles of combinations of independent choices in a product of independent factors. Specifically, for a rooted tree, conditioning on the color of a node, the subtrees of its children become independent with respect to admissible proper colorings, and the count for the whole subtree is the product of the counts of admissible choices for each child subtree that do not re-use the parent color.\n\nImplement a program that solves the problem for the following test suite. Each test case consists of the parameters $(N,K,\\text{edges},\\text{masks})$, where $\\text{edges}$ is a list of pairs of vertex labels and $\\text{masks}$ is a list of $N$ integers $M_i$. All vertex labels and integers are written explicitly below:\n- Test case $1$: $N=1$, $K=3$, $\\text{edges}=[\\,]$, $\\text{masks}=[\\,7\\,]$. Here, $7$ encodes allowed colors $\\{0,1,2\\}$ for the single vertex.\n- Test case $2$: $N=3$, $K=2$, $\\text{edges}=[\\,(1,2),(2,3)\\,]$, $\\text{masks}=[\\,3,3,3\\,]$. Here, $3$ encodes allowed colors $\\{0,1\\}$ at each vertex.\n- Test case $3$: $N=4$, $K=3$, $\\text{edges}=[\\,(1,2),(1,3),(1,4)\\,]$, $\\text{masks}=[\\,7,7,7,7\\,]$. This is a star with center at vertex $1$ and all colors allowed at all vertices.\n- Test case $4$: $N=4$, $K=3$, $\\text{edges}=[\\,(1,2),(2,3),(3,4)\\,]$, $\\text{masks}=[\\,3,6,5,7\\,]$. The masks encode allowed sets: vertex $1$ has $\\{0,1\\}$, vertex $2$ has $\\{1,2\\}$, vertex $3$ has $\\{0,2\\}$, vertex $4$ has $\\{0,1,2\\}$.\n- Test case $5$: $N=2$, $K=1$, $\\text{edges}=[\\,(1,2)\\,]$, $\\textmasks}=[\\,1,1\\,]$. A single color is available and both vertices allow it.\n- Test case $6$: $N=5$, $K=4$, $\\text{edges}=[\\,(1,2),(1,3),(3,4),(3,5)\\,]$, $\\text{masks}=[\\,15,10,13,3,12\\,]$. The masks encode allowed sets: vertex $1$ has $\\{0,1,2,3\\}$, vertex $2$ has $\\{1,3\\}$, vertex $3$ has $\\{0,2,3\\}$, vertex $4$ has $\\{0,1\\}$, vertex $5$ has $\\{2,3\\}$.\n\nYour program should compute the number of proper and admissible colorings for each test case, each count taken modulo $1000000007$. The final output format must be a single line containing the results for the test cases, in order, as a comma-separated list enclosed in square brackets, for example, $\\left[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_6\\right]$. No physical units apply in this problem. Angles and percentages do not apply. The output for each test case must be an integer.", "solution": "The user wants a solution to a graph coloring counting problem, which I must first validate.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Graph Structure**: A finite, simple, connected, undirected graph which is a tree with $N$ vertices labeled $1$ to $N$.\n- **Number of Colors**: An integer $K \\ge 1$, with colors indexed from $0$ to $K-1$.\n- **Per-Vertex Color Constraints**: For each vertex $i$, an integer mask $M_i$ specifies the set of allowed colors. The $j$-th bit of $M_i$ is $1$ if color $j$ is allowed for vertex $i$.\n- **Proper Coloring**: For any edge $(u,v)$, the colors assigned must be different, i.e., $c(u) \\neq c(v)$.\n- **Admissible Coloring**: For any vertex $i$, the assigned color $c(i)$ must be in its allowed set, i.e., the $c(i)$-th bit of $M_i$ must be $1$.\n- **Objective**: Compute the total number of colorings that are both proper and admissible, modulo $10^9 + 7$.\n- **Test Cases**: Six specific instances of $(N, K, \\text{edges}, \\text{masks})$ are provided for which the calculation must be performed.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientific Grounding**: The problem is rooted in graph theory and discrete mathematics, specifically concerning graph coloring on trees. All concepts (trees, coloring, modular arithmetic, bitmask representation) are standard and mathematically sound. The problem is a variant of counting chromatic polynomials with added per-vertex constraints.\n- **Well-Posedness**: The problem is well-posed. For a finite tree and a finite color set, the number of possible colorings is finite. The problem asks for a specific integer count under clear, unambiguous constraints, ensuring a unique solution exists for each test case.\n- **Objectivity**: The problem is stated using precise mathematical definitions and objective numerical data. There is no ambiguity or subjective language.\n- **Completeness and Consistency**: Each test case provides all necessary data ($N, K$, edges, masks). The properties of a tree ($N-1$ edges, connected) are explicitly stated, ensuring consistency.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is a standard algorithmic problem in computer science that can be solved using dynamic programming on trees.\n\n---\n\n### Solution Derivation\n\nThe problem asks for the number of ways to color a tree such that for every vertex, its color is chosen from a specific set of allowed colors, and for every edge, the two connected vertices have different colors. This problem is a classic application of Tree Dynamic Programming.\n\n**1. Formalizing the Problem**\nLet the tree be $T=(V, E)$, where $V=\\{1, \\dots, N\\}$ is the set of vertices and $E$ is the set of edges. Let the set of available colors be $C = \\{0, 1, \\dots, K-1\\}$. For each vertex $i \\in V$, the set of admissible colors is $A_i = \\{j \\in C \\mid ((M_i \\gg j) \\ 1) = 1 \\}$. We seek the number of functions $c: V \\to C$ such that:\n$1$.  **Admissibility**: $\\forall i \\in V, c(i) \\in A_i$.\n$2$.  **Properness**: $\\forall (u, v) \\in E, c(u) \\neq c(v)$.\n\n**2. Dynamic Programming on a Tree**\nThe tree structure is key. If we root the tree at an arbitrary vertex, say vertex $1$, we can define subproblems on the subtrees. The coloring choices for disjoint subtrees become independent once the color of their common parent is fixed. This motivates a dynamic programming approach.\n\nLet's define the DP state. For each vertex $u \\in V$ and each color $j \\in C$, let $dp[u][j]$ be the number of ways to color the subtree rooted at $u$ (including $u$ itself) such that vertex $u$ is assigned color $j$, and the coloring of the entire subtree is proper and admissible.\n\nThe DP values are computed using a post-order traversal (from leaves up to the root).\n\n**3. DP State Transition**\n\n**Base Case (Leaf Nodes):**\nA leaf node $u$ has no children. Its subtree consists only of itself. The only constraints are on the color of $u$. Thus, we can color $u$ with color $j$ in exactly one way if $j$ is an admissible color for $u$.\n$$\ndp[u][j] = \\begin{cases} 1  \\text{if } j \\in A_u \\\\ 0  \\text{if } j \\notin A_u \\end{cases}\n$$\n\n**Recursive Step (Internal Nodes):**\nFor an internal node $u$, let its children in the rooted tree be $v_1, v_2, \\dots, v_m$. To calculate $dp[u][j]$, we first check if color $j$ is admissible for $u$. If $j \\notin A_u$, then $dp[u][j] = 0$.\nIf $j \\in A_u$, we must color the subtrees of its children. For any child $v_i$, it must be colored with any admissible color $k$ as long as $k \\neq j$. The number of ways to color the subtree of $v_i$ under this constraint is the sum of $dp[v_i][k]$ over all valid colors $k \\neq j$.\n$$\n\\text{Ways for child } v_i = \\sum_{k \\in C, k \\neq j} dp[v_i][k]\n$$\nSince the coloring choices for the subtrees of different children are independent of each other (once the parent's color $j$ is fixed), we multiply the number of ways for each child's subtree.\n$$\ndp[u][j] = \\prod_{i=1}^{m} \\left( \\sum_{k \\in C, k \\neq j} dp[v_i][k] \\right) \\pmod{1000000007}\n$$\nFor computational efficiency, the sum can be calculated as:\n$$\n\\sum_{k \\in C, k \\neq j} dp[v_i][k] = \\left( \\left(\\sum_{k \\in C} dp[v_i][k]\\right) - dp[v_i][j] \\right) \\pmod{1000000007}\n$$\nThis avoids a loop of size $K$ for each child and each parent color, reducing the complexity of the transition.\n\n**4. Final Calculation**\nThe computation can be implemented with a single Depth-First Search (DFS) starting from the root. The DFS function processes a node after all its children have been processed. Once the DFS completes and the DP table is filled for all nodes, the total number of valid colorings for the entire tree is the sum of the DP values for the root node over all its possible colors. Let vertex $r$ be the root.\n$$\n\\text{Total Colorings} = \\sum_{j \\in C} dp[r][j] \\pmod{1000000007}\n$$\nAll arithmetic operations (addition, subtraction, multiplication) are performed modulo $10^9 + 7$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Set a higher recursion limit for deep trees, although not strictly necessary for the given test cases.\n    # The default is often 1000, which is sufficient here.\n    sys.setrecursionlimit(2000)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 3, [], [7]),\n        (3, 2, [(1, 2), (2, 3)], [3, 3, 3]),\n        (4, 3, [(1, 2), (1, 3), (1, 4)], [7, 7, 7, 7]),\n        (4, 3, [(1, 2), (2, 3), (3, 4)], [3, 6, 5, 7]),\n        (2, 1, [(1, 2)], [1, 1]),\n        (5, 4, [(1, 2), (1, 3), (3, 4), (3, 5)], [15, 10, 13, 3, 12]),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_colorings(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_colorings(case):\n    \"\"\"\n    Calculates the number of proper, admissible colorings for a single test case.\n    \"\"\"\n    N, K, edges, masks = case\n    MOD = 1000000007\n\n    # Handle the trivial case of a single vertex.\n    if N == 1:\n        mask = masks[0]\n        # Count the number of set bits in the mask, which corresponds to the number of allowed colors.\n        return bin(mask).count('1')\n\n    # Build adjacency list for the tree. Vertices are 1-based in the input,\n    # so we convert them to 0-based indices.\n    adj = [[] for _ in range(N)]\n    for u, v in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    # DP table: dp[u][c] stores the number of ways to color the subtree at u\n    # with color c. Initialize with -1 to mark as uncomputed.\n    dp = np.full((N, K), -1, dtype=np.int64)\n\n    def dfs(u, p):\n        \"\"\"\n        Performs a post-order traversal to compute DP values.\n        u: current vertex (0-indexed)\n        p: parent of u (0-indexed), -1 for root\n        \"\"\"\n        # Memoization check: if already computed for u, return.\n        if dp[u, 0] != -1:\n            return\n\n        # Initialize DP values for u as if it's a leaf.\n        # dp[u][c] = 1 if color c is admissible, 0 otherwise.\n        for c in range(K):\n            if (masks[u] >> c)  1:\n                dp[u, c] = 1\n            else:\n                dp[u, c] = 0\n\n        # Recursively call DFS on children and update DP values for u.\n        for v in adj[u]:\n            if v == p:\n                continue\n            \n            dfs(v, u) # This populates dp[v]\n            \n            # Sum of ways for the child v over all its possible colors.\n            # This sum is used to efficiently calculate the ways for v to avoid parent's color.\n            child_sum = np.sum(dp[v, :]) % MOD\n            \n            # Update dp[u][c_u] by multiplying with the number of ways to color child v's subtree.\n            for c_u in range(K):\n                # If color c_u is not admissible for u, ways are 0.\n                if dp[u, c_u] == 0:\n                    continue\n                \n                # Number of ways to color child v's subtree, given u is colored with c_u.\n                # child_v can take any color except c_u.\n                child_ways = (child_sum - dp[v, c_u]) % MOD\n                # Handle Python's negative result for modulo\n                if child_ways  0:\n                    child_ways += MOD\n                \n                # Since children's colorings are independent, we multiply their counts.\n                dp[u, c_u] = (dp[u, c_u] * child_ways) % MOD\n\n    # Start the DFS from an arbitrary root, here vertex 0.\n    # The parent of the root is marked as -1.\n    dfs(0, -1)\n    \n    # The total number of colorings is the sum of possibilities for the root node over all colors.\n    total_ways = np.sum(dp[0, :]) % MOD\n    return int(total_ways)\n\nsolve()\n```", "id": "3203686"}, {"introduction": "This final exercise deepens our understanding of Tree DP with a more challenging counting problem. Here, we must count all connected subgraphs of a specific size, which requires a more sophisticated state transition than simple coloring. The solution involves a 'knapsack-style' DP on the tree, where we combine subproblems from children in a combinatorial fashion to build up solutions for the parent. [@problem_id:3203742]", "problem": "You are given an undirected tree $G=(V,E)$ with $|V|=N$ vertices labeled from $1$ to $N$, and $|E|=N-1$ edges. A tree is defined as a connected, acyclic graph. For an integer $K$, a connected subgraph of size exactly $K$ is defined as a subset of vertices $S \\subseteq V$ with $|S|=K$ such that the subgraph induced by $S$ is connected (that is, for every pair of vertices in $S$, there is a path entirely within $S$ connecting them). The task is to count the number of distinct connected induced subgraphs of size exactly $K$. All counts are pure integers with no physical units.\n\nBase principles to rely on:\n- The definition of a tree: a connected, acyclic, undirected graph.\n- The property of trees that between any two vertices there exists a unique simple path.\n- The concept of an induced subgraph: for $S \\subseteq V$, the induced subgraph on $S$ contains all vertices in $S$ and all edges $(u,v) \\in E$ such that $u \\in S$ and $v \\in S$.\n\nYour program must compute the count for each of the following test cases. Each test case is specified by $N$, $K$, and a set of edges. Vertices are labeled from $1$ to $N$.\n\nTest suite:\n1. Case $\\mathrm{A}$: $N=7$, $K=3$, edges $\\{(1,2),(1,3),(2,4),(2,5),(3,6),(3,7)\\}$.\n2. Case $\\mathrm{B}$: $N=5$, $K=2$, edges $\\{(1,2),(2,3),(3,4),(4,5)\\}$.\n3. Case $\\mathrm{C}$: $N=5$, $K=3$, edges $\\{(1,2),(1,3),(1,4),(1,5)\\}$.\n4. Case $\\mathrm{D}$: $N=1$, $K=1$, edges $\\{\\}$.\n5. Case $\\mathrm{E}$: $N=3$, $K=0$, edges $\\{(1,2),(2,3)\\}$. For $K=0$, the count is defined to be $0$ since no non-empty connected subgraph has size $0$.\n6. Case $\\mathrm{F}$: $N=6$, $K=6$, edges $\\{(1,2),(2,3),(3,4),(4,5),(5,6)\\}$.\n7. Case $\\mathrm{G}$: $N=4$, $K=5$, edges $\\{(1,2),(1,3),(1,4)\\}$. For $K>N$, the count is defined to be $0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,\\dots]$), where $r_i$ is the integer count for the $i$-th test case in the order listed above. No other output should be produced. No angles or physical units are involved in this task. All outputs are integers.", "solution": "The problem as stated is a well-defined combinatorial counting problem in the domain of graph theory. All terms are standard, and the test cases are consistent and verifiable. The problem is valid and can be solved using established algorithmic techniques.\n\nThe task is to count the number of distinct connected induced subgraphs of a given size $K$ in a tree $G=(V, E)$, where $|V|=N$. A brute-force check of all $\\binom{N}{K}$ vertex subsets is computationally prohibitive. The tree structure of the graph suggests a dynamic programming approach on the tree, often referred to as Tree DP.\n\nA fundamental property of a connected subgraph $S$ within a tree $G$ is that $S$ is itself a tree. If we root the main tree $G$ at an arbitrary vertex $r$, any connected subgraph $S$ will possess a unique \"highest\" vertex, which is the vertex in $S$ that is an ancestor of all other vertices in $S$ with respect to the root $r$. This unique vertex can be designated as the \"root\" of the subgraph $S$.\n\nThis observation allows us to partition the set of all connected subgraphs based on their unique root, ensuring that each subgraph is counted exactly once. The total count is the sum, over all vertices $u \\in V$, of the number of connected subgraphs of size $K$ that are rooted at $u$.\n\nWe formulate a dynamic programming state to compute these counts. Let's fix an arbitrary root for the entire tree $G$, for instance, vertex $1$. We will then perform a post-order traversal (DFS) from this root. For each vertex $u$, our DP state will capture information about subgraphs rooted at $u$.\n\nLet $dp[u][k]$ denote the number of connected subgraphs of size $k$ that are entirely contained within the subtree of $G$ rooted at $u$ and which themselves are rooted at $u$.\n\nThe DP values are computed via a post-order traversal:\n\n**Base Case:** For any leaf vertex $u$, the only connected subgraph rooted at $u$ within its own subtree is the one consisting of a single vertex, $\\{u\\}$. Therefore, $dp[u][1] = 1$, and $dp[u][k] = 0$ for all $k > 1$.\n\n**Recursive Step:** For an internal vertex $u$, we initialize its DP table based on the subgraph containing only itself: $dp[u][1] = 1$ and $dp[u][k] = 0$ for $k > 1$. We then iterate through each of its children, say $v_i$, and merge the DP information from the child's subtree into the parent's DP table.\n\nWhen processing a child $v_i$, we have already computed its DP table $dp[v_i]$. A new, larger connected subgraph rooted at $u$ can be formed by combining an existing connected subgraph of size $k_1$ rooted at $u$ (constructed using $u$ and its previously processed children) with a connected subgraph of size $k_2$ rooted at $v_i$. The connection is established via the edge $(u, v_i)$. The resulting subgraph is rooted at $u$ and has a new size of $k_1 + k_2$. The number of ways to form such a subgraph is the product $dp[u][k_1] \\times dp[v_i][k_2]$.\n\nThis combination process is performed for each child sequentially. Let $dp_{u, \\text{old}}$ be the DP array for $u$ before merging child $v_i$. The new DP array, $dp_{u, \\text{new}}$, is computed as follows:\n$$dp_{u, \\text{new}}[k] = dp_{u, \\text{old}}[k] + \\sum_{k_1+k_2=k} dp_{u, \\text{old}}[k_1] \\times dp_{v_i}[k_2]$$\nThe first term, $dp_{u, \\text{old}}[k]$, accounts for subgraphs rooted at $u$ that do not include any vertices from the subtree of $v_i$. The summation accounts for new subgraphs formed by including a connected component from $v_i$'s subtree.\n\nAfter the post-order traversal completes, the $dp[u][k]$ table is finalized for every vertex $u$. The total number of connected subgraphs of size $K$ in the entire tree is the sum over all possible roots: $\\sum_{u \\in V} dp[u][K]$.\n\nThe time complexity is dominated by the DP merge operations. At each edge $(u, v)$ in the traversal, we perform an operation analogous to a convolution of two arrays of sizes proportional to the respective subtree sizes. The sum of these products of subtree sizes over all edges of a tree is bounded by $O(N^2)$. The space complexity is $O(N^2)$ to store the DP tables for all $N$ vertices, where each table can have up to $N+1$ entries.\n\nSpecial cases where $K=0$ or $K>N$ are handled directly as per the problem statement, with the count being $0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# It is good practice to increase the recursion limit for deep trees,\n# although not strictly necessary for the small N in the test cases.\nsys.setrecursionlimit(2000)\n\ndef count_connected_subgraphs(N, K, edges):\n    \"\"\"\n    Calculates the number of connected induced subgraphs of size K in a tree.\n\n    Args:\n        N (int): The number of vertices in the tree.\n        K (int): The desired size of the connected subgraphs.\n        edges (list of tuples): A list of edges defining the tree.\n\n    Returns:\n        int: The number of distinct connected subgraphs of size K.\n    \"\"\"\n    if K == 0 or K > N:\n        return 0\n    if N == 0:\n        return 0\n    # A single vertex graph.\n    if not edges:\n        return 1 if N == 1 and K == 1 else 0\n\n    adj = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # dp[u][k] stores the number of connected subgraphs of size k\n    # in the subtree of u, with u as the root of the subgraph.\n    # We use np.int64 to prevent potential integer overflow with larger N.\n    dp = np.zeros((N + 1, N + 1), dtype=np.int64)\n\n    def dfs(u, p):\n        \"\"\"\n        Performs a post-order traversal to compute the DP tables.\n\n        Args:\n            u (int): The current vertex.\n            p (int): The parent of the current vertex in the DFS traversal.\n\n        Returns:\n            int: The size of the subtree rooted at u.\n        \"\"\"\n        # Base case for the DP: the subgraph with only vertex u.\n        dp[u][1] = 1\n        current_size = 1\n        \n        for v in adj[u]:\n            if v == p:\n                continue\n            \n            child_size = dfs(v, u)\n            \n            # This temporary array holds the new DP values for u after merging child v.\n            # This corresponds to the polynomial multiplication: P_u_new = P_u_old * (1 + P_v),\n            # where P(x) is the generating function for the DP counts.\n            temp_dp_u = dp[u].copy()\n\n            for k1 in range(1, current_size + 1):\n                if dp[u][k1] == 0:\n                    continue\n                for k2 in range(1, child_size + 1):\n                    if dp[v][k2] == 0:\n                        continue\n                    if k1 + k2 = N:\n                        # Combine a component of size k1 from u's current set\n                        # with a component of size k2 from v's subtree.\n                        temp_dp_u[k1 + k2] += dp[u][k1] * dp[v][k2]\n\n            dp[u] = temp_dp_u\n            current_size += child_size\n        \n        return current_size\n\n    # Start DFS from an arbitrary root (vertex 1), with a dummy parent 0.\n    dfs(1, 0)\n\n    # The total count is the sum of dp[u][K] over all possible subgraph roots u.\n    total_count = np.sum(dp[:, K])\n    \n    return total_count\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, printing the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case A: N=7, K=3, edges={(1,2),(1,3),(2,4),(2,5),(3,6),(3,7)}\n        (7, 3, [(1,2),(1,3),(2,4),(2,5),(3,6),(3,7)]),\n        # Case B: N=5, K=2, edges={(1,2),(2,3),(3,4),(4,5)}\n        (5, 2, [(1,2),(2,3),(3,4),(4,5)]),\n        # Case C: N=5, K=3, edges={(1,2),(1,3),(1,4),(1,5)}\n        (5, 3, [(1,2),(1,3),(1,4),(1,5)]),\n        # Case D: N=1, K=1, edges={}\n        (1, 1, []),\n        # Case E: N=3, K=0, edges={(1,2),(2,3)}\n        (3, 0, [(1,2),(2,3)]),\n        # Case F: N=6, K=6, edges={(1,2),(2,3),(3,4),(4,5),(5,6)}\n        (6, 6, [(1,2),(2,3),(3,4),(4,5),(5,6)]),\n        # Case G: N=4, K=5, edges={(1,2),(1,3),(1,4)}\n        (4, 5, [(1,2),(1,3),(1,4)])\n    ]\n    \n    results = []\n    for N, K, edges in test_cases:\n        result = count_connected_subgraphs(N, K, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3203742"}]}