{"hands_on_practices": [{"introduction": "The median-of-medians algorithm's efficiency hinges on a clever recursive structure. Before analyzing its performance, we must first understand how it constructs its subproblems. This exercise [@problem_id:3250861] tests your grasp of the relationship between the input size $n$, the group size $g$, and the size of the initial recursive call made on the array of medians, providing a crucial first step in understanding the algorithm's mechanics.", "problem": "Consider the deterministic linear-time selection procedure commonly known as Median-of-Medians (MoM). Given an input array of $n$ elements, the procedure partitions the array into contiguous groups of fixed size $g=5$, except possibly the last group, which may contain $s$ elements with $1 \\leq s \\leq 5$. For each group of size $s$, define its median to be the $\\lceil s/2 \\rceil$-th smallest element in that group, and collect one such median from every group into a separate auxiliary array, denoted by $M$. The size of $M$ equals the number of groups formed in the partitioning.\n\nStarting strictly from the definitions above, determine the smallest integer $n$ such that the size of the auxiliary array $M$ is greater than or equal to the group size $g=5$. Provide the exact integer value for $n$.", "solution": "### Solution\nThe problem asks for the smallest integer $n$ such that a specific condition is met. Let's analyze the components of this condition.\n\nThe input array has $n$ elements. It is partitioned into groups of size $g=5$. The last group may be smaller. Let $k$ be the total number of groups created. The number of groups $k$ is determined by the total number of elements $n$ and the group size $g$. Specifically, if we divide the $n$ elements into groups of size $g$, the number of groups will be the total number of elements divided by the group size, rounded up to the nearest integer. This is mathematically represented by the ceiling function:\n$$k = \\left\\lceil \\frac{n}{g} \\right\\rceil$$\n\nAccording to the problem statement, the auxiliary array $M$ contains one median from every group. Therefore, the size of $M$, which we can denote as $|M|$, is equal to the number of groups, $k$.\n$$|M| = k$$\n\nThe problem requires us to find the smallest integer $n$ such that the size of the auxiliary array $M$ is greater than or equal to the group size $g$. This condition can be written as:\n$$|M| \\geq g$$\n\nSubstituting $|M|=k$ and $k=\\lceil n/g \\rceil$, we get the inequality:\n$$\\left\\lceil \\frac{n}{g} \\right\\rceil \\geq g$$\n\nWe are given that the group size is $g=5$. Substituting this value into the inequality:\n$$\\left\\lceil \\frac{n}{5} \\right\\rceil \\geq 5$$\n\nWe need to find the smallest integer $n$ that satisfies this inequality. Let's analyze the properties of the ceiling function. The expression $\\lceil x \\rceil \\geq C$ for an integer $C$ is equivalent to the strict inequality $x > C-1$. If $x$ were equal to $C-1$, $\\lceil x \\rceil$ would be $C-1$. For $\\lceil x \\rceil$ to be at least $C$, $x$ must be strictly greater than $C-1$.\n\nApplying this property to our inequality, where $x = n/5$ and $C=5$:\n$$\\frac{n}{5} > 5 - 1$$\n$$\\frac{n}{5} > 4$$\n\nTo solve for $n$, we multiply both sides of the inequality by $5$:\n$$n > 20$$\n\nSince $n$ represents the number of elements in an array, it must be an integer. The problem asks for the smallest integer $n$ that satisfies the condition $n > 20$. The smallest integer greater than $20$ is $21$.\n\nTherefore, the smallest integer value for $n$ is $21$.\n\nWe can verify this result:\n- If $n=20$, the number of groups is $k = \\lceil 20/5 \\rceil = \\lceil 4 \\rceil = 4$. The condition $k \\geq 5$ is not met, since $4 < 5$.\n- If $n=21$, the number of groups is $k = \\lceil 21/5 \\rceil = \\lceil 4.2 \\rceil = 5$. The condition $k \\geq 5$ is met, since $5=5$.\n\nThus, the smallest integer $n$ for which the number of groups is at least $5$ is indeed $21$.", "answer": "$$\\boxed{21}$$", "id": "3250861"}, {"introduction": "The genius of the median-of-medians algorithm is its guarantee of a \"good enough\" pivot, which prevents the worst-case $O(n^2)$ performance of naive quickselect. To truly appreciate this guarantee, it is instructive to explore its limits. In this practice [@problem_id:3250877], you will act as an adversary to construct an input array that forces the algorithm into its most unbalanced, yet still linear-time, partition, making the abstract performance analysis tangible and concrete.", "problem": "Consider the deterministic linear-time selection algorithm commonly known as the median-of-medians method. The algorithm operates by partitioning an input array into groups of equal size, computing medians of each group, selecting the median of these medians as a pivot, and performing a partition around this pivot; it then recurses on one side depending on the rank of the desired order statistic. For group size $5$, the analysis of the algorithm’s correctness and running time depends on counting how many elements are guaranteed to be strictly less than and strictly greater than the pivot selected as the median of medians.\n\nYou are to construct an explicit input array $A$ of size $n=25$ with distinct integers, arranged to force the algorithm’s partition step to produce the largest possible recursive subproblem under the standard grouping by contiguous blocks of size $5$ in the given array order. Your construction must follow these structural constraints:\n\n- Partition $A$ into the five contiguous groups $G_1, G_2, G_3, G_4, G_5$, each of size $5$, in the array order.\n- Within each $G_i$, the median (the third smallest element of the group) must be well-defined and distinct across groups.\n- The median-of-medians pivot $p$ must be the median of the five group medians, obtained by sorting the five medians and taking the third smallest.\n\nDesign $A$ so that, after partitioning around $p$, the number of elements strictly less than $p$ is minimized while still satisfying the guarantees implied by the algorithm’s grouping and pivot selection, and the remaining elements are placed adversarially to maximize the size of the larger recursive subarray. Explicitly provide the five groups $G_1, G_2, G_3, G_4, G_5$ you constructed, and justify that the median-of-medians pivot is indeed $p$ as intended.\n\nFinally, compute the exact size of the larger recursive subarray that results from your construction after the partition step around $p$. Report only this size as your final numerical answer. Your numerical answer should be exact; do not round.", "solution": "The objective is to construct an array $A$ of $n=25$ distinct integers that, when processed by the median-of-medians algorithm with a group size of $5$, maximizes the size of the larger of the two subarrays for the recursive call. This corresponds to finding an adversarial input that forces the most unbalanced partition allowed by the algorithm's guarantees.\n\nThe algorithm proceeds as follows:\n1.  The input array $A$ of size $n=25$ is divided into $\\lceil n/5 \\rceil = \\lceil 25/5 \\rceil = 5$ contiguous groups, $G_1, G_2, G_3, G_4, G_5$, each of size $5$.\n2.  For each group $G_i$, its median $m_i$ is computed. This results in a set of $5$ medians, $\\{m_1, m_2, m_3, m_4, m_5\\}$.\n3.  The algorithm finds the median of these medians, which we denote as the pivot $p$. This is done by sorting the medians and selecting the middle element.\n4.  The original array $A$ is partitioned around the pivot $p$ into two subarrays: one containing elements strictly less than $p$ and another containing elements strictly greater than $p$.\n5.  The algorithm recurses on the subarray that contains the desired order statistic.\n\nTo maximize the size of the larger recursive subarray, we must make the partition as lopsided as possible. Let us analyze the theoretical bounds on the partition sizes. Let the set of medians be $M = \\{m_1, m_2, m_3, m_4, m_5\\}$. Let the sorted medians be $m_{(1)} \\le m_{(2)} \\le m_{(3)} \\le m_{(4)} \\le m_{(5)}$. The pivot is $p = m_{(3)}$.\n\nConsider the number of elements guaranteed to be less than or equal to $p$:\n- There are $\\lceil 5/2 \\rceil = 3$ medians less than or equal to $p$, namely $m_{(1)}$, $m_{(2)}$, and $p=m_{(3)}$.\n- For each of these $3$ medians, the median itself and the two smaller elements within its group are less than or equal to that median. Since each of these $3$ medians is less than or equal to $p$, the corresponding $3 \\times 3 = 9$ elements are all less than or equal to $p$.\n- As all elements of the array $A$ are distinct, these $9$ elements are distinct. Thus, there are at least $9$ elements in $A$ that are less than or equal to $p$. This implies that the number of elements strictly less than $p$ is at least $9 - 1 = 8$.\n\nConsider the number of elements guaranteed to be greater than or equal to $p$:\n- By a symmetric argument, there are $\\lceil 5/2 \\rceil = 3$ medians greater than or equal to $p$, namely $p=m_{(3)}$, $m_{(4)}$, and $m_{(5)}$.\n- For each of these $3$ groups, the median and the two larger elements are greater than or equal to that median. These $3 \\times 3 = 9$ elements are therefore all greater than or equal to $p$.\n- This guarantees that the number of elements strictly greater than $p$ is at least $8$.\n\nThe partition of $A$ around $p$ yields a subarray of elements smaller than $p$, of size $|S_<|$, and a subarray of elements larger than $p$, of size $|S_>|$. We have $|S_<| + |S_>| = n-1 = 24$. If one side is minimized, the other is maximized. The minimum size for either partition is $8$. If $|S_<|=8$, then $|S_>| = 24 - 8 = 16$. If $|S_>|=8$, then $|S_<|=16$. In either case, the maximum possible size for the larger recursive subarray is $16$.\n\nWe now construct an explicit array $A$ that achieves this $8/16$ split. We will use the distinct integers from $1$ to $25$. To create the most unbalanced partition, we will design the groups such that the number of elements strictly less than the pivot $p$ is minimized to $8$. This forces the pivot to be $p=9$.\n\nLet the five groups be $G_1, G_2, G_3, G_4, G_5$. We construct them as follows:\n\n-   Let two groups, say $G_1$ and $G_2$, have medians less than $p=9$. To minimize the number of small elements, we pack them with large elements where possible.\n    -   $G_1 = \\{13, 1, 5, 12, 2\\}$: The sorted elements are $\\{1, 2, 5, 12, 13\\}$. The median is $m_1 = 5$. The elements $\\{1, 2, 5\\}$ are less than $p=9$. The elements $\\{12, 13\\}$ are greater than $p=9$.\n    -   $G_2 = \\{15, 3, 6, 14, 4\\}$: The sorted elements are $\\{3, 4, 6, 14, 15\\}$. The median is $m_2 = 6$. The elements $\\{3, 4, 6\\}$ are less than $p=9$. The elements $\\{14, 15\\}$ are greater than $p=9$.\n\n-   Let one group, say $G_3$, have the pivot $p=9$ as its median.\n    -   $G_3 = \\{11, 7, 9, 10, 8\\}$: The sorted elements are $\\{7, 8, 9, 10, 11\\}$. The median is $m_3 = 9$. The elements $\\{7, 8\\}$ are less than $p=9$. The element $9$ is the pivot. The elements $\\{10, 11\\}$ are greater than $p=9$.\n\n-   Let the remaining two groups, $G_4$ and $G_5$, have medians greater than $p=9$. To create the adversarial case, all elements in these groups must be greater than $p=9$.\n    -   $G_4 = \\{18, 16, 20, 17, 19\\}$: The sorted elements are $\\{16, 17, 18, 19, 20\\}$. The median is $m_4 = 18$. All $5$ elements are greater than $p=9$.\n    -   $G_5 = \\{23, 21, 25, 22, 24\\}$: The sorted elements are $\\{21, 22, 23, 24, 25\\}$. The median is $m_5 = 23$. All $5$ elements are greater than $p=9$.\n\nJustification of the pivot:\nThe set of medians is $M = \\{m_1, m_2, m_3, m_4, m_5\\} = \\{5, 6, 9, 18, 23\\}$.\nThe median of this set is the $3$rd element in the sorted list $(5, 6, 9, 18, 23)$, which is $9$. Therefore, the pivot selected by the algorithm is indeed $p=9$, as intended by the construction.\n\nPartitioning around $p=9$:\nThe full array $A$ consists of the concatenation of these groups. The set of all integers in $A$ is $\\{1, 2, \\dots, 25\\}$.\n-   The elements of $A$ strictly less than $p=9$ are: $\\{1, 2, 5\\}$ from $G_1$; $\\{3, 4, 6\\}$ from $G_2$; and $\\{7, 8\\}$ from $G_3$. This gives the set $\\{1, 2, 3, 4, 5, 6, 7, 8\\}$. The size of this subarray is $8$.\n-   The elements of $A$ strictly greater than $p=9$ are: $\\{12, 13\\}$ from $G_1$; $\\{14, 15\\}$ from $G_2$; $\\{10, 11\\}$ from $G_3$; $\\{16, 17, 18, 19, 20\\}$ from $G_4$; and $\\{21, 22, 23, 24, 25\\}$ from $G_5$. This gives the set $\\{10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25\\}$. The size of this subarray is $16$.\n\nThe two recursive subproblems would have sizes $8$ and $16$. The larger of these two has size $16$. Our construction has successfully produced the maximally unbalanced partition.\n\nThe size of the larger recursive subarray is therefore $16$.", "answer": "$$\\boxed{16}$$", "id": "3250877"}, {"introduction": "A powerful way to deepen your understanding of an algorithm is to adapt it to solve a new, related problem. This hands-on coding challenge [@problem_id:3250889] asks you to modify the median-of-medians algorithm to efficiently find the two central medians of an even-sized array. You will need to carefully design the recursive logic to handle how the pair of target ranks interacts with the partitions created by the pivot, all while preserving the algorithm's guaranteed linear-time complexity.", "problem": "You are given an unsorted array $A$ of even length $n$ and are asked to compute the two medians of $A$ in worst-case time $O(n)$ using a modification of the deterministic selection algorithm commonly known as the Blum–Floyd–Pratt–Rivest–Tarjan (BFPRT) algorithm. The two medians are defined as the elements whose ranks in the sorted order of $A$ are $k_1 = \\frac{n}{2} - 1$ and $k_2 = \\frac{n}{2}$ under zero-based indexing. The computation must be performed without sorting $A$ end-to-end.\n\nFundamental base to be used:\n- Definition of order statistics: for an array $A$ of length $n$, the element of rank $k$ is the $k$-th smallest element of $A$.\n- Deterministic pivot selection via groups of $5$: partition $A$ into consecutive groups of $5$ elements, compute the median of each group, and select as pivot the median of these medians, determined recursively.\n- Three-way partitioning invariant: after partitioning around a pivot value $p$, the array region under consideration is split into a left region of elements strictly less than $p$, an equal region of elements equal to $p$, and a right region of elements strictly greater than $p$.\n\nRequired design and derivation:\n- Starting from the above fundamental base, derive a modified selection procedure that simultaneously targets both ranks $k_1$ and $k_2$ without sorting the input. Ensure that your derivation relies only on the stated base and principles such as comparison-based partitioning and recursion, and does not rely on unproven shortcuts.\n- Your algorithm must guarantee worst-case time $O(n)$ by using the median-of-medians pivot selection and by proving that, at each recursive step, at most one subproblem is pursued when the target rank interval $[k_1, k_2]$ intersects the equal region created by the pivot partition. Provide a clear justification for why this property implies an $O(n)$ bound.\n\nImplementation requirements:\n- Implement a function that, given an even-length array $A$, returns a pair $[m_{\\text{lo}}, m_{\\text{hi}}]$ where $m_{\\text{lo}}$ is the element of rank $k_1$ and $m_{\\text{hi}}$ is the element of rank $k_2$.\n- The implementation must use the median-of-medians pivot strategy with groups of size $5$ and a three-way partitioning scheme. For small subproblems, use a direct computation by sorting the subarray and taking elements at positions $k_1$ and $k_2$ relative to the subarray.\n- All arrays are purely mathematical sequences; there are no physical units involved.\n\nTest suite:\nUse the following arrays (each of even length) as test cases, computing the pair of medians $[m_{\\text{lo}}, m_{\\text{hi}}]$ for each:\n1. $A_1 = [12,7,3,9,1,5,8,6,10,2]$ with $n = 10$, $k_1 = 4$, $k_2 = 5$.\n2. $A_2 = [4,1]$ with $n = 2$, $k_1 = 0$, $k_2 = 1$.\n3. $A_3 = [5,5,5,5]$ with $n = 4$, $k_1 = 1$, $k_2 = 2$.\n4. $A_4 = [-2,-1,-3,-4,-5,-6,-7,-8]$ with $n = 8$, $k_1 = 3$, $k_2 = 4$.\n5. $A_5 = [0,1,2,3,4,5]$ with $n = 6$, $k_1 = 2$, $k_2 = 3$.\n6. $A_6 = [2,8,1,7,3,6,4,5]$ with $n = 8$, $k_1 = 3$, $k_2 = 4$.\n\nAnswer specification:\n- For each test case, the output must be a list of two integers $[m_{\\text{lo}}, m_{\\text{hi}}]$ representing the lower and upper medians.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the pair for one test case (for example, $[[m_{\\text{lo}_1},m_{\\text{hi}_1}],[m_{\\text{lo}_2},m_{\\text{hi}_2}],\\dots]$).", "solution": "The user wants to find the two medians of an unsorted array $A$ of even length $n$. The two medians are defined by their zero-based ranks $k_1 = \\frac{n}{2} - 1$ and $k_2 = \\frac{n}{2}$. The solution must be a modification of the Blum–Floyd–Pratt–Rivest–Tarjan (BFPRT) deterministic selection algorithm, commonly known as the median-of-medians algorithm, and must achieve a worst-case time complexity of $O(n)$.\n\n**Derivation of the Algorithm**\n\nThe core of the problem is to adapt a selection algorithm designed to find a single element of rank $k$ to find two adjacent elements of ranks $k_1$ and $k_2$ simultaneously, without degrading the worst-case linear time performance. A naive approach of running the $O(n)$ BFPRT algorithm twice, once for $k_1$ and once for $k_2$, would result in a total time of $O(n) + O(n) = O(n)$. However, the problem asks for a single, modified procedure that \"simultaneously targets both ranks,\" suggesting a more integrated approach.\n\nLet us derive such a procedure, which we will call `DualSelect`. This procedure will rely on the fundamental components of the BFPRT algorithm: guaranteed \"good\" pivot selection via median-of-medians and recursive partitioning.\n\n1.  **High-Level Strategy**: The algorithm will be a recursive, divide-and-conquer procedure. At each step, it will select a pivot element $p$ and partition the current subarray into three regions: $L$ (elements $<p$), $E$ (elements $=p$), and $R$ (elements $>p$). Based on the sizes of these partitions, it will determine the location of the target ranks $k_1$ and $k_2$ and either find the solution directly or recurse on a smaller subproblem.\n\n2.  **Pivot Selection**: To guarantee worst-case $O(n)$ time, the pivot $p$ must be chosen carefully. We will use the median-of-medians technique as specified. For a subarray of size $m$, we partition it into $\\lceil m/5 \\rceil$ groups of up to $5$ elements. We find the median of each small group (by sorting). Then, we recursively find the median of these medians. This chosen pivot $p$ is guaranteed to be greater than or equal to at least $\\approx \\frac{3}{10}m$ elements and less than or equal to at least $\\approx \\frac{3}{10}m$ elements. This ensures that any single recursive call will be on a subarray of size at most $\\approx \\frac{7}{10}m$.\n\n3.  **Recursive Logic**: Let our recursive function be `DualSelect(A_sub, k1_rel, k2_rel)`, where `A_sub` is the current subarray under consideration, and `k1_rel`, `k2_rel` are the ranks we seek relative to `A_sub`.\n\n    a.  **Base Case**: If the size of `A_sub`, denoted $m$, is small (e.g., $m \\le 10$), we can solve the problem directly by sorting `A_sub`. The two medians are then the elements at indices `k1_rel` and `k2_rel` in the sorted subarray.\n\n    b.  **Recursive Step**:\n        i.  Select a pivot $p$ from `A_sub` using the median-of-medians method.\n        ii. Perform a three-way partition of `A_sub` around $p$, yielding partitions $L$, $E$, and $R$. Let their sizes be $s_L$, $s_E$, and $s_R$.\n        iii. Determine the location of the target ranks `k1_rel`, `k2_rel` with respect to these partitions.\n\n4.  **Case Analysis**: We analyze the positions of `k1_rel` and `k2_rel` relative to the partitions.\n\n    *   **Case 1: Both Ranks in $L$**. If $k2_{\\text{rel}} < s_L$, then both target elements are in the partition $L$. The problem reduces to finding the elements of the same ranks, `k1_rel` and `k2_rel`, within $L$. We make a single recursive call: `DualSelect(L, k1_rel, k2_rel)`.\n\n    *   **Case 2: Both Ranks in $R$**. If $k1_{\\text{rel}} \\ge s_L + s_E$, then both target elements are in the partition $R$. The problem reduces to finding them in $R$, but their ranks must be adjusted relative to the start of $R$. The new ranks are $k1'_{\\text{rel}} = k1_{\\text{rel}} - (s_L + s_E)$ and $k2'_{\\text{rel}} = k2_{\\text{rel}} - (s_L + s_E)$. We make a single recursive call: `DualSelect(R, k1'_rel, k2'_rel)`.\n\n    *   **Case 3: Both Ranks in $E$**. If $s_L \\le k1_{\\text{rel}}$ and $k2_{\\text{rel}} < s_L + s_E$, then both target elements fall within the partition $E$. Since all elements in $E$ are equal to the pivot $p$, both medians must be $p$. The function returns $[p, p]$.\n\n    *   **Case 4: Ranks Straddle Partitions**. This is the crucial case. Since the target ranks are adjacent ($k_2 = k_1 + 1$ implies $k2_{\\text{rel}} = k1_{\\text{rel}} + 1$), they cannot \"jump\" over a non-empty partition. For instance, it is impossible for rank $k1_{\\text{rel}}$ to be in $L$ and rank $k2_{\\text{rel}}$ to be in $R$, as that would imply the rank interval $[k1_{\\text{rel}}, k2_{\\text{rel}}]$ contains ranks belonging to $E$, which would contradict the adjacency unless $s_E=0$. The pivot selection process ensures $s_E \\ge 1$.\n        This leaves two possibilities for straddling:\n        *   **Straddling $L$ and $E$**: $k1_{\\text{rel}} < s_L$ and $s_L \\le k2_{\\text{rel}} < s_L+s_E$. This implies the upper median is $p$. The problem reduces to finding a single element—the lower median—of rank `k1_rel` within partition $L$. This can be accomplished with a single call to the standard BFPRT `Select(L, k1_rel)`.\n        *   **Straddling $E$ and $R$**: $s_L \\le k1_{\\text{rel}} < s_L+s_E$ and $k2_{\\text{rel}} \\ge s_L+s_E$. This implies the lower median is $p$. The problem reduces to finding the upper median of (adjusted) rank `k2_rel - (s_L+s_E)` within partition $R$. This is done with a single call: `Select(R, k2_rel - (s_L+s_E))`.\n\n5.  **Complexity Analysis and Justification for $O(n)$**:\n    The total work at each step of `DualSelect` on a subarray of size $m$ consists of:\n    1.  Finding medians of groups of 5: $O(m)$.\n    2.  Recursively finding the pivot (median of medians): This call is on an array of size $\\lceil m/5 \\rceil$, so it takes $T(\\lceil m/5 \\rceil)$ time.\n    3.  Partitioning the array: $O(m)$.\n    4.  The main recursive call.\n\n    In all cases analyzed above, we make at most one further recursive call on a subproblem. The \"good\" pivot guarantees that the size of this subproblem (whether for `DualSelect` or `Select`) is at most $\\lfloor \\frac{7m}{10} + 6 \\rfloor$. The complexity of both `DualSelect` and `Select` is therefore governed by the same recurrence relation:\n    $$T(m) \\le T(\\lceil m/5 \\rceil) + T(\\lfloor \\frac{7m}{10} + 6 \\rfloor) + O(m)$$\n    This is the standard recurrence for the BFPRT algorithm. It can be shown by substitution that $T(m) \\le c \\cdot m$ for some constant $c$, which means $T(m) = O(m)$. For sufficiently large $m$, $T(\\lceil m/5 \\rceil) + T(\\lfloor \\frac{7m}{10} + 6 \\rfloor) \\le c(\\frac{m}{5}) + c(\\frac{7m}{10}) + c \\cdot 6 = c(\\frac{9m}{10}) + 6c$. If we choose $c$ large enough such that the $O(m)$ term is bounded by $d \\cdot m$, we need $c(\\frac{9m}{10}) + 6c + dm \\le cm$, which simplifies to $(d - \\frac{c}{10})m + 6c \\le 0$. This inequality holds for large enough $m$ if $d - \\frac{c}{10} < 0$, or $c > 10d$.\n    Thus, our `DualSelect` procedure correctly finds both medians and maintains the worst-case $O(n)$ time complexity by ensuring that at most one recursive call is made on a subproblem whose size is a fraction of the current problem size.\n\nThe implementation will be done in-place on a copy of the input array to avoid the overhead of creating new arrays for partitions $L$ and $R$. This requires careful management of indices and relative ranks.", "answer": "```python\nimport numpy as np\n\n# A small cutoff for switching to sorting-based selection\n# is a standard optimization for selection algorithms.\nSELECTION_CUTOFF = 10\n\ndef _partition3(A, left, right, pivot_val):\n    \"\"\"\n    Performs a three-way partition on the subarray A[left...right]\n    around a given pivot value.\n    Rearranges the subarray into three parts:\n    - Elements less than pivot_val\n    - Elements equal to pivot_val\n    - Elements greater than pivot_val\n    Returns a tuple (i, j) where A[i...j] is the equal partition.\n    \"\"\"\n    lt, gt = left, right\n    i = left\n    while i <= gt:\n        if A[i] < pivot_val:\n            A[lt], A[i] = A[i], A[lt]\n            lt += 1\n            i += 1\n        elif A[i] > pivot_val:\n            A[gt], A[i] = A[i], A[gt]\n            gt -= 1\n        else:\n            i += 1\n    return lt, gt\n\ndef _select(A, left, right, k):\n    \"\"\"\n    Finds the k-th smallest element in A[left...right] (0-indexed)\n    using the BFPRT (median-of-medians) algorithm.\n    This function is guaranteed to run in worst-case O(n) time.\n    \"\"\"\n    while True:\n        if right - left + 1 <= SELECTION_CUTOFF:\n            sub_array = A[left : right + 1]\n            sub_array.sort()\n            return sub_array[k]\n\n        m = right - left + 1\n        num_groups = (m + 4) // 5\n        medians = np.empty(num_groups, dtype=A.dtype)\n\n        for i in range(num_groups):\n            start = left + i * 5\n            end = min(start + 5, right + 1)\n            group = A[start:end]\n            group.sort()\n            medians[i] = group[len(group) // 2]\n        \n        pivot_val = _select(medians, 0, len(medians) - 1, len(medians) // 2)\n\n        i, j = _partition3(A, left, right, pivot_val)\n\n        s_L = i - left\n        s_E = j - i + 1\n\n        if k < s_L:\n            right = i - 1\n        elif k >= s_L + s_E:\n            k -= (s_L + s_E)\n            left = j + 1\n        else:\n            return pivot_val\n\ndef _dual_select(A, left, right, k1, k2):\n    \"\"\"\n    Finds the k1-th and k2-th smallest elements in A[left...right]\n    simultaneously in worst-case O(n) time.\n    \"\"\"\n    while True:\n        m = right - left + 1\n        if m <= SELECTION_CUTOFF:\n            sub_array = A[left : right + 1]\n            sub_array.sort()\n            return [sub_array[k1], sub_array[k2]]\n\n        num_groups = (m + 4) // 5\n        medians = np.empty(num_groups, dtype=A.dtype)\n\n        for i in range(num_groups):\n            start = left + i * 5\n            end = min(start + 5, right + 1)\n            group = A[start:end]\n            group.sort()\n            medians[i] = group[len(group) // 2]\n        \n        pivot_val = _select(medians, 0, len(medians) - 1, len(medians) // 2)\n        \n        i, j = _partition3(A, left, right, pivot_val)\n\n        s_L = i - left\n        s_E = j - i + 1\n\n        if k2 < s_L: # Both ranks are in the left partition\n            right = i - 1\n            # Relative ranks k1, k2 do not change\n        elif k1 >= s_L + s_E: # Both ranks are in the right partition\n            k1 -= (s_L + s_E)\n            k2 -= (s_L + s_E)\n            left = j + 1\n        else: # Ranks straddle partitions or are inside E\n            m_lo, m_hi = -1, -1\n            k1_in_E = s_L <= k1 < s_L + s_E\n            k2_in_E = s_L <= k2 < s_L + s_E\n            \n            if k1_in_E and k2_in_E:\n                return [pivot_val, pivot_val]\n            elif k1_in_E: # k1 in E, k2 in R\n                m_lo = pivot_val\n                m_hi = _select(A, j + 1, right, k2 - (s_L + s_E))\n                return [m_lo, m_hi]\n            elif k2_in_E: # k1 in L, k2 in E\n                m_lo = _select(A, left, i - 1, k1)\n                m_hi = pivot_val\n                return [m_lo, m_hi]\n            else: # Should not happen given k2 = k1 + 1\n                # This case (k1 in L, k2 in R) is impossible\n                # and indicates a logic error if reached.\n                # To be defensive, we handle it but it's not expected.\n                m_lo = _select(A, left, i - 1, k1)\n                m_hi = _select(A, j + 1, right, k2 - (s_L + s_E))\n                return [m_lo, m_hi]\n\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the specified test cases.\n    \"\"\"\n    test_cases = [\n        np.array([12, 7, 3, 9, 1, 5, 8, 6, 10, 2]),\n        np.array([4, 1]),\n        np.array([5, 5, 5, 5]),\n        np.array([-2, -1, -3, -4, -5, -6, -7, -8]),\n        np.array([0, 1, 2, 3, 4, 5]),\n        np.array([2, 8, 1, 7, 3, 6, 4, 5])\n    ]\n\n    results = []\n    for A in test_cases:\n        n = len(A)\n        # We work on a copy to prevent modifying the original test case arrays\n        A_copy = np.copy(A)\n        \n        k1 = n // 2 - 1\n        k2 = n // 2\n        \n        medians = _dual_select(A_copy, 0, n - 1, k1, k2)\n        results.append(medians)\n    \n    # Format the output string exactly as specified, without spaces\n    formatted_results = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3250889"}]}