{"hands_on_practices": [{"introduction": "This first exercise is designed to strengthen your intuition for the direct correspondence between bit masks and sets. You will tackle a counting problem that, when viewed through the lens of bitwise logic, has a surprisingly simple and elegant solution. This practice reinforces the power of analyzing a problem on a per-bit basis, a core skill in bit masking. [@problem_id:3217117]", "problem": "You are given a nonnegative integer mask $M$. Interpret a mask as the set of positions of its $1$-bits in the standard binary representation, so that a submask of $M$ is any nonnegative integer whose $1$-bits form a subset of those of $M$. Two masks $A$ and $B$ are considered as an ordered pair $(A,B)$. Using only fundamental definitions of set operations and bitwise masking, determine the exact number of ordered pairs $(A,B)$ of submasks of $M$ such that the set of $1$-bit positions of $A$ and $B$ satisfy $A \\cap B = \\emptyset$ and $A \\cup B = M$. For concreteness, let $M$ be the integer whose base-$16$ (hexadecimal) numeral is $\\mathrm{1F3A7C}$. Give your final answer as an exact integer with no rounding.", "solution": "The problem asks for the number of ordered pairs of nonnegative integers $(A,B)$ that are submasks of a given mask $M$, and satisfy the conditions $A \\cap B = \\emptyset$ and $A \\cup B = M$. The problem states that these masks should be interpreted as the sets of positions of their $1$-bits.\n\nLet $S_M$ be the set of bit positions where the binary representation of $M$ has a $1$. The condition that $A$ and $B$ are submasks of $M$ is equivalent to stating that their corresponding sets of $1$-bit positions, $S_A$ and $S_B$, are subsets of $S_M$. That is, $S_A \\subseteq S_M$ and $S_B \\subseteq S_M$.\n\nThe conditions given in the problem are:\n$1$. $A \\cap B = \\emptyset$: This means the set of $1$-bit positions of $A$ and the set of $1$-bit positions of $B$ are disjoint. In set notation, this is $S_A \\cap S_B = \\emptyset$. In terms of bitwise operations on the integers themselves, this is equivalent to $(A \\text{ AND } B) = 0$.\n$2$. $A \\cup B = M$: This means the union of the sets of $1$-bit positions of $A$ and $B$ is equal to the set of $1$-bit positions of $M$. In set notation, this is $S_A \\cup S_B = S_M$. In terms of bitwise operations, this is equivalent to $(A \\text{ OR } B) = M$.\n\nThe two set-theoretic conditions, $S_A \\cup S_B = S_M$ and $S_A \\cap S_B = \\emptyset$, together imply that the sets $S_A$ and $S_B$ form a partition of the set $S_M$. Our task is to count the number of such ordered pairs of sets $(S_A, S_B)$.\n\nLet us analyze the constraints on a per-bit basis. Consider the $i$-th bit position for an arbitrary integer $i \\ge 0$.\n\nCase 1: The $i$-th bit of $M$ is $0$.\nSince $A$ and $B$ must be submasks of $M$, their $i$-th bits must also be $0$. This is because $S_A \\subseteq S_M$ and $S_B \\subseteq S_M$, so if $i \\notin S_M$, it follows that $i \\notin S_A$ and $i \\notin S_B$. The conditions are satisfied for this bit position: the $i$-th bit of $(A \\text{ OR } B)$ is $0 \\text{ OR } 0 = 0$, matching $M$, and the $i$-th bit of $(A \\text{ AND } B)$ is $0 \\text{ AND } 0 = 0$, consistent with the empty intersection. For any such bit position, there is only one possible choice for the corresponding bits in $A$ and $B$ (they must both be $0$).\n\nCase 2: The $i$-th bit of $M$ is $1$.\nThis means $i \\in S_M$.\nThe condition $S_A \\cup S_B = S_M$ implies that for this position $i$, we must have $i \\in S_A$ or $i \\in S_B$.\nThe condition $S_A \\cap S_B = \\emptyset$ implies that $i$ cannot be in both $S_A$ and $S_B$.\nCombining these two requirements, for each bit position $i$ where $M$ has a $1$, exactly one of $A$ or $B$ must have a $1$ at that position. This gives two possibilities for each such bit:\na) The $i$-th bit of $A$ is $1$ and the $i$-th bit of $B$ is $0$.\nb) The $i$-th bit of $A$ is $0$ and the $i$-th bit of $B$ is $1$.\n\nSince the choice for each bit position is independent of the choices for all other bit positions, the total number of ordered pairs $(A,B)$ can be found by multiplying the number of choices for each bit.\nLet $N$ be the number of $1$-bits in the binary representation of $M$. This is also known as the population count or Hamming weight of $M$. For each of the $N$ bit positions where $M$ has a $1$, there are $2$ possible ways to assign that bit to either $A$ or $B$. For all other bit positions, where $M$ has a $0$, there is only $1$ choice (both $A$ and $B$ must have a $0$).\n\nTherefore, the total number of ordered pairs $(A,B)$ is $2^N$.\n\nThe problem provides a specific value for $M$ in hexadecimal: $M = \\mathrm{1F3A7C}_{16}$. We must find the number of $1$-bits, $N$, in its binary representation. We convert each hexadecimal digit to its $4$-bit binary equivalent:\n- $1_{16} = 0001_2$ (contains $1$ one)\n- $F_{16} = 1111_2$ (contains $4$ ones)\n- $3_{16} = 0011_2$ (contains $2$ ones)\n- $A_{16} = 1010_2$ (contains $2$ ones)\n- $7_{16} = 0111_2$ (contains $3$ ones)\n- $C_{16} = 1100_2$ (contains $2$ ones)\n\nThe binary representation of $M$ is $0001\\ 1111\\ 0011\\ 1010\\ 0111\\ 1100_2$.\nThe total number of $1$-bits, $N$, is the sum of the $1$-bits from each hexadecimal digit:\n$N = 1 + 4 + 2 + 2 + 3 + 2 = 14$.\n\nThe total number of ordered pairs $(A,B)$ is $2^N = 2^{14}$.\nWe calculate this value:\n$2^{10} = 1024$\n$2^{14} = 2^4 \\times 2^{10} = 16 \\times 1024$\n$16 \\times 1024 = 16 \\times (1000 + 24) = 16000 + 16 \\times 24 = 16000 + 384 = 16384$.\n\nThus, there are exactly $16384$ such ordered pairs $(A,B)$.", "answer": "$$\\boxed{16384}$$", "id": "3217117"}, {"introduction": "Now let's move from static properties to dynamic transformations. This problem challenges you to find the shortest path to a solution by modeling states as bit masks and actions as bitwise operations. By applying a classic algorithm like Breadth-First Search (BFS) to this state space, you'll gain hands-on experience in using bit masking to solve complex puzzles and optimization problems. [@problem_id:3217223]", "problem": "You are given an initial bit mask $m$, a target bit mask $g$, and a finite list of toggle masks $t_i$ for $i \\in \\{1,2,\\dots,k\\}$. A toggle operation applies the bitwise exclusive OR (XOR) to the current mask: if the current mask is $x$, applying toggle $t_i$ transforms it to $x \\oplus t_i$. All masks are constrained to a fixed bit-width $B$, meaning only the lowest $B$ bits are considered and all operations are within the set $\\{0,1,\\dots,2^B-1\\}$.\n\nConstruct a program that determines the minimum number of toggle operations needed to transform $m$ into $g$, or returns $-1$ if $g$ is not reachable from $m$ under any sequence of toggles. Your program must produce a single line of output as a comma-separated list enclosed in square brackets, aggregating the results for the given test suite.\n\nThe reasoning must start from fundamental definitions and facts:\n- The bitwise exclusive OR (XOR), written as $\\oplus$, is defined bitwise using addition modulo $2$ without carry. For any bit masks $a$ and $b$ of width $B$, $a \\oplus b$ is the mask whose bits are $(a_j + b_j) \\bmod 2$ for bit positions $j \\in \\{0,1,\\dots,B-1\\}$.\n- XOR obeys the algebraic properties: $a \\oplus a = 0$, $a \\oplus 0 = a$, commutativity $a \\oplus b = b \\oplus a$, and associativity $(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)$. Every element is its own inverse under $\\oplus$.\n- Breadth-First Search (BFS) on an unweighted graph explores vertices in nondecreasing order of path length and therefore finds a shortest path from a source to any reachable vertex.\n\nModel the reachable masks as vertices of an unweighted directed graph with vertex set $V = \\{0,1,\\dots,2^B-1\\}$. There is an edge from $x$ to $y$ if and only if there exists some toggle $t_i$ such that $y = x \\oplus t_i$. Starting at vertex $m$, the problem asks for the shortest path length to vertex $g$ in this graph. If $g$ is not reachable from $m$, the answer is $-1$.\n\nInput protocol is fixed by the test suite below; your program must not read any external input. The final output format must be a single line containing a list of integers representing the minimum number of toggles for each test case, written exactly as $[r_1,r_2,\\dots,r_n]$ with no spaces.\n\nTest suite (each case is a quadruple $(B,m,g,\\{t_i\\})$):\n- Case $1$: $B = 8$, $m = 26$, $g = 229$, $\\{t_i\\} = [160,39,255,91]$.\n- Case $2$: $B = 8$, $m = 123$, $g = 123$, $\\{t_i\\} = [5,7,200]$.\n- Case $3$: $B = 8$, $m = 0$, $g = 4$, $\\{t_i\\} = [1,2]$.\n- Case $4$: $B = 8$, $m = 42$, $g = 40$, $\\{t_i\\} = [0,5,5,7]$.\n- Case $5$: $B = 4$, $m = 0$, $g = 11$, $\\{t_i\\} = [1,2,4,8]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3,r_4,r_5]$. The expected outputs are integers; for unreachable targets, output $-1$.", "solution": "The problem as stated is valid. It is scientifically grounded in the mathematics of finite fields and graph theory, well-posed with a clear objective, and free from ambiguity or contradiction. All necessary information is provided in the test suite. We may therefore proceed with a solution.\n\nThe problem asks for the minimum number of toggle operations to transform an initial bit mask $m$ into a target bit mask $g$. This is a classic shortest path problem on an unweighted graph. The solution can be systematically derived by first formalizing the problem in terms of a graph-theoretic model and then applying a suitable search algorithm.\n\nFirst, let us define the structure of the state space. The set of all possible bit masks of a fixed width $B$ constitutes the vertex set $V$ of a graph, where $V = \\{0, 1, \\dots, 2^B - 1\\}$. An operation consists of applying a toggle mask $t_i$ from a given list $\\{t_1, t_2, \\dots, t_k\\}$. The effect of a toggle is defined by the bitwise exclusive OR (XOR) operation, denoted by $\\oplus$. If the current mask is $x$, applying the toggle $t_i$ results in a new mask $x' = x \\oplus t_i$.\n\nThis transformation defines the edges of our graph. An edge exists between two vertices (masks) $u$ and $v$ if there is a toggle $t_i$ such that $v = u \\oplus t_i$. The XOR operation is its own inverse, meaning $(u \\oplus t_i) \\oplus t_i = u \\oplus (t_i \\oplus t_i) = u \\oplus 0 = u$. This implies that if there is an edge from $u$ to $v$, there is also an edge from $v$ to $u$. Therefore, the graph is undirected. Each edge represents a single toggle operation, so the graph is unweighted. The problem is thus equivalent to finding the length of the shortest path from the starting vertex $m$ to the target vertex $g$.\n\nThe most appropriate algorithm for finding the shortest path in an unweighted graph is the Breadth-First Search (BFS). BFS systematically explores the graph layer by layer, guaranteeing that it discovers a path to any reachable vertex with the minimum number of edges.\n\nAn alternative perspective illuminates the underlying algebraic structure. A sequence of $L$ toggle operations $t_{i_1}, t_{i_2}, \\dots, t_{i_L}$ transforms $m$ to $g$ as follows:\n$$ g = m \\oplus t_{i_1} \\oplus t_{i_2} \\oplus \\dots \\oplus t_{i_L} $$\nBy the associativity and commutativity of XOR, we can rearrange this expression. XORing both sides with $m$ yields:\n$$ m \\oplus g = (m \\oplus m) \\oplus (t_{i_1} \\oplus t_{i_2} \\oplus \\dots \\oplus t_{i_L}) $$\n$$ m \\oplus g = 0 \\oplus (t_{i_1} \\oplus t_{i_2} \\oplus \\dots \\oplus t_{i_L}) $$\nLet $D = m \\oplus g$ be the \"difference mask\". The problem is equivalent to finding the smallest number of toggle masks from the set $\\{t_i\\}$ that XOR to $D$. This reframes the problem as finding the shortest path from the zero mask, $0$, to the mask $D$. This is a problem in a vector space over the field of two elements, $\\mathbb{F}_2$. While this view is conceptually elegant, the BFS algorithm remains the practical method for a solution, whether starting from $m$ to find $g$ or from $0$ to find $D$. We will adhere to the direct formulation of searching from $m$ to $g$.\n\nThe BFS algorithm proceeds as follows:\n$1.$ Initialize a queue for managing vertices to visit. The queue will store tuples of the form $(mask, distance)$. Add the starting state $(m, 0)$ to the queue.\n$2.$ Initialize a set or boolean array, `visited`, to keep track of masks that have already been enqueued. This is crucial to prevent cycles and redundant computations. Add $m$ to the `visited` set.\n$3.$ If $m=g$, the distance is $0$. This trivial case is handled by the initial state.\n$4.$ Loop while the queue is not empty:\n    a. Dequeue the current state, `(current_mask, current_dist)`.\n    b. For each unique toggle mask $t_j$ in the provided list:\n        i. Compute the `next_mask` as `current_mask` $\\oplus$ $t_j$.\n        ii. If `next_mask` is the target $g$, the shortest path has been found. Its length is `current_dist` $+ 1$. The algorithm can terminate and return this value.\n        iii. If `next_mask` has not yet been visited, add it to the `visited` set and enqueue it with the new distance: `(next_mask, current_dist + 1)`.\n$5.$ If the queue becomes empty and the target $g$ has not been found, it means $g$ is not in the same connected component of the graph as $m$. Thus, $g$ is unreachable. In this case, the function should return $-1$.\n\nDuplicate toggles in the input list $\\{t_i\\}$ do not add new transitions and can be filtered into a unique set. A toggle of $0$ is also a valid operation, corresponding to a self-loop ($x \\oplus 0 = x$), which is correctly handled by the `visited` set.\n\nThis BFS-based approach provides a complete and correct algorithm for solving the stated problem for any given parameters $B$, $m$, $g$, and $\\{t_i\\}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport collections\n\ndef find_min_toggles(B, m, g, toggles):\n    \"\"\"\n    Determines the minimum number of toggle operations to transform mask m into g.\n\n    This function models the problem as a shortest path search on an unweighted graph\n    of possible bit masks. Vertices are the masks, and an edge exists between two masks\n    if one can be transformed into the other by a single toggle operation (XOR).\n    Breadth-First Search (BFS) is used to find the shortest path from m to g.\n\n    Args:\n        B (int): The bit-width of the masks. All masks are in the range [0, 2**B - 1].\n        m (int): The initial bit mask.\n        g (int): The target bit mask.\n        toggles (list[int]): A list of toggle masks.\n\n    Returns:\n        int: The minimum number of operations, or -1 if g is unreachable from m.\n    \"\"\"\n    # If the start and target masks are the same, 0 operations are needed.\n    if m == g:\n        return 0\n\n    # Use a set of unique toggles to avoid redundant computations.\n    # A toggle of 0 results in a self-loop (x - x ^ 0 = x) and does not help\n    # reach new states, so it can be safely ignored.\n    unique_toggles = {t for t in toggles if t != 0}\n\n    # The queue for BFS stores tuples of (mask, distance_from_m).\n    # Initialize with the starting mask and a distance of 0.\n    queue = collections.deque([(m, 0)])\n\n    # A set to keep track of visited masks to avoid cycles and redundant exploration.\n    visited = {m}\n\n    # Perform the BFS.\n    while queue:\n        current_mask, dist = queue.popleft()\n\n        # Explore all possible next states from the current mask.\n        for t in unique_toggles:\n            next_mask = current_mask ^ t\n\n            # If the next mask is the target, we have found the shortest path.\n            if next_mask == g:\n                return dist + 1\n\n            # If the next mask has not been visited, add it to the queue and visited set.\n            if next_mask not in visited:\n                visited.add(next_mask)\n                queue.append((next_mask, dist + 1))\n\n    # If the queue is exhausted and the target was not found, it is unreachable.\n    return -1\n\ndef solve():\n    \"\"\"\n    Solves the problem for the suite of test cases provided in the prompt.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: B=8, m=26, g=229, {t_i}=[160,39,255,91]\n        (8, 26, 229, [160, 39, 255, 91]),\n        # Case 2: B=8, m=123, g=123, {t_i}=[5,7,200]\n        (8, 123, 123, [5, 7, 200]),\n        # Case 3: B=8, m=0, g=4, {t_i}=[1,2]\n        (8, 0, 4, [1, 2]),\n        # Case 4: B=8, m=42, g=40, {t_i}=[0,5,5,7]\n        (8, 42, 40, [0, 5, 5, 7]),\n        # Case 5: B=4, m=0, g=11, {t_i}=[1,2,4,8]\n        (4, 0, 11, [1, 2, 4, 8]),\n    ]\n\n    results = []\n    for B, m, g, toggles in test_cases:\n        result = find_min_toggles(B, m, g, toggles)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3217223"}, {"introduction": "Our final practice demonstrates the remarkable versatility of bit masking by applying it to the domain of linear algebra. You will encode and solve a system of linear equations over the finite field with two elements, GF($2$), using only bitwise operations. This powerful technique, which lies at the heart of the classic 'lights out' puzzle, showcases how bit masking enables efficient solutions to problems in areas like error correction and cryptography. [@problem_id:3217249]", "problem": "You are given $N$ light switches and $N$ bulbs. Switch $i$ toggles a subset of bulbs. The subset is represented by a nonnegative integer mask $m_i$ in base $10$, where the least significant bit (bit $0$) corresponds to bulb $1$, bit $1$ corresponds to bulb $2$, and in general bit $j$ corresponds to bulb $j+1$. Toggling is cumulative modulo $2$: pressing a switch flips the state of each bulb in its subset; pressing the same switch twice is equivalent to not pressing it at all.\n\nYour goal is to press a sequence of switches so that, starting from all bulbs off, only bulb $1$ is on at the end. The order of pressing does not matter because toggling is commutative under addition modulo $2$. Therefore, any solution can be represented as a binary decision vector $x \\in \\{0,1\\}^N$ where $x_i = 1$ if and only if switch $i$ is pressed an odd number of times. Let $A \\in \\{0,1\\}^{N \\times N}$ be the matrix with entries $A_{j,i} = 1$ if and only if switch $i$ toggles bulb $j$, and $A_{j,i} = 0$ otherwise. Let $b \\in \\{0,1\\}^N$ be the target vector with $b_1 = 1$ and $b_j = 0$ for all $j \\neq 1$. You must solve the linear system over the Finite Field with two elements (GF($2$)) given by\n$$\nA x = b \\quad \\text{over GF}(2).\n$$\nIf the system has no solution, you must indicate impossibility. If the system has at least one solution, there may be multiple solutions due to free variables. In that case, you must return the canonical solution obtained by performing Gaussian elimination over GF($2$) using the fixed column order $1,2,\\dots,N$ and setting all free variables to $0$.\n\nYour program must:\n- Construct $A$ from the masks $m_i$ by setting $A_{j,i} = 1$ if and only if the $(j-1)$-th bit of $m_i$ is $1$.\n- Solve $A x = b$ over GF($2$) using row operations that correspond to bitwise exclusive OR (exclusive OR is denoted XOR and equals addition modulo $2$).\n- If there is no solution, output the empty list for that test case.\n- If there is a solution, output the sequence of pressed switch indices as a list of $1$-indexed integers in increasing order, corresponding to all $i$ such that $x_i = 1$ in the canonical solution.\n\nFoundational facts you may use without proof:\n- The Boolean algebra rules for bits, including that XOR is associative and commutative, and that $a \\oplus a = 0$ for any bit $a$.\n- The properties of linear systems over GF($2$), and that Gaussian elimination with row swaps and row XORs preserves solution sets.\n- Representing a vector of $N$ bits as a nonnegative integer mask is equivalent to packing those bits into the binary representation of the integer.\n\nImplement your solution using bit masking to represent rows of the augmented matrix as integers, and use bitwise operations for row operations.\n\nTest suite:\n- Test case $1$: $N = 5$, masks $[13,22,19,26,21]$.\n- Test case $2$: $N = 4$, masks $[1,2,7,4]$.\n- Test case $3$: $N = 1$, masks $[1]$.\n- Test case $4$: $N = 3$, masks $[2,4,6]$.\n- Test case $5$: $N = 5$, masks $[0,1,0,0,0]$.\n\nOutput specification:\n- For each test case, output a list of $1$-indexed switch indices to press (in increasing order) that achieves only bulb $1$ on, using the canonical solution described above. If impossible, output the empty list $[]$ for that test case.\n- Your program should produce a single line of output containing the results for all test cases, in the given order, as a comma-separated list enclosed in square brackets, with no spaces. Each element is the list for one test case. For example, if there were three test cases, a valid output format would be $[[1,3],[],[2]]$.", "solution": "The problem requires solving a system of linear equations $A x = b$ over the finite field with two elements, GF($2$). The system is defined by $N$ switches and $N$ bulbs, where the action of each switch on the bulbs is given by an integer mask. The goal is to find a set of switches to press (represented by the vector $x \\in \\{0,1\\}^N$) such that only the first bulb is turned on, starting from a state where all bulbs are off.\n\nFirst, we must formalize the problem by constructing the augmented matrix $[A|b]$ for the system $Ax=b$. Let $N$ be the number of switches and bulbs. The matrix $A$ is an $N \\times N$ matrix where the entry $A_{j,i}$ is $1$ if switch $i$ toggles bulb $j$, and $0$ otherwise. The problem states that bit $k$ of mask $m_i$ corresponds to bulb $k+1$. Therefore, $A_{j,i} = 1$ if the $(j-1)$-th bit of mask $m_i$ is $1$. This means the $i$-th column of $A$ is the vector representation of the mask $m_i$. The target state vector $b$ is $[1, 0, \\dots, 0]^T$, representing that only bulb $1$ is on.\n\nTo solve the system efficiently, we employ Gaussian elimination over GF($2$), where addition is the bitwise exclusive OR (XOR) operation, and multiplication is the bitwise AND operation. The problem specifies representing rows of the augmented matrix as integers and using bitwise operations. A row of the augmented matrix $[A|b]$ has $N+1$ elements. We can represent the $j$-th row, $[A_{j,1}, \\dots, A_{j,N}, b_j]$, as a single integer. Let's use bits $0, \\dots, N-1$ to store the coefficients of $x_1, \\dots, x_N$ (i.e., the columns of $A$), and bit $N$ to store the augmented part $b_j$. The $j$-th row (for $j=1, \\dots, N$) of the matrix $A$ is constructed by taking the $(j-1)$-th bit from each of the given masks $m_1, \\dots, m_N$.\n\nThe solution process using Gaussian elimination consists of two main phases:\n\n1.  **Forward Elimination**: The augmented matrix is transformed into row echelon form. We iterate through columns $j=0, \\dots, N-1$ and rows $i=0, \\dots, N-1$. For each column $j$, we seek a pivot (a $1$) in a row $k \\geq i$. If a pivot is found, we swap row $k$ with row $i$ and use the new pivot row to eliminate all $1$s below it in column $j$ by XORing the pivot row with any other row that has a $1$ in column $j$. This process identifies pivot columns, which correspond to basic variables, and non-pivot columns, which correspond to free variables.\n\n2.  **Consistency Check and Back Substitution**: After forward elimination, we check for inconsistency. If any row has the form $[0, \\dots, 0 | 1]$, the system has no solution. This corresponds to an integer representation equal to $2^N$. If the system is consistent, we find the canonical solution as specified: all free variables are set to $0$. We then solve for the basic (pivot) variables using back substitution, starting from the last pivot row and moving upwards. For a pivot row $i$ corresponding to pivot variable $x_p$, the equation is of the form $x_p \\oplus \\bigoplus_{kp, k \\text{ is col index}} c_k x_k = b'_i$. Since variables $x_k$ for $kp$ have already been determined (or are free and set to $0$), we can solve for $x_p$ as $x_p = b'_i \\oplus \\bigoplus_{kp} c_k x_k$.\n\nThe final solution vector $x$ indicates which switches to press. The output is a sorted list of $1$-indexed switch indices $i$ for which $x_i=1$. If no solution exists, an empty list is returned.\n\nLet's illustrate with an example: $N=3$, masks $m=[2,4,6]$.\n$m_1=2=(010)_2$, $m_2=4=(100)_2$, $m_3=6=(110)_2$.\nThe matrix $A$ has columns formed by the bit patterns of the masks.\n$A = \\begin{pmatrix} 0  1  1 \\\\ 1  0  1 \\\\ 0  0  0 \\end{pmatrix}$. The target vector is $b = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$.\nThe augmented matrix $[A|b]$ is $\\begin{pmatrix} 0  1  1  |  1 \\\\ 1  0  1  |  0 \\\\ 0  0  0  |  0 \\end{pmatrix}$.\nWe swap rows $1$ and $2$ to get a pivot in the top-left: $\\begin{pmatrix} 1  0  1  |  0 \\\\ 0  1  1  |  1 \\\\ 0  0  0  |  0 \\end{pmatrix}$.\nThis is already in row echelon form. The pivot columns are $0$ and $1$ (for $x_1, x_2$). The column for $x_3$ is a free column.\nThe system is consistent. The canonical solution sets the free variable $x_3=0$.\nFrom row $2$: $x_2 \\oplus x_3 = 1 \\implies x_2 \\oplus 0 = 1 \\implies x_2=1$.\nFrom row $1$: $x_1 \\oplus x_3 = 0 \\implies x_1 \\oplus 0 = 0 \\implies x_1=0$.\nThe solution is $x=[0, 1, 0]$, meaning switch $2$ is pressed. The output is $[2]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        (5, [13, 22, 19, 26, 21]),\n        (4, [1, 2, 7, 4]),\n        (1, [1]),\n        (3, [2, 4, 6]),\n        (5, [0, 1, 0, 0, 0]),\n    ]\n\n    results = []\n    for N, masks in test_cases:\n        result = solve_single_case(N, masks)\n        results.append(result)\n\n    # Format the final output string\n    # e.g., [[1,3,5],[1],[1],[2],[2]]\n    output_str = \"[\" + \",\".join(map(str, results)).replace(\" \", \"\") + \"]\"\n    print(output_str)\n\ndef solve_single_case(N, masks):\n    \"\"\"\n    Solves a single instance of the lights and switches problem.\n    Args:\n        N: The number of switches and bulbs.\n        masks: A list of integers representing the switch-bulb connections.\n    Returns:\n        A sorted list of 1-indexed switch numbers to press for the canonical solution,\n        or an empty list if no solution exists.\n    \"\"\"\n    \n    # Step 1: Construct the augmented matrix as a list of integers.\n    # Each integer represents a row. Bit i corresponds to variable x_{i+1} (column i).\n    # Bit N corresponds to the augmented part (vector b).\n    aug_matrix = [0] * N\n    for j in range(N):  # Corresponds to row j, for bulb j+1\n        row_mask = 0\n        for i in range(N):  # Corresponds to column i, for switch i+1\n            # A_{j,i} is 1 if switch i+1 toggles bulb j+1.\n            # This is given by the j-th bit of masks[i].\n            if (masks[i]  j)  1:\n                row_mask |= (1  i)\n\n        # The target vector b has b_1 = 1, b_j = 0 for j!=1.\n        # This affects the first row (j=0).\n        if j == 0:\n            row_mask |= (1  N)\n        \n        aug_matrix[j] = row_mask\n\n    # Step 2: Forward elimination to achieve row echelon form.\n    pivot_row = 0\n    pivot_cols = []\n    for j in range(N):  # Iterate through columns to find pivots\n        if pivot_row == N:\n            break\n        \n        # Find a row = pivot_row with a 1 in the current column j\n        i = pivot_row\n        while i  N and (aug_matrix[i]  j)  1 == 0:\n            i += 1\n            \n        if i  N:  # A pivot is found at (i, j)\n            # Swap rows to bring the pivot to the diagonal position (pivot_row, j)\n            aug_matrix[pivot_row], aug_matrix[i] = aug_matrix[i], aug_matrix[pivot_row]\n            \n            pivot_val = aug_matrix[pivot_row]\n            \n            # Eliminate 1s below the pivot in the current column j\n            for k in range(pivot_row + 1, N):\n                if (aug_matrix[k]  j)  1:\n                    aug_matrix[k] ^= pivot_val\n            \n            pivot_cols.append(j)\n            pivot_row += 1\n\n    # Step 3: Check for inconsistency.\n    # This occurs if we have a row [0, 0, ..., 0 | 1].\n    for i in range(pivot_row, N):\n        if aug_matrix[i] == (1  N):\n            return []  # No solution\n\n    # Step 4: Back substitution to find the canonical solution.\n    # Free variables (non-pivot columns) are implicitly set to 0.\n    x = [0] * N\n    # Iterate backwards through the pivot rows\n    for i in range(pivot_row - 1, -1, -1):\n        pivot_col = pivot_cols[i]\n        row_val = aug_matrix[i]\n        \n        # Calculate the sum of terms involving already-determined variables\n        # The equation for this row is: x_{pivot_col} + sum_{kpivot_col} c_k*x_k = b'\n        rhs_sum = 0\n        for k in range(pivot_col + 1, N):\n            if (row_val  k)  1:\n                rhs_sum ^= x[k]\n        \n        # The augmented bit for this row\n        b_val = (row_val  N)  1\n        \n        # Solve for x_{pivot_col}\n        x[pivot_col] = b_val ^ rhs_sum\n        \n    # Step 5: Format the output as a sorted list of 1-indexed switch numbers.\n    solution = []\n    for i in range(N):\n        if x[i] == 1:\n            solution.append(i + 1)\n            \n    return solution\n\nsolve()\n\n```", "id": "3217249"}]}