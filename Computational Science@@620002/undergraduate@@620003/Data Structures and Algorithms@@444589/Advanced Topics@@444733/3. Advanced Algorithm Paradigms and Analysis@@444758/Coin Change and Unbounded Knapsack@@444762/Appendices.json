{"hands_on_practices": [{"introduction": "Many real-world optimization problems involve balancing multiple limited resources, such as budget and time, or weight and volume. This practice [@problem_id:3221793] extends the classic unbounded knapsack problem to two dimensions, challenging you to maximize value subject to two separate capacity constraints. The exercise is a perfect illustration of how to scale a dynamic programming solution by expanding its state space, moving from a one-dimensional array to a two-dimensional table to track each resource independently.", "problem": "You are to design and implement a complete program that computes the maximum achievable total value in a two-constraint unbounded knapsack. The problem is purely combinatorial. There are $n$ item types. Each item type $i$ has an integer value $v_i \\ge 0$, an integer weight $w_i \\ge 0$, and an integer volume $u_i \\ge 0$. You may take any nonnegative number of copies of each item. The knapsack has a weight capacity $W$ and a volume capacity $U$, both nonnegative integers. The objective is to choose counts $x_i \\in \\mathbb{Z}_{\\ge 0}$ to maximize the total value $\\sum_{i=1}^n v_i x_i$ subject to the constraints $\\sum_{i=1}^n w_i x_i \\le W$ and $\\sum_{i=1}^n u_i x_i \\le U$. This is the unbounded variant with two resource constraints. The computational task must be solved by reasoning from first principles that justify an algorithmic recurrence from the principle of optimality of dynamic programming (dynamic programming (DP)), without appealing to a pre-stated closed-form recurrence in this prompt.\n\nFundamental base for derivation: use the definitions of optimal substructure and the principle of optimality in dynamic programming for unbounded selection under additive constraints.\n\nInput modeling details:\n- All $v_i$, $w_i$, $u_i$, $W$, and $U$ are integers with $v_i \\ge 0$, $w_i \\ge 0$, $u_i \\ge 0$, $W \\ge 0$, $U \\ge 0$.\n- If there exists any item $i$ with $w_i = 0$, $u_i = 0$, and $v_i > 0$, then the optimal value is unbounded above. In that case, your program must output the integer $-1$ for that test case.\n- Otherwise, the optimal value is finite and is an integer.\n\nYour program must compute the optimal value for each of the following test cases and aggregate the results. The test cases are designed to probe a range of behaviors including typical usage, zero capacities, a zero-weight item, tight volume constraints, and an unbounded-value edge case. The arrays are indexed in the natural order $i = 1, 2, \\dots, n$.\n\nTest Suite:\n- Test case $1$: $n = 3$, $v = [\\,4,5,7\\,]$, $w = [\\,2,3,4\\,]$, $u = [\\,3,4,5\\,]$, $W = 10$, $U = 12$.\n- Test case $2$: $n = 2$, $v = [\\,3,5\\,]$, $w = [\\,1,2\\,]$, $u = [\\,1,2\\,]$, $W = 0$, $U = 0$.\n- Test case $3$: $n = 2$, $v = [\\,2,6\\,]$, $w = [\\,0,5\\,]$, $u = [\\,3,2\\,]$, $W = 10$, $U = 10$.\n- Test case $4$: $n = 2$, $v = [\\,9,3\\,]$, $w = [\\,4,1\\,]$, $u = [\\,5,2\\,]$, $W = 100$, $U = 9$.\n- Test case $5$: $n = 2$, $v = [\\,2,3\\,]$, $w = [\\,1,2\\,]$, $u = [\\,1,2\\,]$, $W = 4$, $U = 4$.\n- Test case $6$: $n = 1$, $v = [\\,1\\,]$, $w = [\\,0\\,]$, $u = [\\,0\\,]$, $W = 5$, $U = 5$. This case has unbounded optimal value and must return $-1$.\n\nOutput specification:\n- Your program must produce a single line of output containing the results across the six test cases in order, as a comma-separated list enclosed in square brackets. For example, if the results for the six test cases were $a_1, a_2, a_3, a_4, a_5, a_6$, it should print exactly the one line $[a_1,a_2,a_3,a_4,a_5,a_6]$. For this specific test suite, the output should contain integers, and in the unbounded case it must be $-1$.\n- There are no physical units involved.\n\nConstraints and assumptions:\n- Your algorithm must be derived and justified from the definition of optimal substructure and the principle of optimality for unbounded selection with two additive constraints.\n- The solution must be implementable in deterministic polynomial time with respect to $n$, $W$, and $U$, and use finite memory bounded in terms of $W$ and $U$.\n\nYour final deliverable is a complete, runnable program that prints the required single-line output in the format $[\\,\\cdot\\,]$ as specified above.", "solution": "We begin from the fundamental base of dynamic programming (dynamic programming (DP)): the principle of optimality states that an optimal solution to a problem instance can be constructed from optimal solutions of its subproblems when the problem exhibits optimal substructure and overlapping subproblems. In the unbounded knapsack with two resource constraints, this applies because once we decide to take an item, the remaining problem is identical in form with reduced capacities, and the choice does not restrict future availability of the same item.\n\nLet $F(w,u)$ denote the maximum total value achievable with weight capacity $w$ and volume capacity $u$, where $w \\in \\{0,1,\\dots,W\\}$ and $u \\in \\{0,1,\\dots,U\\}$. The boundary conditions follow from definitions:\n- If $w = 0$ or $u = 0$, no positive-weight-and-volume combination can exceed the empty set; thus $F(w,u) \\ge 0$ for all feasible states, with $F(0,0) = 0$. More generally, when no item fits within $(w,u)$, the empty solution yields $F(w,u) = 0$.\n\nOptimal substructure: consider any optimal solution at state $(w,u)$. If it uses zero copies of all items, then $F(w,u) = 0$. Otherwise, it includes at least one copy of some item $i$ with $w_i \\le w$ and $u_i \\le u$. Removing one copy of item $i$ yields a feasible solution to subproblem $(w - w_i, u - u_i)$ with value $F(w,u) - v_i$. By the definition of $F$, the best we can achieve at the subproblem is $F(w - w_i, u - u_i)$; hence any optimal solution that includes item $i$ must have value exactly $v_i + F(w - w_i, u - u_i)$. Among all choices of the first item, the best value is therefore the maximum over all feasible items $i$.\n\nThis reasoning yields the recurrence relation:\n$$\nF(w,u) \\;=\\; \\max\\Bigl( F(w,u), \\; \\max_{1 \\le i \\le n \\atop w_i \\le w,\\; u_i \\le u} \\bigl\\{\\, v_i + F(w - w_i, u - u_i) \\,\\bigr\\} \\Bigr),\n$$\nwith initialization $F(w,u) = 0$ for all states. The outer $\\max$ with $F(w,u)$ simply reflects that not taking any new item maintains feasibility with value at least $0$; in an iterative construction it is sufficient to initialize with $0$ and then repeatedly apply the item transitions.\n\nTo implement unboundedness correctly, we must use a forward (increasing) iteration over capacities for each item so that the same item can be used multiple times within the same item pass. Concretely, for each item $i$, we update all states $(w,u)$ with $w$ from $w_i$ to $W$ and $u$ from $u_i$ to $U$:\n$$\nF(w,u) \\;\\leftarrow\\; \\max\\bigl(F(w,u),\\; v_i + F(w - w_i, u - u_i)\\bigr).\n$$\nThis ensures that when $(w,u)$ is processed, the state $(w - w_i, u - u_i)$ for the same item $i$ has already incorporated the possibility of reusing item $i$ unboundedly. If any item has $w_i = 0$, $u_i = 0$, and $v_i > 0$, then by repeatedly adding that item we can increase the value without consuming capacity; by the pigeonhole principle, the optimal value is unbounded above. We detect this case and return the sentinel value $-1$ as required.\n\nCorrectness follows directly from the principle of optimality: the recurrence enumerates all ways to conclude an optimal construction at $(w,u)$ by appending one feasible item $i$ to an optimal solution of the subproblem $(w - w_i, u - u_i)$, and takes the maximum value among them. Initialization with zeros enforces that selecting no item is always an option. The increasing iteration order over $w$ and $u$ per item ensures unbounded reuse of items.\n\nTime and space complexity: the dynamic programming table has $(W+1)\\times(U+1)$ states. For each of $n$ items, we relax all states once, yielding time complexity $\\mathcal{O}(n \\cdot W \\cdot U)$ and space complexity $\\mathcal{O}(W \\cdot U)$. These bounds are polynomial in the input parameters.\n\nWe now compute the outputs for the provided test suite.\n\n- Test case $1$: $n = 3$, $v = [\\,4,5,7\\,]$, $w = [\\,2,3,4\\,]$, $u = [\\,3,4,5\\,]$, $W = 10$, $U = 12$. The optimal is achieved, for example, by $x_1 = 4$, $x_2 = 0$, $x_3 = 0$, yielding total value $16$ with total weight $8$ and total volume $12$. No better feasible combination exceeds value $16$. Hence the result is $16$.\n- Test case $2$: $W = 0$, $U = 0$ implies only the empty selection is feasible, so the result is $0$.\n- Test case $3$: $v = [\\,2,6\\,]$, $w = [\\,0,5\\,]$, $u = [\\,3,2\\,]$, $W = 10$, $U = 10$. Taking $x_2 = 2$ and $x_1 = 2$ uses total weight $10$ and total volume $10$ and yields value $12 + 4 = 16$. This is optimal for this instance, so the result is $16$.\n- Test case $4$: $v = [\\,9,3\\,]$, $w = [\\,4,1\\,]$, $u = [\\,5,2\\,]$, $W = 100$, $U = 9$. A best mix is one copy of item $1$ and two copies of item $2$ for value $9 + 2 \\cdot 3 = 15$ with total volume $5 + 2 \\cdot 2 = 9$ and total weight $4 + 2 \\cdot 1 = 6$. No combination using only item $2$ can exceed $4$ copies (volume $8$) for value $12$. Therefore the result is $15$.\n- Test case $5$: $v = [\\,2,3\\,]$, $w = [\\,1,2\\,]$, $u = [\\,1,2\\,]$, $W = 4$, $U = 4$. Four copies of item $1$ fit both capacities and yield value $8$, which is optimal. Hence the result is $8$.\n- Test case $6$: $v = [\\,1\\,]$, $w = [\\,0\\,]$, $u = [\\,0\\,]$, $W = 5$, $U = 5$. Since $w_1 = 0$, $u_1 = 0$, and $v_1 > 0$, the optimal value is unbounded. By specification, we output $-1$.\n\nTherefore, the program should output the single line $[16,0,16,15,8,-1]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef unbounded_2d_knapsack(values, weights, volumes, W, U):\n    \"\"\"\n    Compute maximum total value for 2D unbounded knapsack with:\n    - values[i], weights[i], volumes[i] for items i\n    - capacities W (weight) and U (volume)\n\n    Returns:\n        -1 if the optimal value is unbounded due to an item with (w=0,u=0,v>0),\n        otherwise the maximum achievable integer value.\n    \"\"\"\n    n = len(values)\n    # Detect unbounded value case: any item with zero cost in both resources and positive value.\n    for i in range(n):\n        if weights[i] == 0 and volumes[i] == 0 and values[i] > 0:\n            return -1\n\n    # Initialize DP table with zeros: dp[w][u] = best value for capacities (w,u)\n    dp = [[0 for _ in range(U + 1)] for _ in range(W + 1)]\n\n    # For each item, relax states in increasing order to allow unbounded reuse\n    for i in range(n):\n        v_i = values[i]\n        w_i = weights[i]\n        u_i = volumes[i]\n        # If both w_i and u_i are zero and v_i == 0, it has no effect; skip safely.\n        # Otherwise, iterate capacities from item cost to max capacity.\n        for w in range(w_i, W + 1):\n            # For each weight, iterate volumes\n            for u in range(u_i, U + 1):\n                candidate = dp[w - w_i][u - u_i] + v_i\n                if candidate > dp[w][u]:\n                    dp[w][u] = candidate\n    return dp[W][U]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (values, weights, volumes, W, U)\n    test_cases = [\n        # Test case 1\n        ([4, 5, 7], [2, 3, 4], [3, 4, 5], 10, 12),\n        # Test case 2\n        ([3, 5], [1, 2], [1, 2], 0, 0),\n        # Test case 3\n        ([2, 6], [0, 5], [3, 2], 10, 10),\n        # Test case 4\n        ([9, 3], [4, 1], [5, 2], 100, 9),\n        # Test case 5\n        ([2, 3], [1, 2], [1, 2], 4, 4),\n        # Test case 6 (unbounded)\n        ([1], [0], [0], 5, 5),\n    ]\n\n    results = []\n    for values, weights, volumes, W, U in test_cases:\n        result = unbounded_2d_knapsack(values, weights, volumes, W, U)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3221793"}, {"introduction": "Dynamic programming is not just for abstract puzzles; it's a powerful tool for solving tangible engineering problems. This practice [@problem_id:3221710] reframes the unbounded coin change problem to model memory allocation, a core challenge in operating systems. Instead of aiming for an exact sum, your goal is to satisfy a memory request of size $N$ by selecting blocks that minimize wasted space and, secondarily, the number of blocks used, demonstrating the versatility of DP in handling more complex, multi-tiered objectives.", "problem": "You are tasked with modeling internal fragmentation in fixed-size block allocation using the core principles of optimal substructure and dynamic programming in the domain of data structures and algorithms. A memory allocator can allocate any nonnegative number of blocks, each block of size selected from a given multiset of block sizes $\\{b_1,b_2,\\dots,b_k\\}$, where each $b_i$ is a strictly positive integer measured in bytes. Given a request of $N$ bytes, the allocator must allocate a multiset of blocks whose total capacity $S$ is at least $N$, i.e., $S \\ge N$. The internal fragmentation (wasted space) is $W = S - N$. Your task is to choose an allocation that minimizes $W$. Among all allocations that achieve the minimal $W$, you must minimize the number of blocks used. If $N = 0$, the correct allocation uses zero blocks and yields zero waste.\n\nThe problem must be solved purely in mathematical and logical terms:\n- You are given a target request size $N \\in \\mathbb{Z}_{\\ge 0}$ and a set of block sizes $\\{b_1,\\dots,b_k\\} \\subset \\mathbb{Z}_{>0}$.\n- You can use any number (including zero) of each block size.\n- Your objective is to minimize $W = S - N$ where $S = \\sum_{i=1}^k x_i b_i$ with $x_i \\in \\mathbb{Z}_{\\ge 0}$ and $S \\ge N$, subject to the tie-breaker that $\\sum_{i=1}^k x_i$ is minimized among all allocations with minimal $W$.\n\nFundamental base for derivation:\n- Use the definitions of optimal substructure and overlapping subproblems that ground dynamic programming for unbounded selection problems, and the equivalence of unbounded coin change to shortest paths in a graph whose nodes are congruence classes modulo the smallest block size.\n- Do not use any unproven shortcuts; derive your approach from these base principles.\n\nYour program must solve the following test suite. For each test case, return a triple consisting of:\n- the minimal wasted bytes $W$ as a nonnegative integer,\n- the minimal number of blocks used to achieve an allocation with that $W$,\n- the allocation vector $\\langle x_1,\\dots,x_k\\rangle$ where $x_i$ counts blocks of size $b_i$, listed in the same order as the given block sizes.\n\nTest suite:\n- Case $1$: $N = 137$, block sizes $\\langle 16, 32, 64 \\rangle$.\n- Case $2$: $N = 100$, block sizes $\\langle 1, 7, 20, 30 \\rangle$.\n- Case $3$: $N = 55$, block sizes $\\langle 6, 10, 14 \\rangle$.\n- Case $4$: $N = 0$, block sizes $\\langle 8, 16 \\rangle$.\n- Case $5$: $N = 23$, block sizes $\\langle 8 \\rangle$.\n- Case $6$: $N = 1000$, block sizes $\\langle 70, 120, 250 \\rangle$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case result formatted as $[W,B,[x_1,\\dots,x_k]]$ and no spaces anywhere. For example, an output aggregating three cases would look like $[[W_1,B_1,[\\dots]],[W_2,B_2,[\\dots]],[W_3,B_3,[\\dots]]]$ where each $W_i$, $B_i$, and $x_j$ are integers. All outputs are integers in bytes (no physical unit conversion is required). The order of the allocation counts must match the order of the block sizes given in each test case.", "solution": "The problem requires finding an optimal allocation of memory blocks to satisfy a request of size $N$ bytes. The available blocks have sizes from a given multiset $\\{b_1, b_2, \\dots, b_k\\}$. An allocation is a multiset of blocks whose total size $S$ is at least $N$. The optimization is two-tiered:\n1.  Primary Objective: Minimize the internal fragmentation, or waste, defined as $W = S - N$.\n2.  Secondary Objective: For allocations that yield the minimal waste, minimize the total number of blocks used, $B$.\n\nThis is a lexicographical optimization problem on the pair $(W, B)$. Let the block counts be $x_i \\in \\mathbb{Z}_{\\ge 0}$, corresponding to block size $b_i$. The total allocated size is $S = \\sum_{i=1}^k x_i b_i$ and the total block count is $B = \\sum_{i=1}^k x_i$. The problem is to find the vector $\\langle x_1, \\dots, x_k \\rangle$ that minimizes $(S - N, \\sum x_i)$ subject to $S \\ge N$.\n\nThis problem is a variant of the unbounded change-making problem, a classic example that exhibits optimal substructure and overlapping subproblems, making it amenable to dynamic programming.\n\nFirst, we establish the search space for the optimal total size, $S_{opt}$. Let $b_{max} = \\max(\\{b_1, \\dots, b_k\\})$. Any potential optimal sum $S_{opt}$ must lie in the range $N \\le S_{opt} < N + b_{max}$.\nProof: Assume, for the sake of contradiction, that an optimal solution exists with a total size $S_{opt} \\ge N + b_{max}$. Such an allocation must use at least one block, as $S_{opt} \\ge N > 0$ (for non-trivial cases) and all $b_i > 0$. Let $b_j$ be one such block used in the allocation. Since $b_j \\le b_{max}$, we can construct a new allocation by removing this block. The new total size is $S' = S_{opt} - b_j$. The new waste is $W' = S' - N$. We have $S' = S_{opt} - b_j \\ge (N + b_{max}) - b_j \\ge (N + b_{max}) - b_{max} = N$. Thus, the new allocation $S'$ is still valid (i.e., $S' \\ge N$). The new waste $W' = S_{opt} - b_j - N$ is strictly smaller than the original waste $W = S_{opt} - N$, because $b_j > 0$. This contradicts the assumption that $S_{opt}$ was part of a waste-minimizing solution. Therefore, the optimal total size must be in the interval $[N, N + b_{max} - 1]$.\n\nWith the search space for $S$ established, the core subproblem is to find the minimum number of blocks required to achieve any given sum $T$. Let $\\text{Blocks}(T)$ be this minimum number. This is the unbounded change-making problem.\n\nWe define a dynamic programming approach to solve for $\\text{Blocks}(T)$. Let $dp[T]$ store the minimum number of blocks needed to form the sum $T$. To reconstruct the final allocation, we also need to store the last block used to achieve this minimum.\nThe state of our DP will be captured in two arrays:\n1.  `min_blocks[T]`: The minimum number of blocks summing to $T$.\n2.  `parent_block_idx[T]`: The index $i$ of the block $b_i$ that was last added to achieve sum $T$ with `min_blocks[T]` blocks.\n\nThe maximum sum we need to consider is $T_{max} = N + b_{max} - 1$. The DP table will be sized accordingly.\n\nThe recurrence relation is derived from the principle of optimal substructure: an optimal solution for sum $T$ is formed by taking an optimal solution for a smaller sum $T - b_i$ and adding one block of size $b_i$. We choose the block $b_i$ that minimizes the total number of blocks.\n$$\n\\text{min\\_blocks}[T] = 1 + \\min_{i \\in \\{1,\\dots,k\\} \\text{ s.t. } b_i \\le T} \\{\\text{min\\_blocks}[T - b_i]\\}\n$$\nThe base case is $\\text{min\\_blocks}[0] = 0$. All other `min_blocks[T]` are initialized to $\\infty$.\n\nThe overall algorithm is as follows:\n1.  Handle the trivial case: If $N=0$, the optimal solution is $W=0$, $B=0$, and an all-zero allocation vector.\n2.  Determine the maximum block size, $b_{max} = \\max(\\{b_i\\})$, and the maximum sum to compute, $T_{max} = N + b_{max} - 1$.\n3.  Initialize two arrays of size $T_{max} + 1$:\n    - `min_blocks`: `min_blocks[0] = 0`, `min_blocks[T] = \\infty$ for $T > 0$.\n    - `parent_block_idx`: Initialized with a sentinel value (e.g., $-1$).\n4.  Populate the DP arrays by iterating $T$ from $1$ to $T_{max}$. For each $T$, iterate through each block $b_i$ (with index $i$). If $T \\ge b_i$ and $1 + \\text{min\\_blocks}[T - b_i] < \\text{min\\_blocks}[T]$, update `min_blocks[T] = 1 + \\text{min\\_blocks}[T - b_i]$ and `parent_block_idx[T] = i$.\n5.  After the DP table is populated, search for the optimal solution in the range of valid total sums. Initialize a tracker for the best solution found, `best_solution = (W=\\infty, B=\\infty, S=None)`.\n6.  Iterate through candidate sums $S$ from $N$ to $T_{max}$. If a sum $S$ is reachable (i.e., `min_blocks[S] \\neq \\infty$), calculate the current waste $W_{curr} = S - N$ and block count $B_{curr} = \\text{min\\_blocks}[S]$. Compare the pair $(W_{curr}, B_{curr})$ lexicographically with the best found so far. If it is better, update `best_solution`.\n7.  Once the best total sum, $S_{best}$, is identified, reconstruct the allocation vector $\\vec{x}$. Initialize $\\vec{x}$ as a zero vector of size $k$. Start with `current_sum = S_{best}`. While `current_sum > 0$, find the last block used, $i = \\text{parent\\_block\\_idx}[\\text{current\\_sum}]$. Increment $x_i$ and update `current_sum = current\\_sum - b_i`.\n8.  The final result is the best waste $W$, best block count $B$, and the reconstructed allocation vector $\\vec{x}$. If no solution is found in the search range, it implies no allocation is possible, though the problem constraints ensure a solution always exists.\n\nThe reference in the prompt to the graph-based approach on congruence classes modulo the smallest block size, $b_{min}$, is an advanced optimization for the change-making problem, often implemented with Dijkstra's algorithm. It is particularly effective when $N$ is very large compared to the block sizes. The standard DP approach described here is more direct, equally valid from first principles, and sufficient for the given constraints, as it correctly identifies the optimal solution within the proven search bound of $N + b_{max} - 1$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the memory allocation optimization problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        (137, [16, 32, 64]),\n        (100, [1, 7, 20, 30]),\n        (55, [6, 10, 14]),\n        (0, [8, 16]),\n        (23, [8]),\n        (1000, [70, 120, 250]),\n    ]\n\n    results = []\n    for N, block_sizes in test_cases:\n        # Handle the trivial case N=0\n        if N == 0:\n            results.append([0, 0, [0] * len(block_sizes)])\n            continue\n\n        # Sort block sizes to potentially speed up inner loop.\n        # Store original indices to reconstruct allocation vector correctly.\n        indexed_blocks = sorted([(size, i) for i, size in enumerate(block_sizes)])\n        sorted_block_sizes = [b for b, i in indexed_blocks]\n        \n        # Determine the search space for the total sum S\n        b_max = sorted_block_sizes[-1] if sorted_block_sizes else 0\n        T_max = N + b_max - 1\n\n        # DP tables\n        # min_blocks[T] = minimum number of blocks to sum to T\n        # parent_block_idx[T] = index in sorted_block_sizes of the last block added\n        min_blocks = np.full(T_max + 1, np.inf, dtype=float)\n        parent_block_idx = np.full(T_max + 1, -1, dtype=int)\n\n        # Base case\n        min_blocks[0] = 0\n\n        # Populate DP table\n        for T in range(1, T_max + 1):\n            for i, b_size in enumerate(sorted_block_sizes):\n                if T >= b_size:\n                    if 1 + min_blocks[T - b_size] < min_blocks[T]:\n                        min_blocks[T] = 1 + min_blocks[T - b_size]\n                        parent_block_idx[T] = i\n                else:\n                    # Since block sizes are sorted, we can break early\n                    break\n        \n        # Find the optimal solution (minimal waste, then minimal blocks)\n        best_W = np.inf\n        best_B = np.inf\n        best_S = -1\n\n        for S in range(N, T_max + 1):\n            if min_blocks[S] != np.inf:\n                current_W = S - N\n                current_B = int(min_blocks[S])\n                \n                if current_W < best_W:\n                    best_W = current_W\n                    best_B = current_B\n                    best_S = S\n                elif current_W == best_W and current_B < best_B:\n                    best_B = current_B\n                    best_S = S\n        \n        # Reconstruct the allocation vector\n        allocation_vector_sorted = [0] * len(sorted_block_sizes)\n        if best_S != -1:\n            current_sum = best_S\n            while current_sum > 0:\n                block_idx_sorted = parent_block_idx[current_sum]\n                block_size = sorted_block_sizes[block_idx_sorted]\n                allocation_vector_sorted[block_idx_sorted] += 1\n                current_sum -= block_size\n        \n        # Un-sort the allocation vector to match original block_sizes order\n        final_allocation_vector = [0] * len(block_sizes)\n        for i in range(len(sorted_block_sizes)):\n            original_index = indexed_blocks[i][1]\n            final_allocation_vector[original_index] = allocation_vector_sorted[i]\n\n        results.append([best_W, best_B, final_allocation_vector])\n\n    # Format the final output string exactly as required\n    result_strings = []\n    for r in results:\n        w, b, alloc = r\n        alloc_str = f\"[{','.join(map(str, alloc))}]\"\n        result_strings.append(f\"[{w},{b},{alloc_str}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3221710"}, {"introduction": "What happens when our choices are not independent? This advanced practice [@problem_id:3221711] introduces prerequisite dependencies, a common feature in project planning and resource management, to the unbounded knapsack problem. This scenario requires more than just tracking capacity; you must also know which items have been \"unlocked.\" You will learn the powerful technique of state augmentation, using a bitmask to encode the set of available items and enriching the DP state to enforce complex logical rules.", "problem": "Consider the unbounded knapsack problem under prerequisite dependencies between item types. You are given a finite set of item types indexed by integers from $0$ to $n-1$. Each item type $i$ has a strictly positive integer weight $w_i$ and a strictly positive integer value $v_i$. Let the integer capacity of the knapsack be $W$. In the standard unbounded knapsack setting, any nonnegative number of copies of each item can be chosen, subject only to the total weight not exceeding capacity $W$. In this variant, there is an additional structural constraint: some items may require at least one copy of another item to be chosen before they are available. Formally, for each item $i$ there is a dependency descriptor $d[i]$; if $d[i] = -1$, item $i$ has no prerequisite, and if $d[i] = j \\ge 0$, then item $i$ can be chosen only if the count of item $j$ is at least one. No item has zero weight, and the dependency relation is acyclic so that there are no circular prerequisites.\n\nStarting from the following fundamental base in data structures and algorithms:\n- The unbounded knapsack and coin change settings are grounded in the principles of optimal substructure and overlapping subproblems. For weight-bounded packing with reusable items, dynamic programming over capacities is a well-tested approach that constructs optimal solutions by extending optimal subsolutions.\n\nYour task is to design and implement a complete, runnable program that computes, for each provided test case, the maximum achievable total value under these dependency constraints. The program must reason from first principles, beginning with the definitions of feasible solutions and capacity-bounded accumulation of value, and derive an algorithm that enumerates the space of valid multisets of items while respecting the prerequisite relation. Do not assume any shortcut formulas not justified by those core principles.\n\nThe objective for a given test case is to compute\n$$\n\\max \\sum_{i=0}^{n-1} x_i \\cdot v_i\n$$\nsubject to\n$$\n\\sum_{i=0}^{n-1} x_i \\cdot w_i \\le W,\\quad x_i \\in \\mathbb{Z}_{\\ge 0},\n$$\nand for every $i$ with $d[i] = j \\ge 0$, the constraint\n$$\nx_i > 0 \\implies x_j \\ge 1.\n$$\n\nThere are no physical units involved. All inputs are integers, and all outputs must be integers.\n\nImplement the program with the following test suite. Each test case is a tuple $(W, w, v, d)$, where $W$ is the capacity, $w$ is the list of weights, $v$ is the list of values, and $d$ is the list of dependencies:\n\n- Test case $1$ (general happy path with a dependency chain):\n  - $W = 10$\n  - $w = [2, 3, 5]$\n  - $v = [3, 4, 10]$\n  - $d = [-1, 0, 1]$\n- Test case $2$ (dependency cannot be satisfied due to capacity, other items available):\n  - $W = 10$\n  - $w = [11, 8, 5]$\n  - $v = [100, 90, 9]$\n  - $d = [-1, 0, -1]$\n- Test case $3$ (boundary condition with zero capacity):\n  - $W = 0$\n  - $w = [1, 2]$\n  - $v = [2, 3]$\n  - $d = [-1, 0]$\n- Test case $4$ (two independent prerequisite branches; choose optimally):\n  - $W = 12$\n  - $w = [4, 6, 3, 4]$\n  - $v = [8, 13, 5, 9]$\n  - $d = [-1, 0, -1, 2]$\n- Test case $5$ (activation cost unlocks high-value dependent items):\n  - $W = 14$\n  - $w = [2, 7, 5]$\n  - $v = [1, 20, 12]$\n  - $d = [-1, 0, -1]$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, the output format must be exactly $[r_1,r_2,r_3,r_4,r_5]$, where $r_k$ is the integer answer for test case $k$ in the order listed above.", "solution": "We begin from the foundational principles of unbounded knapsack and coin change problems. The unbounded knapsack problem relies on optimal substructure: an optimal solution for capacity $W$ can be constructed by extending optimal solutions for smaller capacities. Coin change formulations similarly employ dynamic programming over capacity, exploiting overlapping subproblems. In the standard unbounded knapsack without dependencies, one uses a dynamic programming array over capacities where repeatedly adding items grows the solution while respecting the capacity bound.\n\nIn our setting, the prerequisite dependency introduces a logical constraint coupling item types: an item $i$ is available only if a specific parent item $j = d[i]$ has been chosen at least once. To incorporate this constraint rigorously, we must track not only the remaining capacity but also which items have been chosen at least once. The key insight is that for the dependency condition $x_i > 0 \\implies x_j \\ge 1$, the availability of item $i$ depends on whether $j$ has occurred at least once in the partial solution. Therefore, a natural state augmentation is to record, for any partial selection, the set of item types that have occurred at least once.\n\nLet $n$ be the number of item types. We define a dynamic programming state\n$$\n\\mathrm{dp}[c][S] = \\text{maximum total value achievable with total weight exactly } c \\text{ and with the set of items used at least once equal to } S,\n$$\nwhere $c \\in \\{0,1,\\dots,W\\}$ and $S \\subseteq \\{0,1,\\dots,n-1\\}$ is represented as a bitmask. We initialize $\\mathrm{dp}[0][\\emptyset] = 0$ and $\\mathrm{dp}[c][S] = -\\infty$ for all other $(c,S)$, as no value is achievable with positive weight without adding items.\n\nThe transition is justified by the optimal substructure property. Suppose we have a feasible partial solution represented by $\\mathrm{dp}[c][S]$ and we consider adding one copy of item $i$ with weight $w_i$ and value $v_i$. This extension is valid if and only if:\n- The new total weight does not exceed capacity: $c + w_i \\le W$.\n- The dependency is satisfied: either $d[i] = -1$ (no prerequisite), or $d[i] = j \\ge 0$ and $j \\in S$ (meaning at least one copy of the prerequisite item $j$ has already been chosen).\n\nIf the extension is valid, the resulting state is\n$$\n\\mathrm{dp}[c + w_i][S \\cup \\{i\\}] \\leftarrow \\max\\left(\\mathrm{dp}[c + w_i][S \\cup \\{i\\}],\\ \\mathrm{dp}[c][S] + v_i\\right).\n$$\nThis transition reflects the fundamental pattern of coin change dynamic programming: from every reachable capacity $c$ we can move forward to $c + w_i$ by adding item $i$, and because we sweep $c$ from $0$ upward, items can be added repeatedly, thus modeling the unbounded setting. The augmented set $S$ ensures that availability constraints are enforced: an item $i$ may only be added if its prerequisite $j$ is already in $S$, which encodes $x_j \\ge 1$ in the partial solution. The set $S$ records whether each item has appeared at least once, which suffices to guard the implication $x_i > 0 \\implies x_j \\ge 1$, independent of the exact counts.\n\nThe algorithm proceeds as follows:\n- Initialize $\\mathrm{dp}[0][\\emptyset] = 0$ and all other entries to $-\\infty$.\n- For $c$ from $0$ to $W$:\n  - For each bitmask $S$:\n    - If $\\mathrm{dp}[c][S]$ is finite (i.e., greater than $-\\infty$), consider each item $i \\in \\{0,1,\\dots,n-1\\}$:\n      - Check if $d[i] = -1$ or the bit for $d[i]$ is set in $S$.\n      - If so and $c + w_i \\le W$, update $\\mathrm{dp}[c + w_i][S \\cup \\{i\\}]$ with $\\mathrm{dp}[c][S] + v_i$.\n- The result is the maximum value over all capacities up to $W$ and all sets $S$:\n$$\n\\max_{0 \\le c \\le W} \\max_{S \\subseteq \\{0,\\dots,n-1\\}} \\mathrm{dp}[c][S].\n$$\n\nCorrectness is established by induction on capacity. Base case: with capacity $0$, only the empty set $S = \\emptyset$ is feasible and $\\mathrm{dp}[0][\\emptyset] = 0$. Inductive step: assume for all capacities $\\le c$ the array accurately reflects the best achievable values for each $S$. For capacity $c+ w_i$, the transition considers all ways to reach $c$ and then add one copy of $i$ subject to prerequisites; because prerequisites are enforced using the set $S$, every extension remains feasible, and because we take the maximum over all possible predecessor states $S$ for all items $i$, we capture the best attainable value for the new capacity. Repeated additions are enabled by sweeping $c$ in increasing order, ensuring the unbounded nature of item choices. The dependency relation being acyclic prevents pathological cycles of prerequisite enforcement, and weights being strictly positive avoids infinite loops of zero-weight additions.\n\nThe time complexity for one test case is $O\\left(W \\cdot 2^n \\cdot n\\right)$, which is acceptable for small $n$ and moderate $W$ in an advanced undergraduate context, and it provides clear coverage of the state space necessary to enforce prerequisite availability.\n\nApplying this algorithm to the specified test suite yields integer outputs for each case, and the program aggregates those outputs in the required single-line format $[r_1,r_2,r_3,r_4,r_5]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef max_value_with_dependencies(W, weights, values, deps):\n    \"\"\"\n    Compute the maximum achievable value for an unbounded knapsack with\n    prerequisite dependencies. Each item i can be chosen only if deps[i] == -1\n    or at least one copy of item deps[i] has already been chosen.\n    Dynamic programming state: dp[c][mask] = max value using total weight c\n    and items used at least once encoded by bitmask 'mask'.\n    \"\"\"\n    n = len(weights)\n    # Initialize DP with -inf for impossible states\n    NEG_INF = -10**15\n    dp = [[NEG_INF] * (1 << n) for _ in range(W + 1)]\n    dp[0][0] = 0\n\n    # Iterate capacities and masks; transition by adding one item i if allowed\n    for c in range(W + 1):\n        for mask in range(1 << n):\n            current = dp[c][mask]\n            if current == NEG_INF:\n                continue\n            for i in range(n):\n                prereq = deps[i]\n                # Check if prerequisite is satisfied\n                if prereq != -1:\n                    if (mask & (1 << prereq)) == 0:\n                        continue\n                new_c = c + weights[i]\n                if new_c <= W:\n                    new_mask = mask | (1 << i)\n                    if dp[new_c][new_mask] < current + values[i]:\n                        dp[new_c][new_mask] = current + values[i]\n\n    # Best over all capacities <= W and all masks\n    best = max(max(row) for row in dp)\n    return int(best)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (W, weights, values, deps)\n    test_cases = [\n        (10, [2, 3, 5], [3, 4, 10], [-1, 0, 1]),\n        (10, [11, 8, 5], [100, 90, 9], [-1, 0, -1]),\n        (0, [1, 2], [2, 3], [-1, 0]),\n        (12, [4, 6, 3, 4], [8, 13, 5, 9], [-1, 0, -1, 2]),\n        (14, [2, 7, 5], [1, 20, 12], [-1, 0, -1]),\n    ]\n\n    results = []\n    for W, weights, values, deps in test_cases:\n        result = max_value_with_dependencies(W, weights, values, deps)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3221711"}]}