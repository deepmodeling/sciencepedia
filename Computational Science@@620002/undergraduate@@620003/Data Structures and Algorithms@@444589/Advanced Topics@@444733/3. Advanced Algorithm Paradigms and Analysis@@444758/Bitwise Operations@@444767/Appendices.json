{"hands_on_practices": [{"introduction": "Mastery of any concept begins with its fundamentals. This first practice is a direct exercise in applying the core bitwise operations—`AND`, `OR`, and `XOR`—to integers. By manually converting numbers to their binary form and manipulating them bit by bit, you will build a concrete intuition for how these logical operators work at the lowest level, a skill that is essential for all subsequent applications [@problem_id:15138].", "problem": "In digital systems and logic, operations can be performed on the binary representations of integers. These are known as bitwise operations. This problem requires the use of three fundamental bitwise operations: `AND`, `OR`, and `XOR`.\n\nThe operations are defined for single bits as follows:\n- **`AND`**: The result is 1 only if both input bits are 1.\n  - `0 AND 0 = 0`\n  - `0 AND 1 = 0`\n  - `1 AND 0 = 0`\n  - `1 AND 1 = 1`\n- **`OR`**: The result is 1 if at least one of the input bits is 1.\n  - `0 OR 0 = 0`\n  - `0 OR 1 = 1`\n  - `1 OR 0 = 1`\n  - `1 OR 1 = 1`\n- **`XOR` (Exclusive OR)**: The result is 1 only if the input bits are different.\n  - `0 XOR 0 = 0`\n  - `0 XOR 1 = 1`\n  - `1 XOR 0 = 1`\n  - `1 XOR 1 = 0`\n\nTo apply these operations to integers, each integer is first converted to its binary (base-2) representation. The operation is then performed on each pair of corresponding bits. For this problem, if the binary representations have different lengths, the shorter one should be padded with leading zeros to match the length of the longer one. The resulting binary string is then converted back to a decimal (base-10) integer.\n\nGiven the integers $A = 29$ and $B = 14$, derive the final integer value of the expression `(A OR B) XOR (A AND B)`.", "solution": "We have the integers \n$$A=29,\\quad B=14.$$\nStep 1: Convert to binary (padding $B$ to 5 bits):\n$$29_{10}=(11101)_2,\\qquad 14_{10}=(01110)_2.$$\nStep 2: Compute bitwise OR:\n$$(11101)_2\\;{\\rm OR}\\;(01110)_2=(11111)_2.$$\nStep 3: Compute bitwise AND:\n$$(11101)_2\\;{\\rm AND}\\;(01110)_2=(01100)_2.$$\nStep 4: Compute the XOR of these two results:\n$$(11111)_2\\;{\\rm XOR}\\;(01100)_2=(10011)_2.$$\nStep 5: Convert back to decimal:\n$$(10011)_2=1\\cdot2^4+0\\cdot2^3+0\\cdot2^2+1\\cdot2^1+1\\cdot2^0=16+2+1=19.$$\nHence\n$$(A\\;{\\rm OR}\\;B)\\;{\\rm XOR}\\;(A\\;{\\rm AND}\\;B)=19.$$", "answer": "$$\\boxed{19}$$", "id": "15138"}, {"introduction": "Beyond simple calculation, the true power of bitwise operations lies in their algebraic properties. This practice introduces a classic and elegant algorithm that leverages the unique characteristics of the XOR operator, specifically its self-inverse property ($a \\oplus a = 0$). You will see how these properties can be exploited to solve a common data-finding problem with remarkable efficiency, requiring only a single pass through the data and no extra memory [@problem_id:3275306].", "problem": "You are given a static array, that is, a contiguous block of memory with a fixed length, in which every element appears exactly twice except for one element that appears exactly once. The goal is to identify that single element using only bitwise exclusive-or operations. A static array supports constant-time random access, and its logical model is that the elements occupy consecutive indices starting at $0$ and ending at $n-1$, where $n$ denotes the number of elements.\n\nStart from the following fundamental base for discrete binary operations and static arrays:\n- A static array $A$ of length $n$ is a sequence $(A[0], A[1], \\dots, A[n-1])$ stored contiguously, and its size $n$ does not change.\n- Bitwise exclusive-or (denoted $\\oplus$) is a binary operation on integers defined bitwise on their two's complement representation, with the well-tested algebraic facts: $a \\oplus a = 0$, $a \\oplus 0 = a$, commutativity $a \\oplus b = b \\oplus a$, and associativity $(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)$.\n\nDerive, from these principles without relying on any shortcut formulas, an algorithm that computes the single element that appears once. Your algorithm must:\n- Read a static array $A$ and produce an integer.\n- Use only the bitwise exclusive-or operation $\\oplus$ to combine array elements; do not use any hashing, sorting, or auxiliary data structures beyond $O(1)$ additional memory.\n- Run in time $O(n)$ and space $O(1)$.\n\nNo physical units, angles, or percentages are involved in this problem.\n\nFor testability, apply your algorithm to the following test suite of static arrays, each satisfying the condition that every element except one appears exactly twice:\n- Test $1$: the array $[\\,2,\\,1,\\,4,\\,5,\\,2,\\,4,\\,1\\,]$.\n- Test $2$: the array $[\\,42\\,]$.\n- Test $3$: the array $[\\,{-7},\\,{-7},\\,0,\\,0,\\,{-3}\\,]$.\n- Test $4$: the array $[\\,2147483647,\\,99,\\,2147483647\\,]$.\n- Test $5$: the array $[\\,8,\\,9,\\,9,\\,10,\\,10,\\,11,\\,11,\\,12,\\,12,\\,8,\\,13\\,]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Concretely, if the results for Tests $1$ through $5$ are $r_1, r_2, r_3, r_4, r_5$ respectively, print the line\n$[r_1,r_2,r_3,r_4,r_5]$.", "solution": "The problem has been validated and is determined to be sound. It is scientifically grounded, well-posed, and objective. The problem is a formalizable exercise in algorithm design based on the mathematical properties of bitwise operations. All necessary information is provided, and the constraints are consistent and clear.\n\nThe objective is to devise an algorithm to identify the unique element in a static array $A$ of length $n$, where all other elements appear exactly twice. The algorithm is constrained to use only the bitwise exclusive-or (XOR) operation, denoted by $\\oplus$, for combining elements. It must operate in $O(n)$ time and $O(1)$ space.\n\nThe derivation of the algorithm proceeds from the fundamental algebraic properties of the XOR operation provided in the problem statement:\n1.  Self-inverse property: $a \\oplus a = 0$ for any integer $a$.\n2.  Identity element: $a \\oplus 0 = a$ for any integer $a$.\n3.  Commutativity: $a \\oplus b = b \\oplus a$ for any integers $a, b$.\n4.  Associativity: $(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)$ for any integers $a, b, c$.\n\nConsider the result $R$ obtained by applying the XOR operation across all elements of the array $A$:\n$$ R = A[0] \\oplus A[1] \\oplus \\dots \\oplus A[n-1] = \\bigoplus_{i=0}^{n-1} A[i] $$\nThe problem states that the array consists of a multiset of numbers where each element appears twice, except for one unique element. Let the set of distinct elements that appear twice be $\\{v_1, v_2, \\dots, v_k\\}$, and let the unique element be $u$. The array $A$ is therefore a permutation of the multiset $\\{v_1, v_1, v_2, v_2, \\dots, v_k, v_k, u\\}$.\n\nDue to the commutative and associative properties of XOR, the order of operations in the total XOR-sum does not affect the final result. We can re-group the elements of the array to pair identical values:\n$$ R = (v_1 \\oplus v_1) \\oplus (v_2 \\oplus v_2) \\oplus \\dots \\oplus (v_k \\oplus v_k) \\oplus u $$\nApplying the self-inverse property, $a \\oplus a = 0$, to each pair:\n$$ v_i \\oplus v_i = 0 \\quad \\text{for } i = 1, \\dots, k $$\nSubstituting this result into the expression for $R$:\n$$ R = 0 \\oplus 0 \\oplus \\dots \\oplus 0 \\oplus u $$\nThe XOR-sum of any number of $0$s is $0$. Therefore, the expression simplifies to:\n$$ R = 0 \\oplus u $$\nFinally, applying the identity property, $a \\oplus 0 = a$:\n$$ R = u $$\nThis derivation rigorously demonstrates that the XOR-sum of all elements in the array is precisely equal to the unique element, $u$.\n\nThis leads to the following algorithm:\n1.  Initialize an accumulator variable to $0$, which is the identity element for the XOR operation.\n2.  Iterate through the array $A$ from index $i=0$ to $n-1$.\n3.  For each element $A[i]$, update the accumulator by computing `accumulator = accumulator` $\\oplus$ `A[i]`.\n4.  After the iteration is complete, the final value of the accumulator is the unique element.\n\nThis algorithm accesses each of the $n$ elements once, performing a constant-time XOR operation for each. Thus, its time complexity is $O(n)$. The algorithm requires only a single variable for the accumulator, so its space complexity is $O(1)$. These complexities satisfy the problem's requirements.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies an algorithm to find the single unique element in arrays\n    where all other elements appear twice, using only bitwise XOR operations.\n    \"\"\"\n\n    def find_unique_element(arr: np.ndarray) - np.int64:\n        \"\"\"\n        Computes the unique element in an array by XORing all its elements.\n\n        This method is based on the algebraic properties of XOR:\n        1. a ^ a = 0 (self-inverse)\n        2. a ^ 0 = a (identity)\n        3. a ^ b = b ^ a (commutativity)\n        4. (a ^ b) ^ c = a ^ (b ^ c) (associativity)\n\n        The XOR sum of all elements simplifies to the unique element because all\n        paired elements cancel each other out (e.g., v1^v1^v2^v2^u = 0^0^u = u).\n\n        Args:\n            arr: A NumPy array of integers where one element appears once\n                 and all others appear twice.\n\n        Returns:\n            The integer that appears exactly once in the array.\n        \"\"\"\n        # The identity element for the XOR operation is 0.\n        # We use a fixed-size integer type consistent with a static array model.\n        accumulator = np.int64(0)\n        \n        # Iterate through all elements of the array.\n        for element in arr:\n            # Update the accumulator by XORing it with the current element.\n            accumulator ^= element\n            \n        return accumulator\n\n    # Define the test cases from the problem statement.\n    # The arrays are defined with a 64-bit integer type to accommodate the\n    # full range of values including negatives and large numbers.\n    test_cases = [\n        np.array([2, 1, 4, 5, 2, 4, 1], dtype=np.int64),\n        np.array([42], dtype=np.int64),\n        np.array([-7, -7, 0, 0, -3], dtype=np.int64),\n        np.array([2147483647, 99, 2147483647], dtype=np.int64),\n        np.array([8, 9, 9, 10, 10, 11, 11, 12, 12, 8, 13], dtype=np.int64),\n    ]\n\n    results = []\n    for case in test_cases:\n        # For each test case, apply the derived algorithm.\n        unique_element = find_unique_element(case)\n        results.append(unique_element)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3275306"}, {"introduction": "While elegant tricks are powerful, they often apply only to specific scenarios. True expertise comes from developing general methods that work under broader conditions. This advanced practice challenges you to solve a more complex version of the previous problem where the simple XOR-sum trick no longer applies [@problem_id:3275306]. You will learn to reconstruct a number bit by bit, combining bitwise analysis with modular arithmetic to devise a robust algorithm that is a cornerstone of advanced bit manipulation techniques [@problem_id:3217582].", "problem": "You are asked to design and implement an algorithm grounded in bitwise operations to recover a single integer that has a different multiplicity than all others in a multiset. Let there be an integer array containing signed $64$-bit integers where every distinct integer appears exactly $k$ times, except one integer that appears exactly $p$ times, with $1 \\le p  k$. The goal is to compute this unique integer in time linear in the number of elements and constant auxiliary space with respect to the input size, based on first principles of binary representation and modular arithmetic, without relying on hashing or sorting. All integers in the input are guaranteed to fit within the signed $64$-bit range, that is, within $\\left[-2^{63},2^{63}-1\\right]$.\n\nFundamental base to use:\n- The binary representation of integers and bitwise operations, including bitwise AND, bitwise OR, and bit shifts, on fixed-width words of $64$ bits, with signed values encoded using two’s complement.\n- Modular arithmetic over a modulus $k$, in particular the distributivity of modular reduction across sums.\n- The semantics of bits in two’s complement, including the Most Significant Bit (MSB) at position $63$ indicating sign, and the Least Significant Bit (LSB) at position $0$.\n\nYour program must compute the unique integer for each of the following test cases, each specified as a triple $\\left(\\text{array},k,p\\right)$:\n- Test case $1$: $\\left(\\left[2,2,2,7,-1,-1,-1,42,42,42\\right],3,1\\right)$\n- Test case $2$: $\\left(\\left[13,13,0,0,0,0,0,-4,-4,-4,-4,-4,22,22,22,22,22\\right],5,2\\right)$\n- Test case $3$: $\\left(\\left[0,0,0,5,5,5,5,-7,-7,-7,-7\\right],4,3\\right)$\n- Test case $4$: $\\left(\\left[-15,-15,-15,-15,-15,-15,1,1,1,1,1,1,1,3,3,3,3,3,3,3\\right],7,6\\right)$\n- Test case $5$: $\\left(\\left[-8,-8,17,17,1152921504606847099\\right],2,1\\right)$ where $1152921504606847099=2^{60}+123$.\n- Test case $6$: $\\left(\\left[-4611686018427387897,-4611686018427387897,9,9,9,0,0,0\\right],3,2\\right)$ where $-4611686018427387897=-2^{62}+7$.\n\nYour algorithm must not assume any property beyond the stated multiplicities and the fixed-word two’s complement model, and it must reconstruct the answer by reasoning on the bit-level structure and modular properties. The final output for the entire test suite must be an integer list corresponding to the unique number for each test case, produced on a single line, as a comma-separated list enclosed in square brackets. For example, the output format must be $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\ldots\\right]$. No physical units, angles, or percentages appear in this problem; all outputs are plain integers.", "solution": "The problem statement is rigorously validated and found to be self-contained, scientifically grounded, well-posed, and objective. It is a formal problem in algorithm design based on fundamental principles of computer science and mathematics.\n\nThe core principle for solving this problem is to reconstruct the unique integer bit by bit. This can be achieved by analyzing the sum of bits at each position across all numbers in the array, using the properties of modular arithmetic. The integers are signed $64$-bit values, which means we must consider a bit width of $W=64$. The problem's constraints on time ($O(N)$, where $N$ is the number of elements) and space ($O(1)$) preclude sorting or using an auxiliary data structure like a hash map.\n\nLet the input array be denoted by $A$. The array contains a multiset of integers where every distinct number appears $k$ times, except for a single unique integer, let's call it $x$, which appears $p$ times, with $1 \\le p  k$. Let the set of other distinct integers be $\\{y_1, y_2, \\ldots, y_m\\}$.\n\nConsider a single bit position $j$, where $j$ ranges from $0$ (the Least Significant Bit, LSB) to $63$ (the Most Significant Bit, MSB). Let $b_j(n) \\in \\{0, 1\\}$ be the value of the $j$-th bit of an integer $n$. The algorithm's foundation is to compute the sum of the $j$-th bits for all numbers in the array $A$. Let this sum be $S_j$:\n$$ S_j = \\sum_{n \\in A} b_j(n) $$\nThis sum can be partitioned based on the multiplicities of the numbers. The unique number $x$ contributes $p \\cdot b_j(x)$ to this sum, and each of the other numbers $y_i$ contributes $k \\cdot b_j(y_i)$. Thus, the total sum can be expressed as:\n$$ S_j = p \\cdot b_j(x) + \\sum_{i=1}^{m} k \\cdot b_j(y_i) = p \\cdot b_j(x) + k \\sum_{i=1}^{m} b_j(y_i) $$\nThe second term, $k \\sum_{i=1}^{m} b_j(y_i)$, is by definition an integer multiple of $k$. Let $N_j = \\sum_{i=1}^{m} b_j(y_i)$, which is simply the count of \"non-unique\" numbers that have the $j$-th bit set. The equation becomes:\n$$ S_j = p \\cdot b_j(x) + k \\cdot N_j $$\nNow, we apply modular arithmetic with modulus $k$. Taking the equation modulo $k$:\n$$ S_j \\pmod k = (p \\cdot b_j(x) + k \\cdot N_j) \\pmod k $$\nUsing the property of modular addition, $(a+b) \\pmod k = ((a \\pmod k) + (b \\pmod k)) \\pmod k$:\n$$ S_j \\pmod k = (p \\cdot b_j(x) \\pmod k + k \\cdot N_j \\pmod k) \\pmod k $$\nSince $k \\cdot N_j \\pmod k = 0$, the equation simplifies to:\n$$ S_j \\pmod k = (p \\cdot b_j(x)) \\pmod k $$\nWe must determine the value of $b_j(x)$, which can only be $0$ or $1$.\nCase 1: The $j$-th bit of the unique number $x$ is $0$, i.e., $b_j(x) = 0$.\nIn this case, the equation becomes $S_j \\pmod k = (p \\cdot 0) \\pmod k = 0$.\nCase 2: The $j$-th bit of the unique number $x$ is $1$, i.e., $b_j(x) = 1$.\nIn this case, the equation becomes $S_j \\pmod k = (p \\cdot 1) \\pmod k = p \\pmod k$.\nGiven the problem constraint $1 \\le p  k$, we know that $p$ is not a multiple of $k$, and specifically $p \\pmod k = p$. Therefore, if $b_j(x)=1$, then $S_j \\pmod k = p$, which is non-zero.\n\nCombining these two cases gives a clear decision rule:\n- If $S_j \\pmod k = 0$, then $b_j(x)$ must be $0$.\n- If $S_j \\pmod k \\neq 0$, then $b_j(x)$ must be $1$.\n\nThis logic allows us to determine each bit of the unique number $x$ independently. The algorithm proceeds as follows:\n1. Initialize a $64$-bit result integer, `result`, to $0$.\n2. Iterate for each bit position $j$ from $0$ to $63$.\n3. For each $j$, compute the sum of the $j$-th bits of all numbers in the input array, $S_j$.\n4. Evaluate $S_j \\pmod k$.\n5. If the result is non-zero, it signifies that the $j$-th bit of the unique number $x$ is $1$. In this case, set the $j$-th bit of `result` using a bitwise OR operation with a mask: `result |= (1  j)`.\n\nThis procedure holds for signed integers in two's complement representation. The bitwise logic operates on the binary representation of the numbers, and the counting property is independent of whether a bit is part of a positive or negative number's representation. When a number is negative, its two's complement representation is used. Summing the bits at each position correctly accounts for the contribution from all numbers, positive or negative. After iterating through all $64$ bits, the `result` variable will hold the complete $64$-bit two's complement representation of the unique number $x$.\n\nThe implementation must carefully handle $64$-bit signed integers. Since standard Python integers have arbitrary precision, we will use `numpy.int64` and `numpy.uint64` to enforce the fixed-width semantics specified in the problem, particularly for bitwise operations like shifting and masking, ensuring that sign extension and bit patterns are handled correctly.\nFor each number `num` from the input and for each bit position `j`, we extract its $j$-th bit. This is reliably done by casting `num` to an unsigned $64$-bit integer, `numpy.uint64(num)`, and then using bitwise operations. This prevents sign extension issues with right shifts on negative numbers. The final accumulated bit pattern, stored in a `numpy.uint64` variable, is cast back to `numpy.int64` to yield the final signed integer result.\n\nThe time complexity is determined by two nested loops. The outer loop runs a constant $64$ times. The inner loop iterates over the $N$ elements of the input array. This gives a total time complexity of $O(64 \\cdot N)$, which is $O(N)$. The space complexity is $O(1)$ as we only use a few variables of fixed size (e.g., for the bit sum and the result) regardless of the input size $N$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_unique_integer(arr, k, p):\n    \"\"\"\n    Finds the integer that appears p times in an array where all other\n    distinct integers appear k times.\n\n    The algorithm reconstructs the unique integer bit by bit. For each bit\n    position j from 0 to 63, it sums the j-th bits of all numbers in the\n    array. Let this sum be S_j. The sum of bits from numbers that appear k\n    times will be a multiple of k. Thus, S_j mod k will reveal the j-th\n    bit of the unique number.\n\n    Specifically, S_j = (p * b_j(x)) + (k * M), where b_j(x) is the j-th\n    bit of the unique number x, and M is an integer.\n    So, S_j mod k = (p * b_j(x)) mod k.\n    Since 1 = p  k, p is not a multiple of k.\n    - If b_j(x) = 0, then S_j mod k = 0.\n    - If b_j(x) = 1, then S_j mod k = p != 0.\n    Thus, a non-zero remainder implies the j-th bit of x is 1.\n\n    Args:\n        arr (list): A list of integers.\n        k (int): The multiplicity of the non-unique numbers.\n        p (int): The multiplicity of the unique number.\n\n    Returns:\n        numpy.int64: The integer with unique multiplicity.\n    \"\"\"\n    \n    # The result is built up as an unsigned 64-bit integer to correctly handle\n    # bitwise operations on all 64 bits, including the sign bit.\n    result_unsigned = np.uint64(0)\n    \n    # Iterate over each of the 64 bit positions\n    for j in range(64):\n        bit_sum = 0\n        \n        # Create a mask to isolate the j-th bit. Must be uint64 to avoid overflow warnings\n        # for j=63, as 1  63 would be negative in signed int64.\n        bit_mask = np.uint64(1)  np.uint64(j)\n        \n        for num_py in arr:\n            # Cast the Python int to a numpy 64-bit signed integer to work with\n            # a fixed-width two's complement representation.\n            num_np = np.int64(num_py)\n            \n            # To check the j-th bit correctly for both positive and negative numbers,\n            # we cast the number's bit pattern to its unsigned equivalent.\n            # This ensures that bitwise operations (like ) treat all bits,\n            # including the MSB (sign bit), uniformly as data.\n            if (np.uint64(num_np)  bit_mask):\n                bit_sum += 1\n        \n        # If the sum of bits at this position is not a multiple of k,\n        # it means the unique number has a '1' at this bit position.\n        if bit_sum % k != 0:\n            # Set the corresponding bit in our result.\n            result_unsigned |= bit_mask\n            \n    # Cast the final unsigned bit pattern back to a signed 64-bit integer.\n    # This correctly reinterprets the two's complement representation.\n    return np.int64(result_unsigned)\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the solver for each, printing the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([2,2,2,7,-1,-1,-1,42,42,42], 3, 1),\n        ([13,13,0,0,0,0,0,-4,-4,-4,-4,-4,22,22,22,22,22], 5, 2),\n        ([0,0,0,5,5,5,5,-7,-7,-7,-7], 4, 3),\n        ([-15,-15,-15,-15,-15,-15,1,1,1,1,1,1,1,3,3,3,3,3,3,3], 7, 6),\n        ([-8,-8,17,17,1152921504606847099], 2, 1),\n        ([-4611686018427387897,-4611686018427387897,9,9,9,0,0,0], 3, 2),\n    ]\n\n    results = []\n    for arr, k, p in test_cases:\n        # The parameter 'p' is not strictly necessary for this implementation\n        # but is passed for completeness according to the problem statement.\n        result = find_unique_integer(arr, k, p)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3217582"}]}