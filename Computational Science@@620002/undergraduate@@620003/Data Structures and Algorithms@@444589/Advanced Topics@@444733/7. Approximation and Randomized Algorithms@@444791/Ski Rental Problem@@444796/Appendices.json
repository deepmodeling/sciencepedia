{"hands_on_practices": [{"introduction": "The standard analysis of the ski rental problem assumes a worst-case scenario against an all-powerful adversary. But what if the adversary has limitations? This practice explores a more nuanced \"lazy adversary\" model, where the adversary can only see a fixed number of days, $L$, into the future. By analyzing this constrained scenario [@problem_id:3272187], you will derive how the competitive ratio improves as the adversary's power diminishes, providing a more optimistic and often more realistic performance guarantee.", "problem": "An online skier decides each morning whether to rent or to buy skis. Renting costs $1$ per day, and buying costs a one-time fee of $b$, where $b \\in \\mathbb{Z}_{\\ge 1}$. The total number of ski days $n \\in \\mathbb{Z}_{\\ge 1}$ is not known to the skier in advance and is chosen by an adversary. Consider the following deterministic threshold family of algorithms parameterized by an integer $T \\in \\mathbb{Z}_{\\ge 0}$: rent for the first $T$ days; if the season continues to day $T+1$, then buy at the start of day $T+1$ and incur no further daily cost.\n\nWe study a constrained, adaptive input generator called a \"lazy adversary\" that can only see $L$ days into the future, where $L \\in \\mathbb{Z}_{\\ge 0}$ is known. To model this limitation in a scientifically meaningful and operational way, impose the following constraint on the adversary: once the algorithm buys (at the start of day $T+1$), the adversary cannot end the season earlier than day $T+L$; that is, if the algorithm buys, the total season length $n$ must satisfy $n \\ge T+L$. If the algorithm never buys, the adversary may end the season on any day.\n\nUsing only the core definitions of online algorithms and competitive analysis, and the evident offline optimal behavior that minimizes total cost given $n$, derive the minimal possible worst-case competitive ratio (that is, the infimum over choices of $T$ of the supremum over $n$ consistent with the lazy adversary constraint of the ratio of the algorithm’s cost to the offline optimal cost) as a closed-form expression in terms of $b$ and $L$. Express your final answer as a single analytic expression in $b$ and $L$. No numerical approximation or rounding is required.", "solution": "We begin from the fundamental definition of competitive analysis in online algorithms. For an online algorithm $\\mathcal{A}$ and an input characterized here by a total season length $n \\in \\mathbb{Z}_{\\ge 1}$, the competitive ratio (CR) on $n$ is the ratio of the cost of $\\mathcal{A}$ to the cost of an optimal offline algorithm that knows $n$ in advance. The worst-case competitive ratio for $\\mathcal{A}$ is the supremum of this ratio over all admissible $n$, and the optimal (minimal) worst-case competitive ratio is the infimum of that supremum over the algorithm’s design choices.\n\nWe formalize the costs. Let $b \\in \\mathbb{Z}_{\\ge 1}$ be the buy cost, $1$ be the daily rent cost, and $T \\in \\mathbb{Z}_{\\ge 0}$ be the threshold parameter of the deterministic threshold algorithm $\\mathcal{A}_{T}$ defined as: rent for the first $T$ days; if the season continues to day $T+1$, buy at the start of day $T+1$.\n\nFor a realized season length $n \\in \\mathbb{Z}_{\\ge 1}$, the offline optimal cost, denoted $\\operatorname{OPT}(n)$, is obtained by choosing the cheaper of renting every day or buying at the outset:\n$$\n\\operatorname{OPT}(n) = \\min\\{n,\\, b\\}.\n$$\nThis follows from the fact that buying at any later time weakly dominates buying earlier plus renting some prefix, and renting every day dominates any plan that includes buying strictly after the first day.\n\nThe cost of $\\mathcal{A}_{T}$ for a realized $n$ is\n$$\n\\operatorname{ALG}_{T}(n) = \n\\begin{cases}\nn, & \\text{if } n \\le T \\quad (\\text{the algorithm only rents}),\\\\\nT + b, & \\text{if } n \\ge T+1 \\quad (\\text{the algorithm rents } T \\text{ days then buys}).\n\\end{cases}\n$$\n\nWe now encode the lazy adversary’s $L$-day lookahead constraint. If $\\mathcal{A}_{T}$ never buys (which happens exactly when $n \\le T$), then the adversary may choose any $n \\in \\{1,2,\\dots,T\\}$. If $\\mathcalA}_{T}$ buys at the start of day $T+1$ (which happens exactly when $n \\ge T+1$), the adversary is constrained to choose $n \\ge T+L$. Thus, for a fixed $T$, the admissible $n$ are\n$$\nn \\in \\{1,2,\\dots,T\\} \\cup \\{T+L, T+L+1, T+L+2, \\dots\\}.\n$$\n\nFor a fixed $T$, the worst-case competitive ratio is\n$$\nR(T) \\equiv \\sup_{n \\text{ admissible}} \\frac{\\operatorname{ALG}_{T}(n)}{\\operatorname{OPT}(n)} = \\max\\left\\{ \\max_{1 \\le n \\le T} \\frac{n}{\\min\\{n,b\\}},\\ \\sup_{n \\ge T+L} \\frac{T+b}{\\min\\{n,b\\}} \\right\\}.\n$$\n\nWe compute each term separately.\n\nFirst term over $n \\in \\{1,\\dots,T\\}$:\n- If $T < b$, then for all $n \\le T$ we have $n < b$ and hence $\\frac{n}{\\min\\{n,b\\}} = \\frac{n}{n} = 1$. Therefore $\\max_{1 \\le n \\le T} \\frac{n}{\\min\\{n,b\\}} = 1$.\n- If $T \\ge b$, then the maximum over $n \\in \\{1,\\dots,T\\}$ is attained at $n = T$ because for $n \\ge b$ the ratio is $\\frac{n}{b}$, which increases with $n$, yielding $\\max_{1 \\le n \\le T} \\frac{n}{\\min\\{n,b\\}} = \\frac{T}{b}$.\n\nThus,\n$$\n\\max_{1 \\le n \\le T} \\frac{n}{\\min\\{n,b\\}} =\n\\begin{cases}\n1, & \\text{if } T < b,\\\\[4pt]\n\\frac{T}{b}, & \\text{if } T \\ge b.\n\\end{cases}\n$$\n\nSecond term over $n \\ge T+L$:\nThe expression $\\frac{T+b}{\\min\\{n,b\\}}$ is maximized by minimizing the denominator $\\min\\{n,b\\}$ subject to $n \\ge T+L$. Hence\n- If $T+L < b$, the minimum possible $\\min\\{n,b\\}$ is achieved by taking $n = T+L$, giving $\\frac{T+b}{T+L}$.\n- If $T+L \\ge b$, then for all $n \\ge T+L$ we have $n \\ge b$, so $\\min\\{n,b\\} = b$ and the ratio is $\\frac{T+b}{b}$.\n\nTherefore,\n$$\n\\sup_{n \\ge T+L} \\frac{T+b}{\\min\\{n,b\\}} =\n\\begin{cases}\n\\frac{T+b}{T+L}, & \\text{if } T+L < b,\\\\[4pt]\n\\frac{T+b}{b}, & \\text{if } T+L \\ge b.\n\\end{cases}\n$$\n\nCombine the two terms to obtain\n$$\nR(T) = \\max\\left\\{\n\\begin{array}{l}\n1 \\ \\text{ or } \\ \\frac{T}{b} \\quad \\text{depending on whether } T<b \\text{ or } T\\ge b,\\\\[4pt]\n\\frac{T+b}{T+L} \\ \\text{if } T+L<b, \\ \\text{else } \\ \\frac{T+b}{b}.\n\\end{array}\n\\right.\n$$\n\nWe now minimize $R(T)$ over $T \\in \\mathbb{Z}_{\\ge 0}$.\n\nCase $1$: $T < b$. Then the first term is $1$, and the second term is:\n- If $T+L < b$: $R(T) = \\max\\left\\{1, \\frac{T+b}{T+L}\\right\\} = \\frac{T+b}{T+L}$ since $\\frac{T+b}{T+L} > 1$ when $b > L$. Moreover, on the domain where $T+L < b$ (which implies $L < b$), the function $\\frac{T+b}{T+L}$ is strictly decreasing in $T$ because its derivative with respect to $T$ is $\\frac{(T+L) - (T+b)}{(T+L)^{2}} = \\frac{L-b}{(T+L)^{2}} < 0$. Therefore, within this subcase, $R(T)$ is minimized by taking $T$ as large as possible subject to $T+L < b$, i.e., $T = b - L - 1$. As $T$ approaches the boundary $T+L \\to b$ from below, $\\frac{T+b}{T+L} \\to \\frac{b + (b-L)}{b} = 2 - \\frac{L}{b}$.\n- If $T+L \\ge b$: $R(T) = \\max\\left\\{1, \\frac{T+b}{b}\\right\\} = 1 + \\frac{T}{b}$, which is strictly increasing in $T$. Thus, in this subcase the minimum occurs at the smallest $T$ with $T+L \\ge b$, namely $T = b - L$, yielding $R(T) = 1 + \\frac{b - L}{b} = 2 - \\frac{L}{b}$.\n\nComparing the two subcases in $T < b$, the optimal choice is to take $T$ at the boundary $T = b - L$ (provided $b - L \\ge 0$), which achieves\n$$\nR(T) = 2 - \\frac{L}{b}.\n$$\n\nCase $2$: $T \\ge b$. Then the first term is $\\frac{T}{b}$ and the second term is $\\frac{T+b}{b} = 1 + \\frac{T}{b}$. Hence $R(T) = 1 + \\frac{T}{b}$, which is minimized at the smallest admissible $T$, namely $T = b$, giving $R(T) = 2$. This is never better than the value obtained in Case $1$ when $L \\ge 1$, because $2 - \\frac{L}{b} \\le 2$ with strict inequality for $L \\ge 1$.\n\nFinally, we must also consider the regime $L \\ge b$. In that case, the boundary choice $T = b - L$ from Case $1$ becomes $T \\le 0$, and the smallest feasible threshold is $T = 0$. With $T = 0$, the algorithm buys immediately; by the lazy adversary constraint, if the algorithm buys at day $1$, then $n \\ge 0 + L \\ge b$, so $\\operatorname{OPT}(n) = b$ and $\\operatorname{ALG}_{0}(n) = b$, implying a ratio of $1$. This coincides with the formula $2 - \\frac{L}{b}$ evaluated at $L = b$, which yields $1$, and for $L > b$ the expression $2 - \\frac{L}{b}$ drops below $1$ but the competitive ratio cannot be below $1$, so the optimal worst-case ratio saturates at $1$.\n\nThus, the minimal possible worst-case competitive ratio, as a function of $b$ and $L$, is\n$$\nR^{\\star}(b,L) = \\max\\left\\{ 1,\\ 2 - \\frac{L}{b} \\right\\}.\n$$\nEquivalently, in piecewise form, $R^{\\star}(b,L) = 2 - \\frac{L}{b}$ for $0 \\le L \\le b$ and $R^{\\star}(b,L) = 1$ for $L \\ge b$. The minimizing threshold is $T^{\\star} = \\max\\{0,\\, b - L\\}$, which attains the stated ratio.", "answer": "$$\\boxed{\\max\\left\\{1,\\ 2 - \\frac{L}{b}\\right\\}}$$", "id": "3272187"}, {"introduction": "Moving beyond adversarial thinking, we often have statistical information about the future, such as a probability distribution of how long a ski season might last. This exercise challenges you to find a provably optimal strategy that minimizes the *expected* total cost, rather than the worst-case cost. Using the powerful framework of dynamic programming [@problem_id:3272330], you will formulate the decision process and derive the structure of the optimal policy for this stochastic version of the ski rental problem.", "problem": "A skier faces the classical ski rental decision: on each day she can either rent skis or buy skis outright. Let $r > 0$ be the rental cost per day, and let $b > 0$ be the one-time purchase cost that covers all remaining days without further rental charges. The total number of ski days in the season, denoted by the random variable $K$, is supported on $\\{1, 2, \\dots, N\\}$ with a known probability mass function $P(k)$ satisfying $\\sum_{k=1}^{N} P(k) = 1$. The decision is made at the beginning of each day $t \\in \\{1, 2, \\dots, N\\}$, conditioned on the season not having ended yet (i.e., conditioned on $K \\ge t$). The objective is to minimize the expected total cost.\n\nUsing only the fundamental definition of expected value, the Principle of Optimality for dynamic programming (DP), and standard facts about conditional probabilities of a discrete distribution, formulate the decision process as a finite-horizon DP. Derive a recursion for the minimal expected remaining cost $V(t)$ at the start of day $t$, with an appropriate boundary condition, and deduce the structure of an optimal policy. Then, express the minimal expected total cost from the start of the season as a single closed-form analytic expression in terms of $P(k)$, $r$, $b$, and $N$.\n\nYour final answer must be this single expression. No numerical approximation is required.", "solution": "The problem asks for the formulation and solution of the stochastic ski rental problem using dynamic programming to find the minimal expected total cost.\n\nThe problem is valid as it is a well-defined, self-contained problem in optimization and probability theory, a classic in the field of online and stochastic algorithms. All parameters and the objective are clearly stated.\n\nLet $t \\in \\{1, 2, \\dots, N\\}$ be the current day of the ski season. We are given that the season has not yet ended, i.e., the total number of ski days $K$ is at least $t$ ($K \\ge t$). We must decide whether to rent skis for a cost of $r$ for the day, or buy them for a one-time cost of $b$. We assume we have not yet bought the skis.\n\nLet $V(t)$ be the minimal expected future cost given that we are at the start of day $t$ and have not bought skis. This is our value function for the dynamic programming formulation. The state is defined by the day $t$. The horizon is finite, ending at $N$. We solve this using backward induction, from day $N$ to day $1$.\n\nAt the start of day $t$, we have two actions:\n1.  **Buy**: The cost is $b$. This cost is incurred immediately, and there are no further costs for the rest of the season, regardless of how many more days it lasts. The total future cost is $b$.\n2.  **Rent**: The cost for today is $r$. The season may end today, or it may continue to day $t+1$. We need to account for the expected cost of future decisions. The total expected future cost, if we rent today, is the sum of today's rental cost $r$ and the expected cost from day $t+1$ onwards, conditioned on the season continuing.\n\nLet $S(t) = P(K \\ge t) = \\sum_{k=t}^{N} P(k)$ be the survival function, the probability that the season lasts at least $t$ days. Note that $S(1) = \\sum_{k=1}^{N} P(k) = 1$.\nThe decision at day $t$ is conditioned on $K \\ge t$. The probability that the season continues to day $t+1$, given it has lasted until day $t$, is:\n$$ P(K \\ge t+1 | K \\ge t) = \\frac{P(K \\ge t+1 \\text{ and } K \\ge t)}{P(K \\ge t)} = \\frac{P(K \\ge t+1)}{P(K \\ge t)} = \\frac{S(t+1)}{S(t)} $$\nIf the season continues to day $t+1$, we will face the same problem again, and by the Principle of Optimality, we will proceed optimally, incurring a minimal expected future cost of $V(t+1)$.\n\nThe expected cost of renting at day $t$ is therefore $r + V(t+1) \\cdot P(K \\ge t+1 | K \\ge t) = r + V(t+1) \\frac{S(t+1)}{S(t)}$.\nThe value function $V(t)$ is the minimum of the costs of the two actions:\n$$ V(t) = \\min \\left( b, r + \\frac{S(t+1)}{S(t)} V(t+1) \\right) $$\nThis recurrence relation holds for $t=1, 2, \\dots, N$. We need a boundary condition. Let's define $V(N+1)=0$, as there are no more possible ski days and thus zero future cost.\nFor $t=N$, given $K \\ge N$, we must have $K=N$. So the season lasts for exactly one more day. The probability of continuing to day $N+1$ is $P(K \\ge N+1 | K \\ge N) = S(N+1)/S(N) = 0$.\nThe recursion at $t=N$ becomes:\n$$ V(N) = \\min \\left( b, r + \\frac{S(N+1)}{S(N)} V(N+1) \\right) = \\min(b, r + 0) = \\min(b, r) $$\nThis is logical: on the last possible day, one should simply compare the single-day rental cost with the purchase price.\n\nThe structure of the optimal policy can be deduced from this recurrence. An optimal policy is a stopping rule that specifies when to stop renting and buy the skis. Once skis are bought, the process terminates. Let's assume the optimal policy has a threshold structure: rent for days $t=1, \\dots, \\tau-1$, and if the season is still going on day $\\tau$, buy the skis. Here $\\tau \\in \\{1, 2, \\dots, N+1\\}$ is the threshold day to buy. $\\tau=1$ means buy on day $1$. $\\tau=N+1$ means never buy (always rent).\n\nLet's verify this structure's consistency with the DP recurrence. If the policy is to buy on day $\\tau$, then for any $t \\ge \\tau$, if we reach day $t$, we buy. This implies $V(t) = b$ for all $t \\ge \\tau$.\nFor $t < \\tau$, the policy is to rent. So $V(t) = r + \\frac{S(t+1)}{S(t)}V(t+1)$.\nAt day $\\tau$, the decision must be to buy. This implies:\n$$ b \\le r + \\frac{S(\\tau+1)}{S(\\tau)} V(\\tau+1) $$\nSince $\\tau+1$ is also in the \"buy\" region, $V(\\tau+1) = b$. The condition becomes:\n$$ b \\le r + \\frac{S(\\tau+1)}{S(\\tau)} b \\implies b \\left(1 - \\frac{S(\\tau+1)}{S(\\tau)}\\right) \\le r \\implies b \\frac{S(\\tau)-S(\\tau+1)}{S(\\tau)} \\le r $$\nSince $S(\\tau) - S(\\tau+1) = \\sum_{k=\\tau}^N P(k) - \\sum_{k=\\tau+1}^N P(k) = P(\\tau)$, this simplifies to:\n$$ b \\frac{P(\\tau)}{S(\\tau)} \\le r \\quad \\text{or} \\quad b P(\\tau) \\le r S(\\tau) $$\nAt day $\\tau-1$, the decision must be to rent. This implies:\n$$ b > r + \\frac{S(\\tau)}{S(\\tau-1)} V(\\tau) $$\nSince $\\tau$ is the \"buy\" day, $V(\\tau) = b$. The condition becomes:\n$$ b > r + \\frac{S(\\tau)}{S(\\tau-1)} b \\implies b \\left(1 - \\frac{S(\\tau)}{S(\\tau-1)}\\right) > r \\implies b \\frac{S(\\tau-1)-S(\\tau)}{S(\\tau-1)} > r $$\nThis simplifies to:\n$$ b \\frac{P(\\tau-1)}{S(\\tau-1)} > r \\quad \\text{or} \\quad b P(\\tau-1) > r S(\\tau-1) $$\nCombining these results, the optimal threshold $\\tau_{opt}$ is the first day $t$ for which the \"buy\" condition $b P(t) \\le r S(t)$ is met. If this condition is never met for $t \\in \\{1, \\dots, N\\}$, then we always rent, which corresponds to $\\tau_{opt} = N+1$.\nThus, the optimal buying day is $\\tau_{opt} = \\min(\\{t \\in \\{1, \\dots, N\\} \\mid b P(t) \\le r S(t)\\} \\cup \\{N+1\\})$. The structure of the optimal policy is indeed a simple threshold policy.\n\nNow we can derive a closed-form expression for the minimal expected total cost, which is $V(1)$.\nThe cost is determined by the actual number of ski days, $k$, under the optimal policy with threshold $\\tau_{opt}$.\n- If $K=k < \\tau_{opt}$: we rent for $k$ days. The cost is $k \\cdot r$.\n- If $K=k \\ge \\tau_{opt}$: we rent for $\\tau_{opt}-1$ days and then buy on day $\\tau_{opt}$. The cost is $(\\tau_{opt}-1)r + b$.\n\nThe expected total cost is the sum of these costs weighted by the probability $P(k)$:\n$$ V(1) = \\sum_{k=1}^{\\tau_{opt}-1} (k \\cdot r) P(k) + \\sum_{k=\\tau_{opt}}^{N} ((\\tau_{opt}-1)r + b) P(k) $$\n$$ V(1) = r \\sum_{k=1}^{\\tau_{opt}-1} k P(k) + ((\\tau_{opt}-1)r + b) \\sum_{k=\\tau_{opt}}^{N} P(k) $$\n$$ V(1) = r \\sum_{k=1}^{\\tau_{opt}-1} k P(k) + ((\\tau_{opt}-1)r + b) S(\\tau_{opt}) $$\nThis expression can be simplified. Let's use the recurrence relation we found for the total cost of a threshold policy. For $t < \\tau_{opt}$, we have $V(t) = r + \\frac{S(t+1)}{S(t)}V(t+1)$. This can be rewritten as $S(t)V(t) = rS(t) + S(t+1)V(t+1)$.\nThis gives a telescoping-like relation. For $t = \\tau_{opt}-1$:\n$S(\\tau_{opt}-1)V(\\tau_{opt}-1) = rS(\\tau_{opt}-1) + S(\\tau_{opt})V(\\tau_{opt}) = rS(\\tau_{opt}-1) + b S(\\tau_{opt})$ since $V(\\tau_{opt})=b$.\nFor $t = \\tau_{opt}-2$:\n$S(\\tau_{opt}-2)V(\\tau_{opt}-2) = rS(\\tau_{opt}-2) + S(\\tau_{opt}-1)V(\\tau_{opt}-1) = rS(\\tau_{opt}-2) + rS(\\tau_{opt}-1) + bS(\\tau_{opt})$.\nBy induction, for any $t < \\tau_{opt}$:\n$$ S(t)V(t) = r \\sum_{j=t}^{\\tau_{opt}-1} S(j) + b S(\\tau_{opt}) $$\nThe minimal total cost from the start of the season is $V(1)$. Since $S(1)=1$:\n$$ V(1) = r \\sum_{j=1}^{\\tau_{opt}-1} S(j) + b S(\\tau_{opt}) $$\nWhile this expression depends on $\\tau_{opt}$, which itself must be calculated, an alternative way to express the minimal cost is to state it as the minimum over all possible threshold policies. Let $\\tau$ be a potential buy day. The expected cost $C(\\tau)$ is:\n$$ C(\\tau) = r \\sum_{t=1}^{\\tau-1} S(t) + b S(\\tau) $$\nThe minimal expected cost is the minimum of these values over all possible thresholds $\\tau \\in \\{1, 2, \\dots, N+1\\}$.\nThe sum $\\sum_{t=1}^{\\tau-1}$ is defined as $0$ if $\\tau=1$. The term $S(\\tau)$ is defined as $0$ if $\\tau=N+1$.\nSubstituting the definition of $S(t)$ gives the final expression.\n\nMinimal Expected Cost $= \\min_{\\tau \\in \\{1, 2, \\dots, N+1\\}} C(\\tau) $, where $C(\\tau)$ is the expected cost of buying on day $\\tau$.\n$$ C(\\tau) = r \\sum_{t=1}^{\\tau-1} \\left( \\sum_{k=t}^{N} P(k) \\right) + b \\sum_{k=\\tau}^{N} P(k) $$\nThis is a single closed-form expression for the minimal expected total cost in terms of the given parameters.\nFor $\\tau=1$, the first term is $0$, and the cost is $b \\sum_{k=1}^N P(k) = b$.\nFor $\\tau=N+1$, the second term is $0$ (sum over an empty set), and the cost is $r \\sum_{t=1}^{N} S(t) = r \\sum_{t=1}^N \\sum_{k=t}^N P(k) = r \\sum_{k=1}^N k P(k) = r E[K]$.\nThe expression correctly represents buying on day $1$ versus always renting. The optimal strategy's cost is the minimum over all possible buy days.", "answer": "$$ \\boxed{\\min_{\\tau \\in \\{1, 2, \\dots, N+1\\}} \\left( r \\sum_{t=1}^{\\tau-1} \\sum_{k=t}^{N} P(k) + b \\sum_{k=\\tau}^{N} P(k) \\right)} $$", "id": "3272330"}, {"introduction": "An algorithm's theoretical elegance must often be adapted to the constraints of real-world hardware. This hands-on coding challenge [@problem_id:3272293] bridges the gap between the abstract ski rental model and a practical implementation on a system with fixed-size integer counters. You will design an overflow-safe algorithm using scaled fixed-point arithmetic, forcing you to confront the fundamental trade-off between computational precision and the risk of numerical errors, a critical skill in embedded systems and performance-sensitive software engineering.", "problem": "You are given the online ski rental decision in purely mathematical terms. On each day, renting costs a positive integer amount $r$ measured in arbitrary monetary units and buying costs a positive integer amount $B$ in the same units. The agent may rent for some number of days and then buy once. The classic lazy-buy strategy is to rent until the cumulative rent is at least equal to the buy cost and then buy; in exact arithmetic, this results in the buy day $d^\\star = \\lceil B / r \\rceil$. However, suppose the agent is constrained to implement the decision using only fixed-size unsigned counters of $N$ bits. Storing unscaled $B$ or unbounded daily accumulation may not be safe due to overflow. You must implement an overflow-safe scaled lazy-buy algorithm using integer division by a power-of-two scaling factor, and analyze the effect of scaling on precision and response time.\n\nAlgorithm requirement:\n- Let $C_{\\max} = 2^N - 1$ denote the maximum representable value in a single $N$-bit unsigned counter.\n- Choose a scaling factor $s = 2^k$ for some integer $k \\ge 0$, such that the scaled threshold $T = \\left\\lfloor B / s \\right\\rfloor$ and the scaled accumulator never exceed $C_{\\max}$, and such that the threshold is not degenerate. To avoid trivial immediate buys due to $T = 0$, require $T \\ge 1$. To balance precision and overflow safety, select $s$ to make $T$ lie within the upper fraction of the counter range when possible: specifically, try to ensure $T \\ge \\left\\lceil C_{\\max} / 8 \\right\\rceil$. If this is impossible for the given $B$ and $N$, choose the largest possible $s$ (still a power of two) that yields $T \\ge 1$.\n- Use scaled accumulation that exactly equals $\\left\\lfloor d \\cdot r / s \\right\\rfloor$ after $d$ days by tracking the remainder: on each day add $r$ to a remainder register and increment the counter by $\\left\\lfloor \\text{remainder} / s \\right\\rfloor$, then subtract $s$ times that quotient from the remainder. This realizes exact fixed-point division by $s$ over time using integer arithmetic, avoids per-day rounding loss, and prevents overflow in the main counter by construction.\n- Buy on the first day $d$ when the scaled accumulator $\\left\\lfloor d \\cdot r / s \\right\\rfloor$ reaches or exceeds the threshold $T = \\left\\lfloor B / s \\right\\rfloor$. Equivalently, compute the buy day via the closed-form formula $d_s = \\left\\lceil T \\cdot s / r \\right\\rceil$, which is the smallest $d$ satisfying $\\left\\lfloor d \\cdot r / s \\right\\rfloor \\ge T$.\n\nYour task:\n1. Implement the above scaled lazy-buy algorithm with overflow-safe scaling and remainder-based accumulation. The program must automatically choose the scaling factor $s$ as described for each test case.\n2. For each test case, compute two integers:\n   - The scaled buy day $d_s = \\left\\lceil T \\cdot s / r \\right\\rceil$.\n   - The exact unscaled buy day $d^\\star = \\left\\lceil B / r \\right\\rceil$.\n   Also compute the nonnegative integer deviation $\\Delta = d^\\star - d_s$, which measures how much earlier the scaled implementation buys relative to the exact lazy strategy.\n3. Discuss in comments and in your solution the trade-off between precision and response time as a function of the scaling factor $s$ and counter width $N$, and why the chosen scaling keeps the counter overflow-safe.\n\nImportant constraints and scientific realism:\n- All quantities $N$, $r$, and $B$ are positive integers.\n- The scaled threshold $T$ must satisfy $1 \\le T \\le C_{\\max}$.\n- The remainder register must be representable in the same $N$-bit width, which is guaranteed by choosing $s \\le C_{\\max}$.\n\nTest suite:\nUse the following five test cases, covering typical behavior, boundaries, and edge conditions:\n- Case $1$: $N = 8$, $r = 9$, $B = 200$.\n- Case $2$: $N = 16$, $r = 1$, $B = 50000$.\n- Case $3$: $N = 8$, $r = 200$, $B = 201$.\n- Case $4$: $N = 8$, $r = 9$, $B = 19$.\n- Case $5$: $N = 12$, $r = 300$, $B = 4000$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist of three integers in the order $[d_s, d^\\star, \\Delta]$. For example, the output should look like $[[d_{s1},d^\\star_1,\\Delta_1],[d_{s2},d^\\star_2,\\Delta_2],\\dots]$ with no spaces added between commas or brackets.", "solution": "The problem requires the implementation and analysis of a scaled, fixed-point arithmetic version of the lazy-buy strategy for the ski rental problem, optimized for a system with fixed-size $N$-bit unsigned counters.\n\nFirst, we formalize the unconstrained, exact lazy-buy strategy. An agent faces a daily rental cost of $r$ and a one-time purchase cost of $B$. The number of days the agent will require the service is unknown in advance. The lazy-buy strategy dictates that the agent should rent on each day $d$ as long as the cumulative rental cost, $d \\cdot r$, is less than the buy cost $B$. The agent buys on the first day when this condition is violated. The buy day, denoted $d^\\star$, is therefore the smallest positive integer $d$ such that $d \\cdot r \\ge B$. This can be expressed mathematically using the ceiling function:\n$$d^\\star = \\left\\lceil \\frac{B}{r} \\right\\rceil$$\n\nNext, we introduce the hardware constraint of an $N$-bit unsigned counter. Such a counter can represent integers from $0$ to $C_{\\max} = 2^N - 1$. Directly accumulating the cost $d \\cdot r$ is unsafe, as it could exceed $C_{\\max}$ and cause an overflow, leading to an incorrect decision. To mitigate this, we employ a scaling technique. All monetary values are scaled down by a factor $s$, which is chosen to be a power of two, $s = 2^k$ for some integer $k \\ge 0$, to allow for efficient implementation using bit shifts instead of general division.\n\nThe scaled problem is formulated as follows:\n- The buy cost $B$ is converted to a scaled threshold $T = \\left\\lfloor B / s \\right\\rfloor$.\n- The cumulative rent $d \\cdot r$ is converted to a scaled accumulator $A_d = \\left\\lfloor d \\cdot r / s \\right\\rfloor$.\nThe new buy condition is to purchase on the first day $d$ when the scaled accumulator $A_d$ reaches or exceeds the scaled threshold $T$. The scaled buy day, $d_s$, is the smallest integer $d$ satisfying $A_d \\ge T$.\n\nWe can derive a closed-form expression for $d_s$. The condition is $\\lfloor d \\cdot r / s \\rfloor \\ge T$. Since $T$ is an integer, this inequality is equivalent to $d \\cdot r / s \\ge T$. Rearranging for $d$, we get $d \\ge (T \\cdot s) / r$. As $d$ must be an integer, the smallest value of $d$ that satisfies this is:\n$$d_s = \\left\\lceil \\frac{T \\cdot s}{r} \\right\\rceil$$\n\nThe selection of the scaling factor $s$ is critical and must balance two competing objectives: precision and overflow safety.\n- A smaller $s$ (e.g., $s=1$) yields higher precision, as the effective buy threshold, $\\lfloor B/s \\rfloor \\cdot s$, is closer to the true value $B$. However, this results in a larger scaled threshold $T$, increasing the risk of overflow.\n- A larger $s$ provides a greater margin of safety against overflow by reducing the magnitude of $T$. However, it reduces precision by increasing the quantization error $B - (\\lfloor B/s \\rfloor \\cdot s)$. This can lead to a significant deviation from the exact strategy.\n\nThe problem specifies a deterministic procedure for selecting $s=2^k$:\n1.  The scaled threshold $T$ must be non-degenerate, i.e., $T \\ge 1$. This implies $\\lfloor B / s \\rfloor \\ge 1$, which requires $s \\le B$.\n2.  The scaled threshold $T$ and accumulator must not overflow the $N$-bit counter, meaning $T \\le C_{\\max}$.\n3.  To maintain reasonable precision, the selection logic prioritizes keeping $T$ in the upper portion of the counter's range. Specifically, we attempt to find the largest scaling factor $s=2^k$ such that the resulting threshold $T$ satisfies $T \\ge \\left\\lceil (2^N - 1) / 8 \\right\\rceil$.\n4.  If it is not possible to satisfy the condition in step 3 (which occurs if $B$ itself is too small), we fall back to choosing the largest possible scaling factor $s=2^k$ that still ensures a non-degenerate threshold, $T \\ge 1$. This amounts to selecting the largest power of two that is less than or equal to $B$.\n\nThe deviation between the scaled and exact strategies is $\\Delta = d^\\star - d_s$. We can demonstrate that $\\Delta \\ge 0$. The effective buy threshold in the scaled version is $B_{eff} = \\lfloor B/s \\rfloor \\cdot s$. Since $\\lfloor B/s \\rfloor \\le B/s$, we have $B_{eff} \\le B$. The scaled algorithm triggers a buy based on this lower or equal effective threshold, so it will never buy later than the exact algorithm. Thus, $d_s \\le d^\\star$, and the deviation $\\Delta$ is always non-negative. The magnitude of $\\Delta$ is related to the quantization error $B - B_{eff} = B \\pmod s$. A larger $s$ can lead to a larger error, potentially causing a larger $\\Delta$ and an earlier, less optimal purchase.\n\nThe implementation of the scaled accumulator, $A_d = \\lfloor d \\cdot r / s \\rfloor$, can be achieved without floating-point arithmetic using a remainder-tracking method. A remainder register, `rem`, is initialized to $0$. On each day, the daily cost $r$ is added to this register. The amount to increment the main accumulator is the integer quotient of the new remainder and the scaling factor, `inc = rem // s`. The main accumulator is incremented by `inc`, and the remainder is updated by subtracting the portion that was \"banked\": `rem = rem - inc * s`. This ensures that over $d$ days, the total value added to the accumulator is precisely $\\lfloor d \\cdot r / s \\rfloor$.\n\nFor this remainder-based accumulation to be overflow-safe within an $N$-bit register, the intermediate sum `rem + r` must not exceed $C_{\\max}$. Since the remainder `rem` is always kept in the range $[0, s-1]$, the maximum value of the intermediate sum is $(s-1) + r$. Therefore, a sufficient condition for safety of the remainder register is $s + r - 1 \\le C_{\\max}$. The problem's givens and constraints adhere to this, ensuring the entire algorithm is overflow-safe. The main accumulator is also safe, as it only ever reaches a value close to $T$, and the selection logic for $s$ ensures $T$ is well within the counter's capacity.\n\nWe will now apply this complete methodology to the provided test cases. For each case $(N, r, B)$, we calculate $C_{\\max}$, determine the appropriate scaling factor $s$ based on the specified logic, and then compute the scaled buy day $d_s$, the exact buy day $d^\\star$, and the resulting deviation $\\Delta = d^\\star - d_s$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the scaled ski rental problem for a given set of test cases.\n    \"\"\"\n    \n    # Test suite covering typical behavior, boundaries, and edge conditions.\n    # Each case is a tuple: (N: counter width in bits, r: daily rent cost, B: buy cost).\n    test_cases = [\n        (8, 9, 200),\n        (16, 1, 50000),\n        (8, 200, 201),\n        (8, 9, 19),\n        (12, 300, 4000),\n    ]\n\n    results = []\n    for N, r, B in test_cases:\n        # ----------------------------------------------------------------------\n        # PROBLEM ANALYSIS AND PARAMETER CALCULATION\n        # ----------------------------------------------------------------------\n\n        # C_max: Maximum value for an N-bit unsigned counter.\n        C_max = (1  N) - 1\n\n        # d_star: The exact, unscaled buy day.\n        # This is ceil(B/r), calculated using integer arithmetic to avoid float precision issues.\n        # The formula (a + b - 1) // b computes ceil(a/b) for positive integers a, b.\n        d_star = (B + r - 1) // r\n\n        # ----------------------------------------------------------------------\n        # SCALING FACTOR (s) SELECTION LOGIC\n        # ----------------------------------------------------------------------\n        # The goal is to choose a scaling factor s = 2^k that balances precision\n        # (small s) with overflow safety (large s).\n        #\n        # Trade-off discussion:\n        # - Precision: The scaled threshold T = floor(B/s) introduces quantization.\n        #   The effective buy cost is floor(B/s) * s, which is = B. This causes the\n        #   algorithm to buy potentially earlier than the exact strategy (d_s = d_star).\n        #   A smaller 's' minimizes this quantization error, yielding a more accurate\n        #   result (Delta -> 0), but a larger T that is more likely to overflow.\n        # - Response Time / Overflow Safety: A larger 's' results in a smaller T,\n        #   providing more headroom in the counter (safer from overflow). However,\n        #   the larger quantization error can lead to a larger deviation Delta,\n        #   making the agent buy significantly earlier. The \"response time\" to\n        #   the threshold is shorter, but the economic outcome may be worse.\n        \n        # Priority 1: Try to keep T in the upper 1/8 of the counter range for good precision.\n        # T_pref_min is the preferred minimum threshold: ceil(C_max / 8).\n        T_pref_min = (C_max + 7) // 8 # Integer ceil for C_max > 0.\n\n        # To satisfy T >= T_pref_min, we need floor(B/s) >= T_pref_min.\n        # This implies B/s >= T_pref_min, so s = B / T_pref_min.\n        # s_max_for_pref is the maximum s that could satisfy this.\n        # T_pref_min is always > 0 for N>=3, which covers all test cases.\n        s_max_for_pref = B // T_pref_min\n        \n        s = 0\n        if s_max_for_pref >= 1:\n            # We can satisfy the preferred precision. Choose the largest power of 2\n            # less than or equal to s_max_for_pref. This maximizes s while meeting\n            # the precision target.\n            k = s_max_for_pref.bit_length() - 1\n            s = 1  k\n        else:\n            # Priority 2 (Fallback): Cannot meet preferred precision.\n            # Instead, choose the largest s = 2^k ensuring T >= 1.\n            # This is equivalent to choosing the largest s = 2^k such that s = B.\n            if B > 0:\n                k = B.bit_length() - 1\n                s = 1  k\n            else: # B=0 is ruled out by problem statement, but as a safeguard.\n                s = 1 # T would be 0, but this path is not taken.\n\n\n        # ----------------------------------------------------------------------\n        # SCALED BUY DAY (d_s) and DEVIATION (Delta) CALCULATION\n        # ----------------------------------------------------------------------\n\n        # T: The scaled threshold, based on the chosen scaling factor s.\n        # It is guaranteed to be >= 1 by the selection logic for s.\n        T = B // s\n        \n        # The chosen s guarantees that T is well below C_max, and the accumulator,\n        # which grows to reach T, is also safe from overflow.\n        # The problem also guarantees the remainder register is safe for the given constraints.\n\n        # d_s: The scaled buy day.\n        # This is ceil(T*s/r), calculated using integer arithmetic.\n        d_s = (T * s + r - 1) // r\n\n        # Delta: The non-negative deviation, measuring how much earlier the scaled\n        # implementation buys.\n        Delta = d_star - d_s\n        \n        results.append([d_s, d_star, Delta])\n\n    # Format the final output string exactly as required, with no extra spaces.\n    sub_results_str = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output_str = f\"[{','.join(sub_results_str)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "3272293"}]}