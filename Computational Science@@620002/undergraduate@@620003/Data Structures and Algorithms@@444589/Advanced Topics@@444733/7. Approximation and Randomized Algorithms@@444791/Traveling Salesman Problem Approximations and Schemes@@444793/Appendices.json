{"hands_on_practices": [{"introduction": "Before we write a single line of code, it is crucial to understand *why* an approximation algorithm is considered effective. This practice guides you through the foundational proof for the Christofides algorithm, a cornerstone of TSP approximation theory. By deriving the famous $\\frac{3}{2}$ approximation ratio from first principles—using only the triangle inequality and basic graph theory—you will build a deep, intuitive understanding of the logic that guarantees the algorithm's performance, regardless of the specific problem instance [@problem_id:3280068].", "problem": "Consider a complete graph on a set $V$ of $n$ points embedded in the Euclidean plane $\\mathbb{R}^{2}$ with edge weights given by Euclidean distances $d(u,v)$ for $u,v \\in V$, so that $d$ is a metric satisfying the triangle inequality. You wish to compute a tour for the Traveling Salesman Problem (TSP) using the following pipeline:\n\n1. Replace the dense graph with a sparse supergraph $H$ that provably contains the Euclidean Minimum Spanning Tree (MST), such as the Delaunay triangulation, which can be constructed in expected $O(n\\log n)$ time, and which has $O(n)$ edges. Alternatively, for random inputs, you may discuss heuristics based on $k$-nearest neighbors that reduce the number of candidate edges while keeping an expected $O(n\\log n)$ construction time; however, the correctness of the approximation must not rely on randomness.\n2. Run Kruskal’s algorithm with Disjoint Set Union (DSU, also known as Union-Find) on $H$ to compute an MST $T$; because $H$ contains an MST of the original complete graph, the MST $T$ of $H$ is an MST of the complete graph on $V$.\n3. Let $S \\subseteq V$ be the set of vertices of odd degree in $T$. Compute a minimum-weight perfect matching $M$ on $S$ with respect to the metric $d$, and form the multigraph $G' = T \\cup M$. Because all degrees in $G'$ are even, $G'$ is Eulerian. Compute an Eulerian tour of $G'$ and shortcut repeated vertices using the triangle inequality to obtain a Hamiltonian cycle $C$ on $V$.\n\nStarting only from fundamental definitions and facts about metrics, spanning trees, and Eulerian tours, derive a worst-case multiplicative constant $c$ such that the length $w(C)$ of the returned TSP tour satisfies $w(C) \\leq c \\cdot w(\\mathrm{OPT})$, where $w(\\mathrm{OPT})$ denotes the length of an optimal TSP tour in the metric. Your derivation must not assume any prior bounds other than the triangle inequality and the definition of each constructed object.\n\nReport the exact value of the constant $c$ as a single simplified fraction or real number with no units. If you choose to discuss heuristic pruning via $k$-nearest neighbors, ensure that your derivation of $c$ remains valid independently of heuristic randomness by relying on a deterministic sparse supergraph that contains an MST. The time complexity discussion and pruning details are part of the reasoning, but the final requested answer is only the constant $c$.", "solution": "The problem asks for the derivation of the worst-case approximation ratio $c$ for a specific algorithm for the Traveling Salesman Problem (TSP) in a metric space. The algorithm, a variant of the Christofides algorithm, constructs a tour $C$ and we seek to find the constant $c$ such that its weight $w(C)$ satisfies $w(C) \\leq c \\cdot w(\\mathrm{OPT})$, where $w(\\mathrm{OPT})$ is the weight of an optimal TSP tour. The derivation will proceed by analyzing the weight contributions of each step of the algorithm.\n\nThe problem is defined on a complete graph with vertex set $V$ of size $n$, where vertices are points in $\\mathbb{R}^2$. The edge weights are given by the Euclidean distance $d(u,v)$, which satisfies the triangle inequality: for any three vertices $u, v, w \\in V$, $d(u,w) \\leq d(u,v) + d(v,w)$. The derivation holds for any general metric, not just the Euclidean one.\n\nThe algorithm consists of the following steps:\n$1$. Compute a Minimum Spanning Tree (MST), denoted $T$, of the complete graph on $V$. The problem statement notes that this can be done efficiently by first constructing a sparse supergraph $H$ (e.g., a Delaunay triangulation) that is guaranteed to contain an MST of the complete graph, and then running an MST algorithm on $H$. The weight of the MST is $w(T)$.\n$2$. Identify the set $S$ of all vertices in $T$ that have an odd degree.\n$3$. Compute a minimum-weight perfect matching $M$ on the vertices in the set $S$. The weight of the matching is $w(M)$.\n$4$. Form a multigraph $G' = T \\cup M$.\n$5$. Find an Eulerian tour in $G'$ and convert it into a Hamiltonian cycle (the final tour $C$) by shortcutting repeated vertices.\n\nWe will now bound the weight of the resulting tour $C$ in terms of the weight of the optimal tour $\\mathrm{OPT}$.\n\nFirst, we establish a relationship between the weight of the MST, $w(T)$, and the weight of the optimal tour, $w(\\mathrm{OPT})$. An optimal TSP tour is a Hamiltonian cycle that visits every vertex in $V$. If we remove any single edge from this tour, the result is a spanning path, which is a specific type of spanning tree. The weight of this spanning path is strictly less than $w(\\mathrm{OPT})$ (assuming all edge weights are positive). The Minimum Spanning Tree $T$ is, by definition, a spanning tree of minimum possible weight. Therefore, the weight of $T$ must be less than or equal to the weight of any other spanning tree, including the one derived from the optimal tour. Thus, we have the fundamental inequality:\n$$w(T) \\leq w(\\mathrm{OPT})$$\nFor the case where edge weights can be zero, the inequality would be $w(T) \\leq w(\\mathrm{OPT})$, which is sufficient for our purposes.\n\nSecond, we analyze the set $S$ of odd-degree vertices in the MST $T$. A well-known theorem in graph theory (the handshaking lemma) states that the sum of the degrees of all vertices in any finite graph is equal to twice the number of edges. This sum must be an even number.\n$$\\sum_{v \\in V} \\deg_T(v) = 2|E_T|$$\nwhere $E_T$ is the edge set of $T$. We can partition the sum based on the parity of the degrees:\n$$\\sum_{v \\in S} \\deg_T(v) + \\sum_{v \\in V \\setminus S} \\deg_T(v) = 2|E_T|$$\nThe second sum is over vertices of even degree, so every term is even, and the sum itself is even. For the entire expression to be even, the first sum, $\\sum_{v \\in S} \\deg_T(v)$, must also be even. Since every term in this sum is odd (by definition of $S$), the number of terms, $|S|$, must be even. This proves that the number of odd-degree vertices is even, which is a necessary condition for a perfect matching on $S$ to exist.\n\nThird, we bound the weight of the minimum-weight perfect matching $M$, $w(M)$. Let the vertices of $S$ be $\\{s_1, s_2, \\ldots, s_{2k}\\}$, where $|S| = 2k$ for some integer $k \\geq 1$ (assuming the graph is not just a path, in which case $|S|$ could be $0$ or $2$, and the argument holds trivially). Consider the optimal TSP tour, $\\mathrm{OPT}$. Let's create a sub-tour $C_S$ that visits only the vertices in $S$ in the same order they appear in $\\mathrm{OPT}$. By applying the triangle inequality to shortcut the paths in $\\mathrm{OPT}$ that pass through vertices not in $S$, the total weight of this sub-tour $w(C_S)$ is no greater than the weight of the original optimal tour:\n$$w(C_S) \\leq w(\\mathrm{OPT})$$\nThe tour $C_S$ is a cycle on $2k$ vertices. We can partition the edges of this cycle into two disjoint perfect matchings on $S$. Let the vertices in the order of the tour be $(v_1, v_2, \\ldots, v_{2k})$. The first matching $M_1$ consists of the edges $(v_1, v_2), (v_3, v_4), \\ldots, (v_{2k-1}, v_{2k})$. The second matching $M_2$ consists of the edges $(v_2, v_3), (v_4, v_5), \\ldots, (v_{2k}, v_1)$. The sum of the weights of these two matchings is exactly the weight of the tour $C_S$:\n$$w(M_1) + w(M_2) = w(C_S)$$\nFrom this, it follows that the weight of the lighter of the two matchings is at most half the total weight:\n$$\\min(w(M_1), w(M_2)) \\leq \\frac{1}{2} w(C_S)$$\nThe algorithm computes $M$, the minimum-weight perfect matching on $S$. By definition of minimality, its weight $w(M)$ must be less than or equal to the weight of any other perfect matching on $S$, including $M_1$ and $M_2$. Thus, $w(M) \\leq \\min(w(M_1), w(M_2))$. Combining these inequalities, we get:\n$$w(M) \\leq \\frac{1}{2} w(C_S) \\leq \\frac{1}{2} w(\\mathrm{OPT})$$\n\nFourth, we consider the multigraph $G' = T \\cup M$. The degree of a vertex $v$ in $G'$ is $\\deg_{G'}(v) = \\deg_T(v) + \\deg_M(v)$.\n- If $v \\in S$, then $\\deg_T(v)$ is odd and $\\deg_M(v) = 1$ (since $M$ is a perfect matching on $S$). So, $\\deg_{G'}(v)$ is even.\n- If $v \\notin S$, then $\\deg_T(v)$ is even and $\\deg_M(v) = 0$. So, $\\deg_{G'}(v)$ is even.\nSince all vertices in $G'$ have even degree and the graph is connected (as it contains the spanning tree $T$), $G'$ is Eulerian. An Eulerian tour traverses every edge of $G'$ exactly once. The total length of such a tour is the sum of the weights of all edges in $G'$, which is $w(G') = w(T) + w(M)$.\n\nFinally, the algorithm constructs the TSP tour $C$ by traversing the Eulerian tour and shortcutting any previously visited vertex. For any path $u \\to w_1 \\to \\dots \\to w_m \\to v$ in the Eulerian tour, the triangle inequality guarantees that the direct edge weight $d(u,v)$ is less than or equal to the path's length, $d(u,w_1) + \\ldots + d(w_m,v)$. By applying this principle repeatedly, the total weight of the final Hamiltonian cycle $C$, $w(C)$, is no greater than the total length of the Eulerian tour:\n$$w(C) \\leq w(G')$$\n\nCombining all our findings, we can complete the derivation for the approximation ratio $c$:\n$$w(C) \\leq w(G') = w(T) + w(M)$$\nSubstituting the bounds we derived for $w(T)$ and $w(M)$:\n$$w(C) \\leq w(\\mathrm{OPT}) + \\frac{1}{2} w(\\mathrm{OPT})$$\n$$w(C) \\leq \\frac{3}{2} w(\\mathrm{OPT})$$\nThis shows that the length of the tour produced by the algorithm is at most $1.5$ times the length of the optimal tour. The worst-case multiplicative constant is therefore $c = \\frac{3}{2}$.", "answer": "$$\\boxed{\\frac{3}{2}}$$", "id": "3280068"}, {"introduction": "With the theoretical guarantee established, we now move from proof to practice. This exercise challenges you to implement the Christofides algorithm and compare its output against the true optimal tour, which you will find using the exact Held-Karp algorithm. To make things more interesting, you will test your implementation across various $L_p$ metrics, from Manhattan ($p=1$) to Chebyshev ($p=\\infty$) distance [@problem_id:3280045]. This hands-on comparison will reveal the difference between a worst-case theoretical bound and typical empirical performance, while also demonstrating how the algorithm's logic holds true regardless of how we measure distance.", "problem": "You are given a set of points in the plane and asked to study the Traveling Salesman Problem (TSP) under the family of $L_p$ metrics. For points $(x_i,y_i) \\in \\mathbb{R}^2$, and a parameter $p \\in [1,\\infty]$, the $L_p$ distance between two points $(x,y)$ and $(x',y')$ is defined as\n$$\nd_p\\big((x,y),(x',y')\\big) = \\begin{cases}\n\\left(|x-x'|^p + |y-y'|^p\\right)^{1/p} & \\text{if } 1 \\le p < \\infty \\\\\n\\max\\left(|x-x'|,|y-y'|\\right) & \\text{if } p = \\infty.\n\\end{cases}\n$$\nConsider the metric TSP on the complete graph whose vertices are the points and edge weights are given by $d_p$. Implement the Christofides algorithm and compare its empirical performance for different values of $p$ by computing the ratio of the Christofides tour length to the optimal TSP tour length (computed exactly by dynamic programming).\n\nFoundational base to be used in your derivations and algorithmic design:\n- The Traveling Salesman Problem (TSP) on a complete metric graph: each pair of vertices has a non-negative edge weight that satisfies the triangle inequality, and the goal is to find a minimum-weight Hamiltonian cycle visiting every vertex exactly once.\n- The Minimum Spanning Tree (MST) is a spanning tree of minimum total weight in a connected, undirected graph.\n- The Christofides algorithm constructs a tour by computing an MST, finding the set of odd-degree vertices in the MST, computing a minimum-weight perfect matching on that set, forming an Eulerian multigraph by combining the MST and matching, and finally performing shortcutting to obtain a Hamiltonian cycle. The guarantee that shortcutting does not increase the tour length relies on the triangle inequality.\n- The Held–Karp dynamic programming method for exact TSP solves a complete graph TSP in time $O(n^2 2^n)$, where $n$ is the number of vertices.\n\nTasks:\n1. Implement the Christofides algorithm for $L_p$ metrics for values of $p$ specified in the test suite. For the minimum-weight perfect matching step on the set of odd-degree vertices, use an exact pairing dynamic programming method on the induced complete subgraph of those vertices; this is computationally feasible for the provided instances.\n2. Implement the Held–Karp dynamic programming algorithm to compute the exact optimal TSP tour length for the same instances and the same values of $p$.\n3. For each test case, compute the ratio\n$$\n\\rho(p) = \\frac{\\text{Christofides}_{p}}{\\text{OPT}_{p}},\n$$\nwhere $\\text{Christofides}_{p}$ is the length of the tour returned by the Christofides algorithm under the $L_p$ metric, and $\\text{OPT}_{p}$ is the exact optimal tour length under the same metric. Express $\\rho(p)$ as a real number rounded to six decimal places.\n\nTheoretical analysis requirement:\n- Explain, from first principles, why the constant-factor bound of $1.5$ for the Christofides algorithm is invariant across $p \\in [1,\\infty]$ when distances are measured by $L_p$ metrics.\n\nTest suite:\nUse the following set of planar point instances and metric parameters. Each instance is a list of points, and each $p$ is one of the specified values. For every pair $(\\text{points}, p)$ below, compute $\\rho(p)$.\n\n- Instance $\\mathcal{I}_1$ with $6$ points:\n$$\n\\{(0,0),(4,0),(4,1),(0,1),(2,0),(2,1)\\}.\n$$\n- Instance $\\mathcal{I}_2$ with $7$ points:\n$$\n\\{(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(9,0)\\}.\n$$\n- Instance $\\mathcal{I}_3$ with $8$ points:\n$$\n\\{(0,0),(5,0),(5,5),(0,5),(2,1),(3,1),(2,4),(3,4)\\}.\n$$\n- For each instance, use $p \\in \\{1,2,10,\\infty\\}$.\n\nThis yields $12$ test cases in total.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must have $12$ floating-point numbers corresponding to $\\rho(p)$ for the test cases above, each rounded to six decimal places, in the order:\n$$\n\\big[\\rho_{\\mathcal{I}_1}(1),\\rho_{\\mathcal{I}_1}(2),\\rho_{\\mathcal{I}_1}(10),\\rho_{\\mathcal{I}_1}(\\infty),\\rho_{\\mathcal{I}_2}(1),\\rho_{\\mathcal{I}_2}(2),\\rho_{\\mathcal{I}_2}(10),\\rho_{\\mathcal{I}_2}(\\infty),\\rho_{\\mathcal{I}_3}(1),\\rho_{\\mathcal{I}_3}(2),\\rho_{\\mathcal{I}_3}(10),\\rho_{\\mathcal{I}_3}(\\infty)\\big].\n$$\nNo additional text should be printed.", "solution": "The problem is valid as it is scientifically grounded, well-posed, objective, and contains all necessary information for a complete solution. It is a standard problem in the field of algorithms and computational geometry.\n\n### Theoretical Analysis: Invariance of the Christofides Approximation Ratio\n\nThe Christofides algorithm for the Traveling Salesman Problem (TSP) on a metric graph is guaranteed to produce a tour whose length is at most $1.5$ times the length of the optimal tour. We will demonstrate from first principles that this guarantee is independent of the specific choice of the $L_p$ metric, for any $p \\in [1, \\infty]$. The proof's validity rests solely on the properties of a metric space, which all $L_p$ spaces are.\n\nA function $d(u,v)$ is a metric if it satisfies three properties for all points $u, v, w$:\n1.  **Non-negativity and Identity of Indiscernibles**: $d(u,v) \\ge 0$, and $d(u,v) = 0$ if and only if $u=v$.\n2.  **Symmetry**: $d(u,v) = d(v,u)$.\n3.  **Triangle Inequality**: $d(u,w) \\le d(u,v) + d(v,w)$.\n\nThe $L_p$ distance, for $p \\in [1, \\infty)$, is a valid metric; its satisfaction of the triangle inequality is a direct consequence of Minkowski's inequality. For $p=\\infty$, the triangle inequality can be proven by straightforward case analysis. Since the edge weights in our TSP instance are defined by an $L_p$ distance, the graph is a metric graph. The Christofides approximation proof relies only on this fact.\n\nLet $\\mathcal{G} = (V, E)$ be the complete graph on the set of points, with edge weights given by an $L_p$ metric. Let $T^*$ be an optimal TSP tour with weight $W(T^*)$.\n\nThe steps of the Christofides algorithm and the analysis of their costs are as follows:\n\n1.  **Compute a Minimum Spanning Tree (MST)**: Let $M$ be an MST of $\\mathcal{G}$. The weight of the MST, $W(M)$, is a lower bound on the optimal tour length. Specifically, by removing any single edge from the optimal tour $T^*$, we obtain a spanning path, which is a type of spanning tree. The MST is, by definition, the spanning tree with the minimum possible weight. Thus:\n    $$W(M) \\le W(T^*)$$\n\n2.  **Identify Odd-Degree Vertices**: Let $O \\subseteq V$ be the set of vertices that have an odd degree in the MST, $M$. A fundamental property of any graph is that the number of odd-degree vertices must be even. Let $|O| = 2k$ for some integer $k \\ge 0$.\n\n3.  **Find a Minimum-Weight Perfect Matching (MWPM)**: Consider the subgraph of $\\mathcal{G}$ induced by the vertices in $O$. Find a minimum-weight perfect matching, $P$, on these vertices. To bound the weight of this matching, $W(P)$, we again use the optimal tour $T^*$.\n    -   Consider the optimal tour $T^*$ and shortcut it to visit only the vertices in $O$ in their original order. This creates a cycle on the vertices of $O$. Due to the triangle inequality, which holds for any $L_p$ metric, the weight of this new cycle, $W(T^*_O)$, cannot be greater than the original tour's weight: $W(T^*_O) \\le W(T^*)$.\n    -   The cycle $T^*_O$ is a tour on an even number of vertices ($2k$). It can be decomposed into two disjoint perfect matchings on $O$, say $P_1$ and $P_2$, such that $W(T^*_O) = W(P_1) + W(P_2)$.\n    -   By the pigeonhole principle, at least one of these matchings must have a weight no more than half the total weight of the cycle: $\\min(W(P_1), W(P_2)) \\le W(T^*_O) / 2$.\n    -   Since $P$ is the *minimum-weight* perfect matching on $O$, its weight cannot be more than the weight of any other perfect matching on $O$. Therefore, $W(P) \\le \\min(W(P_1), W(P_2))$.\n    -   Combining these inequalities gives the crucial bound on the matching's weight:\n    $$W(P) \\le \\frac{W(T^*_O)}{2} \\le \\frac{W(T^*)}{2}$$\n\n4.  **Form an Eulerian Multigraph**: A new multigraph $\\mathcal{G}'$ is formed by taking the union of the edges of the MST ($M$) and the perfect matching ($P$). The total weight of the edges in $\\mathcal{G}'$ is $W(\\mathcal{G}') = W(M) + W(P)$. All vertices in $\\mathcal{G}'$ now have an even degree: vertices originally with even degree in $M$ are untouched by $P$ and remain even, while vertices in $O$ (odd degree in $M$) are incident to exactly one edge from $P$, making their new total degree even.\n\n5.  **Find an Eulerian Tour and Shortcut**: Since all vertices in $\\mathcal{G}'$ have an even degree, an Eulerian tour (a tour that traverses every edge exactly once) exists. The length of this Eulerian tour is exactly $W(\\mathcal{G}')$. Using our bounds from steps 1 and 3:\n    $$W(\\mathcal{G}') = W(M) + W(P) \\le W(T^*) + \\frac{W(T^*)}{2} = 1.5 \\cdot W(T^*)$$\n    Finally, the Eulerian tour is converted into a Hamiltonian cycle (the final Christofides tour, $T_C$) by traversing the Eulerian tour and skipping any previously visited vertices. The triangle inequality guarantees that this \"shortcutting\" process does not increase the total length. Thus, the length of the final tour $W(T_C)$ satisfies:\n    $$W(T_C) \\le W(\\mathcal{G}') \\le 1.5 \\cdot W(T^*)$$\n\nThis derivation is completely independent of the specific value of $p$. The proof relies only on the graph being a metric space, a condition satisfied by all $L_p$ metrics. Therefore, the $1.5$-approximation guarantee of the Christofides algorithm is invariant across $p \\in [1, \\infty]$.\n\n### Algorithmic Design\n\nThe solution requires implementing two algorithms: the Christofides heuristic and the exact Held-Karp algorithm.\n\n**1. Christofides Algorithm Implementation**\nFor a given set of $n$ points and a parameter $p$, the tour length is computed as follows:\n- **Distance Matrix**: First, a complete $n \\times n$ distance matrix is constructed, where the entry $(i, j)$ is the $L_p$ distance between point $i$ and point $j$.\n- **Minimum Spanning Tree (MST)**: Prim's algorithm is used to find an MST on the complete graph. Prim's algorithm is efficient for dense graphs, running in $O(n^2)$ time. It builds the MST by iteratively adding the cheapest edge that connects a vertex in the MST to a vertex outside the MST.\n- **Odd-Degree Vertices**: The degrees of all vertices in the computed MST are calculated. The set of vertices $O$ with odd degrees is collected.\n- **Minimum-Weight Perfect Matching (MWPM)**: An exact minimum-weight perfect matching is found on the induced subgraph of odd-degree vertices $O$. As specified, this is solved using dynamic programming with bitmasking. Let $|O| = 2k$. A DP state `dp[mask]` stores the cost of the minimum matching on the subset of $O$ represented by `mask`. The recurrence is:\n  `dp[mask] = min_{j \\in S \\setminus \\{i\\}} (d(i, j) + dp[S \\setminus \\{i, j\\}])`, where $i$ is a fixed element of the subset $S$ corresponding to `mask`. This runs in $O(k^2 2^k)$ time.\n- **Eulerian Circuit and Shortcutting**: The edges from the MST and the MWPM are combined to form an adjacency list representation of an Eulerian multigraph. Hierholzer's algorithm is then used to find an Eulerian circuit in $O(n^2)$ time. Finally, this circuit is traversed to produce a Hamiltonian cycle by skipping any already visited vertices (shortcutting). The total length of this final tour is calculated and returned.\n\n**2. Exact TSP (Held-Karp Algorithm)**\nThe Held-Karp algorithm finds the optimal TSP tour length using dynamic programming.\n- **DP State**: The state is defined as `dp[mask][i]`, representing the length of the shortest path starting at a fixed vertex (e.g., vertex $0$), visiting all vertices in the subset represented by the bitmask `mask`, and ending at vertex `i`.\n- **Recurrence**: The DP table is filled by iterating through subsets of increasing size. For a subset `S` (represented by `mask`) and a vertex `j` in `S`, the value is computed as:\n  $$ \\text{dp}[\\text{mask}][j] = \\min_{k \\in S \\setminus \\{j\\}} \\left( \\text{dp}[\\text{mask} \\setminus \\{j\\}][k] + d(k, j) \\right) $$\n- **Base Case**: The base case is `dp[{0}][0] = 0`.\n- **Final Result**: After computing the DP table for all subsets up to size $n$, the optimal tour length is found by considering all paths that visit every vertex and end at some vertex $j \\neq 0$, and then adding the edge from $j$ back to the starting vertex $0$:\n  $$ \\text{OPT} = \\min_{j \\in \\{1, \\dots, n-1\\}} \\left( \\text{dp}[\\{0, \\dots, n-1\\}][j] + d(j, 0) \\right) $$\nThe overall complexity is $O(n^2 2^n)$.\n\n**Final Computation**\nFor each of the $12$ test cases (instance, $p$ value pair), the lengths from both the Christofides algorithm ($\\text{Christofides}_p$) and the Held-Karp algorithm ($\\text{OPT}_p$) are computed. The ratio $\\rho(p) = \\text{Christofides}_p / \\text{OPT}_p$ is calculated, rounded to six decimal places, and stored. The final output is a list of these $12$ ratios.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve the TSP approximation problem.\n    It orchestrates the validation, computation, and formatting of the final answer.\n    \"\"\"\n\n    test_cases = [\n        # Instance 1\n        (np.array([(0,0),(4,0),(4,1),(0,1),(2,0),(2,1)]), 1),\n        (np.array([(0,0),(4,0),(4,1),(0,1),(2,0),(2,1)]), 2),\n        (np.array([(0,0),(4,0),(4,1),(0,1),(2,0),(2,1)]), 10),\n        (np.array([(0,0),(4,0),(4,1),(0,1),(2,0),(2,1)]), float('inf')),\n        # Instance 2\n        (np.array([(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(9,0)]), 1),\n        (np.array([(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(9,0)]), 2),\n        (np.array([(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(9,0)]), 10),\n        (np.array([(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(9,0)]), float('inf')),\n        # Instance 3\n        (np.array([(0,0),(5,0),(5,5),(0,5),(2,1),(3,1),(2,4),(3,4)]), 1),\n        (np.array([(0,0),(5,0),(5,5),(0,5),(2,1),(3,1),(2,4),(3,4)]), 2),\n        (np.array([(0,0),(5,0),(5,5),(0,5),(2,1),(3,1),(2,4),(3,4)]), 10),\n        (np.array([(0,0),(5,0),(5,5),(0,5),(2,1),(3,1),(2,4),(3,4)]), float('inf')),\n    ]\n\n    results = []\n    for points, p_val in test_cases:\n        n = len(points)\n        dist_matrix = np.zeros((n, n))\n        for i in range(n):\n            for j in range(i, n):\n                if p_val == float('inf'):\n                    dist = np.max(np.abs(points[i] - points[j]))\n                else:\n                    dist = np.power(np.sum(np.power(np.abs(points[i] - points[j]), p_val)), 1/p_val)\n                dist_matrix[i, j] = dist_matrix[j, i] = dist\n\n        christofides_len = _compute_christofides(dist_matrix)\n        optimal_len = _compute_held_karp(dist_matrix)\n        \n        ratio = christofides_len / optimal_len if optimal_len != 0 else 1.0\n        results.append(f\"{ratio:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef _compute_christofides(dist_matrix):\n    \"\"\"Computes the length of a TSP tour using Christofides' algorithm.\"\"\"\n    n = dist_matrix.shape[0]\n    if n == 0:\n        return 0\n\n    # 1. Minimum Spanning Tree (Prim's algorithm)\n    mst_parent = [-1] * n\n    key = [float('inf')] * n\n    in_mst = [False] * n\n    key[0] = 0\n    \n    for _ in range(n):\n        min_key = float('inf')\n        u = -1\n        for v_idx in range(n):\n            if not in_mst[v_idx] and key[v_idx]  min_key:\n                min_key = key[v_idx]\n                u = v_idx\n        \n        if u == -1: continue # Should not happen in a connected graph\n        in_mst[u] = True\n        \n        for v in range(n):\n            if dist_matrix[u, v] > 0 and not in_mst[v] and dist_matrix[u, v]  key[v]:\n                key[v] = dist_matrix[u, v]\n                mst_parent[v] = u\n\n    mst_edges = []\n    for i in range(1, n):\n        mst_edges.append((mst_parent[i], i))\n\n    # 2. Find odd-degree vertices\n    degree = collections.defaultdict(int)\n    for u, v in mst_edges:\n        degree[u] += 1\n        degree[v] += 1\n    \n    odd_vertices = [i for i, deg in degree.items() if deg % 2 != 0]\n\n    # 3. Minimum Weight Perfect Matching on odd_vertices\n    memo_mwpm = {}\n    \n    def get_mwpm_edges(nodes_tuple):\n        if not nodes_tuple:\n            return []\n        if nodes_tuple in memo_mwpm:\n            return memo_mwpm[nodes_tuple]\n\n        p1 = nodes_tuple[0]\n        nodes_rest = nodes_tuple[1:]\n        \n        best_pairing = None\n        min_cost = float('inf')\n\n        for i in range(len(nodes_rest)):\n            p2 = nodes_rest[i]\n            remaining_nodes = tuple(sorted(nodes_rest[:i] + nodes_rest[i+1:]))\n            \n            sub_matching = get_mwpm_edges(remaining_nodes)\n            current_cost = dist_matrix[p1, p2] + sum(dist_matrix[u, v] for u, v in sub_matching)\n            \n            if current_cost  min_cost:\n                min_cost = current_cost\n                best_pairing = [(p1, p2)] + sub_matching\n        \n        memo_mwpm[nodes_tuple] = best_pairing\n        return best_pairing\n\n    matching_edges = []\n    if odd_vertices:\n        matching_edges = get_mwpm_edges(tuple(sorted(odd_vertices)))\n\n    # 4. Form Eulerian multigraph\n    adj = collections.defaultdict(list)\n    for u, v in mst_edges + matching_edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # 5. Find Eulerian path (Hierholzer's algorithm)\n    start_node = 0\n    stack = [start_node]\n    euler_path = []\n    while stack:\n        u = stack[-1]\n        if adj[u]:\n            v = adj[u].pop()\n            adj[v].remove(u)\n            stack.append(v)\n        else:\n            euler_path.append(stack.pop())\n    \n    euler_path.reverse()\n\n    # 6. Shortcut to create Hamiltonian cycle\n    visited = set()\n    final_tour = []\n    for node in euler_path:\n        if node not in visited:\n            final_tour.append(node)\n            visited.add(node)\n    \n    # Calculate tour length\n    tour_len = 0\n    for i in range(len(final_tour)):\n        u = final_tour[i]\n        v = final_tour[(i + 1) % len(final_tour)]\n        tour_len += dist_matrix[u, v]\n        \n    return tour_len\n\ndef _compute_held_karp(dist_matrix):\n    \"\"\"Computes the optimal TSP tour length using Held-Karp algorithm.\"\"\"\n    n = dist_matrix.shape[0]\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n\n    # dp[mask][i] = cost of path from 0 to i visiting nodes in mask\n    dp = np.full((1  n, n), float('inf'))\n    \n    # Base case: path from 0 to 0 has cost 0\n    dp[1, 0] = 0\n    \n    for mask in range(1, 1  n):\n        for j in range(n):\n            if (mask >> j)  1:  # if j is in the set\n                if mask == (1  j): # if j is the only one in the set\n                    if j == 0:\n                        continue # this is the base case\n                    else:\n                        # this path must start from 0\n                        dp[mask, j] = dist_matrix[0,j]\n                \n                prev_mask = mask ^ (1  j)\n                if prev_mask == 0:\n                    continue\n\n                # Find the minimum cost to reach j from a previous node k\n                min_val = float('inf')\n                for k in range(n):\n                    if (prev_mask >> k)  1: # if k is in the previous set\n                        if dp[prev_mask, k] != float('inf'):\n                            min_val = min(min_val, dp[prev_mask, k] + dist_matrix[k, j])\n                dp[mask,j] = min_val\n\n    # Final step: complete the tour by returning to the start node\n    final_mask = (1  n) - 1\n    min_tour_len = float('inf')\n    \n    for j in range(1, n):\n        if dp[final_mask, j] != float('inf'):\n            min_tour_len = min(min_tour_len, dp[final_mask, j] + dist_matrix[j, 0])\n            \n    return min_tour_len if min_tour_len != float('inf') else 0\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3280045"}, {"introduction": "The Christofides algorithm is elegant, but its minimum-weight perfect matching step can be computationally demanding. This final practice delves into a common theme in algorithm design: the trade-off between optimality and speed. You will implement a variation of the Christofides scheme where the exact matching algorithm is replaced with a simpler, faster greedy heuristic [@problem_id:3280073]. By analyzing the performance of this new heuristic against both the standard Christofides tour and the optimal tour, you will gain practical insight into how algorithmic choices impact solution quality and what it means to design \"good enough\" solutions for hard problems.", "problem": "You are given the Traveling Salesman Problem (TSP) in the metric setting: for a finite set of points, the distance between any two points satisfies the triangle inequality. Consider the following scheme for constructing approximate tours based on the Minimum Spanning Tree (MST) and the set of odd-degree vertices in the MST. The scheme has two variants for the matching step on the odd-degree vertex set: (i) Minimum-Cost Perfect Matching (exact optimal matching) and (ii) Greedy Matching (iteratively pick the currently shortest available edge that does not create conflicts until all vertices are paired). Once a matching is computed, augment the MST with the matching edges to obtain an Eulerian multigraph, find an Eulerian tour, and then shortcut repeated vertices to obtain a Hamiltonian cycle, whose length is measured under the given metric. \n\nFundamental definitions to be used:\n- The metric Traveling Salesman Problem (metric TSP) is defined on a complete weighted graph with vertex set $V$ and weight function $d: V \\times V \\to \\mathbb{R}_{\\ge 0}$ such that $d(u,v) = d(v,u)$ for all $u,v \\in V$, $d(u,u) = 0$, and the triangle inequality $d(u,v) \\le d(u,w) + d(w,v)$ holds for all $u,v,w \\in V$.\n- A Minimum Spanning Tree (MST) of a weighted undirected graph is a spanning tree minimizing the sum of edge weights.\n- In any tree, the number of vertices with odd degree is even. Let $O \\subseteq V$ denote the set of vertices with odd degree in the MST.\n- A perfect matching on a set $O$ is a set of disjoint pairs that covers all vertices of $O$ exactly once. A minimum-cost perfect matching minimizes the sum of the weights of the matched pairs.\n- An Eulerian multigraph is an undirected multigraph where every vertex has even degree; such a graph admits a closed walk visiting every edge exactly once (an Eulerian tour).\n- Shortcutting an Eulerian tour in a metric setting means visiting vertices in the order they first appear on the tour and skipping repeated visits; the triangle inequality guarantees that the total length does not increase when taking shortcuts.\n\nYour task is to implement, from these definitions:\n1. Construction of the MST on the complete graph induced by a given set of planar points using Euclidean distance $d((x_1,y_1),(x_2,y_2)) = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}$.\n2. Identification of the odd-degree set $O$ from the MST.\n3. Two matching procedures on $O$:\n   - Minimum-Cost Perfect Matching (exact), computed via a principled dynamic programming over subsets.\n   - Greedy Matching, computed by sorting all possible pairs in $O$ by weight and greedily adding non-conflicting pairs until all vertices are matched.\n4. Augmentation of the MST with the matching edges to obtain an Eulerian multigraph, construction of an Eulerian tour, and shortcutting to a Hamiltonian tour.\n5. Exact computation of the optimal TSP tour length by brute force for the given small instances.\n\nFrom first principles, you must derive both schemes and compute the resulting tour lengths for each instance. You must also quantify how the greedy matching affects the quality of the final tour compared to the minimum-cost matching and the optimal TSP tour.\n\nTest Suite Specification:\n- Each test instance consists of an explicit list of planar points $(x_i,y_i)$ with Euclidean distance; angles, if any were to be considered, are irrelevant here and distances are unitless real numbers calculated from coordinates without requiring any physical unit.\n- For each instance, you must compute and return two floats:\n  - $r_{g/o}$, the ratio of the greedy-matching-based tour length to the optimal TSP tour length.\n  - $r_{g/m}$, the ratio of the greedy-matching-based tour length to the minimum-cost-matching-based tour length.\n\nProvide a test suite covering distinct facets:\n- Instance A (general position, happy path): $6$ points forming a slightly perturbed hexagon: $(0,0)$, $(1,0)$, $(1.5,0.866)$, $(0.5,1.3)$, $(-0.3,0.7)$, $(-0.2,-0.1)$.\n- Instance B (boundary, collinear points): $6$ points on a line: $(0,0)$, $(1,0)$, $(2,0)$, $(3,0)$, $(4,0)$, $(5,0)$.\n- Instance C (clustered structure): $8$ points in two clusters: $(-2,-2)$, $(-2,2)$, $(-1,-1)$, $(-1,1)$, $(2,-2)$, $(2,2)$, $(1,-1)$, $(1,1)$.\n- Instance D (constructed stress test): $8$ points arranged to stress greedy matching: $(0,0)$, $(2,0)$, $(0,3)$, $(2,3)$, $(6,0)$, $(6,3)$, $(3,1.5)$, $(9,1.5)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, $[r_{g/o}^{A}, r_{g/m}^{A}, r_{g/o}^{B}, r_{g/m}^{B}, r_{g/o}^{C}, r_{g/m}^{C}, r_{g/o}^{D}, r_{g/m}^{D}]$, where the superscript denotes the instance. All values must be printed as Python floats.", "solution": "The user has provided a well-defined computational problem in the domain of approximation algorithms for the metric Traveling Salesman Problem (TSP). The problem is scientifically grounded, logically consistent, and all terms and procedures are formally specified. The task is to implement and compare two variants of a Christofides-like approximation algorithm against each other and against the optimal TSP solution for several small instances. The two variants differ in the method used for finding a perfect matching on the set of odd-degree vertices of a Minimum Spanning Tree (MST).\n\nThe solution proceeds by implementing, from first principles, all required algorithmic components:\n1.  **Distance Matrix**: A helper function calculates the Euclidean distances between all pairs of input points, forming a symmetric matrix that represents the complete graph $K_n$.\n2.  **Optimal TSP Tour ($L_{opt}$)**: For the small instances provided ($n \\in \\{6, 8\\}$), the optimal tour length is computed by brute force. This involves iterating through all possible Hamiltonian cycles, calculating their lengths, and finding the minimum. The number of such cycles is $(n-1)!/2$, which is computationally tractable for small $n$.\n3.  **Minimum Spanning Tree (MST)**: Kruskal's algorithm is used to find an MST of the graph. Edges are sorted by weight, and a Disjoint Set Union (DSU) data structure is employed to build the tree by adding edges that connect previously disconnected components.\n4.  **Odd-Degree Vertices ($O$)**: After constructing the MST, the set of vertices with an odd degree is identified. A fundamental property of any graph (and thus any tree) is that the number of odd-degree vertices is always even.\n5.  **Minimum-Cost Perfect Matching (MCM)**: The problem specifies computing an exact minimum-cost perfect matching on the set $O$. This is achieved using dynamic programming over subsets of $O$. The state $dp[S]$ stores the minimum cost to match vertices in a subset $S \\subseteq O$. The recurrence is formulated by selecting an arbitrary vertex $i \\in S$ and pairing it with every other vertex $j \\in S$, minimizing over the sum of the edge weight $d(i,j)$ and the cost of matching the remaining set $S \\setminus \\{i,j\\}$.\n6.  **Greedy Matching**: A second, simpler matching heuristic is implemented. All possible edges between pairs of vertices in $O$ are generated and sorted by weight in non-decreasing order. The algorithm greedily selects edges from this sorted list, adding an edge $(u,v)$ to the matching if neither $u$ nor $v$ has been matched yet, until all vertices in $O$ are covered.\n7.  **Tour Construction and Shortcutting**: For each of the two matching schemes, the MST edges are augmented with the corresponding matching edges. This creates an Eulerian multigraph (all vertex degrees are even). An Eulerian tour, which traverses every edge exactly once, is found using Hierholzer's algorithm. This tour may visit vertices multiple times. A final Hamiltonian cycle (the TSP tour) is obtained by \"shortcutting\": traversing the vertices in the order of their first appearance in the Eulerian tour. The triangle inequality, which holds for Euclidean distance, guarantees that this shortcutting process does not increase the total tour length.\n8.  **Ratio Calculation**: The lengths of the tours generated by the minimum-cost matching ($L_{mcm}$) and the greedy matching ($L_{greedy}$) are calculated. For each test instance, the required ratios $r_{g/o} = L_{greedy} / L_{opt}$ and $r_{g/m} = L_{greedy} / L_{mcm}$ are computed.\n\nThe entire process is encapsulated within a single function and applied to each of the four specified test instances. The final output is a list of these computed ratios.", "answer": "```python\nimport numpy as np\nimport itertools\nimport math\n\ndef solve():\n    # Per the problem specification, all logic is contained within this function.\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Instance A: General position, 6 points\n        [(0, 0), (1, 0), (1.5, 0.866), (0.5, 1.3), (-0.3, 0.7), (-0.2, -0.1)],\n        # Instance B: Collinear points, 6 points\n        [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0)],\n        # Instance C: Clustered structure, 8 points\n        [(-2, -2), (-2, 2), (-1, -1), (-1, 1), (2, -2), (2, 2), (1, -1), (1, 1)],\n        # Instance D: Constructed stress test, 8 points\n        [(0, 0), (2, 0), (0, 3), (2, 3), (6, 0), (6, 3), (3, 1.5), (9, 1.5)],\n    ]\n\n    # ========== HELPER CLASSES AND FUNCTIONS ==========\n\n    class DSU:\n        \"\"\"A Disjoint Set Union data structure for Kruskal's algorithm.\"\"\"\n        def __init__(self, n):\n            self.parent = list(range(n))\n        \n        def find(self, i):\n            if self.parent[i] == i:\n                return i\n            self.parent[i] = self.find(self.parent[i])\n            return self.parent[i]\n\n        def union(self, i, j):\n            root_i = self.find(i)\n            root_j = self.find(j)\n            if root_i != root_j:\n                self.parent[root_j] = root_i\n                return True\n            return False\n\n    def compute_distance_matrix(points):\n        \"\"\"Computes the Euclidean distance matrix for a set of points.\"\"\"\n        n = len(points)\n        dist_matrix = np.zeros((n, n), dtype=float)\n        for i in range(n):\n            for j in range(i, n):\n                dist = math.sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)\n                dist_matrix[i, j] = dist_matrix[j, i] = dist\n        return dist_matrix\n\n    def solve_tsp_optimal(dist_matrix):\n        \"\"\"Computes the optimal TSP tour length by brute force.\"\"\"\n        n = dist_matrix.shape[0]\n        if n = 1:\n            return 0.0\n        \n        min_len = float('inf')\n        nodes = list(range(1, n)) # Exclude starting node 0\n\n        for p in itertools.permutations(nodes):\n            current_len = dist_matrix[0, p[0]]\n            for i in range(len(p) - 1):\n                current_len += dist_matrix[p[i], p[i+1]]\n            current_len += dist_matrix[p[-1], 0]\n            if current_len  min_len:\n                min_len = current_len\n        return min_len\n\n    def compute_mst(dist_matrix):\n        \"\"\"Computes an MST using Kruskal's algorithm.\"\"\"\n        n = dist_matrix.shape[0]\n        edges = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                edges.append((dist_matrix[i, j], i, j))\n        edges.sort()\n        \n        dsu = DSU(n)\n        mst_edges = []\n        for weight, u, v in edges:\n            if dsu.union(u, v):\n                mst_edges.append((u, v))\n                if len(mst_edges) == n - 1:\n                    break\n        return mst_edges\n\n    def find_odd_degree_vertices(mst_edges, n):\n        \"\"\"Finds vertices with odd degree in the MST.\"\"\"\n        degrees = [0] * n\n        for u, v in mst_edges:\n            degrees[u] += 1\n            degrees[v] += 1\n        return [i for i, deg in enumerate(degrees) if deg % 2 != 0]\n\n    def solve_mcm_dp(odd_vertices, dist_matrix):\n        \"\"\"Computes the Minimum-Cost Perfect Matching using dynamic programming.\"\"\"\n        k = len(odd_vertices)\n        if k == 0:\n            return [], 0.0\n\n        memo = {}\n        def dp(mask):\n            if mask == 0:\n                return 0.0, []\n            if mask in memo:\n                return memo[mask]\n\n            min_cost = float('inf')\n            best_edges = []\n            \n            p1_local = (mask  -mask).bit_length() - 1\n            \n            for p2_local in range(p1_local + 1, k):\n                if (mask >> p2_local)  1:\n                    p1_global = odd_vertices[p1_local]\n                    p2_global = odd_vertices[p2_local]\n                    cost = dist_matrix[p1_global, p2_global]\n                    new_mask = mask ^ (1  p1_local) ^ (1  p2_local)\n                    sub_cost, sub_edges = dp(new_mask)\n                    \n                    if cost + sub_cost  min_cost:\n                        min_cost = cost + sub_cost\n                        best_edges = sub_edges + [(p1_global, p2_global)]\n\n            memo[mask] = (min_cost, best_edges)\n            return min_cost, best_edges\n\n        total_cost, edges = dp((1  k) - 1)\n        return edges, total_cost\n\n    def solve_greedy_matching(odd_vertices, dist_matrix):\n        \"\"\"Computes a perfect matching on odd vertices using a greedy approach.\"\"\"\n        if not odd_vertices:\n            return [], 0.0\n        \n        pairs = list(itertools.combinations(odd_vertices, 2))\n        sorted_pairs = sorted(pairs, key=lambda p: dist_matrix[p[0], p[1]])\n        \n        matched, matching_edges = set(), []\n        for u, v in sorted_pairs:\n            if u not in matched and v not in matched:\n                matching_edges.append((u, v))\n                matched.update([u, v])\n            if len(matched) == len(odd_vertices):\n                break\n        return matching_edges\n\n    def build_and_shortcut_tour(mst_edges, matching_edges, n, dist_matrix):\n        \"\"\"Builds an Eulerian multigraph, finds a tour, shortcuts, and returns its length.\"\"\"\n        adj = [[] for _ in range(n)]\n        for u, v in mst_edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        for u, v in matching_edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        if not any(adj): return 0.0\n            \n        start_node = next((i for i, sublist in enumerate(adj) if sublist), 0)\n        \n        euler_path = []\n        def find_path(u):\n            while adj[u]:\n                v = adj[u].pop(0)\n                adj[v].remove(u)\n                find_path(v)\n            euler_path.append(u)\n        \n        find_path(start_node)\n        euler_path.reverse()\n        \n        if not euler_path: return 0.0\n\n        path, visited = [], set()\n        for node in euler_path:\n            if node not in visited:\n                path.append(node)\n                visited.add(node)\n        \n        tour_len = sum(dist_matrix[path[i], path[i+1]] for i in range(len(path) - 1))\n        tour_len += dist_matrix[path[-1], path[0]]\n        return tour_len\n\n    # ========== MAIN PROCESSING LOGIC ==========\n\n    final_results = []\n    for points in test_cases:\n        n = len(points)\n        dist_matrix = compute_distance_matrix(points)\n        \n        l_opt = solve_tsp_optimal(dist_matrix)\n        mst_edges = compute_mst(dist_matrix)\n        odd_vertices = find_odd_degree_vertices(mst_edges, n)\n        \n        mcm_edges, _ = solve_mcm_dp(odd_vertices, dist_matrix)\n        greedy_edges = solve_greedy_matching(odd_vertices, dist_matrix)\n        \n        l_mcm = build_and_shortcut_tour(mst_edges, mcm_edges, n, dist_matrix)\n        l_greedy = build_and_shortcut_tour(mst_edges, greedy_edges, n, dist_matrix)\n        \n        r_g_o = l_greedy / l_opt if l_opt > 0 else 1.0\n        r_g_m = l_greedy / l_mcm if l_mcm > 0 else 1.0\n        \n        final_results.extend([r_g_o, r_g_m])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3280073"}]}