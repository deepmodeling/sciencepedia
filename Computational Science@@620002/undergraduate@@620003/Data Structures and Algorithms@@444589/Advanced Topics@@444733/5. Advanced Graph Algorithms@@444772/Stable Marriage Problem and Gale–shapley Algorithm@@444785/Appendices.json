{"hands_on_practices": [{"introduction": "The Gale-Shapley algorithm is celebrated for its guarantee to find a stable matching. But what does it mean for a matching to be stable, and how can we check this property for any arbitrary pairing? This first exercise tackles that fundamental question by challenging you to develop an efficient method for counting blocking pairs, the tell-tale signs of instability. Mastering this verification is the first step toward a deep understanding of the problem space [@problem_id:3274083].", "problem": "You are given the classical Stable Marriage Problem (SMP), which consists of two disjoint sets of equal size, a set of men and a set of women. Let the number of men be $n$, the number of women be $n$, and let the men be indexed by $\\{0,1,\\dots,n-1\\}$ and the women be indexed by $\\{0,1,\\dots,n-1\\}$. Each man provides a strict total order (no ties) over all women, and each woman provides a strict total order (no ties) over all men. A perfect matching is a bijection $\\mu$ that pairs each man $m$ with exactly one woman $\\mu(m)$ and each woman $w$ with exactly one man $\\mu^{-1}(w)$.\n\nA pair $(m,w)$ is a blocking pair for a matching $\\mu$ if man $m$ and woman $w$ are not matched to each other in $\\mu$, and both $m$ and $w$ strictly prefer each other to their assigned partners under $\\mu$. A matching is stable if and only if there are no blocking pairs.\n\nStarting from the fundamental definitions above, devise an algorithm that, given:\n- a complete strict preference profile for all men and all women, and\n- a perfect matching $\\mu$,\n\ncomputes the exact number of blocking pairs by using rank matrices. Your algorithm must run in time $O(n^2)$ after the preferences and the matching are provided. The rank matrix for men, denoted $R^{M}$, is defined by $R^{M}[m][w] = r$ if woman $w$ is ranked at position $r$ in man $m$'s preference list (with lower values indicating stronger preference). Similarly, the rank matrix for women, denoted $R^{W}$, is defined by $R^{W}[w][m] = r$ if man $m$ is ranked at position $r$ in woman $w$'s preference list (with lower values indicating stronger preference).\n\nYour task is to implement this algorithm and then use it to measure a matching’s closeness to stability by the following normalized instability index:\n$$\nI(\\mu) = \n\\begin{cases}\n\\frac{B(\\mu)}{n^2 - n}, & \\text{if } n^2 - n \\neq 0 \\\\\n0, & \\text{if } n^2 - n = 0\n\\end{cases}\n$$\nwhere $B(\\mu)$ is the number of blocking pairs for $\\mu$. The denominator $n^2 - n$ is the total number of cross pairs $(m,w)$ that are not matched together in a perfect matching. The normalized instability index $I(\\mu)$ takes values in $[0,1]$.\n\nImplement a program that, for each test case below, returns a two-element list $[B(\\mu), I(\\mu)]$ where $B(\\mu)$ is an integer and $I(\\mu)$ is a real number rounded to three decimal places.\n\nTest suite to cover a range of cases:\n- Case A (boundary size): $n=1$.\n  - Men’s preferences: $[[0]]$.\n  - Women’s preferences: $[[0]]$.\n  - Matching: $[0]$.\n- Case B (stable matching, no blocking pairs): $n=3$.\n  - Men’s preferences: $[[0,1,2],[1,2,0],[2,0,1]]$.\n  - Women’s preferences: $[[0,1,2],[1,2,0],[2,0,1]]$.\n  - Matching: $[0,1,2]$.\n- Case C (some blocking pairs): $n=3$.\n  - Men’s preferences: $[[1,0,2],[0,1,2],[0,1,2]]$.\n  - Women’s preferences: $[[1,0,2],[0,1,2],[0,1,2]]$.\n  - Matching: $[0,1,2]$.\n- Case D (many blocking pairs relative to size): $n=4$.\n  - Men’s preferences: $[[0,1,2,3],[0,1,2,3],[0,1,2,3],[0,1,2,3]]$.\n  - Women’s preferences: $[[0,1,2,3],[0,1,2,3],[0,1,2,3],[0,1,2,3]]$.\n  - Matching: $[3,2,1,0]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the two-element list for the corresponding test case, in the same order as listed above. For example, the output must have the form\n\"[[B_A,I_A],[B_B,I_B],[B_C,I_C],[B_D,I_D]]\"\nwith $I_A,I_B,I_C,I_D$ each rounded to three decimal places.", "solution": "The problem is valid. It is a well-defined algorithmic task from the field of discrete mathematics and computer science, specifically concerning the analysis of matchings in the context of the Stable Marriage Problem. All inputs, definitions, and constraints are clear, consistent, and scientifically sound.\n\nThe problem requires us to devise an algorithm to count the number of blocking pairs for a given perfect matching $\\mu$ in a stable marriage instance of size $n$. The algorithm must operate within a time complexity of $O(n^2)$. Subsequently, this count is used to compute a normalized instability index $I(\\mu)$.\n\nA blocking pair for a perfect matching $\\mu$ is a pair $(m, w)$ consisting of a man $m$ and a woman $w$ who are not matched to each other, but who both strictly prefer each other to their partners under $\\mu$. Formally, $(m, w)$ is a blocking pair if and only if three conditions are met:\n1.  Man $m$ and woman $w$ are not matched: $\\mu(m) \\neq w$.\n2.  Man $m$ prefers woman $w$ over his assigned partner $\\mu(m)$.\n3.  Woman $w$ prefers man $m$ over her assigned partner $\\mu^{-1}(w)$.\n\nA naive approach would be to iterate through all $n^2 - n$ pairs $(m, w)$ not in the matching $\\mu$ and, for each pair, check the two preference conditions. Verifying a preference by searching through an individual's preference list of length $n$ would take $O(n)$ time. This leads to an overall time complexity of $O(n^3)$, which is inefficient and does not meet the specified $O(n^2)$ constraint.\n\nTo achieve the required $O(n^2)$ complexity, we must perform preference checks in constant, $O(1)$, time. As suggested, this can be achieved by preprocessing the preference lists into rank matrices. We define two rank matrices, one for men ($R^M$) and one for women ($R^W$).\n\nThe men's rank matrix, $R^M$, is an $n \\times n$ matrix where the entry $R^M[m][w]$ stores the rank of woman $w$ in man $m$'s preference list. A lower rank value signifies a higher preference. For instance, if man $m$'s most preferred woman is $w_i$, then $R^M[m][w_i] = 0$. This matrix can be constructed in $O(n^2)$ time by iterating through each man's preference list. For each man $m$ from $0$ to $n-1$, we iterate through his preference list: if woman $w$ is at position (rank) $r$ in the list, we set $R^M[m][w] = r$.\n\nSimilarly, the women's rank matrix, $R^W$, is an $n \\times n$ matrix where $R^W[w][m]$ stores the rank of man $m$ in woman $w$'s preference list. This matrix can also be constructed in $O(n^2)$ time.\n\nWith these rank matrices, the preference conditions for a blocking pair $(m, w)$ can be checked in $O(1)$ time:\n- Man $m$ prefers $w$ over $\\mu(m)$ if and only if $R^M[m][w]  R^M[m][\\mu(m)]$.\n- Woman $w$ prefers $m$ over $\\mu^{-1}(w)$ if and only if $R^W[w][m]  R^W[w][\\mu^{-1}(w)]$.\n\nThe complete $O(n^2)$ algorithm is as follows:\n\n1.  **Preprocessing (Time: $O(n^2)$):**\n    a. Given the men's preference lists, construct the men's rank matrix $R^M$. This takes $O(n^2)$ time.\n    b. Given the women's preference lists, construct the women's rank matrix $R^W$. This also takes $O(n^2)$ time.\n    c. Given the matching $\\mu$ (an array where `matching[m]` $= \\mu(m)$), construct the inverse matching $\\mu^{-1}$ (an array where `inverse_matching[w]` $= \\mu^{-1}(w)$). This takes $O(n)$ time.\n\n2.  **Blocking Pair Count (Time: $O(n^2)$):**\n    a. Initialize a counter for the number of blocking pairs, $B(\\mu)$, to $0$.\n    b. Iterate through every possible pair of a man $m$ (from $0$ to $n-1$) and a woman $w$ (from $0$ to $n-1$).\n    c. For each pair $(m, w)$, first check if they are already matched, i.e., if $w = \\mu(m)$. If they are, this pair cannot be a blocking pair, so we continue to the next pair.\n    d. If they are not matched, check the two preference conditions using the rank matrices:\n        i.  $R^M[m][w]  R^M[m][\\mu(m)]$\n        ii. $R^W[w][m]  R^W[w][\\mu^{-1}(w)]$\n    e. If both conditions are true, the pair $(m, w)$ is a blocking pair. Increment the counter $B(\\mu)$.\n\n3.  **Instability Index Calculation (Time: $O(1)$):**\n    a. After iterating through all $n^2$ pairs, the counter $B(\\mu)$ will hold the total number of blocking pairs.\n    b. The normalized instability index $I(\\mu)$ is then calculated according to the formula:\n    $$\n    I(\\mu) = \n    \\begin{cases}\n    \\frac{B(\\mu)}{n^2 - n},  \\text{if } n^2 - n \\neq 0 \\\\\n    0,  \\text{if } n^2 - n = 0\n    \\end{cases}\n    $$\n    The case $n^2-n=0$ occurs only for $n=0$ or $n=1$. For $n=1$, there are no non-matched pairs, so $B(\\mu)$ is necessarily $0$, and $I(\\mu)$ is defined to be $0$. For $n>1$, the denominator is non-zero. This index $I(\\mu)$ represents the fraction of non-matched pairs that are unstable.\n\nThe total time complexity of this algorithm is the sum of the complexities of its steps: $O(n^2)$ for preprocessing and $O(n^2)$ for counting, yielding an overall complexity of $O(n^2)$, which satisfies the problem's constraint.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_instability(n, men_prefs, women_prefs, matching):\n    \"\"\"\n    Computes the number of blocking pairs and the instability index for a given matching.\n\n    Args:\n        n (int): The number of men and women.\n        men_prefs (list of list of int): Men's preference lists.\n        women_prefs (list of list of int): Women's preference lists.\n        matching (list of int): The matching to analyze, where matching[m] = w.\n\n    Returns:\n        tuple: A tuple (B, I) where B is the number of blocking pairs and I is the\n               normalized instability index.\n    \"\"\"\n    if n = 1:\n        # For n=1, there are no non-matched pairs, so B=0.\n        # The problem defines I=0 for this case.\n        return 0, 0.0\n\n    # Step 1: Preprocessing\n    # a. Construct men's rank matrix R_M\n    # R_M[m][w] = rank of woman w in man m's preference list\n    R_M = np.zeros((n, n), dtype=int)\n    for m in range(n):\n        for rank, w in enumerate(men_prefs[m]):\n            R_M[m, w] = rank\n\n    # b. Construct women's rank matrix R_W\n    # R_W[w][m] = rank of man m in woman w's preference list\n    R_W = np.zeros((n, n), dtype=int)\n    for w in range(n):\n        for rank, m in enumerate(women_prefs[w]):\n            R_W[w, m] = rank\n\n    # c. Construct the inverse matching\n    inverse_matching = np.zeros(n, dtype=int)\n    for m, w in enumerate(matching):\n        inverse_matching[w] = m\n    \n    # Pre-fetch the ranks of the current partners for faster lookups\n    # Although not strictly necessary for complexity, it can clarify the loop\n    man_partner_ranks = np.zeros(n, dtype=int)\n    for m in range(n):\n        man_partner_ranks[m] = R_M[m, matching[m]]\n        \n    woman_partner_ranks = np.zeros(n, dtype=int)\n    for w in range(n):\n        woman_partner_ranks[w] = R_W[w, inverse_matching[w]]\n\n    # Step 2: Blocking Pair Count\n    blocking_pairs_count = 0\n    for m in range(n):\n        for w in range(n):\n            # A pair cannot block itself\n            if matching[m] == w:\n                continue\n\n            # Check if (m, w) is a blocking pair\n            # Condition 1: m prefers w to his current partner\n            m_prefers_w = R_M[m, w]  man_partner_ranks[m]\n            \n            # Condition 2: w prefers m to her current partner\n            w_prefers_m = R_W[w, m]  woman_partner_ranks[w]\n\n            if m_prefers_w and w_prefers_m:\n                blocking_pairs_count += 1\n    \n    B = blocking_pairs_count\n    \n    # Step 3: Instability Index Calculation\n    # Denominator is the total number of non-matched pairs\n    denominator = n**2 - n\n    I = B / denominator if denominator != 0 else 0.0\n\n    return B, I\n\ndef solve():\n    \"\"\"\n    Defines the test cases and runs the instability calculation for each,\n    then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        # Case A (boundary size): n=1\n        {\n            \"n\": 1,\n            \"men_prefs\": [[0]],\n            \"women_prefs\": [[0]],\n            \"matching\": [0]\n        },\n        # Case B (stable matching, no blocking pairs): n=3\n        {\n            \"n\": 3,\n            \"men_prefs\": [[0, 1, 2], [1, 2, 0], [2, 0, 1]],\n            \"women_prefs\": [[0, 1, 2], [1, 2, 0], [2, 0, 1]],\n            \"matching\": [0, 1, 2]\n        },\n        # Case C (some blocking pairs): n=3\n        {\n            \"n\": 3,\n            \"men_prefs\": [[1, 0, 2], [0, 1, 2], [0, 1, 2]],\n            \"women_prefs\": [[1, 0, 2], [0, 1, 2], [0, 1, 2]],\n            \"matching\": [0, 1, 2]\n        },\n        # Case D (many blocking pairs relative to size): n=4\n        {\n            \"n\": 4,\n            \"men_prefs\": [[0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3]],\n            \"women_prefs\": [[0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3]],\n            \"matching\": [3, 2, 1, 0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        B, I = calculate_instability(case[\"n\"], case[\"men_prefs\"], case[\"women_prefs\"], case[\"matching\"])\n        # Round the instability index to three decimal places\n        I_rounded = round(I, 3)\n        results.append([B, I_rounded])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3274083"}, {"introduction": "Standard algorithms are often just a starting point, and real-world applications frequently introduce new rules, such as when certain pairings are forbidden or when agents only have preferences over a subset of potential partners. This practice asks you to adapt the Gale-Shapley algorithm to accommodate such constraints. By modifying the core procedure to handle incomplete lists and forbidden pairs, you will gain valuable experience in extending foundational algorithms to solve more complex, practical problems [@problem_id:3274062].", "problem": "Consider the Stable Marriage Problem (SMP) with incomplete lists and forbidden pairs. Let there be two disjoint sets of agents, a proposing side $U$ and a receiving side $V$, where $|U| = |V| = n$ for some integer $n \\geq 1$. Each agent $u \\in U$ has a strict preference order over a subset of agents in $V$, and each agent $v \\in V$ has a strict preference order over a subset of agents in $U$. A pair $(u,v)$ is acceptable if and only if both $u$ lists $v$ and $v$ lists $u$. Additionally, a subset $F \\subseteq U \\times V$ of pairs are declared forbidden, meaning any pair $(u,v) \\in F$ can never be matched, even if $(u,v)$ is acceptable according to the agents’ lists.\n\nA matching $M \\subseteq U \\times V$ is a set of disjoint pairs (no agent appears in more than one pair). Unmatched agents are permitted. For acceptability, a pair $(u,v)$ belongs to $M$ only if $(u,v)$ is acceptable and $(u,v) \\notin F$. A pair $(u,v)$ not in $M$ is a blocking pair if $(u,v)$ is acceptable, $(u,v) \\notin F$, agent $u$ strictly prefers $v$ to $u$’s current partner in $M$ (or being unmatched), and agent $v$ strictly prefers $u$ to $v$’s current partner in $M$ (or being unmatched). A matching is stable if it has no blocking pair.\n\nStarting from the core definitions of stability, acceptability, and strict preferences, and using the Gale–Shapley algorithm (GSA) as the fundamental procedure, adapt the algorithm so that proposals never occur to forbidden or unacceptable partners. Your algorithm must handle potentially incomplete preference lists on both sides and the forbidden set $F$. The program must:\n- Construct an $U$-proposing Gale–Shapley procedure that ignores forbidden and unacceptable pairs.\n- Produce a stable matching $M$ (possibly incomplete).\n- Verify stability by counting the number of blocking pairs using the formal definition above.\n- Analyze the existence of a stable perfect matching (one that matches all agents on both sides): return a boolean indicating whether the adapted Gale–Shapley procedure results in a perfect matching. This condition is necessary and sufficient for the existence of a stable perfect matching in SMP with incomplete lists and no ties.\n\nFor each test case, your program must return a list $[s, p, b, u, M]$, where:\n- $s$ is a boolean indicating whether the algorithm produced a stable matching (this should be true if and only if $b = 0$),\n- $p$ is a boolean indicating whether the matching is perfect (all $n$ agents in $U$ are matched),\n- $b$ is the integer number of blocking pairs,\n- $u$ is the integer number of unmatched agents in $U$,\n- $M$ is a list of matched pairs, encoded as a list of lists $[[u_1, v_1], [u_2, v_2], \\dots]$, with each $u_i$ and $v_i$ written as integers.\n\nImplement your solution and compute outputs for the following test suite. In each case, $n$ is specified, as well as preference lists and forbidden pairs. All integers in the lists denote agent indices.\n\n- Test Case $1$ (happy path, perfect matching exists):\n  - $n = 3$\n  - $P_U = \\{0 : [0,1,2],\\ 1 : [1,2,0],\\ 2 : [2,1,0]\\}$\n  - $P_V = \\{0 : [1,0,2],\\ 1 : [0,1,2],\\ 2 : [2,1,0]\\}$\n  - $F = \\{(0,2)\\}$\n\n- Test Case $2$ (no forbidden pairs, standard SMP):\n  - $n = 3$\n  - $P_U = \\{0 : [1,0,2],\\ 1 : [1,2,0],\\ 2 : [0,2,1]\\}$\n  - $P_V = \\{0 : [2,0,1],\\ 1 : [0,1,2],\\ 2 : [1,2,0]\\}$\n  - $F = \\{\\}$\n\n- Test Case $3$ (one agent with an empty acceptable list due to forbidden pairs, no perfect matching):\n  - $n = 4$\n  - $P_U = \\{0 : [0,1,2,3],\\ 1 : [1,0,2,3],\\ 2 : [2,3,1,0],\\ 3 : [3,2,1,0]\\}$\n  - $P_V = \\{0 : [1,0,2,3],\\ 1 : [0,1,2,3],\\ 2 : [2,3,1,0],\\ 3 : [3,2,1,0]\\}$\n  - $F = \\{(3,0),(3,1),(3,2),(3,3)\\}$\n\n- Test Case $4$ (competition for a single receiver with heavily restricted alternatives, no perfect matching):\n  - $n = 4$\n  - $P_U = \\{0 : [0],\\ 1 : [0],\\ 2 : [1,2,3],\\ 3 : [3,2,1]\\}$\n  - $P_V = \\{0 : [1,0,2,3],\\ 1 : [2,3,1,0],\\ 2 : [2,3,1,0],\\ 3 : [3,2,1,0]\\}$\n  - $F = \\{(1,1),(1,2),(1,3)\\}$\n\n- Test Case $5$ (boundary, minimal size with one proposer having no acceptable partners):\n  - $n = 2$\n  - $P_U = \\{0 : [0],\\ 1 : [1,0]\\}$\n  - $P_V = \\{0 : [1,0],\\ 1 : [1,0]\\}$\n  - $F = \\{(0,0)\\}$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[result_1,result_2,\\dots,result_k]$), where each $result_i$ corresponds to one test case and is formatted exactly as $[s,p,b,u,M]$ described above. The program must be self-contained, require no input, and use the specified runtime environment. All returned values must be from the set of basic types: boolean, integer, float, or lists of these types. No strings are permitted in the encoded matching $M$.", "solution": "The problem requires an adaptation of the Gale-Shapley algorithm (GSA) to solve the Stable Marriage Problem with Incomplete Lists and Forbidden Pairs. The solution must handle these constraints, produce a stable matching, and verify its properties. The core principles guiding this solution are the formal definitions of acceptability, forbidden pairs, and stability.\n\nThe overall approach is structured into three main phases:\n1.  **Preprocessing**: We first construct effective preference lists for the proposing agents ($U$). A pair $(u,v)$ is a valid candidate for matching only if it is both *acceptable* (i.e., $u$ is on $v$'s preference list and $v$ is on $u$'s list) and *not forbidden* (i.e., $(u,v) \\notin F$). By filtering each proposer's preference list to include only such valid partners at the outset, we ensure that the subsequent algorithm only considers pairs that are eligible to be part of a stable matching. This transforms the problem into an equivalent instance of the Stable Marriage Problem with Incomplete Lists (SMPI), for which the GSA is a standard solution method.\n2.  **Execution (Adapted Gale-Shapley Algorithm)**: The $U$-proposing GSA is then executed using these preprocessed, effective preference lists.\n    - A queue of \"free\" agents from set $U$ is initialized.\n    - While the queue is not empty, a free agent $u$ is dequeued and proposes to the highest-ranked agent $v$ on their effective list to whom they have not yet proposed.\n    - The receiving agent $v$ assesses the proposal. If $v$ is currently unmatched, they tentatively accept. If $v$ is already matched with an agent $u'$, they compare $u$ and $u'$ based on their original, complete preference list. If $v$ prefers $u$ to $u'$, they break the engagement with $u'$ (who becomes free again) and tentatively accept the proposal from $u$. Otherwise, $v$ rejects $u$, and $u$ remains free to propose to the next agent on their list.\n    - An agent $u$ who exhausts their effective preference list (which could be empty from the start) will remain permanently unmatched.\n    - The algorithm terminates when the queue of free agents is empty. The set of tentative engagements at this point constitutes the final, stable matching. The GSA for SMPI guarantees that this process terminates and produces a $U$-optimal stable matching, meaning no agent in $U$ can do better in any other stable matching.\n3.  **Verification and Analysis**: After obtaining a matching $M$, a rigorous verification process is conducted to confirm its properties as required by the problem statement.\n    - **Stability Check**: The number of blocking pairs is counted. A pair $(u,v) \\notin M$ is a blocking pair if: (a) it is acceptable, (b) it is not forbidden, (c) $u$ prefers $v$ to their partner in $M$ (or to being unmatched), and (d) $v$ prefers $u$ to their partner in $M$ (or to being unmatched). This check is performed exhaustively over all pairs in $(U \\times V) \\setminus M$. For a correctly implemented GSA, this count must be $0$. The stability boolean $s$ is true if and only if this count is $0$.\n    - **Perfection and Unmatched Agents**: The matching is perfect if every agent in $U$ is matched. The boolean $p$ is set accordingly, and the number of unmatched agents in $U$, denoted by $u$, is calculated as $n - |M|$.\n    - **Final Output Assembly**: The results are compiled into the specified list format: $[s, p, b, u, M]$.\n\nThis principled design ensures correctness by first simplifying the problem constraints and then applying a proven algorithm, followed by a formal verification of the result against the initial, complex set of rules.\n\nTo implement this, preference rankings are pre-calculated for efficient lookups. For an agent $w$ and a potential partner $z$, $rank(w, z)$ is the position of $z$ on $w$'s preference list. A rank of infinity (e.g., a number larger than any possible rank) is assigned if $z$ is not on $w$'s list. This allows for simple numerical comparisons when an agent evaluates a new proposal against their current partner.\n\nFor the blocking pair check, for a given pair $(u, v) \\notin M$:\n- $u$ prefers $v$ if $rank(u, v)  rank(u, \\text{current partner of } u)$. If $u$ is unmatched, their current partner's rank is considered infinite, so any valid proposal is preferred.\n- A symmetric logic applies to $v$'s preference.\n- All four conditions for a blocking pair must be met simultaneously for the count to be incremented.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of Stable Marriage Problems with Incomplete Lists and Forbidden Pairs.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"n\": 3,\n            \"P_U\": {0: [0, 1, 2], 1: [1, 2, 0], 2: [2, 1, 0]},\n            \"P_V\": {0: [1, 0, 2], 1: [0, 1, 2], 2: [2, 1, 0]},\n            \"F\": [[0, 2]]\n        },\n        {\n            \"n\": 3,\n            \"P_U\": {0: [1, 0, 2], 1: [1, 2, 0], 2: [0, 2, 1]},\n            \"P_V\": {0: [2, 0, 1], 1: [0, 1, 2], 2: [1, 2, 0]},\n            \"F\": []\n        },\n        {\n            \"n\": 4,\n            \"P_U\": {0: [0, 1, 2, 3], 1: [1, 0, 2, 3], 2: [2, 3, 1, 0], 3: [3, 2, 1, 0]},\n            \"P_V\": {0: [1, 0, 2, 3], 1: [0, 1, 2, 3], 2: [2, 3, 1, 0], 3: [3, 2, 1, 0]},\n            \"F\": [[3, 0], [3, 1], [3, 2], [3, 3]]\n        },\n        {\n            \"n\": 4,\n            \"P_U\": {0: [0], 1: [0], 2: [1, 2, 3], 3: [3, 2, 1]},\n            \"P_V\": {0: [1, 0, 2, 3], 1: [2, 3, 1, 0], 2: [2, 3, 1, 0], 3: [3, 2, 1, 0]},\n            \"F\": [[1, 1], [1, 2], [1, 3]]\n        },\n        {\n            \"n\": 2,\n            \"P_U\": {0: [0], 1: [1, 0]},\n            \"P_V\": {0: [1, 0], 1: [1, 0]},\n            \"F\": [[0, 0]]\n        },\n    ]\n\n    def format_result(res):\n        \"\"\"Formats a single result list into the required string representation.\"\"\"\n        s, p, b, u, M = res\n        s_str = 'true' if s else 'false'\n        p_str = 'true' if p else 'false'\n        m_str_parts = [f\"[{pair[0]},{pair[1]}]\" for pair in M]\n        m_str = f\"[{','.join(m_str_parts)}]\"\n        return f\"[{s_str},{p_str},{b},{u},{m_str}]\"\n\n    def run_smp_case(n, P_U, P_V, F):\n        \"\"\"Processes a single test case of the stable marriage problem.\"\"\"\n        F_set = {tuple(p) for p in F}\n\n        # 1. Preprocessing: Create effective preference lists for U\n        cleaned_U_prefs = {u: [] for u in range(n)}\n        for u in range(n):\n            if u in P_U:\n                for v in P_U[u]:\n                    is_acceptable = v in P_V and u in P_V.get(v, [])\n                    is_not_forbidden = (u, v) not in F_set\n                    if is_acceptable and is_not_forbidden:\n                        cleaned_U_prefs[u].append(v)\n        \n        # Pre-calculate V's rankings for efficient lookups\n        v_rankings = np.full((n, n), n, dtype=int)\n        for v in range(n):\n            if v in P_V:\n                for rank, u in enumerate(P_V[v]):\n                    v_rankings[v, u] = rank\n\n        # 2. Execution: U-proposing Gale-Shapley Algorithm\n        free_men = list(range(n))\n        u_proposal_idx = np.zeros(n, dtype=int)\n        v_partners = np.full(n, -1, dtype=int)\n\n        while free_men:\n            u = free_men.pop(0)\n            u_prefs = cleaned_U_prefs[u]\n            \n            if u_proposal_idx[u]  len(u_prefs):\n                v = u_prefs[u_proposal_idx[u]]\n                u_proposal_idx[u] += 1\n                \n                current_partner = v_partners[v]\n                if current_partner == -1:\n                    v_partners[v] = u\n                else:\n                    if v_rankings[v, u]  v_rankings[v, current_partner]:\n                        v_partners[v] = u\n                        free_men.append(current_partner)\n                    else:\n                        free_men.append(u)\n            # If u has exhausted their list, they remain unmatched.\n        \n        # 3. Verification and Analysis\n        \n        # Construct final matching M and related stats\n        M_dict = {v_partners[v]: v for v in range(n) if v_partners[v] != -1}\n        M_list = sorted(list(M_dict.items()))\n        \n        u_unmatched_count = n - len(M_list)\n        p_is_perfect = (len(M_list) == n)\n\n        # Count blocking pairs\n        u_rankings = np.full((n, n), n, dtype=int)\n        for u in range(n):\n            if u in P_U:\n                for rank, v in enumerate(P_U[u]):\n                    u_rankings[u, v] = rank\n\n        b_blocking_pairs_count = 0\n        for u in range(n):\n            u_current_partner = M_dict.get(u, -1)\n            u_current_rank = n if u_current_partner == -1 else u_rankings[u, u_current_partner]\n\n            if u not in P_U: continue\n\n            for v in P_U[u]:\n                if u_current_partner == v: continue # Not an outside pair\n\n                # Check if (u,v) is a blocking pair\n                is_acceptable = v in P_V and u in P_V.get(v, [])\n                is_not_forbidden = (u,v) not in F_set\n                \n                if is_acceptable and is_not_forbidden:\n                    u_prefers = u_rankings[u, v]  u_current_rank\n                    \n                    if u_prefers:\n                        v_current_partner = v_partners[v]\n                        v_current_rank = n if v_current_partner == -1 else v_rankings[v, v_current_partner]\n                        v_prefers = v_rankings[v, u]  v_current_rank\n                        \n                        if v_prefers:\n                            b_blocking_pairs_count += 1\n        \n        s_is_stable = b_blocking_pairs_count == 0\n        \n        return [s_is_stable, p_is_perfect, b_blocking_pairs_count, u_unmatched_count, M_list]\n\n    results = [run_smp_case(**case) for case in test_cases]\n    results_as_strings = [format_result(r) for r in results]\n    \n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "3274062"}, {"introduction": "Beyond simply knowing that an algorithm works, a computer scientist must understand how well it performs. This final practice moves from implementation to analysis, focusing on the efficiency of the Gale-Shapley algorithm. Your task is to construct a \"pessimal\" input—a set of preferences that forces the algorithm to take the maximum number of steps—and derive the exact number of rejections in this worst-case scenario. This exercise provides critical insight into the algorithm's operational dynamics and its performance guarantees [@problem_id:3274039].", "problem": "Consider the Stable Marriage Problem with two disjoint sets $M=\\{m_{1},m_{2},\\dots,m_{n}\\}$ and $W=\\{w_{1},w_{2},\\dots,w_{n}\\}$, each of size $n$, and the Deferred Acceptance procedure due to Gale and Shapley (Gale–Shapley algorithm, GSA). The GSA operates as follows: while there exists a free man, he proposes to the most-preferred woman on his list to whom he has not yet proposed; each woman who receives one or more proposals keeps her most-preferred proposal (possibly her current provisional partner) and rejects all others; a provisional acceptance can be overturned by a later, more-preferred proposal; the algorithm terminates when all men are provisionally matched.\n\nDefine a “proposal-rejection step” to be any individual proposal that is rejected at the moment it is made (either because the woman prefers her current provisional partner to the new suitor, or because she receives multiple proposals and rejects all but her most-preferred).\n\nYour task:\n- Construct a family of preference profiles (one for each $n \\geq 2$) that provably causes the Gale–Shapley algorithm (men proposing) to perform the maximum possible number of proposal-rejection steps.\n- Starting only from the definitions above and first principles about the algorithm’s dynamics, derive the exact closed-form expression for this maximum number of proposal-rejection steps as a function of $n$.\n\nYour final answer must be a single, closed-form analytic expression in terms of $n$. No rounding is required and no units are involved.", "solution": "The problem requires us to construct a family of preference profiles that maximizes the number of proposal-rejection steps in the Gale-Shapley algorithm (GSA) and to derive the formula for this maximum number. A \"proposal-rejection step\" is defined as a proposal that is rejected at the moment it is made.\n\nLet the set of men be $M = \\{m_1, m_2, \\dots, m_n\\}$ and the set of women be $W = \\{w_1, w_2, \\dots, w_n\\}$. The GSA, with men proposing, can be analyzed by considering synchronous rounds, or \"days,\" where all men who are currently free make a proposal simultaneously.\n\nLet $F_k$ be the set of free men at the beginning of day $k$. Initially, $F_1 = M$, so $|F_1| = n$.\nOn day $k$, each man in $F_k$ proposes to the highest-ranked woman on his list to whom he has not yet proposed.\n\nA proposal-rejection step occurs under two conditions as defined:\n1.  A man $m$ proposes to a woman $w$ who is already provisionally engaged to a man $m'$, and $w$ prefers $m'$ to $m$.\n2.  A woman $w$ receives multiple proposals on the same day and rejects all but the one she prefers most.\n\nLet's analyze the number of rejections on day $k$. Let the set of men proposing on day $k$ be $F_k$. Let $W_k$ be the set of women who receive at least one proposal on day $k$. For each woman $w \\in W_k$, let $S_{k,w} \\subseteq F_k$ be the set of men who propose to her on this day. Woman $w$ considers all proposals from $S_{k,w}$ and her current provisional partner (if any). She keeps the best of these and becomes engaged to him.\n\nIf $w$ was free before day $k$, she accepts one man from $S_{k,w}$ and rejects the other $|S_{k,w}| - 1$ men.\nIf $w$ was engaged to $m'$ and receives proposals from $S_{k,w}$, she compares all men in $S_{k,w} \\cup \\{m'\\}$. If she chooses a new partner $m^* \\in S_{k,w}$, she rejects the $|S_{k,w}|-1$ other new suitors. If she keeps $m'$, she rejects all $|S_{k,w}|$ new suitors. In both cases, the proposals from any man in $S_{k,w}$ other than the \"winner\" (if any is from $S_{k,w}$) are rejected on the spot.\n\nThe total number of proposals made on day $k$ is $|F_k|$. Let $A_k$ be the set of men whose proposals are provisionally accepted on day $k$. A woman can accept at most one proposal. Thus, $|A_k| \\le |W_k|$. In the GSA, every woman who receives a proposal will accept one (possibly her current partner, which is not a new proposal), so $|A_k| = |W_k|$ (counting only new acceptances). The number of rejected proposals on day $k$ is $|F_k| - |A_k| = |F_k| - |W_k|$.\n\nThe set of free men for the next day is $F_{k+1}$. A man in $F_k$ who is not in $A_k$ is rejected and remains free. However, some men who were engaged before day $k$ might be \"jilted\" and become free. In the synchronous-proposal model, this means that at the end of day $k$, the set of free men is $F_{k+1} = F_k \\setminus A_k$. The number of rejections on day $k$ is therefore $|F_k| - |A_k| = |F_k| - |W_k|$.\nThe total number of rejections, $R$, is the sum of rejections over all days until no men are free:\n$$R = \\sum_{k=1}^{T} (\\text{rejections on day } k) = \\sum_{k=1}^{T} (|F_k| - |W_k|)$$\nwhere $T$ is the final day of the algorithm. We also have the relation $|F_{k+1}| = |F_k| - |W_k|$.\nThus, the number of rejections on day $k$ is exactly $|F_{k+1}|$.\nThe total number of rejections is $R = \\sum_{k=1}^{T} |F_{k+1}|$. The algorithm terminates when $|F_{T+1}| = 0$.\n\nTo maximize $R$, we need to maximize the sum of the sizes of the sets of free men over the course of the algorithm. This means the size of the set of free men should decrease as slowly as possible. At each step $k$, we must have $|W_k| \\ge 1$ as long as $F_k$ is non-empty. Therefore, the minimum decrease in the number of free men is $1$, which occurs when $|W_k|=1$. This means all free men on day $k$ propose to the same single woman.\n\nThis leads to the following maximal rejection scenario:\n-   **Day 1**: $|F_1|=n$ men are free. They all propose to one woman, say $w_1$. So $|W_1|=1$. She accepts one man, and rejects the other $n-1$. The number of free men becomes $|F_2| = n-1$. Number of rejections is $n-1$.\n-   **Day 2**: The $|F_2|=n-1$ free men all propose to a single available woman, say $w_2$. So $|W_2|=1$. She accepts one, rejects $n-2$. The number of free men becomes $|F_3| = n-2$. Number of rejections is $n-2$.\n-   **Day k**: The $|F_k|=n-k+1$ free men all propose to a single available woman, say $w_k$. $|W_k|=1$. She accepts one, rejects $n-k$. The number of free men becomes $|F_{k+1}| = n-k$. Number of rejections is $n-k$.\nThis process continues until only one man is left free.\n-   **Day n**: The last free man, $|F_n|=1$, proposes to the last available woman, $w_n$. He is accepted. Number of rejections is $0$. The algorithm terminates.\n\nThe total number of proposal-rejection steps is the sum of rejections from each day:\n$$R_{max} = (n-1) + (n-2) + \\dots + 1 + 0 = \\sum_{i=1}^{n-1} i$$\nThis is the sum of the first $n-1$ positive integers, which has a well-known closed-form expression:\n$$R_{max} = \\frac{(n-1)n}{2}$$\n\nNext, we construct a family of preference profiles that realizes this worst-case scenario. We need to ensure that on each day $k$, all $n-k+1$ free men propose to the same woman $w_k$.\n\n**Construction of Preference Profiles:**\n-   **Men's Preferences**: All men have the exact same preference list.\n    For each $m_i \\in M$, the preference list is $(w_1, w_2, \\dots, w_n)$.\n-   **Women's Preferences**: The women's preferences are designed to sequentially \"peel off\" the highest-indexed available man at each stage.\n    For each $w_j \\in W$, the preference list is $(m_n, m_{n-1}, \\dots, m_1)$.\n\n**Verification of the Construction:**\nLet's trace the GSA with these profiles.\n-   **Day 1**: All $n$ men are free. According to their common preference list, they all propose to $w_1$. Woman $w_1$ receives $n$ proposals from $\\{m_1, \\dots, m_n\\}$. Her preference list is $(m_n, m_{n-1}, \\dots, m_1)$, so she prefers $m_n$ over all others. She provisionally accepts $m_n$ and rejects the other $n-1$ men, $\\{m_1, \\dots, m_{n-1}\\}$.\n    - Rejections: $n-1$. Free men $F_2 = \\{m_1, \\dots, m_{n-1}\\}$.\n\n-   **Day 2**: The $n-1$ free men in $F_2$ proceed to their second choice, $w_2$. Woman $w_2$ receives $n-1$ proposals from $\\{m_1, \\dots, m_{n-1}\\}$. Her preference list is $(m_n, m_{n-1}, \\dots, m_1)$. Among her suitors, she prefers $m_{n-1}$. She accepts $m_{n-1}$ and rejects the other $n-2$ men, $\\{m_1, \\dots, m_{n-2}\\}$.\n    - Rejections: $n-2$. Free men $F_3 = \\{m_1, \\dots, m_{n-2}\\}$.\n\n-   **Day k**: The $n-k+1$ free men in $F_k = \\{m_1, \\dots, m_{n-k+1}\\}$ propose to their $k$-th choice, $w_k$. Woman $w_k$ receives proposals from these men. She prefers $m_{n-k+1}$ among this set. She accepts $m_{n-k+1}$ and rejects the other $n-k$ men.\n    - Rejections: $n-k$. Free men $F_{k+1} = \\{m_1, \\dots, m_{n-k}\\}$.\n\n-   **Day n-1**: The two free men $\\{m_1, m_2\\}$ propose to $w_{n-1}$. She accepts $m_2$ and rejects $m_1$.\n    - Rejections: $1$. Free men $F_n = \\{m_1\\}$.\n\n-   **Day n**: The last free man, $m_1$, proposes to his last choice, $w_n$. She is free and has no other proposals, so she accepts him.\n    - Rejections: $0$. All men are now matched.\n\nThe total number of rejected proposals is the sum $\\sum_{k=1}^{n-1} (n-k) = (n-1) + (n-2) + \\dots + 1 = \\frac{n(n-1)}{2}$.\nThis confirms that the constructed profiles generate the maximum possible number of proposal-rejection steps, as derived from first principles.\n\nThe final derived expression for the maximum number of proposal-rejection steps is $\\frac{n(n-1)}{2}$.", "answer": "$$\\boxed{\\frac{n(n-1)}{2}}$$", "id": "3274039"}]}