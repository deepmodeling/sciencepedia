{"hands_on_practices": [{"introduction": "To truly master an algorithm, it's essential to move beyond the high-level description and see its mechanics up close. This exercise invites you to do just that by manually tracing the foundational Floyd-Warshall algorithm. By computing the distance matrix updates for the first few iterations, you will build a concrete intuition for how the algorithm systematically improves path estimates by considering each vertex as a potential intermediate point in all other paths [@problem_id:1504965]. This step-by-step process demystifies the dynamic programming core of the method.", "problem": "Consider a weighted directed graph with 4 vertices, labeled 1, 2, 3, and 4. The costs of the direct paths between any two vertices are given by an initial distance matrix $D^{(0)}$. In this matrix, the element $D^{(0)}_{ij}$ represents the weight of the directed edge from vertex $i$ to vertex $j$. If no direct edge exists from $i$ to $j$, the weight is considered infinite ($\\infty$). The self-distance $D^{(0)}_{ii}$ is 0 for all vertices.\n\nThe initial distance matrix $D^{(0)}$ is given as:\n$$ D^{(0)} = \\begin{pmatrix} 0  4  \\infty  7 \\\\ \\infty  0  1  \\infty \\\\ 6  \\infty  0  2 \\\\ 3  -2  \\infty  0 \\end{pmatrix} $$\n\nThe Floyd-Warshall algorithm computes the all-pairs shortest paths by iteratively updating this matrix. In the $k$-th iteration (for $k=1, 2, \\dots, 4$), the algorithm considers paths that use vertex $k$ as an intermediate vertex to potentially find a shorter path between any two vertices $i$ and $j$.\n\nStarting with the given matrix $D^{(0)}$, perform the first two iterations of the Floyd-Warshall algorithm to compute the matrices $D^{(1)}$ (using $k=1$) and $D^{(2)}$ (using $k=2$). Your task is to determine the final state of the distance matrix after the second iteration, $D^{(2)}$.", "solution": "We use the Floyd-Warshall update rule: for each iteration $k$ and for all $i,j$,\n$$\nD^{(k)}_{ij}=\\min\\left(D^{(k-1)}_{ij},\\,D^{(k-1)}_{ik}+D^{(k-1)}_{kj}\\right).\n$$\nGiven\n$$\nD^{(0)}=\\begin{pmatrix}\n0  4  \\infty  7\\\\\n\\infty  0  1  \\infty\\\\\n6  \\infty  0  2\\\\\n3  -2  \\infty  0\n\\end{pmatrix},\n$$\nwe perform the first iteration with $k=1$, using $D^{(1)}_{ij}=\\min\\left(D^{(0)}_{ij},\\,D^{(0)}_{i1}+D^{(0)}_{1j}\\right)$.\n\nFor $i=1$:\n- $j=1$: $\\min(0,\\,0+0)=0$.\n- $j=2$: $\\min(4,\\,0+4)=4$.\n- $j=3$: $\\min(\\infty,\\,0+\\infty)=\\infty$.\n- $j=4$: $\\min(7,\\,0+7)=7$.\n\nFor $i=2$ (since $D^{(0)}_{21}=\\infty$, all via $1$ are $\\infty$):\n- $j=1$: $\\min(\\infty,\\,\\infty)=\\infty$.\n- $j=2$: $\\min(0,\\,\\infty)=0$.\n- $j=3$: $\\min(1,\\,\\infty)=1$.\n- $j=4$: $\\min(\\infty,\\,\\infty)=\\infty$.\n\nFor $i=3$ (with $D^{(0)}_{31}=6$):\n- $j=1$: $\\min(6,\\,6+0)=6$.\n- $j=2$: $\\min(\\infty,\\,6+4)=10$.\n- $j=3$: $\\min(0,\\,6+\\infty)=0$.\n- $j=4$: $\\min(2,\\,6+7)=2$.\n\nFor $i=4$ (with $D^{(0)}_{41}=3$):\n- $j=1$: $\\min(3,\\,3+0)=3$.\n- $j=2$: $\\min(-2,\\,3+4)=-2$.\n- $j=3$: $\\min(\\infty,\\,3+\\infty)=\\infty$.\n- $j=4$: $\\min(0,\\,3+7)=0$.\n\nThus\n$$\nD^{(1)}=\\begin{pmatrix}\n0  4  \\infty  7\\\\\n\\infty  0  1  \\infty\\\\\n6  10  0  2\\\\\n3  -2  \\infty  0\n\\end{pmatrix}.\n$$\n\nNext, perform the second iteration with $k=2$, using $D^{(2)}_{ij}=\\min\\left(D^{(1)}_{ij},\\,D^{(1)}_{i2}+D^{(1)}_{2j}\\right)$.\n\nFor $i=1$ (with $D^{(1)}_{12}=4$):\n- $j=1$: $\\min(0,\\,4+\\infty)=0$.\n- $j=2$: $\\min(4,\\,4+0)=4$.\n- $j=3$: $\\min(\\infty,\\,4+1)=5$.\n- $j=4$: $\\min(7,\\,4+\\infty)=7$.\n\nFor $i=2$ (with $D^{(1)}_{22}=0$):\n- $j=1$: $\\min(\\infty,\\,0+\\infty)=\\infty$.\n- $j=2$: $\\min(0,\\,0+0)=0$.\n- $j=3$: $\\min(1,\\,0+1)=1$.\n- $j=4$: $\\min(\\infty,\\,0+\\infty)=\\infty$.\n\nFor $i=3$ (with $D^{(1)}_{32}=10$):\n- $j=1$: $\\min(6,\\,10+\\infty)=6$.\n- $j=2$: $\\min(10,\\,10+0)=10$.\n- $j=3$: $\\min(0,\\,10+1)=0$.\n- $j=4$: $\\min(2,\\,10+\\infty)=2$.\n\nFor $i=4$ (with $D^{(1)}_{42}=-2$):\n- $j=1$: $\\min(3,\\, -2+\\infty)=3$.\n- $j=2$: $\\min(-2,\\, -2+0)=-2$.\n- $j=3$: $\\min(\\infty,\\, -2+1)=-1$.\n- $j=4$: $\\min(0,\\, -2+\\infty)=0$.\n\nTherefore, the matrix after the second iteration is\n$$\nD^{(2)}=\\begin{pmatrix}\n0  4  5  7\\\\\n\\infty  0  1  \\infty\\\\\n6  10  0  2\\\\\n3  -2  -1  0\n\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0  4  5  7 \\\\ \\infty  0  1  \\infty \\\\ 6  10  0  2 \\\\ 3  -2  -1  0\\end{pmatrix}}$$", "id": "1504965"}, {"introduction": "With a grasp of how an all-pairs shortest path (APSP) algorithm works, we can now apply it to solve meaningful, real-world problems. This practice places you in the role of a network analyst seeking to identify the most critical link in a system, a concept known as edge vitality [@problem_id:3206137]. You will use an APSP solver as a subroutine to measure how the removal of each edge impacts the overall network efficiency, illustrating how these algorithms are crucial tools in risk assessment and infrastructure planning.", "problem": "You are given a collection of networks, each represented as a finite, simple, undirected, weighted graph with nonnegative edge weights. For a graph with $n$ vertices, vertices are labeled $0,1,\\dots,n-1$. The quantity of interest is the sum of All-Pairs Shortest Paths (APSP), defined as follows. Let $\\operatorname{dist}_G(i,j)$ denote the shortest path distance between vertices $i$ and $j$ in graph $G$. If there is no path between $i$ and $j$, define $\\operatorname{dist}_G(i,j)=+\\infty$. Define the APSP sum as\n$$\nS(G) \\;=\\; \\sum_{0 \\le i  j  n} \\operatorname{dist}_G(i,j).\n$$\nFor an edge $e$ in $G$, let $G \\setminus e$ denote the graph obtained by removing $e$ (while leaving all other edges unchanged). Define the vitality of $e$ with respect to the APSP sum as\n$$\nV(e) \\;=\\; S(G \\setminus e) \\;-\\; S(G).\n$$\nYour task is, for each provided test graph, to determine the index of the \"most vital\" edge, i.e., the edge $e^\\star$ that maximizes $V(e)$ over all edges in the graph. In the event of a tie (multiple edges achieving the same maximal vitality), select the edge with the smallest index.\n\nEdges are given as triples $(u,v,w)$, where $u$ and $v$ are vertex indices and $w$ is a nonnegative real weight. The graphs are guaranteed to be connected initially (i.e., before any edge removal), but removal of some edges may disconnect the graph, in which case the corresponding $\\operatorname{dist}_{G\\setminus e}(i,j)$ can be $+\\infty$, and thus $S(G\\setminus e)$, and $V(e)$, can be $+\\infty$. All computations are purely mathematical and unitless.\n\nUse any correct algorithmic method to determine $S(G)$ and $S(G\\setminus e)$, consistent with the standard definitions of shortest paths in graphs with nonnegative weights. Define edge indices by their position in the given list, starting at $0$.\n\nTest Suite:\n- Test Case $1$: $n=3$, edges (in index order)\n  - Edge $0$: $(0,1,1)$\n  - Edge $1$: $(1,2,1)$\n  - Edge $2$: $(0,2,2)$\n- Test Case $2$: $n=4$, edges (in index order)\n  - Edge $0$: $(0,1,1)$\n  - Edge $1$: $(1,2,1)$\n  - Edge $2$: $(2,3,1)$\n- Test Case $3$: $n=4$, edges (in index order)\n  - Edge $0$: $(0,1,1)$\n  - Edge $1$: $(1,2,1)$\n  - Edge $2$: $(0,2,2)$\n  - Edge $3$: $(1,3,1)$\n  - Edge $4$: $(2,3,5)$\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each entry should be the integer index of the most vital edge for the corresponding test case in the order listed above. For example, the output must look like $[r_1,r_2,r_3]$, where $r_k$ is the selected edge index for test case $k$.", "solution": "The user-provided problem is valid as it is scientifically grounded in the field of graph theory, well-posed with a unique and meaningful solution, and expressed in objective, formal language. It presents a standard algorithmic challenge related to network sensitivity analysis.\n\nThe problem requires finding the \"most vital\" edge in a weighted, undirected graph. The vitality of an edge $e$, denoted $V(e)$, is defined as the increase in the sum of all-pairs shortest paths (APSP) upon the removal of $e$.\nLet $G=(V,E)$ be a graph with $n$ vertices labeled $0, 1, \\dots, n-1$. The shortest path distance between vertices $i$ and $j$ is $\\operatorname{dist}_G(i,j)$. The APSP sum is $S(G) = \\sum_{0 \\le i  j  n} \\operatorname{dist}_G(i,j)$. The vitality of an edge $e \\in E$ is $V(e) = S(G \\setminus e) - S(G)$, where $G \\setminus e$ is the graph $G$ with edge $e$ removed. We are asked to find the index of the edge $e^\\star$ that maximizes $V(e)$, with ties broken by choosing the smallest edge index.\n\nThe core of the problem is the computation of the APSP sum. As the graphs have nonnegative edge weights, the Floyd-Warshall algorithm is a suitable method for calculating the all-pairs shortest paths. For a graph with $n$ vertices, this algorithm has a time complexity of $O(n^3)$.\n\nThe overall algorithm proceeds as follows:\n1.  Represent the graph using an adjacency matrix, where entry $(i,j)$ stores the weight of the edge between vertices $i$ and $j$. If no direct edge exists, the initial distance is $+\\infty$. The distance from any vertex to itself is $0$.\n2.  Calculate the all-pairs shortest path distance matrix for the original graph $G$ using the Floyd-Warshall algorithm. Let this matrix be $D_G$.\n3.  From $D_G$, compute the initial APSP sum, $S(G) = \\sum_{0 \\le i  j  n} D_G[i,j]$.\n4.  Iterate through each edge $e_k$ in the graph, where $k$ is the edge index. For each edge:\n    a.  Construct the graph $G_k = G \\setminus e_k$ by conceptually removing the edge $e_k$. This is done by setting the corresponding weight in the adjacency matrix to $+\\infty$.\n    b.  Calculate the all-pairs shortest path distance matrix for $G_k$, let it be $D_{G_k}$, by running the Floyd-Warshall algorithm on the modified adjacency matrix.\n    c.  Compute the new APSP sum, $S(G_k) = \\sum_{0 \\le i  j  n} D_{G_k}[i,j]$. If $G_k$ becomes disconnected, some distances will be $+\\infty$, and thus $S(G_k)$ will be $+\\infty$.\n    d.  Calculate the vitality of the edge: $V(e_k) = S(G_k) - S(G)$.\n5.  Maintain a record of the maximum vitality found and the index of the corresponding edge. The tie-breaking rule (smallest index) is naturally handled by updating the maximum only when a strictly greater vitality is found.\n\nLet's apply this procedure to the test cases.\n\n**Test Case 1**: A graph with $n=3$ vertices and edges $e_0=(0,1,1)$, $e_1=(1,2,1)$, and $e_2=(0,2,2)$.\n- The original graph $G$ is a triangle. The shortest path distances are $\\operatorname{dist}_G(0,1)=1$, $\\operatorname{dist}_G(1,2)=1$, and $\\operatorname{dist}_G(0,2)=\\min(2, 1+1)=2$.\n- The APSP sum is $S(G) = 1 + 1 + 2 = 4$.\n- Removing $e_0=(0,1,1)$: The path from $0$ to $1$ is rerouted through $0-2-1$, with distance $2+1=3$. The other distances remain the same. $S(G \\setminus e_0) = 3+1+2 = 6$. Thus, $V(e_0)=6-4=2$.\n- Removing $e_1=(1,2,1)$: The path from $1$ to $2$ is rerouted through $1-0-2$, with distance $1+2=3$. $S(G \\setminus e_1) = 1+3+2 = 6$. Thus, $V(e_1)=6-4=2$.\n- Removing $e_2=(0,2,2)$: The shortest path from $0$ to $2$ was already length $2$ (via $0-1-2$). So, $\\operatorname{dist}_{G\\setminus e_2}(0,2)=2$. Distances do not change. $S(G \\setminus e_2) = 4$. Thus, $V(e_2)=4-4=0$.\n- The maximum vitality is $2$, achieved by edges $e_0$ and $e_1$. The tie-breaking rule selects the one with the smallest index, which is $0$.\n\n**Test Case 2**: A graph with $n=4$ vertices and edges $e_0=(0,1,1)$, $e_1=(1,2,1)$, and $e_2=(2,3,1)$. This is a path graph $0-1-2-3$.\n- The initial APSP sum is $S(G) = \\operatorname{dist}(0,1)+\\operatorname{dist}(0,2)+\\operatorname{dist}(0,3)+\\operatorname{dist}(1,2)+\\operatorname{dist}(1,3)+\\operatorname{dist}(2,3) = 1+2+3+1+2+1=10$.\n- Each edge in this path graph is a bridge. Removing any of them will disconnect the graph.\n- Removing $e_0=(0,1,1)$ disconnects vertex $0$. Distances $\\operatorname{dist}(0,1), \\operatorname{dist}(0,2), \\operatorname{dist}(0,3)$ become $+\\infty$. Thus $S(G \\setminus e_0) = +\\infty$, and $V(e_0)=+\\infty$.\n- Similarly, removing $e_1=(1,2,1)$ or $e_2=(2,3,1)$ also disconnects the graph, leading to $V(e_1)=+\\infty$ and $V(e_2)=+\\infty$.\n- All three edges have a vitality of $+\\infty$. The tie-breaking rule selects the one with the smallest index, which is $0$.\n\n**Test Case 3**: A graph with $n=4$ vertices and 5 edges.\n- Original graph $G$: After running Floyd-Warshall, we find the distance matrix and compute $S(G) = 9$.\n- Removing $e_0=(0,1,1)$: Several paths are rerouted. For example, the shortest path for $(0,1)$ becomes $0-2-1$ (length $3$), and for $(0,3)$ becomes $0-2-1-3$ (length $4$). The total change in the APSP sum is $4$, so $V(e_0)=4$.\n- Removing $e_1=(1,2,1)$: The shortest path for $(1,2)$ becomes $1-0-2$ (length $3$), and for $(2,3)$ becomes $2-0-1-3$ (length $4$). The total change in the APSP sum is $4$, so $V(e_1)=4$.\n- Removing $e_2=(0,2,2)$: The edge $(0,2)$ has weight $2$, but there is an alternate path $0-1-2$ of length $1+1=2$. Removing this edge does not change any shortest path distances. $V(e_2)=0$.\n- Removing $e_3=(1,3,1)$: This is the most critical edge. In the original graph, the shortest paths involving this edge include $\\operatorname{dist}_G(1,3)=1$, $\\operatorname{dist}_G(2,3)=2$ (via $2-1-3$), and $\\operatorname{dist}_G(0,3)=2$ (via $0-1-3$). After removing $e_3$, these paths are rerouted. The new distance $\\operatorname{dist}_{G\\setminus e_3}(1,3)$ becomes $6$ (via $1-2-3$), increasing by $5$. The new distance $\\operatorname{dist}_{G\\setminus e_3}(2,3)$ becomes $5$ (the direct edge), increasing by $3$. The new distance $\\operatorname{dist}_{G\\setminus e_3}(0,3)$ becomes $7$ (via $0-1-2-3$), increasing by $5$. A full re-computation considering all affected pairs confirms the total vitality is $V(e_3)=13$.\n- Removing $e_4=(2,3,5)$: The shortest path between $2$ and $3$ in $G$ is $2-1-3$ with length $2$. The edge $(2,3,5)$ is not on any shortest path. Removing it has no effect on APSP sum. $V(e_4)=0$.\n- The maximum vitality is $13$, which corresponds to edge index $3$.\n\nThe final results are $[0, 0, 3]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef floyd_warshall(n, edges):\n    \"\"\"\n    Computes all-pairs shortest paths using the Floyd-Warshall algorithm.\n\n    Args:\n        n (int): The number of vertices in the graph.\n        edges (list): A list of tuples (u, v, w) representing edges.\n\n    Returns:\n        numpy.ndarray: A 2D array representing the distance matrix.\n    \"\"\"\n    dist = np.full((n, n), np.inf, dtype=np.float64)\n    np.fill_diagonal(dist, 0)\n\n    for u, v, w in edges:\n        dist[u, v] = min(dist[u, v], w)\n        dist[v, u] = min(dist[v, u], w)\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i, j] = min(dist[i, j], dist[i, k] + dist[k, j])\n    \n    return dist\n\ndef calculate_apsp_sum(dist_matrix):\n    \"\"\"\n    Calculates the sum of all-pairs shortest paths from a distance matrix.\n    The sum is over unique pairs (i, j) where i  j.\n\n    Args:\n        dist_matrix (numpy.ndarray): The all-pairs shortest path distance matrix.\n\n    Returns:\n        float: The sum of shortest path distances. Returns np.inf if any path is infinite.\n    \"\"\"\n    n = dist_matrix.shape[0]\n    total_sum = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += dist_matrix[i, j]\n    return total_sum\n\ndef find_most_vital_edge(n, edges):\n    \"\"\"\n    Finds the index of the most vital edge in a graph.\n\n    Args:\n        n (int): The number of vertices.\n        edges (list): A list of edge tuples (u, v, w).\n\n    Returns:\n        int: The index of the most vital edge.\n    \"\"\"\n    # Calculate APSP sum for the original graph\n    dist_G = floyd_warshall(n, edges)\n    S_G = calculate_apsp_sum(dist_G)\n\n    max_vitality = -1.0\n    best_edge_index = -1\n\n    for k in range(len(edges)):\n        # Create graph G \\ e_k by excluding the k-th edge\n        edges_k = [edge for i, edge in enumerate(edges) if i != k]\n        \n        # Calculate APSP sum for the modified graph\n        dist_Gk = floyd_warshall(n, edges_k)\n        S_Gk = calculate_apsp_sum(dist_Gk)\n        \n        vitality = S_Gk - S_G\n\n        if vitality  max_vitality:\n            max_vitality = vitality\n            best_edge_index = k\n            \n    return best_edge_index\n\ndef solve():\n    \"\"\"\n    Defines test cases and solves them, printing the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 3,\n            \"edges\": [(0,1,1), (1,2,1), (0,2,2)]\n        },\n        {\n            \"n\": 4,\n            \"edges\": [(0,1,1), (1,2,1), (2,3,1)]\n        },\n        {\n            \"n\": 4,\n            \"edges\": [(0,1,1), (1,2,1), (0,2,2), (1,3,1), (2,3,5)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        edges = case[\"edges\"]\n        result = find_most_vital_edge(n, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3206137"}, {"introduction": "The classic shortest path problem assumes the only objective is to minimize distance, but real-world problems often come with extra constraints. This advanced practice explores such a scenario, where you must find the shortest path while also managing a budget of \"toll road\" uses [@problem_id:3206273]. The key is not a new algorithm, but a powerful modeling technique called state-space augmentation. You will learn to redefine the problem by creating a new, larger graph where each vertex represents not just a location, but a location *and* the number of tolls used, transforming a constrained problem into a standard one.", "problem": "Consider a directed, weighted graph $G = (V,E)$ where $V = \\{0,1,\\dots,n-1\\}$ for some integer $n \\geq 1$, and $E \\subseteq V \\times V$ is a set of directed edges. Each directed edge $(u,v) \\in E$ has an associated nonnegative real weight $w(u,v) \\geq 0$ and a binary attribute $\\tau(u,v) \\in \\{0,1\\}$ indicating whether the edge is a toll segment ($\\tau(u,v) = 1$) or a non-toll segment ($\\tau(u,v) = 0$). For any ordered pair of vertices $(u,v) \\in V \\times V$, a path $\\pi$ from $u$ to $v$ is a sequence of vertices $(u = x_0, x_1, \\dots, x_m = v)$ such that $(x_i, x_{i+1}) \\in E$ for all integers $i$ satisfying $0 \\leq i  m$. The length of path $\\pi$ is defined as the sum of weights $\\sum_{i=0}^{m-1} w(x_i, x_{i+1})$, and the toll count of path $\\pi$ is defined as $\\sum_{i=0}^{m-1} \\tau(x_i, x_{i+1})$. For a given nonnegative integer $k$, define the constrained all-pairs shortest-path distance $d_k(u,v)$ to be the infimum of the lengths of all paths from $u$ to $v$ whose toll count is at most $k$. If no such path exists, define $d_k(u,v) = +\\infty$.\n\nYour task is to write a complete, runnable program that computes, for each provided test case, the matrix of constrained all-pairs shortest-path distances $D_k \\in \\mathbb{R}^{n \\times n}$ where the entry at row $i$ and column $j$ equals $d_k(i,j)$. The computation must be derived from fundamental principles, starting from the definition of paths and the principle of optimality, and must handle directed graphs, nonnegative edge weights, and the toll constraint. In the output, represent $+\\infty$ using the floating-point infinity of the programming language's standard numerical type.\n\nUse the following test suite, where each test case specifies $(n, E, k)$ with explicit edges. Each edge is given as a quadruple $(u,v,w,\\tau)$, where $u$ and $v$ are integers in $\\{0,1,\\dots,n-1\\}$, $w$ is a nonnegative real weight, and $\\tau \\in \\{0,1\\}$ indicates whether the edge is a toll segment. All numbers that appear are exact and unitless.\n\nTest case $1$ (general case, mixed tolls, moderate constraint):\n- $n = 4$\n- $E = \\{(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)\\}$\n- $k = 1$\n\nTest case $2$ (boundary case, no tolls allowed):\n- $n = 4$\n- $E = \\{(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)\\}$\n- $k = 0$\n\nTest case $3$ (all edges are toll segments, limited toll budget, directed reachability edge cases):\n- $n = 3$\n- $E = \\{(0,1,5,1), (1,2,5,1), (0,2,20,1)\\}$\n- $k = 1$\n\nTest case $4$ (directed cycles with mixed tolls, larger constraint):\n- $n = 5$\n- $E = \\{(0,1,1,0), (1,2,1,1), (2,4,1,0), (0,3,10,0), (3,2,1,1), (1,3,2,0), (3,4,2,0), (4,1,1,1), (4,0,5,0)\\}$\n- $k = 3$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the $n \\times n$ distance matrix $D_k$ for the corresponding test case represented as a list of lists of floating-point numbers, with $+\\infty$ represented by the language’s floating-point infinity. For example, the output format should be of the form $[M_1,M_2,M_3,M_4]$, where each $M_t$ is the matrix for test case $t$.", "solution": "The user-provided problem is a well-defined instance of the constrained all-pairs shortest path problem on a directed graph. The validation process, conducted according to the specified rules, confirms that the problem is scientifically grounded, self-contained, and objective. All parameters are clearly defined, and the premises are consistent with established principles of graph theory and algorithms. Therefore, the problem is deemed valid and a formal solution is warranted.\n\nThe core task is to compute the constrained all-pairs shortest-path distance $d_k(u,v)$ for a directed graph $G=(V,E)$ with $V=\\{0,1,\\dots,n-1\\}$. This distance is the infimum of lengths of all paths from vertex $u$ to vertex $v$ having a total toll count of at most $k$. The toll count of a path is the sum of binary toll attributes $\\tau$ over its edges, and the length is the sum of non-negative weights $w$.\n\nThis problem can be solved by transforming it into a standard shortest path problem on an augmented graph, a technique directly rooted in the principle of optimality. The state of a path must not only encode the current vertex but also the resources consumed—in this case, the number of toll segments used.\n\nLet us define an augmented graph $G'=(V', E')$.\nThe set of vertices $V'$ is the Cartesian product of the original vertex set $V$ and the set of possible toll counts $\\{0, 1, \\dots, k\\}$.\n$$V' = V \\times \\{0, 1, \\dots, k\\}$$\nA vertex $(v,t) \\in V'$ represents the state of reaching vertex $v \\in V$ having traversed a path with a total toll count of exactly $t$. The size of $V'$ is $n \\cdot (k+1)$.\n\nThe set of edges $E'$ is constructed from the edges in $E$. For each edge $(u,v) \\in E$ with weight $w(u,v)$ and toll attribute $\\tau(u,v)$, we define a set of corresponding edges in $G'$. An edge from $u$ to $v$ in $G$ allows a transition from a state at $u$ to a state at $v$. Specifically, if we are at vertex $u$ with $t$ tolls used, traversing the edge $(u,v)$ leads us to vertex $v$ with a new toll count of $t + \\tau(u,v)$. This transition is valid only if the new toll count does not exceed the budget $k$.\nFormally, for each edge $(u,v) \\in E$ and for each integer $t \\in \\{0, 1, \\dots, k\\}$:\nIf $t + \\tau(u,v) \\le k$, we add a directed edge in $E'$ from vertex $(u,t)$ to vertex $(v, t + \\tau(u,v))$ with weight $w(u,v)$.\n$$E' = \\{ ((u,t), (v, t+\\tau(u,v))) \\mid (u,v) \\in E, t \\in \\{0,\\dots,k\\}, t+\\tau(u,v) \\le k \\}$$\nThe weight of the edge $((u,t), (v, t+\\tau(u,v)))$ in $G'$ is defined to be $w(u,v)$.\n\nSince all original edge weights $w(u,v)$ are non-negative, all edge weights in $G'$ are also non-negative. This is a crucial property, as it allows for the application of efficient shortest path algorithms like Dijkstra's. The graph $G'$ is a directed graph, and it can contain cycles if the original graph $G$ contains cycles. However, any cycle in $G'$ formed by edges corresponding to toll edges from $G$ would involve an increase in the toll-count component of the vertex, while a cycle of non-toll edges would leave the toll-count component unchanged. Thus, the state space exploration is guaranteed to terminate.\n\nThe problem asks for $d_k(u,v)$, the shortest path from $u$ to $v$ using *at most* $k$ tolls. A path from $u$ in $G$ begins with $0$ tolls used. In the augmented graph $G'$, this corresponds to starting at vertex $(u,0)$. A path to $v$ in $G$ with at most $k$ tolls corresponds to a path in $G'$ from $(u,0)$ to any of the vertices $(v,t')$ where $t' \\in \\{0, 1, \\dots, k\\}$. The length of the shortest such path is the minimum of the distances from $(u,0)$ to each of these possible destination vertices.\nLet $\\text{dist}_{G'}((a, t_a), (b, t_b))$ be the shortest path distance in $G'$. Then, the constrained distance $d_k(u,v)$ is given by:\n$$d_k(u,v) = \\min_{0 \\le t' \\le k} \\left\\{ \\text{dist}_{G'}((u,0), (v,t')) \\right\\}$$\nTo compute the all-pairs matrix $D_k$, we must find these values for all pairs $(u,v) \\in V \\times V$. This can be achieved by running a single-source shortest path (SSSP) algorithm on $G'$ from each source vertex of the form $(u,0)$ for all $u \\in V$.\n\nThe overall algorithmic procedure is as follows:\n$1$. Initialize an $n \\times n$ result matrix $D_k$ with $+\\infty$ for all entries, and $0$ on the diagonal.\n$2$. For each starting vertex $s \\in \\{0, 1, \\dots, n-1\\}$:\n    a. We need to find the shortest path distances from $(s,0)$ to all other vertices $(v,t)$ in $G'$. We can use Dijkstra's algorithm for this.\n    b. Initialize a distance array $\\delta_s$ of size $n \\times (k+1)$ to $+\\infty$, representing the shortest known distances from $(s,0)$. Set $\\delta_s(s,0) = 0$.\n    c. Use a priority queue for Dijkstra's algorithm, storing tuples of (distance, vertex, tolls). Initially, it contains $(0, s, 0)$.\n    d. While the priority queue is not empty, extract the state $(d, u_{curr}, t_{curr})$ with the minimum distance $d$. If $d  \\delta_s(u_{curr}, t_{curr})$, this is a stale entry, so skip it.\n    e. For each outgoing edge $(u_{curr}, v_{next}) \\in E$ with weight $w$ and toll $\\tau$:\n        i. Calculate the new toll count $t_{next} = t_{curr} + \\tau$.\n        ii. If $t_{next} \\le k$:\n            - If $\\delta_s(u_{curr}, t_{curr}) + w  \\delta_s(v_{next}, t_{next})$, update the distance: $\\delta_s(v_{next}, t_{next}) = \\delta_s(u_{curr}, t_{curr}) + w$.\n            - Add $( \\delta_s(v_{next}, t_{next}), v_{next}, t_{next} )$ to the priority queue.\n    f. After Dijkstra's algorithm terminates, the array $\\delta_s$ contains the shortest path distances from $(s,0)$ to all reachable $(v,t)$ states.\n    g. For each destination vertex $v \\in \\{0, 1, \\dots, n-1\\}$, compute the entry for the final result matrix:\n       $$(D_k)_{sv} = \\min_{0 \\le t' \\le k} \\delta_s(v, t')$$\n$3$. After iterating through all starting vertices $s \\in V$, the matrix $D_k$ will be completely populated with the constrained all-pairs shortest-path distances.\n\nThis method is a direct application of the principle of optimality on the expanded state space and correctly solves the given problem.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    \n    # Test case 1 (general case, mixed tolls, moderate constraint):\n    # n = 4, k = 1\n    # E = {(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)}\n    test_case_1 = {\n        \"n\": 4,\n        \"k\": 1,\n        \"edges\": [(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)]\n    }\n\n    # Test case 2 (boundary case, no tolls allowed):\n    # n = 4, k = 0\n    # E = {(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)}\n    test_case_2 = {\n        \"n\": 4,\n        \"k\": 0,\n        \"edges\": [(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)]\n    }\n\n    # Test case 3 (all edges are toll segments, limited toll budget, directed reachability edge cases):\n    # n = 3, k = 1\n    # E = {(0,1,5,1), (1,2,5,1), (0,2,20,1)}\n    test_case_3 = {\n        \"n\": 3,\n        \"k\": 1,\n        \"edges\": [(0,1,5,1), (1,2,5,1), (0,2,20,1)]\n    }\n\n    # Test case 4 (directed cycles with mixed tolls, larger constraint):\n    # n = 5, k = 3\n    # E = {(0,1,1,0), (1,2,1,1), (2,4,1,0), (0,3,10,0), (3,2,1,1), (1,3,2,0), (3,4,2,0), (4,1,1,1), (4,0,5,0)}\n    test_case_4 = {\n        \"n\": 5,\n        \"k\": 3,\n        \"edges\": [(0,1,1,0), (1,2,1,1), (2,4,1,0), (0,3,10,0), (3,2,1,1), (1,3,2,0), (3,4,2,0), (4,1,1,1), (4,0,5,0)]\n    }\n\n    test_cases = [test_case_1, test_case_2, test_case_3, test_case_4]\n    results = []\n\n    for case in test_cases:\n        n = case[\"n\"]\n        k = case[\"k\"]\n        edges = case[\"edges\"]\n        \n        # Adjacency list representation of the graph\n        adj = [[] for _ in range(n)]\n        for u, v, w, tau in edges:\n            adj[u].append((v, w, tau))\n\n        # The final n x n distance matrix for this test case\n        result_matrix = np.full((n, n), np.inf)\n\n        for start_node in range(n):\n            # dists[v][t]: shortest distance to vertex v using exactly t tolls\n            dists = np.full((n, k + 1), np.inf)\n            \n            # Priority queue for Dijkstra's algorithm\n            # (distance, vertex, tolls_used)\n            pq = [(0, start_node, 0)]\n            dists[start_node][0] = 0\n\n            while pq:\n                d, u, t = heapq.heappop(pq)\n\n                # If we found a shorter path already, skip\n                if d  dists[u][t]:\n                    continue\n\n                # Explore neighbors in the original graph\n                for v, w, tau in adj[u]:\n                    new_t = t + tau\n                    if new_t = k:\n                        if dists[u][t] + w  dists[v][new_t]:\n                            dists[v][new_t] = dists[u][t] + w\n                            heapq.heappush(pq, (dists[v][new_t], v, new_t))\n            \n            # For the current start_node, find the shortest path to all other nodes\n            # by taking the minimum over all possible toll counts up to k.\n            for end_node in range(n):\n                min_dist = np.min(dists[end_node, :])\n                result_matrix[start_node, end_node] = min_dist\n\n        results.append(result_matrix.tolist())\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists containing np.inf is 'inf'\n    # which is the standard representation for float('inf').\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3206273"}]}