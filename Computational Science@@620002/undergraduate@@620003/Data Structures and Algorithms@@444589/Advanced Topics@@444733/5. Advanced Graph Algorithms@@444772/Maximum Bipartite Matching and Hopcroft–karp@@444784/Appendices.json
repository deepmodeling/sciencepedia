{"hands_on_practices": [{"introduction": "The first step in mastering any algorithm is to implement it from first principles. This exercise challenges you to translate the theory of maximum bipartite matching into a functional program [@problem_id:3250161]. By implementing an efficient algorithm based on augmenting paths, such as Hopcroft-Karp, you will gain a deep, practical understanding of how layered graphs and alternating path searches work together to find an optimal solution. This foundational skill is essential for tackling more complex applications of matching theory.", "problem": "You are given a family of bipartite graphs representing which agents can take which tasks. In the specific narrative, a set of spies must acquire a set of secrets. Each spy can attempt to acquire only one secret, and each secret can be acquired by at most one spy. There is an edge between a spy and a secret if that spy has the capability to acquire that secret. Formally, consider a bipartite graph $G = (U,V,E)$, where $U$ is the set of spies, $V$ is the set of secrets, and $E \\subseteq U \\times V$ is the set of possible acquisitions. A matching $M \\subseteq E$ is a set of pairwise non-incident edges, and its cardinality is $|M|$. The maximum bipartite matching problem is to find a matching of largest possible cardinality.\n\nThe fundamental base you should use is the following set of core definitions and facts from graph theory and the theory of algorithms:\n- A bipartite graph $G = (U,V,E)$ has vertex sets $U$ and $V$ with $U \\cap V = \\varnothing$ and edges only between $U$ and $V$.\n- A matching $M$ is a subset of edges such that no two edges share an endpoint.\n- An augmenting path with respect to a matching $M$ is a simple path that starts and ends at unmatched vertices such that edges along the path alternate between not in $M$ and in $M$. If an augmenting path exists, augmenting along it strictly increases $|M|$.\n\nYour task is to write a complete program that, for each test case, computes the maximum number of secrets that can be stolen simultaneously, which equals the size of a maximum matching. The program should implement an algorithm grounded in the concept of augmenting paths and level graphs that is suitable for efficiently finding a maximum matching in bipartite graphs.\n\nFor each test case below, the spies are indexed as integers in the range $[0, n-1]$, the secrets are indexed as integers in the range $[0, m-1]$, and the set $E$ is given as a set of ordered pairs $(u,v)$ with $u \\in U$ and $v \\in V$. If duplicate ordered pairs appear, their effect is identical to a single edge, and they should be treated as a single connection.\n\nThe required final output format is a single line containing a comma-separated list of integers enclosed in square brackets, in the order of the test cases, where each integer is the size of the maximum matching for the corresponding test case. For example, a valid output could look like $[3,0,4]$.\n\nThere are no physical units, angles, or percentages involved in this problem. All outputs must be integers.\n\nTest Suite:\n- Test Case $1$ (general case): $n = 5$, $m = 6$, $E = \\{(0,0),(0,1),(1,0),(1,2),(1,3),(2,1),(2,3),(3,2),(3,4),(4,4),(4,5)\\}$.\n- Test Case $2$ (boundary with no edges): $n = 3$, $m = 4$, $E = \\varnothing$.\n- Test Case $3$ (perfect matching exists): $n = 4$, $m = 4$, $E = \\{(0,0),(1,1),(2,2),(3,3)\\}$.\n- Test Case $4$ (imbalanced graph with limited secrets): $n = 3$, $m = 5$, $E = \\{(0,0),(0,1),(1,0),(1,1),(2,0),(2,1)\\}$.\n- Test Case $5$ (disjoint components and duplicate edges): $n = 6$, $m = 6$, $E = \\{(0,0),(0,0),(0,1),(1,1),(2,2),(2,3),(3,2),(4,3),(4,4),(5,5)\\}$.\n- Test Case $6$ (chain-like structure that enables multiple shortest augmenting paths): $n = 7$, $m = 7$, $E = \\{(0,0),(0,1),(1,1),(1,2),(2,2),(2,3),(3,3),(3,4),(4,4),(4,5),(5,5),(5,6),(6,0),(6,6)\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases. For instance, the output should look exactly like $[r_1,r_2,r_3,r_4,r_5,r_6]$, where each $r_i$ is the maximum matching size for Test Case $i$.", "solution": "We begin from the standard graph-theoretic foundation: for a bipartite graph $G = (U,V,E)$, a matching $M \\subseteq E$ is a set of edges with no shared endpoints, and an augmenting path with respect to $M$ is a simple path that starts and ends at unmatched vertices such that edges on the path alternate between not in $M$ and in $M$. A classical and well-tested fact is that if an augmenting path exists with respect to a matching $M$, then augmenting along it strictly increases the cardinality of the matching, and conversely, a matching is maximum if and only if there is no augmenting path.\n\nTo compute a maximum matching efficiently, one can find multiple vertex-disjoint shortest augmenting paths per iteration rather than a single path at a time. The Hopcroft–Karp algorithm exploits this insight by building a layered graph using a Breadth-First Search (BFS) from all currently unmatched vertices in $U$ simultaneously, discovering the shortest distance to unmatched vertices in $V$, and then performing a Depth-First Search (DFS) restricted to the discovered BFS layers to find a maximal set of vertex-disjoint shortest augmenting paths. Each augmentation increases the matching size, and the BFS ensures that the length of subsequent augmenting paths strictly increases in phases, yielding a worst-case time complexity of $O(|E| \\sqrt{|U| + |V|})$.\n\nAlgorithmic design in detail:\n1. Represent the bipartite graph by an adjacency list for vertices in $U$: for each $u \\in U$, maintain the set of neighbors $N(u) \\subseteq V$ deduplicated from the input pairs.\n2. Maintain two pairing arrays: $\\mathrm{pairU}[u]$ giving the secret in $V$ matched to $u$ or $-1$ if unmatched, and $\\mathrm{pairV}[v]$ giving the spy in $U$ matched to $v$ or $-1$ if unmatched.\n3. Perform a BFS phase:\n   - Initialize a distance array $\\mathrm{dist}[u]$ to $\\infty$ for all $u \\in U$.\n   - For each free (unmatched) $u \\in U$, set $\\mathrm{dist}[u] = 0$ and enqueue $u$.\n   - For each dequeued $u$, for every neighbor $v \\in N(u)$:\n     - If $v$ is matched to some $u' = \\mathrm{pairV}[v]$ and $\\mathrm{dist}[u']$ is $\\infty$, then set $\\mathrm{dist}[u'] = \\mathrm{dist}[u] + 1$ and enqueue $u'$.\n     - If $v$ is free (i.e., $\\mathrm{pairV}[v] = -1$), record that at least one shortest augmenting path exists in this BFS layering.\n   - The BFS phase returns a boolean indicating whether any free vertex in $V$ was reached from the layer graph, which implies the existence of at least one augmenting path.\n4. Perform a DFS phase for each free $u \\in U$ to find and commit augmenting paths while respecting the BFS layers:\n   - For a given $u$, explore neighbors $v \\in N(u)$. If $v$ is free, immediately match $u$ to $v$.\n   - Otherwise, let $u' = \\mathrm{pairV}[v]$; if $\\mathrm{dist}[u'] = \\mathrm{dist}[u] + 1$, recursively attempt to augment through $u'$. If successful, rematch $u$ to $v$ and return success.\n   - If no neighbor leads to augmentation, set $\\mathrm{dist}[u] = \\infty$ to prune future DFS attempts in this phase.\n5. Repeat BFS and DFS phases until BFS indicates no augmenting paths remain. The number of successful augmentations is the maximum matching cardinality.\n\nCorrectness rests on two pillars: first, augmenting along disjoint shortest augmenting paths cannot interfere adversely with each other, since each path is vertex-disjoint and flips the matched status along alternating edges; second, the BFS layering ensures that all augmenting paths found in a phase are shortest, and that after augmentation the shortest possible augmenting path length strictly increases, limiting the number of phases to $O(\\sqrt{|U| + |V|})$.\n\nWe now reason about the test suite results:\n- Test Case $1$: $n = 5$, $m = 6$, $E = \\{(0,0),(0,1),(1,0),(1,2),(1,3),(2,1),(2,3),(3,2),(3,4),(4,4),(4,5)\\}$. One valid maximum matching is $\\{(0,1),(1,3),(2,0),(3,2),(4,4)\\}$, which has size $5$, so the result is $5$.\n- Test Case $2$: $n = 3$, $m = 4$, $E = \\varnothing$. There are no edges, hence no matching edges exist, and the maximum matching size is $0$.\n- Test Case $3$: $n = 4$, $m = 4$, $E = \\{(0,0),(1,1),(2,2),(3,3)\\}$. The set $\\{(0,0),(1,1),(2,2),(3,3)\\}$ is a perfect matching of size $4$, thus the result is $4$.\n- Test Case $4$: $n = 3$, $m = 5$, $E = \\{(0,0),(0,1),(1,0),(1,1),(2,0),(2,1)\\}$. Only secrets $0$ and $1$ are available to all spies; at most two spies can be matched, so the maximum matching size is $2$.\n- Test Case $5$: $n = 6$, $m = 6$, $E = \\{(0,0),(0,0),(0,1),(1,1),(2,2),(2,3),(3,2),(4,3),(4,4),(5,5)\\}$. Despite the duplicate $(0,0)$, deduplication yields effective edges. A maximum matching is $\\{(0,0),(1,1),(2,3),(3,2),(4,4),(5,5)\\}$ of size $6$, hence the result is $6$.\n- Test Case $6$: $n = 7$, $m = 7$, $E = \\{(0,0),(0,1),(1,1),(1,2),(2,2),(2,3),(3,3),(3,4),(4,4),(4,5),(5,5),(5,6),(6,0),(6,6)\\}$. A perfect matching exists, for instance $\\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,0)\\}$ yielding size $7$, so the result is $7$.\n\nTherefore, in order, the outputs for the six test cases are $[5,0,4,2,6,7]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef hopcroft_karp_max_matching(n_left, n_right, edges):\n    \"\"\"\n    Compute maximum bipartite matching using the Hopcroft–Karp algorithm.\n\n    n_left: number of vertices on the left side U (spies), indexed 0..n_left-1\n    n_right: number of vertices on the right side V (secrets), indexed 0..n_right-1\n    edges: list of (u, v) pairs where u in U, v in V\n\n    Returns: size of maximum matching (integer)\n    \"\"\"\n    # Build deduplicated adjacency list for U\n    adj = [set() for _ in range(n_left)]\n    for u, v in edges:\n        if 0 = u  n_left and 0 = v  n_right:\n            adj[u].add(v)\n        else:\n            # Ignore any out-of-range edges; not expected in given test suite\n            pass\n    adj = [sorted(list(neis)) for neis in adj]\n\n    # Pairing arrays: -1 means free/unmatched\n    pairU = [-1] * n_left\n    pairV = [-1] * n_right\n    dist = [0] * n_left\n    INF = 10**9\n\n    def bfs():\n        \"\"\"\n        BFS builds layers from all free U vertices.\n        Returns True if there exists at least one augmenting path.\n        \"\"\"\n        q = deque()\n        for u in range(n_left):\n            if pairU[u] == -1:\n                dist[u] = 0\n                q.append(u)\n            else:\n                dist[u] = INF\n\n        found_free_v = False\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                pu = pairV[v]\n                if pu != -1:\n                    if dist[pu] == INF:\n                        dist[pu] = dist[u] + 1\n                        q.append(pu)\n                else:\n                    # Reached a free vertex on V; indicates an augmenting path exists\n                    found_free_v = True\n        return found_free_v\n\n    def dfs(u):\n        \"\"\"\n        DFS restricted to BFS layers to find and commit augmenting paths.\n        \"\"\"\n        for v in adj[u]:\n            pu = pairV[v]\n            # If v is free, we can match u->v\n            if pu == -1:\n                pairU[u] = v\n                pairV[v] = u\n                return True\n            # Otherwise try to advance on layer graph\n            if dist[pu] == dist[u] + 1 and dfs(pu):\n                pairU[u] = v\n                pairV[v] = u\n                return True\n        # Prune: no augmenting path from u in this phase\n        dist[u] = INF\n        return False\n\n    matching = 0\n    while bfs():\n        for u in range(n_left):\n            if pairU[u] == -1:\n                if dfs(u):\n                    matching += 1\n    return matching\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is (n_left, n_right, edges)\n    test_cases = [\n        # Test Case 1\n        (5, 6, [(0,0),(0,1),(1,0),(1,2),(1,3),(2,1),(2,3),(3,2),(3,4),(4,4),(4,5)]),\n        # Test Case 2\n        (3, 4, []),\n        # Test Case 3\n        (4, 4, [(0,0),(1,1),(2,2),(3,3)]),\n        # Test Case 4\n        (3, 5, [(0,0),(0,1),(1,0),(1,1),(2,0),(2,1)]),\n        # Test Case 5 (includes duplicate edge (0,0))\n        (6, 6, [(0,0),(0,0),(0,1),(1,1),(2,2),(2,3),(3,2),(4,3),(4,4),(5,5)]),\n        # Test Case 6\n        (7, 7, [(0,0),(0,1),(1,1),(1,2),(2,2),(2,3),(3,3),(3,4),(4,4),(4,5),(5,5),(5,6),(6,0),(6,6)]),\n    ]\n\n    results = []\n    for n_left, n_right, edges in test_cases:\n        result = hopcroft_karp_max_matching(n_left, n_right, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3250161"}, {"introduction": "Real-world challenges rarely present themselves as neatly defined graphs. This practice pushes you to apply your algorithmic knowledge to a problem from computational geometry [@problem_id:3250202]. You will first model the problem by constructing a bipartite graph based on the Euclidean distance between points, and only then apply a maximum matching algorithm. This exercise highlights the crucial skill of abstraction: recognizing an underlying graph structure in a seemingly different domain and using it to find a solution.", "problem": "A bipartite graph $G = (U \\cup V, E)$ is defined on two disjoint sets $U$ and $V$ with edges $E \\subseteq U \\times V$. A matching $M \\subseteq E$ is a set of pairwise non-incident edges, meaning that no two edges in $M$ share a common endpoint. The Maximum Bipartite Matching problem asks for a matching of maximum cardinality. In this task, the bipartite graph arises from geometric proximity in the Euclidean plane: there is an edge $(u, v) \\in E$ if and only if the Euclidean distance $d(u, v)$ is strictly less than a given radius $R$, where $d(u, v)$ denotes the Euclidean distance between point $u \\in U$ and point $v \\in V$.\n\nStarting from the fundamental definitions of bipartite graphs, matchings, and augmenting paths, derive the algorithmic design to compute a maximum matching based on layered exploration and augmentation. The derivation must adhere to the conceptual base that an augmenting path increases the matching size by one and that repeatedly finding a set of shortest augmenting paths leads to efficient progress toward the maximum matching. Use this reasoning to implement the Hopcroft–Karp algorithm, which constructs layers using Breadth-First Search (BFS) and finds augmenting paths using Depth-First Search (DFS), thereby augmenting multiple vertex-disjoint shortest paths in each phase.\n\nFor each test case, you are given explicit coordinates of points in $U$ and $V$ as ordered pairs $(x, y)$ and a real radius $R$. Build the bipartite graph by including an edge $(u, v)$ if and only if $d(u, v)  R$. The Euclidean distance $d(u, v)$ between $u = (x_u, y_u)$ and $v = (x_v, y_v)$ is $d(u, v) = \\sqrt{(x_u - x_v)^2 + (y_u - y_v)^2}$. You should compute the size of a maximum matching for each test case. The output for each test case is a single integer equal to the cardinality of the maximum matching.\n\nThe test suite consists of the following cases, each with fully specified parameters:\n- Test case $1$: $U = \\{(0, 0), (2, 0), (1, 1)\\}$, $V = \\{(0, 1), (2, 1), (3, 0)\\}$, $R = 1.5$.\n- Test case $2$: $U = \\{(0, 0)\\}$, $V = \\{(10, 10)\\}$, $R = 5$.\n- Test case $3$: $U = \\{(0, 0), (0, 1), (1, 0)\\}$, $V = \\{(0, 0), (0, 1)\\}$, $R = 100$.\n- Test case $4$: $U = \\{(0, 0), (2, 0)\\}$, $V = \\{(1, 0), (2, 0)\\}$, $R = 1$.\n- Test case $5$: $U = \\{(0, 0), (3, 0), (6, 0)\\}$, $V = \\{(0, 1), (3, 1), (6, 1)\\}$, $R = 1.1$.\n- Test case $6$: $U = \\{(0, 0), (0, 2), (0, 4), (10, 10)\\}$, $V = \\{(0, 1), (0, 3)\\}$, $R = 1.5$.\n\nYour program must:\n- Construct the bipartite graph for each test case by adding an edge $(u, v)$ if and only if $d(u, v)  R$.\n- Compute the size of a maximum matching using an algorithm derived from first principles and implemented via the Hopcroft–Karp method.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases, for example, \"[r1,r2,r3,r4,r5,r6]\". The answers must be integers, and no physical units are involved.\n\nNote: Distances are strict; edges exist only when $d(u, v)  R$ (strict inequality).", "solution": "The problem requires the derivation and implementation of the Hopcroft–Karp algorithm to find the maximum cardinality matching in a bipartite graph. The graph is constructed based on a geometric proximity condition in the Euclidean plane.\n\nA bipartite graph is a graph $G = (V, E)$ whose vertices can be divided into two disjoint and independent sets, $U$ and $V$, such that every edge in $E$ connects a vertex in $U$ to one in $V$. The problem specifies such a graph $G = (U \\cup V, E)$.\n\nA matching $M$ is a subset of edges $M \\subseteq E$ where no two edges share a common vertex. The maximum bipartite matching problem seeks to find a matching $M$ with the largest possible number of edges, i.e., to maximize $|M|$.\n\nThe theoretical foundation for algorithms that find maximum matchings is based on the concept of an augmenting path. Given a matching $M$, an alternating path is a path in the graph whose edges alternate between being in $M$ and not in $M$. An augmenting path is an alternating path whose endpoints are both \"free\" (or \"unmatched\"), meaning they are not endpoints of any edge in $M$.\n\nThe significance of augmenting paths is captured by Berge's Lemma, a fundamental result in matching theory. It states that a matching $M$ in a graph $G$ is a maximum matching if and only if there are no augmenting paths with respect to $M$. This lemma provides a constructive approach to finding a maximum matching:\n$1$. Start with an initial matching $M$, which can be empty ($M = \\emptyset$).\n$2$. Search for an augmenting path $P$ with respect to the current matching $M$.\n$3$. If an augmenting path $P$ is found, the matching can be enlarged. The new matching $M'$ is the symmetric difference of $M$ and $P$, denoted $M' = M \\oplus P = (M \\setminus P) \\cup (P \\setminus M)$. This operation effectively 'flips' the edges along the path $P$, deselecting those in $M$ and selecting those not in $M$. The size of the matching increases by one: $|M'| = |M| + 1$.\n$4$. Repeat from step $2$ until no augmenting path can be found. At this point, by Berge's Lemma, the matching is maximum.\n\nWhile any augmenting path algorithm will find a maximum matching, the efficiency varies greatly. The Hopcroft–Karp algorithm is an efficient method that achieves a time complexity of $O(|E|\\sqrt{|V|})$. Its efficiency stems from finding a maximal set of vertex-disjoint shortest augmenting paths in each phase, rather than just one path at a time. The length of the shortest augmenting path is guaranteed to be non-decreasing with each phase.\n\nEach phase of the Hopcroft–Karp algorithm consists of two main steps:\n\n$1$. **Breadth-First Search (BFS):** The first step constructs a layered graph to identify all shortest augmenting paths. A multi-source BFS is initiated simultaneously from all free vertices in one of the partitions, say $U$. The search proceeds by alternating between edges not in the matching (from a vertex in $U$ to a vertex in $V$) and edges in the matching (from a vertex in $V$ back to a vertex in $U$). This process partitions the vertices into layers $L_0, L_1, L_2, \\dots$. Layer $L_0$ consists of the free vertices in $U$. Layer $L_{i+1}$ is the set of vertices reachable from layer $L_i$. The BFS continues until it either exhausts all reachable vertices or reaches one or more free vertices in $V$. The length of the shortest augmenting paths for the current phase is determined by the first layer in which a free vertex from $V$ appears. If no free vertex in $V$ is reachable, no augmenting paths exist, and the algorithm terminates.\n\n$2$. **Depth-First Search (DFS):** The second step is to find a maximal set of vertex-disjoint augmenting paths using the layered graph constructed by the BFS. A DFS is started from each free vertex $u \\in U$. The search is constrained to the layered graph: an edge from a vertex $x$ in layer $L_i$ to a vertex $y$ is followed only if $y$ is in layer $L_{i+1}$. This corresponds to checking if `dist[v'] == dist[u'] + 1`, where the path segment is $u' \\to v \\to v'$, and $u', v'$ are in $U$. When the DFS finds a path to a free vertex in $V$, an augmenting path has been found. The matching is updated along this path, and the DFS continues its search from the next free vertex in $U$. Using a single DFS traversal for each free vertex in $U$ and marking visited nodes (or by the structure of the recursion) ensures that the augmenting paths found in a single phase are vertex-disjoint.\n\nThe algorithm iterates through these BFS-DFS phases. The size of the matching increases with each phase. The process halts when the BFS step fails to find any augmenting path, indicating the current matching is maximum.\n\nFor the given problem, the graph must first be constructed. For each pair of points $(u, v)$ where $u \\in U$ and $v \\in V$, the squared Euclidean distance is calculated as $d(u, v)^2 = (x_u - x_v)^2 + (y_u - y_v)^2$. An edge $(u,v)$ is added to the graph if and only if $d(u,v)^2  R^2$. This avoids floating-point inaccuracies and computational costs associated with the square root function. Once the adjacency list representation of the graph is built, the Hopcroft–Karp algorithm is applied to find the cardinality of the maximum matching.", "answer": "```python\nimport collections\n\n# numpy is allowed but not strictly necessary for this implementation.\n# The template requires its import.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {'U': [(0, 0), (2, 0), (1, 1)], 'V': [(0, 1), (2, 1), (3, 0)], 'R': 1.5},\n        {'U': [(0, 0)], 'V': [(10, 10)], 'R': 5},\n        {'U': [(0, 0), (0, 1), (1, 0)], 'V': [(0, 0), (0, 1)], 'R': 100},\n        {'U': [(0, 0), (2, 0)], 'V': [(1, 0), (2, 0)], 'R': 1},\n        {'U': [(0, 0), (3, 0), (6, 0)], 'V': [(0, 1), (3, 1), (6, 1)], 'R': 1.1},\n        {'U': [(0, 0), (0, 2), (0, 4), (10, 10)], 'V': [(0, 1), (0, 3)], 'R': 1.5}\n    ]\n\n    results = []\n    for case in test_cases:\n        U_coords, V_coords, R = case['U'], case['V'], case['R']\n        \n        m = len(U_coords)\n        n = len(V_coords)\n        R_sq = R * R\n\n        # Adjacency list for U vertices (1-indexed).\n        # adj[u] contains a list of v vertices adjacent to u.\n        adj = {i: [] for i in range(1, m + 1)}\n        for i in range(m):\n            u_coord = U_coords[i]\n            for j in range(n):\n                v_coord = V_coords[j]\n                dist_sq = (u_coord[0] - v_coord[0])**2 + (u_coord[1] - v_coord[1])**2\n                if dist_sq  R_sq:\n                    # Use 1-based indexing for graph algorithm\n                    adj[i + 1].append(j + 1)\n        \n        result = hopcroft_karp(adj, m, n)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef hopcroft_karp(adj, m, n):\n    \"\"\"\n    Implementation of the Hopcroft-Karp algorithm.\n    :param adj: Adjacency list from U to V (1-indexed).\n    :param m: Number of vertices in U.\n    :param n: Number of vertices in V.\n    :return: The size of the maximum matching.\n    \"\"\"\n    # 0 is the NIL vertex\n    pair_u = {i: 0 for i in range(m + 1)}\n    pair_v = {i: 0 for i in range(n + 1)}\n    dist = {}\n    \n    matching_size = 0\n    \n    # bfs function to build layers\n    def bfs():\n        q = collections.deque()\n        for u in range(1, m + 1):\n            if pair_u[u] == 0:  # u is free\n                dist[u] = 0\n                q.append(u)\n            else:\n                dist[u] = float('inf')\n        \n        dist[0] = float('inf')  # Distance to NIL vertex\n        \n        while q:\n            u = q.popleft()\n            if dist[u]  dist[0]:\n                for v in adj.get(u, []):\n                    # pair_v[v] is the vertex in U matched with v\n                    u_matched = pair_v[v]\n                    if dist.get(u_matched, float('inf')) == float('inf'):\n                        dist[u_matched] = dist[u] + 1\n                        q.append(u_matched)\n                        \n        return dist[0] != float('inf')\n\n    # dfs function to find augmenting paths\n    def dfs(u):\n        if u != 0:\n            for v in adj.get(u, []):\n                u_matched = pair_v[v]\n                if dist.get(u_matched, float('inf')) == dist[u] + 1:\n                    if dfs(u_matched):\n                        pair_v[v] = u\n                        pair_u[u] = v\n                        return True\n            dist[u] = float('inf')\n            return False\n        return True # Reached NIL, augmenting path found\n\n    while bfs():\n        for u in range(1, m + 1):\n            if pair_u[u] == 0:  # If u is free\n                if dfs(u):\n                    matching_size += 1\n                    \n    return matching_size\n\n\nsolve()\n```", "id": "3250202"}, {"introduction": "The power of a maximum matching extends far beyond simply finding the largest set of pairs. This exercise explores the profound connection between maximum matchings and minimum vertex covers, as described by Kőnig's theorem [@problem_id:3250194]. After finding a maximum matching $M$, you will use its structure to construct a minimum vertex cover $C$, demonstrating that $|M|=|C|$. This practice reveals that the algorithmic process doesn't just yield a number, but a rich structure that can be used to solve other fundamental graph problems.", "problem": "You are given the task of constructing, for each of several bipartite graphs, a minimum vertex cover from a maximum matching, using an efficient method grounded in core graph-theoretic principles. A bipartite graph is a graph $G = (V, E)$ with a partition $V = L \\cup R$ where every edge $e \\in E$ has one endpoint in $L$ and the other in $R$. A matching $M \\subseteq E$ is a set of pairwise vertex-disjoint edges. The size of a matching is the number of edges it contains. A vertex cover $C \\subseteq V$ is a set of vertices that intersects every edge in $E$. The goal is to compute a minimum vertex cover $C$ of smallest possible size. A fundamental fact (Kőnig's theorem) asserts that for any bipartite graph, the maximum matching size equals the minimum vertex cover size; that is, if $M$ is a maximum matching and $C$ is a minimum vertex cover, then $|M| = |C|$.\n\nYour program must, for each provided bipartite graph:\n- Compute a maximum matching using an efficient algorithm whose time complexity is asymptotically no worse than $O(|E| \\sqrt{|V|})$ on each instance.\n- From the computed maximum matching, construct a corresponding minimum vertex cover $C$ and report its size.\n- Ensure the reported size equals the size of the computed maximum matching.\n\nDefinitions to be used as the foundational base:\n- A path in $G$ is a sequence of vertices with consecutive vertices connected by an edge. An augmenting path with respect to a matching $M$ is a path that starts and ends at unmatched vertices and alternates between edges not in $M$ and edges in $M$.\n- By Berge's theorem, a matching is maximum if and only if there is no augmenting path with respect to it.\n- The Hopcroft–Karp algorithm is an efficient algorithm for maximum bipartite matching that repeatedly finds a maximal set of vertex-disjoint shortest augmenting paths using Breadth-First Search (BFS) and Depth-First Search (DFS).\n\nInput model for each test case:\n- The bipartite graph is specified by three parameters: the number of left vertices $n_L$, the number of right vertices $n_R$, and the edge list $E \\subseteq \\{0, 1, \\dots, n_L - 1\\} \\times \\{0, 1, \\dots, n_R - 1\\}$.\n- Vertices on the left are labeled by integers $0$ through $n_L - 1$ and on the right by integers $0$ through $n_R - 1$.\n\nTest suite to be hardcoded inside your program:\n- Case $1$ (general happy path): $n_L = 3$, $n_R = 3$, edges $E = [ (0,0), (0,1), (1,1), (2,1), (2,2) ]$.\n- Case $2$ (empty graph boundary): $n_L = 2$, $n_R = 3$, edges $E = [\\,]$.\n- Case $3$ (star-shaped, many-to-one): $n_L = 3$, $n_R = 1$, edges $E = [ (0,0), (1,0), (2,0) ]$.\n- Case $4$ (multiple components, non-perfect): $n_L = 4$, $n_R = 4$, edges $E = [ (0,0), (0,1), (1,1), (2,2), (3,2) ]$.\n- Case $5$ (right-limited capacity): $n_L = 4$, $n_R = 3$, edges $E = [ (0,0), (0,1), (1,1), (1,2), (2,2), (3,2) ]$.\n\nProgram requirements:\n- Implement the Hopcroft–Karp algorithm to compute a maximum matching for each case, ensuring the asymptotic bound $O(|E| \\sqrt{|V|})$.\n- Derive a minimum vertex cover from the computed matching by traversing alternating paths starting from unmatched vertices on the left side using only non-matching edges from $L$ to $R$ and only matching edges from $R$ back to $L$, and then forming the cover $C = \\left( L \\setminus T_L \\right) \\cup \\left( R \\cap T_R \\right)$, where $T_L$ and $T_R$ are, respectively, the sets of reachable left and right vertices in this alternating traversal.\n- For each test case, output a single integer equal to $|C|$, the size of the minimum vertex cover (which must equal the size of the maximum matching by Kőnig's theorem).\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases: for example, the format is $[r_1, r_2, r_3, r_4, r_5]$, where each $r_i$ is the integer size of the computed minimum vertex cover for case $i$.", "solution": "The problem is valid as it is well-posed, self-contained, and grounded in the established principles of graph theory, specifically concerning maximum bipartite matching and minimum vertex covers. It requests the implementation of the Hopcroft–Karp algorithm and the subsequent construction of a minimum vertex cover, a standard and formalizable task in algorithmics.\n\nThe solution is divided into two main parts. First, we compute the maximum matching for a given bipartite graph $G = (V, E)$ with partition $V = L \\cup R$ using the Hopcroft–Karp algorithm. Second, we use the computed maximum matching $M$ to construct a minimum vertex cover $C$ based on the constructive proof of Kőnig's theorem.\n\n**Part 1: The Hopcroft–Karp Algorithm for Maximum Bipartite Matching**\n\nThe Hopcroft–Karp algorithm finds a maximum matching in a bipartite graph with a time complexity of $O(|E| \\sqrt{|V|})$. The algorithm works iteratively. Starting with an empty matching $M$, it repeatedly finds a maximal set of vertex-disjoint shortest augmenting paths and uses them to increase the size of $M$. An augmenting path is a path that alternates between edges not in $M$ and edges in $M$, starting from an unmatched vertex in $L$ and ending at an unmatched vertex in $R$. By Berge's theorem, a matching is maximum if and only if no augmenting path exists with respect to it.\n\nEach iteration of the Hopcroft–Karp algorithm consists of two phases:\n\n1.  **Breadth-First Search (BFS):**\n    A layered graph is constructed using a BFS starting simultaneously from all unmatched vertices in the left partition, $L$. The traversal alternates between partitions: from a vertex $u \\in L$ to a vertex $v \\in R$ via an edge not in the current matching $M$, and from a vertex $v \\in R$ back to a vertex $u' \\in L$ via an edge in $M$. The BFS calculates the length of the shortest augmenting paths. It partitions the vertices into levels, where `dist[u]` for a vertex $u \\in L$ is its level in the layered graph. The BFS phase terminates once it reaches one or more unmatched vertices in $R$. If no unmatched vertex in $R$ is reachable, no augmenting paths exist, and the algorithm terminates, as the current matching $M$ is maximum.\n\n2.  **Depth-First Search (DFS):**\n    A DFS is performed from each unmatched vertex in $L$ to find vertex-disjoint augmenting paths of the shortest length determined by the BFS. The DFS only traverses from a vertex $u$ to a vertex $w$ if $w$ is in the next level of the layered graph, i.e., $\\text{dist}[w] = \\text{dist}[u] + 1$. When a DFS path reaches an unmatched vertex in $R$, an augmenting path has been found. The matching $M$ is updated by taking the symmetric difference of $M$ and the path, which effectively swaps the matched and unmatched edges along the path and increases $|M|$ by $1$. The DFS continues to find other vertex-disjoint augmenting paths from the remaining unmatched vertices in $L$.\n\nThis cycle of BFS followed by DFS is repeated. The length of the shortest augmenting paths is proven to strictly increase with each iteration. This property guarantees that the algorithm performs at most $O(\\sqrt{|V|})$ iterations, leading to the total time complexity of $O(|E|\\sqrt{|V|})$.\n\n**Part 2: Constructing a Minimum Vertex Cover from a Maximum Matching**\n\nKőnig's theorem states that in any bipartite graph, the number of edges in a maximum matching equals the number of vertices in a minimum vertex cover. We use the constructive proof of this theorem to find a minimum vertex cover $C$ from the maximum matching $M$ computed by the Hopcroft–Karp algorithm.\n\nThe construction proceeds as follows:\n\n1.  Let $U_L$ be the set of all unmatched vertices in the left partition $L$.\n2.  Perform a graph traversal (e.g., using DFS or BFS) starting from all vertices in $U_L$. This traversal explores alternating paths:\n    - From a vertex $u \\in L$, traverse to a vertex $v \\in R$ if the edge $(u,v)$ is **not** in the matching $M$.\n    - From a vertex $v \\in R$, traverse to a vertex $u' \\in L$ if the edge $(v,u')$ is **in** the matching $M$.\n3.  Let $T$ be the set of all vertices visited during this traversal. We can partition $T$ into $T_L = T \\cap L$ and $T_R = T \\cap R$.\n4.  The minimum vertex cover $C$ is then defined as the set of vertices $C = (L \\setminus T_L) \\cup T_R$.\n\nTo confirm the validity of this construction, we consider two properties: that $C$ is a vertex cover and that its size is equal to $|M|$.\n\n- **$C$ is a vertex cover:** Consider an arbitrary edge $(u, v) \\in E$, with $u \\in L$ and $v \\in R$.\n    - If the edge $(u, v)$ is in the matching $M$: If $u \\in T_L$, then its matched partner $v$ must have been reached from $u$ via a non-matching edge, which is a contradiction. Therefore, $u$ cannot be in $T_L$. This implies $u \\in (L \\setminus T_L)$, so $u \\in C$, and the edge is covered.\n    - If the edge $(u, v)$ is not in the matching $M$: If $u \\in T_L$, then $v$ is reachable from $u$ via the non-matching edge $(u, v)$. Thus, $v \\in T_R$, so $v \\in C$, and the edge is covered. If $u \\notin T_L$, then $u \\in (L \\setminus T_L)$, so $u \\in C$, and the edge is covered.\n    In all cases, every edge is covered.\n\n- **$|C| = |M|$**: The vertices in $C$ are composed of the \"unreachable\" left vertices $(L \\setminus T_L)$ and the \"reachable\" right vertices $(T_R)$. It can be shown that the matching $M$ establishes a bijection between the set of vertices $T_R$ and the set of matched vertices in $T_L$, and also between the set $(L \\setminus T_L)$ and the set of matched vertices in $(R \\setminus T_R)$. Consequently, the set $C$ consists of exactly one vertex from each edge in the matching $M$. Therefore, $|C| = |M|$. By Kőnig's theorem, since $M$ is a maximum matching, $C$ must be a minimum vertex cover.\n\nThe implementation will apply these two parts to each test case provided. For each graph specified by $n_L$, $n_R$, and an edge list $E$, we first run the Hopcroft–Karp algorithm to find $|M|$ and store the matching pairs. Then, we execute the alternating path traversal to find the sets $T_L$ and $T_R$ and compute the size of the resulting vertex cover $C$, which will be our final result for that case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\nclass HopcroftKarp:\n    \"\"\"\n    Implementation of the Hopcroft-Karp algorithm for maximum bipartite matching\n    and construction of a minimum vertex cover.\n    \"\"\"\n    def __init__(self, nL, nR, edges):\n        \"\"\"\n        Initializes the bipartite graph.\n        - nL: Number of vertices in the left partition (U)\n        - nR: Number of vertices in the right partition (V)\n        - edges: A list of tuples (u, v) representing edges\n        \"\"\"\n        self.nL = nL\n        self.nR = nR\n        # Adjacency list for left vertices\n        self.adj = [[] for _ in range(nL)]\n        for u, v in edges:\n            self.adj[u].append(v)\n        \n        # Matching pairs for left (L) and right (R) partitions\n        self.pairL = np.full(nL, -1, dtype=int)\n        self.pairR = np.full(nR, -1, dtype=int)\n        \n        # Distance array for BFS, only for left vertices\n        self.dist = np.full(nL, -1, dtype=int)\n        \n        # Store computed matching for vertex cover construction\n        self.max_matching_size = 0\n\n    def _bfs(self):\n        \"\"\"\n        Performs BFS to find layers in the graph and check for augmenting paths.\n        \"\"\"\n        queue = deque()\n        self.dist.fill(-1) # Reset distances for left vertices\n        \n        # Start BFS from all unmatched vertices in L\n        for u in range(self.nL):\n            if self.pairL[u] == -1:\n                queue.append(u)\n                self.dist[u] = 0\n        \n        found_path = False\n        while queue:\n            u = queue.popleft()\n            for v in self.adj[u]:\n                # u_matched is the vertex in L matched with v\n                u_matched = self.pairR[v]\n                if u_matched == -1:\n                    # Found an augmenting path to an unmatched right vertex\n                    found_path = True\n                # If u_matched has not been visited yet (dist is -1)\n                elif self.dist[u_matched] == -1:\n                    # This is part of an alternating path\n                    self.dist[u_matched] = self.dist[u] + 1\n                    queue.append(u_matched)\n        return found_path\n\n    def _dfs(self, u):\n        \"\"\"\n        Performs DFS to find an augmenting path from vertex u.\n        \"\"\"\n        for v in self.adj[u]:\n            u_matched = self.pairR[v]\n            # If v is free or we can find an augmenting path from its partner u_matched\n            if u_matched == -1 or (self.dist[u_matched] == self.dist[u] + 1 and self._dfs(u_matched)):\n                self.pairL[u] = v\n                self.pairR[v] = u\n                return True\n        # Mark u as visited in this DFS phase to ensure paths are vertex-disjoint\n        self.dist[u] = -1 \n        return False\n\n    def find_max_matching(self):\n        \"\"\"\n        Computes the maximum matching size using the Hopcroft-Karp algorithm.\n        \"\"\"\n        matching_size = 0\n        # Continue as long as augmenting paths are found by BFS\n        while self._bfs():\n            for u in range(self.nL):\n                if self.pairL[u] == -1:\n                    if self._dfs(u):\n                        matching_size += 1\n        self.max_matching_size = matching_size\n        return matching_size\n\n    def find_min_vertex_cover(self):\n        \"\"\"\n        Constructs a minimum vertex cover from the computed maximum matching.\n        This must be called after find_max_matching().\n        \"\"\"\n        # Find unmatched vertices in the left partition\n        unmatched_L = {u for u in range(self.nL) if self.pairL[u] == -1}\n\n        # Sets of reachable vertices from unmatched_L via alternating paths\n        reachable_L = set(unmatched_L)\n        reachable_R = set()\n        \n        q = deque(list(unmatched_L))\n        visited_in_traversal = set(unmatched_L)\n\n        while q:\n            u = q.popleft() # A reachable vertex from L\n            # Traverse non-matching edges from L to R\n            for v in self.adj[u]:\n                if self.pairL[u] != v and v not in reachable_R:\n                    reachable_R.add(v)\n                    # Traverse matching edge from R to L\n                    u_matched = self.pairR[v]\n                    if u_matched != -1 and u_matched not in reachable_L:\n                        reachable_L.add(u_matched)\n                        q.append(u_matched)\n\n        # The minimum vertex cover C = (L \\ T_L) U T_R\n        # where T_L = reachable_L and T_R = reachable_R\n        unreachable_L = set(range(self.nL)) - reachable_L\n        min_cover = unreachable_L | reachable_R\n        \n        return len(min_cover)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: general happy path\n        {'n_L': 3, 'n_R': 3, 'edges': [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)]},\n        # Case 2: empty graph boundary\n        {'n_L': 2, 'n_R': 3, 'edges': []},\n        # Case 3: star-shaped, many-to-one\n        {'n_L': 3, 'n_R': 1, 'edges': [(0, 0), (1, 0), (2, 0)]},\n        # Case 4: multiple components, non-perfect\n        {'n_L': 4, 'n_R': 4, 'edges': [(0, 0), (0, 1), (1, 1), (2, 2), (3, 2)]},\n        # Case 5: right-limited capacity\n        {'n_L': 4, 'n_R': 3, 'edges': [(0, 0), (0, 1), (1, 1), (1, 2), (2, 2), (3, 2)]},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Initialize the HopcroftKarp instance for the current graph.\n        solver = HopcroftKarp(case['n_L'], case['n_R'], case['edges'])\n        \n        # First, compute the maximum matching. This populates the pair arrays.\n        max_matching_size = solver.find_max_matching()\n        \n        # Second, construct the minimum vertex cover from the matching.\n        min_vertex_cover_size = solver.find_min_vertex_cover()\n        \n        # By Kőnig's theorem, these sizes must be equal.\n        # assert max_matching_size == min_vertex_cover_size\n        \n        results.append(min_vertex_cover_size)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3250194"}]}