{"hands_on_practices": [{"introduction": "Understanding an algorithm often begins with tracing its execution on a concrete example. This practice invites you to manually perform the initial iterations of the Floyd-Warshall algorithm on a small graph containing negative edge weights. By tracking the changes in the distance and successor matrices, you will gain a deep, tactile understanding of the algorithm's core dynamic programming update rule and observe precisely how it discovers shorter paths and detects negative cycles [@problem_id:3235663].", "problem": "Consider the following directed weighted graph on $n=6$ vertices labeled $1,2,3,4,5,6$. The weighted adjacency matrix $W$ is given by\n$$\nW \\;=\\;\n\\begin{pmatrix}\n0  3  \\infty  \\infty  \\infty  \\infty\\\\\n\\infty  0  4  2  \\infty  \\infty\\\\\n-10  \\infty  0  5  \\infty  \\infty\\\\\n\\infty  \\infty  \\infty  0  1  \\infty\\\\\n\\infty  \\infty  \\infty  \\infty  0  1\\\\\n\\infty  \\infty  \\infty  1  \\infty  0\n\\end{pmatrix}.\n$$\nAssume a standard all-pairs shortest path dynamic programming routine based on the following fundamental definitions: a path is a sequence of vertices connected by directed edges; the weight of a path is the sum of its edge weights; a shortest path is a path of minimum total weight among all paths with the same endpoints. The routine proceeds in phases $k=0,1,2,\\dots,6$, maintaining a distance matrix $D^{(k)}$ and a successor matrix $\\mathrm{next}^{(k)}$ that together encode, at phase $k$, shortest-path information for all ordered pairs $(i,j)$ subject to the invariant that any path considered at phase $k$ must have all internal vertices drawn from the set $\\{1,2,\\dots,k\\}$. Initially, $D^{(0)}=W$ and $\\mathrm{next}^{(0)}$ is defined so that $\\mathrm{next}^{(0)}[i,j]=j$ if $W[i,j]\\infty$ and $i\\neq j$, $\\mathrm{next}^{(0)}[i,i]=i$ for all $i$, and $\\mathrm{next}^{(0)}[i,j]=\\varnothing$ otherwise.\n\nYour tasks are:\n- State the invariant in your own words, using only the fundamental definitions above.\n- Write down $D^{(0)}$ and $\\mathrm{next}^{(0)}$ as initialized.\n- For phases $k=1,2,3$, apply the routineâ€™s update policy consistent with the stated invariant to produce $D^{(1)}$, $D^{(2)}$, and $D^{(3)}$, and annotate any entries of $\\mathrm{next}$ that change at each phase. Justify each change by explicitly identifying a strictly shorter path whose internal vertices lie in $\\{1,2,\\dots,k\\}$.\n- Explain precisely when and why some diagonal entry $d_{ii}^{(k)}$ becomes negative, identifying the specific cycle and the set of internal vertices that make it admissible at that phase under the invariant.\n\nAnswer requirement: Let $k^\\star$ denote the smallest phase index $k\\in\\{1,2,\\dots,6\\}$ at which any diagonal entry of $D^{(k)}$ first becomes negative. Provide $k^\\star$ as a single integer. No rounding is necessary, and no physical units apply. Your final answer must be only this integer.", "solution": "The problem requires a step-by-step execution of the Floyd-Warshall algorithm to find the specific phase at which a negative cycle is first detected.\n\nFirst, we address the request to state the algorithm's invariant. Based on the provided definitions, the invariant maintained by the routine is that at the end of phase $k$, for any pair of vertices $(i,j)$, the entry $D^{(k)}[i,j]$ stores the minimum weight of any path from vertex $i$ to vertex $j$ whose internal vertices are all contained within the set $\\{1, 2, \\dots, k\\}$.\n\nNext, we establish the initial state of the algorithm at phase $k=0$. The distance matrix $D^{(0)}$ is the given weighted adjacency matrix $W$. The successor matrix $\\mathrm{next}^{(0)}$ is populated according to the specified rules.\n$$ D^{(0)} = W =\n\\begin{pmatrix}\n0  3  \\infty  \\infty  \\infty  \\infty\\\\\n\\infty  0  4  2  \\infty  \\infty\\\\\n-10  \\infty  0  5  \\infty  \\infty\\\\\n\\infty  \\infty  \\infty  0  1  \\infty\\\\\n\\infty  \\infty  \\infty  \\infty  0  1\\\\\n\\infty  \\infty  \\infty  1  \\infty  0\n\\end{pmatrix}\n$$\n$$ \\mathrm{next}^{(0)} =\n\\begin{pmatrix}\n1  2  \\varnothing  \\varnothing  \\varnothing  \\varnothing \\\\\n\\varnothing  2  3  4  \\varnothing  \\varnothing \\\\\n1  \\varnothing  3  4  \\varnothing  \\varnothing \\\\\n\\varnothing  \\varnothing  \\varnothing  4  5  \\varnothing \\\\\n\\varnothing  \\varnothing  \\varnothing  \\varnothing  5  6 \\\\\n\\varnothing  \\varnothing  \\varnothing  4  \\varnothing  6\n\\end{pmatrix}\n$$\nThe update rule for the dynamic programming routine is $D^{(k)}[i,j] = \\min(D^{(k-1)}[i,j], D^{(k-1)}[i,k] + D^{(k-1)}[k,j])$. If an update occurs, the successor is set to $\\mathrm{next}^{(k)}[i,j] = \\mathrm{next}^{(k-1)}[i,k]$.\n\nPhase $k=1$: We consider paths with internal vertex $1$.\nThe only incoming edge to vertex $1$ is from vertex $3$, with weight $D^{(0)}[3,1] = -10$. The only outgoing edge from vertex $1$ is to vertex $2$, with weight $D^{(0)}[1,2] = 3$. This allows for a potential new path from $3$ to $2$ through $1$.\n- For the pair $(3,2)$: We evaluate $D^{(0)}[3,1] + D^{(0)}[1,2] = -10 + 3 = -7$. This is less than the current distance $D^{(0)}[3,2] = \\infty$.\n- Justification: A new, strictly shorter path $3\\to1\\to2$ is found. Its total weight is $-7$. Its internal vertex is $\\{1\\}$, which is consistent with the invariant for phase $k=1$.\n- Update: $D^{(1)}[3,2] = -7$.\n- Successor update: $\\mathrm{next}^{(1)}[3,2] = \\mathrm{next}^{(0)}[3,1] = 1$.\nNo other paths are improved. The distance matrix for phase $k=1$ is:\n$$ D^{(1)} =\n\\begin{pmatrix}\n0  3  \\infty  \\infty  \\infty  \\infty\\\\\n\\infty  0  4  2  \\infty  \\infty\\\\\n-10  -7  0  5  \\infty  \\infty\\\\\n\\infty  \\infty  \\infty  0  1  \\infty\\\\\n\\infty  \\infty  \\infty  \\infty  0  1\\\\\n\\infty  \\infty  \\infty  1  \\infty  0\n\\end{pmatrix}\n$$\n\nPhase $k=2$: We consider paths with internal vertices from $\\{1, 2\\}$. The pivot vertex is $2$. We check for paths of the form $i \\to \\dots \\to 2 \\to \\dots \\to j$.\n- For $(1,3)$: $D^{(1)}[1,2] + D^{(1)}[2,3] = 3 + 4 = 7$. Current $D^{(1)}[1,3]=\\infty$.\n  - Justification: Path $1\\to2\\to3$ has weight $7$. Internal vertex is $\\{2\\} \\subseteq \\{1,2\\}$.\n  - Update: $D^{(2)}[1,3] = 7$. $\\mathrm{next}^{(2)}[1,3] = \\mathrm{next}^{(1)}[1,2] = 2$.\n- For $(1,4)$: $D^{(1)}[1,2] + D^{(1)}[2,4] = 3 + 2 = 5$. Current $D^{(1)}[1,4]=\\infty$.\n  - Justification: Path $1\\to2\\to4$ has weight $5$. Internal vertex is $\\{2\\} \\subseteq \\{1,2\\}$.\n  - Update: $D^{(2)}[1,4] = 5$. $\\mathrm{next}^{(2)}[1,4] = \\mathrm{next}^{(1)}[1,2] = 2$.\n- For $(3,3)$: $D^{(1)}[3,2] + D^{(1)}[2,3] = -7 + 4 = -3$. Current $D^{(1)}[3,3]=0$.\n  - Justification: Path from $3$ to $2$ is $3\\to1\\to2$ (weight $-7$). Path from $2$ to $3$ is direct (weight $4$). Concatenating gives cycle $3\\to1\\to2\\to3$ with weight $-3$. The set of internal vertices is $\\{1,2\\}$, which is exactly the set admissible at phase $k=2$.\n  - Update: $D^{(2)}[3,3] = -3$. $\\mathrm{next}^{(2)}[3,3] = \\mathrm{next}^{(1)}[3,2] = 1$. This is the first negative diagonal entry.\n- For $(3,4)$: $D^{(1)}[3,2] + D^{(1)}[2,4] = -7 + 2 = -5$. Current $D^{(1)}[3,4]=5$.\n  - Justification: Path $3\\to1\\to2\\to4$ has weight $-5$. Internal vertices are $\\{1,2\\}$.\n  - Update: $D^{(2)}[3,4] = -5$. $\\mathrm{next}^{(2)}[3,4] = \\mathrm{next}^{(1)}[3,2] = 1$.\nThe distance matrix for phase $k=2$ is:\n$$ D^{(2)} =\n\\begin{pmatrix}\n0  3  7  5  \\infty  \\infty\\\\\n\\infty  0  4  2  \\infty  \\infty\\\\\n-10  -7  -3  -5  \\infty  \\infty\\\\\n\\infty  \\infty  \\infty  0  1  \\infty\\\\\n\\infty  \\infty  \\infty  \\infty  0  1\\\\\n\\infty  \\infty  \\infty  1  \\infty  0\n\\end{pmatrix}\n$$\n\nPhase $k=3$: We consider paths with internal vertices from $\\{1, 2, 3\\}$. The pivot vertex is $3$.\n- For $(1,1)$: $D^{(2)}[1,3] + D^{(2)}[3,1] = 7 + (-10) = -3$. Current $D^{(2)}[1,1]=0$.\n  - Justification: Cycle $1\\to2\\to3\\to1$ has weight $-3$. Internal vertices $\\{2,3\\} \\subseteq \\{1,2,3\\}$.\n  - Update: $D^{(3)}[1,1] = -3$. $\\mathrm{next}^{(3)}[1,1] = \\mathrm{next}^{(2)}[1,3] = 2$.\n- For $(1,2)$: $D^{(2)}[1,3] + D^{(2)}[3,2] = 7 + (-7) = 0$. Current $D^{(2)}[1,2]=3$.\n  - Justification: Path $1\\to2\\to3\\to1\\to2$ has weight $0$. Internal $\\{1,2,3\\} \\subseteq \\{1,2,3\\}$.\n  - Update: $D^{(3)}[1,2] = 0$. $\\mathrm{next}^{(3)}[1,2] = \\mathrm{next}^{(2)}[1,3] = 2$.\n- For $(1,4)$: $D^{(2)}[1,3] + D^{(2)}[3,4] = 7 + (-5) = 2$. Current $D^{(2)}[1,4]=5$.\n  - Justification: Path for $D^{(2)}[1,3]$ is $1\\to2\\to3$. Path for $D^{(2)}[3,4]$ is $3\\to1\\to2\\to4$. The new path from $1$ to $4$ passes through $3$ and has internal vertices from $\\{1,2,3\\}$. Path weight is $2$.\n  - Update: $D^{(3)}[1,4] = 2$. $\\mathrm{next}^{(3)}[1,4] = \\mathrm{next}^{(2)}[1,3] = 2$.\n- For $(2,1)$: $D^{(2)}[2,3] + D^{(2)}[3,1] = 4 + (-10) = -6$. Current $D^{(2)}[2,1]=\\infty$.\n  - Justification: Path $2\\to3\\to1$ has weight $-6$. Internal vertex $\\{3\\} \\subseteq \\{1,2,3\\}$.\n  - Update: $D^{(3)}[2,1] = -6$. $\\mathrm{next}^{(3)}[2,1] = \\mathrm{next}^{(2)}[2,3] = 3$.\n- For $(2,2)$: $D^{(2)}[2,3] + D^{(2)}[3,2] = 4 + (-7) = -3$. Current $D^{(2)}[2,2]=0$.\n  - Justification: Cycle $2\\to3\\to1\\to2$ has weight $-3$. Internal vertices $\\{1,3\\} \\subseteq \\{1,2,3\\}$.\n  - Update: $D^{(3)}[2,2] = -3$. $\\mathrm{next}^{(3)}[2,2] = \\mathrm{next}^{(2)}[2,3] = 3$.\n- For $(2,4)$: $D^{(2)}[2,3] + D^{(2)}[3,4] = 4 + (-5) = -1$. Current $D^{(2)}[2,4]=2$.\n  - Justification: Path is $2 \\to 3$ followed by $3 \\to (1,2) \\to 4$, forming the path $2 \\to 3 \\to 1 \\to 2 \\to 4$ which has internal vertices from $\\{1,2,3\\}$. Path weight is $-1$.\n  - Update: $D^{(3)}[2,4] = -1$. $\\mathrm{next}^{(3)}[2,4] = \\mathrm{next}^{(2)}[2,3] = 3$.\nThe distance matrix for phase $k=3$ is:\n$$ D^{(3)} =\n\\begin{pmatrix}\n-3  0  7  2  \\infty  \\infty\\\\\n-6  -3  4  -1  \\infty  \\infty\\\\\n-10  -7  -3  -5  \\infty  \\infty\\\\\n\\infty  \\infty  \\infty  0  1  \\infty\\\\\n\\infty  \\infty  \\infty  \\infty  0  1\\\\\n\\infty  \\infty  \\infty  1  \\infty  0\n\\end{pmatrix}\n$$\n\nA diagonal entry $d_{ii}^{(k)}$ becomes negative when, for the first time, a negative-weight cycle involving vertex $i$ is discovered. According to the algorithm, this happens at phase $k$ if a path from a vertex, say $j$, to itself through the pivot vertex $k$ has a negative weight: $D^{(k-1)}[j,k] + D^{(k-1)}[k,j]  0$. The resulting path $j \\rightsquigarrow k \\rightsquigarrow j$ has its internal vertices drawn from the set $\\{1, \\dots, k-1\\} \\cup \\{k\\}$.\n\nAt phase $k=1$, no such condition $D^{(0)}[j,1] + D^{(0)}[1,j]  0$ is met for any $j$.\n\nAt phase $k=2$, we test the condition $D^{(1)}[j,2] + D^{(1)}[2,j]  0$. For $j=3$:\n$$ D^{(1)}[3,2] + D^{(1)}[2,3] = -7 + 4 = -3 $$\nSince $-3  0$, the entry $D^{(2)}[3,3]$ is updated from $0$ to $-3$. This is the first instant any diagonal entry becomes negative. The specific cycle discovered is $3 \\to 1 \\to 2 \\to 3$. This is formed by concatenating the shortest path from $3$ to $2$ known after phase $k=1$ (which is $3\\to1\\to2$, with internal vertex $\\{1\\}$) and the shortest path from $2$ to $3$ known after phase $k=1$ (which is the direct edge $2\\to3$, with no internal vertices). The set of internal vertices for this cycle is $\\{1, 2\\}$. This set is precisely the set of admissible internal vertices for paths considered at phase $k=2$. Thus, the cycle becomes \"visible\" to the algorithm at this phase.\n\nTherefore, the smallest phase index $k^\\star \\in \\{1, 2, \\dots, 6\\}$ at which a diagonal entry of $D^{(k)}$ first becomes negative is $k^\\star=2$.", "answer": "$$\\boxed{2}$$", "id": "3235663"}, {"introduction": "The elegance of the Floyd-Warshall algorithm lies not just in solving the all-pairs shortest path problem, but in its underlying structure, which can be adapted for other path-finding objectives. This exercise challenges you to modify the algorithm's core logic to solve the \"widest path\" problem, where the goal is to maximize the minimum capacity along a path. This involves replacing the standard $(\\min, +)$ operations with a $(\\max, \\min)$ semiring, offering a powerful lesson in algorithmic generalization [@problem_id:3235604].", "problem": "You are given several independent test cases. Each test case consists of a directed graph with nonnegative edge capacities represented as an adjacency matrix, and a single query pair specifying a source vertex and a target vertex. The capacity of a path is defined as the minimum edge capacity along that path. The objective is to compute, for each test case, the maximum possible path capacity from the source to the target, that is, the maximum over all paths of the minimum edge capacity on each path. This is commonly called the widest path or bottleneck path problem.\n\nFundamental base and constraints:\n- A directed graph is given by a set of vertices and a set of directed edges, where each directed edge from vertex $i$ to vertex $j$ has a nonnegative capacity $w_{ij} \\in \\mathbb{R}_{\\ge 0}$. An adjacency matrix $W$ encodes this as $W[i][j] = w_{ij}$.\n- The capacity of a path $P = (v_0, v_1, \\dots, v_\\ell)$ is the value $\\min\\{ w_{v_0 v_1}, w_{v_1 v_2}, \\dots, w_{v_{\\ell-1} v_\\ell} \\}$.\n- If no path exists from a source to a target, the capacity is defined to be $0$.\n- No edge is represented by capacity $0$ in the adjacency matrix. Self-loops may be present; treat the capacity from a vertex to itself as unbounded (conceptually $+\\infty$) for the purposes of dynamic programming, but note that none of the queries below use identical source and target vertices.\n- You must adapt the classical Floydâ€“Warshall algorithm (which computes transitive closure or all-pairs shortest paths) to solve the widest path objective by using a dynamic programming formulation grounded in the principle of optimality: extending a partial solution by an intermediate vertex cannot increase the path capacity beyond the minimum of its parts, and among candidate routes you must select the best according to the widest path objective. Use this to derive a triple-nested-iteration algorithm over intermediate vertices, sources, and targets that computes all-pairs widest path capacities in time $\\mathcal{O}(n^3)$ for a graph with $n$ vertices.\n\nProgram requirements:\n- Implement a program that, for each test case, constructs the all-pairs widest path capacity matrix from the given adjacency matrix and returns the capacity for the specified query pair $(s, t)$ using $0$-based indexing.\n- All edge capacities and outputs are integers. If there is no path from $s$ to $t$, output $0$.\n\nTest suite:\nFor each test case below, the graph is specified by its adjacency matrix $W$ where $W[i][j]$ is the capacity of edge $(i \\to j)$, with $0$ meaning no edge, and the query pair $(s, t)$ is given after the matrix. Vertices are indexed from $0$.\n\n- Test case 1 (happy path: indirect route beats direct):\n  - $n = 4$\n  - $W = [[0, 5, 6, 3], [0, 0, 0, 7], [0, 0, 0, 4], [0, 0, 0, 0]]$\n  - Query $(s, t) = (0, 3)$\n  - Expected widest capacity is 5.\n\n- Test case 2 (disconnected target):\n  - $n = 3$\n  - $W = [[0, 2, 0], [0, 0, 0], [0, 0, 0]]$\n  - Query $(s, t) = (0, 2)$\n  - Expected widest capacity is 0.\n\n- Test case 3 (self-loop does not help; direct beats narrow detour):\n  - $n = 3$\n  - $W = [[0, 10, 2], [0, 100, 1], [0, 0, 0]]$\n  - Query $(s, t) = (0, 2)$\n  - Expected widest capacity is 2.\n\n- Test case 4 (tie between multiple widest routes):\n  - $n = 4$\n  - $W = [[0, 8, 7, 4], [0, 0, 0, 5], [0, 0, 0, 5], [0, 0, 0, 0]]$\n  - Query $(s, t) = (0, 3)$\n  - Expected widest capacity is 5.\n\n- Test case 5 (zero-capacity edge cannot improve capacity):\n  - $n = 3$\n  - $W = [[0, 0, 3], [0, 0, 9], [0, 0, 0]]$\n  - Query $(s, t) = (0, 2)$\n  - Expected widest capacity is 3.\n\n- Test case 6 (longer chain beats direct edge):\n  - $n = 4$\n  - $W = [[0, 6, 0, 5], [0, 0, 6, 0], [0, 0, 0, 6], [0, 0, 0, 0]]$\n  - Query $(s, t) = (0, 3)$\n  - Expected widest capacity is 6.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases above. For the $6$ test cases provided, the exact format is:\n\"[r1,r2,r3,r4,r5,r6]\"\nwhere each $r_i$ is the integer widest capacity for test case $i$.", "solution": "We frame the widest path problem using dynamic programming based on the principle of optimality on directed graphs. Consider a directed graph with vertex set $\\{0, 1, \\dots, n-1\\}$ and adjacency matrix $W$ where $W[i][j] = w_{ij} \\in \\mathbb{R}_{\\ge 0}$ denotes the capacity of edge $(i \\to j)$, with $w_{ij} = 0$ indicating that no edge exists.\n\nDefine the capacity of a path $P = (v_0, v_1, \\dots, v_\\ell)$ as $\\mathrm{cap}(P) = \\min\\{ w_{v_0 v_1}, w_{v_1 v_2}, \\dots, w_{v_{\\ell-1} v_\\ell} \\}$. For vertices $i$ and $j$, the widest path capacity is the value\n$$\nC(i,j) = \\max_{P \\in \\mathcal{P}_{ij}} \\mathrm{cap}(P),\n$$\nwhere $\\mathcal{P}_{ij}$ is the set of all directed paths from $i$ to $j$. If $\\mathcal{P}_{ij}$ is empty, we define $C(i,j) = 0$.\n\nTo compute $C(i,j)$ for all pairs efficiently in $\\mathcal{O}(n^3)$ time, we adapt the Floydâ€“Warshall paradigm. Introduce a dynamic program indexed by an intermediate-vertex budget. Let $D^{(k)}[i][j]$ denote the widest path capacity from $i$ to $j$ using only the set of intermediates from $\\{0,1,\\dots,k-1\\}$ (that is, paths whose internal vertices are taken from the first $k$ vertices). The base case $k=0$ excludes all intermediate vertices; hence only direct edges and the trivial zero-length path $i=j$ are allowed. Therefore,\n- For $i \\ne j$, we set $D^{(0)}[i][j] = W[i][j]$, because the only candidate is the direct edge.\n- For $i = j$, we set $D^{(0)}[i][i] = +\\infty$, reflecting that the capacity of a zero-edge path is unbounded for the purposes of combining with other segments via a minimum; this ensures that $\\min(D^{(k)}[i][i], D^{(k)}[i][j]) = D^{(k)}[i][j]$ and does not artificially reduce capacities.\n\nFor the inductive step, when vertex $k$ is allowed as an intermediate, any path from $i$ to $j$ either does not use $k$ as an intermediate, in which case its capacity is already accounted for by $D^{(k)}[i][j]$, or it uses $k$, in which case it can be decomposed into a path from $i$ to $k$ and a path from $k$ to $j$ whose capacities are $D^{(k)}[i][k]$ and $D^{(k)}[k][j]$, respectively. By the definition of path capacity, the capacity of the concatenated path through $k$ is the minimum of those two capacities. By the widest-path objective, we take the maximum over the option that avoids $k$ and the option that goes through $k$. Hence the recurrence is\n$$\nD^{(k+1)}[i][j] = \\max\\Big( D^{(k)}[i][j], \\min\\big( D^{(k)}[i][k], D^{(k)}[k][j] \\big) \\Big).\n$$\nAfter processing all $k \\in \\{0,1,\\dots,n-1\\}$, we obtain $D^{(n)} = C$, the desired all-pairs widest path capacity matrix. This is precisely the Floydâ€“Warshall structure with the semiring operations replaced by $\\min$ as the path-extension operator and $\\max$ as the path-selection operator.\n\nAlgorithmic implementation details:\n- Initialize a matrix $D$ with $D[i][j] \\leftarrow W[i][j]$ for $i \\ne j$ and $D[i][i] \\leftarrow +\\infty$.\n- For $k$ from $0$ to $n-1$:\n  - For $i$ from $0$ to $n-1$:\n    - For $j$ from $0$ to $n-1$:\n      - Update $D[i][j] \\leftarrow \\max\\big( D[i][j], \\min(D[i][k], D[k][j]) \\big)$.\n- The answer for a query pair $(s,t)$ is $D[s][t]$ if finite, or $0$ if no path exists. In our representation, the absence of a path maintains $D[s][t] = 0$ throughout, so returning $D[s][t]$ suffices.\n\nCorrectness sketch:\n- Base correctness: For $k=0$, $D^{(0)}$ correctly captures capacities with no intermediates. The $+\\infty$ diagonal ensures that composing with an identity path does not reduce capacity.\n- Inductive step: Suppose $D^{(k)}$ correctly encodes widest capacities with intermediates from $\\{0,\\dots,k-1\\}$. Any path permitted in step $k+1$ either avoids $k$ or includes $k$. If it avoids $k$, its best capacity is $D^{(k)}[i][j]$. If it includes $k$, decompose at the first and last occurrences of $k$ to get two subpaths whose capacities are bounded by $D^{(k)}[i][k]$ and $D^{(k)}[k][j]$, and any such concatenation has capacity equal to the minimum of the two. Taking the maximum over these two cases yields the optimal capacity with intermediates from $\\{0,\\dots,k\\}$. Thus the recurrence preserves correctness.\n- Termination yields $D^{(n)} = C$.\n\nTime and space:\n- The triple loop runs in $\\mathcal{O}(n^3)$ time and uses $\\mathcal{O}(n^2)$ space.\n\nNow apply this to the provided test suite:\n\n- Test case 1: Paths from $0$ to $3$ include direct capacity $3$, path $0 \\to 1 \\to 3$ with capacity $\\min(5, 7) = 5$, and path $0 \\to 2 \\to 3$ with capacity $\\min(6, 4) = 4$. The widest is $5$.\n\n- Test case 2: There is no path from $0$ to $2$, so the capacity remains $0$.\n\n- Test case 3: From $0$ to $2$, the direct edge is $2$. The detour $0 \\to 1 \\to 2$ has capacity $\\min(10, 1) = 1$. The self-loop at $1$ with capacity $100$ does not increase this, since $\\min(10, 100, 1) = 1$. Therefore the widest capacity is $\\max(2, 1) = 2$.\n\n- Test case 4: Two candidate detours from $0$ to $3$: $0 \\to 1 \\to 3$ yields capacity $\\min(8, 5) = 5$, and $0 \\to 2 \\to 3$ yields $\\min(7, 5) = 5$. The direct edge has capacity $4$. The widest capacity is $5$.\n\n- Test case 5: The detour via vertex $1$ has capacity $\\min(0, 9) = 0$, which does not improve over the direct edge capacity $3$. The widest capacity is $3$.\n\n- Test case 6: The chain $0 \\to 1 \\to 2 \\to 3$ has capacity $\\min(6, 6, 6) = 6$, which beats the direct edge capacity $5$. Therefore the widest capacity is $6$.\n\nThus, the outputs in order are $[5, 0, 2, 5, 3, 6]$, which the program must produce as a single line in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef widest_path_all_pairs(adj):\n    \"\"\"\n    Compute all-pairs widest path capacities using a Floydâ€“Warshall-style DP.\n    adj: list of lists (n x n) with nonnegative integers; 0 denotes no edge.\n    Returns: matrix D (n x n) of widest capacities; D[i][j] is an integer,\n             with D[i][j] == 0 meaning no path from i to j.\n    \"\"\"\n    n = len(adj)\n    # Initialize DP matrix with floats to use +inf on diagonal.\n    D = [[float(adj[i][j]) for j in range(n)] for i in range(n)]\n    for i in range(n):\n        D[i][i] = float('inf')\n    # Floydâ€“Warshall over max-min semiring\n    for k in range(n):\n        Dik = D  # local alias for speed/readability\n        for i in range(n):\n            dik = Dik[i][k]\n            # If dik is 0, min(0, anything) stays 0; but we can still compute uniformly.\n            for j in range(n):\n                via = dik\n                dkj = Dik[k][j]\n                if dkj  via:\n                    via = dkj\n                if via  Dik[i][j]:\n                    Dik[i][j] = via\n    # Convert back to integers; keep 0 for no path; do not emit infinities.\n    out = [[(0 if (i == j or not np.isfinite(D[i][j])) else int(D[i][j]))\n             if D[i][j] != float('inf') else 0\n            for j in range(n)] for i in range(n)]\n    return out\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (adjacency matrix, (s, t))\n    test_cases = [\n        # Test case 1\n        (\n            [\n                [0,5,6,3],\n                [0,0,0,7],\n                [0,0,0,4],\n                [0,0,0,0],\n            ],\n            (0,3),\n        ),\n        # Test case 2\n        (\n            [\n                [0,2,0],\n                [0,0,0],\n                [0,0,0],\n            ],\n            (0,2),\n        ),\n        # Test case 3\n        (\n            [\n                [0,10,2],\n                [0,100,1],\n                [0,0,0],\n            ],\n            (0,2),\n        ),\n        # Test case 4\n        (\n            [\n                [0,8,7,4],\n                [0,0,0,5],\n                [0,0,0,5],\n                [0,0,0,0],\n            ],\n            (0,3),\n        ),\n        # Test case 5\n        (\n            [\n                [0,0,3],\n                [0,0,9],\n                [0,0,0],\n            ],\n            (0,2),\n        ),\n        # Test case 6\n        (\n            [\n                [0,6,0,5],\n                [0,0,6,0],\n                [0,0,0,6],\n                [0,0,0,0],\n            ],\n            (0,3),\n        ),\n    ]\n\n    results = []\n    for adj, (s, t) in test_cases:\n        D = widest_path_all_pairs(adj)\n        results.append(D[s][t])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3235604"}, {"introduction": "Detecting the presence of a negative cycle is a critical capability of the Floyd-Warshall algorithm, but in many applications, we need to identify the cycle itself. This practice moves beyond mere detection to reconstruction, tasking you with implementing a method to trace back and report the specific sequence of vertices that form a negative cycle. By leveraging the predecessor matrix populated during the algorithm's execution, you will learn how to turn the algorithm's final state into actionable information [@problem_id:3235685].", "problem": "You are given a family of directed weighted graphs in adjacency-matrix form together with a designated anchor vertex for each graph. Your task is to implement a complete program that uses the Floydâ€“Warshall algorithm to detect whether there is a negative cycle associated with the anchor and, if one exists, reconstruct the vertex sequence of that specific negative cycle. The reconstruction must be based solely on a predecessor (parent) matrix accumulated during the algorithm. The final output must aggregate the results for all provided test cases in a single line.\n\nA directed weighted graph is a pair $(V,E)$ with $|V| = n$ and edge weights given by a matrix $W \\in \\mathbb{R}^{n \\times n}$, where $W[i][j]$ is the weight of the edge from vertex $i$ to vertex $j$. If there is no edge from $i$ to $j$, then $W[i][j]$ is $+\\infty$. For all $i$, the diagonal $W[i][i]$ is $0$ unless there is an explicit self-loop. A path is a sequence of vertices, and its total weight is the sum of its edge weights. The All-Pairs Shortest Paths (APSP) problem seeks the shortest path between all pairs of vertices.\n\nFoundational base:\n- The optimal substructure property of shortest paths: any subpath of a shortest path is itself a shortest path with respect to its endpoints.\n- Dynamic programming principle applied to APSP: progressively consider sets of allowed intermediate vertices to refine path distances while respecting optimal substructure.\n\nDefinition of negative cycle detection in closure:\n- After performing the Floydâ€“Warshall closure over all vertices, a vertex $v$ is part of or affected by a negative cycle if and only if the closed distance $D[v][v]$ is strictly less than $0$.\n\nReconstruction directive:\n- For an anchor $s \\in V$, if $D[s][s]  0$, reconstruct one specific negative cycle using the final predecessor matrix $P$. Let $n = |V|$. Define $u$ as the result of applying the predecessor pointer from $(s,s)$ exactly $n$ times: start at $u \\leftarrow s$ and set $u \\leftarrow P[s][u]$ repeatedly for $n$ steps. Then, starting from $u$, continue following predecessors $P[s][\\cdot]$ until you revisit $u$, thereby forming a cycle. Output the cycle as a list of vertex indices that starts at $u$ and ends by repeating $u$ as the last element. If no such cycle exists for the anchor (i.e., $D[s][s] \\ge 0$ or the reconstruction fails), output the empty list $[]$.\n\nProgram requirements:\n- Implement Floydâ€“Warshall to compute a closed distance matrix $D$ and a predecessor matrix $P$ that stores, for each ordered pair $(i,j)$, the immediate predecessor of $j$ on the current shortest path from $i$ to $j$.\n- Use $+\\infty$ for missing edges.\n- For each test case, produce either the reconstructed cycle (as described) or $[]$.\n\nTest suite (each test case is a pair consisting of a matrix $W$ and an anchor $s$):\n1. $W_1$ with $n=4$:\n   - Row 0: [0, 2, +âˆž, +âˆž]\n   - Row 1: [+âˆž, 0, -1, 2]\n   - Row 2: [-2, +âˆž, 0, +âˆž]\n   - Row 3: [+âˆž, -2, +âˆž, 0]\n   Anchor $s_1 = 0$.\n2. $W_2$ with $n=4$:\n   - Row 0: [0, +âˆž, +âˆž, 2]\n   - Row 1: [+âˆž, 0, -3, +âˆž]\n   - Row 2: [+âˆž, +âˆž, 0, 1]\n   - Row 3: [+âˆž, 1, +âˆž, 0]\n   Anchor $s_2 = 2$.\n3. $W_3$ with $n=3$:\n   - Row 0: [0, 1, +âˆž]\n   - Row 1: [+âˆž, 0, 1]\n   - Row 2: [1, +âˆž, 0]\n   Anchor $s_3 = 0$.\n4. $W_4$ with $n=3$:\n   - Row 0: [0, +âˆž, +âˆž]\n   - Row 1: [+âˆž, 0, +âˆž]\n   - Row 2: [+âˆž, +âˆž, -1]\n   Anchor $s_4 = 2$.\n5. $W_5$ with $n=3$:\n   - Row 0: [0, 1, +âˆž]\n   - Row 1: [1, 0, +âˆž]\n   - Row 2: [+âˆž, +âˆž, -1]\n   Anchor $s_5 = 0$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces. Each element is itself a bracketed comma-separated list of integers representing the cycle, or an empty list if no cycle is to be returned. For example, an output could look like $[[a_0,a_1,\\dots,a_0],[],\\dots]$ where the first cycle starts and ends at the same vertex.", "solution": "The user has provided a problem that requires the implementation of the Floyd-Warshall algorithm to find all-pairs shortest paths in a directed weighted graph. The primary tasks are to detect a negative cycle associated with a specific anchor vertex and, if one exists, to reconstruct the sequence of vertices in that cycle using the predecessor matrix generated by the algorithm.\n\n### Principle-Based Design\n\nThe solution is grounded in the principles of dynamic programming as applied to the All-Pairs Shortest Paths (APSP) problem.\n\n**1. The Floyd-Warshall Algorithm:**\nThe Floyd-Warshall algorithm solves the APSP problem by iteratively considering each vertex as an intermediate point in paths between any two other vertices. It relies on the optimal substructure property: a shortest path between vertices $i$ and $j$ that passes through an intermediate vertex $k$ is composed of a shortest path from $i$ to $k$ and a shortest path from $k$ to $j$.\n\nLet $D^{(k)}[i][j]$ be the weight of the shortest path from vertex $i$ to vertex $j$ using only vertices from the set $\\{0, 1, \\dots, k\\}$ as intermediate vertices. The algorithm computes a sequence of matrices $D^{(0)}, D^{(1)}, \\dots, D^{(n)}$, where $n$ is the number of vertices.\n\nThe recurrence relation is:\n$$\nD^{(k)}[i][j] = \\min(D^{(k-1)}[i][j], D^{(k-1)}[i][k] + D^{(k-1)}[k][j])\n$$\nThe base case, $D^{(-1)}$, is the input weight matrix $W$, where $W[i][j] = \\infty$ if there is no edge from $i$ to $j$. In implementation, we can update the matrix in place, removing the superscript. The algorithm proceeds with three nested loops:\nFor $k$ from $0$ to $n-1$:\n  For $i$ from $0$ to $n-1$:\n    For $j$ from $0$ to $n-1$:\n      $D[i][j] \\leftarrow \\min(D[i][j], D[i][k] + D[k][j])$\n\n**2. Predecessor Matrix for Path Reconstruction:**\nTo reconstruct the shortest paths, we maintain a predecessor matrix, $P$. $P[i][j]$ stores the vertex that immediately precedes $j$ on the shortest path from $i$ to $j$.\n\n- **Initialization:** The predecessor matrix $P$ is initialized based on the input graph. For every edge from $i$ to $j$ with finite weight in the input matrix $W$, we set $P[i][j] = i$. If there is no direct edge, the predecessor is undefined (represented by a special value like $-1$). This includes self-loops, where if $W[i][i]$ is finite, $P[i][i]=i$.\n\n- **Update Rule:** During the main loop of the Floyd-Warshall algorithm, if we find a shorter path from $i$ to $j$ through $k$ (i.e., $D[i][k] + D[k][j]  D[i][j]$), we not only update the distance $D[i][j]$, but also the predecessor $P[i][j]$. The new path from $i$ to $j$ is the concatenation of the path from $i$ to $k$ and the path from $k$ to $j$. Thus, the predecessor of $j$ on the new path from $i$ is the same as the predecessor of $j$ on the path from $k$. The update rule is:\n$$\n\\text{If } D[i][k] + D[k][j]  D[i][j], \\text{ then } P[i][j] \\leftarrow P[k][j]\n$$\n\n**3. Negative Cycle Detection:**\nA key feature of the Floyd-Warshall algorithm is its ability to detect negative cycles. A graph contains a negative-weight cycle reachable from a vertex $i$ and from which $i$ is reachable if and only if, after the algorithm completes, the shortest path distance from $i$ to itself, $D[i][i]$, is negative. The problem specifies checking this condition for a given anchor vertex $s$: if $D[s][s]  0$, a negative cycle is associated with $s$.\n\n**4. Cycle Reconstruction:**\nThe problem provides a specific, unconventional directive for reconstructing the cycle based on the final predecessor matrix $P$ after the Floyd-Warshall algorithm has completed. Let the anchor vertex be $s$ and the number of vertices be $n$.\n\n- **Step 4.1: Identify a Vertex on the Cycle:** If $D[s][s]  0$, it implies that the shortest path from $s$ to itself involves a cycle. A vertex $u$ on this cycle can be found by repeatedly applying the predecessor function. Starting with a pointer at $s$, we trace backwards along the \"shortest path\" from $s$ to $s$. The procedure is to initialize $u \\leftarrow s$ and then update $u \\leftarrow P[s][u]$ for $n$ iterations. Since any simple path has at most $n-1$ edges, traversing $n$ predecessor links guarantees that the final vertex $u$ lies on a cycle within the predecessor graph for source $s$.\n\n- **Step 4.2: Trace the Cycle:** Once vertex $u$ is identified, the cycle itself is traced by starting at $u$ and repeatedly following the predecessors for source $s$ until $u$ is revisited. That is, we generate the sequence $v_0=u, v_1=P[s][v_0], v_2=P[s][v_1], \\dots, v_m=u$. This sequence of vertices represents the cycle in reverse path order.\n\n- **Step 4.3: Format the Output:** The directive requires outputting the list of vertex indices starting with $u$ and ending with a repeated $u$. This corresponds to the sequence $[v_0, v_1, \\dots, v_{m-1}, v_m]$, which is precisely the list generated by the tracing procedure.\n\n### Algorithmic Implementation\n\nThe overall program will first define the test cases as specified. For each test case, comprised of a weight matrix $W$ and an anchor vertex $s$, the following procedure is executed:\n\n1.  Initialize an $n \\times n$ distance matrix $D$ with the values from $W$, and an $n \\times n$ predecessor matrix $P$. For each $(i, j)$ where $W[i][j]  \\infty$, set $P[i][j] \\leftarrow i$. Other entries in $P$ are initialized to $-1$.\n2.  Execute the Floyd-Warshall algorithm with the predecessor update rule $P[i][j] \\leftarrow P[k][j]$ whenever the distance $D[i][j]$ is improved via vertex $k$.\n3.  After the loops complete, check if $D[s][s]  0$. If not, the result for this test case is an empty list, `[]`.\n4.  If $D[s][s]  0$, proceed with reconstruction:\n    a. Determine the cycle vertex $u$ by starting with $u \\leftarrow s$ and iterating $u \\leftarrow P[s][u]$ for $n$ times.\n    b. Trace the cycle by generating the sequence of vertices starting with $u$ and following the predecessors $P[s][\\cdot]$ until $u$ is reached again.\n    c. Format this sequence as a list of integers starting and ending with $u$.\n5.  Collect the results from all test cases and format them into a single-line string as specified.\n\nThis structured approach ensures correctness by strictly adhering to the established principles of the Floyd-Warshall algorithm and the explicit directives of the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_negative_cycle(W: np.ndarray, s: int) - list[int]:\n    \"\"\"\n    Uses the Floyd-Warshall algorithm to detect and reconstruct a negative cycle\n    associated with an anchor vertex.\n\n    Args:\n        W: The adjacency matrix of the graph.\n        s: The anchor vertex.\n\n    Returns:\n        A list of vertices representing the reconstructed negative cycle, starting\n        and ending with a specific vertex `u` on the cycle. Returns an empty\n        list if no such cycle is detected for the anchor.\n    \"\"\"\n    n = W.shape[0]\n\n    # Step 1: Initialize distance and predecessor matrices\n    dist = np.copy(W)\n    pred = np.full((n, n), -1, dtype=int)\n\n    for i in range(n):\n        for j in range(n):\n            if W[i, j] != np.inf:\n                pred[i, j] = i\n\n    # Step 2: Floyd-Warshall Algorithm\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dist[i, k] != np.inf and dist[k, j] != np.inf:\n                    if dist[i, k] + dist[k, j]  dist[i, j]:\n                        dist[i, j] = dist[i, k] + dist[k, j]\n                        pred[i, j] = pred[k, j]\n\n    # Step 3: Check for negative cycle at the anchor vertex\n    if dist[s, s] = 0:\n        return []\n\n    # Step 4: Reconstruct the negative cycle\n    # 4.1: Find a vertex 'u' that is part of the cycle.\n    # By repeatedly applying the predecessor function n times from s,\n    # we are guaranteed to land on a vertex within the cycle.\n    u = s\n    for _ in range(n):\n        if u == -1: # Predecessor path ended, should not happen if dist[s,s]  0\n            return []\n        u = pred[s, u]\n    \n    if u == -1: # This vertex must be on the cycle\n        return []\n\n    # 4.2: Trace the cycle starting from u by following predecessors.\n    # The problem asks for the sequence generated by following predecessors,\n    # which represents the cycle in reverse.\n    v = u\n    cycle = []\n    while True:\n        cycle.append(v)\n        v = pred[s, v]\n        if v == u:\n            break\n    \n    # 4.3: Add the starting vertex `u` to the end to close the cycle display\n    cycle.append(u)\n    \n    return cycle\n\ndef solve():\n    \"\"\"\n    Solves the problem for all given test cases and prints the final output.\n    \"\"\"\n    inf = np.inf\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([\n            [0, 2, inf, inf],\n            [inf, 0, -1, 2],\n            [-2, inf, 0, inf],\n            [inf, -2, inf, 0]\n        ]), 0), # s1=0\n        (np.array([\n            [0, inf, inf, 2],\n            [inf, 0, -3, inf],\n            [inf, inf, 0, 1],\n            [inf, 1, inf, 0]\n        ]), 2), # s2=2\n        (np.array([\n            [0, 1, inf],\n            [inf, 0, 1],\n            [1, inf, 0]\n        ]), 0), # s3=0\n        (np.array([\n            [0, inf, inf],\n            [inf, 0, inf],\n            [inf, inf, -1]\n        ]), 2), # s4=2\n        (np.array([\n            [0, 1, inf],\n            [1, 0, inf],\n            [inf, inf, -1]\n        ]), 0)  # s5=0\n    ]\n\n    results = []\n    for W, s in test_cases:\n        cycle_list = find_negative_cycle(W, s)\n        results.append(f\"[{','.join(map(str, cycle_list))}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3235685"}]}