{"hands_on_practices": [{"introduction": "The cornerstone of working with articulation points is knowing how to find them efficiently. This practice challenges you to implement the classic algorithm, which is a powerful application of Depth-First Search (DFS). By translating the theory of discovery times and low-link values into code, you will gain a concrete understanding of how the structure of a DFS tree reveals critical vertices in a graph. [@problem_id:3227552]", "problem": "You are given a family of undirected, simple graphs. An undirected, simple graph is a pair $G=(V,E)$ where $V$ is a finite set of vertices and $E\\subseteq \\{\\{u,v\\}\\mid u\\in V, v\\in V, u\\neq v\\}$ is a set of unordered pairs with no loops and no parallel edges. A connected component of $G$ is a maximal subset $C\\subseteq V$ such that for every pair of vertices $x,y\\in C$ there exists a path in $G$ whose endpoints are $x$ and $y$. A vertex $a\\in V$ is called an articulation point (also known as a cut vertex) if removing $a$ and all incident edges increases the number of connected components of the graph.\n\nYour task is to implement a program that uses Depth-First Search (DFS) to determine, for each given test graph $G$, the complete set of articulation points, reported as a sorted list of vertex indices in ascending order. Vertices are labeled by integers starting at $0$.\n\nFundamental base for reasoning and implementation:\n- The graph theoretic definitions of path, connectedness, and connected components.\n- The procedural definition of Depth-First Search (DFS) on a graph, which explores along edges by recursively visiting unvisited neighbors to construct a spanning forest that encodes reachability structure.\n- The logical effect of removing a vertex and its incident edges on paths and connected components.\n\nInput is not read from standard input. Instead, you must embed and process the following test suite inside your program. Each test case is specified by the number of vertices $n$ and an edge set $E$ described by unordered pairs $(u,v)$, where $u$ and $v$ are vertex indices.\n\nTest suite:\n- Test case $1$: $n=7$, $E=\\{(0,1),(1,2),(2,3),(1,3),(1,4),(4,5),(5,6)\\}$. This graph consists of a triangle on vertices $\\{1,2,3\\}$ with vertex $1$ connected to vertex $0$ and to a chain $1-4-5-6$.\n- Test case $2$: $n=5$, $E=\\{(0,1),(1,2),(2,3),(3,4),(4,0)\\}$. This graph is a single cycle on vertices $\\{0,1,2,3,4\\}$.\n- Test case $3$: $n=6$, $E=\\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$. This graph is a star centered at vertex $0$ with leaves $\\{1,2,3,4,5\\}$.\n- Test case $4$: $n=1$, $E=\\varnothing$. This graph has a single vertex and no edges.\n- Test case $5$: $n=2$, $E=\\{(0,1)\\}$. This graph is a single edge connecting two vertices.\n- Test case $6$: $n=6$, $E=\\{(0,1),(1,2),(2,0),(3,4),(4,5)\\}$. This graph has two components: a triangle on vertices $\\{0,1,2\\}$ and a path $3-4-5$.\n\nOutput specification:\n- For each test case, compute the list of all articulation points as a list of integers in ascending order.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each per-test-case result is itself a bracket-enclosed, comma-separated list of integers. For example, the overall output must have the form $[r_1,r_2,\\dots,r_k]$, where each $r_i$ is a list like $[v_1,v_2,\\dots]$. If a test case has no articulation points, output the empty list $[]$ for that case.", "solution": "The problem of identifying articulation points, or cut vertices, in an undirected graph is a classic application of Depth-First Search (DFS). An articulation point is a vertex whose removal increases the number of connected components in the graph. The solution presented here is based on a well-established linear-time algorithm, often attributed to John Hopcroft and Robert Tarjan.\n\nThe core idea is to perform a single DFS traversal of the graph, starting from an arbitrary vertex. During this traversal, we maintain two critical pieces of information for each vertex $u$:\n1. The discovery time, `disc[u]`, which is a timestamp recording when the vertex $u$ is first visited during the DFS. The timestamps are provided by a global counter that increments each time a new vertex is visited.\n2. The low-link value, `low[u]`, which is the lowest discovery time (i.e., the \"earliest\" vertex in the traversal) reachable from $u$ (including $u$ itself) by traversing zero or more edges of the DFS tree and at most one back edge. A back edge is an edge that connects a vertex to one of its ancestors in the DFS tree.\n\nThese two values allow us to detect the presence of structures that determine articulation points. Let the graph be $G=(V, E)$, with $|V|=n$ vertices labeled $0, 1, \\dots, n-1$.\n\nThe algorithm proceeds as follows:\n\nFirst, we initialize data structures:\n- An adjacency list representation for the graph $G$.\n- An array `disc` of size $n$, initialized to a sentinel value (e.g., $-1$) to indicate that no vertex has been discovered yet.\n- An array `low` of size $n$, also initialized to $-1$.\n- An array `parent` of size $n$, initialized to $-1$, to store the parent of each vertex in the DFS tree.\n- A global time counter, initialized to $0$.\n- A set to store the identified articulation points, to avoid duplicates.\n\nThe main part of the algorithm is a recursive DFS function, let's call it `FindAPs(u, p)`, which explores the graph starting from vertex $u$, whose parent in the DFS tree is $p$.\n\nWhen `FindAPs(u, p)` is called:\n1. We mark vertex $u$ as discovered by setting both its discovery time and low-link value to the current value of the global time counter, and then we increment the counter.\n$$disc[u] \\leftarrow \\text{time}$$\n$$low[u] \\leftarrow \\text{time}$$\n$$\\text{time} \\leftarrow \\text{time} + 1$$\n2. We set the parent of $u$ to $p$: `parent[u] = p`.\n3. We also initialize a counter `children` to $0$ for vertex $u$. This counter tracks the number of direct children of $u$ in the DFS tree.\n4. We iterate through each neighbor $v$ of $u$ in the adjacency list.\n    - If $v$ is the parent of $u$ (i.e., $v = p$), we ignore it and continue to the next neighbor.\n    - If $v$ has been discovered (i.e., $disc[v] \\neq -1$), the edge $(u, v)$ is a back edge. This edge provides a path from $u$ to an ancestor (or already visited node) $v$. We update the low-link value of $u$ to reflect this potential shortcut to an earlier part of the graph:\n    $$low[u] \\leftarrow \\min(low[u], disc[v])$$\n    - If $v$ has not been discovered, the edge $(u, v)$ is a tree edge. This means $v$ is a new child of $u$ in the DFS tree.\n        a. We increment the `children` counter for $u$.\n        b. We make a recursive call: `FindAPs(v, u)`.\n        c. After the recursive call returns, the entire subtree rooted at $v$ has been explored. The value `low[v]` now holds the lowest discovery time reachable from $v$. We use this to update the low-link value of $u$, as $u$ can reach everything $v$ can reach:\n        $$low[u] \\leftarrow \\min(low[u], low[v])$$\n        d. Now, we perform the crucial check to determine if $u$ is an articulation point. There are two distinct cases for this check.\n\nThe articulation point conditions are as follows:\n\n**Condition 1: The Root of a DFS Tree**\nA vertex $u$ is the root of a DFS tree if its parent `p` is the sentinel value (e.g., $-1$). The root of a DFS tree is an articulation point if and only if it has more than one child in the DFS tree. If the root has two or more children, removing the root would separate the subtrees rooted at these children into distinct connected components. This check is performed after the loop over all neighbors of the root is complete, using the `children` counter. If `p = -1` and `children > 1`, then $u$ is an articulation point.\n\n**Condition 2: A Non-Root Vertex**\nA vertex $u$ that is not the root of a DFS tree (i.e., $p \\neq -1$) is an articulation point if it has at least one child $v$ in the DFS tree such that the entire subtree rooted at $v$ (including $v$ itself) does not have a back edge to any ancestor of $u$. This condition is true if and only if the lowest discovery time reachable from $v$, which is `low[v]`, is greater than or equal to the discovery time of $u$.\n$$low[v] \\ge disc[u]$$\nIf this inequality holds, it means there is no path from the subtree of $v$ back to the \"upper\" part of the graph that bypasses $u$. Therefore, removing $u$ would disconnect the subtree of $v$ from the rest of the graph. This check is performed inside the loop for each child $v$ of $u$, right after the recursive call `FindAPs(v, u)` returns.\n\nTo handle graphs that may not be connected, the main procedure iterates through all vertices from $0$ to $n-1$. If a vertex $i$ has not been discovered yet (`disc[i] = -1`), a new DFS traversal is initiated from $i$ by calling `FindAPs(i, -1)`. This ensures that all connected components of the graph are processed.\n\nThe overall time complexity of this algorithm is $O(n+m)$, where $n$ is the number of vertices and $m$ is the number of edges, because it is based on a single DFS traversal of the entire graph. The space complexity is also $O(n+m)$ for storing the graph and the associated arrays.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass ArticulationPointFinder:\n    \"\"\"\n    A class to find all articulation points in an undirected graph using DFS.\n    \"\"\"\n    def __init__(self, n, edges):\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n        for u, v in edges:\n            self.graph[u].append(v)\n            self.graph[v].append(u)\n        \n        self.disc = [-1] * n\n        self.low = [-1] * n\n        self.parent = [-1] * n\n        self.articulation_points = set()\n        self.time = 0\n\n    def _find_aps_util(self, u):\n        \"\"\"\n        A recursive DFS utility function to find articulation points.\n        \"\"\"\n        self.disc[u] = self.low[u] = self.time\n        self.time += 1\n        children = 0\n\n        for v in self.graph[u]:\n            if v == self.parent[u]:\n                continue\n            \n            if self.disc[v] != -1:  # v is a visited vertex (back edge)\n                self.low[u] = min(self.low[u], self.disc[v])\n            else:  # v is an unvisited vertex (tree edge)\n                children += 1\n                self.parent[v] = u\n                self._find_aps_util(v)\n                \n                # After the DFS subtree rooted at v returns, update low of u\n                self.low[u] = min(self.low[u], self.low[v])\n                \n                # Condition 1: u is the root of DFS tree and has more than one child.\n                if self.parent[u] == -1 and children > 1:\n                    self.articulation_points.add(u)\n                \n                # Condition 2: u is not root and low value of one of its children is >= its discovery time.\n                if self.parent[u] != -1 and self.low[v] >= self.disc[u]:\n                    self.articulation_points.add(u)\n\n    def find_all(self):\n        \"\"\"\n        Finds all articulation points in the graph. Handles disconnected graphs.\n        \"\"\"\n        if self.n <= 1:\n            return []\n\n        for i in range(self.n):\n            if self.disc[i] == -1:\n                self._find_aps_util(i)\n                \n        return sorted(list(self.articulation_points))\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (7, [(0, 1), (1, 2), (2, 3), (1, 3), (1, 4), (4, 5), (5, 6)]),\n        # Test case 2\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]),\n        # Test case 3\n        (6, [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]),\n        # Test case 4\n        (1, []),\n        # Test case 5\n        (2, [(0, 1)]),\n        # Test case 6\n        (6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        finder = ArticulationPointFinder(n, edges)\n        aps = finder.find_all()\n        results.append(aps)\n\n    # Format output according to specification\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    # Fix spacing for empty lists and single-element lists\n    output_str = output_str.replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3227552"}, {"introduction": "A true master of an algorithm understands the \"why\" behind every step. This exercise moves beyond implementation to probe your conceptual understanding of the articulation point detection algorithm. By analyzing the specific condition $low[v] = disc[v]$, you will explore the deep connection between the algorithm's state variables and underlying graph-theoretic properties like bridges and connectivity. [@problem_id:3209677]", "problem": "Consider a simple, connected, undirected graph $G=(V,E)$. Perform a Depth-First Search (DFS) starting from a designated root $r \\in V$, assigning each vertex $u \\in V$ a discovery time $disc[u]$ that is strictly increasing with each first visit, and forming a DFS tree with parent pointers $parent(u)$ for all non-root vertices. In an undirected graph, a non-tree edge connecting a vertex to a strict ancestor in the DFS tree is called a back edge. For each vertex $u$, define $low[u]$ to be the minimum discovery time over all vertices reachable from $u$ by following a path that consists of $0$ or more tree edges going downwards in the DFS tree and then at most one back edge upwards in the tree. A vertex $a$ is an articulation point if removing $a$ (and its incident edges) increases the number of connected components. An edge $e$ is a bridge if removing $e$ increases the number of connected components.\n\nSuppose that for some vertex $v \\in V$ we observe $low[v] = disc[v]$.\n\nWhich of the following statements must hold? Select all that apply.\n\nA. $v$ is necessarily an articulation point.\n\nB. If $parent(v)$ exists, then the tree edge $\\big(parent(v), v\\big)$ is a bridge.\n\nC. There exists a back edge from $v$ or from some descendant of $v$ in the DFS tree to a proper ancestor of $v$.\n\nD. No vertex in the DFS subtree rooted at $v$ (including $v$) has a back edge to any proper ancestor of $v$.\n\nE. $parent(v)$ is necessarily an articulation point.", "solution": "The problem statement is first validated to ensure its scientific and logical integrity.\n\n### Step 1: Extract Givens\n- The graph $G=(V,E)$ is simple, connected, and undirected.\n- A Depth-First Search (DFS) is performed from a root $r \\in V$.\n- $disc[u]$: The discovery time of vertex $u$, strictly increasing with each first visit.\n- $parent(u)$: The parent of a non-root vertex $u$ in the DFS tree.\n- Back edge: A non-tree edge connecting a vertex to a strict ancestor in the DFS tree.\n- $low[u]$: The minimum discovery time over all vertices reachable from $u$ by a path of $0$ or more tree edges downwards and then at most one back edge upwards. This set of vertices consists of $u$ itself, and any vertex $w$ for which there exists a back edge $(x, w)$ where $x$ is in the DFS subtree rooted at $u$ (including $u$ itself). Mathematically, if $S_u$ is the set of vertices in the DFS subtree of $u$, then $low[u] = \\min (\\{disc[u]\\} \\cup \\{ disc[w] \\mid \\exists x \\in S_u, (x,w) \\text{ is a back edge} \\})$.\n- Articulation point: A vertex whose removal increases the number of connected components.\n- Bridge: An edge whose removal increases the number of connected components.\n- The central condition to analyze: For some vertex $v \\in V$, we have $low[v] = disc[v]$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem is based entirely on standard, well-established concepts and algorithms in graph theory, specifically related to connectivity, Depth-First Search, and the Tarjan's bridge-finding algorithm. All definitions are standard and correct.\n- **Well-Posed:** The problem asks for necessary logical consequences of a given condition ($low[v] = disc[v]$), which is a well-defined question with a unique set of correct answers.\n- **Objective:** The language is formal, precise, and devoid of any ambiguity or subjectivity.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. A full solution will be derived.\n\n### Derivation of Solution\n\nThe core of the problem lies in understanding the implication of the condition $low[v] = disc[v]$.\nThe value $low[v]$ is defined as the minimum discovery time reachable from the subtree of $v$ via at most one back edge. Formally:\n$$low[v] = \\min (\\{disc[v]\\} \\cup \\{ disc[w] \\mid \\exists u' \\in S_v, (u',w) \\text{ is a back edge} \\})$$\nwhere $S_v$ is the set of vertices in the DFS subtree rooted at $v$.\n\nThe given condition is $low[v] = disc[v]$. This means that the minimum value in the set on the right-hand side is $disc[v]$ itself. This implies that for any back edge $(u', w)$ originating from a vertex $u'$ in the subtree of $v$, the discovery time of its endpoint, $disc[w]$, must be greater than or equal to $disc[v]$.\n$$ \\forall u' \\in S_v, \\forall w \\in V, \\text{ if } (u', w) \\text{ is a back edge, then } disc[w] \\ge disc[v] $$\nA back edge $(u', w)$ connects $u'$ to a proper ancestor $w$. If $w$ were a proper ancestor of $v$, it would mean $w$ was discovered before $v$, so $disc[w] < disc[v]$. The condition $disc[w] \\ge disc[v]$ thus forbids any back edge from the subtree of $v$ to a proper ancestor of $v$. The only ancestors $w$ of $u'$ in the subtree of $v$ for which a back edge $(u',w)$ could potentially satisfy $disc[w] \\ge disc[v]$ are descendants of $v$ (including $v$ itself). However, an edge to a descendant is a forward edge, and an edge to $v$ from a descendant of $v$ is a tree edge, not a back edge. The edge could be $(u', v)$, but this would mean $v$ is a proper ancestor of $u'$, making $(u', v)$ a back edge. In this case, $disc[v] \\ge disc[v]$, which is not a contradiction.\n\nThe crucial consequence of $low[v] = disc[v]$ is that there is no back edge from any vertex in the subtree of $v$ (including $v$) to any vertex that is a *proper ancestor* of $v$. If such a back edge $(u', w)$ existed, where $w$ is a proper ancestor of $v$, then $disc[w] < disc[v]$. This would imply $low[v] \\le disc[w] < disc[v]$, a contradiction.\n\nWe now evaluate each option based on this core insight.\n\n**A. $v$ is necessarily an articulation point.**\n\nA vertex $v$ is an articulation point if its removal increases the number of connected components. According to the properties of DFS, a non-root vertex $v$ is an articulation point if and only if it has a child $w$ such that $low[w] \\ge disc[v]$. If $v$ is the root, it's an articulation point if it has more than one child.\n\nThe condition $low[v] = disc[v]$ does not guarantee that $v$ is an articulation point. Consider a graph represented by a simple path $r-p-v$. Let the DFS start from $r$. The DFS tree will be $r \\to p \\to v$. Here, $v$ is a leaf of the DFS tree. A leaf vertex in a connected graph with more than $2$ vertices can never be an articulation point. For this leaf vertex $v$, it has no children, so there are no back edges from its (empty) set of descendants. Its own low-link value is determined by its own discovery time and any back edges from $v$ itself. With no back edges, $low[v] = disc[v]$. The premise holds, but $v$ is not an articulation point.\n\nVerdict for A: **Incorrect**.\n\n**B. If $parent(v)$ exists, then the tree edge $\\big(parent(v), v\\big)$ is a bridge.**\n\nAn edge in a connected graph is a bridge if its removal increases the number of connected components. For a tree edge $(u, w)$ in a DFS tree, where $u = parent(w)$, this edge is a bridge if and only if $low[w] > disc[u]$.\n\nLet $p = parent(v)$. The statement concerns the tree edge $(p,v)$. We must check if the condition for this edge being a bridge, which is $low[v] > disc[p]$, holds.\nWe are given $low[v] = disc[v]$.\nSince $p$ is the parent of $v$ in the DFS tree, $v$ must have been discovered after $p$. Therefore, $disc[v] > disc[p]$.\nCombining these, we get $low[v] = disc[v] > disc[p]$.\nThis satisfies the condition $low[v] > disc[p]$. Thus, the edge $(p, v)$ must be a bridge. The logic is that the subtree at $v$ has no other connection (via a back edge) to the part of the graph containing $p$ and its ancestors, so the edge $(p,v)$ is the only connection.\n\nVerdict for B: **Correct**.\n\n**C. There exists a back edge from $v$ or from some descendant of $v$ in the DFS tree to a proper ancestor of $v$.**\n\nThis statement claims that there is a back edge $(u', w)$ where $u'$ is in the subtree of $v$ and $w$ is a proper ancestor of $v$. As established in our initial analysis, the existence of such an edge would imply $disc[w] < disc[v]$. By the definition of the low-link value, we would have $low[v] \\le disc[w]$. This leads to the inequality $low[v] < disc[v]$, which directly contradicts the given condition $low[v] = disc[v]$. Therefore, such a back edge cannot exist. This statement is the exact opposite of what the given condition implies.\n\nVerdict for C: **Incorrect**.\n\n**D. No vertex in the DFS subtree rooted at $v$ (including $v$) has a back edge to any proper ancestor of $v$.**\n\nThis statement is the negation of statement C. As proven in the analysis of C, the condition $low[v] = disc[v]$ logically requires that no back edge connects the subtree of $v$ to any proper ancestor of $v$. To reiterate: suppose such a back edge $(u', w)$ existed, with $u' \\in S_v$ and $w$ a proper ancestor of $v$. Then $disc[w] < disc[v]$. The reachability of $w$ from the subtree $S_v$ implies $low[v] \\le disc[w]$. This would mean $low[v] < disc[v]$, a contradiction. Thus, the statement must be true.\n\nVerdict for D: **Correct**.\n\n**E. $parent(v)$ is necessarily an articulation point.**\n\nLet $p = parent(v)$. For $p$ to be an articulation point, one of two conditions must be met: ($1$) $p$ is the root of the DFS tree and has more than one child, or ($2$) $p$ is not the root and has at least one child $w$ such that $low[w] \\ge disc[p]$.\n\nFrom our analysis for option B, we know that $low[v] = disc[v] > disc[p]$, so the condition $low[v] \\ge disc[p]$ is satisfied. If $p$ is not the root of the DFS tree, this condition is sufficient to make $p$ an articulation point.\n\nHowever, consider the case where $p$ is the root of the DFS tree. Let $p=r$. For $r$ to be an articulation point, it must have more than one child. The problem does not preclude the possibility that $v$ is the *only* child of the root $r$. For example, consider a path graph $r-v-c$. DFS starts at $r$. The DFS tree is $r \\to v \\to c$. The parents are $parent(v)=r$ and $parent(c)=v$.\n- $low[c]=disc[c]$.\n- $low[v] = \\min(disc[v], low[c]) = disc[v]$.\nThe premise $low[v] = disc[v]$ holds.\nThe parent of $v$ is $p=r$. Is $r$ an articulation point? No. Since $r$ is the root and has only one child ($v$), removing $r$ leaves the component $v-c$, so the number of connected components does not increase from $1$. Therefore, $p=r$ is not an articulation point in this case. This provides a counterexample.\n\nVerdict for E: **Incorrect**.", "answer": "$$\\boxed{BD}$$", "id": "3209677"}, {"introduction": "Identifying network vulnerabilities is crucial, but the ultimate goal is often to eliminate them. This final practice elevates the concept of articulation points to a network design problem: how can we add the minimum number of links to make a network robust against any single-node failure? Solving this requires you to synthesize your knowledge to reason about the graph's high-level structure of blocks and cuts, demonstrating the practical power of this analysis. [@problem_id:3209569]", "problem": "Let $G=(V,E)$ be a finite, simple, undirected, connected graph with $|V|=n$ and $|E|=m$, where $n \\ge 3$. A vertex $v \\in V$ is an articulation point if the removal of $v$ (and all incident edges) increases the number of connected components of the graph. A graph is biconnected (two-vertex-connected) if it is connected and has no articulation points. You are to write a complete, runnable program that, for each graph in the provided test suite, computes the minimum number of edges that must be added between currently non-adjacent distinct vertices to make the graph biconnected, without creating parallel edges or self-loops.\n\nYour program must construct its answer from first principles using the core definitions of articulation points and biconnected components, and well-tested algorithmic facts such as the existence of Depth-First Search (DFS) tree structures and low-link values. The program must not rely on pre-specified shortcut formulas; instead, it must identify articulation points and biconnected components, reason about the block-cut tree induced by these components and articulation points, and deduce the minimal number of edges to add.\n\nThe test suite consists of $6$ connected graphs, each specified by its number of vertices $n$ and its edge set $E$ (all vertices are labeled by integers from $0$ to $n-1$):\n\n- Test case $1$: $n=5$, $E=\\{(0,1),(1,2),(2,3),(3,4),(4,0)\\}$ (a cycle on $5$ vertices).\n- Test case $2$: $n=4$, $E=\\{(0,1),(1,2),(2,3)\\}$ (a path on $4$ vertices).\n- Test case $3$: $n=7$, $E=\\{(0,1),(0,2),(0,3),(0,4),(0,5),(0,6)\\}$ (a star with center $0$ and $6$ leaves).\n- Test case $4$: $n=5$, $E=\\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,2)\\}$ (two triangles sharing a single vertex).\n- Test case $5$: $n=6$, $E=\\{(0,1),(1,2),(2,3),(3,0),(1,4),(4,5)\\}$ (a cycle with a length-$2$ tail attached to one cycle vertex).\n- Test case $6$: $n=6$, $E=\\{(0,1),(1,2),(1,3),(3,4),(3,5)\\}$ (a tree with internal vertices $1$ and $3$).\n\nYour program should produce a single line of output containing the results for the six test cases in order, formatted as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3,r_4,r_5,r_6]$, where each $r_i$ is an integer giving the minimal number of edges to add for test case $i$.", "solution": "The problem has been validated and is deemed a well-posed, scientifically grounded problem in the field of graph theory. The givens are complete, consistent, and formalizable.\n\n### Principle-Based Solution Design\n\nThe core task is to determine the minimum number of edges to add to a connected graph $G$ to make it biconnected. A graph is biconnected if and only if it is connected and contains no articulation points. An articulation point (or cut vertex) is a vertex whose removal increases the number of connected components of the graph.\n\n#### 1. The Block-Cut Tree Structure\n\nThe problem can be analyzed by considering the graph's structure in terms of its biconnected components (BCCs or blocks) and articulation points. The relationship between these entities can be modeled by a **block-cut tree**, $T_{BC}$.\n- The vertices of $T_{BC}$ correspond to the articulation points and the BCCs of the original graph $G$.\n- An edge exists in $T_{BC}$ between an articulation point vertex $v_{ap}$ and a block vertex $B$ if and only if the vertex corresponding to $v_{ap}$ is a member of the block $B$ in $G$.\n- For any connected graph $G$, its corresponding block-cut structure $T_{BC}$ is a tree.\n\nMaking the original graph $G$ biconnected is equivalent to transforming its block-cut tree $T_{BC}$ into a single node. This conceptual transformation occurs when all original biconnected components and articulation points are merged into a single, large biconnected component.\n\n#### 2. Strategy: Connecting Leaf Blocks\n\nThe \"weak points\" of the graph's connectivity are its \"dangling\" components. In the block-cut tree, these are represented by leaf nodes. Since any path in a tree must connect two leaf nodes (or be a single node), leaf nodes in $T_{BC}$ are always block-vertices (assuming the tree is not trivial). A block $B$ is a leaf in $T_{BC}$ if it contains exactly one articulation point of $G$. We shall call these **leaf blocks**.\n\nTo eliminate articulation points, we must introduce new paths between parts of the graph that are separated by them. The most efficient way to do this is to add edges between vertices of distinct leaf blocks. Adding a single edge between a vertex in a leaf block $B_1$ and a vertex in another leaf block $B_2$ creates a new cycle in $G$. This has the effect of merging $B_1$, $B_2$, and the entire path of blocks and articulation points between them in $T_{BC}$ into a single, larger biconnected component.\n\nThis operation effectively reduces the number of leaves in the conceptual block-cut tree. If we have $l$ leaf blocks, we can pair them up. An edge added between each pair reduces the number of leaves by two. The minimum number of edges required to connect all $l$ leaves into a single super-component is $\\lceil l/2 \\rceil$.\n\n- If the graph is already biconnected, it consists of a single block and has no articulation points. In this case, the number of leaf blocks is $l=0$, and the formula correctly yields $\\lceil 0/2 \\rceil = 0$.\n- If the graph is not biconnected, it must have at least one articulation point and thus at least two leaf blocks ($l \\ge 2$).\n\n#### 3. Algorithmic Implementation\n\nThe overall algorithm is as follows:\n\n**Step 1: Find Articulation Points and Biconnected Components**\nThis is the central part of the algorithm, executed using a single Depth-First Search (DFS) traversal. For each vertex $u \\in V$, we maintain two values:\n- $disc[u]$: The discovery time of $u$ during the DFS, i.e., the \"time\" (a counter) when $u$ is first visited.\n- $low[u]$: The lowest discovery time reachable from $u$ (including through its own DFS subtree) by traversing zero or more tree edges and at most one back-edge.\n\nAn edge stack is used to keep track of the edges of the BCCs. During the DFS from a vertex $u$ to its neighbor $v$:\n- A vertex $u$ is identified as an articulation point if it is the root of the DFS tree and has more than one child, or if it is not the root and has a child $v$ for which $low[v] \\ge disc[u]$.\n- This same condition, $low[v] \\ge disc[u]$, signals that a BCC has just been fully traversed. The edges of this BCC are on top of the edge stack and can be popped off until the edge $(u,v)$ is removed. The set of all vertices from these popped edges constitutes the BCC.\n\n**Step 2: Count Leaf Blocks**\nAfter the DFS completes and all articulation points and BCCs have been identified, we count the number of leaf blocks, $l$. A BCC is a leaf block if the number of its vertices that are articulation points of the main graph is exactly one.\n\n**Step 3: Calculate Minimum Edges**\nThe minimum number of edges to add is given by the formula $\\lceil l / 2 \\rceil$. This can be computed using integer arithmetic as $(l + 1) // 2$. If the graph is already biconnected, the algorithm will find only a single BCC and no articulation points, resulting in $l=0$ and an answer of $0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the biconnectivity augmentation problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1: n=5, a cycle graph\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]),\n        # Test case 2: n=4, a path graph\n        (4, [(0, 1), (1, 2), (2, 3)]),\n        # Test case 3: n=7, a star graph\n        (7, [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6)]),\n        # Test case 4: n=5, two triangles sharing a vertex\n        (5, [(0, 1), (1, 2), (2, 0), (2, 3), (3, 4), (4, 2)]),\n        # Test case 5: n=6, a cycle with a tail\n        (6, [(0, 1), (1, 2), (2, 3), (3, 0), (1, 4), (4, 5)]),\n        # Test case 6: n=6, a tree\n        (6, [(0, 1), (1, 2), (1, 3), (3, 4), (3, 5)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        solver = BiconnectivityAugmenter(n, edges)\n        result = solver.compute_min_edges()\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nclass BiconnectivityAugmenter:\n    \"\"\"\n    A class to find the minimum number of edges to make a graph biconnected.\n    \"\"\"\n    def __init__(self, n, edges):\n        self.n = n\n        self.adj = [[] for _ in range(n)]\n        for u, v in edges:\n            self.adj[u].append(v)\n            self.adj[v].append(u)\n        \n        # State for the BCC algorithm\n        self.time = 0\n        self.disc = [-1] * n\n        self.low = [-1] * n\n        self.edge_stack = []\n        \n        self.articulation_points = set()\n        self.bccs = []\n\n    def _find_aps_and_bccs(self, u, p):\n        \"\"\"\n        Recursive DFS utility to find articulation points and biconnected components.\n        'u' is the current vertex, 'p' is its parent in the DFS tree.\n        \"\"\"\n        self.disc[u] = self.low[u] = self.time\n        self.time += 1\n        children = 0\n\n        for v in self.adj[u]:\n            if v == p:\n                continue\n\n            if self.disc[v] != -1:  # Visited vertex, so a back edge\n                self.low[u] = min(self.low[u], self.disc[v])\n                if self.disc[v] < self.disc[u]:\n                    self.edge_stack.append((u, v))\n            else:  # Not visited, so a tree edge\n                children += 1\n                self.edge_stack.append((u, v))\n                self._find_aps_and_bccs(v, u)\n                \n                self.low[u] = min(self.low[u], self.low[v])\n\n                # Check for articulation point u\n                if (p == -1 and children > 1) or (p != -1 and self.low[v] >= self.disc[u]):\n                    self.articulation_points.add(u)\n                \n                # If low[v] >= disc[u], u is an AP and a new BCC is found\n                if self.low[v] >= self.disc[u]:\n                    new_bcc_edges = []\n                    while True:\n                        edge = self.edge_stack.pop()\n                        new_bcc_edges.append(edge)\n                        if edge == (u, v) or edge == (v, u):\n                            break\n                    \n                    bcc_nodes = set()\n                    for n1, n2 in new_bcc_edges:\n                        bcc_nodes.add(n1)\n                        bcc_nodes.add(n2)\n                    self.bccs.append(bcc_nodes)\n\n    def compute_min_edges(self):\n        \"\"\"\n        Computes the minimum number of edges to add to make the graph biconnected.\n        \"\"\"\n        # A connected graph with n < 3 is always biconnected.\n        if self.n < 3:\n            return 0\n            \n        # Run DFS from vertex 0. The graph is connected, so one run is sufficient.\n        self._find_aps_and_bccs(0, -1)\n\n        # If the whole graph is one BCC, the stack will not be empty.\n        if self.edge_stack:\n            bcc_nodes = set()\n            for u, v in self.edge_stack:\n                bcc_nodes.add(u)\n                bcc_nodes.add(v)\n            self.bccs.append(bcc_nodes)\n            self.edge_stack.clear()\n        \n        # If there are no articulation points, the graph is already biconnected.\n        # This is equivalent to having 0 or 1 BCCs.\n        if len(self.bccs) <= 1:\n            return 0\n\n        # Count leaf blocks: BCCs with exactly one articulation point.\n        leaf_blocks = 0\n        for bcc in self.bccs:\n            ap_count_in_bcc = 0\n            for node in bcc:\n                if node in self.articulation_points:\n                    ap_count_in_bcc += 1\n            if ap_count_in_bcc == 1:\n                leaf_blocks += 1\n        \n        # The number of edges to add is ceil(number of leaf blocks / 2).\n        return int(np.ceil(leaf_blocks / 2))\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3209569"}]}