{"hands_on_practices": [{"introduction": "The best way to truly understand a complex algorithm is to build it from the ground up. This practice challenges you to implement one of the foundational linear-time algorithms for finding Strongly Connected Components (SCCs), such as Kosaraju's or Tarjan's. By translating the algorithm's steps into code and testing it against various graph structures, you will gain a concrete understanding of how multiple Depth-First Search (DFS) traversals and clever data structures work together to efficiently partition a graph [@problem_id:3205772].", "problem": "Design and specify a complete algorithm to compute all Strongly Connected Components (SCCs) of a directed graph, and prove its correctness from first principles of graph reachability and Depth-First Search (DFS). You must implement the algorithm as a runnable program that outputs canonicalized SCCs for a fixed set of test graphs. Your algorithm must be either Kosaraju’s algorithm or Tarjan’s algorithm; you must make one precise choice and present a full pseudo-code specification for it.\n\nFoundational base and definitions to be used as the starting point:\n- A directed graph is an ordered pair $G=(V,E)$ where $V$ is a finite set of vertices labeled by consecutive integers $0,\\dots,n-1$ for some integer $n \\ge 0$, and $E \\subseteq V \\times V$ is a set of directed edges.\n- For $u,v \\in V$, there is a path from $u$ to $v$ if there exists a sequence of vertices $u=x_0,x_1,\\dots,x_k=v$ with $k \\ge 0$ and $(x_i,x_{i+1}) \\in E$ for all $i \\in \\{0,\\dots,k-1\\}$.\n- A subset $C \\subseteq V$ is a strongly connected component if for all $u,v \\in C$ there is a path from $u$ to $v$ and a path from $v$ to $u$, and $C$ is maximal with respect to set inclusion under this property.\n- Depth-First Search (DFS) explores paths by recursively visiting unvisited out-neighbors, and every edge $(u,v)$ is either a tree edge, back edge, forward edge, or cross edge under the standard DFS classification. The DFS finishing time of a vertex is the time it is fully explored and added to a finishing-order stack. The transpose graph $G^T=(V,E^T)$ has $E^T=\\{(v,u)\\mid (u,v)\\in E\\}$.\n- The condensation (component) graph of $G$ contracts each strongly connected component to a single vertex, yielding a Directed Acyclic Graph (DAG).\n\nYour tasks:\n1. Choose one of Kosaraju’s algorithm or Tarjan’s algorithm and provide precise, language-agnostic pseudo-code that takes as input a directed graph $G=(V,E)$ given as an adjacency list $Adj[0..n-1]$, where $Adj[u]$ enumerates all $v$ such that $(u,v)\\in E$. All intermediate variables, function names, and numbers must be written using LaTeX notation.\n2. Derive the algorithm’s correctness from first principles. Start from the above foundational definitions and well-tested facts about DFS and transpose graphs, and explain why the algorithm partitions $V$ into SCCs. Your reasoning must not rely on any unproven shortcut statements and must articulate the invariants that guarantee correctness.\n3. Analyze the running time in terms of $n=|V|$ and $m=|E|$, and state space usage.\n4. Canonicalization requirement for deterministic output: For every SCC $C$, output its vertices sorted in ascending order. For the collection of all SCCs, output the list sorted in lexicographic order of these sorted vertex lists. For the empty graph with $n=0$, the output is the empty list.\n5. Implementation requirement: Implement your chosen algorithm as a complete program that takes no input and instead runs on the following fixed test suite (graphs are given by $n$ and an adjacency list). Vertices are labeled $0$ through $n-1$.\n- Test $1$: $n=8$, edges $\\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,5),(5,3),(6,7)\\}$. Adjacency list: $Adj = [[1],[2],[0,3],[4],[5],[3],[7],[]]$.\n- Test $2$: $n=0$, edges $\\emptyset$. Adjacency list: $Adj = []$.\n- Test $3$: $n=1$, edges $\\emptyset$. Adjacency list: $Adj = [[]]$.\n- Test $4$: $n=1$, edges $\\{(0,0)\\}$. Adjacency list: $Adj = [[0]]$.\n- Test $5$: $n=5$, edges $\\{(0,1),(1,2),(2,3),(3,4),(4,0),(0,2),(1,3),(2,4),(3,0),(4,1)\\}$. Adjacency list: $Adj = [[1,2],[2,3],[3,4],[4,0],[0,1]]$.\n- Test $6$: $n=6$, edges $\\{(0,1),(1,2),(3,4),(4,5)\\}$. Adjacency list: $Adj = [[1],[2],[],[4],[5],[]]$.\n\nFinal output format:\n- Your program must produce exactly one line to standard output. The line must be a single bracketed list of the results for Tests $1$ through $6$, in order. Each result is itself a list of lists of integers, canonicalized as specified. The entire line must be a single string of the form $[r_1,r_2,r_3,r_4,r_5,r_6]$, where each $r_i$ is the canonicalized list of SCCs for Test $i$. No explanatory text may be printed.\n- Answers are pure lists of integers; there are no physical units or angle units involved.", "solution": "The problem of computing Strongly Connected Components (SCCs) of a directed graph is a fundamental task in graph theory and computer science. The problem statement is valid, as it is based on standard, well-defined mathematical concepts, is self-contained, and poses a well-posed question with objective criteria for the solution. I will select Kosaraju's algorithm for its conceptual clarity, which relies on two sequential applications of Depth-First Search (DFS).\n\nKosaraju's algorithm operates in three main stages:\n1.  Perform a DFS traversal on the input graph $G=(V,E)$ to determine the finishing times of all vertices. The vertices are stored in a data structure (e.g., a stack or list) in the order they finish.\n2.  Compute the transpose graph $G^T=(V,E^T)$, where $E^T = \\{ (v,u) \\mid (u,v) \\in E \\}$.\n3.  Perform a second DFS traversal on the transpose graph $G^T$. The main loop of this DFS considers vertices in decreasing order of their finishing times as computed in the first stage. Each tree in the resulting DFS forest corresponds to a distinct Strongly Connected Component.\n\nI will now provide the formal pseudo-code, derive its correctness from first principles, and analyze its complexity.\n\n**1. Pseudo-code for Kosaraju's Algorithm**\n\nLet the input graph be $G=(V,E)$ with $|V|=n$ and $|E|=m$, represented by an adjacency list $Adj$.\n\nThe main procedure is `KOSARAJU`. It uses two helper procedures, `DFS_PASS1` and `DFS_PASS2`.\n\n`Global Variables:`\n- $visited$: A boolean array of size $n$, initialized to $false$.\n- $F$: A list or stack to store vertices in finishing order.\n\n`Procedure KOSARAJU(G=(V,E))`:\n1. For each vertex $u \\in V$:\n2.     $visited[u] \\leftarrow false$\n3. $F \\leftarrow \\text{empty list}$\n4. For each vertex $u \\in V$:\n5.     If not $visited[u]$:\n6.         `DFS_PASS1(G, u)`\n7. Compute $G^T$ from $G$.\n8. For each vertex $u \\in V$:\n9.     $visited[u] \\leftarrow false$\n10. $SCCs \\leftarrow \\text{empty list of lists}$\n11. While $F$ is not empty:\n12.     $u \\leftarrow F.\\text{pop}()$ (get vertex with latest finishing time)\n13.     If not $visited[u]$:\n14.         $component \\leftarrow \\text{empty list}$\n15.         `DFS_PASS2(G^T, u, component)`\n16.         Append $component$ to $SCCs$.\n17. Return $SCCs$.\n\n`Procedure DFS_PASS1(G, u)`:\n1. $visited[u] \\leftarrow true$\n2. For each neighbor $v$ of $u$ in $G$:\n3.     If not $visited[v]$:\n4.         `DFS_PASS1(G, v)`\n5. Push $u$ onto the front of list $F$.\n\n`Procedure DFS_PASS2(G^T, u, component)`:\n1. $visited[u] \\leftarrow true$\n2. Add $u$ to $component$.\n3. For each neighbor $v$ of $u$ in $G^T$:\n4.     If not $visited[v]$:\n5.         `DFS_PASS2(G^T, v, component)`\n\n**2. Proof of Correctness**\n\nThe correctness of Kosaraju's algorithm hinges on a fundamental property of the condensation graph and DFS finishing times. The condensation graph, $G^{SCC}$, is formed by contracting each SCC of $G$ into a single super-vertex. An edge exists from super-vertex $S_i$ to $S_j$ in $G^{SCC}$ if there is an edge in $G$ from some vertex $u \\in C_i$ to some vertex $v \\in C_j$, where $C_i$ and $C_j$ are the SCCs corresponding to $S_i$ and $S_j$. By definition of SCCs, $G^{SCC}$ is a Directed Acyclic Graph (DAG).\n\nLet $\\text{f}(u)$ denote the finishing time of vertex $u$ in the first DFS pass on $G$. Let $\\text{f}_{\\max}(C) = \\max_{u \\in C} \\{\\text{f}(u)\\}$ for any SCC $C \\subseteq V$.\n\n**Core Lemma:** If $C_1$ and $C_2$ are two distinct SCCs in $G$ and there exists an edge $(u,v) \\in E$ with $u \\in C_1$ and $v \\in C_2$, then $\\text{f}_{\\max}(C_1) > \\text{f}_{\\max}(C_2)$.\n\n**Proof of Lemma:**\nWe consider two cases for the first DFS pass on $G$.\n- **Case 1:** The DFS first visits a vertex in $C_2$ before visiting any vertex in $C_1$. Let $x \\in C_2$ be the first vertex visited in $C_2$. The DFS traversal starting from $x$ will explore all vertices reachable from $x$. Since all vertices in $C_2$ are mutually reachable, they will all be visited as part of the DFS tree rooted at $x$ (or one of its descendants within $C_2$). Because there is no path from any vertex in $C_2$ back to any vertex in $C_1$ (otherwise they would be part of the same SCC), the DFS from $x$ will not visit any vertex in $C_1$. Therefore, all vertices in $C_2$ will be explored and will finish before the traversal of the subtree containing them finishes. Specifically, all vertices in $C_2$ finish before $x$ finishes. Since no vertex in $C_1$ has been visited yet, all vertices in $C_1$ will start and finish after all vertices in $C_2$ have finished. Thus, $\\text{f}_{\\max}(C_1) > \\text{f}_{\\max}(C_2)$.\n- **Case 2:** The DFS first visits a vertex in $C_1$ before visiting any vertex in $C_2$. Let $x \\in C_1$ be the first vertex visited in $C_1$. The DFS from $x$ will explore all vertices reachable from $x$. This includes all vertices in $C_1$ (by definition of SCC) and, due to the edge $(u, v)$ and paths within $C_1$, all vertices in $C_2$. Therefore, the entire component $C_2$ will be contained within the DFS subtree rooted at $x$. In a DFS, any vertex in a subtree finishes before the root of that subtree finishes. Thus, all vertices in $C_2$ will have finishing times less than $\\text{f}(x)$. Since $x \\in C_1$, we have $\\text{f}_{\\max}(C_2) < \\text{f}(x) \\le \\text{f}_{\\max}(C_1)$.\n\nIn both cases, the lemma holds.\n\n**Main Argument:**\nThe second phase of the algorithm performs a DFS on the transpose graph $G^T$, processing vertices in decreasing order of their finishing time $\\text{f}(u)$ from the first pass.\n\nLet $s$ be the vertex with the highest finishing time in all of $V$. Let $C_s$ be the SCC containing $s$. According to the Core Lemma, if there were an edge in $G$ from another SCC, say $C'$, to $C_s$, then it would imply $\\text{f}_{\\max}(C') > \\text{f}_{\\max}(C_s)$. But $s$ has the maximum finishing time overall, so $\\text{f}_{\\max}(C_s)$ must be the maximum over all SCCs. This is a contradiction. Therefore, there can be no edges in $G$ from any other SCC to $C_s$. This means $C_s$ is a \"sink component\" in the condensation graph $G^{SCC}$.\n\nIn the transpose graph $G^T$, all edges between components are reversed. An edge $(u,v)$ in $G$ with $u \\in C_i, v \\in C_j$ becomes $(v,u)$ in $G^T$. Thus, a sink component in $G^{SCC}$ becomes a \"source component\" in the condensation graph of $G^T$. There are no edges in $G^T$ from any other SCC *to* $C_s$.\n\nWhen the second DFS begins on $G^T$ with the vertex $s$, it can reach all other vertices in $C_s$ because they are mutually reachable in $G$ and thus also in $G^T$. However, it cannot reach any vertex outside of $C_s$, because this would imply an edge in $G^T$ from a vertex in $C_s$ to a vertex in another component, which we have just shown is impossible. Therefore, the first DFS tree found in the second pass consists of exactly the vertices of the SCC $C_s$.\n\nAfter this first SCC is identified, its vertices are marked as visited. The algorithm then picks the unvisited vertex with the highest remaining finishing time. This vertex belongs to an SCC which is a sink component in the subgraph of $G$ induced by the remaining unvisited vertices. The same argument applies recursively. This process continues, correctly partitioning the entire vertex set $V$ into its Strongly Connected Components. Each call to `DFS_PASS2` from the main loop of `KOSARAJU` identifies exactly one SCC.\n\n**3. Complexity Analysis**\n\n- **Time Complexity:**\n    1. The first DFS pass (`DFS_PASS1`) visits each vertex and each edge of $G$ exactly once. Its running time is $O(n+m)$.\n    2. The computation of the transpose graph $G^T$ requires iterating through all edges of $G$, taking $O(m)$ time to build the new adjacency list, or $O(n+m)$ to initialize and build it.\n    3. The second DFS pass (`DFS_PASS2`) visits each vertex and each edge of $G^T$ exactly once. The number of vertices is $n$ and edges is $m$. Its running time is $O(n+m)$.\n    The total time complexity is the sum of these steps, which is $O(n+m) + O(n+m) + O(n+m) = O(n+m)$.\n\n- **Space Complexity:**\n    1. Storing the graph $G$ and its transpose $G^T$ as adjacency lists requires $O(n+m)$ space.\n    2. The $visited$ array requires $O(n)$ space.\n    3. The list $F$ to store finishing order requires $O(n)$ space.\n    4. The recursion stack for the DFS procedures can go up to depth $n$ in the worst case (e.g., a path graph), requiring $O(n)$ space.\n    The total space complexity is dominated by the storage of the graphs, resulting in $O(n+m)$.\n\n**4. Canonicalization**\n\nThe specified canonicalization requires two levels of sorting.\n1.  For each identified SCC, the list of its vertex indices must be sorted in ascending order.\n2.  The final list of all SCCs must be sorted lexicographically. This means, for two SCCs represented as sorted lists $C_1$ and $C_2$, $C_1$ comes before $C_2$ if $C_1$ is lexicographically smaller than $C_2$.\n\nThese sorting steps are applied after the core algorithm has identified the components. The complexity of sorting is not dominant. If there are $k$ SCCs, with $|C_i|$ being the size of the $i$-th component, sorting all of them takes $\\sum_{i=1}^{k} O(|C_i| \\log |C_i|)$, which is bounded by $O(n \\log n)$. Sorting the final list of $k$ components is negligible in comparison. The overall $O(n+m)$ complexity remains dominant for typical graphs.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\nimport numpy as np\n\n# It is good practice to increase the recursion limit for deep graphs in Python DFS.\n# The test cases here are small, but this makes the implementation robust.\nsys.setrecursionlimit(200000)\n\ndef solve():\n    \"\"\"\n    Main function to run Kosaraju's algorithm on a fixed set of test cases\n    and print the results in the specified canonical format.\n    \"\"\"\n\n    # Test cases defined as tuples of (n, adjacency_list)\n    test_cases = [\n        # Test 1: Two SCCs {0,1,2} and {3,4,5}, and two trivial ones {6}, {7}\n        (8, [[1], [2], [0, 3], [4], [5], [3], [7], []]),\n        # Test 2: Empty graph\n        (0, []),\n        # Test 3: Single vertex, no edges\n        (1, [[]]),\n        # Test 4: Single vertex, self-loop\n        (1, [[0]]),\n        # Test 5: Fully connected component\n        (5, [[1, 2], [2, 3], [3, 4], [4, 0], [0, 1]]),\n        # Test 6: Two disjoint paths, all vertices are trivial SCCs\n        (6, [[1], [2], [], [4], [5], []]),\n    ]\n    \n    final_results = []\n\n    for n, adj in test_cases:\n        if n == 0:\n            final_results.append(\"[]\")\n            continue\n\n        # --- Kosaraju's Algorithm ---\n        \n        # Step 1: First DFS pass on G to compute finishing order\n        visited = [False] * n\n        finish_stack = []\n        \n        def dfs1(u):\n            visited[u] = True\n            for v in adj[u]:\n                if not visited[v]:\n                    dfs1(v)\n            finish_stack.append(u)\n\n        for i in range(n):\n            if not visited[i]:\n                dfs1(i)\n        \n        # Step 2: Compute the transpose graph G^T\n        adj_t = [[] for _ in range(n)]\n        for u in range(n):\n            for v in adj[u]:\n                adj_t[v].append(u)\n\n        # Step 3: Second DFS pass on G^T in decreasing order of finishing times\n        visited = [False] * n\n        sccs = []\n        \n        def dfs2(u, current_scc):\n            visited[u] = True\n            current_scc.append(u)\n            for v in adj_t[u]:\n                if not visited[v]:\n                    dfs2(v, current_scc)\n\n        while finish_stack:\n            u = finish_stack.pop()\n            if not visited[u]:\n                current_scc = []\n                dfs2(u, current_scc)\n                # Canonicalization Step 1: Sort vertices within the SCC\n                current_scc.sort()\n                sccs.append(current_scc)\n        \n        # Canonicalization Step 2: Sort the list of SCCs lexicographically\n        sccs.sort()\n        \n        # Format the result for this test case as a string\n        case_result_str = str(sccs).replace(\" \", \"\")\n        final_results.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "3205772"}, {"introduction": "After mastering the detection of SCCs, the next step is to use them for analysis. This exercise focuses on the condensation graph, which simplifies a complex network into its core components and their relationships. You will determine the minimum set of \"source\" SCCs from which all other components are reachable, a critical task in fields like program dependency analysis or modeling information flow [@problem_id:3276548].", "problem": "You are given several finite directed graphs. For each graph, determine the minimum number of strongly connected components (SCCs) that must be chosen such that, when considered as vertices in the component graph (also called the condensation), every SCC in the graph is reachable from at least one of the chosen SCCs. Your program must compute this minimum for each test case and output all results in a single line as specified below.\n\nFundamental base and definitions to use:\n- A directed graph is a pair $G = (V, E)$ where $V$ is a finite set of vertices and $E \\subseteq V \\times V$ is a set of directed edges.\n- A directed path in $G$ is a sequence of vertices $(v_0, v_1, \\dots, v_k)$ such that $(v_i, v_{i+1}) \\in E$ for all $i \\in \\{0, 1, \\dots, k-1\\}$.\n- Vertex $u \\in V$ reaches vertex $v \\in V$ if there exists a directed path from $u$ to $v$.\n- Two vertices $u, v \\in V$ are strongly connected if $u$ reaches $v$ and $v$ reaches $u$. This relation partitions $V$ into equivalence classes called strongly connected components (SCCs).\n- The component graph (condensation) $G^{\\ast} = (V^{\\ast}, E^{\\ast})$ is defined as follows: each vertex in $V^{\\ast}$ corresponds to one SCC of $G$, and there is a directed edge $(C_i, C_j) \\in E^{\\ast}$ between two distinct SCCs $C_i, C_j \\in V^{\\ast}$ if there exists at least one edge in $E$ from a vertex in $C_i$ to a vertex in $C_j$. It is a well-known fact that $G^{\\ast}$ is a directed acyclic graph.\n- A source SCC is an SCC in $G^{\\ast}$ with in-degree $0$.\n\nTask:\n- For each input graph, compute the minimum number of SCCs required so that every SCC in the component graph $G^{\\ast}$ is reachable from at least one of the chosen SCCs. The minimum is equal to the number of source SCCs in $G^{\\ast}$.\n\nAlgorithmic requirements:\n- Your method must run in time linear in the size of the graph, that is, in $O(|V| + |E|)$ time for each graph.\n\nGraph specification:\n- Each test case specifies a directed graph with vertices labeled by consecutive integers starting at $0$ (zero-based indexing).\n- Each test case is given by $(n, E)$ where $n$ is the number of vertices and $E$ is the list of directed edges as ordered pairs $(u, v)$ with $u, v \\in \\{0, 1, \\dots, n-1\\}$.\n\nTest suite to implement and solve:\n- Test case $1$: $n = 8$, $E = \\{(0,1),(1,2),(2,0),(0,3),(0,4),(3,4),(4,5),(5,4),(6,0)\\}$. Vertex $7$ has no outgoing edges and no incoming edges.\n- Test case $2$: $n = 4$, $E = \\{(0,1),(1,2),(2,3),(3,0)\\}$.\n- Test case $3$: $n = 5$, $E = \\{\\}$.\n- Test case $4$: $n = 6$, $E = \\{(0,2),(1,2),(3,4),(4,5)\\}$.\n- Test case $5$: $n = 0$, $E = \\{\\}$.\n\nAnswer type:\n- For each test case, output a single integer equal to the minimum number of source SCCs in the component graph, as defined above.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, [$r_1$,$r_2$,$r_3$,$\\dots$], where $r_i$ is the integer answer for test case $i$. There must be no spaces in the output line.", "solution": "The problem asks for the minimum number of Strongly Connected Components (SCCs) that need to be chosen so that all SCCs in a given directed graph $G = (V, E)$ are reachable from this chosen set. The reachability is considered in the context of the component graph, or condensation, $G^{\\ast}$.\n\nFirst, let's establish the theoretical foundation. The component graph $G^{\\ast}$ is formed by contracting each SCC of $G$ into a single vertex. An edge exists from a component-vertex $C_i$ to another component-vertex $C_j$ if there is an edge in the original graph $G$ from any vertex in SCC $C_i$ to any vertex in SCC $C_j$. A fundamental property of this construction is that $G^{\\ast}$ is always a Directed Acyclic Graph (DAG). If there were a cycle in $G^{\\ast}$, say $C_1 \\to C_2 \\to \\dots \\to C_k \\to C_1$, it would imply that any vertex in $C_1$ can reach any vertex in $C_k$, and any vertex in $C_k$ can reach any vertex in $C_1$. This would mean all vertices in $C_1, \\dots, C_k$ are mutually reachable, and thus they would all belong to the same single SCC, contradicting the assumption that they are distinct components.\n\nThe problem is now transformed into an equivalent problem on the DAG $G^{\\ast}$: find the minimum number of vertices in $G^{\\ast}$ from which all other vertices are reachable. In any DAG, the set of vertices with an in-degree of $0$ (called source vertices) forms a unique, minimal set from which all other vertices can be reached. Any vertex that is not a source must have an incoming edge, and by tracing these edges backward, we must eventually arrive at a source vertex, as there are no cycles. Therefore, to ensure all vertices are reachable, we must select, at a minimum, all the source vertices. The problem is thus reduced to counting the number of source SCCs, which are the SCCs with an in-degree of $0$ in $G^{\\ast}$.\n\nTo accomplish this task in the required $O(|V| + |E|)$ time, we employ a three-step, linear-time algorithm:\n\n1.  **Decomposition into SCCs:** We use Kosaraju's algorithm to partition the vertices of $G$ into SCCs. This algorithm has a time complexity of $O(|V| + |E|)$.\n    -   **Step 1a:** Perform a Depth-First Search (DFS) on the graph $G$. As each vertex finishes (all its descendants are visited), push it onto a stack. This results in a stack of vertices ordered by decreasing finishing time.\n    -   **Step 1b:** Compute the transpose graph $G^T$, where each edge $(u, v) \\in E$ is reversed to $(v, u) \\in E^T$. This can be done in $O(|V| + |E|)$ time.\n    -   **Step 1c:** Process the vertices from the stack. Pop a vertex $u$. If $u$ has not yet been assigned to an SCC, start a second DFS from $u$ on the transpose graph $G^T$. All vertices reachable from $u$ in $G^T$ form a single SCC. We assign a unique component ID to all these vertices and mark them as visited. We repeat this until the stack is empty. This process identifies all SCCs and assigns each vertex $v \\in V$ a component ID, say `scc_id[v]`.\n\n2.  **Identify Inter-SCC Edges:** We now conceptually build the condensation graph $G^{\\ast}$ to find the source components. We do not need to construct $G^{\\ast}$ explicitly. Instead, we can directly compute the in-degrees of its vertices (the SCCs). We initialize an array `scc_in_degree` of size equal to the number of SCCs, with all entries set to $0$. We then iterate through every edge $(u, v) \\in E$ of the original graph $G$. For each edge, we compare the component IDs of its endpoints: `scc_id[u]` and `scc_id[v]`. If `scc_id[u]` is different from `scc_id[v]`, it signifies an edge in $G^{\\ast}$ from the SCC containing $u$ to the SCC containing $v$. Consequently, we increment the in-degree of the destination component: `scc_in_degree[scc_id[v]]++`. This step takes $O(|E|)$ time.\n\n3.  **Count Source SCCs:** After iterating through all edges, the `scc_in_degree` array holds the in-degree for each SCC. The final step is to count the number of entries in this array that are equal to $0$. This count is the number of source SCCs, which is the required minimum. This takes $O(|V|)$ time, as the number of SCCs is at most $|V|$.\n\nThe total time complexity is the sum of the complexities of these steps, which is $O(|V| + |E|) + O(|E|) + O(|V|) = O(|V| + |E|)$, satisfying the problem's constraint. Special cases, such as an empty graph ($n=0$), result in $0$ SCCs. A graph with no edges ($E=\\emptyset$) results in $n$ SCCs, each being a source.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases.\n    The main logic for each test case is encapsulated in the `calculate_sources` function.\n    \"\"\"\n\n    # Set a higher recursion limit for deep graphs, although not strictly necessary for these test cases.\n    sys.setrecursionlimit(200000)\n\n    # Test cases from the problem statement.\n    test_cases = [\n        (8, [(0, 1), (1, 2), (2, 0), (0, 3), (0, 4), (3, 4), (4, 5), (5, 4), (6, 0)]),\n        (4, [(0, 1), (1, 2), (2, 3), (3, 0)]),\n        (5, []),\n        (6, [(0, 2), (1, 2), (3, 4), (4, 5)]),\n        (0, [])\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = calculate_sources(n, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_sources(n, edges):\n    \"\"\"\n    Calculates the number of source SCCs for a single graph.\n    This function implements Kosaraju's algorithm to find SCCs,\n    then counts the in-degrees of each SCC in the condensation graph.\n    \"\"\"\n    if n == 0:\n        return 0\n\n    adj = [[] for _ in range(n)]\n    adj_t = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj_t[v].append(u)\n\n    # Step 1 of Kosaraju's algorithm: DFS on G to get post-order\n    visited = np.full(n, False, dtype=bool)\n    stack = []\n    def dfs1(u):\n        visited[u] = True\n        for v in adj[u]:\n            if not visited[v]:\n                dfs1(v)\n        stack.append(u)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs1(i)\n\n    # Step 2 of Kosaraju's algorithm: DFS on G_T to find SCCs\n    scc_id = np.full(n, -1, dtype=int)\n    scc_count = 0\n    def dfs2(u, current_scc_id):\n        scc_id[u] = current_scc_id\n        for v in adj_t[u]:\n            if scc_id[v] == -1:\n                dfs2(v, current_scc_id)\n\n    while stack:\n        u = stack.pop()\n        if scc_id[u] == -1:\n            dfs2(u, scc_count)\n            scc_count += 1\n    \n    if scc_count == 0:\n        return 0\n\n    # Step 3: Count in-degrees of SCCs in the condensation graph\n    scc_in_degree = np.zeros(scc_count, dtype=int)\n    for u, v in edges:\n        if scc_id[u] != scc_id[v]:\n            scc_in_degree[scc_id[v]] += 1\n\n    # The number of source SCCs is the number of SCCs with in-degree 0\n    source_sccs = np.sum(scc_in_degree == 0)\n    \n    return source_sccs\n\nsolve()\n```", "id": "3276548"}, {"introduction": "This final practice applies your understanding of graph structure to a constructive problem relevant to network design and optimization. Starting with a directed acyclic graph (DAG), your task is to determine the minimum number of edges needed to transform it into a single, strongly connected system. This problem elegantly demonstrates how analyzing the \"source\" and \"sink\" components of a graph's condensation provides the key to solving a broader connectivity challenge [@problem_id:3276553].", "problem": "Consider the directed graph $G = (V, E)$ where $V = \\{1, 2, \\dots, 14\\}$ and \n$$E = \\{(1,3), (3,5), (5,7), (2,4), (4,6), (6,8), (6,7), (7,9), (9,12), (12,14), (9,13), (10,11)\\}.$$\nAssume $G$ is a Directed Acyclic Graph (DAG). Using only fundamental definitions (e.g., the definition of strong connectivity and strongly connected components) and well-tested facts about linear-time algorithms for strongly connected components such as Tarjan’s algorithm and Kosaraju’s algorithm, determine the minimum number of directed edges that must be added to $G$ (without removing any existing edges and without creating parallel edges or self-loops) so that the resulting graph is strongly connected. Your reasoning should start from the definition of strong connectivity and the structure of the condensation graph of strongly connected components, and you may rely on the fact that strongly connected components can be computed in time $O(|V| + |E|)$.\n\nExpress your final answer as a single integer (no units). No rounding is necessary.", "solution": "The problem asks for the minimum number of directed edges to be added to a given directed graph $G=(V,E)$ to make it strongly connected. The graph is defined by the vertex set $V = \\{1, 2, \\dots, 14\\}$ and the edge set $E = \\{(1,3), (3,5), (5,7), (2,4), (4,6), (6,8), (6,7), (7,9), (9,12), (12,14), (9,13), (10,11)\\}$. The problem states that $G$ is a Directed Acyclic Graph (DAG).\n\nFirst, let us recall the relevant definitions. A directed graph is said to be **strongly connected** if for every ordered pair of distinct vertices $(u, v)$, there exists a directed path from $u$ to $v$. A **Strongly Connected Component (SCC)** of a directed graph is a maximal subgraph that is strongly connected.\n\nAny directed graph can be uniquely partitioned into its SCCs. By contracting each SCC into a single super-vertex, we can form the **condensation graph**, $G_{SCC}$. An edge exists in $G_{SCC}$ from a super-vertex $C_i$ to a super-vertex $C_j$ if and only if there is an edge in the original graph $G$ from some vertex in SCC $C_i$ to some vertex in SCC $C_j$. A fundamental property of the condensation graph is that it is always a Directed Acyclic Graph (DAG).\n\nTo make the original graph $G$ strongly connected, we must add edges such that there is a path between any two vertices. This is equivalent to making the condensation graph $G_{SCC}$ strongly connected. Since $G_{SCC}$ is a DAG, making it strongly connected means reducing it to a single SCC, which can be achieved by adding edges to create a cycle that includes all the super-vertices of $G_{SCC}$.\n\nThe problem states that the initial graph $G$ is a DAG. In a DAG, by definition, there are no directed cycles. For a set of two or more vertices to form an SCC, there must be a cycle containing them. Since $G$ has no cycles, any SCC in $G$ must consist of a single vertex. Therefore, for the given graph $G$, each of its $14$ vertices is its own SCC.\n\nThis implies that the condensation graph $G_{SCC}$ is isomorphic to the original graph $G$. The super-vertices of $G_{SCC}$ are the vertices of $G$, and the edges of $G_{SCC}$ are the edges of $G$. The problem is thus reduced to finding the minimum number of edges to add to the given DAG, $G$, to make it strongly connected.\n\nFor a DAG with more than one vertex to be made strongly connected, every vertex must have at least one incoming edge and at least one outgoing edge. Let $S$ be the number of \"source\" vertices (vertices with in-degree $0$) and $T$ be the number of \"sink\" vertices (vertices with out-degree $0$). To eliminate all sources, we must add at least $S$ edges, one directed into each source. To eliminate all sinks, we must add at least $T$ edges, one directed out of each sink.\n\nA well-known result in graph theory states that if the condensation graph is not trivial (i.e., has more than one vertex), the minimum number of edges required to make the graph strongly connected is given by $\\max(S, T)$. We can achieve this by adding edges that \"chain\" the sinks to the sources. For example, if we have sinks $\\{t_1, \\dots, t_T\\}$ and sources $\\{s_1, \\dots, s_S\\}$, we can form a cycle of these extremal components. The number of edges required for an optimal construction is precisely $\\max(S, T)$. Since our graph $G$ has $|V| = 14$ vertices, which function as the SCCs, and $14 > 1$, this result is applicable.\n\nWe must now compute $S$ and $T$ for the given graph $G$. We will calculate the in-degree and out-degree for each vertex in $V = \\{1, 2, \\dots, 14\\}$.\n\nThe edge set is $E = \\{(1,3), (3,5), (5,7), (2,4), (4,6), (6,8), (6,7), (7,9), (9,12), (12,14), (9,13), (10,11)\\}$.\n\nThe in-degrees are:\n- $\\text{in-degree}(1) = 0$\n- $\\text{in-degree}(2) = 0$\n- $\\text{in-degree}(3) = 1$ (from vertex $1$)\n- $\\text{in-degree}(4) = 1$ (from vertex $2$)\n- $\\text{in-degree}(5) = 1$ (from vertex $3$)\n- $\\text{in-degree}(6) = 1$ (from vertex $4$)\n- $\\text{in-degree}(7) = 2$ (from vertices $5$ and $6$)\n- $\\text{in-degree}(8) = 1$ (from vertex $6$)\n- $\\text{in-degree}(9) = 1$ (from vertex $7$)\n- $\\text{in-degree}(10) = 0$\n- $\\text{in-degree}(11) = 1$ (from vertex $10$)\n- $\\text{in-degree}(12) = 1$ (from vertex $9$)\n- $\\text{in-degree}(13) = 1$ (from vertex $9$)\n- $\\text{in-degree}(14) = 1$ (from vertex $12$)\n\nThe source vertices (in-degree $0$) are $\\{1, 2, 10\\}$. Thus, the number of sources is $S = 3$.\n\nThe out-degrees are:\n- $\\text{out-degree}(1) = 1$ (to vertex $3$)\n- $\\text{out-degree}(2) = 1$ (to vertex $4$)\n- $\\text{out-degree}(3) = 1$ (to vertex $5$)\n- $\\text{out-degree}(4) = 1$ (to vertex $6$)\n- $\\text{out-degree}(5) = 1$ (to vertex $7$)\n- $\\text-out-degree}(6) = 2$ (to vertices $7$ and $8$)\n- $\\text{out-degree}(7) = 1$ (to vertex $9$)\n- $\\text{out-degree}(8) = 0$\n- $\\text{out-degree}(9) = 2$ (to vertices $12$ and $13$)\n- $\\text{out-degree}(10) = 1$ (to vertex $11$)\n- $\\text{out-degree}(11) = 0$\n- $\\text{out-degree}(12) = 1$ (to vertex $14$)\n- $\\text{out-degree}(13) = 0$\n- $\\text{out-degree}(14) = 0$\n\nThe sink vertices (out-degree $0$) are $\\{8, 11, 13, 14\\}$. Thus, the number of sinks is $T = 4$.\n\nThe minimum number of edges that must be added is $\\max(S, T)$.\nSubstituting the calculated values, we get:\n$$ \\text{Minimum edges} = \\max(3, 4) = 4 $$\nTherefore, a minimum of $4$ edges must be added to make the graph $G$ strongly connected.", "answer": "$$\n\\boxed{4}\n$$", "id": "3276553"}]}