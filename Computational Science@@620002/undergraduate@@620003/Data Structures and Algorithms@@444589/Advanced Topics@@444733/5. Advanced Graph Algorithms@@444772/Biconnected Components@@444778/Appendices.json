{"hands_on_practices": [{"introduction": "Before we write algorithms to find biconnected components, it's crucial to build an intuition for the structures we are looking for. This first exercise [@problem_id:1484292] is a thought experiment that explores the fundamental relationship between the number of blocks and cut vertices in a graph. By determining the minimum number of vertices and edges required for a specific hypothetical configuration, you will gain insight into the constraints imposed by the graph's underlying block-cut tree structure.", "problem": "In graph theory, a **simple graph** is an unweighted, undirected graph containing no loops or multiple edges. A graph is **connected** if there is a path from any vertex to any other vertex in the graph.\n\nA **cut vertex** (or articulation point) of a connected graph is a vertex whose removal (along with all edges incident to it) increases the number of connected components of the graph.\n\nA **block** (or biconnected component) of a graph is a maximal connected subgraph that has no cut vertices of its own. In a connected graph, the blocks are either bridges (and their endpoints) or maximal 2-connected subgraphs. The set of blocks of a graph forms a partition of its edge set.\n\nConsider the set of all possible connected simple graphs $G$ that contain exactly $b=5$ blocks and $c=4$ cut vertices. Let $v_{min}$ be the minimum number of vertices and $e_{min}$ be the minimum number of edges that any such graph $G$ must have.\n\nWhich of the following statements is true for a graph with $b=5$ blocks and $c=4$ cut vertices?\n\nA. Such a graph cannot exist.\nB. Such a graph can exist, and for any such graph, the number of vertices must be at least 8.\nC. Such a graph can exist, and for any such graph, the number of edges must be at least 7.\nD. The minimum number of vertices is $v_{min}=6$ and the minimum number of edges is $e_{min}=5$.\nE. The minimum number of vertices is $v_{min}=5$ and the minimum number of edges is $e_{min}=6$.", "solution": "Let $G$ be a connected simple graph with $b=5$ blocks and $c=4$ cut vertices. Consider the block–cut tree $T$ of $G$. This is a bipartite tree whose bipartition consists of $b$ block-nodes and $c$ cut-vertex-nodes, with an edge joining a block-node to a cut-vertex-node whenever that cut vertex lies in that block. Since $T$ is a tree,\n$$\n|V(T)|=b+c,\\qquad |E(T)|=b+c-1.\n$$\nHence the sum of degrees on either side equals $b+c-1$. Moreover, each cut vertex lies in at least two blocks, so every cut-vertex-node has degree at least $2$. Therefore,\n$$\n\\sum_{\\text{cut vertices}} \\deg_{T}=\\;b+c-1\\;\\ge\\;2c\\;\\;\\Longrightarrow\\;\\;c\\le b-1.\n$$\nWith $b=5$ and $c=4$, equality holds in $b+c-1=2c$, giving $b+c-1=8=2c$, so every cut-vertex-node has degree exactly $2$. In a tree, if all cut-vertex-nodes have degree $2$, then $T$ must be a path starting and ending at block-nodes. Thus the $5$ block-nodes have degrees\n$$\n\\{1,2,2,2,1\\}.\n$$\n\nTo minimize the number of vertices of $G$, note that every vertex that lies in more than one block is a cut vertex, and every non-cut vertex belongs to exactly one block. If a block-node has degree $d_{B}$ in $T$, then the corresponding block contains exactly $d_{B}$ cut vertices. The minimal number of non-cut vertices required by a block with given $d_{B}$ is:\n- If the block is a $K_{2}$ (bridge), it has exactly $2-d_{B}$ non-cut vertices for $d_{B}\\in\\{1,2\\}$.\n- If the block is $2$-connected, the minimum is $\\max(3-d_{B},0)$, realized by a cycle through the $d_{B}$ cut vertices (for $d_{B}\\ge 3$), by a triangle for $d_{B}=2$, and needs two extra vertices for $d_{B}=1$.\n\nFor $d_{B}\\in\\{1,2\\}$, using $K_{2}$ minimizes non-cut vertices. Since our block degrees are $\\{1,2,2,2,1\\}$, choosing all blocks as $K_{2}$ yields total non-cut vertices from the two degree-1 blocks and three degree-2 blocks:\n$$\n2 \\times (2-1) + 3 \\times (2-2) = 2 \\times 1 + 3 \\times 0 = 2.\n$$\nTherefore the minimum number of vertices is\n$$\nv_{\\min}=c+\\text{(non-cut vertices)}=4+2=6.\n$$\n\nFor edges, since the edge set is partitioned by the $b$ blocks and each block has at least one edge, we have\n$$\ne\\ge b=5.\n$$\nThis lower bound is achieved by taking all blocks as $K_{2}$ arranged as a path of $5$ edges, i.e., the path $P_{6}$. Then\n$$\ne_{\\min}=5.\n$$\nThis construction also has exactly $c=4$ cut vertices (the $4$ internal vertices of $P_{6}$), confirming feasibility. Hence the correct statement is that such graphs exist with $v_{\\min}=6$ and $e_{\\min}=5$.", "answer": "$$\\boxed{D}$$", "id": "1484292"}, {"introduction": "Having explored the conceptual properties of blocks and cut vertices, we now move to the main construction task. This practice [@problem_id:3214787] requires you to implement an algorithm that explicitly builds the block-cut tree of a graph. This exercise synthesizes several steps: finding articulation points and blocks using a Depth-First Search, managing their identities according to specific rules, and finally assembling the bipartite tree structure that represents the graph's 2-vertex-connectivity.", "problem": "You are given an undirected simple graph $G$ with a finite vertex set $V$ and edge set $E$. The goal is to design, justify, and implement an algorithm that builds the adjacency list representation of the block-cut tree of $G$. The block-cut tree is the bipartite structure whose nodes are the blocks (maximal $2$-vertex-connected subgraphs together with bridge edges and isolated vertices) and the cut vertices (articulation points), with edges connecting each cut vertex to every block that contains it.\n\nThe fundamental base for this problem is the definition of a cut vertex (articulation point) and the notion of vertex-connectivity, together with the well-tested graph traversal facts that Depth-First Search (DFS) can be used to discover parent-child relationships in the DFS tree, identify back edges, and compute discovery times and low values that reflect reachability via back edges. From these definitions and traversal facts, you are to derive an explicit algorithm that identifies blocks and cut vertices and constructs the block-cut tree.\n\nYour algorithm must:\n\n- Accept as input an undirected simple graph $G$ on vertices labeled as integers from $0$ to $n-1$, where $n$ is the number of vertices.\n- Identify all articulation points and all blocks of $G$, including single bridge edges and isolated vertices as blocks.\n- Construct the block-cut tree, which is a bipartite graph whose nodes correspond to the articulation points and the blocks of $G$, and whose edges connect a cut vertex node to each block node that contains it.\n- Output the adjacency list of the block-cut tree using the following deterministic indexing and ordering conventions:\n  1. Let $a$ be the number of articulation points and $b$ be the number of blocks.\n  2. Index the articulation point nodes from $0$ to $a-1$ in ascending order of their original vertex labels.\n  3. Index the block nodes from $a$ to $a+b-1$ in ascending order of their block keys. The block key is defined as the tuple consisting of the minimum vertex label in the block, the block’s size (number of vertices), and the lexicographically ascending list of its vertices.\n  4. The adjacency list must be a list of length $a+b$, whose $i$-th entry is the sorted list of neighbor indices of node $i$ in the block-cut tree.\n  5. For a graph with no vertices ($n=0$), the output should be the empty list $[]$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result corresponds to one test graph and is itself a nested list representing the adjacency list of the block-cut tree for that graph. For example, an output could look like $[ [\\dots], [\\dots], \\dots ]$ where each inner list is the adjacency list for one test case.\n\nTest Suite:\nImplement and run your algorithm on the following set of input graphs. Each graph is specified by the pair $(n, E)$, where $n$ is the number of vertices and $E$ is the list of unordered vertex pairs indicating edges.\n\n- Test $1$ (connected, multiple blocks and articulation points):\n  $$n = 9,\\quad E = \\{(0,1),(1,2),(2,0),(1,3),(3,4),(4,5),(5,3),(4,6),(6,7),(7,8),(8,6)\\}.$$\n- Test $2$ (single cycle, no articulation points):\n  $$n = 4,\\quad E = \\{(0,1),(1,2),(2,3),(3,0)\\}.$$\n- Test $3$ (single edge, no articulation points):\n  $$n = 2,\\quad E = \\{(0,1)\\}.$$\n- Test $4$ (disconnected, isolated vertices and bridges):\n  $$n = 5,\\quad E = \\{(1,2),(2,3)\\},\\text{ with vertices }0\\text{ and }4\\text{ isolated}.$$\n- Test $5$ (empty graph):\n  $$n = 0,\\quad E = \\{\\}.$$\n\nAnswer Specification:\n- For each test case, the answer must be a list of lists of integers, specifically the adjacency list for the block-cut tree constructed according to the rules above.\n- The final output must be a single line: the list of all test case adjacency lists, as a comma-separated list enclosed in square brackets.", "solution": "The user has requested the design and implementation of an algorithm to construct the block-cut tree of a given undirected simple graph $G=(V, E)$.\n\n### Step 1: Extract Givens\n- **Input**: An undirected simple graph $G$ specified by the number of vertices $n$ (labeled $0$ to $n-1$) and a set of edges $E$.\n- **Core Definitions**:\n    - **Cut Vertex (Articulation Point)**: A vertex whose removal increases the number of connected components of the graph.\n    - **Block**: A maximal $2$-vertex-connected subgraph. Bridges (edges whose removal increases connected components) and isolated vertices are also considered blocks.\n    - **Block-Cut Tree**: A bipartite graph whose nodes represent the blocks and cut vertices of $G$. An edge exists between a cut-vertex-node and a block-node if the corresponding cut vertex is part of the corresponding block.\n- **Output**: The adjacency list of the block-cut tree.\n- **Output Formatting and Indexing Conventions**:\n    1.  Let $a$ be the number of articulation points and $b$ be the number of blocks.\n    2.  Articulation point nodes are indexed $0, \\dots, a-1$, sorted by their original vertex labels in ascending order.\n    3.  Block nodes are indexed $a, \\dots, a+b-1$, sorted by a \"block key.\"\n    4.  **Block Key**: A tuple `(minimum vertex label in the block, block size, lexicographically ascending list of its vertices)`.\n    5.  The final output is an adjacency list of length $a+b$, where the $i$-th entry is the sorted list of neighbors of node $i$.\n    6.  For an empty graph ($n=0$), the output must be an empty list `[]`.\n- **Test Cases**: Five specific test graphs are provided.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed against the validation criteria:\n- **Scientifically Grounded**: The problem is rooted in fundamental, well-established concepts of graph theory, namely vertex connectivity, biconnected components (blocks), and depth-first search (DFS) algorithms. The definitions provided for cut vertices, blocks, and the block-cut tree are standard. The use of DFS to find these structures is a classic and correct approach, often attributed to John Hopcroft and Robert Tarjan. The problem is scientifically sound.\n- **Well-Posed**: The problem is well-posed. The input format is clearly defined. The output format and, critically, the deterministic indexing and sorting rules for the nodes of the block-cut tree ensure that a unique solution exists for any given input graph.\n- **Objective**: The problem statement is objective, precise, and free from any subjective or ambiguous language. All terms are either standard in graph theory or explicitly defined.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a standard, well-defined algorithmic task with clear requirements. I will now proceed with a complete, reasoned solution.\n\n### Principle-Based Solution\nThe construction of the block-cut tree requires two primary steps: first, identifying the articulation points and blocks of the graph $G$, and second, building the tree structure based on their relationships. The canonical algorithm for finding blocks and articulation points is based on a Depth-First Search (DFS) of the graph.\n\n**1. Finding Articulation Points and Blocks via DFS**\n\nWe perform a DFS traversal starting from an arbitrary vertex. During the traversal, we maintain two key pieces of information for each vertex $u$:\n- **Discovery Time $disc[u]$**: The \"time\" (a counter incremented at each vertex visit) when $u$ is first discovered.\n- **Low-Link Value $low[u]$**: The lowest discovery time reachable from $u$ (including itself) by traversing zero or more tree edges in the DFS tree and at most one back edge.\n\nThe $low[u]$ value is calculated as the minimum of:\n1.  $disc[u]$.\n2.  $disc[w]$ for any vertex $w$ such that $(u, w)$ is a back edge in the DFS tree.\n3.  $low[v]$ for any vertex $v$ that is a child of $u$ in the DFS tree.\n\nTo manage the identification of blocks, we use a stack to store the edges as they are traversed.\n\nThe algorithm proceeds as follows:\nWe initialize $disc$, $low$, and $visited$ arrays for all vertices. We iterate through each vertex $u \\in V$. If $u$ has not been visited, we start a recursive DFS from $u$.\n\n**The Recursive DFS function, `dfs(u, p)` (from vertex `u` with parent `p`):**\n1.  Mark $u$ as visited. Set $disc[u]$ and $low[u]$ to the current time, and increment the time counter.\n2.  Keep a count of children of $u$ in the DFS tree, let's call it $children$.\n3.  For each neighbor $v$ of $u$:\n    a. If $v$ is the parent $p$, ignore it.\n    b. If $v$ has been visited (i.e., $visited[v]$ is true), then $(u, v)$ is a back edge. We update $low[u] = \\min(low[u], disc[v])$ and push the edge $(u, v)$ onto our edge stack. We only push if $disc[v]  disc[u]$ to ensure we handle the edge once.\n    c. If $v$ has not been visited, then $(u, v)$ is a tree edge. We increment $children$, push $(u, v)$ onto the edge stack, and recursively call `dfs(v, u)`. After the recursive call returns, we update $low[u] = \\min(low[u], low[v])$.\n\n**Identifying Articulation Points and Blocks:**\nDuring step 3c, after the recursive call for a child $v$ returns to $u$, we check for the articulation point condition:\n- A vertex $u$ is an articulation point if either:\n    1. $u$ is the root of a DFS tree (i.e., $p$ is null/invalid) and $children > 1$.\n    2. $u$ is not the root and there exists a child $v$ such that $low[v] \\ge disc[u]$.\n\nThis second condition, $low[v] \\ge disc[u]$, signifies that the subgraph explored from child $v$ cannot reach any ancestor of $u$ without passing through $u$. This discovery also signals the identification of a new block. To extract this block, we pop edges from the edge stack until we pop the edge $(u, v)$. All vertices involved in these popped edges form the new block.\n\n**Handling Component-Level Biconnectivity and Isolated Vertices:**\n- If, after the initial `dfs(u, p)` call for a connected component returns, there are still edges on the stack that were added during its execution, this means the entire component is biconnected. These remaining edges form a single block.\n- After iterating through all vertices and running DFS on all connected components, any vertex that has not been visited is an isolated vertex. Each isolated vertex forms a block of size one.\n\n**2. Constructing the Block-Cut Tree**\n\nAfter identifying all articulation points (let's say there are $a$ of them) and all blocks ($b$ of them), we proceed to build the tree.\n1.  **Node Indexing**:\n    - Create a sorted list of unique articulation point labels. This gives a mapping from a vertex label to its articulation-point-node index from $0$ to $a-1$.\n    - For each block (represented as a set of vertex labels), compute its key as defined in the problem: `(min_vertex, size, sorted_vertices)`. Sort all blocks based on this key. This gives a mapping from a block to its block-node index from $a$ to $a+b-1$.\n\n2.  **Building the Adjacency List**:\n    - Create an adjacency list `adj_bctree` of size $a+b$.\n    - For each block, iterate through the vertices it contains. If a vertex is an articulation point, find its corresponding articulation-point-node index, let's say `ap_idx`. Let the current block's node index be `block_idx`.\n    - Add an edge in the block-cut tree between `ap_idx` and `block_idx` by appending each to the other's adjacency list: `adj_bctree[ap_idx].append(block_idx)` and `adj_bctree[block_idx].append(ap_idx)`.\n\n3.  **Finalization**:\n    - As per the requirements, sort the list of neighbors for each node in `adj_bctree`.\n    - The special case of an empty graph ($n=0$) results in an empty adjacency list `[]`.\n\nThis structured, principle-based approach correctly implements the required algorithm and adheres to all specified conventions for a deterministic and valid solution.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all given test cases.\n    \"\"\"\n    test_cases = [\n        # Test 1 (connected, multiple blocks and articulation points)\n        (9, [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4), (4, 5), (5, 3), (4, 6), (6, 7), (7, 8), (8, 6)]),\n        # Test 2 (single cycle, no articulation points)\n        (4, [(0, 1), (1, 2), (2, 3), (3, 0)]),\n        # Test 3 (single edge, no articulation points)\n        (2, [(0, 1)]),\n        # Test 4 (disconnected, isolated vertices and bridges)\n        (5, [(1, 2), (2, 3)]),\n        # Test 5 (empty graph)\n        (0, [])\n    ]\n\n    results = []\n    for n, E in test_cases:\n        result = build_block_cut_tree(n, E)\n        results.append(result)\n\n    # The final output is a string representation of a list of lists.\n    # Python's default print for lists matches the required format.\n    print(results)\n\ndef build_block_cut_tree(n, edges):\n    \"\"\"\n    Computes the adjacency list of the block-cut tree for a given graph.\n    \"\"\"\n    if n == 0:\n        return []\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * n\n    disc = np.full(n, -1, dtype=int)\n    low = np.full(n, -1, dtype=int)\n    time = 0\n    edge_stack = []\n    blocks = []\n    articulation_points = set()\n\n    def find_biconnected_components(u, p):\n        nonlocal time\n        visited[u] = True\n        disc[u] = low[u] = time\n        time += 1\n        children = 0\n\n        for v in adj[u]:\n            if v == p:\n                continue\n\n            # Ensure each undirected edge is pushed onto the stack only once\n            if not visited[v]:\n                children += 1\n                edge_stack.append((u, v))\n                find_biconnected_components(v, u)\n                low[u] = min(low[u], low[v])\n\n                if (p == -1 and children  1) or (p != -1 and low[v] = disc[u]):\n                    articulation_points.add(u)\n                    \n                    new_block = set()\n                    while True:\n                        e_u, e_v = edge_stack.pop()\n                        new_block.add(e_u)\n                        new_block.add(e_v)\n                        if (e_u, e_v) == (u, v):\n                            break\n                    blocks.append(frozenset(new_block))\n            elif disc[v]  disc[u]: # Back edge\n                low[u] = min(low[u], disc[v])\n                edge_stack.append((u, v))\n\n    for i in range(n):\n        if not visited[i]:\n            # For each component, find its biconnected components\n            stack_len_before = len(edge_stack)\n            find_biconnected_components(i, -1)\n            \n            # If edges remain on the stack for this component, they form a single biconnected component\n            if len(edge_stack)  stack_len_before:\n                new_block = set()\n                while len(edge_stack)  stack_len_before:\n                    e_u, e_v = edge_stack.pop()\n                    new_block.add(e_u)\n                    new_block.add(e_v)\n                blocks.append(frozenset(new_block))\n\n    # Identify vertices in blocks to find isolated ones\n    vertices_in_blocks = set()\n    for block in blocks:\n        vertices_in_blocks.update(block)\n    \n    # Isolated vertices form their own blocks\n    for i in range(n):\n        if i not in vertices_in_blocks:\n            blocks.append(frozenset([i]))\n\n    # Sort articulation points and blocks to create deterministic indices\n    sorted_aps = sorted(list(articulation_points))\n    ap_map = {label: i for i, label in enumerate(sorted_aps)}\n    num_aps = len(sorted_aps)\n\n    def get_block_key(block):\n        v_list = sorted(list(block))\n        return (v_list[0], len(v_list), tuple(v_list))\n\n    sorted_blocks = sorted(blocks, key=get_block_key)\n    block_map = {block: i + num_aps for i, block in enumerate(sorted_blocks)}\n    num_blocks = len(sorted_blocks)\n\n    num_bct_nodes = num_aps + num_blocks\n    bct_adj = [[] for _ in range(num_bct_nodes)]\n\n    # Build the block-cut tree edges\n    for block in sorted_blocks:\n        block_idx = block_map[block]\n        for vertex in block:\n            if vertex in ap_map:\n                ap_idx = ap_map[vertex]\n                bct_adj[ap_idx].append(block_idx)\n                bct_adj[block_idx].append(ap_idx)\n\n    # Sort neighbor lists as required\n    for i in range(num_bct_nodes):\n        bct_adj[i].sort()\n        \n    return bct_adj\n\nsolve()\n\n```", "id": "3214787"}, {"introduction": "The true power of a concept like the block-cut tree lies in its applications for solving other complex graph problems. In this final practice [@problem_id:3209569], you will use this decomposition to tackle a classic network resilience problem: finding the minimum number of edges to add to make a graph biconnected. This task demonstrates how abstracting a graph into its block-cut tree simplifies the problem to strategically connecting the leaves of this tree, providing an elegant and efficient solution.", "problem": "Let $G=(V,E)$ be a finite, simple, undirected, connected graph with $|V|=n$ and $|E|=m$, where $n \\ge 3$. A vertex $v \\in V$ is an articulation point if the removal of $v$ (and all incident edges) increases the number of connected components of the graph. A graph is biconnected (two-vertex-connected) if it is connected and has no articulation points. You are to write a complete, runnable program that, for each graph in the provided test suite, computes the minimum number of edges that must be added between currently non-adjacent distinct vertices to make the graph biconnected, without creating parallel edges or self-loops.\n\nYour program must construct its answer from first principles using the core definitions of articulation points and biconnected components, and well-tested algorithmic facts such as the existence of Depth-First Search (DFS) tree structures and low-link values. The program must not rely on pre-specified shortcut formulas; instead, it must identify articulation points and biconnected components, reason about the block-cut tree induced by these components and articulation points, and deduce the minimal number of edges to add.\n\nThe test suite consists of $6$ connected graphs, each specified by its number of vertices $n$ and its edge set $E$ (all vertices are labeled by integers from $0$ to $n-1$):\n\n- Test case $1$: $n=5$, $E=\\{(0,1),(1,2),(2,3),(3,4),(4,0)\\}$ (a cycle on $5$ vertices).\n- Test case $2$: $n=4$, $E=\\{(0,1),(1,2),(2,3)\\}$ (a path on $4$ vertices).\n- Test case $3$: $n=7$, $E=\\{(0,1),(0,2),(0,3),(0,4),(0,5),(0,6)\\}$ (a star with center $0$ and $6$ leaves).\n- Test case $4$: $n=5$, $E=\\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,2)\\}$ (two triangles sharing a single vertex).\n- Test case $5$: $n=6$, $E=\\{(0,1),(1,2),(2,3),(3,0),(1,4),(4,5)\\}$ (a cycle with a length-$2$ tail attached to one cycle vertex).\n- Test case $6$: $n=6$, $E=\\{(0,1),(1,2),(1,3),(3,4),(3,5)\\}$ (a tree with internal vertices $1$ and $3$).\n\nYour program should produce a single line of output containing the results for the six test cases in order, formatted as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3,r_4,r_5,r_6]$, where each $r_i$ is an integer giving the minimal number of edges to add for test case $i$.", "solution": "The problem has been validated and is deemed a well-posed, scientifically grounded problem in the field of graph theory. The givens are complete, consistent, and formalizable.\n\n### Principle-Based Solution Design\n\nThe core task is to determine the minimum number of edges to add to a connected graph $G$ to make it biconnected. A graph is biconnected if and only if it is connected and contains no articulation points. An articulation point (or cut vertex) is a vertex whose removal increases the number of connected components of the graph.\n\n#### 1. The Block-Cut Tree Structure\n\nThe problem can be analyzed by considering the graph's structure in terms of its biconnected components (BCCs or blocks) and articulation points. The relationship between these entities can be modeled by a **block-cut tree**, $T_{BC}$.\n- The vertices of $T_{BC}$ correspond to the articulation points and the BCCs of the original graph $G$.\n- An edge exists in $T_{BC}$ between an articulation point vertex $v_{ap}$ and a block vertex $B$ if and only if the vertex corresponding to $v_{ap}$ is a member of the block $B$ in $G$.\n- For any connected graph $G$, its corresponding block-cut structure $T_{BC}$ is a tree.\n\nMaking the original graph $G$ biconnected is equivalent to transforming its block-cut tree $T_{BC}$ into a single node. This conceptual transformation occurs when all original biconnected components and articulation points are merged into a single, large biconnected component.\n\n#### 2. Strategy: Connecting Leaf Blocks\n\nThe \"weak points\" of the graph's connectivity are its \"dangling\" components. In the block-cut tree, these are represented by leaf nodes. Since any path in a tree must connect two leaf nodes (or be a single node), leaf nodes in $T_{BC}$ are always block-vertices (assuming the tree is not trivial). A block $B$ is a leaf in $T_{BC}$ if it contains exactly one articulation point of $G$. We shall call these **leaf blocks**.\n\nTo eliminate articulation points, we must introduce new paths between parts of the graph that are separated by them. The most efficient way to do this is to add edges between vertices of distinct leaf blocks. Adding a single edge between a vertex in a leaf block $B_1$ and a vertex in another leaf block $B_2$ creates a new cycle in $G$. This has the effect of merging $B_1$, $B_2$, and the entire path of blocks and articulation points between them in $T_{BC}$ into a single, larger biconnected component.\n\nThis operation effectively reduces the number of leaves in the conceptual block-cut tree. If we have $l$ leaf blocks, we can pair them up. An edge added between each pair reduces the number of leaves by two. The minimum number of edges required to connect all $l$ leaves into a single super-component is $\\lceil l/2 \\rceil$.\n\n- If the graph is already biconnected, it consists of a single block and has no articulation points. In this case, the number of leaf blocks is $l=0$, and the formula correctly yields $\\lceil 0/2 \\rceil = 0$.\n- If the graph is not biconnected, it must have at least one articulation point and thus at least two leaf blocks ($l \\ge 2$).\n\n#### 3. Algorithmic Implementation\n\nThe overall algorithm is as follows:\n\n**Step 1: Find Articulation Points and Biconnected Components**\nThis is the central part of the algorithm, executed using a single Depth-First Search (DFS) traversal. For each vertex $u \\in V$, we maintain two values:\n- $disc[u]$: The discovery time of $u$ during the DFS, i.e., the \"time\" (a counter) when $u$ is first visited.\n- $low[u]$: The lowest discovery time reachable from $u$ (including through its own DFS subtree) by traversing zero or more tree edges and at most one back-edge.\n\nAn edge stack is used to keep track of the edges of the BCCs. During the DFS from a vertex $u$ to its neighbor $v$:\n- A vertex $u$ is identified as an articulation point if it is the root of the DFS tree and has more than one child, or if it is not the root and has a child $v$ for which $low[v] \\ge disc[u]$.\n- This same condition, $low[v] \\ge disc[u]$, signals that a BCC has just been fully traversed. The edges of this BCC are on top of the edge stack and can be popped off until the edge $(u,v)$ is removed. The set of all vertices from these popped edges constitutes the BCC.\n\n**Step 2: Count Leaf Blocks**\nAfter the DFS completes and all articulation points and BCCs have been identified, we count the number of leaf blocks, $l$. A BCC is a leaf block if the number of its vertices that are articulation points of the main graph is exactly one.\n\n**Step 3: Calculate Minimum Edges**\nThe minimum number of edges to add is given by the formula $\\lceil l / 2 \\rceil$. This can be computed using integer arithmetic as $(l + 1) // 2$. If the graph is already biconnected, the algorithm will find only a single BCC and no articulation points, resulting in $l=0$ and an answer of $0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the biconnectivity augmentation problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1: n=5, a cycle graph\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]),\n        # Test case 2: n=4, a path graph\n        (4, [(0, 1), (1, 2), (2, 3)]),\n        # Test case 3: n=7, a star graph\n        (7, [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6)]),\n        # Test case 4: n=5, two triangles sharing a vertex\n        (5, [(0, 1), (1, 2), (2, 0), (2, 3), (3, 4), (4, 2)]),\n        # Test case 5: n=6, a cycle with a tail\n        (6, [(0, 1), (1, 2), (2, 3), (3, 0), (1, 4), (4, 5)]),\n        # Test case 6: n=6, a tree\n        (6, [(0, 1), (1, 2), (1, 3), (3, 4), (3, 5)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        solver = BiconnectivityAugmenter(n, edges)\n        result = solver.compute_min_edges()\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nclass BiconnectivityAugmenter:\n    \"\"\"\n    A class to find the minimum number of edges to make a graph biconnected.\n    \"\"\"\n    def __init__(self, n, edges):\n        self.n = n\n        self.adj = [[] for _ in range(n)]\n        for u, v in edges:\n            self.adj[u].append(v)\n            self.adj[v].append(u)\n        \n        # State for the BCC algorithm\n        self.time = 0\n        self.disc = [-1] * n\n        self.low = [-1] * n\n        self.edge_stack = []\n        \n        self.articulation_points = set()\n        self.bccs = []\n\n    def _find_aps_and_bccs(self, u, p):\n        \"\"\"\n        Recursive DFS utility to find articulation points and biconnected components.\n        'u' is the current vertex, 'p' is its parent in the DFS tree.\n        \"\"\"\n        self.disc[u] = self.low[u] = self.time\n        self.time += 1\n        children = 0\n\n        for v in self.adj[u]:\n            if v == p:\n                continue\n\n            if self.disc[v] != -1:  # Visited vertex, so a back edge\n                self.low[u] = min(self.low[u], self.disc[v])\n                if self.disc[v]  self.disc[u]:\n                    self.edge_stack.append((u, v))\n            else:  # Not visited, so a tree edge\n                children += 1\n                self.edge_stack.append((u, v))\n                self._find_aps_and_bccs(v, u)\n                \n                self.low[u] = min(self.low[u], self.low[v])\n\n                # Check for articulation point u\n                if (p == -1 and children  1) or (p != -1 and self.low[v] = self.disc[u]):\n                    self.articulation_points.add(u)\n                \n                # If low[v] = disc[u], u is an AP and a new BCC is found\n                if self.low[v] = self.disc[u]:\n                    new_bcc_edges = []\n                    while True:\n                        edge = self.edge_stack.pop()\n                        new_bcc_edges.append(edge)\n                        if edge == (u, v) or edge == (v, u):\n                            break\n                    \n                    bcc_nodes = set()\n                    for n1, n2 in new_bcc_edges:\n                        bcc_nodes.add(n1)\n                        bcc_nodes.add(n2)\n                    self.bccs.append(bcc_nodes)\n\n    def compute_min_edges(self):\n        \"\"\"\n        Computes the minimum number of edges to add to make the graph biconnected.\n        \"\"\"\n        # A connected graph with n  3 is always biconnected.\n        if self.n  3:\n            return 0\n            \n        # Run DFS from vertex 0. The graph is connected, so one run is sufficient.\n        self._find_aps_and_bccs(0, -1)\n\n        # If the whole graph is one BCC, the stack will not be empty.\n        if self.edge_stack:\n            bcc_nodes = set()\n            for u, v in self.edge_stack:\n                bcc_nodes.add(u)\n                bcc_nodes.add(v)\n            self.bccs.append(bcc_nodes)\n            self.edge_stack.clear()\n        \n        # If there are no articulation points, the graph is already biconnected.\n        # This is equivalent to having 0 or 1 BCCs.\n        if len(self.bccs) = 1:\n            return 0\n\n        # Count leaf blocks: BCCs with exactly one articulation point.\n        leaf_blocks = 0\n        for bcc in self.bccs:\n            ap_count_in_bcc = 0\n            for node in bcc:\n                if node in self.articulation_points:\n                    ap_count_in_bcc += 1\n            if ap_count_in_bcc == 1:\n                leaf_blocks += 1\n        \n        # The number of edges to add is ceil(number of leaf blocks / 2).\n        return int(np.ceil(leaf_blocks / 2))\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3209569"}]}