{"hands_on_practices": [{"introduction": "This exercise explores the backtracking framework through the classic puzzle of placing non-attacking rooks on a chessboard. The challenge lies in navigating a tree of decisions—placing a rook or not—and retreating when a choice leads to a conflict. This practice is fundamental for learning how to manage state (occupied rows and columns) and implement pruning by calculating an optimistic upper bound to discard non-promising search paths [@problem_id:3212770].", "problem": "You are given a rectangular grid (the board) with some squares missing. A rook placed on a square attacks all other squares in the same row and in the same column. A set of rooks is non-attacking if and only if no two rooks share a row or a column. Your task is to compute, for each provided board, the maximum number of non-attacking rooks that can be placed only on non-missing squares.\n\nFundamental base: Use the standard definitions from discrete mathematics and algorithm design. Specifically, use that a valid placement is a subset of pairs of row and column indices with the property that (i) each chosen pair corresponds to an existing (not missing) square, and (ii) all chosen pairs have distinct row indices and distinct column indices. A partial placement is a set of such pairs not violating these constraints. The search space is the set of all partial placements ordered by extension. A pruning rule is valid if it provably cannot eliminate any optimal complete placement.\n\nProblem requirements:\n- Design and implement a systematic search over partial placements that respects the above constraints at every step and prunes branches that cannot lead to an optimal solution by using a sound upper bound derived from the number of remaining rows and columns that can still accept a rook.\n- Input is embedded in the program as a set of test boards (there is no external input).\n- Squares are encoded using characters: a period '.' denotes an available square and a hash '#' denotes a missing square.\n- For a board with $R$ rows and $C$ columns, the output for that board must be the maximum cardinality of a non-attacking set of rooks, expressed as an integer.\n\nTest suite:\nFor each of the following cases, compute the maximum number of non-attacking rooks. Each case is a list of $R$ strings of length $C$.\n\n- Case $1$ (happy path, mixed availability, rectangular $4 \\times 5$):\n  - $R = 4$, $C = 5$\n  - Grid:\n    - \".#...\"\n    - \"..#.#\"\n    - \"#..#.\"\n    - \".....\"\n- Case $2$ (boundary, no placement possible, $1 \\times 1$ all missing):\n  - $R = 1$, $C = 1$\n  - Grid:\n    - \"#\"\n- Case $3$ (boundary, smallest nontrivial, $1 \\times 1$ available):\n  - $R = 1$, $C = 1$\n  - Grid:\n    - \".\"\n- Case $4$ (full board, square $5 \\times 5$):\n  - $R = 5$, $C = 5$\n  - Grid:\n    - \".....\"\n    - \".....\"\n    - \".....\"\n    - \".....\"\n    - \".....\"\n- Case $5$ (a whole column effectively unusable, square $4 \\times 4$):\n  - $R = 4$, $C = 4$\n  - Grid:\n    - \"..#.\"\n    - \"###.\"\n    - \".##.\"\n    - \".##.\"\n- Case $6$ (non-square with a fully blocked row, $3 \\times 5$):\n  - $R = 3$, $C = 5$\n  - Grid:\n    - \"..#..\"\n    - \"#####\"\n    - \".#.#.\"\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Concretely, for the above six cases, the program must print a single line of the form \"[x1,x2,x3,x4,x5,x6]\" where each $x_i$ is the integer answer for case $i$.", "solution": "The problem is assessed to be valid. The validation steps are as follows.\n\n### Step 1: Extract Givens\n- **Problem Domain**: Placement of non-attacking rooks on a rectangular grid with missing squares.\n- **Task**: Compute the maximum number of non-attacking rooks that can be placed on non-missing squares for several given boards.\n- **Definitions**:\n    - A rook on a square attacks all other squares in the same row and column.\n    - A set of rooks is non-attacking if no two rooks share a row or a column.\n    - A valid placement is a subset of pairs of row and column indices, say $(r, c)$, such that: (i) the square $(r, c)$ is not a missing square, and (ii) for any two chosen pairs $(r_1, c_1)$ and $(r_2, c_2)$, $r_1 \\neq r_2$ and $c_1 \\neq c_2$.\n    - A partial placement is a set of such pairs satisfying the constraints.\n    - The search space is the set of all partial placements.\n- **Algorithmic Requirements**:\n    - Employ a systematic search over partial placements (backtracking).\n    - The search must respect the placement constraints at every step.\n    - Pruning must be used to eliminate branches that cannot lead to an optimal solution. The pruning must be based on a sound upper bound derived from the number of remaining rows and columns.\n- **Input Specification**:\n    - Input is a set of test boards embedded in the program.\n    - Square encoding: `.` for available, `#` for missing.\n    - Let $R$ be the number of rows and $C$ be the number of columns.\n- **Output Specification**:\n    - For each board, the output is a single integer representing the maximum cardinality of a non-attacking set of rooks.\n    - The final program output must be a single line containing a comma-separated list of results enclosed in square brackets.\n- **Test Suite**: Six specific board configurations are provided.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is a classic combinatorial optimization problem from discrete mathematics and computer science. It is equivalent to finding the maximum matching in a bipartite graph. This is a well-established, scientifically sound problem.\n- **Well-Posed**: The problem is well-posed. It asks for the maximum of a finite set of integers (the possible numbers of non-attacking rooks), so a unique maximum value is guaranteed to exist.\n- **Objective**: The problem is stated using precise, objective, and formal mathematical language. The terms \"non-attacking\", \"valid placement\", and \"maximum cardinality\" are unambiguous.\n- **Completeness and Consistency**: The problem is self-contained. All necessary definitions, constraints, and test data are provided. There are no contradictions.\n- **Other Flaws**: The problem is not unrealistic, ill-posed, trivial, or unverifiable. It is a standard algorithmic challenge perfectly suited for the requested backtracking framework.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. A solution will be provided.\n\n### Principle-Based Solution Design\n\nThe problem requires finding the maximum number of non-attacking rooks on a grid with blocked squares. This problem is a direct application of the **maximum bipartite matching** problem.\n\n**1. Bipartite Graph Formulation**\n\nWe can model the grid as a bipartite graph $G = (U \\cup V, E)$, where:\n- The set of vertices $U$ represents the rows of the board, so $|U| = R$.\n- The set of vertices $V$ represents the columns of the board, so $|V| = C$.\n- An edge $(u_i, v_j) \\in E$ exists if and only if the square at row $i$ and column $j$ is available (i.e., not missing).\n\nA placement of non-attacking rooks corresponds to a **matching** in this graph. A matching is a subset of edges $M \\subseteq E$ where no two edges in $M$ share a common vertex. Since a rook placement at $(i, j)$ occupies row $i$ and column $j$, the non-attacking constraint means that each row and each column can be used at most once. This is precisely the definition of a matching, where each vertex has a degree of at most $1$.\n\nThe problem of finding the maximum number of non-attacking rooks is therefore equivalent to finding the cardinality of a **maximum matching** in the bipartite graph $G$.\n\n**2. Algorithmic Strategy: Backtracking with Pruning**\n\nAs required by the problem statement, we will use a backtracking algorithm, which performs a depth-first search on the state-space tree of partial placements.\n\n- **State Representation**: The state of our recursive search can be defined by the current row we are considering, `row_index`, and the set of columns that are already occupied by rooks. We can use a boolean array, `cols_used`, of size $C$ for this purpose.\n\n- **Recursive Search Function**: We define a function, say `backtrack(row_index, num_placed_rooks)`, which attempts to extend a partial solution of size `num_placed_rooks` by considering placements from `row_index` onwards.\n\n- **Base Case**: The recursion terminates when all rows have been considered, i.e., when `row_index` equals $R$. At this point, `num_placed_rooks` represents the size of a complete valid placement. We update our global maximum with this value if it is greater than the best one found so far.\n\n- **Recursive Step**: For the current `row_index`, we have two main choices:\n    1.  **Do not place a rook in this row**: We simply move to the next row by calling `backtrack(row_index + 1, num_placed_rooks)`.\n    2.  **Place a rook in this row**: We iterate through all columns $j \\in \\{0, 1, ..., C-1\\}$. If column $j$ is not yet used (`cols_used[j]` is false) and the square at `(row_index, j)` is available, we can place a rook there. This involves:\n        a. Marking column $j$ as used.\n        b. Recursively calling `backtrack(row_index + 1, num_placed_rooks + 1)`.\n        c. Upon return from the recursion (i.e., after exploring that entire branch), we must unmark column $j$ as used. This is the \"backtracking\" step, which allows column $j$ to be used in other branches of the search tree.\n\n- **Pruning with an Upper Bound**: To make the search efficient, we must prune branches that cannot lead to a better solution. Let `max_rooks_found` be the maximum number of rooks found in any complete placement so far. Before exploring a state `(row_index, num_placed_rooks)`, we can compute an optimistic upper bound on the total number of rooks we could achieve from this state.\n\nA simple and sound upper bound is `num_placed_rooks` plus the number of remaining rows, which is $R - \\text{row\\_index}$. This is because we can place at most one rook in each of the remaining rows.\n\nThe pruning condition is therefore:\nIf `num_placed_rooks + (R - row_index) = max_rooks_found`, we can safely prune the current branch, as it cannot possibly yield a solution better than the one we have already found.\n\nThis systematic search with pruning guarantees that we explore the entire valid search space and find the optimal solution, fulfilling all the problem's requirements.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the non-attacking rooks problem for a suite of test cases\n    using a backtracking algorithm with pruning.\n    \"\"\"\n\n    # Test suite provided in the problem description.\n    test_cases = [\n        # Case 1 (happy path, mixed availability, rectangular 4x5)\n        [\n            \".#...\",\n            \"..#.#\",\n            \"#..#.\",\n            \".....\"\n        ],\n        # Case 2 (boundary, no placement possible, 1x1 all missing)\n        [\n            \"#\"\n        ],\n        # Case 3 (boundary, smallest nontrivial, 1x1 available)\n        [\n            \".\"\n        ],\n        # Case 4 (full board, square 5x5)\n        [\n            \".....\",\n            \".....\",\n            \".....\",\n            \".....\",\n            \".....\"\n        ],\n        # Case 5 (a whole column effectively unusable, square 4x4)\n        [\n            \"..#.\",\n            \"###.\",\n            \".##.\",\n            \".##.\"\n        ],\n        # Case 6 (non-square with a fully blocked row, 3x5)\n        [\n            \"..#..\",\n            \"#####\",\n            \".#.#.\"\n        ]\n    ]\n\n    results = []\n    for board in test_cases:\n        if not board or not board[0]:\n            results.append(0)\n            continue\n        \n        R = len(board)\n        C = len(board[0])\n        \n        # Use a dictionary to store the mutable max_rooks value,\n        # which is a common pattern to handle nonlocal-like behavior.\n        # Python's nonlocal keyword works only for nested function scopes,\n        # and this structure provides more clarity.\n        state = {'max_rooks': 0}\n        \n        # Boolean array to track used columns. Using numpy as required.\n        cols_used = np.zeros(C, dtype=bool)\n\n        def backtrack(row_index, current_rooks):\n            \"\"\"\n            Recursive backtracking function to find the maximum number of non-attacking rooks.\n            \"\"\"\n            # Pruning step: If the current number of rooks plus the maximum possible\n            # future rooks (one per remaining row) is not better than the best\n            # we've found so far, then there is no need to continue this path.\n            if current_rooks + (R - row_index) = state['max_rooks']:\n                return\n\n            # Base case: if we have considered all rows\n            if row_index == R:\n                if current_rooks > state['max_rooks']:\n                    state['max_rooks'] = current_rooks\n                return\n            \n            # Recursive step:\n\n            # Option 1: Don't place a rook in the current row.\n            # Continue to the next row with the same number of rooks.\n            backtrack(row_index + 1, current_rooks)\n\n            # Option 2: Try to place a rook in the current row.\n            # Iterate through all columns for the current row.\n            for col_index in range(C):\n                # Check if the square is available and the column is not already used.\n                if board[row_index][col_index] == '.' and not cols_used[col_index]:\n                    # Place a rook\n                    cols_used[col_index] = True\n                    \n                    # Recurse to the next row with one more rook placed.\n                    backtrack(row_index + 1, current_rooks + 1)\n                    \n                    # Backtrack: un-place the rook to explore other possibilities.\n                    cols_used[col_index] = False\n\n        # Initial call to start the search from the first row with zero rooks placed.\n        backtrack(0, 0)\n        results.append(state['max_rooks'])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3212770"}, {"introduction": "We now move from a placement puzzle to the canonical subset sum problem, a cornerstone of combinatorial search. This variant [@problem_id:3212780] introduces additional layers of complexity, such as item colors and cardinality limits, which require a more sophisticated state representation in your recursive search. This problem will solidify your understanding of feasibility and sufficiency pruning while demonstrating how the search order is critical for satisfying specific optimization criteria, such as finding a lexicographically minimal solution.", "problem": "You are to design and implement a backtracking framework to solve a constrained variant of the subset sum decision problem. The foundational base for this problem is as follows. A subset sum formulation is defined over a finite set of items with nonnegative weights, where an item set is represented by an index set $\\{0,1,\\dots,n-1\\}$. Each item $i$ has an associated nonnegative integer weight $w_i \\in \\mathbb{Z}_{\\ge 0}$ and belongs to a color class given by a mapping $col(i)$ into a finite set of color labels $\\mathcal{C}$. A target sum $T \\in \\mathbb{Z}_{\\ge 0}$ is specified. The task is to determine a subset $S \\subseteq \\{0,\\dots,n-1\\}$ such that $\\sum_{i \\in S} w_i = T$ subject to the constraint that for each color class $c \\in \\mathcal{C}$, the subset $S$ contains at most $k$ items of color $c$, where $k \\in \\mathbb{Z}_{\\ge 0}$ is a uniform bound.\n\nYour program must implement a principled backtracking search that explores the binary decision tree over item indices in ascending order of indices, applying feasibility pruning rules grounded in the following well-tested facts of combinatorial search. First, feasibility pruning: any partial assignment whose current sum exceeds $T$ cannot be extended to a valid solution because all weights are nonnegative. Second, sufficiency pruning: if the sum of the current partial sum and an upper bound on the remaining attainable sum from items not yet considered is strictly less than $T$, then no extension can reach the target. You must ensure that the algorithm respects the color cardinality constraint, namely that for every color $c$, the count of indices from $S$ with $col(i)=c$ does not exceed $k$. If a valid subset exists, among all valid subsets the program must return the lexicographically smallest list of indices in increasing order. If no valid subset exists, return the empty list. Indices are zero-based, so the first item has index $0$.\n\nYour output for each test case must be the list of integer indices in increasing order that forms the chosen subset, or the empty list if no solution exists. The final output format must aggregate the results of all test cases into a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[result_1,result_2,result_3]$), where each $result_j$ is itself a list of integers (possibly empty).\n\nThe provided test suite consists of $6$ test cases covering a general case, boundary conditions, and edge cases. For each test case, the items are defined by arrays of weights and colors, and the parameters $T$ and $k$ are specified. The required output for each test case is a list of indices:\n\n- Test case $1$ (general happy path):\n  - Weights: $[3,7,2,5,8]$\n  - Colors: [red, blue, red, green, blue]\n  - Target: $T=10$\n  - Color bound: $k=2$\n  - Required output type: list of integers representing indices in increasing order that sum to $10$ subject to at most $2$ items per color; return the lexicographically smallest valid list.\n\n- Test case $2$ (boundary on color usage with $k=1$):\n  - Weights: $[4,4,4,4]$\n  - Colors: [red, red, blue, blue]\n  - Target: $T=8$\n  - Color bound: $k=1$\n  - Required output type: list of integers forming a valid subset.\n\n- Test case $3$ (color constraint critically limits feasibility):\n  - Weights: $[6,6,6]$\n  - Colors: [green, green, green]\n  - Target: $T=18$\n  - Color bound: $k=2$\n  - Required output type: empty list, because any subset summing to $18$ violates the color bound.\n\n- Test case $4$ (unreachable target due to weights):\n  - Weights: $[2,4,6]$\n  - Colors: [r, g, b]\n  - Target: $T=5$\n  - Color bound: $k=2$\n  - Required output type: empty list.\n\n- Test case $5$ (multiple solutions; choose lexicographically smallest):\n  - Weights: $[1,1,2,2,3,3]$\n  - Colors: [A, A, B, B, A, B]\n  - Target: $T=6$\n  - Color bound: $k=2$\n  - Required output type: lexicographically smallest valid list of indices.\n\n- Test case $6$ (edge case with $k=0$ and trivial target):\n  - Weights: $[5,3]$\n  - Colors: [x, y]\n  - Target: $T=0$\n  - Color bound: $k=0$\n  - Required output type: empty list, representing the empty subset which is valid and sums to $0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[[i_0,i_1],[j_0,j_1,j_2],[]]$, with the exact computed lists for the $6$ cases in order $1$ through $6$.", "solution": "The problem posed is a constrained variant of the subset sum problem, a classic topic in combinatorial optimization and algorithmics. A rigorous solution must be built upon a sound backtracking framework that systematically explores the solution space while aggressively pruning non-viable search paths.\n\n### Principle-Based Design\n\n**1. Formal Problem Definition**\n\nLet the set of items be indexed by $I = \\{0, 1, \\dots, n-1\\}$. Each item $i \\in I$ is characterized by a non-negative integer weight $w_i \\in \\mathbb{Z}_{\\ge 0}$ and a color $c_i$ from a finite set of colors $\\mathcal{C}$. Given a non-negative integer target sum $T \\in \\mathbb{Z}_{\\ge 0}$ and a uniform non-negative integer bound $k \\in \\mathbb{Z}_{\\ge 0}$ for color cardinality, the objective is to find a subset of indices $S \\subseteq I$ that is lexicographically minimal among all subsets satisfying two primary conditions:\n\n1.  **Sum Constraint**: The sum of the weights of the items in the subset must equal the target sum: $\\sum_{i \\in S} w_i = T$.\n2.  **Color Constraint**: For any given color $c \\in \\mathcal{C}$, the number of items in the subset $S$ having that color must not exceed the bound $k$. Formally, for every $c \\in \\mathcal{C}$, $|\\{i \\in S \\mid c_i = c\\}| \\le k$.\n\nIf no subset $S$ satisfies these conditions, the problem requires returning an empty list.\n\n**2. Backtracking Framework**\n\nThe search space for this problem consists of all $2^n$ possible subsets of the item set $I$. An exhaustive search is computationally intractable. Backtracking provides a methodical approach to navigate this space, which can be modeled as a binary decision tree of depth $n$. At each level $i$ (from $0$ to $n-1$) of the tree, a decision is made for item $i$: either include it in the candidate solution set or exclude it. The algorithm performs a depth-first traversal of this tree.\n\nTo implement this, we define a recursive function, `backtrack`, whose state captures the progress of the search. The essential parameters for the state at each recursive call are:\n- $i$: The index of the current item being considered for inclusion or exclusion.\n- $W_{curr}$: The sum of weights of items chosen so far in the current path of the search tree.\n- $S_{curr}$: A list representing the partial solution, containing the indices of items chosen so far.\n- $C_{counts}$: A data structure, such as a hash map, that stores the count of items for each color present in $S_{curr}$.\n\n**3. Recursive Logic and Pruning**\n\nThe core of the `backtrack` function consists of base cases, pruning rules, and recursive steps.\n\n**Base Cases:**\n- **Solution Found**: If at any point $W_{curr}$ becomes equal to $T$, a valid solution has been found with the items in $S_{curr}$. Because the search is structured to find the lexicographically smallest solution first, the algorithm can immediately terminate and adopt $S_{curr}$ as the final answer.\n- **Search Exhausted**: If the index $i$ reaches $n$, all items have been considered. If $W_{curr} \\neq T$, this particular search path is a dead end, and the recursion must unwind (backtrack).\n\n**Pruning Strategies:**\nTo avoid exploring futile branches of the search tree, two pruning rules are applied:\n1.  **Feasibility Pruning**: Since all weights are non-negative ($w_i \\ge 0$), if $W_{curr}$ ever exceeds $T$, it is impossible for the sum to decrease. Therefore, any path where $W_{curr} > T$ is immediately abandoned.\n2.  **Sufficiency Pruning**: An optimistic bound can be used to prune paths that cannot possibly reach the target $T$. Let $W_{rem}(i) = \\sum_{j=i}^{n-1} w_j$ be the sum of weights of all remaining items from index $i$ onwards. If the current sum plus this remaining possible sum is less than the target (i.e., $W_{curr} + W_{rem}(i)  T$), then this path cannot be extended to a valid solution. To apply this rule efficiently, the suffix sums $W_{rem}(i)$ for all $i$ are pre-computed.\n\n**4. Lexicographical Minimality and Recursive Step**\n\nThe requirement for the lexicographically smallest solution dictates the search order. The algorithm considers items in ascending order of their indices ($i=0, 1, \\dots, n-1$). At each step $i$, it must prioritize the decision to **include** item $i$ over the decision to **exclude** it. This ensures that if a solution exists, the first one found will be composed of the smallest possible indices, making it lexicographically minimal.\n\nThe recursive step is as follows:\n\n1.  **Try to Include Item $i$**:\n    a. Check if including item $i$ is valid with respect to the color constraint. The count of items with color $c_i$ in the current solution, $C_{counts}[c_i]$, must be strictly less than $k$.\n    b. If valid, update the state: increment $W_{curr}$ by $w_i$, append $i$ to $S_{curr}$, and increment $C_{counts}[c_i]$.\n    c. Make a recursive call: `backtrack(i+1, ...)`.\n    d. After the call returns, revert the state changes (i.e., backtrack) to prepare for exploring the \"exclude\" branch.\n    e. If the recursive call found a solution, a flag is set to terminate all other ongoing and future recursive calls.\n\n2.  **Try to Exclude Item $i$**:\n    a. If and only if the \"include\" branch did not lead to a solution, the algorithm proceeds to explore the \"exclude\" possibility.\n    b. The state remains unchanged except for the index.\n    c. Make a recursive call: `backtrack(i+1, ...)`.\n\nThis disciplined exploration, combined with pruning, forms a correct and efficient algorithm for solving the stated problem. The base case where $T=0$ is handled separately: the empty set is a valid solution, as its sum is $0$ and it contains $0$ items of every color, satisfying the color constraint for any $k \\ge 0$. It is also trivially the lexicographically smallest solution.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    class ConstrainedSubsetSumSolver:\n        \"\"\"\n        A solver for the constrained subset sum problem using a backtracking framework.\n        \"\"\"\n        def __init__(self, weights, colors, target, k_bound):\n            self.weights = weights\n            self.colors = colors\n            self.target = target\n            self.k_bound = k_bound\n            self.n = len(weights)\n            \n            self.solution = []\n            self.found_solution = False\n            \n            # Pre-compute suffix sums for sufficiency pruning.\n            # self.suffix_sums[i] stores the sum of weights from index i to n-1.\n            self.suffix_sums = [0] * (self.n + 1)\n            for i in range(self.n - 1, -1, -1):\n                self.suffix_sums[i] = self.suffix_sums[i + 1] + self.weights[i]\n\n        def solve(self):\n            \"\"\"\n            Initializes and starts the backtracking search.\n            Returns the lexicographically smallest solution or an empty list.\n            \"\"\"\n            # The empty set is the valid, lexicographically smallest solution for T=0.\n            if self.target == 0:\n                return []\n\n            unique_colors = set(self.colors)\n            color_counts = {c: 0 for c in unique_colors}\n            \n            self._backtrack(0, 0, [], color_counts)\n            \n            return self.solution\n\n        def _backtrack(self, index, current_sum, current_path, color_counts):\n            \"\"\"\n            The core recursive backtracking function.\n            \"\"\"\n            # If a solution has been found, terminate this branch.\n            if self.found_solution:\n                return\n\n            # --- Base cases ---\n            # 1. Success: A valid solution is found.\n            if current_sum == self.target:\n                self.solution = list(current_path)\n                self.found_solution = True\n                return\n\n            # 2. Failure: All items considered but target not met.\n            if index == self.n:\n                return\n\n            # --- Pruning rules ---\n            # 1. Feasibility pruning: Current sum exceeds target.\n            if current_sum > self.target:\n                return\n            \n            # 2. Sufficiency pruning: Not enough remaining weight to reach target.\n            if current_sum + self.suffix_sums[index]  self.target:\n                return\n\n            # --- Recursive step ---\n            # To find the lexicographically smallest solution, we explore the \"include\"\n            # branch before the \"exclude\" branch.\n\n            # Choice 1: Include item `index`\n            item_weight = self.weights[index]\n            item_color = self.colors[index]\n            \n            if color_counts[item_color]  self.k_bound:\n                # Add item to the current path\n                current_path.append(index)\n                color_counts[item_color] += 1\n                \n                # Recurse\n                self._backtrack(index + 1, current_sum + item_weight, current_path, color_counts)\n                \n                # Backtrack: remove item from the current path\n                color_counts[item_color] -= 1\n                current_path.pop()\n\n                # If the \"include\" branch found a solution, we are done.\n                if self.found_solution:\n                    return\n\n            # Choice 2: Exclude item `index`\n            # This is explored only if the \"include\" branch did not find a solution.\n            self._backtrack(index + 1, current_sum, current_path, color_counts)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: General happy path\n        {'weights': [3, 7, 2, 5, 8], 'colors': ['red', 'blue', 'red', 'green', 'blue'], 'T': 10, 'k': 2},\n        # Test Case 2: Boundary on color usage with k=1\n        {'weights': [4, 4, 4, 4], 'colors': ['red', 'red', 'blue', 'blue'], 'T': 8, 'k': 1},\n        # Test Case 3: Color constraint critically limits feasibility\n        {'weights': [6, 6, 6], 'colors': ['green', 'green', 'green'], 'T': 18, 'k': 2},\n        # Test Case 4: Unreachable target due to weights\n        {'weights': [2, 4, 6], 'colors': ['r', 'g', 'b'], 'T': 5, 'k': 2},\n        # Test Case 5: Multiple solutions, choose lexicographically smallest\n        {'weights': [1, 1, 2, 2, 3, 3], 'colors': ['A', 'A', 'B', 'B', 'A', 'B'], 'T': 6, 'k': 2},\n        # Test Case 6: Edge case with k=0 and trivial target\n        {'weights': [5, 3], 'colors': ['x', 'y'], 'T': 0, 'k': 0},\n    ]\n\n    results = []\n    for case in test_cases:\n        solver = ConstrainedSubsetSumSolver(case['weights'], case['colors'], case['T'], case['k'])\n        result = solver.solve()\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # e.g., [[0,1],[0,2],[]]\n    formatted_results = []\n    for res in results:\n        res_str = f\"[{','.join(map(str, res))}]\"\n        formatted_results.append(res_str)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3212780"}, {"introduction": "Building on decision and selection problems, this practice tackles a pure optimization challenge: partitioning a set of numbers to minimize the range of subset sums. The primary pedagogical goal is to introduce and apply symmetry reduction, a crucial technique for making backtracking efficient by eliminating redundant explorations of equivalent solutions [@problem_id:3212818]. By solving this, you will learn how to identify and break symmetries in the search space, a skill essential for tackling complex combinatorial optimization tasks.", "problem": "You are given a finite multiset of nonnegative integers represented as a sequence $\\{a_1, a_2, \\dots, a_n\\}$ and an integer $k$ with $1 \\le k \\le n$. A valid solution is a partition of all elements into exactly $k$ nonempty, pairwise disjoint subsets whose union is the entire multiset. Let the subset sums be $s_1, s_2, \\dots, s_k$. The objective is to minimize the range $R = \\max_{1 \\le j \\le k} s_j - \\min_{1 \\le j \\le k} s_j$. The task is to design and implement a program that computes the minimal possible value of $R$ using the backtracking framework with principled pruning and symmetry reduction, starting from the fundamental definitions of search over a state-space tree and constraints on feasible assignments. Your program must not read any input; instead, it must solve the following test suite and produce a single aggregated output.\n\nDefinitions and constraints:\n- The multiset elements $\\{a_1, \\dots, a_n\\}$ are nonnegative integers, and $1 \\le k \\le n$.\n- A partition into $k$ subsets is valid if and only if every subset is nonempty and the subsets are pairwise disjoint with union equal to the original multiset.\n- For any partial assignment of the first $i$ elements, let the current subset sums be a vector $(t_1, \\dots, t_k)$; let the remaining total to assign be $T_{\\mathrm{rem}} = \\sum_{j=i+1}^n a_j$. A backtracking node may be pruned only when you can derive a rigorous lower bound on the best achievable objective from that node that is no better than the best solution already found.\n\nTest suite:\n- Test case $1$: $S = \\{3,1,4,2,2\\}$, $k = 2$.\n- Test case $2$: $S = \\{5,7,9\\}$, $k = 1$.\n- Test case $3$: $S = \\{10,10,9,1\\}$, $k = 3$.\n- Test case $4$: $S = \\{8,1,2,3\\}$, $k = 3$.\n- Test case $5$: $S = \\{1,2,3,4\\}$, $k = 4$.\n\nYour program must compute, for each test case, the minimal attainable range $R$ as an integer. The final output must be a single line containing a comma-separated list of the $5$ results enclosed in square brackets, in the order of the test cases above. For example, if the results are $v_1, v_2, v_3, v_4, v_5$, the program must print a single line in the exact format \"[v1,v2,v3,v4,v5]\".", "solution": "The problem presented is a valid combinatorial optimization problem, formally known as the multiway number partitioning problem, which seeks to partition a multiset of numbers into a fixed number of subsets to minimize a specific objective function, in this case, the range of the subset sums. The problem is well-posed, scientifically grounded in computer science and discrete mathematics, and all provided definitions and constraints are self-contained and consistent.\n\nThe task is to find a partition of a multiset $S = \\{a_1, a_2, \\dots, a_n\\}$ of $n$ nonnegative integers into exactly $k$ nonempty subsets, such that the range of the sums of these subsets is minimized. Let the subsets be $S_1, S_2, \\dots, S_k$. Their sums are $s_j = \\sum_{a \\in S_j} a$. The objective is to minimize $R = \\max_{j} s_j - \\min_{j} s_j$. This problem is NP-hard, implying that no known algorithm can solve it in polynomial time for the general case. A backtracking algorithm provides a systematic way to explore the entire search space of possible partitions and is guaranteed to find the optimal solution. To make this approach computationally feasible for the given test cases, we must incorporate principled pruning and symmetry reduction techniques.\n\nThe core of the solution is a recursive backtracking function that explores the state-space tree of partial assignments. A state in this search is defined by $(i, \\vec{t})$, where $i$ is the index of the next element from the multiset $S$ to be assigned, and $\\vec{t} = (t_1, t_2, \\dots, t_k)$ is a vector representing the current sums of the $k$ subsets.\n\nThe algorithm proceeds as follows:\n\n1.  **Initialization and Heuristics**: The multiset $S$ is first sorted in descending order. This is a powerful heuristic. Placing larger elements first tends to create larger imbalances in subset sums early on, which allows the algorithm to establish a reasonably good upper bound on the minimal range quickly. A tighter bound enables more aggressive pruning of the search space. The minimal range found so far, $R_{\\text{best}}$, is initialized to a large value, such as the total sum of all elements, $\\sum_{i=1}^n a_i$.\n\n2.  **Recursive State Exploration**: The backtracking function, say `backtrack(i, t)`, works as follows:\n    *   **Base Case**: When the index $i$ reaches $n$, all elements have been assigned to a subset. This corresponds to a leaf node in the search tree and represents a complete partition. The range for this partition, $R = \\max(\\vec{t}) - \\min(\\vec{t})$, is calculated. If this range is better than the best range found so far ($R  R_{\\text{best}}$), $R_{\\text{best}}$ is updated to $R$.\n    *   **Recursive Step**: For the element $a_i$ at the current index $i$, the function iterates through each of the $k$ subsets. For each subset $j \\in \\{1, \\dots, k\\}$, it tentatively places $a_i$ into subset $j$ by updating its sum, $t'_j = t_j + a_i$. It then makes a recursive call, `backtrack(i+1, t')`, to assign the next element. After the recursive call returns, it must \"undo\" the placement by restoring the sum, $t_j = t'_j - a_i$, to explore other possibilities for element $a_i$.\n\n3.  **Pruning (Bounding)**: The efficiency of backtracking hinges on its ability to \"prune\" subtrees that cannot possibly lead to a solution better than the current best. At any node $(i, \\vec{t})$, we can calculate the current range of partial sums, $R_{\\text{current}} = \\max(\\vec{t}) - \\min(\\vec{t})$. Since all elements $a_i$ are nonnegative, the sums of the subsets can only increase or stay the same as more elements are added. Consequently, the range of sums is a non-decreasing function as we descend the search tree. This gives us a rigorous lower bound: the final range for any complete partition derived from the current node will be at least $R_{\\text{current}}$. Therefore, if at any point $R_{\\text{current}} \\ge R_{\\text{best}}$, we can immediately prune the current branch, as it cannot yield a better solution.\n\n4.  **Symmetry Reduction**: The $k$ subsets are indistinguishable. For example, with elements $\\{a, b\\}$ and $k=2$, the partition $\\{\\{a\\}, \\{b\\}\\}$ is identical to $\\{\\{b\\}, \\{a\\}\\}$. Exploring both is redundant. To eliminate such symmetric states, we can enforce an arbitrary ordering constraint on how subsets are formed. A standard method is to stipulate that a new element can only be placed into the *first* empty subset. In our state representation where subsets are indexed $j=1, \\dots, k$, if subsets $1, \\dots, m$ are non-empty (have sums $t_j > 0$) and subset $m+1$ is empty ($t_{m+1} = 0$), we only consider placing the current element $a_i$ into one of the subsets $1, \\dots, m, m+1$. This is implemented by breaking the loop over subsets as soon as we backtrack from placing an element into a previously empty subset. That is, if `backtrack` is called after placing $a_i$ in subset $j$ where $t_j$ was previously $0$, we do not proceed to try placing $a_i$ in subset $j+1, \\dots, k$. This ensures that subset $j$ is populated only if subsets $1, \\dots, j-1$ are already populated, effectively breaking the symmetry. With $k \\le n$, this strategy also implicitly satisfies the problem constraint that all $k$ subsets must be nonempty in any valid final partition found at a leaf node.\n\nBy combining these principles—a recursive search structured by backtracking, a descending sort heuristic, lower-bound pruning, and symmetry reduction—we construct an algorithm that correctly and efficiently finds the minimal range for the given partitioning problem.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass PartitionSolver:\n    \"\"\"\n    Solves the k-partition problem to minimize the range of subset sums\n    using a backtracking algorithm with pruning and symmetry reduction.\n    \"\"\"\n    def __init__(self, s, k):\n        # Sort the multiset in descending order as a heuristic to find good\n        # solutions early and improve pruning effectiveness.\n        self.s = sorted(s, reverse=True)\n        self.k = k\n        self.n = len(self.s)\n        # Initialize the best-found range to a loose upper bound (the total sum).\n        self.min_range = sum(self.s)\n\n    def find_min_range(self):\n        \"\"\"\n        Public method to initiate the search for the minimal range.\n        Handles trivial cases and starts the backtracking search.\n        \"\"\"\n        # If there's only one subset, the range is always 0.\n        if self.k == 1:\n            return 0\n        \n        # This condition is guaranteed not to occur by the problem statement,\n        # but is good practice for a general solver.\n        if self.k > self.n:\n            # It's impossible to have k non-empty subsets.\n            return -1  # Or raise an error\n\n        # subset_sums[j] will store the sum of elements in the j-th subset.\n        subset_sums = np.zeros(self.k, dtype=int)\n        \n        # Start the recursive search from the first element (index 0).\n        self.backtrack(0, subset_sums)\n        \n        return self.min_range\n\n    def backtrack(self, element_index, subset_sums):\n        \"\"\"\n        The recursive backtracking function.\n        \n        Args:\n            element_index: The index of the current element in self.s to be placed.\n            subset_sums: A numpy array of the current sums of the k subsets.\n        \"\"\"\n        # --- Pruning Step ---\n        # Calculate the current range of sums.\n        current_range = np.max(subset_sums) - np.min(subset_sums)\n        \n        # If the current range is already worse than or equal to the best one found so\n        # far, this path cannot lead to a better solution. Prune the search here.\n        if current_range >= self.min_range:\n            return\n\n        # --- Base Case ---\n        # If all elements have been placed, we have a complete partition.\n        if element_index == self.n:\n            # The current_range is the final range for this partition.\n            # Update the global minimum if this partition is better.\n            self.min_range = min(self.min_range, current_range)\n            return\n\n        # --- Recursive Step ---\n        current_element = self.s[element_index]\n        \n        # Try placing the current element in each of the k subsets.\n        for i in range(self.k):\n            # Place the element.\n            subset_sums[i] += current_element\n            \n            # Recur for the next element.\n            self.backtrack(element_index + 1, subset_sums)\n            \n            # Backtrack: remove the element to explore other possibilities.\n            subset_sums[i] -= current_element\n            \n            # --- Symmetry Reduction ---\n            # If the subset was empty before we added the element, it means we have\n            # just explored the branch where we start a new subset. To avoid\n            # symmetric solutions, we do not need to try starting another new\n            # subset with this same element. We enforce an implicit order on filling\n            # empty subsets.\n            if subset_sums[i] == 0:\n                break\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the solver for each case,\n    and prints the aggregated results in the specified format.\n    \"\"\"\n    test_cases = [\n        {'S': [3, 1, 4, 2, 2], 'k': 2},\n        {'S': [5, 7, 9], 'k': 1},\n        {'S': [10, 10, 9, 1], 'k': 3},\n        {'S': [8, 1, 2, 3], 'k': 3},\n        {'S': [1, 2, 3, 4], 'k': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        s_list = case['S']\n        k_val = case['k']\n        solver = PartitionSolver(s_list, k_val)\n        result = solver.find_min_range()\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3212818"}]}