{"hands_on_practices": [{"introduction": "To truly master an algorithm, you must understand its step-by-step execution. This first exercise challenges you to do just that by simulating the `buildHeap` procedure on a given array. By tracking a specific element's journey from its initial position to its final place in the max-heap, you will solidify your understanding of the `sift_down` mechanism and the bottom-up construction process [@problem_id:3219649].", "problem": "You are given the task of predicting the final position in an array of the element that starts at a specified index after a bottom-up heap construction is performed. The structure in question is a binary max-heap represented as an array with zero-based indexing. The heap property requires that for every index $j$ with children, the key at index $j$ is greater than or equal to the key at each of its children. The array-to-tree mapping is as follows: for any index $j$, its left child (if it exists) is at index $2j + 1$, and its right child (if it exists) is at index $2j + 2$. The parent of any index $k > 0$ is at index $\\left\\lfloor \\dfrac{k - 1}{2} \\right\\rfloor$.\n\nStart only from fundamental definitions: the binary heap property, the array representation mapping described above, and the definition of a comparison-based heap as a partial order induced by key comparisons. Consider the standard bottom-up heap construction procedure that enforces the heap property by repeated local restorations using downward adjustments from internal nodes to the leaves. Assume the following deterministic comparison and tie-handling rules during the downward adjustment of a node at index $j$:\n- Among the existing children, consider the child with the greatest key. If both children exist and their keys are equal, select the left child at index $2j + 1$.\n- Perform a swap between the node at $j$ and the selected child only if the selected child's key is strictly greater than the node's key.\n- Continue the process at the child index where the swap occurred, and stop when no swap is needed or when a leaf is reached.\n\nThe bottom-up construction visits indices in descending order from the last internal node down to the root. The last internal node is at index $\\left\\lfloor \\dfrac{n - 2}{2} \\right\\rfloor$ where $n$ is the array length. For each visited index $j$ in this order, the downward adjustment described above is executed starting at $j$.\n\nYour program must determine, for each given pair consisting of an array of integers and an initial index $i$, the final index position of the element that started at index $i$ after the heap has been fully constructed. The identity of an element must be tracked by its original index, not by its key value, so that duplicate keys are handled correctly.\n\nUse zero-based indexing throughout. The result for each case is an integer index. No physical units or angles are involved.\n\nImplement a complete, runnable program that uses the following test suite, and produce the final positions as a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases. Each array is written literally, and each index $i$ is specified. The test suite is:\n- Case $1$: array $[\\,3,\\,1,\\,6,\\,5,\\,2,\\,4\\,]$, $i = 1$.\n- Case $2$: array $[\\,9,\\,7,\\,8,\\,3,\\,2,\\,1,\\,5\\,]$, $i = 6$.\n- Case $3$: array $[\\,1,\\,2,\\,3,\\,4\\,]$, $i = 0$.\n- Case $4$: array $[\\,1,\\,2,\\,2\\,]$, $i = 0$.\n- Case $5$: array $[\\,10,\\,9,\\,8,\\,7,\\,6,\\,5\\,]$, $i = 4$.\n- Case $6$: array $[\\,2,\\,2,\\,2,\\,2\\,]$, $i = 2$.\n- Case $7$: array $[\\,1,\\,2\\,]$, $i = 1$.\n- Case $8$: array $[\\,{-3},\\,{-1},\\,{-2}\\,]$, $i = 0$.\n- Case $9$: array $[\\,0,\\,1,\\,2,\\,3,\\,4,\\,5,\\,6\\,]$, $i = 6$.\n- Case $10$: array $[\\,7\\,]$, $i = 0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,\\dots,r_{10}]$), where each $r_k$ is the final index for Case $k$.", "solution": "The problem requires determining the final index of an element, initially at a given index $i$, after a standard bottom-up max-heap construction (heapify) is performed on an array. The process is deterministic due to the precise rules provided for heap operations.\n\nTo solve this, we must simulate the heap construction process while tracking the position of the specific element of interest. Since the array may contain duplicate key values, an element's identity must be tied to its original position. We achieve this by transforming the input array of keys, say `arr`, into an augmented array of pairs. Each element at index $k$ in the original array is represented as a tuple $(key, original\\_index)$, which is $(arr[k], k)$. All subsequent operations are performed on this augmented array.\n\nThe heap construction algorithm, often called `build_heap`, operates on an array of size $n$. It iterates through the internal nodes of the would-be binary tree in reverse order, from the last parent node down to the root. The index of the last parent node in a zero-based array is given by $\\left\\lfloor \\dfrac{n - 2}{2} \\right\\rfloor$. The loop proceeds from this index down to $0$. For each index $j$ in this range, a downward adjustment procedure, `sift_down`, is called to enforce the max-heap property for the subtree rooted at $j$.\n\nThe `sift_down(j)` procedure is the core of the heap construction. It ensures that the element at index $j$ is correctly placed within its subtree. The procedure is as follows:\n1.  Let the current node be at index `root`, initially $j$.\n2.  Identify the node's children. The left child is at index $2 \\cdot \\text{root} + 1$ and the right child is at $2 \\cdot \\text{root} + 2$.\n3.  Select the child with the greatest key. According to the specified rules:\n    - If both children exist and their keys are equal, the left child (at $2 \\cdot \\text{root} + 1$) is chosen.\n    - Otherwise, the child with the strictly greater key is chosen.\n4.  If the selected child's key is strictly greater than the key of the current node at `root`, a swap is performed between the node and the selected child.\n5.  If a swap occurred, the `sift_down` process continues recursively (or iteratively) from the child's index, which now holds the element that was originally at `root`.\n6.  The process terminates when the current node's key is greater than or equal to its children's keys, or when a leaf node is reached (i.e., it has no children).\n\nBy applying this `build_heap` procedure to the augmented array, the elements (including their original indices) are rearranged to satisfy the max-heap property. After the algorithm completes, the final array is a valid max-heap. The final position of the tracked element is found by searching this final array for the tuple whose `original_index` matches the given initial index $i$.\n\nLet us trace Case 3: array $[\\,1,\\,2,\\,3,\\,4\\,]$, with the element to track starting at index $i = 0$.\n- The initial array of keys is $[\\,1,\\,2,\\,3,\\,4\\,]$. The size is $n = 4$. We track the element with original index $0$.\n- The augmented array is $A = [\\,(1, 0),\\,(2, 1),\\,(3, 2),\\,(4, 3)\\,]$.\n- The `build_heap` process starts from the last parent node at index $\\left\\lfloor \\dfrac{4 - 2}{2} \\right\\rfloor = 1$. The loop will execute for $j=1$ and then $j=0$.\n\n- **Step 1: `sift_down(1)`**\n  - The node at index $1$ is $(2, 1)$. Its left child is at index $2(1) + 1 = 3$, which is $(4, 3)$. There is no right child.\n  - The child's key, $4$, is strictly greater than the node's key, $2$. A swap is performed.\n  - The array becomes $A = [\\,(1, 0),\\,(4, 3),\\,(3, 2),\\,(2, 1)\\,]$.\n  - The process continues from the new position of $(2, 1)$, which is index $3$. This is a leaf node, so `sift_down(1)` terminates.\n\n- **Step 2: `sift_down(0)`**\n  - The node at index $0$ is $(1, 0)$. Its children are at indices $1$ and $2$: $(4, 3)$ and $(3, 2)$.\n  - The child with the greatest key is $(4, 3)$ at index $1$.\n  - This child's key, $4$, is strictly greater than the node's key, $1$. A swap is performed.\n  - The array becomes $A = [\\,(4, 3),\\,(1, 0),\\,(3, 2),\\,(2, 1)\\,]$.\n  - The process continues from the new position of $(1, 0)$, which is index $1$.\n  - Now at index $1$, the node is $(1, 0)$. Its left child is at index $2(1) + 1 = 3$, which is $(2, 1)$.\n  - The child's key, $2$, is strictly greater than the node's key, $1$. A swap is performed.\n  - The array becomes $A = [\\,(4, 3),\\,(2, 1),\\,(3, 2),\\,(1, 0)\\,]$.\n  - The process continues from index $3$, which is a leaf. The procedure terminates.\n\n- **Final State:** The heap construction is complete. The final array is $A = [\\,(4, 3),\\,(2, 1),\\,(3, 2),\\,(1, 0)\\,]$.\n- We search for the element with original index $0$, which is the tuple $(1, 0)$. It is located at index $3$.\n- Thus, the final position for Case 3 is $3$.\n\nThis deterministic procedure is implemented and applied to all test cases to obtain the final results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sift_down(arr, root_idx, heap_size):\n    \"\"\"\n    Performs the downward adjustment for a max-heap.\n\n    This function takes an array of (key, original_index) tuples and ensures\n    the subtree rooted at root_idx satisfies the max-heap property.\n    This implementation follows the specific deterministic rules from the problem.\n    \"\"\"\n    root = root_idx\n    while True:\n        # Determine the index of the child to potentially swap with.\n        largest_child_idx = -1\n        left_child_idx = 2 * root + 1\n        right_child_idx = 2 * root + 2\n\n        # Start by assuming the left child is the largest, if it exists.\n        if left_child_idx < heap_size:\n            largest_child_idx = left_child_idx\n\n        # If the right child exists and is greater than the current largest, update.\n        # This handles the tie-breaking rule: if keys are equal, left child is preferred.\n        if right_child_idx < heap_size and arr[right_child_idx][0] > arr[largest_child_idx][0]:\n            largest_child_idx = right_child_idx\n        \n        # If there are no children, the process stops.\n        if largest_child_idx == -1:\n            break\n\n        # Perform swap only if the selected child's key is strictly greater.\n        if arr[largest_child_idx][0] > arr[root][0]:\n            arr[root], arr[largest_child_idx] = arr[largest_child_idx], arr[root]\n            # Continue sifting down from the new position.\n            root = largest_child_idx\n        else:\n            # The heap property holds for this subtree, so stop.\n            break\n\ndef build_heap(arr):\n    \"\"\"\n    Constructs a max-heap in-place from an array of (key, original_index) tuples.\n    \"\"\"\n    n = len(arr)\n    # The last parent node is at index floor((n - 2) / 2). Integer division // performs floor.\n    start_idx = (n - 2) // 2\n    for i in range(start_idx, -1, -1):\n        sift_down(arr, i, n)\n\ndef find_final_position(initial_array, tracked_original_index):\n    \"\"\"\n    Simulates the heap build and finds the final position of a tracked element.\n    \"\"\"\n    n = len(initial_array)\n    if n == 0:\n        return -1 # Should not happen with given test cases\n\n    # Create an augmented array to track elements by original index.\n    # Each element is a tuple: (key, original_index).\n    augmented_arr = [(initial_array[i], i) for i in range(n)]\n\n    # Build the max-heap in-place.\n    build_heap(augmented_arr)\n\n    # Find the final index of the element we are tracking.\n    for i in range(n):\n        if augmented_arr[i][1] == tracked_original_index:\n            return i\n            \n    return -1 # Should not be reached if tracked_original_index is valid.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        ([3, 1, 6, 5, 2, 4], 1),\n        ([9, 7, 8, 3, 2, 1, 5], 6),\n        ([1, 2, 3, 4], 0),\n        ([1, 2, 2], 0),\n        ([10, 9, 8, 7, 6, 5], 4),\n        ([2, 2, 2, 2], 2),\n        ([1, 2], 1),\n        ([-3, -1, -2], 0),\n        ([0, 1, 2, 3, 4, 5, 6], 6),\n        ([7], 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        arr, tracked_idx = case\n        result = find_final_position(arr, tracked_idx)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3219649"}, {"introduction": "After understanding how `buildHeap` works, a natural next question is: what is its worst-case performance? This practice moves from simulation to adversarial thinking, asking you to construct an input array that forces the `buildHeap` algorithm to perform the maximum number of swaps. By comparing your generated cost to the theoretical maximum, you will gain a concrete understanding of the algorithm's linear-time complexity and the structure of inputs that elicit this worst-case behavior [@problem_id:3219678].", "problem": "You are given the array-based representation of a binary max-heap over $n$ distinct keys, where indices start at $1$ and children of a node at index $i$ are at indices $2i$ and $2i+1$ whenever those indices are at most $n$. Consider Floyd’s bottom-up heap construction (also known as “build-heap”), which calls the sift-down operation on each internal node $i$ from $i=\\left\\lfloor n/2 \\right\\rfloor$ down to $i=1$. Define the cost of one sift-down as the number of parent-child exchanges performed along the path that the element traverses until the heap property is restored at that position. The total cost of build-heap is the sum of these exchanges over all internal nodes.\n\nStarting from the core definitions of heaps, array index arithmetic, and Floyd’s build-heap procedure, derive a principled adversarial input generator that, for any given $n$, produces a permutation of $\\{1,2,\\dots,n\\}$ that maximizes the total number of parent-child exchanges performed by build-heap. Prove theoretical bounds describing the proximity of the generator’s achieved cost to the worst-case cost, expressed in terms of the heap’s shape parameters.\n\nYou must start from the following fundamental base:\n- The binary heap shape invariant: the underlying tree is the unique complete binary tree on $n$ nodes; the array index mapping $(i \\mapsto 2i, 2i+1)$ represents left and right children when those indices exist.\n- Floyd’s build-heap processes indices $i=\\left\\lfloor n/2 \\right\\rfloor, \\left\\lfloor n/2 \\right\\rfloor - 1, \\dots, 1$, using sift-down to restore the heap property at each $i$.\n- Each sift-down exchanges the current node’s key with its larger child when that child’s key exceeds the current node’s key, repeating until both children are absent or both children have keys no larger than the current node’s key.\n\nYour program must:\n- Implement a generator that assigns values to indices so that keys strictly increase with depth: all nodes at depth $d$ receive strictly smaller keys than all nodes at depth $d+1$ for every feasible $d$. This generator must aim to maximize the total number of parent-child exchanges during build-heap.\n- Implement Floyd’s build-heap and count the total number of parent-child exchanges.\n- Implement the formula for the worst-case total number of exchanges as $$S_{\\max}(n) = \\sum_{i=1}^{\\left\\lfloor n/2 \\right\\rfloor} \\left\\lfloor \\log_2\\left(\\frac{n}{i}\\right) \\right\\rfloor,$$ which equals the sum of heights $\\left(\\text{number of edges on the longest downward path}\\right)$ of each internal node in the complete binary tree on $n$ nodes. Use this to evaluate optimality.\n\nYou must prove that the generator achieves the worst-case and therefore has ratio $$\\rho(n) = \\frac{S_{\\text{gen}}(n)}{S_{\\max}(n)} = 1,$$ and derive shape-based bounds for $S_{\\max}(n)$ in terms of $n$ and $H=\\left\\lfloor \\log_2 n \\right\\rfloor$, including the special cases $n=2^H$ and $n=2^{H+1}-1$.\n\nTest suite and final output:\n- Use the following test values of $n$: $[1,2,3,4,7,8,10,15]$.\n- For each $n$ in the test suite, compute the ratio $\\rho(n)$ as a decimal value.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each ratio formatted to exactly three decimal places (for example, $[1.000,1.000,1.000]$). If $S_{\\max}(n)=0$, define $\\rho(n)=1.000$ by convention since the generator attains the maximum cost of $0$.", "solution": "The problem as stated is valid. It is scientifically grounded in the domain of data structures and algorithms, well-posed with a clear objective and sufficient constraints, and expressed in precise, objective language. It presents a non-trivial challenge involving formal proof and algorithmic implementation. We may therefore proceed with a full solution.\n\nThe problem asks for the derivation of an adversarial input generator for Floyd's build-heap algorithm that maximizes the total number of parent-child exchanges. We must then prove that the cost achieved by this generator, $S_{\\text{gen}}(n)$, is equal to the theoretical maximum worst-case cost, $S_{\\max}(n)$, and derive expressions for this cost in terms of the heap's shape parameters for specific cases.\n\nLet us begin by analyzing the cost of the `sift-down` operation, which is the fundamental component of the build-heap procedure. A `sift-down` operation on a node at index $i$ in a max-heap aims to restore the heap property, which states that for any node $j$, its key must be greater than or equal to the keys of its children. The operation proceeds by repeatedly exchanging the key at the current node with the key of its larger child, if that child's key is greater. This continues until the key reaches a position where it is larger than or equal to both of its children's keys, or it becomes a leaf node.\n\nThe cost of a single `sift-down` call on node $i$ is defined as the number of exchanges performed. This number is maximized when the key initially at node $i$ is forced to travel as far down the tree as possible. The longest possible path from node $i$ to a descendant leaf defines the *height* of the node $i$. For a key to traverse this entire path, it must be smaller than the keys of all nodes it is compared against along this path. The height $h(i)$ of a node at index $i$ in a complete binary tree of size $n$ is given by $h(i) = \\lfloor \\log_2(n/i) \\rfloor$, where height is the number of edges on the longest downward path to a leaf.\n\nFloyd's build-heap algorithm iterates through all internal nodes, from $i = \\lfloor n/2 \\rfloor$ down to $1$, applying `sift-down` at each. The total cost, $S(n)$, is the sum of the costs of these individual calls:\n$$S(n) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} C_i$$\nwhere $C_i$ is the number of exchanges for `sift-down(i)`. The maximum possible cost for a single `sift-down(i)` is $h(i)$. Therefore, the maximum possible total cost for build-heap is the sum of the heights of all internal nodes:\n$$S_{\\max}(n) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} h(i) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} \\left\\lfloor \\log_2\\left(\\frac{n}{i}\\right) \\right\\rfloor$$\nThis matches the formula provided in the problem statement.\n\nWe are tasked with designing an adversarial input generator. The goal is to construct a permutation of the set of keys $\\{1, 2, \\dots, n\\}$ that forces every `sift-down` call to achieve its maximum possible cost. To make the key at an arbitrary internal node $i$ travel down to a leaf, its value must be smaller than any key it will be compared against. This suggests a general principle: place smaller keys at shallower depths and larger keys at deeper depths. The problem specifically proposes such a generator: assign values to indices so that keys strictly increase with depth.\n\nLet us formalize this generator. The depth of a node at index $i$ (with the root at depth $0$) is $d(i) = \\lfloor \\log_2 i \\rfloor$. The generator creates a permutation `A` of $\\{1, 2, \\dots, n\\}$ such that for any two indices $j$ and $k$, if $d(j) < d(k)$, then $A[j] < A[k]$. This can be implemented by sorting all node indices $i \\in \\{1, \\dots, n\\}$ by their depth $d(i)$ and assigning the keys $1, 2, \\dots, n$ in increasing order to the nodes in this sorted sequence.\n\nNow, we must prove that this generator achieves the maximum cost $S_{\\max}(n)$. Consider the `sift-down` operation on an arbitrary internal node $i$. By construction, the key $A[i]$ is smaller than the keys of its children, $A[2i]$ and (if it exists) $A[2i+1]$, because the children are at a greater depth. The `sift-down` procedure will exchange $A[i]$ with the larger of its children's keys. The key $A[i]$ thus moves to a new node at depth $d(i)+1$. The keys at the next level, which were originally grandchildren of $i$, are at depth $d(i)+2$. Our construction guarantees that the key $A[i]$ is also smaller than these keys. This process will repeat, with the key $A[i]$ being exchanged downwards at every level, until it reaches a leaf node. The number of exchanges will therefore be exactly the number of levels it descends, which is the height of node $i$, $h(i)$.\n\nSince this holds for every internal node $i \\in \\{1, \\dots, \\lfloor n/2 \\rfloor\\}$, the total cost for the generated input is:\n$$S_{\\text{gen}}(n) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} h(i) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} \\left\\lfloor \\log_2\\left(\\frac{n}{i}\\right) \\right\\rfloor$$\nThis is identical to the expression for $S_{\\max}(n)$. Thus, we have proven that $S_{\\text{gen}}(n) = S_{\\max}(n)$. The ratio $\\rho(n) = S_{\\text{gen}}(n) / S_{\\max}(n)$ is therefore equal to $1$ for all $n > 1$. For $n=1$, there are no internal nodes, so $S_{\\max}(1)=0$ and $S_{\\text{gen}}(1)=0$. By the problem's convention, $\\rho(1)=1$.\n\nFinally, we derive shape-based bounds for $S_{\\max}(n)$ for two special cases. A known and powerful identity, provable by induction, states that the sum of the heights of all nodes in a complete binary tree on $n$ nodes is $n - d(n)$, where $d(n)$ is the number of set bits (ones) in the binary representation of $n$. Since the height of any leaf is $0$, this sum is equal to the sum of the heights of the internal nodes:\n$$S_{\\max}(n) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} h(i) = n - d(n)$$\n\nUsing this identity, we can find exact expressions for the specified cases. The heap's total height is $H = \\lfloor \\log_2 n \\rfloor$.\n\n1.  **Case $n=2^{H+1}-1$ (a perfect binary tree):** The tree has height $H$. Its binary representation consists of $H+1$ consecutive ones. Thus, $d(n) = H+1$. The worst-case cost is:\n    $$S_{\\max}(n) = n - d(n) = n - (H+1)$$\n2.  **Case $n=2^H$ (a complete binary tree where the last level has one node):** The problem statement contains a slight ambiguity in its definition of $H$ for this case. For $n=2^k$, the height of the tree is $k$, and the value of $\\lfloor \\log_2 n \\rfloor$ is also $k$. Let us assume the problem implies $n = 2^k$ for some integer $k \\geq 1$, where the tree height is $k$. The value $H = \\lfloor\\log_2 n\\rfloor$ would equal $k$. The binary representation of $n=2^k$ is a single $1$ followed by $k$ zeros. Thus, $d(n) = 1$. The worst-case cost is:\n    $$S_{\\max}(n) = n - d(n) = n - 1$$\n\nThese formulas provide the exact worst-case cost for these specific heap shapes, expressed in terms of $n$ and its associated height parameter $H$. Both derivations confirm that the number of exchanges is on the order of $O(n)$, and specifically is bounded by $n - O(\\log n)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It calculates the ratio rho(n) for each n and prints the results.\n    \"\"\"\n\n    def generate_adversarial_input(n):\n        \"\"\"\n        Generates a permutation of {1, ..., n} that maximizes build-heap cost.\n        Keys are assigned such that they strictly increase with node depth.\n        1-based indexing is used for the heap array.\n        \"\"\"\n        if n == 0:\n            return np.array([], dtype=int)\n        \n        # Create a list of (depth, index) tuples for each node\n        nodes = []\n        for i in range(1, n + 1):\n            depth = int(np.log2(i))\n            nodes.append((depth, i))\n        \n        # Sort nodes primarily by depth, secondarily by index\n        nodes.sort()\n        \n        # Create the array and assign keys {1, 2, ..., n} based on sorted order\n        # The array is of size n+1 to accommodate 1-based indexing.\n        A = np.zeros(n + 1, dtype=int)\n        for key, (_, index) in enumerate(nodes, 1):\n            A[index] = key\n            \n        return A\n\n    def sift_down(A, i, n):\n        \"\"\"\n        Performs the sift-down operation on a max-heap.\n        Starts at index i and restores the heap property downwards.\n        Returns the number of parent-child exchanges.\n        \"\"\"\n        exchanges = 0\n        k = i\n        while True:\n            largest = k\n            left = 2 * k\n            right = 2 * k + 1\n            \n            # Find the largest among the node and its children\n            if left <= n and A[left] > A[largest]:\n                largest = left\n            if right <= n and A[right] > A[largest]:\n                largest = right\n            \n            # If the current node is already the largest, the sub-heap is valid\n            if largest == k:\n                break\n            \n            # Swap with the largest child and continue sifting down\n            A[k], A[largest] = A[largest], A[k]\n            exchanges += 1\n            k = largest\n            \n        return exchanges\n\n    def get_generated_cost(n):\n        \"\"\"\n        Calculates the total exchanges for build-heap on the adversarial input.\n        \"\"\"\n        if n <= 1:\n            return 0\n        \n        A = generate_adversarial_input(n)\n        total_exchanges = 0\n        \n        # Floyd's build-heap algorithm\n        for i in range(n // 2, 0, -1):\n            total_exchanges += sift_down(A, i, n)\n            \n        return total_exchanges\n\n    def get_max_cost(n):\n        \"\"\"\n        Calculates the theoretical maximum cost using the formula\n        S_max(n) = sum of heights of all internal nodes.\n        \"\"\"\n        if n <= 1:\n            return 0\n            \n        total_height = 0\n        for i in range(1, n // 2 + 1):\n            height = int(np.log2(n / i))\n            total_height += height\n            \n        return total_height\n    \n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 3, 4, 7, 8, 10, 15]\n\n    results = []\n    for n in test_cases:\n        s_gen = get_generated_cost(n)\n        s_max = get_max_cost(n)\n        \n        # The ratio rho(n) = S_gen(n) / S_max(n).\n        # By convention, if S_max(n) is 0, the ratio is 1.000.\n        if s_max == 0:\n            rho = 1.0\n        else:\n            rho = s_gen / s_max\n            \n        results.append(f\"{rho:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3219678"}, {"introduction": "The `buildHeap` algorithm is a process, but its goal is to create a structure with specific, static properties. This final exercise encourages you to reason about the properties of the completed max-heap, independent of how it was built. You will investigate the possible locations for the smallest element in the array, leading to a surprising and fundamental insight about the max-heap structure [@problem_id:3219605].", "problem": "Consider an input array $A$ of size $n \\geq 2$ containing $n$ distinct real keys. The array is a uniformly random permutation of these keys. A binary max-heap is defined as a complete binary tree in which, for every node with key $k_{\\text{parent}}$ and any child with key $k_{\\text{child}}$, the heap-order property $k_{\\text{parent}} \\geq k_{\\text{child}}$ holds. In the standard array-based representation of a binary heap with indices starting at $1$, a node at index $i$ has children at indices $2i$ and $2i+1$ (when those indices do not exceed $n$). A leaf node is any node with no children, equivalently any index $i$ such that $2i > n$.\n\nApply the standard bottom-up heap construction procedure buildHeap (also known as Floyd’s heap construction using repeated sift-down operations from indices $\\lfloor n/2 \\rfloor$ down to $1$) to transform $A$ into a binary max-heap. Let $m$ denote the unique minimum key in $A$.\n\nWhat is the exact value of the probability (as a real number) that, after buildHeap completes, the array position storing $m$ is a leaf node of the resulting max-heap? Provide a single exact value; no rounding is required.", "solution": "The problem asks for the probability that the unique minimum element $m$ in an array $A$ resides in a leaf node after the array has been transformed into a max-heap using the standard `buildHeap` algorithm. The initial array $A$ is a uniformly random permutation of $n$ distinct real keys, where $n \\geq 2$.\n\nFirst, we must analyze the properties of the final state of the array after the `buildHeap` procedure is complete. The procedure, by definition, correctly transforms the input array into a data structure that satisfies the max-heap property. Let the array after the `buildHeap` operation be denoted by $A'$.\n\nThe binary max-heap property dictates that for any node at index $i$ that is not a leaf, its key must be greater than or equal to the keys of its children. Using the $1$-based indexing specified in the problem, for any non-leaf node at index $i$, the following conditions must hold:\n$A'[i] \\geq A'[2i]$\nand, if the right child exists ($2i+1 \\leq n$),\n$A'[i] \\geq A'[2i+1]$\n\nA node at index $i$ is a non-leaf node if and only if it has at least one child. In a complete binary tree structure represented by an array of size $n$, this is equivalent to the condition $2i \\leq n$, or $i \\leq \\lfloor n/2 \\rfloor$. Conversely, a node is a leaf if $i > \\lfloor n/2 \\rfloor$.\n\nLet $m$ be the unique minimum key among the $n$ distinct keys. Let us assume, for the sake of contradiction, that after the `buildHeap` algorithm terminates, the element $m$ is located at a non-leaf position $j$ in the array $A'$.\nThis means $A'[j] = m$ and $j$ must satisfy the condition for a non-leaf node, which is $j \\leq \\lfloor n/2 \\rfloor$.\n\nBecause $j$ is a non-leaf node, it must have at least one child, a left child at index $2j$. The key at this child's position is $A'[2j]$.\nFrom the max-heap property, we must have $A'[j] \\geq A'[2j]$.\nSubstituting $A'[j] = m$, this inequality becomes $m \\geq A'[2j]$.\n\nHowever, the problem states that $m$ is the unique minimum key among all $n$ keys, and that all $n$ keys are distinct. This implies that for any other key $k'$ in the set, $m < k'$.\nThe key $A'[2j]$ is one of the keys in the array. Since the keys are distinct, $A'[2j]$ cannot be equal to $m$. Therefore, we must have:\n$m < A'[2j]$.\n\nWe have now arrived at a contradiction. The max-heap property requires $m \\geq A'[2j]$, while the definition of $m$ as the unique minimum requires $m < A'[2j]$. These two conditions cannot hold simultaneously.\n\nTherefore, our initial assumption must be false. The unique minimum element $m$ cannot be located at a non-leaf position in the final max-heap.\nThe set of all positions in the heap is the disjoint union of leaf positions and non-leaf positions. If the position of $m$ is not a non-leaf position, it must be a leaf position.\n\nThis conclusion holds for any array that is a max-heap, regardless of how it was constructed. Since the `buildHeap` algorithm on any initial permutation results in a valid max-heap, the minimum element $m$ will always be in a leaf node in the final configuration.\n\nThe event, \"the array position storing $m$ is a leaf node of the resulting max-heap,\" is a certain event. It occurs for every possible initial random permutation. The probability of a certain event is, by definition, $1$.\nThe information about the random permutation and the specifics of the `buildHeap` process, while defining the problem context, are ultimately irrelevant to the final property of the minimum element's location, which is determined solely by the static properties of a max-heap.\nThus, the probability is $1$.", "answer": "$$\n\\boxed{1}\n$$", "id": "3219605"}]}