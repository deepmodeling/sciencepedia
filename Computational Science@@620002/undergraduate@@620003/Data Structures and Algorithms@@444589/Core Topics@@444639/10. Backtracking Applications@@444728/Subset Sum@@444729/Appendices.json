{"hands_on_practices": [{"introduction": "We begin our hands-on practice with a fundamental version of the subset sum problem. Your task is to find a non-empty subset of integers that sums to exactly zero [@problem_id:3277225]. This exercise is a perfect entry point as it requires you to implement a dynamic programming solution to systematically explore and record all achievable subset sums, a core technique that can be adapted to many other combinatorial problems. Working with both positive and negative numbers adds a layer of realism to this classic challenge.", "problem": "Let $S$ be a finite set of integers, potentially containing both positive and negative values. A subset $T \\subseteq S$ is any collection of elements taken from $S$ where each element of $S$ appears in $T$ no more times than in $S$. The subset sum decision problem asks whether there exists a non-empty subset $T$ such that the arithmetic sum of elements in $T$ equals $0$. Formally, given a finite sequence (to fix an iteration order) $S = (s_1, s_2, \\dots, s_n)$ with each $s_i \\in \\mathbb{Z}$, find a non-empty index set $I \\subseteq \\{1,2,\\dots,n\\}$ such that $\\sum_{i \\in I} s_i = 0$. If such an index set exists, output the corresponding subset of values in the order they appear in $S$; otherwise, output the empty list.\n\nBase your work on fundamental definitions: integer addition is associative and commutative, and a subset is defined by a selection of elements from a larger set. Design an algorithmic solution starting from these foundations that is correct and terminates, and reason about its behavior for arbitrary sequences of integers.\n\nYou must implement a complete, runnable program in the Python programming language that, for each test case below, returns any non-empty subset of values whose sum is exactly $0$ if one exists, or the empty list otherwise. If multiple valid non-empty subsets exist for a test case, any one of them may be returned. The elements in an output subset must appear in the same order as they occur in the input sequence $S$.\n\nTest Suite:\n- Case $1$: $S = \\{3,-1,-7,5,4,2\\}$.\n- Case $2$: $S = \\{0,1,2\\}$.\n- Case $3$: $S = \\{2,-3,7\\}$.\n- Case $4$: $S = \\{5,-5,11\\}$.\n- Case $5$: $S = \\{10,-20,1,2,7\\}$.\n- Case $6$: $S = \\{-4\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is itself a list representing the found subset in the order of appearance in $S$. For example, an output matching the specified format is $[[],[0],[5,-5],\\dots]$ (this is only illustrative; your program must compute the actual results for the given test suite).", "solution": "The problem statement is evaluated for validity according to the specified criteria.\n\n### Step 1: Extract Givens\n-   **Input Data**: A finite sequence of integers, $S = (s_1, s_2, \\dots, s_n)$, where each $s_i \\in \\mathbb{Z}$.\n-   **Problem Definition**: Find a non-empty index set $I \\subseteq \\{1, 2, \\dots, n\\}$ such that the sum of the corresponding elements is zero, i.e., $\\sum_{i \\in I} s_i = 0$.\n-   **Output Specification**:\n    -   If such a non-empty subset exists, output the subset of values, maintaining the order of appearance from the original sequence $S$. If multiple solutions exist, any one is acceptable.\n    -   If no such non-empty subset exists, output the empty list.\n-   **Foundational Principles**: The solution must be based on the properties of integer addition (associativity, commutativity) and the definition of a subset.\n-   **Test Suite**:\n    -   Case $1$: $S = (3, -1, -7, 5, 4, 2)$\n    -   Case $2$: $S = (0, 1, 2)$\n    -   Case $3$: $S = (2, -3, 7)$\n    -   Case $4$: $S = (5, -5, 11)$\n    -   Case $5$: $S = (10, -20, 1, 2, 7)$\n    -   Case $6$: $S = (-4)$\n-   **Output Format**: A single line containing a comma-separated list of results, enclosed in square brackets. Each result is a list representing the found subset.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to a rigorous validation check.\n\n-   **Scientifically Grounded**: The problem is a specific instance of the Subset Sum Problem, a well-established and fundamental problem in computer science and combinatorial optimization. It is based entirely on standard arithmetic and set theory, containing no scientific inaccuracies or pseudoscience.\n-   **Well-Posed**: The problem is well-posed. For any finite sequence of integers, it is guaranteed that either a non-empty subset summing to zero exists or it does not. The output requirements are unambiguous for both cases. The allowance for any valid subset in case of multiple solutions ensures a clear path to a correct answer.\n-   **Objective**: The problem is stated using formal mathematical language and is entirely objective, free from any subjective or biased terminology.\n\nThe problem does not exhibit any of the listed invalidity flaws:\n1.  **Scientific or Factual Unsoundness**: None. The problem is mathematically sound.\n2.  **Non-Formalizable or Irrelevant**: None. The problem is a formal, classic algorithmic challenge directly relevant to the topic.\n3.  **Incomplete or Contradictory Setup**: The problem is complete and self-contained. The initial use of \"set\" notation `$...$` is clarified by the formal definition of $S$ as a sequence $(s_1, \\dots, s_n)$ and the requirement to preserve order, resolving any potential ambiguity regarding duplicate elements or element ordering.\n4.  **Unrealistic or Infeasible**: None. The test cases involve small integers and are computationally feasible.\n5.  **Ill-Posed or Poorly Structured**: None. A unique, meaningful answer (either a specific subset or a declaration of non-existence via an empty list) is guaranteed.\n6.  **Pseudo-Profound, Trivial, or Tautological**: None. While the test cases are small, the general problem is NP-complete and thus non-trivial.\n7.  **Outside Scientific Verifiability**: None. Any proposed solution can be trivially verified by summing the elements of the returned subset.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be developed.\n\n### Algorithmic Solution\nThe problem asks for the existence of a non-empty subset of a sequence of integers $S = (s_1, s_2, \\dots, s_n)$ whose elements sum to $0$. This is a variant of the subset sum problem, which is known to be NP-complete. For the small input sizes specified in the test suite, an algorithm with exponential time complexity is acceptable and practical. We will employ a constructive, dynamic programming-like approach that builds the set of all possible subset sums.\n\nThe core principle is to iteratively process each element of the sequence $S$ and, for each element, determine the new set of sums that can be achieved. We maintain a collection of all reachable sums and the corresponding subsets that produce them.\n\nLet $R$ be a hash map (dictionary) where each key is an achievable sum and the corresponding value is the subset of elements from $S$ that produces this sum.\n\nThe algorithm proceeds as follows:\n1.  Initialize the map $R$ to contain a single entry for the sum of the empty set: $R = \\{0: []\\}$. The sum is $0$, and the subset is the empty list.\n\n2.  Iterate through each element $s_i$ in the input sequence $S$ from $i=1$ to $n$.\n\n3.  For each $s_i$, we compute the new sums that can be formed by adding $s_i$ to all previously found sums. To avoid modifying $R$ while iterating over it, we first identify the new sum-subset pairs to be added in a temporary structure, $U$.\n    -   For each pair `(current_sum, current_subset)` currently in $R$:\n        a.  Calculate the new sum: $new\\_sum = current\\_sum + s_i$.\n        b.  Construct the new subset: $new\\_subset = current\\_subset \\cup \\{s_i\\}$ (or list concatenation, to preserve order).\n        c.  Store this new pair `(new_sum, new_subset)` in the temporary structure $U$.\n\n4.  After iterating through all existing pairs in $R$, we check for a solution and update $R$.\n    -   For each `(new_sum, new_subset)` in $U$:\n        a.  We must check if a solution has been found. The problem requires a non-empty subset. Since $new\\_subset$ is formed by adding $s_i$ to a pre-existing subset (even the empty one), it is guaranteed to be non-empty. If $new\\_sum = 0$, we have found a valid solution. We can immediately return $new\\_subset$ and terminate for the current test case.\n        b.  If $new\\_sum$ is not a solution, we add the pair to our map of reachable sums: $R[new\\_sum] = new\\_subset$. We only need one subset for any given sum, so if the sum already exists in $R$, we can choose to overwrite or ignore it. Overwriting is simpler and sufficient since we only need to find one solution.\n\n5.  If the loop over all elements $s_i \\in S$ completes without finding a sum of $0$ for any non-empty subset, then no such subset exists. In this case, we return the empty list as required.\n\nThis method systematically explores all possible subset sums. If $S$ has $n$ elements, there are $2^n$ subsets. In the worst case, this algorithm might need to store a number of distinct sums that is exponential in $n$, leading to a worst-case time complexity of $O(n \\cdot 2^n)$. Given the constraints of the test suite (maximum $n=6$), this is computationally efficient. For instance, for $n=6$, the number of operations is on the order of $6 \\cdot 2^6 = 384$, which is negligible for modern processors.\n\nLet's trace Case 1: $S = (3, -1, -7, 5, 4, 2)$.\n-   Initial: $R = \\{0: []\\}$.\n-   Process $s_1 = 3$: Create new pair $(0+3, []+[3]) = (3, [3])$. $R$ becomes $\\{0: [], 3: [3]\\}$.\n-   Process $s_2 = -1$: Create new pairs $(0-1, [-1])=(-1, [-1])$ and $(3-1, [3,-1])=(2, [3,-1])$. $R$ becomes $\\{0: [], 3: [3], -1: [-1], 2: [3,-1]\\}$.\n-   Process $s_3 = -7$: Create four new pairs from existing sums: $(0-7, [-7])$, $(3-7, [3,-7])$, $(-1-7, [-1,-7])$, $(2-7, [3,-1,-7])$. None of the new sums are $0$. $R$ is updated with these new sums. The sum $-5$ is now achievable with subset $[3, -1, -7]$.\n-   Process $s_4 = 5$: Create eight new pairs. When processing the sum $-5$ (from subset $[3, -1, -7]$), we compute the new sum $-5+5=0$. The corresponding subset is $[3, -1, -7, 5]$. Since this new sum is $0$ and the subset is non-empty, we have found a solution. The algorithm terminates and returns $[3, -1, -7, 5]$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the subset sum problem for a predefined test suite.\n    \"\"\"\n\n    test_cases = [\n        (3, -1, -7, 5, 4, 2),  # Case 1\n        (0, 1, 2),              # Case 2\n        (2, -3, 7),             # Case 3\n        (5, -5, 11),            # Case 4\n        (10, -20, 1, 2, 7),     # Case 5\n        (-4,),                  # Case 6\n    ]\n\n    results = []\n    for s_sequence in test_cases:\n        result = find_zero_sum_subset(list(s_sequence))\n        # The output format requires standard Python list string representation\n        results.append(str(result))\n    \n    # The final output must be a single string representing a list of strings\n    print(f\"[{','.join(results)}]\")\n\ndef find_zero_sum_subset(s):\n    \"\"\"\n    Finds a non-empty subset of a sequence of integers `s` that sums to 0.\n\n    This function uses a dynamic programming approach. It builds a dictionary `reachable_sums`\n    that maps each achievable sum to the subset that produces it.\n\n    Args:\n        s (list[int]): A list of integers.\n\n    Returns:\n        list[int]: A non-empty subset that sums to 0, with elements in their\n                   original order of appearance. If no such subset exists,\n                   returns an empty list.\n    \"\"\"\n    \n    # The dictionary maps an achievable sum to the subset that creates it.\n    # We initialize with the sum of the empty set, which is 0.\n    reachable_sums = {0: []}\n    \n    # Iterate through each number in the input sequence.\n    for num in s:\n        # Create a temporary dictionary to hold new sums generated in this iteration.\n        # This prevents modifying the dictionary while iterating over it.\n        updates = {}\n        \n        # For each sum we can already make, see what new sum is possible by adding `num`.\n        for current_sum, subset in reachable_sums.items():\n            new_sum = current_sum + num\n            new_subset = subset + [num]\n            \n            # Since `new_subset` is formed by adding `num` to an existing list,\n            # it is guaranteed to be non-empty.\n            # If the new sum is 0, we have found a valid solution.\n            if new_sum == 0:\n                return new_subset\n            \n            # If it's a new achievable sum, store it and its corresponding subset.\n            # We only need one way to form a sum, so we can overwrite if it exists.\n            updates[new_sum] = new_subset\n            \n        # Merge the newly found sums into the main dictionary.\n        reachable_sums.update(updates)\n            \n    # If the loop completes, no non-empty subset summing to 0 was found.\n    return []\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3277225"}, {"introduction": "Moving beyond searching for a single target, this next practice challenges you to analyze the entire set of possible subset sums. Your goal is to find the smallest non-negative integer that *cannot* be formed by summing a subset of a given set of numbers [@problem_id:3277142]. This problem beautifully illustrates that a complex-seeming combinatorial question can sometimes be solved with an elegant and efficient greedy algorithm, providing a powerful alternative to dynamic programming when the problem has the right structure.", "problem": "You are given a finite multiset $S$ of non-negative integers. A subset is any selection of elements of $S$, each element used at most once, and the empty subset is allowed. For an indexing of $S$ as $(s_1,\\dots,s_n)$ with $n \\in \\mathbb{N}$, any subset corresponds to an index set $I \\subseteq \\{1,2,\\dots,n\\}$ and has subset sum $\\sum_{i \\in I} s_i$. Define the subset-sum set $\\Sigma(S) = \\left\\{ \\sum_{i \\in I} s_i \\,\\middle|\\, I \\subseteq \\{1,\\dots,n\\} \\right\\}$. Note that $0 \\in \\Sigma(S)$ because the empty sum is $0$. Your task is to determine the smallest non-negative integer $m \\in \\mathbb{Z}_{\\ge 0}$ that is not contained in $\\Sigma(S)$.\n\nThe problem is to design a program that, for each of several specified test cases (each test case being a particular multiset $S$), outputs the smallest such $m$. You must construct your solution from first principles: rely only on the definitions above, the properties of addition over the non-negative integers, and rigorous reasoning. Do not assume any unproven shortcut characterizations.\n\nInput model for this assignment is implicit: you are given a fixed test suite below, and your program must compute answers for exactly these test cases, with no user input.\n\nTest suite:\n- Case $1$: $S^{(1)} = [\\,]$.\n- Case $2$: $S^{(2)} = [\\,0,0,0\\,]$.\n- Case $3$: $S^{(3)} = [\\,2,3,4\\,]$.\n- Case $4$: $S^{(4)} = [\\,1,2,2,5\\,]$.\n- Case $5$: $S^{(5)} = [\\,1,3,4,10\\,]$.\n- Case $6$: $S^{(6)} = [\\,1,1,1,1\\,]$.\n- Case $7$: $S^{(7)} = [\\,1,2,4,8,16\\,]$.\n- Case $8$: $S^{(8)} = [\\,0,1,2,8\\,]$.\n- Case $9$: $S^{(9)} = [\\,1,1,3\\,]$.\n- Case $10$: $S^{(10)} = [\\,1,1,2,3,6,7,9\\,]$.\n\nRequired final output format:\n- Your program must produce a single line that is a bracketed, comma-separated list of the $10$ integer answers, in order from Case $1$ to Case $10$, and with no spaces. For example, the format is $[\\,a_1,a_2,\\dots,a_{10}\\,]$, where each $a_i$ is the computed smallest non-negative integer not contained in $\\Sigma(S^{(i)})$.", "solution": "The problem statement is first validated against the required criteria.\n\n### Step 1: Extract Givens\n- A finite multiset $S$ of non-negative integers.\n- A subset is a selection of elements of $S$, each used at most once. The empty subset is allowed.\n- $S$ is indexed as $(s_1,\\dots,s_n)$ with $n \\in \\mathbb{N}$.\n- A subset corresponds to an index set $I \\subseteq \\{1,2,\\dots,n\\}$.\n- The subset sum for a given index set $I$ is $\\sum_{i \\in I} s_i$.\n- The subset-sum set is $\\Sigma(S) = \\left\\{ \\sum_{i \\in I} s_i \\,\\middle|\\, I \\subseteq \\{1,\\dots,n\\} \\right\\}$.\n- It is given that $0 \\in \\Sigma(S)$ as it corresponds to the empty sum (when $I = \\emptyset$).\n- The objective is to find the smallest non-negative integer $m \\in \\mathbb{Z}_{\\ge 0}$ such that $m \\notin \\Sigma(S)$.\n- The solution must be derived from first principles.\n- A fixed test suite is provided:\n    - Case $1$: $S^{(1)} = [\\,]$.\n    - Case $2$: $S^{(2)} = [\\,0,0,0\\,]$.\n    - Case $3$: $S^{(3)} = [\\,2,3,4\\,]$.\n    - Case $4$: $S^{(4)} = [\\,1,2,2,5\\,]$.\n    - Case $5$: $S^{(5)} = [\\,1,3,4,10\\,]$.\n    - Case $6$: $S^{(6)} = [\\,1,1,1,1\\,]$.\n    - Case $7$: $S^{(7)} = [\\,1,2,4,8,16\\,]$.\n    - Case $8$: $S^{(8)} = [\\,0,1,2,8\\,]$.\n    - Case $9$: $S^{(9)} = [\\,1,1,3\\,]$.\n    - Case $10$: $S^{(10)} = [\\,1,1,2,3,6,7,9\\,]$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated based on the criteria of being scientifically grounded, well-posed, and objective.\n\n- **Scientifically Grounded**: The problem is a well-established variant of the subset sum problem, a fundamental topic in combinatorics and computer science. All definitions and concepts are mathematically rigorous and standard.\n- **Well-Posed**: For any finite multiset $S$ of non-negative integers, the set of all possible subset sums, $\\Sigma(S)$, is a finite set of non-negative integers. The set of non-negative integers $\\mathbb{Z}_{\\ge 0}$ is infinite. Therefore, the set $\\mathbb{Z}_{\\ge 0} \\setminus \\Sigma(S)$ is non-empty, and by the well-ordering principle, it must contain a smallest element. Thus, a unique solution $m$ exists for any valid input $S$.\n- **Objective**: The problem is defined using precise mathematical language, free from any ambiguity, subjectivity, or opinion.\n\nThe problem statement exhibits none of the invalidating flaws. It is mathematically sound, self-contained, and formally structured.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A principled solution will be constructed.\n\nThe problem asks for the smallest non-negative integer $m$ that cannot be expressed as a sum of a subset of elements from a given multiset $S$. We can approach this by determining the extent to which we can form a continuous range of integer sums starting from $0$.\n\nLet $R$ be the maximum value such that all integers in the set $\\{0, 1, \\dots, R\\}$ are members of $\\Sigma(S')$, where $S'$ is a sub-multiset of $S$ that we have processed. The smallest integer that we cannot (yet) form is $R+1$.\n\nThe proposed algorithm is a greedy one. It relies on processing the elements of $S$ in a specific order to efficiently extend the range of constructible sums.\n\n1.  **Sorting**: First, sort the multiset $S$ in non-decreasing order. Let the sorted elements be $s_1, s_2, \\dots, s_n$, where $s_1 \\le s_2 \\le \\dots \\le s_n$. Sorting is crucial because it allows us to consider elements in increasing order of magnitude, which is key to the greedy strategy's correctness.\n\n2.  **Initialization**: We begin with an empty set of elements. The only sum we can form is $0$ (the sum of the empty subset). Let's define a variable, $R$, to track the maximum boundary of our continuous block of sums starting at $0$. Initially, with no elements from $S$ considered, we can only form the sum $0$. The continuous range of sums is $[0, 0]$. So, we initialize $R=0$. The smallest non-negative integer we cannot yet form is $R+1=1$.\n\n3.  **Iterative Construction**: We iterate through the sorted elements $s_i$ for $i=1, \\dots, n$. In each step, we consider the current element $s_i$ and the current range of achievable sums, which we assume by induction is $[0, R]$. Let's denote the value of $R$ before processing $s_i$ as $R_{i-1}$.\n\n4.  **The Inductive Step and Greedy Choice**: Assume that after processing elements $s_1, \\dots, s_{i-1}$, we have confirmed that all integer sums in the interval $[0, R_{i-1}]$ are constructible. The smallest sum potentially not constructible is $R_{i-1}+1$. Now we introduce the element $s_i$.\n    The set of sums that can be formed using elements $\\{s_1, \\dots, s_i\\}$ is the union of the sums from $\\{s_1, \\dots, s_{i-1}\\}$ and the sums obtained by adding $s_i$ to each sum from $\\{s_1, \\dots, s_{i-1}\\}$.\n    Since we can form all sums in $[0, R_{i-1}]$, adding $s_i$ allows us to form all sums in the new interval $[s_i, R_{i-1}+s_i]$.\n\n    Two cases arise:\n    - **Case A: $s_i > R_{i-1}+1$**. In this situation, there is a gap between the range of sums we could already form, $[0, R_{i-1}]$, and the smallest new sum we can form using $s_i$, which is $0+s_i=s_i$. The integer $R_{i-1}+1$ cannot be formed. Any sum formed from $\\{s_1, \\dots, s_i\\}$ is either a sum from $\\{s_1, \\dots, s_{i-1}\\}$ (and thus cannot be $R_{i-1}+1$) or involves $s_i$, making the sum at least $s_i$. As $s_i > R_{i-1}+1$, no combination can produce $R_{i-1}+1$. Because the elements are sorted, all subsequent elements $s_j$ ($j>i$) are also greater than or equal to $s_i$, and thus greater than $R_{i-1}+1$. Therefore, $R_{i-1}+1$ can never be formed. It is the smallest non-negative integer not in $\\Sigma(S)$. The algorithm terminates, and the answer is $m=R_{i-1}+1$.\n\n    - **Case B: $s_i \\le R_{i-1}+1$**. We can form sums in $[0, R_{i-1}]$. By adding $s_i$, we can also form sums in $[s_i, R_{i-1}+s_i]$. Because $s_i \\le R_{i-1}+1$, these two intervals overlap or touch. Their union, $[0, R_{i-1}] \\cup [s_i, R_{i-1}+s_i]$, forms a single, contiguous interval $[0, R_{i-1}+s_i]$. Thus, we have successfully extended our range of constructible sums. We update our boundary $R$ to the new value $R_i = R_{i-1}+s_i$ and proceed to the next element, $s_{i+1}$.\n\n5.  **Termination**: If the loop completes, having processed all elements of $S$ without encountering Case A, the final range of constructible sums is $[0, R_n]$, where $R_n$ is the final value of $R$. The smallest non-negative integer not in this range is $R_n+1$.\n\nThis logic covers all possibilities. The final algorithm is as follows:\n1. Initialize a variable for the maximum reachable sum, $R = 0$.\n2. Sort the input multiset $S$ in non-decreasing order.\n3. For each element $s \\in S$:\n   - If $s > R+1$, the smallest missing sum is $R+1$. Terminate and return this value.\n   - Otherwise ($s \\le R+1$), update the maximum reachable sum: $R \\leftarrow R+s$.\n4. If the loop finishes, the smallest missing sum is $R+1$.\n\nThis can be more compactly stated: initialize $R=0$; for each $s$ in sorted $S$, if $s > R+1$ break, else $R \\leftarrow R+s$; the result is $R+1$.\n\nLet's apply this to $S^{(4)} = [1, 2, 2, 5]$:\n- Initialize $R=0$.\n- Sorted $S$ is $[1, 2, 2, 5]$.\n- Process $s_1=1$: $1 \\le 0+1$. Update $R \\leftarrow 0+1=1$. We can form sums in $[0,1]$.\n- Process $s_2=2$: $2 \\le 1+1$. Update $R \\leftarrow 1+2=3$. We can form sums in $[0,3]$.\n- Process $s_3=2$: $2 \\le 3+1$. Update $R \\leftarrow 3+2=5$. We can form sums in $[0,5]$.\n- Process $s_4=5$: $5 \\le 5+1$. Update $R \\leftarrow 5+5=10$. We can form sums in $[0,10]$.\n- Loop ends. The smallest missing sum is $R+1 = 10+1=11$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the smallest non-negative integer not in the subset-sum set for a list of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],                   # Case 1: S^{(1)}\n        [0, 0, 0],            # Case 2: S^{(2)}\n        [2, 3, 4],            # Case 3: S^{(3)}\n        [1, 2, 2, 5],         # Case 4: S^{(4)}\n        [1, 3, 4, 10],        # Case 5: S^{(5)}\n        [1, 1, 1, 1],         # Case 6: S^{(6)}\n        [1, 2, 4, 8, 16],     # Case 7: S^{(7)}\n        [0, 1, 2, 8],         # Case 8: S^{(8)}\n        [1, 1, 3],            # Case 9: S^{(9)}\n        [1, 1, 2, 3, 6, 7, 9] # Case 10: S^{(10)}\n    ]\n\n    results = []\n    for s_multiset in test_cases:\n        # The algorithm to find the smallest missing subset sum.\n        # This value represents the maximum integer R such that all integers\n        # in the interval [0, R] are known to be constructible as subset sums.\n        reachable_sum_max = 0\n        \n        # Sort the multiset in non-decreasing order. This is essential for\n        # the greedy approach to work correctly.\n        s_sorted = sorted(s_multiset)\n        \n        for s_val in s_sorted:\n            # If the current element is greater than the next integer we're\n            # trying to form (reachable_sum_max + 1), then there's a gap\n            # that cannot be bridged.\n            if s_val > reachable_sum_max + 1:\n                break\n            \n            # Otherwise, we can extend the range of constructible sums.\n            # The new range becomes [0, reachable_sum_max + s_val].\n            reachable_sum_max += s_val\n            \n        # The smallest integer that cannot be formed is one greater than the\n        # maximum of the continuous range of sums starting from 0.\n        smallest_missing_sum = reachable_sum_max + 1\n        results.append(smallest_missing_sum)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3277142"}, {"introduction": "Our final practice tackles a classic optimization task closely related to subset sum: the partition problem. Here, the objective is not to hit an exact target, but to find a subset whose sum is as close as possible to a given value, in this case, half of the total sum of all elements [@problem_id:3277118]. This exercise will test your ability to adapt the foundational dynamic programming approach to an optimization context and carefully manage a hierarchy of tie-breaking rules, a scenario commonly encountered in practical algorithm design and engineering.", "problem": "You are given a finite multiset of non-negative integers $S$ and a positive integer $T$. Define the target half as $T/2$. The task is to determine a subset $A \\subseteq S$ whose subset sum $\\sum_{a \\in A} a$ is closest to $T/2$ in the sense of minimizing the absolute difference $\\left| \\sum_{a \\in A} a - T/2 \\right|$. To ensure determinism when multiple subsets yield the same minimal absolute difference, apply the following tie-breaking rules in the stated order: \n- Minimize $\\left| \\sum_{a \\in A} a - T/2 \\right|$. \n- If there is a tie, prefer $\\sum_{a \\in A} a \\leq T/2$ over $\\sum_{a \\in A} a > T/2$. \n- If there is still a tie, minimize the cardinality $\\lvert A \\rvert$. \n- If there is still a tie, choose the lexicographically smallest subset when its elements are listed in non-decreasing order.\n\nYour program must compute, for each test case, the triple consisting of:\n- The chosen subset sum as an integer $\\sum_{a \\in A} a$.\n- The absolute difference $\\left| \\sum_{a \\in A} a - T/2 \\right|$ as a decimal number. \n- The chosen subset $A$ written as a list of its elements in non-decreasing order.\n\nThe final output format must aggregate the results of all provided test cases into a single line. Specifically, your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself written as $[\\text{sum},\\text{difference},[\\text{subset elements}]]$. For example, the overall output should look like $[[s_1,d_1,[\\dots]],[s_2,d_2,[\\dots]],\\dots]$.\n\nUse purely mathematical and logical reasoning, and assume standard integer arithmetic. No physical units are involved.\n\nTest suite:\n- Case $1$: $S = [3,1,4,2,2]$, $T = 12$.\n- Case $2$: $S = [\\,]$, $T = 5$. \n- Case $3$: $S = [8,2,6]$, $T = 16$.\n- Case $4$: $S = [1,2,3]$, $T = 100$.\n- Case $5$: $S = [7,12,3,1,9,5,14,8,2,6,10,4,11,13,15,16,17,18,19,20]$, $T = 100$.\n\nYour program must compute the required triple for each case and print all of them in the specified single-line format. No input should be read; the test cases are fixed as above and embedded in the program.", "solution": "The problem is a combinatorial optimization task. We are given a multiset of non-negative integers $S$ and a positive integer target $T$. The objective is to find a subset $A \\subseteq S$ that minimizes the absolute difference between its sum, $\\sum_{a \\in A} a$, and the \"target half\", defined as $T/2$. A detailed hierarchy of tie-breaking rules is provided to ensure a unique solution.\n\nThis problem is a variant of the classic subset sum problem. Given the constraints and the nature of the objective function, which requires evaluating all possible subset sums, a dynamic programming approach is the most suitable methodology. The core idea is to systematically build up solutions for all achievable subset sums, while keeping track of the metadata required for the tie-breaking rules.\n\nFirst, let's formalize the state of our dynamic programming table. For each possible sum $s$ that can be formed using elements from $S$, we need to store the information necessary to apply the tie-breaking rules. The rules, applied to subsets yielding the same sum $s$, are:\n1. Minimize the cardinality $|A|$.\n2. Choose the lexicographically smallest subset $A$ (with elements sorted).\n\nThus, our DP state for a sum $s$, denoted `dp[s]`, will be a tuple $(\\text{cardinality}, \\text{subset})$, where `cardinality` is the minimum number of elements from $S$ that sum to $s$, and `subset` is the corresponding lexicographically smallest subset.\n\nThe algorithm proceeds as follows:\n\n1.  **Initialization**: Let the total sum of all elements in $S$ be $\\Sigma_S = \\sum_{x \\in S} x$. We initialize a DP table, which can be a list or array `dp` of size $\\Sigma_S + 1$. Each entry `dp[s]` will store the optimal subset information for the sum $s$. We initialize `dp[0]` to $(0, [])$, representing the empty set which has a sum of $0$ and cardinality $0$. All other entries `dp[s]` for $s > 0$ are initialized to a state representing non-reachability, for instance, by using infinite cardinality, e.g., $(\\infty, \\text{None})$.\n\n2.  **Sorting**: To correctly handle the lexicographical tie-breaking rule, we first sort the input multiset $S$ in non-decreasing order. Let the sorted multiset be $S' = [s_1, s_2, \\dots, s_n]$. Iterating through the elements of $S'$ in this order is crucial for correctly constructing the lexicographically smallest subsets.\n\n3.  **DP Table Population**: We iterate through each element $x$ in the sorted multiset $S'$. For each $x$, we iterate downwards through the possible sums, from $s = \\Sigma_S$ down to $x$. This downward iteration ensures that we use each element $x$ from the multiset at most once per subset construction step (as if we were using distinct items from the original multiset).\n\n    For each sum $s$, we consider forming a new subset for sum $s$ by adding the current element $x$ to an existing optimal subset for sum $s-x$. If `dp[s-x]` represents a reachable sum (i.e., its cardinality is not $\\infty$), let its value be $(c, A')$. We can form a new candidate subset for sum $s$ with cardinality $c+1$ and elements $A' \\cup \\{x\\}$. Since $S'$ is sorted and we append $x$ to $A'$ (which was constructed from elements smaller than or equal to $x$), the resulting subset list is implicitly sorted.\n\n    Let this new candidate be $(c_{\\text{new}}, A_{\\text{new}})$ where $c_{\\text{new}} = c+1$ and $A_{\\text{new}} = A' + [x]$. We compare this candidate with the current entry for `dp[s]`, say $(c_{\\text{curr}}, A_{\\text{curr}})$:\n    - If $c_{\\text{new}}  c_{\\text{curr}}$, the new subset is better because it has smaller cardinality. We update `dp[s] = (c_{\\text{new}}, A_{\\text{new}})$.\n    - If $c_{\\text{new}} = c_{\\text{curr}}$, we perform a lexicographical comparison between $A_{\\text{new}}$ and $A_{\\text{curr}}$. If $A_{\\text{new}}$ is lexicographically smaller than $A_{\\text{curr}}$, we update `dp[s]`.\n\n4.  **Finding the Optimal Solution**: After the DP table is fully populated, it contains the optimal subset (minimum cardinality and lexicographically smallest) for every achievable sum. We now search through all reachable sums $s \\in [0, \\Sigma_S]$ to find the one that best satisfies the main problem objective and the top-level tie-breaking rules. Let the target half be $\\tau = T/2$.\n\n    We iterate through all sums $s$ for which `dp[s]` is reachable, keeping track of the best solution found so far. Let the current best sum be $s_{\\text{best}}$ and its absolute difference from $\\tau$ be $d_{\\text{best}} = |s_{\\text{best}} - \\tau|$. For each new sum $s$ with difference $d = |s - \\tau|$, we apply the primary tie-breaking rules:\n    - **Rule 1 (Minimize difference)**: If $d  d_{\\text{best}}$, we have found a new best solution. We update $s_{\\text{best}} = s$.\n    - **Rule 2 (Prefer sum $\\leq \\tau$)**: If $d = d_{\\text{best}}$, we check if one sum is less than or equal to $\\tau$ while the other is not. The problem states a preference for $s \\le \\tau$. If $s \\le \\tau$ and $s_{\\text{best}} > \\tau$, we update $s_{\\text{best}} = s$. If both are on the same side of $\\tau$, we proceed to the next rule.\n    - **Rule 3  4 (Minimize cardinality, then lexicographically)**: If we are still tied after the first two rules (i.e., $d=d_{\\text{best}}$ and both $s, s_{\\text{best}}$ are on the same side of $\\tau$), we compare their corresponding entries in the DP table. We compare `dp[s]` with `dp[s_best]`. Since our DP table already stores the optimal subset for each sum based on cardinality and lexicographical order, we simply compare `dp[s]` and `dp[s_best]` using these criteria to find the overall best solution. Specifically, we prefer the sum whose subset has smaller cardinality. If cardinalities are equal, we prefer the one with the lexicographically smaller subset.\n\n5.  **Final Result**: Once the search is complete, the final optimal sum is $s_{\\text{best}}$. The required output triple is $(s_{\\text{best}}, |s_{\\text{best}} - \\tau|, \\text{subset from } dp[s_{\\text{best}}])$.\n\nThis comprehensive approach guarantees that we find the unique subset that satisfies the complete, ordered set of criteria defined in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the predefined test suite.\n    \"\"\"\n\n    test_cases = [\n        {'S': [3, 1, 4, 2, 2], 'T': 12},\n        {'S': [], 'T': 5},\n        {'S': [8, 2, 6], 'T': 16},\n        {'S': [1, 2, 3], 'T': 100},\n        {'S': [7, 12, 3, 1, 9, 5, 14, 8, 2, 6, 10, 4, 11, 13, 15, 16, 17, 18, 19, 20], 'T': 100}\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        S = case['S']\n        T = case['T']\n        \n        # Sort the multiset S. This is crucial for building lexicographically smallest subsets.\n        S.sort()\n        \n        total_sum = sum(S)\n        \n        # dp[s] will store a tuple: (cardinality, subset_list)\n        # for the best subset that sums to s.\n        # Initialize with infinity for cardinality to mark sums as unreachable.\n        dp = {0: (0, [])}\n        \n        for x in S:\n            # Iterate downwards to use each element from the multiset at most once per subset.\n            for s in range(total_sum, x - 1, -1):\n                if s - x in dp:\n                    prev_card, prev_sub = dp[s - x]\n                    new_card = prev_card + 1\n                    # Appending to a sorted list built from smaller elements maintains sorted order.\n                    new_sub = prev_sub + [x]\n                    \n                    if s not in dp:\n                        dp[s] = (new_card, new_sub)\n                    else:\n                        curr_card, curr_sub = dp[s]\n                        # Tie-breaking for a fixed sum s: minimize cardinality, then lexicographically.\n                        if new_card  curr_card:\n                            dp[s] = (new_card, new_sub)\n                        elif new_card == curr_card:\n                            if new_sub  curr_sub: # Python list comparison is lexicographical\n                                dp[s] = (new_card, new_sub)\n        \n        target_half = T / 2\n        \n        best_sum = -1\n        min_diff = float('inf')\n        \n        # Find the best sum among all achievable sums.\n        achievable_sums = sorted(dp.keys())\n        \n        # Initialize with the first achievable sum\n        if achievable_sums:\n            best_sum = achievable_sums[0]\n            min_diff = abs(best_sum - target_half)\n\n        for s in achievable_sums:\n            current_diff = abs(s - target_half)\n            \n            # Rule 1: Minimize absolute difference\n            if current_diff  min_diff:\n                min_diff = current_diff\n                best_sum = s\n            elif current_diff == min_diff:\n                # Rule 2: Prefer sum = T/2\n                is_current_leq = (s = target_half)\n                is_best_leq = (best_sum = target_half)\n                \n                if is_current_leq and not is_best_leq:\n                    best_sum = s\n                elif is_current_leq == is_best_leq:\n                    # Rules 3  4: Minimize cardinality, then choose lexicographically smallest subset.\n                    # This is already encoded in the dp table entries.\n                    current_card, current_sub = dp[s]\n                    best_card, best_sub = dp[best_sum]\n                    \n                    if current_card  best_card:\n                        best_sum = s\n                    elif current_card == best_card:\n                        if current_sub  best_sub:\n                            best_sum = s\n                            \n        final_sum = best_sum\n        final_diff = abs(final_sum - target_half)\n        final_subset = dp[final_sum][1] if final_sum != -1 else []\n        \n        all_results.append([final_sum, float(final_diff), final_subset])\n\n    # Format the final output string to match the required format exactly (no spaces).\n    result_strings = []\n    for res in all_results:\n        s, d, sub = res\n        sub_str = '[' + ','.join(map(str, sub)) + ']'\n        result_strings.append(f'[{s},{d},{sub_str}]')\n    \n    final_output = '[' + ','.join(result_strings) + ']'\n    print(final_output)\n\nsolve()\n```", "id": "3277118"}]}