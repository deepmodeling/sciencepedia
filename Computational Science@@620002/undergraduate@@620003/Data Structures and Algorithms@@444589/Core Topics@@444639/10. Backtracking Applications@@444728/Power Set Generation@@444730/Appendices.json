{"hands_on_practices": [{"introduction": "Generating the entire power set of a large collection can be computationally prohibitive due to its exponential size. This practice challenges you to implement a memory-efficient 'lazy' iterator that generates subsets one by one, only when requested [@problem_id:3259468]. By mastering this, you will understand how to apply the bitmasking technique to handle large-scale combinatorial problems without exhausting system memory.", "problem": "You are asked to implement a complete, runnable program that constructs a \"lazy\" power set iterator for a finite sequence of distinct integers. The iterator must compute the next subset only upon explicit request, without precomputing or materializing the entire power set in memory. The fundamental base for this task is the mathematical definition of a power set and the well-established bijection between subsets and binary indicator vectors. For a finite set $S$ with $n$ distinct elements, its power set $\\mathcal{P}(S)$ is the set of all subsets of $S$, whose cardinality is $2^n$. There exists a bijection between $\\mathcal{P}(S)$ and the set of all $n$-length binary strings $\\{0,1\\}^n$ by mapping each position $i$ in the binary string to the presence or absence of the $i$-th element of $S$. Treat the integer interpretation of the indicator vector as an unsigned number by taking the least significant bit (defined as Least Significant Bit (LSB)) to correspond to the first element of the input sequence, the next bit to the second element, and so on. The required enumeration order over subsets is by ascending integer value of the corresponding indicator vector, starting at the integer $0$ (which maps to the empty subset) and ending at the integer $2^n - 1$.\n\nProgram requirements:\n- Implement a \"lazy\" iterator over $\\mathcal{P}(S)$ that yields the next subset only when explicitly advanced, never materializing more than the current subset. The space overhead beyond storing the input sequence must be $\\mathcal{O}(n)$, where $n$ is the length of the input sequence.\n- The enumeration order must be exactly the ascending integer order of the indicator vectors with the LSB aligned to the first element of the input sequence.\n- The program must include an internal test suite with several parameter sets and produce a single line of output containing the aggregated results of all test cases, formatted as a comma-separated list enclosed in square brackets without spaces. Each test case result must be a list of subsets, where each subset is represented as a list of integers.\n\nTest suite specification:\n- Each test case consists of a pair $(A, k)$ where $A$ is a finite sequence of distinct integers and $k$ is a nonnegative integer specifying how many successive subsets to request from the iterator, starting from the empty subset. If $k$ exceeds $2^{|A|}$, the iterator should stop naturally after $2^{|A|}$ subsets.\n- Use the following cases:\n  - Case $1$: $A = [\\,]$, $k = 1$.\n  - Case $2$: $A = [\\,7\\,]$, $k = 2$.\n  - Case $3$: $A = [\\,1,2,3\\,]$, $k = 4$.\n  - Case $4$: $A = [\\,2,4,6,8\\,]$, $k = 9$.\n  - Case $5$: $A = [\\,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20\\,]$, $k = 5$.\n\nAnswer specification:\n- For each case, the answer is a list of the first $k$ subsets produced by the lazy iterator in the specified order. Each subset is itself a list of integers drawn from the input sequence.\n- The final program output must be a single line containing the results for all test cases aggregated as a comma-separated list enclosed in square brackets, without spaces. For example, if there were three test cases with results $R_1$, $R_2$, and $R_3$, the exact output format would be $[R_1,R_2,R_3]$, where each $R_i$ is a list (printed with brackets) of lists of integers.\n\nNo user input is permitted. There are no physical quantities in this problem, so no unit specification is necessary. Angles and percentages do not appear. The program must adhere to the specified execution environment and produce the final output exactly in the format described above.", "solution": "The problem of generating the power set of a given sequence of distinct integers is a classic combinatorial task rooted in set theory and is fundamental to algorithm design. A direct and efficient solution can be constructed based on the mathematical principle of bijection.\n\nFor a finite set $S$ with cardinality $|S| = n$, its power set, denoted $\\mathcal{P}(S)$, is the set of all possible subsets of $S$. The cardinality of the power set is $|\\mathcal{P}(S)| = 2^n$. There exists a one-to-one correspondence (a bijection) between the subsets in $\\mathcal{P}(S)$ and the set of all binary strings of length $n$.\n\nThis bijection can be established by considering an ordered sequence of elements from $S$, say $s_0, s_1, \\dots, s_{n-1}$. Any subset of $S$ can be uniquely represented by an $n$-bit binary indicator vector $b = (b_{n-1}, \\dots, b_1, b_0)$, where the bit $b_j$ is $1$ if the element $s_j$ is present in the subset and $0$ otherwise.\n\nThe problem specifies a precise mapping and enumeration order. The set of all $n$-bit binary vectors corresponds to the integers from $0$ to $2^n - 1$. The enumeration of subsets must follow the ascending order of these integers. The mapping from bits to elements is defined such that the least significant bit (LSB), or bit $0$, corresponds to the first element of the input sequence (at index $0$), bit $1$ corresponds to the second element (at index $1$), and so on, up to bit $n-1$ for the $n$-th element.\n\nThe task is to create a \"lazy\" iterator, which generates each subset only when requested, rather than materializing the entire power set in memory. This is crucial for efficiency, as the size of the power set grows exponentially with the size of the input sequence. The required space complexity overhead of $\\mathcal{O}(n)$ precludes storing all $2^n$ subsets.\n\nAn algorithm that satisfies these requirements can be designed as follows:\n1.  Let the input sequence be $A$ of length $n$.\n2.  The total number of subsets is $N = 2^n$.\n3.  We use a counter, let's call it `i`, that iterates through the integers from $0$ to $N-1$. Each value of `i` uniquely identifies a subset.\n4.  For each integer `i`, we construct the corresponding subset on-the-fly. To do this, we iterate from $j = 0$ to $n-1$. At each step $j$, we check if the $j$-th bit of `i` is set to $1$.\n5.  The check for the $j$-th bit of `i` can be performed efficiently using bitwise operations. The expression `(i  j)  1` evaluates to $1$ if the $j$-th bit of `i` is set, and $0$ otherwise. The `` operator is a right bit shift.\n6.  If the $j$-th bit is $1$, we include the element at index $j$ of the input sequence, $A[j]$, in the current subset.\n7.  This process is repeated for each requested subset, with the iterator advancing the counter `i` by one for each subsequent call.\n\nIn Python, this lazy iteration is most idiomatically implemented using a generator function. A generator function uses the `yield` keyword to return a value and pause its execution, preserving its internal state (in this case, the counter `i`). When the next value is requested, the function resumes from where it left off. This approach naturally fulfills the lazy evaluation and $\\mathcal{O}(n)$ space complexity requirements, as it only stores the input sequence, the current state of the counter, and the memory for the single subset being constructed.\n\nThe final program will implement this generator. It will then iterate through the specified test cases. For each case $(A, k)$, it will create a new generator instance and retrieve the first $k$ subsets, or fewer if the total number of subsets is less than $k$. The results from all test cases are aggregated into a single list, which is then formatted into a string representation with no spaces as per the specific output requirements.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lazy_power_set(sequence):\n    \"\"\"\n    A lazy iterator (generator) for the power set of a sequence.\n\n    The enumeration order follows the ascending integer value of the\n    binary indicator vector, where the LSB corresponds to the first\n    element of the sequence.\n\n    Args:\n        sequence (list): A list of distinct elements.\n\n    Yields:\n        list: The next subset in the enumeration.\n    \"\"\"\n    n = len(sequence)\n    num_subsets = 1  n  # This is equivalent to 2**n\n\n    for i in range(num_subsets):\n        subset = []\n        for j in range(n):\n            # Check if the j-th bit of i is set.\n            # (i  j) shifts the j-th bit to the LSB position.\n            #  1 isolates this bit.\n            if (i  j)  1:\n                subset.append(sequence[j])\n        yield subset\n\ndef format_list_no_spaces(obj):\n    \"\"\"\n    Recursively formats a list or other object into a string\n    representation without spaces after commas, as required by the spec.\n    \"\"\"\n    if isinstance(obj, list):\n        # Recursively format each item and join with commas.\n        return f\"[{','.join(format_list_no_spaces(item) for item in obj)}]\"\n    else:\n        # For non-list items, use their standard string representation.\n        return str(obj)\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([], 1),\n        ([7], 2),\n        ([1, 2, 3], 4),\n        ([2, 4, 6, 8], 9),\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], 5),\n    ]\n\n    all_results = []\n    for A, k in test_cases:\n        case_result = []\n        iterator = lazy_power_set(A)\n        \n        try:\n            for _ in range(k):\n                case_result.append(next(iterator))\n        except StopIteration:\n            # This handles cases where k  2**|A|. The loop will\n            # naturally terminate when the iterator is exhausted.\n            pass\n            \n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The custom formatter ensures no spaces are included in the list representations.\n    print(format_list_no_spaces(all_results))\n\nsolve()\n```", "id": "3259468"}, {"introduction": "Power set generation is a foundational tool for tackling a wide range of combinatorial search problems. This exercise applies this tool to a classic challenge: finding all subsets whose elements sum to a value within a given range [@problem_id:3259397]. By solving this, you will practice the 'generate-and-test' paradigm, a common problem-solving pattern where a brute-force enumeration is filtered to find solutions.", "problem": "You are given a finite sequence $S$ of integers of length $n$. Consider the power set of $S$, which is the set of all $2^n$ subsets, including the empty subset. For any subset, its sum is defined as the sum of the elements at the selected positions of $S$. Because $S$ may contain repeated values, two distinct subsets (identified by different index sets) that sum to the same integer must both be counted. The empty subset is allowed and has sum $0$. You are also given a closed interval $[W_{\\min}, W_{\\max}]$ consisting of two integers with $W_{\\min} \\le W_{\\max}$. The task is to design an algorithm that, for each input instance, enumerates all subsets whose sums lie within the range $[W_{\\min}, W_{\\max}]$, grounded in the fundamental definitions of sets, sums, and the binary representation of subsets.\n\nYour algorithmic design must start from the following fundamental base:\n- The power set of a set of size $n$ has cardinality $2^n$.\n- Every subset of positions can be represented as a length-$n$ binary vector (or equivalently an integer bit mask from $0$ to $2^n - 1$), where bit $i$ indicates whether index $i$ is included.\n- For any bipartition of $S$ into two halves of sizes $n_1$ and $n_2$ with $n_1 + n_2 = n$, every subset of $S$ corresponds uniquely to the concatenation of a subset of the left half and a subset of the right half, and the sum of the whole is the sum of the parts.\n\nYour program must, for each test case, produce the multiset of all subset sums that lie in $[W_{\\min}, W_{\\max}]$, sorted in nondecreasing order, and with multiplicity preserved; that is, if multiple distinct subsets have the same sum in the interval, that sum should appear multiple times. To make the output compact and verifiable, you should output only these sums, not the subsets themselves.\n\nInput is not read from standard input. Instead, your program should internally define and run the prescribed test suite below. For each test case, compute the sorted multiset of valid subset sums and aggregate the per-test-case results into a single line as specified.\n\nDefinitions and rules to follow:\n- The sequence $S$ may contain repeated integers and may contain negative integers.\n- The empty subset is included; its sum is $0$.\n- The interval $[W_{\\min}, W_{\\max}]$ is inclusive of both endpoints.\n- Subsets are distinguished by the indices of $S$, not merely by values. If $S$ contains equal values at different indices, then selecting them in different index combinations yields different subsets.\n\nTest suite to implement in your program:\n- Test case $1$: $S = [1, 2, 3]$, $W_{\\min} = 3$, $W_{\\max} = 5$.\n- Test case $2$: $S = [0, 0]$, $W_{\\min} = 0$, $W_{\\max} = 0$.\n- Test case $3$: $S = []$ (the empty sequence), $W_{\\min} = 0$, $W_{\\max} = 1$.\n- Test case $4$: $S = [5, -2, 7, -3]$, $W_{\\min} = 0$, $W_{\\max} = 5$.\n- Test case $5$: $S = [2, 2, 2]$, $W_{\\min} = 4$, $W_{\\max} = 4$.\n- Test case $6$: $S = [1, 2]$, $W_{\\min} = 10$, $W_{\\max} = 20$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- Each individual test case result must itself be a bracketed, comma-separated list of integers, with no whitespace anywhere in the entire output.\n- For example, if there were three test cases whose results were the lists $[0, 1, 1]$, $[2, 3]$, and $[4]$, then the output line must be exactly the single string \"[[0,1,1],[2,3],[4]]\".\n- Therefore, for the six prescribed test cases, your program must print a single line looking like \"[case1,case2,case3,case4,case5,case6]\" where each \"case$k$\" is the no-whitespace bracketed list of integers for test case $k$ as defined above.\n\nYour algorithmic reasoning and implementation should be grounded in the base principles stated above, without invoking unproven shortcuts. The answer for each test case is a list of integers, and the aggregated final output is a single line in the format described. No physical units or angle units apply to this purely discrete problem, and there are no percentages to express.", "solution": "The problem statement has been rigorously validated and is determined to be valid. It is a well-posed computational problem grounded in the fundamental principles of discrete mathematics and set theory, specifically concerning power sets and subset sums. It is self-contained, objective, and free from any scientific or logical flaws. We may therefore proceed with a complete solution.\n\nThe problem requires us to find all subset sums of a given integer sequence $S$ of length $n$ that fall within a specified closed interval $[W_{\\min}, W_{\\max}]$. The core of the problem lies in the systematic enumeration and summation of subsets.\n\n**Fundamental Principle: Subset Representation via Binary Integers**\n\nThe problem correctly states that the power set of a set with $n$ elements has a cardinality of $2^n$. Each of these $2^n$ subsets can be uniquely mapped to an integer $k$ in the range $[0, 2^n - 1]$. This mapping is established by considering the $n$-bit binary representation of $k$. Let the sequence be $S = (S_0, S_1, \\dots, S_{n-1})$. An integer $k$ corresponds to a subset where the element $S_j$ is included if and only if the $j$-th bit of $k$ (from the right, or least significant bit) is $1$.\n\nFor example, if $S = [10, 20, 30]$ ($n=3$), the integer $k=5$ has a binary representation of $101_2$. This corresponds to the subset including $S_0=10$ and $S_2=30$, giving a sum of $10+30=40$. The integer $k=0$ ($000_2$) corresponds to the empty set with sum $0$, and $k=7$ ($111_2$) corresponds to the entire set with sum $10+20+30=60$.\n\n**Direct Algorithmic Approach**\n\nThis one-to-one correspondence between integers from $0$ to $2^n - 1$ and subsets of $S$ provides a direct, or brute-force, algorithm:\n1.  Initialize an empty multiset, `results`, to store valid sums.\n2.  Iterate through each integer $k$ from $0$ to $2^n - 1$.\n3.  For each $k$, calculate the corresponding subset sum. Initialize a variable `current_sum` to $0$.\n4.  Iterate through each index $j$ from $0$ to $n-1$.\n5.  To check if the $j$-th bit of $k$ is set, we can use a bitwise AND operation. If $(k \\text{ AND } 2^j) \\neq 0$ (or, equivalently, `(k  j)  1 == 1`), it signifies that the $j$-th element $S_j$ is in the subset. In this case, add $S_j$ to `current_sum`.\n6.  After iterating through all indices $j$ for a given $k$, the `current_sum` is complete.\n7.  Check if this sum falls within the target range: $W_{\\min} \\le \\text{current\\_sum} \\le W_{\\max}$.\n8.  If it does, add `current_sum` to the `results` multiset.\n9.  After the main loop over all $k$ has finished, sort the `results` multiset in non-decreasing order.\n\nThe time complexity of this algorithm is determined by the two nested loops. The outer loop runs $2^n$ times, and the inner loop runs $n$ times. Thus, the total time complexity is $O(n \\cdot 2^n)$. The space complexity is determined by the number of valid sums, which in the worst case could be all $2^n$ of them, leading to $O(2^n)$ space. For the small values of $n$ present in the test suite (the maximum is $n=4$), this approach is computationally feasible and straightforward to implement.\n\n**Optimized Approach: The Meet-in-the-Middle Principle**\n\nThe problem statement provides a hint towards a more advanced technique by mentioning bipartitioning. This suggests the \"meet-in-the-middle\" algorithm, which is significantly more efficient for larger $n$.\n\nThe principle is that any subset of $S$ can be formed by taking the union of a subset of a first part of $S$ and a subset of a second part of $S$. Consequently, any subset sum of $S$ is the sum of a subset sum from the first part and one from the second part.\n1.  **Partition**: Split the sequence $S$ of length $n$ into two halves: $S_1 = (S_0, \\dots, S_{n_1-1})$ of length $n_1 = \\lfloor n/2 \\rfloor$, and $S_2 = (S_{n_1}, \\dots, S_{n-1})$ of length $n_2 = n - n_1$.\n2.  **Generate Half-Sums**:\n    *   Generate all $2^{n_1}$ subset sums for $S_1$ using the direct method described above. Store these sums in a list, call it `sums1`.\n    *   Similarly, generate all $2^{n_2}$ subset sums for $S_2$ and store them in a list, `sums2`.\n3.  **Combine and Search**: We are looking for pairs $(s_1, s_2)$ where $s_1 \\in \\text{sums1}$ and $s_2 \\in \\text{sums2}$ such that $W_{\\min} \\le s_1 + s_2 \\le W_{\\max}$. For a fixed $s_1$, this inequality can be rewritten as $W_{\\min} - s_1 \\le s_2 \\le W_{\\max} - s_1$.\n4.  **Efficient Search**: To find the qualifying $s_2$ values efficiently, we first sort one of the lists, for instance, `sums2`. Then, for each $s_1$ in `sums1`, we can use binary search on the sorted `sums2` to find the range of elements that satisfy the condition $W_{\\min} - s_1 \\le s_2 \\le W_{\\max} - s_1$. This can be done in $O(\\log(2^{n_2})) = O(n_2)$ time for each $s_1$.\n5.  **Collect and Sort**: All sums $s_1 + s_2$ found this way are collected into a final `results` list, which is then sorted.\n\nThe time complexity of this optimized algorithm is dominated by generating the half-sums and the combining step. Generating `sums1` takes $O(n_1 \\cdot 2^{n_1})$, and `sums2` takes $O(n_2 \\cdot 2^{n_2})$. Sorting `sums2` takes $O(2^{n_2} \\log(2^{n_2})) = O(n_2 \\cdot 2^{n_2})$. The main loop runs $2^{n_1}$ times, with each step taking $O(n_2)$ for binary search. Since $n_1 \\approx n/2$ and $n_2 \\approx n/2$, the overall complexity is approximately $O(n \\cdot 2^{n/2})$. This is a substantial improvement over $O(n \\cdot 2^n)$ for large $n$. For instance, if $n=40$, $2^{40}$ is computationally impossible, whereas $40 \\cdot 2^{20}$ is manageable.\n\n**Implementation Choice for This Problem**\n\nGiven that the maximum length of any sequence $S$ in the provided test suite is $n=4$, the direct brute-force approach with complexity $O(n \\cdot 2^n)$ is more than sufficient and is simpler to implement correctly. Its logic is a direct translation of the core principle of representing subsets with bitmasks. Therefore, the provided solution will implement this direct method.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the subset sum problem for a predefined test suite.\n    The final output is a single line, formatted as a list of lists of integers.\n    \"\"\"\n    \n    # Test suite as defined in the problem statement.\n    test_cases = [\n        {'S': [1, 2, 3], 'W_min': 3, 'W_max': 5},\n        {'S': [0, 0], 'W_min': 0, 'W_max': 0},\n        {'S': [], 'W_min': 0, 'W_max': 1},\n        {'S': [5, -2, 7, -3], 'W_min': 0, 'W_max': 5},\n        {'S': [2, 2, 2], 'W_min': 4, 'W_max': 4},\n        {'S': [1, 2], 'W_min': 10, 'W_max': 20},\n    ]\n\n    # Helper function to generate all subset sums for a given sequence.\n    def get_all_subset_sums(s_list):\n        n = len(s_list)\n        num_subsets = 1  n  # This is 2**n\n        all_sums = []\n        for i in range(num_subsets):\n            current_sum = 0\n            for j in range(n):\n                # Check if the j-th bit is set in the integer i\n                if (i  j)  1:\n                    current_sum += s_list[j]\n            all_sums.append(current_sum)\n        return all_sums\n\n    all_results = []\n    \n    for case in test_cases:\n        S = case['S']\n        W_min = case['W_min']\n        W_max = case['W_max']\n\n        # Step 1: Generate all possible subset sums.\n        # This is the direct application of the principle mapping integers 0..2^n-1\n        # to subsets.\n        all_sums = get_all_subset_sums(S)\n        \n        # Step 2: Filter sums to find those within the interval [W_min, W_max].\n        valid_sums = []\n        for s in all_sums:\n            if W_min = s = W_max:\n                valid_sums.append(s)\n        \n        # Step 3: Sort the resulting multiset of sums.\n        valid_sums.sort()\n        \n        all_results.append(valid_sums)\n\n    # Format the final output string exactly as specified.\n    # e.g., [[3,3,4,5],[0,0,0,0],...]\n    case_results_str = []\n    for res_list in all_results:\n        # Format each inner list: [i1,i2,...] with no whitespace\n        inner_str = f\"[{','.join(map(str, res_list))}]\"\n        case_results_str.append(inner_str)\n    \n    final_output = f\"[{','.join(case_results_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3259397"}, {"introduction": "While the 'generate-and-test' method is powerful, it can be inefficient for problems where valid solutions are sparse. A more advanced strategy is to avoid generating invalid subsets altogether by pruning the search space. This practice introduces the concept of monotonic properties to build a highly optimized backtracking algorithm that generates only valid subsets [@problem_id:3259478], a technique crucial for tackling complex computational problems efficiently.", "problem": "You are given a finite sequence of integers $A$ of length $n$, and a predicate $Q$ defined on the power set $\\mathcal{P}(A)$. The predicate $Q$ is monotonic on the subset lattice $(\\mathcal{P}(A), \\subseteq)$ in one of two senses: either downward-closed (hereditarily monotonic) or upward-closed (extensively monotonic). A predicate $Q$ is downward-closed if whenever $Q(S)$ is true and $T \\subseteq S$, then $Q(T)$ is also true. A predicate $Q$ is upward-closed if whenever $Q(S)$ is true and $S \\subseteq T$, then $Q(T)$ is also true. The task is to implement a backtracking algorithm that generates only the subsets $S \\subseteq A$ for which $Q(S)$ is true by pruning the search space using the monotonicity of $Q$.\n\nStart from the fundamental definitions of the subset lattice and monotonicity, and design the algorithm from first principles: a depth-first traversal of the binary decision tree where at each position $i$ you decide to either include $A[i]$ or exclude $A[i]$. Derive pruning rules from monotonicity without using any shortcut formulas. For downward-closed $Q$, if a partial selection $S$ violates $Q$, then any superset of $S$ also violates $Q$ and the branch can be pruned. For upward-closed $Q$, if a partial selection $S$ already satisfies $Q$, then any superset of $S$ will satisfy $Q$ and you may generate all completions of the remaining elements without further checks. Additionally, for upward-closed $Q$, if even with all remaining elements the property cannot be achieved, the branch should be pruned.\n\nThe elements of $A$ are integers without physical units. There are no angles or percentages in this task.\n\nImplement the algorithm to process the following test suite. For each test case, $A$ is specified along with a monotonic predicate $Q$ and any needed parameters. For every test case, list all satisfying subsets in a deterministic order obtained by scanning $A$ from left to right and branching in the fixed order \"exclude then include.\" Represent each subset as a list of integers in the original order of $A$.\n\nTest suite:\n- Case $1$ (downward-closed): $A = [1,2,3]$, $Q$ is \"$\\sum_{x \\in S} x \\le T$\" with $T = 3$.\n- Case $2$ (upward-closed): $A = [2,3,5]$, $Q$ is \"$\\sum_{x \\in S} x \\ge L$\" with $L = 7$.\n- Case $3$ (downward-closed): $A = [1,4,6,7]$, $Q$ is \"$|S| \\le k$\" with $k = 2$.\n- Case $4$ (upward-closed): $A = [3,5,8,10]$, $Q$ is \"the set $S$ contains at least one even element.\"\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is the list of satisfying subsets for the corresponding test case. For example, the overall format is $[r_1,r_2,r_3,r_4]$ where $r_i$ is a list of lists of integers. The program must be self-contained, require no input, and compute outputs for the specified test suite only.", "solution": "We formalize the search space as the subset lattice $(\\mathcal{P}(A), \\subseteq)$ over a finite sequence $A$ of length $n$. A depth-first search (DFS) backtracking traversal visits nodes indexed by position $i \\in \\{0,1,\\dots,n\\}$ and a partial selection $S \\subseteq \\{A[0],A[1],\\dots,A[i-1]\\}$. At each step, the algorithm chooses to exclude $A[i]$ or include $A[i]$ and proceeds to $i+1$.\n\nThe pruning design follows from the definitions of monotonicity:\n\n- Downward-closed predicate $Q$: If a partial set $S$ does not satisfy $Q$, then any superset $T \\supseteq S$ cannot satisfy $Q$ by definition of downward-closure. Therefore, once a node violates $Q$, the entire subtree below that node can be pruned. This eliminates exploration of branches that cannot possibly yield satisfying sets.\n\n- Upward-closed predicate $Q$: If a partial set $S$ satisfies $Q$, then any superset $T \\supseteq S$ also satisfies $Q$ by definition of upward-closure. Thus, once a node satisfies $Q$, the algorithm can enumerate all completions on the remaining positions $i,i+1,\\dots,n-1$ and output the combinations $S \\cup R$ for all $R \\subseteq \\{A[i],\\dots,A[n-1]\\}$ without further property checks. Additionally, we incorporate an impossibility bound: if even the most favorable addition of all remaining elements cannot make $S$ satisfy $Q$, then the branch is pruned.\n\nWe instantiate $Q$ for the test suite using well-tested facts and direct bounds:\n\n- For $Q_{\\le\\mathrm{sum}}$: Maintain the running sum $s(S) = \\sum_{x \\in S} x$. If $s(S)  T$ at any node, prune that branch because any addition preserves $s(S) \\ge s(S)$ and will keep $s(S)  T$ or increase it further, violating the downward-closed property.\n\n- For $Q_{\\ge\\mathrm{sum}}$: Maintain the running sum $s(S)$. Let $M_i = \\sum_{j=i}^{n-1} A[j]$ be the maximum additional sum achievable from the suffix. If $s(S) + M_i  L$, then no superset can reach the threshold and the branch is pruned. If $s(S) \\ge L$, the branch already satisfies $Q$ and we enumerate all suffix completions. These bounds follow from the fact that the sum is additive and integers are non-negative in the given data.\n\n- For $Q_{\\le\\mathrm{card}}$: Maintain $c(S) = |S|$. If $c(S)  k$ at any node, prune due to downward-closure of the cardinality constraint.\n\n- For $Q_{\\exists\\mathrm{even}}$: Maintain a boolean $e(S)$ indicating whether $S$ already contains an even element. If $e(S)$ is true, enumerate all suffix completions. If $e(S)$ is false and the remaining suffix contains no even elements, then no superset can ever satisfy $Q$, so prune. The impossibility bound comes from the observation that the property depends only on the existence of at least one even element.\n\nThe traversal order is fixed: at each position $i$, we branch \"exclude then include,\" ensuring a deterministic ordering of outputs. Represent each subset $S$ as the list of its elements in the original order of $A$.\n\nComplexity perspective: In the worst case without pruning, generating the power set takes $O(2^n)$ time. With monotonic pruning, the algorithm explores only branches that can yield satisfying sets, and for upward-closed properties, it replaces entire subtrees with a direct enumeration of suffix combinations once the predicate is satisfied. The runtime therefore scales with the number of satisfying subsets plus the overhead to check bounds, which is $O(n)$ per node for simple aggregated state (for example, maintaining $s(S)$, $c(S)$, or $e(S)$ and suffix summaries $M_i$ or boolean suffix parity availability).\n\nApplying these principled rules yields a correct and efficient generator for the given test suite. The output is aggregated into a single line $[r_1,r_2,r_3,r_4]$, where $r_i$ is a list of satisfying subsets for case $i$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef emit_all_completions(prefix, suffix):\n    \"\"\"\n    Emit all supersets formed by taking prefix union any subset of suffix,\n    in a deterministic exclude-first order.\n    \"\"\"\n    results = []\n    def rec(j, acc):\n        if j == len(suffix):\n            results.append(prefix + acc)\n            return\n        # Exclude suffix[j]\n        rec(j + 1, acc)\n        # Include suffix[j]\n        rec(j + 1, acc + [suffix[j]])\n    rec(0, [])\n    return results\n\ndef generate_subsets_with_pruning_sum_at_most(A, T):\n    \"\"\"\n    Downward-closed property: sum(S) = T.\n    Prune when running sum exceeds T.\n    \"\"\"\n    n = len(A)\n    results = []\n\n    def backtrack(i, current, current_sum):\n        # Prune if current sum already violates the constraint\n        if current_sum  T:\n            return\n        if i == n:\n            # current_sum = T guaranteed here\n            results.append(current.copy())\n            return\n        # Exclude A[i]\n        backtrack(i + 1, current, current_sum)\n        # Include A[i]\n        current.append(A[i])\n        backtrack(i + 1, current, current_sum + A[i])\n        current.pop()\n\n    backtrack(0, [], 0)\n    return results\n\ndef generate_subsets_with_pruning_sum_at_least(A, L):\n    \"\"\"\n    Upward-closed property: sum(S) = L.\n    Positive prune: if current_sum = L, emit all completions.\n    Impossibility prune: if current_sum + sum(remaining)  L, prune.\n    \"\"\"\n    n = len(A)\n    # Precompute suffix maximum sums M_i = sum(A[i:])\n    suffix_sum = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        suffix_sum[i] = suffix_sum[i + 1] + A[i]\n\n    results = []\n\n    def backtrack(i, current, current_sum):\n        # Positive prune: already satisfies\n        if current_sum = L:\n            results.extend(emit_all_completions(current.copy(), A[i:]))\n            return\n        # Impossibility prune: cannot reach L even if we add all remaining\n        if current_sum + suffix_sum[i]  L:\n            return\n        if i == n:\n            # current_sum  L here due to above conditions, so no output\n            return\n        # Exclude A[i]\n        backtrack(i + 1, current, current_sum)\n        # Include A[i]\n        current.append(A[i])\n        backtrack(i + 1, current, current_sum + A[i])\n        current.pop()\n\n    backtrack(0, [], 0)\n    return results\n\ndef generate_subsets_with_pruning_card_at_most(A, k):\n    \"\"\"\n    Downward-closed property: |S| = k.\n    Prune when cardinality exceeds k.\n    \"\"\"\n    n = len(A)\n    results = []\n\n    def backtrack(i, current, size):\n        if size  k:\n            return\n        if i == n:\n            results.append(current.copy())\n            return\n        # Exclude A[i]\n        backtrack(i + 1, current, size)\n        # Include A[i]\n        current.append(A[i])\n        backtrack(i + 1, current, size + 1)\n        current.pop()\n\n    backtrack(0, [], 0)\n    return results\n\ndef generate_subsets_with_pruning_exists_even(A):\n    \"\"\"\n    Upward-closed property: there exists at least one even element in S.\n    Positive prune: if S already has an even, emit all completions.\n    Impossibility prune: if S has no even and no even remains in suffix, prune.\n    \"\"\"\n    n = len(A)\n    # Precompute suffix availability of even numbers\n    suffix_has_even = [False] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        suffix_has_even[i] = suffix_has_even[i + 1] or (A[i] % 2 == 0)\n\n    results = []\n\n    def backtrack(i, current, has_even):\n        # Positive prune: already satisfies\n        if has_even:\n            results.extend(emit_all_completions(current.copy(), A[i:]))\n            return\n        # Impossibility prune: cannot ever get an even\n        if not suffix_has_even[i]:\n            return\n        if i == n:\n            # has_even is False here, so no output\n            return\n        # Exclude A[i]\n        backtrack(i + 1, current, has_even)\n        # Include A[i]\n        current.append(A[i])\n        backtrack(i + 1, current, has_even or (A[i] % 2 == 0))\n        current.pop()\n\n    backtrack(0, [], False)\n    return results\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"sum_at_most\", [1, 2, 3], {\"T\": 3}),\n        (\"sum_at_least\", [2, 3, 5], {\"L\": 7}),\n        (\"card_at_most\", [1, 4, 6, 7], {\"k\": 2}),\n        (\"exists_even\", [3, 5, 8, 10], {}),\n    ]\n\n    results = []\n    for qtype, A, params in test_cases:\n        if qtype == \"sum_at_most\":\n            result = generate_subsets_with_pruning_sum_at_most(A, params[\"T\"])\n        elif qtype == \"sum_at_least\":\n            result = generate_subsets_with_pruning_sum_at_least(A, params[\"L\"])\n        elif qtype == \"card_at_most\":\n            result = generate_subsets_with_pruning_card_at_most(A, params[\"k\"])\n        elif qtype == \"exists_even\":\n            result = generate_subsets_with_pruning_exists_even(A)\n        else:\n            result = []\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\nsolve()\n```", "id": "3259478"}]}