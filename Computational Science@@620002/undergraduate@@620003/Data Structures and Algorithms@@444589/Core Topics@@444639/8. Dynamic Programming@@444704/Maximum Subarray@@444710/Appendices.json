{"hands_on_practices": [{"introduction": "The best way to understand an algorithm is to build it from the ground up. This first exercise [@problem_id:3250522] guides you through implementing the classic divide-and-conquer solution for the maximum subarray problem. By requiring a specific tie-breaking policy, this practice sharpens your focus on the detailed logic within the \"combine\" step, where the solutions from subproblems are merged to find the overall optimum.", "problem": "You are given a finite string over the lowercase English alphabet. Map each character to an integer weight via the correspondence $a \\mapsto 1, b \\mapsto 2, \\ldots, z \\mapsto 26$. Consider the array $A$ of integer weights constructed from the given string in order. A contiguous substring corresponds to a contiguous subarray of $A$. Define the sum of a contiguous subarray $A[i..j]$ to be $S(i,j) = \\sum_{t=i}^{j} A[t]$. The task is to compute, using a Divide and Conquer (D&C) paradigm, the maximum subarray sum and the corresponding substring’s indices with the following tie-breaking policy: if multiple substrings achieve the same maximum sum, choose the one with the smallest starting index $i$, and if there is still a tie, choose the one with the smallest ending index $j$. Indices must be reported using $0$-based indexing. If the string is empty, define the maximum sum to be $0$ and the indices to be $-1$ and $-1$.\n\nStart from fundamental definitions: a contiguous subarray, an arithmetic summation, and the D&C principle that reduces a problem on size $n$ to subproblems on sizes less than $n$ plus a linear-time combination step. Do not use shortcut formulas. Design the algorithm by reasoning that a maximum subarray on $A[i..j]$ must be either entirely in the left half, entirely in the right half, or cross the midpoint. Derive how to compute the crossing case by constructing the maximum suffix of the left half and the maximum prefix of the right half and combining them.\n\nYour program must implement this D&C approach to return, for each test case, a triple $[S,i,j]$ where $S$ is the maximum sum and $i$ and $j$ are the $0$-based start and end indices of the chosen substring under the stated tie-breaking rules.\n\nTest Suite:\n- Case $1$ (general case): the string \"abcxyz\".\n- Case $2$ (boundary case: empty): the empty string \"\".\n- Case $3$ (single-element): the string \"z\".\n- Case $4$ (homogeneous): the string \"aaaaa\".\n- Case $5$ (another general case): the string \"lmnoa\".\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each result itself formatted as $[S,i,j]$ and no spaces. For example, the output should look exactly like \"[[S1,i1,j1],[S2,i2,j2],[S3,i3,j3],[S4,i4,j4],[S5,i5,j5]]\" for the five cases above.", "solution": "**Problem Validation**\n\nThe provided problem is a well-defined computational task from the domain of algorithms. It asks for the implementation of a specific paradigm (Divide and Conquer) to solve the maximum subarray sum problem, augmented with a character-to-integer mapping and a clear, hierarchical tie-breaking policy.\n\n1.  **Givens Extracted**:\n    *   **Input**: A finite string over the lowercase English alphabet.\n    *   **Mapping**: $a \\mapsto 1, b \\mapsto 2, \\ldots, z \\mapsto 26$.\n    *   **Array**: An array $A$ of integer weights derived from the string.\n    *   **Target**: Find the contiguous subarray $A[i..j]$ with the maximum sum $S(i,j) = \\sum_{t=i}^{j} A[t]$.\n    *   **Algorithm**: Must use Divide and Conquer (D&C).\n    *   **Tie-Breaking**: If sums are equal, choose the one with the smallest start index $i$. If still tied, choose the one with the smallest end index $j$.\n    *   **Indexing**: $0$-based.\n    *   **Edge Case**: For an empty string, the result is sum $0$ with indices $-1, -1$.\n    *   **Output**: A triple $[S, i, j]$.\n\n2.  **Validation Verdict**:\n    *   **Scientifically Grounded**: The problem is based on established computer science and mathematical principles. The mapping is a simple bijective function.\n    *   **Well-Posed**: The problem is unambiguous. The input, transformation, objective function (maximization), constraints (D&C), and tie-breaking rules are all specified, guaranteeing a unique solution.\n    *   **Objective**: The problem is stated with formal, objective language.\n\nThe problem is **valid**. It is a standard algorithmic exercise with specific constraints that test the understanding of the D&C paradigm and the careful implementation of tie-breaking rules.\n\n**Solution Derivation**\n\nThe problem asks for an algorithm to find the contiguous subarray with the maximum sum within a given array of numbers $A$, derived from a string. The algorithm must follow the Divide and Conquer (D&C) paradigm.\n\nLet the input array be $A$ of size $N$. Let our function operate on a subarray defined by indices `low` and `high`, denoted as $A[low..high]$.\n\n**1. Fundamental Principle: Divide and Conquer**\n\nThe D&C strategy consists of three steps:\n*   **Divide**: Divide the problem instance into two or more smaller, independent subproblems of the same type.\n*   **Conquer**: Solve the subproblems recursively. If the subproblem sizes are small enough, solve them directly (base case).\n*   **Combine**: Combine the solutions of the subproblems to form the solution for the original problem.\n\nFor the maximum subarray problem on $A[low..high]$, we divide the array into two halves at the midpoint, $mid = \\lfloor(low + high) / 2\\rfloor$. The maximum subarray can therefore reside in one of three locations:\n1.  Entirely in the left subarray, $A[low..mid]$.\n2.  Entirely in the right subarray, $A[mid+1..high]$.\n3.  Crossing the midpoint, i.e., a subarray $A[i..j]$ such that $low \\le i \\le mid < j \\le high$.\n\n**2. Recursive Structure and Base Case**\n\nThe D&C approach leads to a recursive function.\n\n*   **Recursive Step**: We solve for the maximum subarray in the left half and the right half by making two recursive calls. We then compute the maximum subarray that crosses the midpoint. Finally, we compare the results of these three cases to find the overall maximum, respecting the tie-breaking rules.\n\n*   **Base Case**: The recursion terminates when the subarray contains only one element, i.e., when $low = high$. For such a subarray $A[i..i]$, the maximum subarray is the element itself. The sum is $A[i]$, the start index is $i$, and the end index is $i$. The result is $[A[i], i, i]$.\n\n**3. The Crossing Subarray Calculation**\n\nThis is the core of the \"Combine\" step. A subarray $A[i..j]$ that crosses the midpoint $mid$ is formed by the concatenation of a suffix of the left half, $A[i..mid]$, and a prefix of the right half, $A[mid+1..j]$.\nThe sum is $S(i,j) = (\\sum_{k=i}^{mid} A[k]) + (\\sum_{k=mid+1}^{j} A[k])$.\n\nTo maximize this sum, we must independently maximize the sum of the left suffix and the sum of the right prefix.\n\n*   **Maximum Suffix of the Left Half**: We need to find an index $i$ in $[low, mid]$ that maximizes $\\sum_{k=i}^{mid} A[k]$. We can compute this by iterating from $k = mid$ down to $low$. We maintain a running sum and track the maximum sum seen so far and the index $i$ that produced it.\n    Let $S_{left\\_cross}$ be the maximum suffix sum and $i_{cross}$ be its starting index. We initialize $S_{left\\_cross}$ to a value smaller than any possible sum (e.g., $-\\infty$) and maintain a `current_sum`.\n    `current_sum = 0`\n    `max_left_sum = -∞`\n    `start_index = -1`\n    For $k$ from $mid$ down to $low$:\n        `current_sum = current_sum + A[k]`\n        If `current_sum >= max_left_sum`:\n            `max_left_sum = current_sum`\n            `start_index = k`\n    The tie-breaking rule requires the smallest start index $i$. By updating the index `k` when `current_sum >= max_left_sum`, we ensure that for a given maximum sum, we select the one with the smallest index (since we are iterating downwards from $mid$ to $low$).\n\n*   **Maximum Prefix of the Right Half**: Similarly, we need to find an index $j$ in $[mid+1, high]$ that maximizes $\\sum_{k=mid+1}^{j} A[k]$. We iterate from $k = mid+1$ up to $high$.\n    Let $S_{right\\_cross}$ be the maximum prefix sum and $j_{cross}$ be its ending index.\n    `current_sum = 0`\n    `max_right_sum = -∞`\n    `end_index = -1`\n    For $k$ from $mid+1$ up to $high$:\n        `current_sum = current_sum + A[k]`\n        If `current_sum > max_right_sum`:\n            `max_right_sum = current_sum`\n            `end_index = k`\n    The tie-breaking rule, in case of a further tie on start index, requires the smallest end index $j$. By only updating the index `k` when `current_sum > max_right_sum`, we ensure that for a given maximum sum, we keep the first (and therefore smallest) index $k$ that achieved it.\n\nThe maximum crossing subarray has sum $S_{cross} = S_{left\\_cross} + S_{right\\_cross}$ and spans from $i_{cross}$ to $j_{cross}$.\n\n**4. Combining and Tie-Breaking**\n\nLet the results from the three cases be:\n*   Left: $[S_{L}, i_{L}, j_{L}]$\n*   Right: $[S_{R}, i_{R}, j_{R}]$\n*   Crossing: $[S_{C}, i_{C}, j_{C}]$\n\nWe must select the \"best\" of these three results. A result $[S_1, i_1, j_1]$ is better than $[S_2, i_2, j_2]$ if:\n*   $S_1 > S_2$, OR\n*   $S_1 = S_2$ AND $i_1 < i_2$, OR\n*   $S_1 = S_2$ AND $i_1 = i_2$ AND $j_1 < j_2$.\n\nThis comparison must be applied sequentially. First, compare the left and right results to find an intermediate best. Then, compare this intermediate best with the crossing result to determine the final winner for the current recursive call.\n\n**5. Initial Call and Edge Case**\n\nThe main function will first handle the special case of an empty input string, returning $[0, -1, -1]$ as specified. Otherwise, it will convert the input string into the integer array $A$. It then initiates the D&C process by calling the recursive function on the entire array: `find_max_subarray(A, 0, N-1)`.\n\nThe character-to-integer mapping is $f(c) = \\text{ord}(c) - \\text{ord}('a') + 1$. Since all characters are lowercase English letters, all weights in $A$ will be positive integers from $1$ to $26$. This implies that the maximum subarray sum will always be positive for a non-empty string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n\n    def get_weight(char):\n        \"\"\"Maps a character to its integer weight.\"\"\"\n        return ord(char) - ord('a') + 1\n\n    def is_better(res1, res2):\n        \"\"\"\n        Determines if result 1 is better than result 2 based on the tie-breaking rules.\n        A result is a list [Sum, start_index, end_index].\n        \"\"\"\n        s1, i1, j1 = res1\n        s2, i2, j2 = res2\n\n        if s1 > s2:\n            return True\n        if s1 < s2:\n            return False\n        \n        # Sums are equal, check start index\n        if i1 < i2:\n            return True\n        if i1 > i2:\n            return False\n            \n        # Sums and start indices are equal, check end index\n        if j1 < j2:\n            return True\n        \n        return False\n\n    def find_max_crossing_subarray(arr, low, mid, high):\n        \"\"\"\n        Finds the maximum subarray that crosses the midpoint.\n        This is the 'combine' step of the Divide and Conquer algorithm.\n        \"\"\"\n        # Find maximum suffix sum in the left part (A[i..mid])\n        # We use '>=' to find the smallest start index 'i' in case of a tie in sum,\n        # as we iterate from mid down to low.\n        left_sum = -math.inf\n        current_sum = 0\n        cross_i = -1\n        for i in range(mid, low - 1, -1):\n            current_sum += arr[i]\n            if current_sum >= left_sum:\n                left_sum = current_sum\n                cross_i = i\n\n        # Find maximum prefix sum in the right part (A[mid+1..j])\n        # We use '>' to find the smallest end index 'j' in case of a tie in sum,\n        # as we iterate from mid+1 up to high.\n        right_sum = -math.inf\n        current_sum = 0\n        cross_j = -1\n        for j in range(mid + 1, high + 1):\n            current_sum += arr[j]\n            if current_sum > right_sum:\n                right_sum = current_sum\n                cross_j = j\n        \n        return [left_sum + right_sum, cross_i, cross_j]\n\n\n    def find_max_subarray_recursive(arr, low, high):\n        \"\"\"\n        Recursively finds the maximum subarray sum using Divide and Conquer.\n        Handles tie-breaking as specified.\n        \"\"\"\n        # Base case: only one element\n        if low == high:\n            return [arr[low], low, high]\n\n        # Recursive step\n        mid = (low + high) // 2\n\n        # 1. Maximum subarray is in the left half\n        left_res = find_max_subarray_recursive(arr, low, mid)\n\n        # 2. Maximum subarray is in the right half\n        right_res = find_max_subarray_recursive(arr, mid + 1, high)\n\n        # 3. Maximum subarray crosses the midpoint\n        cross_res = find_max_crossing_subarray(arr, low, mid, high)\n\n        # Compare the three results and return the best one\n        best_res = left_res\n        if is_better(right_res, best_res):\n            best_res = right_res\n        if is_better(cross_res, best_res):\n            best_res = cross_res\n            \n        return best_res\n\n    def find_max_subarray(s: str):\n        \"\"\"\n        Wrapper function to handle input string, including the empty string case.\n        \"\"\"\n        # Handle the empty string case as per the problem description\n        if not s:\n            return [0, -1, -1]\n\n        # Convert string to array of integer weights\n        arr = [get_weight(char) for char in s]\n        \n        return find_max_subarray_recursive(np.array(arr), 0, len(arr) - 1)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        \"abcxyz\",  # Case 1\n        \"\",        # Case 2\n        \"z\",       # Case 3\n        \"aaaaa\",   # Case 4\n        \"lmnoa\",   # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_max_subarray(case)\n        # Ensure integer types for S, i, j in the final output.\n        result = [int(r) for r in result]\n        results.append(f\"[{result[0]},{result[1]},{result[2]}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3250522"}, {"introduction": "Real-world applications often present twists on standard problems. This exercise [@problem_id:3250540] challenges you to adapt your thinking to find the maximum subarray in a circular array, where the subarray can \"wrap around\" the ends. The elegant solution involves decomposing the problem into two cases, demonstrating how the linear maximum subarray algorithm can be repurposed as a powerful tool to solve this more complex variant.", "problem": "Given a finite sequence of integers $A = \\langle a_0, a_1, \\dots, a_{n-1} \\rangle$ of length $n$ with $n \\geq 1$, define a non-empty contiguous subarray on a linear array as any sequence $\\langle a_i, a_{i+1}, \\dots, a_j \\rangle$ for integers $i$ and $j$ satisfying $0 \\leq i \\leq j \\leq n-1$. For a circular array, index arithmetic is performed modulo $n$, so a non-empty contiguous subarray may wrap around the boundary and is any sequence of the form $\\langle a_k, a_{k+1}, \\dots, a_{n-1}, a_0, a_1, \\dots, a_\\ell \\rangle$ for integers $k$ and $\\ell$ satisfying $0 \\leq k \\leq n-1$, $0 \\leq \\ell \\leq n-1$, and where the sequence contains at least one element. The sum of a subarray is the usual integer addition of its elements. The maximum subarray sum in a circular array is the largest possible sum among all non-empty contiguous subarrays under circular indexing.\n\nStarting only from the fundamental definitions above and the general design principle of Divide and Conquer (D&C), which decomposes a problem into subproblems on disjoint parts, solves them independently, and then combines their solutions to obtain the solution of the original problem, implement a program that computes the maximum subarray sum in a circular array for each test case provided below. Your implementation must employ a bona fide D&C strategy to compute the necessary quantities; do not use greedy scanning or dynamic programming.\n\nTest suite to evaluate your program:\n- Case $1$: $[5, -3, 5]$\n- Case $2$: $[-5, -1, -8]$\n- Case $3$: $[7]$\n- Case $4$: $[-7]$\n- Case $5$: $[2, 2, 2]$\n- Case $6$: $[0, -2, 0, -3]$\n- Case $7$: $[10, -12, 11, -1, 12]$\n- Case $8$: $[-2, 1]$\n\nFor each case, the required output is the maximum subarray sum in the circular interpretation, expressed as an integer.\n\nFinal output format specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[result_1, result_2, ...]$). The results must correspond to Cases $1$ through $8$ in order. No units are involved, and no additional text should be printed.", "solution": "The user wants me to solve the \"Maximum Circular Subarray Sum\" problem.\nThe problem is valid. It is a well-defined computational problem within the domain of algorithms and data structures, founded on standard mathematical definitions. It is self-contained, objective, and its solution is verifiable. The constraint to use a Divide and Conquer (D&C) strategy is a standard algorithmic paradigm, making the problem a non-trivial exercise in algorithmic design rather than a simple application of a known greedy algorithm.\n\nThe problem of finding the maximum subarray sum in a circular array can be decomposed into two distinct cases. Let the input array be $A = \\langle a_0, a_1, \\dots, a_{n-1} \\rangle$. A non-empty contiguous subarray in this circular arrangement is either:\n$1$. A standard linear subarray that does not wrap around the ends of the array.\n$2$. A subarray that does wrap around, composed of a suffix of the array followed by a prefix of the array, e.g., $\\langle a_k, \\dots, a_{n-1}, a_0, \\dots, a_{\\ell} \\rangle$.\n\nThe maximum circular subarray sum is therefore the maximum of the sums found in these two cases.\n\n**Case 1: Maximum Linear Subarray Sum**\n\nThis is the standard Maximum Subarray Problem. As per the problem's constraint, we must solve this using a Divide and Conquer strategy. A linear D&C approach for this problem involves the following steps for an array segment $A[\\text{low} \\dots \\text{high}]$:\n- **Divide**: Split the array into two halves at the midpoint, $m = \\lfloor (\\text{low} + \\text{high}) / 2 \\rfloor$. The two subproblems are on $A[\\text{low} \\dots m]$ and $A[m+1 \\dots \\text{high}]$.\n- **Conquer**: Recursively solve for the two halves.\n- **Combine**: The maximum subarray in $A[\\textlow \\dots \\text{high}]$ can be located in one of three places:\n    a) Entirely within the left half, $A[\\text{low} \\dots m]$.\n    b) Entirely within the right half, $A[m+1 \\dots \\text{high}]$.\n    c) Crossing the midpoint $m$. A crossing subarray is the sum of the maximum possible suffix sum of the left half and the maximum possible prefix sum of the right half.\n\nTo facilitate the combine step efficiently, our recursive function must return not just the maximum subarray sum for a given segment, but a richer set of information. Specifically, for any array segment, we will compute a tuple of four values:\n$1$. $S_{\\text{total}}$: The sum of all elements in the segment.\n$2$. $S_{\\text{max\\_sub}}$: The maximum subarray sum within the segment.\n$3$. $S_{\\text{max\\_prefix}}$: The maximum sum of any non-empty prefix of the segment.\n$4$. $S_{\\text{max\\_suffix}}$: The maximum sum of any non-empty suffix of the segment.\n\nThe base case for the recursion is a single-element array $\\langle x \\rangle$, for which all four values are simply $x$.\nIn the combine step, given the results from the left half ($L$) and right half ($R$):\n- $S_{\\text{total}} = L.S_{\\text{total}} + R.S_{\\text{total}}$\n- $S_{\\text{max\\_prefix}} = \\max(L.S_{\\text{max\\_prefix}}, L.S_{\\text{total}} + R.S_{\\text{max\\_prefix}})$\n- $S_{\\text{max\\_suffix}} = \\max(R.S_{\\text{max\\_suffix}}, R.S_{\\text{total}} + L.S_{\\text{max\\_suffix}})$\n- $S_{\\text{max\\_sub}} = \\max(L.S_{\\text{max\\_sub}}, R.S_{\\text{max\\_sub}}, L.S_{\\text{max\\_suffix}} + R.S_{\\text{max\\_prefix}})$\n\nThe solution for Case $1$, which we denote $S_{\\text{max\\_linear}}$, is the value $S_{\\text{max\\_sub}}$ returned by this D&C procedure for the entire array $A$.\n\n**Case 2: Maximum Wrapping Subarray Sum**\n\nA wrapping subarray is equivalent to the entire array with a non-wrapping (linear) subarray \"removed\" from the middle. To maximize the sum of the wrapping portion, one must remove a linear subarray with the *minimum* possible sum.\nLet $S_{\\text{total}}$ be the sum of all elements in $A$. The sum of a wrapping subarray is $S_{\\text{total}} - S_{\\text{removed}}$, where $S_{\\text{removed}}$ is the sum of the non-empty linear subarray that is left out.\nMaximizing this expression is equivalent to minimizing $S_{\\text{removed}}$.\nTherefore, the maximum wrapping subarray sum is $S_{\\text{max\\_wrap}} = S_{\\text{total}} - S_{\\text{min\\_linear}}$, where $S_{\\text{min\\_linear}}$ is the minimum linear subarray sum.\n\nThe minimum linear subarray sum can be found using the same D&C machinery. Note the identity: $\\min(X) = -\\max(-X)$. We can find $S_{\\text{min\\_linear}}$ by negating all elements of $A$ to form a new array $A'$, finding the maximum linear subarray sum of $A'$, and then negating the result.\n$S_{\\text{min\\_linear}}(A) = -S_{\\text{max\\_linear}}(-A)$.\n\n**Combining Cases and Handling the Edge Case**\n\nThe final answer is $\\max(S_{\\text{max\\_linear}}, S_{\\text{max\\_wrap}})$. However, a critical edge case exists. The logic for the wrapping sum, $S_{\\text{total}} - S_{\\text{min\\_linear}}$, assumes that the subarray being \"removed\" is a *proper* subarray of $A$. If the minimum linear subarray is the entire array itself, \"removing\" it would leave an empty set, which is not a valid non-empty subarray as per the problem definition.\n\nThis situation occurs if and only if $S_{\\text{min\\_linear}} = S_{\\text{total}}$. This happens, for example, when all elements of the array are non-positive. In this scenario, any wrapping subarray sum would be less than or equal to a non-wrapping one, so the wrapping case is not a valid candidate for the maximum. The answer must be the maximum linear subarray sum, $S_{\\text{max\\_linear}}$.\n\nTherefore, the final algorithm is:\n$1$. For an array $A$ of length $n$: if $n = 1$, the answer is $a_0$.\n$2$. Use the D&C procedure to compute $S_{\\text{total}}$ and $S_{\\text{max\\_linear}}$ for array $A$.\n$3$. Use the D&C procedure on the negated array $-A$ to find $S'_{\\text{max\\_linear}}$, and compute $S_{\\text{min\\_linear}} = -S'_{\\text{max\\_linear}}$.\n$4$. If $S_{\\text{min\\_linear}} = S_{\\text{total}}$, the answer is $S_{\\text{max\\_linear}}$.\n$5$. Otherwise, the answer is $\\max(S_{\\text{max\\_linear}}, S_{\\text{total}} - S_{\\text{min\\_linear}})$.\nThis approach correctly computes the maximum circular subarray sum while strictly adhering to the Divide and Conquer paradigm.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates and solves the maximum circular subarray sum problem\n    for a suite of test cases using a Divide and Conquer strategy.\n    \"\"\"\n\n    test_cases = [\n        [5, -3, 5],\n        [-5, -1, -8],\n        [7],\n        [-7],\n        [2, 2, 2],\n        [0, -2, 0, -3],\n        [10, -12, 11, -1, 12],\n        [-2, 1],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_max_circular_subarray_sum(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _dnc_linear_solver(arr: np.ndarray) -> tuple[int, int, int, int]:\n    \"\"\"\n    Computes linear subarray properties using Divide and Conquer.\n\n    Args:\n        arr: A numpy array of integers.\n\n    Returns:\n        A tuple containing:\n        (total_sum, max_subarray_sum, max_prefix_sum, max_suffix_sum)\n    \"\"\"\n    n = arr.shape[0]\n    if n == 1:\n        val = arr[0]\n        return (val, val, val, val)\n\n    mid = n // 2\n    left_arr, right_arr = arr[:mid], arr[mid:]\n\n    left_total, left_max_sub, left_max_pre, left_max_suf = _dnc_linear_solver(left_arr)\n    right_total, right_max_sub, right_max_pre, right_max_suf = _dnc_linear_solver(right_arr)\n\n    # Combine results\n    total_sum = left_total + right_total\n    \n    # Max prefix of combined array is either max prefix of left, or all of left + max prefix of right.\n    max_prefix_sum = max(left_max_pre, left_total + right_max_pre)\n    \n    # Max suffix of combined array is either max suffix of right, or all of right + max suffix of left.\n    max_suffix_sum = max(right_max_suf, right_total + left_max_suf)\n    \n    # Max subarray is in left, in right, or crosses the middle.\n    crossing_sum = left_max_suf + right_max_pre\n    max_subarray_sum = max(left_max_sub, right_max_sub, crossing_sum)\n\n    return (total_sum, max_subarray_sum, max_prefix_sum, max_suffix_sum)\n\ndef find_max_circular_subarray_sum(arr: list[int]) -> int:\n    \"\"\"\n    Calculates the maximum circular subarray sum for a given array.\n\n    Args:\n        arr: A list of integers, with length n >= 1.\n\n    Returns:\n        The maximum circular subarray sum.\n    \"\"\"\n    n = len(arr)\n    # The problem statement guarantees n >= 1. The D base case handles n = 1.\n    \n    arr_np = np.array(arr, dtype=np.int64)\n\n    # Case 1: Find the maximum subarray sum in the linear (non-wrapping) array.\n    total_sum, max_linear_sum, _, _ = _dnc_linear_solver(arr_np)\n\n    # Case 2: Find the maximum wrapping subarray sum.\n    # This is total_sum - min_linear_subarray_sum.\n    # We find min_linear_subarray_sum by finding the max subarray sum of the negated array.\n    # min_sum(A) = -max_sum(-A)\n    neg_arr_np = -arr_np\n    _, max_sum_of_neg_arr, _, _ = _dnc_linear_solver(neg_arr_np)\n    min_linear_sum = -max_sum_of_neg_arr\n\n    # Edge Case: If the minimum linear subarray is the entire array itself\n    # (which happens when all numbers are non-positive), total_sum == min_linear_sum.\n    # In this case, the wrapping sum corresponds to removing the whole array, leaving an\n    # empty set, which is invalid. So, the answer must be the non-wrapping max sum.\n    # This check correctly handles the all-non-positive (and single element) cases.\n    if total_sum == min_linear_sum and n  0:\n        return max_linear_sum\n    else:\n        max_wrapping_sum = total_sum - min_linear_sum\n        return max(max_linear_sum, max_wrapping_sum)\n\nsolve()\n```", "id": "3250540"}, {"introduction": "This final practice [@problem_id:3250524] pushes the divide-and-conquer paradigm into more advanced territory by adding a crucial constraint: finding the maximum subarray sum that is less than or equal to a target value $T$. This modification makes the \"combine\" step significantly more challenging, transforming it from a simple comparison into a sophisticated search problem. Solving it provides deep insight into the flexibility of the DC framework and its application to more constrained optimization problems.", "problem": "You are given an integer array $A = [a_0,a_1,\\dots,a_{n-1}]$ and an integer target $T$. A contiguous subarray is any sequence of consecutive elements $[a_i,a_{i+1},\\dots,a_j]$ for indices $0 \\leq i \\leq j  n$. Define the sum of a subarray $[a_i,\\dots,a_j]$ as $S(i,j) = \\sum_{k=i}^{j} a_k$. The task is to compute, for each test case, the value\n$$M(T; A) = \\max\\{S(i,j) \\mid 0 \\leq i \\leq j  n, \\ S(i,j) \\leq T\\},$$\nthat is, the largest subarray sum that is less than or equal to $T$. If the set is empty (no subarray sum is less than or equal to $T$), define $M(T; A) = -\\infty$ (negative infinity), and the program should return this as a floating-point negative infinity.\n\nYour program must use a principle-based divide and conquer (DC) approach: recursively partition the array into subproblems over halves and combine their results using only information computable from the halves. The program should not accept any input and must compute the results for the following test suite hard-coded within the program:\n\n- Test case $1$: $A = [3,-2,5,-1]$, $T = 6$.\n- Test case $2$: $A = [-4,-2,-7]$, $T = -3$.\n- Test case $3$: $A = [5,6]$, $T = -1$.\n- Test case $4$: $A = [2,-1,2,3,-9,5]$, $T = 100$.\n- Test case $5$: $A = [7]$, $T = 7$.\n- Test case $6$: $A = [4,-1,2,1]$, $T = 5$.\n\nAll values are integers and the sums are computed in integer arithmetic. The final output format must be a single line containing the list of results for the six test cases, in order, as a comma-separated list enclosed in square brackets, for example $[x_1,x_2,\\dots,x_6]$, where each $x_i$ is either an integer or the floating-point representation of negative infinity $-\\infty$.\n\nNo physical units or angles are involved in this problem. The output values are pure numbers, and if $-\\infty$ occurs, it must be printed as the floating-point negative infinity token produced by the programming language (for example, $-\\infty$ is printed as $-inf$ in Python).", "solution": "The problem statement has been analyzed and is deemed valid. It is a well-posed, self-contained, and formalizable problem in the domain of algorithms, specifically concerning the divide-and-conquer paradigm. There are no scientific or factual contradictions, ambiguities, or missing information. We may therefore proceed with a solution.\n\nThe problem asks for the maximum sum of a contiguous subarray, with the constraint that this sum must not exceed a given target value $T$. If no subarray sum satisfies this condition, the result should be $-\\infty$. This is a variation of the classic maximum subarray problem, and the solution must employ a divide-and-conquer strategy.\n\nLet the given array be $A$ of length $n$. A divide-and-conquer algorithm operates by recursively breaking down a problem into two or more subproblems of the same or related type, until these become simple enough to be solved directly. The solutions to the subproblems are then combined to give a solution to the original problem.\n\nFor an array $A$ defined on indices $[l, h]$, we can divide it into two halves at the midpoint $m = \\lfloor(l+h)/2\\rfloor$. The left subarray is $A[l \\dots m]$ and the right subarray is $A[m+1 \\dots h]$. Any contiguous subarray of $A[l \\dots h]$ can be in one of three places:\n$1$. Entirely within the left subarray, $A[l \\dots m]$.\n$2$. Entirely within the right subarray, $A[m+1 \\dots h]$.\n$3$. Crossing the midpoint, i.e., a subarray $A[i \\dots j]$ where $l \\le i \\le m  j \\le h$.\n\nThe core of the divide-and-conquer strategy is as follows:\n\n**Divide:** Split the array $A[l \\dots h]$ into $A[l \\dots m]$ and $A[m+1 \\dots h]$.\n\n**Conquer:** Recursively find the maximum subarray sum less than or equal to $T$ for the left and right subarrays. Let these be $M_{left}$ and $M_{right}$.\n\n**Combine:** The final solution for $A[l \\dots h]$ will be the maximum of three values: $M_{left}$, $M_{right}$, and $M_{cross}$, where $M_{cross}$ is the maximum sum of a crossing subarray that is less than or equal to $T$.\n$$M(T; A[l \\dots h]) = \\max(M_{left}, M_{right}, M_{cross})$$\n\nThe base case for the recursion is a single-element subarray $A[i \\dots i]$. The maximum sum is simply $a_i$ if $a_i \\le T$, and $-\\infty$ otherwise.\n\nThe main challenge lies in an efficient computation of $M_{cross}$. A crossing subarray $A[i \\dots j]$ with $i \\le m  j$ can have its sum expressed as the sum of two parts: the sum of a suffix of the left subarray and the sum of a prefix of the right subarray.\n$$ S(i,j) = \\sum_{k=i}^{j} a_k = \\left(\\sum_{k=i}^{m} a_k\\right) + \\left(\\sum_{k=m+1}^{j} a_k\\right) $$\nLet $\\mathcal{L}$ be the set of all suffix sums of the left subarray, i.e., $\\mathcal{L} = \\{ \\sum_{k=i}^{m} a_k \\mid l \\le i \\le m \\}$.\nLet $\\mathcal{R}$ be the set of all prefix sums of the right subarray, i.e., $\\mathcal{R} = \\{ \\sum_{k=m+1}^{j} a_k \\mid m+1 \\le j \\le h \\}$.\n\nWe need to compute $M_{cross} = \\max \\{ l_{sum} + r_{sum} \\mid l_{sum} \\in \\mathcal{L}, r_{sum} \\in \\mathcal{R}, \\text{ and } l_{sum} + r_{sum} \\le T \\}$. A naive check of all pairs $(l_{sum}, r_{sum})$ would be too slow, resulting in an $O(n^2)$ combine step and an overall complexity of $O(n^2)$.\n\nA more efficient method for the combine step can be devised. For each $l_{sum} \\in \\mathcal{L}$, we need to find the largest $r_{sum} \\in \\mathcal{R}$ such that $r_{sum} \\le T - l_{sum}$. This search can be performed efficiently if the set $\\mathcal{R}$ is sorted.\n\nThe algorithm for the combine step is as follows:\n$1$. Compute all sums in $\\mathcal{L}$ by iterating from index $m$ down to $l$. This takes $O(m-l+1)$ time, which is $O(n)$ for a subarray of size $n$.\n$2$. Compute all sums in $\\mathcal{R}$ by iterating from index $m+1$ up to $h$. This is also $O(n)$.\n$3$. Sort the array of sums $\\mathcal{R}$ in ascending order. This takes $O(n \\log n)$ time.\n$4$. Initialize $M_{cross} = -\\infty$.\n$5$. For each $l_{sum}$ in $\\mathcal{L}$:\n    a. Use binary search on the sorted $\\mathcal{R}$ to find the largest element $r_{sum}$ such that $r_{sum} \\le T - l_{sum}$.\n    b. If such an $r_{sum}$ exists, we have a candidate for the maximum crossing sum: $l_{sum} + r_{sum}$. Update $M_{cross} = \\max(M_{cross}, l_{sum} + r_{sum})$.\nThis loop involves $| \\mathcal{L} |$ binary searches on $\\mathcal{R}$, taking $O(n \\log n)$ time in total.\n\nThe complexity of the combine step is therefore dominated by sorting and searching, resulting in $O(n \\log n)$. The recurrence relation for the overall time complexity is $T(n) = 2T(n/2) + O(n \\log n)$. According to the Master Theorem, this gives a total time complexity of $T(n) = O(n (\\log n)^2)$. This approach adheres to the divide-and-conquer principle mandated by the problem.\n\nThe use of $float('-inf')$ as the identity element for the maximum operation ensures that if no subarray sum satisfies the condition $S(i,j) \\le T$, the function correctly returns $-\\infty$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport bisect\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the problem for a hard-coded suite of test cases.\n    \"\"\"\n    test_cases = [\n        {'A': [3, -2, 5, -1], 'T': 6},\n        {'A': [-4, -2, -7], 'T': -3},\n        {'A': [5, 6], 'T': -1},\n        {'A': [2, -1, 2, 3, -9, 5], 'T': 100},\n        {'A': [7], 'T': 7},\n        {'A': [4, -1, 2, 1], 'T': 5},\n    ]\n\n    results = []\n    for case in test_cases:\n        arr = case['A']\n        target = case['T']\n        result = find_max_subarray_sum_le_T(arr, target)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_max_subarray_sum_le_T(arr, target):\n    \"\"\"\n    Main function to find the maximum subarray sum less than or equal to target T.\n    It initiates the divide-and-conquer recursive solver.\n    \"\"\"\n    if not arr:\n        return float('-inf')\n    return _dnc_solver(arr, target, 0, len(arr) - 1)\n\ndef _dnc_solver(arr, target, low, high):\n    \"\"\"\n    Recursive helper function that implements the divide-and-conquer logic.\n    \"\"\"\n    # Base case: if the subarray is empty or invalid, there are no sums.\n    if low  high:\n        return float('-inf')\n\n    # Base case: if the subarray has one element.\n    if low == high:\n        return arr[low] if arr[low] = target else float('-inf')\n\n    # Divide: Find the midpoint.\n    mid = (low + high) // 2\n\n    # Conquer: Recursively solve for left and right subarrays.\n    max_left = _dnc_solver(arr, target, low, mid)\n    max_right = _dnc_solver(arr, target, mid + 1, high)\n\n    # Combine: Find the maximum sum of a subarray crossing the midpoint.\n    \n    # 1. Compute all suffix sums of the left part (ending at mid).\n    left_sums = []\n    current_sum = 0\n    for i in range(mid, low - 1, -1):\n        current_sum += arr[i]\n        left_sums.append(current_sum)\n\n    # 2. Compute all prefix sums of the right part (starting at mid+1).\n    right_sums = []\n    current_sum = 0\n    for i in range(mid + 1, high + 1):\n        current_sum += arr[i]\n        right_sums.append(current_sum)\n\n    # 3. Sort the right_sums to enable efficient searching.\n    right_sums.sort()\n    \n    max_cross = float('-inf')\n\n    # Also, the individual suffixes and prefixes might be the best answer within the crossing part\n    # that is not captured by the recursive calls (which cover subarrays fully within left/right).\n    # But those are already covered by the recursive calls. Example: A[i..mid] is in the left half,\n    # A[mid+1..j] is in the right half. The `max_cross` part only needs to handle A[i..j] where i=midj.\n    \n    # 4. For each left_sum, find the best matching right_sum.\n    for l_sum in left_sums:\n        if l_sum = target:\n            # Case where only a left part is taken, e.g. a suffix of left-half.\n            # This is already covered by max_left, so this check is redundant but harmless.\n            max_cross = max(max_cross, l_sum)\n        \n        # We need to find the largest r_sum such that r_sum = target - l_sum\n        # In a sorted right_sums, we can use binary search for this.\n        # `bisect_right` finds an insertion point which comes after (to the right of) any\n        # existing entries of `target - l_sum` in `right_sums`.\n        idx = bisect.bisect_right(right_sums, target - l_sum)\n        \n        if idx  0:\n            # The element at idx-1 is the largest element = (target - l_sum)\n            r_sum = right_sums[idx - 1]\n            max_cross = max(max_cross, l_sum + r_sum)\n    \n    # The individual right prefixes must also be considered. `max_right` already covers them.\n    # An explicit check is redundant but harmless.\n    for r_sum in right_sums:\n        if r_sum = target:\n            max_cross = max(max_cross, r_sum)\n\n    return max(max_left, max_right, max_cross)\n\nsolve()\n```", "id": "3250524"}]}