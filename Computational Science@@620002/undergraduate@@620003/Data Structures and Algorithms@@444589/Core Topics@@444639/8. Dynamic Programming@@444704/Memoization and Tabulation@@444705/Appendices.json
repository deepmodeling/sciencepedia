{"hands_on_practices": [{"introduction": "Dynamic programming often begins with a fundamental skill: decomposing a problem into simpler, overlapping subproblems. This exercise provides a clear, hands-on example of this process by asking you to count the number of ways to tile a simple grid. By analyzing the choices for covering the very first column, you will derive a recurrence relation from first principles, illustrating one of the most common starting points in combinatorial dynamic programming. [@problem_id:3251168]", "problem": "You are given a rectangular board of size $2 \\times N$, where $N$ is a positive integer. You have an unlimited supply of tiles of two types: dominoes of size $2 \\times 1$ (which exactly span one full column and may not be rotated) and squares of size $2 \\times 2$. A tiling is a placement of tiles that exactly covers the board without overlaps or gaps.\n\nLet $T(n)$ denote the number of distinct tilings of a $2 \\times n$ board using these tiles. Using only the core definition of dynamic programming (DP), namely that a problem exhibits overlapping subproblems and a decomposable substructure that allows a recurrence derived from a complete case split on the first decision, do the following:\n\n- Derive, from first principles of combinatorial decomposition, a correct recurrence for $T(n)$ together with all necessary base cases.\n- Justify why the resulting recurrence exhibits overlapping subproblems suitable for a tabulation (bottom-up) approach, and specify a tabulation schema that computes $T(n)$ iteratively.\n- State the time and space complexities of your tabulation.\n- Finally, apply your tabulation to compute $T(50)$. Report the exact integer value of $T(50)$. No rounding is required.\n\nYour final submitted answer must be the single integer value of $T(50)$.", "solution": "We begin from the foundational dynamic programming (DP) principle: if counting solutions to a combinatorial object can be decomposed on an initial choice into a finite number of disjoint cases, each of which reduces to counting subproblems from the same family, then a recurrence arises. When such subproblems repeat across different decompositions, the problem exhibits overlapping subproblems and admits a tabulation.\n\nDefine $T(n)$ as the number of tilings of a $2 \\times n$ board using $2 \\times 1$ dominoes (non-rotatable, hence vertical and spanning one full column) and $2 \\times 2$ squares.\n\nRecurrence derivation by first-column decomposition:\n- Consider the leftmost column of a $2 \\times n$ board. Any valid tiling must cover this column entirely. There are exactly two mutually exclusive and collectively exhaustive ways to cover the initial portion including this column:\n  1. Place one $2 \\times 1$ domino in the first column. This consumes exactly the first column and leaves a residual board of size $2 \\times (n-1)$, which can be tiled in $T(n-1)$ ways.\n  2. Place one $2 \\times 2$ square covering columns $1$ and $2$. This consumes the first two columns and leaves a residual board of size $2 \\times (n-2)$, which can be tiled in $T(n-2)$ ways.\n- There are no other possibilities because the $2 \\times 1$ domino cannot be rotated and the $2 \\times 2$ square has a fixed shape.\n\nBy additivity over disjoint cases, this yields the recurrence\n$$\nT(n) \\;=\\; T(n-1) \\;+\\; T(n-2).\n$$\n\nBase cases:\n- The empty board $2 \\times 0$ has exactly one tiling (the empty tiling), so\n$$\nT(0) \\;=\\; 1.\n$$\n- A $2 \\times 1$ board can only be covered by a single $2 \\times 1$ domino, hence\n$$\nT(1) \\;=\\; 1.\n$$\n\nThese base cases are consistent with the recurrence. For example, for $n=2$,\n$$\nT(2) \\;=\\; T(1) + T(0) \\;=\\; 1 + 1 \\;=\\; 2,\n$$\ncorresponding to either two $2 \\times 1$ dominoes in consecutive columns or one $2 \\times 2$ square.\n\nOverlapping subproblems and tabulation schema:\n- The recurrence defines $T(n)$ in terms of $T(n-1)$ and $T(n-2)$. Computing $T(n)$ for many values of $n$ reuses $T(k)$ for the same $k$ multiple times, hence the subproblems overlap.\n- A bottom-up tabulation fills an array from smaller to larger $n$ to avoid recomputation. Define an array $A[0 \\ldots n]$ with:\n  - $A[0] \\leftarrow 1$,\n  - $A[1] \\leftarrow 1$,\n  - For each $i$ from $2$ to $n$, set\n    $$\n    A[i] \\leftarrow A[i-1] + A[i-2].\n    $$\n  The value $A[n]$ equals $T(n)$ by induction on $n$ using the recurrence and base cases.\n\nTime and space complexities:\n- The loop performs a constant amount of work for each $i$ from $2$ to $n$, so the time complexity is $\\mathcal{O}(n)$.\n- The table of size $n+1$ uses $\\mathcal{O}(n)$ space. If only the final value is needed, we can store just the previous two values and achieve $\\mathcal{O}(1)$ space.\n\nClosed-form (optional derivation for validation):\n- The linear homogeneous recurrence with constant coefficients\n$$\nT(n) \\;=\\; T(n-1) + T(n-2), \\quad T(0)=1,\\; T(1)=1\n$$\nhas characteristic equation $r^{2} = r + 1$ with roots\n$$\n\\varphi \\;=\\; \\frac{1+\\sqrt{5}}{2}, \\qquad \\psi \\;=\\; \\frac{1-\\sqrt{5}}{2}.\n$$\nThe general solution is $T(n) = \\alpha \\varphi^{n} + \\beta \\psi^{n}$. Solving for $\\alpha$ and $\\beta$ using the base cases yields\n$$\nT(n) \\;=\\; \\frac{\\varphi^{\\,n+1} - \\psi^{\\,n+1}}{\\sqrt{5}}.\n$$\nThis equals the $(n+1)$-st Fibonacci number under the convention $F(0)=0$, $F(1)=1$.\n\nFinal computation:\n- Applying the tabulation up to $n=50$ (or equivalently using the closed form) yields\n$$\nT(50) \\;=\\; \\frac{\\varphi^{\\,51} - \\psi^{\\,51}}{\\sqrt{5}} \\;=\\; 20365011074.\n$$\nTherefore, the exact integer value is $20365011074$.", "answer": "$$\\boxed{20365011074}$$", "id": "3251168"}, {"introduction": "Building on the concept of recurrence relations, we now move from simple counting to optimization. The classic coin change problem challenges you to find the minimum number of coins to make a specific amount, a common scenario in resource optimization. This practice will guide you through implementing a bottom-up tabulation approach, which is highly efficient for solving this class of problems where you must find the \"best\" way to build a solution. [@problem_id:3251178]", "problem": "You are given a finite multiset of coin denominations represented as a list of positive integers and a target amount represented as a nonnegative integer. The objective is to compute, for each provided test case, the minimal number of coins needed to sum exactly to the target amount using an unlimited supply of each denomination, or to determine that no exact sum is possible. The final algorithm must be designed using a bottom-up tabulation approach and must use only $\\mathcal{O}(C)$ additional space, where $C$ denotes the target amount in the test case. Your program must not rely on any interactive input and must run deterministically on the predefined test suite.\n\nFundamental base for derivation:\n- Optimal substructure: Any optimal solution to the target amount can be decomposed into an optimal solution to a smaller sub-amount and one additional coin.\n- Overlapping subproblems: The minimal coin counts for sub-amounts recur across different decomposition paths.\n\nDefinitions and constraints:\n- Let the coins be a list of positive integers $\\{d_1, d_2, \\ldots, d_n\\}$ with $n \\in \\mathbb{N}$.\n- Let the target amount be $C \\in \\mathbb{N}_0$.\n- The output for each test case must be an integer: the minimal number of coins, or $-1$ if no exact sum equals $C$.\n- The tabulation must compute values for all intermediate amounts from $0$ up to $C$ using only an array of length $C+1$ or asymptotically equivalent space.\n\nTest suite:\n- Case $1$: Coins $[1, 2, 5]$, Target $11$.\n- Case $2$: Coins $[2, 4]$, Target $7$.\n- Case $3$: Coins $[3, 7, 10]$, Target $14$.\n- Case $4$: Coins $[9, 6, 5, 1]$, Target $11$.\n- Case $5$: Coins $[5, 7]$, Target $5$.\n- Case $6$: Coins $[7, 9]$, Target $0$.\n\nRequired output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\text{[result1,result2,result3]}$), where each $\\text{result}$ is the integer answer corresponding to the minimal number of coins for the respective test case (or $-1$ if impossible).", "solution": "The Coin Change problem is a classic optimization problem perfectly suited for a bottom-up dynamic programming approach. The goal is to find the minimum number of coins to make a target amount $C$, which is built upon finding the optimal solutions for all smaller amounts from $0$ to $C-1$.\n\n### Algorithm Design (Tabulation)\n\nLet `dp[i]` be the minimum number of coins required to make an amount `i`. Our goal is to compute `dp[C]`.\n\n1.  **Initialization**: Create a table (an array) `dp` of size `C+1`.\n    *   The base case is `dp[0] = 0`, as it takes zero coins to make an amount of 0.\n    *   Initialize all other entries `dp[i]` for $i > 0$ to a value representing infinity (e.g., `C+1`), signifying that we have not yet found a way to make that amount.\n\n2.  **Iteration**: We build the solution iteratively. For each amount `i` from 1 to `C`, we try to form it by using each available coin denomination `d`.\n    *   For each amount `i` from $1$ to $C$:\n        *   For each coin `d` in our set of denominations:\n            *   If we can use this coin (i.e., `i >= d`), a possible solution is to take one coin `d` and add it to the optimal solution for the remaining amount, `i - d`. The total number of coins for this choice would be `1 + dp[i - d]`.\n            *   We update `dp[i]` to be the minimum of its current value and this new possibility: `dp[i] = min(dp[i], 1 + dp[i - d])`.\n\n3.  **Result**: After the loops complete, `dp[C]` will hold the minimum number of coins. If `dp[C]` is still our \"infinity\" value, it means the target amount $C$ cannot be formed, and the answer is $-1$.\n\nThis algorithm runs in $\\mathcal{O}(n \\cdot C)$ time, where $n$ is the number of coin denominations, and uses $\\mathcal{O}(C)$ space for the `dp` table, satisfying the problem's constraints.\n\n### Test Case Execution\n\nLet's trace **Case 1**: Coins `[1, 2, 5]`, Target `11`.\n- `dp` array of size 12, initialized with `dp[0] = 0` and others to `12` (infinity).\n- `dp[1] = 1 + dp[0] = 1` (using coin 1)\n- `dp[2] = min(1 + dp[1], 1 + dp[0]) = 1` (using coin 2)\n- `dp[3] = min(1 + dp[2], 1 + dp[1]) = 2`\n- ...\n- `dp[5] = min(1 + dp[4], 1 + dp[3], 1 + dp[0]) = 1` (using coin 5)\n- ...and so on, until `dp[11]` is calculated. For `dp[11]`, the algorithm will find that the minimum is achieved by `1 + dp[6]` (using coin 5, where `dp[6]` is 2) or `1 + dp[10]` (using coin 1, where `dp[10]` is 2), yielding 3. So `dp[11]=3`.\n\nApplying this logic to all test cases yields the following results:\n- **Case 1** (Coins `[1, 2, 5]`, Target `11`): `3` (e.g., 5+5+1)\n- **Case 2** (Coins `[2, 4]`, Target `7`): `-1` (impossible to make an odd sum with even coins)\n- **Case 3** (Coins `[3, 7, 10]`, Target `14`): `2` (7+7)\n- **Case 4** (Coins `[9, 6, 5, 1]`, Target `11`): `2` (6+5)\n- **Case 5** (Coins `[5, 7]`, Target `5`): `1` (5)\n- **Case 6** (Coins `[7, 9]`, Target `0`): `0` (base case)\n\nThe final, correctly formatted output is `[3,-1,2,2,1,0]`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Coin Change problem for a predefined test suite using\n    bottom-up dynamic programming (tabulation).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        ([1, 2, 5], 11),\n        # Case 2\n        ([2, 4], 7),\n        # Case 3\n        ([3, 7, 10], 14),\n        # Case 4\n        ([9, 6, 5, 1], 11),\n        # Case 5\n        ([5, 7], 5),\n        # Case 6\n        ([7, 9], 0),\n    ]\n\n    results = []\n    for coins, target in test_cases:\n        # Base case: target amount is 0, requires 0 coins.\n        if target == 0:\n            results.append(0)\n            continue\n\n        # Let infinity be a value greater than any possible number of coins.\n        # target + 1 is a safe choice.\n        infinity = target + 1\n        \n        # Create a DP table of size target + 1 to store the minimum coins\n        # for each amount from 0 to target.\n        # dp[i] will be the minimum coins for amount i.\n        dp = np.full(target + 1, infinity, dtype=int)\n\n        # Base case: 0 coins are needed to make an amount of 0.\n        dp[0] = 0\n\n        # Build the table from the bottom up.\n        # Iterate through all amounts from 1 to target.\n        for amount in range(1, target + 1):\n            # For each amount, try each coin denomination.\n            for coin in coins:\n                # If the current coin can be used to form the amount:\n                if amount >= coin:\n                    # Update the dp table with the minimum number of coins.\n                    # The number of coins is 1 (the current coin) + the number\n                    # of coins for the remaining amount (amount - coin).\n                    dp[amount] = min(dp[amount], 1 + dp[amount - coin])\n\n        # The final result is in dp[target].\n        final_count = dp[target]\n\n        # If dp[target] is still infinity, the amount cannot be made.\n        if final_count == infinity:\n            results.append(-1)\n        else:\n            results.append(int(final_count))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3251178"}, {"introduction": "True mastery of dynamic programming involves not just finding a correct solution, but an efficient one. This advanced practice tackles the Longest Palindromic Subsequence problem with a crucial constraint: optimizing space complexity from the straightforward $O(N^2)$ to a more memory-efficient $O(N)$. By carefully analyzing the data dependencies in the tabulation process, you will learn a powerful technique applicable to many sequence alignment and string problems where memory is a critical resource. [@problem_id:3251302]", "problem": "Implement a bottom-up dynamic programming (tabulation) algorithm to compute the length of the Longest Palindromic Subsequence (LPS) of a given string using only $O(N)$ auxiliary space, where $N$ is the length of the input string. A subsequence of a string is defined as a sequence that can be derived from the string by deleting zero or more characters without changing the order of the remaining characters. A palindrome is a sequence that reads the same forwards and backwards. Your solution must be iterative (no recursion), must leverage overlapping subproblems and optimal substructure, and must strictly use $O(N)$ additional memory beyond the input and output.\n\nStart from first principles appropriate for dynamic programming:\n- Formal definitions of subsequence and palindrome,\n- The principle of optimality (Bellman’s principle) for subproblem decomposition,\n- Recognition of overlapping subproblems,\nand derive a correct tabulation strategy that achieves the stated space bound. You must not construct an $O(N^2)$ table in memory, and you must not store the set of decisions for reconstruction; only the LPS length is required.\n\nYour program should compute, for each test string, the integer length of its Longest Palindromic Subsequence. For the empty string, define the LPS length to be $0$.\n\nInput is not provided at runtime. Instead, embed the following test suite directly in your program, in this exact order:\n- $\"\"$,\n- $\"a\"$,\n- $\"abcde\"$,\n- $\"aaaaa\"$,\n- $\"bbbab\"$,\n- $\"cbbd\"$,\n- $\"character\"$,\n- $\"agbdba\"$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite. For example, the required formatting is $[3,0,2]$ for three results $3$, $0$, and $2$.\n\nDesign goals and constraints:\n- Your derivation must rely only on the foundational definitions and the dynamic programming paradigm (principle of optimality and overlapping subproblems).\n- The algorithm must run in $O(N^2)$ time and use $O(N)$ auxiliary space.\n- The answer type for each test case is an integer.", "solution": "The Longest Palindromic Subsequence (LPS) problem can be solved with a standard $O(N^2)$ time and space dynamic programming approach. However, by analyzing the data dependencies, we can optimize the space complexity to $O(N)$, as required by the problem.\n\n### Derivation from First Principles\n\nLet $S$ be the input string of length $N$. Let $L(i, j)$ denote the length of the LPS of the substring $S[i \\dots j]$.\n- **Optimal Substructure**: The LPS of $S[i \\dots j]$ depends on the characters $S[i]$ and $S[j]$.\n  - If $S[i] == S[j]$, then $L(i, j) = 2 + L(i+1, j-1)$. The two matching characters extend the LPS of the inner substring.\n  - If $S[i] \\neq S[j]$, then the LPS cannot use both endpoints. It must be the LPS of either $S[i+1 \\dots j]$ or $S[i \\dots j-1]$. Thus, $L(i, j) = \\max(L(i+1, j), L(i, j-1))$.\n- **Base Cases**: $L(i, i) = 1$ (a single character is a palindrome of length 1). $L(i, j) = 0$ if $i > j$.\n\n### Space Optimization to $O(N)$\n\nA standard tabulation would use a 2D table `dp[i][j]` to store $L(i, j)$, iterating on substring length. Notice that to compute any value in row `i` of this table, we only need values from row `i` (specifically, `dp[i][j-1]`) and row `i+1` (specifically, `dp[i+1][j]` and `dp[i+1][j-1]`). We never need rows older than `i+1`.\n\nThis dependency allows us to use only two rows of the table at any time. We can optimize this further to use a single 1D array `dp` of size $N$. The algorithm iterates `i` from $N-1$ down to $0$. At the start of each iteration `i`, the `dp` array contains the values for row `i+1` from the conceptual 2D table. We then update `dp` in place to hold the values for row `i`.\n\nThe challenge is that when computing `dp[j]` (representing $L(i, j)$), we need values that are being overwritten.\n- `L(i, j-1)` is the new `dp[j-1]`, which is available.\n- `L(i+1, j)` is the old `dp[j]`, which we are about to overwrite.\n- `L(i+1, j-1)` is the old `dp[j-1]`, which was overwritten in the previous step of the inner loop.\n\nTo solve this, as we iterate `j` from $i+1$ to $N-1$, we must save the necessary \"old\" values before they are overwritten. Specifically, to compute $L(i,j)$, we need $L(i+1, j-1)$. This value was available at step `j-1` as the \"old\" `dp[j-1]`. We can carry this value forward in a temporary variable.\n\n**The $O(N)$ Space Algorithm:**\n\n1.  Initialize a 1D array `dp` of size $N$.\n2.  Iterate `i` from $N-1$ down to $0$.\n3.  For each `i`:\n    a. Set `dp[i] = 1`. This is the base case $L(i, i)$.\n    b. Initialize `prev_val = 0`. This will track the value of $L(i+1, j-1)$ for the current `j`.\n    c. Iterate `j` from $i+1$ to $N-1$:\n        i. Store `dp[j]` in a `temp` variable. This `temp` value is $L(i+1, j)$.\n        ii. If `s[i] == s[j]`, the new value for `dp[j]` is $2 + L(i+1, j-1)$. This is `2 + prev_val`.\n        iii. If `s[i] != s[j]`, the new value for `dp[j]` is $\\max(L(i+1, j), L(i, j-1))$. This is `max(temp, dp[j-1])`. Note that `dp[j-1]` already holds the new value for the current row `i`.\n        iv. Update `prev_val = temp` so it's ready for the next inner loop step, `j+1`.\n\nAfter the loops complete, `dp[N-1]` will hold the final answer, $L(0, N-1)$.\n\n### Test Case Results\n\nApplying this algorithm to the test suite yields:\n- `\"\"`: $0$\n- `\"a\"`: $1$\n- `\"abcde\"`: $1$ (any single character)\n- `\"aaaaa\"`: $5$ (the whole string)\n- `\"bbbab\"`: $4$ (the subsequence \"bbbb\")\n- `\"cbbd\"`: $2$ (the subsequence \"bb\")\n- `\"character\"`: $3$ (e.g., \"crc\", \"cac\", or \"rar\" are valid subsequences)\n- `\"agbdba\"`: $5$ (the subsequence \"abdba\")\n\nThe final, correctly formatted output is `[0,1,1,5,4,2,3,5]`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the length of the Longest Palindromic Subsequence for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        \"\",\n        \"a\",\n        \"abcde\",\n        \"aaaaa\",\n        \"bbbab\",\n        \"cbbd\",\n        \"character\",\n        \"agbdba\",\n    ]\n\n    results = []\n    for s in test_cases:\n        results.append(lps_length_optimized(s))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef lps_length_optimized(s: str) -> int:\n    \"\"\"\n    Computes the length of the Longest Palindromic Subsequence using bottom-up\n    dynamic programming with O(N) auxiliary space.\n\n    The derivation is based on the recurrence relation for L(i, j), the length of the\n    LPS in the substring s[i..j].\n\n    L(i, j) = 1,                                   if i = j\n              2 + L(i+1, j-1),                      if s[i] == s[j]\n              max(L(i+1, j), L(i, j-1)),            if s[i] != s[j]\n\n    This function implements the space-optimized tabulation where a single 1D array `dp`\n    is used to store the results of the previous row's computations while calculating\n    the current row's values.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The integer length of the LPS.\n    \"\"\"\n    n = len(s)\n    if n = 1:\n        return n\n\n    # dp array of size N will store the results.\n    # At the start of the outer loop `i`, dp stores the LPS lengths for substrings starting at `i+1`.\n    # It is then updated in-place to store results for substrings starting at `i`.\n    dp = np.zeros(n, dtype=int)\n\n    # Outer loop iterates backwards from the end of the string.\n    for i in range(n - 1, -1, -1):\n        # Base case: LPS of a single character string s[i..i] is 1.\n        dp[i] = 1\n        \n        # prev_val holds the value from the \"top-left\" diagonal in the conceptual 2D DP table.\n        # For a given (i, j), it stores L(i+1, j-1).\n        prev_val = 0\n        \n        # Inner loop computes LPS for substrings s[i..j] of increasing length.\n        for j in range(i + 1, n):\n            # Store dp[j] which is L(i+1, j) before it's overwritten.\n            # This is needed for the L(i+1, j) part of the max() and to update prev_val.\n            temp = dp[j]\n            \n            if s[i] == s[j]:\n                # If characters match, the length is 2 + length of the inner palindrome.\n                # The inner palindrome corresponds to s[i+1..j-1], and its LPS length\n                # is stored in prev_val from the previous j-step.\n                dp[j] = prev_val + 2\n            else:\n                # If characters do not match, we take the maximum of excluding s[i] or s[j].\n                # L(i+1, j) is `temp`.\n                # L(i, j-1) is the newly computed `dp[j-1]`.\n                dp[j] = max(temp, dp[j-1])\n            \n            # Update prev_val for the next iteration of j.\n            # At j+1, we will need L(i+1, j), which is the `temp` from this iteration.\n            prev_val = temp\n            \n    # The final result for the whole string s[0..n-1] is in dp[n-1].\n    return dp[n-1]\n\nsolve()\n```", "id": "3251302"}]}