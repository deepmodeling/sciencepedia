{"hands_on_practices": [{"introduction": "Moving beyond simple cost calculation, this first exercise encourages you to think in reverse. Given the optimal cost and parenthesization for a matrix chain, you are tasked with deducing the properties of the original matrices. This practice reinforces a deep understanding of the cost formula and the logical implications of optimality, moving from \"how\" to \"why\" a particular solution is the best one [@problem_id:3249096].", "problem": "You are given a chain of three matrices $A_1$, $A_2$, and $A_3$ with compatible dimensions $A_1 \\in \\mathbb{R}^{d_0 \\times d_1}$, $A_2 \\in \\mathbb{R}^{d_1 \\times d_2}$, and $A_3 \\in \\mathbb{R}^{d_2 \\times d_3}$, where $d_0$, $d_1$, $d_2$, and $d_3$ are unknown positive integers. Suppose it is known (for example, from a complete dynamic programming computation) that the optimal parenthesization of the chain is $(A_1A_2)A_3$, and that the exact minimal number of scalar multiplications for this optimal evaluation is $C^{\\ast} = 204$. In addition, you are told that forming the subproducts $A_1A_2$ and $A_2A_3$ in isolation would require $120$ and $210$ scalar multiplications, respectively.\n\nStarting only from the standard definition of matrix multiplication and its scalar operation count, derive the equalities and inequalities that the dimensions $d_0$, $d_1$, $d_2$, and $d_3$ must satisfy given the optimality of $(A_1A_2)A_3$. Then, compute the value of the ratio $d_1/d_0$. Express your final answer as a reduced fraction. No rounding is required, and no units are involved.", "solution": "The problem requires the determination of the ratio of two matrix dimensions, $d_1/d_0$, based on cost information from a matrix chain multiplication problem.\n\nFirst, we formalize the given information using the standard definition of the cost of matrix multiplication. The multiplication of a matrix of dimensions $p \\times q$ by a matrix of dimensions $q \\times r$ requires $p \\times q \\times r$ scalar multiplications.\n\nThe matrices in the chain are $A_1 \\in \\mathbb{R}^{d_0 \\times d_1}$, $A_2 \\in \\mathbb{R}^{d_1 \\times d_2}$, and $A_3 \\in \\mathbb{R}^{d_2 \\times d_3}$, where $d_0, d_1, d_2, d_3$ are positive integers.\n\nWe are given the cost of forming two subproducts in isolation:\n1.  The cost of computing $A_1A_2$ is $120$. The dimensions are $d_0 \\times d_1$ and $d_1 \\times d_2$. Thus, the number of scalar multiplications is given by the product of the dimensions:\n    $$d_0 d_1 d_2 = 120$$\n2.  The cost of computing $A_2A_3$ is $210$. The dimensions are $d_1 \\times d_2$ and $d_2 \\times d_3$. The associated cost is:\n    $$d_1 d_2 d_3 = 210$$\n\nFor a chain of three matrices, there are two possible parenthesizations for the full product $A_1A_2A_3$:\n-   $P_1: (A_1A_2)A_3$\n-   $P_2: A_1(A_2A_3)$\n\nLet's compute the total cost for each parenthesization.\nThe cost for $P_1$ is the cost of computing the intermediate product $A_{12} = A_1A_2$, plus the cost of multiplying $A_{12}$ by $A_3$. The matrix $A_{12}$ has dimensions $d_0 \\times d_2$.\nThe cost of computing $A_{12}$ is given as $d_0 d_1 d_2 = 120$.\nThe cost of multiplying $A_{12}$ (size $d_0 \\times d_2$) by $A_3$ (size $d_2 \\times d_3$) is $d_0 d_2 d_3$.\nSo, the total cost for $P_1$ is $C_1 = d_0 d_1 d_2 + d_0 d_2 d_3$.\n\nThe cost for $P_2$ is the cost of computing the intermediate product $A_{23} = A_2A_3$, plus the cost of multiplying $A_1$ by $A_{23}$. The matrix $A_{23}$ has dimensions $d_1 \\times d_3$.\nThe cost of computing $A_{23}$ is given as $d_1 d_2 d_3 = 210$.\nThe cost of multiplying $A_1$ (size $d_0 \\times d_1$) by $A_{23}$ (size $d_1 \\times d_3$) is $d_0 d_1 d_3$.\nSo, the total cost for $P_2$ is $C_2 = d_1 d_2 d_3 + d_0 d_1 d_3$.\n\nThe problem states that $(A_1A_2)A_3$ is the optimal parenthesization, and the minimal number of multiplications is $C^{\\ast} = 204$. This implies two conditions:\n1.  The cost of the optimal path is $C_1 = C^{\\ast} = 204$.\n2.  The cost of the optimal path is less than or equal to the cost of any other path, i.e., $C_1 \\le C_2$.\n\nUsing the first condition, we have:\n$$C_1 = d_0 d_1 d_2 + d_0 d_2 d_3 = 204$$\nWe already know that $d_0 d_1 d_2 = 120$. Substituting this value into the equation for $C_1$:\n$$120 + d_0 d_2 d_3 = 204$$\nSolving for the term $d_0 d_2 d_3$:\n$$d_0 d_2 d_3 = 204 - 120 = 84$$\n\nNow we have a system of three equations relating the products of the dimensions:\n(i) $d_0 d_1 d_2 = 120$\n(ii) $d_1 d_2 d_3 = 210$\n(iii) $d_0 d_2 d_3 = 84$\n\nThe problem asks for the value of the ratio $d_1/d_0$. We can obtain this ratio by dividing equation (ii) by equation (iii). Since all dimensions $d_i$ are positive integers, the products $d_1 d_2 d_3$ and $d_0 d_2 d_3$ are non-zero, making division a valid operation.\n$$\\frac{d_1 d_2 d_3}{d_0 d_2 d_3} = \\frac{210}{84}$$\nThe terms $d_2$ and $d_3$ cancel from the numerator and the denominator:\n$$\\frac{d_1}{d_0} = \\frac{210}{84}$$\nTo simplify the fraction, we can find the greatest common divisor of $210$ and $84$.\n$210 = 2 \\times 3 \\times 5 \\times 7$\n$84 = 2^2 \\times 3 \\times 7$\nThe greatest common divisor is $2 \\times 3 \\times 7 = 42$.\nAlternatively, we recognize $210 = 21 \\times 10$ and $84 = 21 \\times 4$.\n$$\\frac{d_1}{d_0} = \\frac{21 \\times 10}{21 \\times 4} = \\frac{10}{4} = \\frac{5}{2}$$\n\nAs a consistency check, we can verify the optimality condition $C_1 \\le C_2$.\n$$d_0 d_1 d_2 + d_0 d_2 d_3 \\le d_1 d_2 d_3 + d_0 d_1 d_3$$\nSubstituting the known values:\n$$120 + 84 \\le 210 + d_0 d_1 d_3$$\n$$204 \\le 210 + d_0 d_1 d_3$$\nSince $d_0, d_1, d_3$ are positive integers, their product $d_0 d_1 d_3$ is a positive integer. The inequality is satisfied, as $204$ is less than $210$ plus a positive value. This confirms that the problem data is internally consistent. The derivation of the ratio $d_1/d_0$ is thereby confirmed to be sound.\nThe final answer is the reduced fraction for this ratio.", "answer": "$$\\boxed{\\frac{5}{2}}$$", "id": "3249096"}, {"introduction": "The dynamic programming framework for matrix chain multiplication is a powerful and flexible tool. This exercise demonstrates its versatility by flipping the objective: instead of finding the minimum number of multiplications, you will adapt the algorithm to find the parenthesization that results in the maximum cost. This practice highlights how the same core principles of optimal substructure and overlapping subproblems can be applied to different optimization goals by simply changing the core recurrence relation [@problem_id:3249152].", "problem": "Consider a sequence of matrix dimensions represented by an array $p = [p_0, p_1, \\dots, p_n]$ where matrix $A_i$ has dimensions $p_i \\times p_{i+1}$ for $i \\in \\{0, 1, \\dots, n-1\\}$. The binary operation of matrix multiplication is associative, so the final product $A_0 A_1 \\cdots A_{n-1}$ is well-defined, but the total number of scalar multiplications depends on how the product is parenthesized. The fundamental base for this problem is the well-tested fact that multiplying an $a \\times b$ matrix by a $b \\times c$ matrix costs $a \\cdot b \\cdot c$ scalar multiplications, and that matrix multiplication is associative. Using these facts, derive a method that, for a given dimension array $p$, determines the parenthesization that maximizes the total number of scalar multiplications required to compute the product $A_0 A_1 \\cdots A_{n-1}$, and output the maximum number of scalar multiplications required under such an optimal parenthesization. You must not assume any special structure of $p$ beyond positive integer entries. You must reason from first principles starting with the stated facts, and design an algorithmic solution that follows logically from these principles without shortcut formulas.\n\nYour program must implement this logic and compute the maximum number of scalar multiplications for the following test suite of dimension arrays:\nCase $1$: $p = [7, 13]$.\nCase $2$: $p = [40, 20, 30]$.\nCase $3$: $p = [5, 10, 3, 12]$.\nCase $4$: $p = [10, 10, 10, 10, 10]$.\nCase $5$: $p = [2, 100, 2, 100, 2]$.\nCase $6$: $p = [6, 12, 8, 10, 20, 5]$.\n\nFor each case, the output must be a single integer equal to the maximum number of scalar multiplications among all valid parenthesizations for the chain defined by $p$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,\\dots,r_6]$), where $r_i$ corresponds to Case $i$. No physical units, angle units, or percentage formats are involved in this problem; answers are plain integers.\n\nEnsure your algorithm is general and correct for any valid input $p$ satisfying $n \\ge 0$ and $p_i \\in \\mathbb{N}$ for all $i$, and specifically returns $0$ when $n = 1$ (a single matrix requires $0$ scalar multiplications to \"multiply\"). The test suite is constructed to cover a variety of scenarios: a boundary case with a single matrix, a trivial multiplication with two matrices, a small chain where parenthesization changes the cost, a uniform-dimension chain creating ties among parenthesizations, a chain with alternating large and small dimensions to emphasize parenthesization effects, and a larger chain testing general behavior.", "solution": "The fundamental base consists of two well-tested facts: matrix multiplication is associative, and multiplying an $a \\times b$ matrix with a $b \\times c$ matrix costs $a \\cdot b \\cdot c$ scalar multiplications. These facts imply that while the final product of a matrix chain is independent of parenthesization, the total number of scalar multiplications depends on the order in which the multiplications are performed. To design an algorithm that maximizes the total number of scalar multiplications, we use principle-based reasoning to derive a recurrence exploiting optimal substructure and overlapping subproblems, which motivates Dynamic Programming (DP).\n\nLet the chain be $A_0, A_1, \\dots, A_{n-1}$ where $A_i$ has dimensions $p_i \\times p_{i+1}$; thus the dimension array is $p = [p_0, p_1, \\dots, p_n]$. Consider any parenthesization for the subchain $A_i \\cdots A_j$ where $0 \\le i \\le j \\le n-1$. In any valid parenthesization of this subchain, there exists an index $k$ with $i \\le k  j$ at which the last multiplication combines the two subproducts $(A_i \\cdots A_k)$ and $(A_{k+1} \\cdots A_j)$. The cost contributed by this last multiplication is $p_i \\cdot p_{k+1} \\cdot p_{j+1}$ because $(A_i \\cdots A_k)$ has dimensions $p_i \\times p_{k+1}$ and $(A_{k+1} \\cdots A_j)$ has dimensions $p_{k+1} \\times p_{j+1}$. The total cost of the entire parenthesization is the sum of the costs of the left subchain, the right subchain, and the final multiplication.\n\nTo maximize the total number of scalar multiplications, define the DP table $M[i][j]$ to be the maximum number of scalar multiplications required to compute $A_i \\cdots A_j$. The base case is $M[i][i] = 0$ for all $i$, since a single matrix does not require any multiplication. For $i  j$, the recurrence relation derived from the fundamental cost decomposition is\n$$\nM[i][j] = \\max_{i \\le k  j} \\big( M[i][k] + M[k+1][j] + p_i \\cdot p_{k+1} \\cdot p_{j+1} \\big).\n$$\nThis recurrence follows directly from the associative structure of matrix multiplication and the additive cost of combining subchains. The optimal substructure property holds: if a parenthesization of $A_i \\cdots A_j$ achieves the maximum total cost and splits at some $k$, then the parenthesizations of $A_i \\cdots A_k$ and $A_{k+1} \\cdots A_j$ must themselves be maximum for those subproblems, otherwise replacing them with higher-cost parenthesizations would strictly increase the total, contradicting maximality. Overlapping subproblems occur because the same subchains appear across different splits.\n\nThe DP algorithm computes $M[i][j]$ for increasing chain lengths. Specifically, we iterate over subchain lengths $\\ell$ from $2$ to $n$, and for each pair $(i,j)$ with $j = i + \\ell - 1$ we compute $M[i][j]$ using the above recurrence. The algorithm runs in time $O(n^3)$ due to the three nested loops over $\\ell$, $i$, and $k$, and uses space $O(n^2)$ for the table $M$.\n\nEdge cases are handled naturally. When $n = 1$ (i.e., $|p| = 2$), there is only one matrix and the cost is $0$. When $n = 2$ (i.e., $|p| = 3$), there is only one multiplication and the cost is $p_0 \\cdot p_1 \\cdot p_2$. For uniform dimensions such as $p = [10, 10, 10, 10, 10]$, each multiplication cost $p_i \\cdot p_{k+1} \\cdot p_{j+1}$ equals $10 \\cdot 10 \\cdot 10 = 1000$, and the total cost is the same for all parenthesizations, equal to $1000 \\cdot (n-1)$ where $n$ is the number of matrices, which for $n = 4$ yields $3000$.\n\nAs an illustrative derivation for Case $3$ with $p = [5, 10, 3, 12]$ ($n = 3$ matrices):\n- Parenthesization $(A_0 A_1) A_2$ yields cost $$5 \\cdot 10 \\cdot 3 + 5 \\cdot 3 \\cdot 12 = 150 + 180 = 330.$$\n- Parenthesization $A_0 (A_1 A_2)$ yields cost $$10 \\cdot 3 \\cdot 12 + 5 \\cdot 10 \\cdot 12 = 360 + 600 = 960.$$\nThus the maximum is $960$, consistent with the DP formulation. For Case $5$ with $p = [2, 100, 2, 100, 2]$ ($n = 4$ matrices), the DP will select a split that forces multiplications on large intermediate dimensions, giving a maximum total of $40400$ via either $A_0 (A_1 A_2) A_3$ or $A_0 ((A_1 A_2) A_3)$ parenthesizations, both of which perform two costly multiplications with $100 \\times 100$ intermediates.\n\nThe final program implements this DP maximization and produces a single line with the integer results for the specified test suite, formatted as a comma-separated list in square brackets.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef max_mcm_cost(dimensions):\n    \"\"\"\n    Compute the maximum number of scalar multiplications needed to multiply\n    a chain of matrices with dimension array 'dimensions' using dynamic programming.\n    Each matrix A_i has dimensions dimensions[i] x dimensions[i+1].\n\n    Parameters:\n        dimensions (list[int]): The dimension array p of length n+1.\n\n    Returns:\n        int: The maximum number of scalar multiplications among all parenthesizations.\n    \"\"\"\n    # Number of matrices in the chain\n    n = len(dimensions) - 1\n    # If there is 0 or 1 matrix, cost is 0\n    if n = 1:\n        return 0\n\n    # dp[i][j] will store the maximum cost to compute Ai..Aj (0-based indices for matrices)\n    dp = [[0] * n for _ in range(n)]\n\n    # Consider chain lengths from 2 to n\n    for chain_len in range(2, n + 1):\n        for i in range(0, n - chain_len + 1):\n            j = i + chain_len - 1\n            max_cost = -1\n            # Try all possible splits k between i and j-1\n            for k in range(i, j):\n                cost_left = dp[i][k]\n                cost_right = dp[k + 1][j]\n                # Cost of multiplying the two resulting matrices:\n                # dims: (dimensions[i] x dimensions[k+1]) * (dimensions[k+1] x dimensions[j+1])\n                mult_cost = dimensions[i] * dimensions[k + 1] * dimensions[j + 1]\n                total_cost = cost_left + cost_right + mult_cost\n                if total_cost  max_cost:\n                    max_cost = total_cost\n            dp[i][j] = max_cost\n\n    return dp[0][n - 1]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [7, 13],                  # Case 1: single matrix - 0\n        [40, 20, 30],             # Case 2: two matrices - 40*20*30\n        [5, 10, 3, 12],           # Case 3: 3 matrices, nontrivial\n        [10, 10, 10, 10, 10],     # Case 4: uniform dimensions\n        [2, 100, 2, 100, 2],      # Case 5: alternating large/small dimensions\n        [6, 12, 8, 10, 20, 5],    # Case 6: larger chain\n    ]\n\n    results = []\n    for dims in test_cases:\n        result = max_mcm_cost(dims)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3249152"}, {"introduction": "Real-world problems often involve resource constraints. This final practice places the matrix chain multiplication algorithm into a more practical context by introducing a computational budget. Your task is to find the longest chain of matrices from the start of a sequence that can be multiplied without exceeding a given budget, requiring you to use the core algorithm as a subroutine within a larger search strategy [@problem_id:3249062].", "problem": "You are given a chain of matrices $A_1, A_2, \\dots, A_n$ such that for each index $i$ with $1 \\le i \\le n$, the matrix $A_i$ has dimensions $p_{i-1} \\times p_i$, where the sequence of positive integers $p_0, p_1, \\dots, p_n$ encodes the conformable dimensions of the chain. The cost of multiplying two conformable matrices with dimensions $a \\times b$ and $b \\times c$ is defined to be $a \\cdot b \\cdot c$ scalar multiplications. The associative law of matrix multiplication guarantees that any full parenthesization of $A_1 A_2 \\cdots A_k$ yields the same final dimensions, but not necessarily the same cost.\n\nStarting from the foundational definition that multiplying two matrices with dimensions $a \\times b$ and $b \\times c$ incurs $a \\cdot b \\cdot c$ scalar multiplications, and that a full parenthesization is a sequence of binary matrix multiplications reducing the chain to a single matrix, determine, for a given budget $B$ (the maximum permitted number of scalar multiplications), the largest prefix length $k$ with $1 \\le k \\le n$ such that the minimal possible number of scalar multiplications required to compute $A_1 A_2 \\cdots A_k$ does not exceed $B$. If $k = 1$, the cost is $0$ because no multiplication is performed.\n\nYour task is to implement a complete program that, for each supplied test case, computes this largest feasible prefix length $k$ under an optimal parenthesization of the prefix $A_1 A_2 \\cdots A_k$, subject to the budget $B$.\n\nYour program must use the following test suite. Each test case is specified by a dimension sequence $\\langle p_0, p_1, \\dots, p_n \\rangle$ and a budget $B$.\n\n- Test case $1$: $\\langle 10, 30, 5, 60 \\rangle$, $B = 2000$.\n- Test case $2$: $\\langle 2, 3, 4 \\rangle$, $B = 0$.\n- Test case $3$: $\\langle 2, 3, 4 \\rangle$, $B = 24$.\n- Test case $4$: $\\langle 5, 10, 3, 12, 5, 50, 6 \\rangle$, $B = 1000000000$.\n- Test case $5$: $\\langle 7, 9, 3, 4, 8 \\rangle$, $B = 452$.\n\nFor each test case, the output must be the single integer $k$ satisfying the budget constraint as defined above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[k_1,k_2,k_3,k_4,k_5]$), in the order of the test cases listed.\n\nThere are no physical units or angles in this problem. All outputs are integers. Ensure that your implementation is general and based solely on the foundational definition of scalar multiplication cost for matrix products and the associative structure of matrix multiplication. The program must be self-contained and must not read input from any external source.", "solution": "The problem asks for the largest prefix length $k$ of a matrix chain $A_1 A_2 \\cdots A_n$ such that the minimal computational cost of the product $A_1 A_2 \\cdots A_k$ does not exceed a given budget $B$. The dimensions of the matrices are given by a sequence $p = \\langle p_0, p_1, \\dots, p_n \\rangle$, where matrix $A_i$ has dimensions $p_{i-1} \\times p_i$. The cost of multiplying an $(a \\times b)$ matrix by a $(b \\times c)$ matrix is $a \\cdot b \\cdot c$ scalar multiplications.\n\nThis problem can be decomposed into two nested tasks:\n1.  For a given prefix length $k$, determine the minimum number of scalar multiplications required to compute the product $A_1 A_2 \\cdots A_k$. This is the classic Matrix Chain Multiplication (MCM) problem.\n2.  Find the largest integer $k$ in the range $[1, n]$ for which the minimum cost from step 1 is less than or equal to the budget $B$.\n\nLet us first address the inner problem: finding the minimum cost for a fixed chain of $k$ matrices, $A_1 \\cdots A_k$, with dimensions defined by the sequence $\\langle p_0, p_1, \\dots, p_k \\rangle$. This is a canonical problem solved using dynamic programming. Let $m[i, j]$ denote the minimum cost to compute the product of the subchain $A_i A_{i+1} \\cdots A_j$, where $1 \\le i \\le j \\le k$.\n\nThe base cases are for chains of length $1$ (a single matrix), which require no multiplication. Thus, for all $i$:\n$$m[i, i] = 0$$\n\nFor a subchain of length greater than $1$, i.e., $j  i$, we must make a final multiplication. Suppose this final multiplication splits the product as $(A_i \\cdots A_s)(A_{s+1} \\cdots A_j)$ for some split point $s$ where $i \\le s  j$. The cost of this particular parenthesization would be the cost of computing the left sub-product, plus the cost of computing the right sub-product, plus the cost of the final multiplication. The matrix $(A_i \\cdots A_s)$ has dimensions $p_{i-1} \\times p_s$, and the matrix $(A_{s+1} \\cdots A_j)$ has dimensions $p_s \\times p_j$. The cost of the final multiplication is therefore $p_{i-1} \\cdot p_s \\cdot p_j$.\n\nTo find the minimum total cost, we must try all possible split points $s$ and take the minimum. This leads to the following recurrence relation for $i  j$:\n$$m[i, j] = \\min_{i \\le s  j} \\{ m[i, s] + m[s+1, j] + p_{i-1} \\cdot p_s \\cdot p_j \\}$$\n\nThe minimum cost for the entire chain $A_1 \\cdots A_k$ is given by $m[1, k]$. We can compute the values of $m[i, j]$ iteratively. We build a 2D table to store the costs, filling it out for increasing chain lengths. We first compute costs for all chains of length $L=2$, then $L=3$, and so on, up to $L=k$.\n\nNow, we address the outer problem: finding the largest $k \\in [1, n]$ such that $m[1, k] \\le B$. The minimum cost to compute a product of $k$ matrices is a non-decreasing function of $k$. That is, the cost for $A_1 \\cdots A_k$ cannot be less than the cost for $A_1 \\cdots A_{k-1}$, as the former involves at least one more matrix multiplication. This monotonicity allows for an efficient search. A simple and effective strategy is to search for $k$ starting from the maximum possible value, $n$, and decrementing. The first value of $k$ that satisfies the budget constraint will be the largest such $k$.\n\nThe overall algorithm is as follows:\nFor each test case, given a dimension sequence $p = \\langle p_0, \\dots, p_n \\rangle$ and a budget $B$:\n1.  Iterate $k$ from $n$ down to $1$.\n2.   For each $k$, determine the minimal cost to compute the product $A_1 \\cdots A_k$.\n    - If $k=1$, the cost is $0$ by definition.\n    - If $k  1$, use the dynamic programming algorithm described above with the dimension subsequence $\\langle p_0, p_1, \\dots, p_k \\rangle$. This yields the value we denoted as $m[1, k]$.\n3.  Let the computed cost be $C_k$. Check if $C_k \\le B$.\n4.  If the condition is met, then this value of $k$ is the answer. We record it and terminate the search for the current test case.\n5.  If the loop completes down to $k=1$, the cost is $C_1 = 0$. Since matrix dimensions are positive integers, the cost is always non-negative, so $B$ must also be non-negative for any solution to exist. Assuming $B \\ge 0$, $k=1$ will always be a valid solution if no larger $k$ is found.\n\nThis combined approach correctly and efficiently solves the problem as stated.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef matrix_chain_min_cost(dims):\n    \"\"\"\n    Calculates the minimum number of scalar multiplications for a matrix chain.\n    Args:\n        dims: A list of integers representing the matrix dimensions [p_0, p_1, ..., p_k].\n    Returns:\n        The minimum cost to multiply the chain of k matrices.\n    \"\"\"\n    n = len(dims) - 1\n    if n = 1:\n        return 0\n\n    # dp[i, j] will store the minimum cost to multiply matrices A_i through A_j.\n    # We use 1-based indexing for matrices, so the table size is (n+1)x(n+1).\n    dp = np.full((n + 1, n + 1), 0, dtype=np.int64)\n    \n    # Use a large number for infinity. We use int64 to avoid overflow with large costs.\n    infinity = np.iinfo(np.int64).max\n\n    # L is the chain length.\n    for L in range(2, n + 1):\n        # i is the starting matrix index.\n        for i in range(1, n - L + 2):\n            j = i + L - 1\n            dp[i, j] = infinity\n            # s is the split point.\n            for s in range(i, j):\n                # Cost for this split: cost(A_i..A_s) + cost(A_s+1..A_j) + cost(mult)\n                # Dims of (A_i..A_s) is dims[i-1] x dims[s]\n                # Dims of (A_s+1..A_j) is dims[s] x dims[j]\n                cost = dp[i, s] + dp[s + 1, j] + dims[i - 1] * dims[s] * dims[j]\n                if cost  dp[i, j]:\n                    dp[i, j] = cost\n    \n    return dp[1, n]\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Each test case is a tuple: (dimension_sequence, budget)\n    test_cases = [\n        ([10, 30, 5, 60], 2000),\n        ([2, 3, 4], 0),\n        ([2, 3, 4], 24),\n        ([5, 10, 3, 12, 5, 50, 6], 1000000000),\n        ([7, 9, 3, 4, 8], 452),\n    ]\n\n    results = []\n    for p, B in test_cases:\n        # n is the total number of matrices in the full chain.\n        n = len(p) - 1\n        \n        # Search for the largest k from n down to 1.\n        for k in range(n, 0, -1):\n            if k == 1:\n                # Cost for k=1 is 0, as no multiplications are needed.\n                cost = 0\n            else:\n                # Get the dimension subsequence for the prefix of length k.\n                prefix_dims = p[:k+1]\n                cost = matrix_chain_min_cost(prefix_dims)\n\n            # Check if the cost is within the budget.\n            if cost = B:\n                # Since we are iterating downwards, the first k that fits\n                # the budget is the largest one.\n                results.append(k)\n                break\n    \n    # Format and print the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3249062"}]}