{"hands_on_practices": [{"introduction": "The concept of edit distance can be used to measure how much a single string deviates from a desired structural property. This exercise [@problem_id:3230960] challenges you to quantify how \"far\" a given string is from being a palindrome. Solving this problem requires deriving a custom dynamic programming recurrence relation from first principles, providing insight into creative problem-solving by adapting the logic of edit distance.", "problem": "Let $S$ be the string $S=\\text{\"abracad\"}$ with length $n=7$. A palindrome is a string $P$ such that $P$ is identical to its reversal, i.e., $P=P^{\\text{rev}}$. Consider the standard Levenshtein edit operations with unit cost $1$ per operation: single-character insertion, single-character deletion, and single-character substitution. Starting from the foundational definitions of these edit operations and the structural property of palindromes, derive a method from first principles to determine the minimum number of edits required to transform $S$ into any palindrome. Compute this minimum number of edits exactly. The final answer must be a single real-valued number. No rounding is required.", "solution": "The user wants me to find the minimum number of edit operations (insertion, deletion, substitution, all with unit cost) to transform a given string into a palindrome.\n\n### Step 1: Extract Givens\n- The string is $S = \\text{\"abracad\"}$.\n- The length of the string is $n=7$.\n- A palindrome is a string $P$ that is identical to its reversal, $P = P^{\\text{rev}}$.\n- The allowed edit operations are single-character insertion, deletion, and substitution.\n- Each operation has a cost of $1$.\n- The objective is to find the minimum total cost to transform $S$ into any palindrome.\n\n### Step 2: Validate Using Extracted Givens\nThe problem presented is a classic problem in the field of algorithms and data structures, specifically concerning string manipulation and dynamic programming.\n- **Scientifically Grounded (Critical)**: The problem is based on well-defined mathematical and computer science concepts: strings, palindromes, and Levenshtein edit distance. The concepts are sound and rigorously defined.\n- **Well-Posed**: The problem is well-posed. It asks for a minimum value over a defined set of operations, which guarantees that a unique, stable, and meaningful numerical solution exists.\n- **Objective (Critical)**: The problem is stated in precise, objective language, free of ambiguity or subjective claims.\n\nThe problem does not exhibit any of the invalidity flaws:\n1.  It does not violate any scientific or mathematical principles.\n2.  It is a formalizable problem directly related to edit distance.\n3.  The setup is complete and consistent.\n4.  The conditions are purely computational, not physical, and are thus feasible.\n5.  It is well-structured and admits a unique solution.\n6.  It is a standard, non-trivial problem requiring a specific algorithmic approach.\n7.  The result is verifiable.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with a full derivation and solution.\n\n### Derivation of Method\nLet the given string be $S$ of length $n$. We wish to find the minimum number of edits (insertions, deletions, or substitutions) to transform $S$ into a palindrome. Let this minimum number of edits for a generic substring $S[i \\dots j]$ be denoted by the function $D(i, j)$. Our goal is to compute $D(0, n-1)$.\n\nWe can establish a recurrence relation for $D(i, j)$ by considering the characters at the ends of the substring, $S[i]$ and $S[j]$.\n\n**Base Cases:**\n- For a substring of length $1$, $S[i \\dots i]$, it is already a palindrome. Thus, no edits are needed. $D(i, i) = 0$.\n- For a substring of length $0$ (e.g., when $j < i$), it is also trivially a palindrome. The cost is $0$.\n\n**Recursive Step:**\nConsider the substring $S[i \\dots j]$ where $i < j$.\n1.  **Case 1: The outermost characters match, $S[i] = S[j]$.**\n    If the characters at the ends of the substring match, they already satisfy the palindrome property with respect to each other. We do not need to edit them. The problem reduces to making the inner substring $S[i+1 \\dots j-1]$ a palindrome. Therefore, the minimum number of edits is the same as the number of edits required for the inner substring.\n    $$D(i, j) = D(i+1, j-1) \\quad \\text{if } S[i] = S[j]$$\n\n2.  **Case 2: The outermost characters do not match, $S[i] \\neq S[j]$.**\n    Since $S[i]$ and $S[j]$ do not match, we must perform at least one edit operation to resolve this mismatch. We have three fundamental choices, analogous to the Levenshtein distance operations:\n    a. **Substitution:** We can change one of the characters to match the other. For instance, we could substitute $S[i]$ with a character equal to $S[j]$, or substitute $S[j]$ with a character equal to $S[i]$. In either case, this costs $1$ edit. After this operation, the ends match, and we are left with the subproblem of making the inner string $S[i+1 \\dots j-1]$ a palindrome. The total cost for this choice is $1 + D(i+1, j-1)$.\n    b. **Deletion/Insertion (on the left):** We can delete the character $S[i]$. This costs $1$ edit. We are then left with the subproblem of making the remaining substring $S[i+1 \\dots j]$ a palindrome. The total cost is $1 + D(i+1, j)$. This operation is equivalent in outcome to transforming $S[i \\dots j-1]$ into a palindrome and then inserting a character at the beginning to match $S[j]$.\n    c. **Deletion/Insertion (on the right):** Symmetrically, we can delete the character $S[j]$. This costs $1$ edit. We are left with the subproblem of making $S[i \\dots j-1]$ a palindrome. The total cost is $1 + D(i, j-1)$.\n\n    Since we want the minimum number of edits, we must choose the operation that results in the minimum total cost.\n    $$D(i, j) = 1 + \\min \\left( D(i+1, j), D(i, j-1), D(i+1, j-1) \\right) \\quad \\text{if } S[i] \\neq S[j]$$\n\nThis recurrence can be solved efficiently using dynamic programming. We construct a 2D table, say `$dp[i][j]`, to store the values of $D(i, j)$. We fill the table for substrings of increasing length, from $1$ to $n$.\n\n### Computation\nWe apply this method to the string $S = \\text{\"abracad\"}$ ($n=7$, indices $0$ to $6$). Let `$dp[i][j]` be the table storing $D(i, j)$.\n\n**Length $L=1$:**\n`$dp[i][i] = 0$` for all $i \\in \\{0, \\dots, 6\\}$.\n\n**Length $L=2$:**\n- `$dp[0][1]$` (\"ab\"): $S[0] \\neq S[1] \\implies 1 + \\min(dp[1][1], dp[0][0], dp[1][0]) = 1 + \\min(0, 0, 0) = 1$.\n- By the same logic, for all substrings of length $2$ with non-matching characters:\n  `$dp[1][2]$`(\"br\") $= 1$, `$dp[2][3]$`(\"ra\") $= 1$, `$dp[3][4]$`(\"ac\") $= 1$, `$dp[4][5]$`(\"ca\") $= 1$, `$dp[5][6]$`(\"ad\") $= 1$.\n\n**Length $L=3$:**\n- `$dp[0][2]$` (\"abr\"): $S[0] \\neq S[2] \\implies 1 + \\min(dp[1][2], dp[0][1], dp[1][1]) = 1 + \\min(1, 1, 0) = 1$.\n- `$dp[1][3]$` (\"bra\"): $S[1] \\neq S[3] \\implies 1 + \\min(dp[2][3], dp[1][2], dp[2][2]) = 1 + \\min(1, 1, 0) = 1$.\n- `$dp[2][4]$` (\"rac\"): $S[2] \\neq S[4] \\implies 1 + \\min(dp[3][4], dp[2][3], dp[3][3]) = 1 + \\min(1, 1, 0) = 1$.\n- `$dp[3][5]$` (\"aca\"): $S[3] = S[5] \\implies dp[4][4] = 0$.\n- `$dp[4][6]$` (\"cad\"): $S[4] \\neq S[6] \\implies 1 + \\min(dp[5][6], dp[4][5], dp[5][5]) = 1 + \\min(1, 1, 0) = 1$.\n\n**Length $L=4$:**\n- `$dp[0][3]$` (\"abra\"): $S[0] = S[3] \\implies dp[1][2] = 1$.\n- `$dp[1][4]$` (\"brac\"): $S[1] \\neq S[4] \\implies 1 + \\min(dp[2][4], dp[1][3], dp[2][3]) = 1 + \\min(1, 1, 1) = 2$.\n- `$dp[2][5]$` (\"raca\"): $S[2] \\neq S[5] \\implies 1 + \\min(dp[3][5], dp[2][4], dp[3][4]) = 1 + \\min(0, 1, 1) = 1$.\n- `$dp[3][6]$` (\"acad\"): $S[3] \\neq S[6] \\implies 1 + \\min(dp[4][6], dp[3][5], dp[4][5]) = 1 + \\min(1, 0, 1) = 1$.\n\n**Length $L=5$:**\n- `$dp[0][4]$` (\"abrac\"): $S[0] \\neq S[4] \\implies 1 + \\min(dp[1][4], dp[0][3], dp[1][3]) = 1 + \\min(2, 1, 1) = 2$.\n- `$dp[1][5]$` (\"braca\"): $S[1] \\neq S[5] \\implies 1 + \\min(dp[2][5], dp[1][4], dp[2][4]) = 1 + \\min(1, 2, 1) = 2$.\n- `$dp[2][6]$` (\"racad\"): $S[2] \\neq S[6] \\implies 1 + \\min(dp[3][6], dp[2][5], dp[3][5]) = 1 + \\min(1, 1, 0) = 1$.\n\n**Length $L=6$:**\n- `$dp[0][5]$` (\"abraca\"): $S[0] = S[5] \\implies dp[1][4] = 2$.\n- `$dp[1][6]$` (\"bracad\"): $S[1] \\neq S[6] \\implies 1 + \\min(dp[2][6], dp[1][5], dp[2][5]) = 1 + \\min(1, 2, 1) = 2$.\n\n**Length $L=7$:**\n- `$dp[0][6]$` (\"abracad\"): $S[0] \\neq S[6] \\implies 1 + \\min(dp[1][6], dp[0][5], dp[1][5]) = 1 + \\min(2, 2, 2) = 3$.\n\nThe minimum number of edits required to transform the string $S=\\text{\"abracad\"}$ into a palindrome is given by `$dp[0][6]`, which is $3$.\n\nAs an example, one possible sequence of 3 edits is:\n1.  Change $S[1]$ ('b') to 'a'.\n2.  Change $S[2]$ ('r') to 'c'.\n3.  Change $S[6]$ ('d') to 'a'.\nThe original string \"abracad\" becomes \"aacacaa\", which is a palindrome. The total cost is $3$.", "answer": "$$\\boxed{3}$$", "id": "3230960"}, {"introduction": "In many practical scenarios, from bioinformatics to text search, the goal is not to compare two strings of equal length, but to find the best possible match for a pattern within a larger body of text. This practice [@problem_id:3231121] asks you to adapt the standard edit distance algorithm for this string-to-substring search problem. Successfully solving it requires a nuanced understanding of the dynamic programming table and how its initialization defines the search boundaries.", "problem": "Let $S_1$ be the string \"frame\" and let $S_2$ be the string \"infrared\". Consider the standard edit operations on strings over the lowercase English alphabet: insertion of a single character, deletion of a single character, and substitution of a single character for another. Each operation has unit cost $1$, and matching identical characters contributes cost $0$. The edit distance between two strings is the minimum total cost over all sequences of such operations transforming one string into the other.\n\nDefine the string-to-substring edit distance from $S_1$ to $S_2$ as the minimum edit distance between $S_1$ and any contiguous substring of $S_2$.\n\nUsing only the core definitions of edit distance and optimal substructure (as used in dynamic programming), determine the minimum edit distance between $S_1$ and any substring of $S_2$. Provide your final answer as a single integer. No rounding is required.", "solution": "### Step 1: Understand the Problem and Formulate the Approach\nThe goal is to find the minimum edit distance between a pattern string $S_1$ and *any* contiguous substring of a longer text string $S_2$. This is a classic \"fuzzy\" or approximate substring search problem.\n\nThe standard Levenshtein distance algorithm can be adapted for this task. The key modification lies in the initialization of the dynamic programming (DP) table. The main insight is that we want to allow an alignment to start at any position in $S_2$ without incurring a penalty for the characters in $S_2$ that come before the match begins.\n\nLet $S_1$ be the pattern of length $m$ and $S_2$ be the text of length $n$. We will construct a DP table, `dp`, of size $(m+1) \\times (n+1)$. The entry `dp[i][j]` will store the minimum edit distance between the first $i$ characters of $S_1$ and any substring of $S_2$ that ends at position $j-1$.\n\n### Step 2: Define the DP State and Recurrence\n- **Initialization:**\n    - The first column is initialized as `dp[i][0] = i` for $i = 0, \\dots, m$. This represents the cost of deleting the first $i$ characters of the pattern $S_1$ to match an empty string. This is standard.\n    - The first row is initialized as `dp[0][j] = 0` for $j = 0, \\dots, n$. This is the crucial change. It signifies that an empty pattern ($S_1$ prefix of length 0) can be matched to any prefix of $S_2$ with a cost of 0. This effectively allows the alignment of $S_1$ to start at any arbitrary position within $S_2$ for free.\n\n- **Recurrence Relation:** The recurrence for filling the rest of the table is identical to the standard Levenshtein distance algorithm:\n$$dp[i][j] = \\min \\begin{cases} dp[i-1, j] + 1  \\quad \\text{(Deletion from } S_1\\text{)} \\\\ dp[i, j-1] + 1  \\quad \\text{(Insertion into } S_1\\text{)} \\\\ dp[i-1, j-1] + \\text{cost}(S_1[i-1], S_2[j-1]) \\end{cases}$$\nwhere $\\text{cost}(c_1, c_2)$ is $0$ if the characters are the same and $1$ if they are different.\n\n- **Final Answer:** After the table is filled, the cost of the best match of the entire pattern $S_1$ against any substring of $S_2$ will be the minimum value found in the last row of the table. This is because `dp[m][j]` represents the minimum cost to align all of $S_1$ with a substring of $S_2$ ending at position $j-1$. We take the minimum over all possible ending positions.\n$$ \\text{Result} = \\min_{j=0}^{n} dp[m][j] $$\n\n### Step 3: Compute the DP Table for the Given Strings\n- $S_1 = \\text{\"frame\"}$ ($m=5$)\n- $S_2 = \\text{\"infrared\"}$ ($n=8$)\n\nThe DP table `dp[i][j]` will be of size $6 \\times 9$.\n\n**Initialization:**\n- `dp[:, 0] = [0, 1, 2, 3, 4, 5]`\n- `dp[0, :] = [0, 0, 0, 0, 0, 0, 0, 0, 0]`\n\n**Filled Table:**\n```\n      \"\" i n f r a r e d\n\"\"    0  0 0 0 0 0 0 0 0\nf     1  1 1 0 1 1 1 1 1\nr     2  2 2 1 0 1 1 2 2\na     3  3 3 2 1 0 1 2 3\nm     4  4 4 3 2 1 1 2 3\ne     5  5 5 4 3 2 2 1 2\n```\n\n### Step 4: Extract the Final Answer\nThe answer is the minimum value in the last row (the row for $S_1 = \\text{\"frame\"}$).\nLast row: `[5, 5, 5, 4, 3, 2, 2, 1, 2]`\nThe minimum value in this row is $1$.\n\nThis minimum cost of $1$ corresponds to aligning \"frame\" with the substring \"frare\" (a substring of \"infrared\" found by taking characters from index 2 to 6). The edit distance $D(\\text{\"frame\"}, \\text{\"frare\"})$ is $1$ (substituting 'm' with 'r').", "answer": "$$\\boxed{1}$$", "id": "3231121"}, {"introduction": "Calculating the Levenshtein distance between two strings is fundamental, but how can we use it to efficiently search a large dictionary for close matches, as in a spell-checker? This advanced exercise [@problem_id:3216177] tasks you with implementing a BK-Tree, a data structure that leverages the metric properties of Levenshtein distance to dramatically accelerate searches. By deriving a search-pruning rule from the triangle inequality, you will build a practical application that demonstrates the power of theoretical properties in algorithm design.", "problem": "You are to design and implement a complete program that builds and queries a Burkhard–Keller Tree (BK-Tree) for approximate string matching using the Levenshtein distance. A BK-Tree is a rooted tree where each edge is labeled by a nonnegative integer distance, and each node stores a single element from the domain; it supports efficient range queries under a metric. In this problem, the domain is the set of finite strings over a fixed alphabet, and the metric is the Levenshtein distance. The goal is to derive the pruning rule from first principles and implement the resulting search.\n\nFundamental base and definitions:\n- A metric space is a pair $(X, d)$ where $X$ is a set and $d: X \\times X \\to \\mathbb{R}_{\\ge 0}$ satisfies nonnegativity, identity of indiscernibles, symmetry, and the triangle inequality. The triangle inequality states: for all $x, y, z \\in X$, $d(x, z) \\le d(x, y) + d(y, z)$.\n- The Levenshtein distance $D(s, t)$ between strings $s$ and $t$ is the minimum number of single-character insertions, deletions, and substitutions required to transform $s$ into $t$. It is a well-known fact that $D$ is a metric, i.e., $D$ satisfies the metric axioms stated above.\n- A Burkhard–Keller Tree (BK-Tree) organizes elements by placing, for each node storing an element $u$, a child at edge label $\\ell \\in \\mathbb{Z}_{\\ge 0}$ if there exists an element $v$ such that $D(u, v) = \\ell$. During insertion, starting at the root, an element $v$ is routed to a child whose edge label equals $D(u, v)$; if that child does not exist, a new node is created at that edge.\n\nTask:\n- Derive, from the triangle inequality and the definition of a range query, the necessary condition on child edge labels that allows pruning of the search space when querying for all elements $v$ with $D(q, v) \\le k$ from a given query string $q$ and radius $k \\in \\mathbb{Z}_{\\ge 0}$. The problem statement does not provide the explicit inequality; the derivation must begin from the metric axioms and yield a usable pruning criterion for BK-Tree search.\n- Implement a Levenshtein distance function $D(s, t)$ using dynamic programming.\n- Build a BK-Tree from an ordered dictionary of words, assigning each word an index equal to its position in the given list (starting at $0$). Each BK-Tree node should store the word and its index. Insertion should follow the BK-Tree rule using $D$.\n- Implement a range query that, given $(q, k)$, returns the sorted list of indices $i$ such that $D(q, W[i]) \\le k$, where $W$ is the dictionary list.\n\nTest suite and parameters:\n- Use the following dictionary $W$ (each word is assigned the index equal to its position in the list): index $0$: \"book\"; index $1$: \"books\"; index $2$: \"boo\"; index $3$: \"boon\"; index $4$: \"boom\"; index $5$: \"bone\"; index $6$: \"cook\"; index $7$: \"cool\"; index $8$: \"school\"; index $9$: \"fool\"; index $10$: \"boar\"; index $11$: \"board\"; index $12$: \"bored\"; index $13$: \"bond\"; index $14$: \"band\"; index $15$: \"ban\"; index $16$: \"an\"; index $17$: \"a\"; index $18$: \"bo\"; index $19$: \"hook\"; index $20$: \"brook\".\n- Run the range query for the following $(q, k)$ pairs:\n  - $(\\text{\"boon\"}, k = 1)$\n  - $(\\text{\"book\"}, k = 0)$\n  - $(\\text{\"\"}, k = 2)$ where the empty string is allowed\n  - $(\\text{\"scholl\"}, k = 1)$\n  - $(\\text{\"xyz\"}, k = 10)$\n- For each test case, the required answer is the sorted list of indices of matching dictionary entries. Each individual test case result must be a list of integers.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a bracketed, comma-separated list of integers. For example, a valid output format is $[[i_1,i_2],[j_1,j_2,j_3],\\dots]$ with no spaces.", "solution": "The problem requires the derivation of the search pruning rule for a Burkhard–Keller Tree (BK-Tree) from first principles and the implementation of a complete program to build and query such a tree for approximate string matching. The matching is based on the Levenshtein distance, $D$, and the query seeks all strings $v$ in a dictionary $W$ such that their distance to a query string $q$ is within a given radius $k$, i.e., $D(q, v) \\le k$.\n\nThe foundation of the BK-Tree's efficiency is that the elements it stores belong to a metric space $(X, d)$. A metric space is a set $X$ equipped with a distance function $d: X \\times X \\to \\mathbb{R}_{\\ge 0}$ satisfying four axioms:\n$1$. Non-negativity: $d(x, y) \\ge 0$\n$2$. Identity of indiscernibles: $d(x, y) = 0 \\iff x = y$\n$3$. Symmetry: $d(x, y) = d(y, x)$\n$4$. The triangle inequality: $d(x, z) \\le d(x, y) + d(y, z)$\n\nIn this problem, the set $X$ is the set of finite strings, and the distance function $d$ is the Levenshtein distance $D$. It is a given fact that $(X, D)$ is a metric space. The pruning rule for the search algorithm is a direct consequence of the triangle inequality.\n\nDerivation of the Pruning Rule:\nLet $q$ be the query string and $k$ be the search radius. The goal is to find all strings $v$ in the tree such that $D(q, v) \\le k$. The search algorithm traverses the tree, and at each node, it must decide which of its child subtrees, if any, could possibly contain a match.\n\nConsider the state of the search at an arbitrary node in the tree. Let this node contain the string $u$. The algorithm has already computed the distance $d_u = D(q, u)$ between the query string $q$ and the node's string $u$. Now, consider a child of $u$. The edge leading to this child is labeled with an integer distance $\\ell$. By the construction of the BK-Tree, any string $v$ located in the subtree rooted at this child must satisfy the condition $D(u, v) = \\ell$.\n\nTo determine if this subtree needs to be explored, we apply the triangle inequality to the three strings: the query $q$, the current node's string $u$, and a potential match $v$ in the child subtree.\n\nFrom the triangle inequality, we have two key relations:\n$1$. $D(q, u) \\le D(q, v) + D(v, u)$. By symmetry, $D(v, u) = D(u, v)$, so we can write $D(q, u) \\le D(q, v) + D(u, v)$. Rearranging gives:\n$$D(q, u) - D(u, v) \\le D(q, v)$$\n\n$2$. $D(u, v) \\le D(u, q) + D(q, v)$. By symmetry, $D(u, q) = D(q, u)$, so $D(u, v) \\le D(q, u) + D(q, v)$. Rearranging gives:\n$$D(u, v) - D(q, u) \\le D(q, v)$$\n\nThese two inequalities can be combined into a single, more compact form, often called the reverse triangle inequality:\n$$|D(q, u) - D(u, v)| \\le D(q, v)$$\n\nWe are searching for strings $v$ that satisfy the primary query condition $D(q, v) \\le k$. If a string $v$ in the child subtree is a valid match, then combining the reverse triangle inequality with the query condition yields:\n$$|D(q, u) - D(u, v)| \\le D(q, v) \\le k$$\n\nThis implies a necessary condition that must hold for any potential match $v$ to exist in the child subtree:\n$$|D(q, u) - D(u, v)| \\le k$$\n\nLet us substitute the known values: $d_u = D(q, u)$ is the distance computed at the current node, and $\\ell = D(u, v)$ is the label of the edge leading to the child subtree. The necessary condition for exploring the child subtree becomes:\n$$|d_u - \\ell| \\le k$$\n\nThis inequality is the pruning rule. It states that we only need to traverse to children along edges with labels $\\ell$ that are \"close\" to the distance $d_u$ from the query to the current node. Expanding the absolute value gives the range of edge labels to check:\n$$-k \\le d_u - \\ell \\le k$$\nWhich is equivalent to:\n$$d_u - k \\le \\ell \\le d_u + k$$\n\nTherefore, the search algorithm proceeds as follows:\n$1$. Start at the root of the BK-Tree.\n$2$. At a given node containing string $u$:\n   a. Compute the distance $d_u = D(q, u)$.\n   b. If $d_u \\le k$, the string $u$ is a match. Add its index to the result set.\n   c. Iterate through all children of $u$. For each child connected by an edge with label $\\ell$, check if $d_u - k \\le \\ell \\le d_u + k$.\n   d. If the condition is met, recursively apply the search procedure to that child node. Otherwise, prune that entire branch of the tree from the search.\n\nThis derived rule allows the algorithm to avoid computing Levenshtein distances for a large fraction of the strings in the dictionary, making it significantly more efficient than a linear scan.\n\nThe implementation will consist of three main components:\n$1$. A function to compute the Levenshtein distance $D(s, t)$ using a standard dynamic programming approach with a cost matrix.\n$2$. A class-based representation of the BK-Tree, with a `Node` structure to hold a word, its index, and a dictionary of its children, and a `BKTree` class to manage insertion and querying.\n$3$. A query method that implements the recursive search using the derived pruning rule $|d_u - \\ell| \\le k$.\n\nThe final program will build the tree from the provided dictionary and then execute the specified queries, collecting and formatting the results as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef levenshtein_distance(s1: str, s2: str) -> int:\n    \"\"\"\n    Calculates the Levenshtein distance between two strings using dynamic programming.\n    \"\"\"\n    m, n = len(s1), len(s2)\n    \n    # Initialize DP table. dp[i][j] will be the distance between the first\n    # i chars of s1 and the first j chars of s2.\n    dp = np.zeros((m + 1, n + 1), dtype=int)\n    \n    # Base cases: distance from an empty string to a non-empty one is the\n    # length of the non-empty string (all insertions).\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n        \n    # Fill the rest of the table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            cost = 0 if s1[i - 1] == s2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1,        # Deletion\n                           dp[i][j - 1] + 1,        # Insertion\n                           dp[i - 1][j - 1] + cost) # Substitution/Match\n                           \n    return dp[m][n]\n\nclass BKNode:\n    \"\"\"A node in the Burkhard-Keller Tree.\"\"\"\n    def __init__(self, word: str, index: int):\n        self.word = word\n        self.index = index\n        self.children = {}  # dict mapping distance to child BKNode\n\nclass BKTree:\n    \"\"\"A Burkhard-Keller Tree for approximate string matching.\"\"\"\n    def __init__(self):\n        self.root = None\n\n    def add(self, word: str, index: int):\n        \"\"\"Adds a word with its index to the tree.\"\"\"\n        if self.root is None:\n            self.root = BKNode(word, index)\n            return\n\n        current_node = self.root\n        while True:\n            dist = levenshtein_distance(current_node.word, word)\n            if dist in current_node.children:\n                current_node = current_node.children[dist]\n            else:\n                current_node.children[dist] = BKNode(word, index)\n                break\n\n    def query(self, query_word: str, k: int) -> list[int]:\n        \"\"\"\n        Finds all words in the tree within Levenshtein distance k of the query_word.\n        Returns a sorted list of indices.\n        \"\"\"\n        if self.root is None:\n            return []\n            \n        matches = []\n        # A stack for iterative traversal to avoid deep recursion\n        stack = [self.root]\n\n        while stack:\n            node = stack.pop()\n            # Calculate distance from query word to the current node's word\n            dist_to_node = levenshtein_distance(query_word, node.word)\n\n            # If the current node is a match, add its index\n            if dist_to_node <= k:\n                matches.append(node.index)\n\n            # Use the triangle inequality to prune branches\n            # We only need to visit children in the range [d-k, d+k]\n            low = dist_to_node - k\n            high = dist_to_node + k\n\n            for dist, child in node.children.items():\n                if low <= dist <= high:\n                    stack.append(child)\n        \n        matches.sort()\n        return matches\n\ndef solve():\n    # Define the dictionary and test cases from the problem statement.\n    dictionary = [\n        \"book\", \"books\", \"boo\", \"boon\", \"boom\", \"bone\", \"cook\", \"cool\",\n        \"school\", \"fool\", \"boar\", \"board\", \"bored\", \"bond\", \"band\", \"ban\",\n        \"an\", \"a\", \"bo\", \"hook\", \"brook\"\n    ]\n    \n    test_cases = [\n        (\"boon\", 1),\n        (\"book\", 0),\n        (\"\", 2),\n        (\"scholl\", 1),\n        (\"xyz\", 10)\n    ]\n\n    # Build the BK-Tree\n    bktree = BKTree()\n    for i, word in enumerate(dictionary):\n        bktree.add(word, i)\n        \n    all_results = []\n    for q, k in test_cases:\n        result = bktree.query(q, k)\n        all_results.append(result)\n\n    # Format the output exactly as specified: [[i1,i2],[j1],...] with no spaces\n    case_strings = []\n    for res_list in all_results:\n        case_strings.append(f\"[{','.join(map(str, res_list))}]\")\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3216177"}]}