{"hands_on_practices": [{"introduction": "The best way to truly grasp an algorithm is to apply it and understand its underlying proof of correctness. This first exercise [@problem_id:3252772] provides a concrete set of tasks and challenges you to find the optimal schedule that minimizes the maximum lateness. More importantly, it requires you to justify the optimality of the Earliest Deadline First (EDF) rule from first principles, solidifying both the 'how' and the 'why' of this fundamental scheduling strategy.", "problem": "In a single-resource setting modeling an escape room, an escape room master must deliver exactly one hint at a time to a team. There are $6$ hints, each requiring a known non-preemptive duration $t_i$ and having a deadline $d_i$ by which it would ideally be completed to keep the team on track. The master begins at time $0$ and must deliver the hints back-to-back without idle time. The objective is to determine, over all possible orderings of the $6$ hints, the minimum possible value of the maximum lateness, defined as $L_{\\max} = \\max_{i} \\left(C_i - d_i\\right)$, where $C_i$ is the completion time of hint $i$ in the chosen sequence. Use only the core definitions of completion time and lateness, and reason from first principles via pairwise exchanges between adjacent hints to justify optimality of your chosen ordering.\n\nThe hints are:\n- Hint $1$: $t_1 = 3$, $d_1 = 4$.\n- Hint $2$: $t_2 = 2$, $d_2 = 7$.\n- Hint $3$: $t_3 = 5$, $d_3 = 9$.\n- Hint $4$: $t_4 = 4$, $d_4 = 6$.\n- Hint $5$: $t_5 = 2$, $d_5 = 3$.\n- Hint $6$: $t_6 = 6$, $d_6 = 15$.\n\nState the minimum achievable value of $L_{\\max}$ as a single real number. No units are required. If you perform any intermediate arithmetic, keep it exact; no rounding is required in the final answer.", "solution": "The problem asks for the minimum possible value of the maximum lateness, $L_{\\max}$, for a set of $6$ non-preemptive hints to be delivered by a single resource starting at time $t=0$. The hints must be delivered back-to-back, implying no idle time.\n\nFirst, we formalize the problem. Let the set of hints be $\\mathcal{J} = \\{1, 2, 3, 4, 5, 6\\}$. Each hint $i \\in \\mathcal{J}$ has a processing time $t_i > 0$ and a due date $d_i$. A schedule is a permutation $\\sigma = (\\sigma(1), \\sigma(2), \\dots, \\sigma(6))$ of the hints in $\\mathcal{J}$. The start time of the first hint $\\sigma(1)$ is $S_{\\sigma(1)} = 0$. For any subsequent hint $\\sigma(k)$ where $k > 1$, its start time is the completion time of the previous hint, $S_{\\sigma(k)} = C_{\\sigma(k-1)}$. The completion time of hint $\\sigma(k)$ is $C_{\\sigma(k)} = S_{\\sigma(k)} + t_{\\sigma(k)}$. Since there is no idle time, the completion time of the hint at position $k$ in the sequence is the sum of the processing times of all hints up to and including that position:\n$$C_{\\sigma(k)} = \\sum_{j=1}^{k} t_{\\sigma(j)}$$\nThe lateness of hint $i$ is defined as $L_i = C_i - d_i$. The objective is to find a schedule $\\sigma$ that minimizes the maximum lateness, $L_{\\max}(\\sigma) = \\max_{i \\in \\mathcal{J}} (C_i - d_i)$.\n\nThe problem specifies that the optimality of the chosen ordering must be justified from first principles using a pairwise exchange argument. This argument establishes the optimality of the Earliest Deadline First (EDF) scheduling rule, which states that sequencing hints in non-decreasing order of their due dates minimizes the maximum lateness.\n\nLet's prove the optimality of the EDF rule. Consider an arbitrary schedule $S$ that is not an EDF schedule. If $S$ is not an EDF schedule, there must exist at least one pair of hints, say hint $i$ and hint $j$, that are scheduled adjacently with $i$ immediately preceding $j$, but where $d_i > d_j$. Let the schedule be of the form $S = (\\pi_1, i, j, \\pi_2)$, where $\\pi_1$ and $\\pi_2$ are (possibly empty) subsequences of the other hints.\n\nLet $T$ be the completion time of the last hint in the prefix sequence $\\pi_1$. If $\\pi_1$ is empty, $T=0$. In schedule $S$, the completion times of hints $i$ and $j$ are:\n$$C_i = T + t_i$$\n$$C_j = T + t_i + t_j$$\nTheir respective latenesses are:\n$$L_i = T + t_i - d_i$$\n$$L_j = T + t_i + t_j - d_j$$\nThe maximum lateness among this pair is $\\max(L_i, L_j)$.\n\nNow, let's create a new schedule $S'$ by swapping the order of $i$ and $j$: $S' = (\\pi_1, j, i, \\pi_2)$. The completion times of all hints in $\\pi_1$ are unchanged. The total time to process the pair $(i, j)$ is $t_i + t_j$, which is the same for the pair $(j, i)$. Therefore, the start times and completion times for all hints in the suffix sequence $\\pi_2$ are also unchanged. Thus, the lateness of any hint in $\\pi_1$ or $\\pi_2$ is unaffected by the swap. We only need to analyze the change in maximum lateness for hints $i$ and $j$.\n\nIn schedule $S'$, the new completion times $C'_j$ and $C'_i$ are:\n$$C'_j = T + t_j$$\n$$C'_i = T + t_j + t_i$$\nThe new latenesses $L'_j$ and $L'_i$ are:\n$$L'_j = T + t_j - d_j$$\n$$L'_i = T + t_j + t_i - d_i$$\nThe new maximum lateness for the pair is $\\max(L'_j, L'_i)$.\n\nWe want to show that $\\max(L'_j, L'_i) \\le \\max(L_i, L_j)$.\nLet's analyze the new lateness values in relation to the old ones.\nCompare $L'_i$ with $L_j$:\n$L'_i = T + t_j + t_i - d_i$\n$L_j = T + t_i + t_j - d_j$\nSince we assumed an inversion, $d_i > d_j$, which implies $-d_i < -d_j$. Therefore, $L'_i < L_j$.\n\nNow, let's compare $L'_j$ with $L_j$:\n$L'_j = T + t_j - d_j$\n$L_j = (T + t_j - d_j) + t_i$\nSince all processing times are positive ($t_i > 0$), it is clear that $L'_j < L_j$.\n\nWe have demonstrated that both new latenesses, $L'_i$ and $L'_j$, are strictly smaller than the original lateness $L_j$.\n$$L'_i < L_j \\quad \\text{and} \\quad L'_j < L_j$$\nThis implies that the maximum of the new latenesses must also be strictly smaller than $L_j$:\n$$\\max(L'_j, L'_i) < L_j$$\nSince $L_j \\le \\max(L_i, L_j)$ by definition of the maximum function, it follows that:\n$$\\max(L'_j, L'_i) < L_j \\le \\max(L_i, L_j)$$\nThus, swapping an adjacent pair $(i,j)$ with $d_i>d_j$ to $(j,i)$ does not increase the maximum lateness of the schedule. In fact, it can only decrease it or leave it unchanged (if the maximum lateness was determined by some other hint in $\\pi_1$ or $\\pi_2$). By repeatedly applying such swaps, any schedule can be transformed into the EDF schedule. Each step does not increase the maximum lateness. Therefore, the EDF schedule must have a maximum lateness that is less than or equal to that of any other schedule. It is an optimal schedule.\n\nWe now apply the EDF rule to the given data:\n- Hint $1$: $t_1 = 3$, $d_1 = 4$.\n- Hint $2$: $t_2 = 2$, $d_2 = 7$.\n- Hint $3$: $t_3 = 5$, $d_3 = 9$.\n- Hint $4$: $t_4 = 4$, $d_4 = 6$.\n- Hint $5$: $t_5 = 2$, $d_5 = 3$.\n- Hint $6$: $t_6 = 6$, $d_6 = 15$.\n\nSorting these hints in non-decreasing order of their due dates ($d_i$) gives the following sequence:\n$1$. Hint $5$ ($d_5 = 3$)\n$2$. Hint $1$ ($d_1 = 4$)\n$3$. Hint $4$ ($d_4 = 6$)\n$4$. Hint $2$ ($d_2 = 7$)\n$5$. Hint $3$ ($d_3 = 9$)\n$6$. Hint $6$ ($d_6 = 15$)\n\nThe optimal schedule is the sequence $(5, 1, 4, 2, 3, 6)$. We now calculate the completion time and lateness for each hint in this sequence. The start time is $S=0$.\n\n- **Hint 5**:\n  - $t_5 = 2$, $d_5 = 3$.\n  - Start time $S_5 = 0$.\n  - Completion time $C_5 = 0 + 2 = 2$.\n  - Lateness $L_5 = C_5 - d_5 = 2 - 3 = -1$.\n\n- **Hint 1**:\n  - $t_1 = 3$, $d_1 = 4$.\n  - Start time $S_1 = C_5 = 2$.\n  - Completion time $C_1 = 2 + 3 = 5$.\n  - Lateness $L_1 = C_1 - d_1 = 5 - 4 = 1$.\n\n- **Hint 4**:\n  - $t_4 = 4$, $d_4 = 6$.\n  - Start time $S_4 = C_1 = 5$.\n  - Completion time $C_4 = 5 + 4 = 9$.\n  - Lateness $L_4 = C_4 - d_4 = 9 - 6 = 3$.\n\n- **Hint 2**:\n  - $t_2 = 2$, $d_2 = 7$.\n  - Start time $S_2 = C_4 = 9$.\n  - Completion time $C_2 = 9 + 2 = 11$.\n  - Lateness $L_2 = C_2 - d_2 = 11 - 7 = 4$.\n\n- **Hint 3**:\n  - $t_3 = 5$, $d_3 = 9$.\n  - Start time $S_3 = C_2 = 11$.\n  - Completion time $C_3 = 11 + 5 = 16$.\n  - Lateness $L_3 = C_3 - d_3 = 16 - 9 = 7$.\n\n- **Hint 6**:\n  - $t_6 = 6$, $d_6 = 15$.\n  - Start time $S_6 = C_3 = 16$.\n  - Completion time $C_6 = 16 + 6 = 22$.\n  - Lateness $L_6 = C_6 - d_6 = 22 - 15 = 7$.\n\nThe lateness values for the hints in the optimal schedule are $\\{-1, 1, 3, 4, 7, 7\\}$. The maximum lateness is the maximum of these values:\n$$L_{\\max} = \\max(-1, 1, 3, 4, 7, 7) = 7$$\nTherefore, the minimum possible value of the maximum lateness is $7$.", "answer": "$$\\boxed{7}$$", "id": "3252772"}, {"introduction": "Real-world scheduling problems rarely involve all tasks being available from the very beginning; jobs often arrive over time and can sometimes be interrupted and resumed. This exercise [@problem_id:3252827] extends the basic model to include release times ($r_i$) and preemption, requiring you to adapt the EDD principle into a dynamic, event-driven algorithm. Implementing this more sophisticated scheduler will enhance your ability to model and solve problems with more realistic, time-dependent constraints.", "problem": "You are given a single machine scheduling problem in which each job must be processed non-preemptively or preemptively on a single machine that can handle at most one job at any time. Each job has three attributes: a release time $r_i$, a processing time $p_i$, and a deadline $d_i$. The machine is continuously available, jobs become available to process only at or after their release times, a job may be preempted and resumed later without penalty, and all parameters are integers. The completion time of job $i$ is $C_i$, and its lateness is defined as $L_i = C_i - d_i$. The objective is to minimize the maximum lateness $L_{\\max} = \\max_i L_i$. All times are unitless integers.\n\nStarting from the fundamental definitions of completion time and lateness, design an algorithm from first principles that decides, at every instant, which available job to run in order to minimize $L_{\\max}$. Your algorithm must be correct for arbitrary integer inputs $\\{(r_i,p_i,d_i)\\}$ with preemption allowed, and it must compute the minimum possible $L_{\\max}$ value. Your reasoning must not rely on unproven heuristics or black-box theorems, and must be based on fundamental definitions and a logically valid exchange argument.\n\nYour program must implement this algorithm and compute the minimum possible $L_{\\max}$ for each of the following test cases. Each test case is a list of jobs, given as triples $(r_i,p_i,d_i)$:\n\n- Test case $1$: $[(0,3,9),(0,2,8),(0,2,15)]$.\n- Test case $2$: $[(0,10,100),(5,1,7)]$.\n- Test case $3$: $[(0,5,3),(0,2,5)]$.\n- Test case $4$: $[(0,3,10),(2,0,1)]$.\n- Test case $5$: $[(0,7,20),(3,4,8),(4,2,6)]$.\n- Test case $6$: $[(0,2,5),(5,2,20)]$.\n- Test case $7$: $[(0,2,5),(1,2,5)]$.\n\nYour program must produce a single line of output containing the results for the test cases as a comma-separated list enclosed in square brackets, in the same order as above, for example $[x_1,x_2,\\dots,x_7]$. The result for each test must be a single integer equal to the minimum achievable $L_{\\max}$ for that test case under preemption without penalty. No additional text or whitespace should be printed, and no input should be read. The program must be self-contained and runnable as is.", "solution": "The user is asking for an algorithm to solve the single-machine scheduling problem with release times and preemption, with the objective of minimizing the maximum lateness, defined as $L_{\\max} = \\max_i L_i$, where $L_i = C_i - d_i$. Here, $C_i$ is the completion time of job $i$, and $d_i$ is its deadline. Each job $i$ is defined by a triplet $(r_i, p_i, d_i)$, representing its release time, processing time, and deadline, respectively. All parameters are integers.\n\nThe problem is to devise an algorithm from first principles and prove its correctness via an exchange argument. The required algorithm is a dynamic version of the Earliest Deadline First (EDF) rule.\n\n### The Proposed Algorithm: Earliest Deadline First (EDF)\n\nThe greedy strategy is as follows: At any point in time $t$, from the set of available jobs (those released, $r_i \\le t$, but not yet completed), select the one with the earliest deadline $d_i$ to process. If the set of available jobs is empty, the machine remains idle. This is known as the Earliest Deadline First (EDF) algorithm.\n\n### Correctness Proof\n\nWe will prove the optimality of the EDF algorithm by an exchange argument. The proof consists of two parts: first, showing that an optimal schedule need not have any idle time when jobs are available, and second, showing that any non-EDF schedule can be transformed into an EDF schedule without increasing the maximum lateness.\n\n#### Part 1: Idle Time\n\nLet $S_{OPT}$ be an optimal schedule that minimizes $L_{\\max}$. Suppose at some time $t_1$, there is at least one job available, but the machine is idle in $S_{OPT}$ during the interval $[t_1, t_2)$. Let job $j$ be an available job at $t_1$. Since the machine is idle, this job $j$ (and any other work) must be scheduled at some time $t_3 \\ge t_2$.\n\nWe can construct a new schedule $S'$ from $S_{OPT}$ by moving $\\delta > 0$ units of work on some job from an interval starting at or after $t_2$ to the idle interval starting at $t_1$. Specifically, we can take a portion of job $j$'s processing from a later time and perform it in the interval $[t_1, t_1+\\delta]$, where $\\delta = \\min(t_2-t_1, p_j(t_1))$, with $p_j(t_1)$ being the remaining processing time of job $j$ at time $t_1$.\n\nIn the new schedule $S'$, all jobs complete no later than they did in $S_{OPT}$, so their lateness does not increase. Thus, $L_{\\max}(S') \\le L_{\\max}(S_{OPT})$. We can repeat this process until the schedule has no idle time when jobs are available. This shows that there exists an optimal schedule that is \"busy\" whenever possible.\n\n#### Part 2: Exchange Argument\n\nLet $S_{EDF}$ be the schedule generated by our EDF algorithm. Let $S_{OPT}$ be an optimal schedule that is \"busy\" (as per Part 1) but is not an EDF schedule. If $S_{OPT}$ is not an EDF schedule, there must be a first time $t$ at which its choice of job to process differs from EDF's choice.\n\nAt this time $t$, $S_{EDF}$ chooses an available job $j$ such that for any other available job $k$, $d_j \\le d_k$. Since $S_{OPT}$ deviates, it must choose a different available job, say $k$, where by necessity $d_k \\ge d_j$. Let's assume for simplicity of argument that $d_k > d_j$.\n\nIn $S_{OPT}$, job $k$ is processed for some time $\\Delta > 0$ starting at $t$. Job $j$ must be processed at a later time. Let's find the first interval $[t', t'+\\Delta']$ after $t$ where $S_{OPT}$ processes job $j$.\n\nWe now construct a new schedule $S'$ from $S_{OPT}$ by swapping these blocks of work. Let $\\delta = \\min(\\Delta, \\Delta')$.\n- In $S'$, process job $j$ in the interval $[t, t+\\delta]$.\n- In $S'$, process job $k$ in the interval $[t', t'+\\delta]$.\n- At all other times, $S'$ is identical to $S_{OPT}$.\n\nThis new schedule $S'$ is valid because job $j$ was available at time $t$, and job $k$ (available at $t$) is certainly available at the later time $t'$.\n\nLet's analyze the lateness in $S'$ compared to $S_{OPT}$. Let $C_i$ and $C'_i$ be the completion times in $S_{OPT}$ and $S'$, respectively.\n1.  For any job $i \\neq j, k$, its processing is unaffected. Thus, $C'_i = C_i$ and $L'_i = L_i$.\n2.  For job $j$, a portion of its work is performed earlier. This can only lead to an earlier or identical completion time. So, $C'_j \\le C_j$, which implies $L'_j = C'_j - d_j \\le C_j - d_j = L_j$.\n3.  For job $k$, a portion of its work is delayed. Its completion time $C'_k$ might be greater than $C_k$. However, the time slot that job $j$ occupied in $S_{OPT}$ at $[t', t'+\\delta]$ is now available for other work, including job $k$. The total work on jobs $j$ and $k$ is completed within the same total time window previously enclosing their execution in $S_{OPT}$. Critically, the completion time of job $k$ in $S'$, $C'_k$, cannot exceed the completion time of job $j$ in $S_{OPT}$, $C_j$. This is because any time slot used for job $j$ after time $t$ in $S_{OPT}$ is now made available for job $k$ in $S'$. Therefore, $C'_k \\le C_j$.\n\nNow we can compare the lateness of job $k$:\n$L'_k = C'_k - d_k \\le C_j - d_k$.\nSince we started with the premise that $d_j < d_k$, it follows that $-d_k < -d_j$.\nSo, $L'_k \\le C_j - d_k < C_j - d_j = L_j$.\n\nWe have shown that $L'_j \\le L_j$ and $L'_k < L_j$. This means $\\max(L'_j, L'_k) \\le L_j \\le \\max(L_j, L_k)$. The maximum lateness of the pair $\\{j, k\\}$ has not increased. Since lateness for all other jobs is unchanged, the overall maximum lateness has not increased: $L_{\\max}(S') \\le L_{\\max}(S_{OPT})$.\n\nBy repeatedly applying this exchange, we can transform $S_{OPT}$ into a schedule that matches $S_{EDF}$ at every step, without ever increasing the maximum lateness. This proves that the schedule $S_{EDF}$ produced by the Earliest Deadline First algorithm is optimal.\n\n### Algorithmic Implementation\n\nThe EDF algorithm can be implemented as a discrete-event simulation. The \"events\" that require a scheduling decision are the release of a new job or the completion of the currently running job.\n\n1.  Maintain a global `currentTime`.\n2.  Keep a list of jobs not yet released, sorted by release time $r_i$.\n3.  Use a min-priority queue to store available jobs, ordered by their deadline $d_i$.\n4.  The main simulation loop advances `currentTime` from one event to the next.\n    -   At `currentTime`, add any newly released jobs to the priority queue.\n    -   If the machine is busy, check if any job in the priority queue has an earlier deadline than the one running. If so, preempt the current job (return it to the priority queue) and start the new one.\n    -   If the machine is idle, extract the job with the minimum deadline from the priority queue to run.\n    -   If the machine is idle and no jobs are available, advance `currentTime` to the next job release time.\n    -   Calculate the time until the next event (either the current job's completion or the next job's release). Advance `currentTime` by this amount and update the remaining processing time of the current job.\n    -   If a job completes, record its completion time and set the machine to be idle.\n5.  The simulation ends when all jobs are completed.\n6.  Finally, compute $L_{\\max} = \\max_i(C_i - d_i)$ over all jobs. This will be the minimum possible maximum lateness.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to solve the scheduling problem for all test cases.\n    \"\"\"\n    test_cases = [\n        [(0, 3, 9), (0, 2, 8), (0, 2, 15)],\n        [(0, 10, 100), (5, 1, 7)],\n        [(0, 5, 3), (0, 2, 5)],\n        [(0, 3, 10), (2, 0, 1)],\n        [(0, 7, 20), (3, 4, 8), (4, 2, 6)],\n        [(0, 2, 5), (5, 2, 20)],\n        [(0, 2, 5), (1, 2, 5)],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = edf_scheduler(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef edf_scheduler(jobs_data):\n    \"\"\"\n    Calculates the minimum maximum lateness for a set of jobs using the\n    Earliest Deadline First (EDF) scheduling algorithm with preemption.\n\n    Args:\n        jobs_data: A list of tuples, where each tuple is (r_i, p_i, d_i)\n                   representing release time, processing time, and deadline.\n\n    Returns:\n        The minimum possible maximum lateness (L_max).\n    \"\"\"\n    if not jobs_data:\n        return 0\n\n    # Job representation: Use a dictionary to hold mutable state (p_rem).\n    # 'id' is the original index, used for tracking.\n    jobs = [{'id': i, 'r': r, 'p': p, 'd': d, 'p_rem': p}\n            for i, (r, p, d) in enumerate(jobs_data)]\n    \n    # Map job IDs to their data for O(1) access.\n    job_map = {j['id']: j for j in jobs}\n    \n    # Jobs to be processed, sorted by release time.\n    unreleased_jobs = sorted(jobs, key=lambda j: j['r'])\n\n    # Min-priority queue for available jobs, ordered by deadline.\n    # Stores tuples of (deadline, job_id).\n    available_jobs_pq = []\n\n    completion_times = {}\n    current_time = 0\n    current_job_id = None\n    processed_job_count = 0\n\n    # The simulation runs until all jobs are completed.\n    while processed_job_count < len(jobs):\n        \n        # If the machine is idle and no jobs are available, jump time to the next release.\n        if current_job_id is None and not available_jobs_pq and unreleased_jobs:\n            current_time = max(current_time, unreleased_jobs[0]['r'])\n        \n        # Add all jobs released by the current time to the available pool.\n        while unreleased_jobs and unreleased_jobs[0]['r'] <= current_time:\n            job = unreleased_jobs.pop(0)\n            heapq.heappush(available_jobs_pq, (job['d'], job['id']))\n\n        # If a job just finished or the machine was idle, select the next job to run (EDF).\n        if current_job_id is None and available_jobs_pq:\n            _, current_job_id = heapq.heappop(available_jobs_pq)\n\n        # Preemption check: if an available job has an earlier deadline than the current one.\n        if current_job_id is not None and available_jobs_pq:\n            best_available_d, _ = available_jobs_pq[0]\n            if best_available_d < job_map[current_job_id]['d']:\n                # The available job preempts the current job.\n                heapq.heappush(available_jobs_pq, (job_map[current_job_id]['d'], current_job_id))\n                _, current_job_id = heapq.heappop(available_jobs_pq)\n        \n        if current_job_id is None:\n            # This handles idle periods between jobs when the ready queue is temporarily empty.\n            continue\n            \n        current_job = job_map[current_job_id]\n\n        # Determine the time slice for the current job. It runs until it's finished\n        # or a new job is released, whichever comes first.\n        time_to_completion = current_job['p_rem']\n        time_to_next_release = float('inf')\n        if unreleased_jobs:\n            time_to_next_release = unreleased_jobs[0]['r'] - current_time\n        \n        time_to_run = max(0, min(time_to_completion, time_to_next_release))\n\n        # Update state based on the time slice.\n        current_job['p_rem'] -= time_to_run\n        current_time += time_to_run\n\n        # If the job has finished processing.\n        if current_job['p_rem'] == 0:\n            completion_times[current_job_id] = current_time\n            current_job_id = None\n            processed_job_count += 1\n            \n    # Calculate the maximum lateness over all jobs.\n    max_lateness = -float('inf')\n    for i in range(len(jobs_data)):\n        d = jobs_data[i][2]\n        c = completion_times[i]\n        max_lateness = max(max_lateness, c - d)\n            \n    return int(max_lateness)\n\nsolve()\n```", "id": "3252827"}, {"introduction": "While minimizing the single worst-case lateness is a common goal, some applications may be more concerned with the overall service quality, such as ensuring that not too many jobs are excessively late. This advanced problem [@problem_id:3252882] challenges you to optimize a different objective: minimizing the lateness of the $k$-th latest job. Tackling this requires a powerful problem-solving pattern that combines binary search on the answer with a clever greedy substructure, demonstrating how to transform a complex optimization task into a series of simpler decision problems.", "problem": "You are given a single-machine scheduling problem with a set of $n$ independent jobs. Each job $J_i$ has a positive processing time $p_i$ and a due date $d_i$, where $i \\in \\{1,2,\\dots,n\\}$. A schedule is any permutation $\\sigma$ of the jobs, executed non-preemptively on a single machine that can process at most one job at a time. For a given schedule $\\sigma$, the completion time of job $J_i$ is denoted by $C_i(\\sigma)$, defined recursively as the cumulative sum of processing times in the order $\\sigma$. The lateness of job $J_i$ under schedule $\\sigma$ is $L_i(\\sigma) = C_i(\\sigma) - d_i$. For any schedule $\\sigma$, consider the multiset $\\{L_1(\\sigma), L_2(\\sigma), \\dots, L_n(\\sigma)\\}$ sorted in non-increasing order; the $k$-th latest job’s lateness is the $k$-th element of this sorted list, for a given integer $k$ with $1 \\le k \\le n$.\n\nYour task is to design and implement a complete, runnable program that, for each of several specified test cases, computes the minimal possible value of the $k$-th latest job’s lateness over all valid schedules. The derivation must start from fundamental definitions of single-machine scheduling, completion time, and lateness, and must not use any unverified shortcuts. The final output must be a single line containing the results of all test cases as a comma-separated list enclosed in square brackets.\n\nThere are no physical units in this problem. All returned values must be integers.\n\nUse the following test suite. For each test case, the input is a list of $(p_i, d_i)$ pairs and an integer $k$. Your program must compute a single integer: the minimal possible value of the $k$-th latest job’s lateness over all schedules.\n\n- Test case $1$: jobs $[(3,10),(2,5),(7,12),(4,8),(5,14),(6,7)]$, $k=2$.\n- Test case $2$: jobs $[(1,4),(3,9),(2,8),(6,15),(4,16)]$, $k=1$.\n- Test case $3$: jobs $[(2,20),(7,20),(1,20),(5,20),(4,20),(6,20),(3,20)]$, $k=3$.\n- Test case $4$: jobs $[(5,25),(4,25),(7,25),(6,25)]$, $k=4$.\n- Test case $5$: jobs $[(4,10),(4,10),(4,10),(4,10)]$, $k=2$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is the integer answer to the corresponding test case.", "solution": "We begin from the fundamental definitions of single-machine scheduling. A schedule $\\sigma$ is any permutation of the set of jobs $\\{J_1,\\dots,J_n\\}$. The completion time $C_i(\\sigma)$ of job $J_i$ is defined by the cumulative processing time of the jobs preceding it in $\\sigma$ plus $p_i$. The lateness of job $J_i$ in schedule $\\sigma$ is $L_i(\\sigma)=C_i(\\sigma)-d_i$. Sorting $\\{L_1(\\sigma),\\dots,L_n(\\sigma)\\}$ in non-increasing order yields an ordered vector of latenesses, and the $k$-th latest is the $k$-th element of this sorted vector. The problem is to find a schedule that minimizes the $k$-th largest element of this vector.\n\nA key equivalence follows from the definition of lateness. Fix any threshold $T \\in \\mathbb{Z}$. A job $J_i$ satisfies $L_i(\\sigma)\\le T$ if and only if $C_i(\\sigma)\\le d_i+T$. Therefore, for a given $T$, jobs with lateness at most $T$ in $\\sigma$ are precisely those that complete by their adjusted deadlines $d_i+T$. If at most $(k-1)$ jobs have lateness strictly greater than $T$, then the $k$-th largest lateness is at most $T$. Conversely, if more than $(k-1)$ jobs have lateness strictly greater than $T$, then the $k$-th largest lateness exceeds $T$. This establishes a monotone decision property in $T$: define $f(T)$ as the number of jobs whose lateness is strictly greater than $T$ in the best-possible schedule with respect to the adjusted deadlines $d_i+T$. Then $f(T)$ is non-increasing in $T$, and the minimal possible value of the $k$-th latest job’s lateness equals the minimal integer $T$ such that $f(T)\\le k-1$.\n\nWe now describe how to compute $f(T)$ from first principles. For a fixed $T$, we ask: what is the maximum number of jobs that can be scheduled to meet adjusted deadlines $\\tilde{d}_i=d_i+T$ on a single machine without preemption? This is the classic feasibility question for meeting deadlines, and a widely accepted solution is given by the Moore–Hodgson algorithm: sort jobs by non-decreasing adjusted deadlines (Earliest Due Date (EDD) order on $\\tilde{d}_i$), then greedily include jobs while keeping track of the cumulative processing time $S$. Whenever $S$ exceeds the current job’s adjusted deadline, remove from the set the job with the largest processing time among the included ones; this step strictly reduces $S$, and by an exchange argument it preserves the potential to meet the maximum number of deadlines. Specifically, suppose at some point $S>\\tilde{d}_j$. Removing any included job reduces $S$ by its processing time; removing the longest processing time job achieves the greatest reduction in $S$ and never harms feasibility relative to removing a shorter job, because any feasible schedule must have cumulative processing times not exceeding the adjusted deadline thresholds. One can show that the set of kept jobs at the end is maximum cardinality among all subsets that can meet all adjusted deadlines when scheduled in EDD order, using a standard exchange argument: any schedule violating EDD order admits swaps that do not reduce the number of on-time jobs, and any schedule with a choice of removed job other than the longest can be transformed into one removing the longest without decreasing the cardinality of on-time jobs.\n\nLet $g(T)$ denote the maximum number of jobs that can be completed no later than their adjusted deadlines $d_i+T$ under some schedule. Then the minimum number of jobs with lateness strictly greater than $T$ equals $n-g(T)$. The monotonicity is clear: as $T$ increases, each adjusted deadline increases, so $g(T)$ is non-decreasing and $n-g(T)$ is non-increasing.\n\nGiven this monotonic decision structure, we apply binary search on integer thresholds. We need valid global bounds. For any job $J_i$, since $C_i(\\sigma)\\ge 0$, we have $L_i(\\sigma)=C_i(\\sigma)-d_i\\ge -d_i\\ge -\\max_i d_i$. Therefore, the $k$-th largest lateness is always at least $-\\max_i d_i$. On the other hand, since $C_i(\\sigma)\\le \\sum_{j=1}^n p_j$ and $d_i\\ge \\min_i d_i$, we have $L_i(\\sigma)\\le \\sum_{j=1}^n p_j - \\min_i d_i$, so the $k$-th largest lateness is at most $\\sum_{j=1}^n p_j - \\min_i d_i$. Thus, we can search $T$ in the integer interval $[-\\max_i d_i,\\ \\sum_{j=1}^n p_j - \\min_i d_i]$. For a given midpoint $T$, compute $g(T)$ via the Moore–Hodgson procedure in EDD order on $d_i+T$, and test whether $n-g(T)\\le k-1$. If true, move the search to smaller $T$; otherwise, move to larger $T$. The minimal $T$ satisfying the predicate is the minimal possible value of the $k$-th latest job’s lateness.\n\nCorrectness is established by the equivalence: minimizing the $k$-th largest lateness is the same as minimizing $T$ such that at most $(k-1)$ jobs exceed $T$, and the Moore–Hodgson algorithm optimally computes $g(T)$ for any $T$. Since the predicate is monotone in $T$, binary search finds the minimal feasible $T$.\n\nComplexity analysis: For each $T$, computing $g(T)$ requires sorting by adjusted deadlines, which costs $O(n\\log n)$, and then processing jobs with a priority structure to remove the job of largest processing time when needed. Using a binary heap yields per-insert $O(\\log n)$ and per-remove $O(\\log n)$, for a total of $O(n\\log n)$ per feasibility check. Binary search over the integer interval of length at most $\\sum_{j=1}^n p_j + \\max_i d_i$ requires $O(\\log(\\sum_{j=1}^n p_j + \\max_i d_i))$ iterations. Therefore, the total time is $O(n\\log n \\cdot \\log(\\sum_{j=1}^n p_j + \\max_i d_i))$, with $O(n)$ space.\n\nWe implement this algorithm and evaluate it on the specified test suite:\n- Test case $1$: jobs $[(3,10),(2,5),(7,12),(4,8),(5,14),(6,7)]$, $k=2$.\n- Test case $2$: jobs $[(1,4),(3,9),(2,8),(6,15),(4,16)]$, $k=1$.\n- Test case $3$: jobs $[(2,20),(7,20),(1,20),(5,20),(4,20),(6,20),(3,20)]$, $k=3$.\n- Test case $4$: jobs $[(5,25),(4,25),(7,25),(6,25)]$, $k=4$.\n- Test case $5$: jobs $[(4,10),(4,10),(4,10),(4,10)]$, $k=2$.\n\nThe program produces a single line containing the minimal integer values of the $k$-th latest job’s lateness for each case, formatted as a comma-separated list enclosed in square brackets.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef moore_hodgson_max_on_time(processing_times, due_dates, T):\n    \"\"\"\n    Compute the maximum number of jobs that can be completed no later than\n    their adjusted deadlines d_i + T using the Moore–Hodgson algorithm\n    in Earliest Due Date order.\n    \"\"\"\n    n = len(processing_times)\n    # Adjusted deadlines\n    adjusted = [(processing_times[i], due_dates[i] + T) for i in range(n)]\n    # Sort by adjusted deadline (EDD)\n    adjusted.sort(key=lambda x: x[1])\n\n    total_time = 0\n    # We use a max-heap by storing negative processing times in a min-heap\n    max_heap = []  # stores negative p to simulate max-heap\n\n    for p, adj_d in adjusted:\n        total_time += p\n        heapq.heappush(max_heap, -p)\n        # If total processing exceeds adjusted deadline, remove the longest job\n        if total_time > adj_d:\n            longest = -heapq.heappop(max_heap)\n            total_time -= longest\n\n    # The jobs remaining in the heap can meet their adjusted deadlines\n    return len(max_heap)\n\ndef minimize_kth_latest_lateness(processing_times, due_dates, k):\n    \"\"\"\n    Minimize the k-th largest lateness over all schedules by binary searching T,\n    where T is the threshold such that at most (k-1) jobs have lateness > T.\n    \"\"\"\n    n = len(processing_times)\n    if n == 0:\n        return 0\n\n    sum_p = sum(processing_times)\n    max_d = max(due_dates)\n    min_d = min(due_dates)\n\n    # Global bounds for lateness\n    low = -max_d\n    high = sum_p - min_d\n\n    best = high  # initialize with upper bound\n    while low <= high:\n        mid = (low + high) // 2\n        on_time_count = moore_hodgson_max_on_time(processing_times, due_dates, mid)\n        tardy_count = n - on_time_count\n        if tardy_count <= (k - 1):\n            best = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    return best\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (list_of_jobs_as_(p,d), k)\n    test_cases = [\n        ([(3,10),(2,5),(7,12),(4,8),(5,14),(6,7)], 2),\n        ([(1,4),(3,9),(2,8),(6,15),(4,16)], 1),\n        ([(2,20),(7,20),(1,20),(5,20),(4,20),(6,20),(3,20)], 3),\n        ([(5,25),(4,25),(7,25),(6,25)], 4),\n        ([(4,10),(4,10),(4,10),(4,10)], 2),\n    ]\n\n    results = []\n    for jobs, k in test_cases:\n        ps = [p for p, d in jobs]\n        ds = [d for p, d in jobs]\n        result = minimize_kth_latest_lateness(ps, ds, k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3252882"}]}