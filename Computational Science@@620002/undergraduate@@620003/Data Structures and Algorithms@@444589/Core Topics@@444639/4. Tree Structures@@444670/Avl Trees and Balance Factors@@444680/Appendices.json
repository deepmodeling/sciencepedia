{"hands_on_practices": [{"introduction": "To truly master AVL trees, we must move from theory to practice. This first exercise provides a hands-on walkthrough of the core mechanics of AVL tree maintenance. By manually tracing a specific sequence of insertions, you will calculate balance factors at each step and observe precisely how an imbalance develops and triggers a Right-Left ($RL$) rotation, one of the key rebalancing operations [@problem_id:3210713].", "problem": "You will use the core definitions of Adelson–Velsky and Landis (AVL) trees to analyze how rotations are triggered and how balance factors evolve during binary search tree insertions. Let the height of an empty child be defined as $-1$, the height of a node be $1 + \\max\\{\\text{height of left child}, \\text{height of right child}\\}$, and the balance factor of a node $v$ be $\\operatorname{bf}(v) = \\text{height(left}(v)) - \\text{height(right}(v))$. An AVL tree is balanced if every node has balance factor in $\\{-1, 0, 1\\}$. Upon insertion, a node $z$ triggers:\n- a Left–Left ($LL$) rotation if $\\operatorname{bf}(z) = +2$ and the insertion occurred in the left subtree of $z$'s left child,\n- a Right–Right ($RR$) rotation if $\\operatorname{bf}(z) = -2$ and the insertion occurred in the right subtree of $z$'s right child,\n- a Left–Right ($LR$) rotation if $\\operatorname{bf}(z) = +2$ and the left child of $z$ has $\\operatorname{bf} = -1$ (fix is a left rotation on the left child, then a right rotation on $z$),\n- a Right–Left ($RL$) rotation if $\\operatorname{bf}(z) = -2$ and the right child of $z$ has $\\operatorname{bf} = +1$ (fix is a right rotation on the right child, then a left rotation on $z$).\n\nConsider inserting the keys $\\{1,2,3,4,5,6,7\\}$ into an initially empty binary search tree in the specific order $\\langle 4, 6, 5, 2, 1, 3, 7 \\rangle$. This order forces a Right–Left ($RL$) rotation at node $4$ at the moment just after inserting key $5$ and before any rebalancing is performed at that step.\n\nFor step $t \\in \\{1,2,\\dots,7\\}$, let $V_t$ denote the set of nodes present immediately after the $t$-th insertion and before any rebalancing at that step, and let $\\operatorname{bf}_t^{-}(v)$ denote the balance factor of a node $v \\in V_t$ in that pre-rebalancing tree. Define the cumulative imbalance magnitude\n$$\nS \\;=\\; \\sum_{t=1}^{7} \\;\\sum_{v \\in V_t} \\left|\\operatorname{bf}_t^{-}(v)\\right|.\n$$\n\nTasks:\n- Using only the fundamental definitions above, argue why the given insertion order forces an $RL$ rotation at node $4$ at the moment just after inserting key $5$.\n- Compute $\\operatorname{bf}_t^{-}(v)$ for every $v \\in V_t$ at each step $t$ and identify all rotation triggers at their first unbalanced ancestors.\n- Evaluate the exact value of $S$.\n\nYour final answer must be the exact value of $S$ (a single integer). No rounding is required.", "solution": "The problem is valid as it is self-contained, scientifically grounded in the theory of AVL trees, and well-posed. The definitions, insertion sequence, and the quantity to be computed are all specified unambiguously, ensuring a unique and meaningful solution exists.\n\nThe solution proceeds in two parts. First, we will demonstrate why an RL rotation is forced at node $4$ after inserting key $5$. Second, we will trace the insertion of each of the $7$ keys, calculating the set of pre-rebalancing balance factors $\\operatorname{bf}_t^{-}(v)$ at each step $t$ and summing their absolute magnitudes to find the total cumulative imbalance $S$.\n\n### Argument for Right-Left (RL) Rotation\n\nWe begin with an empty tree.\n1.  Insert $4$: The tree is a single node, $4$. $h(4)=0$, $\\operatorname{bf}(4)=0$.\n2.  Insert $6$: Since $6 > 4$, $6$ becomes the right child of $4$. The tree is $4 \\rightarrow (\\text{right}) \\ 6$.\n    - $h(6) = 1 + \\max(-1, -1) = 0$.\n    - $h(4) = 1 + \\max(h(\\text{left}), h(6)) = 1 + \\max(-1, 0) = 1$.\n    - $\\operatorname{bf}(4) = h(\\text{left}) - h(6) = -1 - 0 = -1$. The tree is balanced.\n\n3.  Insert $5$: Since $5 > 4$, we go right to node $6$. Since $5  6$, we go left. $5$ is inserted as the left child of $6$. The structure before any rebalancing is $4 \\rightarrow (\\text{right}) \\ 6 \\rightarrow (\\text{left}) \\ 5$. Let's analyze the state just after this insertion, denoted by $t=3$.\n    - Let $v_4, v_5, v_6$ be the nodes with keys $4, 5, 6$.\n    - The height of the new leaf node is $h(v_5) = 0$. Its balance factor is $\\operatorname{bf}_3^{-}(v_5) = 0 - 0 = 0$.\n    - The height of its parent is $h(v_6) = 1 + \\max(h(v_5), h(\\text{empty})) = 1+\\max(0, -1) = 1$.\n    - The balance factor of $v_6$ is $\\operatorname{bf}_3^{-}(v_6) = h(v_5) - h(\\text{empty}) = 0 - (-1) = +1$.\n    - The height of the root node is $h(v_4) = 1 + \\max(h(\\text{empty}), h(v_6)) = 1+\\max(-1, 1) = 2$.\n    - The balance factor of $v_4$ is $\\operatorname{bf}_3^{-}(v_4) = h(\\text{empty}) - h(v_6) = -1 - 1 = -2$.\n\nThe first node, tracing up from the insertion point ($v_5$), with a balance factor outside the set $\\{-1, 0, 1\\}$ is $z=v_4$. Its balance factor is $\\operatorname{bf}_3^{-}(v_4) = -2$. The problem defines an RL rotation trigger for a node $z$ as: \"$\\operatorname{bf}(z) = -2$ and the right child of $z$ has $\\operatorname{bf} = +1$\". Here, $z=v_4$, its right child is $v_6$, and we have calculated $\\operatorname{bf}_3^{-}(v_6) = +1$.\nBoth conditions are met. Thus, the insertion of key $5$ forces an RL rotation at node $4$.\n\n### Step-by-Step Calculation of $S$\n\nWe now compute $S = \\sum_{t=1}^{7} \\sum_{v \\in V_t} |\\operatorname{bf}_t^{-}(v)|$. For each step $t$, we show the tree state before rebalancing, calculate the balance factors, sum their absolute values, and describe the rebalancing operation.\n\n**Step $t=1$: Insert $4$**\n-   Pre-rebalancing tree: A single node $4$.\n-   $V_1 = \\{4\\}$.\n-   $\\operatorname{bf}_1^{-}(4) = 0$.\n-   $\\sum_{v \\in V_1} |\\operatorname{bf}_1^{-}(v)| = |0| = 0$.\n-   Tree is balanced.\n\n**Step $t=2$: Insert $6$**\n-   Pre-rebalancing tree: $4 \\rightarrow (\\text{right}) \\ 6$.\n-   $V_2 = \\{4, 6\\}$.\n-   $\\operatorname{bf}_2^{-}(6) = 0$.\n-   $\\operatorname{bf}_2^{-}(4) = h(\\text{left}) - h(\\text{right}) = -1 - 0 = -1$.\n-   $\\sum_{v \\in V_2} |\\operatorname{bf}_2^{-}(v)| = |-1| + |0| = 1$.\n-   Tree is balanced.\n\n**Step $t=3$: Insert $5$**\n-   Pre-rebalancing tree: $4 \\rightarrow (\\text{right}) \\ 6 \\rightarrow (\\text{left}) \\ 5$.\n-   $V_3 = \\{4, 5, 6\\}$.\n-   $\\operatorname{bf}_3^{-}(5) = 0$.\n-   $\\operatorname{bf}_3^{-}(6) = h(5) - h(\\text{empty}) = 0 - (-1) = 1$.\n-   $\\operatorname{bf}_3^{-}(4) = h(\\text{empty}) - h(6) = -1 - 1 = -2$.\n-   $\\sum_{v \\in V_3} |\\operatorname{bf}_3^{-}(v)| = |-2| + |0| + |1| = 3$.\n-   Rotation: Node $4$ is unbalanced ($\\operatorname{bf}=-2$) with right child's $\\operatorname{bf}=+1$. An **RL rotation** is performed at node $4$. The tree becomes rooted at $5$, with left child $4$ and right child $6$.\n\n**Step $t=4$: Insert $2$**\n-   Tree after rebalancing from $t=3$: $5 \\rightarrow (\\text{left}) \\ 4, (\\text{right}) \\ 6$.\n-   Pre-rebalancing tree for $t=4$: $5 \\rightarrow (\\text{left}) \\ (4 \\rightarrow (\\text{left}) \\ 2), (\\text{right}) \\ 6$.\n-   $V_4 = \\{2, 4, 5, 6\\}$.\n-   $\\operatorname{bf}_4^{-}(2)=0$, $\\operatorname{bf}_4^{-}(6)=0$.\n-   $\\operatorname{bf}_4^{-}(4) = h(2) - h(\\text{empty}) = 0 - (-1) = 1$.\n-   $\\operatorname{bf}_4^{-}(5) = h(4) - h(6) = 1 - 0 = 1$.\n-   $\\sum_{v \\in V_4} |\\operatorname{bf}_4^{-}(v)| = |0| + |1| + |1| + |0| = 2$.\n-   Tree is balanced.\n\n**Step $t=5$: Insert $1$**\n-   Tree from $t=4$: $5 \\rightarrow \\big( (\\text{left}) \\ 4 \\rightarrow(\\text{left}) \\ 2 \\big), (\\text{right}) \\ 6$.\n-   Pre-rebalancing tree for $t=5$: $5 \\rightarrow \\big( (\\text{left}) \\ 4 \\rightarrow(\\text{left}) \\ (2 \\rightarrow \\text{left} \\ 1) \\big), (\\text{right}) \\ 6$.\n-   $V_5 = \\{1, 2, 4, 5, 6\\}$.\n-   $\\operatorname{bf}_5^{-}(1)=0$, $\\operatorname{bf}_5^{-}(6)=0$.\n-   $\\operatorname{bf}_5^{-}(2) = h(1) - h(\\text{empty}) = 0 - (-1) = 1$.\n-   $h(2)=1$, so $\\operatorname{bf}_5^{-}(4) = h(2) - h(\\text{empty}) = 1 - (-1) = 2$.\n-   $h(4)=2$, so $\\operatorname{bf}_5^{-}(5) = h(4) - h(6) = 2 - 0 = 2$.\n-   $\\sum_{v \\in V_5} |\\operatorname{bf}_5^{-}(v)| = |0| + |1| + |2| + |2| + |0| = 5$.\n-   Rotation: Node $4$ is the first unbalanced node ($\\operatorname{bf}=+2$). Insertion was in the left subtree of its left child. An **LL rotation** (a single right rotation) is performed at node $4$. The subtree rooted at $4$ becomes rooted at $2$, with left child $1$ and right child $4$. This fixes the balance for all ancestors, including node $5$.\n\n**Step $t=6$: Insert $3$**\n-   Tree after rebalancing from $t=5$: $5 \\rightarrow \\big( (\\text{left}) \\ (2 \\rightarrow (\\text{left}) \\ 1, (\\text{right}) \\ 4) \\big), (\\text{right}) \\ 6$.\n-   Pre-rebalancing tree for $t=6$: Insertion of $3$ ($35, 3>2, 34$) is as left child of $4$.\n-   $V_6 = \\{1, 2, 3, 4, 5, 6\\}$.\n-   $\\operatorname{bf}_6^{-}(1)=0$, $\\operatorname{bf}_6^{-}(3)=0$, $\\operatorname{bf}_6^{-}(6)=0$.\n-   $\\operatorname{bf}_6^{-}(4) = h(3) - h(\\text{empty}) = 0 - (-1) = 1$.\n-   $h(4)=1, h(1)=0$, so $\\operatorname{bf}_6^{-}(2) = h(1) - h(4) = 0 - 1 = -1$.\n-   $h(2)=2, h(6)=0$, so $\\operatorname{bf}_6^{-}(5) = h(2) - h(6) = 2 - 0 = 2$.\n-   $\\sum_{v \\in V_6} |\\operatorname{bf}_6^{-}(v)| = |0| + |-1| + |0| + |1| + |2| + |0| = 4$.\n-   Rotation: Node $5$ is unbalanced ($\\operatorname{bf}=+2$) and its left child ($2$) has $\\operatorname{bf}=-1$. An **LR rotation** is performed at node $5$. The final tree is rooted at $4$.\n\n**Step $t=7$: Insert $7$**\n-   Tree after rebalancing from $t=6$: rooted at $4$, left child $2$ (with children $1,3$), right child $5$ (with right child $6$).\n-   Pre-rebalancing tree for $t=7$: $7$ is inserted as right child of $6$.\n-   $V_7 = \\{1, 2, 3, 4, 5, 6, 7\\}$.\n-   $\\operatorname{bf}_7^{-}(1)=0, \\operatorname{bf}_7^{-}(3)=0, \\operatorname{bf}_7^{-}(7)=0$.\n-   $\\operatorname{bf}_7^{-}(2) = h(1) - h(3) = 0 - 0 = 0$.\n-   $\\operatorname{bf}_7^{-}(6) = h(\\text{empty}) - h(7) = -1 - 0 = -1$.\n-   $h(2)=1$. $h(6)=1$, so $\\operatorname{bf}_7^{-}(5) = h(\\text{empty}) - h(6) = -1 - 1 = -2$.\n-   $h(5)=2$, so $\\operatorname{bf}_7^{-}(4) = h(2) - h(5) = 1 - 2 = -1$.\n-   $\\sum_{v \\in V_7} |\\operatorname{bf}_7^{-}(v)| = |0| + |0| + |0| + |-1| + |-2| + |-1| + |0| = 4$.\n-   Rotation: Node $5$ is unbalanced ($\\operatorname{bf}=-2$). Insertion was in right subtree of right child. An **RR rotation** (a single left rotation) is performed at node $5$.\n\n**Final Calculation of S**\nThe total cumulative imbalance magnitude $S$ is the sum of the per-step sums:\n$$\nS = \\sum_{t=1}^{7} \\sum_{v \\in V_t} |\\operatorname{bf}_t^{-}(v)| = 0 + 1 + 3 + 2 + 5 + 4 + 4\n$$\n$$\nS = 19\n$$", "answer": "$$\\boxed{19}$$", "id": "3210713"}, {"introduction": "While insertions build the tree, deletions test its resilience. This practice explores the impact of node removal on the AVL property, challenging you to identify which nodes are 'safe' to delete without requiring any rebalancing rotations. This exercise deepens your understanding of how changes in subtree height propagate and provides insight into the stability of the AVL structure under deletion [@problem_id:3211065].", "problem": "You are given several valid Adelson-Velsky and Landis (AVL) trees. An Adelson-Velsky and Landis (AVL) tree is a binary search tree in which, for every node $v$, the balance factor $\\beta(v)$ satisfies $|\\beta(v)| \\leq 1$, where $\\beta(v) = h(v_{\\text{left}}) - h(v_{\\text{right}})$ and $h(\\cdot)$ denotes the height of a subtree. The height function $h(T)$ is defined recursively by $h(\\varnothing) = -1$ and $h(T) = 1 + \\max\\{h(T_{\\text{left}}), h(T_{\\text{right}})\\}$ for a non-empty subtree $T$, where height is measured by the number of edges on the longest path from the root of the subtree to a leaf. A binary search tree satisfies the invariant that for each node with key $k$, all keys in the left subtree are strictly less than $k$, and all keys in the right subtree are strictly greater than $k$.\n\nA rotation is a local restructuring operation (single or double rotation) that restores the invariant $|\\beta(v)| \\leq 1$ at an unbalanced node produced by updates. In an Adelson-Velsky and Landis (AVL) tree, rotations are needed after an update if and only if there exists a node $v$ with $|\\beta(v)| = 2$.\n\nDeletion from a binary search tree proceeds by the following well-tested rule set: given a key $x$,\n- if the node with key $x$ has no child, remove it;\n- if it has one child, replace it by its child;\n- if it has two children, replace its key with its in-order successor’s key (the minimum key in its right subtree) and then delete that successor node from the right subtree.\n\nStarting from the above fundamental definitions, your task is to identify, for each provided valid Adelson-Velsky and Landis (AVL) tree, a key whose deletion (using the standard binary search tree deletion described above) will not require any rotations anywhere in the tree. Equivalently, after performing the deletion, the resulting tree must still satisfy $|\\beta(v)| \\leq 1$ for every node $v$. If multiple keys satisfy this property, you must select the smallest such key. If no such key exists, output $-1$.\n\nTest Suite:\nEach tree is specified by an insertion sequence of distinct integer keys. Build the tree by inserting the keys in the given order using standard Adelson-Velsky and Landis (AVL) tree insertion, which maintains $|\\beta(v)| \\leq 1$ via rotations as needed during insertion. Use the following insertion sequences (each number is an integer key, presented in the given order; all numbers are to be interpreted as pure integers without any units):\n- Case $1$: $[10, 5, 15, 3, 7, 13, 17]$\n- Case $2$: $[8, 4, 12, 2, 6, 10, 14, 1, 3]$\n- Case $3$: $[50, 25, 75, 10, 37, 62, 87, 5, 12, 31, 43, 57, 68, 81, 93]$\n- Case $4$: $[30, 20, 40, 10, 25, 35, 50, 27, 26]$\n- Case $5$: $[1, 2, 3, 4, 5, 6]$\n\nYour program must:\n- Construct each Adelson-Velsky and Landis (AVL) tree by inserting the sequence in the given order.\n- For each constructed tree, consider deletion of every existing key $x$ via the standard binary search tree deletion operation described earlier. For each deletion, determine if the post-deletion tree remains an Adelson-Velsky and Landis (AVL) tree (i.e., $|\\beta(v)| \\leq 1$ for all nodes $v$). Collect all such keys $x$ whose deletion does not require any rotations, and choose the smallest. If the collection is empty, return $-1$ for that case.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for all five cases as a comma-separated list enclosed in square brackets, for example, $[r_1, r_2, r_3, r_4, r_5]$, where each $r_i$ is the selected integer key for Case $i$ or $-1$ if no such key exists. No angles or physical units appear in this problem, and all reported values are pure integers.", "solution": "The problem requires us to identify, for a given set of Adelson-Velsky and Landis (AVL) trees, the smallest key whose deletion, using a standard binary search tree (BST) deletion algorithm, does not necessitate any rebalancing rotations. An AVL tree is balanced if for every node $v$, its balance factor $\\beta(v) = h(v_{\\text{left}}) - h(v_{\\text{right}})$ satisfies $|\\beta(v)| \\leq 1$. A rotation is required if an update (like deletion) causes any node to have a balance factor of $|\\beta(v)| = 2$. Therefore, the task is to find the smallest key whose deletion leaves the tree in a state where $|\\beta(v)| \\leq 1$ for all nodes $v$.\n\nThe solution follows a multi-step, systematic approach for each test case.\n\n**1. AVL Tree Construction**\nFirst, we must construct the initial valid AVL trees from the provided insertion sequences. This requires a robust implementation of an AVL tree data structure.\n\n-   **Node Structure**: Each node in the tree stores its `key`, pointers to its `left` and `right` children, and its `height`. The height of a leaf is 0, and the height of a `None` (empty) subtree is -1. The height of an internal node is $1 + \\max(\\text{height of left child, height of right child})$.\n\n-   **Insertion Algorithm**: For each key in a given sequence, we perform an AVL insertion. This starts with a standard BST insertion, which places the new key at a leaf position. Then, as the recursion unwinds back to the root, we update the height of each node along the insertion path. After each height update, we calculate the node's balance factor. If a node becomes unbalanced ($|\\beta(v)| = 2$), we perform the appropriate single or double rotation to restore the AVL property. The four imbalance cases are:\n    1.  **Left-Left Case**: A single right rotation.\n    2.  **Left-Right Case**: A left rotation on the left child, followed by a right rotation on the current node.\n    3.  **Right-Right Case**: A single left rotation.\n    4.  **Right-Left Case**: A right rotation on the right child, followed by a left rotation on the current node.\n\nBy applying this procedure for each key in the input sequence, we construct the required initial AVL tree for each test case.\n\n**2. Simulation of Deletion and Validation**\nThe core of the problem is to check the outcome of deleting each key. The process must be a simulation because we are not actually changing the tree permanently, but rather testing a hypothetical scenario for each key.\n\n-   **Systematic Iteration**: We first obtain a sorted list of all keys present in the constructed AVL tree. An in-order traversal of a BST (and thus an AVL tree) naturally yields the keys in ascending order. We then iterate through these keys. The first key that satisfies the condition will be the smallest one, fulfilling the problem's requirement.\n\n-   **Deletion Simulation**: For each key $x$ to be tested:\n    1.  **Create a Copy**: To avoid altering the original tree, which is needed for subsequent tests, we create a deep copy of the entire tree structure.\n    2.  **Perform BST Deletion**: On this copy, we execute the BST deletion algorithm as specified in the problem statement, but crucially, *without* the rebalancing (rotation) step. The algorithm is as follows:\n        -   If the node to be deleted has **no children**, it is simply removed.\n        -   If it has **one child**, the node is replaced by its child.\n        -   If it has **two children**, its key is replaced by the key of its in-order successor (the smallest key in its right subtree). Then, the successor node is recursively deleted from the right subtree.\n    3.  **Update Heights**: During the recursive deletion process, the heights of all nodes on the path from the deleted node back to the root are updated.\n\n-   **Validation Check**: After the structural change from the deletion and the subsequent height updates, we must verify if the resulting tree remains a valid AVL tree.\n    1.  **Traverse the Tree**: We perform a full traversal (e.g., pre-order or post-order) of the modified tree copy.\n    2.  **Check Balance Factors**: For each node $v$ in the tree, we compute its balance factor $\\beta(v) = h(v_{\\text{left}}) - h(v_{\\text{right}})$.\n    3.  **Condition Check**: If we find any node where $|\\beta(v)| > 1$, it means that rotations would have been necessary to restore balance. Therefore, the deletion of key $x$ is not a valid solution.\n    4.  **Successful Candidate**: If the traversal completes and all nodes satisfy $|\\beta(v)| \\leq 1$, then deleting key $x$ does not require any rotations. It is a valid candidate.\n\n**3. Determining the Final Answer**\n-   For each test case, we iterate through the sorted keys. The first key found to be a valid candidate is, by definition, the smallest such key. We record this key as the result for the case and proceed to the next test case.\n-   If we iterate through all keys in the tree and none of them result in a balanced tree upon deletion, it means no such key exists. In this situation, the answer for the test case is $-1$.\n\nThis comprehensive procedure of construction, simulation, and validation is applied to each of the five test cases to generate the final list of results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport copy\nimport sys\n\n# Increase recursion limit for deep trees during validation.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"A node in the AVL tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 0  # A new node is a leaf, with edge-based height 0.\n\nclass AVLTree:\n    \"\"\"AVL tree implementation with methods for insertion, deletion, and validation.\"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def _height(self, node):\n        return node.height if node else -1 # Edge-based height of an empty subtree is -1.\n\n    def _get_balance(self, node):\n        if not node:\n            return 0\n        return self._height(node.left) - self._height(node.right)\n\n    def _right_rotate(self, z):\n        y = z.left\n        T3 = y.right\n        y.right = z\n        z.left = T3\n        z.height = 1 + max(self._height(z.left), self._height(z.right))\n        y.height = 1 + max(self._height(y.left), self._height(y.right))\n        return y\n\n    def _left_rotate(self, y):\n        z = y.right\n        T2 = z.left\n        z.left = y\n        y.right = T2\n        y.height = 1 + max(self._height(y.left), self._height(y.right))\n        z.height = 1 + max(self._height(z.left), self._height(z.right))\n        return z\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n\n    def _insert(self, root, key):\n        if not root:\n            return Node(key)\n        elif key  root.key:\n            root.left = self._insert(root.left, key)\n        else:\n            root.right = self._insert(root.right, key)\n\n        root.height = 1 + max(self._height(root.left), self._height(root.right))\n        balance = self._get_balance(root)\n\n        # Rebalance if necessary\n        # Case 1: Left Left\n        if balance > 1 and key  root.left.key:\n            return self._right_rotate(root)\n        # Case 2: Right Right\n        if balance  -1 and key > root.right.key:\n            return self._left_rotate(root)\n        # Case 3: Left Right\n        if balance > 1 and key > root.left.key:\n            root.left = self._left_rotate(root.left)\n            return self._right_rotate(root)\n        # Case 4: Right Left\n        if balance  -1 and key  root.right.key:\n            root.right = self._right_rotate(root.right)\n            return self._left_rotate(root)\n        \n        return root\n\n    def _get_min_value_node(self, root):\n        current = root\n        while current.left is not None:\n            current = current.left\n        return current\n\n    def bst_delete(self, key):\n        \"\"\"Performs BST deletion without rebalancing, only height updates.\"\"\"\n        self.root = self._bst_delete(self.root, key)\n    \n    def _bst_delete(self, root, key):\n        if not root:\n            return root\n\n        if key  root.key:\n            root.left = self._bst_delete(root.left, key)\n        elif key > root.key:\n            root.right = self._bst_delete(root.right, key)\n        else: # Node to be deleted is found\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n            \n            # Node with two children\n            temp = self._get_min_value_node(root.right)\n            root.key = temp.key\n            root.right = self._bst_delete(root.right, temp.key)\n\n        if not root: # In case the tree becomes empty\n            return root\n\n        root.height = 1 + max(self._height(root.left), self._height(root.right))\n        return root\n\n    def is_balanced(self):\n        \"\"\"Checks if the entire tree satisfies the AVL property.\"\"\"\n        return self._is_balanced_recursive(self.root)\n\n    def _is_balanced_recursive(self, root):\n        if not root:\n            return True\n        \n        balance = self._get_balance(root)\n        if abs(balance) > 1:\n            return False\n            \n        return self._is_balanced_recursive(root.left) and \\\n               self._is_balanced_recursive(root.right)\n\n    def get_all_keys(self):\n        \"\"\"Returns a sorted list of all keys in the tree.\"\"\"\n        keys = []\n        self._inorder_traversal(self.root, keys)\n        return keys\n\n    def _inorder_traversal(self, root, keys_list):\n        if root:\n            self._inorder_traversal(root.left, keys_list)\n            keys_list.append(root.key)\n            self._inorder_traversal(root.right, keys_list)\n            \ndef solve():\n    \"\"\"Main function to solve the problem for all test cases.\"\"\"\n    test_cases = [\n        [10, 5, 15, 3, 7, 13, 17],\n        [8, 4, 12, 2, 6, 10, 14, 1, 3],\n        [50, 25, 75, 10, 37, 62, 87, 5, 12, 31, 43, 57, 68, 81, 93],\n        [30, 20, 40, 10, 25, 35, 50, 27, 26],\n        [1, 2, 3, 4, 5, 6]\n    ]\n\n    final_results = []\n    for insertion_sequence in test_cases:\n        # 1. Build the initial AVL tree for the current case.\n        avl_tree = AVLTree()\n        for key in insertion_sequence:\n            avl_tree.insert(key)\n        \n        # 2. Get a sorted list of all keys in the tree.\n        all_keys = avl_tree.get_all_keys()\n        \n        # 3. Find the smallest key whose deletion doesn't require rotation.\n        result_for_case = -1\n        for key_to_delete in all_keys:\n            # a. Create a deep copy to simulate deletion on.\n            tree_copy = copy.deepcopy(avl_tree)\n            \n            # b. Perform standard BST deletion (without rebalancing).\n            tree_copy.bst_delete(key_to_delete)\n            \n            # c. Check if the resulting tree is still balanced.\n            if tree_copy.is_balanced():\n                result_for_case = key_to_delete\n                break  # Found the smallest key, move to the next test case.\n        \n        final_results.append(result_for_case)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "3211065"}, {"introduction": "The efficiency of an AVL tree stems from its ability to localize the effects of an update. This advanced problem has you investigate the propagation of balance factor updates, a crucial aspect of the tree's performance. You will determine which insertion maximizes the number of ancestor nodes that need updating, thereby probing the limits of the update mechanism and its termination conditions [@problem_id:3211032].", "problem": "You are given the definition of an Adelson-Velsky and Landis (AVL) tree, which is a type of Binary Search Tree (BST) that maintains a height-balance invariant by ensuring that for every node, the difference between the heights of its left and right subtrees (called the balance factor) is in $\\{-1,0,+1\\}$. For a node $v$, the balance factor is $bf(v) = h(\\text{left}(v)) - h(\\text{right}(v))$, where $h(\\cdot)$ denotes subtree height measured in edges. Insertion into an AVL tree proceeds by placing the new key as in a BST and then updating balance factors on the path back to the root. When a node $z$ on this path attains $bf(z) = +2$ or $bf(z) = -2$, a rotation (single or double) is performed to restore the invariant. During the upward update phase, two termination conditions are standard: (i) if at some node $u$, the balance factor changes from $\\pm 1$ to $0$, then the height of $u$ does not increase and no further ancestors are affected; (ii) if a rotation occurs at some node $z$, the height of the subtree rooted at $z$ after rebalancing equals its height before the insertion, so no further ancestors are affected.\n\nDefine the following objective precisely. Let $T$ be a valid AVL tree. For a key $k$ that is not already in $T$, consider the AVL insertion of $k$ into $T$ with the conventional rotation and stopping rules described above. Define the propagation count $P_T(k)$ to be the number of distinct nodes on the search path from the insertion position up to and including the first ancestor at which the algorithm terminates (either because the balance factor hits $\\pm 2$ and triggers a rotation or because the balance factor becomes $0$), for which the algorithm computes and assigns a new balance factor value during the upward update phase. Equivalently, $P_T(k)$ counts how many ancestor nodes receive a balance factor update before the update propagation stops.\n\nObservations from fundamental definitions:\n- The BST property determines the insertion path uniquely based on comparisons of $k$ with existing keys.\n- Balance factor updates follow from subtree height changes; a change from $0$ to $\\pm 1$ signifies a height increase, a change from $\\pm 1$ to $0$ halts propagation, and a change reaching $\\pm 2$ triggers a rotation that halts propagation.\n- Any key $k$ falling within an interval between two consecutive in-order keys of $T$ produces the same insertion path and the same propagation behavior; therefore, it suffices to choose one canonical representative from each such interval, together with representatives for the two unbounded intervals below the minimum and above the maximum.\n\nYour task is to write a complete, runnable program that, for each provided test case, constructs the initial AVL tree by inserting a given sequence of integer keys into an empty tree (in the order provided), then evaluates $P_T(k)$ for a canonical finite set of candidate keys $k$ defined as follows. Let the sorted in-order keys of $T$ be $a_0  a_1  \\cdots  a_{n-1}$. The candidate set $C(T)$ must include:\n- $a_0 - 1$,\n- $a_{n-1} + 1$,\n- and for each $i \\in \\{0,1,\\dots,n-2\\}$ with $a_{i+1} - a_i \\ge 2$, the integer midpoint $\\left\\lfloor \\dfrac{a_i + a_{i+1}}{2} \\right\\rfloor$.\nAny candidate equal to an existing key must be discarded. For each $k \\in C(T)$, compute $P_T(k)$ by simulating the AVL insertion of $k$ into a fresh copy of $T$ that has been rebuilt from the given sequence. For each test case, select a key $k^\\star \\in C(T)$ that maximizes $P_T(k)$; in case of ties, choose the smallest such $k^\\star$. The required output for each test case is the pair $[k^\\star,P_T(k^\\star)]$.\n\nThe final output format must be a single line containing a comma-separated list of these pairs for all test cases, enclosed in square brackets, that is, an outer list whose elements are inner lists of two integers. For example, the format must be like $[[x_1,y_1],[x_2,y_2],\\dots]$ with no spaces and no additional text.\n\nThere are no physical units, angle units, or percentages in this problem. All values are integers.\n\nTest Suite:\n- Case $1$ (general balanced case): Insert, in order, the keys $[30,20,40,10,25,35,50]$.\n- Case $2$ (boundary minimal tree): Insert, in order, the keys $[100]$.\n- Case $3$ (left-deep bias): Insert, in order, the keys $[50,30,70,20,40,60,80,10]$.\n- Case $4$ (mixed depths): Insert, in order, the keys $[15,5,25,2,7,20,30,1,3,6,8]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in the same order as above, and has the pair format $[k^\\star,P_T(k^\\star)]$.", "solution": "The problem is well-defined, scientifically grounded in the principles of data structures, and contains all necessary information for a deterministic solution. It is therefore deemed valid.\n\nThe core of the problem is to determine, for a given Adelson-Velsky and Landis (AVL) tree $T$, which candidate key $k$ (not in $T$) leads to the longest chain of balance factor updates during the upward-tracing phase of an AVL insertion. This chain length is defined as the propagation count, $P_T(k)$.\n\nThe solution approach involves three main stages:\n1.  Constructing the initial AVL tree for each test case.\n2.  Generating the set of candidate keys $C(T)$.\n3.  Simulating the insertion of each candidate key to calculate its propagation count $P_T(k)$ and finding the key $k^\\star$ that maximizes this count.\n\n**1. AVL Tree Implementation**\n\nFirst, a standard AVL tree data structure is implemented. This involves a `Node` class to store a key, pointers to left and right children, and the height of the subtree rooted at the node. The height of a leaf is defined as $0$, and the height of a null subtree is $-1$.\n\nThe `AVLTree` class encapsulates the root of the tree and provides an `insert` method. The insertion follows the standard AVL algorithm:\n- A new key is inserted as in a regular Binary Search Tree (BST).\n- The algorithm then traverses the path from the new node's parent up to the root, updating the `height` and balance factor of each node. The balance factor of a node $v$ is given by $bf(v) = h(\\text{left}(v)) - h(\\text{right}(v))$, where $h(\\cdot)$ is the subtree height.\n- If a node's balance factor becomes $\\pm 2$, a rotation (single or double) is performed to restore the AVL property. The types of rotations (Left-Left, Right-Right, Left-Right, Right-Left) are determined by the balance factor of the unbalanced node and its relevant child.\n\nA helper function `inorder_keys` is also implemented to retrieve the keys of the constructed tree in sorted order, which is necessary for the next stage.\n\n**2. Candidate Set Generation**\n\nFor a given AVL tree $T$ with its keys sorted in-order as $a_0  a_1  \\dots  a_{n-1}$, the set of candidate keys $C(T)$ is constructed according to the problem's definition:\n- The key $a_0 - 1$, representing insertions smaller than any existing key.\n- The key $a_{n-1} + 1$, representing insertions larger than any existing key.\n- For each pair of consecutive keys $(a_i, a_{i+1})$ where the gap $a_{i+1} - a_i \\ge 2$, the integer midpoint $\\lfloor \\frac{a_i + a_{i+1}}{2} \\rfloor$ is included. This key represents insertions that fall between $a_i$ and $a_{i+1}$.\n\nThese candidates represent all topologically distinct insertion paths for keys not already in the tree.\n\n**3. Propagation Count Calculation and Maximization**\n\nThe central task is to compute the propagation count $P_T(k)$ for each $k \\in C(T)$. This is done by a simulation function, `calculate_propagation_count`, which does not modify the original tree $T$. The logic is as follows:\n\n1.  **Find Insertion Path**: A standard BST search for the key $k$ is performed on $T$ to identify the path from the root to the position where $k$ would be inserted. The nodes on this path are stored.\n\n2.  **Upward Traversal and Counting**: The algorithm then simulates the upward update phase, starting from the parent of the prospective new node and moving towards the root along the stored path.\n    - A counter, `propagation_count`, is initialized to $0$.\n    - For each node $u$ on the upward path:\n        a. The `propagation_count` is incremented, as the algorithm must compute a new balance factor for $u$.\n        b. The current balance factor of $u$, $bf_{old}(u)$, is retrieved from the original tree structure.\n        c. A hypothetical new balance factor, $bf_{new}(u)$, is calculated. If the insertion occurred in the left subtree of $u$, its height increases, so $bf_{new}(u) = bf_{old}(u) + 1$. If in the right subtree, $bf_{new}(u) = bf_{old}(u) - 1$.\n        d. The algorithm checks for the two termination conditions described in the problem:\n            i. **Balance Factor becomes 0**: If $bf_{new}(u) = 0$, it implies that $bf_{old}(u)$ must have been $\\pm 1$. In this case, the shorter subtree has grown to match the height of the taller one. The overall height of the subtree rooted at $u$ does not change, so propagation to ancestors ceases. The simulation loop terminates.\n            ii. **Rotation Triggered**: If $|bf_{new}(u)| = 2$, the node $u$ has become unbalanced. A rotation would be performed. An essential property of AVL rotations is that the height of the rebalanced subtree (rooted at the node that replaces $u$) is the same as the height of the original subtree at $u$ before the insertion. Therefore, no further height updates are propagated to ancestors. The simulation loop terminates.\n\n3.  **Find Optimal Key**: For each test case, this simulation is run for every $k \\in C(T)$. The results $(k, P_T(k))$ are tracked. The final selection is the key $k^\\star$ that yields the maximum propagation count, with ties broken by choosing the smallest $k^\\star$.\n\nThis systematic process correctly models the behavior specified and allows for the determination of the required pair $[k^\\star, P_T(k^\\star)]$ for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"Node class for the AVL tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 0  # Height of a leaf node is 0. Height of a null subtree is -1.\n\nclass AVLTree:\n    \"\"\"AVL Tree implementation.\"\"\"\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"Public method to insert a key into the AVL tree.\"\"\"\n        self.root = self._insert(self.root, key)\n\n    def _get_height(self, node):\n        \"\"\"Returns the height of a node, or -1 for a null subtree.\"\"\"\n        return node.height if node else -1\n\n    def _update_height(self, node):\n        \"\"\"Updates the height of a node based on its children's heights.\"\"\"\n        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))\n\n    def get_balance(self, node):\n        \"\"\"Calculates the balance factor of a node.\"\"\"\n        return self._get_height(node.left) - self._get_height(node.right) if node else 0\n\n    def _rotate_right(self, y):\n        \"\"\"Performs a right rotation on subtree rooted at y.\"\"\"\n        x = y.left\n        T2 = x.right\n        x.right = y\n        y.left = T2\n        self._update_height(y)\n        self._update_height(x)\n        return x\n\n    def _rotate_left(self, x):\n        \"\"\"Performs a left rotation on subtree rooted at x.\"\"\"\n        y = x.right\n        T2 = y.left\n        y.left = x\n        x.right = T2\n        self._update_height(x)\n        self._update_height(y)\n        return y\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper function for insertion and rebalancing.\"\"\"\n        if not node:\n            return Node(key)\n        \n        if key  node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n            node.right = self._insert(node.right, key)\n        else:\n            return node  # Duplicate keys are not inserted\n\n        self._update_height(node)\n        balance = self.get_balance(node)\n\n        # Rebalancing cases\n        # Left-Left case\n        if balance > 1 and key  node.left.key:\n            return self._rotate_right(node)\n        # Right-Right case\n        if balance  -1 and key > node.right.key:\n            return self._rotate_left(node)\n        # Left-Right case\n        if balance > 1 and key > node.left.key:\n            node.left = self._rotate_left(node.left)\n            return self._rotate_right(node)\n        # Right-Left case\n        if balance  -1 and key  node.right.key:\n            node.right = self._rotate_right(node.right)\n            return self._rotate_left(node)\n        \n        return node\n\n    def inorder_keys(self):\n        \"\"\"Returns a list of keys in sorted order.\"\"\"\n        keys = []\n        self._inorder_traversal(self.root, keys)\n        return keys\n\n    def _inorder_traversal(self, node, keys):\n        if not node:\n            return\n        self._inorder_traversal(node.left, keys)\n        keys.append(node.key)\n        self._inorder_traversal(node.right, keys)\n\ndef calculate_propagation_count(tree, k):\n    \"\"\"\n    Simulates an AVL insertion of key k into tree T and returns the propagation count P_T(k).\n    \"\"\"\n    if not tree.root:\n        return 0\n    \n    path = []\n    node = tree.root\n    while node:\n        path.append(node)\n        if k  node.key:\n            node = node.left\n        else:\n            node = node.right\n\n    propagation_count = 0\n    child_key = k\n\n    # Traverse path upwards from the would-be parent of the new node\n    for i in range(len(path) - 1, -1, -1):\n        u = path[i]\n        propagation_count += 1\n        \n        bf_old = tree.get_balance(u)\n        \n        # Determine which subtree of u grew\n        if child_key  u.key:  # Left subtree grew\n            bf_new = bf_old + 1\n        else:  # Right subtree grew\n            bf_new = bf_old - 1\n\n        # Check for termination conditions\n        if bf_new == 0:  # bf changed from ±1 to 0; height of subtree at u doesn't change\n            break\n        if abs(bf_new) == 2:  # Rotation triggered; height of rebalanced subtree is same as original\n            break\n        \n        # For the next iteration, the 'child' is the current node u from the perspective of its parent\n        child_key = u.key\n    \n    return propagation_count\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        [30, 20, 40, 10, 25, 35, 50],\n        [100],\n        [50, 30, 70, 20, 40, 60, 80, 10],\n        [15, 5, 25, 2, 7, 20, 30, 1, 3, 6, 8],\n    ]\n\n    final_results = []\n    for keys in test_cases:\n        tree = AVLTree()\n        for key in keys:\n            tree.insert(key)\n        \n        sorted_keys = tree.inorder_keys()\n        \n        candidates = set()\n        if sorted_keys:\n            candidates.add(sorted_keys[0] - 1)\n            candidates.add(sorted_keys[-1] + 1)\n            for i in range(len(sorted_keys) - 1):\n                if sorted_keys[i+1] - sorted_keys[i] >= 2:\n                    candidates.add((sorted_keys[i] + sorted_keys[i+1]) // 2)\n\n        existing_keys = set(sorted_keys)\n        valid_candidates = sorted(list(candidates - existing_keys))\n\n        max_p = -1\n        best_k = -1\n\n        for k in valid_candidates:\n            p_k = calculate_propagation_count(tree, k)\n            if p_k > max_p:\n                max_p = p_k\n                best_k = k\n        \n        final_results.append([best_k, max_p])\n\n    # Format the output as specified: [[k1,p1],[k2,p2],...] with no spaces\n    print(f\"[{','.join([f'[{r[0]},{r[1]}]' for r in final_results])}]\")\n\nsolve()\n```", "id": "3211032"}]}