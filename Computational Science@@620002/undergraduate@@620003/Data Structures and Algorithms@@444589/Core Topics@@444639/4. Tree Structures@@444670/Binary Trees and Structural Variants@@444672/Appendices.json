{"hands_on_practices": [{"introduction": "This first exercise focuses on a fundamental property of any binary tree: its structure. We will explore the concept of symmetry, where a tree is a mirror image of itself around its central axis. This practice is an excellent way to develop your recursive thinking, as the solution elegantly lies in defining a helper function that determines if two subtrees are mirror images of each other. [@problem_id:3216104]", "problem": "You are tasked with designing and implementing a program that decides whether a given binary tree is symmetric around its root, using fundamental definitions and first principles from data structures. Begin from the recursive definition of a binary tree: a binary tree is either empty or consists of a node with a left child and a right child, each of which is a binary tree. Let a tree be denoted by $T$, its root by $r$, and its left and right subtrees by $T_{\\text{L}}$ and $T_{\\text{R}}$, respectively.\n\nDefine a path from the root to any node by a finite sequence over the alphabet $\\{\\text{L}, \\text{R}\\}$. For any path $p \\in \\{\\text{L}, \\text{R}\\}^{\\ast}$, define the mirror of the path by a function $\\phi$ such that $\\phi(\\text{L}) = \\text{R}$ and $\\phi(\\text{R}) = \\text{L}$, extended homomorphically to strings so that $\\phi(p_{1}p_{2}\\cdots p_{k}) = \\phi(p_{1})\\phi(p_{2})\\cdots\\phi(p_{k})$ for any $k \\in \\mathbb{N}$. A binary tree $T$ with root $r$ is symmetric around its root if and only if, for every path $p$ leading to a node $u$ in $T_{\\text{L}}$, there exists a node $v$ in $T_{\\text{R}}$ at path $\\phi(p)$ such that the value stored at $u$ equals the value stored at $v$, and conversely, and all such correspondences hold at every depth. If either side lacks a node where the other side has one, the tree is not symmetric.\n\nThe input to the algorithm is a sequence encoding the tree in level-order (breadth-first) as a list. For an index $i$, the left child is at index $2i+1$ and the right child is at index $2i+2$, provided these indices exist and the parent is not absent. Use `\\texttt{None}` to represent the absence of a node. For example, the list $\\left[\\,1,2,2,3,4,4,3\\,\\right]$ encodes a perfectly symmetric tree of height $3$. The list $\\left[\\,1,2,2,\\texttt{None},3,\\texttt{None},3\\,\\right]$ encodes a tree that is not symmetric because the mirror positions do not both exist or do not match in value.\n\nYour task is to:\n- Implement a procedure that, given such a level-order list, constructs the corresponding binary tree respecting the absence markers `\\texttt{None}`, and then decides whether the tree is symmetric around its root based on the above definition.\n- The decision must be grounded in the recursive structure of binary trees and the mirror path mapping $\\phi$; no shortcuts or prepackaged symmetry checks are permitted.\n\nYour program should evaluate the following test suite. Each test case is a level-order list using `\\texttt{None}` for absent nodes:\n- Test $1$: $\\left[\\,\\,\\right]$ (the empty tree).\n- Test $2$: $\\left[\\,1\\,\\right]$.\n- Test $3$: $\\left[\\,1,2,2,3,4,4,3\\,\\right]$.\n- Test $4$: $\\left[\\,1,2,2,\\texttt{None},3,\\texttt{None},3\\,\\right]$.\n- Test $5$: $\\left[\\,1,2,2,3,\\texttt{None},\\texttt{None},4\\,\\right]$.\n- Test $6$: $\\left[\\,1,2,2,3,4,4,3,\\texttt{None},\\texttt{None},5,6,6,5,\\texttt{None},\\texttt{None}\\,\\right]$.\n- Test $7$: $\\left[\\,1,\\texttt{None},2\\,\\right]$.\n\nFor each test case, the required output is a boolean value indicating whether the tree is symmetric around its root. Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, for example, `[\\,\\texttt{True},\\texttt{False}\\,]`. The final output must have no spaces, exactly in the form: \"[result1,result2,...]\".", "solution": "The problem statement is assessed to be valid. It is a well-posed, scientifically grounded problem within the domain of data structures and algorithms, containing all necessary information and definitions for a unique solution.\n\nThe task is to determine if a binary tree, provided in a level-order list format, is symmetric around its root. The solution logically decomposes into two principal stages: first, the reconstruction of the tree data structure from its list representation, and second, the verification of its symmetry according to the provided recursive and path-based definition.\n\nFirst, we address the construction of the binary tree from a level-order list. A binary tree node is a fundamental structure containing a value and pointers to its left and right children, which are themselves binary trees. We can define a `TreeNode` class for this purpose. The input list represents the tree in a breadth-first manner, where for a parent node at index $i$, its left child is at index $2i+1$ and its right child is at index $2i+2$. The value `\\texttt{None}` signifies an absent node.\n\nThe construction algorithm proceeds as follows:\n$1$. If the input list is empty, the tree is empty, and we return `\\texttt{None}`.\n$2$. Otherwise, the element at index $0$ is the root of the tree. A `TreeNode` is created for it.\n$3$. A queue is initialized and the root node is added to it. This queue will hold parent nodes whose children need to be assigned.\n$4. A counter, say $j$, is initialized to $1$ to traverse the input list for child values.\n$5$. While the queue is not empty and the index $j$ is within the bounds of the list, we dequeue a parent node.\n$6$. The value at index $j$ corresponds to the left child. If this value is not `\\texttt{None}`, a new `TreeNode` is created and assigned as the parent's left child, and this new node is enqueued. The index $j$ is incremented.\n$7$. The value at the new index $j$ corresponds to the right child. If this value is not `\\texttt{None}`, a new `TreeNode` is created, assigned as the parent's right child, and enqueued. The index $j$ is again incremented.\n$8$. This process continues until all nodes in the list have been processed, correctly reconstructing the tree structure.\n\nSecond, we address the verification of symmetry. The problem defines a tree $T$ with root $r$ as symmetric if for every path $p$ in its left subtree $T_{\\text{L}}$, a node with an equal value exists at the mirrored path $\\phi(p)$ in the right subtree $T_{\\text{R}}$, and vice-versa. The mirror function $\\phi$ swaps $\\text{L}$ and $\\text{R}$ in the path sequence.\n\nThis formal definition lends itself to an elegant recursive solution. A tree is symmetric if and only if its left and right subtrees are mirror images of each other. We can define a recursive helper function, let's call it `areMirrors(node1, node2)`, that determines if two trees rooted at `node1` and `node2` are mirror images. This function is defined by the following conditions:\n\n$1$. **Base Case 1**: If both `node1` and `node2` are empty (i.e., `\\texttt{None}`), they are vacuously mirror images of each other. The function returns `True`. This corresponds to the case where paths terminate in both subtrees simultaneously.\n$2$. **Base Case 2**: If exactly one of `node1` or `node2` is empty while the other is not, they cannot be mirror images. The function returns `False`. This corresponds to the condition that if a node exists at a given path on one side, its counterpart must exist on the mirrored path on the other side.\n$3$. **Recursive Step**: If neither node is empty, they are mirror images if and only if three conditions are met:\n    a. Their root values must be equal: `node1.value == node2.value`.\n    b. The left subtree of `node1` must be a mirror image of the right subtree of `node2`. This is checked by the recursive call `areMirrors(node1.left, node2.right)`.\n    c. The right subtree of `node1` must be a mirror image of the left subtree of `node2`. This is checked by the recursive call `areMirrors(node1.right, node2.left)`.\n\nThis recursive structure directly implements the path-mapping requirement. The initial call `areMirrors(root.left, root.right)` compares the path $\\text{L}$ from the root to the path $\\phi(\\text{L}) = \\text{R}$. A subsequent recursive call, such as `areMirrors(node1.left, node2.right)`, effectively compares a path like $\\text{L}p$ (a path starting with $\\text{L}$) in the original tree's left subtree to a path $\\text{R}\\phi(p)$ (a path starting with $\\text{R}$ and followed by the mirror of $p$) in the original tree's right subtree, ensuring the structural and value-based correspondence at every level. The main function, `isSymmetric(root)`, simply handles the case of an empty tree (which is symmetric) and otherwise initiates the recursive check on its two main subtrees via `areMirrors(root.left, root.right)`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass TreeNode:\n    \"\"\"\n    Represents a node in a binary tree.\n    \"\"\"\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(level_order_list):\n    \"\"\"\n    Constructs a binary tree from a level-order list representation.\n    None indicates an absent node.\n    \"\"\"\n    if not level_order_list:\n        return None\n\n    root = TreeNode(level_order_list[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(level_order_list):\n        current_node = queue.pop(0)\n\n        if i < len(level_order_list) and level_order_list[i] is not None:\n            current_node.left = TreeNode(level_order_list[i])\n            queue.append(current_node.left)\n        i += 1\n\n        if i < len(level_order_list) and level_order_list[i] is not None:\n            current_node.right = TreeNode(level_order_list[i])\n            queue.append(current_node.right)\n        i += 1\n\n    return root\n\ndef are_mirrors(node1, node2):\n    \"\"\"\n    Recursively checks if two trees are mirror images of each other.\n    \"\"\"\n    # Base case: both are null, they are mirrors.\n    if not node1 and not node2:\n        return True\n    \n    # Base case: one is null but the other isn't, not mirrors.\n    if not node1 or not node2:\n        return False\n    \n    # Recursive step: check values and mirrored subtrees.\n    return (node1.val == node2.val and\n            are_mirrors(node1.left, node2.right) and\n            are_mirrors(node1.right, node2.left))\n\ndef is_symmetric(root):\n    \"\"\"\n    Determines if a binary tree is symmetric around its root.\n    \"\"\"\n    # An empty tree is symmetric.\n    if not root:\n        return True\n    # A tree is symmetric if its left and right subtrees are mirror images.\n    return are_mirrors(root.left, root.right)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],\n        [1],\n        [1, 2, 2, 3, 4, 4, 3],\n        [1, 2, 2, None, 3, None, 3],\n        [1, 2, 2, 3, None, None, 4],\n        [1, 2, 2, 3, 4, 4, 3, None, None, 5, 6, 6, 5, None, None],\n        [1, None, 2]\n    ]\n\n    results = []\n    for case in test_cases:\n        # Build the tree from the list representation.\n        root = build_tree(case)\n        # Check for symmetry and store the boolean result.\n        result = is_symmetric(root)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3216104"}, {"introduction": "Moving from general binary trees to their specialized variant, the Binary Search Tree (BST), we can unlock significant algorithmic efficiencies. This practice challenges you to find the Lowest Common Ancestor (LCA) of two nodes, but by leveraging the unique ordering property of a BST. You will discover how this property allows for a remarkably simple and efficient iterative solution, demonstrating how a data structure's invariants can be exploited for elegant problem-solving. [@problem_id:3216153]", "problem": "You are given the task of computing the Lowest Common Ancestor (LCA) of two nodes in a Binary Search Tree (BST) under a strict additional space constraint. Begin from the fundamental definitions: a Binary Search Tree (BST) is a rooted binary tree in which every node with key $k$ has all keys in its left subtree strictly less than $k$ and all keys in its right subtree strictly greater than $k$. For nodes $u$ and $v$ in a rooted tree, a node $w$ is an ancestor of $u$ if $w$ lies on the unique simple path from the root to $u$. The Lowest Common Ancestor (LCA) of $u$ and $v$ is the unique node $w$ that is an ancestor of both $u$ and $v$ and has no descendant that is also a common ancestor of $u$ and $v$.\n\nYour task is to implement an algorithm that, given a BST and two target keys $p$ and $q$, returns the key of their LCA if both keys are present in the BST; otherwise, return $-1$. The algorithm used to determine the LCA must run using only $\\mathcal{O}(1)$ additional space, meaning it must not use recursion or any auxiliary data structures that scale with input size. The memory required to store the tree itself does not count toward this additional space constraint.\n\nConstruction of the BST: For each test case, the BST must be constructed by inserting distinct integer keys in the given order using the standard BST insertion rule: a key $x$ less than a node's key goes to the left child, and a key $x$ greater than a node's key goes to the right child.\n\nPresence requirement: If either of the keys $p$ or $q$ is not present in the BST, you must return $-1$ for that test case.\n\nReturn value: For each test case, return a single integer: the LCA key if both keys are present, or $-1$ otherwise.\n\nYou must implement a complete, runnable program that hardcodes the following test suite, constructs each BST as described, and computes the required result for each test case:\n- Test case $1$: insertion order $[20,10,30,5,15,25,35]$, query $(p,q)=(5,15)$.\n- Test case $2$: insertion order $[20,10,30,5,15,25,35]$, query $(p,q)=(5,35)$.\n- Test case $3$: insertion order $[20,10,30,5,15,25,35]$, query $(p,q)=(30,35)$.\n- Test case $4$: insertion order $[8,3,10,1,6,14,4,7,13]$, query $(p,q)=(2,7)$.\n- Test case $5$: insertion order $[1,2,3,4,5]$, query $(p,q)=(2,5)$.\n- Test case $6$: insertion order $[5,4,3,2,1]$, query $(p,q)=(1,3)$.\n- Test case $7$: insertion order $[42]$, query $(p,q)=(42,42)$.\n- Test case $8$: insertion order $[42]$, query $(p,q)=(42,7)$.\n- Test case $9$: insertion order $[10,5,15]$, query $(p,q)=(100,200)$.\n\nComplexity target: The LCA computation for a tree with height $h$ should take $\\mathcal{O}(h)$ time and $\\mathcal{O}(1)$ additional space.\n\nFinal output format: Your program should produce a single line of output containing the results for the nine test cases as a comma-separated list enclosed in square brackets and with no spaces, for example, $[r_1,r_2,\\dots,r_9]$, where each $r_i$ is an integer as specified above.\n\nNo input is to be read. Your program must construct the exact test suite above and produce the corresponding outputs in the specified format.", "solution": "The problem requires us to find the Lowest Common Ancestor (LCA) of two nodes, identified by their keys $p$ and $q$, in a Binary Search Tree (BST). The solution is subject to a strict space complexity constraint of $\\mathcal{O}(1)$ for the LCA-finding part of the algorithm. Furthermore, the algorithm must first validate that both keys $p$ and $q$ are present in the tree; if either is missing, the designated return value is $-1$.\n\nThe solution is developed based on the fundamental properties of a BST and is structured into three logical stages for each test case: BST construction, node presence verification, and the LCA computation.\n\n**1. Binary Search Tree (BST) Construction**\n\nAs per the problem statement, for each test case, a BST is constructed by inserting a given sequence of distinct integer keys. A BST is a rooted binary tree where for any node with key $k$, all keys in its left subtree are strictly less than $k$, and all keys in its right subtree are strictly greater than $k$. An iterative insertion algorithm is used to build the tree. For each key to be inserted, we traverse the tree from the root, moving left if the key is smaller than the current node's key and right if it is larger, until an empty spot (a `None` child pointer) is found where the new node can be attached.\n\n**2. Node Presence Verification**\n\nA critical preliminary step is to confirm that both specified keys, $p$ and $q$, actually exist in the constructed BST. Without this check, the LCA algorithm might return a \"split point\" node for two keys that are not even in the tree, leading to an incorrect result. To adhere to the space complexity constraints and maintain consistency, we employ an iterative search algorithm. Starting from the root, we traverse the tree following the BST property. If the target key is found, the search succeeds. If a `None` pointer is reached, the key is not in the tree. This search is performed for both $p$ and $q$. If either search fails, the process terminates for that test case, and the value $-1$ is returned as required. This check takes $\\mathcal{O}(h)$ time and $\\mathcal{O}(1)$ additional space for each key, where $h$ is the height of the tree.\n\n**3. Lowest Common Ancestor (LCA) Computation**\n\nIf both keys $p$ and $q$ are confirmed to be present, we proceed to find their LCA. The ordered nature of the BST allows for a highly efficient, iterative algorithm that satisfies the $\\mathcal{O}(1)$ additional space constraint. The logic hinges on identifying the node at which the paths to $p$ and $q$ from the root diverge. This divergence point is, by definition, the LCA.\n\nLet the current node being examined be `current`, initially set to the root of the tree. Let its key be $c$. The iterative process is as follows:\n\n- **Case 1: Both keys are greater than the current node's key.** If $p > c$ and $q > c$, it implies that both target nodes must reside in the right subtree of the `current` node. Consequently, their LCA must also be in the right subtree. The search is narrowed by updating the `current` pointer to its right child: `current = current.right`.\n\n- **Case 2: Both keys are less than the current node's key.** If $p < c$ and $q < c$, both target nodes are in the left subtree. Their LCA must also be in the left subtree. The search continues from the left child: `current = current.left`.\n\n- **Case 3: The keys split at the current node.** If neither of the above conditions is met, it means that the `current` node is the first node on the path from the root that lies between $p$ and $q$ (inclusive). This can happen in three ways:\n    - $p < c$ and $q > c$ (or vice versa), meaning the paths to $p$ and $q$ diverge at `current`.\n    - $c = p$, meaning the `current` node is one of the target nodes. Since $q$ is present in the tree, it must be in a subtree of `current` (or $q=p$), making `current` the LCA.\n    - $c = q$, which is analogous to the previous sub-case.\n\nIn all variations of Case $3$, the `current` node is the LCA. The loop terminates, and the key $c$ of the `current` node is returned.\n\nThis algorithm traverses a single path from the root downwards. The length of this path is bounded by the tree's height $h$, resulting in a time complexity of $\\mathcal{O}(h)$. Since the algorithm only requires a single pointer (`current`) to traverse the tree, its additional space complexity is $\\mathcal{O}(1)$, fully satisfying the problem's constraints.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LCA in a BST problem for a hardcoded suite of test cases.\n    The solution follows these steps for each case:\n    1. Constructs the BST from a list of keys.\n    2. Verifies that both query keys, p and q, exist in the tree.\n    3. If they exist, it computes their LCA using an O(1) space iterative algorithm.\n    4. If either key is missing, it returns -1.\n    5. Collects all results and prints them in the specified format.\n    \"\"\"\n\n    class Node:\n        \"\"\"Represents a node in a Binary Search Tree.\"\"\"\n        def __init__(self, key):\n            self.key = int(key)\n            self.left = None\n            self.right = None\n\n    def build_bst(keys):\n        \"\"\"Constructs a BST by iteratively inserting keys.\"\"\"\n        if not keys:\n            return None\n        \n        root = Node(keys[0])\n        for key in keys[1:]:\n            current = root\n            while True:\n                if key < current.key:\n                    if current.left is None:\n                        current.left = Node(key)\n                        break\n                    else:\n                        current = current.left\n                elif key > current.key:\n                    if current.right is None:\n                        current.right = Node(key)\n                        break\n                    else:\n                        current = current.right\n        return root\n\n    def search_bst(root, key):\n        \"\"\"Iteratively searches for a key in the BST. O(1) space.\"\"\"\n        current = root\n        while current is not None:\n            if key == current.key:\n                return True\n            elif key < current.key:\n                current = current.left\n            else:\n                current = current.right\n        return False\n\n    def find_lca(root, p, q):\n        \"\"\"\n        Iteratively finds the LCA of two keys p and q in a BST. O(1) space.\n        This function assumes both p and q are present in the BST.\n        \"\"\"\n        current = root\n        while current is not None:\n            # If both p and q are greater than current node's key, LCA is in the right subtree\n            if p > current.key and q > current.key:\n                current = current.right\n            # If both p and q are smaller than current node's key, LCA is in the left subtree\n            elif p < current.key and q < current.key:\n                current = current.left\n            # Otherwise, this is the split point, so this node is the LCA.\n            # This covers cases where one key is on one side and the other is on the other,\n            # or when one of the keys is the current node.\n            else:\n                return current.key\n        return -1 # Should not be reached given presence check\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'keys': [20, 10, 30, 5, 15, 25, 35], 'pq': (5, 15)},\n        {'keys': [20, 10, 30, 5, 15, 25, 35], 'pq': (5, 35)},\n        {'keys': [20, 10, 30, 5, 15, 25, 35], 'pq': (30, 35)},\n        {'keys': [8, 3, 10, 1, 6, 14, 4, 7, 13], 'pq': (2, 7)},\n        {'keys': [1, 2, 3, 4, 5], 'pq': (2, 5)},\n        {'keys': [5, 4, 3, 2, 1], 'pq': (1, 3)},\n        {'keys': [42], 'pq': (42, 42)},\n        {'keys': [42], 'pq': (42, 7)},\n        {'keys': [10, 5, 15], 'pq': (100, 200)},\n    ]\n\n    results = []\n    for case in test_cases:\n        keys = case['keys']\n        p, q = case['pq']\n        \n        # 1. Construct the BST\n        root = build_bst(keys)\n        \n        # 2. Verify presence of both p and q\n        p_found = search_bst(root, p)\n        q_found = search_bst(root, q)\n        \n        if p_found and q_found:\n            # 3. If present, find the LCA\n            lca_key = find_lca(root, p, q)\n            results.append(lca_key)\n        else:\n            # 4. If either is not present, return -1\n            results.append(-1)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3216153"}, {"introduction": "This final practice synthesizes your knowledge of BSTs with classic algorithmic techniques under strict resource constraints. The task is to find two nodes that sum to a target value, a variation of the well-known \"two-sum\" problem. A naive approach would be to convert the BST to a sorted array, but this exercise challenges you to achieve a more efficient solution in terms of memory by simulating the classic two-pointer technique directly on the tree structure using concurrent iterators. [@problem_id:3216226]", "problem": "You are given a finite rooted Binary Search Tree (BST) storing integer keys, where Binary Search Tree (BST) means that for every node with key $k$ the keys in its left subtree are strictly less than $k$ and the keys in its right subtree are greater than or equal to $k$. Keys may include duplicates. Let $X$ be a target integer. The task is to design and implement a program that determines whether there exist two distinct nodes whose keys sum to $X$, and, if so, returns one such pair of keys. If multiple valid pairs exist, any one pair is acceptable. If no such pair exists, return an empty list.\n\nYour derivation and design must start from the fundamental base:\n- The Binary Search Tree (BST) ordering property defined above.\n- The well-tested fact that an in-order traversal of a Binary Search Tree (BST) yields a non-decreasing sequence of keys, and a reverse in-order traversal yields a non-increasing sequence of keys.\n\nConstraints for the algorithm:\n- The algorithm must run in $\\mathcal{O}(n)$ time on a tree with $n$ nodes.\n- The algorithm must use at most $\\mathcal{O}(h)$ additional memory, where $h$ is the height of the tree, and must not materialize the entire tree or its traversal into an array or list.\n- The two nodes used to form the sum must be distinct; the same node cannot be used twice to sum to $X$ (even if $2 \\cdot k = X$ for some key $k$).\n\nYour program should construct Binary Search Trees (BSTs) by inserting keys in the given order, with the insertion rule that a key equal to a node’s key is inserted to the right subtree. For each test case, return the result as either:\n- A list of two integers $[a,b]$ denoting the keys of a valid pair with $a + b = X$ and corresponding to two distinct nodes in the tree, or\n- An empty list $[]$ if no such pair exists.\n\nTest suite (each test case is a pair consisting of an insertion sequence and a target $X$):\n- Case $1$: insertion sequence $\\langle 8,3,10,1,6,14,4,7,13\\rangle$, target $X = 17$.\n- Case $2$: insertion sequence $\\langle -10,-3,0,5,9\\rangle$, target $X = -13$.\n- Case $3$: insertion sequence $\\langle 5,5,3,7\\rangle$ (duplicates present), target $X = 10$.\n- Case $4$: insertion sequence $\\langle 2,1,4\\rangle$, target $X = 8$.\n- Case $5$: insertion sequence $\\langle 42\\rangle$, target $X = 84$.\n- Case $6$: insertion sequence $\\langle 1,2,3,4,5\\rangle$ (degenerate right-leaning tree), target $X = 6$.\n- Case $7$: insertion sequence $\\langle 5,3,7\\rangle$, target $X = 10$ (tests prohibition against using the same node twice when only one instance of the key exists).\n\nFinal output format:\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. Each result must itself be a list in square brackets with no spaces. For example, a valid output for three test cases would look like $[[a,b],[],[c,d]]$. Your program must not read any input and must use the test suite above, in the order listed. All numeric values must be printed in base-$10$ digits with no additional spaces.", "solution": "The problem as stated is valid. It is a well-defined algorithmic challenge within the domain of data structures, resting on established principles of computer science. It is self-contained, unambiguous, and its constraints are stringent but solvable. We may therefore proceed with a formal derivation of the solution.\n\nThe problem asks for an algorithm to find if two distinct nodes in a given Binary Search Tree (BST) have keys that sum to a target value $X$. The algorithm must operate within $\\mathcal{O}(n)$ time and $\\mathcal{O}(h)$ auxiliary space, where $n$ is the number of nodes and $h$ is the height of the tree. The BST adheres to a specific insertion rule for duplicate keys: a key $k$ is inserted into the right subtree of a node with key $k'$, if $k \\geq k'$.\n\n**1. Foundational Principle: BST Traversal and Sorted Sequences**\n\nThe fundamental property upon which the solution is built is the relationship between a BST and sorted data. The problem statement correctly provides this basis:\n- An in-order traversal (left subtree, root, right subtree) of a BST yields the keys in a non-decreasingly sorted sequence.\n- A reverse in-order traversal (right subtree, root, left subtree) yields the keys in a non-increasingly sorted sequence.\n\nLet the sequence of keys from an in-order traversal be $S_{asc} = \\langle k_1, k_2, \\dots, k_n \\rangle$, where $k_i \\leq k_{i+1}$. Our task is equivalent to finding two indices $i$ and $j$ corresponding to two distinct nodes, such that $k_i + k_j = X$.\n\n**2. The Two-Pointer Method on a Sorted Array**\n\nIf we were permitted to use $\\mathcal{O}(n)$ space, a straightforward solution would be:\n1. Perform an in-order traversal of the BST and store all $n$ node keys in an array. This array would be sorted non-decreasingly.\n2. Use the \"two-pointer\" technique. Initialize a pointer `low` to the start of the array and a pointer `high` to the end.\n3. While `low` is less than `high`:\n    - Let the current sum be $S = \\text{array}[\\text{low}] + \\text{array}[\\text{high}]$.\n    - If $S = X$, a pair is found.\n    - If $S < X$, the sum is too small. To increase it, we must select a larger value, so we increment `low`.\n    - If $S > X$, the sum is too large. To decrease it, we must select a smaller value, so we decrement `high`.\n\nThis approach has a time complexity of $\\mathcal{O}(n)$ for the traversal and $\\mathcal{O}(n)$ for the two-pointer scan, resulting in a total of $\\mathcal{O}(n)$. However, it requires $\\mathcal{O}(n)$ space to store the array, which violates the $\\mathcal{O}(h)$ space constraint.\n\n**3. Derivation of an $\\mathcal{O}(h)$ Space Algorithm**\n\nTo meet the $\\mathcal{O}(h)$ space constraint, we must avoid materializing the entire sequence of keys. The core insight is to simulate the two-pointer approach directly on the BST structure. We need a mechanism to get the \"next\" smallest key and the \"next\" largest key on demand, without processing the entire tree at once.\n\nThis requirement leads to the design of two stateful iterators:\n- An **in-order iterator**, which, upon each request, yields the next node in the non-decreasing sequence of keys.\n- A **reverse in-order iterator**, which, upon each request, yields the next node in the non-increasing sequence of keys.\n\nAn iterative traversal of a BST can be implemented using a stack. For an in-order traversal, we repeatedly push left children onto the stack. When we need the next item, we pop a node, visit it, and then process its right subtree by pushing its left-child chain. The maximum depth of this stack corresponds to the longest path from the root to a leaf, which is the height $h$ of the tree. Therefore, a stack-based iterator uses $\\mathcal{O}(h)$ space. The same principle applies to a reverse in-order iterator, which would prioritize pushing right children.\n\nBy employing two such iterators concurrently, one for the ascending sequence and one for the descending sequence, we can perfectly simulate the two-pointer method while respecting the $\\mathcal{O}(h)$ space bound.\n\n**4. Algorithmic Design and Implementation**\n\nThe algorithm proceeds as follows:\n\n1.  **Node Representation**: Define a `TreeNode` class containing an integer key and references to left and right children. The identity of a `TreeNode` object will be used to satisfy the \"distinct nodes\" constraint.\n\n2.  **Iterator Implementation**:\n    - `InOrderIterator`:\n        - Maintains a stack.\n        - On initialization with the root, it traverses down the left spine of the tree, pushing each node onto the stack. This primes the iterator to return the node with the minimum key.\n        - A `next()` method pops a node from the stack (the next in-order node), and then prepares for the subsequent call by traversing the left spine of the popped node's right child.\n    - `ReverseInOrderIterator`:\n        - Operates symmetrically to the `InOrderIterator`.\n        - On initialization, it traverses down the right spine, pushing nodes to prepare for yielding the maximum key.\n        - Its `next()` method pops a node, and then prepares by traversing the right spine of the popped node's left child.\n\n3.  **Main Control Loop**:\n    - Initialize one instance of `InOrderIterator` and one of `ReverseInOrderIterator` with the root of the BST.\n    - Fetch the first node from each iterator: `node_asc` (smallest) and `node_desc` (largest).\n    - Enter a loop that continues as long as both iterators can provide nodes and the nodes they point to are not the same object (`node_asc is not node_desc`). This condition is critical for correctness, ensuring that we only consider pairs of distinct nodes.\n    - Inside the loop:\n        a. Calculate the sum of the keys: $S = \\text{node\\_asc.key} + \\text{node\\_desc.key}$.\n        b. If $S = X$, we have found a valid pair. Return their keys, e.g., $[\\text{node\\_asc.key}, \\text{node\\_desc.key}]$.\n        c. If $S < X$, we require a larger sum. We advance the in-order iterator to get the next-smallest key: `node_asc = iter_asc.next()`.\n        d. If $S > X$, we require a smaller sum. We advance the reverse in-order iterator to get the next-largest key: `node_desc = iter_desc.next()`.\n    - If the loop terminates without finding a pair (either because the iterators have crossed or met at the same node), no such pair exists. Return an empty list.\n\n**5. Complexity Analysis**\n\n- **Time Complexity**: Each iterator traverses the edges of the BST. In the main loop, at each step, exactly one of the two iterators is advanced. Since the iterators start at opposite ends of the sorted sequence and move towards each other, each node in the tree will be visited at most once by one of the advancing iterators. The work done inside the `next()` methods, when amortized over the entire traversal, is constant per node. Thus, the total time complexity is $\\mathcal{O}(n)$.\n\n- **Space Complexity**: The algorithm uses two stacks, one for each iterator. The maximum size of each stack is bounded by the height of the tree, $h$. Therefore, the total auxiliary space required is $\\mathcal{O}(h) + \\mathcal{O}(h) = \\mathcal{O}(h)$. In a balanced BST, $h = \\mathcal{O}(\\log n)$, and in a degenerate (skewed) tree, $h = \\mathcal{O}(n)$. The space complexity correctly adheres to the specified constraint.\n\nThis design fulfills all problem requirements, providing a solution that is both correct and efficient within the given constraints.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass TreeNode:\n    \"\"\"\n    A node in a Binary Search Tree.\n    \"\"\"\n    def __init__(self, key):\n        self.key = int(key)\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        return f\"TreeNode({self.key})\"\n\nclass BST:\n    \"\"\"\n    Binary Search Tree implementation with a specific insertion rule for duplicates.\n    \"\"\"\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"\n        Inserts a key into the BST. If the key is >= a node's key, it goes to the right.\n        \"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursive(self.root, key)\n    \n    def _insert_recursive(self, node, key):\n        if key < node.key:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursive(node.left, key)\n        else:  # key >= node.key\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursive(node.right, key)\n\n    @staticmethod\n    def from_sequence(sequence):\n        \"\"\"\n        Builds a BST from a sequence of keys.\n        \"\"\"\n        tree = BST()\n        for key in sequence:\n            tree.insert(key)\n        return tree.root\n\nclass InOrderIterator:\n    \"\"\"\n    An iterator that yields BST nodes in non-decreasing order of keys (in-order).\n    Uses O(h) space, where h is the tree height.\n    \"\"\"\n    def __init__(self, root):\n        self.stack = []\n        self._push_left_path(root)\n\n    def _push_left_path(self, node):\n        while node:\n            self.stack.append(node)\n            node = node.left\n\n    def next(self):\n        if not self.stack:\n            return None\n        node = self.stack.pop()\n        if node.right:\n            self._push_left_path(node.right)\n        return node\n\nclass ReverseInOrderIterator:\n    \"\"\"\n    An iterator that yields BST nodes in non-increasing order of keys (reverse in-order).\n    Uses O(h) space, where h is the tree height.\n    \"\"\"\n    def __init__(self, root):\n        self.stack = []\n        self._push_right_path(root)\n\n    def _push_right_path(self, node):\n        while node:\n            self.stack.append(node)\n            node = node.right\n\n    def next(self):\n        if not self.stack:\n            return None\n        node = self.stack.pop()\n        if node.left:\n            self._push_right_path(node.left)\n        return node\n\ndef find_two_sum_pair(root, target):\n    \"\"\"\n    Finds a pair of distinct nodes in a BST that sum to a target value.\n    \n    Args:\n        root: The root of the BST.\n        target: The target integer sum.\n\n    Returns:\n        A list [a, b] with the keys of the two nodes if found, otherwise an empty list.\n    \"\"\"\n    if not root:\n        return []\n\n    iter_asc = InOrderIterator(root)\n    iter_desc = ReverseInOrderIterator(root)\n\n    node_asc = iter_asc.next()\n    node_desc = iter_desc.next()\n\n    while node_asc and node_desc and node_asc is not node_desc:\n        current_sum = node_asc.key + node_desc.key\n        \n        if current_sum == target:\n            return [node_asc.key, node_desc.key]\n        elif current_sum < target:\n            node_asc = iter_asc.next()\n        else: # current_sum > target\n            node_desc = iter_desc.next()\n            \n    return []\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        ( (8, 3, 10, 1, 6, 14, 4, 7, 13), 17 ),\n        # Case 2\n        ( (-10, -3, 0, 5, 9), -13 ),\n        # Case 3\n        ( (5, 5, 3, 7), 10 ),\n        # Case 4\n        ( (2, 1, 4), 8 ),\n        # Case 5\n        ( (42,), 84 ),\n        # Case 6\n        ( (1, 2, 3, 4, 5), 6 ),\n        # Case 7\n        ( (5, 3, 7), 10 ),\n    ]\n\n    results = []\n    for sequence, target in test_cases:\n        root = BST.from_sequence(sequence)\n        result = find_two_sum_pair(root, target)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[3,14],[-10,-3],[3,7],[],[],[1,5],[3,7]]\n    # str(list) adds spaces, so we remove them.\n    formatted_results = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3216226"}]}