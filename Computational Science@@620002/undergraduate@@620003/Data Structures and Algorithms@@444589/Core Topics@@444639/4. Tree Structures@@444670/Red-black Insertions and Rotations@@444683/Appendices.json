{"hands_on_practices": [{"introduction": "Mastering red-black trees begins with the ability to predict the outcome of an insertion without relying on a computer simulation. This exercise challenges you to mentally trace the standard insertion and fix-up algorithm on a given tree. By determining the precise sequence of recoloring and rotation operations, you will solidify your understanding of the core mechanics that keep the tree balanced [@problem_id:3266139].", "problem": "Consider a binary search tree (BST) augmented with red-black properties (commonly called a red-black tree), where the following core definitions hold: the root is black, every node is either red or black, every red node has black children, and every path from the root to a leaf contains the same number of black nodes (the black-height). Insertion proceeds by placing the new key as in a BST, initially coloring the new node red, and then restoring the red-black properties using local recoloring (only when both the parent and the uncle of the newly inserted node are red) and rotations (Left, Right, Left-Right, Right-Left) determined by the orientation of the parent-child relationships.\n\nLet $T$ be a valid red-black tree with keys and colors as follows. The root is the key $50$ colored black. Its left child is the key $30$ colored red, and its right child is the key $70$ colored black. The node $30$ has two children: the key $20$ colored black on the left, and the key $40$ colored black on the right. The node $20$ has two children: the key $15$ colored red on the left, and the key $25$ colored red on the right. All other children not explicitly mentioned are leaves and are black.\n\nWithout drawing or simulating the operations on $T$, use the red-black properties and the insertion restoration rules to predict the exact sequence of balancing operations triggered when inserting the key $k=23$. For the purposes of the final numerical answer, encode the sequence in temporal order using the mapping $L \\mapsto 1$, $R \\mapsto 2$, $\\text{LR} \\mapsto 3$, $\\text{RL} \\mapsto 4$, and a recoloring step when both the parent and the uncle are red (call this a color flip) $C \\mapsto 5$. If the sequence comprises $m$ steps with codes $c_{1},c_{2},\\ldots,c_{m}$, define the encoding integer by\n$$\nE \\;=\\; \\sum_{i=1}^{m} c_{i}\\,10^{\\,m-i}.\n$$\nReturn the single number $E$ as your final answer. No rounding is required.", "solution": "We start from the red-black tree invariants and the binary search tree (BST) insertion mechanism. The insertion of a key proceeds by placing the new key in its BST position and initially coloring the new node red. Any subsequent violations are repaired using local recoloring and rotations, guided by the following established facts:\n\n1. If the newly inserted node has a red parent and a red uncle, a color flip is performed at the grandparent: the parent and uncle are recolored black and the grandparent is recolored red, after which the restoration continues from the grandparent.\n2. If the newly inserted node has a red parent and a black uncle, rotations are needed. The specific rotation type depends on whether the local configuration is left-left, left-right, right-right, or right-left relative to the grandparent. In left-left, perform a right rotation at the grandparent; in right-right, perform a left rotation at the grandparent; in left-right, first a left rotation at the parent followed by a right rotation at the grandparent; in right-left, first a right rotation at the parent followed by a left rotation at the grandparent. After rotations, recoloring is performed locally to restore the red-black properties, and the loop terminates once the parent of the current node is black.\n\nNow we determine the BST location for the key $k=23$ in $T$:\n- Compare $23$ with $50$: since $2350$, go to the left child $30$.\n- Compare $23$ with $30$: since $2330$, go to the left child $20$.\n- Compare $23$ with $20$: since $23>20$, go to the right child $25$.\n- Compare $23$ with $25$: since $2325$, the insertion location is the left child of $25$.\n\nThus the new node with key $23$ is inserted as the left child of the node $25$ and is initially colored red.\n\nImmediately after insertion, examine the local configuration around the newly inserted red node:\n- The parent is the node $25$, which is red.\n- The uncle is the sibling of the parent, which is the node $15$, and this node is red.\n- The grandparent is the node $20$, which is black.\n\nBecause both the parent and the uncle are red, we perform a color flip at the grandparent $20$. According to the recoloring rule, $25$ becomes black, $15$ becomes black, and $20$ becomes red. After this recoloring, the current node for continued restoration is the grandparent, namely the node $20$ (now red). This constitutes one color flip step, encoded as $C \\mapsto 5$.\n\nNext, we check for any violation with the current node $20$ and its parent:\n- The parent of $20$ is $30$, which is red.\n- The uncle of $20$ at this level is the node $40$, which is black.\n- The grandparent at this level is $50$, which is black.\n- The orientation is as follows: $20$ is the left child of $30$, and $30$ is the left child of $50$, which is the left-left case relative to $50$.\n\nWith a red parent and black uncle in the left-left configuration, the remedy is a right rotation at the grandparent $50$, followed by local recoloring. Performing a right rotation at $50$ places $30$ as the root of the subtree, with $50$ becoming its right child and $20$ its left child. The standard recoloring for this case makes $30$ black and $50$ red, restoring the red-black properties locally and breaking the red-red chain. This constitutes one right rotation step, encoded as $R \\mapsto 2$.\n\nAfter this rotation, the parent of the current node is black, so the fix-up terminates. The exact sequence of balancing operations, in temporal order, is therefore:\n- First, a color flip ($C$).\n- Second, a right rotation ($R$).\n\nUsing the prescribed encoding $L \\mapsto 1$, $R \\mapsto 2$, $\\text{LR} \\mapsto 3$, $\\text{RL} \\mapsto 4$, $C \\mapsto 5$, the sequence $(C, R)$ corresponds to the code sequence $(5, 2)$. The encoding integer is computed by\n$$\nE \\;=\\; \\sum_{i=1}^{m} c_{i}\\,10^{\\,m-i} \\;=\\; 5\\cdot 10^{\\,2-1} \\;+\\; 2\\cdot 10^{\\,2-2} \\;=\\; 5\\cdot 10 \\;+\\; 2\\cdot 1 \\;=\\; 50 \\;+\\; 2 \\;=\\; 52.\n$$\nTherefore, the required final number is $52$.", "answer": "$$\\boxed{52}$$", "id": "3266139"}, {"introduction": "Once you can predict the behavior of the fix-up algorithm, the next step is to understand how to provoke specific behaviors. This practice asks you to think like a test engineer and construct a minimal sequence of insertions that triggers the most complex rebalancing case—a double rotation. Successfully identifying such a sequence demonstrates a deep comprehension of the structural conditions, particularly the \"inner child\" or zig-zag configuration, that necessitate this specific chain of operations [@problem_id:3266096].", "problem": "A Red-Black Tree (RBT) is a Binary Search Tree (BST) augmented with the following invariants: (i) each node is either red or black, (ii) the root is black, (iii) all external null leaves are black, (iv) no red node has a red child, and (v) every simple path from a node to any external leaf contains the same number of black nodes (black-height). Insertion proceeds by first inserting the new key as in a BST and coloring it red, then restoring invariants by a finite sequence of local recolorings and rotations. In the standard textbook fix-up, let the newly inserted node be $z$, its parent be $P$, its grandparent be $G$, and its uncle be $U$. While $P$ is red: \n- Case $1$: $U$ is red. Recolor $P$ and $U$ to black, $G$ to red, and continue with $z \\leftarrow G$. \n- Case $2$: $U$ is black and $z$ is an inner child (left-right or right-left relative to $G$). Rotate once about $P$ to transform into Case $3$. \n- Case $3$: $U$ is black and $z$ is an outer child (left-left or right-right relative to $G$). Rotate once about $G$ and recolor appropriately. Finally, recolor the root black.\n\nA single insertion can trigger at most $2$ rotations in this algorithm. Your task is to identify a minimal example (fewest total inserted keys) in which a single insertion requires exactly $2$ rotations during its fix-up, and to correctly state which case transitions produce those $2$ rotations for that insertion.\n\nChoose all options that simultaneously: \n- provide a minimal insertion sequence of distinct integer keys into an initially empty tree whose last insertion triggers exactly $2$ rotations during that insertion’s fix-up, and \n- correctly identify the case-transition explanation for those $2$ rotations, using the case numbering above.\n\nA. Insert in order $[10, 5, 7]$. Explanation: the last insertion’s fix-up performs $\\text{case }2$ followed by $\\text{case }3$ at the same grandparent, yielding exactly $2$ rotations.\n\nB. Insert in order $[10, 5, 1, 7]$. Explanation: the last insertion’s fix-up performs $\\text{case }1$ followed by $\\text{case }3$, yielding exactly $2$ rotations.\n\nC. Insert in order $[10, 15, 12]$. Explanation: the last insertion’s fix-up performs $\\text{case }2$ followed by $\\text{case }3$ (mirror image of left-right), yielding exactly $2$ rotations.\n\nD. Insert in order $[10, 5, 7]$. Explanation: the last insertion’s fix-up performs $\\text{case }1$ followed by $\\text{case }3$, yielding exactly $2$ rotations.\n\nE. Insert in order $[10, 5, 3]$. Explanation: the last insertion’s fix-up is $\\text{case }3$ only, yielding exactly $2$ rotations.", "solution": "The problem requires identifying minimal insertion sequences into a Red-Black Tree that cause exactly $2$ rotations during the fix-up of the final insertion, along with the correct explanation for these rotations based on the provided case definitions.\n\nFirst, let us validate the problem statement.\nThe problem defines a Red-Black Tree with its standard invariants and a common variant of the insertion fix-up algorithm. The definitions for the nodes ($z$, $P$, $G$, $U$), the invariants, and the cases for the fix-up procedure are consistent with established literature on the subject (e.g., Cormen, Leiserson, Rivest, and Stein, *Introduction to Algorithms*). The problem is well-posed, scientifically grounded in the field of computer science, and stated objectively. All necessary information is provided. Therefore, the problem is valid and we can proceed to a solution.\n\nThe core of the problem is to understand how rotations are generated by the fix-up algorithm. Let's analyze the number of rotations produced by each case:\n- **Case $1$**: The uncle $U$ is red. This case involves only recoloring nodes and propagating the problem up the tree by setting $z \\leftarrow G$. It performs **zero** rotations.\n- **Case $2$**: The uncle $U$ is black and $z$ is an inner child. This case performs **one** rotation about the parent $P$. The explicit purpose of this case is to transform the structure into a Case $3$ configuration.\n- **Case $3$**: The uncle $U$ is black and $z$ is an outer child. This case performs **one** rotation about the grandparent $G$ and then terminates the loop.\n\nA single insertion can trigger at most $2$ rotations. To achieve exactly $2$ rotations, the fix-up process must execute a sequence of case handlers that sum to $2$ rotations.\nBased on the definitions:\n- A `Case 1 - Case 3` sequence would involve zero rotations from Case $1$, followed by one rotation from Case $3$ at a higher level in the tree, for a total of $1$ rotation.\n- A `Case 3` only situation yields $1$ rotation.\n- The only way to achieve exactly $2$ rotations is to first encounter **Case $2$**, which performs $1$ rotation, and which by definition transforms the subtree into a **Case $3$** configuration. This Case $3$ is then immediately handled, performing a second rotation and terminating the fix-up.\n\nTherefore, the only mechanism that produces exactly $2$ rotations is the sequence **Case $2 \\rightarrow$ Case $3$**. This occurs when fixing a double-red violation involving an \"inner child\" (a left-right or right-left zig-zag configuration relative to the grandparent). Now, we evaluate each option based on this principle.\n\nA minimal example requires a grandparent-parent-child structure, which implies a minimum of $3$ nodes. Both options A and C propose sequences of $3$ keys.\n\n**Option A: Insert in order $[10, 5, 7]$. Explanation: the last insertion’s fix-up performs $\\text{case }2$ followed by $\\text{case }3$ at the same grandparent, yielding exactly $2$ rotations.**\n\n1.  Insert $10$: The tree is a single black node, $10(\\text{B})$.\n2.  Insert $5$: The tree is $10(\\text{B}) \\leftarrow 5(\\text{R})$. This is a valid RBT.\n3.  Insert $7$:\n    -   Standard BST insertion places $7$ as the right child of $5$. The tree is $10(\\text{B}) \\leftarrow 5(\\text{R}) \\rightarrow 7(\\text{R})$.\n    -   This creates a violation: the parent of $7(\\text{R})$, which is $5(\\text{R})$, is also red.\n    -   In the fix-up for $z=7$: Parent $P=5$, Grandparent $G=10$. The uncle $U$ (right child of $10$) is a null leaf, which is black.\n    -   $P$ is a left child of $G$, and $z$ is a right child of $P$. This is a \"left-right\" configuration, which is an inner child. This is **Case $2$**.\n    -   Action for Case $2$: A single left rotation is performed on $P=5$. This is the **first rotation**. The subtree under $G=10$ now has $7(\\text{R})$ as its left child, which in turn has $5(\\text{R})$ as its left child.\n    -   This transforms the structure into a \"left-left\" outer child configuration. This is now **Case $3$**.\n    -   Action for Case $3$: A single right rotation is performed on $G=10$, along with recoloring. This is the **second rotation**.\n    -   The fix-up terminates. The total number of rotations is exactly $2$. The explanation is correct.\n    -   **Verdict: Correct.**\n\n**Option B: Insert in order $[10, 5, 1, 7]$. Explanation: the last insertion’s fix-up performs $\\text{case }1$ followed by $\\text{case }3$, yielding exactly $2$ rotations.**\n\n1.  Insert $10, 5, 1$: After these insertions, the tree becomes $5(\\text{B})$ with children $1(\\text{R})$ and $10(\\text{R})$.\n2.  Insert $7$:\n    -   BST insertion places $7$ as the left child of $10$. Tree: $5(\\text{B}) \\rightarrow 10(\\text{R}) \\leftarrow 7(\\text{R})$.\n    -   Violation: The parent of $7(\\text{R})$, $P=10(\\text{R})$, is red.\n    -   In the fix-up for $z=7$: $P=10$, $G=5$. The uncle $U$ is the other child of $G=5$, which is $1(\\text{R})$.\n    -   Since the uncle $U=1$ is red, this is **Case $1$**.\n    -   Action for Case $1$: Recolor $P(10)$ and $U(1)$ to black, and recolor $G(5)$ to red. $z$ is updated to $G=5$. Node $5$ is the root, so its parent is black (null). The loop `while P is red` terminates. The final step is to color the root black. Case $1$ performs **zero** rotations.\n    -   The insertion of $7$ causes zero rotations. The explanation is factually incorrect as it claims $2$ rotations occurred, and the case sequence `Case 1 - Case 3` would only yield $1$ rotation anyway.\n    -   **Verdict: Incorrect.**\n\n**Option C: Insert in order $[10, 15, 12]$. Explanation: the last insertion’s fix-up performs $\\text{case }2$ followed by $\\text{case }3$ (mirror image of left-right), yielding exactly $2$ rotations.**\n\n1.  Insert $10$: The tree is a single black node, $10(\\text{B})$.\n2.  Insert $15$: The tree is $10(\\text{B}) \\rightarrow 15(\\text{R})$.\n3.  Insert $12$:\n    -   BST insertion places $12$ as the left child of $15$. Tree: $10(\\text{B}) \\rightarrow 15(\\text{R}) \\leftarrow 12(\\text{R})$.\n    -   Violation: The parent of $12(\\text{R})$, $P=15(\\text{R})$, is red.\n    -   In the fix-up for $z=12$: $P=15$, $G=10$. The uncle $U$ (left child of $10$) is a null leaf, which is black.\n    -   $P$ is a right child of $G$, and $z$ is a left child of $P$. This is a \"right-left\" configuration, the mirror image of option A. It is an inner child case. This is **Case $2$**.\n    -   Action for Case $2$: A single right rotation is performed on $P=15$. This is the **first rotation**.\n    -   This transforms the structure into a \"right-right\" outer child configuration. This is now **Case $3$**.\n    -   Action for Case $3$: A single left rotation is performed on $G=10$. This is the **second rotation**.\n    -   The fix-up terminates, having performed exactly $2$ rotations. The explanation is correct.\n    -   **Verdict: Correct.**\n\n**Option D: Insert in order $[10, 5, 7]$. Explanation: the last insertion’s fix-up performs $\\text{case }1$ followed by $\\text{case }3$, yielding exactly $2$ rotations.**\n\n-   The insertion sequence is the same as in option A. As established, the fix-up performs a `Case 2 - Case 3` sequence. This option provides an incorrect explanation, `Case 1 - Case 3`. A `Case 1` situation does not even occur. Furthermore, a `Case 1 - Case 3` sequence would result in only $1$ rotation, not $2$. Therefore, the explanation is incorrect.\n-   **Verdict: Incorrect.**\n\n**Option E: Insert in order $[10, 5, 3]$. Explanation: the last insertion’s fix-up is $\\text{case }3$ only, yielding exactly $2$ rotations.**\n\n1.  Insert $10$: $10(\\text{B})$.\n2.  Insert $5$: $10(\\text{B}) \\leftarrow 5(\\text{R})$.\n3.  Insert $3$:\n    -   BST insertion places $3$ as the left child of $5$. Tree: $10(\\text{B}) \\leftarrow 5(\\text{R}) \\leftarrow 3(\\text{R})$.\n    -   Violation: The parent of $3(\\text{R})$, $P=5(\\text{R})$, is red.\n    -   In the fix-up for $z=3$: $P=5$, $G=10$. The uncle $U$ is black (null leaf).\n    -   $P$ is a left child of $G$, and $z$ is a left child of $P$. This is a \"left-left\" configuration, an outer child. This is **Case $3$** directly.\n    -   Action for Case $3$: Perform one rotation (right rotation on $G=10$) and recolor. The fix-up terminates.\n    -   This insertion yields exactly **one** rotation. The explanation incorrectly claims it yields $2$.\n    -   **Verdict: Incorrect.**\n\nIn summary, both options A and C provide minimal $3$-key insertion sequences where the final insertion triggers exactly $2$ rotations, and both provide the correct `Case 2 - Case 3` explanation of this phenomenon.", "answer": "$$\\boxed{AC}$$", "id": "3266096"}, {"introduction": "An abstract algorithm is only as good as its concrete implementation. This final exercise bridges theory and practice by presenting a hypothetical scenario: a buggy `LeftRotate` function that fails to update a crucial parent pointer. Your task is to devise an insertion sequence that exposes this bug by leading to a violation of the red-black tree invariants. This practice underscores the importance of implementation details and demonstrates how a seemingly minor local error can have cascading effects that corrupt the entire data structure [@problem_id:3266135].", "problem": "Consider a Red-Black Tree (RBT) that maintains the following invariants: (i) the root is colored black, (ii) every leaf (the sentinel $\\mathsf{nil}$) is colored black, (iii) no red node has a red child, and (iv) for each node, all simple paths from the node to descendant leaves contain the same number of black nodes (equal black-height). The standard insertion procedure first inserts a new key as in a binary search tree (BST) and colors the new node red, then applies the widely used fix-up routine from Introduction to Algorithms (third edition) by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein (CLRS) to restore the RBT invariants. Rotations are performed by the fix-up routine as needed; the sentinel $\\mathsf{nil}$ is used as a shared black leaf, and parent pointers are used as in the CLRS implementation.\n\nAssume the LeftRotate operation is implemented with the following bug: when performing a left rotation on a node $x$ with right child $y$, the implementation omits the assignment $x.\\mathrm{p} \\leftarrow y$ (the parent pointer of $x$ is not updated to point to $y$). All other assignments follow the standard CLRS LeftRotate specification, including $y.\\mathrm{p}$ being updated appropriately and child pointers being adjusted correctly. The RightRotate operation is implemented correctly. After each insertion, the CLRS insertion fix-up procedure is run to completion.\n\nStarting from an empty RBT, which of the following insertion sequences provides a minimal counterexample in the sense that, after all keys in the sequence have been inserted and the (buggy) fix-up has been applied, the tree violates at least one RBT invariant while its left/right child pointers still represent a valid BST?\n\nA. Insert $10$, then $20$, then $30$, then $5$.\n\nB. Insert $10$, then $20$, then $30$, then $25$.\n\nC. Insert $10$, then $5$, then $1$, then $0$.\n\nD. Insert $10$, then $2$, then $3$, then $4$.\n\nOnly choose an option that unambiguously demonstrates an RBT invariant violation caused by the stated LeftRotate parent-pointer bug, not due to incorrect BST ordering or other unspecified failures. Justify the choice based on first principles: the Red-Black Tree invariants, the CLRS insertion fix-up logic, and the pointer semantics of rotations.", "solution": "The user wants me to identify a minimal insertion sequence that causes a Red-Black Tree (RBT) invariant to be violated, given a specific bug in the `LeftRotate` operation.\n\n### Problem Statement Validation\n\n**Step 1: Extract Givens**\n- **Data Structure**: Red-Black Tree (RBT) with standard CLRS invariants:\n    1. The root is black.\n    2. All leaves ($\\mathsf{nil}$) are black.\n    3. If a node is red, both its children are black (no red-red violation).\n    4. For each node, all simple paths to descendant leaves have the same black-height.\n- **Insertion Rule**: Standard Binary Search Tree (BST) insertion, coloring the new node red, followed by the CLRS `RB-INSERT-FIXUP` procedure.\n- **Implementation Details**: The tree uses a shared sentinel black leaf ($\\mathsf{nil}$) and parent pointers. The `RightRotate` operation is correct.\n- **The Bug**: The `LeftRotate(x)` operation, where `y` is the right child of `x`, omits the final pointer assignment `x.p \\leftarrow y`. All other pointer assignments in `LeftRotate` are performed correctly.\n- **The Goal**: Find the minimal sequence of insertions (from the given options) that results in a tree that violates at least one RBT invariant but still maintains the BST property for its child pointers. The violation must be a direct consequence of the buggy `LeftRotate`.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The problem is based on the canonical Red-Black Tree data structure and its standard insertion algorithm as described in *Introduction to Algorithms* (CLRS), a cornerstone text in computer science. The described bug is a specific, formalizable modification to this algorithm. The problem is scientifically sound.\n- **Well-Posed**: The problem is well-defined. It specifies the data structure, the invariants, the insertion algorithm, and a precise bug. It asks for the identification of a sequence from a given set of options that leads to a specific, verifiable outcome (an RBT invariant violation). The term \"minimal counterexample\" is unambiguous here, as all provided sequences have the same length ($4$), and we are looking for one that demonstrates the failure.\n- **Objective**: The problem is stated in precise, technical language, free from subjectivity or ambiguity.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. It is a well-posed problem in the domain of data structures and algorithms that requires a rigorous step-by-step analysis of the specified algorithm under a buggy condition. I will proceed with the derivation.\n\n### Derivation and Solution\n\nThe core of the problem lies in understanding the consequences of the buggy `LeftRotate(x)` operation. In a standard `LeftRotate(x)`, where `y` is `x`'s right child, `y` replaces `x` in the tree, and `x` becomes `y`'s left child. The final step, `x.p \\leftarrow y`, is essential to reflect this new relationship. The bug states this step is omitted. Consequently, after a buggy `LeftRotate(x)`, `x`'s parent pointer, `x.p`, will retain its old value (pointing to the original parent of `x`) instead of pointing to `y`. This creates an inconsistency between the child/parent pointers. An RBT invariant violation will occur if a subsequent operation in the `RB-INSERT-FIXUP` procedure relies on this corrupted parent pointer.\n\nThe `RB-INSERT-FIXUP` procedure from CLRS calls `LeftRotate` in two scenarios when fixing a red-red violation between a node `z` and its parent `p`:\n1.  **Symmetric Case 2**: If `p` is the left child of its parent `g` (the grandparent of `z`), and `z` is the right child of `p`. A `LeftRotate(p)` is performed.\n2.  **Case 3**: If `p` is the right child of `g`, and `z` is the right child of `p`. A `LeftRotate(g)` is performed.\n\nWe will now trace each provided insertion sequence to determine which one triggers a `LeftRotate` and subsequently leads to an RBT invariant violation due to the corrupted parent pointer.\n\n**A. Insert $10$, then $20$, then $30$, then $5$.**\n\n1.  **Insert $10$**: The tree is `$10(B)$`.\n2.  **Insert $20$**: `$20(R)$` is the right child of `$10(B)$`. No violation. The tree is `$10(B) \\rightarrow 20(R)$`.\n3.  **Insert $30$**: `$30(R)$` is inserted as the right child of `$20(R)$`. This creates a red-red violation.\n    -   `z=30(R)`, `p=z.p=20(R)`, `g=p.p=10(B)`.\n    -   The parent `p` is a right child of `g`, and `z` is a right child of `p`. This is **Case 3**.\n    -   The fix-up procedure performs:\n        a. Recolor `p` to black: `$20(B)$`.\n        b. Recolor `g` to red: `$10(R)$`.\n        c. Perform `LeftRotate(g)`, which is `LeftRotate(10)`.\n    -   In the buggy `LeftRotate(10)`, let `x=10` and `y=20`. The operation correctly makes `$20$` the new root of the subtree with `$10$` as its left child. However, the step `$x.p \\leftarrow y` (i.e., `$10.p \\leftarrow 20$`) is **omitted**. Since `$10$` was the root, its parent pointer was `nil`. Therefore, `$10.p` remains `nil`.\n    -   After fix-up, the tree's child pointers represent `$20(B)$` as the root, with left child `$10(R)$` and right child `$30(R)$`.\n    -   Parent pointers: `$20.p` is `nil`, `$30.p` is `$20$`. Critically, `$10.p` is `nil` (the bug).\n    -   At this stage, all RBT invariants hold.\n4.  **Insert $5$**: `$5(R)$` is inserted as the left child of `$10(R)$`. This creates a red-red violation.\n    -   `z=5(R)`, `p=z.p=10(R)`. The `while (z.p.color == RED)` loop in `RB-INSERT-FIXUP` begins.\n    -   Inside the loop, the algorithm computes the grandparent `g = p.p = 10.p`. Due to the bug from the previous step, `$10.p` is `nil`.\n    -   The CLRS algorithm assumes that if a node's parent `p` is red, `p` cannot be the root, and thus the grandparent `g` must exist (i.e., not be `nil`). The bug violates this precondition.\n    -   Any attempt to access `g`'s children (e.g., to find the uncle `y = g.right`) would result in a null pointer dereference. A robust implementation would likely terminate the fix-up procedure prematurely. Assuming the procedure aborts, the red-red violation between `$5(R)$` and `$10(R)$` is never resolved.\n    -   The final tree state (based on child pointers) is:\n        $$\n        \\begin{array}{c}\n        20(B) \\\\\n        /   \\quad \\\\\n        10(R) \\quad 30(R) \\\\\n        / \\\\\n        5(R)\n        \\end{array}\n        $$\n    -   **Validation**:\n        -   The child pointers represent a valid BST ($5  10  20  30$).\n        -   RBT invariant (iii) is **violated**: node `$5(R)$` has a red parent `$10(R)$`.\n        -   This violation is a direct result of the bug, which caused the fix-up to fail.\n\nTherefore, this sequence is a valid counterexample.\n\n**B. Insert $10$, then $20$, then $30$, then $25$.**\n\n1.  **Insert $10, 20, 30$**: Same as in option A. The tree has root `$20(B)$`, children `$10(R)$` and `$30(R)$`, and the buggy pointer `$10.p = \\text{nil}`.\n2.  **Insert $25$**: `$25(R)$` is inserted as the left child of `$30(R)$`. This creates a red-red violation.\n    -   `z=25(R)`, `p=z.p=30(R)`, `g=p.p=20(B)`. The uncle `u = g.left = 10(R)`.\n    -   This is **Case 1** (red uncle). The fix-up recolors `p` (`$30$`) to black, `u` (`$10$`) to black, and `g` (`$20$`) to red. Then, `z` is updated to `g` (`$20$`) and the loop continues.\n    -   The new `z` is `$20(R)$`. Its parent `z.p` is `nil`, which is black. The loop terminates.\n    -   The final step of insertion colors the root black, so `$20$` becomes black again.\n    -   The final tree is valid and satisfies all RBT invariants. The buggy pointer `$10.p` was never accessed during the fix-up for `$25$`.\n\nThus, this sequence is not a counterexample.\n\n**C. Insert $10$, then $5$, then $1$, then $0$.**\n\nThis sequence consists of exclusively left-sided insertions.\n1.  **Insert $10, 5, 1$**: Inserting `$1$` creates a red-red violation (`$1(R), 5(R)$`). `p = 5` is a left child of `g = 10`, and `z = 1` is a left child of `p`. This is a symmetric Case 3, which triggers a `RightRotate(10)`.\n2.  **Insert $0$**: Inserting `$0$` creates a red-red violation (`$0(R), 1(R)$`). This triggers a Case 1 fix-up (red uncle).\nThe entire sequence only involves `RightRotate` operations, which are specified to be correct. The buggy `LeftRotate` is never called. Therefore, the resulting tree will be a valid RBT.\n\nThus, this sequence is not a counterexample.\n\n**D. Insert $10$, then $2$, then $3$, then $4$.**\n\n1.  **Insert $10, 2$**: Tree is `$10(B) \\leftarrow 2(R)$`.\n2.  **Insert $3$**: `$3(R)` is inserted as the right child of `$2(R)$`. Red-red violation.\n    -   `z=3(R)`, `p=2(R)`, `g=10(B)`.\n    -   `p` is a left child of `g`, and `z` is a right child of `p`. This is **Symmetric Case 2**.\n    -   The fix-up sets `z \\leftarrow p` (so `z` becomes `$2$`) and performs `LeftRotate(z)` (i.e., `LeftRotate(2)`).\n    -   The buggy `LeftRotate(2)` is called. Let `x=2, y=3`. The parent of `$2$` was `$10$`. The operation omits `$x.p \\leftarrow y` (`$2.p \\leftarrow 3$`), so `$2.p` remains pointing to `$10$`.\n    -   The fix-up continues, transforming into Symmetric Case 3, which performs a correct `RightRotate(10)`. After all operations, the tree is a valid RBT, but with an inconsistent internal state: the child of `$3$` is `$2$`, but `$2.p$` points to `$10$`.\n3.  **Insert $4$**: `$4(R)$` is inserted, causing a red-red violation. The fix-up is a Case 1 (red uncle). The fix-up operations read the color of uncle `$2$` but do not navigate using `$2$`'s parent pointer. The buggy pointer `$2.p` is never accessed. The final tree satisfies all RBT invariants.\n\nThus, this sequence is not a counterexample because although the bug is triggered, it does not lead to a violation of the four external RBT invariants in the final tree.\n\n### Conclusion\n\nOnly the insertion sequence in Option A leads to a state where the buggy `LeftRotate` causes a corrupted parent pointer, which in turn causes a subsequent `RB-INSERT-FIXUP` to fail, leaving the tree in a state that violates the red-red property (RBT invariant iii).\n\n**Final Analysis of Options:**\n-   **A**: Creates a red-red violation that is left unfixed because the fix-up procedure fails due to the bug. **Correct**.\n-   **B**: The bug is triggered, but the subsequent insertion's fix-up does not rely on the corrupted pointer. The final tree is a valid RBT. **Incorrect**.\n-   **C**: The buggy `LeftRotate` is never called. The final tree is a valid RBT. **Incorrect**.\n-   **D**: The bug is triggered, creating an inconsistent parent pointer, but the subsequent fix-up does not expose this inconsistency in a way that violates an RBT invariant. The final tree is a valid RBT. **Incorrect**.", "answer": "$$\\boxed{A}$$", "id": "3266135"}]}