{"hands_on_practices": [{"introduction": "Understanding the red-black tree deletion algorithm requires more than just memorizing the rules; it demands hands-on practice. This exercise challenges you to perform a complete deletion on a given tree, starting from identifying the correct node, finding its successor, and meticulously applying the fix-up rules. By tracing every step, you will build a concrete mental model of how the tree maintains its balance. [@problem_id:3265764]", "problem": "You are given a concrete red-black binary search tree whose keys are distinct integers. All external leaves (sentinels $\\mathsf{NIL}$) are black. The tree satisfies the red-black properties: the root is black, every red node has black children, and every path from a node to any descendant $\\mathsf{NIL}$ has the same number of black nodes. The tree is specified as follows (each node is annotated with its color in parentheses):\n\n- Root: $15$ (black)\n  - Left child: $9$ (black)\n    - Left child: $5$ (red)\n      - Left child: $3$ (black)\n      - Right child: $7$ (black)\n    - Right child: $12$ (red)\n      - Left child: $11$ (black)\n      - Right child: $13$ (black)\n  - Right child: $21$ (black)\n    - Left child: $18$ (red)\n      - Left child: $17$ (black)\n      - Right child: $19$ (black)\n    - Right child: $25$ (red)\n      - Left child: $23$ (black)\n      - Right child: $27$ (black)\n\nTasks:\n- Using only the foundational definitions of red-black trees (binary search tree ordering, red-black coloring properties, and the standard red-black deletion procedure including successor replacement, rotations, and recolorings), first identify the median key of the set of stored keys and then delete this median from the tree using the standard red-black deletion algorithm (as presented in canonical sources such as Cormen–Leiserson–Rivest–Stein).\n- After all necessary structural changes and fix-up operations (rotations and recolorings) are performed to restore the red-black properties, determine the key stored at the root of the resulting red-black tree.\n\nAnswer format:\n- Provide only the final root key as a single exact integer. No rounding is required. Do not include any units or additional text.", "solution": "The problem requires us to perform a deletion operation on a given red-black tree and determine the key of the new root node. The process involves first identifying the median of all keys in the tree, then deleting the node with that key using the standard red-black tree deletion algorithm, and finally reporting the key at the root of the modified tree.\n\nFirst, we validate the provided tree structure to ensure it conforms to the properties of a red-black tree and a binary search tree.\nThe keys are: $3, 5, 7, 9, 11, 12, 13, 15, 17, 18, 19, 21, 23, 25, 27$.\nThe structure is given as:\n- Root: $15$ (black)\n  - Left child: $9$ (black)\n    - Left child: $5$ (red) -> children $3$ (black), $7$ (black)\n    - Right child: $12$ (red) -> children $11$ (black), $13$ (black)\n  - Right child: $21$ (black)\n    - Left child: $18$ (red) -> children $17$ (black), $19$ (black)\n    - Right child: $25$ (red) -> children $23$ (black), $27$ (black)\nThe binary search tree property holds for all nodes. The root is black. All red nodes ($5, 12, 18, 25$) have black children. The black-height (number of black nodes on any simple path from a node, not including the node itself, to a descendant leaf) is uniform. For the root $15$, the black-height is $2$ for all paths (e.g., path through $3$: $9(\\text{B}) \\rightarrow 5(\\text{R}) \\rightarrow 3(\\text{B}) \\rightarrow \\mathsf{NIL}$, black nodes are $9, 3$). The given tree is a valid red-black tree.\n\nThe first task is to identify the median key. The set of keys, sorted in ascending order, is:\n$$S = \\{3, 5, 7, 9, 11, 12, 13, 15, 17, 18, 19, 21, 23, 25, 27\\}$$\nThe number of keys is $|S| = 15$. For a set with an odd number of elements, the median is the element at position $\\frac{n+1}{2}$. Here, it is the $\\frac{15+1}{2} = 8$-th element.\nCounting through the sorted set, the 8th key is $15$. Therefore, we must delete the node with key $15$.\n\nThe node to be deleted, let's call it $z$, is the root of the tree. Node $z$ has two children (nodes $9$ and $21$). The standard binary search tree deletion procedure for a node with two children requires replacing it with its in-order successor, and then deleting the successor node from its original position.\nThe in-order successor of a node is the node with the smallest key in its right subtree. The right subtree of node $15$ is rooted at node $21$. To find the minimum key in this subtree, we follow the left-child pointers starting from node $21$: $21 \\rightarrow 18 \\rightarrow 17$. The in-order successor is the node with key $17$. Let's call this successor node $y$.\n\nThe deletion algorithm proceeds as follows:\n1.  The key of the successor node $y$ (which is $17$) is copied into the node $z$ (the root). The root node's key is now $17$, but its color remains black.\n2.  The problem is now reduced to deleting the original successor node $y$ (the node with key $17$) from the tree.\n\nLet's examine the node $y$ to be physically removed. Its key is $17$, its color is black, and its parent is node $18$. Node $17$ has no children (both its children are $\\mathsf{NIL}$ leaves).\nWhen we remove node $y$, we replace it with one of its children. We can choose its right child, which is a $\\mathsf{NIL}$ node. Let's call this replacement node $x$. So, $x$ is a $\\mathsf{NIL}$ node.\nThe original color of the deleted node $y$ was black. Removing a black node from the tree disrupts the red-black property that all paths from a node to its descendant leaves must have the same number of black nodes (property 5). To restore this property, we must run the `RB-DELETE-FIXUP` procedure on the node $x$. Node $x$ is considered to carry an \"extra black\".\n\nThe `RB-DELETE-FIXUP` procedure for $x$ is as follows. Initially, $x$ is the $\\mathsf{NIL}$ node that replaced node $17$. The parent of $x$, denoted $p(x)$, is node $18$. Since $x$ is not the root and is \"doubly black\", we enter a loop.\n\n**Iteration 1:**\n-   $x$ is the left child of its parent, $p(x) = 18$.\n-   We identify the sibling of $x$, denoted $w$. $w$ is the right child of node $18$, which is the node with key $19$.\n-   The original color of $w$ (node $19$) is black. This corresponds to Case 2, 3, or 4 of the CLRS deletion algorithm.\n-   We check the colors of $w$'s children. Both children of node $19$ are $\\mathsf{NIL}$ leaves, which are black.\n-   This situation matches **Case 2**: The sibling $w$ is black, and both of $w$'s children are black.\n-   The actions for Case 2 are:\n    1.  Recolor $w$ to red. So, node $19$ becomes red.\n    2.  Move the \"extra black\" up the tree by setting $x = p(x)$. So, $x$ now points to node $18$.\n-   The loop condition (`x` is not root and is \"doubly black\") is now re-evaluated for the new $x$ (node $18$). The original color of node $18$ was red. When the \"extra black\" moves to a red node, the loop terminates. The red-and-black node simply becomes black, absorbing the extra blackness and restoring the black-height property for all paths passing through it.\n\n-   The `RB-DELETE-FIXUP` procedure has a final step after the loop: it sets the color of the current node $x$ to black. In our case, the loop terminated with $x$ pointing to node $18$. Therefore, node $18$, which was originally red, is recolored to black.\n\nLet's summarize the changes to the tree:\n1.  The key of the root node is changed from $15$ to $17$. Its color remains black.\n2.  The node with key $17$ is physically removed.\n3.  The node with key $19$ is recolored from black to red.\n4.  The node with key $18$ is recolored from red to black.\nNo rotations were performed.\n\nThe final state of the tree structure is:\n- Root: $17$ (black)\n  - Left child: $9$ (black)\n    - Left child: $5$ (red)\n    - Right child: $12$ (red)\n  - Right child: $21$ (black)\n    - Left child: $18$ (black)\n      - Right child: $19$ (red)\n    - Right child: $25$ (red)\n\nAll red-black properties are satisfied in the new tree. The root is black. Every red node ($5, 12, 19, 25$) has black children. The black-height from the root is still $2$ for all paths.\n\nThe problem asks for the key stored at the root of the resulting red-black tree. After the deletion and fix-up operations, the root node contains the key of the successor of the original median, which is $17$.", "answer": "$$\\boxed{17}$$", "id": "3265764"}, {"introduction": "The deletion fix-up procedure can seem daunting with its multiple cases, but some scenarios are much simpler than others. This problem presents a situation where the fix-up is resolved with a single color change, a common and efficient case. Analyzing this scenario helps you appreciate the nuances of the algorithm and recognize when a complex series of rotations is not required. [@problem_id:3265805]", "problem": "Consider a Red-Black Tree (RBT) that stores distinct integer keys and uses the canonical deletion algorithm that removes a node by splicing out its in-order successor when the node has two children, followed by the standard fix-up based solely on the RBT axioms. All missing children are the sentinel leaf $\\mathsf{NIL}$, which is colored black.\n\nYou are given the following RBT, where the root is the node $x$ with key $20$ and color black. The left subtree of $x$ is as follows:\n- Node with key $10$ colored black, whose left child is key $5$ colored black (both of whose children are $\\mathsf{NIL}$) and whose right child is key $15$ colored black (both of whose children are $\\mathsf{NIL}$).\n\nThe right subtree of $x$ is as follows:\n- Node with key $30$ colored black, whose left child is key $25$ colored black and whose right child is key $35$ colored black.\n- The node with key $25$ has left child $\\mathsf{NIL}$ and right child key $27$ colored red (both of whose children are $\\mathsf{NIL}$).\n- The node with key $35$ has left child $\\mathsf{NIL}$ and right child key $37$ colored red (both of whose children are $\\mathsf{NIL}$).\n\nAssume this tree satisfies all Red-Black Tree axioms. Now delete the node $x$ (key $20$) using the canonical Red-Black Tree deletion procedure described above. In particular, when a node has two children, its in-order successor $y$ is spliced out and moved to the deleted node’s position, and fix-up is performed only if the deleted physical node had black color. This scenario is constructed so that the in-order successor of $x$ is a strict grandchild of $x$, and moving it to $x$’s position causes that grandchild to become the new parent of $x$’s former children.\n\nLet $R$ be the total number of rotations (left or right) executed by the deletion and all subsequent fix-up steps, and let $K$ be the total number of recolor operations that actually change a node’s color bit during the deletion and all subsequent fix-up steps. Define $C = R + K$.\n\nCompute $C$. Your answer must be a single real-valued number. If you need to round, round to four significant figures; however, in this instance no rounding is necessary.", "solution": "The problem will be solved by first validating its premises and then executing the canonical Red-Black Tree (RBT) deletion algorithm as specified.\n\n### Problem Validation\n\nThe problem asks to compute the number of rotations and color changes during the deletion of a node from a given RBT.\n\nThe initial state of the tree is described as follows:\n- Root `x`: key $20$, color black.\n- Left subtree of `x`: Node with key $10$ (black), whose left child is key $5$ (black) and right child is key $15$ (black).\n- Right subtree of `x`: Node with key $30$ (black), whose left child is key $25$ (black) and right child is key $35$ (black). The node with key $25$ has a right child with key $27$ (red). The node with key $35$ has a right child with key $37$ (red). All other children are the sentinel `NIL` node, colored black.\n\nBefore proceeding, we must verify that this initial configuration is a valid RBT. The RBT axioms are:\n1.  Every node is either red or black. (Satisfied by description).\n2.  The root is black. (Node $20$ is black, satisfied).\n3.  Every leaf (`NIL`) is black. (Satisfied by description).\n4.  If a node is red, then both its children are black. The red nodes are $27$ and $37$. Their children are all `NIL` (black), so this is satisfied.\n5.  For each node, all simple paths from the node to descendant leaves contain the same number of black nodes (the black-height). The black-height is typically defined as the number of black nodes on a path from a node (not including it) to a leaf. Let's verify from the root ($20$):\n    - Path $20 \\to 10(\\text{B}) \\to 5(\\text{B}) \\to \\mathsf{NIL}(\\text{B})$: Black node count is $3$.\n    - Path $20 \\to 10(\\text{B}) \\to 15(\\text{B}) \\to \\mathsf{NIL}(\\text{B})$: Black node count is $3$.\n    - Path $20 \\to 30(\\text{B}) \\to 25(\\text{B}) \\to (\\text{left})\\mathsf{NIL}(\\text{B})$: Black node count is $3$.\n    - Path $20 \\to 30(\\text{B}) \\to 25(\\text{B}) \\to 27(\\text{R}) \\to \\mathsf{NIL}(\\text{B})$: Black node count is $3$.\n    - Path $20 \\to 30(\\text{B}) \\to 35(\\text{B}) \\to (\\text{left})\\mathsf{NIL}(\\text{B})$: Black node count is $3$.\n    - Path $20 \\to 30(\\text{B}) \\to 35(\\text{B}) \\to 37(\\text{R}) \\to \\mathsf{NIL}(\\text{B})$: Black node count is $3$.\nThe black-height property holds. The initial tree is a valid RBT.\n\nThe problem specifies using the \"canonical deletion algorithm\", but includes a description that is potentially contradictory: \"...moving it [the successor] to x's position causes that grandchild to become the new parent of x's former children.\" The canonical algorithm involves copying the successor's *data* into the node to be deleted and then splicing out the successor node from its original position. The successor *node* itself does not move to the deleted node's position. We will adhere to the \"canonical\" instruction and treat the subsequent sentence as an imprecise description of the process. The problem is thus deemed valid and solvable under this interpretation.\n\n### Deletion Procedure\n\nLet the node to be deleted be $z$. Here, $z$ is the node with key $20$.\nThe initial tree is:\n$$\n\\begin{array}{c}\n20(\\text{B}) \\\\\n/ \\quad \\setminus \\\\\n10(\\text{B}) \\quad 30(\\text{B}) \\\\\n/ \\quad \\setminus \\quad / \\quad \\setminus \\\\\n5(\\text{B}) \\quad 15(\\text{B}) \\quad 25(\\text{B}) \\quad 35(\\text{B}) \\\\\n\\qquad \\qquad \\qquad \\setminus \\qquad \\setminus \\\\\n\\qquad \\qquad \\qquad 27(\\text{R}) \\quad 37(\\text{R})\n\\end{array}\n$$\n\n1.  **Identify Node for Splicing:** Since node $z$ (key $20$) has two children, we must find its in-order successor, let's call it $y$. The successor is the node with the minimum key in $z$'s right subtree. The right subtree is rooted at $30$. The minimum key is found by following left child pointers from $30$, which leads to the node with key $25$. Thus, $y$ is the node with key $25$.\n\n2.  **Transplant Data:** The canonical algorithm copies the key and satellite data of the successor $y$ into the node $z$. The color of $z$ is not changed.\n    - `z.key = y.key` $\\implies$ The node with original key $20$ now has key $25$. It remains black.\n\n3.  **Physical Deletion:** The node that is physically removed (spliced out) from the tree is the successor node, $y$ (the original node with key $25$). Let's track the properties of this node $y$:\n    - `y.key` is $25$.\n    - `y.color` is black.\n    - Node $y$ has a right child, let's call it `x_fixup`, which is the node with key $27$ and color red. `y` has no left child (`NIL`).\n\n4.  **Splicing:** Node $y$ is removed by linking its parent (node $30$) to its child (`x_fixup`, node $27$). Since $y$ was the left child of $30$, the node $27$ becomes the new left child of the node $30$.\n\nThe tree structure immediately after the splice, but before the fix-up procedure, is:\n$$\n\\begin{array}{c}\n25(\\text{B}) \\\\\n/ \\quad \\setminus \\\\\n10(\\text{B}) \\quad 30(\\text{B}) \\\\\n/ \\quad \\setminus \\quad / \\quad \\setminus \\\\\n5(\\text{B}) \\quad 15(\\text{B}) \\quad 27(\\text{R}) \\quad 35(\\text{B}) \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad \\setminus \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad 37(\\text{R})\n\\end{array}\n$$\n\n### Fix-Up Procedure\n\nThe physically removed node $y$ (original key $25$) was black. This violates RBT property 5 (black-height) for any path that passed through the removed node. Therefore, a fix-up procedure must be called. The procedure (`RB-DELETE-FIXUP`) is invoked on the node that replaced $y$, which is `x_fixup` (the node with key $27$).\n\nThe core idea of the fix-up is that the position of `x_fixup` now has an \"extra black\". The standard procedure handles this based on the color of `x_fixup`.\n\n- The node `x_fixup` (key $27$) is **red**.\n- The standard fix-up algorithm (e.g., from CLRS) first checks if the node `x_fixup` itself is red. If it is, the fix-up is simple: the node can absorb the \"extra black\" by being colored black.\n- The main loop of the fix-up procedure has the condition `while x_fixup != root and x_fixup.color == BLACK`.\n- In our case, `x_fixup.color` is red. The condition is false, and the `while` loop is not entered at all.\n- Consequently, no rotations are performed. The number of rotations, $R$, is $0$.\n- After the loop, the algorithm executes the final step: `x_fixup.color = BLACK`. The node with key $27$, which was red, is now colored black. This is a change of color.\n\n### Counting Operations\n\n- **Rotations ($R$):** The fix-up `while` loop was not entered. No rotations were performed.\n  $$ R = 0 $$\n- **Color Changes ($K$):** The color of the node with key $27$ was changed from red to black. This is the only operation that changes a node's color bit.\n  $$ K = 1 $$\n\nThe final valid RBT is:\n$$\n\\begin{array}{c}\n25(\\text{B}) \\\\\n/ \\quad \\setminus \\\\\n10(\\text{B}) \\quad 30(\\text{B}) \\\\\n/ \\quad \\setminus \\quad / \\quad \\setminus \\\\\n5(\\text{B}) \\quad 15(\\text{B}) \\quad 27(\\text{B}) \\quad 35(\\text{B}) \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad \\setminus \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad 37(\\text{R})\n\\end{array}\n$$\nAll RBT properties are satisfied in this final tree.\n\n### Final Calculation\n\nThe problem asks for $C = R + K$.\n$$ C = 0 + 1 = 1 $$", "answer": "$$\\boxed{1}$$", "id": "3265805"}, {"introduction": "Expert problem-solving often involves abstracting away complexity to find a simple, elegant solution. This exercise asks you to identify a deleted key by comparing two trees, a task that might seem to require reverse-engineering the complex rebalancing operations. However, by focusing on the fundamental *effect* of deletion—the removal of a single element from a set—you can devise a surprisingly simple and efficient algorithm. [@problem_id:3265781]", "problem": "You are given two binary search trees with red-black balancing, denoted by $T_1$ and $T_2$, where $T_2$ is allegedly obtained from $T_1$ by deleting exactly one key using the standard red-black deletion procedure. Keys are distinct integers. The objective is to devise and implement an algorithm that determines the unique deleted key using only the following fundamental base:\n\n- Fundamental definitions:\n  - A binary search tree (BST) satisfies: for every node with key $k$, all keys in its left subtree are less than $k$, and all keys in its right subtree are greater than $k$.\n  - A red-black tree is a BST whose nodes are colored red or black and satisfies: the root is black, all leaves (null pointers) are black, no red node has a red child, and every path from a node to its descendant leaves has the same number of black nodes (black-height).\n  - Tree rotations are local pointer changes that preserve the in-order order of keys.\n  - The standard red-black insertion and deletion procedures preserve the BST property and the red-black properties via rotations and recolorings.\n- Well-tested facts:\n  - An in-order traversal of any BST yields the keys in strictly increasing order when all keys are distinct.\n  - Rotations do not change the set of keys or their in-order order; they only change the tree shape and colors.\n\nTask:\n1. Starting from these base definitions and facts, derive an algorithm that, given only the encodings of $T_1$ and $T_2$ as described below, outputs the unique deleted key. The algorithm must not assume any information about how the shapes or colors change, beyond the fundamental properties above.\n2. Provide a proof of correctness grounded in the stated base, and a tight asymptotic analysis of running time and extra space.\n3. Implement the algorithm as a complete, runnable program that also constructs the test trees according to the test suite below using the standard red-black insertion and deletion procedures, encodes them, and then applies your algorithm to obtain the deleted key for each test case.\n\nTree encoding:\n- Each tree is encoded as a tuple $\\left(K, C, L, R, r\\right)$, where:\n  - $K$ is an array of length $n$ of integer keys.\n  - $C$ is an array of length $n$ of colors with $C[i] \\in \\{0, 1\\}$, where $0$ denotes black and $1$ denotes red.\n  - $L$ and $R$ are arrays of length $n$ of child indices, where $L[i]$ is the index of the left child of node $i$ and $R[i]$ is the index of the right child of node $i$; a missing child is encoded as $-1$.\n  - $r$ is the index of the root, or $-1$ if the tree is empty.\n- The encoding induces a valid BST if and only if following the left and right indices from $r$ traverses all nodes and satisfies the BST ordering condition with the keys in $K$.\n\nYour program must:\n- Construct $T_1$ by performing standard red-black insertions of the given sequence of keys in the given order.\n- Construct $T_2$ by performing a standard red-black deletion of the specified single key from $T_1$.\n- Encode $T_1$ and $T_2$ using the encoding above.\n- Apply your derived algorithm to output the deleted key by comparing only these encodings.\n- Aggregate the outputs for all test cases and print them.\n\nTest suite:\n- Case $1$: Insert $[\\,10, 5, 15, 3, 7, 12, 18, 6\\,]$, then delete $7$.\n- Case $2$: Insert $[\\,20, 15, 25, 10, 18, 22, 30, 5, 12, 17, 19, 21, 23\\,]$, then delete $10$.\n- Case $3$: Insert $[\\,1, 2, 3, 4, 5, 6, 7, 8, 9\\,]$, then delete $6$.\n- Case $4$: Insert $[\\,40, 20, 60, 10, 30, 50, 70\\,]$, then delete $10$.\n- Case $5$: Insert $[\\,11, 2, 14, 1, 7, 15, 5, 8\\,]$, then delete $1$.\n- Case $6$: Insert $[\\,42\\,]$, then delete $42$.\n\nAnswer specification:\n- For each case, your program must output the unique deleted key as an integer.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[k_1,k_2,k_3,k_4,k_5,k_6]$, where each $k_i$ is the deleted key for case $i$.\n- No physical units or angle units are involved.\n\nEvaluation criteria:\n- Correctness of the algorithm derived strictly from the fundamental base.\n- Correctness and robustness of the implementation for all test cases, including boundary conditions such as deleting the minimum key and deleting the only key (producing the empty tree).\n- Time complexity and space complexity must be clearly analyzed in your solution. The implementation should reflect the claimed asymptotics.", "solution": "The user-provided problem is assessed to be valid. It is a well-defined problem in the domain of data structures and algorithms, grounded in standard, formal definitions of binary search trees and red-black trees. The problem is self-contained, consistent, and admits a unique, verifiable solution.\n\n### Algorithm Derivation and Proof of Correctness\n\nThe problem requires an algorithm to identify a unique key that has been deleted from a red-black tree $T_1$ to produce another red-black tree $T_2$. The derivation of this algorithm is constrained to a fundamental base of definitions and facts, explicitly forbidding reliance on the specific implementation details of red-black tree rebalancing operations.\n\nLet $S_1$ be the set of keys contained in tree $T_1$, and $S_2$ be the set of keys in $T_2$. The problem states that $T_2$ is obtained from $T_1$ by deleting exactly one key, which we shall call $k_d$.\n\nThe standard procedure for deleting a key from a binary search tree, including a red-black tree, consists of two main phases:\n1.  The removal of a node from the tree. This operation alters the set of keys. If the deleted key is $k_d$, the node containing $k_d$ (or its in-order successor, whose key is then moved into the position of the node for $k_d$) is physically removed from the tree's structure. In either case, the net effect on the set of keys is the removal of the single key $k_d$.\n2.  A sequence of rebalancing operations (rotations and recolorings) to restore the red-black properties. The problem provides a \"well-tested fact\" that is critical here: rotations do not change the set of keys or their in-order order. Similarly, recoloring a node only changes a property of the node, not its key or its existence.\n\nFrom these points, we can formally relate the key sets $S_1$ and $S_2$. The transformation from $T_1$ to $T_2$ involves operations that either remove the single key $k_d$ or do not change the set of keys at all. Therefore, the set of keys in $T_2$ is precisely the set of keys in $T_1$ excluding $k_d$. Mathematically, this is expressed as:\n$$ S_2 = S_1 \\setminus \\{k_d\\} $$\nThis implies that the set difference $S_1 \\setminus S_2$ contains exactly one element, which is the deleted key $k_d$:\n$$ S_1 \\setminus S_2 = \\{k_d\\} $$\nThe problem provides the complete encoding of both trees, $T_1$ and $T_2$. The encoding for a tree with $n$ nodes is given as a tuple $(K, C, L, R, r)$, where $K$ is an array of length $n$ containing all integer keys present in the tree. Thus, the set of keys $S_1$ for tree $T_1$ is simply the set of elements in its key array, $K_1$. Likewise, $S_2$ is the set of elements in $K_2$.\n\nThis directly leads to the following algorithm:\n1.  From the encoding of $T_1$, extract the key array $K_1$.\n2.  From the encoding of $T_2$, extract the key array $K_2$.\n3.  Compute the unique element in the set difference of the elements of $K_1$ and the elements of $K_2$. This element is the deleted key $k_d$.\n\nThis algorithm adheres strictly to the problem's constraints, as it relies only on the definition of deletion as an operation that removes an element from a set, a consequence of the provided base facts. It correctly abstracts away the complex and irrelevant details of rotations and recolorings.\n\n### Complexity Analysis\n\nLet $n$ be the number of keys in the initial tree $T_1$. The number of keys in $T_2$ is then $n-1$.\n\n-   **Time Complexity**: This is determined by the most efficient method to find the single element difference between two collections of keys, $K_1$ (size $n$) and $K_2$ (size $n-1$).\n    1.  Construct a hash set from the keys in $K_2$. This takes $O(n-1) = O(n)$ time on average.\n    2.  Iterate through the keys in $K_1$. For each key, check for its presence in the hash set. This takes $O(1)$ time per key on average. The first key from $K_1$ not found in the set is the deleted key. In the worst case, this requires iterating through all $n$ keys of $K_1$. This step takes $O(n)$ time.\n    \n    The total time complexity is $O(n) + O(n) = O(n)$. This is asymptotically optimal, as any algorithm must, at a minimum, examine all the keys in one of the trees to ascertain the difference, which requires $\\Omega(n)$ time.\n\n-   **Space Complexity**: The algorithm requires additional space to store the hash set of keys from $K_2$. This set will contain $n-1$ elements.\n    \n    The extra space complexity is therefore $O(n)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Node class for Red-Black Tree\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.parent = None\n        self.left = None\n        self.right = None\n        self.color = 1  # 1 for Red, 0 for Black\n\n# Red-Black Tree Implementation\nclass RedBlackTree:\n    def __init__(self):\n        self.TNULL = Node(0)\n        self.TNULL.color = 0\n        self.TNULL.left = None\n        self.TNULL.right = None\n        self.root = self.TNULL\n\n    def left_rotate(self, x):\n        y = x.right\n        x.right = y.left\n        if y.left != self.TNULL:\n            y.left.parent = x\n\n        y.parent = x.parent\n        if x.parent is None:\n            self.root = y\n        elif x == x.parent.left:\n            x.parent.left = y\n        else:\n            x.parent.right = y\n        y.left = x\n        x.parent = y\n\n    def right_rotate(self, x):\n        y = x.left\n        x.left = y.right\n        if y.right != self.TNULL:\n            y.right.parent = x\n\n        y.parent = x.parent\n        if x.parent is None:\n            self.root = y\n        elif x == x.parent.right:\n            x.parent.right = y\n        else:\n            x.parent.left = y\n        y.right = x\n        x.parent = y\n\n    def insert(self, key):\n        node = Node(key)\n        node.parent = None\n        node.left = self.TNULL\n        node.right = self.TNULL\n        node.color = 1  # New node is always red\n\n        y = None\n        x = self.root\n\n        while x != self.TNULL:\n            y = x\n            if node.key < x.key:\n                x = x.left\n            else:\n                x = x.right\n\n        node.parent = y\n        if y is None:\n            self.root = node\n        elif node.key < y.key:\n            y.left = node\n        else:\n            y.right = node\n\n        if node.parent is None:\n            node.color = 0\n            return\n\n        if node.parent.parent is None:\n            return\n\n        self.insert_fixup(node)\n\n    def insert_fixup(self, k):\n        while k.parent.color == 1:\n            if k.parent == k.parent.parent.right:\n                u = k.parent.parent.left  # Uncle\n                if u.color == 1:\n                    u.color = 0\n                    k.parent.color = 0\n                    k.parent.parent.color = 1\n                    k = k.parent.parent\n                else:\n                    if k == k.parent.left:\n                        k = k.parent\n                        self.right_rotate(k)\n                    k.parent.color = 0\n                    k.parent.parent.color = 1\n                    self.left_rotate(k.parent.parent)\n            else:\n                u = k.parent.parent.right  # Uncle\n                if u.color == 1:\n                    u.color = 0\n                    k.parent.color = 0\n                    k.parent.parent.color = 1\n                    k = k.parent.parent\n                else:\n                    if k == k.parent.right:\n                        k = k.parent\n                        self.left_rotate(k)\n                    k.parent.color = 0\n                    k.parent.parent.color = 1\n                    self.right_rotate(k.parent.parent)\n            if k == self.root:\n                break\n        self.root.color = 0\n\n    def transplant(self, u, v):\n        if u.parent is None:\n            self.root = v\n        elif u == u.parent.left:\n            u.parent.left = v\n        else:\n            u.parent.right = v\n        v.parent = u.parent\n\n    def minimum(self, node):\n        while node.left != self.TNULL:\n            node = node.left\n        return node\n\n    def get_node(self, key):\n        node = self.root\n        while node != self.TNULL and key != node.key:\n            if key < node.key:\n                node = node.left\n            else:\n                node = node.right\n        return node\n    \n    def delete(self, key):\n        z = self.get_node(key)\n        if z == self.TNULL:\n            return  # Key not found\n\n        y = z\n        y_original_color = y.color\n        if z.left == self.TNULL:\n            x = z.right\n            self.transplant(z, z.right)\n        elif z.right == self.TNULL:\n            x = z.left\n            self.transplant(z, z.left)\n        else:\n            y = self.minimum(z.right)\n            y_original_color = y.color\n            x = y.right\n            if y.parent == z:\n                x.parent = y\n            else:\n                self.transplant(y, y.right)\n                y.right = z.right\n                y.right.parent = y\n\n            self.transplant(z, y)\n            y.left = z.left\n            y.left.parent = y\n            y.color = z.color\n        \n        if y_original_color == 0:\n            self.delete_fixup(x)\n        \n        # After deletion, if root becomes NIL, make it TNULL\n        if self.root is None:\n            self.root = self.TNULL\n\n    def delete_fixup(self, x):\n        while x != self.root and x.color == 0:\n            if x == x.parent.left:\n                s = x.parent.right\n                if s.color == 1:\n                    s.color = 0\n                    x.parent.color = 1\n                    self.left_rotate(x.parent)\n                    s = x.parent.right\n\n                if s.left.color == 0 and s.right.color == 0:\n                    s.color = 1\n                    x = x.parent\n                else:\n                    if s.right.color == 0:\n                        s.left.color = 0\n                        s.color = 1\n                        self.right_rotate(s)\n                        s = x.parent.right\n\n                    s.color = x.parent.color\n                    x.parent.color = 0\n                    s.right.color = 0\n                    self.left_rotate(x.parent)\n                    x = self.root\n            else:\n                s = x.parent.left\n                if s.color == 1:\n                    s.color = 0\n                    x.parent.color = 1\n                    self.right_rotate(x.parent)\n                    s = x.parent.left\n\n                if s.right.color == 0 and s.left.color == 0:\n                    s.color = 1\n                    x = x.parent\n                else:\n                    if s.left.color == 0:\n                        s.right.color = 0\n                        s.color = 1\n                        self.left_rotate(s)\n                        s = x.parent.left\n\n                    s.color = x.parent.color\n                    x.parent.color = 0\n                    s.left.color = 0\n                    self.right_rotate(x.parent)\n                    x = self.root\n        x.color = 0\n\n    def encode_tree(self):\n        if self.root == self.TNULL:\n            return ([], [], [], [], -1)\n\n        nodes_in_order = []\n        q = [self.root]\n        \n        nodes_in_order.append(self.root)\n        head = 0\n        while head < len(nodes_in_order):\n            node = nodes_in_order[head]\n            head += 1\n            if node.left != self.TNULL:\n                nodes_in_order.append(node.left)\n            if node.right != self.TNULL:\n                nodes_in_order.append(node.right)\n        \n        node_to_idx = {node: i for i, node in enumerate(nodes_in_order)}\n        n = len(nodes_in_order)\n        K = [0] * n\n        C = [0] * n\n        L = [-1] * n\n        R = [-1] * n\n        \n        for i, node in enumerate(nodes_in_order):\n            K[i] = node.key\n            C[i] = node.color\n            if node.left != self.TNULL:\n                L[i] = node_to_idx[node.left]\n            if node.right != self.TNULL:\n                R[i] = node_to_idx[node.right]\n        \n        r = node_to_idx[self.root]\n        return (K, C, L, R, r)\n\ndef find_deleted_key(encoding1, encoding2):\n    \"\"\"\n    Finds the single deleted key by comparing the key arrays of two tree encodings.\n    \"\"\"\n    K1, _, _, _, _ = encoding1\n    K2, _, _, _, _ = encoding2\n\n    # Handle the case where the tree becomes empty after deletion.\n    if not K2:\n        return K1[0]\n\n    set_K2 = set(K2)\n    for key in K1:\n        if key not in set_K2:\n            return key\n    \n    # This part of the code should not be reachable given the problem statement.\n    return None\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'insert': [10, 5, 15, 3, 7, 12, 18, 6], 'delete': 7},\n        {'insert': [20, 15, 25, 10, 18, 22, 30, 5, 12, 17, 19, 21, 23], 'delete': 10},\n        {'insert': [1, 2, 3, 4, 5, 6, 7, 8, 9], 'delete': 6},\n        {'insert': [40, 20, 60, 10, 30, 50, 70], 'delete': 10},\n        {'insert': [11, 2, 14, 1, 7, 15, 5, 8], 'delete': 1},\n        {'insert': [42], 'delete': 42}\n    ]\n\n    results = []\n    for case in test_cases:\n        # 1. Construct T1\n        t1 = RedBlackTree()\n        for key in case['insert']:\n            t1.insert(key)\n        \n        # 2. Encode T1\n        encoding1 = t1.encode_tree()\n\n        # 3. Construct T2 by deleting from T1\n        t1.delete(case['delete'])\n        \n        # 4. Encode T2\n        encoding2 = t1.encode_tree()\n\n        # 5. Apply the derived algorithm to find the deleted key\n        deleted_key = find_deleted_key(encoding1, encoding2)\n        results.append(deleted_key)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3265781"}]}