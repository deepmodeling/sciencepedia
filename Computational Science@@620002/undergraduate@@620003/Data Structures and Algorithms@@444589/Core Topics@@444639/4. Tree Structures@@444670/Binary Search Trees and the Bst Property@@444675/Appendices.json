{"hands_on_practices": [{"introduction": "One of the most powerful properties of a Binary Search Tree is that its in-order traversal yields a perfectly sorted sequence of keys. This exercise challenges you to use this property as a diagnostic tool to solve what appears to be a complex tree problem with a simple sequence analysis. By determining if a binary tree can become a valid BST with at most one swap, you will deepen your understanding of the fundamental link between a tree's structure and its in-order traversal sequence [@problem_id:3215353].", "problem": "You are given the task to determine, for a collection of binary trees, whether each tree can be transformed into a Binary Search Tree (BST) by performing at most one swap of values between two nodes. The transformation must preserve the original tree shape; only the values stored at nodes may be swapped.\n\nUse the following fundamental base:\n- A binary tree is a node-labeled, rooted tree in which each node has up to two children, called the left and right child.\n- A Binary Search Tree (BST) over pairwise distinct integers satisfies the property that for every node with key $k$, all keys in its left subtree are strictly less than $k$, and all keys in its right subtree are strictly greater than $k$.\n- An in-order traversal of a BST yields a strictly increasing sequence of keys.\n- Swapping the values of exactly two nodes in the tree corresponds exactly to swapping the values at two positions in the in-order traversal sequence produced from that tree shape.\n\nAssumptions:\n- All node values are pairwise distinct integers.\n- The trees are represented in level-order (breadth-first order) as arrays. The root is at index $0$. For any node stored at index $i$, its left child is at index $2i+1$ and its right child is at index $2i+2$. If a child does not exist, its corresponding array entry is the token `None`. No node appears as a child if its parent is `None`.\n\nYour task:\n- For each provided test case, determine a boolean value: `true` if the tree can be made into a BST by at most $1$ swap of two node values (or if it is already a BST), and `false` otherwise.\n- Your program must not read input. It should use the test suite embedded below and produce the required output format precisely.\n\nTest suite (each case is a level-order array with `None` denoting a missing child; numbers are integers):\n- `[]`.\n- `[5]`.\n- `[2,1,3]`.\n- `[3,1,4, None, None, 2]`.\n- `[3,2,1]`.\n- `[10,5,15,1,12]`.\n- `[2,1,4,3]`.\n- `[2, None, 3]`.\n- `[2,3,4,1]`.\n\nAnswer specification:\n- For each test case, output a boolean: `true` or `false`.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, if there are three cases, a valid output is `[true,false,true]`. Use lowercase literals \"true\" and \"false\" for booleans.", "solution": "The problem requires us to determine if a given binary tree can be transformed into a Binary Search Tree (BST) by performing at most one swap of values between two nodes. The core of the solution rests on a fundamental property of BSTs and their relationship with in-order traversals.\n\nA key principle, provided in the problem statement, is that an in-order traversal of a valid BST yields a sequence of node values that is strictly increasing. Furthermore, swapping the values of two nodes in the tree directly corresponds to swapping the positions of those two values in the sequence generated by an in-order traversal of that tree's structure. This insight allows us to reframe the problem from one of tree manipulation to one of sequence analysis.\n\nLet the given binary tree, represented by a level-order array, be denoted by $T$. The sequence of node values obtained from an in-order traversal of $T$ is denoted by $S_{\\text{inorder}}$. Since all node values are stated to be pairwise distinct integers, a correctly formed BST on these same values would have an in-order traversal sequence that is simply the sorted version of these values. Let this target sequence be denoted by $S_{\\text{sorted}}$, which is obtained by sorting the elements of $S_{\\text{inorder}}$ in strictly ascending order.\n\nThe problem is now equivalent to answering the question: can the sequence $S_{\\text{inorder}}$ be transformed into the sequence $S_{\\text{sorted}}$ by performing at most one swap of two elements?\n\nTo answer this, we compare $S_{\\text{inorder}}$ and $S_{\\text{sorted}}$ element by element and count the number of positions at which they differ. Let this count of mismatches be denoted by $d$.\n\nWe analyze the possible values of $d$:\n\n1.  Case $d=0$: If there are zero mismatches, $S_{\\text{inorder}}$ is identical to $S_{\\text{sorted}}$. This means the sequence is already sorted, and thus the original tree $T$ is already a valid BST. This requires $0$ swaps, which satisfies the condition of \"at most one swap\". The result is `true`.\n\n2.  Case $d=2$: If there are exactly two mismatches, it implies that two elements are out of their sorted positions. For example, suppose $S_{\\text{inorder}}[i] \\neq S_{\\text{sorted}}[i]$ and $S_{\\text{inorder}}[j] \\neq S_{\\text{sorted}}[j]$ for $i \\neq j$, and all other elements are in their correct positions. Since all values are unique and both sequences contain the same set of values, it must be that $S_{\\text{inorder}}[i] = S_{\\text{sorted}}[j]$ and $S_{\\text{inorder}}[j] = S_{\\text{sorted}}[i]$. A single swap of the elements at positions $i$ and $j$ in $S_{\\text{inorder}}$ will correct both positions simultaneously, making the sequence sorted. This corresponds to exactly one swap of node values in the tree $T$. This satisfies the condition of \"at most one swap\". The result is `true`.\n\n3.  Case $d>2$: If there are more than two mismatches, the elements are displaced in a way that cannot be resolved with a single swap. For example, a cyclic permutation of three elements, such as $S_{\\text{inorder}} = [\\dots, c, \\dots, a, \\dots, b, \\dots]$ where $S_{\\text{sorted}} = [\\dots, a, \\dots, b, \\dots, c, \\dots]$, requires at least two swaps to sort. Therefore, if $d > 2$, the condition is not met. The result is `false`.\n\n4.  Case $d=1$: This case is impossible. If a single element at position $i$ is a mismatch, meaning $S_{\\text{inorder}}[i] = v_1$ while $S_{\\text{sorted}}[i] = v_2$ (with $v_1 \\neq v_2$), then the value $v_2$ must appear somewhere else in $S_{\\text{inorder}}$, say at position $j$, where $S_{\\text{inorder}}[j] = v_2$. Since all values are unique, $j \\neq i$. The value at $S_{\\text{sorted}}[j]$ cannot be $v_2$, so the element at position $j$ is also a mismatch. Thus, mismatches must occur in pairs or larger groups, and $d$ can never be $1$.\n\nTherefore, the tree can be made a BST with at most one swap if and only if the number of mismatches $d$ is either $0$ or $2$. The algorithm is as follows:\n\n1.  For the given tree represented as a level-order array, construct the in-order traversal sequence, $S_{\\text{inorder}}$. This can be achieved with a recursive function that, for a node at index $i$, first processes its left child (at index $2i+1$), then records the value at index $i$, and finally processes its right child (at index $2i+2$). The recursion terminates for indices that are out of bounds or correspond to a `None` value.\n2.  Create a sorted version of this sequence, $S_{\\text{sorted}}$.\n3.  Calculate the number of mismatches, $d$, by comparing $S_{\\text{inorder}}$ and $S_{\\text{sorted}}$.\n4.  If $d \\le 2$, the condition is met, and the result is `true`. Otherwise, the result is `false`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the entire test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],\n        [5],\n        [2, 1, 3],\n        [3, 1, 4, None, None, 2],\n        [3, 2, 1],\n        [10, 5, 15, 1, 12],\n        [2, 1, 4, 3],\n        [2, None, 3],\n        [2, 3, 4, 1],\n    ]\n\n    def is_recoverable(tree_array):\n        \"\"\"\n        Determines if a binary tree can be made a BST with at most one swap.\n\n        Args:\n            tree_array: A list representing the tree in level-order.\n\n        Returns:\n            A boolean, True if recoverable, False otherwise.\n        \"\"\"\n        # An empty tree is a valid, sorted structure.\n        if not tree_array:\n            return True\n\n        inorder_seq = []\n        \n        def get_inorder(idx):\n            \"\"\"\n            Recursively performs an in-order traversal on the level-order array.\n            \n            Args:\n                idx: The index of the current node in tree_array.\n            \"\"\"\n            # Base case: if index is out of bounds or the node is None.\n            if idx = len(tree_array) or tree_array[idx] is None:\n                return\n            \n            # 1. Recurse on the left child.\n            get_inorder(2 * idx + 1)\n            \n            # 2. Visit (append) the current node's value.\n            inorder_seq.append(tree_array[idx])\n            \n            # 3. Recurse on the right child.\n            get_inorder(2 * idx + 2)\n\n        # Start the traversal from the root at index 0.\n        get_inorder(0)\n        \n        # If the traversal results in an empty list (e.g., tree was [None]), \n        # it is considered a valid (empty) BST.\n        if not inorder_seq:\n            return True\n\n        # The target sequence for a BST is the sorted in-order sequence.\n        sorted_seq = sorted(inorder_seq)\n        \n        # Convert lists to NumPy arrays for efficient comparison.\n        inorder_np = np.array(inorder_seq)\n        sorted_np = np.array(sorted_seq)\n        \n        # Count the number of positions where the elements differ.\n        mismatches = np.sum(inorder_np != sorted_np)\n        \n        # A tree is recoverable by at most one swap if it's already a BST\n        # (0 mismatches) or if exactly two elements are swapped (2 mismatches).\n        return mismatches = 2\n\n    results = [is_recoverable(case) for case in test_cases]\n    \n    # Format the results as a list of lowercase boolean strings.\n    results_str = [str(r).lower() for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3215353"}, {"introduction": "While verifying a BST is important, constructing one efficiently is a fundamental skill for any programmer. This practice guides you through building a BST of minimum possible height from a sorted list of keys, which is the tree's natural in-order traversal. Mastering this construction is key to understanding how balanced structures are created to guarantee the logarithmic time complexity, such as $O(\\log n)$, that makes BSTs a cornerstone of efficient data management [@problem_id:3215469].", "problem": "You are given several finite sequences of distinct integers. For each sequence, your task is to construct a Binary Search Tree (BST) of minimum possible height that has exactly the given sequence as its inorder traversal. The program you produce must operate in purely algorithmic terms and must be self-contained: it must not read from standard input or external files, and it must not produce any output other than the required final line.\n\nFundamental base for this task:\n- A Binary Search Tree (BST) on distinct keys satisfies the BST property: for every node with key $k$, all keys in its left subtree are strictly less than $k$, and all keys in its right subtree are strictly greater than $k$.\n- The inorder traversal of any BST with distinct keys yields the keys in strictly increasing order.\n- The height of a tree is defined as the number of edges on the longest simple path from the root to any leaf; by convention, the empty tree has height $-1$.\n- Time complexity is measured using the standard asymptotic notation $O(\\cdot)$; you must construct the BST in $O(n)$ time for a sequence of length $n$.\n\nYour task:\n- For each provided test sequence $A$, where $A$ is strictly increasing (so that the inorder target is already determined), construct a BST that has $A$ as its inorder traversal and whose height is the minimum possible among all BSTs whose inorder traversal is $A$.\n- After constructing the BST for each $A$, compute:\n  1. The height $h(A)$ of the constructed tree, using the convention that the empty tree has height $-1$.\n  2. A boolean $b_{\\mathrm{bst}}(A)$ indicating whether the constructed structure satisfies the strict BST property for all nodes.\n  3. A boolean $b_{\\mathrm{in}}(A)$ indicating whether the inorder traversal of the constructed tree equals $A$ element-by-element.\n  4. A boolean $b_{\\min}(A)$ indicating whether $h(A)$ attains the information-theoretic lower bound on height for any binary tree with $n$ nodes, namely\n     $$\\boxed{h^\\star(n) = \\begin{cases}\n     -1  \\text{if } n = 0,\\\\\n     \\lceil \\log_2(n+1) \\rceil - 1  \\text{if } n \\ge 1,\n     \\end{cases}}$$\n     where $n$ is the length of $A$.\n\nAll sequences are strictly increasing and contain distinct integers, so the strict BST property is well-defined.\n\nPerformance requirement:\n- Your construction algorithm for each sequence of length $n$ must run in $O(n)$ time and $O(n)$ space.\n\nTest suite:\nLet the sequences be exactly the following:\n- $A_1 = [\\,]$ (the empty sequence).\n- $A_2 = [\\,42\\,]$.\n- $A_3 = [\\,1,2\\,]$.\n- $A_4 = [\\,1,2,3,4,5\\,]$.\n- $A_5 = [\\,1,2,3,4,5,6,7\\,]$.\n- $A_6 = [\\,10,20,30,40,50,60,70,80\\,]$.\n- $A_7 = [\\,3,9,12,27,31,44,58,60,72,90,101\\,]$.\n\nRequired final output format:\n- Your program should produce a single line of output containing a list of $7$ results, one for each $A_i$ in order from $i=1$ to $i=7$.\n- Each result must itself be a list of four items in the order $[\\,h(A_i), b_{\\mathrm{bst}}(A_i), b_{\\mathrm{in}}(A_i), b_{\\min}(A_i)\\,]$.\n- The entire output must be a single line, with no spaces anywhere, using square brackets and commas only. For example, an output for three hypothetical cases would follow the pattern\n  $$[ [\\,\\cdot,\\cdot,\\cdot,\\cdot\\,], [\\,\\cdot,\\cdot,\\cdot,\\cdot\\,], [\\,\\cdot,\\cdot,\\cdot,\\cdot\\,] ]$$\n  but without any spaces. Concretely, your program must print exactly a single line like\n  $$[[r_{11},r_{12},r_{13},r_{14}],[r_{21},r_{22},r_{23},r_{24}],\\dots,[r_{71},r_{72},r_{73},r_{74}]],$$\n  where each $r_{ij}$ is either an integer or a boolean literal.", "solution": "### Algorithmic Solution\nThe problem requires constructing a Binary Search Tree (BST) of minimal height from a given sequence of keys, which is already sorted. The fact that the input sequence $A$ is sorted implies that it is the unique inorder traversal for any BST built from these keys.\n\n**Principle of Construction**\n\nThe fundamental property of an inorder traversal is that it visits all nodes in the left subtree, then the root, then all nodes in the right subtree. To construct a BST from its inorder traversal $A$, if we select an element $A[i]$ as the root, all elements in the prefix $A[0 \\dots i-1]$ must form the left subtree, and all elements in the suffix $A[i+1 \\dots n-1]$ must form the right subtree.\n\nTo achieve a tree of minimum height, the number of nodes in the left and right subtrees must be as balanced as possible at every level of recursion. For a sorted array segment $A[\\text{start} \\dots \\text{end}]$, the optimal choice for the root is the median element, $A[\\text{mid}]$, where $\\text{mid}$ is the middle index of the segment. This choice partitions the remaining elements into two sub-arrays of sizes $\\lfloor (N-1)/2 \\rfloor$ and $\\lceil (N-1)/2 \\rceil$, where $N$ is the number of elements in the segment. This strategy guarantees the construction of a height-balanced tree, thus achieving the minimum possible height.\n\n**Algorithm Design**\n\nA recursive algorithm based on this principle can be designed. Let's define a function `build(A, start, end)` that constructs a minimal-height BST from the sub-array $A[\\text{start} \\dots \\text{end}]$.\n\n1.  **Base Case**: If `start  end`, the array segment is empty, so we return `None` to represent an empty subtree.\n2.  **Recursive Step**:\n    a. Calculate the middle index: `mid = start + (end - start) // 2`.\n    b. Create a new tree node with the key $A[\\text{mid}]$. This node is the root of the current subtree.\n    c. Recursively build the left subtree by calling `build(A, start, mid - 1)`. The result is assigned as the left child of the root.\n    d. Recursively build the right subtree by calling `build(A, mid + 1, end)`. The result is assigned as the right child of the root.\n    e. Return the newly created root node.\n\nThe initial call to construct the entire tree from sequence $A$ of length $n$ would be `build(A, 0, n - 1)`.\n\n**Complexity Analysis**\n\n-   **Time Complexity**: The `build` function is called exactly once for each element in the input array $A$. The work done within each call (calculating `mid`, creating a node) is constant, i.e., $O(1)$. Therefore, the total time complexity is linear in the number of elements, $O(n)$. It is crucial that sub-arrays are not passed by value (slicing), as this would degrade performance to $O(n \\log n)$. Passing indices achieves the required $O(n)$ complexity.\n-   **Space Complexity**: The algorithm requires space to store the constructed tree, which has $n$ nodes, contributing $O(n)$ space. The recursion stack depth is equal to the height of the tree. Since the tree is balanced, its height is $O(\\log n)$. Thus, the total space complexity is dominated by the storage of the tree itself, which is $O(n)$. Both complexity metrics satisfy the problem's constraints.\n\n**Verification Procedures**\n\nAfter constructing the tree for each sequence $A$, the following four properties must be verified:\n\n1.  **Height, $h(A)$**: The height of a tree rooted at `node` is computed recursively:\n    -   If `node` is `None`, height is $-1$.\n    -   Otherwise, height is $1 + \\max(\\text{height}(\\text{node.left}), \\text{height}(\\text{node.right}))$.\n\n2.  **BST Property, $b_{\\mathrm{bst}}(A)$**: A recursive function `is_bst(node, min_bound, max_bound)` can validate this property. For each `node`, it checks if `min_bound  node.key  max_bound`. The check then recurses on the left child with updated bounds `(min_bound, node.key)` and on the right child with bounds `(node.key, max_bound)`. The initial call for the root would be `is_bst(root, -infinity, +infinity)`. By virtue of the construction algorithm, this will always be `True`.\n\n3.  **Inorder Traversal, $b_{\\mathrm{in}}(A)$**: An inorder traversal is performed on the constructed tree, collecting the keys into a new sequence $A'$. This is done by recursively visiting the left subtree, then the root, then the right subtree. Finally, $A'$ is compared element-by-element with the original input $A$. They must be identical, so this check will also always yield `True`.\n\n4.  **Minimal Height, $b_{\\min}(A)$**: The computed height $h(A)$ is compared to the theoretical minimum height $h^\\star(n)$. For $n \\ge 1$, this is $h^\\star(n) = \\lceil \\log_2(n+1) \\rceil - 1$. An efficient, equivalent computation in Python for $n \\ge 1$ is `n.bit_length() - 1`. The construction algorithm is guaranteed to produce a tree of this minimal height, so this check will also always result in `True`. For $n=0$, $h(A)=-1$ and $h^\\star(0)=-1$, so it is also `True`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nimport sys\n\n# It is good practice to increase recursion limit for deep recursion, although not strictly necessary for the given test cases.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"A node in a binary search tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite by constructing and validating\n    minimum-height BSTs from sorted sequences.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],\n        [42],\n        [1, 2],\n        [1, 2, 3, 4, 5],\n        [1, 2, 3, 4, 5, 6, 7],\n        [10, 20, 30, 40, 50, 60, 70, 80],\n        [3, 9, 12, 27, 31, 44, 58, 60, 72, 90, 101],\n    ]\n\n    results = []\n    for A in test_cases:\n        n = len(A)\n        \n        # Construct the BST of minimum height\n        root = _build_min_height_bst(A, 0, n - 1)\n        \n        # 1. Compute the height h(A)\n        h_A = _get_height(root)\n        \n        # 2. Check if the BST property is satisfied\n        b_bst_A = _is_bst(root, float('-inf'), float('inf'))\n        \n        # 3. Check if the inorder traversal matches the input sequence\n        inorder_traversal = _get_inorder(root)\n        b_in_A = (inorder_traversal == A)\n        \n        # 4. Check if the height is the theoretical minimum\n        if n == 0:\n            h_star_n = -1\n        else:\n            # h*(n) = ceil(log2(n+1)) - 1\n            # In integer arithmetic for n = 1, this is n.bit_length() - 1.\n            # Example: n=7, n.bit_length()=3, h=2. log2(8)=3, h=2. Correct.\n            # Example: n=8, n.bit_length()=4, h=3. log2(9)~3.17, ceil=4, h=3. Correct.\n            h_star_n = n.bit_length() - 1\n        \n        b_min_A = (h_A == h_star_n)\n        \n        results.append([h_A, b_bst_A, b_in_A, b_min_A])\n\n    # Format the final output string as required: no spaces.\n    outer_parts = []\n    for res in results:\n        # Convert each item in the inner list to a string and join with commas\n        # Note: str(True) is 'True', str(False) is 'False'\n        inner_str = ','.join([str(item).lower() if isinstance(item, bool) else str(item) for item in res])\n        outer_parts.append(f\"[{inner_str}]\")\n    \n    final_output = f\"[{','.join(outer_parts)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\ndef _build_min_height_bst(array, start, end):\n    \"\"\"\n    Recursively builds a BST of minimum height from a sorted array segment.\n    Time: O(N), Space: O(log N) for recursion stack + O(N) for tree = O(N)\n    \"\"\"\n    if start  end:\n        return None\n    \n    # Choose the middle element as the root to ensure balance\n    mid = start + (end - start) // 2\n    \n    node = Node(array[mid])\n    node.left = _build_min_height_bst(array, start, mid - 1)\n    node.right = _build_min_height_bst(array, mid + 1, end)\n    \n    return node\n\ndef _get_height(node):\n    \"\"\"Computes the height of the tree (number of edges from root to furthest leaf).\"\"\"\n    if node is None:\n        return -1 # Height of an empty tree is -1 by convention\n    \n    return 1 + max(_get_height(node.left), _get_height(node.right))\n\ndef _is_bst(node, min_bound, max_bound):\n    \"\"\"\n    Recursively validates the BST property for each node.\n    A node's key must be within the bounds set by its ancestors.\n    \"\"\"\n    if node is None:\n        return True\n    \n    if not (min_bound  node.key  max_bound):\n        return False\n        \n    return (_is_bst(node.left, min_bound, node.key) and\n            _is_bst(node.right, node.key, max_bound))\n\ndef _get_inorder(root):\n    \"\"\"Performs an inorder traversal and returns the keys as a list.\"\"\"\n    result = []\n    \n    def traverse(node):\n        if node is None:\n            return\n        traverse(node.left)\n        result.append(node.key)\n        traverse(node.right)\n        \n    traverse(root)\n    return result\n\nsolve()\n```", "id": "3215469"}, {"introduction": "Real-world data is rarely perfect, and a binary tree you encounter may not be a valid BST, but it could contain one. This advanced problem asks you to find the largest rooted subtree within an arbitrary binary tree that satisfies the BST property. Solving this requires a clever recursive approach that verifies the BST property from the bottom up, passing information about subtree validity, size, and key boundaries to parent nodes, offering a masterclass in solving complex tree problems [@problem_id:3215484].", "problem": "You are given several finite rooted binary trees where each node stores an integer key. A binary tree is defined recursively as either empty or a node with a left binary tree and a right binary tree. For any node $u$ with key $k(u)$, the subtree rooted at $u$ is the node $u$ together with all of its descendants. A Binary Search Tree (BST) is a binary tree in which, for every node $u$ with key $k(u)$, all keys in the left subtree of $u$ are strictly less than $k(u)$, and all keys in the right subtree of $u$ are strictly greater than $k(u)$. Duplicates are allowed in the input trees, but any subtree containing equal keys on the same side will violate the strict inequalities required by the Binary Search Tree (BST) property.\n\nThe task is to compute, for each provided tree $T$, the integer $S(T)$ defined as the number of nodes in the largest rooted subtree of $T$ that satisfies the Binary Search Tree (BST) property. The largest subtree must be a rooted subtree, meaning it consists of some node and all of its descendants.\n\nFundamental base and constraints:\n- Use the core definitions of binary trees, subtrees, and the Binary Search Tree (BST) property stated above.\n- Use well-tested facts only as starting points, such as that an in-order traversal of a Binary Search Tree (BST) yields a strictly increasing sequence of keys, and that the Binary Search Tree (BST) property can be enforced by maintaining ranges for allowable keys across subtrees.\n- Do not assume or use any specialized shortcut formulas beyond these foundations.\n\nInput representation for the provided trees:\n- Each tree is supplied as a level-order list of values where the $i$-th element corresponds to a node, its left child (if any) is at index $2i+1$, and its right child (if any) is at index $2i+2$.\n- The marker `None` denotes a missing child.\n- An empty list denotes the empty tree.\n\nYou must write a complete, runnable program that constructs the trees below internally (no input is read) and computes $S(T)$ for each. The trees are:\n\n- Test case $1$ (general non-BST with a valid Binary Search Tree (BST) subtree): `[10, 5, 15, 1, 8, None, 7]`.\n- Test case $2$ (entire tree is a Binary Search Tree (BST)): `[5, 3, 8, 2, 4, 6, 9]`.\n- Test case $3$ (contains duplicates that break the Binary Search Tree (BST) property globally): `[5, 1, 5, 0, 2, 5, 6]`.\n- Test case $4$ (Binary Search Tree (BST) with negative keys): `[-3, -5, 2, -6, -4, 0, 3]`.\n- Test case $5$ (empty tree): `[]`.\n- Test case $6$ (sparse non-Binary Search Tree (BST) where a proper right subtree is a Binary Search Tree (BST)): `[5, 2, 4, 1, None, 3, 6]`.\n\nOutput specification:\n- For each test case in the order listed, compute $S(T)$, the size (node count) of the largest rooted subtree that satisfies the Binary Search Tree (BST) property.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets and ordered by test case. For example, the format is `[r_1,r_2,r_3,...,r_m]`, where $r_i$ is the result for test case $i$.\n\nThere are no physical units, angles, or percentages involved in this problem. All answers are integers.", "solution": "### Solution Algorithm\nThe problem asks for the size of the largest rooted subtree that is a Binary Search Tree (BST). This implies that for each node in the given tree, we must determine if the subtree rooted at that node is a BST and, if so, what its size is. The final answer is the maximum size found across all nodes.\n\nA post-order traversal is a natural strategy for this task. When visiting a node `n`, we first process its left and right subtrees. The information gathered from the children can then be used to determine the properties of the subtree rooted at `n`.\n\nFor any given node `n` with key $k(n)$, to verify if the subtree rooted at `n` is a BST, we require the following conditions to be met simultaneously:\n1.  The left subtree, rooted at $n_{\\text{left}}$, must itself be a BST.\n2.  The right subtree, rooted at $n_{\\text{right}}$, must itself be a BST.\n3.  The key of the current node, $k(n)$, must be strictly greater than the maximum key in its entire left subtree. Let this maximum be $\\max(T_{n_{\\text{left}}})$. The condition is $\\max(T_{n_{\\text{left}}})  k(n)$.\n4.  The key of the current node, $k(n)$, must be strictly less than the minimum key in its entire right subtree. Let this minimum be $\\min(T_{n_{\\text{right}}})$. The condition is $k(n)  \\min(T_{n_{\\text{right}}})$.\n\nThis suggests that a recursive function processing a node must return a set of properties for the subtree rooted at that node. Specifically, for a subtree rooted at node `n`, we need to know:\n- Whether it is a valid BST.\n- Its size (number of nodes).\n- The minimum key within it.\n- The maximum key within it.\n\nLet us define a recursive function, `get_bst_info(node)`, that traverses the tree and returns a tuple of properties: `(is_bst, size, min_val, max_val)`. We also maintain a global or class-level variable, `max_bst_size`, to keep track of the largest BST size found so far.\n\nThe recursive logic for `get_bst_info` at a given `node` is as follows:\n\n1.  **Base Case**: If `node` is empty (`None`), it represents an empty tree, which is by definition a BST of size $0$. To facilitate the parent's calculations, we must return boundary values for `min_val` and `max_val` that will not violate the BST property. We return a tuple indicating success, a size of 0, a minimum value of $+\\infty$, and a maximum value of $-\\infty$.\n\n2.  **Recursive Step**: If `node` is not empty:\n    a. Recursively call the function on the left and right children:\n       - `(is_bst_left, size_left, min_left, max_left) = get_bst_info(node.left)`\n       - `(is_bst_right, size_right, min_right, max_right) = get_bst_info(node.right)`\n    b. Check if the current subtree rooted at `node` is a BST. This is true if and only if all of the following hold:\n       - `is_bst_left` is `True`.\n       - `is_bst_right` is `True`.\n       - `$max_{\\text{left}}  \\text{node.key}  min_{\\text{right}}$`.\n    c. **If the current subtree is a BST**:\n       - Calculate its size: $size_{\\text{current}} = 1 + size_{\\text{left}} + size_{\\text{right}}$.\n       - Update the overall maximum size found: `max_bst_size = max(max_bst_size, size_current)`.\n       - Determine the minimum and maximum keys for this new, larger BST:\n         - $min_{\\text{current}} = \\min(\\text{node.key}, min_{\\text{left}})$.\n         - $max_{\\text{current}} = \\max(\\text{node.key}, max_{\\text{right}})$.\n       - Return a tuple with the properties of this valid BST to the parent: `(True, size_current, min_current, max_current)`.\n    d. **If the current subtree is not a BST**:\n       - It cannot be part of a larger BST rooted at an ancestor. We must propagate this \"failure\" information upwards.\n       - The largest BSTs may still exist in its left or right subtrees; their sizes would have already been recorded in `max_bst_size` during the recursive calls.\n       - Return a tuple indicating failure, e.g., `(False, 0, -infinity, +infinity)`. These bounds are chosen to ensure that any parent node will also fail its BST check, correctly breaking the chain of BST formation. The size is returned as $0$ because this subtree is not a valid BST.\n\nThe overall algorithm consists of initializing `max_bst_size` to $0$, calling `get_bst_info` on the root of the tree, and then returning the final value of `max_bst_size`. For an empty input tree, the size is correctly determined to be $0$.\n\nBefore applying this logic, the input level-order list must be converted into a tree data structure. This can be accomplished using a queue to manage parent nodes as we iterate through the list of keys.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport collections\nimport numpy as np\n\nclass TreeNode:\n    \"\"\"\n    Represents a node in a binary tree.\n    \"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef build_tree(values):\n    \"\"\"\n    Constructs a binary tree from a list of values in level-order.\n    'None' is used as the marker for a missing child.\n    \"\"\"\n    if not values:\n        return None\n\n    root = TreeNode(values[0])\n    queue = collections.deque([root])\n    i = 1\n    while i  len(values):\n        parent = queue.popleft()\n\n        # Left child\n        if i  len(values) and values[i] is not None:\n            left_child = TreeNode(values[i])\n            parent.left = left_child\n            queue.append(left_child)\n        i += 1\n\n        # Right child\n        if i  len(values) and values[i] is not None:\n            right_child = TreeNode(values[i])\n            parent.right = right_child\n            queue.append(right_child)\n        i += 1\n    \n    return root\n\nclass Solution:\n    \"\"\"\n    Encapsulates the logic to find the largest BST subtree.\n    \"\"\"\n    def __init__(self):\n        # Using a list for mutability to track the max size found across recursive calls.\n        self.max_bst_size = [0]\n\n    def find_largest_bst_size(self, root):\n        \"\"\"\n        Public method to initiate the search.\n        \"\"\"\n        self._get_bst_info(root)\n        return self.max_bst_size[0]\n\n    def _get_bst_info(self, node):\n        \"\"\"\n        Performs a post-order traversal to gather BST properties.\n        Returns a tuple: (is_bst, size, min_key, max_key)\n        - is_bst: Boolean, True if the subtree at 'node' is a BST.\n        - size: Integer, size of the subtree if it is a BST.\n        - min_key: The minimum key in the subtree.\n        - max_key: The maximum key in the subtree.\n        \"\"\"\n        # Base case: an empty tree is a BST of size 0.\n        # min_val is +inf and max_val is -inf to ensure parent node's key\n        # will always satisfy the BST property with an empty child.\n        if node is None:\n            return (True, 0, float('inf'), float('-inf'))\n\n        # Recursively get info from left and right children.\n        left_is_bst, left_size, left_min, left_max = self._get_bst_info(node.left)\n        right_is_bst, right_size, right_min, right_max = self._get_bst_info(node.right)\n        \n        # Check if the current node is the root of a valid BST.\n        # This requires both children's subtrees to be BSTs, and the current\n        # node's key to be between the max of the left and min of the right.\n        if left_is_bst and right_is_bst and (left_max  node.key  right_min):\n            current_size = 1 + left_size + right_size\n            \n            # Update the global maximum size if this BST is larger.\n            if current_size  self.max_bst_size[0]:\n                self.max_bst_size[0] = current_size\n\n            # Determine the min and max for the current BST.\n            # For a leaf, left_min is inf, so min(node.key, inf) is node.key.\n            current_min = min(node.key, left_min)\n            # For a leaf, right_max is -inf, so max(node.key, -inf) is node.key.\n            current_max = max(node.key, right_max)\n            \n            return (True, current_size, current_min, current_max)\n        else:\n            # If the current node is not the root of a BST, propagate this failure\n            # upwards. The returned values ensure any parent will also fail the check.\n            # Size is irrelevant as this is not a valid BST.\n            return (False, 0, float('-inf'), float('inf'))\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Problem statement test cases with 'null' represented by None.\n    test_cases = [\n        [10, 5, 15, 1, 8, None, 7],\n        [5, 3, 8, 2, 4, 6, 9],\n        [5, 1, 5, 0, 2, 5, 6],\n        [-3, -5, 2, -6, -4, 0, 3],\n        [],\n        [5, 2, 4, 1, None, 3, 6],\n    ]\n\n    results = []\n    for values in test_cases:\n        root = build_tree(values)\n        solver = Solution()\n        result = solver.find_largest_bst_size(root)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3215484"}]}