{"hands_on_practices": [{"introduction": "A binary tree's structure is uniquely defined by its preorder and inorder traversals, a fundamental concept in data structures. This exercise challenges you to move beyond the intuitive linked-node model and directly map this logical structure onto the rigid indexing scheme of an implicit array [@problem_id:3207658]. Mastering this technique deepens your understanding of how abstract tree structures are concretely realized in memory, forcing you to reconcile a recursive algorithm with a linear memory layout.", "problem": "You are given two traversal arrays of a binary tree: a preorder traversal array and an inorder traversal array. Each array contains distinct positive integers representing the labels of the treeâ€™s nodes. The task is to reconstruct the binary tree and then produce its implicit array representation directly, without constructing any intermediate linked node representation.\n\nFundamental base definitions:\n- A binary tree is a finite set of nodes, each of which may have a left child and a right child. A traversal is a systematic method of visiting all nodes.\n- Depth-First Search (DFS) preorder traversal visits nodes in the order: root, left subtree, right subtree.\n- Depth-First Search (DFS) inorder traversal visits nodes in the order: left subtree, root, right subtree.\n- The implicit array representation of a binary tree is defined on a zero-indexed array such that, if a node occupies index $i$, then its left child occupies index $2i+1$ and its right child occupies index $2i+2$. If a child does not exist, the corresponding position is considered unused. In this problem, unused positions must be filled with the sentinel value $-1$.\n\nRequirements:\n- You must reconstruct the implicit array representation directly from the traversal arrays, placing each node value at its correct index under the mapping $i \\mapsto (2i+1,\\,2i+2)$ for left and right children, respectively. You must not build or store any intermediate linked node structure.\n- All node values are distinct positive integers, and the traversals describe a valid binary tree.\n\nTest suite:\nFor each test case, the first array is the preorder traversal and the second array is the inorder traversal. The tree must be reconstructed and output as its implicit array representation with $-1$ in unused positions.\n\n1. Balanced tree (happy path):\n   - Preorder: $[4,2,1,3,6,5,7]$\n   - Inorder: $[1,2,3,4,5,6,7]$\n\n2. Empty tree (boundary):\n   - Preorder: $[]$\n   - Inorder: $[]$\n\n3. Single node (boundary):\n   - Preorder: $[10]$\n   - Inorder: $[10]$\n\n4. Left-skewed tree (edge case):\n   - Preorder: $[5,4,3,2,1]$\n   - Inorder: $[1,2,3,4,5]$\n\n5. Right-skewed tree (edge case):\n   - Preorder: $[1,2,3,4,5]$\n   - Inorder: $[1,2,3,4,5]$\n\n6. Mixed shape (non-trivial sparse):\n   - Preorder: $[8,4,6,12,10]$\n   - Inorder: $[4,6,8,10,12]$\n\nFinal output format:\nYour program should produce a single line of output containing the constructed arrays for all test cases in order, as a comma-separated list enclosed in square brackets. Specifically, if there are $k$ test cases and the constructed arrays for them are $A_1, A_2, \\dots, A_k$, then the output must be the single line\n$[A_1,A_2,\\dots,A_k]$,\nwhere each $A_j$ is itself a bracketed, comma-separated list of integers with no spaces, and unused positions filled with $-1$.", "solution": "The problem of reconstructing a binary tree from its preorder and inorder traversals is valid. It is a well-established, non-trivial problem in computer science, grounded in the fundamental properties of tree traversal algorithms.\n\n### Step 1: Extract Givens\n- **Input**: Two arrays of distinct positive integers: a preorder traversal array and an inorder traversal array of a binary tree.\n- **Task**: Reconstruct the tree and represent it as an implicit array.\n- **Definition (Preorder Traversal)**: Root, Left Subtree, Right Subtree.\n- **Definition (Inorder Traversal)**: Left Subtree, Root, Right Subtree.\n- **Definition (Implicit Array Representation)**: A node at zero-based index $i$ has its left child at index $2i+1$ and its right child at index $2i+2$.\n- **Constraint**: The implicit array representation must be produced directly, without constructing any intermediate linked node data structure.\n- **Sentinel Value**: Unused positions in the output array must be filled with $-1$.\n- **Test Cases**:\n    1. Preorder: $[4,2,1,3,6,5,7]$, Inorder: $[1,2,3,4,5,6,7]$\n    2. Preorder: $[]$, Inorder: $[]$\n    3. Preorder: $[10]$, Inorder: $[10]$\n    4. Preorder: $[5,4,3,2,1]$, Inorder: $[1,2,3,4,5]$\n    5. Preorder: $[1,2,3,4,5]$, Inorder: $[1,2,3,4,5]$\n    6. Preorder: $[8,4,6,12,10]$, Inorder: $[4,6,8,10,12]$\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is internally consistent, scientifically grounded, and well-posed.\n- **Scientifically Grounded**: The premise that a binary tree (with distinct node values) is uniquely determined by its preorder and inorder traversals is a fundamental theorem in data structures.\n- **Well-Posed**: The inputs are clearly defined, and the desired output format is specified precisely. The guarantee of distinct node values ensures a unique tree structure can be resolved.\n- **Objective**: The problem is described using formal, unambiguous language.\n\nThe problem does not exhibit any of the invalidity criteria. It is a standard algorithmic challenge that is both formalizable and solvable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A reasoned solution will be provided.\n\n### Principle-Based Solution Design\nThe core principle for reconstructing a binary tree from its preorder and inorder traversals lies in the specific ordering information each traversal provides.\n1.  The first element of any preorder traversal sequence is always the root of the corresponding tree or subtree.\n2.  Once the root's value is known, its position within the inorder traversal sequence partitions all other nodes into two disjoint sets: those appearing to the left of the root form the left subtree, and those to the right form the right subtree.\n\nThe challenge is to apply this principle to directly construct an implicit array representation, $A$, where a node at index $i$ has children at indices $2i+1$ (left) and $2i+2$ (right), without creating an intermediate linked `Node` object representation.\n\nA recursive approach is naturally suited for this decomposition. We can define a recursive function that operates on sub-arrays (or more efficiently, on index ranges) of the preorder and inorder traversals and is tasked with placing a given subtree's root at a specific target index in the final array.\n\nTo manage the potentially sparse nature of the implicit array representation (e.g., in skewed trees), and to determine the final array's size without a preliminary pass, we can use a dictionary or hash map to store the `(index, value)` pairs as they are determined. This map serves as a sparse representation of the final array. Once the recursion is complete, the map contains all node placements. The final, dense array can then be constructed by initializing an array of size `max_index + 1` with the sentinel value $-1$ and populating it from the map.\n\nThe algorithm proceeds as follows:\n1.  For efficient lookup, pre-process the inorder traversal array into a hash map, `inorder_map`, that maps each node value to its index. This allows for an $O(1)$ lookup of a root's position in the inorder sequence, which is critical for an overall efficient algorithm. Without this, each step would require an $O(N)$ scan, leading to an $O(N^2)$ algorithm.\n2.  Define a recursive function, `build(pre_start, pre_end, in_start, in_end, array_idx)`, where:\n    - `pre_start, pre_end`: The start and end indices of the current sub-problem in the preorder array.\n    - `in_start, in_end`: The start and end indices of the current sub-problem in the inorder array.\n    - `array_idx`: The index in the conceptual output array where the root of the current subtree must be placed.\n3.  The `build` function's logic:\n    - **Base Case**: If `pre_start > pre_end`, the subtree is empty. Terminate the recursion for this path.\n    - **Identify Root**: The root of the current subtree is `root_val = preorder[pre_start]`.\n    - **Place Root**: Store the root's value at its designated index in our sparse map: `tree_map[array_idx] = root_val`.\n    - **Partition**: Find the root's index in the current inorder segment: `in_root_idx = inorder_map[root_val]`. The number of nodes in the left subtree is `left_subtree_size = in_root_idx - in_start`.\n    - **Recurse on Left Subtree**: The left subtree corresponds to `preorder` indices `pre_start + 1` to `pre_start + left_subtree_size` and `inorder` indices `in_start` to `in_root_idx - 1`. Its root will be placed at index `2 * array_idx + 1`. Make a recursive call with these new parameters.\n    - **Recurse on Right Subtree**: The right subtree corresponds to `preorder` indices `pre_start + left_subtree_size + 1` to `pre_end` and `inorder` indices `in_root_idx + 1` to `in_end`. Its root will be placed at index `2 * array_idx + 2`. Make a second recursive call.\n4.  To start the process, make an initial call to `build(0, N-1, 0, N-1, 0)`, where $N$ is the total number of nodes and the root of the entire tree is placed at index $0$.\n5.  After the initial call returns, `tree_map` will contain all the nodes and their correct indices.\n6.  If the tree is not empty, determine the required array size by finding the maximum index in `tree_map`: `max_idx = max(tree_map.keys())`.\n7.  Create the final array of size `max_idx + 1`, initialize all its elements to $-1$, and then populate it using the `(index, value)` pairs from `tree_map`.\n\nThis single-pass recursive approach correctly constructs the implicit array representation with an optimal time complexity of $O(N)$, as each node is processed exactly once, and a space complexity of $O(N)$ for the recursion stack and the `inorder_map`. The size of the output array can be up to $O(2^N)$ in the worst case for a skewed tree, but its size is determined dynamically by the structure of the specific tree.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # 1. Balanced tree (happy path)\n        ([4, 2, 1, 3, 6, 5, 7], [1, 2, 3, 4, 5, 6, 7]),\n        # 2. Empty tree (boundary)\n        ([], []),\n        # 3. Single node (boundary)\n        ([10], [10]),\n        # 4. Left-skewed tree (edge case)\n        ([5, 4, 3, 2, 1], [1, 2, 3, 4, 5]),\n        # 5. Right-skewed tree (edge case)\n        ([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]),\n        # 6. Mixed shape (non-trivial sparse)\n        ([8, 4, 6, 12, 10], [4, 6, 8, 10, 12]),\n    ]\n\n    results = []\n    for preorder, inorder in test_cases:\n        result = build_implicit_array(preorder, inorder)\n        results.append(result)\n\n    # Format each result list into a string like \"[v1,v2,...]\" with no spaces\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    \n    # Print the final output as a single-line comma-separated list of these strings\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef build_implicit_array(preorder: list[int], inorder: list[int]) -> list[int]:\n    \"\"\"\n    Reconstructs the implicit array representation of a binary tree from its\n    preorder and inorder traversals.\n\n    Args:\n        preorder: A list of integers representing the preorder traversal.\n        inorder: A list of integers representing the inorder traversal.\n\n    Returns:\n        A list of integers for the implicit array representation, with -1\n        for unused positions.\n    \"\"\"\n    if not preorder:\n        return []\n\n    # O(N) step to create a map for O(1) lookups of inorder indices.\n    inorder_map = {val: i for i, val in enumerate(inorder)}\n    tree_map = {}  # Using a dictionary as a sparse array for {index: value}\n    n = len(preorder)\n\n    def build_recursive(pre_start, pre_end, in_start, in_end, array_idx):\n        \"\"\"\n        Recursively populates the tree_map.\n        \n        Args:\n            pre_start, pre_end: Slice indices for the preorder array.\n            in_start, in_end: Slice indices for the inorder array.\n            array_idx: The index in the final implicit array for the current root.\n        \"\"\"\n        # Base case: If the current subtree is empty, do nothing.\n        if pre_start > pre_end:\n            return\n\n        # The root of the current subtree is the first element in its preorder traversal.\n        root_val = preorder[pre_start]\n        tree_map[array_idx] = root_val\n\n        # Find the root's position in the inorder traversal to partition subtrees.\n        in_root_idx = inorder_map[root_val]\n        left_subtree_size = in_root_idx - in_start\n        \n        # Recurse for the left child.\n        # Its preorder traversal is the next 'left_subtree_size' elements.\n        # Its inorder traversal is the elements to the left of the root.\n        # Its array index is 2*i+1.\n        build_recursive(\n            pre_start + 1,\n            pre_start + left_subtree_size,\n            in_start,\n            in_root_idx - 1,\n            2 * array_idx + 1\n        )\n        \n        # Recurse for the right child.\n        # Its preorder traversal follows the left subtree's elements.\n        # Its inorder traversal is the elements to the right of the root.\n        # Its array index is 2*i+2.\n        build_recursive(\n            pre_start + left_subtree_size + 1,\n            pre_end,\n            in_root_idx + 1,\n            in_end,\n            2 * array_idx + 2\n        )\n\n    # Initial call for the entire tree, root at index 0.\n    build_recursive(0, n - 1, 0, n - 1, 0)\n    \n    # Determine the size of the final array from the maximum index used.\n    if not tree_map:\n        return []\n    max_idx = max(tree_map.keys())\n    \n    # Create the dense array and populate it from the sparse map.\n    # Using np.full for initialization as per environment specification.\n    result_array = np.full(max_idx + 1, -1, dtype=int)\n    for idx, val in tree_map.items():\n        result_array[idx] = val\n        \n    return result_array.tolist()\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3207658"}, {"introduction": "While linked representations offer structural flexibility, array representations can provide superior memory locality and performance for certain operations. This practice explores a powerful conversion technique: re-organizing a linked tree into an array such that a post-order traversal becomes a simple linear scan [@problem_id:3207735]. This type of linearization is a key optimization pattern used in algorithms for expression evaluation and compiler design, where the order of operations is critical.", "problem": "Consider a finite, rooted binary tree represented in linked form. The linked representation consists of an integer number of nodes $n$, with nodes labeled by their original indices $0,1,\\dots,n-1$, and two arrays $L$ and $R$ of length $n$ such that $L[i]$ is the index of the left child of node $i$ or the sentinel $-1$ if the left child does not exist, and $R[i]$ is the index of the right child of node $i$ or the sentinel $-1$ if the right child does not exist. The tree has a designated root index $r$; for an empty tree, the root is $-1$ and both arrays $L$ and $R$ are empty. Each node index refers to a unique node, and the structure is acyclic and connected from the root to all nodes.\n\nYour task is to devise and implement an algorithm that constructs a flat array representation of the same tree in memory such that a post-order traversal becomes a simple linear scan of the array from index $0$ to index $n-1$. In other words, the array should contain the nodes in the exact post-order of the original tree. Additionally, the child pointers must be updated to reflect the new array indices: for the node placed at position $i$ in the new array, its left pointer should be the new array index of its left child (or $-1$ if none), and similarly for its right pointer.\n\nThe fundamental base for this problem is the definition of a binary tree, the definition of tree traversals, and the procedural steps of Depth-First Search (DFS). A binary tree is a directed acyclic graph where each node has at most two children, designated as left and right. A post-order traversal is defined recursively as visiting the left subtree in post-order, then the right subtree in post-order, and finally the node itself. Depth-First Search (DFS) explores along one branch of the tree as deep as possible before backtracking, and can be implemented iteratively using an explicit stack or recursively using function calls.\n\nYour program must, for each test case, compute:\n- The array $A$ of length $n$ such that scanning $A$ from index $0$ to $n-1$ yields the nodes in post-order with respect to the original linked representation.\n- The updated left-child array $L'$ of length $n$ in the new array coordinate system, where $L'[i]$ is the new array index of the left child of the node at position $i$ in $A$, or $-1$ if it has no left child.\n- The updated right-child array $R'$ of length $n$ in the new array coordinate system, where $R'[i]$ is the new array index of the right child of the node at position $i$ in $A$, or $-1$ if it has no right child.\n\nDesign your algorithm to run in time linear in $n$ and space linear in $n$. Do not assume any special properties beyond the given definitions. The computation must be exact and must not rely on unstated heuristics.\n\nTest Suite:\nProvide solutions for the following test cases. For each case, $n$ equals the length of $L$ and $R$, and nodes are labeled $0,1,\\dots,n-1$.\n\n- Case $1$ (empty tree): $n=0$, $L=\\left[ \\right]$, $R=\\left[ \\right]$, $r=-1$.\n- Case $2$ (single node): $n=1$, $L=\\left[ -1 \\right]$, $R=\\left[ -1 \\right]$, $r=0$.\n- Case $3$ (left-skewed tree): $n=4$, $L=\\left[ 1,2,3,-1 \\right]$, $R=\\left[ -1,-1,-1,-1 \\right]$, $r=0$.\n- Case $4$ (complete binary tree of height $2$): $n=7$, $L=\\left[ 1,3,5,-1,-1,-1,-1 \\right]$, $R=\\left[ 2,4,6,-1,-1,-1,-1 \\right]$, $r=0$.\n- Case $5$ (tree with missing children): $n=6$, $L=\\left[ 1,-1,4,-1,-1,-1 \\right]$, $R=\\left[ 2,3,-1,-1,5,-1 \\right]$, $r=0$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for all five cases as a comma-separated list enclosed in square brackets. Each caseâ€™s result must be the triple $\\left[ A, L', R' \\right]$, where $A$, $L'$, and $R'$ are lists of integers as defined above. For example, the overall output should look like $\\left[ \\text{case}_1,\\text{case}_2,\\text{case}_3,\\text{case}_4,\\text{case}_5 \\right]$, where each $\\text{case}_i$ is the triple for the $i$-th test case.", "solution": "The user-provided problem is valid. It is scientifically grounded in the domain of computer science, specifically data structures and algorithms. The problem is well-posed, with a clear objective, sufficient input data, and unambiguous definitions of a binary tree and post-order traversal. It is an objective, formalizable task free of contradictions, unsound premises, or subjective claims.\n\nThe problem asks for a transformation of a given linked representation of a rooted binary tree into a flat array representation. The key constraint is that a linear scan of this new array, from index $0$ to $n-1$, must be equivalent to a post-order traversal of the original tree. This requires constructing three arrays: an array $A$ containing the original node indices in post-order, and two corresponding arrays, $L'$ and $R'$, containing the updated child pointers in the new coordinate system. The algorithm must operate in time and space linear in the number of nodes, $n$.\n\nA two-pass algorithm provides an efficient and direct solution to this problem, adhering to the specified complexity constraints.\n\n### Algorithmic Design\n\nThe core of the problem is to re-index the tree's nodes according to a specific traversal order. This can be broken down into two main phases:\n$1$. **Generating the Post-Order Sequence**: First, we must determine the post-order sequence of the original node indices. This sequence will define the contents of the target array $A$.\n$2$. **Remapping the Child Pointers**: Once the new ordering of nodes in array $A$ is established, the original left and right child pointers must be translated from the original index space to the new index space of array $A$.\n\n### Phase 1: Post-Order Traversal\n\nA post-order traversal of a binary tree is recursively defined as:\n$1$. Traverse the left subtree.\n$2$. Traverse the right subtree.\n$3$. Visit the root node.\n\nThis definition lends itself naturally to a recursive Depth-First Search (DFS) implementation. We can define a function, let's call it $\\text{DFS-Post-Order}(u)$, which takes an original node index $u$ as input.\n\nThe procedure for $\\text{DFS-Post-Order}(u)$ is as follows:\n- If the node index $u$ is the sentinel value $-1$ (indicating a non-existent child), the function returns immediately.\n- The function recursively calls itself on the left child of $u$, which is given by $L[u]$: $\\text{DFS-Post-Order}(L[u])$.\n- The function then recursively calls itself on the right child of $u$, which is given by $R[u]$: $\\text{DFS-Post-Order}(R[u])$.\n- Finally, after the recursive calls for both subtrees have completed, the function processes the node $u$ itself by appending its index to a global list. This list will become our target array $A$.\n\nBy initiating this process with a call to $\\text{DFS-Post-Order}(r)$, where $r$ is the root of the tree, we will populate the list $A$ with the original node indices in the exact post-order sequence. For an empty tree where $r = -1$, this process is simply skipped, resulting in an empty array $A$, which is the correct outcome. The time complexity of this phase is $O(n)$, as the DFS visits each node and edge precisely once. The space complexity is determined by the depth of the recursion stack, which is $O(h)$ where $h$ is the height of the tree. In the worst case of a degenerate (skewed) tree, $h$ can be $O(n)$, leading to a space complexity of $O(n)$.\n\n### Phase 2: Pointer Remapping\n\nAfter Phase $1$, we have the array $A$ of length $n$, where $A[i]$ is the original index of the node that now occupies the position $i$ in the new, post-ordered representation. To compute the new pointer arrays $L'$ and $R'$, we need to determine, for each node, the new indices of its children.\n\nFor a node at new index $i$, its original index is $A[i]$. Its original children had indices $L[A[i]]$ and $R[A[i]]$. To find the new indices corresponding to these original child indices, we require a mapping from the original index space to the new index space.\n\nLet us define a mapping array, $M$, of size $n$, where $M[j]$ stores the new index of the node that originally had index $j$. This map can be constructed in a single pass over the array $A$. We iterate with an index $i$ from $0$ to $n-1$:\n$$M[A[i]] = i$$\nThis construction takes $O(n)$ time and $O(n)$ space.\n\nWith the mapping $M$ in hand, we can construct the final pointer arrays $L'$ and $R'$. We initialize $L'$ and $R'$ as arrays of size $n$. We then iterate through the new indices, from $i = 0$ to $n-1$:\n- The node at new position $i$ is the one with original index $u_{\\text{orig}} = A[i]$.\n- The original left child of this node is $c_L = L[u_{\\text{orig}}]$.\n- If $c_L$ is not $-1$, its new index is $M[c_L]$. We set $L'[i] = M[c_L]$. Otherwise, if $c_L$ is $-1$, we set $L'[i] = -1$.\n- Similarly, for the original right child $c_R = R[u_{\\text{orig}}]$: if $c_R \\neq -1$, we set $R'[i] = M[c_R]$; otherwise, $R'[i] = -1$.\n\nThis second pass also takes $O(n)$ time. The total algorithm, therefore, has a time complexity of $O(n) + O(n) + O(n) = O(n)$ and a space complexity for the intermediate and final arrays of $O(n) + O(n) = O(n)$, satisfying all problem constraints.\n\n### Summary of the Algorithm\n1.  Handle the empty tree case ($n=0, r=-1$) by returning three empty arrays.\n2.  Initialize an empty list for the post-order sequence, $A$.\n3.  Perform a recursive DFS starting from the root $r$. In the post-visit step of the DFS for a node $u$, append $u$ to $A$.\n4.  Create a mapping array $M$ of size $n$. Populate it by iterating through $A$: for each $i \\in [0, n-1]$, set $M[A[i]] = i$.\n5.  Initialize two result arrays, $L'$ and $R'$, of size $n$ with a default value of $-1$.\n6.  Iterate from $i=0$ to $n-1$:\n    a. Let $u_{\\text{orig}} = A[i]$.\n    b. Find original children: $c_L = L[u_{\\text{orig}}]$ and $c_R = R[u_{\\text{orig}}]$.\n    c. If $c_L \\neq -1$, set $L'[i] = M[c_L]$.\n    d. If $c_R \\neq -1$, set $R'[i] = M[c_R]$.\n7.  Return the triple $[A, L', R']$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# It is good practice to increase the recursion limit for deep trees,\n# although not strictly necessary for the given test cases.\nsys.setrecursionlimit(2000)\n\ndef solve():\n    \"\"\"\n    Solves the tree representation problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (empty tree)\n        {'n': 0, 'L': [], 'R': [], 'r': -1},\n        # Case 2 (single node)\n        {'n': 1, 'L': [-1], 'R': [-1], 'r': 0},\n        # Case 3 (left-skewed tree)\n        {'n': 4, 'L': [1, 2, 3, -1], 'R': [-1, -1, -1, -1], 'r': 0},\n        # Case 4 (full binary tree of height 2)\n        {'n': 7, 'L': [1, 3, 5, -1, -1, -1, -1], 'R': [2, 4, 6, -1, -1, -1, -1], 'r': 0},\n        # Case 5 (tree with missing children)\n        {'n': 6, 'L': [1, -1, 4, -1, -1, -1], 'R': [2, 3, -1, -1, 5, -1], 'r': 0}\n    ]\n\n    all_results = []\n\n    def format_case_result(result_triple):\n        \"\"\"Custom formatter to produce output strings without spaces.\"\"\"\n        A, Lp, Rp = result_triple\n        A_str = f\"[{','.join(map(str, A))}]\"\n        Lp_str = f\"[{','.join(map(str, Lp))}]\"\n        Rp_str = f\"[{','.join(map(str, Rp))}]\"\n        return f\"[{A_str},{Lp_str},{Rp_str}]\"\n    \n    for case in test_cases:\n        n, L, R, r = case['n'], case['L'], case['R'], case['r']\n\n        if n == 0:\n            all_results.append(format_case_result([[], [], []]))\n            continue\n        \n        # Phase 1: Perform post-order traversal to get array A\n        A = []\n        def dfs_post_order(node_idx):\n            if node_idx == -1:\n                return\n            \n            # 1. Traverse left subtree\n            dfs_post_order(L[node_idx])\n            # 2. Traverse right subtree\n            dfs_post_order(R[node_idx])\n            # 3. Visit node\n            A.append(node_idx)\n\n        dfs_post_order(r)\n\n        # Phase 2: Remap child pointers\n        \n        # Create a map from original node index to new array index\n        original_to_new_map = [-1] * n\n        for i in range(n):\n            original_node_idx = A[i]\n            original_to_new_map[original_node_idx] = i\n\n        # Create new pointer arrays L' and R'\n        L_prime = [-1] * n\n        R_prime = [-1] * n\n\n        for i in range(n):\n            # i is the new index\n            # A[i] is the original index of the node at this new position\n            original_node_idx = A[i]\n            \n            # Get original children\n            original_left_child = L[original_node_idx]\n            original_right_child = R[original_node_idx]\n            \n            # Update left pointer for the new representation\n            if original_left_child != -1:\n                new_left_child_idx = original_to_new_map[original_left_child]\n                L_prime[i] = new_left_child_idx\n            \n            # Update right pointer for the new representation\n            if original_right_child != -1:\n                new_right_child_idx = original_to_new_map[original_right_child]\n                R_prime[i] = new_right_child_idx\n        \n        all_results.append(format_case_result([A, L_prime, R_prime]))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3207735"}, {"introduction": "The efficiency of the implicit array representation is built upon strict structural rules, where a node's index directly implies its parent-child relationships. This exercise simulates a real-world data validation scenario, tasking you with auditing a potentially corrupted array-based tree [@problem_id:3207807]. You will learn to diagnose structural inconsistencies, such as \"orphan\" nodes and fragmented tree components, by applying the mathematical properties of the index mapping, such as calculating a parent's index via $p = \\lfloor \\frac{j - 1}{2} \\rfloor$.", "problem": "You are given an array $A$ of length $n$ that encodes a binary tree using $0$-based indexing. In this representation, if a node exists at index $i$, then its left child is at index $2i + 1$ and its right child is at index $2i + 2$, provided those indices are less than $n$. The array entries satisfy the following constraints: each valid node key is a strictly positive integer, and the integer $0$ denotes a corrupted or missing node. Your task is to design and implement an algorithm that detects structural inconsistencies that arise from corruption, based on fundamental properties of the array and linked representations of binary trees.\n\nFundamental base:\n- A binary tree is a finite set of nodes, each with at most two children (left and right).\n- In the array representation with $0$-based indexing, the parent of an index $j > 0$ is $p = \\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor$. The root is at index $0$.\n- In any consistent array representation of a binary tree, for any node at index $j$ that is present (i.e., $A[j] > 0$), all ancestors along the chain $j, \\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor, \\left\\lfloor \\dfrac{\\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor - 1}{2} \\right\\rfloor, \\dots$ down to index $0$ must also be present. Equivalently, no node can exist if any ancestor is missing.\n- In the linked representation, each present node has pointers to its present left and right children, thereby forming a parent-child graph. The connected components of this graph are formed by considering only present nodes and the parent-child relationships that link them.\n\nStructural inconsistencies to report:\n1. The list of indices $j$ (sorted in ascending order) such that $A[j] > 0$ and there exists at least one missing ancestor on the path from $j$ to the root. These are nodes that violate the requirement that all ancestors must be present. For clarity, these indices are called the orphan indices, but the definition requires checking the entire ancestor chain, not just the immediate parent.\n2. A boolean indicating whether the root is missing while some nodes are present, that is, whether $A[0] = 0$ and there exists an index $j > 0$ with $A[j] > 0$.\n3. The number of connected components formed by present nodes under the parent-child relation. This equals the count of indices $j$ with $A[j] > 0$ such that either $j = 0$ or $A\\left[\\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor\\right] = 0$ (i.e., nodes whose immediate parent is missing are considered roots of components).\n\nYour program must construct these reports for each of the following test cases (arrays are given explicitly; keys use integers, where $0$ indicates corruption):\n- Test case $1$: $A_1 = [1, 2, 3, 4, 0, 0, 7]$ with $n_1 = 7$.\n- Test case $2$: $A_2 = [0, 2, 0, 0, 5]$ with $n_2 = 5$.\n- Test case $3$: $A_3 = [1, 0, 3, 0, 0, 6, 0, 8]$ with $n_3 = 8$.\n- Test case $4$: $A_4 = []$ with $n_4 = 0$.\n- Test case $5$: $A_5 = [9]$ with $n_5 = 1$.\n\nFor each test case, the output should be a list containing:\n- The list of orphan indices (as defined above), sorted in ascending order.\n- The boolean indicating whether the root is missing while some nodes are present.\n- The integer number of connected components as defined above.\n\nFinal output format:\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. Each element of this top-level list is itself a list with the structure described above. For example, an output with two test cases would look like $[[\\dots,\\dots,\\dots],[\\dots,\\dots,\\dots]]$.", "solution": "The problem statement has been rigorously validated and is assessed to be valid. It is scientifically grounded in the principles of data structures, specifically the array representation of binary trees. The problem is well-posed, with all terms, constraints, and objectives clearly and objectively defined. There are no internal contradictions, missing information, or ambiguities. The problem is formalizable and requires a substantive algorithmic solution based on the provided definitions.\n\nThe task is to devise an algorithm to analyze an array-based representation of a binary tree for three specific types of structural inconsistencies arising from corrupted or missing nodes, denoted by the value $0$. The array $A$ of length $n$ uses $0$-based indexing, where for a node at index $i$, its left and right children are at indices $2i + 1$ and $2i + 2$, respectively.\n\nThe analysis will be broken down into three distinct algorithms, one for each required report.\n\n**1. Detection of Orphan Indices**\n\nThe first required report is a sorted list of \"orphan\" indices. An index $j$ is defined as an orphan if the node at that position is present ($A[j] > 0$) but at least one of its ancestors on the path to the root (index $0$) is missing.\n\n**Principle:** In a structurally consistent array-based binary tree, the presence of a node at a non-root index $j$ necessitates the presence of its parent at index $p = \\left\\lfloor \\frac{j-1}{2} \\right\\rfloor$. By induction, this requirement extends to the entire chain of ancestors from $j$ to the root at index $0$. A violation of this principle, where a node $A[j] > 0$ has an ancestor $A[k] = 0$ for some $k$ on the path from $j$ to $0$, indicates a structural break.\n\n**Algorithm:** To identify all orphan indices, we can iterate through each index $j$ of the array $A$ from $1$ to $n-1$. The root at index $0$ cannot be an orphan as it has no ancestors. For each index $j$ where $A[j] > 0$, we trace its ancestry upward. Let a temporary variable `current_index` be initialized to $j$. While `current_index` is greater than $0$, we compute the parent index $p = \\left\\lfloor \\frac{\\text{current\\_index}-1}{2} \\right\\rfloor$. We then check if $A[p] = 0$. If it is, the node at $j$ has a missing ancestor, so $j$ is added to our list of orphan indices, and the check for this particular $j$ can be terminated. If $A[p] > 0$, we continue the traversal by setting `current_index = p$. If the loop completes without finding a missing ancestor, the node at $j$ is not an orphan. The resulting list of indices is maintained in ascending sorted order.\n\n**2. Identification of a Rootless Tree with Present Nodes**\n\nThe second report is a boolean value indicating whether the root at index $0$ is missing while other nodes are present.\n\n**Principle:** The array representation implicitly defines a single hierarchical structure originating from the root at index $0$. The condition where $A[0] = 0$ while there exists some $j>0$ such that $A[j] > 0$ represents a fundamental inconsistency: the tree structure lacks its designated starting point, yet contains other non-empty parts.\n\n**Algorithm:** This is a direct check of two conditions. First, we verify if the array is non-empty ($n>0$) and if its first element is zero ($A[0] = 0$). If this is not the case, the condition is false. If it is true, we then proceed to check if any other element in the array is positive. This can be done by iterating from index $j=1$ to $n-1$ and checking if $A[j] > 0$. The first time such an element is found, we can conclude the overall condition is true. If the loop finishes without finding any positive element, the condition is false. For an empty array ($n=0$), the condition is defined to be false.\n\n**3. Enumeration of Connected Components**\n\nThe third report is the number of connected components. A component is defined by the set of present nodes linked by the immediate parent-child relationship.\n\n**Principle:** The problem defines a component's root as any present node ($A[j] > 0$) that either is the main root ($j=0$) or whose immediate parent is missing ($A[\\left\\lfloor \\frac{j-1}{2} \\right\\rfloor] = 0$). Each such node acts as the root of a disjoint subtree, or component. The total number of components is therefore equivalent to the total number of these component roots.\n\n**Algorithm:** We initialize a counter for the number of components to $0$. We then iterate through every index $j$ from $0$ to $n-1$. For each index, we first check if a node is present, i.e., $A[j] > 0$. If it is, we apply the component root test. If $j=0$, it is by definition a root of a component, so we increment the counter. If $j>0$, we calculate its parent's index $p = \\left\\lfloor \\frac{j-1}{2} \\right\\rfloor$ and check if $A[p] = 0$. If the parent is missing, the node at $j$ is the root of a component, and we increment the counter. After checking all indices, the final value of the counter is the total number of connected components.\n\nThese three algorithms provide a complete and correct method for detecting the specified structural inconsistencies.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes binary trees encoded in arrays for structural inconsistencies.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [1, 2, 3, 4, 0, 0, 7],       # Test case 1\n        [0, 2, 0, 0, 5],             # Test case 2\n        [1, 0, 3, 0, 0, 6, 0, 8],    # Test case 3\n        [],                          # Test case 4\n        [9],                         # Test case 5\n    ]\n\n    results = []\n    for A in test_cases:\n        n = len(A)\n\n        # 1. Detect orphan indices\n        orphan_indices = []\n        # Iterate from index 1, as the root at index 0 has no ancestors.\n        for j in range(1, n):\n            if A[j] > 0:\n                is_orphan = False\n                current_idx = j\n                # Traverse up the ancestor chain to the root\n                while current_idx > 0:\n                    # Calculate parent index using floor, as per the definition.\n                    # int() is used because np.floor returns a float.\n                    parent_idx = int(np.floor((current_idx - 1) / 2))\n                    \n                    if A[parent_idx] == 0:\n                        is_orphan = True\n                        break  # An orphan is found, no need to check further ancestors.\n                    \n                    current_idx = parent_idx\n                \n                if is_orphan:\n                    orphan_indices.append(j)\n        # The list is naturally sorted as we iterate j in ascending order.\n\n        # 2. Check for rootless tree condition\n        is_rootless = False\n        if n > 0 and A[0] == 0:\n            # Check if any other node is present\n            if any(val > 0 for val in A[1:]):\n                is_rootless = True\n\n        # 3. Count connected components\n        num_components = 0\n        for j in range(n):\n            if A[j] > 0:\n                # A present node is a component root if it is the main root (j=0)\n                # or if its immediate parent is missing.\n                if j == 0:\n                    num_components += 1\n                else:\n                    parent_idx = int(np.floor((j - 1) / 2))\n                    if A[parent_idx] == 0:\n                        num_components += 1\n\n        # Collate the results for the current test case.\n        case_result = [orphan_indices, is_rootless, num_components]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of lists is used as it matches the\n    # structure of the example output format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3207807"}]}