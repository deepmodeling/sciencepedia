{"hands_on_practices": [{"introduction": "Inserting sorted data into a standard BST yields a degenerate, list-like structure with $O(N)$ search time, defeating the purpose of a tree. This exercise challenges you to design and implement a far more intelligent construction algorithm that builds a perfectly balanced BST from sorted data in optimal $O(N)$ time. By reversing the logic of an in-order traversal, you will gain a deep appreciation for the structural relationship between a sorted sequence and a balanced tree. [@problem_id:3213153]", "problem": "Given a sorted Doubly Linked List (DLL), design an algorithm that converts it into a perfectly balanced Binary Search Tree (BST) in $O(N)$ time and $O(\\log N)$ space, where $N$ is the number of nodes in the DLL. Use only the structural properties of the Binary Search Tree (BST) and the sequential ordering of the Doubly Linked List (DLL). Begin from the following fundamental bases: the definition of the BST property that for every node with key $k$, all keys in its left subtree are strictly less than $k$ and all keys in its right subtree are strictly greater than $k$, and the observation that an in-order traversal of a BST visits keys in strictly increasing order.\n\nDefinitions and constraints:\n- The input sequences are strictly increasing sequences of integers, which must be materialized as sorted DLLs where each node contains one integer key and pointers to the previous and next nodes.\n- A perfectly balanced BST is one in which, for every node, the sizes of its left and right subtrees differ by at most $1$. This property implies a height that is within the minimal achievable for the given $N$.\n- The height of a BST is defined as the number of edges on the longest path from the root to a leaf. Under this definition, an empty tree has height $-1$ and a single-node tree has height $0$.\n\nYou must implement an algorithm that constructs the balanced BST in $O(N)$ time and $O(\\log N)$ space, measured as auxiliary stack space due to recursion (ignoring the space needed to store the output tree itself). Additionally, construct an unbalanced BST by inserting the same sorted keys one by one into an initially empty BST using standard BST insertion, which produces a degenerate (right-skewed) tree.\n\nFor each test case, compute and return:\n- The integer height of the balanced BST.\n- The integer height of the unbalanced BST obtained by naive sorted insertion.\n- A boolean indicating whether the balanced BST simultaneously meets two conditions: its in-order traversal reproduces the original sorted sequence and its height equals the theoretical minimal height $h_{\\min}(N) = \\lceil \\log_2(N+1) \\rceil - 1$.\n\nTest suite to be used (each described sequence is strictly increasing):\n- Case $1$: integers $-3,-2,-1,0,1,2,3$.\n- Case $2$: empty sequence (i.e., $N = 0$).\n- Case $3$: single element $42$.\n- Case $4$: two elements $5,10$.\n- Case $5$: ten elements $-10,-5,0,5,9,12,13,14,15,20$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a list of the form $[h_{\\text{balanced}}, h_{\\text{unbalanced}}, \\text{boolean}]$. For example, a valid output for two test cases would look like $[[1,4,\\text{True}],[0,-1,\\text{False}]]$.", "solution": "The problem requires converting a sorted Doubly Linked List (DLL) into a perfectly balanced Binary Search Tree (BST) with optimal complexity.\n\n1.  **Goal**: Build a perfectly balanced BST from a sorted sequence in $O(N)$ time and $O(\\log N)$ space. A \"perfectly balanced\" tree here means the number of nodes in the left and right subtrees of any node differ by at most one.\n\n2.  **Naive Approach & Inefficiency**: A simple but flawed approach is to iterate through the sorted list and insert each element into a BST using the standard insertion algorithm. Because the keys are sorted, each new element becomes the rightmost child of the previous one, forming a degenerate, right-skewed tree that resembles a linked list. The insertion of the $k$-th element takes $O(k)$ time. The total time to build the tree is $\\sum_{k=1}^{N} O(k) = O(N^2)$, which is highly inefficient.\n\n3.  **Recursive Divide-and-Conquer**: A better approach is recursive. Find the median of the sorted list, make it the root, and recursively build the left and right subtrees from the two halves of the list. While this produces a balanced tree, finding the median of a linked list takes $O(N)$ time. The recurrence relation for the runtime would be $T(N) = 2T(N/2) + O(N)$, which solves to $O(N \\log N)$. This is an improvement but still not the optimal $O(N)$.\n\n4.  **Optimal $O(N)$ Approach (In-order Construction)**: The key insight is that an in-order traversal of a BST visits the nodes in sorted order. We can reverse this process. Instead of finding the median first, we can construct the tree *as if* we are performing an in-order traversal.\n\n    The algorithm is as follows:\n    - A recursive function `build(n)` is defined, where `n` is the number of nodes to use from the current position in the DLL to construct a subtree.\n    - To build a subtree of size `n`, we first recursively call `build(n // 2)` to construct the entire left subtree. This call will consume the first `n // 2` elements from the DLL.\n    - After the left subtree is fully constructed, the pointer to the current head of the DLL is now at the element that must become the root of our current subtree. We create a root node with this element's value and advance the DLL pointer.\n    - Finally, we recursively call `build` for the remaining elements (`n - (n // 2) - 1`) to construct the right subtree.\n\n5.  **Complexity Analysis**: In this approach, each node in the DLL is visited exactly once to create a corresponding BST node. The process is a single pass over the list, guided by the recursion. The time complexity is therefore $O(N)$. The space complexity is determined by the depth of the recursion stack. Since the resulting tree is perfectly balanced, its height is $O(\\log N)$, so the auxiliary space complexity is $O(\\log N)$. This method meets all problem constraints.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Define data structures for Doubly Linked List and Binary Search Tree nodes.\nclass DLLNode:\n    \"\"\"Node for a Doubly Linked List.\"\"\"\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\nclass BSTNode:\n    \"\"\"Node for a Binary Search Tree.\"\"\"\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n# ---- Helper Functions ----\n\ndef get_height(node):\n    \"\"\"\n    Computes the height of a tree based on the number of edges.\n    An empty tree has height -1, a single-node tree has height 0.\n    \"\"\"\n    if node is None:\n        return -1\n    return 1 + max(get_height(node.left), get_height(node.right))\n\ndef get_in_order(root):\n    \"\"\"Performs an in-order traversal of a BST and returns a list of keys.\"\"\"\n    result = []\n    if root:\n        result.extend(get_in_order(root.left))\n        result.append(root.data)\n        result.extend(get_in_order(root.right))\n    return result\n\n# ---- Core Algorithm for Balanced BST ----\n\ndef _sorted_list_to_bst(head_ref, n):\n    \"\"\"\n    Recursively constructs a perfectly balanced BST from a sorted DLL.\n    This function simulates an in-order traversal for construction.\n    `head_ref` is a list [node] acting as a mutable pointer to the DLL head.\n    `n` is the number of nodes to include in the current subtree.\n    \"\"\"\n    if n = 0:\n        return None\n\n    # 1. Recursively construct the left subtree. It will contain n // 2 nodes.\n    left_subtree = _sorted_list_to_bst(head_ref, n // 2)\n\n    # 2. After the left subtree is built, the current head_ref[0]\n    #    points to the element that should be the root of this subtree.\n    dll_node_for_root = head_ref[0]\n    root = BSTNode(dll_node_for_root.data)\n    root.left = left_subtree\n\n    # 3. Advance the DLL pointer for the next recursive calls.\n    head_ref[0] = dll_node_for_root.next\n\n    # 4. Recursively construct the right subtree. It contains the remaining nodes.\n    #    Size is n - (size of left subtree) - 1 (for the root).\n    right_subtree_size = n - (n // 2) - 1\n    root.right = _sorted_list_to_bst(head_ref, right_subtree_size)\n\n    return root\n\n# ---- Algorithm for Unbalanced BST ----\n\ndef insert_unbalanced(root, key):\n    \"\"\"\n    Standard BST insertion. If keys are inserted in sorted order,\n    this produces a degenerate (right-skewed) tree.\n    \"\"\"\n    if root is None:\n        return BSTNode(key)\n    if key  root.data:\n        root.left = insert_unbalanced(root.left, key)\n    elif key > root.data:\n        root.right = insert_unbalanced(root.right, key)\n    return root\n\n# ---- Main Solver ----\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem logic for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: integers -3,-2,-1,0,1,2,3.\n        list(range(-3, 4)),\n        # Case 2: empty sequence.\n        [],\n        # Case 3: single element 42.\n        [42],\n        # Case 4: two elements 5,10.\n        [5, 10],\n        # Case 5: ten elements -10,-5,0,5,9,12,13,14,15,20.\n        [-10, -5, 0, 5, 9, 12, 13, 14, 15, 20],\n    ]\n\n    results = []\n    for sequence in test_cases:\n        n = len(sequence)\n\n        # 1. Materialize the sorted DLL from the input sequence\n        dll_head = None\n        if n > 0:\n            head_node = DLLNode(sequence[0])\n            current = head_node\n            for i in range(1, n):\n                new_node = DLLNode(sequence[i])\n                current.next = new_node\n                new_node.prev = current\n                current = new_node\n            dll_head = head_node\n\n        # 2. Construct the perfectly balanced BST\n        # Use a list to pass the head by reference, allowing modification\n        head_ref = [dll_head]\n        balanced_root = _sorted_list_to_bst(head_ref, n)\n        h_balanced = get_height(balanced_root)\n\n        # 3. Construct the unbalanced (degenerate) BST by sorted insertion\n        unbalanced_root = None\n        for key in sequence:\n            unbalanced_root = insert_unbalanced(unbalanced_root, key)\n        h_unbalanced = get_height(unbalanced_root)\n\n        # 4. Perform validation checks\n        if n == 0:\n            # For N=0, h_min is -1.\n            h_min = -1\n            # In-order of empty tree is empty list, matching empty sequence.\n            is_valid_construct = (h_balanced == h_min)\n        else:\n            # Theoretical minimal height for a BST with N nodes.\n            h_min = int(np.ceil(np.log2(n + 1)) - 1)\n            # Check 1: In-order traversal must reproduce the original sequence.\n            in_order_list = get_in_order(balanced_root)\n            in_order_matches = (in_order_list == sequence)\n            # Check 2: The height must be the theoretical minimum.\n            height_matches = (h_balanced == h_min)\n            is_valid_construct = in_order_matches and height_matches\n\n        results.append([h_balanced, h_unbalanced, is_valid_construct])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\n\nsolve()\n```", "id": "3213153"}, {"introduction": "While self-balancing trees automatically correct imbalances, what if you are faced with a static, unbalanced BST and can only perform one single adjustment? This practice asks you to find the single rotation anywhere in the tree that yields the maximum immediate reduction in height. Solving this efficiently requires moving beyond a brute-force approach and developing a clever algorithm to calculate the global impact of local changes in $O(1)$ time after an initial $O(N)$ preprocessing pass. [@problem_id:3213120]", "problem": "You are given the abstract data type of a Binary Search Tree (BST), which is a rooted, ordered binary tree with a unique key at each node satisfying the Binary Search Tree property: for any node with key $k$, every key in its left subtree is strictly less than $k$, and every key in its right subtree is strictly greater than $k$. The height of a tree is defined to be the number of edges on the longest downward path from the root to any leaf. A single rotation is a local transformation at a node that preserves the BST property and reconfigures the tree as follows: a right rotation at a node with a nonempty left child moves that left child up and the node down to the right; a left rotation at a node with a nonempty right child moves that right child up and the node down to the left.\n\nStarting from the core definitions of a Binary Search Tree, tree height, and single rotation, devise an algorithm that, given an unbalanced BST, finds the single rotation (either left or right) at any node that produces the largest immediate decrease in the overall tree height. If multiple rotations yield the same largest decrease, break ties by choosing the rotation at the smallest node key; if still tied at the same node, prefer a right rotation over a left rotation. If no rotation strictly reduces the height, return that no improving rotation exists.\n\nYour program must implement this derivation and compute the following for each provided test tree:\n- The original height $H$ of the tree.\n- For every rotation candidate at a node $v$, the new height $H_{\\text{new}}$ after performing exactly that single rotation (and only that rotation) at $v$.\n- The immediate height improvement $\\Delta = H - H_{\\text{new}}$ for the best rotation according to the specified tie-breaking rules.\n\nFor reporting, encode the selected rotation using the following integer direction codes:\n- $0$ for a right rotation,\n- $1$ for a left rotation,\n- $-1$ if no rotation yields a strict improvement (in that case also report the node key as $-1$ and the improvement as $0$).\n\nYour program must be self-contained and must not read any input. It should compute results for the following test suite of BSTs, each given as a list of triples $(k,\\ell,r)$, where $k$ is the node key, $\\ell$ is the left child key or $None$ if absent, and $r$ is the right child key or $None$ if absent. All keys are distinct integers.\n\nTest suite:\n- Case $1$ (balanced): $\\{(30,20,40),(20,10,25),(10,None,None),(25,None,None),(40,35,50),(35,None,None),(50,None,None)\\}$.\n- Case $2$ (single node): $\\{(10,None,None)\\}$.\n- Case $3$ (right-skewed chain): $\\{(1,None,2),(2,None,3),(3,None,4),(4,None,5),(5,None,None)\\}$.\n- Case $4$ (left-skewed chain): $\\{(6,5,None),(5,4,None),(4,3,None),(3,2,None),(2,1,None),(1,None,None)\\}$.\n- Case $5$ (mixed unbalanced): $\\{(50,30,70),(30,20,None),(20,10,None),(10,None,None),(70,60,None),(60,None,None)\\}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results for the test suite as a comma-separated list enclosed in square brackets. Each test case result must itself be a list of three integers in the form $[\\Delta, k^\\ast, d]$, where $\\Delta$ is the largest immediate height decrease, $k^\\ast$ is the key at which to rotate (or $-1$ if none), and $d$ is the direction code ($0$ for right, $1$ for left, $-1$ for none). For example, a valid overall output might look like $[[1,10,0],[0,-1,-1],\\dots]$.\n\nConstraints and expectations:\n- Derive your algorithm from the fundamental definitions of BSTs, tree height, and single rotation without shortcut formulas as given facts.\n- Your algorithm must run in time $O(n)$ for a tree with $n$ nodes and use $O(n)$ auxiliary space.\n- Height must be measured in edges, not nodes; ensure consistency throughout.", "solution": "The problem requires us to find a single rotation (left or right) in a given Binary Search Tree (BST) that results in the largest possible immediate decrease in the tree's height. We must adhere to specific tie-breaking rules and operate within a time complexity of $O(n)$ and space complexity of $O(n)$ for a tree with $n$ nodes.\n\nFirst, we formalize the fundamental definitions. A BST is a rooted binary tree where for any node with key $k$, all keys in the left subtree are less than $k$ and all keys in the right subtree are greater than $k$. The height of a tree, denoted $H$, is the number of edges on the longest path from the root to any leaf node. This is equivalent to the maximum depth of any leaf node in the tree, where the depth of the root is $0$. A single rotation is a local transformation that restructures the tree while preserving the BST property. A right rotation at a node $v$ with a non-null left child $L$ makes $L$ the new root of the local subtree, with $v$ becoming $L$'s right child. Symmetrically, a left rotation at $v$ with a non-null right child $R$ makes $R$ the new root, with $v$ becoming $R$'s left child.\n\nA direct but inefficient approach would be to iterate through every possible rotation, perform it, re-calculate the entire tree's height from scratch, and record the improvement. Calculating the height of a tree with $n$ nodes takes $O(n)$ time. Since there are $O(n)$ possible rotations (at most two for each node), this naive method has a time complexity of $O(n^2)$, which violates the stated constraint.\n\nTo achieve an $O(n)$ solution, we must be able to compute the new height of the tree after a hypothetical rotation in $O(1)$ time, following an $O(n)$ preprocessing phase. The key insight lies in analyzing how a rotation affects the depths of all leaf nodes, as the tree's height is the maximum depth among all leaves.\n\nA rotation at a node $v$ is a local change, but it systematically alters the depths of nodes within specific subtrees. The new height of the tree, $H_{\\text{new}}$, will be the maximum of the new depths of all leaves. The change in depth for any node depends on which subtree it belongs to relative to the rotation pivot. For a left rotation at node $v$ with right child $R$:\n1.  Nodes in $v$'s left subtree and in $R$'s left subtree move down by one level (depth increases by 1).\n2.  Nodes in $R$'s right subtree move up by one level (depth decreases by 1).\n3.  The depths of all nodes outside of $v$'s original subtree remain unchanged.\n\nThis suggests an algorithm based on pre-calculating all necessary information to apply this logic in $O(1)$ for each potential rotation.\n\n**The $O(n)$ Algorithm:**\n\n**1. Preprocessing ($O(n)$ time, $O(n)$ space):**\nWe perform three traversals of the tree to gather data at each node $v$. We build the tree with parent pointers to facilitate traversals.\n- **Pass 1: Post-order Traversal.** For each node $v$, we compute the height of the subtree rooted at $v$, denoted $h(v)$. This is defined recursively as $h(v) = 1 + \\max(h(v.\\text{left}), h(v.\\text{right}))$, with the height of a null child being $-1$.\n- **Pass 2: Pre-order Traversal.** For each node $v$, we compute its depth, $d(v)$, where $d(\\text{root}) = 0$ and $d(\\text{child}) = d(\\text{parent}) + 1$.\n- **Pass 3: Pre-order Traversal.** For each node $v$, we compute the maximum depth of any leaf node that lies *outside* the subtree of $v$. Let's call this `max_depth_outside(v)`. This can be computed by passing information down from the parent. For a node $v$, an outside leaf is either outside its parent $p$'s subtree, or it is in the subtree of $v$'s sibling. Thus, `max_depth_outside(v)` is the maximum of `max_depth_outside(p)` and the maximum leaf depth in the sibling's subtree. The maximum depth of a leaf in a subtree rooted at node $u$ is $d(u) + h(u)$.\n\n**2. Analysis ($O(n)$ time):**\nWith these values pre-calculated, we iterate through all nodes $v$ (sorted by key to handle tie-breaking) and evaluate each possible rotation. The original height is $H_{\\text{orig}} = h(\\text{root})$.\n\nFor a candidate rotation, we calculate the new tree height $H_{\\text{new}}$ in $O(1)$. This new height is the maximum of the leaf depths across three categories: unaffected leaves, leaves that move up, and leaves that move down.\n- The maximum depth of unaffected leaves is precisely `max_depth_outside(v)`.\n- For a **left rotation** at $v$ with right child $R$:\n  - The maximum depth of leaves in $v$'s left subtree becomes $(d(v.\\text{left}) + h(v.\\text{left})) + 1$.\n  - The maximum depth of leaves in $R$'s left subtree becomes $(d(R.\\text{left}) + h(R.\\text{left})) + 1$.\n  - The maximum depth of leaves in $R$'s right subtree becomes $(d(R.\\text{right}) + h(R.\\text{right})) - 1$.\n- A special case arises if the rotated node $v$ itself becomes a leaf. This happens if its original subtrees involved in the move are empty.\n\nBy calculating the maximum of these potential new depths, we find $H_{\\text{new}}$. A symmetric calculation applies to a right rotation. We then calculate the improvement $\\Delta = H_{\\text{orig}} - H_{\\text{new}}$. We keep track of the rotation yielding the largest $\\Delta > 0$, using the specified tie-breaking rules (smallest node key, then prefer right rotation). This is naturally handled by iterating through nodes in increasing key order and checking the right rotation candidate before the left. If no rotation yields $\\Delta > 0$, we report that no improvement exists. This comprehensive approach satisfies all problem constraints.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# The default recursion limit may be too low for skewed trees.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"Represents a node in the BST.\"\"\"\n    def __init__(self, key):\n        self.key = int(key)\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.h = -1  # Height of the subtree rooted at this node\n        self.d = -1  # Depth of this node\n        self.max_depth_outside = -1  # Max depth of a leaf outside this node's subtree\n\ndef build_tree(tree_data):\n    \"\"\"Builds the tree from a list of triples and returns the root and a node map.\"\"\"\n    if not tree_data:\n        return None, {}\n    \n    nodes = {int(k): Node(k) for k, _, _ in tree_data}\n    \n    # Identify the root by find a node that is never a child.\n    child_keys = set()\n    for _, left_key, right_key in tree_data:\n        if left_key is not None:\n            child_keys.add(int(left_key))\n        if right_key is not None:\n            child_keys.add(int(right_key))\n            \n    root_key_set = set(nodes.keys()) - child_keys\n    if not root_key_set: # Handle empty or malformed data\n        return None, {}\n    root_key = root_key_set.pop()\n    root = nodes[root_key]\n\n    for key, left_key, right_key in tree_data:\n        node = nodes[int(key)]\n        if left_key is not None:\n            node.left = nodes[int(left_key)]\n            node.left.parent = node\n        if right_key is not None:\n            node.right = nodes[int(right_key)]\n            node.right.parent = node\n            \n    return root, nodes\n\ndef compute_heights(node):\n    \"\"\"Pass 1 (Post-order): Computes subtree height for each node.\"\"\"\n    if node is None:\n        return -1\n    h_left = compute_heights(node.left)\n    h_right = compute_heights(node.right)\n    node.h = 1 + max(h_left, h_right)\n    return node.h\n\ndef compute_depths(node, current_depth):\n    \"\"\"Pass 2 (Pre-order): Computes depth for each node.\"\"\"\n    if node is None:\n        return\n    node.d = current_depth\n    compute_depths(node.left, current_depth + 1)\n    compute_depths(node.right, current_depth + 1)\n\ndef get_max_depth_in_subtree(node):\n    \"\"\"Helper to get max leaf depth within a subtree, using pre-calculated values.\"\"\"\n    if node is None:\n        return -1\n    return node.d + node.h\n\ndef compute_max_depth_outside(node, parent_max_depth):\n    \"\"\"Pass 3 (Pre-order): Computes max leaf depth outside each node's subtree.\"\"\"\n    if node is None:\n        return\n    \n    node.max_depth_outside = parent_max_depth\n    \n    max_d_in_left_sibling = get_max_depth_in_subtree(node.left)\n    max_d_in_right_sibling = get_max_depth_in_subtree(node.right)\n    \n    compute_max_depth_outside(node.left, max(parent_max_depth, max_d_in_right_sibling))\n    compute_max_depth_outside(node.right, max(parent_max_depth, max_d_in_left_sibling))\n\ndef analyze_tree(tree_data):\n    \"\"\"Main logic for a single test case.\"\"\"\n    if not tree_data:\n        return [0, -1, -1]\n\n    root, nodes_map = build_tree(tree_data)\n    if not root:\n         return [0, -1, -1]\n         \n    # Preprocessing passes\n    compute_heights(root)\n    compute_depths(root, 0)\n    compute_max_depth_outside(root, -1)\n\n    original_height = root.h\n    best_delta = 0\n    best_key = -1\n    best_dir = -1\n\n    # Analysis pass: Iterate through nodes sorted by key for tie-breaking\n    sorted_nodes = sorted(nodes_map.values(), key=lambda n: n.key)\n\n    for v in sorted_nodes:\n        # Candidate 1: Right Rotation (direction code 0)\n        if v.left is not None:\n            L = v.left\n            \n            md_LL = get_max_depth_in_subtree(L.left)\n            md_LR = get_max_depth_in_subtree(L.right)\n            md_vR = get_max_depth_in_subtree(v.right)\n            \n            new_md_LL = md_LL - 1 if md_LL != -1 else -1\n            new_md_LR = md_LR + 1 if md_LR != -1 else -1\n            new_md_vR = md_vR + 1 if md_vR != -1 else -1\n\n            new_leaf_term = -1\n            if v.right is None and L.right is None: # v becomes a leaf\n                new_leaf_term = v.d + 1\n            \n            new_height = max(v.max_depth_outside, new_md_LL, new_md_LR, new_md_vR, new_leaf_term)\n            delta = original_height - new_height\n\n            if delta > best_delta:\n                best_delta = delta\n                best_key = v.key\n                best_dir = 0\n\n        # Candidate 2: Left Rotation (direction code 1)\n        if v.right is not None:\n            R = v.right\n\n            md_vL = get_max_depth_in_subtree(v.left)\n            md_RL = get_max_depth_in_subtree(R.left)\n            md_RR = get_max_depth_in_subtree(R.right)\n            \n            new_md_vL = md_vL + 1 if md_vL != -1 else -1\n            new_md_RL = md_RL + 1 if md_RL != -1 else -1\n            new_md_RR = md_RR - 1 if md_RR != -1 else -1\n\n            new_leaf_term = -1\n            if v.left is None and R.left is None: # v becomes a leaf\n                new_leaf_term = v.d + 1\n\n            new_height = max(v.max_depth_outside, new_md_vL, new_md_RL, new_md_RR, new_leaf_term)\n            delta = original_height - new_height\n            \n            if delta > best_delta:\n                best_delta = delta\n                best_key = v.key\n                best_dir = 1\n\n    return [best_delta, best_key, best_dir]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: balanced\n        [(30, 20, 40), (20, 10, 25), (10, None, None), (25, None, None), (40, 35, 50), (35, None, None), (50, None, None)],\n        # Case 2: single node\n        [(10, None, None)],\n        # Case 3: right-skewed chain\n        [(1, None, 2), (2, None, 3), (3, None, 4), (4, None, 5), (5, None, None)],\n        # Case 4: left-skewed chain\n        [(6, 5, None), (5, 4, None), (4, 3, None), (3, 2, None), (2, 1, None), (1, None, None)],\n        # Case 5: mixed unbalanced\n        [(50, 30, 70), (30, 20, None), (20, 10, None), (10, None, None), (70, 60, None), (60, None, None)]\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_tree(case)\n        results.append(result)\n\n    result_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3213120"}, {"introduction": "AVL trees guarantee logarithmic height by performing rotations, but these operations are not free. To understand the cost of maintaining balance, this exercise puts you in the role of an adversary trying to maximize this cost. You will implement a procedure to find a \"spiteful\" insertion sequence that triggers the maximum number of rotations at each step, providing a concrete understanding of the worst-case rebalancing behavior in AVL trees. [@problem_id:3213238]", "problem": "You are asked to formalize and compute a sequence of keys for insertion into a height-balanced Binary Search Tree (BST), specifically the Adelson-Velsky and Landis (AVL) tree, that is chosen by an adversarial procedure intending to maximize rotations at each insertion. Begin from the core definitions: a Binary Search Tree (BST) maintains the search-order property, and an Adelson-Velsky and Landis (AVL) tree maintains the invariant that for every node $v$, the absolute value of its balance factor satisfies $\\lvert bf(v) \\rvert \\le 1$, where $bf(v) = \\text{height}(\\text{left}(v)) - \\text{height}(\\text{right}(v))$, and the height of an empty subtree is defined as $-1$ while the height of a non-empty node is $1 + \\max(\\text{height of its children})$. When an insertion violates the invariant at some node, a rotation is performed at the first such unbalanced node encountered on the path from the inserted leaf toward the root. A single left or right rotation counts as one primitive rotation; a double rotation is a composition of two primitive rotations and counts as two.\n\nDefine a “spiteful” insertion sequence $S = \\langle s_1, s_2, \\dots \\rangle$ of distinct positive integers inductively as follows. At step $t \\ge 1$, given the current AVL tree $T_{t-1}$ built by inserting $\\{s_1,\\dots,s_{t-1}\\}$ using the standard AVL insertion procedure, choose $s_t$ from the set of unused positive integers to maximize the number of primitive rotations executed by the insertion of $s_t$ into $T_{t-1}$. If multiple unused keys yield the same maximum number of rotations at step $t$, break ties by choosing the smallest such key. The tree is updated to $T_t$ via that insertion and its required rebalancing.\n\nYour tasks:\n- Implement a program that constructs the “spiteful” sequence $S$ under the above rule starting from an empty tree, and returns, for a given index $k$, the value $s_k$.\n- Use the following test suite of indices $k$: $[\\,1,2,3,4,5,6,7,8,9,10\\,]$.\n- For scientific realism and determinism, the algorithm must follow the AVL rebalancing rule stated above and the rotation counting rule that a double rotation counts as $2$ primitive rotations.\n- The final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,\\dots,r_m]$ where each $r_i$ is the answer for the corresponding test case). Since all data are abstract and unitless, no physical units are required.\n\nGoal: Produce the single-line output containing $[s_1,s_2,s_3,s_4,s_5,s_6,s_7,s_8,s_9,s_{10}]$ under the specified spiteful rule and tie-breaking.", "solution": "The problem defines a precise, deterministic, and inductive procedure for constructing a \"spiteful\" sequence $S$ of distinct positive integers for insertion into an an Adelson-Velsky and Landis (AVL) tree.\n\n### Principle of Solution\n\nAt each step $t \\ge 1$, given the AVL tree $T_{t-1}$ constructed from the keys $\\{s_1, \\dots, s_{t-1}\\}$, the next key $s_t$ is chosen from the set of unused positive integers based on a two-part rule:\n1.  **Primary Objective**: Choose $s_t$ to maximize the number of primitive rotations required for its insertion into $T_{t-1}$. A single rotation (left or right) counts as 1, and a double rotation (left-right or right-left) counts as 2.\n2.  **Tie-Breaking Rule**: If multiple keys yield the same maximum number of rotations, the smallest of these keys must be chosen.\n\nThis procedure is myopic; the choice at step $t$ is based solely on the immediate number of rotations and does not consider any future effects on the tree's structure.\n\nTo compute the sequence $S$, we will implement an algorithm that follows this inductive definition strictly. For each step $t$ from $1$ to $10$:\n1.  **Identify Candidate Keys**: The insertion path of a key $j$ is determined by its value relative to the keys already in the tree. If the sorted keys in the tree are $k'_1  k'_2  \\dots  k'_{t-1}$, they partition the number line into $t$ intervals: $(-\\infty, k'_1), (k'_1, k'_2), \\dots, (k'_{t-1}, \\infty)$. Any two keys from the same interval will follow identical insertion paths. Thus, we only need to test one representative key from each interval that contains unused positive integers. A simple and robust way to ensure all paths are tested is to iterate through candidate keys $j = 1, 2, 3, \\ldots$ up to a sufficiently large number (e.g., $\\max(\\{s_1, \\dots, s_{t-1}\\}) + 2$), ignoring keys already used.\n2.  **Simulate Insertions**: For each candidate key $j$, we simulate its insertion into a copy of the current AVL tree, $T_{t-1}$. The simulation requires a correct implementation of the AVL insertion algorithm, including the rebalancing logic that performs rotations at the first unbalanced node on the path from the new leaf to the root. The simulation must count the number of primitive rotations according to the problem's rules.\n3.  **Apply Selection Criteria**: After simulating insertions for a comprehensive set of candidate keys, we find the maximum number of rotations achieved, $R_{max}$. We then identify the set of all candidate keys that produced $R_{max}$ rotations.\n4.  **Determine $s_t$**: From this set, we select the smallest key. This key is $s_t$.\n5.  **Update State**: We append $s_t$ to our sequence $S$, add it to the set of used keys, and perform the actual insertion of $s_t$ into the tree $T_{t-1}$ to produce $T_t$ for the next step.\n\nThis step-by-step simulation is the only way to guarantee a correct result, as the interaction between tree state and the rotation-maximizing key is complex and not easily predictable by a simple formula. The algorithm must be implemented programmatically to find the correct key at each of the 10 steps.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\nimport copy\n\n# Set a higher recursion limit for safety.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"A node in an AVL Tree.\"\"\"\n    def __init__(self, key):\n        self.key = int(key)\n        self.left = None\n        self.right = None\n        self.height = 0 # Height of leaf is 0 (edge-based)\n\nclass AVLTree:\n    \"\"\"\n    An implementation of an AVL Tree that supports counting primitive rotations\n    during an insertion operation, using edge-based height consistently.\n    \"\"\"\n\n    def get_height(self, node):\n        \"\"\"Returns the height of a node, with -1 for an empty subtree.\"\"\"\n        if not node:\n            return -1\n        return node.height\n\n    def get_balance(self, node):\n        \"\"\"Calculates the balance factor of a node.\"\"\"\n        if not node:\n            return 0\n        return self.get_height(node.left) - self.get_height(node.right)\n\n    def right_rotate(self, y):\n        \"\"\"Performs a right rotation on the subtree rooted at y.\"\"\"\n        x = y.left\n        T2 = x.right\n        x.right = y\n        y.left = T2\n        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))\n        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))\n        return x\n\n    def left_rotate(self, x):\n        \"\"\"Performs a left rotation on the subtree rooted at x.\"\"\"\n        y = x.right\n        T2 = y.left\n        y.left = x\n        x.right = T2\n        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))\n        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))\n        return y\n\n    def insert(self, root, key):\n        \"\"\"\n        Public insert method. It initializes a counter for rotations and calls\n        the recursive helper.\n        Returns the new root of the tree and the total number of primitive rotations.\n        \"\"\"\n        rotation_counter = [0]\n        new_root = self._insert_recursive(root, key, rotation_counter)\n        return new_root, rotation_counter[0]\n\n    def _insert_recursive(self, node, key, rotation_counter):\n        \"\"\"\n        Recursively inserts a key and performs rebalancing. Rotations are counted\n        in the mutable `rotation_counter` list.\n        \"\"\"\n        if not node:\n            return Node(key)\n        \n        if key  node.key:\n            node.left = self._insert_recursive(node.left, key, rotation_counter)\n        elif key > node.key:\n            node.right = self._insert_recursive(node.right, key, rotation_counter)\n        else:\n            return node\n\n        node.height = 1 + max(self.get_height(node.left), self.get_height(node.right))\n\n        balance = self.get_balance(node)\n\n        if balance > 1:\n            if key  node.left.key:  # Left-Left Case\n                rotation_counter[0] += 1\n                return self.right_rotate(node)\n            else:  # Left-Right Case\n                rotation_counter[0] += 2\n                node.left = self.left_rotate(node.left)\n                return self.right_rotate(node)\n\n        if balance  -1:\n            if key > node.right.key:  # Right-Right Case\n                rotation_counter[0] += 1\n                return self.left_rotate(node)\n            else:  # Right-Left Case\n                rotation_counter[0] += 2\n                node.right = self.right_rotate(node.right)\n                return self.left_rotate(node)\n        \n        return node\n\ndef solve():\n    \"\"\"\n    Constructs the \"spiteful\" sequence s_1 to s_10 by following the problem's\n    inductive definition.\n    \"\"\"\n    test_indices = range(1, 11)\n\n    root = None\n    used_keys = set()\n    spiteful_sequence = []\n    avl_tree = AVLTree()\n\n    for t in test_indices:\n        candidates = {}  # Maps rotation_count -> list_of_keys\n\n        max_used_key = max(used_keys) if used_keys else 0\n        search_limit = max_used_key + 2\n        if t  5:\n            search_limit = max(search_limit, t + 5)\n\n        for probe_key in range(1, search_limit + 1): # Extend search limit just in case\n            if probe_key in used_keys:\n                continue\n\n            tree_copy = copy.deepcopy(root)\n            _, rotations = avl_tree.insert(tree_copy, probe_key)\n            \n            if rotations not in candidates:\n                candidates[rotations] = []\n            candidates[rotations].append(probe_key)\n\n        max_rotations = -1\n        if candidates:\n            max_rotations = max(candidates.keys())\n\n        best_key = min(candidates[max_rotations])\n        \n        spiteful_sequence.append(best_key)\n        used_keys.add(best_key)\n        root, _ = avl_tree.insert(root, best_key)\n\n    print(f\"[{','.join(map(str, spiteful_sequence))}]\")\n\nsolve()\n\n```", "id": "3213238"}]}