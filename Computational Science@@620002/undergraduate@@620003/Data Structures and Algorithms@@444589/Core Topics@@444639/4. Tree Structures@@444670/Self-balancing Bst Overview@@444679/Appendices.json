{"hands_on_practices": [{"introduction": "Before we can confidently build or modify complex data structures like Red-Black Trees, we must first be able to verify their integrity. This practice challenges you to move from theory to implementation by creating a verifier that checks if a given tree adheres to all of the fundamental RBT invariants. By designing an algorithm that checks these properties in a single, efficient $O(N)$ traversal, you will gain a much deeper and more tangible understanding of the rules that give Red-Black Trees their power [@problem_id:3269583].", "problem": "Design and implement a verifier that decides whether a given colored binary search tree is a valid Red-Black Tree (RBT) in time complexity $O(N)$, where $N$ is the number of nodes reachable from the designated root. The verifier must be derived from first principles, starting only from core definitions, and must be correct for all finite trees.\n\nA Red-Black Tree (RBT) is a binary search tree (BST) equipped with a color on each internal node satisfying the following invariants derived from fundamental definitions of search trees and the notion of balanced black-height:\n- Binary Search Tree (BST) property: For every node with key $k$, all keys in its left subtree are strictly less than $k$, and all keys in its right subtree are strictly greater than $k$. Keys are assumed to be integers and strictly ordered.\n- Root color property: The root node, if it exists, is colored black.\n- Red property (no red-red edge): No red node has a red child.\n- Black-height property: For every node, the number of black nodes on any simple path from that node to any descendant null leaf is the same. Here, the null children are treated as black leaves.\n- By convention, the empty tree is considered a valid Red-Black Tree with black-height $0$.\n\nInput model to be used inside your program (no external input should be read): A colored BST is represented as a pair $(\\text{nodes}, \\text{root})$ where:\n- $\\text{nodes}$ is an array indexed from $0$ to $n-1$, where each entry is a record $(\\text{key}, \\text{color}, \\text{left}, \\text{right})$.\n- $\\text{key}$ is an integer key.\n- $\\text{color}$ is a character, either $'B'$ (black) or $'R'$ (red).\n- $\\text{left}$ and $\\text{right}$ are child indices in $\\{0,\\dots,n-1\\}$ or $-1$ to denote a null child.\n- $\\text{root}$ is the index of the root in $\\{0,\\dots,n-1\\}$ or $-1$ to denote the empty tree.\n- Only nodes reachable from $\\text{root}$ are semantically part of the tree; unreachable nodes may be present but must be ignored by the verifier.\n\nTask requirements:\n- Derive and implement a verification algorithm that, using only the preceding definitions, checks all RBT invariants in $O(N)$ time and $O(H)$ additional space, where $H$ is the height of the tree, by performing a single depth-first traversal that simultaneously enforces the BST ordering constraints, the red property, and the black-height equality.\n- The program should hard-code and evaluate the following test suite of parameter values, each being a separate $(\\text{nodes}, \\text{root})$ instance. For each case, return a boolean indicating whether the instance is a valid RBT.\n\nTest suite to embed in the program:\n\n- Case $1$ (valid RBT, non-trivial):\n  - $\\text{nodes} = [ (10, 'B', 1, 2), (5, 'R', 3, 4), (15, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- Case $2$ (BST ordering violation in the right subtree):\n  - $\\text{nodes} = [ (10, 'B', 1, 2), (5, 'R', 3, 4), (9, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- Case $3$ (isolated red-red violation, all other invariants satisfied including equal black-height):\n  - $\\text{nodes} = [ (10, 'B', 1, 2), (5, 'R', 3, -1), (15, 'R', -1, -1), (2, 'R', -1, -1), (7, 'B', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- Case $4$ (black-height mismatch without a red-red violation):\n  - $\\text{nodes} = [ (10, 'B', 1, 2), (5, 'R', -1, -1), (15, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- Case $5$ (root not black, other invariants satisfied):\n  - $\\text{nodes} = [ (10, 'R', 1, 2), (5, 'B', 3, 4), (15, 'B', -1, -1), (2, 'R', -1, -1), (7, 'R', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- Case $6$ (single-node black tree):\n  - $\\text{nodes} = [ (42, 'B', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- Case $7$ (empty tree):\n  - $\\text{nodes} = [\\ ]$\n  - $\\text{root} = -1$\n\nOutput format:\n- Your program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets, in the exact order of the test cases, for example, $[ \\text{True}, \\text{False}, \\dots ]$.\n\nNo user input or external files are permitted. All computations are unitless and purely combinatorial; no physical units apply. Angles are not used. Percentages do not appear. The answer for each case must be a boolean.", "solution": "The problem requires the design and implementation of a verifier for Red-Black Trees (RBTs). The verifier must decide if a given colored binary search tree is a valid RBT in $O(N)$ time and $O(H)$ auxiliary space, where $N$ is the number of nodes reachable from the root and $H$ is the tree's height. The derivation must proceed from first principles.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\nThe problem provides the following definitions and constraints for a valid Red-Black Tree:\n1.  **Binary Search Tree (BST) property**: For every node with key $k$, all keys in its left subtree are strictly less than $k$, and all keys in its right subtree are strictly greater than $k$.\n2.  **Root color property**: The root node, if it exists, is colored black ($'B'$).\n3.  **Red property (no red-red edge)**: No red ($'R'$) node has a red child.\n4.  **Black-height property**: For every node, the number of black nodes on any simple path from that node to any descendant null leaf is the same. Null children are treated as black leaves.\n5.  **Empty Tree**: The empty tree is a valid RBT.\n\nThe input is a pair $(\\text{nodes}, \\text{root})$, where $\\text{nodes}$ is an array of node records $(\\text{key}, \\text{color}, \\text{left}, \\text{right})$ and $root$ is the index of the root node. A root index of $-1$ denotes an empty tree.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem statement is evaluated against the required criteria:\n-   **Scientifically Grounded**: The problem is based on the formal definition of a Red-Black Tree, a canonical data structure in computer science. The properties listed are the standard, universally accepted invariants for an RBT. The problem is scientifically sound.\n-   **Well-Posed**: The problem is clearly defined. The input format is specified, and the desired output is a boolean decision. The time and space complexity constraints ($O(N)$ and $O(H)$) are specific and achievable. A unique, correct answer exists for any given input.\n-   **Objective**: The problem is stated using formal, objective definitions and avoids any subjective or ambiguous language.\n\nThe problem exhibits none of the invalidating flaws. It is a well-defined, formal problem in the domain of algorithms and data structures.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A solution will be developed and implemented.\n\n### Derivation of the Verification Algorithm\n\nThe objective is to verify all RBT properties simultaneously in a single pass to achieve the $O(N)$ time complexity. A recursive depth-first traversal of the tree is the natural approach. We will design a recursive helper function that traverses the tree and validates properties along the way.\n\nLet the recursive helper function be `validate_subtree(node_idx, parent_color, min_bound, max_bound)`. This function will analyze the subtree rooted at index `node_idx` and return a pair `(is_valid, black_height)`, where `is_valid` is a boolean indicating if the subtree satisfies the RBT properties (given the context from its ancestors) and `black_height` is the count of black nodes on any path from `node_idx` to a descendant null leaf, inclusive of `node_idx` and the null leaf.\n\n**1. Base Case: Null Nodes**\n\nA null node is represented by an index of $-1$. According to the **black-height property**, null children are treated as black leaves. Therefore, a path from a null leaf to itself contains exactly one node (the null leaf), which is black. So, the black-height of a null subtree is $1$. A null subtree trivially satisfies all other properties.\n-   `validate_subtree(-1, ...)` returns `(True, 1)`.\n\n**2. Recursive Step: Internal Nodes**\n\nFor an internal node at index `node_idx`, we must verify all properties.\n\n-   **Unreachable Nodes**: The traversal starts from the specified `root` and only follows valid child indices. Any nodes in the `nodes` array that are not reachable from the `root` will never be visited, correctly ignoring them as per the problem specification.\n\n-   **Red Property**: This property states a red node cannot have a red child. To check this, the recursive function must know the color of the parent node. The parameter `parent_color` serves this purpose. At the current node with color `current_color`, we check if `current_color == 'R'` and `parent_color == 'R'`. If this condition is met, the property is violated.\n\n-   **BST Property**: To ensure the tree is a valid Binary Search Tree, each node's key must lie within a specific range defined by its ancestors. The root can have any key. For any other node, its key must be greater than the key of its left-chain ancestors and less than the key of its right-chain ancestors. We enforce this by passing down a valid range `(min_bound, max_bound)`. For a node with key $k$, all keys in its left subtree must be in the range `(min_bound, k)`, and all keys in its right subtree must be in the range `(k, max_bound)`.\n\n-   **Black-Height Property**: This property states that for any node $n$, the number of black nodes on a simple path from $n$ to any descendant null leaf is constant. Let this number be $BH(n)$. If a node $n$ has children $n_l$ and $n_r$, any path from $n$ must pass through either $n_l$ or $n_r$. For the total count of black nodes to be constant, it is necessary that $BH(n_l) = BH(n_r)$. Our recursive function returns the black-height of the subtree it validates. Therefore, after the recursive calls for the left and right children return `(is_left_valid, left_bh)` and `(is_right_valid, right_bh)`, we must check if `left_bh == right_bh`. If they are not equal, the property is violated.\n\n-   **Calculating Black-Height**: If the properties are satisfied for the children, the black-height of the current node's subtree, $BH(\\text{node})$, is calculated based on the (now verified equal) black-height of its children, $BH(\\text{child})$, and its own color. The count of black nodes on a path starting from the current node is its own contribution ( $1$ if black, $0$ if red) plus the count from its child. Thus, $BH(\\text{node}) = BH(\\text{child}) + (\\text{1 if node is black else 0})$.\n\n**3. Main Verifier Function**\n\nThe main function `is_valid_rbt(nodes, root)` orchestrates the verification.\n\n1.  **Empty Tree**: If `root` is $-1$, the tree is empty. By definition, this is a valid RBT. Return `True`.\n2.  **Root Color Property**: If the tree is not empty, the root node must be black. We fetch the root node's data and check its color. If it is red, the tree is invalid. Return `False`.\n3.  **Initiate Traversal**: The traversal starts at the root. The root has no parent, so we can consider its parent \"black\" to ensure the `red property` check doesn't incorrectly fail. The initial key range is unbounded, represented by $(-\\infty, +\\infty)$.\n4.  **Final Verdict**: The main function calls `validate_subtree(root, 'B', -infinity, +infinity)` and returns the boolean part of the result tuple.\n\nThis comprehensive, single-pass, recursive algorithm verifies all specified properties. It visits each reachable node exactly once, performing constant-time work at each node. This results in a time complexity of $O(N)$. The space complexity is determined by the maximum depth of the recursion stack, which is equal to the height of the tree, $H$, thus achieving $O(H)$ auxiliary space.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RBT verification problem for a hard-coded suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (valid RBT, non-trivial)\n        (\n            [ (10, 'B', 1, 2), (5, 'R', 3, 4), (15, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ],\n            0\n        ),\n        # Case 2 (BST ordering violation in the right subtree)\n        (\n            [ (10, 'B', 1, 2), (5, 'R', 3, 4), (9, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ],\n            0\n        ),\n        # Case 3 (isolated red-red violation)\n        (\n            [ (10, 'B', 1, 2), (5, 'R', 3, -1), (15, 'R', -1, -1), (2, 'R', -1, -1), (7, 'B', -1, -1) ],\n            0\n        ),\n        # Case 4 (black-height mismatch)\n        (\n            [ (10, 'B', 1, 2), (5, 'R', -1, -1), (15, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ],\n            0\n        ),\n        # Case 5 (root not black)\n        (\n            [ (10, 'R', 1, 2), (5, 'B', 3, 4), (15, 'B', -1, -1), (2, 'R', -1, -1), (7, 'R', -1, -1) ],\n            0\n        ),\n        # Case 6 (single-node black tree)\n        (\n            [ (42, 'B', -1, -1) ],\n            0\n        ),\n        # Case 7 (empty tree)\n        (\n            [],\n            -1\n        ),\n    ]\n\n    results = []\n    for nodes, root in test_cases:\n        verifier = RBTVerifier(nodes)\n        results.append(verifier.is_valid_rbt(root))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nclass RBTVerifier:\n    \"\"\"\n    A verifier for Red-Black Trees derived from first principles.\n    \"\"\"\n    def __init__(self, nodes):\n        self._nodes = nodes\n\n    def is_valid_rbt(self, root_idx: int) -> bool:\n        \"\"\"\n        Checks if the tree rooted at root_idx is a valid Red-Black Tree.\n        \"\"\"\n        # Property 5: The empty tree is a valid RBT.\n        if root_idx == -1:\n            return True\n\n        root_node = self._nodes[root_idx]\n        root_color = root_node[1]\n\n        # Property 2: The root node, if it exists, is colored black.\n        if root_color == 'R':\n            return False\n\n        # Start recursive validation. The root's parent can be considered black.\n        # The key range for the root is unbounded.\n        is_valid, _ = self._validate_subtree(root_idx, 'B', float('-inf'), float('inf'))\n        return is_valid\n\n    def _validate_subtree(self, node_idx: int, parent_color: str, min_bound: float, max_bound: float) -> tuple[bool, int]:\n        \"\"\"\n        Recursively validates the RBT properties for the subtree at node_idx.\n\n        Returns a tuple: (is_valid, black_height).\n        black_height is the count of black nodes on any path from this node\n        to a descendant null leaf, inclusive of this node and the null leaf.\n        A black_height of 0 is used to signal failure internally.\n        \"\"\"\n        # Base case: A null child is a conceptual black leaf.\n        # The path from this leaf to itself contains one node (itself), which is black.\n        # Its black-height is 1.\n        if node_idx == -1:\n            return True, 1\n\n        key, color, left_idx, right_idx = self._nodes[node_idx]\n\n        # Property 3 (Red Property): A red node cannot have a red child.\n        if color == 'R' and parent_color == 'R':\n            return False, 0\n\n        # Property 1 (BST Property): Key must be within the bounds set by ancestors.\n        if not (min_bound < key < max_bound):\n            return False, 0\n        \n        # Recurse on children, updating bounds and passing current node's color.\n        left_valid, left_bh = self._validate_subtree(left_idx, color, min_bound, key)\n        if not left_valid:\n            return False, 0\n            \n        right_valid, right_bh = self._validate_subtree(right_idx, color, key, max_bound)\n        if not right_valid:\n            return False, 0\n\n        # Property 4 (Black-height Property): All simple paths from this node to\n        # descendant leaves must contain the same number of black nodes.\n        # This means the black-heights returned by its children must be equal.\n        if left_bh != right_bh:\n            return False, 0\n\n        # This subtree is valid. Calculate its black-height.\n        # The black-height is the child's black-height plus 1 if this node is black.\n        current_bh = left_bh + (1 if color == 'B' else 0)\n        \n        return True, current_bh\n\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3269583"}, {"introduction": "Having mastered the invariants of a Red-Black Tree, we now turn to a practical problem: updating the value of a key. A naive in-place modification risks corrupting the entire tree structure by violating the fundamental Binary Search Tree property. This exercise guides you to develop a robust $O(\\log N)$ update algorithm by composing the reliable, pre-existing `delete` and `insert` operations, teaching a crucial software engineering principle of building complex logic from simple, proven primitives [@problem_id:3269521].", "problem": "You are asked to reason from the foundational definitions of Binary Search Tree (BST) and Red-Black Tree (RBT) and implement a program that supports a key-update operation in a Red-Black Tree in logarithmic time. A Binary Search Tree (BST) stores comparable keys so that an in-order traversal yields a strictly increasing sequence. A Red-Black Tree (RBT) is a BST augmented with colors satisfying the classical invariants: every node is either red or black, the root is black, every leaf sentinel (the null child) is black, every red node has black children, and every simple path from a node to a descendant leaf has the same number of black nodes. These well-tested facts imply that standard RBT insertion and deletion run in time $O(\\log N)$, where $N$ is the number of keys, by performing a logarithmic number of rotations and recolorings and maintaining the BST ordering at all times.\n\nDesign an algorithm to update a key in an RBT in $O(\\log N)$ time, given only the fundamental definitions and the existence of the standard RBT insertion and deletion procedures. The update operation must take an existing key $k_{\\text{old}}$ and a new key $k_{\\text{new}}$, and transform the tree so that the key formerly equal to $k_{\\text{old}}$ becomes $k_{\\text{new}}$ while preserving BST ordering and RBT invariants. You must handle the following cases with explicit behavior:\n- If $k_{\\text{old}}$ is not present in the tree, perform no change.\n- If $k_{\\text{new}}$ is already present in the tree and $k_{\\text{new}} \\neq k_{\\text{old}}$, perform no change.\n- If $k_{\\text{new}} = k_{\\text{old}}$ and $k_{\\text{old}}$ exists, this is a no-op.\n\nThe output for each test case must quantify the final state of the tree as a list with the following components, in order:\n- An integer validity flag equal to $1$ if and only if the final tree satisfies all RBT invariants and is a valid BST, otherwise $0$.\n- The final number of keys (an integer).\n- The black-height of the tree (an integer), defined as the number of black nodes on any simple path from the root down to and including a null leaf sentinel; if the tree is not a valid RBT, output $-1$ for this component.\n- The height of the tree (an integer), defined as the number of real nodes on a longest simple root-to-leaf path; an empty tree has height $0$.\n- The in-order traversal as a list of integers in strictly increasing order.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each result must be a list structured as described above.\n\nTest suite. For each test, the initial tree is constructed by inserting the given keys in the listed order, and then the listed sequence of update requests $(k_{\\text{old}}, k_{\\text{new}})$ is applied in order. Keys are integers, and initial lists contain unique values.\n- Test $1$:\n  - Initial keys: $[10, 20, 30, 15, 25, 5, 1]$.\n  - Updates: $(15, 17)$, $(25, 22)$, $(1, 26)$.\n- Test $2$:\n  - Initial keys: $[7, 3, 18, 10, 22, 8, 11, 26]$.\n  - Updates: $(3, 2)$, $(26, 30)$, $(7, 7)$, $(8, 9)$.\n- Test $3$:\n  - Initial keys: $[1, 2, 3, 4, 5]$.\n  - Updates: $(6, 0)$, $(2, 3)$, $(5, 5)$, $(4, -1)$.\n- Test $4$:\n  - Initial keys: $[50, 25, 75, 12, 37, 62, 87, 6, 18, 31, 43, 56, 68, 81, 93]$.\n  - Updates: $(37, 38)$, $(62, 24)$, $(81, 90)$, $(12, 13)$, $(93, 1)$.\n\nYour implementation must be grounded on the core definitions and facts stated above, without assuming any specialized shortcut formula. The required time complexity for the update operation is $O(\\log N)$, justified from first principles. The final output must be a single line formatted as a JSON-like Python list of per-test-case result lists, in the order of the tests above.", "solution": "The problem requires the design and implementation of an algorithm to update a key in a Red-Black Tree (RBT) from a value $k_{\\text{old}}$ to $k_{\\text{new}}$ in $O(\\log N)$ time, where $N$ is the number of keys in the tree. The solution must be derived from the fundamental properties of Binary Search Trees (BSTs) and RBTs.\n\nA Binary Search Tree maintains a crucial invariant: for any node with key $k$, all keys in its left subtree are less than $k$, and all keys in its right subtree are greater than $k$. This property dictates the structural position of every node within the tree. A Red-Black Tree is a special type of self-balancing BST that maintains this ordering while also satisfying a set of color-based invariants to ensure that the tree's height remains logarithmic in the number of nodes, specifically $O(\\log N)$. Standard operations like insertion and deletion on an RBT preserve all invariants and complete in $O(\\log N)$ time due to a limited number of local recoloring and restructuring operations (rotations).\n\nConsider a naive approach to the update operation:\n1. Find the node $x$ containing the key $k_{\\text{old}}$.\n2. Directly modify the key of this node: $x.key \\leftarrow k_{\\text{new}}$.\n\nThis approach is flawed because it can violate the fundamental BST ordering property. The node $x$ is located at a specific position in the tree based on the value of $k_{\\text{old}}$ relative to its ancestors and descendants. Changing its key to $k_{\\text{new}}$ does not change its position. If $k_{\\text{new}}$ violates the ordering with respect to $x$'s parent, children, or any other node in the tree, the BST property is broken. For example, if a node with key $10$ has a right child with key $15$, updating the parent's key to $20$ would violate the BST property, as a node with key $20$ would be in the left subtree of a node with key $15$ (its own child). Repairing such a structural violation by moving the node and its subtrees while preserving RBT invariants would be a highly complex, non-local operation, likely equivalent to or more complex than deletion and insertion.\n\nA more principled approach recognizes that changing a key's value is equivalent to changing its identity with respect to the tree's order. The correct structural position for $k_{\\text{new}}$ may be entirely different from that of $k_{\\text{old}}$. Therefore, the operation must effectively \"move\" the key from its old position to its new one. The most direct way to achieve this using standard, well-defined RBT operations is to perform a deletion followed by an insertion.\n\nThe proposed algorithm is as follows:\n1.  **Handle Preconditions**: The problem specifies behavior for several edge cases.\n    - If $k_{\\text{old}} = k_{\\text{new}}$, the operation is a no-op. No change is needed.\n    - If a node with key $k_{\\text{new}}$ already exists in the tree (and $k_{\\text{new}} \\neq k_{\\text{old}}$), no change should be performed. This prevents the creation of duplicate keys, which would violate the BST property. This check requires a search for $k_{\\text{new}}$, which takes $O(\\log N)$ time.\n    - If the key $k_{\\text{old}}$ is not present in the tree, no change is made.\n\n2.  **Core Logic**: If the preconditions for inaction are not met (i.e., $k_{\\text{old}} \\neq k_{\\text{new}}$, $k_{\\text{new}}$ is not in the tree, and $k_{\\text{old}}$ is in the tree), the update proceeds.\n    - **Deletion**: Perform a standard RBT deletion of the key $k_{\\text{old}}$. The problem states this operation is available and runs in $O(\\log N)$ time. This process correctly removes the node and rebalances the tree to maintain all RBT invariants. If $k_{\\text{old}}$ is not found, the `delete` operation naturally does nothing, satisfying the problem's requirement.\n    - **Insertion**: Perform a standard RBT insertion of the new key $k_{\\text{new}}$. This operation also runs in $O(\\log N)$ time, placing the new key in its correct structural position while preserving all RBT invariants.\n\n**Complexity Analysis**:\nThe overall `update` algorithm consists of a constant number of standard RBT operations:\n- One search operation to check for the existence of $k_{\\text{new}}$: $O(\\log N)$.\n- One deletion operation for $k_{\\text{old}}$ (which includes a search): $O(\\log N)$.\n- One insertion operation for $k_{\\text{new}}$: $O(\\log N)$.\n\nThe total time complexity is the sum of these, which is $O(\\log N) + O(\\log N) + O(\\log N) = O(\\log N)$. This satisfies the performance requirement of the problem. This delete-then-insert strategy correctly and efficiently performs the key update by leveraging the guaranteed correctness and performance of the base RBT operations.\n\nThe implementation will consist of a complete RBT data structure including `insert`, `delete`, their fixup routines, and rotations. The `update` method will orchestrate these primitives as described. Finally, a set of validation methods will be implemented to check the final state of the tree against all BST and RBT invariants and to compute the required output metrics (validity flag, node count, black-height, height, and in-order traversal).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# Increase recursion limit for deep trees; a safeguard for robust tree algorithms.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"A node in the Red-Black Tree.\"\"\"\n    def __init__(self, key, color='RED', parent=None, left=None, right=None):\n        self.key = key\n        self.color = color\n        self.parent = parent\n        self.left = left\n        self.right = right\n    \n    def __repr__(self):\n        return f\"Node(key={self.key}, color={self.color})\"\n\nclass RedBlackTree:\n    \"\"\"A Red-Black Tree implementation supporting key updates.\"\"\"\n    def __init__(self):\n        # The NIL sentinel is a single black node representing all leaves.\n        self.NIL = Node(key=None, color='BLACK')\n        self.root = self.NIL\n        self.size = 0\n\n    def _left_rotate(self, x):\n        y = x.right\n        x.right = y.left\n        if y.left is not self.NIL:\n            y.left.parent = x\n        y.parent = x.parent\n        if x.parent is self.NIL:\n            self.root = y\n        elif x == x.parent.left:\n            x.parent.left = y\n        else:\n            x.parent.right = y\n        y.left = x\n        x.parent = y\n\n    def _right_rotate(self, y):\n        x = y.left\n        y.left = x.right\n        if x.right is not self.NIL:\n            x.right.parent = y\n        x.parent = y.parent\n        if y.parent is self.NIL:\n            self.root = x\n        elif y == y.parent.right:\n            y.parent.right = x\n        else:\n            y.parent.left = x\n        x.right = y\n        y.parent = x\n\n    def insert(self, key):\n        if self.find(key) is not self.NIL:\n            return\n\n        z = Node(key=key, left=self.NIL, right=self.NIL)\n        y = self.NIL\n        x = self.root\n\n        while x is not self.NIL:\n            y = x\n            if z.key < x.key:\n                x = x.left\n            else:\n                x = x.right\n\n        z.parent = y\n        if y is self.NIL:\n            self.root = z\n        elif z.key < y.key:\n            y.left = z\n        else:\n            y.right = z\n\n        z.color = 'RED'\n        self._insert_fixup(z)\n        self.size += 1\n\n    def _insert_fixup(self, z):\n        while z.parent.color == 'RED':\n            if z.parent == z.parent.parent.left:\n                y = z.parent.parent.right  # Uncle\n                if y.color == 'RED':\n                    z.parent.color = 'BLACK'\n                    y.color = 'BLACK'\n                    z.parent.parent.color = 'RED'\n                    z = z.parent.parent\n                else:\n                    if z == z.parent.right:\n                        z = z.parent\n                        self._left_rotate(z)\n                    z.parent.color = 'BLACK'\n                    z.parent.parent.color = 'RED'\n                    self._right_rotate(z.parent.parent)\n            else:\n                y = z.parent.parent.left  # Uncle\n                if y.color == 'RED':\n                    z.parent.color = 'BLACK'\n                    y.color = 'BLACK'\n                    z.parent.parent.color = 'RED'\n                    z = z.parent.parent\n                else:\n                    if z == z.parent.left:\n                        z = z.parent\n                        self._right_rotate(z)\n                    z.parent.color = 'BLACK'\n                    z.parent.parent.color = 'RED'\n                    self._left_rotate(z.parent.parent)\n        self.root.color = 'BLACK'\n\n    def _transplant(self, u, v):\n        if u.parent is self.NIL:\n            self.root = v\n        elif u == u.parent.left:\n            u.parent.left = v\n        else:\n            u.parent.right = v\n        v.parent = u.parent\n\n    def delete(self, key):\n        z = self.find(key)\n        if z is self.NIL:\n            return False\n\n        y = z\n        y_original_color = y.color\n        if z.left is self.NIL:\n            x = z.right\n            self._transplant(z, z.right)\n        elif z.right is self.NIL:\n            x = z.left\n            self._transplant(z, z.left)\n        else:\n            y = self._tree_minimum(z.right)\n            y_original_color = y.color\n            x = y.right\n            if y.parent == z:\n                x.parent = y\n            else:\n                self._transplant(y, y.right)\n                y.right = z.right\n                y.right.parent = y\n            self._transplant(z, y)\n            y.left = z.left\n            y.left.parent = y\n            y.color = z.color\n        \n        if y_original_color == 'BLACK':\n            self._delete_fixup(x)\n        \n        self.size -= 1\n        return True\n\n    def _delete_fixup(self, x):\n        while x is not self.root and x.color == 'BLACK':\n            if x == x.parent.left:\n                w = x.parent.right\n                if w.color == 'RED':\n                    w.color = 'BLACK'\n                    x.parent.color = 'RED'\n                    self._left_rotate(x.parent)\n                    w = x.parent.right\n                if w.left.color == 'BLACK' and w.right.color == 'BLACK':\n                    w.color = 'RED'\n                    x = x.parent\n                else:\n                    if w.right.color == 'BLACK':\n                        w.left.color = 'BLACK'\n                        w.color = 'RED'\n                        self._right_rotate(w)\n                        w = x.parent.right\n                    w.color = x.parent.color\n                    x.parent.color = 'BLACK'\n                    w.right.color = 'BLACK'\n                    self._left_rotate(x.parent)\n                    x = self.root\n            else:\n                w = x.parent.left\n                if w.color == 'RED':\n                    w.color = 'BLACK'\n                    x.parent.color = 'RED'\n                    self._right_rotate(x.parent)\n                    w = x.parent.left\n                if w.right.color == 'BLACK' and w.left.color == 'BLACK':\n                    w.color = 'RED'\n                    x = x.parent\n                else:\n                    if w.left.color == 'BLACK':\n                        w.right.color = 'BLACK'\n                        w.color = 'RED'\n                        self._left_rotate(w)\n                        w = x.parent.left\n                    w.color = x.parent.color\n                    x.parent.color = 'BLACK'\n                    w.left.color = 'BLACK'\n                    self._right_rotate(x.parent)\n                    x = self.root\n        x.color = 'BLACK'\n\n    def find(self, key):\n        x = self.root\n        while x is not self.NIL and key != x.key:\n            if key < x.key:\n                x = x.left\n            else:\n                x = x.right\n        return x\n\n    def _tree_minimum(self, x):\n        while x.left is not self.NIL:\n            x = x.left\n        return x\n\n    def update(self, k_old, k_new):\n        if k_old == k_new:\n            return\n        if self.find(k_new) is not self.NIL:\n            return\n        if self.delete(k_old):\n            self.insert(k_new)\n\n    def get_in_order_traversal(self):\n        result = []\n        def _in_order(node):\n            if node is not self.NIL:\n                _in_order(node.left)\n                result.append(node.key)\n                _in_order(node.right)\n        _in_order(self.root)\n        return result\n\n    def get_height(self):\n        if self.root is self.NIL:\n            return 0\n        def _height(node):\n            if node is self.NIL:\n                return 0\n            return 1 + max(_height(node.left), _height(node.right))\n        return _height(self.root)\n\n    def get_final_state(self):\n        in_order = self.get_in_order_traversal()\n        \n        is_bst = all(in_order[i] < in_order[i+1] for i in range(len(in_order)-1))\n\n        def _validate_rbt(node):\n            if node is self.NIL:\n                return True, True, 1\n            \n            p4_node = True\n            if node.color == 'RED' and (node.left.color == 'RED' or node.right.color == 'RED'):\n                p4_node = False\n            \n            p4_left, p5_left, bh_left = _validate_rbt(node.left)\n            p4_right, p5_right, bh_right = _validate_rbt(node.right)\n            \n            is_p4_valid = p4_node and p4_left and p4_right\n            is_p5_valid = p5_left and p5_right and (bh_left == bh_right)\n            \n            bh = -1\n            if is_p5_valid:\n                bh = bh_left + (1 if node.color == 'BLACK' else 0)\n            \n            return is_p4_valid, is_p5_valid, bh\n\n        validity_flag = 0\n        black_height = -1\n        \n        if self.root is self.NIL:\n            validity_flag = 1\n            black_height = 1\n        elif self.root.color == 'BLACK':\n            p4_valid, p5_valid, bh = _validate_rbt(self.root)\n            if is_bst and p4_valid and p5_valid:\n                validity_flag = 1\n                black_height = bh\n        \n        return [validity_flag, self.size, black_height, self.get_height(), in_order]\n\ndef solve():\n    test_cases = [\n        {\"initial_keys\": [10, 20, 30, 15, 25, 5, 1], \"updates\": [(15, 17), (25, 22), (1, 26)]},\n        {\"initial_keys\": [7, 3, 18, 10, 22, 8, 11, 26], \"updates\": [(3, 2), (26, 30), (7, 7), (8, 9)]},\n        {\"initial_keys\": [1, 2, 3, 4, 5], \"updates\": [(6, 0), (2, 3), (5, 5), (4, -1)]},\n        {\"initial_keys\": [50, 25, 75, 12, 37, 62, 87, 6, 18, 31, 43, 56, 68, 81, 93], \"updates\": [(37, 38), (62, 24), (81, 90), (12, 13), (93, 1)]}\n    ]\n\n    results = []\n    for case in test_cases:\n        tree = RedBlackTree()\n        for key in case[\"initial_keys\"]:\n            tree.insert(key)\n        \n        for k_old, k_new in case[\"updates\"]:\n            tree.update(k_old, k_new)\n            \n        final_state = tree.get_final_state()\n        results.append(final_state)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3269521"}, {"introduction": "Self-balancing trees offer different performance guarantees, and understanding these trade-offs is key to choosing the right tool for a job. While AVL and Red-Black trees provide worst-case $O(\\log N)$ guarantees for each operation, Splay trees offer an amortized $O(\\log N)$ guarantee, meaning some operations can be much slower. This problem demystifies this distinction by tasking you with constructing a specific sequence of operations that forces a single splay operation to take $\\Omega(N)$ time, providing a concrete illustration of the difference between worst-case and amortized performance [@problem_id:3269554].", "problem": "A self-balancing Binary Search Tree (BST) is a binary search tree that performs structural adjustments during operations to maintain favorable height bounds without storing explicit balance information at each node. A splay tree is a canonical example: it performs a sequence of rotations called splaying to move an accessed node to the root. The fundamental primitives are single rotations and the three splay steps, defined on a node $x$ with parent $p$ and grandparent $g$: zig (applied when $x$ has no grandparent), zig-zig (applied when $x$ and $p$ are both left children or both right children), and zig-zag (applied when $x$ and $p$ are on opposite sides). Each rotation is a constant-time pointer rearrangement. Consider the following sequence of operations on a splay tree that uses the classical bottom-up splaying after inserts and searches, and has no duplicate keys:\n\n- Start with an empty tree.\n- Insert keys in strictly decreasing order $N,N-1,\\dots,2,1$, where after each insertion of a key $k$ the splay operation is immediately applied to $k$ (which is standard for splay tree insertion).\n- Then perform a search for the key $N$, applying the splay operation to $N$ at the end of the search.\n\nDerive, from first principles and the definitions of splay steps, the exact number of single rotations performed during the final search-and-splay of $N$ as a function of $N$. Express your final answer as a closed-form expression in $N$. No rounding is required and no units are involved. Your derivation must begin from the BST property and the splay step definitions (zig, zig-zig, zig-zag), and must not appeal to unproven shortcuts about splay tree amortized bounds. The correctness of the sequence shape prior to the final search must be justified using these primitives and the BST order properties. The final answer must be a single analytic expression in $N$.", "solution": "The problem requires the derivation of the exact number of single rotations performed during the search and subsequent splay of the key $N$ in a splay tree, following a specific sequence of insertions. The derivation must be from first principles.\n\nThe solution is divided into two main parts. First, we determine the precise structure of the splay tree after the specified insertion sequence. Second, we analyze the search for $N$ and the splaying of node $N$ based on this structure to count the rotations.\n\n**Part 1: Determining the Structure of the Splay Tree**\n\nThe initial state is an empty tree. The keys $N, N-1, \\dots, 2, 1$ are inserted in sequence. After each insertion of a key $k$, the node containing $k$ is splayed to the root.\n\nWe will prove by induction that after inserting the keys $N, N-1, \\dots, k$ (for $1 \\le k \\le N$), the resulting tree is a right-leaning chain (a \"stick\") with root $k$. The nodes in the tree are $\\{k, k+1, \\dots, N\\}$, and for any node $i$ in this set where $i < N$, its right child is $i+1$ and its left child is null.\n\n**Base Case:** The first key inserted is $N$.\n- The tree contains a single node, $N$. Splaying this node has no effect as it is already the root.\n- The tree is a right-leaning chain of length $1$ with root $N$. The proposition holds for $k=N$.\n\n**Inductive Hypothesis:** Assume that after inserting the keys $N, N-1, \\dots, k+1$, the tree is a right-leaning chain with root $k+1$. The structure is:\n$$(k+1) \\rightarrow_R (k+2) \\rightarrow_R \\dots \\rightarrow_R N$$\nwhere $\\rightarrow_R$ denotes a right-child link.\n\n**Inductive Step:** We now insert the key $k$.\n1.  According to the Binary Search Tree (BST) property, to insert $k$, we start at the root, which is $k+1$. Since $k < k+1$, we must proceed to the left.\n2.  The root $k+1$ has no left child under the inductive hypothesis. Thus, the new node $k$ is inserted as the left child of $k+1$.\n3.  The tree structure immediately after insertion, but before splaying $k$, is a root $k+1$ with a left child $k$ and its original right subtree.\n4.  The next step is to splay the newly inserted node $k$. Node $k$ has parent $p = k+1$. The parent $p$ is the root of the tree, so $k$ has no grandparent.\n5.  According to the definition of splay steps, when the node to be splayed ($x=k$) has a parent but no grandparent, a **Zig** step is performed. This consists of a single rotation that makes $x$ the new root.\n6.  In this case, $k$ is a left child of $k+1$. A single right rotation is performed on the edge between $k+1$ and $k$.\n7.  After the rotation, $k$ becomes the new root. Its former parent, $k+1$, becomes the right child of $k$. The original right subtree of $k$ (which was null) becomes the left child of $k+1$. The original right subtree of $k+1$ remains its right subtree.\n8.  The resulting tree has root $k$, whose right child is $k+1$, whose right child is $k+2$, and so on. The structure is:\n$$k \\rightarrow_R (k+1) \\rightarrow_R (k+2) \\rightarrow_R \\dots \\rightarrow_R N$$\nThis is a right-leaning chain with root $k$. The induction is complete.\n\nBy this inductive argument, after inserting all keys from $N$ down to $1$, the final structure of the tree (for $k=1$) is a right-leaning chain with root $1$:\n$$1 \\rightarrow_R 2 \\rightarrow_R 3 \\rightarrow_R \\dots \\rightarrow_R (N-1) \\rightarrow_R N$$\n\n**Part 2: Analyzing the Final Search and Splay Operation**\n\nThe final operation is to search for the key $N$ and then splay its node to the root.\n\n**Search Path:**\n- The search for $N$ begins at the root, which is the node with key $1$.\n- Since $N > 1$, we traverse to the right child, which is node $2$.\n- Since $N > 2$, we traverse to the right child, node $3$.\n- This process continues down the right-leaning chain until we reach the node with key $N$.\n- The path of traversal is $1 \\rightarrow 2 \\rightarrow \\dots \\rightarrow N$.\n- The depth of a node is the number of edges on the path from the root to that node. The path to $N$ has $N-1$ edges. Therefore, the depth of node $N$ is $d = N-1$.\n\n**Splay Operation:**\nWe now splay the node $N$ from its position at depth $d=N-1$. The path from the root to $N$ consists entirely of right-child links. Let $x$ be the node being splayed, initially $x=N$.\n\n- Any time $x$ has a grandparent $g$, its parent is $p$. In our tree, $x$ is the right child of $p$, and $p$ is the right child of $g$. This configuration calls for a **Zig-Zig** step.\n- A Zig-Zig step consists of two single rotations. It has the effect of moving $x$ up by two levels in the tree, replacing its grandparent.\n\n- The splay process on a node at depth $d$ on a straight path proceeds as follows:\n  1.  Repeatedly apply the Zig-Zig step as long as the node has a grandparent. Each Zig-Zig step costs $2$ rotations and reduces the node's depth by $2$. The number of Zig-Zig steps possible is $\\lfloor d/2 \\rfloor$.\n  2.  Total rotations from these steps: $2 \\times \\lfloor d/2 \\rfloor$.\n  3.  After these steps, the remaining depth of the node is $d_{rem} = d - 2 \\times \\lfloor d/2 \\rfloor$. This is equivalent to $d \\pmod 2$.\n  4.  If $d_{rem} = 1$ (which occurs if and only if $d$ is odd), the node is now a child of the root. It has a parent but no grandparent. A final **Zig** step is required. A Zig step costs $1$ rotation and makes the node the root.\n  5.  If $d_{rem} = 0$ (which occurs if and only if $d$ is even), the node has become the root, and the operation is complete.\n\nThe total number of single rotations is the sum of rotations from all Zig-Zig steps and the final Zig step (if any).\nTotal Rotations $= (2 \\times \\text{number of Zig-Zig steps}) + (1 \\times \\text{number of Zig steps})$\nTotal Rotations $= 2 \\times \\lfloor d/2 \\rfloor + (d \\pmod 2)$.\n\nFor any non-negative integer $d$, the expression $2 \\lfloor d/2 \\rfloor + (d \\pmod 2)$ is identically equal to $d$.\n- If $d$ is even, $d=2k$ for some integer $k \\ge 0$. The expression becomes $2 \\times \\lfloor 2k/2 \\rfloor + (2k \\pmod 2) = 2 \\times k + 0 = 2k = d$.\n- If $d$ is odd, $d=2k+1$ for some integer $k \\ge 0$. The expression becomes $2 \\times \\lfloor (2k+1)/2 \\rfloor + ((2k+1) \\pmod 2) = 2 \\times k + 1 = 2k+1 = d$.\n\nSo, the total number of rotations to splay a node from a straight-line path of depth $d$ is exactly $d$.\n\nIn our problem, the node to be splayed is $N$, and its depth is $d = N-1$.\nSubstituting this into our result, the total number of single rotations is $N-1$.\n\nThis holds for all $N \\ge 1$.\n- If $N=1$, the tree is just node $1$. The search finds it at the root (depth $d=0$). The number of rotations is $0$. Our formula gives $1-1=0$.\n- If $N>1$, the depth $d=N-1 \\ge 1$, and the derived count holds.\n\nTherefore, the exact number of single rotations performed during the final search-and-splay of $N$ is $N-1$.", "answer": "$$\\boxed{N-1}$$", "id": "3269554"}]}