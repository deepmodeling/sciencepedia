{"hands_on_practices": [{"introduction": "Can any arbitrary collection of depths correspond to the leaves of a valid binary tree? This exercise challenges that assumption, revealing a fundamental structural constraint that all binary trees must obey. By testing different sets of leaf depths against a powerful mathematical rule related to Kraft's inequality, you will gain a deeper intuition for how the branching structure of a tree dictates the placement of its leaves. This practice [@problem_id:3280782] is essential for validating tree data and understanding the limits of tree-based structures.", "problem": "A rooted binary tree is a finite, ordered tree in which each node has at most two children. A leaf is a node with outdegree $0$, and the depth of a node is the number of edges on the unique path from the root to that node. Consider the multiset of depths of all leaves in a finite rooted binary tree. Which of the following multisets could be the full set of leaf depths of some valid rooted binary tree? Choose all that apply.\n\nA. $\\{1,1,2,3\\}$\n\nB. $\\{2,2,3,3,3\\}$\n\nC. $\\{0,2,3\\}$\n\nD. $\\{1,3,4,4,5,5,5\\}$\n\nE. $\\{2,2,2,2\\}$\n\nProvide justification grounded in the core definitions above and general, widely accepted properties of binary trees, without assuming special restrictions such as every internal node having exactly two children.", "solution": "The problem asks to determine which of the given multisets of numbers can represent the depths of all leaves in a finite rooted binary tree. A rooted binary tree allows nodes to have $0$, $1$, or $2$ children.\n\nA fundamental property connects the depths of the leaves of any such tree. Let $D$ be the multiset of the depths of all leaves in a finite rooted binary tree. This multiset $D = \\{d_1, d_2, \\ldots, d_k\\}$ is valid if and only if it satisfies two conditions:\n1.  If $0 \\in D$, then $D$ must be $\\{0\\}$. A leaf at depth $0$ implies the root node is a leaf. If the root is a leaf, it has no children, and the tree consists of only this single node. Consequently, there can be no other leaves at other depths.\n2.  The sum of the quantities $2^{-d}$ for each depth $d$ in the multiset must be less than or equal to $1$. This is a form of the Kraft's inequality for prefix codes, where leaf depths correspond to codeword lengths.\n    $$ \\sum_{i=1}^{k} 2^{-d_i} \\le 1 $$\n\nLet us provide a brief justification for this inequality. We can construct any binary tree by starting with a single node (the root) and repeatedly applying an expansion operation.\n- **Base Case:** The simplest tree is a single node, which is the root. This node is also a leaf at depth $d=0$. The sum is $2^{-0} = 1$. The inequality $1 \\le 1$ holds.\n- **Inductive Step:** Assume we have a valid binary tree for which the sum is $S = \\sum_{l \\in \\text{leaves}} 2^{-d(l)} \\le 1$. We can expand the tree by picking a leaf $l_0$ at depth $d_0$ and making it an internal node.\n    - If we give $l_0$ one child, this new child becomes a leaf at depth $d_0+1$. The original leaf $l_0$ is removed from the set of leaves. The new sum $S'$ is:\n      $$ S' = S - 2^{-d_0} + 2^{-(d_0+1)} = S - 2^{-d_0} + \\frac{1}{2} 2^{-d_0} = S - \\frac{1}{2} 2^{-d_0} $$\n      Since $S \\le 1$, the new sum $S'$ is also less than or equal to $1$.\n    - If we give $l_0$ two children, these two new children become leaves, both at depth $d_0+1$. The original leaf $l_0$ is removed. The new sum $S'$ is:\n      $$ S' = S - 2^{-d_0} + 2^{-(d_0+1)} + 2^{-(d_0+1)} = S - 2^{-d_0} + 2 \\cdot \\left(\\frac{1}{2} 2^{-d_0}\\right) = S $$\n      The sum remains unchanged.\n\nSince we start with a sum of $1$ and the operations either preserve the sum or decrease it, the sum for any finite rooted binary tree must be less than or equal to $1$. The converse, that any multiset of depths satisfying the inequality corresponds to a valid tree, is also true and can be shown by a constructive algorithm.\n\nWe will now evaluate each option based on this principle.\n\n**A. $\\{1,1,2,3\\}$**\nThe multiset of depths is $D = \\{1,1,2,3\\}$. We calculate the sum:\n$$ S = 2^{-1} + 2^{-1} + 2^{-2} + 2^{-3} = \\frac{1}{2} + \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8} $$\n$$ S = 1 + \\frac{1}{4} + \\frac{1}{8} = \\frac{8}{8} + \\frac{2}{8} + \\frac{1}{8} = \\frac{11}{8} $$\nSince $S = \\frac{11}{8} > 1$, the inequality is violated.\nVerdict: **Incorrect**.\n\n**B. $\\{2,2,3,3,3\\}$**\nThe multiset of depths is $D = \\{2,2,3,3,3\\}$. We calculate the sum:\n$$ S = 2^{-2} + 2^{-2} + 2^{-3} + 2^{-3} + 2^{-3} = 2 \\cdot 2^{-2} + 3 \\cdot 2^{-3} $$\n$$ S = 2 \\cdot \\frac{1}{4} + 3 \\cdot \\frac{1}{8} = \\frac{1}{2} + \\frac{3}{8} = \\frac{4}{8} + \\frac{3}{8} = \\frac{7}{8} $$\nSince $S = \\frac{7}{8} \\le 1$, the inequality holds. Such a tree can be constructed.\nVerdict: **Correct**.\n\n**C. $\\{0,2,3\\}$**\nThe multiset of depths $D = \\{0,2,3\\}$ contains the depth $0$. A leaf at depth $0$ implies the root is a leaf. If the root is a leaf, it has an outdegree of $0$ and cannot have any children. Therefore, the tree consists of a single node. The set of all leaf depths in such a tree would be just $\\{0\\}$. The presence of other leaf depths, $2$ and $3$, creates a contradiction.\nVerdict: **Incorrect**.\n\n**D. $\\{1,3,4,4,5,5,5\\}$**\nThe multiset of depths is $D = \\{1,3,4,4,5,5,5\\}$. We calculate the sum:\n$$ S = 2^{-1} + 2^{-3} + 2 \\cdot 2^{-4} + 3 \\cdot 2^{-5} $$\n$$ S = \\frac{1}{2} + \\frac{1}{8} + 2 \\cdot \\frac{1}{16} + 3 \\cdot \\frac{1}{32} = \\frac{1}{2} + \\frac{1}{8} + \\frac{1}{8} + \\frac{3}{32} $$\n$$ S = \\frac{1}{2} + \\frac{2}{8} + \\frac{3}{32} = \\frac{1}{2} + \\frac{1}{4} + \\frac{3}{32} $$\nTo sum these fractions, we use a common denominator of $32$:\n$$ S = \\frac{16}{32} + \\frac{8}{32} + \\frac{3}{32} = \\frac{16+8+3}{32} = \\frac{27}{32} $$\nSince $S = \\frac{27}{32} \\le 1$, the inequality holds. Such a tree can be constructed.\nVerdict: **Correct**.\n\n**E. $\\{2,2,2,2\\}$**\nThe multiset of depths is $D = \\{2,2,2,2\\}$. We calculate the sum:\n$$ S = 2^{-2} + 2^{-2} + 2^{-2} + 2^{-2} = 4 \\cdot 2^{-2} = 4 \\cdot \\frac{1}{4} = 1 $$\nSince $S = 1 \\le 1$, the inequality holds. A simple example of such a tree is a perfect binary tree of height $2$, which has $4$ leaves, all at depth $2$.\nVerdict: **Correct**.", "answer": "$$\\boxed{BDE}$$", "id": "3280782"}, {"introduction": "Tree traversals provide a linear representation of a hierarchical structure, but how can we reverse the process? This practice guides you through a classic algorithmic challenge: reconstructing a tree's exact parent-child relationships using only its post-order traversal and the depth of each node. By synthesizing the distinct properties of post-order sequences and node depths, you will design an efficient algorithm, a core skill for parsing and manipulating serialized tree data in real-world applications [@problem_id:3280807].", "problem": "You are given the post-order traversal of a rooted ordered tree and, for each node in the traversal sequence, its depth measured as the number of edges from the root. Using only the foundational definitions of a rooted tree, post-order traversal, and node depth, design an algorithm that reconstructs the parent of each node in the given traversal order. A rooted ordered tree is defined as a connected acyclic graph with a designated root such that each nodeâ€™s children are ordered. A post-order traversal is defined recursively: for a node, visit all of its children in order using post-order, and then visit the node itself. The depth of a node is defined as the number of edges on the unique simple path from the root to that node. Your program must validate the consistency of the given sequences with the definitions and return the parent array if valid, or an empty list if invalid.\n\nInput model for each test case:\n- A sequence of node identifiers $S$ given in post-order. Identifiers are arbitrary but, for the purposes of output representation, nodes are indexed by their position in $S$, that is, indices $0$ through $n-1$, where $n$ is the number of nodes.\n- A sequence of nonnegative integer depths $D$ of the same length as $S$, where $D[j]$ is the depth of $S[j]$.\n\nOutput specification:\n- For each test case, return a list $P$ of length $n$ where $P[j]$ equals the index of the parent of the node $S[j]$ within the traversal order, or $-1$ if $S[j]$ is the root.\n- If the input sequence does not represent a valid rooted ordered tree consistent with the given post-order and depth constraints, output the empty list $[]$ for that test case.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result is itself a comma-separated list enclosed in square brackets, with no spaces. For example, the output format must look like $[[p\\_0,p\\_1,\\dots,p\\_{n-1}],[q\\_0,q\\_1,\\dots],[\\dots]]$ on one line.\n\nScientific realism and fundamental base:\n- Use only the core definitions stated above and deduce the algorithmic properties needed to reconstruct the tree. Do not rely on unproven shortcut formulas.\n\nTest suite:\n- Case $1$ (general branching): $S=[0,1,2,3,4,5,6]$, $D=[2,2,1,2,2,1,0]$.\n- Case $2$ (single node): $S=[0]$, $D=[0]$.\n- Case $3$ (deep chain): $S=[0,1,2,3]$, $D=[3,2,1,0]$.\n- Case $4$ (invalid; no root at the end): $S=[0,1]$, $D=[1,1]$.\n\nYour program must process exactly these four cases internally and produce the final single-line output in the format described above.", "solution": "### Principle-Based Solution\nThe solution is derived by reasoning from the foundational definitions of post-order traversal and node depth.\n\nA post-order traversal sequence has the defining property that a parent node is always visited immediately after the traversals of all its children's subtrees are completed. This implies that for any node $v$, its parent $p$ must appear later in the post-order sequence. Consequently, if the nodes are indexed $0, 1, \\dots, n-1$ according to their appearance in the traversal $S$, the parent of the node at index $j$ must be a node at some index $k > j$.\n\nFurthermore, the depth definition dictates that for any node $v$ with parent $p$, their depths are related by $depth(v) = depth(p) + 1$.\n\nCombining these two properties provides a powerful method for reconstruction. If we process the traversal sequence $S$ in reverse order (from index $j = n-1$ down to $0$), we are effectively moving from parents to their descendants. At any point in this reverse scan, for a node at index $j$ with depth $D[j] = d$, its parent must be a node at some index $k > j$ with depth $D[k] = d-1$. The key insight is identifying which node at index $k$ is the correct parent.\n\nDue to the nested structure of subtrees in a post-order traversal, the correct parent for the node at index $j$ is the *most recently encountered* node to its right (i.e., at an index $k>j$) that has a depth of $d-1$. This \"most recent\" node represents the root of the smallest enclosing subtree at the parent's depth level.\n\nThis leads to the following algorithm:\n\n$1$. **Validation**: First, we perform initial consistency checks.\n    - The sequence must not be empty. Let $n$ be the number of nodes. If $n=0$, it is invalid under the problem's implicit assumption of at least one node.\n    - The last node in the traversal, $S[n-1]$, must be the root. Therefore, its depth $D[n-1]$ must be exactly $0$.\n    - All other nodes must be non-root nodes, so their depths $D[j]$ for $j < n-1$ must be greater than $0$.\n\n$2$. **Reconstruction**: We iterate from right to left, from $j = n-1$ down to $0$. We use a map, let's call it `last_at_depth`, to store the index of the most recently seen node for each depth level.\n    - Initialize an integer array $P$ of size $n$ with default values of $-1$.\n    - Initialize the map `last_at_depth`.\n    - Begin the loop for $j$ from $n-1$ down to $0$:\n        a. Let the current node's depth be $d = D[j]$.\n        b. If $d > 0$, the node must have a parent. The parent's depth must be $d-1$. We look for `last_at_depth[d-1]`.\n            i. If a parent at depth $d-1$ has not been seen yet (i.e., `d-1` is not a key in `last_at_depth`), the depth sequence is inconsistent with a valid tree structure. The input is invalid.\n            ii. Otherwise, the parent is the node at index `last_at_depth[d-1]`. We set $P[j] = \\text{last\\_at\\_depth}[d-1]$.\n        c. If $d=0$ (which should only be true for $j=n-1$), the node is the root and its parent remains $-1$.\n        d. Finally, we update the map with the current node's information: `last_at_depth[d] = j$. This establishes the current node as the potential parent for subsequent (leftward) nodes that are its children.\n\nIf the algorithm completes without finding any inconsistencies, the array $P$ holds the unique parent structure of the tree.\n\nLet us trace Case 1: $S=[0,1,2,3,4,5,6]$, $D=[2,2,1,2,2,1,0]$.\n- $n=7$. $D[6]=0$, which is valid for the root.\n- Initialize $P = [-1, -1, -1, -1, -1, -1, -1]$ and `last_at_depth = {}`.\n\n- $j=6$: Node index $6$, depth $D[6]=0$. This is the root. $P[6]$ remains $-1$. Update `last_at_depth[0] = 6`.\n- $j=5$: Node index $5$, depth $D[5]=1$. Parent must have depth $0$. Find `last_at_depth[0]`, which is $6$. Set $P[5] = 6$. Update `last_at_depth[1] = 5$.\n- $j=4$: Node index $4$, depth $D[4]=2$. Parent must have depth $1$. Find `last_at_depth[1]`, which is $5$. Set $P[4] = 5$. Update `last_at_depth[2] = 4$.\n- $j=3$: Node index $3$, depth $D[3]=2$. Parent must have depth $1$. Find `last_at_depth[1]`, which is $5$. Set $P[3] = 5$. Update `last_at_depth[2] = 3$.\n- $j=2$: Node index $2$, depth $D[2]=1$. Parent must have depth $0$. Find `last_at_depth[0]`, which is $6$. Set $P[2] = 6$. Update `last_at_depth[1] = 2$.\n- $j=1$: Node index $1$, depth $D[1]=2$. Parent must have depth $1$. Find `last_at_depth[1]`, which is $2$. Set $P[1] = 2$. Update `last_at_depth[2] = 1$.\n- $j=0$: Node index $0$, depth $D[0]=2$. Parent must have depth $1$. Find `last_at_depth[1]`, which is $2$. Set $P[0] = 2$. Update `last_at_depth[2] = 0$.\n\nThe final parent array is $P = [2, 2, 6, 5, 5, 6, -1]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef reconstruct_parent_array(S, D):\n    \"\"\"\n    Reconstructs the parent array of a rooted ordered tree from its post-order\n    traversal and node depths.\n\n    Args:\n        S (list): A sequence of node identifiers in post-order. For this problem,\n                  it's assumed to be [0, 1, ..., n-1].\n        D (list): A sequence of non-negative integer depths corresponding to S.\n\n    Returns:\n        list: A list P where P[j] is the parent index of node S[j], or -1 for the root.\n              Returns an empty list if the input is invalid.\n    \"\"\"\n    n = len(S)\n    if n == 0:\n        return []\n\n    # Validation: The last node in a post-order traversal must be the root,\n    # and the root's depth must be 0.\n    if D[n - 1] != 0:\n        return []\n\n    if n == 1:\n        return [-1]\n\n    # The parent array P, initialized with -1 for all nodes.\n    # P[j] will store the index of the parent of the node at index j.\n    P = np.full(n, -1, dtype=int)\n\n    # This dictionary maps a depth level to the index of the most recently\n    # seen node at that depth.\n    last_node_at_depth = {0: n - 1}\n\n    # Iterate from the second-to-last node down to the first.\n    for j in range(n - 2, -1, -1):\n        depth = D[j]\n        \n        # Validation: All non-root nodes must have a depth greater than 0.\n        if depth <= 0:\n            return []\n\n        parent_depth = depth - 1\n        \n        # Validation: A parent must exist at the required depth. If not, the\n        # depth sequence is inconsistent with a valid tree structure.\n        if parent_depth not in last_node_at_depth:\n            return []\n\n        parent_idx = last_node_at_depth[parent_depth]\n        P[j] = parent_idx\n        \n        # Record the current node as the most recently seen at its depth.\n        last_node_at_depth[depth] = j\n\n    return P.tolist()\n\n\ndef solve():\n    \"\"\"\n    Defines the test cases from the problem, solves them, and prints the\n    final output in the exact specified format.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general branching)\n        (list(range(7)), [2, 2, 1, 2, 2, 1, 0]),\n        # Case 2 (single node)\n        (list(range(1)), [0]),\n        # Case 3 (deep chain)\n        (list(range(4)), [3, 2, 1, 0]),\n        # Case 4 (invalid; no root at the end)\n        (list(range(2)), [1, 1]),\n    ]\n\n    results = []\n    for s, d in test_cases:\n        result = reconstruct_parent_array(s, d)\n        results.append(result)\n\n    # Format the results into the required single-line string format.\n    # Example: [[-1],[1,2,3,-1]]\n    output_parts = []\n    for res in results:\n        if not res:\n            output_parts.append(\"[]\")\n        else:\n            output_parts.append(f\"[{','.join(map(str, res))}]\")\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n\n```", "id": "3280807"}, {"introduction": "In many network and distribution problems, it is useful to find a \"central\" point that minimizes the maximum distance to any other point in the network. This practice introduces the formal graph-theoretic concepts of a tree's center and radius to solve this exact problem. You will translate the mathematical definitions of eccentricity, radius, and center into a concrete algorithm, applying graph traversal techniques to analyze a tree's global structure and identify its most central nodes [@problem_id:3280735].", "problem": "You are given a finite, connected, undirected acyclic graph, that is, a tree. Let the tree be denoted by $T=(V,E)$ with $|V|=n$ vertices labeled as $0,1,\\dots,n-1$. The distance between two vertices $u$ and $v$, denoted $d(u,v)$, is the number of edges on the unique simple path between $u$ and $v$. The eccentricity of a vertex $v$, denoted $\\mathrm{ecc}(v)$, is $\\max_{u \\in V} d(v,u)$. The radius of the tree, denoted $r(T)$, is $\\min_{v \\in V} \\mathrm{ecc}(v)$. The center of the tree, denoted $C(T)$, is the set of vertices with eccentricity equal to $r(T)$.\n\nStarting only from these definitions, design and implement a program that, for each test tree specified below, computes:\n- the center $C(T)$ as an ascending list of vertex indices,\n- the radius $r(T)$ as an integer,\n- and a boolean indicating whether the center is unique, that is, whether $|C(T)|=1$.\n\nYour algorithm must be correct for any tree and must rely solely on the foundational properties of trees: connectivity, acyclicity, and the uniqueness of simple paths between vertices. You should derive why your method identifies the center and the radius from these base definitions, without assuming or citing any shortcut formulas.\n\nTest Suite:\n- Tree $\\mathrm{T}_1$: $n=5$, $E=\\{(0,1),(1,2),(2,3),(3,4)\\}$.\n- Tree $\\mathrm{T}_2$: $n=4$, $E=\\{(0,1),(1,2),(2,3)\\}$.\n- Tree $\\mathrm{T}_3$: $n=5$, $E=\\{(0,1),(0,2),(0,3),(0,4)\\}$.\n- Tree $\\mathrm{T}_4$: $n=1$, $E=\\emptyset$.\n- Tree $\\mathrm{T}_5$: $n=2$, $E=\\{(0,1)\\}$.\n- Tree $\\mathrm{T}_6$: $n=7$, $E=\\{(0,1),(1,2),(2,3),(2,4),(4,5),(5,6)\\}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a list of the form $[L,R,B]$ where $L$ is the ascending list of center vertex indices, $R$ is the integer radius, and $B$ is the boolean indicating uniqueness. For example, a valid final line for three tests would look like $[[[a_1,\\dots],[r_1],b_1],[[a_2,\\dots],r_2,b_2],[[a_3,\\dots],r_3,b_3]]$ with actual integers replacing symbolic placeholders, and booleans written as $True$ or $False$.\n\nYour program must be self-contained and use the provided test suite exactly as given. It must not read any input or write any output other than the single required line. The only acceptable libraries are the Python standard library and the specified numerical library.", "solution": "The task is to design an algorithm to compute the center $C(T)$ and radius $r(T)$ of a given tree $T=(V,E)$, relying only on the provided foundational definitions. The definitions are:\n- The distance $d(u,v)$ is the number of edges on the unique simple path between vertices $u, v \\in V$.\n- The eccentricity of a vertex $v$, $\\mathrm{ecc}(v)$, is $\\max_{u \\in V} d(v,u)$.\n- The radius of the tree, $r(T)$, is $\\min_{v \\in V} \\mathrm{ecc}(v)$.\n- The center of the tree, $C(T)$, is the set of vertices $\\{v \\in V \\mid \\mathrm{ecc}(v) = r(T)\\}$.\n\nThese definitions naturally prescribe a direct computational procedure. The algorithm's validity rests on its being a direct translation of these mathematical statements into a sequence of computations, rather than relying on external theorems. The procedure is as follows:\n\nFirst, to evaluate the eccentricity of any vertex, one must first determine its distance to all other vertices in the tree. This necessitates the computation of all-pairs shortest paths. Since the graph is a tree and is unweighted, the distance $d(u,v)$ corresponds to the number of edges on the path. The Breadth-First Search (BFS) algorithm is the standard method for finding shortest paths from a single source in an unweighted graph. By executing a BFS starting from each vertex $s \\in V$, we can systematically find the distances $d(s,v)$ for all other vertices $v \\in V$. This process is repeated for every vertex in the tree, yielding all necessary distance information. Let the number of vertices be $n = |V|$.\n\nSecond, with all distances computed, the eccentricity $\\mathrm{ecc}(v)$ for each vertex $v$ is calculated directly from its definition. For each $v \\in V$, we find the maximum value in the set of distances $\\{d(v,u) \\mid u \\in V\\}$. This maximum is, by definition, $\\mathrm{ecc}(v)$. This step is performed for all $n$ vertices, resulting in a list containing the eccentricity of every vertex.\n\nThird, the radius of the tree, $r(T)$, is defined as the minimum eccentricity among all vertices. After computing all $n$ eccentricities, we find the minimum value in this collection. This value is the radius $r(T) = \\min_{v \\in V} \\mathrm{ecc}(v)$.\n\nFourth, the center $C(T)$ is the set of vertices whose eccentricity is equal to the radius. We identify these vertices by iterating through our list of eccentricities and collecting all vertices $v$ for which $\\mathrm{ecc}(v) = r(T)$. The resulting set of vertices constitutes the center of the tree. Per the output requirements, this set is stored as an ascending list of vertex indices.\n\nFinally, the uniqueness of the center is determined by its cardinality, $|C(T)|$. If $|C(T)| = 1$, the center is unique; otherwise, it is not. A boolean value represents this outcome.\n\nThis algorithmic procedure is correct by construction because each step is a direct implementation of the corresponding mathematical definition provided in the problem statement. It relies only on the fundamental property that distances in a connected graph are well-defined and computable (e.g., via BFS). The method does not invoke any advanced, unstated theorems about the properties of tree centers, thereby adhering to the problem's constraints. The computational complexity of this approach for a tree with $n$ vertices is dominated by the all-pairs distance computation. A single BFS traversal on a tree takes time proportional to the number of vertices and edges, which is $O(n + m) = O(n)$ since $m=n-1$. Repeating this for all $n$ vertices gives a total time complexity of $O(n^2)$. The subsequent steps to find the radius and center are of a lower complexity, $O(n)$. For the small values of $n$ in the provided test suite, this $O(n^2)$ complexity is entirely feasible.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the tree center and radius problem for a predefined suite of test cases.\n    \"\"\"\n    \n    # Test Suite\n    test_cases = [\n        # T1: n=5, E={(0,1),(1,2),(2,3),(3,4)}\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4)]),\n        # T2: n=4, E={(0,1),(1,2),(2,3)}\n        (4, [(0, 1), (1, 2), (2, 3)]),\n        # T3: n=5, E={(0,1),(0,2),(0,3),(0,4)}\n        (5, [(0, 1), (0, 2), (0, 3), (0, 4)]),\n        # T4: n=1, E=emptyset\n        (1, []),\n        # T5: n=2, E={(0,1)}\n        (2, [(0, 1)]),\n        # T6: n=7, E={(0,1),(1,2),(2,3),(2,4),(4,5),(5,6)}\n        (7, [(0, 1), (1, 2), (2, 3), (2, 4), (4, 5), (5, 6)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = compute_center_radius(n, edges)\n        results.append(result)\n\n    # Manual string formatting for exact output matching\n    res_strings = []\n    for L, R, B in results:\n        L_str = str(L).replace(' ', '')\n        res_strings.append(f\"[{L_str},{R},{str(B)}]\")\n    \n    final_output = f\"[{','.join(res_strings)}]\"\n    print(final_output)\n\ndef compute_center_radius(n, edges):\n    \"\"\"\n    Computes the center, radius, and uniqueness of the center for a single tree.\n\n    The algorithm directly implements the definitions:\n    1. For each vertex, run a BFS to find its distance to all other vertices.\n    2. The maximum of these distances is the vertex's eccentricity.\n    3. The minimum of all eccentricities is the tree's radius.\n    4. The vertices with eccentricity equal to the radius form the center.\n    \"\"\"\n    if n == 0:\n        return [[], -1, False] # Or handle as an error, but problem implies n>=1\n    if n == 1:\n        return [[0], 0, True]\n\n    adj = {i: [] for i in range(n)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    all_eccentricities = []\n\n    for start_node in range(n):\n        # BFS to find distances from start_node\n        distances = [-1] * n\n        distances[start_node] = 0\n        queue = deque([start_node])\n        \n        max_dist = 0\n        \n        while queue:\n            u = queue.popleft()\n            max_dist = max(max_dist, distances[u])\n\n            for v in adj[u]:\n                if distances[v] == -1:\n                    distances[v] = distances[u] + 1\n                    queue.append(v)\n        \n        all_eccentricities.append(max_dist)\n\n    radius = min(all_eccentricities)\n    center = sorted([i for i, ecc in enumerate(all_eccentricities) if ecc == radius])\n    is_unique = (len(center) == 1)\n    \n    return [center, radius, is_unique]\n\nsolve()\n```", "id": "3280735"}]}