{"hands_on_practices": [{"introduction": "Before we can build and manipulate Red-black Trees, we must first grasp their fundamental structural constraints. This exercise moves beyond simple rule memorization, challenging you to determine if a given binary tree shape can be validly colored according to the RBT invariants at all. By working through this problem ([@problem_id:3280790]), you will develop a deeper intuition for the black-height property, the most crucial invariant for guaranteeing logarithmic performance, and understand that not every balanced-looking tree can be a Red-black Tree.", "problem": "A binary tree is a connected, acyclic, directed structure with a designated root in which each node has at most two children, called the left child and the right child. Consider the canonical definition of a Red-Black Tree (RBT), which is a binary search tree augmented with a coloring and subject to properties that do not depend on key ordering when only structural feasibility is considered. The feasibility of red-black coloring depends solely on the following properties: each node is colored either red or black, the root is black, all absent children (conceptual sentinel leaves) are black, no red node has a red child, and all simple paths from any node to a descendant sentinel leaf contain the same number of black nodes. Let the black-height of a node be the number of black nodes encountered along any simple path from that node down to a sentinel leaf, excluding the sentinel leaf itself.\n\nGiven only the shape of a binary tree (without keys), determine for each provided test case whether there exists a coloring of the actual nodes into red or black such that the Red-Black Tree properties listed above are satisfied. The determination must treat all absent children as sentinel leaves that are black.\n\nInput representation for each test case: the tree is given by a list of ordered pairs $(\\ell_i, r_i)$ for $i \\in \\{0, 1, \\dots, n-1\\}$, where $\\ell_i$ and $r_i$ are indices of the left and right children of node $i$, respectively, and $-1$ denotes an absent child. The root of the tree is node $0$ when $n \\geq 1$, and the tree is empty when $n = 0$. The structure is guaranteed to be a valid rooted binary tree (no cycles, at most two children per node, and children indices refer within the array or are $-1$). The output for each test case must be a boolean indicating whether a valid red-black coloring exists, with the convention that an empty tree is considered colorable in a manner that satisfies the properties (vacuously, the root condition does not apply because there is no root).\n\nFundamental base and definitions to be used:\n- Binary tree structure and sentinel leaves as conceptual black nodes.\n- Red-Black Tree properties (root black, leaves black, no red parent with red child, equal black-height across all paths from any node to its descendant leaves).\n- Black-height definition: for a node $v$, the black-height $\\mathrm{bh}(v)$ is the number of black nodes on any simple path from $v$ to a sentinel leaf, excluding the sentinel leaf.\n\nYour task: For each test case, output a boolean indicating whether the given shape admits at least one red-black coloring satisfying the properties, subject to the root being black when the root exists.\n\nTest suite (each test case is a list of pairs; $-1$ denotes no child):\n- Case $1$: $[]$ (the empty tree).\n- Case $2$: $[(-1,-1)]$.\n- Case $3$: $[(1,2),(3,4),(5,6),(-1,-1),(-1,-1),(-1,-1),(-1,-1)]$.\n- Case $4$: $[(1,-1),(2,-1),(-1,-1)]$.\n- Case $5$: $[(1,2),(3,4),(-1,-1),(-1,-1),(-1,-1)]$.\n- Case $6$: $[(-1,1),(-1,-1)]$.\n\nRequired final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_m]$, where each $\\text{result}_i$ is a boolean corresponding to the $i$-th test case in the order provided above.", "solution": "The problem is subjected to validation to ensure its scientific and logical integrity.\n\n### Step 1: Extract Givens\n\n- **Structure:** The input is a binary tree defined by a list of ordered pairs $(\\ell_i, r_i)$ for nodes $i \\in \\{0, 1, \\dots, n-1\\}$. $\\ell_i$ and $r_i$ are child indices. The value $-1$ signifies an absent child (a conceptual sentinel leaf). Node $0$ is the root if $n \\geq 1$. An empty tree has $n=0$. The input is guaranteed to be a valid rooted binary tree.\n- **Coloring:** Each node is either red or black.\n- **Red-Black Tree Properties (Structural):**\n    1.  The root is black.\n    2.  All sentinel leaves are black.\n    3.  A red node cannot have a red child.\n    4.  For any given node, all simple paths from it to any of its descendant sentinel leaves have the same number of black nodes.\n- **Definition (Black-Height):** The black-height of a node $v$, denoted $\\mathrm{bh}(v)$, is the count of black nodes on any simple path from $v$ to a sentinel leaf, not including the sentinel leaf itself.\n- **Task:** Determine if a valid red-black coloring exists for the given tree structure. An empty tree is considered validly colorable.\n- **Output:** A boolean value for each test case.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded:** The problem is founded on the standard, formal definition of a Red-Black Tree, a cornerstone data structure in computer science. The properties listed are canonical. The problem is well-situated within the domain of algorithms and discrete mathematics. The premise is factually sound.\n- **Well-Posed:** The problem is clearly defined. The input representation is unambiguous, the constraints (RBT properties) are explicit, and the desired output is a definite boolean, indicating the existence of a valid coloring. This forms a standard decision problem for which a unique answer exists.\n- **Objective:** The problem statement is expressed in precise, objective language, using standard terminology from computer science. There are no subjective or ambiguous elements.\n\nAll validation criteria are met. The problem does not exhibit any flaws such as scientific unsoundness, ambiguity, or incompleteness.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A solution will be developed.\n\n### Principle-Based Solution Design\n\nThe problem requires determining the existence of a valid red-black coloring for a given tree structure. The constraints are imposed by the Red-Black Tree properties. We can devise a recursive algorithm, leveraging dynamic programming (memoization), that computes the set of possible structural outcomes for each subtree.\n\nA key insight can be derived from the black-height property: For any node $v$ with children $v_L$ and $v_R$, the number of black nodes on all paths from $v$ through $v_L$ must be equal to the number of black nodes on all paths from $v$ through $v_R$. If we let $\\delta(v) = 1$ if node $v$ is black and $\\delta(v) = 0$ if it is red, this implies $\\delta(v) + \\mathrm{bh}(v_L) = \\delta(v) + \\mathrm{bh}(v_R)$, which simplifies to $\\mathrm{bh}(v_L) = \\mathrm{bh}(v_R)$. If a child is a sentinel leaf $s$, its black-height $\\mathrm{bh}(s)$ is taken to be $0$.\n\nThis suggests a post-order traversal (bottom-up) approach. For each node $u$, we can determine the possible black-heights of the subtree rooted at $u$ based on the possible black-heights of its children's subtrees. However, the \"no red-red parent-child\" rule is a top-down constraint: the color of a node constrains the color of its children.\n\nTo handle both constraints, our recursive function, let's call it $\\Phi(u)$, for a node $u$ must return the set of possible black-heights conditioned on the color of $u$. Thus, $\\Phi(u)$ will compute a pair of sets:\n1.  $\\mathcal{B}_u$: The set of possible black-heights for the subtree at $u$, assuming $u$ is colored **black**.\n2.  $\\mathcal{R}_u$: The set of possible black-heights for the subtree at $u$, assuming $u$ is colored **red**.\n\nThe computation proceeds as follows:\n\n**Base Case:** For a sentinel leaf $s$ (represented by index $-1$), it is conceptually black and has no descendants. The path from it to a sentinel is empty, so its black-height is $0$. Therefore, $\\Phi(s) = (\\mathcal{B}_s, \\mathcal{R}_s) = (\\{0\\}, \\emptyset)$. The set for red-rooted height is empty as sentinels are always black.\n\n**Recursive Step:** For a node $u$ with children $u_L$ and $u_R$, we first recursively compute $(\\mathcal{B}_L, \\mathcal{R}_L) = \\Phi(u_L)$ and $(\\mathcal{B}_R, \\mathcal{R}_R) = \\Phi(u_R)$.\nLet $\\mathcal{A}_L = \\mathcal{B}_L \\cup \\mathcal{R}_L$ and $\\mathcal{A}_R = \\mathcal{B}_R \\cup \\mathcal{R}_R$ be the sets of all possible black-heights for the left and right subtrees, respectively, regardless of their root colors.\n\n1.  **To compute $\\mathcal{B}_u$ (if $u$ is colored black):**\n    - The node $u$ contributes $1$ to the black-height.\n    - Its children, $u_L$ and $u_R$, can be any color.\n    - The black-heights of their respective subtrees must be equal. So, we seek a common height $h$ that is achievable by both subtrees.\n    - $\\mathcal{B}_u = \\{h + 1 \\mid h \\in \\mathcal{A}_L \\cap \\mathcal{A}_R\\}$.\n\n2.  **To compute $\\mathcal{R}_u$ (if $u$ is colored red):**\n    - The node $u$ contributes $0$ to the black-height.\n    - The \"no red-red\" rule dictates that its children, $u_L$ and $u_R$, must be colored **black**.\n    - Thus, their subtrees must have matching black-heights achievable only with black-colored roots ($u_L$ and $u_R$).\n    - $\\mathcal{R}_u = \\{h \\mid h \\in \\mathcal{B}_L \\cap \\mathcal{B}_R\\}$.\n\n**Final Determination:**\n- For an empty tree ($n=0$), the condition is vacuously met, so the answer is `True`.\n- For a non-empty tree with root $r$ (node $0$), we compute $(\\mathcal{B}_r, \\mathcal{R}_r) = \\Phi(r)$.\n- The RBT root must be black. Therefore, a valid coloring exists if and only if there is at least one possible black-height when the root is colored black. This means the set $\\mathcal{B}_r$ must be non-empty.\n\nThis recursive process can be implemented efficiently using memoization to store the results of $\\Phi(u)$ for each node $u$, avoiding recomputation for shared subtrees. The algorithm explores all valid coloring configurations implicitly and determines if any satisfy all properties.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A memoization table to store the results for each subtree, keyed by node index.\n# The value will be a tuple: (set_of_black_rooted_heights, set_of_red_rooted_heights).\nmemo = {}\n# The adjacency list representation of the tree for the current test case.\nadj = []\n\ndef compute_heights(u):\n    \"\"\"\n    Recursively computes possible black-heights for the subtree rooted at u.\n\n    For each node u, it returns a pair of frozensets:\n    1. The set of black-heights if the subtree at u is rooted with a BLACK node.\n    2. The set of black-heights if the subtree at u is rooted with a RED node.\n\n    Args:\n        u (int): The index of the node. -1 represents a sentinel leaf.\n\n    Returns:\n        tuple[frozenset[int], frozenset[int]]: A pair of frozensets for black-rooted\n        and red-rooted colorings of the subtree.\n    \"\"\"\n    if u in memo:\n        return memo[u]\n\n    # Base Case: A sentinel leaf (represented by u = -1).\n    # It is conceptually black and has a black-height of 0. It cannot be red.\n    if u == -1:\n        return (frozenset([0]), frozenset())\n\n    left_child, right_child = adj[u]\n\n    # Recursively compute possible heights for children's subtrees.\n    left_black_h, left_red_h = compute_heights(left_child)\n    right_black_h, right_red_h = compute_heights(right_child)\n\n    # Union of a child's black-rooted and red-rooted heights gives all its possibilities.\n    left_all_h = left_black_h.union(left_red_h)\n    right_all_h = right_black_h.union(right_red_h)\n    \n    # --- Case 1: Node 'u' is colored BLACK ---\n    # Its children can be any color. The black-heights of the children's subtrees must match.\n    # We find the intersection of all possible heights from both children.\n    common_h_for_black_u = left_all_h.intersection(right_all_h)\n    # The black-height of the current subtree is 1 (for node u) + the common child height.\n    my_black_h = {h + 1 for h in common_h_for_black_u}\n\n    # --- Case 2: Node 'u' is colored RED ---\n    # Its children MUST be black. Their black-heights must match.\n    # We find the intersection of heights achievable only with black-rooted children subtrees.\n    common_h_for_red_u = left_black_h.intersection(right_black_h)\n    # The black-height of the current subtree is 0 (for red node u) + the common child height.\n    my_red_h = {h for h in common_h_for_red_u}\n\n    result = (frozenset(my_black_h), frozenset(my_red_h))\n    memo[u] = result\n    return result\n\ndef is_colorable(tree_adj):\n    \"\"\"\n    Determines if a given tree structure can be colored as a Red-Black Tree.\n    \n    Args:\n        tree_adj (list[tuple[int, int]]): The tree structure.\n        \n    Returns:\n        bool: True if a valid coloring exists, False otherwise.\n    \"\"\"\n    # Set up global state for this test case.\n    global adj, memo\n    adj = tree_adj\n    memo = {}\n\n    # Per problem statement, an empty tree is considered colorable.\n    if not adj:\n        return True\n\n    # For a non-empty tree, compute possible heights starting from the root (node 0).\n    # The root of a Red-Black Tree must be black.\n    root_black_h, _ = compute_heights(0)\n    \n    # A valid coloring exists if there's at least one possible black-height\n    # when the root is colored black.\n    return len(root_black_h) > 0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],  # Case 1: Empty tree\n        [(-1, -1)],  # Case 2: Single node tree\n        [(1, 2), (3, 4), (5, 6), (-1, -1), (-1, -1), (-1, -1), (-1, -1)],  # Case 3: Perfect binary tree h=2\n        [(1, -1), (2, -1), (-1, -1)],  # Case 4: A stick of 3 nodes\n        [(1, 2), (3, 4), (-1, -1), (-1, -1), (-1, -1)],  # Case 5: An unbalanced tree\n        [(-1, 1), (-1, -1)],  # Case 6: Root with one child\n    ]\n\n    results = []\n    for case in test_cases:\n        result = is_colorable(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Example: [True,True,True,False,True,True]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3280790"}, {"introduction": "Understanding the logic of the insertion fix-up algorithm is key to mastering Red-black Trees. This practice serves as a bridge from pure theory to algorithmic thinking, asking you to predict the final color of a newly inserted node by analyzing only the local configuration of its parent, grandparent, and uncle ([@problem_id:3266375]). This exercise sharpens your ability to reason through the rebalancing cases—recoloring and rotations—without getting lost in implementation details, building a strong mental model of how the invariants are restored.", "problem": "You are given the formal invariants that define a red-black tree (RBT) and the binary search tree property. Using only these invariants and without simulating any structural update, your task is to derive and implement a method that predicts the final color of a newly inserted node with key $k$ when the standard red-black tree insertion procedure completes. You must reason from the invariants to determine how the color of the newly added node will end up after the algorithm terminates, exclusively through logical analysis of the local configuration at the would-be insertion position. The following definitions form the fundamental base for your derivation.\n\nThe binary search tree property: For any node with key $x$, all keys in its left subtree are strictly less than $x$, and all keys in its right subtree are strictly greater than $x$.\n\nRed-black tree invariants:\n- The root is black.\n- Every leaf node (the external sentinel leaf) is black.\n- If a node is red, then both of its children are black.\n- For every node, all simple paths from that node to a descendant leaf contain the same number of black nodes (this number is called the black-height of the node, and the count excludes the node itself but includes the black sentinel leaves).\n\nYour program must:\n- Walk the existing tree using the binary search tree property to determine the would-be parent and side ($\\text{left}$ or $\\text{right}$) of the new key $k$.\n- Use only the above invariants to deduce the final color of the new node after the insertion procedure completes, without performing any rotations or recolorings.\n- Encode colors as integers: $0$ denotes red and $1$ denotes black.\n\nTest suite:\nProvide predictions for the following fixed scenarios, each consisting of an existing tree and an insertion key $k$.\n\n- Test case $1$: An empty tree; insert $k=42$.\n- Test case $2$: A tree whose root is key $10$ (black), with left child key $5$ (black) and right child key $15$ (black); insert $k=2$.\n- Test case $3$: A tree whose root is key $10$ (black), with left child key $5$ (red) and right child key $15$ (red); insert $k=7$.\n- Test case $4$: A tree whose root is key $10$ (black), with left child key $5$ (red) and right child key $15$ (black); insert $k=7$.\n- Test case $5$: A tree whose root is key $10$ (black), with left child key $5$ (black) and right child key $15$ (red); insert $k=20$.\n\nAssumptions:\n- All given trees satisfy the red-black tree invariants prior to insertion.\n- The key $k$ is distinct from all existing keys.\n- The external leaf is considered a black sentinel and is not an internal node; when reasoning about colors, a missing child is treated as a black leaf.\n\nRequired final output format:\nYour program should produce a single line of output containing the results, one per test case in order from $1$ to $5$, as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is an integer in $\\{0,1\\}$. No other text should be printed.", "solution": "We begin from the binary search tree property and the red-black tree invariants. The binary search tree property identifies the unique place where the new key $k$ would attach, namely as a child of some parent $P$ on either the $\\text{left}$ or $\\text{right}$ side. The red-black tree invariants constrain how the final color of the inserted node can be after the algorithm completes, without specifying the intermediate steps.\n\nFoundational facts consistent with the invariants and standard insertion practice:\n- The new internal node is initially colored red. Coloring it black immediately would increase the black-height of paths that traverse the new node by $1$, violating the invariant that all simple paths from the root to leaves contain the same number of black nodes. Coloring it red preserves black-height locally at the moment of attachment.\n- If the parent $P$ is black, then attaching a red child does not violate the invariant that no red node has a red child. Therefore, no corrective actions are needed that would change the new node’s color; the new node remains red.\n- If the parent $P$ is red, then attaching a red child violates the invariant that a red node must have black children. This violation must be resolved by local recoloring and possibly rotations while preserving black-height.\n\nLet $G$ be the grandparent of the would-be inserted node, and let $U$ be the uncle (the sibling of $P$). By the invariant that no red node has a red parent, $G$ must be black when $P$ is red.\n\nWe consider the cases implied by the invariants:\n\nCase $1$: The tree is empty. By the invariant that the root is black, the inserted node must become the root and end black. Thus, the final color is $1$.\n\nCase $2$: The parent $P$ is black. Because the new node starts red and a black parent having a red child does not violate any invariant, no transformations affecting the new node’s color are required. The final color is $0$.\n\nCase $3$: The parent $P$ is red and the uncle $U$ is red. The violation at $P$ can be eliminated by recoloring $P$ and $U$ to black and $G$ to red. This preserves black-height because the number of black nodes on all paths through $G$ remains unchanged: we remove one black at $G$ but add one black via $P$ and $U$ across both sides, and the new node stays red. If the recoloring causes $G$ to have a red parent, the process logically continues up the tree, but the original new node’s color remains red. Thus, the final color is $0$.\n\nCase $4$: The parent $P$ is red and the uncle $U$ is black (including the sentinel). The invariant that all paths have equal black-height and that red nodes cannot have red children forces a local restructuring. There are two geometric subcases determined by the orientation of $k$ relative to $P$ and $G$:\n- Inner orientation: $P$ is a left child of $G$ and $k$ goes to $P$’s right, or $P$ is a right child of $G$ and $k$ goes to $P$’s left. In this configuration, the only local resolution consistent with invariants is that after a preparatory local rotation, the middle key among $\\{G,P,k\\}$ becomes the parent and is colored black to restore the red-child constraint and maintain black-height. In the inner case, this middle node is the newly inserted node, which therefore ends black. The final color is $1$.\n- Outer orientation: $P$ is a left child of $G$ and $k$ goes to $P$’s left, or $P$ is a right child of $G$ and $k$ goes to $P$’s right. In this configuration, a single rotation around $G$ with a recoloring that makes the middle node (which is $P$) black and $G$ red restores the invariants, while the new node remains red as one of $P$’s children. The final color is $0$.\n\nThese conclusions follow uniquely from the invariants: preservation of equal black-height across all root-to-leaf paths and the prohibition of red nodes having red children. No complete simulation of rotations is necessary; one needs only to inspect the local colors of $P$ and $U$ and the relative orientation of $k$ with respect to $P$ and $G$.\n\nApplying this reasoning to the test suite:\n\n- Test case $1$ ($k=42$ on empty tree): The new node becomes the root, which must be black. Output $1$.\n- Test case $2$ (root $10$ black; children $5$ black, $15$ black; $k=2$): The would-be parent is $5$ black, so the new node remains red. Output $0$.\n- Test case $3$ (root $10$ black; left $5$ red; right $15$ red; $k=7$): Parent red, uncle red, recoloring applies, and the new node remains red. Output $0$.\n- Test case $4$ (root $10$ black; left $5$ red; right $15$ black; $k=7$): Parent red, uncle black, inner orientation (left-right). The new node ends black. Output $1$.\n- Test case $5$ (root $10$ black; left $5$ black; right $15$ red; $k=20$): Parent red, uncle black, outer orientation (right-right). The new node remains red. Output $0$.\n\nTherefore, the required outputs in order are $[1,0,0,1,0]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nRED = 0\nBLACK = 1\n\nclass Node:\n    def __init__(self, key: int, color: int):\n        self.key = key\n        self.color = color\n        self.left = None\n        self.right = None\n        self.parent = None\n\n    def set_left(self, child):\n        self.left = child\n        if child is not None:\n            child.parent = self\n\n    def set_right(self, child):\n        self.right = child\n        if child is not None:\n            child.parent = self\n\ndef bst_find_parent(root, k):\n    \"\"\"\n    Traverse the BST to find the would-be parent of key k and the side ('L' or 'R').\n    Returns (parent_node, side) where side is None if tree is empty.\n    \"\"\"\n    if root is None:\n        return None, None\n    curr = root\n    parent = None\n    side = None\n    while curr is not None:\n        parent = curr\n        if k  curr.key:\n            side = 'L'\n            curr = curr.left\n        else:\n            side = 'R'\n            curr = curr.right\n    return parent, side\n\ndef is_left_child(node):\n    return node.parent is not None and node.parent.left is node\n\ndef is_right_child(node):\n    return node.parent is not None and node.parent.right is node\n\ndef predicted_final_color(root, k):\n    \"\"\"\n    Predict the final color (0 for red, 1 for black) of the node with key k\n    after insertion completes, using only RBT invariants and local configuration.\n    \"\"\"\n    # Empty tree: new node becomes root, which must be black.\n    if root is None:\n        return BLACK\n\n    parent, side = bst_find_parent(root, k)\n    # Parent is black: new node remains red.\n    if parent.color == BLACK:\n        return RED\n\n    # Parent is red: examine grandparent and uncle.\n    grandparent = parent.parent\n    # In a valid RBT, grandparent must exist and be black if parent is red.\n    # Determine uncle (sibling of parent).\n    if grandparent is None:\n        # Defensive fallback: if this happens, treat as becoming root (black).\n        return BLACK\n    uncle = grandparent.right if is_left_child(parent) else grandparent.left\n\n    # Treat missing uncle (None) as black sentinel.\n    uncle_color = BLACK if uncle is None else uncle.color\n\n    if uncle_color == RED:\n        # Recoloring case: new node remains red.\n        return RED\n    else:\n        # Uncle is black: orientation determines outcome.\n        # Inner if parent is left child and insertion to right, or parent is right child and insertion to left.\n        parent_is_left = is_left_child(parent)\n        inner = (parent_is_left and side == 'R') or ((not parent_is_left) and side == 'L')\n        if inner:\n            # Triangle (inner) case: inserted node becomes black.\n            return BLACK\n        else:\n            # Linear (outer) case: inserted node remains red.\n            return RED\n\ndef build_test_cases():\n    tests = []\n\n    # Test 1: Empty tree, insert k=42\n    root1 = None\n    k1 = 42\n    tests.append((root1, k1))\n\n    # Test 2: Root 10 (black), left 5 (black), right 15 (black); insert k=2\n    root2 = Node(10, BLACK)\n    n5_2 = Node(5, BLACK)\n    n15_2 = Node(15, BLACK)\n    root2.set_left(n5_2)\n    root2.set_right(n15_2)\n    k2 = 2\n    tests.append((root2, k2))\n\n    # Test 3: Root 10 (black), left 5 (red), right 15 (red); insert k=7\n    root3 = Node(10, BLACK)\n    n5_3 = Node(5, RED)\n    n15_3 = Node(15, RED)\n    root3.set_left(n5_3)\n    root3.set_right(n15_3)\n    k3 = 7\n    tests.append((root3, k3))\n\n    # Test 4: Root 10 (black), left 5 (red), right 15 (black); insert k=7\n    root4 = Node(10, BLACK)\n    n5_4 = Node(5, RED)\n    n15_4 = Node(15, BLACK)\n    root4.set_left(n5_4)\n    root4.set_right(n15_4)\n    k4 = 7\n    tests.append((root4, k4))\n\n    # Test 5: Root 10 (black), left 5 (black), right 15 (red); insert k=20\n    root5 = Node(10, BLACK)\n    n5_5 = Node(5, BLACK)\n    n15_5 = Node(15, RED)\n    root5.set_left(n5_5)\n    root5.set_right(n15_5)\n    k5 = 20\n    tests.append((root5, k5))\n\n    return tests\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = build_test_cases()\n\n    results = []\n    for root, k in test_cases:\n        result = predicted_final_color(root, k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3266375"}, {"introduction": "The ultimate test of understanding is implementation. This final practice challenges you to synthesize your knowledge by building a complete, iterative Red-black Tree insertion algorithm from the ground up ([@problem_id:3266412]). The constraint to use only constant extra space ($O(1)$) pushes you to master the iterative fix-up loop, a technique essential for high-performance, memory-constrained environments. By translating abstract invariants into concrete, efficient code, you will solidify your command of this foundational data structure.", "problem": "You are to design and implement an iterative insertion algorithm for a Red-Black Tree (RBT), using only a constant amount of extra space (asymptotic big-O notation (O) refers to the rate of growth, and $O(1)$ means constant with respect to the number of keys). Your program must construct a Red-Black Tree (RBT) from given sequences of integer keys and verify that the tree satisfies the Red-Black Tree invariants after all insertions in each sequence. You must produce a single line of output aggregating the results for all test cases, in the exact format specified below.\n\nFoundational definitions to be used:\n- A Binary Search Tree (BST) satisfies the property that for any node with key $k$, every key in its left subtree is strictly less than $k$, and every key in its right subtree is strictly greater than $k$.\n- A Red-Black Tree (RBT) is a BST with an additional color attribute for each node (either red or black) and satisfies the following invariants:\n  1. The root is black.\n  2. All leaves are the same sentinel leaf (commonly represented as a single shared node) and are black.\n  3. Every red node has two black children.\n  4. For every node, every simple path from that node down to a leaf has the same number of black nodes.\n\nYou must implement insertion iteratively. Duplicates are to be ignored (that is, if a key equal to an existing key is inserted, the tree remains unchanged). The sentinel leaf must be represented explicitly and be black.\n\nFor verification and reporting, you must compute:\n- A boolean indicating whether all Red-Black Tree invariants hold after all insertions in the sequence.\n- The black-height of the root as an integer, where the black-height is defined as follows. Let $\\mathrm{bh}^{\\star}(x)$ denote the black-height with the following recurrence:\n  - If $x$ is the sentinel leaf, $\\mathrm{bh}^{\\star}(x) = 1$.\n  - If $x$ is a real node, then under the invariants, $\\mathrm{bh}^{\\star}(x) = \\mathrm{bh}^{\\star}(x.\\mathrm{left}) + \\mathbf{1}_{\\{\\text{color}(x) = \\text{black}\\}} = \\mathrm{bh}^{\\star}(x.\\mathrm{right}) + \\mathbf{1}_{\\{\\text{color}(x) = \\text{black}\\}}$, where $\\mathbf{1}$ is the indicator function.\n- The height $h(T)$ of the tree as an integer, defined as the number of real nodes on a longest simple path from the root down to a real leaf (for an empty tree, $h(T) = 0$; for a tree with one real node, $h(T) = 1$).\n\nYour program must use only a constant amount of extra space beyond the nodes themselves during insertion. Verification routines used after construction are not constrained in space complexity, but must be correct.\n\nTest Suite:\nConstruct the RBT for each of the following insertion sequences, in order, starting from an empty tree for each case. Duplicates in the sequence must be ignored.\n1. Case A (general mixed order): $\\langle 10, 20, 30, 15, 25, 5, 1, 7, 12, 17 \\rangle$.\n2. Case B (strictly increasing): $\\langle 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 \\rangle$.\n3. Case C (strictly decreasing): $\\langle 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 \\rangle$.\n4. Case D (single element): $\\langle 42 \\rangle$.\n5. Case E (contains duplicates to be ignored): $\\langle 5, 3, 7, 3, 5, 7, 2, 8 \\rangle$.\n6. Case F (recoloring chain behavior): $\\langle 11, 2, 14, 1, 7, 5, 8, 15, 13, 12 \\rangle$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for all six cases as a comma-separated list of sublists, each sublist formatted as $[\\text{boolean}, \\text{integer}, \\text{integer}]$, with the boolean written as the lowercase word $true$ or $false$. For example, the output must be in the exact form\n$[[\\text{ok}_A,\\text{bh}_A,\\text{h}_A],[\\text{ok}_B,\\text{bh}_B,\\text{h}_B],[\\text{ok}_C,\\text{bh}_C,\\text{h}_C],[\\text{ok}_D,\\text{bh}_D,\\text{h}_D],[\\text{ok}_E,\\text{bh}_E,\\text{h}_E],[\\text{ok}_F,\\text{bh}_F,\\text{h}_F]]$,\nwith no spaces in the printed line.\n\nNo physical units are involved; all outputs are dimensionless integers and booleans. The program must be complete and runnable without any additional input.", "solution": "The problem requires the design and implementation of an iterative insertion algorithm for a Red-Black Tree (RBT) with a constant extra space complexity of $O(1)$. Following the construction of the tree from several key sequences, the algorithm must verify the integrity of the RBT invariants and report on the tree's structural properties.\n\n### Problem Validation\nFirst, the problem statement is subjected to rigorous validation.\n\n**Step 1: Extract Givens**\n- **Data Structure**: Red-Black Tree (RBT), a type of Binary Search Tree (BST).\n- **Node Attributes**: `key`, `color` (`RED` or `BLACK`), `left` child, `right` child, `parent`.\n- **RBT Invariants**:\n    1. The root is black.\n    2. All leaves (sentinels) are black.\n    3. A red node must have two black children.\n    4. Every simple path from a given node to any of its descendant leaves contains the same number of black nodes.\n- **Sentinel Leaf**: A single, shared, black sentinel node must be used to represent all leaves.\n- **Insertion Rule**: Insertion must be implemented iteratively, not recursively.\n- **Space Complexity Constraint**: Insertion and fix-up operations must use $O(1)$ extra space relative to the number of nodes in the tree.\n- **Duplicate Keys**: Keys that are already present in the tree are to be ignored upon insertion.\n- **Verification Metrics**:\n    1. `ok`: A boolean indicating if all RBT invariants hold.\n    2. `bh`: The black-height of the root, $\\mathrm{bh}^{\\star}(\\text{root})$, defined by the recurrence: $\\mathrm{bh}^{\\star}(x) = 1$ if $x$ is a sentinel leaf, and $\\mathrm{bh}^{\\star}(x) = \\mathrm{bh}^{\\star}(x.\\mathrm{left}) + \\mathbf{1}_{\\{\\text{color}(x) = \\text{black}\\}}$ otherwise.\n    3. `h`: The height of the tree, defined as the number of real nodes on the longest path from the root to a real leaf node.\n- **Test Cases**: Six specific integer sequences are provided for constructing and testing the RBT.\n- **Output Format**: A single-line comma-separated list of sublists, e.g., `[[ok_A,bh_A,h_A],...]`.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is firmly located within the standard computer science curriculum, specifically the study of data structures and algorithms. Red-Black Trees are a classic, well-understood data structure. The definitions of RBT invariants and associated operations are standard textbook material. The problem is scientifically and mathematically sound.\n- **Well-Posed**: The problem is well-posed. The inputs (sequences of keys) are clearly defined, and the desired outputs (a boolean and two integer metrics) are unambiguously specified. An iterative RBT insertion algorithm is known to exist and produce a unique, valid RBT for any given sequence of insertions.\n- **Objective**: The problem is stated using precise, objective, and formal language. There are no subjective or opinion-based components.\n- **Completeness and Consistency**: The problem is self-contained. All necessary definitions for RBTs, invariants, height, and black-height are provided. There are no contradictions. The constraint of $O(1)$ space for insertion is a key requirement that guides the choice of an iterative algorithm over a recursive one (which would use $O(\\log n)$ stack space).\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. It is a well-defined algorithmic task based on established computer science principles. A solution will be provided.\n\n### Algorithmic Design\n\nThe solution involves creating a `RedBlackTree` class that encapsulates the tree's logic, including a `Node` class for its elements.\n\n**1. Data Structures**\n- A `Node` class is defined with attributes: `key`, `color`, `parent`, `left`, and `right`.\n- The `RedBlackTree` class holds a reference to the `root` of the tree and a single `NIL` node, which serves as the sentinel for all leaves, as required. The `NIL` node is always colored `BLACK`.\n\n**2. Rotations**\nTree rotations, `left_rotate` and `right_rotate`, are fundamental operations for rebalancing the tree. They locally restructure the tree to maintain the RBT properties while preserving the BST property. These operations meticulously update the `parent`, `left`, and `right` pointers of the affected nodes. For an iterative implementation, correct management of parent pointers is critical.\n\n**3. Iterative Insertion**\nThe insertion of a new key $k$ is a two-phase process: BST insertion followed by a fix-up phase.\n- **Phase 1: BST Insertion**: The algorithm iteratively traverses the tree from the `root` to find the proper position for the new node, similar to a standard BST. A pointer `y` tracks the parent of the current node `x`. If a node with key $k$ is found, the insertion is aborted, ignoring the duplicate. Otherwise, a new node `z` with key $k$ is created and linked as a child of `y`. The new node `z` is colored `RED` and its children are set to the `NIL` sentinel.\n- **Phase 2: Iterative Fix-up**: A `RED` child under a `RED` parent (a \"red-red\" violation) is the primary issue that can arise. An iterative fix-up procedure, `insert_fixup`, restores the RBT invariants. This procedure uses a `while` loop that continues as long as the current node, `z`, is not the root and its parent, `z.parent`, is `RED`. The logic inside the loop depends on the color of `z`'s uncle (the sibling of `z`'s parent).\n    - **Case 1: `z`'s uncle is `RED`**: This is the simplest case. We recolor `z`'s parent and uncle to `BLACK`, and `z`'s grandparent to `RED`. The problem is then moved up the tree by setting `z` to its grandparent (`z = z.parent.parent`) and continuing the loop.\n    - **Case 2: `z`'s uncle is `BLACK` (Triangle)**: This occurs when `z` and its parent are on opposite sides of their respective parents (e.g., `z` is a right child and its parent is a left child). A rotation on `z`'s parent transforms this into the \"line\" case (Case 3).\n    - **Case 3: `z`'s uncle is `BLACK` (Line)**: This occurs when `z` and its parent are on the same side (e.g., both are left children). We recolor the parent to `BLACK`, the grandparent to `RED`, and perform a rotation on the grandparent. This resolves the red-red violation, and the loop terminates.\nAfter the loop, the root of the tree is always set to `BLACK` to guarantee Invariant 1. This entire process, using only a few pointers (`z`, its parent, grandparent, and uncle), requires only $O(1)$ additional space.\n\n**4. Verification and Metrics**\nAfter constructing the tree for a given sequence, three metrics are computed.\n- **Invariant Verification**: A comprehensive recursive function, `_verify_and_get_bh_recursive`, is implemented. This function traverses the tree, simultaneously checking for violations of Invariant 3 (a red node cannot have a red child) and Invariant 4 (all paths have the same black-height). It returns the black-height of the subtree if it is valid, or an error signal (e.g., $-1$) if an invariant is violated. The main verification function, `verify_all_invariants`, also checks Invariant 1 (root is black) and uses the result of the recursive check to return a final `True` or `False`.\n- **Black-Height Calculation**: The problem defines black-height $\\mathrm{bh}^{\\star}$ such that $\\mathrm{bh}^{\\star}(\\text{sentinel}) = 1$. The recursive verification function is designed to compute exactly this value. Thus, `get_black_height` simply calls this function on the root.\n- **Tree Height Calculation**: A separate standard recursive function, `_height_recursive`, calculates the height of the tree, defined as the number of real nodes on the longest path from the root to a real leaf, correctly handling the base cases for empty trees and `NIL` nodes.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Color constants\nRED = 0\nBLACK = 1\n\nclass Node:\n    \"\"\"A node in the Red-Black Tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.parent = None\n        self.left = None\n        self.right = None\n        self.color = RED  # New nodes are initially red\n\nclass RedBlackTree:\n    \"\"\"An implementation of a Red-Black Tree.\"\"\"\n    def __init__(self):\n        self.NIL = Node(None)\n        self.NIL.color = BLACK\n        self.NIL.left = self.NIL\n        self.NIL.right = self.NIL\n        self.NIL.parent = self.NIL # Self-parent for convenience\n        self.root = self.NIL\n\n    def left_rotate(self, x):\n        \"\"\"Performs a left rotation on node x.\"\"\"\n        y = x.right\n        x.right = y.left\n        if y.left != self.NIL:\n            y.left.parent = x\n        y.parent = x.parent\n        if x.parent == self.NIL:\n            self.root = y\n        elif x == x.parent.left:\n            x.parent.left = y\n        else:\n            x.parent.right = y\n        y.left = x\n        x.parent = y\n\n    def right_rotate(self, y):\n        \"\"\"Performs a right rotation on node y.\"\"\"\n        x = y.left\n        y.left = x.right\n        if x.right != self.NIL:\n            x.right.parent = y\n        x.parent = y.parent\n        if y.parent == self.NIL:\n            self.root = x\n        elif y == y.parent.right:\n            y.parent.right = x\n        else:\n            y.parent.left = x\n        x.right = y\n        y.parent = x\n\n    def insert(self, key):\n        \"\"\"Inserts a new key into the tree iteratively.\"\"\"\n        y = self.NIL\n        x = self.root\n\n        while x != self.NIL:\n            y = x\n            if key  x.key:\n                x = x.left\n            elif key > x.key:\n                x = x.right\n            else:\n                # Duplicate key, do nothing\n                return\n\n        z = Node(key)\n        z.parent = y\n        if y == self.NIL:\n            self.root = z\n        elif z.key  y.key:\n            y.left = z\n        else:\n            y.right = z\n        \n        z.left = self.NIL\n        z.right = self.NIL\n        z.color = RED\n\n        self.insert_fixup(z)\n\n    def insert_fixup(self, z):\n        \"\"\"Restores the Red-Black properties after insertion.\"\"\"\n        while z.parent.color == RED:\n            if z.parent == z.parent.parent.left:\n                uncle = z.parent.parent.right\n                if uncle.color == RED: # Case 1: Uncle is RED\n                    z.parent.color = BLACK\n                    uncle.color = BLACK\n                    z.parent.parent.color = RED\n                    z = z.parent.parent\n                else:\n                    if z == z.parent.right: # Case 2: Triangle\n                        z = z.parent\n                        self.left_rotate(z)\n                    # Case 3: Line\n                    z.parent.color = BLACK\n                    z.parent.parent.color = RED\n                    self.right_rotate(z.parent.parent)\n            else: # Symmetric case\n                uncle = z.parent.parent.left\n                if uncle.color == RED: # Case 1\n                    z.parent.color = BLACK\n                    uncle.color = BLACK\n                    z.parent.parent.color = RED\n                    z = z.parent.parent\n                else:\n                    if z == z.parent.left: # Case 2\n                        z = z.parent\n                        self.right_rotate(z)\n                    # Case 3\n                    z.parent.color = BLACK\n                    z.parent.parent.color = RED\n                    self.left_rotate(z.parent.parent)\n        self.root.color = BLACK\n\n    def _verify_and_get_bh_recursive(self, node):\n        \"\"\"\n        Recursively verifies RBT properties 3 and 4, and computes black-height.\n        Returns black-height if subtree is valid, -1 otherwise.\n        \"\"\"\n        if node == self.NIL:\n            return 1  # bh*(sentinel) = 1\n\n        left_bh = self._verify_and_get_bh_recursive(node.left)\n        right_bh = self._verify_and_get_bh_recursive(node.right)\n\n        # Propagate error signal\n        if left_bh == -1 or right_bh == -1:\n            return -1\n\n        # Invariant 4: Black-heights of children must be equal\n        if left_bh != right_bh:\n            return -1\n\n        # Invariant 3: Red node's children must be black\n        if node.color == RED:\n            if node.left.color == RED or node.right.color == RED:\n                return -1\n\n        # Calculate black-height for this node's subtree\n        if node.color == BLACK:\n            return left_bh + 1\n        else: # Node is RED\n            return left_bh\n    \n    def verify_all_invariants(self):\n        \"\"\"Verifies all RBT invariants.\"\"\"\n        # Invariant 1: Root is BLACK. An empty tree's root is NIL, which is black.\n        if self.root != self.NIL and self.root.color != BLACK:\n            return False\n        \n        # Invariant 2 is true by design (self.NIL is always black).\n\n        # Check invariants 3 and 4\n        return self._verify_and_get_bh_recursive(self.root) != -1\n    \n    def get_black_height(self):\n        \"\"\"Returns the black-height of the tree, or -1 if invalid.\"\"\"\n        return self._verify_and_get_bh_recursive(self.root)\n    \n    def _height_recursive(self, node):\n        \"\"\"Computes height (number of real nodes on longest path).\"\"\"\n        if node == self.NIL:\n            return 0\n        return 1 + max(self._height_recursive(node.left), self._height_recursive(node.right))\n\n    def get_height(self):\n        \"\"\"Returns the height of the tree.\"\"\"\n        return self._height_recursive(self.root)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # Case A (general mixed order)\n        [10, 20, 30, 15, 25, 5, 1, 7, 12, 17],\n        # Case B (strictly increasing)\n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n        # Case C (strictly decreasing)\n        [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],\n        # Case D (single element)\n        [42],\n        # Case E (contains duplicates to be ignored)\n        [5, 3, 7, 3, 5, 7, 2, 8],\n        # Case F (recoloring chain behavior)\n        [11, 2, 14, 1, 7, 5, 8, 15, 13, 12]\n    ]\n\n    results = []\n    for keys in test_cases:\n        rbt = RedBlackTree()\n        for key in keys:\n            rbt.insert(key)\n        \n        is_valid = rbt.verify_all_invariants()\n        black_height = rbt.get_black_height()\n        height = rbt.get_height()\n        results.append([is_valid, black_height, height])\n    \n    # Format the final output string exactly as specified\n    result_strings = []\n    for r in results:\n        is_valid_str = str(r[0]).lower()\n        bh_str = str(r[1])\n        h_str = str(r[2])\n        result_strings.append(f\"[{is_valid_str},{bh_str},{h_str}]\")\n\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3266412"}]}