{"hands_on_practices": [{"introduction": "This first exercise bridges the gap between the abstract data structure of an expression tree and its concrete application in compilers and interpreters. You will transform a tree directly into a sequence of instructions for a simple stack-based virtual machine. This process reveals how the tree's inherent hierarchy, when traversed in post-order, naturally produces the Reverse Polish Notation (RPN) required for efficient stack-based evaluation [@problem_id:3232522].", "problem": "You are given rooted, ordered expression trees where each internal node is an operator and each leaf node is either a variable or a constant. The goal is to convert each expression tree into a flat sequence of integer-encoded instructions for a stack-based virtual machine that, when executed, evaluates the expression according to the semantics of arithmetic on real numbers. The semantics are defined from first principles using the structure of the tree and the behavior of a last-in-first-out stack.\n\nFundamental base definitions:\n- An expression tree is a finite rooted, ordered tree. Each leaf represents either a constant or a variable. Each unary operator node has exactly one child, and each binary operator node has exactly two children. Let the overall expression computed by a tree be denoted $E$, with evaluation defined recursively by the structure of the tree.\n- A stack-based virtual machine maintains a stack $S$ of values. Instructions act on $S$ deterministically.\n\nInstruction set and encoding:\n- Opcodes are integer codes with the following mapping:\n  - $0$: push constant, denoted $\\text{PUSH\\_CONST}$, which takes one immediate operand that is the constant value.\n  - $1$: push variable, denoted $\\text{PUSH\\_VAR}$, which takes one immediate operand that is the nonnegative integer index of the variable.\n  - $2$: addition, denoted $\\text{ADD}$, which pops the top two elements $r$ and $l$ from $S$ (where $r$ is the right operand and $l$ is the left operand), and pushes $l + r$.\n  - $3$: subtraction, denoted $\\text{SUB}$, which pops $r$ and $l$ and pushes $l - r$.\n  - $4$: multiplication, denoted $\\text{MUL}$, which pops $r$ and $l$ and pushes $l \\cdot r$.\n  - $5$: division, denoted $\\text{DIV}$, which pops $r$ and $l$ and pushes $l / r$.\n  - $6$: unary negation, denoted $\\text{NEG}$, which pops $a$ and pushes $-a$.\n  - $7$: exponentiation, denoted $\\text{POW}$, which pops $r$ and $l$ and pushes $l^r$.\n- The instruction stream is a flat list of integers. For $\\text{PUSH\\_CONST}$ and $\\text{PUSH\\_VAR}$, the opcode is immediately followed by the integer operand (the constant value or variable index, respectively). For all other opcodes, the instruction is just the single opcode integer.\n- Variables are identified by nonnegative integer indices. For example, variable $x$ may be bound to index $0$, variable $y$ to index $1$, and so on. Constants are integers; assume they fit within $64$-bit signed integer range.\n\nRequired compilation semantics:\n- The instruction sequence for an expression tree must be produced by a postorder traversal of the tree (children before parent), emitting instructions as follows:\n  - For a constant leaf with value $c$: emit $[0, c]$.\n  - For a variable leaf with index $i$: emit $[1, i]$.\n  - For a unary negation node with child $u$: emit the sequence for $u$, then emit $[6]$.\n  - For a binary operator node with left child $L$ and right child $R$ and operator $\\oplus \\in \\{+, -, \\cdot, /, ^\\}$: emit the sequence for $L$, then the sequence for $R$, then the opcode corresponding to $\\oplus$ (i.e., $[2]$ for $+$, $[3]$ for $-$, $[4]$ for $\\cdot$, $[5]$ for $/$, $[7]$ for $^$).\n\nScientific realism and generality:\n- The approach must be derived from the core definitions of expression trees and the deterministic stack semantics above, without relying on shortcuts beyond these definitions.\n- The compiled sequence must be correct for any expression composed from the supported operators under these semantics.\n\nTest suite:\n- Use the following five distinct expression trees and variable index bindings to test your compilation. For each case, produce the corresponding instruction stream as a list of integers, per the encoding above.\n  - Case $1$ (general binary composition): $(x + 3) \\cdot (y - 2)$ with $x$ mapped to index $0$ and $y$ mapped to index $1$.\n  - Case $2$ (unary and binary mix): $(-x) + 5$ with $x$ mapped to index $0$.\n  - Case $3$ (exponentiation and division): $\\dfrac{a^{3}}{b + 1}$ with $a$ mapped to index $2$ and $b$ mapped to index $3$.\n  - Case $4$ (single constant): $42$.\n  - Case $5$ (deep left-associative subtraction): (((x - 1) - 2) - 3) with $x$ mapped to index $0$.\n  - Case $6$ (double unary negation): $-(-(c))$ with $c$ mapped to index $5$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces anywhere. Each element should be the inner instruction list corresponding to one test case, in order from Case $1$ through Case $6$. For example, produce something like $[[i_{1,1},i_{1,2},\\dots],[i_{2,1},\\dots],\\dots]$ where each $i_{k,j}$ is an integer. Ensure the exact format has no spaces.", "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded in the principles of computer science, specifically concerning data structures (expression trees) and compilation theory (stack machines and instruction encoding). The problem is well-posed, with a clear, objective, and complete set of definitions and constraints that allow for the derivation of a unique and verifiable solution for each test case.\n\nThe core principle for converting an expression tree into a sequence of instructions for a stack-based virtual machine is the postorder traversal algorithm. A postorder traversal visits the left child, then the right child (for binary nodes), and finally the parent node. This sequence, `Left-Right-Parent`, naturally corresponds to Reverse Polish Notation (RPN), or postfix notation, where operands appear before their operator. A stack-based machine is designed to evaluate RPN expressions efficiently: it pushes operands onto the stack and, upon encountering an operator, pops the required number of operands, performs the operation, and pushes the result back onto the stack.\n\nThe problem requires us to formalize this process into a compilation algorithm. Let us denote the function that generates the instruction sequence for a given subtree rooted at node $N$ as $\\text{Compile}(N)$. The output of $\\text{Compile}(N)$ is a flat list of integers representing machine instructions. The behavior of this function is defined recursively based on the type of the node $N$.\n\nThe instruction set is defined with integer opcodes:\n- $\\text{PUSH\\_CONST} = 0$: takes one operand (the constant value).\n- $\\text{PUSH\\_VAR} = 1$: takes one operand (the variable's index).\n- $\\text{ADD} = 2$, $\\text{SUB} = 3$, $\\text{MUL} = 4$, $\\text{DIV} = 5$: binary operators.\n- $\\text{NEG} = 6$: unary operator.\n- $\\text{POW} = 7$: binary operator.\n\nThe compilation algorithm is defined by the following rules:\n\n1.  **Base Case: Leaf Nodes**\n    - If the node $N$ is a constant leaf with value $c$, the machine must push this constant onto the stack. The instruction sequence is $[\\text{PUSH\\_CONST}, c]$. Therefore, $\\text{Compile}(N) = [0, c]$.\n    - If the node $N$ is a variable leaf with index $i$, the machine must push the value of this variable onto the stack. The instruction sequence is $[\\text{PUSH\\_VAR}, i]$. Therefore, $\\text{Compile}(N) = [1, i]$.\n\n2.  **Recursive Case: Unary Operator Node**\n    - If the node $N$ is a unary operator (e.g., negation, $\\text{NEG}$) with a single child $U$, a postorder traversal dictates that we first process the child subtree. The evaluation requires that the operand (the result of evaluating $U$) is on the stack before the operator is applied. Thus, we first generate the instructions for the child, then append the operator's opcode.\n    - $\\text{Compile}(N) = \\text{Compile}(U) \\oplus [\\text{OP}_{\\text{unary}}]$, where $\\oplus$ denotes list concatenation and $\\text{OP}_{\\text{unary}}$ is the opcode for the unary operator (e.g., $6$ for $\\text{NEG}$).\n\n3.  **Recursive Case: Binary Operator Node**\n    - If the node $N$ is a binary operator (e.g., addition, $+$) with a left child $L$ and a right child $R$, a postorder traversal visits $L$, then $R$, then $N$. For evaluation, the machine needs the left operand on the stack, followed by the right operand. Thus, we generate instructions for $L$, then for $R$, and finally append the operator's opcode.\n    - $\\text{Compile}(N) = \\text{Compile}(L) \\oplus \\text{Compile}(R) \\oplus [\\text{OP}_{\\text{binary}}]$, where $\\text{OP}_{\\text{binary}}$ is the opcode for the binary operator (e.g., $2$ for $\\text{ADD}$).\n\nLet us demonstrate this algorithm with Test Case $1$: the expression $(x + 3) \\cdot (y - 2)$, where variable $x$ has index $0$ and $y$ has index $1$.\n\nThe expression tree has a multiplication node ($\\cdot$) at its root.\n- The left child, $L$, is an addition node ($+$) for the subexpression $(x + 3)$.\n- The right child, $R$, is a subtraction node ($-$) for the subexpression $(y - 2)$.\n\nThe compilation proceeds as follows:\n$\\text{Compile}(\\cdot) = \\text{Compile}(+) \\oplus \\text{Compile}(-) \\oplus [4]$\n\n- To compute $\\text{Compile}(+)$ for $(x + 3)$:\n  - The left child is the variable $x$ (index $0$). $\\text{Compile}(x) = [1, 0]$.\n  - The right child is the constant $3$. $\\text{Compile}(3) = [0, 3]$.\n  - The opcode for $+$ is $2$.\n  - $\\text{Compile}(+) = \\text{Compile}(x) \\oplus \\text{Compile}(3) \\oplus [2] = [1, 0] \\oplus [0, 3] \\oplus [2] = [1, 0, 0, 3, 2]$.\n\n- To compute $\\text{Compile}(-)$ for $(y - 2)$:\n  - The left child is the variable $y$ (index $1$). $\\text{Compile}(y) = [1, 1]$.\n  - The right child is the constant $2$. $\\text{Compile}(2) = [0, 2]$.\n  - The opcode for $-$ is $3$.\n  - $\\text{Compile}(-) = \\text{Compile}(y) \\oplus \\text{Compile}(2) \\oplus [3] = [1, 1] \\oplus [0, 2] \\oplus [3] = [1, 1, 0, 2, 3]$.\n\n- Finally, we assemble the full sequence:\n  - $\\text{Compile}(\\cdot) = [1, 0, 0, 3, 2] \\oplus [1, 1, 0, 2, 3] \\oplus [4]$\n  - The resulting instruction stream is $[1, 0, 0, 3, 2, 1, 1, 0, 2, 3, 4]$.\n\nWhen executed, this sequence performs the following stack operations:\n1. PUSH\n2. PUSH\n3. ADD (stack now contains $x+3$)\n4. PUSH\n5. PUSH\n6. SUB (stack now contains $x+3$, $y-2$)\n7. MUL (stack now contains $(x+3) \\cdot (y-2)$)\n\nThis procedure is systematically applied to all provided test cases to generate their corresponding instruction streams. The logic is deterministic and directly derived from the fundamental definitions of expression trees and stack-based computation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of compiling expression trees into a flat sequence\n    of integer-encoded instructions for a stack-based virtual machine.\n    \"\"\"\n\n    # Opcodes as defined in the problem statement.\n    OP_PUSH_CONST = 0\n    OP_PUSH_VAR = 1\n    OP_ADD = 2\n    OP_SUB = 3\n    OP_MUL = 4\n    OP_DIV = 5\n    OP_NEG = 6\n    OP_POW = 7\n\n    # Mapping from operator symbols to opcodes for convenience.\n    OPCODE_MAP = {\n        '+': OP_ADD,\n        '-': OP_SUB,\n        '*': OP_MUL,\n        '/': OP_DIV,\n        'NEG': OP_NEG,\n        '^': OP_POW,\n    }\n\n    def compile_tree(node):\n        \"\"\"\n        Recursively compiles an expression tree node into an instruction list\n        based on a postorder traversal.\n        The tree structure is represented using nested dictionaries.\n        \"\"\"\n        # Case 1: Binary operator node\n        if 'op' in node and 'L' in node and 'R' in node:\n            left_instr = compile_tree(node['L'])\n            right_instr = compile_tree(node['R'])\n            op_code = OPCODE_MAP[node['op']]\n            return left_instr + right_instr + [op_code]\n        \n        # Case 2: Unary operator node\n        elif 'op' in node and 'arg' in node:\n            arg_instr = compile_tree(node['arg'])\n            op_code = OPCODE_MAP[node['op']]\n            return arg_instr + [op_code]\n            \n        # Case 3: Variable leaf node\n        elif 'var' in node:\n            return [OP_PUSH_VAR, node['var']]\n            \n        # Case 4: Constant leaf node\n        elif 'const' in node:\n            return [OP_PUSH_CONST, node['const']]\n            \n        else:\n            # This should not be reached with well-formed trees.\n            raise ValueError(\"Invalid node format in expression tree\")\n\n    # Define the six test cases using the nested dictionary representation.\n    test_cases = [\n        # Case 1: (x + 3) * (y - 2) with x=0, y=1\n        {'op': '*', 'L': {'op': '+', 'L': {'var': 0}, 'R': {'const': 3}}, 'R': {'op': '-', 'L': {'var': 1}, 'R': {'const': 2}}},\n        \n        # Case 2: (-x) + 5 with x=0\n        {'op': '+', 'L': {'op': 'NEG', 'arg': {'var': 0}}, 'R': {'const': 5}},\n        \n        # Case 3: a^3 / (b + 1) with a=2, b=3\n        {'op': '/', 'L': {'op': '^', 'L': {'var': 2}, 'R': {'const': 3}}, 'R': {'op': '+', 'L': {'var': 3}, 'R': {'const': 1}}},\n        \n        # Case 4: 42\n        {'const': 42},\n        \n        # Case 5: (((x - 1) - 2) - 3) with x=0\n        {'op': '-', 'L': {'op': '-', 'L': {'op': '-', 'L': {'var': 0}, 'R': {'const': 1}}, 'R': {'const': 2}}, 'R': {'const': 3}},\n        \n        # Case 6: -(-(c)) with c=5\n        {'op': 'NEG', 'arg': {'op': 'NEG', 'arg': {'var': 5}}},\n    ]\n\n    results = []\n    for tree in test_cases:\n        instruction_list = compile_tree(tree)\n        results.append(instruction_list)\n\n    # Format the output exactly as specified: [[i_1,1,...],[i_2,1,...],...] with no spaces.\n    # 1. Convert each inner list of integers to a string like '[1,2,3]'.\n    # 2. Join these strings with commas.\n    # 3. Enclose the final result in brackets.\n    result_strings = []\n    for res_list in results:\n        # Create string representation of inner list without spaces\n        inner_str = '[' + ','.join(map(str, res_list)) + ']'\n        result_strings.append(inner_str)\n    \n    final_output = '[' + ','.join(result_strings) + ']'\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3232522"}, {"introduction": "While machines efficiently process postfix notation, humans typically read expressions in infix form. This practice challenges you to perform the reverse of parsing: converting a tree back into a human-readable infix string. The core task is to add the minimum number of parentheses necessary to preserve the original order of operations, forcing you to engage deeply with the rules of operator precedence and associativity that an expression tree implicitly encodes [@problem_id:3232525].", "problem": "Implement a program that, given a set of expression trees, produces an infix string for each tree with the minimum number of parentheses required so that, under conventional parsing rules for operator precedence and associativity, the original tree is reconstructed uniquely and exactly. The output to be printed must be the count of parenthesis pairs used for each tree, aggregated in a single line as a comma-separated list enclosed in square brackets.\n\nAn expression tree is a rooted, ordered tree in which each internal node is an operator and each leaf node is either a variable or a constant. The canonical operators and their conventional parsing rules for this problem are defined as follows:\n- Binary operators: $+$, $-$, $\\times$, $\\div$, and $^$.\n- Unary prefix operator: $-$ (unary negation).\n- Precedence (from highest to lowest): $^$ has precedence level $4$, unary $-$ has precedence level $3$, $\\times$ and $\\div$ have precedence level $2$, and $+$ and $-$ have precedence level $1$.\n- Associativity: $^$ is right-associative, $+$, $-$, $\\times$, and $\\div$ are left-associative. Unary $-$ applies to its single operand before any binary operator of lower precedence in the usual manner.\n\nThe fundamental base of this task is the definition of an expression tree together with the well-tested parsing facts about operator precedence and associativity: when parsing infix notation, operators of higher precedence bind tighter than operators of lower precedence, and when precedence is equal, associativity dictates grouping ($^$ groups to the right; $+$, $-$, $\\times$, and $\\div$ group to the left). Parentheses override these default grouping rules locally. Your goal is to derive, from these foundational definitions, an algorithm that decides exactly when parentheses are necessary around subexpressions to ensure that the printed infix string parses back to the original tree.\n\nYour program must internally construct and pretty-print the following test suite of expression trees. Each tree is specified in a structural form using node constructors with variables and constants shown in LaTeX for readability, but your program should represent them in a standard tree structure. For clarity, let $\\operatorname{Bin}(op, L, R)$ denote a binary node with operator $op$ and left and right children $L$ and $R$, and let $\\operatorname{Un}(op, C)$ denote a unary node with operator $op$ and child $C$. Let $\\operatorname{Var}(name)$ and $\\operatorname{Const}(value)$ denote leaf nodes.\n\nTest Suite (covering happy path, associativity and precedence boundaries, unary operator interactions, and nested edge cases):\n1. $\\operatorname{Var}(x)$\n2. $\\operatorname{Bin}(+, \\operatorname{Var}(a), \\operatorname{Bin}(+, \\operatorname{Var}(b), \\operatorname{Var}(c)))$\n3. $\\operatorname{Bin}(-, \\operatorname{Var}(a), \\operatorname{Bin}(-, \\operatorname{Var}(b), \\operatorname{Var}(c)))$\n4. $\\operatorname{Bin}(\\div, \\operatorname{Var}(a), \\operatorname{Bin}(+, \\operatorname{Var}(b), \\operatorname{Var}(c)))$\n5. $\\operatorname{Bin}(^, \\operatorname{Bin}(^, \\operatorname{Var}(a), \\operatorname{Var}(b)), \\operatorname{Var}(c))$\n6. $\\operatorname{Bin}(^, \\operatorname{Var}(a), \\operatorname{Bin}(^, \\operatorname{Var}(b), \\operatorname{Var}(c)))$\n7. $\\operatorname{Un}(-, \\operatorname{Bin}(\\times, \\operatorname{Bin}(+, \\operatorname{Var}(a), \\operatorname{Var}(b)), \\operatorname{Var}(c)))$\n8. $\\operatorname{Bin}(^, \\operatorname{Un}(-, \\operatorname{Var}(a)), \\operatorname{Un}(-, \\operatorname{Var}(b)))$\n9. $\\operatorname{Bin}(+, \\operatorname{Var}(a), \\operatorname{Bin}(\\times, \\operatorname{Var}(b), \\operatorname{Var}(c)))$\n10. $\\operatorname{Un}(-, \\operatorname{Bin}(^, \\operatorname{Var}(a), \\operatorname{Var}(b)))$\n\nYour program must implement a pretty printer that decides, for each node, whether to wrap its child expressions in parentheses according to the precedence and associativity rules, such that re-parsing the printed string using those same rules reconstructs the original expression tree exactly. After generating the pretty-printed string for each test case, your program should compute the integer count of parenthesis pairs used in that string (every occurrence of the character \"(\" must match a corresponding \")\" and counts as one pair). This count is the result for the corresponding test case.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\texttt{[r_1,r_2,\\dots,r_{10}]}$, where each $r_i$ is the integer count of parenthesis pairs for test case $i$.\n\nThere are no physical units involved. Angles do not appear. Percentages do not appear. The answers are integers.\n\nEnsure scientific realism by adhering to the fundamental definitions and facts stated above. The algorithm must not rely on any shortcuts that presuppose the final decision rules; rather, derive the decision of when to add parentheses from the precedence and associativity properties of the operators.", "solution": "The problem is to determine the minimum number of parenthesis pairs required to represent a given expression tree as an infix string, such that parsing the string according to standard operator precedence and associativity rules reconstructs the original tree.\n\n### Step 1: Problem Formalization and Principle of Minimality\n\nAn expression tree's structure explicitly defines the order of operations. An infix string, however, relies on parsing rules to determine this order. Parentheses serve one purpose: to override the default parsing rules where they conflict with the tree's structure. The principle of minimality dictates that we should only insert parentheses when their absence would lead to a different parse tree.\n\nThe decision to parenthesize a subexpression depends on the interplay between the operator at the root of the subexpression (the \"child\" operator) and the operator of its parent node in the tree (the \"parent\" operator).\n\nLet's define the operator properties as given:\n- **Precedence**: A mapping from an operator to an integer, where a higher value indicates higher precedence.\n  - $P(^) = 4$\n  - $P(\\text{unary}-) = 3$\n  - $P(\\times), P(\\div) = 2$\n  - $P(+), P(-) = 1$\n- **Associativity**: A rule for grouping operators of equal precedence.\n  - Right-associative (`R`): $^$ (e.g., $a ^ b ^ c \\equiv a ^ (b ^ c)$)\n  - Left-associative (`L`): $+, -, \\times, \\div$ (e.g., $a - b - c \\equiv (a - b) - c$)\n\n### Step 2: Derivation of Parenthesization Rules\n\nWe can derive the conditions requiring parentheses by analyzing cases where the default parsing would alter the tree structure. We consider a node $N$ in the tree, which corresponds to a subexpression. Let $op_N$ be the operator at node $N$, and let $P$ be its parent node with operator $op_P$.\n\n#### Rule 1: Precedence Conflict\nIf the operator $op_N$ has a lower precedence than its parent operator $op_P$, the operation at $N$ must be enclosed in parentheses. Without them, the high-precedence parent operator $op_P$ would bind to one of $N$'s immediate operands, restructuring the tree.\n- **Condition**: Add parentheses if $P(op_N) < P(op_P)$.\n- **Example**: For the tree $\\operatorname{Bin}(\\div, \\operatorname{Var}(a), \\operatorname{Bin}(+, \\operatorname{Var}(b), \\operatorname{Var}(c)))$, representing $a / (b+c)$, the parent operator is $\\div$ ($P=2$) and the child operator is $+$ ($P=1$). Since $P(+) < P(\\div)$, the subexpression $(b+c)$ requires parentheses. Omitting them, $a / b + c$, would parse as $(a/b)+c$.\n\n#### Rule 2: Associativity Conflict\nIf $op_N$ and $op_P$ have the same precedence, associativity rules determine the default grouping. Parentheses are needed if the tree's structure contradicts this default grouping.\n\n- **Case 2a: Left-Associative Operators** ($+, -, \\times, \\div$)\n  - These operators group from left to right. The structure $(L \\, op \\, M) \\, op \\, R$ is the default.\n  - If a node $N$ with operator $op_N$ is the *right* child of a node $P$ with a left-associative operator $op_P$ of the same precedence, parentheses are required.\n  - **Condition**: Add parentheses if $P(op_N) = P(op_P)$, $op_P$ is left-associative, and $N$ is the right child.\n  - **Example**: For $\\operatorname{Bin}(-, \\operatorname{Var}(a), \\operatorname{Bin}(-, \\operatorname{Var}(b), \\operatorname{Var}(c)))$, representing $a - (b-c)$, both operators are $-$, which is left-associative. The subexpression $(b-c)$ is the right child. Omitting parentheses yields $a-b-c$, which parses as $(a-b)-c$, a different tree.\n\n- **Case 2b: Right-Associative Operators** ($^$)\n  - This operator groups from right to left. The structure $L \\, op \\, (M \\, op \\, R)$ is the default.\n  - If a node $N$ with operator $op_N$ is the *left* child of a node $P$ with a right-associative operator $op_P$ of the same precedence, parentheses are required.\n  - **Condition**: Add parentheses if $P(op_N) = P(op_P)$, $op_P$ is right-associative, and $N$ is the left child.\n  - **Example**: For $\\operatorname{Bin}(^, \\operatorname{Bin}(^, \\operatorname{Var}(a), \\operatorname{Var}(b)), \\operatorname{Var}(c))$, representing $(a^b)^c$, both operators are $^$, which is right-associative. The subexpression $(a^b)$ is the left child. Omitting parentheses yields $a^b^c$, which parses as $a^(b^c)$.\n\n#### Rule 3: Special Cases for Unary Minus ($-$)\n\nThe unary minus operator introduces unique scenarios.\n\n- **Case 3a: Unary subexpression as a child of a binary operator.**\n  - If $\\operatorname{Un}(-, C)$ is the *left* child of a binary operator $op_P$ and $P(\\text{unary}-) < P(op_P)$, parentheses are needed.\n  - **Example**: $\\operatorname{Bin}(^, \\operatorname{Un}(-, \\operatorname{Var}(a)), \\operatorname{Var}(b))$ represents $(-a)^b$. Here, $P(\\text{unary}-) = 3$ and $P(^) = 4$. Without parentheses, the string `-a^b` would be parsed as `-(a^b)` because $^$ has higher precedence. Thus, parentheses are mandatory: `(-a)^b`.\n\n  - If $\\operatorname{Un}(-, C)$ is the *right* child of a binary operator $op_P$, parentheses are generally not needed, as in $a \\times -b$, which is unambiguously $a \\times (-b)$.\n  - **Exception**: If the parent operator $op_P$ is itself a binary minus, parentheses are required to avoid ambiguity.\n  - **Example**: For an expression tree representing $a - (-b)$, the string $a - -b$ is syntactically invalid or ambiguous in many contexts. Parentheses are necessary: $a - (-b)$.\n\n- **Case 3b: Binary subexpression as a child of a unary minus.**\n  - If a node $N$ with operator $op_N$ is the child of $\\operatorname{Un}(-, ...)$, the rule is simpler: If $P(op_N) < P(\\text{unary}-)$, parentheses are needed.\n  - **Example**: $\\operatorname{Un}(-, \\operatorname{Bin}(+, \\operatorname{Var}(a), \\operatorname{Var}(b)))$ represents `-(a+b)`. Since $P(+) < P(\\text{unary}-)$, parentheses are needed. `-a+b` would parse as `(-a)+b`.\n\n### Step 3: Algorithmic Implementation\n\nThese derived rules can be implemented in a recursive function that traverses the expression tree. The function, `get_paren_count(node, parent_op, is_right_child)`, calculates the number of parenthesis pairs for the subtree rooted at `node`.\n\n1.  **Base Case**: If `node` is a leaf (`Var` or `Const`), it requires $0$ parentheses.\n2.  **Recursive Step**:\n    a. Recursively call `get_paren_count` for all children of `node`, passing `node`'s operator as the new `parent_op`. Sum the counts returned by these calls.\n    b. Apply the derived rules to determine if the subexpression for `node` itself needs to be parenthesized, based on `node.op`, `parent_op`, and its position (`is_right_child`).\n    c. If parentheses are needed, add $1$ to the total count.\n    d. Return the total count.\n\nThis algorithm systematically applies the fundamental principles of operator parsing to count the minimum required parentheses, ensuring the generated infix string is both correct and concise.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# --- Data Structures for Expression Trees ---\n\nclass Node:\n    \"\"\"Base class for a node in an expression tree.\"\"\"\n    def __init__(self, op):\n        self.op = op\n\nclass Var(Node):\n    \"\"\"Represents a variable or constant (a leaf node).\"\"\"\n    def __init__(self, name):\n        super().__init__(name)\n    def __repr__(self):\n        return f\"Var({self.op})\"\n\nclass UnaryOp(Node):\n    \"\"\"Represents a unary operation.\"\"\"\n    def __init__(self, op, child):\n        super().__init__(op)\n        self.child = child\n    def __repr__(self):\n        return f\"UnaryOp({self.op}, {self.child})\"\n\nclass BinaryOp(Node):\n    \"\"\"Represents a binary operation.\"\"\"\n    def __init__(self, op, left, right):\n        super().__init__(op)\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return f\"BinaryOp({self.op}, {self.left}, {self.right})\"\n\n# --- Problem Definition: Operators and Rules ---\n\nOP_INFO = {\n    # Operator: (precedence, associativity)\n    '^': (4, 'R'),\n    'u-': (3, 'R'), # Unary minus\n    '*': (2, 'L'),\n    '/': (2, 'L'),\n    'x': (2, 'L'), # For representation of the multiplication symbol\n    '÷': (2, 'L'), # For representation of the division symbol\n    '+': (1, 'L'),\n    '-': (1, 'L'), # Binary minus\n}\n\ndef solve():\n    \"\"\"\n    Main function to construct test cases and compute parenthesis counts.\n    \"\"\"\n    # --- Test Suite Construction ---\n    \n    # Aliases for brevity in test case definitions\n    Bin = BinaryOp\n    Un = UnaryOp\n    V = Var\n    \n    # Test cases defined as per the problem statement's structural form.\n    # LaTeX representations: +, -, ×, ÷, ^\n    test_cases = [\n        # 1. Var(x)\n        V('x'),\n        # 2. Bin(+, Var(a), Bin(+, Var(b), Var(c)))\n        Bin('+', V('a'), Bin('+', V('b'), V('c'))),\n        # 3. Bin(-, Var(a), Bin(-, Var(b), Var(c)))\n        Bin('-', V('a'), Bin('-', V('b'), V('c'))),\n        # 4. Bin(÷, Var(a), Bin(+, Var(b), Var(c)))\n        Bin('÷', V('a'), Bin('+', V('b'), V('c'))),\n        # 5. Bin(^, Bin(^, Var(a), Var(b)), Var(c))\n        Bin('^', Bin('^', V('a'), V('b')), V('c')),\n        # 6. Bin(^, Var(a), Bin(^, Var(b), Var(c)))\n        Bin('^', V('a'), Bin('^', V('b'), V('c'))),\n        # 7. Un(-, Bin(×, Bin(+, Var(a), Var(b)), Var(c)))\n        Un('u-', Bin('x', Bin('+', V('a'), V('b')), V('c'))),\n        # 8. Bin(^, Un(-, Var(a)), Un(-, Var(b)))\n        Bin('^', Un('u-', V('a')), Un('u-', V('b'))),\n        # 9. Bin(+, Var(a), Bin(×, Var(b), Var(c)))\n        Bin('+', V('a'), Bin('x', V('b'), V('c'))),\n        # 10. Un(-, Bin(^, Var(a), Var(b)))\n        Un('u-', Bin('^', V('a'), V('b'))),\n    ]\n\n    results = []\n    for tree in test_cases:\n        count = get_paren_count(tree, parent_op=None, is_right_child=False)\n        results.append(count)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef needs_parens(node, parent_op, is_right_child):\n    \"\"\"\n    Determines if a subexpression rooted at `node` needs parentheses.\n    This function implements the derived rules for parenthesization.\n    \"\"\"\n    if parent_op is None:\n        return False\n\n    node_op = node.op\n    p_node, assoc_node = OP_INFO[node_op]\n    p_parent, assoc_parent = OP_INFO[parent_op]\n\n    # Rule 1: Precedence conflict\n    if p_node  p_parent:\n        return True\n\n    # Rule 2: Associativity conflict for binary operators\n    if isinstance(node, BinaryOp) and p_node == p_parent:\n        if assoc_parent == 'L' and is_right_child:\n            return True\n        if assoc_parent == 'R' and not is_right_child:\n            return True\n\n    # Rule 3: Special cases for UnaryOp children\n    if isinstance(node, UnaryOp):\n        # Case `(-a)^b`: precedence of u- is less than ^\n        if not is_right_child and p_node  p_parent:\n            return True\n        # Case `a - (-b)`\n        if is_right_child and parent_op == '-':\n            return True\n            \n    return False\n\ndef get_paren_count(node, parent_op, is_right_child):\n    \"\"\"\n    Recursively traverses the tree to count the minimum required parenthesis pairs.\n    \"\"\"\n    if isinstance(node, Var):\n        return 0\n\n    count = 0\n    if isinstance(node, UnaryOp):\n        # Recurse on the single child\n        # The child's position is irrelevant for a unary parent\n        count += get_paren_count(node.child, node.op, False)\n    elif isinstance(node, BinaryOp):\n        # Recurse on left and right children\n        count += get_paren_count(node.left, node.op, False)\n        count += get_paren_count(node.right, node.op, True)\n\n    # Check if the current node's subexpression needs parentheses\n    if needs_parens(node, parent_op, is_right_child):\n        count += 1\n        \n    return count\n\n# Execute the solution\nsolve()\n\n```", "id": "3232525"}, {"introduction": "Moving beyond analyzing and representing given trees, this final practice delves into the combinatorial challenge of *finding* a tree that meets a specific goal. Inspired by the classic \"24 Game,\" you will search for an expression tree that combines a given set of numbers to produce a target value. This advanced exercise requires you to systematically explore all valid partitions and tree structures, providing a hands-on application of recursion, dynamic programming, and memoization to navigate a complex search space [@problem_id:3232629].", "problem": "You are given a finite multiset of integers and an integer target. Treat each integer as a leaf in a binary expression tree. Internal nodes are binary operators drawn from the set $\\{+,-,\\*,/\\}$. You must use each given integer exactly once as a leaf and you may not introduce any new constants. Parentheses are implicit in the tree structure. Division is exact rational division and division by zero is not allowed. There are no unary operators. The value of an expression tree is obtained by evaluating the binary operators at the internal nodes in the usual algebraic way on the values of their child subtrees.\n\nUsing only the core definitions of a binary expression tree, exact arithmetic on rational numbers, and the fact that any binary tree with more than one leaf can be decomposed into two proper subtrees at its root, derive from first principles an algorithm that, given a multiset of leaves, enumerates all values achievable by some expression tree using all leaves exactly once, together with the minimal possible height for each such value. The height of a tree is defined as the number of edges on the longest path from the root to a leaf; a single-leaf tree has height $0$. For any internal node with left subtree height $h_\\ell$ and right subtree height $h_r$, the height at that node is $1+\\max(h_\\ell,h_r)$.\n\nYour program must compute, for each test case below, the minimal possible height $h^\\star$ among all valid expression trees that evaluate exactly to the given target (with exact equality over rational numbers). If no such tree exists, output $-1$ for that case. All arithmetic must be carried out exactly over the rational numbers, and equality must be exact over the rationals. Any intermediate division by zero is invalid and must be discarded.\n\nTest suite:\n- Case $1$: multiset $[8, 8, 3, 3]$, target $24$.\n- Case $2$: multiset $[24]$, target $24$.\n- Case $3$: multiset $[1, 1, 1, 1]$, target $24$.\n- Case $4$: multiset $[4, 4, 4, 4]$, target $24$.\n- Case $5$: multiset $[-1, 2, 3, 4]$, target $-24$.\n\nFinal output format:\n- Your program should produce a single line of output containing the five results as a comma-separated list enclosed in square brackets, in the order of the cases above, for example: $[h_1, h_2, h_3, h_4, h_5]$. Each $h_i$ is an integer, equal to the minimal height if achievable or $-1$ if not.\n\nDesign for coverage:\n- The suite includes a typical solvable case, a single-leaf boundary case, an unsolvable case, a solvable case with repeated numbers, and a case involving a negative number. Your algorithm must systematically consider all binary tree shapes and operator placements consistent with the given leaves and must enforce exact rational arithmetic and the height definition stated above.", "solution": "The problem requires the derivation of an algorithm from first principles to find the minimal height of a binary expression tree that evaluates to a specific target value. The tree must be constructed from a given multiset of integers, using each integer exactly once as a leaf, and a set of binary operators $\\{+,-,*,/\\}$.\n\nLet $S$ be the given multiset of integers. Let $V(T)$ be the value of an expression tree $T$ and $H(T)$ be its height. We are asked to find $h^\\star = \\min \\{ H(T) \\mid V(T) = \\text{target} \\land \\text{leaves}(T) = S \\}$. If no such tree exists, $h^\\star = -1$.\n\nThe derivation proceeds from the fundamental recursive structure of binary trees, as suggested by the problem statement: \"any binary tree with more than one leaf can be decomposed into two proper subtrees at its root\".\n\nLet us define a function, $\\text{Compute}(S)$, which returns a map of all possible values achievable using the numbers in a multiset $S$. This map will associate each achievable value $v$ with the minimum possible height $h$ of a tree that produces it. Let this map be denoted $M_S$, where $M_S[v] = h$.\n\n**Base Case**\nIf the multiset $S$ contains a single element, $S=\\{x\\}$, the only possible tree is a single leaf node.\n- The value of this tree is $x$.\n- The height of this tree is defined as $0$.\nTherefore, for a singleton multiset $\\{x\\}$, the result is $\\text{Compute}(\\{x\\}) = \\{x \\mapsto 0\\}$.\n\n**Recursive Step**\nIf $S$ contains more than one element ($|S|  1$), any expression tree $T$ with leaves from $S$ must have a root node corresponding to a binary operator $\\circ \\in \\{+, -, *, /\\}$. This root has a left child and a right child, which are roots of two non-empty subtrees, $T_L$ and $T_R$.\n\nThe set of leaves of $T$ is the multiset union of the leaves of $T_L$ and $T_R$. This means that the multiset $S$ must be partitioned into two non-empty, disjoint sub-multisets, $S_L$ and $S_R$, such that $S_L \\cup S_R = S$. The leaves of $T_L$ are from $S_L$, and the leaves of $T_R$ are from $S_R$.\n\nThe value of the tree $T$ is $V(T) = V(T_L) \\circ V(T_R)$.\nThe height of the tree $T$ is $H(T) = 1 + \\max(H(T_L), H(T_R))$.\n\nThis decomposition is the foundation of our algorithm. To find all achievable values and their minimum heights for a multiset $S$, we can:\n1.  Generate all possible partitions of $S$ into two non-empty sub-multisets, $S_L$ and $S_R$.\n2.  For each partition $(S_L, S_R)$, recursively call $\\text{Compute}(S_L)$ and $\\text{Compute}(S_R)$ to obtain the result maps $M_{S_L}$ and $M_{S_R}$.\n3.  For every pair of values $(v_L, h_L)$ from $M_{S_L}$ and $(v_R, h_R)$ from $M_{S_R}$, we can form a new, larger tree.\n    - The new height will be $h = 1 + \\max(h_L, h_R)$.\n    - For each operator $\\circ \\in \\{+,-,*,/\\}$, we compute a new value $v = v_L \\circ v_R$.\n    - We must handle division by zero, which is invalid. For example, $v_L / v_R$ is only computed if $v_R \\neq 0$.\n    - For non-commutative operators (subtraction and division), we must consider both $v_L \\circ v_R$ and $v_R \\circ v_L$.\n    - For each newly computed value $v$, we update its entry in our result map for $S$, $M_S$. If $v$ is not yet in $M_S$, we add it with height $h$. If it is already present, we update its height to $\\min(M_S[v], h)$.\n\nThis recursive process naturally lends itself to a dynamic programming or memoization approach. We can store the results of $\\text{Compute}(S')$ for each sub-multiset $S'$ of the original $S$ to avoid redundant computations. The key for the memoization table can be a canonical representation of the multiset, such as a sorted tuple of its elements.\n\n**Arithmetic over Rational Numbers**\nThe problem mandates exact rational arithmetic. This is crucial for the division operator and for exact equality checking against the target. We must use a data type that represents numbers as fractions, e.g., $a/b$ where $a, b$ are integers. Standard floating-point arithmetic is unsuitable due to precision errors.\n\n**Algorithm Outline**\n1.  Initialize a memoization dictionary, `memo`.\n2.  Define a recursive function `compute(s_tuple)`, where `s_tuple` is a sorted tuple representing a multiset.\n3.  Inside `compute(s_tuple)`:\n    a. If `s_tuple` is in `memo`, return the stored result.\n    b. If `len(s_tuple) == 1`, return a map `{Fraction(s_tuple[0]): 0}\\}$.\n    c. Initialize an empty map `current_results`.\n    d. Iterate through all unique partitions of `s_tuple` into two non-empty, sorted sub-tuples, `s_L` and `s_R`. This can be done by iterating through subset sizes $k$ from $1$ to $|S|/2$ and generating combinations of indices.\n    e. For each partition $(s_L, s_R)$:\n        i. Recursively obtain $M_{S_L} = \\text{compute}(s_L)$ and $M_{S_R} = \\text{compute}(s_R)$.\n        ii. For each $(v_L, h_L) \\in M_{S_L}$ and $(v_R, h_R) \\in M_{S_R}$:\n            - Calculate $h = 1 + \\max(h_L, h_R)$.\n            - Calculate new values for all operators: $v_L+v_R$, $v_L-v_R$, $v_R-v_L$, $v_L \\times v_R$. If denominators are non-zero, also $v_L/v_R$ and $v_R/v_L$.\n            - For each new value $v$, update `current_results`: if $v$ is not in the map or $h  \\text{current\\_results}[v]$, set $\\text{current\\_results}[v] = h$.\n    f. Store `current_results` in `memo` for `s_tuple` and return it.\n\n4.  To solve a specific test case (multiset `initial_S`, integer `target`), call `compute(tuple(sorted(initial_S)))`.\n5.  Check if `Fraction(target)` exists as a key in the returned map. If so, its value is the minimal height. If not, the target is unachievable, and the result is $-1$.\n\nThis algorithm systematically explores all valid expression trees that can be formed, guaranteeing correctness and finding the minimal height for any achievable value.\nFor example, for the multiset $[8, 8, 3, 3]$ and target $24$, the algorithm would explore partitions like $(\\{3,3,8\\}, \\{8\\})$ and eventually discover the expression $8 / (3 - 8/3)$, corresponding to the tree $(\\text{root}=/,\\, T_L=\\{8\\},\\, T_R=\\{3,3,8\\} \\text{ forming } 1/3)$ with height $1 + \\max(H(T_L), H(T_R)) = 1+\\max(0,2) = 3$. It will also evaluate balanced partitions like $(\\{3,8\\}, \\{3,8\\})$ to check for solutions with a smaller height of $2$, but will find none that yield $24$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom fractions import Fraction\nfrom collections.abc import Mapping\nfrom itertools import combinations\n\n# Global memoization table\n# Key: sorted tuple of numbers (representing a multiset)\n# Value: a dictionary mapping achievable Fraction values to their minimum height\nmemo: dict[tuple[int, ...], dict[Fraction, int]] = {}\n\ndef update_results(res_map: dict[Fraction, int], val: Fraction, height: int):\n    \"\"\"\n    Updates the results map with a new value and height.\n    If the value is new, it's added.\n    If the value exists, its height is updated only if the new height is smaller.\n    \"\"\"\n    if val not in res_map or height  res_map[val]:\n        res_map[val] = height\n\ndef compute_achievable_values(s_tuple: tuple[int, ...]) - dict[Fraction, int]:\n    \"\"\"\n    Recursively computes all achievable values from a multiset of numbers (s_tuple)\n    and returns a map from each value to its minimum achievable height.\n    Uses memoization to store results for subproblems.\n    \"\"\"\n    if s_tuple in memo:\n        return memo[s_tuple]\n\n    n = len(s_tuple)\n    if n == 1:\n        # Base case: a single number forms a leaf node with height 0.\n        result = {Fraction(s_tuple[0]): 0}\n        memo[s_tuple] = result\n        return result\n\n    current_results: dict[Fraction, int] = {}\n    \n    # Partition s_tuple into two non-empty sub-multisets, s_L and s_R.\n    # We iterate through the size of the left partition, k, up to n // 2.\n    # This, combined with canonical representation of partitions, avoids duplicates.\n    processed_partitions = set()\n    for k in range(1, n // 2 + 1):\n        # Generate partitions by choosing k indices for the left sub-multiset.\n        for left_indices in combinations(range(n), k):\n            left_list = [s_tuple[i] for i in left_indices]\n            \n            right_list = []\n            right_indices_set = set(range(n)) - set(left_indices)\n            for i in sorted(list(right_indices_set)):\n                 right_list.append(s_tuple[i])\n\n            # Use sorted tuples as canonical representations for sub-multisets\n            s_L = tuple(left_list)\n            s_R = tuple(right_list)\n\n            # Canonical representation of the partition pair to avoid duplicates\n            # like ((a,b), (c,d)) and ((c,d), (a,b)).\n            if s_L  s_R:\n                s_L, s_R = s_R, s_L\n            \n            if (s_L, s_R) in processed_partitions:\n                continue\n            processed_partitions.add((s_L, s_R))\n\n            # Recursive calls to solve for the sub-multisets\n            results_L = compute_achievable_values(s_L)\n            results_R = compute_achievable_values(s_R)\n\n            # Combine results from left and right subtrees\n            for val_L, h_L in results_L.items():\n                for val_R, h_R in results_R.items():\n                    height = 1 + max(h_L, h_R)\n                    \n                    # Addition\n                    update_results(current_results, val_L + val_R, height)\n                    \n                    # Subtraction (non-commutative)\n                    update_results(current_results, val_L - val_R, height)\n                    update_results(current_results, val_R - val_L, height)\n                    \n                    # Multiplication\n                    update_results(current_results, val_L * val_R, height)\n                    \n                    # Division (non-commutative and guards against zero division)\n                    if val_R != 0:\n                        update_results(current_results, val_L / val_R, height)\n                    if val_L != 0:\n                        update_results(current_results, val_R / val_L, height)\n\n    memo[s_tuple] = current_results\n    return current_results\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'multiset': [8, 8, 3, 3], 'target': 24},  # Case 1\n        {'multiset': [24], 'target': 24},          # Case 2\n        {'multiset': [1, 1, 1, 1], 'target': 24},  # Case 3\n        {'multiset': [4, 4, 4, 4], 'target': 24},  # Case 4\n        {'multiset': [-1, 2, 3, 4], 'target': -24} # Case 5\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        # Clear memoization table for each independent test case\n        global memo\n        memo.clear()\n        \n        multiset = case['multiset']\n        target = case['target']\n        \n        # The algorithm requires a sorted tuple for keys\n        s_tuple = tuple(sorted(multiset))\n        \n        all_values = compute_achievable_values(s_tuple)\n        \n        target_fraction = Fraction(target)\n        \n        if target_fraction in all_values:\n            results.append(all_values[target_fraction])\n        else:\n            results.append(-1)\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver\nsolve()\n\n```", "id": "3232629"}]}