{"hands_on_practices": [{"introduction": "On modern processors, integer division is significantly slower than multiplication. This performance gap has led to clever compiler optimizations where division by a constant $d$ is replaced by a faster sequence of multiplication by a precomputed \"magic number\" and a bit-shift. This exercise guides you through the process of deriving these magic numbers from first principles, providing a deep look into how low-level arithmetic can be optimized and mathematically proven correct [@problem_id:3229075].", "problem": "An unsigned integer division by a fixed positive integer divisor $d$ can be realized without hardware division by multiplying the dividend by a precomputed constant and right-shifting. Consider a Central Processing Unit (CPU) whose Arithmetic Logic Unit (ALU) supports $w=32$-bit unsigned integers and can compute the high $w$ bits of the $64$-bit product $n \\cdot M$; mathematically, this corresponds to the quantity $\\left\\lfloor \\frac{n \\cdot M}{2^{w}} \\right\\rfloor$, where $n \\in \\{0,1,\\dots,2^{w}-1\\}$ and $M$ is an integer constant. You will study bit-level tricks for quickly determining divisibility by small constants using multiplication by “magic numbers” and shifts, and derive such magic numbers.\n\nStarting from the foundational facts that fixed-point reciprocals can be approximated by ratios of integers and that the floor function is defined by the inequality $\\lfloor x \\rfloor \\le x < \\lfloor x \\rfloor + 1$, derive, from first principles, a choice of integer constant $M(d)$ depending on $d$ and $w$ such that the quantity\n$$\nq(n;d) \\;=\\; \\left\\lfloor \\frac{n \\cdot M(d)}{2^{w}} \\right\\rfloor\n$$\napproximates the true quotient $\\left\\lfloor \\frac{n}{d} \\right\\rfloor$ with a worst-case error bounded by $1$ for all $n \\in [0,2^{w})$. Explain why this bound holds. Then, using the derived $M(d)$, explain how to implement a divisibility test for $d$ using only multiplication by $M(d)$, one right-shift by $w$ bits, and at most one conditional correction step based on a comparison; do not rely on hardware division.\n\nFinally, for the specific divisors $d \\in \\{7,10,25\\}$ and word size $w=32$, compute the corresponding magic numbers $M(7)$, $M(10)$, and $M(25)$. Report the single quantity\n$$\nS \\;=\\; M(7) \\;+\\; M(10) \\;+\\; M(25)\n$$\nas your final answer. No rounding is required; $S$ is an exact integer.", "solution": "The problem asks for a method to approximate the unsigned integer quotient $q_{true} = \\left\\lfloor \\frac{n}{d} \\right\\rfloor$ using the operation $q(n;d) = \\left\\lfloor \\frac{n \\cdot M(d)}{2^{w}} \\right\\rfloor$ for a dividend $n \\in \\{0, 1, \\dots, 2^{w}-1\\}$ and a fixed positive integer divisor $d$. We must derive a suitable integer constant $M(d)$ and prove the error bound.\n\n**Derivation of the Magic Number $M(d)$ and Error Bound**\n\nOur goal is to find an integer $M(d)$ such that $\\frac{M(d)}{2^w}$ is a good approximation of $\\frac{1}{d}$. To ensure that our estimated quotient does not systematically underestimate the true quotient (which can be more difficult to correct), we will choose an approximation that is slightly larger than or equal to the true value. Let's enforce the condition $\\frac{M(d)}{2^w} \\ge \\frac{1}{d}$. The smallest integer $M(d)$ that satisfies this inequality for a fixed $w$ and $d$ is given by the ceiling of $\\frac{2^w}{d}$.\nLet us define our magic number as:\n$$\nM(d) = \\left\\lceil \\frac{2^w}{d} \\right\\rceil\n$$\nThis can be computed using integer arithmetic as $M(d) = (2^w + d - 1) / d$.\n\nNow, we must prove that the error for the quotient $q(n;d) = \\left\\lfloor \\frac{n \\cdot M(d)}{2^w} \\right\\rfloor$ is bounded by $1$.\nBy the definition of the ceiling function, we have:\n$$\n\\frac{2^w}{d} \\le M(d) < \\frac{2^w}{d} + 1\n$$\nMultiplying this inequality by $\\frac{n}{2^w}$ (where $n \\ge 0$) yields:\n$$\n\\frac{n}{d} \\le \\frac{n \\cdot M(d)}{2^w} < \\frac{n}{d} + \\frac{n}{2^w}\n$$\nSince $n$ is an unsigned $w$-bit integer, its maximum value is $2^w-1$. Thus, for all $n$ in the specified range, we have $n < 2^w$, which implies $\\frac{n}{2^w} < 1$.\nThe inequality can be rewritten as:\n$$\n\\frac{n}{d} \\le \\frac{n \\cdot M(d)}{2^w} < \\frac{n}{d} + 1\n$$\nLet $q_{true} = \\left\\lfloor \\frac{n}{d} \\right\\rfloor$ and $q(n;d) = \\left\\lfloor \\frac{n \\cdot M(d)}{2^w} \\right\\rfloor$.\nFrom the left-hand side of the inequality, $\\frac{n}{d} \\le \\frac{n \\cdot M(d)}{2^w}$, we can apply the floor function to both sides. Since the floor function is monotonically non-decreasing, we get:\n$$\n\\left\\lfloor \\frac{n}{d} \\right\\rfloor \\le \\left\\lfloor \\frac{n \\cdot M(d)}{2^w} \\right\\rfloor \\quad \\implies \\quad q_{true} \\le q(n;d)\n$$\nFrom the right-hand side, $\\frac{n \\cdot M(d)}{2^w} < \\frac{n}{d} + 1$, we have:\n$$\nq(n;d) = \\left\\lfloor \\frac{n \\cdot M(d)}{2^w} \\right\\rfloor \\le \\frac{n \\cdot M(d)}{2^w} < \\frac{n}{d} + 1\n$$\nSince $q_{true} = \\left\\lfloor \\frac{n}{d} \\right\\rfloor$ is an integer, the property $x < I+1 \\implies \\lfloor x \\rfloor \\le I$ for any integer $I$ applies. So, $q(n;d) < \\frac{n}{d} + 1$ implies $q(n;d) \\le \\left\\lfloor \\frac{n}{d} \\right\\rfloor + 1 = q_{true} + 1$.\nCombining both results, we have established the bound:\n$$\nq_{true} \\le q(n;d) \\le q_{true} + 1\n$$\nThis shows that the computed quotient $q(n;d)$ is either the true quotient or one greater than the true quotient. The absolute error $|q(n;d) - q_{true}|$ is therefore either $0$ or $1$, which is bounded by $1$ as required.\n\n**Divisibility Test Implementation**\n\nTo devise a divisibility test, we investigate the behavior of our approximation when $n$ is a multiple of $d$.\nLet $n=k \\cdot d$ for some integer $k$. From the problem constraints, $n < 2^w$, so $k < \\frac{2^w}{d}$.\nOur computed quotient is $q(n;d) = \\left\\lfloor \\frac{k \\cdot d \\cdot M(d)}{2^w} \\right\\rfloor$.\nFrom the definition of $M(d)$, we can write $d \\cdot M(d) = d \\cdot \\left\\lceil \\frac{2^w}{d} \\right\\rceil = 2^w + \\delta$, where $\\delta$ is an integer satisfying $0 \\le \\delta < d$.\nSubstituting this into the expression for $q(n;d)$:\n$$\nq(k \\cdot d; d) = \\left\\lfloor \\frac{k(2^w + \\delta)}{2^w} \\right\\rfloor = \\left\\lfloor k + \\frac{k\\delta}{2^w} \\right\\rfloor = k + \\left\\lfloor \\frac{k\\delta}{2^w} \\right\\rfloor\n$$\nWe must evaluate the floor term. We know $k < \\frac{2^w}{d}$ and $\\delta < d$. Therefore:\n$$\nk\\delta < \\frac{2^w}{d} \\cdot d = 2^w\n$$\nSince $k \\ge 0$ and $\\delta \\ge 0$, we have $0 \\le k\\delta < 2^w$, which implies $0 \\le \\frac{k\\delta}{2^w} < 1$.\nThe floor of this term is thus $0$: $\\left\\lfloor \\frac{k\\delta}{2^w} \\right\\rfloor = 0$.\nThis leads to a crucial result: if $n$ is a multiple of $d$, then $q(n;d) = k = \\frac{n}{d} = q_{true}$. The computed quotient is exact.\n\nIf $n$ is not a multiple of $d$, then by definition $n \\ne \\frac{n}{d} \\cdot d$, and since $q(n;d)$ is an integer, it must be that $n \\ne q(n;d) \\cdot d$.\n\nThis gives a simple and robust divisibility test:\n1.  Compute the magic number $M(d) = \\left\\lceil \\frac{2^w}{d} \\right\\rceil$.\n2.  For a given $n$, calculate the estimated quotient $q = \\left\\lfloor \\frac{n \\cdot M(d)}{2^w} \\right\\rfloor$. This is achieved with one multiplication (`n * M(d)`) and one right-shift by $w$ bits.\n3.  Calculate the product $P = q \\cdot d$.\n4.  The integer $n$ is divisible by $d$ if and only if $P = n$.\n\nThe phrase \"at most one conditional correction step based on a comparison\" used in the problem description is more fitting for an algorithm that returns the exact quotient $\\lfloor n/d \\rfloor$ (which would require correcting $q$ downward if $q \\cdot d > n$). For a simple Boolean divisibility test, the direct comparison $q \\cdot d = n$ is sufficient and fully determined by the multiplication and shift.\n\n**Computation of S**\n\nWe are given $w=32$, so $2^w = 2^{32} = 4294967296$. We need to compute $M(d) = \\left\\lceil \\frac{2^{32}}{d} \\right\\rceil$ for $d \\in \\{7, 10, 25\\}$. We will use the integer arithmetic formula $M(d) = (2^{32} + d - 1)/d$.\n\nFor $d=7$:\n$$M(7) = \\left\\lceil \\frac{4294967296}{7} \\right\\rceil = \\left\\lceil 613566756.57... \\right\\rceil = 613566757$$\n\nFor $d=10$:\n$$M(10) = \\left\\lceil \\frac{4294967296}{10} \\right\\rceil = \\left\\lceil 429496729.6 \\right\\rceil = 429496730$$\n\nFor $d=25$:\n$$M(25) = \\left\\lceil \\frac{4294967296}{25} \\right\\rceil = \\left\\lceil 171798691.84 \\right\\rceil = 171798692$$\n\nFinally, we compute the sum $S$:\n$$S = M(7) + M(10) + M(25) = 613566757 + 429496730 + 171798692$$\n$$S = 1043063487 + 171798692 = 1214862179$$\nThe required quantity is $S = 1214862179$.", "answer": "$$\\boxed{1214862179}$$", "id": "3229075"}, {"introduction": "Division and multiplication are not just arithmetic operations; they are fundamental building blocks for essential data structures like hash tables. The choice between the \"division method\" and the \"multiplication method\" for hashing has significant consequences for performance, especially when keys have certain patterns. This practice challenges you to implement both methods and, more importantly, to design a white-box test suite to rigorously validate their properties and expose their potential weaknesses [@problem_id:3229012].", "problem": "You are asked to implement, reason about, and validate two indexing strategies for hash tables that are canonically referred to as the division method and the multiplication method, using only core mathematical definitions. You must then construct a white-box test suite that generates adversarial and boundary inputs (including keys of the form $x = 2^k - 1$ and table sizes $m = 2^k$) and checks invariants that must hold across multiple independent implementations and parameter choices.\n\nFundamental bases to use:\n- For any integers $x$ and $m$ with $m \\ge 1$, the remainder $r$ of dividing $x$ by $m$ is the unique integer satisfying $0 \\le r \\le m - 1$ and $x = q m + r$ for some integer $q$.\n- For any real $y$, define the floor function $\\lfloor y \\rfloor$ as the greatest integer less than or equal to $y$, and define the fractional part $\\{y\\} = y - \\lfloor y \\rfloor \\in [0, 1)$.\n\nTasks to implement:\n1. Implement an index function for the division method that returns the remainder of $x$ modulo $m$ as an integer in $[0, m-1]$. Implement it in two algebraically equivalent ways and verify their equality on all tested inputs:\n   - Using the canonical remainder function.\n   - Using the identity $x - m \\cdot \\left\\lfloor \\dfrac{x}{m} \\right\\rfloor$.\n2. When $m$ is a power of two, implement a third, bit-level index function that uses only bitwise operations and is provably equivalent to the division method in this case.\n3. Implement an index function for the multiplication method using a fixed real multiplier $A \\in (0, 1)$: compute $\\left\\lfloor m \\cdot \\{x A\\} \\right\\rfloor$ using only the definitions above.\n\nWhite-box invariants your program must check:\n- Range safety: every computed index must be in $[0, m-1]$.\n- Equivalence of independent implementations of the same specification: when $m = 2^k$, the division method and the bit-level method must agree for all tested $x$, including negative integers.\n- Arithmetic progression stability under division: for keys of the form $x = t m + r$ with fixed $m$ and $r$, the division method must return $r$ for all integers $t$.\n- Sensitivity of the multiplication method to the choice of $A$: with an irrational-like slope (e.g., a high-quality constant in $(0, 1)$) the distribution of bucket counts should be near-uniform; with a rational slope such as $A = \\dfrac{1}{2}$ and $m = 2^k$, only a small number of buckets should be used.\n\nRequired test suite. Your program must compute a list of seven boolean results, each corresponding to one of the following test cases and its invariant. Use exactly the parameter values given below and no randomness.\n\n- Test $1$ (power-of-two equivalence and range): let $m = 2^{10}$ and test all integers $x$ in $\\{0, 1, \\dots, 4095\\}$. Verify that the two division-method implementations and the bitwise implementation are all equal and in range.\n- Test $2$ (arithmetic progression under prime modulus): let $m = 1019$ (prime), $r = 57$, and test $x = t m + r$ for $t \\in \\{0, 1, \\dots, 999\\}$. Verify that both division-method implementations return $r$ for all tested $x$.\n- Test $3$ (negative keys under power-of-two modulus): let $m = 2^8$. Test all $x$ in $\\{-300, -299, \\dots, 300\\}$. Verify that both division-method implementations are equal and that the bitwise implementation equals them for all tested $x$.\n- Test $4$ (near-uniformity for multiplication method): let $m = 2^{10}$, $A = \\dfrac{\\sqrt{5} - 1}{2}$, and test $x \\in \\{0, 1, \\dots, 65535\\}$. Compute bucket counts for all $m$ buckets. Let $N = 65536$ and check the predicate $\\max\\text{count} - \\min\\text{count} \\le \\lceil 4 \\sqrt{N / m} \\rceil$. Return a boolean indicating whether this holds.\n- Test $5$ (degeneracy detection for rational slope): let $m = 2^{10}$, $A = \\dfrac{1}{2}$, and test $x \\in \\{0, 1, \\dots, 4095\\}$. Verify that exactly $2$ distinct buckets are used. Return a boolean that is true if this degeneracy is detected.\n- Test $6$ (cross-method contrast on arithmetic progression): let $m = 2^{10}$, $A = \\dfrac{\\sqrt{5} - 1}{2}$, fix $r = 7$, and test $x = t m + r$ for $t \\in \\{0, 1, \\dots, 2047\\}$. Verify that the division method uses exactly $1$ bucket while the multiplication method uses at least $900$ distinct buckets.\n- Test $7$ (large-integer boundary conditions under power-of-two modulus): let $m = 2^{20}$ and test $x \\in \\{2^{61} - 1, 2^{61}, 2^{61} + 1, -(2^{61} - 1), -2^{61}, -(2^{61} + 1)\\}$. Verify equality of the two division-method implementations and the bitwise implementation on all these $x$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of the seven booleans, enclosed in square brackets, with no spaces. For example, a valid output looks like \"[true1,true2,true3,true4,true5,true6,true7]\" where each \"truei\" is either \"True\" or \"False\" as produced by the programming language’s boolean-to-string conversion.\n\nNo user input is allowed. No external files or network access are allowed. All numeric answers are unitless real or integer quantities as appropriate and no physical units or angles are involved. The outputs for the seven test cases must each be a boolean.", "solution": "The user-provided problem statement has been meticulously analyzed and is determined to be **valid**. It is scientifically grounded in the established principles of algorithms and data structures, specifically hash table index generation. The problem is well-posed, with all parameters, definitions, and constraints clearly and unambiguously specified. It requires the implementation and validation of canonical hashing methods against a comprehensive, well-designed test suite that probes their fundamental mathematical properties and practical behaviors.\n\n### Principle-Based Solution Design\n\nThe solution involves implementing two primary hashing strategies—the division method and the multiplication method—and then subjecting them to a series of rigorous white-box tests. The design is based on the precise mathematical definitions provided.\n\n#### 1. The Division Method\n\nThe division method computes the hash index of a key $x$ for a table of size $m$ as the remainder of the division of $x$ by $m$. Mathematically, this is expressed as $h(x) = x \\pmod m$. The problem requires this to be implemented in three distinct ways, which must be equivalent under the specified conditions.\n\n**Implementation 1: Canonical Remainder**\nThis implementation uses the native remainder operator provided by the programming language. In Python, the operator `%` computes the remainder. For a positive modulus $m > 0$, Python's `x % m` correctly yields a result in the interval $[0, m-1]$ for any integer $x$ (positive or negative), which precisely matches the problem's definition of remainder: the unique integer $r$ such that $x = qm + r$ and $0 \\le r < m$.\n\n**Implementation 2: Floor-Based Identity**\nThis implementation is based on the mathematical identity $x \\pmod m = x - m \\lfloor \\frac{x}{m} \\rfloor$. For integer arithmetic, this is equivalent to `x - m * (x // m)`, where `//` is the integer floor division operator. This formulation is mathematically equivalent to the canonical remainder and must produce identical results for all integers $x$ and a positive integer $m$.\n\n**Implementation 3: Bitwise Method for Power-of-Two Modulus**\nWhen the table size $m$ is a power of two, i.e., $m = 2^k$ for some integer $k \\ge 1$, the operation $x \\pmod m$ is equivalent to isolating the lower $k$ bits of the binary representation of $x$. This is because any integer $x$ can be written as $x = q \\cdot 2^k + r$, where $r$ is the integer represented by the lower $k$ bits. The remainder is thus $r$. This bit-level extraction can be performed efficiently using a bitwise AND operation with a mask. The required mask is $m-1$, which in binary is a sequence of $k$ ones. The hash index is therefore calculated as $h(x) = x \\text{ & } (m-1)$, where `&` denotes the bitwise AND operator. This equivalence holds for both positive and negative integers when using a two's complement representation, which is standard in modern computing architectures.\n\n#### 2. The Multiplication Method\n\nThe multiplication method computes a hash index via the formula $h(x) = \\lfloor m \\cdot \\{xA\\} \\rfloor$, where $A$ is a chosen constant in $(0, 1)$ and $\\{y\\} = y - \\lfloor y \\rfloor$ denotes the fractional part of a real number $y$.\n\n**Implementation and Principles**\nThis method works by first mapping the integer key $x$ to a real number $xA$. The fractional part $\\{xA\\}$ then provides a value in the interval $[0, 1)$, effectively scrambling the key's value. Multiplying by $m$ scales this value to the range $[0, m)$, and the final floor operation maps it to an integer index in $[0, m-1]$.\n\nThe effectiveness of this method is highly sensitive to the choice of $A$.\n- If $A$ is an irrational number whose fractional part has \"good\" distribution properties (e.g., the golden ratio conjugate $A = \\frac{\\sqrt{5}-1}{2} \\approx 0.618$), the resulting hash values tend to be spread uniformly across the buckets. This is desirable for avoiding collisions.\n- If $A$ is a simple rational, such as $A = \\frac{p}{q}$ for small integers $p, q$, the method can exhibit degenerate behavior. For example, if $A = 1/2$ and $m$ is a power of two, only two distinct hash values will ever be produced, leading to extremely poor performance.\n\nThe implementation will use standard double-precision floating-point arithmetic (e.g., `numpy.float64`) to represent $A$ and perform the intermediate calculations.\n\n#### 3. Test Suite and Invariants\n\nThe seven test cases are designed to verify the correctness and specific properties of the implemented hash functions.\n\n- **Tests 1, 3, and 7** are equivalence checks. They confirm that all three implementations of the division method produce identical results for a range of inputs: positive integers (Test 1), negative integers (Test 3), and very large integers that test the limits of standard fixed-size integer types (Test 7). This validates the underlying mathematical equivalences.\n- **Test 2** verifies a fundamental property of the modulo operation: for any arithmetic progression $x_t = tm+r$, the hash value via the division method is always the constant remainder $r$. This ensures the implementation is arithmetically sound.\n- **Test 4** provides a quantitative check on the uniformity of the multiplication method. By choosing a good constant $A$ and a large set of keys, it measures the spread of bucket occupancies. The condition $\\max(\\text{count}) - \\min(\\text{count}) \\le \\lceil 4 \\sqrt{N / m} \\rceil$ is a heuristic to confirm that the distribution is close to uniform (the range of counts is bounded relative to the expected standard deviation of counts).\n- **Test 5** is the counterpoint to Test 4. It demonstrates the degenerate case of the multiplication method by using a poor choice of A ($A=1/2$) with a power-of-two table size, verifying that this leads to a catastrophic collapse of the hash space into just two buckets.\n- **Test 6** provides a direct contrast between the two methods on the same input data (an arithmetic progression). It confirms that the division method predictably maps all keys to a single bucket, whereas the multiplication method, with a good constant $A$, scatters the keys widely across the hash table, highlighting their different sensitivities to input patterns.\n\nThe solution will be a self-contained Python program implementing these functions and executing the seven tests, producing a list of boolean outcomes as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates division and multiplication hashing methods.\n    \"\"\"\n\n    # --------------------------------------------------------------------------\n    # HASH FUNCTION IMPLEMENTATIONS\n    # --------------------------------------------------------------------------\n\n    def division_method_mod(x: int, m: int) -> int:\n        \"\"\"\n        Computes the hash index using the canonical remainder operator.\n        Corresponds to x mod m.\n        \"\"\"\n        return x % m\n\n    def division_method_floor(x: int, m: int) -> int:\n        \"\"\"\n        Computes the hash index using the identity x - m * floor(x/m).\n        \"\"\"\n        if m <= 0:\n            raise ValueError(\"Modulus m must be positive.\")\n        return x - m * (x // m)\n\n    def division_method_bitwise(x: int, m: int) -> int:\n        \"\"\"\n        Computes the hash index using bitwise AND for m = 2^k.\n        \"\"\"\n        # This implementation assumes m is a power of 2, but the logic\n        # doesn't strictly require a check as it's only used in contexts\n        # where this is guaranteed.\n        return x & (m - 1)\n\n    def multiplication_method(x: int, m: int, A: float) -> int:\n        \"\"\"\n        Computes the hash index using the multiplication method:\n        h(x) = floor(m * {x*A}), where {y} = y - floor(y).\n        \"\"\"\n        if m <= 0:\n            raise ValueError(\"Table size m must be positive.\")\n        if not (0 < A < 1):\n            raise ValueError(\"Constant A must be in (0, 1).\")\n        \n        y = x * A\n        # The fractional part {y} is y - floor(y).\n        frac_part = y - np.floor(y)\n        # Final index calculation\n        index = np.floor(m * frac_part)\n        return int(index)\n\n    # --------------------------------------------------------------------------\n    # WHITE-BOX TEST SUITE\n    # --------------------------------------------------------------------------\n\n    def test1() -> bool:\n        \"\"\"\n        Test 1: Power-of-two equivalence and range.\n        m = 2^10, x in {0, ..., 4095}.\n        Verify all three division methods are equal and in range.\n        \"\"\"\n        m = 2**10\n        for x in range(4096):\n            h1 = division_method_mod(x, m)\n            h2 = division_method_floor(x, m)\n            h3 = division_method_bitwise(x, m)\n            if not (h1 == h2 == h3 and 0 <= h1 < m):\n                return False\n        return True\n\n    def test2() -> bool:\n        \"\"\"\n        Test 2: Arithmetic progression under prime modulus.\n        m = 1019, r = 57, x = t*m + r for t in {0, ..., 999}.\n        Verify both division methods return r.\n        \"\"\"\n        m = 1019\n        r = 57\n        for t in range(1000):\n            x = t * m + r\n            h1 = division_method_mod(x, m)\n            h2 = division_method_floor(x, m)\n            if not (h1 == r and h2 == r):\n                return False\n        return True\n\n    def test3() -> bool:\n        \"\"\"\n        Test 3: Negative keys under power-of-two modulus.\n        m = 2^8, x in {-300, ..., 300}.\n        Verify all three division methods are equal.\n        \"\"\"\n        m = 2**8\n        for x in range(-300, 301):\n            h1 = division_method_mod(x, m)\n            h2 = division_method_floor(x, m)\n            h3 = division_method_bitwise(x, m)\n            if not (h1 == h2 == h3):\n                return False\n        return True\n\n    def test4() -> bool:\n        \"\"\"\n        Test 4: Near-uniformity for multiplication method.\n        m = 2^10, A = (sqrt(5)-1)/2, x in {0, ..., 65535}.\n        Check max(counts) - min(counts) <= ceil(4 * sqrt(N/m)).\n        \"\"\"\n        m = 2**10\n        A = (np.sqrt(5) - 1) / 2\n        N = 65536\n        counts = np.zeros(m, dtype=int)\n        \n        for x in range(N):\n            h = multiplication_method(x, m, A)\n            if not (0 <= h < m): return False # Implicit range safety check\n            counts[h] += 1\n            \n        max_count = np.max(counts)\n        min_count = np.min(counts)\n        bound = np.ceil(4 * np.sqrt(N / m))\n        \n        return (max_count - min_count) <= bound\n\n    def test5() -> bool:\n        \"\"\"\n        Test 5: Degeneracy detection for rational slope.\n        m = 2^10, A = 1/2, x in {0, ..., 4095}.\n        Verify exactly 2 distinct buckets are used.\n        \"\"\"\n        m = 2**10\n        A = 0.5\n        buckets = set()\n        for x in range(4096):\n            h = multiplication_method(x, m, A)\n            buckets.add(h)\n        return len(buckets) == 2\n\n    def test6() -> bool:\n        \"\"\"\n        Test 6: Cross-method contrast on arithmetic progression.\n        m = 2^10, A = (sqrt(5)-1)/2, r = 7, x = t*m + r for t in {0, ..., 2047}.\n        Verify division method uses 1 bucket, multiplication uses >= 900.\n        \"\"\"\n        m = 2**10\n        A = (np.sqrt(5) - 1) / 2\n        r = 7\n        div_buckets = set()\n        mul_buckets = set()\n\n        for t in range(2048):\n            x = t * m + r\n            h_div = division_method_mod(x, m)\n            h_mul = multiplication_method(x, m, A)\n            div_buckets.add(h_div)\n            mul_buckets.add(h_mul)\n            \n        return len(div_buckets) == 1 and len(mul_buckets) >= 900\n\n    def test7() -> bool:\n        \"\"\"\n        Test 7: Large-integer boundary conditions.\n        m = 2^20, test specific large integers around 2^61.\n        Verify equality of all three division methods.\n        \"\"\"\n        m = 2**20\n        p = 2**61\n        keys = [p - 1, p, p + 1, -(p - 1), -p, -(p + 1)]\n        \n        for x in keys:\n            h1 = division_method_mod(x, m)\n            h2 = division_method_floor(x, m)\n            h3 = division_method_bitwise(x, m)\n            if not (h1 == h2 == h3):\n                return False\n        return True\n\n    # --------------------------------------------------------------------------\n    # EXECUTION\n    # --------------------------------------------------------------------------\n    \n    test_functions = [test1, test2, test3, test4, test5, test6, test7]\n    results = [func() for func in test_functions]\n    \n    # Format the final output string as specified: [True,False,...] without spaces.\n    results_str = \",\".join(map(str, results))\n    print(f\"[{results_str}]\")\n\nsolve()\n```", "id": "3229012"}, {"introduction": "While the standard algorithm for matrix multiplication has a time complexity of $O(n^3)$, asymptotically faster methods like Strassen's algorithm, with a complexity of approximately $O(n^{\\log_2 7})$, exist. However, the higher overhead of these advanced algorithms means they are only faster for sufficiently large inputs. This hands-on exercise requires you to build a detailed cost model to determine the practical \"crossover point\" where Strassen's algorithm actually outperforms the standard method, illustrating the crucial interplay between theoretical complexity and real-world performance engineering [@problem_id:3229040].", "problem": "You are given two algorithms for square matrix multiplication: the standard cubic-time algorithm and a divide-and-conquer algorithm due to Volker Strassen. Your task is to determine, for a particular machine model, the smallest matrix dimension $n$ (if any) at which Strassen’s algorithm becomes faster than the standard $O(n^3)$ algorithm when all relevant overheads are accounted for. The answer must be produced by a complete, runnable program that evaluates the machine model and reports the minimal crossover $n$ for each provided test case.\n\nStart from the following fundamental base and widely accepted facts:\n- In the standard algorithm for multiplying two $n \\times n$ matrices, there are exactly $n^3$ scalar multiply-accumulate pairs and $n^2$ scalar writes to the output matrix, ignoring loop overhead. Treat the cost of a multiply-accumulate pair and a scalar add as separate and assume that a fused multiply-accumulate primitive is available, with a per-pair time constant.\n- Strassen’s algorithm partitions each input matrix into four submatrices of dimension approximately $\\lceil n/2 \\rceil \\times \\lceil n/2 \\rceil$, performs $7$ subproblems of matrix multiplication at that reduced dimension, and uses $18$ matrix additions or subtractions on matrices of dimension approximately $\\lceil n/2 \\rceil \\times \\lceil n/2 \\rceil$ to form the intermediate results and the final blocks. For non-even $n$, a standard approach is to conceptually pad to the next even dimension and count work with the ceiling.\n- Time on a real machine comes from scalar arithmetic, memory traffic (loads, stores, and packing or copying), and fixed overheads per call or recursion node. These costs combine additively, and we assume they scale linearly with the number of scalar operations or moved elements as appropriate.\n\nYou must derive algorithmic cost expressions from the above base, making clear how the structure of each algorithm leads to its total time as a function of $n$ and machine constants. You will then implement these costs and search for the smallest $n$ such that Strassen’s cost is less than or equal to the classic algorithm’s cost. If no crossover exists up to a specified search limit $N_{\\max}$, you must report $-1$ for that test case.\n\nAll timing constants are given in nanoseconds per scalar operation or per call, as appropriate. Report $n$ as a dimensionless integer. No other physical units are required in the output.\n\nImplementation requirements:\n- Let $T_{\\text{classic}}(n)$ denote the cost of the standard algorithm with per-operation constants provided in the test case. Model it using the $n^3$ multiply-accumulate pairs and $n^2$ memory traffic that must occur to produce and write the output.\n- Let $T_{\\text{strassen}}(n)$ denote the cost of Strassen’s algorithm, with a recursion that replaces a problem of size $n$ by $7$ subproblems of size $\\lceil n/2 \\rceil$, plus the costs of matrix additions/subtractions, packing or copying, and a fixed overhead per recursion node. Below a given base threshold $b$ (specified per test case), the Strassen routine should switch to a base multiplication routine whose per-operation constants may differ from those of the top-level classic algorithm to reflect a tuned kernel.\n- For non-even $n$, use $\\lceil n/2 \\rceil$ to determine the subproblem dimension and count matrix additions and packing at the $\\lceil n/2 \\rceil \\times \\lceil n/2 \\rceil$ granularity. You may assume padding is conceptual, and costs are proportional to the number of scalar elements touched.\n- Use memoization to avoid recomputing $T_{\\text{strassen}}(n)$ for repeated $n$, and search $n$ from $1$ up to and including $N_{\\max}$ to find the smallest crossover, if any.\n- The final output must be a single line containing the answers for all test cases as a comma-separated list enclosed in square brackets, for example $[n_1,n_2,n_3]$.\n\nTest suite:\nProvide answers for the following $4$ machine models and configuration parameters. Each case supplies:\n- $t^{\\text{classic}}_{\\text{fma}}$: nanoseconds per scalar fused multiply-accumulate pair in the standard algorithm.\n- $t^{\\text{classic}}_{\\text{mem}}$: nanoseconds per scalar element of memory traffic attributable to the standard algorithm, scaled by $n^2$.\n- $t^{\\text{classic}}_{\\text{setup}}$: fixed nanoseconds per top-level multiplication call in the standard algorithm.\n- $t^{\\text{base}}_{\\text{fma}}$: nanoseconds per scalar fused multiply-accumulate pair when the Strassen routine uses its base multiplication kernel.\n- $t^{\\text{base}}_{\\text{mem}}$: nanoseconds per scalar element of memory traffic in the base kernel, scaled by $n^2$.\n- $t^{\\text{base}}_{\\text{setup}}$: fixed nanoseconds per base-kernel call.\n- $t_{\\text{add}}$: nanoseconds per scalar matrix addition or subtraction.\n- $t_{\\text{pack}}$: nanoseconds per scalar element packed or copied in Strassen’s overhead.\n- $f_{\\text{pack}}$: a dimensionless factor multiplying the $\\lceil n/2 \\rceil^2$ elements to model total packing or temporary-move volume per recursion node.\n- $t_{\\text{call}}$: fixed nanoseconds of overhead per Strassen recursion node.\n- $b$: base threshold; when $n \\le b$ the Strassen routine uses the base kernel.\n- $N_{\\max}$: the maximum dimension to search for a crossover.\n\nCase A (balanced overhead):\n- $t^{\\text{classic}}_{\\text{fma}} = 1.1$, $t^{\\text{classic}}_{\\text{mem}} = 0.06$, $t^{\\text{classic}}_{\\text{setup}} = 200000$.\n- $t^{\\text{base}}_{\\text{fma}} = 0.9$, $t^{\\text{base}}_{\\text{mem}} = 0.08$, $t^{\\text{base}}_{\\text{setup}} = 250000$.\n- $t_{\\text{add}} = 0.35$, $t_{\\text{pack}} = 0.07$, $f_{\\text{pack}} = 12.0$, $t_{\\text{call}} = 4000$.\n- $b = 64$, $N_{\\max} = 2048$.\n\nCase B (high Strassen overhead, unfavorable):\n- $t^{\\text{classic}}_{\\text{fma}} = 1.0$, $t^{\\text{classic}}_{\\text{mem}} = 0.05$, $t^{\\text{classic}}_{\\text{setup}} = 50000$.\n- $t^{\\text{base}}_{\\text{fma}} = 1.0$, $t^{\\text{base}}_{\\text{mem}} = 0.1$, $t^{\\text{base}}_{\\text{setup}} = 200000$.\n- $t_{\\text{add}} = 0.6$, $t_{\\text{pack}} = 0.2$, $f_{\\text{pack}} = 16.0$, $t_{\\text{call}} = 20000$.\n- $b = 64$, $N_{\\max} = 2048$.\n\nCase C (favorable to Strassen):\n- $t^{\\text{classic}}_{\\text{fma}} = 1.5$, $t^{\\text{classic}}_{\\text{mem}} = 0.08$, $t^{\\text{classic}}_{\\text{setup}} = 300000$.\n- $t^{\\text{base}}_{\\text{fma}} = 0.7$, $t^{\\text{base}}_{\\text{mem}} = 0.06$, $t^{\\text{base}}_{\\text{setup}} = 150000$.\n- $t_{\\text{add}} = 0.25$, $t_{\\text{pack}} = 0.05$, $f_{\\text{pack}} = 8.0$, $t_{\\text{call}} = 1000$.\n- $b = 32$, $N_{\\max} = 1024$.\n\nCase D (large base threshold):\n- $t^{\\text{classic}}_{\\text{fma}} = 1.2$, $t^{\\text{classic}}_{\\text{mem}} = 0.05$, $t^{\\text{classic}}_{\\text{setup}} = 100000$.\n- $t^{\\text{base}}_{\\text{fma}} = 0.95$, $t^{\\text{base}}_{\\text{mem}} = 0.07$, $t^{\\text{base}}_{\\text{setup}} = 120000$.\n- $t_{\\text{add}} = 0.3$, $t_{\\text{pack}} = 0.06$, $f_{\\text{pack}} = 10.0$, $t_{\\text{call}} = 5000$.\n- $b = 128$, $N_{\\max} = 4096$.\n\nYour program should produce a single line of output containing the four crossover points as a comma-separated list enclosed in square brackets, in the order A, B, C, D, for example $[n_A,n_B,n_C,n_D]$. If there is no crossover up to $N_{\\max}$ for a case, print $-1$ in that position. No additional text or lines should be printed.", "solution": "The user provided a valid problem statement. I will proceed with the solution.\n\n### Problem Validation\n\nThe problem is to determine the crossover point in performance between the standard cubic-time matrix multiplication algorithm and Strassen's divide-and-conquer algorithm, based on a detailed cost model.\n\n**1. Extracted Givens:**\nThe problem provides definitions and parameters for three cost models:\n- $T_{\\text{classic}}(n)$: The time for the standard $n \\times n$ matrix multiplication.\n- $T_{\\text{base}}(n)$: The time for a tuned base-case multiplication kernel.\n- $T_{\\text{strassen}}(n)$: The time for Strassen's recursive algorithm.\n\nThe cost functions depend on a set of parameters provided for four distinct test cases (A, B, C, D):\n- $t^{\\text{classic}}_{\\text{fma}}$, $t^{\\text{classic}}_{\\text{mem}}$, $t^{\\text{classic}}_{\\text{setup}}$: Time constants for the standard algorithm's fused multiply-accumulate (FMA) operations, memory traffic, and setup overhead.\n- $t^{\\text{base}}_{\\text{fma}}$, $t^{\\text{base}}_{\\text{mem}}$, $t^{\\text{base}}_{\\text{setup}}$: Time constants for the base-case kernel used by Strassen's algorithm for small matrices.\n- $t_{\\text{add}}$: Time per scalar addition/subtraction in Strassen's overhead.\n- $t_{\\text{pack}}$, $f_{\\text{pack}}$: Time per scalar element packed/copied and a dimensionless factor for total data movement in Strassen's overhead.\n- $t_{\\text{call}}$: Fixed overhead per recursive call in Strassen's algorithm.\n- $b$: The dimension at or below which Strassen's algorithm switches to the base-case kernel.\n- $N_{\\max}$: The maximum matrix dimension to search for a crossover.\n\nThe goal is to find the smallest integer $n \\in [1, N_{\\max}]$ such that $T_{\\text{strassen}}(n) \\le T_{\\text{classic}}(n)$.\n\n**2. Validation Verdict:**\nThe problem is **valid**. It is scientifically grounded in the principles of algorithm analysis and performance modeling. It is well-posed, with a clear objective and all necessary data provided. The definitions are precise and objective, allowing for a unique, verifiable solution. The problem does not violate any of the invalidity criteria.\n\n### Algorithmic Cost Models\n\nTo find the crossover point, we first formalize the cost function for each algorithm as a function of the matrix dimension $n$ and the given time constants.\n\n**1. Standard Algorithm Cost: $T_{\\text{classic}}(n)$**\nThe standard algorithm for multiplying two $n \\times n$ matrices involves $n^3$ scalar multiplications and additions, which are modeled as fused multiply-accumulate (FMA) pairs. Additionally, the $n^2$ elements of the resulting matrix must be written to memory. A fixed setup cost is also included. The total time, $T_{\\text{classic}}(n)$, is the sum of these components:\n$$T_{\\text{classic}}(n) = t^{\\text{classic}}_{\\text{fma}} \\cdot n^3 + t^{\\text{classic}}_{\\text{mem}} \\cdot n^2 + t^{\\text{classic}}_{\\text{setup}}$$\nwhere $t^{\\text{classic}}_{\\text{fma}}$ is the time per FMA, $t^{\\text{classic}}_{\\text{mem}}$ is the time per element written, and $t^{\\text{classic}}_{\\text{setup}}$ is the fixed setup cost per call.\n\n**2. Base-Case Kernel Cost: $T_{\\text{base}}(n)$**\nStrassen's algorithm utilizes a standard multiplication kernel for subproblems of size $n \\le b$. This kernel has a cost structure identical to the classic algorithm but with potentially different performance constants, reflecting a more specialized implementation.\n$$T_{\\text{base}}(n) = t^{\\text{base}}_{\\text{fma}} \\cdot n^3 + t^{\\text{base}}_{\\text{mem}} \\cdot n^2 + t^{\\text{base}}_{\\text{setup}}$$\n\n**3. Strassen's Algorithm Cost: $T_{\\text{strassen}}(n)$**\nStrassen's algorithm is recursive. Its cost, $T_{\\text{strassen}}(n)$, is defined by a recurrence relation. For non-even dimensions, the subproblem size is taken as $m = \\lceil n/2 \\rceil$.\n\n- **Base Case ($n \\le b$):** If the dimension $n$ is less than or equal to the threshold $b$, the algorithm switches to the base-case kernel.\n$$T_{\\text{strassen}}(n) = T_{\\text{base}}(n), \\quad \\text{for } n \\le b$$\n\n- **Recursive Step ($n > b$):** For dimensions larger than $b$, the algorithm divides the matrices into blocks of size $m = \\lceil n/2 \\rceil$ and performs:\n    1.  $7$ recursive matrix multiplications of size $m \\times m$.\n    2.  $18$ matrix additions or subtractions on matrices of size $m \\times m$.\nThe overhead at each recursive step includes the cost of these additions/subtractions, data packing/copying for temporary matrices, and a fixed per-call overhead. The total overhead cost, $O_{\\text{strassen}}(n)$, is:\n$$O_{\\text{strassen}}(n) = 18 \\cdot m^2 \\cdot t_{\\text{add}} + f_{\\text{pack}} \\cdot m^2 \\cdot t_{\\text{pack}} + t_{\\text{call}}$$\nThe complete recurrence relation for $n > b$ is:\n$$T_{\\text{strassen}}(n) = 7 \\cdot T_{\\text{strassen}}(\\lceil n/2 \\rceil) + O_{\\text{strassen}}(n)$$\n\n### Solution Methodology\n\nTo find the crossover point for each test case, we implement the derived cost functions and perform a linear search.\n1.  For each set of parameters, we define functions to compute $T_{\\text{classic}}(n)$ and $T_{\\text{strassen}}(n)$.\n2.  The function for $T_{\\text{strassen}}(n)$ is implemented recursively. To avoid recomputing costs for the same subproblem size, we use memoization (caching the results of $T_{\\text{strassen}}(n)$ for each $n$ as it is calculated).\n3.  We iterate through matrix dimensions $n$ from $1$ up to the specified limit $N_{\\max}$.\n4.  In each iteration, we compute both $T_{\\text{classic}}(n)$ and $T_{\\text{strassen}}(n)$.\n5.  The first value of $n$ for which the condition $T_{\\text{strassen}}(n) \\le T_{\\text{classic}}(n)$ is satisfied is the crossover point. This value is recorded, and the search for that test case terminates.\n6.  If the loop completes without finding such an $n$, it means no crossover occurs within the search limit. In this scenario, we report $-1$ as per the problem specification.\n7.  The final results for all test cases are collected and formatted into a single output line.\n\nThe following program implements this methodology.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the crossover point for Strassen's vs. standard matrix multiplication\n    for a series of machine models.\n    \"\"\"\n\n    class CrossoverFinder:\n        \"\"\"\n        Encapsulates the logic and parameters for finding the crossover point\n        for a single machine model.\n        \"\"\"\n        def __init__(self, params):\n            \"\"\"\n            Initializes the finder with a dictionary of parameters for one test case.\n            \n            Args:\n                params (dict): A dictionary containing all time constants and limits.\n            \"\"\"\n            self.p = params\n            self.memo = {}\n\n        def t_classic(self, n):\n            \"\"\"\n            Calculates the cost of the standard cubic-time matrix multiplication.\n            \n            T_classic(n) = t_fma_c * n^3 + t_mem_c * n^2 + t_setup_c\n            \"\"\"\n            return self.p['t_fma_c'] * n**3 + \\\n                   self.p['t_mem_c'] * n**2 + \\\n                   self.p['t_setup_c']\n\n        def t_base(self, n):\n            \"\"\"\n            Calculates the cost of the base-case kernel used by Strassen's algorithm.\n            \n            T_base(n) = t_fma_b * n^3 + t_mem_b * n^2 + t_setup_b\n            \"\"\"\n            return self.p['t_fma_b'] * n**3 + \\\n                   self.p['t_mem_b'] * n**2 + \\\n                   self.p['t_setup_b']\n        \n        def t_strassen(self, n):\n            \"\"\"\n            Calculates the cost of Strassen's algorithm recursively with memoization.\n            \"\"\"\n            if n in self.memo:\n                return self.memo[n]\n            \n            # Base case: if n <= b, use the tuned base kernel.\n            if n <= self.p['b']:\n                result = self.t_base(n)\n                self.memo[n] = result\n                return result\n            \n            # Recursive step\n            m = int(np.ceil(n / 2))\n            \n            # Overhead at this recursion level: 18 matrix additions/subtractions,\n            # data packing, and a fixed call overhead.\n            overhead = (18 * m**2 * self.p['t_add'] +\n                        self.p['f_pack'] * m**2 * self.p['t_pack'] +\n                        self.p['t_call'])\n            \n            # Recurrence relation: T(n) = 7*T(n/2) + Overhead(n)\n            result = 7 * self.t_strassen(m) + overhead\n            \n            self.memo[n] = result\n            return result\n\n        def find_crossover(self):\n            \"\"\"\n            Searches for the smallest integer n where Strassen's is faster.\n            \"\"\"\n            for n in range(1, self.p['N_max'] + 1):\n                cost_classic = self.t_classic(n)\n                cost_strassen = self.t_strassen(n)\n                \n                if cost_strassen <= cost_classic:\n                    return n\n            \n            return -1\n\n    test_cases = [\n        # Case A: balanced overhead\n        {'t_fma_c': 1.1, 't_mem_c': 0.06, 't_setup_c': 200000,\n         't_fma_b': 0.9, 't_mem_b': 0.08, 't_setup_b': 250000,\n         't_add': 0.35, 't_pack': 0.07, 'f_pack': 12.0, 't_call': 4000,\n         'b': 64, 'N_max': 2048},\n        # Case B: high Strassen overhead, unfavorable\n        {'t_fma_c': 1.0, 't_mem_c': 0.05, 't_setup_c': 50000,\n         't_fma_b': 1.0, 't_mem_b': 0.1, 't_setup_b': 200000,\n         't_add': 0.6, 't_pack': 0.2, 'f_pack': 16.0, 't_call': 20000,\n         'b': 64, 'N_max': 2048},\n        # Case C: favorable to Strassen\n        {'t_fma_c': 1.5, 't_mem_c': 0.08, 't_setup_c': 300000,\n         't_fma_b': 0.7, 't_mem_b': 0.06, 't_setup_b': 150000,\n         't_add': 0.25, 't_pack': 0.05, 'f_pack': 8.0, 't_call': 1000,\n         'b': 32, 'N_max': 1024},\n        # Case D: large base threshold\n        {'t_fma_c': 1.2, 't_mem_c': 0.05, 't_setup_c': 100000,\n         't_fma_b': 0.95, 't_mem_b': 0.07, 't_setup_b': 120000,\n         't_add': 0.3, 't_pack': 0.06, 'f_pack': 10.0, 't_call': 5000,\n         'b': 128, 'N_max': 4096}\n    ]\n\n    results = []\n    for params in test_cases:\n        finder = CrossoverFinder(params)\n        crossover_point = finder.find_crossover()\n        results.append(crossover_point)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3229040"}]}