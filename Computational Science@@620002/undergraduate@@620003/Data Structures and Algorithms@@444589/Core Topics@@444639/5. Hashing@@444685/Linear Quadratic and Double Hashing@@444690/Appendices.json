{"hands_on_practices": [{"introduction": "To truly understand an algorithm's limitations, it is often instructive to design inputs that expose its worst-case behavior. This exercise challenges you to do just that for linear probing. By constructing a specific sequence of keys, you will see firsthand how primary clustering develops and leads to degraded performance, making an abstract concept very concrete. [@problem_id:3244644]", "problem": "Consider a hash table of size $m$ that uses open addressing with linear probing. The collision resolution rule is: upon inserting or searching for a key $k$, probe the sequence of table indices $h(k), h(k)+1, h(k)+2, \\dots$ taken modulo $m$ until an empty slot is found (during insertion) or the target key is found (during successful search). The primary hash function is $h(k) = k \\bmod m$. The table is initially empty. You will insert $n$ distinct keys $k_1, k_2, \\dots, k_n$ with $0 < n < m$, and after all insertions, a successful search is performed for a single key drawn uniformly at random from $\\{k_1, k_2, \\dots, k_n\\}$. Define the load factor $\\alpha$ as $\\alpha = \\frac{n}{m}$.\n\nYour task is to design an adversarial choice of $m$ and a sequence of distinct keys $k_1, \\dots, k_n$ so that linear probing creates a single contiguous cluster of length $n$ in the table, and then quantify the expected number of probes required for a successful search under the uniform random key model described above. You must do the following:\n\n- Specify a valid choice of $m$ and $k_1, \\dots, k_n$ in terms of $m$ that ensures all keys hash to the same initial index under $h(k) = k \\bmod m$, thereby forcing a single contiguous cluster through linear probing. Argue that the keys are distinct and that the resulting cluster is contiguous of length $n$.\n\n- Starting from the core definitions of open addressing, linear probing, and the probing sequence induced by $h(k)$, derive the expected number of probes required for a successful search when the query key is drawn uniformly from the $n$ inserted keys. Express your final answer as a closed-form analytic expression in terms of the load factor $\\alpha$ and $m$.\n\nNo shortcut formulas may be invoked; derive the result directly from the definitions and the structural effect of the adversarial sequence on the probe sequences. The final answer must be a single closed-form analytic expression. No rounding is required.", "solution": "The problem statement is validated as being scientifically grounded, well-posed, objective, and complete. It describes a classic worst-case scenario for linear probing in hashing, a standard topic in the analysis of algorithms. The problem is free of any scientific or logical flaws. We may therefore proceed with a solution.\n\nThe task is to first construct a sequence of keys that creates a specific adversarial condition (a single contiguous cluster) and then to derive the expected number of probes for a successful search under this condition.\n\n### Part 1: Adversarial Key Sequence Construction\n\nThe goal is to choose a hash table size $m$ and a sequence of $n$ distinct keys, $k_1, k_2, \\dots, k_n$, such that all keys hash to the same initial table index, thereby generating a single long cluster under linear probing.\n\nLet the hash table size $m$ be an integer satisfying $m > n > 0$.\nThe primary hash function is given as $h(k) = k \\bmod m$.\nTo ensure all keys hash to the same index, we must have $h(k_1) = h(k_2) = \\dots = h(k_n)$. Without loss of generality, let us choose this common hash index to be $0$. This requires that $k_i \\bmod m = 0$ for all $i \\in \\{1, 2, \\dots, n\\}$. This is equivalent to stating that each key $k_i$ must be an integer multiple of $m$.\n\nWe must also ensure the keys are distinct. A simple choice that satisfies both conditions is to define the keys as successive non-zero multiples of $m$. We specify the sequence of keys as:\n$$k_i = i \\cdot m \\quad \\text{for } i = 1, 2, \\dots, n$$\n\nWe verify that this choice of keys meets the required criteria:\n1.  **Distinctness**: Let $i$ and $j$ be two distinct indices in $\\{1, 2, \\dots, n\\}$, so $i \\neq j$. Since $m > n > 0$, it follows that $i \\cdot m \\neq j \\cdot m$. Thus, the keys $k_1, k_2, \\dots, k_n$ are all distinct.\n2.  **Common Hash Index**: For any key $k_i = i \\cdot m$ in the sequence, the hash function yields $h(k_i) = (i \\cdot m) \\bmod m = 0$. All keys hash to the initial index $0$.\n\nNow, we analyze the state of the hash table after inserting these $n$ keys in order into an initially empty table.\n-   **Insertion of $k_1 = 1 \\cdot m$**: The hash index is $h(k_1)=0$. The table slot at index $0$ is empty, so $k_1$ is placed at index $0$. This requires $1$ probe.\n-   **Insertion of $k_2 = 2 \\cdot m$**: The hash index is $h(k_2)=0$. Slot $0$ is now occupied by $k_1$. Linear probing proceeds to the next index, $(0+1) \\bmod m = 1$. Slot $1$ is empty, so $k_2$ is placed at index $1$. This requires $2$ probes (one for slot $0$, one for slot $1$).\n-   **Insertion of $k_3 = 3 \\cdot m$**: The hash index is $h(k_3)=0$. Slot $0$ is occupied. Probing to index $1$ finds it also occupied. Probing to index $(0+2) \\bmod m = 2$ finds an empty slot. So, $k_3$ is placed at index $2$. This requires $3$ probes.\n\nWe can formalize this with a simple inductive argument. Assume that after inserting keys $k_1, \\dots, k_{j-1}$, the table slots with indices $0, 1, \\dots, j-2$ are occupied. Now, consider the insertion of key $k_j = j \\cdot m$. Its hash index is $h(k_j)=0$. The linear probing sequence is $0, 1, 2, \\dots$. The probe will examine slots $0, 1, \\dots, j-2$, all of which are occupied. The next probe is to index $j-1$. Since $j-1 < n < m$, this index is within the table bounds and, by our assumption, is empty. Thus, $k_j$ is placed at index $j-1$. The number of probes to insert $k_j$ is $(j-1) - 0 + 1 = j$.\n\nThis process holds for all $j$ from $1$ to $n$. After inserting all $n$ keys, $k_1, \\dots, k_n$, the hash table slots at indices $0, 1, \\dots, n-1$ are occupied. This forms a single contiguous cluster of length $n$, as required by the problem.\n\n### Part 2: Expected Number of Probes for Successful Search\n\nWe are to find the expected number of probes for a successful search, where the key to be searched is drawn uniformly at random from the set of $n$ inserted keys $\\{k_1, k_2, \\dots, k_n\\}$.\n\nThe number of probes required for a successful search for a key is identical to the number of probes that were required to insert that key in the first place. Let $C(k)$ be the number of probes to search for key $k$. From our analysis in Part 1, the number of probes to insert (and thus to find) key $k_i$ is $C(k_i) = i$.\n\nThe keys to be searched are drawn with uniform probability. This means the probability of searching for any particular key $k_i$ is $P(\\text{search } k_i) = \\frac{1}{n}$.\n\nLet $E[C_S]$ be the expected number of probes for a successful search. By the definition of expected value, we have:\n$$E[C_S] = \\sum_{i=1}^{n} C(k_i) \\cdot P(\\text{search } k_i)$$\nSubstituting the values we found:\n$$E[C_S] = \\sum_{i=1}^{n} i \\cdot \\frac{1}{n}$$\nWe can factor the constant $\\frac{1}{n}$ out of the summation:\n$$E[C_S] = \\frac{1}{n} \\sum_{i=1}^{n} i$$\nThe summation is the sum of the first $n$ positive integers, for which there is a well-known closed-form formula:\n$$\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$$\nSubstituting this back into the expression for the expected value:\n$$E[C_S] = \\frac{1}{n} \\left( \\frac{n(n+1)}{2} \\right) = \\frac{n+1}{2}$$\nThe problem requires the final answer to be expressed in terms of the load factor $\\alpha = \\frac{n}{m}$ and the table size $m$. From the definition of the load factor, we can express $n$ as $n = \\alpha m$.\n\nSubstituting $n = \\alpha m$ into our result for $E[C_S]$:\n$$E[C_S] = \\frac{(\\alpha m) + 1}{2} = \\frac{\\alpha m + 1}{2}$$\nThis is the final closed-form analytic expression for the expected number of probes for a successful search under the specified adversarial conditions.", "answer": "$$\\boxed{\\frac{\\alpha m + 1}{2}}$$", "id": "3244644"}, {"introduction": "Double hashing is designed to mitigate the clustering issues found in linear probing, but its effectiveness depends critically on the properties of the secondary hash function. This practice presents a carefully constructed scenario where a poor choice of step size leads to catastrophic failure, even when the table is mostly empty. Analyzing this pathology reveals the essential number-theoretic principles that ensure a robust double hashing implementation. [@problem_id:3244585]", "problem": "You are given an open-address hash table with table size $m$ and a standard double hashing scheme. By definition, when inserting a key $k$, the $j$-th probe examines the table index\n$$\ni_j \\equiv h_1(k) + j \\cdot h_2(k) \\pmod m,\n$$\nfor $j \\in \\{0,1,2,\\dots\\}$, stopping as soon as an empty slot is found or reporting failure if no empty slot is encountered before an index repeats. The load factor is $\\alpha \\equiv n/m$, where $n$ is the current number of stored keys.\n\nConsider the following concrete setup designed to isolate the effect of the secondary hash function:\n\n- Table size $m = 64$.\n- Primary hash $h_1(k) \\equiv k \\bmod 64$ (so, for uniformly distributed residues modulo $64$, it is near-perfect).\n- Secondary hash $h_2(k) \\equiv 8$ for all keys (so the step size is fixed).\n- Key sequence $S$ of $9$ keys to be inserted into an initially empty table, in the given order:\n$$\nS = \\{0,\\,64,\\,128,\\,192,\\,256,\\,320,\\,384,\\,448,\\,512\\}.\n$$\n- The load factor after inserting all $9$ keys would be $\\alpha = 9/64$ if all insertions succeeded.\n\nUsing only the core definitions of open addressing with double hashing and fundamental properties of modular arithmetic, select all statements below that are correct about this setup and about how to avoid the pathology it exhibits.\n\nA. With $m=64$, $h_1(k) \\equiv k \\bmod 64$, $h_2(k) \\equiv 8$, and the sequence $S$ as given, the insertion of the $9$-th key fails even though $\\alpha = 9/64$ is small.\n\nB. If, instead, $m$ were any prime and $h_2(k)$ were guaranteed to lie in $\\{1,2,\\dots,m-1\\}$ for every key $k$, then for any insertion sequence no insertion can fail before the table is completely full, because each double-hash probe sequence can visit all $m$ slots.\n\nC. Replacing double hashing by linear probing (that is, using step size $1$) while keeping $m=64$ and $h_1(k) \\equiv k \\bmod 64$ would still fail on the $9$-th insertion for the same sequence $S$.\n\nD. The failure in this setup arises solely because $h_1$ is poor; if $h_1$ is replaced by any permutation on the residues modulo $64$ (that is, any $h_1$ that is a bijection on $\\{0,1,\\dots,63\\}$), the failure disappears even if $h_2(k) \\equiv 8$.\n\nE. For general $m$ and any fixed key $k$, the number of distinct table indices its double-hash probe sequence can reach equals $m / \\gcd(h_2(k), m)$, where $\\gcd$ denotes the greatest common divisor; consequently, if $\\gcd(h_2(k), m) > 1$, the probe sequence for $k$ is confined to a strict subset of the table.", "solution": "The problem statement describes an open-address hash table using a double hashing scheme. We are asked to analyze a specific pathological case and evaluate several statements about it and its underlying causes.\n\nFirst, let's validate the problem statement.\nThe givens are:\n- Hash table size: $m = 64$.\n- Primary hash function: $h_1(k) \\equiv k \\bmod 64$.\n- Secondary hash function: $h_2(k) \\equiv 8$ for all keys.\n- Probe sequence formula: $i_j \\equiv h_1(k) + j \\cdot h_2(k) \\pmod m$ for $j \\in \\{0, 1, 2, \\dots\\}$.\n- Key sequence for insertion into an initially empty table: $S = \\{0, 64, 128, 192, 256, 320, 384, 448, 512\\}$. There are $9$ keys in this sequence.\n\nThe problem is scientifically grounded in the principles of data structures and algorithms, specifically hashing. It is well-posed, with all necessary parameters defined. The language is objective and unambiguous. The setup, while demonstrating poor hashing practice, is not invalid as a theoretical exercise. It is a valid problem designed to test the understanding of double hashing mechanics.\n\nWe begin by analyzing the behavior of the given hash functions with the specified key sequence.\nFor every key $k$ in the sequence $S = \\{0, 64, \\dots, 512\\}$, $k$ is an integer multiple of $64$. That is, $k = q \\cdot 64$ for some integer $q \\in \\{0, 1, \\dots, 8\\}$.\nThe primary hash function, $h_1(k) \\equiv k \\bmod 64$, will therefore map every key in $S$ to the same initial index:\n$$h_1(k) = (q \\cdot 64) \\bmod 64 = 0$$\nThis is a case of extreme primary collision: all $9$ keys map to slot $0$.\n\nThe secondary hash function is a constant, $h_2(k) = 8$.\nConsequently, the probe sequence for any key $k \\in S$ is given by:\n$$i_j \\equiv h_1(k) + j \\cdot h_2(k) \\pmod m \\equiv 0 + j \\cdot 8 \\pmod{64} \\equiv 8j \\pmod{64}$$\n\nThe number of distinct indices visited by this probe sequence is given by the general formula $m / \\gcd(h_2(k), m)$, where $\\gcd$ is the greatest common divisor. In this case, the step size is $h_2(k) = 8$ and the table size is $m = 64$.\nThe number of distinct reachable slots is:\n$$ \\frac{m}{\\gcd(h_2(k), m)} = \\frac{64}{\\gcd(8, 64)} = \\frac{64}{8} = 8 $$\nThe probe sequence for any key in $S$ can only visit $8$ distinct slots. The specific slots are $\\{8 \\cdot 0 \\bmod 64, 8 \\cdot 1 \\bmod 64, \\dots, 8 \\cdot 7 \\bmod 64\\}$, which is the set $\\{0, 8, 16, 24, 32, 40, 48, 56\\}$. After $j=7$, the probe sequence repeats, as $i_8 = 8 \\cdot 8 \\bmod 64 = 0 = i_0$.\n\nNow, let's trace the insertion of the keys from $S$:\n1.  Insert $k=0$: Probes index $0$. The slot is empty. It is placed there.\n2.  Insert $k=64$: Probes index $0$ (occupied), then index $0 + 1 \\cdot 8 = 8$ (empty). It is placed at index $8$.\n3.  Insert $k=128$: Probes index $0$ (occupied), $8$ (occupied), then $16$ (empty). It is placed at index $16$.\n...\n8.  Insert $k=448$: Probes indices $0, 8, 16, 24, 32, 40, 48$ (all occupied), then $56$ (empty). It is placed at index $56$.\n\nAfter the first $8$ keys are inserted, all $8$ reachable slots $\\{0, 8, 16, 24, 32, 40, 48, 56\\}$ are filled. The table contains $n=8$ elements, and the load factor is $\\alpha = 8/64 = 1/8$.\n\nNow, consider the insertion of the $9$-th key, $k=512$.\nIts hash values are $h_1(512)=0$ and $h_2(512)=8$. The probe sequence is identical to the previous ones: $0, 8, 16, \\dots, 56$.\nThe insertion algorithm will check slots $0, 8, 16, 24, 32, 40, 48,$ and $56$. It will find all of them occupied. The next probe, for $j=8$, would be index $0$ again. Since the probe sequence has repeated and no empty slot was found, the insertion process fails. This failure occurs even though $64 - 8 = 56$ slots in the table are still empty.\n\nWith this analysis, we can evaluate each option.\n\nA. With $m=64$, $h_1(k) \\equiv k \\bmod 64$, $h_2(k) \\equiv 8$, and the sequence $S$ as given, the insertion of the $9$-th key fails even though $\\alpha = 9/64$ is small.\nAs derived above, after inserting the first $8$ keys, all reachable slots for a key with $h_1(k)=0$ are occupied. The $9$-th key, $k=512$, also has $h_1(512)=0$ and thus probes the same sequence of slots. As all are occupied, the insertion fails. The load factor at the time of this failed insertion attempt is $n/m = 8/64$. The potential load factor if it had succeeded would be $\\alpha=9/64$, which is approximately $0.14$, a small value. The statement is entirely consistent with our derivation.\n**Verdict: Correct.**\n\nB. If, instead, $m$ were any prime and $h_2(k)$ were guaranteed to lie in $\\{1,2,\\dots,m-1\\}$ for every key $k$, then for any insertion sequence no insertion can fail before the table is completely full, because each double-hash probe sequence can visit all $m$ slots.\nThe number of distinct slots visited by a probe sequence is $m / \\gcd(h_2(k), m)$. If $m$ is a prime number, then for any integer $c$ such that $1 \\le c \\le m-1$, it holds that $\\gcd(c, m) = 1$.\nSince $h_2(k)$ is guaranteed to be in $\\{1, 2, \\dots, m-1\\}$, we have $\\gcd(h_2(k), m) = 1$.\nThe number of distinct slots visited is $m / 1 = m$. This means the probe sequence for any key generates a permutation of all table indices $\\{0, 1, \\dots, m-1\\}$.\nTherefore, when attempting to insert a key, its probe sequence will eventually visit every slot in the table. If the table is not full (i.e., at least one empty slot exists), the insertion is guaranteed to find an empty slot and succeed. An insertion can only fail if the table is completely full ($n=m$). The statement is a correct and fundamental principle for designing robust double hashing schemes.\n**Verdict: Correct.**\n\nC. Replacing double hashing by linear probing (that is, using step size $1$) while keeping $m=64$ and $h_1(k) \\equiv k \\bmod 64$ would still fail on the $9$-th insertion for the same sequence $S$.\nLinear probing is equivalent to setting the step size to $1$ for all keys. In the context of the double hashing formula, this corresponds to $h_2(k) = 1$. The probe sequence is $i_j \\equiv h_1(k) + j \\pmod m$.\nAll keys in $S$ still map to $h_1(k)=0$.\n1.  Insert $k=0$: placed at index $0$.\n2.  Insert $k=64$: probes $0$ (occ.), placed at index $1$.\n3.  Insert $k=128$: probes $0, 1$ (occ.), placed at index $2$.\n...\n8.  Insert $k=448$: probes $0, \\dots, 6$ (occ.), placed at index $7$.\n9.  Insert $k=512$: probes $0, \\dots, 7$ (occ.). The next probe is for index $8$, which is empty. The insertion succeeds, placing $k=512$ at index $8$.\nThe insertion does not fail. The reason is that with a step size of $1$, $\\gcd(1, 64) = 1$, so the probe sequence can visit all $64$ slots. The statement claims the insertion would fail, which is false.\n**Verdict: Incorrect.**\n\nD. The failure in this setup arises solely because $h_1$ is poor; if $h_1$ is replaced by any permutation on the residues modulo $64$ (that is, any $h_1$ that is a bijection on $\\{0,1,\\dots,63\\}$), the failure disappears even if $h_2(k) \\equiv 8$.\nThe statement claims the failure is *solely* due to $h_1$. The failure mechanism has two components: first, $h_1$ maps all keys in $S$ to the same slot, creating a primary collision cluster; second, $h_2$ generates a short probe sequence because $\\gcd(h_2(k), m) > 1$.\nIf $h_1$ were a permutation, the $9$ distinct keys in $S$ would map to $9$ distinct initial slots. Each key would be inserted into its initial slot without any collisions. The failure would indeed disappear for this specific sequence $S$.\nHowever, the word \"solely\" is critical. It implies that $h_2$ is not a cause. This is false. As shown in the analysis of option C, if we keep the \"poor\" $h_1$ but use a better $h_2$ (like $h_2(k) = 1$ for linear probing), the failure also disappears. Since fixing $h_2$ while keeping $h_1$ also solves the problem for this sequence, $h_1$ cannot be the sole cause. The pathology is a combined effect of primary collisions from $h_1$ and the deficient probe sequence length from $h_2$.\n**Verdict: Incorrect.**\n\nE. For general $m$ and any fixed key $k$, the number of distinct table indices its double-hash probe sequence can reach equals $m / \\gcd(h_2(k), m)$, where $\\gcd$ denotes the greatest common divisor; consequently, if $\\gcd(h_2(k), m) > 1$, the probe sequence for $k$ is confined to a strict subset of the table.\nThe probe sequence is an arithmetic progression modulo $m$: $p_j = a + j \\cdot s \\pmod m$, where $a=h_1(k)$ and $s=h_2(k)$. The set of values generated by this sequence is a coset of the cyclic subgroup generated by $s$ in the additive group of integers modulo $m$, $\\mathbb{Z}_m$. The order (size) of this subgroup is $|\\langle s \\rangle| = m / \\gcd(s, m)$. A coset has the same size as the subgroup. Thus, the number of distinct indices in the probe sequence is precisely $m / \\gcd(h_2(k), m)$.\nThe consequence follows directly: if $\\gcd(h_2(k), m) > 1$, then the denominator is greater than $1$, which means the number of reachable indices $m / \\gcd(h_2(k), m)$ is strictly less than $m$. Therefore, the probe sequence is confined to a strict subset of the table. This statement is a correct and fundamental theorem from number theory applied to hashing.\n**Verdict: Correct.**\n\nIn summary, statements A, B, and E are correct.", "answer": "$$\\boxed{ABE}$$", "id": "3244585"}, {"introduction": "Having seen how hashing schemes can fail, we now turn to analyzing their ideal performance. Under the uniform hashing assumption, which well-designed double hashing approximates, we can derive the expected number of probes for a search. This fundamental exercise guides you through the derivation for an unsuccessful search, providing a theoretical benchmark and demonstrating the excellent average-case efficiency that makes hashing so powerful. [@problem_id:3244529]", "problem": "A hash table uses open addressing with table size $m \\geq 2$ and contains $n$ stored keys, so the load factor is $\\alpha = n/m$ with $0 \\leq \\alpha < 1$. The table uses double hashing: the probe sequence for a key $k$ is $j_t(k) \\equiv h_1(k) + t \\cdot h_2(k) \\pmod m$ for $t = 0, 1, 2, \\dots$, where $h_1(k)$ is uniformly distributed over $\\{0, 1, \\dots, m-1\\}$ and $h_2(k)$ is independent of $h_1(k)$, uniformly distributed over $\\{1, 2, \\dots, m-1\\}$, and $\\gcd(h_2(k), m) = 1$. Assume the following modeling idealization that is standard in uniform hashing analysis: conditional on the set of $n$ occupied slots, the probe order induced by the double hashing sequence for an unsuccessful query key (a key not present in the table) is a uniformly random permutation of the $m$ slots, independent of which particular $n$ slots are occupied.\n\nStarting only from the fundamental definitions of a uniformly random permutation and linearity of expectation, derive an exact expression in terms of $m$ and $n$ for the expected number of probes performed by an unsuccessful search (that is, the expected index of the first empty slot encountered in the probe order). Then take the large-table limit $m \\to \\infty$ with fixed load factor $\\alpha \\in (0, 1)$ and provide the leading-order expression in terms of $\\alpha$ alone. Report only the final leading-order expression in terms of $\\alpha$ as your answer. No rounding is required.", "solution": "The problem requires the derivation of the expected number of probes for an unsuccessful search in an open-addressing hash table under the uniform hashing assumption.\n\nFirst, we validate the problem statement.\nThe problem provides a clear and self-contained setup.\nGivens:\n- Table size: $m \\geq 2$.\n- Number of stored keys: $n$.\n- Load factor: $\\alpha = n/m$, where $0 \\leq \\alpha < 1$.\n- Hashing scheme: Open addressing with double hashing, defined by the probe sequence $j_t(k) \\equiv h_1(k) + t \\cdot h_2(k) \\pmod m$. The properties of $h_1(k)$ and $h_2(k)$ are specified.\n- Critical modeling assumption: The probe sequence for an unsuccessful search is a uniformly random permutation of the $m$ slots.\n\nThe problem is scientifically grounded, as it deals with a standard, albeit idealized, model for analyzing hashing algorithms. It is well-posed, objective, and contains no contradictions or ambiguities. Therefore, the problem is valid, and we proceed with the solution.\n\nLet $X$ be the random variable representing the number of probes for an unsuccessful search. The search terminates upon finding the first empty slot. Under the uniform hashing assumption, the sequence of probes is a random permutation of the $m$ slots in the table. Of these $m$ slots, $n$ are occupied and $m-n$ are empty. We seek to find the expected value of $X$, denoted $E[X]$.\n\nA direct calculation of $E[X] = \\sum_{k=1}^{m-n+1} k \\cdot P(X=k)$ is possible but tedious. A more elegant and direct approach, as requested, is to use the linearity of expectation.\n\nLet us define a related random variable, $Y$, as the number of occupied slots examined before the first empty slot is found. The total number of probes is always one more than the number of occupied slots probed, so $X = Y + 1$. By the linearity of expectation, $E[X] = E[Y+1] = E[Y] + 1$. Our task thus reduces to finding $E[Y]$.\n\nTo find $E[Y]$, we can express $Y$ as a sum of indicator random variables. Let the set of $n$ occupied slots be denoted by $\\mathcal{O} = \\{O_1, O_2, \\dots, O_n\\}$. For each occupied slot $O_j \\in \\mathcal{O}$, we define an indicator variable $I_j$ as follows:\n$$\nI_j =\n\\begin{cases}\n1 & \\text{if slot } O_j \\text{ is probed before any empty slot} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\nThe total number of occupied slots probed before the first empty one is the sum of these indicator variables: $Y = \\sum_{j=1}^{n} I_j$.\n\nUsing the linearity of expectation, we have:\n$$E[Y] = E\\left[\\sum_{j=1}^{n} I_j\\right] = \\sum_{j=1}^{n} E[I_j]$$\nThe expectation of an indicator variable is equal to the probability of the event it indicates:\n$$E[I_j] = 1 \\cdot P(I_j=1) + 0 \\cdot P(I_j=0) = P(I_j=1)$$\nSo, we need to find the probability that a specific occupied slot $O_j$ is probed before any of the $m-n$ empty slots.\n\nLet the set of empty slots be denoted by $\\mathcal{E}$. The size of this set is $|\\mathcal{E}| = m-n$. Consider the subset of table slots consisting of the specific occupied slot $O_j$ and all the empty slots: $S_j = \\{O_j\\} \\cup \\mathcal{E}$. The size of this set is $|S_j| = 1 + (m-n) = m-n+1$.\n\nThe event $I_j=1$ occurs if and only if, within the probe sequence, the slot $O_j$ appears before any of the slots from $\\mathcal{E}$. The uniform hashing assumption states that the entire probe sequence is a uniformly random permutation of the $m$ table slots. A direct consequence of this is that the relative ordering of any subset of slots is also uniformly random.\nTherefore, if we consider only the relative ordering of the $m-n+1$ slots in the set $S_j$, each of these slots has an equal probability of appearing first.\n\nThe probability that $O_j$ is the first slot from $S_j$ to be probed is $\\frac{1}{|S_j|}$.\n$$P(I_j=1) = \\frac{1}{m-n+1}$$\nSince this probability is the same for all occupied slots $O_j$ (for $j=1, \\dots, n$), we have $E[I_j] = \\frac{1}{m-n+1}$ for all $j$.\n\nNow we can calculate $E[Y]$:\n$$E[Y] = \\sum_{j=1}^{n} E[I_j] = \\sum_{j=1}^{n} \\frac{1}{m-n+1} = \\frac{n}{m-n+1}$$\nFinally, we can find the exact expression for the expected number of probes, $E[X]$:\n$$E[X] = E[Y] + 1 = \\frac{n}{m-n+1} + 1 = \\frac{n + (m-n+1)}{m-n+1} = \\frac{m+1}{m-n+1}$$\nThis is the exact expression for the expected number of probes for an unsuccessful search in terms of $m$ and $n$.\n\nThe second part of the problem asks for the leading-order expression for $E[X]$ in the large-table limit, where $m \\to \\infty$ and the load factor $\\alpha = n/m$ remains constant.\nWe substitute $n = \\alpha m$ into our exact expression for $E[X]$:\n$$E[X] = \\frac{m+1}{m - \\alpha m + 1} = \\frac{m+1}{m(1-\\alpha) + 1}$$\nTo find the behavior for large $m$, we divide both the numerator and the denominator by $m$:\n$$E[X] = \\frac{1 + \\frac{1}{m}}{(1-\\alpha) + \\frac{1}{m}}$$\nNow, we take the limit as $m \\to \\infty$. The term $\\frac{1}{m}$ approaches $0$:\n$$\\lim_{m\\to\\infty} E[X] = \\frac{1 + 0}{(1-\\alpha) + 0} = \\frac{1}{1-\\alpha}$$\nThis is the leading-order expression for the expected number of probes for an unsuccessful search in terms of the load factor $\\alpha$.", "answer": "$$\\boxed{\\frac{1}{1-\\alpha}}$$", "id": "3244529"}]}