{"hands_on_practices": [{"introduction": "A hash function maps a large input space to a smaller, finite set of hash values, a property that makes collisions unavoidable. This first exercise challenges you to explore this many-to-one nature from a different angle: by working backward. Given a specific hash output, your task is to determine how many input pairs map to it within a given range [@problem_id:3261635]. This practice will sharpen your skills in modular arithmetic and demonstrate how to efficiently count preimages without resorting to brute force, a crucial technique for analyzing hash function distribution.", "problem": "Consider the hash function $h: \\mathbb{Z} \\times \\mathbb{Z} \\to \\{0,1,\\dots,m-1\\}$ defined by $h(x,y) = (x^2 + y) \\pmod{m}$, where $m$ is a given positive integer. For a fixed target hash value $v \\in \\{0,1,\\dots,m-1\\}$, the preimage set consists of all integer pairs $(x,y)$ such that $x \\in [X_{\\min}, X_{\\max}]$, $y \\in [Y_{\\min}, Y_{\\max}]$, and $x^2 + y \\equiv v \\pmod{m}$. Starting only from the formal definitions of a hash function, congruence modulo $m$, and integer intervals, derive a principled method to determine how many such pairs exist for any valid parameter set. Your program must compute, for each provided test case, the total number of pairs $(x,y)$ in the specified ranges that map to $v$ under $h$.\n\nAll quantities are integers. Assume $m \\geq 1$ and that $X_{\\min} \\leq X_{\\max}$ and $Y_{\\min} \\leq Y_{\\max}$. Your program must not enumerate all pairs explicitly unless the derivation justifies it; it must be based on logic derived from core definitions and properties of modular arithmetic. The required outputs are integers representing the counts of such pairs for each test case.\n\nTest Suite:\n- Case $1$: $m = 7$, $v = 3$, $X_{\\min} = 0$, $X_{\\max} = 20$, $Y_{\\min} = 0$, $Y_{\\max} = 30$.\n- Case $2$: $m = 1$, $v = 0$, $X_{\\min} = -5$, $X_{\\max} = 5$, $Y_{\\min} = -5$, $Y_{\\max} = 5$.\n- Case $3$: $m = 13$, $v = 0$, $X_{\\min} = 0$, $X_{\\max} = 100$, $Y_{\\min} = 0$, $Y_{\\max} = 100$.\n- Case $4$: $m = 9$, $v = 4$, $X_{\\min} = -20$, $X_{\\max} = -1$, $Y_{\\min} = -30$, $Y_{\\max} = -10$.\n- Case $5$: $m = 8$, $v = 7$, $X_{\\min} = 0$, $X_{\\max} = 50$, $Y_{\\min} = 3$, $Y_{\\max} = 3$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results, in the order of the cases above, as a comma-separated list enclosed in square brackets. For example, if the results for the five cases were $a_1, a_2, a_3, a_4, a_5$, the output must be exactly in the form $[a_1,a_2,a_3,a_4,a_5]$.", "solution": "The problem is well-defined, mathematically sound, and self-contained. It is based on established principles of number theory, specifically modular arithmetic, and computer science concepts related to hash functions. All provided parameters are clearly defined, and the constraints are consistent. Therefore, the problem is deemed valid and a formal solution can be derived.\n\nThe objective is to find the number of integer pairs $(x,y)$ that satisfy the following three conditions for given integers $m, v, X_{\\min}, X_{\\max}, Y_{\\min}, Y_{\\max}$:\n1.  $x \\in [X_{\\min}, X_{\\max}]$\n2.  $y \\in [Y_{\\min}, Y_{\\max}]$\n3.  $h(x,y) = (x^2 + y) \\pmod{m} = v$\n\nThe third condition can be expressed using the definition of congruence modulo $m$:\n$$x^2 + y \\equiv v \\pmod{m}$$\nThis congruence can be rearranged to isolate the variable $y$:\n$$y \\equiv v - x^2 \\pmod{m}$$\nA naive approach would be to iterate through all possible pairs $(x,y)$ in the specified rectangular domain and check if the congruence holds. However, this is computationally expensive if the ranges for $x$ and $y$ are large. The problem statement itself suggests that a more principled method based on modular arithmetic is required.\n\nA more efficient strategy is to iterate through the values of one variable, say $x$, and for each $x$, calculate the number of valid $y$ values. A crucial observation is that the condition on $y$ depends on $x$ only through the value of $x^2 \\pmod{m}$.\n\nLet $x_1$ and $x_2$ be two integers such that $x_1 \\equiv x_2 \\pmod{m}$. Then $x_1^2 \\equiv x_2^2 \\pmod{m}$. Consequently, the congruence for $y$ becomes identical for both $x_1$ and $x_2$:\n$$y \\equiv v - x_1^2 \\pmod{m} \\implies y \\equiv v - x_2^2 \\pmod{m}$$\nThis insight allows us to group all integers $x$ in the range $[X_{\\min}, X_{\\max}]$ by their residue class modulo $m$. For any $x$ belonging to a given residue class $r \\in \\{0, 1, \\dots, m-1\\}$, where $x \\equiv r \\pmod{m}$, the required residue for $y$ is the same. Let this required residue for $y$ be $c_r$:\n$$c_r = (v - r^2) \\pmod{m}$$\nThe problem is now reduced to two main steps:\n1.  For each residue class $r \\in \\{0, 1, \\dots, m-1\\}$, determine the number of integers $y$ in the interval $[Y_{\\min}, Y_{\\max}]$ that satisfy $y \\equiv c_r \\pmod{m}$.\n2.  For each residue class $r$, determine the number of integers $x$ in the interval $[X_{\\min}, X_{\\max}]$ that satisfy $x \\equiv r \\pmod{m}$.\n\nThe total number of pairs is the sum, over all residue classes $r$, of the product of these two counts.\nLet's formalize the counting method. We need a function to count the number of integers in an interval $[A, B]$ that are congruent to $c \\pmod{m}$. An integer $z$ satisfies $z \\equiv c \\pmod{m}$ if and only if $z-c$ is a multiple of $m$. Thus, we need to count the number of multiples of $m$ in the interval $[A-c, B-c]$. The number of multiples of $m$ in an interval $[L, R]$ can be calculated as $\\lfloor R/m \\rfloor - \\lfloor (L-1)/m \\rfloor$. This formula is robust for both positive and negative integers when using floor division.\n\nApplying this to our problem:\nLet $N_y(c_r)$ be the number of valid $y$ values for a required residue $c_r$. This corresponds to counting integers congruent to $c_r \\pmod{m}$ in the interval $[Y_{\\min}, Y_{\\max}]$.\n$$N_y(c_r) = \\left\\lfloor \\frac{Y_{\\max} - c_r}{m} \\right\\rfloor - \\left\\lfloor \\frac{Y_{\\min} - c_r - 1}{m} \\right\\rfloor$$\nLet $N_x(r)$ be the number of $x$ values in $[X_{\\min}, X_{\\max}]$ that are congruent to $r \\pmod{m}$.\n$$N_x(r) = \\left\\lfloor \\frac{X_{\\max} - r}{m} \\right\\rfloor - \\left\\lfloor \\frac{X_{\\min} - r - 1}{m} \\right\\rfloor$$\n\nThe overall algorithm proceeds as follows:\n1.  Initialize total count to $0$.\n2.  Loop through each possible residue class for $x$, i.e., for $r$ from $0$ to $m-1$.\n3.  For each $r$, calculate the required residue for $y$: $c_r = (v - r^2) \\pmod{m}$.\n4.  Calculate $N_y(c_r)$, the number of $y$ values in $[Y_{\\min}, Y_{\\max}]$ that are congruent to $c_r \\pmod{m}$.\n5.  If $N_y(c_r) > 0$, calculate $N_x(r)$, the number of $x$ values in $[X_{\\min}, X_{\\max}]$ that are congruent to $r \\pmod{m}$.\n6.  Add the product $N_x(r) \\times N_y(c_r)$ to the total count.\n7.  After iterating through all $r$, the total count is the final answer.\n\nThis algorithm has a time complexity of $O(m)$, which is highly efficient and independent of the size of the ranges for $x$ and $y$.\n\nA special case occurs when $m=1$. In this case, any integer is congruent to $0 \\pmod 1$. The condition $x^2 + y \\equiv v \\pmod 1$ is always satisfied (as $v$ must be $0$). The problem reduces to counting the total number of pairs in the rectangle, which is $(X_{\\max} - X_{\\min} + 1) \\times (Y_{\\max} - Y_{\\min} + 1)$. The general algorithm correctly handles this case as well.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(m, v, x_min, x_max, y_min, y_max):\n    \"\"\"\n    Calculates the number of integer pairs (x,y) in the given ranges satisfying\n    (x^2 + y) mod m = v, based on principles of modular arithmetic.\n    \"\"\"\n    # The condition is y === v - x^2 (mod m).\n    # The required remainder for y depends only on r_x = x mod m.\n    # The overall strategy is to iterate through each residue class r_x from 0 to m-1,\n    # calculate the number of valid y's for that class, calculate the number of\n    # x's belonging to that class, and sum up the products.\n\n    # This is a general function to count integers in [lower, upper]\n    # that are congruent to `rem` modulo `mod`.\n    # Based on the formula: count = floor( (upper-rem)/mod ) - floor( (lower-rem-1)/mod )\n    # This is equivalent to counting multiples of `mod` in the range [lower-rem, upper-rem].\n    def count_congruent(lower, upper, mod, rem):\n        u_bound = upper - rem\n        l_bound = lower - rem\n        return (u_bound // mod) - ((l_bound - 1) // mod)\n\n    # Special case for m=1. Any integer is congruent to 0 mod 1.\n    # Since v must be 0, the condition is always met.\n    if m == 1:\n        num_x = x_max - x_min + 1\n        num_y = y_max - y_min + 1\n        return num_x * num_y\n\n    # Step 1: Pre-calculate the number of valid y's for each possible residue class of x.\n    # Let r_x = x mod m. The required residue for y is c_r = (v - r_x^2) mod m.\n    y_counts_per_residue = [0] * m\n    for r_x in range(m):\n        c_r = (v - r_x**2) % m\n        y_counts_per_residue[r_x] = count_congruent(y_min, y_max, m, c_r)\n\n    # Step 2: Sum up contributions for each residue class.\n    total_pairs = 0\n    for r_x in range(m):\n        # Optimization: if no y values work for this residue, skip calculation for x.\n        if y_counts_per_residue[r_x] == 0:\n            continue\n\n        # Count how many x's in [x_min, x_max] belong to residue class r_x.\n        num_x = count_congruent(x_min, x_max, m, r_x)\n        \n        # Add the product to the total.\n        total_pairs += num_x * y_counts_per_residue[r_x]\n            \n    return total_pairs\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # m, v, X_min, X_max, Y_min, Y_max\n        (7, 3, 0, 20, 0, 30),\n        (1, 0, -5, 5, -5, 5),\n        (13, 0, 0, 100, 0, 100),\n        (9, 4, -20, -1, -30, -10),\n        (8, 7, 0, 50, 3, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, v, x_min, x_max, y_min, y_max = case\n        result = solve_case(m, v, x_min, x_max, y_min, y_max)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3261635"}, {"introduction": "While a good hash function aims to distribute keys uniformly, collisions will still occur, and the performance of a hash table then hinges on its collision resolution strategy. This practice dives into quadratic probing, a popular open addressing technique designed to avoid the clustering issues of linear probing. Instead of just analyzing average performance, you will engineer a specific sequence of keys to induce a worst-case probe sequence, revealing the phenomenon of secondary clustering [@problem_id:3261658]. Completing this challenge provides a concrete understanding of how the interplay between keys and the probing mechanism dictates real-world performance.", "problem": "You are given an initially empty open-addressed hash table of size $M$ with the following properties. The base hash function is $h_0(k) = k \\pmod M$. Open addressing (OA) is performed by quadratic probing (QP) with the probe function $h(k,i) = (h_0(k) + i^2) \\pmod M$ for successive probe indices $i = 0, 1, 2, \\dots$. Assume $M$ is an odd prime and the hash table stores integers without deletions, with an insertion procedure that probes until it finds the first empty slot and places the key there.\n\nStarting from the foundational definitions above, design a sequence of integer keys $\\{k_j\\}$ to be inserted into the empty table such that the insertion of the final key in your sequence causes the probing process to examine exactly $\\frac{M+1}{2}$ distinct slots in total (counting both unsuccessful probes that find occupied slots and the final successful probe that finds an empty slot) before placing the key. Your construction must be justified by first principles of modular arithmetic and hash function behavior, not by ad hoc prescriptions.\n\nYour program must:\n- For each specified value of $M$, construct such a sequence of keys, insert them into the hash table using quadratic probing as defined, and record the total number of distinct probes performed during the insertion of the final key (including the successful probe that finds the empty slot).\n- Simulate the hash table faithfully according to the definitions provided, ensuring that each probe checks the slot index $h(k,i)$ in increasing order of $i$ starting from $i=0$, stopping on the first empty slot found and placing the key there.\n- Use only integers; there are no physical units involved.\n- Produce the final output aggregating the results for all provided test cases into a single line as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3]$ where each $r_j$ is the integer probe count for the corresponding test case.\n\nTest suite:\n- Case 1: $M = 3$ (boundary prime).\n- Case 2: $M = 7$ (small prime).\n- Case 3: $M = 11$ (moderate prime).\n- Case 4: $M = 17$ (larger prime).\n- Case 5: $M = 101$ (significantly larger prime).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_j$ is the total number of probes (including the successful one) performed during the insertion of the final key for the corresponding $M$ in the test suite. The solution must be universally applicable in purely mathematical and logical terms to any modern programming language, but your final answer must be provided as runnable Python code as specified.", "solution": "The user's request is to design a sequence of integer keys $\\{k_j\\}$ to be inserted into an initially empty open-addressed hash table of size $M$. The insertion of the final key must result in exactly $\\frac{M+1}{2}$ distinct probe attempts. The hash table uses quadratic probing with the function $h(k,i) = (h_0(k) + i^2) \\pmod M$, where $h_0(k) = k \\pmod M$ and $M$ is an odd prime.\n\n**1. Analysis of Quadratic Probing with Prime Modulus**\n\nThe core of this problem lies in the number-theoretic properties of quadratic probing when the table size $M$ is a prime number. The sequence of indices probed for a key $k$ is given by $(h_0(k) + i^2) \\pmod M$ for $i = 0, 1, 2, \\dots$. The number of distinct slots visited depends on the number of distinct values of $i^2 \\pmod M$.\n\nLet's analyze the set of quadratic residues modulo a prime $M$, $S = \\{i^2 \\pmod M \\mid i \\in \\{0, 1, \\dots, M-1\\}\\}$.\n- For $i=0$, we have $0^2 \\equiv 0 \\pmod M$.\n- For any $i \\in \\{1, \\dots, M-1\\}$, if we have two probe indices $i$ and $j$ such that $0 \\le i < j < M$ and $i^2 \\equiv j^2 \\pmod M$, this implies $j^2 - i^2 \\equiv 0 \\pmod M$, which is $(j-i)(j+i) \\equiv 0 \\pmod M$.\n- Since $M$ is prime, it must divide either $(j-i)$ or $(j+i)$.\n- As $0 < j-i < M$, $M$ cannot divide $(j-i)$.\n- Therefore, $M$ must divide $(j+i)$. Since $0 < i+j < 2M$, the only possibility is $j+i = M$.\n\nThis means that for any $i \\in \\{1, 2, \\dots, \\frac{M-1}{2}\\}$, its square modulo $M$ is the same as that of $M-i$, since $(M-i)^2 = M^2 - 2Mi + i^2 \\equiv i^2 \\pmod M$.\nThe values of $i^2 \\pmod M$ for $i=1, 2, \\dots, \\frac{M-1}{2}$ are all distinct. If $i^2 \\equiv j^2 \\pmod M$ for $1 \\le i < j \\le \\frac{M-1}{2}$, then $j+i=M$. However, $i+j \\le (\\frac{M-1}{2}-1) + \\frac{M-1}{2} = M-2$, which is less than $M$. This is a contradiction.\n\nConsequently, the set of distinct values of $i^2 \\pmod M$ is generated by $i=0, 1, \\dots, \\frac{M-1}{2}$. The size of this set is precisely $\\frac{M-1}{2} + 1 = \\frac{M+1}{2}$. This proves that quadratic probing for any key will visit at most $\\frac{M+1}{2}$ distinct slots. The problem requires us to construct a scenario where this maximum is achieved.\n\n**2. Construction of the Key Sequence**\n\nTo force an insertion to perform exactly $N = \\frac{M+1}{2}$ probes, we must ensure that the first $N-1$ slots it attempts to access are occupied, and the $N$-th slot is empty.\n\nLet the final key be $k_{final}$. To simplify the analysis of its probe sequence, let's choose $k_{final}$ such that its base hash $h_0(k_{final})$ is $0$. A simple choice that has not been previously inserted is $k_{final} = M$, since $h_0(M) = M \\pmod M = 0$.\n\nThe probe sequence for $k_{final}=M$ will access slots at indices $h(M, i) = (0 + i^2) \\pmod M = i^2 \\pmod M$. The probe attempts correspond to $i=0, 1, 2, \\dots$.\n\nTo achieve $\\frac{M+1}{2}$ probes, we require probe attempts for $i = 0, 1, \\dots, \\frac{M-1}{2}$.\n- The probe for $i = \\frac{M-1}{2}$ must be the one that finds an empty slot.\n- The probes for $i = 0, 1, \\dots, \\frac{M-1}{2}-1 = \\frac{M-3}{2}$ must find occupied slots.\n\nThis means we must pre-fill the hash table by inserting a sequence of keys that occupy the slots at indices $j^2 \\pmod M$ for all $j \\in \\{0, 1, \\dots, \\frac{M-3}{2}\\}$. The number of such slots is $\\frac{M-3}{2} - 0 + 1 = \\frac{M-1}{2}$.\n\nThe most direct way to occupy a slot at a given index `idx` is to insert a key `k` such that $h_0(k) = \\text{idx}$. The simplest choice is to insert the key $k = \\text{idx}$ itself. Since we are pre-filling an empty table and all target indices $j^2 \\pmod M$ for $j \\in \\{0, \\dots, \\frac{M-3}{2}\\}$ are distinct and less than $M$, inserting the key $k = j^2 \\pmod M$ will place it directly into slot $j^2 \\pmod M$ in a single probe.\n\nTherefore, the constructed key sequence is as follows:\n1.  **Pre-fill Sequence**: Insert the keys $\\{k_j'\\} = \\{j^2 \\pmod M \\mid j=0, 1, \\dots, \\frac{M-3}{2}\\}$. There are $\\frac{M-1}{2}$ such keys.\n2.  **Final Key**: The final key to be inserted is $k_{final} = M$.\n\n**3. Verification of the Construction**\n\nLet's simulate the insertion of the final key, $k_{final}=M$, into the prepared hash table.\n- The base hash is $h_0(M) = 0$.\n- **Probe $i=0$**: Index is $(0+0^2) \\pmod M = 0$. This slot was filled by the key $0^2 \\pmod M$. The probe is unsuccessful.\n- **Probe $i=1$**: Index is $(0+1^2) \\pmod M = 1$. This slot was filled by the key $1^2 \\pmod M$. The probe is unsuccessful.\n- ...\n- **Probe $i = \\frac{M-3}{2}$**: Index is $(0 + (\\frac{M-3}{2})^2) \\pmod M$. This slot was filled by the key $(\\frac{M-3}{2})^2 \\pmod M$. The probe is unsuccessful.\nThese are $\\frac{M-1}{2}$ unsuccessful probes.\n\n- **Probe $i = \\frac{M-1}{2}$**: Index is $(0 + (\\frac{M-1}{2})^2) \\pmod M$. This slot was not part of the pre-fill sequence. It is empty. The probe is successful.\n\nThe total number of probes for the insertion of $k_{final}$ is the sum of unsuccessful probes and the one successful probe:\n$$ \\text{Total Probes} = \\left(\\frac{M-1}{2}\\right) + 1 = \\frac{M+1}{2} $$\nThis matches the problem's requirement. The design is thus validated. The program will implement this construction and simulation for each given value of $M$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hash table problem for a given suite of test cases.\n\n    For each prime M, it constructs a sequence of keys that, when inserted,\n    causes the final key's insertion to take exactly (M+1)/2 probes\n    using quadratic probing. It then simulates this process and records the\n    probe count.\n    \"\"\"\n    # Test cases as specified in the problem statement.\n    test_cases = [3, 7, 11, 17, 101]\n    results = []\n\n    for M in test_cases:\n        # Initialize the hash table of size M.\n        # We use -1 as a sentinel for an empty slot, as all keys are non-negative.\n        table = np.full(M, -1, dtype=int)\n\n        # 1. CONSTRUCT AND INSERT THE PRE-FILL KEY SEQUENCE\n        # The goal is to occupy the first (M-1)/2 probe locations for a key hashing to 0.\n        # These locations correspond to probe indices j = 0, 1, ..., (M-3)/2.\n        # The slot indices are (j^2 mod M).\n        # The number of slots to pre-fill is (M-1)/2. The range upper bound is exclusive.\n        num_prefill_slots = (M - 1) // 2\n\n        for j in range(num_prefill_slots):\n            # The key to insert is the index of the slot we want to fill.\n            # h_0(k) = k % M. Since k < M, h_0(k) = k.\n            key_to_insert = (j * j) % M\n            \n            # Since all pre-fill keys are inserted into an empty table at distinct\n            # base hash locations, each insertion takes exactly one probe.\n            # We don't need to simulate the probing for these keys.\n            table[key_to_insert] = key_to_insert\n\n        # 2. DEFINE THE FINAL KEY AND SIMULATE ITS INSERTION\n        # We choose a final key that hashes to 0 but is not in the pre-fill set.\n        # k_final = M is a safe choice, as all pre-fill keys are < M.\n        final_key = M\n        base_hash = final_key % M  # This will be 0\n\n        # Simulate the insertion of the final key and count the probes.\n        probe_count = 0\n        i = 0\n        while True:\n            probe_count += 1\n            index = (base_hash + i*i) % M\n\n            if table[index] == -1:  # Found an empty slot.\n                # The problem asks for the probe count, so the simulation can stop here.\n                # The actual insertion would be: table[index] = final_key\n                break\n            \n            # The slot is occupied, continue to the next probe.\n            i += 1\n        \n        results.append(probe_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3261658"}, {"introduction": "The power of hashing extends far beyond simple key-value lookups, forming the backbone of many advanced algorithms. This capstone practice applies hashing to a complex problem from bioinformatics: finding long, similar DNA sequences, even with some mutations. You will use a specialized tool, the rolling hash, to efficiently compare vast numbers of substrings, combined with a clever combinatorial argument to handle mismatches [@problem_id:3261679]. This exercise illustrates how hashing serves as a powerful building block for solving large-scale, real-world computational problems.", "problem": "You are given two finite strings over the Deoxyribonucleic Acid (DNA) alphabet $\\{A,C,G,T\\}$, denoted $S$ and $T$, and a nonnegative integer $k$. Define the Hamming distance $d_H(U,V)$ of two strings $U$ and $V$ of equal length as the count of positions at which the corresponding symbols differ. The longest $k$-mismatch common substring length is the maximum integer $\\ell$ such that there exist indices $i$ and $j$ with $0 \\le i \\le |S| - \\ell$ and $0 \\le j \\le |T| - \\ell$ for which $d_H\\big(S[i:i+\\ell], T[j:j+\\ell]\\big) \\le k$.\n\nStarting from the fundamental definitions of a hash function, a rolling hash, and the Hamming distance, design and implement an algorithm that uses a rolling hash to decide, for a fixed length $\\ell$, whether there exist substrings of $S$ and $T$ of length $\\ell$ whose Hamming distance is at most $k$, and then uses this decision procedure within a search to determine the longest $k$-mismatch common substring length. The algorithm must rely on:\n- A polynomial rolling hash over a finite modulus, with precomputed powers and prefix hashes, enabling $O(1)$ substring hash queries.\n- The combinatorial fact that for any two strings of equal length that differ in at most $k$ positions, a partition of the length into $k+1$ contiguous blocks guarantees at least one block matches exactly.\n\nYour program must:\n- Map each DNA character to an integer in $\\{1,2,3,4\\}$.\n- Use double hashing with two distinct large prime moduli to reduce collision probability.\n- For a given $\\ell$, partition the $\\ell$ positions into $k+1$ contiguous blocks where the first $r$ blocks have size $q+1$ and the remaining blocks have size $q$, with $q = \\lfloor \\frac{\\ell}{k+1} \\rfloor$ and $r = \\ell \\pmod{k+1}$.\n- For each block index $b \\in \\{0,1,\\dots,k\\}$, use the rolling hash to index all substrings of $S$ of length $\\ell$ by the hash of their $b$-th block. For each substring of $T$ of length $\\ell$, use the same $b$-th block hash to retrieve candidates from $S$, and confirm candidates by directly computing the Hamming distance, accepting if it is at most $k$.\n- Use a search over $\\ell \\in \\{0,1,\\dots,\\min(|S|,|T|)\\}$ to find the maximum $\\ell$ for which acceptance occurs. The search must be correct and efficient for the provided test suite.\n\nThe final output must be a single line containing the results for the entire test suite, formatted as a comma-separated list enclosed in square brackets (for example, \"[result1,result2,result3]\"). Each result must be an integer equal to the longest $k$-mismatch common substring length for its test case.\n\nTest Suite:\n- Case $1$: $S = $ \"AAAAAA\", $T = $ \"AAAATA\", $k = 1$.\n- Case $2$: $S = $ \"ACGT\", $T = $ \"ACGT\", $k = 0$.\n- Case $3$: $S = $ \"AAAA\", $T = $ \"TTTT\", $k = 0$.\n- Case $4$: $S = $ \"ACGTCGTA\", $T = $ \"ACGACGTA\", $k = 2$.\n- Case $5$: $S = $ \"\", $T = $ \"ACGT\", $k = 1$.\n- Case $6$: $S = $ \"ACGTACGT\", $T = $ \"ACGTTTGT\", $k = 1$.\n\nYour program must produce a single line of output containing the six integer results in the specified format, corresponding to the cases above and in the same order.", "solution": "The user provided a detailed problem statement, which I will now validate.\n\n### Step 1: Extract Givens\n\n-   **Inputs**:\n    1.  Two finite strings, $S$ and $T$, over the DNA alphabet $\\{A, C, G, T\\}$.\n    2.  A nonnegative integer $k$.\n\n-   **Definitions**:\n    1.  **Hamming distance $d_H(U,V)$**: For two strings $U$ and $V$ of equal length, this is the count of positions at which the corresponding symbols differ.\n    2.  **Longest $k$-mismatch common substring length**: The maximum integer $\\ell$ such that there exist indices $i$ and $j$ ($0 \\le i \\le |S| - \\ell$, $0 \\le j \\le |T| - \\ell$) for which $d_H\\big(S[i:i+\\ell], T[j:j+\\ell]\\big) \\le k$.\n\n-   **Algorithmic Constraints**:\n    1.  The solution must employ a two-part algorithm: a decision procedure nested within a search procedure.\n    2.  The decision procedure, for a fixed length $\\ell$, determines if any substrings of $S$ and $T$ of length $\\ell$ have a Hamming distance of at most $k$.\n    3.  The search procedure finds the maximum $\\ell$ for which the decision procedure returns true. The search must cover the range $\\ell \\in \\{0, 1, \\dots, \\min(|S|,|T|)\\}$.\n    4.  The algorithm must be based on a polynomial rolling hash with precomputed powers and prefix hashes for $O(1)$ substring hash queries. Double hashing with two distinct large prime moduli is required.\n    5.  DNA characters must be mapped to integers in $\\{1, 2, 3, 4\\}$.\n    6.  The core of the decision procedure must use the combinatorial principle: for any two strings of length $\\ell$ with Hamming distance $\\le k$, a partition of the strings into $k+1$ contiguous blocks guarantees at least one pair of corresponding blocks is identical.\n    7.  For a given $\\ell$, the $k+1$ blocks are defined as follows: let $q = \\lfloor \\frac{\\ell}{k+1} \\rfloor$ and $r = \\ell \\pmod{k+1}$. The first $r$ blocks have size $q+1$, and the remaining blocks have size $q$.\n    8.  The decision procedure must, for each block index $b \\in \\{0, 1, \\dots, k\\}$, index all length-$\\ell$ substrings of $S$ by the hash of their $b$-th block. Then, for each length-$\\ell$ substring of $T$, it uses the hash of its $b$-th block to find candidate matches from $S$ and verifies them by computing the full Hamming distance.\n\n-   **Test Suite**:\n    -   Case $1$: $S = $ \"AAAAAA\", $T = $ \"AAAATA\", $k = 1$.\n    -   Case $2$: $S = $ \"ACGT\", $T = $ \"ACGT\", $k = 0$.\n    -   Case $3$: $S = $ \"AAAA\", $T = $ \"TTTT\", $k = 0$.\n    -   Case $4$: $S = $ \"ACGTCGTA\", $T = $ \"ACGACGTA\", $k = 2$.\n    -   Case $5$: $S = $ \"\", $T = $ \"ACGT\", $k = 1$.\n    -   Case $6$: $S = $ \"ACGTACGT\", $T = $ \"ACGTTTGT\", $k = 1$.\n\n-   **Output Format**: A single line containing a comma-separated list of integer results enclosed in square brackets.\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientific or Factual Unsoundness**: The problem is scientifically sound. It is based on established concepts in computer science (string algorithms, hashing) and mathematics (combinatorics, number theory). The core combinatorial principle is a direct application of the Pigeonhole Principle: if there are at most $k$ mismatches (pigeons) distributed among $k+1$ blocks (pigeonholes), at least one block must contain zero pigeons (mismatches).\n-   **Non-Formalizable or Irrelevant**: The problem is highly formal and directly relevant to the design and analysis of algorithms for string matching.\n-   **Incomplete or Contradictory Setup**: The problem is exceptionally well-specified, providing not just the objective but also a detailed blueprint for the required algorithm. There are no contradictions.\n-   **Unrealistic or Infeasible**: The problem is a standard computational task with no reference to physically impossible conditions.\n-   **Ill-Posed or Poorly Structured**: The problem is well-posed. The existence of a solution is guaranteed (a length of $0$ is always possible), and the detailed algorithmic prescription leads to a unique, deterministic result.\n-   **Pseudo-Profound, Trivial, or Tautological**: The problem is non-trivial, requiring careful implementation of several complex components (binary search, double rolling hash, block-based candidate generation). It represents a standard and elegant algorithmic technique.\n-   **Outside Scientific Verifiability**: The correctness of the algorithm can be mathematically reasoned, and its output is verifiable for any given input.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. It is self-contained, scientifically grounded, and rigorously defined. I will proceed to provide a complete solution.\n\n### Principle-Based Design and Solution\n\nThe problem asks for the design of an algorithm to find the longest $k$-mismatch common substring length, $\\ell_{\\max}$, between two strings $S$ and $T$. The approach is structured as an optimization problem solved by searching over a decision problem.\n\n**1. Overall Strategy: Binary Search on the Answer**\n\nLet's define a boolean function, `check($\\ell$)`, which is true if there exists a pair of substrings of length $\\ell$ from $S$ and $T$ with a Hamming distance of at most $k$, and false otherwise. This function is monotonic: if `check($\\ell$)` is true, then `check($\\ell'$)` is also true for any $1 \\le \\ell' < \\ell$. This is because any prefix of a valid pair of substrings of length $\\ell$ will form a valid pair of substrings of length $\\ell'$, as the Hamming distance cannot increase.\n\nThis monotonicity allows us to use binary search to efficiently find the maximum $\\ell$ for which `check($\\ell$)` is true. The search space for $\\ell$ is the interval $[0, \\min(|S|,|T|)]$. The binary search will repeatedly probe this space, converging on the optimal value $\\ell_{\\max}$.\n\n**2. The Decision Procedure: `check($\\ell$)`**\n\nThe core of the algorithm is the `check($\\ell$)` function. A naive implementation would compare every substring of length $\\ell$ from $S$ with every such substring from $T$, an approach with complexity prohibitive for large strings. The problem specifies a more sophisticated method based on a key combinatorial insight.\n\n**Combinatorial Principle**: If two strings $U$ and $V$ of length $\\ell$ have a Hamming distance $d_H(U, V) \\le k$, and we partition both strings into $k+1$ contiguous blocks, then by the Pigeonhole Principle, at least one corresponding pair of blocks must be identical. If every block pair had at least one mismatch, the total number of mismatches would be at least $k+1$, contradicting the premise.\n\nThis principle allows us to transform the problem from finding an approximate match over the full length $\\ell$ to finding at least one exact match over a smaller block. Exact matching can be solved very efficiently with hashing.\n\n**Block Partitioning**: For a given length $\\ell$ and mismatch tolerance $k$, we partition the length into $B = k+1$ blocks. The base block size is $q = \\lfloor \\frac{\\ell}{B} \\rfloor$, and the number of larger blocks is $r = \\ell \\pmod{B}$. The first $r$ blocks are given size $q+1$, and the remaining $B-r$ blocks are given size $q$. We can precompute the starting offsets of these $k+1$ blocks.\n\n**3. Efficient Exact Matching with Rolling Hashing**\n\nTo efficiently find identical blocks, we use a polynomial rolling hash.\n\n**Polynomial Rolling Hash**: A string $W = w_0w_1\\dots w_{m-1}$ is mapped to an integer hash value. First, each character $w_i$ is mapped to a positive integer $c(w_i)$ from the set $\\{1, 2, 3, 4\\}$. The hash is then defined as:\n$$ H(W) = \\left( \\sum_{i=0}^{m-1} c(w_i) \\cdot p^{m-1-i} \\right) \\pmod{M} $$\nwhere $p$ is a prime base larger than the alphabet size, and $M$ is a large prime modulus.\n\n**Double Hashing**: To drastically reduce the probability of hash collisions (two different strings producing the same hash), we compute two independent hashes for each string using different bases ($p_1, p_2$) and moduli ($M_1, M_2$). A string is then represented by a pair of hashes $(h_1, h_2)$.\n\n**$O(1)$ Substring Hashing**: We can compute the hash of any substring in $O(1)$ time after an initial $O(|S|)$ precomputation. We precompute two arrays for each hash function:\n1.  Powers of the base: $P[i] = p^i \\pmod M$.\n2.  Prefix hashes: $H_{\\text{pref}}[i] = H(S[0:i-1])$.\n\nThe hash of a substring $S[i:j]$ (of length $len = j-i+1$) is then:\n$$ H(S[i:j]) = \\left( H_{\\text{pref}}[j+1] - H_{\\text{pref}}[i] \\cdot P[\\text{len}] \\right) \\pmod M $$\nCare must be taken with negative results from subtraction by adding $M$ before the final modulo.\n\n**4. The `check($\\ell$)` Algorithm**\n\nWith these tools, the algorithm for `check($\\ell$)` is as follows (assuming $\\ell > 0$):\n\n1.  Determine the start- and end-points for each of the $k+1$ blocks within a string of length $\\ell$.\n2.  For each block index $b \\in \\{0, 1, \\dots, k\\}$:\n    a. Create a hash map, `hash_to_indices`, to store hashes of the $b$-th block of substrings from $S$.\n    b. Iterate through all starting positions $i$ from $0$ to $|S|-\\ell$. For each substring $S[i:i+\\ell]$:\n        i.  Determine the slice corresponding to the $b$-th block: $S[i+\\text{start}_b : i+\\text{end}_b]$.\n        ii. Compute its double hash $(h_1, h_2)$ in $O(1)$ time using the precomputed tables.\n        iii. Store the starting index of the full substring: `hash_to_indices[(h_1, h_2)].append(i)`.\n    c. Iterate through all starting positions $j$ from $0$ to $|T|-\\ell$. For each substring $T[j:j+\\ell]$:\n        i.  Determine the slice corresponding to the $b$-th block: $T[j+\\text{start}_b : j+\\text{end}_b]$.\n        ii. Compute its double hash $(h'_1, h'_2)$.\n        iii. If this hash $(h'_1, h'_2)$ exists as a key in `hash_to_indices`, we have found candidate pairs.\n        iv. For each candidate starting index $i_{\\text{cand}}$ associated with this hash:\n            -   Perform a direct character-by-character comparison to compute $d_H(S[i_{\\text{cand}}:i_{\\text{cand}}+\\ell], T[j:j+\\ell])$.\n            -   If the distance is $\\le k$, a valid pair has been found. Return `True`.\n3.  If the outer loop over all $k+1$ blocks completes without finding a match, then no such pair of substrings of length $\\ell$ exists. Return `False`.\n\nThis procedure is guaranteed to be correct due to the Pigeonhole Principle. Its efficiency comes from reducing a large number of expensive $O(\\ell)$ approximate comparisons to a much smaller number of $O(1)$ hash computations and lookups, followed by a few $O(\\ell)$ verifications only for strong candidates.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        (\"AAAAAA\", \"AAAATA\", 1),\n        # Case 2\n        (\"ACGT\", \"ACGT\", 0),\n        # Case 3\n        (\"AAAA\", \"TTTT\", 0),\n        # Case 4\n        (\"ACGTCGTA\", \"ACGACGTA\", 2),\n        # Case 5\n        (\"\", \"ACGT\", 1),\n        # Case 6\n        (\"ACGTACGT\", \"ACGTTTGT\", 1),\n    ]\n\n    results = []\n    for S, T, k in test_cases:\n        result = find_longest_k_mismatch_substring(S, T, k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_longest_k_mismatch_substring(S, T, k):\n    \"\"\"\n    Finds the longest k-mismatch common substring length using binary search.\n    \"\"\"\n    n, m = len(S), len(T)\n    if n == 0 or m == 0:\n        return 0\n\n    checker = KMismatchChecker(S, T, k)\n    \n    ans = 0\n    low, high = 1, min(n, m)\n    \n    while low <= high:\n        ell = low + (high - low) // 2\n        if checker.check(ell):\n            ans = ell\n            low = ell + 1\n        else:\n            high = ell - 1\n            \n    return ans\n\nclass KMismatchChecker:\n    \"\"\"\n    A class to check for the existence of a k-mismatch substring of a given length ell.\n    It precomputes rolling hash structures for efficiency.\n    \"\"\"\n    CHAR_MAP = {'A': 1, 'C': 2, 'G': 3, 'T': 4}\n    P1, M1 = 313, 10**9 + 7\n    P2, M2 = 353, 10**9 + 9\n\n    class RollingHasher:\n        def __init__(self, text, p, m, char_map):\n            self.n = len(text)\n            self.p = p\n            self.m = m\n            \n            self.prefix_hash = np.zeros(self.n + 1, dtype=np.int64)\n            self.powers = np.ones(self.n + 1, dtype=np.int64)\n            \n            for i in range(self.n):\n                self.prefix_hash[i+1] = (self.prefix_hash[i] * self.p + char_map[text[i]]) % self.m\n            \n            for i in range(self.n):\n                self.powers[i+1] = (self.powers[i] * self.p) % self.m\n\n        def get_hash(self, i, length):\n            \"\"\"Computes hash of substring of given length starting at i.\"\"\"\n            h = (self.prefix_hash[i + length] - self.prefix_hash[i] * self.powers[length]) % self.m\n            return h + self.m if h < 0 else h\n\n    def __init__(self, S, T, k):\n        self.S = S\n        self.T = T\n        self.k = k\n        self.n = len(S)\n        self.m = len(T)\n        \n        self.s_hasher1 = self.RollingHasher(S, self.P1, self.M1, self.CHAR_MAP)\n        self.s_hasher2 = self.RollingHasher(S, self.P2, self.M2, self.CHAR_MAP)\n        self.t_hasher1 = self.RollingHasher(T, self.P1, self.M1, self.CHAR_MAP)\n        self.t_hasher2 = self.RollingHasher(T, self.P2, self.M2, self.CHAR_MAP)\n\n    @staticmethod\n    def _get_block_structure(ell, k):\n        \"\"\"Calculates the start and length of each of the k+1 blocks.\"\"\"\n        if ell == 0:\n            return [], []\n        num_blocks = k + 1\n        base_len = ell // num_blocks\n        rem = ell % num_blocks\n        \n        block_starts = [0] * (num_blocks + 1)\n        block_lengths = [0] * num_blocks\n\n        for i in range(num_blocks):\n            length = base_len + 1 if i < rem else base_len\n            block_lengths[i] = length\n            block_starts[i+1] = block_starts[i] + length\n            \n        return block_starts, block_lengths\n\n    def _hamming_distance(self, s1_start, s2_start, length):\n        \"\"\"Calculates Hamming distance between substrings of S and T.\"\"\"\n        dist = 0\n        for i in range(length):\n            if self.S[s1_start + i] != self.T[s2_start + i]:\n                dist += 1\n        return dist\n\n    def check(self, ell):\n        \"\"\"\n        Checks if a k-mismatch common substring of length ell exists.\n        \"\"\"\n        if ell == 0:\n            return True\n        if ell > min(self.n, self.m):\n            return False\n\n        block_starts, block_lengths = self._get_block_structure(ell, self.k)\n        \n        for b in range(self.k + 1):\n            s_block_hashes = defaultdict(list)\n            block_start_offset = block_starts[b]\n            block_len = block_lengths[b]\n            \n            if block_len == 0:\n                continue\n                \n            # Index substrings of S by their b-th block's hash\n            for i in range(self.n - ell + 1):\n                h1 = self.s_hasher1.get_hash(i + block_start_offset, block_len)\n                h2 = self.s_hasher2.get_hash(i + block_start_offset, block_len)\n                s_block_hashes[(h1, h2)].append(i)\n\n            if not s_block_hashes:\n                continue\n\n            # Check substrings of T against the index\n            for j in range(self.m - ell + 1):\n                h1 = self.t_hasher1.get_hash(j + block_start_offset, block_len)\n                h2 = self.t_hasher2.get_hash(j + block_start_offset, block_len)\n\n                if (h1, h2) in s_block_hashes:\n                    for s_start_idx in s_block_hashes[(h1, h2)]:\n                        # Candidate found, verify with Hamming distance\n                        if self._hamming_distance(s_start_idx, j, ell) <= self.k:\n                            return True\n                            \n        return False\n\n# Execute the solver\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3261679"}]}