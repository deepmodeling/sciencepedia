{"hands_on_practices": [{"introduction": "The adjacency matrix is more than just a static table of connections; it is a powerful computational tool whose algebraic properties can reveal deep structural information about a graph. This practice challenges you to use matrix multiplication to count the number of triangles ($3$-cycles) in a graph. You will see how concepts from linear algebra connect to graph theory by understanding that the entries of matrix powers correspond to the number of walks of a certain length between vertices [@problem_id:3236897].", "problem": "Let $G$ be a simple, undirected graph on vertex set $V=\\{1,2,3,4,5,6\\}$, represented by the following adjacency list (each line lists the open neighborhood of the indicated vertex):\n- $1:\\ \\{2,3\\}$\n- $2:\\ \\{1,3,5,6\\}$\n- $3:\\ \\{1,2,4,5\\}$\n- $4:\\ \\{3,5\\}$\n- $5:\\ \\{2,3,4\\}$\n- $6:\\ \\{2\\}$\n\nLet $A$ denote the adjacency matrix of $G$ under the vertex ordering $(1,2,3,4,5,6)$, so that\n$$\nA \\;=\\;\n\\begin{pmatrix}\n0 & 1 & 1 & 0 & 0 & 0\\\\\n1 & 0 & 1 & 0 & 1 & 1\\\\\n1 & 1 & 0 & 1 & 1 & 0\\\\\n0 & 0 & 1 & 0 & 1 & 0\\\\\n0 & 1 & 1 & 1 & 0 & 0\\\\\n0 & 1 & 0 & 0 & 0 & 0\n\\end{pmatrix}.\n$$\nUsing only the core definitions of graph adjacency matrix multiplication and the trace operation, first justify a relationship between $\\operatorname{tr}(A^3)$ and the number of distinct $3$-cycles (triangles) in $G$. Then evaluate $\\operatorname{tr}(A^3)$ for the specific $A$ given above and, from your justified relationship, determine the number of triangles in $G$. Provide your final answer as a single integer. Do not directly count triangles by inspection; your computation must proceed by analyzing $\\operatorname{tr}(A^3)$ from first principles. No rounding is required.", "solution": "The problem is well-posed and validated as sound within the domain of graph theory and linear algebra. The given adjacency matrix $A$ correctly represents the graph $G$ described by the adjacency list for the specified vertex ordering. We proceed with the solution.\n\nFirst, we must establish the relationship between the trace of the cubic power of the adjacency matrix, $\\operatorname{tr}(A^3)$, and the number of $3$-cycles (triangles) in the graph $G$. Let $G$ be a simple, undirected graph with $n$ vertices, and let $A$ be its adjacency matrix, where $A_{ij} = 1$ if vertices $i$ and $j$ are adjacent, and $A_{ij} = 0$ otherwise. Since the graph is simple, there are no self-loops, so $A_{ii} = 0$ for all $i$.\n\nThe entries of the powers of the adjacency matrix have a well-known combinatorial interpretation. Specifically, the entry $(A^k)_{ij}$ of the matrix $A^k$ represents the number of distinct walks of length $k$ from vertex $i$ to vertex $j$.\n\nLet's consider the matrix $A^2$. An entry $(A^2)_{ij}$ is given by the matrix product definition:\n$$ (A^2)_{ij} = \\sum_{k=1}^{n} A_{ik} A_{kj} $$\nA term $A_{ik} A_{kj}$ is $1$ if and only if $A_{ik}=1$ and $A_{kj}=1$, which means there is an edge from $i$ to $k$ and an edge from $k$ to $j$. Thus, $(A^2)_{ij}$ counts the number of paths of length $2$ from $i$ to $j$ passing through an intermediate vertex $k$.\n\nNow, let's consider the diagonal entries of $A^3$. The entry $(A^3)_{ii}$ is given by:\n$$ (A^3)_{ii} = \\sum_{j=1}^{n} \\sum_{k=1}^{n} A_{ij} A_{jk} A_{ki} $$\nA term $A_{ij} A_{jk} A_{ki}$ is non-zero (equal to $1$) if and only if $A_{ij}=1$, $A_{jk}=1$, and $A_{ki}=1$. This corresponds to the existence of edges $(i, j)$, $(j, k)$, and $(k, i)$. This sequence of edges forms a closed walk of length $3$ starting and ending at vertex $i$: $i \\rightarrow j \\rightarrow k \\rightarrow i$.\n\nSince the graph $G$ is simple, it has no self-loops, meaning $A_{vv}=0$ for any vertex $v$.\nThis implies that in any non-zero term $A_{ij} A_{jk} A_{ki}$, we cannot have $i=j$, $j=k$, or $k=i$. For instance, if $j=k$, the term becomes $A_{ij} A_{jj} A_{ji}$. Since $A_{jj}=0$, this term is zero. Therefore, for a non-zero contribution, the vertices $i$, $j$, and $k$ must be distinct.\n\nA closed walk of length $3$ involving three distinct vertices $i, j, k$ defines a triangle with vertex set $\\{i, j, k\\}$. Thus, $(A^3)_{ii}$ counts the number of such walks that start and end at $i$. For a given triangle $\\{i, j, k\\}$, there are two such walks starting at $i$: the walk $i \\rightarrow j \\rightarrow k \\rightarrow i$ and the walk $i \\rightarrow k \\rightarrow j \\rightarrow i$. Both are counted in the sum for $(A^3)_{ii}$. Therefore, $(A^3)_{ii}$ is equal to twice the number of triangles containing vertex $i$.\n\nThe trace of $A^3$ is the sum of its diagonal entries:\n$$ \\operatorname{tr}(A^3) = \\sum_{i=1}^{n} (A^3)_{ii} $$\nThis sum counts all closed walks of length $3$ in the graph. Let $T$ be the total number of distinct triangles in $G$. Each triangle, say with vertices $\\{v_1, v_2, v_3\\}$, contributes to the diagonal entries $(A^3)_{v_1 v_1}$, $(A^3)_{v_2 v_2}$, and $(A^3)_{v_3 v_3}$. As established, it is counted twice for each of its three vertices. The walks associated with this triangle are:\n\\begin{itemize}\n    \\item $v_1 \\rightarrow v_2 \\rightarrow v_3 \\rightarrow v_1$ (counted in $(A^3)_{v_1 v_1}$)\n    \\item $v_1 \\rightarrow v_3 \\rightarrow v_2 \\rightarrow v_1$ (counted in $(A^3)_{v_1 v_1}$)\n    \\item $v_2 \\rightarrow v_1 \\rightarrow v_3 \\rightarrow v_2$ (counted in $(A^3)_{v_2 v_2}$)\n    \\item $v_2 \\rightarrow v_3 \\rightarrow v_1 \\rightarrow v_2$ (counted in $(A^3)_{v_2 v_2}$)\n    \\item $v_3 \\rightarrow v_1 \\rightarrow v_2 \\rightarrow v_3$ (counted in $(A^3)_{v_3 v_3}$)\n    \\item $v_3 \\rightarrow v_2 \\rightarrow v_1 \\rightarrow v_3$ (counted in $(A^3)_{v_3 v_3}$)\n\\end{itemize}\nTherefore, each triangle is counted a total of $3 \\times 2 = 6$ times in the sum for $\\operatorname{tr}(A^3)$. This gives the relationship:\n$$ \\operatorname{tr}(A^3) = 6T $$\nThus, the number of triangles is $T = \\frac{\\operatorname{tr}(A^3)}{6}$.\n\nNow we perform the calculation for the given graph $G$. The adjacency matrix is:\n$$ A \\;=\\; \\begin{pmatrix} 0 & 1 & 1 & 0 & 0 & 0\\\\ 1 & 0 & 1 & 0 & 1 & 1\\\\ 1 & 1 & 0 & 1 & 1 & 0\\\\ 0 & 0 & 1 & 0 & 1 & 0\\\\ 0 & 1 & 1 & 1 & 0 & 0\\\\ 0 & 1 & 0 & 0 & 0 & 0 \\end{pmatrix} $$\nFirst, we compute $A^2 = A \\times A$:\n$$ A^2 \\;=\\; \\begin{pmatrix} 0 & 1 & 1 & 0 & 0 & 0\\\\ 1 & 0 & 1 & 0 & 1 & 1\\\\ 1 & 1 & 0 & 1 & 1 & 0\\\\ 0 & 0 & 1 & 0 & 1 & 0\\\\ 0 & 1 & 1 & 1 & 0 & 0\\\\ 0 & 1 & 0 & 0 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 1 & 1 & 0 & 0 & 0\\\\ 1 & 0 & 1 & 0 & 1 & 1\\\\ 1 & 1 & 0 & 1 & 1 & 0\\\\ 0 & 0 & 1 & 0 & 1 & 0\\\\ 0 & 1 & 1 & 1 & 0 & 0\\\\ 0 & 1 & 0 & 0 & 0 & 0 \\end{pmatrix} \\;=\\; \\begin{pmatrix} 2 & 1 & 1 & 1 & 2 & 1\\\\ 1 & 4 & 2 & 2 & 1 & 0\\\\ 1 & 2 & 4 & 1 & 2 & 1\\\\ 1 & 2 & 1 & 2 & 1 & 0\\\\ 2 & 1 & 2 & 1 & 3 & 1\\\\ 1 & 0 & 1 & 0 & 1 & 1 \\end{pmatrix} $$\nNext, we need the diagonal entries of $A^3$. We find them by calculating $(A^3)_{ii} = \\sum_{k=1}^6 A_{ik} (A^2)_{ki}$. Since $A^2$ is symmetric, $(A^2)_{ki} = (A^2)_{ik}$.\n$$ (A^3)_{11} = A_{12}(A^2)_{21} + A_{13}(A^2)_{31} = 1 \\cdot 1 + 1 \\cdot 1 = 2 $$\n$$ (A^3)_{22} = A_{21}(A^2)_{12} + A_{23}(A^2)_{32} + A_{25}(A^2)_{52} + A_{26}(A^2)_{62} = 1 \\cdot 1 + 1 \\cdot 2 + 1 \\cdot 1 + 1 \\cdot 0 = 4 $$\n$$ (A^3)_{33} = A_{31}(A^2)_{13} + A_{32}(A^2)_{23} + A_{34}(A^2)_{43} + A_{35}(A^2)_{53} = 1 \\cdot 1 + 1 \\cdot 2 + 1 \\cdot 1 + 1 \\cdot 2 = 6 $$\n$$ (A^3)_{44} = A_{43}(A^2)_{34} + A_{45}(A^2)_{54} = 1 \\cdot 1 + 1 \\cdot 1 = 2 $$\n$$ (A^3)_{55} = A_{52}(A^2)_{25} + A_{53}(A^2)_{35} + A_{54}(A^2)_{45} = 1 \\cdot 1 + 1 \\cdot 2 + 1 \\cdot 1 = 4 $$\n$$ (A^3)_{66} = A_{62}(A^2)_{26} = 1 \\cdot 0 = 0 $$\nThe trace of $A^3$ is the sum of these diagonal entries:\n$$ \\operatorname{tr}(A^3) = (A^3)_{11} + (A^3)_{22} + (A^3)_{33} + (A^3)_{44} + (A^3)_{55} + (A^3)_{66} $$\n$$ \\operatorname{tr}(A^3) = 2 + 4 + 6 + 2 + 4 + 0 = 18 $$\nFinally, we use the derived relationship to find the number of triangles $T$:\n$$ T = \\frac{\\operatorname{tr}(A^3)}{6} = \\frac{18}{6} = 3 $$\nThe number of distinct triangles in the graph $G$ is $3$.", "answer": "$$\\boxed{3}$$", "id": "3236897"}, {"introduction": "Choosing the right data structure is a fundamental skill in algorithm design, and this is especially true for graphs where performance can vary dramatically. This exercise provides a hands-on comparison of two primary graph representations: the adjacency list and the adjacency matrix. You will implement the graph reversal operation—flipping the direction of all edges—using both structures, allowing you to directly analyze the implementation complexity and computational costs associated with each [@problem_id:3236874].", "problem": "Consider a finite directed multigraph defined as an ordered pair $(V,E)$ where $V$ is a finite set of vertices labeled by consecutive integers starting at $0$, and $E$ is a multiset of ordered pairs $(u,v)$ with $u \\in V$ and $v \\in V$, representing directed edges from $u$ to $v$. No self-loops are present, i.e., no edge of the form $(u,u)$ appears. The goal is to formalize and implement the graph reversal operation: for every edge $(u,v) \\in E$, produce the reversed edge $(v,u)$, and study how this operation is performed when the graph is represented as an adjacency list versus an adjacency matrix, and cross-validate the result using the incidence matrix.\n\nFoundational base definitions:\n1. An adjacency list is a collection of lists $\\{L_u\\}_{u \\in V}$, where the list $L_u$ contains one entry $v$ for each edge $(u,v) \\in E$; multiple entries are present for parallel edges.\n2. An adjacency matrix is a matrix $A \\in \\mathbb{N}^{|V| \\times |V|}$ with entry $A[u,v]$ equal to the number of edges from $u$ to $v$.\n3. An incidence matrix for a directed multigraph is a matrix $M \\in \\{-1,0,1\\}^{|V| \\times |E|}$ with one column per edge. For an edge $e = (u,v)$, the column indexed by $e$ has $M[u,e] = -1$, $M[v,e] = +1$, and $M[w,e] = 0$ for all $w \\in V$ with $w \\notin \\{u,v\\}$. No self-loops are included, so each column has exactly one $-1$ and one $+1$.\n4. The graph reversal operator $\\mathcal{R}$ maps a graph $(V,E)$ to $(V,E')$, where $E' = \\{(v,u) : (u,v) \\in E\\}$.\n\nYou must implement algorithms that compute the reversed graph when input is:\n- The adjacency list $\\{L_u\\}_{u \\in V}$.\n- The adjacency matrix $A$.\nAdditionally, verify the correctness via the incidence matrix $M$ by constructing $M$ from the adjacency list, reversing by negating all its entries, and then reconstructing an adjacency matrix from the reversed incidence matrix. For algorithmic comparison, define a simple operation-counting model:\n- For adjacency list reversal, count $1$ operation for initializing each empty list $L^{\\mathrm{rev}}_u$ for $u \\in V$, and $1$ operation for each appended edge during reversal. The total count should be $|V| + |E|$.\n- For adjacency matrix reversal, construct a new matrix $A^{\\mathrm{rev}}$ of the same size and set every entry by $A^{\\mathrm{rev}}[i,j] := A[j,i]$. Count $1$ operation for each assignment to $A^{\\mathrm{rev}}[i,j]$, yielding $|V|^2$ operations.\n- For incidence matrix reversal, given $M$ of size $|V| \\times |E|$, set $M^{\\mathrm{rev}}[i,e] := -M[i,e]$ for all entries and count $1$ operation per entry assignment, yielding $|V|\\cdot|E|$ operations.\n\nTest suite:\nYou must implement the following parameterized test cases, each given by its number of vertices $|V|$ and an adjacency list. For each case, you should derive the corresponding adjacency matrix according to the definition above.\n\nCase $1$: $|V| = 5$. Adjacency list $= \\left[ [1,1], [3], [0,4], [2], [1] \\right]$.\nCase $2$: $|V| = 4$. Adjacency list $= \\left[ [], [], [], [] \\right]$.\nCase $3$: $|V| = 2$. Adjacency list $= \\left[ [1], [] \\right]$.\nCase $4$: $|V| = 4$. Adjacency list $= \\left[ [1,2,3], [0,2,3], [0,1,3], [0,1,2] \\right]$.\nCase $5$: $|V| = 6$. Adjacency list $= \\left[ [5,5], [2], [1], [], [2], [] \\right]$.\n\nFor each test case, compute:\n1. The reversed adjacency list and convert it to a matrix $A^{\\mathrm{rev}}_{\\text{list}}$.\n2. The reversed adjacency matrix $A^{\\mathrm{rev}}_{\\text{matrix}}$ by transposition from the original adjacency matrix.\n3. The incidence matrix $M$ constructed from the original adjacency list, the reversed incidence matrix $M^{\\mathrm{rev}}$ by negating all entries, and the adjacency matrix $A^{\\mathrm{rev}}_{\\text{inc}}$ reconstructed from $M^{\\mathrm{rev}}$.\n\nThen, report for each test case:\n- A boolean that is true if $A^{\\mathrm{rev}}_{\\text{list}}$ equals $A^{\\mathrm{rev}}_{\\text{matrix}}$.\n- A boolean that is true if $A^{\\mathrm{rev}}_{\\text{list}}$ equals $A^{\\mathrm{rev}}_{\\text{inc}}$.\n- An integer equal to the operation count for adjacency list reversal.\n- An integer equal to the operation count for adjacency matrix reversal.\n- An integer equal to the operation count for incidence matrix reversal.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and must be a list in the order specified above. For example, the final output should look like $\\left[ [b_1,b'_1,c^{\\mathrm{list}}_1,c^{\\mathrm{mat}}_1,c^{\\mathrm{inc}}_1], [b_2,b'_2,c^{\\mathrm{list}}_2,c^{\\mathrm{mat}}_2,c^{\\mathrm{inc}}_2], \\ldots \\right]$, where $b_i$ and $b'_i$ are booleans and $c^{\\mathrm{list}}_i$, $c^{\\mathrm{mat}}_i$, $c^{\\mathrm{inc}}_i$ are integers.", "solution": "The problem is valid. It is a well-posed and scientifically grounded exercise in graph theory and data structures, concerning the representation and transformation of directed multigraphs. The provided definitions for adjacency lists, adjacency matrices, and incidence matrices are standard, and the relationships between them under the graph reversal operation are correctly stated. The task is to implement and verify these relationships algorithmically.\n\nA directed multigraph is given as $G=(V,E)$, where $V=\\{0, 1, \\dots, |V|-1\\}$ is the set of vertices and $E$ is a multiset of directed edges $(u,v)$, with $u,v \\in V$ and $u \\neq v$. The graph reversal operation, denoted by $\\mathcal{R}$, transforms $G$ into a new graph $G^{\\mathrm{rev}} = (V, E^{\\mathrm{rev}})$, where $E^{\\mathrm{rev}} = \\{ (v,u) : (u,v) \\in E \\}$. We will formalize the procedure for computing $G^{\\mathrm{rev}}$ for three different data structures representing the graph.\n\nFirst, let's establish the foundational representations for a given graph $G=(V,E)$.\n- The adjacency list representation is a collection of lists, $\\{L_u\\}_{u \\in V}$, where each list $L_u$ contains an entry for vertex $v$ for every edge $(u,v) \\in E$. The number of occurrences of $v$ in $L_u$ equals the number of parallel edges from $u$ to $v$.\n- The adjacency matrix $A$ is a $|V| \\times |V|$ matrix of natural numbers $\\mathbb{N}$, where the entry $A[u,v]$ denotes the multiplicity of the edge $(u,v)$, i.e., the number of edges from vertex $u$ to vertex $v$.\n- The incidence matrix $M$ is a $|V| \\times |E|$ matrix with entries in $\\{-1, 0, 1\\}$. Each column corresponds to a unique edge in $E$. For an edge $e = (u,v)$, its corresponding column has $M[u,e] = -1$, $M[v,e] = 1$, and all other entries are $0$.\n\nThe task requires implementing and comparing three methods for obtaining the reversed graph, based on these representations.\n\n**1. Reversal via Adjacency List**\n\nThe reversal operation is performed by directly applying its definition. Given the adjacency list $\\{L_u\\}_{u \\in V}$ for graph $G$, we construct the adjacency list $\\{L^{\\mathrm{rev}}_v\\}_{v \\in V}$ for the reversed graph $G^{\\mathrm{rev}}$.\n\nThe algorithm proceeds as follows:\n1. Initialize $|V|$ empty lists, $L^{\\mathrm{rev}}_0, L^{\\mathrm{rev}}_1, \\dots, L^{\\mathrm{rev}}_{|V|-1}$. This step corresponds to $|V|$ operations according to the problem's counting model.\n2. Iterate through each vertex $u \\in V$.\n3. For each vertex $v$ appearing in the list $L_u$, which signifies an edge $(u,v) \\in E$:\n   a. The corresponding reversed edge is $(v,u)$.\n   b. Therefore, append the vertex $u$ to the list $L^{\\mathrm{rev}}_v$. This step corresponds to $1$ operation per edge.\n4. The total operation count is the sum of operations from both steps, which is $|V| + |E|$, where $|E| = \\sum_{u \\in V} |L_u|$ is the total number of edges.\n\nFinally, the resulting adjacency list $\\{L^{\\mathrm{rev}}_v\\}$ is converted into an adjacency matrix $A^{\\mathrm{rev}}_{\\text{list}}$ for comparison, where $A^{\\mathrm{rev}}_{\\text{list}}[i,j]$ is the count of occurrences of $j$ in the list $L^{\\mathrm{rev}}_i$.\n\n**2. Reversal via Adjacency Matrix**\n\nThe relationship between the adjacency matrix $A$ of a graph $G$ and the adjacency matrix $A^{\\mathrm{rev}}$ of its reversal $G^{\\mathrm{rev}}$ is one of transposition. Let $A[u,v]$ be the number of edges from $u$ to $v$. In the reversed graph, the number of edges from $v$ to $u$, which is $A^{\\mathrm{rev}}[v,u]$, must be equal to the original number of edges from $u$ to $v$. Thus, $A^{\\mathrm{rev}}[v,u] = A[u,v]$ for all $u,v \\in V$. This is the definition of the matrix transpose, i.e., $A^{\\mathrm{rev}} = A^T$.\n\nThe algorithm is:\n1. Construct the original adjacency matrix $A$ from the input adjacency list.\n2. Create a new $|V| \\times |V|$ matrix, $A^{\\mathrm{rev}}_{\\text{matrix}}$.\n3. For each pair of indices $(i,j)$ where $i, j \\in V$:\n   a. Assign $A^{\\mathrm{rev}}_{\\text{matrix}}[i,j] = A[j,i]$. This is a single assignment operation.\n4. The total operation count is the total number of entries in the matrix, which is $|V| \\times |V| = |V|^2$.\n\n**3. Verification via Incidence Matrix**\n\nThis method validates the reversal operation through the incidence matrix representation. It involves three steps: constructing the incidence matrix $M$ for the original graph, reversing it to get $M^{\\mathrm{rev}}$, and reconstructing an adjacency matrix $A^{\\mathrm{rev}}_{\\text{inc}}$ from $M^{\\mathrm{rev}}$.\n\nThe algebraic principle is that reversing an edge $(u,v)$ amounts to swapping the roles of source and destination. In the defined incidence matrix, this corresponds to negating the column associated with that edge. For an edge $e=(u,v)$, its column has entries $M[u,e] = -1$ and $M[v,e] = 1$. The reversed edge $e^{\\mathrm{rev}} = (v,u)$ would have an incidence column with entries $M^{\\mathrm{rev}}[v,e^{\\mathrm{rev}}] = -1$ and $M^{\\mathrm{rev}}[u,e^{\\mathrm{rev}}] = 1$. This new column is precisely the negative of the original column. Thus, the incidence matrix of the reversed graph is the negative of the original incidence matrix: $M^{\\mathrm{rev}} = -M$.\n\nThe algorithm is as follows:\n1. **Construction of M**: From the input adjacency list $\\{L_u\\}$, construct the $|V| \\times |E|$ incidence matrix $M$. This is done by iterating through all edges, and for each edge $e_k = (u,v)$, setting the $k$-th column of $M$ to have $M[u,k] = -1$ and $M[v,k] = 1$.\n2. **Reversal of M**: Create a new matrix $M^{\\mathrm{rev}}$ by negating every entry of $M$: $M^{\\mathrm{rev}}[i,k] = -M[i,k]$ for all $i,k$. The operation count for this step is the number of entries in the matrix, which is $|V| \\cdot |E|$.\n3. **Reconstruction of A**: Reconstruct the adjacency matrix $A^{\\mathrm{rev}}_{\\text{inc}}$ from $M^{\\mathrm{rev}}$. For each column $k$ of $M^{\\mathrm{rev}}$, find the row indices $i$ and $j$ such that $M^{\\mathrm{rev}}[i,k] = -1$ (the new source) and $M^{\\mathrm{rev}}[j,k] = 1$ (the new destination). This corresponds to an edge $(i,j)$ in the reversed graph. Increment the count $A^{\\mathrm{rev}}_{\\text{inc}}[i,j]$.\n\nThe successful completion of this process and the verification that $A^{\\mathrm{rev}}_{\\text{list}} = A^{\\mathrm{rev}}_{\\text{matrix}} = A^{\\mathrm{rev}}_{\\text{inc}}$ demonstrates the consistency of these fundamental graph-theoretic transformations across different representations. The operation counts provide a simplified metric for comparing the computational cost of these algorithms, highlighting that the optimal choice of data structure depends on the graph's density and the specific operations to be performed.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef adj_list_to_adj_matrix(adj_list, num_vertices):\n    \"\"\"Converts an adjacency list to an adjacency matrix.\"\"\"\n    adj_matrix = np.zeros((num_vertices, num_vertices), dtype=int)\n    for u, neighbors in enumerate(adj_list):\n        for v in neighbors:\n            adj_matrix[u, v] += 1\n    return adj_matrix\n\ndef adj_list_to_inc_matrix(adj_list, num_vertices, num_edges):\n    \"\"\"Converts an adjacency list to an incidence matrix.\"\"\"\n    if num_edges == 0:\n        return np.zeros((num_vertices, 0), dtype=int)\n    inc_matrix = np.zeros((num_vertices, num_edges), dtype=int)\n    edge_idx = 0\n    for u, neighbors in enumerate(adj_list):\n        for v in neighbors:\n            inc_matrix[u, edge_idx] = -1\n            inc_matrix[v, edge_idx] = 1\n            edge_idx += 1\n    return inc_matrix\n\ndef inc_matrix_to_adj_matrix(inc_matrix, num_vertices, num_edges):\n    \"\"\"Converts an incidence matrix to an adjacency matrix.\"\"\"\n    adj_matrix = np.zeros((num_vertices, num_vertices), dtype=int)\n    for e in range(num_edges):\n        col = inc_matrix[:, e]\n        # Find source (u) and destination (v)\n        # Using np.where returns arrays of indices.\n        u_indices = np.where(col == -1)[0]\n        v_indices = np.where(col == 1)[0]\n        if u_indices.size > 0 and v_indices.size > 0:\n            u = u_indices[0]\n            v = v_indices[0]\n            adj_matrix[u, v] += 1\n    return adj_matrix\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and compute results.\n    \"\"\"\n    test_cases = [\n        (5, [[1, 1], [3], [0, 4], [2], [1]]),\n        (4, [[], [], [], []]),\n        (2, [[1], []]),\n        (4, [[1, 2, 3], [0, 2, 3], [0, 1, 3], [0, 1, 2]]),\n        (6, [[5, 5], [2], [1], [], [2], []])\n    ]\n\n    results = []\n\n    for num_vertices, adj_list in test_cases:\n        V = num_vertices\n        E = sum(len(neighbors) for neighbors in adj_list)\n\n        # 1. Adjacency List Reversal\n        rev_adj_list = [[] for _ in range(V)]\n        for u, neighbors in enumerate(adj_list):\n            for v in neighbors:\n                rev_adj_list[v].append(u)\n        \n        A_rev_list = adj_list_to_adj_matrix(rev_adj_list, V)\n        cost_list = V + E\n        \n        # 2. Adjacency Matrix Reversal\n        A_orig = adj_list_to_adj_matrix(adj_list, V)\n        A_rev_matrix = A_orig.T\n        cost_matrix = V * V\n\n        # 3. Incidence Matrix Verification\n        M_orig = adj_list_to_inc_matrix(adj_list, V, E)\n        M_rev = -M_orig\n        A_rev_inc = inc_matrix_to_adj_matrix(M_rev, V, E)\n        cost_inc = V * E\n\n        # Comparisons\n        eq_list_matrix = np.array_equal(A_rev_list, A_rev_matrix)\n        eq_list_inc = np.array_equal(A_rev_list, A_rev_inc)\n\n        results.append([\n            eq_list_matrix,\n            eq_list_inc,\n            cost_list,\n            cost_matrix,\n            cost_inc\n        ])\n\n    # Final print statement in the exact required format.\n    # The default str() for a list includes spaces, which is standard.\n    # The template 'print(f\"[{','.join(map(str, results))}]\")' ensures there are no spaces\n    # between the outer list elements, which is a subtle but important detail.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3236874"}, {"introduction": "An adjacency matrix provides constant-time access to check for any specific edge, but how do we efficiently solve problems involving a graph's global properties? This practice challenges you to move beyond brute-force solutions by designing a clever algorithm to find a \"sink\" vertex in $O(n)$ time, a significant improvement over the naive $O(n^2)$ approach. Successfully solving this problem requires you to think critically about how to eliminate candidates and exploit the structure of the adjacency matrix representation [@problem_id:3236899].", "problem": "You are given a directed graph represented solely by its adjacency matrix. A directed graph has a vertex set $V$ with $|V| = n$, labeled $0,1,\\dots,n-1$. Its adjacency matrix is an $n \\times n$ matrix $A$ over $\\{0,1\\}$ where $A[i][j] = 1$ if and only if there is a directed edge from vertex $i$ to vertex $j$, and $A[i][j] = 0$ otherwise. Assume the graph is simple and directed: there are no self-loops and no multi-edges, so $A[i][i] = 0$ for all $i$. A sink vertex is a vertex $s \\in V$ such that its out-degree is $0$ and its in-degree is $n-1$. Equivalently, in the adjacency matrix, the entire row $s$ is all zeros, and the column $s$ has ones in all positions except possibly at the diagonal entry, which is zero in this setting.\n\nFrom the core definitions above, design a program that determines, using only the adjacency matrix representation, whether a sink vertex exists and, if it exists, returns its index. Your program must operate in time $O(n)$, where $n = |V|$, and it must not convert the adjacency matrix into another representation such as an adjacency list or an incidence matrix. If there is no sink vertex, return $-1$. For the special boundary case $n = 0$, return $-1$.\n\nYour program must process the following fixed test suite of adjacency matrices (each matrix is a list of lists of integers in $\\{0,1\\}$), and produce one integer result per matrix:\n\n- Test case $1$ ($n = 5$): a graph with a sink at index $3$.\n  Matrix:\n  [\n    [$0$,$1$,$0$,$1$,$0$],\n    [$0$,$0$,$1$,$1$,$0$],\n    [$1$,$0$,$0$,$1$,$0$],\n    [$0$,$0$,$0$,$0$,$0$],\n    [$0$,$1$,$0$,$1$,$0$]\n  ]\n\n- Test case $2$ ($n = 4$): a directed cycle; no sink exists.\n  Matrix:\n  [\n    [$0$,$1$,$0$,$0$],\n    [$0$,$0$,$1$,$0$],\n    [$0$,$0$,$0$,$1$],\n    [$1$,$0$,$0$,$0$]\n  ]\n\n- Test case $3$ ($n = 1$): a single-vertex graph; the unique vertex is a sink.\n  Matrix:\n  [\n    [$0$]\n  ]\n\n- Test case $4$ ($n = 0$): the empty graph; by convention return $-1$.\n  Matrix:\n  [ ]\n\n- Test case $5$ ($n = 4$): a graph with a sink at index $0$.\n  Matrix:\n  [\n    [$0$,$0$,$0$,$0$],\n    [$1$,$0$,$1$,$0$],\n    [$1$,$0$,$0$,$1$],\n    [$1$,$1$,$0$,$0$]\n  ]\n\n- Test case $6$ ($n = 4$): a graph with a vertex of out-degree $0$ at index $2$ but missing one incoming edge; no sink exists.\n  Matrix:\n  [\n    [$0$,$1$,$0$,$0$],\n    [$0$,$0$,$1$,$0$],\n    [$0$,$0$,$0$,$0$],\n    [$1$,$0$,$1$,$0$]\n  ]\n\nOutput specification: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases $1$ through $6$. For example, an output line of the form [$r_1$,$r_2$,$r_3$,$r_4$,$r_5$,$r_6$] where each $r_i$ is an integer result for test case $i$.", "solution": "The problem has been validated and is determined to be a valid, well-posed problem in the domain of graph algorithms. All provided information is self-contained, consistent, and scientifically grounded in established principles of graph theory. The definitions of a directed graph, its adjacency matrix representation, and a sink vertex are standard. The problem asks for an algorithm with a specific time complexity constraint, $O(n)$, which elevates it from a trivial search to a proper algorithmic challenge.\n\nThe task is to find a sink vertex in a directed graph represented by its $n \\times n$ adjacency matrix $A$. A sink vertex $s$ is defined as a vertex with an in-degree of $n-1$ and an out-degree of $0$. In terms of the adjacency matrix $A$, this means that for a sink $s$:\n1.  The row $s$ must be all zeros: $A[s][j] = 0$ for all $j \\in \\{0, 1, \\dots, n-1\\}$. This corresponds to an out-degree of $0$.\n2.  The column $s$ must be all ones, except at the diagonal: $A[j][s] = 1$ for all $j \\in \\{0, 1, \\dots, n-1\\}$ where $j \\neq s$. This corresponds to an in-degree of $n-1$. The problem specifies that $A[i][i] = 0$ for all $i$, which is consistent with this definition.\n\nA critical property of a sink vertex is its uniqueness. If a graph contains a sink vertex, it can contain only one. Suppose, for the sake of contradiction, that there are two distinct sink vertices, $s_1$ and $s_2$. Since $s_1$ is a sink, its in-degree must be $n-1$, which implies there must be a directed edge from every other vertex to $s_1$. Thus, there must be an edge $(s_2, s_1)$. However, since $s_2$ is also a sink, its out-degree must be $0$, which means there can be no outgoing edges from $s_2$. This contradicts the existence of the edge $(s_2, s_1)$. Therefore, a graph can have at most one sink.\n\nA naive approach to finding the sink would be to iterate through each vertex $i \\in \\{0, 1, \\dots, n-1\\}$ and verify if it satisfies the sink conditions. Verifying a single vertex requires inspecting its entire row and column, which takes $O(n)$ time. Repeating this for all $n$ vertices results in a total time complexity of $O(n^2)$. The problem demands a more efficient algorithm with a time complexity of $O(n)$.\n\nAn $O(n)$ solution can be achieved using a two-phase process: candidate elimination followed by verification.\n\n**Phase 1: Candidate Elimination**\n\nThe core principle of this phase is to discard vertices that cannot be the sink in $O(n)$ time, leaving at most one candidate. We can iterate through the vertices and progressively eliminate non-sink candidates.\n\n1.  We begin by postulating that vertex $0$ is a potential sink. Let us maintain a variable, `candidate`, initialized to $0$.\n2.  We then iterate through the remaining vertices, $i = 1, 2, \\dots, n-1$. In each step, we compare the current `candidate` with vertex $i$.\n3.  We inspect the matrix entry $A[\\text{candidate}][i]$.\n    -   If $A[\\text{candidate}][i] = 1$, it signifies an edge from `candidate` to $i$. A sink vertex cannot have any outgoing edges (out-degree must be $0$). Therefore, the current `candidate` is definitively not a sink. We eliminate it from consideration. In this event, vertex $i$ becomes our new `candidate`. While $i$ itself may not be a sink, it has successfully 'disproven' the previous candidate, and it is the next vertex to consider.\n    -   If $A[\\text{candidate}][i] = 0$, it signifies the absence of an edge from `candidate` to $i$. A sink vertex must have an incoming edge from every other vertex (in-degree must be $n-1$). The lack of an edge from `candidate` to $i$ proves that vertex $i$ cannot be a sink. Therefore, we can eliminate $i$ from consideration. The current `candidate` survives this test and remains the `candidate`.\n\nThis elimination process performs exactly $n-1$ comparisons, one for each $i$ from $1$ to $n-1$. After the loop completes, we are left with a single vertex that has survived the elimination process. This is our sole candidate for being a sink. This phase has a time complexity of $O(n)$.\n\n**Phase 2: Candidate Verification**\n\nThe elimination phase guarantees that if a sink exists, it must be the final `candidate`. However, it does not guarantee that this `candidate` is actually a sink. The candidate might have been chosen simply because it eliminated all other contenders, even if it does not satisfy the sink properties itself. Thus, a final verification step is mandatory.\n\nLet the final candidate be $c$. We must verify that $c$ satisfies both conditions for being a sink:\n1.  **Zero Out-Degree**: Iterate through column indices $j = 0, 1, \\dots, n-1$. If we find any $j$ such that $A[c][j] = 1$, then vertex $c$ has a non-zero out-degree and cannot be a sink.\n2.  **In-Degree of $n-1$**: Iterate through row indices $i = 0, 1, \\dots, n-1$. If we find any $i \\neq c$ such that $A[i][c] = 0$, then vertex $c$ is missing an incoming edge and its in-degree is less than $n-1$. It cannot be a sink. We also must confirm $A[c][c] = 0$, which is guaranteed by the problem statement.\n\nIf the candidate $c$ passes both verification checks, it is the unique sink, and its index $c$ is returned. If it fails either check, it implies that no vertex in the graph satisfies the sink conditions, and therefore no sink exists. In this case, $-1$ is returned.\n\nThe overall algorithm consists of the $O(n)$ elimination phase and the $O(n)$ verification phase, yielding a total time complexity of $O(n) + O(n) = O(n)$, which satisfies the problem's constraint. The algorithm uses a constant amount of extra space for the candidate and loop indices, so its space complexity is $O(1)$. Special cases for $n=0$ and $n=1$ must be handled. For $n=0$, there are no vertices, so no sink; we return $-1$. For $n=1$, the single vertex $0$ has an in-degree of $1-1=0$ and an out-degree of $0$, so it is a sink.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sink-finding problem for a predefined test suite of graphs.\n    \"\"\"\n    # Define the test cases from the problem statement as numpy arrays.\n    test_cases = [\n        # Test case 1 (n=5, sink at 3)\n        np.array([\n            [0, 1, 0, 1, 0],\n            [0, 0, 1, 1, 0],\n            [1, 0, 0, 1, 0],\n            [0, 0, 0, 0, 0],\n            [0, 1, 0, 1, 0]\n        ]),\n        # Test case 2 (n=4, no sink)\n        np.array([\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]\n        ]),\n        # Test case 3 (n=1, sink at 0)\n        np.array([\n            [0]\n        ]),\n        # Test case 4 (n=0, no sink)\n        np.array([]).reshape(0,0),\n        # Test case 5 (n=4, sink at 0)\n        np.array([\n            [0, 0, 0, 0],\n            [1, 0, 1, 0],\n            [1, 0, 0, 1],\n            [1, 1, 0, 0]\n        ]),\n        # Test case 6 (n=4, no sink)\n        np.array([\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 0],\n            [1, 0, 1, 0]\n        ])\n    ]\n\n    results = []\n    \n    for A in test_cases:\n        n = A.shape[0]\n\n        # Handle boundary case for an empty graph (n=0).\n        if n == 0:\n            results.append(-1)\n            continue\n        \n        # Phase 1: Candidate Elimination in O(n)\n        # We find a single candidate that could be a sink.\n        candidate = 0\n        for i in range(1, n):\n            # If A[candidate][i] is 1, there's an edge candidate -> i.\n            # This means 'candidate' cannot be a sink (out-degree > 0).\n            # The new candidate becomes i.\n            # If A[candidate][i] is 0, there is no edge candidate -> i.\n            # This means 'i' cannot be a sink (in-degree < n-1).\n            # The current 'candidate' survives.\n            if A[candidate, i] == 1:\n                candidate = i\n        \n        # Phase 2: Candidate Verification in O(n)\n        # Check if the final candidate is indeed a sink.\n        is_sink = True\n        for i in range(n):\n            # A sink must have an out-degree of 0.\n            # Check if the candidate's row has any 1s.\n            if A[candidate, i] == 1:\n                is_sink = False\n                break\n            \n            # A sink must have an in-degree of n-1.\n            # Check if the candidate's column has any 0s (for i != candidate).\n            # The A[i][i] == 0 condition is given.\n            if i != candidate and A[i, candidate] == 0:\n                is_sink = False\n                break\n        \n        if is_sink:\n            results.append(candidate)\n        else:\n            results.append(-1)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3236899"}]}