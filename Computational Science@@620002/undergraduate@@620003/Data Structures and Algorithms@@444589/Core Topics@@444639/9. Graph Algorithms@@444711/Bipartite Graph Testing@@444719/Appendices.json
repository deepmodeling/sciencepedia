{"hands_on_practices": [{"introduction": "While a general 2-coloring algorithm can test any graph for bipartiteness, skilled programmers know that analyzing a problem's specific structure can unlock far more efficient solutions. This practice challenges you to exploit the properties of a simple, yet important, graph structure: a tree augmented with a single extra edge [@problem_id:3216784]. By recognizing that such a graph contains exactly one cycle, you can reduce the problem of bipartiteness to simply checking the parity of that cycle's length.", "problem": "Let an undirected, simple, connected graph $G=(V,E)$ be obtained by taking a tree $T$ on $|V|=n$ vertices (so $|E(T)|=n-1$) and adding exactly $1$ extra edge between two distinct, non-adjacent vertices of $T$. Such a graph has exactly $1$ simple cycle. A graph is called bipartite if its vertex set can be partitioned into two disjoint parts $A$ and $B$ such that every edge has one endpoint in $A$ and the other endpoint in $B$. You are to design and implement a linear-time algorithm, expressed and justified from first principles, to decide whether $G$ is bipartite. The algorithm must not rely on any shortcut formulas presented in this problem statement and must be derived from foundational definitions and well-tested facts.\n\nFundamental base requirements:\n- Use only the core definitions of graphs, trees, paths, and cycles, and the well-tested fact that a graph is bipartite if and only if it contains no odd-length cycle.\n- The design must start from these bases, explain why they imply the desired test for $G$ (a tree plus $1$ extra edge), and show how to implement the decision in time $O(n)$.\n\nProgram specification:\n- Vertices are labeled by integers $0,1,2,\\dots,n-1$.\n- Each test case is specified by:\n  - An integer $n$ (number of vertices).\n  - A list of $n-1$ undirected tree edges forming $T$.\n  - A single undirected extra edge $(u,v)$ whose endpoints are distinct and non-adjacent in $T$.\n- Your program must implement a linear-time algorithm that, for each test case, returns a boolean indicating whether the resulting graph $G$ is bipartite.\n\nTest suite:\nProvide the results for the following test cases (all edges are undirected):\n- Test case $1$: $n=3$, tree edges $\\{(0,1),(1,2)\\}$, extra edge $(0,2)$.\n- Test case $2$: $n=4$, tree edges $\\{(0,1),(1,2),(2,3)\\}$, extra edge $(0,3)$.\n- Test case $3$: $n=5$, tree edges $\\{(0,1),(0,2),(0,3),(0,4)\\}$, extra edge $(1,2)$.\n- Test case $4$: $n=6$, tree edges $\\{(0,1),(1,2),(2,3),(3,4),(4,5)\\}$, extra edge $(1,4)$.\n- Test case $5$: $n=7$, tree edges $\\{(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)\\}$, extra edge $(3,2)$.\n- Test case $6$: $n=8$, tree edges $\\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7)\\}$, extra edge $(2,6)$.\n\nOutput format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3]$), where each $r_i$ is the boolean result for test case $i$ in the order given above.\n\nThere are no physical quantities involved, so no units are required. Angles do not appear, so no angle units are required. Percentages do not appear, so there is no special instruction for percentage formatting.", "solution": "The validity of the problem statement is established. It is a well-posed problem in algorithmic graph theory, grounded in standard definitions and theorems, and free of any scientific or logical flaws.\n\nThe solution is derived from first principles, beginning with the fundamental characterization of bipartite graphs.\n\n**1. Foundational Principle of Bipartite Graphs**\n\nA cornerstone theorem in graph theory states that an undirected graph is bipartite if and only if it contains no simple cycles of odd length. A graph is bipartite if its vertices can be partitioned into two disjoint sets, say $A$ and $B$, such that every edge connects a vertex in $A$ to one in $B$. If a cycle has an odd number of vertices, say $v_1, v_2, \\dots, v_k, v_1$ with $k$ being odd, any attempt to $2$-color it will fail. If $v_1$ is in set $A$, then $v_2$ must be in $B$, $v_3$ in $A$, and so on. For any vertex $v_i$, its color will be determined by the parity of its index $i$. The vertex $v_k$ will have the same color as $v_1$ if $k-1$ is even, which is true if $k$ is odd. However, the edge $(v_k, v_1)$ connects them, creating a conflict. Conversely, if a graph has no odd cycles, a $2$-coloring can always be found.\n\n**2. Structural Analysis of the Graph $G$**\n\nThe problem specifies that the graph $G=(V,E)$ is constructed by taking a tree $T$ on $n$ vertices and adding a single extra edge $(u,v)$ between two distinct, non-adjacent vertices of $T$. We analyze the cyclic structure that results from this construction.\n\n- A tree is, by definition, a connected graph that contains no cycles.\n- A fundamental property of a tree is that for any two vertices, say $u$ and $v$, there exists a unique simple path between them. Let us denote this path in $T$ as $P_{uv}$.\n- The graph $G$ is formed by the union of the tree $T$ and the edge $(u,v)$. The edge set of $G$ is $E(G) = E(T) \\cup \\{(u,v)\\}$.\n- The addition of the edge $(u,v)$ creates a cycle $C$ composed of the path $P_{uv}$ and the edge $(u,v)$ itself.\n- This cycle $C$ is the *only* simple cycle in $G$. To see why, assume there exists another simple cycle $C'$. If $C'$ does not use the edge $(u,v)$, then all its edges must belong to the tree $T$. This would imply that $T$ contains a cycle, which contradicts the definition of a tree. Therefore, any cycle in $G$ must involve the edge $(u,v)$. Since $P_{uv}$ is the unique path between $u$ and $v$ in $T$, any cycle containing $(u,v)$ must be formed by traversing $P_{uv}$ and then returning via the edge $(u,v)$. Thus, $C$ is the unique simple cycle in $G$.\n\n**3. Derivation of a Specific Test for Bipartiteness**\n\nCombining the foundational principle with the structural analysis of $G$, we can formulate a direct test for bipartiteness.\n\n- According to the principle, $G$ is bipartite if and only if it has no odd-length cycles.\n- Since we have established that $G$ has exactly one simple cycle, $C$, the condition for bipartiteness simplifies: $G$ is bipartite if and only if the length of this unique cycle $C$ is even.\n\n**4. Calculation of the Cycle Length**\n\nThe length of a cycle, denoted $|C|$, is the number of edges it contains. The cycle $C$ is formed by the edges of the path $P_{uv}$ and the single edge $(u,v)$. Therefore, its length is:\n$$|C| = |P_{uv}| + 1$$\nHere, $|P_{uv}|$ is the number of edges on the unique path between $u$ and $v$ in the tree $T$. This is, by definition, the distance between $u$ and $v$ in $T$, denoted $\\text{dist}_T(u,v)$.\nSo, the cycle length is:\n$$|C| = \\text{dist}_T(u,v) + 1$$\nThe condition that $G$ is bipartite is that $|C|$ must be even. This implies that $\\text{dist}_T(u,v) + 1$ must be even, which is true if and only if $\\text{dist}_T(u,v)$ is odd.\n\n**5. The Linear-Time Algorithm**\n\nThe problem is now reduced to computing the distance between vertices $u$ and $v$ in the tree $T$ and checking if this distance is odd. This can be accomplished efficiently in linear time.\n\n- **Algorithm**:\n    1.  Construct an adjacency list representation of the tree $T$ from the given $n-1$ edges. This requires iterating through the edges once and takes $O(n)$ time.\n    2.  Perform a Breadth-First Search (BFS) starting from vertex $u$ to find the distance to all other vertices in the tree. We use a queue and a distance array, `distances`, of size $n$, initialized with a value (e.g., $-1$) indicating that vertices have not yet been visited.\n    3.  Initialize the queue with $u$ and set `distances[u] = 0`.\n    4.  While the queue is not empty, dequeue a vertex, say `curr`. For each neighbor `next` of `curr`, if `distances[next]` is $-1$, update it to `distances[curr] + 1` and enqueue `next`.\n    5.  The BFS explores each vertex and edge of the tree exactly once. When the algorithm finishes (or, as an optimization, as soon as `v` is reached), the value `distances[v]` will hold $\\text{dist}_T(u,v)$.\n    6.  The final step is to check if `distances[v]` is odd. If it is, the graph $G$ is bipartite; otherwise, it is not.\n\n- **Complexity Analysis**:\n    - The adjacency list construction is $O(n)$.\n    - The BFS on a tree (a connected graph with $n$ vertices and $n-1$ edges) has a time complexity of $O(|V|+|E(T)|) = O(n + (n-1)) = O(n)$.\n    - The final check is an $O(1)$ operation.\n    - Thus, the entire algorithm runs in $O(n)$, satisfying the problem's linear-time requirement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport collections\n\ndef is_bipartite_for_tree_plus_one_edge(n, tree_edges, extra_edge):\n    \"\"\"\n    Determines if a graph formed by a tree plus one edge is bipartite.\n\n    The method is based on the principle that a graph is bipartite if and only if\n    it contains no odd-length cycles. The given graph structure has exactly one\n    cycle, formed by the extra edge (u, v) and the unique path between u and v\n    in the tree. The graph is bipartite if and only if this cycle has an even\n    length.\n\n    Cycle length = dist_T(u, v) + 1.\n    For the cycle length to be even, dist_T(u, v) must be odd.\n\n    This function calculates the distance between u and v in the tree using BFS\n    and checks if it is odd.\n\n    Args:\n        n (int): The number of vertices.\n        tree_edges (list of tuple): A list of n-1 edges forming the tree.\n        extra_edge (tuple): The single edge added to the tree.\n\n    Returns:\n        bool: True if the graph is bipartite, False otherwise.\n    \"\"\"\n    u, v = extra_edge\n\n    # Step 1: Build the adjacency list for the tree T.\n    # Complexity: O(n) as there are n-1 edges.\n    adj = [[] for _ in range(n)]\n    for a, b in tree_edges:\n        adj[a].append(b)\n        adj[b].append(a)\n\n    # Step 2: Use Breadth-First Search (BFS) to find the distance from u to v.\n    # Complexity: O(n) for a tree with n vertices.\n    queue = collections.deque([u])\n    # distances array tracks distance from u and also serves as a visited set.\n    distances = [-1] * n\n    distances[u] = 0\n\n    while queue:\n        current_node = queue.popleft()\n\n        # If we have reached the target vertex v, we have found the distance.\n        if current_node == v:\n            break\n\n        for neighbor in adj[current_node]:\n            # If the neighbor has not been visited yet\n            if distances[neighbor] == -1:\n                distances[neighbor] = distances[current_node] + 1\n                queue.append(neighbor)\n    \n    # Step 3: Check the parity of the distance.\n    # The graph is bipartite iff the unique cycle is of even length.\n    # Cycle length = dist(u,v) + 1.\n    # Length is even iff dist(u,v) is odd.\n    distance_uv = distances[v]\n    \n    # This case should not be reached for a valid connected tree input.\n    if distance_uv == -1:\n        return False\n\n    return distance_uv % 2 == 1\n\ndef solve():\n    \"\"\"\n    Runs the algorithm on the predefined test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1: n=3, tree edges {(0,1),(1,2)}, extra edge (0,2).\n        # Path 0-1-2. dist(0,2) = 2. Cycle length = 3 (odd). Not bipartite.\n        (3, [(0, 1), (1, 2)], (0, 2)),\n        # Test case 2: n=4, tree edges {(0,1),(1,2),(2,3)}, extra edge (0,3).\n        # Path 0-1-2-3. dist(0,3) = 3. Cycle length = 4 (even). Bipartite.\n        (4, [(0, 1), (1, 2), (2, 3)], (0, 3)),\n        # Test case 3: n=5, tree edges {(0,1),(0,2),(0,3),(0,4)}, extra edge (1,2).\n        # Path 1-0-2. dist(1,2) = 2. Cycle length = 3 (odd). Not bipartite.\n        (5, [(0, 1), (0, 2), (0, 3), (0, 4)], (1, 2)),\n        # Test case 4: n=6, tree edges {(0,1),(1,2),(2,3),(3,4),(4,5)}, extra edge (1,4).\n        # Path 1-2-3-4. dist(1,4) = 3. Cycle length = 4 (even). Bipartite.\n        (6, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)], (1, 4)),\n        # Test case 5: n=7, tree edges {(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)}, extra edge (3,2).\n        # Path 3-1-0-2. dist(3,2) = 3. Cycle length = 4 (even). Bipartite.\n        (7, [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6)], (3, 2)),\n        # Test case 6: n=8, tree edges {(0,1),..,(6,7)}, extra edge (2,6).\n        # Path 2-3-4-5-6. dist(2,6) = 4. Cycle length = 5 (odd). Not bipartite.\n        (8, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)], (2, 6)),\n    ]\n\n    results = []\n    for n, tree_edges, extra_edge in test_cases:\n        result = is_bipartite_for_tree_plus_one_edge(n, tree_edges, extra_edge)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3216784"}, {"introduction": "A boolean `False` from a bipartiteness test tells us a graph has an odd cycle, but it doesn't show us where. This exercise takes you a step further, asking you to not just detect non-bipartiteness, but to provide concrete proof by finding a shortest odd-length cycle [@problem_id:3216863]. This task requires a deeper understanding of the Breadth-First Search (BFS) algorithm, using its level-by-level traversal to identify the specific edge that closes the first, and thus shortest, odd cycle from a given source.", "problem": "You are given the task of designing and implementing a program that, for each finite, undirected, simple graph $G = (V,E)$ with vertex labels in $\\{0,1,2,\\dots,n-1\\}$, computes a shortest odd-length cycle if one exists, and otherwise reports that no such cycle exists. The solution must be fully derived from first principles, starting from definitions, and must be implemented as a complete program that runs without any external input. You must use the following fundamental base for your derivation: the definition of a bipartite graph, the definition of graph distance, and properties of Breadth-First Search (BFS stands for Breadth-First Search). No other shortcut formulas may be used or cited.\n\nDefinitions required for the derivation:\n- A graph $G$ is bipartite if and only if $V$ can be partitioned into two disjoint sets $X$ and $Y$ such that every edge connects a vertex in $X$ to a vertex in $Y$. Equivalently, $G$ is bipartite if and only if it contains no cycle of odd length.\n- The graph distance $\\operatorname{dist}_G(u,v)$ between vertices $u$ and $v$ is the length (number of edges) of a shortest path between $u$ and $v$.\n- In an undirected, unweighted graph, a Breadth-First Search (BFS) from a source $s$ discovers vertices in nondecreasing order of $\\operatorname{dist}_G(s,\\cdot)$, assigns to each discovered vertex $v$ a parent $\\operatorname{parent}(v)$ on some shortest path, and induces a layering by distance levels. In such a BFS layering, any edge connects vertices either on the same level or on adjacent levels.\n\nYour program must implement an algorithm grounded in these principles that finds a shortest odd-length cycle in $G$ if it exists, by examining the BFS structure and using it to reconstruct a cycle when appropriate. The algorithm must also be correct for disconnected graphs by considering every vertex as a potential BFS source.\n\nNormalization requirement for outputting cycles:\n- A cycle is represented by a sequence of distinct vertices $[c_0,c_1,\\dots,c_{k-1}]$ with implicit edges $\\{(c_i,c_{(i+1) \\bmod k}) \\mid i \\in \\{0,1,\\dots,k-1\\}\\}$. The first and last vertices in the list must not repeat.\n- Normalize any cycle as follows: rotate the sequence so that the smallest vertex label appears first; then choose the orientation (clockwise or counterclockwise) that yields the lexicographically smaller sequence. Among multiple cycles of minimum odd length, select the lexicographically smallest normalized cycle.\n\nIf no odd-length cycle exists, output the empty list `[]` for that graph.\n\nYour program must use the following test suite of graphs, each specified by an integer $n$ and a set of undirected edges $E$ given as pairs $(u,v)$ with $0 \\le u,v < n$:\n\n- Test case $1$ (a triangle):\n  - $n = 3$\n  - $E = \\{(0,1),(1,2),(2,0)\\}$\n\n- Test case $2$ (a $4$-cycle, bipartite):\n  - $n = 4$\n  - $E = \\{(0,1),(1,2),(2,3),(3,0)\\}$\n\n- Test case $3$ (two triangles sharing a vertex):\n  - $n = 5$\n  - $E = \\{(0,1),(1,2),(2,0),(0,3),(3,4),(4,0)\\}$\n\n- Test case $4$ (disconnected: a $4$-cycle and a $5$-cycle):\n  - $n = 9$\n  - $E = \\{(0,1),(1,2),(2,3),(3,0),(4,5),(5,6),(6,7),(7,8),(8,4)\\}$\n\n- Test case $5$ (no edges):\n  - $n = 3$\n  - $E = \\{\\}$\n\n- Test case $6$ (a $5$-cycle with extra tree attachments):\n  - $n = 7$\n  - $E = \\{(0,1),(1,2),(2,3),(3,4),(4,0),(2,5),(5,6)\\}$\n\nOutput specification:\n- For each test case in the order listed above, output either the empty list `[]` if the graph has no odd-length cycle, or the normalized vertex list $[c_0,c_1,\\dots,c_{k-1}]$ of a shortest odd-length cycle as defined above.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces anywhere; for example, an output with three results might look like $[[0,1,2],[],[4,5,6,7,8]]$.\n\nNo physical units or angles are involved in this problem. All numeric values and indices must be treated as pure integers. The final answers for each test case must be a list of integers or an empty list, and the overall output must be a single list aggregating these results as specified above. The program must not read from standard input and must run as-is.", "solution": "The user-provided problem statement has been validated and is determined to be a valid, well-posed problem in the domain of graph algorithms. It is scientifically grounded in established principles of graph theory, provides all necessary definitions and data, and is free of contradictions or ambiguities.\n\n### Derivation from First Principles\n\nThe problem asks for the shortest odd-length cycle in a given simple, undirected graph $G=(V, E)$. The derivation of the algorithm will be based on the fundamental principles provided: the definition of a bipartite graph, properties of graph distance, and the behavior of Breadth-First Search (BFS).\n\n1.  **Odd Cycles and Bipartite Graphs**: A key principle is that a graph is bipartite if and only if it contains no odd-length cycles. This means that the existence of an odd-length cycle is synonymous with the graph (or one of its connected components) being non-bipartite. An algorithm that tests for bipartiteness can therefore be adapted to find an odd-length cycle.\n\n2.  **Bipartite Testing with BFS**: A standard method to test for bipartiteness in a connected component is to perform a 2-coloring of its vertices using BFS. Starting from a source vertex $s$, we can assign it to a set $X$ (or color $0$). All its neighbors are assigned to a set $Y$ (color $1$). The neighbors of those vertices are assigned back to set $X$ (color $0$), and so on. In a BFS traversal starting from $s$, a vertex $v$ is at a distance $\\operatorname{dist}_G(s,v)$ from $s$. The coloring rule is equivalent to assigning color $\\operatorname{dist}_G(s,v) \\bmod 2$ to each vertex $v$.\n\n3.  **Detecting an Odd Cycle**: The 2-coloring fails, and thus an odd cycle is detected, if we find an edge $(u,v)$ connecting two vertices that have been assigned the same color. In the context of a BFS from a source $s$, this means $\\operatorname{dist}_G(s,u) \\bmod 2 = \\operatorname{dist}_G(s,v) \\bmod 2$.\n\n4.  **BFS Layering and Cycle Formation**: The problem statement specifies a crucial property of BFS on unweighted graphs: any edge connects vertices on the same level or on adjacent levels. That is, for any edge $(u,v)$, the distances from a BFS source $s$ must satisfy $|\\operatorname{dist}_G(s,u) - \\operatorname{dist}_G(s,v)| \\le 1$.\n    -   If $\\operatorname{dist}_G(s,u)$ and $\\operatorname{dist}_G(s,v)$ have different parity, their difference must be $1$. This corresponds to an edge between adjacent levels (e.g., $\\operatorname{dist}_G(s,u) = d$ and $\\operatorname{dist}_G(s,v) = d-1$), which is consistent with a bipartite structure.\n    -   If $\\operatorname{dist}_G(s,u)$ and $\\operatorname{dist}_G(s,v)$ have the same parity, their difference must be $0$. This implies $\\operatorname{dist}_G(s,u) = \\operatorname{dist}_G(s,v) = d$. The edge $(u,v)$ connects two vertices at the same distance level $d$ from $s$. This configuration necessarily forms an odd-length cycle.\n\n5.  **Finding the Shortest Odd Cycle**: The cycle formed by the edge $(u,v)$ and the shortest paths in the BFS tree from $s$ to $u$ and from $s$ to $v$ has a length of $\\operatorname{dist}_G(s,u) + \\operatorname{dist}_G(s,v) + 1$. Since $\\operatorname{dist}_G(s,u) = \\operatorname{dist}_G(s,v) = d$, the cycle length is $2d+1$, which is odd. It is a known result that the shortest odd cycle in a graph can be found by computing $\\min_s \\min_{(u,v)} (\\operatorname{dist}_G(s,u) + \\operatorname{dist}_G(s,v) + 1)$ over all vertices $s$ and edges $(u,v)$ where $\\operatorname{dist}_G(s,u) = \\operatorname{dist}_G(s,v)$. By running a BFS from every vertex $s \\in V$, we are guaranteed to find the source vertex and edge that produces the shortest possible odd cycle. For a disconnected graph, this ensures each component is checked.\n\n6.  **Algorithmic Procedure**:\n    a. Initialize the minimum odd cycle length found so far to infinity, and the best cycle found to an empty list.\n    b. Iterate through each vertex $s \\in \\{0, 1, \\dots, n-1\\}$ to use as a source for a BFS. This ensures all connected components are explored and the global minimum is found.\n    c. For each source $s$, perform a BFS. Maintain an array `dist` to store distances from $s$ and a `parent` array to reconstruct paths.\n    d. During the BFS, when exploring from a vertex $u$ to its neighbor $v$:\n        i. If $v$ has not been visited (`dist[v]` is uninitialized), it is a tree edge. Set `dist[v] = dist[u] + 1` and `parent[v] = u`, and add $v$ to the queue.\n        ii. If $v$ has been visited and is not the direct parent of $u$ in the BFS tree, a cycle is found. If `dist[v] == dist[u]`, this is an odd cycle of length $k = \\operatorname{dist}[u] + \\operatorname{dist}[v] + 1$.\n    e. Whenever an odd cycle is found, compare its length $k$ with the minimum length found so far. If $k$ is smaller, or if $k$ is equal and the new cycle is lexicographically smaller after normalization, update the best cycle.\n\n7.  **Cycle Reconstruction and Normalization**: When an odd cycle candidate is found with endpoints $u$ and $v$ (and source $s$), the cycle's vertices can be reconstructed by tracing back `parent` pointers from $u$ and $v$ to their lowest common ancestor (LCA) in the BFS tree. The cycle consists of the path from the LCA to $u$, the path from the LCA to $v$, and the edge $(u,v)$. The resulting vertex list must then be normalized as per the problem's rules: rotate to start with the smallest vertex label, then orient to produce the lexicographically smaller sequence.\n\nThis systematic approach, grounded in the properties of BFS and its relation to bipartiteness, correctly identifies and computes the shortest odd-length cycle as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport collections\n\ndef get_normalized_cycle(u, v, parent):\n    \"\"\"\n    Reconstructs and normalizes a cycle given its closing edge (u, v) and\n    the parent pointers from a BFS.\n    \"\"\"\n    # Trace back from u and v to find the path to the source\n    path_u, path_v = [], []\n    curr = u\n    while curr != -1:\n        path_u.append(curr)\n        curr = parent[curr]\n    curr = v\n    while curr != -1:\n        path_v.append(curr)\n        curr = parent[curr]\n\n    # Reverse paths to go from source to node\n    path_u.reverse()\n    path_v.reverse()\n\n    # Find the lowest common ancestor (LCA) by finding the last common vertex\n    # in the paths from the source.\n    lca_idx = 0\n    while (lca_idx < len(path_u) and lca_idx < len(path_v) and \n           path_u[lca_idx] == path_v[lca_idx]):\n        lca_idx += 1\n    lca_idx -= 1\n\n    # The cycle is the path from LCA to u, plus the path from v to LCA.\n    cycle = path_u[lca_idx:] + path_v[lca_idx+1:][::-1]\n\n    # Normalize the cycle\n    if not cycle:\n        return []\n    \n    # 1. Rotate so the minimum element is first.\n    min_val = min(cycle)\n    min_idx = cycle.index(min_val)\n    rotated = cycle[min_idx:] + cycle[:min_idx]\n    \n    # 2. Choose the lexicographically smaller of the two possible orientations.\n    # The second element of the reversed sequence (excluding the first element)\n    # is the last element of the original rotated sequence.\n    if len(rotated) > 1 and rotated[-1] < rotated[1]:\n        return [rotated[0]] + rotated[1:][::-1]\n    else:\n        return rotated\n\n\ndef solve():\n    \"\"\"\n    Main function to solve for all test cases.\n    \"\"\"\n    test_cases = [\n        (3, {(0, 1), (1, 2), (2, 0)}),\n        (4, {(0, 1), (1, 2), (2, 3), (3, 0)}),\n        (5, {(0, 1), (1, 2), (2, 0), (0, 3), (3, 4), (4, 0)}),\n        (9, {(0, 1), (1, 2), (2, 3), (3, 0), (4, 5), (5, 6), (6, 7), (7, 8), (8, 4)}),\n        (3, set()),\n        (7, {(0, 1), (1, 2), (2, 3), (3, 4), (4, 0), (2, 5), (5, 6)}),\n    ]\n\n    all_results = []\n\n    for n, edges in test_cases:\n        if n == 0:\n            all_results.append([])\n            continue\n        \n        adj = collections.defaultdict(list)\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        min_k = float('inf')\n        best_cycle = []\n\n        # Iterate through each vertex as a potential BFS source\n        for s in range(n):\n            dist = [-1] * n\n            parent = [-1] * n\n            q = collections.deque([s])\n            \n            dist[s] = 0\n            \n            while q:\n                u = q.popleft()\n                \n                for v in adj[u]:\n                    if v == parent[u]:\n                        continue\n                        \n                    if dist[v] == -1:  # v is unvisited (tree edge)\n                        dist[v] = dist[u] + 1\n                        parent[v] = u\n                        q.append(v)\n                    else:  # v is visited (non-tree edge), a cycle is detected\n                        # An odd cycle is found if the edge connects two vertices\n                        # at the same level in the BFS tree.\n                        if dist[v] == dist[u]:\n                            k = dist[u] + dist[v] + 1\n                            \n                            if k < min_k:\n                                min_k = k\n                                best_cycle = get_normalized_cycle(u, v, parent)\n                            elif k == min_k:\n                                current_cycle = get_normalized_cycle(u, v, parent)\n                                # Lexicographical comparison for tie-breaking\n                                if tuple(current_cycle) < tuple(best_cycle):\n                                    best_cycle = current_cycle\n        \n        all_results.append(best_cycle)\n\n    # Format the final output string according to specifications\n    result_strings = [str(res).replace(\" \", \"\") for res in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3216863"}, {"introduction": "Real-world networks are rarely static; they grow and change over time. This practice introduces the dynamic version of bipartiteness testing, where you must efficiently determine the exact moment a graph becomes non-bipartite as edges are added one by one [@problem_id:3216756]. This problem challenges you to move beyond static algorithms and implement an elegant solution using an augmented Disjoint Set Union (DSU) data structure, which tracks both connected components and their internal color relationships.", "problem": "Consider an undirected simple graph $G = (V,E)$ with vertex set $V$ and edge set $E$. Edges are added one at a time in a fixed sequence, producing a nested family of graphs $G_1, G_2, \\ldots, G_m$, where $G_t$ denotes the graph after the first $t$ edges have been added. A graph is called bipartite if there exists a partition $V = X \\cup Y$ with $X \\cap Y = \\varnothing$ such that every edge has one endpoint in $X$ and the other in $Y$. It is a well-tested fact that an undirected graph is bipartite if and only if it contains no cycle of odd length.\n\nStarting only from the core definitions above, design a program that, for each of the specified test cases, reports the earliest index $t$ in $\\{1,2,\\ldots,m\\}$ such that $G_t$ is not bipartite. If the graph remains bipartite after all $m$ edges have been added, report $0$. A self-loop, that is, an edge of the form $(u,u)$ for some $u \\in V$, immediately causes the graph to be non-bipartite because a single vertex cannot be placed in both parts of the partition simultaneously.\n\nAll graphs in the test suite are undirected, edges may repeat, and vertices are labeled by consecutive integers starting at $1$. An added edge $(u,v)$ is interpreted as placing a constraint that the labels of $u$ and $v$ must be assigned opposite colors in any valid two-coloring of the connected component containing them.\n\nThe test suite consists of the following parameter sets. Each test case is given by a vertex count $n$ and an edge sequence of length $m$, written as ordered pairs $(u,v)$ with $u,v \\in \\{1,2,\\ldots,n\\}$, processed in the order listed.\n\n- Test case $1$: $n = 6$, edges $\\big((1,2),(2,3),(3,4),(4,5),(5,6),(6,1),(1,3)\\big)$.\n- Test case $2$: $n = 5$, edges $\\big((1,2),(2,3),(3,4),(4,5)\\big)$.\n- Test case $3$: $n = 3$, edges $\\big((1,2),(2,2),(2,3)\\big)$.\n- Test case $4$: $n = 4$, edges $\\big((1,2),(2,3),(3,1),(4,1)\\big)$.\n- Test case $5$: $n = 4$, edges $\\big((1,2),(2,3),(1,2),(3,4),(4,1),(2,4)\\big)$.\n- Test case $6$: $n = 3$, edges $\\big(\\ \\big)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces, in the same order as the test suite (for example, $[r_1,r_2,\\ldots,r_6]$ where each $r_i$ is an integer as specified above).", "solution": "The problem requires the design of an algorithm to determine the earliest point in a sequence of edge additions at which a graph ceases to be bipartite. A graph $G=(V,E)$ is defined as bipartite if its vertex set $V$ can be partitioned into two disjoint sets, $X$ and $Y$, such that every edge in $E$ connects a vertex in $X$ to one in $Y$. The problem statement correctly provides the fundamental theorem: a graph is bipartite if and only if it contains no cycles of odd length. We process a sequence of $m$ edges, creating a series of graphs $G_1, G_2, \\ldots, G_m$, where $G_t$ is the graph with the first $t$ edges. We seek the smallest $t \\in \\{1, 2, \\ldots, m\\}$ for which $G_t$ is not bipartite. If all graphs in the sequence are bipartite, the result is $0$.\n\nThe core of the problem is to efficiently detect the formation of the first odd-length cycle. An edge $(u,v)$ added to an already bipartite graph $G$ will render the new graph non-bipartite if and only if this new edge closes a cycle of odd length. This occurs if and only if vertices $u$ and $v$ are already in the same connected component and the path between them in $G$ has an even length. The addition of the edge $(u,v)$ creates a cycle whose length is the even path length plus $1$, which is odd.\n\nFrom a two-coloring perspective, this means that vertices $u$ and $v$ were required to have the same color in any valid two-coloring of their connected component *before* the edge $(u,v)$ was added. The new edge imposes the constraint that they must have different colors, creating a contradiction.\n\nThis dynamic connectivity and relative coloring problem is elegantly solved using an augmented Disjoint Set Union (DSU) data structure. A standard DSU tracks the connected components of a graph. We augment it to additionally track the parity of the \"distance\" (path length) between nodes within a component, which corresponds to their color relationship in a two-coloring.\n\nOur DSU structure will consist of two primary arrays for a graph with $n$ vertices labeled $1$ through $n$:\n$1$. `parent`: An array of size $n+1$, where `parent[i]` stores the parent of node $i$ in its component's tree representation.\n$2$. `parity`: An array of size $n+1$, where `parity[i]` stores the parity (either $0$ or $1$) of the path length between node $i$ and its parent, `parent[i]`. `parity[i] = 1` implies that $i$ and `parent[i]` must have different colors, while `parity[i] = 0` implies they must have the same color. An edge naturally corresponds to a path of length $1$, so its endpoints have different colors.\n\nThe DSU operations are modified as follows:\n\n**`find(i)` Operation**: This operation finds the representative (root) of the component containing vertex $i$. It implements path compression to maintain efficiency. As the path is compressed (i.e., `parent[i]` is set to the component's root), the `parity[i]` value must be updated to store the parity of the path length from $i$ to the root. If the original path from $i$ to the root was $i \\to p_1 \\to p_2 \\to \\dots \\to \\text{root}$, the new `parity[i]` becomes the XOR sum $(\\text{parity}_{\\text{old}}[i] \\oplus \\text{parity}_{\\text{old}}[p_1] \\oplus \\dots) \\pmod 2$. A recursive implementation handles this naturally. The `find(i)` operation returns a tuple containing the root of the component and the calculated parity of the path from $i$ to that root.\n\n**`union(u, v)` Operation**: This operation processes the addition of a new edge $(u,v)$ and determines if it violates the bipartite property.\n$1$. First, we invoke `find(u)` and `find(v)` to get their respective roots and parities relative to those roots: $(\\text{root}_u, \\text{parity}_u)$ and $(\\text{root}_v, \\text{parity}_v)$.\n$2$. **Case A: Different Components ($\\text{root}_u \\neq \\text{root}_v$)**. The edge connects two previously separate components. This cannot create a cycle, so the graph remains bipartite. We merge the components, for instance, by setting `parent[root_v] = root_u`. We must then establish the parity relationship for this new link. The path from $\\text{root}_v$ to $\\text{root}_u$ now effectively traverses $\\text{root}_v \\leftarrow \\dots \\leftarrow v - u \\rightarrow \\dots \\rightarrow \\text{root}_u$. The parity of the path length from $\\text{root}_v$ to $\\text{root}_u$ is the XOR sum of the parities of the three segments: path from $v$ to $\\text{root}_v$ ($\\text{parity}_v$), edge $(u,v)$ (parity $1$), and path from $u$ to $\\text{root}_u$ ($\\text{parity}_u$). Thus, we set `parity[root_v] = parity_u \\oplus parity_v \\oplus 1`.\n$3$. **Case B: Same Component ($\\text{root}_u = \\text{root}_v$)**. The edge is being added within an existing component. This will create a cycle. The path between $u$ and $v$ within the DSU tree structure has a length parity of $\\text{parity}_u \\oplus \\text{parity}_v$. Adding the edge $(u,v)$ (length $1$) creates a cycle of length parity $(\\text{parity}_u \\oplus \\text{parity}_v \\oplus 1) \\pmod 2$. The cycle is odd if and only if $\\text{parity}_u \\oplus \\text{parity}_v = 0$, which simplifies to $\\text{parity}_u = \\text{parity}_v$. This condition means that in the existing component's two-coloring, $u$ and $v$ were forced to have the same color. Adding an edge between them creates an unresolvable conflict. The graph is no longer bipartite.\n\nA special case is a self-loop, $(u,u)$, which is a cycle of length $1$. This is an odd cycle, so any graph containing a self-loop is not bipartite.\n\nThe final algorithm proceeds as follows: For each test case with $n$ vertices and a sequence of $m$ edges, we initialize the DSU structure for $n$ vertices. We then iterate through the edges from $t=1$ to $m$. For each edge $(u,v)$ at index $t$:\n- If $u=v$, we have a self-loop. The graph becomes non-bipartite. We report $t$ and terminate for this case.\n- Otherwise, we perform the `union(u, v)` operation. If it returns `False` (indicating a conflict), we report $t$ and terminate.\n- If the loop completes without any conflicts, all graphs $G_1, \\dots, G_m$ are bipartite. We report $0$.", "answer": "```python\nimport numpy as np\n\n# Although numpy is available, it is not used in this solution.\n# The solution uses only standard Python libraries.\n\nclass BipartiteDSU:\n    \"\"\"\n    An augmented Disjoint Set Union (DSU) data structure to track graph\n    bipartiteness. It checks for odd cycles as edges are added.\n    \"\"\"\n    def __init__(self, n):\n        \"\"\"\n        Initializes the DSU for n vertices (labeled 1 to n).\n        \n        Args:\n            n (int): The number of vertices.\n        \"\"\"\n        # Vertices are 1-indexed, so arrays are of size n+1.\n        self.parent = list(range(n + 1))\n        # self.parity[i] stores the parity of path length from node i to its parent.\n        # This is equivalent to color difference: 0 for same color, 1 for different.\n        self.parity = [0] * (n + 1)\n\n    def find(self, i):\n        \"\"\"\n        Finds the root of the set containing i and computes the parity of the\n        path from i to the root. Implements path compression.\n\n        Args:\n            i (int): The vertex to find.\n\n        Returns:\n            tuple[int, int]: A tuple (root, parity) where root is the\n                             representative of the set and parity is the path\n                             parity from i to the root.\n        \"\"\"\n        if self.parent[i] == i:\n            return i, 0\n        \n        # Recurse to find the root and the parity from parent[i] to the root.\n        root, parent_parity = self.find(self.parent[i])\n        \n        # Path Compression: Set the parent of i directly to the root.\n        self.parent[i] = root\n        \n        # Update Parity: The new parity of i is the XOR sum of its old\n        # parity (relative to its old parent) and its old parent's parity\n        # (relative to the root).\n        self.parity[i] ^= parent_parity\n        \n        return self.parent[i], self.parity[i]\n\n    def union(self, u, v):\n        \"\"\"\n        Processes the addition of an edge (u, v) and checks for conflicts\n        with the bipartite property.\n\n        Args:\n            u (int): The first vertex of the edge.\n            v (int): The second vertex of the edge.\n\n        Returns:\n            bool: True if the graph remains bipartite after adding the edge,\n                  False if an odd cycle is created.\n        \"\"\"\n        root_u, parity_u = self.find(u)\n        root_v, parity_v = self.find(v)\n\n        if root_u != root_v:\n            # The vertices are in different components. Merging them will not\n            # create a cycle, so the graph remains bipartite.\n            self.parent[root_v] = root_u\n            \n            # The new parity for root_v is determined by the path from root_v to\n            # root_u, which goes through v and u.\n            # Path: root_v <-- v -- u --> root_u\n            # Parity(root_v -> root_u) = Parity(v->root_v) ^ Parity(u->v) ^ Parity(u->root_u)\n            self.parity[root_v] = parity_u ^ parity_v ^ 1\n            return True\n        else:\n            # The vertices are already in the same component. Adding an edge\n            # will create a cycle. The graph becomes non-bipartite if this\n            # cycle is of odd length. This occurs if u and v have the same\n            # parity relative to their common root.\n            if parity_u == parity_v:\n                return False  # Conflict: odd cycle detected.\n            return True # Consistent edge, no new information.\n\ndef solve():\n    \"\"\"\n    Main function to run the bipartite test on all specified test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (6, [(1,2),(2,3),(3,4),(4,5),(5,6),(6,1),(1,3)]),\n        # Test case 2\n        (5, [(1,2),(2,3),(3,4),(4,5)]),\n        # Test case 3\n        (3, [(1,2),(2,2),(2,3)]),\n        # Test case 4\n        (4, [(1,2),(2,3),(3,1),(4,1)]),\n        # Test case 5\n        (4, [(1,2),(2,3),(1,2),(3,4),(4,1),(2,4)]),\n        # Test case 6\n        (3, []),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        dsu = BipartiteDSU(n)\n        result_t = 0\n        for i, edge in enumerate(edges):\n            t = i + 1\n            u, v = edge\n\n            # A self-loop is an odd cycle of length 1.\n            if u == v:\n                result_t = t\n                break\n\n            if not dsu.union(u, v):\n                # union returns False if a conflict (odd cycle) is found.\n                result_t = t\n                break\n        \n        results.append(result_t)\n\n    # Format the final output string as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3216756"}]}