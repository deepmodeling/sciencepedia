{"hands_on_practices": [{"introduction": "Understanding graph properties often involves combining different concepts to deduce new insights. This exercise challenges you to connect the structure of a complete bipartite graph, $K_{n,m}$, with the necessary and sufficient conditions for the existence of an Eulerian circuit. By analyzing the vertex degrees in $K_{n,m}$, you can precisely determine for which values of $n$ and $m$ such a tour is possible. [@problem_id:3237299]", "problem": "You are working with finite, simple, undirected graphs. Let $K_{n,m}$ denote the complete bipartite graph with bipartition classes of sizes $n$ and $m$, where $n,m \\in \\mathbb{Z}_{\\ge 1}$. Using only standard definitions concerning bipartite graphs, vertex degrees, graph connectivity, and the characterization for the existence of an Eulerian circuit in finite undirected graphs, determine which statement precisely characterizes all $(n,m)$ for which $K_{n,m}$ has an Eulerian circuit.\n\nChoose the single best option.\n\nA. $K_{n,m}$ has an Eulerian circuit exactly when both $n$ and $m$ are even integers (with $n,m \\ge 1$).\n\nB. $K_{n,m}$ has an Eulerian circuit exactly when both $n$ and $m$ are odd and $n=m$.\n\nC. $K_{n,m}$ has an Eulerian circuit exactly when one of $n$ or $m$ is even and the other is odd.\n\nD. $K_{n,m}$ has an Eulerian circuit exactly when $n+m$ is even (with $n,m \\ge 1$).\n\nE. $K_{n,m}$ has an Eulerian circuit exactly when $n=m$ and $n \\ge 2$.", "solution": "The problem statement is to determine the precise conditions on the integers $n$ and $m$ for which the complete bipartite graph $K_{n,m}$ has an Eulerian circuit.\n\n### Step 1: Extract Givens\n- The graphs under consideration are finite, simple, and undirected.\n- $K_{n,m}$ denotes the complete bipartite graph with bipartition classes of sizes $n$ and $m$.\n- The sizes of the partition classes are $n,m \\in \\mathbb{Z}_{\\ge 1}$, which means $n \\ge 1$ and $m \\ge 1$.\n- The task is to find a characterization for the existence of an Eulerian circuit in $K_{n,m}$.\n- The derivation must be based on standard definitions of bipartite graphs, vertex degrees, graph connectivity, and the characterization of Eulerian circuits.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is a standard exercise in introductory graph theory.\n- **Scientifically Grounded:** The concepts of complete bipartite graphs ($K_{n,m}$) and Eulerian circuits are fundamental and rigorously defined within the mathematical field of graph theory. The problem is based on established mathematical principles.\n- **Well-Posed:** The problem asks for a precise characterization, which is a necessary and sufficient condition. All terms are standard and clearly defined, and the constraints ($n, m \\ge 1$) are explicit. A unique, meaningful solution exists and can be derived from the given principles.\n- **Objective:** The language is formal and mathematical, free of ambiguity or subjective claims.\n\nThe problem statement is valid as it is self-contained, consistent, and grounded in established mathematical theory.\n\n### Step 3: Derivation of the Solution\n\nAccording to a fundamental theorem in graph theory, a finite undirected graph $G$ has an Eulerian circuit if and only if it satisfies two conditions:\n1.  $G$ is connected (except possibly for isolated vertices, though a graph with an edge-traversing circuit cannot have isolated vertices unconnected to the main component).\n2.  Every vertex in $G$ has an even degree.\n\nWe will now apply these two conditions to the complete bipartite graph $K_{n,m}$.\n\n**1. Connectivity of $K_{n,m}$**\n\nLet the vertex set of $K_{n,m}$ be $V = U \\cup W$, where $U$ and $W$ are the disjoint partition sets with $|U| = n$ and $|W| = m$. The problem states that $n \\ge 1$ and $m \\ge 1$.\n\n-   Let $v_1, v_2$ be any two vertices in $V$.\n    -   If $v_1 \\in U$ and $v_2 \\in W$, then by the definition of a complete bipartite graph, the edge $\\{v_1, v_2\\}$ exists. Thus, they are connected by a path of length $1$.\n    -   If $v_1, v_2$ are both in $U$ (which requires $n \\ge 2$), since $m \\ge 1$, there exists at least one vertex $w \\in W$. The path $v_1 - w - v_2$ connects $v_1$ and $v_2$.\n    -   If $v_1, v_2$ are both in $W$ (which requires $m \\ge 2$), since $n \\ge 1$, there exists at least one vertex $u \\in U$. The path $v_1 - u - v_2$ connects $v_1$ and $v_2$.\n\nSince any pair of vertices is connected by a path, the graph $K_{n,m}$ is connected for all $n, m \\ge 1$. The first condition for an Eulerian circuit is therefore always met.\n\n**2. Vertex Degrees in $K_{n,m}$**\n\nNow we examine the degrees of the vertices.\n-   Consider any vertex $u \\in U$. By definition of $K_{n,m}$, this vertex is connected to every vertex in $W$, and to no vertex in $U$. Since $|W| = m$, the degree of any vertex $u \\in U$ is $\\text{deg}(u) = m$.\n-   Similarly, consider any vertex $w \\in W$. This vertex is connected to every vertex in $U$, and to no vertex in $W$. Since $|U| = n$, the degree of any vertex $w \\in W$ is $\\text{deg}(w) = n$.\n\nFor $K_{n,m}$ to have an Eulerian circuit, every vertex must have an even degree. This implies:\n-   The degree of all vertices in $U$ must be even. Thus, $m$ must be an even integer.\n-   The degree of all vertices in $W$ must be even. Thus, $n$ must be an even integer.\n\nCombining these, a complete bipartite graph $K_{n,m}$ (with $n, m \\ge 1$) has an Eulerian circuit if and only if both $n$ and $m$ are even integers.\n\n### Evaluation of Options\n\nNow, we evaluate each of the given options against our derived condition.\n\n**A. $K_{n,m}$ has an Eulerian circuit exactly when both $n$ and $m$ are even integers (with $n,m \\ge 1$).**\nThis statement perfectly matches our derived necessary and sufficient condition. The parenthetical remark \"with $n,m \\ge 1$\" is consistent with the problem's setup.\n**Verdict: Correct.**\n\n**B. $K_{n,m}$ has an Eulerian circuit exactly when both $n$ and $m$ are odd and $n=m$.**\nIf $n$ and $m$ are both odd, then the degree of every vertex in the partition of size $n$ is $m$ (odd), and the degree of every vertex in the partition of size $m$ is $n$ (odd). Since all vertices have odd degrees, the condition that all vertices must have even degrees is violated. Therefore, no Eulerian circuit exists.\n**Verdict: Incorrect.**\n\n**C. $K_{n,m}$ has an Eulerian circuit exactly when one of $n$ or $m$ is even and the other is odd.**\nSuppose $n$ is even and $m$ is odd, without loss of generality. The $n$ vertices in the partition of size $n$ each have degree $m$ (odd). The $m$ vertices in the partition of size $m$ each have degree $n$ (even). Since there exist vertices of odd degree (specifically, all $n$ vertices in one partition), the graph does not have an Eulerian circuit. (It would have an Eulerian path if and only if there are exactly two vertices of odd degree, which would require $n=2$.)\n**Verdict: Incorrect.**\n\n**D. $K_{n,m}$ has an Eulerian circuit exactly when $n+m$ is even (with $n,m \\ge 1$).**\nThe sum $n+m$ is even if and only if $n$ and $m$ have the same parity. This means either both are even or both are odd.\n-   If both $n$ and $m$ are even, an Eulerian circuit exists.\n-   If both $n$ and $m$ are odd, as shown in the analysis of option B, no Eulerian circuit exists.\nSince this condition includes a case where no Eulerian circuit exists, it is not a sufficient condition. Therefore, it is not an exact characterization.\n**Verdict: Incorrect.**\n\n**E. $K_{n,m}$ has an Eulerian circuit exactly when $n=m$ and $n \\ge 2$.**\nThis condition is neither necessary nor sufficient.\n-   Not sufficient: consider $n=m=3$. Here, $n$ and $m$ are both odd, so all vertices have degree $3$. No Eulerian circuit exists. This provides a counterexample.\n-   Not necessary: consider $K_{2,4}$. Here $n=2$ and $m=4$. Both are even, so an Eulerian circuit exists. However, $n \\ne m$. This provides a counterexample.\n**Verdict: Incorrect.**\n\nBased on the analysis, only option A provides the correct characterization.", "answer": "$$\\boxed{A}$$", "id": "3237299"}, {"introduction": "A fundamental question in graph theory is how local structural constraints, such as the absence of certain subgraphs, affect global properties like the total number of edges. This practice guides you to determine the maximum number of edges a bipartite graph on a fixed number of vertices can have. By reasoning from first principles, you will discover that the most edge-dense bipartite graphs have a specific, balanced structure, a foundational concept in extremal graph theory. [@problem_id:3237256]", "problem": "A simple graph is a graph with no loops and no parallel edges. A bipartite graph is a graph whose vertex set can be partitioned into two disjoint independent sets so that every edge joins a vertex in one part to a vertex in the other part. Consider simple graphs on $n=10$ vertices. Using only the defining property of bipartite graphs that all edges cross between the two independent parts, determine the maximum number of edges $m_{\\max}(10)$ that any simple bipartite graph on $10$ vertices can have by reasoning from first principles. Based on your derivation, decide whether a simple graph with $10$ vertices and $20$ edges can be bipartite, but report only the value of $m_{\\max}(10)$ as your final answer. Express your final answer as an exact integer.", "solution": "The problem requires determining the maximum number of edges a simple bipartite graph with $n=10$ vertices can have, using only first principles.\n\nLet $G=(V, E)$ be a simple graph with a set of vertices $V$ and a set of edges $E$. The number of vertices is given as $|V| = n = 10$.\n\nThe defining property of a bipartite graph is that its vertex set $V$ can be partitioned into two disjoint and non-empty independent sets, which we will call $V_1$ and $V_2$. This partition must satisfy the following conditions:\n$1.$ $V_1 \\cup V_2 = V$\n$2.$ $V_1 \\cap V_2 = \\emptyset$\n$3.$ For any edge $(u, v) \\in E$, one vertex must be in $V_1$ and the other in $V_2$. This means there are no edges connecting two vertices within $V_1$, nor any edges connecting two vertices within $V_2$.\n\nLet the number of vertices in the set $V_1$ be $k$. Since the total number of vertices is $n=10$, the number of vertices in the set $V_2$ must be $|V_2| = n - k = 10 - k$. As the partitions are non-empty, $k$ must be an integer such that $1 \\le k \\le 9$. The case where $k=0$ or $k=10$ would imply one of the sets is empty, resulting in a graph with no edges, which we can exclude when seeking a maximum.\n\nTo find the maximum number of edges, $m_{\\max}$, we consider a graph where every possible edge that respects the bipartite property exists. The graph is simple, meaning there are no multiple edges between the same pair of vertices. Therefore, for a given partition $(V_1, V_2)$, the maximum number of edges is achieved when every vertex in $V_1$ is connected to every vertex in $V_2$.\n\nThe number of such edges, let us denote it by $m(k)$, is the product of the number of vertices in each partition set:\n$$m(k) = |V_1| \\times |V_2| = k \\times (10 - k)$$\n\nOur goal is to find the maximum value of the function $m(k) = 10k - k^2$ for integer values of $k$ in the range $1 \\le k \\le 9$.\n\nThis function $m(k)$ is a quadratic function of $k$ representing a downward-opening parabola. The maximum value of this continuous function occurs at its vertex. The coordinate of the vertex for a parabola of the form $ax^2 + bx + c$ is at $x = -\\frac{b}{2a}$. For $m(k) = -k^2 + 10k$, we have $a = -1$ and $b = 10$. The vertex is at:\n$$k = -\\frac{10}{2(-1)} = 5$$\n\nSince $k=5$ is an integer and falls within our allowed range for $k$, the maximum number of edges will occur when the vertices are partitioned into two sets of size $k=5$ and $10-k=5$.\n\nLet's evaluate $m(k)$ for this value of $k$:\n$$m_{\\max}(10) = m(5) = 5 \\times (10 - 5) = 5 \\times 5 = 25$$\n\nThis corresponds to the complete bipartite graph $K_{5,5}$. We can verify that this is indeed the maximum by evaluating the function at other possible integer values of $k$:\n- If $k=1$ (or $k=9$), $m(1) = 1 \\times 9 = 9$ edges.\n- If $k=2$ (or $k=8$), $m(2) = 2 \\times 8 = 16$ edges.\n- If $k=3$ (or $k=7$), $m(3) = 3 \\times 7 = 21$ edges.\n- If $k=4$ (or $k=6$), $m(4) = 4 \\times 6 = 24$ edges.\n- If $k=5$, $m(5) = 5 \\times 5 = 25$ edges.\n\nThe maximum value is clearly $25$. Thus, the maximum number of edges any simple bipartite graph on $10$ vertices can have is $m_{\\max}(10) = 25$.\n\nThe problem also asks to decide whether a simple graph with $10$ vertices and $20$ edges can be bipartite. Since the maximum possible number of edges is $25$, and $20  25$, it is certainly possible for such a graph to be bipartite. For example, one could construct a complete bipartite graph $K_{4,6}$, which has $4 \\times 6 = 24$ edges, and then remove any $4$ edges. The resulting graph would have $20$ edges and remain bipartite. Alternatively, one could take the maximal graph $K_{5,5}$ and remove $5$ edges. In either case, a simple bipartite graph on $10$ vertices with $20$ edges can exist.\n\nThe final answer to be reported is only the value of $m_{\\max}(10)$.", "answer": "$$\\boxed{25}$$", "id": "3237256"}, {"introduction": "Theoretical graph concepts find their power in a wide range of practical applications, especially in algorithm design. This exercise asks you to design a data structure that can efficiently detect cycles as new edges are added to a graph. The key is to leverage the relationship between cycles and connected components, translating a theoretical property into an efficient algorithmic solution for dynamic graph management. [@problem_id:3237184]", "problem": "You are given an undirected graph $G = (V, E)$ with a finite set of vertices $V$ labeled as the integer range $\\{0, 1, \\dots, n-1\\}$, and an initially specified set of edges $E$ that may be empty. The graph evolves by proposed additions of edges of the form $(u, v)$, where $u, v \\in V$. Your task is to design and implement a complete program that maintains a data structure grounded in graph properties to efficiently report, for each proposed edge addition, whether adding the edge $(u, v)$ would create a cycle in the current undirected graph.\n\nThe foundational base you must rely on is the following collection of definitions and facts:\n- A simple path in an undirected graph is a sequence of distinct vertices $(x_0, x_1, \\dots, x_k)$ such that for every index $i$ with $0 \\le i  k$, the pair $(x_i, x_{i+1})$ is an edge in the graph.\n- A cycle in an undirected graph is a path $(x_0, x_1, \\dots, x_{k-1}, x_0)$ with $k \\ge 3$ whose vertices $x_0, x_1, \\dots, x_{k-1}$ are distinct except that the first and last vertices coincide; by convention, adding a self-loop $(u, u)$ is considered to create a cycle immediately.\n- A connected component is a maximal set of vertices where each pair of vertices in the set is connected by some path.\n- A tree is a connected undirected acyclic graph, and a forest is a disjoint union of trees.\n\nYour program must implement a data structure that can determine, for each proposed edge $(u, v)$, whether adding $(u, v)$ would create a cycle. The decision must be made based strictly on graph-theoretic properties of connectivity as the graph evolves with accepted additions. The program must assume that each proposed edge is undirected. If adding $(u, v)$ would create a cycle, the program must output the boolean value $\\texttt{True}$ for that proposal; otherwise, the program must output $\\texttt{False}$ and incorporate $(u, v)$ into the data structure going forward. Self-loops $(u, u)$ always yield $\\texttt{True}$.\n\nYour program must use the following test suite, where each test case consists of $(n, E_{\\text{init}}, E_{\\text{add}})$:\n- Test case A (general case):\n  - $n = 5$\n  - $E_{\\text{init}} = \\emptyset$\n  - $E_{\\text{add}} = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]$\n- Test case B (merging components then closing a cycle):\n  - $n = 4$\n  - $E_{\\text{init}} = [(0, 1), (2, 3)]$\n  - $E_{\\text{add}} = [(1, 2), (0, 2), (1, 3)]$\n- Test case C (self-loop and repeated connection):\n  - $n = 3$\n  - $E_{\\text{init}} = \\emptyset$\n  - $E_{\\text{add}} = [(0, 0), (1, 2), (2, 1)]$\n- Test case D (single vertex boundary):\n  - $n = 1$\n  - $E_{\\text{init}} = \\emptyset$\n  - $E_{\\text{add}} = [(0, 0), (0, 0)]$\n\nFor each test case, your program must output a list of booleans in the order of $E_{\\text{add}}$, where each boolean indicates whether the corresponding proposed edge addition would create a cycle at the time of the proposal. Your program should produce a single line of output containing the results aggregated across all provided test cases into a single comma-separated list enclosed in square brackets, with each test case’s list enclosed in its own square brackets and no spaces. For example, an aggregate of two test cases with results $\\texttt{[True,False]}$ and $\\texttt{[False]}$ must be printed exactly as $\\texttt{[[True,False],[False]]}$.\n\nAll answers are pure booleans, and no physical units are involved. Angles and percentages do not appear in this problem. The program must be a complete, runnable program and must not read input from standard input or from files; it must run as-is and print the specified single-line output.", "solution": "The solution hinges on a fundamental property connecting cycles and connectivity in an undirected graph. The graph can be viewed as a forest, where each connected component is a tree (an acyclic structure). Adding a new edge can have two outcomes:\n1.  If the new edge $(u, v)$ connects two vertices that are already in the same connected component, a path already exists between $u$ and $v$. Adding the edge $(u, v)$ completes a cycle.\n2.  If the new edge $(u, v)$ connects two vertices in different connected components, it merges the two components (two trees) into a single larger one, without creating any cycles.\n\nThis \"same component\" check can be performed efficiently using a **Disjoint Set Union (DSU)** or **Union-Find** data structure. This data structure is designed to maintain a collection of disjoint sets, which perfectly model the connected components of a graph.\n-   **Initialization:** Each vertex starts in its own set, representing a graph with no edges.\n-   **`find(i)` operation:** Determines the representative (root) of the set containing vertex `i`, effectively identifying its connected component.\n-   **`union(i, j)` operation:** Merges the two sets containing `i` and `j`, modeling the addition of an edge that connects two components.\n\nThe algorithm is as follows:\n1.  Initialize a DSU structure for all vertices in $V$.\n2.  Process any initial edges in $E$ by calling `union(u, v)` for each edge.\n3.  For each proposed edge $(u, v)$ to be added:\n    -   Handle self-loops: if $u=v$, a cycle is formed. Report `True`.\n    -   Check connectivity: Call `find(u)` and `find(v)`. If their representatives are the same, they are in the same component. Adding the edge would create a cycle. Report `True`.\n    -   If their representatives are different, no cycle is created. Report `False` and then call `union(u, v)` to merge the components, reflecting the addition of the new edge to the graph.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass UnionFind:\n    \"\"\"\n    An implementation of the Union-Find (Disjoint Set Union) data structure.\n\n    This data structure keeps track of a set of elements partitioned into a\n    number of disjoint (non-overlapping) subsets. It provides two main\n    operations: find, which determines which subset an element is in, and\n    union, which joins two subsets into a single subset.\n\n    This implementation uses two standard optimizations for near-constant time\n    amortized performance:\n    1. Union by Rank: When merging two sets, the root of the shorter tree\n       is made a child of the root of the taller tree. This keeps the trees\n       from becoming too deep.\n    2. Path Compression: During a find operation, the path from the element\n       to the root is flattened, making future finds faster.\n    \"\"\"\n    def __init__(self, n):\n        \"\"\"\n        Initializes the Union-Find structure for n elements.\n        Each element from 0 to n-1 starts in its own set.\n        \n        Args:\n            n (int): The number of elements.\n        \"\"\"\n        # parent[i] stores the parent of element i.\n        self.parent = np.arange(n)\n        # rank[i] stores the height of the tree rooted at i.\n        self.rank = np.zeros(n, dtype=int)\n\n    def find(self, i):\n        \"\"\"\n        Finds the representative (root) of the set containing element i.\n        Implements path compression.\n        \n        Args:\n            i (int): The element to find.\n        \n        Returns:\n            int: The representative of the set.\n        \"\"\"\n        if self.parent[i] == i:\n            return i\n        # Path compression: set the parent of i directly to the root.\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        \"\"\"\n        Merges the sets containing elements i and j.\n        Implements union by rank.\n        \n        Args:\n            i (int): The first element.\n            j (int): The second element.\n        \"\"\"\n        root_i = self.find(i)\n        root_j = self.find(j)\n        \n        if root_i != root_j:\n            # Union by rank\n            if self.rank[root_i]  self.rank[root_j]:\n                self.parent[root_i] = root_j\n            elif self.rank[root_i]  self.rank[root_j]:\n                self.parent[root_j] = root_i\n            else:\n                self.parent[root_j] = root_i\n                self.rank[root_i] += 1\n\n\ndef solve():\n    \"\"\"\n    Solves the cycle detection problem for a series of test cases.\n    For each test case, it processes initial and proposed edge additions,\n    reporting for each proposed edge whether its addition would create a cycle.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A (general case)\n        (5, [], [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]),\n        # Test case B (merging components then closing a cycle)\n        (4, [(0, 1), (2, 3)], [(1, 2), (0, 2), (1, 3)]),\n        # Test case C (self-loop and repeated connection)\n        (3, [], [(0, 0), (1, 2), (2, 1)]),\n        # Test case D (single vertex boundary)\n        (1, [], [(0, 0), (0, 0)]),\n    ]\n\n    all_results = []\n    \n    for n, E_init, E_add in test_cases:\n        # Initialize Union-Find data structure for n vertices.\n        uf = UnionFind(n)\n        \n        # Process the initial set of edges to establish the starting graph state.\n        for u, v in E_init:\n            uf.union(u, v)\n        \n        case_results = []\n        # Process each proposed edge addition.\n        for u, v in E_add:\n            # According to the problem, a self-loop (u, u) always creates a cycle.\n            if u == v:\n                case_results.append(True)\n                # The state of the graph does not change for a rejected edge.\n                continue\n\n            # Check if u and v are already in the same connected component.\n            # If find(u) == find(v), they are, and adding edge (u, v) creates a cycle.\n            if uf.find(u) == uf.find(v):\n                case_results.append(True)\n            else:\n                # If they are in different components, adding the edge does not create a cycle.\n                case_results.append(False)\n                # The edge is added to the graph, so we merge the components.\n                uf.union(u, v)\n        \n        all_results.append(case_results)\n\n    # Format the final output string as specified.\n    # e.g., [[False,False,True],[False,True]]\n    output_str = f\"[{','.join([str(res).replace(' ', '') for res in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3237184"}]}