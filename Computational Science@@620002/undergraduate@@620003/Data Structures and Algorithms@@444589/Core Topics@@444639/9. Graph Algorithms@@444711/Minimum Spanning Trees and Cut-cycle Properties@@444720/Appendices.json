{"hands_on_practices": [{"introduction": "An MST represents the cheapest way to connect a network, but are all of its edges equally critical? This practice challenges you to determine if a specific edge is essential, meaning it must belong to *every* possible Minimum Spanning Tree. To solve this, you'll need to move beyond simply running an MST algorithm and instead use the cut property to reason about whether a cheaper alternative path could ever replace the edge in question. [@problem_id:3253138]", "problem": "You are given an undirected, connected, weighted graph $G$ with vertex set $V(G)$ and edge set $E(G)$, where each edge $e=(u,v,w)$ has a nonnegative weight $w \\in \\mathbb{R}_{\\ge 0}$. A spanning tree of $G$ is a connected, cycle-free subgraph covering all vertices. A Minimum Spanning Tree (MST) is a spanning tree whose total weight is minimized among all spanning trees of $G$. The cut property states: for any partition (cut) of $V(G)$ into two disjoint nonempty sets, any edge with strictly minimal weight among all edges crossing this cut appears in some MST. The cycle property states: in any cycle, an edge with strictly maximal weight does not appear in any MST.\n\nDesign an algorithm that, given $G$ and a specific edge $e^\\star=(x,y,w_{e^\\star})$, decides whether $e^\\star$ belongs to every MST of $G$. Your algorithm must be based on fundamental definitions and the cut-cycle properties and must be implemented as a complete program.\n\nYour program must execute on the following test suite. Each test case is specified by the number of vertices $n$, a list of edges as triples $(u,v,w)$ with $u,v \\in \\{1,\\dots,n\\}$ and $w \\in \\mathbb{R}_{\\ge 0}$, and the distinguished edge $e^\\star$ written as a triple $(x,y,w_{e^\\star})$. The graphs are undirected and connected, and weights are integers.\n\n- Test case $1$:\n  - $n=3$\n  - $E=\\{(1,2,1),(2,3,2),(1,3,3)\\}$\n  - $e^\\star=(1,2,1)$\n- Test case $2$:\n  - $n=4$\n  - $E=\\{(1,2,1),(2,3,1),(3,4,1),(4,1,1)\\}$\n  - $e^\\star=(1,2,1)$\n- Test case $3$:\n  - $n=3$\n  - $E=\\{(1,2,1),(2,3,2),(1,3,3)\\}$\n  - $e^\\star=(1,3,3)$\n- Test case $4$:\n  - $n=2$\n  - $E=\\{(1,2,5)\\}$\n  - $e^\\star=(1,2,5)$\n- Test case $5$:\n  - $n=5$\n  - $E=\\{(1,2,1),(3,4,1),(4,5,1),(3,5,2),(2,3,4),(1,3,7),(2,4,8)\\}$\n  - $e^\\star=(2,3,4)$\n\nYour program must produce, for each test case, a boolean indicating whether $e^\\star$ belongs to every MST of $G$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$, where each $\\text{result}_i$ is either $\\text{True}$ or $\\text{False}$.\n\nThere are no physical units or angles involved. All answers are dimensionless booleans.", "solution": "The problem requires an algorithm to determine if a given edge $e^\\star=(x,y,w_{e^\\star})$ belongs to every Minimum Spanning Tree (MST) of a connected, undirected, weighted graph $G=(V, E)$. The algorithm must be grounded in the fundamental properties of MSTs, such as the cut and cycle properties.\n\nA well-established theorem in graph theory provides a necessary and sufficient condition for an edge to be included in every MST. This theorem, which can be derived from the cut and cycle properties, forms the basis of our algorithm.\n\n**Core Principle**\n\nAn edge $e^\\star=(x, y, w_{e^\\star})$ is in every MST of a graph $G$ if and only if for any path between its endpoints $x$ and $y$ that does not include $e^\\star$, there is at least one edge on that path with a weight strictly greater than $w_{e^\\star}$.\n\n**Justification of the Principle**\n\nWe can prove this by contradiction. Let's assume the opposite condition allows us to construct an MST without $e^\\star$.\n\nSuppose there exists a path $P_{xy}$ between $x$ and $y$ in $G \\setminus \\{e^\\star\\}$ (i.e., a path not using $e^\\star$) such that all edges on $P_{xy}$ have weights less than or equal to $w_{e^\\star}$. We want to show that this implies that $e^\\star$ is not in every MST.\n\nLet $T$ be an MST of $G$. If $T$ does not contain $e^\\star$, we have already found an MST without it, and thus $e^\\star$ is not in every MST.\n\nNow, consider the case where $T$ does contain $e^\\star$. Adding the path $P_{xy}$ to $T$ is not what we want to do. Instead, let's consider the cycle $C = \\{e^\\star\\} \\cup P_{xy}$. By our supposition, every edge on $P_{xy}$ has a weight $w \\le w_{e^\\star}$. There must be at least one edge $e'$ on the path $P_{xy}$ that can be removed to break the cycle $C$ while keeping the graph connected. Let's start with a spanning tree $T_{base}$ built from all edges with weight $w  w_{e^\\star}$ together with a selection of edges of weight $w_{e^\\star}$ from $P_{xy}$ to connect $x$ and $y$. This construction is guaranteed to be part of some MST. Since this tree connects $x$ and $y$ without using $e^\\star$, it demonstrates that an MST can exist without $e^\\star$.\n\nA more formal argument relies on the exchange property. Suppose $e^\\star$ is in an MST, $T_{mst}$. Adding any edge $e' \\in P_{xy}$ to $T_{mst}$ creates a cycle. This line of reasoning is more complex. A more direct proof is as follows:\n\nLet's prove that if every path in $G \\setminus \\{e^\\star\\}$ between $x$ and $y$ contains an edge heavier than $e^\\star$, then $e^\\star$ must be in every MST.\nAssume for contradiction that there exists an MST, $T$, that does not contain $e^\\star$. Since $T$ is a spanning tree, there must be a unique path $P$ in $T$ that connects $x$ and $y$. By our premise, this path $P$ must contain at least one edge, let's call it $e'=(u,v)$, with weight $w(e') > w_{e^\\star}$. Now, consider a new graph $T' = (T \\setminus \\{e'\\}) \\cup \\{e^\\star\\}$. Removing $e'$ from $T$ splits it into two disconnected components. Since $x$ and $y$ are connected by $P$ in $T$, and $e'$ is on that path, adding $e^\\star$ which connects $x$ and $y$ will join the two components in some way. In fact, adding $e^\\star$ to $T$ forms a cycle containing both $e^\\star$ and $e'$, so removing $e'$ from this cycle results in a new spanning tree $T'$. The total weight of $T'$ is $W(T') = W(T) - w(e') + w_{e^\\star}$. Since $w(e') > w_{e^\\star}$, we have $W(T')  W(T)$. This contradicts the assumption that $T$ is an MST. Therefore, no MST can exist without containing $e^\\star$.\n\n**Algorithmic Formulation**\n\nThe core principle can be rephrased into a testable condition: $e^\\star$ is in every MST if and only if there is *no* path between $x$ and $y$ (in $G \\setminus \\{e^\\star\\}$) where all edges have weights less than or equal to $w_{e^\\star}$.\n\nThis leads to the following algorithm:\n1.  Construct a subgraph $G_{alt} = (V, E_{alt})$. The vertex set is the same as the original graph $G$.\n2.  The edge set $E_{alt}$ consists of all edges $e=(u,v,w)$ from the original edge set $E$ that satisfy two conditions:\n    a. The weight $w$ is less than or equal to the weight of the target edge, $w \\le w_{e^\\star}$.\n    b. The edge $e$ is not the target edge $e^\\star$ itself ($e \\neq e^\\star$).\n3.  Check if vertices $x$ and $y$ are connected in this new subgraph $G_{alt}$. This can be efficiently done using a Breadth-First Search (BFS), Depth-First Search (DFS), or a Disjoint Set Union (DSU) data structure.\n4.  If $x$ and $y$ are connected in $G_{alt}$, it means an alternative path of \"cheap\" edges exists. Therefore, $e^\\star$ is not essential and does not belong to every MST. The algorithm returns $\\text{False}$.\n5.  If $x$ and $y$ are disconnected in $G_{alt}$, it means any alternative path between them must use at least one edge with weight strictly greater than $w_{e^\\star}$. As proven above, this makes $e^\\star$ essential to every MST. The algorithm returns $\\text{True}$.\n\nThis algorithm correctly determines if an edge is a \"bridge\" over a critical weight threshold, making it indispensable. The check for connectivity in step $3$ using a DSU data structure is particularly efficient, offering a near-constant time complexity for each edge union operation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_in_every_mst(n, edges, e_star):\n    \"\"\"\n    Determines if a given edge e_star is in every Minimum Spanning Tree (MST)\n    of the graph defined by n vertices and the edge list.\n    \n    Args:\n        n (int): The number of vertices, labeled 1 to n.\n        edges (list of tuples): The list of edges, each as a (u, v, w) tuple.\n        e_star (tuple): The distinguished edge (x, y, w_star) to be checked.\n        \n    Returns:\n        bool: True if e_star is in every MST, False otherwise.\n    \"\"\"\n    \n    # DSU (Disjoint Set Union) data structure implemented with nested functions\n    # for checking connectivity. Vertices are 1-based.\n    parent = list(range(n + 1))\n    \n    def find(i):\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent[i])\n        return parent[i]\n\n    def union(i, j):\n        root_i = find(i)\n        root_j = find(j)\n        if root_i != root_j:\n            parent[root_i] = root_j\n\n    x, y, w_star = e_star\n    \n    # Normalize e_star's endpoints for consistent undirected edge comparison.\n    # This handles cases where the edge in the list is (v, u) instead of (u, v).\n    e_star_nodes = tuple(sorted((x, y)))\n\n    # Build the connected components for the subgraph containing alternative paths.\n    # An alternative path is one that connects x and y without using e_star,\n    # composed entirely of edges with weights less than or equal to w_star.\n    for u, v, w in edges:\n        # Normalize the current edge's endpoints for comparison.\n        current_edge_nodes = tuple(sorted((u, v)))\n        \n        if w  w_star:\n            # Edges strictly cheaper than e_star can always be part of an alternative path.\n            union(u, v)\n        elif w == w_star and current_edge_nodes != e_star_nodes:\n            # Edges with the same weight can also be part of an alternative path,\n            # as long as they are not e_star itself.\n            union(u, v)\n\n    # An alternative path exists if and only if x and y are in the same\n    # connected component in the subgraph we've just processed.\n    # If find(x) == find(y), they are connected, so e_star is NOT in every MST.\n    # If find(x) != find(y), they are disconnected, so e_star IS in every MST.\n    return find(x) != find(y)\n\n\ndef solve():\n    \"\"\"\n    Defines the test suite and runs the algorithm for each case,\n    then prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)], (1, 2, 1)),\n        # Test case 2\n        (4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)], (1, 2, 1)),\n        # Test case 3\n        (3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)], (1, 3, 3)),\n        # Test case 4\n        (2, [(1, 2, 5)], (1, 2, 5)),\n        # Test case 5\n        (5, [(1, 2, 1), (3, 4, 1), (4, 5, 1), (3, 5, 2), (2, 3, 4), (1, 3, 7), (2, 4, 8)], (2, 3, 4))\n    ]\n\n    results = []\n    for n, edges, e_star in test_cases:\n        result = is_in_every_mst(n, edges, e_star)\n        results.append(result)\n\n    # The final print statement must produce only the specified single-line format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\n# Execute the main solver function.\nsolve()\n```", "id": "3253138"}, {"introduction": "Building on the idea of essential edges, this exercise explores the stability of a given MST. In many practical applications, edge weights (like costs or distances) can fluctuate. This problem asks you to calculate the precise \"breaking point\" for an edge within an MST—how much can its weight increase before the tree is no longer optimal? [@problem_id:3253184] Solving this requires a direct application of the cut property to identify the competing edge that limits this threshold.", "problem": "Consider a connected, undirected, weighted graph $G=(V,E)$ with vertex set $V=\\{1,2,3,4,5,6\\}$. The edge weights are given by the function $w:E\\to\\mathbb{R}_{\\ge 0}$ on the following edges:\n- $w(\\{1,2\\})=2$, $w(\\{2,3\\})=3$, $w(\\{3,4\\})=4$, $w(\\{4,5\\})=5$, $w(\\{5,6\\})=6$,\n- $w(\\{1,3\\})=7$, $w(\\{2,4\\})=8$, $w(\\{3,5\\})=9$, $w(\\{4,6\\})=10$, $w(\\{1,4\\})=11$, $w(\\{2,5\\})=12$, $w(\\{3,6\\})=13$.\n\nLet $T$ be the Minimum Spanning Tree (MST) comprising the edges $\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\},\\{5,6\\}\\}$. Let $e=\\{3,4\\}\\in T$ be the tree edge with weight $w(e)=4$.\n\nStarting only from the core definitions of spanning trees and the cut-cycle properties of MSTs, determine the largest real number $\\Delta\\ge 0$ such that increasing the weight of $e$ to $w(e)+\\Delta$ leaves $T$ as an MST of $G$. Express your final answer as a single real number. No rounding is required.", "solution": "The problem asks to find the maximum allowable increase in weight for an edge in a given Minimum Spanning Tree (MST) such that the tree remains an MST.\n\n**Step 1: Understand the Setup**\n-   Graph $G=(V,E)$ is connected, undirected, and weighted.\n-   Vertex set $V=\\{1,2,3,4,5,6\\}$.\n-   Edge weights are provided.\n-   $T = \\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\},\\{5,6\\}\\}$ is the MST. This is correct as these are the 5 cheapest edges that form a spanning path.\n-   The edge to modify is $e=\\{3,4\\}$, with original weight $w(e)=4$.\n-   The new weight is $w'(e) = w(e)+\\Delta = 4+\\Delta$, where $\\Delta\\ge 0$.\n-   We need to find the largest $\\Delta$ for which $T$ is still an MST.\n\n**Step 2: Apply the Cut Property**\nThe solution hinges on the **Cut Property** of MSTs. For any cut (a partition of vertices into two sets), an edge in an MST that crosses the cut must be a \"light edge,\" meaning no other edge crossing the same cut is cheaper.\n\nRemoving the edge $e=\\{3,4\\}$ from the MST $T$ splits the tree's vertices into two disjoint sets, creating a specific cut $(S_1, S_2)$.\n-   Vertices connected to vertex 3 in $T \\setminus \\{e\\}$ form one set: $S_1 = \\{1, 2, 3\\}$.\n-   Vertices connected to vertex 4 in $T \\setminus \\{e\\}$ form the other set: $S_2 = \\{4, 5, 6\\}$.\n\nFor the tree $T$ to remain an MST after increasing the weight of $e$, the modified edge $e$ must still be a light edge for the cut $(S_1, S_2)$. This means its new weight, $w'(e)$, must be less than or equal to the weight of any *other* edge in the original graph that crosses this cut.\n\n**Step 3: Identify Competing Edges**\nWe must find all edges in the graph $G$ that connect a vertex in $S_1$ to a vertex in $S_2$. These are the \"competitor\" edges.\nFrom the given list:\n-   $\\{2,4\\}$ connects $S_1$ to $S_2$, weight $w(\\{2,4\\})=8$.\n-   $\\{3,5\\}$ connects $S_1$ to $S_2$, weight $w(\\{3,5\\})=9$.\n-   $\\{1,4\\}$ connects $S_1$ to $S_2$, weight $w(\\{1,4\\})=11$.\n-   $\\{2,5\\}$ connects $S_1$ to $S_2$, weight $w(\\{2,5\\})=12$.\n-   $\\{3,6\\}$ connects $S_1$ to $S_2$, weight $w(\\{3,6\\})=13$.\n\nThe original edge $\\{3,4\\}$ with weight 4 is also in this set.\n\n**Step 4: Formulate the Inequality**\nThe new weight of edge $e$, which is $4+\\Delta$, must be less than or equal to the weight of the cheapest of these competitor edges.\n$$ w'(e) \\le \\min \\{ w(\\{2,4\\}), w(\\{3,5\\}), w(\\{1,4\\}), w(\\{2,5\\}), w(\\{3,6\\}) \\} $$\n$$ 4 + \\Delta \\le \\min \\{8, 9, 11, 12, 13\\} $$\nThe minimum weight of the competitor edges is 8.\n$$ 4 + \\Delta \\le 8 $$\n\n**Step 5: Solve for $\\Delta$**\nSolving the inequality for $\\Delta$:\n$$ \\Delta \\le 8 - 4 $$\n$$ \\Delta \\le 4 $$\nThe largest non-negative real number $\\Delta$ that satisfies this condition is $\\Delta = 4$.\n\nIf $\\Delta$ is greater than 4, the edge $\\{2,4\\}$ (with weight 8) would be strictly cheaper than the modified edge $\\{3,4\\}$ (with weight $>8$). By the Cut Property, we could create a cheaper spanning tree by swapping $\\{3,4\\}$ with $\\{2,4\\}$, so $T$ would no longer be an MST. If $\\Delta = 4$, the edge $\\{3,4\\}$ has weight 8, which is equal to the cheapest competitor. It remains a light edge for the cut, so $T$ is still an MST.\n\nThus, the largest value for $\\Delta$ is 4.", "answer": "$$\\boxed{4}$$", "id": "3253184"}, {"introduction": "In network design and optimization, the absolute best solution might not always be available or desired. This advanced practice asks you to find the \"second-best\" MST, the spanning tree with the smallest weight that is strictly greater than the MST's weight. This task requires you to synthesize your understanding of MSTs by first finding an optimal tree, and then systematically using the cycle property to explore single-edge swaps that generate slightly costlier, but still optimal, alternatives. [@problem_id:3253223]", "problem": "Given a connected, undirected, weighted graph $G = (V, E)$ with $|V| = n$ vertices labeled from $0$ to $n-1$ and $|E| = m$ edges, design an algorithm to compute the weight of the \"second-best\" Minimum Spanning Tree (MST), defined as the smallest total weight among all spanning trees that is strictly greater than the weight of a minimum spanning tree. If there is no spanning tree whose total weight is strictly greater than the weight of a minimum spanning tree, the algorithm should return $-1$. All edge weights are nonnegative integers. The algorithm must be derived from first principles using fundamental definitions and well-tested facts of graph theory, specifically the cut property and the cycle property for spanning trees.\n\nThe fundamental base you must use includes:\n- The definition of a spanning tree, a cycle, and a cut in a graph.\n- The definition of the Minimum Spanning Tree (MST) as a spanning tree with minimum total edge weight.\n- The cut property: for any cut in the graph, the lightest edge that crosses the cut is always included in some MST.\n- The cycle property: for any cycle in the graph, the heaviest edge on that cycle is excluded from every MST.\n\nYour program must implement an algorithm that:\n- Computes an MST of $G$ (you may assume without proof that algorithms like Kruskal's algorithm produce a valid MST when applied correctly).\n- Determines the weight of the second-best MST by logically reasoning about how replacing edges in an MST using non-tree edges affects total weight, relying on the cut and cycle properties rather than shortcut formulas.\n\nInput is embedded in the program as a test suite of graphs. For each graph, the output must be a single integer: the weight of the second-best MST, or $-1$ if no spanning tree has strictly greater total weight than the MSTs. No physical units or angles are involved.\n\nTest suite:\n- Test case $1$ (general connected graph with a unique MST):\n  - $n = 6$\n  - $E = \\{(0,1,4), (0,2,3), (1,2,1), (1,3,2), (2,3,4), (3,4,2), (4,5,6), (3,5,5), (2,5,7), (0,5,10)\\}$\n- Test case $2$ (graph with multiple MSTs of equal weight, requiring strict increase for the second-best):\n  - $n = 4$\n  - $E = \\{(0,1,1), (1,2,1), (2,3,1), (3,0,1), (0,2,2), (1,3,2)\\}$\n- Test case $3$ (small graph where the second-best MST differs by a single edge substitution):\n  - $n = 3$\n  - $E = \\{(0,1,1), (1,2,1), (0,2,2)\\}$\n- Test case $4$ (graph where all spanning trees have the same total weight, so there is no strictly greater spanning tree):\n  - $n = 3$\n  - $E = \\{(0,1,5), (1,2,5), (0,2,5)\\}$\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets, for example, $[a,b,c,d]$, where $a$, $b$, $c$, and $d$ are integers corresponding to the test cases above, in order.\n\nYour implementation must be self-contained and produce deterministic results for the given test suite. The answers for all test cases are integers. No percentages or angle units are required.", "solution": "The problem asks for the weight of the \"second-best\" minimum spanning tree of a given graph $G = (V, E)$. The second-best spanning tree is defined as the spanning tree with the smallest total weight that is strictly greater than the weight of a minimum spanning tree (MST). Let the weight of an MST be $W_{MST}$. We seek to find $\\min \\{ W(T) \\mid T \\text{ is a spanning tree of } G \\text{ and } W(T) > W_{MST} \\}$.\n\nThe solution is derived from the fundamental properties of spanning trees. A key insight is that any spanning tree can be transformed into another by swapping edges. Specifically, any spanning tree $T'$ can be obtained from an MST, $T_{MST}$, by adding an edge not in $T_{MST}$ and removing an edge from the cycle that is formed.\n\nLet $T_{MST}$ be an MST of $G$. Consider any edge $e_{in} = (u,v)$ that is not in $T_{MST}$. Adding $e_{in}$ to $T_{MST}$ creates a unique cycle, $C$. This cycle consists of $e_{in}$ and the unique path $P_{uv}$ between vertices $u$ and $v$ within $T_{MST}$. To form a new spanning tree, we must remove an edge $e_{out}$ from this cycle $C$. To ensure the new graph is a tree, $e_{out}$ must be one of the edges on the path $P_{uv}$. The resulting set of edges, $T' = (T_{MST} \\setminus \\{e_{out}\\}) \\cup \\{e_{in}\\}$, is a new spanning tree.\n\nThe weight of this new spanning tree $T'$ is $W(T') = W(T_{MST}) - w(e_{out}) + w(e_{in})$. We are looking for the minimum $W(T')$ such that $W(T') > W_{MST}$, which is equivalent to finding the minimum positive weight difference, $\\Delta W = w(e_{in}) - w(e_{out})$.\n\nThe cycle property implies that for the cycle $C$, the weight of the non-MST edge $e_{in}$ must be greater than or equal to the weight of any edge on the path $P_{uv}$ (i.e., $w(e_{in}) \\ge w(e)$ for all $e \\in P_{uv}$). If not, swapping $e_{in}$ with a heavier edge on the path would create a spanning tree cheaper than $T_{MST}$, a contradiction. Therefore, the weight difference $\\Delta W = w(e_{in}) - w(e_{out})$ is always non-negative.\n\nTo find the second-best MST, we must find the smallest possible *strictly positive* increase in weight over $W_{MST}$. This means we must find the minimum $\\Delta W$ that is greater than zero. For a fixed choice of incoming edge $e_{in}$, the weight increase $w(e_{in}) - w(e_{out})$ is minimized when $w(e_{out})$ is maximized. Thus, for each non-MST edge $e_{in}$, we should consider swapping it with the heaviest edge, $e_{out}$, from the path $P_{uv}$ in $T_{MST}$.\n\nThis leads to a complete algorithm:\n1.  Compute an MST of the graph $G$, let it be $T_{MST}$, and its total weight, $W_{MST}$. Kruskal's algorithm is suitable for this. This partitions the edge set $E$ into MST edges and non-MST edges.\n\n2.  Initialize a variable for the second-best weight, $W_{2nd}$, to infinity ($\\infty$).\n\n3.  For each edge $e_{in} = (u, v)$ with weight $w_{in}$ that is not in $T_{MST}$:\n    a. Identify the unique path, $P_{uv}$, in $T_{MST}$ connecting vertices $u$ and $v$.\n    b. Find the edge $e_{out}$ on this path $P_{uv}$ that has the maximum weight, $w_{out}$. This can be done using a graph traversal like BFS or DFS on the tree $T_{MST}$.\n    c. If $w_{in} > w_{out}$, a new tree with a strictly greater weight can be formed. Calculate its weight: $W' = W_{MST} - w_{out} + w_{in}$.\n    d. Update the minimum second-best weight found so far: $W_{2nd} = \\min(W_{2nd}, W')$. The case $w_{in} = w_{out}$ corresponds to finding another MST of the same weight, which is not what we seek.\n\n4.  After iterating through all non-MST edges, if $W_{2nd}$ is still $\\infty$, no spanning tree with a strictly greater weight could be formed. In this case, the answer is $-1$. Otherwise, the answer is $W_{2nd}$.\n\nThis algorithm is guaranteed to find the second-best MST because it systematically considers all \"closest\" spanning trees to the initial MST—those that can be formed by a single edge swap—and finds the one with the smallest weight increase. It can be shown that the true second-best MST must be among these candidates.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the weight of the second-best MST for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (6, [(0,1,4), (0,2,3), (1,2,1), (1,3,2), (2,3,4), (3,4,2), (4,5,6), (3,5,5), (2,5,7), (0,5,10)]),\n        # Test case 2\n        (4, [(0,1,1), (1,2,1), (2,3,1), (3,0,1), (0,2,2), (1,3,2)]),\n        # Test case 3\n        (3, [(0,1,1), (1,2,1), (0,2,2)]),\n        # Test case 4\n        (3, [(0,1,5), (1,2,5), (0,2,5)]),\n    ]\n\n    results = []\n\n    for n, edges in test_cases:\n        # Step 1: Find an MST using Kruskal's algorithm\n        # A Disjoint Set Union (DSU) data structure for tracking connected components.\n        parent = list(range(n))\n        def find_set(v):\n            if v == parent[v]:\n                return v\n            parent[v] = find_set(parent[v])\n            return parent[v]\n\n        def union_sets(a, b):\n            a = find_set(a)\n            b = find_set(b)\n            if a != b:\n                parent[b] = a\n                return True\n            return False\n\n        # Sort edges by weight\n        edges.sort(key=lambda item: item[2])\n\n        mst_weight = 0\n        mst_edges = []\n        non_mst_edges = []\n\n        for u, v, w in edges:\n            if union_sets(u, v):\n                mst_weight += w\n                mst_edges.append((u, v, w))\n            else:\n                non_mst_edges.append((u, v, w))\n\n        # Check if graph was connected (MST should have n-1 edges)\n        if len(mst_edges) != n - 1 and n  0:\n            # This case corresponds to a disconnected graph.\n            # Problem assumes connected graphs, so no second-best exists.\n             results.append(-1)\n             continue\n\n        # Step 2: Build adjacency list for the MST for traversal\n        mst_adj = [[] for _ in range(n)]\n        for u, v, w in mst_edges:\n            mst_adj[u].append((v, w))\n            mst_adj[v].append((u, w))\n\n        # Step 3: Iterate through non-MST edges to find the second-best MST weight\n        second_best_weight = float('inf')\n\n        for u_in, v_in, w_in in non_mst_edges:\n            # Find the heaviest edge on the path between u_in and v_in in the MST\n            # using BFS to find the path and track max edge weight.\n            parent_map = {u_in: (None, 0)} # node -> (parent, weight_to_parent)\n            queue = [u_in]\n            \n            head = 0\n            path_found = False\n            while head  len(queue):\n                curr = queue[head]\n                head += 1\n                if curr == v_in:\n                    path_found = True\n                    break\n                for neighbor, weight in mst_adj[curr]:\n                    if neighbor not in parent_map:\n                        parent_map[neighbor] = (curr, weight)\n                        queue.append(neighbor)\n            \n            if not path_found: continue\n\n            max_weight_on_path = 0\n            curr_node = v_in\n            while curr_node != u_in and curr_node is not None:\n                p_node, p_weight = parent_map[curr_node]\n                if p_weight  max_weight_on_path:\n                    max_weight_on_path = p_weight\n                curr_node = p_node\n            \n            w_out = max_weight_on_path\n            \n            # We must have a strictly greater weight for the new tree\n            if w_in  w_out:\n                candidate_weight = mst_weight - w_out + w_in\n                if candidate_weight  second_best_weight:\n                    second_best_weight = candidate_weight\n\n        if second_best_weight == float('inf'):\n            results.append(-1)\n        else:\n            results.append(int(second_best_weight))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3253223"}]}