{"hands_on_practices": [{"introduction": "This first practice tackles a classic problem: counting all unique simple paths through a grid with obstacles. This exercise is fundamental for understanding how Depth-First Search can be adapted into a powerful backtracking algorithm to navigate a state space, in this case, the grid itself [@problem_id:3227616]. By implementing this, you will gain hands-on experience with the recursive nature of DFS and the critical role of state management in avoiding cycles and enumerating all valid solutions.", "problem": "You are given a finite rectangular grid that may contain obstacles. Model the grid as an undirected graph $G = (V, E)$, where $V$ is the set of grid cells that are not obstacles and $E$ contains an undirected edge between two cells if and only if they are horizontally or vertically adjacent and both are not obstacles. Let the grid have $m$ rows and $n$ columns, with row indices in $\\{0, 1, \\dots, m-1\\}$ and column indices in $\\{0, 1, \\dots, n-1\\}$. The start vertex is $s = (0, 0)$ (top-left corner) and the target vertex is $t = (m-1, n-1)$ (bottom-right corner). A path is a sequence of vertices $(v_0, v_1, \\dots, v_k)$ with $v_0 = s$, $v_k = t$, and each consecutive pair $(v_i, v_{i+1})$ is an edge in $E$. A path is simple if it does not visit any vertex more than once.\n\nTask: Using first principles from graph theory and depth-first search, design and implement a program that computes, for each of the specified test grids, the total number of distinct simple paths from $s$ to $t$. The algorithm must use depth-first search (DFS) and backtracking on the underlying graph defined by the grid; the path count must treat paths as distinct if and only if their sequences of vertices differ at any position.\n\nFundamental basis you may assume without proof: the definition of a graph $G = (V, E)$, the definition of a path and a simple path in a graph, and the existence of a depth-first search procedure that systematically explores adjacent vertices by recursing along edges and backtracking when no further progress is possible.\n\nBoundary conventions:\n- If $s \\notin V$ or $t \\notin V$ (that is, if either the start or the target is an obstacle), the number of simple paths is $0$.\n- If $s = t \\in V$ (that is, the grid has $m = 1$ and $n = 1$ with no obstacle at $(0,0)$), the number of simple paths is $1$ (the empty walk of length $0$ that starts and ends at $s$).\n\nMovement rules: At each step you may move from a cell to one of its four axis-aligned neighbors (up, down, left, right), provided the neighbor is within bounds and not an obstacle. No diagonal moves are allowed.\n\nYour program must not read any input. Instead, it must execute on the following fixed test suite and produce the required outputs.\n\nTest suite of parameter values:\n- Test $1$: $m = 2$, $n = 2$, obstacle set $\\mathcal{O} = \\varnothing$.\n- Test $2$: $m = 3$, $n = 3$, obstacle set $\\mathcal{O} = \\varnothing$.\n- Test $3$: $m = 3$, $n = 3$, obstacle set $\\mathcal{O} = \\{(1,1)\\}$.\n- Test $4$: $m = 1$, $n = 1$, obstacle set $\\mathcal{O} = \\varnothing$.\n- Test $5$: $m = 2$, $n = 3$, obstacle set $\\mathcal{O} = \\varnothing$.\n- Test $6$: $m = 2$, $n = 2$, obstacle set $\\mathcal{O} = \\{(1,1)\\}$.\n\nRequired output: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the tests above. Each result must be an integer giving the count of simple paths for that test. For example, the format is $[r_1,r_2,r_3,r_4,r_5,r_6]$, where $r_i$ is the integer result for Test $i$. There are no physical units involved in this problem. All angle units are irrelevant. Percentages do not apply. The final output must be exactly one line in the specified format.", "solution": "The problem asks for the number of distinct simple paths from a starting cell $s$ to a target cell $t$ on a rectangular grid that may contain obstacles. A simple path is one that does not visit any cell more than once. This problem can be modeled using graph theory and solved with a recursive backtracking algorithm based on depth-first search (DFS).\n\nFirst, we formalize the grid as a graph. Let the grid have $m$ rows and $n$ columns. A cell is represented by its coordinates $(r, c)$, where $r \\in \\{0, 1, \\dots, m-1\\}$ and $c \\in \\{0, 1, \\dots, n-1\\}$. We construct an undirected graph $G = (V, E)$. The set of vertices $V$ consists of all cells $(r, c)$ that are not obstacles. An undirected edge exists between two vertices $v_1 = (r_1, c_1)$ and $v_2 = (r_2, c_2)$ if and only if they are adjacent on the grid and both are in $V$. Adjacency is defined by the Manhattan distance being $1$, i.e., $|r_1 - r_2| + |c_1 - c_2| = 1$. The start vertex is $s=(0,0)$ and the target vertex is $t=(m-1, n-1)$.\n\nThe objective is to find the total number of simple paths from $s$ to $t$. A path is a sequence of vertices $(v_0, v_1, \\dots, v_k)$ where $v_0=s$, $v_k=t$, and for all $i \\in \\{0, \\dots, k-1\\}$, $(v_i, v_{i+1})$ is an edge in $E$. The path is simple if all $v_i$ in the sequence are distinct.\n\nThe problem of counting simple paths is generally \\#P-complete, but for the small grids specified, an exhaustive search is feasible. The required algorithm is a depth-first search with backtracking, which is a natural fit for enumerating all such paths.\n\nWe design a recursive function, let's call it $f(u)$, that computes the number of simple paths from the current vertex $u$ to the target $t$, assuming a set of vertices on the current path have already been visited. The state of the search needs to track the current position and the path taken so far to avoid cycles and ensure simplicity.\n\nLet $P$ be the set of vertices visited on the current path from $s$ to the predecessor of $u$. The function can be defined as $f(u, P)$.\n\n1.  **Base Case:** If the current vertex $u$ is the target vertex $t$, we have found one complete simple path. Therefore, the function should return $1$.\n    $$ f(t, P) = 1 $$\n\n2.  **Recursive Step:** If $u \\neq t$, we must explore its neighbors. Let $\\mathcal{N}(u)$ be the set of neighbors of $u$ in the graph $G$. The next vertex in any simple path starting from $u$ must be a neighbor of $u$ that has not yet been visited. The set of available neighbors is $\\mathcal{N}(u) \\setminus P$. The total number of simple paths from $u$ is the sum of the number of simple paths from each of these available neighbors. The new set of visited vertices for the recursive call will be $P \\cup \\{u\\}$.\n    $$ f(u, P) = \\sum_{v \\in \\mathcal{N}(u) \\setminus P} f(v, P \\cup \\{u\\}) $$\n\nIn an implementation, passing the set of visited nodes $P$ by value in each recursive call can be inefficient. A more common and efficient technique is to use a single stateful `visited` set that tracks the vertices of the path currently being built. The recursive function modifies this set as it traverses the graph. This is the essence of backtracking.\n\nThe algorithm proceeds as follows:\nLet `count_paths(u)` be the recursive function. A set `visited_nodes` is maintained outside the recursion or passed by reference.\n\n-   **Initialization:** Before starting the search, handle the boundary conditions. If $s$ or $t$ are obstacles (i.e., $s \\notin V$ or $t \\notin V$), no path is possible, and the count is $0$. If $s=t$ and $s \\in V$ (a $1 \\times 1$ grid with no obstacle), the count is $1$. The main algorithm is initiated by calling `count_paths(s)` with `visited_nodes` initially empty.\n\n-   **Recursive function `count_paths(u)`:**\n    1.  If $u = t$, a path has been found. Return $1$.\n    2.  Add $u$ to `visited_nodes`.\n    3.  Initialize a local variable `path_count = 0$.\n    4.  For each neighbor $v$ of $u$:\n        a. Check if $v$ is within grid bounds.\n        b. Check if $v$ is an obstacle.\n        c. Check if $v$ is in `visited_nodes`.\n        d. If $v$ is a valid, unvisited, non-obstacle neighbor, add the result of the recursive call `count_paths(v)` to `path_count`.\n    5.  Remove $u$ from `visited_nodes`. This is the critical backtracking step. By \"un-visiting\" $u$, we allow it to be part of other paths found later in the search. For instance, a path from $s$ might go through some vertex $w$ and then later explore a branch that leads to $u$.\n    6.  Return `path_count`.\n\nThe final result is the value returned by the initial call `count_paths(s)`. This algorithm systematically explores every possible simple path from $s$ to $t$, counts them, and returns the total. For each test case, we apply this procedure to the specified grid dimensions and obstacle set.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the simple path counting problem for a fixed test suite.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is (m, n, obstacles), where obstacles is a frozenset of (row, col) tuples.\n    test_cases = [\n        (2, 2, frozenset()),\n        (3, 3, frozenset()),\n        (3, 3, frozenset([(1, 1)])),\n        (1, 1, frozenset()),\n        (2, 3, frozenset()),\n        (2, 2, frozenset([(1, 1)]))\n    ]\n\n    results = []\n    for m, n, obstacles in test_cases:\n        start_node = (0, 0)\n        target_node = (m - 1, n - 1)\n\n        # Handle boundary conditions as per the problem statement.\n        if start_node in obstacles or target_node in obstacles:\n            results.append(0)\n            continue\n\n        # This set will store visited nodes for the current path being explored.\n        visited_nodes = set()\n\n        def dfs_count_paths(r, c):\n            \"\"\"\n            Recursively counts simple paths from (r, c) to target_node using DFS and backtracking.\n            - m, n, obstacles, target_node, and visited_nodes are available from the closure.\n            \"\"\"\n            # Base case: if the current node is the target, we have found one valid path.\n            if (r, c) == target_node:\n                return 1\n\n            # Mark the current node as visited for the current path.\n            visited_nodes.add((r, c))\n            \n            path_count = 0\n            \n            # Explore neighbors: down, right, up, left.\n            # Order does not matter for the total count.\n            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                nr, nc = r + dr, c + dc\n\n                # Check if the neighbor is valid.\n                # 1. Is it within the grid boundaries?\n                if not (0 <= nr < m and 0 <= nc < n):\n                    continue\n                \n                # 2. Has it been visited in the current path?\n                if (nr, nc) in visited_nodes:\n                    continue\n\n                # 3. Is it an obstacle?\n                if (nr, nc) in obstacles:\n                    continue\n\n                # If the neighbor is valid, recurse.\n                path_count += dfs_count_paths(nr, nc)\n\n            # Backtracking step: remove the current node from the visited set\n            # so it can be part of other paths.\n            visited_nodes.remove((r, c))\n            \n            return path_count\n\n        # Start the recursive search from the start node.\n        total_paths = dfs_count_paths(start_node[0], start_node[1])\n        results.append(total_paths)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3227616"}, {"introduction": "Moving from path enumeration to property testing, this exercise challenges you to determine if a graph is bipartite, a property with applications from scheduling to circuit design. You will use DFS not just to visit nodes, but to actively \"color\" them and detect conflicts [@problem_id:3227650]. This practice demonstrates how DFS can be used to efficiently uncover fundamental structural properties of a graph, specifically by relating the 2-coloring process to the absence of odd-length cycles.", "problem": "Consider an undirected finite graph that models a circuit layout, where vertices represent connection points and edges represent direct connections. A circuit layout is said to be $2$-colorable if one can assign one of two colors to each vertex so that no edge connects vertices of the same color. In graph theory terms, this is equivalent to the graph being bipartite. Your task is to derive, implement, and apply a Depth-First Search (DFS) based method to decide bipartiteness for a collection of undirected graphs.\n\nStart from the following foundational base: the definition of an undirected graph as a pair $(V, E)$ with vertex set $V$ and edge set $E$, a path as a sequence of vertices with consecutive pairs in $E$, a cycle as a closed path with at least three vertices and all vertices (except the first and last) distinct, and parity (evenness or oddness) of a path or cycle length measured in the number of edges. Define a $2$-coloring of a graph as a function $c: V \\to \\{0,1\\}$ such that for every edge $\\{u,v\\} \\in E$ one has $c(u) \\neq c(v)$. Use Depth-First Search (DFS) to explore the graph and attempt to construct such a coloring, and decide whether a conflict arises. No intermediate algorithms beyond these core definitions are permitted in the problem statement.\n\nYour program must be self-contained and must not read any input. It must encode the following test suite of undirected graphs, each represented by an adjacency list. The adjacency list is an ordered list of lists; the $i$-th inner list enumerates the neighbors of vertex $i$. All vertices are labeled with consecutive integers from $0$ through $n-1$ for a graph with $n$ vertices. Interpret each adjacency list symmetrically as an undirected graph.\n\nTest suite:\n- Case $1$ (even cycle, bipartite): $n=6$, adjacency list $[[1,5],[0,2],[1,3],[2,4],[3,5],[4,0]]$.\n- Case $2$ (odd cycle, not bipartite): $n=3$, adjacency list $[[1,2],[0,2],[0,1]]$.\n- Case $3$ (empty graph, vacuously bipartite): $n=0$, adjacency list $[]$.\n- Case $4$ (single vertex, bipartite): $n=1$, adjacency list $[[]]$.\n- Case $5$ (disconnected, contains an odd cycle, not bipartite): $n=6$, adjacency list $[[1],[0,2],[1],[4,5],[3,5],[3,4]]$.\n- Case $6$ (parallel edges but bipartite): $n=2$, adjacency list $[[1,1],[0,0]]$.\n- Case $7$ (self-loop, not bipartite): $n=1$, adjacency list $[[0]]$.\n\nDesign requirements:\n- Use Depth-First Search (DFS) to attempt to assign colors $0$ and $1$ to vertices along discovery edges, alternating the color on each step. If a neighbor already has the same color as the current vertex, report the graph is not bipartite; otherwise, continue. Handle disconnected graphs by initiating DFS from every uncolored vertex.\n- Self-loops are immediate violations because an edge $\\{v,v\\}$ forces $c(v) \\neq c(v)$, which is impossible.\n- Multiple edges between two vertices do not change bipartiteness; however, your DFS must be robust to such duplicates in the adjacency lists.\n- Time complexity and space complexity must be linear in the size of the graph, that is, $O(|V|+|E|)$ time and $O(|V|)$ space.\n\nFinal output format:\nYour program should produce a single line of output containing the results for the seven cases as a comma-separated list enclosed in square brackets, where each result is a boolean indicating whether the corresponding graph is bipartite (true means bipartite, false means not bipartite), for example $[r_1,r_2,\\dots,r_7]$ where each $r_i$ is either $\\mathrm{True}$ or $\\mathrm{False}$ in standard programming language boolean notation. No other text should be printed.", "solution": "The problem requires an algorithmic method based on Depth-First Search (DFS) to determine if a given undirected graph is bipartite. A graph is bipartite if and only if it is $2$-colorable.\n\n**Theoretical Foundation**\n\nAn undirected graph $G = (V, E)$, where $V$ is the set of vertices and $E$ is the set of edges, is defined as bipartite if its vertex set $V$ can be partitioned into two disjoint and independent sets, $V_0$ and $V_1$, such that every edge in $E$ connects a vertex in $V_0$ to one in $V_1$. An equivalent formulation is the existence of a $2$-coloring function, $c: V \\to \\{0, 1\\}$, such that for every edge $\\{u,v\\} \\in E$, the condition $c(u) \\neq c(v)$ holds.\n\nA fundamental theorem in graph theory states that a graph is bipartite if and only if it contains no cycles of odd length. A cycle is a path of length at least one that starts and ends at the same vertex. The length of a cycle is the number of edges it contains. A self-loop, i.e., an edge of the form $\\{v,v\\}$, constitutes a cycle of length $1$, which is odd. Therefore, any graph with a self-loop is not bipartite.\n\n**Algorithmic Strategy: $2$-Coloring via Depth-First Search**\n\nWe can determine if a graph is bipartite by attempting to construct a valid $2$-coloring using Depth-First Search (DFS). The algorithm proceeds as follows:\n\n1.  **Initialization**: We maintain a color array, `colors`, of size $|V|$, where `colors[i]` stores the color assigned to vertex $i$. We initialize this array with a special value (e.g., $-1$) to indicate that no vertex has been colored yet.\n\n2.  **Handling Disconnected Components**: A graph may consist of multiple disjoint connected components. The bipartiteness of the graph as a whole depends on the bipartiteness of each individual component. Therefore, we iterate through all vertices from $v=0$ to $|V|-1$. If a vertex $v$ has not yet been colored (i.e., `colors[v]` is $-1$), it belongs to a new, unexplored component. We initiate a DFS traversal starting from this vertex $v$, assigning it an initial color, say $0$.\n\n3.  **DFS Traversal and Coloring**: The DFS procedure, which can be implemented recursively, performs the coloring and conflict detection:\n    - When visiting a vertex $u$ with an assigned color $c(u)$, we iterate through all its neighbors $w$ in the adjacency list.\n    - **Case A: Neighbor is uncolored**. If a neighbor $w$ has not been colored yet (i.e., `colors[w]` is $-1$), we assign it the opposite color of $u$, i.e., $c(w) = 1 - c(u)$. We then recursively call DFS on $w$. If this recursive call detects a conflict within its subtree, the conflict is propagated back, and we conclude the graph is not bipartite.\n    - **Case B: Neighbor is already colored**. If a neighbor $w$ has already been colored, we must check for a conflict. A conflict arises if $w$ has the same color as $u$, i.e., if $c(w) = c(u)$. This discovery implies that there is an edge connecting two vertices of the same color, which violates the condition for $2$-coloring. This situation corresponds to the discovery of an odd-length cycle in the graph. The path from the component's starting vertex to $u$ and the path from the same start vertex to $w$, combined with the edge $\\{u,w\\}$, form a cycle. If $u$ and $w$ have the same color, their distances (in terms of edges) from the start vertex have the same parity. The length of the cycle is the sum of these path lengths plus one. `(even + even + 1)` or `(odd + odd + 1)` both result in an odd number. Thus, a color conflict signals an odd cycle.\n\n4.  **Termination**: If the DFS traversal for a component completes without any color conflicts, that component is bipartite. The main loop then continues to search for other uncolored components. If the entire set of vertices is processed and no conflict is ever found, the entire graph is bipartite. If a conflict is found at any point, the algorithm can terminate immediately and report that the graph is not bipartite.\n\n**Complexity Analysis**\n-   **Time Complexity**: Each vertex is visited exactly once as the root of a DFS call (for each component) and processed. Each edge $\\{u, v\\}$ is examined twice in an adjacency list representation (once from $u$'s list, once from $v$'s list). The work done per vertex and per edge is constant. The overall time complexity is therefore linear in the size of the graph, which is $O(|V| + |E|)$.\n-   **Space Complexity**: The primary space requirement is for the `colors` array, which has a size of $|V|$. Additionally, the recursion stack for DFS can reach a depth of at most $|V|$ in the worst-case scenario (a path graph). Thus, the space complexity is $O(|V|)$.\n\nThis DFS-based approach correctly addresses the problem requirements, including robustness to disconnected graphs, self-loops (which create an immediate conflict: $c(v)=c(v)$ is false), and parallel edges (which are redundant checks that do not alter the outcome).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bipartite checking problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: n=6, even cycle, bipartite\n        (6, [[1, 5], [0, 2], [1, 3], [2, 4], [3, 5], [4, 0]]),\n        # Case 2: n=3, odd cycle, not bipartite\n        (3, [[1, 2], [0, 2], [0, 1]]),\n        # Case 3: n=0, empty graph, vacuously bipartite\n        (0, []),\n        # Case 4: n=1, single vertex, bipartite\n        (1, [[]]),\n        # Case 5: n=6, disconnected with odd cycle, not bipartite\n        (6, [[1], [0, 2], [1], [4, 5], [3, 5], [3, 4]]),\n        # Case 6: n=2, parallel edges, bipartite\n        (2, [[1, 1], [0, 0]]),\n        # Case 7: n=1, self-loop, not bipartite\n        (1, [[0]]),\n    ]\n\n    results = []\n    for n, adj in test_cases:\n        results.append(is_bipartite(n, adj))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef is_bipartite(n, adj):\n    \"\"\"\n    Checks if a graph is bipartite using DFS-based 2-coloring.\n\n    Args:\n        n (int): The number of vertices, |V|.\n        adj (list of list of int): The adjacency list of the graph.\n\n    Returns:\n        bool: True if the graph is bipartite, False otherwise.\n    \"\"\"\n    if n == 0:\n        return True\n\n    # colors[i] = -1: uncolored, 0: color 0, 1: color 1\n    colors = [-1] * n\n\n    def dfs(u, color):\n        \"\"\"\n        Recursive DFS to perform 2-coloring.\n\n        Args:\n            u (int): The current vertex.\n            color (int): The color to assign to the current vertex (0 or 1).\n\n        Returns:\n            bool: True if the component is bipartite, False if a conflict is found.\n        \"\"\"\n        colors[u] = color\n        for v in adj[u]:\n            if colors[v] == -1:\n                # If neighbor is uncolored, color with the opposite color\n                # and recurse. If recursion finds a conflict, propagate False.\n                if not dfs(v, 1 - color):\n                    return False\n            elif colors[v] == colors[u]:\n                # If neighbor has the same color, an odd cycle is found.\n                return False\n        return True\n\n    # Iterate through all vertices to handle disconnected graphs\n    for i in range(n):\n        if colors[i] == -1:\n            # If a component is not bipartite, the whole graph is not.\n            if not dfs(i, 0):\n                return False\n\n    return True\n\nsolve()\n```", "id": "3227650"}, {"introduction": "This final practice explores a more advanced application: finding the longest path in a weighted Directed Acyclic Graph (DAG). While finding the longest path is notoriously hard in general graphs, the special structure of a DAG makes it solvable efficiently, a principle at the heart of scheduling algorithms like the Critical Path Method [@problem_id:3227722]. This exercise will guide you to fuse Depth-First Search with memoization, revealing its deep connection to dynamic programming and the power of solving problems in a reverse topological order.", "problem": "You are given a directed acyclic graph (DAG) with nonnegative integer edge weights. Your task is twofold: first, starting only from the core definitions of depth-first search (DFS) and directed acyclic graphs (DAGs), derive a correct modification of DFS that computes the length of the longest path in any DAG. Your derivation must identify a recursive or loop invariant grounded in fundamental graph-theoretic definitions and justify termination and correctness using the structural properties of a DAG and the ordering induced by DFS. Second, apply your derived method to the concrete DAG below and compute the length of the longest path. The final answer must be a single real-valued number equal to the maximum total weight along any directed path in the graph.\n\nThe vertex set is $\\{1,2,3,4,5,6,7,8,9\\}$, and every edge is directed from a vertex with a smaller label to a vertex with a larger label. Each directed edge is annotated with a nonnegative integer weight. The edges are:\n- $(1 \\to 2,\\, 3)$, $(1 \\to 3,\\, 2)$, $(1 \\to 4,\\, 5)$\n- $(2 \\to 5,\\, 4)$, $(2 \\to 6,\\, 6)$\n- $(3 \\to 4,\\, 1)$, $(3 \\to 6,\\, 2)$, $(3 \\to 7,\\, 7)$\n- $(4 \\to 6,\\, 1)$, $(4 \\to 7,\\, 4)$, $(4 \\to 8,\\, 2)$\n- $(5 \\to 7,\\, 3)$, $(5 \\to 8,\\, 5)$\n- $(6 \\to 8,\\, 4)$, $(6 \\to 9,\\, 3)$\n- $(7 \\to 8,\\, 1)$, $(7 \\to 9,\\, 8)$\n- $(8 \\to 9,\\, 2)$\n\nAssume the length of a path is the sum of the weights of its directed edges. If a vertex has no outgoing edges, the length of the longest path that starts at that vertex is $0$. Express your final answer as a single number. No rounding is necessary.", "solution": "The problem requires the derivation of an algorithm to find the length of the longest path in a directed acyclic graph (DAG) based on depth-first search (DFS), followed by an application of this algorithm to a specific graph.\n\n**Part 1: Derivation of the Algorithm**\n\nLet $G = (V, E)$ be a directed acyclic graph (DAG), where $V$ is the set of vertices and $E$ is the set of directed edges. Let $w(u, v)$ be the nonnegative integer weight of an edge $(u, v) \\in E$. The length of a path is the sum of the weights of its edges. A path with a single vertex has length $0$.\n\nOur goal is to find the length of the longest path in $G$. Let us define $L(u)$ as the length of the longest path starting at vertex $u \\in V$. The length of the longest path in the entire graph is then $\\max_{u \\in V} L(u)$.\n\nA fundamental property of a path starting at $u$ is that it must begin with an edge $(u, v)$ to one of its neighbors $v$, followed by a path starting from $v$. To maximize the length of the path starting at $u$, we must choose the neighbor $v$ that maximizes the sum of the edge weight $w(u, v)$ and the length of the longest path starting from $v$, which is $L(v)$. This gives rise to a recursive definition for $L(u)$:\n\n1.  If a vertex $u$ has no outgoing edges (it is a terminal or sink vertex), any path starting at $u$ consists only of the vertex $u$ itself. The length of such a path is defined as $0$. Thus, for a terminal vertex $u$, $L(u) = 0$. This forms the base case of our recursion.\n2.  If a vertex $u$ has outgoing edges, the longest path starting from $u$ is found by considering all its neighbors. For each neighbor $v$, a path starting with the edge $(u,v)$ has a maximum length of $w(u,v) + L(v)$. We must choose the neighbor $v$ that maximizes this value. Therefore,\n    $$L(u) = \\max_{(u,v) \\in E} \\{ w(u,v) + L(v) \\}$$\n\nThis recurrence relation shows that to compute $L(u)$, we need the values of $L(v)$ for all successors $v$ of $u$. The acyclic nature of a DAG is critical here. Since there are no cycles, the computation of $L(u)$ will never depend on itself, either directly or indirectly through a chain of successors.\n\nWe can solve this system of recurrences using a modification of Depth-First Search (DFS). A standard recursive DFS explores a graph by visiting a vertex and then recursively calling itself on all unvisited neighbors. When a recursive call `DFS(v)` returns to its caller `DFS(u)`, it signifies that the traversal of the entire subgraph reachable from $v$ is complete. This point in the execution, after all recursive calls for a vertex's children have finished, is known as the post-order processing step.\n\nThe ordering of vertices by their finishing times in a DFS traversal of a DAG is a reverse topological sort. This means that for any edge $(u,v) \\in E$, the finish time of $v$ is less than the finish time of $u$. Consequently, if we compute $L(u)$ in the post-order step of a DFS traversal of $u$, we are guaranteed that the values $L(v)$ for all its successors $v$ have already been computed.\n\nThis leads to the following algorithm, which uses memoization (a form of dynamic programming) to store the results for $L(u)$ and avoid recomputation. Let `dist[u]` be an array to store the computed value of $L(u)$, initialized to a sentinel value (e.g., $-\\infty$ or $-1$) indicating that the value is not yet computed.\n\n**Algorithm: `LongestPathDFS(u)`**\n1.  If `dist[u]` is not the sentinel value, return `dist[u]`.\n2.  Initialize `max_len = 0`. This handles the base case for terminal vertices.\n3.  For each vertex $v$ such that $(u, v) \\in E$:\n    a. Calculate `path_len = w(u, v) + LongestPathDFS(v)`.\n    b. Update `max_len = max(max_len, path_len)`.\n4.  Store the result: `dist[u] = max_len`.\n5.  Return `dist[u]`.\n\nTo find the longest path in the entire graph, we invoke this function for every vertex $u \\in V$ and take the maximum of the results. If the graph has known source vertices (in-degree $0$), it is sufficient to start the search from them.\n\n**Justification:**\n- **Recursive Invariant:** The function `LongestPathDFS(u)` correctly computes $L(u)$. The base case, a terminal vertex, correctly returns $0$. The recursive step correctly implements the recurrence relation $L(u) = \\max_{(u,v) \\in E} \\{w(u,v) + L(v)\\}$, under the assumption that the recursive calls `LongestPathDFS(v)` are correct.\n- **Termination:** In a DAG, the sequence of recursive calls follows a simple path in the graph. Since there are no cycles, the recursion depth is bounded by the number of vertices, and each vertex's $L(u)$ value is computed exactly once due to memoization. The algorithm processes each vertex and edge once, leading to a time complexity of $O(|V| + |E|)$.\n- **Correctness:** The correctness follows from the principle of optimality inherent in the recurrence relation and the fact that the reverse topological ordering induced by the DFS post-order traversal ensures that all subproblems $L(v)$ are solved before they are needed to compute $L(u)$.\n\n**Part 2: Application to the Given DAG**\n\nThe given graph has the vertex set $V = \\{1, 2, 3, 4, 5, 6, 7, 8, 9\\}$. A crucial property is that for every edge $(u \\to v)$, $u < v$. This property guarantees that the graph is a DAG and that the vertex labels $(1, 2, \\dots, 9)$ constitute a topological sort. We can therefore compute the values of $L(u)$ by iterating through the vertices in reverse topological order, from $u=9$ down to $u=1$. This is equivalent to the outcome of the memoized recursive DFS algorithm.\n\nLet $L(u)$ denote the length of the longest path starting at vertex $u$.\n\n-   **Vertex 9:** $L(9) = 0$, as it is a terminal vertex.\n\n-   **Vertex 8:** The only outgoing edge is $(8 \\to 9, 2)$.\n    $L(8) = w(8, 9) + L(9) = 2 + 0 = 2$.\n\n-   **Vertex 7:** Outgoing edges are $(7 \\to 8, 1)$ and $(7 \\to 9, 8)$.\n    $L(7) = \\max \\{ w(7, 8) + L(8), w(7, 9) + L(9) \\} = \\max \\{ 1 + 2, 8 + 0 \\} = \\max \\{ 3, 8 \\} = 8$.\n\n-   **Vertex 6:** Outgoing edges are $(6 \\to 8, 4)$ and $(6 \\to 9, 3)$.\n    $L(6) = \\max \\{ w(6, 8) + L(8), w(6, 9) + L(9) \\} = \\max \\{ 4 + 2, 3 + 0 \\} = \\max \\{ 6, 3 \\} = 6$.\n\n-   **Vertex 5:** Outgoing edges are $(5 \\to 7, 3)$ and $(5 \\to 8, 5)$.\n    $L(5) = \\max \\{ w(5, 7) + L(7), w(5, 8) + L(8) \\} = \\max \\{ 3 + 8, 5 + 2 \\} = \\max \\{ 11, 7 \\} = 11$.\n\n-   **Vertex 4:** Outgoing edges are $(4 \\to 6, 1)$, $(4 \\to 7, 4)$, and $(4 \\to 8, 2)$.\n    $L(4) = \\max \\{ w(4, 6) + L(6), w(4, 7) + L(7), w(4, 8) + L(8) \\} = \\max \\{ 1 + 6, 4 + 8, 2 + 2 \\} = \\max \\{ 7, 12, 4 \\} = 12$.\n\n-   **Vertex 3:** Outgoing edges are $(3 \\to 4, 1)$, $(3 \\to 6, 2)$, and $(3 \\to 7, 7)$.\n    $L(3) = \\max \\{ w(3, 4) + L(4), w(3, 6) + L(6), w(3, 7) + L(7) \\} = \\max \\{ 1 + 12, 2 + 6, 7 + 8 \\} = \\max \\{ 13, 8, 15 \\} = 15$.\n\n-   **Vertex 2:** Outgoing edges are $(2 \\to 5, 4)$ and $(2 \\to 6, 6)$.\n    $L(2) = \\max \\{ w(2, 5) + L(5), w(2, 6) + L(6) \\} = \\max \\{ 4 + 11, 6 + 6 \\} = \\max \\{ 15, 12 \\} = 15$.\n\n-   **Vertex 1:** Outgoing edges are $(1 \\to 2, 3)$, $(1 \\to 3, 2)$, and $(1 \\to 4, 5)$.\n    $L(1) = \\max \\{ w(1, 2) + L(2), w(1, 3) + L(3), w(1, 4) + L(4) \\} = \\max \\{ 3 + 15, 2 + 15, 5 + 12 \\} = \\max \\{ 18, 17, 17 \\} = 18$.\n\nThe lengths of the longest paths starting from each vertex are:\n$L(1)=18$, $L(2)=15$, $L(3)=15$, $L(4)=12$, $L(5)=11$, $L(6)=6$, $L(7)=8$, $L(8)=2$, $L(9)=0$.\n\nThe length of the longest path in the entire graph is the maximum of these values: $\\max \\{18, 15, 15, 12, 11, 6, 8, 2, 0\\} = 18$. This value corresponds to the longest path starting from the unique source vertex, vertex $1$.\nThe path is $1 \\to 2 \\to 5 \\to 7 \\to 9$, with total weight $w(1,2)+w(2,5)+w(5,7)+w(7,9) = 3+4+3+8 = 18$.", "answer": "$$\\boxed{18}$$", "id": "3227722"}]}