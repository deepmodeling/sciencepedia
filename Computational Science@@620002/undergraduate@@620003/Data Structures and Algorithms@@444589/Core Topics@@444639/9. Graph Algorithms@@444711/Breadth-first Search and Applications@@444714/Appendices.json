{"hands_on_practices": [{"introduction": "Real-world pathfinding often involves more than just finding the shortest route; it involves avoiding obstacles or restricted areas. This first exercise challenges you to adapt the standard Breadth-First Search to find a shortest path while respecting a set of \"forbidden\" nodes. This practice is fundamental to understanding how to incorporate real-world constraints into graph traversal algorithms by effectively pruning the search space. [@problem_id:3218360]", "problem": "Consider a finite, simple, unweighted graph $G=(V,E)$ where $V$ is a finite set of nodes labeled by distinct integers and $E \\subseteq \\{\\,(u,v)\\mid u,v \\in V,\\, u \\neq v\\,\\}$ is a set of undirected edges. A path is a sequence of nodes $(v_0,v_1,\\ldots,v_k)$ such that for all $i \\in \\{0,1,\\ldots,k-1\\}$, $(v_i,v_{i+1}) \\in E$. The length of a path is the number of edges in the sequence, which equals $k$. Given two distinct nodes $s,t \\in V$ and a set of forbidden nodes $F \\subseteq V$, an admissible path from $s$ to $t$ is a path that starts at $s$, ends at $t$, and contains no node from $F$. If either $s \\in F$ or $t \\in F$, there is no admissible path by definition.\n\nYou must compute the shortest admissible path from $s$ to $t$ in $G$, if it exists, under the following deterministic tie-breaking rule: among all admissible paths of minimal length, return the path with the lexicographically smallest sequence of nodes. To enforce determinism, when exploring neighbors, always consider neighbors in ascending numerical order. If no admissible path exists, return the empty list.\n\nThe fundamental base you may assume is the following: in an unweighted graph, the breadth-first search expansion layers correspond to shortest-path distances from a source node, and restricting to an induced subgraph preserves path lengths relative to that subgraph.\n\nYour program must implement this computation and produce outputs for the following test suite. In each case, interpret $E$ as an undirected set: for each $(u,v) \\in E$, both $(u,v)$ and $(v,u)$ are allowed moves.\n\n- Test case $1$ (happy path with a detour forced by a forbidden node):\n  - $V = \\{0,1,2,3,4,5,6\\}$.\n  - $E = \\{(0,1),(0,3),(1,2),(2,3),(2,5),(5,6),(3,4),(4,6)\\}$.\n  - $s = 0$, $t = 6$, $F = \\{3\\}$.\n  - Expected behavior: the direct route through node $3$ is disallowed; find the shortest admissible path.\n\n- Test case $2$ (boundary condition where $s=t$):\n  - $V = \\{0,1,2\\}$.\n  - $E = \\{(0,1),(1,2)\\}$.\n  - $s = 2$, $t = 2$, $F = \\varnothing$.\n  - Expected behavior: the shortest admissible path has length $0$ and is the single-node sequence.\n\n- Test case $3$ (target is forbidden):\n  - $V = \\{0,1,2,3,4\\}$.\n  - $E = \\{(0,1),(1,4),(0,2),(2,3),(3,4)\\}$.\n  - $s = 0$, $t = 4$, $F = \\{4\\}$.\n  - Expected behavior: no admissible path exists.\n\n- Test case $4$ (source is forbidden):\n  - $V = \\{0,1,2,3\\}$.\n  - $E = \\{(0,1),(1,2),(2,3)\\}$.\n  - $s = 1$, $t = 3$, $F = \\{1\\}$.\n  - Expected behavior: no admissible path exists.\n\n- Test case $5$ (multiple shortest admissible paths, require lexicographic tie-breaking):\n  - $V = \\{0,1,2,3,4\\}$.\n  - $E = \\{(0,1),(1,4),(0,2),(2,4),(0,3),(3,4)\\}$.\n  - $s = 0$, $t = 4$, $F = \\varnothing$.\n  - Expected behavior: there are multiple admissible paths of minimal length; return the lexicographically smallest one.\n\nOutput specification: Your program should produce a single line of output containing the results for the above five test cases as a comma-separated list enclosed in square brackets. Each test case result must be a list of integers representing the sequence of nodes on the returned path from $s$ to $t$ (inclusive), or the empty list $[]$ if no admissible path exists. For example, an output might look like $[[0,1,2,5,6],[2],[],[],[0,1,4]]$. There are no physical quantities in this problem; therefore, no physical units are required. The only acceptable data types in the final output are lists of integers, aggregated into a single top-level list as specified.", "solution": "The problem statement is evaluated as valid. There exists a minor contradiction where the general problem description specifies \"two distinct nodes $s,t \\in V$\", but Test Case $2$ provides an instance where $s=t$. This is categorized as an ambiguity (a violation of Checklist Item 5: Ill-Posed or Poorly Structured). However, the test case is explicitly labeled as a \"boundary condition where $s=t$\", which serves to clarify the intended behavior. The problem is therefore solvable by interpreting the specific test cases as ground truth that refines or supersedes the general description. All other aspects of the problem are scientifically grounded, well-posed, and objective.\n\nThe task is to find a shortest path between a source node $s$ and a target node $t$ in a finite, simple, unweighted graph $G=(V,E)$. The path must be \"admissible,\" meaning it cannot pass through any node in a given forbidden set $F$. Furthermore, among all shortest admissible paths, the one that is lexicographically smallest must be chosen.\n\nThe fundamental principle for finding shortest paths in an unweighted graph is the Breadth-First Search (BFS) algorithm. BFS explores the graph layer by layer from the source node $s$. This guarantees that the first time the target node $t$ is reached, the path taken is one of minimal length (i.e., has the fewest edges).\n\nThe solution must incorporate three main features into the standard BFS framework:\n1.  **Handling Forbidden Nodes**: The constraint that paths must be admissible is addressed by treating nodes in the set $F$ as if they are not part of the graph. The problem defines that if $s \\in F$ or $t \\in F$, no admissible path exists. This forms a base case that must be checked before initiating the search. During the search, any neighbor node $v$ that belongs to $F$ is ignored and not added to the exploration queue.\n2.  **Lexicographical Tie-Breaking**: The problem requires the lexicographically smallest path among all shortest paths. This is achieved by enforcing a deterministic order of exploration. The rule \"when exploring neighbors, always consider neighbors in ascending numerical order\" ensures this property. When the BFS expands from a node $u$, it enqueues its neighbors in sorted ascending order. Let us consider two paths $P_1 = (s, \\dots, u, v_1, \\dots, t)$ and $P_2 = (s, \\dots, u, v_2, \\dots, t)$ of the same minimal length, which first differ at the node after a common prefix $(s, \\dots, u)$. If $v_1 < v_2$, then the BFS will explore from $v_1$ before exploring from $v_2$. Consequently, the sub-path from $v_1$ will be explored, and the target $t$ will be found via this route, before the search proceeds from $v_2$ at the same depth. The algorithm terminates upon first finding $t$, thereby guaranteeing that the discovered path is not only of minimal length but also the lexicographically smallest.\n3.  **Path Reconstruction**: A standard BFS finds the shortest path *length* but does not inherently store the path itself. To reconstruct the path, we use a parent map, a data structure (e.g., a dictionary) that stores the predecessor of each visited node along the search path. For a node $v$ visited from node $u$, we set `parent[v] = u`. Once the target $t$ is found, the path can be reconstructed by backtracking from $t$ to $s$ using this parent map and then reversing the resulting sequence.\n\nThe complete algorithm is as follows:\n\n1.  **Preprocessing and Initial Checks**:\n    - Given the set of nodes $V$, edges $E$, source $s$, target $t$, and forbidden nodes $F$.\n    - Check if $s \\in F$ or $t \\in F$. If so, no admissible path exists; return an empty list.\n    - If $s = t$, the shortest path is of length $0$ and consists of the node itself. Return the list $[s]$.\n    - Construct an adjacency list representation of the graph $G$, where for each node $u \\in V$, the list of its neighbors is sorted in ascending numerical order. This is critical for the lexicographical tie-breaking rule.\n\n2.  **BFS Execution**:\n    - Initialize a queue for BFS and add the source node $s$: `queue = [s]`.\n    - Initialize a set of visited nodes to prevent cycles and redundant exploration, containing only the source: `visited = {s}`.\n    - Initialize a parent map to reconstruct the path: `parents = {s: None}`.\n\n3.  **Graph Traversal**:\n    - While the queue is not empty:\n        - Dequeue the current node $u$.\n        - If $u = t$, the shortest, lexicographically smallest path has been found. Proceed to path reconstruction.\n        - For each neighbor $v$ of $u$ (in pre-sorted ascending order):\n            - If $v$ has not been visited and $v \\notin F$:\n                - Mark $v$ as visited: add $v$ to `visited`.\n                - Record the parent: `parents[v] = u`.\n                - Enqueue $v$: `queue.append(v)`.\n\n4.  **Path Reconstruction or Failure**:\n    - If the loop finishes (queue is empty) and the target $t$ was not reached (i.e., `t` is not in the `parents` map), then no admissible path exists. Return an empty list.\n    - If $t$ was reached, backtrack from $t$ to $s$ using the `parents` map. Initialize a path list with `path = [t]`. While the last node in the path is not $s$, prepend its parent: `path.insert(0, parents[path[0]])`. Return the reconstructed `path`.\n\nThis algorithm correctly and efficiently computes the required path, satisfying all constraints of the problem.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef find_shortest_admissible_path(V, E, s, t, F):\n    \"\"\"\n    Computes the shortest admissible path from s to t with lexicographical tie-breaking.\n\n    Args:\n        V (set): The set of nodes.\n        E (set): The set of undirected edges as tuples.\n        s (int): The source node.\n        t (int): The target node.\n        F (set): The set of forbidden nodes.\n\n    Returns:\n        list: The sequence of nodes in the path, or an empty list if no path exists.\n    \"\"\"\n    # Step 1: Initial checks for admissibility.\n    if s in F or t in F:\n        return []\n\n    # Handle the boundary condition where s and t are the same.\n    if s == t:\n        return [s]\n\n    # Build the adjacency list with sorted neighbors for deterministic exploration.\n    adj = {node: [] for node in V}\n    for u, v in E:\n        adj[u].append(v)\n        adj[v].append(u)\n    for node in adj:\n        adj[node].sort()\n    \n    # Step 2: BFS Initialization\n    # A standard Python list used as a queue with pop(0) is slow.\n    # collections.deque is a double-ended queue optimized for appends and pops from either end.\n    queue = collections.deque([s])\n    visited = {s}\n    # Parent map for path reconstruction.\n    parents = {s: None}\n\n    # Step 3: BFS Traversal\n    path_found = False\n    while queue:\n        u = queue.popleft()\n\n        if u == t:\n            path_found = True\n            break\n\n        for v in adj.get(u, []):\n            if v not in visited and v not in F:\n                visited.add(v)\n                parents[v] = u\n                queue.append(v)\n\n    # Step 4: Path Reconstruction\n    if not path_found:\n        return []\n\n    path = []\n    curr = t\n    while curr is not None:\n        path.append(curr)\n        curr = parents[curr]\n    \n    return path[::-1] # Reverse the path to get s to t order.\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        {\n            \"V\": {0, 1, 2, 3, 4, 5, 6},\n            \"E\": {(0, 1), (0, 3), (1, 2), (2, 3), (2, 5), (5, 6), (3, 4), (4, 6)},\n            \"s\": 0, \"t\": 6, \"F\": {3}\n        },\n        {\n            \"V\": {0, 1, 2},\n            \"E\": {(0, 1), (1, 2)},\n            \"s\": 2, \"t\": 2, \"F\": set()\n        },\n        {\n            \"V\": {0, 1, 2, 3, 4},\n            \"E\": {(0, 1), (1, 4), (0, 2), (2, 3), (3, 4)},\n            \"s\": 0, \"t\": 4, \"F\": {4}\n        },\n        {\n            \"V\": {0, 1, 2, 3},\n            \"E\": {(0, 1), (1, 2), (2, 3)},\n            \"s\": 1, \"t\": 3, \"F\": {1}\n        },\n        {\n            \"V\": {0, 1, 2, 3, 4},\n            \"E\": {(0, 1), (1, 4), (0, 2), (2, 4), (0, 3), (3, 4)},\n            \"s\": 0, \"t\": 4, \"F\": set()\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_shortest_admissible_path(\n            case[\"V\"], case[\"E\"], case[\"s\"], case[\"t\"], case[\"F\"]\n        )\n        results.append(result)\n\n    # Custom formatter to match the output specification (no spaces).\n    def format_list(lst):\n        return f\"[{','.join(map(str, lst))}]\"\n    \n    formatted_results = [format_list(res) for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "3218360"}, {"introduction": "Many routing problems require a path to not only reach a destination but also to pass through a specific checkpoint. This problem extends the shortest path concept by adding an intermediate vertex constraint. You will see how a complex pathfinding goal can be elegantly decomposed into two independent shortest-path subproblems, each solvable with a standard BFS, reinforcing the modular power of this algorithm. [@problem_id:3218504]", "problem": "You are given finite, unweighted, directed graphs. For each graph, vertices are labeled by integers from $0$ to $n-1$, and edges are ordered pairs $(u,v)$ indicating a directed edge from $u$ to $v$. A path from a source vertex $s$ to a target vertex $t$ is a finite sequence of vertices $(v_0,v_1,\\dots,v_k)$ such that $v_0=s$, $v_k=t$, and for each $i\\in\\{0,1,\\dots,k-1\\}$ there is an edge $(v_i,v_{i+1})$. The length of a path is the number of edges on it, which is $k$. In this task, you must find a shortest path from $s$ to $t$ that passes through a specified intermediate vertex $w$ at least once (the intermediate vertex may coincide with $s$ or $t$). If multiple shortest such paths exist, choose the one that is lexicographically smallest when comparing the sequences of vertex labels. If no path from $s$ to $t$ that includes $w$ exists, report that no solution exists.\n\nYour program must compute, for each test case, the integer length $L$ of the shortest path from $s$ to $t$ that passes through $w$, and the corresponding path $P$ represented as a list of vertex labels. If no path exists, output $L=-1$ and $P$ as the empty list $[]$.\n\nUse only the foundational definitions of graphs and paths. Do not rely on any specialized heuristics that are not derivable from core definitions and widely accepted facts in the study of data structures and algorithms.\n\nTest Suite:\n- Test Case $A$:\n  - Number of vertices: $n=6$ (vertices $0,1,2,3,4,5$).\n  - Directed edges: $((0,1),(0,2),(1,3),(2,3),(3,4),(4,5),(1,5),(2,5))$.\n  - Source $s=0$, target $t=5$, intermediate $w=3$.\n- Test Case $B$:\n  - Number of vertices: $n=7$ (vertices $0,1,2,3,4,5,6$).\n  - Directed edges: $((0,1),(0,2),(1,3),(2,3),(3,4),(3,5),(4,6),(5,6))$.\n  - Source $s=0$, target $t=6$, intermediate $w=3$.\n- Test Case $C$:\n  - Number of vertices: $n=4$ (vertices $0,1,2,3$).\n  - Directed edges: $((0,1),(1,2),(2,3))$.\n  - Source $s=0$, target $t=3$, intermediate $w=0$.\n- Test Case $D$:\n  - Number of vertices: $n=5$ (vertices $0,1,2,3,4$).\n  - Directed edges: $((0,2),(2,4))$.\n  - Source $s=0$, target $t=4$, intermediate $w=4$.\n- Test Case $E$:\n  - Number of vertices: $n=6$ (vertices $0,1,2,3,4,5$).\n  - Directed edges: $((0,1),(1,2),(3,4),(4,5))$.\n  - Source $s=0$, target $t=5$, intermediate $w=3$.\n- Test Case $F$:\n  - Number of vertices: $n=7$ (vertices $0,1,2,3,4,5,6$).\n  - Directed edges: $((0,1),(1,2),(2,0),(2,3),(3,4),(4,5),(5,3),(1,6),(6,4))$.\n  - Source $s=0$, target $t=5$, intermediate $w=4$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[result_1,result_2,\\dots]$).\n- Each $result_i$ must be the two-element list $[L,P]$ where $L$ is the integer path length and $P$ is the list of integers representing the path satisfying the constraint that it passes through $w$. If no such path exists, output $[-1,[]]$ for that test case.", "solution": "## Problem Validation\n\n### Step 1: Extract Givens\n\nThe problem provides the following data and definitions for a series of test cases:\n- Graph structure: Finite, unweighted, directed graphs.\n- Vertex labeling: Integers from $0$ to $n-1$, where $n$ is the number of vertices.\n- Edge representation: An edge from vertex $u$ to vertex $v$ is an ordered pair $(u,v)$.\n- Path definition: A sequence of vertices $(v_0, v_1, \\dots, v_k)$ where $v_0$ is a source vertex $s$, $v_k$ is a target vertex $t$, and for each $i \\in \\{0, 1, \\dots, k-1\\}$, there is an edge $(v_i, v_{i+1})$.\n- Path length: The number of edges in a path, denoted by $k$.\n- Primary constraint: The path from $s$ to $t$ must pass through a specified intermediate vertex $w$ at least once.\n- Objective 1 (Minimization): Find a path that satisfies the constraint and has the minimum possible length, $L$.\n- Objective 2 (Tie-breaking): If multiple paths of minimum length exist, select the one that is lexicographically smallest. The lexicographical comparison is performed on the sequences of integer vertex labels.\n- No-solution case: If no path from $s$ to $t$ passing through $w$ exists, the length $L$ should be $-1$ and the path $P$ should be an empty list, $[]$.\n- Test Suite: Six specific test cases (A-F) are provided, each with a defined number of vertices $n$, a set of edges, a source $s$, a target $t$, and an intermediate vertex $w$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is scrutinized against the validation criteria:\n\n- **Scientifically Grounded (Critical)**: The problem is fundamentally a graph traversal problem. It relies on standard and universally accepted definitions from graph theory, a core area of mathematics and computer science. Concepts like directed graphs, paths, path length, and lexicographical ordering are rigorously defined. The problem is free of any pseudoscience or factual inaccuracies.\n- **Well-Posed**: The problem is well-posed. The objective is clearly stated: find a shortest path with a specific property. The inclusion of a lexicographical tie-breaking rule ensures that if a solution exists, it is unique. The conditions for what constitutes a solution versus no solution are explicitly defined.\n- **Objective (Critical)**: The problem is stated in precise, objective, and mathematical language. It is devoid of ambiguity, subjectivity, or opinion-based claims.\n\nFurthermore, the problem does not exhibit any of the listed invalidity flaws:\n1.  **Scientific or Factual Unsoundness**: None. The problem is based on sound mathematical principles.\n2.  **Non-Formalizable or Irrelevant**: The problem is directly formalizable into an algorithmic task and is a classic application of shortest-path algorithms, highly relevant to the specified topic of \"breadth-first search and applications\".\n3.  **Incomplete or Contradictory Setup**: None. Each test case is self-contained and provides all necessary parameters ($n$, edges, $s$, $t$, $w$).\n4.  **Unrealistic or Infeasible**: Not applicable. The problem deals with abstract mathematical graph structures, for which physical realism is not a relevant constraint.\n5.  **Ill-Posed or Poorly Structured**: None. The problem is well-structured, and the objectives guarantee a unique, meaningful solution if one exists.\n6.  **Pseudo-Profound, Trivial, or Tautological**: None. The problem requires a thoughtful combination of standard algorithms to handle the intermediate vertex constraint and the lexicographical tie-breaking, making it a non-trivial algorithmic challenge.\n7.  **Outside Scientific Verifiability**: None. Any proposed algorithmic solution can be rigorously proven correct and its output can be verified against the problem's definitions.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. It is a clear, consistent, and solvable problem in the field of algorithms. A full solution will be provided.\n\n## Solution\n\nThe problem requires finding the lexicographically smallest shortest path from a source vertex $s$ to a target vertex $t$ that is constrained to pass through a specific intermediate vertex $w$.\n\n### Principle-Based Design\n\nA path from $s$ to $t$ that passes through $w$ can be conceptually decomposed into two segments: a path from $s$ to $w$ and a path from $w$ to $t$. To find the overall shortest path, we must find the shortest path for each of these segments.\nLet $P_{s \\to w}$ be a shortest path from $s$ to $w$, and $P_{w \\to t}$ be a shortest path from $w$ to $t$. The concatenation of these two paths forms a path from $s$ to $t$ that passes through $w$. The length of this concatenated path is the sum of the lengths of the individual paths: $L = \\text{length}(P_{s \\to w}) + \\text{length}(P_{w \\to t})$. By the principle of optimality, any shortest path from $s$ to $t$ via $w$ must be composed of a shortest path from $s$ to $w$ and a shortest path from $w$ to $t$.\n\nSince the graph is unweighted, the Breadth-First Search (BFS) algorithm is the appropriate method for finding shortest paths from a single source. A standard BFS finds the shortest path in terms of the number of edges.\n\nThe problem introduces a tie-breaking rule: among all shortest paths, we must choose the one that is lexicographically smallest. A path $P_A = (v_0, v_1, \\dots, v_k)$ is lexicographically smaller than another path $P_B = (u_0, u_1, \\dots, u_k)$ if at the first index $i$ where they differ, $v_i < u_i$. To ensure our BFS finds the lexicographically smallest path, we must modify the order in which it explores neighbors. When exploring the neighbors of any given vertex, the standard BFS algorithm can visit them in any order. To satisfy the lexicographical requirement, we must ensure that the neighbors are visited in ascending order of their vertex labels. This is achieved by sorting the adjacency list for each vertex.\n\nThe overall algorithm is as follows:\n\n1.  **Graph Representation**: Represent the graph using an adjacency list. For each vertex $u$, the list `adj[u]` will store all vertices $v$ for which an edge $(u,v)$ exists. Crucially, each of these lists must be sorted in ascending order to facilitate the lexicographical tie-breaking.\n\n2.  **Modified Breadth-First Search**: Implement a BFS function, `bfs(graph, source)`, that takes a graph and a source vertex as input. This function will:\n    - Use a queue to manage the frontier of vertices to visit.\n    - Use a `distance` array, initialized to a value indicating infinity (e.g., $-1$), to store the shortest distance from the `source` to every other vertex.\n    - Use a `parent` array to store the predecessor of each vertex in the shortest path, which is necessary for path reconstruction.\n    - When dequeuing a vertex $u$, iterate through its neighbors $v$ from the sorted adjacency list. If $v$ has not been visited yet (i.e., `distance[v] == -1`), update its distance and parent (`distance[v] = distance[u] + 1`, `parent[v] = u`) and enqueue it.\n    - The function returns the `distance` and `parent` arrays.\n\n3.  **Pathfinding and Combination**:\n    a. Execute the modified BFS starting from the source vertex $s$: `(distances_s, parents_s) = bfs(graph, s)`.\n    b. Execute the modified BFS starting from the intermediate vertex $w$: `(distances_w, parents_w) = bfs(graph, w)`.\n\n4.  **Reachability Check**:\n    a. Check if $w$ is reachable from $s$ by inspecting `distances_s[w]`.\n    b. Check if $t$ is reachable from $w$ by inspecting `distances_w[t]`.\n    c. If either is unreachable (distance is $-1$), no valid path exists. In this case, the result is a length of $-1$ and an empty path $[]$.\n\n5.  **Path Reconstruction**:\n    a. If both segments are navigable, reconstruct the lexicographically smallest shortest path from $s$ to $w$, let's call it $P_{s \\to w}$, by backtracking from $w$ to $s$ using the `parents_s` array.\n    b. Similarly, reconstruct the path from $w$ to $t$, $P_{w \\to t}$, using the `parents_w` array.\n\n6.  **Final Path and Length Calculation**:\n    a. The final path $P$ is the concatenation of $P_{s \\to w}$ and $P_{w \\to t}$. Since $w$ is the last vertex of $P_{s \\to w}$ and the first vertex of $P_{w \\to t}$, it appears twice. One instance must be removed. The final path is $P = P_{s \\to w} \\oplus P_{w \\to t}[1:]$, where $\\oplus$ denotes list concatenation and $[1:]$ denotes the slice of the list from the second element onward.\n    b. The total length $L$ is the sum of the lengths of the two sub-paths: $L = \\text{distances\\_s}[w] + \\text{distances\\_w}[t]$.\n\nThis constructive method is guaranteed to yield the correct result. The path length is minimal because it is the sum of two minimal-length sub-paths. The path is lexicographically minimal among all shortest paths because the sequential composition of two lexicographically minimal shortest paths ($s \\to w$ and $w \\to t$) results in an overall lexicographically minimal path. If there were a lexicographically smaller path of the same length, it would imply that either its $s \\to w$ segment or its $w \\to t$ segment is lexicographically smaller, contradicting the way they were constructed.", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves a series of graph pathfinding problems as specified in the test suite.\n    \"\"\"\n    test_cases = [\n        # Test Case A\n        {'n': 6, 'edges': ((0,1),(0,2),(1,3),(2,3),(3,4),(4,5),(1,5),(2,5)), 's': 0, 't': 5, 'w': 3},\n        # Test Case B\n        {'n': 7, 'edges': ((0,1),(0,2),(1,3),(2,3),(3,4),(3,5),(4,6),(5,6)), 's': 0, 't': 6, 'w': 3},\n        # Test Case C\n        {'n': 4, 'edges': ((0,1),(1,2),(2,3)), 's': 0, 't': 3, 'w': 0},\n        # Test Case D\n        {'n': 5, 'edges': ((0,2),(2,4)), 's': 0, 't': 4, 'w': 4},\n        # Test Case E\n        {'n': 6, 'edges': ((0,1),(1,2),(3,4),(4,5)), 's': 0, 't': 5, 'w': 3},\n        # Test Case F\n        {'n': 7, 'edges': ((0,1),(1,2),(2,0),(2,3),(3,4),(4,5),(5,3),(1,6),(6,4)), 's': 0, 't': 5, 'w': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_constrained_path(case['n'], case['edges'], case['s'], case['t'], case['w'])\n        # Python's default str() for lists adds spaces, which is not ideal for the join,\n        # so we manually create a compact string representation.\n        path_str = f\"[{','.join(map(str, result[1]))}]\"\n        results.append(f\"[{result[0]},{path_str}]\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef find_constrained_path(n, edges, s, t, w):\n    \"\"\"\n    Finds the lexicographically smallest shortest path from s to t passing through w.\n    \"\"\"\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n    \n    # Sort adjacency lists to ensure lexicographically smallest path in BFS\n    for i in range(n):\n        adj[i].sort()\n\n    # Find shortest path from s to w\n    distances_s, parents_s = bfs(n, adj, s)\n    if distances_s[w] == -1:\n        return [-1, []]\n\n    # Find shortest path from w to t\n    distances_w, parents_w = bfs(n, adj, w)\n    if distances_w[t] == -1:\n        return [-1, []]\n\n    # Reconstruct paths\n    path_sw = reconstruct_path(s, w, parents_s)\n    path_wt = reconstruct_path(w, t, parents_w)\n\n    # Combine paths and total length\n    # The intermediate vertex 'w' is the end of the first path and the start of the second,\n    # so we exclude it from the second path segment to avoid duplication.\n    full_path = path_sw + path_wt[1:]\n    full_length = distances_s[w] + distances_w[t]\n    \n    return [full_length, full_path]\n\ndef bfs(n, adj, start_node):\n    \"\"\"\n    Performs a Breadth-First Search to find shortest paths from a start_node.\n    It returns distances and parent pointers for path reconstruction.\n    adjacency lists in 'adj' must be sorted to find lexicographically smallest paths.\n    \"\"\"\n    # Initialize distances and parents arrays. -1 indicates not visited.\n    distances = np.full(n, -1, dtype=int)\n    parents = np.full(n, -1, dtype=int)\n    \n    q = deque([start_node])\n    distances[start_node] = 0\n    \n    while q:\n        u = q.popleft()\n        \n        # Iterate over neighbors in pre-sorted order\n        for v in adj[u]:\n            if distances[v] == -1: # If vertex v has not been visited\n                distances[v] = distances[u] + 1\n                parents[v] = u\n                q.append(v)\n                \n    return distances, parents\n\ndef reconstruct_path(start, end, parents):\n    \"\"\"\n    Reconstructs the path from a start to an end vertex using the parent pointers.\n    \"\"\"\n    path = []\n    curr = end\n    if parents[curr] == -1 and curr != start: # End node is not reachable from start\n        return []\n        \n    while True:\n        path.append(curr)\n        if curr == start:\n            break\n        curr = parents[curr]\n    \n    return path[::-1] # Reverse to get path from start to end\n\nsolve()\n```", "id": "3218504"}, {"introduction": "What if the constraint on a path isn't about where it goes, but about a property of the path itself, like its length? This advanced exercise asks you to find the shortest path that has an even number of edges, a constraint that standard BFS cannot handle directly. The key is to expand the notion of a state in your search, from just a vertex $v$ to a pair $(v, \\text{parity})$, a powerful technique for solving a wide class of constrained pathfinding problems. [@problem_id:3218441]", "problem": "You are given the task of designing and implementing an algorithmic solution, grounded in fundamental definitions of graphs and the well-tested properties of the breadth-first search (BFS) algorithm, to determine constrained shortest paths in directed graphs. Consider a finite, directed, unweighted graph $G = (V, E)$ with $|V| = n$ and $|E| = m$, where $V$ is a finite set of vertices and $E \\subseteq V \\times V$ is a finite set of directed edges. A path from a vertex $s \\in V$ to a vertex $t \\in V$ is a sequence of vertices $(v_0, v_1, \\dots, v_k)$ such that $v_0 = s$, $v_k = t$, and $(v_{i-1}, v_i) \\in E$ for all integers $i$ with $1 \\le i \\le k$. The length of a path is the number of edges it contains, namely $k$. A path is called even-length if its length $k$ is an even integer (including $k = 0$).\n\nYour program must compute, for each test case in the test suite below, the length of the shortest even-length path from a specified source vertex $s$ to a specified target vertex $t$. If no even-length path exists, return $-1$ for that test case. Answers are to be reported as integers.\n\nThe solution must be derived from the following base:\n- Fundamental definitions of graphs, paths, and path length.\n- The well-tested fact that breadth-first search (BFS) on a finite unweighted graph discovers vertices in nondecreasing order of distance and computes shortest-path lengths in number of edges.\n\nTest suite. For each test case, the graph is directed and unweighted. Each case specifies the number of vertices $n$, the edge set $E$ as ordered pairs, and the query $(s, t)$.\n\n- Case 1: $n = 6,\\quad E = \\{(0,1),(1,2),(2,3),(3,4),(4,5),(0,2),(2,4)\\},\\quad s = 0,\\ t = 4.$\n- Case 2: $n = 3,\\quad E = \\{(0,1),(1,2),(2,0),(2,1)\\},\\quad s = 0,\\ t = 1.$\n- Case 3: $n = 2,\\quad E = \\{(0,1)\\},\\quad s = 0,\\ t = 1.$\n- Case 4: $n = 4,\\quad E = \\{(0,1),(1,2),(2,3),(3,0)\\},\\quad s = 0,\\ t = 0.$\n- Case 5: $n = 6,\\quad E = \\{(0,1),(1,3),(3,5),(0,2),(2,4),(4,5),(1,2)\\},\\quad s = 0,\\ t = 5.$\n- Case 6: $n = 2,\\quad E = \\{(0,1),(1,1)\\},\\quad s = 0,\\ t = 1.$\n\nRequired final output format. Your program should produce a single line of output containing the results for all cases, in order, as a comma-separated list enclosed in square brackets, with no spaces, for example $[r_1,r_2,\\dots,r_k]$ where each $r_i$ is the integer answer for case $i$.", "solution": "The user provides a problem that requires finding the length of the shortest even-length path between two vertices in a directed, unweighted graph. The solution must be derived from the principles of graph theory and the breadth-first search (BFS) algorithm.\n\n### Problem Validation\n\n#### Step 1: Extract Givens\n- **Graph**: A finite, directed, unweighted graph $G = (V, E)$, with $|V| = n$ and $|E| = m$.\n- **Path**: A sequence of vertices $(v_0, v_1, \\dots, v_k)$ such that $v_0 = s$, $v_k = t$, and $(v_{i-1}, v_i) \\in E$ for $1 \\le i \\le k$.\n- **Path Length**: The number of edges, $k$, in a path.\n- **Even-Length Path**: A path whose length $k$ is an even integer ($k \\ge 0$).\n- **Objective**: For a given source $s$ and target $t$, compute the length of the shortest even-length path from $s$ to $t$. If no such path exists, the value is $-1$.\n- **Algorithmic Basis**: The solution must be grounded in fundamental graph definitions and the properties of Breadth-First Search (BFS), specifically that it finds shortest paths in unweighted graphs.\n- **Test Suite**:\n  - Case $1$: $n = 6$, $E = \\{(0,1),(1,2),(2,3),(3,4),(4,5),(0,2),(2,4)\\}$, $s = 0, t = 4$.\n  - Case $2$: $n = 3$, $E = \\{(0,1),(1,2),(2,0),(2,1)\\}$, $s = 0, t = 1$.\n  - Case $3$: $n = 2$, $E = \\{(0,1)\\}$, $s = 0, t = 1$.\n  - Case $4$: $n = 4$, $E = \\{(0,1),(1,2),(2,3),(3,0)\\}$, $s = 0, t = 0$.\n  - Case $5$: $n = 6$, $E = \\{(0,1),(1,3),(3,5),(0,2),(2,4),(4,5),(1,2)\\}$, $s = 0, t = 5$.\n  - Case $6$: $n = 2$, $E = \\{(0,1),(1,1)\\}$, $s = 0, t = 1$.\n\n#### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria:\n- **Scientifically Grounded**: The problem is a well-established topic in graph theory and algorithms, a sub-field of computer science and discrete mathematics. It is based on formal definitions of graphs, paths, and path lengths. All premises are factually sound.\n- **Well-Posed**: The problem is clearly specified. The objective is to find a minimum value (shortest length) under a specific constraint (even length). For a finite graph, such a path either exists, in which case a shortest one is guaranteed to exist, or it does not. Therefore, a unique, meaningful solution (the length, or $-1$) exists.\n- **Objective**: The problem statement is expressed in precise, formal mathematical language, free from any subjectivity, ambiguity, or opinion.\n- **Relevance**: The problem is directly related to the topic of breadth-first search and its applications, as specified in the problem statement.\n\nThe problem does not exhibit any of the defined flaws. It is scientifically sound, formalizable, complete, feasible, and well-posed. It is a standard extension of a classic algorithm, not a trivial or contrived problem.\n\n#### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Solution Derivation\n\nThe problem asks for the length of a shortest path with an additional constraint on the parity of its length. The standard Breadth-First Search (BFS) algorithm is guaranteed to find the shortest path in an unweighted graph, where \"shortest\" is defined as the minimum number of edges. However, a standard BFS does not inherently distinguish between paths of different parities. The shortest path found by BFS could be of odd length, which would not be a valid solution to our problem.\n\nTo incorporate the parity constraint, we must augment the state representation used in the search. A state in a standard BFS corresponds to a vertex $v \\in V$. We need a state representation that encodes not only the current location (vertex) but also the parity of the path taken to reach it.\n\nLet us define a new state space. A state can be represented by a pair $(v, p)$, where $v \\in V$ is a vertex and $p \\in \\{0, 1\\}$ is the parity of the path length from the source vertex $s$ to $v$. Here, $p=0$ signifies an even-length path, and $p=1$ signifies an odd-length path.\n\nThis conceptual augmentation can be formalized by constructing a new graph, $G' = (V', E')$.\n- The set of vertices in the new graph is $V' = V \\times \\{0, 1\\}$. The size of this set is $|V'| = 2n$. A vertex $(v, p)$ in $G'$ signifies that we have reached vertex $v$ in $G$ via a path of parity $p$.\n- The set of edges $E'$ in $G'$ is derived from the edges in $G$. For each edge $(u, v) \\in E$, traversing it increases the path length by $1$, thereby flipping the parity of the path length. This translates to two directed edges in $G'$:\n  1. An edge from $(u, 0)$ to $(v, 1)$: A path to $u$ of even length, followed by the edge $(u,v)$, results in a path to $v$ of odd length.\n  2. An edge from $(u, 1)$ to $(v, 0)$: A path to $u$ of odd length, followed by the edge $(u,v)$, results in a path to $v$ of even length.\n\nThe problem of finding the shortest even-length path from $s$ to $t$ in the original graph $G$ is now transformed into the problem of finding the shortest path from a start vertex to a target vertex in the new graph $G'$. The starting point is a path of length $0$ from $s$ to itself. Since $0$ is an even number, the starting state in $G'$ is $(s, 0)$. We are looking for an even-length path to $t$, so the target state in $G'$ is $(t, 0)$.\n\nSince the original graph $G$ is unweighted, the transformed graph $G'$ is also unweighted. Therefore, we can apply the standard BFS algorithm on $G'$ to find the shortest path from $(s, 0)$ to $(t, 0)$. The length of this path in $G'$ is equal to the length of the corresponding path in $G$.\n\nThe algorithm proceeds as follows:\n1.  We do not need to explicitly construct $G'$. We can perform the BFS on the implicit state space.\n2.  We use a queue to store states to visit. Each element in the queue will be a tuple `(vertex, length)`, e.g., $(u, d)$.\n3.  We use a $2$-dimensional array, `distances[v][p]`, to store the length of the shortest path found so far to vertex $v$ with parity $p$. This array is of size $n \\times 2$ and is initialized with a value indicating unreachability, such as $-1$. This array also serves to track visited states, preventing cycles and redundant computations.\n4.  The search begins at the source $s$ with a path of length $0$. We initialize `distances[s][0] = 0` and add $(s, 0)$ to the queue.\n5.  The BFS main loop:\n    a. Dequeue a state $(u, d)$.\n    b. For each neighbor $v$ of $u$ in the original graph $G$:\n        i. The new path length to $v$ is $d_{\\text{new}} = d + 1$.\n        ii. The parity of this new path is $p_{\\text{new}} = d_{\\text{new}} \\pmod 2$.\n        iii. If the state $(v, p_{\\text{new}})$ has not been visited yet (i.e., `distances[v][p_{new}] == -1`), we have found the shortest path to this state. We record its length, `distances[v][p_{new}] = d_{new}`, and enqueue the new state $(v, d_{\\text{new}})$.\n6.  The BFS continues until the queue is empty.\n7.  The final answer is the length of the shortest even-length path to $t$, which is stored in `distances[t][0]`. If `distances[t][0]` remains at its initial value of $-1$, it means the state $(t, 0)$ was never reached, and thus no even-length path from $s$ to $t$ exists.\n\nA special case is when $s = t$. The path of length $0$ from $s$ to itself is an even-length path. Thus, the answer is $0$. The described algorithm correctly handles this, as `distances[s][0]` is initialized to $0$.\n\nThis principled approach correctly adapts the BFS algorithm to solve the constrained shortest path problem by expanding the state space to include the constraint itself.", "answer": "```python\nimport collections\nimport numpy as np\n\ndef solve_case(n, E, s, t):\n    \"\"\"\n    Computes the length of the shortest even-length path from s to t.\n\n    The problem is solved by running a Breadth-First Search (BFS) on an\n    expanded state space. A state is defined by a pair (vertex, parity),\n    where parity is 0 for even-length paths and 1 for odd-length paths.\n\n    This is equivalent to finding the shortest path in a new graph G' where\n    each vertex v in the original graph G is split into two vertices, (v, 0)\n    and (v, 1). An edge (u, v) in G corresponds to edges ((u, 0), (v, 1))\n    and ((u, 1), (v, 0)) in G'.\n\n    We seek the shortest path from state (s, 0) to (t, 0).\n\n    Args:\n        n (int): The number of vertices.\n        E (list of tuples): The set of directed edges.\n        s (int): The source vertex.\n        t (int): The target vertex.\n\n    Returns:\n        int: The length of the shortest even-length path, or -1 if none exists.\n    \"\"\"\n    if n == 0:\n        return -1\n\n    adj = collections.defaultdict(list)\n    for u, v in E:\n        adj[u].append(v)\n    \n    # A path of length 0 from s to s is an even-length path.\n    if s == t:\n        return 0\n\n    # distances[v][p] stores the shortest distance to vertex v\n    # with a path of parity p (0 for even, 1 for odd).\n    # Initialize with -1 to indicate unreachability.\n    distances = np.full((n, 2), -1, dtype=int)\n    \n    # The queue stores tuples of (vertex, current_path_length).\n    queue = collections.deque()\n\n    # Start BFS from source s with a path of length 0.\n    # The path is even, so update distances for parity 0.\n    distances[s][0] = 0\n    queue.append((s, 0))\n\n    while queue:\n        u, path_len = queue.popleft()\n        \n        new_path_len = path_len + 1\n        new_parity = new_path_len % 2\n\n        for v in adj[u]:\n            # If we haven't found a path to vertex v with this new_parity,\n            # this must be the shortest one.\n            if distances[v][new_parity] == -1:\n                distances[v][new_parity] = new_path_len\n                queue.append((v, new_path_len))\n                \n                # If we've just reached the target with an even path, we are done\n                # because BFS guarantees this is the shortest such path.\n                if v == t and new_parity == 0:\n                    return new_path_len\n\n    # If the BFS completes and distances[t][0] is still -1, no even path exists.\n    return distances[t][0]\n\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the shortest even-length path problem.\n    \"\"\"\n    test_cases = [\n        {\"n\": 6, \"E\": [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (0, 2), (2, 4)], \"s\": 0, \"t\": 4},\n        {\"n\": 3, \"E\": [(0, 1), (1, 2), (2, 0), (2, 1)], \"s\": 0, \"t\": 1},\n        {\"n\": 2, \"E\": [(0, 1)], \"s\": 0, \"t\": 1},\n        {\"n\": 4, \"E\": [(0, 1), (1, 2), (2, 3), (3, 0)], \"s\": 0, \"t\": 0},\n        {\"n\": 6, \"E\": [(0, 1), (1, 3), (3, 5), (0, 2), (2, 4), (4, 5), (1, 2)], \"s\": 0, \"t\": 5},\n        {\"n\": 2, \"E\": [(0, 1), (1, 1)], \"s\": 0, \"t\": 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case[\"n\"], case[\"E\"], case[\"s\"], case[\"t\"])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3218441"}]}