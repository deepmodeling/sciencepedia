{"hands_on_practices": [{"introduction": "The Bellman-Ford algorithm's primary strength is its ability to handle negative edge weights, but its most critical feature is detecting negative cycles. This practice tackles the quintessential problem of finding a \"safe\" shortest path in a graph that may contain such cycles. You will implement a robust solution that not only computes shortest path distances but also identifies all vertices whose path calculations are rendered meaningless by a nearby negative cycle, ensuring the path you find is verifiably optimal and finite [@problem_id:3214050].", "problem": "You are given a finite directed weighted graph $G=(V,E)$ with real-valued edge weights $w:E\\to\\mathbb{R}$. A path from a source vertex $s\\in V$ to a target vertex $t\\in V$ is a sequence of vertices $\\left[v_0,v_1,\\dots,v_k\\right]$ with $v_0=s$, $v_k=t$, and $\\left(v_i,v_{i+1}\\right)\\in E$ for all $i\\in\\{0,1,\\dots,k-1\\}$. The weight of a path is the sum of its edge weights, that is, $\\sum_{i=0}^{k-1} w\\!\\left(v_i,v_{i+1}\\right)$. A cycle is a path with $v_0=v_k$ and $k\\geq 1$. A negative cycle is a cycle whose total weight is strictly less than $0$. In the Single Source Shortest Path (SSSP) problem, the goal is to find a path from $s$ to $t$ with minimum total weight among all $s$ to $t$ paths.\n\nYour task is to write a complete program that, for each provided test case, computes a shortest path from $s$ to $t$ that is guaranteed not to be part of any negative cycle, even if such cycles exist elsewhere in the graph. The program must implement logic that ensures the returned path uses only vertices that are not affected by any negative cycle reachable from $s$. If the target vertex $t$ is unreachable from $s$, or $t$ is reachable from any vertex that lies on or is reachable from a negative cycle that is itself reachable from $s$, then there is no well-defined finite shortest path, and you must return an empty list.\n\nFundamental base and definitions you must adhere to:\n- The directed weighted graph $G=(V,E)$ has vertex set $V$ and edge set $E\\subseteq V\\times V$, with each edge $\\left(u,v\\right)\\in E$ assigned a weight $w\\!\\left(u,v\\right)\\in\\mathbb{R}$.\n- The weight of any path $\\left[v_0,\\dots,v_k\\right]$ is $\\sum_{i=0}^{k-1} w\\!\\left(v_i,v_{i+1}\\right)$.\n- A negative cycle is any cycle $\\left[v_0,\\dots,v_k\\right]$ with $v_0=v_k$ and $\\sum_{i=0}^{k-1} w\\!\\left(v_i,v_{i+1}\\right)0$.\n- It is a well-tested fact that if there is a negative cycle reachable from $s$ that can reach $t$, then no finite minimum exists for the $s$ to $t$ path weight; moreover, after performing $|V|-1$ rounds of relaxation in the Bellmanâ€“Ford algorithm, the presence of any edge $\\left(u,v\\right)\\in E$ for which the distance estimate $d[u]+w\\!\\left(u,v\\right)$ is still less than $d[v]$ implies the existence of a negative cycle reachable from $s$, and any vertex reachable from such a witness of further relaxation is affected by that negative cycle.\n\nOutput requirements:\n- For each test case, return the path as a list of integers denoting the vertex sequence from $s$ to $t$. If no well-defined finite shortest path exists (either because $t$ is unreachable from $s$ or because $t$ is affected by a negative cycle reachable from $s$), return an empty list $\\left[\\right]$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$), where each $\\text{result}_i$ is itself a list (e.g., $\\left[0,1,2\\right]$) or an empty list $\\left[\\right]$.\n\nTest suite:\nUse exactly the following test cases, each specified by a tuple $\\left(n,E,s,t\\right)$ where $n=|V|$ is the number of vertices labeled as integers $\\{0,1,\\dots,n-1\\}$, $E$ is a list of directed edges with weights given as triples $\\left(u,v,w\\right)$, and $s,t$ are the source and target vertices.\n\n- Test case $1$ (happy path with an unreachable negative cycle elsewhere):\n  - $n=5$\n  - $E=\\left[\\left(0,1,3\\right),\\left(1,2,-2\\right),\\left(0,2,5\\right),\\left(3,4,-1\\right),\\left(4,3,-1\\right)\\right]$\n  - $s=0$\n  - $t=2$\n  - Expected behavior: The negative cycle on vertices $\\left\\{3,4\\right\\}$ is unreachable from $s$, so the shortest path is well-defined.\n\n- Test case $2$ (negative cycle reachable from $s$ that can reach $t$):\n  - $n=4$\n  - $E=\\left[\\left(0,1,1\\right),\\left(1,2,1\\right),\\left(2,1,-3\\right),\\left(2,3,2\\right)\\right]$\n  - $s=0$\n  - $t=3$\n  - Expected behavior: There exists a negative cycle reachable from $s$ that can reach $t$, so no finite shortest path exists; return $\\left[\\right]$.\n\n- Test case $3$ (negative cycle reachable from $s$ but cannot reach $t$, with an unaffected path to $t$):\n  - $n=6$\n  - $E=\\left[\\left(0,1,2\\right),\\left(1,2,2\\right),\\left(2,1,-5\\right),\\left(0,3,1\\right),\\left(3,4,1\\right),\\left(4,5,1\\right)\\right]$\n  - $s=0$\n  - $t=5$\n  - Expected behavior: The negative cycle on vertices $\\left\\{1,2\\right\\}$ is reachable from $s$ but cannot reach $t$, so the shortest path to $t$ is well-defined and must avoid affected vertices.\n\n- Test case $4$ (target unreachable):\n  - $n=3$\n  - $E=\\left[\\left(0,1,1\\right)\\right]$\n  - $s=0$\n  - $t=2$\n  - Expected behavior: Vertex $t$ is unreachable from $s$; return $\\left[\\right]$.\n\n- Test case $5$ (boundary case $s=t$ with no negative influence on $s$):\n  - $n=3$\n  - $E=\\left[\\left(0,2,4\\right)\\right]$\n  - $s=1$\n  - $t=1$\n  - Expected behavior: The shortest path from $s$ to itself is the trivial path $\\left[1\\right]$ since $s$ is not affected by any negative cycle.\n\nYour program must use these test cases and output one line containing the list of results in the exact format described above.", "solution": "The given problem asks for the computation of a shortest path from a source vertex $s$ to a target vertex $t$ in a directed, weighted graph $G=(V,E)$ where edge weights can be negative. The crucial constraint is that the path must be well-defined, meaning it must not be possible to decrease its weight indefinitely by traversing a negative cycle. Specifically, if the target $t$ is unreachable, or if its shortest path is influenced by a negative cycle reachable from $s$, no such path exists.\n\nThe presence of negative edge weights suggests the use of the Bellman-Ford algorithm, which is designed for the Single-Source Shortest Path (SSSP) problem in such graphs. The standard Bellman-Ford algorithm can also detect if there is a negative cycle reachable from the source $s$. Our task requires an extension of this capability to identify all vertices whose shortest path calculations are \"corrupted\" by such cycles and to ensure our path to $t$ avoids them.\n\nThe core principle of the Bellman-Ford algorithm is iterative relaxation. It initializes the distance to the source $d[s]$ as $0$ and all other distances $d[v]$ to infinity. It then repeatedly relaxes all edges in the graph. For an edge $(u,v)$ with weight $w(u,v)$, relaxation is the process of checking if the path to $v$ can be shortened by going through $u$, i.e., if $d[u] + w(u,v)  d[v]$. If so, $d[v]$ is updated to $d[u] + w(u,v)$, and the predecessor of $v$ on this path, $p[v]$, is set to $u$.\n\nIn a graph with $|V|$ vertices, any simple path (a path without repeated vertices) can have at most $|V|-1$ edges. The Bellman-Ford algorithm guarantees that after $|V|-1$ iterations of relaxing all edges, the calculated distances $d[v]$ are the shortest path weights from $s$ to all other vertices $v$, provided there are no negative cycles reachable from $s$.\n\nThe problem hinges on correctly handling negative cycles. A key property of the Bellman-Ford algorithm, as stated in the problem description, is that if after $|V|-1$ iterations, a further relaxation is possible for any edge $(u,v)$, it signals the existence of a negative-weight cycle reachable from $s$. Any vertex $v$ whose distance estimate $d[v]$ is lowered during a conceptual $|V|$-th iteration is on a path from $s$ that contains a negative cycle. The shortest path to such a vertex is undefined (it can be made arbitrarily small by repeatedly traversing the cycle).\n\nFurthermore, any vertex reachable from a vertex affected by a negative cycle is also considered affected, as paths to it could be routed through the corrupted vertex, making their shortest path weights also undefined.\n\nThis leads to the following comprehensive algorithm:\n\n1.  **Initialization**: For a graph with $n=|V|$ vertices, create a distance array $d$ of size $n$ and initialize $d[s] = 0$ and $d[v] = \\infty$ for all $v \\neq s$. Create a predecessor array $p$ of size $n$, initialized to a sentinel value (e.g., $-1$) indicating no predecessor.\n\n2.  **Bellman-Ford Relaxations**: Perform $n-1$ iterations. In each iteration, loop through every edge $(u,v) \\in E$ with weight $w(u,v)$ and perform the relaxation step: if $d[u] \\neq \\infty$ and $d[u] + w(u,v)  d[v]$, update $d[v] = d[u] + w(u,v)$ and $p[v] = u$.\n\n3.  **Identification of Affected Vertices**:\n    a.  Identify vertices directly affected by negative cycles. We can do this by performing one more round of relaxation checks (the $n$-th round). Create a queue, `affected_queue`, and for each edge $(u,v) \\in E$, if $d[u] + w(u,v)  d[v]$, it means $v$ is on a path from $s$ that involves a negative cycle. Add $v$ to `affected_queue`. To avoid duplicates and for efficient lookup, a set `all_affected` is also populated with these initial vertices.\n    b.  Propagate the \"affected\" status. Any vertex reachable from an affected vertex is also affected. Perform a graph traversal (e.g., Breadth-First Search or Depth-First Search) starting from all vertices in `affected_queue`. For this, an adjacency list representation of the graph is useful. During the traversal, add all newly discovered reachable vertices to the `all_affected` set.\n\n4.  **Path Determination and Reconstruction**:\n    a.  First, check if the target vertex $t$ is reachable at all. If $d[t] = \\infty$ after the Bellman-Ford phase, no path exists from $s$ to $t$. The result is an empty list.\n    b.  Next, check if $t$ is affected by a negative cycle. If $t$ is in the `all_affected` set, no well-defined finite shortest path exists. The result is an empty list.\n    c.  If $t$ is reachable and not affected, a valid shortest path exists. This path can be reconstructed by starting from $t$ and iteratively moving to its predecessor using the array $p$ until $s$ is reached. The sequence of vertices visited, when reversed, gives the shortest path from $s$ to $t$. If $s=t$, the path is simply $[s]$.\n\nThis algorithm correctly finds a safe shortest path by first running the Bellman-Ford algorithm to compute path weights and predecessors, then systematically identifying and quarantining all vertices whose shortest path distances are compromised by negative cycles, and finally checking the target vertex against these conditions before reconstructing the path.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the provided test cases for the secure shortest path problem.\n    \"\"\"\n    test_cases = [\n        # Test case 1: Happy path with an unreachable negative cycle\n        {\n            \"n\": 5,\n            \"E\": [(0, 1, 3), (1, 2, -2), (0, 2, 5), (3, 4, -1), (4, 3, -1)],\n            \"s\": 0,\n            \"t\": 2,\n        },\n        # Test case 2: Negative cycle reachable from s that can reach t\n        {\n            \"n\": 4,\n            \"E\": [(0, 1, 1), (1, 2, 1), (2, 1, -3), (2, 3, 2)],\n            \"s\": 0,\n            \"t\": 3,\n        },\n        # Test case 3: Negative cycle reachable from s but cannot reach t\n        {\n            \"n\": 6,\n            \"E\": [(0, 1, 2), (1, 2, 2), (2, 1, -5), (0, 3, 1), (3, 4, 1), (4, 5, 1)],\n            \"s\": 0,\n            \"t\": 5,\n        },\n        # Test case 4: Target unreachable\n        {\n            \"n\": 3,\n            \"E\": [(0, 1, 1)],\n            \"s\": 0,\n            \"t\": 2,\n        },\n        # Test case 5: Boundary case s=t\n        {\n            \"n\": 3,\n            \"E\": [(0, 2, 4)],\n            \"s\": 1,\n            \"t\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_shortest_safe_path(case[\"n\"], case[\"E\"], case[\"s\"], case[\"t\"])\n        results.append(result)\n\n    # Format the final output string to be space-free as per the implicit format.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f'[{\",\".join(formatted_results)}]')\n\n\ndef find_shortest_safe_path(n, E, s, t):\n    \"\"\"\n    Finds a shortest path from s to t that is not affected by any negative cycle.\n\n    Args:\n        n (int): The number of vertices, labeled 0 to n-1.\n        E (list): A list of edges, where each edge is a tuple (u, v, w).\n        s (int): The source vertex.\n        t (int): The target vertex.\n\n    Returns:\n        list: A list of integers representing the path from s to t, or an empty list\n              if no such path exists.\n    \"\"\"\n    # Step 1: Initialization\n    distances = np.full(n, np.inf)\n    predecessors = np.full(n, -1, dtype=int)\n    distances[s] = 0\n\n    # Step 2: Bellman-Ford relaxations for n-1 iterations\n    for _ in range(n - 1):\n        for u, v, w in E:\n            if distances[u] != np.inf and distances[u] + w  distances[v]:\n                distances[v] = distances[u] + w\n                predecessors[v] = u\n\n    # Step 3: Identification of affected vertices\n    # a. Identify vertices directly updated in the n-th relaxation round\n    initially_affected = set()\n    for u, v, w in E:\n        if distances[u] != np.inf and distances[u] + w  distances[v]:\n            initially_affected.add(v)\n\n    # b. Propagate the \"affected\" status via BFS\n    if not initially_affected:\n        all_affected = set()\n    else:\n        # Build adjacency list for traversal\n        adj = [[] for _ in range(n)]\n        for u, v, _ in E:\n            adj[u].append(v)\n            \n        all_affected = set(initially_affected)\n        queue = list(initially_affected)\n        \n        while queue:\n            curr = queue.pop(0)\n            for neighbor in adj[curr]:\n                if neighbor not in all_affected:\n                    all_affected.add(neighbor)\n                    queue.append(neighbor)\n\n    # Step 4: Path Determination and Reconstruction\n    # Case a: Target is unreachable\n    if distances[t] == np.inf:\n        return []\n\n    # Case b: Target is affected by a negative cycle\n    if t in all_affected:\n        return []\n\n    # Case c: A valid, safe shortest path exists\n    path = []\n    curr = t\n    while curr != -1:\n        path.append(curr)\n        if curr == s:\n            break\n        curr = predecessors[curr]\n    \n    path.reverse()\n    \n    if path and path[0] == s:\n        return path\n    else:\n        # This case should not be reached if distances[t] is finite\n        # and predecessors are correctly maintained, but serves as a safeguard.\n        return []\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3214050"}, {"introduction": "Beyond simply detecting the presence of a negative cycle, a common task is to diagnose whether a specific process or connectionâ€”represented by a designated edge $(u,v)$â€”is part of a problematic, self-reinforcing loop. This exercise challenges you to adapt the Bellman-Ford algorithm to answer this targeted question. By reframing the problem as a search for a specific shortest path from $v$ to $u$, you will learn a powerful technique in algorithmic problem-solving: reducing a novel question to a well-understood primitive [@problem_id:3213972].", "problem": "You are given a directed, weighted graph specified by a finite vertex set and a finite edge set. Each edge has an integer weight. A cycle is a closed walk that starts and ends at the same vertex. The total weight of a cycle is the sum of the weights of its constituent edges. A cycle is called negative if its total weight is strictly less than $0$. You are also given a designated directed edge $(u,v)$ inside the graph. Your task is to design and implement a program that, using first principles of shortest-path definitions and the Bellmanâ€“Ford algorithm, determines whether there exists a negative cycle that passes through the designated edge $(u,v)$. If such a cycle exists, the program must return one explicit instance of it as a list of vertex indices in order, starting at $u$, immediately traversing the designated edge to $v$, and then continuing until returning to $u$. If no such cycle exists, return the empty list for that test case.\n\nFundamental base and definitions to use:\n- A directed weighted graph is a tuple $(V,E,w)$, where $V$ is a finite set of vertices indexed by integers, $E \\subseteq V \\times V$ is the set of directed edges, and $w: E \\to \\mathbb{Z}$ assigns an integer weight to each edge.\n- For a path $P = (x_0, x_1, \\ldots, x_k)$ where $(x_i, x_{i+1}) \\in E$ for all $i \\in \\{0,\\ldots,k-1\\}$, the path weight is $\\sum_{i=0}^{k-1} w(x_i, x_{i+1})$.\n- For an edge $(u,v) \\in E$, and any path $Q$ from $v$ to $u$, the closed walk that traverses $(u,v)$ followed by $Q$ is a cycle. If there are no negative cycles that make shortest-path values ill-defined along the path to $u$, then a negative cycle passing through $(u,v)$ exists if and only if there exists a path $Q$ from $v$ to $u$ whose weight is strictly less than $-w(u,v)$, since the cycleâ€™s total weight is $w(u,v) + \\text{weight}(Q)$.\n\nYour program must:\n- Operate purely at the level of mathematical and algorithmic logic. No physical units are involved.\n- For each test case, determine whether a negative cycle that includes the designated edge $(u,v)$ exists under the graphâ€™s structure. If it exists, return one cycle as a list of integers representing vertex indices in order, starting at $u$, then $v$, and ending at $u$ to close the cycle. If it does not exist, return the empty list.\n- Apply the Bellmanâ€“Ford algorithm from $v$ to compute shortest-path estimates to $u$ and use predecessor information to reconstruct a path from $v$ back to $u$ when applicable. Combine this path with the designated edge $(u,v)$ to produce the cycle and verify its negativity by the fundamental definition. Avoid relying on any shortcut formulas beyond the fundamental definitions and widely accepted algorithmic facts.\n\nTest suite:\nFor each test case below, vertices are indexed by nonnegative integers, edges are given as triples $(a,b,w)$ with $a,b \\in V$ and weight $w \\in \\mathbb{Z}$, and the designated edge is $(u,v)$. The graphs are small and chosen to cover different facets: a clear negative cycle through the designated edge, absence of such a cycle, zero-weight cycle boundary, edge not present, multi-component graphs with unrelated negative cycles, and missing return path.\n\n- Test case $1$ (happy path, negative cycle exists through the designated edge):\n  - Number of vertices: $4$.\n  - Edges: $(1,2,-1)$, $(2,3,1)$, $(3,1,-1)$, $(0,1,4)$, $(0,2,2)$.\n  - Designated edge: $(1,2)$.\n  - There is a cycle $1 \\to 2 \\to 3 \\to 1$ with total weight $-1 + 1 + (-1) = -1$.\n\n- Test case $2$ (path exists but the resulting cycle is not negative):\n  - Number of vertices: $3$.\n  - Edges: $(0,1,2)$, $(1,2,1)$, $(2,0,0)$.\n  - Designated edge: $(0,1)$.\n  - The path from $1$ to $0$ has weight $1 + 0 = 1$, so the cycle weight is $2 + 1 = 3$, which is not negative.\n\n- Test case $3$ (designated edge not present):\n  - Number of vertices: $4$.\n  - Edges: $(0,1,1)$, $(1,2,1)$, $(2,0,1)$.\n  - Designated edge: $(3,2)$.\n  - Since $(3,2)$ is not in $E$, no cycle can pass through it.\n\n- Test case $4$ (zero-weight cycle boundary case):\n  - Number of vertices: $6$.\n  - Edges: $(4,5,-2)$, $(5,4,2)$, $(0,1,3)$, $(1,2,3)$, $(2,3,3)$, $(3,0,-1)$.\n  - Designated edge: $(4,5)$.\n  - The cycle $4 \\to 5 \\to 4$ has total weight $-2 + 2 = 0$, which is not negative.\n\n- Test case $5$ (negative cycle exists elsewhere but not through the designated edge):\n  - Number of vertices: $6$.\n  - Edges: $(0,3,0)$, $(3,4,1)$, $(4,0,0)$, $(1,2,-3)$, $(2,1,-3)$.\n  - Designated edge: $(0,3)$.\n  - There is a negative cycle between $1$ and $2$, but it is in a different component and does not imply a negative cycle through $(0,3)$.\n\n- Test case $6$ (designated edge present but no return path to close a cycle):\n  - Number of vertices: $2$.\n  - Edges: $(0,1,-1)$.\n  - Designated edge: $(0,1)$.\n  - There is no path from $1$ back to $0$, so no cycle exists.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is either the empty list (written as $[]$) or a list of integers denoting the vertex sequence of one found negative cycle that passes through $(u,v)$. There must be no spaces in the printed output. For example, the format must look like $[[1,2,3,1],[],\\ldots]$ with commas separating test case results and no spaces anywhere in the string.", "solution": "The problem requires us to determine if a directed, weighted graph $(V,E,w)$ contains a negative-weight cycle that passes through a designated edge $(u,v) \\in E$. If such a cycle exists, we must provide one instance of it.\n\nThe fundamental principle for identifying such a cycle is rooted in the definition of cycle weight. A cycle passing through the edge $(u,v)$ is formed by the traversal of $(u,v)$ followed by a path $P$ from vertex $v$ back to vertex $u$. The total weight of this cycle, $W_{cycle}$, is the sum of the weight of the edge $(u,v)$, denoted $w(u,v)$, and the weight of the path $P$, denoted $W(P_{v \\to u})$.\n$$W_{cycle} = w(u,v) + W(P_{v \\to u})$$\nThe cycle is negative if and only if its total weight is strictly less than zero.\n$$w(u,v) + W(P_{v \\to u})  0$$\nThis inequality can be rearranged to provide a condition on the path weight:\n$$W(P_{v \\to u})  -w(u,v)$$\nTo determine if such a path exists, we must find the path from $v$ to $u$ with the minimum possible weight. This is, by definition, the shortest path from $v$ to $u$. Let the weight of this shortest path be $\\delta(v,u)$. If $\\delta(v,u)  -w(u,v)$, then a negative cycle through $(u,v)$ is guaranteed to exist, formed by the edge $(u,v)$ and this shortest path. If even the shortest path does not satisfy this condition, no other path will, and thus no such negative cycle exists.\n\nThe problem statement includes a critical specification: \"if there are no negative cycles that make shortest-path values ill-defined along the path to $u$\". This implies that we can assume the shortest path weight $\\delta(v,u)$ is a finite value, rather than $-\\infty$, which would be the case if a negative-weight cycle were part of the shortest path from $v$ to $u$. This simplification allows for a direct application of a standard shortest-path algorithm.\n\nThe Bellman-Ford algorithm is the appropriate tool for this task, as it correctly computes single-source shortest paths in graphs that may contain negative-weight edges. We will execute the Bellman-Ford algorithm with vertex $v$ as the source to find the shortest path to all other vertices, including $u$.\n\nThe algorithmic procedure is as follows:\n\n1.  **Initial Validation**: First, we verify that the designated edge $(u,v)$ exists in the graph's edge set $E$. If it does not, no cycle can pass through it, and the process terminates for that test case. Let its weight be $w_{uv}$.\n\n2.  **Bellman-Ford Execution**: We initialize a distance array, $d$, of size $|V|$, with $d[v] = 0$ and $d[i] = \\infty$ for all other vertices $i \\in V$. A predecessor array, $p$, is also initialized to track the path. The core of the Bellman-Ford algorithm consists of relaxing every edge in the graph. This relaxation step is repeated $|V|-1$ times. For each edge $(x,y)$ with weight $w_{xy}$, the relaxation operation is: if $d[x] + w_{xy}  d[y]$, update $d[y]$ to $d[x] + w_{xy}$ and set $p[y] = x$. After $|V|-1$ iterations, $d[u]$ will hold the weight of the shortest path from $v$ to $u$, $\\delta(v,u)$, given the problem's simplifying assumption.\n\n3.  **Path and Cycle Existence Check**:\n    - If, after the algorithm completes, $d[u]$ remains $\\infty$, it signifies that there is no path from $v$ to $u$. Consequently, no cycle can be formed, and we conclude no such negative cycle exists.\n    - If a path exists (i.e., $d[u]$ is finite), we check the negativity condition: $d[u] + w_{uv}  0$. If this condition is not met, the cycle formed by the shortest path is not negative, and no other path from $v$ to $u$ can form a lighter cycle.\n\n4.  **Cycle Reconstruction**: If the negativity condition $d[u] + w_{uv}  0$ is satisfied, a negative cycle has been found. We must reconstruct its vertex sequence. This is done by backtracking from $u$ using the predecessor array $p$. We start with a list containing $u$, and iteratively prepend its predecessor $p[u]$, then $p[p[u]]$, and so on, until we reach $v$. This process yields the vertex list for the shortest path from $v$ to $u$, let's call it `path_v_to_u`. The final output is the ordered list of vertices forming the cycle, which starts at $u$, traverses the edge to $v$, and then follows the reconstructed path back to $u$. This corresponds to concatenating a list containing just $u$ with `path_v_to_u`, i.e., `[u] + path_v_to_u`. For a path $v \\to x_1 \\to \\dots \\to u$, the reconstructed path list is $[v, x_1, \\dots, u]$, and the final cycle list is $[u, v, x_1, \\dots, u]$.\n\nThis systematic approach, founded on the first principles of shortest paths and implemented with the Bellman-Ford algorithm, correctly solves the problem as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_negative_cycle_through_edge(num_vertices, edges, u, v):\n    \"\"\"\n    Determines if a negative cycle exists through a designated edge (u, v)\n    using the Bellman-Ford algorithm.\n\n    Args:\n        num_vertices (int): The number of vertices in the graph.\n        edges (list of tuples): The list of edges, each as (source, dest, weight).\n        u (int): The starting vertex of the designated edge.\n        v (int): The ending vertex of the designated edge.\n\n    Returns:\n        list: A list of vertex indices representing the negative cycle, starting and\n              ending at u. Returns an empty list if no such cycle exists.\n    \"\"\"\n    w_uv = None\n    edge_map = {(src, dst): weight for src, dst, weight in edges}\n    \n    if (u, v) not in edge_map:\n        return []\n    w_uv = edge_map[(u, v)]\n\n    # Step 2: Bellman-Ford from source v\n    dist = [np.inf] * num_vertices\n    pred = [None] * num_vertices\n    dist[v] = 0\n\n    for _ in range(num_vertices - 1):\n        for x, y, weight in edges:\n            if dist[x] != np.inf and dist[x] + weight  dist[y]:\n                dist[y] = dist[x] + weight\n                pred[y] = x\n\n    # Step 3: Path and Cycle Existence Check\n    if dist[u] == np.inf:\n        return []\n\n    if dist[u] + w_uv >= 0:\n        return []\n\n    # Step 4: Cycle Reconstruction\n    path_vu = []\n    curr = u\n    while True:\n        path_vu.insert(0, curr)\n        if curr == v:\n            break\n        curr = pred[curr]\n        # This safeguard is for unexpected graph structures, though not expected\n        # in this problem's context. If pred[curr] is None before reaching v,\n        # it means there's no path, which contradicts dist[u] being finite.\n        if curr is None and path_vu[0] != v:\n            return [] # Should not happen under normal BF operation\n\n    # The problem asks for the cycle starting at u, traversing (u,v), and returning to u.\n    # The sequence is u, followed by the path from v to u.\n    # Our reconstructed `path_vu` is the sequence of vertices from v to u.\n    # For example, for a path v -> x -> u, path_vu is [v, x, u].\n    # Cycle sequence u -> v -> x -> u is represented as [u, v, x, u].\n    # This is [u] + path_vu.\n    cycle = [u] + path_vu\n    \n    return cycle\n    \ndef solve():\n    \"\"\"\n    Defines the test cases from the problem statement and runs the solver.\n    \"\"\"\n    test_cases = [\n        {\n            \"num_vertices\": 4,\n            \"edges\": [(1, 2, -1), (2, 3, 1), (3, 1, -1), (0, 1, 4), (0, 2, 2)],\n            \"u\": 1, \"v\": 2,\n        },\n        {\n            \"num_vertices\": 3,\n            \"edges\": [(0, 1, 2), (1, 2, 1), (2, 0, 0)],\n            \"u\": 0, \"v\": 1,\n        },\n        {\n            \"num_vertices\": 4,\n            \"edges\": [(0, 1, 1), (1, 2, 1), (2, 0, 1)],\n            \"u\": 3, \"v\": 2,\n        },\n        {\n            \"num_vertices\": 6,\n            \"edges\": [(4, 5, -2), (5, 4, 2), (0, 1, 3), (1, 2, 3), (2, 3, 3), (3, 0, -1)],\n            \"u\": 4, \"v\": 5,\n        },\n        {\n            \"num_vertices\": 6,\n            \"edges\": [(0, 3, 0), (3, 4, 1), (4, 0, 0), (1, 2, -3), (2, 1, -3)],\n            \"u\": 0, \"v\": 3,\n        },\n        {\n            \"num_vertices\": 2,\n            \"edges\": [(0, 1, -1)],\n            \"u\": 0, \"v\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_negative_cycle_through_edge(\n            case[\"num_vertices\"], case[\"edges\"], case[\"u\"], case[\"v\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    result_strs = []\n    for r in results:\n        if r:\n            result_strs.append(f\"[{','.join(map(str, r))}]\")\n        else:\n            result_strs.append(\"[]\")\n    \n    print(f\"[{','.join(result_strs)}]\")\n\nsolve()\n```", "id": "3213972"}, {"introduction": "An algorithm that works on a whiteboard may fail in practice if its implementation ignores the physical constraints of a computer. This hands-on problem bridges the gap between theory and reality by focusing on a robust implementation of Bellman-Ford. You will address the critical issue of integer overflow that can arise when path weights become very large or small, a common scenario in real-world applications. By implementing careful, overflow-safe arithmetic, you will ensure your algorithm is not only theoretically correct but also practically reliable [@problem_id:3213991].", "problem": "You are given the task of designing and implementing a program that computes shortest path estimates in a directed weighted graph using the Bellmanâ€“Ford algorithm. The focus is to reason from core definitions of paths and cycles and to ensure the implementation uses only signed $64$-bit integer arithmetic, including a robust strategy to detect and handle potential overflows during relaxation.\n\nThe fundamental base to be used is the following set of definitions and properties:\n- A directed graph $G = (V, E)$ consists of a finite set of vertices $V$ and directed edges $E \\subseteq V \\times V$ with weights.\n- Each edge $(u, v) \\in E$ has an integer weight $w(u, v)$. A path $P = (v_0, v_1, \\dots, v_k)$ has total weight equal to the sum of its edge weights, that is $W(P) = \\sum_{i=0}^{k-1} w(v_i, v_{i+1})$.\n- A cycle is a path whose starting and ending vertex are the same. A cycle is negative if the sum of its edge weights is strictly less than $0$.\n- The Bellmanâ€“Ford algorithm iteratively relaxes edges based on path definitions, and it detects the presence of a negative cycle reachable from the source if an additional relaxation after $|V|-1$ iterations can still reduce some distance estimate.\n- All integer computations must conform to signed $64$-bit two's complement bounds. Define the smallest representable signed $64$-bit integer as $\\text{MIN} = -2^{63}$ and the largest as $\\text{MAX} = 2^{63}-1$.\n\nImplementation requirements:\n- Use only signed $64$-bit integer arithmetic for all path weight computations and comparisons. You must design a relaxation step that checks for potential overflow before attempting to add two signed $64$-bit integers $a$ and $b$. Overflow must be detected using inequalities on $\\text{MIN}$ and $\\text{MAX}$ without computing $a+b$ if it would exceed the representable bounds. If an overflow would occur during a relaxation attempt, the relaxation must be skipped (i.e., treated as no improvement).\n- Use the convention that an initially unreachable vertex has distance $\\text{INF} = \\text{MAX}$. Use the convention that a vertex affected by a negative cycle reachable from the source has distance $\\text{NEG\\_INF} = \\text{MIN}$. For scientific realism and to prevent ambiguous sentinel collisions, assume all edge weights lie strictly within the open interval $(\\text{MIN}, \\text{MAX})$ and that the program will not assign $\\text{MIN}$ through finite relaxation except when marking vertices as affected by a negative cycle.\n- The algorithm must detect vertices whose estimates can still be decreased on the $|V|$-th pass and then mark all vertices reachable from any such vertex as affected by a negative cycle reachable from the source. Those vertices must have their output distance set to $\\text{NEG\\_INF}$.\n\nYour program must be self-contained, with the following fixed test suite encoded within it. Interpret each test case as a directed graph with a specified source, and produce the computed result for that case.\n\nTest Suite:\n- Case $1$ (Happy path with no negative cycle):\n  - Vertices: $5$\n  - Edges: $(0,1,5)$, $(0,2,10)$, $(1,3,3)$, $(2,3,1)$, $(3,4,2)$\n  - Source: $0$\n  - Expected behavior: shortest path estimates computed normally.\n- Case $2$ (Negative cycle reachable from the source):\n  - Vertices: $4$\n  - Edges: $(0,1,1)$, $(1,2,-1)$, $(2,1,-1)$, $(2,3,2)$\n  - Source: $0$\n  - Expected behavior: detection and propagation of negative cycle reachability to affected vertices.\n- Case $3$ (Boundary weights inducing potential overflow handling during relaxation):\n  - Vertices: $4$\n  - Edges: $(0,1, \\text{MAX}-1)$, $(1,2, 10)$, $(1,3, \\text{MIN}+10)$\n  - Source: $0$\n  - Expected behavior: a relaxation that would overflow is skipped; other relaxations proceed if within bounds.\n- Case $4$ (Disconnected graph with an unreachable negative cycle):\n  - Vertices: $5$\n  - Edges: $(1,2,4)$, $(2,3,5)$, $(3,1,-12)$\n  - Source: $0$\n  - Expected behavior: unreachable vertices retain $\\text{INF}$; the negative cycle is not reachable from the source and thus does not affect outputs.\n\nFinal Output Format:\n- For each test case, produce a list containing two elements: the boolean indicating whether some vertex is affected by a negative cycle reachable from the source, and a list of signed $64$-bit integers representing the distance to each vertex where $\\text{INF} = 2^{63}-1$ denotes unreachable and $\\text{NEG\\_INF} = -2^{63}$ denotes affected by a reachable negative cycle.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. For example, the overall output should look like $[ [\\text{boolean}, [\\text{d}_0,\\dots,\\text{d}_{n-1}] ], \\dots ]$ with literal Python syntax in the printed line.", "solution": "The provided problem is valid. It is a well-defined task in the domain of graph algorithms, grounded in standard computer science principles. The constraints on arithmetic and overflow handling are specific and formalizable.\n\nThe goal is to implement the Bellmanâ€“Ford algorithm for finding shortest paths in a directed, weighted graph $G=(V, E)$ from a given source vertex $s \\in V$. The implementation must strictly adhere to signed $64$-bit integer arithmetic, including robust overflow detection, and correctly handle negative-weight cycles.\n\nThe core principle of the Bellman-Ford algorithm is iterative relaxation based on the property that a shortest path in a graph with no negative-weight cycles can have at most $|V|-1$ edges. Let $d[v]$ be the estimated weight of the shortest path from the source $s$ to any vertex $v \\in V$.\n\n**1. Initialization**\nFirst, we initialize the distance estimates. The distance to the source $s$ is $0$, and the distance to all other vertices is $\\infty$. For this problem, we must use the signed $64$-bit integer limits. We define $\\text{INF}$ as the maximum representable value, $\\text{MAX} = 2^{63}-1$, and $\\text{NEG\\_INF}$ as the minimum representable value, $\\text{MIN} = -2^{63}$.\nThe distance array, $d$, is initialized as:\n$d[s] = 0$\n$d[v] = \\text{INF}$ for all $v \\in V, v \\neq s$.\n\n**2. Iterative Relaxation with Overflow Safety**\nThe algorithm proceeds by relaxing edges repeatedly. For each edge $(u, v) \\in E$ with weight $w(u,v)$, relaxation is the process of checking if the path through $u$ provides a shorter path to $v$. The standard relaxation is:\nif $d[u] + w(u,v)  d[v]$, then update $d[v] = d[u] + w(u,v)$.\n\nThis loop is executed $|V|-1$ times. After $i$ iterations, the algorithm finds all shortest paths of at most $i$ edges. After $|V|-1$ iterations, it has found all shortest paths, provided no negative-weight cycles exist.\n\nA critical requirement is to perform this addition with overflow safety within signed $64$-bit integer bounds. Before computing $a+b$, where $a=d[u]$ and $b=w(u,v)$, we must check if the result would exceed $[\\text{MIN}, \\text{MAX}]$. An overflow occurs if:\n- **Positive Overflow**: $a  0$, $b  0$, and $b  \\text{MAX} - a$.\n- **Negative Overflow**: $a  0$, $b  0$, and $b  \\text{MIN} - a$.\nIf an overflow is detected, the relaxation is skipped, as if no shorter path was found. We also do not relax from a vertex $u$ if $d[u] = \\text{INF}$.\n\n**3. Negative-Weight Cycle Detection**\nAfter $|V|-1$ iterations, a final, $|V|$-th, iteration over all edges is performed. If any distance $d[v]$ can still be improved, it signifies that $v$ is part of or reachable from a negative-weight cycle that is itself reachable from the source $s$.\nSpecifically, we identify a set of \"infected\" vertices:\n$$I = \\{ v \\in V \\mid \\exists (u, v) \\in E \\text{ such that } d[u] + w(u,v)  d[v] \\text{ after } |V|-1 \\text{ passes} \\}$$\nThe same overflow-safe addition must be used in this check. If this set $I$ is non-empty, a reachable negative-weight cycle has been detected.\n\n**4. Negative-Weight Cycle Propagation**\nThe presence of a negative-weight cycle means the shortest path to vertices affected by it is undefined (or can be considered $-\\infty$). The problem requires us to identify all such vertices and set their distance to $\\text{NEG\\_INF}$. A vertex is affected if it is reachable from any vertex that is part of a negative-weight cycle. Our set $I$ contains vertices whose distances were shortened in the $|V|$-th pass. These vertices are guaranteed to be reachable from a negative cycle. Therefore, any vertex reachable from a vertex in $I$ is also affected.\n\nTo implement this, we perform a graph traversal (such as Breadth-First Search or Depth-First Search) starting from all vertices in the set $I$. All vertices visited during this traversal have their final distance set to $\\text{NEG\\_INF}$.\n\n**5. Final Result Formulation**\nThe output for each test case is a pair: a boolean value indicating if a reachable negative-weight cycle was detected (i.e., if the set $I$ was non-empty), and a list of the final distances to each vertex. Distances to unreachable vertices remain $\\text{INF}$, and distances to vertices affected by a negative cycle are set to $\\text{NEG\\_INF}$.\nThe implementation will process the provided test suite, applying this logic to each case, and format the collected results into a single output string as specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Bellman-Ford problem for a fixed test suite,\n    adhering to strict 64-bit signed integer arithmetic and overflow handling.\n    \"\"\"\n\n    # Define 64-bit signed integer constants.\n    MIN = np.iinfo(np.int64).min\n    MAX = np.iinfo(np.int64).max\n\n    # Define the fixed test suite.\n    test_cases = [\n        {\n            \"num_vertices\": 5,\n            \"edges\": [(0, 1, 5), (0, 2, 10), (1, 3, 3), (2, 3, 1), (3, 4, 2)],\n            \"source\": 0,\n        },\n        {\n            \"num_vertices\": 4,\n            \"edges\": [(0, 1, 1), (1, 2, -1), (2, 1, -1), (2, 3, 2)],\n            \"source\": 0,\n        },\n        {\n            \"num_vertices\": 4,\n            \"edges\": [\n                (0, 1, int(MAX) - 1),\n                (1, 2, 10),\n                (1, 3, int(MIN) + 10),\n            ],\n            \"source\": 0,\n        },\n        {\n            \"num_vertices\": 5,\n            \"edges\": [(1, 2, 4), (2, 3, 5), (3, 1, -12)],\n            \"source\": 0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        num_vertices = case[\"num_vertices\"]\n        edges = case[\"edges\"]\n        source = case[\"source\"]\n\n        # Initialize distances using 64-bit integers.\n        # INF is represented by MAX.\n        dist = np.full(num_vertices, MAX, dtype=np.int64)\n        dist[source] = np.int64(0)\n\n        # Main Bellman-Ford relaxation loop for |V| - 1 iterations.\n        for _ in range(num_vertices - 1):\n            for u, v, w in edges:\n                # Use Python's arbitrary-precision integers for checks to avoid overflow.\n                d_u = int(dist[u])\n                \n                # Skip relaxation if source vertex is unreachable.\n                if d_u == int(MAX):\n                    continue\n                \n                # Overflow-safe addition check.\n                if w > 0 and d_u > int(MAX) - w:  # Positive overflow\n                    continue\n                if w  0 and d_u  int(MIN) - w:  # Negative overflow\n                    continue\n                \n                new_dist = d_u + w\n                if new_dist  int(dist[v]):\n                    dist[v] = np.int64(new_dist)\n\n        # Detect vertices affected by negative cycles in the |V|-th iteration.\n        infected_nodes = set()\n        for u, v, w in edges:\n            d_u = int(dist[u])\n            if d_u == int(MAX):\n                continue\n            \n            if w > 0 and d_u > int(MAX) - w:\n                continue\n            if w  0 and d_u  int(MIN) - w:\n                continue\n\n            new_dist = d_u + w\n            if new_dist  int(dist[v]):\n                infected_nodes.add(v)\n        \n        has_neg_cycle = bool(infected_nodes)\n\n        # Propagate negative cycle effect to all reachable vertices.\n        # NEG_INF is represented by MIN.\n        if has_neg_cycle:\n            adj = [[] for _ in range(num_vertices)]\n            for u, v, _ in edges:\n                adj[u].append(v)\n            \n            # Multi-source BFS/DFS from all initially infected nodes.\n            q = list(infected_nodes)\n            visited = set(q)\n            head = 0\n            while head  len(q):\n                u = q[head]\n                head += 1\n                dist[u] = MIN\n                for v_neighbor in adj[u]:\n                    if v_neighbor not in visited:\n                        visited.add(v_neighbor)\n                        q.append(v_neighbor)\n\n        # Convert numpy array to list of Python integers for final output.\n        final_dists = [int(d) for d in dist]\n        results.append([has_neg_cycle, final_dists])\n\n    # Print the results in the specified single-line format.\n    # The string representation of a list includes spaces, which is fine.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3213991"}]}