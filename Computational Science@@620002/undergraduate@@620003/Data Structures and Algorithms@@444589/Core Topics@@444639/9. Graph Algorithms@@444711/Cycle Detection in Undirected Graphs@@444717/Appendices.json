{"hands_on_practices": [{"introduction": "Before we can analyze the properties of cycles, we must first be able to answer the fundamental question: does a cycle even exist? This practice explores the core algorithm for detecting cycles in any undirected graph, a crucial skill for identifying important structures like trees and forests. By performing a Depth-First Search (DFS) and keeping track of visited nodes, you will learn to spot the \"back-edges\" that are the definitive evidence of a cycle, a concept illustrated here through the practical example of verifying a video game's dungeon layout [@problem_id:3225348].", "problem": "A video game dungeon layout can be modeled as a finite, simple, undirected graph with vertex set $V$ and edge set $E$, where each vertex is a room and each edge is a bidirectional corridor between two distinct rooms. A cycle is a sequence of distinct vertices $v_{0}, v_{1}, \\dots, v_{k-1}$ with $k \\geq 3$ such that $\\{v_{i}, v_{(i+1) \\bmod k}\\}$ is an edge for every $i \\in \\{0, 1, \\dots, k-1\\}$. A graph is acyclic if it contains no cycle. A forest is an acyclic undirected graph, possibly with multiple connected components. To ensure the dungeon is a simple branching path system rather than a maze, it must be acyclic in every connected component, that is, it must be a forest.\n\nFundamental base and constraints:\n- The graph is finite, simple, and undirected: edges are unordered pairs of distinct vertices, there are no multiple edges, and no self-loops.\n- Vertices are labeled by consecutive integers from $0$ to $n-1$, where $n = |V|$.\n- The task is to determine acyclicity based on the definitions above, not by assuming any particular algorithmic shortcut.\n\nTask:\n- Write a complete program that, for each test case below, determines whether the given undirected graph is acyclic in every connected component (i.e., whether it is a forest) and outputs a boolean value for each case.\n\nInput model for your program:\n- There is no external input. Instead, use the embedded test suite below as the internal data source.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces, in the order of the test cases listed below. Each element must be either True or False with that exact capitalization. For example, a valid output format is $[True,False]$.\n\nTest suite (each test case is a pair $(n, E)$ where $n$ is the number of vertices and $E$ is the list of undirected edges as unordered pairs of vertex labels):\n- Case $1$: $n = 5$, $E = \\{(0,1),(1,2),(1,3),(3,4)\\}$. This connected graph has branching but no cycles; it should be acyclic.\n- Case $2$: $n = 5$, $E = \\{(0,1),(1,2),(2,3),(3,0)\\}$. This connected graph contains a cycle; it should be cyclic.\n- Case $3$: $n = 7$, $E = \\{(0,1),(0,2),(2,3),(4,5)\\}$, with vertex $6$ isolated. This disconnected graph has only tree components and an isolated vertex; it should be acyclic.\n- Case $4$: $n = 6$, $E = \\{(0,1),(1,2),(2,0),(3,4),(4,5)\\}$. This disconnected graph has a cyclic component and an acyclic component; overall it should be cyclic.\n- Case $5$: $n = 1$, $E = \\{\\}$. A single isolated vertex; it should be acyclic.\n- Case $6$: $n = 2$, $E = \\{(0,1)\\}$. A single edge between two vertices; it should be acyclic.\n\nYour program must compute, for each case, a boolean indicating whether the graph is acyclic (True if and only if it is a forest), and then print a single line in the exact format described above aggregating the results for cases $1$ through $6$ in order. No physical units or angle units are involved in this problem, and no percentage expressions are required or permitted in the output. The expected answer types are booleans.", "solution": "The problem requires determining whether a given simple, undirected graph is a forest. A forest is defined as an acyclic undirected graph, which may consist of one or more connected components, where each component is a tree (an acyclic connected graph) or an isolated vertex. The core of the problem is to detect the presence of any cycle within any of the graph's components. A graph is acyclic if and only if it contains no cycles.\n\nThe most fundamental and rigorous method to detect cycles in an undirected graph is to use a graph traversal algorithm, such as Depth-First Search (DFS). The principle behind using DFS for cycle detection is based on the structure of the DFS traversal itself, which partitions the graph's edges into tree edges and back edges.\n\nA cycle exists in an undirected graph if and only if the DFS traversal encounters a \"back edge\". A back edge is an edge $(u, v)$ from a currently visited vertex $u$ to a vertex $v$ that has already been visited and is not the immediate parent of $u$ in the DFS tree. If $v$ is the parent of $u$, the edge $(u, v)$ is simply the tree edge that was used to discover $u$, and tracing it back does not form a cycle. However, if $v$ is already visited and is not the parent of $u$, it means $v$ is an ancestor of $u$ in the DFS tree, and the edge $(u, v)$ closes a path, thus forming a cycle.\n\nThe algorithm proceeds as follows for each test case, which is a graph $G = (V, E)$ with $n = |V|$ vertices labeled $0, 1, \\dots, n-1$:\n\n1.  **Graph Representation**: The graph, given as a list of edges $E$, is first converted into an adjacency list representation. An adjacency list, denoted `adj`, is an array or map where `adj[u]` stores a list of all vertices $v$ such that $\\{u, v\\} \\in E$. This structure allows for efficient iteration over the neighbors of any given vertex.\n\n2.  **State Tracking**: A boolean array, `visited`, of size $n$ is initialized with all entries set to `False`. This array is used to keep track of the vertices that have been visited during the traversal. `visited[v] = True` indicates that vertex $v$ has been encountered.\n\n3.  **Component Traversal**: To handle graphs that may be disconnected (i.e., have multiple connected components), the algorithm iterates through every vertex $u \\in \\{0, 1, \\dots, n-1\\}$. If a vertex $u$ has not yet been visited (`visited[u]` is `False`), it signifies the start of a new, unexplored connected component. A DFS traversal is initiated from this vertex $u$.\n\n4.  **Recursive DFS for Cycle Detection**: A recursive function, let's call it `dfs_check(u, p)`, is defined to perform the traversal and cycle detection.\n    -   It takes two arguments: the current vertex $u$ being visited, and its parent $p$ in the DFS tree from which $u$ was discovered. The parent $p$ is crucial to distinguish valid parent-child tree edges from cycle-forming back edges. For the initial call on a new component, the parent can be a sentinel value, such as $-1$, since the root of a DFS tree has no parent.\n    -   Upon entering `dfs_check(u, p)`:\n        a. The current vertex $u$ is marked as visited: `visited[u] = True`.\n        b. The algorithm iterates through each neighbor $v$ in the adjacency list of $u$.\n        c. For each neighbor $v$:\n            i.  If $v$ has not been visited (`visited[v]` is `False`), it means $(u, v)$ is a tree edge. A recursive call `dfs_check(v, u)` is made to continue the traversal deeper into the graph. If this recursive call returns `True` (indicating that a cycle was found in the subtree rooted at $v$), the current function immediately returns `True` to propagate the cycle detection result up the call stack.\n            ii. If $v$ has already been visited (`visited[v]` is `True`) and $v$ is not the parent of $u$ (i.e., $v \\neq p$), this condition signifies that a back edge has been found. The vertex $v$ was visited earlier in the current traversal, meaning there is a path from $v$ to $u$ in the DFS tree, and the edge $(u, v)$ closes this path to form a cycle. In this case, the function returns `True`.\n    -   If the loop over all neighbors of $u$ completes without returning `True`, it means no cycles were detected in the subtree rooted at $u$. The function then returns `False`.\n\n5.  **Final Verdict**: During the main loop iterating from vertex $0$ to $n-1$, if any call to `dfs_check` returns `True`, it means a cycle has been found somewhere in the graph. The algorithm can terminate immediately and conclude that the graph is not a forest. The result for this test case is `False`. If the main loop completes without any `dfs_check` call returning `True`, it confirms that no cycles exist in any of the graph's components. Therefore, the graph is a forest, and the result for the test case is `True`.\n\nThis procedure is exhaustive and correct for any finite, simple, undirected graph. It correctly handles isolated vertices, single connected components (trees), and multiple disconnected components (forests).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the cycle detection problem for a batch of test cases.\n    \"\"\"\n    \n    # Test suite as defined in the problem statement.\n    test_cases = [\n        # Case 1: n = 5, E = {(0,1),(1,2),(1,3),(3,4)} -> Acyclic (Tree)\n        (5, [(0, 1), (1, 2), (1, 3), (3, 4)]),\n        # Case 2: n = 5, E = {(0,1),(1,2),(2,3),(3,0)} -> Cyclic\n        (5, [(0, 1), (1, 2), (2, 3), (3, 0)]),\n        # Case 3: n = 7, E = {(0,1),(0,2),(2,3),(4,5)} -> Acyclic (Forest)\n        (7, [(0, 1), (0, 2), (2, 3), (4, 5)]),\n        # Case 4: n = 6, E = {(0,1),(1,2),(2,0),(3,4),(4,5)} -> Cyclic (one component)\n        (6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5)]),\n        # Case 5: n = 1, E = {} -> Acyclic (Isolated vertex)\n        (1, []),\n        # Case 6: n = 2, E = {(0,1)} -> Acyclic (Single edge)\n        (2, [(0, 1)])\n    ]\n\n    def is_graph_acyclic(n, edges):\n        \"\"\"\n        Determines if a graph with n vertices and a given edge list is acyclic.\n        An empty graph or a graph with no vertices is considered acyclic.\n        \n        Args:\n            n (int): The number of vertices, labeled 0 to n-1.\n            edges (list of tuples): The list of edges in the graph.\n            \n        Returns:\n            bool: True if the graph is a forest (acyclic), False otherwise.\n        \"\"\"\n        if n == 0:\n            return True\n        \n        # 1. Build adjacency list representation of the graph\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n            \n        # 2. Keep track of visited vertices for all DFS traversals\n        visited = [False] * n\n\n        def has_cycle_dfs(u, parent):\n            \"\"\"\n            Recursive DFS function to detect a cycle in a connected component.\n            \n            Args:\n                u (int): The current vertex being visited.\n                parent (int): The parent vertex from which u was discovered.\n            \n            Returns:\n                bool: True if a cycle is detected, False otherwise.\n            \"\"\"\n            visited[u] = True\n            \n            for v in adj[u]:\n                # If neighbor v is not visited yet, recurse on it\n                if not visited[v]:\n                    if has_cycle_dfs(v, u):\n                        return True\n                # If v is visited and is not the parent of u, then there is a cycle\n                elif v != parent:\n                    return True\n            \n            return False\n\n        # 3. Iterate through all vertices to handle disconnected graphs (forests)\n        for i in range(n):\n            if not visited[i]:\n                # If a cycle is found in any component, the whole graph is considered cyclic.\n                # The parent of the starting node of a component's traversal is -1 (a sentinel value).\n                if has_cycle_dfs(i, -1):\n                    return False\n        \n        # 4. If no cycles are found after checking all components, the graph is acyclic.\n        return True\n\n    results = []\n    for n, edges in test_cases:\n        # Acyclic means it's a forest, so the function should return True.\n        # We want to output this boolean directly.\n        is_acyclic = is_graph_acyclic(n, edges)\n        results.append(str(is_acyclic))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3225348"}, {"introduction": "Once we know a graph contains cycles, a natural next question is to quantify them. The 'girth' of a graph, defined as the length of its shortest cycle, is a key topological property. This exercise challenges you to move beyond simple detection and compute this value by leveraging the power of Breadth-First Search (BFS), whose level-by-level traversal is perfectly suited for finding shortest paths, and by extension, shortest cycles [@problem_id:3225402].", "problem": "You are given the task of designing and implementing a complete, runnable program to compute the girth of an undirected, simple, unweighted graph. The girth of a graph is defined as the length (number of edges) of its shortest cycle. If a graph has no cycle, its girth is defined to be $0$. All vertices are labeled with consecutive integers starting from $0$. Graphs are specified by the number of vertices and a list of undirected edges. The graphs in the test suite are simple: they contain no parallel edges and no self-loops.\n\nFundamental definitions and facts form the base of this task:\n- An undirected graph $G$ is a pair $G = (V, E)$, where $V$ is the set of vertices and $E$ is the set of undirected edges, each edge being a $2$-element subset of $V$.\n- A path is a sequence of vertices with consecutive pairs connected by edges.\n- A cycle is a path that starts and ends at the same vertex and has at least $3$ distinct vertices.\n- Breadth-First Search (BFS) is an algorithm that explores vertices in nondecreasing order of their distance (in number of edges) from a chosen source vertex in an unweighted graph.\n- The BFS distance from a source vertex $s$ to a vertex $u$, denoted $d_s(u)$, equals the length of the shortest path from $s$ to $u$.\n\nStarting from these core definitions and facts, derive an algorithm that computes the girth of a general undirected simple graph. The program must not accept input; instead, it must embed and execute a predefined test suite of graphs, compute the girth for each, and then print the results in the specified final output format.\n\nModel and assumptions:\n- Each graph is specified by $n$, the number of vertices, and a list of edges as ordered pairs $(i,j)$ representing the undirected edge $\\{i,j\\}$, with $i \\in \\{0,1,\\dots,n-1\\}$ and $j \\in \\{0,1,\\dots,n-1\\}$, and $i \\neq j$.\n- All graphs are simple and undirected: no parallel edges, no self-loops.\n- The girth is the minimum cycle length across all connected components; if no cycle exists in any component, the girth is $0$.\n\nTest suite:\nCompute the girth for the following five graphs. Vertex labels are $0$-based.\n\n- Test case $1$ (multiple cycles; smallest is a triangle):\n  - $n = 7$\n  - $E = \\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,5),(5,2),(5,6)\\}$\n  - Expected girth is $3$.\n- Test case $2$ (acyclic tree):\n  - $n = 5$\n  - $E = \\{(0,1),(1,2),(2,3),(3,4)\\}$\n  - Expected girth is $0$.\n- Test case $3$ (single cycle of length $4$ with branches):\n  - $n = 6$\n  - $E = \\{(0,1),(1,2),(2,3),(3,0),(0,4),(2,5)\\}$\n  - Expected girth is $4$.\n- Test case $4$ (disconnected: one path component and one $5$-cycle component):\n  - $n = 8$\n  - $E = \\{(0,1),(1,2),(3,4),(4,5),(5,6),(6,7),(7,3)\\}$\n  - Expected girth is $5$.\n- Test case $5$ (hexagon with a tail):\n  - $n = 7$\n  - $E = \\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,0),(0,6)\\}$\n  - Expected girth is $6$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces. For example, if the five computed girths are $3$, $0$, $4$, $5$, and $6$, the output must be [$3$,$0$,$4$,$5$,$6$].", "solution": "The problem requires the derivation and implementation of an algorithm to compute the girth of a simple, undirected, unweighted graph $G=(V, E)$, where $V$ is the set of vertices and $E$ is the set of edges. The girth is defined as the length of the shortest cycle in the graph. If the graph contains no cycles (i.e., it is a forest), its girth is defined to be $0$.\n\nThe fundamental principle for finding a cycle in a graph is to detect a \"back edge\" during a traversal. A back edge is an edge that connects a vertex to an ancestor in the traversal tree that is not its direct parent. The most suitable traversal algorithm for finding the *shortest* cycle is Breadth-First Search (BFS), because BFS explores the graph layer by layer, guaranteeing that it finds the shortest path from a source vertex to all other vertices in terms of the number of edges.\n\nLet us formalize the algorithm. The girth of a graph is the minimum cycle length over all its connected components. Our algorithm must therefore correctly handle both connected and disconnected graphs. We can achieve this by iterating through each vertex of the graph and initiating a traversal, ensuring all components are explored. The overall girth will be the minimum of the shortest cycle lengths found in each component.\n\nThe core of the algorithm involves running a separate BFS from each vertex $s \\in V$. For a given BFS starting at source $s$, we maintain the distance $d_s(u)$ from $s$ to every other vertex $u$, and the parent $p_s(u)$ of each vertex $u$ in the BFS tree.\n\nDuring the BFS starting from $s$, let us consider the process when we are at a vertex $u$ and are exploring its adjacent vertices. For each neighbor $v$ of $u$:\n$1$. If $v$ has not yet been visited in this BFS (i.e., $d_s(v) = \\infty$), we have found a new vertex to add to the BFS tree. We set its distance $d_s(v) = d_s(u) + 1$ and its parent $p_s(v) = u$.\n$2$. If $v$ has already been visited, a cycle has been detected. The edge $(u,v)$ closes a loop. This loop consists of three parts: the path from the source $s$ to $u$, the edge $(u,v)$, and the path from $v$ back to the source $s$. However, we must exclude the trivial case where $v$ is the immediate parent of $u$ (i.e., $v = p_s(u)$), because in an undirected graph, this corresponds to simply traversing an edge and its reverse, which does not constitute a cycle. Therefore, a cycle is confirmed if and only if $v$ has been visited and $v \\neq p_s(u)$.\n\nWhen such a cycle is found, its length is the sum of the distances of $u$ and $v$ from the source $s$, plus one for the closing edge $(u,v)$. The length $L$ of this cycle is given by $L = d_s(u) + d_s(v) + 1$.\n\nBy executing a separate BFS from every vertex $s \\in V$ and keeping track of the minimum cycle length discovered across all these traversals, we ensure that we find the global shortest cycle. The reason this works is that any cycle in the graph, say of length $k$, will be composed of vertices. When we run a BFS starting from any one of those $k$ vertices, that cycle (or a shorter one) will eventually be detected. The process of iterating through all possible start vertices guarantees that the shortest cycle is found.\n\nThe complete algorithm is as follows:\n$1$. Let the number of vertices be $n$ and the set of edges be $E$. Represent the graph using an adjacency list.\n$2$. Initialize a variable for the minimum cycle length, $girth \\leftarrow \\infty$.\n$3$. For each vertex $s$ from $0$ to $n-1$:\n    a. Initiate a BFS starting from $s$.\n    b. Create a distance array $d$ of size $n$, initialized to a sentinel value (e.g., $-1$) representing infinity, and a parent array $p$ of size $n$, also initialized to $-1$.\n    c. Set $d[s] \\leftarrow 0$ and initialize a queue $Q$ with $s$.\n    d. While $Q$ is not empty:\n        i. Dequeue a vertex $u$.\n        ii. For each neighbor $v$ of $u$:\n            - If $d[v] = -1$ (i.e., $v$ is unvisited):\n                Set $d[v] \\leftarrow d[u] + 1$.\n                Set $p[v] \\leftarrow u$.\n                Enqueue $v$.\n            - Else if $v \\neq p[u]$:\n                A cycle has been found. Calculate its length $L = d[u] + d[v] + 1$.\n                Update $girth \\leftarrow \\min(girth, L)$.\n$4$. After the outer loop completes, if $girth$ remains $\\infty$, the graph has no cycles, so the girth is $0$. Otherwise, the girth is the final value of $girth$.\n\nThe time complexity of this algorithm is determined by running a BFS from each of the $n$ vertices. A single BFS on a graph with $n$ vertices and $m$ edges takes $O(n+m)$ time. Therefore, the total time complexity is $O(n(n+m))$. The space complexity is dominated by the adjacency list, which is $O(n+m)$, and the data structures for each BFS run (distance and parent arrays, queue), which are $O(n)$, resulting in a total space complexity of $O(n+m)$. This approach is sound and computationally feasible for the graphs specified in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the girth computation problem for a predefined test suite of graphs.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (number_of_vertices, list_of_edges)\n    test_cases = [\n        # Test case 1 (multiple cycles; smallest is a triangle):\n        (7, [(0, 1), (1, 2), (2, 0), (2, 3), (3, 4), (4, 5), (5, 2), (5, 6)]),\n        # Test case 2 (acyclic tree):\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4)]),\n        # Test case 3 (single cycle of length 4 with branches):\n        (6, [(0, 1), (1, 2), (2, 3), (3, 0), (0, 4), (2, 5)]),\n        # Test case 4 (disconnected: one path and one 5-cycle):\n        (8, [(0, 1), (1, 2), (3, 4), (4, 5), (5, 6), (6, 7), (7, 3)]),\n        # Test case 5 (hexagon with a tail):\n        (7, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0), (0, 6)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        girth = compute_girth(n, edges)\n        results.append(girth)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_girth(n, edges):\n    \"\"\"\n    Computes the girth of an undirected, simple, unweighted graph.\n\n    The girth is the length of the shortest cycle. If the graph is acyclic,\n    the girth is defined as 0.\n\n    The algorithm iterates through each vertex, treating it as a source for a\n    Breadth-First Search (BFS). During the BFS, if we encounter an already\n    visited vertex that is not the immediate parent of the current vertex,\n    we have found a cycle. The length of this cycle is the sum of the\n    distances of the two adjacent vertices from the source plus one. We keep\n    track of the minimum such length found across all BFS runs.\n\n    Args:\n        n (int): The number of vertices in the graph, labeled 0 to n-1.\n        edges (list of tuples): A list of pairs (u, v) representing\n                               undirected edges.\n\n    Returns:\n        int: The girth of the graph.\n    \"\"\"\n    if n == 0:\n        return 0\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    min_cycle_length = float('inf')\n\n    # Run a BFS from each vertex to find the shortest cycle\n    for start_node in range(n):\n        # distance array: dist[i] stores the shortest distance from start_node to i\n        # parent array: parent[i] stores the parent of i in the BFS tree\n        # Using -1 as a sentinel for unvisited nodes\n        dist = np.full(n, -1, dtype=int)\n        parent = np.full(n, -1, dtype=int)\n        \n        q = deque()\n\n        dist[start_node] = 0\n        q.append(start_node)\n\n        while q:\n            current_node = q.popleft()\n\n            for neighbor in adj[current_node]:\n                if dist[neighbor] == -1:\n                    # Neighbor has not been visited\n                    dist[neighbor] = dist[current_node] + 1\n                    parent[neighbor] = current_node\n                    q.append(neighbor)\n                elif neighbor != parent[current_node]:\n                    # Cycle detected. The neighbor has been visited and is not\n                    # the direct parent of the current node in the BFS tree.\n                    cycle_len = dist[current_node] + dist[neighbor] + 1\n                    min_cycle_length = min(min_cycle_length, cycle_len)\n    \n    # If min_cycle_length remains infinity, the graph is acyclic.\n    if min_cycle_length == float('inf'):\n        return 0\n    else:\n        return int(min_cycle_length)\n\n# Execute the solution\nsolve()\n\n```", "id": "3225402"}, {"introduction": "Cycle detection is not just an analytical tool; it is a critical component in algorithms that modify graph structures. This practice introduces the problem of finding a minimum feedback edge set—the smallest set of edges to remove to make a graph acyclic. You will implement a constructive algorithm based on the principles of Kruskal's algorithm, which builds a maximum spanning forest by iteratively adding edges and using an efficient cycle check to discard any that would form a loop [@problem_id:3225361].", "problem": "Given an undirected simple graph $G = (V, E)$ on a finite vertex set $V$ and edge set $E$, a cycle is any sequence of distinct vertices $(v_0, v_1, \\dots, v_{k-1})$ with $k \\ge 3$ such that $(v_i, v_{i+1}) \\in E$ for all $i \\in \\{0,1,\\dots,k-2\\}$ and $(v_{k-1}, v_0) \\in E$. A forest is an acyclic undirected graph. A feedback edge set is a set $F \\subseteq E$ such that removing the edges in $F$ from $G$ yields a forest. The minimum feedback edge set problem asks for a set $F$ of minimum cardinality that makes the graph acyclic when removed.\n\nYour task is to write a complete program that, for each graph in the test suite specified below, returns one canonical minimum feedback edge set according to the following tie-breaking rule. Represent each undirected edge $(u, v)$ with the ordered pair $(\\min(u, v), \\max(u, v))$. Consider the sequence of edges obtained by sorting all edges in ascending lexicographic order of these ordered pairs. Starting from the empty graph on $V$, scan this sorted edge list from left to right. An edge is kept if it connects two different connected components of the current partial graph and is discarded into the feedback edge set $F$ if and only if it would connect two vertices already in the same connected component. The output for a graph is the list of all discarded edges, in the order they are encountered during this scan. This rule uniquely determines the output without prescribing any particular internal data structure.\n\nThe vertices in all test graphs are labeled by integers in the range $\\{0,1,\\dots,n-1\\}$, where $n = |V|$. Edges are specified as pairs $(u, v)$ with $0 \\le u, v < n$, $u \\ne v$. The graphs are simple: there are no self-loops and no parallel edges.\n\nTest suite:\n- Graph $\\mathrm{A}$: $n = 6$, $E = \\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,2),(4,5)\\}$. This graph is connected and contains multiple cycles sharing vertices.\n- Graph $\\mathrm{B}$: $n = 7$, $E = \\{(0,1),(1,2),(2,0),(3,4),(4,5),(5,6),(3,5)\\}$. This graph has two connected components, one cyclic and one that is a path augmented to form a cycle.\n- Graph $\\mathrm{C}$: $n = 5$, $E = \\{(0,1),(1,2),(3,4)\\}$. This graph is already a forest (acyclic).\n- Graph $\\mathrm{D}$: $n = 1$, $E = \\varnothing$. This graph has a single vertex and no edges.\n- Graph $\\mathrm{E}$: $n = 4$, $E = \\{(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)\\}$. This graph is the complete graph on four vertices.\n\nRequired final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each graph’s result must itself be a list of edges, where each edge is written as a two-element list $[u,v]$ with $u < v$. There must be no spaces in the output. For example, a two-edge result is written as $[[u_1,v_1],[u_2,v_2]]$. With the five graphs above, the final output should be a single line of the form $[R_A,R_B,R_C,R_D,R_E]$, where $R_X$ is the list for graph $\\mathrm{X}$ as described.\n\nAnswers involve only discrete structures and contain no physical units or angles. All computed outputs are lists of integers, which are fundamental types.", "solution": "The user-provided problem has been analyzed and is deemed valid. It is a well-posed problem within the domain of algorithmic graph theory, free of scientific or logical inconsistencies. The definitions and the prescribed procedure are standard and unambiguous.\n\nThe problem asks for the computation of a canonical minimum feedback edge set for a given undirected graph $G = (V, E)$. A feedback edge set is a subset of edges $F \\subseteq E$ whose removal from $G$ results in an acyclic graph (a forest). A minimum feedback edge set is such a set with the smallest possible cardinality. The problem specifies a deterministic algorithm to find one such set, which also serves to resolve any ambiguity in which specific edges should be chosen.\n\nThe core principle underpinning the prescribed algorithm is identical to that of Kruskal's algorithm for finding a Maximum Spanning Forest. A spanning forest of a graph is a subgraph that is a forest, is not contained in any larger acyclic subgraph, and spans all vertices of the original graph. A Maximum Spanning Forest is a spanning forest containing the maximum possible number of edges. The set of edges in a graph that are *not* part of a given maximum spanning forest constitutes a minimum feedback edge set. The number of edges in any spanning forest of a graph with $n = |V|$ vertices and $c$ connected components is fixed at $n - c$. Therefore, the size of the minimum feedback edge set is $|E| - (n - c)$.\n\nThe specified algorithm constructs a maximum spanning forest by iteratively adding edges, and collects all edges that are not part of this forest. These collected edges are precisely those whose addition would have created a cycle.\n\nThe algorithm proceeds as follows:\n$1$. **Initialization**: Begin with a graph containing all $n$ vertices but no edges. This is a forest where each vertex forms its own connected component. A Disjoint Set Union (DSU), or Union-Find, data structure is initialized to manage these components. Initially, there are $n$ disjoint sets, one for each vertex $v \\in \\{0, 1, \\dots, n-1\\}$. An empty list, $F$, is created to store the edges of the feedback set.\n\n$2$. **Edge Canonicalization and Sorting**: Every undirected edge $\\{u, v\\}$ in the edge set $E$ is represented by a unique, canonical ordered pair $(\\min(u, v), \\max(u, v))$. The entire list of these canonical edge pairs is then sorted in ascending lexicographical order. This step ensures that the process is deterministic.\n\n$3$. **Iterative Construction**: The algorithm iterates through the sorted list of edges. For each edge $(u, v)$:\n    - It checks if vertices $u$ and $v$ already belong to the same connected component. This check is performed efficiently using the `find` operation of the DSU data structure, which returns a unique representative for each component.\n    - If `find(u)` is not equal to `find(v)`, the vertices are in different components. The edge $(u, v)$ connects these two components without creating a cycle. Thus, it is an edge of the maximum spanning forest. The edge is added to the forest by merging the two components using the DSU's `union(u, v)` operation.\n    - If `find(u)` is equal to `find(v)`, the vertices are already connected within the same component. Adding the edge $(u, v)$ would introduce a cycle. Therefore, this edge must belong to the feedback set. The edge's canonical representation $(\\min(u, v), \\max(u, v))$ is appended to the list $F$.\n\n$4$. **Termination**: After processing all edges in $E$, the list $F$ contains a minimum feedback edge set. The order of edges in $F$ is determined by the sorted iteration order. The final forest constructed is a maximum spanning forest of the original graph $G$.\n\nThe efficiency of this approach is primarily determined by the edge sorting step, which takes $O(|E| \\log |E|)$ time, and the DSU operations. With an optimized DSU implementation using both path compression and union by size/rank, the total time for all DSU operations is nearly constant on average, specifically $O(|E| \\cdot \\alpha(|V|))$, where $\\alpha$ is the extremely slow-growing inverse Ackermann function. Thus, the overall time complexity is dominated by sorting, rendering it $O(|E| \\log |E|)$.\n\nFor example, consider Graph A with $n=6$ and $E = \\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,2),(4,5)\\}$.\nThe canonical edges are $(0,1), (1,2), (0,2), (2,3), (3,4), (2,4), (4,5)$.\nThe sorted list of edges is $S = [(0,1), (0,2), (1,2), (2,3), (2,4), (3,4), (4,5)]$.\nThe DSU is initialized with sets $\\{0\\}, \\{1\\}, \\{2\\}, \\{3\\}, \\{4\\}, \\{5\\}$. The feedback set $F$ is empty.\n- Process $(0,1)$: `find(0) \\neq find(1)`. Union components of $0$ and $1$.\n- Process $(0,2)$: `find(0) \\neq find(2)`. Union components of $0$ and $2$. Components for $\\{0,1,2\\}$ are now merged.\n- Process $(1,2)$: `find(1) = find(2)`. Vertices $1$ and $2$ are already connected. Add $[1,2]$ to $F$.\n- Process $(2,3)$: `find(2) \\neq find(3)`. Union components. Components for $\\{0,1,2,3\\}$ are now merged.\n- Process $(2,4)$: `find(2) \\neq find(4)`. Union components. Components for $\\{0,1,2,3,4\\}$ are now merged.\n- Process $(3,4)$: `find(3) = find(4)`. Vertices $3$ and $4$ are already connected. Add $[3,4]$ to $F$.\n- Process $(4,5)$: `find(4) \\neq find(5)`. Union components. All vertices are now in one component.\nThe final feedback set for Graph A is $F = [[1,2],[3,4]]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the minimum feedback edge set problem for a suite of test graphs.\n    \"\"\"\n\n    class DSU:\n        \"\"\"\n        A Disjoint Set Union (DSU) data structure, also known as Union-Find,\n        optimized with path compression and union by size.\n        \"\"\"\n        def __init__(self, n):\n            \"\"\"\n            Initializes the DSU for n elements, where each element is in its\n            own set.\n            Args:\n                n (int): The number of elements.\n            \"\"\"\n            self.parent = list(range(n))\n            self.size = [1] * n\n\n        def find(self, i):\n            \"\"\"\n            Finds the representative of the set containing element i, with path\n            compression.\n            Args:\n                i (int): The element to find.\n            Returns:\n                int: The representative of the set.\n            \"\"\"\n            if self.parent[i] == i:\n                return i\n            self.parent[i] = self.find(self.parent[i])\n            return self.parent[i]\n\n        def union(self, i, j):\n            \"\"\"\n            Merges the sets containing elements i and j, using union by size.\n            Args:\n                i (int): An element in the first set.\n                j (int): An element in the second set.\n            Returns:\n                bool: True if the sets were merged, False if they were already\n                      in the same set.\n            \"\"\"\n            root_i = self.find(i)\n            root_j = self.find(j)\n            if root_i != root_j:\n                # Union by size: attach smaller tree under root of larger tree\n                if self.size[root_i] < self.size[root_j]:\n                    root_i, root_j = root_j, root_i\n                self.parent[root_j] = root_i\n                self.size[root_i] += self.size[root_j]\n                return True\n            return False\n\n    def find_minimum_feedback_edge_set(n, edges):\n        \"\"\"\n        Finds a canonical minimum feedback edge set for a graph using the\n        prescribed algorithm based on Kruskal's MST method.\n\n        Args:\n            n (int): The number of vertices in the graph.\n            edges (list of tuples): The list of edges in the graph.\n\n        Returns:\n            list of lists: The list of edges in the feedback set, ordered\n                           as they were identified.\n        \"\"\"\n        if n == 0 or not edges:\n            return []\n\n        # 1. Canonicalize edges to (min(u,v), max(u,v)) and sort them.\n        canonical_edges = sorted([(min(u, v), max(u, v)) for u, v in edges])\n        \n        dsu = DSU(n)\n        feedback_edges = []\n        \n        # 2. Iterate through sorted edges, building a maximum spanning forest.\n        for u, v in canonical_edges:\n            # 3. If an edge connects two vertices already in the same component,\n            # it forms a cycle and belongs to the feedback set.\n            if not dsu.union(u, v):\n                feedback_edges.append([u, v])\n                \n        return feedback_edges\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Graph A\n        (6, [(0,1),(1,2),(2,0),(2,3),(3,4),(4,2),(4,5)]),\n        # Graph B\n        (7, [(0,1),(1,2),(2,0),(3,4),(4,5),(5,6),(3,5)]),\n        # Graph C\n        (5, [(0,1),(1,2),(3,4)]),\n        # Graph D\n        (1, []),\n        # Graph E (K4)\n        (4, [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = find_minimum_feedback_edge_set(n, edges)\n        results.append(result)\n\n    # Format the final output string according to the exact problem specification.\n    # The str() conversion might add spaces, so we remove them.\n    results_as_strings = [str(r).replace(\" \", \"\") for r in results]\n    final_output = f\"[{','.join(results_as_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3225361"}]}