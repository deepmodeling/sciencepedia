{"hands_on_practices": [{"introduction": "Many practical routing problems involve constraints that go beyond simple path lengths. A fundamental skill for an algorithm designer is to transform such constrained problems into a standard form that known algorithms can solve. This first exercise [@problem_id:3270849] provides a direct application of this principle, asking you to find a shortest path while avoiding a specific set of \"forbidden\" vertices. The key is to see how this constraint translates into a simple modification of the graph, allowing you to apply a standard shortest path algorithm directly on the resulting subgraph.", "problem": "You are given a weighted directed graph $G = (V, E)$ with nonnegative edge weights and two distinguished vertices $s$ and $t$. Let $V_{bad} \\subset V$ be a set of forbidden vertices that cannot appear on any feasible path. A path is feasible if and only if all its internal vertices lie in $V \\setminus V_{bad}$ and its endpoints are the designated $s$ and $t$, neither of which belongs to $V_{bad}$. The goal is to determine, from first principles, the length (total weight) of the shortest feasible path from $s$ to $t$. Use only the core definitions of shortest paths and the correctness of Dijkstra’s algorithm for graphs with nonnegative edge weights as foundational facts, without invoking any pre-computed results about this particular graph.\n\nConsider the instance specified below.\n- Vertex set $V = \\{s, a, b, c, d, e, f, g, h, t\\}$.\n- Forbidden set $V_{bad} = \\{c, f\\}$.\n- Edge multiset $E$ with weights $w: E \\to \\mathbb{R}_{\\ge 0}$ is given as follows (each triple $(u, v, w)$ denotes a directed edge $u \\to v$ of weight $w$):\n  - $(s, a, 2)$, $(s, b, 5)$, $(s, h, 15)$, $(s, c, 1)$,\n  - $(a, c, 2)$, $(a, d, 4)$, $(a, e, 7)$,\n  - $(b, a, 1)$, $(b, d, 2)$, $(b, f, 6)$,\n  - $(c, d, 2)$, $(c, g, 5)$,\n  - $(d, e, 1)$, $(d, f, 2)$, $(d, g, 6)$,\n  - $(e, g, 1)$, $(e, h, 3)$,\n  - $(f, t, 3)$,\n  - $(g, h, 2)$, $(g, t, 4)$,\n  - $(h, t, 2)$.\n\nTask:\n- Formally reduce the problem to computing shortest paths in the induced subgraph $G[V \\setminus V_{bad}]$ by removing all vertices in $V_{bad}$ and all edges incident to them. Then, using the foundational definitions of path length and the correctness of Dijkstra’s algorithm on graphs with nonnegative weights, logically derive the shortest path tree (SPT) rooted at $s$ in the reduced graph and thereby determine the length of the shortest feasible $s$ to $t$ path.\n- Provide the final numerical answer as the exact integer path length. No rounding is required.\n\nWhat is the length of the shortest feasible path from $s$ to $t$ in this instance?", "solution": "The problem is first subjected to validation.\n\n### Step 1: Extract Givens\n-   **Graph Definition**: A weighted directed graph $G = (V, E)$ with nonnegative edge weights.\n-   **Vertices**: $V = \\{s, a, b, c, d, e, f, g, h, t\\}$.\n-   **Start and End Vertices**: Source $s$, destination $t$.\n-   **Forbidden Vertices**: $V_{bad} = \\{c, f\\}$.\n-   **Feasible Path Definition**: A path from $s$ to $t$ where all internal vertices are in $V \\setminus V_{bad}$. The endpoints $s$ and $t$ also do not belong to $V_{bad}$.\n-   **Edges and Weights**:\n    -   $(s, a, 2)$, $(s, b, 5)$, $(s, h, 15)$, $(s, c, 1)$,\n    -   $(a, c, 2)$, $(a, d, 4)$, $(a, e, 7)$,\n    -   $(b, a, 1)$, $(b, d, 2)$, $(b, f, 6)$,\n    -   $(c, d, 2)$, $(c, g, 5)$,\n    -   $(d, e, 1)$, $(d, f, 2)$, $(d, g, 6)$,\n    -   $(e, g, 1)$, $(e, h, 3)$,\n    -   $(f, t, 3)$,\n    -   $(g, h, 2)$, $(g, t, 4)$,\n    -   $(h, t, 2)$.\n-   **Task**: Reduce the problem to a shortest path problem in an induced subgraph, then use Dijkstra's algorithm from first principles to find the length of the shortest feasible path from $s$ to $t$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is a standard exercise in graph theory and algorithms, a subfield of computer science and discrete mathematics. It is grounded in established definitions and algorithms.\n2.  **Well-Posed**: The problem provides a completely specified graph with non-negative weights and a clear objective. The definition of a \"feasible path\" is precise. The condition that $s, t \\notin V_{bad}$ (since $s, t \\notin \\{c, f\\}$) is satisfied. As the edge weights are non-negative, Dijkstra's algorithm is applicable and guaranteed to find a solution. Thus, a unique, stable, and meaningful solution (the shortest path length) exists.\n3.  **Objective**: The language is formal and unambiguous. All terms are standard in graph theory.\n4.  **Completeness and Consistency**: The problem is self-contained. All necessary information (vertices, edges, weights, forbidden set) is provided. There are no contradictions in the provided data.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be derived.\n\n### Solution Derivation\n\nThe problem is to find the length of the shortest feasible path from vertex $s$ to vertex $t$. A path is defined as feasible if its internal vertices do not belong to the set $V_{bad} = \\{c, f\\}$. The problem also specifies that the endpoints $s$ and $t$ are not in $V_{bad}$. This means that any feasible path from $s$ to $t$ must consist entirely of vertices from the set $V' = V \\setminus V_{bad}$. Therefore, finding the shortest feasible path in the original graph $G$ is equivalent to finding the shortest path in the subgraph of $G$ induced by the vertex set $V'$.\n\nLet this reduced graph be $G' = (V', E')$.\nThe vertex set $V'$ is:\n$V' = V \\setminus V_{bad} = \\{s, a, b, c, d, e, f, g, h, t\\} \\setminus \\{c, f\\} = \\{s, a, b, d, e, g, h, t\\}$.\n\nThe edge set $E'$ consists of all edges $(u, v) \\in E$ such that both $u$ and $v$ are in $V'$. We filter the original edge list:\n-   $(s, a, 2)$: Valid, since $s, a \\in V'$.\n-   $(s, b, 5)$: Valid, since $s, b \\in V'$.\n-   $(s, h, 15)$: Valid, since $s, h \\in V'$.\n-   $(s, c, 1)$: Invalid, since $c \\notin V'$.\n-   $(a, c, 2)$: Invalid, since $c \\notin V'$.\n-   $(a, d, 4)$: Valid, since $a, d \\in V'$.\n-   $(a, e, 7)$: Valid, since $a, e \\in V'$.\n-   $(b, a, 1)$: Valid, since $b, a \\in V'$.\n-   $(b, d, 2)$: Valid, since $b, d \\in V'$.\n-   $(b, f, 6)$: Invalid, since $f \\notin V'$.\n-   $(c, d, 2)$: Invalid, since $c \\notin V'$.\n-   $(c, g, 5)$: Invalid, since $c \\notin V'$.\n-   $(d, e, 1)$: Valid, since $d, e \\in V'$.\n-   $(d, f, 2)$: Invalid, since $f \\notin V'$.\n-   $(d, g, 6)$: Valid, since $d, g \\in V'$.\n-   $(e, g, 1)$: Valid, since $e, g \\in V'$.\n-   $(e, h, 3)$: Valid, since $e, h \\in V'$.\n-   $(f, t, 3)$: Invalid, since $f \\notin V'$.\n-   $(g, h, 2)$: Valid, since $g, h \\in V'$.\n-   $(g, t, 4)$: Valid, since $g, t \\in V'$.\n-   $(h, t, 2)$: Valid, since $h, t \\in V'$.\n\nThe resulting graph $G' = (V', E')$ has weights that are all non-negative. We can therefore apply Dijkstra's algorithm to find the shortest path from $s$ to all other vertices. Let $d(v)$ be the shortest distance from $s$ to $v$ found so far, and $\\pi(v)$ be the predecessor of $v$ on the shortest path.\n\n**Initialization:**\n-   A set of visited vertices, $S = \\emptyset$.\n-   A priority queue $Q$ containing all vertices in $V'$, prioritized by distance.\n-   Initialize distances: $d(s) = 0$, and $d(v) = \\infty$ for all other $v \\in V'$.\n-   Initialize predecessors: $\\pi(v) = \\text{null}$ for all $v \\in V'$.\nThe initial state is:\n$d = \\{s:0, a:\\infty, b:\\infty, d:\\infty, e:\\infty, g:\\infty, h:\\infty, t:\\infty\\}$\n$Q = \\{s(0), a(\\infty), b(\\infty), d(\\infty), e(\\infty), g(\\infty), h(\\infty), t(\\infty)\\}$\n\n**Execution of Dijkstra's Algorithm:**\n\n1.  **Extract $s$**: $u = s$. Add $s$ to $S$. $S=\\{s\\}$.\n    -   Relax edge $(s, a)$ with weight $2$: $d(a) > d(s)+2 \\implies \\infty > 0+2$. Update $d(a)=2$, $\\pi(a)=s$.\n    -   Relax edge $(s, b)$ with weight $5$: $d(b) > d(s)+5 \\implies \\infty > 0+5$. Update $d(b)=5$, $\\pi(b)=s$.\n    -   Relax edge $(s, h)$ with weight $15$: $d(h) > d(s)+15 \\implies \\infty > 0+15$. Update $d(h)=15$, $\\pi(h)=s$.\n    $d = \\{s:0, a:2, b:5, d:\\infty, e:\\infty, g:\\infty, h:15, t:\\infty\\}$.\n    $Q = \\{a(2), b(5), h(15), d(\\infty), e(\\infty), g(\\infty), t(\\infty)\\}$.\n\n2.  **Extract $a$**: $u = a$. Add $a$ to $S$. $S=\\{s, a\\}$.\n    -   Relax edge $(a, d)$ with weight $4$: $d(d) > d(a)+4 \\implies \\infty > 2+4$. Update $d(d)=6$, $\\pi(d)=a$.\n    -   Relax edge $(a, e)$ with weight $7$: $d(e) > d(a)+7 \\implies \\infty > 2+7$. Update $d(e)=9$, $\\pi(e)=a$.\n    $d = \\{s:0, a:2, b:5, d:6, e:9, g:\\infty, h:15, t:\\infty\\}$.\n    $Q = \\{b(5), d(6), e(9), h(15), g(\\infty), t(\\infty)\\}$.\n\n3.  **Extract $b$**: $u = b$. Add $b$ to $S$. $S=\\{s, a, b\\}$.\n    -   Relax edge $(b, a)$ with weight $1$: $d(a) > d(b)+1 \\implies 2 > 5+1$ is false. No update.\n    -   Relax edge $(b, d)$ with weight $2$: $d(d) > d(b)+2 \\implies 6 > 5+2$ is false. No update.\n    $d$ is unchanged. $Q = \\{d(6), e(9), h(15), g(\\infty), t(\\infty)\\}$.\n\n4.  **Extract $d$**: $u = d$. Add $d$ to $S$. $S=\\{s, a, b, d\\}$.\n    -   Relax edge $(d, e)$ with weight $1$: $d(e) > d(d)+1 \\implies 9 > 6+1$. Update $d(e)=7$, $\\pi(e)=d$.\n    -   Relax edge $(d, g)$ with weight $6$: $d(g) > d(d)+6 \\implies \\infty > 6+6$. Update $d(g)=12$, $\\pi(g)=d$.\n    $d = \\{s:0, a:2, b:5, d:6, e:7, g:12, h:15, t:\\infty\\}$.\n    $Q = \\{e(7), g(12), h(15), t(\\infty)\\}$.\n\n5.  **Extract $e$**: $u = e$. Add $e$ to $S$. $S=\\{s, a, b, d, e\\}$.\n    -   Relax edge $(e, g)$ with weight $1$: $d(g) > d(e)+1 \\implies 12 > 7+1$. Update $d(g)=8$, $\\pi(g)=e$.\n    -   Relax edge $(e, h)$ with weight $3$: $d(h) > d(e)+3 \\implies 15 > 7+3$. Update $d(h)=10$, $\\pi(h)=e$.\n    $d = \\{s:0, a:2, b:5, d:6, e:7, g:8, h:10, t:\\infty\\}$.\n    $Q = \\{g(8), h(10), t(\\infty)\\}$.\n\n6.  **Extract $g$**: $u = g$. Add $g$ to $S$. $S=\\{s, a, b, d, e, g\\}$.\n    -   Relax edge $(g, h)$ with weight $2$: $d(h) > d(g)+2 \\implies 10 > 8+2$ is false. No update.\n    -   Relax edge $(g, t)$ with weight $4$: $d(t) > d(g)+4 \\implies \\infty > 8+4$. Update $d(t)=12$, $\\pi(t)=g$.\n    $d = \\{s:0, a:2, b:5, d:6, e:7, g:8, h:10, t:12\\}$.\n    $Q = \\{h(10), t(12)\\}$.\n\n7.  **Extract $h$**: $u = h$. Add $h$ to $S$. $S=\\{s, a, b, d, e, g, h\\}$.\n    -   Relax edge $(h, t)$ with weight $2$: $d(t) > d(h)+2 \\implies 12 > 10+2$ is false. No update.\n    $d$ is unchanged. $Q = \\{t(12)\\}$.\n\n8.  **Extract $t$**: $u = t$. Add $t$ to $S$. $S=\\{s, a, b, d, e, g, h, t\\}$. Algorithm terminates as $Q$ is now empty.\n\nThe final distances from $s$ are given by the array $d$. The shortest path tree (SPT) from $s$ is implicitly defined by the predecessor array $\\pi$. The length of the shortest path from $s$ to $t$ is $d(t)$.\n\nFrom the final state, $d(t) = 12$.\n\nWe can trace the shortest path found:\n$t \\leftarrow \\pi(t)=g \\leftarrow \\pi(g)=e \\leftarrow \\pi(e)=d \\leftarrow \\pi(d)=a \\leftarrow \\pi(a)=s$.\nThe path is $s \\to a \\to d \\to e \\to g \\to t$.\nThe length is $w(s,a) + w(a,d) + w(d,e) + w(e,g) + w(g,t) = 2 + 4 + 1 + 1 + 4 = 12$.\nThis confirms the result of Dijkstra's algorithm.\n\nIt is worth noting that another path of the same length exists: $s \\to a \\to d \\to e \\to h \\to t$. Its length is $2+4+1+3+2=12$. Dijkstra's algorithm finds one such path, and the length $12$ is guaranteed to be minimal.\n\nThe length of the shortest feasible path from $s$ to $t$ is $12$.", "answer": "$$\n\\boxed{12}\n$$", "id": "3270849"}, {"introduction": "Building on the theme of problem reduction, we now move from modifying the graph's structure to modifying its cost model. This practice [@problem_id:3270794] introduces a more complex scenario where costs are associated not only with edges, but also with the intermediate vertices themselves, such as a toll or processing delay. Your task is to devise a transformation that absorbs these vertex costs into a new set of edge weights, demonstrating the power of remodeling a problem to fit the elegant framework of a standard shortest path algorithm.", "problem": "Consider a directed graph $G=(V,E)$ with vertices $V=\\{v_1,v_2,v_3,v_4,v_5,v_6,v_7\\}$. Each directed edge $(u,v)\\in E$ has a nonnegative edge weight given by a function $w:E\\to \\mathbb{R}_{\\ge 0}$, and each vertex $x\\in V$ has a nonnegative vertex cost given by a function $c:V\\to \\mathbb{R}_{\\ge 0}$. For any directed $s$-$t$ path $P=\\langle s=x_0,x_1,\\dots,x_k=t\\rangle$, define its path cost to be\n$$\n\\sum_{i=0}^{k-1} w(x_i,x_{i+1}) \\;+\\; \\sum_{i=1}^{k-1} c(x_i),\n$$\nthat is, the sum of edge weights plus the costs of all intermediate vertices on the path (excluding the source and the destination). Assume that all edge weights and vertex costs are nonnegative.\n\nYour task is to ground your reasoning in the core definitions of shortest paths and Dijkstra’s algorithm (which is valid on directed graphs with nonnegative edge weights) and, without appealing to any pre-stated reduction formulas, derive a correct way to compute the above path costs using a standard single-source shortest path computation with nonnegative edge weights. Then, for the specific instance below with source $s=v_1$ and destination $t=v_7$, compute the minimal path cost from $v_1$ to $v_7$ under the stated model.\n\nThe directed edges and their weights are:\n- Edge $v_1\\to v_2$ with weight $w=4$; edge $v_1\\to v_3$ with weight $w=2$.\n- Edge $v_2\\to v_3$ with weight $w=1$; edge $v_2\\to v_4$ with weight $w=5$; edge $v_2\\to v_5$ with weight $w=7$.\n- Edge $v_3\\to v_4$ with weight $w=8$; edge $v_3\\to v_5$ with weight $w=10$; edge $v_3\\to v_6$ with weight $w=4$.\n- Edge $v_4\\to v_5$ with weight $w=2$; edge $v_4\\to v_6$ with weight $w=6$.\n- Edge $v_5\\to v_6$ with weight $w=2$; edge $v_5\\to v_7$ with weight $w=5$.\n- Edge $v_6\\to v_7$ with weight $w=1$.\n\nThe vertex costs are:\n- $c(v_1)=3$, $c(v_2)=4$, $c(v_3)=2$, $c(v_4)=5$, $c(v_5)=1$, $c(v_6)=3$, $c(v_7)=6$.\n\nReport only the minimal path cost value from $v_1$ to $v_7$ as a real number. No rounding is necessary for this instance.", "solution": "The user has provided a well-defined shortest path problem on a directed graph with a non-standard cost function. The problem is valid as it is mathematically and algorithmically sound, self-contained, and devoid of ambiguity. I will first derive a method to solve this class of problems by reducing it to a standard single-source shortest path problem, and then apply this method to the specific instance provided.\n\n### Part 1: Derivation of the Reduction\nLet the directed graph be $G=(V,E)$, with a nonnegative edge weight function $w:E\\to \\mathbb{R}_{\\ge 0}$ and a nonnegative vertex cost function $c:V\\to \\mathbb{R}_{\\ge 0}$. For a given source vertex $s \\in V$ and destination vertex $t \\in V$, we are asked to find a path $P=\\langle s=x_0,x_1,\\dots,x_k=t\\rangle$ that minimizes the path cost, defined as:\n$$\nC(P) = \\sum_{i=0}^{k-1} w(x_i,x_{i+1}) \\;+\\; \\sum_{i=1}^{k-1} c(x_i)\n$$\nThis cost is the sum of all edge weights along the path, plus the sum of the costs of all intermediate vertices (i.e., excluding the source $s$ and the destination $t$).\n\nStandard shortest path algorithms, such as Dijkstra's algorithm, operate on graphs where costs are associated only with edges. Our goal is to transform the given problem into an equivalent one on a graph with only edge weights, such that the standard shortest path cost in the new graph is directly related to the custom cost $C(P)$.\n\nLet us construct a new graph $G'=(V, E)$ having the same set of vertices and edges as $G$. We need to define a new edge weight function $w': E \\to \\mathbb{R}_{\\ge 0}$. The key is to incorporate the vertex costs into these new edge weights. A vertex cost $c(v)$ is incurred when a path passes through $v$. This suggests that the cost $c(v)$ can be added to the weight of every edge entering $v$ or every edge leaving $v$.\n\nLet us explore the first approach: defining the new weight of an edge $(u,v)$ as the sum of its original weight and the cost of its destination vertex $v$.\nLet $w'(u,v) = w(u,v) + c(v)$ for every edge $(u,v) \\in E$.\nSince $w(u,v) \\ge 0$ and $c(v) \\ge 0$, the new edge weights $w'(u,v)$ are also all nonnegative. This ensures that Dijkstra's algorithm is applicable to the transformed graph $G'$.\n\nNow, let's consider the cost of the same path $P = \\langle s=x_0,x_1,\\dots,x_k=t\\rangle$ in this new graph $G'$, according to the standard shortest path metric. This cost, let's call it $C'(P)$, is the sum of the new edge weights along the path:\n$$\nC'(P) = \\sum_{i=0}^{k-1} w'(x_i,x_{i+1})\n$$\nSubstituting the definition of $w'$, we have:\n$$\nC'(P) = \\sum_{i=0}^{k-1} \\left( w(x_i,x_{i+1}) + c(x_{i+1}) \\right)\n$$\nWe can split this sum into two parts:\n$$\nC'(P) = \\sum_{i=0}^{k-1} w(x_i,x_{i+1}) + \\sum_{i=0}^{k-1} c(x_{i+1})\n$$\nLet's expand the second summation:\n$$\n\\sum_{i=0}^{k-1} c(x_{i+1}) = c(x_1) + c(x_2) + \\dots + c(x_{k-1}) + c(x_k)\n$$\nThe first part of this sum, $\\sum_{i=1}^{k-1} c(x_i)$, corresponds to the costs of the intermediate vertices. The vertex $x_k$ is the destination vertex $t$. So, we can rewrite the expression for $C'(P)$ as:\n$$\nC'(P) = \\left( \\sum_{i=0}^{k-1} w(x_i,x_{i+1}) + \\sum_{i=1}^{k-1} c(x_i) \\right) + c(x_k)\n$$\nThe expression in parentheses is precisely the original cost function $C(P)$. Since $x_k = t$, we have:\n$$\nC'(P) = C(P) + c(t)\n$$\nThis relationship shows that for any path from $s$ to $t$, the standard cost in $G'$ is equal to the custom cost in $G$ plus the cost of the destination vertex, $c(t)$. Since $c(t)$ is a constant for all paths from $s$ to $t$, the path that minimizes $C'(P)$ is the same path that minimizes $C(P)$.\n\nTherefore, we can find the minimum path cost in the original problem by performing the following steps:\n1. Construct the graph $G'$ with edge weights $w'(u,v) = w(u,v) + c(v)$.\n2. Run Dijkstra's algorithm on $G'$ starting from source $s$ to find the shortest path distance to all other vertices. Let $d'(s,v)$ denote this distance for any vertex $v$.\n3. The shortest path distance from $s$ to $t$ in $G'$ is $d'(s,t)$.\n4. The minimal path cost under the original definition is then $C_{min} = d'(s,t) - c(t)$.\n\n### Part 2: Application to the Specific Instance\nWe are given the graph $G=(V, E)$ with $V=\\{v_1, \\dots, v_7\\}$, source $s=v_1$, destination $t=v_7$, and the following edge weights and vertex costs:\n\n**Vertex Costs:**\n$c(v_1)=3$, $c(v_2)=4$, $c(v_3)=2$, $c(v_4)=5$, $c(v_5)=1$, $c(v_6)=3$, $c(v_7)=6$.\n\n**Graph Transformation:**\nWe compute the new edge weights $w'(u,v) = w(u,v) + c(v)$:\n- $w'(v_1, v_2) = w(v_1, v_2) + c(v_2) = 4 + 4 = 8$\n- $w'(v_1, v_3) = w(v_1, v_3) + c(v_3) = 2 + 2 = 4$\n- $w'(v_2, v_3) = w(v_2, v_3) + c(v_3) = 1 + 2 = 3$\n- $w'(v_2, v_4) = w(v_2, v_4) + c(v_4) = 5 + 5 = 10$\n- $w'(v_2, v_5) = w(v_2, v_5) + c(v_5) = 7 + 1 = 8$\n- $w'(v_3, v_4) = w(v_3, v_4) + c(v_4) = 8 + 5 = 13$\n- $w'(v_3, v_5) = w(v_3, v_5) + c(v_5) = 10 + 1 = 11$\n- $w'(v_3, v_6) = w(v_3, v_6) + c(v_6) = 4 + 3 = 7$\n- $w'(v_4, v_5) = w(v_4, v_5) + c(v_5) = 2 + 1 = 3$\n- $w'(v_4, v_6) = w(v_4, v_6) + c(v_6) = 6 + 3 = 9$\n- $w'(v_5, v_6) = w(v_5, v_6) + c(v_6) = 2 + 3 = 5$\n- $w'(v_5, v_7) = w(v_5, v_7) + c(v_7) = 5 + 6 = 11$\n- $w'(v_6, v_7) = w(v_6, v_7) + c(v_7) = 1 + 6 = 7$\n\n**Dijkstra's Algorithm on $G'$ from $v_1$:**\nLet $d'[v]$ be the shortest distance from $v_1$ to $v \\in V$ in $G'$.\n1. Initialize: $d'[v_1]=0$, $d'[v_i]=\\infty$ for $i \\in \\{2, \\dots, 7\\}$. Priority queue $Q=\\{(0, v_1)\\}$.\n2. Extract $v_1$ ($d'[v_1]=0$).\n   - Relax $(v_1,v_2)$: $d'[v_2] = 0 + 8 = 8$.\n   - Relax $(v_1,v_3)$: $d'[v_3] = 0 + 4 = 4$.\n   $d' = [0, 8, 4, \\infty, \\infty, \\infty, \\infty]$. $Q=\\{(4, v_3), (8, v_2)\\}$.\n3. Extract $v_3$ ($d'[v_3]=4$).\n   - Relax $(v_3,v_4)$: $d'[v_4] = 4 + 13 = 17$.\n   - Relax $(v_3,v_5)$: $d'[v_5] = 4 + 11 = 15$.\n   - Relax $(v_3,v_6)$: $d'[v_6] = 4 + 7 = 11$.\n   $d' = [0, 8, 4, 17, 15, 11, \\infty]$. $Q=\\{(8, v_2), (11, v_6), (15, v_5), (17, v_4)\\}$.\n4. Extract $v_2$ ($d'[v_2]=8$).\n   - Relax $(v_2,v_3)$: $d'[v_3]=\\min(4, 8+3)=4$. No change.\n   - Relax $(v_2,v_4)$: $d'[v_4]=\\min(17, 8+10)=17$. No change.\n   - Relax $(v_2,v_5)$: $d'[v_5]=\\min(15, 8+8)=15$. No change.\n   $Q=\\{(11, v_6), (15, v_5), (17, v_4)\\}$.\n5. Extract $v_6$ ($d'[v_6]=11$).\n   - Relax $(v_6,v_7)$: $d'[v_7] = 11 + 7 = 18$.\n   $d' = [0, 8, 4, 17, 15, 11, 18]$. $Q=\\{(15, v_5), (17, v_4), (18, v_7)\\}$.\n6. Extract $v_5$ ($d'[v_5]=15$).\n   - Relax $(v_5,v_6)$: $v_6$ already finalized.\n   - Relax $(v_5,v_7)$: $d'[v_7]=\\min(18, 15+11)=18$. No change.\n   $Q=\\{(17, v_4), (18, v_7)\\}$.\n7. Extract $v_4$ ($d'[v_4]=17$).\n   - Neighbors $v_5, v_6$ already finalized. No changes.\n   $Q=\\{(18, v_7)\\}$.\n8. Extract $v_7$ ($d'[v_7]=18$). Algorithm terminates.\n\nThe shortest path distance from $v_1$ to $v_7$ in the transformed graph is $d'(v_1, v_7) = 18$.\n\n**Final Cost Calculation:**\nThe minimal path cost in the original problem is given by $C_{min} = d'(v_1, v_7) - c(v_7)$.\nGiven $c(v_7) = 6$, we find:\n$$\nC_{min} = 18 - 6 = 12\n$$\nThe path yielding this cost is $\\langle v_1, v_3, v_6, v_7 \\rangle$. We can verify its cost with the original formula:\n$C(P) = (w(v_1,v_3)+w(v_3,v_6)+w(v_6,v_7)) + (c(v_3)+c(v_6)) = (2+4+1) + (2+3) = 7+5=12$.\nThe result is consistent.", "answer": "$$\\boxed{12}$$", "id": "3270794"}, {"introduction": "Real-world systems like communication networks or road maps are dynamic, with link conditions changing over time. Re-calculating all shortest paths from scratch after a single link improves is highly inefficient. This advanced exercise [@problem_id:3270914] challenges you to implement an efficient update procedure for a Shortest Path Tree when an edge's weight decreases. This practice moves beyond static problems and introduces the core idea behind dynamic algorithms: intelligently updating an existing solution is often much faster than full re-computation.", "problem": "Consider a directed graph $G = (V, E)$ with nonnegative edge weights given by a function $w : E \\to \\mathbb{R}_{\\ge 0}$, and a distinguished source vertex $s \\in V$. A Shortest Path Tree (SPT) is defined as a predecessor map $\\pi : V \\to V \\cup \\{\\text{nil}\\}$ such that the directed edges $\\{(\\pi(v), v) : v \\in V, \\pi(v) \\neq \\text{nil}\\}$ form a directed spanning tree rooted at $s$ and the associated path distances $d : V \\to \\mathbb{R}_{\\ge 0} \\cup \\{\\infty\\}$ satisfy that for each vertex $v \\in V$, the path from $s$ to $v$ in this tree has total weight exactly $d(v)$ and equals the minimum possible among all $s \\to v$ directed paths.\n\nThe objective is to design and implement a program that, given an SPT for $G$ with respect to $s$, updates this SPT after the weight of a single directed edge $(u, v) \\in E$ decreases to a new value $w'(u, v)$ satisfying $0 \\le w'(u, v)  w(u, v)$, without performing a full recomputation from scratch. The update should rely on fundamental properties of shortest paths and the behavior of relaxation with nonnegative weights, and must operate by re-using the existing distances $d(\\cdot)$ and predecessors $\\pi(\\cdot)$ rather than reinitializing all structures as if no information were known. The updated SPT must reflect the new shortest path distances $d'(\\cdot)$ and an updated predecessor map $\\pi'(\\cdot)$.\n\nFundamental base for derivation:\n- Definition of shortest path distances with nonnegative weights.\n- Optimal substructure of shortest paths: if a path from $s$ to $y$ is shortest, then any prefix from $s$ to any intermediate vertex $x$ is also shortest.\n- Relaxation invariants: for any edge $(x, y) \\in E$, the inequality $d(y) \\le d(x) + w(x, y)$ must hold in a valid SPT; when an edge weight decreases, only vertices whose shortest path can be improved by traversing this edge or paths reachable from its head may change.\n\nYour program must compute initial shortest path distances from $s$ using a correct algorithm for nonnegative weights, then apply a single-edge decrease update step using only localized relaxations seeded at $v$ if $d(u) + w'(u, v)  d(v)$, and propagate improvements to affected vertices via a min-priority queue until no improvement is possible. The program must not re-run a full computation starting from scratch.\n\nYour program must be self-contained and must not read input. Use the following test suite, where each test case is specified by the number of vertices, an edge list with weights, a source vertex, and a single edge weight decrease specified by $(u, v, w')$. Vertices are indexed by integers starting at $0$.\n\nTest suite:\n- Test case $1$: $|V| = 6$, $s = 0$, edges given as the list of triples $(x, y, w)$:\n  $(0, 1, 7)$, $(0, 2, 9)$, $(0, 5, 14)$, $(1, 2, 10)$, $(1, 3, 15)$, $(2, 3, 11)$, $(2, 5, 2)$, $(3, 4, 6)$, $(5, 4, 9)$. Decrease edge weight $(1, 2)$ to $w' = 1$.\n- Test case $2$: $|V| = 6$, $s = 0$, edges identical to test case $1$. Decrease edge weight $(3, 4)$ to $w' = 4$.\n- Test case $3$: $|V| = 6$, $s = 0$, edges identical to test case $1$. Decrease edge weight $(0, 2)$ to $w' = 2$.\n\nFor each test case, compute the updated shortest path distance list $[d'(0), d'(1), \\dots, d'(5)]$ after applying the single-edge weight decrease. All distances are integers in these cases. The final output format must be a single line containing the results for all test cases aggregated into a comma-separated list enclosed in square brackets, where each test case result is itself a bracketed comma-separated list of integers. That is, the output must be of the form $[\\,[d'_0^{(1)}, d'_1^{(1)}, \\dots],\\,[d'_0^{(2)}, d'_1^{(2)}, \\dots],\\,[d'_0^{(3)}, d'_1^{(3)}, \\dots]\\,]$ with no additional whitespace or text.", "solution": "The user-provided problem is valid. It is scientifically grounded in the established principles of graph theory and algorithm design, specifically concerning single-source shortest paths in directed graphs with non-negative edge weights. The problem is well-posed, with a clear objective, all necessary data provided, and no internal contradictions. It asks for the implementation of a standard and efficient algorithm for updating a Shortest Path Tree (SPT) after a single edge weight decrease, which is a non-trivial but well-understood task in computer science.\n\nThe solution proceeds in two stages: first, the computation of an initial Shortest Path Tree, and second, the incremental update of this tree after an edge weight decreases.\n\n### 1. Initial Shortest Path Tree Computation\n\nGiven a directed graph $G = (V, E)$, a non-negative weight function $w : E \\to \\mathbb{R}_{\\ge 0}$, and a source vertex $s \\in V$, the single-source shortest path problem is to find, for every vertex $v \\in V$, the path from $s$ to $v$ with the minimum total weight. The weight of such a path is denoted by $d(v)$.\n\nSince all edge weights are non-negative, Dijkstra's algorithm is the canonical and most efficient method for this task. The algorithm maintains a set of vertices whose shortest path from the source is already finalized. It iteratively selects a vertex $u$ which is not yet finalized and has the smallest known distance from $s$. Once selected, $u$ is considered finalized, and all its outgoing edges $(u, v)$ are \"relaxed\": if a shorter path to any neighbor $v$ is found through $u$ (i.e., if $d(u) + w(u, v)  d(v)$), the distance $d(v)$ and predecessor $\\pi(v)$ are updated. A min-priority queue is typically used to efficiently select the vertex with the minimum distance at each step.\n\nThe algorithm proceeds as follows:\n1. Initialize a distance array $d$ such that $d(s) = 0$ and $d(v) = \\infty$ for all $v \\neq s$.\n2. Initialize a predecessor array $\\pi$ such that $\\pi(v) = \\text{nil}$ for all $v \\in V$.\n3. Initialize a min-priority queue $Q$ with all vertices, using the values in $d$ as keys.\n4. While $Q$ is not empty:\n   a. Extract the vertex $u$ with the minimum distance from $Q$.\n   b. For each vertex $v$ adjacent to $u$ (i.e., for each edge $(u, v) \\in E$):\n      i. perform the relaxation operation: if $d(u) + w(u, v)  d(v)$, then update $d(v) \\leftarrow d(u) + w(u, v)$ and $\\pi(v) \\leftarrow u$. The priority queue $Q$ must be updated to reflect the new distance for $v$.\n\nUpon termination, $d(v)$ will hold the shortest path distance from $s$ to $v$ for all $v \\in V$, and $\\pi$ will define the SPT.\n\n### 2. Updating the Shortest Path Tree after an Edge Weight Decrease\n\nLet us assume we have an existing SPT, represented by the distance array $d$ and predecessor map $\\pi$. We are given that the weight of a single edge $(u, v) \\in E$ decreases from $w(u, v)$ to $w'(u, v)$, where $0 \\le w'(u, v)  w(u, v)$.\n\nAn essential property of shortest paths on graphs with non-negative weights is that a decrease in an edge weight can only potentially decrease the shortest path distances to other vertices; it can never cause an increase. All previously computed shortest paths remain valid paths, although they may no longer be the shortest.\n\nThe update to the SPT is triggered only if the modified edge $(u, v)$ provides a shorter path to vertex $v$ than was previously known. The new potential path to $v$ goes from $s$ to $u$ (with cost $d(u)$) and then across the modified edge $(u, v)$ (with cost $w'(u, v)$). The condition for an improvement is thus:\n$$d(u) + w'(u, v)  d(v)$$\n\n- If this condition is **false**, the old shortest path to $v$ is still better than or equal to any new path through the modified edge $(u, v)$. Consequently, the shortest paths to all other vertices are also unaffected, and the SPT remains unchanged. The new distances $d'$ are identical to the old distances $d$.\n\n- If the condition is **true**, we have found a new shortest path to vertex $v$. We must update its distance and predecessor:\n$$d'(v) \\leftarrow d(u) + w'(u, v)$$\n$$\\pi'(v) \\leftarrow u$$\nThis improvement in the distance to $v$ may, in turn, create shorter paths to vertices reachable from $v$. For any neighbor $z$ of $v$, the path $s \\to \\dots \\to u \\to v \\to z$ might now be shorter than the existing shortest path to $z$.\n\nThis propagation of distance improvements is structurally identical to the process of Dijkstra's algorithm itself. Therefore, we can perform an efficient, localized update. Instead of re-running Dijkstra's algorithm from the source $s$ on the entire graph, we can initiate a Dijkstra-like procedure starting only from the vertex $v$ whose distance was first improved.\n\nThe update algorithm is as follows:\n1. Let the initial SPT be given by distances $d$ and predecessors $\\pi$.\n2. Let the weight of edge $(u, v)$ decrease to $w'(u, v)$. Update the graph's internal representation of this weight.\n3. Check the trigger condition. If $d(u) + w'(u, v)  d(v)$:\n   a. Update the distance array: $d(v) \\leftarrow d(u) + w'(u, v)$.\n   b. Update the predecessor array: $\\pi(v) \\leftarrow u$.\n   c. Initialize a min-priority queue $Q_{update}$ and insert $v$ into it.\n   d. While $Q_{update}$ is not empty:\n      i. Extract the vertex $x$ with the minimum distance from $Q_{update}$.\n      ii. For each neighbor $y$ of $x$, relax the edge $(x, y)$: if $d(x) + w(x, y)  d(y)$, update $d(y) \\leftarrow d(x) + w(x, y)$, set $\\pi(y) \\leftarrow x$, and add or update $y$ in $Q_{update}$ with its new, lower distance.\n4. If the trigger condition in step $3$ is not met, no changes are needed. The final distance array $d'$ is the (now updated) array $d$.\n\nThis procedure is more efficient than a full recomputation because it only processes vertices whose shortest paths are actually affected by the edge weight decrease.\n\n### Application to Test Cases\n\nLet's apply this logic to Test Case $1$: $|V| = 6$, $s = 0$, edges $\\{(0, 1, 7), (0, 2, 9), (0, 5, 14), (1, 2, 10), (1, 3, 15), (2, 3, 11), (2, 5, 2), (3, 4, 6), (5, 4, 9)\\}$.\n1.  **Initial Dijkstra**: The initial shortest path distances from $s=0$ are calculated as $d = [0, 7, 9, 20, 20, 11]$.\n2.  **Edge Decrease**: The weight of edge $(1, 2)$ decreases to $w'(1, 2) = 1$.\n3.  **Update**:\n    a. Check condition: $d(1) + w'(1, 2)  d(2)$ becomes $7 + 1  9$, which is $8  9$. The condition is true.\n    b. Update $d(2) \\leftarrow 8$. Initialize $Q_{update}$ with vertex $2$.\n    c. Extract $2$ (cost $8$). Relax its outgoing edges:\n       - $(2, 3)$: $d(2) + w(2, 3) = 8 + 11 = 19$. Since $19  d(3)=20$, update $d(3) \\leftarrow 19$ and add $3$ to $Q_{update}$.\n       - $(2, 5)$: $d(2) + w(2, 5) = 8 + 2 = 10$. Since $10  d(5)=11$, update $d(5) \\leftarrow 10$ and add $5$ to $Q_{update}$.\n    d. $Q_{update}$ now contains $\\{ (10, 5), (19, 3) \\}$. Extract $5$ (cost $10$). Relax its outgoing edge:\n       - $(5, 4)$: $d(5) + w(5, 4) = 10 + 9 = 19$. Since $19  d(4)=20$, update $d(4) \\leftarrow 19$ and add $4$ to $Q_{update}$.\n    e. $Q_{update}$ now contains $\\{ (19, 3), (19, 4) \\}$. Extract $3$ (cost $19$). Relax its outgoing edge:\n       - $(3, 4)$: $d(3) + w(3, 4) = 19 + 6 = 25$. Since $25 \\not d(4)=19$, no update.\n    f. Extract $4$ (cost $19$). No outgoing edges to relax.\n    g. $Q_{update}$ is empty. The process terminates.\n4.  **Final Distances**: The updated distance array is $d' = [0, 7, 8, 19, 19, 10]$.\n\nSimilar analyses yield the results for the other test cases. For Test Case $2$, the trigger condition is not met, so the distances remain unchanged. For Test Case $3$, the trigger condition is met, and a similar update propagation occurs.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Solves the shortest path tree update problem for a given test suite.\n    \"\"\"\n\n    # Dijkstra's algorithm for SSSP on graphs with non-negative weights.\n    def dijkstra(num_vertices, edges, source):\n        adj = [[] for _ in range(num_vertices)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n        \n        dist = np.full(num_vertices, np.inf)\n        pred = np.full(num_vertices, -1, dtype=int)\n        \n        dist[source] = 0\n        pq = [(0, source)]\n        \n        while pq:\n            d, u = heapq.heappop(pq)\n            \n            if d > dist[u]:\n                continue\n            \n            for v, weight in adj[u]:\n                if dist[u] + weight  dist[v]:\n                    dist[v] = dist[u] + weight\n                    pred[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n        \n        # Convert infinities to a large number if needed for integer output,\n        # but the test cases are all connected.\n        return dist.astype(int), pred\n\n    # Test suite definition\n    test_suite = [\n        {\n            \"num_vertices\": 6,\n            \"source\": 0,\n            \"edges\": [\n                (0, 1, 7), (0, 2, 9), (0, 5, 14), (1, 2, 10), (1, 3, 15),\n                (2, 3, 11), (2, 5, 2), (3, 4, 6), (5, 4, 9)\n            ],\n            \"decrease\": (1, 2, 1)\n        },\n        {\n            \"num_vertices\": 6,\n            \"source\": 0,\n            \"edges\": [\n                (0, 1, 7), (0, 2, 9), (0, 5, 14), (1, 2, 10), (1, 3, 15),\n                (2, 3, 11), (2, 5, 2), (3, 4, 6), (5, 4, 9)\n            ],\n            \"decrease\": (3, 4, 4)\n        },\n        {\n            \"num_vertices\": 6,\n            \"source\": 0,\n            \"edges\": [\n                (0, 1, 7), (0, 2, 9), (0, 5, 14), (1, 2, 10), (1, 3, 15),\n                (2, 3, 11), (2, 5, 2), (3, 4, 6), (5, 4, 9)\n            ],\n            \"decrease\": (0, 2, 2)\n        }\n    ]\n\n    results = []\n\n    for case in test_suite:\n        num_v = case[\"num_vertices\"]\n        edges = case[\"edges\"]\n        source = case[\"source\"]\n        u_dec, v_dec, w_prime = case[\"decrease\"]\n        \n        # 1. Compute initial SPT distances\n        initial_dist, initial_pred = dijkstra(num_v, edges, source)\n        \n        # Make a mutable copy for the update process\n        updated_dist = initial_dist.copy()\n        \n        # Build adjacency list with original weights for propagation\n        adj = [[] for _ in range(num_v)]\n        current_edges = { (u, v): w for u, v, w in edges }\n        \n        # Apply the weight decrease\n        current_edges[(u_dec, v_dec)] = w_prime\n        \n        for (u, v), w in current_edges.items():\n            adj[u].append((v, w))\n\n        # 2. Check update condition and propagate if necessary\n        if updated_dist[u_dec] + w_prime  updated_dist[v_dec]:\n            updated_dist[v_dec] = updated_dist[u_dec] + w_prime\n            \n            # 3. Propagate updates using a Dijkstra-like process\n            pq_update = [(updated_dist[v_dec], v_dec)]\n            \n            while pq_update:\n                d, x = heapq.heappop(pq_update)\n\n                if d > updated_dist[x]:\n                    continue\n                \n                for y, weight in adj[x]:\n                    if updated_dist[x] + weight  updated_dist[y]:\n                        updated_dist[y] = updated_dist[x] + weight\n                        heapq.heappush(pq_update, (updated_dist[y], y))\n        \n        results.append(list(updated_dist))\n\n    # Format the final output string exactly as required\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3270914"}]}