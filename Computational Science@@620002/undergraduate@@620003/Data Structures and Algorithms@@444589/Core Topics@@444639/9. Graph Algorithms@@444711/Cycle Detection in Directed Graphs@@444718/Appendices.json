{"hands_on_practices": [{"introduction": "The most fundamental task in analyzing directed graphs is determining whether a cycle exists. This first exercise [@problem_id:3224952] provides practice in the complete workflow, from processing a raw list of edges into a usable data structure to implementing a Depth-First Search (DFS) with state tracking. Mastering this core skill is essential, as cycle detection forms the basis for solving a wide range of problems, including dependency resolution and deadlock detection.", "problem": "You are given only a list of directed edges for each test case, without an explicit adjacency list or adjacency matrix. A directed graph is defined as $G = (V, E)$, where $V$ is a finite set of vertices and $E \\subseteq V \\times V$ is a finite set of ordered pairs representing directed edges. A directed path is a finite sequence of vertices $v_0, v_1, \\dots, v_k$ such that $(v_i, v_{i+1}) \\in E$ for all indices $i$ with $0 \\le i < k$. A directed cycle is a directed path of length at least $1$ in which the starting vertex equals the ending vertex, and there is at least one edge traversed; formally, there exist vertices $v_0, v_1, \\dots, v_k$ with $k \\ge 1$ such that $(v_i, v_{i+1}) \\in E$ for all indices $i$ with $0 \\le i < k$ and $v_0 = v_k$. A directed graph is called acyclic if it contains no directed cycle. It is a well-established theorem that a directed graph is acyclic if and only if it admits a topological ordering of its vertices. The vertex set for each test case is the set of all endpoints appearing in that test case’s edge list; vertices with no incident edges are not given and need not be inferred, as they cannot be part of any directed cycle.\n\nYour task is to write a complete, runnable program that, for each test case, constructs any internal representation needed from the provided edge list and decides whether the directed graph contains at least one directed cycle. The output for each test case must be a boolean value: $True$ if a directed cycle exists, and $False$ otherwise. The program must not assume any additional input beyond the given edge lists, and must be robust to the following realistic conditions: duplicate edges, self-loops, disconnected components, and an empty edge list.\n\nUse the following test suite of $7$ test cases, each specified as a list of ordered pairs $(u, v)$ representing a directed edge from vertex $u$ to vertex $v$:\n- Test case $1$: edges $[(1, 2), (2, 3), (3, 4)]$.\n- Test case $2$: edges $[(1, 2), (2, 3), (3, 1)]$.\n- Test case $3$: edges $[(5, 5)]$.\n- Test case $4$: edges $[(10, 11), (11, 12), (12, 10), (20, 21)]$.\n- Test case $5$: edges $[]$.\n- Test case $6$: edges $[(0, 1), (0, 1), (1, 2), (0, 2)]$.\n- Test case $7$: edges $[(100, 101), (101, 102), (102, 103), (103, 104), (104, 105), (105, 100), (106, 107)]$.\n\nFinal output format: Your program should produce a single line of output containing the results for these $7$ test cases as a comma-separated list enclosed in square brackets, in the order given above (for example, $[True,False,True,\\dots]$). No other output is permitted.", "solution": "The problem requires determining whether a directed graph, specified by a list of edges, contains at least one cycle. The solution must be robust to various graph structures, including disconnected components, self-loops, and duplicate edges. The fundamental approach to this problem is to perform a Depth-First Search (DFS) on the graph while maintaining the state of each vertex to detect back edges, which are indicative of cycles.\n\nThe problem can be decomposed into two main parts: first, constructing a suitable representation of the graph from the given edge list; and second, implementing a cycle detection algorithm on that representation.\n\n### Principle 1: Graph Representation from Edge List\n\nA directed graph is defined as a pair $G = (V, E)$, where $V$ is a set of vertices and $E$ is a set of directed edges. The input is a list of edges, for example, $[(u_1, v_1), (u_2, v_2), \\dots]$. From this, we first need to determine the vertex set $V$ and then structure the edges $E$ for efficient traversal.\n\n1.  **Vertex Set Construction**: The problem specifies that the vertex set $V$ consists of all unique vertices appearing as an endpoint in any edge. We can obtain $V$ by iterating through the edge list and collecting all unique vertex identifiers into a set.\n    For an edge list like $[(1, 2), (2, 3)]$, the vertex set is $V = \\{1, 2, 3\\}$.\n\n2.  **Adjacency List**: For graph traversal algorithms like DFS, an adjacency list is a common and efficient representation. An adjacency list is a mapping from each vertex $u \\in V$ to a collection of vertices $v$ for which an edge $(u, v) \\in E$ exists. A dictionary (or hash map) is an ideal data structure for this, where keys are vertices and values are lists of their adjacent neighbors.\n\n    The process to build the adjacency list is as follows:\n    - Initialize an empty dictionary, say `adj`.\n    - For each vertex $u$ in the determined vertex set $V$, initialize `adj[u] = []`.\n    - Iterate through each edge $(u, v)$ in the input list and append $v$ to the list `adj[u]`.\n\nThis construction naturally handles the specified conditions:\n-   **Duplicate edges**: If an edge $(u, v)$ appears multiple times, $v$ will be appended to `adj[u]` multiple times. This is acceptable; the cycle detection logic remains correct as it is concerned with reachability, not the number of paths.\n-   **Self-loops**: An edge $(u, u)$ will result in $u$ being in its own adjacency list, `adj[u]`.\n-   **Empty edge list**: If $E = \\emptyset$, then $V = \\emptyset$. The adjacency list will be empty, and the algorithm will correctly conclude there are no cycles.\n\n### Principle 2: Cycle Detection Using Depth-First Search\n\nA directed graph contains a cycle if and only if a Depth-First Search (DFS) traversal reveals a \"back edge\". A back edge is an edge from a vertex $u$ to an ancestor $v$ in the DFS tree. To identify back edges, we must track the state of each vertex during the traversal. Each vertex can be in one of three states:\n1.  **Unvisited (White)**: The vertex has not been visited yet.\n2.  **Visiting (Gray)**: The vertex is currently in the recursion stack of the DFS. This means we started exploring from this vertex, but have not yet finished exploring all of its descendants. These are the ancestors of the current node.\n3.  **Visited (Black)**: The vertex and all its descendants have been fully explored.\n\nA cycle is detected when, during the exploration of a vertex $u$, we encounter a neighbor $v$ that is currently in the \"Visiting\" state. This means we have found an edge from $u$ back to one of its ancestors $v$, completing a cycle.\n\nThe algorithm proceeds as follows:\n-   Initialize two sets: `visiting` (for gray vertices) and `visited` (for black vertices).\n-   Iterate through every vertex $u \\in V$.\n-   If $u$ has not been fully `visited` yet, start a DFS traversal from $u$.\n-   If the DFS traversal starting from any vertex returns that a cycle was found, the algorithm can terminate and report `True`.\n-   If the DFS has been run for all unvisited vertices and no cycle has been found, the graph is acyclic, and the result is `False`. This iterative approach ensures that all disconnected components of the graph are checked.\n\nThe recursive DFS function, say `dfs(u)`, works as follows:\n1.  Mark vertex $u$ as \"visiting\" by adding it to the `visiting` set.\n2.  For each neighbor $v$ of $u$:\n    a. If $v$ is in the `visiting` set, a back edge $(u, v)$ has been found. A cycle exists. Return `True`.\n    b. If $v$ is not in the `visited` set (to avoid re-exploring already completed subtrees), recursively call `dfs(v)`. If this recursive call returns `True`, it means a cycle was found downstream, so propagate `True` up the call stack.\n3.  Once all neighbors of $u$ have been processed, the exploration from $u$ is complete. Mark $u$ as \"visited\" by removing it from `visiting` and adding it to `visited`.\n4.  If the function has not returned `True` yet, it means no cycle was found in the subgraph reachable from $u$ (that hasn't been visited before). Return `False`.\n\nLet's illustrate with test case $2$: edges $[(1, 2), (2, 3), (3, 1)]$.\n-   $V = \\{1, 2, 3\\}$. Adjacency list: `adj = {1: [2], 2: [3], 3: [1]}`.\n-   Initialize `visiting = {}`, `visited = {}`.\n-   Start DFS from vertex $1$: call `dfs(1)`.\n    -   Add $1$ to `visiting`. `visiting = {1}`.\n    -   Neighbor of $1$ is $2$. $2$ is not visiting/visited. Call `dfs(2)`.\n        -   Add $2$ to `visiting`. `visiting = {1, 2}`.\n        -   Neighbor of $2$ is $3$. $3$ is not visiting/visited. Call `dfs(3)`.\n            -   Add $3$ to `visiting`. `visiting = {1, 2, 3}`.\n            -   Neighbor of $3$ is $1$. Check status of vertex $1$.\n            -   Vertex $1$ is in the `visiting` set. This is a back edge. Cycle detected.\n            -   `dfs(3)` returns `True`.\n        -   `dfs(2)` receives `True` from `dfs(3)` and returns `True`.\n    -   `dfs(1)` receives `True` from `dfs(2)` and returns `True`.\n-   The main loop receives `True` and concludes that the graph has a cycle. The result is `True`.\n\nThis algorithm is both correct and complete, satisfying all requirements of the problem.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cycle detection problem for a suite of test cases.\n    \"\"\"\n\n    # Test suite of 7 test cases, each specified as a list of directed edges.\n    test_cases = [\n        # Test case 1: A directed acyclic graph (path).\n        [(1, 2), (2, 3), (3, 4)],\n        # Test case 2: A simple cycle.\n        [(1, 2), (2, 3), (3, 1)],\n        # Test case 3: A self-loop.\n        [(5, 5)],\n        # Test case 4: A disconnected graph with one component having a cycle.\n        [(10, 11), (11, 12), (12, 10), (20, 21)],\n        # Test case 5: An empty graph.\n        [],\n        # Test case 6: A DAG with duplicate edges.\n        [(0, 1), (0, 1), (1, 2), (0, 2)],\n        # Test case 7: A more complex graph with a cycle and a separate path.\n        [(100, 101), (101, 102), (102, 103), (103, 104), (104, 105), (105, 100), (106, 107)]\n    ]\n\n    def has_cycle(edges: list[tuple[int, int]]) -> bool:\n        \"\"\"\n        Determines if a directed graph contains a cycle using Depth-First Search.\n\n        The graph is defined by a list of edges. The algorithm tracks vertex states\n        (unvisited, visiting, visited) to detect back edges, which indicate a cycle.\n\n        Args:\n            edges: A list of tuples, where each tuple (u, v) represents a\n                   directed edge from vertex u to vertex v.\n\n        Returns:\n            True if the graph contains at least one cycle, False otherwise.\n        \"\"\"\n        if not edges:\n            return False\n\n        # Build the vertex set and adjacency list from the edge list.\n        # The vertex set V is the set of all endpoints appearing in the edge list.\n        vertices = set()\n        adj = {}\n        for u, v in edges:\n            vertices.add(u)\n            vertices.add(v)\n        \n        for vertex in vertices:\n            adj[vertex] = []\n\n        for u, v in edges:\n            adj[u].append(v)\n\n        # `visiting` set tracks nodes in the current recursion stack (gray nodes).\n        # `visited` set tracks nodes that have been fully explored (black nodes).\n        visiting = set()\n        visited = set()\n\n        def _dfs(node):\n            \"\"\"Recursive DFS helper function to detect cycles.\"\"\"\n            visiting.add(node)\n\n            for neighbor in adj.get(node, []):\n                if neighbor in visiting:\n                    # A back edge is found, indicating a cycle.\n                    return True\n                if neighbor not in visited:\n                    if _dfs(neighbor):\n                        return True\n            \n            # All descendants from 'node' are explored.\n            visiting.remove(node)\n            visited.add(node)\n            return False\n\n        # Iterate through all vertices to handle disconnected components.\n        # sorted() is used for deterministic behavior, although not strictly necessary for correctness.\n        for vertex in sorted(list(vertices)):\n            if vertex not in visited:\n                if _dfs(vertex):\n                    return True\n        \n        return False\n\n    results = []\n    for case in test_cases:\n        result = has_cycle(case)\n        results.append(result)\n\n    # Format the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nsolve()\n```", "id": "3224952"}, {"introduction": "A robust algorithm is not just a sequence of steps; it's a logical structure where every detail serves a purpose. This next practice [@problem_id:3224987] challenges you to think like a debugger by analyzing a flawed version of the DFS cycle detection algorithm. By tracing its execution and pinpointing exactly why it fails to identify a cycle, you will solidify your understanding of the critical role that vertex coloring states play in correctly identifying back edges.", "problem": "You are given a directed graph $G=(V,E)$ with $V=\\{1,2,3,4\\}$ and $E=\\{(1,2),(1,4),(2,4),(2,3),(3,1)\\}$. Adjacency lists are fixed as $\\mathrm{Adj}[1]=[2,4]$, $\\mathrm{Adj}[2]=[4,3]$, $\\mathrm{Adj}[3]=[1]$, $\\mathrm{Adj}[4]=[\\ ]$. A traversal always considers vertices in increasing numerical order and, within each adjacency list, edges are scanned from left to right.\n\nConsider the following faulty cycle-detection procedure, which aims to mimic Depth-First Search (DFS) with the standard white-gray-black coloring but modifies when a vertex becomes black. The procedure maintains a color $\\mathrm{color}[u]\\in\\{\\text{white},\\text{gray},\\text{black}\\}$ for each $u\\in V$, initialized to white. For each $u$ in increasing order, if $\\mathrm{color}[u]=\\text{white}$, it calls $\\mathrm{Explore}(u)$. The subroutine $\\mathrm{Explore}(u)$ does:\n- Set $\\mathrm{color}[u]\\leftarrow\\text{gray}$.\n- For each $(u,v)\\in E$ in the order given by $\\mathrm{Adj}[u]$:\n  - If $\\mathrm{color}[v]=\\text{white}$, call $\\mathrm{Explore}(v)$.\n  - If $\\mathrm{color}[v]=\\text{gray}$, the algorithm intends to detect a directed cycle (as in correct DFS), but see the next bullet.\n- Faulty blackening rule: While $u$ is gray, as soon as every outgoing neighbor $v$ of $u$ is non-white (that is, $\\mathrm{color}[v]\\in\\{\\text{gray},\\text{black}\\}$), immediately set $\\mathrm{color}[u]\\leftarrow\\text{black}$, even if some such $v$ are still gray (their $\\mathrm{Explore}$ calls have not finished).\nThe algorithm reports “cycle detected” only when it scans an edge $(x,y)$ with $\\mathrm{color}[y]=\\text{gray}$ at that scan moment. Otherwise, if no such scan occurs, it reports “acyclic.”\n\nUse only fundamental definitions for your reasoning: a directed cycle is a sequence of vertices $u_1,u_2,\\dots,u_k$ with $k\\ge 2$ such that $(u_i,u_{i+1})\\in E$ for all $i\\in\\{1,\\dots,k-1\\}$ and $(u_k,u_1)\\in E$; correct DFS with recursion finishes a vertex $u$ (colors it black) only after all descendants reachable via tree edges from $u$ have finished; a back edge is an edge from a vertex to an ancestor on the current recursion stack (gray set), and its presence is equivalent to a directed cycle.\n\nQuestion: Running the faulty algorithm on $G$ with the specified orders, which option best explains the outcome and the precise reason for any failure?\n\nA. The algorithm incorrectly reports “acyclic” by prematurely blackening vertex $1$ once both $(1,2)$ and $(1,4)$ lead to non-white vertices (with $2$ gray and $4$ black) before $(3,1)$ is scanned; later, scanning $(3,1)$ targets a black vertex rather than gray, so the back edge $3\\to 1$ is not recognized and the directed cycle $1\\to 2\\to 3\\to 1$ is missed.\n\nB. The algorithm correctly reports “cyclic” because when scanning $(3,1)$ it encounters a gray neighbor, which is a back edge in DFS, so the cycle $1\\to 2\\to 3\\to 1$ is detected.\n\nC. The algorithm would fail only if the traversal started from vertex $4$ instead of vertex $1$; with the given order starting at $1$, it cannot prematurely blacken an ancestor and therefore still detects the cycle.\n\nD. The algorithm cannot miss cycles but can only raise false positives, because any edge to a previously visited vertex (gray or black) is treated as a back edge; thus it would report “cyclic” here due to $(2,4)$.", "solution": "The user requires a critical validation of the problem statement, followed by a detailed derivation of the solution and an evaluation of all provided options.\n\n### Step 1: Extract Givens\n\n-   **Graph**: A directed graph $G=(V,E)$.\n-   **Vertices**: $V=\\{1,2,3,4\\}$.\n-   **Edges**: $E=\\{(1,2),(1,4),(2,4),(2,3),(3,1)\\}$.\n-   **Adjacency Lists**: $\\mathrm{Adj}[1]=[2,4]$, $\\mathrm{Adj}[2]=[4,3]$, $\\mathrm{Adj}[3]=[1]$, $\\mathrm{Adj}[4]=[\\ ]$.\n-   **Traversal Order**: The main loop iterates through vertices in increasing numerical order ($1,2,3,4$). Adjacency lists are scanned from left to right as specified.\n-   **Algorithm State**: Each vertex $u$ has a color, $\\mathrm{color}[u]\\in\\{\\text{white},\\text{gray},\\text{black}\\}$, initialized to white.\n-   **Algorithm Main Loop**: For each $u \\in \\{1,2,3,4\\}$, if $\\mathrm{color}[u]=\\text{white}$, call $\\mathrm{Explore}(u)$.\n-   **Subroutine `Explore(u)`**:\n    1.  Set $\\mathrm{color}[u]\\leftarrow\\text{gray}$.\n    2.  For each neighbor $v$ of $u$ (in $\\mathrm{Adj}[u]$ order):\n        -   If $\\mathrm{color}[v]=\\text{white}$, call $\\mathrm{Explore}(v)$.\n        -   If $\\mathrm{color}[v]=\\text{gray}$, a cycle is detected (conditionally, see below).\n-   **Faulty Blackening Rule**: A vertex $u$ that is currently gray is immediately colored black as soon as all of its outgoing neighbors $v$ are non-white (i.e., $\\mathrm{color}[v]\\in\\{\\text{gray},\\text{black}\\}$). This can happen in the middle of an `Explore` call for $u$ or its descendants.\n-   **Cycle Reporting**: The algorithm reports \"cycle detected\" if and only if it scans an edge $(x,y)$ where $\\mathrm{color}[y]=\\text{gray}$ at that moment. Otherwise, it reports \"acyclic\".\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded**: The problem is situated in the field of computer science, specifically graph algorithms. All concepts, such as directed graphs, Depth-First Search (DFS), vertex coloring, and cycle detection, are standard and well-defined. The \"faulty\" procedure is a modification of a standard algorithm, which is a common and valid method for testing a deep understanding of the underlying principles. The problem is mathematically and logically sound.\n-   **Well-Posed**: The graph structure, traversal orders, and the rules of the algorithm (including the faulty one) are specified precisely and unambiguously. This ensures that the execution of the algorithm is deterministic, leading to a unique outcome. The problem is well-posed.\n-   **Objective**: The problem is stated in precise, objective language, free of any subjectivity or ambiguity.\n\nThe problem statement has no scientific or factual unsoundness, is formalizable, is complete, is computationally feasible, is well-posed, and is not trivial due to the subtlety of the faulty rule.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A detailed analysis can proceed.\n\n### Solution Derivation\n\nWe will trace the execution of the specified faulty algorithm on the graph $G$. The colors are abbreviated as $W$ (white), $G$ (gray), and $B$ (black). The initial state is $\\mathrm{color} = [W, W, W, W]$ for vertices $[1, 2, 3, 4]$. The recursion stack is represented by the sequence of `Explore` calls.\n\n1.  **Main Loop**: Start with $u=1$. $\\mathrm{color}[1]$ is $W$. Call $\\mathrm{Explore}(1)$.\n    -   **`Explore(1)`**: Set $\\mathrm{color}[1] \\leftarrow G$.\n        -   State: $[G, W, W, W]$. Stack: `[Explore(1)]`.\n    -   Examine neighbors of $1$: $\\mathrm{Adj}[1]=[2,4]$. First is $v=2$.\n    -   $\\mathrm{color}[2]$ is $W$. Call $\\mathrm{Explore}(2)$.\n        -   **`Explore(2)`**: Set $\\mathrm{color}[2] \\leftarrow G$.\n            -   State: $[G, G, W, W]$. Stack: `[Explore(1), Explore(2)]`.\n        -   Examine neighbors of $2$: $\\mathrm{Adj}[2]=[4,3]$. First is $w=4$.\n        -   $\\mathrm{color}[4]$ is $W$. Call `Explore(4)`.\n            -   **`Explore(4)`**: Set $\\mathrm{color}[4] \\leftarrow G$.\n                -   State: $[G, G, W, G]$. Stack: `[Explore(1), Explore(2), Explore(4)]`.\n            -   Examine neighbors of $4$: $\\mathrm{Adj}[4]=[\\ ]$. The loop is empty.\n            -   **Faulty Rule Check for vertex 4**: The condition for blackening a gray vertex $u$ is that all its outgoing neighbors are non-white. For vertex $4$, this set of neighbors is empty, so the condition is vacuously true.\n            -   Immediately set $\\mathrm{color}[4] \\leftarrow B$.\n                -   State: $[G, G, W, B]$.\n            -   **Faulty Rule Global Check**: The change of $\\mathrm{color}[4]$ from $W$ to $B$ (via $G$) is an event that might trigger the blackening of other gray vertices. The phrase \"as soon as ... immediately\" implies this check is not delayed. We must check all currently gray vertices: $1$ and $2$.\n                -   Check vertex $2$ (gray): Neighbors are $4, 3$. $\\mathrm{color}[4]=B$, but $\\mathrm{color}[3]=W$. The condition is not met.\n                -   Check vertex $1$ (gray): Neighbors are $2, 4$. $\\mathrm{color}[2]=G$ (non-white) and $\\mathrm{color}[4]=B$ (non-white). All neighbors of $1$ are now non-white. The condition is met.\n                -   Immediately set $\\mathrm{color}[1] \\leftarrow B$.\n                    -   State: $[B, G, W, B]$.\n            -   `Explore(4)` call finishes and returns.\n\n        -   Back in `Explore(2)`. The state is now $[B, G, W, B]$. The call stack is `[Explore(1), Explore(2)]`. Note that $\\mathrm{color}[1]$ turned black while we were deeper in the recursion.\n        -   Continue examining neighbors of $2$. Next is $w=3$.\n        -   $\\mathrm{color}[3]$ is $W$. Call `Explore(3)`.\n            -   **`Explore(3)`**: Set $\\mathrm{color}[3] \\leftarrow G$.\n                -   State: $[B, G, G, B]$. Stack: `[Explore(1), Explore(2), Explore(3)]`.\n            -   **Faulty Rule Global Check**: The change $\\mathrm{color}[3] \\leftarrow G$ is another triggering event. We check all gray vertices: $2$ and $3$.\n                -   Check vertex $2$ (gray): Neighbors are $4, 3$. $\\mathrm{color}[4]=B$ and $\\mathrm{color}[3]=G$. Both are non-white. Condition met. Immediately set $\\mathrm{color}[2] \\leftarrow B$.\n                    -   State: $[B, B, G, B]$.\n                -   Check vertex $3$ (gray): Neighbor is $1$. $\\mathrm{color}[1]=B$ (non-white). Condition met. Immediately set $\\mathrm{color}[3] \\leftarrow B$.\n                    -   State: $[B, B, B, B]$.\n            -   Now, `Explore(3)` proceeds. The state is $[B, B, B, B]$.\n            -   Examine neighbors of $3$: $\\mathrm{Adj}[3]=[1]$.\n            -   Scan edge $(3,1)$. Check $\\mathrm{color}[1]$. It is $B$.\n            -   The condition for reporting a cycle is $\\mathrm{color}[\\text{neighbor}] = G$. Since $\\mathrm{color}[1]$ is $B$, no cycle is reported here.\n            -   `Explore(3)` loop finishes. The vertex is already black. It returns.\n\n        -   Back in `Explore(2)`. The loop over its neighbors is finished. The vertex is already black. It returns.\n    -   Back in `Explore(1)`. The loop continues to its next neighbor, $v=4$.\n    -   $\\mathrm{color}[4]$ is $B$. No action is taken.\n    -   The loop over `Adj[1]` finishes. The vertex is already black. `Explore(1)` returns.\n\n2.  **Main Loop**: Continues. $u=2$, $\\mathrm{color}[2]$ is $B$. Skip. $u=3$, $\\mathrm{color}[3]$ is $B$. Skip. $u=4$, $\\mathrm{color}[4]$ is $B$. Skip.\n3.  **Termination**: The algorithm terminates. No edge $(x,y)$ was ever scanned when $\\mathrm{color}[y]$ was gray. The algorithm reports \"acyclic\".\n\nThe algorithm incorrectly fails to detect the cycle $1 \\to 2 \\to 3 \\to 1$. The failure occurs because vertex $1$, an ancestor on the recursion stack of `Explore(3)`, is prematurely colored black. When the edge $(3,1)$ (which is a back edge in a correct DFS) is examined, vertex $1$ is seen as black, not gray, thus masking the cycle.\n\n### Option-by-Option Analysis\n\n**A. The algorithm incorrectly reports “acyclic” by prematurely blackening vertex $1$ once both $(1,2)$ and $(1,4)$ lead to non-white vertices (with $2$ gray and $4$ black) before $(3,1)$ is scanned; later, scanning $(3,1)$ targets a black vertex rather than gray, so the back edge $3\\to 1$ is not recognized and the directed cycle $1\\to 2\\to 3\\to 1$ is missed.**\n-   The trace shows the algorithm reports \"acyclic\", which is incorrect.\n-   The trace shows vertex $1$ is prematurely blackened.\n-   The trigger for this blackening is that its neighbors, $2$ and $4$, become non-white. The specific state that triggers this is when `Explore(4)` has finished (making $\\mathrm{color}[4]=B$) while `Explore(2)` is still running (so $\\mathrm{color}[2]=G$). This perfectly matches the parenthetical description \"(with 2 gray and 4 black)\".\n-   This blackening of vertex $1$ occurs before `Explore(3)` is ever called, and thus well before the edge $(3,1)$ is scanned.\n-   When $(3,1)$ is finally scanned, $\\mathrm{color}[1]$ is indeed black, causing the cycle to be missed.\n-   This option provides a complete and accurate description of the algorithm's execution and failure mode.\n-   **Verdict: Correct.**\n\n**B. The algorithm correctly reports “cyclic” because when scanning $(3,1)$ it encounters a gray neighbor, which is a back edge in DFS, so the cycle $1\\to 2\\to 3\\to 1$ is detected.**\n-   This describes the behavior of a correct DFS algorithm. However, the faulty blackening rule alters the execution. As shown in the trace, vertex $1$ is black, not gray, when the edge $(3,1)$ is processed. Therefore, the algorithm does not report a cycle.\n-   **Verdict: Incorrect.**\n\n**C. The algorithm would fail only if the traversal started from vertex $4$ instead of vertex $1$; with the given order starting at $1$, it cannot prematurely blacken an ancestor and therefore still detects the cycle.**\n-   The first clause is false; the trace shows the algorithm fails starting from vertex $1$.\n-   The second clause is also false; the trace explicitly shows that vertex $1$, an ancestor in the DFS tree, is prematurely blackened.\n-   The conclusion is consequently false; the cycle is missed.\n-   **Verdict: Incorrect.**\n\n**D. The algorithm cannot miss cycles but can only raise false positives, because any edge to a previously visited vertex (gray or black) is treated as a back edge; thus it would report “cyclic” here due to $(2,4)$.**\n-   The premise \"The algorithm cannot miss cycles\" is false, as demonstrated by the trace. The premature blackening is a mechanism that causes false negatives (missed cycles).\n-   The reason given is also false: \"any edge to a previously visited vertex (gray or black) is treated as a back edge\". The problem explicitly states a cycle is reported *only* on an edge to a gray vertex. Edges to black vertices are ignored.\n-   The example given is false: \"it would report 'cyclic' here due to (2,4)\". When the edge $(2,4)$ is processed, $\\mathrm{color}[4]$ is white. This leads to a recursive call, not cycle detection. The edge $(2,4)$ is a tree edge.\n-   **Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "3224987"}, {"introduction": "Beyond simply detecting a cycle's existence, many applications require finding the *shortest* one. This problem [@problem_id:3225009] shifts our focus from a boolean question to an optimization problem, introducing Breadth-First Search (BFS) as the ideal tool for finding shortest paths in unweighted graphs. You will practice adapting BFS to find the smallest cycle and apply pruning techniques to make the search more efficient, a valuable skill in computational problem-solving.", "problem": "You are given a finite directed graph with a finite set of vertices and directed edges, with no weights on edges. A directed cycle is a sequence of vertices $(v_0,v_1,\\dots,v_{k-1})$ such that $k \\ge 1$, the vertices in the sequence are distinct, and for all $i \\in \\{0,1,\\dots,k-1\\}$ there is a directed edge from $v_i$ to $v_{(i+1) \\bmod k}$. The length of a directed cycle is the number of edges in the cycle, which equals $k$ in this definition. Design and implement an algorithm that, for each test graph, computes the length of its shortest directed cycle in terms of edge count, where graphs are unweighted. If a graph contains no directed cycle, define its shortest directed cycle length to be $0$. Use Breadth-First Search (BFS) from each vertex, but incorporate principled pruning based on lower bounds so that searches that cannot improve the current best known cycle length are not explored to completion. You must also justify why your approach is correct and analyze its worst-case running time.\n\nBegin from core definitions and properties appropriate to data structures and algorithms, specifically: the definition of a directed graph $G = (V, E)$ with $|V| = n$ and $|E| = m$, the notion of reachability, the property that Breadth-First Search (BFS) on an unweighted graph explores vertices in nondecreasing order of shortest path length in number of edges, and the concept of a Strongly Connected Component (SCC) of a directed graph. Do not assume or use any pre-specified formulas for shortest cycles; derive any necessary relationships from these foundational definitions.\n\nYour program must implement the algorithm and produce the results for the following test suite of graphs. Each graph is specified by the number of vertices $n$ labeled $\\{0,1,\\dots,n-1\\}$ and a list of directed edges as ordered pairs $\\left(u,v\\right)$ meaning a directed edge from $u$ to $v$.\n\n- Test case $1$: $n = 5$, edges $\\left[(0,1),(1,2),(2,3),(3,4)\\right]$.\n- Test case $2$: $n = 3$, edges $\\left[(0,0),(0,1),(1,2)\\right]$.\n- Test case $3$: $n = 4$, edges $\\left[(0,1),(1,0),(2,3)\\right]$.\n- Test case $4$: $n = 6$, edges $\\left[(0,1),(1,2),(2,0),(3,4),(4,5),(5,3),(2,3),(5,0)\\right]$.\n- Test case $5$: $n = 7$, edges $\\left[(0,1),(1,2),(2,3),(3,0),(4,5),(5,6)\\right]$.\n- Test case $6$: $n = 1$, edges $\\left[\\right]$.\n\nScientific realism requirements: Apply BFS only as appropriate for unweighted edges. Use lower bounds that arise from definitions and established properties, such as: vertices with in-degree $0$ cannot lie on a directed cycle; vertices in an SCC of size $1$ without a self-loop cannot lie on any directed cycle; and when a global best cycle length $L^\\star$ is known, any BFS layer producing distances $d$ where $d+1 \\ge L^\\star$ cannot yield a strictly shorter cycle and can be pruned. Ensure your program reflects these constraints faithfully.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$), where each entry is an integer equal to the shortest directed cycle length for the corresponding test graph, with $0$ indicating no cycle. No physical units, angle units, or percentages are involved in this problem, and all answers are integers.", "solution": "The problem requires designing an algorithm to find the length of the shortest directed cycle in a given unweighted directed graph. If the graph is acyclic, the length should be reported as $0$. The algorithm must be based on executing a Breadth-First Search (BFS) from each vertex, with specific pruning optimizations.\n\nA directed graph is formally represented as a pair $G=(V, E)$, where $V$ is a finite set of vertices and $E$ is a set of ordered pairs of vertices called directed edges. Let $n = |V|$ be the number of vertices and $m = |E|$ be the number of edges. The vertices are labeled $\\{0, 1, \\dots, n-1\\}$.\n\nA simple directed cycle is defined as a sequence of $k \\ge 1$ distinct vertices $(v_0, v_1, \\dots, v_{k-1})$, such that for all $i \\in \\{0, 1, \\dots, k-1\\}$, there is a directed edge from $v_i$ to $v_{(i+1) \\bmod k}$. The length of this cycle is $k$, the number of edges it contains. For $k=1$, a cycle $(v_0)$ implies a self-loop edge $(v_0, v_0)$. The objective is to find the minimum such $k$ over all cycles in the graph $G$.\n\nThe core principle of the proposed algorithm relies on the properties of BFS and the structure of cycles. A BFS initiated from a source vertex $s \\in V$ explores the graph layer by layer, guaranteeing that it finds the shortest path from $s$ to any reachable vertex in terms of the number of edges. A cycle containing a vertex $s$ can be seen as a path from $s$ to some vertex $u$, followed by a \"back edge\" $(u, s)$. The length of such a cycle is the length of the path from $s$ to $u$ plus one. By systematically searching for the shortest such construct for every possible vertex $s$, we can find the globally shortest cycle.\n\nThe algorithm proceeds as follows:\n1. Initialize a variable $L^*$ to store the length of the aforementioned shortest cycle. A safe initial value is $n+1$, as any simple cycle in a graph with $n$ vertices cannot have a length greater than $n$.\n2. Iterate through each vertex $s \\in V$, treating each one as a potential vertex in a shortest cycle and the root of a BFS traversal.\n3. For each $s$, perform a BFS:\n    a. Initialize a distance array, $d$, of size $n$, with $d(s) = 0$ and $d(v) = \\infty$ for all other vertices $v \\in V \\setminus \\{s\\}$.\n    b. Initialize a queue, $Q$, for the BFS and enqueue $s$.\n    c. While $Q$ is not empty, dequeue a vertex $u$.\n    d. **Pruning**: Before exploring from $u$, check if $d(u) + 1 \\ge L^*$. The quantity $d(u)+1$ represents the minimum length of any cycle that could be formed through the path from $s$ to $u$ and a back edge. If this minimum possible length is not strictly less than the current best-known cycle length $L^*$, no shorter cycle can be found by expanding the search from $u$. Thus, we can prune this branch of the search and continue to the next vertex in the queue.\n    e. Explore the neighbors of $u$: For each vertex $v$ such that $(u, v) \\in E$:\n        i. If $v = s$, a cycle has been found. The cycle consists of the shortest path from $s$ to $u$ (of length $d(u)$) and the edge $(u, s)$. Its length is $d(u) + 1$. Update $L^* = \\min(L^*, d(u) + 1)$.\n        ii. If $v$ has not been visited in the current BFS (i.e., $d(v) = \\infty$), update its distance $d(v) = d(u) + 1$ and enqueue $v$.\n4. After iterating through all possible starting vertices $s \\in V$, if $L^*$ remains $n+1$, it signifies that no cycles were found. In this case, the result is $0$. Otherwise, the result is the final value of $L^*$.\n\n**Correctness Justification**\nLet $C = (v_0, v_1, \\dots, v_{k-1}, v_0)$ be a shortest cycle in the graph $G$, having length $k$. The algorithm will eventually select one of its vertices, say $s=v_0$, as the starting vertex for a BFS traversal. The sub-sequence $(v_0, v_1, \\dots, v_{k-1})$ constitutes a simple path of length $k-1$ from $v_0$ to $v_{k-1}$. This path must be a shortest path from $v_0$ to $v_{k-1}$. If a shorter path existed, it would imply the existence of a shorter cycle in the graph, which contradicts the assumption that $C$ is a shortest cycle.\nSince the BFS algorithm finds the shortest path from its source to all other vertices, the BFS starting at $v_0$ will determine the distance to $v_{k-1}$ as $d(v_0, v_{k-1}) = k-1$. When the BFS, having processed $v_{k-1}$'s predecessor on the shortest path, explores the neighbors of $v_{k-1}$, it will discover the edge $(v_{k-1}, v_0)$. As $v_0$ is the starting vertex $s$, the algorithm correctly identifies a cycle of length $d(v_0, v_{k-1}) + 1 = (k-1) + 1 = k$. This ensures that $L^*$ will be updated to at most $k$. Because the algorithm considers all possibilities and $k$ is the minimum possible cycle length, the final result will be exactly $k$. The pruning step preserves correctness because it only discards search paths that cannot possibly lead to a cycle shorter than the one already found.\n\n**Worst-Case Running Time Analysis**\nThe algorithm consists of a main loop that iterates $n$ times, once for each vertex in $V$. Inside this loop, a BFS is performed. A standard BFS on a graph represented by an adjacency list takes $O(n+m)$ time. Therefore, the total worst-case time complexity of the algorithm is $n \\times O(n+m) = O(n(n+m))$. The worst-case performance is realized on graphs that are acyclic or have very long cycles, where the pruning optimization offers minimal benefit.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve_graph(n, edges):\n    \"\"\"\n    Computes the length of the shortest directed cycle in a graph.\n\n    Args:\n        n (int): The number of vertices, labeled 0 to n-1.\n        edges (list of tuple): A list of directed edges (u, v).\n\n    Returns:\n        int: The length of the shortest directed cycle, or 0 if no cycle exists.\n    \"\"\"\n    if n == 0:\n        return 0\n\n    # Adjacency list representation of the graph\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        if u < n and v < n:  # Basic validation\n            adj[u].append(v)\n\n    # Initialize shortest cycle length. A simple cycle length is at most n.\n    # We use n + 1 as an indicator for \"infinity\" or \"not found\".\n    min_cycle_len = n + 1\n\n    # Iterate through each vertex, treating it as a potential start of a cycle\n    for s in range(n):\n        # Start a Breadth-First Search (BFS) from vertex s.\n        # We use a numpy array for distances; -1 represents an unvisited vertex.\n        dist = np.full(n, -1, dtype=int)\n        \n        # Queue for BFS. collections.deque is efficient for this purpose.\n        q = deque()\n\n        # Initialize BFS from s\n        dist[s] = 0\n        q.append(s)\n\n        while q:\n            u = q.popleft()\n\n            # Pruning step: if the path to u is already long enough that any\n            # cycle through it cannot be shorter than the current best, we prune.\n            # a cycle found from here would have length at least dist[u] + 1.\n            if dist[u] + 1 >= min_cycle_len:\n                continue\n\n            for v in adj[u]:\n                if v == s:\n                    # Found a cycle back to the starting vertex s.\n                    # Cycle length = path length to u + edge (u, s).\n                    cycle_len = dist[u] + 1\n                    min_cycle_len = min(min_cycle_len, cycle_len)\n                elif dist[v] == -1:\n                    # First time visiting vertex v in this BFS. Record distance and enqueue.\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n                # If dist[v] != -1 and v != s, we have found another path to v.\n                # Since BFS explores layer by layer, this new path cannot be shorter,\n                # so we ignore it.\n\n    # If min_cycle_len was not updated from its initial value, no cycles were found.\n    # As per the problem statement, return 0 in this case.\n    if min_cycle_len == n + 1:\n        return 0\n    else:\n        return min_cycle_len\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Acyclic graph\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4)]),\n        # Test case 2: Self-loop (cycle of length 1)\n        (3, [(0, 0), (0, 1), (1, 2)]),\n        # Test case 3: Simple cycle of length 2\n        (4, [(0, 1), (1, 0), (2, 3)]),\n        # Test case 4: Two disjoint cycles of length 3, plus connecting edges\n        (6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5), (5, 3), (2, 3), (5, 0)]),\n        # Test case 5: One cycle of length 4 and a separate path\n        (7, [(0, 1), (1, 2), (2, 3), (3, 0), (4, 5), (5, 6)]),\n        # Test case 6: A single vertex with no edges\n        (1, []),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = solve_graph(n, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3225009"}]}