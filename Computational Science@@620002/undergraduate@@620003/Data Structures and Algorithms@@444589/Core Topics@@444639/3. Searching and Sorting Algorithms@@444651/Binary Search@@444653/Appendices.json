{"hands_on_practices": [{"introduction": "While the concept of binary search is simple, its implementation is notoriously prone to subtle off-by-one errors. This exercise tasks you with diagnosing and correcting a common but flawed implementation, forcing a deeper engagement with the algorithm's core mechanics. By reasoning about loop invariants and search interval definitions, you will move beyond simply memorizing a template to truly understanding why a correct binary search works [@problem_id:3215041].", "problem": "You are given an ordered array $A$ of length $n$ with elements in nondecreasing order under the usual total order on the integers. The task is to compute, for each query value $x$, the index of the first position $i$ such that $A[i] \\ge x$. If no such position exists, the answer is $n$. This function is the mathematical lower bound, which we denote as $\\text{first\\_geq}(x)$, formally defined by\n$$\n\\text{first\\_geq}(x) = \\min\\{\\, i \\in \\{0,1,\\dots,n\\} \\mid i=n \\ \\text{or} \\ A[i] \\ge x \\,\\}.\n$$\nA commonly seen buggy iterative approach tries to search with a closed interval and a loop of the form `while l  r`, set `$m = \\lfloor (l + r)/2 \\rfloor$`, and branch. For the specific task of $\\text{first\\_geq}(x)$ it often uses the update rule `if A[m] >= x then r = m - 1, else l = m + 1,` and finally returns `l`. Your tasks are:\n- Identify the off-by-one error that makes this approach incapable of producing $\\text{first\\_geq}(x)$ in all cases, and rewrite the loop invariant to fix it so that the algorithm is correct for all arrays and all $x$.\n- Implement two correct algorithms for $\\text{first\\_geq}(x)$ in addition to the buggy iterative version:\n  1. A corrected iterative binary search using your fixed invariant.\n  2. A corrected recursive binary search using your fixed invariant.\n  \nBase your reasoning on fundamental definitions about totally ordered sets and the property that the predicate $P(i) : A[i] \\ge x$ is monotone in $i$ for a nondecreasing array $A$.\n\nYour program must run with no user input and evaluate the following test suite. Each test case is a pair $(A, x)$, with $A$ given explicitly and $x$ an integer. For each test case, you must output a triple `[b,i,r]` where:\n- `b` is the index returned by the buggy iterative method described above,\n- `i` is the index returned by your corrected iterative method,\n- `r` is the index returned by your corrected recursive method.\n\nTest suite (arrays are written in standard list notation):\n1. $A = [\\,]$, $x = 10$.\n2. $A = [1,3,5]$, $x = 0$.\n3. $A = [1,3,5]$, $x = 6$.\n4. $A = [1,2,2,2,5]$, $x = 2$.\n5. $A = [1,2,2,2,5]$, $x = 4$.\n6. $A = [1,1,1]$, $x = 1$.\n7. $A = [1,2,3,4,5,6,7,8]$, $x = 5$.\n8. $A = [-5,-3,0,0,0,2,9]$, $x = 0$.\n\nFinal output format: Your program should produce a single line containing the list of triples for the test suite, in the exact format\n`[[b1,i1,r1],[b2,i2,r2],...,[b8,i8,r8]]`\nwith no spaces. For example, a line could look like\n`[[0,0,0],[0,0,0],...]`\ndepending on the results. No additional text should be printed.", "solution": "The problem asks for an analysis of a buggy binary search algorithm for finding the lower bound of a value in a sorted array, and the subsequent implementation of corrected iterative and recursive versions. The function to be computed is $\\text{first\\_geq}(x)$, formally defined for a non-decreasing array $A$ of length $n$ as:\n$$\n\\text{first\\_geq}(x) = \\min\\{\\, i \\in \\{0,1,\\dots,n\\} \\mid i=n \\ \\text{or} \\ A[i] \\ge x \\,\\}\n$$\nThis is the index of the first element in $A$ that is greater than or equal to $x$. If all elements of $A$ are smaller than $x$, the result is $n$.\n\nLet's define a predicate $P(i)$ for $i \\in \\{0, 1, \\dots, n-1\\}$ as $P(i): A[i] \\ge x$. Since the array $A$ is sorted in non-decreasing order, this predicate is monotonic. That is, if $P(j)$ is true for some index $j$, then $P(k)$ must be true for all $k > j$. Consequently, the sequence of truth values $P(0), P(1), \\dots, P(n-1)$ will consist of zero or more `False` values followed by zero or more `True` values. Our goal is to find the index of the first `True` value. If all values are `False`, the answer is $n$.\n\n### Analysis of the Buggy Algorithm\n\nThe problem describes a buggy iterative approach characterized by:\n1.  A search over a closed interval of indices, which we assume to be initialized as `l=0`, `r=n-1`. This interval, `[l, r]`, is intended to contain the solution.\n2.  A loop condition `while l  r`.\n3.  A branching logic based on the midpoint `$m = \\lfloor(l+r)/2\\rfloor$`:\n    *   If `A[m] >= x`, the update is `r = m-1`.\n    *   If `A[m]  x`, the update is `l = m+1`.\n4.  The function returns `l` upon loop termination.\n\nThe fundamental flaw lies in the update rule for the case where `A[m] >= x`. When `A[m] >= x`, it signifies that $P(m)$ is `True`. This means that the index we are searching for, let's call it $k$, must be less than or equal to $m$ (i.e., $k \\le m$). The index $m$ itself is a candidate for the solutionâ€”it could be the *first* index where the condition is met. However, the algorithm updates the right boundary of the search space to `r = m-1`, thereby excluding `m` from the interval `[l, r]` for all subsequent iterations. This premature exclusion of a potential correct answer makes the algorithm fundamentally incapable of solving the problem in all cases.\n\nLet's illustrate with a counterexample. Consider the array $A = [1, 5, 10]$ of length $n=3$, and the query value $x=5$. The correct answer for $\\text{first\\_geq}(5)$ is $1$, as $A[1]=5$ is the first element greater than or equal to $5$.\nTracing the buggy algorithm:\n1.  Initialize `l=0`, `r=n-1=2`. The interval is `[0, 2]`.\n2.  Loop 1: `l  r` ($0  2$) is true.\n    *   `m = floor((0+2)/2) = 1`.\n    *   `A[1] = 5`. The condition `A[m] >= x` ($5 \\ge 5$) is true.\n    *   The algorithm incorrectly updates `r = m-1 = 0`. The new search interval becomes `[0, 0]`.\n3.  Loop 2: `l  r` ($0  0$) is false. The loop terminates.\n4.  The function returns `l`, which has a value of `0`.\n\nThe algorithm returns `0`, but the correct answer is `1`. The error occurred because the correct solution at index `1` was discarded.\n\n### A Corrected Binary Search Algorithm\n\nTo correct the algorithm, we must redefine the search interval and the loop invariant. A robust approach for this type of search problem (finding a boundary) is to maintain an interval `[l, r]` that is guaranteed to contain the answer.\n\nLet the search space for the answer be the set of indices $\\{0, 1, \\dots, n\\}$.\n**Initialization:** We initialize our search interval to `[l, r] = [0, n]`. Notice that `r` is one beyond the last valid index of the array, which is necessary to accommodate the case where the answer is `n`.\n**Invariant:** The core principle of the corrected algorithm is to maintain the loop invariant that the target index $k = \\text{first\\_geq}(x)$ is always within the current search interval, i.e., `$l \\le k \\le r$`.\n**Loop Condition:** The search continues as long as the interval contains more than one possibility, which can be expressed as `while l  r`. When `l=r`, the interval has converged to a single point, which, by our invariant, must be the solution.\n\n**Update Logic:**\nInside the loop, we compute the midpoint `$m = l + \\lfloor(r-l)/2\\rfloor$`. We then inspect `A[m]`:\n1.  If `A[m] >= x`: This implies $P(m)$ is `True`. The target index $k$ must be at or before $m$ (i.e., $k \\le m$). To maintain the invariant `$l \\le k \\le r$`, we must update our interval to `[l, m]`. We achieve this by setting `r=m`. The new interval `[l, m]` still contains the answer.\n2.  If `A[m]  x`: This implies $P(m)$ is `False`. The target index $k$ must be after $m$ (i.e., $k > m$, or $k \\ge m+1$). To maintain the invariant, we must update our interval to `[m+1, r]`. We achieve this by setting `l = m+1`. The new interval `[m+1, r]` still contains the answer.\n\n**Termination:** The loop terminates when `l=r`. At this point, the search interval has shrunk to a single value. Due to the carefully maintained invariant, this value must be the answer, so the function returns `l` (or `r`).\n\nThis logic correctly handles all cases, including empty arrays and cases where the answer is `n`.\n\n### Corrected Implementations\n\nThis corrected logic can be implemented both iteratively and recursively.\n\n**1. Corrected Iterative Algorithm:**\n```python\ndef first_geq_iterative(A, x):\n    n = len(A)\n    l, r = 0, n\n    while l  r:\n        m = l + (r - l) // 2\n        if A[m] >= x:\n            r = m\n        else:\n            l = m + 1\n    return l\n```\n\n**2. Corrected Recursive Algorithm:**\nThe recursive version translates the same logic. A helper function is used to pass the search interval `[l, r]` through recursive calls.\n```python\ndef first_geq_recursive_helper(A, x, l, r):\n    if l >= r:\n        return l\n    m = l + (r - l) // 2\n    if A[m] >= x:\n        return first_geq_recursive_helper(A, x, l, m)\n    else:\n        return first_geq_recursive_helper(A, x, m + 1, r)\n\ndef first_geq_recursive(A, x):\n    n = len(A)\n    return first_geq_recursive_helper(A, x, 0, n)\n```\nThese two algorithms correctly implement the $\\text{first\\_geq}(x)$ function, adhering to the principles of binary search on a monotonic predicate.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef buggy_iterative_first_geq(A, x):\n    \"\"\"\n    Implements the buggy iterative binary search described in the problem.\n    It uses a closed interval [0, n-1], a `while l  r` loop, the flawed\n    update `r = m - 1` when A[m] >= x, and returns `l`.\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        return 0\n    \n    l, r = 0, n - 1\n    \n    while l  r:\n        m = l + (r - l) // 2\n        if A[m] >= x:\n            # Flaw: m could be the answer, but it's discarded.\n            r = m - 1\n        else:\n            l = m + 1\n            \n    # After the loop `l >= r`. The problem states the algorithm returns `l`.\n    # This logic is flawed and may produce an incorrect index. For example,\n    # for A=[1,3,5], x=6, the loop terminates with l=2, but the correct\n    # answer is 3. We return the result of the flawed logic as required.\n    return l\n\n\ndef corrected_iterative_first_geq(A, x):\n    \"\"\"\n    Correct iterative binary search for first_geq(x) (lower bound).\n    Uses a half-open interval [0, n).\n    \"\"\"\n    n = len(A)\n    l, r = 0, n\n    while l  r:\n        m = l + (r - l) // 2\n        if A[m] >= x:\n            r = m\n        else:\n            l = m + 1\n    return l\n\ndef corrected_recursive_first_geq_helper(A, x, l, r):\n    \"\"\"Helper for the recursive version.\"\"\"\n    if l >= r:\n        return l\n    m = l + (r - l) // 2\n    if A[m] >= x:\n        return corrected_recursive_first_geq_helper(A, x, l, m)\n    else:\n        return corrected_recursive_first_geq_helper(A, x, m + 1, r)\n\ndef corrected_recursive_first_geq(A, x):\n    \"\"\"\n    Correct recursive binary search for first_geq(x) (lower bound).\n    \"\"\"\n    n = len(A)\n    return corrected_recursive_first_geq_helper(A, x, 0, n)\n\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        ([], 10),\n        ([1, 3, 5], 0),\n        ([1, 3, 5], 6),\n        ([1, 2, 2, 2, 5], 2),\n        ([1, 2, 2, 2, 5], 4),\n        ([1, 1, 1], 1),\n        ([1, 2, 3, 4, 5, 6, 7, 8], 5),\n        ([-5, -3, 0, 0, 0, 2, 9], 0),\n    ]\n\n    results = []\n    for A_list, x in test_cases:\n        A = np.array(A_list, dtype=int)\n        \n        b = buggy_iterative_first_geq(A, x)\n        i = corrected_iterative_first_geq(A, x)\n        r = corrected_recursive_first_geq(A, x)\n\n        results.append([b, i, r])\n\n    # Format the output string as required\n    results_str = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(results_str)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3215041"}, {"introduction": "Beyond simply determining if an element exists, a more powerful application of binary search is to find its precise position, especially in arrays with duplicate values. This practice focuses on implementing the `lower_bound` and `upper_bound` functions, which find the first element greater-than-or-equal-to a target and the first element strictly greater-than a target, respectively. Mastering this requires you to reframe the search in terms of a monotonic predicate, such as $A[i] \\ge x$, and finding the first index where this condition holds true [@problem_id:3215126].", "problem": "You must write a complete program that, for each test case consisting of a sorted array and a key, computes two insertion indices that maintain nondecreasing order without using any library search or insertion helpers. The goal is to derive and implement both an iterative and a recursive binary search, each locating a boundary index induced by a monotone predicate. Specifically, given a finite sequence of integers $A$ of length $n$ that is sorted in nondecreasing order under the standard total order on the integers and a key $x$, you must compute:\n- The lower bound index $L$, defined as the smallest index $i \\in \\{0,\\dots,n\\}$ such that inserting $x$ at position $i$ preserves the sorted order and places $x$ no earlier than any existing element equal to $x$. Equivalently, $L$ is the smallest $i$ such that $A[i] \\ge x$, with the convention that the condition is vacuously true at $i = n$.\n- The upper bound index $U$, defined as the smallest index $i \\in \\{0,\\dots,n\\}$ such that inserting $x$ at position $i$ preserves the sorted order and places $x$ strictly after any existing elements equal to $x$. Equivalently, $U$ is the smallest $i$ such that $A[i]  x$, with the convention that the condition is vacuously true at $i = n$.\n\nYou must derive both indices from first principles using the following base:\n- A sequence $A$ is sorted in nondecreasing order if and only if for all indices $i$ and $j$ with $0 \\le i  j  n$ we have $A[i] \\le A[j]$.\n- For any fixed $x$, the predicates $P(i):\\; A[i] \\ge x$ and $Q(i):\\; A[i]  x$ defined over indices $i \\in \\{0,\\dots,n-1\\}$ and extended by $P(n) = \\text{true}$ and $Q(n) = \\text{true}$ are monotone (once true, always true for larger $i$) under the sortedness assumption.\n\nFrom these, derive a binary search algorithm as an invariant-driven search over a half-open interval of indices, halving the interval until the minimal index satisfying the predicate is found. Implement:\n- An iterative binary search that returns $L$.\n- A recursive binary search that returns $U$.\n\nNo standard library functions that directly implement binary search or insertion computations are allowed. In particular, you must not call any functions equivalent to computing lower or upper bounds in a standard library.\n\nYour program must run the following test suite. Each test case is a pair $(A, x)$ with $A$ sorted in nondecreasing order:\n- Case $1$: $A = [1,3,3,5,7]$, $x = 3$.\n- Case $2$: $A = [2,4,6]$, $x = 1$.\n- Case $3$: $A = [2,4,6]$, $x = 9$.\n- Case $4$: $A = [5,5,5,5]$, $x = 5$.\n- Case $5$: $A = [1,2,4,5]$, $x = 3$.\n- Case $6$: $A = []$, $x = 42$.\n- Case $7$: $A = [10]$, $x = 10$.\n- Case $8$: $A = [10]$, $x = 11$.\n- Case $9$: $A = [10]$, $x = 9$.\n\nYour program must apply the iterative algorithm to compute $L$ and the recursive algorithm to compute $U$ for each case and aggregate the results in order into a single output line in the following format: a single list where each element is a two-integer list $[L,U]$, with no additional whitespace, and the entire output printed on one line. Formally, if there are $m$ cases, output a single line encoding $[[L_1,U_1],[L_2,U_2],\\dots,[L_m,U_m]]$.\n\nAll answers are integers; no physical units or angles are involved. You may analyze the time complexity using Big O notation (Big O), but the final output is the specified list of integer pairs only.", "solution": "The problem is valid. It is a well-posed, scientifically grounded problem from the field of data structures and algorithms. It is free of any of the invalidity criteria, providing a complete and consistent set of definitions and requirements for deriving and implementing two variations of the binary search algorithm.\n\nThe core task is to find the smallest index $i$ in the range $\\{0, \\dots, n\\}$ that satisfies a monotone predicate. A predicate $P(i)$ is monotone over a sorted sequence if, for any indices $i$ and $j$ with $i  j$, $P(i) \\implies P(j)$. This means that if the predicate is true for some index, it is true for all subsequent indices. This property implies that the sequence of truth values `[P(0), P(1), ..., P(n-1)]` will be of the form `[False, ..., False, True, ..., True]`. The problem is to find the index of the first `True`. We extend this to the index $n$ by defining the predicates to be vacuously true at $n$, ensuring a \"first true\" always exists in the range $\\{0, \\dots, n\\}$.\n\nThis structure is perfectly suited for a binary search. The algorithm maintains a candidate interval of indices, `$[$low, high$)$`, which is guaranteed to contain the target index. The interval is iteratively halved until its size becomes $1$, at which point `low` equals `high` and points to the first index satisfying the predicate.\n\nLet the search space for the insertion index be the integers from $0$ to $n$. We define a half-open search interval of indices `$[$low, high$)$`. Our goal is to find the smallest index $k$ such that a given predicate is true. We maintain the invariant that the answer $k$ is contained in `$[$low, high$)$`.\n\nInitially, the entire search space is the candidate interval, so we set `low = 0` and `high = n`. Note that the index $n$ is a valid insertion point. The loop or recursion proceeds as long as `low  high`.\n\nIn each step, we compute a midpoint `$mid = low + \\lfloor \\frac{high - low}{2} \\rfloor$`. We then evaluate the predicate at this index, $P(mid)$.\n- If $P(mid)$ is true, it means that the first true value could be at index `mid` or at an earlier index. Therefore, we can discard the right half of the interval, `$[$mid+1, high$)$`, and continue our search in `$[$low, mid$)$`. We achieve this by setting `high = mid`.\n- If $P(mid)$ is false, it means that the first true value must be at an index strictly greater than `mid`. Therefore, we can discard the left half of the interval, `$[$low, mid$]$`, and continue our search in `$[$mid+1, high$)$`. We do this by setting `low = mid + 1`.\n\nThe process terminates when `low = high`. At this point, the interval has shrunk to a single point. This value, `low` (or `high`), is the smallest index $k$ for which $P(k)$ is true.\n\n**Lower Bound (L) - Iterative Implementation**\nThe lower bound, $L$, is defined as the smallest index $i \\in \\{0, \\dots, n\\}$ such that $A[i] \\ge x$. This corresponds to finding the first occurrence of an element greater than or equal to $x$.\n\nThe predicate is $P(i):\\; A[i] \\ge x$. This predicate is monotone for a nondecreasingly sorted array $A$. We can apply the general binary search algorithm derived above to find the smallest index $i$ satisfying $P(i)$. The problem specifies an iterative implementation.\n\nThe algorithm is as follows:\n1. Initialize `low = 0` and `high = n`.\n2. While `low  high`:\n   a. Calculate `$mid = low + (high - low) // 2$`.\n   b. If `A[mid] >= x`, the target index is in `$[$low, mid$)$`. Set `high = mid`.\n   c. If `A[mid]  x`, the target index is in `$[$mid+1, high$)$`. Set `low = mid + 1`.\n3. Return `low`.\n\n**Upper Bound (U) - Recursive Implementation**\nThe upper bound, $U$, is defined as the smallest index $i \\in \\{0, \\dots, n\\}$ such that $A[i] > x$. This corresponds to finding the insertion point that is strictly after all elements equal to $x$.\n\nThe predicate is $Q(i):\\; A[i] > x$. This predicate is also monotone for a nondecreasingly sorted array $A$. We apply the same binary search logic, but with a recursive implementation as specified.\n\nThe recursive function, say `search(low, high)`, will be:\n1. Base Case: If `low >= high`, the interval is empty or a single point. Return `low`.\n2. Recursive Step:\n   a. Calculate `$mid = low + (high - low) // 2$`.\n   b. If `A[mid] > x`, the target index is in `$[$low, mid$)$`. Recursively call `search(low, mid)`.\n   c. If `A[mid] = x`, the target index is in `$[$mid+1, high$)$`. Recursively call `search(mid + 1, high)`.\n\nA wrapper function will initiate the search with the full interval, calling `search(0, n)`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the binary search problem for all test cases.\n    Derives and implements iterative lower_bound and recursive upper_bound.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([1, 3, 3, 5, 7], 3),\n        ([2, 4, 6], 1),\n        ([2, 4, 6], 9),\n        ([5, 5, 5, 5], 5),\n        ([1, 2, 4, 5], 3),\n        ([], 42),\n        ([10], 10),\n        ([10], 11),\n        ([10], 9),\n    ]\n\n    def find_lower_bound_iterative(A, x):\n        \"\"\"\n        Computes the lower bound L, the smallest index i such that A[i] >= x.\n        This is an iterative implementation of binary search.\n        The search space is the half-open interval [low, high).\n        \"\"\"\n        n = len(A)\n        low, high = 0, n\n        # Invariant: The answer is in the interval [low, high].\n        # All indices k  low have A[k]  x.\n        while low  high:\n            mid = low + (high - low) // 2\n            # Predicate: A[mid] >= x\n            if A[mid] >= x:\n                # The element at mid satisfies the condition.\n                # The first occurrence could be at mid or to the left.\n                # Thus, we narrow the search to [low, mid].\n                high = mid\n            else:  # A[mid]  x\n                # The element at mid does not satisfy the condition.\n                # The first occurrence must be to the right of mid.\n                # Thus, we narrow the search to [mid + 1, high].\n                low = mid + 1\n        # When the loop terminates, low == high, which is the first index\n        # where the predicate A[i] >= x is true.\n        return low\n\n    def find_upper_bound_recursive(A, x):\n        \"\"\"\n        Wrapper function to compute the upper bound U, the smallest index i\n        such that A[i] > x. It initiates the recursive search.\n        \"\"\"\n        n = len(A)\n        \n        def _search(low, high):\n            \"\"\"\n            Recursive helper function for binary search.\n            \"\"\"\n            # Base case: When the interval is empty or a single point,\n            # low is the answer.\n            if low >= high:\n                return low\n            \n            mid = low + (high - low) // 2\n            # Predicate: A[mid] > x\n            if A[mid] > x:\n                # The element at mid satisfies the condition.\n                # The first occurrence could be at mid or to the left.\n                # Recurse on the interval [low, mid].\n                return _search(low, mid)\n            else:  # A[mid] = x\n                # The element at mid does not satisfy the condition.\n                # The first occurrence must be to the right of mid.\n                # Recurse on the interval [mid + 1, high].\n                return _search(mid + 1, high)\n\n        return _search(0, n)\n\n    results = []\n    for A, x in test_cases:\n        # Per problem, compute L iteratively and U recursively.\n        L = find_lower_bound_iterative(A, x)\n        U = find_upper_bound_recursive(A, x)\n        results.append([L, U])\n\n    # Format the final output string to exactly match [[L1,U1],[L2,U2],...]\n    # without any extra whitespace as specified.\n    formatted_pairs = []\n    for pair in results:\n        formatted_pairs.append(f\"[{pair[0]},{pair[1]}]\")\n    \n    final_output = f\"[{','.join(formatted_pairs)}]\"\n    print(final_output)\n\n\nsolve()\n```", "id": "3215126"}, {"introduction": "Binary search's power extends beyond perfectly sorted arrays. This problem challenges you to adapt its divide-and-conquer strategy to find the minimum element in a sorted array that has been rotated, a structure that is not globally sorted but possesses local order. The key is to devise a new comparison logicâ€”by comparing the midpoint element to an endpointâ€”that reliably determines which half of the search space contains the rotation point, even in the tricky presence of duplicate elements [@problem_id:3214996].", "problem": "You are given a finite array of integers that was originally sorted in non-decreasing order and then rotated by an unknown number of steps. Duplicates are allowed. Formally, let $A$ be an array of length $n \\ge 1$ that was produced by taking a non-decreasing array $B$ and rotating it by $k$ positions, where $k \\in \\{0,1,\\dots,n-1\\}$. Equivalently, there exists $k$ such that for all $i \\in \\{0,1,\\dots,n-1\\}$ one has $A[i] = B[(i+k) \\bmod n]$. The task is to design and implement two procedures, one iterative and one recursive, that each return the index of the rotation point.\n\nDefinition of the rotation point: Define the rotation point index $r$ as the smallest index $i \\in \\{0,1,\\dots,n-1\\}$ such that $A[i]$ is a global minimum of $A$. If there are multiple indices attaining the same global minimum value, $r$ is the smallest among them. If the array is not rotated (that is, $k = 0$), then $r = 0$. This definition is equivalent to the index of the minimum element with the additional tie-breaking to the leftmost occurrence.\n\nStarting base for derivation: Use only the following foundational facts about arrays and order to derive both procedures.\n- The array $A$ is the concatenation of two non-decreasing subarrays $A[0],A[1],\\dots,A[r-1]$ and $A[r],A[r+1],\\dots,A[n-1]$, where $A[n-1] \\ge A[0]$ if and only if $r = 0$, and $A[r] \\le A[i]$ for all $i$.\n- For any indices $l$ and $r$ with $0 \\le l \\le r \\le n-1$, a mid-point index $m = \\left\\lfloor \\dfrac{l+r}{2} \\right\\rfloor$ partitions the subarray $A[l],A[l+1],\\dots,A[r]$ into two halves.\n- Comparisons of the form $A[m] \\le A[r]$, $A[m]  A[r]$, and $A[m]  A[r]$ reveal relative order between halves under the non-decreasing and rotation assumptions.\n\nYour program must implement two functions that both return the index $r$ as defined:\n- An iterative binary-search-based function using only $O(1)$ additional space.\n- A recursive binary-search-based function that explores at most one half per recursive call and uses $O(\\log n)$ stack depth in the absence of degeneracy; note that in the presence of many equal elements, comparisons may be inconclusive and force a worst-case $O(n)$ behavior.\n\nInput model: There is no external input. Instead, use the following fixed test suite of arrays $A^{(t)}$, $t \\in \\{1,2,\\dots,8\\}$:\n\n- $A^{(1)} = [15,18,2,3,6,12]$, expected $r^{(1)} = 2$.\n- $A^{(2)} = [3,4,5,2,2,2]$, expected $r^{(2)} = 3$.\n- $A^{(3)} = [1,1,1,1]$, expected $r^{(3)} = 0$.\n- $A^{(4)} = [10]$, expected $r^{(4)} = 0$.\n- $A^{(5)} = [2,2,3,4,5,1,1]$, expected $r^{(5)} = 5$.\n- $A^{(6)} = [4,5,6,7,0,1,2,2,2]$, expected $r^{(6)} = 4$.\n- $A^{(7)} = [2,2,2,3,4,5,1,2]$, expected $r^{(7)} = 6$.\n- $A^{(8)} = [0,0,1,2,2,2,3]$, expected $r^{(8)} = 0$.\n\nCorrectness requirement: For each $t \\in \\{1,2,\\dots,8\\}$, both your iterative and your recursive functions must return the same index $r^{(t)}$. If they disagree for any test array, your program must detect this discrepancy and terminate with a runtime error.\n\nOutput specification: Your program should produce a single line of output containing a JSON-like list, where each element corresponds to one test array and is itself a two-element list $[x^{(t)}_{\\mathrm{it}}, x^{(t)}_{\\mathrm{rec}}]$ of the indices returned by the iterative and recursive procedures, respectively. For example, the output format must be exactly\n$[[x^{(1)}_{\\mathrm{it}},x^{(1)}_{\\mathrm{rec}}],[x^{(2)}_{\\mathrm{it}},x^{(2)}_{\\mathrm{rec}}],\\dots,[x^{(8)}_{\\mathrm{it}},x^{(8)}_{\\mathrm{rec}}]]$\nwith no spaces. Each $x^{(t)}_{\\mathrm{it}}$ and $x^{(t)}_{\\mathrm{rec}}$ is an integer.\n\nYour implementation must be a complete, runnable program in a modern programming language, with no external input, that prints exactly one line in the specified format and uses the provided test suite. No physical units, angles, or percentages are involved, so no unit specification is required.", "solution": "The problem statement is formally valid. It is self-contained, mathematically well-posed, and grounded in the established principles of algorithm design. The objective is to devise and implement two algorithms, one iterative and one recursive, to find the rotation point in a rotated, non-decreasingly sorted array that may contain duplicate elements.\n\nThe rotation point $r$ is defined as the smallest index $i \\in \\{0, 1, \\dots, n-1\\}$ such that the element $A[i]$ is a global minimum of the array $A$. This definition uniquely identifies the target index even in the presence of multiple equal minimum values.\n\nThe core of the problem lies in adapting the binary search algorithm. A standard binary search operates on a fully sorted array. Here, the array $A$ consists of two concatenated non-decreasing subarrays. Let the length of the array be $n$. If the rotation point is at index $r$, then the first subarray is $A[0..r-1]$ and the second is $A[r..n-1]$. All elements in the first subarray are greater than or equal to any element in the second subarray, provided the rotation is non-trivial (i.e., $r > 0$). The task is to efficiently locate the index $r$, which marks the beginning of the second subarray.\n\nOur strategy is to maintain a search interval `[l, r]` (where the variable `r` here refers to the right boundary, not the rotation point) that is guaranteed to contain the rotation point. We repeatedly shrink this interval by comparing the element at the midpoint, `A[m]`, with an element at one of the boundaries, for instance, `A[r]`.\n\nLet the search interval be defined by the indices `l` (left) and `r` (right). Initially, `l=0` and `r=n-1`. The midpoint is `$m = \\lfloor(l+r)/2\\rfloor$`. The decision to discard the left or right half of the search interval is based on the following case analysis:\n\n1.  **Case `A[m]  A[r]`**: This inequality implies that the subarray `A[m..r]` is sorted in non-decreasing order. If the rotation point were in the interval `(m, r]`, then there would be a \"drop\" in value, which would contradict the sorted nature of `A[m..r]`. Therefore, the rotation point must be at index `m` or to its left. We can safely discard the right half of the interval `(m, r]` and confine the search to `[l, m]`. We update our right boundary: `$r \\leftarrow m$`.\n\n2.  **Case `A[m] > A[r]`**: This inequality indicates that the subarray from `m` to `r` is not monotonic. The \"drop\" must occur somewhere between index `m` and index `r`. Specifically, the rotation point must lie in the interval `(m, r]`. Thus, we can discard the left half of the interval `[l, m]` and continue the search in `[m+1, r]`. We update our left boundary: `$l \\leftarrow m+1$`.\n\n3.  **Case `A[m] = A[r]`**: This is the ambiguous case introduced by duplicate elements. We cannot definitively determine whether the rotation point is to the left or right of `m`. For example, in an array `[1, 0, 1, 1, 1]`, with `l=0, r=4, m=2`, we have `A[m]=A[r]=1`, but the minimum is at index `1` (to the left of `m`). In an array `[1, 1, 1, 0, 1]`, with `l=0, r=4, m=2`, we again have `A[m]=A[r]=1`, but the minimum is at index `3` (to the right of `m`).\n    To resolve this ambiguity, we leverage the definition of the rotation point as the *smallest* index of a minimum value. If the rotation point were at index `r`, it would have to be the first occurrence of the minimum value. However, the condition `A[m]=A[r]` with `m  r` implies that `A[r]` is not the first occurrence of its value. Therefore, the index `r` cannot be the rotation point. We can safely discard the element at index `r` by shrinking the search space to `[l, r-1]`. We update our right boundary: `$r \\leftarrow r-1$`. This step ensures correctness but may, in worst-case scenarios (e.g., an array like `[1, 1, ..., 1]`), lead to a linear search behavior, degrading the performance from $O(\\log n)$ to $O(n)$.\n\nThe search process terminates when `l=r`. At this point, the search interval has converged to a single index, which, by our invariant, must be the rotation point.\n\n**Iterative Implementation**\nThe logic above can be implemented using a `while` loop that continues as long as `l  r`. The variables `l` and `r` are updated inside the loop according to the three cases. This approach uses $O(1)$ additional space.\n\n**Recursive Implementation**\nThe same logic can be expressed recursively. A function, say `find(A, l, r)`, is defined. The base case for the recursion is `l >= r`, at which point `l` is returned. In the recursive step, the function calculates `m` and then calls itself on the reduced interval: `find(A, l, m)`, `find(A, m+1, r)`, or `find(A, l, r-1)`. This approach maintains its state on the call stack, resulting in a space complexity of $O(\\log n)$ for most cases, and $O(n)$ in the worst case due to the third condition.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_rotation_point_iterative(arr):\n    \"\"\"\n    Finds the rotation point of a rotated sorted array using an iterative binary search.\n    The rotation point is the index of the minimum element.\n    If there are multiple minima, it's the index of the first one.\n    \n    Args:\n        arr (list or np.ndarray): The rotated sorted array.\n        \n    Returns:\n        int: The index of the rotation point.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return -1 # Or raise an error for empty array\n    if n == 1:\n        return 0\n        \n    l, r = 0, n - 1\n    \n    # The loop continues as long as the search space has more than one element.\n    # The invariant is that the rotation point is always in the range [l, r].\n    while l  r:\n        m = l + (r - l) // 2\n        \n        # Case 1: The subarray from m to r is sorted.\n        # The minimum must be in the left part, including m.\n        if arr[m]  arr[r]:\n            r = m\n        # Case 2: The \"drop\" is in the right part (m, r].\n        # The minimum must be in the right part, after m.\n        elif arr[m] > arr[r]:\n            l = m + 1\n        # Case 3 (ambiguous): arr[m] == arr[r].\n        # We can't decide which half contains the minimum.\n        # However, we can safely discard arr[r] because if it were the\n        # rotation point (the first minimum), arr[m] couldn't be equal to it.\n        # So, we shrink the search space from the right.\n        else: # arr[m] == arr[r]\n            r = r - 1\n            \n    # When the loop terminates, l == r, which is the rotation point.\n    return l\n\ndef _find_recursive_helper(arr, l, r):\n    \"\"\"Helper for the recursive implementation.\"\"\"\n    # Base case: search space has converged to one element.\n    if l >= r:\n        return l\n        \n    m = l + (r - l) // 2\n    \n    if arr[m]  arr[r]:\n        # Recurse on the left half [l, m].\n        return _find_recursive_helper(arr, l, m)\n    elif arr[m] > arr[r]:\n        # Recurse on the right half [m+1, r].\n        return _find_recursive_helper(arr, m + 1, r)\n    else: # arr[m] == arr[r]\n        # Ambiguous case, recurse on [l, r-1].\n        return _find_recursive_helper(arr, l, r - 1)\n\ndef find_rotation_point_recursive(arr):\n    \"\"\"\n    Finds the rotation point of a rotated sorted array using a recursive binary search.\n    This function is a wrapper for the main recursive logic.\n    \n    Args:\n        arr (list or np.ndarray): The rotated sorted array.\n        \n    Returns:\n        int: The index of the rotation point.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return -1\n    return _find_recursive_helper(arr, 0, n - 1)\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([15, 18, 2, 3, 6, 12]),      # expected r = 2\n        ([3, 4, 5, 2, 2, 2]),       # expected r = 3\n        ([1, 1, 1, 1]),             # expected r = 0\n        ([10]),                     # expected r = 0\n        ([2, 2, 3, 4, 5, 1, 1]),     # expected r = 5\n        ([4, 5, 6, 7, 0, 1, 2, 2, 2]), # expected r = 4\n        ([2, 2, 2, 3, 4, 5, 1, 2]),   # expected r = 6\n        ([0, 0, 1, 2, 2, 2, 3]),     # expected r = 0\n    ]\n\n    results = []\n    for case_list in test_cases:\n        # Per problem specification, use numpy array\n        case_arr = np.array(case_list)\n        \n        # Calculate result from both iterative and recursive functions\n        r_it = find_rotation_point_iterative(case_arr)\n        r_rec = find_rotation_point_recursive(case_arr)\n\n        # Correctness requirement check\n        if r_it != r_rec:\n            raise RuntimeError(\n                f\"Mismatch for case {case_list}: iterative={r_it}, recursive={r_rec}\"\n            )\n        \n        results.append([r_it, r_rec])\n\n    # Final print statement in the exact required format: [[r1_it,r1_rec],[r2_it,r2_rec],...]\n    # Using str() and replace() to achieve the no-space JSON-like format\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3214996"}]}