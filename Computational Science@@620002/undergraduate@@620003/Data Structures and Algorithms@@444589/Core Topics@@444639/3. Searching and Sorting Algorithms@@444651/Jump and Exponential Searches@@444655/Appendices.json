{"hands_on_practices": [{"introduction": "While a basic jump search can efficiently find an element, real-world data often contains duplicates. This exercise builds directly on the foundational jump search algorithm, requiring you to derive the optimal jump size $k=\\sqrt{n}$ and then apply the jump-and-scan logic symmetrically—both forwards and backwards—to locate the first and last occurrences of a value. This practice deepens your understanding of jump search's performance characteristics and demonstrates how to adapt it for more complex range-finding queries. [@problem_id:3242935]", "problem": "You are given a sorted array in non-decreasing order that may contain duplicate values. Design and implement a complete, runnable program that computes, for each provided test case, the indices of the first and last occurrences of a query value using a dual jump-based search strategy. The dual strategy must rely solely on the monotonicity of sorted arrays and a principled choice of a jump size, without resorting to binary search. Your design must explicitly justify the choice of jump size from a worst-case comparison perspective and then use symmetric leftward and rightward jump expansions to isolate the range of duplicates.\n\nFundamental base and constraints: Let the array be denoted by $A = [A_0, A_1, \\dots, A_{n-1}]$ with $n \\in \\mathbb{N}$ where $n \\geq 0$, and let the query value be denoted by $v \\in \\mathbb{Z}$. The array satisfies $A_i \\leq A_j$ for all indices $i,j \\in \\{0,1,\\dots,n-1\\}$ with $i \\leq j$. The search cost is quantified by the number of element comparisons. You must begin your reasoning from the sortedness property and a comparison-count model; do not rely on or cite pre-derived optimal parameters without justification. You must select a jump size as a function of $n$ based on minimizing worst-case comparisons for jump-style bracket localization and justify this choice in your solution.\n\nRequired algorithmic behavior:\n- Use forward jumps to locate a block that may contain $v$, then linearly scan within that block to find some index $i$ such that $A_i = v$, if it exists.\n- If such an index $i$ is found, expand leftward using fixed-size reverse jumps to bracket the first occurrence, then perform a local linear scan to identify the exact first index $i_{\\text{first}}$.\n- Expand rightward using fixed-size forward jumps to bracket the last occurrence, then perform a local linear scan to identify the exact last index $i_{\\text{last}}$.\n- If $v$ does not occur, return the list $[-1,-1]$.\n\nTest suite: Your program must run on the following set of test cases without any external input, files, or network calls. Each test case is a pair $(A, v)$.\n\n- Case $1$: $A = [\\,1,2,2,2,3,4,5\\,]$, $v = 2$.\n- Case $2$: $A = [\\,5,5,5,6,7\\,]$, $v = 5$.\n- Case $3$: $A = [\\,1,2,3,9,9,9\\,]$, $v = 9$.\n- Case $4$: $A = [\\,1,2,3,4\\,]$, $v = 6$.\n- Case $5$: $A = [\\,8\\,]$, $v = 8$.\n- Case $6$: $A = [\\,8\\,]$, $v = 9$.\n- Case $7$: $A = [\\,7,7,7,7,7,7,7,7\\,]$, $v = 7$.\n- Case $8$: $A = [\\,0,1,1,1,2,2,4,4,4,4,5,9,9,11\\,]$, $v = 4$.\n- Case $9$: $A = [\\,\\,]$ (the empty array), $v = 3$.\n\nAnswer specification:\n- For each test case, the program must output a list of exactly two integers $[i_{\\text{first}}, i_{\\text{last}}]$, where $i_{\\text{first}}$ is the index of the first occurrence of $v$ in $A$, and $i_{\\text{last}}$ is the index of the last occurrence of $v$ in $A$. If $v$ is not present, output $[-1,-1]$.\n- The final output of the program must be a single line containing a comma-separated list of these per-case results, enclosed in square brackets, with no spaces inside the inner result lists. For example, if there are three cases with outputs $[\\,1,3\\,]$, $[\\,0,2\\,]$, and $[\\,4,4\\,]$, the program must print the string \"[[$1$,$3$],[$0$,$2$],[$4$,$4$]]\".\n\nYour program must be fully self-contained, executable as-is, and expressed in a general-purpose language. Numerically, all outputs are pure indices, which are integers, and no physical units apply. There are no angles or percentages involved. The algorithm must not assume any distribution beyond the array being sorted in non-decreasing order.", "solution": "The posed problem is valid as it is scientifically grounded in the principles of algorithm design, is well-posed with a unique and verifiable solution, and is expressed in objective, formal language. It is free from any scientific, logical, or factual unsoundness.\n\nThe problem requires the design of an algorithm to find the first and last occurrences of a query value, denoted as $v$, within a sorted array, $A$, of size $n$. The array is sorted in non-decreasing order, meaning $A_i \\leq A_j$ for all indices $i, j$ such that $0 \\leq i \\leq j < n$. The solution must employ a jump-based search strategy, explicitly avoiding binary search. A core requirement is to justify the choice of jump size, $k$, based on minimizing the worst-case number of comparisons.\n\nThe overall algorithm is structured into three phases:\n1.  An initial jump search to find any index $i$ where $A_i=v$.\n2.  A leftward expanding jump search from this index to locate the first occurrence, $i_{\\text{first}}$.\n3.  A symmetric, rightward expanding jump search to pinpoint the last occurrence, $i_{\\text{last}}$.\n\n**Justification of Jump Size**\n\nA jump search operates by examining elements at fixed intervals of size $k$ to quickly narrow down the region where a target value might exist. The total search cost is dominated by two operations: the jumps themselves and a subsequent linear scan within a narrowed-down block.\n\n1.  **Jumping Phase**: We probe indices $k, 2k, 3k, \\dots, m \\cdot k$ until our search has passed the potential location of $v$. In the worst-case scenario (e.g., $v$ is the last element), the number of jumps, $m$, is approximately $\\frac{n}{k}$. This contributes $\\frac{n}{k}$ comparisons to the total cost.\n\n2.  **Linear Scan Phase**: After the jumping phase, we identify a block of size at most $k$ that must contain $v$ if it exists. A linear search within this block is then performed. In the worst case, this requires an additional $k-1$ comparisons.\n\nThe total worst-case comparison count, $C(k)$, is the sum of the costs from both phases:\n$$C(k) = \\frac{n}{k} + (k-1)$$\nTo find the optimal jump size $k$ that minimizes this cost, we can treat $k$ as a continuous variable and use calculus to find the minimum of the function $C(k)$. The first derivative of $C(k)$ with respect to $k$ is:\n$$\\frac{dC}{dk} = -\\frac{n}{k^2} + 1$$\nSetting this derivative to $0$ to find the critical point yields:\n$$-\\frac{n}{k^2} + 1 = 0 \\implies k^2 = n \\implies k = \\sqrt{n}$$\nThis derivation establishes that the optimal jump size that minimizes the worst-case number of comparisons is $k = \\sqrt{n}$. For an array of discrete elements, we use the integer part $k = \\lfloor \\sqrt{n} \\rfloor$. If $n=0$, this calculation is not applicable; if $n>0$ and $\\lfloor \\sqrt{n} \\rfloor = 0$, a minimum jump size of $1$ must be enforced to ensure progress. The overall time complexity of a search with this optimal jump size is $O(\\sqrt{n})$. This jump size, $k$, will be used consistently throughout all phases of the algorithm.\n\n**Algorithmic Implementation**\n\nThe search for $[i_{\\text{first}}, i_{\\text{last}}]$ proceeds as follows.\n\n**Phase 1: Initial Search for an Occurrence of $v$**\nFirst, handle the edge case: if the array is empty ($n=0$), $v$ cannot be present, so we return $[-1, -1]$. Otherwise, we compute the jump size $k = \\max(1, \\lfloor \\sqrt{n} \\rfloor)$.\n\n1.  **Block Location**: We use forward jumps of size $k$ to find a block that may contain $v$. We initialize two pointers, `prev` and `curr`, to $0$. We advance `curr` by $k$ as long as $A_{\\text{curr}} < v$, setting `prev` to the old value of `curr` before each jump. This process stops when $A_{\\text{curr}} \\geq v$ or `curr` exceeds the array bounds.\n2.  **Linear Scan**: The element $v$, if it exists, must be located within the block of indices $[\\text{prev}, \\min(\\text{curr}, n-1)]$. We perform a linear scan within this block to find an index, let's call it `found_idx`, such that $A_{\\text{found\\_idx}} = v$. If the scan completes without finding $v$, the element is absent from the array, and we return $[-1, -1]$.\n\n**Phase 2: Finding the First Occurrence ($i_{\\text{first}}$)**\nIf Phase $1$ succeeds, we have an index `found_idx` where $A_{\\text{found\\_idx}} = v$. We now search for the first such occurrence.\n\n1.  **Leftward Bracketing**: Starting from `found_idx`, we expand leftward using jumps of size $k$. We define a search range `[start_rng, end_rng]`. Initially, `end_rng` is set to `found_idx`. We repeatedly update `end_rng` to the current position and jump `start_rng` to the left by $k$, as long as `start_rng` is a valid positive index and $A_{\\text{start\\_rng}} = v$. This quickly establishes a bracket `[start_rng, end_rng]` that is guaranteed to contain $i_{\\text{first}}$.\n2.  **Local Linear Scan**: We then perform a fine-grained linear scan forward from `start_rng` to `end_rng`. The first index $j$ in this range for which $A_j = v$ is the required first occurrence, $i_{\\text{first}}$.\n\n**Phase 3: Finding the Last Occurrence ($i_{\\text{last}}$)**\nThis phase mirrors Phase $2$, but expands rightward from `found_idx`.\n\n1.  **Rightward Bracketing**: Starting from `found_idx`, we expand rightward. Initially, `start_rng` is set to `found_idx`. We repeatedly update `start_rng` to the current position and jump `end_rng` rightward by $k$, as long as `end_rng` is within the array bounds and $A_{\\text{end\\_rng}} = v$. This process identifies a bracket `[start_rng, end_rng]` guaranteed to contain $i_{\\text{last}}$.\n2.  **Local Linear Scan**: To pinpoint the exact index, we perform a linear scan backward from `end_rng` to `start_rng`. The first index $j$ encountered (from the right) for which $A_j = v$ is the last occurrence, $i_{\\text{last}}$.\n\nFinally, the algorithm returns the list $[i_{\\text{first}}, i_{\\text{last}}]$, which contains the indices of the first and last occurrences of $v$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef dual_jump_search(A, v):\n    \"\"\"\n    Computes the first and last occurrences of a value v in a sorted array A\n    using a dual jump-based search strategy.\n    \n    Args:\n        A (list): A sorted list of numbers in non-decreasing order.\n        v (int or float): The value to search for.\n        \n    Returns:\n        list: A list [i_first, i_last] of the first and last indices of v.\n              Returns [-1, -1] if v is not found.\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        return [-1, -1]\n\n    # k is chosen to minimize worst-case comparisons, derived from d/dk(n/k + k-1) = 0.\n    k = int(n**0.5)\n    if k == 0:\n        k = 1\n\n    # Phase 1: Initial Jump Search to find any occurrence of v.\n    found_idx = -1\n    \n    # 1.a: Find a block where v might be located.\n    prev = 0\n    curr = 0\n    while curr  n and A[curr]  v:\n        prev = curr\n        curr += k\n\n    # 1.b: Linear scan within the identified block.\n    block_end = min(curr, n - 1)\n    for i in range(prev, block_end + 1):\n        if A[i] == v:\n            found_idx = i\n            break\n    \n    if found_idx == -1:\n        return [-1, -1]\n\n    # Phase 2: Find the first occurrence (i_first) by expanding leftward.\n    i_first = -1\n    \n    # 2.a: Bracket the first occurrence with reverse jumps.\n    end_rng_first = found_idx\n    start_rng_first = max(0, found_idx - k)\n    \n    while start_rng_first > 0 and A[start_rng_first] == v:\n        end_rng_first = start_rng_first\n        start_rng_first = max(0, start_rng_first - k)\n\n    # 2.b: Linear scan within the bracket to find the exact first index.\n    for j in range(start_rng_first, end_rng_first + 1):\n        if A[j] == v:\n            i_first = j\n            break\n\n    # Phase 3: Find the last occurrence (i_last) by expanding rightward.\n    i_last = -1\n    \n    # 3.a: Bracket the last occurrence with forward jumps.\n    start_rng_last = found_idx\n    end_rng_last = min(n - 1, found_idx + k)\n\n    while end_rng_last  n - 1 and A[end_rng_last] == v:\n        start_rng_last = end_rng_last\n        end_rng_last = min(n - 1, end_rng_last + k)\n\n    # 3.b: Linear scan (backwards) within the bracket for the exact last index.\n    for j in range(end_rng_last, start_rng_last - 1, -1):\n        if A[j] == v:\n            i_last = j\n            break\n            \n    return [i_first, i_last]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, printing the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([1, 2, 2, 2, 3, 4, 5], 2),\n        ([5, 5, 5, 6, 7], 5),\n        ([1, 2, 3, 9, 9, 9], 9),\n        ([1, 2, 3, 4], 6),\n        ([8], 8),\n        ([8], 9),\n        ([7, 7, 7, 7, 7, 7, 7, 7], 7),\n        ([0, 1, 1, 1, 2, 2, 4, 4, 4, 4, 5, 9, 9, 11], 4),\n        ([], 3)\n    ]\n\n    results = []\n    for A, v in test_cases:\n        result = dual_jump_search(A, v)\n        results.append(result)\n\n    # Format the final output string as per the specification.\n    # e.g., [[1,3],[0,2],[-1,-1]]\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]}]\" for r in results]) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "3242935"}, {"introduction": "Search algorithms are powerful, but their standard forms assume a simple, linearly sorted array, which is not always the case. This problem challenges you to adapt both jump and exponential search to work on a sorted circular (or rotated) array, a common data structure variant. The key is to first locate the \"pivot\" point to create a virtual linear view of the data, upon which standard search algorithms can be applied with a simple index transformation, a technique that is both powerful and frequently tested. [@problem_id:3242790]", "problem": "You are given a finite array $A$ of length $n$ that is a rotation of a nondecreasing sorted array, which is also called a sorted circular array. Formally, there exists an index $p \\in \\{0, 1, \\dots, n-1\\}$ such that the sequence $B$ defined by $B[i] = A[(p + i) \\bmod n]$ for all $i \\in \\{0, 1, \\dots, n-1\\}$ is nondecreasing. You must design and implement a modification of jump search that works efficiently on such arrays, and, in addition, implement an exponential search variant over the same circular structure. Both algorithms must return the index $j \\in \\{0, 1, \\dots, n-1\\}$ such that $A[j] = t$ for a given target value $t$, or return $-1$ if the target is not present.\n\nYour design and implementation must be derived from the following base definitions and facts:\n- A nondecreasing sorted array $S$ satisfies $S[i] \\leq S[i+1]$ for all valid indices $i$.\n- Jump search on a nondecreasing sorted array proceeds by scanning in blocks of fixed size $s$ (with $s$ chosen deterministically as a function of $n$), jumping ahead by $s$ until the block boundary value is greater than or equal to the target, then performing a linear scan within the block. The typical choice is $s = \\lfloor \\sqrt{n} \\rfloor$.\n- Exponential search on a nondecreasing sorted array proceeds by probing positions at geometrically increasing indices until exceeding the target bound, followed by a standard binary search within the last bracketed interval.\n\nTo adapt jump search and exponential search to a sorted circular array $A$:\n- Identify a pivot index $p$ for $A$ such that the virtual linearization $B[i] = A[(p + i) \\bmod n]$ is nondecreasing. Justify the correctness of identifying $p$ using order comparisons only.\n- Define the circular jump search by performing jump search steps on $B$ using a block size $s = \\lfloor \\sqrt{n} \\rfloor$, and map any discovered index $i$ in $B$ back to the original array index $(p + i) \\bmod n$.\n- Define the circular exponential search by performing exponential range expansion over $B$, followed by a binary search within the discovered interval, and then map the resulting index back to the original array index via $(p + i) \\bmod n$.\n\nAssume all array entries and targets are integers. If the array contains duplicates, your pivot identification must remain correct and must not rely on any structure beyond comparisons; it must degrade gracefully when duplicates are adversarial. Handle edge cases, including $n = 0$ and $n = 1$.\n\nImplement both algorithms and apply them to the test suite below. For each test case, return a list with two integers: the index found by circular jump search and the index found by circular exponential search. If the target does not exist, return $-1$ for that method. There are no physical units involved; all results are pure integers.\n\nTest suite (arrays and targets):\n- Case $1$: $A = [\\,7,\\,9,\\,12,\\,15,\\,1,\\,3,\\,4,\\,5,\\,6\\,]$, $t = 3$.\n- Case $2$: $A = [\\,30,\\,40,\\,50,\\,10,\\,20\\,]$, $t = 35$.\n- Case $3$: $A = [\\,2,\\,4,\\,6,\\,8,\\,10,\\,12\\,]$, $t = 12$.\n- Case $4$: $A = [\\,4,\\,4,\\,4,\\,4\\,]$, $t = 4$.\n- Case $5$: $A = [\\,5\\,]$, $t = 5$.\n- Case $6$: $A = [\\,50,\\,60,\\,5,\\,10,\\,20,\\,30,\\,40\\,]$, $t = 50$.\n- Case $7$: $A = [\\,0,\\,1,\\,3,\\,5,\\,-10,\\,-5,\\,-2\\,]$, $t = -5$.\n- Case $8$: $A = [\\,0,\\,1,\\,3,\\,5,\\,-10,\\,-5,\\,-2\\,]$, $t = 2$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets with no spaces, in the exact format\n$[[i_{1,\\mathrm{jump}},i_{1,\\mathrm{exp}}],[i_{2,\\mathrm{jump}},i_{2,\\mathrm{exp}}],\\dots,[i_{8,\\mathrm{jump}},i_{8,\\mathrm{exp}}]]$,\nwhere $i_{k,\\mathrm{jump}}$ and $i_{k,\\mathrm{exp}}$ are the indices returned by the circular jump search and the circular exponential search respectively on test case $k$.", "solution": "The problem requires the adaptation of jump search and exponential search algorithms, traditionally used on sorted arrays, to function on sorted circular arrays. A sorted circular array, denoted as $A$ of length $n$, is a rotation of a nondecreasing sorted array.\n\n### Principle of Virtual Linearization via Pivot Identification\n\nThe core strategy is to find a \"pivot\" index $p$ that linearizes the array. The problem defines the pivot $p \\in \\{0, 1, \\dots, n-1\\}$ as the index such that the virtual array $B$ defined by $B[i] = A[(p + i) \\bmod n]$ for $i \\in \\{0, 1, \\dots, n-1\\}$ is nondecreasing. This pivot $p$ corresponds to the index of the minimum element in the array $A$. Once $p$ is identified, any search algorithm for a sorted array can be applied to the virtual array $B$ by translating indices. An index $i$ in $B$ maps to the index $(p+i) \\pmod n$ in $A$.\n\n### Pivot Identification Algorithm\n\nTo find the pivot $p$, we must find the index of the minimum element. While algorithms with $O(\\log n)$ average-case complexity exist (based on binary search), they have subtle failure modes and complexities when the array contains many duplicate values. The problem statement requires that the pivot identification \"must degrade gracefully when duplicates are adversarial.\"\n\nFor this reason, a simple and unconditionally correct approach is a linear scan, which has a time complexity of $O(n)$. This method is robust, relies only on comparisons as required, and is guaranteed to find the correct pivot in all cases, including adversarial duplicate patterns. The algorithm is as follows:\n1. If the array has $n \\le 1$ elements, it is already sorted, and the pivot is $p=0$.\n2. Iterate from $i=1$ to $n-1$. The pivot is the first index $i$ where a descent occurs, i.e., $A[i]  A[i-1]$. This index $i$ is the start of the sorted sequence and thus is the pivot $p$.\n3. If the loop completes without finding such a descent, the array is fully sorted, and the pivot is $p=0$.\n\nThis $O(n)$ pivot identification will determine the overall complexity of the subsequent search algorithms, but it ensures correctness.\n\n### Circular Jump Search\n\nThe jump search algorithm is adapted to the virtual sorted array $B$.\n1.  **Initialization**: Determine the pivot $p$. For an empty array ($n=0$), the search fails, returning $-1$. The block size for jumping is set to $s = \\lfloor \\sqrt{n} \\rfloor$.\n2.  **Jumping Phase**: We search for a block in $B$ that may contain the target value $t$. We start with a block from index $0$ to $s-1$. We repeatedly jump forward by $s$ positions. Let the current search block in $B$ be demarcated by indices `prev` and `step`. We check the value at the end of the current block, $B[\\min(\\text{step}, n)-1]$. As long as this value is less than the target $t$, we jump to the next block by setting `prev = step` and `step = step + s`. If `prev` becomes greater than or equal to $n$, the target is not in the array. The comparison is $A[(p + \\min(\\text{step}, n) - 1) \\pmod n]  t$.\n3.  **Linear Scan Phase**: Once the jumping phase terminates, the target $t$, if present, must lie within the virtual block of indices $[\\text{prev}, \\min(\\text{step}, n))$. A linear scan is performed over these virtual indices. For each virtual index $i$ in this range, we check if $B[i] = t$, which translates to checking if $A[(p+i) \\pmod n] = t$.\n4.  **Result**: If the target is found at virtual index $i$, the algorithm returns the real index $(p+i) \\pmod n$. If the scan completes without finding the target, it returns $-1$.\n\nThe time complexity is $O(n)$ for the pivot find, plus $O(\\sqrt{n})$ for the jump search itself, resulting in a total complexity of $O(n)$.\n\n### Circular Exponential Search\n\nExponential search is also adapted to operate on the virtual array $B$.\n1.  **Initialization**: Find the pivot $p$. Handle the empty array case ($n=0$) by returning $-1$.\n2.  **Range Finding Phase**: First, check if the target $t$ is the first element of the virtual array, $B[0]$ (i.e., $A[p]$). If so, return $p$. Otherwise, find a range $[i/2, i]$ in $B$ that brackets the target. This is done by initializing a bound to $1$ and doubling it ($bound = 1, 2, 4, \\dots$) as long as $bound  n$ and $B[bound] \\le t$. The check is performed as $A[(p + bound) \\pmod n] \\le t$.\n3.  **Binary Search Phase**: Once the bound exceeds the target's value or the array's limits, the target (if it exists) must be in the range of virtual indices from $bound/2$ to $\\min(bound, n-1)$. A standard binary search is then performed on this sub-array of $B$. The binary search must also use the index mapping $i \\to (p+i) \\pmod n$ to access elements in $A$.\n4.  **Result**: If the binary search finds the target at virtual index $i$, the real index $(p+i) \\pmod n$ is returned. Otherwise, $-1$ is returned.\n\nThe time complexity is $O(n)$ for the pivot find, plus $O(\\log k)$ for the exponential search (where $k$ is the target's position in $B$), for a total of $O(n)$.\n\n### Edge Case Handling\n- **$n=0$**: Both algorithms check for an empty array at the beginning and correctly return $-1$.\n- **$n=1$**: The pivot is found as $p=0$. Jump search with $s=1$ and exponential search (which checks the first element) both correctly handle this case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Implements and tests circular jump search and circular exponential search\n    on rotated sorted arrays.\n    \"\"\"\n\n    def find_pivot_linear(arr):\n        \"\"\"\n        Finds the pivot (index of the minimum element) in a rotated sorted array.\n        This O(n) implementation is robust against all duplicate patterns.\n        \"\"\"\n        n = len(arr)\n        if n = 1:\n            return 0\n        for i in range(1, n):\n            if arr[i]  arr[i - 1]:\n                return i\n        return 0\n\n    def binary_search_circular(arr, target, pivot, n, low_b, high_b):\n        \"\"\"\n        Helper function to perform binary search on a virtual sorted array.\n        low_b and high_b are indices in the virtual array B.\n        \"\"\"\n        while low_b = high_b:\n            mid_b = low_b + (high_b - low_b) // 2\n            real_idx = (pivot + mid_b) % n\n            val = arr[real_idx]\n\n            if val == target:\n                return real_idx\n            elif val  target:\n                low_b = mid_b + 1\n            else:\n                high_b = mid_b - 1\n        return -1\n\n    def circular_jump_search(arr, target):\n        \"\"\"\n        Performs jump search on a sorted circular array.\n        \"\"\"\n        n = len(arr)\n        if n == 0:\n            return -1\n\n        pivot = find_pivot_linear(arr)\n        \n        block_size = int(n**0.5)\n        if block_size == 0:\n            block_size = 1\n\n        prev = 0\n        step = block_size\n\n        # Jumping phase on the virtual array B.\n        # Check an element at the end of the block.\n        while arr[(pivot + min(step, n) - 1) % n]  target:\n            prev = step\n            step += block_size\n            if prev >= n:\n                return -1\n\n        # Linear scan phase on the determined block.\n        for i in range(prev, min(step, n)):\n            real_idx = (pivot + i) % n\n            if arr[real_idx] == target:\n                return real_idx\n\n        return -1\n\n    def circular_exponential_search(arr, target):\n        \"\"\"\n        Performs exponential search on a sorted circular array.\n        \"\"\"\n        n = len(arr)\n        if n == 0:\n            return -1\n\n        pivot = find_pivot_linear(arr)\n\n        # Check the first element of the virtual sorted array.\n        if arr[pivot] == target:\n            return pivot\n\n        # Find range for binary search by doubling the bound.\n        bound = 1\n        while bound  n and arr[(pivot + bound) % n] = target:\n            # Optimization: check if the target is at the current bound.\n            if arr[(pivot + bound) % n] == target:\n                return (pivot + bound) % n\n            bound *= 2\n\n        # Perform binary search in the found range.\n        return binary_search_circular(\n            arr,\n            target,\n            pivot,\n            n,\n            bound // 2,\n            min(bound, n - 1)\n        )\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([7, 9, 12, 15, 1, 3, 4, 5, 6], 3),      # Case 1\n        ([30, 40, 50, 10, 20], 35),             # Case 2\n        ([2, 4, 6, 8, 10, 12], 12),             # Case 3\n        ([4, 4, 4, 4], 4),                      # Case 4\n        ([5], 5),                               # Case 5\n        ([50, 60, 5, 10, 20, 30, 40], 50),      # Case 6\n        ([0, 1, 3, 5, -10, -5, -2], -5),        # Case 7\n        ([0, 1, 3, 5, -10, -5, -2], 2),         # Case 8\n    ]\n\n    results = []\n    for arr, target in test_cases:\n        res_jump = circular_jump_search(arr, target)\n        res_exp = circular_exponential_search(arr, target)\n        # Format the result for a single case as [i_jump, i_exp]\n        results.append(f\"[{res_jump},{res_exp}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3242790"}, {"introduction": "Large datasets are often organized into hierarchical structures to be managed efficiently, moving beyond simple flat arrays. This exercise simulates searching in a two-level index, a structure analogous to those used in databases and file systems. You will apply the jump search methodology at a higher level of abstraction, first to identify a \"block\" of data using representative values, and then to search within that block, illustrating the algorithm's versatility in navigating more complex data layouts. [@problem_id:3242865]", "problem": "Consider a two-level index data structure $X$ defined as a finite sequence of inner sequences $X[0], X[1], \\dots, X[B-1]$, where each $X[b]$ is a finite sequence of comparable keys in non-decreasing order, duplicates are permitted within an inner sequence, and empty inner sequences are permitted. The data structure satisfies the global ordering constraint that for all block indices $b$ and $b+1$ such that both $X[b]$ and $X[b+1]$ are non-empty, $\\max(X[b])  \\min(X[b+1])$. This makes the concatenation of the inner sequences globally sorted. You are to design and implement an adaptation of jump search for this two-level index that respects the following principles.\n\n- Only comparisons of keys are permitted; no hashing or auxiliary balanced trees may be used.\n- The outer search must use a monotone representative function per non-empty block (for example, a boundary value) to decide which block may contain the query key.\n- The inner search within a candidate block must use a method that does not assume a priori knowledge of the target’s position and must be asymptotically efficient on sorted arrays.\n- The step sizes and bounds must be derived from first principles, not by guessing, and must be justified by minimizing worst-case comparisons under the constraints of a sorted structure.\n\nFormally, given a query key $x$, your algorithm must:\n- Identify a candidate block index $b^\\*$ by performing a jump-style search over the sequence of non-empty blocks using a monotone representative per block. If no candidate block can contain $x$, report that $x$ is not found.\n- Search within $X[b^\\*]$ to find the leftmost position $j$ such that $X[b^\\*][j] = x$. If such a position exists, return the pair $[b^\\*, j]$; otherwise, report that $x$ is not found.\n\nYour program must implement this algorithm and run it on the following test suite. Each test case consists of a specific two-level index and a query key $x$.\n\nDefine the three data sets:\n- $\\mathcal{D}_A = [[1, 3, 5, 5], [8, 9, 10], [14, 14, 15, 16], [20, 21]]$.\n- $\\mathcal{D}_B = [[-10, -5], [0], [2, 4, 6, 8, 10], [13, 17, 19], [23]]$.\n- $\\mathcal{D}_C = [[], [1, 2, 3], [5], [7, 7, 7, 7], [9, 12]]$.\n\nRun the algorithm on the following ordered list of test cases:\n- $(\\mathcal{D}_A, 14)$.\n- $(\\mathcal{D}_A, 1)$.\n- $(\\mathcal{D}_A, 21)$.\n- $(\\mathcal{D}_A, 7)$.\n- $(\\mathcal{D}_A, 0)$.\n- $(\\mathcal{D}_A, 100)$.\n- $(\\mathcal{D}_B, 17)$.\n- $(\\mathcal{D}_C, 7)$.\n- $(\\mathcal{D}_C, 4)$.\n- $(\\mathcal{D}_B, -10)$.\n\nFor each test case, the output must be either the pair $[b^\\*, j]$ (with both entries being integers) if the key is found, or the integer $-1$ if the key is not found. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1, r_2, r_3]$), in the same order as the test cases above. No physical units, angles, or percentages are involved; all outputs are either integers or lists of integers.", "solution": "The problem requires the design and implementation of a specialized search algorithm for a two-level indexed data structure, denoted as $X$. This structure is composed of a sequence of $B$ inner sequences, $X[0], \\dots, X[B-1]$. Each inner sequence is sorted in non-decreasing order, and a global ordering constraint, $\\max(X[b])  \\min(X[b+1])$ for any adjacent non-empty blocks $X[b]$ and $X[b+1]$, ensures that the concatenation of all elements is globally sorted. The task is to find the leftmost occurrence of a query key $x$ by adapting jump search principles.\n\nThe solution is a two-stage search process. The first stage, an outer search, identifies a single candidate block that could contain the key $x$. The second stage, an inner search, probes this specific block to locate the key.\n\n**Outer Search: Block Identification**\n\nThe outer search operates on the ordered sequence of non-empty blocks. Let there be $N$ such blocks. The problem mandates a jump-style search using a monotone representative for each block. A valid and natural choice for a representative is the first element of each non-empty block, let's say $R_i = \\min(X[b_i])$, where $b_i$ is the original index of the $i$-th non-empty block. The global ordering constraint guarantees that this sequence of representatives is strictly increasing, i.e., $R_i  R_{i+1}$ for all $i \\in [0, N-2]$.\n\nThe core principle is to find the optimal jump step size $k$ to minimize the number of comparisons in the worst case. The search involves two phases: jumping and linear scanning.\n1.  **Jumping Phase:** We jump through the representatives by a step size of $k$. The number of jumps required to find an interval containing the target is at most $\\lceil N/k \\rceil - 1$.\n2.  **Linear Scanning Phase:** Once a jump overshoots the target's potential location (i.e., we find an index $j$ such that $R_j  x$), we must perform a linear scan in the preceding interval of size $k-1$ to pinpoint the correct block.\n\nThe total number of comparisons in the outer search is therefore a function of the step size $k$, given by $C(k) \\approx N/k + k - 1$. To minimize this cost, we treat $k$ as a continuous variable and find the minimum by setting the derivative to zero:\n$$\n\\frac{dC}{dk} = -\\frac{N}{k^2} + 1 = 0\n$$\nThis yields $k^2 = N$, so the optimal step size is $k = \\sqrt{N}$. For a discrete number of blocks, we use the integer part, $k = \\lfloor \\sqrt{N} \\rfloor$.\n\nThe outer search algorithm is as follows:\n1.  Construct a list of non-empty blocks and their original indices. Let its size be $N$. If $N=0$, the key cannot be found.\n2.  Handle the edge case where the query key $x$ is smaller than the first element of the first non-empty block; in this case, $x$ is not present.\n3.  Using a step size of $k = \\lfloor \\sqrt{N} \\rfloor$, jump through the list of non-empty blocks until an index `curr` is found such that the representative at `curr` is greater than $x$. The previously visited index is `prev`. The candidate block must lie in the index range `[prev, curr - 1]`.\n4.  Perform a reverse linear scan from `curr - 1` down to `prev` to find the last block whose representative is less than or equal to $x$. This block, $X[b^\\*]$, is the unique candidate that can contain $x$.\n\n**Inner Search: Key Localization**\n\nOnce the candidate block $X[b^\\*]$ is identified, we must search within it. The problem specifies that this search must be asymptotically efficient on sorted data and not rely on a priori knowledge of the key's position. Binary search perfectly fits these criteria.\n\nTo satisfy the requirement of finding the *leftmost* position $j$ such that $X[b^\\*][j] = x$, a standard binary search is modified. When an element equal to $x$ is found at an index `mid`, this index is stored as a potential answer, and the search is subsequently narrowed to the left half of the current range (i.e., from the start to `mid - 1`). This ensures that if multiple occurrences of $x$ exist, the search will continue until the first one is found.\n\n**Algorithm Synthesis**\n\nThe complete algorithm integrates these two stages:\n1.  Extract the sequence of non-empty blocks and their original indices. Let the size of this sequence be $N$. If $N=0$, terminate and report \"not found\".\n2.  If the query key $x$ is smaller than the smallest element in the entire data structure, report \"not found\".\n3.  Execute the jump search on the representatives of the $N$ blocks with step size $k = \\lfloor\\sqrt{N}\\rfloor$ to identify the candidate block $X[b^\\*]$. If no such block can contain the key (which occurs if $x$ falls in a gap between blocks), the subsequent inner search will correctly fail.\n4.  Execute the leftmost-finding binary search for $x$ within $X[b^\\*]$.\n5.  If the inner search finds the key at local index $j$, return the pair $[b^\\*, j]$.\n6.  If the inner search does not find the key, report \"not found\". This outcome is definitive as $X[b^\\*]$ was the only possible location for $x$.", "answer": "```python\ndef search_in_two_level_index(data_structure, query_key):\n    \"\"\"\n    Performs a two-level search on the described data structure.\n\n    Args:\n        data_structure (list of lists): The two-level index X.\n        query_key (int or float): The key to search for.\n\n    Returns:\n        list or int: [block_index, inner_index] if found, otherwise -1.\n    \"\"\"\n    # Step 1: Filter to get non-empty blocks and their original indices.\n    non_empty_info = []\n    for i, block in enumerate(data_structure):\n        if block:\n            non_empty_info.append((i, block))\n\n    if not non_empty_info:\n        return -1\n\n    num_non_empty = len(non_empty_info)\n\n    # Step 2: Outer search (Jump Search) to find the candidate block.\n    # Check if the key is smaller than the very first element.\n    if query_key  non_empty_info[0][1][0]:\n        return -1\n\n    # Derive step size from first principles.\n    step_size = int(num_non_empty**0.5)\n    if step_size == 0:\n        step_size = 1\n    # A step size of 0 is only possible if num_non_empty is 0 or 1.\n    # We guarantee a minimum step size of 1 to ensure progress.\n\n    prev_idx = 0\n    curr_idx = 0\n    # Jumping phase.\n    while curr_idx  num_non_empty and non_empty_info[curr_idx][1][0] = query_key:\n        prev_idx = curr_idx\n        curr_idx += step_size\n\n    # Linear scanning phase within the identified interval.\n    candidate_block_info = None\n    # The range to scan in `non_empty_info` is [prev_idx, min(curr_idx, num_non_empty)].\n    # We scan backwards to find the last block whose first element is = query_key.\n    for i in range(min(curr_idx, num_non_empty) - 1, prev_idx - 1, -1):\n        if non_empty_info[i][1][0] = query_key:\n            candidate_block_info = non_empty_info[i]\n            break\n    \n    if candidate_block_info is None:\n        # This case implies the key is smaller than all elements,\n        # which is already handled by the initial boundary check.\n        return -1\n\n    original_block_idx, block_data = candidate_block_info\n\n    # Step 3: Inner search (Leftmost-finding Binary Search).\n    low = 0\n    high = len(block_data) - 1\n    found_idx = -1\n\n    while low = high:\n        mid = low + (high - low) // 2\n        \n        if block_data[mid] == query_key:\n            found_idx = mid\n            high = mid - 1  # Continue searching left for the first occurrence.\n        elif block_data[mid]  query_key:\n            low = mid + 1\n        else: # block_data[mid] > query_key\n            high = mid - 1\n            \n    if found_idx != -1:\n        return [original_block_idx, found_idx]\n    else:\n        return -1\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the search algorithm on them, producing\n    the final formatted output.\n    \"\"\"\n    d_a = [[1, 3, 5, 5], [8, 9, 10], [14, 14, 15, 16], [20, 21]]\n    d_b = [[-10, -5], [0], [2, 4, 6, 8, 10], [13, 17, 19], [23]]\n    d_c = [[], [1, 2, 3], [5], [7, 7, 7, 7], [9, 12]]\n\n    test_cases = [\n        (d_a, 14),\n        (d_a, 1),\n        (d_a, 21),\n        (d_a, 7),\n        (d_a, 0),\n        (d_a, 100),\n        (d_b, 17),\n        (d_c, 7),\n        (d_c, 4),\n        (d_b, -10),\n    ]\n\n    results = []\n    for data_structure, query_key in test_cases:\n        result = search_in_two_level_index(data_structure, query_key)\n        if isinstance(result, list):\n            # Format list [b, j] as a string \"[b,j]\" without spaces.\n            results.append(f\"[{result[0]},{result[1]}]\")\n        else:\n            results.append(str(result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3242865"}]}