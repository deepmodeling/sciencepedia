{"hands_on_practices": [{"introduction": "The theory of stable sorting is often best understood through practice. We begin with a common scenario in software development: debugging. Mergesort is a classic divide-and-conquer algorithm that is naturally stable if its merge step is implemented correctly. This exercise [@problem_id:3273649] challenges you to explore what happens when a subtle bug is introduced, specifically using a strict less-than comparison ($k_L \\lt k_R$) instead of a non-strict one ($k_L \\le k_R$). By implementing both the flawed and correct versions, you will see firsthand how a single character change can violate the stability guarantee when equal-keyed elements are merged from different subarrays.", "problem": "You are given an array of records, each record being a pair consisting of an integer key and an identifier. The array length is $n$. The goal is to sort the array by increasing key while preserving the relative order of records that have equal keys, which is the definition of stability: for any indices $i$ and $j$ with $0 \\le i < j < n$, if the keys satisfy $k_i = k_j$, then in the output the record originating from index $i$ must precede the record originating from index $j$. Formally, let the input sequence be $A = \\langle a_0, a_1, \\dots, a_{n-1} \\rangle$, where each $a_t = (k_t, \\mathrm{id}_t)$. A sorting algorithm is stable if for all $i, j$ with $0 \\le i < j < n$ and $k_i = k_j$, the output sequence $B$ places $a_i$ before $a_j$.\n\nConsider a recursive divide-and-conquer sorting procedure that uses a merge operation to combine two sorted halves. The merge operation compares the keys at the heads of the two halves and moves one record into the output at a time. A subtle bug can destroy stability if the merge chooses from the right half whenever the keys are equal, which can happen if the selection rule uses strict less-than $<$ improperly. Specifically, if the merge takes the left element only when the left key is strictly less than the right key, and otherwise takes the right element, then when the keys are equal, the right element is taken first, violating stability whenever equal keys are split across the two halves.\n\nTask:\n- Implement two sorting procedures on arrays of pairs $(k, \\mathrm{id})$:\n  1. A broken mergesort that fails to be stable because its merge uses strict less-than $<$ to decide which element to take from the left half. Concretely, during merge, if the left key $k_L$ and the right key $k_R$ satisfy $k_L < k_R$, take from the left; otherwise take from the right.\n  2. A corrected stable mergesort whose merge operation ensures that when $k_L \\le k_R$ it takes from the left, thereby preserving the relative order of records with equal keys across merges.\n- For each test case, output three items:\n  1. The sequence of identifiers $\\langle \\mathrm{id} \\rangle$ after applying the broken mergesort.\n  2. The sequence of identifiers $\\langle \\mathrm{id} \\rangle$ after applying the corrected stable mergesort.\n  3. A boolean indicating whether the corrected stable mergesort preserves the original relative order of records with equal keys. This boolean must be computed by comparing, for each key value $v$, the sequence of identifiers with key $v$ in the input versus the sequence with key $v$ in the output.\n\nFoundational base and constraints:\n- Use the core definition of stability as stated above: for all $i, j$ with $0 \\le i < j < n$ and $k_i = k_j$, the output must place the element from index $i$ before the element from index $j$.\n- The objective is to correct the merge decision so that the stable property holds for all inputs, and to demonstrate the difference on carefully chosen test cases.\n\nTest suite:\nUse the following six test cases, each a list of pairs $(k, \\mathrm{id})$, where the identifier $\\mathrm{id}$ is the original position in the list:\n- Test case $1$ (general mix with equal keys spanning halves): $[(3,0),(1,1),(2,2),(1,3),(2,4),(3,5),(1,6)]$.\n- Test case $2$ (all distinct keys): $[(5,0),(1,1),(3,2),(4,3),(2,4)]$.\n- Test case $3$ (all equal keys): $[(1,0),(1,1),(1,2),(1,3),(1,4)]$.\n- Test case $4$ (blocks of duplicates split across halves): $[(1,0),(1,1),(2,2),(2,3),(1,4),(1,5),(2,6),(2,7)]$.\n- Test case $5$ (empty input): $[]$.\n- Test case $6$ (single element): $[(42,0)]$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces. Each element corresponds to one test case and is itself a triple of the form $[L_b,L_f,S]$, where $L_b$ is the list of identifiers after the broken sort, $L_f$ is the list of identifiers after the fixed stable sort, and $S$ is the boolean stability check for the fixed sort. For example, the outermost list should look like $[[\\dots],[\\dots],\\dots]$ with no spaces anywhere.", "solution": "The problem requires an analysis and implementation of stable and unstable sorting, specifically focusing on the mergesort algorithm. Stability in sorting dictates that elements with equal keys must maintain their original relative order in the sorted output. We will implement two variants of mergesort: one that is deliberately broken to be unstable, and one that is correctly implemented to be stable. The difference lies in a single comparison operator within the merge subroutine.\n\nA sorting algorithm is defined as stable if, for any two records in the input sequence $A = \\langle a_0, a_1, \\dots, a_{n-1} \\rangle$, say $a_i = (k_i, \\mathrm{id}_i)$ and $a_j = (k_j, \\mathrm{id}_j)$ where $0 \\le i < j < n$, the condition $k_i = k_j$ implies that $a_i$ must appear before $a_j$ in the sorted output sequence.\n\nThe mergesort algorithm follows a divide-and-conquer paradigm:\n1.  **Divide**: The input array of size $n$ is split into two subarrays of size approximately $n/2$.\n2.  **Conquer**: The two subarrays are recursively sorted by calling mergesort on them.\n3.  **Combine**: The two sorted subarrays are merged into a single sorted array.\n\nThe stability of mergesort is determined exclusively by the \"Combine\" step, i.e., the merge operation. Let the two sorted subarrays to be merged be $L$ (left) and $R$ (right). Every element in $L$ originally appeared before every element in $R$ in the array segment being processed. To maintain stability, if we encounter an element $l \\in L$ and an element $r \\in R$ such that their keys are equal, $key(l) = key(r)$, the element $l$ from the left subarray must be placed into the output before $r$.\n\n**Corrected Stable Merge Logic**\n\nThe merge operation iterates through $L$ and $R$, repeatedly comparing the elements at the current heads of both subarrays and moving the smaller one to the output. To ensure stability, the comparison must be non-strict. Let the current element from $L$ be $l$ with key $k_L$ and from $R$ be $r$ with key $k_R$. The rule for a stable merge is:\n\nIf $k_L \\le k_R$, take element $l$ from $L$. Otherwise, take element $r$ from $R$.\n\nWhen $k_L = k_R$, this rule correctly selects the element $l$ from the left subarray, thereby preserving the original relative order and guaranteeing stability.\n\n**Broken Unstable Merge Logic**\n\nThe problem describes a buggy implementation where the comparison is strict:\n\nIf $k_L < k_R$, take element $l$ from $L$. Otherwise, take element $r$ from $R$.\n\nLet's analyze the case where keys are equal, $k_L = k_R$. The condition $k_L < k_R$ is false. The `else` branch is executed, causing the element $r$ from the right subarray to be selected and placed into the output before $l$. Since $l$ originally preceded $r$, this action inverts their relative order, violating the definition of stability. This bug is subtle but has significant consequences for applications where maintaining original order is critical.\n\n**Stability Verification Procedure**\n\nTo programmatically verify the stability of the corrected algorithm for a given test case, we must confirm that the relative order of items with equal keys is unchanged. The procedure is as follows:\n1.  For each unique key value $v$ present in the input array, construct a list of the identifiers of all records having that key, in the order they appear. Let this be $\\mathrm{IDs}_{\\text{input}}(v)$.\n2.  Similarly, for each unique key value $v$, construct a list of identifiers from the output of the sorting algorithm. Let this be $\\mathrm{IDs}_{\\text{output}}(v)$.\n3.  The algorithm is stable if and only if for every key $v$, the sequence of identifiers is identical: $\\mathrm{IDs}_{\\text{input}}(v) = \\mathrm{IDs}_{\\text{output}}(v)$. The final boolean result $S$ is true if this holds for all keys, and false otherwise.\n\nWe will apply this entire process—implementing both merge variants, sorting the test cases, and performing the stability check—to demonstrate the practical difference between the stable and unstable approaches.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef broken_merge(left, right):\n    \"\"\"\n    Merges two sorted numpy arrays unstably.\n    Takes the right element if keys are equal.\n    \"\"\"\n    if len(left) == 0:\n        return right\n    if len(right) == 0:\n        return left\n\n    dtype = left.dtype\n    result = np.empty(len(left) + len(right), dtype=dtype)\n    i, j, k = 0, 0, 0\n\n    while i < len(left) and j < len(right):\n        # Unstable condition: left key must be strictly less than right key\n        if left[i]['key'] < right[j]['key']:\n            result[k] = left[i]\n            i += 1\n        else: # This includes the case left['key'] >= right['key']\n            result[k] = right[j]\n            j += 1\n        k += 1\n\n    while i < len(left):\n        result[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        result[k] = right[j]\n        j += 1\n        k += 1\n\n    return result\n\ndef stable_merge(left, right):\n    \"\"\"\n    Merges two sorted numpy arrays stably.\n    Takes the left element if keys are equal or less.\n    \"\"\"\n    if len(left) == 0:\n        return right\n    if len(right) == 0:\n        return left\n\n    dtype = left.dtype\n    result = np.empty(len(left) + len(right), dtype=dtype)\n    i, j, k = 0, 0, 0\n\n    while i < len(left) and j < len(right):\n        # Stable condition: left key is less than or equal to right key\n        if left[i]['key'] <= right[j]['key']:\n            result[k] = left[i]\n            i += 1\n        else:\n            result[k] = right[j]\n            j += 1\n        k += 1\n\n    while i < len(left):\n        result[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        result[k] = right[j]\n        j += 1\n        k += 1\n\n    return result\n\ndef mergesort(arr, merge_func):\n    \"\"\"\n    Recursive mergesort implementation using a provided merge function.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = mergesort(arr[:mid], merge_func)\n    right = mergesort(arr[mid:], merge_func)\n\n    return merge_func(left, right)\n\ndef check_stability(original_arr, sorted_arr):\n    \"\"\"\n    Verifies if the sort was stable by comparing relative order of equal-keyed items.\n    \"\"\"\n    if len(original_arr) == 0:\n        return True\n        \n    original_groups = defaultdict(list)\n    for record in original_arr:\n        original_groups[record['key']].append(record['id'])\n\n    sorted_groups = defaultdict(list)\n    for record in sorted_arr:\n        sorted_groups[record['key']].append(record['id'])\n\n    for key in original_groups:\n        if original_groups[key] != sorted_groups[key]:\n            return False\n            \n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [(3,0),(1,1),(2,2),(1,3),(2,4),(3,5),(1,6)],\n        [(5,0),(1,1),(3,2),(4,3),(2,4)],\n        [(1,0),(1,1),(1,2),(1,3),(1,4)],\n        [(1,0),(1,1),(2,2),(2,3),(1,4),(1,5),(2,6),(2,7)],\n        [],\n        [(42,0)],\n    ]\n\n    dtype = [('key', int), ('id', int)]\n    results = []\n    \n    for case in test_cases:\n        if not case:\n            # Handle empty list case\n            results.append([[], [], True])\n            continue\n\n        arr = np.array(case, dtype=dtype)\n        \n        # 1. Broken mergesort\n        broken_sorted_arr = mergesort(arr.copy(), broken_merge)\n        L_b = broken_sorted_arr['id'].tolist()\n\n        # 2. Corrected stable mergesort\n        stable_sorted_arr = mergesort(arr.copy(), stable_merge)\n        L_f = stable_sorted_arr['id'].tolist()\n        \n        # 3. Stability check\n        S = check_stability(arr, stable_sorted_arr)\n        \n        results.append([L_b, L_f, S])\n\n    # Final print statement in the exact required format (no spaces).\n    results_str_parts = []\n    for L_b, L_f, S in results:\n        lb_str = f\"[{','.join(map(str, L_b))}]\"\n        lf_str = f\"[{','.join(map(str, L_f))}]\"\n        s_str = 'True' if S else 'False'\n        results_str_parts.append(f\"[{lb_str},{lf_str},{s_str}]\")\n    \n    final_output = f\"[{','.join(results_str_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3273649"}, {"introduction": "Having seen how stability can fail in a specific implementation, we now formalize the concept at a more fundamental level. This exercise [@problem_id:3273737] challenges you to act as a verifier, determining if a given sequence of adjacent swaps could have been generated by a stable sorting process. You will learn to use a powerful formal tool—the lexicographical order on the pair $(\\kappa(x), \\tau(x))$, where $\\kappa(x)$ is the record's key and $\\tau(x)$ is its original position—to validate each swap and appreciate the deep connection between stability and sorting inversions.", "problem": "You are given an initial array of records and a finite sequence of swap operations. Each record has a key and an implicit original position that is its index in the initial array. A sorting algorithm is called stable if, for any two records with equal keys, their relative order in the output is the same as in the input. In formal terms, let each record be denoted by $x$ with key $\\kappa(x)$ and original position $\\tau(x)$. Define the stable comparator order $\\prec_{\\text{stab}}$ by the lexicographic rule: for any two records $x$ and $y$, $x \\prec_{\\text{stab}} y$ if and only if $\\left(\\kappa(x),\\tau(x)\\right)$ is lexicographically less than $\\left(\\kappa(y),\\tau(y)\\right)$. A sequence of adjacent swaps that only ever exchanges neighboring records that are out of order with respect to $\\prec_{\\text{stab}}$ constitutes a canonical model of a stable adjacent-swap sorting process, because such a process never reorders equal-key records against their original positions and strictly reduces the number of inversions under $\\prec_{\\text{stab}}$ until a $\\prec_{\\text{stab}}$-sorted array is reached.\n\nYou will be given several test cases. For each test case, you must decide whether the provided sequence of swaps could have been generated by some stable adjacent-swap sorting algorithm running on the given input (that is, whether every swap is between adjacent positions and swaps a pair that is currently out of order under $\\prec_{\\text{stab}}$, and whether the final array after applying all swaps is sorted under $\\prec_{\\text{stab}}$). Your program should simulate the swaps on the input and check these conditions.\n\nFundamental base to use:\n- Definition of stability: A sorting algorithm is stable if for all records $x$ and $y$ with $\\kappa(x) = \\kappa(y)$ and $\\tau(x) < \\tau(y)$, the output satisfies $x$ precedes $y$.\n- Lexicographic ordering: For pairs $\\left(a,b\\right)$ and $\\left(c,d\\right)$, $\\left(a,b\\right)$ is less than $\\left(c,d\\right)$ if $a<c$, or $a=c$ and $b<d$.\n- Inversion under a total order: For a sequence $\\left(z_0,z_1,\\dots,z_{n-1}\\right)$, an inversion is a pair of indices $\\left(i,j\\right)$ with $0 \\le i < j \\le n-1$ and $z_j \\prec_{\\text{stab}} z_i$ under the chosen total order.\n\nInput model for each test case:\n- An initial key array $K = [k_0,k_1,\\dots,k_{n-1}]$ with $n \\ge 1$, where each $k_i$ is an integer key. The original position of the record at index $i$ is $\\tau = i$, and this original position is carried with the record throughout swaps.\n- A swap sequence $S = [(i_0,j_0),(i_1,j_1),\\dots,(i_{m-1},j_{m-1})]$, where each pair $(i_t,j_t)$ denotes swapping the records currently at positions $i_t$ and $j_t$ at step $t$ of the simulation.\n\nFeasibility criteria for a test case to be labeled true:\n- Adjacency: For every swap $(i_t,j_t)$, it must hold that $|i_t - j_t| = 1$.\n- Local out-of-order condition: Right before performing $(i_t,j_t)$, let the two adjacent records be $a$ at position $\\min(i_t,j_t)$ and $b$ at position $\\max(i_t,j_t)$. The swap is valid only if $b \\prec_{\\text{stab}} a$ using the comparator on $\\left(\\kappa(\\cdot),\\tau(\\cdot)\\right)$.\n- Final sortedness: After performing all swaps, the resulting array must be sorted under $\\prec_{\\text{stab}}$, that is, the sequence $\\left(\\left(\\kappa(z_0),\\tau(z_0)\\right),\\dots,\\left(\\kappa(z_{n-1}),\\tau(z_{n-1})\\right)\\right)$ is nondecreasing in the lexicographic sense, and consequently equal-key records appear in the same relative order as in the input.\n\nYour program must implement this simulation and decision logic. It must produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, such as `[True, False]`, but with Python boolean literals.\n\nTest suite to use:\n- Test case $1$: $K = [3,1,1,2]$, $S = [(0,1),(1,2),(2,3)]$.\n- Test case $2$: $K = [2,2,1]$, $S = [(0,1),(1,2)]$.\n- Test case $3$: $K = [2,1,3]$, $S = [(0,2)]$.\n- Test case $4$: $K = [3,2,1]$, $S = [(0,1)]$.\n- Test case $5$: $K = [1,1,2,3]$, $S = []$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each result a Python boolean literal, in the order of the test cases, for example `[True,False,...]`.", "solution": "We begin from the definitions. A stable sorting algorithm preserves the relative order of records with equal keys. Formally, let each record $x$ have a key $\\kappa(x)$ and an original position $\\tau(x)$, and define the order $\\prec_{\\text{stab}}$ on records $x$ and $y$ by $x \\prec_{\\text{stab}} y$ if and only if $\\left(\\kappa(x),\\tau(x)\\right)$ is lexicographically less than $\\left(\\kappa(y),\\tau(y)\\right)$. This turns the stability requirement into the property that the output sequence is nondecreasing with respect to $\\prec_{\\text{stab}}$. In particular, if $\\kappa(x)=\\kappa(y)$ and $\\tau(x)<\\tau(y)$, then $x \\prec_{\\text{stab}} y$, ensuring that equal-key records must appear in the original order in the sorted output.\n\nConsider adjacent-swap sorting processes that operate under $\\prec_{\\text{stab}}$; such a process examines neighboring positions at each step and swaps them only if the right neighbor $b$ is strictly less than the left neighbor $a$ according to $\\prec_{\\text{stab}}$, i.e., $b \\prec_{\\text{stab}} a$. This is the local rule of methods such as bubble sort, which is known to be stable when comparisons treat equal keys as not out-of-order. Two key observations establish principle-based correctness of our feasibility criteria:\n\n1. Local legality via lexicographic comparator prevents reordering equal-key records in unstable ways. If two adjacent records have equal keys, say $\\kappa(a)=\\kappa(b)$, then the comparator reduces to comparing $\\tau(a)$ and $\\tau(b)$. Because the initial $\\tau$ values reflect the original order and are never altered, if $a$ precedes $b$ in the array, then $\\tau(a) < \\tau(b)$ and thus $a \\prec_{\\text{stab}} b$. Therefore $b \\prec_{\\text{stab}} a$ is false, and a stable adjacent-swap algorithm will not swap equal-key neighbors in their original order. Consequently, any swap between equal-key neighbors that are already in original order violates the local out-of-order condition, which our feasibility check rejects.\n\n2. Each valid adjacent swap strictly reduces the number of inversions under $\\prec_{\\text{stab}}$. Define the inversion count $I$ of a sequence $\\left(z_0,\\dots,z_{n-1}\\right)$ under $\\prec_{\\text{stab}}$ as the number of index pairs $\\left(i,j\\right)$ with $0 \\le i < j \\le n-1$ such that $z_j \\prec_{\\text{stab}} z_i$. If we swap adjacent elements $a$ and $b$ with $b \\prec_{\\text{stab}} a$, then exactly one inversion between that pair is removed and no new inversions are introduced that were not already present among nonadjacent elements, because $a$ moves right by one position and $b$ moves left by one position; standard arguments for bubble-sort correctness formalize that such adjacent swaps monotonically decrease $I$ until $I=0$, which is equivalent to the sequence being sorted under $\\prec_{\\text{stab}}$.\n\nFrom these principles, the feasibility criteria are necessary for the swap sequence to be produced by a stable adjacent-swap sorting algorithm:\n\n- Adjacency, $|i_t-j_t|=1$, ensures the swap is a local neighbor exchange as in bubble sort and similar stable methods.\n- Local out-of-order condition, $b \\prec_{\\text{stab}} a$ before the swap, ensures that each swap is legitimate under the comparator that encodes stability, preventing swaps of equal-key items in their original order and guaranteeing inversion reduction.\n- Final sortedness ensures that the sequence of swaps indeed completes a sorting process under $\\prec_{\\text{stab}}$.\n\nThey are also sufficient in the following sense: if every swap in the sequence satisfies adjacency and local legality, and the final array is $\\prec_{\\text{stab}}$-sorted, then there exists a stable adjacent-swap sorting routine (for instance, a bubble-sort variant that scans and swaps only out-of-order neighbors) that could produce exactly this sequence on the given input, because any sequence of legitimate adjacent swaps that ends in a sorted state can be realized by choosing the positions to examine in the order indicated by the given sequence.\n\nAlgorithmic design to check feasibility adheres to these principles:\n\n- Represent each record by the pair $\\left(\\kappa,\\tau\\right)$ where $\\tau$ is the initial index. Define a comparator that returns true for $x \\prec_{\\text{stab}} y$ if $\\left(\\kappa(x),\\tau(x)\\right)$ is lexicographically less than $\\left(\\kappa(y),\\tau(y)\\right)$.\n- Simulate the swap sequence:\n  - For each swap $(i_t,j_t)$, verify adjacency by checking $|i_t-j_t|=1$.\n  - Let $p=\\min(i_t,j_t)$ and $q=\\max(i_t,j_t)$, and inspect neighbors $a$ at position $p$ and $b$ at position $q$. Check local legality by testing $b \\prec_{\\text{stab}} a$; if false, reject the sequence.\n  - Perform the swap of positions $p$ and $q$.\n- After processing all swaps, check final sortedness: for every consecutive pair of positions $(r,r+1)$, ensure that the record at $r$ is not greater than the record at $r+1$ under $\\prec_{\\text{stab}}$, equivalently check that $\\neg\\left(z_{r+1} \\prec_{\\text{stab}} z_r\\right)$ for all $r$.\n\nApplying this to the given test suite:\n\n- Test case $1$: $K=[3,1,1,2]$, $S=[(0,1),(1,2),(2,3)]$. Each swap is adjacent and locally legal: $3$ swaps with $1$, then $3$ swaps with the next $1$, then $3$ swaps with $2$. The final array is sorted under $\\prec_{\\text{stab}}$ with equal-key $1$ records preserved in original order. Result $\\text{True}$.\n- Test case $2$: $K=[2,2,1]$, $S=[(0,1),(1,2)]$. The first swap attempts to exchange equal-key neighbors $2$ at original positions $\\tau=0$ and $\\tau=1$, which are not out-of-order under $\\prec_{\\text{stab}}$. Local legality fails. Result $\\text{False}$.\n- Test case $3$: $K=[2,1,3]$, $S=[(0,2)]$. The swap is not adjacent since $|0-2|=2$. Adjacency fails. Result $\\text{False}$.\n- Test case $4$: $K=[3,2,1]$, $S=[(0,1)]$. The single swap is adjacent and locally legal ($2 \\prec_{\\text{stab}} 3$), but the final array $[2,3,1]$ is not sorted under $\\prec_{\\text{stab}}$. Final sortedness fails. Result $\\text{False}$.\n- Test case $5$: $K=[1,1,2,3]$, $S=[]$. No swaps are performed; the initial array is already sorted under $\\prec_{\\text{stab}}$. All criteria pass. Result $\\text{True}$.\n\nTherefore, the program outputs the list of booleans corresponding to each test case in order, enclosed in square brackets and comma-separated.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nfrom typing import List, Tuple\n\ndef stable_less(a: Tuple[int, int], b: Tuple[int, int]) -> bool:\n    \"\"\"\n    Return True iff record a is less than record b under the stable comparator.\n    Records are tuples (key, original_index).\n    Lexicographic comparison on (key, original_index).\n    \"\"\"\n    # Compare keys first, then original indices for tie-breaking.\n    if a[0] != b[0]:\n        return a[0] < b[0]\n    return a[1] < b[1]\n\ndef is_stable_adjacent_swap_sequence(keys: List[int], swaps: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Check whether the given swap sequence could have been generated by\n    a stable adjacent-swap sorting algorithm on the given keys.\n\n    Conditions:\n    - Each swap is between adjacent positions.\n    - Each swap exchanges a locally out-of-order adjacent pair under the stable comparator.\n    - After all swaps, the array is sorted under the stable comparator.\n    \"\"\"\n    # Build records (key, original_index)\n    arr = [(k, i) for i, k in enumerate(keys)]\n\n    n = len(arr)\n\n    # Simulate swaps\n    for (i, j) in swaps:\n        # Bounds check\n        if not (0 <= i < n and 0 <= j < n):\n            return False\n        # Adjacency check\n        if abs(i - j) != 1:\n            return False\n\n        p = min(i, j)\n        q = max(i, j)\n        a = arr[p]\n        b = arr[q]\n\n        # Local out-of-order check: swap only if b  a under stable comparator\n        if not stable_less(b, a):\n            return False\n\n        # Perform swap\n        arr[p], arr[q] = arr[q], arr[p]\n\n    # Final sortedness check: ensure the array is nondecreasing under stable comparator\n    for r in range(n - 1):\n        if stable_less(arr[r + 1], arr[r]):\n            return False\n\n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Happy path, valid stable adjacent swaps (bubble-like).\n        ([3, 1, 1, 2], [(0, 1), (1, 2), (2, 3)]),\n        # Test case 2: Invalid because swapping equal-key neighbors in original order.\n        ([2, 2, 1], [(0, 1), (1, 2)]),\n        # Test case 3: Invalid due to non-adjacent swap.\n        ([2, 1, 3], [(0, 2)]),\n        # Test case 4: Valid local swap but incomplete sorting; final array not sorted.\n        ([3, 2, 1], [(0, 1)]),\n        # Test case 5: Already sorted, no swaps; valid.\n        ([1, 1, 2, 3], []),\n    ]\n\n    results = []\n    for keys, swaps in test_cases:\n        result = is_stable_adjacent_swap_sequence(keys, swaps)\n        results.append(result)\n\n    # Final print statement in the exact required format (no spaces).\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3273737"}, {"introduction": "Stability is a general algorithmic property, not one exclusive to comparison-based sorts. This final practice [@problem_id:3273671] expands our horizon to non-comparison algorithms by tasking you with designing a stable version of Counting Sort. You must adapt this linear-time algorithm, typically used for integers, to handle general records. This will reveal how stability can be achieved through a completely different mechanism: using an auxiliary array of counts to determine final positions, and iterating through the input in reverse order to place elements correctly.", "problem": "You are tasked with designing and implementing a stable sorting algorithm based on counting frequencies of integer keys for a sequence of general records (objects). The goal is to sort by extracted integer keys while preserving the relative order of records that share the same key. You must implement a complete, runnable program that constructs the specified test suite, applies your sorting procedure, verifies correctness and stability for each test case, and prints the results in the required aggregate output format.\n\nDefinitions to be used as the fundamental base for reasoning and verification:\n- A sorting algorithm takes a sequence $S$ of length $n$ and produces a permutation $S'$ such that a chosen key function $K$ is non-decreasing on $S'$. Formally, for all indices $i$ with $0 \\le i  n-1$, $K(S'[i]) \\le K(S'[i+1])$.\n- A sorting algorithm is stable if for any two records $x$ and $y$ with $K(x) = K(y)$ and $x$ appearing before $y$ in the original sequence $S$, then $x$ appears before $y$ in the output sequence $S'$.\n\nRequired behavior and constraints:\n- Your algorithm must sort arbitrary records, each with at least an identifier field, a key field, and an arbitrary payload field. The key field is an integer produced by an extraction function $K$.\n- Assume keys are integers in a specified closed range $[k_{\\min}, k_{\\max}]$. If any record’s key falls outside $[k_{\\min}, k_{\\max}]$, treat the case as invalid and report failure for that test case.\n- The algorithm must be stable and must be based on counting frequencies of keys (i.e., using counts over the key domain to determine positions). It must work for negative keys by appropriately handling the key range $[k_{\\min}, k_{\\max}]$.\n\nVerification criteria for each test case:\n- Sortedness: The output sequence $S'$ must satisfy $K(S'[i]) \\le K(S'[i+1])$ for all valid indices $i$.\n- Stability: For every value $v$ in the key domain, consider the subsequence of identifiers from $S$ whose keys equal $v$. In the output $S'$, the identifiers associated with key $v$ must appear in exactly the same relative order as in $S$.\n\nTest suite to implement:\nUse the following six test cases. Each record is described as a triple $(\\text{id}, \\text{key}, \\text{payload})$, where $\\text{id}$ is a unique identifier, $\\text{key}$ is the integer key, and $\\text{payload}$ is an arbitrary string.\n\n- Test case $1$ (general case with duplicates and multiple keys, happy path):\n  - Sequence $S_1$: $(\\text{id}=0,\\text{key}=3,\\text{payload}='a')$, $(\\text{id}=1,\\text{key}=1,\\text{payload}='b')$, $(\\text{id}=2,\\text{key}=2,\\text{payload}='c')$, $(\\text{id}=3,\\text{key}=1,\\text{payload}='d')$, $(\\text{id}=4,\\text{key}=3,\\text{payload}='e')$, $(\\text{id}=5,\\text{key}=0,\\text{payload}='f')$, $(\\text{id}=6,\\text{key}=2,\\text{payload}='g')$, $(\\text{id}=7,\\text{key}=0,\\text{payload}='h')$, $(\\text{id}=8,\\text{key}=3,\\text{payload}='i')$.\n  - Range: $[k_{\\min}, k_{\\max}] = [0, 3]$.\n\n- Test case $2$ (all keys equal, tests pure stability):\n  - Sequence $S_2$: $(\\text{id}=0,\\text{key}=5,\\text{payload}='x')$, $(\\text{id}=1,\\text{key}=5,\\text{payload}='y')$, $(\\text{id}=2,\\text{key}=5,\\text{payload}='z')$.\n  - Range: $[k_{\\min}, k_{\\max}] = [5, 5]$.\n\n- Test case $3$ (negative to positive keys, boundary coverage):\n  - Sequence $S_3$: $(\\text{id}=0,\\text{key}=-3,\\text{payload}='a')$, $(\\text{id}=1,\\text{key}=-1,\\text{payload}='b')$, $(\\text{id}=2,\\text{key}=-3,\\text{payload}='c')$, $(\\text{id}=3,\\text{key}=0,\\text{payload}='d')$, $(\\text{id}=4,\\text{key}=2,\\text{payload}='e')$, $(\\text{id}=5,\\text{key}=-1,\\text{payload}='f')$.\n  - Range: $[k_{\\min}, k_{\\max}] = [-3, 2]$.\n\n- Test case $4$ (empty sequence, edge case):\n  - Sequence $S_4$: empty sequence.\n  - Range: $[k_{\\min}, k_{\\max}] = [0, 0]$.\n\n- Test case $5$ (invalid due to out-of-range key, error detection):\n  - Sequence $S_5$: $(\\text{id}=0,\\text{key}=0,\\text{payload}='a')$, $(\\text{id}=1,\\text{key}=10,\\text{payload}='b')$, $(\\text{id}=2,\\text{key}=5,\\text{payload}='c')$.\n  - Range: $[k_{\\min}, k_{\\max}] = [0, 5]$.\n  - A record has $\\text{key} = 10$, which is outside $[0, 5]$. The expected boolean for this test case is failure.\n\n- Test case $6$ (non-contiguous keys with gaps in the key domain):\n  - Sequence $S_6$: $(\\text{id}=0,\\text{key}=4,\\text{payload}='a')$, $(\\text{id}=1,\\text{key}=0,\\text{payload}='b')$, $(\\text{id}=2,\\text{key}=4,\\text{payload}='c')$, $(\\text{id}=3,\\text{key}=2,\\text{payload}='d')$, $(\\text{id}=4,\\text{key}=2,\\text{payload}='e')$, $(\\text{id}=5,\\text{key}=0,\\text{payload}='f')$.\n  - Range: $[k_{\\min}, k_{\\max}] = [0, 4]$.\n\nProgram output specification:\n- For each test case $i \\in \\{1, 2, 3, 4, 5, 6\\}$, compute a boolean that is $true$ if and only if:\n  - The sorting result is non-decreasing by key, and\n  - The sorting result preserves the relative order of records with equal keys (stability), and\n  - All keys are inside the specified range $[k_{\\min}, k_{\\max}]$.\n  Otherwise, the boolean must be $false$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[true,false,true,...]\"). Use the native boolean formatting of the programming language for each entry in the list. No additional text should be printed.", "solution": "The problem requires the design and implementation of a stable sorting algorithm based on counting key frequencies, suitable for a sequence of records with integer keys. The implementation must be verified against criteria of sortedness, stability, and adherence to a specified key range $[k_{\\min}, k_{\\max}]$.\n\nThe specified requirements lead directly to an adaptation of the **Counting Sort** algorithm. Standard Counting Sort is designed for integers in a known, bounded range. To satisfy the problem's constraints, we must generalize it to handle arbitrary record types, ensure stability, and manage a key range $[k_{\\min}, k_{\\max}]$ that may include negative numbers.\n\nThe validation and sorting procedure for a given input sequence $S$ of length $n$ and key range $[k_{\\min}, k_{\\max}]$ proceeds in the following steps.\n\n**Step 1: Input Validation (Key Range Check)**\nThis is a prerequisite for sorting. The algorithm must first iterate through the input sequence $S$ to ensure all record keys fall within the specified closed interval $[k_{\\min}, k_{\\max}]$.\nLet $x$ be a record in $S$, and let $K(x)$ be its integer key. We must verify that for all $x \\in S$, the condition $k_{\\min} \\le K(x) \\le k_{\\max}$ holds. If this condition is violated for any record, the test case is deemed invalid, and the process for that case terminates with a `false` result.\n\n**Step 2: Algorithm Design - Stable Counting Sort**\n\nIf the input is valid, we proceed with a stable variant of Counting Sort. The core idea is to use an auxiliary array to store the counts of each key, and then use these counts to determine the correct position of each record in the final sorted sequence. To handle an arbitrary integer range $[k_{\\min}, k_{\\max}]$, we map the keys to zero-based indices.\n\nLet the size of the key domain be $L = k_{\\max} - k_{\\min} + 1$. We will use an auxiliary `counts` array of size $L$. A key $k$ from the input will map to an index $i = k - k_{\\min}$ in this array.\n\n**2a. Frequency Counting**\nWe create a `counts` array of size $L$, initialized with all zeros. We then iterate through the input sequence $S$. For each record $x$, we increment the count corresponding to its key $K(x)$.\n`counts[K(x) - k_{min}] \\leftarrow counts[K(x) - k_{min}] + 1`\n\nAfter this phase, `counts[i]` stores the number of records with key $k = i + k_{\\min}$.\n\n**2b. Cumulative Position Calculation (Prefix Sum)**\nTo determine the final positions, we transform the `counts` array into a structure that stores the position of the *end* of each key group. This is achieved by computing a prefix sum.\n`for i from 1 to L-1:`\n  `counts[i] \\leftarrow counts[i] + counts[i-1]`\n\nAfter this transformation, `counts[i]` holds the total number of records with keys less than or equal to $k = i + k_{\\min}$. This value corresponds to the index *one past* the last position for a record with key $k$ in the sorted output. For example, if `counts[i] = 5`, it means records with key $k=i+k_{\\min}$ should occupy indices up to $4$.\n\n**2c. Output Placement and Stability**\nWe create a new output sequence $S'$ of the same size $n$ as the input $S$. To ensure stability, we must place records into $S'$ by iterating through the original input sequence $S$ in **reverse order**, from index $n-1$ down to $0$.\n\nFor each record $x_j$ (at index $j$ in $S$) processed in reverse order:\n1. Extract its key $k = K(x_j)$.\n2. Compute the corresponding index in the `counts` array: $i = k - k_{\\min}$.\n3. The starting position for this record in the output sequence is given by `counts[i] - 1`.\n4. Place the record $x_j$ into the output sequence: $S'[counts[i] - 1] \\leftarrow x_j$.\n5. Decrement the count for that key: `counts[i] \\leftarrow counts[i] - 1$. This ensures that the next record encountered with the same key (which must have appeared earlier in the original sequence $S$) will be placed in the immediately preceding slot, thereby preserving their relative order.\n\nThis reverse-order placement is the critical mechanism that guarantees stability.\n\n**Step 3: Verification**\nAfter producing the sorted sequence $S'$, we must verify its correctness against the problem's criteria.\n\n**3a. Sortedness Verification**\nIterate through $S'$ from index $j = 0$ to $n-2$ and confirm that $K(S'[j]) \\le K(S'[j+1])$ for all $j$. A single violation invalidates the result.\n\n**3b. Stability Verification**\nTo verify stability, we must confirm that the relative order of records with identical keys is preserved. This can be done by:\n1. For each distinct key value $k$ present in the input, extract the subsequence of identifiers of records from $S$ that have this key. Let this be $ID_{orig}(k)$.\n2. Similarly, for each key value $k$, extract the subsequence of identifiers from the sorted output $S'$ that have this key. Let this be $ID_{sorted}(k)$.\n3. The sort is stable if and only if $ID_{orig}(k) = ID_{sorted}(k)$ for all key values $k$.\n\nIf the initial range check, the sortedness check, and the stability check all pass, the result for the test case is `true`. Otherwise, it is `false`. For an empty input sequence, all checks pass vacuously, resulting in `true`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and verify test cases for the stable counting sort.\n    \"\"\"\n\n    # Record is represented as a dictionary: {'id': int, 'key': int, 'payload': str}\n    \n    # Test case 1 (general case with duplicates and multiple keys, happy path)\n    s1 = [\n        {'id': 0, 'key': 3, 'payload': 'a'}, {'id': 1, 'key': 1, 'payload': 'b'},\n        {'id': 2, 'key': 2, 'payload': 'c'}, {'id': 3, 'key': 1, 'payload': 'd'},\n        {'id': 4, 'key': 3, 'payload': 'e'}, {'id': 5, 'key': 0, 'payload': 'f'},\n        {'id': 6, 'key': 2, 'payload': 'g'}, {'id': 7, 'key': 0, 'payload': 'h'},\n        {'id': 8, 'key': 3, 'payload': 'i'}\n    ]\n    r1 = (0, 3)\n\n    # Test case 2 (all keys equal, tests pure stability)\n    s2 = [\n        {'id': 0, 'key': 5, 'payload': 'x'}, {'id': 1, 'key': 5, 'payload': 'y'},\n        {'id': 2, 'key': 5, 'payload': 'z'}\n    ]\n    r2 = (5, 5)\n\n    # Test case 3 (negative to positive keys, boundary coverage)\n    s3 = [\n        {'id': 0, 'key': -3, 'payload': 'a'}, {'id': 1, 'key': -1, 'payload': 'b'},\n        {'id': 2, 'key': -3, 'payload': 'c'}, {'id': 3, 'key': 0, 'payload': 'd'},\n        {'id': 4, 'key': 2, 'payload': 'e'}, {'id': 5, 'key': -1, 'payload': 'f'}\n    ]\n    r3 = (-3, 2)\n\n    # Test case 4 (empty sequence, edge case)\n    s4 = []\n    r4 = (0, 0)\n    \n    # Test case 5 (invalid due to out-of-range key, error detection)\n    s5 = [\n        {'id': 0, 'key': 0, 'payload': 'a'}, {'id': 1, 'key': 10, 'payload': 'b'},\n        {'id': 2, 'key': 5, 'payload': 'c'}\n    ]\n    r5 = (0, 5)\n\n    # Test case 6 (non-contiguous keys with gaps in the key domain)\n    s6 = [\n        {'id': 0, 'key': 4, 'payload': 'a'}, {'id': 1, 'key': 0, 'payload': 'b'},\n        {'id': 2, 'key': 4, 'payload': 'c'}, {'id': 3, 'key': 2, 'payload': 'd'},\n        {'id': 4, 'key': 2, 'payload': 'e'}, {'id': 5, 'key': 0, 'payload': 'f'}\n    ]\n    r6 = (0, 4)\n\n    test_cases = [\n        (s1, r1), (s2, r2), (s3, r3), (s4, r4), (s5, r5), (s6, r6)\n    ]\n\n    results = []\n    for sequence, key_range in test_cases:\n        result = run_and_verify(sequence, key_range)\n        results.append(str(result).lower()) # Python bools are Capitalized\n\n    print(f\"[{','.join(results)}]\")\n\ndef stable_counting_sort(sequence, k_min, k_max):\n    \"\"\"\n    Implements a stable counting sort for a sequence of records.\n    Assumes keys have already been validated to be within the range [k_min, k_max].\n    \"\"\"\n    n = len(sequence)\n    if n == 0:\n        return []\n\n    range_size = k_max - k_min + 1\n    counts = np.zeros(range_size, dtype=int)\n    \n    # 1. Frequency Counting\n    for record in sequence:\n        key = record['key']\n        counts[key - k_min] += 1\n\n    # 2. Cumulative Position Calculation\n    for i in range(1, range_size):\n        counts[i] += counts[i-1]\n\n    # 3. Output Placement\n    output = [None] * n\n    for i in range(n - 1, -1, -1):\n        record = sequence[i]\n        key = record['key']\n        \n        pos_index = key - k_min\n        output_pos = counts[pos_index] - 1\n        \n        output[output_pos] = record\n        counts[pos_index] -= 1\n        \n    return output\n\ndef run_and_verify(sequence, key_range):\n    \"\"\"\n    Runs the sorting and verifies sortedness, stability, and key range constraints.\n    Returns a single boolean indicating if all criteria are met.\n    \"\"\"\n    k_min, k_max = key_range\n    \n    # 1. Key Range Validation\n    for record in sequence:\n        if not (k_min = record['key'] = k_max):\n            return False\n\n    # Handle empty sequence edge case\n    if not sequence:\n        return True\n\n    # Get sorted sequence\n    sorted_sequence = stable_counting_sort(list(sequence), k_min, k_max)\n    \n    # 2. Sortedness Verification\n    for i in range(len(sorted_sequence) - 1):\n        if sorted_sequence[i]['key']  sorted_sequence[i+1]['key']:\n            return False\n            \n    # 3. Stability Verification\n    original_order = defaultdict(list)\n    for record in sequence:\n        original_order[record['key']].append(record['id'])\n        \n    sorted_order = defaultdict(list)\n    for record in sorted_sequence:\n        sorted_order[record['key']].append(record['id'])\n        \n    for key in original_order:\n        if original_order[key] != sorted_order[key]:\n            return False\n            \n    # All checks passed\n    return True\n\nsolve()\n```", "id": "3273671"}]}