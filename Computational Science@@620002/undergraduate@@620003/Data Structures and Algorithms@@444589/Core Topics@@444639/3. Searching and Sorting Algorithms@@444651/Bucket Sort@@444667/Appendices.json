{"hands_on_practices": [{"introduction": "The core principle of bucket sort is mapping values from a given domain into a discrete set of buckets. This exercise challenges you to apply this principle beyond simple real numbers to the two-dimensional domain of complex numbers [@problem_id:3219470]. You will design a mapping based on fundamental properties like modulus ($|z|$) and argument ($\\theta(z)$), reinforcing your understanding of how to construct a valid bucketization scheme for any ordered data structure.", "problem": "You are asked to design and implement a generalization of bucket sort that can order complex numbers using a user-chosen mapping function grounded in the standard definitions of complex modulus and complex argument. The implementation must be a complete, runnable program. The target audience is an advanced undergraduate in data structures and algorithms.\n\nStart from the following fundamental base:\n- A complex number $z \\in \\mathbb{C}$ can be written as $z = x + iy$, where $x = \\Re(z)$ and $y = \\Im(z)$.\n- The modulus (magnitude) of $z$ is $|z| = \\sqrt{x^2 + y^2}$.\n- The principal argument of $z$ is $\\operatorname{Arg}(z) \\in (-\\pi, \\pi]$; the normalized argument is $\\theta(z) \\in [0, 2\\pi)$ defined by $\\theta(z) = \\operatorname{Arg}(z)$ if $\\operatorname{Arg}(z) \\ge 0$, and $\\theta(z) = \\operatorname{Arg}(z) + 2\\pi$ otherwise. The angle unit is radians.\n\nDefine a generalized bucket sort that:\n- Accepts a finite list of complex numbers $\\{z_1, z_2, \\dots, z_n\\}$.\n- Accepts a mapping choice $m(\\cdot)$ that is either the modulus $m(z) = |z|$ or the normalized argument $m(z) = \\theta(z)$.\n- Given an integer number of buckets $B \\in \\mathbb{Z}_{\\ge 1}$, assigns each element to one of $B$ buckets using a derivable linear scaling. For modulus-based mapping, assume a finite known range $[r_{\\min}, r_{\\max}]$ with $0 \\le r_{\\min}  r_{\\max}$ and $r_{\\max}  0$, and derive a linear scaling function $\\phi: [r_{\\min}, r_{\\max}] \\to [0, B)$ so that the bucket index is $b(z) = \\lfloor \\phi(m(z)) \\rfloor$. For argument-based mapping, the known range is $[0, 2\\pi)$, and bucket index is $b(z) = \\lfloor \\phi(m(z)) \\rfloor$ for your derived appropriate $\\phi$.\n- Handles the special case $z = 0$ in a scientifically consistent way: for modulus-based mapping, $m(0) = 0$ is in range; for argument-based mapping, the argument is undefined, and by convention you must assign $z = 0$ to bucket index $0$.\n- Within each bucket, produces a deterministic order by applying a secondary key to break ties. Use $\\theta(z)$ as the secondary key when $m(z) = |z|$, and use $|z|$ as the secondary key when $m(z) = \\theta(z)$. The final global ordering is by bucket index in ascending order, followed by the secondary key in ascending order.\n\nYou must implement the algorithm without using any external input. The mapping and bucketization must be derived from the stated fundamental definitions; do not rely on shortcut formulas beyond those derivable from the base definitions. The program must execute the following test suite and produce a single consolidated output line. All angles must be in radians. There are no physical units required beyond radians for angles.\n\nTest suite:\n- Case $1$ (happy path, modulus-based): $B = 5$, $r_{\\min} = 0$, $r_{\\max} = 5$, numbers $[3 + 4i,\\,-1 + 0.5i,\\,0 + 0i,\\,2 - 2i,\\,-3 - 4i]$.\n- Case $2$ (boundary conditions, argument-based): $B = 8$, numbers $[1 + 0i,\\,-1 + 0i,\\,0 - 1i,\\,0 + 1i,\\,0 + 0i,\\,1 - 1i,\\,-1 + 1i]$.\n- Case $3$ (edge case, many items in one bucket, modulus-based): $B = 3$, $r_{\\min} = 0$, $r_{\\max} = 1$, numbers $[0.1 + 0.2i,\\,-0.1 - 0.2i,\\,0.2 - 0.1i,\\,0 + 0i]$.\n\nAnswer specification:\n- For each case, output the final ordered list of complex numbers encoded as a list of pairs $[\\Re(z), \\Im(z)]$, where each pair is a list of two real numbers. For example, $z = 3 + 4i$ is encoded as $[3.0, 4.0]$.\n- Your program should produce a single line of output containing the results for all cases as a comma-separated list enclosed in square brackets. The outer list contains three elements (one per case), each of which is a list of pairs. For example, the format is $[ \\text{result}_1, \\text{result}_2, \\text{result}_3 ]$, where each $\\text{result}_k$ is a list of pairs $[\\Re(z), \\Im(z)]$.\n\nYour program must be complete, runnable, and produce the exact single-line output in the specified format. No user input is allowed.", "solution": "The problem is valid. It presents a well-posed algorithmic design challenge grounded in standard mathematical definitions and computer science principles. It is self-contained, objective, and its requirements are internally consistent. We may, therefore, proceed with a formal solution.\n\nThe task is to design a generalized bucket sort algorithm for a list of complex numbers, $\\{z_1, z_2, \\dots, z_n\\}$. The sorting is based on a primary key, which is a user-selected mapping $m(z)$, and ties are broken by a secondary key.\n\nFirst, we establish the necessary mathematical functions based on the provided definitions. A complex number is $z = x + iy$, where $x, y \\in \\mathbb{R}$.\nThe primary mappings are the modulus, $|z| = \\sqrt{x^2 + y^2}$, and the normalized argument, $\\theta(z)$. The normalized argument $\\theta(z)$ is defined in the range $[0, 2\\pi)$. It is derived from the principal argument, $\\operatorname{Arg}(z) \\in (-\\pi, \\pi]$, which is the angle of the vector $(x,y)$ with the positive real axis. The relationship is:\n$$\n\\theta(z) = \\begin{cases} \\operatorname{Arg}(z)  \\text{if } \\operatorname{Arg}(z) \\ge 0 \\\\ \\operatorname{Arg}(z) + 2\\pi  \\text{if } \\operatorname{Arg}(z)  0 \\end{cases}\n$$\nFor the special case $z = 0$, the argument is mathematically undefined. The problem provides conventions for this case:\n1.  For argument-based sorting, $z=0$ is assigned to bucket index $0$.\n2.  For modulus-based sorting, where $\\theta(z)$ is a secondary key, we need a deterministic value. The natural choice, consistent with the limit of $\\theta(x+0i)$ as $x \\to 0^+$, is to define $\\theta(0) = 0$.\n\nThe core of bucket sort is the distribution of elements into $B$ buckets, where $B \\in \\mathbb{Z}_{\\ge 1}$. This requires a function that maps the range of the primary key values to the bucket indices $\\{0, 1, \\dots, B-1\\}$. The problem specifies a linear scaling function $\\phi$ and a bucket index formula $b(z) = \\lfloor \\phi(m(z)) \\rfloor$.\n\nLet's derive the scaling function for each mapping type.\n\nCase 1: Modulus-based mapping, $m(z) = |z|$.\nThe values of $|z|$ are known to be within a range $[r_{\\min}, r_{\\max}]$, where $0 \\le r_{\\min}  r_{\\max}$. We need to map this value range to $B$ buckets. We can partition the value range into $B$ equal sub-intervals. The width of each sub-interval is $w = (r_{\\max} - r_{\\min}) / B$. A value $v = |z|$ falls into bucket $k$ if it is in the $k$-th sub-interval, which is $[r_{\\min} + k \\cdot w, r_{\\min} + (k+1) \\cdot w)$.\nThis condition is equivalent to $k \\cdot w \\le v - r_{\\min}  (k+1) \\cdot w$, which implies $k \\le \\frac{v - r_{\\min}}{w}  k+1$.\nTaking the floor gives the bucket index $k = \\lfloor \\frac{v - r_{\\min}}{w} \\rfloor$. Substituting for $w$, we get:\n$$\nb(z) = \\left\\lfloor B \\cdot \\frac{|z| - r_{\\min}}{r_{\\max} - r_{\\min}} \\right\\rfloor\n$$\nThis formula is valid for $|z| \\in [r_{\\min}, r_{\\max})$. For the boundary case $|z| = r_{\\max}$, the formula yields $\\lfloor B \\rfloor = B$, which is an out-of-bounds index. The standard convention is to place any value equal to or greater than $r_{\\max}$ into the final bucket, $B-1$. Thus, the robust bucket index formula is:\n$$\nb(z) = \\min\\left(\\left\\lfloor B \\cdot \\frac{|z| - r_{\\min}}{r_{\\max} - r_{\\min}} \\right\\rfloor, B-1\\right)\n$$\nThis handles all values $|z| \\ge r_{\\min}$. Values $|z|  r_{\\min}$ would yield a negative index and are assumed not to occur, or they can be placed in bucket $0$.\n\nCase 2: Argument-based mapping, $m(z) = \\theta(z)$.\nThe value range for the normalized argument $\\theta(z)$ is $[0, 2\\pi)$ for any $z \\neq 0$. Following the same logic as above, we have a range of length $2\\pi$. The width of each bucket's value range is $w = 2\\pi/B$. The bucket index for a value $v = \\theta(z)$ is:\n$$\nb(z) = \\left\\lfloor \\frac{\\theta(z)}{w} \\right\\rfloor = \\left\\lfloor \\frac{\\theta(z)}{2\\pi/B} \\right\\rfloor = \\left\\lfloor B \\cdot \\frac{\\theta(z)}{2\\pi} \\right\\rfloor\n$$\nSince $\\theta(z)$ is in the half-open interval $[0, 2\\pi)$, the term $B \\cdot \\frac{\\theta(z)}{2\\pi}$ is in $[0, B)$. The floor of this value will always be in the valid index range $\\{0, 1, \\dots, B-1\\}$. No special clamping for the upper bound is needed. As per the problem, $z=0$ is a special case assigned directly to bucket $0$.\n\nThe overall sorting algorithm is as follows:\n1.  Initialize $B$ empty lists (buckets).\n2.  Iterate through each complex number $z$ in the input list:\n    a.  Determine the mapping type (modulus or argument).\n    b.  If argument-based and $z=0$, place $z$ in bucket $0$.\n    c.  Otherwise, calculate the primary key value $m(z)$.\n    d.  Use the appropriate derived formula to calculate the bucket index $b(z)$.\n    e.  Append $z$ to the list at `buckets[b(z)]`.\n3.  Iterate through each bucket from index $0$ to $B-1$:\n    a.  Sort the elements within the bucket. The sort key is the secondary key:\n        i.  If the primary mapping was modulus, sort by normalized argument $\\theta(z)$ in ascending order.\n        ii. If the primary mapping was argument, sort by modulus $|z|$ in ascending order.\n4.  Concatenate the sorted buckets in sequence to produce the final sorted list of complex numbers.\nThis procedure ensures a deterministic and correct ordering according to the specified rules.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite for the generalized bucket sort.\n    \"\"\"\n\n    def normalized_argument(z: complex) - float:\n        \"\"\"\n        Calculates the normalized argument of a complex number in the range [0, 2*pi).\n        By convention, the argument of 0 is 0.\n        \"\"\"\n        if z == 0:\n            return 0.0\n        angle = np.angle(z)\n        return angle if angle = 0 else angle + 2 * np.pi\n\n    def generalized_bucket_sort(\n        numbers: list[complex],\n        B: int,\n        map_type: str,\n        r_min: float | None = None,\n        r_max: float | None = None\n    ) - list[complex]:\n        \"\"\"\n        Sorts a list of complex numbers using a generalized bucket sort algorithm.\n\n        Args:\n            numbers: The list of complex numbers to sort.\n            B: The number of buckets.\n            map_type: 'modulus' or 'argument', the primary sorting key.\n            r_min: The minimum value of the range for modulus sorting.\n            r_max: The maximum value of the range for modulus sorting.\n\n        Returns:\n            The sorted list of complex numbers.\n        \"\"\"\n        if B  1:\n            raise ValueError(\"Number of buckets B must be at least 1.\")\n\n        buckets: list[list[complex]] = [[] for _ in range(B)]\n\n        if map_type == 'modulus':\n            if r_min is None or r_max is None or r_max = r_min:\n                raise ValueError(\"A valid range [r_min, r_max] must be provided for modulus mapping.\")\n            \n            range_len = r_max - r_min\n            for z in numbers:\n                val = np.abs(z)\n                if val  r_min:\n                    b_index = 0\n                elif val = r_max:\n                    b_index = B - 1\n                else:\n                    # Scale to [0, B) and take the floor.\n                    b_index = int(B * (val - r_min) / range_len)\n                    # The index should be clamped to B-1, although int() on scaling for val  r_max\n                    # will not exceed B-1. This is for robustness.\n                    b_index = min(b_index, B - 1)\n                \n                buckets[b_index].append(z)\n\n            # Sort each bucket using the secondary key (normalized argument)\n            for i in range(B):\n                buckets[i].sort(key=normalized_argument)\n\n        elif map_type == 'argument':\n            for z in numbers:\n                if z == 0:\n                    # Special case for z=0 as per problem description\n                    b_index = 0\n                else:\n                    val = normalized_argument(z)\n                    # Scale to [0, B) and take the floor\n                    b_index = int(B * val / (2 * np.pi))\n                    # Clamp index for robustness, though should not be necessary for arg in [0, 2*pi)\n                    b_index = min(b_index, B - 1)\n                \n                buckets[b_index].append(z)\n            \n            # Sort each bucket using the secondary key (modulus)\n            for i in range(B):\n                buckets[i].sort(key=np.abs)\n\n        else:\n            raise ValueError(f\"Invalid map_type: {map_type}. Must be 'modulus' or 'argument'.\")\n\n        # Concatenate buckets to get the final sorted list\n        sorted_list = []\n        for bucket in buckets:\n            sorted_list.extend(bucket)\n            \n        return sorted_list\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"params\": {\n                \"numbers\": [3+4j, -1+0.5j, 0+0j, 2-2j, -3-4j],\n                \"B\": 5, \"map_type\": \"modulus\", \"r_min\": 0.0, \"r_max\": 5.0\n            }\n        },\n        {\n            \"name\": \"Case 2\",\n            \"params\": {\n                \"numbers\": [1+0j, -1+0j, 0-1j, 0+1j, 0+0j, 1-1j, -1+1j],\n                \"B\": 8, \"map_type\": \"argument\"\n            }\n        },\n        {\n            \"name\": \"Case 3\",\n            \"params\": {\n                \"numbers\": [0.1+0.2j, -0.1-0.2j, 0.2-0.1j, 0+0j],\n                \"B\": 3, \"map_type\": \"modulus\", \"r_min\": 0.0, \"r_max\": 1.0\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        sorted_numbers = generalized_bucket_sort(**case[\"params\"])\n        # Format the result into a list of [Re, Im] pairs\n        formatted_result = [[z.real, z.imag] for z in sorted_numbers]\n        results.append(str(formatted_result))\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list is used, as it matches the specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3219470"}, {"introduction": "A key limitation of naive bucket sort is its performance degradation when data is not uniformly distributed. This practice tackles this challenge head-on by having you build an adaptive algorithm that learns from the data itself [@problem_id:3219485]. By constructing a mapping function based on an empirical cumulative distribution function (ECDF), you will create a more robust sort that can handle real-world clustered data efficiently.", "problem": "You are given the task to design and implement a bucket sort algorithm whose bucket assignment mapping function is learned from a deterministic sample of the input data to optimize bucket population balance. The algorithm must be derived from the following fundamental base: the definition of sorting, the principle of partitioning in bucket sort, and the construction and properties of an empirical cumulative distribution function (empirical CDF). The problem is to reason from these foundations to a complete algorithm for bucket sort with learned mapping and then implement it.\n\nLet an input array be denoted by $A = [a_1, a_2, \\dots, a_n]$ with length $n$. The sorting task is to produce an array $A^{\\mathrm{sorted}} = [a_{(1)}, a_{(2)}, \\dots, a_{(n)}]$ such that $a_{(1)} \\le a_{(2)} \\le \\dots \\le a_{(n)}$. In bucket sort, the high-level plan is to select a number of buckets $B \\in \\mathbb{N}$ with $B \\ge 1$, define a mapping function $g : \\mathbb{R} \\to \\{0, 1, \\dots, B-1\\}$ to assign each element $x \\in A$ to a bucket index $g(x)$, sort the elements within each bucket, and concatenate the buckets in increasing index order to produce $A^{\\mathrm{sorted}}$.\n\nThe mapping function $g$ is unknown a priori and must be learned from a sample of the data. The principle is that if one had access to the true cumulative distribution function $F(x) = \\mathbb{P}(X \\le x)$ of the data-generating process for $A$ where $X$ is a real-valued random variable, then mapping $x$ to a bucket according to quantiles can equalize expected bucket counts. Since $F$ is unknown, we estimate it using the empirical cumulative distribution function constructed from a deterministic sample $S$ of size $s$, where $1 \\le s \\le n$. The deterministic sample $S$ must be selected by evenly spaced indices across $A$, specifically\n$$\n\\text{if } s = 1,\\ \\ \\text{indices} = [0];\\quad \\text{if } s \\ge 2,\\ \\ \\text{indices} = \\left[\\, \\left\\lfloor \\frac{i \\cdot (n-1)}{s-1} \\right\\rfloor \\ :\\ i = 0, 1, \\dots, s-1 \\right].\n$$\nThen $S$ is formed by $S_i = a_{\\text{indices}[i]}$ for $i=0,1,\\dots,s-1$. The empirical cumulative distribution function is defined as\n$$\n\\hat{F}(x) = \\frac{1}{s}\\sum_{i=1}^{s} \\mathbf{1}\\{S_i \\le x\\},\n$$\nwhere $\\mathbf{1}\\{\\cdot\\}$ is the indicator function. The learned mapping function is then\n$$\ng(x) = \\min\\left( B - 1, \\left\\lfloor B \\cdot \\hat{F}(x) \\right\\rfloor \\right),\n$$\nwhich assigns each $x$ to a bucket index in $\\{0,1,\\dots,B-1\\}$. Sorting is performed independently within each bucket (in nondecreasing order), and the final output is the concatenation of all buckets in increasing index order.\n\nYour program must implement this bucket sort algorithm with the above deterministic sampling rule and empirical cumulative distribution function mapping. It must handle general real numbers, including negative values, zero, duplicates, and large magnitude outliers. Within each bucket, use a stable comparison-based sorting method to ensure the final order is nondecreasing.\n\nTest Suite and Parameter Specification:\nImplement and run the algorithm on the following test cases. For each test case, the parameters are the input array $A$, the number of buckets $B$, and the sample size $s$. In cases where $s  n$, use $s' = \\min(s, n)$ (that is, cap the sample size at the array length). All numbers and arrays are to be treated as dimensionless real numbers.\n\n- Test case $1$: $A = [\\, 0.15,\\, 0.85,\\, 0.40,\\, 0.01,\\, 0.99,\\, 0.75,\\, 0.50 \\,]$, $B = 3$, $s = 4$.\n- Test case $2$: $A = [\\, 5,\\, 5,\\, 5,\\, 5 \\,]$, $B = 5$, $s = 3$.\n- Test case $3$: $A = [\\, -10,\\, -0.5,\\, -3.3,\\, 2,\\, 0,\\, -1,\\, 8.8 \\,]$, $B = 4$, $s = 5$.\n- Test case $4$: $A = [\\, 1000,\\, -1000,\\, 10,\\, -10,\\, 0,\\, 0.1,\\, -0.1,\\, 500,\\, -500 \\,]$, $B = 6$, $s = 7$.\n- Test case $5$: $A = [\\, 1 \\,]$, $B = 1$, $s = 1$.\n- Test case $6$: $A = [\\, 3,\\, 1,\\, 4,\\, 1,\\, 5 \\,]$, $B = 4$, $s = 10$.\n\nRequired Final Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result is the fully sorted array for the corresponding test case. For example, the outer format must be $[\\,\\text{result}_1, \\text{result}_2, \\dots \\,]$, where each $\\text{result}_i$ is a list of numbers. No additional text or lines should be printed.", "solution": "The problem statement is subjected to validation against the established criteria.\n\n### Step 1: Extract Givens\n- **Input Array**: An array $A = [a_1, a_2, \\dots, a_n]$ of length $n$.\n- **Number of Buckets**: $B \\in \\mathbb{N}$ with $B \\ge 1$.\n- **Sample Size**: $s$, with $1 \\le s \\le n$. A provision is made: if the provided $s  n$, use $s' = \\min(s, n)$.\n- **Sorting Definition**: Produce an array $A^{\\mathrm{sorted}} = [a_{(1)}, a_{(2)}, \\dots, a_{(n)}]$ such that $a_{(1)} \\le a_{(2)} \\le \\dots \\le a_{(n)}$.\n- **Bucket Sort Principle**: Partition elements into $B$ buckets using a mapping function $g$, sort each bucket, and concatenate the sorted buckets.\n- **Deterministic Sampling Rule**: The sample $S$ of size $s$ is formed from elements of $A$ at specific indices.\n  - If $s = 1$, indices = $[0]$.\n  - If $s \\ge 2$, indices = $\\left[\\, \\left\\lfloor \\frac{i \\cdot (n-1)}{s-1} \\right\\rfloor \\ :\\ i = 0, 1, \\dots, s-1 \\right]$.\n- **Empirical CDF Definition**: $\\hat{F}(x) = \\frac{1}{s}\\sum_{i=1}^{s} \\mathbf{1}\\{S_i \\le x\\}$, where $\\mathbf{1}\\{\\cdot\\}$ is the indicator function.\n- **Mapping Function Definition**: $g(x) = \\min\\left( B - 1, \\left\\lfloor B \\cdot \\hat{F}(x) \\right\\rfloor \\right)$.\n- **Internal Sorting**: Buckets are to be sorted using a stable comparison-based method.\n- **Test Cases**:\n  1. $A = [\\, 0.15,\\, 0.85,\\, 0.40,\\, 0.01,\\, 0.99,\\, 0.75,\\, 0.50 \\,]$, $B = 3$, $s = 4$.\n  2. $A = [\\, 5,\\, 5,\\, 5,\\, 5 \\,]$, $B = 5$, $s = 3$.\n  3. $A = [\\, -10,\\, -0.5,\\, -3.3,\\, 2,\\, 0,\\, -1,\\, 8.8 \\,]$, $B = 4$, $s = 5$.\n  4. $A = [\\, 1000,\\, -1000,\\, 10,\\, -10,\\, 0,\\, 0.1,\\, -0.1,\\, 500,\\, -500 \\,]$, $B = 6$, $s = 7$.\n  5. $A = [\\, 1 \\,]$, $B = 1$, $s = 1$.\n  6. $A = [\\, 3,\\, 1,\\, 4,\\, 1,\\, 5 \\,]$, $B = 4$, $s = 10$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated for validity.\n1.  **Scientifically Grounded**: The problem is well-grounded in the fields of computer science (algorithms) and statistics. Bucket sort is a standard sorting algorithm. The use of an empirical cumulative distribution function ($\\hat{F}(x)$) to approximate an unknown true data distribution $F(x)$ is a fundamental technique in non-parametric statistics. The proposed mapping function $g(x)$ is a direct application of this principle, aiming to partition the data domain into segments of roughly equal probability mass, thereby balancing bucket sizes. All mathematical definitions are standard and correct.\n2.  **Well-Posed**: The problem is specified with high precision. All inputs ($A$, $B$, $s$), intermediate constructs (sampling rule, $\\hat{F}(x)$, $g(x)$), and procedures (bucketing, internal sort, concatenation) are defined unambiguously. The edge cases $s=1$ and $sn$ are explicitly handled. This structure guarantees that a unique and meaningful sorted array can be produced for any valid input.\n3.  **Objective**: The problem is stated in objective, mathematical language, free of any subjective or opinion-based assertions.\n\nThe problem does not exhibit any of the invalidity flaws. It is scientifically sound, formally specified, complete, consistent, and solvable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. Proceeding with the derivation of the solution.\n\n### Algorithmic Derivation from First Principles\nThe task is to derive and implement a bucket sort algorithm where the bucket mapping is learned from the data. The derivation follows from the provided foundational principles.\n\n**1. The Goal: Sorting**\nThe fundamental objective is to transform an input array $A=[a_1, \\dots, a_n]$ into a permutation $A^{\\mathrm{sorted}}=[a_{(1)}, \\dots, a_{(n)}]$ where $a_{(1)} \\le a_{(2)} \\le \\dots \\le a_{(n)}$.\n\n**2. The Strategy: Bucket Sort**\nThe bucket sort algorithm partitions the sorting problem. It involves three primary stages:\n- **Partition**: Distribute the $n$ elements of $A$ into $B$ ordered containers, or buckets, based on a mapping function $g(x)$.\n- **Sort**: Sort the elements within each individual bucket.\n- **Concatenate**: Combine the sorted buckets in order to form the final sorted array.\nThe efficacy of bucket sort hinges on the quality of the mapping function $g(x)$. An ideal $g(x)$ would distribute elements uniformly across the buckets, making the sub-problems (sorting each bucket) of roughly equal and small size.\n\n**3. The Learned Mapping Function: $g(x)$**\nThe core of this problem lies in constructing $g(x)$. The principle is to use the data's distributional properties. If the true cumulative distribution function (CDF), $F(x) = \\mathbb{P}(X \\le x)$, were known, the function $F(x)$ would map values to the interval $[0, 1]$. Multiplying by $B$ and taking the floor, $g_{\\text{ideal}}(x) = \\lfloor B \\cdot F(x) \\rfloor$, would map elements to bucket indices $\\{0, 1, \\dots, B-1\\}$. For a continuous random variable $X$, $F(X)$ is uniformly distributed on $[0,1]$, so this mapping would, in expectation, perfectly balance the buckets.\n\nSince $F(x)$ is unknown, we must estimate it from the data. The problem specifies using the **empirical cumulative distribution function (ECDF)**, denoted $\\hat{F}(x)$. This is constructed from a deterministic sample $S$ drawn from the input array $A$. The ECDF is a non-parametric maximum likelihood estimate of the true CDF.\nThe algorithm proceeds as follows:\n\n**Step A: Sampling and Model Construction**\n   1.  Determine the effective sample size, $s_{\\text{eff}} = \\min(s, n)$, where $n$ is the length of $A$.\n   2.  Construct the deterministic sample $S$. An array of indices is first computed according to the rule:\n       - For $s_{\\text{eff}} = 1$, the index is $[0]$.\n       - For $s_{\\text{eff}} \\ge 2$, the indices are $\\left[\\left\\lfloor \\frac{i \\cdot (n-1)}{s_{\\text{eff}}-1} \\right\\rfloor\\right]$ for $i \\in \\{0, 1, \\dots, s_{\\text{eff}}-1\\}$.\n       The sample $S$ consists of the elements of $A$ at these computed indices.\n   3.  To facilitate the computation of $\\hat{F}(x)$, the sample $S$ is sorted into nondecreasing order, yielding $S^{\\text{sorted}}$.\n\n**Step B: Defining the Mapping and Partitioning**\n   1.  The ECDF, $\\hat{F}(x) = \\frac{1}{s_{\\text{eff}}}\\sum_{j=1}^{s_{\\text{eff}}} \\mathbf{1}\\{S_j \\le x\\}$, is implemented. For a given value $x$, the sum $\\sum \\mathbf{1}\\{S_j \\le x\\}$ is simply the count of elements in the sample $S$ that are less than or equal to $x$. This count can be found efficiently on $S^{\\text{sorted}}$ using a binary search algorithm, which has a time complexity of $O(\\log s_{\\text{eff}})$.\n   2.  The mapping function $g(x)$ is then given by $g(x) = \\min\\left( B - 1, \\left\\lfloor B \\cdot \\hat{F}(x) \\right\\rfloor \\right)$. The $\\min(B-1, \\dots)$ term ensures that even if $\\hat{F}(x)=1$, the resulting index $\\lfloor B \\cdot 1 \\rfloor = B$ is corrected to the maximum valid index $B-1$.\n   3.  An array of $B$ empty buckets is initialized. The input array $A$ is traversed, and for each element $a_i$, its bucket index $k = g(a_i)$ is computed, and $a_i$ is placed into bucket $k$.\n\n**Step C: Sorting and Concatenation**\n   1.  Each of the $B$ buckets is sorted independently. The problem mandates a stable sorting algorithm. This ensures that if $a_i = a_j$ for $i  j$, their relative order in the final sorted output is preserved. The stability of the overall algorithm is guaranteed because equal-valued elements will always map to the same bucket (since $g(x)$ is a function of value only), and the stable sort within that bucket maintains their original relative order.\n   2.  The final sorted array, $A^{\\mathrm{sorted}}$, is constructed by concatenating the sorted buckets in sequence, from bucket $0$ to bucket $B-1$.\n\nThis completes the derivation of the algorithm from the specified principles. The procedure is deterministic and produces a correctly sorted array.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests the bucket sort algorithm with a learned mapping function\n    based on an empirical cumulative distribution function (ECDF).\n    \"\"\"\n\n    test_cases = [\n        {'A': [0.15, 0.85, 0.40, 0.01, 0.99, 0.75, 0.50], 'B': 3, 's': 4},\n        {'A': [5, 5, 5, 5], 'B': 5, 's': 3},\n        {'A': [-10, -0.5, -3.3, 2, 0, -1, 8.8], 'B': 4, 's': 5},\n        {'A': [1000, -1000, 10, -10, 0, 0.1, -0.1, 500, -500], 'B': 6, 's': 7},\n        {'A': [1], 'B': 1, 's': 1},\n        {'A': [3, 1, 4, 1, 5], 'B': 4, 's': 10}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        A = case['A']\n        B = case['B']\n        s = case['s']\n\n        n = len(A)\n\n        if n == 0:\n            results.append([])\n            continue\n\n        # Step A.1: Determine the effective sample size\n        s_eff = min(s, n)\n\n        # Step A.2: Construct the deterministic sample S\n        if s_eff == 1:\n            indices = [0]\n        else:\n            indices_float = np.arange(s_eff) * (n - 1) / (s_eff - 1)\n            indices = np.floor(indices_float).astype(int)\n        \n        sample_S = [A[i] for i in indices]\n\n        # Step A.3: Sort the sample to facilitate ECDF computation\n        sorted_sample_S = sorted(sample_S)\n\n        # Step B.1-2: Define the ECDF-based mapping function g(x)\n        def get_bucket_index(x):\n            # Compute F_hat(x)\n            # Find count of elements in sample_S = x using binary search\n            # np.searchsorted(side='right') is equivalent to bisect_right\n            count_le_x = np.searchsorted(sorted_sample_S, x, side='right')\n            f_hat_x = count_le_x / s_eff\n            \n            # Compute bucket index using the learned mapping function\n            bucket_idx = int(B * f_hat_x)\n            \n            # Ensure index is within the valid range [0, B-1]\n            return min(B - 1, bucket_idx)\n\n        # Step B.3: Partition elements into buckets\n        buckets = [[] for _ in range(B)]\n        for element in A:\n            idx = get_bucket_index(element)\n            buckets[idx].append(element)\n\n        # Step C.1: Sort each bucket (using Python's stable Timsort)\n        for i in range(B):\n            buckets[i].sort()\n\n        # Step C.2: Concatenate sorted buckets\n        sorted_A = [element for bucket in buckets for element in bucket]\n        \n        results.append(sorted_A)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3219485"}, {"introduction": "This final practice delves into the intersection of algorithms and low-level data representation. Standard sorting comparisons fail for special IEEE 754 floating-point values such as NaN or Infinity, yet a total order is still defined for them [@problem_id:3219392]. Your task is to implement a bucket sort that respects this total order by devising a clever, order-preserving mapping from the 64-bit float representation to integer keys, a powerful technique for handling complex data types.", "problem": "Design and implement a modification of bucket sort that correctly orders IEEE 754 double-precision floating-point values, including the special values Not-a-Number (NaN), positive infinity, and negative infinity, according to the IEEE 754 total order. Your program must implement the following.\n\n1. Fundamental base and constraints. Begin from the core definitions:\n   - Bucket sort assumes a list of $n$ keys drawn from a domain that can be mapped into $B$ buckets such that keys are approximately evenly distributed across buckets. Within each bucket, a stable, comparison-based method (for example, insertion sort) is applied, and buckets are concatenated in order.\n   - IEEE 754 double-precision floating-point numbers classify into signed zeros, finite numbers, signed infinities, and NaNs. Standard comparison operators do not define a total order over these values because any comparison with NaN is unordered. However, the IEEE 754 standard specifies a total order that distinguishes $-0.0$ from $+0.0$, places $-\\infty$ before all finite numbers, places $+\\infty$ after all finite numbers but before all NaNs, and places all NaNs after $+\\infty$.\n\n2. Task. Devise a principled way to modify bucket sort so that:\n   - It sorts any finite and special double-precision values into the IEEE 754 total order without relying on floating-point comparisons that are undefined for NaN.\n   - The bucket assignment is performed on an order-preserving mapping of each floating-point value to an integer key that is totally ordered according to the IEEE 754 total order, and this integer key is used consistently for both bucket placement and in-bucket ordering.\n   - The algorithm is stable for values that are equal under the total order.\n   - Choose the number of buckets $B$ as $B=\\lceil \\sqrt{n} \\rceil$ for an input of size $n$.\n   - For bucket index calculation, if $k_{\\min}$ and $k_{\\max}$ are the minimum and maximum integer keys in the input, respectively, then each element with key $k$ must be placed into bucket index\n     $$\\left\\lfloor \\dfrac{(k - k_{\\min}) \\cdot B}{(k_{\\max} - k_{\\min}) + 1} \\right\\rfloor,$$\n     which guarantees an index in $\\{0,1,\\dots,B-1\\}$ even when all keys are equal.\n\n3. Output. For each test case, output the sorted list. Aggregate the results for all test cases into a single line of output containing the per-test-case results as a comma-separated list enclosed in square brackets, with no spaces. For example, for three test cases producing results $r_1$, $r_2$, and $r_3$, the program must print a single line in the exact format\n   - $[r_1,r_2,r_3]$,\n   where each $r_i$ is itself a list literal with elements printed using the language’s canonical floating-point literal forms, namely \"nan\" for NaN, \"inf\" for $+\\infty$, and \"-inf\" for $-\\infty$, and signed zeros as \"$-0.0$\" and \"$0.0$\".\n\n4. Test suite. Your program must hard-code and sort the following test arrays and output their sorted forms in the format specified above.\n   - Test A (happy path, mixture): $[3.0,\\ NaN,\\ $-\\infty$,\\ $+\\infty$,\\ 2.5,\\ -0.0,\\ 0.0,\\ -1.0,\\ 1.0\\times10^{-308},\\ -1.0\\times10^{-308},\\ 0.5]$.\n   - Test B (boundary with only specials): $[NaN,\\ $-\\infty$,\\ $+\\infty$]$.\n   - Test C (zeros and subnormals): $[-0.0,\\ 0.0,\\ 5.0\\times10^{-324},\\ -5.0\\times10^{-324}]$.\n   - Test D (extreme finite magnitudes): $[1.7976931348623157\\times10^{308},\\ -1.7976931348623157\\times10^{308},\\ 2.2250738585072014\\times10^{-308},\\ -2.2250738585072014\\times10^{-308}]$.\n\n5. Answer format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces, in the exact order of the tests A, B, C, D. Each per-test-case result must be a list literal in the same no-spaces format. The elements of each list must be printed as canonical literals: \"nan\" for NaN, \"inf\" for $+\\infty$, and \"-inf\" for $-\\infty$, and with signed zeros preserved.\n\nNo input should be read; the program must be fully self-contained and must only output the single required line.", "solution": "The problem requires the design and implementation of a modified bucket sort algorithm capable of sorting IEEE 754 double-precision floating-point numbers according to the `totalOrder` predicate defined in the standard. This order is specified as:\n$$-\\infty  \\dots  \\text{negative finite numbers}  -0.0  +0.0  \\text{positive finite numbers}  \\dots  +\\infty  \\text{NaNs}$$\nA standard comparison-based sort fails because any comparison involving Not-a-Number (NaN) is undefined. The core of the solution is to devise an order-preserving mapping from any double-precision float $x$ to a $64$-bit unsigned integer key, $k = f(x)$, such that for any two floats $x_1$ and $x_2$, $x_1  x_2$ under the `totalOrder` implies $f(x_1)  f(x_2)$. Bucket sort can then operate on these integer keys.\n\nThe principled design proceeds as follows:\n\n1.  **Integer Representation of Floating-Point Numbers**: An IEEE 754 double-precision float is stored as a $64$-bit value. We can reinterpret this bit pattern as a $64$-bit unsigned integer, let's call it $u$. This integer `u` consists of a sign bit (most significant bit, MSB), an $11$-bit exponent, and a $52$-bit fraction.\n\n    -   If the sign bit is $0$ (for positive numbers, $+0.0$, $+\\infty$, and positive NaNs), the numerical order of the floats corresponds directly to the integer order of their $u$ representations. For two such floats $x_1$ and $x_2$, if $x_1  x_2$, then $u_1  u_2$.\n    -   If the sign bit is $1$ (for negative numbers, $-0.0$, $-\\infty$, and negative NaNs), the numerical order is the reverse of the integer order of their $u$ representations. For two such floats $x_1$ and $x_2$, if $x_1  x_2$, then $u_1  u_2$. This is because the representation is sign-magnitude, where larger magnitudes (more negative numbers) result in larger integer representations when the MSB is $1$.\n\n2.  **Constructing the Order-Preserving Key Mapping**: To establish a single monotonic sequence of keys that respects the `totalOrder`, we map the floats to a $64$-bit unsigned integer key space. We can map all negative values to the lower half of the key space ($[0, 2^{63}-1]$) and all positive values to the upper half ($[2^{63}, 2^{64}-1]$).\n\n    -   **For a float $x$ with sign bit $1$ (negative value)**: The `uint64` representation $u$ is order-inverting. To correct this, we apply an order-reversing transformation. The bitwise NOT operation, $\\sim u$, which for a $64$-bit unsigned integer is equivalent to $(2^{64}-1) - u$, serves this purpose. For example, $u(-0.0) = 0x8000000000000000$ is mapped to $\\sim u = 0x7FFFFFFFFFFFFFFF$, while $u(-\\infty) = 0xFFF0000000000000$ is mapped to $\\sim u = 0x000FFFFFFFFFFFFF$. This correctly places $-\\infty$ at the low end of this key range and $-0.0$ at the high end.\n\n    -   **For a float $x$ with sign bit $0$ (positive value)**: The `uint64` representation $u$ is already order-preserving. To ensure these keys are greater than all keys from negative floats, we shift them into the upper half of the $64$-bit range. This is achieved by adding $2^{63}$ (i.e., $0x8000000000000000$) to $u$. For example, $u(+0.0)=0x0$ is mapped to $0x8000000000000000$, and $u(+\\infty)=0x7FF0000000000000$ is mapped to $0xFFF0000000000000$.\n\n    This mapping function, $f(x)$, is defined as:\n    $$\n    f(x) = \\begin{cases} (2^{64}-1) - u  \\text{if sign bit of } u \\text{ is } 1 \\\\ u + 2^{63}  \\text{if sign bit of } u \\text{ is } 0 \\end{cases}\n    $$\n    where $u$ is the $64$-bit unsigned integer representation of the float $x$. This function correctly establishes a total ordering on the integer keys that matches the IEEE 754 `totalOrder`, including the relative order of $-0.0$ and $+0.0$.\n\n3.  **Modified Bucket Sort Algorithm**:\n    -   **Step 1: Key Generation**: For each float $x_i$ in the input array of size $n$, compute its corresponding integer key $k_i = f(x_i)$. Store these as pairs $(k_i, x_i)$.\n    -   **Step 2: Bucket Initialization**: Find the minimum key, $k_{\\min}$, and maximum key, $k_{\\max}$, among all generated keys. The number of buckets, $B$, is set to $\\lceil \\sqrt{n} \\rceil$. Create $B$ empty buckets.\n    -   **Step 3: Distribution**: For each pair $(k, x)$, calculate its bucket index $j$ using the formula specified in the problem:\n      $$j = \\left\\lfloor \\dfrac{(k - k_{\\min}) \\cdot B}{(k_{\\max} - k_{\\min}) + 1} \\right\\rfloor$$\n      This formula ensures that the index $j$ is in the valid range $\\{0, 1, \\dots, B-1\\}$. The properties of Python's arbitrary-precision integers are leveraged for the numerator to prevent overflow during this calculation. Place the pair $(k, x)$ into bucket $j$.\n    -   **Step 4: In-Bucket Sorting**: Sort each bucket individually based on the integer key $k$. To adhere to the stability requirement, a stable sorting algorithm must be used. Insertion sort is a simple, stable algorithm suitable for this task, as the buckets are expected to be small and nearly sorted.\n    -   **Step 5: Concatenation**: Concatenate the sorted buckets in order from bucket $0$ to bucket $B-1$ to produce the final sorted sequence of pairs.\n    -   **Step 6: Final Result**: Extract the original float values from the sorted sequence of pairs to obtain the final sorted array. The entire process is stable because the key mapping is deterministic and the in-bucket sort is stable.\n\nThis principled approach correctly transforms a problem that is ill-defined for standard comparison operators into a well-defined integer sorting problem, which is then solved efficiently using bucket sort.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing a modified bucket sort for IEEE 754 doubles,\n    including special values, and printing the sorted results for the given test suite.\n    \"\"\"\n\n    def float_to_key(x: float) - np.uint64:\n        \"\"\"\n        Maps an IEEE 754 double-precision float to a 64-bit unsigned integer key\n        that preserves the IEEE 754 totalOrder.\n        \"\"\"\n        # Reinterpret the 64-bit float as a 64-bit unsigned integer.\n        u = np.float64(x).view(np.uint64)\n        \n        # Check the sign bit (the most significant bit).\n        if (u  63)  1:\n            # Negative floats (including -0.0, -inf, and negative NaNs).\n            # Their uint64 representation is in reverse of the desired totalOrder.\n            # Applying bitwise NOT (on 64 bits) reverses the order.\n            # In Python, ~u doesn't work as expected for uint64, so we simulate it.\n            return np.uint64((1  64) - 1) - u\n        else:\n            # Positive floats (including +0.0, +inf, and positive NaNs).\n            # Their uint64 representation is already in the correct relative order.\n            # We add 2**63 to shift them to the upper half of the uint64 range,\n            # ensuring all positive keys are greater than all negative keys.\n            return u + np.uint64(1  63)\n\n    def insertion_sort(bucket: list):\n        \"\"\"\n        Sorts a bucket (list of (key, value) tuples) in-place using insertion sort.\n        This is a stable sorting algorithm.\n        \"\"\"\n        for i in range(1, len(bucket)):\n            key_item = bucket[i]\n            j = i - 1\n            # Compare items based on their integer key (item[0]).\n            while j = 0 and bucket[j][0]  key_item[0]:\n                bucket[j + 1] = bucket[j]\n                j -= 1\n            bucket[j + 1] = key_item\n\n    def modified_bucket_sort(arr: list) - list:\n        \"\"\"\n        Sorts a list of floats using a modified bucket sort algorithm.\n        \"\"\"\n        n = len(arr)\n        if n = 1:\n            return arr\n        \n        # 1. Map floats to order-preserving integer keys.\n        keyed_arr = [(float_to_key(x), x) for x in arr]\n\n        # 2. Find min and max keys.\n        keys = [item[0] for item in keyed_arr]\n        k_min = min(keys)\n        k_max = max(keys)\n\n        # 3. Initialize buckets.\n        num_buckets = math.ceil(math.sqrt(n))\n        buckets = [[] for _ in range(num_buckets)]\n\n        # If all keys are the same, all items go to the first bucket.\n        if k_max == k_min:\n            denominator = np.uint64(1)\n        else:\n            denominator = k_max - k_min + np.uint64(1)\n        \n        # 4. Distribute items into buckets.\n        for item in keyed_arr:\n            k = item[0]\n            # Use Python's arbitrary-precision integers for the numerator to avoid overflow.\n            numerator = (int(k) - int(k_min)) * num_buckets\n            idx = numerator // int(denominator)\n            buckets[idx].append(item)\n            \n        # 5. Sort each bucket and concatenate the results.\n        sorted_arr = []\n        for bucket in buckets:\n            # Use a stable sort (insertion sort as specified).\n            insertion_sort(bucket)\n            sorted_arr.extend(bucket)\n            \n        # 6. Extract the original float values.\n        return [item[1] for item in sorted_arr]\n\n    def format_float(f: float) - str:\n        \"\"\"\n        Formats a float into the required string representation for special values.\n        \"\"\"\n        if np.isnan(f):\n            return \"nan\"\n        if np.isposinf(f):\n            return \"inf\"\n        if np.isneginf(f):\n            return \"-inf\"\n        if f == 0.0 and np.signbit(f):\n            return \"-0.0\"\n        return str(f)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A (happy path, mixture)\n        [3.0, np.nan, -np.inf, np.inf, 2.5, -0.0, 0.0, -1.0, 1.0e-308, -1.0e-308, 0.5],\n        # Test B (boundary with only specials)\n        [np.nan, -np.inf, np.inf],\n        # Test C (zeros and subnormals)\n        [-0.0, 0.0, 5.0e-324, -5.0e-324],\n        # Test D (extreme finite magnitudes)\n        [1.7976931348623157e+308, -1.7976931348623157e+308, 2.2250738585072014e-308, -2.2250738585072014e-308],\n    ]\n\n    results_str = []\n    for case in test_cases:\n        sorted_list = modified_bucket_sort(case)\n        formatted_list_str = \",\".join([format_float(x) for x in sorted_list])\n        results_str.append(f\"[{formatted_list_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3219392"}]}