{"hands_on_practices": [{"introduction": "Ternary search is classically taught for finding the peak of a unimodal function. However, its core principle of interval reduction is more versatile. This first exercise challenges you to adapt ternary search to solve a boundary-finding problem on a sorted array, specifically to locate the beginning of a \"plateau\" of equal values [@problem_id:3278839]. This practice will help you see search algorithms not as rigid recipes, but as flexible tools for problems with underlying monotonic properties.", "problem": "You are given a sorted array in nondecreasing order. Let the array be denoted by $A$, with length $n$, and indices taken from $0$ to $n-1$. The maximum value is $M = A[n-1]$. Because the array is sorted, all occurrences of $M$ form a contiguous block at the right end of the array. Define the plateau of equal maximum values as the set of indices $i$ such that $A[i] = M$. There exist unique integers $L$ and $R$ with $0 \\leq L \\leq R \\leq n-1$ such that for all $i$ with $L \\leq i \\leq R$, one has $A[i] = M$, and for all $i  L$, one has $A[i]  M$. Since $A$ is sorted nondecreasingly, it follows that $R = n-1$. The problem therefore reduces to finding $L$.\n\nStarting from the following fundamental base in data structures and algorithms:\n- A predicate $P(i)$ is monotone on an interval if it transitions from \"false\" to \"true\" exactly once and never flips back; when an array is sorted nondecreasing and $M = A[n-1]$, the predicate $P(i) : A[i] = M$ is monotone false-then-true over indices $0,1,\\dots,n-1$.\n- Ternary search is an interval-narrowing method that uses two pivots to partition the search interval into three subintervals and discards at least one subinterval based on comparisons, preserving a loop invariant that the target lies in the retained interval.\n\nYour task is to devise, implement, and justify a ternary search variant that finds the left boundary $L$ of the plateau in a sorted array $A$ with duplicates allowed, including the edge case where the entire array is equal to $M$. The algorithm must maintain a correct loop invariant for all iterations and terminate with $L$ when the interval collapses. You must design the algorithm to handle small intervals robustly without relying on formulas that directly reveal the solution.\n\nImplement a program that, for each test case array $A$, outputs the pair $[L,R]$ where $R$ must be set to $n-1$. Your program must not read input; it must use the test suite embedded in the code. For each array $A$, compute $n$, $M = A[n-1]$, and then compute $L$ using your ternary search variant, with $R = n-1$.\n\nTest suite:\n- Case $1$: $A = [1,2,3,7,9,9,9]$. Expected plateau bounds are $[4,6]$.\n- Case $2$: $A = [5,5,5]$. Expected plateau bounds are $[0,2]$.\n- Case $3$: $A = [42]$. Expected plateau bounds are $[0,0]$.\n- Case $4$: $A = [0,1,2,3,4,5]$. Expected plateau bounds are $[5,5]$.\n- Case $5$: $A = [1,1,2,2,2,8,8,8,8]$. Expected plateau bounds are $[5,8]$.\n- Case $6$: $A = [2,3,3,3,4,6,9,10,10,10,10,10]$. Expected plateau bounds are $[7,11]$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case result formatted as $[L,R]$ and no spaces. For the above six cases, the output will be of the form $[[L_1,R_1],[L_2,R_2],[L_3,R_3],[L_4,R_4],[L_5,R_5],[L_6,R_6]]$.", "solution": "The problem as stated is valid. It is a well-posed algorithmic challenge grounded in the fundamental principles of data structures and algorithms. It is self-contained, consistent, and requires the design of a specific search variant under clear constraints.\n\nThe task is to find the left boundary, denoted by $L$, of the plateau of maximum values in a sorted nondecreasing array $A$ of length $n$. The maximum value is $M = A[n-1]$. The plateau consists of all indices $i$ where $A[i] = M$. Since the array is sorted, this plateau is a contiguous block at the end of the array, from index $L$ to $R = n-1$. Our goal is to find $L$.\n\nThis problem can be reformulated as a search for the smallest index $i$ in the range $[0, n-1]$ that satisfies a certain property. Let us define the predicate $P(i)$ as $A[i] = M$. Because the array $A$ is sorted nondecreasingly and $M$ is the maximum value, this predicate is monotonic. It is false for all indices $i  L$ (where $A[i]  M$) and true for all indices $i \\ge L$ (where $A[i] = M$). Our objective is to find the first index $i$ for which $P(i)$ is true.\n\nThe problem mandates the use of a ternary search variant. A standard ternary search is typically used to find the extremum of a unimodal function. Here, we adapt it to find the first transition point of a monotonic (step) function. The algorithm will maintain a search interval $[l, r]$ that is guaranteed to contain the target index $L$.\n\n**Algorithm Design and Justification**\n\n1.  **Initialization**: The search space for $L$ is the entire set of indices of the array, from $0$ to $n-1$. We initialize our search interval $[l, r]$ to $[0, n-1]$. An empty array is not considered based on the problem statement ($M=A[n-1]$ implies $n \\ge 1$). For an array of size $n=1$, the interval is $[0,0]$, the search loop is skipped, and the result is $L=0$, which is correct.\n\n2.  **Loop Invariant**: The core of the algorithm's correctness rests on a loop invariant: At the beginning of each iteration, the target index $L$ is contained within the closed interval $[l, r]$. That is, $l \\le L \\le r$.\n\n3.  **Iteration and Interval Reduction**: The search proceeds by iteratively narrowing the interval $[l, r]$ until it converges to a single index. The loop continues as long as $l  r$. In each iteration:\n    a. We select two pivots, $m_1$ and $m_2$, which partition the interval $[l, r]$ into three segments. The pivots are calculated as:\n    $$m_1 = l + \\lfloor \\frac{r-l}{3} \\rfloor$$\n    $$m_2 = r - \\lfloor \\frac{r-l}{3} \\rfloor$$\n    This choice ensures $l \\le m_1  m_2 \\le r$ for any interval of size $r-l \\ge 2$, robustly handling intervals of any size.\n\n    b. We evaluate the predicate $P(i)$ at the pivots by comparing the array values $A[m_1]$ and $A[m_2]$ with the maximum value $M$. Based on the outcomes, we shrink the search interval $[l, r]$ while preserving the loop invariant.\n\n4.  **Case Analysis for Interval Update**:\n    -   **Case 1: $A[m_1] = M$**.\n        If the value at the first pivot is the maximum value $M$, it means we have found an index where the predicate $P(m_1)$ is true. Since we are looking for the *first* such index, $L$, it must be that $L \\le m_1$. Any index greater than $m_1$ cannot be the first occurrence. Therefore, we can safely discard the interval $(m_1, r]$ and update our search space to $[l, m_1]$ by setting $r = m_1$. The invariant $L \\in [l, m_1]$ is maintained.\n\n    -   **Case 2: $A[m_1]  M$**.\n        If the value at the first pivot is less than $M$, then due to the sorted nature of the array, all elements at indices $i \\le m_1$ must also be less than $M$. This implies that the first occurrence of $M$ must be at an index strictly greater than $m_1$, i.e., $L > m_1$. We proceed by checking the second pivot, $m_2$.\n        -   **Subcase 2a: $A[m_2] = M$**. We have an index $m_2$ where the predicate $P(m_2)$ is true. This means $L \\le m_2$. Combined with our earlier deduction that $L > m_1$, we can conclude that $L$ must lie in the interval $(m_1, m_2]$, which is the integer interval $[m_1+1, m_2]$. We update our search space by setting $l = m_1+1$ and $r = m_2$. The invariant $L \\in [m_1+1, m_2]$ is maintained.\n        -   **Subcase 2b: $A[m_2]  M$**. Since $A[m_2]  M$ and the array is sorted, all elements at indices $i \\le m_2$ must be less than $M$. Therefore, the first occurrence of $M$ must be at an index strictly greater than $m_2$, i.e., $L > m_2$. We can discard the entire interval $[l, m_2]$ and update our search space to $[m_2+1, r]$ by setting $l = m_2+1$. The invariant $L \\in [m_2+1, r]$ is maintained.\n\n5.  **Termination and Correctness**: In every step of the loop, the interval size $(r-l)$ is strictly reduced. This guarantees that the loop condition $l  r$ will eventually become false and the loop will terminate. The loop terminates when $l = r$. At this point, the invariant $L \\in [l, r]$ implies $L \\in [l, l]$, which means $L = l$. The algorithm thus correctly identifies the index $L$. The final value of $R$ is fixed at $n-1$. This design is robust for small intervals and correctly handles all edge cases, such as the entire array consisting of the maximum value ($L=0$) or only the last element being the maximum value ($L=n-1$).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_plateau_ternary(A: np.ndarray) - list[int]:\n    \"\"\"\n    Finds the left boundary L of the plateau of maximum values in a sorted array\n    using a ternary search variant. The right boundary R is always n-1.\n\n    Args:\n        A: A numpy array of numbers, sorted in nondecreasing order.\n\n    Returns:\n        A list [L, R] representing the start and end indices of the plateau.\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        # As per problem constraints, n = 1, but this is a failsafe.\n        return [-1, -1]\n    \n    # R is always the last index for a sorted array.\n    R = n - 1\n\n    # The maximum value M is at the end of the sorted array.\n    M = A[n - 1]\n\n    # The search space for L is the interval of indices [l, r].\n    l, r = 0, n - 1\n\n    # The loop invariant is that the solution L is within [l, r].\n    # The loop terminates when l == r, at which point L = l.\n    while l  r:\n        # Standard ternary search pivots to divide the interval [l, r].\n        m1 = l + (r - l) // 3\n        m2 = r - (r - l) // 3\n\n        # Case 1: A[m1] equals the maximum value.\n        # This implies L = m1. The search space is reduced to [l, m1].\n        if A[m1] == M:\n            r = m1\n        # Case 2: A[m1] is less than the maximum value.\n        # This implies L  m1. We check A[m2].\n        else:\n            # Subcase 2a: A[m2] equals the maximum value.\n            # We know L  m1 and L = m2.\n            # The search space is reduced to [m1 + 1, m2].\n            if A[m2] == M:\n                l = m1 + 1\n                r = m2\n            # Subcase 2b: A[m2] is also less than the maximum value.\n            # This implies L  m2.\n            # The search space is reduced to [m2 + 1, r].\n            else:\n                l = m2 + 1\n\n    # When the loop terminates, l == r, and this is our answer for L.\n    L = l\n    return [L, R]\n\ndef solve():\n    \"\"\"\n    Solves the problem for the embedded test suite and prints the results\n    in the specified format.\n    \"\"\"\n    test_cases = [\n        np.array([1, 2, 3, 7, 9, 9, 9]),\n        np.array([5, 5, 5]),\n        np.array([42]),\n        np.array([0, 1, 2, 3, 4, 5]),\n        np.array([1, 1, 2, 2, 2, 8, 8, 8, 8]),\n        np.array([2, 3, 3, 3, 4, 6, 9, 10, 10, 10, 10, 10]),\n    ]\n\n    results = []\n    for A in test_cases:\n        result = find_plateau_ternary(A)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # e.g., [[L1,R1],[L2,R2],...]\n    str_results = []\n    for res in results:\n        str_results.append(f\"[{res[0]},{res[1]}]\")\n    \n    final_output = f\"[{','.join(str_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3278839"}, {"introduction": "Real-world data is often not perfectly sorted but may follow more complex patterns, like the \"bitonic\" sequence which increases then decreases. This practice problem models exactly that scenario, requiring a two-stage strategy to find an element [@problem_id:3278805]. You will first use a ternary search-based approach to efficiently locate the peak, and then apply Fibonacci search on the resulting monotonic sections, demonstrating a powerful divide-and-conquer approach.", "problem": "You are given a finite sequence interpreted as an array $A$ of length $n \\geq 1$. The array $A$ is assumed to be bitonic, meaning there exists a unique peak index $p$ (with $0 \\leq p \\leq n - 1$) such that the sequence $A[0 \\dots p]$ is strictly increasing and the sequence $A[p \\dots n-1]$ is strictly decreasing. A strictly increasing array corresponds to the special case $p = n - 1$, and a strictly decreasing array corresponds to the special case $p = 0$. Your task is to derive, from first principles, and then implement an algorithm that returns the index of a given target value $x$ in $A$ or returns $-1$ if $x$ is not present, using only comparison operations and the foundational ideas of ternary and Fibonacci searches.\n\nThe fundamental base you must use is as follows:\n- The definition of a bitonic sequence: there exists a unique peak index $p$ where $A_p$ is the maximum, and $A$ increases on $[0, p]$ and decreases on $[p, n - 1]$.\n- The principle that a unimodal function on a discrete domain can be located using a ternary partitioning strategy that compares values at two interior points to discard one of the outer thirds of the search interval without missing the maximum.\n- The principle that a monotonic sequence can be searched using Fibonacci search, which partitions the search interval using Fibonacci numbers $\\{F_k\\}$ defined by $F_0 = 0$, $F_1 = 1$, and $F_{k} = F_{k-1} + F_{k-2}$ for $k \\geq 2$, to guarantee logarithmic-time search under comparison-only constraints.\n\nYour program must:\n1. Use a discrete ternary-search idea to locate the unique peak index $p$ of $A$ by repeatedly choosing two interior indices $m_1$ and $m_2$ inside the current interval and discarding one third of the interval based on comparing $A[m_1]$ and $A[m_2]$, until a small interval remains, and then find the maximum in that small interval by direct comparison.\n2. Search for $x$ in the strictly increasing prefix $A[0..p-1]$ using Fibonacci search under ascending order and, if not found and $p + 1 \\leq n - 1$, search for $x$ in the strictly decreasing suffix $A[p+1..n-1]$ using Fibonacci search adapted to descending order. You must ensure comparisons are oriented correctly with respect to the order of the segment being searched.\n3. Return a single index $i$ such that $A_i = x$, or return $-1$ if no such index exists.\n\nYour algorithm must be justified by the unimodality of $A$ and by the structural invariants of Fibonacci search. The total number of comparisons must be on the order of $\\log n$.\n\nImplement a single program that solves the problem for the following test suite. Each test case is a pair $(A, x)$ where $A$ is the bitonic array and $x$ is the target:\n- Test case $1$: $A = [1, 3, 8, 12, 9, 5, 2]$, $x = 9$.\n- Test case $2$: $A = [1, 3, 8, 12, 9, 5, 2]$, $x = 12$.\n- Test case $3$: $A = [1, 3, 8, 12, 9, 5, 2]$, $x = 7$.\n- Test case $4$: $A = [1, 3, 2]$, $x = 2$.\n- Test case $5$: $A = [1, 2, 3, 4, 5]$, $x = 4$.\n- Test case $6$: $A = [9, 7, 5, 3, 1]$, $x = 9$.\n- Test case $7$: $A = [2, 5, 9, 15, 14, 7, 3]$, $x = 5$.\n- Test case $8$: $A = [2, 5, 9, 15, 14, 7, 3]$, $x = 3$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The $i$-th entry in the list must be an integer equal to the index found for the $i$-th test case or $-1$ if the search fails (for example, $[4,3,-1,2,3,0,1,6]$). No physical units or angle units are involved in this problem. All numeric outputs must be integers as specified.", "solution": "The problem requires finding a target value $x$ within a bitonic array $A$ of length $n$. A bitonic array is characterized by a single peak element, with a strictly increasing sequence leading up to the peak and a strictly decreasing sequence following it. The solution must be constructed from the first principles of ternary search and Fibonacci search.\n\nThe overall strategy is a classic divide-and-conquer approach. The bitonic property is the key weakness to exploit. Instead of a single monotonic sequence, we have two, joined at a peak. The problem thus decomposes into two primary phases:\n1.  **Locate the Peak**: Find the index $p$ of the maximum element in the bitonic array $A$. This element, $A[p]$, is the \"peak\".\n2.  **Search Monotonic Segments**: Once $p$ is known, the search for $x$ is reduced to searching within two well-defined monotonic segments: the increasing part $A[0 \\dots p-1]$ and the decreasing part $A[p+1 \\dots n-1]$. A check against the peak element $A[p]$ itself is also necessary.\n\nWe will now derive the algorithms for each phase based on the specified principles.\n\n### Phase 1: Locating the Peak with Ternary Search\n\nA bitonic array, when its values are plotted against their indices, forms a unimodal function. The task of finding the peak index $p$ is equivalent to finding the maximum of this discrete unimodal function. Ternary search is an effective algorithm for this purpose. It works by progressively narrowing the search interval until the maximum is isolated.\n\nLet the search interval be $[l, r]$. The principle of ternary search is to select two points, $m_1$ and $m_2$, that partition the interval into three (approximately) equal parts. For a discrete domain, we can choose:\n$$m_1 = l + \\lfloor \\frac{r-l}{3} \\rfloor$$\n$$m_2 = r - \\lfloor \\frac{r-l}{3} \\rfloor$$\n\nBy comparing the values $A[m_1]$ and $A[m_2]$, we can eliminate one of the outer thirds of the search interval. The reasoning is as follows:\n- If $A[m_1]  A[m_2]$: The peak cannot be in the interval $[l, m_1]$. If it were, then both $m_1$ and $m_2$ would be on the decreasing slope to the right of the peak. Since $m_1  m_2$, this would imply $A[m_1] > A[m_2]$, which contradicts our observation. Therefore, the peak must lie in the interval $(m_1, r]$. We update our search space by setting $l = m_1$. We do not use $l=m_1+1$ to avoid accidentally skipping over the peak.\n- If $A[m_1] > A[m_2]$: By symmetric reasoning, the peak cannot be in the interval $[m_2, r]$. Both $m_1$ and $m_2$ cannot be on the increasing slope, as this would imply $A[m_1]  A[m_2]$. Thus, the peak must be in the interval $[l, m_2)$. We update our search space by setting $r = m_2$.\n- If $A[m_1] = A[m_2]$: Given the strictly increasing and decreasing nature of the segments, this can only happen if $m_1$ is on the increasing slope and $m_2$ is on the decreasing slope. The peak must lie between them, in $[m_1, m_2]$. We could shrink the interval to $[m_1, m_2]$, but the simpler rules above are sufficient and also cover this case implicitly.\n\nThis process is repeated until the interval $[l, r]$ becomes small (e.g., of size less than $3$). At this point, the peak index can be found by a simple linear scan of the elements $A[l], \\dots, A[r]$. This entire procedure has a time complexity of $O(\\log n)$, as we discard approximately one-third of the search space in each iteration.\n\n### Phase 2: Searching Monotonic Segments with Fibonacci Search\n\nAfter identifying the peak index $p$, we check if $A[p] = x$. If it is, we have found the index. If not, we must search for $x$ in the increasing prefix $A[0 \\dots p-1]$ and the decreasing suffix $A[p+1 \\dots n-1]$. The problem mandates the use of Fibonacci search.\n\nFibonacci search is a comparison-based technique for searching a sorted array. Its main advantage is that it uses only addition and subtraction to calculate probe positions, unlike binary search which requires division/bitwise shifts. The search is based on Fibonacci numbers, defined by the recurrence $F_k = F_{k-1} + F_{k-2}$ with $F_0 = 0$ and $F_1 = 1$.\n\nThe core principle is to maintain a search interval whose size is a Fibonacci number. Let the array to be searched, `arr`, have length $N$.\n1.  Find the smallest Fibonacci number $F_m$ such that $F_m \\geq N$.\n2.  The search interval is partitioned at an index $i$ which is based on the second-to-last Fibonacci number in the sequence, $F_{m-2}$. The index is calculated relative to an offset that tracks the discarded portion of the array. The probe index is `i = min(offset + F_{m-2}, N-1)`.\n3.  Compare $x$ with `arr[i]`:\n    - If `arr[i]` equals $x$, the search is complete.\n    - If $x$ is in the larger partition, we update the Fibonacci numbers to `F_{m-1}, F_{m-2}, F_{m-3}` and adjust the offset to move our search window. The new interval size is roughly $F_{m-1}$.\n    - If $x$ is in the smaller partition, we update the Fibonacci numbers to `F_{m-2}, F_{m-3}, F_{m-4}`. The new interval size is roughly $F_{m-2}$.\nThis process continues until the search interval is exhausted. A key property is that one of the new partitions will always have a size that is the next Fibonacci number down, maintaining the search invariant. The time complexity is $O(\\log N)$.\n\nThis algorithm must be adapted for our specific use case:\n- **Ascending Search**: For the prefix $A[0 \\dots p-1]$, we apply Fibonacci search directly. If `arr[i]  x`, the target must be in the right partition (larger indices). If `arr[i] > x`, it must be in the left partition.\n- **Descending Search**: For the suffix $A[p+1 \\dots n-1]$, the logic is inverted. If `arr[i]  x`, the target must be in the left partition (smaller indices in the subarray, but corresponding to larger indices in the original array $A$). If `arr[i] > x`, it must be in the right partition.\n\n### The Complete Algorithm\n\nThe final integrated algorithm is as follows:\n\n1.  Given the bitonic array $A$ of length $n$ and target $x$.\n2.  If $n=0$, return $-1$.\n3.  Use ternary search on the indices $[0, n-1]$ to find the peak index $p$.\n4.  Compare the target with the peak element: if $A[p] = x$, return $p$.\n5.  If $p > 0$, perform Fibonacci search for $x$ on the ascending subarray slice $A[0 \\dots p-1]$. If found at relative index `res`, return `res`.\n6.  If $x$ was not found in the prefix (and $p  n-1$), perform Fibonacci search for $x$ on the descending subarray slice $A[p+1 \\dots n-1]$. The comparison logic must be inverted for descending order. If found at relative index `res`, return the absolute index $p + 1 + res$.\n7.  If $x$ is not found in any segment, return $-1$.\n\nThe total time complexity is the sum of the complexities of its parts. Finding the peak takes $O(\\log n)$. The two Fibonacci searches take $O(\\log p)$ and $O(\\log(n-p-1))$ respectively. Since these are sequential, the total complexity is $O(\\log n) + O(\\log p) + O(\\log(n-p-1))$, which simplifies to $O(\\log n)$.", "answer": "```python\nimport numpy as np\n\ndef find_peak_index(A: np.ndarray) - int:\n    \"\"\"\n    Finds the index of the peak element in a bitonic array using ternary search.\n    The array is guaranteed to have at least one element.\n    \"\"\"\n    n = len(A)\n    if n = 2:\n        max_idx = 0\n        for i in range(1, n):\n            if A[i]  A[max_idx]:\n                max_idx = i\n        return max_idx\n\n    l, r = 0, n - 1\n    while r - l = 3:\n        m1 = l + (r - l) // 3\n        m2 = r - (r - l) // 3\n        if A[m1]  A[m2]:\n            l = m1\n        else:\n            r = m2\n    \n    # Linear scan on the remaining small interval [l, r]\n    max_val_idx = l\n    for i in range(l + 1, r + 1):\n        if A[i]  A[max_val_idx]:\n            max_val_idx = i\n    \n    return max_val_idx\n\ndef fibonacci_search(arr: np.ndarray, x: int, ascending: bool = True) - int:\n    \"\"\"\n    Performs Fibonacci search for a value x in a monotonic array slice.\n    Returns the index relative to the slice, or -1 if not found.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return -1\n\n    # Initialize Fibonacci numbers\n    fib_m2 = 0\n    fib_m1 = 1\n    fib_m = fib_m2 + fib_m1\n    while fib_m  n:\n        fib_m2 = fib_m1\n        fib_m1 = fib_m\n        fib_m = fib_m1 + fib_m2\n\n    offset = -1\n    while fib_m  1:\n        i = min(offset + fib_m2, n - 1)\n        \n        # Compare and shrink the search space\n        if ascending:\n            if arr[i]  x:\n                fib_m = fib_m1\n                fib_m1 = fib_m2\n                fib_m2 = fib_m - fib_m1\n                offset = i\n            elif arr[i]  x:\n                fib_m = fib_m2\n                fib_m1 = fib_m1 - fib_m2\n                fib_m2 = fib_m - fib_m1\n            else:\n                return i\n        else:  # descending\n            if arr[i]  x:\n                fib_m = fib_m1\n                fib_m1 = fib_m2\n                fib_m2 = fib_m - fib_m1\n                offset = i\n            elif arr[i]  x:\n                fib_m = fib_m2\n                fib_m1 = fib_m1 - fib_m2\n                fib_m2 = fib_m - fib_m1\n            else:\n                return i\n                \n    # Final check for the last element\n    if fib_m1 == 1 and offset + 1  n and arr[offset + 1] == x:\n        return offset + 1\n\n    return -1\n\ndef find_in_bitonic(A: np.ndarray, x: int) - int:\n    \"\"\"\n    Finds a target value x in a bitonic array A.\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        return -1\n    \n    peak_index = find_peak_index(A)\n    \n    # Check if the peak element is the target\n    if A[peak_index] == x:\n        return peak_index\n    \n    # Search in the strictly increasing part (A[0...p-1])\n    if peak_index  0:\n        res_left = fibonacci_search(A[0:peak_index], x, ascending=True)\n        if res_left != -1:\n            return res_left\n            \n    # Search in the strictly decreasing part (A[p+1...n-1])\n    if peak_index  n - 1:\n        res_right = fibonacci_search(A[peak_index+1:n], x, ascending=False)\n        if res_right != -1:\n            # Adjust index to be relative to the original array A\n            return peak_index + 1 + res_right\n    \n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to run the algorithm on the specified test suite.\n    \"\"\"\n    test_cases = [\n        (np.array([1, 3, 8, 12, 9, 5, 2]), 9),\n        (np.array([1, 3, 8, 12, 9, 5, 2]), 12),\n        (np.array([1, 3, 8, 12, 9, 5, 2]), 7),\n        (np.array([1, 3, 2]), 2),\n        (np.array([1, 2, 3, 4, 5]), 4),\n        (np.array([9, 7, 5, 3, 1]), 9),\n        (np.array([2, 5, 9, 15, 14, 7, 3]), 5),\n        (np.array([2, 5, 9, 15, 14, 7, 3]), 3),\n    ]\n\n    results = []\n    for A, x in test_cases:\n        result = find_in_bitonic(A, x)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3278805"}, {"introduction": "Our final practice elevates the concept of unimodality to a non-linear domain: a circular array. This \"unimodal-on-a-torus\" structure, where the minimum and maximum elements might be cyclically adjacent, requires a more abstract approach to searching [@problem_id:3278722]. You will devise a multi-stage algorithm that first intelligently \"brackets\" an extremum on the circle to create a linear search space, and then applies both Fibonacci and ternary search to pinpoint the minimum and maximum values.", "problem": "You are given a family of arrays that are circular and strictly unimodal on the circle. Formally, for an integer array $A$ of length $n \\geq 1$, regard the domain of indices as the cyclic group $\\mathbb{Z}_n = \\{0,1,\\dots,n-1\\}$ with addition modulo $n$. The array is called unimodal-on-a-torus if there exist exactly one index $i_{\\min} \\in \\mathbb{Z}_n$ and exactly one index $i_{\\max} \\in \\mathbb{Z}_n$ such that:\n- Moving forward from $i_{\\min}$ in cyclic order yields a strictly increasing sequence until $i_{\\max}$.\n- Continuing forward from $i_{\\max}$ yields a strictly decreasing sequence until returning to $i_{\\min}$.\nEquivalently, the cyclic sequence has one global minimum and one global maximum, and when traversed once around the circle, it consists of exactly one strictly increasing arc and one strictly decreasing arc; the minimum and maximum may be adjacent when considering circular adjacency.\n\nYour task is to design and implement a program that, for each test case array, computes the index of the global minimum $i_{\\min}$ and the index of the global maximum $i_{\\max}$ using a two-stage search that must explicitly employ:\n- Ternary search (for locating the global maximum on a properly linearized unimodal interval).\n- Fibonacci search method (for locating the global minimum by first bracketing it on the circle and then minimizing over the bracketed linear interval).\n\nYou must derive the algorithm from the following fundamental bases:\n- The definition of unimodality and the properties of strictly monotonic segments on the circle.\n- The Fibonacci search method for minimizing a unimodal function on a closed interval by shrinking the interval using positions determined by ratios of consecutive Fibonacci numbers.\n- Ternary search for locating the extremum of a unimodal function by comparing values at two interior points to eliminate a portion of the interval.\n\nDesign requirements:\n1. You must first produce a bracket that contains $i_{\\min}$ and respects unimodality over a linear interval. To do this from first principles, choose three equally spaced sample indices $a$, $b$, and $c$ in cyclic order, where $a = 0$, $b = \\lfloor n/3 \\rfloor$, and $c = \\lfloor 2n/3 \\rfloor$. Let $v_a = A[a]$, $v_b = A[b]$, and $v_c = A[c]$. Show that the global minimum lies on the unique cyclic arc connecting the two samples that are adjacent around the lowest-valued sample among $\\{v_a, v_b, v_c\\}$ when following the cyclic order. Convert that arc into a linear interval $[L,R]$ of integer indices by choosing a linearization start and end along the forward direction, of length $\\ell = (R-L)+1$, and define a function $f(k) = A[(L+k) \\bmod n]$ for $k \\in \\{0,1,\\dots,\\ell-1\\}$ that is unimodal with a single minimum on this linear interval.\n2. Apply the Fibonacci search method to $f(k)$ on the bracketed interval to find the minimizing index $k^* \\in \\{0,\\dots,\\ell-1\\}$. Map it back to the circular index $i_{\\min} = (L + k^*) \\bmod n$.\n3. Construct a linearized unimodal function $g(j) = A[(i_{\\min} + j) \\bmod n]$ for $j \\in \\{0,1,\\dots,n-1\\}$ that is strictly increasing up to its unique maximum and strictly decreasing thereafter. Apply discrete ternary search to $g(j)$ to find the index $j^*$ of its maximum, and map back to the circular index $i_{\\max} = (i_{\\min} + j^*) \\bmod n$.\n\nOutput specification:\n- For each test case, your program must output the pair $[i_{\\min}, i_{\\max}]$ as a list of two integers.\n- Aggregate the results for all test cases as a single line containing a comma-separated list of such pairs, enclosed in square brackets. For example, the output should look like $[[i_{\\min}^{(1)}, i_{\\max}^{(1)}],[i_{\\min}^{(2)}, i_{\\max}^{(2)}],\\dots]$.\n\nTest suite:\nUse the following arrays as the test suite. These arrays are all strictly unimodal on the circle as defined above, and they are chosen to cover general cases, boundary conditions, and edge cases:\n- Case 1 (general unimodal with peak interior): $A_1 = [7, 9, 12, 11, 8, 5, 3]$ with $n=7$.\n- Case 2 (strictly decreasing on the line, minimum and maximum adjacent on the circle): $A_2 = [5, 4, 3, 2, 1]$ with $n=5$.\n- Case 3 (strictly increasing on the line, minimum and maximum adjacent on the circle): $A_3 = [1, 2, 3, 4, 5]$ with $n=5$.\n- Case 4 (two-element circle): $A_4 = [10, 1]$ with $n=2$.\n- Case 5 (single-element circle): $A_5 = [42]$ with $n=1$.\n- Case 6 (general unimodal with minimum at the end): $A_6 = [4, 6, 9, 12, 7, 3, 2]$ with $n=7$.\n\nYour program should produce a single line of output containing the list of six results in the exact format described above. No physical units are involved. All angles, if any appear in reasoning, are implicit in the cyclic index arithmetic and need no unit specification. All answers for each case are integers.", "solution": "The problem requires us to find the indices of the global minimum, $i_{\\min}$, and global maximum, $i_{\\max}$, of a circularly unimodal array. The array $A$ of length $n$ is defined on the cyclic group of indices $\\mathbb{Z}_n = \\{0, 1, \\dots, n-1\\}$. By definition, there is a unique global minimum at index $i_{\\min}$ and a unique global maximum at index $i_{\\max}$. The sequence of values from $A[(i_{\\min}+j)\\pmod{n}]$ for $j=0, \\dots, n-1$ is strictly increasing until the maximum is reached, and strictly decreasing thereafter.\n\nThe solution is a two-stage process as prescribed: first, find $i_{\\min}$ using a bracketing strategy followed by Fibonacci search; second, find $i_{\\max}$ using ternary search on a cyclically shifted version of the array.\n\n### Stage 1: Finding the Global Minimum ($i_{\\min}$)\n\n#### 1.1 Bracketing the Minimum\nThe first step is to reduce the search space from the entire circle of $n$ elements to a smaller linear interval that is guaranteed to contain the minimum. The problem specifies a bracketing method using three sample points.\n\nLet the three sample indices be $s_0 = 0$, $s_1 = \\lfloor n/3 \\rfloor$, and $s_2 = \\lfloor 2n/3 \\rfloor$. We evaluate the array at these points to get the values $v_0 = A[s_0]$, $v_1 = A[s_1]$, and $v_2 = A[s_2]$.\n\nLet's analyze the configuration of these values. Due to the unimodal-on-a-torus property, the array consists of one contiguous strictly increasing arc and one contiguous strictly decreasing arc. The three sample points must fall on these arcs. Let's find the sample with the minimum value, say $v_k = \\min(v_0, v_1, v_2)$ at index $s_k$. Since the values increase as we move away from the global minimum $i_{\\min}$ in either cyclic direction, the value $v_k$ is a local minimum among the three samples. This implies that the global minimum $i_{\\min}$ must lie in the cyclic segment \"cornered\" by the other two sample points.\n\nFor instance, if $v_1 = A[s_1]$ is the minimum among the three, i.e., $A[s_1]  A[s_0]$ and $A[s_1]  A[s_2]$, it indicates that from index $s_1$, the path toward $s_0$ (cyclically backwards) and the path toward $s_2$ (cyclically forwards) are both on the increasing slope away from $i_{\\min}$. This confines $i_{\\min}$ to the cyclic arc that starts at $s_0$, passes through $s_1$, and ends at $s_2$.\n\nTherefore, we can establish a search bracket. If $A[s_k]$ is the minimum among the samples, the global minimum $i_{\\min}$ is located on the cyclic arc connecting the other two sample points, specifically the arc that contains $s_k$. For example, if $s_k=s_1$, the arc is from $s_0$ to $s_2$. We can linearize this arc to form an interval for a standard search algorithm. Let this arc start at index $L$ and end at index $R$ in the forward cyclic direction. We define a new function $f(k)$ for $k \\in \\{0, 1, \\dots, \\ell-1\\}$, where $\\ell = (R - L + n) \\pmod n + 1$ is the length of the arc:\n$$f(k) = A[(L+k) \\pmod n]$$\nBecause this arc contains the unique global minimum $i_{\\min}$ and is guaranteed not to contain the global maximum $i_{\\max}$ (unless the arc spans almost the entire circle, which is a possible but valid outcome of this bracketing), the function $f(k)$ will be unimodal with a single minimum over its domain $\\{0, 1, \\dots, \\ell-1\\}$.\n\nThis bracketing strategy requires at least three distinct sample points to be effective, which is true for $n \\ge 4$. For smaller $n$ ($1, 2, 3$), we handle them as special cases where the minimum and maximum can be found by direct inspection.\n\n#### 1.2 Fibonacci Search\nWith a linearized unimodal function $f(k)$ on an interval of length $\\ell$, we apply Fibonacci search to find the index $k^*$ that minimizes $f(k)$. Fibonacci search is an efficient method for finding the extremum of a unimodal function by progressively shrinking the search interval. The positions of the two probe points in each step are determined by ratios of consecutive Fibonacci numbers, which optimally reduces the search space.\n\nThe Fibonacci sequence is defined by $F_0=0, F_1=1$, and $F_m = F_{m-1} + F_{m-2}$ for $m \\ge 2$.\nTo find the minimum in an interval of length $\\ell$, we first find the smallest Fibonacci number $F_m \\ge \\ell$. The search proceeds by maintaining a search interval $[l, r]$ and iteratively reducing it. A recursive implementation simplifies managing the logic. A search on an interval of size approximately $F_k$ probes at two internal points derived from $F_{k-1}$ and $F_{k-2}$, and based on the comparison, recurses on a smaller interval of size approximately $F_{k-1}$.\n\nAfter the Fibonacci search finds the minimizing index $k^*$ for the function $f$, we map it back to the original array's index system:\n$$i_{\\min} = (L + k^*) \\pmod n$$\n\n### Stage 2: Finding the Global Maximum ($i_{\\max}$)\n\n#### 2.1 Linearization for Ternary Search\nOnce $i_{\\min}$ is known, the structure of the array relative to its minimum is fixed. We can define a new function $g(j)$ by cyclically shifting the array $A$ so that the minimum element is at index $0$:\n$$g(j) = A[(i_{\\min} + j) \\pmod n], \\quad \\text{for } j \\in \\{0, 1, \\dots, n-1\\}$$\nBy the definition of a circularly unimodal array, $g(j)$ is strictly increasing from $j=0$ up to a unique peak, and then strictly decreasing. This makes $g(j)$ a classic unimodal function (with one maximum) on a linear domain, which is a perfect candidate for ternary search.\n\n#### 2.2 Ternary Search\nTernary search is another interval-shrinking algorithm for finding the extremum of a unimodal function. It works by maintaining a search interval $[l, r]$ and evaluating the function at two intermediate points, $m_1$ and $m_2$, which are one-third and two-thirds of the way through the interval.\n$$m_1 = l + \\lfloor(r-l)/3\\rfloor$$\n$$m_2 = r - \\lfloor(r-l)/3\\rfloor$$\nBy comparing $g(m_1)$ and $g(m_2)$, we can discard one-third of the search interval.\n- If $g(m_1)  g(m_2)$, the maximum cannot be in the leftmost third $[l, m_1]$, so we update the interval to $[m_1+1, r]$.\n- If $g(m_1) > g(m_2)$, the maximum cannot be in the rightmost third $[m_2, r]$, so we update to $[l, m_2-1]$.\n- If $g(m_1) = g(m_2)$, we can shrink both sides.\n\nThis process is repeated until the interval is small enough (e.g., length less than $3$), at which point the maximum can be found by a simple linear scan of the few remaining elements. Let the maximizing index found for $g(j)$ be $j^*$. This index corresponds to the distance from $i_{\\min}$ to $i_{\\max}$ in the cyclic order.\n\nFinally, we map $j^*$ back to the original index system to find $i_{\\max}$:\n$$i_{\\max} = (i_{\\min} + j^*) \\pmod n$$\n\nThis two-stage algorithm correctly identifies both the global minimum and maximum indices as required.", "answer": "```python\nimport numpy as np\n\ndef fibonacci_search(f, length):\n    \"\"\"\n    Finds the index of the minimum value of a unimodal function f defined on [0, length-1].\n    Uses a robust iterative approach.\n    \"\"\"\n    if length = 1:\n        return 0\n\n    fib_seq = [0, 1]\n    while fib_seq[-1]  length:\n        fib_seq.append(fib_seq[-1] + fib_seq[-2])\n    \n    k = len(fib_seq) - 1\n    low, high = 0, length - 1\n    \n    while high - low > 2:\n        if k  3: break\n        # Symmetrical probes\n        p1 = low + fib_seq[k-2]\n        p2 = high - fib_seq[k-2]\n\n        if p1 > p2: # Crossover can happen if probes are not placed carefully\n            break\n            \n        if f(p1)  f(p2):\n            high = p2 - 1\n            k -= 1\n        else:\n            low = p1 + 1\n            # Shrinking from left side; a more careful fibonacci search\n            # would adjust k differently, but this is robust enough.\n            k -= 2\n            \n    # Linear scan on the final small interval\n    min_idx = low\n    for i in range(low + 1, min(high + 1, length)):\n        if f(i)  f(min_idx):\n            min_idx = i\n    return min_idx\n\n\ndef ternary_search_max(g, length):\n    \"\"\"\n    Finds the index of the maximum value of a unimodal function g on [0, length-1].\n    \"\"\"\n    if length = 1:\n        return 0\n\n    low, high = 0, length - 1\n    while high - low >= 3:\n        m1 = low + (high - low) // 3\n        m2 = high - (high - low) // 3\n        if g(m1)  g(m2):\n            low = m1 + 1\n        else:\n            high = m2 - 1\n    \n    # Final linear scan on the small remaining interval\n    max_idx = low\n    for i in range(low + 1, min(high + 1, length)):\n        if g(i) > g(max_idx):\n            max_idx = i\n    return max_idx\n\ndef find_min_max(A):\n    \"\"\"\n    Finds i_min and i_max for a circularly unimodal array A.\n    \"\"\"\n    n = len(A)\n\n    # Handle edge cases for n = 3, where bracketing is ill-defined or trivial.\n    if n = 3:\n        i_min = np.argmin(A)\n        i_max = np.argmax(A)\n        return [int(i_min), int(i_max)]\n\n    # Stage 1: Find i_min\n    # 1.1 Bracketing\n    s0, s1, s2 = 0, n // 3, (2 * n) // 3\n    v0, v1, v2 = A[s0], A[s1], A[s2]\n    \n    samples = [(v0, s0), (v1, s1), (v2, s2)]\n    samples.sort()\n    \n    min_sample_idx = samples[0][1]\n    \n    if min_sample_idx == s0:\n        L, R = s2, s1\n    elif min_sample_idx == s1:\n        L, R = s0, s2\n    else: # min_sample_idx == s2\n        L, R = s1, s0\n    \n    arc_len = (R - L + n) % n + 1\n    f = lambda k: A[(L + k) % n]\n\n    # 1.2 Fibonacci search on the bracketed arc\n    k_star = fibonacci_search(f, arc_len)\n    i_min = (L + k_star) % n\n\n    # Stage 2: Find i_max\n    # 2.1 Linearization from the minimum\n    g = lambda j: A[(i_min + j) % n]\n\n    # 2.2 Ternary search for the maximum on the linearized array\n    j_star = ternary_search_max(g, n)\n    i_max = (i_min + j_star) % n\n\n    return [i_min, i_max]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([7, 9, 12, 11, 8, 5, 3]),\n        np.array([5, 4, 3, 2, 1]),\n        np.array([1, 2, 3, 4, 5]),\n        np.array([10, 1]),\n        np.array([42]),\n        np.array([4, 6, 9, 12, 7, 3, 2]),\n    ]\n    \n    results = []\n    for A in test_cases:\n        result = find_min_max(A)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).replace(' ', '') for r in results)}]\")\n\nsolve()\n```", "id": "3278722"}]}