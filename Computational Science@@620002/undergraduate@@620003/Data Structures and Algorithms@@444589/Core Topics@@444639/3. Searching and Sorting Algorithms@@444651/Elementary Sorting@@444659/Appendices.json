{"hands_on_practices": [{"introduction": "This first exercise provides a bridge between the procedural execution of an algorithm and its theoretical analysis. By tracing bubble sort on a carefully chosen input array, you will gain a concrete understanding of how its fundamental operation—the adjacent swap—directly relates to resolving inversions in the data. This practice is key to moving beyond rote memorization of complexity classes and toward a deeper grasp of algorithmic behavior.", "problem": "Consider the standard bubble sort algorithm on an array of distinct integers. Bubble sort repeatedly performs passes over the array from left to right, comparing adjacent pairs $A[j]$ and $A[j+1]$ for indices $j$ where the pair exists, and swapping them if $A[j]  A[j+1]$. A pass ends after the rightmost adjacent pair is processed, and the algorithm terminates when a complete pass performs no swaps. Count exactly one swap operation per exchange of two adjacent elements.\n\nLet $n$ be an integer with $n \\geq 2$, and consider the input array $A = [n, 1, 2, 3, \\dots, n-1]$. Derive, from first principles and core definitions in sorting and order theory, a closed-form expression in $n$ for the total number of swaps bubble sort performs until termination on this array. Express your final answer as a single closed-form expression in $n$. No rounding is required.", "solution": "The problem asks for the total number of swaps performed by the bubble sort algorithm for a specific input array $A$ of size $n \\geq 2$. The array is given as $A = [n, 1, 2, 3, \\dots, n-1]$.\n\nThe bubble sort algorithm operates in passes. In each pass, it traverses the array, comparing adjacent elements and swapping them if they are in the wrong order. The algorithm terminates when a pass is completed with no swaps. A swap is counted as a single operation.\n\nWe will analyze the behavior of the algorithm pass by pass on the given input.\n\n**Initial State:** The array is $A^{(0)} = [n, 1, 2, \\dots, n-1]$.\n\n**Pass 1:**\nThe first pass iterates with index $j$ from $0$ to $n-2$.\n- For $j=0$: The elements $A[0]=n$ and $A[1]=1$ are compared. Since $n1$, they are swapped. This is $1$ swap. The array becomes $[1, n, 2, 3, \\dots, n-1]$.\n- For $j=1$: The new $A[1]=n$ is compared with $A[2]=2$. Since $n2$, they are swapped. This is the $2$-nd swap. The array becomes $[1, 2, n, 3, \\dots, n-1]$.\n- This process continues. The element $n$ is the largest in the array. In each comparison, it is found to be greater than its right neighbor. It is thus swapped successively with the elements $1, 2, 3, \\dots, n-1$.\n- The element $n$ \"bubbles\" from the first position (index $0$) to the last position (index $n-1$). To move from index $k$ to $k+1$, one swap is required. To move from index $0$ to index $n-1$, a total of $(n-1) - 0 = n-1$ swaps are necessary.\n- At the conclusion of the first pass, the array becomes $A^{(1)} = [1, 2, 3, \\dots, n-1, n]$.\n- The number of swaps performed in Pass $1$ is exactly $n-1$.\n\n**Pass 2:**\nThe algorithm now performs a second pass on the array $A^{(1)} = [1, 2, 3, \\dots, n-1, n]$. This array is now sorted in ascending order.\n- The pass iterates from $j=0$ to $j=n-2$. For each $j$, the elements $A[j]$ and $A[j+1]$ are compared.\n- Since the array is sorted, for every $j$, we have $A[j]  A[j+1]$. For example, for $j=0$, $A[0]=1  A[1]=2$; for $j=1$, $A[1]=2  A[2]=3$, and so on.\n- The condition $A[j]  A[j+1]$ is never satisfied.\n- Consequently, zero swaps are performed during Pass $2$.\n\n**Termination:**\nAccording to the algorithm's definition, it terminates when a complete pass results in zero swaps. Since Pass $2$ had $0$ swaps, the algorithm halts.\n\n**Total Swaps:**\nThe total number of swaps is the sum of swaps from all passes.\nTotal Swaps = (Swaps in Pass $1$) + (Swaps in Pass $2$) = $(n-1) + 0 = n-1$.\n\n**Derivation from Order Theory Principles:**\nThis result can be rigorously confirmed using the concept of inversions from order theory. An inversion is a pair of indices $(i, j)$ in an array such that $i  j$ and $A[i]  A[j]$. A fundamental property of bubble sort is that the total number of swaps performed is precisely equal to the initial number of inversions in the array. This is because each swap of adjacent elements $A[j]$ and $A[j+1]$ where $A[j]  A[j+1]$ corrects exactly one inversion.\n\nLet's count the number of inversions in the initial array $A = [n, 1, 2, \\dots, n-1]$.\n1. Consider the element $A[0]=n$. For any other element $A[j]=j$ where $j \\in \\{1, 2, \\dots, n-1\\}$, we have $0  j$ and $A[0]=n  A[j]=j$. Thus, the pairs $(A[0], A[1]), (A[0], A[2]), \\dots, (A[0], A[n-1])$ are all inversions. This gives a total of $n-1$ inversions involving the element $n$.\n2. Now consider the subarray formed by the remaining elements: $[1, 2, \\dots, n-1]$. This subarray is already sorted. For any two elements $A[i]$ and $A[j]$ with $1 \\le i  j \\le n-1$, we have $A[i]=i$ and $A[j]=j$. Since $i  j$, the condition $A[i]  A[j]$ is never met. Therefore, this subarray contains $0$ inversions.\n\nThe total number of inversions in the initial array is the sum of these counts: $(n-1) + 0 = n-1$.\nSince the total number of swaps is equal to the initial number of inversions, the total number of swaps is $n-1$.\n\nBoth methods of derivation yield the same result. The final closed-form expression for the total number of swaps is $n-1$.", "answer": "$$\n\\boxed{n-1}\n$$", "id": "3231384"}, {"introduction": "Building on the concept of inversions, this next challenge asks you to think like an adversary by constructing the worst-possible input for insertion sort from a sorted list. This \"anti-algorithm\" design problem deepens your understanding of worst-case analysis by connecting the abstract property of maximum inversions to a concrete target permutation. The exercise further sharpens your problem-solving skills by requiring you to achieve this transformation with the minimum number of swaps, a classic puzzle in permutation theory.", "problem": "Given a strictly increasing list of pairwise distinct integers $A = [a_1,a_2,\\dots,a_n]$, consider the Elementary Sorting family and, in particular, the comparison-based algorithm insertion sort. A fundamental base for reasoning about insertion sort is the definition of inversion in an array: an inversion is a pair of indices $(i,j)$ with $1 \\leq i  j \\leq n$ such that $A[i]  A[j]$. The worst-case input for insertion sort, for a fixed multiset of values, is any arrangement that maximizes the number of inversions. Design and implement an anti-algorithm that, starting from the strictly increasing list $A$, produces an arrangement $B$ that attains the maximum number of inversions for the given values by applying a sequence of element swaps, with the objective of minimizing the number of swaps used. A swap is defined as exchanging the elements at positions $i$ and $j$ for any $1 \\leq i,j \\leq n$, where a single swap counts as one operation, and there is no restriction that swaps be adjacent.\n\nYour program must, for each test case, output the minimal number of swaps your anti-algorithm uses, the resulting list $B$ after performing those swaps, and the inversion count of $B$ computed directly by enumeration of all index pairs. The final output should aggregate the results of all test cases into a single line, as a comma-separated list enclosed in square brackets, where each per-test-case result is a list of the form $[k,B,I]$ with $k$ the integer number of swaps performed, $B$ the resulting list of integers, and $I$ the integer inversion count of $B$.\n\nUse exactly the following test suite, in this order:\n$[\\,7\\,]$,\n$[\\,1,2\\,]$,\n$[\\,1,3,4,7,9,10,15\\,]$,\n$[\\,{-10},{-5},0,2,3,8\\,]$,\n$[\\,2,4,6,8,12\\,]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, an output of the form $[\\,[k_1,B_1,I_1],[k_2,B_2,I_2],\\dots\\,]$, with no additional text. No external input is permitted; the test suite must be embedded in the program. All integers should be treated as dimensionless quantities; there are no physical units involved. The algorithm must be deterministic and should use the global minimum number of swaps needed to transform the given sorted list into an arrangement that maximizes the inversion count for the given values.", "solution": "The problem requires us to design an \"anti-algorithm\" that transforms a strictly increasing list of distinct integers $A$ into an arrangement $B$ that contains the maximum possible number of inversions, while minimizing the number of swaps used.\n\n**1. Identification of the Target Arrangement $B$**\n\nAn inversion is a pair of indices $(i, j)$ such that $i  j$ and $A[i]  A[j]$. To maximize the number of inversions for a list of $n$ distinct elements, every pair of elements must be in an inverted order. This is achieved if and only if the list is sorted in strictly decreasing order. Since the input list $A = [a_1, a_2, \\dots, a_n]$ is sorted in strictly increasing order ($a_1  a_2  \\dots  a_n$), the unique arrangement $B$ with the maximum number of inversions comprises the same elements as $A$ but in reverse order: $B = [a_n, a_{n-1}, \\dots, a_1]$. In this arrangement, for any two indices $i  j$, the corresponding elements $b_i$ and $b_j$ will satisfy $b_i  b_j$, thus forming an inversion. The total number of such pairs, and therefore the maximum number of inversions, is the number of ways to choose $2$ elements from $n$, which is $\\binom{n}{2} = \\frac{n(n-1)}{2}$.\n\n**2. Minimizing the Number of Swaps**\n\nThe problem now reduces to finding the minimum number of swaps to transform the list $A$ into its reverse, $B$. This is a classic result in the study of permutations. Any permutation can be decomposed into disjoint cycles. The minimum number of swaps (transpositions) required to achieve a permutation $\\pi$ on a set of $n$ elements is given by the formula $n - c(\\pi)$, where $c(\\pi)$ is the number of disjoint cycles in the cycle decomposition of $\\pi$.\n\nLet's analyze the permutation that reverses a list of length $n$. We are mapping the element at position $i$ (1-indexed, for $i \\in \\{1, \\dots, n\\}$) to the element at position $n-i+1$. The permutation of positions is therefore $\\pi(i) = n-i+1$.\n\nThe cycle decomposition of $\\pi$ consists of pairs of the form $(i, n-i+1)$. For example, $\\pi(1) = n$ and $\\pi(n) = 1$, forming the cycle $(1, n)$. Similarly, $\\pi(2) = n-1$ and $\\pi(n-1) = 2$, forming the cycle $(2, n-1)$. This continues for all $i$ where $i \\neq n-i+1$.\n\nA fixed point occurs if an element is mapped to itself, i.e., $i = \\pi(i) = n-i+1$. This solves to $2i = n+1$, or $i = (n+1)/2$. A fixed point exists if and only if $n$ is odd, in which case the middle element of the list does not move.\n\nThe permutation $\\pi$ thus consists of:\n- $\\lfloor n/2 \\rfloor$ two-cycles (transpositions) of the form $(i, n-i+1)$.\n- If $n$ is odd, one one-cycle (a fixed point) for the middle element.\n\nThe total number of cycles is $c(\\pi) = \\lfloor n/2 \\rfloor + (n \\pmod 2) = \\lceil n/2 \\rceil$.\n\nThe minimum number of swaps, $k$, is therefore:\n$$k = n - c(\\pi) = n - \\lceil n/2 \\rceil = \\lfloor n/2 \\rfloor$$\n\n**3. The Anti-Algorithm and Implementation**\n\nThe minimal number of swaps $k = \\lfloor n/2 \\rfloor$ can be achieved constructively. The algorithm is as follows:\n1.  Given the input list $A$ of length $n$.\n2.  The minimal number of swaps is $k = \\lfloor n/2 \\rfloor$.\n3.  Create a copy of the list, $B$. To achieve the reversal of the list, iterate from index $i=0$ to $i=k-1$ (using $0$-based indexing) and swap the element $B[i]$ with $B[n-1-i]$. This procedure performs exactly $k = \\lfloor n/2 \\rfloor$ swaps.\n4.  The resulting list $B$ is the reverse of $A$.\n5.  The total number of inversions $I$ in $B$ is computed by direct enumeration, as specified. We iterate through all pairs of indices $(i, j)$ with $0 \\leq i  j  n$ and increment a counter if $B[i]  B[j]$. As argued, this count will be $I = \\frac{n(n-1)}{2}$.\n\nFor each test case, we compute the triplet $[k, B, I]$ and format the final output as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite and prints the result.\n    \"\"\"\n    # Use exactly the following test suite, in this order:\n    test_cases = [\n        [7],\n        [1, 2],\n        [1, 3, 4, 7, 9, 10, 15],\n        [-10, -5, 0, 2, 3, 8],\n        [2, 4, 6, 8, 12],\n    ]\n\n    results = []\n    for case in test_cases:\n        # The input numpy array is created from the test case list.\n        # This is a strictly increasing list of pairwise distinct integers.\n        A = np.array(case)\n        n = A.size\n        \n        # 1. Determine the minimal number of swaps.\n        # The target arrangement B that maximizes inversions is the reverse of A.\n        # The permutation to reverse a list of length n consists of floor(n/2)\n        # 2-cycles and (n mod 2) 1-cycles (fixed points).\n        # The number of cycles is c = floor(n/2) + (n mod 2) = ceil(n/2).\n        # The minimum number of swaps is k = n - c = n - ceil(n/2) = floor(n/2).\n        k = n // 2\n        \n        # 2. Perform the swaps to generate list B.\n        # This is done constructively by swapping symmetric elements.\n        B_array = A.copy()\n        for i in range(k):\n            # Swap element i with element n-1-i\n            B_array[i], B_array[n - 1 - i] = B_array[n - 1 - i], B_array[i]\n        \n        # Convert the numpy array to a standard Python list for the output.\n        B = B_array.tolist()\n        \n        # 3. Compute the inversion count of B by enumeration.\n        # An inversion is a pair of indices (i, j) with i  j and B[i] > B[j].\n        I = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if B[i] > B[j]:\n                    I += 1\n        \n        # The theoretical count is n*(n-1)/2, which can be used for verification.\n        # assert I == (n * (n - 1)) // 2\n        \n        # Append the result for the current test case.\n        results.append([k, B, I])\n\n    # Final print statement must produce the single-line format exactly.\n    # The str() representation of a list of lists adds spaces, which are removed\n    # to match the desired compact output format `[[k1,B1,I1],[k2,B2,I2],...]`.\n    output_str = str(results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```", "id": "3231396"}, {"introduction": "Our final practice moves from abstract analysis to a practical decision-making scenario common in software engineering. Not all data is perfectly random; it is often \"nearly sorted,\" and exploiting this structure is key to efficient processing. This problem challenges you to analyze how different elementary sorts perform on an array with a single reversed section, forcing you to compare their mechanics and select the most efficient tool for this specific kind of \"unsortedness.\"", "problem": "You are given an array of length $n$ with distinct keys that was initially sorted in nondecreasing order and then had a single contiguous sub-array of length $k$ reversed in place, where $2 \\le k \\le n$. Assume the unit-cost Random Access Machine (RAM) model in which each key comparison and each elementary move (swap or single-position shift) costs $1$. You will run one of the standard in-place elementary sorting algorithms on this array: bubble sort (with the usual early-exit optimization that stops when a pass makes no swaps), selection sort (standard version that repeatedly selects the minimum of the unsorted suffix), or insertion sort (standard version that scans left and shifts larger elements right to insert the key). Which of these three algorithms performs best on this particular input family, and what is its exact time complexity as a function of $n$ and $k$ under the stated cost model?\n\nChoose the single best option.\n\n- A. Insertion sort; its running time is $\\Theta\\!\\left(n + \\frac{k(k-1)}{2}\\right)$ on this input family, and it asymptotically outperforms bubble sort and selection sort.\n\n- B. Bubble sort with early-exit; its running time is $\\Theta(nk)$ on this input family, and no elementary sort can be asymptotically better here.\n\n- C. Selection sort; its running time is $\\Theta(n^2)$ but uses only $\\mathcal{O}(k)$ swaps on this input family, so it is best when $k$ is small.\n\n- D. Insertion sort; its running time is $\\Theta(n \\log k)$ on this input family because it exploits near-sortedness.", "solution": "### Analysis of Algorithms\nLet the initial sorted array be $A_{sorted} = (a_1, a_2, \\dots, a_n)$, where $a_i  a_{i+1}$ for all valid $i$. A contiguous sub-array of length $k$ starting at some index $j$ is reversed. The resulting array $A$ contains a sequence of elements that are in decreasing order relative to each other.\n\nA key property of such an array is its number of inversions. An inversion is a pair of indices $(i, l)$ such that $i  l$ and $A[i]  A[l]$. The only elements that can form an inversion are pairs from the reversed sub-array. The number of pairs of elements in a block of size $k$ is $\\binom{k}{2}$. Since all these pairs are in reversed order, the total number of inversions $I$ in the array is:\n$$I = \\binom{k}{2} = \\frac{k(k-1)}{2}$$\n\nWe will now analyze the time complexity of each algorithm under the given cost model, where Total Cost = (Number of Comparisons) + (Number of Moves).\n\n**1. Selection Sort**\nSelection sort works by repeatedly finding the minimum element in the unsorted suffix of the array and swapping it into place.\n- **Comparisons**: The number of comparisons is independent of the input array's initial order. The total number of comparisons is $\\sum_{i=0}^{n-2} (n-1-i) = \\frac{(n-1)n}{2}$. This is $\\Theta(n^2)$.\n- **Moves (Swaps)**: A swap occurs in pass $i$ only if the minimum element is not already at index $i$. The number of out-of-place elements is at most $k$, so the number of swaps is $\\mathcal{O}(k)$.\n- **Total Cost**: The total cost is the sum of comparisons and swaps. The $\\Theta(n^2)$ comparisons dominate the $\\mathcal{O}(k)$ swaps. Therefore, the total time complexity for selection sort is $\\Theta(n^2)$.\n\n**2. Bubble Sort (with Early-Exit Optimization)**\nBubble sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The early-exit optimization terminates the algorithm if a full pass completes with no swaps.\n- **Comparisons and Passes**: The number of passes is determined by the maximum distance an element is from its sorted position to the left (a \"turtle\"). The smallest element in the reversed block, initially at position $j+k-1$, needs to move to position $j$. This element requires $k-1$ passes to reach its destination. The algorithm will therefore perform $\\Theta(k)$ passes. Each pass involves $\\Theta(n)$ comparisons. This gives a total of $\\Theta(nk)$ comparisons.\n- **Moves (Swaps)**: Each swap in bubble sort resolves exactly one inversion. The total number of swaps is equal to the total number of inversions, which is $I = \\frac{k(k-1)}{2} = \\Theta(k^2)$.\n- **Total Cost**: The total cost is $\\Theta(nk)$ for comparisons plus $\\Theta(k^2)$ for swaps. Since $k \\le n$, $k^2 \\le nk$. Thus, the $\\Theta(nk)$ term dominates. The total time complexity for bubble sort is $\\Theta(nk)$.\n\n**3. Insertion Sort**\nInsertion sort builds the final sorted array one item at a time. In each iteration $i$, it takes the element $A[i]$ and inserts it into the correct position within the already-sorted prefix $A[0 \\dots i-1]$.\n- **Moves (Shifts)**: The total number of shifts in insertion sort is exactly equal to the number of inversions in the array. The total number of shifts is $I = \\frac{k(k-1)}{2} = \\Theta(k^2)$.\n- **Comparisons**: For each of the $n-1$ elements from $A[1]$ to $A[n-1]$ that are inserted, there is one comparison that stops the inner while-loop (or finishes the scan). Additionally, there is one comparison for every shift. The total number of comparisons is $(n-1) + I = (n-1) + \\frac{k(k-1)}{2}$.\n- **Total Cost**: The total cost is (Number of Shifts) + (Number of Comparisons) = $I + ((n-1)+I) = 2I + n-1$.\nSubstituting $I = \\frac{k(k-1)}{2}$:\n$$ \\text{Cost} = 2 \\left( \\frac{k(k-1)}{2} \\right) + n-1 = k(k-1) + n-1 $$\nThe asymptotic complexity is $\\Theta(n+k^2)$, which is equivalent to $\\Theta(n + \\frac{k(k-1)}{2})$.\n\n### Comparison and Conclusion\n\nWe compare the time complexities:\n- Selection Sort: $\\Theta(n^2)$\n- Bubble Sort: $\\Theta(nk)$\n- Insertion Sort: $\\Theta(n+k^2)$\n\n**Comparison:**\n- **Selection Sort vs. Others**: Since $k \\le n$, we have $nk \\le n^2$ and $n+k^2 \\le n+n^2 = \\Theta(n^2)$. Both bubble sort and insertion sort are asymptotically at least as good as selection sort. When $k=o(n)$, both are strictly better. Selection sort is the worst of the three.\n- **Bubble Sort vs. Insertion Sort**: We compare $\\Theta(nk)$ with $\\Theta(n+k^2)$.\n    - If $k = \\mathcal{O}(\\sqrt{n})$, then $k^2 = \\mathcal{O}(n)$. Insertion sort's complexity becomes $\\Theta(n)$. Bubble sort's is $\\Theta(nk)$. Since $k \\ge 2$, $\\Theta(n) \\le \\Theta(nk)$, making insertion sort better or equal.\n    - If $k = \\omega(\\sqrt{n})$, then $k^2 = \\omega(n)$. Insertion sort's complexity becomes $\\Theta(k^2)$. Bubble sort's is $\\Theta(nk)$. We compare $k^2$ with $nk$. Since $k \\le n$, we have $k^2 \\le nk$. Again, insertion sort is asymptotically better or equal.\n\nTherefore, **Insertion Sort** exhibits the best performance among the three algorithms for this family of inputs.\n\n**Evaluation of Options:**\n\n- **A. Insertion sort; its running time is $\\Theta\\!\\left(n + \\frac{k(k-1)}{2}\\right)$ on this input family, and it asymptotically outperforms bubble sort and selection sort.** This option correctly identifies insertion sort as the best-performing algorithm and provides the correct time complexity. The analysis confirms it outperforms the others.\n- **B. Bubble sort with early-exit; its running time is $\\Theta(nk)$ on this input family, and no elementary sort can be asymptotically better here.** The running time for bubble sort is correct, but the claim that it's the best is false.\n- **C. Selection sort; its running time is $\\Theta(n^2)$ but uses only $\\mathcal{O}(k)$ swaps on this input family, so it is best when $k$ is small.** The running time and swap count are correct, but the conclusion is false. For small $k$, insertion sort is much faster ($\\Theta(n)$ vs $\\Theta(n^2)$).\n- **D. Insertion sort; its running time is $\\Theta(n \\log k)$ on this input family because it exploits near-sortedness.** This option correctly identifies insertion sort but states an incorrect running time for the standard algorithm.\n\nBased on the analysis, option A is the only one that is entirely correct.", "answer": "$$\\boxed{A}$$", "id": "3231463"}]}