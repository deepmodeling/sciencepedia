{"hands_on_practices": [{"introduction": "Convolutional Neural Networks (CNNs) excel at pattern recognition, but the learned filters can often feel like a black box. This first exercise demystifies the concept of a filter by tasking you with designing one from scratch. By manually constructing the weights and bias for a convolutional filter to detect a specific biological sequence, you will gain a fundamental intuition for how these core components function as precise, engineered pattern matchers. [@problem_id:2373361]", "problem": "A prokaryotic messenger ribonucleic acid sequence is encoded for input to a Convolutional Neural Network (CNN) as a one-hot tensor over the alphabet $\\{A,C,G,U\\}$. At each nucleotide position $i$, the encoding is a column vector $x_i \\in \\{0,1\\}^{4}$ with channel order $(A,C,G,U)$, where exactly one entry equals $1$ and the others equal $0$. Consider a one-dimensional convolutional filter with kernel size $k=6$, input channels $4$, a single output channel, weight matrix $W \\in \\mathbb{R}^{4 \\times 6}$, and scalar bias $b \\in \\mathbb{R}$. When applied to a window of length $6$, the filter computes the linear score\n$$\ns \\;=\\; \\sum_{i=0}^{5} w_i^{\\top} x_i \\;+\\; b,\n$$\nwhere $w_i \\in \\mathbb{R}^{4}$ denotes the $i$-th column of $W$.\n\nLet the Shine-Dalgarno motif to be detected be the exact messenger ribonucleic acid sequence AGGAGG. Design $W$ and $b$ so that for any length-$6$ window, the score satisfies $s=6$ if and only if the window equals AGGAGG (in that order), and $s6$ otherwise. Provide your answer as a single row vector by flattening $W$ column-wise in the order $[A_0, C_0, G_0, U_0, A_1, C_1, G_1, U_1, \\dots, A_5, C_5, G_5, U_5]$ and then appending $b$ as the final entry, yielding a vector of length $25$. Express all entries as exact integers. No rounding is required.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded, well-posed, and objective. It presents a clear task in designing a component of a convolutional neural network for a specific bioinformatics application.\n\nThe task is to design a one-dimensional convolutional filter, defined by its weight matrix $W \\in \\mathbb{R}^{4 \\times 6}$ and scalar bias $b \\in \\mathbb{R}$, that acts as a perfect detector for the messenger ribonucleic acid (mRNA) sequence `AGGAGG`. The filter's score $s$ must equal $6$ if the length-$6$ input window is exactly `AGGAGG`, and must be strictly less than $6$ for any other sequence.\n\nThe input at each position $i$ is a one-hot encoded vector $x_i \\in \\{0, 1\\}^4$ corresponding to one of the four nucleotides in the alphabet $\\{A, C, G, U\\}$, with the channel order $(A, C, G, U)$. For a given nucleotide, only the corresponding entry in its vector representation is $1$, while all others are $0$. Let the weight vector for position $i$ be the $i$-th column of $W$, denoted as $w_i \\in \\mathbb{R}^4$. The components of $w_i$ are $(w_{i,A}, w_{i,C}, w_{i,G}, w_{i,U})^{\\top}$. The filter's score for a window $(x_0, x_1, \\dots, x_5)$ is given by:\n$$s = \\sum_{i=0}^{5} w_i^{\\top} x_i + b$$\nDue to the one-hot encoding, the dot product $w_i^{\\top} x_i$ serves to select exactly one weight from the vector $w_i$. If the nucleotide at position $i$ is $N_i$, then $w_i^{\\top} x_i = w_{i, N_i}$. The score can thus be rewritten as:\n$$s = \\sum_{i=0}^{5} w_{i, N_i} + b$$\nwhere $N_i$ is the nucleotide at position $i$ in the input window.\n\nThe target sequence is $S^* = \\text{AGGAGG}$. The corresponding sequence of nucleotides is $(N^*_0, N^*_1, N^*_2, N^*_3, N^*_4, N^*_5) = (A, G, G, A, G, G)$.\nOur objective is to create a matched filter. For each position $i$, the filter should assign the highest possible score contribution if the nucleotide $N_i$ matches the target $N^*_i$, and a lower contribution otherwise. To maximize the score for the target sequence and penalize any deviation, we will assign a weight of $1$ for a match at each position and a lesser value for a mismatch. The most straightforward design, which we will adopt, is to set the weight for a mismatch to $0$.\n\nFormally, for each position $i \\in \\{0, 1, ..., 5\\}$, we define the weights $w_{i,N}$ for each nucleotide $N \\in \\{A, C, G, U\\}$ as follows:\n$$w_{i,N} = \\begin{cases} 1  \\text{if } N = N^*_i \\\\ 0  \\text{if } N \\neq N^*_i \\end{cases}$$\n\nApplying this rule to the target sequence `AGGAGG`:\n-   For $i=0$, $N^*_0 = A$. So, $w_{0,A}=1$ and $w_{0,C}=w_{0,G}=w_{0,U}=0$. Thus, $w_0 = [1, 0, 0, 0]^{\\top}$.\n-   For $i=1$, $N^*_1 = G$. So, $w_{1,G}=1$ and $w_{1,A}=w_{1,C}=w_{1,U}=0$. Thus, $w_1 = [0, 0, 1, 0]^{\\top}$.\n-   For $i=2$, $N^*_2 = G$. So, $w_{2,G}=1$ and $w_{2,A}=w_{2,C}=w_{2,U}=0$. Thus, $w_2 = [0, 0, 1, 0]^{\\top}$.\n-   For $i=3$, $N^*_3 = A$. So, $w_{3,A}=1$ and $w_{3,C}=w_{3,G}=w_{3,U}=0$. Thus, $w_3 = [1, 0, 0, 0]^{\\top}$.\n-   For $i=4$, $N^*_4 = G$. So, $w_{4,G}=1$ and $w_{4,A}=w_{4,C}=w_{4,U}=0$. Thus, $w_4 = [0, 0, 1, 0]^{\\top}$.\n-   For $i=5$, $N^*_5 = G$. So, $w_{5,G}=1$ and $w_{5,A}=w_{5,C}=w_{5,U}=0$. Thus, $w_5 = [0, 0, 1, 0]^{\\top}$.\n\nNow we determine the bias $b$. The first condition states that if the input is the target sequence `AGGAGG`, the score must be $s=6$. For this sequence, every nucleotide $N_i$ equals the target nucleotide $N^*_i$. The score contribution from each position is therefore $w_{i,N^*_i} = 1$.\nThe total score $s^*$ is:\n$$s^* = \\sum_{i=0}^{5} w_{i,N^*_i} + b = (1+1+1+1+1+1) + b = 6 + b$$\nTo satisfy the condition $s^*=6$, we must have $6+b=6$, which implies $b=0$.\n\nNow we must verify the second condition: for any input sequence other than `AGGAGG`, the score must be strictly less than $6$.\nLet an arbitrary input sequence be $(N_0, N_1, \\dots, N_5)$. The score is $s = \\sum_{i=0}^5 w_{i,N_i} + 0$.\nThe contribution from each position, $w_{i,N_i}$, is $1$ if $N_i = N^*_i$ (a match) and $0$ if $N_i \\neq N^*_i$ (a mismatch).\nThe total score $s$ is therefore equal to the number of positions where the input sequence matches the target sequence `AGGAGG`. Let this number of matches be $m$. Then $s=m$.\nIf the input sequence is not `AGGAGG`, it must have at least one mismatch. Therefore, the number of matches $m$ must be less than $6$, i.e., $m \\in \\{0, 1, 2, 3, 4, 5\\}$.\nThis means the score will be $s = m \\le 5$, which satisfies the condition $s  6$.\nThe design is therefore correct.\n\nThe weight matrix $W$ is formed by these column vectors:\n$$W = \\begin{pmatrix} w_0  w_1  w_2  w_3  w_4  w_5 \\end{pmatrix} = \\begin{pmatrix} 1  0  0  1  0  0 \\\\ 0  0  0  0  0  0 \\\\ 0  1  1  0  1  1 \\\\ 0  0  0  0  0  0 \\end{pmatrix}$$\nThe bias is $b=0$.\n\nThe final answer must be a single row vector obtained by flattening $W$ column-wise and appending $b$.\nThe flattened vector from $W$ is $[w_{0,A}, w_{0,C}, w_{0,G}, w_{0,U}, w_{1,A}, \\dots, w_{5,U}]$.\nThis corresponds to concatenating the transposes of the column vectors $w_0, w_1, \\dots, w_5$.\nFlattened $W$: $[1, 0, 0, 0, \\quad 0, 0, 1, 0, \\quad 0, 0, 1, 0, \\quad 1, 0, 0, 0, \\quad 0, 0, 1, 0, \\quad 0, 0, 1, 0]$.\nAppending the bias $b=0$ at the end gives the final vector of length $25$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  0  0  0  0  0  1  0  0  0  1  0  1  0  0  0  0  0  1  0  0  0  1  0  0\n\\end{pmatrix}\n}\n$$", "id": "2373361"}, {"introduction": "Moving from individual components to the network as a whole, we now explore how global properties of the network's parameters influence its behavior. This practice connects the theoretical concept of regularization to the practical goals of stability and robustness. You will investigate how constraining the spectral norm of the weight matrices affects the network's Lipschitz constant—a measure of its sensitivity to input changes—and directly quantify the resulting improvement in robustness against perturbations. [@problem_id:3113400]", "problem": "Consider a fully connected two-layer feed-forward network with Rectified Linear Unit (ReLU) activation, mapping inputs $\\mathbf{x} \\in \\mathbb{R}^2$ to a scalar output. The model is\n$$\n\\mathbf{h}(\\mathbf{x}) = \\operatorname{ReLU}\\!\\left(W_1 \\mathbf{x} + \\mathbf{b}_1\\right), \\qquad\nf(\\mathbf{x}) = W_2 \\mathbf{h}(\\mathbf{x}) + b_2,\n$$\nwhere $W_1 \\in \\mathbb{R}^{3 \\times 2}$, $\\mathbf{b}_1 \\in \\mathbb{R}^3$, $W_2 \\in \\mathbb{R}^{1 \\times 3}$, and $b_2 \\in \\mathbb{R}$. Let the training set be the fixed collection $\\{(\\mathbf{x}_i, y_i)\\}_{i=1}^n$ with $n = 8$, $\\mathbf{x}_i \\in \\mathbb{R}^2$, and $y_i \\in \\{-1, +1\\}$.\n\nThe parameters are given numerically as follows:\n- $W_1 = \\begin{bmatrix} 1.0  0.5 \\\\ -0.3  1.2 \\\\ 0.7  -0.8 \\end{bmatrix}$, $\\mathbf{b}_1 = \\begin{bmatrix} 0.1 \\\\ -0.2 \\\\ 0.05 \\end{bmatrix}$,\n- $W_2 = \\begin{bmatrix} 0.9  0.7  -0.6 \\end{bmatrix}$, $b_2 = -0.1$.\n\nThe dataset is:\n- Positive class ($y=+1$): $\\mathbf{x}_1 = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$, $\\mathbf{x}_2 = \\begin{bmatrix} 1.2 \\\\ 0.9 \\end{bmatrix}$, $\\mathbf{x}_3 = \\begin{bmatrix} 0.8 \\\\ 1.1 \\end{bmatrix}$, $\\mathbf{x}_4 = \\begin{bmatrix} 1.1 \\\\ 1.2 \\end{bmatrix}$.\n- Negative class ($y=-1$): $\\mathbf{x}_5 = \\begin{bmatrix} -1.0 \\\\ -1.0 \\end{bmatrix}$, $\\mathbf{x}_6 = \\begin{bmatrix} -1.2 \\\\ -0.9 \\end{bmatrix}$, $\\mathbf{x}_7 = \\begin{bmatrix} -0.8 \\\\ -1.1 \\end{bmatrix}$, $\\mathbf{x}_8 = \\begin{bmatrix} -1.1 \\\\ -1.2 \\end{bmatrix}$.\n\nYou will enforce a spectral norm penalty on the linear layers via a deterministic rescaling rule parameterized by a nonnegative penalty strength $a \\ge 0$. For a given $a$, define the penalized weights by\n$$\n\\widetilde{W}_1(a) = \\frac{1}{1+a}\\, W_1,\\qquad \\widetilde{W}_2(a) = \\frac{1}{1+a}\\, W_2,\n$$\nwhile leaving the biases unchanged, that is, $\\widetilde{\\mathbf{b}}_1(a) = \\mathbf{b}_1$ and $\\widetilde{b}_2(a) = b_2$. This rule reduces the spectral norms of the linear maps monotonically as $a$ increases, reflecting the effect of the penalty $\\sum_\\ell \\|W_\\ell\\|_2$.\n\nYour tasks are:\n1. Starting only from core definitions in analysis and linear algebra, derive a computable upper bound on the global Lipschitz constant of the network $f$ as a function of the linear maps and the fact that the Rectified Linear Unit (ReLU) is $1$-Lipschitz. You must justify the bound using the definition of the operator norm and the $1$-Lipschitz property of the activation, and the composition rule for Lipschitz functions.\n2. Using the definition of Lipschitz continuity and of classification margin, derive a sample-wise lower bound on the minimum $\\ell_2$-norm perturbation required to flip the sign of $y_i f(\\mathbf{x}_i)$, expressed only in terms of the Lipschitz bound from Task $1$ and the signed margin $m_i = y_i f(\\mathbf{x}_i)$. Explain why examples with nonpositive margin contribute a lower bound of zero.\n3. Define the empirical $0$-$1$ risk (training classification error) as $\\widehat{R}(f) = \\frac{1}{n} \\sum_{i=1}^n \\mathbf{1}\\{y_i f(\\mathbf{x}_i) \\le 0\\}$. Compute it for each penalized model $f_a$ obtained by the rescaling rule above.\n\nImplement a program that, for each penalty parameter $a$ from the following test suite,\n- $a \\in \\{\\, 0,\\, 0.5,\\, 3,\\, 50 \\,\\}$,\nperforms the enforcement step to obtain $\\widetilde{W}_1(a)$ and $\\widetilde{W}_2(a)$, then computes:\n- a valid Lipschitz upper bound $L(a)$ for $f_a$ justified by your derivation,\n- the average sample-wise robustness lower bound $\\frac{1}{n}\\sum_{i=1}^n r_i(a)$, where $r_i(a)$ is the lower bound derived in Task $2$,\n- the empirical risk $\\widehat{R}(f_a)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list $[L(a), \\overline{r}(a), \\widehat{R}(f_a)]$ in this order for the corresponding $a$, with each value represented as a decimal. For example, an output with four test cases must have the form $[[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot]]$ on a single line. No physical units or angle units are involved; all values are real numbers.", "solution": "The problem is assessed to be valid as it is scientifically grounded in the principles of statistical learning, is well-posed with all necessary data provided, and is formulated objectively using standard mathematical definitions.\n\nHere we present the derivations and computational strategy. The network function $f_a: \\mathbb{R}^2 \\to \\mathbb{R}$ for a given penalty strength $a \\ge 0$ is defined by the composition\n$$\nf_a(\\mathbf{x}) = g_3(g_2(g_1(\\mathbf{x})))\n$$\nwhere\n- $g_1(\\mathbf{x}) = \\widetilde{W}_1(a) \\mathbf{x} + \\widetilde{\\mathbf{b}}_1(a) = \\frac{1}{1+a}W_1 \\mathbf{x} + \\mathbf{b}_1$\n- $g_2(\\mathbf{h}) = \\operatorname{ReLU}(\\mathbf{h})$\n- $g_3(\\mathbf{h}) = \\widetilde{W}_2(a) \\mathbf{h} + \\widetilde{b}_2(a) = \\frac{1}{1+a}W_2 \\mathbf{h} + b_2$\n\nAll vector norms $\\|\\cdot\\|$ are assumed to be the Euclidean $\\ell_2$-norm, and matrix norms $\\|\\cdot\\|_2$ are the corresponding induced operator norms (spectral norms).\n\n### Task 1: Derivation of a Global Lipschitz Constant Upper Bound\n\nA function $g: \\mathbb{R}^m \\to \\mathbb{R}^k$ is $L$-Lipschitz continuous if for all $\\mathbf{u}, \\mathbf{v} \\in \\mathbb{R}^m$, the inequality $\\|g(\\mathbf{u}) - g(\\mathbf{v})\\| \\le L \\|\\mathbf{u} - \\mathbf{v}\\|$ holds. The minimal such $L$ is the Lipschitz constant of $g$. A key property is that for a composition of Lipschitz functions, $g = g_N \\circ \\dots \\circ g_1$, the composite function is also Lipschitz with a constant $L_g \\le L_{g_N} \\cdots L_{g_1}$. We apply this to the network.\n\n1.  **Lipschitz constant of an affine map**: Let $g(\\mathbf{x}) = W\\mathbf{x} + \\mathbf{b}$. For any $\\mathbf{u}, \\mathbf{v}$, we have\n    $$\n    \\|g(\\mathbf{u}) - g(\\mathbf{v})\\| = \\|(W\\mathbf{u} + \\mathbf{b}) - (W\\mathbf{v} + \\mathbf{b})\\| = \\|W(\\mathbf{u} - \\mathbf{v})\\|\n    $$\n    By the definition of the induced operator norm, $\\|W\\mathbf{z}\\| \\le \\|W\\|_2 \\|\\mathbf{z}\\|$ for any vector $\\mathbf{z}$. Thus,\n    $$\n    \\|g(\\mathbf{u}) - g(\\mathbf{v})\\| \\le \\|W\\|_2 \\|\\mathbf{u} - \\mathbf{v}\\|\n    $$\n    The Lipschitz constant of an affine map is the spectral norm of its linear part. Therefore, the Lipschitz constants for $g_1$ and $g_3$ are $L_{g_1} = \\|\\widetilde{W}_1(a)\\|_2$ and $L_{g_3} = \\|\\widetilde{W}_2(a)\\|_2$, respectively.\n\n2.  **Lipschitz constant of the activation**: The problem states that the Rectified Linear Unit, $\\operatorname{ReLU}(z) = \\max(0, z)$, is $1$-Lipschitz. For the element-wise vector function $g_2(\\mathbf{h}) = \\operatorname{ReLU}(\\mathbf{h})$, its Lipschitz constant with respect to the $\\ell_2$-norm is also $1$. To see this,\n    $$\n    \\|g_2(\\mathbf{u}) - g_2(\\mathbf{v})\\|_2^2 = \\|\\operatorname{ReLU}(\\mathbf{u}) - \\operatorname{ReLU}(\\mathbf{v})\\|_2^2 = \\sum_j (\\operatorname{ReLU}(u_j) - \\operatorname{ReLU}(v_j))^2\n    $$\n    Since the scalar ReLU is $1$-Lipschitz, $|\\operatorname{ReLU}(u_j) - \\operatorname{ReLU}(v_j)| \\le |u_j - v_j|$. Squaring both sides yields $(\\operatorname{ReLU}(u_j) - \\operatorname{ReLU}(v_j))^2 \\le (u_j - v_j)^2$. Summing over all components gives\n    $$\n    \\sum_j (\\operatorname{ReLU}(u_j) - \\operatorname{ReLU}(v_j))^2 \\le \\sum_j (u_j - v_j)^2 \\implies \\|g_2(\\mathbf{u}) - g_2(\\mathbf{v})\\|_2^2 \\le \\|\\mathbf{u} - \\mathbf{v}\\|_2^2\n    $$\n    Taking the square root, we find $\\|g_2(\\mathbf{u}) - g_2(\\mathbf{v})\\|_2 \\le \\|\\mathbf{u} - \\mathbf{v}\\|_2$. Thus, $L_{g_2} = 1$.\n\n3.  **Composition**: The Lipschitz constant of the full network, $L(f_a)$, is bounded by the product of the individual constants:\n    $$\n    L(f_a) \\le L_{g_3} \\cdot L_{g_2} \\cdot L_{g_1} = \\|\\widetilde{W}_2(a)\\|_2 \\cdot 1 \\cdot \\|\\widetilde{W}_1(a)\\|_2\n    $$\n    Using the penalization rule $\\widetilde{W}_\\ell(a) = \\frac{1}{1+a}W_\\ell$ and the property $\\|\\lambda W\\|_2 = |\\lambda|\\|W\\|_2$, we obtain the upper bound, which we denote $L(a)$:\n    $$\n    L(a) = \\left\\| \\frac{1}{1+a}W_2 \\right\\|_2 \\left\\| \\frac{1}{1+a}W_1 \\right\\|_2 = \\frac{1}{(1+a)^2} \\|W_2\\|_2 \\|W_1\\|_2\n    $$\n    This is the computable upper bound for the Lipschitz constant of $f_a$.\n\n### Task 2: Derivation of a Sample-Wise Robustness Lower Bound\n\nWe aim to find a lower bound on the $\\ell_2$-norm of a perturbation $\\mathbf{\\delta}$ that flips the classification of a sample $(\\mathbf{x}_i, y_i)$. A sign flip occurs if $y_i f_a(\\mathbf{x}_i + \\mathbf{\\delta}) \\le 0$, given that the original classification was correct, i.e., $y_i f_a(\\mathbf{x}_i)  0$. The signed margin is $m_i(a) = y_i f_a(\\mathbf{x}_i)$.\n\n1.  **Case 1: Correctly classified sample** ($m_i(a)  0$).\n    By the definition of the Lipschitz constant $L(a)$ for $f_a$:\n    $$\n    |f_a(\\mathbf{x}_i + \\mathbf{\\delta}) - f_a(\\mathbf{x}_i)| \\le L(a) \\|\\mathbf{\\delta}\\|_2\n    $$\n    Multiplying by $|y_i|=1$ does not change the inequality:\n    $$\n    |y_i f_a(\\mathbf{x}_i + \\mathbf{\\delta}) - y_i f_a(\\mathbf{x}_i)| \\le L(a) \\|\\mathbf{\\delta}\\|_2\n    $$\n    This is equivalent to the two-sided inequality:\n    $$\n    -L(a) \\|\\mathbf{\\delta}\\|_2 \\le y_i f_a(\\mathbf{x}_i + \\mathbf{\\delta}) - y_i f_a(\\mathbf{x}_i) \\le L(a) \\|\\mathbf{\\delta}\\|_2\n    $$\n    Rearranging the left side gives a lower bound on the perturbed margin:\n    $$\n    y_i f_a(\\mathbf{x}_i + \\mathbf{\\delta}) \\ge y_i f_a(\\mathbf{x}_i) - L(a) \\|\\mathbf{\\delta}\\|_2 = m_i(a) - L(a) \\|\\mathbf{\\delta}\\|_2\n    $$\n    For a sign flip to be possible, the new margin $y_i f_a(\\mathbf{x}_i + \\mathbf{\\delta})$ must be capable of becoming non-positive. This requires its lower bound to be non-positive:\n    $$\n    m_i(a) - L(a) \\|\\mathbf{\\delta}\\|_2 \\le 0\n    $$\n    This implies that any successful perturbation $\\mathbf{\\delta}$ must satisfy:\n    $$\n    \\|\\mathbf{\\delta}\\|_2 \\ge \\frac{m_i(a)}{L(a)}\n    $$\n    Therefore, $\\frac{m_i(a)}{L(a)}$ is a lower bound on the magnitude of the minimal perturbation required to cause a misclassification.\n\n2.  **Case 2: Incorrectly classified sample** ($m_i(a) \\le 0$).\n    If the sample is already misclassified or lies on the decision boundary, the condition $y_i f_a(\\mathbf{x}_i + \\mathbf{\\delta}) \\le 0$ is satisfied by the null perturbation $\\mathbf{\\delta} = \\mathbf{0}$. The norm of this perturbation is $\\|\\mathbf{0}\\|_2 = 0$. Thus, the lower bound on the required perturbation norm is $0$.\n\nCombining both cases, the sample-wise robustness lower bound $r_i(a)$ can be expressed as:\n$$\nr_i(a) = \\frac{\\max(0, m_i(a))}{L(a)} = \\frac{\\max(0, y_i f_a(\\mathbf{x}_i))}{L(a)}\n$$\nThe average lower bound is $\\overline{r}(a) = \\frac{1}{n} \\sum_{i=1}^n r_i(a)$.\n\n### Task 3: Empirical 0-1 Risk\n\nThe empirical $0$-$1$ risk, or training classification error, measures the fraction of samples in the training set that are misclassified by the model. It is defined as the average of the $0$-$1$ loss over the dataset $\\{(\\mathbf{x}_i, y_i)\\}_{i=1}^n$. The $0$-$1$ loss function is given by $\\mathbf{1}\\{y f(\\mathbf{x}) \\le 0\\}$, where $\\mathbf{1}\\{\\cdot\\}$ is the indicator function ($1$ if the condition is true, $0$ otherwise).\nThe empirical risk is therefore:\n$$\n\\widehat{R}(f_a) = \\frac{1}{n} \\sum_{i=1}^n \\mathbf{1}\\{y_i f_a(\\mathbf{x}_i) \\le 0\\} = \\frac{1}{n} \\sum_{i=1}^n \\mathbf{1}\\{m_i(a) \\le 0\\}\n$$\nThis is computed by evaluating the model on all $n=8$ training samples, checking the sign of the margin for each, counting the number of non-positive margins, and dividing by $n$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Lipschitz bound, robustness bound, and risk for a two-layer NN.\n    \"\"\"\n    # 1. Define the initial network parameters and dataset.\n    W1 = np.array([\n        [1.0, 0.5],\n        [-0.3, 1.2],\n        [0.7, -0.8]\n    ])\n    b1 = np.array([0.1, -0.2, 0.05])\n    \n    W2 = np.array([[0.9, 0.7, -0.6]])\n    b2 = -0.1\n\n    # Dataset\n    X = np.array([\n        [1.0, 1.0], [1.2, 0.9], [0.8, 1.1], [1.1, 1.2],  # Positive class\n        [-1.0, -1.0], [-1.2, -0.9], [-0.8, -1.1], [-1.1, -1.2]  # Negative class\n    ])\n    y = np.array([1, 1, 1, 1, -1, -1, -1, -1])\n    n = len(y)\n\n    # Test suite for penalty parameter 'a'\n    a_values = [0.0, 0.5, 3.0, 50.0]\n\n    # 2. Pre-compute constant parts of the Lipschitz bound.\n    # The spectral norm (ord=2) of a 1D array is its Euclidean norm.\n    norm_W1 = np.linalg.norm(W1, ord=2)\n    norm_W2 = np.linalg.norm(W2, ord=2)\n    L0 = norm_W1 * norm_W2\n\n    # 3. Define the network's forward pass.\n    def forward_pass(x_in, w1_p, b1_p, w2_p, b2_p):\n        \"\"\"Computes the forward pass of the neural network.\"\"\"\n        # Layer 1: linear transformation + bias\n        z1 = x_in @ w1_p.T + b1_p\n        # Layer 1: ReLU activation\n        h = np.maximum(0, z1)\n        # Layer 2: linear transformation + bias\n        output = h @ w2_p.T + b2_p\n        return output.flatten()\n\n    results = []\n    # 4. Iterate through each penalty parameter 'a' and perform computations.\n    for a in a_values:\n        # Enforce the spectral norm penalty on weights\n        factor = 1.0 / (1.0 + a)\n        W1_a = W1 * factor\n        W2_a = W2 * factor\n        # Biases remain unchanged as per the problem statement\n        b1_a = b1\n        b2_a = b2\n\n        # Task 1: Compute the Lipschitz upper bound L(a)\n        # L(a) = ||W2_a|| * ||W1_a|| = (1/(1+a))^2 * ||W2|| * ||W1||\n        L_a = L0 / ((1.0 + a) ** 2)\n\n        # Compute network outputs for the current penalized model f_a\n        outputs_a = forward_pass(X, W1_a, b1_a, W2_a, b2_a)\n        \n        # Compute signed margins m_i(a) = y_i * f_a(x_i)\n        margins_a = y * outputs_a\n\n        # Task 2: Compute the average sample-wise robustness lower bound r_bar(a)\n        # r_i(a) = max(0, m_i(a)) / L(a)\n        if L_a > 0:\n            robustness_bounds = np.maximum(0, margins_a) / L_a\n        else: # Handle a -> infinity case where L_a -> 0\n            # If margin is positive, bound is infinite. If zero/negative, it's zero.\n            # Not strictly needed for the given 'a' values but good practice.\n            robustness_bounds = np.zeros_like(margins_a)\n            robustness_bounds[margins_a > 0] = np.inf\n            \n        r_bar_a = np.mean(robustness_bounds)\n\n        # Task 3: Compute the empirical 0-1 risk R_hat(f_a)\n        # R_hat = (1/n) * sum(I(m_i(a) = 0))\n        num_errors = np.sum(margins_a = 0)\n        R_hat_a = num_errors / n\n        \n        # Store results for this 'a'\n        results.append([L_a, r_bar_a, R_hat_a])\n\n    # 5. Format and print the final output as specified.\n    formatted_results = [f\"[{res[0]},{res[1]},{res[2]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3113400"}, {"introduction": "The process of training a neural network finds a single point in a vast parameter space that minimizes loss. But what does the neighborhood around this solution look like, and are there other, distant solutions that are equally good? This final exercise takes you on a tour of the neural network loss landscape to explore the concept of \"mode connectivity\". By examining the loss along a linear path between two different solutions, you will investigate whether they reside in the same connected basin of low loss and discover how symmetries in the network can lead to functionally identical but parametrically distinct solutions. [@problem_id:3113426]", "problem": "You are asked to examine mode connectivity in a simple two-layer neural network by evaluating empirical risk along linear parameter paths and quantifying representation consistency. The goal is to implement a program that, for a set of prescribed test cases, determines whether the endpoints are connected by a low-loss linear path in parameter space and reports a representation consistency statistic.\n\nDefinitions, model, and dataset:\n- Consider a two-layer feed-forward neural network with Rectified Linear Unit (ReLU) activation. The hypothesis class is\n$$\nf_{\\theta}(x) \\;=\\; W_2 \\,\\sigma\\!\\left(W_1 x + b_1\\right) + b_2,\n$$\nwith parameters $\\theta=(W_1,b_1,W_2,b_2)$, where $\\sigma(z)=\\max\\{0,z\\}$ is applied elementwise, input $x\\in\\mathbb{R}^d$, hidden width $h$, and output dimension $1$. In all test cases use $d=h=2$, $b_1=\\mathbf{0}\\in\\mathbb{R}^2$, and $b_2=0$.\n- Use the dataset $\\{(x_i,y_i)\\}_{i=1}^n$ with $n=6$ input vectors and scalar labels:\n  - Inputs $x_1=\\begin{bmatrix}1\\\\0\\end{bmatrix}$, $x_2=\\begin{bmatrix}0\\\\1\\end{bmatrix}$, $x_3=\\begin{bmatrix}1\\\\1\\end{bmatrix}$, $x_4=\\begin{bmatrix}1\\\\-1\\end{bmatrix}$, $x_5=\\begin{bmatrix}-1\\\\1\\end{bmatrix}$, $x_6=\\begin{bmatrix}-1\\\\-1\\end{bmatrix}$.\n  - Labels are defined by a fixed target function $y_i=\\max\\{0, x_{i,1}\\}+\\max\\{0, x_{i,2}\\}$, for $i\\in\\{1,\\dots,6\\}$.\n- Empirical risk is the Mean Squared Error (MSE), a special case of Empirical Risk Minimization (ERM):\n$$\nL(\\theta)\\;=\\;\\frac{1}{n}\\sum_{i=1}^n \\left( f_{\\theta}(x_i) - y_i \\right)^2.\n$$\n\nLinear parameter path and objectives:\n- For two parameter sets $\\theta_a$ and $\\theta_b$, define the linear interpolation in parameter space\n$$\n\\theta(t) \\;=\\; (1-t)\\,\\theta_a + t\\,\\theta_b,\\quad t\\in[0,1],\n$$\napplied componentwise to $W_1$, $b_1$, $W_2$, and $b_2$.\n- For a finite grid $T=\\{t_k\\}_{k=0}^{m-1}$ with $m=21$ equally spaced values in $[0,1]$ (i.e., $t_k=\\frac{k}{20}$), evaluate the empirical risk along the path: $\\{L(\\theta(t_k))\\}_{k=0}^{m-1}$.\n- Define the loss barrier height\n$$\nB(\\theta_a,\\theta_b)\\;=\\;\\max_{t\\in T} L(\\theta(t)) \\;-\\; \\max\\{L(\\theta_a),\\,L(\\theta_b)\\}.\n$$\nA pair $(\\theta_a,\\theta_b)$ is said to be linearly mode-connected at tolerance $\\delta$ if $B(\\theta_a,\\theta_b)\\le \\delta$. In this problem use $\\delta=10^{-9}$.\n- Define the hidden representation on the dataset at parameter $\\theta$ as the stacked hidden activations\n$$\nH(\\theta) \\;\\in\\; \\mathbb{R}^{n\\times h},\\qquad H(\\theta)_{i,:} \\;=\\; \\sigma\\!\\left(W_1 x_i + b_1\\right)^{\\top}.\n$$\nLet $v(\\theta)\\in\\mathbb{R}^{nh}$ be the vectorization of $H(\\theta)$ by row-major flattening. Define cosine similarity\n$$\n\\mathrm{sim}(u,v)\\;=\\;\\frac{\\langle u,v\\rangle}{\\|u\\|_2\\,\\|v\\|_2},\n$$\nwith the conventions: if $\\|u\\|_2=\\|v\\|_2=0$ then $\\mathrm{sim}(u,v)=1$, and if exactly one of $\\|u\\|_2$ or $\\|v\\|_2$ is $0$ then $\\mathrm{sim}(u,v)=0$.\n- For the path $\\theta(t)$, define the representation consistency at $t$ as\n$$\nR(t)\\;=\\;\\max\\!\\left\\{\\,\\mathrm{sim}\\big(v(\\theta(t)),v(\\theta_a)\\big),\\;\\mathrm{sim}\\big(v(\\theta(t)),v(\\theta_b)\\big)\\right\\}.\n$$\nSummarize a path by its worst-case representation consistency\n$$\nR_{\\min}\\;=\\;\\min_{t\\in T} R(t).\n$$\n\nTest suite:\nEvaluate the following three test cases. In all cases take $b_1=\\mathbf{0}$ and $b_2=0$.\n- Case $\\#1$ (identical endpoints):\n  - $\\theta_a$: $W_{1,a}=\\begin{bmatrix}1  0\\\\ 0  1\\end{bmatrix}$, $W_{2,a}=\\begin{bmatrix}1  1\\end{bmatrix}$.\n  - $\\theta_b$: $W_{1,b}=\\begin{bmatrix}1  0\\\\ 0  1\\end{bmatrix}$, $W_{2,b}=\\begin{bmatrix}1  1\\end{bmatrix}$.\n- Case $\\#2$ (permuted hidden units):\n  - $\\theta_a$: $W_{1,a}=\\begin{bmatrix}1  0\\\\ 0  1\\end{bmatrix}$, $W_{2,a}=\\begin{bmatrix}1  1\\end{bmatrix}$.\n  - $\\theta_b$: $W_{1,b}=\\begin{bmatrix}0  1\\\\ 1  0\\end{bmatrix}$, $W_{2,b}=\\begin{bmatrix}1  1\\end{bmatrix}$.\n- Case $\\#3$ (small perturbation):\n  - $\\theta_a$: $W_{1,a}=\\begin{bmatrix}1  0\\\\ 0  1\\end{bmatrix}$, $W_{2,a}=\\begin{bmatrix}1  1\\end{bmatrix}$.\n  - $\\theta_b$: $W_{1,b}=\\begin{bmatrix}1  0.05\\\\ 0.05  1\\end{bmatrix}$, $W_{2,b}=\\begin{bmatrix}1  1\\end{bmatrix}$.\n\nWhat you must implement:\n- For each case, compute:\n  - The barrier $B(\\theta_a,\\theta_b)$ over the grid $T$ and the boolean connectivity decision $\\mathbf{conn}=\\big(B(\\theta_a,\\theta_b)\\le \\delta\\big)$.\n  - The worst-case representation consistency $R_{\\min}$ over the same grid $T$.\n- Output format:\n  - Your program should produce a single line of output containing a list with one element per test case. Each element must itself be a two-element list of the form $[\\mathbf{conn}, r]$, where $\\mathbf{conn}$ is a boolean and $r$ is a floating-point number equal to $R_{\\min}$ rounded to six decimal places.\n  - Concretely, the output must look like a single Python-style list literal on one line, for example $[[\\text{boolean}, \\text{float}], [\\text{boolean}, \\text{float}], [\\text{boolean}, \\text{float}]]$.\n\nScientific starting points only:\n- Use only the fundamentals of Empirical Risk Minimization (ERM), Mean Squared Error (MSE), the definition of a Rectified Linear Unit (ReLU), linear interpolation in parameter space, and cosine similarity to derive your computations.\n- Angles or physical units are not involved, so no unit conventions are required beyond the definitions above.\n\nYour task:\n- Implement a complete program that performs the computations as specified for the three cases above and prints the results in the exact output format described.", "solution": "The user has requested an analysis of mode connectivity for a simple two-layer neural network. This requires validating the problem statement, and if it is found to be valid, providing a detailed solution and a corresponding Python implementation.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n*   **Model ($f_{\\theta}(x)$)**: A two-layer feed-forward neural network with ReLU activation, $f_{\\theta}(x) = W_2 \\sigma(W_1 x + b_1) + b_2$.\n*   **Parameters ($\\theta$)**: $\\theta=(W_1,b_1,W_2,b_2)$.\n*   **Activation function ($\\sigma$)**: Elementwise ReLU, $\\sigma(z)=\\max\\{0,z\\}$.\n*   **Dimensions**: Input dimension $d=2$, hidden width $h=2$, output dimension $1$.\n*   **Fixed Parameters**: For all test cases, the biases are zero: $b_1=\\mathbf{0}\\in\\mathbb{R}^2$ and $b_2=0$.\n*   **Dataset**: $n=6$ input-output pairs $\\{(x_i,y_i)\\}_{i=1}^6$.\n    *   Inputs $X$: $x_1=\\begin{bmatrix}1\\\\0\\end{bmatrix}, x_2=\\begin{bmatrix}0\\\\1\\end{bmatrix}, x_3=\\begin{bmatrix}1\\\\1\\end{bmatrix}, x_4=\\begin{bmatrix}1\\\\-1\\end{bmatrix}, x_5=\\begin{bmatrix}-1\\\\1\\end{bmatrix}, x_6=\\begin{bmatrix}-1\\\\-1\\end{bmatrix}$.\n    *   Labels $Y$: $y_i=\\max\\{0, x_{i,1}\\}+\\max\\{0, x_{i,2}\\}$.\n*   **Empirical Risk ($L(\\theta)$)**: Mean Squared Error (MSE), $L(\\theta) = \\frac{1}{n}\\sum_{i=1}^n ( f_{\\theta}(x_i) - y_i )^2$.\n*   **Parameter Path**: Linear interpolation $\\theta(t) = (1-t)\\theta_a + t\\theta_b$ for $t\\in[0,1]$.\n*   **Evaluation Grid ($T$)**: $m=21$ equally spaced points in $[0,1]$, $t_k=k/(m-1) = k/20$.\n*   **Loss Barrier ($B(\\theta_a,\\theta_b)$)**: $B(\\theta_a,\\theta_b) = \\max_{t\\in T} L(\\theta(t)) - \\max\\{L(\\theta_a), L(\\theta_b)\\}$.\n*   **Connectivity Condition**: Linearly mode-connected if $B(\\theta_a,\\theta_b) \\le \\delta$, with tolerance $\\delta=10^{-9}$.\n*   **Hidden Representation ($H(\\theta)$)**: $n \\times h$ matrix where $H(\\theta)_{i,:} = \\sigma(W_1 x_i + b_1)^{\\top}$.\n*   **Vectorized Representation ($v(\\theta)$)**: Row-major flattened vector of $H(\\theta)$, $v(\\theta) \\in \\mathbb{R}^{nh}$.\n*   **Cosine Similarity ($\\mathrm{sim}(u,v)$)**: $\\frac{\\langle u,v\\rangle}{\\|u\\|_2\\,\\|v\\|_2}$. Conventions: $\\mathrm{sim}=1$ if $\\|u\\|_2=\\|v\\|_2=0$; $\\mathrm{sim}=0$ if one norm is zero.\n*   **Representation Consistency ($R(t)$)**: $R(t) = \\max\\{\\mathrm{sim}(v(\\theta(t)),v(\\theta_a)), \\mathrm{sim}(v(\\theta(t)),v(\\theta_b))\\}$.\n*   **Worst-Case Consistency ($R_{\\min}$)**: $R_{\\min} = \\min_{t\\in T} R(t)$.\n*   **Test Cases**:\n    1.  **Identical**: $\\theta_a=\\theta_b$ with $W_{1,a}=\\begin{bmatrix}1  0\\\\ 0  1\\end{bmatrix}, W_{2,a}=\\begin{bmatrix}1  1\\end{bmatrix}$.\n    2.  **Permuted**: $\\theta_a$ as in Case 1. $\\theta_b$ has $W_{1,b}=\\begin{bmatrix}0  1\\\\ 1  0\\end{bmatrix}, W_{2,b}=\\begin{bmatrix}1  1\\end{bmatrix}$.\n    3.  **Perturbed**: $\\theta_a$ as in Case 1. $\\theta_b$ has $W_{1,b}=\\begin{bmatrix}1  0.05\\\\ 0.05  1\\end{bmatrix}, W_{2,b}=\\begin{bmatrix}1  1\\end{bmatrix}$.\n*   **Output Specification**: A single line printing a Python list of lists: `[[conn, r], [conn, r], [conn, r]]`, where `conn` is a boolean and `r` is $R_{\\min}$ rounded to 6 decimal places.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is scientifically grounded in the domain of deep learning theory, specifically the study of loss landscapes and model symmetries. It is well-posed, with all necessary data, parameters, and definitions provided for a unique, deterministic computation. The language is objective and formal. There are no contradictions, missing information, or violations of scientific principles. The computational task is feasible and the definitions are standard within the field.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A solution will be developed and implemented.\n\n### Derivation and Solution Design\n\nThe problem requires implementing a computational procedure to evaluate properties of linear paths in the parameter space of a simple neural network. We will structure the solution by first defining the core components and then applying them to the specified test cases.\n\n**1. Model and Loss Function**\nThe model simplifies due to the zero-bias constraints ($b_1=\\mathbf{0}, b_2=0$) to:\n$$\nf_{\\theta}(x) = W_2 \\sigma(W_1 x)\n$$\nThe parameters are $\\theta = (W_1, W_2)$. The empirical risk $L(\\theta)$ is the mean of squared differences between $f_{\\theta}(x_i)$ and the target labels $y_i=\\max\\{0, x_{i,1}\\}+\\max\\{0, x_{i,2}\\}$ over the dataset.\n\nIt is instructive to analyze the function represented by the parameters in Case #1. Here, $W_{1,a} = I$ (the identity matrix) and $W_{2,a} = \\begin{bmatrix}1  1\\end{bmatrix}$. The network computes:\n$$\nf_{\\theta_a}(x) = \\begin{bmatrix}1  1\\end{bmatrix} \\sigma\\left(\\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix} \\begin{bmatrix}x_1 \\\\ x_2\\end{bmatrix}\\right) = \\begin{bmatrix}1  1\\end{bmatrix} \\begin{bmatrix}\\max\\{0, x_1\\} \\\\ \\max\\{0, x_2\\}\\end{bmatrix} = \\max\\{0, x_1\\} + \\max\\{0, x_2\\}\n$$\nThis is precisely the target function $y$. Thus, for $\\theta_a$ (and any other $\\theta$ defining the same function), the loss $L(\\theta)$ is $0$.\n\n**2. Path Interpolation and Analysis**\nFor each test case, we consider two endpoints $\\theta_a$ and $\\theta_b$. The linear path is defined by $\\theta(t) = ((1-t)W_{1,a} + tW_{1,b}, (1-t)W_{2,a} + tW_{2,b})$ for $t \\in [0, 1]$. We discretize this path using a grid $T=\\{0, 1/20, 2/20, \\dots, 1\\}$.\n\nFor each $t_k \\in T$, we must compute:\n-   **Loss $L(\\theta(t_k))$**: This involves performing a forward pass for each of the $n=6$ data points with the interpolated parameters $\\theta(t_k)$ and calculating the MSE.\n-   **Representation Consistency $R(t_k)$**: This requires:\n    a.  Computing the hidden representations $H(\\theta_a)$, $H(\\theta_b)$, and $H(\\theta(t_k))$. The $(i,:)$ row of $H(\\theta)$ is $\\sigma(W_1 x_i)^\\top$.\n    b.  Vectorizing these matrices into $v(\\theta_a)$, $v(\\theta_b)$, and $v(\\theta(t_k))$.\n    c.  Calculating the cosine similarities $\\mathrm{sim}(v(\\theta(t_k)), v(\\theta_a))$ and $\\mathrm{sim}(v(\\theta(t_k)), v(\\theta_b))$ using the provided definition and conventions for zero vectors.\n    d.  $R(t_k)$ is the maximum of these two similarities.\n\n**3. Final Metrics**\nAfter evaluating the path properties on the grid $T$, we compute the summary statistics for each test case:\n-   **Barrier Height $B(\\theta_a, \\theta_b)$**: Calculated from the collected losses $\\{L(\\theta(t_k))\\}$ as $\\max_{k} L(\\theta(t_k)) - \\max\\{L(\\theta(t_0)), L(\\theta(t_{m-1}))\\}$.\n-   **Connectivity $\\mathbf{conn}$**: A boolean, `True` if $B(\\theta_a, \\theta_b) \\le 10^{-9}$, `False` otherwise.\n-   **Worst-Case Consistency $R_{\\min}$**: The minimum value among the collected consistencies, $\\min_{k} R(t_k)$.\n\nThe procedure will be systematically applied to each of the three test cases.\n\n-   **Case #1 (Identical)**: Since $\\theta_a=\\theta_b$, the path is constant: $\\theta(t)=\\theta_a$ for all $t$. The loss $L(\\theta(t_k))$ will be $0$ for all $k$. Thus, $B=0$, and $\\mathbf{conn}$ is `True`. The representation $v(\\theta(t_k))$ is also constant and identical to $v(\\theta_a)$ and $v(\\theta_b)$, so $\\mathrm{sim}=1$ for all $k$. Thus, $R_{\\min}=1$.\n\n-   **Case #2 (Permuted)**: Here, $\\theta_b$ represents the same function as $\\theta_a$ but with the hidden neurons swapped. $W_{1,b}$ is a permutation matrix, and $W_{2,b}$ is symmetric, so the permutation's effect is canceled. Thus $L(\\theta_a)=L(\\theta_b)=0$. However, linear interpolation between these permuted solutions is known to pass through a high-loss region where the network's effective capacity is reduced. We expect $B  \\delta$ and $\\mathbf{conn}$ to be `False`. The representations will also diverge along the path, especially near $t=0.5$, leading to an $R_{\\min}  1$.\n\n-   **Case #3 (Perturbed)**: $\\theta_b$ is a small perturbation of $\\theta_a$. Both points lie within the same low-loss basin. The linear path between them is expected to remain in this basin. We anticipate a very small loss barrier $B \\approx 0$, so $\\mathbf{conn}$ should be `True`. The hidden representations should remain very similar along the path, yielding an $R_{\\min}$ very close to $1$.\n\nThe implementation will follow this logic, creating helper functions for the forward pass, loss, representation extraction, and similarity calculation, then iterating through the test cases to compute and format the final results.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the mode connectivity problem for the given test cases.\n    \"\"\"\n\n    # --- Problem Definitions ---\n\n    # Dataset\n    X = np.array([\n        [1, 0], [0, 1], [1, 1], [1, -1], [-1, 1], [-1, -1]\n    ])\n    # Target function y = max(0, x_1) + max(0, x_2)\n    Y = np.maximum(0, X[:, 0]) + np.maximum(0, X[:, 1])\n    n = X.shape[0]\n\n    # Parameters for analysis\n    m = 21  # Number of grid points\n    delta = 1e-9  # Connectivity tolerance\n    t_grid = np.linspace(0.0, 1.0, m)\n\n    # --- Helper Functions ---\n\n    def relu(z):\n        \"\"\"Element-wise Rectified Linear Unit.\"\"\"\n        return np.maximum(0, z)\n\n    def forward_pass(W1, W2, x):\n        \"\"\"Computes the network output for a single input vector x.\"\"\"\n        # Biases b1 and b2 are zero\n        a1 = relu(W1 @ x)\n        output = W2 @ a1\n        return output[0] # Return scalar\n\n    def mse_loss(W1, W2, X_data, Y_data):\n        \"\"\"Computes the Mean Squared Error loss over the dataset.\"\"\"\n        squared_errors = []\n        for i in range(X_data.shape[0]):\n            y_pred = forward_pass(W1, W2, X_data[i])\n            squared_errors.append((y_pred - Y_data[i])**2)\n        return np.mean(squared_errors)\n\n    def get_vectorized_representation(W1, X_data):\n        \"\"\"Computes the vectorized hidden representation v(theta).\"\"\"\n        # H(theta) is n x h\n        h = W1.shape[0]\n        n_data = X_data.shape[0]\n        H = np.zeros((n_data, h))\n        for i in range(n_data):\n            H[i, :] = relu(W1 @ X_data[i])\n        return H.flatten() # Row-major flattening by default\n\n    def cosine_similarity(u, v):\n        \"\"\"Computes cosine similarity with special conventions for zero vectors.\"\"\"\n        norm_u = np.linalg.norm(u)\n        norm_v = np.linalg.norm(v)\n\n        if norm_u == 0 and norm_v == 0:\n            return 1.0\n        if norm_u == 0 or norm_v == 0:\n            return 0.0\n        \n        return np.dot(u, v) / (norm_u * norm_v)\n\n    # --- Test Case Definitions ---\n\n    # Case #1: Identical endpoints\n    W1_a1 = np.array([[1.0, 0.0], [0.0, 1.0]])\n    W2_a1 = np.array([[1.0, 1.0]])\n    W1_b1 = np.array([[1.0, 0.0], [0.0, 1.0]])\n    W2_b1 = np.array([[1.0, 1.0]])\n\n    # Case #2: Permuted hidden units\n    W1_a2 = np.array([[1.0, 0.0], [0.0, 1.0]])\n    W2_a2 = np.array([[1.0, 1.0]])\n    W1_b2 = np.array([[0.0, 1.0], [1.0, 0.0]])\n    W2_b2 = np.array([[1.0, 1.0]])\n\n    # Case #3: Small perturbation\n    W1_a3 = np.array([[1.0, 0.0], [0.0, 1.0]])\n    W2_a3 = np.array([[1.0, 1.0]])\n    W1_b3 = np.array([[1.0, 0.05], [0.05, 1.0]])\n    W2_b3 = np.array([[1.0, 1.0]])\n\n    test_cases = [\n        (W1_a1, W2_a1, W1_b1, W2_b1),\n        (W1_a2, W2_a2, W1_b2, W2_b2),\n        (W1_a3, W2_a3, W1_b3, W2_b3)\n    ]\n\n    final_results = []\n    \n    # --- Main Calculation Loop ---\n    \n    for W1_a, W2_a, W1_b, W2_b in test_cases:\n        \n        path_losses = []\n        path_consistencies = []\n\n        # Pre-compute representations at endpoints\n        v_a = get_vectorized_representation(W1_a, X)\n        v_b = get_vectorized_representation(W1_b, X)\n\n        for t in t_grid:\n            # Interpolate parameters\n            W1_t = (1 - t) * W1_a + t * W1_b\n            W2_t = (1 - t) * W2_a + t * W2_b\n\n            # 1. Calculate loss along the path\n            loss_t = mse_loss(W1_t, W2_t, X, Y)\n            path_losses.append(loss_t)\n\n            # 2. Calculate representation consistency\n            v_t = get_vectorized_representation(W1_t, X)\n            \n            sim_a = cosine_similarity(v_t, v_a)\n            sim_b = cosine_similarity(v_t, v_b)\n            \n            R_t = max(sim_a, sim_b)\n            path_consistencies.append(R_t)\n\n        # Calculate final metrics for the case\n        loss_endpoints = max(path_losses[0], path_losses[-1])\n        max_path_loss = max(path_losses)\n        \n        barrier = max_path_loss - loss_endpoints\n        conn = barrier = delta\n        \n        R_min = min(path_consistencies)\n        \n        # Store result in the required format\n        final_results.append([conn, round(R_min, 6)])\n\n    # --- Format and Print Output ---\n    \n    # Format each inner list to string, join with commas, and wrap in brackets\n    str_results = [f\"[{res[0]}, {res[1]}]\" for res in final_results]\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```", "id": "3113426"}]}