{"hands_on_practices": [{"introduction": "Spectral clustering is a powerful technique that uses the eigenvalues of a graph's Laplacian matrix to identify community structures. A common rule of thumb, the eigengap heuristic, suggests that the number of clusters $k$ can be found by locating a large gap between the $k$-th and $(k+1)$-th eigenvalues. This thought experiment challenges you to explore a scenario where this heuristic fails, forcing a deeper look at the connection between graph topology, cut conductance, and the Laplacian spectrum. Understanding these failure modes is crucial for applying spectral methods correctly and interpreting their results with nuance [@problem_id:3126418].", "problem": "Consider a weighted undirected graph $G$ with adjacency matrix $W \\in \\mathbb{R}^{n \\times n}$ and degree matrix $D = \\mathrm{diag}(d_1,\\dots,d_n)$, where $d_i = \\sum_{j} W_{ij}$. The symmetric normalized Laplacian is defined as $L_{\\mathrm{sym}} = I - D^{-1/2} W D^{-1/2}$, with ordered eigenvalues $0 = \\lambda_1 \\le \\lambda_2 \\le \\dots \\le \\lambda_n$. In spectral clustering, a common model selection rule is the eigengap heuristic, which selects the number of clusters $k$ by locating a prominent gap between consecutive eigenvalues, typically between $\\lambda_k$ and $\\lambda_{k+1}$. It is known that for exactly $m$ connected components one has exactly $m$ zero eigenvalues, and for connected graphs with $m$ well-separated low-conductance regions one often observes $m$ small eigenvalues near zero.\n\nConstruct a graph on which the eigengap heuristic between $\\lambda_k$ and $\\lambda_{k+1}$ fails to reveal the true number $k$ of clusters and explain the failure mode using first principles of spectral graph theory and cut conductance. For concreteness, assume the true intended number of clusters is $k = 3$.\n\nWhich option below correctly specifies such a construction and provides a correct explanation of the failure?\n\nA. Let $G$ consist of three intended clusters $C_1$, $C_2$, and $C_3$. Take $C_1$ and $C_2$ to be complete graphs $K_{20}$ with unit edge weights, so all internal edges in $C_1$ and $C_2$ have weight $1$. Take $C_3$ to be the union of two complete graphs $K_{15}$ and $K_{15}$ with unit edge weights, connected to each other by a single edge of weight $\\delta = 0.01$ between designated vertices $u \\in K_{15}$ and $v \\in K_{15}$. Make $G$ connected by adding, for each unordered pair $\\{i,j\\} \\subset \\{1,2,3\\}$, exactly $10$ cross-cluster edges of weight $\\epsilon = 0.2$ between $C_i$ and $C_j$ (placed arbitrarily). Explanation: The cut inside $C_3$ between its two halves has extremely low conductance compared to inter-cluster cuts, so there will be approximately $4$ small eigenvalues near zero, with the eigengap appearing after $\\lambda_4$, leading the heuristic to overestimate $k$ as $4$ even though the intended number is $3$.\n\nB. Let $G$ consist of three disconnected complete graphs $K_{20}$, $K_{20}$, and $K_{30}$, all with unit edge weights, and no edges between them. Explanation: Because the graph has $3$ connected components, there are exactly $3$ zero eigenvalues and a pronounced gap after $\\lambda_3$, so the eigengap heuristic fails by selecting $k = 4$ instead of $k = 3$.\n\nC. Let $G$ consist of three complete graphs $K_{20}$, $K_{20}$, and $K_{30}$ with unit edge weights, and connect every vertex in each cluster to every vertex in the other clusters with edges of weight $w = 0.8$. Explanation: The graph is nearly uniform, so all eigenvalues cluster together without any significant gaps, causing the heuristic to fail to identify $k = 3$.\n\nD. Let $G$ consist of three complete graphs $K_{20}$, $K_{20}$, and $K_{30}$ with unit edge weights, connected in a path by single edges of weight $\\epsilon = 0.01$ only between one pair $(C_1,C_2)$ and one pair $(C_2,C_3)$, with no other cross edges. Explanation: The two weak edges make $\\lambda_2$, $\\lambda_3$, and $\\lambda_4$ all almost zero with no clear separation around $\\lambda_3$, causing the eigengap heuristic to pick the wrong $k$.\n\nChoose the correct option.", "solution": "The task is to identify a graph construction and an accompanying explanation that correctly demonstrates a failure of the eigengap heuristic in spectral clustering for an intended number of clusters $k = 3$.\n\nThe fundamental principle underlying spectral clustering is that the number of small eigenvalues of the graph Laplacian corresponds to the number of quasi-disconnected components in the graph. For the symmetric normalized Laplacian $L_{\\mathrm{sym}} = I - D^{-1/2}WD^{-1/2}$, its eigenvalues $0 = \\lambda_1 \\le \\lambda_2 \\le \\dots \\le \\lambda_n$ are related to the connectivity of the graph. Specifically, the number of eigenvalues equal to $0$ is precisely the number of connected components. For a connected graph, the number of small eigenvalues (close to $0$) is associated with the number of clusters that are densely connected internally but only sparsely connected with each other. The sparsity of the connection between a cluster (a vertex set $S$) and the rest of the graph is quantified by the conductance, $\\phi(S) = \\frac{\\mathrm{cut}(S, S^c)}{\\min(\\mathrm{vol}(S), \\mathrm{vol}(S^c))}$, where $\\mathrm{cut}(S, S^c) = \\sum_{i \\in S, j \\in S^c} W_{ij}$ and $\\mathrm{vol}(S) = \\sum_{i \\in S} d_i$. A graph with $k$ well-separated clusters (i.e., $k$ components that can be separated by low-conductance cuts) will exhibit $k$ small eigenvalues, from $\\lambda_1$ to $\\lambda_k$. The eigengap heuristic identifies $k$ by finding a large gap between $\\lambda_k$ and $\\lambda_{k+1}$.\n\nA failure of this heuristic means that the most prominent gap is not located after $\\lambda_3$, despite the intended structure having $k=3$ clusters. This can happen if, for example, there are more or fewer than $3$ sets with low conductance, causing the number of small eigenvalues to be different from $3$.\n\nWe will now evaluate each option.\n\n**Option A Analysis:**\nThis option proposes a graph with three intended clusters, $C_1, C_2, C_3$. The clusters $C_1$ and $C_2$ are complete graphs $K_{20}$ with internal edge weights of $1$. The cluster $C_3$ has an internal hierarchical structure: it is composed of two complete graphs, $K_{15}$ and $K_{15}$, connected to each other by a single edge of a very small weight $\\delta = 0.01$. The three main clusters $C_1, C_2, C_3$ are connected to each other by edges of weight $\\epsilon = 0.2$.\n\nThis construction creates a graph with four natural, dense components: $C_1, C_2$, and the two $K_{15}$ subgraphs within $C_3$. Let's call the two halves of $C_3$ as $C_{3a}$ and $C_{3b}$. The connection between $C_{3a}$ and $C_{3b}$ is extremely weak (a single cut edge of weight $0.01$). The connections between the main clusters $C_1, C_2, C_3$ are significantly stronger. For instance, the total weight of edges between any two main clusters is $10 \\times \\epsilon = 10 \\times 0.2 = 2.0$.\n\nThe structure of the graph is essentially one with four \"almost-disconnected\" components: $C_1, C_2, C_{3a}, C_{3b}$. A cut that separates $C_{3a}$ from $C_{3b}$ would be very \"cheap\" in terms of cut weight compared to the overall volume of the graph. This indicates that the cut separating $C_{3a}$ from the rest of the graph will have a very small conductance. Similarly, the cuts separating $C_1$ and $C_2$ will also have small conductance. Because of this, the graph has not just three, but four components that are separable by low-conductance cuts.\n\nConsequently, the Laplacian spectrum will feature four small eigenvalues: $\\lambda_1 = 0$, and $\\lambda_2, \\lambda_3, \\lambda_4$ will be close to $0$. The fifth eigenvalue, $\\lambda_5$, will correspond to the best cut *inside* one of these four dense components (which are complete graphs). Since complete graphs are very hard to partition, the conductance of such a cut will be large, and thus $\\lambda_5$ will be significantly larger than $\\lambda_4$. The most prominent eigengap will appear between $\\lambda_4$ and $\\lambda_5$.\n\nThe eigengap heuristic, seeking this gap, will suggest that the number of clusters is $k=4$. This contradicts the intended number of clusters, $k=3$. The explanation provided in the option is therefore correct: the internal sub-structure of $C_3$ is so pronounced (i.e., its constituent parts are so weakly linked) that the algorithm identifies the sub-parts as separate clusters, leading to an overestimation of $k$.\n\nVerdict: **Correct**.\n\n**Option B Analysis:**\nThis option describes a graph composed of three disconnected complete graphs: $K_{20}$, $K_{20}$, and $K_{30}$. As stated in the problem's preamble, a graph with exactly $m$ connected components has exactly $m$ eigenvalues equal to $0$. Here, $m=3$, so the Laplacian spectrum will have $\\lambda_1 = \\lambda_2 = \\lambda_3 = 0$. The next eigenvalue, $\\lambda_4$, must be strictly positive. It corresponds to the smallest non-zero eigenvalue of the Laplacians of the individual components. For a complete graph $K_n$, the smallest non-zero eigenvalue of $L_{\\mathrm{sym}}$ is $\\frac{n}{n-1}$. For our components, these values are $\\frac{20}{19} \\approx 1.05$ and $\\frac{30}{29} \\approx 1.03$. Therefore, $\\lambda_4 = \\min(\\frac{20}{19}, \\frac{30}{29}) = \\frac{30}{29} > 1$. There is a massive gap between $\\lambda_3=0$ and $\\lambda_4>1$. The eigengap heuristic would unambiguously select $k=3$. The option claims the heuristic fails by selecting $k=4$, which is factually incorrect.\n\nVerdict: **Incorrect**.\n\n**Option C Analysis:**\nThis option describes a graph with three \"intended\" clusters, but where every vertex in each cluster is connected to every vertex in the other clusters with a high edge weight $w=0.8$. The internal edges have weight $1$. Let's consider a vertex in one of the $K_{20}$ clusters. The sum of weights of its internal edges is $19 \\times 1 = 19$. The sum of weights of its external edges is $(20 + 30) \\times 0.8 = 50 \\times 0.8 = 40$. The external connections for each vertex are more than twice as strong as the internal connections. This means the \"intended\" cluster structure is completely overwhelmed by the inter-cluster connectivity. The graph behaves as a single, highly-connected component, not three separate ones. The Laplacian spectrum would reflect this: apart from $\\lambda_1=0$, all other eigenvalues would be large, and there would be no significant gap after $\\lambda_2$ or $\\lambda_3$. The heuristic would fail to find $k=3$ (it would likely suggest $k=1$). While this is a failure scenario, it's a somewhat trivial one. The \"intended\" number of clusters is not reflected in the graph's topology in any meaningful way. Option A presents a more subtle and instructive failure where the intended cluster structure is plausible (intra-cluster weights are higher than inter-cluster weights) but the heuristic is still fooled by a hierarchical feature.\n\nVerdict: **Incorrect** (while describing a valid failure, it's a less specific and insightful example compared to A, where the failure is more characteristic of the heuristic itself).\n\n**Option D Analysis:**\nThis option describes three complete graphs connected in a path-like structure by single, very weak edges ($\\epsilon = 0.01$). This creates a graph with three well-defined clusters separated by two very low-conductance cuts. This is a classic example where spectral clustering is expected to perform very well. The two weak cuts will give rise to two small, non-zero eigenvalues, $\\lambda_2$ and $\\lambda_3$. The next eigenvalue, $\\lambda_4$, would correspond to a cut inside one of the dense $K_{20}$ or $K_{30}$ components, and would thus be large (close to $1$). This results in a clear eigengap between $\\lambda_3$ and $\\lambda_4$. The heuristic would correctly identify $k=3$. The explanation's claim that $\\lambda_4$ would also be \"almost zero\" is false.\n\nVerdict: **Incorrect**.\n\nBased on the analysis, Option A provides the most accurate and insightful construction of a graph where the eigengap heuristic fails to identify the intended number of clusters ($k=3$), along with a correct causal explanation based on the principles of spectral graph theory.", "answer": "$$\\boxed{A}$$", "id": "3126418"}, {"introduction": "The performance of spectral methods can be sensitive to the degree distribution of the graph, with high-degree \"hub\" nodes sometimes distorting the resulting embeddings. This practice introduces a hands-on coding challenge to address this issue through a principled downweighting scheme, where edge weights are adjusted based on the degrees of their incident nodes. By implementing and testing this technique on different graph structures, you will gain a practical understanding of how to make spectral analysis more robust and how to quantitatively measure the effect of this reweighting on the graph's algebraic connectivity, $\\lambda_2$ [@problem_id:3126409].", "problem": "You are given an undirected, simple graph represented by its adjacency matrix $A \\in \\mathbb{R}^{n \\times n}$ with $A_{ij} \\in \\{0,1\\}$, $A_{ii} = 0$, and $A_{ij} = A_{ji}$. Consider the degree matrix of $A$, defined by $D_A = \\mathrm{diag}(d_1,\\dots,d_n)$ with $d_i = \\sum_{j=1}^n A_{ij}$. We study the effect of hub nodes on spectral embeddings and the second smallest eigenvalue (also known as the Fiedler value) of a weighted Laplacian after applying a hub downweighting scheme.\n\nFundamental base:\n- The unnormalized graph Laplacian for a weighted adjacency matrix $W$ is $L_W = D_W - W$, where $D_W = \\mathrm{diag}(w_1,\\dots,w_n)$ with $w_i = \\sum_{j=1}^n W_{ij}$.\n- The Rayleigh quotient $R_L(x) = \\dfrac{x^\\top L x}{x^\\top x}$, combined with the Courant–Fischer theorem, yields that the second smallest eigenvalue $\\lambda_2$ of a symmetric, positive semidefinite matrix $L$ can be characterized as the minimum of $R_L(x)$ over vectors $x$ orthogonal to the all-ones vector.\n- Spectral embeddings used in spectral clustering stem from eigenvectors corresponding to the smallest eigenvalues of the Laplacian, which are sensitive to high-degree nodes (hubs).\n\nWe propose a hub downweighting scheme parameterized by $\\beta \\ge 0$:\n$$\nW(\\beta) \\;=\\; D_A^{-\\beta} \\, A \\, D_A^{-\\beta},\n$$\nso that $W_{ij}(\\beta) = A_{ij} \\, d_i^{-\\beta} \\, d_j^{-\\beta}$. This reweights edges adjacent to high-degree vertices downward. From $W(\\beta)$, define $D_W(\\beta)$ with entries $w_i(\\beta) = \\sum_{j=1}^n W_{ij}(\\beta)$ and the unnormalized Laplacian\n$$\nL_{W(\\beta)} \\;=\\; D_W(\\beta) \\,-\\, W(\\beta).\n$$\nWe are interested in how $\\lambda_2\\big(L_{W(\\beta)}\\big)$ changes with $\\beta$ in graphs with hub nodes.\n\nYour task:\n- Implement a program that, for each test case $(A,\\beta)$, computes $W(\\beta)$ using $D_A$ (the degree matrix of $A$), then forms $L_{W(\\beta)}$ and returns the second smallest eigenvalue $\\lambda_2\\big(L_{W(\\beta)}\\big)$.\n- All computations must be carried out in floating point and the final answers for each test case must be rounded to six decimal places.\n\nTest suite:\n- Case $1$ (Happy path; known structure): Star graph $S_6$ on $n = 6$ nodes labeled $\\{0,1,2,3,4,5\\}$ where node $0$ is the hub and is connected to nodes $\\{1,2,3,4,5\\}$. Use $\\beta = 0$.\n- Case $2$ (Effect of downweighting on the same graph): Same $S_6$ as Case $1$, with $\\beta = 0.5$.\n- Case $3$ (Two tight clusters bridged by a hub; no downweighting): Graph on $n = 10$ nodes labeled $\\{0,1,2,3,4,5,6,7,8,9\\}$ constructed as follows:\n  - Clique on $\\{0,1,2,3\\}$, i.e., all edges among these $4$ nodes.\n  - Clique on $\\{4,5,6,7\\}$, i.e., all edges among these $4$ nodes.\n  - Hub node $8$ connected to each node in $\\{0,1,2,3,4,5,6,7\\}$ and also connected to node $9$.\n  - No other edges. Use $\\beta = 0$.\n- Case $4$ (Downweighting on the bridged-clusters graph): Same graph as Case $3$, with $\\beta = 0.5$.\n\nAlgorithmic requirements and constraints:\n- For each test case, compute $D_A$ from $A$, then $W(\\beta)$ via $W_{ij}(\\beta) = A_{ij} d_i^{-\\beta} d_j^{-\\beta}$, then $D_W(\\beta)$, then $L_{W(\\beta)}$.\n- Compute eigenvalues of $L_{W(\\beta)}$; extract the second smallest eigenvalue $\\lambda_2$.\n- Numerical linear algebra must maintain symmetry and use standard routines suitable for symmetric matrices.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for Cases $1$ through $4$ in order, as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places (for example, $\"[1.000000,0.447214,0.123456,0.078900]\"$).", "solution": "The problem statement is formally valid. It presents a self-contained, mathematically consistent, and objective task rooted in established principles of graph theory and spectral analysis. The provided definitions and test cases are complete and unambiguous for the required computations. The potential issue of zero-degree nodes, which would lead to division by zero in the downweighting formula, does not arise in the specified test cases, as all graphs are connected and all nodes have a degree of at least $1$.\n\nThe task is to compute the second smallest eigenvalue, $\\lambda_2$, also known as the Fiedler value, of a specially constructed graph Laplacian, $L_{W(\\beta)}$. This value is a crucial measure of a graph's connectivity and is central to spectral clustering algorithms. The procedure involves reweighting the edges of an initial unweighted graph, represented by its adjacency matrix $A$, to mitigate the influence of high-degree \"hub\" nodes.\n\nThe process for each test case $(A, \\beta)$ is as follows:\n\n1.  **Construct Adjacency and Degree Matrices**: Given a graph on $n$ nodes, we first represent it by its symmetric adjacency matrix $A \\in \\{0, 1\\}^{n \\times n}$, where $A_{ij}=1$ if an edge exists between nodes $i$ and $j$, and $A_{ij}=0$ otherwise. The diagonal entries $A_{ii}$ are $0$. From $A$, we compute the degree vector $d$, where $d_i = \\sum_{j=1}^n A_{ij}$ is the degree of node $i$. This vector forms the diagonal of the degree matrix $D_A = \\mathrm{diag}(d_1, \\dots, d_n)$.\n\n2.  **Apply Hub Downweighting**: We introduce a weighted adjacency matrix $W(\\beta)$ using the specified downweighting scheme, which is parameterized by $\\beta \\ge 0$. The formula is given as a matrix product:\n    $$\n    W(\\beta) = D_A^{-\\beta} A D_A^{-\\beta}\n    $$\n    This operation reweights each edge $(i, j)$ based on the degrees of its incident nodes. The weight of the edge between nodes $i$ and $j$ becomes:\n    $$\n    W_{ij}(\\beta) = A_{ij} d_i^{-\\beta} d_j^{-\\beta}\n    $$\n    When $\\beta > 0$, edges connected to high-degree nodes (hubs) receive a smaller weight than edges connecting low-degree nodes. For $\\beta = 0$, $D_A^0$ is the identity matrix $I$, so $W(0) = IAI = A$, meaning no reweighting occurs.\n\n3.  **Form the Weighted Laplacian**: From the weighted adjacency matrix $W(\\beta)$, we construct its corresponding unnormalized graph Laplacian, $L_{W(\\beta)}$. This requires first calculating the weighted degrees, $w_i(\\beta) = \\sum_{j=1}^n W_{ij}(\\beta)$, which form the diagonal of the weighted degree matrix $D_W(\\beta) = \\mathrm{diag}(w_1(\\beta), \\dots, w_n(\\beta))$. The Laplacian is then:\n    $$\n    L_{W(\\beta)} = D_W(\\beta) - W(\\beta)\n    $$\n    Since $A$ is symmetric and $D_A$ is diagonal, $W(\\beta)$ is symmetric. Consequently, $L_{W(\\beta)}$ is also a symmetric matrix. It is also positive semidefinite, ensuring its eigenvalues are real and non-negative.\n\n4.  **Compute Eigenvalues**: The final step is to solve the eigenvalue problem for the matrix $L_{W(\\beta)}$. We compute its spectrum of eigenvalues, $\\{\\lambda_1, \\lambda_2, \\dots, \\lambda_n\\}$, ordered such that $0 = \\lambda_1 \\le \\lambda_2 \\le \\dots \\le \\lambda_n$. The smallest eigenvalue, $\\lambda_1$, is always $0$ for a connected graph, with a corresponding eigenvector of all ones, $\\mathbf{1}$. The quantity of interest is the second smallest eigenvalue, $\\lambda_2\\big(L_{W(\\beta)}\\big)$. This is computed numerically using standard, stable algorithms for symmetric matrices.\n\nThe Fiedler value $\\lambda_2$ is fundamentally related to graph partitioning via the Courant-Fischer theorem and the Rayleigh quotient. Specifically, $\\lambda_2$ is the minimum value of the Rayleigh quotient $R_{L_{W(\\beta)}}(x) = \\frac{x^\\top L_{W(\\beta)} x}{x^\\top x}$ over all non-zero vectors $x$ that are orthogonal to the eigenvector $\\mathbf{1}$. The quadratic form can be expressed as:\n    $$\n    x^\\top L_{W(\\beta)} x = \\frac{1}{2} \\sum_{i=1}^n \\sum_{j=1}^n W_{ij}(\\beta) (x_i - x_j)^2\n    $$\nThe downweighting for $\\beta>0$ reduces the terms $W_{ij}(\\beta)$ for edges connected to hubs. In graphs where hubs bridge distinct communities (like Case $3$), this makes it \"cheaper\" in the sense of the quadratic form to create a partition that cuts through the hub. We therefore expect $\\lambda_2$ to decrease as $\\beta$ increases from $0$, indicating a reduction in the graph's algebraic connectivity induced by the reweighting scheme. The provided implementation will execute this four-step procedure for each test case.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the second smallest eigenvalue of a\n    hub-downweighted graph Laplacian for four specified test cases.\n    \"\"\"\n\n    # --- Test Case 1: Star graph S_6, beta = 0 ---\n    A1 = np.zeros((6, 6), dtype=np.float64)\n    A1[0, 1:] = 1\n    A1[1:, 0] = 1\n    beta1 = 0.0\n\n    # --- Test Case 2: Star graph S_6, beta = 0.5 ---\n    A2 = A1.copy()\n    beta2 = 0.5\n\n    # --- Test Case 3: Two cliques bridged by a hub, beta = 0 ---\n    A3 = np.zeros((10, 10), dtype=np.float64)\n    # Clique 1 on nodes {0, 1, 2, 3}\n    clique1_nodes = np.arange(4)\n    A3[np.ix_(clique1_nodes, clique1_nodes)] = 1\n    # Clique 2 on nodes {4, 5, 6, 7}\n    clique2_nodes = np.arange(4, 8)\n    A3[np.ix_(clique2_nodes, clique2_nodes)] = 1\n    # Set diagonals to 0 after filling cliques\n    np.fill_diagonal(A3, 0)\n    # Hub node 8 connections\n    hub_node = 8\n    leaf_node = 9\n    connected_to_hub = np.arange(8)\n    A3[hub_node, connected_to_hub] = 1\n    A3[connected_to_hub, hub_node] = 1\n    A3[hub_node, leaf_node] = 1\n    A3[leaf_node, hub_node] = 1\n    beta3 = 0.0\n    \n    # --- Test Case 4: Two cliques bridged by a hub, beta = 0.5 ---\n    A4 = A3.copy()\n    beta4 = 0.5\n\n    test_cases = [\n        (A1, beta1),\n        (A2, beta2),\n        (A3, beta3),\n        (A4, beta4),\n    ]\n\n    results = []\n    \n    for A, beta in test_cases:\n        # Step 1: Compute degree matrix D_A from adjacency matrix A\n        # For an undirected graph, sum over rows or columns gives degrees.\n        d = np.sum(A, axis=1)\n        \n        # Check for isolated vertices (degree 0) which would cause division by zero.\n        # The problem's test cases do not have this issue.\n        if np.any(d == 0):\n            # This case is not handled by the problem description.\n            # However, for d_i=0 and beta>0, d_i^-beta is infinity.\n            # In a physical or computational context, this could be an error\n            # or require special handling, which is not specified.\n            # For the given problem, this branch is not taken.\n            raise ValueError(\"Graph contains isolated vertices (degree 0).\")\n            \n        # Step 2: Apply hub downweighting to get W(beta)\n        # D_A^-beta is a diagonal matrix with d_i^-beta on the diagonal.\n        d_inv_beta = np.power(d, -beta)\n        D_A_inv_beta = np.diag(d_inv_beta)\n        \n        # W(beta) = D_A^-beta * A * D_A^-beta\n        W_beta = D_A_inv_beta @ A @ D_A_inv_beta\n        \n        # Step 3: Form the weighted Laplacian L_W(beta)\n        # First, find the degree matrix of W(beta), D_W(beta).\n        w = np.sum(W_beta, axis=1)\n        D_W_beta = np.diag(w)\n        \n        # Then, L_W(beta) = D_W(beta) - W(beta)\n        L_W_beta = D_W_beta - W_beta\n        \n        # Step 4: Compute eigenvalues\n        # eigh is for symmetric/Hermitian matrices. It returns sorted eigenvalues.\n        eigenvalues = eigh(L_W_beta, eigvals_only=True)\n        \n        # The second smallest eigenvalue is lambda_2.\n        # Eigenvalues are sorted in ascending order, so it's at index 1.\n        lambda_2 = eigenvalues[1]\n        results.append(lambda_2)\n\n    # Format the final output string as specified.\n    output_str = f\"[{','.join(f'{val:.6f}' for val in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3126409"}, {"introduction": "Modern Graph Neural Networks (GNNs) learn powerful node representations by iteratively aggregating information from neighbors, a process closely related to signal propagation on graphs. A key challenge with deep GNNs is \"oversmoothing,\" where repeated aggregation makes node features indistinguishable, degrading model performance. This hands-on exercise explores how augmenting the graph structure—by adding weighted \"shortcut\" edges—affects the spectral properties of the GNN's propagation operator and, consequently, the rate of oversmoothing. By computationally investigating this phenomenon, you will connect the abstract spectral theory of graphs to a critical and practical issue in contemporary deep learning [@problem_id:3126463].", "problem": "You are given a family of undirected graphs and an augmentation scheme that adds edges of small weight between nodes that are separated by exactly $k$ steps in shortest-path distance. Starting from core definitions in graph-based learning, construct a principled investigation of how this augmentation affects the spectrum of the normalized propagation operator and how it increases oversmoothing in a linear Graph Convolutional Network (GCN). For each test case described below, your program must compute two quantities: the change in spectral gap and the increase in oversmoothing (defined via a variance ratio metric). Your final output must be a single line containing all results as a comma-separated list enclosed in square brackets.\n\nFundamental base and definitions:\n- Let $G$ be an undirected graph with adjacency matrix $A \\in \\mathbb{R}^{n \\times n}$, where $A_{ij} = 1$ if nodes $i$ and $j$ are connected by an edge and $A_{ij} = 0$ otherwise, for $i \\ne j$, and $A_{ii} = 0$ for all $i$ in the base graph. Define the identity matrix $I \\in \\mathbb{R}^{n \\times n}$. The renormalized adjacency used in the Graph Convolutional Network (GCN) is $\\tilde{A} = A + I$. The corresponding degree matrix is $D = \\mathrm{diag}(\\tilde{A} \\mathbf{1})$, where $\\mathbf{1}$ is the all-ones vector in $\\mathbb{R}^{n}$. The symmetric normalized propagation operator is $S = D^{-1/2} \\tilde{A} D^{-1/2}$. This operator is a well-tested construction in spectral graph theory and statistical learning for diffusive propagation on graphs.\n- The augmentation at step size $k$ and small weight $\\epsilon$ is defined by first computing the shortest-path distance matrix on the unweighted base graph, then forming $M^{(k)} \\in \\{0,1\\}^{n \\times n}$ with $M^{(k)}_{ij} = 1$ if the shortest-path distance between $i$ and $j$ equals $k$ and $M^{(k)}_{ij} = 0$ otherwise, with $M^{(k)}_{ii} = 0$. The augmented adjacency is $A^{\\mathrm{aug}} = A + \\epsilon M^{(k)}$, and its renormalized version is $\\tilde{A}^{\\mathrm{aug}} = A^{\\mathrm{aug}} + I$. The corresponding degree matrix and normalized propagation operator are $D^{\\mathrm{aug}} = \\mathrm{diag}(\\tilde{A}^{\\mathrm{aug}} \\mathbf{1})$ and $S^{\\mathrm{aug}} = (D^{\\mathrm{aug}})^{-1/2} \\tilde{A}^{\\mathrm{aug}} (D^{\\mathrm{aug}})^{-1/2}$.\n- Let the eigenvalues of $S$ be ordered by non-increasing absolute value as $|\\lambda_1(S)| \\ge |\\lambda_2(S)| \\ge \\cdots \\ge |\\lambda_n(S)|$. With self-loops present, $|\\lambda_1(S)| = 1$. Define the spectral gap as $\\gamma(S) = 1 - \\max_{i \\ge 2} |\\lambda_i(S)|$. Similarly, $\\gamma(S^{\\mathrm{aug}}) = 1 - \\max_{i \\ge 2} |\\lambda_i(S^{\\mathrm{aug}})|$. The change in spectral gap due to augmentation is $\\Delta_{\\gamma} = \\gamma(S^{\\mathrm{aug}}) - \\gamma(S)$.\n- To quantify oversmoothing, let $X \\in \\mathbb{R}^{n \\times d}$ be node features with each column centered to have zero mean across nodes. For a fixed integer $t \\ge 1$, define $H^{(t)} = S^t X$ and $H^{(t)}_{\\mathrm{aug}} = (S^{\\mathrm{aug}})^t X$. Define the across-node variance for a feature matrix $Y \\in \\mathbb{R}^{n \\times d}$ as $\\mathrm{VarAcrossNodes}(Y) = \\sum_{j=1}^d \\mathrm{Var}(Y_{\\cdot,j})$, where $\\mathrm{Var}$ is the unbiased sample variance across the $n$ nodes for feature $j$. Define the variance ratio $r = \\frac{\\mathrm{VarAcrossNodes}(H^{(t)})}{\\mathrm{VarAcrossNodes}(X)}$ and $r^{\\mathrm{aug}} = \\frac{\\mathrm{VarAcrossNodes}(H^{(t)}_{\\mathrm{aug}})}{\\mathrm{VarAcrossNodes}(X)}$. The oversmoothing increase is $\\Delta_{\\mathrm{os}} = r - r^{\\mathrm{aug}}$, where a positive $\\Delta_{\\mathrm{os}}$ indicates that augmentation causes stronger smoothing.\n\nTask:\n- For each test case below, construct the base graph $A$, the augmentation matrix $M^{(k)}$, the augmented graph $A^{\\mathrm{aug}}$, and the operators $S$ and $S^{\\mathrm{aug}}$ as defined above. Use a fixed random seed to generate $X$ so that results are reproducible, and center each feature column to have zero mean across nodes. Compute $\\Delta_{\\gamma}$ and $\\Delta_{\\mathrm{os}}$ as defined.\n\nTest suite:\n1. Path graph: $n = 6$. Base edges connect consecutive nodes $(0,1)$, $(1,2)$, $(2,3)$, $(3,4)$, $(4,5)$. Augmentation parameters: $k = 2$, $\\epsilon = 0.05$. Propagation steps: $t = 5$. Feature dimension: $d = 4$.\n2. Path graph boundary case: same base graph as case $1$ with $n = 6$. Augmentation parameters: $k = 2$, $\\epsilon = 0$. Propagation steps: $t = 5$. Feature dimension: $d = 4$.\n3. Star graph: $n = 7$. Node $0$ is the center connected to nodes $1,2,3,4,5,6$. Augmentation parameters: $k = 2$, $\\epsilon = 0.2$. Propagation steps: $t = 5$. Feature dimension: $d = 4$.\n4. Cycle graph: $n = 10$. Base edges connect $(0,1)$, $(1,2)$, $\\dots$, $(8,9)$, and $(9,0)$. Augmentation parameters: $k = 3$, $\\epsilon = 0.1$. Propagation steps: $t = 8$. Feature dimension: $d = 4$.\n\nImplementation requirements:\n- Use the shortest-path distances on the unweighted base graph $A$ (without self-loops) to build $M^{(k)}$.\n- Use the renormalized operator $S$ and $S^{\\mathrm{aug}}$ that include self-loops via $\\tilde{A} = A + I$ and $\\tilde{A}^{\\mathrm{aug}} = A^{\\mathrm{aug}} + I$.\n- Generate $X$ by sampling entries independently from a standard normal distribution and then centering each column across nodes; use a fixed random seed of $42$ to ensure reproducibility.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\Delta_{\\gamma}^{(1)}, \\Delta_{\\mathrm{os}}^{(1)}, \\Delta_{\\gamma}^{(2)}, \\Delta_{\\mathrm{os}}^{(2)}, \\Delta_{\\gamma}^{(3)}, \\Delta_{\\mathrm{os}}^{(3)}, \\Delta_{\\gamma}^{(4)}, \\Delta_{\\mathrm{os}}^{(4)}]$, where the superscript indicates the test case number. All entries must be floating-point numbers.", "solution": "We begin from core definitions in spectral graph theory and the standard renormalization used in Graph Convolutional Networks (GCN). Given an undirected base graph with adjacency matrix $A \\in \\mathbb{R}^{n \\times n}$, the GCN propagation operator incorporates self-loops to avoid periodicity and improve stability, by using $\\tilde{A} = A + I$ and $S = D^{-1/2} \\tilde{A} D^{-1/2}$ where $D = \\mathrm{diag}(\\tilde{A}\\mathbf{1})$. This construction ensures that $S$ is symmetric and has real eigenvalues in the interval $(0,1]$ for connected graphs due to the presence of self-loops.\n\nAugmentation by adding small-weight edges between $k$-step neighbors modifies the topology without changing the node set. On the unweighted base graph (with $A_{ii} = 0$), we compute the shortest-path distance matrix. For a chosen $k$ and $\\epsilon$, we define the binary matrix $M^{(k)}$ by $M^{(k)}_{ij} = 1$ if the shortest-path distance between nodes $i$ and $j$ equals $k$ and $M^{(k)}_{ij} = 0$ otherwise, with $M^{(k)}_{ii} = 0$. The augmented adjacency becomes $A^{\\mathrm{aug}} = A + \\epsilon M^{(k)}$. Its renormalized version is $\\tilde{A}^{\\mathrm{aug}} = A^{\\mathrm{aug}} + I$, leading to $D^{\\mathrm{aug}} = \\mathrm{diag}(\\tilde{A}^{\\mathrm{aug}}\\mathbf{1})$ and $S^{\\mathrm{aug}} = (D^{\\mathrm{aug}})^{-1/2} \\tilde{A}^{\\mathrm{aug}} (D^{\\mathrm{aug}})^{-1/2}$.\n\nThe spectrum of $S$ captures mixing under linear propagation. Let the eigenvalues of $S$ be denoted and ordered by non-increasing absolute value as $|\\lambda_1(S)| \\ge |\\lambda_2(S)| \\ge \\cdots \\ge |\\lambda_n(S)|$. With self-loops, $|\\lambda_1(S)| = 1$ and the rate at which $S^t$ contracts directions orthogonal to the principal eigenvector is governed by $\\max_{i \\ge 2} |\\lambda_i(S)|$. The spectral gap\n$$\n\\gamma(S) = 1 - \\max_{i \\ge 2} |\\lambda_i(S)|\n$$\nis larger when contraction is faster; a larger spectral gap implies stronger and quicker smoothing. After augmentation, $\\gamma(S^{\\mathrm{aug}})$ is defined analogously. Therefore, the change in spectral gap\n$$\n\\Delta_{\\gamma} = \\gamma(S^{\\mathrm{aug}}) - \\gamma(S)\n$$\nquantifies how augmentation shifts the spectrum toward stronger mixing (positive values) or weaker mixing (negative values).\n\nOversmoothing in a GCN can be measured operationally by how node features lose variability across nodes under repeated propagation. Let $X \\in \\mathbb{R}^{n \\times d}$ be initial node features with each column centered to zero mean across nodes. After $t$ propagation steps, we have $H^{(t)} = S^{t} X$ and $H^{(t)}_{\\mathrm{aug}} = (S^{\\mathrm{aug}})^t X$. Define an across-node variance functional\n$$\n\\mathrm{VarAcrossNodes}(Y) = \\sum_{j=1}^{d} \\mathrm{Var}(Y_{\\cdot,j}),\n$$\nwhere $\\mathrm{Var}$ is the unbiased sample variance across the $n$ nodes for feature $j$. The variance ratio\n$$\nr = \\frac{\\mathrm{VarAcrossNodes}(H^{(t)})}{\\mathrm{VarAcrossNodes}(X)}\n$$\nand its augmented counterpart\n$$\nr^{\\mathrm{aug}} = \\frac{\\mathrm{VarAcrossNodes}(H^{(t)}_{\\mathrm{aug}})}{\\mathrm{VarAcrossNodes}(X)}\n$$\ncapture how much variance remains after $t$ steps. Oversmoothing increase due to augmentation is\n$$\n\\Delta_{\\mathrm{os}} = r - r^{\\mathrm{aug}},\n$$\nwith $\\Delta_{\\mathrm{os}} > 0$ indicating that augmentation causes more smoothing.\n\nAlgorithmic steps:\n1. Construct the base adjacency $A$ for each graph in the test suite.\n2. Compute the shortest-path distance matrix on the unweighted base graph using Breadth-First Search (BFS) from each node, since graphs are small and BFS is a fundamental, well-tested method for shortest paths in unweighted graphs.\n3. Build $M^{(k)}$: set $M^{(k)}_{ij} = 1$ if the shortest-path distance equals $k$, $M^{(k)}_{ij} = 0$ otherwise, and $M^{(k)}_{ii} = 0$.\n4. Form $A^{\\mathrm{aug}} = A + \\epsilon M^{(k)}$.\n5. Compute $S = D^{-1/2} \\tilde{A} D^{-1/2}$ with $\\tilde{A} = A + I$ and $D = \\mathrm{diag}(\\tilde{A}\\mathbf{1})$. Similarly compute $S^{\\mathrm{aug}}$ from $\\tilde{A}^{\\mathrm{aug}} = A^{\\mathrm{aug}} + I$ and $D^{\\mathrm{aug}} = \\mathrm{diag}(\\tilde{A}^{\\mathrm{aug}}\\mathbf{1})$.\n6. Obtain eigenvalues of $S$ and $S^{\\mathrm{aug}}$ using symmetric eigendecomposition (e.g., the method for real symmetric matrices). Sort eigenvalues by non-increasing absolute value, identify $\\lambda_1$ (whose absolute value should be close to $1$ due to self-loops), and compute $\\gamma(S)$ and $\\gamma(S^{\\mathrm{aug}})$ to get $\\Delta_{\\gamma}$.\n7. Generate $X$ by sampling from a standard normal distribution with a fixed random seed, then center each feature column by subtracting its mean across nodes. Compute $H^{(t)} = S^{t} X$ and $H^{(t)}_{\\mathrm{aug}} = (S^{\\mathrm{aug}})^t X$ via repeated multiplication by $S$ and $S^{\\mathrm{aug}}$, respectively.\n8. Compute $\\mathrm{VarAcrossNodes}(X)$, $\\mathrm{VarAcrossNodes}(H^{(t)})$, and $\\mathrm{VarAcrossNodes}(H^{(t)}_{\\mathrm{aug}})$ using unbiased sample variance across nodes. Form $r$, $r^{\\mathrm{aug}}$, and $\\Delta_{\\mathrm{os}} = r - r^{\\mathrm{aug}}$.\n9. Report $[\\Delta_{\\gamma}^{(1)}, \\Delta_{\\mathrm{os}}^{(1)}, \\Delta_{\\gamma}^{(2)}, \\Delta_{\\mathrm{os}}^{(2)}, \\Delta_{\\gamma}^{(3)}, \\Delta_{\\mathrm{os}}^{(3)}, \\Delta_{\\gamma}^{(4)}, \\Delta_{\\mathrm{os}}^{(4)}]$.\n\nCoverage of the test suite:\n- Case $1$ (path graph with $n=6$, $k=2$, $\\epsilon=0.05$, $t=5$, $d=4$) is a typical sparse graph; augmentation introduces shortcuts between nodes at distance $2$ and should increase the spectral gap and oversmoothing.\n- Case $2$ (same path graph with $\\epsilon=0$) is a boundary case where no augmentation is applied; changes should be numerically near zero.\n- Case $3$ (star graph with $n=7$, $k=2$, $\\epsilon=0.2$, $t=5$, $d=4$) tests a hub-and-spoke topology; augmentation connects leaves at distance $2$ via the center, dramatically altering connectivity and likely increasing oversmoothing.\n- Case $4$ (cycle graph with $n=10$, $k=3$, $\\epsilon=0.1$, $t=8$, $d=4$) tests a regular structure with longer-range augmentation and a larger number of propagation steps, probing cumulative smoothing effects.\n\nThese steps align with fundamental graph propagation and spectral analysis principles, avoid shortcut formulas beyond standard, well-tested definitions, and yield quantifiable outputs that reflect how $k$-step edge augmentation with small $\\epsilon$ shifts the spectrum and increases oversmoothing in GCN-like propagation.", "answer": "```python\nimport numpy as np\n\ndef bfs_distances(adj):\n    \"\"\"\n    Compute shortest-path distances for an unweighted undirected graph.\n    adj: (n,n) adjacency matrix with 1 for edges, 0 otherwise, no self-loops.\n    Returns: (n,n) matrix of distances where dist[i,i]=0 and dist[i,j]=inf if disconnected.\n    \"\"\"\n    n = adj.shape[0]\n    dist = np.full((n, n), np.inf, dtype=float)\n    for s in range(n):\n        d = np.full(n, np.inf, dtype=float)\n        d[s] = 0.0\n        queue = [s]\n        head = 0\n        while head < len(queue):\n            u = queue[head]\n            head += 1\n            # neighbors: indices v where adj[u,v] > 0\n            for v in np.where(adj[u] > 0)[0]:\n                if d[v] == np.inf:\n                    d[v] = d[u] + 1.0\n                    queue.append(v)\n        dist[s, :] = d\n    return dist\n\ndef build_augmented_adjacency(A, k, eps):\n    \"\"\"\n    Build augmented adjacency: A_aug = A + eps * M^(k),\n    where M^(k)[i,j] = 1 if shortest-path distance between i and j equals k.\n    \"\"\"\n    n = A.shape[0]\n    dist = bfs_distances(A)\n    M = np.zeros((n, n), dtype=float)\n    # Add edges for pairs at exactly distance k (exclude diagonal)\n    for i in range(n):\n        for j in range(i+1, n):\n            if dist[i, j] == float(k):  # distance equals k\n                M[i, j] = 1.0\n                M[j, i] = 1.0\n    A_aug = A.astype(float) + eps * M\n    return A_aug\n\ndef normalized_propagation(A):\n    \"\"\"\n    Compute symmetric normalized propagation operator S = D^{-1/2} (A + I) D^{-1/2}.\n    \"\"\"\n    n = A.shape[0]\n    A_tilde = A + np.eye(n)\n    deg = A_tilde.sum(axis=1)\n    # Avoid division by zero; graphs are connected in tests, but be safe:\n    deg_sqrt_inv = np.zeros_like(deg)\n    with np.errstate(divide='ignore'):\n        deg_sqrt_inv = 1.0 / np.sqrt(deg)\n    deg_sqrt_inv[~np.isfinite(deg_sqrt_inv)] = 0.0\n    D_inv_sqrt = np.diag(deg_sqrt_inv)\n    S = D_inv_sqrt @ A_tilde @ D_inv_sqrt\n    return S\n\ndef spectral_gap(S):\n    \"\"\"\n    Compute spectral gap gamma(S) = 1 - max_{i>=2} |lambda_i(S)|,\n    where eigenvalues are ordered by non-increasing absolute value.\n    \"\"\"\n    # S is symmetric; use eigh for numerical stability\n    vals = np.linalg.eigh(S)[0]\n    # Sort by absolute value descending\n    abs_sorted = np.sort(np.abs(vals))[::-1]\n    if len(abs_sorted) < 2:\n        return 0.0\n    # Largest absolute eigenvalue should be ~1 due to self-loops; take second largest\n    lam2_abs = abs_sorted[1]\n    gamma = 1.0 - lam2_abs\n    return float(gamma)\n\ndef power_propagate(S, X, t):\n    \"\"\"\n    Compute H^{(t)} = S^t X by repeated multiplication.\n    \"\"\"\n    H = X.copy()\n    for _ in range(t):\n        H = S @ H\n    return H\n\ndef var_across_nodes(Y):\n    \"\"\"\n    Compute sum of unbiased sample variances across nodes for each feature column.\n    \"\"\"\n    n, d = Y.shape\n    # Center columns explicitly to avoid numerical drift\n    Y_centered = Y - Y.mean(axis=0, keepdims=True)\n    # Unbiased sample variance across rows for each column\n    # var = sum((y_i - mean)^2) / (n - 1)\n    if n > 1:\n        var_cols = (Y_centered ** 2).sum(axis=0) / (n - 1)\n    else:\n        var_cols = np.zeros(d, dtype=float)\n    return float(var_cols.sum())\n\ndef compute_metrics(A, k, eps, t, d, rng):\n    \"\"\"\n    For one test case:\n    - Build augmented adjacency.\n    - Compute S and S_aug.\n    - Compute spectral gap change Delta_gamma.\n    - Generate X with standard normal entries, center columns.\n    - Compute H^t and H_aug^t, variance ratios, and oversmoothing increase Delta_os.\n    \"\"\"\n    # Augmented adjacency from base graph A (without self-loops)\n    A_aug = build_augmented_adjacency(A, k, eps)\n\n    # Normalized propagation operators (renormalized adjacency includes self-loops)\n    S = normalized_propagation(A)\n    S_aug = normalized_propagation(A_aug)\n\n    # Spectral gap change\n    gamma_orig = spectral_gap(S)\n    gamma_aug = spectral_gap(S_aug)\n    delta_gamma = gamma_aug - gamma_orig\n\n    # Features X: standard normal, centered per column\n    n = A.shape[0]\n    X = rng.standard_normal((n, d))\n    X = X - X.mean(axis=0, keepdims=True)\n\n    # Propagate\n    H_t = power_propagate(S, X, t)\n    H_t_aug = power_propagate(S_aug, X, t)\n\n    # Variance ratios\n    var_X = var_across_nodes(X)\n    var_H = var_across_nodes(H_t)\n    var_H_aug = var_across_nodes(H_t_aug)\n    r = var_H / var_X if var_X != 0.0 else 0.0\n    r_aug = var_H_aug / var_X if var_X != 0.0 else 0.0\n\n    # Oversmoothing increase\n    delta_os = r - r_aug\n\n    return float(delta_gamma), float(delta_os)\n\ndef build_path_graph(n):\n    A = np.zeros((n, n), dtype=float)\n    for i in range(n - 1):\n        A[i, i + 1] = 1.0\n        A[i + 1, i] = 1.0\n    return A\n\ndef build_star_graph(n):\n    # node 0 is center\n    A = np.zeros((n, n), dtype=float)\n    for i in range(1, n):\n        A[0, i] = 1.0\n        A[i, 0] = 1.0\n    return A\n\ndef build_cycle_graph(n):\n    A = np.zeros((n, n), dtype=float)\n    for i in range(n):\n        j = (i + 1) % n\n        A[i, j] = 1.0\n        A[j, i] = 1.0\n    return A\n\ndef solve():\n    # Fixed RNG for reproducibility\n    rng = np.random.default_rng(42)\n\n    # Define test cases:\n    # Each is a tuple: (A_builder, n, k, eps, t, d)\n    test_cases = [\n        (build_path_graph, 6, 2, 0.05, 5, 4),  # Case 1\n        (build_path_graph, 6, 2, 0.0,  5, 4),  # Case 2 (boundary)\n        (build_star_graph, 7, 2, 0.2,  5, 4),  # Case 3\n        (build_cycle_graph,10, 3, 0.1,  8, 4), # Case 4\n    ]\n\n    results = []\n    for builder, n, k, eps, t, d in test_cases:\n        A = builder(n)\n        delta_gamma, delta_os = compute_metrics(A, k, eps, t, d, rng)\n        results.append(delta_gamma)\n        results.append(delta_os)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3126463"}]}