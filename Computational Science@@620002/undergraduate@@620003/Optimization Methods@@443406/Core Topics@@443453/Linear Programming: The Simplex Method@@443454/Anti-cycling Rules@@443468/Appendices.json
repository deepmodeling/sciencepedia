{"hands_on_practices": [{"introduction": "This first practice provides a direct, empirical look at the problem of cycling. By implementing a basic simplex solver, you will simulate a classic example where a standard pivot rule can get stuck in a loop, and then observe how Bland's rule elegantly breaks the cycle to find the optimal solution. This exercise [@problem_id:3117274] builds a foundational intuition for why anti-cycling rules are an essential component of robust linear programming solvers.", "problem": "You are asked to implement a simulation of the Simplex method for Linear Programming (LP) to study degeneracy and cycling under different pivot selection rules. The fundamental base for this problem is the canonical formulation of Linear Programming: maximize a linear objective subject to linear equality constraints and nonnegativity, and the Simplex method which proceeds by moving from one basic feasible solution (BFS) to another via pivots until optimality conditions are satisfied. In standard form, an LP is expressed as maximizing $c^\\top x$ subject to $A x = b$ and $x \\ge 0$, which is obtained from $\\le$ constraints by introducing slack variables. The Simplex method uses a basis matrix $B$ formed by columns of $A$, and computes the current BFS $x_B = B^{-1} b$; it evaluates reduced costs $r_N = c_N - c_B^\\top B^{-1} N$ for nonbasic variables and performs a pivot if some component of $r_N$ is positive (for a maximization problem). Degeneracy occurs when one or more basic variables equal $0$, and cycling refers to revisiting the same basis without improvement in the objective, typically due to degenerate pivots. Two pivot rules are considered: Dantzig’s rule (choose the entering variable with the largest positive reduced cost) and Bland’s rule (choose the entering variable with the smallest index among those with positive reduced cost, and the leaving variable with the smallest index among those minimizing the ratio test). You must implement both pivot rules and empirically test for cycling by detecting repeated bases.\n\nImplement a program that:\n- Converts each LP given in $\\le$ form to standard equality form by adding slack variables.\n- Simulates the Simplex method with two pivot rules: Dantzig’s rule and Bland’s rule. At each iteration, compute $x_B = B^{-1} b$, the dual vector $y^\\top = c_B^\\top B^{-1}$, reduced costs $r_N = c_N - y^\\top N$, select an entering variable following the specified rule, compute the direction $d_B$ from $B d_B = A_{\\cdot,e}$, perform the minimum ratio test on components with $d_{B,i}  0$ to select the leaving variable, and pivot. Stop when all reduced costs are nonpositive (optimality), when the problem is unbounded (no positive $d_{B,i}$ along a direction with positive reduced cost), or when a previously seen basis reappears (cycling). Use a numerical tolerance $\\varepsilon = 10^{-9}$ for positivity and equality comparisons.\n- For each test case, report whether cycling was detected under Dantzig’s rule and under Bland’s rule (booleans), and the final objective value $c^\\top x$ at termination for each rule (floats). If cycling is detected, report the objective value at the moment cycling is detected. If unbounded is detected, report the objective value as $0.0$.\n\nTest Suite:\nProvide three LPs in $\\le$ form with nonnegativity constraints on decision variables:\n\n- Case $1$ (degenerate, known to cycle under Dantzig’s rule and avoided by Bland’s rule):\n  Maximize $10 x_1 - 57 x_2 - 9 x_3 - 24 x_4$ subject to\n  $0.5 x_1 - 5.5 x_2 - 2.5 x_3 + 9 x_4 \\le 0$,\n  $0.5 x_1 - 1.5 x_2 - 0.5 x_3 + 1 x_4 \\le 0$,\n  $1 x_1 \\le 1$,\n  and $x_1, x_2, x_3, x_4 \\ge 0$.\n  This introduces $3$ slack variables and has $b = [0, 0, 1]^\\top$.\n\n- Case $2$ (non-degenerate, simple bounded problem):\n  Maximize $3 x_1 + 2 x_2$ subject to\n  $1 x_1 + 1 x_2 \\le 4$,\n  $1 x_1 \\le 2$,\n  $1 x_2 \\le 3$,\n  and $x_1, x_2 \\ge 0$.\n\n- Case $3$ (edge case with tie in entering variable reduced costs at the start):\n  Maximize $1 x_1 + 1 x_2$ subject to\n  $1 x_1 + 1 x_2 \\le 1$,\n  $1 x_1 \\le 0.5$,\n  $1 x_2 \\le 0.5$,\n  and $x_1, x_2 \\ge 0$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result should be a list in the form $[d\\_cycle, b\\_cycle, d\\_opt, b\\_opt]$, where $d\\_cycle$ and $b\\_cycle$ are booleans indicating cycling under Dantzig’s and Bland’s rules, respectively, and $d\\_opt$, $b\\_opt$ are floats giving the final objective values for Dantzig’s and Bland’s rule, respectively. For example, the output should look like $[[\\text{True},\\text{False},10.0,10.0],[\\dots],[\\dots]]$. Floats must be printed in decimal form; no physical units are involved in this problem.", "solution": "We begin from the foundational formulation of Linear Programming (LP). In standard form, an LP seeks to maximize $c^\\top x$ subject to $A x = b$ and $x \\ge 0$. Any system of constraints of the form $M x \\le b$ with $x \\ge 0$ can be converted to standard form by introducing slack variables $s \\ge 0$ such that $M x + s = b$. This yields an equality system $A x' = b$ where $x' = \\begin{bmatrix} x \\\\ s \\end{bmatrix}$ and $A = [M \\ \\ I]$, and the augmented objective vector $c' = \\begin{bmatrix} c \\\\ 0 \\end{bmatrix}$. A Basic Feasible Solution (BFS) is obtained by choosing a basis $B$ comprising $m$ columns of $A$ (with $m$ equal to the number of constraints), solving $x_B = B^{-1} b$, setting $x_N = 0$ for nonbasic variables, and requiring $x_B \\ge 0$. In the standard initialization, slack variables form the basis because this corresponds to the identity matrix and thus a BFS exists provided $b \\ge 0$.\n\nThe Simplex method advances by pivoting: selecting an entering variable from the nonbasic set and a leaving variable from the basic set. The principle guiding the selection relies on the reduced costs. Let $B$ be the basis matrix and $N$ the submatrix of $A$ comprising columns of nonbasic variables. Denote $c_B$ and $c_N$ as the corresponding partitions of the objective coefficients. The current solution is $x_B = B^{-1} b$. The objective can be expressed as:\n$$\nz = c^\\top x = c_B^\\top x_B + c_N^\\top x_N = c_B^\\top B^{-1} b + \\left( c_N^\\top - c_B^\\top B^{-1} N \\right) x_N,\n$$\nhence the reduced costs (also called relative profits in the context of maximization) are:\n$$\nr_N = c_N - c_B^\\top B^{-1} N.\n$$\nIf all components of $r_N$ are nonpositive, then increasing any nonbasic variable cannot improve the objective, and the current BFS is optimal. If some $r_j  0$, then increasing the corresponding nonbasic variable $x_j$ can increase $z$, and this variable is a candidate to enter the basis. The effect on the basic variables is governed by the direction $d_B$ satisfying:\n$$\nB d_B = A_{\\cdot,j},\n$$\nso that increasing $x_j$ by $\\theta$ changes the basic variables to $x_B(\\theta) = x_B - \\theta d_B$. The minimum ratio test ensures feasibility by restricting $\\theta$ to the largest nonnegative value such that $x_B(\\theta) \\ge 0$, given by:\n$$\n\\theta^\\star = \\min_{i: d_{B,i}  0} \\frac{x_{B,i}}{d_{B,i}}.\n$$\nIf no component $d_{B,i}  0$ exists, then the problem is unbounded in the direction of $x_j$ because increasing $x_j$ improves the objective without violating feasibility.\n\nDegeneracy refers to the case where one or more basic variables equal zero. In a degenerate pivot, the minimum ratio $\\theta^\\star$ equals zero, resulting in no change in the objective value and potentially allowing the algorithm to revisit a previously seen basis. Cycling is the phenomenon where the algorithm revisits the same basis (and the same BFS), thereby entering an infinite loop without improving the objective. The pivot rules studied are:\n- Dantzig’s rule: Among all nonbasic variables with $r_j  0$, choose the entering variable with the largest $r_j$; perform the ratio test and choose the first (or any consistent) basic variable attaining the minimum ratio to leave.\n- Bland’s rule: Among all nonbasic variables with $r_j  0$, choose the one with the smallest index to enter; among all indices attaining the minimum ratio, choose the basic variable with the smallest index to leave.\n\nBland’s rule is known to prevent cycling by enforcing a lexicographic monotonicity on the sequence of bases, a result supported by the theory of pivot selections in the Simplex method: when ties are broken by smallest indices for both entering and leaving variables, the algorithm cannot revisit a previously seen basis.\n\nAlgorithmic design:\n- Input: For each test case, a matrix $M$, vector $b$, and objective coefficient vector $c$ for the original decision variables together with nonnegativity constraints $x \\ge 0$.\n- Conversion to standard form: Construct $A = [M \\ \\ I_m]$ and $c' = \\begin{bmatrix} c \\\\ 0_m \\end{bmatrix}$, with initial basis comprising the $m$ slack variables (indices from $n$ to $n + m - 1$).\n- Iteration:\n  1. Form $B$ by selecting columns of $A$ corresponding to the current basis. Compute $x_B = B^{-1} b$ by solving $B x_B = b$. Compute $y$ by solving $B^\\top y = c_B$, which yields $y^\\top = c_B^\\top B^{-1}$.\n  2. Compute $r_N = c_N - y^\\top N$. If $\\max_j r_{N,j} \\le \\varepsilon$, declare optimality.\n  3. Select entering variable:\n     - Dantzig’s rule: choose the index $j$ with the largest $r_{N,j}$ subject to $r_{N,j}  \\varepsilon$; break ties consistently (e.g., first encountered).\n     - Bland’s rule: choose the smallest index $j$ in the nonbasic set with $r_{N,j}  \\varepsilon$.\n  4. Compute $d_B$ by solving $B d_B = A_{\\cdot,j}$. Perform the ratio test on components with $d_{B,i}  \\varepsilon$: $\\theta_i = x_{B,i} / d_{B,i}$, and choose the leaving index minimizing $\\theta_i$; break ties:\n     - Dantzig’s rule: first encountered minimum.\n     - Bland’s rule: among minima, choose the smallest basic variable index.\n  5. Pivot: Replace the leaving basic variable with the entering variable and update the basis and nonbasis sets.\n  6. Cycling detection: Maintain a set of visited bases (as ordered tuples of variable indices). If the new basis is already in the set, declare cycling.\n- Termination: Return whether cycling was detected and the final objective value $c^\\top x$. If cycling occurs, the objective value remains unchanged during degenerate pivots; report the value when cycling is detected. If unbounded is detected (no $d_{B,i}  0$), report $0.0$.\n\nTest cases and expected phenomena:\n- Case $1$ (Beale’s cycling example): With $c = [10, -57, -9, -24]$, $b = [0, 0, 1]^\\top$, and constraints as given, the initial BFS is degenerate ($x = 0$, slack variables $s_1 = 0$, $s_2 = 0$, $s_3 = 1$). Under Dantzig’s rule, the sequence of degenerate pivots can revisit a previously encountered basis, demonstrating cycling; under Bland’s rule, the sequence of pivots avoids cycling and reaches optimality.\n- Case $2$: A simple bounded non-degenerate LP with $c = [3, 2]$ and $b = [4, 2, 3]^\\top$; both rules should converge to the optimal value, typically at $x_1 = 2$, $x_2 = 2$, achieving objective $z = 10$ without cycling.\n- Case $3$: An edge case with tied entering reduced costs initially ($c = [1, 1]$ and $b = [1, 0.5, 0.5]^\\top$); both rules should still avoid cycling, and the optimal solution is $x_1 = 0.5$, $x_2 = 0.5$, with $z = 1$.\n\nThe final program implements the described algorithm for the three test cases and outputs the list of results in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nEPS = 1e-9\nMAX_ITERS = 200\n\ndef simplex(M, b, c, rule=\"dantzig\"):\n    \"\"\"\n    Solve a maximization LP given in = form with nonnegativity: M x = b, x = 0, maximize c^T x.\n    Adds slacks to get equality, runs simplex with specified pivot rule.\n    rule: \"dantzig\" or \"bland\".\n    Returns: (cycled: bool, optimal_value: float)\n    \"\"\"\n    M = np.array(M, dtype=float)\n    b = np.array(b, dtype=float)\n    c = np.array(c, dtype=float)\n\n    m, n = M.shape  # m constraints, n decision variables\n\n    # Build standard-form A = [M | I], augmented c' = [c, 0_m]\n    A = np.hstack([M, np.eye(m, dtype=float)])\n    c_full = np.concatenate([c, np.zeros(m, dtype=float)])\n\n    # Initial basis: slacks\n    basis = list(range(n, n + m))\n    nonbasis = list(range(0, n))\n\n    visited_bases = set()\n    visited_bases.add(tuple(basis))\n\n    cycled = False\n    z_value = 0.0\n\n    for _ in range(MAX_ITERS):\n        B = A[:, basis]  # m x m\n        N = A[:, nonbasis]  # m x (n_nonbasic)\n\n        # Solve for x_B and y\n        try:\n            x_B = np.linalg.solve(B, b)\n        except np.linalg.LinAlgError:\n            # Singular basis; treat as cycle or fail-safe\n            cycled = True\n            break\n        c_B = c_full[basis]\n        c_N = c_full[nonbasis]\n        try:\n            y = np.linalg.solve(B.T, c_B)\n        except np.linalg.LinAlgError:\n            cycled = True\n            break\n\n        # Reduced costs r_N = c_N - y^T N\n        r_N = c_N - (y @ N)\n\n        # Check optimality (no positive reduced costs)\n        max_r = np.max(r_N) if r_N.size  0 else -np.inf\n        if max_r = EPS:\n            # Optimal; compute objective z = c_B^T x_B\n            z_value = float(c_B @ x_B)\n            cycled = False\n            break\n\n        # Select entering variable\n        enter_idx_in_N = None\n        if rule == \"dantzig\":\n            # Choose index with largest positive reduced cost\n            # If multiple, choose first encountered\n            candidates = [(j, r) for j, r in enumerate(r_N) if r  EPS]\n            if not candidates:\n                z_value = float(c_B @ x_B)\n                cycled = False\n                break\n            # Find argmax r\n            max_val = -np.inf\n            for j, r in candidates:\n                if r  max_val:\n                    max_val = r\n                    enter_idx_in_N = j\n        elif rule == \"bland\":\n            # Choose smallest variable index in nonbasis with r  EPS\n            enter_idx_in_N = None\n            min_var_index = None\n            for j, r in enumerate(r_N):\n                if r  EPS:\n                    var_index = nonbasis[j]\n                    if (min_var_index is None) or (var_index  min_var_index):\n                        min_var_index = var_index\n                        enter_idx_in_N = j\n            if enter_idx_in_N is None:\n                z_value = float(c_B @ x_B)\n                cycled = False\n                break\n        else:\n            raise ValueError(\"Unknown rule: must be 'dantzig' or 'bland'.\")\n\n        entering_var = nonbasis[enter_idx_in_N]\n\n        # Compute direction d_B by solving B d_B = a_enter\n        a_enter = A[:, entering_var]\n        try:\n            d_B = np.linalg.solve(B, a_enter)\n        except np.linalg.LinAlgError:\n            cycled = True\n            break\n\n        # Ratio test\n        ratios = []\n        for i in range(m):\n            if d_B[i]  EPS:\n                ratios.append(x_B[i] / d_B[i])\n            else:\n                ratios.append(np.inf)\n        min_ratio = min(ratios) if ratios else np.inf\n        if np.isinf(min_ratio):\n            # Unbounded direction\n            z_value = 0.0\n            cycled = False\n            break\n\n        # Select leaving variable\n        leave_row = None\n        if rule == \"dantzig\":\n            # First encountered minimum ratio\n            for i in range(m):\n                if d_B[i]  EPS:\n                    if abs(ratios[i] - min_ratio) = EPS:\n                        leave_row = i\n                        break\n        else:  # bland\n            # Among minima, choose smallest basic variable index\n            candidate_rows = []\n            for i in range(m):\n                if d_B[i]  EPS and abs(ratios[i] - min_ratio) = EPS:\n                    candidate_rows.append(i)\n            if not candidate_rows:\n                z_value = 0.0\n                cycled = False\n                break\n            # Select smallest index of the basic variable\n            best_row = candidate_rows[0]\n            best_var_index = basis[best_row]\n            for i in candidate_rows[1:]:\n                var_idx = basis[i]\n                if var_idx  best_var_index:\n                    best_var_index = var_idx\n                    best_row = i\n            leave_row = best_row\n\n        leaving_var = basis[leave_row]\n\n        # Pivot: update basis and nonbasis\n        basis[leave_row] = entering_var\n        # Update nonbasis: replace entering with leaving\n        # Keep nonbasis sorted for consistent behavior except Bland requires index ordering; we will reconstruct properly\n        nonbasis = [v for v in nonbasis if v != entering_var]\n        nonbasis.append(leaving_var)\n        # For Bland, maintain sorted nonbasis to enforce index ordering in selection\n        if rule == \"bland\":\n            nonbasis.sort()\n\n        # Check cycling: if basis repeats, declare cycle\n        basis_tuple = tuple(basis)\n        if basis_tuple in visited_bases:\n            cycled = True\n            # Objective at cycle detection\n            z_value = float(c_full[basis] @ x_B)\n            break\n        visited_bases.add(basis_tuple)\n\n        # Continue to next iteration\n\n    else:\n        # Max iterations reached; treat as cycle for safety\n        cycled = True\n        z_value = float(c_full[basis] @ x_B) if 'x_B' in locals() else 0.0\n\n    return cycled, z_value\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case 1: Beale's cycling example (degenerate)\n    M1 = np.array([\n        [0.5, -5.5, -2.5, 9.0],\n        [0.5, -1.5, -0.5, 1.0],\n        [1.0,  0.0,  0.0, 0.0]\n    ], dtype=float)\n    b1 = np.array([0.0, 0.0, 1.0], dtype=float)\n    c1 = np.array([10.0, -57.0, -9.0, -24.0], dtype=float)\n\n    # Case 2: Simple bounded non-degenerate\n    M2 = np.array([\n        [1.0, 1.0],\n        [1.0, 0.0],\n        [0.0, 1.0]\n    ], dtype=float)\n    b2 = np.array([4.0, 2.0, 3.0], dtype=float)\n    c2 = np.array([3.0, 2.0], dtype=float)\n\n    # Case 3: Edge case with tie in entering reduced costs\n    M3 = np.array([\n        [1.0, 1.0],\n        [1.0, 0.0],\n        [0.0, 1.0]\n    ], dtype=float)\n    b3 = np.array([1.0, 0.5, 0.5], dtype=float)\n    c3 = np.array([1.0, 1.0], dtype=float)\n\n    test_cases = [\n        (M1, b1, c1),\n        (M2, b2, c2),\n        (M3, b3, c3)\n    ]\n\n    results = []\n    for M, b, c in test_cases:\n        d_cycle, d_opt = simplex(M, b, c, rule=\"dantzig\")\n        b_cycle, b_opt = simplex(M, b, c, rule=\"bland\")\n        # Round floats to 6 decimals for stable output\n        d_opt_round = round(float(d_opt), 6)\n        b_opt_round = round(float(b_opt), 6)\n        results.append([d_cycle, b_cycle, d_opt_round, b_opt_round])\n\n    # Final print statement in the exact required format.\n    # Ensure booleans and floats are printed correctly in a single-line list of lists.\n    def format_item(item):\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        elif isinstance(item, float):\n            # Keep as decimal\n            return f\"{item}\"\n        else:\n            return str(item)\n\n    formatted = []\n    for res in results:\n        formatted.append(\"[\" + \",\".join(format_item(x) for x in res) + \"]\")\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```", "id": "3117274"}, {"introduction": "Having seen that some rules can prevent cycling, a natural question is whether any deterministic tie-breaking scheme will suffice. This exercise presents a thought experiment with a simple, yet flawed, \"largest-index\" pivot rule. By manually tracing the pivots through a degenerate dictionary [@problem_id:3098176], you will uncover a cycle, demonstrating that the design of an effective anti-cycling rule requires careful theoretical consideration beyond simple determinism.", "problem": "Consider the following linear programming problem in standard dictionary form with basic variables $x_3$ and $x_4$ and nonbasic variables $x_1$ and $x_2$:\n$$\n\\begin{aligned}\nx_3 = 0 - x_1 + x_2, \\\\\nx_4 = 0 + x_1 - x_2, \\\\\nz   = 0 + x_1 + x_2,\n\\end{aligned}\n$$\ntogether with the nonnegativity constraints $x_1, x_2, x_3, x_4 \\geq 0$. Interpret this dictionary as arising from the system $x_1 - x_2 + x_3 = 0$, $-x_1 + x_2 + x_4 = 0$ and the objective $\\max z = x_1 + x_2$. The basic feasible solution is degenerate at the origin $x_1=x_2=x_3=x_4=0$.\n\nAdopt the following pivot rule, which uses largest-index tie-breaking:\n- Entering variable rule: Among all nonbasic variables with positive reduced cost (the coefficients of $x_j$ in the $z$-row), choose the $x_j$ with the largest index.\n- Leaving variable rule: Apply the minimum ratio test. Because the right-hand sides here are zero, any basic row with a positive coefficient in the entering column yields a ratio of zero; among these ties, choose the leaving basic variable with the largest index.\n\nSimulate the simplex pivots deterministically according to this rule until a basis repeats, thereby tracing a directed walk on the basis graph (whose nodes are the size-$2$ index sets of basic variables). Starting from the initial basis $\\{x_3, x_4\\}$, determine the length of the directed cycle encountered (the number of distinct bases in the cycle). Provide your final answer as an exact integer. No rounding is required and no physical units are involved.", "solution": "The problem is well-posed and self-contained. The provided dictionary and pivot rules must be followed precisely. We will simulate the simplex pivots step by step, tracking the basis at each iteration until a basis repeats. The variables are indexed from $1$ to $4$.\n\nLet $B_k$ be the set of indices of the basic variables at iteration $k$.\nLet $D_k$ be the dictionary at iteration $k$.\n\n**Iteration 0:**\nThe initial state is given.\nThe basis is $B_0 = \\{3, 4\\}$. The nonbasic variable indices are $\\{1, 2\\}$.\nThe dictionary $D_0$ is:\n$$\n\\begin{aligned}\nx_3 = 0 - x_1 + x_2 \\\\\nx_4 = 0 + x_1 - x_2 \\\\\nz   = 0 + x_1 + x_2\n\\end{aligned}\n$$\n\n**Pivot 1:**\n1.  **Entering Variable Selection:** The nonbasic variables are $x_1$ and $x_2$. Their coefficients in the $z$-row are $+1$ and $+1$, respectively. Both are positive, so both are eligible to enter the basis. According to the specified rule, we choose the variable with the largest index. Thus, $x_2$ is selected as the entering variable.\n\n2.  **Leaving Variable Selection:** We apply the minimum ratio test. We examine the rows of the dictionary for a positive coefficient on the entering variable $x_2$.\n    - In the row for $x_3$, the expression is $x_3 = 0 - x_1 + x_2$. The coefficient of $x_2$ is $+1$. Since this is positive, this row is a candidate. The ratio is the constant term divided by this coefficient: $0/1 = 0$.\n    - In the row for $x_4$, the expression is $x_4 = 0 + x_1 - x_2$. The coefficient of $x_2$ is $-1$. Since this is not positive, this row is not a candidate for the ratio test.\n    There is only one candidate for the leaving variable, $x_3$. Thus, $x_3$ leaves the basis. The tie-breaking rule for leaving variables is not needed in this step.\n\n3.  **Dictionary Update:** We pivot by solving the $x_3$-row for the entering variable $x_2$:\n    $x_3 = -x_1 + x_2 \\implies x_2 = x_1 + x_3$.\n    Next, we substitute this expression for $x_2$ into the other equations:\n    $x_4 = x_1 - x_2 = x_1 - (x_1 + x_3) = -x_3$.\n    $z = x_1 + x_2 = x_1 + (x_1 + x_3) = 2x_1 + x_3$.\n\n**Iteration 1:**\nThe new basis is $B_1 = \\{2, 4\\}$. The nonbasic variable indices are $\\{1, 3\\}$.\nThe new dictionary $D_1$ is:\n$$\n\\begin{aligned}\nx_2 = 0 + x_1 + x_3 \\\\\nx_4 = 0 - x_3 \\\\\nz   = 0 + 2x_1 + x_3\n\\end{aligned}\n$$\n\n**Pivot 2:**\n1.  **Entering Variable Selection:** The nonbasic variables are $x_1$ and $x_3$. Their coefficients in the $z$-row are $+2$ and $+1$, respectively. Both are positive. We choose the one with the largest index, which is $x_3$. So, $x_3$ enters the basis.\n\n2.  **Leaving Variable Selection:** We apply the minimum ratio test for the entering variable $x_3$.\n    - In the row for $x_2$, the expression is $x_2 = 0 + x_1 + x_3$. The coefficient of $x_3$ is $+1$. This row is a candidate. The ratio is $0/1 = 0$.\n    - In the row for $x_4$, the expression is $x_4 = 0 - x_3$. The coefficient of $x_3$ is $-1$. This row is not a candidate.\n    There is only one candidate, $x_2$, which must leave the basis. Again, the tie-breaking rule is not invoked.\n\n3.  **Dictionary Update:** We pivot by solving the $x_2$-row for $x_3$:\n    $x_2 = x_1 + x_3 \\implies x_3 = x_2 - x_1$.\n    We substitute this into the other equations:\n    $x_4 = -x_3 = -(x_2 - x_1) = x_1 - x_2$.\n    $z = 2x_1 + x_3 = 2x_1 + (x_2 - x_1) = x_1 + x_2$.\n\n**Iteration 2:**\nThe new basis is $B_2 = \\{3, 4\\}$. The nonbasic variable indices are $\\{1, 2\\}$.\nThe new dictionary $D_2$ is:\n$$\n\\begin{aligned}\nx_3 = 0 - x_1 + x_2 \\\\\nx_4 = 0 + x_1 - x_2 \\\\\nz   = 0 + x_1 + x_2\n\\end{aligned}\n$$\nWe observe that the basis $B_2 = \\{3, 4\\}$ is identical to the initial basis $B_0$. The dictionary $D_2$ is also identical to $D_0$. This indicates that the simplex method has entered a cycle.\n\nThe sequence of bases generated by the pivoting rule is:\n$B_0 = \\{3, 4\\} \\to B_1 = \\{2, 4\\} \\to B_2 = \\{3, 4\\}$.\nThe directed cycle of bases is $(B_0, B_1)$. The distinct bases in this cycle are $B_0$ and $B_1$.\nThe length of a cycle is the number of distinct vertices (bases) it contains. In this case, there are two distinct bases.\n\nTherefore, the length of the directed cycle is $2$.", "answer": "$$\\boxed{2}$$", "id": "3098176"}, {"introduction": "This capstone practice broadens our scope to a suite of established anti-cycling techniques. You will implement and compare not only Bland's rule but also two powerful forms of lexicographic perturbation and a randomized approach [@problem_id:3098175]. This comparative analysis on a set of challenging test cases will reveal the different strengths and operational characteristics of each method, providing a more complete picture of the tools available to ensure the simplex algorithm's termination.", "problem": "You will implement a primal simplex method for Linear Programming (LP) in standard inequality form and compare multiple anti-cycling rules on specifically constructed degenerate families. The LPs you will solve are of the form\n$$\n\\text{maximize } c^\\top x \\quad \\text{subject to } A x \\le b, \\; x \\ge 0,\n$$\nwhere $A \\in \\mathbb{R}^{m \\times n}$, $b \\in \\mathbb{R}^m$, and $c \\in \\mathbb{R}^n$. Introduce slack variables $s \\in \\mathbb{R}^m$ to transform each constraint into equality $A x + s = b$ with $s \\ge 0$. The primal simplex algorithm maintains a basis of $m$ basic variables. At each iteration, for a current basis matrix $B \\in \\mathbb{R}^{m \\times m}$ formed by current basic columns, its inverse $B^{-1}$ is used to compute fundamental quantities as follows:\n- The vector of current basic values is $x_B = B^{-1} b$.\n- The vector of simplex multipliers is $y^\\top = c_B^\\top B^{-1}$, where $c_B$ are the costs of the basic variables.\n- The reduced cost of a nonbasic column $A_j$ with cost $c_j$ is $r_j = c_j - y^\\top A_j$.\n- If there exists a reduced cost $r_j$ that is strictly positive, an entering variable is chosen. The direction in basic space is $d = B^{-1} A_j$ and the ratio test chooses the leaving row $i$ by minimizing $x_{B,i} / d_i$ over indices $i$ where $d_i  0$. If no $d_i  0$ exists for the chosen entering variable, the LP is unbounded in the direction of improvement.\n\nDegeneracy occurs when some basic values are zero, which can induce pivots that do not move the solution and may lead to cycling. To prevent cycling, implement the following anti-cycling rules:\n- Bland's rule: choose the entering variable as the one with the smallest index among those with $r_j  0$; choose the leaving variable as the one with the smallest basic-variable index among those achieving the minimum ratio.\n- Lexicographic perturbation of $c$: perturb the objective coefficients by a tiny lexicographically decreasing sequence so that ties in entering selection are broken deterministically. Concretely, use $c' = c + \\varepsilon w$ where $\\varepsilon = 10^{-9}$ and $w_j = \\delta^j$ with $\\delta = 10^{-3}$ for the $j$-th variable index in the extended variable list (original variables followed by slacks).\n- Lexicographic perturbation of $b$: perturb the right-hand side by a tiny lexicographically decreasing sequence so that ties in the ratio test are broken deterministically. Concretely, use $b' = b + \\varepsilon v$ where $\\varepsilon = 10^{-9}$ and $v_i = \\delta^i$ with $\\delta = 10^{-3}$ for the $i$-th constraint.\n- Randomized tie-breaking: when multiple entering variables have reduced costs within a small numerical tolerance of the maximal positive reduced cost, choose uniformly at random among them; similarly, when multiple leaving rows achieve the minimal ratio within tolerance, choose uniformly at random among them. Use a fixed Random Number Generator (RNG) seed to ensure reproducibility.\n\nYour program must implement the primal simplex algorithm with the four rules above. At each pivot, update the basis by replacing the leaving row's basic variable index with the entering variable index. Track the number of pivots performed. Detect cycling by maintaining the set of visited bases (as ordered tuples of basic variable indices) and reporting a cycle if the basis repeats; in case of detected cycle, stop. Use a strict positivity tolerance for reduced costs and pivot directions of $10^{-10}$, and a tie tolerance of $10^{-12}$ for identifying ties. Impose a maximum pivot count of $1000$ to avoid infinite loops in case of unexpected behavior.\n\nTest Suite:\nImplement and solve the following LP instances. For each LP, $A$, $b$, and $c$ are given as arrays of real numbers. All variables are dimensionless; no physical units apply.\n\n- Test Case $1$ (non-degenerate \"happy path\"):\n  $$\n  A = \\begin{bmatrix} 1  1 \\\\ 2  1 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 4 \\\\ 5 \\end{bmatrix}, \\quad c = \\begin{bmatrix} 3 \\\\ 2 \\end{bmatrix}.\n  $$\n- Test Case $2$ (degeneracy in $b$ with ratio ties):\n  $$\n  A = \\begin{bmatrix} 1  1 \\\\ 1  0 \\\\ 0  1 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 3 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad c = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}.\n  $$\n- Test Case $3$ (symmetry causing entering-variable ties):\n  $$\n  A = \\begin{bmatrix} 1  1  0 \\\\ 1  0  1 \\\\ 0  1  1 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}, \\quad c = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}.\n  $$\n- Test Case $4$ (unbounded case):\n  $$\n  A = \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}, \\quad c = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}.\n  $$\n\nFor each test case, run the primal simplex with each of the four pivot rules in the fixed order: Bland's rule, lexicographic perturbation of $c$, lexicographic perturbation of $b$, randomized tie-breaking. For each run, compute:\n- The total number of pivots performed as a nonnegative integer.\n- A cycle flag indicating whether a cycle was detected as a boolean.\n- A status code indicating termination reason as an integer, with the following semantics:\n  - $0$: optimal solution reached (no positive reduced costs),\n  - $1$: unbounded (chosen entering column has no positive direction components),\n  - $2$: cycle detected (basis repeated),\n  - $3$: maximum pivot count reached (safety stop).\n\nFinal Output Format:\nYour program should produce a single line of output containing a nested list. The outer list enumerates test cases in the given order. Each element of the outer list is an inner list enumerating the four rules in the given order. Each element of the rule list is a list of three entries $[pivots, cycled, status]$. For example, a syntactically correct output for four test cases would look like\n$$\n\\big[ \\big[ [p_1, c_1, s_1], [p_2, c_2, s_2], [p_3, c_3, s_3], [p_4, c_4, s_4] \\big], \\ldots \\big],\n$$\nbut with actual integer and boolean values in place of the symbols. Your program must print this single line exactly, with lists using square brackets and commas, and booleans printed as the native language booleans.", "solution": "The user has provided a well-defined problem in the domain of linear programming. The task is to implement the primal simplex algorithm and compare four distinct anti-cycling (or pivot selection) rules on a set of test cases designed to elicit specific behaviors like degeneracy and unboundedness. The problem statement is scientifically sound, objective, and provides all necessary parameters, definitions, and test data. An initial feasible basis is implicitly available for all test cases by choosing the slack variables, as all right-hand side vectors $b$ are non-negative. Therefore, the problem is valid and a solution can be constructed.\n\nThe solution will be implemented using the revised simplex method, as implied by the problem's reference to $B^{-1}$. The state of the algorithm at each iteration is defined by the set of basic variable indices. The algorithm proceeds as follows:\n\n1.  **Initialization**: For a given problem $(\\text{maximize } c^\\top x \\text{ s.t. } Ax \\le b, x \\ge 0)$, we introduce $m$ slack variables $s$ to form the standard equality form $Ax + Is = b$. The full problem has $N=n+m$ variables and $m$ constraints. The initial basis is chosen to be the set of slack variables, which is feasible since $b \\ge 0$. This corresponds to an initial basic solution $x_B = b$. Any perturbations to $b$ or $c$ required by the pivot rule are applied at this stage.\n\n2.  **Iteration**: The main loop of the simplex method performs the following steps until a termination condition is met:\n    a. **Termination and Cycling Check**: The algorithm checks if the maximum pivot count has been reached (status $3$) or if the current basis has been visited before (status $2$).\n    b. **Compute Simplex Multipliers and Reduced Costs**: Given the current basis (a list of $m$ variable indices), the basis matrix $B$ is formed by the corresponding columns of the full constraint matrix $[A|I]$. Its inverse $B^{-1}$ is computed. The simplex multipliers are calculated as $y^\\top = c_B^\\top B^{-1}$, where $c_B$ are the costs of the basic variables. The reduced cost for each non-basic variable $j$ is $r_j = c_j - y^\\top A_j$.\n    c. **Select Entering Variable**: An entering variable is chosen from the non-basic variables with a strictly positive reduced cost ($r_j  10^{-10}$). If no such variable exists, the current solution is optimal (status $0$), and the algorithm terminates. The specific choice is dictated by the active pivot rule.\n    d. **Select Leaving Variable (Ratio Test)**: The pivot search direction is computed as $d = B^{-1}A_j$, where $j$ is the index of the entering variable. If all components of $d$ are non-positive ($d_i \\le 10^{-10}$), the problem is unbounded (status $1$), and the algorithm terminates. Otherwise, the leaving variable is determined by the ratio test: find the row $i$ that minimizes the ratio $x_{B,i}/d_i$ among all rows with $d_i  10^{-10}$, where $x_B = B^{-1}b$. Ties are broken according to the active pivot rule.\n    e. **Pivot**: The basis is updated by replacing the leaving variable's index with the entering variable's index. The pivot count is incremented.\n\nThe four pivoting rules are implemented as follows:\n\n-   **Bland's Rule**:\n    -   **Entering**: Choose the non-basic variable with the smallest index $j$ among all variables with a positive reduced cost ($r_j  10^{-10}$).\n    -   **Leaving**: Among all basic variables that are candidates to leave (i.e., correspond to rows achieving the minimum ratio), choose the one with the smallest variable index.\n\n-   **Lexicographic Perturbation of $c$**:\n    -   The cost vector $c$ is perturbed to $c' = c + \\varepsilon w$, where $\\varepsilon = 10^{-9}$ and the $k$-th component of $w$ is $\\delta^k$ for $\\delta=10^{-3}$, with $k$ being the variable index ($0, \\dots, n+m-1$).\n    -   **Entering**: The standard rule of selecting the variable with the maximum positive reduced cost is used. The perturbation on $c$ ensures that ties are deterministically broken, as the reduced costs $r'_j = c'_j - y'^\\top A_j$ are extremely unlikely to be equal for different $j$.\n    -   **Leaving**: The standard ratio test is used. Ties are broken by choosing the variable in the lowest-indexed row.\n\n-   **Lexicographic Perturbation of $b$**:\n    -   The right-hand side vector $b$ is perturbed to $b' = b + \\varepsilon v$, where $\\varepsilon = 10^{-9}$ and the $i$-th component of $v$ is $\\delta^i$ for $\\delta=10^{-3}$, with $i$ being the constraint index ($0, \\dots, m-1$).\n    -   **Entering**: The standard \"maximum positive reduced cost\" rule is used, with ties broken by selecting the variable with the smallest index.\n    -   **Leaving**: The ratio test is performed using the perturbed basic solution $x_B = B^{-1} b'$. The perturbation on $b$ ensures that the values of $x_{B,i}$ are lexicographically distinct, thus breaking ties in the ratio test.\n\n-   **Randomized Tie-Breaking**:\n    -   A fixed random seed is used for reproducibility.\n    -   **Entering**: Find the maximum positive reduced cost, $r_{max}$. All variables whose reduced costs are within a tolerance ($10^{-12}$) of $r_{max}$ are considered candidates. One is chosen uniformly at random from this set.\n    -   **Leaving**: Find the minimum ratio, $\\theta_{min}$. All variables whose rows yield a ratio within a tolerance ($10^{-12}$) of $\\theta_{min}$ are considered candidates. One is chosen uniformly at random from this set.\n\nThe implementation is encapsulated in a class that manages the state of the simplex algorithm. A main function orchestrates the execution of all four rules on each test case and formats the output as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_list(l):\n    \"\"\"\n    Recursively formats a list into a string without spaces after commas,\n    as required by the output format.\n    \"\"\"\n    if isinstance(l, list):\n        return f\"[{','.join(map(format_list, l))}]\"\n    else:\n        # Handles integers, booleans (True/False), etc.\n        return str(l)\n\nclass SimplexSolver:\n    \"\"\"\n    Implements the primal simplex algorithm with various anti-cycling rules.\n    \"\"\"\n    def __init__(self, A, b, c, rule, seed=0):\n        # Constants and Tolerances\n        self.POS_TOL = 1e-10\n        self.TIE_TOL = 1e-12\n        self.MAX_PIVOTS = 1000\n        \n        # Problem data setup\n        m, n = A.shape\n        self.m, self.n = m, n\n        self.total_vars = n + m\n        \n        # Full A matrix [A | I]\n        self.A_full = np.hstack([A, np.eye(m)])\n        \n        self.rule = rule\n        \n        # Initialize b and c from originals\n        self.b = np.copy(b).astype(float)\n        self.c_full = np.zeros(self.total_vars, dtype=float)\n        self.c_full[:n] = c\n\n        # Apply perturbations based on the chosen rule\n        if self.rule == 'lex_c':\n            epsilon = 1e-9\n            delta = 1e-3\n            for j in range(self.total_vars):\n                self.c_full[j] += epsilon * (delta ** j)\n        \n        if self.rule == 'lex_b':\n            epsilon = 1e-9\n            delta = 1e-3\n            for i in range(m):\n                self.b[i] += epsilon * (delta ** i)\n\n        if self.rule == 'randomized':\n            np.random.seed(seed)\n\n        # Initial algorithm state\n        self.basis_indices = list(range(n, self.total_vars)) # Initial all-slack basis\n        self.pivots = 0\n        self.cycled = False\n        self.status = -1 # -1: Unresolved, 0: Optimal, 1: Unbounded, 2: Cycled, 3: Max pivots\n        self.visited_bases = set()\n\n    def run(self):\n        \"\"\"\n        Executes the simplex algorithm from the initial state until termination.\n        \"\"\"\n        while True:\n            # --- Termination and Cycling Checks ---\n            if self.pivots = self.MAX_PIVOTS:\n                self.status = 3\n                break\n\n            current_basis_tuple = tuple(sorted(self.basis_indices))\n            if current_basis_tuple in self.visited_bases:\n                self.status = 2\n                self.cycled = True\n                break\n            self.visited_bases.add(current_basis_tuple)\n\n            # --- Main Simplex Step ---\n            \n            # 1. Compute B_inv, y, and reduced costs\n            try:\n                B = self.A_full[:, self.basis_indices]\n                B_inv = np.linalg.inv(B)\n            except np.linalg.LinAlgError:\n                self.status = 3 # Error state\n                break\n\n            c_B = self.c_full[self.basis_indices]\n            y_T = c_B @ B_inv\n\n            non_basic_indices = [j for j in range(self.total_vars) if j not in current_basis_tuple]\n            \n            reduced_costs = {j: self.c_full[j] - y_T @ self.A_full[:, j] for j in non_basic_indices}\n\n            # 2. Select entering variable\n            entering_idx = self._select_entering_variable(reduced_costs, non_basic_indices)\n\n            if entering_idx is None:\n                self.status = 0 # Optimal\n                break\n            \n            # 3. Select leaving variable (Ratio Test)\n            A_entering = self.A_full[:, entering_idx]\n            d = B_inv @ A_entering\n\n            if np.all(d  self.POS_TOL):\n                self.status = 1 # Unbounded\n                break\n            \n            x_B = B_inv @ self.b\n            \n            leaving_row_idx = self._select_leaving_variable(d, x_B)\n\n            if leaving_row_idx is None:\n                # Should be caught by unboundedness check, but as a safeguard\n                self.status = 1\n                break\n            \n            # 4. Perform pivot\n            self.basis_indices[leaving_row_idx] = entering_idx\n            self.pivots += 1\n\n        return [self.pivots, self.cycled, self.status]\n    \n    def _select_entering_variable(self, reduced_costs, non_basic_indices):\n        \"\"\"Selects an entering variable based on the current pivot rule.\"\"\"\n        positive_rc_indices = [j for j, rc in reduced_costs.items() if rc  self.POS_TOL]\n        if not positive_rc_indices:\n            return None\n\n        if self.rule == 'bland':\n            return min(positive_rc_indices)\n        \n        elif self.rule == 'randomized':\n            max_rc = max(reduced_costs[j] for j in positive_rc_indices)\n            candidates = [j for j in positive_rc_indices if abs(reduced_costs[j] - max_rc)  self.TIE_TOL]\n            return np.random.choice(candidates)\n        \n        else: # Standard max-rc rule for lex_c, lex_b\n            max_rc = -1.0\n            entering_idx = -1\n            # Tie-break with smallest index\n            for j in sorted(positive_rc_indices):\n                if reduced_costs[j]  max_rc:\n                    max_rc = reduced_costs[j]\n                    entering_idx = j\n            return entering_idx\n\n    def _select_leaving_variable(self, d, x_B):\n        \"\"\"Selects a leaving variable based on the ratio test and pivot rule.\"\"\"\n        eligible_rows = [i for i in range(self.m) if d[i]  self.POS_TOL]\n        if not eligible_rows:\n            return None\n        \n        ratios = {i: x_B[i] / d[i] for i in eligible_rows}\n        min_ratio = min(ratios.values())\n        \n        min_ratio_rows = [i for i, r in ratios.items() if abs(r - min_ratio)  self.TIE_TOL]\n\n        if len(min_ratio_rows) == 1:\n            return min_ratio_rows[0]\n            \n        if self.rule == 'bland':\n            candidate_vars = {i: self.basis_indices[i] for i in min_ratio_rows}\n            min_var_idx = min(candidate_vars.values())\n            for i, var_idx in candidate_vars.items():\n                if var_idx == min_var_idx:\n                    return i\n        \n        elif self.rule == 'randomized':\n            return np.random.choice(min_ratio_rows)\n\n        else: # lex_c, lex_b. lex_b tie is unlikely. Standard tie-break is smallest row index.\n            return min(min_ratio_rows)\n        return None # Should not be reached\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the SimplexSolver for each rule, and prints the results.\n    \"\"\"\n    test_cases = [\n        {\n            'A': np.array([[1, 1], [2, 1]]),\n            'b': np.array([4, 5]),\n            'c': np.array([3, 2]),\n        },\n        {\n            'A': np.array([[1, 1], [1, 0], [0, 1]]),\n            'b': np.array([3, 0, 0]),\n            'c': np.array([1, 1]),\n        },\n        {\n            'A': np.array([[1, 1, 0], [1, 0, 1], [0, 1, 1]]),\n            'b': np.array([1, 1, 1]),\n            'c': np.array([1, 1, 1]),\n        },\n        {\n            'A': np.array([[1, -1], [-1, 1]]),\n            'b': np.array([1, 1]),\n            'c': np.array([1, 1]),\n        },\n    ]\n\n    rules = ['bland', 'lex_c', 'lex_b', 'randomized']\n    \n    all_results = []\n    for case_data in test_cases:\n        case_results = []\n        for rule in rules:\n            solver = SimplexSolver(A=case_data['A'], b=case_data['b'], c=case_data['c'], rule=rule, seed=0)\n            result = solver.run()\n            case_results.append(result)\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format (no spaces after commas)\n    print(format_list(all_results))\n\nsolve()\n\n```", "id": "3098175"}]}