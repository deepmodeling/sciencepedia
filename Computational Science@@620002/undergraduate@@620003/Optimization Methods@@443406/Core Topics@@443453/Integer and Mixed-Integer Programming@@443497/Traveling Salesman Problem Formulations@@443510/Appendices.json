{"hands_on_practices": [{"introduction": "To formulate the Traveling Salesman Problem as an integer program, we must go beyond simply ensuring each city is entered and left once. We also need constraints to prevent disconnected subtours. The Miller-Tucker-Zemlin (MTZ) formulation provides an elegant algebraic solution by introducing auxiliary variables that enforce a sequential ordering on the cities visited. This practice [@problem_id:1411103] challenges you to construct the complete set of MTZ constraints for a small 4-city problem, providing fundamental, hands-on experience with the mechanics of this classic subtour elimination technique.", "problem": "An integer programming formulation for the Traveling Salesman Problem (TSP) on a set of $n$ cities, labeled $V = \\{1, 2, \\dots, n\\}$, often starts by defining binary variables $x_{ij}$ where $x_{ij} = 1$ if the tour travels directly from city $i$ to city $j$, and $x_{ij} = 0$ otherwise. The basic assignment constraints, $\\sum_{i \\in V, i \\neq j} x_{ij} = 1$ for all $j \\in V$ and $\\sum_{j \\in V, j \\neq i} x_{ij} = 1$ for all $i \\in V$, ensure that each city is entered exactly once and exited exactly once. However, these constraints alone do not prevent the formation of disconnected subtours.\n\nTo enforce a single, connected tour, one common approach is the Miller-Tucker-Zemlin (MTZ) formulation. This introduces a set of auxiliary continuous variables $u_i$ for $i \\in \\{2, 3, \\dots, n\\}$. For a tour starting and ending at a designated depot, city 1, these $u_i$ variables can be interpreted as the position of city $i$ in the sequence of visited cities.\n\nConsider a 4-city TSP with cities $V = \\{1, 2, 3, 4\\}$, where city 1 is the depot. The auxiliary variables are $u_2, u_3, u_4$. Which of the following options represents the complete and correct set of MTZ constraints required to guarantee a single tour for this specific problem?\n\nA.\n$u_2 - u_3 + 3x_{23} \\le 2$\n$u_2 - u_4 + 3x_{24} \\le 2$\n$u_3 - u_2 + 3x_{32} \\le 2$\n$u_3 - u_4 + 3x_{34} \\le 2$\n$u_4 - u_2 + 3x_{42} \\le 2$\n$u_4 - u_3 + 3x_{43} \\le 2$\nand $1 \\le u_i \\le 3$ for $i \\in \\{2, 3, 4\\}$.\n\nB.\n$u_2 - u_3 + 3x_{23} \\le 2$\n$u_3 - u_4 + 3x_{34} \\le 2$\n$u_4 - u_2 + 3x_{42} \\le 2$\nand $1 \\le u_i \\le 3$ for $i \\in \\{2, 3, 4\\}$.\n\nC.\n$u_2 - u_3 + 4x_{23} \\le 3$\n$u_2 - u_4 + 4x_{24} \\le 3$\n$u_3 - u_2 + 4x_{32} \\le 3$\n$u_3 - u_4 + 4x_{34} \\le 3$\n$u_4 - u_2 + 4x_{42} \\le 3$\n$u_4 - u_3 + 4x_{43} \\le 3$\nand $1 \\le u_i \\le 4$ for $i \\in \\{2, 3, 4\\}$.\n\nD.\n$u_2 - u_3 + 3x_{23} \\le 2$\n$u_2 - u_4 + 3x_{24} \\le 2$\n$u_3 - u_2 + 3x_{32} \\le 2$\n$u_3 - u_4 + 3x_{34} \\le 2$\n$u_4 - u_2 + 3x_{42} \\le 2$\n$u_4 - u_3 + 3x_{43} \\le 2$\nand $1 \\le u_i \\le 4$ for $i \\in \\{1, 2, 3, 4\\}$.\n\nE.\n$u_i - u_j + 3x_{ij} \\le 2$ for all $i,j \\in \\{1, 2, 3, 4\\}$, $i \\neq j$.\nand $1 \\le u_i \\le 3$ for $i \\in \\{1, 2, 3, 4\\}$.", "solution": "We recall the standard Miller-Tucker-Zemlin (MTZ) subtour elimination constraints for a TSP on $n$ cities with a designated depot (city $1$). Introduce continuous auxiliary variables $u_{i}$ for $i \\in \\{2,3,\\dots,n\\}$ with bounds representing the visit position of each non-depot city. A common and correct MTZ form is:\n- Bounds: for all $i \\in \\{2,3,\\dots,n\\}$,\n$$\n1 \\le u_{i} \\le n-1.\n$$\n- Pairwise MTZ inequalities: for all $i,j \\in \\{2,3,\\dots,n\\}$ with $i \\neq j$,\n$$\nu_{i} - u_{j} + (n-1)\\,x_{ij} \\le n-2.\n$$\n\nJustification:\n- If $x_{ij} = 1$, then $u_{i} - u_{j} \\le -1$, i.e., $u_{i} \\le u_{j} - 1$, enforcing a consistent ordering along selected arcs and thus prohibiting subtours among non-depot nodes.\n- If $x_{ij} = 0$, the inequality becomes $u_{i} - u_{j} \\le n-2$, which is redundant given $1 \\le u_{i} \\le n-1$ and $1 \\le u_{j} \\le n-1$, since the maximum possible difference is $(n-1) - 1 = n-2$.\n\nSpecializing to $n=4$ with depot city $1$, we define $u_{2}, u_{3}, u_{4}$ and obtain:\n- Bounds:\n$$\n1 \\le u_{i} \\le 3 \\quad \\text{for } i \\in \\{2,3,4\\}.\n$$\n- MTZ inequalities for all ordered pairs $(i,j)$ with $i,j \\in \\{2,3,4\\}$, $i \\neq j$:\n$$\nu_{i} - u_{j} + 3\\,x_{ij} \\le 2.\n$$\n\nEnumerating these pairs yields the six inequalities:\n$$\nu_{2} - u_{3} + 3x_{23} \\le 2,\\quad\nu_{2} - u_{4} + 3x_{24} \\le 2,\\quad\nu_{3} - u_{2} + 3x_{32} \\le 2,\n$$\n$$\nu_{3} - u_{4} + 3x_{34} \\le 2,\\quad\nu_{4} - u_{2} + 3x_{42} \\le 2,\\quad\nu_{4} - u_{3} + 3x_{43} \\le 2,\n$$\ntogether with $1 \\le u_{i} \\le 3$ for $i \\in \\{2,3,4\\}$.\n\nComparison with the options:\n- Option A exactly matches the derived MTZ form for $n=4$.\n- Option B is incomplete (omits several required $(i,j)$ pairs).\n- Option C uses the alternative coefficient $4$ and right-hand side $3$ but incorrectly sets the upper bound to $4$ instead of $3$ for $u_{2},u_{3},u_{4}$, which does not align with the standard positional interpretation $1 \\le u_{i} \\le n-1$.\n- Option D incorrectly places bounds on $u_{1}$ (which is not part of the MTZ variables in this variant) and uses an upper bound $4$.\n- Option E incorrectly includes city $1$ in the MTZ inequalities and also bounds $u_{1}$, both of which are not part of the standard MTZ construction for a fixed depot.\n\nTherefore, the complete and correct set for this specific problem is given by Option A.", "answer": "$$\\boxed{A}$$", "id": "1411103"}, {"introduction": "An alternative to the MTZ formulation is the more intuitive cut-based approach, central to the Dantzig-Fulkerson-Johnson (DFJ) formulation. These subtour elimination constraints (SECs) are based on a simple, powerful idea: for any subset of cities $S$, a valid tour must cross the \"cut\" between $S$ and the remaining cities at least twice. This exercise [@problem_id:3193309] makes this abstract concept tangible by modeling a network with a physical bridge, demonstrating precisely how SECs enforce connectivity and prevent the tour from breaking into isolated fragments.", "problem": "Consider a symmetric traveling salesman problem over $n=5$ cities whose costs are induced by shortest-path distances on the following undirected road network (a connected weighted graph) with a single bridge. The vertex set is $V=\\{1,2,3,4,5\\}$. The edge set and lengths (in kilometers) are:\n- Left cluster: $\\{(1,2),(2,3),(1,3)\\}$ with lengths $c_{12}=4$, $c_{23}=4$, $c_{13}=7$.\n- Bridge: $\\{(3,4)\\}$ with length $c_{34}=9$. This is the only edge between the left cluster $\\{1,2,3\\}$ and the right cluster $\\{4,5\\}$.\n- Right cluster: $\\{(4,5)\\}$ with length $c_{45}=5$.\nAll edges are undirected, and lengths are nonnegative and satisfy the triangle inequality along the network.\n\nDefine the traveling salesman problem on the complete directed graph on $V$ with arc-costs $c_{ij}$ equal to the shortest-path distance from $i$ to $j$ in the road network for all $i\\neq j$, and $c_{ii}=0$. Thus, the costs $c_{ij}$ inherit the metric induced by the above network. Use the standard directed assignment formulation with binary variables $x_{ij}\\in\\{0,1\\}$ for $i\\neq j$, with the degree equalities $\\sum_{j\\in V\\setminus\\{i\\}}x_{ij}=1$ for all $i\\in V$ and $\\sum_{i\\in V\\setminus\\{j\\}}x_{ij}=1$ for all $j\\in V$. Initially, do not include any Subtour Elimination Constraint (SEC).\n\nTasks:\n1. Compute all-pairs shortest-path distances $c_{ij}$ induced by the road network.\n2. Exhibit a feasible (but disconnected) solution to the degree-equality constraints comprising a $3$-cycle on $\\{1,2,3\\}$ and a $2$-cycle on $\\{4,5\\}$, and compute its objective value under the costs $c_{ij}$.\n3. Let $S=\\{1,2,3\\}$. Write the cut-based Subtour Elimination Constraints (SEC) for the directed formulation specialized to $S$, and explain why the disconnected solution from Task $2$ violates these constraints. Briefly justify why these SECs are pivotal for enforcing connectivity across the bridge.\n4. Determine the optimal Hamiltonian tour length for the $5$-city traveling salesman problem under the metric $c_{ij}$ by reasoning from first principles about how the tour must cross the bridge and traverse each cluster. Your final answer must be a single real number.\n\nExpress the final tour length in kilometers. Round your answer to four significant figures.", "solution": "The problem statement has been validated as scientifically grounded, well-posed, and objective. It is a standard problem in combinatorial optimization with a clear structure and sufficient information for a unique solution.\n\nFirst, we address the four tasks sequentially. The core of the problem is a traveling salesman problem (TSP) on $n=5$ cities, with costs $c_{ij}$ defined as the shortest-path distances on a given underlying road network.\n\n**Task 1: Compute all-pairs shortest-path distances $c_{ij}$**\n\nThe road network consists of two clusters of vertices, $A=\\{1,2,3\\}$ and $B=\\{4,5\\}$, connected by a single bridge edge $(3,4)$. The shortest-path distances $c_{ij}$ are computed as follows:\n\n1.  **Distances within cluster A ($\\{1,2,3\\}$):**\n    -   $c_{12}$: The direct path has length $4$. No shorter path exists. So, $c_{12}=c_{21}=4$.\n    -   $c_{23}$: The direct path has length $4$. No shorter path exists. So, $c_{23}=c_{32}=4$.\n    -   $c_{13}$: The direct path has length $7$. The alternative path $1 \\to 2 \\to 3$ has length $c_{12}+c_{23} = 4+4=8$. The shortest path is the direct one. So, $c_{13}=c_{31}=7$.\n\n2.  **Distances within cluster B ($\\{4,5\\}$):**\n    -   $c_{45}$: The only path is the direct edge of length $5$. So, $c_{45}=c_{54}=5$.\n\n3.  **Distances between clusters A and B:**\n    Any path from a vertex $i \\in A$ to a vertex $j \\in B$ must cross the bridge $(3,4)$. The shortest-path distance is therefore the sum of the shortest distance from $i$ to $3$, the length of the bridge, and the shortest distance from $4$ to $j$.\n    The general formula is $c_{ij} = c_{i3} + c_{34} + c_{4j}$ for $i \\in A, j \\in B$.\n    -   $c_{14} = c_{13} + c_{34} = 7 + 9 = 16$.\n    -   $c_{15} = c_{13} + c_{34} + c_{45} = 7 + 9 + 5 = 21$.\n    -   $c_{24} = c_{23} + c_{34} = 4 + 9 = 13$.\n    -   $c_{25} = c_{23} + c_{34} + c_{45} = 4 + 9 + 5 = 18$.\n    -   $c_{34} = 9$ (the bridge itself).\n    -   $c_{35} = c_{34} + c_{45} = 9 + 5 = 14$.\n    By symmetry of the underlying undirected graph, $c_{ji} = c_{ij}$.\n\nThe complete, symmetric cost matrix $C = (c_{ij})$ for the TSP is:\n$$\nC = \\begin{pmatrix}\n0  4  7  16  21 \\\\\n4  0  4  13  18 \\\\\n7  4  0  9  14 \\\\\n16  13  9  0  5 \\\\\n21  18  14  5  0\n\\end{pmatrix}\n$$\n\n**Task 2: Exhibit a feasible but disconnected solution**\n\nWe are asked to find a feasible solution to the assignment problem relaxation (degree constraints only), which consists of a $3$-cycle on $\\{1,2,3\\}$ and a $2$-cycle on $\\{4,5\\}$.\n-   For the $3$-cycle, we can choose the tour $1 \\to 2 \\to 3 \\to 1$. The corresponding binary variables are $x_{12}=1$, $x_{23}=1$, and $x_{31}=1$. The cost of this subtour is $c_{12} + c_{23} + c_{31} = 4 + 4 + 7 = 15$.\n-   For the $2$-cycle, the tour must be $4 \\to 5 \\to 4$. The corresponding binary variables are $x_{45}=1$ and $x_{54}=1$. The cost of this subtour is $c_{45} + c_{54} = 5 + 5 = 10$.\n\nThe complete disconnected solution is given by the set of non-zero variables $\\{x_{12}, x_{23}, x_{31}, x_{45}, x_{54}\\}$. This set of variables satisfies the degree constraints for each vertex $i \\in V$: $\\sum_j x_{ij} = 1$ and $\\sum_j x_{ji} = 1$. The total objective value for this solution is the sum of the subtour costs: $15 + 10 = 25$.\n\n**Task 3: Subtour Elimination Constraints (SECs)**\n\nThe cut-based SEC for a directed TSP formulation states that for any non-empty proper subset of vertices $S \\subset V$, at least one arc must leave $S$. The constraint is:\n$$\n\\sum_{i \\in S, j \\in V \\setminus S} x_{ij} \\geq 1\n$$\nFor the specific set $S=\\{1,2,3\\}$, we have $V \\setminus S = \\{4,5\\}$, and the SEC becomes:\n$$\n\\sum_{i \\in \\{1,2,3\\}, j \\in \\{4,5\\}} x_{ij} = x_{14} + x_{15} + x_{24} + x_{25} + x_{34} + x_{35} \\geq 1\n$$\nThe disconnected solution from Task $2$ has non-zero variables only for arcs whose endpoints are both within $S$ (i.e., $x_{12}, x_{23}, x_{31}$) or both within $V \\setminus S$ (i.e., $x_{45}, x_{54}$). All variables representing arcs that cross from $S$ to $V \\setminus S$ are zero: $x_{14}=x_{15}=x_{24}=x_{25}=x_{34}=x_{35}=0$.\nSubstituting these values into the SEC gives:\n$$\n0 + 0 + 0 + 0 + 0 + 0 = 0\n$$\nSince $0  1$, the constraint is violated.\n\nThese SECs are pivotal because they enforce connectivity. The set $S$ corresponds to the left cluster of cities, which is connected to the right cluster $V \\setminus S$ only via the bridge in the underlying network. By requiring at least one arc to go from $S$ to $V \\setminus S$, the SEC ensures that any valid tour must \"cross the bridge\", preventing the solution from decomposing into separate, disconnected subtours within each cluster.\n\n**Task 4: Determine the optimal Hamiltonian tour length**\n\nA Hamiltonian tour on $V=\\{1,2,3,4,5\\}$ must visit every city. Given the partition of cities into clusters $A=\\{1,2,3\\}$ and $B=\\{4,5\\}$, any tour must contain a path that spans all cities in $A$, a path that spans all cities in $B$, and two \"crossing\" arcs that connect the endpoints of these paths to form a single cycle.\n\nThe total tour length $L$ can be decomposed as:\n$L = (\\text{Length of Hamiltonian path in } A) + (\\text{Length of Hamiltonian path in } B) + (\\text{Cost of two crossing arcs})$.\n\n1.  **Path in B:** The path must connect vertices $4$ and $5$. The only such path is $4 \\leftrightarrow 5$, with length $c_{45}=5$. The endpoints are $\\{4,5\\}$.\n\n2.  **Path in A:** We must find the length of a Hamiltonian path through $\\{1,2,3\\}$. There are three possibilities for the path's structure (up to reversal):\n    -   Path $1-2-3$: Length $c_{12} + c_{23} = 4 + 4 = 8$. Endpoints are $\\{1,3\\}$.\n    -   Path $2-1-3$: Length $c_{21} + c_{13} = 4 + 7 = 11$. Endpoints are $\\{2,3\\}$.\n    -   Path $1-3-2$: Length $c_{13} + c_{32} = 7 + 4 = 11$. Endpoints are $\\{1,2\\}$.\n\n3.  **Connecting the paths:** We must connect the endpoints of the chosen path in $A$ to the endpoints $\\{4,5\\}$ of the path in $B$ to minimize the total length. Let the endpoints of the path in $A$ be $\\{u,v\\}$. The cost of the crossing arcs is $\\min(c_{u4}+c_{v5}, c_{u5}+c_{v4})$.\n\nLet's evaluate the total tour length for each case:\n\n-   **Case A1 (Path $1-2-3$):** Length in A is $8$, endpoints are $\\{1,3\\}$.\n    -   Crossing cost: $\\min(c_{14}+c_{35}, c_{15}+c_{34}) = \\min(16+14, 21+9) = \\min(30,30) = 30$.\n    -   Total tour length: $8\\ (\\text{path A}) + 5\\ (\\text{path B}) + 30\\ (\\text{crossings}) = 43$.\n    -   An example tour is $3 \\to 2 \\to 1 \\to 5 \\to 4 \\to 3$ with cost $c_{32}+c_{21}+c_{15}+c_{54}+c_{43} = 4+4+21+5+9 = 43$.\n\n-   **Case A2 (Path $2-1-3$):** Length in A is $11$, endpoints are $\\{2,3\\}$.\n    -   Crossing cost: $\\min(c_{24}+c_{35}, c_{25}+c_{34}) = \\min(13+14, 18+9) = \\min(27,27) = 27$.\n    -   Total tour length: $11\\ (\\text{path A}) + 5\\ (\\text{path B}) + 27\\ (\\text{crossings}) = 43$.\n    -   An example tour is $2 \\to 1 \\to 3 \\to 5 \\to 4 \\to 2$ with cost $c_{21}+c_{13}+c_{35}+c_{54}+c_{42} = 4+7+14+5+13=43$.\n\n-   **Case A3 (Path $1-3-2$):** Length in A is $11$, endpoints are $\\{1,2\\}$.\n    -   Crossing cost: $\\min(c_{14}+c_{25}, c_{15}+c_{24}) = \\min(16+18, 21+13) = \\min(34,34) = 34$.\n    -   Total tour length: $11\\ (\\text{path A}) + 5\\ (\\text{path B}) + 34\\ (\\text{crossings}) = 50$.\n\nComparing the total lengths from all cases ($43, 43, 50$), the minimum length is $43$. The optimal Hamiltonian tour length is $43$ kilometers. Rounding to four significant figures gives $43.00$ kilometers.", "answer": "$$\\boxed{43.00}$$", "id": "3193309"}, {"introduction": "While integer programming formulations perfectly describe the TSP, solving them directly can be computationally intensive. A cornerstone of modern solvers is the concept of linear programming (LP) relaxation, where the integrality requirement on variables (e.g., $x_{ij} \\in \\{0,1\\}$) is relaxed to a continuous range (e.g., $0 \\le x_{ij} \\le 1$). The solution to this relaxed problem provides a powerful lower bound on the optimal tour cost. This computational practice [@problem_id:3248052] guides you to calculate this lower bound by solving the assignment problem relaxation for several TSP instances, bridging the gap between theoretical formulation and practical solution strategies.", "problem": "You are asked to compute a linear programming lower bound for the Traveling Salesman Problem (TSP) using the assignment relaxation. Consider the directed TSP on $n$ cities with cost matrix $C = (c_{ij})$ where $c_{ij}$ is the cost to go from city $i$ to city $j$. The standard integer programming formulation introduces decision variables $x_{ij} \\in \\{0,1\\}$ for $i \\neq j$ and $x_{ii} = 0$, and minimizes the tour cost subject to one outgoing and one incoming edge at each city, together with subtour elimination constraints. The assignment linear programming (LP) relaxation drops both integrality and subtour elimination constraints and imposes only the doubly stochastic degree constraints. Formally, the LP relaxation is:\n$$\n\\min_{X} \\sum_{i=1}^{n} \\sum_{j=1}^{n} c_{ij}\\, x_{ij}\n$$\nsubject to\n$$\n\\sum_{j=1}^{n} x_{ij} = 1 \\quad \\text{for all } i \\in \\{1,\\dots,n\\}, \\qquad\n\\sum_{i=1}^{n} x_{ij} = 1 \\quad \\text{for all } j \\in \\{1,\\dots,n\\},\n$$\nand\n$$\n0 \\le x_{ij} \\le 1 \\quad \\text{for all } i,j \\in \\{1,\\dots,n\\}, \\qquad x_{ii} = 0 \\quad \\text{for all } i.\n$$\nThis relaxation yields a lower bound on the optimal TSP tour length because any Hamiltonian cycle is a feasible point of this LP. By the Birkhoff–von Neumann theorem, the feasible region defined by doubly stochastic constraints has extreme points corresponding to permutation matrices. Therefore, solving the LP is equivalent to finding a minimum-cost assignment (one-to-one mapping of cities to successors), which can be solved by algorithms such as the Hungarian method.\n\nYour task is to implement a program that, given several test cost matrices, computes the LP relaxation lower bound by solving the minimum-cost assignment problem for each matrix. To forbid self-loops $x_{ii}$, use a large penalty $M = 10^6$ on diagonal entries $c_{ii}$; that is, set $c_{ii} = M$ to enforce $x_{ii} = 0$ in the optimal assignment.\n\nTest Suite:\n- Test Case 1 (symmetric Euclidean distances on four cities arranged at the corners of a unit square): Cities at coordinates $(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$ with $c_{ij}$ equal to the Euclidean distance from city $i$ to $j$ if $i \\neq j$, and $c_{ii} = M$.\n- Test Case 2 (asymmetric five-city instance):\n$$\nC =\n\\begin{bmatrix}\nM  3  1  5  9 \\\\\n2  M  6  4  3 \\\\\n7  5  M  2  4 \\\\\n3  1  5  M  2 \\\\\n8  2  6  3  M\n\\end{bmatrix}.\n$$\n- Test Case 3 (three-city instance with ties off-diagonal):\n$$\nC =\n\\begin{bmatrix}\nM  2  2 \\\\\n2  M  2 \\\\\n2  2  M\n\\end{bmatrix}.\n$$\n- Test Case 4 (two-city boundary case):\n$$\nC =\n\\begin{bmatrix}\nM  3 \\\\\n5  M\n\\end{bmatrix}.\n$$\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must be a float rounded to three decimal places, in the order of the test cases listed above. For example:\n$$\n[\\text{bound}_{1},\\text{bound}_{2},\\text{bound}_{3},\\text{bound}_{4}]\n$$\nNo physical units apply, and no angles are involved. The results are floats representing lower bounds from the LP relaxation.", "solution": "The user has provided a well-defined problem in the domain of linear programming and combinatorial optimization. The task is to compute a lower bound for the Traveling Salesman Problem (TSP) by solving its assignment relaxation for several given cost matrices.\n\n### Step 1: Problem Validation\n\nThe problem statement is critically evaluated based on the established criteria.\n\n**Extracted Givens:**\n- **Problem:** Compute the lower bound for the directed TSP by solving the assignment relaxation.\n- **LP Formulation (Assignment Relaxation):**\n  $$\n  \\min_{X} \\sum_{i=1}^{n} \\sum_{j=1}^{n} c_{ij}\\, x_{ij}\n  $$\n  subject to:\n  $$\n  \\sum_{j=1}^{n} x_{ij} = 1 \\quad \\text{for all } i \\in \\{1,\\dots,n\\}\n  $$\n  $$\n  \\sum_{i=1}^{n} x_{ij} = 1 \\quad \\text{for all } j \\in \\{1,\\dots,n\\}\n  $$\n  $$\n  0 \\le x_{ij} \\le 1 \\quad \\text{for all } i,j \\in \\{1,\\dots,n\\}\n  $$\n  $$\n  x_{ii} = 0 \\quad \\text{for all } i\n  $$\n- **Methodology:** The problem states that this LP is equivalent to a minimum-cost assignment problem, solvable by algorithms like the Hungarian method. The constraint $x_{ii}=0$ is to be enforced by setting the diagonal costs $c_{ii}$ to a large penalty value, $M=10^6$.\n- **Test Cases:**\n  1. A $4 \\times 4$ symmetric cost matrix derived from the Euclidean distances between vertices of a unit square, with $c_{ii}=M$.\n  2. A $5 \\times 5$ asymmetric cost matrix.\n  3. A $3 \\times 3$ symmetric cost matrix.\n  4. A $2 \\times 2$ asymmetric cost matrix.\n- **Output Format:** A single line with a comma-separated list of floating-point results rounded to three decimal places, enclosed in square brackets.\n\n**Validation Results:**\n- **Scientific Grounding:** The problem is scientifically and mathematically sound. The assignment relaxation of the TSP is a standard technique in operations research. The formulation provided is the correct definition of the assignment problem as a linear program. The reference to the Birkhoff-von Neumann theorem and the equivalence to a minimum-cost assignment (or minimum weight perfect matching in a bipartite graph) are standard theoretical results. The use of a penalty term to forbid self-loops is a common and valid modeling practice.\n- **Well-Posedness:** The problem is well-posed. For any given cost matrix, the assignment problem has a unique, stable, and meaningful optimal cost.\n- **Objectivity:** The problem is stated objectively using precise mathematical language, free from ambiguity or subjective claims.\n- **Completeness and Consistency:** All necessary data (cost matrices, penalty value) and definitions are provided. The problem is self-contained and free of contradictions.\n\n**Verdict:** The problem is **valid**. It is a standard computational problem in the field of numerical optimization.\n\n### Step 2: Solution Design\n\nThe core task is to solve the minimum-cost assignment problem. As the use of libraries such as `scipy` is forbidden by the execution environment constraints, a from-scratch implementation of a suitable algorithm is required. The Hungarian algorithm is the canonical method for this problem and will be implemented.\n\nThe Hungarian algorithm operates on a cost matrix and consists of the following phases:\n1.  **Reduction:** Subtract the minimum value from each row and then from each column to create zero entries in the matrix without changing the optimal assignment. The sum of subtracted values provides a component of the total cost.\n2.  **Assignment:** Find a maximum matching in the bipartite graph corresponding to the zero-valued entries of the reduced cost matrix. A standard approach for this is using augmenting paths, which can be found via a Depth-First Search (DFS) or Breadth-First Search (BFS).\n3.  **Optimality Check:** If the size of the maximum matching equals the matrix dimension $n$, an optimal assignment has been found among the zero entries. The total cost is the sum of the costs from the *original* matrix at the positions of the optimal assignment.\n4.  **Matrix Update:** If the matching is not of size $n$, the cost matrix must be updated to create new opportunities for zero-cost assignments. This involves:\n    a. Finding the minimum number of lines (horizontal or vertical) required to cover all zeros in the matrix. By König's theorem, this number is equal to the size of the maximum matching. This set of lines can be determined from the augmenting path search state.\n    b. Identifying the minimum value, $\\delta$, among all elements not covered by any line.\n    c. Subtracting $\\delta$ from all uncovered elements and adding it to all elements covered by two lines (intersections).\n    d. Repeating from Step 2 with the updated matrix.\n\nThe implementation will consist of a main function to orchestrate these steps and a helper function for the DFS-based maximum matching search. This process is guaranteed to terminate and find the optimal assignment.\n\nThe complete solution will be encapsulated in a Python script that sets up each test case, calls the implemented Hungarian algorithm solver, and formats the output as specified.\n\n- **Test Case 1:** The $4 \\times 4$ cost matrix will be programmatically generated based on the Euclidean distances between the points $(0,0), (1,0), (1,1), (0,1)$. The diagonal will be set to $M=10^6$. The expected minimum cost is $4.0$, corresponding to the tour around the perimeter of the square.\n- **Test Case 2:** The provided $5 \\times 5$ asymmetric matrix will be used. The minimum cost assignment is found to be $9$.\n- **Test Case 3:** The $3 \\times 3$ matrix will be used. Any valid assignment forms a 3-cycle with a total cost of $2+2+2 = 6$.\n- **Test Case 4:** The $2 \\times 2$ matrix will be used. The only valid assignment is the 2-cycle with cost $3+5=8$.\n\nThe final code will calculate these values and present them in the required format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _dfs_match(u, adj, match, visited_v):\n    \"\"\"\n    A helper depth-first search function to find an augmenting path in a bipartite graph.\n    This is used to find the maximum matching.\n\n    Args:\n        u (int): The current vertex in the first partition (U, representing rows).\n        adj (list[list[int]]): Adjacency list where adj[u] contains neighbors of u in V.\n        match (np.ndarray): An array where match[v] = u if (u, v) is in the current matching.\n        visited_v (np.ndarray): A boolean array tracking visited vertices in the second partition (V, columns) during the current DFS.\n\n    Returns:\n        bool: True if an augmenting path is found, False otherwise.\n    \"\"\"\n    for v in adj[u]:\n        if not visited_v[v]:\n            visited_v[v] = True\n            if match[v]  0 or _dfs_match(match[v], adj, match, visited_v):\n                match[v] = u\n                return True\n    return False\n\ndef _solve_assignment_problem(cost_matrix):\n    \"\"\"\n    Solves the assignment problem (minimum weight perfect matching in a bipartite graph)\n    using the Hungarian algorithm. This implementation is necessary as external libraries\n    like scipy.optimize.linear_sum_assignment are not permitted.\n\n    Args:\n        cost_matrix (np.ndarray): The n x n cost matrix.\n\n    Returns:\n        float: The total cost of the optimal assignment.\n    \"\"\"\n    n = cost_matrix.shape[0]\n    original_cost_matrix = cost_matrix.copy()\n    cost = cost_matrix.copy()\n\n    # Step 1: Row and column reduction\n    cost -= np.min(cost, axis=1)[:, np.newaxis]\n    cost -= np.min(cost, axis=0)[np.newaxis, :]\n\n    while True:\n        # Step 2: Find a maximum matching in the graph of zero-cost edges.\n        adj = [[] for _ in range(n)]\n        for r in range(n):\n            for c in range(n):\n                if np.isclose(cost[r, c], 0):\n                    adj[r].append(c)\n\n        match = np.full(n, -1, dtype=int)  # match[col] = row\n        match_size = 0\n        for r in range(n):\n            visited_v = np.zeros(n, dtype=bool)\n            if _dfs_match(r, adj, match, visited_v):\n                match_size += 1\n\n        # Step 3: Check for optimality.\n        if match_size == n:\n            assignment_cols = np.arange(n)\n            assignment_rows = match[assignment_cols]\n            total_cost = original_cost_matrix[assignment_rows, assignment_cols].sum()\n            return total_cost\n\n        # Step 4: Update cost matrix if matching is not perfect.\n        # Find minimum line cover using the state of the matching algorithm.\n        unmatched_rows = np.where(~np.isin(np.arange(n), match))[0]\n        \n        reachable_rows = set(unmatched_rows)\n        reachable_cols = set()\n\n        q = list(unmatched_rows)\n        head = 0\n        while head  len(q):\n            u = q[head]\n            head += 1\n            for v in adj[u]:\n                if v not in reachable_cols:\n                    reachable_cols.add(v)\n                    u_partner = match[v]\n                    if u_partner != -1 and u_partner not in reachable_rows:\n                        reachable_rows.add(u_partner)\n                        q.append(u_partner)\n        \n        # Uncovered elements are in reachable rows and unreachable columns.\n        unreachable_cols = set(range(n)) - reachable_cols\n        rows_idx = np.array(list(reachable_rows))\n        cols_idx = np.array(list(unreachable_cols))\n\n        if len(rows_idx) == 0 or len(cols_idx) == 0:\n            # This case implies no uncovered elements, which should not happen\n            # if the matching is not yet of size n. Can indicate an issue\n            # with floating point precision. For this problem's scope, we assume\n            # a non-zero minimum will always be found.\n            continue\n\n        min_val = np.min(cost[np.ix_(rows_idx, cols_idx)])\n\n        # Subtract min_val from all uncovered elements.\n        cost[np.ix_(rows_idx, cols_idx)] -= min_val\n        \n        # Add min_val to all double-covered elements (unreachable rows, reachable cols).\n        unreachable_rows = set(range(n)) - reachable_rows\n        rows_to_add_idx = np.array(list(unreachable_rows))\n        cols_to_add_idx = np.array(list(reachable_cols))\n        \n        if len(rows_to_add_idx)  0 and len(cols_to_add_idx)  0:\n            cost[np.ix_(rows_to_add_idx, cols_to_add_idx)] += min_val\n\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, compute the LP relaxation lower bound for each,\n    and print the results in the specified format.\n    \"\"\"\n    M = 1e6\n    \n    # Test Case 1: Symmetric Euclidean distances on a unit square\n    coords = np.array([[0, 0], [1, 0], [1, 1], [0, 1]])\n    n1 = 4\n    c1 = np.zeros((n1, n1))\n    for i in range(n1):\n        for j in range(n1):\n            if i == j:\n                c1[i, j] = M\n            else:\n                c1[i, j] = np.linalg.norm(coords[i] - coords[j])\n    \n    # Test Case 2: Asymmetric 5-city instance\n    c2 = np.array([\n        [M, 3, 1, 5, 9],\n        [2, M, 6, 4, 3],\n        [7, 5, M, 2, 4],\n        [3, 1, 5, M, 2],\n        [8, 2, 6, 3, M]\n    ])\n    \n    # Test Case 3: 3-city instance with ties\n    c3 = np.array([\n        [M, 2, 2],\n        [2, M, 2],\n        [2, 2, M]\n    ])\n    \n    # Test Case 4: 2-city boundary case\n    c4 = np.array([\n        [M, 3],\n        [5, M]\n    ])\n    \n    test_cases = [c1, c2, c3, c4]\n    \n    results = []\n    for cost_matrix in test_cases:\n        bound = _solve_assignment_problem(cost_matrix)\n        results.append(bound)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```", "id": "3248052"}]}