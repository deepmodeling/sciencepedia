{"hands_on_practices": [{"introduction": "This first practice grounds us in one of the most fundamental templates in optimization: resource allocation. By tackling the hypothetical scenario of designing a museum layout, you will learn to translate a real-world problem into the precise language of Linear Programming (LP). This exercise [@problem_id:3106569] focuses on identifying decision variables, formulating a linear objective function to maximize, and defining a system of linear inequalities that represent physical and budgetary constraints, a core skill for any optimization modeler.", "problem": "A museum wishes to allocate floor space and electrical power to a set of interactive exhibits to maximize visitor engagement. The decision variables are the floor space $x_i$ (in square meters, denoted as $\\mathrm{m}^2$) and electrical power $p_i$ (in kilowatts, denoted as $\\mathrm{kW}$) assigned to exhibit $i$ for $i \\in \\{1,\\dots,n\\}$. Engagement is modeled as a linear function $\\sum_{i=1}^{n} \\alpha_i x_i + \\sum_{i=1}^{n} \\beta_i p_i$, where $\\alpha_i$ and $\\beta_i$ are nonnegative coefficients reflecting marginal engagement per unit space and power, respectively. The allocations must satisfy resource constraints: a total space budget, a total power budget, per-exhibit upper bounds on space and power, and a linear coupling between power and space for each exhibit reflecting maximum power density.\n\nFrom the fundamental base of Linear Programming (LP), which optimizes a linear objective subject to linear constraints over a convex polyhedron, formulate the allocation problem as an LP and implement a solver that, for given parameters, computes the allocation vector that maximizes engagement. The feasible set must reflect the standard physical realism: nonnegative allocations, capacity limits, and linear coupling constraints of the form $p_i \\le r_i x_i$ where $r_i$ is the maximum allowable power density for exhibit $i$ measured in $\\mathrm{kW}/\\mathrm{m}^2$.\n\nYou must use the following canonical LP modeling template: define the decision vector $y = [x_1,\\dots,x_n,p_1,\\dots,p_n]^\\top$, construct a linear objective and linear inequality system that captures all constraints, and compute an optimal $y^\\star$.\n\nThe program must solve the LP for each test case below and output, for each case, a single list containing the optimal allocations and the optimal engagement value in the specific order $[x_1,\\dots,x_n,p_1,\\dots,p_n,z]$, where $z$ is the maximized value of $\\sum_{i=1}^{n} \\alpha_i x_i + \\sum_{i=1}^{n} \\beta_i p_i$. All $x_i$ must be interpreted in $\\mathrm{m}^2$ and all $p_i$ must be interpreted in $\\mathrm{kW}$; report numerical values only, with no unit symbols, rounded to four decimal places.\n\nFundamental definitions to use:\n- Linear Programming (LP): maximize or minimize a linear objective function subject to linear equality and inequality constraints over a set defined by linear bounds. The feasible region is a convex polyhedron, and an optimal solution (if one exists) is attained at an extreme point.\n- Nonnegativity and capacity constraints reflect physical limits of resources and equipment.\n\nYou must not use shortcut formulas beyond these fundamental bases. Derive the linear model from first principles: decision variables, objective, and constraints. Then solve the LP using a general-purpose solver.\n\nTest suite:\n- Case $1$ (happy path, moderately tight budgets, multiple exhibits, all constraints potentially active):\n  - Number of exhibits: $n = 3$.\n  - Engagement coefficients: $\\alpha = (3.0,\\, 2.5,\\, 1.0)$ and $\\beta = (5.0,\\, 2.0,\\, 4.0)$.\n  - Budgets: total space $S = 120.0$ $\\mathrm{m}^2$, total power $P = 30.0$ $\\mathrm{kW}$.\n  - Power density limits: $r = (0.20,\\, 0.10,\\, 0.25)$ $\\mathrm{kW}/\\mathrm{m}^2$.\n  - Per-exhibit upper bounds: $\\bar{x} = (60.0,\\, 50.0,\\, 80.0)$ $\\mathrm{m}^2$, $\\bar{p} = (15.0,\\, 20.0,\\, 12.0)$ $\\mathrm{kW}$.\n- Case $2$ (boundary case where total power is tight and coupling constraints are significant):\n  - Number of exhibits: $n = 3$.\n  - Engagement coefficients: $\\alpha = (2.0,\\, 1.5,\\, 3.0)$ and $\\beta = (1.0,\\, 0.5,\\, 2.0)$.\n  - Budgets: total space $S = 80.0$ $\\mathrm{m}^2$, total power $P = 12.0$ $\\mathrm{kW}$.\n  - Power density limits: $r = (0.15,\\, 0.12,\\, 0.20)$ $\\mathrm{kW}/\\mathrm{m}^2$.\n  - Per-exhibit upper bounds: $\\bar{x} = (40.0,\\, 40.0,\\, 60.0)$ $\\mathrm{m}^2$, $\\bar{p} = (10.0,\\, 10.0,\\, 15.0)$ $\\mathrm{kW}$.\n- Case $3$ (edge case with zero marginal engagement for space on one exhibit and zero marginal engagement for power on another, with tight coupling):\n  - Number of exhibits: $n = 2$.\n  - Engagement coefficients: $\\alpha = (0.0,\\, 0.9)$ and $\\beta = (2.0,\\, 0.0)$.\n  - Budgets: total space $S = 10.0$ $\\mathrm{m}^2$, total power $P = 5.0$ $\\mathrm{kW}$.\n  - Power density limits: $r = (0.50,\\, 0.20)$ $\\mathrm{kW}/\\mathrm{m}^2$.\n  - Per-exhibit upper bounds: $\\bar{x} = (10.0,\\, 10.0)$ $\\mathrm{m}^2$, $\\bar{p} = (5.0,\\, 1.0)$ $\\mathrm{kW}$.\n\nModeling requirements:\n- Decision variables: $x_i \\ge 0$ and $p_i \\ge 0$ for all $i$.\n- Objective: maximize $\\sum_{i=1}^{n} \\alpha_i x_i + \\sum_{i=1}^{n} \\beta_i p_i$.\n- Constraints:\n  - Total space: $\\sum_{i=1}^{n} x_i \\le S$.\n  - Total power: $\\sum_{i=1}^{n} p_i \\le P$.\n  - Coupling: $p_i \\le r_i x_i$ for all $i$.\n  - Bounds: $0 \\le x_i \\le \\bar{x}_i$ and $0 \\le p_i \\le \\bar{p}_i$ for all $i$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list containing $[x_1,\\dots,x_n,p_1,\\dots,p_n,z]$ with all numbers rounded to four decimals. For example, in the correct format: $[[\\dots],[\\dots],[\\dots]]$ where there are no spaces after commas. Do not include unit symbols in the output; interpret $x_i$ values in $\\mathrm{m}^2$ and $p_i$ values in $\\mathrm{kW}$.", "solution": "The user wants me to solve a linear programming problem related to resource allocation in a museum.\n\nHere's my plan:\n1.  **Validate the problem statement.**\n    -   **Step 1: Extract Givens.** I will list all the variables, constants, and constraints provided in the problem description.\n    -   **Step 2: Validate Using Extracted Givens.** I will check if the problem is scientifically grounded, well-posed, objective, and complete. It seems to be a standard resource allocation problem, which is a canonical application of linear programming. The setup is clear, and all necessary parameters are provided for the test cases. The constraints are linear, and the objective function is linear. This fits the definition of a Linear Programming (LP) problem. The physical constraints (non-negativity, capacity limits) are realistic. The problem is well-posed and objective. It is directly related to the specified topic of optimization methods and canonical modeling templates (resource allocation).\n    -   **Step 3: Verdict and Action.** The problem appears to be valid. I will proceed with the solution.\n\n2.  **Formulate the solution.**\n    -   **Principle-Based Design**: I need to explain the formulation of the LP problem from first principles.\n    -   **Decision Variables**: The problem defines them as $x_i$ (space) and $p_i$ (power) for each exhibit $i$. It asks to create a single decision vector $y = [x_1, \\dots, x_n, p_1, \\dots, p_n]^\\top$. This vector has $2n$ elements.\n    -   **Objective Function**: The goal is to maximize total engagement, which is given as a linear function: $z = \\sum_{i=1}^{n} \\alpha_i x_i + \\sum_{i=1}^{n} \\beta_i p_i$. In matrix form, this is $c^\\top y$, where $c = [\\alpha_1, \\dots, \\alpha_n, \\beta_1, \\dots, \\beta_n]^\\top$. Since standard LP solvers typically minimize, I will maximize $c^\\top y$ by minimizing $-c^\\top y$.\n    -   **Constraints**: I need to list all constraints and express them in the form $A_{ub} y \\le b_{ub}$ and $A_{eq} y = b_{eq}$ (if any). The problem only has inequality constraints.\n        -   **Total Space**: $\\sum_{i=1}^{n} x_i \\le S$.\n        -   **Total Power**: $\\sum_{i=1}^{n} p_i \\le P$.\n        -   **Coupling**: $p_i \\le r_i x_i$ for each $i=1, \\dots, n$. This can be rewritten as $-r_i x_i + p_i \\le 0$.\n        -   **Upper Bounds**: $x_i \\le \\bar{x}_i$ and $p_i \\le \\bar{p}_i$ for each $i=1, \\dots, n$.\n        -   **Non-negativity**: $x_i \\ge 0$ and $p_i \\ge 0$ for each $i=1, \\dots, n$. These are typically handled as bounds by LP solvers, so I don't need to put them in the $A_{ub}$ matrix. The `scipy.optimize.linprog` function takes `bounds` as a separate argument. The bounds for each variable $y_j$ are $(l_j, u_j)$.\n            - For $j = 1, \\dots, n$, the variable is $x_j$, and its bounds are $(0, \\bar{x}_j)$.\n            - For $j = n+1, \\dots, 2n$, the variable is $p_{j-n}$, and its bounds are $(0, \\bar{p}_{j-n})$.\n\n3.  **Construct the matrices for the LP solver.**\n    -   Let's be systematic. The decision vector is $y = [x_1, \\dots, x_n, p_1, \\dots, p_n]^\\top$. It has dimension $2n \\times 1$.\n    -   The objective vector is $c = [\\alpha_1, \\dots, \\alpha_n, \\beta_1, \\dots, \\beta_n]^\\top$. We want to maximize $c^\\top y$, which is equivalent to minimizing $-c^\\top y$.\n    -   The constraints need to be written in the form $A_{ub} y \\le b_{ub}$.\n        -   **Total Space Constraint (1 row):**\n            $\\sum_{i=1}^{n} x_i + \\sum_{i=1}^{n} 0 \\cdot p_i \\le S$.\n            The corresponding row in $A_{ub}$ will be $[1, 1, \\dots, 1, 0, 0, \\dots, 0]$ (n ones followed by n zeros). The corresponding element in $b_{ub}$ is $S$.\n        -   **Total Power Constraint (1 row):**\n            $\\sum_{i=1}^{n} 0 \\cdot x_i + \\sum_{i=1}^{n} p_i \\le P$.\n            The corresponding row in $A_{ub}$ will be $[0, 0, \\dots, 0, 1, 1, \\dots, 1]$ (n zeros followed by n ones). The corresponding element in $b_{ub}$ is $P$.\n        -   **Coupling Constraints ($n$ rows):**\n            For each $i \\in \\{1, \\dots, n\\}$, we have $-r_i x_i + p_i \\le 0$.\n            The $i$-th coupling constraint row in $A_{ub}$ will have $-r_i$ at the $i$-th position (for $x_i$), $+1$ at the $(n+i)$-th position (for $p_i$), and zeros elsewhere. The corresponding element in $b_{ub}$ is $0$.\n        -   **Total number of inequality constraints**: $1$ (space) + $1$ (power) + $n$ (coupling) = $n+2$.\n        -   So, $A_{ub}$ will be a matrix of size $(n+2) \\times 2n$.\n        -   And $b_{ub}$ will be a vector of size $(n+2) \\times 1$.\n    -   The bounds are handled separately. For each variable $y_k$, the bound is $[0, u_k]$.\n        -   For $k \\in \\{1, \\dots, n\\}$, the variable is $x_k$, and the upper bound is $\\bar{x}_k$. So, bounds are $(0, \\bar{x}_k)$.\n        -   For $k \\in \\{n+1, \\dots, 2n\\}$, the variable is $p_{k-n}$, and the upper bound is $\\bar{p}_{k-n}$. So, bounds are $(0, \\bar{p}_{k-n})$.\n        The `scipy.optimize.linprog` function accepts a list of tuples for the bounds.\n\n4.  **Implement the Python code.**\n    -   Use `scipy.optimize.linprog`.\n    -   The function signature is `linprog(c, A_ub=None, b_ub=None, A_eq=None, b_eq=None, bounds=None, method='highs')`.\n    -   I'll use the 'highs' solver, which is the default and generally robust.\n    -   `c`: The coefficients of the objective function to be **minimized**. So I must pass `-c = [-\\alpha_1, ..., -\\beta_n]`.\n    -   `A_ub`: The inequality constraint matrix.\n    -   `b_ub`: The inequality constraint vector.\n    -   `bounds`: A sequence of `(min, max)` pairs for each decision variable.\n    -   The `linprog` function returns a result object. The optimal values are in `result.x`, and the optimal objective function value is `result.fun`. Since I minimized $-c^\\top y$, `result.fun` will be the minimum value, so the maximum value of the original objective is `-result.fun`.\n    -   I'll create a function `solve_case(params)` that takes the parameters for one test case, constructs the matrices, calls `linprog`, and formats the output.\n    -   The main part of the script will define the test cases and loop through them, calling `solve_case` for each.\n    -   The final output needs to be a list of lists, with each inner list being `[x_1, ..., x_n, p_1, ..., p_n, z]`, with numbers rounded to four decimal places. The format is `[[...],[...],[...]]`.\n\n5.  **Walk through one case to be sure:**\n    -   **Case 1:**\n        -   `n = 3`\n        -   Decision vector `y = [x_1, x_2, x_3, p_1, p_2, p_3]^\\top` (6 variables).\n        -   `alpha = [3.0, 2.5, 1.0]`\n        -   `beta = [5.0, 2.0, 4.0]`\n        -   `c_max = [3.0, 2.5, 1.0, 5.0, 2.0, 4.0]`\n        -   `c_min = [-3.0, -2.5, -1.0, -5.0, -2.0, -4.0]`\n        -   `S = 120.0`, `P = 30.0`\n        -   `r = [0.20, 0.10, 0.25]`\n        -   `x_bar = [60.0, 50.0, 80.0]`\n        -   `p_bar = [15.0, 20.0, 12.0]`\n\n        -   **Bounds**:\n            - `x_1`: `(0, 60.0)`\n            - `x_2`: `(0, 50.0)`\n            - `x_3`: `(0, 80.0)`\n            - `p_1`: `(0, 15.0)`\n            - `p_2`: `(0, 20.0)`\n            - `p_3`: `(0, 12.0)`\n            `bounds = [(0, 60), (0, 50), (0, 80), (0, 15), (0, 20), (0, 12)]`\n\n        -   **Inequality Constraints `A_ub y = b_ub`**:\n            - Number of constraints = $n+2 = 5$.\n            - `A_ub` is $5 \\times 6$. `b_ub` is $5 \\times 1$.\n\n            1.  **Space:** `x_1 + x_2 + x_3 = 120.0`\n                Row 1 of `A_ub`: `[1, 1, 1, 0, 0, 0]`\n                `b_ub[0] = 120.0`\n            2.  **Power:** `p_1 + p_2 + p_3 = 30.0`\n                Row 2 of `A_ub`: `[0, 0, 0, 1, 1, 1]`\n                `b_ub[1] = 30.0`\n            3.  **Coupling 1:** `p_1 = 0.20 * x_1 = -0.20*x_1 + p_1 = 0`\n                Row 3 of `A_ub`: `[-0.20, 0, 0, 1, 0, 0]`\n                `b_ub[2] = 0.0`\n            4.  **Coupling 2:** `p_2 = 0.10 * x_2 = -0.10*x_2 + p_2 = 0`\n                Row 4 of `A_ub`: `[0, -0.10, 0, 0, 1, 0]`\n                `b_ub[3] = 0.0`\n            5.  **Coupling 3:** `p_3 = 0.25 * x_3 = -0.25*x_3 + p_3 = 0`\n                Row 5 of `A_ub`: `[0, 0, -0.25, 0, 0, 1]`\n                `b_ub[4] = 0.0`\n\n        -   **Matrix `A_ub`:**\n            ```\n            [[ 1.0,  1.0,  1.0,  0.0,  0.0,  0.0],\n             [ 0.0,  0.0,  0.0,  1.0,  1.0,  1.0],\n             [-0.2,  0.0,  0.0,  1.0,  0.0,  0.0],\n             [ 0.0, -0.1,  0.0,  0.0,  1.0,  0.0],\n             [ 0.0,  0.0, -0.25, 0.0,  0.0,  1.0]]\n            ```\n        -   **Vector `b_ub`:**\n            `[120.0, 30.0, 0.0, 0.0, 0.0]`\n\n        -   This seems correct and ready for implementation. I will construct these matrices dynamically based on `n`.\n\n6.  **Code Structure:**\n    -   `solve()` function:\n        -   `test_cases` list containing dictionaries or tuples for each case's parameters. A tuple seems fine. `(n, alpha, beta, S, P, r, x_bar, p_bar)`.\n        -   `results = []`.\n        -   Loop `for case in test_cases`:\n            -   Unpack `n, alpha, beta, S, P, r, x_bar, p_bar`.\n            -   Construct `c`, `A_ub`, `b_ub`, `bounds`.\n            -   `n_vars = 2 * n`\n            -   `c = -np.concatenate([alpha, beta])`\n            -   `A_ub = np.zeros((n + 2, n_vars))`\n            -   `b_ub = np.zeros(n + 2)`\n            -   `A_ub[0, :n] = 1` (space constraint)\n            -   `b_ub[0] = S`\n            -   `A_ub[1, n:] = 1` (power constraint)\n            -   `b_ub[1] = P`\n            -   Loop `for i in range(n)`:\n                -   `A_ub[2 + i, i] = -r[i]` (coupling x_i)\n                -   `A_ub[2 + i, n + i] = 1` (coupling p_i)\n                -   `b_ub[2 + i] = 0`\n            -   `bounds` list: `[(0, x_bar[i]) for i in range(n)] + [(0, p_bar[i]) for i in range(n)]`\n            -   `res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')`\n            -   Check `res.success`. The problem is well-formed, so it should succeed.\n            -   `optimal_y = res.x`\n            -   `optimal_z = -res.fun`\n            -   Combine `optimal_y` and `optimal_z` into a single list.\n            -   Round all values to 4 decimal places.\n            -   Append the formatted list to `results`.\n    -   Final print statement: `print(f\"[{','.join(map(str, results))}]\")`. This format is tricky. I need to convert each inner list to a string without spaces.\n        -   `str(a_list)` will produce `[1, 2, 3]`.\n        -   I need `[1,2,3]`.\n        -   So, for each result list, I'll need `f\"[{','.join(map(str, rounded_result_list))}]\"`.\n        -   Then I join these strings with a comma: `f\"[{','.join(stringified_results)}]\"`\n\nLet's refine the printing part.\nExample `results = [[1,2], [3,4]]`.\nI need `[[1,2],[3,4]]`.\n`repr(results)` gives `'[[1.0, 2.0], [3.0, 4.0]]'`. This has spaces.\nSo I need to build the string manually.\n```python\nfinal_list_strs = []\nfor res_list in results:\n    # res_list is [1.1234, 2.5678, ...]\n    res_list_str = f\"[{','.join([f'{v:.4f}' for v in res_list])}]\"\n    final_list_strs.append(res_list_str)\nprint(f\"[{','.join(final_list_strs)}]\")\n```\nWait, the example output is `[{','.join(map(str, results))}]`. Here, `results` is a list of strings. So `results` should not be a list of lists of numbers. It should be a list of the final formatted strings for each case. No, `results` is a list of Python *objects*. The `map(str, results)` will convert each inner list to its string representation, which includes spaces.\n\nLet's look at the sample output format again: `[[x1,...,z],[x1,...,z],...]`.\nIf `results` is a list of lists of numbers `[[1.23, 4.56], [7.89, 0.12]]`, I need to generate `[[1.23,4.56],[7.89,0.12]]`.\n```python\noutput_parts = []\nfor res_list in results: # res_list is like [1.23, 4.56]\n    # format numbers and join without space\n    formatted_numbers = [f\"{num:.4f}\" for num in res_list]\n    part_str = \"[\" + \",\".join(formatted_numbers) + \"]\"\n    output_parts.append(part_str)\nfinal_output = \"[\" + \",\".join(output_parts) + \"]\"\nprint(final_output)\n```\nThis is the reliable way to produce the exact string format required. I will use this logic in my python code implementation.\n\nLet's check the solution logic derivation again. It needs to be from first principles.\n\n**Solution section structure:**\n1.  **Problem Formulation:** State the goal is to formulate this as a Linear Program (LP).\n2.  **Decision Variables:** Define the vector $y$ as required, containing all $x_i$ and $p_i$. Explain that there are $2n$ variables.\n3.  **Objective Function:**\n    -   State the objective: maximize engagement $z = \\sum_{i=1}^{n} \\alpha_i x_i + \\sum_{i=1}^{n} \\beta_i p_i$.\n    -   Express this in vector form as maximizing $z = c^\\top y$, where $c$ is the vector of engagement coefficients.\n    -   Mention that standard LP solvers perform minimization, so we will minimize $-c^\\top y$.\n4.  **Constraints:**\n    -   Systematically list all constraints given in the problem.\n    -   For each constraint type, show its mathematical form.\n    -   Show how to convert it to the standard LP form $A_{ub} y \\le b_{ub}$.\n    -   **Total Space:** $\\sum x_i \\le S$. Describe the corresponding row in $A_{ub}$ and entry in $b_{ub}$.\n    -   **Total Power:** $\\sum p_i \\le P$. Describe the corresponding row in $A_{ub}$ and entry in $b_{ub}$.\n    -   **Coupling:** $p_i - r_i x_i \\le 0$ for each $i$. Describe the $n$ rows in $A_{ub}$ and entries in $b_{ub}$.\n    -   **Bounds:** $0 \\le x_i \\le \\bar{x}_i$ and $0 \\le p_i \\le \\bar{p}_i$. Explain that these are handled as variable bounds, not as part of the $A_{ub}$ matrix, which is a standard feature of LP solvers.\n5.  **Canonical LP Model Summary:**\n    -   Bring it all together: state the final LP problem is to minimize $-c^\\top y$ subject to $A_{ub} y \\le b_{ub}$ and $l \\le y \\le u$, where $l$ and $u$ are the lower and upper bound vectors.\n    -   Define the dimensions of the matrices and vectors involved ($A_{ub}$ is $(n+2) \\times 2n$, etc.).\n6.  **Implementation via `scipy.optimize.linprog`**:\n    -   Explain that this formulated LP can be solved using computational tools. Mention that the `scipy.optimize.linprog` function will be used.\n    -   Briefly map the components ($c$, $A_{ub}$, $b_{ub}$, bounds) to the function's arguments.\n\nThis structure seems complete, reasoned, and follows the \"Principle-Based Design\" requirement. It derives the model from first principles and then describes how to solve it. I will ensure every single mathematical symbol is in LaTeX. This is a lot of work but a strict requirement. For example, even `1` should be `$1$`.\n\nI will double check the test cases.\nCase 1: `n=3`. `x` variables: $x_1, x_2, x_3$. `p` variables: $p_1, p_2, p_3$. Total 6 variables. $1+1+3=5$ constraints in $A_{ub}$.\nCase 2: `n=3`. Same structure.\nCase 3: `n=2`. `x` variables: $x_1, x_2$. `p` variables: $p_1, p_2$. Total 4 variables. $1+1+2=4$ constraints in $A_{ub}$.\n\nThe problem is clear that $\\alpha_i$ and $\\beta_i$ are nonnegative. This is important as it ensures the objective function is bounded above on the feasible set (which is compact). The existence of an optimal solution is guaranteed by the Extreme Value Theorem, as the feasible set (a polyhedron defined by linear inequalities) is closed and bounded (compact), and the objective function is continuous. LP theory further guarantees that an optimal solution exists at a vertex of the polyhedron if the feasible set is non-empty. The problem setup ensures a non-empty feasible set (e.g., $x_i=0, p_i=0$ for all $i$ is a feasible solution). The problem is well-posed.\n\nFinal check on the output format.\n`[x_1,\\dots,x_n,p_1,\\dots,p_n,z]`\n`x_i` in $\\mathrm{m}^2$, `p_i` in $\\mathrm{kW}$.\nAll numbers rounded to four decimal places.\nThe overall output is `[[case1_results], [case2_results], [case3_results]]`.\nExample: `[[1.0000,2.0000,..,100.0000],[...],[...]]`\nThe manual string construction I planned earlier is correct for this.\n`f\"{num:.4f}\"` will correctly format the numbers.\n\nLooks like a solid plan. I am ready to write.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of linear programming problems for museum resource allocation.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"n\": 3,\n            \"alpha\": np.array([3.0, 2.5, 1.0]),\n            \"beta\": np.array([5.0, 2.0, 4.0]),\n            \"S\": 120.0,\n            \"P\": 30.0,\n            \"r\": np.array([0.20, 0.10, 0.25]),\n            \"x_bar\": np.array([60.0, 50.0, 80.0]),\n            \"p_bar\": np.array([15.0, 20.0, 12.0]),\n        },\n        # Case 2\n        {\n            \"n\": 3,\n            \"alpha\": np.array([2.0, 1.5, 3.0]),\n            \"beta\": np.array([1.0, 0.5, 2.0]),\n            \"S\": 80.0,\n            \"P\": 12.0,\n            \"r\": np.array([0.15, 0.12, 0.20]),\n            \"x_bar\": np.array([40.0, 40.0, 60.0]),\n            \"p_bar\": np.array([10.0, 10.0, 15.0]),\n        },\n        # Case 3\n        {\n            \"n\": 2,\n            \"alpha\": np.array([0.0, 0.9]),\n            \"beta\": np.array([2.0, 0.0]),\n            \"S\": 10.0,\n            \"P\": 5.0,\n            \"r\": np.array([0.50, 0.20]),\n            \"x_bar\": np.array([10.0, 10.0]),\n            \"p_bar\": np.array([5.0, 1.0]),\n        },\n    ]\n\n    results_for_all_cases = []\n    \n    for case in test_cases:\n        n = case[\"n\"]\n        alpha = case[\"alpha\"]\n        beta = case[\"beta\"]\n        S = case[\"S\"]\n        P = case[\"P\"]\n        r = case[\"r\"]\n        x_bar = case[\"x_bar\"]\n        p_bar = case[\"p_bar\"]\n\n        # Decision vector y = [x_1, ..., x_n, p_1, ..., p_n]\n        # Number of variables is 2*n\n        n_vars = 2 * n\n\n        # Objective function c_vector^T * y to be maximized.\n        # linprog minimizes, so we minimize -c_vector^T * y.\n        # c_vector = [alpha_1, ..., alpha_n, beta_1, ..., beta_n]\n        c = -np.concatenate([alpha, beta])\n\n        # Inequality constraints A_ub * y = b_ub\n        # There are n+2 such constraints: 1 for space, 1 for power, n for coupling.\n        A_ub = np.zeros((n + 2, n_vars))\n        b_ub = np.zeros(n + 2)\n\n        # 1. Total space constraint: sum(x_i) = S\n        A_ub[0, :n] = 1\n        b_ub[0] = S\n        \n        # 2. Total power constraint: sum(p_i) = P\n        A_ub[1, n:] = 1\n        b_ub[1] = P\n        \n        # 3. Coupling constraints: p_i = r_i * x_i  =  -r_i * x_i + p_i = 0\n        for i in range(n):\n            A_ub[2 + i, i] = -r[i]\n            A_ub[2 + i, n + i] = 1\n            b_ub[2 + i] = 0\n\n        # Bounds for each variable: 0 = y_i = u_i\n        # bounds = [(0, x_bar_1), ..., (0, x_bar_n), (0, p_bar_1), ..., (0, p_bar_n)]\n        bounds_x = [(0, val) for val in x_bar]\n        bounds_p = [(0, val) for val in p_bar]\n        bounds = bounds_x + bounds_p\n\n        # Solve the LP\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n        if res.success:\n            optimal_y = res.x\n            # The maximized objective value is -1 * minimized value\n            optimal_z = -res.fun\n            # Combine allocations and objective value into a single list\n            current_result = list(optimal_y) + [optimal_z]\n            results_for_all_cases.append(current_result)\n        else:\n            # Handle the case where the solver fails\n            # For this well-posed problem, this path should not be taken.\n            # Fill with NaN or handle error as appropriate.\n            # Using NaN of the correct size to avoid crashing the output formatting.\n            results_for_all_cases.append([np.nan] * (n_vars + 1))\n\n    # Format the final output string as per requirements:\n    # [[case1_results],[case2_results],...] with no spaces and 4 decimal places.\n    output_parts = []\n    for res_list in results_for_all_cases:\n        formatted_numbers = [f\"{num:.4f}\" for num in res_list]\n        part_str = \"[\" + \",\".join(formatted_numbers) + \"]\"\n        output_parts.append(part_str)\n        \n    final_output_string = \"[\" + \",\".join(output_parts) + \"]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3106569"}, {"introduction": "Moving beyond purely linear relationships, this practice introduces the power of integer variables to model discrete choices and logical conditions. The scenario involves allocating resources where benefits are only realized if a certain threshold is met, a common feature in project selection or investment problems. This exercise [@problem_id:3106648] will guide you through formulating a Mixed-Integer Linear Program (MILP) and demonstrates how such problems can sometimes be simplified by recognizing an underlying classic structure, like the $0/1$ Knapsack Problem.", "problem": "A finite set of activities indexed by $i \\in \\{0,1,\\dots,n-1\\}$ is available. For each $i$, there is a nonnegative integer benefit $b_i$, a nonnegative integer threshold $T_i$, and a nonnegative integer upper bound $U_i$. A nonnegative integer budget $B$ is available for allocating a scalar resource $x_i$ to each activity. Benefits accrue only if the resource allocation to activity $i$ meets or exceeds its threshold. Introduce binary decision variables $z_i \\in \\{0,1\\}$ indicating whether activity $i$ is activated and integer resource allocations $x_i \\ge 0$. The optimization problem is\n$$\n\\max \\sum_{i=0}^{n-1} b_i z_i\n$$\nsubject to\n$$\n\\sum_{i=0}^{n-1} x_i \\le B, \\quad x_i \\ge T_i z_i, \\quad x_i \\le U_i z_i, \\quad x_i \\in \\mathbb{Z}_{\\ge 0}, \\quad z_i \\in \\{0,1\\} \\quad \\text{for all } i.\n$$\nThis is a canonical resource allocation model with threshold effects and upper bounds, representable as a Mixed-Integer Linear Program (MILP), where the threshold ensures that benefit only accrues if $x_i$ reaches $T_i$ and the upper bound constrains $x_i$.\n\nYour task is to write a complete program that, for each supplied test case, computes the set of indices of activities selected at optimality under the above model. If multiple optimal selections achieve the same maximal objective value, your program must return the lexicographically smallest ascending list of indices among the optimal selections. An activity $i$ for which $U_i  T_i$ cannot be feasibly activated (no $x_i$ satisfies both $x_i \\ge T_i$ and $x_i \\le U_i$ when $z_i=1$), so any feasible optimal solution must set $z_i=0$ for such $i$.\n\nAll parameters in the test suite are integers, so the resource budget and allocations are integer-valued. No physical units are involved.\n\nTest suite:\n- Case A (general case): $b=[9,6,4,7,5,3]$, $T=[5,3,2,6,4,2]$, $U=[8,3,5,6,10,2]$, $B=12$.\n- Case B (boundary budget too small): $b=[5,4,3]$, $T=[2,2,3]$, $U=[5,5,3]$, $B=1$.\n- Case C (invalid activations present): $b=[8,7,6,4]$, $T=[4,3,5,2]$, $U=[3,3,4,4]$, $B=6$.\n- Case D (ties in optimal benefit require lexicographic tie-breaking): $b=[8,8,8,8]$, $T=[5,5,5,5]$, $U=[5,5,5,5]$, $B=10$.\n- Case E (zero-threshold items): $b=[1,2,3]$, $T=[0,0,5]$, $U=[0,4,5]$, $B=4$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the ascending list of selected indices for the corresponding test case, with no spaces anywhere. For example, the output must look like\n$[[i_1^{(A)},i_2^{(A)},\\dots],[\\dots],\\dots]$\nSpecifically, the output must be a single line of the form \"[[...],[...],[...],[...],[...]]\" with no spaces, and each inner list must contain the selected indices in strictly increasing order.", "solution": "The user-provided problem is a valid optimization task.\n\n### Step 1: Extract Givens\n- **Activities**: A finite set indexed by $i \\in \\{0,1,\\dots,n-1\\}$.\n- **Parameters**: For each activity $i$, there are a non-negative integer benefit $b_i$, a non-negative integer threshold $T_i$, and a non-negative integer upper bound $U_i$.\n- **Budget**: A non-negative integer budget $B$.\n- **Decision Variables**:\n    - Binary variables $z_i \\in \\{0,1\\}$, where $z_i=1$ if activity $i$ is activated, and $z_i=0$ otherwise.\n    - Non-negative integer resource allocations $x_i \\in \\mathbb{Z}_{\\ge 0}$.\n- **Objective Function**: Maximize total benefit, $\\max \\sum_{i=0}^{n-1} b_i z_i$.\n- **Constraints**:\n    1. Budget constraint: $\\sum_{i=0}^{n-1} x_i \\le B$.\n    2. Activation constraints: $x_i \\ge T_i z_i$ for all $i$.\n    3. Upper bound constraints: $x_i \\le U_i z_i$ for all $i$.\n- **Feasibility Condition**: An activity $i$ with $U_i  T_i$ cannot be feasibly activated.\n- **Tie-Breaking Rule**: If multiple selections of activities yield the same maximum benefit, the one corresponding to the lexicographically smallest ascending list of indices must be returned.\n- **Test Suite**: Five distinct test cases (A, B, C, D, E) with integer parameters are provided.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed against the validation criteria:\n- **Scientifically Grounded**: The problem is a well-defined Mixed-Integer Linear Program (MILP). It represents a canonical resource allocation problem with activation thresholds, a standard topic in operations research and optimization theory. The formulation is mathematically sound.\n- **Well-Posed**: The problem is well-posed. The search space for the binary variables $z_i$ is finite ($2^n$ possibilities). For each choice of $z_i$, the existence of feasible $x_i$ can be determined. The objective function is bounded. The explicit lexicographical tie-breaking rule ensures that a unique solution is specified.\n- **Objective**: The problem is stated using precise, formal mathematical language, devoid of ambiguity or subjective content.\n\nAll validation checks are passed. The problem is valid.\n\n### Step 3: Verdict and Action\nThe problem is VALID. A complete, reasoned solution will be provided.\n\n### Principle-Based Solution\nThe optimization problem is formulated as a Mixed-Integer Linear Program (MILP):\n$$\n\\max \\sum_{i=0}^{n-1} b_i z_i\n$$\nsubject to\n$$\n\\sum_{i=0}^{n-1} x_i \\le B\n$$\n$$\nT_i z_i \\le x_i \\le U_i z_i, \\quad \\forall i \\in \\{0, \\dots, n-1\\}\n$$\n$$\nx_i \\in \\mathbb{Z}_{\\ge 0}, \\quad z_i \\in \\{0,1\\}, \\quad \\forall i \\in \\{0, \\dots, n-1\\}\n$$\n\nA critical first step is to simplify the model by analyzing the role of the resource allocation variables $x_i$.\n- If an activity $i$ is not activated, $z_i=0$. The constraints on $x_i$ become $0 \\le x_i \\le 0$, which implies $x_i=0$. This choice contributes $0$ to the benefit and consumes $0$ resources.\n- If an activity $i$ is activated, $z_i=1$. The constraints become $T_i \\le x_i \\le U_i$. This is only possible if $T_i \\le U_i$; otherwise, no feasible integer $x_i$ exists. As stated in the problem, any activity with $U_i  T_i$ is inherently infeasible to activate, so we must enforce $z_i=0$ for such activities.\n\nThe objective function $\\sum b_i z_i$ depends only on which activities are activated, not on the specific amount of resource $x_i$ allocated to them. To maximize the objective value, we should aim to activate a set of activities with high total benefit. The ability to do so is limited only by the budget $B$. For any given set of activated activities $S = \\{i \\mid z_i=1\\}$, the total resource consumption is $\\sum_{i \\in S} x_i$. To conserve the budget and potentially enable the activation of more activities, we should allocate the minimum possible resource to each activated activity.\n\nFor an activated activity $i \\in S$, the minimum required resource allocation is $x_i = T_i$. This allocation is valid as it satisfies $T_i \\le x_i \\le U_i$ (since we only consider activities where $T_i \\le U_i$). Therefore, for any feasible solution $(z^*, x^*)$, we can construct a new solution $(z^*, x')$ where $x'_i = T_i$ if $z^*_i=1$ and $x'_i=0$ if $z^*_i=0$. This new solution has the same objective value, and its total resource consumption is $\\sum x'_i = \\sum_{i: z^*_i=1} T_i \\le \\sum_{i: z^*_i=1} x^*_i \\le \\sum_{i=0}^{n-1} x^*_i \\le B$. Thus, the new solution $(z^*, x')$ is also feasible.\n\nThis proves that an optimal solution can always be found by setting the resource allocation for each activated activity $i$ to its minimum required value, $T_i$. The problem simplifies to selecting a subset of activities to activate, which reduces to the classic **0/1 Knapsack Problem**:\n- **Items**: The set of valid activities $i$ where $T_i \\le U_i$.\n- **Value of item $i$**: The benefit $b_i$.\n- **Weight of item $i$**: The resource cost $T_i$.\n- **Knapsack Capacity**: The total budget $B$.\n\nThe reformulated problem is:\n$$\n\\max \\sum_{i \\in I_{valid}} b_i z_i\n$$\nsubject to\n$$\n\\sum_{i \\in I_{valid}} T_i z_i \\le B\n$$\n$$\nz_i \\in \\{0,1\\}, \\quad \\forall i \\in I_{valid}\n$$\nwhere $I_{valid} = \\{i \\mid T_i \\le U_i\\}$.\n\nThe 0/1 Knapsack Problem is NP-hard. However, the number of activities $n$ in the provided test cases is small (at most $6$). This allows for a complete enumeration of all possible subsets of activities. An exhaustive search is computationally feasible and guarantees finding the global optimum.\n\nThe algorithm proceeds as follows:\n1.  **Filter Activities**: Create a list of indices for valid activities, i.e., those where $T_i \\le U_i$.\n2.  **Iterate Subsets**: Generate all $2^k$ subsets of the $k$ valid activities. Each subset represents a potential selection. A simple way to achieve this is to loop an integer counter from $0$ to $2^k-1$, where the binary representation of the counter indicates which activities to include in the subset.\n3.  **Evaluate Each Subset**: For each generated subset:\n    a. Calculate the total cost (sum of $T_i$) and total benefit (sum of $b_i$).\n    b. Check if the total cost is within the budget $B$.\n4.  **Determine Optimal Selection**:\n    a. Maintain a variable for the maximum benefit found so far (`max_benefit`) and the corresponding list of indices (`best_selection`).\n    b. If a feasible subset yields a benefit greater than `max_benefit`, update `max_benefit` and `best_selection`.\n    c. If a feasible subset yields a benefit equal to `max_benefit`, compare its list of indices (sorted in ascending order) with the current `best_selection`. If the new list is lexicographically smaller, update `best_selection`.\n5.  **Output**: After checking all subsets, `best_selection` contains the optimal set of indices satisfying all problem criteria.\n\nThis procedure correctly solves the problem by transforming it into a tractable form and applying a brute-force search that respects the specified tie-breaking rule.", "answer": "```python\nimport numpy as np\n\ndef _solve_knapsack_variant(b, T, U, B):\n    \"\"\"\n    Solves the resource allocation problem by reducing it to a 0/1 knapsack\n    problem and using brute-force search over all subsets of activities.\n    \n    This approach is feasible given the small number of activities in test cases.\n    \"\"\"\n    n = len(b)\n    \n    # 1. Filter out invalid activities where the threshold is greater than the upper bound.\n    # The list comprehension preserves the ascending order of indices.\n    valid_indices = [i for i in range(n) if T[i] = U[i]]\n    num_valid = len(valid_indices)\n    \n    max_benefit = -1  # A value lower than any possible benefit (e.g., 0 for empty set)\n    best_selection = []\n    \n    # 2. Iterate through all 2^num_valid subsets of valid activities.\n    # Each integer `i` from 0 to 2^num_valid - 1 represents a unique subset.\n    for i in range(1  num_valid):\n        current_selection = []\n        current_cost = 0\n        current_benefit = 0\n        \n        # Construct the subset based on the bits of `i`.\n        for j in range(num_valid):\n            if (i  j)  1:\n                # If the j-th bit is set, include the j-th valid activity.\n                idx = valid_indices[j]\n                current_selection.append(idx)\n                current_cost += T[idx]\n                current_benefit += b[idx]\n\n        # 3. Evaluate the current subset.\n        if current_cost = B:\n            # The selection is feasible.\n            # 4. Check if it's better than the best one found so far.\n            if current_benefit  max_benefit:\n                max_benefit = current_benefit\n                best_selection = current_selection\n            elif current_benefit == max_benefit:\n                # Tie-breaking rule: choose the lexicographically smallest list of indices.\n                # `current_selection` is guaranteed to be sorted because `valid_indices`\n                # and the inner loop order are both ascending.\n                # `best_selection` is also always sorted.\n                if current_selection  best_selection:\n                    best_selection = current_selection\n                    \n    return best_selection\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver for each,\n    and print the results in the required format.\n    \"\"\"\n    # Define the test suite from the problem statement.\n    test_cases = [\n        # Case A (general case)\n        {'b': np.array([9,6,4,7,5,3]), 'T': np.array([5,3,2,6,4,2]), 'U': np.array([8,3,5,6,10,2]), 'B': 12},\n        # Case B (boundary budget too small)\n        {'b': np.array([5,4,3]), 'T': np.array([2,2,3]), 'U': np.array([5,5,3]), 'B': 1},\n        # Case C (invalid activations present)\n        {'b': np.array([8,7,6,4]), 'T': np.array([4,3,5,2]), 'U': np.array([3,3,4,4]), 'B': 6},\n        # Case D (ties in optimal benefit require lexicographic tie-breaking)\n        {'b': np.array([8,8,8,8]), 'T': np.array([5,5,5,5]), 'U': np.array([5,5,5,5]), 'B': 10},\n        # Case E (zero-threshold items)\n        {'b': np.array([1,2,3]), 'T': np.array([0,0,5]), 'U': np.array([0,4,5]), 'B': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Solve each case\n        result = _solve_knapsack_variant(**case)\n        results.append(result)\n\n    # Format the final output string according to the specification:\n    # \"[[...],[...],...]\" with no spaces.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver\nsolve()\n```", "id": "3106648"}, {"introduction": "This final practice explores another cornerstone of optimization: network flow models. We will tackle a minimum-cost flow problem where the cost is not a simple constant but changes as the flow increases—a common scenario reflecting economies of scale or congestion effects. This exercise [@problem_id:3106543] teaches the critical technique of linearizing a convex, piecewise-linear cost function, allowing us to solve a seemingly non-linear problem using the efficient machinery of Linear Programming.", "problem": "You are asked to build and solve a single-commodity minimum-cost network flow model with piecewise-linear arc costs using Linear Programming (LP). The fundamental base is the network flow conservation law: for each node, the total outflow minus total inflow equals the node’s net supply (positive for sources) or demand (negative for sinks), and the definition of linear optimization, where a linear objective function is minimized subject to linear equality constraints and variable bounds.\n\nEach directed arc $(i,j)$ has a capacity $u_{ij}$ and a convex piecewise-linear cost of the form $c_{ij}(f_{ij}) = a_{ij} f_{ij} + b_{ij} \\max(0, f_{ij} - \\theta_{ij})$, where $f_{ij}$ is the flow on arc $(i,j)$, $a_{ij} \\ge 0$, $b_{ij} \\ge 0$, and $\\theta_{ij} \\ge 0$. To obtain a linear program, represent $f_{ij}$ using two nonnegative segment variables that split the flow relative to the threshold $\\theta_{ij}$ and enforce appropriate bounds and conservation. Minimize the total cost subject to flow conservation at each node and arc capacity limits.\n\nYour program must:\n- Formulate the LP implied by the above description for each test case by introducing segment variables per arc to linearize the cost, enforce segment bounds derived from $u_{ij}$ and $\\theta_{ij}$, and enforce node-wise flow conservation equalities derived from the node supplies and demands.\n- Solve the LP and return the optimal objective value (total cost) as a decimal number for each test case.\n\nNo physical units are involved. Angles do not appear. Percentages do not appear.\n\nTest Suite:\nProvide a single program that solves the following three test cases. Each test case describes a directed network. Nodes are denoted by labels, and arcs are given by tuples ($i,j$, $a_{ij}$, $b_{ij}$, $\\theta_{ij}$, $u_{ij}$) with all mathematical entities, including numbers, written in LaTeX.\n\n- Test Case $1$ (happy path, mixed thresholds and capacities):\n  - Nodes: $\\{S,A,B,T\\}$.\n  - Supplies/Demands: $s_S = 6$, $s_A = 0$, $s_B = 0$, $s_T = -6$.\n  - Arcs:\n    - (S, A, $a_{SA}=2, b_{SA}=3, \\theta_{SA}=3, u_{SA}=5$),\n    - (S, B, $a_{SB}=1, b_{SB}=0.5, \\theta_{SB}=1, u_{SB}=4$),\n    - (A, T, $a_{AT}=1.5, b_{AT}=2, \\theta_{AT}=2, u_{AT}=4$),\n    - (B, T, $a_{BT}=2, b_{BT}=1, \\theta_{BT}=4, u_{BT}=5$),\n    - (S, T, $a_{ST}=3, b_{ST}=1, \\theta_{ST}=1, u_{ST}=2$).\n\n- Test Case $2$ (boundary case: capacity equals threshold or capacity below threshold):\n  - Nodes: $\\{S,A,T\\}$.\n  - Supplies/Demands: $s_S = 5$, $s_A = 0$, $s_T = -5$.\n  - Arcs:\n    - (S, A, $a_{SA}=1, b_{SA}=5, \\theta_{SA}=3, u_{SA}=3$),\n    - (A, T, $a_{AT}=2, b_{AT}=4, \\theta_{AT}=5, u_{AT}=3$),\n    - (S, T, $a_{ST}=4, b_{ST}=0, \\theta_{ST}=2, u_{ST}=2$).\n\n- Test Case $3$ (edge case: zero threshold):\n  - Nodes: $\\{S,C,T\\}$.\n  - Supplies/Demands: $s_S = 4$, $s_C = 0$, $s_T = -4$.\n  - Arcs:\n    - (S, C, $a_{SC}=1, b_{SC}=2, \\theta_{SC}=0, u_{SC}=5$),\n    - (C, T, $a_{CT}=1, b_{CT}=1, \\theta_{CT}=0, u_{CT}=5$),\n    - (S, T, $a_{ST}=0, b_{ST}=0, \\theta_{ST}=0, u_{ST}=1$).\n\nFinal Output Format:\nYour program should produce a single line of output containing the optimal objective values for the three test cases as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3]$). Each $result_k$ must be a decimal number (a float). The program must be self-contained, require no input, and directly solve the three provided test cases as specified.", "solution": "The problem asks for the formulation and solution of a single-commodity minimum-cost network flow problem where the cost on each arc is a convex, piecewise-linear function of the flow. The problem is to be modeled as a Linear Program (LP).\n\nThe fundamental principle is the transformation of a convex piecewise-linear objective function into a linear one by introducing new variables that represent the flow on different segments of the cost function. Because the original objective function is convex and the constraints are linear, a minimizer will naturally prioritize using flow on cheaper segments before using more expensive ones, validating this decomposition without needing extra integer variables or special branching rules.\n\nLet the network be represented by a directed graph $G = (V, E)$, where $V$ is the set of nodes and $E$ is the set of arcs. For each node $i \\in V$, there is a net supply $s_i$. If $s_i  0$, node $i$ is a source. If $s_i  0$, it is a sink. If $s_i = 0$, it is a transshipment node. For a valid problem, the total supply must equal the total demand, i.e., $\\sum_{i \\in V} s_i = 0$.\n\nFor each arc $(i,j) \\in E$, we are given:\n- $u_{ij}$: the maximum capacity of the arc.\n- A convex piecewise-linear cost function $c_{ij}(f_{ij})$ for the flow $f_{ij}$ on the arc, defined as:\n$$ c_{ij}(f_{ij}) = a_{ij} f_{ij} + b_{ij} \\max(0, f_{ij} - \\theta_{ij}) $$\nwhere $a_{ij} \\ge 0$, $b_{ij} \\ge 0$, and $\\theta_{ij} \\ge 0$ is the flow threshold where the cost function's slope changes.\n\nThe optimization problem is:\n$$ \\text{minimize} \\quad Z = \\sum_{(i,j) \\in E} c_{ij}(f_{ij}) $$\nsubject to:\n$1$. Flow conservation at each node $k \\in V$:\n$$ \\sum_{j:(k,j) \\in E} f_{kj} - \\sum_{i:(i,k) \\in E} f_{ik} = s_k $$\n$2$. Arc capacity constraints for each arc $(i,j) \\in E$:\n$$ 0 \\le f_{ij} \\le u_{ij} $$\n\nTo linearize the objective function, we decompose the flow variable $f_{ij}$ for each arc into two non-negative variables, $f_{ij}^{(1)}$ and $f_{ij}^{(2)}$:\n$$ f_{ij} = f_{ij}^{(1)} + f_{ij}^{(2)} $$\nThese variables represent the flow in the two linear segments of the cost function:\n- $f_{ij}^{(1)}$ is the flow in the first segment, up to the threshold $\\theta_{ij}$.\n- $f_{ij}^{(2)}$ is the flow in the second segment, beyond the threshold $\\theta_{ij}$.\n\nThis decomposition is governed by the following bounds:\n$$ 0 \\le f_{ij}^{(1)} \\le \\theta_{ij} $$\n$$ f_{ij}^{(2)} \\ge 0 $$\nWith this, the term $\\max(0, f_{ij} - \\theta_{ij})$ in the cost function is equivalent to $f_{ij}^{(2)}$. The cost function for arc $(i,j)$ can now be rewritten as a linear function of these new variables:\n$$ c_{ij}(f_{ij}^{(1)}, f_{ij}^{(2)}) = a_{ij} (f_{ij}^{(1)} + f_{ij}^{(2)}) + b_{ij} f_{ij}^{(2)} = a_{ij} f_{ij}^{(1)} + (a_{ij} + b_{ij}) f_{ij}^{(2)} $$\nThe marginal cost of flow on the first segment is $a_{ij}$, and on the second segment, it is $a_{ij} + b_{ij}$. Since $b_{ij} \\ge 0$, the cost of the second segment is always greater than or equal to the first. An LP solver minimizing the total cost will therefore automatically saturate the first segment (up to its bound $\\theta_{ij}$) before assigning any flow to the second, more expensive segment.\n\nThe complete LP formulation is as follows:\n\n**Decision Variables:**\nFor each arc $(i,j) \\in E$, we have two variables, $f_{ij}^{(1)}$ and $f_{ij}^{(2)}$.\n\n**Objective Function:**\nMinimize the total linear cost:\n$$ \\text{minimize} \\quad Z = \\sum_{(i,j) \\in E} \\left( a_{ij} f_{ij}^{(1)} + (a_{ij} + b_{ij}) f_{ij}^{(2)} \\right) $$\n\n**Constraints:**\n$1$. Flow conservation for each node $k \\in V$:\n$$ \\sum_{j:(k,j) \\in E} \\left( f_{kj}^{(1)} + f_{kj}^{(2)} \\right) - \\sum_{i:(i,k) \\in E} \\left( f_{ik}^{(1)} + f_{ik}^{(2)} \\right) = s_k $$\nThis forms a set of linear equality constraints ($A_{eq}x = b_{eq}$).\n\n$2$. Arc capacity for each arc $(i,j) \\in E$:\n$$ f_{ij}^{(1)} + f_{ij}^{(2)} \\le u_{ij} $$\nThis forms a set of linear inequality constraints ($A_{ub}x \\le b_{ub}$).\n\n$3$. Variable bounds for each arc $(i,j) \\in E$:\n$$ 0 \\le f_{ij}^{(1)} \\le \\theta_{ij} $$\n$$ f_{ij}^{(2)} \\ge 0 $$\nThe upper bound on $f_{ij}^{(2)}$ is implicitly handled by the arc capacity constraint. The standard LP form combines these into a single bounds vector.\n\nThis formulation is implemented for each test case. The node and arc data are used to construct the objective vector $c$, the constraint matrices $A_{eq}$ and $A_{ub}$, the corresponding right-hand-side vectors $b_{eq}$ and $b_{ub}$, and the variable bounds. A standard LP solver, such as `scipy.optimize.linprog`, is then used to find the solution vector $x = [..., f_{ij}^{(1)}, f_{ij}^{(2)}, ...]^T$ that minimizes the objective function $Z$. The optimal value of $Z$ is the minimum total cost for the network flow, which is the required output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves three minimum-cost network flow problems with piecewise-linear costs.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"nodes\": [\"S\", \"A\", \"B\", \"T\"],\n            \"supplies\": {\"S\": 6.0, \"A\": 0.0, \"B\": 0.0, \"T\": -6.0},\n            \"arcs\": [\n                # (from, to, a, b, theta, u)\n                (\"S\", \"A\", 2.0, 3.0, 3.0, 5.0),\n                (\"S\", \"B\", 1.0, 0.5, 1.0, 4.0),\n                (\"A\", \"T\", 1.5, 2.0, 2.0, 4.0),\n                (\"B\", \"T\", 2.0, 1.0, 4.0, 5.0),\n                (\"S\", \"T\", 3.0, 1.0, 1.0, 2.0)\n            ]\n        },\n        # Test Case 2\n        {\n            \"nodes\": [\"S\", \"A\", \"T\"],\n            \"supplies\": {\"S\": 5.0, \"A\": 0.0, \"T\": -5.0},\n            \"arcs\": [\n                (\"S\", \"A\", 1.0, 5.0, 3.0, 3.0),\n                (\"A\", \"T\", 2.0, 4.0, 5.0, 3.0),\n                (\"S\", \"T\", 4.0, 0.0, 2.0, 2.0)\n            ]\n        },\n        # Test Case 3\n        {\n            \"nodes\": [\"S\", \"C\", \"T\"],\n            \"supplies\": {\"S\": 4.0, \"C\": 0.0, \"T\": -4.0},\n            \"arcs\": [\n                (\"S\", \"C\", 1.0, 2.0, 0.0, 5.0),\n                (\"C\", \"T\", 1.0, 1.0, 0.0, 5.0),\n                (\"S\", \"T\", 0.0, 0.0, 0.0, 1.0)\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        supplies = case[\"supplies\"]\n        arcs_data = case[\"arcs\"]\n\n        num_nodes = len(nodes)\n        num_arcs = len(arcs_data)\n        num_vars = 2 * num_arcs\n\n        node_map = {name: i for i, name in enumerate(nodes)}\n\n        # LP formulation: min c'x s.t. A_eq x = b_eq, A_ub x = b_ub, and bounds on x.\n        \n        # 1. Objective function vector c\n        c = np.zeros(num_vars)\n        for i, arc in enumerate(arcs_data):\n            _, _, a, b, _, _ = arc\n            c[2 * i] = a         # Cost for the first segment f_ij^(1)\n            c[2 * i + 1] = a + b # Cost for the second segment f_ij^(2)\n            \n        # 2. Equality constraints A_eq, b_eq (flow conservation)\n        A_eq = np.zeros((num_nodes, num_vars))\n        b_eq = np.array([supplies[name] for name in nodes])\n        \n        for i, arc in enumerate(arcs_data):\n            u_name, v_name, _, _, _, _ = arc\n            u_idx, v_idx = node_map[u_name], node_map[v_name]\n            \n            # For arc i, variables are at 2*i and 2*i+1.\n            # Total flow on arc i is f_i^(1) + f_i^(2).\n            # It is an outflow from node u, so coefficient is +1.\n            A_eq[u_idx, 2 * i] = 1.0\n            A_eq[u_idx, 2 * i + 1] = 1.0\n            \n            # It is an inflow to node v, so coefficient is -1.\n            A_eq[v_idx, 2 * i] = -1.0\n            A_eq[v_idx, 2 * i + 1] = -1.0\n\n        # 3. Inequality constraints A_ub, b_ub (arc capacity)\n        A_ub = np.zeros((num_arcs, num_vars))\n        b_ub = np.zeros(num_arcs)\n        for i, arc in enumerate(arcs_data):\n            _, _, _, _, _, u_cap = arc\n            # f_i^(1) + f_i^(2) = u_i\n            A_ub[i, 2 * i] = 1.0\n            A_ub[i, 2 * i + 1] = 1.0\n            b_ub[i] = u_cap\n\n        # 4. Variable bounds\n        bounds = []\n        for arc in arcs_data:\n            _, _, _, _, theta, _ = arc\n            # 0 = f_i^(1) = theta_i\n            bounds.append((0, theta))\n            # 0 = f_i^(2)\n            bounds.append((0, None))\n\n        # Solve the Linear Program\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        if res.success:\n            results.append(res.fun)\n        else:\n            # This path is not expected for the given valid test cases.\n            results.append(float('nan')) \n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3106543"}]}