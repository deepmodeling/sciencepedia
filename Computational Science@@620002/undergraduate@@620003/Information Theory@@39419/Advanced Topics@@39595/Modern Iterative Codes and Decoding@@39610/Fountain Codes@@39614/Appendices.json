{"hands_on_practices": [{"introduction": "The best way to understand an algorithm is to see it in action. The peeling decoder is a simple yet powerful iterative process at the heart of many fountain codes. This first practice exercise guides you through a complete, successful decoding sequence, allowing you to trace how source packets are recovered one by one by simplifying the system of equations. By methodically applying the decoding rules, you will gain a concrete understanding of this elegant algorithm's mechanics [@problem_id:1625543].", "problem": "In modern data transmission systems, such as satellite communication or peer-to-peer file sharing, rateless codes (a class of Fountain Codes) are employed for their efficiency and robustness. A file is first divided into $K$ source packets, denoted $s_1, s_2, \\dots, s_K$. The transmitter then generates a potentially limitless stream of encoded packets, $c_1, c_2, \\dots$. Each encoded packet $c_j$ is formed by taking the bitwise exclusive-OR (XOR, denoted by $\\oplus$) of a randomly chosen subset of the source packets.\n\nA receiver collects these encoded packets. To reconstruct the original file, a simple and effective iterative algorithm known as a \"peeling decoder\" is used. The decoding process proceeds as follows:\n1.  The decoder searches for any received encoded packet $c_j$ that is composed of only a single source packet, say $c_j = s_i$. This immediately recovers the source packet $s_i$.\n2.  Once a source packet $s_i$ is recovered, its value is used to simplify all other encoded packets that depend on it. For any other received packet $c_k$ that includes $s_i$ in its XOR sum (e.g., $c_k = s_i \\oplus s_p \\oplus s_q$), the receiver computes a new, simplified encoded packet $c'_k = c_k \\oplus s_i = s_p \\oplus s_q$. This new packet $c'_k$ replaces $c_k$ in the set of equations to be solved.\n3.  The process repeats from Step 1, iteratively finding newly-resolvable dependencies and simplifying the system until all $K$ source packets are recovered.\n\nIn the event that multiple packets become resolvable at the same time, they are processed in ascending order of their original encoded packet index (e.g., a simplification originating from $c_2$ is processed before one from $c_3$).\n\nConsider a scenario where a file has been divided into $K=4$ source packets: $s_1, s_2, s_3,$ and $s_4$. A receiver has collected the following four encoded packets:\n- $c_1 = s_1$\n- $c_2 = s_1 \\oplus s_2$\n- $c_3 = s_1 \\oplus s_3$\n- $c_4 = s_2 \\oplus s_3 \\oplus s_4$\n\nFollowing the peeling decoder algorithm described, the source packets will be recovered in a specific sequence. What is the index $i$ of the source packet $s_i$ that is the third one to be recovered in this sequence? Provide your answer as a single integer.", "solution": "We follow the peeling decoder exactly as specified, applying XOR simplification and the given tie-breaking rule by ascending original encoded packet index.\n\nInitially, the received encoded packets are:\n$$\nc_{1}=s_{1},\\quad c_{2}=s_{1}\\oplus s_{2},\\quad c_{3}=s_{1}\\oplus s_{3},\\quad c_{4}=s_{2}\\oplus s_{3}\\oplus s_{4}.\n$$\n\n1) Identify degree-1 packet(s): $c_{1}=s_{1}$ has degree 1, so $s_{1}$ is recovered first.\n\n2) Use $s_{1}$ to simplify all other packets containing $s_{1}$:\n$$\nc_{2}'=c_{2}\\oplus s_{1}=(s_{1}\\oplus s_{2})\\oplus s_{1}=s_{2},\\quad\nc_{3}'=c_{3}\\oplus s_{1}=(s_{1}\\oplus s_{3})\\oplus s_{1}=s_{3},\n$$\nand $c_{4}$ remains $s_{2}\\oplus s_{3}\\oplus s_{4}$ since it does not contain $s_{1}$.\n\nNow both $c_{2}'=s_{2}$ and $c_{3}'=s_{3}$ are degree-1 simultaneously. By the rule that ties are broken by ascending original encoded packet index, we process $c_{2}'$ (originating from $c_{2}$) before $c_{3}'$ (originating from $c_{3}$). Hence $s_{2}$ is recovered second.\n\n3) Use $s_{2}$ to simplify packets containing $s_{2}$:\n$$\nc_{4}'=c_{4}\\oplus s_{2}=(s_{2}\\oplus s_{3}\\oplus s_{4})\\oplus s_{2}=s_{3}\\oplus s_{4},\n$$\nwhile $c_{3}'=s_{3}$ remains unchanged.\n\nNow the degree-1 packet is $c_{3}'=s_{3}$, so $s_{3}$ is recovered third.\n\nTherefore, the index of the third recovered source packet is $i=3$.", "answer": "$$\\boxed{3}$$", "id": "1625543"}, {"introduction": "While the peeling decoder is highly effective, simply receiving as many encoded packets as there are source packets does not guarantee success. This exercise explores a classic scenario where the decoding process stalls. By analyzing a specific set of received packets, you will uncover the concept of linear dependency and understand why the decoder cannot make progress, providing crucial insight into the failure modes of fountain codes [@problem_id:1625537].", "problem": "A simple digital fountain code is used to transmit a message that has been broken into three source packets, denoted $S_1$, $S_2$, and $S_3$. The encoding process generates new packets by taking the bitwise Exclusive OR (XOR, denoted by $\\oplus$) of a subset of the source packets. A receiver collects encoded packets until it has enough information to reconstruct the original three source packets.\n\nSuppose a receiver has collected the following three encoded packets, $E_1$, $E_2$, and $E_3$:\n- $E_1 = S_1 \\oplus S_2$\n- $E_2 = S_1 \\oplus S_3$\n- $E_3 = S_2 \\oplus S_3$\n\nThe standard decoding algorithm for this type of code, known as the \"ripple\" process, starts by finding a received packet that is a copy of a single source packet (a \"degree-one\" packet). This source packet is then considered \"solved\" and is XORed with any other encoded packets that contain it, reducing their complexity and hopefully creating new degree-one packets. This process continues until all source packets are solved.\n\nBased on the set of received packets $\\{E_1, E_2, E_3\\}$ and the properties of the XOR operation, which one of the following statements is correct?\n\nA: The source packet $S_1$ can be uniquely determined from the received packets.\n\nB: The XOR sum $S_1 \\oplus S_2 \\oplus S_3$ can be uniquely determined from the received packets.\n\nC: The ripple decoding process can successfully start and will eventually recover all source packets.\n\nD: The set of received packets is linearly dependent, but it is still possible to uniquely determine all source packets by other means (e.g., Gaussian elimination).\n\nE: The XOR sum $S_1 \\oplus S_2$ can be uniquely determined, but no individual source packet can be.", "solution": "Let the unknown packets be elements of a vector space over the field $\\mathbb{F}_{2}$, with XOR denoted by $\\oplus$. The received equations are\n$$\nE_{1} = S_{1} \\oplus S_{2}, \\quad E_{2} = S_{1} \\oplus S_{3}, \\quad E_{3} = S_{2} \\oplus S_{3}.\n$$\nWe use the properties of XOR: commutativity and associativity, $x \\oplus x = 0$, and $x \\oplus 0 = x$.\n\nFirst, observe linear dependence among the received packets. XORing all three equations gives\n$$\nE_{1} \\oplus E_{2} \\oplus E_{3} = (S_{1} \\oplus S_{2}) \\oplus (S_{1} \\oplus S_{3}) \\oplus (S_{2} \\oplus S_{3}) = (S_{1} \\oplus S_{1}) \\oplus (S_{2} \\oplus S_{2}) \\oplus (S_{3} \\oplus S_{3}) = 0,\n$$\nso $E_{1} \\oplus E_{2} \\oplus E_{3} = 0$ and the three equations are linearly dependent. Equivalently, the coefficient matrix\n$$\n\\begin{pmatrix}\n1 & 1 & 0 \\\\\n1 & 0 & 1 \\\\\n0 & 1 & 1\n\\end{pmatrix}\n$$\nhas rows that sum to the zero vector, hence rank $2$. With $3$ unknowns and only $2$ independent equations, one cannot uniquely determine all $S_{i}$ by Gaussian elimination. Thus option D is false.\n\nConsider the ripple decoding process. It requires a degree-one packet (an equation equal to a single $S_{i}$). Each $E_{k}$ is the XOR of two sources (degree $2$), so there is no starting degree-one packet and the ripple cannot start; consequently it cannot recover all sources. Thus option C is false.\n\nExamine uniqueness of individual sources. If $(S_{1}, S_{2}, S_{3})$ is any solution, then for any packet $V$ the triplet $(S_{1} \\oplus V, S_{2} \\oplus V, S_{3} \\oplus V)$ yields the same $E_{1}, E_{2}, E_{3}$, since\n$$\n(S_{1} \\oplus V) \\oplus (S_{2} \\oplus V) = S_{1} \\oplus S_{2}, \\quad (S_{1} \\oplus V) \\oplus (S_{3} \\oplus V) = S_{1} \\oplus S_{3}, \\quad (S_{2} \\oplus V) \\oplus (S_{3} \\oplus V) = S_{2} \\oplus S_{3}.\n$$\nTherefore no individual $S_{i}$ is uniquely determined; option A is false.\n\nCheck whether $S_{1} \\oplus S_{2} \\oplus S_{3}$ is uniquely determined. Expressing in terms of $S_{1}$ and the known $E_{1}, E_{2}$,\n$$\nS_{2} = S_{1} \\oplus E_{1}, \\quad S_{3} = S_{1} \\oplus E_{2},\n$$\nso\n$$\nS_{1} \\oplus S_{2} \\oplus S_{3} = S_{1} \\oplus (S_{1} \\oplus E_{1}) \\oplus (S_{1} \\oplus E_{2}) = (S_{1} \\oplus S_{1} \\oplus S_{1}) \\oplus E_{1} \\oplus E_{2} = S_{1} \\oplus E_{1} \\oplus E_{2}.\n$$\nBecause $S_{1}$ is not uniquely determined, $S_{1} \\oplus S_{2} \\oplus S_{3}$ is also not uniquely determined; option B is false.\n\nHowever, certain pairwise XORs are uniquely known. In particular, $S_{1} \\oplus S_{2} = E_{1}$ is directly given and thus uniquely determined. The same holds for $S_{1} \\oplus S_{3} = E_{2}$ and $S_{2} \\oplus S_{3} = E_{3}$. This establishes that while no individual source packet is uniquely determined, the XOR sum $S_{1} \\oplus S_{2}$ is. Therefore option E is correct.", "answer": "$$\\boxed{E}$$", "id": "1625537"}, {"introduction": "Moving from the mechanics of decoding to overall system performance, we introduce the concept of \"reception overhead.\" This metric quantifies the efficiency of a fountain code by measuring how many extra packets are needed, on average, to ensure successful decoding. This problem provides a practical scenario involving a firmware update, challenging you to calculate this key performance indicator and appreciate its importance in designing robust communication systems [@problem_id:1625538].", "problem": "A technology company is deploying a critical firmware update to a large fleet of remote sensors. The total size of the update file is $20.0$ megabytes (MB). To ensure robust delivery over a lossy wireless network, the company uses a Luby Transform (LT) code, a type of fountain code. The update file is first divided into a set of $K$ original source packets, each of size $128$ kilobytes (KB). Assume that $1 \\text{ MB} = 1024 \\text{ KB}$.\n\nThe server then generates and broadcasts an effectively endless stream of encoded packets derived from the source packets. A sensor is able to successfully reconstruct the original firmware update file once it has collected a total number of unique encoded packets, $N_{rx}$, that is $5.00\\%$ greater than the number of original source packets, $K$.\n\nThe \"reception overhead\" of this coding scheme is defined as the ratio of the number of packets required for decoding to the number of original source packets, i.e., $\\frac{N_{rx}}{K}$.\n\nCalculate the reception overhead for this system. Provide your answer as a number rounded to three significant figures.", "solution": "The total update size is $S=20.0\\ \\text{MB}$ and $1\\ \\text{MB}=1024\\ \\text{KB}$, so in kilobytes $S=20.0\\times 1024\\ \\text{KB}=20480\\ \\text{KB}$. Each source packet has size $P=128\\ \\text{KB}$, hence the number of original source packets is\n$$\nK=\\frac{S}{P}=\\frac{20480}{128}=160.\n$$\nA sensor must collect a number of unique encoded packets that is $0.0500$ greater in relative terms than $K$, so\n$$\nN_{rx}=K\\left(1+0.0500\\right)=1.05\\,K.\n$$\nThe reception overhead is defined as\n$$\n\\frac{N_{rx}}{K}=\\frac{1.05\\,K}{K}=1.05.\n$$\nRounded to three significant figures, this is $1.05$.", "answer": "$$\\boxed{1.05}$$", "id": "1625538"}]}