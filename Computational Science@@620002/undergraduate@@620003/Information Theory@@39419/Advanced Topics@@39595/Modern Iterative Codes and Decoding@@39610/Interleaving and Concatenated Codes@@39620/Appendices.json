{"hands_on_practices": [{"introduction": "Concatenated codes are a cornerstone of modern communication systems, achieving remarkable error-correction performance by combining two or more simpler codes. This exercise introduces the fundamental structure of a two-stage concatenated code, comprising an \"outer\" code and an \"inner\" code. By calculating the overall code rate, you will learn how the efficiency of each component code contributes to the final efficiency of the entire system, a crucial first step in designing and analyzing such powerful coding schemes [@problem_id:1633140].", "problem": "To ensure reliable data transmission from a satellite, a concatenated coding scheme is used. This scheme works in two stages: an outer code followed by an inner code.\n\nThe process begins with an original information message, which is grouped into $K=24$ blocks of data. Each of these blocks has a size of $k=5$ bits. The outer encoder, a block code denoted by $C_{out}$, takes these $K$ blocks and adds redundancy, producing an output of $N=32$ blocks.\n\nEach of the $N=32$ blocks (still of size $k=5$ bits) is then processed by the inner encoder, a block code denoted by $C_{in}$. The inner code takes each $5$-bit block and encodes it into an $n=8$ bit codeword for transmission.\n\nCalculate the overall code rate $R$ for this entire process. The code rate is defined as the ratio of the total number of original information bits to the total number of bits that are ultimately transmitted. Express your answer as a decimal.", "solution": "The total number of original information bits is the number of information blocks times the bits per block:\n$$\nB_{\\text{info}} = K \\cdot k.\n$$\nAfter the outer code, there are $N$ blocks (each still $k$ bits) that are fed to the inner code. The inner code maps each $k$-bit block to an $n$-bit codeword, so the total number of transmitted bits is:\n$$\nB_{\\text{tx}} = N \\cdot n.\n$$\nTherefore, the overall code rate is the ratio:\n$$\nR = \\frac{B_{\\text{info}}}{B_{\\text{tx}}} = \\frac{K \\cdot k}{N \\cdot n}.\n$$\nEquivalently, this is the product of the outer and inner code rates:\n$$\nR = \\left(\\frac{K}{N}\\right)\\left(\\frac{k}{n}\\right).\n$$\nSubstituting $K=24$, $N=32$, $k=5$, and $n=8$:\n$$\nR = \\frac{24}{32} \\cdot \\frac{5}{8} = \\frac{3}{4} \\cdot \\frac{5}{8} = \\frac{15}{32} = 0.46875.\n$$", "answer": "$$\\boxed{0.46875}$$", "id": "1633140"}, {"introduction": "While error-correcting codes are designed to fix errors, their effectiveness can be severely compromised by \"burst errors\" â€” long strings of consecutive errors common in wireless channels. Interleaving is a powerful technique used to combat this issue by scrambling the data before transmission and unscrambling it upon reception. This practice will guide you through the mechanics of a block interleaver, allowing you to visualize how a contiguous burst of channel errors is dispersed into isolated, more manageable errors for the decoder to handle [@problem_id:1633148].", "problem": "A digital communication system is designed to be resilient against burst errors, which are errors that occur in consecutive symbols during transmission. To achieve this, the system employs a data reshuffling technique before transmission and a corresponding unscrambling technique after reception.\n\nConsider a block of 12 symbols, indexed from 1 to 12. Before transmission, these symbols are rearranged. The process is as follows: the original sequence of symbols is written into a $3 \\times 4$ matrix (3 rows, 4 columns) column by column, from left to right and top to bottom. Then, the symbols are read out from this matrix row by row, from top to bottom and left to right, to form the transmitted sequence.\n\nThe reverse process happens at the receiver. The incoming sequence of 12 symbols is written into a new $3 \\times 4$ matrix row by row. The final, reconstructed sequence is then obtained by reading the symbols out from this second matrix column by column.\n\nSuppose that during transmission over a noisy channel, a burst error of length 4 corrupts the symbols at positions 5, 6, 7, and 8 of the 12-symbol *transmitted* sequence. After the receiver performs the unscrambling process, at which positions (1-indexed) in the final reconstructed sequence do these errors appear?\n\nA. 2, 5, 8, 11\n\nB. 5, 6, 7, 8\n\nC. 3, 6, 7, 10\n\nD. 3, 6, 9, 12\n\nE. 4, 5, 6, 7", "solution": "Label the original symbols by indices $k\\in\\{1,\\dots,12\\}$. They are written into a $3\\times 4$ matrix column by column, so index $k$ occupies matrix coordinates $(r,c)$ satisfying\n$$\nk=(c-1)\\cdot 3 + r,\\quad r\\in\\{1,2,3\\},\\ c\\in\\{1,2,3,4\\}.\n$$\nReading row by row forms the transmitted index $t$ given by\n$$\nt=(r-1)\\cdot 4 + c.\n$$\nAt the receiver, the inverse operation is performed: the transmitted sequence is written into a $3\\times 4$ matrix row by row, so a transmitted position $t$ maps to coordinates\n$$\nr=\\left\\lfloor\\frac{t-1}{4}\\right\\rfloor+1,\\qquad c=((t-1)\\bmod 4)+1.\n$$\nReading column by column gives the reconstructed index\n$$\ns=(c-1)\\cdot 3 + r.\n$$\nTherefore, the composite mapping from a transmitted position $t$ to its position $s$ in the final reconstructed sequence is\n$$\ns=3\\,((t-1)\\bmod 4)+\\left\\lfloor\\frac{t-1}{4}\\right\\rfloor+1.\n$$\nEvaluate this for the burst-error positions $t=5,6,7,8$:\n- For $t=5$: $t-1=4$, so $((t-1)\\bmod 4)=0$ and $\\left\\lfloor\\frac{t-1}{4}\\right\\rfloor=1$, hence $s=3\\cdot 0+1+1=2$.\n- For $t=6$: $t-1=5$, so $((t-1)\\bmod 4)=1$ and $\\left\\lfloor\\frac{t-1}{4}\\right\\rfloor=1$, hence $s=3\\cdot 1+1+1=5$.\n- For $t=7$: $t-1=6$, so $((t-1)\\bmod 4)=2$ and $\\left\\lfloor\\frac{t-1}{4}\\right\\rfloor=1$, hence $s=3\\cdot 2+1+1=8$.\n- For $t=8$: $t-1=7$, so $((t-1)\\bmod 4)=3$ and $\\left\\lfloor\\frac{t-1}{4}\\right\\rfloor=1$, hence $s=3\\cdot 3+1+1=11$.\nThus the errors appear at positions $2,5,8,11$ in the reconstructed sequence, which matches option A.", "answer": "$$\\boxed{A}$$", "id": "1633148"}, {"introduction": "This final practice synthesizes the concepts of concatenation and interleaving through the elegant structure of a product code, which can be viewed as a two-dimensional concatenated code. You will simulate the process of iterative decoding, a powerful algorithm where simple row and column decoders exchange information to collectively correct complex error patterns. This exercise provides a tangible glimpse into the principles behind advanced techniques like turbo codes, demonstrating how cooperative decoding can achieve performance far beyond the capability of its individual components [@problem_id:1633093].", "problem": "A product code is constructed using two identical systematic (7,4) Hamming codes. An original $4 \\times 4$ block of message bits is first encoded row-by-row to form a $4 \\times 7$ matrix. Then, each of the 7 columns of this new matrix is encoded to produce the final $7 \\times 7$ codeword matrix.\n\nThe component (7,4) Hamming code takes a 4-bit data vector $(d_1, d_2, d_3, d_4)$ and produces a 7-bit codeword $(c_1, c_2, c_3, c_4, c_5, c_6, c_7)$ where the bits are arranged as $(d_1, d_2, d_3, d_4, p_1, p_2, p_3)$. The parity-check bits $p_1, p_2, p_3$ are calculated using modulo-2 arithmetic. The code is defined by its parity-check matrix $H$:\n$$ H = \\begin{pmatrix} 1  1  0  1  1  0  0 \\\\ 1  0  1  1  0  1  0 \\\\ 0  1  1  1  0  0  1 \\end{pmatrix} $$\nFor any valid codeword $c$, the syndrome $s = Hc^T$ is the zero vector $(0,0,0)^T$. For a received vector $r$ containing a single error at position $i$ (1-indexed), the syndrome $s = Hr^T$ will be equal to the $i$-th column of $H$. The mapping from syndrome to error position is as follows:\n- (1,0,0) - pos 5\n- (0,1,0) - pos 6\n- (0,0,1) - pos 7\n- (1,1,0) - pos 1\n- (1,0,1) - pos 2\n- (0,1,1) - pos 3\n- (1,1,1) - pos 4\n\nA $7 \\times 7$ matrix $R$ is received from a noisy channel. Iterative decoding is applied to R. The process is as follows:\n1.  **Row Decoding:** For each of the 7 rows, calculate its syndrome. If the syndrome indicates a single-bit error, flip the corresponding bit in that row. If the syndrome is zero, the row is left unchanged. A multi-bit error might be misidentified as a single-bit error, and the decoder will proceed with the corresponding bit-flip.\n2.  **Column Decoding:** After all rows have been processed, perform the same decoding procedure for each of the 7 columns of the modified matrix.\n3.  **Iteration:** Repeat the full cycle of row decoding followed by column decoding until a full cycle (one row pass and one column pass) results in no bit flips.\n\nThe received matrix $R$ is:\n$$ R = \\begin{pmatrix}\n1  0  1  0  1  0  1 \\\\\n0  1  0  0  0  1  0 \\\\\n1  1  0  1  1  0  0 \\\\\n0  0  0  1  1  0  0 \\\\\n1  1  1  1  1  1  1 \\\\\n0  1  0  0  1  0  1 \\\\\n1  0  0  0  1  1  0\n\\end{pmatrix} $$\nAfter the iterative decoding process converges, determine the final corrected second row of the matrix. Provide your answer as the integer value of this 7-bit binary vector, treating the leftmost bit as the most significant bit.", "solution": "Define the columns of the given parity-check matrix $H$ as $v_{i}$ for positions $i=1,\\dots,7$:\n$$\nv_{1}=(1,1,0),\\quad v_{2}=(1,0,1),\\quad v_{3}=(0,1,1),\\quad v_{4}=(1,1,1),\\quad v_{5}=(1,0,0),\\quad v_{6}=(0,1,0),\\quad v_{7}=(0,0,1).\n$$\nFor any length-$7$ binary vector $x=(x_{1},\\dots,x_{7})$, its syndrome is $s=\\sum_{i:x_{i}=1} v_{i}$ (modulo $2$). If $s\\neq 0$, flip the bit at the position indicated by the mapping $s\\mapsto i$ (where $v_{i}=s$).\n\nStart with the received matrix $R$ (rows $1$ to $7$):\n$$\n\\begin{pmatrix}\n1  0  1  0  1  0  1 \\\\\n0  1  0  0  0  1  0 \\\\\n1  1  0  1  1  0  0 \\\\\n0  0  0  1  1  0  0 \\\\\n1  1  1  1  1  1  1 \\\\\n0  1  0  0  1  0  1 \\\\\n1  0  0  0  1  1  0\n\\end{pmatrix}.\n$$\n\nRow decoding, pass 1:\n- Row 1: ones at $\\{1,3,5,7\\}$, $s=v_{1}+v_{3}+v_{5}+v_{7}=(1,1,0)+(0,1,1)+(1,0,0)+(0,0,1)=(0,0,0)$, no flip.\n- Row 2: ones at $\\{2,6\\}$, $s=v_{2}+v_{6}=(1,0,1)+(0,1,0)=(1,1,1)\\mapsto 4$, flip position $4$: row becomes $(0,1,0,1,0,1,0)$.\n- Row 3: ones at $\\{1,2,4,5\\}$, $s=v_{1}+v_{2}+v_{4}+v_{5}=(1,1,0)+(1,0,1)+(1,1,1)+(1,0,0)=(0,0,0)$, no flip.\n- Row 4: ones at $\\{4,5\\}$, $s=v_{4}+v_{5}=(1,1,1)+(1,0,0)=(0,1,1)\\mapsto 3$, flip position $3$: row becomes $(0,0,1,1,1,0,0)$.\n- Row 5: ones at $\\{1,2,3,4,5,6,7\\}$, $s=v_{1}+v_{2}+v_{3}+v_{4}+v_{5}+v_{6}+v_{7}=(0,0,0)$, no flip.\n- Row 6: ones at $\\{2,5,7\\}$, $s=v_{2}+v_{5}+v_{7}=(1,0,1)+(1,0,0)+(0,0,1)=(0,0,0)$, no flip.\n- Row 7: ones at $\\{1,5,6\\}$, $s=v_{1}+v_{5}+v_{6}=(1,1,0)+(1,0,0)+(0,1,0)=(0,0,0)$, no flip.\n\nAfter row pass 1, the matrix is\n$$\n\\begin{pmatrix}\n1  0  1  0  1  0  1 \\\\\n0  1  0  1  0  1  0 \\\\\n1  1  0  1  1  0  0 \\\\\n0  0  1  1  1  0  0 \\\\\n1  1  1  1  1  1  1 \\\\\n0  1  0  0  1  0  1 \\\\\n1  0  0  0  1  1  0\n\\end{pmatrix}.\n$$\n\nColumn decoding, pass 1 (compute syndrome down each column; positions now refer to row indices):\n- Column 1 (ones at $\\{1,3,5,7\\}$): $s=v_{1}+v_{3}+v_{5}+v_{7}=(0,0,0)$, no flip.\n- Column 2 (ones at $\\{2,3,5,6\\}$): $s=v_{2}+v_{3}+v_{5}+v_{6}=(0,0,0)$, no flip.\n- Column 3 (ones at $\\{1,4,5\\}$): $s=v_{1}+v_{4}+v_{5}=(1,0,1)\\mapsto 2$, flip row $2$: entry $(2,3)$ flips $0\\to 1$.\n- Column 4 (ones at $\\{2,3,4,5\\}$): $s=v_{2}+v_{3}+v_{4}+v_{5}=(1,0,1)\\mapsto 2$, flip row $2$: entry $(2,4)$ flips $1\\to 0$.\n- Column 5 (ones at $\\{1,3,4,5,6,7\\}$): $s=v_{1}+v_{3}+v_{4}+v_{5}+v_{6}+v_{7}=(1,0,1)\\mapsto 2$, flip row $2$: entry $(2,5)$ flips $0\\to 1$.\n- Column 6 (ones at $\\{2,5,7\\}$): $s=v_{2}+v_{5}+v_{7}=(0,0,0)$, no flip.\n- Column 7 (ones at $\\{1,5,6\\}$): $s=v_{1}+v_{5}+v_{6}=(0,0,0)$, no flip.\n\nAfter column pass 1, only row $2$ changed and is now $(0,1,1,0,1,1,0)$.\n\nRow decoding, pass 2:\n- Row 1: $s=(0,0,0)$, no flip (same calculation as before).\n- Row 2: ones at $\\{2,3,5,6\\}$, $s=v_{2}+v_{3}+v_{5}+v_{6}=(0,0,0)$, no flip.\n- Row 3: $s=(0,0,0)$, no flip.\n- Row 4: ones at $\\{3,4,5\\}$, $s=v_{3}+v_{4}+v_{5}=(0,0,0)$, no flip.\n- Row 5: $s=(0,0,0)$, no flip.\n- Row 6: $s=(0,0,0)$, no flip.\n- Row 7: $s=(0,0,0)$, no flip.\n\nColumn decoding, pass 2:\nAll column syndromes remain zero (same combinations as after column pass 1), so no flips occur.\n\nTherefore the iterative decoding converges. The final corrected second row is the binary vector $0110110$. Interpreting with the leftmost bit as the most significant bit, its integer value is\n$$\n0\\cdot 2^{6}+1\\cdot 2^{5}+1\\cdot 2^{4}+0\\cdot 2^{3}+1\\cdot 2^{2}+1\\cdot 2^{1}+0\\cdot 2^{0}=32+16+4+2=54.\n$$", "answer": "$$\\boxed{54}$$", "id": "1633093"}]}