{"hands_on_practices": [{"introduction": "Understanding how fountain codes work begins with visualizing their structure. A Tanner graph is an indispensable tool that represents the relationship between the original source symbols (variable nodes) and the encoded packets (check nodes). This exercise [@problem_id:1651913] provides practice in translating the algebraic description of an LT code into this graphical form, which is the first step toward understanding the mechanics of the peeling decoder.", "problem": "In a digital communication system employing a Luby Transform (LT) code, a set of 4 source symbols, denoted as $s_1, s_2, s_3,$ and $s_4$, are encoded into 5 transmitted packets, denoted as $p_1, p_2, p_3, p_4,$ and $p_5$. Each packet is generated by taking the bitwise exclusive-OR (XOR, denoted by $\\oplus$) of a subset of the source symbols.\n\nThe composition of the five received packets is as follows:\n- $p_1 = s_1 \\oplus s_3$\n- $p_2 = s_2 \\oplus s_3 \\oplus s_4$\n- $p_3 = s_1 \\oplus s_4$\n- $p_4 = s_2 \\oplus s_4$\n- $p_5 = s_1 \\oplus s_2 \\oplus s_3$\n\nThis encoding scheme can be represented by a Tanner graph, which is a bipartite graph. One set of nodes, called variable nodes, represents the source symbols ($s_i$). The other set of nodes, called check nodes, represents the encoded packets ($p_j$). An edge exists between a variable node $s_i$ and a check node $p_j$ if and only if the source symbol $s_i$ is a component of the packet $p_j$. The degree of a node is the number of edges connected to it.\n\nBased on the given packet compositions, which of the following statements correctly describes the degrees of the nodes in the corresponding Tanner graph?\n\nA. All variable nodes have a degree of 3, and all check nodes have a degree of 2.\n\nB. All variable nodes have a degree of 3, and the check nodes for ($p_1, p_2, p_3, p_4, p_5$) have degrees (2, 3, 2, 2, 3) respectively.\n\nC. The variable nodes for ($s_1, s_2, s_3, s_4$) have degrees (3, 3, 3, 3) respectively, and the check nodes for ($p_1, p_2, p_3, p_4, p_5$) have degrees (3, 2, 3, 2, 3) respectively.\n\nD. All check nodes have a degree of 3, and all variable nodes have a degree of 3.\n\nE. The variable nodes for ($s_1, s_2, s_3, s_4$) have degrees (2, 3, 3, 2) respectively, and the check nodes for ($p_1, p_2, p_3, p_4, p_5$) have degrees (2, 3, 2, 2, 3) respectively.", "solution": "A Tanner graph for this LT code has variable nodes for $s_{1},s_{2},s_{3},s_{4}$ and check nodes for $p_{1},p_{2},p_{3},p_{4},p_{5}$. An edge connects $s_{i}$ to $p_{j}$ if and only if $s_{i}$ appears in $p_{j}$. Therefore, the degree of a variable node $s_{i}$ equals the number of packets containing $s_{i}$, and the degree of a check node $p_{j}$ equals the number of source symbols XORed to form $p_{j}$.\n\nFrom the given compositions:\n- $p_{1}=s_{1}\\oplus s_{3}$ implies $\\deg(p_{1})=2$ and edges to $s_{1},s_{3}$.\n- $p_{2}=s_{2}\\oplus s_{3}\\oplus s_{4}$ implies $\\deg(p_{2})=3$ and edges to $s_{2},s_{3},s_{4}$.\n- $p_{3}=s_{1}\\oplus s_{4}$ implies $\\deg(p_{3})=2$ and edges to $s_{1},s_{4}$.\n- $p_{4}=s_{2}\\oplus s_{4}$ implies $\\deg(p_{4})=2$ and edges to $s_{2},s_{4}$.\n- $p_{5}=s_{1}\\oplus s_{2}\\oplus s_{3}$ implies $\\deg(p_{5})=3$ and edges to $s_{1},s_{2},s_{3}$.\n\nCounting for variable nodes:\n- $s_{1}$ appears in $p_{1},p_{3},p_{5}$, so $\\deg(s_{1})=3$.\n- $s_{2}$ appears in $p_{2},p_{4},p_{5}$, so $\\deg(s_{2})=3$.\n- $s_{3}$ appears in $p_{1},p_{2},p_{5}$, so $\\deg(s_{3})=3$.\n- $s_{4}$ appears in $p_{2},p_{3},p_{4}$, so $\\deg(s_{4})=3$.\n\nThus the variable node degrees are $(3,3,3,3)$ for $(s_{1},s_{2},s_{3},s_{4})$, and the check node degrees are $(2,3,2,2,3)$ for $(p_{1},p_{2},p_{3},p_{4},p_{5})$. This matches option B.", "answer": "$$\\boxed{B}$$", "id": "1651913"}, {"introduction": "The process of decoding fountain codes relies on solving a system of linear equations, often one piece at a time. This exercise [@problem_id:1651915] simulates a single step of the decoding process where a known packet and a previously recovered symbol are used to solve for a new, unknown symbol. It is a great opportunity to practice the underlying finite field arithmetic that makes these codes function.", "problem": "In modern digital communication and storage systems, fountain codes, such as Raptor codes, are used for reliable data transmission over unreliable channels. These codes generate an endless stream of encoded packets from a finite set of source data symbols. The key mathematical structure enabling this process is a finite field, also known as a Galois Field (GF), where all arithmetic operations (addition, subtraction, multiplication, and division) are well-defined.\n\nConsider a simplified scenario within such a a system. The source data is broken into symbols, and all arithmetic is performed in the Galois Field $GF(11)$. A received encoded packet $p$ has a value that is a linear combination of two original source symbols, $s_1$ and $s_2$. The specific relationship for this packet is given by the equation:\n$$p = 4s_1 + 7s_2$$\nSuppose that the value of the received packet is measured to be $p=2$. Through other means, the system has already successfully decoded the symbol $s_2$ and found its value to be $s_2=9$.\n\nYour task is to recover the value of the original source symbol $s_1$. The result should be an integer from the set $\\{0, 1, 2, ..., 10\\}$.", "solution": "We work in the finite field $GF(11)$, so all equalities are taken modulo $11$. The packet relation is $p=4s_{1}+7s_{2}$ and we are given $p=2$ and $s_{2}=9$. Substitute these values to obtain\n$$\n4s_{1}+7\\cdot 9 \\equiv 2 \\pmod{11}.\n$$\nCompute the product and reduce modulo $11$:\n$$\n7\\cdot 9=63 \\equiv 8 \\pmod{11},\n$$\nso the equation becomes\n$$\n4s_{1}+8 \\equiv 2 \\pmod{11}.\n$$\nSubtract $8$ from both sides:\n$$\n4s_{1} \\equiv 2-8 \\equiv -6 \\equiv 5 \\pmod{11}.\n$$\nSince $11$ is prime, every nonzero element has a multiplicative inverse modulo $11$. The inverse of $4$ modulo $11$ is $3$ because $4\\cdot 3=12 \\equiv 1 \\pmod{11}$. Multiply both sides by $3$:\n$$\ns_{1} \\equiv 3\\cdot 5 \\equiv 15 \\equiv 4 \\pmod{11}.\n$$\nThus the recovered symbol is $s_{1}=4$ in $\\{0,1,2,\\ldots,10\\}$.", "answer": "$$\\boxed{4}$$", "id": "1651915"}, {"introduction": "While the peeling decoder is elegantly simple, it is not foolproof. The decoding process can get stuck if no simple-to-solve packets are available, even if unrecovered data remains. This exercise [@problem_id:1651898] demonstrates a classic scenario where the decoder \"stalls\" due to a cycle in the Tanner graph, highlighting a key challenge that led to the development of the more robust Raptor codes.", "problem": "In the study of modern error-correcting codes, Luby Transform (LT) codes are a class of fountain codes known for their simple encoding and decoding mechanisms. An LT code generates encoded symbols by taking the XOR (exclusive OR, denoted by $\\oplus$) sum of a randomly chosen set of source symbols.\n\nThis process can be visualized using a bipartite Tanner graph, where one set of nodes represents the source symbols (variable nodes) and the other set represents the encoded symbols (check nodes). An edge connects a variable node to a check node if that source symbol was included in the XOR sum for that encoded symbol.\n\nThe standard decoding algorithm for LT codes is a greedy iterative process called the peeling decoder. The process is as follows:\n1.  Identify a \"ripple,\" which is a check node of degree one (i.e., it is connected to only one variable node).\n2.  If a ripple is found, the value of the connected variable node is immediately recovered (it is equal to the value of the check node).\n3.  This recovered variable's value is then XORed into all other check nodes it is connected to. The recovered variable node, the ripple check node, and all their incident edges are removed from the graph.\n4.  The process repeats from Step 1.\nIf at any point there are no check nodes of degree one, but there are still unrecovered variable nodes, the decoder is said to \"stall.\"\n\nConsider a scenario where four source symbols, $\\{s_1, s_2, s_3, s_4\\}$, are encoded into four symbols, $\\{c_1, c_2, c_3, c_4\\}$, according to the following relationships:\n- $c_1 = s_3$\n- $c_2 = s_1 \\oplus s_2 \\oplus s_3$\n- $c_3 = s_1 \\oplus s_4$\n- $c_4 = s_2 \\oplus s_4$\n\nAssuming these four encoded symbols are received without error, what is the outcome of applying the peeling decoder to this system?\n\nA. The decoder successfully recovers all four source symbols $\\{s_1, s_2, s_3, s_4\\}$.\n\nB. The decoder stalls immediately, as there are no degree-one check nodes in the initial graph.\n\nC. The decoder recovers some symbols but stalls before recovering all of them. A minimal set of unrecoverable symbols is $\\{s_1, s_2, s_4\\}$.\n\nD. The decoder recovers some symbols but stalls before recovering all of them. A minimal set of unrecoverable symbols is $\\{s_1, s_4\\}$.\n\nE. The decoder can recover all symbols, but only if it first decodes $s_1$ and $s_2$ simultaneously by solving a system of linear equations.", "solution": "We represent the system as a bipartite graph with variable nodes $\\{s_{1},s_{2},s_{3},s_{4}\\}$ and check nodes $\\{c_{1},c_{2},c_{3},c_{4}\\}$, with edges corresponding to inclusion in the XOR. The equations are\n$$\nc_{1}=s_{3},\\quad c_{2}=s_{1}\\oplus s_{2}\\oplus s_{3},\\quad c_{3}=s_{1}\\oplus s_{4},\\quad c_{4}=s_{2}\\oplus s_{4}.\n$$\nBy the peeling decoder rule, a ripple is any check node of degree one. Initially, $c_{1}$ has degree one since it is connected only to $s_{3}$. Therefore, we immediately recover\n$$\ns_{3}=c_{1}.\n$$\nWe then XOR this recovered variable into all neighboring checks and remove $s_{3}$ and $c_{1}$ and their incident edges from the graph. The only neighboring check is $c_{2}$, which updates to\n$$\nc_{2}'=c_{2}\\oplus s_{3}=(s_{1}\\oplus s_{2}\\oplus s_{3})\\oplus s_{3}=s_{1}\\oplus s_{2}.\n$$\nThe residual system is\n$$\nc_{2}'=s_{1}\\oplus s_{2},\\quad c_{3}=s_{1}\\oplus s_{4},\\quad c_{4}=s_{2}\\oplus s_{4}.\n$$\nEach remaining check has degree two, so there are no degree-one checks (no ripple), and the peeling decoder stalls at this point.\n\nTo see that no further variables can be recovered by peeling, observe the linear dependence among the residual equations:\n$$\n(s_{1}\\oplus s_{4})\\oplus(s_{2}\\oplus s_{4})=s_{1}\\oplus s_{2},\n$$\nso $c_{2}'=c_{3}\\oplus c_{4}$. Hence the residual system has rank two in the three unknowns $\\{s_{1},s_{2},s_{4}\\}$, leaving one degree of freedom and preventing unique recovery by peeling. The unrecovered variables form a stopping set $S=\\{s_{1},s_{2},s_{4}\\}$: every neighboring check node ($c_{2}',c_{3},c_{4}$) has degree at least two with respect to $S$, and any proper subset of $S$ would induce a degree-one check, so $S$ is minimal.\n\nTherefore, the decoder recovers $s_{3}$ and then stalls with the minimal unrecoverable set $\\{s_{1},s_{2},s_{4}\\}$, matching option C.", "answer": "$$\\boxed{C}$$", "id": "1651898"}]}