{"hands_on_practices": [{"introduction": "The Viterbi algorithm operates by finding the path of minimum cumulative cost through a trellis diagram. This first practice focuses on the elementary calculation at the heart of the algorithm: the branch metric. By calculating the Hamming distance between a received signal and the ideal output for a specific state transition, you will be computing the \"cost\" of that single step, a foundational skill for decoding any convolutional code [@problem_id:1616748].", "problem": "A digital communication system uses a rate $R=1/2$, constraint length $K=3$ convolutional encoder. The state of the encoder at time step $i$ is defined by the contents of its two memory registers, $S_i = (m_{i-1}, m_{i-2})$, where $m_{i-k}$ is the input bit from $k$ time steps prior.\n\nThe two output bits at time step $i$, denoted by the pair $c_i = (c_{i,1}, c_{i,2})$, are generated from the current input bit $m_i$ and the state $(m_{i-1}, m_{i-2})$ according to the following generator rules, where $\\oplus$ denotes addition modulo-2:\n$c_{i,1} = m_i \\oplus m_{i-1} \\oplus m_{i-2}$\n$c_{i,2} = m_i \\oplus m_{i-2}$\n\nAfter transmission over a noisy channel, the receiver gets a corrupted version of the encoded sequence. In the Viterbi decoding algorithm, the receiver calculates a branch metric for each possible state transition to find the most likely transmitted sequence. The branch metric for a given transition is defined as the Hamming distance between the received pair of bits and the ideal pair of bits that the encoder would have produced for that same transition.\n\nSuppose at time step $i$, the encoder is in state $S_i = (1, 0)$ and the next input bit is $m_i = 1$. At the receiver, the corresponding received bit pair for this time step is observed to be $r_i = (1, 0)$.\n\nCalculate the numerical value of the branch metric for this specific transition.", "solution": "The encoder is rate $R=1/2$ with constraint length $K=3$, so the state at time $i$ is $S_{i}=(m_{i-1},m_{i-2})$. The generator rules are\n$$\nc_{i,1}=m_{i}\\oplus m_{i-1}\\oplus m_{i-2}, \\qquad c_{i,2}=m_{i}\\oplus m_{i-2}.\n$$\nGiven $S_{i}=(1,0)$ and $m_{i}=1$, compute the ideal encoder output:\n$$\nc_{i,1}=1\\oplus 1\\oplus 0=(1\\oplus 1)\\oplus 0=0\\oplus 0=0, \\qquad c_{i,2}=1\\oplus 0=1,\n$$\nso $c_{i}=(0,1)$. The received pair is $r_{i}=(1,0)$.\n\nThe Viterbi branch metric is the Hamming distance between $c_{i}$ and $r_{i}$, i.e., the number of differing positions. Equivalently, for binary symbols,\n$$\nd_{H}(c_{i},r_{i})=(c_{i,1}\\oplus r_{i,1})+(c_{i,2}\\oplus r_{i,2})=(0\\oplus 1)+(1\\oplus 0)=1+1=2.\n$$\nTherefore, the branch metric for this transition is $2$.", "answer": "$$\\boxed{2}$$", "id": "1616748"}, {"introduction": "Having mastered the calculation of individual branch metrics, we now scale up to decode an entire received sequence. This practice guides you through a complete execution of the Viterbi algorithm, from initializing path metrics to making survivor path decisions at each stage of the trellis. By navigating the trellis and performing the final traceback, you will experience firsthand how the algorithm efficiently finds the most probable transmitted message amidst channel noise [@problem_id:1664334].", "problem": "In a digital communication system, a simple rate-1/2 convolutional encoder is used to add redundancy to a message before transmission. The encoder has a single bit of memory, which defines its state. The state space consists of two states: State `S0`, representing that the previous input bit was `0`, and State `S1`, representing that the previous input bit was `1`.\n\nAt each time step, one input bit `m` enters the encoder, a state transition occurs, and a two-bit output `c` is generated. The transition logic is as follows:\n- If the encoder is in state `S0` (previous input was `0`):\n    - An input bit `m=0` transitions the encoder back to state `S0` and produces the output `c=00`.\n    - An input bit `m=1` transitions the encoder to state `S1` and produces the output `c=11`.\n- If the encoder is in state `S1` (previous input was `1`):\n    - An input bit `m=0` transitions the encoder to state `S0` and produces the output `c=10`.\n    - An input bit `m=1` transitions the encoder back to state `S1` and produces the output `c=01`.\n\nAn unknown 3-bit information sequence is processed by this encoder. Before encoding, a single '0' bit, known as a flush bit, is appended to the 3-bit sequence. The encoder is initialized in state `S0` before processing the first bit of this appended 4-bit sequence. The resulting 8-bit encoded sequence is transmitted over a noisy channel.\n\nThe received sequence of 2-bit pairs is `[10, 01, 01, 10]`. Assuming that errors are independent and equally likely for any bit, the most probable transmitted sequence is the one with the minimum total Hamming distance to the received sequence. Use the Viterbi algorithm to determine the original 3-bit information sequence.\n\nWhich of the following is the most likely original 3-bit information sequence?\nA. `011`\n\nB. `101`\n\nC. `111`\n\nD. `001`\n\nE. `110`", "solution": "The goal is to find the original 3-bit information sequence by applying the Viterbi algorithm to decode the received sequence `r = [10, 01, 01, 10]`. The Viterbi algorithm finds the path through the trellis diagram of the convolutional code that has the minimum Hamming distance to the received sequence.\n\nThe encoder has two states, `S0` and `S1`, and is initialized in `S0`. The input is a 4-bit sequence (3 message bits + 1 flush bit). The algorithm proceeds step-by-step for the 4 time steps. The metric used is the cumulative Hamming distance, which we will call the Path Metric (PM). The branch metric is the Hamming distance between the output of a transition and the received pair for that time step.\n\nLet `PM_t(S)` be the path metric for state `S` at time `t`.\n**Initial Step (t=0):**\nThe encoder starts in state `S0`.\n`PM_0(S0) = 0`\n`PM_0(S1) = \\infty` (or a very large number, since it's an impossible starting state)\n\n**Time Step 1 (t=1):**\nReceived bits: `r_1 = 10`.\nTwo paths emerge from `S0` at `t=0`.\n- Path to `S0`: Input `m=0`, output `c=00`. Branch metric = Hamming distance `d(00, 10) = 1`.\n  `PM_1(S0) = PM_0(S0) + d(00, 10) = 0 + 1 = 1`. The survivor path to `S0` corresponds to input `0`.\n- Path to `S1`: Input `m=1`, output `c=11`. Branch metric = `d(11, 10) = 1`.\n  `PM_1(S1) = PM_0(S0) + d(11, 10) = 0 + 1 = 1`. The survivor path to `S1` corresponds to input `1`.\n\n**Time Step 2 (t=2):**\nReceived bits: `r_2 = 01`.\n- Paths to `S0`:\n  - From `S0` (input `m=0`, output `c=00`): Total PM = `PM_1(S0) + d(00, 01) = 1 + 1 = 2`.\n  - From `S1` (input `m=0`, output `c=10`): Total PM = `PM_1(S1) + d(10, 01) = 1 + 2 = 3`.\n  The minimum PM for `S0` is 2. The survivor path is from `S0`.\n  `PM_2(S0) = 2`. The input sequence for this path is `00`.\n- Paths to `S1`:\n  - From `S0` (input `m=1`, output `c=11`): Total PM = `PM_1(S0) + d(11, 01) = 1 + 1 = 2`.\n  - From `S1` (input `m=1`, output `c=01`): Total PM = `PM_1(S1) + d(01, 01) = 1 + 0 = 1`.\n  The minimum PM for `S1` is 1. The survivor path is from `S1`.\n  `PM_2(S1) = 1`. The input sequence for this path is `11`.\n\n**Time Step 3 (t=3):**\nReceived bits: `r_3 = 01`.\n- Paths to `S0`:\n  - From `S0` (input `m=0`, output `c=00`): Total PM = `PM_2(S0) + d(00, 01) = 2 + 1 = 3`.\n  - From `S1` (input `m=0`, output `c=10`): Total PM = `PM_2(S1) + d(10, 01) = 1 + 2 = 3`.\n  There is a tie. A common convention is to choose the path from the upper state (`S0`).\n  `PM_3(S0) = 3`. The survivor path corresponds to input sequence `000`.\n- Paths to `S1`:\n  - From `S0` (input `m=1`, output `c=11`): Total PM = `PM_2(S0) + d(11, 01) = 2 + 1 = 3`.\n  - From `S1` (input `m=1`, output `c=01`): Total PM = `PM_2(S1) + d(01, 01) = 1 + 0 = 1`.\n  The minimum PM for `S1` is 1. The survivor path is from `S1`.\n  `PM_3(S1) = 1`. The survivor path corresponds to input sequence `111`.\n\n**Time Step 4 (t=4):**\nReceived bits: `r_4 = 10`. The input is the flush bit `m=0`. We only consider transitions for input `0`. The encoder must end in state `S0`.\n- Path from `S0` at `t=3` to `S0` at `t=4` (input `m=0`, output `c=00`):\n  Final PM = `PM_3(S0) + d(00, 10) = 3 + 1 = 4`.\n- Path from `S1` at `t=3` to `S0` at `t=4` (input `m=0`, output `c=10`):\n  Final PM = `PM_3(S1) + d(10, 10) = 1 + 0 = 1`.\n\n**Traceback:**\nComparing the final path metrics for paths ending in `S0`, the minimum is 1. This path is the most likely one. We trace it back to find the input sequence.\n- At `t=4`, the winning path came from `S1` at `t=3`. The input was `0`.\n- At `t=3`, the survivor path into `S1` was from `S1` at `t=2`. The input was `1`.\n- At `t=2`, the survivor path into `S1` was from `S1` at `t=1`. The input was `1`.\n- At `t=1`, the survivor path into `S1` was from `S0` at `t=0`. The input was `1`.\n\nReading the inputs in chronological order, the decoded 4-bit sequence is `1110`. The last bit is the flush bit, so the original 3-bit information sequence is `111`.\n\nThis matches option C.", "answer": "$$\\boxed{C}$$", "id": "1664334"}, {"introduction": "The Viterbi algorithm is not only a decoding tool but also a conceptual framework for understanding a code's robustness. This practice explores the idea of an \"error event,\" where the decoded path temporarily diverges from the true path in the trellis. By analyzing the properties of such detours, you will gain insight into the fundamental performance limits of a convolutional code and understand how its structure dictates its ability to correct errors [@problem_id:1616756].", "problem": "A digital communication system employs a rate $R=1/2$ convolutional code for forward error correction. The encoder has a memory of $M=2$. The state of the encoder at time step $k$ is given by the two previous information bits, $S_k = (u_{k-1}, u_{k-2})$. The encoder is initialized in the all-zero state, meaning $S_1 = (u_0, u_{-1}) = (0, 0)$. The two output bits at time $k$, denoted by the pair $(v_k^{(1)}, v_k^{(2)})$, are generated from the current input bit $u_k$ and the current state $S_k$ according to the following generator equations, where all additions are performed modulo-2:\n$$v_k^{(1)} = u_k + u_{k-1} + u_{k-2}$$\n$$v_k^{(2)} = u_k + u_{k-2}$$\n\nAssume the transmitter sends a message composed entirely of zeros (the all-zero information sequence). The correct coded sequence transmitted is therefore also an all-zero sequence. At the receiver, a Viterbi decoder might erroneously choose a path through the code trellis that diverges from the all-zero path and later re-merges. Such a detour is called an error event. The propensity for an error event to be confused with the correct all-zero path is related to the Hamming weight of the coded sequence generated along this incorrect path (i.e., the total number of '1's in its output).\n\nConsider two specific error events, Path A and Path B, which both diverge from the all-zero path starting at time $k=1$.\n- **Path A** is the trajectory taken by the encoder if the input information sequence is $u_A = (1, 0, 0, 0, \\dots)$, with a single '1' at time $k=1$.\n- **Path B** is the trajectory taken if the input information sequence is $u_B = (1, 1, 0, 0, \\dots)$, with '1's at times $k=1$ and $k=2$.\n\nBoth paths will eventually return to the all-zero state. Let $d_A$ be the Hamming weight of the full coded output sequence generated by Path A from the point of divergence until it re-merges with the all-zero path. Similarly, let $d_B$ be the Hamming weight for Path B.\n\nCalculate the ratio $d_B / d_A$.", "solution": "The encoder has memory $M=2$ and state $S_{k}=(u_{k-1},u_{k-2})$. With all-zero transmitted information, the all-zero coded sequence is the correct path. An error event is generated by a nonzero input subsequence that leaves the all-zero state and later returns to it; the Hamming weight of the event equals the total number of ones in the encoder outputs along that subsequence. Because the all-zero path outputs are all zeros, the Hamming weight of the incorrect path equals the Hamming distance to the correct path over the event.\n\nThe generator equations (modulo-2) are\n$$\nv_{k}^{(1)}=u_{k}+u_{k-1}+u_{k-2},\\qquad v_{k}^{(2)}=u_{k}+u_{k-2}.\n$$\nRe-merging with the all-zero path occurs when the state returns to $(0,0)$, i.e., when two successive input bits are zero. By the state definition $S_{k}=(u_{k-1},u_{k-2})$, the outputs to include are those produced at each time $k$ from the divergence at $k=1$ until the time step just before the state first becomes $(0,0)$ again (equivalently, include outputs up to and including the transition that returns the state to zero).\n\nPath A has input $u_{1}=1$, $u_{2}=0$, $u_{3}=0$, $u_{k}=0$ for $k\\geq 4$. The states evolve as $S_{1}=(0,0)$, $S_{2}=(1,0)$, $S_{3}=(0,1)$, $S_{4}=(0,0)$, so the event spans $k=1,2,3$. The outputs are:\n$$\nk=1:\\ (v_{1}^{(1)},v_{1}^{(2)})=(1+0+0,\\ 1+0)=(1,1),\n$$\n$$\nk=2:\\ (v_{2}^{(1)},v_{2}^{(2)})=(0+1+0,\\ 0+0)=(1,0),\n$$\n$$\nk=3:\\ (v_{3}^{(1)},v_{3}^{(2)})=(0+0+1,\\ 0+1)=(1,1).\n$$\nThe per-time-step Hamming weights are $2$, $1$, and $2$, so\n$$\nd_{A}=2+1+2=5.\n$$\n\nPath B has input $u_{1}=1$, $u_{2}=1$, $u_{3}=0$, $u_{4}=0$, $u_{k}=0$ for $k\\geq 5$. The states evolve as $S_{1}=(0,0)$, $S_{2}=(1,0)$, $S_{3}=(1,1)$, $S_{4}=(0,1)$, $S_{5}=(0,0)$, so the event spans $k=1,2,3,4$. The outputs are:\n$$\nk=1:\\ (v_{1}^{(1)},v_{1}^{(2)})=(1+0+0,\\ 1+0)=(1,1),\n$$\n$$\nk=2:\\ (v_{2}^{(1)},v_{2}^{(2)})=(1+1+0,\\ 1+0)=(0,1),\n$$\n$$\nk=3:\\ (v_{3}^{(1)},v_{3}^{(2)})=(0+1+1,\\ 0+1)=(0,1),\n$$\n$$\nk=4:\\ (v_{4}^{(1)},v_{4}^{(2)})=(0+0+1,\\ 0+1)=(1,1).\n$$\nThe per-time-step Hamming weights are $2$, $1$, $1$, and $2$, so\n$$\nd_{B}=2+1+1+2=6.\n$$\n\nTherefore, the required ratio is\n$$\n\\frac{d_{B}}{d_{A}}=\\frac{6}{5}.\n$$", "answer": "$$\\boxed{\\frac{6}{5}}$$", "id": "1616756"}]}