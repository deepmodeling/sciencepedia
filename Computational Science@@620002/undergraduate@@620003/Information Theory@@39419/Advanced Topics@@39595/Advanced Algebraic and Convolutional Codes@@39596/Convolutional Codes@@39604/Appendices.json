{"hands_on_practices": [{"introduction": "To begin our hands-on exploration of convolutional codes, we'll start with the most fundamental operation: the encoding process. Understanding how an input message is transformed into a longer, redundant codeword is the first step toward appreciating their error-correcting capabilities. This exercise [@problem_id:1614381] will guide you through a step-by-step calculation, showing how the encoder's memory and generator connections work together to produce the final output sequence.", "problem": "A deep space probe utilizes a simple Forward Error Correction (FEC) system to protect its telemetry data. The system employs a convolutional encoder with a code rate of $R = 1/2$ and a memory of $\\nu=2$. This means for each bit of the input message, the encoder produces two output bits, and its calculations depend on the current input bit and the two preceding input bits.\n\nThe encoder's operation is defined by two generator connections. Let the input message bit at time step $k$ be $m_k$. The two previous message bits, $m_{k-1}$ and $m_{k-2}$, are stored in the encoder's memory registers. The two output bits at time step $k$, denoted $c_k^{(1)}$ and $c_k^{(2)}$, are generated by the following rules, where all additions are performed modulo 2:\n$$\n\\begin{cases}\nc_k^{(1)} = m_k + m_{k-1} + m_{k-2} \\\\\nc_k^{(2)} = m_k + m_{k-2}\n\\end{cases}\n$$\nAssume the encoder is in the all-zero state initially, meaning the memory registers corresponding to $m_{k-1}$ and $m_{k-2}$ are both zero before the first message bit is processed. The encoder is tasked with encoding the input message sequence $m = (1, 1, 0, 1)$. The final output is a single bit stream formed by interleaving the two output sequences, i.e., $c = (c_1^{(1)}, c_1^{(2)}, c_2^{(1)}, c_2^{(2)}, c_3^{(1)}, c_3^{(2)}, \\dots)$.\n\nWhat are the first 8 bits of the encoded output sequence?\n\nA. 11101000\n\nB. 11000101\n\nC. 11010100\n\nD. 11100001\n\nE. 01100110", "solution": "All additions are modulo 2. The encoder has memory of two previous bits, with initial state $m_{0}=0$ and $m_{-1}=0$. The generators are\n$$\n\\begin{cases}\nc_{k}^{(1)}=m_{k}+m_{k-1}+m_{k-2},\\\\\nc_{k}^{(2)}=m_{k}+m_{k-2}.\n\\end{cases}\n$$\nGiven $m=(m_{1},m_{2},m_{3},m_{4})=(1,1,0,1)$, compute for each $k$:\n\nFor $k=1$: $m_{1}=1$, $m_{0}=0$, $m_{-1}=0$,\n$$\nc_{1}^{(1)}=1+0+0=1,\\quad c_{1}^{(2)}=1+0=1.\n$$\n\nFor $k=2$: $m_{2}=1$, $m_{1}=1$, $m_{0}=0$,\n$$\nc_{2}^{(1)}=1+1+0=0,\\quad c_{2}^{(2)}=1+0=1.\n$$\n\nFor $k=3$: $m_{3}=0$, $m_{2}=1$, $m_{1}=1$,\n$$\nc_{3}^{(1)}=0+1+1=0,\\quad c_{3}^{(2)}=0+1=1.\n$$\n\nFor $k=4$: $m_{4}=1$, $m_{3}=0$, $m_{2}=1$,\n$$\nc_{4}^{(1)}=1+0+1=0,\\quad c_{4}^{(2)}=1+1=0.\n$$\n\nInterleaving yields\n$$\nc=(c_{1}^{(1)},c_{1}^{(2)},c_{2}^{(1)},c_{2}^{(2)},c_{3}^{(1)},c_{3}^{(2)},c_{4}^{(1)},c_{4}^{(2)})=(1,1,0,1,0,1,0,0),\n$$\nwhich corresponds to $11010100$, i.e., option C.", "answer": "$$\\boxed{C}$$", "id": "1614381"}, {"introduction": "After mastering the forward process of encoding, a powerful way to deepen your understanding is to work backward. In this problem [@problem_id:1614397], you are given the sequence of states and outputs from an encoder and tasked with reconstructing the original input message. This 'reverse engineering' exercise is crucial because it mirrors the core logic of a decoder, forcing you to think critically about the unique relationship between the input sequence and the path it carves through the encoder's state trellis.", "problem": "Consider a rate $R=1/2$ convolutional encoder with a constraint length of $K=3$. The encoder's connections are defined by the generator polynomials $g^{(1)}(D) = 1+D+D^2$ and $g^{(2)}(D) = 1+D^2$. At each time step $i$, a single input bit $m_i$ enters the encoder, and two output bits, $c_i^{(1)}$ and $c_i^{(2)}$, are produced. The encoding equations are $c_i^{(1)} = m_i + m_{i-1} + m_{i-2}$ and $c_i^{(2)} = m_i + m_{i-2}$, where all additions are performed modulo-2.\n\nThe state of the encoder at time step $i$, denoted $S_i$, is defined by the contents of its two memory elements before the input bit $m_i$ is processed, i.e., $S_i = (m_{i-1}, m_{i-2})$. The encoder is initialized in the all-zero state, meaning $S_1 = (m_0, m_{-1}) = (0,0)$.\n\nAn information message consisting of a sequence of $L=4$ bits, $M = (m_1, m_2, m_3, m_4)$, is fed into the encoder. To properly terminate the encoding process and return the encoder to the all-zero state, two zero-bits are appended to the message. This creates a total input sequence of length 6.\n\nDuring the encoding of this 6-bit sequence, the resulting sequence of encoder states is observed to be:\n$S_1$ to $S_6$: $((0,0), (1,0), (1,1), (0,1), (1,0), (0,1))$\n\nThe corresponding sequence of 2-bit outputs is:\n$C_1$ to $C_6$: $((1,1), (0,1), (0,1), (0,0), (1,0), (1,1))$\n\nBased on this information, determine the original 4-bit information message $M = (m_1, m_2, m_3, m_4)$.\n\nA. (1, 1, 0, 1)\n\nB. (1, 0, 1, 0)\n\nC. (1, 1, 1, 0)\n\nD. (0, 1, 0, 1)\n\nE. (1, 0, 1, 1)", "solution": "The encoder has memory of length $K=3$, so the state at time $i$ is $S_{i}=(m_{i-1},m_{i-2})$. After processing $m_{i}$, the next state is\n$$\nS_{i+1}=(m_{i},m_{i-1}).\n$$\nThe encoder is initialized with $S_{1}=(m_{0},m_{-1})=(0,0)$, and two zero tail bits are appended so that $m_{5}=0$ and $m_{6}=0$ to terminate in the all-zero state.\n\nFrom the given state sequence $S_{1}$ to $S_{6}$:\n- $S_{1}=(0,0)$ implies $m_{0}=0$, $m_{-1}=0$.\n- $S_{2}=(1,0)=(m_{1},m_{0})$ gives $m_{1}=1$.\n- $S_{3}=(1,1)=(m_{2},m_{1})$ gives $m_{2}=1$.\n- $S_{4}=(0,1)=(m_{3},m_{2})$ gives $m_{3}=0$.\n- $S_{5}=(1,0)=(m_{4},m_{3})$ gives $m_{4}=1$.\n- $S_{6}=(0,1)=(m_{5},m_{4})$ gives $m_{5}=0$ (consistent with tail) and confirms $m_{4}=1$.\n\nThus the information message is $M=(m_{1},m_{2},m_{3},m_{4})=(1,1,0,1)$.\n\nConsistency check with the output equations $c_{i}^{(1)}=m_{i}+m_{i-1}+m_{i-2}$ and $c_{i}^{(2)}=m_{i}+m_{i-2}$ (modulo-2), using $(m_{-1},m_{0},m_{1},m_{2},m_{3},m_{4},m_{5},m_{6})=(0,0,1,1,0,1,0,0)$:\n- $i=1$: $c_{1}^{(1)}=1+0+0=1$, $c_{1}^{(2)}=1+0=1$ gives $(1,1)$.\n- $i=2$: $c_{2}^{(1)}=1+1+0=0$, $c_{2}^{(2)}=1+0=1$ gives $(0,1)$.\n- $i=3$: $c_{3}^{(1)}=0+1+1=0$, $c_{3}^{(2)}=0+1=1$ gives $(0,1)$.\n- $i=4$: $c_{4}^{(1)}=1+0+1=0$, $c_{4}^{(2)}=1+1=0$ gives $(0,0)$.\n- $i=5$: $c_{5}^{(1)}=0+1+0=1$, $c_{5}^{(2)}=0+0=0$ gives $(1,0)$.\n- $i=6$: $c_{6}^{(1)}=0+0+1=1$, $c_{6}^{(2)}=0+1=1$ gives $(1,1)$.\n\nThese match the given output sequence, confirming $M=(1,1,0,1)$, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1614397"}, {"introduction": "Not all convolutional codes are created equal; some offer much better protection against errors than others. The key performance metric is the \"free distance\" ($d_{\\text{free}}$), which quantifies the code's inherent error-correcting capability. In this practical design comparison [@problem_id:1614368], you will analyze two different encoder designs by calculating their respective free distances, allowing you to determine which one offers superior performance.", "problem": "In the design of a digital communication system, two engineers have proposed different convolutional encoders for forward error correction. Both encoders have a rate of $R=1/2$ and a memory of $\\nu=2$. All arithmetic is performed over the binary field $\\mathrm{GF}(2)$.\n\nThe state of the encoder at time $t$ is determined by the previous two message bits, $s_t=(m_{t-1}, m_{t-2})$. The output at time $t$, a pair of bits $(c_t^{(1)}, c_t^{(2)})$, is generated by convolving the input message sequence $m = (m_0, m_1, m_2, \\dots)$ with the encoder's generator vectors.\n\nThe two proposed designs are:\n\n**Encoder A:**\n- Generator vector for the first output bit: $g_A^{(1)} = (1, 1, 1)$\n- Generator vector for the second output bit: $g_A^{(2)} = (1, 0, 1)$\n- The output bits are calculated as $c_t^{(1)} = m_t + m_{t-1} + m_{t-2}$ and $c_t^{(2)} = m_t + m_{t-2}$.\n\n**Encoder B:**\n- Generator vector for the first output bit: $g_B^{(1)} = (1, 1, 0)$\n- Generator vector for the second output bit: $g_B^{(2)} = (1, 1, 1)$\n- The output bits are calculated as $c_t^{(1)} = m_t + m_{t-1}$ and $c_t^{(2)} = m_t + m_{t-1} + m_{t-2}$.\n\nThe error-correction capability of a convolutional code is primarily determined by its free distance, $d_{\\text{free}}$, which is defined as the minimum Hamming weight of any non-zero codeword. A higher free distance indicates a more robust code.\n\nYour task is to evaluate the two designs. Calculate the free distance for each encoder, $d_{\\text{free, A}}$ and $d_{\\text{free, B}}$, and determine which design is superior. Select the correct statement from the options below.\n\nA. $d_{\\text{free, A}} = 4$, $d_{\\text{free, B}} = 5$; Encoder B is superior.\n\nB. $d_{\\text{free, A}} = 5$, $d_{\\text{free, B}} = 4$; Encoder A is superior.\n\nC. $d_{\\text{free, A}} = 5$, $d_{\\text{free, B}} = 5$; The encoders have equivalent performance.\n\nD. $d_{\\text{free, A}} = 6$, $d_{\\text{free, B}} = 5$; Encoder A is superior.\n\nE. $d_{\\text{free, A}} = 5$, $d_{\\text{free, B}} = 6$; Encoder B is superior.", "solution": "We work over $\\mathrm{GF}(2)$, so all additions are modulo $2$. The free distance $d_{\\text{free}}$ is the minimum Hamming weight of any non-zero codeword. For a rate-$\\frac{1}{2}$, memory-$\\nu=2$ encoder, the trellis state is $s_{t}=(m_{t-1},m_{t-2})$. To find $d_{\\text{free}}$, we consider paths that start in the all-zero state, diverge at the first nonzero input (w.l.o.g. at $t=0$ with $m_{0}=1$), and remerge to the all-zero state as soon as possible (which requires two trailing zeros, because $\\nu=2$). We then minimize the total output Hamming weight along the divergeâ€“remerge path.\n\nEncoder A has $g_{A}^{(1)}=(1,1,1)$ and $g_{A}^{(2)}=(1,0,1)$, so\n$$\nc_{t}^{(1)}=m_{t}+m_{t-1}+m_{t-2},\\qquad c_{t}^{(2)}=m_{t}+m_{t-2}.\n$$\nStart in state $(0,0)$ and let $m_{0}=1$. With $m_{-1}=m_{-2}=0$:\n- At $t=0$: $c_{0}^{(1)}=1$, $c_{0}^{(2)}=1$, so the branch weight is $2$.\n- At $t=1$, with a generic $m_{1}\\in\\{0,1\\}$ and $(m_{0},m_{-1})=(1,0)$:\n$$\nc_{1}^{(1)}=m_{1}+1+0=m_{1}+1,\\qquad c_{1}^{(2)}=m_{1}+0=m_{1}.\n$$\nIf both $c_{1}^{(1)}=0$ and $c_{1}^{(2)}=0$, then $m_{1}+1=0$ and $m_{1}=0$, which is impossible. Therefore the branch weight at $t=1$ is at least $1$. The minimum is attained by $m_{1}=0$, which gives $(c_{1}^{(1)},c_{1}^{(2)})=(1,0)$ of weight $1$.\n- To remerge to $(0,0)$ at the earliest time $t=3$, we must set $(m_{2},m_{1})=(0,0)$. Then at $t=2$ with $(m_{2},m_{1},m_{0})=(0,0,1)$ we get\n$$\nc_{2}^{(1)}=0+0+1=1,\\qquad c_{2}^{(2)}=0+1=1,\n$$\nso the branch weight is $2$.\n\nThus the minimum total weight along an earliest remerging path is $2+1+2=5$, achieved by the input $(m_{0},m_{1},m_{2})=(1,0,0)$. Hence $d_{\\text{free,A}}=5$.\n\nEncoder B has $g_{B}^{(1)}=(1,1,0)$ and $g_{B}^{(2)}=(1,1,1)$, so\n$$\nc_{t}^{(1)}=m_{t}+m_{t-1},\\qquad c_{t}^{(2)}=m_{t}+m_{t-1}+m_{t-2}.\n$$\nStart in state $(0,0)$ and let $m_{0}=1$:\n- At $t=0$: $c_{0}^{(1)}=1$, $c_{0}^{(2)}=1$, branch weight $2$.\n- At $t=1$ with generic $m_{1}$ and $(m_{0},m_{-1})=(1,0)$:\n$$\nc_{1}^{(1)}=m_{1}+1,\\qquad c_{1}^{(2)}=m_{1}+1+0=m_{1}+1.\n$$\nChoosing $m_{1}=1$ makes $(c_{1}^{(1)},c_{1}^{(2)})=(0,0)$, i.e., branch weight $0$ and state $(m_{1},m_{0})=(1,1)$.\n- To remerge earliest at $t=4$, set $m_{2}=0$ and $m_{3}=0$. Then\nat $t=2$ with $(m_{2},m_{1},m_{0})=(0,1,1)$:\n$$\nc_{2}^{(1)}=0+1=1,\\qquad c_{2}^{(2)}=0+1+1=0,\n$$\nbranch weight $1$;\nat $t=3$ with $(m_{3},m_{2},m_{1})=(0,0,1)$:\n$$\nc_{3}^{(1)}=0+0=0,\\qquad c_{3}^{(2)}=0+0+1=1,\n$$\nbranch weight $1$.\n\nTherefore the total weight along this earliest remerging path is $2+0+1+1=4$, achieved by input $(m_{0},m_{1},m_{2},m_{3})=(1,1,0,0)$. It is not possible to reduce the sum below $4$: the first branch has weight $2$, the second can be $0$ by choosing $m_{1}=1$, and (given the state $(1,1)$) the two subsequent branches necessary to remerge cannot both be $0$ simultaneously. Hence $d_{\\text{free,B}}=4$.\n\nComparing, $d_{\\text{free,A}}=5$ and $d_{\\text{free,B}}=4$, so Encoder A is superior. The correct option is B.", "answer": "$$\\boxed{B}$$", "id": "1614368"}]}