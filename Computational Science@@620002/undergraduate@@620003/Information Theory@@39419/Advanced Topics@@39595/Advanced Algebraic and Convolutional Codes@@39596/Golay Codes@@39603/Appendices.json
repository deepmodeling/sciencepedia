{"hands_on_practices": [{"introduction": "The first step in protecting information with a linear block code is encoding the message into a longer, redundant codeword. This practice focuses on the mechanics of this crucial transformation using the binary Golay code $G_{23}$ [@problem_id:1627030]. By performing the encoding yourself, you will gain a concrete understanding of how a generator matrix $G$ systematically adds parity bits to your original message, all while working within the rules of arithmetic over the binary field $\\mathbb{F}_2$.", "problem": "In digital communications, the binary Golay code $G_{23}$ is a well-known perfect error-correcting code used to protect data from errors. It is a $(23, 12)$ linear block code, which means it encodes a 12-bit message into a 23-bit codeword.\n\nThe encoding process can be described by matrix multiplication using a generator matrix $G$. A standard generator matrix for $G_{23}$ is given in systematic form as $G = [I_{12} | A]$, where all arithmetic is performed in the finite field GF(2) (i.e., addition is XOR, and multiplication is AND).\n- $I_{12}$ is the $12 \\times 12$ identity matrix.\n- $A$ is a $12 \\times 11$ matrix that generates the parity bits. Its structure is as follows (using 0-based indexing for rows and columns):\n    - The first row, $A_{0}$, is an all-ones vector: $A_{0} = (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)$.\n    - The subsequent 11 rows, from $A_{1}$ to $A_{11}$, form an $11 \\times 11$ circulant matrix. A circulant matrix is one where each row is a cyclic shift of the row above it. The first row of this circulant submatrix, which corresponds to row $A_1$, is the vector $s = (0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1)$. Thus, $A_2$ is a right cyclic shift of $A_1$, $A_3$ is a right cyclic shift of $A_2$, and so on.\n\nYou are given the 12-bit message vector $m = (1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1)$.\n\nCalculate the corresponding 23-bit codeword $c$ by computing the matrix-vector product $c = mG$. Your final answer should be a single sequence of 23 binary digits without any spaces or commas.", "solution": "We work over GF(2), so addition is XOR and multiplication is AND. With the systematic generator matrix $G=[I_{12}\\,|\\,A]$, the codeword for message $m$ is $c=mG=(m,\\;p)$ where the parity part is $p=mA$.\n\nThe given message is $m=(1,0,1,1,0,0,1,1,0,1,0,1)$, so the indices with $m_{i}=1$ (using $0$-based indexing) are $i\\in\\{0,2,3,6,7,9,11\\}$. Therefore,\n$$\np \\;=\\; \\bigoplus_{i\\in\\{0,2,3,6,7,9,11\\}} A_{i}.\n$$\n\nThe rows of $A$ are defined as follows:\n- $A_{0}=(1,1,1,1,1,1,1,1,1,1,1)$.\n- The $11\\times 11$ circulant submatrix has first row $A_{1}=s$ with\n$$\ns=(0,1,1,0,1,1,1,0,0,0,1),\n$$\nand for $k=2,\\dots,11$, $A_{k}$ is the right cyclic shift of $A_{k-1}$. Explicitly,\n$$\n\\begin{aligned}\nA_{1}&=(0,1,1,0,1,1,1,0,0,0,1),\\\\\nA_{2}&=(1,0,1,1,0,1,1,1,0,0,0),\\\\\nA_{3}&=(0,1,0,1,1,0,1,1,1,0,0),\\\\\nA_{4}&=(0,0,1,0,1,1,0,1,1,1,0),\\\\\nA_{5}&=(0,0,0,1,0,1,1,0,1,1,1),\\\\\nA_{6}&=(1,0,0,0,1,0,1,1,0,1,1),\\\\\nA_{7}&=(1,1,0,0,0,1,0,1,1,0,1),\\\\\nA_{8}&=(1,1,1,0,0,0,1,0,1,1,0),\\\\\nA_{9}&=(0,1,1,1,0,0,0,1,0,1,1),\\\\\nA_{10}&=(1,0,1,1,1,0,0,0,1,0,1),\\\\\nA_{11}&=(1,1,0,1,1,1,0,0,0,1,0).\n\\end{aligned}\n$$\n\nHence,\n$$\np \\;=\\; A_{0}\\oplus A_{2}\\oplus A_{3}\\oplus A_{6}\\oplus A_{7}\\oplus A_{9}\\oplus A_{11}\n\\;=\\; (1,1,1,1,0,0,0,0,1,0,0).\n$$\n\nFinally, the codeword is the concatenation of $m$ and $p$:\n$$\nc \\;=\\; (1,0,1,1,0,0,1,1,0,1,0,1,\\,1,1,1,1,0,0,0,0,1,0,0).\n$$\n\nWriting this as a single sequence of $23$ binary digits without spaces or commas gives $10110011010111110000100$.", "answer": "$$\\boxed{10110011010111110000100}$$", "id": "1627030"}, {"introduction": "Once a codeword is transmitted through a noisy channel, the receiver must determine if it arrived intact, a process known as error detection. This is achieved by computing a 'syndrome', which acts as a unique signature for certain error patterns [@problem_id:1627048]. This exercise challenges you to calculate the syndrome for a received vector using the parity-check matrix of the ternary Golay code $G_{11}$, providing essential practice with error detection fundamentals and arithmetic over the finite field $\\mathbb{F}_3$.", "problem": "In a digital communication system, information is encoded using the perfect ternary Golay code, denoted as $G_{11}$. This is a linear block code of length $n=11$ over the finite field $GF(3) = \\{0, 1, 2\\}$, where all arithmetic operations are performed modulo 3. The code is defined by its parity-check matrix $H$. Any valid codeword $c$ satisfies the equation $Hc^T = 0$, where the result is a zero vector and $T$ denotes the transpose.\n\nThe parity-check matrix for $G_{11}$ is given by:\n$$\nH = \\begin{pmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\\n0 & 1 & 2 & 1 & 2 & 2 & 2 & 1 & 0 & 0 & 0 \\\\\n0 & 1 & 1 & 2 & 2 & 1 & 2 & 0 & 1 & 0 & 0 \\\\\n0 & 1 & 2 & 2 & 1 & 2 & 1 & 0 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 1\n\\end{pmatrix}\n$$\nA vector is transmitted through a noisy channel, and the received vector is $r = (1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1)$.\n\nTo detect potential errors, the receiver computes the syndrome of the received vector, which is defined as $s = Hr^T$. Calculate the syndrome vector $s$. Express your answer as a row vector of 5 elements.", "solution": "We work over $GF(3)$, so all arithmetic is performed modulo $3$. The syndrome is defined as $s = H r^{T}$, where each component is\n$$\ns_{i} = \\sum_{j=1}^{11} H_{ij} r_{j} \\pmod{3}.\n$$\nFor the received vector $r = (1,0,1,0,1,0,1,0,1,0,1)$, we have $r_{j} = 1$ for odd $j \\in \\{1,3,5,7,9,11\\}$ and $r_{j} = 0$ for even $j$. Therefore,\n$$\ns_{i} \\equiv \\sum_{j \\in \\{1,3,5,7,9,11\\}} H_{ij} \\pmod{3}.\n$$\n\nCompute each component:\n- For row 1: $H_{1j} = 1$ for all $j$, so\n$$\ns_{1} \\equiv 1+1+1+1+1+1 = 6 \\equiv 0 \\pmod{3}.\n$$\n- For row 2: $(H_{2,1},H_{2,3},H_{2,5},H_{2,7},H_{2,9},H_{2,11}) = (0,2,2,2,0,0)$, so\n$$\ns_{2} \\equiv 0+2+2+2+0+0 = 6 \\equiv 0 \\pmod{3}.\n$$\n- For row 3: $(H_{3,1},H_{3,3},H_{3,5},H_{3,7},H_{3,9},H_{3,11}) = (0,1,2,2,1,0)$, so\n$$\ns_{3} \\equiv 0+1+2+2+1+0 = 6 \\equiv 0 \\pmod{3}.\n$$\n- For row 4: $(H_{4,1},H_{4,3},H_{4,5},H_{4,7},H_{4,9},H_{4,11}) = (0,2,1,1,0,0)$, so\n$$\ns_{4} \\equiv 0+2+1+1+0+0 = 4 \\equiv 1 \\pmod{3}.\n$$\n- For row 5: $(H_{5,1},H_{5,3},H_{5,5},H_{5,7},H_{5,9},H_{5,11}) = (0,1,1,1,0,1)$, so\n$$\ns_{5} \\equiv 0+1+1+1+0+1 = 4 \\equiv 1 \\pmod{3}.\n$$\n\nThus the syndrome vector, expressed as a row vector, is\n$$\n(0,\\,0,\\,0,\\,1,\\,1).\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0 & 0 & 0 & 1 & 1\\end{pmatrix}}$$", "id": "1627048"}, {"introduction": "Error detection isn't always about complex matrix multiplications; sometimes, it's about appreciating a code's elegant properties. The extended binary Golay code $G_{24}$ has a remarkable structural property related to the Hamming weight of its codewords [@problem_id:1627075]. This exercise allows you to apply this high-level concept as a simple yet powerful validity check, demonstrating how abstract mathematical properties can have direct and practical consequences in identifying corrupted data.", "problem": "In digital communications, error-correcting codes are used to detect and correct errors that occur during transmission over noisy channels. One of the most remarkable codes is the extended binary Golay code, denoted as $G_{24}$. It is a linear block code consisting of a set of binary vectors of length 24, which are called codewords.\n\nFor the purposes of this problem, you are given the following two fundamental properties of the $G_{24}$ code:\n1.  The Hamming weight of a binary vector is defined as the number of '1's in the vector.\n2.  The Hamming weight of every codeword in $G_{24}$ is an integer multiple of 4.\n\nSuppose an engineer is monitoring a communication link that uses the $G_{24}$ code. A binary vector $\\mathbf{r}$ of length 24 is received. Upon inspection, the engineer computes the Hamming weight of $\\mathbf{r}$ and finds it to be 19.\n\nBased solely on the information provided, which of the following statements represents a necessary conclusion?\n\nA. The vector $\\mathbf{r}$ is a valid codeword that was transmitted without errors.\n\nB. The vector $\\mathbf{r}$ is not a valid codeword, but it must be the result of a single bit-flip error on some valid codeword from $G_{24}$.\n\nC. The vector $\\mathbf{r}$ cannot be a valid codeword in $G_{24}$.\n\nD. It is impossible to draw any conclusion about $\\mathbf{r}$ without comparing it to the full list of all $2^{12}$ codewords in $G_{24}$.\n\nE. The vector $\\mathbf{r}$ is a valid codeword, but its Hamming weight was calculated incorrectly.", "solution": "Let $w_{H}(\\mathbf{x})$ denote the Hamming weight of a binary vector $\\mathbf{x}$. The given property of $G_{24}$ states that for every codeword $\\mathbf{c} \\in G_{24}$, the Hamming weight satisfies\n$$\nw_{H}(\\mathbf{c}) \\in \\{0,4,8,12,16,20,24\\} = 4\\mathbb{Z}.\n$$\nThe received vector $\\mathbf{r}$ has $w_{H}(\\mathbf{r})=19$. Compute its remainder modulo $4$:\n$$\n19 = 4 \\cdot 4 + 3 \\quad \\Rightarrow \\quad 19 \\notin 4\\mathbb{Z}.\n$$\nTherefore $w_{H}(\\mathbf{r})$ is not a multiple of $4$, which by the stated property implies $\\mathbf{r} \\notin G_{24}$. Hence it is a necessary conclusion that $\\mathbf{r}$ cannot be a valid codeword in $G_{24}$.\n\nChecking the options:\n- A is false because it asserts $\\mathbf{r}$ is a valid codeword, contradicting $w_{H}(\\mathbf{r}) \\notin 4\\mathbb{Z}$.\n- B is not necessary from the given information; while a single-bit flip changes weight by $\\pm 1$ so a parent codeword would have weight $18$ or $20$, the problem does not guarantee the existence of codewords of those weights.\n- D is false because we can conclude $\\mathbf{r} \\notin G_{24}$ without enumerating codewords.\n- E is unwarranted; there is no basis to assert a miscalculation of weight.\n\nThus the necessary conclusion is C.", "answer": "$$\\boxed{C}$$", "id": "1627075"}]}