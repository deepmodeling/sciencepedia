{"hands_on_practices": [{"introduction": "The state diagram is the fundamental roadmap for a convolutional encoder, visually representing all possible transitions and their corresponding outputs. Being able to interpret this diagram is the first step toward understanding how an encoder processes an information sequence. This exercise [@problem_id:1660291] tests your ability to read such a diagram by asking you to determine the encoder's output and next state for a specific input, given its current state.", "problem": "A rate $R=1/2$ convolutional encoder is defined by the transitions of its state diagram. The encoder has four possible states, represented by two-bit strings: state A corresponds to '00', state B to '01', state C to '10', and state D to '11'. At any given time step, the encoder accepts a single input bit ($u_t$) and, based on its current state ($s_t$), produces a two-bit output ($v_t$) and transitions to a new state ($s_{t+1}$).\n\nThe complete set of state transitions for this encoder is described as follows:\n- From state A ('00'): an input of 0 leads to state A ('00') with an output of '00', and an input of 1 leads to state C ('10') with an output of '11'.\n- From state B ('01'): an input of 0 leads to state A ('00') with an output of '11', and an input of 1 leads to state C ('10') with an output of '00'.\n- From state C ('10'): an input of 0 leads to state B ('01') with an output of '10', and an input of 1 leads to state D ('11') with an output of '01'.\n- From state D ('11'): an input of 0 leads to state B ('01') with an output of '01', and an input of 1 leads to state D ('11') with an output of '10'.\n\nIf the encoder is currently in state '10' and receives an input bit of 1, what are the resulting output bits and the next state? Choose the correct option from the list below.\n\nA. Next state: '01', Output: '10'\n\nB. Next state: '11', Output: '01'\n\nC. Next state: '10', Output: '11'\n\nD. Next state: '00', Output: '00'\n\nE. Next state: '11', Output: '10'", "solution": "We are given the state-transition rules of a rate $R=\\frac{1}{2}$ convolutional encoder via its state diagram. The current state is C, which corresponds to the two-bit memory state '10'. The input bit is $u_{t}=1$. By the problemâ€™s specified transitions:\n- From state C ('10'): input $0$ leads to next state B ('01') with output '10'.\n- From state C ('10'): input $1$ leads to next state D ('11') with output '01'.\n\nWe apply the relevant rule for the case $s_{t}=\\text{C ('10')}$ and $u_{t}=1$. Therefore, the next state is D ('11') and the encoder output is the two-bit string '01'. Comparing with the provided options, this corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1660291"}, {"introduction": "While a state diagram shows single transitions, a trellis diagram unfolds these transitions over time, illustrating the specific paths an encoder can take. This practice [@problem_id:1660233] asks you to trace a path for a given input sequence, effectively simulating the encoding process over multiple time steps. By calculating the outputs at each step, you'll gain a concrete understanding of how a short information stream is transformed into a longer, coded sequence.", "problem": "A rate $R=1/2$ convolutional encoder is constructed using a shift register with two memory elements (D flip-flops). The state of the encoder at any time $k$ can be represented by the ordered pair of bits stored in these registers, $S_k = (M_{1,k}, M_{2,k})$. At each time step, a single input bit $u_k$ enters the encoder. Two output bits, $v_k^{(1)}$ and $v_k^{(2)}$, are generated based on the current input and the current state. The logic for the output generation is defined by the following equations, where all additions are performed modulo-2 (XOR operation):\n\n$$v_k^{(1)} = u_k + M_{1,k} + M_{2,k}$$\n$$v_k^{(2)} = u_k + M_{2,k}$$\n\nAfter the outputs are computed, the state of the registers is updated for the next time step, $k+1$. The new bit $u_k$ is shifted into the first register, and the bit from the first register is shifted into the second. That is, the next state is $S_{k+1} = (u_k, M_{1,k})$.\n\nSuppose the encoder is not in the conventional all-zero starting state. Instead, its initial state at time $k=1$ is $S_1 = (0, 1)$. The encoder is then fed the two-bit input sequence '10' (meaning $u_1 = 1$ and $u_2 = 0$).\n\nWhat is the resulting 4-bit output sequence, formed by concatenating the first output block $(v_1^{(1)}, v_1^{(2)})$ and the second output block $(v_2^{(1)}, v_2^{(2)})$?\n\nSelect the correct sequence from the options below.\n\nA. 0010\n\nB. 1110\n\nC. 0101\n\nD. 0001\n\nE. 1111", "solution": "We are given a rate $R=\\frac{1}{2}$ convolutional encoder with state $S_{k}=(M_{1,k},M_{2,k})$, outputs\n$$v_{k}^{(1)}=u_{k}+M_{1,k}+M_{2,k},\\quad v_{k}^{(2)}=u_{k}+M_{2,k},$$\nwith all additions modulo-2, and state update\n$$S_{k+1}=(u_{k},M_{1,k}).$$\nThe initial state is $S_{1}=(0,1)$ and the inputs are $u_{1}=1$, $u_{2}=0$.\n\nStep at $k=1$:\nGiven $S_{1}=(M_{1,1},M_{2,1})=(0,1)$ and $u_{1}=1$,\n$$v_{1}^{(1)}=u_{1}+M_{1,1}+M_{2,1}=1+0+1=0,$$\n$$v_{1}^{(2)}=u_{1}+M_{2,1}=1+1=0.$$\nUpdate the state:\n$$S_{2}=(u_{1},M_{1,1})=(1,0).$$\n\nStep at $k=2$:\nGiven $S_{2}=(M_{1,2},M_{2,2})=(1,0)$ and $u_{2}=0$,\n$$v_{2}^{(1)}=u_{2}+M_{1,2}+M_{2,2}=0+1+0=1,$$\n$$v_{2}^{(2)}=u_{2}+M_{2,2}=0+0=0.$$\n\nConcatenating $(v_{1}^{(1)},v_{1}^{(2)})=(0,0)$ and $(v_{2}^{(1)},v_{2}^{(2)})=(1,0)$ yields the 4-bit sequence $0010$, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1660233"}, {"introduction": "In practical communication systems, it's often essential to reset the encoder to a known state after transmitting a block of data. This exercise [@problem_id:1660254] explores this concept of \"termination\" for a recursive convolutional encoder, a type widely used in modern standards. You will determine the specific input \"tail bits\" needed to guide the encoder from an arbitrary state back to the all-zero state, a critical procedure for error containment and packet synchronization.", "problem": "In modern digital communication systems, recursive convolutional codes are often used due to their excellent performance characteristics. A crucial operation is to terminate a block of data by driving the encoder's memory back to the all-zero state. This ensures that a subsequent data block starts from a known, clean state.\n\nConsider a specific rate 1/1 recursive convolutional encoder with three memory elements. The state of the encoder at any time is represented by a binary triple $S = (s_2, s_1, s_0)$. The encoder processes a single input bit, $u$, at each time step to produce a new state. The state update mechanism is as follows:\n1. A temporary feedback bit, $a$, is calculated based on the input $u$ and the current state bits $s_2$ and $s_0$. The relationship is given by $a = u \\oplus s_2 \\oplus s_0$, where $\\oplus$ denotes addition modulo 2 (the XOR operation).\n2. The next state of the encoder, $S' = (s'_2, s'_1, s'_0)$, is determined by shifting the feedback bit $a$ into the register: $s'_2 = a$, $s'_1 = s_2$, and $s'_0 = s_1$.\n\nSuppose that after encoding a long data sequence, the encoder is left in the state $S_{initial} = (1, 1, 1)$. To prepare for the next transmission, a special termination sequence of input bits must be sent to drive the encoder to the all-zero state, $S_{final} = (0, 0, 0)$.\n\nWhat is the shortest sequence of input bits that will transition the encoder from state $(1, 1, 1)$ to state $(0, 0, 0)$?\n\nA. 110\n\nB. 011\n\nC. 101\n\nD. 001\n\nE. 111", "solution": "Let the initial state be $S_{0}=(s_{2}^{(0)},s_{1}^{(0)},s_{0}^{(0)})=(1,1,1)$. For inputs $u_{0},u_{1},u_{2}$ applied at successive time instants, the feedback at time $t$ is $a_{t}=u_{t}\\oplus s_{2}^{(t)}\\oplus s_{0}^{(t)}$, and the next state is given by $s_{2}^{(t+1)}=a_{t}$, $s_{1}^{(t+1)}=s_{2}^{(t)}$, $s_{0}^{(t+1)}=s_{1}^{(t)}$.\n\nStep $t=0$ with input $u_{0}$:\n$$\na_{0}=u_{0}\\oplus 1\\oplus 1=u_{0},\\quad S_{1}=(s_{2}^{(1)},s_{1}^{(1)},s_{0}^{(1)})=(u_{0},1,1).\n$$\n\nStep $t=1$ with input $u_{1}$:\n$$\na_{1}=u_{1}\\oplus s_{2}^{(1)}\\oplus s_{0}^{(1)}=u_{1}\\oplus u_{0}\\oplus 1,\n$$\n$$\nS_{2}=(s_{2}^{(2)},s_{1}^{(2)},s_{0}^{(2)})=(u_{1}\\oplus u_{0}\\oplus 1,\\;u_{0},\\;1).\n$$\n\nStep $t=2$ with input $u_{2}$:\n$$\na_{2}=u_{2}\\oplus s_{2}^{(2)}\\oplus s_{0}^{(2)}=u_{2}\\oplus(u_{1}\\oplus u_{0}\\oplus 1)\\oplus 1=u_{2}\\oplus u_{1}\\oplus u_{0},\n$$\n$$\nS_{3}=(s_{2}^{(3)},s_{1}^{(3)},s_{0}^{(3)})=(u_{2}\\oplus u_{1}\\oplus u_{0},\\;u_{1}\\oplus u_{0}\\oplus 1,\\;u_{0}).\n$$\n\nTo reach $S_{3}=(0,0,0)$, solve the system over modulo-2 arithmetic:\n$$\nu_{2}\\oplus u_{1}\\oplus u_{0}=0,\\quad u_{1}\\oplus u_{0}\\oplus 1=0,\\quad u_{0}=0.\n$$\nFrom $u_{0}=0$, the second equation gives $u_{1}\\oplus 1=0$ hence $u_{1}=1$. The first then gives $u_{2}\\oplus 1=0$ hence $u_{2}=1$. Therefore the unique 3-bit sequence is $(u_{0},u_{1},u_{2})=(0,1,1)$, i.e., 011.\n\nIt is impossible to terminate in fewer than 3 steps: after two steps $S_{2}=(u_{1}\\oplus u_{0}\\oplus 1,\\;u_{0},\\;1)$ always has $s_{0}^{(2)}=1\\neq 0$, so $S_{2}\\neq(0,0,0)$. Hence the shortest sequence is 011, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1660254"}]}