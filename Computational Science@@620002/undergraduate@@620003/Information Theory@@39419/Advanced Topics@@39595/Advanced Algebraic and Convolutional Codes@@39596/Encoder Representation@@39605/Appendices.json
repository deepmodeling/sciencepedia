{"hands_on_practices": [{"introduction": "The primary purpose of an efficient encoder is to represent information compactly, but this is useless if the original message cannot be perfectly recovered. This first exercise focuses on the fundamental process of decoding. By working with a prefix code, you will see firsthand how its unique structure prevents ambiguity and allows for a simple, instantaneous reconstruction of the source data from a continuous stream of bits, a cornerstone skill for understanding data transmission and compression [@problem_id:1619443].", "problem": "A deep-space probe uses a variable-length binary encoding scheme to compress data from four distinct scientific instruments before transmitting it back to Earth. The instruments and their corresponding binary codewords are as follows:\n\n- Instrument A (measures Alpha particle flux): `0`\n- Instrument B (measures Boron isotope ratios): `10`\n- Instrument C (measures Carbon-based molecule presence): `110`\n- Instrument D (measures Dust particle density): `111`\n\nThe probe transmits a continuous bit stream representing a sequence of measurements. A ground station receives the following stream: `101100111`. Assuming no transmission errors, what is the sequence of instrument readings that the ground station will reconstruct?\n\nA. `BCAD`\n\nB. `BACD`\n\nC. `ADBC`\n\nD. The bit stream contains an invalid codeword.\n\nE. `B C A A A`", "solution": "We have a variable-length, prefix-free code with the mapping: A: 0, B: 10, C: 110, D: 111. Because the code is prefix-free, the bit stream can be decoded instantaneously by scanning from left to right and at each step taking the shortest prefix that matches a codeword.\n\nStart with the received stream 101100111.\n\nStep 1: Read the first bit 1; since no codeword is 1 alone, read the next bit to form 10, which matches B. Record B and remove the prefix 10. Remaining stream: 1100111.\n\nStep 2: Read 1 then 11; neither 1 nor 11 is a complete codeword. Read the next bit to form 110, which matches C. Record C and remove 110. Remaining stream: 0111.\n\nStep 3: The first bit 0 matches A. Record A and remove 0. Remaining stream: 111.\n\nStep 4: The next three bits 111 match D. Record D and remove 111. Remaining stream is empty.\n\nThe reconstructed sequence is BCAD, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1619443"}, {"introduction": "Moving from using a code to designing one, we now explore what makes a code \"optimal.\" The foundational principle of efficient source coding is to assign shorter codewords to more frequent symbols. This thought experiment [@problem_id:1619430] invites you to analyze the outcome of a flawed algorithm that does the exact opposite. By calculating the average codeword length of this deliberately inefficient code, you will gain a more profound appreciation for the logic that underpins truly optimal methods like Huffman coding.", "problem": "Consider a discrete memoryless source with an alphabet of four symbols, $\\{S_1, S_2, S_3, S_4\\}$, having probabilities of occurrence $P(S_1)=0.5$, $P(S_2)=0.4$, $P(S_3)=0.05$, and $P(S_4)=0.05$. An engineer implements an algorithm to construct a binary prefix code for this source. The algorithm builds a code tree by iteratively merging nodes. At each step, it identifies the two nodes in the current set with the highest probabilities and combines them into a new parent node. The probability of this new node is the sum of the probabilities of its children. This process is repeated until all symbols are part of a single tree, with the root node having a total probability of 1.\n\nCalculate the average codeword length of the resulting code. Express your answer in bits per symbol.", "solution": "We are given a binary prefix-code construction algorithm that repeatedly merges the two current nodes with the highest probabilities, combining them into a parent whose probability is the sum of the two. This produces a full binary tree; the codeword length of each symbol equals its depth in the final tree (distance from the root), and the average codeword length is computed as $L=\\sum_{i}P(S_{i})\\,\\ell(S_{i})$.\n\nStart with the multiset of node probabilities:\n$$\\{0.5,\\,0.4,\\,0.05,\\,0.05\\}.$$\n\nStep 1 (merge the two highest): merge $0.5$ and $0.4$ to form a node of probability $0.9$.\nCurrent set:\n$$\\{0.9,\\,0.05,\\,0.05\\}.$$\nThis makes $S_{1}$ and $S_{2}$ siblings in a subtree, each currently at depth $1$ within that subtree.\n\nStep 2 (merge the two highest): merge $0.9$ and one of the $0.05$ nodes to form a node of probability $0.95$.\nCurrent set:\n$$\\{0.95,\\,0.05\\}.$$\nThis places the merged $0.05$ leaf at depth $1$ within this new subtree and the $\\{S_{1},S_{2}\\}$ subtree as its sibling; relative to the final root they will gain one more level in the next step.\n\nStep 3 (merge the two highest): merge $0.95$ and $0.05$ to form the root of probability $1$.\n\nFrom this construction, the resulting codeword lengths are determined by the number of merges affecting each symbol along the path to the root:\n- $S_{4}$ (the $0.05$ not merged until the last step) is attached only at the final merge, so $\\ell(S_{4})=1$.\n- The other $0.05$ (say $S_{3}$) was merged in step 2 and then again in step 3, so $\\ell(S_{3})=2$.\n- $S_{1}$ and $S_{2}$ were merged in step 1, then their parent was merged in step 2, and again in step 3, so $\\ell(S_{1})=\\ell(S_{2})=3$.\n\nTherefore the average codeword length is\n$$\nL \\;=\\; 0.5\\cdot 3 \\;+\\; 0.4\\cdot 3 \\;+\\; 0.05\\cdot 2 \\;+\\; 0.05\\cdot 1\n\\;=\\; 1.5 \\;+\\; 1.2 \\;+\\; 0.1 \\;+\\; 0.05\n\\;=\\; 2.85.\n$$\nAny tie-breaking between the two $0.05$ symbols only swaps their lengths $1$ and $2$, leaving the average unchanged.", "answer": "$$\\boxed{2.85}$$", "id": "1619430"}, {"introduction": "In practical applications, \"optimality\" often extends beyond minimizing the average number of bits per symbol. Transmission resources like energy or time can vary for different signals. This problem challenges you to generalize the concept of an optimal code by introducing non-uniform costs for the encoding symbols. You will need to adapt the greedy strategy learned from Huffman coding to minimize the total average transmission cost, reflecting a more realistic and versatile engineering challenge [@problem_id:1619389].", "problem": "A deep-space probe is designed to monitor four distinct types of astronomical phenomena, which we will label as symbols $S_1, S_2, S_3,$ and $S_4$. Long-term observations have shown that these phenomena occur with equal probability. To transmit its findings back to Earth, the probe uses a communication system based on two types of pulses: a short pulse, which has a transmission cost of 1 energy unit, and a long pulse, which has a transmission cost of 3 energy units.\n\nThe probe must encode the four symbols into sequences of these pulses. The set of sequences must form a prefix code, meaning no codeword can be the prefix of another. The cost of transmitting a symbol is the sum of the costs of the pulses in its corresponding codeword. Your task is to determine the design of an optimal prefix code that minimizes the average transmission cost per symbol.\n\nWhat is the minimum possible average transmission cost per symbol? Report your final answer as an exact decimal value.", "solution": "Let the two pulse types be letters of a binary code alphabet, with costs $c_{S}=1$ (short) and $c_{L}=3$ (long). A prefix code corresponds to a rooted binary tree where each edge to a child adds the respective pulse cost to the path, and each leaf corresponds to a codeword with cost equal to the sum of its edge costs. With four equiprobable symbols, the average transmission cost equals the sum of the four leaf costs divided by $4$. Hence we must minimize the sum of the four leaf costs.\n\nStart from the root as a single leaf of cost $0$. To reach a code with $4$ leaves, iteratively replace a leaf by its two children. If we expand a leaf of cost $c$ into its two children (costs $c+1$ and $c+3$), the total leaf-cost sum changes from $T$ to\n$$\nT' \\;=\\; T - c + (c+1) + (c+3) \\;=\\; T + c + 4.\n$$\nThus, at each step, to minimize the increase in the total cost we should expand the currently cheapest leaf. This greedy rule is optimal by an exchange argument: any deviation that expands a more expensive leaf instead would increase $T'$ by a larger amount.\n\nExecute the greedy construction until there are $4$ leaves:\n\n1) Start with one leaf: $\\{0\\}$.\nExpand $0 \\to \\{1,3\\}$. Leaves: costs $\\{1,3\\}$; sum $=4$.\n\n2) Expand cheapest leaf $1 \\to \\{2,4\\}$. Leaves: $\\{2,3,4\\}$; sum $=9$.\n\n3) Expand cheapest leaf $2 \\to \\{3,5\\}$. Leaves: $\\{3,3,4,5\\}$; sum $=15$.\n\nNow we have $4$ leaves with minimal possible total cost $15$, so the minimal average cost is\n$$\n\\frac{15}{4} \\;=\\; 3.75.\n$$\nOne can also confirm optimality by feasibility constraints: to beat $15$ we would need a total $\\leq 14$, for instance $\\{3,3,4,4\\}$. The only cost-$3$ leaves are $L$ and $SSS$, and taking both forces excluding $LS$ and $SSSS$ by the prefix constraint, leaving at most one cost-$4$ leaf ($SL$), with the fourth leaf at least cost $5$ (e.g., $SSL$), yielding the sum $15$. Hence no sum below $15$ is achievable, and the constructed code is optimal. Therefore the minimum possible average transmission cost per symbol is $3.75$.", "answer": "$$\\boxed{3.75}$$", "id": "1619389"}]}