{"hands_on_practices": [{"introduction": "The first step in any privacy amplification protocol is to accurately assess the amount of randomness present in the raw, partially compromised data. Min-entropy, denoted as $H_{\\infty}(X)$, serves as our most conservative measure, quantifying the uncertainty from the perspective of an attacker making a single best guess. This practice problem [@problem_id:1647791] provides a hands-on opportunity to calculate the min-entropy for a source with a clear structural weakness, helping to solidify your understanding of how correlations in data reduce its effective unpredictability.", "problem": "A cryptographic protocol relies on a source that generates $n$-bit keys, where $n$ is an even positive integer. A flaw in the implementation causes the key generation process to behave as follows: a string of $n/2$ bits is chosen uniformly at random, and this string constitutes the first half of the key. The second half of the key is then set to be an exact copy of the first half. The resulting $n$-bit key is represented by the random variable $X$.\n\nThe min-entropy of a discrete random variable $Y$ is defined as $H_{\\infty}(Y) = -\\log_{2}(\\max_{y} P(Y=y))$, where the maximization is over all possible outcomes $y$ of the variable $Y$. This metric is a crucial measure of an attacker's single-guess success probability.\n\nCalculate the min-entropy of the random variable $X$. Express your answer in bits as a function of $n$.", "solution": "Let $n$ be an even positive integer. The process selects a string $w$ of length $n/2$ uniformly at random from $\\{0,1\\}^{n/2}$ and outputs the $n$-bit string $X = ww$. Therefore, the support of $X$ is the set\n$$\nS = \\{ ww : w \\in \\{0,1\\}^{n/2} \\},\n$$\nwhich has cardinality\n$$\n|S| = 2^{n/2}.\n$$\nSince $w$ is chosen uniformly and deterministically mapped to $ww$, $X$ is uniform over $S$. Hence, for any $x \\in S$,\n$$\nP(X = x) = \\frac{1}{2^{n/2}},\n$$\nand for any $x \\notin S$, $P(X = x) = 0$. Therefore, the maximum probability of any outcome is\n$$\n\\max_{x} P(X = x) = \\frac{1}{2^{n/2}}.\n$$\nBy the definition of min-entropy,\n$$\nH_{\\infty}(X) = -\\log_{2}\\!\\left( \\max_{x} P(X = x) \\right) = -\\log_{2}\\!\\left( 2^{-n/2} \\right) = \\frac{n}{2}.\n$$\nThus, the min-entropy of $X$ is $\\frac{n}{2}$ bits.", "answer": "$$\\boxed{\\frac{n}{2}}$$", "id": "1647791"}, {"introduction": "With a measure for initial randomness established, our next step is to understand the tool used to distill a secure key: the universal hash function. These are not single functions, but large families of functions from which one is chosen at random, and their effectiveness hinges on the guarantee that the probability of any two distinct inputs mapping to the same output (a \"collision\") is very low. In this exercise [@problem_id:1647784], you will explore one of the most fundamental constructions of a universal hash family and derive its collision probability, revealing the simple yet powerful mechanism behind this cryptographic primitive.", "problem": "In the field of cryptography and information theory, a crucial tool for tasks like privacy amplification is a universal hash family. Such a family allows for mapping long data strings to shorter, fixed-length strings in a way that minimizes collisions for any two distinct inputs.\n\nConsider a simple family of linear hash functions, $\\mathcal{H}$, designed to map $n$-bit binary strings to $m$-bit binary strings, with $n > m$. All arithmetic is performed over the Galois Field of two elements, denoted as GF(2), where addition corresponds to the bitwise XOR operation and multiplication corresponds to the bitwise AND operation.\n\nA specific hash function $h_A \\in \\mathcal{H}$ is determined by an $m \\times n$ matrix $A$, whose entries are chosen independently and uniformly at random from $\\{0, 1\\}$. An input, represented as an $n$-bit string, is treated as an $n \\times 1$ column vector $x$. The function computes the hash value as the matrix-vector product:\n$$h_A(x) = Ax$$\nThe result, $h_A(x)$, is an $m \\times 1$ column vector representing the $m$-bit output string.\n\nAssume a hash function $h_A$ is selected from this family by choosing the matrix $A$ uniformly at random. For any two distinct $n$-bit input vectors, $x_1$ and $x_2$, determine the probability that their hash values are identical. Express your answer as a mathematical expression in terms of $m$.", "solution": "Let $x_{1},x_{2} \\in \\{0,1\\}^{n}$ with $x_{1} \\neq x_{2}$ and let $A$ be an $m \\times n$ random matrix over $\\mathrm{GF}(2)$ with entries independently and uniformly distributed in $\\{0,1\\}$. Define the nonzero difference vector $d = x_{1} + x_{2}$ in $\\mathrm{GF}(2)$, so $d \\neq 0$.\n\nThe collision event $h_{A}(x_{1}) = h_{A}(x_{2})$ satisfies\n$$\nh_{A}(x_{1}) = h_{A}(x_{2})\n\\;\\;\\Longleftrightarrow\\;\\;\nA x_{1} = A x_{2}\n\\;\\;\\Longleftrightarrow\\;\\;\nA(x_{1}+x_{2}) = 0\n\\;\\;\\Longleftrightarrow\\;\\;\nA d = 0.\n$$\n\nWrite the rows of $A$ as $r_{1}^{\\top},\\dots,r_{m}^{\\top} \\in \\{0,1\\}^{n}$. Then $A d = 0$ if and only if $r_{i}^{\\top} d = 0$ in $\\mathrm{GF}(2)$ for all $i=1,\\dots,m$. For a fixed nonzero $d$, consider a single random row $r$. The dot product $r^{\\top} d = \\sum_{j=1}^{n} r_{j} d_{j}$ is computed in $\\mathrm{GF}(2)$. Since $d \\neq 0$, there exists an index $j^{*}$ with $d_{j^{*}}=1$. Conditioning on all coordinates $\\{r_{j}\\}_{j \\neq j^{*}}$, the value of $r^{\\top} d$ is equal to $b + r_{j^{*}}$ in $\\mathrm{GF}(2)$ for some fixed $b \\in \\{0,1\\}$. Because $r_{j^{*}}$ is uniform in $\\{0,1\\}$ and independent of the other coordinates, it follows that\n$$\n\\Pr(r^{\\top} d = 0) = \\frac{1}{2}.\n$$\n\nSince the rows $r_{1},\\dots,r_{m}$ are independent, the events $\\{r_{i}^{\\top} d = 0\\}$ are independent, and therefore\n$$\n\\Pr(A d = 0) = \\prod_{i=1}^{m} \\Pr(r_{i}^{\\top} d = 0) = \\left(\\frac{1}{2}\\right)^{m} = 2^{-m}.\n$$\n\nThus, for any two distinct inputs $x_{1}$ and $x_{2}$, the probability over the random choice of $A$ that $h_{A}(x_{1}) = h_{A}(x_{2})$ is $2^{-m}$.", "answer": "$$\\boxed{2^{-m}}$$", "id": "1647784"}, {"introduction": "The Leftover Hash Lemma provides the central theoretical guarantee for privacy amplification, elegantly connecting the min-entropy of a source on one hand, and the security of the key extracted by a universal hash function on the other. This practice problem [@problem_id:1647754] moves from theory to application, placing you in the role of a cryptography engineer. You will use the security bound provided by the lemma to solve a practical design problem: determining the minimum amount of initial randomness required to generate a final key that meets specific security standards.", "problem": "A cryptography engineer is tasked with designing the privacy amplification module for a secure communication system. This module processes a raw key, which is partially compromised, to produce a shorter, highly secure final key. The raw key is represented as a random variable $X$, and the initial uncertainty about it is quantified by its min-entropy, $k$, measured in bits.\n\nThe system uses a randomly selected universal hash function to transform the raw key into a final key of length $m$. The security of this final key is guaranteed by a parameter $\\epsilon$, representing its statistical distinguishability from a truly random string. A lower value of $\\epsilon$ indicates a more secure key. The theoretical security guarantee for the chosen privacy amplification protocol is given by the inequality:\n$$ \\epsilon \\le \\frac{1}{2} 2^{(m-k)/2} $$\nThe system must generate a final key of length $m=64$ bits. For the key to be considered cryptographically secure for its intended application, the security parameter must satisfy the condition $\\epsilon \\le 2^{-20}$.\n\nTo ensure the system is designed correctly, determine the minimum integer value of the min-entropy $k$ that the raw key must possess to meet these security and output length requirements.", "solution": "We are given that a privacy amplification protocol using a universal hash function guarantees\n$$ \\epsilon \\le \\frac{1}{2} 2^{(m - k)/2}. $$\nTo ensure the final key meets the design requirement $\\epsilon \\le 2^{-20}$ for an output length $m = 64$, it is sufficient to require the upper bound to be at most $2^{-20}$:\n$$ \\frac{1}{2} 2^{(64 - k)/2} \\le 2^{-20}. $$\nBoth sides are positive, and $\\log_{2}$ is strictly increasing, so we take $\\log_{2}$ of both sides:\n$$ \\log_{2}\\!\\left(\\frac{1}{2} 2^{(64 - k)/2}\\right) \\le \\log_{2}\\!\\left(2^{-20}\\right). $$\nEvaluating each side gives\n$$ -1 + \\frac{64 - k}{2} \\le -20. $$\nRearranging step by step:\n$$ \\frac{64 - k}{2} \\le -19, $$\n$$ 64 - k \\le -38, $$\n$$ -k \\le -102, $$\n$$ k \\ge 102. $$\nSince $k$ must be an integer, the minimum integer value satisfying the requirement is $k = 102$.", "answer": "$$\\boxed{102}$$", "id": "1647754"}]}