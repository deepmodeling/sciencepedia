{"hands_on_practices": [{"introduction": "The first step in working with linear codes is understanding that a code is fundamentally a vector subspace, which can be described by different sets of basis vectors. This practice explores a common scenario where two teams design a code for the same purpose and produce different generator matrices. By working through this problem [@problem_id:1633509], you will learn a crucial skill: how to determine if two generator matrices generate the exact same set of codewords, ensuring they represent the same underlying code.", "problem": "In a new satellite communication project, two engineering teams, designated Alpha and Bravo, were independently tasked with designing a binary linear error-correcting code. Both teams were supposed to implement the same $[6, 3]$ code, meaning a code that maps 3-bit message words into 6-bit codewords. However, due to a mix-up in the initial project specifications, their final documented generator matrices differ. All arithmetic is performed in the finite field $GF(2)$, where $1+1=0$.\n\nTeam Alpha's generator matrix is:\n$$ G_A = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\\\ 0 & 1 & 0 & 1 & 0 & 1 \\\\ 0 & 0 & 1 & 0 & 1 & 1 \\end{pmatrix} $$\n\nTeam Bravo's generator matrix is:\n$$ G_B = \\begin{pmatrix} 1 & 1 & 0 & 0 & 1 & 1 \\\\ 0 & 1 & 1 & 1 & 1 & 0 \\\\ 1 & 1 & 1 & 1 & 1 & 1 \\end{pmatrix} $$\n\nYour task is to determine if the two matrices generate the same code. Two generator matrices are said to generate the same code if and only if the set of all possible codewords produced by one matrix is identical to the set of all possible codewords produced by the other. Which of the following statements is true?\n\nA. The codes generated by $G_A$ and $G_B$ are identical.\n\nB. The codes generated by $G_A$ and $G_B$ are not identical.\n\nC. There is not enough information to determine if the codes are identical.\n\nD. One or both of the matrices are not valid generator matrices for a $[6, 3]$ code.", "solution": "Two generator matrices over $GF(2)$ generate the same linear code if and only if their row spaces are equal. Equivalently, there exists an invertible $3 \\times 3$ matrix $U$ over $GF(2)$ such that $G_{B} = U G_{A}$, or both matrices have the same reduced row echelon form (RREF) over $GF(2)$.\n\nTeam Alpha’s matrix is\n$$\nG_{A}=\\begin{pmatrix}\n1 & 0 & 0 & 1 & 1 & 0\\\\\n0 & 1 & 0 & 1 & 0 & 1\\\\\n0 & 0 & 1 & 0 & 1 & 1\n\\end{pmatrix},\n$$\nwhich is already in systematic form $[I_{3} \\mid P_{A}]$ with\n$$\nP_{A}=\\begin{pmatrix}\n1 & 1 & 0\\\\\n1 & 0 & 1\\\\\n0 & 1 & 1\n\\end{pmatrix}.\n$$\n\nRow-reduce $G_{B}$ over $GF(2)$:\n$$\nG_{B}=\\begin{pmatrix}\n1 & 1 & 0 & 0 & 1 & 1\\\\\n0 & 1 & 1 & 1 & 1 & 0\\\\\n1 & 1 & 1 & 1 & 1 & 1\n\\end{pmatrix}.\n$$\nUse $R_{3} \\leftarrow R_{3}+R_{1}$ to eliminate the entry in column $1$ of $R_{3}$:\n$$\n\\begin{pmatrix}\n1 & 1 & 0 & 0 & 1 & 1\\\\\n0 & 1 & 1 & 1 & 1 & 0\\\\\n0 & 0 & 1 & 1 & 0 & 0\n\\end{pmatrix}.\n$$\nUse $R_{1} \\leftarrow R_{1}+R_{2}$ to eliminate the entry in column $2$ of $R_{1}$:\n$$\n\\begin{pmatrix}\n1 & 0 & 1 & 1 & 0 & 1\\\\\n0 & 1 & 1 & 1 & 1 & 0\\\\\n0 & 0 & 1 & 1 & 0 & 0\n\\end{pmatrix}.\n$$\nUse $R_{1} \\leftarrow R_{1}+R_{3}$ and $R_{2} \\leftarrow R_{2}+R_{3}$ to eliminate the entries in column $3$ of $R_{1}$ and $R_{2}$:\n$$\n\\begin{pmatrix}\n1 & 0 & 0 & 0 & 0 & 1\\\\\n0 & 1 & 0 & 0 & 1 & 0\\\\\n0 & 0 & 1 & 1 & 0 & 0\n\\end{pmatrix}.\n$$\nThis is the RREF of $G_{B}$, which is in systematic form $[I_{3} \\mid P_{B}]$ with\n$$\nP_{B}=\\begin{pmatrix}\n0 & 0 & 1\\\\\n0 & 1 & 0\\\\\n1 & 0 & 0\n\\end{pmatrix}.\n$$\n\nSince the RREFs are unique for a given row space, and $P_{A} \\neq P_{B}$, the row spaces of $G_{A}$ and $G_{B}$ are not equal. Therefore, the codes are not identical.\n\nAs a direct consistency check, the code generated by $G_{B}$ in this form has codewords of the form $[u_{1}, u_{2}, u_{3}, u_{3}, u_{2}, u_{1}]$, because $u P_{B} = [u_{3}, u_{2}, u_{1}]$ for any message row vector $u = [u_{1}, u_{2}, u_{3}]$. The code generated by $G_{A}$ has codewords $[u_{1}, u_{2}, u_{3}, u_{1}+u_{2}, u_{1}+u_{3}, u_{2}+u_{3}]$. Taking $u=[1,0,0]$ gives the $G_{A}$ codeword $[1,0,0,1,1,0]$, which does not satisfy the equalities $c_{6}=c_{1}$ required by the $G_{B}$ codewords. Hence $G_{A}$’s code contains a vector not in $G_{B}$’s code, confirming the codes are different.\n\nBoth matrices are valid generator matrices for a $[6,3]$ code because they are $3 \\times 6$ with rank $3$ (for $G_{A}$ this is immediate from the leading $I_{3}$ block; for $G_{B}$ the RREF explicitly shows three pivots). Therefore, the correct statement is that the codes generated by $G_{A}$ and $G_{B}$ are not identical.", "answer": "$$\\boxed{B}$$", "id": "1633509"}, {"introduction": "After defining a code, the next critical question is: how effective is it at detecting errors? This exercise [@problem_id:1633520] delves into the limits of a code's error-detection capability by using its parity-check matrix $H$. You will investigate the relationship between the columns of $H$ and discover the smallest number of bit-flips that can create an error pattern the code fails to detect, a value directly related to the code's minimum distance.", "problem": "In a digital communication system, information is encoded using a binary linear block code to protect against errors during transmission. A code is defined as a set of valid codewords, which are vectors of binary digits (bits). This particular code is an $[n, k]$ linear code defined by its parity-check matrix, $H$. Any transmitted codeword $c$ must satisfy the condition $Hc^T = \\boldsymbol{0}$, where the matrix multiplication is performed over the binary field $\\mathbb{F}_2$ (i.e., addition is XOR, and multiplication is AND).\n\nWhen a codeword $c$ is transmitted over a noisy channel, it may be received as a different vector $y = c + e$, where $e$ is a non-zero error vector. The vector $e$ has a '1' in each position where a bit-flip occurred and a '0' elsewhere. The receiver checks the validity of the received vector $y$ by computing a syndrome vector $s = Hy^T$. If $s = \\boldsymbol{0}$, the receiver assumes no error occurred. Consequently, if an error pattern $e$ is such that $He^T = \\boldsymbol{0}$, the error will go undetected.\n\nConsider a binary linear code defined by the following $3 \\times 6$ parity-check matrix $H$:\n$$\nH = \\begin{pmatrix} \n1 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 1 & 0 & 1 & 1 \n\\end{pmatrix}\n$$\nWhat is the minimum number of bit-flips in a transmission that could result in an error pattern that the receiver cannot detect?", "solution": "An undetected error occurs when the received word $y=c+e$ has syndrome $s=Hy^{T}=\\boldsymbol{0}$. Since codewords satisfy $Hc^{T}=\\boldsymbol{0}$, we have\n$$\ns=H(c+e)^{T}=Hc^{T}+He^{T}=\\boldsymbol{0}+He^{T}=He^{T}.\n$$\nThus an error $e$ is undetected if and only if $He^{T}=\\boldsymbol{0}$ with $e\\neq \\boldsymbol{0}$. The minimum number of bit-flips that can go undetected is the minimum Hamming weight among all nonzero $e$ in the null space of $H$, which equals the code’s minimum distance.\n\nLet the columns of $H$ be $h_{1},\\dots,h_{6}$. Over $\\mathbb{F}_{2}$, the condition $He^{T}=\\boldsymbol{0}$ means that the sum (XOR) of the columns indexed by the support of $e$ is the zero vector. Compute the columns:\n$$\nh_{1}=\\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix},\\quad\nh_{2}=\\begin{pmatrix}0\\\\1\\\\0\\end{pmatrix},\\quad\nh_{3}=\\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix},\\quad\nh_{4}=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix},\\quad\nh_{5}=\\begin{pmatrix}1\\\\0\\\\1\\end{pmatrix},\\quad\nh_{6}=\\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix}.\n$$\n- Weight-1: An undetected single-bit error would require some $h_{i}=\\boldsymbol{0}$, which does not occur. Hence weight $1$ is impossible.\n- Weight-2: An undetected two-bit error would require $h_{i}+h_{j}=\\boldsymbol{0}$, i.e., $h_{i}=h_{j}$. All columns are distinct, so weight $2$ is impossible.\n- Weight-3: Check for a triple summing to zero. We have\n$$\nh_{1}+h_{2}=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix}=h_{4}\\;\\Rightarrow\\;h_{1}+h_{2}+h_{4}=\\boldsymbol{0}.\n$$\nTherefore a weight-$3$ error on positions $\\{1,2,4\\}$ is undetected, so the minimum undetectable weight is at most $3$. Combined with the impossibility of weights $1$ and $2$, the minimum is exactly $3$.\n\nHence, the minimum number of bit-flips that can go undetected is $3$.", "answer": "$$\\boxed{3}$$", "id": "1633520"}, {"introduction": "This final practice integrates everything you've learned into a complete decoding challenge that mimics a real-world engineering problem. Faced with a received message and a unique, non-standard error model, you will need to construct a full decoding strategy from the ground up [@problem_id:1633532]. This exercise will test your ability to use the generator and parity-check matrices to perform syndrome decoding and will highlight the practical issue of decoding ambiguity, where a received word could correspond to more than one valid original message.", "problem": "In a new type of high-density magnetic storage, data is encoded using a systematic linear block code before being written. A message, represented by a 3-bit binary vector $m = (m_1, m_2, m_3)$, is encoded into a 6-bit codeword $c = (c_1, c_2, c_3, c_4, c_5, c_6)$ using the generator matrix $G$ over the finite field $\\mathbb{F}_2$:\n$$ G = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\\\ 0 & 1 & 0 & 0 & 1 & 1 \\\\ 0 & 0 & 1 & 1 & 0 & 1 \\end{pmatrix} $$\nThe encoding rule is $c = mG$. All arithmetic is performed modulo 2.\n\nThe primary failure mode of this storage medium is a localized magnetic field decay, which causes a single, specific type of error event. This error, which we will call a Cyclic Adjacent Pair Flip (CAPF) error, simultaneously flips the values of exactly two adjacent bits in the codeword. The adjacency is cyclic, meaning bit $c_6$ is considered adjacent to bit $c_1$. For example, a CAPF error could flip bits $(c_2, c_3)$ or $(c_6, c_1)$, but not $(c_1, c_3)$.\n\nA 6-bit vector $r = (1, 1, 0, 0, 1, 1)$ is read from the storage medium. Assuming that at most one error event (either no error or a single CAPF error) has occurred, determine the set of all possible original 3-bit messages $m$ that could have been sent.\n\nWhich of the following statements is correct?\n\nA. The only possible message is $(1, 0, 1)$.\n\nB. The only possible message is $(1, 1, 0)$.\n\nC. The only possible message is $(0, 1, 1)$.\n\nD. There are exactly two possible messages: $(1, 0, 1)$ and $(1, 1, 0)$.\n\nE. The received vector must have resulted from more than one CAPF error, as it is inconsistent with any single-error scenario.", "solution": "The problem asks us to perform decoding for a linear code on a channel with a specific error model. The standard procedure for this is syndrome decoding.\n\nFirst, we need to determine the parity-check matrix $H$ for the given linear code. The generator matrix $G$ is given in systematic form $G = [I_k | P]$, where $k=3$ is the number of message bits, and $I_k$ is the $k \\times k$ identity matrix. The matrix $P$ is the $k \\times (n-k)$ matrix forming the rest of $G$. Here, $n=6$, so $n-k=3$.\n$$ P = \\begin{pmatrix} 1 & 1 & 0 \\\\ 0 & 1 & 1 \\\\ 1 & 0 & 1 \\end{pmatrix} $$\nThe parity-check matrix $H$ is then given by $H = [P^T | I_{n-k}]$, where $P^T$ is the transpose of $P$.\n$$ P^T = \\begin{pmatrix} 1 & 0 & 1 \\\\ 1 & 1 & 0 \\\\ 0 & 1 & 1 \\end{pmatrix} $$\nThus, the parity-check matrix $H$ is:\n$$ H = \\begin{pmatrix} 1 & 0 & 1 & 1 & 0 & 0 \\\\ 1 & 1 & 0 & 0 & 1 & 0 \\\\ 0 & 1 & 1 & 0 & 0 & 1 \\end{pmatrix} $$\nA vector $c$ is a valid codeword if and only if $cH^T = 0$. For a received vector $r = c + e$, where $c$ is the transmitted codeword and $e$ is the error vector, the syndrome $s$ is calculated as $s = rH^T$. Since $cH^T=0$, we have $s = (c+e)H^T = cH^T + eH^T = eH^T$. The syndrome depends only on the error.\n\nThe received vector is $r = (1, 1, 0, 0, 1, 1)$. Let's compute its syndrome. All operations are in $\\mathbb{F}_2$.\n$$ s = rH^T = (1, 1, 0, 0, 1, 1) \\begin{pmatrix} 1 & 1 & 0 \\\\ 0 & 1 & 1 \\\\ 1 & 0 & 1 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} $$\nLet's compute each component of the 3-bit syndrome vector $s=(s_1, s_2, s_3)$:\n$s_1 = 1 \\cdot 1 + 1 \\cdot 0 + 0 \\cdot 1 + 0 \\cdot 1 + 1 \\cdot 0 + 1 \\cdot 0 = 1$\n$s_2 = 1 \\cdot 1 + 1 \\cdot 1 + 0 \\cdot 0 + 0 \\cdot 0 + 1 \\cdot 1 + 1 \\cdot 0 = 1+1+1 = 1$\n$s_3 = 1 \\cdot 0 + 1 \\cdot 1 + 0 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 0 + 1 \\cdot 1 = 1+1 = 0$\nSo, the syndrome of the received vector is $s = (1, 1, 0)$. Since $s \\neq (0,0,0)$, the received vector is not a valid codeword, and an error must have occurred.\n\nNext, we must find which error(s) from our error model correspond to this syndrome. The possible single CAPF errors are represented by error vectors with weight 2, where the 1s are in adjacent positions (cyclically). Let's calculate the syndrome for each possible single error vector $e$:\nLet $h_i$ be the $i$-th column of $H$. Then the syndrome for an error flipping bits $i$ and $j$ is $h_i^T + h_j^T$.\n\n- No error: $e_0 = (0,0,0,0,0,0)$, syndrome $s_0 = (0,0,0)$.\n- Error flipping bits 1, 2: $e_1 = (1,1,0,0,0,0)$, syndrome $s_1 = h_1^T + h_2^T = (1,1,0) + (0,1,1) = (1,0,1)$.\n- Error flipping bits 2, 3: $e_2 = (0,1,1,0,0,0)$, syndrome $s_2 = h_2^T + h_3^T = (0,1,1) + (1,0,1) = (1,1,0)$.\n- Error flipping bits 3, 4: $e_3 = (0,0,1,1,0,0)$, syndrome $s_3 = h_3^T + h_4^T = (1,0,1) + (1,0,0) = (0,0,1)$.\n- Error flipping bits 4, 5: $e_4 = (0,0,0,1,1,0)$, syndrome $s_4 = h_4^T + h_5^T = (1,0,0) + (0,1,0) = (1,1,0)$.\n- Error flipping bits 5, 6: $e_5 = (0,0,0,0,1,1)$, syndrome $s_5 = h_5^T + h_6^T = (0,1,0) + (0,0,1) = (0,1,1)$.\n- Error flipping bits 6, 1: $e_6 = (1,0,0,0,0,1)$, syndrome $s_6 = h_6^T + h_1^T = (0,0,1) + (1,1,0) = (1,1,1)$.\n\nThe syndrome of our received vector is $s=(1,1,0)$. From our table of syndromes, this matches two possible error vectors: $e_2 = (0,1,1,0,0,0)$ and $e_4 = (0,0,0,1,1,0)$. This means the decoding is ambiguous. We must find both possible transmitted codewords. The corrected codeword $\\hat{c}$ is found by $\\hat{c} = r + e$.\n\nPossibility 1: The error was $e_2 = (0,1,1,0,0,0)$.\nThe transmitted codeword would be $\\hat{c}_1 = r + e_2 = (1,1,0,0,1,1) + (0,1,1,0,0,0) = (1,0,1,0,1,1)$.\n\nPossibility 2: The error was $e_4 = (0,0,0,1,1,0)$.\nThe transmitted codeword would be $\\hat{c}_2 = r + e_4 = (1,1,0,0,1,1) + (0,0,0,1,1,0) = (1,1,0,1,0,1)$.\n\nWe must now decode these two possible codewords to find the original messages. Since the code is systematic with $G=[I_3 | P]$, the original message $m = (m_1, m_2, m_3)$ corresponds to the first three bits of the codeword $c$.\n\nFor $\\hat{c}_1 = (1,0,1,0,1,1)$, the original message is $m_1 = (1,0,1)$.\nFor $\\hat{c}_2 = (1,1,0,1,0,1)$, the original message is $m_2 = (1,1,0)$.\n\nBoth of these are valid interpretations under the assumption of a single CAPF error. Therefore, there are two possible original messages: $(1,0,1)$ and $(1,1,0)$.\n\nComparing our findings with the given options:\nA. The only possible message is $(1, 0, 1)$. (Incorrect, incomplete)\nB. The only possible message is $(1, 1, 0)$. (Incorrect, incomplete)\nC. The only possible message is $(0, 1, 1)$. (Incorrect)\nD. There are exactly two possible messages: $(1, 0, 1)$ and $(1, 1, 0)$. (Correct)\nE. The received vector must have resulted from more than one CAPF error... (Incorrect, we found single-error explanations)\n\nThe correct statement is D.", "answer": "$$\\boxed{D}$$", "id": "1633532"}]}