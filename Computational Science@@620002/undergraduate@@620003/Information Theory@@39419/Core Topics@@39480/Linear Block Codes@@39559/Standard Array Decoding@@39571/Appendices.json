{"hands_on_practices": [{"introduction": "Welcome to the hands-on section where we put theory into practice. Our first exercise focuses on the fundamental first step in standard array decoding: calculating the syndrome. The syndrome acts as a unique signature for an error pattern, allowing us to diagnose issues in a received message. This practice [@problem_id:1659997] will solidify your understanding of how to compute the syndrome vector $s$ from a received vector $y$ and a parity-check matrix $H$, using the core formula $s = H y^T$.", "problem": "A deep space probe transmits scientific data back to Earth. To protect against corruption from cosmic radiation, the data is encoded using a linear block code. The code used is a specific $(n=7, k=4)$ code operating over the binary field $\\mathbb{F}_2$, where all arithmetic is performed modulo 2.\n\nThe integrity of the received data is checked using a parity-check matrix $H$. A received 7-bit vector $y$ is considered a valid codeword only if the product $Hy^T$ results in a zero vector. If the product is non-zero, it indicates that errors have occurred. This non-zero result is called the syndrome vector, $s$, and is formally defined as $s = Hy^T$.\n\nThe parity-check matrix for this code is given by:\n$$ H = \\begin{pmatrix} 0 & 0 & 0 & 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 0 & 0 & 1 & 1 \\\\ 1 & 0 & 1 & 0 & 1 & 0 & 1 \\end{pmatrix} $$\n\nSuppose that after traveling through space, a particular transmission is received on Earth as the vector $y = [1, 0, 1, 1, 1, 1, 0]$.\n\nCalculate the syndrome vector $s$ for this received vector $y$. Express your result as a row vector.", "solution": "We work over the binary field $\\mathbb{F}_{2}$, so all additions and multiplications are performed modulo $2$. The syndrome is defined by\n$$\ns = H y^{T},\n$$\nwhere $H \\in \\mathbb{F}_{2}^{3 \\times 7}$ and $y \\in \\mathbb{F}_{2}^{1 \\times 7}$ is the received vector. With\n$$\nH = \\begin{pmatrix}\n0 & 0 & 0 & 1 & 1 & 1 & 1 \\\\\n0 & 1 & 1 & 0 & 0 & 1 & 1 \\\\\n1 & 0 & 1 & 0 & 1 & 0 & 1\n\\end{pmatrix}, \\quad\ny = \\begin{pmatrix} 1 & 0 & 1 & 1 & 1 & 1 & 0 \\end{pmatrix},\n$$\nwe form $y^{T} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 0 \\end{pmatrix}$ and compute each component of $s$ as a modulo-$2$ dot product of the corresponding row of $H$ with $y$:\n$$\ns_{1} = 0\\cdot 1 + 0\\cdot 0 + 0\\cdot 1 + 1\\cdot 1 + 1\\cdot 1 + 1\\cdot 1 + 1\\cdot 0 \\equiv 0+0+0+1+1+1+0 \\equiv 3 \\equiv 1 \\pmod{2},\n$$\n$$\ns_{2} = 0\\cdot 1 + 1\\cdot 0 + 1\\cdot 1 + 0\\cdot 1 + 0\\cdot 1 + 1\\cdot 1 + 1\\cdot 0 \\equiv 0+0+1+0+0+1+0 \\equiv 2 \\equiv 0 \\pmod{2},\n$$\n$$\ns_{3} = 1\\cdot 1 + 0\\cdot 0 + 1\\cdot 1 + 0\\cdot 1 + 1\\cdot 1 + 0\\cdot 1 + 1\\cdot 0 \\equiv 1+0+1+0+1+0+0 \\equiv 3 \\equiv 1 \\pmod{2}.\n$$\nThus,\n$$\ns = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix}.\n$$\nExpressed as the requested row vector, the syndrome is\n$$\n\\begin{pmatrix} 1 & 0 & 1 \\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}1 & 0 & 1\\end{pmatrix}}$$", "id": "1659997"}, {"introduction": "Now that you can calculate a syndrome, let's explore how it's used to correct errors. This problem demonstrates the complete standard array decoding process. By computing the syndrome and using it to look up the corresponding \"coset leader\" — the most likely error pattern — we can reverse the damage done during transmission. This exercise [@problem_id:1659967] will guide you through taking a received vector, identifying the error, and recovering the original, intended codeword.", "problem": "A space probe uses a binary linear block code for transmitting data. The code is a $(5, 2)$ code, meaning it encodes 2-bit messages into 5-bit codewords. The error correction for this system is handled on Earth using standard array decoding. The parity-check matrix $H$ for this code is given by:\n$$H = \\begin{pmatrix} 1 & 0 & 1 & 0 & 0 \\\\ 1 & 1 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 0 & 1 \\end{pmatrix}$$\nA data packet is received from the probe as the binary vector $y = (1, 0, 1, 1, 1)$. All arithmetic is performed over the finite field $\\mathbb{F}_2$, where addition is equivalent to the XOR operation.\n\nTo decode the received vector, the ground station uses the following pre-computed table, which maps each possible syndrome to its corresponding coset leader (the most likely error pattern):\n\n| Syndrome, $s$ | Coset Leader, $e$ |\n| :--- | :--- |\n| $(0, 0, 0)$ | $(0, 0, 0, 0, 0)$ |\n| $(0, 0, 1)$ | $(0, 0, 0, 0, 1)$ |\n| $(0, 1, 0)$ | $(0, 0, 0, 1, 0)$ |\n| $(0, 1, 1)$ | $(0, 1, 0, 0, 0)$ |\n| $(1, 0, 0)$ | $(0, 0, 1, 0, 0)$ |\n| $(1, 0, 1)$ | $(1, 1, 0, 0, 0)$ |\n| $(1, 1, 0)$ | $(1, 0, 0, 0, 0)$ |\n| $(1, 1, 1)$ | $(1, 0, 0, 0, 1)$ |\n\nAssuming a single error event occurred, corresponding to one of the coset leaders in the table, determine the most likely transmitted codeword. Present your answer as a 5-element row vector.", "solution": "We work over the field $\\mathbb{F}_{2}$ where addition and subtraction coincide. The standard array decoding proceeds by computing the syndrome of the received vector $y$ using the parity-check matrix $H$, then selecting the corresponding coset leader $e$ from the table, and finally forming the decoded codeword $c$ by $c = y + e$.\n\nGiven\n$$\nH = \\begin{pmatrix}\n1 & 0 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 1\n\\end{pmatrix},\\quad\ny = \\begin{pmatrix} 1 & 0 & 1 & 1 & 1 \\end{pmatrix},\n$$\nthe syndrome is\n$$\ns = H y^{T} \\in \\mathbb{F}_{2}^{3}.\n$$\nCompute each component of $s$:\n$$\ns_{1} = 1\\cdot y_{1} + 0\\cdot y_{2} + 1\\cdot y_{3} + 0\\cdot y_{4} + 0\\cdot y_{5} = y_{1} + y_{3} = 1 + 1 = 0,\n$$\n$$\ns_{2} = 1\\cdot y_{1} + 1\\cdot y_{2} + 0\\cdot y_{3} + 1\\cdot y_{4} + 0\\cdot y_{5} = y_{1} + y_{2} + y_{4} = 1 + 0 + 1 = 0,\n$$\n$$\ns_{3} = 0\\cdot y_{1} + 1\\cdot y_{2} + 0\\cdot y_{3} + 0\\cdot y_{4} + 1\\cdot y_{5} = y_{2} + y_{5} = 0 + 1 = 1.\n$$\nThus\n$$\ns = \\begin{pmatrix} 0 & 0 & 1 \\end{pmatrix}.\n$$\nFrom the provided table, the coset leader corresponding to $s = \\begin{pmatrix} 0 & 0 & 1 \\end{pmatrix}$ is\n$$\ne = \\begin{pmatrix} 0 & 0 & 0 & 0 & 1 \\end{pmatrix}.\n$$\nAssuming a single error with this most likely pattern, the decoded codeword is\n$$\nc = y + e = \\begin{pmatrix} 1 & 0 & 1 & 1 & 1 \\end{pmatrix} + \\begin{pmatrix} 0 & 0 & 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 & 1 & 1 & 0 \\end{pmatrix}.\n$$\nVerification that $c$ is a valid codeword:\n$$\nH c^{T} = \\begin{pmatrix}\n1\\cdot c_{1} + 0\\cdot c_{2} + 1\\cdot c_{3} + 0\\cdot c_{4} + 0\\cdot c_{5} \\\\\n1\\cdot c_{1} + 1\\cdot c_{2} + 0\\cdot c_{3} + 1\\cdot c_{4} + 0\\cdot c_{5} \\\\\n0\\cdot c_{1} + 1\\cdot c_{2} + 0\\cdot c_{3} + 0\\cdot c_{4} + 1\\cdot c_{5}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 + 1 \\\\\n1 + 0 + 1 \\\\\n0 + 0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n0 \\\\\n0\n\\end{pmatrix},\n$$\nso $c$ is in the code. Therefore, the most likely transmitted codeword is $\\begin{pmatrix} 1 & 0 & 1 & 1 & 0 \\end{pmatrix}$.", "answer": "$$\\boxed{\\begin{pmatrix} 1 & 0 & 1 & 1 & 0 \\end{pmatrix}}$$", "id": "1659967"}, {"introduction": "Standard array decoding is a powerful technique, but it's built on a key assumption: that the error with the fewest bit flips (lowest Hamming weight) is the most likely one to have occurred. This final practice problem [@problem_id:1660006] presents a fascinating thought experiment where this assumption leads to an incorrect decoding. By working through a scenario where a less common, higher-weight error occurs, you will gain a deeper appreciation for the probabilistic nature of error correction and the inherent limitations of nearest-neighbor decoding methods.", "problem": "A digital communication system for a deep-space probe uses a linear block code to enhance data integrity. The system encodes 3-bit messages into 6-bit codewords. All arithmetic is performed over the binary field $\\mathbb{F}_2$. The encoding is defined by the generator matrix $G$:\n$$\nG = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\\\ 0 & 1 & 0 & 0 & 1 & 1 \\\\ 0 & 0 & 1 & 1 & 0 & 1 \\end{pmatrix}\n$$\nA message vector $m$ is encoded into a codeword $c$ via the matrix multiplication $c = mG$.\n\nSuppose the specific 3-bit message $m = (1, 0, 0)$ is encoded and transmitted. During its journey, the transmission is disturbed by a specific pattern of interference, which results in a constant, additive error vector $e = (1, 1, 0, 0, 0, 0)$. The vector received at the ground station is $r = c + e$.\n\nThe receiver's decoding strategy is to select the unique codeword from the entire set of valid codewords that has the minimum Hamming distance to the received vector $r$. This process results in an incorrect decoding.\n\nWhat is the 6-bit codeword, $\\hat{c}$, that the receiver incorrectly decodes the received vector $r$ into?", "solution": "All operations are over $\\mathbb{F}_{2}$.\n\nThe encoding is $c = mG$. For $m = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix}$, the codeword equals the first row of $G$:\n$$\nc = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix}\n\\begin{pmatrix}\n1 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 1 & 0 & 1\n\\end{pmatrix}\n= \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\end{pmatrix}.\n$$\nThe received vector is $r = c + e$, with $e = \\begin{pmatrix} 1 & 1 & 0 & 0 & 0 & 0 \\end{pmatrix}$, so\n$$\nr = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\end{pmatrix} + \\begin{pmatrix} 1 & 1 & 0 & 0 & 0 & 0 \\end{pmatrix}\n= \\begin{pmatrix} 0 & 1 & 0 & 1 & 1 & 0 \\end{pmatrix}.\n$$\nLet the generator rows be $g_{1} = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\end{pmatrix}$, $g_{2} = \\begin{pmatrix} 0 & 1 & 0 & 0 & 1 & 1 \\end{pmatrix}$, $g_{3} = \\begin{pmatrix} 0 & 0 & 1 & 1 & 0 & 1 \\end{pmatrix}$. All codewords are $m_{1}g_{1} + m_{2}g_{2} + m_{3}g_{3}$ for $(m_{1},m_{2},m_{3}) \\in \\mathbb{F}_{2}^{3}$:\n$$\n\\begin{aligned}\n&000 \\to \\begin{pmatrix} 0 & 0 & 0 & 0 & 0 & 0 \\end{pmatrix},\\quad\n100 \\to \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\end{pmatrix},\\quad\n010 \\to \\begin{pmatrix} 0 & 1 & 0 & 0 & 1 & 1 \\end{pmatrix},\\\\\n&001 \\to \\begin{pmatrix} 0 & 0 & 1 & 1 & 0 & 1 \\end{pmatrix},\\quad\n110 \\to \\begin{pmatrix} 1 & 1 & 0 & 1 & 0 & 1 \\end{pmatrix},\\quad\n101 \\to \\begin{pmatrix} 1 & 0 & 1 & 0 & 1 & 1 \\end{pmatrix},\\\\\n&011 \\to \\begin{pmatrix} 0 & 1 & 1 & 1 & 1 & 0 \\end{pmatrix},\\quad\n111 \\to \\begin{pmatrix} 1 & 1 & 1 & 0 & 0 & 0 \\end{pmatrix}.\n\\end{aligned}\n$$\nThe decoder selects the codeword minimizing the Hamming distance to $r$, which equals the Hamming weight of $r + \\text{codeword}$.\n\nCompute distances:\n$$\n\\begin{aligned}\n&r + 000000 = 010110 \\Rightarrow d = 3,\\\\\n&r + 100110 = 110000 \\Rightarrow d = 2,\\\\\n&r + 010011 = 000101 \\Rightarrow d = 2,\\\\\n&r + 001101 = 011011 \\Rightarrow d = 4,\\\\\n&r + 110101 = 100011 \\Rightarrow d = 3,\\\\\n&r + 101011 = 111101 \\Rightarrow d = 5,\\\\\n&r + 011110 = 001000 \\Rightarrow d = 1,\\\\\n&r + 111000 = 101110 \\Rightarrow d = 4.\n\\end{aligned}\n$$\nThe unique minimum distance is $1$, attained by the codeword $\\begin{pmatrix} 0 & 1 & 1 & 1 & 1 & 0 \\end{pmatrix}$. Since the transmitted codeword had distance $2$, the decoder incorrectly outputs\n$$\n\\hat{c} = \\begin{pmatrix} 0 & 1 & 1 & 1 & 1 & 0 \\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix} 0 & 1 & 1 & 1 & 1 & 0 \\end{pmatrix}}$$", "id": "1660006"}]}