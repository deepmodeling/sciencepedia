{"hands_on_practices": [{"introduction": "Grasping the theory of adaptive Huffman coding is best done by working through the process yourself. This first exercise [@problem_id:1601884] is a fundamental drill in mastering the mechanics of a Faller-Gallager-Knuth (FGK) style algorithm. By carefully tracking symbol weights and performing swaps to maintain the tree's sibling property, you will see exactly how the code for a given character is determined at a specific point in a data stream.", "problem": "An adaptive Huffman encoder is used to compress a stream of characters. The encoder uses the Faller-Gallager-Knuth (FGK) algorithm to dynamically update its Huffman tree as it processes each character. The alphabet consists of the 26 uppercase English letters.\n\nThe encoding process follows these rules:\n1.  The tree is initialized with a single Not Yet Transmitted (NYT) node.\n2.  When a character appears for the first time, the encoder transmits the code for the current NYT node followed by a fixed 5-bit code for the character. 'A' is represented by `00000`, 'B' by `00001`, ..., and 'Z' by `11001`.\n3.  When a character that has appeared before is encountered, the encoder transmits its current Huffman code from the tree.\n4.  After encoding a character, the tree is updated. The frequency count of the character is incremented, and weights of all its ancestor nodes are also incremented.\n5.  To maintain the Huffman property, a node `P` is swapped with its sibling if the weight of `P` becomes strictly greater than its sibling's weight after an update. In this case, their positions and subtrees are exchanged. This check-and-swap process is applied recursively upwards from the updated character's leaf node towards the root.\n6.  When creating new children for a node (either by splitting an NYT node or through a swap), the child with the lower weight is assigned the local code '0' (left branch) and the child with the higher weight gets '1' (right branch). If the weights are equal, the internal node or NYT node is assigned '0' and the leaf node is assigned '1'.\n\nConsider the input string `BOOKKEEPER`. What is the binary code transmitted for the *second* appearance of the character 'K'?\n\nA. `10`\n\nB. `110`\n\nC. `101`\n\nD. `010`\n\nE. `111`", "solution": "We process the string BOOKKEEPER with the given FGK-style adaptive Huffman rules, tracking the Huffman tree and codes at each step until just before encoding the second K (the 5th character). We only need the code assigned to K at that moment.\n\nInitial state: single NYT node (weight 0).\n\n1) Read B (first appearance).\n- Transmit NYT code (root, empty) and 5-bit for B (irrelevant to the asked code).\n- Update: split root NYT into left NYT (weight 0, code 0) and right leaf B (weight 1, code 1). Root weight becomes 1. No swaps are needed. Current codes: B = 1, NYT = 0.\n\n2) Read O (first appearance).\n- Transmit NYT code 0 and 5-bit for O (irrelevant).\n- Update: split the current NYT (code 0) into an internal node whose children are left NYT (weight 0, code 00) and right O (weight 1, code 01). This internal node’s weight is 1; root becomes weight 2.\n- Check swaps bottom-up:\n  • At the local split, higher weight child O is already on the right, so no swap.\n  • At the root, left child (internal) has weight 1, right child B has weight 1. Since weights are equal, the internal node is correctly on the left (code 0) and the leaf B on the right (code 1) by the stated tie-break rule. No swap. Current codes: B = 1, O = 01, NYT = 00.\n\n3) Read O (seen before).\n- Transmit its current code 01 (not asked).\n- Update: increment O’s weight from 1 to 2; its parent and root weights each increase by 1. Now O has weight 2, its parent has weight 2, root has weight 3, and B has weight 1.\n- Check swaps bottom-up:\n  • At O’s parent: O (2) vs NYT (0); O already on the right, no swap.\n  • At the root: left child (the internal containing O) now has weight 2 and right child B has weight 1. Since the heavier subtree is on the left, swap the root’s children to maintain “heavier gets 1.” After swap: left child B (weight 1, code 0), right child the internal with O (weight 2, code 1). This changes codes: B = 0, O = 11, NYT (the current NYT under that internal) = 10.\n\n4) Read K (first appearance).\n- Transmit current NYT code 10 and 5-bit for K (irrelevant).\n- Update: split that NYT (code 10) into left NYT (weight 0, code 100) and right K (weight 1, code 101). The parent internal’s weight increases to 3; root weight increases to 4.\n- Check swaps bottom-up:\n  • At the local split: K (1) vs NYT (0); heavier is already on the right, no swap.\n  • At K’s parent (the right child of the root): left subtree weight 1 (the new internal with NYT and K), right subtree O has weight 2; heavier is on the right, no swap.\n  • At the root: left child B has weight 1, right child the internal has weight 3; heavier is on the right, no swap.\n\nAt this point, just before reading the next character (which is the second K), the code for K is 101.\n\n5) Read K (second appearance).\n- By rule, transmit its current Huffman code from the tree, which is 101.\n\nTherefore, the binary code transmitted for the second appearance of K is 101, which corresponds to option C.", "answer": "$$\\boxed{C}$$", "id": "1601884"}, {"introduction": "After mastering the step-by-step mechanics, we can zoom out to analyze the algorithm's overall performance and efficiency. This problem [@problem_id:1601888] challenges you to move from procedural tracing to analytical thinking. By observing the pattern that emerges from a simple, monotonous input, you can derive a general formula for the compressed length and appreciate how efficiently the coder adapts to predictable data.", "problem": "An adaptive Huffman encoder is used to compress a stream of data. The encoder operates on an alphabet of 256 distinct symbols, which are represented by fixed-length 8-bit codes when transmitted for the first time. The encoder follows a simplified adaptive algorithm described by the rules below:\n\n1.  **Initialization**: The compression model starts with a tree consisting of a single special node called the Not Yet Transmitted (NYT) node. This node has a weight of 0.\n\n2.  **Symbol Processing**:\n    *   **New Symbol**: If the symbol being processed has not been seen before, the encoder transmits the current Huffman code for the `NYT` node, followed by the symbol's 8-bit fixed-length code. The `NYT` node is then replaced in the tree by a new internal node. This internal node has two children: a new `NYT` leaf node with a weight of 0, and a new leaf node for the symbol with a weight of 1.\n    *   **Existing Symbol**: If the symbol has been seen before, the encoder transmits the symbol's current Huffman code. The weight of the symbol's leaf node is then incremented by 1.\n\n3.  **Tree Maintenance**: The Huffman tree structure is maintained dynamically.\n    *   After a node's weight is updated (either a new symbol's leaf or an existing one), the weight of its parent is updated to be the sum of its children's weights. This update propagates recursively to the root of the tree.\n    *   For any internal node in the tree, the child with the strictly greater weight is always assigned to the right branch (code '1'), and the child with the lesser weight is assigned to the left branch (code '0'). If the two children have equal weights, their positions (left/right) relative to each other are not changed.\n\nConsider an input stream consisting of a single symbol, `S`, repeated `N` times. Let $L(N)$ be the total length in bits of the compressed output generated by this encoder for such a stream of length `N`.\n\nCalculate the numerical value of the ratio $L(120) / L(40)$. Round your final answer to three significant figures.", "solution": "The problem asks for the ratio of the compressed lengths for two monotonous input streams of different lengths, using a specified adaptive Huffman coding algorithm. Let's analyze the number of bits generated at each step.\n\n**Step 1: Analyze the first symbol transmission**\nThe input stream is `S, S, S, ...`. When the first `S` is processed, it is a \"new\" symbol.\nAccording to the rules:\n- The encoder must transmit the current Huffman code for the `NYT` node. Initially, the tree consists of only the `NYT` node, which is the root. The code for the root is an empty string, so its length is 0 bits.\n- Next, the encoder transmits the symbol's 8-bit fixed-length code. This contributes 8 bits.\n- The total number of bits generated for the first symbol is `0 + 8 = 8` bits.\n\nAfter the first symbol is processed, the tree is updated. The original `NYT` node becomes an internal node (the new root). This root has two children:\n- A new `NYT` leaf node with weight 0.\n- A new leaf node for symbol `S` with weight 1.\n\nAccording to the tree maintenance rule, the child with the greater weight becomes the right child ('1') and the one with lesser weight becomes the left child ('0').\n- Left child: `NYT` node (weight 0). Its code path from the root is `0`.\n- Right child: `S` node (weight 1). Its code path from the root is `1`.\nThe weight of the root becomes the sum of its children's weights: `0 + 1 = 1`.\n\n**Step 2: Analyze the second symbol transmission**\nWhen the second `S` is processed, it is now an \"existing\" symbol.\n- The encoder transmits the symbol's current Huffman code. From Step 1, the code for `S` is `1`. This contributes 1 bit.\n- The total number of bits generated for the second symbol is 1 bit.\n\nAfter the second symbol is processed, the weight of the leaf node for `S` is incremented. Its weight becomes `1 + 1 = 2`.\nThe tree structure is checked. The root's children are the `NYT` node (weight 0) and the `S` node (weight 2). Since `weight(S) > weight(NYT)`, the `S` node remains the right child. The tree topology and the codes for `S` and `NYT` do not change. The root's weight is updated to `0 + 2 = 2`.\n\n**Step 3: Analyze all subsequent symbol transmissions**\nFor any subsequent transmission of the symbol `S` (from the 3rd symbol onwards), the process is identical to Step 2.\n- The symbol `S` is an \"existing\" symbol.\n- Its code remains `1`, because its weight will continue to increase, always being greater than the `NYT` node's weight of 0. No other symbols are introduced, so the tree structure will never change beyond the `S` node's weight updates.\n- Therefore, for every `S` from the second one to the N-th one, the encoder will transmit 1 bit.\n\n**Step 4: Formulate the total length function L(N)**\nThe total length $L(N)$ of the compressed output for a stream of `N` identical symbols is the sum of the bits from the first transmission and the bits from the subsequent `N-1` transmissions.\n- Bits for the 1st symbol: 8 bits.\n- Bits for each of the `N-1` subsequent symbols: 1 bit each.\n- Total bits for the `N-1` symbols: `(N - 1) * 1 = N - 1` bits.\n\nSo, the total length is:\n$$L(N) = 8 + (N - 1) = N + 7$$\n\n**Step 5: Calculate the required ratio**\nWe need to calculate the ratio $L(120) / L(40)$.\nUsing the formula for $L(N)$:\n- For $N = 120$: $L(120) = 120 + 7 = 127$ bits.\n- For $N = 40$: $L(40) = 40 + 7 = 47$ bits.\n\nThe ratio is:\n$$\\frac{L(120)}{L(40)} = \\frac{127}{47}$$\n\nNow, we compute the decimal value and round to three significant figures.\n$$\\frac{127}{47} \\approx 2.702127659...$$\nRounding to three significant figures gives `2.70`.", "answer": "$$\\boxed{2.70}$$", "id": "1601888"}, {"introduction": "The dynamic nature of the adaptive tree can lead to some non-intuitive behaviors. While the overall compression improves as the model learns, the codeword length for an individual symbol does not always strictly decrease. This final exercise [@problem_id:1601893] pushes you to explore this complexity, demonstrating how a symbol's code length can oscillate as its frequency rank shifts relative to other symbols in the stream.", "problem": "An adaptive Huffman coder based on the Faller-Gallager-Knuth (FGK) algorithm is used to compress a stream of symbols from the alphabet `{A, B, C, D}`. The coder starts with an empty tree, containing only a special Not Yet Transmitted (NYT) node of weight 0.\n\nWhen a symbol is transmitted, its frequency count (weight) is incremented. The tree is then updated to maintain the sibling property, which ensures that nodes are ordered by weight. For this problem, you can assume the update procedure results in a tree structure that is always equivalent to a canonical Huffman tree constructed from the current symbol weights and the single NYT node (which always has a weight of 0). The codeword length of a symbol is its depth in this tree (with the root at depth 0).\n\nYour task is to identify a sequence from the options below that causes the codeword length of the symbol `C` to exhibit a specific pattern of change. Specifically, after the initial transmission of `C` establishes its first codeword length, the sequence of subsequent symbols must cause the length to first **increase**, then **decrease**, and finally **increase** again.\n\nWhich of the following is the shortest sequence that produces this oscillatory behavior in the codeword length of `C`?\n\nA. `ABCACA`\n\nB. `AABBCC`\n\nC. `ABCABC`\n\nD. `ACBCBA`\n\nE. `ABCCBA`", "solution": "We model the adaptive FGK update, as allowed, by reconstructing after each transmitted symbol a canonical Huffman tree from the current symbol weights together with a single NYT leaf of weight $0$. The codeword length of a symbol equals its depth (root at depth $0$). To make the construction deterministic under ties, we adopt the following standard tie rule: at each Huffman merge step, pick the two nodes of least weight; for equal weights, break ties by the lexicographically smallest symbol contained in the node’s leaf set, using the order $A<B<C<D<\\text{NYT}$. This yields a unique tree (and hence a unique codeword length) at each step.\n\nWe must find the shortest listed sequence in which, after the first transmission of $C$ establishes its initial length, the subsequent lengths of $C$ change in the pattern increase, then decrease, then increase. All given options have length $6$, so we identify the sequences that realize the desired pattern and then select among them.\n\nConsider option A: $ABCACA$. The first occurrence of $C$ is at step $3$. We compute $L_{C}$ (the codeword length of $C$) after steps $3,4,5,6$.\n\n- After step $3$ (weights $A:1,B:1,C:1,\\text{NYT}:0$): Merge $(0,\\text{NYT})$ with $(1,A)$ to form $X_{1}$ of weight $1$; merge $X_{1}(1)$ with $(1,B)$ to form $X_{2}(2)$; finally merge $X_{2}(2)$ with $(1,C)$ to the root. Thus $C$ is a child of the root and $L_{C}=1$.\n- After step $4$ (symbol $A$, weights $A:2,B:1,C:1,\\text{NYT}:0$): Merge $(0,\\text{NYT})$ with $(1,B)$ to $X_{1}(1)$; merge $X_{1}(1)$ with $(1,C)$ to $X_{2}(2)$; merge $X_{2}(2)$ with $(2,A)$ to the root. Here $A$ is at depth $1$ and $C$ is in $X_{2}$ at depth $2$, so $L_{C}=2$ (increase from $1$).\n- After step $5$ (symbol $C$, weights $A:2,B:1,C:2,\\text{NYT}:0$): Merge $(0,\\text{NYT})$ with $(1,B)$ to $X_{1}(1)$; merge $X_{1}(1)$ with $(2,A)$ to $X_{2}(3)$; merge $X_{2}(3)$ with $(2,C)$ to the root. Then $C$ is a child of the root, so $L_{C}=1$ (decrease from $2$).\n- After step $6$ (symbol $A$, weights $A:3,B:1,C:2,\\text{NYT}:0$): Merge $(0,\\text{NYT})$ with $(1,B)$ to $X_{1}(1)$; merge $X_{1}(1)$ with $(2,C)$ to $X_{2}(3)$; merge $X_{2}(3)$ with $(3,A)$ to the root. Now $A$ is at depth $1$ and $C$ is in $X_{2}$ at depth $2$, so $L_{C}=2$ (increase from $1$).\n\nThus, for option A, after the first appearance of $C$, the sequence of lengths is $1 \\to 2 \\to 1 \\to 2$, which is increase, then decrease, then increase as required.\n\nWe now check that no other option provides the required pattern:\n\n- Option B: $AABBCC$. The first $C$ appears at step $5$, leaving only one subsequent symbol; three oscillations are impossible.\n- Option C: $ABCABC$. After the first $C$ (step $3$), the subsequent $L_{C}$ values are $1 \\to 2 \\to 3 \\to 1$, which is increase, increase, decrease, not the desired increase, decrease, increase.\n- Option D: $ACBCBA$. After the first $C$ (step $2$), recomputations give $L_{C}$ staying at $1$ through the end; no oscillation occurs.\n- Option E: $ABCCBA$. After the first $C$ (step $3$), $L_{C}$ does not realize the required increase, decrease, increase pattern.\n\nTherefore, among the provided sequences, option A is the (and hence the shortest) sequence that produces the required oscillatory behavior of the codeword length of $C$.", "answer": "$$\\boxed{A}$$", "id": "1601893"}]}