{"hands_on_practices": [{"introduction": "This exercise serves as a foundational practice for understanding the Lempel-Ziv-Welch (LZW) algorithm. In this problem ([@problem_id:1636836]), you will manually trace the encoding of a simple string, gaining hands-on experience with the core mechanics of LZW: identifying the longest dictionary match, generating output codes, and dynamically updating the dictionary. This step-by-step simulation is crucial for building a solid grasp of how LZW achieves compression.", "problem": "The Lempel-Ziv-Welch (LZW) algorithm is a universal lossless data compression algorithm. Its operation relies on building a dictionary of strings encountered during the compression process. The compression proceeds as follows:\n\n1.  Initialize the dictionary with a set of predefined strings and their corresponding codes.\n2.  Start with an empty 'current string' `S`.\n3.  Read the next character `C` from the input stream.\n4.  Consider the new string `S + C` (the current string appended with the new character).\n5.  If `S + C` is already in the dictionary, update the current string: `S = S + C`.\n6.  If `S + C` is not in the dictionary:\n    a) Add `S + C` to the dictionary with the next available integer code.\n    b) Output the code for the current string `S`.\n    c) Reset the current string to be just the character `C`, i.e., `S = C`.\n7.  Repeat from step 3 until the end of the input stream is reached.\n8.  After the loop terminates, output the code for the final 'current string' `S`.\n\nConsider an LZW compressor with an initial dictionary containing only two entries: `A` is assigned code `0`, and `B` is assigned code `1`. The codes for new dictionary entries start from `2` and are assigned sequentially.\n\nDetermine the sequence of output codes generated by this LZW compressor for the input string `BBAABABB`. Present your answer as a sequence of integers.", "solution": "Initialize the dictionary with $D(\\text{A})=0$ and $D(\\text{B})=1$. Let the next available code be $n=2$. Start with the current string $S$ empty.\n\nRead the first character $C=\\text{B}$. Since $S$ is empty, the concatenation $S+C=\\text{B}$ is in the dictionary, so update $S=\\text{B}$.\n\nRead the second character $C=\\text{B}$. Now $S+C=\\text{BB}$ is not in the dictionary. Add it: $D(\\text{BB})=2$ and update $n \\rightarrow 3$. Output the code for the current string $S$, which is $D(\\text{B})=1$. Reset $S=C=\\text{B}$.\n\nRead the third character $C=\\text{A}$. Now $S+C=\\text{BA}$ is not in the dictionary. Add it: $D(\\text{BA})=3$ and update $n \\rightarrow 4$. Output $D(\\text{B})=1$. Reset $S=C=\\text{A}$.\n\nRead the fourth character $C=\\text{A}$. Now $S+C=\\text{AA}$ is not in the dictionary. Add it: $D(\\text{AA})=4$ and update $n \\rightarrow 5$. Output $D(\\text{A})=0$. Reset $S=C=\\text{A}$.\n\nRead the fifth character $C=\\text{B}$. Now $S+C=\\text{AB}$ is not in the dictionary. Add it: $D(\\text{AB})=5$ and update $n \\rightarrow 6$. Output $D(\\text{A})=0$. Reset $S=C=\\text{B}$.\n\nRead the sixth character $C=\\text{A}$. Now $S+C=\\text{BA}$ is in the dictionary (with code $3$), so update $S=\\text{BA}$.\n\nRead the seventh character $C=\\text{B}$. Now $S+C=\\text{BAB}$ is not in the dictionary. Add it: $D(\\text{BAB})=6$ and update $n \\rightarrow 7$. Output $D(\\text{BA})=3$. Reset $S=C=\\text{B}$.\n\nRead the eighth character $C=\\text{B}$. Now $S+C=\\text{BB}$ is in the dictionary (with code $2$), so update $S=\\text{BB}$.\n\nEnd of input: output the code for the final current string $S$, which is $D(\\text{BB})=2$.\n\nCollecting the outputs in order gives the sequence $1, 1, 0, 0, 3, 2$.", "answer": "$$\\boxed{\\begin{pmatrix}1 & 1 & 0 & 0 & 3 & 2\\end{pmatrix}}$$", "id": "1636836"}, {"introduction": "Having mastered encoding, the next essential skill is understanding its inverse: decompression. This practice ([@problem_id:1636869]) guides you through reconstructing an original message from a sequence of LZW codes, a task central to any compression system. You will see how the decoder cleverly mirrors the encoder's logic to rebuild the dictionary on the fly, demonstrating the elegant symmetry that makes lossless decompression possible.", "problem": "A simplified data compression system uses the Lempel-Ziv-Welch (LZW) algorithm to encode text messages. The algorithm works by building a dictionary of strings encountered during compression. For the purpose of this problem, assume the following specific details about the LZW implementation:\n\n1.  The initial dictionary is pre-populated with entries for all 8-bit ASCII characters. This means the integer codes from 0 to 255 are mapped to their corresponding single-character strings.\n2.  The first available code for newly generated dictionary entries is 256.\n3.  The LZW encoder reads the longest string `S` from the input that is currently in the dictionary. It outputs the code for `S`. It then takes `S` plus the next character `C` from the input, `S+C`, and adds this new string to the dictionary with the next available numeric code.\n\nA compressed message fragment is received as a sequence of integer codes. The sequence is `[65, 66, 67, 256, 258]`. Reconstruct the original text message fragment from this sequence.", "solution": "We are asked to decode an LZW-compressed sequence of codes: `[65, 66, 67, 256, 258]`. We will use the standard LZW decoding algorithm, which mirrors the encoding process.\n\n**Initial State:**\n*   The dictionary contains entries for all ASCII characters from 0 to 255. For example, code `65` maps to the string 'A', `66` to 'B', and `67` to 'C'.\n*   The next available code to be added to the dictionary is `256`.\n*   The output string is initially empty.\n\nThe decoding algorithm proceeds as follows: read a code from the input, look up its corresponding string in the dictionary, and output that string. Then, create a new dictionary entry by concatenating the previously output string with the first character of the currently output string.\n\nLet's trace the decoding of the sequence `[65, 66, 67, 256, 258]`.\n\n**Step 1: Decode code `65`**\n*   Input code: `65`.\n*   From the initial dictionary, code `65` corresponds to the string 'A'.\n*   Output string: 'A'.\n*   The first code has been processed. We set `previous_string = 'A'`.\n*   Current decoded message: \"A\".\n\n**Step 2: Decode code `66`**\n*   Input code: `66`.\n*   From the initial dictionary, code `66` corresponds to the string 'B'. Let's call this `current_string`.\n*   Output string: 'B'.\n*   A new dictionary entry must be created. The new entry is `previous_string + first_character(current_string)`.\n*   `previous_string` is 'A'. `current_string` is 'B'. `first_character(current_string)` is 'B'.\n*   New string to add: 'A' + 'B' = \"AB\".\n*   This new string \"AB\" is added to the dictionary with the next available code, which is `256`. So, dictionary now contains `(256, \"AB\")`.\n*   Update `previous_string = current_string = 'B'`.\n*   Current decoded message: \"AB\".\n\n**Step 3: Decode code `67`**\n*   Input code: `67`.\n*   From the initial dictionary, code `67` corresponds to the string 'C'. Let's call this `current_string`.\n*   Output string: 'C'.\n*   Create a new dictionary entry: `previous_string + first_character(current_string)`.\n*   `previous_string` is 'B'. `current_string` is 'C'. `first_character(current_string)` is 'C'.\n*   New string to add: 'B' + 'C' = \"BC\".\n*   This new string \"BC\" is added to the dictionary with the next available code, which is `257`. So, dictionary now contains `(257, \"BC\")`.\n*   Update `previous_string = current_string = 'C'`.\n*   Current decoded message: \"ABC\".\n\n**Step 4: Decode code `256`**\n*   Input code: `256`.\n*   We look up code `256` in our dictionary. From Step 2, we know this corresponds to the string \"AB\". Let's call this `current_string`.\n*   Output string: \"AB\".\n*   Create a new dictionary entry: `previous_string + first_character(current_string)`.\n*   `previous_string` is 'C'. `current_string` is \"AB\". `first_character(current_string)` is 'A'.\n*   New string to add: 'C' + 'A' = \"CA\".\n*   This new string \"CA\" is added to the dictionary with the next available code, which is `258`. So, dictionary now contains `(258, \"CA\")`.\n*   Update `previous_string = current_string = \"AB\"`.\n*   Current decoded message: \"ABCAB\".\n\n**Step 5: Decode code `258`**\n*   Input code: `258`.\n*   We look up code `258` in our dictionary. From Step 4, we know this corresponds to the string \"CA\". Let's call this `current_string`.\n*   Output string: \"CA\".\n*   Create a new dictionary entry: `previous_string + first_character(current_string)`.\n*   `previous_string` is \"AB\". `current_string` is \"CA\". `first_character(current_string)` is 'C'.\n*   New string to add: \"AB\" + 'C' = \"ABC\".\n*   This new string \"ABC\" is added to the dictionary with the next available code, which is `259`. So, dictionary now contains `(259, \"ABC\")`.\n*   Update `previous_string = current_string = \"CA\"`.\n*   Current decoded message: \"ABCABCA\".\n\nThe input sequence is now fully processed. The concatenated output gives the original message.\n\nFinal Decoded String: 'A' + 'B' + 'C' + \"AB\" + \"CA\" = \"ABCABCA\".", "answer": "$$\\boxed{ABCABCA}$$", "id": "1636869"}, {"introduction": "This final practice moves beyond simple application to test your deeper analytical understanding of LZW's dictionary-building mechanism. Here ([@problem_id:1636859]), you are challenged to work backward from a specified final dictionary state to determine the shortest input string that could have produced it. This \"forensic\" approach solidifies your grasp of the precise cause-and-effect relationship between the input data and the evolution of the LZW dictionary.", "problem": "The Lempel-Ziv-Welch (LZW) data compression algorithm functions by processing an input string and building a dictionary of sequences it has encountered. The dictionary is initialized to contain all single characters of the source alphabet. For this problem, assume the alphabet is `{X, Y, Z}` and the initial dictionary contains entries for `X`, `Y`, and `Z`. New dictionary entries are assigned integer codes starting from 256.\n\nThe algorithm builds the dictionary using the following rule: it finds the longest string `w` already in the dictionary that matches the start of the current, unprocessed part of the input. Let `c` be the character immediately following this match in the input. The algorithm then adds a new entry for the string `w+c` to the dictionary.\n\nSuppose after processing a particular input string, the LZW encoder's dictionary contains, among others, the following three new entries which were created in the specified order:\n1.  Code 256: `XY`\n2.  Code 257: `YZ`\n3.  Code 258: `ZY`\n\nDetermine the shortest possible input string that could produce this state.", "solution": "Initialize the LZW dictionary with the single-character entries $\\{X, Y, Z\\}$ and let new codes start at $256$. The LZW update rule is: at each step, find the longest dictionary entry $w$ that matches the current input prefix; let $c$ be the next character in the input immediately following $w$; then add the new entry $w+c$ to the dictionary.\n\nTo force the first new entry to be $256: XY$, the input must begin with $X$ followed by $Y$, because at the very first step only single-character entries exist, so with input starting $XY\\cdots$, the longest initial match is $w=X$ and the next character is $c=Y$, which adds $w+c=XY$ as code $256$. After this addition, the algorithm sets $w=Y$.\n\nTo force the second new entry to be $257: YZ$, the next character must be $Z$. With the input now starting as $XYZ\\cdots$, at the next step the longest match is $w=Y$ and the next character is $c=Z$, so the algorithm adds $w+c=YZ$ as code $257$ and sets $w=Z$.\n\nTo force the third new entry to be $258: ZY$, the next character must be $Y$. With input $XYZY\\cdots$, at the next step the longest match is $w=Z$ and the next character $c=Y$, so the algorithm adds $w+c=ZY$ as code $258$.\n\nA minimality argument shows this is shortest: starting from a dictionary containing only single-character entries, the first addition requires at least two input characters, and each subsequent addition requires at least one more new character. Therefore, to obtain three additions, at least four characters are needed. The string $XYZY$ accomplishes the required additions in order: \n- Step 1 on $X|Y\\cdots$ adds $XY$ as $256$, \n- Step 2 on $Y|Z\\cdots$ adds $YZ$ as $257$, \n- Step 3 on $Z|Y$ adds $ZY$ as $258$.\nThus the shortest possible input string is $XYZY$.", "answer": "$$\\boxed{XYZY}$$", "id": "1636859"}]}