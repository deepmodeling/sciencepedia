{"hands_on_practices": [{"introduction": "Arithmetic coding is a powerful method for data compression that represents an entire sequence of symbols as a single fraction. The core idea is to recursively partition the initial interval $[0, 1)$ into smaller sub-intervals, where the size of each sub-interval is proportional to the probability of the corresponding symbol. This first exercise [@problem_id:1602900] provides a foundational walkthrough of the encoding process, allowing you to manually calculate how a sequence is mapped to its unique final interval.", "problem": "Arithmetic coding is a powerful data compression technique that represents an entire sequence of symbols as a single fraction in the interval $[0, 1)$. Consider a simplified source model for telemetry data from a planetary probe. The source emits symbols from the alphabet $\\{A, B, C\\}$ with the following fixed probabilities: $P(A) = 0.5$, $P(B) = 0.3$, and $P(C) = 0.2$.\n\nThe arithmetic coding algorithm starts with the interval $[0, 1)$ and iteratively narrows it based on the symbols in the input sequence. For the input sequence 'BCA', determine the final interval $[L, H)$ that represents this sequence.\n\nProvide the exact decimal values for the lower bound $L$ and the upper bound $H$ of the final interval.", "solution": "Arithmetic coding starts with the full interval $[0,1)$ and iteratively refines it using the source model. Let $L$ and $H$ denote the current lower and upper bounds, and let $W = H - L$ be the current width. For a symbol $s$ with cumulative distribution function $F(s)$ (the cumulative probability up to but not including $s$) and probability $p(s)$, the update is\n$$\nL' = L + W \\, F(s), \\quad H' = L + W \\, \\big(F(s) + p(s)\\big).\n$$\nUsing the given probabilities $P(A) = 0.5$, $P(B) = 0.3$, $P(C) = 0.2$, the cumulative ranges in the order $\\{A,B,C\\}$ are:\n$$\nA: [0, 0.5), \\quad B: [0.5, 0.8), \\quad C: [0.8, 1).\n$$\nStart with $[L_{0}, H_{0}) = [0, 1)$, so $W_{0} = 1$.\n\nFor the first symbol $B$, we have $F(B) = 0.5$ and $p(B) = 0.3$. Therefore,\n$$\nL_{1} = 0 + 1 \\cdot 0.5 = 0.5, \\quad H_{1} = 0 + 1 \\cdot (0.5 + 0.3) = 0.8,\n$$\nso the interval is $[0.5, 0.8)$ with width $W_{1} = 0.3$.\n\nFor the second symbol $C$, we have $F(C) = 0.8$ and $p(C) = 0.2$. Using $L_{1} = 0.5$ and $W_{1} = 0.3$,\n$$\nL_{2} = 0.5 + 0.3 \\cdot 0.8 = 0.74, \\quad H_{2} = 0.5 + 0.3 \\cdot 1 = 0.8,\n$$\nso the interval is $[0.74, 0.8)$ with width $W_{2} = 0.06$.\n\nFor the third symbol $A$, we have $F(A) = 0$ and $p(A) = 0.5$. Using $L_{2} = 0.74$ and $W_{2} = 0.06$,\n$$\nL_{3} = 0.74 + 0.06 \\cdot 0 = 0.74, \\quad H_{3} = 0.74 + 0.06 \\cdot 0.5 = 0.77.\n$$\nTherefore, the final interval representing the sequence 'BCA' is $[0.74, 0.77)$. As a consistency check, the final width is $0.77 - 0.74 = 0.03$, which equals $1 \\cdot 0.3 \\cdot 0.2 \\cdot 0.5$ as expected.", "answer": "$$\\boxed{\\begin{pmatrix}0.74  0.77\\end{pmatrix}}$$", "id": "1602900"}, {"introduction": "The power of arithmetic coding lies not just in encoding but also in its perfectly reversible decoding process. If the decoder knows the same probability model, it can take the compressed fractional value and uniquely reconstruct the original sequence of symbols. This practice [@problem_id:1602946] reverses the perspective, challenging you to step into the role of the decoder and determine the original message from a received code value.", "problem": "A lossless data compression system is designed to transmit real-time data from a remote environmental sensor. The sensor's output is one of three possible states, denoted by the symbols in the set $\\{S_1, S_2, S_3\\}$. Based on extensive historical data, the stationary probabilities of these states occurring are known to be $P(S_1) = 0.6$, $P(S_2) = 0.3$, and $P(S_3) = 0.1$.\n\nThe system employs an ideal arithmetic coder, which maps an entire sequence of source symbols to a single fractional value represented in binary. A receiver intercepts a transmission and begins to decode the incoming message. The first part of the received binary code is $0.1011_2$.\n\nBased on the model probabilities and the received code, determine the first two symbols of the original message sequence. Select the correct sequence from the options below.\n\nA. $S_1, S_1$\n\nB. $S_1, S_2$\n\nC. $S_2, S_1$\n\nD. $S_2, S_3$\n\nE. $S_3, S_1$", "solution": "In ideal arithmetic coding for an i.i.d. source with symbol set $\\{S_{1},S_{2},S_{3}\\}$ and probabilities $P(S_{1})=\\frac{3}{5}$, $P(S_{2})=\\frac{3}{10}$, $P(S_{3})=\\frac{1}{10}$, the unit interval $[0,1)$ is partitioned using cumulative distribution boundaries\n$$\nF_{0}=0,\\quad F_{1}=\\frac{3}{5},\\quad F_{2}=\\frac{9}{10},\\quad F_{3}=1.\n$$\nThus the first-symbol intervals are $[0,\\frac{3}{5})$ for $S_{1}$, $[\\frac{3}{5},\\frac{9}{10})$ for $S_{2}$, and $[\\frac{9}{10},1)$ for $S_{3}$. An arithmetic code value $r$ represents the entire message and lies in $[0,1)$. Knowing only the first four received bits $0.1011_{2}$ means $r$ is constrained to the interval\n$$\n\\left[0.1011_{2},\\,0.1011_{2}+2^{-4}\\right]=\\left[\\frac{11}{16},\\,\\frac{3}{4}\\right).\n$$\nSince $\\left[\\frac{11}{16},\\,\\frac{3}{4}\\right)\\subset\\left[\\frac{3}{5},\\,\\frac{9}{10}\\right)$, the first symbol must be $S_{2}$.\n\nFor the second symbol, arithmetic decoding refines the current interval using the update rule: if the current interval is $[l,u)$ with width $W=u-l$, then selecting symbol $S_{i}$ maps to\n$$\n\\left[l+W F_{i-1},\\,l+W F_{i}\\right).\n$$\nAfter decoding $S_{2}$ first, the current interval is $[l,u)=\\left[\\frac{3}{5},\\,\\frac{9}{10}\\right)$ with width $W=\\frac{9}{10}-\\frac{3}{5}=\\frac{3}{10}$. Partitioning this interval for the second symbol gives:\n- $S_{1}$: \n$$\n\\left[\\frac{3}{5},\\,\\frac{3}{5}+ \\frac{3}{10}\\cdot\\frac{3}{5}\\right]=\\left[\\frac{3}{5},\\,\\frac{39}{50}\\right),\n$$\n- $S_{2}$:\n$$\n\\left[\\frac{39}{50},\\,\\frac{39}{50}+ \\frac{3}{10}\\cdot\\frac{3}{10}\\right]=\\left[\\frac{39}{50},\\,\\frac{87}{100}\\right),\n$$\n- $S_{3}$:\n$$\n\\left[\\frac{87}{100},\\,\\frac{9}{10}\\right).\n$$\nThe received value range $\\left[\\frac{11}{16},\\,\\frac{3}{4}\\right)$ lies entirely within $\\left[\\frac{3}{5},\\,\\frac{39}{50}\\right)$, so the second symbol is $S_{1}$.\n\nTherefore, the first two symbols are $S_{2}, S_{1}$, corresponding to option C.", "answer": "$$\\boxed{C}$$", "id": "1602946"}, {"introduction": "While our first two examples used a static probability model, real-world applications often employ adaptive models where symbol frequencies are updated on the fly. This adaptation makes the coder more efficient for sources with changing statistics, but it introduces a new challenge: how to maintain and query these changing frequencies efficiently? This final problem [@problem_id:1602938] moves from pure theory to implementation, asking you to analyze the computational complexity of two different data structures used in adaptive arithmetic coding, a critical consideration for building fast and practical compressors.", "problem": "An adaptive arithmetic coder is being designed to compress data from a source with a fixed, known alphabet of size $k$. The symbols in the alphabet are indexed from $1$ to $k$. In adaptive coding, the frequency counts of symbols are updated dynamically as the input stream is processed. Specifically, after each symbol is encoded, its frequency count is incremented by one. Initially, all symbols are assumed to have a frequency count of one.\n\nThe core of the arithmetic coding algorithm relies on a cumulative frequency table, which is used to partition the interval $[0, 1)$ into sub-intervals corresponding to each symbol. The width of a symbol's sub-interval is proportional to its relative frequency. To encode a given symbol, the coder needs to determine its current sub-interval, which requires looking up the cumulative frequencies of the symbols that precede it. After the encoding, the frequency table must be updated.\n\nWe are considering two different data structures for maintaining the frequency information. Let $T_A(k)$ and $T_B(k)$ be the worst-case asymptotic time complexities for processing a single symbol (both encoding and updating the model) for Method A and Method B, respectively.\n\n**Method A**: A simple array of size $k$ is used to store the **cumulative** frequencies. The $i$-th element of the array stores the sum of frequencies of symbols from $1$ to $i$.\n\n**Method B**: A Fenwick tree (also known as a Binary Indexed Tree), which operates on an array of size $k$, is used to store the **individual** frequency count of each symbol.\n\nWhat is the pair of time complexities $(T_A(k), T_B(k))$?\n\nA. $(O(k), O(\\log k))$\n\nB. $(O(k), O(k))$\n\nC. $(O(\\log k), O(k))$\n\nD. $(O(\\log k), O(\\log k))$\n\nE. $(O(k \\log k), O(k))$\n\nF. $(O(1), O(\\log k))$", "solution": "We need the worst-case time to process a single symbol, consisting of:\n1) Encoding: obtain the current sub-interval, which requires cumulative frequencies up to the symbol and up to the previous symbol.\n2) Model update: increment the symbolâ€™s frequency by one, and reflect this in the maintained data structure.\n\nMethod A (array of cumulative frequencies):\n- Let $C[i]$ store the sum of individual frequencies for symbols $1$ through $i$. For encoding symbol index $i$, we need $C[i-1]$ and $C[i]$, which are each a direct array access, so encoding costs $O(1)$ time.\n- Updating the model after increasing the individual frequency of symbol $i$ by $1$ requires incrementing all cumulative entries from $i$ through $k$: for all $j \\in \\{i,i+1,\\dots,k\\}$, set $C[j] \\leftarrow C[j] + 1$. This costs $k-i+1$ increments in the worst case, which is $O(k)$.\n- Therefore, the per-symbol worst-case time is $T_{A}(k)=O(k)$.\n\nMethod B (Fenwick tree over individual frequencies):\n- A Fenwick tree supports prefix-sum queries and point updates in $O(\\log k)$ time due to its binary lifting structure with height $O(\\log k)$.\n- For encoding symbol index $i$, we need the cumulative sums up to $i-1$ and up to $i$, i.e., two prefix-sum queries, each costing $O(\\log k)$. Thus encoding is $O(\\log k)$.\n- Updating the model is a point update to increase the frequency of symbol $i$ by $1$, which costs $O(\\log k)$.\n- Therefore, the per-symbol worst-case time is $T_{B}(k)=O(\\log k)$.\n\nHence, the pair is $(O(k), O(\\log k))$, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1602938"}]}