{"hands_on_practices": [{"introduction": "Understanding a compression algorithm involves not only knowing how it works but also when it is effective. This first exercise [@problem_id:1655653] provides a practical application of Run-Length Encoding (RLE) to a simple image pattern. By calculating the compression ratio for a highly non-repetitive sequence, you will gain firsthand insight into the performance limits of RLE and discover the critical concept of data expansion, where the \"compressed\" output can be larger than the original.", "problem": "Run-Length Encoding (RLE) is a simple form of lossless data compression where sequences of the same data value occurring in a row are stored as a single data value and count, rather than as the original run.\n\nConsider a monochrome digital image represented by a grid of pixels. Each pixel is represented by a single bit: '0' for a white pixel and '1' for a black pixel. For this image, an RLE scheme is used where a run of `n` identical pixels (of value `s`) is encoded as a pair. The run count `n` is stored as a 5-bit unsigned integer, and the pixel value `s` is stored as a 1-bit value.\n\nThe image is a $16 \\times 16$ pixel checkerboard. The pixel at the top-left corner (row 0, column 0) is white. We are interested in compressing the first horizontal scanline of this image (row 0).\n\nThe compression ratio is defined as the ratio of the original data size (in bits) to the compressed data size (in bits).\n\nCalculate the compression ratio for the first scanline of this checkerboard image. Express your answer as a decimal, rounded to three significant figures.", "solution": "A $16 \\times 16$ checkerboard with the top-left pixel white alternates pixel values along each row. For the first scanline (row 0), the pixel pattern is $0,1,0,1,\\ldots$ with no two adjacent pixels equal.\n\nOriginal data size in bits for the scanline:\n$$\nB_{o} = 16 \\times 1 = 16.\n$$\nSince every pixel alternates, each run has length $n=1$, and there are $R=16$ runs. Each run is encoded using $5$ bits for the count and $1$ bit for the pixel value, totaling $6$ bits per run. Thus the compressed size is\n$$\nB_{c} = R \\times 6 = 16 \\times 6 = 96.\n$$\nThe compression ratio (original size divided by compressed size) is\n$$\nC = \\frac{B_{o}}{B_{c}} = \\frac{16}{96} = \\frac{1}{6}.\n$$\nAs a decimal rounded to three significant figures:\n$$\nC \\approx 0.167.\n$$", "answer": "$$\\boxed{0.167}$$", "id": "1655653"}, {"introduction": "Simple RLE can be inefficient for data with many short runs, as seen in the previous exercise. To address this, practical implementations often use modified schemes that apply compression more selectively. This problem [@problem_id:1655629] introduces you to a \"Selective Run-Length Encoding\" (SRLE) algorithm that only compresses runs above a certain length, offering a more nuanced and often more effective approach to compression.", "problem": "A new lossless data compression algorithm, called Selective Run-Length Encoding (SRLE), has been designed to compress binary data streams. The algorithm operates by segmenting the input stream into runs of consecutive identical bits and encoding each run based on its length.\n\nThe rules for SRLE are as follows:\n1.  A run of length $L < 3$ is classified as a \"short run\". Short runs are considered incompressible and are written to the output stream verbatim, without any modification.\n2.  A run of length $L \\ge 3$ is classified as a \"long run\". Long runs are compressed into a fixed-length 8-bit code word. This code word is constructed by concatenating three parts:\n    *   A 3-bit marker sequence `111`.\n    *   A single bit representing the digit of the run (`0` for a run of zeros, `1` for a run of ones).\n    *   A 4-bit unsigned binary integer representing the length $L$ of the run. This format can represent lengths from 0 to 15.\n\nYou are given the following 21-bit binary sequence $S$:\n$$S = 110000010011111111110$$\n\nCalculate the total length, in bits, of the compressed binary sequence generated by applying this SRLE scheme to the sequence $S$.", "solution": "The problem requires us to apply the Selective Run-Length Encoding (SRLE) algorithm to a given binary sequence $S$ and determine the total length of the resulting compressed sequence. We must first parse the input sequence into runs of identical bits and then apply the appropriate rule for each run.\n\nThe input sequence is $S = 110000010011111111110$.\n\nFirst, we segment $S$ into consecutive runs of identical bits:\n*   Run 1: `11` (A run of ones, length 2)\n*   Run 2: `00000` (A run of zeros, length 5)\n*   Run 3: `1` (A run of one, length 1)\n*   Run 4: `00` (A run of zeros, length 2)\n*   Run 5: `1111111111` (A run of ones, length 10)\n*   Run 6: `0` (A run of zero, length 1)\n\nNext, we process each run according to the SRLE rules and calculate the length of its compressed representation.\n\n**Run 1:** `11`\nThe length of this run is $L=2$. According to the rules, since $L < 3$, this is a \"short run\". It is written to the output verbatim.\nThe compressed representation is `11`.\nThe length of this compressed part is 2 bits.\n\n**Run 2:** `00000`\nThe length of this run is $L=5$. Since $L \\ge 3$, this is a \"long run\" and must be encoded. The encoding consists of:\n1.  The 3-bit marker: `111`.\n2.  The bit for the digit: `0`.\n3.  The 4-bit binary representation of the length $L=5$: `0101`.\nThe full encoded representation is `11100101`.\nThe length of this compressed part is $3 + 1 + 4 = 8$ bits.\n\n**Run 3:** `1`\nThe length of this run is $L=1$. Since $L < 3$, this is a \"short run\". It is written verbatim.\nThe compressed representation is `1`.\nThe length of this compressed part is 1 bit.\n\n**Run 4:** `00`\nThe length of this run is $L=2$. Since $L < 3$, this is a \"short run\". It is written verbatim.\nThe compressed representation is `00`.\nThe length of this compressed part is 2 bits.\n\n**Run 5:** `1111111111`\nThe length of this run is $L=10$. Since $L \\ge 3$, this is a \"long run\" and must be encoded. The encoding consists of:\n1.  The 3-bit marker: `111`.\n2.  The bit for the digit: `1`.\n3.  The 4-bit binary representation of the length $L=10$: `1010`.\nThe full encoded representation is `11111010`.\nThe length of this compressed part is $3 + 1 + 4 = 8$ bits.\n\n**Run 6:** `0`\nThe length of this run is $L=1$. Since $L < 3$, this is a \"short run\". It is written verbatim.\nThe compressed representation is `0`.\nThe length of this compressed part is 1 bit.\n\nFinally, to find the total length of the compressed sequence, we sum the lengths of all the individual compressed parts.\nTotal Length = (Length from Run 1) + (Length from Run 2) + (Length from Run 3) + (Length from Run 4) + (Length from Run 5) + (Length from Run 6)\nTotal Length = $2 + 8 + 1 + 2 + 8 + 1 = 22$ bits.\n\nThe original sequence was 21 bits long, and the compressed sequence is 22 bits long. In this case, the \"compression\" algorithm actually increased the data size, which is possible for certain input sequences with lossless algorithms.", "answer": "$$\\boxed{22}$$", "id": "1655629"}, {"introduction": "Beyond lossless methods, we can sometimes achieve much greater compression by allowing a small, controlled number of errors. This final practice [@problem_id:1655600] transforms RLE into an optimization puzzle, challenging you to find the best way to use a limited \"budget\" of bit-flips to merge runs and minimize their total count. This exercise bridges the gap between basic compression and more advanced algorithmic strategies used in lossy data processing.", "problem": "In digital communications and data storage, Run-Length Encoding (RLE) is a simple form of lossless data compression. The basic principle is to replace consecutive sequences of identical symbols, known as \"runs,\" with a pair consisting of the symbol and the length of the run. For instance, the binary sequence `000011100` would be encoded as three runs: `(0, 4)`, `(1, 3)`, and `(0, 2)`.\n\nTo further enhance compression, one might consider introducing a limited number of bit-flips into a binary data stream. This is particularly relevant in applications where the data can tolerate minor errors, such as in image or sensor data processing. By strategically flipping a small number of bits, it may be possible to merge adjacent runs of the same symbol, thereby reducing the total number of runs required to represent the data. For example, the sequence `111011` consists of three runs. By flipping the single `0` to a `1` (at the cost of one flip), the sequence becomes `111111`, which is a single run.\n\nYou are given a binary data sequence $S$ of length $N$ and an integer $D$ representing the maximum number of bit-flips you are allowed to perform. Your task is to calculate the absolute minimum number of runs that the sequence can be represented by, using no more than $D$ flips.\n\nFor the specific binary sequence $S = \\text{\"0110100011\"}$ and a maximum flip budget of $D=2$, what is the minimum number of runs achievable?", "solution": "Let the binary string be $S = 0110100011$ of length $N=10$. First count the initial runs by grouping consecutive equal bits:\n$$0^{1},\\ 1^{2},\\ 0^{1},\\ 1^{1},\\ 0^{3},\\ 1^{2}$$\nso the initial number of runs is $R_{0}=6$.\n\nA run boundary is a transition between adjacent bits. The number of runs equals the number of transitions plus $1$. Flipping a single bit can affect at most the two adjacent transitions, hence one flip can reduce the number of runs by at most $2$ (this maximum happens only when flipping the middle bit of a pattern $a\\,b\\,a$ with $a \\neq b$ and both neighbors equal). Therefore, with $D=2$ flips, a theoretical lower bound is\n$$R \\geq R_{0} - 2D = 6 - 4 = 2.$$\nWe now determine whether $R=2$ is achievable.\n\nA binary string with exactly $2$ runs must be of the form $0^{k}1^{N-k}$ or $1^{k}0^{N-k}$ for some cut index $k \\in \\{0,1,\\dots,N\\}$. The minimum flips needed to transform $S$ into $0^{k}1^{N-k}$ is\n$$F(k) = \\underbrace{O[k]}_{\\text{ones in first }k\\text{ turned to }0} + \\underbrace{\\big((N-k) - (O[N]-O[k])\\big)}_{\\text{zeros in last }N-k\\text{ turned to }1} = N - O[N] - k + 2O[k],$$\nwhere $O[k]$ is the number of ones in the prefix of length $k$, and here $N=10$ and $O[N]=5$, so\n$$F(k) = 5 - k + 2O[k].$$\nSimilarly, the minimum flips to transform $S$ into $1^{k}0^{N-k}$ is\n$$G(k) = \\underbrace{(k - O[k])}_{\\text{zeros in first }k\\text{ turned to }1} + \\underbrace{(O[N]-O[k])}_{\\text{ones in last }N-k\\text{ turned to }0} = k + 5 - 2O[k].$$\n\nCompute the prefix-one counts $O[k]$ from $S=0,1,1,0,1,0,0,0,1,1$:\n$$O[0]=0,\\ O[1]=0,\\ O[2]=1,\\ O[3]=2,\\ O[4]=2,\\ O[5]=3,\\ O[6]=3,\\ O[7]=3,\\ O[8]=3,\\ O[9]=4,\\ O[10]=5.$$\nThus\n$$F(k) = 5 - k + 2O[k] \\text{ takes values } (5,4,5,6,5,6,5,4,3,4,5),$$\n$$G(k) = k + 5 - 2O[k] \\text{ takes values } (5,6,5,4,5,4,5,6,7,6,5),$$\nfor $k=0,1,\\dots,10$, respectively. The minima are $\\min_{k} F(k)=3$ and $\\min_{k} G(k)=4$. Therefore, achieving $2$ runs would require at least $3$ flips, which exceeds the budget $D=2$. Hence $R=2$ is impossible.\n\nIt remains to show that $R=3$ is achievable with $2$ flips. For example, by flipping the bit at index 0 from $0$ to $1$, the sequence becomes `1110100011`, whose runs are $1^{3},0^{1},1^{1},0^{3},1^{2}$ (that is $5$ runs). Then, flipping the bit at index 3 of this new string from $0$ to $1$ yields `1111100011`, which has runs $1^{5},0^{3},1^{2}$, hence exactly $3$ runs. Therefore, with $D=2$ flips, the absolute minimum number of runs is $3$.", "answer": "$$\\boxed{3}$$", "id": "1655600"}]}