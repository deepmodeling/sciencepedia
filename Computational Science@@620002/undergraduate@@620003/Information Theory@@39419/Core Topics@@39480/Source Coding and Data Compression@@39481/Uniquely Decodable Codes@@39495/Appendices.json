{"hands_on_practices": [{"introduction": "A crucial first step in information theory is mastering the ability to determine if a code is uniquely decodable. This exercise provides a diverse set of codes, challenging you to apply different tests for unique decodability. You will need to distinguish between prefix-free codes (which are always uniquely decodable), non-prefix codes that are still uniquely decodable, and those that are ambiguous, providing a comprehensive workout of this fundamental skill [@problem_id:1666431].", "problem": "In information theory, a code is a set of codewords, each representing a symbol from a source alphabet. A code is defined as **uniquely decodable** if any finite sequence of codewords concatenated together can be parsed into its constituent codewords in only one way. For example, the code `C = {\"0\", \"10\", \"11\"}` is uniquely decodable. A string like `10011` can only be decoded as `(10)(0)(11)`. In contrast, a code is **not uniquely decodable** if there exists at least one sequence of symbols that has two or more distinct decodings. For example, `C' = {\"0\", \"1\", \"01\"}` is not uniquely decodable because the string `01` can be interpreted as the single codeword `(01)` or as the sequence of two codewords `(0)(1)`.\n\nConsider the following codes, where the codewords are the strings given in each set. Identify all the codes that are uniquely decodable.\n\nA. $C_A = \\{\\text{\"the\", \"then\", \"end\"}\\}$\n\nB. $C_B = \\{\\text{\"0\", \"10\", \"01\"}\\}$\n\nC. $C_C = \\{\\text{\"10\", \"00\", \"110\"}\\}$\n\nD. $C_D = \\{\\text{\"a\", \"ab\", \"b\"}\\}$\n\nSelect all options that represent uniquely decodable codes. Your answer should be a string concatenating the letters of the correct options in alphabetical order (e.g., `BD` if you find options B and D to be correct).", "solution": "We use the Sardinas–Patterson algorithm and basic prefix-code logic to test unique decodability. A code is prefix-free (and thus uniquely decodable) if no codeword is a prefix of another. For other codes, we compute the Sardinas–Patterson sets of suffixes. If any of these suffix sets contains an original codeword, the code is not uniquely decodable. If the process terminates without this occurring, the code is uniquely decodable.\n\nOption A: $C_A = \\{\\text{\"the\", \"then\", \"end\"}\\}$.\n- \"the\" is a prefix of \"then\", leaving the residual suffix \"n\". Thus the first suffix set is $S_1 = \\{\\text{\"n\"}\\}$.\n- No codeword begins with \"n\", and no new suffix can be formed from \"n\". Hence the next suffix set $S_2$ is empty, and the process terminates. The code is uniquely decodable.\nConclusion: $C_A$ is uniquely decodable.\n\nOption B: $C_B = \\{\\text{\"0\", \"10\", \"01\"}\\}$.\n- \"0\" is a prefix of \"01\", leaving the residual suffix \"1\". So the first suffix set is $S_1 = \\{\\text{\"1\"}\\}$.\n- The codeword \"10\" begins with this suffix \"1\", leaving a new residual \"0\". Thus, the second suffix set is $S_2 = \\{\\text{\"0\"}\\}$.\n- Since \"0\" is an element of the original code $C_B$, the code is not uniquely decodable.\nAn explicit ambiguity is the string 010, which can be parsed as (0)(10) or as (01)(0).\nConclusion: $C_B$ is not uniquely decodable.\n\nOption C: $C_C = \\{\\text{\"10\", \"00\", \"110\"}\\}$.\n- No codeword is a prefix of another; the code is prefix-free.\nConclusion: Every prefix-free code is uniquely decodable, so $C_C$ is uniquely decodable.\n\nOption D: $C_D = \\{\\text{\"a\", \"ab\", \"b\"}\\}$.\n- The string \"ab\" has two decodings: (ab) and (a)(b).\nConclusion: $C_D$ is not uniquely decodable.\n\nTherefore, the uniquely decodable codes are A and C.", "answer": "$$\\boxed{AC}$$", "id": "1666431"}, {"introduction": "Moving beyond simple analysis, this problem challenges you to think like a code designer—or a system auditor looking for flaws. Instead of testing a given code, you must strategically introduce a flaw by selecting a codeword that breaks unique decodability. This task requires a deeper understanding of how ambiguities arise from the structural relationships between codewords, specifically how one sequence can be formed in multiple ways from a given codebook [@problem_id:1666448].", "problem": "In designing a simple data compression scheme for a telemetry system, an engineer is assigning variable-length binary codewords to a set of three distinct source symbols, $\\{s_1, s_2, s_3\\}$. The first two symbols have already been assigned the codewords $c_1 = 01$ for $s_1$ and $c_2 = 101$ for $s_2$. The engineer must now choose a third binary codeword, $c_3$, for the symbol $s_3$.\n\nTo ensure reliable communication, the final code $\\{c_1, c_2, c_3\\}$ must be uniquely decodable, meaning any sequence of concatenated codewords has only one possible interpretation as a sequence of source symbols. Your task is to play the role of a system auditor and identify a potential design flaw.\n\nDetermine the shortest possible non-empty binary codeword for $c_3$ that can be added to the set $\\{01, 101\\}$ to make the resulting three-symbol code **not** uniquely decodable. If multiple codewords of this minimal length exist, select the one that is lexicographically first (assuming '0' comes before '1').", "solution": "We have an initial binary code with codewords $c_{1} = 01$ for $s_{1}$ and $c_{2} = 101$ for $s_{2}$. We must choose a non-empty binary $c_{3}$ so that the resulting code $\\{01, 101, c_{3}\\}$ is not uniquely decodable, and among the shortest such choices, pick the lexicographically first.\n\nA code is not uniquely decodable if there exists at least one binary string that can be represented as a concatenation of codewords in two different ways (corresponding to two distinct sequences of source symbols). The shortest possible non-empty binary word has length $1$, so we test whether a length-$1$ choice can create ambiguity.\n\nChoose $c_{3} = 0$. Consider the concatenated bitstring $0101$. It has two distinct parses using the codewords:\n- As $c_{3}$ followed by $c_{2}$: $0$ then $101$, corresponding to the symbol sequence $(s_{3}, s_{2})$.\n- As $c_{1}$ followed by $c_{1}$: $01$ then $01$, corresponding to the symbol sequence $(s_{1}, s_{1})$.\n\nBoth concatenations yield the same bitstring $0101$, so the code $\\{01, 101, 0\\}$ is not uniquely decodable.\n\nSince non-empty binary codewords have length at least $1$, and we have exhibited a valid choice with length $1$, the minimal possible length is $1$. Among length-$1$ candidates, the lexicographically first is $0$. (Indeed, $1$ would also make the code not uniquely decodable because $101$ can be parsed either as $c_2$ or as $c_3$ followed by $c_1$, but the lexicographic rule selects $0$.) Therefore, the required $c_{3}$ is $0$.", "answer": "$$\\boxed{0}$$", "id": "1666448"}, {"introduction": "In real-world systems, we sometimes have to work with imperfect codes. This advanced problem tackles the practical question that follows from non-unique decodability: exactly how ambiguous is a given message? You will use the powerful technique of dynamic programming to count the total number of ways a received binary string can be interpreted, shifting the focus from a simple yes/no answer to a quantitative measure of ambiguity [@problem_id:1666456].", "problem": "A digital communication system uses a variable-length binary code to transmit messages composed of a sequence of source symbols. The codebook, which maps source symbols to codewords, is defined by the set of available binary codewords $C = \\{1, 01, 101, 011\\}$. When a message is sent, the corresponding codewords are concatenated directly without any delimiters.\n\nAn engineer at the receiving end observes the binary string $Y = 011011$. The codebook $C$ is not necessarily uniquely decodable, meaning the received string $Y$ could potentially be parsed into a sequence of valid codewords in multiple ways.\n\nDetermine the total number of distinct sequences of codewords from the set $C$ that can be concatenated to form the exact string $Y$.", "solution": "Let the codebook be $C=\\{1, 01, 101, 011\\}$ and the received string be $Y=011011$ of length $6$. Define $F(i)$ as the number of distinct parses of the suffix of $Y$ starting at position $i$, where positions are indexed $1$ through $6$, and let the empty suffix occur at position $7$. The boundary condition is\n$$\nF(7)=1,\n$$\nsince there is exactly one way to parse the empty string.\n\nFor each position $i$, the recurrence is\n$$\nF(i)=\\sum_{w\\in C} \\mathbf{1}[\\text{$w$ matches $Y$ starting at $i$}] \\cdot F(i+|w|),\n$$\nwhere $|w|$ is the length of codeword $w$.\n\nCompute from the end:\n\nAt $i=6$, the suffix is \"1\". The only matching codeword is $1$, hence\n$$\nF(6)=F(7)=1.\n$$\n\nAt $i=5$, the suffix is \"11\". The only matching codeword is $1$, hence\n$$\nF(5)=F(6)=1.\n$$\n\nAt $i=4$, the suffix is \"011\". The matching codewords are $01$ and $011$, giving\n$$\nF(4)=F(6)+F(7)=1+1=2.\n$$\n\nAt $i=3$, the suffix is \"1011\". The matching codewords are $1$ and $101$, giving\n$$\nF(3)=F(4)+F(6)=2+1=3.\n$$\n\nAt $i=2$, the suffix is \"11011\". The only matching codeword is $1$, hence\n$$\nF(2)=F(3)=3.\n$$\n\nAt $i=1$, the suffix is \"011011\". The matching codewords are $01$ and $011$, giving\n$$\nF(1)=F(3)+F(4)=3+2=5.\n$$\n\nTherefore, the total number of distinct sequences of codewords from $C$ that concatenate to $Y$ is $F(1)=5$.", "answer": "$$\\boxed{5}$$", "id": "1666456"}]}