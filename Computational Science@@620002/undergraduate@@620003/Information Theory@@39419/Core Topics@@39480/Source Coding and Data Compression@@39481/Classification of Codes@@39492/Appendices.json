{"hands_on_practices": [{"introduction": "Before designing a specific set of codewords, we must first determine if a prefix code with our desired lengths is even possible. The Kraft inequality provides a powerful and simple test for this, acting as a fundamental blueprint for code design. This exercise [@problem_id:1610387] challenges you to apply this inequality to a hypothetical engineering problem, using it not just to verify a set of lengths but to optimize a design under given constraints.", "problem": "A systems engineer is designing a communication protocol for a network of autonomous environmental sensors. The central hub receives status updates from five distinct types of sensors, labeled A, B, C, D, and E. Each status update is encoded into a codeword composed of ternary digits, or \"trits\" (0, 1, or 2). For the hub to process the incoming stream of data without ambiguity and without needing to wait for a special termination symbol, the set of codewords must form an instantaneous code.\n\nBased on the frequency and priority of the sensor types, the codeword lengths for the first three types have been fixed:\n- The codeword for sensor type A has a length of $l_A = 1$ trit.\n- The codewords for sensor types B and C each have a length of $l_B = l_C = 2$ trits.\n\nThe remaining two sensor types, D and E, are for non-critical, periodic check-ins. Their codeword lengths, $l_D$ and $l_E$, are integers that need to be determined. To minimize the computational resources on the simple decoders used in the hub, the design specification requires minimizing the sum of the lengths of these two undetermined codewords, $S = l_D + l_E$.\n\nAssuming $l_D$ and $l_E$ must be positive integers, what is the minimum possible value for the sum $S$?", "solution": "An instantaneous (prefix-free) code over a $D$-ary alphabet must satisfy the Kraft inequality. For ternary trits, $D=3$, so any set of codeword lengths $\\{l_{i}\\}$ must satisfy\n$$\n\\sum_{i} 3^{-l_{i}} \\leq 1.\n$$\nWith the given lengths $l_{A}=1$, $l_{B}=l_{C}=2$ and unknown positive integers $l_{D},l_{E}$, the inequality becomes\n$$\n3^{-1}+3^{-2}+3^{-2}+3^{-l_{D}}+3^{-l_{E}} \\leq 1,\n$$\nwhich simplifies to\n$$\n3^{-l_{D}}+3^{-l_{E}} \\leq 1-\\frac{1}{3}-\\frac{2}{9}=\\frac{4}{9}.\n$$\nWe seek to minimize $S=l_{D}+l_{E}$ subject to $l_{D},l_{E}\\in \\mathbb{Z}_{\\geq 1}$ and the above constraint. Since $3^{-l}$ is strictly decreasing in $l$, making lengths as small as possible increases the left-hand side. The smallest pair is $(1,1)$, which yields\n$$\n3^{-1}+3^{-1}=\\frac{1}{3}+\\frac{1}{3}=\\frac{2}{3}>\\frac{4}{9},\n$$\nso it violates the constraint. The next smallest sum is $S=3$ with pairs $(1,2)$ or $(2,1)$, for which\n$$\n3^{-1}+3^{-2}=\\frac{1}{3}+\\frac{1}{9}=\\frac{4}{9},\n$$\nwhich meets the constraint with equality. By the Kraft–McMillan theorem, this guarantees the existence of a ternary instantaneous code with these lengths, so such a code is feasible. Any larger lengths give $S \\geq 4$, which is not minimal.\n\nTherefore, the minimal possible sum is $S_{\\min}=3$.", "answer": "$$\\boxed{3}$$", "id": "1610387"}, {"introduction": "Knowing that a prefix code with a given set of lengths can exist is only the first step; the next is to actually construct it. This practice [@problem_id:1610365] guides you through a canonical construction procedure, a systematic and algorithmic way to assign specific binary sequences that satisfy the prefix condition. Mastering this method turns the abstract promise of the Kraft inequality into a tangible, usable code.", "problem": "In digital communication, prefix codes are used for lossless data compression. A code is defined as a prefix code (or an instantaneous code) if no codeword in the assigned set is a prefix of any other codeword. This property allows for unambiguous decoding.\n\nConsider a source alphabet $\\mathcal{S} = \\{A, B, C\\}$. We want to assign a unique binary codeword to each symbol based on a given set of desired codeword lengths: $l_A=2$, $l_B=3$, and $l_C=3$.\n\nThe assignment must follow a specific canonical construction procedure, outlined below:\n1.  The symbols are arranged in a list, sorted first by their required codeword length in non-decreasing order. Any ties in length are broken alphabetically (e.g., A comes before B).\n2.  The first codeword in this sorted list, $c_1$ of length $l_1$, is an all-zero string of length $l_1$.\n3.  Each subsequent codeword, $c_i$ of length $l_i$, is generated from the previous codeword in the list, $c_{i-1}$ of length $l_{i-1}$. Let $v_{i-1}$ be the integer represented by the binary string $c_{i-1}$. The integer value for the current codeword, $v_i$, is given by the formula $v_i = (v_{i-1} + 1) \\times 2^{(l_i - l_{i-1})}$. The codeword $c_i$ is then the binary representation of the integer $v_i$, padded with leading zeros if necessary to ensure it has the required length $l_i$.\n\nWhich of the following options correctly represents the set of codeword assignments $\\{C(A), C(B), C(C)\\}$ generated by this specific procedure?\n\nA. $C(A)=00, C(B)=010, C(C)=011$\n\nB. $C(A)=00, C(B)=001, C(C)=010$\n\nC. $C(A)=11, C(B)=101, C(C)=100$\n\nD. $C(A)=0, C(B)=10, C(C)=11$", "solution": "We are given desired codeword lengths $l_{A}=2$, $l_{B}=3$, and $l_{C}=3$, and the canonical construction procedure.\n\nFirst, sort the symbols by non-decreasing length and alphabetically to break ties. This yields the ordered list $(A, B, C)$ with lengths $(2, 3, 3)$.\n\nFor the first codeword, apply the rule that $c_{1}$ is the all-zero string of length $l_{1}$. Therefore,\n$$\nc_{A} = 00,\\quad v_{A} = 0.\n$$\n\nFor the next symbol $B$ with $l_{B}=3$, use the recurrence\n$$\nv_{B} = (v_{A} + 1)\\times 2^{(l_{B} - l_{A})} = (0 + 1)\\times 2^{(3 - 2)} = 1\\times 2 = 2.\n$$\nThe codeword $c_{B}$ is the binary representation of $v_{B}$ padded to length $3$:\n$$\nc_{B} = 010.\n$$\n\nFor the next symbol $C$ with $l_{C}=3$, apply the recurrence again:\n$$\nv_{C} = (v_{B} + 1)\\times 2^{(l_{C} - l_{B})} = (2 + 1)\\times 2^{(3 - 3)} = 3\\times 1 = 3.\n$$\nThe codeword $c_{C}$ is the binary representation of $v_{C}$ padded to length $3$:\n$$\nc_{C} = 011.\n$$\n\nThus the canonical assignments are $C(A)=00$, $C(B)=010$, and $C(C)=011$, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1610365"}, {"introduction": "While all prefix codes are easy to decode, they are not the only codes that guarantee unambiguous communication. There exists a broader class of uniquely decodable codes that are not prefix codes, representing an important trade-off in code design. This practice [@problem_id:1610419] challenges you to identify such a code, deepening your understanding of the subtle but crucial differences between these important code classifications.", "problem": "In digital communications, a source alphabet of symbols is often encoded into a sequence of symbols from a code alphabet for transmission. A crucial aspect of this process is the choice of the code itself, which determines how efficiently and reliably the original information can be recovered.\n\nConsider a source alphabet $\\mathcal{S}$ whose symbols are mapped to codewords composed of symbols from a ternary code alphabet $\\mathcal{A} = \\{0, 1, 2\\}$. A set of such codewords for all symbols in $\\mathcal{S}$ is called a code $\\mathcal{C}$. We are interested in two fundamental properties of such codes:\n\n1.  **Prefix Condition**: A code satisfies the prefix condition (and is called a prefix code) if no codeword in the set is a prefix of any other codeword. For example, in the code $\\{01, 2, 011\\}$, the codeword `01` is a prefix of `011`, so this code does not satisfy the prefix condition.\n\n2.  **Unique Decodability**: A code is uniquely decodable if any sequence of symbols formed by concatenating codewords can be unambiguously resolved back into the original sequence of codewords. For example, the code $\\{1, 0, 10\\}$ is not uniquely decodable because the sequence `10` can be interpreted as the single codeword `10` or as the concatenation of codewords `1` and `0`. All prefix codes are uniquely decodable, but not all uniquely decodable codes are prefix codes.\n\nGiven the five ternary codes listed below, identify which one is uniquely decodable but does **not** satisfy the prefix condition.\n\nA. $\\mathcal{C}_A = \\{0, 1, 2\\}$\n\nB. $\\mathcal{C}_B = \\{0, 01, 2\\}$\n\nC. $\\mathcal{C}_C = \\{1, 2, 12\\}$\n\nD. $\\mathcal{C}_D = \\{00, 11, 22\\}$\n\nE. $\\mathcal{C}_E = \\{0, 10, 01\\}$", "solution": "We use the definitions of the prefix condition and unique decodability, with the latter tested via the Sardinas–Patterson algorithm. A code is a prefix code if no codeword is a prefix of another. Every prefix code is uniquely decodable. For non-prefix candidates, we apply Sardinas–Patterson: define $U_{1}=\\{v:\\exists x\\neq y\\text{ in }X\\text{ with }x=yv\\text{ or }y=xv\\}$ where $v$ is a nonempty suffix; then iteratively $U_{n+1}=\\{v:\\exists u\\in U_{n},\\,\\exists x\\in X\\text{ with }x=uv\\text{ or }u=xv\\}$. If at any stage the empty string $\\varepsilon$ appears, the code is not uniquely decodable; if the process stabilizes without producing $\\varepsilon$, the code is uniquely decodable.\n\nAnalyze each option:\n\n- Option A: $\\mathcal{C}_{A}=\\{0,1,2\\}$. All codewords have length $1$, so no codeword is a prefix of another. Hence it is a prefix code, therefore uniquely decodable. It does not meet the requirement because it satisfies the prefix condition.\n\n- Option B: $\\mathcal{C}_{B}=\\{0,01,2\\}$. The codeword $0$ is a prefix of $01$, so it is not a prefix code. Apply Sardinas–Patterson with $X=\\{0,01,2\\}$.\n  Compute $U_{1}$ from prefix overlaps:\n  Since $01=0\\cdot 1$, we get $U_{1}=\\{1\\}$. No other pair yields a nonempty suffix.\n  Now for $u=1$, check all $x\\in X$:\n  For $x=0$: neither $0=1v$ nor $1=0v$ holds.\n  For $x=01$: neither $01=1v$ nor $1=01v$ holds.\n  For $x=2$: neither $2=1v$ nor $1=2v$ holds.\n  Hence $U_{2}=\\varnothing$. Since no $\\varepsilon$ is produced and the process terminates, the code is uniquely decodable. Therefore $\\mathcal{C}_{B}$ is uniquely decodable but not prefix.\n\n- Option C: $\\mathcal{C}_{C}=\\{1,2,12\\}$. The codeword $1$ is a prefix of $12$, so it is not a prefix code. Apply Sardinas–Patterson with $X=\\{1,2,12\\}$.\n  Compute $U_{1}$: since $12=1\\cdot 2$, $U_{1}=\\{2\\}$.\n  For $u=2$, check $x\\in X$:\n  For $x=2$: $2=2\\cdot \\varepsilon$ produces $\\varepsilon$, so the code is not uniquely decodable. Indeed, the string $12$ has two parses: $12$ and $1,2$.\n\n- Option D: $\\mathcal{C}_{D}=\\{00,11,22\\}$. All codewords have equal length and differ, so no codeword is a prefix of another. It is a prefix code, hence uniquely decodable. It does not meet the requirement.\n\n- Option E: $\\mathcal{C}_{E}=\\{0,10,01\\}$. The codeword $0$ is a prefix of $01$, so it is not a prefix code. Apply Sardinas–Patterson with $X=\\{0,10,01\\}$.\n  Compute $U_{1}$: since $01=0\\cdot 1$, $U_{1}=\\{1\\}$.\n  For $u=1$:\n  For $x=10$: $10=1\\cdot 0$ gives $U_{2}=\\{0\\}$.\n  For $u=0$:\n  For $x=0$: $0=0\\cdot \\varepsilon$ produces $\\varepsilon$, so the code is not uniquely decodable. An explicit ambiguity is the string $010$, which can be parsed as $01,0$ or $0,10$.\n\nFrom the above, the only code that is uniquely decodable but does not satisfy the prefix condition is $\\mathcal{C}_{B}$.", "answer": "$$\\boxed{B}$$", "id": "1610419"}]}