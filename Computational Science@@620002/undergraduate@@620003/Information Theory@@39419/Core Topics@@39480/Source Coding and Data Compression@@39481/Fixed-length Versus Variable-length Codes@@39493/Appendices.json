{"hands_on_practices": [{"introduction": "In data compression, our goal is to represent information efficiently. However, efficiency cannot come at the cost of clarity. This first exercise explores a crucial pitfall: ambiguity. You will analyze a seemingly simple variable-length code that is not a prefix code, discovering how a single encoded binary string can lead to multiple valid interpretations. This practice highlights why the prefix-free property is fundamental for any reliable communication or storage system. [@problem_id:1625290]", "problem": "A digital archivist is working to preserve a newly discovered ancient text that uses a very simple alphabet consisting of only three symbols: Aleph ($\\alpha$), Bet ($\\beta$), and Gamal ($\\gamma$). The archivist proposes a variable-length binary encoding scheme to represent these symbols for digital storage. The proposed codebook is as follows:\n- The symbol $\\alpha$ is encoded as the binary string `0`.\n- The symbol $\\beta$ is encoded as the binary string `1`.\n- The symbol $\\gamma$ is encoded as the binary string `01`.\n\nDuring data recovery from a damaged storage medium, the archivist successfully retrieves an uninterrupted binary sequence: `010110`. However, due to the nature of the encoding, it is unclear what the original sequence of symbols was.\n\nHow many distinct sequences of symbols from the set $\\{\\alpha, \\beta, \\gamma\\}$ could have produced this exact binary sequence `010110`?\n\nSelect the correct count from the options below.\n\nA. 1\n\nB. 2\n\nC. 3\n\nD. 4\n\nE. 5", "solution": "The codebook assigns $\\alpha \\mapsto 0$, $\\beta \\mapsto 1$, and $\\gamma \\mapsto 01$. This code is not prefix-free because `0` is a prefix of `01`, so the decoding of the binary string can be ambiguous. We must count how many ways the string `010110` can be parsed into codewords from the set $\\{0,1,01\\}$.\n\nLet the binary string be $w$ of length $n=6$, with positions indexed $1$ through $6$. Define $f(i)$ to be the number of ways to parse the suffix starting at position $i$. Use the base condition $f(n+1)=f(7)=1$, representing that once the end is reached, there is exactly one way to finish (do nothing).\n\nAt position $i$, the recurrence is\n$$\nf(i)=\\begin{cases}\n\\mathbf{1}_{\\{w_{i}=0\\}}\\,f(i+1)+\\mathbf{1}_{\\{w_{i}=1\\}}\\,f(i+1)+\\mathbf{1}_{\\{i\\leq n-1,\\,w_{i}=0,\\,w_{i+1}=1\\}}\\,f(i+2), & 1\\leq i\\leq n,\\\\\n1, & i=n+1,\n\\end{cases}\n$$\nwhich corresponds respectively to choosing the codeword `0`, `1`, or `01` when allowed by the current bits.\n\nFor $w=010110$, compute from the end:\n- $f(7)=1$.\n- At $i=6$, $w_{6}=0$: $f(6)=f(7)=1$.\n- At $i=5$, $w_{5}=1$: $f(5)=f(6)=1$.\n- At $i=4$, $w_{4}=1$: $f(4)=f(5)=1$.\n- At $i=3$, $w_{3}=0$ and $w_{4}=1$: $f(3)=f(4)+f(5)=1+1=2$.\n- At $i=2$, $w_{2}=1$: $f(2)=f(3)=2$.\n- At $i=1$, $w_{1}=0$ and $w_{2}=1$: $f(1)=f(2)+f(3)=2+2=4$.\n\nThus the total number of decodings is $f(1)=4$. Explicitly, the sequences are $\\,\\alpha\\beta\\alpha\\beta\\beta\\alpha$, $\\,\\alpha\\beta\\gamma\\beta\\alpha$, $\\,\\gamma\\alpha\\beta\\beta\\alpha$, and $\\,\\gamma\\gamma\\beta\\alpha$, each mapping to `010110`.\n\nTherefore, the correct option is D.", "answer": "$$\\boxed{D}$$", "id": "1625290"}, {"introduction": "After understanding the importance of prefix codes, we turn to a key design question: if we propose a set of codeword lengths, how can we know if a valid prefix code can even be constructed? This exercise introduces the Kraft–McMillan inequality, a powerful mathematical test for the existence of a prefix code. You will apply this theorem to a hypothetical scenario involving a ternary alphabet, demonstrating a fundamental principle that governs the limits of instantaneous coding. [@problem_id:1625225]", "problem": "An engineering team is designing a communication protocol for a deep-space probe. The probe monitors five different categories of environmental data. To conserve bandwidth, the data category identifiers are to be encoded using a variable-length code. The communication hardware is designed to transmit signals from a ternary alphabet, which consists of three distinct symbols (e.g., $\\{0, 1, 2\\}$).\n\nFor the system to function correctly, the encoding must be a prefix code. A code is a prefix code if no codeword is a prefix (the initial part) of any other codeword. This property is essential for unambiguous and instantaneous decoding of a continuous data stream.\n\nAn engineer proposes a set of codeword lengths for the five data categories: $\\{1, 1, 2, 2, 2\\}$. Your task is to determine if it is mathematically possible to construct a ternary prefix code with this specific set of lengths.\n\nWhich of the following statements is correct?\n\nA. It is possible to construct a ternary prefix code with the specified codeword lengths.\n\nB. It is impossible to construct a ternary prefix code with the specified codeword lengths.\n\nC. A prefix code with these lengths could be constructed if the alphabet were binary, but it is not possible for a ternary alphabet.\n\nD. It is impossible to determine if a prefix code can be constructed without knowing the specific probabilities of the five data categories.", "solution": "We seek to determine whether there exists a prefix code over a ternary alphabet (alphabet size $D=3$) with the proposed multiset of codeword lengths $\\{1,1,2,2,2\\}$. The relevant principle is the Kraft–McMillan inequality for $D$-ary prefix codes: a set of lengths $\\{l_{i}\\}_{i=1}^{n}$ is achievable by a prefix code over a $D$-ary alphabet if and only if\n$$\n\\sum_{i=1}^{n} D^{-l_{i}} \\leq 1.\n$$\nHere, $D=3$ and $n=5$. Substituting the given lengths $l_{1}=1$, $l_{2}=1$, $l_{3}=2$, $l_{4}=2$, $l_{5}=2$, we compute\n$$\n\\sum_{i=1}^{5} 3^{-l_{i}} = 3^{-1} + 3^{-1} + 3^{-2} + 3^{-2} + 3^{-2}.\n$$\nGroup like terms:\n$$\n3^{-1} + 3^{-1} = 2 \\cdot 3^{-1} = \\frac{2}{3}, \\quad 3^{-2} + 3^{-2} + 3^{-2} = 3 \\cdot 3^{-2} = \\frac{3}{9} = \\frac{1}{3}.\n$$\nTherefore,\n$$\n\\sum_{i=1}^{5} 3^{-l_{i}} = \\frac{2}{3} + \\frac{1}{3} = 1.\n$$\nSince the Kraft sum equals $1$, the Kraft–McMillan inequality is satisfied with equality, which is sufficient to guarantee the existence of a ternary prefix code with these lengths.\n\nA constructive interpretation using the ternary code tree confirms feasibility: two codewords of length $1$ occupy two of the three children of the root; the remaining child yields exactly three available nodes at depth $2$, which can be assigned to the three codewords of length $2$, preserving the prefix property.\n\nHence, it is possible to construct a ternary prefix code with lengths $\\{1,1,2,2,2\\}$. Statements asserting impossibility or dependence on symbol probabilities are incorrect, since feasibility depends solely on the Kraft–McMillan inequality and not on probabilities.", "answer": "$$\\boxed{A}$$", "id": "1625225"}, {"introduction": "With the foundational concepts of prefix codes established, we can now quantify their practical benefits in data compression. This problem puts you in the role of an engineer optimizing a large-scale data storage system. By comparing an efficient variable-length code (specifically, an optimal Huffman code) against a simple fixed-length code for a source with non-uniform probabilities, you will calculate the concrete storage savings, illustrating the real-world power of adapting code lengths to symbol frequencies. [@problem_id:1625230]", "problem": "A university's computer science department is tasked with optimizing the storage of final course grades for a massive historical dataset containing $N = 2,500,000$ student records. The possible grades are A, B, C, D, and F. After a statistical analysis of the dataset, the frequencies of the grades were found to be non-uniform. The observed probabilities for each grade are as follows:\n- Grade A: $p_A = 0.25$\n- Grade B: $p_B = 0.35$\n- Grade C: $p_C = 0.20$\n- Grade D: $p_D = 0.15$\n- Grade F: $p_F = 0.05$\n\nThe department is comparing two lossless compression strategies:\n1.  **Fixed-Length Encoding:** Each grade is represented by a binary string of the same, minimal possible length.\n2.  **Variable-Length Encoding:** An optimal prefix code (Huffman code) is constructed based on the grade probabilities, where more frequent grades are assigned shorter binary strings.\n\nYour task is to quantify the storage improvement. Calculate the total number of bits saved across the entire dataset of $N$ records by using the optimal Huffman code compared to the minimal fixed-length code. Provide your answer as an integer.", "solution": "We have an alphabet of size $M=5$ and $N=2{,}500{,}000$ records. For minimal fixed-length encoding, the per-symbol length is the smallest integer $L_{\\text{fix}}$ such that $2^{L_{\\text{fix}}} \\geq M$, i.e.,\n$$\nL_{\\text{fix}}=\\lceil \\log_{2}(M) \\rceil=\\lceil \\log_{2}(5) \\rceil=3.\n$$\nThus total bits with fixed-length encoding are\n$$\nB_{\\text{fix}}=N \\cdot L_{\\text{fix}}=N \\cdot 3.\n$$\n\nFor an optimal Huffman code, we construct the code by repeatedly merging the two least probable symbols/nodes. The probabilities in ascending order are $0.05,\\,0.15,\\,0.20,\\,0.25,\\,0.35$. Merge $0.05$ and $0.15$ to get $0.20$; the multiset becomes $0.20,\\,0.20,\\,0.25,\\,0.35$. Merge the two $0.20$'s to get $0.40$; the multiset becomes $0.25,\\,0.35,\\,0.40$. Merge $0.25$ and $0.35$ to get $0.60$; the multiset becomes $0.40,\\,0.60$. Merge $0.40$ and $0.60$ to get the root. This yields codeword lengths $l_{A}=2$, $l_{B}=2$, $l_{C}=2$, $l_{D}=3$, $l_{F}=3$.\n\nThe expected code length per symbol is\n$$\nL_{\\text{huff}}=\\sum_{i} p_{i} l_{i}=2\\left(p_{A}+p_{B}+p_{C}\\right)+3\\left(p_{D}+p_{F}\\right).\n$$\nSubstituting the given probabilities,\n$$\nL_{\\text{huff}}=2\\left(0.25+0.35+0.20\\right)+3\\left(0.15+0.05\\right)=2\\cdot 0.80+3\\cdot 0.20=1.60+0.60=2.20.\n$$\nHence total bits with the Huffman code are\n$$\nB_{\\text{huff}}=N \\cdot L_{\\text{huff}}=N \\cdot 2.20.\n$$\n\nThe total bits saved are\n$$\n\\Delta B=B_{\\text{fix}}-B_{\\text{huff}}=N\\left(L_{\\text{fix}}-L_{\\text{huff}}\\right)=N\\left(3-2.20\\right)=N \\cdot 0.80.\n$$\nWith $N=2{,}500{,}000$,\n$$\n\\Delta B=2{,}500{,}000 \\times 0.80=2{,}000{,}000.\n$$", "answer": "$$\\boxed{2000000}$$", "id": "1625230"}]}