{"hands_on_practices": [{"introduction": "The journey into coding theory begins with a foundational principle: every symbol must have a unique identity. A code is considered **nonsingular** if each source symbol maps to a distinct codeword, preventing any ambiguity at the most basic level. This practice asks you to perform this fundamental check, which is the first gate every functional code must pass. By examining several proposed codebooks, you will develop the essential skill of quickly verifying nonsingularity by looking for duplicate codewords [@problem_id:1643893].", "problem": "In the field of information theory, a code is a system of rules to convert information from a source alphabet into another representation, typically shorter or more suitable for a specific medium. Consider a set of source symbols $\\mathcal{X}$. An encoding function $C$ maps each symbol $x \\in \\mathcal{X}$ to a finite-length string of symbols from a code alphabet $\\mathcal{Y}$. The string $C(x)$ is called a codeword, and the set of all codewords, $\\{C(x) \\mid x \\in \\mathcal{X}\\}$, is called the codebook.\n\nA code is defined as **nonsingular** if the encoding function $C$ is one-to-one. This means that for any two distinct source symbols $x_1, x_2 \\in \\mathcal{X}$ where $x_1 \\neq x_2$, their corresponding codewords must also be distinct, i.e., $C(x_1) \\neq C(x_2)$. This is a fundamental requirement for a code to be useful, as it ensures that every codeword can be unambiguously mapped back to its original source symbol.\n\nA team is developing a communication protocol for a simple robotic arm. The source alphabet consists of four commands: $\\mathcal{X} = \\{\\text{UP}, \\text{DOWN}, \\text{LEFT}, \\text{RIGHT}\\}$. The code alphabet is binary, $\\mathcal{Y} = \\{0, 1\\}$. The team has proposed five different codebooks for encoding these commands.\n\n**Codebook A**\n- UP: 010\n- DOWN: 101\n- LEFT: 010\n- RIGHT: 111\n\n**Codebook B**\n- UP: 1\n- DOWN: 10\n- LEFT: 100\n- RIGHT: 1000\n\n**Codebook C**\n- UP: 00\n- DOWN: 11\n- LEFT: 010\n- RIGHT: 11\n\n**Codebook D**\n- UP: 01\n- DOWN: 10\n- LEFT: 11\n- RIGHT: 00\n\n**Codebook E**\n- UP: 101\n- DOWN: 010\n- LEFT: 1010\n- RIGHT: 0101\n\nWhich of the following proposed codebooks are nonsingular? Your answer should consist of the letters corresponding to all the nonsingular codebooks, concatenated in alphabetical order. For example, if you find that A, B, and C are the correct options, your answer should be ABC.\n\nA. Codebook A\n\nB. Codebook B\n\nC. Codebook C\n\nD. Codebook D\n\nE. Codebook E", "solution": "A code is nonsingular if and only if the encoding function $C$ is one-to-one, i.e., for all distinct $x_{1},x_{2}\\in\\mathcal{X}$ with $x_{1}\\neq x_{2}$, we have $C(x_{1})\\neq C(x_{2})$. Equivalently, the set $\\{C(x):x\\in\\mathcal{X}\\}$ must have cardinality $|\\mathcal{X}|=4$.\n\n- Codebook A: The images are $\\{010,101,010,111\\}$. Since $C(\\text{UP})=010=C(\\text{LEFT})$, we have $|\\{C(x):x\\in\\mathcal{X}\\}|=3<4$. Not nonsingular.\n\n- Codebook B: The images are $\\{1,10,100,1000\\}$. All four strings are distinct, so $|\\{C(x):x\\in\\mathcal{X}\\}|=4$. Nonsingular.\n\n- Codebook C: The images are $\\{00,11,010,11\\}$. Since $C(\\text{DOWN})=11=C(\\text{RIGHT})$, we have $|\\{C(x):x\\in\\mathcal{X}\\}|=3<4$. Not nonsingular.\n\n- Codebook D: The images are $\\{01,10,11,00\\}$. All four strings are distinct, so $|\\{C(x):x\\in\\mathcal{X}\\}|=4$. Nonsingular.\n\n- Codebook E: The images are $\\{101,010,1010,0101\\}$. All four strings are distinct, so $|\\{C(x):x\\in\\mathcal{X}\\}|=4$. Nonsingular.\n\nTherefore, the nonsingular codebooks are B, D, and E, listed in alphabetical order as required.", "answer": "$$\\boxed{BDE}$$", "id": "1643893"}, {"introduction": "Identifying a flaw is the first step, but the true work of an engineer or scientist lies in correcting it. Building on the concept of nonsingularity, this exercise presents a practical design scenario. You are given a code that is demonstrably faulty because it fails the nonsingularity test. Your task is to apply your understanding to repair it with a minimal change, transforming a non-functional code into a valid one [@problem_id:1643885]. This moves you from simply identifying properties to actively constructing codes that meet essential criteria.", "problem": "In the design of a simple data compression scheme, a source alphabet $S = \\{s_1, s_2, s_3, s_4\\}$ is to be encoded using a binary code alphabet $X = \\{0, 1\\}$. An initial design proposes the following codebook $C$:\n- $C(s_1) = 101$\n- $C(s_2) = 00$\n- $C(s_3) = 110$\n- $C(s_4) = 101$\n\nA code is defined as **nonsingular** if every unique source symbol is mapped to a unique codeword. It is clear that the proposed code $C$ is not nonsingular. To fix this, a junior engineer suggests modifying *only* the codeword for the source symbol $s_4$.\n\nFrom the list of possible new codewords for $s_4$ below, identify all options that would make the resulting code nonsingular.\n\nA) $00$\n\nB) $10$\n\nC) $110$\n\nD) $001$\n\nE) $1010$", "solution": "A code $C:S\\to X^{*}$ is nonsingular if it is injective, i.e., for all $i\\neq j$, $C(s_{i})\\neq C(s_{j})$. The current code assigns $C(s_{1})=101$, $C(s_{2})=00$, $C(s_{3})=110$, and we must modify only $C(s_{4})$ so that $C(s_{4})\\notin\\{101,00,110\\}$.\n\nCheck each option for $C(s_{4})$:\n- A) $00$: equals $C(s_{2})$, violates injectivity; reject.\n- B) $10$: distinct from $101,00,110$; accept.\n- C) $110$: equals $C(s_{3})$, violates injectivity; reject.\n- D) $001$: distinct from $101,00,110$; accept.\n- E) $1010$: distinct from $101,00,110$; accept.\n\nTherefore, the options that make the code nonsingular are B, D, and E.", "answer": "$$\\boxed{BDE}$$", "id": "1643885"}, {"introduction": "A code can be nonsingular—with every symbol having a unique codeword—yet still create confusion when used to transmit messages. This happens when a sequence of codewords can be interpreted in multiple ways, a failure of **unique decodability**. This final practice challenges you to explore this critical distinction by identifying a code that is nonsingular but not uniquely decodable. You'll need to pinpoint not just the flawed code, but also an ambiguous string that proves why nonsingularity alone is a necessary but insufficient condition for clear communication [@problem_id:1610386].", "problem": "In digital communications, source symbols from an alphabet are converted into sequences of binary digits (bits) using a code. Consider a source with an alphabet $\\mathcal{S} = \\{A, B, C\\}$. We wish to encode messages from this source using a binary code, where each symbol is mapped to a variable-length string of bits from the set $\\{0, 1\\}$.\n\nFor a code to be useful, it must satisfy certain properties. Let's define two important classifications:\n1.  A code is **non-singular** if every symbol in the source alphabet maps to a different, unique codeword.\n2.  A code is **uniquely decodable** if any finite sequence of concatenated codewords can be resolved into only one possible sequence of source symbols. Note that all uniquely decodable codes must be non-singular, but the converse is not always true.\n\nYour task is to identify which of the following options correctly provides a binary code for the source alphabet $\\mathcal{S}$ that is **non-singular** but **not uniquely decodable**, along with a specific encoded string that demonstrates this lack of unique decodability. In each option, the code mapping is assumed to be $A \\to c_1$, $B \\to c_2$, and $C \\to c_3$.\n\nA. Code: $\\{0, 01, 10\\}$. Ambiguous String: \"010\"\n\nB. Code: $\\{0, 1, 0\\}$. Ambiguous String: \"010\"\n\nC. Code: $\\{0, 10, 11\\}$. Ambiguous String: \"100\"\n\nD. Code: $\\{1, 10, 100\\}$. Ambiguous String: \"101\"\n\nE. Code: $\\{0, 01, 10\\}$. Ambiguous String: \"0110\"", "solution": "We use the definitions:\n- A code is non-singular if all codewords are distinct.\n- A code is uniquely decodable if any concatenation of codewords has exactly one parsing into source symbols. A sufficient condition for unique decodability is the prefix condition (no codeword is a prefix of another). More generally, the Sardinas–Patterson test detects unique decodability by iteratively building difference sets; if the empty string ever appears, the code is not uniquely decodable; if the process ends without producing the empty string, the code is uniquely decodable.\n\nCheck each option.\n\nA. Code $\\{0, 01, 10\\}$ with $A \\mapsto 0$, $B \\mapsto 01$, $C \\mapsto 10$.\n- Non-singular: $0$, $01$, and $10$ are distinct, so the code is non-singular.\n- Not uniquely decodable: The string 010 has two parsings:\n  - $0 \\, | \\, 10$ corresponds to $A C$.\n  - $01 \\, | \\, 0$ corresponds to $B A$.\n  Therefore the code is not uniquely decodable, and the given ambiguous string correctly demonstrates it.\n\nB. Code $\\{0, 1, 0\\}$ with $A \\mapsto 0$, $B \\mapsto 1$, $C \\mapsto 0$.\n- Not non-singular: $A$ and $C$ share the same codeword $0$. Hence this option fails the non-singularity requirement and is invalid regardless of any string.\n\nC. Code $\\{0, 10, 11\\}$ with $A \\mapsto 0$, $B \\mapsto 10$, $C \\mapsto 11$.\n- Non-singular: codewords are distinct.\n- Prefix-free: no codeword is a prefix of another (neither $10$ nor $11$ starts with $0$, and $0$ is not a prefix of them since they start with $1$). Hence the code is uniquely decodable.\n- The proposed string 100 parses as $10 \\, | \\, 0$ (i.e., $B A$), and there is no alternative parsing, confirming unique decodability. Thus this option does not meet the “not uniquely decodable” requirement.\n\nD. Code $\\{1, 10, 100\\}$ with $A \\mapsto 1$, $B \\mapsto 10$, $C \\mapsto 100$.\n- Non-singular: codewords are distinct.\n- Not prefix-free (since $1$ is a prefix of $10$ and $100$), so we apply the Sardinas–Patterson test:\n  - $D_{1} = \\{0, 00\\}$ from the relations $1$ prefix of $10$ (suffix $0$) and $1$ prefix of $100$ (suffix $00$), and $10$ prefix of $100$ (suffix $0$).\n  - Compute $D_{2}$ from overlaps of $D_{1}$ with the code and vice versa. No codeword starts with $0$, and no element of $D_{1}$ starts with $1$, so no new non-empty suffixes are produced; thus $D_{2} = \\varnothing$.\n  - Since the empty string never appears and the process terminates, the code is uniquely decodable.\n- The proposed string 101 has the unique parsing $10 \\, | \\, 1$ (i.e., $B A$). Therefore this option does not meet the “not uniquely decodable” requirement.\n\nE. Code $\\{0, 01, 10\\}$ (same as A) with ambiguous string 0110.\n- The code itself is non-singular and not uniquely decodable (as shown in A), but the specific string 0110 is not ambiguous: it parses as $01 \\, | \\, 10$ (i.e., $B C$), and no alternative parsing exists because trying to begin with $0$ leaves 110, which cannot be segmented into valid codewords. Hence this option fails to provide a correct demonstrating string.\n\nTherefore, only option A both provides a non-singular code that is not uniquely decodable and supplies a correct ambiguous string that demonstrates the lack of unique decodability.", "answer": "$$\\boxed{A}$$", "id": "1610386"}]}