{"hands_on_practices": [{"introduction": "The standard Non-Maximum Suppression algorithm is a cornerstone of object detection, valued for its speed and simplicity. However, it's crucial to understand that it is a 'greedy' heuristic, not a globally optimal solution. This first practice [@problem_id:3159494] provides a deep dive into this trade-off by challenging you to frame NMS as an exact Integer Linear Programming (ILP) problem. By comparing the results of the fast greedy algorithm against the theoretically perfect (but computationally intensive) ILP solution, you will gain a fundamental understanding of why and when greedy NMS might fall short.", "problem": "You are given a set of axis-aligned rectangular bounding boxes in a two-dimensional plane. Each box has coordinates and an associated nonnegative confidence score. The goal is to implement Non-Maximum Suppression (NMS) by formulating it as a constraint satisfaction problem and solving it exactly via Integer Linear Programming (ILP) on small instances, and also by a greedy selection procedure, then comparing the results.\n\nDefinitions and foundations:\n- For a box with coordinates represented by the tuple $(x_1,y_1,x_2,y_2)$, assume $x_1 < x_2$ and $y_1 < y_2$. The area is $(x_2 - x_1)\\,(y_2 - y_1)$.\n- The Intersection over Union (IoU) between two boxes $i$ and $j$ is defined as the ratio of the intersection area to the union area of the two boxes. If there is no overlap, the intersection area is $0$ and $\\mathrm{IoU}_{ij} = 0$. The union area equals the sum of the individual areas minus the intersection area. All IoU values are dimensionless.\n- Non-Maximum Suppression (NMS) suppresses overlapping boxes based on a threshold $t \\in [0,1]$. In this problem, use the following rule: two boxes $i$ and $j$ are mutually exclusive if $\\mathrm{IoU}_{ij} \\ge t$.\n\nFormulation as ILP:\n- Introduce binary decision variables $x_i \\in \\{0,1\\}$ for each box $i$, where $x_i = 1$ means the box is selected and $x_i = 0$ means it is not selected.\n- Let $s_i \\ge 0$ denote the confidence score of box $i$.\n- For every pair $(i,j)$ with $\\mathrm{IoU}_{ij} \\ge t$, impose the constraint $x_i + x_j \\le 1$.\n- Objective: maximize $\\sum_i s_i x_i$ subject to the above constraints.\n- Since instances are small, solve the ILP exactly by enumerating all feasible assignments of $\\{x_i\\}$ that satisfy the constraints and selecting the assignment that maximizes the objective. In the case of ties in total score, break ties by choosing the lexicographically smallest sorted list of selected indices.\n\nGreedy NMS procedure:\n- Sort boxes in descending order of score. When scores are equal, break ties by ascending index.\n- Iterate through the sorted list, selecting a box if it has not been suppressed. Upon selecting box $k$, suppress every remaining box $j$ such that $\\mathrm{IoU}_{kj} \\ge t$.\n- The output is the sorted list (ascending) of selected indices.\n\nYour task:\n- Implement both methods: the exact ILP solver (via enumeration) and the greedy NMS.\n- Use the following test suite. Boxes are specified as $(x_1,y_1,x_2,y_2)$ and all scores are unitless. For each case, indices are $0$-based.\n- For each test case, output a list containing:\n  1. The greedy-selected indices as an ascending list of integers.\n  2. The ILP-selected indices as an ascending list of integers (using lexicographic tie-breaking among optimal solutions).\n  3. A boolean indicating whether the two index lists are identical.\n  4. The greedy total score, rounded to three decimal places.\n  5. The ILP total score, rounded to three decimal places.\n\nTest suite:\n- Case A (happy path, moderate overlaps): threshold $t = 0.3$; boxes and scores\n  - Index $0$: $(0.0, 0.0, 2.0, 2.0)$ with $s_0 = 0.90$\n  - Index $1$: $(0.5, 0.5, 2.5, 2.5)$ with $s_1 = 0.85$\n  - Index $2$: $(2.1, 0.0, 4.1, 2.0)$ with $s_2 = 0.70$\n  - Index $3$: $(0.0, 2.1, 2.0, 4.1)$ with $s_3 = 0.60$\n- Case B (suboptimal greedy due to chain conflicts): threshold $t = 0.5$; boxes and scores\n  - Index $0$: $(0.0, 0.0, 2.0, 2.0)$ with $s_0 = 0.60$\n  - Index $1$: $(0.5, 0.0, 2.5, 2.0)$ with $s_1 = 0.95$\n  - Index $2$: $(1.0, 0.0, 3.0, 2.0)$ with $s_2 = 0.60$\n- Case C (boundary condition $t = 0$): threshold $t = 0.0$; boxes and scores\n  - Index $0$: $(0.0, 0.0, 1.0, 1.0)$ with $s_0 = 0.50$\n  - Index $1$: $(2.0, 0.0, 3.0, 1.0)$ with $s_1 = 0.70$\n  - Index $2$: $(4.0, 0.0, 5.0, 1.0)$ with $s_2 = 0.60$\n- Case D (boundary condition $t = 1$ with identical boxes): threshold $t = 1.0$; boxes and scores\n  - Index $0$: $(0.0, 0.0, 1.0, 1.0)$ with $s_0 = 0.60$\n  - Index $1$: $(0.0, 0.0, 1.0, 1.0)$ with $s_1 = 0.59$\n  - Index $2$: $(2.0, 2.0, 3.0, 3.0)$ with $s_2 = 0.40$\n- Case E (tie-breaking in both strategies): threshold $t = 0.5$; boxes and scores\n  - Index $0$: $(0.0, 0.0, 2.0, 2.0)$ with $s_0 = 0.80$\n  - Index $1$: $(0.5, 0.0, 2.5, 2.0)$ with $s_1 = 0.80$\n  - Index $2$: $(3.0, 0.0, 5.0, 2.0)$ with $s_2 = 0.10$\n\nFinal output format:\n- Your program should produce a single line of output containing a list with one element per test case. Each element must be a list of the form\n  $[G, O, B, S_G, S_O]$,\n  where $G$ is the greedy indices list, $O$ is the ILP indices list, $B$ is the boolean equality indicator, $S_G$ is the greedy total score rounded to three decimal places, and $S_O$ is the ILP total score rounded to three decimal places. The entire output must be a single line, for example:\n  $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$.", "solution": "The posed problem requires the implementation and comparison of two distinct methods for Non-Maximum Suppression (NMS): a standard greedy heuristic and an exact solver based on an Integer Linear Programming (ILP) formulation. The task is to apply both methods to a series of test cases and report the selected bounding boxes, the resulting total scores, and a comparison between the two sets of results.\n\nFirst, we establish the mathematical foundations for the problem. A bounding box $B_i$ is defined by its coordinates $(x_{i,1}, y_{i,1}, x_{i,2}, y_{i,2})$, where we are given that $x_{i,1} < x_{i,2}$ and $y_{i,1} < y_{i,2}$. The area of box $B_i$ is given by:\n$$\n\\text{Area}(B_i) = (x_{i,2} - x_{i,1})(y_{i,2} - y_{i,1})\n$$\nThe core metric for NMS is the Intersection over Union (IoU), which quantifies the extent of overlap between two boxes, $B_i$ and $B_j$. The intersection area is calculated from the overlapping rectangle:\n$$\n\\text{Area}(B_i \\cap B_j) = \\max(0, \\min(x_{i,2}, x_{j,2}) - \\max(x_{i,1}, x_{j,1})) \\cdot \\max(0, \\min(y_{i,2}, y_{j,2}) - \\max(y_{i,1}, y_{j,1}))\n$$\nThe union area is derived from the principle of inclusion-exclusion:\n$$\n\\text{Area}(B_i \\cup B_j) = \\text{Area}(B_i) + \\text{Area}(B_j) - \\text{Area}(B_i \\cap B_j)\n$$\nThus, the IoU is defined as the ratio:\n$$\n\\mathrm{IoU}_{ij} = \\frac{\\text{Area}(B_i \\cap B_j)}{\\text{Area}(B_i \\cup B_j)}\n$$\nIf the union area is zero (which implies both box areas are zero, a case excluded by the problem statement), the IoU is taken to be $0$. The value of $\\mathrm{IoU}_{ij}$ lies in the interval $[0, 1]$.\n\nThe first method to be implemented is the Greedy NMS algorithm. This is a widely used heuristic that operates as follows:\n1.  A list of all candidate boxes is created, each with an associated confidence score $s_i$ and an original index $i$.\n2.  The list is sorted in descending order based on the confidence scores. In case of a tie in scores, the box with the lower original index is placed first.\n3.  The algorithm iterates through the sorted list. The first box is selected. Then, all other boxes $B_j$ that have an IoU with the selected box $B_i$ greater than or equal to a specified threshold $t$ (i.e., $\\mathrm{IoU}_{ij} \\ge t$) are marked as suppressed and removed from consideration.\n4.  The process repeats with the next available (unsuppressed) box in the sorted list until all boxes have been either selected or suppressed.\n5.  The final output is the set of indices of the selected boxes, sorted in ascending order.\n\nThe second method is an exact solution based on an Integer Linear Programming (ILP) formulation. This approach guarantees an optimal selection of boxes that maximizes the total confidence score, subject to the overlap constraints. The formulation is as follows:\n-   For each box $i$, we introduce a binary decision variable $x_i \\in \\{0, 1\\}$, where $x_i = 1$ if the box is selected and $x_i = 0$ otherwise.\n-   The objective is to maximize the sum of scores of the selected boxes:\n    $$\n    \\text{maximize} \\quad Z = \\sum_{i} s_i x_i\n    $$\n-   The NMS rule is enforced through a set of constraints. For every pair of boxes $(i, j)$ where their overlap meets or exceeds the threshold, $\\mathrm{IoU}_{ij} \\ge t$, we impose the constraint that at most one of them can be selected:\n    $$\n    x_i + x_j \\le 1 \\quad \\forall (i, j) \\text{ such that } i < j \\text{ and } \\mathrm{IoU}_{ij} \\ge t\n    $$\nSince the problem instances are small (up to $4$ boxes), this ILP can be solved exactly by enumerating all $2^N$ possible assignments for the variables $\\{x_i\\}$, where $N$ is the number of boxes. For each assignment, we check if it is feasible (i.e., satisfies all constraints). Among all feasible assignments, we seek the one that yields the maximum objective value. If multiple assignments result in the same maximum score, the tie is broken by selecting the assignment whose corresponding list of indices is lexicographically smallest.\n\nThe implementation will consist of helper functions to calculate IoU, and dedicated functions for the greedy and ILP algorithms. The main procedure will iterate through the provided test suite, execute both algorithms, and format the results as specified, including the selected indices, total scores, and a boolean comparison of the selected index sets. Scores will be reported rounded to three decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the NMS problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"t\": 0.3,\n            \"boxes\": np.array([\n                [0.0, 0.0, 2.0, 2.0],\n                [0.5, 0.5, 2.5, 2.5],\n                [2.1, 0.0, 4.1, 2.0],\n                [0.0, 2.1, 2.0, 4.1]\n            ]),\n            \"scores\": np.array([0.90, 0.85, 0.70, 0.60])\n        },\n        {\n            \"t\": 0.5,\n            \"boxes\": np.array([\n                [0.0, 0.0, 2.0, 2.0],\n                [0.5, 0.0, 2.5, 2.0],\n                [1.0, 0.0, 3.0, 2.0]\n            ]),\n            \"scores\": np.array([0.60, 0.95, 0.60])\n        },\n        {\n            \"t\": 0.0,\n            \"boxes\": np.array([\n                [0.0, 0.0, 1.0, 1.0],\n                [2.0, 0.0, 3.0, 1.0],\n                [4.0, 0.0, 5.0, 1.0]\n            ]),\n            \"scores\": np.array([0.50, 0.70, 0.60])\n        },\n        {\n            \"t\": 1.0,\n            \"boxes\": np.array([\n                [0.0, 0.0, 1.0, 1.0],\n                [0.0, 0.0, 1.0, 1.0],\n                [2.0, 2.0, 3.0, 3.0]\n            ]),\n            \"scores\": np.array([0.60, 0.59, 0.40])\n        },\n        {\n            \"t\": 0.5,\n            \"boxes\": np.array([\n                [0.0, 0.0, 2.0, 2.0],\n                [0.5, 0.0, 2.5, 2.0],\n                [3.0, 0.0, 5.0, 2.0]\n            ]),\n            \"scores\": np.array([0.80, 0.80, 0.10])\n        }\n    ]\n\n    def calculate_iou(box1, box2):\n        \"\"\"Calculates Intersection over Union for two bounding boxes.\"\"\"\n        x1_1, y1_1, x2_1, y2_1 = box1\n        x1_2, y1_2, x2_2, y2_2 = box2\n\n        inter_x1 = max(x1_1, x1_2)\n        inter_y1 = max(y1_1, y1_2)\n        inter_x2 = min(x2_1, x2_2)\n        inter_y2 = min(y2_1, y2_2)\n\n        inter_w = max(0, inter_x2 - inter_x1)\n        inter_h = max(0, inter_y2 - inter_y1)\n        intersection_area = inter_w * inter_h\n\n        area1 = (x2_1 - x1_1) * (y2_1 - y1_1)\n        area2 = (x2_2 - x1_2) * (y2_2 - y1_2)\n        union_area = area1 + area2 - intersection_area\n\n        if union_area == 0:\n            return 0.0\n        return intersection_area / union_area\n\n    def greedy_nms(boxes, scores, threshold):\n        \"\"\"Performs greedy Non-Maximum Suppression.\"\"\"\n        indices = np.arange(len(scores))\n        \n        # Sort by score (desc) and then index (asc for tie-breaking)\n        sorted_indices = sorted(indices, key=lambda i: (-scores[i], i))\n        \n        selected_indices = []\n        suppressed = np.zeros(len(scores), dtype=bool)\n\n        for i in sorted_indices:\n            if not suppressed[i]:\n                selected_indices.append(i)\n                for j in sorted_indices:\n                    if i != j and not suppressed[j]:\n                        iou = calculate_iou(boxes[i], boxes[j])\n                        if iou >= threshold:\n                            suppressed[j] = True\n        \n        return sorted(selected_indices)\n\n    def ilp_nms(boxes, scores, threshold):\n        \"\"\"Performs exact NMS via ILP formulation (solved by enumeration).\"\"\"\n        num_boxes = len(scores)\n        conflicts = []\n        for i in range(num_boxes):\n            for j in range(i + 1, num_boxes):\n                if calculate_iou(boxes[i], boxes[j]) >= threshold:\n                    conflicts.append((i, j))\n\n        max_score = -1.0\n        best_selection = []\n\n        # Enumerate all 2^N subsets of boxes\n        for i in range(1  num_boxes):\n            current_selection_indices = []\n            for j in range(num_boxes):\n                if (i >> j)  1:\n                    current_selection_indices.append(j)\n            \n            # Check feasibility\n            is_feasible = True\n            for c1, c2 in conflicts:\n                if c1 in current_selection_indices and c2 in current_selection_indices:\n                    is_feasible = False\n                    break\n            \n            if is_feasible:\n                current_score = np.sum(scores[current_selection_indices])\n                \n                if current_score > max_score:\n                    max_score = current_score\n                    best_selection = current_selection_indices\n                elif current_score == max_score:\n                    if not best_selection or current_selection_indices  best_selection:\n                        best_selection = current_selection_indices\n\n        return sorted(best_selection)\n\n    results = []\n    for case in test_cases:\n        t, boxes, scores = case[\"t\"], case[\"boxes\"], case[\"scores\"]\n        \n        # Greedy NMS\n        greedy_indices = greedy_nms(boxes, scores, t)\n        greedy_score = np.sum(scores[greedy_indices])\n\n        # ILP NMS\n        ilp_indices = ilp_nms(boxes, scores, t)\n        ilp_score = np.sum(scores[ilp_indices])\n\n        are_identical = (greedy_indices == ilp_indices)\n        \n        G_str = f\"[{','.join(map(str, greedy_indices))}]\"\n        O_str = f\"[{','.join(map(str, ilp_indices))}]\"\n        \n        # Format the result list for this case as a string\n        case_result_str = (\n            f\"[{G_str},\"\n            f\"{O_str},\"\n            f\"{str(are_identical).lower()},\"\n            f\"{greedy_score:.3f},\"\n            f\"{ilp_score:.3f}]\"\n        )\n        results.append(case_result_str)\n\n    # Print the final list of results\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3159494"}, {"introduction": "A key limitation of standard NMS is its reliance on the Intersection over Union (IoU) metric, which can unfairly penalize smaller objects that are heavily overlapped by larger ones. This hands-on problem [@problem_id:3159508] moves beyond simply applying algorithms to designing them. You will derive a new, more nuanced overlap metric from a set of logical constraints, tackling this specific failure case and learning how to adapt core components of a system to improve its real-world performance.", "problem": "A modern object detector outputs multiple bounding boxes per object and uses non-maximum suppression to keep the highest-scoring detection while suppressing others that overlap strongly with it. The standard overlap measure is Intersection over Union (IoU), defined for two axis-aligned rectangles as the ratio of the area of their intersection to the area of their union. Let $\\operatorname{IoU}(B_{1},B_{2}) = \\frac{A(B_{1} \\cap B_{2})}{A(B_{1} \\cup B_{2})}$, where $A(\\cdot)$ denotes area and $\\cap,\\cup$ denote intersection and union. To handle the asymmetry in suppressing candidates, define Intersection over Area (IoA) with respect to the box designated for suppression as $\\operatorname{IoA}_{\\mathrm{sup}}(B_{\\mathrm{sup}},B_{\\mathrm{keep}}) = \\frac{A(B_{\\mathrm{sup}} \\cap B_{\\mathrm{keep}})}{A(B_{\\mathrm{sup}})}$, which measures the fraction of the candidate-to-be-suppressed covered by the box being kept.\n\nConsider a scenario in which a small true-positive box is partially overlapped by a larger box with a higher confidence score. To prevent suppressing the small true positive, you will construct a combined overlap metric $M$ that depends on $\\operatorname{IoU}$ and $\\operatorname{IoA}_{\\mathrm{sup}}$. Derive an explicit closed-form expression for $M(\\operatorname{IoU},\\operatorname{IoA}_{\\mathrm{sup}})$ from the following requirements rooted in the role these quantities play in non-maximum suppression:\n\n- When the candidate-to-be-suppressed is completely covered by the kept box, the effective overlap for suppression should vanish: for any $\\operatorname{IoU} \\in [0,1]$, $M(\\operatorname{IoU},1) = 0$.\n- When the candidate-to-be-suppressed does not overlap the kept box, the combined overlap should reduce to the standard $\\operatorname{IoU}$: for any $\\operatorname{IoU} \\in [0,1]$, $M(\\operatorname{IoU},0) = \\operatorname{IoU}$.\n- For fixed $\\operatorname{IoA}_{\\mathrm{sup}}$, $M$ should be monotonically increasing in $\\operatorname{IoU}$.\n- For fixed $\\operatorname{IoU}$, $M$ should be monotonically decreasing in $\\operatorname{IoA}_{\\mathrm{sup}}$.\n- Among bivariate polynomials in $\\operatorname{IoU}$ and $\\operatorname{IoA}_{\\mathrm{sup}}$ of total degree at most $2$, select the simplest form that satisfies the above constraints.\n\nThen, evaluate your derived $M$ for the following pair of detections where the smaller box is the candidate to suppress and the larger box is the one to keep:\n- Small box $B_{s}$: lower-left at $(2,2)$ and upper-right at $(5,5)$.\n- Large box $B_{\\ell}$: lower-left at $(1,1)$ and upper-right at $(6,4)$.\n\nCompute the numerical value of $M(\\operatorname{IoU}(B_{s},B_{\\ell}), \\operatorname{IoA}_{\\mathrm{sup}}(B_{s},B_{\\ell}))$ and round your final answer to four significant figures. The final answer must be a single real-valued number with no units.", "solution": "The problem is deemed valid as it is scientifically grounded in the domain of deep learning, well-posed with a clear set of constraints, and formulated with objective and precise language. All necessary information is provided, and there are no internal contradictions.\n\nThe task is to first derive a closed-form expression for a combined overlap metric $M(\\operatorname{IoU}, \\operatorname{IoA}_{\\mathrm{sup}})$ and then evaluate it for a specific pair of bounding boxes.\n\nLet $x = \\operatorname{IoU}$ and $y = \\operatorname{IoA}_{\\mathrm{sup}}$. We are searching for the simplest bivariate polynomial $M(x, y)$ of total degree at most $2$ that satisfies the given constraints. A general polynomial of total degree $2$ has the form:\n$$M(x, y) = c_{00} + c_{10}x + c_{01}y + c_{20}x^2 + c_{11}xy + c_{02}y^2$$\n\nWe apply the given constraints to determine the coefficients $c_{ij}$.\n\nConstraint 2: $M(x, 0) = x$ for any $x \\in [0,1]$.\nSubstituting $y=0$ into the polynomial gives:\n$$M(x, 0) = c_{00} + c_{10}x + c_{20}x^2$$\nFor this to be identically equal to $x$, the coefficients of like powers of $x$ must match. This yields:\n$c_{00} = 0$, $c_{10} = 1$, and $c_{20} = 0$.\nThe polynomial simplifies to:\n$$M(x, y) = x + c_{01}y + c_{11}xy + c_{02}y^2$$\n\nConstraint 1: $M(x, 1) = 0$ for any $x \\in [0,1]$.\nSubstituting $y=1$ into the simplified polynomial gives:\n$$M(x, 1) = x + c_{01}(1) + c_{11}x(1) + c_{02}(1)^2 = (1 + c_{11})x + (c_{01} + c_{02})$$\nFor this to be identically equal to $0$ for all $x$, the coefficients must be zero:\n$1 + c_{11} = 0 \\implies c_{11} = -1$.\n$c_{01} + c_{02} = 0 \\implies c_{01} = -c_{02}$.\nThe polynomial now takes the form:\n$$M(x, y) = x - c_{02}y - xy + c_{02}y^2$$\n\nConstraint 5: Select the simplest form. A polynomial is generally considered simpler if it has fewer terms or a lower overall degree. The current form has degree $2$. A linear polynomial (degree $1$) was ruled out as it cannot satisfy both constraints $1$ and $2$ simultaneously. The simplest form of the current polynomial is obtained by setting the remaining free coefficient $c_{02}$ to the simplest possible value, which is $0$.\nIf we set $c_{02} = 0$, then $c_{01} = -c_{02} = 0$. The polynomial becomes:\n$$M(x, y) = x - xy = x(1 - y)$$\nThis is a polynomial of total degree $2$.\n\nWe must now verify if this form satisfies the remaining monotonicity constraints.\nConstraint 3: $M$ is monotonically increasing in $x$ for a fixed $y$.\nWe compute the partial derivative with respect to $x$:\n$$\\frac{\\partial M}{\\partial x} = \\frac{\\partial}{\\partial x} (x(1-y)) = 1 - y$$\nSince $y = \\operatorname{IoA}_{\\mathrm{sup}}$ is a ratio of areas, its value is in the range $[0, 1]$. Therefore, $1 - y \\ge 0$, which confirms that $M$ is monotonically non-decreasing in $x$. This satisfies the constraint.\n\nConstraint 4: $M$ is monotonically decreasing in $y$ for a fixed $x$.\nWe compute the partial derivative with respect to $y$:\n$$\\frac{\\partial M}{\\partial y} = \\frac{\\partial}{\\partial y} (x(1-y)) = -x$$\nSince $x = \\operatorname{IoU}$ is also a ratio of areas, its value is in the range $[0, 1]$. Therefore, $-x \\le 0$, which confirms that $M$ is monotonically non-increasing in $y$. This satisfies the constraint.\n\nThe simplest polynomial satisfying all constraints is thus $M(x, y) = x(1-y)$. In terms of the original variables:\n$$M(\\operatorname{IoU}, \\operatorname{IoA}_{\\mathrm{sup}}) = \\operatorname{IoU} (1 - \\operatorname{IoA}_{\\mathrm{sup}})$$\n\nNext, we evaluate this metric for the given bounding boxes.\nThe small box to be suppressed is $B_s$, with lower-left corner at $(2,2)$ and upper-right corner at $(5,5)$.\nIts width is $w_s = 5 - 2 = 3$ and its height is $h_s = 5 - 2 = 3$.\nThe area is $A(B_s) = w_s \\times h_s = 3 \\times 3 = 9$.\n\nThe large box to be kept is $B_\\ell$, with lower-left corner at $(1,1)$ and upper-right corner at $(6,4)$.\nIts width is $w_\\ell = 6 - 1 = 5$ and its height is $h_\\ell = 4 - 1 = 3$.\nThe area is $A(B_\\ell) = w_\\ell \\times h_\\ell = 5 \\times 3 = 15$.\n\nWe compute the area of the intersection, $A(B_s \\cap B_\\ell)$. The coordinates of the intersection rectangle are given by:\n$x_{\\text{min,int}} = \\max(2, 1) = 2$\n$y_{\\text{min,int}} = \\max(2, 1) = 2$\n$x_{\\text{max,int}} = \\min(5, 6) = 5$\n$y_{\\text{max,int}} = \\min(5, 4) = 4$\nThe width of the intersection is $w_{\\text{int}} = 5 - 2 = 3$.\nThe height of the intersection is $h_{\\text{int}} = 4 - 2 = 2$.\nThe area of the intersection is $A(B_s \\cap B_\\ell) = w_{\\text{int}} \\times h_{\\text{int}} = 3 \\times 2 = 6$.\n\nNow we can compute $\\operatorname{IoU}$ and $\\operatorname{IoA}_{\\mathrm{sup}}$.\nThe area of the union is $A(B_s \\cup B_\\ell) = A(B_s) + A(B_\\ell) - A(B_s \\cap B_\\ell) = 9 + 15 - 6 = 18$.\nThe Intersection over Union is:\n$$\\operatorname{IoU}(B_s, B_\\ell) = \\frac{A(B_s \\cap B_\\ell)}{A(B_s \\cup B_\\ell)} = \\frac{6}{18} = \\frac{1}{3}$$\nThe candidate for suppression is $B_s$, so $B_{\\mathrm{sup}} = B_s$. The Intersection over Area of the suppressed box is:\n$$\\operatorname{IoA}_{\\mathrm{sup}}(B_s, B_\\ell) = \\frac{A(B_s \\cap B_\\ell)}{A(B_s)} = \\frac{6}{9} = \\frac{2}{3}$$\n\nFinally, we substitute these values into our derived expression for $M$:\n$$M\\left(\\frac{1}{3}, \\frac{2}{3}\\right) = \\frac{1}{3} \\left(1 - \\frac{2}{3}\\right) = \\frac{1}{3} \\left(\\frac{1}{3}\\right) = \\frac{1}{9}$$\nThe problem requires the answer rounded to four significant figures.\n$$\\frac{1}{9} = 0.111111... \\approx 0.1111$$", "answer": "$$\\boxed{0.1111}$$", "id": "3159508"}, {"introduction": "Modern computer vision has moved beyond simple bounding boxes to more precise instance masks, especially in tasks like instance segmentation. This shift in representation has profound implications for post-processing steps like NMS. In this exercise [@problem_id:3159563], you will implement and compare traditional box-NMS with mask-NMS, using exact geometric formulas. This will concretely demonstrate how a more accurate object representation can drastically reduce false suppressions in crowded scenes, a critical insight for building state-of-the-art detection systems.", "problem": "You are given a task to formalize and test the hypothesis that, in crowded scenes where multiple instances are spatially close, non-maximum suppression based on instance masks (mask non-maximum suppression) suppresses fewer true positives than non-maximum suppression based on axis-aligned bounding boxes (box non-maximum suppression). Your program must implement both strategies and evaluate them on a synthetic family of scenes that you will construct from first principles.\n\nStart from the following foundational definitions and facts.\n\n1. Let each predicted instance be represented as both a geometric set and a real-valued confidence score. A box is a closed axis-aligned square in the plane, and a mask is a closed set describing the region occupied by the instance. For two sets $A$ and $B$ in the plane with finite area (Lebesgue measure), define the intersection area as $\\mu(A \\cap B)$ and the union area as $\\mu(A \\cup B)$. The intersection-over-union similarity is $\\mathrm{IoU}(A,B) = \\dfrac{\\mu(A \\cap B)}{\\mu(A \\cup B)}$ whenever $\\mu(A \\cup B) \\neq 0$.\n\n2. Non-maximum suppression (NMS) is a greedy selection over a list of detections sorted by descending confidence scores. Given a threshold $\\tau \\in (0,1)$ and a similarity function $S(\\cdot,\\cdot)$ obeying $S \\in [0,1]$, the algorithm proceeds by:\n   - Sorting detections by decreasing score.\n   - Iterating the sorted list: a detection $d$ is kept if its similarity to all previously kept detections is strictly less than $\\tau$; it is suppressed otherwise.\n   - We explicitly define suppression when $S \\ge \\tau$ and keep when $S  \\tau$.\n   In box non-maximum suppression, $S$ is $\\mathrm{IoU}$ computed between axis-aligned squares (bounding boxes). In mask non-maximum suppression, $S$ is $\\mathrm{IoU}$ computed between instance masks.\n\n3. Consider a synthetic crowded scene constructed as an integer grid of instance centers with spacing $(g_x,g_y)$ along the horizontal and vertical directions. Each instance $i$ has:\n   - A box which is a square of side length $s  0$ centered at its grid location.\n   - A mask which is either:\n     - A disk (circle filled-in) of radius $r$ centered at the same location, with $0  r \\le s/2$, or\n     - The same square as the box (so that mask and box coincide).\n   You must use exact geometric formulas for the area of intersection of two axis-aligned squares and for the area of intersection of two disks. If you use inverse trigonometric functions for disk intersections, use radians. Do not approximate via discretization.\n\n4. For a grid with centers $(x_i,y_i)$ and $(x_j,y_j)$, where $|x_i-x_j| = \\Delta x$ and $|y_i-y_j| = \\Delta y$, the overlap area of two axis-aligned squares of side $s$ is $\\max(0, s - \\Delta x) \\cdot \\max(0, s - \\Delta y)$, and is $0$ if either factor is non-positive. The area of the union is the sum of areas minus the intersection area. The disk intersection area between two disks of equal radius $r$ separated by center distance $d$ is a known closed form in terms of $d$, $r$, and the inverse cosine, which must be used exactly. The union area is the sum of disk areas minus the intersection area.\n\n5. Define a false suppression as any instance suppressed by the algorithm when all detections represent distinct ground-truth instances (i.e., no duplicate detections for the same object). In such a setting, the ideal algorithm would keep all detections; any suppression is an error, and the false suppression count equals the number of suppressed detections.\n\nYour tasks are:\n\nA. Derive, from these definitions and without introducing any untested assumptions, conditions on $(s,g_x,g_y,r,\\tau)$ under which box non-maximum suppression suppresses a pair of neighboring instances while mask non-maximum suppression does not for the same pair. Your derivation should use only the geometric and measure-theoretic definitions above and standard analytic formulas for areas. Explain why a disk mask with $r  s/2$ can reduce the mask intersection-over-union relative to the box intersection-over-union for nearest neighbors on the grid when the spacing is tight, making it less likely for mask non-maximum suppression to suppress.\n\nB. Implement both algorithms exactly as defined, using:\n   - Boxes as axis-aligned squares of side $s$.\n   - Masks either as disks of radius $r$ or as the same squares as the boxes.\n   - Similarity $S$ computed as $\\mathrm{IoU}$ for boxes and masks respectively.\n   - Suppression when $S \\ge \\tau$.\n\nC. Evaluate the algorithms on the following test suite. In all cases, assign unique scores in strictly descending order by row-major index so that the top-left instance has the highest score, proceeding left-to-right then top-to-bottom.\n\n- Test case $1$ (happy path crowded grid where mask non-maximum suppression is expected to suppress fewer): grid size $3 \\times 3$, spacing $(g_x,g_y) = (10,10)$, square side $s = 40$, disk radius $r = 12$, threshold $\\tau = 0.5$, masks are disks. Angles in any inverse trigonometric expressions must be in radians.\n\n- Test case $2$ (boundary condition at equality): grid size $1 \\times 3$, spacing $(g_x,g_y) = (10,1000)$, square side $s = 40$, disk radius $r = 12$, threshold $\\tau = 0.6$, masks are disks. This isolates a one-dimensional chain so that nearest-neighbor box intersection-over-union equals the threshold.\n\n- Test case $3$ (masks equal boxes): grid size $3 \\times 3$, spacing $(g_x,g_y) = (10,10)$, square side $s = 40$, threshold $\\tau = 0.5$, masks are the same squares as boxes. This forces mask non-maximum suppression to match box non-maximum suppression.\n\n- Test case $4$ (no overlap): grid size $2 \\times 2$, spacing $(g_x,g_y) = (50,50)$, square side $s = 40$, disk radius $r = 12$, threshold $\\tau = 0.5$, masks are disks. This ensures zero overlap for both shapes.\n\nYour program must compute, for each test case in order, the triple consisting of: the integer false suppression count for box non-maximum suppression, the integer false suppression count for mask non-maximum suppression, and a boolean indicating whether mask non-maximum suppression yields a strictly smaller false suppression count than box non-maximum suppression on that test case.\n\nFinal output format: Your program should produce a single line of output containing all results concatenated as a single comma-separated list enclosed in square brackets. For each test case, append the three outputs in order. For example, the output should have the form $[b_1,m_1,f_1,b_2,m_2,f_2,b_3,m_3,f_3,b_4,m_4,f_4]$, where $b_k$ and $m_k$ are integers and $f_k$ is a boolean.", "solution": "The problem statement has been validated and found to be scientifically grounded, well-posed, objective, and internally consistent. It provides a formal framework for testing the hypothesis that mask-based non-maximum suppression (NMS) can outperform box-based NMS in crowded scenes. We will proceed with a solution.\n\nThe solution is presented in three parts as requested: a theoretical derivation, an overview of the implementation, and the evaluation on the specified test suite.\n\n### A. Derivation and Theoretical Analysis\n\nThe core of the problem is to identify conditions under which box NMS suppresses a pair of nearby object detections while mask NMS does not. This occurs when the similarity score for the pair exceeds a threshold $\\tau$ for boxes but not for masks. Let two instances be denoted by their geometric sets, $A$ and $B$. The Intersection-over-Union (IoU) is given by $\\mathrm{IoU}(A,B) = \\frac{\\mu(A \\cap B)}{\\mu(A \\cup B)}$. Since all instances of a given type (box or mask) are identical in shape and size, their areas are equal: $\\mu(A) = \\mu(B)$. The union area is $\\mu(A \\cup B) = \\mu(A) + \\mu(B) - \\mu(A \\cap B) = 2\\mu(A) - \\mu(A \\cap B)$. The IoU is then:\n$$ \\mathrm{IoU}(A,B) = \\frac{\\mu(A \\cap B)}{2\\mu(A) - \\mu(A \\cap B)} $$\nThis is a monotonically increasing function of the intersection area $\\mu(A \\cap B)$.\n\nLet's analyze two nearest-neighbor instances on the grid, for example, two instances separated horizontally by the grid spacing $g_x$. Their center-to-center distance is $d = g_x$. We assume $g_x  s$ for boxes to overlap and $g_x  2r$ for disks to overlap.\n\n**1. Box Non-Maximum Suppression (Box NMS)**\nFor two axis-aligned squares of side length $s$ with centers separated by $(\\Delta x, \\Delta y) = (g_x, 0)$, the intersection area is:\n$$ \\mu(B_1 \\cap B_2) = \\max(0, s - g_x) \\cdot \\max(0, s - 0) = s(s - g_x) $$\nThe area of a single box is $\\mu(B) = s^2$. The IoU for the boxes is:\n$$ \\mathrm{IoU}_{box} = \\frac{s(s-g_x)}{2s^2 - s(s-g_x)} = \\frac{s(s-g_x)}{s^2 + sg_x} = \\frac{s-g_x}{s+g_x} $$\n\n**2. Mask Non-Maximum Suppression (Mask NMS with Disks)**\nFor two disks of radius $r$ with centers separated by distance $d = g_x$, the intersection area, for $0 \\le d \\le 2r$, is given by the formula for the area of a lens formed by two overlapping circles:\n$$ \\mu(M_1 \\cap M_2) = 2r^2 \\cos^{-1}\\left(\\frac{d}{2r}\\right) - \\frac{d}{2}\\sqrt{4r^2 - d^2} $$\nThe area of a single disk is $\\mu(M) = \\pi r^2$. The IoU for the aasks is:\n$$ \\mathrm{IoU}_{mask} = \\frac{\\mu(M_1 \\cap M_2)}{2\\pi r^2 - \\mu(M_1 \\cap M_2)} $$\n\n**3. Condition for Differential Suppression**\nBox NMS suppresses the pair while mask NMS does not under the following joint condition, given the suppression rule $S \\ge \\tau$:\n$$ \\mathrm{IoU}_{box} \\ge \\tau \\quad \\land \\quad \\mathrm{IoU}_{mask}  \\tau $$\nSubstituting the derived expressions, we get the explicit conditions on the parameters $(s, g_x, r, \\tau)$:\n$$ \\frac{s-g_x}{s+g_x} \\ge \\tau \\quad \\land \\quad \\frac{2r^2 \\cos^{-1}\\left(\\frac{g_x}{2r}\\right) - \\frac{g_x}{2}\\sqrt{4r^2 - g_x^2}}{2\\pi r^2 - \\left(2r^2 \\cos^{-1}\\left(\\frac{g_x}{2r}\\right) - \\frac{g_x}{2}\\sqrt{4r^2 - g_x^2}\\right)}  \\tau $$\n\n**4. Explanation for IoU Discrepancy**\nThe hypothesis that $\\mathrm{IoU}_{mask}  \\mathrm{IoU}_{box}$ under relevant conditions is based on the geometric \"tightness\" of the representations. Tighter masks reduce spurious overlap.\n- An axis-aligned square bounding box is a loose approximation of many object shapes. For a disk of radius $r$, the minimal bounding square must have side $s = 2r$. The area of this box is $s^2 = 4r^2$, while the disk's area is $\\pi r^2 \\approx 3.14r^2$. The box contains \"empty\" area in its corners, about $4r^2 - \\pi r^2 \\approx 0.86r^2$, which is over $21\\%$ of the box's area. The problem statement allows $r \\le s/2$, so this discrepancy can be even larger.\n- When two such boxes overlap, these empty corner regions can contribute to the intersection area $\\mu(B_1 \\cap B_2)$, artificially inflating it relative to the true object overlap. The IoU, being a function of this intersection, is consequently higher.\n- A disk mask is a \"tighter\" representation. The intersection area $\\mu(M_1 \\cap M_2)$ corresponds to the actual overlap of the instances.\n- The IoU is a monotonically increasing function of the relative intersection area, defined as $\\rho = \\frac{\\mu(A \\cap B)}{\\mu(A)}$. To have $\\mathrm{IoU}_{box}  \\mathrm{IoU}_{mask}$, we need $\\rho_{box}  \\rho_{mask}$.\n$$ \\rho_{box} = \\frac{s(s-g_x)}{s^2} = 1 - \\frac{g_x}{s} $$\n$$ \\rho_{mask} = \\frac{2r^2 \\cos^{-1}\\left(\\frac{g_x}{2r}\\right) - \\frac{g_x}{2}\\sqrt{4r^2 - g_x^2}}{\\pi r^2} $$\nFor small separations $g_x$ and for a disk radius $r$ significantly smaller than $s/2$, the box overlap ratio $\\rho_{box}$ is typically larger than the disk overlap ratio $\\rho_{mask}$. The box, being a coarser approximation, overestimates the overlap, leading to a higher IoU and a greater propensity for false suppressions in crowded scenes.\n\n### B. Implementation Strategy\n\nThe implementation will consist of several components: geometric utility functions, a generic NMS function, and a main routine to execute the test cases.\n\n**1. Data Structures:**\nEach detection will be represented as a dictionary containing its ID, score, and center coordinates: `{'id': k, 'score': score, 'center': (cx, cy)}`. The list of all detections is sorted by score in descending order to prepare for the NMS algorithm.\n\n**2. Geometric Calculation Functions:**\n- `box_iou(center1, center2, s)`: This function calculates the IoU between two squares of side $s$. It takes two center points, computes the separations $\\Delta x$ and $\\Delta y$, calculates the intersection area $\\max(0, s - \\Delta x) \\cdot \\max(0, s - \\Delta y)$, and from this, the union and IoU.\n- `disk_iou(center1, center2, r)`: This function calculates the IoU between two disks of radius $r$. It computes the Euclidean distance $d$ between centers. It handles three cases: if $d \\ge 2r$, intersection is $0$; if $d=0$, intersection is $\\pi r^2$ (IoU is $1$); otherwise, it applies the closed-form formula for the lens area. The union and IoU are then computed.\n\n**3. Non-Maximum Suppression Algorithm:**\nA single function `perform_nms(detections, tau, similarity_func)` will implement the NMS logic.\n- **Inputs**: A sorted list of `detections`, a suppression threshold `tau`, and a `similarity_func` (either `box_iou` or `disk_iou`, adapted to handle detection dictionaries).\n- **Process**: The function iterates through the sorted detections. It maintains a list of `kept_detections`. For each new detection, it computes its similarity to every detection already in `kept_detections`. If the similarity is greater than or equal to `tau` ($\\ge$) for any of the kept detections, the new detection is marked as suppressed. Otherwise, it is added to the `kept_detections` list.\n- **Output**: The function returns the total count of suppressed detections.\n\n### C. Evaluation on Test Suite\n\nThe program will systemically evaluate each of the four test cases provided. For each case:\n1.  A list of detections is generated according to the specified grid size, spacing, and scoring rule (scores descending by row-major index).\n2.  The `perform_nms` function is called twice:\n    a. Once for box NMS, using the `box_iou` calculator with side length $s$.\n    b. Once for mask NMS, using the appropriate similarity calculator: `disk_iou` with radius $r$ for disk masks, or `box_iou` with side $s$ if masks are squares.\n3.  The number of false suppressions for both methods is recorded.\n4.  A boolean flag is computed to indicate if the mask NMS suppression count is strictly less than the box NMS count.\n5.  The resulting triple of (box suppressions, mask suppressions, boolean flag) is stored.\nFinally, all results are aggregated into a single list and printed in the specified format. The implementation will use `numpy` for precise mathematical constants and functions.", "answer": "```python\nimport numpy as np\n\ndef get_disk_intersection_area(d, r):\n    \"\"\"\n    Calculates the intersection area of two disks of equal radius.\n    \n    Args:\n        d (float): Distance between the centers of the two disks.\n        r (float): Radius of the disks.\n\n    Returns:\n        float: The intersection area. Returns 0 if d >= 2*r.\n    \"\"\"\n    if d >= 2 * r:\n        return 0.0\n    if d == 0.0:\n        return np.pi * r**2\n    # From the formula for the area of a circular segment/lens\n    term1 = 2 * r**2 * np.arccos(d / (2 * r))\n    term2 = (d / 2) * np.sqrt(4 * r**2 - d**2)\n    return term1 - term2\n\ndef box_similarity(det1, det2, s):\n    \"\"\"Calculates IoU for two square boxes.\"\"\"\n    center1 = det1['center']\n    center2 = det2['center']\n    delta_x = abs(center1[0] - center2[0])\n    delta_y = abs(center1[1] - center2[1])\n\n    if delta_x >= s or delta_y >= s:\n        intersection_area = 0.0\n    else:\n        intersection_area = (s - delta_x) * (s - delta_y)\n\n    if intersection_area == 0.0:\n        return 0.0\n    \n    area_box = s**2\n    union_area = 2 * area_box - intersection_area\n    \n    return intersection_area / union_area\n\ndef disk_similarity(det1, det2, r):\n    \"\"\"Calculates IoU for two disk masks.\"\"\"\n    center1 = det1['center']\n    center2 = det2['center']\n    d = np.sqrt((center1[0] - center2[0])**2 + (center1[1] - center2[1])**2)\n    \n    intersection_area = get_disk_intersection_area(d, r)\n\n    if intersection_area == 0.0:\n        return 0.0\n\n    area_disk = np.pi * r**2\n    union_area = 2 * area_disk - intersection_area\n    \n    return intersection_area / union_area\n\ndef perform_nms(detections, tau, similarity_func, **kwargs):\n    \"\"\"\n    Performs non-maximum suppression on a list of detections.\n    \n    Args:\n        detections (list): A list of detection dictionaries, sorted by score.\n        tau (float): The IoU threshold for suppression.\n        similarity_func (function): The function to compute similarity (IoU).\n        **kwargs: Additional parameters for the similarity function (e.g., s or r).\n\n    Returns:\n        int: The number of suppressed detections.\n    \"\"\"\n    kept_detections = []\n    suppressed_count = 0\n\n    for det in detections:\n        is_suppressed = False\n        for kept_det in kept_detections:\n            similarity = similarity_func(det, kept_det, **kwargs)\n            if similarity >= tau:\n                is_suppressed = True\n                suppressed_count += 1\n                break\n        \n        if not is_suppressed:\n            kept_detections.append(det)\n            \n    return suppressed_count\n\ndef solve():\n    \"\"\"\n    Main function to run the NMS evaluation on the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: Crowded grid, disk mask. Expect mask NMS to be better.\n        {'grid_dims': (3, 3), 'spacing': (10, 10), 's': 40, 'r': 12, 'tau': 0.5, 'mask_type': 'disk'},\n        # Case 2: 1D boundary condition.\n        {'grid_dims': (1, 3), 'spacing': (10, 1000), 's': 40, 'r': 12, 'tau': 0.6, 'mask_type': 'disk'},\n        # Case 3: Masks are squares, should be identical to box NMS.\n        {'grid_dims': (3, 3), 'spacing': (10, 10), 's': 40, 'r': None, 'tau': 0.5, 'mask_type': 'square'},\n        # Case 4: No overlap.\n        {'grid_dims': (2, 2), 'spacing': (50, 50), 's': 40, 'r': 12, 'tau': 0.5, 'mask_type': 'disk'},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        grid_h, grid_w = case['grid_dims']\n        g_x, g_y = case['spacing']\n        s = case['s']\n        r = case['r']\n        tau = case['tau']\n        mask_type = case['mask_type']\n\n        # Generate detections, sorted by score (descending) based on row-major index\n        detections = []\n        num_detections = grid_h * grid_w\n        for i in range(grid_h):\n            for j in range(grid_w):\n                idx = i * grid_w + j\n                detection = {\n                    'id': idx,\n                    'score': num_detections - idx,\n                    'center': (j * g_x, i * g_y)\n                }\n                detections.append(detection)\n\n        # Run Box NMS\n        box_suppressions = perform_nms(detections, tau, box_similarity, s=s)\n\n        # Run Mask NMS\n        if mask_type == 'disk':\n            mask_suppressions = perform_nms(detections, tau, disk_similarity, r=r)\n        elif mask_type == 'square':\n            # Masks are the same as boxes\n            mask_suppressions = perform_nms(detections, tau, box_similarity, s=s)\n        \n        less_suppressions = mask_suppressions  box_suppressions\n\n        results.extend([box_suppressions, mask_suppressions, str(less_suppressions).lower()])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3159563"}]}