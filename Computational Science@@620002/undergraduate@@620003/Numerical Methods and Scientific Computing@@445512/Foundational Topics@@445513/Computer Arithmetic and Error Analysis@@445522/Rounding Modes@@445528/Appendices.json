{"hands_on_practices": [{"introduction": "This first exercise provides a foundational look into how real-world numbers are represented in digital systems with limited precision. By converting a decimal value into a fixed-point binary format, you will directly apply two common rounding modesâ€”truncation and round-to-nearest. This practice is crucial for understanding the trade-offs in hardware design, especially in resource-constrained environments like the embedded systems described in the problem [@problem_id:2199486].", "problem": "An embedded system designed for a remote environmental monitoring station utilizes a specialized low-power processor. To conserve power and silicon area, this processor avoids floating-point arithmetic and instead represents all sensor data using a signed 8-bit fixed-point format. This format is defined as Q3.4, which signifies that each 8-bit number includes 1 sign bit, 3 integer bits, and 4 fractional bits.\n\nA new barometric pressure sensor is calibrated to output a normalized value, which can be positive or negative. A specific reading from this sensor is $-0.3$. Before this value can be processed, it must be converted into the Q3.4 binary format. The processor's instruction set architecture provides two distinct rounding modes for this conversion:\n1.  **Truncation (Round toward Zero):** The fractional part of the number is discarded. For example, $5.9$ becomes $5$ and $-5.9$ becomes $-5$.\n2.  **Round-to-Nearest-Even (Convergent Rounding):** The number is rounded to the nearest integer. If the number is exactly halfway between two integers (e.g., has a fractional part of exactly $0.5$), it is rounded to the nearest even integer. For example, $5.5$ rounds to $6$, and $4.5$ rounds to $4$.\n\nDetermine the two 8-bit signed integer values that correspond to the binary patterns representing the sensor reading of $-0.3$ after it is converted using each of the two rounding modes. Present your answer as a pair of integers ordered as (result from truncation, result from round-to-nearest-even).", "solution": "In a signed Q3.4 fixed-point format with 8 bits total, there are 1 sign bit, 3 integer bits, and 4 fractional bits. The quantization step is therefore $2^{-4}$. Converting a real number $x$ to this format proceeds by scaling and rounding:\n$$\nS = x \\cdot 2^{4}, \\quad I = R(S),\n$$\nwhere $R(\\cdot)$ is the rounding rule, and the stored 8-bit signed integer is $I$. The represented real value is $I \\cdot 2^{-4}$.\n\nFor $x=-0.3$, the scaled value is\n$$\nS = -0.3 \\cdot 2^{4} = -0.3 \\cdot 16 = -4.8.\n$$\n\nUnder truncation (round toward zero), the rule discards the fractional part, which for negative values is equivalent to taking the ceiling:\n$$\nI_{\\text{trunc}} = -4.\n$$\n\nUnder round-to-nearest-even, we choose the nearest integer to $-4.8$. Since $-5$ is closer than $-4$ and there is no tie (not exactly halfway), the result is\n$$\nI_{\\text{rne}} = -5.\n$$\n\nBoth $I_{\\text{trunc}}$ and $I_{\\text{rne}}$ lie within the valid 8-bit signed range, so no saturation is needed. Thus, the required pair of 8-bit signed integers is $\\left(-4,-5\\right)$, ordered as (truncation, round-to-nearest-even).", "answer": "$$\\boxed{(-4, -5)}$$", "id": "2199486"}, {"introduction": "Floating-point arithmetic can sometimes lead to surprisingly inaccurate results, even when the underlying mathematics appears straightforward. This problem explores a classic pitfall known as \"catastrophic cancellation,\" where subtracting two nearly equal numbers obliterates significant digits of precision. By comparing a naive calculation with a numerically stable alternative, you will witness firsthand how a simple algebraic rearrangement can preserve accuracy in the face of rounding [@problem_id:2199459].", "problem": "A computational system for financial analysis operates using a specific decimal floating-point arithmetic. In this system, every number is stored and every intermediate result of an operation (addition, subtraction, multiplication, division, and square root) is immediately rounded to a precision of exactly 5 significant decimal digits. The system employs the \"round half to even\" rounding rule, where numbers are rounded to the nearest value, and a value halfway between two representable numbers is rounded to the one with an even last digit.\n\nYou are tasked with evaluating the function $f(x) = \\sqrt{x+1} - \\sqrt{x}$ for the input value $x = 8888$.\n\nFirst, compute the value of the function directly using the expression for $f(x)$. Let this result be $v_1$.\n\nSecond, compute the value using the algebraically equivalent expression $g(x) = \\frac{1}{\\sqrt{x+1} + \\sqrt{x}}$. Let this result be $v_2$.\n\nAssuming that the value $v_2$ obtained from the second method is a more accurate representation of the true value, calculate the relative error of the first method's result, $v_1$. The relative error is defined as $\\frac{|v_2 - v_1|}{|v_2|}$.\n\nExpress your final answer for the relative error as a decimal, rounded to three significant figures.", "solution": "The problem asks for the relative error between two computational methods for evaluating a function on a specific arithmetic system. The system uses decimal arithmetic with a precision of $p=5$ significant digits and rounds every intermediate operation using the \"round half to even\" rule. The input value is $x=8888$.\n\nFirst, we compute the value using the direct method, $f(x) = \\sqrt{x+1} - \\sqrt{x}$. Let's call the computed result $v_1$.\n\n1.  Calculate $x+1$:\n    $x+1 = 8888 + 1 = 8889$. This is an exact calculation and has 4 significant digits, which is less than the system's precision of 5, so no rounding is needed.\n\n2.  Calculate the first square root, $\\sqrt{x+1}$:\n    $\\sqrt{8889} \\approx 94.28149339...$. We must round this intermediate result to 5 significant digits. The first 5 digits are $94.281$. The 6th digit is 4, which is less than 5, so we round down (truncate).\n    Let's call this rounded value $y_1 = 94.281$.\n\n3.  Calculate the second square root, $\\sqrt{x}$:\n    $\\sqrt{8888} \\approx 94.27618919...$. We round this to 5 significant digits. The first 5 digits are $94.276$. The 6th digit is 1, which is less than 5, so we round down.\n    Let's call this rounded value $y_2 = 94.276$.\n\n4.  Perform the subtraction:\n    $v_1 = y_1 - y_2 = 94.281 - 94.276 = 0.005$. This result has only one significant digit. It can be represented exactly within the 5-digit precision system (as $5.0000 \\times 10^{-3}$), so no further rounding is needed.\n    So, $v_1 = 0.005$.\n\nNext, we compute the value using the alternative, algebraically equivalent method, $g(x) = \\frac{1}{\\sqrt{x+1} + \\sqrt{x}}$. Let's call the computed result $v_2$.\n\n1.  The intermediate square root calculations are the same as before. We use the rounded values:\n    $y_1 = 94.281$\n    $y_2 = 94.276$\n\n2.  Perform the addition in the denominator:\n    $y_1 + y_2 = 94.281 + 94.276 = 188.557$. This intermediate result has 6 significant digits and must be rounded to 5. The first 5 digits are $188.55$. The 6th digit is 7, which is greater than 5, so we must round up the 5th digit.\n    Let's call this rounded sum $S = 188.56$.\n\n3.  Perform the division:\n    $v_2 = \\frac{1}{S} = \\frac{1}{188.56}$. The unrounded value is approximately $0.00530335171...$. We must round this to 5 significant digits. The first 5 significant digits are $5, 3, 0, 3, 3$. The number is $0.0053033$. The next digit is 5, followed by non-zero digits ($171...$). According to the rounding rule, if the part to be discarded is greater than half a unit in the last place (which is the case here, as $0.5171... > 0.5$), we round up.\n    Rounding $0.00530335171...$ up at the 5th significant digit gives $v_2 = 0.0053034$.\n\nFinally, we calculate the relative error of $v_1$ with respect to $v_2$. The formula is $E_r = \\frac{|v_2 - v_1|}{|v_2|}$.\n\n1.  Substitute the computed values:\n    $E_r = \\frac{|0.0053034 - 0.005|}{|0.0053034|} = \\frac{0.0003034}{0.0053034}$.\n\n2.  Calculate the final value:\n    $E_r \\approx 0.05720877...$\n\n3.  Round the result to three significant figures as requested. The first three significant digits are $5, 7, 2$. The next digit is 0, so we round down.\n    The final answer is $0.0572$.", "answer": "$$\\boxed{0.0572}$$", "id": "2199459"}, {"introduction": "Beyond just applying rounding rules, a deeper understanding comes from being able to identify them in action. This challenge puts you in the role of a numerical detective, tasking you with deducing the rounding policy of a \"black-box\" system. By carefully selecting test inputs that expose the unique behavior of different tie-breaking rules, you will develop a systematic method for characterizing computational environments [@problem_id:3269799].", "problem": "You are given access to a black-box function that maps real numbers to integers. The internal rounding policy of this black-box is unknown but is guaranteed to be consistent across calls. The task is to empirically determine which rounding mode the black-box implements by querying it with inputs that are exactly at half-way points on the real number line.\n\nUse the following fundamental base to construct your reasoning: the floor function $\\lfloor x \\rfloor$, the ceiling function $\\lceil x \\rceil$, the absolute value $|x|$, and the sign function $\\operatorname{sgn}(x)$. The nearest integer to a real number $x$ is any integer $n \\in \\mathbb{Z}$ that minimizes the absolute difference $|x - n|$. A half-way point between consecutive integers occurs when $x = n + 0.5$ for some integer $n$, which implies a tie since $|x - n| = |x - (n+1)|$.\n\nDefine the following set of candidate rounding modes:\n- Code $0$: Round to nearest, ties to even. For $x = n + 0.5$, choose the even integer among $n$ and $n+1$.\n- Code $1$: Round to nearest, ties away from zero. For $x = n + 0.5$, choose the integer with larger magnitude, that is $n+1$ if $x \\ge 0$ and $n$ if $x < 0$.\n- Code $2$: Round toward zero, meaning $x$ maps to $\\operatorname{sgn}(x) \\cdot \\lfloor |x| \\rfloor$.\n- Code $3$: Round toward $+\\infty$, meaning $x$ maps to $\\lceil x \\rceil$.\n- Code $4$: Round toward $-\\infty$, meaning $x$ maps to $\\lfloor x \\rfloor$.\n- Code $5$: Round to nearest, ties to odd. For $x = n + 0.5$, choose the odd integer among $n$ and $n+1$.\n\nYour program must implement an empirical identification procedure using only the four half-way probes $x \\in \\{0.5, 1.5, -0.5, -1.5\\}$. For each black-box, record its outputs on these probes and use logical deductions grounded in the above base to determine the unique code among $\\{0,1,2,3,4,5\\}$.\n\nTest suite:\n- Test case $1$: A black-box that implements round to nearest, ties to even.\n- Test case $2$: A black-box that implements round to nearest, ties away from zero.\n- Test case $3$: A black-box that implements round toward zero.\n- Test case $4$: A black-box that implements round toward $+\\infty$.\n- Test case $5$: A black-box that implements round toward $-\\infty$.\n- Test case $6$: A black-box that implements round to nearest, ties to odd.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4,r5,r6]\"), where each $r_k$ is the integer code determined for test case $k$. No physical units are involved; all quantities are unitless real numbers and integers.", "solution": "The problem requires the development of an empirical procedure to identify which of six standard rounding modes is implemented by a given black-box function. The identification must be based solely on the function's outputs for a specific set of four input values: $x \\in \\{0.5, 1.5, -0.5, -1.5\\}$. These inputs are all \"half-way points\" between consecutive integers, which are the critical test cases for distinguishing rounding modes that handle ties differently.\n\nThe core of the solution is to first determine the unique output signatureâ€”a vector of four integer resultsâ€”that each rounding mode produces for the given probe inputs. Then, an algorithm can be designed to compute this signature for any black-box function and match it against the pre-computed signatures to identify the rounding mode.\n\nLet $f(x)$ represent the black-box rounding function. The probe vector is defined as $P = (0.5, 1.5, -0.5, -1.5)$, and the corresponding output signature is the vector $V = (f(0.5), f(1.5), f(-0.5), f(-1.5))$. We will now derive the signature vector for each of the six candidate rounding modes.\n\n**Mode 0: Round to nearest, ties to even**\nFor a number $x = n + 0.5$ where $n \\in \\mathbb{Z}$, the function rounds to the even integer among the two nearest integers, $n$ and $n+1$.\n- $f(0.5)$: With $n=0$, the candidates are $0$ and $1$. The even integer is $0$.\n- $f(1.5)$: With $n=1$, the candidates are $1$ and $2$. The even integer is $2$.\n- $f(-0.5)$: This is $-1 + 0.5$, so $n=-1$. The candidates are $-1$ and $0$. The even integer is $0$.\n- $f(-1.5)$: This is $-2 + 0.5$, so $n=-2$. The candidates are $-2$ and $-1$. The even integer is $-2$.\nThe signature vector is $V_0 = (0, 2, 0, -2)$.\n\n**Mode 1: Round to nearest, ties away from zero**\nFor a number $x = n + 0.5$, the function rounds to the integer with the larger absolute value. This is equivalent to rounding up for positive $x$ and down for negative $x$. A formal definition is $f(x) = \\operatorname{sgn}(x) \\lfloor |x| + 0.5 \\rfloor$.\n- $f(0.5) = \\operatorname{sgn}(0.5) \\lfloor |0.5| + 0.5 \\rfloor = 1 \\cdot \\lfloor 1.0 \\rfloor = 1$.\n- $f(1.5) = \\operatorname{sgn}(1.5) \\lfloor |1.5| + 0.5 \\rfloor = 1 \\cdot \\lfloor 2.0 \\rfloor = 2$.\n- $f(-0.5) = \\operatorname{sgn}(-0.5) \\lfloor |-0.5| + 0.5 \\rfloor = -1 \\cdot \\lfloor 1.0 \\rfloor = -1$.\n- $f(-1.5) = \\operatorname{sgn}(-1.5) \\lfloor |-1.5| + 0.5 \\rfloor = -1 \\cdot \\lfloor 2.0 \\rfloor = -2$.\nThe signature vector is $V_1 = (1, 2, -1, -2)$.\n\n**Mode 2: Round toward zero (truncate)**\nThe function rounds to the integer closest to zero, which is equivalent to taking the integer part of the number. The formal definition is $f(x) = \\operatorname{sgn}(x) \\lfloor |x| \\rfloor$.\n- $f(0.5) = \\operatorname{sgn}(0.5) \\lfloor |0.5| \\rfloor = 1 \\cdot 0 = 0$.\n- $f(1.5) = \\operatorname{sgn}(1.5) \\lfloor |1.5| \\rfloor = 1 \\cdot 1 = 1$.\n- $f(-0.5) = \\operatorname{sgn}(-0.5) \\lfloor |-0.5| \\rfloor = -1 \\cdot 0 = 0$.\n- $f(-1.5) = \\operatorname{sgn}(-1.5) \\lfloor |-1.5| \\rfloor = -1 \\cdot 1 = -1$.\nThe signature vector is $V_2 = (0, 1, 0, -1)$.\n\n**Mode 3: Round toward $+\\infty$ (ceiling)**\nThe function rounds to the smallest integer greater than or equal to $x$. The formal definition is $f(x) = \\lceil x \\rceil$.\n- $f(0.5) = \\lceil 0.5 \\rceil = 1$.\n- $f(1.5) = \\lceil 1.5 \\rceil = 2$.\n- $f(-0.5) = \\lceil -0.5 \\rceil = 0$.\n- $f(-1.5) = \\lceil -1.5 \\rceil = -1$.\nThe signature vector is $V_3 = (1, 2, 0, -1)$.\n\n**Mode 4: Round toward $-\\infty$ (floor)**\nThe function rounds to the largest integer less than or equal to $x$. The formal definition is $f(x) = \\lfloor x \\rfloor$.\n- $f(0.5) = \\lfloor 0.5 \\rfloor = 0$.\n- $f(1.5) = \\lfloor 1.5 \\rfloor = 1$.\n- $f(-0.5) = \\lfloor -0.5 \\rfloor = -1$.\n- $f(-1.5) = \\lfloor -1.5 \\rfloor = -2$.\nThe signature vector is $V_4 = (0, 1, -1, -2)$.\n\n**Mode 5: Round to nearest, ties to odd**\nFor a number $x = n + 0.5$ where $n \\in \\mathbb{Z}$, the function rounds to the odd integer among the two nearest integers, $n$ and $n+1$.\n- $f(0.5)$: With $n=0$, the candidates are $0$ and $1$. The odd integer is $1$.\n- $f(1.5)$: With $n=1$, the candidates are $1$ and $2$. The odd integer is $1$.\n- $f(-0.5)$: With $n=-1$, the candidates are $-1$ and $0$. The odd integer is $-1$.\n- $f(-1.5)$: With $n=-2$, the candidates are $-2$ and $-1$. The odd integer is $-1$.\nThe signature vector is $V_5 = (1, 1, -1, -1)$.\n\nSince all six signature vectors $V_0, V_1, V_2, V_3, V_4, V_5$ are unique, the set of four probes is sufficient to distinguish between the six specified rounding modes. The identification procedure is as follows:\n1.  Define a map (e.g., a dictionary) from each signature vector to its corresponding integer code.\n2.  For a given black-box function, compute its output for each of the four probe values.\n3.  Form the observed signature vector from these outputs.\n4.  Use the map to look up the code associated with the observed vector.\n\nThe provided test suite consists of six black-box functions, each implementing one of the rounding modes. The program will apply the identification procedure to each of these functions and report the determined codes.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Identifies the rounding mode of black-box functions based on their\n    outputs for a specific set of probe inputs.\n    \"\"\"\n\n    # Define the six black-box functions for the test suite, each corresponding\n    # to a specific rounding mode as defined in the problem.\n    test_cases = [\n        # Test case 1: Code 0 - Round to nearest, ties to even.\n        # Python's built-in round() implements this mode.\n        lambda x: int(round(x)),\n\n        # Test case 2: Code 1 - Round to nearest, ties away from zero.\n        # Formal definition: sgn(x) * floor(|x| + 0.5)\n        lambda x: int(np.sign(x) * np.floor(np.abs(x) + 0.5)) if x != 0 else 0,\n\n        # Test case 3: Code 2 - Round toward zero (truncate).\n        # Formal definition: sgn(x) * floor(|x|)\n        lambda x: int(np.trunc(x)),\n\n        # Test case 4: Code 3 - Round toward +infinity (ceiling).\n        # Formal definition: ceil(x)\n        lambda x: int(np.ceil(x)),\n\n        # Test case 5: Code 4 - Round toward -infinity (floor).\n        # Formal definition: floor(x)\n        lambda x: int(np.floor(x)),\n\n        # Test case 6: Code 5 - Round to nearest, ties to odd.\n        # For a half-integer x, the ties-to-even result is r = round(x).\n        # The ties-to-odd result is r if r is odd, and 2x - r if r is even.\n        # Since all probes are half-integers, we can use this logic.\n        lambda x: int((lambda r: r if r % 2 != 0 else 2 * x - r)(round(x))),\n    ]\n\n    # The four half-way point probes to be used for identification.\n    probes = [0.5, 1.5, -0.5, -1.5]\n\n    # A decision map from the unique signature vector to the rounding mode code.\n    # The vectors were derived from the formal definitions in the problem statement.\n    # The key is a tuple: (f(0.5), f(1.5), f(-0.5), f(-1.5))\n    decision_map = {\n        (0, 2, 0, -2): 0,  # Ties to even\n        (1, 2, -1, -2): 1,  # Ties away from zero\n        (0, 1, 0, -1): 2,  # Toward zero\n        (1, 2, 0, -1): 3,  # Toward +infinity\n        (0, 1, -1, -2): 4,  # Toward -infinity\n        (1, 1, -1, -1): 5,  # Ties to odd\n    }\n\n    results = []\n    # Iterate through each black-box function in the test suite.\n    for black_box_func in test_cases:\n        # Generate the signature vector by applying the black-box to the probes.\n        signature_vector = tuple(black_box_func(p) for p in probes)\n        \n        # Look up the corresponding code in the decision map.\n        # A KeyError would indicate an unknown or inconsistent rounding mode,\n        # but the problem guarantees the modes are from the specified set.\n        identified_code = decision_map[signature_vector]\n        results.append(identified_code)\n\n    # Format the final output as a comma-separated list in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3269799"}]}