{"hands_on_practices": [{"introduction": "The best way to begin understanding floating-point numbers is to learn how to read them. This exercise challenges you to take a raw binary string from a hypothetical computer system and decode it back into a familiar decimal value. By manually parsing the sign, biased exponent, and fraction, you will see exactly how these components work together to represent a number [@problem_id:1937520].", "problem": "An engineer is designing a low-power microcontroller for an environmental sensor. To conserve memory, the microcontroller uses a custom 10-bit floating-point number format to represent sensor readings. This format is defined as follows:\n\n- **Sign (S)**: 1 bit (0 for positive, 1 for negative)\n- **Exponent (E)**: 5 bits, using an exponent bias of 15.\n- **Fraction (F)**: 4 bits\n\nThe bits are arranged in the order S, E, F, from most significant to least significant. The value of a normalized number is given by the formula $V = (-1)^{S} \\times (1.F)_{2} \\times 2^{(E-15)}$, where $(1.F)_{2}$ is the mantissa with an implicit leading 1. The special cases for an exponent of all zeros (denormalized numbers/zero) or all ones (infinity/NaN) do not apply to this problem.\n\nSuppose the microcontroller's memory contains the 10-bit binary value `1100101100`. Determine the decimal value represented by this floating-point number. Express your answer as a decimal number, rounded to four significant figures if necessary.", "solution": "The 10-bit word is 1100101100, arranged as $S|E|F$ with $S$ the first bit, $E$ the next five bits, and $F$ the last four bits. Thus $S=1$, $E=10010_{2}$, and $F=1100_{2}$. Since $E$ is neither all zeros nor all ones, the number is normalized and we use\n$$\nV = (-1)^{S}\\,(1.F)_{2}\\,2^{(E-15)}.\n$$\n\nConvert the exponent: \n$$\nE = 1\\cdot 2^{4} + 0\\cdot 2^{3} + 0\\cdot 2^{2} + 1\\cdot 2^{1} + 0\\cdot 2^{0} = 16 + 2 = 18,\n$$\nso the unbiased exponent is\n$$\nE - 15 = 18 - 15 = 3.\n$$\n\nCompute the mantissa:\n$$\n(1.F)_{2} = 1 + 1\\cdot 2^{-1} + 1\\cdot 2^{-2} + 0\\cdot 2^{-3} + 0\\cdot 2^{-4} = 1 + \\frac{1}{2} + \\frac{1}{4} = \\frac{7}{4}.\n$$\n\nWith $S=1$, the sign factor is $(-1)^{1}=-1$. Therefore,\n$$\nV = -\\frac{7}{4}\\,2^{3} = -\\frac{7}{4}\\cdot 8 = -14.\n$$\n\nThis is an exact decimal value; rounding is not needed.", "answer": "$$\\boxed{-14}$$", "id": "1937520"}, {"introduction": "After learning to decode a floating-point number, the next logical step is to encode one. This practice involves taking a decimal number and converting it into a custom floating-point format, a process that requires normalization, calculating a biased exponent, and constructing the final bit pattern [@problem_id:1937489]. This skill is essential for understanding how real-world data is translated into a machine-readable form.", "problem": "A team of engineers is developing a specialized processor for an embedded Internet of Things (IoT) device. To minimize power consumption and circuit complexity, they have designed a custom 10-bit floating-point number format to represent sensor readings. This format adheres to the following structure:\n- 1 bit for the sign (S), where S=0 for positive and S=1 for negative.\n- 4 bits for the biased exponent (E). The exponent bias is 7.\n- 5 bits for the fraction (F).\n\nThe value of a normalized number is interpreted using the formula $V = (-1)^{S} \\times (1.F)_2 \\times 2^{(E-7)}$, where $(1.F)_2$ represents the significand with a hidden leading '1'. The full 10-bit word is structured with the sign bit first, followed by the exponent bits, and then the fraction bits, in the order `S EEEE FFFFF`.\n\nA temperature sensor on the device returns a reading equivalent to the decimal value -13.5. What is the correct 10-bit binary representation of this value in the custom format described?\n\nA. 1101010110\n\nB. 0101010110\n\nC. 1101111011\n\nD. 1101001011\n\nE. 1100110110", "solution": "We are given a custom 10-bit floating-point format with fields: sign $S$ (1 bit), exponent $E$ (4 bits) with bias $7$, and fraction $F$ (5 bits). For normalized numbers, the value is\n$$\nV = (-1)^{S} (1.F)_{2} 2^{(E-7)}.\n$$\nWe need to encode $V=-13.5$.\n\nStep 1: Determine the sign bit.\nSince the value is negative, the sign bit is\n$$\nS=1.\n$$\n\nStep 2: Convert the absolute value to binary and normalize.\nThe absolute value is $13.5$. In binary,\n$$\n13.5 = 1101.1_{2}.\n$$\nNormalize to the form $(1.F)_{2} 2^{e}$:\n$$\n1101.1_{2} = 1.1011_{2} \\times 2^{3}.\n$$\nThus the unbiased exponent is\n$$\ne = 3.\n$$\n\nStep 3: Compute the biased exponent and encode it in 4 bits.\nThe bias is $7$, so the stored exponent is\n$$\nE = e + 7 = 3 + 7 = 10.\n$$\nIn 4-bit binary, $10$ is\n$$\nE = 1010.\n$$\n\nStep 4: Determine the 5-bit fraction field.\nFrom the normalized significand $1.1011_{2}$, the fraction (bits after the binary point) is $1011$. We need 5 fraction bits; since $13.5$ is exactly representable, we append a trailing zero:\n$$\nF = 10110.\n$$\n\nStep 5: Concatenate fields in order $S\\,EEEE\\,FFFFF$.\nWith $S=1$, $E=1010$, $F=10110$, the 10-bit word is\n$$\n1\\,1010\\,10110 \\;\\Rightarrow\\; 1101010110.\n$$\n\nThis matches option A.", "answer": "$$\\boxed{A}$$", "id": "1937489"}, {"introduction": "While floating-point systems can represent a vast range of values, their precision is finite, which leads to some surprising limitations. This exercise explores one of the most important consequences: the existence of \"gaps\" between representable numbers, which grow larger as the magnitude of the number increases [@problem_id:1937511]. By finding the smallest positive integer that cannot be perfectly stored, you will gain a deeper appreciation for the trade-offs inherent in floating-point arithmetic.", "problem": "A computer science student is designing a custom processor with a specialized 10-bit floating-point number format for a high-performance computing application. This format adheres to the principles of the IEEE 754 standard for normalized numbers but with different bit allocations.\n\nThe 10-bit word is partitioned as follows:\n- 1 bit for the sign (S).\n- 4 bits for the exponent (E).\n- 5 bits for the fraction (F).\n\nThe value of a number is interpreted as $V = (-1)^S \\times (1.F)_2 \\times 2^{E - \\text{bias}}$, where $(1.F)_2$ is the mantissa with an implicit leading 1, and the exponent bias is 7. For this format, the exponent field values E=0 (all zeros) and E=15 (all ones) are reserved for special cases like zero, denormalized numbers, infinity, and Not-a-Number (NaN), and are therefore not used for representing normalized numbers.\n\nDetermine the smallest positive integer that cannot be represented exactly in this 10-bit floating-point format.", "solution": "The format has 1 sign bit, 4 exponent bits with bias $7$, and 5 fraction bits. For normalized numbers $E \\in \\{1,\\dots,14\\}$, and the value is\n$$\nV = (-1)^{S} (1.F)_{2} 2^{E-7}.\n$$\nWith 5 fraction bits, the normalized significand has $p=6$ bits of precision. Writing the significand as an integer over a power of two, set\n$$\n1.F = \\frac{m}{2^{5}}, \\quad m \\in \\{32,33,\\dots,63\\}.\n$$\nThus any normalized value can be written as\n$$\nV = \\frac{m}{2^{5}} 2^{e} = m \\, 2^{e-5}, \\quad e = E-7.\n$$\nConsider a positive integer $N$. Let $e = \\lfloor \\log_{2} N \\rfloor$, so $2^{e} \\leq N < 2^{e+1}$. For exact representation, we require an integer $m$ such that\n$$\nN = m \\, 2^{e-5} \\quad \\Longleftrightarrow \\quad m = N \\, 2^{5-e}.\n$$\nBecause $N \\in [2^{e}, 2^{e+1})$, it follows that\n$$\nm \\in \\left[2^{e} \\cdot 2^{5-e}, \\; 2^{e+1} \\cdot 2^{5-e}\\right) = [2^{5}, 2^{6}) = [32,64),\n$$\nso if $m$ is an integer, it automatically lies in $\\{32,\\dots,63\\}$ and yields a valid normalized encoding.\n\nIf $e \\leq 5$ (equivalently $N < 2^{6} = 64$), then $2^{5-e}$ is an integer, so $m = N \\, 2^{5-e}$ is an integer; hence every integer $N$ with $1 \\leq N \\leq 63$ is exactly representable. For $N = 64 = 2^{6}$, we have $e=6$ and\n$$\nm = 64 \\cdot 2^{-1} = 32,\n$$\nwhich is an integer in $[32,63]$, so $64$ is also exactly representable.\n\nFor $N = 65$, we have $e=6$ and\n$$\nm = 65 \\cdot 2^{-1} = 32.5,\n$$\nwhich is not an integer, so $65$ is not exactly representable. Since all smaller positive integers are representable, the smallest positive integer not exactly representable is $65$.", "answer": "$$\\boxed{65}$$", "id": "1937511"}]}