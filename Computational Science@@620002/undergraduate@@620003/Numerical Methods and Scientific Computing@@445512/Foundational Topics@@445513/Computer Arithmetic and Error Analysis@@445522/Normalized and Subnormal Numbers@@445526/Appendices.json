{"hands_on_practices": [{"introduction": "A deep understanding of floating-point representation is best achieved by building a system from first principles. This exercise challenges you to apply the foundational definitions of exponent bias, implicit bits, and special encodings to a custom \"toy\" system. By calculating its key limits, you will gain a concrete grasp of how the normalized and subnormal ranges are structured and interconnected [@problem_id:3257655].", "problem": "You are tasked with specifying a self-consistent toy binary floating-point format and using foundational definitions to deduce key quantities about its normalized and subnormal numbers.\n\nConsider a toy $8$-bit binary floating-point system with the following design:\n- The representation has $1$ sign bit, $4$ exponent bits, and $3$ fraction (mantissa) bits.\n- The exponent uses a bias of $7$.\n- For exponent field equal to all zeros and nonzero fraction, the number is a subnormal (also called denormal), and for exponent field equal to all zeros and zero fraction, the number is a signed zero.\n- For exponent field equal to all ones, the encodings represent infinities and not-a-number values and are excluded from this problemâ€™s consideration.\n- For normalized numbers (exponent field neither all zeros nor all ones), the significand is interpreted with an implicit leading one, that is, of the form $1.f_1 f_2 f_3$ in base $2$. For subnormal numbers (exponent field all zeros and nonzero fraction), the significand has no implicit leading one and is of the form $0.f_1 f_2 f_3$ in base $2$.\n- The real value represented is $(-1)^{s} \\times m \\times 2^{e}$, where $s$ is the sign bit, $m$ is the significand as above, and $e$ is the unbiased exponent. For normalized numbers, the unbiased exponent is the stored exponent field value minus the bias. For subnormal numbers, the unbiased exponent is fixed to the minimum exponent that maintains continuity at the boundary between subnormal and normalized ranges.\n\nUsing only these definitions and first principles of binary floating-point representation (as standardized in practice by the Institute of Electrical and Electronics Engineers (IEEE) 754, but adapted here to the above toy format), determine:\n- The smallest positive normalized number, denoted $N_{\\min}$.\n- The smallest positive subnormal number, denoted $S_{\\min}$.\n- The total count of representable subnormal numbers across both signs, excluding the two signed zeros.\n\nExpress $N_{\\min}$ and $S_{\\min}$ exactly as powers of $2$, and give the subnormal count as an integer. Provide your final answer as a row matrix $\\big(N_{\\min},\\,S_{\\min},\\,C\\big)$. Do not round. No units are required.", "solution": "The user has provided a specification for a toy $8$-bit binary floating-point system and requested the determination of three quantities: the smallest positive normalized number ($N_{\\min}$), the smallest positive subnormal number ($S_{\\min}$), and the total count of subnormal numbers ($C$).\n\nThe problem is self-contained and consistent with the principles of floating-point arithmetic as defined by standards like IEEE 754. All necessary parameters are provided, and the questions are well-posed. Therefore, the problem is valid and a solution can be derived.\n\nThe system is defined by the following parameters:\n- Total bits: $8$.\n- Sign bits ($s$): $1$.\n- Exponent bits ($k$): $4$.\n- Fraction bits ($p$): $3$.\n- Exponent bias ($B$): $7$.\n\nA floating-point number's value $v$ is given by the formula $v = (-1)^{s} \\times m \\times 2^{e}$, where $s$ is the sign bit, $m$ is the significand, and $e$ is the unbiased exponent.\n\nFirst, we determine the range of stored exponent values ($E$) for normalized numbers. The exponent field has $k=4$ bits, so its value can range from $0$ to $2^4-1 = 15$. The problem states that $E=0$ (all zeros) is reserved for zeros and subnormal numbers, and $E=15$ (all ones) is reserved for special values (infinities/NaNs). Therefore, the range of stored exponents for normalized numbers is $E \\in [1, 14]$. The unbiased exponent $e$ for a normalized number is calculated as $e = E - B$. With a bias $B=7$, the range of unbiased exponents for normalized numbers is:\n- $e_{\\min\\_norm} = 1 - 7 = -6$.\n- $e_{\\max\\_norm} = 14 - 7 = 7$.\n\n**1. Smallest Positive Normalized Number ($N_{\\min}$)**\n\nTo find the smallest positive normalized number, we must satisfy three conditions:\n- The sign must be positive, so the sign bit $s=0$.\n- The significand $m$ must be as small as possible. For normalized numbers, the significand is of the form $m = 1.f_1 f_2 f_3$ (base $2$) with an implicit leading $1$. The smallest value occurs when all fraction bits are zero: $f_1=0, f_2=0, f_3=0$. This gives a significand of $m_{\\min\\_norm} = 1.000_2 = 1$.\n- The exponent $e$ must be as small as possible. As determined above, the minimum unbiased exponent for a normalized number is $e_{\\min\\_norm} = -6$.\n\nCombining these, we calculate $N_{\\min}$:\n$$N_{\\min} = (-1)^0 \\times 1 \\times 2^{-6} = 2^{-6}$$\n\n**2. Smallest Positive Subnormal Number ($S_{\\min}$)**\n\nFirst, we must determine the fixed unbiased exponent for subnormal numbers, $e_{sub}$. The problem specifies that this exponent is chosen to maintain continuity at the boundary between the subnormal and normalized ranges. The boundary is between the largest subnormal number, $S_{\\max}$, and the smallest normalized number, $N_{\\min}$.\n\nThe value of $N_{\\min}$ is $1.000_2 \\times 2^{-6}$. The spacing (or ulp, unit in the last place) between representable numbers with this exponent is determined by the value of the least significant bit of the fraction, which is $2^{-p} = 2^{-3}$. The total step size at this exponent is $2^{-3} \\times 2^{e_{\\min\\_norm}} = 2^{-3} \\times 2^{-6} = 2^{-9}$.\n\nFor a continuous transition, the largest subnormal number must be one step size smaller than the smallest normalized number:\n$$S_{\\max} = N_{\\min} - (\\text{step size}) = 2^{-6} - 2^{-9} = 2^{-6}(1 - 2^{-3}) = 2^{-6}(1 - \\frac{1}{8}) = \\frac{7}{8} \\times 2^{-6}$$\n\nNow, we express $S_{\\max}$ using the definition of a subnormal number. For a subnormal number, the significand is $m = 0.f_1 f_2 f_3$ (base $2$). The largest subnormal significand occurs when all fraction bits are one: $f_1=1, f_2=1, f_3=1$.\n$$m_{\\max\\_sub} = 0.111_2 = \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8} = \\frac{7}{8}$$\nThe value of the largest subnormal is $S_{\\max} = m_{\\max\\_sub} \\times 2^{e_{sub}} = \\frac{7}{8} \\times 2^{e_{sub}}$.\n\nEquating the two expressions for $S_{\\max}$ allows us to solve for $e_{sub}$:\n$$\\frac{7}{8} \\times 2^{e_{sub}} = \\frac{7}{8} \\times 2^{-6}$$\n$$\\implies e_{sub} = -6$$\nThis confirms the standard convention that the subnormal exponent is $e_{sub} = 1 - B = 1 - 7 = -6$.\n\nNow we can find the smallest positive subnormal number, $S_{\\min}$.\n- The sign must be positive, so $s=0$.\n- The exponent is the fixed subnormal exponent, $e_{sub} = -6$.\n- The significand $m = 0.f_1 f_2 f_3$ must be the smallest possible *nonzero* value. This occurs when only the least significant bit is one: $f_1=0, f_2=0, f_3=1$.\n$$m_{\\min\\_sub} = 0.001_2 = 0 \\times 2^{-1} + 0 \\times 2^{-2} + 1 \\times 2^{-3} = 2^{-3}$$\n\nCombining these, we calculate $S_{\\min}$:\n$$S_{\\min} = (-1)^0 \\times (2^{-3}) \\times 2^{-6} = 2^{-9}$$\n\n**3. Total Count of Representable Subnormal Numbers ($C$)**\n\nA number is subnormal if its exponent field is all zeros and its fraction field is nonzero. We need to count all such possible bit patterns.\n- Sign bit ($s$): $1$ bit, can be $0$ or $1$. This gives $2$ choices.\n- Exponent field ($E$): $4$ bits, must be $0000_2$. This gives $1$ choice.\n- Fraction field ($f$): $3$ bits, can be any pattern *except* all zeros ($000_2$). The total number of patterns for $3$ bits is $2^3 = 8$. The number of nonzero patterns is $2^3 - 1 = 7$.\n\nThe total count $C$ is the product of the number of choices for each field:\n$$C = (\\text{choices for sign}) \\times (\\text{choices for fraction}) = 2 \\times (2^3 - 1) = 2 \\times 7 = 14$$\n\nThe three quantities are $N_{\\min} = 2^{-6}$, $S_{\\min} = 2^{-9}$, and $C = 14$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2^{-6} & 2^{-9} & 14\n\\end{pmatrix}\n}\n$$", "id": "3257655"}, {"introduction": "Subnormal numbers are not just a theoretical curiosity; they serve the critical purpose of enabling \"gradual underflow,\" preventing an abrupt drop to zero for very small results. This practice explores the dynamic behavior of subnormals by examining what happens when they are added together [@problem_id:3257753]. You will construct an example to demonstrate that the sum of two subnormal numbers can cross the boundary into the normalized range, illustrating the seamless transition that these numbers provide.", "problem": "Consider the Institute of Electrical and Electronics Engineers (IEEE) 754 standard half-precision binary floating-point system (binary16), which uses base $2$, $1$ sign bit, $5$ exponent bits, and $10$ fraction (significand) bits. The exponent bias is $15$. In this system, numbers with a nonzero exponent field are normalized, while those with an exponent field of $0$ and a nonzero fraction are subnormal.\n\nAnswer the following: Is it possible for the sum of two subnormal positive numbers $x$ and $y$ to exceed the subnormal range and be representable as a normalized number in this system? Construct an explicit example by taking $x$ to be the largest positive subnormal number and $y$ to be the smallest positive subnormal number in binary16, and compute the exact real value of $x + y$. Express your final answer as a single power of $2$ with an integer exponent. No rounding is required.", "solution": "The problem is valid as it is scientifically grounded in the IEEE 754 standard for floating-point arithmetic, is well-posed, objective, and contains all necessary information for a unique solution.\n\nFirst, we analyze the structure of numbers in the specified IEEE 754 half-precision binary floating-point system (binary16). The system uses a base $B=2$, $1$ sign bit ($s$), $5$ exponent bits (forming an exponent field $e$), and $10$ fraction bits (forming a fraction field $f$). The exponent bias is given as $15$.\n\nA number $v$ in this system is represented by the formula $v = (-1)^s \\times m \\times 2^E$, where $m$ is the significand and $E$ is the true exponent. The values of $m$ and $E$ depend on the exponent field $e$.\n\nFor subnormal (or denormalized) numbers, the exponent field is $e = 0$. The true exponent is fixed at its minimum value, $E = 1 - \\text{bias} = 1 - 15 = -14$. The significand has an implicit leading bit of $0$ and is given by $m = (0.f)_2 = \\sum_{i=1}^{10} f_i 2^{-i}$, where $f_i$ is the $i$-th bit of the fraction field $f$. For a number to be subnormal, the fraction field $f$ must be non-zero.\nThus, a positive subnormal number has the form $v_{sub} = (\\sum_{i=1}^{10} f_i 2^{-i}) \\times 2^{-14}$.\n\nFor normalized numbers, the exponent field $e$ is in the range $1 \\le e \\le 30$. The true exponent is $E = e - \\text{bias} = e - 15$. The significand has an implicit leading bit of $1$ and is given by $m = (1.f)_2 = 1 + \\sum_{i=1}^{10} f_i 2^{-i}$.\nThus, a positive normalized number has the form $v_{norm} = (1 + \\sum_{i=1}^{10} f_i 2^{-i}) \\times 2^{e-15}$.\n\nThe problem asks if the sum of two positive subnormal numbers can result in a normalized number. We investigate this by constructing an explicit example as requested.\n\nLet $x$ be the largest positive subnormal number. This occurs when all bits of the fraction field $f$ are $1$.\nThe fraction field is $f = 1111111111_2$.\nThe significand is $m_x = (0.1111111111)_2 = \\sum_{i=1}^{10} 2^{-i}$. This is a geometric series with sum $2^{-1} \\frac{1-(2^{-1})^{10}}{1-2^{-1}} = \\frac{1}{2} \\frac{1-2^{-10}}{1/2} = 1 - 2^{-10}$.\nThe exponent is $E = -14$.\nTherefore, the value of $x$ is:\n$$x = (1 - 2^{-10}) \\times 2^{-14}$$\n\nLet $y$ be the smallest positive subnormal number. This occurs when the fraction field $f$ is the smallest non-zero value, which is $f = 0000000001_2$.\nThe significand is $m_y = (0.0000000001)_2 = 2^{-10}$.\nThe exponent is $E = -14$.\nTherefore, the value of $y$ is:\n$$y = 2^{-10} \\times 2^{-14} = 2^{-24}$$\n\nNow, we compute the sum $x+y$:\n$$x + y = \\left( (1 - 2^{-10}) \\times 2^{-14} \\right) + \\left( 2^{-10} \\times 2^{-14} \\right)$$\nFactoring out the common term $2^{-14}$:\n$$x + y = (1 - 2^{-10} + 2^{-10}) \\times 2^{-14}$$\n$$x + y = 1 \\times 2^{-14} = 2^{-14}$$\n\nThe sum is $2^{-14}$. We must now determine if this number is in the subnormal range or the normalized range.\nThe maximum value for a subnormal number is $x = (1 - 2^{-10}) \\times 2^{-14}$, which is strictly less than $2^{-14}$.\nSince $x+y = 2^{-14}$, the sum is greater than the largest subnormal number, so it must lie outside the subnormal range.\n\nLet's check if $2^{-14}$ is representable as a normalized number in the binary16 system.\nA normalized number has the form $(1.f)_2 \\times 2^{e-15}$. We want to find $f$ and $e$ such that this expression equals $2^{-14}$.\n$$(1.f)_2 \\times 2^{e-15} = 2^{-14}$$\nWe can achieve this by setting the significand to $(1.0)_2 = 1$ and the exponent to $-14$.\nFor a significand of $1$, the fraction field $f$ must be all zeros: $f = 0000000000_2$.\nFor a true exponent of $E = -14$, we need $e-15 = -14$, which implies $e=1$.\nThe exponent field $e=1$ is a valid value for a normalized number (the range being $1 \\le e \\le 30$).\nThus, $2^{-14}$ is the smallest positive normalized number in the binary16 system. Its representation is $s=0$, $e=00001_2$, and $f=0000000000_2$.\n\nThis explicitly demonstrates that the sum of two positive subnormal numbers, $x$ and $y$, can exceed the subnormal range and be representable as a normalized number. The exact real value of the sum for the chosen $x$ and $y$ is $2^{-14}$.\nThe problem requires the answer expressed as a single power of $2$ with an integer exponent, which is $2^{-14}$.", "answer": "$$\\boxed{2^{-14}}$$", "id": "3257753"}, {"introduction": "The theoretical rules governing floating-point numbers have a direct and efficient implementation in computer hardware and software. This final hands-on practice bridges the gap between theory and application by asking you to classify raw bit patterns using only integer and bitwise logic [@problem_id:3257791]. This task mimics how a processor interprets a floating-point number without using floating-point hardware, solidifying your understanding of the IEEE 754 standard at the most fundamental level.", "problem": "You are given the unsigned $32$-bit integer representation of a binary floating-point number in the Institute of Electrical and Electronics Engineers (IEEE) Standard for Floating-Point Arithmetic (IEEE $754$) binary$32$ format. Your task is to write a program that, without using any floating-point operations, determines whether each given $32$-bit pattern represents a normalized finite number, a subnormal (denormalized) finite number, a zero, an infinity, or a not-a-number (NaN), and outputs an integer code for each classification.\n\nFundamental base to use:\n- IEEE $754$ binary$32$ encodes a real value using $32$ bits partitioned as follows: one sign bit $s$ (the most significant bit), an $8$-bit exponent field $e$, and a $23$-bit fraction (also called significand field) $f$. The stored exponent $e$ is an unsigned integer in $\\{0,1,\\dots,255\\}$, and the fraction $f$ is an unsigned integer in $\\{0,1,\\dots,2^{23}-1\\}$. The exponent bias is $127$.\n- For normalized finite numbers, the encoded value (if interpreted as a real number) would be of the form $(-1)^s \\cdot (1.f)_2 \\cdot 2^{E}$ with unbiased exponent $E = e - 127$, where $1 \\le e \\le 254$.\n- For subnormal finite numbers, the encoded value would be of the form $(-1)^s \\cdot (0.f)_2 \\cdot 2^{1-127}$ with $e = 0$ and $f \\ne 0$.\n- For zeros, $e = 0$ and $f = 0$ (both $+0$ and $-0$ are considered zero).\n- For infinities, $e = 255$ and $f = 0$ (both $+\\infty$ and $-\\infty$ are considered infinity).\n- For not-a-number (NaN), $e = 255$ and $f \\ne 0$.\n\nYour program must:\n- Treat each input as an unsigned $32$-bit integer $x \\in \\{0,1,\\dots,2^{32}-1\\}$ and classify it solely by integer and bitwise operations.\n- Extract the fields $s$, $e$, and $f$ using bit operations on $x$.\n- Output for each input a classification code $c \\in \\{0,1,2,3,4\\}$ defined as follows:\n  - $0$: zero,\n  - $1$: subnormal finite,\n  - $2$: normalized finite,\n  - $3$: infinity,\n  - $4$: not-a-number (NaN).\n\nTest suite:\nUse exactly the following test cases (each is a single unsigned $32$-bit integer written in hexadecimal for readability):\n- $x_1 = \\texttt{0x00000000}$,\n- $x_2 = \\texttt{0x80000000}$,\n- $x_3 = \\texttt{0x00000001}$,\n- $x_4 = \\texttt{0x00012345}$,\n- $x_5 = \\texttt{0x00800000}$,\n- $x_6 = \\texttt{0x3F800000}$,\n- $x_7 = \\texttt{0x7F7FFFFF}$,\n- $x_8 = \\texttt{0x7F800000}$,\n- $x_9 = \\texttt{0xFF800000}$,\n- $x_{10} = \\texttt{0x7FC00000}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the classification codes for the $10$ test cases in order, as a comma-separated list enclosed in square brackets, for example: $[c_1,c_2,\\dots,c_{10}]$.\n- Each $c_i$ must be an integer as defined above.", "solution": "The problem is valid as it is well-defined, scientifically grounded in the IEEE $754$ standard, and self-contained. The task is to classify a given $32$-bit unsigned integer, representing a single-precision floating-point number, into one of five categories: zero, subnormal, normalized, infinity, or Not-a-Number (NaN), using only integer and bitwise operations.\n\nThe core principle is to deconstruct the $32$-bit integer $x$ into its three constituent fields as defined by the IEEE $754$ binary$32$ standard: the sign bit $s$, the $8$-bit exponent field $e$, and the $23$-bit fraction field $f$. The classification of the number is uniquely determined by the values of the fields $e$ and $f$.\n\nA $32$-bit integer $x$ is structured as follows, from the most significant bit (MSB) to the least significant bit (LSB):\n- Bit $31$: Sign bit $s$ ($1$ bit)\n- Bits $30-23$: Exponent field $e$ ($8$ bits)\n- Bits $22-0$: Fraction field $f$ ($23$ bits)\n\nThe classification algorithm proceeds in two main steps: field extraction and logical rule application.\n\n**Step 1: Field Extraction using Bitwise Operations**\n\nWe can isolate the exponent and fraction fields from the integer $x$ using bitwise AND operations with specific masks, followed by bitwise right shifts.\n\n1.  **Exponent Field ($e$) Extraction:**\n    The exponent field occupies bits $23$ through $30$. To isolate these $8$ bits, we use a bitmask that has $1$s in these positions and $0$s elsewhere. This mask is $\\texttt{0x7F800000}$ in hexadecimal, which is equivalent to the binary pattern `01111111100000000000000000000000`.\n    First, we perform a bitwise AND between the input integer $x$ and the exponent mask:\n    $$x_{exp} = x \\ \\& \\ \\texttt{0x7F800000}$$\n    This operation zeroes out all bits except for the exponent bits. The result $x_{exp}$ has the exponent value shifted to the left by $23$ positions. To obtain the actual $8$-bit value of $e$, we must perform a logical right shift by $23$ bits:\n    $$e = (x \\ \\& \\ \\texttt{0x7F800000}) \\gg 23$$\n    The resulting value of $e$ will be an integer in the range $\\{0, 1, \\dots, 255\\}$.\n\n2.  **Fraction Field ($f$) Extraction:**\n    The fraction field occupies the lower $23$ bits (bits $0$ through $22$). The mask to isolate this field has $1$s in these positions and $0$s elsewhere. This mask is $\\texttt{0x007FFFFF}$ in hexadecimal, which corresponds to the binary pattern `00000000011111111111111111111111`.\n    We perform a bitwise AND between the input integer $x$ and the fraction mask. No shift is necessary as the field is already aligned to the LSB.\n    $$f = x \\ \\& \\ \\texttt{0x007FFFFF}$$\n    The resulting value of $f$ will be an integer in the range $\\{0, 1, \\dots, 2^{23}-1\\}$.\n\nThe sign bit $s$ is not required for this classification problem, as the rules only depend on $e$ and $f$. For instance, $+0$ and $-0$ are both classified as zero.\n\n**Step 2: Classification based on Extracted Fields**\n\nOnce the values of $e$ and $f$ are obtained, we can apply the classification rules provided in the problem statement. The rules form a set of mutually exclusive conditions that cover all possible combinations of $e$ and $f$. The logic is implemented as a sequence of conditional checks. A robust approach is to first test for the special exponent values ($e=0$ and $e=255$).\n\nLet $E_{max} = 2^8 - 1 = 255$.\n\n- **Case 1: $e = E_{max} = 255_d = \\texttt{0xFF}_{h}$**\n  This case corresponds to infinities and NaNs.\n  - If $f = 0$, the number is an **infinity**. The classification code is $3$. This holds for both positive infinity ($\\texttt{0x7F800000}$) and negative infinity ($\\texttt{0xFF800000}$).\n  - If $f \\ne 0$, the number is a **Not-a-Number (NaN)**. The classification code is $4$.\n\n- **Case 2: $e = 0$**\n  This case corresponds to zeros and subnormal (denormalized) numbers.\n  - If $f = 0$, the number is a **zero**. The classification code is $0$. This holds for both positive zero ($\\texttt{0x00000000}$) and negative zero ($\\texttt{0x80000000}$).\n  - If $f \\ne 0$, the number is a **subnormal finite** number. The classification code is $1$.\n\n- **Case 3: $1 \\le e \\le 254$**\n  If the exponent $e$ is not $0$ and not $255$, the number is by definition a **normalized finite** number. The classification code is $2$.\n\nThis set of rules provides a complete decision procedure for classifying any $32$-bit pattern according to the IEEE $754$ standard. Applying this logic to the provided test cases yields the final sequence of classification codes.\n\nFor example, let's analyze $x_4 = \\texttt{0x00012345}$:\n- $x = \\texttt{0x00012345}$\n- $e = (\\texttt{0x00012345} \\ \\& \\ \\texttt{0x7F800000}) \\gg 23 = 0 \\gg 23 = 0$.\n- $f = \\texttt{0x00012345} \\ \\& \\ \\texttt{0x007FFFFF} = \\texttt{0x00012345}$.\n- Since $e=0$ and $f \\ne 0$, the number is subnormal, and its code is $1$.\n\nAs another example, let's analyze $x_8 = \\texttt{0x7F800000}$:\n- $x = \\texttt{0x7F800000}$\n- $e = (\\texttt{0x7F800000} \\ \\& \\ \\texttt{0x7F800000}) \\gg 23 = \\texttt{0x7F800000} \\gg 23$. The binary pattern for the exponent bits is `11111111`, which is $255$ in decimal. So, $e=255$.\n- $f = \\texttt{0x7F800000} \\ \\& \\ \\texttt{0x007FFFFF} = 0$.\n- Since $e=255$ and $f=0$, the number is an infinity, and its code is $3$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Classifies 32-bit unsigned integers representing IEEE 754 single-precision\n    floating-point numbers using only bitwise integer operations.\n    \"\"\"\n    \n    # Define the test cases from the problem statement as unsigned 32-bit integers.\n    test_cases = [\n        0x00000000,  # x1: +0\n        0x80000000,  # x2: -0\n        0x00000001,  # x3: smallest positive subnormal\n        0x00012345,  # x4: a subnormal number\n        0x00800000,  # x5: smallest positive normalized\n        0x3F800000,  # x6: 1.0\n        0x7F7FFFFF,  # x7: largest normalized\n        0x7F800000,  # x8: +infinity\n        0xFF800000,  # x9: -infinity\n        0x7FC00000,  # x10: a quiet NaN\n    ]\n\n    results = []\n    \n    # Constants for bitwise field extraction based on the IEEE 754 binary32 format.\n    # Exponent field: bits 23-30\n    EXP_MASK = np.uint32(0x7F800000)\n    # Fraction/significand field: bits 0-22\n    FRAC_MASK = np.uint32(0x007FFFFF)\n    \n    # The maximum value for the 8-bit exponent field (all bits set to 1).\n    EXP_MAX = np.uint32(0xFF) # 255 in decimal\n\n    for x_int in test_cases:\n        # We work with numpy.uint32 to be explicit about the 32-bit nature of the data,\n        # aligning with common practices in numerical computing.\n        x = np.uint32(x_int)\n        \n        # Extract the 8-bit exponent field by masking and right-shifting.\n        exp_field = (x & EXP_MASK) >> np.uint32(23)\n        \n        # Extract the 23-bit fraction field by masking.\n        frac_field = x & FRAC_MASK\n        \n        # Apply the classification rules defined in the problem statement.\n        \n        # Case 1: Exponent bits are all 1s (e = 255)\n        # This corresponds to infinities and NaNs.\n        if exp_field == EXP_MAX:\n            if frac_field == 0:\n                # Code 3: infinity\n                results.append(3)\n            else:\n                # Code 4: not-a-number (NaN)\n                results.append(4)\n        \n        # Case 2: Exponent bits are all 0s (e = 0)\n        # This corresponds to zeros and subnormal numbers.\n        elif exp_field == 0:\n            if frac_field == 0:\n                # Code 0: zero\n                results.append(0)\n            else:\n                # Code 1: subnormal (denormalized)\n                results.append(1)\n        \n        # Case 3: Exponent is in the range [1, 254]\n        # This corresponds to normalized numbers.\n        else:\n            # Code 2: normalized\n            results.append(2)\n\n    # Format the final output as a comma-separated list in brackets.\n    # The problem asks for the output format: [c1,c2,...,c10]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3257791"}]}