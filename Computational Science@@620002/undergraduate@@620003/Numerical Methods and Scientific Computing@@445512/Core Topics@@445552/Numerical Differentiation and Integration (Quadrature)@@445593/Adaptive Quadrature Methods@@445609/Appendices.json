{"hands_on_practices": [{"introduction": "To truly grasp how an adaptive algorithm works, there is no substitute for tracing its steps by hand. This exercise demystifies the recursive process by guiding you through the core logic on a simple polynomial function. You will manually calculate coarse and fine approximations, compare them to an error tolerance, and make the crucial decision at each stage: accept the result or subdivide the interval and recurse [@problem_id:2153105].", "problem": "An adaptive quadrature algorithm refines its calculation mesh to meet a desired error tolerance. Consider the following recursive algorithm designed to approximate the definite integral $I = \\int_a^b f(x) \\,dx$.\n\n**Adaptive Integration Algorithm:**\nThe function `AdaptiveIntegrate(f, a, b, ε)` takes a function $f$, an interval $[a, b]$, and a tolerance $\\epsilon$ as input.\n\n1.  Calculate $S_1$, the approximation from the trapezoidal rule using a single interval of width $h_1 = b-a$. The formula is $S_1 = \\frac{h_1}{2}(f(a) + f(b))$.\n2.  Let $c = (a+b)/2$ be the midpoint of the interval. Calculate $S_2$, the approximation from the composite trapezoidal rule using two subintervals $[a, c]$ and $[c, b]$, each of width $h_2 = (b-a)/2$. The formula is $S_2 = \\frac{h_2}{2}(f(a) + f(c)) + \\frac{h_2}{2}(f(c) + f(b))$.\n3.  An estimate for the error in the more accurate approximation $S_2$ is based on the difference between the two approximations. The stopping criterion is $|S_2 - S_1| < 3\\epsilon$.\n4.  If the criterion is met, the procedure for this interval terminates and returns the value of $S_2$.\n5.  If the criterion is not met, the algorithm refines the interval. It recursively calls itself on the two subintervals, halving the tolerance for each. The result for the interval $[a, b]$ is the sum of the results from these two calls:\n    `AdaptiveIntegrate(f, a, c, ε/2) + AdaptiveIntegrate(f, c, b, ε/2)`\n\nYour task is to manually trace this algorithm to find the numerical approximation of the integral\n$$ I = \\int_0^4 x^2 \\,dx $$\nwith an initial tolerance of $\\epsilon = 2$.\n\nCalculate the final numerical approximation for the integral returned by the algorithm. Provide your answer as an exact integer or fraction.", "solution": "We apply the given adaptive trapezoidal algorithm to $f(x)=x^{2}$ on $[0,4]$ with initial tolerance $\\epsilon=2$. The trapezoidal approximation on $[a,b]$ with one panel is $S_{1}=\\frac{h_{1}}{2}\\left(f(a)+f(b)\\right)$ where $h_{1}=b-a$, and with two panels is\n$$\nS_{2}=\\frac{h_{2}}{2}\\left(f(a)+f(c)\\right)+\\frac{h_{2}}{2}\\left(f(c)+f(b)\\right),\n$$\nwhere $c=\\frac{a+b}{2}$ and $h_{2}=\\frac{b-a}{2}$. The stopping criterion for an interval is $\\left|S_{2}-S_{1}\\right|<3\\epsilon$. If not met, we recurse on $[a,c]$ and $[c,b]$ with tolerance $\\epsilon/2$ each and sum the returned values.\n\nTop-level interval $[0,4]$ with $\\epsilon=2$:\n- Compute $h_{1}=4$, $S_{1}=\\frac{4}{2}\\left(f(0)+f(4)\\right)=2\\left(0+16\\right)=32$.\n- Midpoint $c=2$, $h_{2}=2$, and\n$$\nS_{2}=\\frac{2}{2}\\left(f(0)+f(2)\\right)+\\frac{2}{2}\\left(f(2)+f(4)\\right)=1\\left(0+4\\right)+1\\left(4+16\\right)=4+20=24.\n$$\n- Error check: $\\left|S_{2}-S_{1}\\right|=\\left|24-32\\right|=8$, while $3\\epsilon=3\\cdot 2=6$. Since $8\\not<6$, we recurse on $[0,2]$ and $[2,4]$ with tolerance $\\epsilon/2=1$ each.\n\nSubinterval $[0,2]$ with $\\epsilon=1$:\n- Compute $h_{1}=2$, $S_{1}=\\frac{2}{2}\\left(f(0)+f(2)\\right)=1\\left(0+4\\right)=4$.\n- Midpoint $c=1$, $h_{2}=1$, and\n$$\nS_{2}=\\frac{1}{2}\\left(f(0)+f(1)\\right)+\\frac{1}{2}\\left(f(1)+f(2)\\right)=\\frac{1}{2}\\left(0+1\\right)+\\frac{1}{2}\\left(1+4\\right)=\\frac{1}{2}+\\frac{5}{2}=3.\n$$\n- Error check: $\\left|S_{2}-S_{1}\\right|=\\left|3-4\\right|=1$, while $3\\epsilon=3\\cdot 1=3$. Since $1<3$, accept $S_{2}=3$ for $[0,2]$.\n\nSubinterval $[2,4]$ with $\\epsilon=1$:\n- Compute $h_{1}=2$, $S_{1}=\\frac{2}{2}\\left(f(2)+f(4)\\right)=1\\left(4+16\\right)=20$.\n- Midpoint $c=3$, $h_{2}=1$, and\n$$\nS_{2}=\\frac{1}{2}\\left(f(2)+f(3)\\right)+\\frac{1}{2}\\left(f(3)+f(4)\\right)=\\frac{1}{2}\\left(4+9\\right)+\\frac{1}{2}\\left(9+16\\right)=\\frac{13}{2}+\\frac{25}{2}=19.\n$$\n- Error check: $\\left|S_{2}-S_{1}\\right|=\\left|19-20\\right|=1$, while $3\\epsilon=3$. Since $1<3$, accept $S_{2}=19$ for $[2,4]$.\n\nFinally, the top-level call returns the sum of the accepted subinterval results:\n$$\n\\text{Result} = 3+19=22.\n$$\nThis is the final numerical approximation returned by the algorithm.", "answer": "$$\\boxed{22}$$", "id": "2153105"}, {"introduction": "While adaptive quadrature is powerful, it is not infallible, and a good scientist always probes for an algorithm's limitations. This problem challenges you to find a function that \"tricks\" the error-checking mechanism, causing the algorithm to terminate with an incorrect answer [@problem_id:2153040]. By understanding how the error estimate can be misleadingly small, you will gain a deeper appreciation for the assumptions underlying these numerical methods and the importance of critically evaluating their output.", "problem": "An adaptive quadrature algorithm is designed to numerically approximate the definite integral $I = \\int_a^b f(x)\\,dx$ for a continuous function $f(x)$ up to a desired tolerance $\\epsilon > 0$. The algorithm, based on Simpson's rule, operates as follows on any given interval $[u, v]$:\n\n1.  Calculate a coarse approximation using Simpson's rule over the entire interval:\n    $$S_1 = \\frac{v-u}{6}\\left(f(u) + 4f\\left(\\frac{u+v}{2}\\right) + f(v)\\right)$$\n2.  Calculate a more refined approximation by summing the Simpson's rule results from the two half-intervals, $[u, w]$ and $[w, v]$, where $w = (u+v)/2$:\n    $$S_2 = \\frac{w-u}{6}\\left(f(u) + 4f\\left(\\frac{u+w}{2}\\right) + f(w)\\right) + \\frac{v-w}{6}\\left(f(w) + 4f\\left(\\frac{w+v}{2}\\right) + f(v)\\right)$$\n3.  Estimate the error of the refined approximation $S_2$ using the formula:\n    $$E = \\frac{1}{15}|S_2 - S_1|$$\n4.  If the estimated error $E$ is less than the tolerance allocated for the interval $[u,v]$, the algorithm terminates for this interval and returns $S_2$ as its value. Otherwise, the algorithm is applied recursively to the sub-intervals $[u, w]$ and $[w, v]$, each with half of the previous tolerance.\n\nConsider the task of evaluating the integral of a function over the interval $[-1, 1]$. Which of the following continuous functions would cause this algorithm to terminate on its very first check (i.e., without any recursion) and return an incorrect value of 0? Assume the initial tolerance $\\epsilon$ is any small positive number.\n\nA. $f(x) = 3x^2 - 1$\n\nB. $f(x) = \\sin(\\pi x)$\n\nC. $f(x) = \\cos\\left(\\frac{\\pi}{2} x\\right)$\n\nD. $f(x) = 16x^6 - 20x^4 + x^2 + 1$\n\nE. $f(x) = x^5 - x^3 + x$", "solution": "For the algorithm to terminate on its very first check for any small positive tolerance $\\epsilon$, the estimated error must be exactly zero on the initial interval. With $[u,v]=[-1,1]$ and $w=0$, the two Simpson approximations are\n$$\nS_{1}=\\frac{1}{3}\\left(f(-1)+4f(0)+f(1)\\right),\n$$\n$$\nS_{2}=\\frac{1}{6}\\left(f(-1)+4f\\left(-\\frac{1}{2}\\right)+f(0)\\right)+\\frac{1}{6}\\left(f(0)+4f\\left(\\frac{1}{2}\\right)+f(1)\\right)\n=\\frac{1}{6}\\left(f(-1)+f(1)+2f(0)+4f\\left(-\\frac{1}{2}\\right)+4f\\left(\\frac{1}{2}\\right)\\right).\n$$\nThe error estimate is\n$$\nE=\\frac{1}{15}|S_{2}-S_{1}|.\n$$\nTo terminate for any $\\epsilon>0$, we need $E=0$, i.e., $S_{2}=S_{1}$. For the algorithm to return the incorrect value $0$, we must also have $S_{2}=0$ while the true integral $\\int_{-1}^{1}f(x)\\,dx\\neq 0$.\n\nEvaluate $S_{1}$ and $S_{2}$ for each option:\n\nA. $f(x)=3x^{2}-1$. Compute $f(-1)=2$, $f(0)=-1$, $f(1)=2$, and $f\\left(\\pm\\frac{1}{2}\\right)=3\\cdot\\frac{1}{4}-1=-\\frac{1}{4}$. Then\n$$\nS_{1}=\\frac{1}{3}(2+4(-1)+2)=0,\\quad\nS_{2}=\\frac{1}{6}\\left(2+2+2(-1)+4\\left(-\\frac{1}{4}\\right)+4\\left(-\\frac{1}{4}\\right)\\right)=0.\n$$\nMoreover, $\\int_{-1}^{1}(3x^{2}-1)\\,dx=\\left[x^{3}-x\\right]_{-1}^{1}=0$, so returning $0$ would be correct, not incorrect.\n\nB. $f(x)=\\sin(\\pi x)$. Compute $f(-1)=0$, $f(0)=0$, $f(1)=0$, $f\\left(-\\frac{1}{2}\\right)=-1$, $f\\left(\\frac{1}{2}\\right)=1$. Then\n$$\nS_{1}=0,\\quad S_{2}=\\frac{1}{6}\\left(0+0+0+4(-1)+4(1)\\right)=0,\n$$\nand $\\int_{-1}^{1}\\sin(\\pi x)\\,dx=0$ (odd integrand), so returning $0$ is correct.\n\nC. $f(x)=\\cos\\left(\\frac{\\pi}{2}x\\right)$. Compute $f(-1)=0$, $f(0)=1$, $f(1)=0$, $f\\left(\\pm\\frac{1}{2}\\right)=\\cos\\left(\\pm\\frac{\\pi}{4}\\right)=\\frac{\\sqrt{2}}{2}$. Then\n$$\nS_{1}=\\frac{1}{3}(0+4\\cdot 1+0)=\\frac{4}{3},\\quad\nS_{2}=\\frac{1}{6}\\left(0+0+2\\cdot 1+4\\cdot\\frac{\\sqrt{2}}{2}+4\\cdot\\frac{\\sqrt{2}}{2}\\right)=\\frac{1}{6}\\left(2+4\\sqrt{2}\\right)=\\frac{1}{3}\\left(1+2\\sqrt{2}\\right)\\neq 0,\n$$\nso the algorithm would not return $0$.\n\nD. $f(x)=16x^{6}-20x^{4}+x^{2}+1$. Compute $f(-1)=-2$, $f(0)=1$, $f(1)=-2$, and $f\\left(\\pm\\frac{1}{2}\\right)=16\\left(\\frac{1}{64}\\right)-20\\left(\\frac{1}{16}\\right)+\\frac{1}{4}+1=\\frac{1}{4}$. Then\n$$\nS_{1}=\\frac{1}{3}(-2+4\\cdot 1-2)=0,\\quad\nS_{2}=\\frac{1}{6}\\left(-2-2+2\\cdot 1+4\\cdot\\frac{1}{4}+4\\cdot\\frac{1}{4}\\right)=\\frac{1}{6}(-4+2+1+1)=0.\n$$\nThus $E=0$ and the algorithm terminates immediately, returning $0$. The true integral is\n$$\n\\int_{-1}^{1}\\left(16x^{6}-20x^{4}+x^{2}+1\\right)dx\n=2\\int_{0}^{1}\\left(16x^{6}-20x^{4}+x^{2}+1\\right)dx\n=2\\left(\\frac{16}{7}-4+\\frac{1}{3}+1\\right)\n=2\\left(\\frac{16}{7}-\\frac{8}{3}\\right)\n=-\\frac{16}{21}\\neq 0,\n$$\nso the returned value $0$ is incorrect.\n\nE. $f(x)=x^{5}-x^{3}+x$ is odd, so $S_{1}=0$, $S_{2}=0$ (by symmetry of nodes and weights), and $\\int_{-1}^{1}f(x)\\,dx=0$, hence returning $0$ is correct.\n\nOnly option D meets the requirement: immediate termination with $E=0$, returning $0$, while the true integral is nonzero.", "answer": "$$\\boxed{D}$$", "id": "2153040"}, {"introduction": "The ultimate demonstration of an adaptive method's value is seeing it in action on a function where uniform sampling would be prohibitively expensive. This hands-on coding challenge asks you to implement an adaptive integrator and apply it to a function that contains both smooth and highly oscillatory regions [@problem_id:3203443]. By tracking where the algorithm chooses to place its evaluation points, you will quantitatively confirm that it intelligently concentrates its effort on the most complex part of the integrand, which is the very essence of \"adaptive\" integration.", "problem": "Consider the interval $[0,2\\pi]$ and the piecewise-defined function $f(x)$ given by $f(x)=\\sin(x)$ for $x  \\pi$ and $f(x)=\\sin(100x)$ for $x \\ge \\pi$. The task is to implement an adaptive quadrature method that starts from foundational numerical analysis principles and uses local error control to decide where to subdivide the integration domain. You must construct a program that computes an approximation to the definite integral of $f(x)$ over $[0,2\\pi]$ and quantitatively analyzes how the adaptive procedure allocates nodes in the low-frequency region $[0,\\pi)$ compared to the high-frequency region $[\\pi,2\\pi]$.\n\nStart from the definition of the definite integral and the concept of composite numerical quadrature based on polynomial interpolation. Use a principled local error estimator to drive subdivision, ensuring that the algorithm refines subintervals where the estimated error is large. You must implement an adaptive algorithm based on Simpson-type local approximations that recursively bisects intervals until a specified absolute error tolerance $\\tau$ is met or a maximum recursion depth $D_{\\max}$ is reached. You should not assume any pre-derived shortcut formulas for the target method; instead, derive decisions from the core definitions of numerical integration and local error estimation.\n\nYour program must perform the following for each test input:\n- Compute the numerical approximation $I$ to $\\int_{0}^{2\\pi} f(x)\\,dx$.\n- Track the set of unique abscissas where $f(x)$ is evaluated, and report the counts $n_{\\text{low}}$ and $n_{\\text{high}}$ of unique points used in $[0,\\pi)$ and $[\\pi,2\\pi]$, respectively. Classify $x=\\pi$ as belonging to the high-frequency region.\n- Compute the absolute error $e=|I-I_{\\text{exact}}|$, where $I_{\\text{exact}}$ is the exact value of the integral derived from fundamental properties of trigonometric integrals.\n- Report whether the adaptive method allocated strictly more nodes to the high-frequency region than to the low-frequency region, that is, the boolean value of $n_{\\text{high}}n_{\\text{low}}$.\n\nTest Suite:\nProvide results for the following parameter sets $(\\tau,D_{\\max})$:\n1. $\\tau=10^{-6}$ and $D_{\\max}=40$ (general case).\n2. $\\tau=10^{-4}$ and $D_{\\max}=20$ (moderate tolerance).\n3. $\\tau=10^{-8}$ and $D_{\\max}=12$ (edge case with tight tolerance but limited recursion depth).\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case must contribute a nested list in the form $[I,e,n_{\\text{low}},n_{\\text{high}},\\text{high\\_more}]$, where $I$ and $e$ are floats, $n_{\\text{low}}$ and $n_{\\text{high}}$ are integers, and $\\text{high\\_more}$ is a boolean. For example, the overall output must look like $[[I_1,e_1,n_{\\text{low},1},n_{\\text{high},1},\\text{high\\_more}_1],[I_2,e_2,n_{\\text{low},2},n_{\\text{high},2},\\text{high\\_more}_2],[I_3,e_3,n_{\\text{low},3},n_{\\text{high},3},\\text{high\\_more}_3]]$. No physical units are involved.", "solution": "### 1. Principle-Based Derivation of the Adaptive Method\n\nThe goal is to approximate the definite integral $I = \\int_a^b f(x) \\, dx$. Adaptive quadrature methods refine the integration domain by subdividing intervals where the approximation error is estimated to be large, thus concentrating computational effort where the function is most difficult to integrate.\n\nWe will base our method on Simpson's rule, which approximates the integrand with a quadratic polynomial.\n\n**Local Approximation using Simpson's Rule**\n\nFor a given interval $[a, b]$, let $c = (a+b)/2$ be the midpoint. The basic Simpson's rule provides an approximation, $S_1$, using three points:\n$$ S_1 = \\frac{b-a}{6} \\left( f(a) + 4f(c) + f(b) \\right) $$\nThe error of this approximation is known to be $E_1 = -\\frac{(b-a)^5}{2880} f^{(4)}(\\xi_1)$ for some $\\xi_1 \\in (a, b)$.\n\nTo estimate this error without knowing $f^{(4)}$, we compute a more accurate approximation, $S_2$, by applying Simpson's rule to the two half-intervals, $[a, c]$ and $[c, b]$. Let $d = (a+c)/2$ and $e = (c+b)/2$ be the new midpoints. The composite Simpson's rule on these two subintervals yields:\n$$ S_2 = \\frac{c-a}{6} \\left( f(a) + 4f(d) + f(c) \\right) + \\frac{b-c}{6} \\left( f(c) + 4f(e) + f(b) \\right) $$\nSince $c-a = b-c = (b-a)/2$, this simplifies to:\n$$ S_2 = \\frac{b-a}{12} \\left( f(a) + 4f(d) + 2f(c) + 4f(e) + f(b) \\right) $$\nThe error of this 5-point approximation, $S_2$, is the sum of the errors on the two subintervals:\n$$ E_2 = -2 \\cdot \\frac{((b-a)/2)^5}{2880} f^{(4)}(\\xi_2) = -\\frac{1}{16} \\frac{(b-a)^5}{2880} f^{(4)}(\\xi_2) $$\nAssuming $f^{(4)}(x)$ is approximately constant over $[a, b]$, we have $E_2 \\approx \\frac{1}{16} E_1$.\n\n**Local Error Estimation**\n\nLet the true value of the integral over $[a, b]$ be $I_{[a,b]}$. We have the following relationships:\n$I_{[a,b]} \\approx S_1 + E_1$\n$I_{[a,b]} \\approx S_2 + E_2 \\approx S_2 + \\frac{1}{16} E_1$\n\nEquating the two expressions for $I_{[a,b]}$:\n$S_1 + E_1 \\approx S_2 + \\frac{1}{16} E_1 \\implies \\frac{15}{16} E_1 \\approx S_2 - S_1 \\implies E_1 \\approx \\frac{16}{15} (S_2 - S_1)$\n\nThe error in our *better* approximation, $S_2$, is what we are truly interested in. This error is $E_2 \\approx \\frac{1}{16} E_1$. Substituting the expression for $E_1$:\n$$ E_{\\text{local}} = E_2 \\approx \\frac{1}{16} \\left( \\frac{16}{15} (S_2 - S_1) \\right) = \\frac{S_2 - S_1}{15} $$\nThus, the magnitude of the local error can be estimated as $|S_2 - S_1| / 15$.\n\n**Recursive Subdivision Strategy**\n\nThe adaptive algorithm is implemented recursively. For an interval $[a, b]$ and a desired local tolerance $\\tau_{\\text{local}}$:\n1.  Compute the coarse approximation $S_1$ and the fine approximation $S_2$.\n2.  Estimate the error $E_{\\text{local}} = |S_2 - S_1|/15$.\n3.  If $E_{\\text{local}}  \\tau_{\\text{local}}$ or if a maximum recursion depth $D_{\\max}$ has been reached, the subdivision stops. The best estimate for the integral on this interval is returned. This can be the more accurate value $S_2$, or an even better estimate obtained through Richardson extrapolation: $I_{\\text{best}} = S_2 + E_{\\text{local}} = S_2 + (S_2 - S_1)/15$. We will use this improved value.\n4.  If the error is too large, the interval is bisected into $[a, c]$ and $[c, b]$. The algorithm is called recursively on each subinterval. The tolerance is distributed to the subproblems; a common strategy is to assign half of the parent's tolerance to each child, so $\\tau_{\\text{child}} = \\tau_{\\text{local}}/2$.\n\nThe initial call is on the full domain $[0, 2\\pi]$ with the user-specified tolerance $\\tau$ and maximum depth $D_{\\max}$.\n\n### 2. Analysis of the Target Problem\n\n**Function Definition**\n\nThe function to be integrated over $[0, 2\\pi]$ is:\n$$ f(x) = \\begin{cases} \\sin(x)  \\text{for } x  \\pi \\\\ \\sin(100x)  \\text{for } x \\ge \\pi \\end{cases} $$\nThis function has a low-frequency component on $[0, \\pi)$ and a high-frequency component on $[\\pi, 2\\pi]$. The adaptive algorithm is expected to perform many more subdivisions in the high-frequency region to resolve the rapid oscillations of $\\sin(100x)$.\n\n**Exact Integral Calculation**\n\nThe exact value of the integral is required to compute the error.\n$$ I_{\\text{exact}} = \\int_{0}^{2\\pi} f(x) \\, dx = \\int_{0}^{\\pi} \\sin(x) \\, dx + \\int_{\\pi}^{2\\pi} \\sin(100x) \\, dx $$\nThe first part is:\n$$ \\int_{0}^{\\pi} \\sin(x) \\, dx = [-\\cos(x)]_{0}^{\\pi} = (-\\cos(\\pi)) - (-\\cos(0)) = -(-1) - (-1) = 1+1=2 $$\nThe second part is:\n$$ \\int_{\\pi}^{2\\pi} \\sin(100x) \\, dx = \\left[-\\frac{1}{100}\\cos(100x)\\right]_{\\pi}^{2\\pi} = -\\frac{1}{100} (\\cos(200\\pi) - \\cos(100\\pi)) = -\\frac{1}{100} (1 - 1) = 0 $$\nTherefore, the exact value of the integral is $I_{\\text{exact}} = 2 + 0 = 2$.\n\n**Computational Plan**\n\nFor each test case $(\\tau, D_{\\max})$:\n1.  Initialize an empty set to store the unique abscissas (evaluation points).\n2.  Execute the recursive adaptive quadrature algorithm over $[0, 2\\pi]$. The recursive function will populate the set of abscissas.\n3.  The result of the algorithm is the numerical approximation $I$.\n4.  Calculate the absolute error $e = |I - I_{\\text{exact}}|$.\n5.  Iterate through the set of unique abscissas. Count the number of points in $[0, \\pi)$ as $n_{\\text{low}}$ and the number of points in $[\\pi, 2\\pi]$ as $n_{\\text{high}}$ (with $x=\\pi$ classified as high).\n6.  Determine the boolean value of the condition $n_{\\text{high}}  n_{\\text{low}}$.\n7.  Collect these five results: $[I, e, n_{\\text{low}}, n_{\\text{high}}, (n_{\\text{high}}  n_{\\text{low}})]$.\nThe results from all test cases will be compiled into a single list for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the final result.\n    \"\"\"\n\n    # Define the piecewise function f(x)\n    def f(x):\n        \"\"\"\n        The piecewise function to be integrated.\n        f(x) = sin(x) for x  pi\n        f(x) = sin(100x) for x = pi\n        \"\"\"\n        if isinstance(x, (list, np.ndarray)):\n            # Support for vectorized input, though the algorithm evaluates point-wise\n            return np.where(x  np.pi, np.sin(x), np.sin(100 * x))\n        else:\n            if x  np.pi:\n                return np.sin(x)\n            else:\n                return np.sin(100 * x)\n\n    class AdaptiveQuadrature:\n        \"\"\"\n        A class to encapsulate the adaptive quadrature logic and state.\n        This avoids using global variables for tracking evaluation points.\n        \"\"\"\n        def __init__(self, func, exact_value):\n            self.func = func\n            self.exact_value = exact_value\n            self.points_set = set()\n\n        def _recursive_solver(self, a, b, tol, depth):\n            \"\"\"\n            The recursive core of the adaptive Simpson's method.\n            \"\"\"\n            # 1. Define the 5 points for the two-level Simpson's rule\n            c = (a + b) / 2.0\n            d = (a + c) / 2.0\n            e = (c + b) / 2.0\n\n            # 2. Evaluate the function at the necessary points\n            # To avoid duplicate additions to the set, check first if needed,\n            # but for simplicity, we add all 5 and let the set handle uniqueness.\n            # This is less performant but conceptually clear.\n            fa, fb, fc = self.func(a), self.func(b), self.func(c)\n            fd, fe = self.func(d), self.func(e)\n            \n            # Record all unique evaluation points\n            self.points_set.update([a, b, c, d, e])\n\n            # 3. Compute coarse (S1) and fine (S2) approximations\n            # S1: Simpson's rule on [a, b]\n            s1 = (b - a) * (fa + 4 * fc + fb) / 6.0\n            # S2: Composite Simpson's rule on [a, c] and [c, b]\n            s2 = (b - a) * (fa + 4 * fd + 2 * fc + 4 * fe + fb) / 12.0\n\n            # 4. Estimate the error of the more accurate approximation, S2\n            # The error is estimated as |S2 - S1| / 15\n            error = abs(s2 - s1) / 15.0\n\n            # 5. Check stopping conditions\n            if depth = 0 or error  tol:\n                # Return the best estimate using Richardson extrapolation\n                return s2 + (s2 - s1) / 15.0\n            else:\n                # 6. Recurse on subintervals with scaled tolerance\n                left_integral = self._recursive_solver(a, c, tol / 2.0, depth - 1)\n                right_integral = self._recursive_solver(c, b, tol / 2.0, depth - 1)\n                return left_integral + right_integral\n\n        def compute(self, a, b, tau, d_max):\n            \"\"\"\n            Public method to run the adaptive quadrature for a given problem setup.\n            \"\"\"\n            self.points_set.clear()\n            \n            # Start the recursion\n            integral_approx = self._recursive_solver(a, b, tau, d_max)\n            \n            # Calculate absolute error\n            abs_error = abs(integral_approx - self.exact_value)\n            \n            # Analyze node distribution\n            n_low = 0\n            n_high = 0\n            pi_val = np.pi\n            for p in self.points_set:\n                if p  pi_val:\n                    n_low += 1\n                else:  # p = pi_val\n                    n_high += 1\n            \n            high_more = n_high  n_low\n            \n            return [integral_approx, abs_error, n_low, n_high, high_more]\n\n    # Define the problem's domain and exact integral value\n    a_domain, b_domain = 0, 2 * np.pi\n    i_exact = 2.0\n    \n    # Instantiate the solver\n    solver = AdaptiveQuadrature(func=f, exact_value=i_exact)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (tau, D_max)\n        (1e-6, 40),   # general case\n        (1e-4, 20),   # moderate tolerance\n        (1e-8, 12),   # tight tolerance, limited depth\n    ]\n\n    # Run the solver for each case and collect results\n    results = []\n    for tau, d_max in test_cases:\n        result = solver.compute(a_domain, b_domain, tau, d_max)\n        results.append(result)\n\n    # Format the final output string as required\n    # Custom formatter to handle boolean correctly as lowercased string\n    def format_item(item):\n        if isinstance(item, bool):\n            return str(item).lower()\n        return str(item)\n\n    # Format each inner list\n    formatted_results = []\n    for res_list in results:\n        formatted_list = f\"[{','.join(format_item(item) for item in res_list)}]\"\n        formatted_results.append(formatted_list)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3203443"}]}