{"hands_on_practices": [{"introduction": "Before relying on pre-built library functions, it is crucial to understand how quadrature rules are constructed from the ground up. This exercise [@problem_id:3214972] guides you through implementing the composite trapezoidal rule from its fundamental definition: approximating a function with a series of piecewise linear segments. By verifying its theoretical exactness for linear functions and observing how error is introduced by curvature, you will build a solid, intuitive understanding of the method's core properties and limitations.", "problem": "You are to write a complete, runnable program that constructs and studies the composite trapezoidal numerical integration rule from first principles, verifying exactness on linear functions and quantifying how error grows when a small quadratic curvature is added. The foundational base must be the definition of the Riemann integral and piecewise linear interpolation of the integrand on a uniform partition. On an interval $\\,[A,B]\\,$ partitioned into $\\,n\\,$ equal subintervals of width $\\,h = (B-A)/n\\,$, the composite trapezoidal rule is defined by constructing, on each subinterval $\\,[x_i, x_{i+1}]\\,$ with $\\,x_i = A + i h\\,$, the unique line that interpolates the integrand at the endpoints $\\,x_i\\,$ and $\\,x_{i+1}\\,$, integrating that line exactly over $\\,[x_i, x_{i+1}]\\,$, and summing these contributions over all subintervals. Your program must implement this definition directly and must not invoke any closed-form trapezoidal summation formula.\n\nThe tasks are as follows.\n\n1. Verify exactness on linear functions. For functions of the form $\\,f(x) = a x + b\\,$, exactness means that the composite trapezoidal rule returns the exact value of the integral $\\,\\int_A^B f(x)\\,dx\\,$ for any $\\,n \\ge 1\\,$. Use a tolerance of $\\,10^{-12}\\,$ on the absolute difference to decide exactness.\n\n2. Quantify error growth when a small quadratic curvature is added. Consider functions of the form $\\,f(x) = a x + b + \\varepsilon x^2\\,$ with $\\,\\varepsilon\\,$ small. Compute the absolute error $\\;E = \\left|\\text{composite\\_trapezoid}(f;[A,B],n) - \\int_A^B f(x)\\,dx\\right|\\;$ and study how $\\,E\\,$ depends on $\\,\\varepsilon\\,$, the interval length $\\,B-A\\,$, and the number of subintervals $\\,n\\,$.\n\nYour program must use a pseudorandom number generator seeded deterministically to ensure reproducibility. Initialize the generator with seed $\\,1729\\,$, and draw independent $\\,a\\,$ and $\\,b\\,$ uniformly from the interval $\\,[-3,3]\\,$ as specified below. All angles, if any appear, must be in radians; however, this problem does not involve physical units or angles.\n\nImplement the following test suite and produce outputs exactly as specified. For each integral, use the exact antiderivative for evaluation of $\\,\\int_A^B f(x)\\,dx\\,$:\n$$\n\\int_A^B \\big(a x + b + \\varepsilon x^2\\big)\\,dx \\;=\\; \\frac{a}{2}\\,(B^2 - A^2) \\;+\\; b\\,(B - A) \\;+\\; \\frac{\\varepsilon}{3}\\,(B^3 - A^3).\n$$\n\nTest suite:\n\n- Linear exactness tests (produce booleans):\n  - Case L1: $\\,f(x) = 0\\cdot x + 1\\,$ on $\\,[A,B]=[0,1]\\,$, check $\\,n \\in \\{1,5,13\\}\\,$.\n  - Case L2: draw $\\,a\\,$ and $\\,b\\,$ from the seeded generator, denote them $\\,a_1\\,$ and $\\,b_1\\,$, with $\\,a_1,b_1 \\sim \\mathcal{U}([-3,3])\\,$; set $\\,f(x) = a_1 x + b_1\\,$ on $\\,[A,B]=[0,1]\\,$, check $\\,n \\in \\{1,5,13\\}\\,$.\n  - Case L3: draw another independent pair $\\,a_2\\,$ and $\\,b_2\\,$ from the same generator; set $\\,f(x) = a_2 x + b_2\\,$ on $\\,[A,B]=[-2,3]\\,$, check $\\,n \\in \\{2,7,17\\}\\,$.\n\n- Curvature error tests (produce floats):\n  For all curvature tests, reuse the first random linear coefficients $\\,a_1\\,$ and $\\,b_1\\,$ from Case L2 and add curvature $\\,\\varepsilon x^2\\,$.\n  - Case C1: $\\,\\varepsilon = 10^{-3}\\,$, $\\,[A,B]=[0,1]\\,$, $\\,n=10\\,$. Output $\\,E\\,$ as a float.\n  - Case C2: same as Case C1 but with $\\,n=20\\,$. Output $\\,E\\,$ as a float.\n  - Case C3: output the ratio $\\,E_{\\text{C1}} / E_{\\text{C2}}\\,$ as a float.\n  - Case C4: $\\,\\varepsilon = 5\\cdot 10^{-3}\\,$, $\\,[A,B]=[0,1]\\,$, $\\,n=20\\,$. Output the ratio $\\,E(\\varepsilon=5\\cdot 10^{-3}) / E(\\varepsilon=10^{-3})\\,$ as a float.\n  - Case C5: $\\,\\varepsilon = 10^{-3}\\,$, $\\,[A,B]=[-1,1]\\,$, $\\,n=40\\,$. Output $\\,E\\,$ as a float.\n  - Case C6: $\\,\\varepsilon = 10^{-3}\\,$, $\\,[A,B]=[2,5]\\,$, $\\,n=30\\,$. Output $\\,E\\,$ as a float.\n  - Case C7 (edge case): $\\,\\varepsilon = 10^{-12}\\,$, $\\,[A,B]=[0,1]\\,$, $\\,n=10\\,$. Output $\\,E\\,$ as a float.\n\nProgram output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, the three booleans from Cases L1–L3 followed by the seven floats from Cases C1–C7. For example, an output line with placeholders would look like\n$\\,\\big[\\text{bool\\_L1},\\text{bool\\_L2},\\text{bool\\_L3},E_{\\text{C1}},E_{\\text{C2}},\\text{ratio\\_C3},\\text{ratio\\_C4},E_{\\text{C5}},E_{\\text{C6}},E_{\\text{C7}}\\big]\\,$.\n\nAll computations must be performed in pure mathematical terms without any physical units. Ensure numerical results are deterministic by adhering strictly to the specified random seed and generation procedure.", "solution": "The problem requires the construction and analysis of the composite trapezoidal numerical integration rule from first principles. This entails implementing the rule not from its final convenient summation formula, but from its fundamental definition: approximating an integrand by a series of piecewise linear functions and integrating these approximations. The analysis will verify the rule's exactness for linear functions and quantify its error for functions with quadratic curvature.\n\nThe definite integral $\\int_A^B f(x) dx$ represents the area under the curve of the function $f(x)$ from $x=A$ to $x=B$. The core idea of numerical quadrature is to approximate this area by dividing the interval $[A,B]$ into a partition and replacing the potentially complex function $f(x)$ on each sub-domain with a simpler, easily integrable function.\n\nThe composite trapezoidal rule begins by partitioning the interval $[A,B]$ into $n$ subintervals of equal width, $h = (B-A)/n$. The partition points are given by $x_i = A + i h$ for $i = 0, 1, \\dots, n$. On each subinterval $[x_i, x_{i+1}]$, the function $f(x)$ is approximated by the unique straight line, let us call it $p_i(x)$, that passes through the endpoints of the curve on that subinterval, namely $(x_i, f(x_i))$ and $(x_{i+1}, f(x_{i+1}))$. This is the linear interpolant of $f(x)$ at the nodes $x_i$ and $x_{i+1}$.\n\nThe equation for this line $p_i(x)$ is:\n$$\np_i(x) = f(x_i) + \\frac{f(x_{i+1}) - f(x_i)}{x_{i+1} - x_i}(x - x_i)\n$$\nThe integral of $f(x)$ over this subinterval is then approximated by the integral of $p_i(x)$:\n$$\n\\int_{x_i}^{x_{i+1}} f(x) dx \\approx \\int_{x_i}^{x_{i+1}} p_i(x) dx\n$$\nThe integral on the right is the area of the trapezoid with vertices $(x_i, 0)$, $(x_{i+1}, 0)$, $(x_{i+1}, f(x_{i+1}))$, and $(x_i, f(x_i))$. We can compute this integral directly:\n$$\n\\begin{aligned}\n\\int_{x_i}^{x_{i+1}} p_i(x) dx &= \\int_{x_i}^{x_{i+1}} \\left( f(x_i) + \\frac{f(x_{i+1}) - f(x_i)}{h}(x - x_i) \\right) dx \\\\\n&= \\left[ f(x_i)x + \\frac{f(x_{i+1}) - f(x_i)}{h} \\frac{(x-x_i)^2}{2} \\right]_{x_i}^{x_{i+1}} \\\\\n&= \\left( f(x_i)x_{i+1} + \\frac{f(x_{i+1}) - f(x_i)}{h} \\frac{h^2}{2} \\right) - \\left( f(x_i)x_i + 0 \\right) \\\\\n&= f(x_i)(x_{i+1} - x_i) + \\frac{f(x_{i+1}) - f(x_i)}{2}h \\\\\n&= f(x_i)h + \\frac{h}{2}f(x_{i+1}) - \\frac{h}{2}f(x_i) \\\\\n&= \\frac{h}{2}(f(x_i) + f(x_{i+1}))\n\\end{aligned}\n$$\nThis result is the well-known formula for the area of a trapezoid. The composite rule is formed by summing these areas over all $n$ subintervals:\n$$\n\\int_A^B f(x) dx \\approx \\sum_{i=0}^{n-1} \\frac{h}{2}(f(x_i) + f(x_{i+1}))\n$$\nThe implementation will follow this derivation by iterating through each subinterval, calculating the area of the corresponding trapezoid, and accumulating these areas into a total sum.\n\nA key property of the trapezoidal rule is its exactness for linear functions. If $f(x) = ax + b$, the function itself is a line. The linear interpolant $p_i(x)$ on any subinterval $[x_i, x_{i+1}]$ is defined by the two points $(x_i, f(x_i))$ and $(x_{i+1}, f(x_{i+1}))$. Since these points lie on the line $f(x)$, the interpolant $p_i(x)$ is identical to $f(x)$ over the entire subinterval. Consequently, the integral of the approximation, $\\int_{x_i}^{x_{i+1}} p_i(x) dx$, is exactly equal to the integral of the function, $\\int_{x_i}^{x_{i+1}} f(x) dx$. This holds for all subintervals, so the total sum is exact. This property is independent of the number of subintervals $n \\ge 1$.\n\nFor non-linear functions, the rule introduces an error. For a function with a small quadratic component, $f(x) = ax + b + \\varepsilon x^2$, the second derivative is constant: $f''(x) = 2\\varepsilon$. The local error on a single subinterval $[x_i, x_{i+1}]$ is given by the integral of the difference between the function and its linear interpolant, $f(x) - p_i(x)$. The error term for the trapezoidal rule on one interval of width $h$ is known to be $-\\frac{1}{12} f''(\\xi) h^3$ for some $\\xi \\in (x_i, x_{i+1})$. With $f''(x) = 2\\varepsilon$, this local error is $-\\frac{\\varepsilon}{6}h^3$. The total error is the sum of these local errors over all $n$ intervals:\n$$\nE = \\sum_{i=0}^{n-1} \\left( -\\frac{\\varepsilon}{6}h^3 \\right) = n \\left( -\\frac{\\varepsilon}{6}h^3 \\right)\n$$\nSubstituting $h = (B-A)/n$, we obtain the global error:\n$$\nE = n \\left( -\\frac{\\varepsilon}{6}\\left(\\frac{B-A}{n}\\right)^3 \\right) = -\\frac{\\varepsilon(B-A)^3}{6n^2}\n$$\nThe absolute error is $|E| = \\frac{|\\varepsilon|(B-A)^3}{6n^2}$. This theoretical result predicts that the error is directly proportional to the magnitude of the curvature, $|\\varepsilon|$, and inversely proportional to the square of the number of subintervals, $n^2$. The test cases are designed to verify these relationships. For instance, doubling $n$ should reduce the error by a factor of $2^2=4$. Multiplying $\\varepsilon$ by a factor of $k$ should multiply the error by the same factor $k$.\n\nThe program will implement these principles, performing calculations for the specified test suite to produce the required boolean and floating-point results, respecting the deterministic setup through a seeded random number generator. The exact integral for verification is calculated using the provided antiderivative: $\\int_A^B (ax + b + \\varepsilon x^2)dx = \\frac{a}{2}(B^2 - A^2) + b(B-A) + \\frac{\\varepsilon}{3}(B^3 - A^3)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and studies the composite trapezoidal rule, verifying its\n    properties on linear and nearly-linear functions.\n    \"\"\"\n\n    def composite_trapezoid(f, A, B, n):\n        \"\"\"\n        Computes the definite integral of f from A to B using the composite\n        trapezoidal rule with n subintervals, implemented from first principles.\n        \"\"\"\n        h = (B - A) / n\n        total_integral = 0.0\n        for i in range(n):\n            x_i = A + i * h\n            x_i1 = A + (i + 1) * h\n            y_i = f(x_i)\n            y_i1 = f(x_i1)\n            # The integral of the unique line connecting (x_i, y_i) and (x_i1, y_i1)\n            # over [x_i, x_i1] is the area of a trapezoid.\n            sub_integral = h * (y_i + y_i1) / 2.0\n            total_integral += sub_integral\n        return total_integral\n\n    def exact_integral_eval(a, b, eps, A, B):\n        \"\"\"\n        Computes the exact integral of f(x) = ax + b + eps*x^2 from A to B.\n        \"\"\"\n        term_a = a / 2.0 * (B**2 - A**2)\n        term_b = b * (B - A)\n        term_eps = eps / 3.0 * (B**3 - A**3)\n        return term_a + term_b + term_eps\n\n    results = []\n    TOL = 1e-12\n    SEED = 1729\n    rng = np.random.default_rng(seed=SEED)\n\n    # --- Linear exactness tests ---\n    # Case L1\n    a, b, eps = 0.0, 1.0, 0.0\n    A, B = 0.0, 1.0\n    ns_L1 = [1, 5, 13]\n    f_L1 = lambda x: a * x + b\n    exact_L1 = exact_integral_eval(a, b, eps, A, B)\n    is_exact_L1 = all(abs(composite_trapezoid(f_L1, A, B, n) - exact_L1) < TOL for n in ns_L1)\n    results.append(is_exact_L1)\n\n    # Case L2\n    a1, b1 = rng.uniform(-3, 3, 2)\n    eps = 0.0\n    A, B = 0.0, 1.0\n    ns_L2 = [1, 5, 13]\n    f_L2 = lambda x: a1 * x + b1\n    exact_L2 = exact_integral_eval(a1, b1, eps, A, B)\n    is_exact_L2 = all(abs(composite_trapezoid(f_L2, A, B, n) - exact_L2) < TOL for n in ns_L2)\n    results.append(is_exact_L2)\n\n    # Case L3\n    a2, b2 = rng.uniform(-3, 3, 2)\n    eps = 0.0\n    A, B = -2.0, 3.0\n    ns_L3 = [2, 7, 17]\n    f_L3 = lambda x: a2 * x + b2\n    exact_L3 = exact_integral_eval(a2, b2, eps, A, B)\n    is_exact_L3 = all(abs(composite_trapezoid(f_L3, A, B, n) - exact_L3) < TOL for n in ns_L3)\n    results.append(is_exact_L3)\n\n    # --- Curvature error tests ---\n    # Constants for curvature tests reuse a1, b1 from L2.\n    a, b = a1, b1\n\n    # Case C1\n    eps_C1 = 1e-3\n    A_C1, B_C1 = 0.0, 1.0\n    n_C1 = 10\n    f_C1 = lambda x: a * x + b + eps_C1 * x**2\n    num_C1 = composite_trapezoid(f_C1, A_C1, B_C1, n_C1)\n    exact_C1 = exact_integral_eval(a, b, eps_C1, A_C1, B_C1)\n    E_C1 = abs(num_C1 - exact_C1)\n    results.append(E_C1)\n    \n    # Case C2\n    eps_C2 = 1e-3\n    A_C2, B_C2 = 0.0, 1.0\n    n_C2 = 20\n    f_C2 = lambda x: a * x + b + eps_C2 * x**2\n    num_C2 = composite_trapezoid(f_C2, A_C2, B_C2, n_C2)\n    exact_C2 = exact_integral_eval(a, b, eps_C2, A_C2, B_C2)\n    E_C2 = abs(num_C2 - exact_C2)\n    results.append(E_C2)\n    \n    # Case C3\n    ratio_C3 = E_C1 / E_C2\n    results.append(ratio_C3)\n    \n    # Case C4\n    eps_C4 = 5e-3\n    A_C4, B_C4 = 0.0, 1.0\n    n_C4 = 20\n    f_C4 = lambda x: a * x + b + eps_C4 * x**2\n    num_C4 = composite_trapezoid(f_C4, A_C4, B_C4, n_C4)\n    exact_C4 = exact_integral_eval(a, b, eps_C4, A_C4, B_C4)\n    E_C4 = abs(num_C4 - exact_C4)\n    ratio_C4 = E_C4 / E_C2 # Compare with C2 error (same A,B,n, different eps)\n    results.append(ratio_C4)\n\n    # Case C5\n    eps_C5 = 1e-3\n    A_C5, B_C5 = -1.0, 1.0\n    n_C5 = 40\n    f_C5 = lambda x: a * x + b + eps_C5 * x**2\n    num_C5 = composite_trapezoid(f_C5, A_C5, B_C5, n_C5)\n    exact_C5 = exact_integral_eval(a, b, eps_C5, A_C5, B_C5)\n    E_C5 = abs(num_C5 - exact_C5)\n    results.append(E_C5)\n\n    # Case C6\n    eps_C6 = 1e-3\n    A_C6, B_C6 = 2.0, 5.0\n    n_C6 = 30\n    f_C6 = lambda x: a * x + b + eps_C6 * x**2\n    num_C6 = composite_trapezoid(f_C6, A_C6, B_C6, n_C6)\n    exact_C6 = exact_integral_eval(a, b, eps_C6, A_C6, B_C6)\n    E_C6 = abs(num_C6 - exact_C6)\n    results.append(E_C6)\n    \n    # Case C7\n    eps_C7 = 1e-12\n    A_C7, B_C7 = 0.0, 1.0\n    n_C7 = 10\n    f_C7 = lambda x: a * x + b + eps_C7 * x**2\n    num_C7 = composite_trapezoid(f_C7, A_C7, B_C7, n_C7)\n    exact_C7 = exact_integral_eval(a, b, eps_C7, A_C7, B_C7)\n    E_C7 = abs(num_C7 - exact_C7)\n    results.append(E_C7)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3214972"}, {"introduction": "A uniform grid can be highly inefficient, wasting computational resources on regions where a function is flat. This exercise [@problem_id:2180787] introduces a powerful hybrid analytical-numerical method known as \"subtracting out the singularity\". You will learn to tame an improper integral by identifying and analytically integrating its singular component, transforming the remaining problem into a regular, well-behaved integral that is easily handled by numerical quadrature.", "problem": "Consider the improper integral $I = \\int_0^{\\pi/2} \\frac{dx}{\\sqrt{\\sin(x)}}$. This integral is challenging for standard numerical quadrature schemes due to the singularity of the integrand at the lower limit of integration, $x=0$.\n\nA powerful technique to evaluate such an integral is \"subtracting out the singularity\". This method involves splitting the integrand $f(x)$ into two parts: a singular part $f_{sing}(x)$ that captures the problematic behavior but is analytically integrable, and a regular (well-behaved) part $f_{reg}(x) = f(x) - f_{sing}(x)$ that is suitable for numerical integration. The original integral is then expressed as:\n$$I = \\int_0^{\\pi/2} f_{reg}(x) \\,dx + \\int_0^{\\pi/2} f_{sing}(x) \\,dx$$\n\nYour task is to apply this technique. First, identify an appropriate function $f_{sing}(x)$ by using the leading-order term of the Maclaurin series for $\\sin(x)$ to approximate the integrand for small $x$. Next, analytically evaluate the integral of this singular part, which we will call $I_{sing} = \\int_0^{\\pi/2} f_{sing}(x) \\,dx$.\n\nFor the purpose of this problem, assume that the integral of the regular part has been precisely evaluated by a numerical method, yielding:\n$$ \\int_0^{\\pi/2} \\left( \\frac{1}{\\sqrt{\\sin(x)}} - f_{sing}(x) \\right) dx \\approx 0.1154 $$\n\nUsing your analytical result for $I_{sing}$ and the given numerical value for the regular part, determine the value of the original integral $I$. Round your final answer to four significant figures.", "solution": "We are given the improper integral $I=\\int_{0}^{\\pi/2} \\frac{dx}{\\sqrt{\\sin(x)}}$ with an integrable singularity at $x=0$. To apply the subtracting-the-singularity technique, we approximate the integrand near $x=0$ using the leading term of the Maclaurin series for $\\sin(x)$.\n\nThe Maclaurin expansion for $\\sin(x)$ is\n$$\n\\sin(x)=x-\\frac{x^{3}}{3!}+O(x^{5}).\n$$\nFor small $x$, the leading-order behavior is $\\sin(x)\\sim x$. Therefore,\n$$\n\\frac{1}{\\sqrt{\\sin(x)}}\\sim \\frac{1}{\\sqrt{x}} \\quad \\text{as } x\\to 0^{+}.\n$$\nAn appropriate choice for the singular part is\n$$\nf_{\\text{sing}}(x)=\\frac{1}{\\sqrt{x}}.\n$$\nThen the regular part is\n$$\nf_{\\text{reg}}(x)=\\frac{1}{\\sqrt{\\sin(x)}}-\\frac{1}{\\sqrt{x}}.\n$$\nTo verify that $f_{\\text{reg}}$ is well-behaved at $x=0$, write\n$$\n\\frac{1}{\\sqrt{\\sin(x)}}=\\frac{1}{\\sqrt{x}}\\frac{1}{\\sqrt{1-\\frac{x^{2}}{6}+O(x^{4})}}\n=\\frac{1}{\\sqrt{x}}\\left(1+\\frac{1}{2}\\left(\\frac{x^{2}}{6}\\right)+O(x^{4})\\right)\n=\\frac{1}{\\sqrt{x}}+\\frac{1}{12}x^{3/2}+O(x^{7/2}),\n$$\nso\n$$\nf_{\\text{reg}}(x)=\\frac{1}{12}x^{3/2}+O(x^{7/2}) \\quad \\text{as } x\\to 0^{+},\n$$\nwhich is continuous and integrable on $[0,\\pi/2]$.\n\nNext, we analytically evaluate the singular integral\n$$\nI_{\\text{sing}}=\\int_{0}^{\\pi/2} f_{\\text{sing}}(x)\\,dx=\\int_{0}^{\\pi/2} x^{-1/2}\\,dx.\n$$\nUsing the antiderivative $\\int x^{-1/2}\\,dx=2x^{1/2}$, we obtain\n$$\nI_{\\text{sing}}=\\left[2x^{1/2}\\right]_{0}^{\\pi/2}=2\\sqrt{\\frac{\\pi}{2}}=\\sqrt{2\\pi}.\n$$\n\nBy construction,\n$$\nI=\\int_{0}^{\\pi/2} f_{\\text{reg}}(x)\\,dx+\\int_{0}^{\\pi/2} f_{\\text{sing}}(x)\\,dx.\n$$\nWe are given the numerical evaluation\n$$\n\\int_{0}^{\\pi/2}\\left(\\frac{1}{\\sqrt{\\sin(x)}}-\\frac{1}{\\sqrt{x}}\\right)dx\\approx 0.1154,\n$$\nso\n$$\nI\\approx 0.1154+\\sqrt{2\\pi}.\n$$\nNumerically, $\\sqrt{2\\pi}\\approx 2.506628274631$, hence\n$$\nI\\approx 0.1154+2.506628274631=2.622028274631.\n$$\nRounding to four significant figures gives\n$$\nI\\approx 2.622.\n$$", "answer": "$$\\boxed{2.622}$$", "id": "2180787"}, {"introduction": "A uniform grid can be highly inefficient, wasting computational resources on regions where a function is flat. This exercise [@problem_id:3214881] explores adaptive quadrature, an intelligent approach that automatically concentrates computational effort where it is needed most. By implementing and comparing an adaptive Simpson's method against its uniform-grid counterpart, you will gain practical insight into how adaptivity can achieve superior accuracy with significantly fewer function evaluations.", "problem": "Consider the numerical evaluation of the definite integral of the function $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$ on the interval $[0,1]$. The task is to implement two composite numerical integration methods based on the Simpson rule and to compare their accuracy and computational effort:\n\n1. A uniform composite Simpson method over a partition of $[0,1]$ into $N$ equal subintervals, where $N$ is an even integer. If an odd $N$ is supplied, the implementation must increase it by $1$ so that the rule is applicable.\n\n2. An adaptive composite Simpson method with local error control, which recursively subdivides an interval until a specified local absolute tolerance $\\text{tol}$ is met. Local error control must be enforced by comparing the Simpson approximation on an interval with the sum of Simpson approximations on its two halves, and by distributing the tolerance across subintervals in a manner that ensures a globally controlled absolute error.\n\nThe implementation should build from the following fundamental base:\n\n- Polynomial interpolation: approximate a sufficiently smooth function on an interval by a quadratic interpolant through three points and integrate the interpolant exactly.\n- Error behavior of composite polynomial-based quadrature: for sufficiently smooth $f$, the Simpson rule has a truncation error that scales with the fifth power of the interval length for a single panel and yields a fourth-order global convergence rate when applied uniformly.\n\nCompute the true value of the integral using the known antiderivative of a Gaussian function, expressed in terms of the error function, and use it as the ground truth for error calculation.\n\nFor each method, report:\n- The absolute error with respect to the true integral.\n- The number of function evaluations used.\n\nThe program must implement both methods and run the following test suite, where each test case is a pair $(\\text{tol}, N)$:\n\n- Test case 1 (happy path): $\\text{tol} = 10^{-6}$, $N = 100$.\n- Test case 2 (tighter tolerance, finer grid): $\\text{tol} = 10^{-8}$, $N = 1000$.\n- Test case 3 (looser tolerance, coarse grid): $\\text{tol} = 10^{-4}$, $N = 10$.\n- Test case 4 (edge case with minimal uniform panels): $\\text{tol} = 10^{-10}$, $N = 2$.\n- Test case 5 (very strict tolerance): $\\text{tol} = 10^{-12}$, $N = 200$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this list corresponds to one test case and must itself be a list of four values in the following order: $[\\text{abs\\_error\\_adaptive}, \\text{evals\\_adaptive}, \\text{abs\\_error\\_uniform}, \\text{evals\\_uniform}]$. For example, an output for two cases would have the form $[[e_1,c_1,E_1,C_1],[e_2,c_2,E_2,C_2]]$.\n\nNo physical units are involved in this problem, and no angles or percentages are required. The final output values must be real numbers or integers, as appropriate, without any additional text.", "solution": "The task is to evaluate the definite integral $I = \\int_0^1 f(x) \\,dx$ for $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$ using two variants of the composite Simpson's rule and compare their efficiency.\n\nTo assess the accuracy of our numerical methods, we first need a \"ground truth\" value for the integral. The integral of a Gaussian function can be expressed using the error function, $\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2} \\,dt$. By performing a change of variables $u = 10(x - 0.3)$, the integral transforms to $I = \\frac{1}{10} \\int_{-3}^{7} e^{-u^2} \\,du$. Using the definition of the error function and its property $\\text{erf}(-z) = -\\text{erf}(z)$, the exact value can be found:\n$$ I_{true} = \\frac{\\sqrt{\\pi}}{20} \\left[ \\text{erf}(7) + \\text{erf}(3) \\right] $$\nThis value will serve as our benchmark for calculating errors.\n\nThe **uniform composite Simpson's rule** provides a straightforward approach. It applies the basic Simpson's rule, which integrates a quadratic interpolant over an interval, to a uniform partition of $[a, b]$ into $N$ subintervals of width $h = (b-a)/N$. The approximation is given by the formula:\n$$ S_N = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1, i \\text{ odd}}^{N-1} f(x_i) + 2\\sum_{i=2, i \\text{ even}}^{N-2} f(x_i) + f(x_N) \\right] $$\nThis method is simple but can be inefficient for a function with localized features, such as the sharp peak of the given Gaussian. It wastes computational effort by using a fixed step size in regions where the function is nearly flat. The total number of function evaluations is $N+1$.\n\nThe **adaptive composite Simpson's rule** offers a more intelligent strategy. It adjusts the density of evaluation points based on the local behavior of the integrand. The method works by recursively refining the grid. For any interval, it computes a \"coarse\" approximation with one Simpson panel ($S_1$) and a \"fine\" approximation with two panels ($S_2$). The difference between these provides an error estimate for the finer approximation: $\\text{err} \\approx \\frac{|S_2 - S_1|}{15}$. If this error is smaller than a local tolerance, the result is accepted (often using the more accurate Richardson-extrapolated value $S_2 + \\frac{S_2 - S_1}{15}$). If the error is too large, the interval is subdivided, and the procedure is applied to each half with a halved tolerance. This ensures that computational effort is concentrated where the function changes most rapidly—in this case, near the peak at $x=0.3$—thereby achieving a desired accuracy with potentially far fewer function evaluations than the uniform method.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Implements and compares uniform and adaptive Simpson's rule for integrating\n    a Gaussian function, then runs a suite of test cases.\n    \"\"\"\n    \n    # 1. Define the function to integrate\n    def f(x):\n        return np.exp(-100.0 * (x - 0.3)**2)\n\n    # 2. Calculate the \"true\" value of the integral using the error function\n    # I = integral from 0 to 1 of exp(-100*(x-0.3)^2) dx\n    # Let u = 10*(x-0.3), so du = 10*dx.\n    # Limits: x=0 -> u=-3; x=1 -> u=7.\n    # I = (1/10) * integral from -3 to 7 of exp(-u^2) du\n    # Using erf(z) = (2/sqrt(pi)) * integral from 0 to z of exp(-t^2) dt\n    # Integral from a to b = sqrt(pi)/2 * (erf(b) - erf(a))\n    # I = (1/10) * sqrt(pi)/2 * (erf(7) - erf(-3))\n    #   = (sqrt(pi)/20) * (erf(7) + erf(3))\n    true_value = (math.sqrt(math.pi) / 20.0) * (math.erf(7.0) + math.erf(3.0))\n\n    # 3. Uniform Composite Simpson's Rule Implementation\n    def uniform_simpson(func, a, b, N):\n        \"\"\"\n        Calculates the definite integral using the uniform composite Simpson's rule.\n        \n        Args:\n            func: The function to integrate.\n            a, b: The interval of integration.\n            N: The number of subintervals (must be even, adjusted if not).\n            \n        Returns:\n            A tuple (integral_value, num_evaluations).\n        \"\"\"\n        if N % 2 != 0:\n            N += 1\n        \n        h = (b - a) / float(N)\n        x = np.linspace(a, b, N + 1)\n        y = func(x)\n        \n        # Simpson's formula: h/3 * (y0 + 4y1 + 2y2 + ... + 4y(N-1) + yN)\n        # Slicing: y[1:-1:2] gets odd indices, y[2:-2:2] gets even indices.\n        integral = (h / 3.0) * (y[0] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-2:2]) + y[-1])\n        \n        evals = N + 1\n        return integral, evals\n\n    # 4. Adaptive Composite Simpson's Rule Implementation\n    def adaptive_simpson(func, a, b, tol):\n        \"\"\"\n        Wrapper for the recursive adaptive Simpson's rule integrator.\n        \n        Args:\n            func: The function to integrate.\n            a, b: The interval of integration.\n            tol: The desired absolute error tolerance.\n            \n        Returns:\n            A tuple (integral_value, num_evaluations).\n        \"\"\"\n        \n        eval_count = [0] # Use a list as a mutable counter\n\n        def f_counted(x):\n            eval_count[0] += 1\n            return func(x)\n        \n        # Initial function evaluations\n        fa = f_counted(a)\n        fm = f_counted((a + b) / 2.0)\n        fb = f_counted(b)\n        \n        integral = _adaptive_simpson_recursive(f_counted, a, b, tol, fa, fm, fb)\n        \n        return integral, eval_count[0]\n\n    def _adaptive_simpson_recursive(func, a, b, tol, fa, fm, fb):\n        \"\"\"Recursive helper for adaptive Simpson's rule.\"\"\"\n        h = b - a\n        m = (a + b) / 2.0\n        \n        # Coarse approximation (1 panel)\n        s1 = (h / 6.0) * (fa + 4.0 * fm + fb)\n        \n        # Finer approximation (2 panels) requires 2 new function evaluations\n        ml = (a + m) / 2.0\n        mr = (m + b) / 2.0\n        fml = func(ml)\n        fmr = func(mr)\n        \n        s2 = (h / 12.0) * (fa + 4.0 * fml + 2.0 * fm + 4.0 * fmr + fb)\n        \n        # Error estimation: |(S2 - S1) / 15| is an estimate of the error in S2.\n        error_estimate = abs(s2 - s1) / 15.0\n        \n        if error_estimate < tol:\n            # Richardson extrapolation for a more accurate result\n            return s2 + (s2 - s1) / 15.0\n        else:\n            # Subdivide and recurse, distributing tolerance\n            left_integral = _adaptive_simpson_recursive(func, a, m, tol / 2.0, fa, fml, fm)\n            right_integral = _adaptive_simpson_recursive(func, m, b, tol / 2.0, fm, fmr, fb)\n            return left_integral + right_integral\n\n    # 5. Define test cases\n    test_cases = [\n        (1e-6, 100),\n        (1e-8, 1000),\n        (1e-4, 10),\n        (1e-10, 2),\n        (1e-12, 200),\n    ]\n\n    all_results = []\n\n    # 6. Run the test suite\n    for tol, N in test_cases:\n        # Run adaptive method\n        res_adaptive, evals_adaptive = adaptive_simpson(f, 0.0, 1.0, tol)\n        error_adaptive = abs(res_adaptive - true_value)\n\n        # Run uniform method\n        res_uniform, evals_uniform = uniform_simpson(f, 0.0, 1.0, N)\n        error_uniform = abs(res_uniform - true_value)\n        \n        # Store results for this test case\n        case_result = [error_adaptive, evals_adaptive, error_uniform, evals_uniform]\n        all_results.append(case_result)\n\n    # 7. Format and print the final output\n    # The output format must be exact: [[v1,v2,v3,v4],[v5,v6,v7,v8]] with no spaces.\n    # repr() gives the correct bracket/comma structure, and .replace removes spaces.\n    output_str = repr(all_results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```", "id": "3214881"}]}