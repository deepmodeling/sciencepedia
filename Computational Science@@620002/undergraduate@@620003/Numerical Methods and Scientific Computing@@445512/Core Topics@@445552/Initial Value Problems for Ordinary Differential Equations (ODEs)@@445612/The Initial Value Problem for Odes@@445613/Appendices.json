{"hands_on_practices": [{"introduction": "The world of numerical solvers for ODEs is rich with different methods, each with its own philosophy and trade-offs. This first practice invites you to compare two powerful fourth-order methods: the Taylor series method and the classical Runge-Kutta (RK4) method [@problem_id:3282721]. By implementing both, you will gain a deeper appreciation for the balance between the analytical work required upfront (for the Taylor method) and the computational cost per step (for the RK4 method), a fundamental consideration in scientific computing.", "problem": "Implement a complete program that numerically solves the initial value problem (IVP) ordinary differential equation (ODE) $y'(t) = \\cos(t) + y(t)$ with initial condition $y(0) = y_0$ over the interval $[0, T]$ using two methods: a Taylor series method of order $4$ and the classical Runge–Kutta method of order $4$ (RK4). Your implementation must start from the foundational definition of the IVP, namely that for a continuously differentiable right-hand side $f(t,y)$, the IVP is specified by $y'(t) = f(t, y(t))$ and $y(t_0) = y_0$. Derive the Taylor series method of order $4$ for this ODE by expanding $y(t)$ in a Taylor series about $t_n$ and expressing time derivatives $y^{(k)}(t_n)$ in terms of $t_n$ and $y_n$ using the chain rule applied to $f(t,y) = \\cos(t) + y$. Implement the RK4 method by constructing a $4$-stage approximation based on the fundamental idea of approximating the integral of $f(t,y(t))$ over each step by weighted evaluations at intermediate points. Do not use or assume any shortcut formulas beyond these fundamental bases.\n\nUse the exact analytical solution to evaluate accuracy: solve the linear IVP $y'(t) - y(t) = \\cos(t)$ via integrating factors to obtain $y(t)$, then compute the absolute error at $t = T$ for each numerical method. Define computational cost as the total number of evaluations of the base right-hand side function $f(t,y)$ (each call to $f$ counts as $1$ unit of cost). Angles used in $\\cos(\\cdot)$ and $\\sin(\\cdot)$ must be interpreted in radians.\n\nTest suite:\n- Final time $T = 1$.\n- Initial conditions $y_0 \\in \\{0, 1\\}$.\n- Step sizes $h \\in \\{1.0, 0.2, 0.1, 0.05, 0.0125\\}$, each chosen so that $N = T/h$ is an integer number of steps.\n\nFor each test case $(y_0, h)$, compute:\n- The absolute error at $t = T$ for the Taylor-$4$ method, denoted $E_{\\mathrm{T4}}$.\n- The absolute error at $t = T$ for RK4, denoted $E_{\\mathrm{RK4}}$.\n- The total function evaluation cost for the Taylor-$4$ method, denoted $C_{\\mathrm{T4}}$.\n- The total function evaluation cost for RK4, denoted $C_{\\mathrm{RK4}}$.\n\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of the form $[E_{\\mathrm{T4}}, E_{\\mathrm{RK4}}, C_{\\mathrm{T4}}, C_{\\mathrm{RK4}}]$. For example: $[[e_1,r_1,c_1,d_1],[e_2,r_2,c_2,d_2],\\dots]$. All numerical values should be standard floating-point or integer types without any unit symbols.", "solution": "The user-provided problem is assessed to be valid. It is a well-posed initial value problem (IVP) within the standard framework of numerical methods for ordinary differential equations (ODEs). The problem statement is scientifically grounded, self-contained, and provides all necessary parameters, definitions, and constraints for a unique and meaningful solution.\n\nThe problem requires solving the IVP defined by the first-order ODE $y'(t) = \\cos(t) + y(t)$ with the initial condition $y(0) = y_0$ on the interval $[0, T]$. This will be accomplished using two distinct numerical methods of order $4$: the Taylor series method and the classical Runge-Kutta method (RK4). The accuracy of these methods will be benchmarked against the exact analytical solution.\n\n### 1. Analytical Solution\n\nThe ODE is a first-order linear differential equation which can be written in the standard form $y'(t) - y(t) = \\cos(t)$. We solve this using an integrating factor, $I(t)$.\n\nThe integrating factor is given by $I(t) = \\exp\\left(\\int -1 \\, dt\\right) = e^{-t}$. Multiplying the standard form of the ODE by $I(t)$ gives:\n$$e^{-t} y'(t) - e^{-t} y(t) = e^{-t} \\cos(t)$$\nThe left-hand side is the derivative of the product $I(t)y(t) = e^{-t}y(t)$:\n$$\\frac{d}{dt}\\left(e^{-t} y(t)\\right) = e^{-t} \\cos(t)$$\nIntegrating both sides with respect to $t$:\n$$e^{-t} y(t) = \\int e^{-t} \\cos(t) \\, dt$$\nTo evaluate the integral on the right-hand side, we use integration by parts twice. Let the integral be $J = \\int e^{-t} \\cos(t) \\, dt$.\nFirst, let $u = \\cos(t)$ and $dv = e^{-t} dt$, so $du = -\\sin(t) dt$ and $v = -e^{-t}$.\n$$J = -\\cos(t)e^{-t} - \\int (-e^{-t})(-\\sin(t)) \\, dt = -e^{-t}\\cos(t) - \\int e^{-t}\\sin(t) \\, dt$$\nFor the remaining integral, let $u = \\sin(t)$ and $dv = e^{-t} dt$, so $du = \\cos(t) dt$ and $v = -e^{-t}$.\n$$\\int e^{-t}\\sin(t) \\, dt = -\\sin(t)e^{-t} - \\int (-e^{-t})(\\cos(t)) \\, dt = -e^{-t}\\sin(t) + J$$\nSubstituting this back into the equation for $J$:\n$$J = -e^{-t}\\cos(t) - (-e^{-t}\\sin(t) + J)$$\n$$2J = e^{-t}(\\sin(t) - \\cos(t))$$\n$$J = \\frac{1}{2}e^{-t}(\\sin(t) - \\cos(t)) + C_0$$\nwhere $C_0$ is the constant of integration.\nSubstituting this result back into the equation for $y(t)$:\n$$e^{-t} y(t) = \\frac{1}{2}e^{-t}(\\sin(t) - \\cos(t)) + C_0$$\n$$y(t) = \\frac{1}{2}(\\sin(t) - \\cos(t)) + C_0 e^{t}$$\nWe apply the initial condition $y(0) = y_0$ to determine $C_0$:\n$$y_0 = y(0) = \\frac{1}{2}(\\sin(0) - \\cos(0)) + C_0 e^{0} = \\frac{1}{2}(0 - 1) + C_0 = -\\frac{1}{2} + C_0$$\nThus, $C_0 = y_0 + \\frac{1}{2}$. The exact analytical solution is:\n$$y(t) = \\frac{1}{2}(\\sin(t) - \\cos(t)) + \\left(y_0 + \\frac{1}{2}\\right) e^{t}$$\n\n### 2. Taylor Series Method of Order 4 (T4)\n\nThe Taylor series method is derived by expanding the solution $y(t)$ around a point $t_n$ to approximate the value at $t_{n+1} = t_n + h$:\n$$y(t_{n+1}) = y(t_n) + h y'(t_n) + \\frac{h^2}{2!} y''(t_n) + \\frac{h^3}{3!} y'''(t_n) + \\frac{h^4}{4!} y^{(4)}(t_n) + O(h^5)$$\nA method of order $4$ truncates this series after the $h^4$ term. The numerical update rule is:\n$$y_{n+1} = y_n + h y'(t_n) + \\frac{h^2}{2} y''(t_n) + \\frac{h^3}{6} y'''(t_n) + \\frac{h^4}{24} y^{(4)}(t_n)$$\nWe must express the derivatives of $y$ at $t_n$ in terms of $t_n$ and $y_n = y(t_n)$. Given $y'(t) = f(t,y) = \\cos(t) + y(t)$, we find the higher derivatives by repeated total differentiation with respect to $t$:\n- $y'(t) = \\cos(t) + y(t)$\n- $y''(t) = \\frac{d}{dt}y'(t) = -\\sin(t) + y'(t) = -\\sin(t) + \\cos(t) + y(t)$\n- $y'''(t) = \\frac{d}{dt}y''(t) = -\\cos(t) - \\sin(t) + y'(t) = -\\cos(t) - \\sin(t) + (\\cos(t) + y(t)) = -\\sin(t) + y(t)$\n- $y^{(4)}(t) = \\frac{d}{dt}y'''(t) = -\\cos(t) + y'(t) = -\\cos(t) + (\\cos(t) + y(t)) = y(t)$\n\nSubstituting these into the update rule, with $y_n$ approximating $y(t_n)$:\n$y_{n+1} = y_n + h(\\cos(t_n) + y_n) + \\frac{h^2}{2}(-\\sin(t_n) + \\cos(t_n) + y_n) + \\frac{h^3}{6}(-\\sin(t_n) + y_n) + \\frac{h^4}{24}y_n$\nThe computational cost is defined as the number of evaluations of $f(t,y)$. At each step, we must calculate the derivatives. The expression for $y'(t_n)$ is exactly $f(t_n, y_n)$. The higher derivatives are constructed analytically using $\\sin(t_n)$, $\\cos(t_n)$, and $y_n$, without requiring further \"black-box\" calls to $f$. Thus, the cost per step is $1$ evaluation of $f$. For $N = T/h$ steps, the total cost is $C_{\\mathrm{T4}} = N$.\n\n### 3. Classical Runge-Kutta Method of Order 4 (RK4)\n\nThe RK4 method approximates the integral in the exact relation $y(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(\\tau, y(\\tau)) d\\tau$. It does so by using a weighted average of four slope estimates ($k_1, k_2, k_3, k_4$) within the interval $[t_n, t_{n+1}]$. This is a multi-stage method.\n\nThe stages for the classical RK4 method are defined as follows:\n1.  An initial slope estimate at the beginning of the interval:\n    $$k_1 = f(t_n, y_n)$$\n2.  A slope estimate at the midpoint of the interval, using $k_1$ to approximate $y$ at that point:\n    $$k_2 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_1\\right)$$\n3.  A refined slope estimate at the midpoint, now using $k_2$ to approximate $y$:\n    $$k_3 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_2\\right)$$\n4.  A slope estimate at the end of the interval, using $k_3$ to approximate $y$:\n    $$k_4 = f(t_n + h, y_n + h k_3)$$\n\nThe final update is a weighted average of these slopes, resembling Simpson's rule for numerical integration:\n$$y_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$\nEach step requires calculating $k_1, k_2, k_3,$ and $k_4$, each of which is one evaluation of the function $f(t,y)$. Therefore, the cost per step is $4$ evaluations. Over $N=T/h$ steps, the total cost is $C_{\\mathrm{RK4}} = 4N$.\n\n### 4. Error and Cost Summary\n\n- **Absolute Error**: For each method, the error is the absolute difference between the numerical solution at $t=T$ and the analytical solution: $E = |y_{\\text{numerical}}(T) - y_{\\text{analytical}}(T)|$.\n- **Computational Cost**: For a simulation with $N=T/h$ steps:\n    - $C_{\\mathrm{T4}} = N$\n    - $C_{\\mathrm{RK4}} = 4N$\n\nThe program below will implement these two methods, calculate the results for the specified test suite, and format the output as required.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the IVP y' = cos(t) + y using Taylor-4 and RK4 methods,\n    and calculates errors and costs for a given test suite.\n    \"\"\"\n    \n    # Problem parameters from the statement\n    T = 1.0\n    y0_values = [0.0, 1.0]\n    h_values = [1.0, 0.2, 0.1, 0.05, 0.0125]\n\n    # Generate the list of test cases (y0, h)\n    test_cases = [(y0, h) for y0 in y0_values for h in h_values]\n\n    def f(t, y):\n        \"\"\"The right-hand side of the ODE y'(t) = f(t, y).\"\"\"\n        return np.cos(t) + y\n\n    def analytical_solution(t, y0):\n        \"\"\"The exact analytical solution to the IVP.\"\"\"\n        # y(t) = 0.5*(sin(t) - cos(t)) + (y0 + 0.5)*exp(t)\n        return 0.5 * (np.sin(t) - np.cos(t)) + (y0 + 0.5) * np.exp(t)\n\n    def solve_taylor4(y0, T, h):\n        \"\"\"\n        Solves the ODE using the Taylor series method of order 4.\n        The derivatives are specific to y' = cos(t) + y.\n        \"\"\"\n        N = int(round(T / h))\n        t = 0.0\n        y = y0\n        for _ in range(N):\n            # y' = cos(t) + y\n            y_d1 = np.cos(t) + y\n            # y'' = -sin(t) + cos(t) + y\n            y_d2 = -np.sin(t) + np.cos(t) + y\n            # y''' = -sin(t) + y\n            y_d3 = -np.sin(t) + y\n            # y'''' = y\n            y_d4 = y\n            \n            # Update y using the Taylor-4 formula\n            y = y + h * y_d1 + (h**2 / 2.0) * y_d2 + (h**3 / 6.0) * y_d3 + (h**4 / 24.0) * y_d4\n            \n            t += h\n            \n        # Cost is N function evaluations (one evaluation of y' per step).\n        cost = N\n        return y, cost\n\n    def solve_rk4(f, y0, T, h):\n        \"\"\"Solves the ODE using the classical Runge-Kutta method of order 4.\"\"\"\n        N = int(round(T / h))\n        t = 0.0\n        y = y0\n        for _ in range(N):\n            k1 = f(t, y)\n            k2 = f(t + h / 2.0, y + h / 2.0 * k1)\n            k3 = f(t + h / 2.0, y + h / 2.0 * k2)\n            k4 = f(t + h, y + h * k3)\n            \n            y = y + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            t += h\n            \n        # Cost is 4 function evaluations per step.\n        cost = 4 * N\n        return y, cost\n\n    results = []\n    for y0, h in test_cases:\n        # Calculate the exact solution at the final time T\n        y_exact_T = analytical_solution(T, y0)\n        \n        # Solve with Taylor-4 method and compute error/cost\n        y_t4, cost_t4 = solve_taylor4(y0, T, h)\n        error_t4 = np.abs(y_t4 - y_exact_T)\n        \n        # Solve with RK4 method and compute error/cost\n        y_rk4, cost_rk4 = solve_rk4(f, y0, T, h)\n        error_rk4 = np.abs(y_rk4 - y_exact_T)\n        \n        results.append([error_t4, error_rk4, cost_t4, cost_rk4])\n\n    # Format the final output string as specified\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str.replace(\" \", \"\"))\n\nsolve()\n```", "id": "3282721"}, {"introduction": "The true power of numerical ODE solvers is revealed when we move from single equations to systems that model complex, interacting phenomena. This exercise takes you into the realm of mathematical biology to simulate the classic Lotka-Volterra competition model [@problem_id:3282760]. You will apply the robust Runge-Kutta method to a system of nonlinear ODEs, allowing you to explore how the dynamics of competing species can lead to different long-term outcomes, such as stable coexistence or the extinction of one species.", "problem": "Consider the Initial Value Problem (IVP) for a two-species competition model represented by a system of Ordinary Differential Equations (ODEs). Let $x(t)$ and $y(t)$ denote the nonnegative densities of two competing species at time $t$. The classical Lotka–Volterra competition model specifies the dynamics by\n$$\n\\frac{dx}{dt} = x\\left(r_1 - a_{11} x - a_{12} y\\right), \\quad\n\\frac{dy}{dt} = y\\left(r_2 - a_{21} x - a_{22} y\\right),\n$$\nwith initial conditions $x(0) = x_0$ and $y(0) = y_0$. Here $r_1$ and $r_2$ are intrinsic growth rates, and $a_{11}, a_{22}$ are intraspecific competition coefficients while $a_{12}, a_{21}$ are interspecific competition coefficients.\n\nStarting from the definition of the Initial Value Problem (IVP) for Ordinary Differential Equations (ODEs), implement a numerical solver for the above system using a fixed-step explicit fourth-order Runge–Kutta method. You must:\n- Treat the state vector $(x,y)$ as nonnegative for all $t \\ge 0$; if the numerical update yields a negative component due to discretization error, you must project it back to the nonnegative orthant by replacing it with $0$ immediately after each time step.\n- Integrate from $t=0$ to $t=T$ with a uniform time step $h$, where $T$ and $h$ are given below.\n- Classify the long-time outcome at $t=T$ using a threshold $\\varepsilon$ as follows:\n  - Output $2$ if both $x(T) > \\varepsilon$ and $y(T) > \\varepsilon$ (coexistence).\n  - Output $1$ if $x(T) > \\varepsilon$ and $y(T) \\le \\varepsilon$ (species $x$ persists, species $y$ goes extinct).\n  - Output $-1$ if $x(T) \\le \\varepsilon$ and $y(T) > \\varepsilon$ (species $y$ persists, species $x$ goes extinct).\n  - Output $0$ if both $x(T) \\le \\varepsilon$ and $y(T) \\le \\varepsilon$ (both go extinct).\n\nUse the following numerical parameters for all test cases:\n- Final time $T = 60$.\n- Time step $h = 0.01$.\n- Threshold $\\varepsilon = 10^{-8}$.\n\nThe test suite comprises five parameter sets $(r_1,r_2,a_{11},a_{12},a_{21},a_{22},x_0,y_0)$ that probe different dynamical regimes:\n1. A case expected to yield coexistence for moderate initial densities:\n   - $r_1 = 1.0$, $r_2 = 1.2$, $a_{11} = 1.0$, $a_{12} = 0.3$, $a_{21} = 0.5$, $a_{22} = 1.0$, $x_0 = 0.2$, $y_0 = 0.2$.\n2. A case where interspecific pressure on species $x$ is strong enough to exclude it:\n   - $r_1 = 1.0$, $r_2 = 1.0$, $a_{11} = 1.0$, $a_{12} = 1.4$, $a_{21} = 0.3$, $a_{22} = 1.0$, $x_0 = 0.6$, $y_0 = 0.6$.\n3. A case where interspecific pressure on species $y$ is strong enough to exclude it:\n   - $r_1 = 1.0$, $r_2 = 1.0$, $a_{11} = 1.0$, $a_{12} = 0.4$, $a_{21} = 1.3$, $a_{22} = 1.0$, $x_0 = 0.4$, $y_0 = 0.7$.\n4. A case with negative intrinsic growth rates for both species (both trend to extinction):\n   - $r_1 = -0.3$, $r_2 = -0.2$, $a_{11} = 1.0$, $a_{12} = 0.3$, $a_{21} = 0.5$, $a_{22} = 1.0$, $x_0 = 0.5$, $y_0 = 0.5$.\n5. A boundary case where one initial population is exactly zero:\n   - $r_1 = 1.0$, $r_2 = 1.2$, $a_{11} = 1.0$, $a_{12} = 0.3$, $a_{21} = 0.5$, $a_{22} = 1.0$, $x_0 = 0.3$, $y_0 = 0.0$.\n\nYour program should produce a single line of output containing the classification results for the five test cases as a comma-separated list enclosed in square brackets, for example $[c_1,c_2,c_3,c_4,c_5]$, where each $c_i$ is the integer classification code computed at $t=T$ for test case $i$.", "solution": "The problem presented is a valid initial value problem (IVP) in the field of numerical analysis for ordinary differential equations (ODEs). It is scientifically grounded in the established Lotka–Volterra competition model, is well-posed with all necessary parameters and conditions provided, and is objective and computationally feasible. We may therefore proceed with a solution.\n\nThe core of the problem is to determine the long-term outcome of a two-species competition, modeled by the following system of autonomous ODEs:\n$$\n\\begin{align*}\n\\frac{dx}{dt} &= x(t) \\left(r_1 - a_{11} x(t) - a_{12} y(t)\\right) \\\\\n\\frac{dy}{dt} &= y(t) \\left(r_2 - a_{21} x(t) - a_{22} y(t)\\right)\n\\end{align*}\n$$\nwhere $x(t)$ and $y(t)$ are the population densities of the two species at time $t$. The system is subject to the initial conditions $x(0) = x_0$ and $y(0) = y_0$. This set of equations and initial conditions constitutes the IVP.\n\nFor conciseness and computational implementation, we represent the state of the system using a vector $\\vec{u}(t) = \\begin{pmatrix} x(t) \\\\ y(t) \\end{pmatrix}$. The IVP can then be written in the compact form:\n$$\n\\frac{d\\vec{u}}{dt} = \\vec{F}(\\vec{u}(t)), \\quad \\vec{u}(0) = \\vec{u}_0 = \\begin{pmatrix} x_0 \\\\ y_0 \\end{pmatrix}\n$$\nwhere the function $\\vec{F}: \\mathbb{R}^2 \\to \\mathbb{R}^2$ is the right-hand side of the ODE system:\n$$\n\\vec{F}(\\vec{u}) = \\begin{pmatrix} x(r_1 - a_{11} x - a_{12} y) \\\\ y(r_2 - a_{21} x - a_{22} y) \\end{pmatrix}\n$$\nSince this nonlinear system does not generally admit a closed-form analytical solution, we must employ a numerical method to approximate the solution trajectory $\\vec{u}(t)$ over the interval $[0, T]$. The problem specifies the use of the explicit fourth-order Runge–Kutta (RK4) method with a fixed time step $h$.\n\nThe RK4 method iteratively computes an approximation $\\vec{u}_{n+1}$ to the true solution $\\vec{u}(t_{n+1})$ at time $t_{n+1} = (n+1)h$, given the approximation $\\vec{u}_n$ at time $t_n = nh$. For an autonomous system, the update rule is:\n$$\n\\vec{u}_{n+1} = \\vec{u}_n + \\frac{h}{6}(\\vec{k}_1 + 2\\vec{k}_2 + 2\\vec{k}_3 + \\vec{k}_4)\n$$\nThe four intermediate \"slopes\" $\\vec{k}_i$ are evaluations of the function $\\vec{F}$ at different points in the time step, forming a weighted average that achieves fourth-order accuracy:\n$$\n\\begin{align*}\n\\vec{k}_1 &= \\vec{F}(\\vec{u}_n) \\\\\n\\vec{k}_2 &= \\vec{F}(\\vec{u}_n + \\frac{h}{2}\\vec{k}_1) \\\\\n\\vec{k}_3 &= \\vec{F}(\\vec{u}_n + \\frac{h}{2}\\vec{k}_2) \\\\\n\\vec{k}_4 &= \\vec{F}(\\vec{u}_n + h\\vec{k}_3)\n\\end{align*}\n\nA critical feature of this biological model is that population densities cannot be negative. While the exact solution of the Lotka–Volterra equations with non-negative initial data remains non-negative, discretization errors in numerical methods can sometimes lead to small negative values. To enforce this physical constraint, the problem mandates a projection step. After each time step calculation, any negative component in the computed state vector $\\vec{u}_{n+1}$ must be set to $0$. If we let $\\vec{u}_{n+1}^{\\text{raw}}$ be the result from the RK4 formula, the projected state is:\n$$\n\\vec{u}_{n+1} = \\begin{pmatrix} x_{n+1} \\\\ y_{n+1} \\end{pmatrix} = \\begin{pmatrix} \\max(0, x_{n+1}^{\\text{raw}}) \\\\ \\max(0, y_{n+1}^{\\text{raw}}) \\end{pmatrix}\n$$\n\nThe overall algorithm to solve the problem is as follows:\n1.  For each of the five test cases, set the specific model parameters $(r_1, r_2, a_{11}, a_{12}, a_{21}, a_{22})$ and initial conditions $(x_0, y_0)$.\n2.  Initialize the state vector $\\vec{u}_0 = \\begin{pmatrix} x_0 \\\\ y_0 \\end{pmatrix}$.\n3.  Set the numerical parameters: final time $T = 60$, time step $h = 0.01$. The number of steps required is $N = T/h = 6000$.\n4.  Iterate from $n = 0$ to $N-1$:\n    a. Calculate the four RK4 stages $\\vec{k}_1, \\vec{k}_2, \\vec{k}_3, \\vec{k}_4$ using the current state $\\vec{u}_n$.\n    b. Compute the raw next state $\\vec{u}_{n+1}^{\\text{raw}}$ using the RK4 update formula.\n    c. Apply the non-negativity projection to obtain the final state for the step, $\\vec{u}_{n+1}$.\n5.  After $N$ steps, the final state is $\\vec{u}_N \\approx \\vec{u}(T) = \\begin{pmatrix} x(T) \\\\ y(T) \\end{pmatrix}$.\n6.  Classify the outcome based on the components of $\\vec{u}_N$ and the threshold $\\varepsilon = 10^{-8}$:\n    - If $x(T) > \\varepsilon$ and $y(T) > \\varepsilon$, the outcome is coexistence (code $2$).\n    - If $x(T) > \\varepsilon$ and $y(T) \\le \\varepsilon$, species $x$ persists (code $1$).\n    - If $x(T) \\le \\varepsilon$ and $y(T) > \\varepsilon$, species $y$ persists (code $-1$).\n    - If $x(T) \\le \\varepsilon$ and $y(T) \\le \\varepsilon$, both species go extinct (code $0$).\n\nThis procedure is then applied to each of the five distinct parameter sets to generate the final list of classification codes.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Lotka-Volterra competition model for five test cases\n    using the RK4 method and classifies the long-term outcome.\n    \"\"\"\n    # Numerical parameters for all test cases\n    T = 60.0\n    h = 0.01\n    epsilon = 1e-8\n\n    # The test suite comprises five parameter sets:\n    # (r1, r2, a11, a12, a21, a22, x0, y0)\n    test_cases = [\n        # 1. Expected coexistence\n        (1.0, 1.2, 1.0, 0.3, 0.5, 1.0, 0.2, 0.2),\n        # 2. Species x is excluded\n        (1.0, 1.0, 1.0, 1.4, 0.3, 1.0, 0.6, 0.6),\n        # 3. Species y is excluded\n        (1.0, 1.0, 1.0, 0.4, 1.3, 1.0, 0.4, 0.7),\n        # 4. Both species go extinct\n        (-0.3, -0.2, 1.0, 0.3, 0.5, 1.0, 0.5, 0.5),\n        # 5. One initial population is zero\n        (1.0, 1.2, 1.0, 0.3, 0.5, 1.0, 0.3, 0.0),\n    ]\n\n    def lotka_volterra_rhs(u, p):\n        \"\"\"\n        Computes the right-hand side of the Lotka-Volterra ODE system.\n        \n        Args:\n            u (np.ndarray): State vector [x, y].\n            p (tuple): Model parameters (r1, r2, a11, a12, a21, a22).\n        \n        Returns:\n            np.ndarray: The derivatives [dx/dt, dy/dt].\n        \"\"\"\n        x, y = u\n        r1, r2, a11, a12, a21, a22 = p\n        dxdt = x * (r1 - a11 * x - a12 * y)\n        dydt = y * (r2 - a21 * x - a22 * y)\n        return np.array([dxdt, dydt])\n\n    results = []\n    num_steps = int(T / h)\n\n    for case in test_cases:\n        r1, r2, a11, a12, a21, a22, x0, y0 = case\n        params = (r1, r2, a11, a12, a21, a22)\n        \n        u = np.array([x0, y0], dtype=np.float64)\n\n        # Time-stepping loop using RK4\n        for _ in range(num_steps):\n            k1 = lotka_volterra_rhs(u, params)\n            k2 = lotka_volterra_rhs(u + 0.5 * h * k1, params)\n            k3 = lotka_volterra_rhs(u + 0.5 * h * k2, params)\n            k4 = lotka_volterra_rhs(u + h * k3, params)\n            \n            u_raw = u + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            # Project to non-negative orthant\n            u = np.maximum(0.0, u_raw)\n        \n        xT, yT = u\n        \n        # Classify the outcome at t=T\n        classification_code = 0\n        if xT > epsilon and yT > epsilon:\n            classification_code = 2  # Coexistence\n        elif xT > epsilon and yT = epsilon:\n            classification_code = 1  # Species x persists\n        elif xT = epsilon and yT > epsilon:\n            classification_code = -1 # Species y persists\n        else: # xT = epsilon and yT = epsilon\n            classification_code = 0  # Both extinct\n            \n        results.append(classification_code)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3282760"}, {"introduction": "Many real-world physical systems involve more than just smooth evolution; they are punctuated by discrete events that cause abrupt changes in the state. This advanced practice guides you through building a sophisticated solver for a bouncing ball, a classic example of such a hybrid system [@problem_id:3282603]. You will integrate an adaptive Runge-Kutta method with an event-finding algorithm to precisely locate impact times and model the resulting change in velocity, a crucial skill for simulating mechanical, electrical, and biological systems with discontinuous dynamics.", "problem": "You will design and implement a complete numerical Initial Value Problem (IVP) solver for a one-dimensional bouncing ball with event detection and restart at each impact. The goal is to accurately detect the event time at which the ball hits the ground, enforce a coefficient of restitution at impact, and then restart integration with the post-impact velocity. The scenario is governed by Newtonian mechanics and formulated as an Ordinary Differential Equation (ODE) IVP. You must derive your approach from fundamental principles and then implement it in a correct and robust program.\n\nThe physical setup is as follows. Consider a point-mass ball moving vertically under gravity with linear air drag. Let $y(t)$ be the vertical position and $v(t)$ be the vertical velocity. The governing force balance is Newton’s second law: $m \\frac{\\mathrm{d}v}{\\mathrm{d}t} = \\sum F$, with gravitational force $-m g$ and linear drag force $-b v$. Define the drag-per-unit-mass parameter $\\gamma = b/m$. The continuous-time model is the first-order system\n$$\n\\frac{\\mathrm{d}y}{\\mathrm{d}t} = v,\\quad\n\\frac{\\mathrm{d}v}{\\mathrm{d}t} = -g - \\gamma v,\n$$\nwith initial conditions $y(0)=y_0$ and $v(0)=v_0$. A ground impact event occurs whenever $y(t)=0$ with a downward crossing. At an impact time $t_e$ with pre-impact velocity $v(t_e^-)$, the post-impact velocity is given by the Newtonian restitution law $v(t_e^+) = - r \\, v(t_e^-)$, with coefficient of restitution $r \\in [0,1]$. The position remains continuous $y(t_e^+)=0$.\n\nYour program must:\n- Integrate the system from $t=0$ forward, using a fixed-derivation integrator design rooted in standard explicit Runge–Kutta methods. Use a classical fourth-order Runge–Kutta method (RK4) as the basic time-marching scheme. Control local truncation error using step doubling: compare one step of size $h$ to two steps of size $h/2$ to obtain an error estimate. Accept or reject steps based on a user-specified absolute tolerance and relative tolerance, and adapt $h$ accordingly to maintain stability and accuracy.\n- Detect ground-impact events by bracketing sign changes of $y(t)$ across accepted steps. When an event is bracketed, refine the event time $t_e$ with a root-finding procedure on $y(t)$ using bisection on time. Each evaluation of $y(t)$ during refinement must be computed by numerically propagating the ODE from the left bracket to the query time using RK4 substeps. The refinement should stop when the time bracket width is below a small absolute threshold and the height magnitude is below a small absolute threshold.\n- Apply the restitution law at $t_e$ by resetting to $y(t_e)=0$ and $v(t_e) = - r \\, v(t_e^-)$, then restart the IVP from this event state, continuing integration. Count the number of impacts. If at some event the post-impact speed is effectively zero, you should stop further integration as no more impacts can occur.\n- Terminate integration when either a specified number of impacts has occurred or a specified maximum time has been reached, whichever comes first.\n\nAll computations must be in coherent SI units: $y$ in meters, $v$ in meters per second, $g$ in meters per second squared, $\\gamma$ in inverse seconds, and time in seconds. Angles are not used. Your program must report the requested output in seconds rounded to six decimals.\n\nYou must propose and use concrete numerical tolerances:\n- Absolute tolerance $\\mathrm{atol} = 10^{-12}$ (in state units).\n- Relative tolerance $\\mathrm{rtol} = 10^{-9}$ (dimensionless).\n- Event time refinement tolerance $\\delta t = 10^{-10}$ seconds and event height tolerance $\\delta y = 10^{-12}$ meters.\nThese tunings must be used for all test cases.\n\nTest suite specification. For each test case below, run your solver until the $K$-th impact (if it occurs before the maximum time $T_{\\max}$), and return the time $t_K$ of that $K$-th impact in seconds, rounded to six decimals.\n\n- Test case A (happy path, no drag):\n  - Parameters: $y_0 = 10.0$ m, $v_0 = 0.0$ m/s, $g = 9.81$ m/s^2, $\\gamma = 0.0$ s⁻¹, $r = 0.8$, $K = 3$, $T_{\\max} = 30.0$ s.\n- Test case B (with drag, upward initial velocity):\n  - Parameters: $y_0 = 20.0$ m, $v_0 = 5.0$ m/s, $g = 9.81$ m/s^2, $\\gamma = 0.1$ s⁻¹, $r = 0.9$, $K = 2$, $T_{\\max} = 40.0$ s.\n- Test case C (edge case, start at ground but rising):\n  - Parameters: $y_0 = 0.0$ m, $v_0 = 5.0$ m/s, $g = 9.81$ m/s^2, $\\gamma = 0.0$ s⁻¹, $r = 0.6$, $K = 2$, $T_{\\max} = 20.0$ s.\n- Test case D (edge case, completely inelastic impact):\n  - Parameters: $y_0 = 1.0$ m, $v_0 = 0.0$ m/s, $g = 9.81$ m/s^2, $\\gamma = 0.0$ s⁻¹, $r = 0.0$, $K = 1$, $T_{\\max} = 10.0$ s.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC,resultD]\"). Specifically, for the four test cases A, B, C, and D in that order, output $[t_3^{(A)}, t_2^{(B)}, t_2^{(C)}, t_1^{(D)}]$ as seconds rounded to six decimals, with no additional text.", "solution": "We construct the solver from physical principles and numerical analysis fundamentals. The physical base is Newton’s second law $m \\frac{\\mathrm{d}v}{\\mathrm{d}t} = \\sum F$. For vertical motion with gravity and linear drag, the forces are $-m g$ and $- b v$, hence $m \\frac{\\mathrm{d}v}{\\mathrm{d}t} = -m g - b v$. Introducing $\\gamma = b/m$ yields $\\frac{\\mathrm{d}v}{\\mathrm{d}t} = -g - \\gamma v$. The kinematic identity $\\frac{\\mathrm{d}y}{\\mathrm{d}t} = v$ closes the first-order system\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\n\\begin{bmatrix}\ny \\\\ v\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nv \\\\\n- g - \\gamma v\n\\end{bmatrix},\n$$\nwith initial state $\\begin{bmatrix} y(0) \\\\ v(0) \\end{bmatrix} = \\begin{bmatrix} y_0 \\\\ v_0 \\end{bmatrix}$.\n\nAn event occurs when the ground $y=0$ is reached while descending: $y(t_e) = 0$ with $v(t_e^-)  0$. Impact is modeled as instantaneous with position continuity $y(t_e^+) = 0$ and velocity jump $v(t_e^+) = - r \\, v(t_e^-)$. For $r \\in [0,1]$, energy decreases on impact, and for $r=0$ the motion stops at the first impact.\n\nWe must design a solver that integrates the Initial Value Problem (IVP) and detects the event times accurately. We use the explicit fourth-order Runge–Kutta method (RK4), which is a well-tested integrator for smooth right-hand sides:\n$$\n\\mathbf{k}_1 = f(t_n,\\mathbf{y}_n),\\;\n\\mathbf{k}_2 = f\\!\\left(t_n+\\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{h}{2}\\mathbf{k}_1\\right),\\;\n\\mathbf{k}_3 = f\\!\\left(t_n+\\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{h}{2}\\mathbf{k}_2\\right),\\;\n\\mathbf{k}_4 = f\\!\\left(t_n+h, \\mathbf{y}_n + h \\mathbf{k}_3\\right),\n$$\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\tfrac{h}{6}\\left(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4\\right).\n$$\nTo control local error without relying on pre-tabulated embedded pairs, we apply step doubling: compute $\\mathbf{y}^{(1)}$ using one RK4 step of size $h$, and $\\mathbf{y}^{(2)}$ using two RK4 steps of size $h/2$. The difference $\\delta = \\|\\mathbf{y}^{(2)} - \\mathbf{y}^{(1)}\\|_{\\infty}$ estimates the local truncation error. We accept the two-half-step solution if $\\delta \\le \\mathrm{atol} + \\mathrm{rtol}\\,\\|\\mathbf{y}^{(2)}\\|_{\\infty}$; otherwise, we reject and reduce $h$. Upon acceptance, we may modestly increase $h$ to enhance efficiency while remaining within tolerances.\n\nEvent detection is handled as follows. After each accepted step from $(t_n,\\mathbf{y}_n)$ to $(t_{n+1},\\mathbf{y}_{n+1})$, we check the sign of the height component $y$. If $y_n  0$ and $y_{n+1} \\le 0$, an event is bracketed in $[t_n,t_{n+1}]$. We then refine the event time $t_e$ by bisection on time:\n- Maintain a left bracket $(t_L,\\mathbf{y}_L)$ with $y_L0$ and a right bracket $(t_R,\\mathbf{y}_R)$ with $y_R \\le 0$.\n- At each refinement iteration, choose $t_M=(t_L+t_R)/2$ and compute $\\mathbf{y}_M$ by numerically propagating from $(t_L,\\mathbf{y}_L)$ to $t_M$ using RK4 with a fixed small number of substeps to ensure accuracy. If $y_M0$, update the left bracket to $(t_M,\\mathbf{y}_M)$; otherwise, update the right bracket to $(t_M,\\mathbf{y}_M)$.\n- Terminate when $t_R-t_L \\le \\delta t$ and $|y_M| \\le \\delta y$. The refined event time is $t_e \\approx t_R$ with pre-impact state $\\mathbf{y}(t_e^-)\\approx \\mathbf{y}_R$.\nAt the event, we set $y(t_e)=0$ exactly and compute the post-impact velocity $v(t_e^+)=-r\\,v(t_e^-)$. Restart the IVP from $(t_e,[0, v(t_e^+)])$. If the post-impact speed is extremely small, say $|v(t_e^+)| \\le 10^{-12}$, we stop further integration because no future impacts will occur.\n\nCorrectness and consistency checks derive from fundamental solutions in special cases. In the no-drag case $\\gamma=0$, between impacts the motion is ballistic with $\\frac{\\mathrm{d}^2 y}{\\mathrm{d}t^2} = -g$. If $y_00$ and $v_0 \\ge 0$, the first impact time is\n$$\nt_1 = \\frac{v_0 + \\sqrt{v_0^2 + 2 g y_0}}{g}.\n$$\nLet $v_1^- = -\\sqrt{v_0^2 + 2 g y_0}$ be the pre-impact velocity, so $v_1^+ = r \\sqrt{v_0^2 + 2 g y_0}$. The next flight has symmetric rise and fall, giving an inter-impact time increment $\\Delta t = 2 v_1^+/g$. Further impacts form a geometric sequence in time increments if $\\gamma=0$, with multipliers $r, r^2, \\dots$. Our numerical method must reproduce these values within tolerances. For example, in the special case $y_0=0$ and $v_00$ with $\\gamma=0$, the first impact time is $t_1 = 2 v_0/g$, and the second is $t_2 = t_1 + 2 r v_0/g$.\n\nIn the presence of linear drag $\\gamma0$, the solution between impacts is no longer symmetric, and closed-form inter-impact times are not simple in terms of elementary functions for general initial data. The event-driven numerical method above remains applicable and accurate because the right-hand side is smooth, and the bisection refinement uses the flow map defined by the ODE itself, ensuring consistent root finding for $y(t)=0$.\n\nAlgorithmic design summary:\n- Use RK4 with step doubling for adaptive control with $\\mathrm{atol}=10^{-12}$ and $\\mathrm{rtol}=10^{-9}$.\n- Detect events via sign change of $y$ over accepted steps.\n- Refine event times using time bisection with numerical propagation and tolerances $\\delta t=10^{-10}$ s and $\\delta y=10^{-12}$ m.\n- Apply $v^+ = - r v^-$ at each event, set $y=0$ at the event, and restart.\n- Terminate upon reaching the $K$-th impact or exceeding $T_{\\max}$.\n\nThe final outputs are the event times required by the test suite, in seconds rounded to six decimals, aggregated in the specified order and format. This design directly reflects the Initial Value Problem (IVP) formulation for Ordinary Differential Equations (ODEs), respects physical laws, and ensures numerical robustness through principled error control and root-finding.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dynamics(t, state, g, gamma):\n    # state = [y, v]\n    y, v = state\n    dy = v\n    dv = -g - gamma * v\n    return np.array([dy, dv], dtype=float)\n\ndef rk4_step(f, t, y, h, args):\n    k1 = f(t, y, *args)\n    k2 = f(t + 0.5*h, y + 0.5*h*k1, *args)\n    k3 = f(t + 0.5*h, y + 0.5*h*k2, *args)\n    k4 = f(t + h, y + h*k3, *args)\n    return y + (h/6.0)*(k1 + 2*k2 + 2*k3 + k4)\n\ndef rk4_step_doubling(f, t, y, h, args):\n    # One full step\n    y1 = rk4_step(f, t, y, h, args)\n    # Two half steps\n    y_half = rk4_step(f, t, y, 0.5*h, args)\n    y2 = rk4_step(f, t + 0.5*h, y_half, 0.5*h, args)\n    # Error estimate\n    err = np.max(np.abs(y2 - y1))\n    return y2, err\n\ndef integrate_segment(f, t0, y0, t1, args, nsub=12):\n    # Propagate from (t0, y0) to t1 using nsub RK4 substeps\n    t = t0\n    y = y0.copy()\n    dt = t1 - t0\n    if dt == 0.0:\n        return y\n    h = dt / float(nsub)\n    for _ in range(nsub):\n        y = rk4_step(f, t, y, h, args)\n        t += h\n    return y\n\ndef refine_event_bisection(f, tL, yL, tR, yR, args, tol_t, tol_y):\n    # Assumes yL[0]  0 and yR[0] = 0\n    left_t = tL\n    left_y = yL.copy()\n    right_t = tR\n    right_y = yR.copy()\n    # Use bisection with numerical propagation from left\n    while (right_t - left_t)  tol_t:\n        mid_t = 0.5*(left_t + right_t)\n        # Propagate from left to mid\n        mid_y = integrate_segment(f, left_t, left_y, mid_t, args, nsub=12)\n        ymid = mid_y[0]\n        if abs(ymid) = tol_y:\n            # Close enough in height; choose mid as right bracket\n            right_t = mid_t\n            right_y = mid_y\n            break\n        if ymid  0.0:\n            left_t = mid_t\n            left_y = mid_y\n        else:\n            right_t = mid_t\n            right_y = mid_y\n    # Ensure right_y corresponds to y = 0 (or near zero)\n    return right_t, right_y\n\ndef simulate_bouncing_ball(y0, v0, g, gamma, r, K, t_max,\n                           atol=1e-12, rtol=1e-9,\n                           event_tol_t=1e-10, event_tol_y=1e-12):\n    # Initial state\n    t = 0.0\n    y = np.array([y0, v0], dtype=float)\n    impacts = 0\n    impact_times = []\n\n    # Initial step size guess based on time scales\n    # Use a conservative initial step\n    h = 0.01\n    h_min = 1e-8\n    h_max = 0.2\n\n    # Helper for norm\n    def norm_inf(vec):\n        return float(np.max(np.abs(vec)))\n\n    # If starting exactly at ground with negative velocity, handle as immediate impact by convention\n    # Here we avoid counting an immediate event at t=0 unless descending from y0\n    # So we proceed to integrate.\n\n    # Main integration loop\n    prev_t = t\n    prev_y = y.copy()\n\n    while t  t_max and impacts  K:\n        # Adjust step not to overrun t_max\n        h = min(h, t_max - t)\n        if h  h_min:\n            h = h_min\n\n        # Take a trial step with error estimation\n        y_new, err = rk4_step_doubling(dynamics, t, y, h, (g, gamma))\n        ynew_val = y_new[0]\n        tol = atol + rtol * max(norm_inf(y_new), 1.0)\n\n        if err = tol or h = h_min*1.01:\n            # Accept step\n            t_new = t + h\n            # Event detection: look for crossing from y0 to y=0\n            y_old_val = y[0]\n            if y_old_val  0.0 and ynew_val = 0.0:\n                # Refine event time within [t, t_new]\n                # Use the more accurate accepted step endpoints\n                # Ensure right endpoint state yR corresponds to y = 0 by integrating directly to t_new\n                yR = y_new.copy()\n                t_e, state_e_minus = refine_event_bisection(\n                    dynamics, t, y, t_new, yR, (g, gamma), event_tol_t, event_tol_y\n                )\n                # Compute post-impact state\n                v_minus = state_e_minus[1]\n                v_plus = -r * v_minus\n                # Register impact\n                impacts += 1\n                impact_times.append(t_e)\n                # Restart at event\n                t = t_e\n                y = np.array([0.0, v_plus], dtype=float)\n                prev_t = t\n                prev_y = y.copy()\n                # If the bounce has essentially zero speed, stop\n                if abs(v_plus) = 1e-12:\n                    break\n                # Reduce step after event to be safe\n                h = max(h_min*10, min(h*0.5, h_max))\n                continue\n            else:\n                # No event, advance\n                prev_t = t\n                prev_y = y.copy()\n                t = t_new\n                y = y_new\n                # Attempt to increase step slightly if error is small\n                if err  0.1 * tol:\n                    h = min(h * 1.5, h_max)\n                else:\n                    # Keep h or slightly reduce\n                    h = min(h, h_max)\n        else:\n            # Reject step and decrease h\n            # Scale h down; use a safety factor\n            factor = 0.5\n            h = max(h * factor, h_min)\n\n    # If impacts  K by t_max, we still return whatever impacts found; caller expects K-th impact time.\n    # To stay consistent with the problem, assume parameters ensure hits before t_max.\n    # Return the time of the K-th impact if available; otherwise, return t_max.\n    if len(impact_times) = K:\n        return impact_times[K-1]\n    else:\n        # In case the K-th impact did not occur, return t_max (still consistent numeric type)\n        return t_max\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (y0, v0, g, gamma, r, K, T_max)\n    test_cases = [\n        (10.0, 0.0, 9.81, 0.0, 0.8, 3, 30.0),  # A\n        (20.0, 5.0, 9.81, 0.1, 0.9, 2, 40.0),  # B\n        (0.0, 5.0, 9.81, 0.0, 0.6, 2, 20.0),   # C\n        (1.0, 0.0, 9.81, 0.0, 0.0, 1, 10.0),   # D\n    ]\n\n    results = []\n    for case in test_cases:\n        y0, v0, g, gamma, r, K, tmax = case\n        t_k = simulate_bouncing_ball(y0, v0, g, gamma, r, K, tmax)\n        results.append(t_k)\n\n    # Final print statement in the exact required format with six decimals.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3282603"}]}