{"hands_on_practices": [{"introduction": "The first step in applying Chebyshev interpolation is learning how to compute the node locations. This exercise provides a practical scenario where optimal sensor placement is key to creating a reliable model. By calculating the Chebyshev nodes for a quadratic polynomial on a general interval, you will master the fundamental formula and the simple affine transformation required to move from the standard interval $[-1, 1]$ to any interval $[a, b]$ encountered in practice [@problem_id:2187273].", "problem": "A team of structural engineers is tasked with monitoring the deflection of a new 10-meter-long composite beam under a static load. They plan to model the deflection profile, $d(x)$, where $x$ is the position along the beam from $x=0$ to $x=10$ meters, using a quadratic polynomial. Due to budget constraints, they can only place three deflection sensors. To construct the most robust polynomial model, which minimizes the maximum possible interpolation error for any well-behaved deflection function, they decide to place the sensors at the specific locations known as Chebyshev nodes.\n\nCalculate the three optimal positions for the sensors along the beam, corresponding to the Chebyshev nodes for quadratic interpolation over the interval $[0, 10]$. Express your answer as a row matrix containing the three positions in meters, ordered from smallest to largest. Provide the exact numerical values.", "solution": "We seek the three Chebyshev nodes for quadratic (degree 2) interpolation on the interval $[0,10]$. For $N=n+1=3$ interpolation nodes, the Chebyshev nodes of the first kind on $[-1,1]$ are\n$$\nt_{k}=\\cos\\left(\\frac{(2k-1)\\pi}{2N}\\right), \\quad k=1,2,3.\n$$\nThese nodes minimize the maximum interpolation error among all choices of $N$ nodes on $[-1,1]$. To map them to the interval $[a,b]=[0,10]$, use the affine transformation\n$$\nx=\\frac{a+b}{2}+\\frac{b-a}{2}\\,t=\\frac{0+10}{2}+\\frac{10-0}{2}\\,t=5+5t.\n$$\nCompute the $t_{k}$ values:\n- For $k=1$: $t_{1}=\\cos\\left(\\frac{\\pi}{6}\\right)=\\frac{\\sqrt{3}}{2}$.\n- For $k=2$: $t_{2}=\\cos\\left(\\frac{3\\pi}{6}\\right)=\\cos\\left(\\frac{\\pi}{2}\\right)=0$.\n- For $k=3$: $t_{3}=\\cos\\left(\\frac{5\\pi}{6}\\right)=-\\frac{\\sqrt{3}}{2}$.\n\nMap each to $[0,10]$ via $x=5+5t$:\n$$\nx_{1}=5+5\\cdot\\frac{\\sqrt{3}}{2}=5+\\frac{5\\sqrt{3}}{2},\\quad\nx_{2}=5+5\\cdot 0=5,\\quad\nx_{3}=5+5\\cdot\\left(-\\frac{\\sqrt{3}}{2}\\right)=5-\\frac{5\\sqrt{3}}{2}.\n$$\nOrdering from smallest to largest gives:\n$$\n5-\\frac{5\\sqrt{3}}{2},\\quad 5,\\quad 5+\\frac{5\\sqrt{3}}{2}.\n$$\nThese are the exact positions in meters for the three sensors.", "answer": "$$\\boxed{\\begin{pmatrix}5-\\frac{5\\sqrt{3}}{2} & 5 & 5+\\frac{5\\sqrt{3}}{2}\\end{pmatrix}}$$", "id": "2187273"}, {"introduction": "Beyond simply finding the nodes, it is crucial to understand the properties of the interpolating polynomial they define. This practice moves from calculation to analysis, exploring a case where the resulting polynomial is surprisingly simple and elegant. Working through this problem reveals that Chebyshev interpolation is not just a matter of connecting dots; it is deeply connected to the concept of finding a \"best\" polynomial approximation, providing a result that is both accurate and efficient [@problem_id:2187288].", "problem": "In numerical analysis, interpolation using Chebyshev nodes is a superior alternative to using equally spaced points, especially for avoiding Runge's phenomenon. This method chooses interpolation points that are the roots of Chebyshev polynomials, which are clustered near the endpoints of the interval.\n\nConsider the function $f(x) = x^3$ over the interval $[-1, 1]$. Your task is to find the unique polynomial of degree at most 2, let's call it $P_2(x)$, that interpolates $f(x)$ at the three Chebyshev nodes on this interval. These nodes are defined as the roots of the degree-3 Chebyshev polynomial of the first kind, $T_3(x)$.\n\nExpress your answer for $P_2(x)$ as a simplified polynomial in terms of $x$.", "solution": "We are given $f(x)=x^{3}$ on $[-1,1]$ and must find the unique polynomial $P_{2}(x)$ of degree at most $2$ that interpolates $f$ at the three Chebyshev nodes on $[-1,1]$, defined as the roots of $T_{3}(x)$, the degree-$3$ Chebyshev polynomial of the first kind.\n\nUse the identity $T_{3}(x)=\\cos\\!\\big(3\\arccos x\\big)=4x^{3}-3x$. The roots of $T_{3}$ are the three Chebyshev nodes:\n$$\nT_{3}(x)=4x^{3}-3x=x\\big(4x^{2}-3\\big)=0\n\\quad\\Longrightarrow\\quad\nx\\in\\left\\{0,\\;\\pm\\frac{\\sqrt{3}}{2}\\right\\}.\n$$\nLet $P_{2}(x)=A x^{2}+B x+C$. The interpolation conditions are $P_{2}(\\xi)=\\xi^{3}$ at each node $\\xi\\in\\left\\{0,\\pm\\frac{\\sqrt{3}}{2}\\right\\}$.\n\n1) At $x=0$:\n$$\nP_{2}(0)=C=0 \\quad\\Longrightarrow\\quad C=0.\n$$\n\n2) Let $a=\\frac{\\sqrt{3}}{2}$. At $x=a$ and $x=-a$:\n$$\nP_{2}(a)=A a^{2}+B a=a^{3},\\qquad P_{2}(-a)=A a^{2}-B a=-a^{3}.\n$$\nAdding these two equations eliminates $B$:\n$$\n\\big(A a^{2}+B a\\big)+\\big(A a^{2}-B a\\big)=a^{3}+(-a^{3})\n\\;\\Longrightarrow\\;\n2A a^{2}=0\n\\;\\Longrightarrow\\;\nA=0\n\\quad(\\text{since }a\\neq 0).\n$$\nSubstitute $A=0$ into $A a^{2}+B a=a^{3}$ to solve for $B$:\n$$\nB a=a^{3}\\;\\Longrightarrow\\;B=a^{2}.\n$$\nWith $a=\\frac{\\sqrt{3}}{2}$, we have\n$$\na^{2}=\\left(\\frac{\\sqrt{3}}{2}\\right)^{2}=\\frac{3}{4}.\n$$\nTherefore,\n$$\nP_{2}(x)=B x=\\frac{3}{4}\\,x.\n$$\nA quick check: $P_{2}(0)=0=f(0)$, and $P_{2}(\\pm a)=\\frac{3}{4}(\\pm a)=\\pm a\\cdot\\frac{3}{4}=\\pm a^{3}=f(\\pm a)$, so the interpolation conditions are satisfied at all three Chebyshev nodes.\n\nHence, the unique interpolating polynomial of degree at most $2$ is $P_{2}(x)=\\frac{3}{4}x$.", "answer": "$$\\boxed{\\frac{3}{4}x}$$", "id": "2187288"}, {"introduction": "Theoretical claims of superiority are best understood through direct demonstration. This hands-on coding exercise brings the abstract benefits of Chebyshev nodes to life by tackling the infamous Runge phenomenon. You will write a program to compare polynomial interpolation using equispaced nodes against Chebyshev nodes, witnessing firsthand the failure of the former and the success of the latter. This practice solidifies why the choice of interpolation points is a cornerstone of reliable numerical approximation [@problem_id:3212557].", "problem": "You are to investigate the Runge phenomenon for polynomial interpolation of the function $f(x)=\\dfrac{1}{1+25x^2}$ on the interval $[-1,1]$ by comparing two node choices: equispaced nodes and Chebyshev–Lobatto nodes. Your implementation must be a complete, runnable program that carries out the computations numerically and reports quantitative metrics that enable a clear comparison of the two node choices. All angles must be interpreted in radians.\n\nUse only foundational definitions and well-tested facts as your starting point:\n- The interpolation problem is: given nodes $\\{x_j\\}_{j=0}^n$ in $[-1,1]$ and data values $y_j=f(x_j)$, construct the unique polynomial $p_n$ of degree at most $n$ such that $p_n(x_j)=y_j$ for all $j$.\n- The Chebyshev polynomials of the first kind $\\{T_k\\}_{k\\ge 0}$ are defined by $T_k(\\cos\\theta)=\\cos(k\\theta)$ for $\\theta\\in\\mathbb{R}$, and the Chebyshev–Lobatto nodes are the extrema of $T_n$, namely $x_k=\\cos\\left(\\dfrac{k\\pi}{n}\\right)$ for $k=0,1,\\dots,n$, with $\\pi$ measured in radians.\n- The Runge phenomenon refers to the large endpoint oscillations that may occur when interpolating analytic functions with high-degree polynomials at equispaced nodes on $[-1,1]$.\n\nYour task is to:\n1. For each node family and each degree $n$, construct the interpolating polynomial $p_n$ without using any pre-existing black-box interpolation routines. You may use any mathematically equivalent and numerically stable formulation consistent with the definition of polynomial interpolation (for example, a barycentric realization of Lagrange interpolation, or a Newton form constructed from divided differences). Ensure numerical stability.\n2. Approximate the uniform error $\\| f-p_n\\|_{\\infty}$ on $[-1,1]$ by sampling $p_n$ and $f$ on a uniform grid of $M$ points in $[-1,1]$. Use $M=20001$.\n3. Quantify endpoint behavior using two measures on the union of endpoint windows $[-1,-1+w]\\cup[1-w,1]$ with $w=0.1$:\n   - The endpoint error amplitude $E_{\\mathrm{end}}=\\max_{x\\in[-1,-1+w]\\cup[1-w,1]} |f(x)-p_n(x)|$.\n   - An endpoint oscillation count defined as the number of strict sign changes of a discrete derivative of $p_n$ on the sampled grid restricted to $[-1,-1+w]\\cup[1-w,1]$. Compute the derivative via a centered finite-difference on the uniform grid and threshold small magnitudes by declaring values with absolute value $\\le \\tau$ as zero, where $\\tau=10^{-8}$. A strict sign change is counted whenever two consecutive nonzero derivative samples have opposite signs. Zeros should be ignored (do not count transitions involving zero; compress runs of zeros by carrying forward the last nonzero sign when determining changes).\n4. Compare equispaced nodes and Chebyshev–Lobatto nodes for each $n$ using the above metrics.\n\nTest suite and parameters:\n- Use degrees $n\\in\\{5,10,20\\}$.\n- For each $n$, use both node families:\n  - Equispaced nodes: $x_j=-1+\\dfrac{2j}{n}$ for $j=0,1,\\dots,n$.\n  - Chebyshev–Lobatto nodes: $x_k=\\cos\\left(\\dfrac{k\\pi}{n}\\right)$ for $k=0,1,\\dots,n$, with $\\pi$ in radians.\n\nRequired outputs per degree $n$:\n- For equispaced nodes: three values in this order $(\\| f-p_n\\|_{\\infty}, E_{\\mathrm{end}}, \\text{oscillation count})$.\n- For Chebyshev–Lobatto nodes: three values in this order $(\\| f-p_n\\|_{\\infty}, E_{\\mathrm{end}}, \\text{oscillation count})$.\n- Thus, for each $n$, report six values. For all three values of $n$, report a total of $18$ values.\n\nFinal output format:\n- Your program must produce a single line of output containing all $18$ results as a comma-separated list enclosed in square brackets, ordered by $n=5$, then $n=10$, then $n=20$, and within each $n$ the equispaced triplet followed by the Chebyshev–Lobatto triplet. For example, your output should look like\n  $[a_1,a_2,a_3,a_4,a_5,a_6,\\ a_7,a_8,a_9,a_{10},a_{11},a_{12},\\ a_{13},a_{14},a_{15},a_{16},a_{17},a_{18}]$,\n  where all $a_i$ are numbers in the specified order.\n- Express all floating-point outputs rounded to $8$ decimal places; oscillation counts must be integers.\n\nAngle unit specification:\n- Wherever the cosine function is used to define nodes, the argument must be in radians.\n\nYour program must be fully self-contained, require no user input, and rely only on the Python standard library and the specified numerical library. The only permitted numerical library is a standard numerical array library. The output must be reproducible under the given specifications.", "solution": "We begin with the definition of polynomial interpolation. For nodes $\\{x_j\\}_{j=0}^n\\subset[-1,1]$ and values $y_j=f(x_j)$, there exists a unique polynomial $p_n\\in\\mathbb{P}_n$ with $p_n(x_j)=y_j$ for all $j$. Any representation consistent with this definition is acceptable. From a numerical methods perspective, a robust approach uses the barycentric Lagrange formulation, which realizes the same interpolant while improving numerical stability compared to the naive Lagrange formula.\n\nFoundational facts used:\n1. Interpolation error identity: For $f\\in C^{n+1}([-1,1])$, the pointwise error can be expressed as\n   $$ f(x)-p_n(x)=\\frac{f^{(n+1)}(\\xi_x)}{(n+1)!}\\prod_{j=0}^n (x-x_j), $$\n   for some $\\xi_x\\in(-1,1)$ depending on $x$. This identity shows that the node placement $\\{x_j\\}$ shapes the factor $\\prod_{j=0}^n(x-x_j)$ and hence the size and distribution of the error.\n2. Chebyshev polynomials of the first kind $\\{T_k\\}$ satisfy $T_k(\\cos\\theta)=\\cos(k\\theta)$ for $\\theta\\in\\mathbb{R}$. The extrema of $T_n$ occur at $x_k=\\cos\\left(\\frac{k\\pi}{n}\\right)$, $k=0,\\dots,n$, which are the Chebyshev–Lobatto nodes. These nodes cluster near the endpoints and are known to tame the magnitude of $\\prod_{j=0}^n(x-x_j)$ on $[-1,1]$ relative to equispaced nodes.\n3. The Runge phenomenon arises prominently for equispaced nodes as $n$ grows, amplifying oscillations near endpoints even for analytic $f$. Chebyshev–Lobatto nodes mitigate this by distributing nodes according to the density induced by the map $x=\\cos\\theta$ with uniformly spaced $\\theta$.\n\nAlgorithmic design:\n- Function and grid:\n  - Define $f(x)=\\dfrac{1}{1+25x^2}$ on $[-1,1]$.\n  - Use a uniform grid $\\{x^{\\mathrm{eval}}_i\\}_{i=0}^{M-1}$ with $M=20001$ points spanning $[-1,1]$ to approximate $\\| f-p_n\\|_{\\infty}$ by sampling.\n- Node generation:\n  - Equispaced nodes: $x_j=-1+\\dfrac{2j}{n}$ for $j=0,\\dots,n$.\n  - Chebyshev–Lobatto nodes: $x_k=\\cos\\left(\\dfrac{k\\pi}{n}\\right)$ for $k=0,\\dots,n$ with $\\pi$ in radians.\n- Interpolation construction:\n  - Use the barycentric Lagrange interpolant (which is mathematically equivalent to the unique interpolating polynomial) with weights $w_j=\\left(\\prod_{m\\ne j}(x_j-x_m)\\right)^{-1}$. Scaling all $w_j$ by a common nonzero factor leaves the interpolant invariant and can be used to normalize the weights for numerical stability.\n  - For evaluation at a point $x$, the first barycentric formula reads\n    $$ p_n(x)=\\frac{\\sum_{j=0}^n \\dfrac{w_j}{x-x_j} y_j}{\\sum_{j=0}^n \\dfrac{w_j}{x-x_j}}, $$\n    with the convention that if $x=x_j$ (to numerical tolerance), then $p_n(x)=y_j$ exactly to enforce interpolation and avoid division by zero.\n  - Vectorize evaluation across the entire grid $\\{x^{\\mathrm{eval}}_i\\}$ for efficiency.\n- Error metrics:\n  - Compute the sampled error $e_i=|f(x^{\\mathrm{eval}}_i)-p_n(x^{\\mathrm{eval}}_i)|$ and approximate $\\| f-p_n\\|_{\\infty}$ by $\\max_i e_i$.\n  - Define endpoint windows with width $w=0.1$ as $[-1,-1+w]\\cup[1-w,1]$, i.e., $[-1,-0.9]\\cup[0.9,1]$, and compute $E_{\\mathrm{end}}=\\max\\{e_i: x^{\\mathrm{eval}}_i\\in[-1,-0.9]\\cup[0.9,1]\\}$.\n- Oscillation metric:\n  - Approximate the derivative of $p_n$ on the grid by a centered finite-difference, i.e., the standard second-order accurate discrete derivative on a uniform grid with edge handling.\n  - Threshold small derivative magnitudes using $\\tau=10^{-8}$: map values with absolute value $\\le \\tau$ to $0$, leaving other values unchanged. Define the sign sequence $s_i=\\mathrm{sign}(p_n'(x^{\\mathrm{eval}}_i))$ with the thresholding applied.\n  - Restrict to indices in the union of endpoint windows. Remove zeros by compressing the sequence to its nonzero elements, and count strict sign changes: the number of indices where two consecutive nonzero signs differ (i.e., their product is negative). This yields an integer oscillation count for the endpoint regions.\n- Test suite:\n  - Degrees $n\\in\\{5,10,20\\}$. For each $n$, compute the triple $(\\| f-p_n\\|_{\\infty}, E_{\\mathrm{end}}, \\text{oscillation count})$ first for equispaced nodes and then for Chebyshev–Lobatto nodes.\n- Output formatting:\n  - For each $n$, concatenate the equispaced triple followed by the Chebyshev–Lobatto triple, yielding $6$ values per $n$ and $18$ values overall when $n=5,10,20$ are processed in order.\n  - Round all floating-point outputs to $8$ decimal places; keep oscillation counts as integers.\n  - Print a single line in the form of a comma-separated list enclosed in brackets.\n\nWhy this reveals the Runge phenomenon:\n- By the error identity, equispaced nodes do not control $\\max_{x\\in[-1,1]}\\left|\\prod_{j=0}^n(x-x_j)\\right|$ as $n$ grows, leading to large endpoint oscillations even for analytic $f$. Chebyshev–Lobatto nodes, arising from the extrema of $T_n$, effectively minimize the sup norm of the nodal polynomial up to scaling, spreading error more uniformly and suppressing endpoint blow-up. The global sup norm error and the endpoint error amplitude directly quantify these effects. The oscillation count detects spurious oscillatory behavior in $p_n$ near endpoints that is absent in $f$ (which is monotone on each endpoint window), providing a complementary qualitative assessment that is reduced for Chebyshev–Lobatto nodes relative to equispaced nodes.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef f(x):\n    return 1.0 / (1.0 + 25.0 * x * x)\n\ndef equispaced_nodes(n):\n    # n: degree, so n+1 nodes including endpoints\n    j = np.arange(n + 1, dtype=float)\n    return -1.0 + 2.0 * j / n\n\ndef chebyshev_lobatto_nodes(n):\n    # x_k = cos(k*pi/n), k=0..n, with radians\n    k = np.arange(n + 1, dtype=float)\n    return np.cos(np.pi * k / n)\n\ndef barycentric_weights(x):\n    # Compute first-form barycentric weights: w_j = 1 / prod_{k!=j} (x_j - x_k)\n    # Normalize to avoid overflow/underflow; overall scaling cancels in formula.\n    x = np.asarray(x, dtype=float)\n    m = x.size\n    w = np.empty(m, dtype=float)\n    for j in range(m):\n        diffs = x[j] - np.delete(x, j)\n        w[j] = 1.0 / np.prod(diffs)\n    # Normalize weights to unit max absolute value\n    maxabs = np.max(np.abs(w))\n    if maxabs == 0.0 or not np.isfinite(maxabs):\n        return w\n    return w / maxabs\n\ndef barycentric_interpolate(x_nodes, y_nodes, w, x_eval, atol=1e-14):\n    # Vectorized first-form barycentric interpolation\n    x_nodes = np.asarray(x_nodes, dtype=float)\n    y_nodes = np.asarray(y_nodes, dtype=float)\n    w = np.asarray(w, dtype=float)\n    x_eval = np.asarray(x_eval, dtype=float)\n    # Compute differences matrix\n    Xdiff = x_eval[:, None] - x_nodes[None, :]\n    # Identify exact matches to nodes within tolerance\n    mask_eq = np.isclose(Xdiff, 0.0, rtol=0.0, atol=atol)\n    any_eq = np.any(mask_eq, axis=1)\n    # For non-matching points, compute barycentric formula\n    # Avoid division by zero by masking those rows later\n    with np.errstate(divide='ignore', invalid='ignore'):\n        tmp = w[None, :] / Xdiff\n        num = np.dot(tmp, y_nodes)\n        den = np.sum(tmp, axis=1)\n        y = num / den\n    # Fix rows where x_eval equals a node\n    if np.any(any_eq):\n        idxs = np.where(any_eq)[0]\n        # For each such row, pick the corresponding node value\n        # If multiple trues due to tolerance, take the first\n        j_star = np.argmax(mask_eq[idxs, :], axis=1)\n        y[idxs] = y_nodes[j_star]\n    return y\n\ndef endpoint_masks(x_grid, w=0.1):\n    left = x_grid <= (-1.0 + w)\n    right = x_grid >= (1.0 - w)\n    return left | right\n\ndef count_strict_sign_changes(values, tol=1e-8):\n    # values: derivative samples on a 1D grid\n    v = np.asarray(values, dtype=float)\n    s = np.sign(v)\n    s[np.abs(v) <= tol] = 0.0\n    nonzero = s[s != 0.0]\n    if nonzero.size <= 1:\n        return 0\n    # Count transitions where consecutive signs differ\n    return int(np.sum(nonzero[1:] * nonzero[:-1] < 0.0))\n\ndef interpolation_metrics(n, node_kind, x_eval, f_eval, tau=1e-8):\n    # node_kind: 'equispaced' or 'cheb_lobatto'\n    if node_kind == 'equispaced':\n        x_nodes = equispaced_nodes(n)\n    elif node_kind == 'cheb_lobatto':\n        x_nodes = chebyshev_lobatto_nodes(n)\n    else:\n        raise ValueError(\"Unknown node kind\")\n\n    y_nodes = f(x_nodes)\n    w = barycentric_weights(x_nodes)\n    p_eval = barycentric_interpolate(x_nodes, y_nodes, w, x_eval)\n\n    # Errors\n    err = np.abs(f_eval - p_eval)\n    E_inf = float(np.max(err))\n\n    # Endpoint window metrics\n    mask_end = endpoint_masks(x_eval, w=0.1)\n    E_end = float(np.max(err[mask_end]))\n\n    # Oscillation count via discrete derivative\n    # Use np.gradient with x grid for better edge approximation\n    dp = np.gradient(p_eval, x_eval, edge_order=2)\n    osc_count = count_strict_sign_changes(dp[mask_end], tol=tau)\n\n    return E_inf, E_end, osc_count\n\ndef solve():\n    # Define the test cases from the problem statement.\n    degrees = [5, 10, 20]  # n values\n    # Evaluation grid\n    M = 20001\n    x_eval = np.linspace(-1.0, 1.0, M, dtype=float)\n    f_eval = f(x_eval)\n\n    results = []\n    for n in degrees:\n        # Equispaced nodes metrics\n        E_inf_e, E_end_e, osc_e = interpolation_metrics(n, 'equispaced', x_eval, f_eval, tau=1e-8)\n        # Chebyshev–Lobatto nodes metrics\n        E_inf_c, E_end_c, osc_c = interpolation_metrics(n, 'cheb_lobatto', x_eval, f_eval, tau=1e-8)\n\n        # Round floats to 8 decimal places as required; integers unchanged\n        results.extend([\n            f\"{np.round(E_inf_e, 8):.8f}\",\n            f\"{np.round(E_end_e, 8):.8f}\",\n            str(int(osc_e)),\n            f\"{np.round(E_inf_c, 8):.8f}\",\n            f\"{np.round(E_end_c, 8):.8f}\",\n            str(int(osc_c)),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3212557"}]}