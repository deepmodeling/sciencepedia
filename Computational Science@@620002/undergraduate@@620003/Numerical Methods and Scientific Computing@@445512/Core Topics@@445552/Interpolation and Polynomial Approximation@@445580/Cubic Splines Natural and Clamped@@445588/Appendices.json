{"hands_on_practices": [{"introduction": "To truly understand a concept, it is often helpful to test it at its limits. This exercise strips cubic splines down to their simplest possible form: interpolating just two data points. By applying the foundational definitions of natural and clamped boundary conditions to this single-interval case, we can reveal their essential nature and their connection to other familiar interpolation methods. [@problem_id:3220918]", "problem": "Consider a data set with exactly $2$ distinct nodes $\\{(x_0,y_0),(x_1,y_1)\\}$ where $x_0 < x_1$. A cubic spline on an interval is defined as a function that is a polynomial of degree at most $3$ on each subinterval, interpolates the given data, and is twice continuously differentiable. When there is only one subinterval $[x_0,x_1]$, there are no interior knots, so all continuity conditions at interior knots are vacuous. Boundary conditions distinguish common spline variants: a natural spline imposes $s''(x_0)=0$ and $s''(x_1)=0$, while a clamped spline imposes $s'(x_0)=m_0$ and $s'(x_1)=m_1$ for given endpoint slopes $m_0$ and $m_1$. Using only these foundational definitions, reason carefully about existence, uniqueness, and the resulting form of the spline when there are only $2$ data points.\n\nWhich statement is correct?\n\n- A. With $2$ data points, a natural cubic spline is undefined because there are no interior knots and the usual tridiagonal system cannot be formed; similarly, a clamped spline is undefined unless more points are added.\n- B. With $2$ data points, the natural cubic spline exists and reduces to the unique straight line through $(x_0,y_0)$ and $(x_1,y_1)$; the clamped cubic spline exists and reduces to the unique cubic Hermite interpolant on $[x_0,x_1]$ matching $s(x_i)=y_i$ and $s'(x_i)=m_i$ for $i\\in\\{0,1\\}$.\n- C. With $2$ data points, both natural and clamped splines exist and are always identical cubic polynomials on $[x_0,x_1]$, independent of the prescribed endpoint slopes.\n- D. With $2$ data points, a clamped cubic spline exists only if the prescribed slopes $m_0$ and $m_1$ both equal the secant slope $(y_1-y_0)/(x_1-x_0)$; otherwise, no solution exists.\n- E. With $2$ data points, a natural cubic spline is any cubic interpolant of the two points, because the second-derivative continuity conditions are vacuous when there are no interior knots.", "solution": "The problem statement poses a question about the existence, uniqueness, and form of natural and clamped cubic splines for the minimal case of $2$ distinct data points. We must validate the problem statement before proceeding.\n\n### Step 1: Extract Givens\n- Data set: Exactly $2$ distinct nodes $\\{(x_0,y_0),(x_1,y_1)\\}$ where $x_0  x_1$.\n- Spline definition: A function $s(x)$ that is a polynomial of degree at most $3$ on the interval $[x_0,x_1]$.\n- Interpolation conditions: $s(x_0) = y_0$ and $s(x_1) = y_1$.\n- Continuity conditions: Since there is only one interval, $[x_0,x_1]$, and no interior knots, the conditions of continuity for $s(x)$, $s'(x)$, and $s''(x)$ at interior knots are vacuously satisfied.\n- Natural spline boundary conditions: $s''(x_0) = 0$ and $s''(x_1) = 0$.\n- Clamped spline boundary conditions: $s'(x_0) = m_0$ and $s'(x_1) = m_1$ for given slopes $m_0$ and $m_1$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is scientifically and mathematically sound. It is well-posed, objective, and self-contained. The definitions provided for cubic splines, natural splines, and clamped splines are standard in the field of numerical analysis. The scenario of $2$ points is a perfectly valid, albeit simple, case to which these definitions can be applied. The problem does not violate any fundamental principles, is not ambiguous, and requires a rigorous application of the definitions to determine the properties of the resulting functions. It is a valid exercise in understanding the foundational definitions of splines beyond the common application to larger data sets.\n\n### Step 3: Verdict and Action\nThe problem is valid. We will now proceed with a formal derivation of the solution.\n\n### Derivation\n\nA cubic spline on a single interval $[x_0,x_1]$ is a polynomial $s(x)$ of degree at most $3$. We can express this polynomial as:\n$$s(x) = a_3 x^3 + a_2 x^2 + a_1 x + a_0$$\nThis polynomial has $4$ coefficients ($a_3, a_2, a_1, a_0$) that must be determined. The interpolation conditions, $s(x_0) = y_0$ and $s(x_1) = y_1$, provide $2$ linear equations. To uniquely determine the polynomial, $2$ additional conditions are required. These are provided by the boundary conditions.\n\n**Case 1: The Natural Cubic Spline**\n\nA natural spline imposes the following boundary conditions:\n1. $s''(x_0) = 0$\n2. $s''(x_1) = 0$\n\nLet's compute the second derivative of $s(x)$:\n$$s'(x) = 3a_3 x^2 + 2a_2 x + a_1$$\n$$s''(x) = 6a_3 x + 2a_2$$\nThe second derivative, $s''(x)$, is a linear function of $x$. The boundary conditions state that this linear function is zero at two distinct points, $x_0$ and $x_1$. A non-zero linear function can have at most one root. Therefore, for $s''(x)$ to be zero at two distinct points, it must be the zero polynomial.\n$$s''(x) = 0 \\quad \\forall x \\in [x_0, x_1]$$\nThis implies that $6a_3 = 0$ and $2a_2 = 0$, which means $a_3 = 0$ and $a_2 = 0$.\n\nWith $a_3=0$ and $a_2=0$, the spline function $s(x)$ simplifies to a linear polynomial:\n$$s(x) = a_1 x + a_0$$\nThe remaining coefficients, $a_1$ and $a_0$, are determined by the $2$ interpolation conditions:\n1. $s(x_0) = a_1 x_0 + a_0 = y_0$\n2. $s(x_1) = a_1 x_1 + a_0 = y_1$\nThis is a system of $2$ linear equations in $2$ unknowns ($a_1, a_0$). Since $x_0 \\neq x_1$, this system has a unique solution. This solution defines the unique straight line passing through the points $(x_0, y_0)$ and $(x_1, y_1)$.\nThus, for $2$ data points, the natural cubic spline exists, is unique, and is the straight line connecting them.\n\n**Case 2: The Clamped Cubic Spline**\n\nA clamped spline imposes boundary conditions on the first derivative:\n1. $s'(x_0) = m_0$\n2. $s'(x_1) = m_1$\n\nWe have a total of $4$ conditions to determine the $4$ coefficients of the cubic polynomial $s(x)$:\n1. $s(x_0) = y_0$\n2. $s(x_1) = y_1$\n3. $s'(x_0) = m_0$\n4. $s'(x_1) = m_1$\n\nThese are precisely the conditions that define the unique cubic Hermite interpolating polynomial on the interval $[x_0, x_1]$. For any given set of values $\\{y_0, y_1, m_0, m_1\\}$, and for distinct points $x_0$ and $x_1$, it is a standard result in numerical analysis that there exists a unique polynomial of degree at most $3$ satisfying these $4$ conditions. The existence and uniqueness are guaranteed because the associated $4 \\times 4$ linear system for the coefficients $(a_3, a_2, a_1, a_0)$ is non-singular.\n\nTherefore, for $2$ data points, the clamped cubic spline exists and is identical to the unique cubic Hermite interpolant defined by the function values and specified derivative values at the endpoints. Unless the slopes $m_0$ and $m_1$ happen to be equal to the secant slope $(y_1-y_0)/(x_1-x_0)$, this polynomial will be of degree higher than $1$.\n\n### Option-by-Option Analysis\n\n- **A. With $2$ data points, a natural cubic spline is undefined because there are no interior knots and the usual tridiagonal system cannot be formed; similarly, a clamped spline is undefined unless more points are added.**\nThis statement is incorrect. The tridiagonal system is a computational method for solving the multi-knot case, not a part of the fundamental definition. The absence of this specific computational structure does not imply the mathematical object is undefined. As derived above, applying the fundamental definitions to the $2$-point case yields unique, well-defined functions for both the natural and clamped splines.\n**Verdict: Incorrect.**\n\n- **B. With $2$ data points, the natural cubic spline exists and reduces to the unique straight line through $(x_0,y_0)$ and $(x_1,y_1)$; the clamped cubic spline exists and reduces to the unique cubic Hermite interpolant on $[x_0,x_1]$ matching $s(x_i)=y_i$ and $s'(x_i)=m_i$ for $i\\in\\{0,1\\}$.**\nThis statement is fully consistent with our derivation.\nThe natural spline conditions $s''(x_0)=0$ and $s''(x_1)=0$ force the cubic polynomial to be linear. The interpolation conditions then select the unique line through the two points.\nThe clamped spline conditions $s(x_0)=y_0, s(x_1)=y_1, s'(x_0)=m_0, s'(x_1)=m_1$ are the explicit definition of cubic Hermite interpolation on the interval $[x_0,x_1]$, which is known to have a unique solution.\n**Verdict: Correct.**\n\n- **C. With $2$ data points, both natural and clamped splines exist and are always identical cubic polynomials on $[x_0,x_1]$, independent of the prescribed endpoint slopes.**\nThis statement is incorrect. The natural spline is a linear polynomial (degree $1$). The clamped spline is generally a cubic polynomial (degree up to $3$) whose coefficients depend directly on the prescribed slopes $m_0$ and $m_1$. They are not \"always identical\" and the clamped spline is not \"independent of the prescribed endpoint slopes.\" They are only identical in the specific case where the prescribed slopes $m_0$ and $m_1$ both equal the slope of the line connecting the points, $(y_1-y_0)/(x_1-x_0)$.\n**Verdict: Incorrect.**\n\n- **D. With $2$ data points, a clamped cubic spline exists only if the prescribed slopes $m_0$ and $m_1$ both equal the secant slope $(y_1-y_0)/(x_1-x_0)$; otherwise, no solution exists.**\nThis statement is incorrect. As established in the derivation for the clamped spline, a unique solution (the cubic Hermite interpolant) exists for *any* given values of $m_0$ and $m_1$. The condition mentioned is not a condition for existence; it is the specific condition under which the (cubic) clamped spline reduces to the (linear) natural spline.\n**Verdict: Incorrect.**\n\n- **E. With $2$ data points, a natural cubic spline is any cubic interpolant of the two points, because the second-derivative continuity conditions are vacuous when there are no interior knots.**\nThis statement is incorrect. It confuses the vacuous continuity conditions at interior knots with the non-vacuous boundary conditions. The natural spline definition explicitly imposes $s''(x_0)=0$ and $s''(x_1)=0$. These are $2$ powerful constraints that, together with the $2$ interpolation constraints, uniquely determine the polynomial. This leads to a single, unique solution (the line), not a family of \"any cubic interpolant.\" An infinite number of cubic polynomials can interpolate two points, but only one of them is the natural spline.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{B}$$", "id": "3220918"}, {"introduction": "The choice between natural and clamped boundary conditions has profound practical effects on the shape of the interpolant. This hands-on coding exercise challenges you to implement both spline types and quantify a common artifact known as \"overshoot,\" where the spline oscillates beyond the range of its defining data points. By comparing the behavior of natural and clamped splines on a carefully chosen dataset, you will gain an intuitive understanding of why one might be preferred over the other to avoid non-physical behavior. [@problem_id:3220873]", "problem": "You are asked to implement from first principles the construction and evaluation of cubic spline interpolants with two distinct endpoint boundary conditions: the natural boundary condition and the clamped boundary condition. A cubic spline is defined as a function composed of piecewise cubic polynomials on consecutive subintervals that interpolate given data points and is twice continuously differentiable across the entire domain. The natural boundary condition sets the second derivative at the endpoints to zero, while the clamped boundary condition specifies the first derivative at the endpoints. Your task is to:\n- Derive an algorithmic formulation to compute a unique cubic spline interpolant for strictly increasing abscissae $\\{x_i\\}_{i=0}^{n-1}$ and ordinates $\\{y_i\\}_{i=0}^{n-1}$, under either the natural or the clamped boundary condition. The derivation must begin from the defining properties: cubic-by-interval, interpolation constraints, and continuity up to the second derivative at the internal knots.\n- Implement both boundary condition choices. For the clamped boundary condition, use endpoint derivatives given by the one-sided secant slopes,\n$$\ns_0 \\equiv \\frac{y_1 - y_0}{x_1 - x_0}, \\quad s_{n-1} \\equiv \\frac{y_{n-1} - y_{n-2}}{x_{n-1} - x_{n-2}}.\n$$\n\nTo quantify counter-intuitive oscillation, define the overshoot magnitude on one subinterval $[x_i,x_{i+1}]$ as follows. Let $m_i = \\min\\{y_i,y_{i+1}\\}$ and $M_i = \\max\\{y_i,y_{i+1}\\}$. Let $S(x)$ denote the spline value. The overshoot magnitude on $[x_i,x_{i+1}]$ is\n$$\n\\Delta_i \\equiv \\max\\Big\\{ \\max_{x \\in [x_i,x_{i+1}]} \\big(S(x) - M_i\\big), \\ \\max_{x \\in [x_i,x_{i+1}]}\\big(m_i - S(x)\\big), \\ 0 \\Big\\}.\n$$\nThe global overshoot is $\\Delta \\equiv \\max_i \\Delta_i$. Numerically approximate the subinterval maxima by evaluating $S(x)$ on a uniform grid of $1001$ points on each $[x_i,x_{i+1}]$.\n\nImplement a single program that:\n- Constructs both the natural spline and the clamped spline (with the above $s_0$ and $s_{n-1}$) for each dataset in the test suite.\n- Evaluates and reports the global overshoot $\\Delta$ for each spline.\n\nYour implementation must be fully self-contained and must not call external libraries beyond the specified ones. All computations are in pure mathematics (no physical units).\n\nTest suite. Use the following datasets, each given as lists $x$ and $y$ of equal length with strictly increasing $x$:\n\n- Case A (left-end steepening that induces a large natural-spline oscillation near the left endpoint):\n  - $x = [\\,0.0,\\,0.5,\\,0.6,\\,2.0\\,]$\n  - $y = [\\,0.0,\\,1.0,\\,10.0,\\,12.0\\,]$\n\n- Case B (near-linear, happy-path):\n  - $x = [\\,0.0,\\,1.0,\\,2.0,\\,3.0\\,]$\n  - $y = [\\,0.0,\\,1.0,\\,2.0,\\,3.0\\,]$\n\n- Case C (right-end steepening that induces a natural-spline oscillation near the right endpoint):\n  - $x = [\\,0.0,\\,1.4,\\,1.5,\\,2.0\\,]$\n  - $y = [\\,0.0,\\,2.0,\\,3.0,\\,3.2\\,]$\n\nFor each case, compute and return the pair of overshoot magnitudes $\\Delta_{\\text{natural}}$ and $\\Delta_{\\text{clamped}}$ as floating-point numbers. Your program should produce a single line of output containing all results concatenated in order as a comma-separated list enclosed in square brackets, in the order\n$$\n[\\,\\Delta_{\\text{natural}}^{(A)},\\,\\Delta_{\\text{clamped}}^{(A)},\\,\\Delta_{\\text{natural}}^{(B)},\\,\\Delta_{\\text{clamped}}^{(B)},\\,\\Delta_{\\text{natural}}^{(C)},\\,\\Delta_{\\text{clamped}}^{(C)}\\,].\n$$", "solution": "The user requires a derivation and implementation of cubic spline interpolation for both natural and clamped boundary conditions. The derivation must proceed from first principles, and the implementation must compute the global overshoot for several test cases.\n\n### Derivation of the Cubic Spline Interpolant\n\nA cubic spline $S(x)$ interpolating a set of $n$ data points $(x_i, y_i)$ for $i=0, 1, \\ldots, n-1$ with strictly increasing abscissae $x_0  x_1  \\ldots  x_{n-1}$ is a piecewise function defined on $[x_0, x_{n-1}]$. For each subinterval $[x_i, x_{i+1}]$, the spline segment $S_i(x)$ is a cubic polynomial. The entire spline $S(x)$ must satisfy the following properties:\n1.  **Interpolation**: $S(x_i) = y_i$ for all $i=0, \\ldots, n-1$.\n2.  **Continuity**: $S(x)$ is twice continuously differentiable on $[x_0, x_{n-1}]$, i.e., $S \\in C^2[x_0, x_{n-1}]$. This implies that at each interior knot $x_i$ ($i=1, \\ldots, n-2$), $S_{i-1}(x_i) = S_i(x_i)$, $S'_{i-1}(x_i) = S'_i(x_i)$, and $S''_{i-1}(x_i) = S''_i(x_i)$.\n\nLet us define the second derivatives of the spline at the knots as $M_i = S''(x_i)$ for $i=0, \\ldots, n-1$. Since each segment $S_i(x)$ is a cubic polynomial, its second derivative $S_i''(x)$ is a linear function. On the interval $[x_i, x_{i+1}]$, $S_i''(x)$ passes through the points $(x_i, M_i)$ and $(x_{i+1}, M_{i+1})$. Let $h_i = x_{i+1} - x_i$. The linear function $S_i''(x)$ can be written using Lagrange's linear interpolation formula:\n$$\nS_i''(x) = M_i \\frac{x_{i+1} - x}{h_i} + M_{i+1} \\frac{x - x_i}{h_i}\n$$\nIntegrating $S_i''(x)$ twice with respect to $x$ gives the general form of the cubic polynomial $S_i(x)$:\n$$\nS_i(x) = M_i \\frac{(x_{i+1} - x)^3}{6h_i} + M_{i+1} \\frac{(x - x_i)^3}{6h_i} + C(x-x_i) + D(x_{i+1}-x)\n$$\nwhere $C$ and $D$ are constants of integration, expressed in a form convenient for applying the interpolation conditions.\nWe enforce the interpolation conditions $S_i(x_i) = y_i$ and $S_i(x_{i+1}) = y_{i+1}$:\nAt $x=x_i$: $y_i = M_i \\frac{h_i^3}{6h_i} + D h_i \\implies D = \\frac{y_i}{h_i} - \\frac{M_i h_i}{6}$.\nAt $x=x_{i+1}$: $y_{i+1} = M_{i+1} \\frac{h_i^3}{6h_i} + C h_i \\implies C = \\frac{y_{i+1}}{h_i} - \\frac{M_{i+1} h_i}{6}$.\n\nSubstituting these constants back, we obtain the expression for the spline segment $S_i(x)$ in terms of the known data points and the unknown second derivatives $M_i$:\n$$\nS_i(x) = \\frac{M_i}{6h_i}(x_{i+1}-x)^3 + \\frac{M_{i+1}}{6h_i}(x-x_i)^3 + \\left(\\frac{y_{i+1}}{h_i} - \\frac{M_{i+1}h_i}{6}\\right)(x-x_i) + \\left(\\frac{y_i}{h_i} - \\frac{M_i h_i}{6}\\right)(x_{i+1}-x)\n$$\nThis equation defines the spline on each subinterval $[x_i, x_{i+1}]$ for $i=0, \\ldots, n-2$. To find the unknown values $M_i$, we use the continuity condition for the first derivative, $S'_{i-1}(x_i) = S'_i(x_i)$, at the interior knots $x_i$ for $i=1, \\ldots, n-2$.\n\nFirst, we find the derivative $S'_i(x)$:\n$$\nS'_i(x) = -\\frac{M_i}{2h_i}(x_{i+1}-x)^2 + \\frac{M_{i+1}}{2h_i}(x-x_i)^2 + \\left(\\frac{y_{i+1}}{h_i} - \\frac{M_{i+1}h_i}{6}\\right) - \\left(\\frac{y_i}{h_i} - \\frac{M_i h_i}{6}\\right)\n$$\nEvaluating the derivatives at the knots:\n$S'_i(x_i) = -\\frac{M_i h_i}{2} + \\frac{y_{i+1}-y_i}{h_i} - \\frac{M_{i+1}h_i}{6} + \\frac{M_i h_i}{6} = \\frac{y_{i+1}-y_i}{h_i} - \\frac{h_i}{3}M_i - \\frac{h_i}{6}M_{i+1}$.\n$S'_{i-1}(x_i) = \\frac{M_{i-1}h_{i-1}}{6} + \\frac{M_i h_{i-1}}{3} + \\frac{y_i-y_{i-1}}{h_{i-1}}$.\n\nEquating $S'_{i-1}(x_i) = S'_i(x_i)$ for $i=1, \\ldots, n-2$:\n$$\n\\frac{y_i-y_{i-1}}{h_{i-1}} + \\frac{h_{i-1}}{6}M_{i-1} + \\frac{h_{i-1}}{3}M_i = \\frac{y_{i+1}-y_i}{h_i} - \\frac{h_i}{3}M_i - \\frac{h_i}{6}M_{i+1}\n$$\nRearranging the terms to group the unknowns $M_{i-1}$, $M_i$, and $M_{i+1}$:\n$$\nh_{i-1}M_{i-1} + (2h_{i-1} + 2h_i)M_i + h_iM_{i+1} = 6\\left(\\frac{y_{i+1}-y_i}{h_i} - \\frac{y_i-y_{i-1}}{h_{i-1}}\\right)\n$$\nThis fundamental relation provides a system of $n-2$ linear equations for the $n$ unknowns $M_0, \\ldots, M_{n-1}$. To obtain a unique solution, we need two additional equations, which are provided by the boundary conditions.\n\n### Boundary Conditions\n\n**1. Natural Spline:**\nThe natural boundary condition specifies zero curvature at the endpoints: $S''(x_0)=0$ and $S''(x_{n-1})=0$. This directly translates to:\n$$\nM_0 = 0, \\quad M_{n-1} = 0\n$$\nSubstituting these into the general system leaves $n-2$ equations for the $n-2$ unknowns $M_1, \\ldots, M_{n-2}$. The system forms a strictly diagonally dominant tridiagonal matrix, guaranteeing a unique solution.\n\n**2. Clamped Spline:**\nThe clamped boundary condition specifies the first derivatives at the endpoints: $S'(x_0)=s_0$ and $S'(x_{n-1})=s_{n-1}$.\nUsing our expression for $S'_i(x_i)$, we set $i=0$:\n$S'(x_0) = S'_0(x_0) = \\frac{y_1-y_0}{h_0} - \\frac{h_0}{3}M_0 - \\frac{h_0}{6}M_1 = s_0$.\nRearranging gives the first boundary equation:\n$$\n2h_0M_0 + h_0M_1 = 6\\left(\\frac{y_1-y_0}{h_0} - s_0\\right)\n$$\nFor the condition at $x_{n-1}$, we evaluate $S'_{n-2}(x_{n-1})=s_{n-1}$:\n$S'_{n-2}(x_{n-1}) = \\frac{y_{n-1}-y_{n-2}}{h_{n-2}} + \\frac{h_{n-2}}{6}M_{n-2} + \\frac{h_{n-2}}{3}M_{n-1} = s_{n-1}$.\nRearranging gives the second boundary equation:\n$$\nh_{n-2}M_{n-2} + 2h_{n-2}M_{n-1} = 6\\left(s_{n-1} - \\frac{y_{n-1}-y_{n-2}}{h_{n-2}}\\right)\n$$\nThe problem specifies particular values for $s_0$ and $s_{n-1}$:\n$s_0 = \\frac{y_1 - y_0}{x_1 - x_0} = \\frac{y_1 - y_0}{h_0}$\n$s_{n-1} = \\frac{y_{n-1} - y_{n-2}}{x_{n-1} - x_{n-2}} = \\frac{y_{n-1} - y_{n-2}}{h_{n-2}}$\nWith these choices, the right-hand sides of both boundary equations become zero:\n$2h_0M_0 + h_0M_1 = 0 \\implies 2M_0 + M_1 = 0$.\n$h_{n-2}M_{n-2} + 2h_{n-2}M_{n-1} = 0 \\implies M_{n-2} + 2M_{n-1} = 0$.\nThese two equations, combined with the $n-2$ interior equations, form a full $n \\times n$ tridiagonal system for the unknowns $M_0, \\ldots, M_{n-1}$. This system is also strictly diagonally dominant and has a unique solution.\n\n### Overshoot Calculation\n\nThe overshoot magnitude on a subinterval $[x_i, x_{i+1}]$ is defined as:\n$$\n\\Delta_i = \\max\\left\\{ \\max_{x \\in [x_i,x_{i+1}]} \\left(S(x) - \\max\\{y_i,y_{i+1}\\}\\right), \\ \\max_{x \\in [x_i,x_{i+1}]}\\left(\\min\\{y_i,y_{i+1}\\} - S(x)\\right), \\ 0 \\right\\}\n$$\nThe global overshoot is the maximum over all subintervals, $\\Delta = \\max_i \\Delta_i$. Computationally, the maxima on each subinterval are approximated by evaluating the spline $S(x)$ on a fine uniform grid of $1001$ points spanning $[x_i, x_{i+1}]$. This procedure quantifies the extent to which the spline oscillates beyond the range of the data points it interpolates.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tdma(lower, main, upper, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax=d using the Thomas algorithm.\n\n    Args:\n        lower (np.ndarray): The lower diagonal of A (length n-1).\n        main (np.ndarray): The main diagonal of A (length n).\n        upper (np.ndarray): The upper diagonal of A (length n-1).\n        d (np.ndarray): The right-hand side vector (length n).\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = len(main)\n    c_p = np.zeros(n)\n    d_p = np.zeros(n)\n\n    # Forward elimination\n    c_p[0] = upper[0] / main[0]\n    d_p[0] = d[0] / main[0]\n    for i in range(1, n):\n        denom = main[i] - lower[i-1] * c_p[i-1]\n        if i  n - 1:\n            c_p[i] = upper[i] / denom\n        d_p[i] = (d[i] - lower[i-1] * d_p[i-1]) / denom\n\n    # Backward substitution\n    x = np.zeros(n)\n    x[n-1] = d_p[n-1]\n    for i in range(n-2, -1, -1):\n        x[i] = d_p[i] - c_p[i] * x[i+1]\n    return x\n\nclass CubicSpline:\n    \"\"\"\n    A class for computing and evaluating cubic spline interpolants.\n    \"\"\"\n    def __init__(self, x, y, bc_type='natural'):\n        self.x = np.asarray(x, dtype=float)\n        self.y = np.asarray(y, dtype=float)\n        self.n = len(x)\n        \n        if self.n  2:\n            raise ValueError(\"Need at least 2 points for interpolation.\")\n        \n        self.h = self.x[1:] - self.x[:-1]\n        \n        if np.any(self.h = 0):\n            raise ValueError(\"x coordinates must be strictly increasing.\")\n\n        if bc_type == 'natural':\n            self._compute_natural_spline()\n        elif bc_type == 'clamped':\n            self._compute_clamped_spline()\n        else:\n            raise ValueError(f\"Unsupported boundary condition type: {bc_type}\")\n\n    def _compute_natural_spline(self):\n        \"\"\"Computes the second derivatives M for a natural spline.\"\"\"\n        if self.n = 2:\n            self.M = np.zeros(self.n)\n            return\n\n        N = self.n - 2  # Size of the internal system\n        \n        A_lower = self.h[1:-1]\n        A_main = 2 * (self.h[:-1] + self.h[1:])\n        A_upper = self.h[1:-1]\n\n        delta = (self.y[1:] - self.y[:-1]) / self.h\n        b_rhs = 6 * (delta[1:] - delta[:-1])\n\n        M_internal = solve_tdma(A_lower, A_main, A_upper, b_rhs)\n        \n        self.M = np.zeros(self.n)\n        self.M[1:-1] = M_internal\n\n    def _compute_clamped_spline(self):\n        \"\"\"Computes the second derivatives M for a clamped spline with specified derivatives.\"\"\"\n        if self.n = 2:\n            # Linear interpolation for 2 points, second derivatives are zero\n            self.M = np.zeros(self.n)\n            return\n\n        N = self.n\n        A_lower = np.zeros(N - 1)\n        A_main = np.zeros(N)\n        A_upper = np.zeros(N - 1)\n        b_rhs = np.zeros(N)\n\n        # First row from boundary condition: 2*M_0 + M_1 = 0\n        A_main[0] = 2.0\n        A_upper[0] = 1.0\n        b_rhs[0] = 0.0\n\n        # Internal rows\n        delta = (self.y[1:] - self.y[:-1]) / self.h\n        internal_rhs = 6 * (delta[1:] - delta[:-1])\n        b_rhs[1:-1] = internal_rhs\n\n        A_main[1:-1] = 2 * (self.h[:-1] + self.h[1:])\n        A_lower[:-1] = self.h[:-1]\n        A_upper[1:] = self.h[1:]\n\n        # Last row from boundary condition: M_{n-2} + 2*M_{n-1} = 0\n        A_lower[-1] = 1.0\n        A_main[-1] = 2.0\n        b_rhs[-1] = 0.0\n        \n        self.M = solve_tdma(A_lower, A_main, A_upper, b_rhs)\n\n    def evaluate(self, x_eval):\n        \"\"\"Evaluates the spline at given points.\"\"\"\n        x_eval = np.asarray(x_eval)\n        indices = np.searchsorted(self.x, x_eval, side='right') - 1\n        indices = np.clip(indices, 0, self.n - 2)\n\n        xi = self.x[indices]\n        xi1 = self.x[indices + 1]\n        yi = self.y[indices]\n        yi1 = self.y[indices + 1]\n        hi = self.h[indices]\n        Mi = self.M[indices]\n        Mi1 = self.M[indices + 1]\n\n        t = x_eval - xi\n        t_comp = xi1 - x_eval\n        \n        term1 = (Mi / (6 * hi)) * (t_comp**3)\n        term2 = (Mi1 / (6 * hi)) * (t**3)\n        term3 = (yi1 / hi - Mi1 * hi / 6) * t\n        term4 = (yi / hi - Mi * hi / 6) * t_comp\n        \n        return term1 + term2 + term3 + term4\n\ndef calculate_overshoot(spline, n_grid=1001):\n    \"\"\"Calculates the global overshoot magnitude for a given spline.\"\"\"\n    max_overshoot = 0.0\n    for i in range(spline.n - 1):\n        xi, xi1 = spline.x[i], spline.x[i+1]\n        yi, yi1 = spline.y[i], spline.y[i+1]\n        \n        m_i = min(yi, yi1)\n        M_i = max(yi, yi1)\n        \n        x_grid = np.linspace(xi, xi1, n_grid)\n        y_grid = spline.evaluate(x_grid)\n        \n        overshoot = np.max(y_grid) - M_i\n        undershoot = m_i - np.min(y_grid)\n        \n        interval_max_deviation = max(overshoot, undershoot, 0.0)\n        \n        if interval_max_deviation  max_overshoot:\n            max_overshoot = interval_max_deviation\n            \n    return max_overshoot\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A (left-end steepening)\n        {'x': [0.0, 0.5, 0.6, 2.0], 'y': [0.0, 1.0, 10.0, 12.0]},\n        # Case B (near-linear)\n        {'x': [0.0, 1.0, 2.0, 3.0], 'y': [0.0, 1.0, 2.0, 3.0]},\n        # Case C (right-end steepening)\n        {'x': [0.0, 1.4, 1.5, 2.0], 'y': [0.0, 2.0, 3.0, 3.2]}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x = case['x']\n        y = case['y']\n        \n        # Natural Spline\n        natural_spline = CubicSpline(x, y, bc_type='natural')\n        delta_natural = calculate_overshoot(natural_spline)\n        results.append(delta_natural)\n        \n        # Clamped Spline\n        clamped_spline = CubicSpline(x, y, bc_type='clamped')\n        delta_clamped = calculate_overshoot(clamped_spline)\n        results.append(delta_clamped)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3220873"}, {"introduction": "Clamped splines offer great control, but their accuracy hinges on the quality of the derivative estimates supplied at the endpoints. This practice explores the principle that local approximation errors at the boundaries can have a global impact on the quality of the fit. By implementing clamped splines with both first-order and second-order accurate derivative formulas, you will directly measure and quantify how improving boundary conditions leads to a more accurate interpolation across the entire domain. [@problem_id:3220799]", "problem": "Consider uniform nodes $\\{x_i\\}_{i=0}^n$ on an interval $[a,b]$ with spacing $h = \\frac{b-a}{n}$ and sampled values $f_i = f(x_i)$. A clamped cubic spline $S(x)$ on $[a,b]$ is defined as a function that on each subinterval $[x_i,x_{i+1}]$ is a cubic polynomial, with $S(x)$, $S'(x)$, and $S''(x)$ continuous on $[a,b]$, and with boundary derivative constraints $S'(x_0) = d_0$ and $S'(x_n) = d_n$. The clamped cubic spline is fully determined by these properties and the data $\\{(x_i,f_i)\\}_{i=0}^n$.\n\nWhen the exact endpoint derivatives $f'(x_0)$ and $f'(x_n)$ are unavailable, they can be approximated from $\\{f_i\\}$ using one-sided Finite Difference (FD) formulas. For uniform spacing and sufficiently smooth $f$, the following standard one-sided FD approximations are used:\n- First-order forward/backward formulas (order $\\mathcal{O}(h)$):\n$$\nd_0^{(1)} = \\frac{f(x_1) - f(x_0)}{h}, \\quad d_n^{(1)} = \\frac{f(x_n) - f(x_{n-1})}{h}.\n$$\n- Second-order forward/backward formulas (order $\\mathcal{O}(h^2)$):\n$$\nd_0^{(2)} = \\frac{-3 f(x_0) + 4 f(x_1) - f(x_2)}{2 h}, \\quad d_n^{(2)} = \\frac{3 f(x_n) - 4 f(x_{n-1}) + f(x_{n-2})}{2 h}.\n$$\n\nYour task is to implement clamped cubic spline interpolation on uniform grids using only the data $\\{f_i\\}$ and to set the clamped slopes at the endpoints by either the $\\mathcal{O}(h)$ or the $\\mathcal{O}(h^2)$ one-sided FD approximations defined above. Then, for each case, quantify the interior interpolation error by computing the maximum absolute error $\\max_{x \\in [x_0+h,\\,x_n-h]} |S(x) - f(x)|$ using a dense set of sample points in the open interior of the interval. Use exactly $1001$ equally spaced interior sample points over $[x_0+h,\\,x_n-h]$.\n\nImplement the spline and error computation in a single program. The program must produce a single line of output containing the results for all provided test cases as a comma-separated list enclosed in square brackets, where each test case contributes a list of three floating-point numbers:\n- the maximum interior absolute error using $\\mathcal{O}(h^2)$ endpoint slopes,\n- the maximum interior absolute error using $\\mathcal{O}(h)$ endpoint slopes,\n- the ratio of the two errors (the $\\mathcal{O}(h)$ error divided by the $\\mathcal{O}(h^2)$ error).\n\nAngle units, when applicable, must be radians. No physical units are involved.\n\nTest Suite:\n- Case $\\mathbf{A}$ (happy path, trigonometric): $f(x) = \\sin(x)$ on $[0,\\pi]$, with $n = 10$. Use $\\pi$ in radians.\n- Case $\\mathbf{B}$ (exponential growth): $f(x) = e^{x}$ on $[0,1]$, with $n = 8$.\n- Case $\\mathbf{C}$ (polynomial edge case): $f(x) = x^3$ on $[0,1]$, with $n = 8$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case reported as a list of three floats in the order specified above. For example, a valid output format for three cases is\n$$\n\\big[ [E^{(2)}_A, E^{(1)}_A, R_A], [E^{(2)}_B, E^{(1)}_B, R_B], [E^{(2)}_C, E^{(1)}_C, R_C] \\big],\n$$\nwhere $E^{(2)}$ and $E^{(1)}$ denote the maximum interior absolute errors for $\\mathcal{O}(h^2)$ and $\\mathcal{O}(h)$ endpoint slopes, respectively, and $R$ is their ratio.", "solution": "The user-provided problem has been analyzed and validated as a well-posed, scientifically grounded task in numerical methods. The following is a complete and reasoned solution.\n\n### Principle and Method\n\nThe objective is to construct a clamped cubic spline interpolant $S(x)$ for a given function $f(x)$ on a uniform grid, and to analyze the interpolation error when the required endpoint derivatives are approximated using finite difference formulas of different orders of accuracy.\n\nA cubic spline $S(x)$ interpolating the data points $\\{(x_i, f_i)\\}_{i=0}^n$ is a piecewise cubic function. On each subinterval $[x_i, x_{i+1}]$, $S(x)$ is a cubic polynomial, which we denote by $S_i(x)$. The defining properties are that $S(x)$, its first derivative $S'(x)$, and its second derivative $S''(x)$ are continuous over the entire interval $[a,b]$.\n\nLet $h = x_{i+1} - x_i$ be the uniform spacing and let $M_i = S''(x_i)$ be the unknown second derivatives at the nodes. The cubic polynomial $S_i(x)$ on $[x_i, x_{i+1}]$ can be expressed in terms of $M_i$ and $M_{i+1}$:\n$$\nS_i(x) = M_i \\frac{(x_{i+1}-x)^3}{6h} + M_{i+1} \\frac{(x-x_i)^3}{6h} + \\left(\\frac{f_{i+1}}{h} - \\frac{M_{i+1}h}{6}\\right)(x-x_i) + \\left(\\frac{f_i}{h} - \\frac{M_i h}{6}\\right)(x_{i+1}-x)\n$$\nThis form automatically satisfies the interpolating conditions $S_i(x_i) = f_i$ and $S_i(x_{i+1}) = f_{i+1}$.\n\nThe continuity of the first derivative, $S'_{i-1}(x_i) = S'_{i}(x_i)$, at the interior nodes $x_i$ for $i=1, 2, \\dots, n-1$ yields a system of linear equations for the unknowns $M_i$:\n$$\nM_{i-1} + 4M_i + M_{i+1} = \\frac{6}{h^2}(f_{i-1} - 2f_i + f_{i+1}) \\quad \\text{for } i=1, \\dots, n-1\n$$\nThis provides $n-1$ equations for the $n+1$ unknowns $(M_0, M_1, \\dots, M_n)$.\n\nThe remaining two equations are derived from the clamped boundary conditions, $S'(x_0) = d_0$ and $S'(x_n) = d_n$. By differentiating the expressions for $S_0(x)$ and $S_{n-1}(x)$ and evaluating at the endpoints, we obtain:\n$$\nS'(x_0) = \\frac{f_1-f_0}{h} - \\frac{h}{3}M_0 - \\frac{h}{6}M_1 = d_0 \\implies 2M_0 + M_1 = \\frac{6}{h}\\left(\\frac{f_1 - f_0}{h} - d_0\\right)\n$$\n$$\nS'(x_n) = \\frac{f_n - f_{n-1}}{h} + \\frac{h}{6}M_{n-1} + \\frac{h}{3}M_n = d_n \\implies M_{n-1} + 2M_n = \\frac{6}{h}\\left(d_n - \\frac{f_n - f_{n-1}}{h}\\right)\n$$\n\nThese equations complete the system, which can be written in matrix form as $A\\mathbf{M} = \\mathbf{b}$, where $\\mathbf{M} = [M_0, M_1, \\dots, M_n]^T$:\n$$\n\\begin{pmatrix}\n2  1  0  \\cdots  0 \\\\\n1  4  1  \\cdots  0 \\\\\n0  1  4  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  4  1 \\\\\n0  \\cdots  0  1  2\n\\end{pmatrix}\n\\begin{pmatrix} M_0 \\\\ M_1 \\\\ M_2 \\\\ \\vdots \\\\ M_n \\end{pmatrix}\n=\n\\begin{pmatrix} \\frac{6}{h}(\\frac{f_1-f_0}{h} - d_0) \\\\ \\frac{6}{h^2}(f_0 - 2f_1 + f_2) \\\\ \\vdots \\\\ \\frac{6}{h^2}(f_{n-2} - 2f_{n-1} + f_n) \\\\ \\frac{6}{h}(d_n - \\frac{f_n-f_{n-1}}{h}) \\end{pmatrix}\n$$\nThe matrix $A$ is a strictly diagonally dominant tridiagonal matrix, guaranteeing a unique solution for $\\mathbf{M}$ that can be found efficiently.\n\nThe problem requires approximating the endpoint derivatives $d_0$ and $d_n$ from the data $\\{f_i\\}$ using two different one-sided finite difference formulas:\n1.  **Order $\\mathcal{O}(h)$ approximation**: $d_0^{(1)} = \\frac{f_1 - f_0}{h}$, $d_n^{(1)} = \\frac{f_n - f_{n-1}}{h}$.\n2.  **Order $\\mathcal{O}(h^2)$ approximation**: $d_0^{(2)} = \\frac{-3f_0 + 4f_1 - f_2}{2h}$, $d_n^{(2)} = \\frac{3f_n - 4f_{n-1} + f_{n-2}}{2h}$.\n\nFor each test case, we will solve the system $A\\mathbf{M} = \\mathbf{b}$ twice: once using $(d_0^{(2)}, d_n^{(2)})$ and once using $(d_0^{(1)}, d_n^{(1)})$. This yields two different sets of second derivatives, $\\mathbf{M}^{(2)}$ and $\\mathbf{M}^{(1)}$, and thus two different spline interpolants, $S^{(2)}(x)$ and $S^{(1)}(x)$.\n\nOnce the vector $\\mathbf{M}$ is determined, the spline is fully defined. To evaluate the spline at an arbitrary point $x \\in [x_i, x_{i+1}]$, we can use the following polynomial form derived from Taylor's theorem:\n$$\nS_i(x) = a_i(x-x_i)^3 + b_i(x-x_i)^2 + c_i(x-x_i) + d_i\n$$\nwhere the coefficients are given by:\n$d_i = f_i$\n$c_i = \\frac{f_{i+1}-f_i}{h} - \\frac{h}{6}(M_{i+1} + 2M_i)$\n$b_i = \\frac{M_i}{2}$\n$a_i = \\frac{M_{i+1}-M_i}{6h}$\n\nThe final step is to quantify the interpolation error for each spline. The error is measured as the maximum absolute difference between the spline and the true function, $\\max|S(x) - f(x)|$, over the interior of the domain, $[x_1, x_{n-1}]$. This is computed by sampling the error at $1001$ equally spaced points within this interval and finding the maximum value.\n\nThe algorithm for each test case is as follows:\n1.  Generate the grid $\\{x_i\\}$ and sample values $\\{f_i\\}$.\n2.  For each approximation order ($\\mathcal{O}(h^2)$ and $\\mathcal{O}(h)$):\n    a. Calculate the endpoint derivatives $d_0$ and $d_n$ using the corresponding finite difference formula.\n    b. Construct the matrix $A$ and the right-hand side vector $\\mathbf{b}$.\n    c. Solve the linear system $A\\mathbf{M}=\\mathbf{b}$ to find the second derivative values $M_i$.\n    d. Define a dense evaluation grid of $1001$ points in $[x_1, x_{n-1}]$.\n    e. For each point in the evaluation grid, identify its subinterval $[x_i, x_{i+1}]$, calculate the spline coefficients $(a_i, b_i, c_i, d_i)$, and evaluate $S(x)$.\n    f. Compute the maximum absolute error between the spline values and the true function values on the evaluation grid.\n3.  Calculate the ratio of the $\\mathcal{O}(h)$ error to the $\\mathcal{O}(h^2)$ error.\n4.  Report the $\\mathcal{O}(h^2)$ error, the $\\mathcal{O}(h)$ error, and their ratio.\n\nThis procedure is applied to all specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_spline_error(func, a, b, n, order):\n    \"\"\"\n    Computes the clamped cubic spline and its maximum interior error.\n    \n    Args:\n        func (callable): The true function f(x).\n        a (float): The start of the interval.\n        b (float): The end of the interval.\n        n (int): The number of subintervals.\n        order (int): The order of the finite difference approximation for endpoint slopes (1 or 2).\n\n    Returns:\n        float: The maximum absolute error on the interior interval [x_1, x_{n-1}].\n    \"\"\"\n    # 1. Set up the grid and function values\n    x = np.linspace(a, b, n + 1)\n    y = func(x)\n    h = (b - a) / n\n\n    # 2. Calculate endpoint derivatives using finite difference formulas\n    if order == 1:\n        # O(h) one-sided formulas\n        d0 = (y[1] - y[0]) / h\n        dn = (y[n] - y[n-1]) / h\n    elif order == 2:\n        # O(h^2) one-sided formulas\n        if n  2:\n            raise ValueError(\"n must be at least 2 for O(h^2) formula.\")\n        d0 = (-3 * y[0] + 4 * y[1] - y[2]) / (2 * h)\n        dn = (3 * y[n] - 4 * y[n-1] + y[n-2]) / (2 * h)\n    else:\n        raise ValueError(\"Order must be 1 or 2.\")\n\n    # 3. Set up the linear system A*M = B for the second derivatives M\n    # The matrix A is an (n+1)x(n+1) tridiagonal matrix\n    A = np.zeros((n + 1, n + 1))\n    A += np.diag(np.full(n + 1, 4))\n    A += np.diag(np.ones(n), k=1)\n    A += np.diag(np.ones(n), k=-1)\n    A[0, 0] = 2\n    A[n, n] = 2\n    A[0, 1] = 1\n    A[n, n-1] = 1\n\n    # The right-hand side vector B\n    B = np.zeros(n + 1)\n    B[0] = 6 / h * ((y[1] - y[0]) / h - d0)\n    B[n] = 6 / h * (dn - (y[n] - y[n-1]) / h)\n    for i in range(1, n):\n        B[i] = 6 / h**2 * (y[i-1] - 2 * y[i] + y[i+1])\n\n    # 4. Solve for the second derivatives M\n    M = np.linalg.solve(A, B)\n\n    # 5. Evaluate the spline and the error on a dense grid\n    # The error is computed on the interior of the interval [x_1, x_{n-1}]\n    num_eval_points = 1001\n    x_eval = np.linspace(x[1], x[n-1], num_eval_points)\n    y_true = func(x_eval)\n\n    # Vectorized spline evaluation\n    # Find the interval index for each evaluation point\n    indices = np.searchsorted(x, x_eval, side='right') - 1\n    # Handle case where evaluation point is exactly the last node\n    indices[indices == n] = n - 1\n\n    # Get parameters for each evaluation point's interval\n    x_i = x[indices]\n    f_i = y[indices]\n    f_i1 = y[indices + 1]\n    M_i = M[indices]\n    M_i1 = M[indices + 1]\n    \n    # Calculate coefficients of the cubic polynomial S_i(t) = at^3 + bt^2 + ct + d, where t = x - x_i\n    # Note: These are coefficients for the polynomial based at x_i, not normalized coefficients.\n    t = x_eval - x_i\n    \n    d_coeffs = f_i\n    c_coeffs = (f_i1 - f_i)/h - h/6 * (M_i1 + 2 * M_i)\n    b_coeffs = M_i / 2\n    a_coeffs = (M_i1 - M_i) / (6 * h)\n\n    y_spline = a_coeffs * t**3 + b_coeffs * t**2 + c_coeffs * t + d_coeffs\n    \n    # Calculate the maximum absolute error\n    max_error = np.max(np.abs(y_true - y_spline))\n    \n    return max_error\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {'func': np.sin, 'a': 0, 'b': np.pi, 'n': 10},\n        {'func': np.exp, 'a': 0, 'b': 1, 'n': 8},\n        {'func': lambda x: x**3, 'a': 0, 'b': 1, 'n': 8},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        func, a, b, n = case['func'], case['a'], case['b'], case['n']\n        \n        # Calculate error for O(h^2) derivative approximation\n        error_h2 = compute_spline_error(func, a, b, n, order=2)\n        \n        # Calculate error for O(h) derivative approximation\n        error_h1 = compute_spline_error(func, a, b, n, order=1)\n        \n        # Calculate the ratio\n        ratio = error_h1 / error_h2 if error_h2 != 0 else float('inf')\n        \n        all_results.append([error_h2, error_h1, ratio])\n\n    # Format the final output string as specified\n    # The default str() for a list creates the '[val1, val2, ...]' format\n    # with spaces after commas, which matches the problem description's example.\n    results_str = ','.join(map(str, all_results))\n    \n    # Print the final output in the exact required format.\n    print(f\"[{results_str}]\")\n\nsolve()\n```", "id": "3220799"}]}