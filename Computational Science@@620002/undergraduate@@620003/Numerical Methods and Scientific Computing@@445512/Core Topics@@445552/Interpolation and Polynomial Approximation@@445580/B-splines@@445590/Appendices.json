{"hands_on_practices": [{"introduction": "The most effective way to understand B-splines is to build them from the ground up. This practice guides you through implementing the fundamental Cox-de Boor recursion, the mathematical engine that generates B-spline curves. By creating a program that evaluates a curve and verifies its ability to pass through its endpoints, you will gain a concrete understanding of how knot vectors and control points work together to define a spline's shape and properties [@problem_id:3207506].", "problem": "You are asked to write a complete, runnable program that constructs and evaluates a Basis spline (B-spline) curve in a way that is guaranteed to interpolate its first and last control points. Your design must begin from the core recursive definition of B-spline basis functions and proceed to an algorithmic implementation that respects numerical stability and correctness.\n\nStart from the following fundamental base: the Cox–de Boor recursive definition of B-spline basis functions. For a given nondecreasing knot vector $\\{t_0, t_1, \\dots, t_m\\}$ and degree $p \\ge 0$, the basis functions $N_{i,p}(u)$ are defined recursively by\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1, & t_i \\le u < t_{i+1} \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\nand for $p \\ge 1$,\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u),\n$$\nwith the convention that terms with zero denominators are treated as zero. The parametric curve is then given by\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i,\n$$\nwhere $\\{\\mathbf{P}_0,\\dots,\\mathbf{P}_n\\}$ are the control points. When the knot vector is clamped (also called open), meaning the first and last knots are each repeated $p+1$ times, the curve is guaranteed to interpolate the first and last control points at the ends of the parametric domain. Your task is to implement an evaluation algorithm that uses these definitions and to demonstrate, through a test suite, that your curve passes exactly through its first and last control points.\n\nRequirements:\n- Implement B-spline curve evaluation based on the above recursive basis definition, using a numerically stable approach appropriate for advanced undergraduate numerical methods. You must ensure endpoint interpolation by using clamped knot vectors with multiplicity $p+1$ at both ends.\n- The domain of evaluation must be $[t_p, t_{m-p}]$. At $u = t_p$ and $u = t_{m-p}$, the curve must return $\\mathbf{P}_0$ and $\\mathbf{P}_n$, respectively.\n- Use Euclidean distance to compare vector equality up to a tolerance of $10^{-9}$, with zero relative tolerance. If the norm difference is less than or equal to $10^{-9}$, treat the values as equal.\n\nTest suite and parameters:\nFor each test case below, evaluate the curve at the left endpoint $u = t_p$ and the right endpoint $u = t_{m-p}$, and check whether these points match the first and last control points within the tolerance. Your program should produce one boolean per test case indicating whether both endpoint checks passed.\n\nLet each control point $\\mathbf{P}_i$ be a coordinate vector in either two dimensions or three dimensions as specified. The knot vectors are either explicitly given or must be constructed as clamped open-uniform knot vectors. An open-uniform clamped knot vector of length $m+1 = n + p + 2$ has the first $p+1$ entries equal to $0$, the last $p+1$ entries equal to $1$, and the interior knots evenly spaced in $(0,1)$.\n\n- Test case 1 (happy path, two dimensions, quadratic clamped open-uniform):\n  - Degree $p = 2$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_4$: $\\{(0,0),(1,2),(2,0.5),(3,3),(4,0)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=4$, $p=2$.\n- Test case 2 (boundary case with minimal interior knots, cubic clamped open-uniform, Bezier-like):\n  - Degree $p = 3$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_3$: $\\{(0,0),(1,2),(3,2),(4,0)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=3$, $p=3$.\n- Test case 3 (non-uniform clamped, two dimensions):\n  - Degree $p = 3$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_6$: $\\{(0,0),(1,1),(2,-1),(3,2),(4,-0.5),(5,1.5),(6,0)\\}$.\n  - Explicit clamped non-uniform knot vector: $\\{0,0,0,0,0.15,0.6,0.85,1,1,1,1\\}$.\n- Test case 4 (edge case, linear clamped open-uniform):\n  - Degree $p = 1$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_2$: $\\{(0,1),(1,0),(2,1.5)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=2$, $p=1$.\n- Test case 5 (three dimensions, cubic clamped open-uniform):\n  - Degree $p = 3$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_5$: $\\{(0,0,0),(1,2,1),(2,-1,2),(3,3,2),(4,0,1),(5,1,0)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=5$, $p=3$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\texttt{[true,false,true]}$. Use lowercase Python boolean formatting. The list must contain one boolean per test case, in the order listed above.", "solution": "The problem requires the implementation and verification of B-spline curve evaluation, demonstrating the endpoint interpolation property for clamped knot vectors. The solution is derived directly from the fundamental recursive definition of B-spline basis functions provided in the problem statement.\n\nA B-spline curve $\\mathbf{C}(u)$ of degree $p$ is a parametric curve defined as a weighted sum of $n+1$ control points $\\{\\mathbf{P}_0, \\dots, \\mathbf{P}_n\\}$:\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i\n$$\nThe weights are the B-spline basis functions $N_{i,p}(u)$, which are piecewise polynomials of degree $p$. Their definition depends on a non-decreasing sequence of real numbers $T = \\{t_0, t_1, \\dots, t_m\\}$ called the knot vector, where the relation $m = n+p+1$ must hold. The basis functions are defined by the Cox–de Boor recursion formula.\n\nFor $p=0$:\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1, & \\text{if } t_i \\le u < t_{i+1} \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\nThis definition implies that for any interval of zero length, where $t_i = t_{i+1}$, the basis function $N_{i,0}(u)$ is always $0$. A special consideration is required for the parameter value $u$ at the very end of the domain. If the curve domain is $[t_p, t_{n+1}]$, then for $u = t_{n+1}$, the relevant non-zero degree-$0$ basis function is taken to be $N_{n,0}(t_{n+1})=1$.\n\nFor $p \\ge 1$:\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u)\n$$\nThe problem specifies that if a denominator in this expression is zero, the corresponding term is treated as zero.\n\nThe core of the task is to implement an algorithm for $\\mathbf{C}(u)$ based on these definitions and verify that for a clamped knot vector, $\\mathbf{C}(t_p) = \\mathbf{P}_0$ and $\\mathbf{C}(t_{n+1}) = \\mathbf{P}_n$. A clamped knot vector has its first $p+1$ knots equal and its last $p+1$ knots equal. This structure ensures that $N_{0,p}(t_p)=1$ and $N_{n,p}(t_{n+1})=1$, while all other basis functions $N_{i,p}$ are zero at the respective endpoints, leading to interpolation.\n\nThe overall algorithm proceeds as follows for each test case:\n1.  **Parameter Setup**: The degree $p$ and the set of $n+1$ control points $\\{\\mathbf{P}_i\\}$ are defined.\n2.  **Knot Vector Construction**: The knot vector $T$ is constructed. For cases requiring a clamped open-uniform knot vector, the first $p+1$ knots are set to $0$, the last $p+1$ knots are set to $1$, and the $n-p$ interior knots are spaced uniformly in the interval $(0,1)$. The number of knots is $m+1 = n+p+2$.\n3.  **Curve Evaluation at Endpoints**:\n    *   The curve is evaluated at the left endpoint of its domain, $u_{left} = t_p$.\n    *   The curve is evaluated at the right endpoint of its domain, $u_{right} = t_{n+1}$.\n    *   The evaluation itself, $\\mathbf{C}(u)$, is performed by a function that calculates $\\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i$.\n4.  **Basis Function Calculation**: The value of each basis function $N_{i,p}(u)$ is calculated using a recursive function that directly implements the Cox-de Boor formula. To ensure computational feasibility, this recursive function is memoized (a form of dynamic programming), preventing redundant calculations of the same basis function values. The implementation of the base case $N_{i,0}(u)$ must carefully handle the half-open interval and the special case at the domain's right endpoint.\n5.  **Verification**: The computed point $\\mathbf{C}(u_{left})$ is compared to the first control point $\\mathbf{P}_0$, and $\\mathbf{C}(u_{right})$ is compared to the last control point $\\mathbf{P}_n$. The comparison is done by calculating the Euclidean distance between the vectors. If the distance is within the specified tolerance of $10^{-9}$ for both endpoints, the test case is considered passed.\n\nThe implementation encapsulates these steps. A main function iterates through the test suite, calling helper functions to construct knot vectors and evaluate the B-spline curve. The evaluation function `b_spline_eval` uses a nested helper function `_basis_function` to compute the basis functions recursively. This nested structure allows the recursive function to be clean while having access to the parameter $u$, the knot vector $T$, and the memoization dictionary, avoiding the use of global state. The result of each test case (a boolean value) is collected and printed in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_clamped_uniform_knot_vector(n, p):\n    \"\"\"\n    Constructs a clamped open-uniform knot vector.\n    The domain for the interior knots is (0, 1).\n    \n    Args:\n        n (int): The number of control points minus 1.\n        p (int): The degree of the B-spline.\n        \n    Returns:\n        np.ndarray: The knot vector of length n + p + 2.\n    \"\"\"\n    num_knots = n + p + 2\n    T = np.zeros(num_knots, dtype=float)\n    \n    num_interior_knots = n - p\n    if num_interior_knots > 0:\n      denominator = float(n - p + 1)\n      T[p + 1 : n + 1] = np.arange(1, num_interior_knots + 1) / denominator\n    \n    T[n + 1:] = 1.0\n    return T\n\ndef b_spline_eval(u, p, control_points, T):\n    \"\"\"\n    Evaluates the B-spline curve at a parameter value u using the recursive\n    Cox-de Boor basis function definition with memoization.\n    \n    Args:\n        u (float): The parameter value.\n        p (int): The degree of the B-spline.\n        control_points (np.ndarray): Array of control points.\n        T (np.ndarray): The knot vector.\n        \n    Returns:\n        np.ndarray: The computed point on the curve.\n    \"\"\"\n    n = len(control_points) - 1\n    memo = {}\n\n    def _basis_function(i, deg):\n        \"\"\"\n        Computes the value of the B-spline basis function N_i,deg(u) via\n        a memoized recursion. This is a nested function to capture u, T, n, and memo.\n        \"\"\"\n        if (i, deg) in memo:\n            return memo[(i, deg)]\n\n        if deg == 0:\n            # The curve domain is [t_p, t_{n+1}]. At the right boundary u = t_{n+1},\n            # the convention is that u falls in the last interval [t_n, t_{n+1}],\n            # making N_{n,0}(t_{n+1}) = 1.\n            if u == T[n + 1] and i == n:\n                res = 1.0\n            else:\n                # Standard definition for half-open interval [t_i, t_{i+1}).\n                # This is 0 if t_i == t_{i+1}.\n                res = 1.0 if T[i] <= u < T[i + 1] else 0.0\n            memo[(i, deg)] = res\n            return res\n\n        # Recursive step\n        term1 = 0.0\n        den1 = T[i + deg] - T[i]\n        if den1 != 0.0:\n            term1 = ((u - T[i]) / den1) * _basis_function(i, deg - 1)\n\n        term2 = 0.0\n        den2 = T[i + deg + 1] - T[i + 1]\n        if den2 != 0.0:\n            term2 = ((T[i + deg + 1] - u) / den2) * _basis_function(i + 1, deg - 1)\n\n        res = term1 + term2\n        memo[(i, deg)] = res\n        return res\n\n    curve_point = np.zeros_like(control_points[0], dtype=float)\n    for i in range(n + 1):\n        basis_val = _basis_function(i, p)\n        # Optimization: only add if the basis function is non-zero\n        if basis_val > 1e-12: # Check against small tolerance\n            curve_point += basis_val * control_points[i]\n            \n    return curve_point\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify endpoint interpolation.\n    \"\"\"\n    test_cases = [\n        # Case 1: 2D quadratic\n        {\n            \"p\": 2,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [2, 0.5], [3, 3], [4, 0]\n            ]),\n            \"knot_vector\": None \n        },\n        # Case 2: 2D cubic, Bezier-like\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [3, 2], [4, 0]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 3: 2D cubic, non-uniform knots\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 1], [2, -1], [3, 2], [4, -0.5], [5, 1.5], [6, 0]\n            ]),\n            \"knot_vector\": np.array([0, 0, 0, 0, 0.15, 0.6, 0.85, 1, 1, 1, 1])\n        },\n        # Case 4: 2D linear\n        {\n            \"p\": 1,\n            \"control_points\": np.array([\n                [0, 1], [1, 0], [2, 1.5]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 5: 3D cubic\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0, 0], [1, 2, 1], [2, -1, 2], [3, 3, 2], [4, 0, 1], [5, 1, 0]\n            ]),\n            \"knot_vector\": None\n        }\n    ]\n\n    results = []\n    tolerance = 1e-9\n\n    for case in test_cases:\n        p = case[\"p\"]\n        P = case[\"control_points\"]\n        n = len(P) - 1\n\n        if case[\"knot_vector\"] is None:\n            T = build_clamped_uniform_knot_vector(n, p)\n        else:\n            T = case[\"knot_vector\"]\n        \n        # Endpoints of the parametric domain for a clamped knot vector\n        u_left = T[p]\n        u_right = T[n + 1]\n\n        # Evaluate curve at endpoints\n        C_left = b_spline_eval(u_left, p, P, T)\n        C_right = b_spline_eval(u_right, p, P, T)\n\n        # Verify interpolation\n        dist_left = np.linalg.norm(C_left - P[0])\n        dist_right = np.linalg.norm(C_right - P[-1])\n\n        check_left = dist_left <= tolerance\n        check_right = dist_right <= tolerance\n        \n        results.append(check_left and check_right)\n\n    # Format output as required\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```", "id": "3207506"}, {"introduction": "B-spline curves are intimately linked to their control polygon, but this relationship can be subtle. This exercise challenges the common intuition derived from the convex hull property, demonstrating that a B-spline function can remain positive even when one of its control coefficients is negative. By analyzing the interplay between the partition of unity and the magnitudes of the basis functions, you will uncover a deeper principle of how control points blend to form the final curve [@problem_id:3207399].", "problem": "Consider a scalar B-spline function of degree $p$ defined on a nondecreasing knot vector $\\mathbf{U}$ by\n$$\ns(t) \\;=\\; \\sum_{i=0}^{n} c_i\\,N_{i,p}(t),\n$$\nwhere $\\{c_i\\}_{i=0}^{n}$ are real control coefficients and $\\{N_{i,p}\\}_{i=0}^{n}$ are the B-spline basis functions defined recursively by the Cox–de Boor formula\n$$\nN_{i,0}(t) \\;=\\; \\begin{cases} 1, & t_i \\le t < t_{i+1}, \\\\ 0, & \\text{otherwise}, \\end{cases}\n\\qquad\nN_{i,p}(t) \\;=\\; \\frac{t - t_i}{t_{i+p} - t_i}\\,N_{i,p-1}(t) \\;+\\; \\frac{t_{i+p+1} - t}{t_{i+p+1} - t_{i+1}}\\,N_{i+1,p-1}(t),\n$$\nwith the usual convention that a fraction with zero denominator is interpreted as zero. It is a well-tested fact that for a valid knot vector, each $N_{i,p}(t)$ is nonnegative and the basis functions satisfy the partition of unity $\\sum_{i=0}^{n} N_{i,p}(t) = 1$ for all $t$ in the parametric domain.\n\nWork with the open uniform knot vector of degree $p=2$ (quadratic) and $n+1=5$ control coefficients:\n$$\n\\mathbf{U} \\;=\\; (0,\\,0,\\,0,\\,1,\\,2,\\,3,\\,3,\\,3),\n$$\nso the parameter domain is $t\\in[0,3]$, and write $N_{i,2}(t)$ for the quadratic basis functions. You are asked to identify an explicit example of $s(t)$ that is strictly positive for all $t\\in[0,3]$ even though at least one control coefficient $c_i$ is negative, and to recognize a correct first-principles explanation of how this can happen.\n\nWhich of the following options correctly exhibits such an $s(t)$ and gives a valid reasoning? Select all that apply.\n\n- A. Use $p=2$, $\\mathbf{U}=(0,0,0,1,2,3,3,3)$, and control coefficients $(c_0,c_1,c_2,c_3,c_4)=(1,\\,1,\\,-0.1,\\,1,\\,1)$. Explanation: Because each $N_{i,2}(t)\\ge 0$ and $\\sum_i N_{i,2}(t)=1$, one has\n$$\ns(t)\\;=\\;\\sum_{i\\neq 2} 1\\cdot N_{i,2}(t)\\;+\\;(-0.1)\\,N_{2,2}(t)\\;=\\;1-(1.1)\\,N_{2,2}(t).\n$$\nFor a quadratic uniform B-spline basis function, the pointwise maximum satisfies $\\max_t N_{2,2}(t)=\\tfrac{3}{4}$, hence $s(t)\\ge 1-1.1\\cdot\\tfrac{3}{4}=0.175>0$ for all $t\\in[0,3]$.\n\n- B. Use $p=2$, $\\mathbf{U}=(0,0,0,1,2,3,3,3)$, and control coefficients $(c_0,c_1,c_2,c_3,c_4)=(-0.1,\\,1,\\,1,\\,1,\\,1)$. Explanation: Since the negative coefficient is small, the nonnegativity and partition of unity ensure $s(t)>0$ for all $t\\in[0,3]$.\n\n- C. Use $p=2$, $\\mathbf{U}=(0,0,0,1,2,3,3,3)$, and control coefficients $(c_0,c_1,c_2,c_3,c_4)=(0.2,\\,0.2,\\,-0.9,\\,0.2,\\,0.2)$. Explanation: The nonnegativity and partition of unity guarantee that the positive coefficients outweigh the negative one, so $s(t)>0$ on $[0,3]$.\n\n- D. Use $p=1$ (linear), $\\mathbf{U}=(0,\\,0,\\,1,\\,2,\\,2)$, and control coefficients $(c_0,c_1,c_2)=(1,\\,-0.1,\\,1)$. Explanation: The nonnegativity and partition of unity of the linear basis imply $s(t)>0$ for all $t\\in[0,2]$ even though $c_1<0$.\n\nExplain your selection in terms of the core properties of B-spline basis functions and their implications for $s(t)$. Your reasoning should start from the Cox–de Boor definition and well-tested facts (nonnegativity, partition of unity, local support, and the effect of clamped end knots) and should not assume any unproven shortcut formulas about $s(t)$.", "solution": "The problem statement is a valid exercise in the theory of B-splines. It is scientifically grounded, well-posed, objective, and self-contained. All definitions and parameters are standard and consistent. I will proceed with the solution.\n\nThe problem asks for an example of a B-spline curve $s(t) = \\sum_{i=0}^{n} c_i N_{i,p}(t)$ that is strictly positive for all $t$ in its domain, despite having at least one negative control coefficient $c_i < 0$. The setup specifies a quadratic B-spline ($p=2$) with $n+1=5$ control points (so $n=4$) over the open uniform knot vector $\\mathbf{U} = (0,0,0,1,2,3,3,3)$. The parametric domain is $t \\in [t_p, t_{n+1}] = [t_2, t_5] = [0, 3]$.\n\nThe core properties of B-splines that we will use are:\n1.  **Nonnegativity**: $N_{i,p}(t) \\ge 0$ for all $i,p,t$.\n2.  **Partition of Unity**: $\\sum_{i=0}^{n} N_{i,p}(t) = 1$ for $t \\in [t_p, t_{n+1}]$.\n3.  **Local Support**: $N_{i,p}(t)$ is non-zero only for $t \\in [t_i, t_{i+p+1})$.\n4.  **Endpoint Interpolation**: For an open knot vector where the first $p+1$ knots are identical and the last $p+1$ knots are identical (a clamped spline), the curve interpolates the first and last control points. Specifically, $s(t_p) = c_0$ and $s(t_{n+1})=c_n$. In our case, $t_p=t_2=0$ and $t_{n+1}=t_5=3$, so $s(0)=c_0$ and $s(3)=c_4$.\n\nWe can prove the endpoint interpolation property. At $t=0=t_2$, for a basis function $N_{i,2}(t)$ to be non-zero, its support $[t_i, t_{i+3})$ must contain $t=0$. This is true for $i=0, 1, 2$. By the Cox-de Boor recursion on the knots $(t_0, t_1, t_2) = (0,0,0)$, we can show that $N_{0,2}(0)=1$, $N_{1,2}(0)=0$, and $N_{2,2}(0)=0$. Therefore, $s(0) = \\sum_{i=0}^4 c_i N_{i,2}(0) = c_0 N_{0,2}(0) = c_0$. A symmetric argument at $t=3$ with knots $(t_5, t_6, t_7)=(3,3,3)$ shows $N_{4,2}(3)=1$ and other basis functions are zero, leading to $s(3)=c_4$.\n\nLet us now evaluate each option.\n\n### Option A Analysis\nThe coefficients are $(c_0, c_1, c_2, c_3, c_4)=(1, 1, -0.1, 1, 1)$. One coefficient, $c_2 = -0.1$, is negative.\nThe spline is given by $s(t) = 1 \\cdot N_{0,2}(t) + 1 \\cdot N_{1,2}(t) - 0.1 \\cdot N_{2,2}(t) + 1 \\cdot N_{3,2}(t) + 1 \\cdot N_{4,2}(t)$.\nAt the endpoints, using the interpolation property:\n$s(0) = c_0 = 1 > 0$.\n$s(3) = c_4 = 1 > 0$.\nFor the interior, we use the reasoning provided in the option, which is based on the partition of unity:\n$$\ns(t) = \\sum_{i=0}^4 c_i N_{i,2}(t) = \\sum_{i \\neq 2} 1 \\cdot N_{i,2}(t) + (-0.1) N_{2,2}(t)\n$$\nUsing $\\sum_{i \\neq 2} N_{i,2}(t) = 1 - N_{2,2}(t)$ from the partition of unity property:\n$$\ns(t) = (1 - N_{2,2}(t)) - 0.1 N_{2,2}(t) = 1 - 1.1 N_{2,2}(t)\n$$\nFor $s(t)$ to be strictly positive, we require $1 - 1.1 N_{2,2}(t) > 0$, which implies $N_{2,2}(t) < 1/1.1 \\approx 0.90909$. This requires finding the maximum value of $N_{2,2}(t)$. The basis function $N_{2,2}(t)$ is defined by the knots $(t_2, t_3, t_4, t_5) = (0, 1, 2, 3)$, which are uniformly spaced. This is a standard uniform quadratic B-spline basis function. Let's derive it from the Cox-de Boor formula.\n$N_{2,2}(t) = \\frac{t - t_2}{t_4 - t_2}N_{2,1}(t) + \\frac{t_5 - t}{t_5 - t_3}N_{3,1}(t) = \\frac{t}{2}N_{2,1}(t) + \\frac{3-t}{2}N_{3,1}(t)$.\nThe required linear basis functions are:\n- $N_{2,1}(t)$ on knots $(t_2, t_3, t_4)=(0,1,2)$: $N_{2,1}(t) = \\frac{t-0}{1-0}N_{2,0}(t) + \\frac{2-t}{2-1}N_{3,0}(t)$. This gives $N_{2,1}(t) = t$ for $t \\in [0,1)$ and $N_{2,1}(t) = 2-t$ for $t \\in [1,2)$.\n- $N_{3,1}(t)$ on knots $(t_3, t_4, t_5)=(1,2,3)$: $N_{3,1}(t) = \\frac{t-1}{2-1}N_{3,0}(t) + \\frac{3-t}{3-2}N_{4,0}(t)$. This gives $N_{3,1}(t) = t-1$ for $t \\in [1,2)$ and $N_{3,1}(t) = 3-t$ for $t \\in [2,3]$.\nCombining these results:\n- For $t \\in [0,1)$: $N_{2,2}(t) = \\frac{t}{2}(t) = \\frac{1}{2}t^2$.\n- For $t \\in [1,2)$: $N_{2,2}(t) = \\frac{t}{2}(2-t) + \\frac{3-t}{2}(t-1) = \\frac{1}{2}(-2t^2+6t-3)$.\n- For $t \\in [2,3]$: $N_{2,2}(t) = \\frac{3-t}{2}(3-t) = \\frac{1}{2}(3-t)^2$.\nTo find the maximum of $N_{2,2}(t)$, we check the quadratic piece on $[1,2)$. The vertex is at $t = -6/(2(-2)) = 1.5$.\nAt $t=1.5$, $N_{2,2}(1.5) = \\frac{1}{2}(-2(1.5)^2 + 6(1.5) - 3) = \\frac{1}{2}(-4.5 + 9 - 3) = \\frac{1.5}{2} = \\frac{3}{4}$.\nSo, $\\max_t N_{2,2}(t) = \\frac{3}{4} = 0.75$. This value is less than $1/1.1$.\nThe minimum value of $s(t)$ is $s(1.5) = 1 - 1.1 \\times N_{2,2}(1.5) = 1 - 1.1 \\times \\frac{3}{4} = 1 - \\frac{3.3}{4} = 1 - 0.825 = 0.175$.\nSince the minimum value of $s(t)$ is $0.175$, which is strictly positive, $s(t) > 0$ for all $t \\in [0,3]$. The example and the reasoning are correct.\nVerdict: **Correct**.\n\n### Option B Analysis\nThe coefficients are $(-0.1, 1, 1, 1, 1)$. The first coefficient, $c_0=-0.1$, is negative.\nUsing the endpoint interpolation property $s(0)=c_0$, we immediately find:\n$s(0) = -0.1$.\nSince $s(0)$ is negative, the function $s(t)$ is not strictly positive for all $t \\in [0,3]$. The explanation that the \"small\" negative coefficient is outweighed is fallacious because it ignores the fact that the corresponding basis function $N_{0,2}(t)$ reaches a maximum of $1$ at $t=0$, giving its coefficient full effect.\nVerdict: **Incorrect**.\n\n### Option C Analysis\nThe coefficients are $(0.2, 0.2, -0.9, 0.2, 0.2)$. The coefficient $c_2 = -0.9$ is negative.\nAt the endpoints, $s(0)=c_0=0.2>0$ and $s(3)=c_4=0.2>0$.\nWe analyze the interior using the same logic as in Option A. Let $C=0.2$ be the value of the positive coefficients.\n$$\ns(t) = C \\sum_{i \\neq 2} N_{i,2}(t) + c_2 N_{2,2}(t) = C(1 - N_{2,2}(t)) + c_2 N_{2,2}(t) = C + (c_2 - C) N_{2,2}(t)\n$$\nPlugging in the values $C=0.2$ and $c_2=-0.9$:\n$$\ns(t) = 0.2 + (-0.9 - 0.2) N_{2,2}(t) = 0.2 - 1.1 N_{2,2}(t)\n$$\nFor $s(t)>0$, we need $0.2 - 1.1 N_{2,2}(t) > 0$, or $N_{2,2}(t) < 0.2/1.1 \\approx 0.1818$.\nFrom the analysis for Option A, we know $\\max_t N_{2,2}(t) = 3/4 = 0.75$. Since $0.75$ is much larger than $0.1818$, the function $s(t)$ will become negative. The minimum value of $s(t)$ is:\n$s_{min} = 0.2 - 1.1 \\times (3/4) = 0.2 - 0.825 = -0.625$.\nSince $s(t)$ becomes negative, this option is not a valid example. The provided explanation is an unsubstantiated hand-waving argument.\nVerdict: **Incorrect**.\n\n### Option D Analysis\nThis option changes the problem parameters to degree $p=1$ and knot vector $\\mathbf{U}=(0,0,1,2,2)$. This violates the premise \"Work with the open uniform knot vector of degree $p=2$...\". Therefore, this option does not answer the question posed.\nHowever, for completeness, we can analyze the claim on its own merits. For $p=1$ with $\\mathbf{U}=(0,0,1,2,2)$, the number of control points is $n+1=3$ ($n=2$). The domain is $t \\in [t_1, t_3] = [0,2]$. The coefficients are $(c_0, c_1, c_2) = (1, -0.1, 1)$.\nThe spline is $s(t) = 1 \\cdot N_{0,1}(t) - 0.1 \\cdot N_{1,1}(t) + 1 \\cdot N_{2,1}(t)$.\nThe reasoning from Option A gives $s(t) = 1 - 1.1 N_{1,1}(t)$.\nThe basis function $N_{1,1}(t)$ is defined on knots $(t_1, t_2, t_3) = (0,1,2)$. It is the standard linear B-spline \"hat function\":\n$N_{1,1}(t) = t$ for $t \\in [0,1)$ and $N_{1,1}(t) = 2-t$ for $t \\in [1,2]$.\nThe maximum value is $\\max_t N_{1,1}(t) = N_{1,1}(1) = 1$.\nThe minimum value of $s(t)$ is therefore $s(1) = 1 - 1.1 \\times 1 = -0.1$.\nThe spline is not strictly positive. This shows that the reasoning in option A works for quadratic splines because the basis function's maximum is less than $1$, a condition not met by the interior linear basis functions. Thus, this option is incorrect on two grounds: it does not conform to the problem's setup, and its own claim is factually wrong.\nVerdict: **Incorrect**.\n\nBased on the detailed analysis, only Option A provides a correct example and a valid explanation.", "answer": "$$\\boxed{A}$$", "id": "3207399"}, {"introduction": "Beyond their use in computer graphics, B-splines are a cornerstone of modern numerical analysis and simulation. This advanced practice showcases their power in function approximation by guiding you through an $L^2$ projection of a smooth function onto a spline space. By implementing this projection and conducting a convergence study, you will computationally verify the theoretical approximation rates, providing a tangible link between spline theory and its application in scientific computing [@problem_id:3099508].", "problem": "You are tasked with designing and implementing a numerical experiment that demonstrates the approximation power of B-splines in the setting of introduction to computational science. The experiment must be defined, executed, and its results reported by a complete, runnable program. The experiment focuses on projecting a smooth target function onto a spline space and studying how the approximation error scales under uniform mesh refinement.\n\nThe domain is the closed interval $[0,1]$. The target function is $f(x) = \\sin(10 x)$, where the argument of the sine function is measured in radians. The spline space is the B-spline space of degree $p$ with an open uniform knot vector on $[0,1]$. The knot vector should have $M$ uniform elements, where $h = 1/M$ is the mesh size, the endpoints $0$ and $1$ are each repeated $p+1$ times, and the interior knots are placed at the uniform subdivision points $x = i h$ for $i = 1,2,\\ldots,M-1$. The number of basis functions in this space is $n = M + p$.\n\nThe projection is the $L^2$ (square-integrable) projection. Let $S_{p,h}$ denote the spline space of degree $p$ and mesh size $h$. The $L^2$ projection $s \\in S_{p,h}$ of $f$ is characterized by the Galerkin orthogonality conditions with respect to the spline basis: for every basis function $v \\in S_{p,h}$, the residual satisfies $\\int_0^1 (f(x) - s(x)) \\, v(x) \\, dx = 0$. You must implement the normalized B-spline basis evaluation from first principles using the standard recursive definition (Cox–de Boor recursion) and assemble the linear system that enforces these orthogonality conditions on the coefficients of $s$. All integrations in the assembly and in the error computation must be performed numerically using Gaussian quadrature of sufficiently high order on each subinterval so that the quadrature error is negligible relative to the spline approximation error. Use Gauss–Legendre quadrature on each element, with at least $50$ quadrature points per element. All computations must be in double precision. Angles must be interpreted in radians, and norms and integrals carry no physical unit because the domain and function are nondimensional.\n\nThe $L^2$ error is the $L^2$ norm of the difference $f - s$, defined by $\\| f - s \\|_{L^2(0,1)} = \\left( \\int_0^1 (f(x) - s(x))^2 \\, dx \\right)^{1/2}$. Implement a reliable numerical evaluation of this error via element-wise Gaussian quadrature.\n\nYou must run a convergence study in which $h$ is refined uniformly and the error is measured for each refinement. For a fixed degree $p$, consider the mesh sizes corresponding to $M \\in \\{8, 16, 32, 64\\}$. For each degree $p \\in \\{0, 1, 2, 3\\}$, compute the list of $L^2$ errors for these mesh sizes and then compute the observed convergence rate by performing a linear least-squares fit of $\\log(\\text{error})$ versus $\\log(h)$; the fitted slope is the observed rate. The asymptotic expectation is that the rate should be approximately $p+1$ for smooth $f$.\n\nYour program must implement:\n- Construction of the open uniform knot vector for given $p$ and $M$.\n- Evaluation of all normalized B-spline basis functions of degree $p$ on a given set of points via the Cox–de Boor recursion.\n- Assembly of the $L^2$ projection linear system using numerical quadrature.\n- Solution of the linear system for the spline coefficients and computation of the $L^2$ error via quadrature.\n- Computation of the observed convergence rate from the $(h, \\text{error})$ data.\n\nTest suite specification:\n- Case $1$: $p = 0$ with $M \\in \\{8, 16, 32, 64\\}$.\n- Case $2$: $p = 1$ with $M \\in \\{8, 16, 32, 64\\}$.\n- Case $3$: $p = 2$ with $M \\in \\{8, 16, 32, 64\\}$.\n- Case $4$: $p = 3$ with $M \\in \\{8, 16, 32, 64\\}$.\n\nFor each case, report the observed convergence rate as a single floating-point number rounded to three decimal places. These four values together constitute the final output.\n\nFinal output format:\nYour program should produce a single line of output containing the four observed rates, ordered by increasing $p$, formatted as a comma-separated list enclosed in square brackets, for example, $[r_0,r_1,r_2,r_3]$, where each $r_p$ is a float rounded to three decimals. No additional text or lines should be printed.", "solution": "We begin from the fundamental definitions of B-splines and the $L^2$ projection.\n\nLet $[0,1]$ be partitioned uniformly into $M$ elements with mesh size $h = 1/M$. For a given degree $p \\in \\mathbb{N}_0$, we consider the open uniform knot vector. Denote the knot vector by $\\{t_i\\}_{i=0}^{K-1}$, where the endpoints are repeated $p+1$ times and the interior knots are placed at $i h$ for $i=1,2,\\ldots,M-1$. Explicitly,\n$$\nt_0 = t_1 = \\cdots = t_p = 0,\\quad\nt_{p+1} = h,\\quad\nt_{p+2} = 2h,\\quad \\ldots,\\quad t_{p+M-1} = (M-1)h,\\quad\nt_{K-p-1} = t_{K-p} = \\cdots = t_{K-1} = 1,\n$$\nwith $K = (M-1) + 2(p+1)$ and the number of basis functions $n = K - p - 1 = M + p$. The normalized B-spline basis functions $\\{N_{i,p}(x)\\}_{i=0}^{n-1}$ are defined recursively by the Cox–de Boor recursion. The base case for piecewise constants ($p = 0$) is the indicator of the half-open support interval:\n$$\nN_{i,0}(x) = \n\\begin{cases}\n1 & \\text{if } t_i \\le x < t_{i+1}, \\\\\n0 & \\text{otherwise}.\n\\end{cases}\n$$\nThe recursive definition for $p \\ge 1$ is\n$$\nN_{i,p}(x) = \\alpha_{i,p}(x)\\, N_{i,p-1}(x) + \\beta_{i,p}(x)\\, N_{i+1,p-1}(x),\n$$\nwith blending coefficients\n$$\n\\alpha_{i,p}(x) = \n\\begin{cases}\n\\dfrac{x - t_i}{t_{i+p} - t_i} & \\text{if } t_{i+p} > t_i,\\\\\n0 & \\text{otherwise},\n\\end{cases}\n\\qquad\n\\beta_{i,p}(x) =\n\\begin{cases}\n\\dfrac{t_{i+p+1} - x}{t_{i+p+1} - t_{i+1}} & \\text{if } t_{i+p+1} > t_{i+1},\\\\\n0 & \\text{otherwise}.\n\\end{cases}\n$$\nThese definitions imply that the basis functions are nonnegative, have minimal local support on $[t_i, t_{i+p+1}]$, and form a partition of unity on $[0,1]$.\n\nLet $S_{p,h} = \\operatorname{span}\\{N_{i,p}\\}_{i=0}^{n-1}$ be the spline space. The $L^2$ projection $s \\in S_{p,h}$ of a given function $f$ is defined by the Galerkin orthogonality:\n$$\n\\int_0^1 \\left( f(x) - s(x) \\right) v(x) \\, dx = 0 \\quad \\text{for all } v \\in S_{p,h}.\n$$\nWriting $s(x) = \\sum_{i=0}^{n-1} c_i\\, N_{i,p}(x)$ and choosing the test functions $v = N_{j,p}$ for $j = 0,1,\\ldots,n-1$, we obtain the linear system\n$$\n\\sum_{i=0}^{n-1} c_i \\int_0^1 N_{i,p}(x) N_{j,p}(x) \\, dx = \\int_0^1 f(x) N_{j,p}(x) \\, dx,\\quad j=0,\\ldots,n-1.\n$$\nDefining the mass matrix $M \\in \\mathbb{R}^{n \\times n}$ and the right-hand side $b \\in \\mathbb{R}^n$ by\n$$\nM_{j,i} = \\int_0^1 N_{i,p}(x) N_{j,p}(x) \\, dx,\\qquad\nb_j = \\int_0^1 f(x) N_{j,p}(x) \\, dx,\n$$\nthe coefficients $c = (c_0,\\ldots,c_{n-1})^\\top$ satisfy\n$$\nM c = b.\n$$\nThe $L^2$ approximation error is then\n$$\n\\| f - s \\|_{L^2(0,1)} = \\left( \\int_0^1 \\left( f(x) - \\sum_{i=0}^{n-1} c_i N_{i,p}(x) \\right)^2 \\, dx \\right)^{1/2}.\n$$\n\nNumerical integration is performed by Gauss–Legendre quadrature of order $q$ on each element. Let the reference Gauss–Legendre points and weights on $[-1,1]$ be $\\{\\xi_k, w_k\\}_{k=1}^q$. For the element interval $[a,b]$, the affine mapping $x = \\frac{b-a}{2} \\xi + \\frac{a+b}{2}$ yields the physical quadrature points $\\{x_k\\}$ and weights $\\{ \\hat{w}_k = \\frac{b-a}{2} w_k \\}$. Summing over all elements, integrals over $[0,1]$ are approximated by\n$$\n\\int_0^1 g(x)\\, dx \\approx \\sum_{e=1}^{M} \\sum_{k=1}^q \\hat{w}_{e,k}\\, g(x_{e,k}).\n$$\nIn our setting, we take $q \\ge 50$ to ensure that the quadrature error is negligible; this choice safely handles the polynomial products in the mass matrix and the oscillatory term $\\sin(10 x)$ in the right-hand side.\n\nThe algorithmic steps are:\n1. For given $p$ and $M$, construct the open uniform knot vector $\\{t_i\\}$ and compute the number of basis functions $n$.\n2. Create the global quadrature points and weights by looping over elements and mapping the $q$-point Gauss–Legendre rule to each element.\n3. Evaluate all basis functions $\\{N_{i,p}\\}_{i=0}^{n-1}$ at all quadrature points using the Cox–de Boor recursion. Organize the evaluations into a matrix $B \\in \\mathbb{R}^{n \\times N_q}$, where $N_q = M \\cdot q$ is the total number of quadrature points.\n4. Assemble the mass matrix using the weighted inner products,\n$$\nM = B \\, \\operatorname{diag}(w) \\, B^\\top,\n$$\nwhere $w \\in \\mathbb{R}^{N_q}$ are the global quadrature weights.\n5. Assemble the right-hand side by\n$$\nb = B \\left( w \\odot f(x) \\right),\n$$\nwhere $f(x) = \\sin(10 x)$ evaluated at the quadrature points and $\\odot$ denotes pointwise multiplication.\n6. Solve the linear system $M c = b$ for the coefficients $c$ in double precision.\n7. Compute the spline approximation values at the quadrature points by $s(x) = \\sum_i c_i N_{i,p}(x)$, which vectorizes to $s = B^\\top c$.\n8. Compute the $L^2$ error by\n$$\n\\| f - s \\|_{L^2(0,1)} \\approx \\left( \\sum_{k=1}^{N_q} w_k \\left( f(x_k) - s(x_k) \\right)^2 \\right)^{1/2}.\n$$\n9. For each degree $p \\in \\{0,1,2,3\\}$ and mesh sizes $M \\in \\{8,16,32,64\\}$, compute the errors, then perform a least-squares fit of $\\log(\\text{error})$ versus $\\log(h)$ to estimate the slope $r_p$. Concretely, if we denote $X = \\log(h)$ and $Y = \\log(\\text{error})$, then the fitted slope is\n$$\nr_p = \\frac{\\sum_i (X_i - \\bar{X})(Y_i - \\bar{Y})}{\\sum_i (X_i - \\bar{X})^2},\n$$\nwhere the sums run over the refinement levels and bars denote averages. In practice, this is obtained via polynomial fitting of degree one.\n\nBy approximation theory for spline spaces, for sufficiently smooth $f$ and uniform refinement, the $L^2$ projection error satisfies\n$$\n\\| f - s \\|_{L^2(0,1)} \\le C\\, h^{p+1} \\, |f|_{H^{p+1}(0,1)},\n$$\nfor some constant $C$ independent of $h$, which implies an observed convergence rate close to $p+1$. The test suite includes $p=0$ (piecewise constants) as a significant edge case, and increasingly higher degrees up to $p=3$, and it ranges from relatively coarse meshes ($M=8$) to fine meshes ($M=64$), covering the happy path and boundary conditions at the endpoints via the open knot construction.\n\nThe program outputs the four observed rates, rounded to three decimals, as a single comma-separated list enclosed in square brackets, ordered by increasing $p$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef open_uniform_knots(M: int, p: int) -> np.ndarray:\n    \"\"\"\n    Construct open uniform knot vector on [0,1] with M elements and degree p.\n    Endpoints are repeated p+1 times. Interior knots are at i/M for i=1..M-1.\n    \"\"\"\n    interior = np.linspace(0.0, 1.0, M + 1)\n    # Exclude endpoints from interior\n    interior = interior[1:-1]\n    # Build knot vector\n    knots = np.concatenate([\n        np.zeros(p + 1),\n        interior,\n        np.ones(p + 1)\n    ])\n    return knots\n\ndef bspline_basis_matrix(knots: np.ndarray, p: int, x: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate all normalized B-spline basis functions of degree p defined by 'knots'\n    at points x using Cox-de Boor recursion. Returns shape (n_basis, len(x)).\n    \"\"\"\n    K = len(knots)\n    n_basis = K - p - 1\n    N = np.zeros((n_basis, x.size), dtype=np.float64)\n\n    # Base case p=0: indicator of half-open intervals [t_i, t_{i+1})\n    # Gauss-Legendre points lie inside elements, so endpoint handling is minimal.\n    for i in range(n_basis):\n        left = knots[i]\n        right = knots[i + 1]\n        # Indicator: include left, exclude right\n        mask = (x >= left) & (x < right)\n        N[i, mask] = 1.0\n    # Handle the very end point x == 1 (if present) to ensure partition of unity\n    # Assign to the last basis.\n    if np.any(np.isclose(x, knots[-1])):\n        N[-1, np.isclose(x, knots[-1])] = 1.0\n\n    # Recursion for p>=1\n    for d in range(1, p + 1):\n        N_next = np.zeros_like(N)\n        for i in range(n_basis):\n            # First term\n            denom1 = knots[i + d] - knots[i]\n            if denom1 > 0.0:\n                coeff1 = (x - knots[i]) / denom1\n                N_next[i, :] += coeff1 * N[i, :]\n            # Second term (uses N_{i+1, d-1})\n            if i + 1 < n_basis:\n                denom2 = knots[i + d + 1] - knots[i + 1]\n                if denom2 > 0.0:\n                    coeff2 = (knots[i + d + 1] - x) / denom2\n                    N_next[i, :] += coeff2 * N[i + 1, :]\n        N = N_next\n\n    return N\n\ndef element_quadrature_points_weights(M: int, q: int) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Build global quadrature points and weights by mapping q-point Gauss-Legendre\n    rule to each of the M uniform elements on [0,1].\n    \"\"\"\n    # Gauss-Legendre on [-1,1]\n    xi, w = np.polynomial.legendre.leggauss(q)\n    points = []\n    weights = []\n    h = 1.0 / M\n    for e in range(M):\n        a = e * h\n        b = (e + 1) * h\n        # Affine map: x = 0.5*(b-a)*xi + 0.5*(b+a)\n        x_e = 0.5 * (b - a) * xi + 0.5 * (b + a)\n        w_e = 0.5 * (b - a) * w\n        points.append(x_e)\n        weights.append(w_e)\n    x_all = np.concatenate(points)\n    w_all = np.concatenate(weights)\n    return x_all, w_all\n\ndef l2_projection_error(p: int, M: int, q: int = 50) -> float:\n    \"\"\"\n    Compute L2 projection of f(x)=sin(10x) onto spline space of degree p with M elements,\n    and return the L2 error norm via high-order Gaussian quadrature.\n    \"\"\"\n    # Build knots and basis dimension\n    knots = open_uniform_knots(M, p)\n    # Global quadrature\n    xq, wq = element_quadrature_points_weights(M, q)\n    # Evaluate basis matrix\n    B = bspline_basis_matrix(knots, p, xq)  # shape (n_basis, Nq)\n    # Assemble mass matrix M = B * diag(wq) * B^T\n    BW = B * wq[np.newaxis, :]\n    Mmat = BW @ B.T\n    # Assemble RHS b = B * (wq * f(xq))\n    fx = np.sin(10.0 * xq)  # radians\n    b = B @ (wq * fx)\n    # Solve for coefficients\n    c = np.linalg.solve(Mmat, b)\n    # Approximation values at quadrature points\n    sx = B.T @ c\n    # L2 error\n    err = np.sqrt(np.sum(wq * (fx - sx) ** 2))\n    return float(err)\n\ndef convergence_rate(p: int, Ms: list[int], q: int = 50) -> float:\n    \"\"\"\n    Compute observed convergence rate via least-squares fit of log(error) vs log(h).\n    \"\"\"\n    hs = np.array([1.0 / M for M in Ms], dtype=np.float64)\n    errs = np.array([l2_projection_error(p, M, q=q) for M in Ms], dtype=np.float64)\n    X = np.log(hs)\n    Y = np.log(errs)\n    # Least squares slope\n    slope = np.polyfit(X, Y, 1)[0]\n    return float(slope)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_degrees = [0, 1, 2, 3]\n    Ms = [8, 16, 32, 64]\n    q = 50  # quadrature points per element\n\n    results = []\n    for p in test_degrees:\n        rate = convergence_rate(p, Ms, q=q)\n        results.append(f\"{rate:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3099508"}]}