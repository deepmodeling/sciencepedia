{"hands_on_practices": [{"introduction": "Parametric equations do more than just trace a geometric path; they describe motion along that path over time. This distinction is fundamental and has critical real-world implications, such as determining if two moving objects will collide. This exercise [@problem_id:2140263] challenges you to analyze the paths of two robots to distinguish between a path intersection, where their routes cross, and a collision, where they are at the same place at the same time, a core concept in robotics and motion planning.", "problem": "Two autonomous mobile robots, 'Pathfinder' and 'Rover', are programmed to navigate on a large, flat factory floor. Their positions are described by a Cartesian coordinate system where units are in meters.\n\nPathfinder's path, $C_1$, is described by the parametric equations for its position $(x_1, y_1)$ at its internal time $t \\ge 0$ (in seconds):\n$$x_1(t) = 2t+1$$\n$$y_1(t) = t^2 - 2$$\n\nRover's path, $C_2$, is described by the parametric equations for its position $(x_2, y_2)$ at its internal time $s \\ge 0$ (in seconds):\n$$x_2(s) = s-1$$\n$$y_2(s) = s+1$$\n\nThe robots' movements are analyzed for two distinct scenarios: path intersection (do their geometric paths cross?) and collision (are they at the same place at the same time?). A path intersection occurs if there exist time parameters $t$ and $s$ (not necessarily equal) for which the positions are the same. A collision occurs only if their positions are the same for the *same* value of the time parameter, assuming their clocks are synchronized ($t=s$).\n\nBased on your analysis of the robots' paths, which of the following statements is correct?\n\nA. The paths do not intersect.\n\nB. The paths intersect at the point $(3+2\\sqrt{6}, 5+2\\sqrt{6})$, and the robots will collide at this point if their clocks are synchronized.\n\nC. The paths intersect at the point $(3+2\\sqrt{6}, 5+2\\sqrt{6})$, but the robots will not collide even if their clocks are synchronized.\n\nD. The paths intersect at a point other than $(3+2\\sqrt{6}, 5+2\\sqrt{6})$, and the robots will collide at this other point if their clocks are synchronized.\n\nE. The paths intersect at a point other than $(3+2\\sqrt{6}, 5+2\\sqrt{6})$, but the robots will not collide at this other point even if their clocks are synchronized.", "solution": "We are given two parametrically defined paths on the plane. Pathfinder follows $C_{1}$ with $(x_{1}(t), y_{1}(t))$ where $x_{1}(t) = 2t + 1$ and $y_{1}(t) = t^{2} - 2$ for $t \\ge 0$. Rover follows $C_{2}$ with $(x_{2}(s), y_{2}(s))$ where $x_{2}(s) = s - 1$ and $y_{2}(s) = s + 1$ for $s \\ge 0$.\n\nTo determine whether the geometric paths intersect, we must find $t \\ge 0$ and $s \\ge 0$ such that\n$$\nx_{1}(t) = x_{2}(s), \\quad y_{1}(t) = y_{2}(s).\n$$\nEquating the $x$-coordinates gives\n$$\n2t + 1 = s - 1 \\quad \\Rightarrow \\quad s = 2t + 2.\n$$\nEquating the $y$-coordinates gives\n$$\nt^{2} - 2 = s + 1 \\quad \\Rightarrow \\quad s = t^{2} - 3.\n$$\nSetting these expressions for $s$ equal yields\n$$\n2t + 2 = t^{2} - 3 \\quad \\Rightarrow \\quad t^{2} - 2t - 5 = 0.\n$$\nSolving the quadratic equation,\n$$\nt = \\frac{2 \\pm \\sqrt{4 + 20}}{2} = \\frac{2 \\pm \\sqrt{24}}{2} = 1 \\pm \\sqrt{6}.\n$$\nSince $t \\ge 0$, we accept $t = 1 + \\sqrt{6}$ and reject $t = 1 - \\sqrt{6} < 0$. Then\n$$\ns = 2t + 2 = 2(1 + \\sqrt{6}) + 2 = 4 + 2\\sqrt{6} \\ge 0.\n$$\nThe intersection point is computed from either path; using $C_{1}$,\n$$\nx = 2t + 1 = 2(1 + \\sqrt{6}) + 1 = 3 + 2\\sqrt{6}, \\quad y = t^{2} - 2 = (1 + \\sqrt{6})^{2} - 2 = 5 + 2\\sqrt{6}.\n$$\nThus the paths intersect at $(3 + 2\\sqrt{6}, 5 + 2\\sqrt{6})$.\n\nTo determine if they collide with synchronized clocks, we require the same time parameter $t = s$ and the same position:\n$$\n2t + 1 = t - 1, \\quad t^{2} - 2 = t + 1.\n$$\nFrom the first equation,\n$$\n2t + 1 = t - 1 \\quad \\Rightarrow \\quad t = -2,\n$$\nwhich violates $t \\ge 0$. Therefore, no nonnegative $t$ satisfies both coordinate equalities simultaneously, and a collision does not occur under synchronized clocks.\n\nHence, the correct statement is that the paths intersect at $(3 + 2\\sqrt{6}, 5 + 2\\sqrt{6})$, but the robots will not collide even with synchronized clocks.", "answer": "$$\\boxed{C}$$", "id": "2140263"}, {"introduction": "The power of parametric equations shines when modeling complex dynamic systems, such as the intricate patterns generated by a spirograph. This practice [@problem_id:3261316] guides you through deriving the parametric equations for a hypotrochoidâ€”the curve traced by a point on a circle rolling inside another. You will then apply differential calculus to compute the curvature, a precise measure of how sharply the curve bends, connecting the physics of motion to rigorous geometric analysis.", "problem": "A circle of radius $r$ rolls without slipping inside a fixed circle of radius $R$. A tracer point is attached at a distance $d$ from the center of the rolling circle. Let $\\theta$ (in radians) denote the polar angle of the center of the rolling circle with respect to the center of the fixed circle, measured from the positive $x$-axis. At $\\theta=0$, the center of the rolling circle lies on the positive $x$-axis and the tracer point lies on the same axis further to the right, so that the initial position of the tracer is at $(R-r+d,\\,0)$. Starting solely from the rolling-without-slipping condition (equality of arc lengths) and the definition of curvature as the magnitude of the rate of change of the unit tangent with respect to arc length, perform the following:\n\n- Derive the parametric equations $x(\\theta)$ and $y(\\theta)$ for the tracer path for the case of rolling inside (a hypotrochoid), expressed in terms of $R$, $r$, $d$, and $\\theta$.\n- Specialize to $R=7$, $r=3$, and $d=1$, and compute the curvature $\\kappa$ of the tracer path at $\\theta=0$.\n\nExpress the final answer as an exact value. No approximation or rounding is required. Angles are in radians.", "solution": "The problem is validated as scientifically grounded, well-posed, objective, and self-contained. It describes the generation of a hypotrochoid curve and asks for its parametric equations and curvature at a specific point, which are standard topics in differential geometry and kinematics. All necessary parameters and initial conditions are provided.\n\n### Part 1: Derivation of the Parametric Equations\n\nLet the fixed circle be centered at the origin $O=(0,0)$ of a Cartesian coordinate system. Its radius is $R$. The rolling circle has radius $r$ and its center is denoted by $C$. It rolls without slipping inside the fixed circle.\n\nThe center $C$ of the rolling circle is always at a distance $R-r$ from the origin $O$. Let $\\theta$ be the polar angle of the position vector $\\vec{OC}$, measured from the positive $x$-axis. The coordinates of the center $C$ are therefore given by:\n$$ \\vec{r}_C(\\theta) = ((R-r)\\cos\\theta, (R-r)\\sin\\theta) $$\n\nA tracer point $P$ is attached to the rolling circle at a distance $d$ from its center $C$. The position vector of the tracer point $P$ is given by $\\vec{r}_P = \\vec{OC} + \\vec{CP}$. We need to determine the vector $\\vec{CP}$ as a function of $\\theta$.\n\nThe \"rolling without slipping\" condition implies that the arc length traversed on the circumference of the fixed circle is equal to the arc length rolled on the circumference of the rolling circle.\nLet the initial point of contact be $K_0$ at $(R,0)$ at $\\theta=0$. As the center $C$ moves such that $\\vec{OC}$ makes an angle $\\theta$ with the $x$-axis, the new point of contact $K$ is on the line segment $OC$ extended to the fixed circle's edge. The arc length on the fixed circle between $K_0$ and $K$ is $s = R\\theta$.\n\nThis arc length must be equal to the arc length on the rolling circle. Let $\\phi$ be the angle of rotation of the rolling circle with respect to its center $C$. This rotation is measured relative to a moving reference frame. Let's analyze the orientation of the vector $\\vec{CP}$.\n\nAt $\\theta=0$, the center $C$ is at $(R-r, 0)$. The tracer point $P$ is at $(R-r+d, 0)$. Thus, at $\\theta=0$, the vector $\\vec{CP}$ is $(d, 0)$, pointing along the positive $x$-axis.\n\nAs the system evolves, the line segment $OC$ rotates by an angle $\\theta$ counter-clockwise. In the absence of rolling, the vector $\\vec{CP}$ would also rotate by $\\theta$. However, the circle also rotates about its own center $C$ due to the rolling condition. The arc length rolled is $s=R\\theta$. This corresponds to a rotation of the rolling circle by an angle $\\phi = \\frac{s}{r} = \\frac{R\\theta}{r}$. As the center $C$ moves counter-clockwise, the rolling circle itself rotates clockwise relative to the line $OC$.\n\nThe initial orientation angle of the vector $\\vec{CP}$ with the $x$-axis is $0$. The rotation of the frame $OC$ adds $\\theta$. The rolling motion subtracts $\\phi$. Therefore, the angle $\\alpha$ of the vector $\\vec{CP}$ with respect to the positive $x$-axis is:\n$$ \\alpha(\\theta) = \\theta - \\phi = \\theta - \\frac{R\\theta}{r} = \\left(1 - \\frac{R}{r}\\right)\\theta = -\\frac{R-r}{r}\\theta $$\nThe vector $\\vec{CP}$ has magnitude $d$ and angle $\\alpha(\\theta)$. Its components are:\n$$ \\vec{CP}(\\theta) = (d\\cos(\\alpha(\\theta)), d\\sin(\\alpha(\\theta))) = \\left(d\\cos\\left(-\\frac{R-r}{r}\\theta\\right), d\\sin\\left(-\\frac{R-r}{r}\\theta\\right)\\right) $$\nUsing the identities $\\cos(-u) = \\cos(u)$ and $\\sin(-u) = -\\sin(u)$, we get:\n$$ \\vec{CP}(\\theta) = \\left(d\\cos\\left(\\frac{R-r}{r}\\theta\\right), -d\\sin\\left(\\frac{R-r}{r}\\theta\\right)\\right) $$\nThe position vector of the tracer point $P$ is the sum of $\\vec{r}_C$ and $\\vec{CP}$:\n$$ \\vec{r}_P(\\theta) = (x(\\theta), y(\\theta)) = ((R-r)\\cos\\theta + d \\cos\\left(\\frac{R-r}{r}\\theta\\right), (R-r)\\sin\\theta - d\\sin\\left(\\frac{R-r}{r}\\theta\\right)) $$\nThe parametric equations are:\n$$ x(\\theta) = (R-r)\\cos\\theta + d \\cos\\left(\\frac{R-r}{r}\\theta\\right) $$\n$$ y(\\theta) = (R-r)\\sin\\theta - d\\sin\\left(\\frac{R-r}{r}\\theta\\right) $$\nAt $\\theta=0$, $x(0) = (R-r)(1) + d(1) = R-r+d$ and $y(0) = (R-r)(0) - d(0) = 0$. This matches the initial condition $(R-r+d, 0)$.\n\n### Part 2: Curvature Calculation\n\nWe are given the specific values $R=7$, $r=3$, and $d=1$.\nThe parametric equations become:\n$$ R-r = 7-3 = 4 $$\n$$ \\frac{R-r}{r} = \\frac{4}{3} $$\n$$ x(\\theta) = 4\\cos\\theta + \\cos\\left(\\frac{4}{3}\\theta\\right) $$\n$$ y(\\theta) = 4\\sin\\theta - \\sin\\left(\\frac{4}{3}\\theta\\right) $$\nThe curvature $\\kappa$ is defined as the magnitude of the rate of change of the unit tangent vector $\\vec{T}$ with respect to arc length $s$, i.e., $\\kappa = \\left|\\frac{d\\vec{T}}{ds}\\right|$.\nUsing the chain rule, $\\frac{d\\vec{T}}{ds} = \\frac{d\\vec{T}/d\\theta}{ds/d\\theta}$. The arc length element is $ds = |\\vec{v}(\\theta)|d\\theta$, where $\\vec{v}(\\theta) = \\frac{d\\vec{r}_P}{d\\theta}$ is the velocity vector. So $\\frac{ds}{d\\theta} = |\\vec{v}(\\theta)|$.\nThe curvature is $\\kappa(\\theta) = \\frac{|d\\vec{T}/d\\theta|}{|\\vec{v}(\\theta)|}$.\nThe unit tangent vector is $\\vec{T} = \\vec{v}/|\\vec{v}|$. Differentiating with respect to $\\theta$ gives $\\frac{d\\vec{T}}{d\\theta} = \\frac{\\vec{a}|\\vec{v}|^2 - \\vec{v}(\\vec{v}\\cdot\\vec{a})}{|\\vec{v}|^3}$, where $\\vec{a}(\\theta)=\\frac{d\\vec{v}}{d\\theta}$ is the acceleration vector.\n\nAt a point where the velocity $\\vec{v}$ and acceleration $\\vec{a}$ are orthogonal (i.e., $\\vec{v} \\cdot \\vec{a} = 0$), the expression simplifies. Let's compute the derivatives at $\\theta=0$.\nFirst derivatives (velocity components):\n$$ x'(\\theta) = -4\\sin\\theta - \\frac{4}{3}\\sin\\left(\\frac{4}{3}\\theta\\right) $$\n$$ y'(\\theta) = 4\\cos\\theta - \\frac{4}{3}\\cos\\left(\\frac{4}{3}\\theta\\right) $$\nAt $\\theta=0$:\n$$ x'(0) = -4\\sin(0) - \\frac{4}{3}\\sin(0) = 0 $$\n$$ y'(0) = 4\\cos(0) - \\frac{4}{3}\\cos(0) = 4 - \\frac{4}{3} = \\frac{8}{3} $$\nSo the velocity vector at $\\theta=0$ is $\\vec{v}(0) = (0, \\frac{8}{3})$.\n\nSecond derivatives (acceleration components):\n$$ x''(\\theta) = -4\\cos\\theta - \\left(\\frac{4}{3}\\right)^2\\cos\\left(\\frac{4}{3}\\theta\\right) = -4\\cos\\theta - \\frac{16}{9}\\cos\\left(\\frac{4}{3}\\theta\\right) $$\n$$ y''(\\theta) = -4\\sin\\theta + \\frac{16}{9}\\sin\\left(\\frac{4}{3}\\theta\\right) $$\nAt $\\theta=0$:\n$$ x''(0) = -4\\cos(0) - \\frac{16}{9}\\cos(0) = -4 - \\frac{16}{9} = -\\frac{36+16}{9} = -\\frac{52}{9} $$\n$$ y''(0) = -4\\sin(0) + \\frac{16}{9}\\sin(0) = 0 $$\nSo the acceleration vector at $\\theta=0$ is $\\vec{a}(0) = (-\\frac{52}{9}, 0)$.\n\nThe dot product $\\vec{v}(0) \\cdot \\vec{a}(0) = (0)(-\\frac{52}{9}) + (\\frac{8}{3})(0) = 0$. The vectors are orthogonal.\nThe tangential component of acceleration, $\\frac{d|\\vec{v}|}{d\\theta} = \\frac{\\vec{v}\\cdot\\vec{a}}{|\\vec{v}|}$, is zero at $\\theta=0$.\nThis simplifies the calculation of $\\frac{d\\vec{T}}{d\\theta}$.\n$$ \\frac{d\\vec{T}}{d\\theta}\\bigg|_{\\theta=0} = \\frac{\\vec{a}(0)|\\vec{v}(0)|^2 - \\vec{v}(0)(0)}{|\\vec{v}(0)|^3} = \\frac{\\vec{a}(0)}{|\\vec{v}(0)|} $$\nThe curvature is then:\n$$ \\kappa(0) = \\frac{|d\\vec{T}/d\\theta|_{\\theta=0}|}{|\\vec{v}(0)|} = \\frac{|\\vec{a}(0)/|\\vec{v}(0)||}{|\\vec{v}(0)|} = \\frac{|\\vec{a}(0)|}{|\\vec{v}(0)|^2} $$\nLet's compute the magnitudes:\n$$ |\\vec{v}(0)| = \\sqrt{0^2 + \\left(\\frac{8}{3}\\right)^2} = \\frac{8}{3} $$\n$$ |\\vec{a}(0)| = \\sqrt{\\left(-\\frac{52}{9}\\right)^2 + 0^2} = \\frac{52}{9} $$\nNow, we compute the curvature $\\kappa(0)$:\n$$ \\kappa(0) = \\frac{|\\vec{a}(0)|}{|\\vec{v}(0)|^2} = \\frac{52/9}{(8/3)^2} = \\frac{52/9}{64/9} = \\frac{52}{64} $$\nTo simplify the fraction, we find the greatest common divisor of $52$ and $64$. Both are divisible by $4$.\n$$ 52 = 4 \\times 13 $$\n$$ 64 = 4 \\times 16 $$\n$$ \\kappa(0) = \\frac{13}{16} $$\nThe curvature of the tracer path at $\\theta=0$ is $\\frac{13}{16}$.\n\nAlternatively, one can use the standard formula for curvature for a parametric curve $(x(\\theta), y(\\theta))$:\n$$ \\kappa(\\theta) = \\frac{|x'(\\theta)y''(\\theta) - y'(\\theta)x''(\\theta)|}{(x'(\\theta)^2 + y'(\\theta)^2)^{3/2}} $$\nAt $\\theta=0$, we have $x'(0)=0$ and $y''(0)=0$.\n$$ \\kappa(0) = \\frac{|0 - y'(0)x''(0)|}{(0^2 + y'(0)^2)^{3/2}} = \\frac{|-y'(0)x''(0)|}{|y'(0)|^3} = \\frac{|x''(0)|}{y'(0)^2} $$\nSubstituting the values we found:\n$$ |x''(0)| = \\left|-\\frac{52}{9}\\right| = \\frac{52}{9} $$\n$$ y'(0)^2 = \\left(\\frac{8}{3}\\right)^2 = \\frac{64}{9} $$\n$$ \\kappa(0) = \\frac{52/9}{64/9} = \\frac{52}{64} = \\frac{13}{16} $$\nThis confirms the result.", "answer": "$$\\boxed{\\frac{13}{16}}$$", "id": "3261316"}, {"introduction": "In fields like computer graphics and data science, we often work with curves defined by a large number of points, making them computationally expensive to store and render. A crucial task is to simplify these curves by reducing the number of points while preserving the essential shape within a given tolerance. This hands-on coding challenge [@problem_id:3261322] asks you to implement a fundamental algorithm for polyline simplification, applying geometric principles to solve a practical data compression problem.", "problem": "You are given a parametric planar curve specified by a continuous mapping $C:[a,b]\\to\\mathbb{R}^2$, where $C(t)=(x(t),y(t))$. You will uniformly sample this curve at $N$ points to form an ordered sequence of points $P_0,P_1,\\dots,P_{N-1}$, where $P_i=C(t_i)$ with $t_i=a+i\\Delta t$ and $\\Delta t=(b-a)/(N-1)$. The goal is to algorithmically simplify this sampled polyline to a subsequence $Q_0,Q_1,\\dots,Q_{M-1}$ where each $Q_j$ is one of the original $P_i$, with $Q_0=P_0$ and $Q_{M-1}=P_{N-1}$, such that the simplified polyline stays within a prescribed tolerance $\\,\\epsilon\\,$ under the following constraint.\n\nStart from the fundamental definition of Euclidean distance in $\\mathbb{R}^2$, namely that for points $A=(a_x,a_y)$ and $B=(b_x,b_y)$ the distance is $\\|A-B\\|_2=\\sqrt{(a_x-b_x)^2+(a_y-b_y)^2}$. Define the distance from a point $R$ to a closed line segment with endpoints $A$ and $B$ as the minimal Euclidean distance from $R$ to any point on that segment. Using only these definitions, construct a method that selects a subsequence of the sampled points satisfying the following admissibility condition: for each consecutive pair of retained points $Q_j=P_{i_j}$ and $Q_{j+1}=P_{i_{j+1}}$ with $i_j<i_{j+1}$, every original point $P_k$ with $i_j<k<i_{j+1}$ must have distance at most $\\epsilon$ to the line segment with endpoints $Q_j$ and $Q_{j+1}$. Your method must always include the first and last sampled points, must return indices in increasing order, and must terminate in finite time. The intent is to develop a procedure in the spirit of recursive deviation refinement for polylines, without assuming any specialized shortcut formulas beyond the fundamental definitions above.\n\nYour program must implement this method for two-dimensional curves and apply it to the test suite below. Angles are to be interpreted in radians. No physical units are involved. All computations of trigonometric functions must use input measured in radians.\n\nTest suite specification:\n- Case $1$ (curved shape, moderate tolerance): $x(t)=\\cos(t)$, $y(t)=\\sin(t)$, with $t\\in[0,\\tfrac{\\pi}{2}]$, sampled at $N=101$ uniformly spaced parameters. Use $\\epsilon=0.01$.\n- Case $2$ (piecewise linear with a corner, near-zero tolerance): $x(t)$ and $y(t)$ defined piecewise for $t\\in[0,1]$ as follows. For $t\\in[0,0.5]$, set $x(t)=t$ and $y(t)=0$. For $t\\in(0.5,1]$, set $x(t)=0.5$ and $y(t)=2(t-0.5)$. Sample at $N=51$ uniformly spaced parameters. Use $\\epsilon=10^{-12}$.\n- Case $3$ (oscillatory curve, very large tolerance): $x(t)=t$, $y(t)=\\sin(3t)$, with $t\\in[0,2\\pi]$, sampled at $N=401$ uniformly spaced parameters. Use $\\epsilon=100$.\n\nFor each case, your program must:\n- Sample the curve to obtain $P_0,\\dots,P_{N-1}$.\n- Compute the simplified subsequence that satisfies the admissibility condition with the specified $\\epsilon$.\n- Return the retained indices as zero-based integers relative to the sampled sequence, in strictly increasing order.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is itself a list of integers representing the retained zero-based indices for that case. Concretely, the output must have the form $[\\,[i^{(1)}_0,\\dots,i^{(1)}_{m_1-1}],\\,[i^{(2)}_0,\\dots,i^{(2)}_{m_2-1}],\\,[i^{(3)}_0,\\dots,i^{(3)}_{m_3-1}]\\,]$ with no spaces other than those implicitly included by commas, and where all indices are integers. Angles are in radians, and no other units apply.", "solution": "The problem set forth is to develop and implement a polyline simplification algorithm based on fundamental geometric principles. The problem is well-defined, mathematically sound, and computationally tractable. It is a classic problem in computational geometry, often addressed by the Ramer-Douglas-Peucker (RDP) algorithm. We shall construct this method from the first principles specified.\n\nA problem is valid if it is scientifically grounded, well-posed, and objective.\n- **Scientific Grounding**: The problem is based on established principles of Euclidean geometry and calculus, specifically dealing with parametric curves, sampling, and distance metrics. The definitions provided, such as Euclidean distance and distance from a point to a line segment, are standard and correct.\n- **Well-Posedness**: The goal is clearly stated: to find a subsequence of points satisfying a specific tolerance criterion. The inputs (curve definitions, sampling parameters, tolerance $\\epsilon$) are fully specified for each test case. The Ramer-Douglas-Peucker algorithm, which the problem statement implicitly describes, is guaranteed to terminate and produce a unique simplification for a given polyline and tolerance.\n- **Objectivity**: The problem is expressed using precise mathematical language, free from ambiguity or subjective claims.\n\nThe problem is therefore deemed **valid** as it meets all criteria for a solvable scientific problem.\n\nThe solution is developed in two primary stages: first, formalizing the distance calculation as required, and second, constructing the recursive simplification algorithm.\n\n### 1. Distance from a Point to a Line Segment\n\nThe problem requires calculating the minimum Euclidean distance from a point $R$ to a closed line segment with endpoints $A$ and $B$. Let the points be represented by vectors from the origin, denoted as $\\vec{r}$, $\\vec{a}$, and $\\vec{b}$.\n\nA point on the infinite line passing through $A$ and $B$ can be parameterized as $L(u) = \\vec{a} + u(\\vec{b} - \\vec{a})$ for a scalar parameter $u \\in \\mathbb{R}$. The point on this line closest to $R$ is the orthogonal projection of $R$ onto the line. This occurs when the vector from the projected point to $R$ is orthogonal to the direction vector of the line, $\\vec{v} = \\vec{b} - \\vec{a}$.\n\n$$(\\vec{r} - L(u)) \\cdot (\\vec{b} - \\vec{a}) = 0$$\n$$(\\vec{r} - (\\vec{a} + u(\\vec{b} - \\vec{a}))) \\cdot (\\vec{b} - \\vec{a}) = 0$$\n$$(\\vec{r} - \\vec{a}) \\cdot (\\vec{b} - \\vec{a}) - u(\\vec{b} - \\vec{a}) \\cdot (\\vec{b} - \\vec{a}) = 0$$\n\nSolving for $u$ yields:\n$$u = \\frac{(\\vec{r} - \\vec{a}) \\cdot (\\vec{b} - \\vec{a})}{\\|\\vec{b} - \\vec{a}\\|^2}$$\n\nThis parameter $u$ determines the location of the closest point on the infinite line. For a closed line segment, the parameter must be restricted to $u \\in [0, 1]$. This leads to three cases:\n\n1.  If $u \\in [0, 1]$, the projection falls on the segment. The closest point is $P_{proj} = \\vec{a} + u(\\vec{b} - \\vec{a})$, and the distance is $\\|\\vec{r} - P_{proj}\\|$.\n2.  If $u < 0$, the closest point on the segment is the endpoint $A$. The distance is $\\|\\vec{r} - \\vec{a}\\|$.\n3.  If $u > 1$, the closest point on the segment is the endpoint $B$. The distance is $\\|\\vec{r} - \\vec{b}\\|$.\n\nA special case arises if $A$ and $B$ are coincident, i.e., $\\|\\vec{b} - \\vec{a}\\|^2 = 0$. In this scenario, the segment is a single point, and the distance is simply $\\|\\vec{r} - \\vec{a}\\|$.\n\n### 2. Recursive Deviation Refinement Algorithm\n\nThe problem asks for a method in the spirit of \"recursive deviation refinement,\" which is a descriptive name for the Ramer-Douglas-Peucker algorithm. Given a sequence of points $P_0, \\dots, P_{N-1}$, the goal is to find a simplified subsequence that starts with $P_0$ and ends with $P_{N-1}$.\n\nThe algorithm operates on a segment of the polyline, defined by a start index $i_{start}$ and an end index $i_{end}$. Initially, this is the full polyline from index $0$ to $N-1$.\n\n1.  Consider the line segment connecting the endpoints $P_{i_{start}}$ and $P_{i_{end}}$.\n2.  For every intermediate point $P_k$ with $i_{start} < k < i_{end}$, calculate its perpendicular distance to the line segment $(P_{i_{start}}, P_{i_{end}})$ using the method derived above.\n3.  Find the point $P_{i_{max}}$ that has the maximum distance, $d_{max}$, from the segment.\n4.  Compare $d_{max}$ with the specified tolerance $\\epsilon$:\n    a. If $d_{max} \\le \\epsilon$, all intermediate points are considered acceptably close to the line segment. The simplification for this portion of the polyline is just the two endpoints, $P_{i_{start}}$ and $P_{i_{end}}$.\n    b. If $d_{max} > \\epsilon$, the point $P_{i_{max}}$ is a significant feature and must be retained. The simplification process is then applied recursively to the two sub-polylines: one from $P_{i_{start}}$ to $P_{i_{max}}$, and the other from $P_{i_{max}}$ to $P_{i_{end}}$.\n\nThe set of all retained points (the initial endpoints plus all points like $P_{i_{max}}$ that were found to exceed the tolerance) forms the final simplified polyline. The process is guaranteed to terminate because each recursive step operates on a strictly smaller sub-problem, and the number of points is finite.\n\nFor implementation, a stack-based iterative approach is functionally equivalent to recursion and avoids potential deep recursion limits.\n\n### Algorithm Implementation\n\nThe overall program will proceed as follows for each test case:\n1.  **Sampling**: Generate the $N$ points of the curve $C(t)$ by creating a uniform grid of $t_i$ values in $[a, b]$ and evaluating $(x(t_i), y(t_i))$.\n2.  **Simplification**:\n    a. Initialize a set of indices to keep, `kept_indices`, with $\\{0, N-1\\}$.\n    b. Push the initial index pair `(0, N-1)` onto a stack.\n    c. While the stack is not empty:\n        i. Pop an index pair `(start, end)`.\n        ii. Find the index `max_dist_idx` and value `d_max` for the point between `start` and `end` with the greatest distance to the segment from `points[start]` to `points[end]`.\n        iii. If a farthest point exists (i.e., `start + 1 < end`) and `d_max > epsilon`, add `max_dist_idx` to `kept_indices` and push the new pairs `(start, max_dist_idx)` and `(max_dist_idx, end)` onto the stack.\n3.  **Output**: Convert the final set `kept_indices` to a sorted list and format it as requested.\n\nThis structured approach correctly implements the specified requirements from first principles.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef point_segment_distance(point, start, end):\n    \"\"\"\n    Calculate the Euclidean distance from a point to a line segment.\n\n    Args:\n        point (np.ndarray): The point, shape (2,).\n        start (np.ndarray): The start point of the segment, shape (2,).\n        end (np.ndarray): The end point of the segment, shape (2,).\n\n    Returns:\n        float: The distance from the point to the segment.\n    \"\"\"\n    # Handle the case where the segment is a single point\n    if np.array_equal(start, end):\n        return np.linalg.norm(point - start)\n\n    line_vec = end - start\n    pnt_vec = point - start\n    \n    line_len_sq = np.dot(line_vec, line_vec)\n    \n    # Project point onto the line containing the segment.\n    # The parameter t is the projection factor.\n    t = np.dot(pnt_vec, line_vec) / line_len_sq\n    \n    if t  0.0:\n        # Projection is outside the segment, closer to the start point.\n        return np.linalg.norm(point - start)\n    elif t > 1.0:\n        # Projection is outside the segment, closer to the end point.\n        return np.linalg.norm(point - end)\n    else:\n        # Projection is on the segment.\n        projection = start + t * line_vec\n        return np.linalg.norm(point - projection)\n\ndef simplify_polyline(points, epsilon):\n    \"\"\"\n    Simplify a polyline using the Ramer-Douglas-Peucker algorithm.\n\n    Args:\n        points (np.ndarray): An array of points, shape (N, 2).\n        epsilon (float): The tolerance for simplification.\n\n    Returns:\n        list: A sorted list of indices of the points to keep.\n    \"\"\"\n    n_points = len(points)\n    if n_points  2:\n        return list(range(n_points))\n\n    # Use a stack for an iterative implementation of the algorithm\n    stack = [(0, n_points - 1)]\n    kept_indices = {0, n_points - 1}\n\n    while stack:\n        start_idx, end_idx = stack.pop()\n\n        # Find the point with the maximum distance\n        d_max = 0.0\n        max_dist_idx = -1\n\n        for i in range(start_idx + 1, end_idx):\n            d = point_segment_distance(points[i], points[start_idx], points[end_idx])\n            if d > d_max:\n                d_max = d\n                max_dist_idx = i\n\n        # If max distance is greater than epsilon, recursively simplify\n        if max_dist_idx != -1 and d_max > epsilon:\n            kept_indices.add(max_dist_idx)\n            # Push the two new sub-segments onto the stack\n            if max_dist_idx - start_idx > 1:\n                stack.append((start_idx, max_dist_idx))\n            if end_idx - max_dist_idx > 1:\n                stack.append((max_dist_idx, end_idx))\n                \n    return sorted(list(kept_indices))\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"x_func\": lambda t: np.cos(t),\n            \"y_func\": lambda t: np.sin(t),\n            \"t_range\": (0, np.pi / 2),\n            \"N\": 101,\n            \"epsilon\": 0.01\n        },\n        {\n            \"x_func\": lambda t: np.piecewise(t, [t = 0.5, t > 0.5], [lambda v: v, 0.5]),\n            \"y_func\": lambda t: np.piecewise(t, [t = 0.5, t > 0.5], [0, lambda v: 2 * (v - 0.5)]),\n            \"t_range\": (0, 1),\n            \"N\": 51,\n            \"epsilon\": 1e-12\n        },\n        {\n            \"x_func\": lambda t: t,\n            \"y_func\": lambda t: np.sin(3 * t),\n            \"t_range\": (0, 2 * np.pi),\n            \"N\": 401,\n            \"epsilon\": 100\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        t_start, t_end = case[\"t_range\"]\n        N = case[\"N\"]\n        epsilon = case[\"epsilon\"]\n        \n        # 1. Sample the curve\n        t_values = np.linspace(t_start, t_end, N)\n        x_values = case[\"x_func\"](t_values)\n        y_values = case[\"y_func\"](t_values)\n        points = np.vstack((x_values, y_values)).T\n\n        # 2. Compute the simplified subsequence\n        retained_indices = simplify_polyline(points, epsilon)\n        all_results.append(retained_indices)\n\n    # 3. Format the final output string\n    inner_results_str = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(inner_results_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3261322"}]}