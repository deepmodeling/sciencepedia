{"hands_on_practices": [{"introduction": "The bisection method is a cornerstone of root-finding due to its simplicity and guaranteed convergence. While standard analysis focuses on the error in the root's position, real-world problems often demand accuracy in the function's value itself. This exercise [@problem_id:2219715] challenges you to determine the number of iterations needed to guarantee a company's profit calculation is within a specific monetary threshold, a task that requires a practical application of the Mean Value Theorem to relate the error in the input variable $x$ to the tolerance of the output value $P(x)$.", "problem": "A boutique manufacturer of specialized drone components has modeled its weekly profit, $P(x)$, in US dollars, as a function of the number of components produced and sold, $x$. The profit function is given by:\n$$P(x) = -0.000001x^3 + 0.002x^2 + 15x - 5000$$\nThe company's analysts have determined that a break-even point, where the profit is zero, exists for a production level within the interval $[300, 400]$. To optimize their production targets, managers need to determine this break-even quantity. They plan to use the bisection method on the initial interval $[300, 400]$ to find an approximation, $x_{approx}$, for the true break-even quantity, $x^*$.\n\nWhat is the minimum number of bisection iterations, $n$, required to guarantee that the absolute value of the profit at the approximated break-even point, $|P(x_{approx})|$, is less than $0.01$?", "solution": "We are given the continuous cubic profit function\n$$P(x)=-1 \\times 10^{-6}x^{3}+2 \\times 10^{-3}x^{2}+15x-5000,$$\nwith a root in the interval $\\left[300,400\\right]$. The bisection method halves the interval length at each iteration. Let $[a,b]=[300,400]$, so the initial length is $L_{0}=b-a=100$. After $n$ iterations, the interval length is\n$$L_{n}=\\frac{100}{2^{n}},$$\nand the midpoint $x_{\\text{approx}}$ satisfies the standard bisection error bound in $x$:\n$$|x_{\\text{approx}}-x^{*}|\\leq \\frac{L_{n}}{2}=\\frac{100}{2^{n+1}}.$$\n\nTo ensure a bound on the function value, apply the Mean Value Theorem. There exists $c$ between $x_{\\text{approx}}$ and $x^{*}$ such that\n$$|P(x_{\\text{approx}})-P(x^{*})|=|P'(c)|\\,|x_{\\text{approx}}-x^{*}|.$$\nThus, for any $M \\geq \\max_{x \\in [300,400]}|P'(x)|$, we have\n$$|P(x_{\\text{approx}})| \\leq M\\,|x_{\\text{approx}}-x^{*}|.$$\nTherefore, it suffices to enforce\n$$|x_{\\text{approx}}-x^{*}|\\leq \\frac{0.01}{M}.$$\n\nCompute a suitable $M$. Differentiate:\n$$P'(x)=-3 \\times 10^{-6}x^{2}+4 \\times 10^{-3}x+15,$$\n$$P''(x)=-6 \\times 10^{-6}x+4 \\times 10^{-3}.$$\nSet $P''(x)=0$ to locate extrema of $P'$:\n$$-6 \\times 10^{-6}x+4 \\times 10^{-3}=0 \\;\\Rightarrow\\; x=\\frac{4 \\times 10^{-3}}{6 \\times 10^{-6}}=\\frac{2}{3} \\times 10^{3}=\\frac{2000}{3},$$\nwhich lies outside $\\left[300,400\\right]$. Since $P''(x)>0$ on $\\left[300,400\\right]$, $P'(x)$ is increasing there. Hence\n$$M=\\max_{x \\in [300,400]}|P'(x)|=P'(400)=-3 \\times 10^{-6}\\cdot 160000+4 \\times 10^{-3}\\cdot 400+15=-0.48+1.6+15=16.12.$$\n\nTo guarantee $|P(x_{\\text{approx}})|0.01$, it is sufficient that\n$$\\frac{100}{2^{n+1}} \\leq \\frac{0.01}{16.12} \\;\\;\\Longleftrightarrow\\;\\; 2^{n+1} \\geq \\frac{100 \\cdot 16.12}{0.01}=161200.$$\nSince $2^{17}=131072  161200$ and $2^{18}=262144 \\ge 161200$, the smallest integer $n$ satisfying the inequality is\n$$n=17.$$", "answer": "$$\\boxed{17}$$", "id": "2219715"}, {"introduction": "While bracketing methods guarantee convergence by trapping a root, open methods like fixed-point iteration can offer faster performance but require careful design to ensure they converge at all. This practice [@problem_id:2219690] delves into the heart of this issue by asking you to find the range of a parameter $\\alpha$ that ensures the convergence of a given iterative scheme, $x_{k+1} = g(x_k)$. By analyzing the condition $|g'(x^*)|  1$, where $x^*$ is the root, you will develop a fundamental understanding of contraction mappings, the theoretical bedrock that guarantees iterative methods successfully find a solution.", "problem": "An engineer is using a numerical method to find the solution to the equation $e^{x} = 3$. They choose a fixed-point iteration scheme defined by the recurrence relation:\n$$\nx_{k+1} = x_{k} - \\alpha (e^{x_{k}} - 3)\n$$\nwhere $k$ is the iteration index ($k=0, 1, 2, \\dots$) and $\\alpha$ is a real-valued constant parameter used to control the convergence of the method. For the iteration to converge to the true root of the equation, the parameter $\\alpha$ must lie within a specific range.\n\nAssuming the initial guess $x_0$ is sufficiently close to the root, which of the following represents the open interval of values for $\\alpha$ that guarantees convergence?\n\nA. $(0, 1/3)$\n\nB. $(0, 2/3)$\n\nC. $(-1/3, 1/3)$\n\nD. $(0, 1)$\n\nE. $(-2/3, 2/3)$", "solution": "We seek the fixed point of the iteration $x_{k+1}=g(x_{k})$ with\n$$\ng(x)=x-\\alpha\\left(\\exp(x)-3\\right).\n$$\nThe fixed point $x^{\\ast}$ satisfies $\\exp(x^{\\ast})=3$, hence $x^{\\ast}=\\ln(3)$.\n\nA sufficient condition for local convergence of fixed-point iteration, assuming $x_{0}$ is sufficiently close to $x^{\\ast}$ and $g$ is continuously differentiable near $x^{\\ast}$, is the contraction condition\n$$\n|g'(x^{\\ast})|1.\n$$\nCompute the derivative:\n$$\ng'(x)=1-\\alpha\\exp(x),\n$$\nso at the fixed point,\n$$\ng'(x^{\\ast})=1-\\alpha\\exp(x^{\\ast})=1-3\\alpha.\n$$\nThe convergence condition becomes\n$$\n|1-3\\alpha|1.\n$$\nThis is equivalent to the double inequality\n$$\n-11-3\\alpha1.\n$$\nFrom the left inequality: $-11-3\\alpha\\implies -2-3\\alpha\\implies 2>3\\alpha\\implies \\alpha2/3$.\nFrom the right inequality: $1-3\\alpha1\\implies -3\\alpha0\\implies 3\\alpha>0\\implies \\alpha>0$.\nCombining gives\n$$\n0\\alpha2/3,\n$$\nwhich corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "2219690"}, {"introduction": "Finding a single root is useful, but many scientific and engineering problems require identifying *all* solutions within a given domain. This advanced practice [@problem_id:3283618] challenges you to design a robust algorithm that can locate multiple roots of a function and, critically, certify that none have been missed. By combining adaptive interval subdivision with a derivative-bound analysis based on the Mean Value Theorem, you will build a powerful tool that moves beyond simple iteration to provide guaranteed, comprehensive results.", "problem": "Consider the root-finding problem for the continuous function $f(x) = \\cos(10x) - x$, where the angle for the cosine function is measured in radians. The task is to design and implement a program that, for a given closed interval $[a,b]$, locates all real numbers $x \\in [a,b]$ such that $f(x) = 0$ and provides a rigorous certification that no roots have been missed. Your design must start from first principles appropriate for numerical methods: continuity, the Intermediate Value Theorem, and the Mean Value Theorem. Use a bounded derivative argument to establish an a priori Lipschitz bound and build an adaptive meshing procedure that subdivides the interval $[a,b]$ as needed to both detect and certify the absence of additional roots. The certification must be logically derived from these principles and should ensure that every subinterval is either proven root-free or is refined until any root within it is bracketed and resolved.\n\nIn this problem, you must:\n- Identify a uniform bound $L$ such that $\\lvert f'(x) \\rvert \\le L$ for all $x$ in any interval under consideration.\n- Implement an adaptive subdivision of $[a,b]$. When the function values at the endpoints of a subinterval have opposite signs, use a bracketing method to isolate and approximate a root. When they have the same sign, use the bounded derivative argument to certify that the entire subinterval contains no roots; otherwise, subdivide further.\n- Ensure that the algorithm detects multiple roots if present and that discovered roots are reported uniquely.\n\nYour program should apply the method to the following test suite of intervals and aggregate the results:\n- Test $1$: $[0,1]$.\n- Test $2$: $[-1,0]$.\n- Test $3$: $[1.2,2.0]$.\n- Test $4$: $[-1,1]$.\n- Test $5$: $[0.14,0.18]$.\n\nFor each test, return the list of all roots in the given interval, expressed as floating-point numbers rounded to ten decimal places. The final output must be a single line containing the results for all tests as a comma-separated list of lists enclosed in square brackets. For example, the format should be $[[r_{1,1},r_{1,2},\\dots],[r_{2,1},\\dots],\\dots]$, where $r_{i,j}$ denotes the $j$-th root found in the $i$-th test. If an interval contains no roots, return an empty list for that interval. Angles must be in radians, and no physical units are involved.\n\nYour algorithm must be robust enough to handle:\n- A general case with multiple isolated roots (Test $1$).\n- A symmetric interval covering negative values (Test $2$).\n- A case with no roots, to test your certification of absence (Test $3$).\n- A larger interval that includes both positive and negative ranges, potentially containing more roots (Test $4$).\n- A narrow interval around a root, to test precision and boundary handling (Test $5$).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[[r_{1,1},r_{1,2}],[\\dots],\\dots]$).", "solution": "The problem requires us to find all real roots of the function $f(x) = \\cos(10x) - x$ within a given closed interval $[a, b]$. A critical component of the task is to provide a rigorous certification, based on first principles of calculus, that no roots have been missed. The methodology stipulated involves an adaptive subdivision of the interval combined with a derivative-based argument.\n\n### Theoretical Framework\n\nThe function in question is $f(x) = \\cos(10x) - x$. This function is continuous and infinitely differentiable for all $x \\in \\mathbb{R}$. The core of the certification method relies on bounding its rate of change.\n\n1.  **Function and its Derivative**:\n    The function is $f(x) = \\cos(10x) - x$.\n    Its derivative with respect to $x$ is $f'(x) = \\frac{d}{dx}(\\cos(10x) - x) = -10\\sin(10x) - 1$.\n\n2.  **Lipschitz Constant (Bounded Derivative)**:\n    To certify that a region is root-free, we need a uniform upper bound on the magnitude of the function's derivative. This bound, known as a Lipschitz constant $L$, satisfies the condition $\\lvert f'(x) \\rvert \\le L$ for all $x$ in the domain of interest.\n    The sine function is bounded such that $-1 \\le \\sin(10x) \\le 1$.\n    Therefore, the derivative $f'(x)$ is bounded as follows:\n    $$ -10(1) - 1 \\le -10\\sin(10x) - 1 \\le -10(-1) - 1 $$\n    $$ -11 \\le f'(x) \\le 9 $$\n    The maximum absolute value of $f'(x)$ is therefore $\\max(\\lvert -11 \\rvert, \\lvert 9 \\rvert) = 11$. We can thus choose a global Lipschitz constant $L=11$. This implies that for any two points $x_1$ and $x_2$, the Mean Value Theorem (MVT) guarantees:\n    $$ \\lvert f(x_1) - f(x_2) \\rvert \\le L \\lvert x_1 - x_2 \\rvert = 11 \\lvert x_1 - x_2 \\rvert $$\n\n### Algorithm Design: Adaptive Subdivision with Certification\n\nA naive approach of simply searching for sign changes is insufficient, as an interval could contain an even number of roots without a sign change between its endpoints. The specified method overcomes this by systematically subdividing the interval until each subinterval can either be proven root-free or is small enough that any contained root can be isolated.\n\nThe algorithm uses a stack of intervals to be processed, starting with the initial interval $[a, b]$.\n\n1.  **The Certification Principle**:\n    Consider a subinterval $[c, d]$. We evaluate the function at its endpoints, $f(c)$ and $f(d)$.\n    If $f(c)$ and $f(d)$ have the same sign (e.g., both are positive), a root can only exist if the function dips to zero and returns. We can use the Lipschitz constant $L$ to construct a lower bound for $f(x)$ on $[c,d]$. The function's graph must lie above the two lines starting from $(c, f(c))$ and $(d, f(d))$ with slopes $\\pm L$. Specifically, for $x \\in [c, d]$, $f(x)$ must be above the envelope formed by $y_1(x) = f(c) - L(x-c)$ and $y_2(x) = f(d) - L(d-x)$.\n    The minimum value of this envelope occurs at the intersection of these two lines, which can be calculated as $y_{min} = \\frac{f(c)+f(d)}{2} - \\frac{L(d-c)}{2}$.\n    If this minimum value is positive, then we are certain that $f(x)  0$ for all $x \\in [c, d]$.\n    A symmetric argument applies if both $f(c)$ and $f(d)$ are negative. This leads to the general certification condition:\n    An interval $[c, d]$ is guaranteed to be root-free if $f(c)$ and $f(d)$ have the same sign and $\\lvert f(c) + f(d) \\rvert > L(d-c)$.\n\n2.  **The Recursive Subdivision Algorithm**:\n    - A stack is initialized with the starting interval $[a, b]$.\n    - An interval $[c, d]$ is popped from the stack.\n    - If the interval is smaller than a predefined `SUBDIVISION_STOP_WIDTH` (e.g., $10^{-9}$), it is considered \"atomic\". We test for a root by checking if $f(c)f(d) \\le 0$. If so, the Intermediate Value Theorem (IVT) guarantees a root, which is then found using a bracketing numerical method like Bisection. Otherwise, the tiny interval is discarded.\n    - For larger intervals:\n        - **Case 1: Same Sign ($f(c)f(d) > 0$)**: The certification condition $\\lvert f(c) + f(d) \\rvert > L(d-c)$ is tested. If true, the interval is proven root-free and discarded. If false, we lack certainty, so the interval is subdivided at its midpoint $m=(c+d)/2$, and the two resulting subintervals, $[c, m]$ and $[m, d]$, are pushed onto the stack for further investigation.\n        - **Case 2: Sign Change ($f(c)f(d) \\le 0$)**: The IVT guarantees at least one root. However, there could be an odd number of roots ($3, 5, \\dots$). As we cannot certify the absence of additional roots, the only rigorous course of action is to subdivide the interval. Both $[c, m]$ and $[m, d]$ are pushed onto the stack.\n\n3.  **Root Isolation and Uniqueness**:\n    - When the subdivision process yields a very small interval that contains a sign change, we employ the Bisection method to approximate the root to a high precision (e.g., a tolerance of $10^{-15}$).\n    - This entire process populates a list of found roots. Since a single root might be detected at the boundary of two adjacent small intervals, a final filtering step is necessary. The list of roots is sorted, and duplicates are removed by iterating through the sorted list and only keeping roots that are separated from the previous one by more than a small tolerance (e.g., $10^{-12}$).\n    - Finally, the unique roots are rounded to the required $10$ decimal places.\n\nThis complete, systematic process ensures that the entire initial interval $[a, b]$ is exhaustively searched, and the combination of the certified-absence test and recursive subdivision guarantees that all roots are found.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants defining the problem and algorithm parameters.\nL = 11.0  # Lipschitz constant for f(x)\nTOLERANCE_BISECT = 1e-15  # Tolerance for the bisection root-finding method.\nTOLERANCE_UNIQUENESS = 1e-12  # Tolerance for distinguishing unique roots.\n# Subdivision stops when an interval's width is below this threshold.\n# On such small intervals, we check for a root using IVT directly.\nSUBDIVISION_STOP_WIDTH = 1e-9\n\ndef f(x):\n    \"\"\"The function for which we are finding roots.\"\"\"\n    return np.cos(10 * x) - x\n\ndef bisection(c, d):\n    \"\"\"\n    Finds a root in the interval [c, d] using the bisection method.\n    It is assumed that f(c) * f(d) = 0.\n    \"\"\"\n    low, high = c, d\n    f_low = f(low)\n    \n    # Safety check for roots at endpoints.\n    if abs(f_low)  TOLERANCE_BISECT:\n        return low\n    if abs(f(high))  TOLERANCE_BISECT:\n        return high\n\n    # Bisection guarantees convergence. 100 iterations is more than\n    # sufficient for standard double precision floating-point numbers.\n    for _ in range(100):\n        if high - low  TOLERANCE_BISECT:\n            break\n        \n        mid = low + (high - low) / 2  # Numerically stable midpoint calculation\n        f_mid = f(mid)\n\n        if abs(f_mid)  TOLERANCE_BISECT:\n            return mid\n\n        # If signs are different, root is in the lower half.\n        if np.sign(f_low) != np.sign(f_mid):\n            high = mid\n        else: # Otherwise, root is in the upper half.\n            low = mid\n            f_low = f_mid\n            \n    return low + (high - low) / 2\n\ndef find_all_roots_certified(a, b):\n    \"\"\"\n    Finds all roots of f(x) in the interval [a, b] using an adaptive\n    subdivision algorithm with a rigorous certification of absence.\n    \"\"\"\n    stack = [(a, b)]\n    roots = []\n\n    while stack:\n        c, d = stack.pop()\n\n        if d = c:\n            continue\n\n        f_c = f(c)\n        f_d = f(d)\n\n        # Base case for recursion: interval is small enough.\n        if (d - c)  SUBDIVISION_STOP_WIDTH:\n            # For this small interval, check for a root using the Intermediate Value Theorem.\n            if f_c * f_d = 0:\n                root = bisection(c, d)\n                roots.append(root)\n            # If no sign change, the small interval is discarded.\n            continue\n\n        # Subdivision Step:\n        # Case 1: No sign change. Attempt to certify that no roots exist.\n        if f_c * f_d  0:\n            # Certification condition: |f(c) + f(d)|  L * (d-c)\n            if abs(f_c + f_d)  L * (d - c):\n                # Interval is certified to be root-free. Discard it.\n                continue\n            else:\n                # Certification failed. Subdivide and check both halves.\n                m = c + (d-c)/2\n                stack.append((c, m))\n                stack.append((m, d))\n        # Case 2: Sign change detected.\n        else:  # f_c * f_d = 0\n            # A root is guaranteed, but more may exist. Subdivide to find all.\n            m = c + (d-c)/2\n            stack.append((c, m))\n            stack.append((m, d))\n\n    # Post-processing: remove duplicates and round.\n    if not roots:\n        return []\n\n    roots.sort()\n    \n    # Filter for unique roots based on a proximity tolerance.\n    unique_roots = [roots[0]]\n    for i in range(1, len(roots)):\n        if abs(roots[i] - unique_roots[-1])  TOLERANCE_UNIQUENESS:\n            unique_roots.append(roots[i])\n\n    # Round the final unique roots to the specified number of decimal places.\n    return [round(r, 10) for r in unique_roots]\n\ndef solve():\n    \"\"\"\n    Main function to run the root-finding algorithm on the given test cases\n    and print the results in the specified format.\n    \"\"\"\n    test_cases = [\n        (0.0, 1.0),\n        (-1.0, 0.0),\n        (1.2, 2.0),\n        (-1.0, 1.0),\n        (0.14, 0.18),\n    ]\n\n    results = []\n    for a, b in test_cases:\n        # The result for each case is the list of roots found in the interval.\n        roots_list = find_all_roots_certified(a, b)\n        results.append(roots_list)\n\n    # Format the final output string to match the problem specification\n    # e.g., \"[[root1,root2],[],[root3]]\" with no spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3283618"}]}