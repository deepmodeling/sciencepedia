{"hands_on_practices": [{"introduction": "To truly understand an algorithm, it is often best to start by executing it manually. This first practice strips away the complexity of advanced numerical integrators and asks you to apply the simple explicit Euler method to a boundary value problem. By performing a few steps by hand, you will build a concrete intuition for how the shooting method transforms a BVP into an IVP and see firsthand how the final value at the boundary depends linearly on your initial choice of slope, $s$ [@problem_id:1127152].", "problem": "Consider the following linear second-order boundary value problem (BVP) on the interval $x \\in [1, 3]$:\n$$y'' + \\frac{1}{x} y' - \\frac{1}{x^2} y = 0, \\quad y(1) = \\alpha, \\quad y(3) = \\beta$$\n\nTo solve this BVP using the shooting method, one converts it into an initial value problem (IVP) by imposing an initial slope, $y'(1) = s$. The resulting IVP is:\n$$y'' = -\\frac{1}{x} y' + \\frac{1}{x^2} y, \\quad y(1) = \\alpha, \\quad y'(1) = s$$\n\nThis IVP can be solved numerically to find an approximation for $y(3)$. Let this approximation be denoted by $y_N$, where $N$ is the number of steps.\n\nYour task is to apply the explicit Euler method with $N=2$ uniform steps to this IVP. Derive the expression for the approximate value of the solution at $x=3$, denoted as $y_2$, in terms of the initial value $\\alpha$ and the trial slope $s$.", "solution": "**Step 1: Compute step size**\nThe interval is $[1, 3]$ and we use $N=2$ steps, so the step size $h$ is:\n$$h=\\frac{3-1}{2}=1.$$\nThe grid points are $x_0=1$, $x_1=2$, and $x_2=3$.\n\n**Step 2: First Euler step (from $x_0=1$ to $x_1=2$)**\nWe start with the initial data $y(x_0)=y_0=\\alpha$ and $y'(x_0)=y_0'=s$.\nFirst, compute the second derivative at $x_0=1$:\n$$y_0''=-\\frac{1}{x_0}y_0'+\\frac{1}{x_0^2}y_0 = -\\frac{1}{1}s + \\frac{1}{1^2}\\alpha = \\alpha-s.$$\nUsing the explicit Euler formulas $y_{k+1} = y_k + h y_k'$ and $y'_{k+1} = y'_k + h y''_k$, we find the state at $x_1=2$:\n$$y_1=y_0+h\\,y_0'=\\alpha+1 \\cdot s = \\alpha+s$$\n$$y_1'=y_0'+h\\,y_0''=s+1 \\cdot (\\alpha-s)=\\alpha$$\n\n**Step 3: Second Euler step (from $x_1=2$ to $x_2=3$)**\nNow we take a step from $x_1=2$ using the state $(y_1, y_1') = (\\alpha+s, \\alpha)$. We only need to find the next position, $y_2$:\n$$y_2=y_1+h\\,y_1'=(\\alpha+s)+1 \\cdot \\alpha = 2\\alpha+s.$$", "answer": "$$\\boxed{2\\alpha + s}$$", "id": "1127152"}, {"introduction": "The previous exercise demonstrated numerically that the relationship between the initial slope and the final boundary value is linear. This practice delves into the theoretical reason: the principle of superposition for linear ODEs. Here, you will not perform a numerical approximation but instead derive an exact, closed-form expression for the required initial slope [@problem_id:3248440]. This exercise is crucial for understanding why the *linear* shooting method is so efficient, as it replaces a potentially difficult nonlinear root-finding problem with a simple linear equation.", "problem": "Consider the boundary value problem for the linear ordinary differential equation (ODE)\n$$\ny''(x) + \\frac{1}{x}\\,y'(x) = 0,\\quad x \\in [1, L],\n$$\nwith boundary conditions\n$$\ny(1)=A,\\quad y(L)=B,\n$$\nwhere $L>1$ and $A,B \\in \\mathbb{R}$. Starting only from the linearity of the ODE operator and the uniqueness of solutions to initial value problems (IVPs) with continuous coefficients, apply the linear shooting method to determine the unique initial slope $s = y'(1)$ that produces a solution satisfying the boundary condition at $x=L$. Derive $s$ explicitly in closed form in terms of $A$, $B$, and $L$. Your final answer must be a single closed-form expression. Do not provide a numerical approximation.", "solution": "The linear shooting method transforms the BVP into an IVP by using the initial slope $s=y'(1)$ as a parameter. We then solve the IVP and determine the value of $s$ that satisfies the boundary condition at $x=L$. For a linear ODE, this can be done analytically.\n\nLet the linear differential operator be $L[y] = y''(x) + \\frac{1}{x}\\,y'(x)$. We seek the solution to $L[y] = 0$ with $y(1)=A$ and $y(L)=B$.\n\nThe core of the method is the principle of superposition. We express the solution to the IVP with initial conditions $y(1)=A, y'(1)=s$ as a linear combination of two fundamental solutions.\nLet $y_1(x)$ be the solution to the IVP:\n$$\nL[y_1] = 0, \\quad y_1(1) = 1, \\quad y_1'(1) = 0\n$$\nAnd let $y_2(x)$ be the solution to the IVP:\n$$\nL[y_2] = 0, \\quad y_2(1) = 0, \\quad y_2'(1) = 1\n$$\nBy linearity, the function $Y(x) = A y_1(x) + s y_2(x)$ satisfies $L[Y]=0$ and has the initial conditions $Y(1)=A$ and $Y'(1)=s$. By the uniqueness of solutions to IVPs, this is our desired solution, $y(x; s) = A y_1(x) + s y_2(x)$.\n\nWe now impose the second boundary condition, $y(L; s) = B$:\n$$\nA y_1(L) + s y_2(L) = B\n$$\nThis is a linear algebraic equation for the unknown slope $s$. Solving for $s$ gives:\n$$\ns = \\frac{B - A y_1(L)}{y_2(L)}\n$$\nTo obtain an explicit closed-form expression, we find the analytical forms of $y_1(x)$ and $y_2(x)$. The given ODE can be written as the derivative of a product:\n$$\n\\frac{d}{dx}\\left(x y'(x)\\right) = y'(x) + x y''(x) = x \\left( y'' + \\frac{1}{x} y' \\right) = 0\n$$\nIntegrating $\\frac{d}{dx}(x y') = 0$ gives $x y'(x) = C_1$, so $y'(x) = \\frac{C_1}{x}$.\nIntegrating again yields the general solution:\n$$\ny(x) = C_1 \\ln(x) + C_2\n$$\n\nNow we apply the initial conditions for $y_1(x)$ and $y_2(x)$:\n\nFor $y_1(x)$:\n$y_1(1) = 1 \\implies C_1 \\ln(1) + C_2 = 1 \\implies C_2 = 1$.\n$y_1'(1) = 0 \\implies \\frac{C_1}{1} = 0 \\implies C_1=0$.\nThus, the solution is $y_1(x) = 1$.\n\nFor $y_2(x)$:\n$y_2(1) = 0 \\implies D_1 \\ln(1) + D_2 = 0 \\implies D_2 = 0$.\n$y_2'(1) = 1 \\implies \\frac{D_1}{1} = 1 \\implies D_1=1$.\nThus, the solution is $y_2(x) = \\ln(x)$.\n\nWe evaluate these solutions at $x=L$:\n$y_1(L) = 1$ and $y_2(L) = \\ln(L)$.\nSince $L>1$, $y_2(L) \\neq 0$.\n\nSubstituting these values into the formula for $s$:\n$$\ns = \\frac{B - A \\cdot y_1(L)}{y_2(L)} = \\frac{B - A \\cdot 1}{\\ln(L)} = \\frac{B - A}{\\ln(L)}\n$$", "answer": "$$\n\\boxed{\\frac{B-A}{\\ln(L)}}\n$$", "id": "3248440"}, {"introduction": "While elegant, the standard shooting method can suffer from a critical flaw: numerical instability, especially for problems on long intervals where solutions may grow or decay exponentially. This hands-on coding exercise introduces multiple shooting, a robust technique designed to overcome this limitation. You will implement both the standard single shooting method and the more stable multiple shooting method for a classic problem where single shooting fails dramatically, providing a powerful and practical comparison of the two approaches [@problem_id:3248449].", "problem": "You are to implement and test a multiple shooting (also known as parallel or segment-wise shooting) method for linear two-point boundary value problems to overcome the instability and ill-conditioning that can appear in standard single shooting over long intervals. Work with the following boundary value problem:\nGiven $L \\in \\mathbb{R}_{>0}$ and boundary data $\\alpha, \\beta \\in \\mathbb{R}$, find $y:[0,L] \\to \\mathbb{R}$ such that\n$\ny''(x) - y(x) = 0,\\quad x \\in [0,L],\\quad y(0) = \\alpha,\\quad y(L) = \\beta.\n$\nFor verification, the exact solution is\n$\ny(x) = \\alpha\\,\\frac{\\sinh(L-x)}{\\sinh(L)} + \\beta\\,\\frac{\\sinh(x)}{\\sinh(L)}.\n$\n\nStarting from the fundamental base that any scalar second-order linear ordinary differential equation can be rewritten as a first-order system, recast the boundary value problem as the first-order linear system\n$\n\\mathbf{u}'(x) = A(x)\\,\\mathbf{u}(x),\\quad \\mathbf{u}(x) \\in \\mathbb{R}^2,\n$\nwhere $\\mathbf{u}(x) = \\begin{bmatrix}y(x)\\\\y'(x)\\end{bmatrix}$ and $A(x) = \\begin{bmatrix}0 & 1\\\\ 1 & 0\\end{bmatrix}$ is constant. Use the linear initial value problem flow and the state transition matrix to derive a multiple shooting formulation on a uniform partition of $[0,L]$ into $m$ subintervals with nodes $x_k = k\\,h$, $h = L/m$, $k=0,1,\\dots,m$. On each subinterval $[x_k,x_{k+1}]$, approximate the state transition matrix $\\Phi_k$ that maps $\\mathbf{u}(x_k)$ to $\\mathbf{u}(x_{k+1})$ by numerically integrating the matrix differential equation\n$\n\\frac{d}{dx}\\Phi(x) = A(x)\\,\\Phi(x),\\quad \\Phi(x_k) = I,\n$\nusing the classical Runge–Kutta method of order $4$ with a fixed number of steps per subinterval. Assemble a linear block system that enforces:\n- continuity across internal nodes, i.e., $\\mathbf{u}(x_{k+1}) - \\Phi_k\\,\\mathbf{u}(x_k) = \\mathbf{0}$ for $k=0,1,\\dots,m-1$, and\n- the boundary conditions $y(0) = \\alpha$ and $y(L) = \\beta$,\nand solve it for the unknown nodal states $\\mathbf{u}(x_k)$, $k=0,1,\\dots,m-1$. Recover $y$ at the grid nodes $x_k$ from these states and the final propagation on the last subinterval. Compute the maximum absolute error at the grid nodes $x_k$ by comparing the numerical $y(x_k)$ to the exact $y(x_k)$.\n\nAlso implement a standard single shooting baseline. Use the linear superposition principle: integrate two initial value problems across $[0,L]$ with initial data $\\mathbf{u}^{(1)}(0) = \\begin{bmatrix}\\alpha\\\\0\\end{bmatrix}$ and $\\mathbf{u}^{(2)}(0) = \\begin{bmatrix}0\\\\1\\end{bmatrix}$ to determine the initial slope needed to satisfy $y(L)=\\beta$, then integrate once from $x=0$ to $x=L$ with that initial slope and record the values $y(x_k)$ at the same grid nodes. Use the same Runge–Kutta method of order $4$ with a fixed number of steps per subinterval to build the state transition matrices for this baseline.\n\nImplement a program that, for each test case, returns a two-element list containing:\n- the maximum absolute nodal error for single shooting, and\n- the maximum absolute nodal error for multiple shooting,\neach as a floating-point number.\n\nTest suite:\n- Test case $1$: $L=20$, $\\alpha=0$, $\\beta=1$, $m=10$, steps per subinterval for multiple shooting $=40$, steps per subinterval for single shooting $=40$.\n- Test case $2$: $L=20$, $\\alpha=1$, $\\beta=2$, $m=1$, steps per subinterval for multiple shooting $=2000$, steps per subinterval for single shooting $=2000$.\n- Test case $3$: $L=10$, $\\alpha=0.5$, $\\beta=1.5$, $m=5$, steps per subinterval for multiple shooting $=50$, steps per subinterval for single shooting $=50$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a two-element list in the order described above. For example, a valid output looks like\n$\n[[e_{1,\\text{single}},e_{1,\\text{multi}}],[e_{2,\\text{single}},e_{2,\\text{multi}}],[e_{3,\\text{single}},e_{3,\\text{multi}}]].\n$", "solution": "This problem requires implementing and comparing two numerical strategies: single shooting and multiple shooting. Both methods rely on converting the second-order ODE into a first-order system and using a numerical integrator (RK4) to propagate the solution.\n\nFirst, the BVP $y'' - y = 0$ is transformed into a first-order system $\\mathbf{u}'(x) = A\\mathbf{u}(x)$ where the state vector is $\\mathbf{u}(x) = [y(x), y'(x)]^T$ and the constant matrix is $A = \\begin{bmatrix}0 & 1\\\\ 1 & 0\\end{bmatrix}$. The solution to this linear system can be written as $\\mathbf{u}(x) = \\Phi(x-x_0)\\mathbf{u}(x_0)$, where $\\Phi$ is the state transition matrix. $\\Phi$ is found by numerically integrating the matrix differential equation $\\Phi'(x) = A\\Phi(x)$ with the initial condition $\\Phi(0) = I$ using the specified RK4 method.\n\n### Single Shooting Implementation\nThe single shooting method aims to find the unknown initial slope $s = y'(0)$ that satisfies the boundary condition at $x=L$.\n1.  **Find the Initial Slope**: The state transition matrix over the entire interval, $\\Phi(L)$, is computed. This matrix relates the state at the end to the state at the start: $\\mathbf{u}(L) = \\Phi(L)\\mathbf{u}(0)$. Expanding the first row of this matrix equation gives $y(L) = \\Phi_{11}(L)y(0) + \\Phi_{12}(L)y'(0)$. With the known boundary conditions $y(0)=\\alpha$ and $y(L)=\\beta$, we can solve for the unknown initial slope:\n    $$ s = y'(0) = \\frac{\\beta - \\Phi_{11}(L)\\alpha}{\\Phi_{12}(L)} $$\n2.  **Integrate the IVP**: With the complete initial state vector $\\mathbf{u}(0) = [\\alpha, s]^T$ now known, the problem becomes a standard initial value problem. We integrate this IVP from $x=0$ to $x=L$ using RK4, storing the solution $y(x_k)$ at each grid node.\n3.  **Compute Error**: The numerical solution at the nodes is compared to the exact analytical solution to find the maximum absolute error. The instability of this method for large $L$ comes from the fact that the entries of $\\Phi(L)$ (related to $\\cosh(L)$ and $\\sinh(L)$) become extremely large, leading to numerical ill-conditioning and loss of precision when calculating $s$.\n\n### Multiple Shooting Implementation\nThe multiple shooting method divides the interval $[0,L]$ into $m$ subintervals $[x_k, x_{k+1}]$ to avoid the long integration that causes instability.\n1.  **Formulate a Linear System**: The state vectors at all grid nodes, $\\mathbf{u}_k = \\mathbf{u}(x_k)$ for $k=0, \\dots, m$, are treated as unknowns. A large, block-structured linear system $M\\mathbf{S} = \\mathbf{b}$ is constructed, where $\\mathbf{S} = [\\mathbf{u}_0^T, \\mathbf{u}_1^T, \\dots, \\mathbf{u}_m^T]^T$. The system is built from the following equations:\n    *   **Continuity Conditions**: For each subinterval $[x_k, x_{k+1}]$, the states are related by the local state transition matrix $\\Phi_k$ (which is the same for all subintervals here): $\\mathbf{u}_{k+1} = \\Phi_k \\mathbf{u}_k$. These are rewritten as $\\mathbf{u}_{k+1} - \\Phi_k \\mathbf{u}_k = \\mathbf{0}$. This provides $2m$ linear equations.\n    *   **Boundary Conditions**: The two boundary conditions, $y(0)=\\alpha$ and $y(L)=\\beta$, are incorporated. In terms of the unknown vectors, these are $(\\mathbf{u}_0)_1 = \\alpha$ and $(\\mathbf{u}_m)_1 = \\beta$. These provide 2 linear equations.\n2.  **Solve the System**: The resulting $2(m+1) \\times 2(m+1)$ linear system $M\\mathbf{S} = \\mathbf{b}$ is solved for the vector of all nodal states $\\mathbf{S}$. Because the state transition matrices $\\Phi_k$ are computed over short intervals, their elements are of moderate size, and the global system $M$ is well-conditioned and can be solved accurately.\n3.  **Compute Error**: The first component of each solved state vector $\\mathbf{u}_k$ gives the numerical solution $y(x_k)$. This is compared to the exact solution to find the maximum absolute error.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    # This is the ODE system function u' = f(u) = A @ u\n    def ode_system_f(u, A):\n        return A @ u\n\n    # Generic RK4 stepper for a vector or matrix state Y, solving Y' = A @ Y\n    def rk4_step(A, Y, h):\n        k1 = h * ode_system_f(Y, A)\n        k2 = h * ode_system_f(Y + 0.5 * k1, A)\n        k3 = h * ode_system_f(Y + 0.5 * k2, A)\n        k4 = h * ode_system_f(Y + k3, A)\n        return Y + (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n\n    # Computes the state transition matrix Phi over an interval.\n    def compute_phi(A, interval_len, n_steps):\n        h_rk = interval_len / n_steps\n        # Start with the identity matrix\n        Phi = np.identity(A.shape[0], dtype=float)\n        for _ in range(n_steps):\n            Phi = rk4_step(A, Phi, h_rk)\n        return Phi\n\n    # Exact solution of the BVP for verification\n    def exact_solution(x, L, alpha, beta):\n        # The problem statement guarantees L > 0, so sinh(L) is not zero.\n        # numpy's sinh handles large arguments up to ~709, returning 'inf' beyond that.\n        # This is sufficient for the test cases provided.\n        sinh_L = np.sinh(L)\n        return alpha * np.sinh(L - x) / sinh_L + beta * np.sinh(x) / sinh_L\n\n    def solve_single_shooting(L, alpha, beta, m, steps_per_sub):\n        A = np.array([[0.0, 1.0], [1.0, 0.0]])\n        total_steps = m * steps_per_sub\n        x_nodes = np.linspace(0, L, m + 1)\n\n        # 1. Find the initial slope y'(0) using the shooting condition.\n        # This requires the state transition matrix over the full interval [0, L].\n        Phi_L = compute_phi(A, L, total_steps)\n        phi_11 = Phi_L[0, 0]\n        phi_12 = Phi_L[0, 1]\n        \n        # Check for singularity. For this problem, phi_12 = sinh(L) which is non-zero for L>0.\n        if abs(phi_12) < 1e-15:\n            return np.inf\n\n        # From y(L) = beta = phi_11*y(0) + phi_12*y'(0), solve for y'(0).\n        y0_prime = (beta - phi_11 * alpha) / phi_12\n        u0 = np.array([alpha, y0_prime], dtype=float)\n\n        # 2. Integrate the IVP with the correct initial condition u0.\n        y_numeric = np.zeros(m + 1, dtype=float)\n        y_numeric[0] = alpha\n        h_rk = L / total_steps\n        u_current = u0.copy()\n        \n        for k in range(m):\n            # Integrate over one subinterval [x_k, x_{k+1}]\n            for _ in range(steps_per_sub):\n                u_current = rk4_step(A, u_current, h_rk)\n            y_numeric[k + 1] = u_current[0]\n            \n        # 3. Compute the maximum absolute error at the nodes.\n        y_exact = exact_solution(x_nodes, L, alpha, beta)\n        max_error = np.max(np.abs(y_numeric - y_exact))\n        \n        return max_error\n\n    def solve_multiple_shooting(L, alpha, beta, m, steps_per_sub):\n        if m == 0: return np.nan\n\n        A = np.array([[0.0, 1.0], [1.0, 0.0]])\n        h_sub = L / m\n        x_nodes = np.linspace(0, L, m + 1)\n        \n        # 1. Compute state transition matrix for a subinterval.\n        # Because A is constant, Phi is the same for all subintervals.\n        Phi = compute_phi(A, h_sub, steps_per_sub)\n        \n        # 2. Assemble and solve the block linear system M*S = b.\n        # Unknowns S = [u0, u1, ..., um]^T. Total size is 2*(m+1).\n        N = 2 * (m + 1)\n        M = np.zeros((N, N), dtype=float)\n        b = np.zeros(N, dtype=float)\n        I = np.identity(2, dtype=float)\n        \n        # BC at x=0: y(0) = alpha\n        M[0, 0] = 1.0\n        b[0] = alpha\n        \n        # Continuity conditions: u_{k+1} - Phi * u_k = 0\n        for k in range(m):\n            row_idx = 1 + 2 * k\n            col_idx_k = 2 * k\n            col_idx_k_plus_1 = 2 * (k + 1)\n            \n            M[row_idx:row_idx+2, col_idx_k:col_idx_k+2] = -Phi\n            M[row_idx:row_idx+2, col_idx_k_plus_1:col_idx_k_plus_1+2] = I\n        \n        # BC at x=L: y(L) = beta (which is y_m)\n        M[N-1, N-2] = 1.0\n        b[N-1] = beta\n        \n        try:\n            S = np.linalg.solve(M, b)\n        except np.linalg.LinAlgError:\n            return np.inf\n\n        # 3. Extract solution and compute error.\n        y_numeric = S[0::2] # Extract y_k values from solution vector\n        y_exact = exact_solution(x_nodes, L, alpha, beta)\n        max_error = np.max(np.abs(y_numeric - y_exact))\n        \n        return max_error\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, alpha, beta, m, steps_per_subinterval)\n        (20.0, 0.0, 1.0, 10, 40),\n        (20.0, 1.0, 2.0, 1, 2000),\n        (10.0, 0.5, 1.5, 5, 50),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, alpha, beta, m, steps = case\n        err_single = solve_single_shooting(L, alpha, beta, m, steps)\n        err_multi = solve_multiple_shooting(L, alpha, beta, m, steps)\n        results.append([err_single, err_multi])\n\n    # Final print statement in the exact required format.\n    # The format requires no spaces, which str() adds by default for lists.\n    # So we build the string manually.\n    formatted_results = []\n    for res_pair in results:\n        formatted_results.append(f\"[{res_pair[0]},{res_pair[1]}]\")\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3248449"}]}