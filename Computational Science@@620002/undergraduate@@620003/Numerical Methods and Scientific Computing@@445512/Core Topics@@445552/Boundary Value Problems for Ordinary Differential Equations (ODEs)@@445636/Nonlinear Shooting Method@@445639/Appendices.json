{"hands_on_practices": [{"introduction": "To begin, we will explore the fundamental principle of the shooting method in a simplified context. This practice applies the shooting methodology to a linear boundary value problem, which allows us to solve for the unknown initial slope $s$ analytically. By working through this problem [@problem_id:3256898], you will gain a concrete understanding of how a boundary value problem is transformed into a root-finding problem for a single parameter, laying a solid conceptual foundation before we introduce numerical solvers.", "problem": "A slender rod of length $L$ conducts heat in one dimension with uniform, temperature-independent properties that have been absorbed into a normalized model. The steady-state temperature distribution $T(x)$ along the rod is governed by the ordinary differential equation (ODE)\n$$\nT''(x) = -q(x),\n$$\nwhere $q(x)$ is a prescribed spatial heat source density expressed in units consistent with $T''(x)$. The rod is held at fixed temperatures $T(0) = T_a$ and $T(L) = T_b$.\n\nConsider the specific case\n$$\nL = 1,\\quad T_a = 310,\\quad T_b = 325,\\quad q(x) = 10\\,\\exp(2x).\n$$\nUse the shooting methodology appropriate for nonlinear boundary value problems (BVPs): introduce the unknown initial slope $s = T'(0)$, treat the problem as an initial value problem, and enforce the terminal boundary condition at $x=L$ by solving a scalar consistency equation in $s$. Derive the closed-form expression for $T(x)$ by carrying out the required integrations and solving for $s$ from first principles. Your derivation must start from the model ODE and the boundary conditions, without assuming any pre-derived solution formula.\n\nReport the final expression for $T(x)$ in kelvin. Provide the expression exactly; no rounding.", "solution": "The problem has been validated and is deemed sound. It is scientifically grounded, well-posed, and objective. All necessary data are provided, and there are no contradictions. The problem asks for an analytical solution to a linear boundary value problem (BVP) using the conceptual framework of the shooting method. While the shooting method is typically implemented numerically for nonlinear problems, its application here to a linear problem is a valid exercise that results in a linear algebraic equation for the unknown initial condition, which can be solved analytically.\n\nThe governing ordinary differential equation (ODE) is:\n$$\nT''(x) = -q(x)\n$$\nwith the specific heat source $q(x) = 10 \\exp(2x)$. The equation becomes:\n$$\nT''(x) = -10 \\exp(2x)\n$$\nThe boundary conditions are $T(0) = T_a = 310$ and $T(L) = T(1) = T_b = 325$.\n\nFollowing the shooting methodology, we convert this BVP into an initial value problem (IVP). We introduce an unknown initial slope, $s = T'(0)$. The IVP is thus defined by the ODE and the initial conditions:\n$$\nT(0) = 310\n$$\n$$\nT'(0) = s\n$$\nOur goal is to find the value of $s$ that ensures the solution to this IVP also satisfies the second boundary condition, $T(1) = 325$.\n\nFirst, we integrate the ODE $T''(x) = -10 \\exp(2x)$ with respect to $x$ to find the expression for the temperature gradient, $T'(x)$:\n$$\nT'(x) = \\int -10 \\exp(2x) \\, dx = -10 \\frac{\\exp(2x)}{2} + C_1 = -5 \\exp(2x) + C_1\n$$\nwhere $C_1$ is the constant of integration. We use the initial condition $T'(0) = s$ to determine $C_1$:\n$$\ns = T'(0) = -5 \\exp(2 \\cdot 0) + C_1 = -5 \\exp(0) + C_1 = -5(1) + C_1\n$$\nSolving for $C_1$, we get:\n$$\nC_1 = s + 5\n$$\nSubstituting this back into the expression for $T'(x)$, we have:\n$$\nT'(x) = -5 \\exp(2x) + s + 5\n$$\nNext, we integrate $T'(x)$ with respect to $x$ to find the temperature distribution, $T(x)$:\n$$\nT(x) = \\int \\left(-5 \\exp(2x) + s + 5\\right) \\, dx = -5 \\frac{\\exp(2x)}{2} + (s + 5)x + C_2\n$$\n$$\nT(x) = -\\frac{5}{2} \\exp(2x) + (s + 5)x + C_2\n$$\nwhere $C_2$ is the second constant of integration. We use the initial condition $T(0) = 310$ to determine $C_2$:\n$$\n310 = T(0) = -\\frac{5}{2} \\exp(2 \\cdot 0) + (s+5)(0) + C_2 = -\\frac{5}{2} \\exp(0) + C_2 = -\\frac{5}{2} + C_2\n$$\nSolving for $C_2$:\n$$\nC_2 = 310 + \\frac{5}{2} = \\frac{620}{2} + \\frac{5}{2} = \\frac{625}{2}\n$$\nThe solution to the IVP, which depends on the parameter $s$, is therefore:\n$$\nT(x; s) = -\\frac{5}{2} \\exp(2x) + (s + 5)x + \\frac{625}{2}\n$$\nNow, we enforce the second boundary condition, $T(1) = 325$, to find the correct value of $s$. We set $x=1$ and $T(1;s) = 325$:\n$$\n325 = T(1; s) = -\\frac{5}{2} \\exp(2 \\cdot 1) + (s + 5)(1) + \\frac{625}{2}\n$$\n$$\n325 = -\\frac{5}{2} \\exp(2) + s + 5 + \\frac{625}{2}\n$$\nNow, we solve this linear equation for $s$. It is convenient to work with fractions: $325 = \\frac{650}{2}$ and $5 = \\frac{10}{2}$.\n$$\n\\frac{650}{2} = -\\frac{5}{2} \\exp(2) + s + \\frac{10}{2} + \\frac{625}{2}\n$$\n$$\n\\frac{650}{2} = s + \\frac{635}{2} - \\frac{5}{2} \\exp(2)\n$$\nIsolating $s$:\n$$\ns = \\frac{650}{2} - \\frac{635}{2} + \\frac{5}{2} \\exp(2)\n$$\n$$\ns = \\frac{15}{2} + \\frac{5}{2} \\exp(2)\n$$\nHaving found the unique value of the initial slope $s$, we substitute it back into the general solution $T(x;s)$ to obtain the final expression for $T(x)$:\n$$\nT(x) = -\\frac{5}{2} \\exp(2x) + \\left( \\left(\\frac{15}{2} + \\frac{5}{2} \\exp(2)\\right) + 5 \\right)x + \\frac{625}{2}\n$$\nWe simplify the coefficient of the $x$ term. Noting that $5 = \\frac{10}{2}$:\n$$\nT(x) = -\\frac{5}{2} \\exp(2x) + \\left( \\frac{15}{2} + \\frac{10}{2} + \\frac{5}{2} \\exp(2) \\right)x + \\frac{625}{2}\n$$\n$$\nT(x) = -\\frac{5}{2} \\exp(2x) + \\left( \\frac{25}{2} + \\frac{5}{2} \\exp(2) \\right)x + \\frac{625}{2}\n$$\nThis is the closed-form expression for the temperature distribution $T(x)$ along the rod.", "answer": "$$\n\\boxed{T(x) = -\\frac{5}{2} \\exp(2x) + \\left( \\frac{25}{2} + \\frac{5}{2} \\exp(2) \\right)x + \\frac{625}{2}}\n$$", "id": "3256898"}, {"introduction": "Having established the core concept, we now move to a full numerical implementation for a nonlinear problem. This hands-on coding practice [@problem_id:3248424] guides you through combining a Runge-Kutta integrator with the secant method to determine the correct initial slope $s$. This exercise is crucial for understanding how to solve problems where an analytical solution is not available and highlights the power of derivative-free root-finding algorithms, which approximate the derivative $F'(s)$, in the shooting framework.", "problem": "Consider the nonlinear second-order boundary value problem defined on a closed interval $[a,b]$ by the differential equation $y'' = y^2$ together with boundary conditions $y(a) = \\alpha$ and $y(b) = \\beta$. Reformulate this boundary value problem as a one-dimensional root-finding problem for a shooting parameter $s$, where $s$ represents the unknown initial slope $y'(a)$. Specifically, define the initial value problem with $y(a) = \\alpha$ and $y'(a) = s$, integrate to $x=b$ to obtain $y(b;s)$, and define the mismatch function $F(s) = y(b;s) - \\beta$. Use a root-finding algorithm based on secant updates to find $s$ such that $F(s) = 0$.\n\nYour program must:\n- Implement numerical integration of the initial value problem for $y'' = y^2$ via the classical fourth-order Runge–Kutta method with a uniform step size, by rewriting the second-order equation into the first-order system $y' = v$ and $v' = y^2$.\n- Implement the secant method to solve $F(s) = 0$, where each evaluation of $F(s)$ requires one numerical integration of the initial value problem from $x=a$ to $x=b$ with the chosen $s$.\n- Use a convergence tolerance for the mismatch magnitude of $10^{-8}$, and a maximum of $50$ secant iterations. If the denominator in the secant update becomes numerically zero, terminate and return the current iterate.\n- Choose two initial secant guesses for $s$ centered around the naive linear estimate $s_{\\text{lin}} = (\\beta - \\alpha)/(b-a)$, for example $s_0 = s_{\\text{lin}} - 0.1\\,(1+|s_{\\text{lin}}|)$ and $s_1 = s_{\\text{lin}} + 0.1\\,(1+|s_{\\text{lin}}|)$.\n\nBase your derivation and algorithm design on the following foundational principles:\n- Conversion of second-order ordinary differential equations into first-order systems using the definitions $y' = v$ and $v' = y^2$.\n- The shooting method, which reduces boundary value problems to root-finding for the unknown initial slope by enforcing terminal boundary conditions through the mismatch function $F(s)$.\n- The secant method, which approximates the derivative in Newton’s method by finite differences, producing an update $s_{k+1} = s_k - F(s_k)\\,(s_k - s_{k-1})/(F(s_k)-F(s_{k-1}))$ when $F(s_k) \\neq F(s_{k-1})$.\n\nTest Suite:\nRun your program on the following four test cases, each specified as a tuple $(a,b,\\alpha,\\beta,N)$ where $N$ is the number of uniform Runge–Kutta steps used for integration over $[a,b]$:\n1. $(0.0, 1.0, 0.0, 0.0, 200)$ is a baseline case with trivial boundary data.\n2. $(0.0, 1.0, 0.0, 0.1, 200)$ is a happy-path case with small positive terminal value.\n3. $(0.0, 0.5, 0.2, 0.25, 150)$ tests moderate positive initial and terminal values on a shorter interval.\n4. $(0.0, 0.5, 0.1, 0.0, 150)$ tests a case requiring a negative shooting parameter to decrease from a positive initial value to a smaller terminal value.\n\nAnswer Specification:\n- For each test case, compute and return the shooting parameter $s$ that makes $F(s)$ approximately zero to the specified tolerance.\n- The final output must be a single line containing the four computed $s$ values as a comma-separated list enclosed in square brackets. Each value must be a floating-point number printed with exactly eight digits after the decimal point, in the order of the test cases given above, for example $[s_1,s_2,s_3,s_4]$.\n- No physical units or angle units are involved in this problem. All outputs are real numbers with eight decimal places.\n\nYour program must be a complete, runnable implementation that performs the described computations and prints the results in the exact format specified.", "solution": "The user wants to solve a nonlinear second-order boundary value problem and has provided a detailed set of instructions for the validation and solution process. I will first validate the problem to ensure it is scientifically sound and well-posed, and then proceed with the solution if it is valid.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Differential Equation:** $y'' = y^2$\n- **Domain:** Closed interval $[a, b]$\n- **Boundary Conditions:** $y(a) = \\alpha$, $y(b) = \\beta$\n- **Methodology:** Shooting method combined with a secant root-finding algorithm.\n- **Shooting Formulation:**\n    - An initial value problem (IVP) is defined with initial conditions $y(a) = \\alpha$ and $y'(a) = s$, where $s$ is the shooting parameter.\n    - The solution to this IVP, evaluated at $x=b$, is denoted $y(b;s)$.\n    - A mismatch function is defined as $F(s) = y(b;s) - \\beta$.\n    - The goal is to find a root $s$ of the equation $F(s) = 0$.\n- **IVP Solver:**\n    - The second-order ODE is rewritten as a first-order system: $y' = v$, $v' = y^2$.\n    - The integration method is the classical fourth-order Runge–Kutta (RK4) method.\n    - The integration interval $[a,b]$ is divided into $N$ uniform steps.\n- **Root-Finding Algorithm:**\n    - **Method:** Secant method.\n    - **Update Rule:** $s_{k+1} = s_k - F(s_k)\\,(s_k - s_{k-1})/(F(s_k)-F(s_{k-1}))$.\n    - **Convergence Criterion:** The magnitude of the mismatch, $|F(s)|$, must be less than $10^{-8}$.\n    - **Maximum Iterations:** $50$.\n    - **Termination Condition:** The iteration stops if the denominator in the secant update, $|F(s_k) - F(s_{k-1})|$, is numerically close to zero.\n- **Initial Guesses for Secant Method:**\n    - **Linear Estimate:** $s_{\\text{lin}} = (\\beta - \\alpha)/(b-a)$.\n    - **Initial Iterates:** $s_0 = s_{\\text{lin}} - 0.1\\,(1+|s_{\\text{lin}}|)$ and $s_1 = s_{\\text{lin}} + 0.1\\,(1+|s_{\\text{lin}}|)$.\n- **Test Suite:**\n    - Case 1: $(a,b,\\alpha,\\beta,N) = (0.0, 1.0, 0.0, 0.0, 200)$\n    - Case 2: $(a,b,\\alpha,\\beta,N) = (0.0, 1.0, 0.0, 0.1, 200)$\n    - Case 3: $(a,b,\\alpha,\\beta,N) = (0.0, 0.5, 0.2, 0.25, 150)$\n    - Case 4: $(a,b,\\alpha,\\beta,N) = (0.0, 0.5, 0.1, 0.0, 150)$\n- **Output Format:** A single line with a comma-separated list of the four computed shooting parameters, enclosed in square brackets, with each value formatted to eight decimal places (e.g., `[s_1,s_2,s_3,s_4]`).\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded:** The problem is a standard application of numerical methods to solve ordinary differential equations. The equation $y'' = y^2$ is a specific case of the Emden–Fowler equation, a well-studied topic in mathematics. The proposed methods—shooting, conversion to a first-order system, Runge-Kutta integration, and the secant method—are all canonical, well-established algorithms in scientific computing. The problem is therefore scientifically and mathematically sound.\n- **Well-Posed:** The numerical task is well-posed. It provides a clear objective and a complete set of instructions, including the governing equation, boundary conditions, numerical methods, convergence criteria, and initial guess generation. While nonlinear boundary value problems do not always guarantee a unique solution, the computational procedure to find *a* solution is unambiguously defined.\n- **Objective:** The problem is stated in precise, objective mathematical language, free from ambiguity or subjective claims.\n\nThe problem does not exhibit any of the invalidity flaws:\n1.  **Scientific Unsoundness:** None. The principles are correct.\n2.  **Non-Formalizable/Irrelevant:** None. The problem is directly relevant to its stated topic of the linear shooting method.\n3.  **Incomplete/Contradictory:** None. All parameters and procedural details are provided.\n4.  **Unrealistic/Infeasible:** None. The problem is a purely mathematical exercise.\n5.  **Ill-Posed/Poorly Structured:** None. The numerical algorithm is clearly structured, including handling of potential failure modes like division by zero.\n6.  **Pseudo-Profound/Trivial:** None. The problem requires the non-trivial implementation and combination of several numerical algorithms.\n7.  **Outside Scientific Verifiability:** None. The results are computationally reproducible.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A solution will be developed by implementing the specified numerical algorithms.\n\n### Solution\n\nThe solution to the nonlinear boundary value problem (BVP) $y'' = y^2$ with boundary conditions $y(a) = \\alpha$ and $y(b) = \\beta$ will be constructed based on the shooting method. This involves three core principles: converting the BVP into an initial value problem (IVP), integrating the IVP numerically, and using a root-finding algorithm to satisfy the terminal boundary condition.\n\n**1. Conversion of the Second-Order ODE to a First-Order System**\n\nTo apply standard numerical integrators like Runge-Kutta, the second-order ODE must be expressed as a system of first-order ODEs. We introduce a new state variable, $v$, representing the first derivative of $y$:\n$$\ny' = v\n$$\nDifferentiating this expression gives $y'' = v'$. Substituting this into the original ODE, $y'' = y^2$, yields:\n$$\nv' = y^2\n$$\nWe can now define a state vector $\\mathbf{u}(x) = [y(x), v(x)]^T$. The first-order system is then given by:\n$$\n\\frac{d\\mathbf{u}}{dx} = \\mathbf{f}(x, \\mathbf{u}) = \\begin{pmatrix} y' \\\\ v' \\end{pmatrix} = \\begin{pmatrix} v \\\\ y^2 \\end{pmatrix}\n$$\nThe initial conditions for this system at $x=a$ are derived from the BVP's condition at $a$ and the introduction of the shooting parameter $s$:\n$$\n\\mathbf{u}(a) = \\begin{pmatrix} y(a) \\\\ v(a) \\end{pmatrix} = \\begin{pmatrix} y(a) \\\\ y'(a) \\end{pmatrix} = \\begin{pmatrix} \\alpha \\\\ s \\end{pmatrix}\n$$\n\n**2. The Shooting Method and the Mismatch Function**\n\nThe shooting method re-frames the BVP as a root-finding problem. For any chosen initial slope $s = y'(a)$, the first-order system above becomes a well-defined IVP. We can integrate this IVP from $x=a$ to $x=b$. The resulting value of $y$ at $x=b$ will be a function of the initial choice of $s$, which we denote as $y(b; s)$.\n\nThe goal is to find the specific value of $s$ for which this computed terminal value matches the desired boundary condition, $y(b) = \\beta$. This is expressed by defining a mismatch function, $F(s)$, which must be zero for the correct $s$:\n$$\nF(s) = y(b; s) - \\beta = 0\n$$\nSolving the BVP is now equivalent to finding the root of the function $F(s)$.\n\n**3. Numerical Integration via the Fourth-Order Runge-Kutta (RK4) Method**\n\nTo evaluate $F(s)$ for a given $s$, we must numerically solve the IVP from $x=a$ to $x=b$. The problem specifies the classical fourth-order Runge-Kutta method with a uniform step size $h = (b-a)/N$. Given the state $\\mathbf{u}_i$ at step $i$, the state $\\mathbf{u}_{i+1}$ at the next step is calculated as follows:\n$$\n\\mathbf{k}_1 = h \\mathbf{f}(x_i, \\mathbf{u}_i) \\\\\n\\mathbf{k}_2 = h \\mathbf{f}(x_i + h/2, \\mathbf{u}_i + \\mathbf{k}_1/2) \\\\\n\\mathbf{k}_3 = h \\mathbf{f}(x_i + h/2, \\mathbf{u}_i + \\mathbf{k}_2/2) \\\\\n\\mathbf{k}_4 = h \\mathbf{f}(x_i + h, \\mathbf{u}_i + \\mathbf{k}_3) \\\\\n\\mathbf{u}_{i+1} = \\mathbf{u}_i + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nwhere $\\mathbf{u}_i = [y_i, v_i]^T$. The process starts with $\\mathbf{u}_0 = [\\alpha, s]^T$ and iterates $N$ times to obtain $\\mathbf{u}_N = [y_N, v_N]^T$, which is our numerical approximation for $\\mathbf{u}(b)$. The value $y(b;s)$ is then approximated by $y_N$.\n\n**4. Root-Finding via the Secant Method**\n\nThe secant method is an iterative root-finding algorithm that approximates the derivative in Newton's method using a finite difference. Given two initial guesses for the slope, $s_0$ and $s_1$, and their corresponding function values, $F_0 = F(s_0)$ and $F_1 = F(s_1)$, the next guess $s_2$ is found by linearly extrapolating to the root. The general update rule is:\n$$\ns_{k+1} = s_k - F(s_k) \\frac{s_k - s_{k-1}}{F(s_k) - F(s_{k-1})}\n$$\nThe procedure for finding the root is as follows:\n1.  Calculate the naive linear slope estimate: $s_{\\text{lin}} = (\\beta - \\alpha)/(b-a)$.\n2.  Generate two initial guesses: $s_0 = s_{\\text{lin}} - 0.1\\,(1+|s_{\\text{lin}}|)$ and $s_1 = s_{\\text{lin}} + 0.1\\,(1+|s_{\\text{lin}}|)$.\n3.  Compute $F_0 = F(s_0)$ and $F_1 = F(s_1)$ by performing two separate RK4 integrations.\n4.  Iterate using the secant update rule for at most $50$ iterations or until $|F(s_k)| < 10^{-8}$. The iteration is also terminated if the denominator $|F(s_k) - F(s_{k-1})|$ becomes too small, indicating a potential stall or division by zero.\n5.  The final iterate $s_k$ that satisfies the convergence criterion is the desired shooting parameter.\n\nBy integrating these four principles, we can construct a program to solve the given BVP for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the BVP for the given test cases and print the results.\n    \"\"\"\n\n    def run_rk4(f_ode, u0, x_span, n_steps):\n        \"\"\"\n        Integrates a system of first-order ODEs using the classical RK4 method.\n\n        Args:\n            f_ode (callable): The function defining the ODE system, f(x, u).\n            u0 (np.ndarray): The initial state vector [y0, v0].\n            x_span (tuple): The integration interval (a, b).\n            n_steps (int): The number of uniform steps for integration.\n\n        Returns:\n            np.ndarray: The final state vector [y_b, v_b].\n        \"\"\"\n        a, b = x_span\n        h = (b - a) / n_steps\n        u = u0.copy()\n        x = a\n\n        for _ in range(n_steps):\n            k1 = h * f_ode(x, u)\n            k2 = h * f_ode(x + h / 2.0, u + k1 / 2.0)\n            k3 = h * f_ode(x + h / 2.0, u + k2 / 2.0)\n            k4 = h * f_ode(x + h, u + k3)\n            u += (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n            x += h\n\n        return u\n\n    def shooting_solver(params):\n        \"\"\"\n        Solves the BVP for a single set of parameters using the shooting method with a secant root-finder.\n\n        Args:\n            params (tuple): A tuple containing (a, b, alpha, beta, N).\n\n        Returns:\n            float: The computed shooting parameter s.\n        \"\"\"\n        a, b, alpha, beta, N = params\n        \n        # Define the first-order ODE system: u' = f(x, u) = [v, y^2]\n        # where u = [y, v]\n        def f_ode(x, u):\n            return np.array([u[1], u[0]**2])\n\n        # Define the mismatch function F(s) = y(b; s) - beta\n        # Each evaluation requires one full RK4 integration.\n        def F(s):\n            u0 = np.array([alpha, s])\n            u_final = run_rk4(f_ode, u0, (a, b), N)\n            y_b = u_final[0]\n            return y_b - beta\n\n        # Secant method parameters\n        TOL = 1e-8\n        MAX_ITER = 50\n        NUM_ZERO = 1e-15 # Denominator tolerance\n\n        # 1. Calculate initial guesses for the secant method\n        if abs(b - a) < NUM_ZERO:\n            s_lin = 0.0 # Avoid division by zero, though not expected for given tests\n        else:\n            s_lin = (beta - alpha) / (b - a)\n\n        s0 = s_lin - 0.1 * (1.0 + abs(s_lin))\n        s1 = s_lin + 0.1 * (1.0 + abs(s_lin))\n        \n        f0 = F(s0)\n        f1 = F(s1)\n\n        # 2. Iterate using secant method\n        for _ in range(MAX_ITER):\n            # Check for convergence\n            if abs(f1) < TOL:\n                break\n            \n            # Check for stall / division by zero\n            denom = f1 - f0\n            if abs(denom) < NUM_ZERO:\n                break\n            \n            # Secant update\n            s_next = s1 - f1 * (s1 - s0) / denom\n            \n            # Update states\n            s0, s1 = s1, s_next\n            f0, f1 = f1, F(s1)\n            \n        return s1\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 1.0, 0.0, 0.0, 200),  # Case 1\n        (0.0, 1.0, 0.0, 0.1, 200),  # Case 2\n        (0.0, 0.5, 0.2, 0.25, 150), # Case 3\n        (0.0, 0.5, 0.1, 0.0, 150),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        s_final = shooting_solver(case)\n        results.append(s_final)\n    \n    # Format the results as specified\n    formatted_results = [f\"{r:.8f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3248424"}, {"introduction": "For our final practice, we will enhance our solver by implementing a more powerful root-finding algorithm: Newton's method. This method's rapid convergence requires the derivative of the shooting function, $R'(s)$, which we will compute by simultaneously integrating a set of auxiliary differential equations known as the variational equations. This advanced implementation [@problem_id:3256899] demonstrates a sophisticated technique for building highly efficient and accurate solvers for nonlinear boundary value problems.", "problem": "Implement a program that solves nonlinear two-point boundary value problems by the shooting method with Newton-Raphson iteration on the unknown initial slope and with simultaneous integration of the variational (sensitivity) equation for $\\partial y/\\partial s$. The fundamental base for the design is the standard reduction of a second-order ordinary differential equation (ODE) to a first-order system and the chain rule for sensitivity of the terminal value with respect to the initial slope.\n\nYou are given a scalar second-order ODE of the form\n$$\ny''(x) = f\\big(x, y(x), y'(x)\\big),\n$$\nposed on the interval $[a,b]$ with boundary conditions\n$$\ny(a) = \\alpha,\\quad y(b) = \\beta,\n$$\nwhere $f$ is a sufficiently smooth function. The shooting method treats the unknown initial slope $s = y'(a)$ as a parameter and defines the residual\n$$\nR(s) = y(b; s) - \\beta,\n$$\nwhere $y(b; s)$ is the terminal value obtained by integrating the initial value problem\n$$\n\\begin{aligned}\ny'(x) &= p(x),\\\\\np'(x) &= f(x, y(x), p(x)),\\\\\ny(a) &= \\alpha,\\quad p(a) = s,\n\\end{aligned}\n$$\nfrom $x=a$ to $x=b$. Newton-Raphson iteration updates $s$ by\n$$\ns_{k+1} = s_k - \\frac{R(s_k)}{R'(s_k)},\n$$\nrequiring the derivative $R'(s)$. By differentiating the first-order system with respect to $s$ and applying the chain rule, the sensitivity system is\n$$\n\\begin{aligned}\nv_1'(x) &= v_2(x),\\\\\nv_2'(x) &= \\frac{\\partial f}{\\partial y}(x, y(x), p(x))\\, v_1(x) + \\frac{\\partial f}{\\partial p}(x, y(x), p(x))\\, v_2(x),\\\\\nv_1(a) &= 0,\\quad v_2(a) = 1,\n\\end{aligned}\n$$\nwhere $v_1(x) = \\frac{\\partial y(x)}{\\partial s}$ and $v_2(x) = \\frac{\\partial p(x)}{\\partial s}$. Then $R'(s) = v_1(b)$. Your implementation must integrate $(y,p,v_1,v_2)$ simultaneously using the classical fourth-order Runge-Kutta method (RK4) and must perform Newton-Raphson updates of $s$. To promote robust convergence, use a simple backtracking line search on the Newton step: if a full Newton update does not reduce $|R(s)|$, halve the step repeatedly until a reduction is achieved or until a small step factor threshold is reached.\n\nNumerical integration details:\n- Use the classical fourth-order Runge-Kutta method (RK4) on the augmented system for $(y,p,v_1,v_2)$ with a uniform step size $h = (b-a)/N$, where $N$ is a positive integer provided per test case.\n- Terminate Newton-Raphson when $|R(s)| \\le \\varepsilon$ with $\\varepsilon = 10^{-10}$ or after a maximum of $M = 30$ iterations. If backtracking fails to reduce the residual after $L = 20$ halvings, accept the attempted update and continue.\n\nTest suite:\nImplement the solver and apply it to the following three boundary value problems. In each case, define $f$, its partial derivatives $\\frac{\\partial f}{\\partial y}$ and $\\frac{\\partial f}{\\partial p}$, the interval endpoints $a$ and $b$, boundary values $\\alpha$ and $\\beta$, the initial guess $s_0$, and the number of integration steps $N$.\n\n- Case $1$ (nonlinear with dependence on $y'$):\n  - $f(x,y,p) = \\sin(y) + x\\,p$\n  - $\\frac{\\partial f}{\\partial y}(x,y,p) = \\cos(y)$\n  - $\\frac{\\partial f}{\\partial p}(x,y,p) = x$\n  - $a = 0$, $b = 1$\n  - $\\alpha = 0$, $\\beta = 0.5$\n  - $s_0 = 0.3$\n  - $N = 2000$\n\n- Case $2$ (nonlinear with trivial solution as a boundary condition edge case):\n  - $f(x,y,p) = y^3 - y$\n  - $\\frac{\\partial f}{\\partial y}(x,y,p) = 3y^2 - 1$\n  - $\\frac{\\partial f}{\\partial p}(x,y,p) = 0$\n  - $a = 0$, $b = 1$\n  - $\\alpha = 0$, $\\beta = 0$\n  - $s_0 = 1.0$\n  - $N = 2000$\n\n- Case $3$ (linear reference problem for accuracy validation):\n  - $f(x,y,p) = y$\n  - $\\frac{\\partial f}{\\partial y}(x,y,p) = 1$\n  - $\\frac{\\partial f}{\\partial p}(x,y,p) = 0$\n  - $a = 0$, $b = 1$\n  - $\\alpha = 0$, $\\beta = 1$\n  - $s_0 = 0.5$\n  - $N = 2000$\n\nOutput specification:\n- For each test case, compute the Newton-Raphson estimate $s^\\ast$ of the shooting parameter $s$ such that $|R(s^\\ast)| \\le \\varepsilon$.\n- Express each $s^\\ast$ as a decimal rounded to eight decimal places.\n- Your program should produce a single line of output containing the three rounded values as a comma-separated list enclosed in square brackets, for example, $[s_1,s_2,s_3]$.\n\nNo physical units or angle units are involved in this problem. All outputs are dimensionless real numbers.", "solution": "The problem presented requires the implementation of a numerical algorithm to solve a nonlinear two-point boundary value problem (BVP) of the form\n$$\ny''(x) = f\\big(x, y(x), y'(x)\\big), \\quad x \\in [a,b]\n$$\nwith boundary conditions $y(a) = \\alpha$ and $y(b) = \\beta$. The specified method is the nonlinear shooting method, where the BVP is converted into an initial value problem (IVP) and the unknown initial condition is adjusted iteratively until the boundary condition at the far end is met. The iterative adjustment is to be performed using the Newton-Raphson method, which necessitates the derivative of the final state with respect to the initial condition. This derivative is to be found by integrating a set of auxiliary differential equations known as the sensitivity equations.\n\nFirst, let us formalize the shooting method framework. We reduce the second-order ODE to a system of two first-order ODEs by letting $p(x) = y'(x)$. The system is then:\n$$\n\\begin{aligned}\ny'(x) &= p(x) \\\\\np'(x) &= f(x, y(x), p(x)).\n\\end{aligned}\n$$\nThe boundary conditions are $y(a) = \\alpha$ and $y(b) = \\beta$. In the shooting method, we treat this as an IVP starting from $x=a$. The initial condition $y(a)=\\alpha$ is known, but $p(a) = y'(a)$ is not. We shall denote this unknown initial slope as a parameter, $s$, so that $p(a) = s$. With this, we can integrate the system from $x=a$ to $x=b$. The value of $y$ at $x=b$ will depend on our choice of $s$. Let us denote this functional dependence as $y(b; s)$. The objective is to find the value of $s$ for which the computed terminal value matches the required boundary condition, i.e., $y(b; s) = \\beta$. This condition is expressed by defining a residual function, $R(s)$, whose root we seek:\n$$\nR(s) = y(b; s) - \\beta = 0.\n$$\nThis is a root-finding problem for the single variable $s$. The problem specifies using the Newton-Raphson method for this task. The iterative formula for updating an estimate $s_k$ to a new estimate $s_{k+1}$ is:\n$$\ns_{k+1} = s_k - \\frac{R(s_k)}{R'(s_k)},\n$$\nwhere $R'(s_k)$ is the derivative of the residual function with respect to $s$, evaluated at $s_k$. This derivative is $R'(s) = \\frac{d}{ds} \\left( y(b; s) - \\beta \\right) = \\frac{\\partial y(b; s)}{\\partial s}$.\n\nTo find $\\frac{\\partial y(b; s)}{\\partial s}$, we derive the sensitivity equations. Let us define the sensitivity variables $v_1(x) = \\frac{\\partial y(x)}{\\partial s}$ and $v_2(x) = \\frac{\\partial p(x)}{\\partial s}$. We differentiate the first-order system with respect to $s$ using the chain rule:\n$$\n\\frac{\\partial}{\\partial s} (y'(x)) = \\frac{\\partial}{\\partial s} (p(x)) \\implies \\left(\\frac{\\partial y}{\\partial s}\\right)' = \\frac{\\partial p}{\\partial s} \\implies v_1'(x) = v_2(x).\n$$\n$$\n\\frac{\\partial}{\\partial s} (p'(x)) = \\frac{\\partial}{\\partial s} f(x, y, p) \\implies \\left(\\frac{\\partial p}{\\partial s}\\right)' = \\frac{\\partial f}{\\partial y} \\frac{\\partial y}{\\partial s} + \\frac{\\partial f}{\\partial p} \\frac{\\partial p}{\\partial s} \\implies v_2'(x) = \\frac{\\partial f}{\\partial y} v_1(x) + \\frac{\\partial f}{\\partial p} v_2(x).\n$$\nThis gives us a linear system of ODEs for the sensitivities $(v_1, v_2)$. To solve it, we require a set of initial conditions at $x=a$. These are derived from the initial conditions of the primary system:\n$$\ny(a) = \\alpha \\implies v_1(a) = \\frac{\\partial y(a)}{\\partial s} = \\frac{\\partial \\alpha}{\\partial s} = 0.\n$$\n$$\np(a) = s \\implies v_2(a) = \\frac{\\partial p(a)}{\\partial s} = \\frac{\\partial s}{\\partial s} = 1.\n$$\nThe derivative of the residual is then $R'(s) = v_1(b)$.\n\nThe overall strategy is to solve an augmented system of four first-order ODEs for the state vector $\\mathbf{U}(x) = [y(x), p(x), v_1(x), v_2(x)]^T$. The governing equation is:\n$$\n\\mathbf{U}'(x) = \\mathbf{F}(x, \\mathbf{U}(x)) = \n\\begin{pmatrix}\np(x) \\\\\nf(x, y(x), p(x)) \\\\\nv_2(x) \\\\\n\\frac{\\partial f}{\\partial y} v_1(x) + \\frac{\\partial f}{\\partial p} v_2(x)\n\\end{pmatrix}.\n$$\nFor a given guess $s_k$, the initial condition for this augmented system at $x=a$ is $\\mathbf{U}(a) = [\\alpha, s_k, 0, 1]^T$.\n\nThe numerical procedure for one Newton-Raphson iteration is as follows:\n1.  Set the initial vector $\\mathbf{U}(a) = [\\alpha, s_k, 0, 1]^T$.\n2.  Integrate the $4$-dimensional system for $\\mathbf{U}'(x)$ from $x=a$ to $x=b$ using the classical fourth-order Runge-Kutta (RK4) method with a step size of $h=(b-a)/N$. The integration yields the terminal state vector $\\mathbf{U}(b) = [y(b;s_k), p(b;s_k), v_1(b;s_k), v_2(b;s_k)]^T$.\n3.  Calculate the residual $R(s_k) = y(b;s_k) - \\beta$.\n4.  Check for convergence: if $|R(s_k)| \\le \\varepsilon=10^{-10}$, the process terminates.\n5.  Calculate the derivative of the residual $R'(s_k) = v_1(b;s_k)$.\n6.  Compute the Newton step $\\Delta s_k = -R(s_k)/R'(s_k)$.\n7.  To ensure robust convergence, perform a backtracking line search. The full step $s_k + \\Delta s_k$ is attempted. If it does not reduce the magnitude of the residual, i.e., $|R(s_k + \\Delta s_k)| \\ge |R(s_k)|$, the step is halved repeatedly. A new trial step $\\lambda \\Delta s_k$ is tested with $\\lambda \\in \\{1, 1/2, 1/4, \\dots\\}$. The first value of $\\lambda$ that produces a reduction in the residual's magnitude is accepted.\n8.  If $L=20$ halvings fail to find a better step, the last attempted update (with the smallest $\\lambda$) is accepted, and the iteration proceeds.\n9.  Update the slope estimate, $s_{k+1} = s_k + \\lambda \\Delta s_k$, and repeat from step 1.\nThe process is terminated if convergence is achieved or after a maximum of $M=30$ iterations. The final value of $s_k$ is taken as the solution $s^\\ast$. This algorithm is implemented and applied to the three specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the specified boundary value problems and print the results.\n    \"\"\"\n    \n    # Define global constants for the Newton-Raphson solver\n    epsilon = 1e-10\n    max_iter = 30\n    max_backtrack = 20\n    \n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            \"f\": lambda x, y, p: np.sin(y) + x * p,\n            \"dfdy\": lambda x, y, p: np.cos(y),\n            \"dfdp\": lambda x, y, p: x,\n            \"a\": 0.0, \"b\": 1.0,\n            \"alpha\": 0.0, \"beta\": 0.5,\n            \"s0\": 0.3, \"N\": 2000\n        },\n        {\n            \"f\": lambda x, y, p: y**3 - y,\n            \"dfdy\": lambda x, y, p: 3 * y**2 - 1,\n            \"dfdp\": lambda x, y, p: 0.0,\n            \"a\": 0.0, \"b\": 1.0,\n            \"alpha\": 0.0, \"beta\": 0.0,\n            \"s0\": 1.0, \"N\": 2000\n        },\n        {\n            \"f\": lambda x, y, p: y,\n            \"dfdy\": lambda x, y, p: 1.0,\n            \"dfdp\": lambda x, y, p: 0.0,\n            \"a\": 0.0, \"b\": 1.0,\n            \"alpha\": 0.0, \"beta\": 1.0,\n            \"s0\": 0.5, \"N\": 2000\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        s_star = nonlinear_shooter(\n            case, epsilon, max_iter, max_backtrack\n        )\n        results.append(f\"{s_star:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef nonlinear_shooter(params, epsilon, max_iter, max_backtrack):\n    \"\"\"\n    Solves a two-point BVP using the nonlinear shooting method with Newton's iteration.\n    \n    Args:\n        params (dict): A dictionary containing all problem-specific parameters.\n        epsilon (float): The tolerance for the residual.\n        max_iter (int): Maximum number of Newton-Raphson iterations.\n        max_backtrack (int): Maximum number of step halvings in the line search.\n        \n    Returns:\n        float: The converged value of the initial slope 's'.\n    \"\"\"\n    f = params[\"f\"]\n    dfdy = params[\"dfdy\"]\n    dfdp = params[\"dfdp\"]\n    a = params[\"a\"]\n    b = params[\"b\"]\n    alpha = params[\"alpha\"]\n    beta = params[\"beta\"]\n    s0 = params[\"s0\"]\n    N = params[\"N\"]\n    \n    h = (b - a) / N\n\n    def F_augmented(x, U):\n        \"\"\"\n        Defines the right-hand side of the augmented 4D system of ODEs.\n        U = [y, p, v1, v2]\n        \"\"\"\n        y, p, v1, v2 = U\n        dy_dx = p\n        dp_dx = f(x, y, p)\n        dv1_dx = v2\n        dv2_dx = dfdy(x, y, p) * v1 + dfdp(x, y, p) * v2\n        return np.array([dy_dx, dp_dx, dv1_dx, dv2_dx])\n\n    def integrate_ivp(s_guess):\n        \"\"\"\n        Integrates the augmented IVP from a to b using RK4 for a given initial slope s.\n        Returns the terminal value y(b) and the sensitivity v1(b).\n        \"\"\"\n        U = np.array([alpha, s_guess, 0.0, 1.0])\n        x = a\n        for _ in range(N):\n            k1 = h * F_augmented(x, U)\n            k2 = h * F_augmented(x + h/2, U + k1/2)\n            k3 = h * F_augmented(x + h/2, U + k2/2)\n            k4 = h * F_augmented(x + h, U + k3)\n            U += (k1 + 2*k2 + 2*k3 + k4) / 6\n            x += h\n        return U[0], U[2] # y(b), v1(b)\n\n    s = s0\n    for _ in range(max_iter):\n        y_b, v1_b = integrate_ivp(s)\n        \n        R_s = y_b - beta\n        \n        if abs(R_s) <= epsilon:\n            return s\n            \n        Rp_s = v1_b\n        \n        if abs(Rp_s) < 1e-12:  # Prevent division by zero or extremely large steps\n            break\n            \n        delta_s = -R_s / Rp_s\n        \n        # Backtracking line search\n        lambda_factor = 1.0\n        updated_in_backtrack = False\n        last_s_trial = s # Fallback value\n        \n        for _ in range(max_backtrack):\n            s_trial = s + lambda_factor * delta_s\n            last_s_trial = s_trial\n            y_b_trial, _ = integrate_ivp(s_trial)\n            R_s_new = y_b_trial - beta\n\n            if abs(R_s_new) < abs(R_s):\n                s = s_trial\n                updated_in_backtrack = True\n                break\n            \n            lambda_factor /= 2.0\n            \n        if not updated_in_backtrack:\n            # If no better step was found after L halvings, accept the last attempted update.\n            s = last_s_trial\n\n    return s\n\nsolve()\n```", "id": "3256899"}]}