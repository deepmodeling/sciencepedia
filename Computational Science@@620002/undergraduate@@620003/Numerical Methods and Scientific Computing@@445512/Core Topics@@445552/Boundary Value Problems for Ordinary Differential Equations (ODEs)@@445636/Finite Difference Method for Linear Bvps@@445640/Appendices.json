{"hands_on_practices": [{"introduction": "Real-world problems rarely fit the simplest textbook models. This practice guides you through constructing a robust solver for a general self-adjoint BVP, which models phenomena like heat conduction with variable material properties. You will learn to handle variable coefficients and mixed boundary conditions, developing a versatile tool applicable to a wide range of scientific and engineering challenges. [@problem_id:3228073]", "problem": "Consider the linear second-order ordinary differential equation in divergence (self-adjoint) form\n$$\n-\\,\\frac{d}{dx}\\left(p(x)\\,\\frac{d u}{dx}\\right) + q(x)\\,u(x) = r(x),\n$$\nposed on the closed interval $[a,b]$, where $p(x)$, $q(x)$, and $r(x)$ are given sufficiently smooth functions with $p(x) > 0$, and the solution $u(x)$ is subject to mixed boundary conditions:\n$$\nu(a) = \\alpha \\quad \\text{(Dirichlet at } x=a\\text{)}, \\qquad u'(b) = \\beta \\quad \\text{(Neumann at } x=b\\text{)}.\n$$\nYour task is to derive, from first principles, a second-order accurate Finite Difference Method (FDM) discretization on a uniform grid and implement it to solve the boundary value problem. The derivation must start from the core definitions of the first derivative and Taylor series expansions about grid points, and must not assume any pre-known discrete stencil. Specifically:\n- Begin with the definitions of the first derivative and apply Taylor series expansions near grid points to obtain second-order approximations.\n- Use the resulting approximations to discretize the operator $-(p u')'$ consistently at interior grid points. Treat $p(x)$ at half-grid locations so that the discrete operator is conservative.\n- Impose the Dirichlet boundary condition by directly prescribing the value at $x=a$.\n- Impose the Neumann boundary condition at $x=b$ using a second-order one-sided difference formula derived by Taylor series.\n- Assemble and solve the resulting linear system for the nodal values of $u(x)$.\n\nImplementation requirements:\n- Use a uniform grid with $N$ equal subintervals, grid points $x_i = a + i h$ for $i=0,1,\\dots,N$, and grid spacing $h = (b-a)/N$.\n- At each interior grid point, approximate the differential operator using second-order consistent flux differences that depend on $p(x)$ evaluated at half-grid locations.\n- Enforce the Neumann boundary condition at $x=b$ with a second-order one-sided finite difference relation for $u'(b)$.\n\nTest suite:\nFor each test case below, compute the maximum absolute error over all grid points by comparing the numerical solution to the provided exact solution. The final numerical answers are dimensionless real numbers (no physical units). Express each result as a floating-point number rounded to six decimal places.\n\nTest cases:\n1. Conservative diffusion, no reaction:\n   - Domain: $[a,b] = [0,1]$, $N = 50$.\n   - Coefficients: $p(x) = 1$, $q(x) = 0$, $r(x) = \\sin(x)$.\n   - Exact solution: $u(x) = \\sin(x) + x$.\n   - Boundary data: $\\alpha = u(0)$, $\\beta = u'(1)$.\n\n2. Variable diffusivity, no reaction:\n   - Domain: $[a,b] = [0,1]$, $N = 40$.\n   - Coefficients: $p(x) = 1 + x$, $q(x) = 0$, and $r(x)$ chosen so that $u(x) = x^2$ solves the differential equation. Use $r(x) = -\\frac{d}{dx}\\left(p(x)\\,\\frac{d}{dx} x^2\\right) = -(2 + 4x)$.\n   - Exact solution: $u(x) = x^2$.\n   - Boundary data: $\\alpha = u(0)$, $\\beta = u'(1)$.\n\n3. Constant diffusivity with reaction:\n   - Domain: $[a,b] = [0,1]$, $N = 60$.\n   - Coefficients: $p(x) = 1$, $q(x) = 2$, $r(x)$ chosen so that $u(x) = e^x$ solves the differential equation. Use $r(x) = -u''(x) + q(x) u(x) = e^x$.\n   - Exact solution: $u(x) = e^x$.\n   - Boundary data: $\\alpha = u(0)$, $\\beta = u'(1)$.\n\n4. Edge-grid case to test boundary handling:\n   - Domain: $[a,b] = [0,1]$, $N = 2$.\n   - Coefficients: $p(x) = 1$, $q(x) = 0$, $r(x) = \\sin(x)$.\n   - Exact solution: $u(x) = \\sin(x) + x$.\n   - Boundary data: $\\alpha = u(0)$, $\\beta = u'(1)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is the maximum absolute error for the corresponding test case rounded to six decimal places.", "solution": "The user has provided a valid problem statement. I will proceed with the derivation and solution.\n\nWe are tasked with solving the linear second-order ordinary differential equation in self-adjoint form:\n$$\n-\\frac{d}{dx}\\left(p(x)\\frac{du}{dx}\\right) + q(x)u(x) = r(x), \\quad x \\in [a, b]\n$$\nwith mixed boundary conditions: a Dirichlet condition $u(a) = \\alpha$ and a Neumann condition $u'(b) = \\beta$. The functions $p(x)$, $q(x)$, and $r(x)$ are given, with $p(x) > 0$. We will derive a second-order accurate finite difference method on a uniform grid and implement it.\n\n**1. Grid and Notation**\n\nWe define a uniform grid on the interval $[a,b]$ with $N$ subintervals. The grid points are $x_i = a + i h$ for $i=0, 1, \\dots, N$, where the grid spacing is $h = (b-a)/N$. The numerical solution at these points will be denoted by $U_i \\approx u(x_i)$. The unknowns to be solved for are $U_1, U_2, \\dots, U_N$, since $U_0 = u(a) = \\alpha$ is given by the Dirichlet boundary condition. This gives a system of $N$ unknowns.\n\n**2. Discretization at Interior Points**\n\nThe differential equation can be written as $-F'(x) + q(x)u(x) = r(x)$, where $F(x) = p(x)u'(x)$ is the flux.\nAt an interior grid point $x_i$ for $i=1, \\dots, N-1$, we approximate the term $-F'(x_i)$ using a second-order central difference centered at $x_i$:\n$$\n-F'(x_i) \\approx -\\frac{F(x_i + h/2) - F(x_i - h/2)}{h}\n$$\nThe half-grid points are denoted as $x_{i \\pm 1/2} = x_i \\pm h/2$. This approximation is $O(h^2)$ accurate.\n\nTo maintain second-order accuracy and the conservative property of the operator, we approximate the flux $F$ at these half-grid points. At $x_{i+1/2}$, we have $F(x_{i+1/2}) = p(x_{i+1/2}) u'(x_{i+1/2})$. We approximate the derivative $u'(x_{i+1/2})$ using a second-order central difference centered at $x_{i+1/2}$:\n$$\nu'(x_{i+1/2}) \\approx \\frac{u(x_{i+1}) - u(x_i)}{h} = \\frac{U_{i+1} - U_i}{h} + O(h^2)\n$$\nLetting $p_{i+1/2} = p(x_{i+1/2})$, the flux approximation is:\n$$\nF_{i+1/2} \\approx p_{i+1/2} \\frac{U_{i+1} - U_i}{h}\n$$\nSimilarly, at $x_{i-1/2}$:\n$$\nF_{i-1/2} \\approx p_{i-1/2} \\frac{U_i - U_{i-1}}{h}\n$$\nSubstituting these flux approximations back into the approximation for $-F'(x_i)$:\n$$\n-\\frac{d}{dx}\\left(p(x)\\frac{du}{dx}\\right)\\bigg|_{x_i} \\approx -\\frac{1}{h} \\left( p_{i+1/2} \\frac{U_{i+1} - U_i}{h} - p_{i-1/2} \\frac{U_i - U_{i-1}}{h} \\right)\n$$\n$$\n= \\frac{1}{h^2} \\left[ -p_{i-1/2} U_{i-1} + (p_{i-1/2} + p_{i+1/2}) U_i - p_{i+1/2} U_{i+1} \\right]\n$$\nThe full discretized equation at an interior point $x_i$ ($i=1, \\dots, N-1$) is:\n$$\n\\frac{1}{h^2} \\left[ -p_{i-1/2} U_{i-1} + (p_{i-1/2} + p_{i+1/2}) U_i - p_{i+1/2} U_{i+1} \\right] + q(x_i) U_i = r(x_i)\n$$\nMultiplying by $h^2$, we obtain the linear equation for row $i$:\n$$\n-p_{i-1/2} U_{i-1} + (p_{i-1/2} + p_{i+1/2} + h^2 q_i) U_i - p_{i+1/2} U_{i+1} = h^2 r_i\n$$\nwhere $q_i=q(x_i)$ and $r_i=r(x_i)$.\n\n**3. Discretization of Boundary Conditions**\n\nThe system requires $N$ equations for the $N$ unknowns $U_1, \\dots, U_N$. We have $N-1$ equations from the interior points. The remaining equation comes from the Neumann boundary condition at $x_N=b$.\n\n**Dirichlet condition at $x_0 = a$:**\nThe value $U_0$ is known: $U_0 = \\alpha$. This value is not an unknown. For the first equation ($i=1$), the term involving $U_0$ is moved to the right-hand side:\n$$\n(p_{1/2} + p_{3/2} + h^2 q_1) U_1 - p_{3/2} U_2 = h^2 r_1 + p_{1/2} U_0 = h^2 r_1 + p_{1/2} \\alpha\n$$\n\n**Neumann condition at $x_N = b$:**\nThe condition is $u'(b) = \\beta$. We are required to use a second-order accurate one-sided difference formula. We derive this by considering Taylor series expansions of $u(x)$ around $x_N$:\n$$\nu(x_{N-1}) = u(x_N - h) = u(x_N) - h u'(x_N) + \\frac{h^2}{2} u''(x_N) - \\frac{h^3}{6} u'''(x_N) + O(h^4)\n$$\n$$\nu(x_{N-2}) = u(x_N - 2h) = u(x_N) - 2h u'(x_N) + \\frac{(2h)^2}{2} u''(x_N) - \\frac{(2h)^3}{6} u'''(x_N) + O(h^4)\n$$\nTo create a formula for $u'(x_N)$ that is $O(h^2)$, we must eliminate the $u''(x_N)$ term. We multiply the first equation by $4$ and subtract the second:\n$$\n4u(x_{N-1}) - u(x_{N-2}) = 3u(x_N) - 2h u'(x_N) + O(h^3)\n$$\nSolving for $u'(x_N)$:\n$$\nu'(x_N) = \\frac{3u(x_N) - 4u(x_{N-1}) + u(x_{N-2})}{2h} + O(h^2)\n$$\nApplying this to our discrete problem at $x_N=b$, we get the final equation:\n$$\n\\frac{3U_N - 4U_{N-1} + U_{N-2}}{2h} = \\beta\n$$\nThis can be written as: $U_{N-2} - 4U_{N-1} + 3U_N = 2h\\beta$. Note that for the special case $N=2$, the point $x_{N-2}$ is $x_0$, so the equation involves the known value $U_0 = \\alpha$: $-4U_1 + 3U_2 = 2h\\beta - U_0 = 2h\\beta - \\alpha$.\n\n**4. Assembling the Linear System**\n\nWe assemble the $N \\times N$ linear system $A \\vec{U} = \\vec{F}$, where the vector of unknowns is $\\vec{U} = [U_1, U_2, \\dots, U_N]^T$. Let the matrix and vector indices be 0-based in correspondence with programming practice, where row/column $k$ corresponds to unknown $U_{k+1}$.\n\nFor $k = 0, \\dots, N-2$ (representing the ODE at grid points $x_{k+1}$):\nThe equation for $x_{j}$ ($j=k+1$) is: $-p_{j-\\frac{1}{2}}U_{j-1} + (p_{j-\\frac{1}{2}}+p_{j+\\frac{1}{2}}+h^2q_j)U_j -p_{j+\\frac{1}{2}}U_{j+1} = h^2r_j$.\n- **Row $k=0$ (for $U_1$):**\n  $A_{0,0} = p_{1/2} + p_{3/2} + h^2 q_1$\n  $A_{0,1} = -p_{3/2}$\n  $F_0 = h^2 r_1 + p_{1/2} \\alpha$\n- **Rows $k=1, \\dots, N-2$ (for $U_2, \\dots, U_{N-1}$):**\n  $j = k+1$. The unknowns are $U_j, U_{j \\pm 1}$, corresponding to `U_vec` indices $k, k \\pm 1$.\n  $A_{k, k-1} = -p_{k+1/2}$\n  $A_{k, k} = p_{k+1/2} + p_{k+3/2} + h^2 q_{k+1}$\n  $A_{k, k+1} = -p_{k+3/2}$\n  $F_k = h^2 r_{k+1}$\n\n- **Row $k=N-1$ (for $U_N$, from Neumann BC):**\n  - If $N \\ge 3$: The equation is $U_{N-2} - 4U_{N-1} + 3U_N = 2h\\beta$. The unknowns involved correspond to `U_vec` indices $N-3, N-2, N-1$.\n    $A_{N-1, N-3} = 1$\n    $A_{N-1, N-2} = -4$\n    $A_{N-1, N-1} = 3$\n    $F_{N-1} = 2h\\beta$\n  - If $N=2$: The equation is $-4U_1 + 3U_2 = 2h\\beta - \\alpha$. The unknowns are $U_1, U_2$, corresponding to `U_vec` indices $0, 1$.\n    $A_{1,0} = -4$\n    $A_{1,1} = 3$\n    $F_1 = 2h\\beta - \\alpha$\n\nThis fully specified linear system can be solved for $\\vec{U}$. The full numerical solution is then given by concatenating the Dirichlet value with the solved unknowns: $[U_0, U_1, \\dots, U_N]$. The maximum absolute error is then computed by comparing this vector with the exact solution evaluated at the grid points.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the solver.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Conservative diffusion, no reaction\",\n            \"a\": 0.0, \"b\": 1.0, \"N\": 50,\n            \"p\": lambda x: 1.0,\n            \"q\": lambda x: 0.0,\n            \"r\": lambda x: np.sin(x),\n            \"u_exact\": lambda x: np.sin(x) + x,\n            \"du_exact\": lambda x: np.cos(x) + 1.0,\n        },\n        {\n            \"name\": \"Variable diffusivity, no reaction\",\n            \"a\": 0.0, \"b\": 1.0, \"N\": 40,\n            \"p\": lambda x: 1.0 + x,\n            \"q\": lambda x: 0.0,\n            \"r\": lambda x: -(2.0 + 4.0 * x),\n            \"u_exact\": lambda x: x**2,\n            \"du_exact\": lambda x: 2.0 * x,\n        },\n        {\n            \"name\": \"Constant diffusivity with reaction\",\n            \"a\": 0.0, \"b\": 1.0, \"N\": 60,\n            \"p\": lambda x: 1.0,\n            \"q\": lambda x: 2.0,\n            \"r\": lambda x: np.exp(x),\n            \"u_exact\": lambda x: np.exp(x),\n            \"du_exact\": lambda x: np.exp(x),\n        },\n        {\n            \"name\": \"Edge-grid case\",\n            \"a\": 0.0, \"b\": 1.0, \"N\": 2,\n            \"p\": lambda x: 1.0,\n            \"q\": lambda x: 0.0,\n            \"r\": lambda x: np.sin(x),\n            \"u_exact\": lambda x: np.sin(x) + x,\n            \"du_exact\": lambda x: np.cos(x) + 1.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha = case[\"u_exact\"](case[\"a\"])\n        beta = case[\"du_exact\"](case[\"b\"])\n\n        U_numerical, x_grid = solve_bvp(\n            p=case[\"p\"], q=case[\"q\"], r=case[\"r\"],\n            a=case[\"a\"], b=case[\"b\"], N=case[\"N\"],\n            alpha=alpha, beta=beta\n        )\n\n        U_exact_vals = case[\"u_exact\"](x_grid)\n        max_abs_error = np.max(np.abs(U_numerical - U_exact_vals))\n        results.append(f\"{max_abs_error:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_bvp(p, q, r, a, b, N, alpha, beta):\n    \"\"\"\n    Solves the BVP using the derived finite difference scheme.\n    \n    The system is A * U_vec = F, where U_vec contains the N unknowns U_1, ..., U_N.\n    \"\"\"\n    h = (b - a) / N\n\n    # Grid points\n    x_grid = np.linspace(a, b, N + 1)\n    \n    # Initialize the linear system\n    A = np.zeros((N, N))\n    F = np.zeros(N)\n\n    # The vector of unknowns U_vec corresponds to U_1, ..., U_N\n    # U_vec[k] approximates u(x_{k+1})\n\n    # Equation for U_1 (matrix row 0)\n    # This corresponds to the ODE at x_1\n    p_half = p(x_grid[0] + h/2.0)\n    p_3half = p(x_grid[1] + h/2.0)\n    A[0, 0] = p_half + p_3half + h**2 * q(x_grid[1])\n    if N > 1:\n        A[0, 1] = -p_3half\n    F[0] = h**2 * r(x_grid[1]) + p_half * alpha\n\n    # Equations for U_2, ..., U_{N-1} (matrix rows 1 to N-2)\n    # This corresponds to the ODE at x_j where j = 2, ..., N-1\n    for j in range(2, N):\n        k = j - 1 # 0-based index for matrix row\n        \n        p_minus_half = p(x_grid[j] - h/2.0)\n        p_plus_half = p(x_grid[j] + h/2.0)\n        \n        A[k, k - 1] = -p_minus_half\n        A[k, k] = p_minus_half + p_plus_half + h**2 * q(x_grid[j])\n        A[k, k + 1] = -p_plus_half\n        F[k] = h**2 * r(x_grid[j])\n\n    # Equation for U_N (matrix row N-1) from Neumann BC\n    if N >= 3:\n        # One-sided 2nd order formula for u'(x_N) uses U_N, U_{N-1}, U_{N-2}\n        # U_N-2 - 4*U_{N-1} + 3*U_N = 2*h*beta\n        A[N - 1, N - 3] = 1.0\n        A[N - 1, N - 2] = -4.0\n        A[N - 1, N - 1] = 3.0\n        F[N - 1] = 2.0 * h * beta\n    elif N == 2:\n        # For N=2, formula uses U_2, U_1, U_0\n        # -4*U_1 + 3*U_2 = 2*h*beta - U_0\n        A[1, 0] = -4.0\n        A[1, 1] = 3.0\n        F[1] = 2.0 * h * beta - alpha\n    elif N == 1:\n        # For N=1, formula is 3*U_1 - 4*U_0 + ... not usable.\n        # But this problem doesn't test N=1. The standard one-sided formula is:\n        # (U_1 - U_0)/h = beta. A[0,0]=1, F[0]=h*beta+alpha.\n        # A simpler handling for N=1: (3U_1 - 4U_0 + U_{-1})/2h = beta\n        # Let's derive a simpler O(h^2) for this case:\n        # u(a) = u(b-h) = u(b)-h*u'(b)+h^2/2 u''(b) + ...\n        # alpha = U_1 - h*beta + h^2/2*... -> U_1 = alpha+h*beta\n        # Use equation at U1: -p0.5*(U0)+ (p0.5+p1.5+h^2q1)U1-p1.5U2 = h^2 r1 --> needs U2\n        # The prompt only requires handling N>=2\n        pass\n\n    # Solve the linear system\n    U_vec = np.linalg.solve(A, F)\n\n    # Combine with Dirichlet BC to form full solution\n    U_solution = np.concatenate(([alpha], U_vec))\n\n    return U_solution, x_grid\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3228073"}, {"introduction": "The accuracy of the Finite Difference Method often hinges on the smoothness of the underlying solution. This exercise explores what happens when this condition is violated by introducing a discontinuous forcing function, a common feature in problems with abrupt changes or switches. By analyzing the error near the discontinuity, you will gain crucial insight into the local behavior and limitations of the method. [@problem_id:3228101]", "problem": "Consider the linear boundary value problem (BVP) defined on the interval $[0,1]$ with Dirichlet boundary conditions. Let $u:[0,1]\\to\\mathbb{R}$ satisfy\n$$\nu''(x) = f(x), \\quad x\\in(0,1), \\qquad u(0)=0,\\quad u(1)=0,\n$$\nwhere the forcing function $f(x)$ is a discontinuous step function at the point $x=x_c$ given by\n$$\nf(x) = \\begin{cases}\n1, & 0 \\le x < x_c,\\\\\n0, & x_c \\le x \\le 1.\n\\end{cases}\n$$\nUse a uniform mesh with $N$ subintervals, mesh width $h=1/N$, and nodes $x_i = i h$ for $i=0,1,\\dots,N$. Approximate $u(x)$ at the interior nodes $\\{x_i\\}_{i=1}^{N-1}$ by the standard central finite difference discretization of $u''(x)$, that is, construct the tridiagonal linear system obtained by replacing $u''(x_i)$ with\n$$\n\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = f(x_i), \\quad i=1,2,\\dots,N-1,\n$$\nsubject to the boundary conditions $u_0=0$ and $u_N=0$. Solve the resulting linear system to obtain the numerical approximation $\\{u_i\\}_{i=0}^N$.\n\nDefine the exact solution $u(x)$ analytically by solving the BVP and enforcing appropriate continuity conditions at $x=x_c$. Using this exact solution, compute the following error metrics based on the numerical approximation:\n- The infinity norm of the error over interior nodes,\n$$\nE_{\\infty} = \\max_{1\\le i \\le N-1} \\left|u_i - u(x_i)\\right|.\n$$\n- The errors at the grid points immediately to the left and right of the discontinuity. Let $i_L$ and $i_R$ be defined as follows:\n  1. If $x_c$ does not coincide with a grid node, set $i_L = \\lfloor x_c/h \\rfloor$ and $i_R = i_L + 1$, and then clamp to interior indices so that $1 \\le i_L \\le N-2$ and $2 \\le i_R \\le N-1$.\n  2. If $x_c$ coincides with a grid node $x_k$ (that is, $x_k = x_c$ for some integer $k$), set $i_L = \\max(1,k-1)$ and $i_R = \\min(N-1,k+1)$.\nThen compute\n$$\nE_L = \\left|u_{i_L} - u(x_{i_L})\\right|, \\qquad E_R = \\left|u_{i_R} - u(x_{i_R})\\right|.\n$$\n\nYour program must:\n- Assemble and solve the finite difference linear system for each test case specified below.\n- Construct the exact solution $u(x)$ and compute $E_{\\infty}$, $E_L$, and $E_R$ for each test case.\n- Produce a single line of output containing a comma-separated list of results, one per test case, where each result is the list $[E_{\\infty},E_L,E_R]$.\n\nTest suite (each item is a pair $(x_c,N)$):\n1. $(x_c,N) = (0.37,40)$, a general case where the discontinuity lies strictly between grid nodes.\n2. $(x_c,N) = (0.50,50)$, a case where the discontinuity aligns exactly with a grid node.\n3. $(x_c,N) = (0.05,41)$, a case where the discontinuity is near the left boundary and does not align with a grid node.\n4. $(x_c,N) = (1.00,60)$, a case where the discontinuity is at the right boundary.\n5. $(x_c,N) = (0.37,80)$, a refinement of the first case to observe error behavior under mesh refinement.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case contributing one sub-list $[E_{\\infty},E_L,E_R]$. For example, the output should look like\n$$\n[[e_{\\infty}^{(1)},e_L^{(1)},e_R^{(1)}],[e_{\\infty}^{(2)},e_L^{(2)},e_R^{(2)}],\\dots].\n$$", "solution": "The problem requires solving a one-dimensional linear boundary value problem (BVP) with a discontinuous forcing function using the finite difference method, and comparing the numerical solution to the exact analytical solution.\n\n### 1. Analytical Solution\nThe BVP is given by:\n$$\nu''(x) = f(x), \\quad x \\in (0,1)\n$$\nwith Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$. The forcing function $f(x)$ is a step function:\n$$\nf(x) = \\begin{cases}\n1, & 0 \\le x < x_c, \\\\\n0, & x_c \\le x \\le 1.\n\\end{cases}\n$$\nWe solve this by integrating $u''(x)$ piecewise on the two subintervals defined by the discontinuity at $x=x_c$.\n\nFor $0 \\le x < x_c$, we have $u''(x) = 1$. Integrating twice with respect to $x$ yields:\n$$\nu'(x) = x + A\n$$\n$$\nu(x) = \\frac{1}{2}x^2 + Ax + B\n$$\nFor $x_c \\le x \\le 1$, we have $u''(x) = 0$. Integrating twice yields:\n$$\nu'(x) = C\n$$\n$$\nu(x) = Cx + D\n$$\nwhere $A$, $B$, $C$, and $D$ are constants of integration. These are determined by the boundary conditions and by enforcing continuity of the solution $u(x)$ and its first derivative $u'(x)$ at $x=x_c$. A physical system corresponding to this equation (e.g., a string under a piecewise constant load) requires that the string itself does not break ($u$ is continuous) and does not have a kink ($u'$ is continuous).\n\n1.  **Boundary condition at $x=0$**: $u(0)=0$. Assuming $x_c>0$, we use the first form of the solution:\n    $u(0) = \\frac{1}{2}(0)^2 + A(0) + B = 0 \\implies B=0$.\n\n2.  **Boundary condition at $x=1$**: $u(1)=0$. We use the second form:\n    $u(1) = C(1) + D = 0 \\implies D=-C$.\n\n3.  **Continuity of $u(x)$ at $x=x_c$**: The values from both pieces must match, $u(x_c^-) = u(x_c^+)$.\n    $$\n    \\frac{1}{2}x_c^2 + Ax_c = Cx_c + D\n    $$\n    Substituting $B=0$ and $D=-C$, we get:\n    $$\n    \\frac{1}{2}x_c^2 + Ax_c = C(x_c - 1) \\quad (\\text{Eq. 1})\n    $$\n\n4.  **Continuity of $u'(x)$ at $x=x_c$**: The derivatives must also match, $u'(x_c^-) = u'(x_c^+)$.\n    $$\n    x_c + A = C \\quad (\\text{Eq. 2})\n    $$\n\nWe now solve the system of two linear equations (Eq. 1 and Eq. 2) for $A$ and $C$. From Eq. 2, we have $A = C-x_c$. Substituting this into Eq. 1:\n$$\n\\frac{1}{2}x_c^2 + (C-x_c)x_c = C(x_c - 1)\n$$\n$$\n\\frac{1}{2}x_c^2 + Cx_c - x_c^2 = Cx_c - C\n$$\n$$\n-\\frac{1}{2}x_c^2 = -C \\implies C = \\frac{1}{2}x_c^2\n$$\nNow, we find the other constants:\n$A = C - x_c = \\frac{1}{2}x_c^2 - x_c$\n$D = -C = -\\frac{1}{2}x_c^2$\n\nSubstituting these constants back into the piecewise expressions for $u(x)$, the exact analytical solution is:\n$$\nu(x) = \\begin{cases}\n\\frac{1}{2}x^2 + \\left(\\frac{1}{2}x_c^2 - x_c\\right)x, & 0 \\le x < x_c \\\\\n\\frac{1}{2}x_c^2 (x-1), & x_c \\le x \\le 1\n\\end{cases}\n$$\n\n### 2. Finite Difference Method\nWe discretize the domain $[0,1]$ using a uniform mesh with $N$ subintervals of width $h=1/N$. The grid nodes are $x_i = ih$ for $i=0,1,\\dots,N$. Let $u_i$ be the numerical approximation of $u(x_i)$.\n\nThe second derivative $u''(x_i)$ is approximated by a second-order central difference formula:\n$$\nu''(x_i) \\approx \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\nSubstituting this into the BVP at each interior node $x_i$ for $i=1, 2, \\dots, N-1$, we obtain a system of linear equations:\n$$\n\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = f(x_i)\n$$\nThe boundary conditions give $u_0=0$ and $u_N=0$. Rearranging the equations, we get:\n$$\nu_{i-1} - 2u_i + u_{i+1} = h^2 f(x_i), \\quad i=1, 2, \\dots, N-1\n$$\nThis forms a linear system $A \\mathbf{u} = \\mathbf{b}$ for the vector of unknowns $\\mathbf{u} = [u_1, u_2, \\dots, u_{N-1}]^T$. The matrix $A$ is an $(N-1) \\times (N-1)$ tridiagonal matrix:\n$$\nA = \\begin{pmatrix}\n-2 & 1 & & & \\\\\n1 & -2 & 1 & & \\\\\n& \\ddots & \\ddots & \\ddots & \\\\\n& & 1 & -2 & 1 \\\\\n& & & 1 & -2\n\\end{pmatrix}\n$$\nThe right-hand side vector $\\mathbf{b}$ has components $b_{i-1} = h^2 f(x_i)$ for $i=1, \\dots, N-1$. The value of $f(x_i)$ is $1$ if $x_i < x_c$ and $0$ if $x_i \\ge x_c$. This system is non-singular and can be solved efficiently, for instance, using a standard linear solver.\n\n### 3. Error Computation\nOnce the numerical solution $\\{u_i\\}_{i=0}^N$ is found, we compute the error by comparing it to the exact solution $\\{u(x_i)\\}_{i=0}^N$.\nThe required error metrics are:\n- The maximum absolute error over the interior nodes:\n  $$\n  E_{\\infty} = \\max_{1\\le i \\le N-1} \\left|u_i - u(x_i)\\right|\n  $$\n- The local errors at grid points bracketing the discontinuity. The indices $i_L$ (left) and $i_R$ (right) are determined as specified:\n  - If $x_c$ does not coincide with a grid node $x_k$, $i_L = \\lfloor x_c/h \\rfloor$ and $i_R = i_L + 1$. The problem statement implies these indices should be within the valid range for interior points near the discontinuity.\n  - If $x_c$ coincides with a grid node $x_k$, $i_L = \\max(1,k-1)$ and $i_R = \\min(N-1,k+1)$.\n  The errors are then computed as:\n  $$\n  E_L = \\left|u_{i_L} - u(x_{i_L})\\right|, \\quad E_R = \\left|u_{i_R} - u(x_{i_R})\\right|\n  $$\nThe Python program below implements this entire process for the given test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(xc, N):\n    \"\"\"\n    Solves the BVP for a given xc and N, and computes error metrics.\n    \"\"\"\n    # 1. Discretization\n    h = 1.0 / N\n    x_nodes = np.linspace(0, 1, N + 1)\n    dim = N - 1\n\n    if dim = 0:\n        return [0.0, 0.0, 0.0]\n\n    # 2. Assemble the finite difference matrix A\n    main_diag = np.full(dim, -2.0)\n    off_diag = np.full(dim - 1, 1.0)\n    A = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n    \n    # 3. Assemble the right-hand side vector b\n    f_int = np.zeros(dim)\n    for i in range(dim):\n        # x_nodes[i + 1] corresponds to the interior node x_{i+1}\n        if x_nodes[i + 1]  xc:\n            f_int[i] = 1.0\n    \n    b = (h**2) * f_int\n    \n    # 4. Solve the linear system for interior nodes\n    u_int = np.linalg.solve(A, b)\n    \n    # 5. Construct full numerical solution vector (including boundaries)\n    u_num = np.concatenate(([0.0], u_int, [0.0]))\n\n    # 6. Compute the exact solution at grid points\n    def exact_u_func(x, xc_val):\n        \"\"\"Computes the exact analytical solution u(x) for a given xc.\"\"\"\n        A_const = 0.5 * xc_val**2 - xc_val\n        C_const = 0.5 * xc_val**2\n        \n        if x  xc_val:\n            return 0.5 * x**2 + A_const * x\n        else:\n            return C_const * (x - 1)\n\n    u_exact_vals = np.array([exact_u_func(xi, xc) for xi in x_nodes])\n\n    # 7. Compute error vector and E_infinity\n    errors = np.abs(u_num - u_exact_vals)\n    E_inf = np.max(errors[1:N])\n    \n    # 8. Determine indices i_L and i_R for local errors\n    is_on_grid = np.isclose(xc / h, np.round(xc / h))\n    \n    if is_on_grid:\n        k = int(np.round(xc / h))\n        i_L = max(1, k - 1)\n        i_R = min(N - 1, k + 1)\n    else:\n        i_L_raw = int(np.floor(xc / h))\n        i_R_raw = i_L_raw + 1\n        \n        # The problem statement's clamping instruction is:\n        # \"...clamp to interior indices so that 1=iL=N-2 and 2=iR=N-1.\"\n        # The following implementation satisfies this constraint and keeps i_R = i_L + 1.\n        if i_L_raw  1:\n            i_L = 1\n            i_R = 2\n        elif i_L_raw >= N - 1:\n            i_L = N - 2\n            i_R = N - 1\n        else:\n            i_L = i_L_raw\n            i_R = i_R_raw\n\n    E_L = errors[i_L]\n    E_R = errors[i_R]\n    \n    return [E_inf, E_L, E_R]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.37, 40),\n        (0.50, 50),\n        (0.05, 41),\n        (1.00, 60),\n        (0.37, 80),\n    ]\n\n    results = []\n    for xc, N in test_cases:\n        result = solve_case(xc, N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{res[0]},{res[1]},{res[2]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3228101"}, {"introduction": "A numerical method can only be as good as the problem it aims to solve. This practice investigates the numerical consequences of discretizing an ill-posed, or resonant, boundary value problem, which lacks a unique solution. You will discover how the properties of the continuous operator manifest in the discrete system, leading to an ill-conditioned matrix and demonstrating the deep connection between analytical theory and numerical stability. [@problem_id:3228013]", "problem": "Consider the linear boundary value problem on the unit interval with homogeneous Dirichlet boundary conditions,\n$$\n-\\,u''(x)\\;-\\;\\pi^2\\,u(x)\\;=\\;f(x),\\quad x\\in(0,1),\\qquad u(0)=0,\\;u(1)=0.\n$$\nFrom first principles of the Finite Difference Method (FDM), use the second-order central difference approximation for the second derivative on a uniform grid with $N$ interior points and spacing $h=1/(N+1)$ to derive a discrete linear system in the form\n$$\n\\mathbf{A}\\,\\mathbf{u}\\;=\\;\\mathbf{b},\n$$\nwhere $\\mathbf{u}\\in\\mathbb{R}^N$ represents the discrete unknowns $u_i\\approx u(x_i)$ at interior nodes $x_i=i\\,h$, and $\\mathbf{b}\\in\\mathbb{R}^N$ contains the samples $f(x_i)$. Clearly and explicitly identify the entries of the matrix $\\mathbf{A}$ that arise from the central difference approximation and the Dirichlet boundary conditions.\n\nStarting from well-tested facts about Sturm–Liouville problems and the Dirichlet Laplacian on $(0,1)$, explain why the continuous operator\n$$\n\\mathcal{L}u\\;=\\;-\\,u''(x)\\;-\\;\\pi^2\\,u(x)\n$$\nwith the given boundary conditions has a nontrivial nullspace. Using the orthogonality of eigenfunctions, state the compatibility condition on $f(x)$ required for the continuous problem to admit solutions. Then, analyze the discrete FDM matrix $\\mathbf{A}$ by expressing it as a shifted discrete Dirichlet Laplacian. Using fundamental properties of symmetric tridiagonal Toeplitz matrices with Dirichlet boundary conditions, deduce a closed-form expression for the eigenvalues of $\\mathbf{A}$ as functions of $N$. Use this to determine the smallest singular value and the condition number in the spectral norm, and argue what happens as $N$ increases. Your analysis should make clear whether $\\mathbf{A}$ is exactly singular for finite $N$, and why it may nevertheless be ill-conditioned.\n\nImplementation task. Write a complete, runnable program that:\n- Constructs the FDM matrix $\\mathbf{A}$ and right-hand side vector $\\mathbf{b}$ for each test case.\n- Solves $\\mathbf{A}\\mathbf{u}=\\mathbf{b}$ for the discrete solution $\\mathbf{u}$.\n- Computes the following diagnostics for each test case:\n  1. An estimate of the spectral condition number $\\kappa_2(\\mathbf{A})$ using the exact eigenvalues of $\\mathbf{A}$ derived from analysis.\n  2. The minimum absolute eigenvalue of $\\mathbf{A}$.\n  3. The relative residual $\\|\\mathbf{A}\\mathbf{u}-\\mathbf{b}\\|_2 / \\|\\mathbf{b}\\|_2$, defined to be $0$ when $\\mathbf{b}=\\mathbf{0}$.\n  4. The discrete solution norm $\\|\\mathbf{u}\\|_2$.\nAll trigonometric functions must be evaluated with angles measured in radians.\n\nTest suite. Your program must evaluate the following five test cases, each specified by the pair $(N,f)$ with $N$ interior points and right-hand side $f(x)$:\n- Case 1: $N=50$, $f(x)=\\sin(\\pi x)$.\n- Case 2: $N=50$, $f(x)=\\sin(2\\pi x)$.\n- Case 3: $N=200$, $f(x)=\\sin(\\pi x)$.\n- Case 4: $N=200$, $f(x)=\\sin(\\pi x)+10^{-3}\\sin(2\\pi x)$.\n- Case 5: $N=100$, $f(x)\\equiv 0$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a four-element list containing $[\\kappa_2(\\mathbf{A}),\\,\\min_k|\\lambda_k(\\mathbf{A})|,\\,\\|\\mathbf{A}\\mathbf{u}-\\mathbf{b}\\|_2/\\|\\mathbf{b}\\|_2,\\,\\|\\mathbf{u}\\|_2]$ in that order. For example,\n$$\n[\\,[\\text{case1\\_cond},\\text{case1\\_minabs},\\text{case1\\_relres},\\text{case1\\_unorm}],\\ldots,[\\text{case5\\_cond},\\text{case5\\_minabs},\\text{case5\\_relres},\\text{case5\\_unorm}]\\,].\n$$", "solution": "The user has provided a problem concerning the numerical solution of a linear boundary value problem (BVP) using the Finite Difference Method (FDM). I will first validate the problem statement according to the specified criteria.\n\n### Step 1: Extract Givens\n\n- **Governing Equation**: $-\\,u''(x)\\;-\\;\\pi^2\\,u(x)\\;=\\;f(x)$, for $x \\in (0,1)$.\n- **Boundary Conditions**: Homogeneous Dirichlet, $u(0)=0$ and $u(1)=0$.\n- **Discretization Method**: Second-order central difference approximation for the second derivative.\n- **Grid**: Uniform grid with $N$ interior points, $x_i = i\\,h$ for $i=1, \\dots, N$.\n- **Grid Spacing**: $h=1/(N+1)$.\n- **Discrete System**: $\\mathbf{A}\\,\\mathbf{u}\\;=\\;\\mathbf{b}$, where $\\mathbf{u} \\in \\mathbb{R}^N$ with entries $u_i \\approx u(x_i)$, and $\\mathbf{b} \\in \\mathbb{R}^N$ with entries $b_i = f(x_i)$.\n- **Continuous Operator**: $\\mathcal{L}u\\;=\\;-\\,u''(x)\\;-\\;\\pi^2\\,u(x)$.\n- **Analytical Tasks**:\n    1.  Derive the matrix $\\mathbf{A}$.\n    2.  Analyze the nullspace of the continuous operator $\\mathcal{L}$.\n    3.  State the compatibility condition on $f(x)$ for the continuous problem.\n    4.  Analyze the discrete matrix $\\mathbf{A}$, its eigenvalues, singularity, and condition number as a function of $N$.\n- **Implementation Tasks**:\n    1.  Construct $\\mathbf{A}$ and $\\mathbf{b}$.\n    2.  Solve $\\mathbf{A}\\,\\mathbf{u}\\;=\\;\\mathbf{b}$.\n    3.  Compute diagnostics: $\\kappa_2(\\mathbf{A})$, $\\min_k|\\lambda_k(\\mathbf{A})|$, relative residual $\\|\\mathbf{A}\\mathbf{u}-\\mathbf{b}\\|_2 / \\|\\mathbf{b}\\|_2$, and solution norm $\\|\\mathbf{u}\\|_2$.\n- **Test Cases**:\n    - Case 1: $N=50$, $f(x)=\\sin(\\pi x)$.\n    - Case 2: $N=50$, $f(x)=\\sin(2\\pi x)$.\n    - Case 3: $N=200$, $f(x)=\\sin(\\pi x)$.\n    - Case 4: $N=200$, $f(x)=\\sin(\\pi x)+10^{-3}\\sin(2\\pi x)$.\n    - Case 5: $N=100$, $f(x)\\equiv 0$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is evaluated against the validation criteria:\n\n- **Scientifically Grounded**: The problem is rooted in the classical theory of Sturm-Liouville problems and numerical analysis, specifically the finite difference method for solving differential equations. The continuous problem is a resonant case, where the operator has a non-trivial nullspace, a standard topic in the study of BVPs. The analysis of the corresponding discrete system's ill-conditioning is a fundamental concept in scientific computing. The problem is a well-formulated and standard exercise in this field.\n- **Well-Posed**: The problem statement is complete, providing the differential equation, boundary conditions, discretization scheme, and all necessary parameters. The tasks are clearly defined, leading to a unique set of analytical derivations and numerical results. The continuous problem is intentionally chosen to be on the boundary of well-posedness (it is solvable only if a compatibility condition is met), and the core of the problem is to analyze how this property is reflected in the discretized system. This is a deliberate and meaningful structure, not a flaw.\n- **Objective**: The problem is stated using precise mathematical language and notation, free from any subjective or ambiguous terms.\n\nThe problem does not exhibit any of the invalidity flaws. It is scientifically sound, formalizable, complete, feasible, and properly structured to investigate an important numerical phenomenon.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. I will proceed to provide a complete solution.\n\n### Derivation and Analysis\n\nWe begin by discretizing the given boundary value problem.\nThe differential equation is evaluated at the interior grid points $x_i = i h$ for $i=1, \\dots, N$, where $h = 1/(N+1)$:\n$$\n-u''(x_i) - \\pi^2 u(x_i) = f(x_i)\n$$\nThe second derivative $u''(x_i)$ is approximated using a second-order central difference formula:\n$$\nu''(x_i) \\approx \\frac{u(x_i - h) - 2u(x_i) + u(x_i + h)}{h^2} = \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2}\n$$\nReplacing the continuous function $u(x_i)$ with its discrete approximation $u_i$, we obtain the system of linear equations:\n$$\n-\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} - \\pi^2 u_i = f_i\n$$\nwhere $f_i = f(x_i)$. Rearranging the terms yields:\n$$\n\\frac{1}{h^2} (-u_{i-1} + 2u_i - u_{i+1}) - \\pi^2 u_i = f_i\n$$\nThis equation holds for $i=1, \\dots, N$. The boundary conditions $u(0)=0$ and $u(1)=0$ imply $u_0=0$ and $u_{N+1}=0$.\nFor $i=1$: $\\frac{1}{h^2} (2u_1 - u_2) - \\pi^2 u_1 = f_1$.\nFor $i=N$: $\\frac{1}{h^2} (-u_{N-1} + 2u_N) - \\pi^2 u_N = f_N$.\n\nThese $N$ linear equations can be written in the matrix form $\\mathbf{A}\\mathbf{u} = \\mathbf{b}$. The matrix $\\mathbf{A}$ is an $N \\times N$ matrix, $\\mathbf{u} = [u_1, u_2, \\dots, u_N]^T$, and $\\mathbf{b} = [f_1, f_2, \\dots, f_N]^T$.\nThe matrix $\\mathbf{A}$ can be expressed as the sum of two matrices: one from the discretized second derivative and one from the $-\\pi^2 u(x)$ term.\nLet $\\mathbf{L}_N$ be the matrix representing the finite difference approximation of the negative second derivative operator, $-d^2/dx^2$. Its entries are derived from the term $\\frac{1}{h^2}(-u_{i-1} + 2u_i - u_{i+1})$.\n$$\n\\mathbf{L}_N = \\frac{1}{h^2}\n\\begin{pmatrix}\n2  -1  0  \\cdots  0 \\\\\n-1  2  -1  \\cdots  0 \\\\\n0  -1  2  \\ddots  \\vdots \\\\\n\\vdots  \\vdots  \\ddots  \\ddots  -1 \\\\\n0  0  \\cdots  -1  2\n\\end{pmatrix}\n$$\nThe term $-\\pi^2 u_i$ contributes $-\\pi^2 \\mathbf{I}$ to the system matrix, where $\\mathbf{I}$ is the $N \\times N$ identity matrix.\nThus, the system matrix $\\mathbf{A}$ is:\n$$\n\\mathbf{A} = \\mathbf{L}_N - \\pi^2 \\mathbf{I}\n$$\nThe entries of $\\mathbf{A}$ are explicitly given by:\n$$\nA_{ij} = \\begin{cases} \\frac{2}{h^2} - \\pi^2  \\text{if } i=j \\\\ -\\frac{1}{h^2}  \\text{if } |i-j|=1 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n\nNext, we analyze the continuous operator $\\mathcal{L}u = -u'' - \\pi^2 u$ with homogeneous Dirichlet boundary conditions. This is a Sturm-Liouville operator. Its nullspace consists of non-trivial solutions to $\\mathcal{L}u=0$, which is the homogeneous equation $-u'' - \\pi^2 u = 0$, or $u'' + \\pi^2 u = 0$. The general solution is $u(x) = C_1 \\cos(\\pi x) + C_2 \\sin(\\pi x)$.\nApplying the boundary conditions:\n1. $u(0) = C_1 \\cos(0) + C_2 \\sin(0) = C_1 = 0$. The solution must be of the form $u(x) = C_2 \\sin(\\pi x)$.\n2. $u(1) = C_2 \\sin(\\pi) = C_2 \\cdot 0 = 0$. This condition is satisfied for any value of $C_2$.\nTherefore, any function $u(x) = C \\sin(\\pi x)$ for any constant $C \\in \\mathbb{R}$ is a solution. The nullspace is non-trivial and is spanned by the eigenfunction $\\phi_1(x) = \\sin(\\pi x)$. This is because $\\pi^2$ is the first eigenvalue of the negative Laplacian operator $-d^2/dx^2$ on $(0,1)$ with these boundary conditions.\nFor the inhomogeneous problem $\\mathcal{L}u = f$ to have a solution, the Fredholm Alternative theorem requires the right-hand side $f(x)$ to be orthogonal to the nullspace of the adjoint operator $\\mathcal{L}^*$. Since $\\mathcal{L}$ is self-adjoint, the compatibility condition is that $f(x)$ must be orthogonal to the nullspace of $\\mathcal{L}$. This means:\n$$\n\\langle f, \\phi_1 \\rangle = \\int_0^1 f(x) \\sin(\\pi x) \\, dx = 0\n$$\n\nWe now analyze the discrete matrix $\\mathbf{A} = \\mathbf{L}_N - \\pi^2 \\mathbf{I}$. The matrix $\\mathbf{L}_N$ is a symmetric tridiagonal Toeplitz matrix. Its eigenvalues and eigenvectors are well-known. The eigenvalues of $\\mathbf{L}_N$, which are approximations of the eigenvalues $k^2 \\pi^2$ of the continuous operator $-d^2/dx^2$, are given by:\n$$\n\\mu_k = \\frac{2}{h^2} (1 - \\cos(k \\pi h)) = \\frac{4}{h^2} \\sin^2\\left(\\frac{k \\pi h}{2}\\right) \\quad \\text{for } k = 1, \\dots, N\n$$\nThe eigenvalues of $\\mathbf{A}$ are obtained by shifting the eigenvalues of $\\mathbf{L}_N$:\n$$\n\\lambda_k(\\mathbf{A}) = \\mu_k - \\pi^2 = \\frac{4}{h^2} \\sin^2\\left(\\frac{k \\pi h}{2}\\right) - \\pi^2 = 4(N+1)^2 \\sin^2\\left(\\frac{k \\pi}{2(N+1)}\\right) - \\pi^2\n$$\nThe matrix $\\mathbf{A}$ is singular if and only if $\\lambda_k(\\mathbf{A}) = 0$ for some $k$. This would require $2(N+1) \\sin\\left(\\frac{k \\pi}{2(N+1)}\\right) = \\pi$. For $x \\in (0, \\pi/2)$, we have the inequality $\\sin(x)  x$. Letting $x = \\frac{k\\pi}{2(N+1)}$, we have $2(N+1)\\sin\\left(\\frac{k\\pi}{2(N+1)}\\right)  2(N+1)\\frac{k\\pi}{2(N+1)} = k\\pi$. For this to equal $\\pi$, we would need $k=1$ and for the inequality to be an equality, which is not possible for $x0$. Thus, $\\lambda_k(\\mathbf{A}) \\ne 0$ for any $k$ and finite $N$. The matrix $\\mathbf{A}$ is never exactly singular.\n\nHowever, for $k=1$, the eigenvalue $\\lambda_1$ is very close to zero. Using the Taylor expansion $\\sin(x) = x - x^3/6 + O(x^5)$ for small $x = \\pi h/2$:\n$$\n\\lambda_1(\\mathbf{A}) = \\frac{4}{h^2} \\left( \\frac{\\pi h}{2} - \\frac{1}{6}\\left(\\frac{\\pi h}{2}\\right)^3 + O(h^5) \\right)^2 - \\pi^2 = \\pi^2 \\left(1 - \\frac{\\pi^2 h^2}{12} + O(h^4) \\right) - \\pi^2 = -\\frac{\\pi^4 h^2}{12} + O(h^4)\n$$\nThis eigenvalue $\\lambda_1$ approaches $0$ as $h \\to 0$ (i.e., $N \\to \\infty$). This near-singularity makes the matrix $\\mathbf{A}$ ill-conditioned. Since $\\mathbf{A}$ is symmetric, its singular values are the absolute values of its eigenvalues, $\\sigma_k = |\\lambda_k|$. The smallest singular value is $\\sigma_{\\min} = |\\lambda_1| = |\\mu_1 - \\pi^2| \\approx \\frac{\\pi^4 h^2}{12}$.\n\nThe spectral condition number is $\\kappa_2(\\mathbf{A}) = \\sigma_{\\max}/\\sigma_{\\min} = \\max_k|\\lambda_k|/\\min_k|\\lambda_k|$. The eigenvalues $\\lambda_k$ form an increasing sequence. $\\lambda_1$ is small and negative, while $\\lambda_2, \\dots, \\lambda_N$ are positive. The largest eigenvalue in magnitude is $\\lambda_N$:\n$$\n\\lambda_N = \\frac{4}{h^2}\\sin^2\\left(\\frac{N \\pi h}{2}\\right) - \\pi^2 = \\frac{4}{h^2}\\sin^2\\left(\\frac{N \\pi}{2(N+1)}\\right) - \\pi^2\n$$\nAs $N \\to \\infty$, $h \\to 0$ and $\\frac{N}{N+1} \\to 1$, so $\\lambda_N \\to \\frac{4}{h^2} - \\pi^2 \\approx 4(N+1)^2$.\nThe condition number therefore behaves as:\n$$\n\\kappa_2(\\mathbf{A}) = \\frac{|\\lambda_N|}{|\\lambda_1|} \\approx \\frac{4/h^2}{\\pi^4 h^2/12} = \\frac{48}{\\pi^4 h^4} = O((N+1)^4)\n$$\nThe condition number grows as $N^4$, indicating severe ill-conditioning for large $N$. This reflects the fact that the discrete problem is approximating a continuous problem that is not unconditionally solvable.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the FDM discretization of a linear BVP for several test cases\n    and computes specified diagnostics for each case.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (N, f(x)), where N is the number of interior points\n    # and f(x) is the right-hand side function.\n    test_cases = [\n        (50, lambda x: np.sin(np.pi * x)),\n        (50, lambda x: np.sin(2 * np.pi * x)),\n        (200, lambda x: np.sin(np.pi * x)),\n        (200, lambda x: np.sin(np.pi * x) + 1e-3 * np.sin(2 * np.pi * x)),\n        (100, lambda x: np.zeros_like(x))\n    ]\n\n    results = []\n    for N, f_func in test_cases:\n        # 1. Setup grid and parameters\n        h = 1.0 / (N + 1)\n        # Grid points x_i = i*h for i=1,...,N\n        x = np.arange(1, N + 1) * h\n\n        # 2. Construct the FDM matrix A\n        # A = (1/h^2) * tridiag(-1, 2, -1) - pi^2 * I\n        diag_val = 2.0 / h**2 - np.pi**2\n        off_diag_val = -1.0 / h**2\n        \n        A = diag_val * np.eye(N) + off_diag_val * np.diag(np.ones(N - 1), k=1) + off_diag_val * np.diag(np.ones(N - 1), k=-1)\n\n        # 3. Construct the right-hand side vector b\n        b = f_func(x)\n\n        # 4. Solve the linear system Au = b\n        # For the homogeneous case (b=0), the solution is the zero vector.\n        if np.all(b == 0):\n            u = np.zeros(N)\n        else:\n            u = np.linalg.solve(A, b)\n\n        # 5. Compute diagnostics\n\n        # a) Spectral condition number kappa_2(A) using exact eigenvalues\n        # lambda_k = 4*(N+1)^2 * sin^2(k*pi/(2*(N+1))) - pi^2\n        # Smallest magnitude eigenvalue is |lambda_1|\n        lambda_1 = 4 * (N + 1)**2 * np.sin(np.pi / (2 * (N + 1)))**2 - np.pi**2\n        min_abs_eig = np.abs(lambda_1)\n        \n        # Largest magnitude eigenvalue is lambda_N\n        lambda_N = 4 * (N + 1)**2 * np.sin(N * np.pi / (2 * (N + 1)))**2 - np.pi**2\n        \n        # kappa_2(A) = |lambda_N| / |lambda_1|\n        cond_A = lambda_N / min_abs_eig\n\n        # b) Minimum absolute eigenvalue (already computed)\n        \n        # c) Relative residual ||Au - b||_2 / ||b||_2\n        norm_b = np.linalg.norm(b)\n        if norm_b == 0:\n            rel_res = 0.0\n        else:\n            residual = A @ u - b\n            rel_res = np.linalg.norm(residual) / norm_b\n\n        # d) Discrete solution norm ||u||_2\n        u_norm = np.linalg.norm(u)\n\n        # Store results for this case\n        results.append([cond_A, min_abs_eig, rel_res, u_norm])\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list includes spaces, which is acceptable.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3228013"}]}