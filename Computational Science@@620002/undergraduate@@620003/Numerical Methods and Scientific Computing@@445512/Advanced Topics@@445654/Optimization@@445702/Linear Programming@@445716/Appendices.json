{"hands_on_practices": [{"introduction": "Linear programming algorithms like the simplex method operate by moving between the vertices of a feasible region. This exercise provides fundamental practice in algebraically identifying these vertices, known as basic feasible solutions (BFS), which form the discrete set of candidates for the optimal solution. Mastering this conversion from geometric intuition to algebraic computation is the first step toward understanding how linear programs are solved. [@problem_id:2180575]", "problem": "Consider a linear programming problem involving two decision variables, $x_1$ and $x_2$. The feasible region for the problem is defined by the following system of constraints:\n$$\n\\begin{align*}\n3x_1 + 2x_2 &\\le 12 \\\\\nx_1 + 4x_2 &\\le 10 \\\\\nx_1 &\\ge 0 \\\\\nx_2 &\\ge 0\n\\end{align*}\n$$\nA basic solution to this system is found by converting it to standard form and setting a specific number of variables to zero. If a basic solution also satisfies all non-negativity constraints, it is called a basic feasible solution.\n\nYour task is to algebraically determine all distinct basic feasible solutions for this system. Then, calculate the sum of the $x_1$-coordinates from all of these basic feasible solutions. Express your final answer as an exact fraction in simplest form.", "solution": "Introduce slack variables $s_{1}$ and $s_{2}$ to convert the inequalities to equalities, obtaining the standard form\n$$\n\\begin{aligned}\n3x_{1}+2x_{2}+s_{1}&=12,\\\\\nx_{1}+4x_{2}+s_{2}&=10,\n\\end{aligned}\n$$\nwith $x_{1},x_{2},s_{1},s_{2}\\geq 0$. There are $2$ equations, so a basic solution is obtained by choosing any $2$ variables as basic and setting the other $2$ to zero, then solving. A basic feasible solution (BFS) additionally requires all variables to be nonnegative.\n\n1. Basis $\\{s_{1},s_{2}\\}$: Set $x_{1}=0$, $x_{2}=0$. Then $s_{1}=12$, $s_{2}=10$. This is feasible, giving $(x_{1},x_{2})=(0,0)$.\n\n2. Basis $\\{x_{1},s_{1}\\}$: Set $x_{2}=0$, $s_{2}=0$. From $x_{1}+4x_{2}+s_{2}=10$ we get $x_{1}=10$. Then $3x_{1}+2x_{2}+s_{1}=12$ gives $s_{1}=12-3\\cdot 10=-18<0$. Infeasible; discard.\n\n3. Basis $\\{x_{2},s_{1}\\}$: Set $x_{1}=0$, $s_{2}=0$. From $x_{1}+4x_{2}+s_{2}=10$ we get $4x_{2}=10$, so $x_{2}=\\frac{5}{2}$. Then $3x_{1}+2x_{2}+s_{1}=12$ gives $s_{1}=12-2\\cdot\\frac{5}{2}=12-5=7\\geq 0$. Feasible, giving $(x_{1},x_{2})=(0,\\frac{5}{2})$.\n\n4. Basis $\\{x_{1},s_{2}\\}$: Set $x_{2}=0$, $s_{1}=0$. From $3x_{1}+2x_{2}+s_{1}=12$ we get $3x_{1}=12$, so $x_{1}=4$. Then $x_{1}+4x_{2}+s_{2}=10$ gives $s_{2}=10-4=6\\geq 0$. Feasible, giving $(x_{1},x_{2})=(4,0)$.\n\n5. Basis $\\{x_{2},s_{2}\\}$: Set $x_{1}=0$, $s_{1}=0$. From $3x_{1}+2x_{2}+s_{1}=12$ we get $2x_{2}=12$, so $x_{2}=6$. Then $x_{1}+4x_{2}+s_{2}=10$ gives $s_{2}=10-24=-14<0$. Infeasible; discard.\n\n6. Basis $\\{x_{1},x_{2}\\}$: Set $s_{1}=0$, $s_{2}=0$. Solve\n$$\n\\begin{aligned}\n3x_{1}+2x_{2}&=12,\\\\\nx_{1}+4x_{2}&=10.\n\\end{aligned}\n$$\nMultiply the second equation by $3$ to get $3x_{1}+12x_{2}=30$, subtract the first to obtain $10x_{2}=18$, hence $x_{2}=\\frac{9}{5}$. Substitute into $x_{1}+4x_{2}=10$ to get $x_{1}=10-4\\cdot\\frac{9}{5}=\\frac{14}{5}$. Both are nonnegative, so $(x_{1},x_{2})=\\left(\\frac{14}{5},\\frac{9}{5}\\right)$ is feasible.\n\nThe distinct basic feasible solutions are therefore $(0,0)$, $\\left(0,\\frac{5}{2}\\right)$, $(4,0)$, and $\\left(\\frac{14}{5},\\frac{9}{5}\\right)$. The sum of the $x_{1}$-coordinates is\n$$\n0+0+4+\\frac{14}{5}=\\frac{20}{5}+\\frac{14}{5}=\\frac{34}{5}.\n$$", "answer": "$$\\boxed{\\frac{34}{5}}$$", "id": "2180575"}, {"introduction": "The simplex method iteratively improves a solution by pivoting from one basic feasible solution to an adjacent one with a better objective value. This exercise focuses on the core mechanic of a single pivot operation within a simplex tableau, including the rules for selecting entering and leaving variables. You will also confront a common and important special case known as degeneracy, which occurs when a tie in the minimum ratio test leads to a basic variable having a value of zero. [@problem_id:2166082]", "problem": "Consider the following Linear Programming Problem (LPP), where the goal is to find values for $x_1$ and $x_2$ that maximize the objective function $Z$. The variables $s_1, s_2, s_3$ are slack variables.\n\nMaximize $Z = 5x_1 + 3x_2$\nSubject to:\n$2x_1 + x_2 + s_1 = 4$\n$3x_1 + 5x_2 + s_2 = 6$\n$4x_1 + 2x_2 + s_3 = 10$\n$x_1, x_2, s_1, s_2, s_3 \\ge 0$\n\nThe initial simplex tableau corresponding to the basic feasible solution where $x_1=0$ and $x_2=0$ is given below:\n$$\n\\begin{array}{c|c|ccccc|c}\n\\text{Basis} & Z & x_1 & x_2 & s_1 & s_2 & s_3 & \\text{RHS} \\\\\n\\hline\nZ & 1 & -5 & -3 & 0 & 0 & 0 & 0 \\\\\ns_1 & 0 & 2 & 1 & 1 & 0 & 0 & 4 \\\\\ns_2 & 0 & 3 & 5 & 0 & 1 & 0 & 6 \\\\\ns_3 & 0 & 4 & 2 & 0 & 0 & 1 & 10 \\\\\n\\end{array}\n$$\nYou are to perform a single iteration of the simplex method. First, identify the entering variable by choosing the one with the most negative coefficient in the objective function row ($Z$-row). Then, identify the potential leaving variables using the minimum ratio test. In the event of a tie for the leaving variable, choose the one that appears first in the \"Basis\" column of the tableau (i.e., choose $s_1$ over $s_2$ if they are tied).\n\nAfter performing the pivot operation, which of the following statements is true about the new basic feasible solution?\n\nA. The objective value increases, and the resulting basic feasible solution is degenerate.\n\nB. The objective value increases, and the resulting basic feasible solution is non-degenerate.\n\nC. The objective value does not change, and the resulting basic feasible solution is degenerate.\n\nD. The objective value does not change, and the resulting basic feasible solution is non-degenerate.\n\nE. The simplex method terminates because the solution is found to be unbounded.", "solution": "We first identify the entering variable by the most negative reduced cost in the $Z$-row. The $Z$-row has coefficients $-5$ for $x_{1}$ and $-3$ for $x_{2}$. Therefore, the entering variable is $x_{1}$.\n\nNext, we apply the minimum ratio test on the $x_{1}$ column with positive coefficients:\n$$\n\\frac{4}{2} = 2 \\quad (s_{1}), \\qquad \\frac{6}{3} = 2 \\quad (s_{2}), \\qquad \\frac{10}{4} = \\frac{5}{2} \\quad (s_{3}).\n$$\nThe minimum ratio is $2$, with a tie between $s_{1}$ and $s_{2}$. By the given rule, we choose the one that appears first in the Basis column, so $s_{1}$ leaves. The pivot element is $2$ in the $s_{1}$ row and $x_{1}$ column.\n\nPerform the pivot by first normalizing the pivot row (divide the $s_{1}$ row by $2$):\n$$\n\\text{New }s_{1}\\text{ row: } x_{1} + \\frac{1}{2}x_{2} + \\frac{1}{2}s_{1} = 2.\n$$\nEliminate $x_{1}$ from the other rows.\n\nFor the $Z$-row, add $5$ times the new $s_{1}$ row:\n$$\nZ: \\quad Z + 5\\left(x_{1} + \\frac{1}{2}x_{2} + \\frac{1}{2}s_{1} = 2\\right) \\implies Z = 10 - \\frac{1}{2}x_{2} + \\frac{5}{2}s_{1}.\n$$\n\nFor the $s_{2}$ row, subtract $3$ times the new $s_{1}$ row:\n$$\ns_{2}: \\quad 3x_{1} + 5x_{2} + s_{2} = 6 \\;-\\; 3\\left(x_{1} + \\frac{1}{2}x_{2} + \\frac{1}{2}s_{1} = 2\\right)\n$$\nwhich yields\n$$\n0\\cdot x_{1} + \\frac{7}{2}x_{2} - \\frac{3}{2}s_{1} + s_{2} = 0.\n$$\n\nFor the $s_{3}$ row, subtract $4$ times the new $s_{1}$ row:\n$$\ns_{3}: \\quad 4x_{1} + 2x_{2} + s_{3} = 10 \\;-\\; 4\\left(x_{1} + \\frac{1}{2}x_{2} + \\frac{1}{2}s_{1} = 2\\right)\n$$\nwhich yields\n$$\n0\\cdot x_{1} + 0\\cdot x_{2} - 2s_{1} + s_{3} = 2.\n$$\n\nThe new basis is $\\{x_{1}, s_{2}, s_{3}\\}$, and setting nonbasic variables $x_{2}=0$ and $s_{1}=0$ gives the basic feasible solution:\n$$\nx_{1} = 2, \\quad s_{2} = 0, \\quad s_{3} = 2.\n$$\nThe objective value becomes\n$$\nZ = 10 - \\frac{1}{2}\\cdot 0 + \\frac{5}{2}\\cdot 0 = 10,\n$$\nwhich is an increase from the initial value $Z=0$.\n\nSince one of the basic variables, $s_{2}$, has value $0$, the new basic feasible solution is degenerate. Therefore, the correct statement is that the objective value increases and the resulting basic feasible solution is degenerate.", "answer": "$$\\boxed{A}$$", "id": "2166082"}, {"introduction": "While the simplex method is remarkably efficient in practice, certain pathological cases can expose its worst-case exponential complexity. This advanced exercise challenges you to implement the simplex algorithm to trace its path on a Klee-Minty cube, a specially constructed problem designed to make the algorithm visit a large number of vertices. By coding and observing this behavior, you will gain a deeper appreciation for the interplay between algorithm design and problem structure in scientific computing. [@problem_id:3248214]", "problem": "Consider a family of linear programs constructed to be the Klee-Minty cube in dimension $n$, parameterized by a base $a$ with $a > 1$. The Klee-Minty cube is a perturbation of the unit hypercube designed to cause the simplex method to visit an exponential number of vertices under specific pivot rules. The linear program is expressed in standard form as maximizing an objective subject to upper triangular inequality constraints and nonnegativity restrictions. The precise model is as follows.\n\nGiven integers $n \\geq 1$ and a real parameter $a > 1$, define the decision variables $x_1, x_2, \\dots, x_n$ and construct the constraint matrix $A \\in \\mathbb{R}^{n \\times n}$ and the right-hand side vector $b \\in \\mathbb{R}^n$ by\n$$\nA_{i,j} = \n\\begin{cases}\na^{\\,i-j}, & \\text{if } j < i, \\\\\n1, & \\text{if } j = i, \\\\\n0, & \\text{if } j > i,\n\\end{cases}\n\\quad \\text{for } i,j \\in \\{1,\\dots,n\\},\n\\qquad\nb_i = a^{\\,i}.\n$$\nDefine the objective coefficient vector $c \\in \\mathbb{R}^n$ with strictly decreasing weights\n$$\nc_j = a^{\\,n-j}, \\quad \\text{for } j \\in \\{1,\\dots,n\\}.\n$$\nThe linear program is\n$$\n\\max_{x \\in \\mathbb{R}^n} \\; c^\\top x\n\\quad \\text{subject to} \\quad\nA x \\le b, \\quad x \\ge 0.\n$$\nIntroduce slack variables $s \\in \\mathbb{R}^n$ to convert the inequalities to equalities as $A x + s = b$ with $s \\ge 0$. A basic feasible solution is obtained by taking $x = 0$ and $s = b$. The simplex method will pivot on a sequence of bases, each corresponding to a vertex of the feasible region. Under the entering-variable rule known as Dantzig’s rule (choose a nonbasic variable with the largest positive reduced cost), the Klee-Minty cube forces the simplex method through exponentially many iterations, specifically $2^n - 1$ pivots in dimension $n$.\n\nYour task is to implement the primal simplex method with Dantzig’s rule on this Klee-Minty family, starting from the slack basis, to numerically trace and count the number of pivot iterations until optimality. Use the tableau representation with the following specifications:\n- Construct the augmented tableau with columns for the $n$ decision variables $x$ and $n$ slack variables $s$, plus a right-hand side column. The initial basis is the $n$ slack variables.\n- Maintain the objective row as reduced costs for all variables and the current objective value $z$, and pivot using row operations to keep the tableau in canonical form.\n- At each iteration, choose the entering variable as the index $j \\in \\{1,\\dots,n\\}$ (among the decision-variable columns only) with the largest positive reduced cost; break ties by selecting the smallest index.\n- Choose the leaving variable using the minimum ratio test over rows with positive entries in the entering column; break ties by selecting the smallest row index.\n- Terminate when all decision-variable reduced costs are nonpositive.\n\nFrom a numerical methods and scientific computing perspective, your implementation must faithfully perform floating-point row operations and ratio tests, while using tolerances to avoid spurious pivots due to round-off (e.g., treat values with magnitude below $10^{-12}$ as zero).\n\nDesign a test suite to evaluate the iteration counts across multiple $(n,a)$ pairs that cover different aspects:\n- Happy path: moderate dimensions where the exponential behavior is visible.\n- Boundary condition: the smallest nontrivial dimension.\n- Edge variation: a smaller base $a$ verifying robustness of the construction.\n\nUse the following test suite:\n1. $(n,a) = (1,10)$\n2. $(n,a) = (2,10)$\n3. $(n,a) = (3,10)$\n4. $(n,a) = (4,10)$\n5. $(n,a) = (3,2)$\n\nFor each test case, your program must output the number of pivot iterations (as an integer) taken by the simplex method to reach optimality. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[result1,result2,result3]`). No physical units or angle units apply in this purely mathematical problem. All numeric outputs must be integers.", "solution": "The user has provided a specific formulation of a linear program, identified as a member of the Klee-Minty cube family, and has requested the implementation of the primal simplex method to determine the number of pivot iterations required to reach optimality. The validation and solution process will proceed as follows.\n\n### Step 1: Extract Givens\nThe linear program is defined as:\n- **Objective Function**: Maximize $z = c^\\top x$, where $x = (x_1, \\dots, x_n)^\\top \\in \\mathbb{R}^n$.\n- **Decision Variables**: $x_j \\ge 0$ for $j \\in \\{1, \\dots, n\\}$.\n- **Parameters**: An integer dimension $n \\ge 1$ and a real base $a > 1$.\n- **Objective Coefficients**: $c_j = a^{n-j}$ for $j \\in \\{1, \\dots, n\\}$.\n- **Constraints**: $A x \\le b$, where the matrix $A \\in \\mathbb{R}^{n \\times n}$ and vector $b \\in \\mathbb{R}^n$ are defined as:\n  $$\n  A_{i,j} = \n  \\begin{cases}\n  a^{i-j}, & \\text{if } j < i, \\\\\n  1, & \\text{if } j = i, \\\\\n  0, & \\text{if } j > i,\n  \\end{cases}\n  \\quad \\text{for } i,j \\in \\{1, \\dots, n\\}\n  $$\n  $$\n  b_i = a^i, \\quad \\text{for } i \\in \\{1, \\dots, n\\}\n  $$\n\nThe algorithm to be implemented is the primal simplex method using a tableau representation, with the following specific rules:\n- **Initial Basis**: The slack variables $s_1, \\dots, s_n$ from the standard form conversion $Ax + s = b, s \\ge 0$.\n- **Tableau**: An augmented tableau including columns for decision variables $x$, slack variables $s$, and the right-hand side (RHS). The objective row stores the reduced costs and the current objective value.\n- **Entering Variable Rule**: Dantzig's rule applied only to decision variables. Choose the variable $x_j$ corresponding to the largest positive reduced cost. Ties are broken by selecting the smallest index $j$.\n- **Leaving Variable Rule**: The minimum ratio test. For the entering column, consider all rows with a positive entry. The leaving variable corresponds to the row with the minimum ratio of the RHS value to the pivot column entry. Ties are broken by selecting the smallest row index.\n- **Termination**: The algorithm terminates when the reduced costs for all decision variables $x_1, \\dots, x_n$ are non-positive.\n- **Numerical Tolerance**: Values with a magnitude less than $10^{-12}$ are to be treated as zero.\n\nThe test suite to be evaluated is:\n1.  $(n,a) = (1,10)$\n2.  $(n,a) = (2,10)$\n3.  $(n,a) = (3,10)$\n4.  $(n,a) = (4,10)$\n5.  $(n,a) = (3,2)$\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is critically assessed against the validation criteria.\n- **Scientifically Grounded**: The problem is rooted in the established mathematical field of linear programming. The simplex method, Klee-Minty cubes, and Dantzig's pivot rule are standard, well-documented concepts in optimization theory. The problem is scientifically sound.\n- **Well-Posed**: The problem provides a complete and unambiguous definition of the linear program (objective, constraints) and the algorithm to be used (initialization, pivot rules, tie-breaking, termination). This ensures that for any given $(n, a)$, a unique sequence of pivots is defined, leading to a single, verifiable number of iterations.\n- **Objective**: The problem is formulated in precise mathematical language, free from subjectivity or ambiguity.\n\nThe preamble mentions that the Klee-Minty cube is known to require an exponential number of pivots ($2^n-1$). A manual trace or preliminary analysis of the given formulation reveals that it leads to exactly $n$ pivots. This discrepancy does not constitute a formal contradiction within the problem's task. The preamble provides context, whereas the task is a direct instruction to \"trace and count the number of pivot iterations\" for the *given* specific mathematical model. The task is not to verify the preamble's claim. Therefore, the problem is not contradictory but rather a well-defined computational exercise. The problem is valid.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be developed and implemented as specified.\n\n### Solution Design\n\nThe solution involves implementing the primal simplex method using a tableau. The indices used in the implementation will be $0$-based, so the problem's $1$-based definitions for $i,j \\in \\{1, \\dots, n\\}$ are mapped to `i_code`, `j_code` $\\in \\{0, \\dots, n-1\\}$.\n\n1.  **Tableau Initialization**:\n    A NumPy array of size $(n+1) \\times (2n+1)$ is used for the tableau.\n    - The first $n$ columns represent decision variables $x_0, \\dots, x_{n-1}$.\n    - The next $n$ columns represent slack variables $s_0, \\dots, s_{n-1}$.\n    - The last column is the Right-Hand Side (RHS).\n    - The first row (index $0$) is the objective row.\n    - The subsequent $n$ rows (indices $1, \\dots, n$) represent the constraints.\n\n    Initially, the decision variables $x$ are non-basic, and the slack variables $s$ are basic. With a basic feasible solution $x=0, s=b$, the initial basis matrix is the identity matrix $I$, and the cost vector for basic variables is $c_B = 0$. The reduced cost for a variable with coefficient column $p_j$ is $\\bar{c}_j = c_j - c_B^\\top B^{-1} p_j$.\n    - For a decision variable $x_j$, $p_j = A_j$ (column $j$ of $A$), so $\\bar{c}_j = c_j - 0 = c_j$.\n    - For a slack variable $s_j$, $p_{n+j}$ is the $(j+1)$-th standard basis vector $e_{j+1}$, so $\\bar{c}_{n+j} = 0 - 0 = 0$.\n    \n    The initial objective value is $z = c_B^\\top B^{-1} b = 0$.\n    The initial tableau is constructed as:\n    $$\n    \\begin{bmatrix}\n    c^\\top & 0^\\top & | & 0 \\\\\n    \\hline\n    A & I & | & b\n    \\end{bmatrix}\n    $$\n    where $c_j = a^{n-(j+1)}$, $b_i = a^{i+1}$, and $A_{ij}$ is defined as per the problem for $0$-based indices $i,j$.\n\n2.  **Simplex Iteration Loop**:\n    The algorithm proceeds iteratively until the termination condition is met.\n    - **Termination Check**: The algorithm scans the reduced costs of the decision variables, stored in `tableau[0, 0:n]`. If `max(tableau[0, 0:n]) = tol` (where `tol` is a small tolerance like $10^{-12}$), the algorithm terminates.\n    - **Entering Variable**: The index of the entering variable, `piv_col`, is found by `piv_col = argmax(tableau[0, 0:n])`. The `argmax` function inherently breaks ties by choosing the smallest index.\n    - **Leaving Variable**: The minimum ratio test is performed. For each row $i \\in \\{1, \\dots, n\\}$ where the entry in the pivot column, `tableau[i, piv_col]`, is greater than `tol`, the ratio `tableau[i, 2n] / tableau[i, piv_col]` is computed. The index of the leaving variable's row, `piv_row`, corresponds to the minimum of these ratios. Ties are again broken by selecting the smallest row index, which `argmin` provides.\n    - **Pivot Operation**: The tableau is updated to reflect the change of basis.\n        a. The pivot row is normalized by dividing all its elements by the pivot element, `tableau[piv_row, piv_col]`.\n        b. For every other row `k` (including the objective row), the new row is computed as `row_k_new = row_k_old - multiplier * row_piv_new`, where `multiplier` is the entry in row `k` at the pivot column, `tableau[k, piv_col]`.\n    - **Iteration Count**: A counter is incremented after each successful pivot.\n\n3.  **Final Result**: The loop continues until an optimal tableau is found, and the final value of the iteration counter is returned. This process is repeated for each test case.\nThe manual trace conducted during validation indicates that for the given formulation and pivot rules, the number of iterations is consistently equal to the dimension $n$, regardless of the base $a$. For $(n,a)=(1,10)$, iterations=1. For $(n,a)=(2,10)$, iterations=2. For $(n,a)=(3,10)$, iterations=3. For $(n,a)=(4,10)$, iterations=4. For $(n,a)=(3,2)$, iterations=3.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simplex method on the Klee-Minty test suite\n    and print the results.\n    \"\"\"\n\n    def run_simplex_on_km(n: int, a: float) - int:\n        \"\"\"\n        Implements the primal simplex method for the given Klee-Minty family.\n\n        Args:\n            n: The dimension of the problem.\n            a: The base parameter of the Klee-Minty construction.\n\n        Returns:\n            The number of pivot iterations to reach optimality.\n        \"\"\"\n        # --- Step 1: Construct the initial LP formulation ---\n        # Note: Using 0-based indexing for implementation (i, j from 0 to n-1)\n        \n        # Construct constraint matrix A\n        A = np.zeros((n, n), dtype=float)\n        for i in range(n):\n            for j in range(n):\n                if j  i:\n                    A[i, j] = a**(i - j)\n                elif j == i:\n                    A[i, j] = 1.0\n        \n        # Construct RHS vector b (b_i = a^i for i=1..n - b_i_code = a^(i_code+1))\n        b = np.array([a**(i + 1) for i in range(n)], dtype=float)\n        \n        # Construct objective coefficient vector c (c_j = a^(n-j) - c_j_code = a^(n-(j_code+1)))\n        c = np.array([a**(n - (j + 1)) for j in range(n)], dtype=float)\n\n        # --- Step 2: Initialize the simplex tableau ---\n        # Tableau dimensions: (n+1) rows, (2n+1) columns\n        # Rows: 1 objective row, n constraint rows\n        # Cols: n for x_vars, n for slack_vars, 1 for RHS\n        tableau = np.zeros((n + 1, 2 * n + 1), dtype=float)\n\n        # Objective row (row 0): stores the reduced costs. Initially, these are just c.\n        tableau[0, :n] = c\n        \n        # Constraint rows (rows 1 to n)\n        tableau[1:, :n] = A                   # A matrix part\n        tableau[1:, n:2*n] = np.identity(n)   # Slack variable part (identity matrix)\n        tableau[1:, 2*n] = b                  # RHS part\n        \n        iterations = 0\n        tol = 1e-12\n\n        # --- Step 3: Main simplex loop ---\n        while True:\n            # Termination check: Are all reduced costs for x_j non-positive?\n            reduced_costs_x = tableau[0, :n]\n            max_rc = np.max(reduced_costs_x)\n            \n            if max_rc = tol:\n                break\n\n            # Find entering variable (Dantzig's rule)\n            # Choose column with largest positive reduced cost among decision variables.\n            # np.argmax breaks ties by choosing the smallest index.\n            piv_col = np.argmax(reduced_costs_x)\n\n            # Find leaving variable (Minimum ratio test)\n            pivot_column_data = tableau[1:, piv_col]\n            rhs = tableau[1:, 2*n]\n            \n            # Calculate ratios only for rows with a positive entry in the pivot column\n            ratios = np.full_like(rhs, np.inf)\n            positive_entries_mask = pivot_column_data  tol\n            \n            if not np.any(positive_entries_mask):\n                # This indicates an unbounded problem, which should not occur here.\n                raise RuntimeError(f\"Unbounded LP detected for n={n}, a={a}.\")\n\n            ratios[positive_entries_mask] = rhs[positive_entries_mask] / pivot_column_data[positive_entries_mask]\n\n            # Choose row with the minimum ratio.\n            # np.argmin breaks ties by choosing the smallest index.\n            piv_row_idx = np.argmin(ratios)\n            piv_row = piv_row_idx + 1  # Convert 0-based index to tableau row number (1 to n)\n\n            # Perform pivot operation\n            pivot_element = tableau[piv_row, piv_col]\n            \n            # Normalize pivot row\n            tableau[piv_row, :] /= pivot_element\n            \n            # Update all other rows\n            for i in range(n + 1):\n                if i != piv_row:\n                    multiplier = tableau[i, piv_col]\n                    tableau[i, :] -= multiplier * tableau[piv_row, :]\n            \n            iterations += 1\n\n        return iterations\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 10.0),\n        (2, 10.0),\n        (3, 10.0),\n        (4, 10.0),\n        (3, 2.0),\n    ]\n\n    results = []\n    for n, a in test_cases:\n        # Run the simplex method for the current case and store the iteration count.\n        count = run_simplex_on_km(n, a)\n        results.append(count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3248214"}]}