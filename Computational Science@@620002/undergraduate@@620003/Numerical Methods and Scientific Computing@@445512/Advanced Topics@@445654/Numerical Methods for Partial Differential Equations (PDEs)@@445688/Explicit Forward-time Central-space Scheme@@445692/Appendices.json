{"hands_on_practices": [{"introduction": "Before diving into code, let's explore a fundamental consequence of the FTCS scheme's structure. The stability of the simulation is governed by the dimensionless parameter $r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$, which links the physical properties of the system ($\\alpha$) to the numerical grid choices ($\\Delta t, \\Delta x$). This exercise [@problem_id:2141772] challenges you to think about the practical implications of this relationship, specifically how refining your spatial grid to capture more detail forces a dramatic change in the time step, impacting the overall computational cost.", "problem": "A materials science student is developing a numerical simulation for heat transfer along a thin, one-dimensional carbon nanotube. The temperature evolution $u(x,t)$ is governed by the 1D heat equation, $\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}$, where $\\alpha$ is the thermal diffusivity of the material. The student chooses to use the explicit Forward-Time Central-Space (FTCS) finite difference method to approximate the solution.\n\nThe stability of this numerical scheme is determined by the dimensionless parameter $r$, defined as:\n$$r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$$\nwhere $\\Delta t$ is the time step and $\\Delta x$ is the spatial grid spacing.\n\nIn an initial simulation run, the student sets the spatial grid spacing to $\\Delta x_1 = 50.0$ nanometers and the time step to $\\Delta t_1 = 2.50$ picoseconds. For a second, more detailed simulation, the student needs to improve the spatial resolution by reducing the grid spacing to $\\Delta x_2 = 12.5$ nanometers. To ensure the numerical properties and error characteristics of the simulation remain consistent, the student must maintain the exact same value for the stability parameter $r$ in both simulations (i.e., $r_1 = r_2$).\n\nCalculate the new time step, $\\Delta t_2$, that must be used for the second simulation. Express your answer in picoseconds, rounded to three significant figures.", "solution": "The FTCS stability parameter is defined as $r = \\alpha \\Delta t / (\\Delta x)^{2}$. To keep $r$ unchanged between the two simulations, set $r_{1} = r_{2}$:\n$$\\frac{\\alpha \\Delta t_{1}}{(\\Delta x_{1})^{2}} = \\frac{\\alpha \\Delta t_{2}}{(\\Delta x_{2})^{2}}.$$\nCanceling $\\alpha$ and solving for $\\Delta t_{2}$ gives\n$$\\Delta t_{2} = \\Delta t_{1} \\left( \\frac{\\Delta x_{2}}{\\Delta x_{1}} \\right)^{2}.$$\nSubstituting the given values (with consistent units already specified: $\\Delta x_{1} = 50.0$ nanometers, $\\Delta x_{2} = 12.5$ nanometers, $\\Delta t_{1} = 2.50$ picoseconds):\n$$\\Delta t_{2} = 2.50 \\left( \\frac{12.5}{50.0} \\right)^{2} = 2.50 \\left( \\frac{1}{4} \\right)^{2} = 2.50 \\cdot \\frac{1}{16} = 0.15625.$$\nRounding to three significant figures yields $0.156$ in picoseconds.", "answer": "$$\\boxed{0.156}$$", "id": "2141772"}, {"introduction": "The best way to understand a numerical scheme is to implement it yourself. This practice [@problem_id:3204666] guides you through writing a program to solve the 1D heat equation using the FTCS method. You will not only translate the discrete equations into code but also perform a critical scientific task: experimental verification. By running your simulation with the stability parameter $r$ set below, at, and above the theoretical threshold of $0.5$, you can directly observe the boundary between a stable solution and numerical chaos, reinforcing the theory in a tangible way.", "problem": "Consider the one-dimensional heat equation $u_t = \\alpha u_{xx}$ on the spatial interval $x \\in [0,1]$ and time $t \\ge 0$, where $\\alpha > 0$ is a constant. Impose homogeneous Dirichlet boundary conditions $u(0,t) = 0$ and $u(1,t) = 0$ for all $t \\ge 0$, and the initial condition $u(x,0) = \\sin(\\pi x)$. The exact solution for this initial-boundary value problem is $u(x,t) = e^{-\\alpha \\pi^2 t} \\sin(\\pi x)$. Starting from the fundamental definitions of partial derivatives and second-order central differences, implement the explicit forward-time scheme combined with second-order central spatial differences that approximates $u_t$ by a forward difference and $u_{xx}$ by a second-order central difference on a uniform grid with spatial step $\\Delta x$ and temporal step $\\Delta t$. Use the nondimensional parameter $r = \\alpha \\Delta t / (\\Delta x)^2$ to parameterize the time step relative to the spatial resolution.\n\nYour program must:\n- Discretize the domain $[0,1]$ with $N_x$ grid points, so that $\\Delta x = 1/(N_x-1)$.\n- Evolve the explicit scheme to the final time $T$ using the chosen $\\Delta t$ determined by the specified $r$.\n- For each run, compute the maximum norm of the numerical solution over time, and declare the behavior \"observationally stable\" if the maximum norm over the entire simulation does not exceed $1.05$ times the maximum norm of the initial condition; declare \"observationally unstable\" otherwise.\n- Compare the observational stability with the theoretical classification criterion based on $r$ and return a boolean indicating whether the observation matches the theory for that run.\n- Compute the numerical error at the final simulation time using the exact solution $u(x,t) = e^{-\\alpha \\pi^2 t} \\sin(\\pi x)$ and the infinity norm of the grid error.\n\nTest suite and parameters:\n- Verification of stability across three regimes with $\\alpha = 1.0$, $N_x = 51$, and final time $T = 0.1$:\n  - Case $1$: $r = 0.45$.\n  - Case $2$: $r = 0.5$.\n  - Case $3$: $r = 0.55$.\n  For each case, output a boolean stating whether the observed stability matches the theoretical stability classification.\n- Accuracy versus efficiency assessment under stable operation:\n  - Use $\\alpha = 1.0$, $T = 0.1$, $r = 0.45$.\n  - Run two simulations: a coarse grid with $N_x = 51$ and a fine grid with $N_x = 101$.\n  - Compute the ratio of the infinity-norm errors $E_{\\text{coarse}} / E_{\\text{fine}}$ as a float. Additionally, the program should internally count the operation proxy $W = N_t \\cdot (N_x - 2)$ for each run, where $N_t$ is the number of time steps, to discuss efficiency conceptually, but this count need not be printed.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces. The list must contain four entries in the order: the three booleans for the stability verification cases followed by the float error ratio for the accuracy assessment. For example, the output should look like \"[True,True,False,3.85]\" where the last number is a float.\n- There are no physical units in this problem; all quantities are dimensionless.", "solution": "The one-dimensional heat equation $u_t = \\alpha u_{xx}$ models diffusive smoothing. For a uniform grid $x_i = i \\Delta x$ with $i = 0,\\dots,N_x-1$ and time levels $t^n = n \\Delta t$, the explicit forward-time and second-order central-space scheme follows from the definitions of the time derivative and second derivative. The time derivative is approximated by the forward difference $u_t(x_i,t^n) \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}$, and the second derivative by the central difference $u_{xx}(x_i,t^n) \\approx \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{(\\Delta x)^2}$. Equating these approximations yields the explicit update\n$$\nu_i^{n+1} = u_i^n + r \\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\\right), \\quad r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2},\n$$\nfor interior indices $i = 1,\\dots,N_x-2$, with Dirichlet boundary conditions $u_0^n = 0$ and $u_{N_x-1}^n = 0$ for all $n$.\n\nPrinciple-based stability analysis uses the Von Neumann method for linear constant-coefficient schemes. Consider a Fourier mode $e^{\\mathrm{i} k x_i}$ and write the amplification factor $g(k)$ such that $u_i^{n+1} = g(k) u_i^n$ for that mode. Substituting the central difference yields\n$$\ng(k) = 1 - 4 r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right).\n$$\nStability in the sense of bounded amplification for all modes requires $\\lvert g(k) \\rvert \\le 1$ for all wavenumbers $k$. The most restrictive case is when $\\sin^2\\left(k \\Delta x/2\\right) = 1$, which yields the condition\n$$\n-1 \\le 1 - 4r \\le 1 \\quad \\Rightarrow \\quad r \\le \\frac{1}{2}.\n$$\nThus the explicit forward-time central-space scheme is stable if and only if $r \\le 1/2$. The scheme is first-order accurate in time ($\\mathcal{O}(\\Delta t)$ truncation error) and second-order accurate in space ($\\mathcal{O}((\\Delta x)^2)$ truncation error). If one keeps $r$ fixed when refining the grid, then $\\Delta t$ scales like $(\\Delta x)^2$, and both temporal and spatial errors scale as $\\mathcal{O}((\\Delta x)^2)$, with overall error behaving like $\\mathcal{O}((\\Delta x)^2)$. Under this coupling, halving $\\Delta x$ reduces the error by a factor of approximately $4$.\n\nEfficiency considerations for the explicit method are straightforward: each time step updates $N_x-2$ interior points and involves a constant amount of arithmetic per point, so the computational work proxy $W$ scales like $W = N_t \\cdot (N_x - 2)$, where $N_t$ is the number of time steps. For fixed $r$ and final time $T$, we have $\\Delta t = r (\\Delta x)^2/\\alpha$ and $N_t \\approx T/\\Delta t \\propto 1/(\\Delta x)^2$. Consequently, the total work scales like $W \\propto (N_x-2) \\cdot 1/(\\Delta x)^2 \\sim \\mathcal{O}(N_x^3)$ for one-dimensional uniform grids (since $N_x \\sim 1/\\Delta x$), reflecting the parabolic restriction on the time step for explicit schemes.\n\nThe program implements the explicit scheme with $u(x,0) = \\sin(\\pi x)$ and Dirichlet boundaries, evolves to the final time $T$ for specified $\\alpha$, $N_x$, and $r$, and measures observational stability by monitoring the maximum norm over time. It computes the infinity-norm error at the last simulated time using the exact solution $u(x,t) = e^{-\\alpha \\pi^2 t} \\sin(\\pi x)$. The stability verification compares the observed classification with the theoretical classification based on $r$ and outputs booleans per test case. For accuracy assessment, it computes the error ratio $E_{\\text{coarse}}/E_{\\text{fine}}$ under the stable coupling $r = 0.45$, $N_x = 51$ versus $N_x = 101$, expecting a ratio near $4$, consistent with second-order accuracy in space and the coupled first-order in time with $\\Delta t \\propto (\\Delta x)^2$.\n\nThe final output is a single line in the format \"[b1,b2,b3,ratio]\", where $b1$, $b2$, and $b3$ are booleans for the cases $r = 0.45$, $r = 0.5$, and $r = 0.55$, respectively, and \"ratio\" is the floating-point value of $E_{\\text{coarse}}/E_{\\text{fine}}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef explicit_heat(alpha: float, Nx: int, r: float, T: float):\n    \"\"\"\n    Run the explicit FTCS (Forward-Time, Central-Space) scheme for the 1D heat equation\n    u_t = alpha * u_xx with Dirichlet boundaries u(0,t)=u(1,t)=0 and initial condition\n    u(x,0) = sin(pi x).\n\n    Parameters\n    ----------\n    alpha : float\n        Diffusion coefficient (dimensionless).\n    Nx : int\n        Number of spatial grid points on [0,1].\n    r : float\n        Nondimensional parameter r = alpha * dt / dx^2.\n    T : float\n        Final simulation time.\n\n    Returns\n    -------\n    verify_match : bool\n        True if the observed stability classification matches the theoretical classification.\n    err_inf : float\n        Infinity-norm error at the final simulated time compared to the exact solution.\n    work_units : int\n        Proxy for computational work: number of interior updates performed.\n    \"\"\"\n    L = 1.0\n    x = np.linspace(0.0, L, Nx)\n    dx = x[1] - x[0]\n    dt = r * dx * dx / alpha\n    # Number of time steps to reach or slightly exceed T\n    Nt = int(np.ceil(T / dt)) if dt > 0 else 0\n    # Initialize u with the exact initial condition\n    u = np.sin(np.pi * x)\n    # Enforce Dirichlet boundaries explicitly (though sin(pi*x) already satisfies them)\n    u[0] = 0.0\n    u[-1] = 0.0\n    max_initial = np.max(np.abs(u))\n    max_over_time = max_initial\n    observed_stable = True\n\n    # Time stepping loop\n    for _ in range(Nt):\n        # Vectorized interior update\n        u_new = u.copy()\n        u_new[1:-1] = u[1:-1] + r * (u[2:] - 2.0 * u[1:-1] + u[:-2])\n        # Enforce Dirichlet boundaries\n        u_new[0] = 0.0\n        u_new[-1] = 0.0\n        u = u_new\n        current_max = np.max(np.abs(u))\n        # Detect numerical issues\n        if not np.isfinite(current_max):\n            observed_stable = False\n            max_over_time = np.inf\n            break\n        if current_max > max_over_time:\n            max_over_time = current_max\n\n    # Observational stability criterion: no growth beyond 5% of initial peak\n    if not (np.isfinite(max_over_time) and max_over_time = 1.05 * max_initial):\n        observed_stable = False\n\n    # Final time actually reached\n    t_end = Nt * dt\n    # Exact solution at final time\n    u_exact = np.exp(-alpha * (np.pi ** 2) * t_end) * np.sin(np.pi * x)\n    # Infinity-norm error\n    err_inf = float(np.max(np.abs(u - u_exact)))\n\n    # Theoretical stability classification for FTCS heat: r = 1/2\n    theoretical_stable = (r = 0.5 + 1e-12)\n    verify_match = (observed_stable == theoretical_stable)\n\n    # Work units proxy: number of interior updates\n    work_units = Nt * max(Nx - 2, 0)\n    return verify_match, err_inf, work_units\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Stability verification cases: alpha=1.0, Nx=51, T=0.1, r in {0.45, 0.5, 0.55}\n    stability_cases = [\n        (1.0, 51, 0.45, 0.1),\n        (1.0, 51, 0.5, 0.1),\n        (1.0, 51, 0.55, 0.1),\n    ]\n    # Accuracy ratio assessment: alpha=1.0, T=0.1, r=0.45, Nx in {51, 101}\n    accuracy_params = {\n        \"alpha\": 1.0,\n        \"T\": 0.1,\n        \"r\": 0.45,\n        \"Nx_coarse\": 51,\n        \"Nx_fine\": 101,\n    }\n\n    results = []\n\n    # Run stability verification cases\n    for alpha, Nx, r, T in stability_cases:\n        verify_match, _, _ = explicit_heat(alpha, Nx, r, T)\n        results.append(verify_match)\n\n    # Run accuracy ratio assessment\n    # Coarse grid\n    e_match_c, err_coarse, _ = explicit_heat(\n        accuracy_params[\"alpha\"], accuracy_params[\"Nx_coarse\"], accuracy_params[\"r\"], accuracy_params[\"T\"]\n    )\n    # Fine grid\n    e_match_f, err_fine, _ = explicit_heat(\n        accuracy_params[\"alpha\"], accuracy_params[\"Nx_fine\"], accuracy_params[\"r\"], accuracy_params[\"T\"]\n    )\n    # Compute error ratio; guard against zero to avoid division by zero\n    ratio = (err_coarse / err_fine) if err_fine != 0.0 else float(\"inf\")\n    results.append(ratio)\n\n    # Final print statement in the exact required format: single line, no spaces.\n    def fmt(x):\n        if isinstance(x, float):\n            # Format float with reasonable precision, remove spaces\n            return f\"{x:.12g}\"\n        else:\n            return str(x)\n\n    print(f\"[{','.join(fmt(r) for r in results)}]\")\n\nsolve()\n```", "id": "3204666"}, {"introduction": "We've seen that the FTCS scheme can become unstable, but what is the underlying mechanism? Stability analysis reveals that the highest-frequency oscillations representable on the grid are the first to grow uncontrollably. This exercise [@problem_id:3227167] is a numerical experiment designed to \"stress-test\" the scheme by initializing the simulation with precisely this most volatile mode. By observing its explosive growth when the stability condition is violated, you will gain a deeper, more intuitive grasp of why high-frequency errors are the primary culprits in the breakdown of explicit methods.", "problem": "Consider the one-dimensional diffusion equation on a unit interval with homogeneous Dirichlet boundary conditions, stated as follows. Let $u(x,t)$ be a sufficiently smooth, dimensionless field defined for $x \\in [0,1]$ and $t \\ge 0$, satisfying the partial differential equation $u_t = \\alpha u_{xx}$, with parameters $\\alpha > 0$, $u(0,t) = 0$, and $u(1,t) = 0$. Discretize the spatial domain into $M$ equal subintervals with spacing $\\Delta x = 1/M$ and grid points $x_j = j \\Delta x$ for $j = 0,1,\\dots,M$. Using the forward-time central-space (FTCS) explicit scheme, approximate $u_t$ by the forward difference over a uniform time step $\\Delta t$ and approximate $u_{xx}$ by the second-order central difference over the spatial grid. Define the dimensionless parameter $r = \\alpha \\Delta t / \\Delta x^2$. The interior update is to be applied for indices $j = 1,2,\\dots,M-1$, while the boundary values at $j = 0$ and $j = M$ remain fixed at zero for all time levels.\n\nDesign an initial condition composed exclusively of the highest frequency discrete sine mode that is representable on the grid and that satisfies the homogeneous Dirichlet boundary conditions. This highest frequency mode is the discrete sine mode with index $m = M - 1$, given at interior points by $u_j^0 = \\sin\\!\\big( (M-1)\\pi x_j \\big)$ for $j = 1,2,\\dots,M-1$, with $u_0^0 = 0$ and $u_M^0 = 0$. Evolve this initial condition forward in time using the FTCS scheme for a prescribed number of time steps $N_t$.\n\nYour task is to quantitatively capture the growth or decay of the solution under different choices of the parameter $r$. For each specified test case, compute the ratio $R$ defined as the discrete infinity-norm growth factor,\n$$\nR = \\frac{\\max_{0 \\le j \\le M} \\big|u_j^{N_t}\\big|}{\\max_{0 \\le j \\le M} \\big|u_j^{0}\\big|}.\n$$\nAll quantities are dimensionless. Use $\\alpha = 1$ and $L = 1$ so that $\\Delta x = 1/M$, and set the time step $\\Delta t$ via the specified value of $r$ using $\\Delta t = r \\Delta x^2 / \\alpha$. Implement the FTCS time-marching using these values.\n\nTest Suite:\n- Case $1$: $M = 64$, $N_t = 50$, $r = 0.49$.\n- Case $2$: $M = 64$, $N_t = 50$, $r = 0.50$.\n- Case $3$: $M = 64$, $N_t = 50$, $r = 0.51$.\n- Case $4$: $M = 64$, $N_t = 20$, $r = 1.00$.\n\nYour program should produce a single line of output containing the results for the four cases aggregated as a comma-separated list enclosed in square brackets, with each element being the corresponding floating-point growth ratio $R$ in the order of the cases listed above (for example, $[R_1,R_2,R_3,R_4]$). No units are required because the variables are dimensionless, and angles are in radians by construction of the sine mode.", "solution": "The problem requires the numerical solution of the one-dimensional diffusion equation, $u_t = \\alpha u_{xx}$, on a spatial domain $x \\in [0,1]$ with homogeneous Dirichlet boundary conditions, $u(0,t) = 0$ and $u(1,t) = 0$. We will employ the Forward-Time Central-Space (FTCS) explicit finite difference scheme.\n\nFirst, we discretize the partial differential equation. The spatial domain is divided into $M$ subintervals of width $\\Delta x = 1/M$, creating a grid of points $x_j = j \\Delta x$ for $j = 0, 1, \\dots, M$. The time domain is discretized into steps of size $\\Delta t$. We denote the numerical approximation of the solution $u(x_j, n\\Delta t)$ as $u_j^n$.\n\nThe time derivative $u_t$ at $(x_j, t_n)$ is approximated using a first-order forward difference:\n$$\nu_t \\approx \\frac{u_j^{n+1} - u_j^n}{\\Delta t}\n$$\nThe second spatial derivative $u_{xx}$ is approximated using a second-order central difference:\n$$\nu_{xx} \\approx \\frac{u_{j-1}^n - 2u_j^n + u_{j+1}^n}{\\Delta x^2}\n$$\nSubstituting these approximations into the diffusion equation $u_t = \\alpha u_{xx}$ yields:\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\alpha \\frac{u_{j-1}^n - 2u_j^n + u_{j+1}^n}{\\Delta x^2}\n$$\nRearranging this equation to solve for the solution at the next time step, $u_j^{n+1}$, gives the explicit FTCS update rule:\n$$\nu_j^{n+1} = u_j^n + \\frac{\\alpha \\Delta t}{\\Delta x^2} \\left( u_{j-1}^n - 2u_j^n + u_{j+1}^n \\right)\n$$\nWe define the dimensionless diffusion number, $r = \\frac{\\alpha \\Delta t}{\\Delta x^2}$. The update rule simplifies to:\n$$\nu_j^{n+1} = u_j^n + r \\left( u_{j-1}^n - 2u_j^n + u_{j+1}^n \\right)\n$$\nThis equation is applied to all interior grid points, i.e., for $j = 1, 2, \\dots, M-1$. The boundary conditions dictate that $u_0^n = 0$ and $u_M^n = 0$ for all time levels $n$.\n\nThe problem specifies an initial condition $u(x,0)$ composed of the highest frequency discrete sine mode representable on the grid that satisfies the boundary conditions. This mode corresponds to an index $m = M-1$, given by $u_j^0 = \\sin((M-1)\\pi x_j)$ for $j=1,\\dots,M-1$. This mode is chosen because it represents the most challenging case for the stability of the numerical scheme. The values at the boundaries are $u_0^0 = \\sin(0) = 0$ and $u_M^0 = \\sin((M-1)\\pi \\cdot M/M) = \\sin((M-1)\\pi) = 0$, satisfying the Dirichlet conditions.\n\nA crucial aspect of explicit schemes like FTCS is conditional stability. A von Neumann stability analysis shows that the FTCS scheme for the diffusion equation is stable only if $r \\le 1/2$. For an initial condition containing multiple frequency modes, if $r > 1/2$, the high-frequency components experience amplification in each time step, leading to catastrophic, unphysical growth of the numerical solution. The stability condition for a specific discrete mode with index $m$ is $r \\le \\frac{1}{2 \\sin^2(m\\pi / (2M))}$. The most restrictive condition comes from the highest frequency mode, $m=M-1$, yielding a critical value $r_c = \\frac{1}{2 \\sin^2((M-1)\\pi / (2M))}$. For large $M$, $\\sin^2((M-1)\\pi / (2M)) \\approx 1$, so $r_c \\approx 0.5$. The provided test cases with $r=0.49$, $r=0.50$, and $r=0.51$ are designed to probe this stability boundary. For $M=64$, the critical value is $r_c \\approx 0.50096$. We therefore expect decay (stability) for $r \\le 0.50$ and growth (instability) for $r = 0.51$.\n\nThe algorithm to solve the problem is as follows:\n1.  For each test case $(M, N_t, r)$, initialize the constants $\\alpha=1$ and the grid. The spatial step is $\\Delta x = 1/M$.\n2.  Create an array `u` of size $M+1$ to store the solution at a given time step.\n3.  Set the initial condition: $u_j^0 = \\sin((M-1)\\pi x_j) = \\sin((M-1)\\pi j \\Delta x)$ for $j=1, \\dots, M-1$. The boundary points $u_0^0$ and $u_M^0$ are zero.\n4.  Calculate the initial discrete infinity-norm, $N_0 = \\max_{0 \\le j \\le M} |u_j^0|$.\n5.  Iterate for $N_t$ time steps. In each step, compute the next state $u^{n+1}$ from the current state $u^n$ using the FTCS update rule for all interior points. A copy of the solution at step $n$ must be used to calculate all values for step $n+1$ before updating the solution array.\n6.  After $N_t$ steps, calculate the final discrete infinity-norm, $N_{final} = \\max_{0 \\le j \\le M} |u_j^{N_t}|$.\n7.  Compute the required ratio $R = N_{final} / N_0$.\n\nThis procedure is repeated for all four test cases. The implementation will use vectorized `numpy` operations for efficiency.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D diffusion equation using the FTCS scheme for several\n    test cases and calculates the infinity-norm growth factor.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (M, N_t, r).\n    test_cases = [\n        (64, 50, 0.49),\n        (64, 50, 0.50),\n        (64, 50, 0.51),\n        (64, 20, 1.00),\n    ]\n\n    results = []\n    for case in test_cases:\n        M, N_t, r = case\n        \n        # Spatial discretization\n        # L=1, so dx = 1/M. Total points = M+1 (from j=0 to j=M)\n        M_int = int(M)\n        x = np.linspace(0.0, 1.0, M_int + 1)\n        \n        # Initial condition u(x,0)\n        # Highest frequency discrete sine mode: sin((M-1)*pi*x)\n        u = np.zeros(M_int + 1)\n        # Apply to interior points j = 1, ..., M-1\n        u[1:M_int] = np.sin((M_int - 1) * np.pi * x[1:M_int])\n        \n        # Calculate the initial discrete infinity-norm of the solution\n        u_norm_initial = np.max(np.abs(u))\n        \n        # Time-marching loop using the FTCS scheme\n        for _ in range(int(N_t)):\n            # Store the current state to use in the update step\n            u_old = u.copy()\n            \n            # Apply the FTCS update rule for all interior points j=1..M-1\n            # u_j^{n+1} = u_j^n + r * (u_{j-1}^n - 2*u_j^n + u_{j+1}^n)\n            # This is vectorized for efficiency.\n            u[1:M_int] = u_old[1:M_int] + r * (u_old[0:M_int-1] - 2 * u_old[1:M_int] + u_old[2:M_int+1])\n            \n            # Boundary conditions u(0,t)=0 and u(1,t)=0 are maintained\n            # as u[0] and u[M] are never updated and were initialized to 0.\n\n        # Calculate the final discrete infinity-norm of the solution\n        u_norm_final = np.max(np.abs(u))\n        \n        # Compute the growth factor ratio R\n        # Handle the case where the initial norm is zero to avoid division by zero.\n        if u_norm_initial == 0.0:\n            # If initial is zero, final should also be zero. Ratio is 1 if both are 0.\n            # If final is non-zero, it implies infinite growth, which 'inf' can represent.\n            growth_ratio = 1.0 if u_norm_final == 0.0 else np.inf\n        else:\n            growth_ratio = u_norm_final / u_norm_initial\n            \n        results.append(growth_ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.12f}' for res in results)}]\")\n\nsolve()\n```", "id": "3227167"}]}