{"hands_on_practices": [{"introduction": "The best way to grasp the characteristics of a numerical method is to see it in action. This first exercise provides a foundational hands-on experience with the first-order upwind scheme by applying it to the linear advection equation. By simulating the movement of a sharp discontinuity, a Heaviside step function, you will directly observe the scheme's behavior—most notably, the introduction of numerical diffusion which smears the sharp front. This practice is essential for understanding the trade-offs between stability and accuracy inherent in simple numerical methods. [@problem_id:2448567]", "problem": "Consider the one-dimensional linear advection equation for a scalar field $u(x,t)$ with constant advection speed $a$,\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\\quad x \\in [x_{\\min},x_{\\max}],\\ t \\ge 0,\n$$\nwith the initial condition given by the Heaviside step function\n$$\nu(x,0) = H(x - x_0),\\quad H(\\xi) = \\begin{cases}\n1, \\xi \\ge 0,\\\\\n0, \\xi  0.\n\\end{cases}\n$$\nImpose inflow boundary conditions consistent with the far-field states of the initial data: if $a  0$, enforce $u(x_{\\min},t)=0$ for all $t \\ge 0$; if $a  0$, enforce $u(x_{\\max},t)=1$ for all $t \\ge 0$. All quantities are dimensionless.\n\nAdvance the solution in time on a uniform spatial grid of $N$ points in $[x_{\\min},x_{\\max}]$ up to a final time $T$, with a time step $\\Delta t$ chosen to satisfy a specified Courant–Friedrichs–Lewy (CFL) number $C$, where\n$$\nC = \\frac{|a|\\,\\Delta t}{\\Delta x},\\quad \\Delta x = \\frac{x_{\\max} - x_{\\min}}{N-1}.\n$$\nUse a first-order upwind discretization consistent with the sign of $a$. For each test case below, compute the discrete $\\ell^1$ error at time $T$ defined by\n$$\nE_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x,\n$$\nwhere $x_i$ are the grid points, $u_i^{\\text{num}}(T)$ is the numerical solution at time $T$, and the analytical solution is the translated step\n$$\nu^{\\text{exact}}(x,T) = H\\!\\left( x - (x_0 + a\\,T) \\right),\n$$\nwhich is valid for the times and parameters given below because the advected discontinuity remains strictly inside the interval $[x_{\\min},x_{\\max}]$ and does not interact with the boundaries.\n\nTest Suite (each test case is a tuple $(a,x_{\\min},x_{\\max},x_0,N,T,C)$):\n- Test $1$: $(1.0,\\,0.0,\\,1.0,\\,0.25,\\,401,\\,0.2,\\,0.5)$.\n- Test $2$: $(-0.7,\\,0.0,\\,1.0,\\,0.8,\\,401,\\,0.15,\\,0.8)$.\n- Test $3$: $(1.0,\\,0.0,\\,1.0,\\,0.3,\\,201,\\,0.3,\\,1.0)$.\n\nYour program must compute $E_1$ for each test in the order listed and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each number rounded to six decimal places (for example, $[0.123456,0.000000,1.234568]$).", "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It presents a standard task in computational physics: solving the linear advection equation using a first-order upwind scheme and evaluating the numerical error. All parameters and conditions are clearly defined.\n\nThe governing equation is the one-dimensional linear advection equation for a scalar field $u(x,t)$ with a constant advection speed $a$:\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0\n$$\nTo solve this equation numerically, we discretize the spatio-temporal domain. The spatial domain $[x_{\\min}, x_{\\max}]$ is divided into a uniform grid of $N$ points, $x_i = x_{\\min} + i\\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = (x_{\\max} - x_{\\min}) / (N-1)$. Time is advanced in discrete steps, and we denote the numerical approximation of $u(x_i, t^n)$ as $u_i^n$.\n\nThe time derivative $\\partial_t u$ is approximated using a first-order forward difference (Forward Euler method):\n$$\n\\partial_t u(x_i, t^n) \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\nThe first-order upwind scheme approximates the spatial derivative $\\partial_x u$ using a one-sided finite difference. The choice of the one-sided stencil depends on the direction of information propagation, which is given by the sign of the advection speed $a$. This ensures that the numerical method draws information from the \"upwind\" direction, a crucial property for the stability of hyperbolic solvers.\n\nCase 1: $a > 0$\nInformation propagates from left to right (in the positive $x$ direction). The spatial derivative at $x_i$ is approximated using a backward difference, which involves the point upwind, $x_{i-1}$:\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n$$\nSubstituting these discrete approximations into the partial differential equation yields the update rule:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_i^n - u_{i-1}^n}{\\Delta x} = 0\n$$\nSolving for the solution at the next time step, $u_i^{n+1}$:\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n) = u_i^n - C (u_i^n - u_{i-1}^n)\n$$\nwhere $C = \\frac{a \\Delta t}{\\Delta x}$ is the Courant–Friedrichs–Lewy (CFL) number, as $a>0$. This scheme is applied for $i=1, \\dots, N-1$.\n\nCase 2: $a  0$\nInformation propagates from right to left (in the negative $x$ direction). The spatial derivative is approximated using a forward difference, involving the upwind point $x_{i+1}$:\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_{i+1}^n - u_i^n}{\\Delta x}\n$$\nThe corresponding update rule is:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_{i+1}^n - u_i^n}{\\Delta x} = 0\n$$\nSolving for $u_i^{n+1}$:\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n) = u_i^n + C (u_{i+1}^n - u_i^n)\n$$\nHere, the CFL number is defined as $C = \\frac{|a| \\Delta t}{\\Delta x} = \\frac{-a \\Delta t}{\\Delta x}$, which means $\\frac{a \\Delta t}{\\Delta x} = -C$. This scheme is applied for $i=0, \\dots, N-2$.\n\nThe stability of this explicit time-stepping scheme is guaranteed if the CFL condition, $C \\le 1$, is met. All test cases provided satisfy this condition.\n\nThe simulation proceeds as follows:\n1.  **Initialization**: For each test case $(a, x_{\\min}, x_{\\max}, x_0, N, T, C)$, the grid spacing $\\Delta x$ and nominal time step $\\Delta t = C \\Delta x / |a|$ are calculated. The solution array $u$ is initialized with the Heaviside function $u(x,0) = H(x - x_0)$.\n2.  **Time Evolution**: A loop advances the solution from $t=0$ to $T$. To ensure the final time $T$ is reached precisely, the time step for each iteration is calculated as $\\Delta t_{\\text{curr}} = \\min(\\Delta t, T - t)$. This handles cases where $T$ is not an integer multiple of $\\Delta t$.\n3.  **Update Step**: Inside the loop, a copy of the solution $u^n$ is made. The new solution $u^{n+1}$ is computed for all interior points using the appropriate upwind formula, with the update coefficient scaled by $\\Delta t_{\\text{curr}}$.\n4.  **Boundary Conditions**: After computing the interior-point updates, the inflow boundary condition is enforced. If $a  0$, the value at the left boundary is set: $u_0^{n+1} = 0$. If $a  0$, the value at the right boundary is set: $u_{N-1}^{n+1} = 1$. The outflow boundary requires no special treatment as it is handled by the one-sided nature of the upwind stencil.\n5.  **Error Calculation**: Once the simulation reaches $t=T$, the final numerical solution $u_i^{\\text{num}}(T)$ is obtained. The analytical solution $u^{\\text{exact}}(x_i,T) = H(x_i - (x_0 + aT))$ is computed on the same grid. The discrete $\\ell^1$ error is then calculated using the formula:\n    $$\n    E_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x\n    $$\nFor the test case where $C=1.0$, the scheme (for $a>0$) simplifies to $u_i^{n+1} = u_{i-1}^n$. This corresponds to an exact shift of the discrete data by one grid cell per time step. Since the total time $T$ is chosen such that the total advection distance $aT$ is an integer multiple of $\\Delta x$, the numerical solution on the grid is identical to the exact solution, resulting in zero error. For $C  1$, the scheme introduces numerical diffusion, which smears the sharp step and produces a non-zero error.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation for multiple test cases\n    using a first-order upwind scheme and computes the l1 error.\n    \"\"\"\n    test_cases = [\n        # (a, x_min, x_max, x_0, N, T, C)\n        (1.0, 0.0, 1.0, 0.25, 401, 0.2, 0.5),\n        (-0.7, 0.0, 1.0, 0.8, 401, 0.15, 0.8),\n        (1.0, 0.0, 1.0, 0.3, 201, 0.3, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(*case)\n        # Append result formatted to six decimal places.\n        results.append(f\"{error:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_case(a, x_min, x_max, x_0, N, T, C):\n    \"\"\"\n    Runs a single simulation case for the 1D linear advection equation.\n\n    Args:\n        a (float): Advection speed.\n        x_min (float): Minimum of the spatial domain.\n        x_max (float): Maximum of the spatial domain.\n        x_0 (float): Initial position of the step in the Heaviside function.\n        N (int): Number of grid points.\n        T (float): Final time.\n        C (float): Courant–Friedrichs–Lewy (CFL) number.\n\n    Returns:\n        float: The discrete l1 error at the final time T.\n    \"\"\"\n    # 1. Setup grid and initial condition\n    dx = (x_max - x_min) / (N - 1)\n    x = np.linspace(x_min, x_max, N)\n    # The problem defines H(xi) = 1 for xi = 0. np.heaviside with second arg 1.0 does this.\n    u = np.heaviside(x - x_0, 1.0)\n\n    # 2. Setup time stepping\n    # The advection speed 'a' is non-zero in all test cases.\n    dt_nominal = C * dx / abs(a)\n    \n    # 3. Time integration loop\n    t = 0.0\n    # Use a small tolerance for floating point comparison to ensure loop termination.\n    while t  T:\n        # Determine current time step to not step over T.\n        current_dt = min(dt_nominal, T - t)\n        \n        # Make a copy of the solution at the current time step 'n'.\n        u_n = u.copy()\n        \n        # The update coefficient nu = a * dt / dx\n        nu = a * current_dt / dx\n        \n        if a  0:\n            # FTBS (Forward-Time, Backward-Space) for a  0\n            # u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n)\n            u[1:] = u_n[1:] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_min\n            u[0] = 0.0\n        else: # a  0\n            # FTFS (Forward-Time, Forward-Space) for a  0\n            # u_i^{n+1} = u_i^n - nu * (u_{i+1}^n - u_i^n)\n            u[:-1] = u_n[:-1] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_max\n            u[-1] = 1.0\n            \n        t += current_dt\n\n    # 4. Calculate exact solution at time T\n    x_final_discontinuity = x_0 + a * T\n    u_exact = np.heaviside(x - x_final_discontinuity, 1.0)\n    \n    # 5. Compute the discrete l1 error\n    error = np.sum(np.abs(u - u_exact)) * dx\n    \n    return error\n\nsolve()\n```", "id": "2448567"}, {"introduction": "Building on the constant-speed case, we now explore a more dynamic scenario where the advection speed varies in space and even changes sign. This practice is designed to test your core understanding of the \"upwind\" principle, as the numerical stencil must adapt locally to the direction of information flow at each point in the domain. Successfully implementing this logic is a critical step toward simulating more realistic physical systems where flows can be complex and non-uniform. [@problem_id:3285398]", "problem": "Consider the one-dimensional linear advection equation with space-dependent speed,\n$$\nu_t(x,t) + a(x)\\,u_x(x,t) = 0,\\quad x\\in[0,1],\\ t\\ge 0,\n$$\nwhere $u(x,t)$ is a transported scalar field and $a(x)$ is a prescribed, sufficiently smooth speed that may change sign over the spatial domain. For a hyperbolic transport equation, information travels along characteristic curves determined by the sign of $a(x)$, and a stable discretization must use values from the upwind direction. Your task is to implement a first-order explicit upwind finite difference method that switches stencils according to the local sign of $a(x)$, and to quantify properties of this switching and of the resulting discrete solution.\n\nImplement the following design in a single, complete program:\n- Discretize $[0,1]$ using a uniform grid of $N$ points $x_i = i\\,\\Delta x$ for $i=0,1,\\dots,N-1$ with $\\Delta x = 1/(N-1)$.\n- Use a single explicit Euler time stepper with time step $\\Delta t$ satisfying the Courant-Friedrichs-Lewy (CFL) stability condition, specifically\n$$\n\\Delta t = \\lambda\\,\\frac{\\Delta x}{\\max_{0\\le i\\le N-1} |a(x_i)|},\n$$\nwhere $0\\lambda\\le 1$ is the Courant number.\n- At each interior grid point $i=1,2,\\dots,N-2$, approximate $u_x(x_i,t)$ by a one-sided difference taken from the upwind direction, chosen by the sign of $a(x_i)$: use a backward difference if $a(x_i)0$, use a forward difference if $a(x_i)0$, and set the derivative contribution to zero when $a(x_i)=0$ (no transport).\n- Impose Dirichlet boundary values $u(0,t) = u_L$ and $u(1,t) = u_R$ for all $t\\ge 0$. Note that, for a hyperbolic flow, these act as inflow values where characteristic information enters the domain; on outflow boundaries they do not influence interior updates because the upwind stencil does not reference them.\n- Advance the numerical solution for $K$ explicit Euler steps.\n\nFrom first principles, this method must be derived using the causality of the hyperbolic transport equation and the directionality of characteristics implied by the sign of $a(x)$. In particular, the backward difference is consistent with $a(x)0$ because information at $x_i$ arrives from $x_{i-1}$, whereas the forward difference is consistent with $a(x)0$ because information at $x_i$ arrives from $x_{i+1}$.\n\nDefine the following discrete diagnostics to be computed by your program for each test case:\n1. The integer number of interior points $i=1,\\dots,N-2$ where the method uses a backward difference (i.e., points with $a(x_i)0$).\n2. The integer number of interior points $i=1,\\dots,N-2$ where the method uses a forward difference (i.e., points with $a(x_i)0$).\n3. The integer number of sign-change interfaces in the discrete speed field, defined as the count of indices $i=0,\\dots,N-2$ such that $\\operatorname{sign}(a(x_i))\\ne \\operatorname{sign}(a(x_{i+1}))$, with the convention $\\operatorname{sign}(0)=0$.\n4. A boolean indicating whether, after $K$ steps, the discrete solution satisfies a discrete maximum principle relative to the envelope of the initial and boundary data, namely whether\n$$\n\\min_{0\\le i\\le N-1} u^K_i \\ge \\min\\left(\\min_{0\\le i\\le N-1} u^0_i,\\ u_L,\\ u_R\\right)\n\\quad\\text{and}\\quad\n\\max_{0\\le i\\le N-1} u^K_i \\le \\max\\left(\\max_{0\\le i\\le N-1} u^0_i,\\ u_L,\\ u_R\\right),\n$$\nwhere $u^n_i$ denotes the numerical solution at grid point $x_i$ after $n$ time steps.\n\nUse the following test suite of parameter values to exercise different facets of the method:\n- Test case A (general case with a single jump and distinct magnitudes):\n  - $N=51$, $\\lambda=0.9$, $K=25$,\n  - $a(x)=\\begin{cases}1, x0.5\\\\ -0.5, x\\ge 0.5\\end{cases}$,\n  - $u_L=0$, $u_R=1$,\n  - $u_0(x)=\\sin(2\\pi x)$.\n- Test case B (boundary-aligned zero speed, exact sign reversal at a grid point):\n  - $N=51$, $\\lambda=0.9$, $K=30$,\n  - $a(x)=x-0.5$,\n  - $u_L=0.5$, $u_R=-0.5$,\n  - $u_0(x)=1-2|x-0.5|$.\n- Test case C (smooth sign change with rapidly varying transition):\n  - $N=101$, $\\lambda=0.9$, $K=40$,\n  - $a(x)=\\tanh\\big(20(0.7-x)\\big)$,\n  - $u_L=1$, $u_R=-1$,\n  - $u_0(x)=\\cos(4\\pi x)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must itself be a comma-separated list in square brackets in the order described above. For example, the output format must be\n$$\n[\\,[n_{\\text{back}},n_{\\text{fwd}},n_{\\text{sign}},\\text{mp}],\\,[\\dots],\\,[\\dots]\\,],\n$$\nwhere $n_{\\text{back}}$ and $n_{\\text{fwd}}$ are integers, $n_{\\text{sign}}$ is an integer, and $\\text{mp}$ is a boolean.", "solution": "The user-provided problem is assessed to be valid. It is a well-posed, scientifically grounded problem in the field of numerical analysis for partial differential equations, with all necessary components clearly defined.\n\nThe problem requires the implementation of a first-order explicit upwind finite difference method for the one-dimensional linear advection equation with a space-dependent, sign-changing advection speed $a(x)$:\n$$\nu_t(x,t) + a(x)\\,u_x(x,t) = 0\n$$\nThe fundamental principle governing this problem is that of hyperbolic causality. Information for hyperbolic equations, such as the advection equation, propagates along characteristic curves. The trajectory of these curves in the $(x,t)$-plane is defined by the ordinary differential equation $dx/dt = a(x)$. The sign of the speed $a(x)$ dictates the direction of information flow: if $a(x)0$, information travels from left to right, and if $a(x)0$, it travels from right to left. A stable numerical scheme must respect this physical causality by differencing in the \"upwind\" direction—the direction from which information arrives.\n\nThe solution is discretized on a uniform spatial grid of $N$ points, $x_i = i\\,\\Delta x$ for $i=0, 1, \\dots, N-1$, with grid spacing $\\Delta x = 1/(N-1)$. Time is advanced using an explicit Euler method with a time step $\\Delta t$. The semi-discretized equation at grid point $x_i$ is:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a(x_i) (u_x)_i^n = 0\n$$\nwhich gives the update formula $u_i^{n+1} = u_i^n - \\Delta t \\, a(x_i) (u_x)_i^n$.\n\nThe core of the upwind method lies in the approximation of the spatial derivative, $(u_x)_i^n$. The choice of stencil is determined by the local sign of the advection speed $a(x_i)$:\n1.  If $a(x_i)  0$, the flow is from left to right. Information at $x_i$ comes from $x_{i-1}$. The spatial derivative is approximated using a first-order backward difference:\n    $$\n    (u_x)_i^n \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n    $$\n2.  If $a(x_i)  0$, the flow is from right to left. Information at $x_i$ comes from $x_{i+1}$. The spatial derivative is approximated using a first-order forward difference:\n    $$\n    (u_x)_i^n \\approx \\frac{u_{i+1}^n - u_i^n}{\\Delta x}\n    $$\n3.  If $a(x_i) = 0$, there is no transport at $x_i$. The advection term $a(x_i)u_x$ is zero, and the solution does not change: $u_i^{n+1} = u_i^n$.\n\nCombining these, the full update scheme for interior points $i=1, \\dots, N-2$ is:\n$$\nu_i^{n+1} = \\begin{cases}\nu_i^n - \\frac{a(x_i)\\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n),  \\text{if } a(x_i)  0 \\\\\nu_i^n - \\frac{a(x_i)\\Delta t}{\\Delta x}(u_{i+1}^n - u_i^n),  \\text{if } a(x_i)  0 \\\\\nu_i^n,  \\text{if } a(x_i) = 0\n\\end{cases}\n$$\nThis explicit scheme is stable under the Courant-Friedrichs-Lewy (CFL) condition, which requires the numerical domain of dependence to contain the physical one. This translates to the constraint $|a(x_i)|\\Delta t / \\Delta x \\le 1$ for all $i$. To ensure stability across the entire grid, the time step $\\Delta t$ is chosen based on the maximum speed:\n$$\n\\Delta t = \\lambda \\frac{\\Delta x}{\\max_{i} |a(x_i)|}\n$$\nwhere $\\lambda \\in (0, 1]$ is the Courant number.\n\nThe Dirichlet boundary conditions $u(0,t) = u_L$ and $u(1,t) = u_R$ are enforced by setting $u_0^n = u_L$ and $u_{N-1}^n = u_R$ for all time steps $n$. These values provide the necessary upwind data for interior points adjacent to the boundary when the flow is directed into the domain. For example, at $i=1$, if $a(x_1)0$, the stencil requires $u_0^n = u_L$. Conversely, if the flow is directed out of the domain (e.g., $a(x_1)0$), the boundary value $u_L$ is not used in the update for $u_1^n$, correctly reflecting the physics of outflow.\n\nThe implementation proceeds by first defining the discrete grid and evaluating the speed field $a(x_i)$ and initial condition $u_i^0$ at all grid points. The diagnostic quantities related to the speed field ($n_{\\text{back}}$, $n_{\\text{fwd}}$, $n_{\\text{sign}}$) are computed once. Then, the solution is advanced for $K$ time steps, where each step involves updating all interior points according to the upwind logic described above. After $K$ steps, the final solution $u_i^K$ is used to check the discrete maximum principle. This principle, which states that the scheme does not create new extrema, is a key property of this method and is satisfied if the CFL condition holds. It is verified by comparing the minimum and maximum of the final solution against the envelope of the initial data and boundary values.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, lambda_cfl, K, a_func, u_L, u_R, u0_func):\n    \"\"\"\n    Solves the 1D advection equation with a space-dependent speed\n    using a first-order upwind scheme and computes specified diagnostics.\n    \"\"\"\n    # 1. Grid and Field Setup\n    x = np.linspace(0.0, 1.0, N)\n    dx = 1.0 / (N - 1)\n    \n    a = a_func(x)\n    u = u0_func(x)\n    u_initial = u.copy()\n\n    # 2. Pre-computation of Diagnostics\n    # Number of interior points with backward/forward differences\n    interior_a = a[1:-1]\n    n_back = int(np.sum(interior_a  0))\n    n_fwd = int(np.sum(interior_a  0))\n\n    # Number of sign-change interfaces in the discrete speed field\n    signs = np.sign(a)\n    n_sign = int(np.sum(signs[:-1] != signs[1:]))\n\n    # 3. Time Step Calculation\n    a_max = np.max(np.abs(a))\n    if a_max == 0:\n        # Avoid division by zero if a(x) is identically zero.\n        # dt can be anything, as nothing will change.\n        dt = 1.0\n    else:\n        dt = lambda_cfl * dx / a_max\n\n    # 4. Time-stepping Loop\n    u[0] = u_L\n    u[N - 1] = u_R\n    \n    for _ in range(K):\n        u_old = u.copy()\n        \n        # Vectorized update for interior points, can be slow. A loop is clearer and sufficient for these N.\n        for i in range(1, N - 1):\n            a_i = a[i]\n            if a_i  0:\n                # Backward difference for u_x\n                grad_u = (u_old[i] - u_old[i-1]) / dx\n                u[i] = u_old[i] - dt * a_i * grad_u\n            elif a_i  0:\n                # Forward difference for u_x\n                grad_u = (u_old[i+1] - u_old[i]) / dx\n                u[i] = u_old[i] - dt * a_i * grad_u\n            # If a_i == 0, u[i] remains u_old[i], so no operation needed.\n    \n    # 5. Post-computation of Diagnostics (Maximum Principle)\n    min_bound = min(np.min(u_initial), u_L, u_R)\n    max_bound = max(np.max(u_initial), u_L, u_R)\n    \n    # Use a small tolerance for floating-point comparisons\n    tol = 1e-9\n    mp = bool((np.min(u) = min_bound - tol) and (np.max(u) = max_bound + tol))\n\n    return [n_back, n_fwd, n_sign, mp]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 51, \"lambda_cfl\": 0.9, \"K\": 25,\n            \"a_func\": lambda x: np.where(x  0.5, 1.0, -0.5),\n            \"u_L\": 0.0, \"u_R\": 1.0,\n            \"u0_func\": lambda x: np.sin(2 * np.pi * x)\n        },\n        {\n            \"N\": 51, \"lambda_cfl\": 0.9, \"K\": 30,\n            \"a_func\": lambda x: x - 0.5,\n            \"u_L\": 0.5, \"u_R\": -0.5,\n            \"u0_func\": lambda x: 1.0 - 2.0 * np.abs(x - 0.5)\n        },\n        {\n            \"N\": 101, \"lambda_cfl\": 0.9, \"K\": 40,\n            \"a_func\": lambda x: np.tanh(20 * (0.7 - x)),\n            \"u_L\": 1.0, \"u_R\": -1.0,\n            \"u0_func\": lambda x: np.cos(4 * np.pi * x)\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = run_simulation(\n            case[\"N\"], case[\"lambda_cfl\"], case[\"K\"],\n            case[\"a_func\"], case[\"u_L\"], case[\"u_R\"], case[\"u0_func\"]\n        )\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    inner_results_str = []\n    for res in all_results:\n        # res is a list like [n_back, n_fwd, n_sign, mp_bool]\n        inner_str = f\"[{res[0]},{res[1]},{res[2]},{str(res[3]).lower()}]\"\n        inner_results_str.append(inner_str)\n    \n    final_output_str = f\"[{','.join(inner_results_str)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3285398"}, {"introduction": "Real-world transport phenomena often involve more than just advection; diffusion plays a crucial role as well. This exercise moves to a more comprehensive model by discretizing the advection-diffusion equation, combining the upwind scheme for the advective term with a central difference scheme for the diffusive term. This practice is invaluable as it introduces the dimensionless Péclet number, $P_e$, which gauges the relative importance of advection versus diffusion, and requires you to analyze the combined stability constraints for this hybrid scheme. [@problem_id:3285468]", "problem": "Consider the linear advection-diffusion initial value problem on a periodic spatial domain, defined by the partial differential equation $u_t + a\\,u_x = \\nu\\,u_{xx}$ for $x \\in [0,L]$ and $t \\ge 0$, with constant advection speed $a$ and constant diffusion coefficient $\\nu$. The initial condition is $u(x,0) = \\sin\\!\\left(\\frac{2\\pi m}{L}\\,x\\right)$ with integer mode $m \\ge 1$, and periodic boundary conditions $u(0,t) = u(L,t)$ for all $t \\ge 0$. All quantities use the units: $x$ in meters, $t$ in seconds, $a$ in meters per second, and $\\nu$ in square meters per second. Outputs are dimensionless real numbers and booleans and should be unit-free.\n\nYour task is to derive an explicit upwind-in-time discretization for the advection term and a second-order central discretization for the diffusion term, then implement it to explore the regime defined by the Péclet number (Pe). Specifically:\n\n1. Starting from the conservation form and the definition of one-sided finite differences for first derivatives and centered finite differences for second derivatives on a uniform grid, derive a fully discrete explicit time-stepping scheme on a uniform mesh $x_j = j\\,\\Delta x$ for $j=0,1,\\dots,N-1$ with periodic indexing, and time levels $t^n = n\\,\\Delta t$. The scheme must use an upwind spatial difference for the advection term, chosen according to the sign of $a$, and a centered second difference for the diffusion term. Use forward Euler time integration. Express the discrete update in terms of coefficients that depend on the Courant number and the diffusion number, and determine a sufficient monotonicity-based stability condition that ensures all update coefficients are nonnegative.\n\n2. Using the derived discrete scheme, implement a program that, for each test case listed below, evolves the numerical solution from $t=0$ to $t=T$ on a uniform grid of $N$ points with spatial step $\\Delta x = L/N$, using the given time step $\\Delta t$. Use periodic boundary conditions implemented via periodic indexing. The discrete solution should be advanced using the explicit scheme from Part 1. If the final time $T$ is not an integer multiple of $\\Delta t$, use a final time step adjusted so that the total simulated time equals exactly $T$.\n\n3. For each test case, compute:\n   - The Péclet number $P_e = \\dfrac{a\\,L}{\\nu}$.\n   - A boolean flag indicating whether the sufficient monotonicity-based stability condition from Part 1 holds for the given $\\Delta t$ and $\\Delta x$.\n   - The discrete $\\ell^2$ error at time $T$ with respect to the exact solution of the advection-diffusion equation for the initial condition $u(x,0) = \\sin\\!\\left(\\frac{2\\pi m}{L}\\,x\\right)$ on $[0,L]$ with periodic boundary conditions. The exact solution is given by translation at speed $a$ and exponential decay of the Fourier mode, resulting in a function of the form $u_{\\text{exact}}(x,T) = \\exp\\!\\big(-\\nu\\,k^2\\,T\\big)\\,\\sin\\!\\big(k\\,(x - a\\,T)\\big)$ where $k = \\dfrac{2\\pi m}{L}$. The discrete $\\ell^2$ error is $\\left(\\Delta x \\sum_{j=0}^{N-1} \\big(u_j^{n_T} - u_{\\text{exact}}(x_j,T)\\big)^2\\right)^{1/2}$, where $n_T$ denotes the final time level.\n\n4. Use the following test suite, which explores different Péclet regimes and stability edge cases. Each test case is a tuple $(a,\\nu,L,N,\\Delta t,T,m)$, with $a$ in meters per second, $\\nu$ in square meters per second, $L$ in meters, $N$ an integer number of grid points, $\\Delta t$ in seconds, $T$ in seconds, and $m$ as a positive integer:\n   - Test $1$: $(1.0,\\,0.1,\\,1.0,\\,100,\\,4\\times 10^{-4},\\,2\\times 10^{-2},\\,1)$.\n   - Test $2$: $(0.2,\\,0.5,\\,1.0,\\,100,\\,8\\times 10^{-5},\\,2\\times 10^{-2},\\,1)$.\n   - Test $3$: $(5.0,\\,0.01,\\,1.0,\\,100,\\,1.4\\times 10^{-3},\\,2\\times 10^{-2},\\,1)$.\n   - Test $4$: $(1.0,\\,0.1,\\,1.0,\\,100,\\,\\Delta t^*,\\,2\\times 10^{-2},\\,1)$ where $\\Delta t^* = \\left(\\dfrac{a}{\\Delta x} + \\dfrac{2\\,\\nu}{\\Delta x^2}\\right)^{-1}$ with $\\Delta x = L/N$.\n   - Test $5$: $(1.0,\\,0.1,\\,1.0,\\,100,\\,6\\times 10^{-4},\\,2\\times 10^{-2},\\,1)$.\n   - Test $6$: $(-1.0,\\,0.05,\\,1.0,\\,100,\\,0.9\\times\\left(\\dfrac{|a|}{\\Delta x} + \\dfrac{2\\,\\nu}{\\Delta x^2}\\right)^{-1},\\,2\\times 10^{-2},\\,1)$ with $\\Delta x = L/N$.\n\n5. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result should itself be a list of three elements in the order $[P_e,\\text{stability\\_flag},\\ell^2\\text{\\_error}]$. For example, the output format should be exactly like $[[P_{e,1},\\text{flag}_1,\\text{err}_1],[P_{e,2},\\text{flag}_2,\\text{err}_2],\\dots]$.\n\nEnsure numerical soundness and scientific realism. The derivation must begin from the definitions of spatial finite differences on a uniform grid and forward Euler time integration and must not assume or quote any pre-derived discretization or stability formula. The connection between the Péclet number and the observed regimes should follow from definitions and the resulting discrete scheme. The final outputs are unit-free real numbers and booleans, expressed as fundamental types.", "solution": "The problem is valid. It is a well-posed initial-boundary value problem from the field of numerical analysis, specifically concerning the discretization of partial differential equations. All parameters are clearly defined, and the tasks are specific and formalizable.\n\nHere is the derivation of the numerical scheme and the stability analysis as requested.\n\nThe governing partial differential equation (PDE) is the linear advection-diffusion equation:\n$$ u_t + a\\,u_x = \\nu\\,u_{xx} $$\nwhere $u(x,t)$ is the quantity of interest, $a$ is the constant advection speed, and $\\nu$ is the constant diffusion coefficient. The spatial domain is $x \\in [0,L]$ with periodic boundary conditions, and the time domain is $t \\ge 0$.\n\nWe discretize this equation on a uniform spatio-temporal grid. The spatial grid points are $x_j = j\\,\\Delta x$ for $j=0, 1, \\dots, N-1$, where $\\Delta x = L/N$. The time levels are $t^n = n\\,\\Delta t$ for $n=0, 1, \\dots$. The numerical solution at $(x_j, t^n)$ is denoted by $u_j^n$.\n\nWe use the forward Euler method for time integration. The time derivative $u_t$ at $(x_j, t^n)$ is approximated by a forward difference:\n$$ u_t \\approx \\frac{u_j^{n+1} - u_j^n}{\\Delta t} $$\nSubstituting this into the PDE, we obtain an explicit update scheme:\n$$ \\frac{u_j^{n+1} - u_j^n}{\\Delta t} = -a\\,(u_x)_j^n + \\nu\\,(u_{xx})_j^n $$\n$$ u_j^{n+1} = u_j^n - a\\,\\Delta t\\,(u_x)_j^n + \\nu\\,\\Delta t\\,(u_{xx})_j^n $$\nHere, $(u_x)_j^n$ and $(u_{xx})_j^n$ are spatial difference approximations at time level $n$.\n\nThe diffusion term $\\nu\\,u_{xx}$ is discretized using a standard second-order central difference stencil:\n$$ (u_{xx})_j^n \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} $$\n\nThe advection term $a\\,u_x$ is discretized using a first-order upwind scheme. The choice of the one-sided difference depends on the sign of the advection speed $a$, which determines the direction of information propagation.\n1.  If $a  0$, the \"wind\" or information travels from left to right (increasing $x$). Thus, we use a backward difference, which uses the point \"upwind\" at $x_{j-1}$:\n    $$ (u_x)_j^n \\approx \\frac{u_j^n - u_{j-1}^n}{\\Delta x} \\quad (\\text{for } a  0) $$\n2.  If $a  0$, the wind travels from right to left (decreasing $x$). We use a forward difference, which uses the point \"upwind\" at $x_{j+1}$:\n    $$ (u_x)_j^n \\approx \\frac{u_{j+1}^n - u_j^n}{\\Delta x} \\quad (\\text{for } a  0) $$\nIf $a=0$, the advection term vanishes, and the choice of scheme is irrelevant. For completeness, we can include this case in either of the above.\n\nLet's construct the fully discrete update formula for both cases.\n\n**Case 1: $a \\ge 0$**\nSubstituting the backward difference for $u_x$ and central difference for $u_{xx}$ into the forward Euler formula:\n$$ u_j^{n+1} = u_j^n - a\\,\\Delta t\\left(\\frac{u_j^n - u_{j-1}^n}{\\Delta x}\\right) + \\nu\\,\\Delta t\\left(\\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}\\right) $$\nWe group terms by their spatial index at time level $n$:\n$$ u_j^{n+1} = \\left(\\frac{a\\,\\Delta t}{\\Delta x} + \\frac{\\nu\\,\\Delta t}{(\\Delta x)^2}\\right) u_{j-1}^n + \\left(1 - \\frac{a\\,\\Delta t}{\\Delta x} - \\frac{2\\nu\\,\\Delta t}{(\\Delta x)^2}\\right) u_j^n + \\left(\\frac{\\nu\\,\\Delta t}{(\\Delta x)^2}\\right) u_{j+1}^n $$\nLet us define the dimensionless Courant number $C = \\frac{a\\,\\Delta t}{\\Delta x}$ and the diffusion number $d = \\frac{\\nu\\,\\Delta t}{(\\Delta x)^2}$. Since $a \\ge 0$, $C$ is non-negative.\nThe update scheme becomes:\n$$ u_j^{n+1} = (C+d) u_{j-1}^n + (1 - C - 2d) u_j^n + d u_{j+1}^n $$\n\n**Case 2: $a  0$**\nSubstituting the forward difference for $u_x$ and central difference for $u_{xx}$:\n$$ u_j^{n+1} = u_j^n - a\\,\\Delta t\\left(\\frac{u_{j+1}^n - u_j^n}{\\Delta x}\\right) + \\nu\\,\\Delta t\\left(\\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}\\right) $$\nGrouping terms:\n$$ u_j^{n+1} = \\left(\\frac{\\nu\\,\\Delta t}{(\\Delta x)^2}\\right) u_{j-1}^n + \\left(1 + \\frac{a\\,\\Delta t}{\\Delta x} - \\frac{2\\nu\\,\\Delta t}{(\\Delta x)^2}\\right) u_j^n + \\left(-\\frac{a\\,\\Delta t}{\\Delta x} + \\frac{\\nu\\,\\Delta t}{(\\Delta x)^2}\\right) u_{j+1}^n $$\nLet us define the Courant number based on the speed, $C = \\frac{|a|\\,\\Delta t}{\\Delta x} = \\frac{-a\\,\\Delta t}{\\Delta x}$ (since $a0$), and the diffusion number $d = \\frac{\\nu\\,\\Delta t}{(\\Delta x)^2}$.\nThe update scheme becomes:\n$$ u_j^{n+1} = d u_{j-1}^n + (1 - C - 2d) u_j^n + (C+d) u_{j+1}^n $$\n\n**Monotonicity-Based Stability Condition**\nA sufficient condition for the stability of this explicit scheme is that it is monotone, which means that the new value $u_j^{n+1}$ is a convex combination of the old values. This requires all coefficients multiplying $u_{j-1}^n$, $u_j^n$, and $u_{j+1}^n$ to be non-negative.\n\nIn both cases ($a \\ge 0$ and $a  0$), the coefficients are $(C+d)$, $(1-C-2d)$, and $d$, where $C = \\frac{|a|\\Delta t}{\\Delta x}$ and $d = \\frac{\\nu \\Delta t}{(\\Delta x)^2}$.\n- The coefficients $d$ and $C+d$ are non-negative since $\\Delta t, \\Delta x, \\nu$ are non-negative and $C$ is defined with $|a|$.\n- The non-negativity of the coefficient of $u_j^n$ provides the stability constraint:\n$$ 1 - C - 2d \\ge 0 $$\nSubstituting the definitions of $C$ and $d$:\n$$ 1 - \\frac{|a|\\,\\Delta t}{\\Delta x} - \\frac{2\\nu\\,\\Delta t}{(\\Delta x)^2} \\ge 0 $$\nFactoring out $\\Delta t$:\n$$ 1 \\ge \\Delta t \\left( \\frac{|a|}{\\Delta x} + \\frac{2\\nu}{(\\Delta x)^2} \\right) $$\nThis gives the sufficient stability condition for the time step $\\Delta t$:\n$$ \\Delta t \\le \\frac{1}{\\frac{|a|}{\\Delta x} + \\frac{2\\nu}{(\\Delta x)^2}} $$\nThis condition ensures that the numerical scheme is monotone and, by the maximum principle, stable. It combines the Courant-Friedrichs-Lewy (CFL) condition for both the hyperbolic (advection) part and the parabolic (diffusion) part of the equation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the advection-diffusion problem for a suite of test cases.\n\n    This function implements an explicit finite difference scheme (upwind for\n    advection, central for diffusion, forward Euler in time) to solve the\n    1D linear advection-diffusion equation on a periodic domain. It then\n    computes the Péclet number, checks a sufficient stability condition, and\n    calculates the L2 error against the exact solution for several test cases.\n    \"\"\"\n\n    # Pre-calculate dt for cases 4 and 6, as they depend on other parameters.\n    # Case 4 parameters: a=1.0, nu=0.1, L=1.0, N=100\n    dx4 = 1.0 / 100\n    dt_star4 = (1.0 / dx4 + 2 * 0.1 / dx4**2)**-1\n\n    # Case 6 parameters: a=-1.0, nu=0.05, L=1.0, N=100\n    dx6 = 1.0 / 100\n    dt_crit6 = (abs(-1.0) / dx6 + 2 * 0.05 / dx6**2)**-1\n    dt6 = 0.9 * dt_crit6\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (a, nu, L, N, dt, T, m)\n    test_cases = [\n        (1.0, 0.1, 1.0, 100, 4e-4, 2e-2, 1),\n        (0.2, 0.5, 1.0, 100, 8e-5, 2e-2, 1),\n        (5.0, 0.01, 1.0, 100, 1.4e-3, 2e-2, 1),\n        (1.0, 0.1, 1.0, 100, dt_star4, 2e-2, 1),\n        (1.0, 0.1, 1.0, 100, 6e-4, 2e-2, 1),\n        (-1.0, 0.05, 1.0, 100, dt6, 2e-2, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, nu, L, N, dt, T, m = case\n        dx = L / N\n\n        # 1. Compute Péclet number\n        # If nu is zero, Pe is infinite. Handle this to avoid division by zero.\n        if nu == 0:\n            Pe = np.inf * np.sign(a) if a != 0 else 0\n        else:\n            Pe = a * L / nu\n\n        # 2. Check the sufficient monotonicity-based stability condition\n        # The condition is dt = 1 / ( |a|/dx + 2*nu/dx^2 )\n        # Rearranged to avoid division by a potentially zero denominator:\n        # dt * ( |a|/dx + 2*nu/dx^2 ) = 1\n        stability_term = abs(a) / dx + 2 * nu / dx**2\n        # Use a small tolerance for floating point comparison\n        is_stable = dt * stability_term = 1.0 + 1e-9\n\n        # 3. Set up the grid and initial condition\n        x = np.linspace(0, L, N, endpoint=False)\n        k = 2 * np.pi * m / L\n        u = np.sin(k * x)\n\n        # 4. Define the time-stepping function\n        def step(u_current, time_step):\n            \"\"\"Applies one step of the finite difference scheme.\"\"\"\n            u_jp1 = np.roll(u_current, -1)\n            u_jm1 = np.roll(u_current, 1)\n\n            # Upwind scheme for advection\n            if a = 0:\n                advection_term = (a * time_step / dx) * (u_current - u_jm1)\n            else: # a  0\n                advection_term = (a * time_step / dx) * (u_jp1 - u_current)\n            \n            # Central difference for diffusion\n            diffusion_term = (nu * time_step / dx**2) * (u_jp1 - 2 * u_current + u_jm1)\n            \n            return u_current - advection_term + diffusion_term\n\n        # 5. Evolve the solution in time\n        num_full_steps = int(T / dt)\n        \n        for _ in range(num_full_steps):\n            u = step(u, dt)\n        \n        # Adjust for a final partial time step to reach T exactly\n        last_dt = T - num_full_steps * dt\n        if last_dt  1e-12: # Check to avoid negligible or negative steps\n            u = step(u, last_dt)\n        \n        u_numerical = u\n\n        # 6. Compute the exact solution and the discrete l2 error\n        u_exact = np.exp(-nu * k**2 * T) * np.sin(k * (x - a * T))\n        l2_error = np.sqrt(dx * np.sum((u_numerical - u_exact)**2))\n\n        # 7. Store the results for this test case\n        results.append([Pe, is_stable, l2_error])\n\n    # 8. Format and print the final output string\n    # Build the string manually to match the required format without extra spaces\n    output_parts = []\n    for pe_val, flag_val, err_val in results:\n        # Format the numbers to a reasonable precision for clean output\n        pe_str = f\"{pe_val:.10g}\"\n        err_str = f\"{err_val:.10g}\"\n        flag_str = str(flag_val).lower()\n        output_parts.append(f\"[{pe_str},{flag_str},{err_str}]\")\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3285468"}]}