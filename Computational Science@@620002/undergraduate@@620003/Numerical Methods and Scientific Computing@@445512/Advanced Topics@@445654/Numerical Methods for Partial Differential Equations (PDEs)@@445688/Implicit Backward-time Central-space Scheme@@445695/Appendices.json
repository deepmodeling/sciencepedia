{"hands_on_practices": [{"introduction": "Before deploying a numerical method, it is crucial to verify that its implementation is correct. This practice introduces the Method of Manufactured Solutions, a powerful technique to test code against a problem with a known exact solution. By systematically refining the grid, you will empirically measure the convergence rates of the BTCS scheme, confirming that it achieves its theoretical first-order accuracy in time ($O(\\Delta t)$) and second-order accuracy in space ($O((\\Delta x)^2)$). [@problem_id:3241236]", "problem": "Consider the one-dimensional heat conduction model defined on the spatial interval $[0,1]$ and time interval $[0,T]$,\n$$\n\\frac{\\partial u}{\\partial t}(x,t) \\;=\\; \\alpha \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t) \\;+\\; f(x,t),\n$$\nwith Dirichlet boundary conditions $u(0,t)=0$ and $u(1,t)=0$ for all $t \\in [0,T]$, and initial condition $u(x,0)=\\sin(\\pi x)$. Use the method of manufactured solutions to verify the accuracy of the Implicit Backward-Time Central-Space (BTCS) scheme, formally known as the Backward-Time Central-Space (BTCS) scheme.\n\nYou will start from the following fundamental bases:\n- The definition of the heat equation and central finite differences: for a sufficiently smooth function $u$, the spatial second derivative is approximated by\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i,t) \\approx \\frac{u(x_{i-1},t) - 2u(x_i,t) + u(x_{i+1},t)}{(\\Delta x)^2},\n$$\nand the backward Euler time derivative is\n$$\n\\frac{\\partial u}{\\partial t}(x_i,t_{n+1}) \\approx \\frac{u(x_i,t_{n+1}) - u(x_i,t_n)}{\\Delta t}.\n$$\n- The method of manufactured solutions: choose a smooth function $\\tilde{u}(x,t)$, substitute it into the partial differential equation, and define $f(x,t)$ so that $\\tilde{u}(x,t)$ becomes the exact solution to the forced problem.\n\nTask:\n1. Choose the manufactured solution $\\tilde{u}(x,t)=e^{t}\\sin(\\pi x)$ and, using calculus, derive the corresponding source term $f(x,t)$ so that $\\tilde{u}(x,t)$ exactly satisfies the model equation.\n2. Discretize the spatial domain with grid points $x_i = i\\,\\Delta x$ for $i=0,1,\\dots,N_x-1$, where $\\Delta x = 1/(N_x-1)$, and the time domain with time levels $t_n = n\\,\\Delta t$ for $n=0,1,\\dots,N_t$. Impose the Dirichlet boundary conditions $u_0^n = 0$ and $u_{N_x-1}^n=0$ for all $n$, and the initial condition $u_i^0 = \\sin(\\pi x_i)$ for $i=1,\\dots,N_x-2$.\n3. Derive and implement the BTCS linear system at each time step $t_{n+1}$ for the interior nodes $i=1,\\dots,N_x-2$ by combining the backward Euler time approximation and the central spatial approximation, and using the source $f$ evaluated at time $t_{n+1}$.\n4. Advance the solution from $t=0$ to $t=T$ by solving the resulting tridiagonal linear system at each time step. Compute the error at the final time $t=T$ by comparing the numerical solution $u_i^{N_t}$ with the exact $\\tilde{u}(x_i,T)$ using the discrete $L^2$ norm\n$$\nE_{L^2} \\;=\\; \\left(\\Delta x\\sum_{i=1}^{N_x-2}\\left(u_i^{N_t}-\\tilde{u}(x_i,T)\\right)^2\\right)^{1/2}\n$$\nand the discrete $L^\\infty$ norm\n$$\nE_{L^\\infty} \\;=\\; \\max_{1\\le i \\le N_x-2}\\left|u_i^{N_t}-\\tilde{u}(x_i,T)\\right|.\n$$\n\nEmpirical convergence verification:\n- To verify the time accuracy order $O(\\Delta t)$, use a very fine spatial grid to make the spatial error negligible and perform a time refinement study. Fix $\\alpha=0.1$, set $T=0.2$, choose $N_x=1001$, and run the BTCS scheme for the four time step counts $N_t\\in\\{10,20,40,80\\}$, corresponding to $\\Delta t\\in\\{0.02,0.01,0.005,0.0025\\}$. For each run, compute $E_{L^2}$ at $t=T$. Estimate the observed time-convergence order $p_t$ by fitting a line to $(\\log(\\Delta t),\\log(E_{L^2}))$ via least squares and taking the slope.\n- To verify the spatial accuracy order $O((\\Delta x)^2)$, use a very small time step to make the time error negligible and perform a spatial refinement study. Fix $\\alpha=0.1$, set $T=0.01$, choose $N_t=1000$ (so $\\Delta t=0.00001$), and run the BTCS scheme for $N_x\\in\\{33,65,129,257\\}$, corresponding to spatial steps halved each refinement. For each run, compute $E_{L^2}$ at $t=T$. Estimate the observed spatial-convergence order $p_x$ by fitting a line to $(\\log(\\Delta x),\\log(E_{L^2}))$ via least squares and taking the slope.\n- Edge case robustness check: test with a very coarse grid to ensure the linear system assembly and boundary handling are correct. Fix $\\alpha=0.1$, set $T=0.1$, choose $N_x=5$, and $N_t=5$ (so $\\Delta t=0.02$). Compute the final-time discrete infinity-norm error $E_{L^\\infty}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order $[p_t,p_x,E_{L^\\infty}]$. All three entries must be real numbers. No additional text should be printed.\n\nTest suite summary:\n- Time refinement (expected $O(\\Delta t)$): $\\alpha=0.1$, $T=0.2$, $N_x=1001$, $N_t\\in\\{10,20,40,80\\}$.\n- Space refinement (expected $O((\\Delta x)^2)$): $\\alpha=0.1$, $T=0.01$, $N_t=1000$, $N_x\\in\\{33,65,129,257\\}$.\n- Edge case: $\\alpha=0.1$, $T=0.1$, $N_x=5$, $N_t=5$.\n\nAll quantities are dimensionless; no physical units are required.", "solution": "The problem requires the derivation, implementation, and verification of the Backward-Time Central-Space (BTCS) scheme for the one-dimensional heat equation using the method of manufactured solutions. The solution is presented in four parts: derivation of the analytical source term, derivation of the discrete numerical scheme, an outline of the empirical verification process, and a summary of the algorithm.\n\n**Step 1: Derivation of the Source Term**\n\nThe method of manufactured solutions is employed to create a problem with a known analytical solution, which serves as a benchmark for verifying the numerical code. The governing partial differential equation (PDE) is:\n$$\n\\frac{\\partial u}{\\partial t}(x,t) \\;=\\; \\alpha \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t) \\;+\\; f(x,t)\n$$\nWe choose the manufactured solution $\\tilde{u}(x,t) = e^{t}\\sin(\\pi x)$. This function satisfies the boundary conditions $u(0,t)=e^t\\sin(0)=0$ and $u(1,t)=e^t\\sin(\\pi)=0$, and the initial condition $u(x,0)=e^0\\sin(\\pi x)=\\sin(\\pi x)$. To find the corresponding source term $f(x,t)$, we compute the partial derivatives of $\\tilde{u}(x,t)$:\nThe time derivative is:\n$$\n\\frac{\\partial \\tilde{u}}{\\partial t} = \\frac{\\partial}{\\partial t} \\left( e^t \\sin(\\pi x) \\right) = e^t \\sin(\\pi x)\n$$\nThe second spatial derivative is:\n$$\n\\frac{\\partial^2 \\tilde{u}}{\\partial x^2} = \\frac{\\partial^2}{\\partial x^2} \\left( e^t \\sin(\\pi x) \\right) = \\frac{\\partial}{\\partial x} \\left( \\pi e^t \\cos(\\pi x) \\right) = -\\pi^2 e^t \\sin(\\pi x)\n$$\nSubstituting these into the PDE allows us to solve for $f(x,t)$:\n$$\ne^t \\sin(\\pi x) = \\alpha \\left( -\\pi^2 e^t \\sin(\\pi x) \\right) + f(x,t)\n$$\n$$\nf(x,t) = e^t \\sin(\\pi x) + \\alpha \\pi^2 e^t \\sin(\\pi x) = (1 + \\alpha \\pi^2)e^t \\sin(\\pi x)\n$$\nThis derived source term ensures that $\\tilde{u}(x,t)$ is the exact solution to the problem.\n\n**Step 2: Derivation of the BTCS Discretization**\n\nThe BTCS scheme is formulated by discretizing the PDE on a grid with spatial points $x_i = i\\Delta x$ and time levels $t_n = n\\Delta t$. We approximate the time derivative using a first-order backward Euler difference and the spatial derivative using a second-order central difference, both evaluated at the future time level $t_{n+1}$:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} \\approx \\alpha \\left( \\frac{u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}}{(\\Delta x)^2} \\right) + f(x_i, t_{n+1})\n$$\nwhere $u_i^n \\approx u(x_i, t_n)$. This scheme is implicit, as it couples several unknown values at the time level $n+1$. To solve it, we rearrange the equation into a linear system. Let $c = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$ be the diffusion number. We group all unknown terms (at time $n+1$) on the left-hand side (LHS) and known terms (at time $n$) on the right-hand side (RHS):\n$$\nu_i^{n+1} - c (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}) = u_i^n + \\Delta t f_i^{n+1}\n$$\n$$\n-c u_{i-1}^{n+1} + (1 + 2c)u_i^{n+1} - c u_{i+1}^{n+1} = u_i^n + \\Delta t f_i^{n+1}\n$$\nThis equation is valid for all interior grid points, $i = 1, 2, \\dots, N_x-2$. Given the Dirichlet boundary conditions $u_0^{n+1}=0$ and $u_{N_x-1}^{n+1}=0$, these equations form a tridiagonal linear system $A \\mathbf{u}^{n+1} = \\mathbf{b}^n$ for the vector of interior unknowns $\\mathbf{u}^{n+1} = [u_1^{n+1}, \\dots, u_{N_x-2}^{n+1}]^T$. The $(N_x-2) \\times (N_x-2)$ matrix $A$ is:\n$$\nA = \\begin{pmatrix}\n1+2c & -c & 0 & \\dots & 0 \\\\\n-c & 1+2c & -c & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots & \\ddots & -c & 1+2c & -c \\\\\n0 & \\dots & 0 & -c & 1+2c\n\\end{pmatrix}\n$$\nThe RHS vector $\\mathbf{b}^n$ depends on the solution at the previous time step $n$ and the source term at step $n+1$. At each time step, this system must be solved to find the solution at the next time level.\n\n**Step 3: Empirical Convergence Verification**\n\nThe theoretical accuracy of the BTCS scheme is $O(\\Delta t)$ in time and $O((\\Delta x)^2)$ in space. The total error $E$ is approximately $E \\approx C_t (\\Delta t)^{p_t} + C_x (\\Delta x)^{p_x}$, where $p_t=1$ and $p_x=2$ are the convergence orders.\nTo empirically measure $p_t$, a time-refinement study is conducted. By using a very fine spatial grid ($N_x=1001$), the spatial error term $C_x (\\Delta x)^2$ becomes negligible. The error is then dominated by the time discretization, $E \\approx C_t (\\Delta t)^{p_t}$. Taking the logarithm gives $\\log(E) \\approx \\log(C_t) + p_t \\log(\\Delta t)$. The order $p_t$ is the slope of the line fitted to the $(\\log(\\Delta t), \\log(E))$ data points.\nSimilarly, to measure $p_x$, a spatial-refinement study is performed. By using a very small time step ($N_t=1000$), the temporal error term $C_t (\\Delta t)^{p_t}$ becomes negligible, so $E \\approx C_x (\\Delta x)^{p_x}$. The order $p_x$ is then the slope of the line fitted to the $(\\log(\\Delta x), \\log(E))$ data.\n\n**Step 4: Algorithmic Implementation**\n\nThe numerical solution is computed as follows:\n1.  Initialize parameters $\\alpha$, $T$, $N_x$, $N_t$ and calculate grid spacings $\\Delta x$ and $\\Delta t$.\n2.  Set up the spatial grid $x$ and initialize the solution vector $u$ using the initial condition $u(x,0)=\\sin(\\pi x)$.\n3.  Construct the constant tridiagonal matrix $A$ for the given parameters.\n4.  Iterate from $n=0$ to $N_t-1$. In each iteration:\n    a. Calculate the next time level $t_{n+1}$.\n    b. Assemble the RHS vector $\\mathbf{b}^n$ using the solution from the previous step, $u^n$, and the source term $f(x,t_{n+1})$.\n    c. Solve the linear system $A \\mathbf{u}^{n+1} = \\mathbf{b}^n$ to get the solution at the interior points for the next time step.\n    d. Update the full solution vector, keeping the boundary values at $0$.\n5.  After the loop, compute the final error at $t=T$ using either the $L^2$ or $L^\\infty$ norm as required by comparing the final numerical solution to the exact manufactured solution.\n6.  For the convergence studies, repeat this process for each set of refinement parameters, collect the errors, and perform a linear least-squares fit on the log-log data to find the slopes $p_t$ and $p_x$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_btcs_and_get_error(alpha, T, Nx, Nt, error_norm_type):\n    \"\"\"\n    Runs the BTCS simulation for the 1D heat equation with a source term\n    and returns the specified error norm against the manufactured solution.\n\n    Args:\n        alpha (float): Thermal diffusivity constant.\n        T (float): Final time.\n        Nx (int): Number of spatial grid points.\n        Nt (int): Number of time steps.\n        error_norm_type (str): Type of error norm to compute ('L2' or 'L_inf').\n\n    Returns:\n        float: The computed error value.\n    \"\"\"\n    # Define the manufactured solution and the corresponding source term\n    def u_exact(x, t):\n        return np.exp(t) * np.sin(np.pi * x)\n\n    def f_source(x, t, alpha_val):\n        return (1.0 + alpha_val * np.pi**2) * np.exp(t) * np.sin(np.pi * x)\n\n    # Discretization parameters\n    dx = 1.0 / (Nx - 1)\n    dt = T / Nt\n    x = np.linspace(0, 1, Nx)\n    \n    # Grid for interior points\n    x_interior = x[1:-1]\n    M = Nx - 2  # Number of interior points\n\n    # Diffusion number\n    c = alpha * dt / (dx**2)\n\n    # Initial condition. The vector u_current includes boundary points.\n    u_current = u_exact(x, 0.0)\n    \n    # Construct the tridiagonal matrix A for a single time step.\n    # The matrix is constant for fixed parameters.\n    A = np.zeros((M, M))\n    np.fill_diagonal(A, 1.0 + 2.0 * c)\n    np.fill_diagonal(A[1:], -c)\n    np.fill_diagonal(A[:, 1:], -c)\n\n    # Time-stepping loop\n    for n in range(Nt):\n        t_next = (n + 1) * dt\n        \n        # Get the solution at interior points from the previous time step\n        u_current_interior = u_current[1:-1]\n        \n        # Construct the RHS vector b = u_current_interior + dt * f(t_next)\n        f_vec = f_source(x_interior, t_next, alpha)\n        b = u_current_interior + dt * f_vec\n        \n        # Dirichlet boundary conditions u(0,t)=0 and u(1,t)=0 are handled implicitly\n        # because the terms involving u_0 and u_{Nx-1} are zero and do not\n        # contribute to the RHS vector for the interior problem.\n        \n        # Solve the linear system A * u_next_interior = b\n        u_next_interior = np.linalg.solve(A, b)\n        \n        # Update solution vector for the next time step. Boundaries remain zero.\n        u_current[1:-1] = u_next_interior\n        \n    # At t=T, u_current holds the final numerical solution\n    u_numerical_final = u_current\n    \n    # Calculate the exact solution at the final time T\n    u_exact_final = u_exact(x, T)\n\n    # Calculate the error vector at interior points\n    error_vec = u_numerical_final[1:-1] - u_exact_final[1:-1]\n    \n    # Compute the requested error norm\n    if error_norm_type == 'L2':\n        error_val = np.sqrt(dx * np.sum(error_vec**2))\n    elif error_norm_type == 'L_inf':\n        error_val = np.max(np.abs(error_vec))\n    else:\n        raise ValueError(\"Invalid error_norm_type specified.\")\n        \n    return error_val\n\ndef solve():\n    \"\"\"\n    Performs the three specified tasks: time refinement, space refinement,\n    and an edge case test, printing the results in the required format.\n    \"\"\"\n    # --- Task 1: Time refinement study to find p_t ---\n    alpha_t = 0.1\n    T_t = 0.2\n    Nx_t = 1001\n    Nt_t_vals = [10, 20, 40, 80]\n    \n    dt_vals = [T_t / N for N in Nt_t_vals]\n    errors_t = []\n    for Nt_t in Nt_t_vals:\n        error = run_btcs_and_get_error(alpha_t, T_t, Nx_t, Nt_t, 'L2')\n        errors_t.append(error)\n        \n    # Fit a line to (log(dt), log(error)) to find the convergence order p_t\n    log_dt = np.log(dt_vals)\n    log_errors_t = np.log(errors_t)\n    p_t = np.polyfit(log_dt, log_errors_t, 1)[0]\n\n    # --- Task 2: Spatial refinement study to find p_x ---\n    alpha_x = 0.1\n    T_x = 0.01\n    Nt_x = 1000\n    Nx_x_vals = [33, 65, 129, 257]\n    \n    dx_vals = [1.0 / (N - 1) for N in Nx_x_vals]\n    errors_x = []\n    for Nx_x in Nx_x_vals:\n        error = run_btcs_and_get_error(alpha_x, T_x, Nx_x, Nt_x, 'L2')\n        errors_x.append(error)\n        \n    # Fit a line to (log(dx), log(error)) to find the convergence order p_x\n    log_dx = np.log(dx_vals)\n    log_errors_x = np.log(errors_x)\n    p_x = np.polyfit(log_dx, log_errors_x, 1)[0]\n\n    # --- Task 3: Edge case robustness check ---\n    alpha_e = 0.1\n    T_e = 0.1\n    Nx_e = 5\n    Nt_e = 5\n    E_Linf = run_btcs_and_get_error(alpha_e, T_e, Nx_e, Nt_e, 'L_inf')\n\n    # Final print statement in the exact required format\n    print(f\"[{p_t},{p_x},{E_Linf}]\")\n\nsolve()\n```", "id": "3241236"}, {"introduction": "Real-world physical systems are described by a variety of boundary interactions, from fixed values (Dirichlet conditions) to specified rates of change (Neumann conditions). A robust numerical solver must be able to accommodate these different scenarios. This exercise guides you through the process of deriving and implementing the BTCS scheme for all combinations of Dirichlet and Neumann boundary conditions, building a flexible and powerful simulation tool. [@problem_id:3241116]", "problem": "You are to design and implement a program that solves the one-dimensional diffusion equation using the implicit backward-time central-space (BTCS) scheme while flexibly switching between Dirichlet and Neumann boundary conditions on either boundary, controlled by a configuration object. The governing partial differential equation is the linear parabolic model on a bounded interval,\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in [0,L], \\ t \\in (0,T],\n$$\nwhere $u=u(x,t)$ is the scalar field of interest and $\\alpha>0$ is the diffusivity. The initial condition is\n$$\nu(x,0)=u_0(x), \\quad x \\in [0,L],\n$$\nand each boundary at $x=0$ and $x=L$ independently satisfies either a Dirichlet condition,\n$$\nu(0,t)=g_L(t) \\ \\text{or} \\ u(L,t)=g_R(t),\n$$\nor a Neumann condition,\n$$\n\\frac{\\partial u}{\\partial x}(0,t)=q_L(t) \\ \\text{or} \\ \\frac{\\partial u}{\\partial x}(L,t)=q_R(t).\n$$\nYour discretization must start from the following fundamental base: (i) the definition of the time derivative as a backward difference in time over a uniform time grid of step size $\\Delta t$, (ii) the definition of the second spatial derivative as a central second difference over a uniform spatial grid with mesh spacing $\\Delta x$, and (iii) the precise meaning of Dirichlet and Neumann boundary conditions. You may assume smoothness sufficient for second-order spatial accuracy and first-order temporal accuracy. Do not assume or use any formula not derivable from these bases.\n\nYou must derive and implement a fully implicit scheme consistent with the backward difference in time and the central difference in space at interior grid points. At boundaries, impose the Dirichlet or Neumann conditions in a way that is consistent with the same order of accuracy as the interior discretization, without introducing ghost unknowns in the final linear system. Your derivation must show clearly how boundary equations differ from interior equations and how boundary data $g_L(t)$, $g_R(t)$, $q_L(t)$, $q_R(t)$ enter the right-hand side. Use a uniform spatial mesh of $M$ nodes on $[0,L]$ (that is, $M$ includes both boundary nodes), so that $\\Delta x = L/(M-1)$. Use a uniform time step $\\Delta t$ and advance from time $t^n=n\\Delta t$ to $t^{n+1}=(n+1)\\Delta t$.\n\nYour program must:\n- Build a single linear system per time step for the vector of all nodal unknowns at time $t^{n+1}$, with coefficients determined by the BTCS discretization and the boundary condition types on the left and right ends.\n- Allow either boundary to be Dirichlet or Neumann, with corresponding data functions $g_L(t)$, $g_R(t)$, $q_L(t)$, $q_R(t)$ evaluated at $t^{n+1}$.\n- Accept a configuration-like data structure (hard-coded within your program; no files or external input are allowed) specifying $L$, $\\alpha$, $M$, $\\Delta t$, $T$, boundary condition types and data, and the initial condition function $u_0(x)$.\n- For verification, use manufactured exact solutions $u_{\\text{exact}}(x,t)$ for which both the interior equation and the chosen boundary conditions hold for all $t\\in[0,T]$. Initialize with $u_0(x)=u_{\\text{exact}}(x,0)$.\n\nTest suite. Implement and run the following five test cases, each specified by a configuration object inside your program. In every case, take the diffusivity $\\alpha=1$ unless otherwise stated, and report the maximum absolute error at the final time $T$ between the numerical and exact solutions over all grid nodes. The five cases are:\n- Case $1$ (Dirichlet–Dirichlet, homogeneous, sine mode): $L=\\pi$, $M=101$, $\\Delta t=5\\times 10^{-4}$, $T=5\\times 10^{-2}$, left boundary Dirichlet with $g_L(t)=0$, right boundary Dirichlet with $g_R(t)=0$, exact solution $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\sin(\\lambda x)$ with $\\lambda=1$.\n- Case $2$ (Neumann–Neumann, homogeneous, cosine mode): $L=\\pi$, $M=101$, $\\Delta t=5\\times 10^{-4}$, $T=5\\times 10^{-2}$, left boundary Neumann with $q_L(t)=0$, right boundary Neumann with $q_R(t)=0$, exact solution $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\cos(\\lambda x)$ with $\\lambda=1$.\n- Case $3$ (Dirichlet–Neumann, homogeneous, half-integer sine mode): $L=\\pi$, $M=101$, $\\Delta t=5\\times 10^{-4}$, $T=5\\times 10^{-2}$, left boundary Dirichlet with $g_L(t)=0$, right boundary Neumann with $q_R(t)=0$, exact solution $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\sin(\\lambda x)$ with $\\lambda=\\tfrac{1}{2}$.\n- Case $4$ (Neumann–Dirichlet, homogeneous, half-integer cosine mode): $L=\\pi$, $M=101$, $\\Delta t=5\\times 10^{-4}$, $T=5\\times 10^{-2}$, left boundary Neumann with $q_L(t)=0$, right boundary Dirichlet with $g_R(t)=0$, exact solution $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\cos(\\lambda x)$ with $\\lambda=\\tfrac{1}{2}$.\n- Case $5$ (steady linear solution, mixed nonhomogeneous): $L=1$, $M=51$, $\\Delta t=10^{-2}$, $T=10^{-1}$, left boundary Dirichlet with $g_L(t)=2$, right boundary Neumann with $q_R(t)=-\\tfrac{3}{2}$, exact solution $u_{\\text{exact}}(x,t)=ax+b$ with $a=-\\tfrac{3}{2}$ and $b=2$ (time-independent).\n\nFinal output format. Your program should produce a single line of output containing the maximum absolute error at time $T$ for each of the five cases, as a comma-separated list of decimal numbers enclosed in square brackets, ordered as Cases $1$ through $5$. For example, an output for three hypothetical cases would look like\n$$\n[\\text{err}_1,\\text{err}_2,\\text{err}_3]\n$$\nbut your program must output five entries corresponding to the five cases above.", "solution": "The task is to derive and implement the implicit backward-time central-space (BTCS) scheme for the one-dimensional diffusion equation, $\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}$, on a bounded domain $x \\in [0,L]$ with options for Dirichlet or Neumann boundary conditions at each end. The derivation will proceed from first principles as specified.\n\nLet the spatial domain $[0,L]$ be discretized into a uniform grid with $M$ nodes, indexed by $i=0, 1, \\dots, M-1$. The grid points are $x_i = i\\Delta x$, where the mesh spacing is $\\Delta x = L/(M-1)$. The time domain is discretized with a uniform step size $\\Delta t$, with time levels denoted by $t^n = n\\Delta t$. The numerical approximation of the solution $u(x_i, t^n)$ is denoted by $u_i^n$.\n\nThe BTCS scheme is formulated by approximating the time derivative using a first-order backward finite difference and the spatial second derivative using a second-order central finite difference, both evaluated at the future time level $t^{n+1}$. The governing partial differential equation (PDE) is thus discretized as:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{(\\Delta x)^2}\n$$\nThis equation establishes a relationship between the known solution at time $t^n$ and the unknown solution at time $t^{n+1}$.\n\nLet's define the dimensionless parameter $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$. Rearranging the discretized equation to group the unknown terms (at level $n+1$) on the left-hand side (LHS) and known terms (at level $n$) on the right-hand side (RHS) gives the equation for an interior node $i \\in \\{1, 2, \\dots, M-2\\}$:\n$$\n-s u_{i-1}^{n+1} + (1+2s) u_i^{n+1} - s u_{i+1}^{n+1} = u_i^n\n$$\nThese equations form a system of linear equations for the unknown vector $\\mathbf{u}^{n+1} = [u_0^{n+1}, u_1^{n+1}, \\dots, u_{M-1}^{n+1}]^T$. The specific form of the first ($i=0$) and last ($i=M-1$) equations in the system depends on the boundary conditions.\n\nThe boundary conditions must be discretized with an accuracy consistent with the interior scheme, i.e., second-order in space. We will now derive the equations for each boundary without introducing ghost nodes into the final linear system.\n\n**Left Boundary ($x=0$, node $i=0$)**\n\n1.  **Dirichlet Condition**: $u(0,t) = g_L(t)$.\n    The condition is applied directly at the new time level $t^{n+1}$. The value of the unknown $u_0^{n+1}$ is explicitly given:\n    $$\n    u_0^{n+1} = g_L(t^{n+1})\n    $$\n    This translates into the first row of the linear system as $1 \\cdot u_0^{n+1} = g_L(t^{n+1})$.\n\n2.  **Neumann Condition**: $\\frac{\\partial u}{\\partial x}(0,t) = q_L(t)$.\n    To achieve second-order accuracy, we use a central difference for the spatial derivative around $x_0$. This requires a \"ghost\" node at $x_{-1} = -\\Delta x$. The derivative is approximated at $t^{n+1}$ as:\n    $$\n    \\frac{u_1^{n+1} - u_{-1}^{n+1}}{2\\Delta x} = q_L(t^{n+1})\n    $$\n    From this, we can express the ghost value $u_{-1}^{n+1}$ as $u_{-1}^{n+1} = u_1^{n+1} - 2\\Delta x q_L(t^{n+1})$. We then apply the general PDE discretization at the boundary node $i=0$:\n    $$\n    -s u_{-1}^{n+1} + (1+2s) u_0^{n+1} - s u_1^{n+1} = u_0^n\n    $$\n    Substituting the expression for $u_{-1}^{n+1}$ eliminates the ghost node:\n    $$\n    -s (u_1^{n+1} - 2\\Delta x q_L(t^{n+1})) + (1+2s) u_0^{n+1} - s u_1^{n+1} = u_0^n\n    $$\n    Grouping terms yields the final equation for the first row of the system:\n    $$\n    (1+2s) u_0^{n+1} - 2s u_1^{n+1} = u_0^n - 2s\\Delta x q_L(t^{n+1})\n    $$\n    Noting that $2s\\Delta x = 2 \\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\Delta x = \\frac{2\\alpha\\Delta t}{\\Delta x}$, the equation is $(1+2s) u_0^{n+1} - 2s u_1^{n+1} = u_0^n - \\frac{2\\alpha\\Delta t}{\\Delta x} q_L(t^{n+1})$.\n\n**Right Boundary ($x=L$, node $i=M-1$)**\n\n1.  **Dirichlet Condition**: $u(L,t) = g_R(t)$.\n    Similar to the left boundary, the condition at $t^{n+1}$ provides the value for $u_{M-1}^{n+1}$ directly:\n    $$\n    u_{M-1}^{n+1} = g_R(t^{n+1})\n    $$\n    This defines the last row of the linear system as $1 \\cdot u_{M-1}^{n+1} = g_R(t^{n+1})$.\n\n2.  **Neumann Condition**: $\\frac{\\partial u}{\\partial x}(L,t) = q_R(t)$.\n    Using a central difference around $x_{M-1}$ requires a ghost node at $x_M = L+\\Delta x$:\n    $$\n    \\frac{u_M^{n+1} - u_{M-2}^{n+1}}{2\\Delta x} = q_R(t^{n+1})\n    $$\n    This gives the ghost value as $u_M^{n+1} = u_{M-2}^{n+1} + 2\\Delta x q_R(t^{n+1})$. Applying the PDE discretization at $i=M-1$:\n    $$\n    -s u_{M-2}^{n+1} + (1+2s) u_{M-1}^{n+1} - s u_M^{n+1} = u_{M-1}^n\n    $$\n    Substituting the expression for $u_M^{n+1}$:\n    $$\n    -s u_{M-2}^{n+1} + (1+2s) u_{M-1}^{n+1} - s (u_{M-2}^{n+1} + 2\\Delta x q_R(t^{n+1})) = u_{M-1}^n\n    $$\n    Grouping terms gives the final equation for the last row of the system:\n    $$\n    -2s u_{M-2}^{n+1} + (1+2s) u_{M-1}^{n+1} = u_{M-1}^n + 2s\\Delta x q_R(t^{n+1})\n    $$\n    The term involving the boundary data is $\\frac{2\\alpha\\Delta t}{\\Delta x} q_R(t^{n+1})$.\n\n**Matrix System Formulation**\n\nAt each time step, we solve a linear system $\\mathbf{A} \\mathbf{u}^{n+1} = \\mathbf{b}$ for the vector of unknowns $\\mathbf{u}^{n+1}$. The matrix $\\mathbf{A}$ and vector $\\mathbf{b}$ are constructed as follows:\n\nLet $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$.\nThe matrix $\\mathbf{A}$ is an $M \\times M$ matrix, and $\\mathbf{b}$ is a vector of size $M$.\n\n**Interior Rows ($i = 1, \\dots, M-2$):**\n-   $A_{i,i-1} = -s$\n-   $A_{i,i} = 1+2s$\n-   $A_{i,i+1} = -s$\n-   $b_i = u_i^n$\n\n**First Row ($i=0$):**\n-   If Left BC is Dirichlet: $A_{0,0}=1$, and all other $A_{0,j}=0$. $b_0 = g_L(t^{n+1})$.\n-   If Left BC is Neumann: $A_{0,0}=1+2s$, $A_{0,1}=-2s$. $b_0 = u_0^n - \\frac{2\\alpha\\Delta t}{\\Delta x} q_L(t^{n+1})$.\n\n**Last Row ($i=M-1$):**\n-   If Right BC is Dirichlet: $A_{M-1,M-1}=1$, and all other $A_{M-1,j}=0$. $b_{M-1} = g_R(t^{n+1})$.\n-   If Right BC is Neumann: $A_{M-1,M-2}=-2s$, $A_{M-1,M-1}=1+2s$. $b_{M-1} = u_{M-1}^n + \\frac{2\\alpha\\Delta t}{\\Delta x} q_R(t^{n+1})$.\n\n**Overall Algorithm:**\n\n1.  Initialize parameters from the test case configuration.\n2.  Set up the spatial grid $x_i$ for $i=0, \\dots, M-1$.\n3.  Compute the initial solution vector $\\mathbf{u}^0$ using $u_i^0 = u_{\\text{exact}}(x_i, 0)$.\n4.  Iterate through time steps from $n=0$ until the final time $T$ is reached. In each step:\n    a. Determine the current time $t^{n+1} = (n+1)\\Delta t$.\n    b. Construct the matrix $\\mathbf{A}$ and vector $\\mathbf{b}$ according to the specified boundary conditions and the formulas derived above.\n    c. Solve the linear system $\\mathbf{A} \\mathbf{u}^{n+1} = \\mathbf{b}$ to find the solution at the new time level.\n    d. Update the solution for the next iteration: $\\mathbf{u}^n \\leftarrow \\mathbf{u}^{n+1}$.\n5.  After the final time step, compute the exact solution $\\mathbf{u}_{\\text{exact}}$ at time $T$.\n6.  Calculate the maximum absolute error between the final numerical solution and the exact solution: $\\max_i |u_i^{\\text{final}} - u_{\\text{exact}}(x_i, T)|$.\nThis process is repeated for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the BTCS diffusion solver.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Dirichlet-Dirichlet\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"dirichlet\", \"bc_right_type\": \"dirichlet\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 1**2 * t) * np.sin(1 * x)\n        },\n        # Case 2: Neumann-Neumann\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"neumann\", \"bc_right_type\": \"neumann\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 1**2 * t) * np.cos(1 * x)\n        },\n        # Case 3: Dirichlet-Neumann\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"dirichlet\", \"bc_right_type\": \"neumann\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 0.5**2 * t) * np.sin(0.5 * x)\n        },\n        # Case 4: Neumann-Dirichlet\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"neumann\", \"bc_right_type\": \"dirichlet\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 0.5**2 * t) * np.cos(0.5 * x)\n        },\n        # Case 5: Dirichlet-Neumann, non-homogeneous steady state\n        {\n            \"L\": 1.0, \"alpha\": 1.0, \"M\": 51, \"dt\": 1e-2, \"T\": 1e-1,\n            \"bc_left_type\": \"dirichlet\", \"bc_right_type\": \"neumann\",\n            \"g_L\": lambda t: 2.0, \"g_R\": lambda t: 0.0,  # g_R not used\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: -1.5, # q_L not used\n            \"u_exact\": lambda x, t, alpha: -1.5 * x + 2.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_btcs_simulation(case)\n        results.append(f\"{error:.15e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef run_btcs_simulation(params):\n    \"\"\"\n    Executes a single simulation run for the 1D diffusion equation using BTCS.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the simulation.\n\n    Returns:\n        float: The maximum absolute error at the final time T.\n    \"\"\"\n    # Unpack parameters\n    L = params[\"L\"]\n    alpha = params[\"alpha\"]\n    M = params[\"M\"]\n    dt = params[\"dt\"]\n    T = params[\"T\"]\n    \n    # Grid setup\n    dx = L / (M - 1)\n    x = np.linspace(0, L, M)\n    \n    # Dimensionless parameter\n    s = alpha * dt / (dx**2)\n    \n    # Time stepping\n    num_steps = int(round(T / dt))\n    \n    # Initial condition\n    u = params[\"u_exact\"](x, 0, alpha)\n\n    # Time evolution loop\n    for n in range(num_steps):\n        t_next = (n + 1) * dt\n        \n        # Setup the linear system A u_next = b\n        A = np.zeros((M, M))\n        b = np.zeros(M)\n        \n        # Interior points\n        for i in range(1, M - 1):\n            A[i, i-1] = -s\n            A[i, i]   = 1 + 2*s\n            A[i, i+1] = -s\n            b[i]      = u[i]\n            \n        # Boundary conditions\n        # Left boundary (i=0)\n        if params[\"bc_left_type\"] == \"dirichlet\":\n            A[0, 0] = 1.0\n            b[0] = params[\"g_L\"](t_next)\n        elif params[\"bc_left_type\"] == \"neumann\":\n            A[0, 0] = 1 + 2*s\n            A[0, 1] = -2*s\n            b[0] = u[0] - (2 * alpha * dt / dx) * params[\"q_L\"](t_next)\n\n        # Right boundary (i=M-1)\n        if params[\"bc_right_type\"] == \"dirichlet\":\n            A[M-1, M-1] = 1.0\n            b[M-1] = params[\"g_R\"](t_next)\n        elif params[\"bc_right_type\"] == \"neumann\":\n            A[M-1, M-2] = -2*s\n            A[M-1, M-1] = 1 + 2*s\n            b[M-1] = u[M-1] + (2 * alpha * dt / dx) * params[\"q_R\"](t_next)\n        \n        # Solve the system for the next time step\n        u_next = np.linalg.solve(A, b)\n        u = u_next\n\n    # Calculate final error\n    u_final_exact = params[\"u_exact\"](x, T, alpha)\n    max_error = np.max(np.abs(u - u_final_exact))\n    \n    return max_error\n\nsolve()\n```", "id": "3241116"}, {"introduction": "The heart of any implicit method is the solution of a linear system at each time step. While direct solvers like the Thomas algorithm are highly efficient for 1D problems, their computational cost becomes prohibitive in higher dimensions. This practice delves into the use of iterative methods, such as Jacobi and Gauss-Seidel, to solve the BTCS system, providing a bridge between numerical PDEs and numerical linear algebra and offering insights into the performance of solvers for large-scale simulations. [@problem_id:3241177]", "problem": "Consider the one-dimensional heat equation $u_{t}=\\kappa\\,u_{xx}$ on the spatial interval $0<x<1$ and for time $t>0$, subject to homogeneous Dirichlet boundary conditions $u(0,t)=0$ and $u(1,t)=0$. Discretize space on a uniform grid with $n$ interior points and grid spacing $h=1/(n+1)$, and discretize time with step size $\\Delta t>0$. Use the fully implicit Backward-Time Central-Space (BTCS) scheme, namely backward Euler in time and the central difference in space, to advance one time step from $t^{n}$ to $t^{n+1}$.\n\nStarting from the backward Euler definition and the central difference approximation for the second derivative, derive the linear system that must be solved at each time step for the interior unknowns. Express the system in the form $A\\,u^{n+1}=b$, where the coefficient matrix $A$ is tridiagonal and Toeplitz, and $b$ is determined by the previous time level and boundary conditions. Let $r=\\kappa\\,\\Delta t/h^{2}$ denote the nondimensional time step.\n\nInstead of using a direct tridiagonal solver, explore using iterative linear solvers: the Jacobi method and the Gauss-Seidel (GS) method. Your tasks are:\n\n- Using only fundamental discretization definitions and well-tested facts about eigenstructures of symmetric tridiagonal Toeplitz matrices, derive:\n  1. The explicit entries of the coefficient matrix $A$ in terms of $r$ and $n$.\n  2. The Jacobi iteration in the fixed-point form $x^{k+1}=B_{J}\\,x^{k}+c$, identifying the iteration matrix $B_{J}$, and the Gauss–Seidel iteration in the form $x^{k+1}=B_{GS}\\,x^{k}+d$, identifying $B_{GS}$.\n  3. Closed-form expressions for the spectral radii $\\rho(B_{J})$ and $\\rho(B_{GS})$ as functions of $r$ and $n$.\n- Explain why both methods converge for the BTCS matrix for all $r>0$ and $n\\in\\mathbb{N}$ by appealing to the strict diagonal dominance and symmetry of $A$, and relate the asymptotic error reduction factor per iteration to the respective spectral radii.\n- For a prescribed relative residual tolerance $\\tau$ in the Euclidean norm (that is, the $2$-norm), give the iteration count estimate $K_{\\text{est}}=\\lceil \\log(\\tau)/\\log(\\rho)\\rceil$, where $\\rho$ is the spectral radius of the chosen iteration matrix and the initial guess is the zero vector. Clarify the assumptions under which this estimate is meaningful.\n\nThen implement a complete, runnable program that:\n\n- Constructs the BTCS linear system $A\\,u^{n+1}=b$ for a single time step for the initial condition $u(x,0)=\\sin(\\pi x)$, homogeneous Dirichlet boundaries, and given $(n,r)$.\n- Forms $b$ from the previous time level as dictated by BTCS with these boundary conditions.\n- Solves $A\\,x=b$ by:\n  1. The Jacobi method with a zero initial guess, stopping when $\\lVert b-Ax^{k}\\rVert_{2}/\\lVert b\\rVert_{2}\\le \\tau$ or when a maximum of $K_{\\max}$ iterations is reached.\n  2. The Gauss–Seidel method with a zero initial guess and the same stopping criterion.\n  3. A direct tridiagonal matrix algorithm (TDMA), also known as the Thomas algorithm, to serve as a reference solution for accuracy checks.\n- Computes for each $(n,r)$ in the test suite:\n  1. The iteration counts $K_{J}$ and $K_{GS}$ required by Jacobi and Gauss–Seidel to reach the tolerance $\\tau$.\n  2. The analytic spectral radii $\\rho(B_{J})$ and $\\rho(B_{GS})$.\n  3. Booleans $\\text{ok}_{J}$ and $\\text{ok}_{GS}$ that are true if the corresponding iterative solution satisfies $\\lVert x_{\\text{iter}}-x_{\\text{TDMA}}\\rVert_{\\infty}\\le \\varepsilon$ for a given $\\varepsilon$.\n  4. The theoretical iteration estimates $K_{J,\\text{est}}$ and $K_{GS,\\text{est}}$ computed from the spectral radii and $\\tau$.\n\nUse the following test suite, which covers a typical case, a relatively stiff case, a very nonstiff case, and a small-size boundary case:\n\n- Case $1$: $n=20$, $r=0.1$.\n- Case $2$: $n=20$, $r=5$.\n- Case $3$: $n=5$, $r=0.001$.\n- Case $4$: $n=2$, $r=0.5$.\n\nUse tolerance $\\tau=10^{-8}$, maximum iterations $K_{\\max}=10000$, and accuracy threshold $\\varepsilon=10^{-9}$. Angles used inside trigonometric functions must be in radians. There are no physical-unit outputs to report.\n\nFinal output format requirement:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output a sublist in the following order:\n  - $[K_{J},K_{GS},\\rho(B_{J}),\\rho(B_{GS}),\\text{ok}_{J},\\text{ok}_{GS},K_{J,\\text{est}},K_{GS,\\text{est}}]$.\n- Aggregate these per-case sublists into a single list: for example, $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$.", "solution": "### Derivation and Analysis\n\nWe consider the one-dimensional heat equation $u_t = \\kappa u_{xx}$. Let the spatial domain $[0,1]$ be discretized by $n+2$ points $x_j=jh$ for $j=0, 1, \\dots, n+1$, with spacing $h=1/(n+1)$. The points $j=1, \\dots, n$ are the interior points. Let the time be discretized by $t_k=k\\Delta t$. Let $u_j^k \\approx u(x_j, t_k)$.\n\nThe Backward-Time Central-Space (BTCS) scheme discretizes the PDE as:\n$$\n\\frac{u_j^{k+1} - u_j^k}{\\Delta t} = \\kappa \\frac{u_{j-1}^{k+1} - 2u_j^{k+1} + u_{j+1}^{k+1}}{h^2}\n$$\nThis applies to the interior points, $j=1, \\dots, n$. We can rearrange the terms by multiplying by $\\Delta t$ and using the definition $r = \\kappa \\Delta t / h^2$:\n$$\nu_j^{k+1} - u_j^k = r \\left( u_{j-1}^{k+1} - 2u_j^{k+1} + u_{j+1}^{k+1} \\right)\n$$\nGrouping terms at the unknown time level $k+1$ on the left side and known terms from level $k$ on the right side yields:\n$$\n-r u_{j-1}^{k+1} + (1+2r) u_j^{k+1} - r u_{j+1}^{k+1} = u_j^k\n$$\nThe homogeneous Dirichlet boundary conditions state $u(0, t) = u_0^k = 0$ and $u(1, t) = u_{n+1}^k = 0$ for all $k$.\nFor $j=1$: $-r u_0^{k+1} + (1+2r) u_1^{k+1} - r u_2^{k+1} = u_1^k \\implies (1+2r) u_1^{k+1} - r u_2^{k+1} = u_1^k$.\nFor $j=n$: $-r u_{n-1}^{k+1} + (1+2r) u_n^{k+1} - r u_{n+1}^{k+1} = u_n^k \\implies -r u_{n-1}^{k+1} + (1+2r) u_n^{k+1} = u_n^k$.\n\nLet $u^{k+1}$ be the column vector of unknowns $[u_1^{k+1}, \\dots, u_n^{k+1}]^T$ and $b$ be the column vector of knowns from the previous time step, $b = [u_1^k, \\dots, u_n^k]^T$. The system of $n$ linear equations can be written in matrix form $A u^{k+1} = b$.\n\n**1. Coefficient Matrix $A$**\n\nThe matrix $A$ is an $n \\times n$ symmetric tridiagonal Toeplitz matrix with the following entries:\n- Diagonal entries: $A_{ii} = 1+2r$ for $i=1, \\dots, n$.\n- Sub-diagonal and super-diagonal entries: $A_{i,i-1} = A_{i,i+1} = -r$ for $i=2, \\dots, n-1$ and relevant endpoints.\n$$\nA = \\begin{pmatrix}\n1+2r & -r & 0 & \\dots & 0 \\\\\n-r & 1+2r & -r & \\ddots & \\vdots \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots & \\ddots & -r & 1+2r & -r \\\\\n0 & \\dots & 0 & -r & 1+2r\n\\end{pmatrix}\n$$\n\n**2. Jacobi and Gauss-Seidel Iteration Matrices**\n\nTo define the iterative methods, we decompose $A$ into its diagonal ($D$), strictly lower triangular ($-L$), and strictly upper triangular ($-U$) parts, such that $A=D-L-U$.\n- $D = (1+2r)I$, where $I$ is the $n \\times n$ identity matrix.\n- $L$ and $U$ are matrices with entries $r$ on their first sub-diagonal and super-diagonal, respectively, and zeros elsewhere. $L=U^T$.\n\n**Jacobi Method**: The iteration is defined by $D x^{k+1} = (L+U)x^k + b$, which gives the fixed-point form $x^{k+1} = D^{-1}(L+U)x^k + D^{-1}b$.\nThe Jacobi iteration matrix is $B_J = D^{-1}(L+U)$.\nSince $D^{-1} = \\frac{1}{1+2r}I$, we have:\n$$\nB_J = \\frac{1}{1+2r}(L+U) = \\frac{r}{1+2r} \\begin{pmatrix}\n0 & 1 & 0 & \\dots & 0 \\\\\n1 & 0 & 1 & \\ddots & \\vdots \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots & \\ddots & 1 & 0 & 1 \\\\\n0 & \\dots & 0 & 1 & 0\n\\end{pmatrix}\n$$\n\n**Gauss-Seidel Method**: The iteration is defined by $(D-L)x^{k+1} = U x^k + b$, which gives the fixed-point form $x^{k+1} = (D-L)^{-1}U x^k + (D-L)^{-1}b$.\nThe Gauss-Seidel iteration matrix is $B_{GS} = (D-L)^{-1}U$.\n\n**3. Spectral Radii of Iteration Matrices**\n\nThe eigenvalues of an $n \\times n$ symmetric tridiagonal Toeplitz matrix of the form $\\text{tridiag}(c, a, c)$ are given by $\\lambda_j = a + 2c \\cos\\left(\\frac{j\\pi}{n+1}\\right)$ for $j=1, \\dots, n$.\n\nThe Jacobi matrix $B_J$ is of this form with $a=0$ and $c = \\frac{r}{1+2r}$. Its eigenvalues are:\n$$\n\\lambda_j(B_J) = \\frac{2r}{1+2r} \\cos\\left(\\frac{j\\pi}{n+1}\\right), \\quad j=1, \\dots, n\n$$\nThe spectral radius $\\rho(B_J)$ is the maximum of the absolute values of these eigenvalues. Since $r>0$, $\\frac{2r}{1+2r} > 0$. The cosine term has its largest magnitude for $j=1$ or $j=n$. Thus,\n$$\n\\rho(B_J) = \\frac{2r}{1+2r} \\cos\\left(\\frac{\\pi}{n+1}\\right)\n$$\nThe matrix $A$ is a real symmetric matrix with non-positive off-diagonal entries ($A_{ij} \\leq 0$ for $i \\neq j$) and positive diagonal entries ($A_{ii} > 0$). Such a matrix is a \"Stieltjes matrix\" and is \"consistently ordered\" because it is tridiagonal. For consistently ordered matrices, the eigenvalues $\\lambda_j(B_{GS})$ of the Gauss-Seidel iteration matrix are related to the eigenvalues $\\lambda_j(B_J)$ of the Jacobi matrix by $\\lambda_j(B_{GS}) = (\\lambda_j(B_J))^2$. Therefore,\n$$\n\\lambda_j(B_{GS}) = \\left( \\frac{2r}{1+2r} \\cos\\left(\\frac{j\\pi}{n+1}\\right) \\right)^2, \\quad j=1, \\dots, n\n$$\nThe spectral radius $\\rho(B_{GS})$ is the maximum of these eigenvalues, which are all non-negative.\n$$\n\\rho(B_{GS}) = \\left( \\frac{2r}{1+2r} \\cos\\left(\\frac{\\pi}{n+1}\\right) \\right)^2 = \\left(\\rho(B_J)\\right)^2\n$$\n\n**Convergence Analysis**\n\nAn iterative method converges for any initial guess if and only if the spectral radius of its iteration matrix is less than $1$.\nFor any $r>0$ and $n \\in \\mathbb{N}$ ($n \\ge 1$):\n- $\\frac{2r}{1+2r} < 1$ because $2r < 1+2r$ simplifies to $0 < 1$.\n- $\\cos\\left(\\frac{\\pi}{n+1}\\right) < 1$ because $n+1 > 2$, so $\\frac{\\pi}{n+1} \\in (0, \\pi/2)$.\nTherefore, $\\rho(B_J) = \\frac{2r}{1+2r} \\cos\\left(\\frac{\\pi}{n+1}\\right) < 1 \\cdot 1 = 1$.\nSince $\\rho(B_J) < 1$, it follows that $\\rho(B_{GS}) = (\\rho(B_J))^2 < 1$. Thus, both methods are guaranteed to converge for all $r>0$ and $n \\in \\mathbb{N}$.\n\nAlternatively, the matrix $A$ is strictly diagonally dominant for all $r>0$. For any row $i$, the diagonal element is $|A_{ii}| = 1+2r$. The sum of the absolute values of the off-diagonal elements is $\\sum_{j \\ne i}|A_{ij}| \\le |-r| + |-r| = 2r$. Since $1+2r > 2r$, the matrix is strictly diagonally dominant. A well-known theorem states that for a strictly diagonally dominant matrix, both Jacobi and Gauss-Seidel methods converge.\n\nThe asymptotic error reduction factor per iteration is approximately the spectral radius $\\rho$ of the iteration matrix. This is because the error vector $e^k = x^k - x^*$ satisfies $e^k \\approx \\rho^k c v_{dom}$, where $v_{dom}$ is the eigenvector corresponding to the eigenvalue with the largest magnitude.\n\n**Iteration Count Estimate**\n\nThe number of iterations $K$ required to reduce the initial error by a factor of $\\tau$ is estimated by solving $\\rho^K \\approx \\tau$. Taking logarithms gives $K \\log(\\rho) \\approx \\log(\\tau)$, which leads to $K \\approx \\log(\\tau)/\\log(\\rho)$.\nThe problem uses a stopping criterion on the relative residual, $\\lVert b-Ax^k \\rVert_2 / \\lVert b \\rVert_2 \\le \\tau$, with an initial guess $x^0=0$. The initial residual is $r^0 = b-Ax^0 = b$. The residual vector $r^k$ transforms as $r^{k+1} = (I-AD^{-1})r^k$ for Jacobi. The spectral radius of this residual iteration matrix is $\\rho(I - AD^{-1}) = \\rho(B_J)$. A similar relation holds for Gauss-Seidel. Therefore, the residual norm is expected to decrease as $\\lVert r^k \\rVert \\approx \\rho^k \\lVert r^0 \\rVert$. The condition becomes $\\rho^K \\lVert b \\rVert \\le \\tau \\lVert b \\rVert$, or $\\rho^K \\le \\tau$. Since $K$ must be an integer, the estimate is $K_{\\text{est}}=\\lceil \\log(\\tau)/\\log(\\rho)\\rceil$. This estimate is meaningful when the convergence rate is dominated by the spectral radius from early on, which is a reasonable assumption for the given problem setup.", "answer": "```python\nimport numpy as np\n\ndef solve_btcs_iterative(n, r, tau=1e-8, k_max=10000, epsilon=1e-9):\n    \"\"\"\n    Solves the BTCS system and computes metrics for a given (n, r) case.\n\n    Args:\n        n (int): Number of interior spatial grid points.\n        r (float): Nondimensional timestep, kappa*dt/h^2.\n        tau (float): Relative residual tolerance for iterative solvers.\n        k_max (int): Maximum number of iterations.\n        epsilon (float): Accuracy threshold for comparing with TDMA solution.\n\n    Returns:\n        list: A list containing [K_J, K_GS, rho_J, rho_GS, ok_J, ok_GS, K_J_est, K_GS_est].\n    \"\"\"\n\n    # --- System Setup ---\n    h = 1.0 / (n + 1)\n    # The right-hand side vector b is the initial condition u(x,0) at the grid points\n    j = np.arange(1, n + 1)\n    b = np.sin(np.pi * j * h)\n\n    # Coefficient matrix A can be constructed explicitly for applying to vectors.\n    A_diag = 1.0 + 2.0 * r\n    A_offdiag = -r\n\n    def mat_vec_A(x):\n        # A is tridiag(A_offdiag, A_diag, A_offdiag)\n        y = np.zeros_like(x)\n        # First element\n        if n > 0:\n            y[0] = A_diag * x[0] + A_offdiag * x[1] if n > 1 else A_diag * x[0]\n        # Interior elements\n        for i in range(1, n - 1):\n            y[i] = A_offdiag * x[i-1] + A_diag * x[i] + A_offdiag * x[i+1]\n        # Last element\n        if n > 1:\n            y[n-1] = A_offdiag * x[n-2] + A_diag * x[n-1]\n        return y\n\n\n    # --- Analytic Spectral Radii  Iteration Estimates ---\n    cos_term = np.cos(np.pi / (n + 1))\n    rho_J = (2.0 * r / (1.0 + 2.0 * r)) * cos_term\n    rho_GS = rho_J**2\n\n    # Prevent log(0) for very small rho where est_K would be 1 anyway.\n    if rho_J > 1e-16:\n        K_J_est = np.ceil(np.log(tau) / np.log(rho_J))\n    else: \n        K_J_est = 1\n        \n    if rho_GS > 1e-16:\n        K_GS_est = np.ceil(np.log(tau) / np.log(rho_GS))\n    else:\n        K_GS_est = 1\n\n    # --- TDMA (Thomas Algorithm) Reference Solution ---\n    def solve_tdma(a, d, c, b):\n        n_tdma = len(d)\n        c_prime = np.zeros(n_tdma)\n        d_prime = np.zeros(n_tdma)\n        x_tdma = np.zeros(n_tdma)\n\n        c_prime[0] = c[0] / d[0]\n        d_prime[0] = b[0] / d[0]\n\n        for i in range(1, n_tdma):\n            denom = d[i] - a[i] * c_prime[i-1]\n            c_prime[i] = c[i] / denom if i  n_tdma - 1 else 0.0\n            d_prime[i] = (b[i] - a[i] * d_prime[i-1]) / denom\n\n        x_tdma[n_tdma-1] = d_prime[n_tdma-1]\n        for i in range(n_tdma-2, -1, -1):\n            x_tdma[i] = d_prime[i] - c_prime[i] * x_tdma[i+1]\n        return x_tdma\n\n    diag_vec = np.full(n, A_diag)\n    offdiag_vec = np.full(n, A_offdiag)\n    x_tdma = solve_tdma(offdiag_vec, diag_vec, offdiag_vec, b)\n\n    # --- Jacobi Method ---\n    x_j = np.zeros(n)\n    K_J = 0\n    norm_b = np.linalg.norm(b, 2)\n    # Handle b=0 case, though not expected here\n    tol_abs = tau * norm_b if norm_b > 0 else tau\n    \n    for k in range(k_max):\n        # Calculate residual for stopping criterion\n        residual = b - mat_vec_A(x_j)\n        if np.linalg.norm(residual, 2) = tol_abs:\n            break\n        \n        x_j_new = np.zeros(n)\n        # x_j with padding for boundary conditions u_0 = u_{n+1} = 0\n        x_j_padded = np.pad(x_j, (1, 1), 'constant', constant_values=0)\n        \n        for i in range(n):\n            # Indices for padded vector are i and i+2\n            x_j_new[i] = (b[i] - A_offdiag * (x_j_padded[i] + x_j_padded[i+2])) / A_diag\n        \n        x_j = x_j_new\n        K_J = k + 1\n\n    # --- Gauss-Seidel Method ---\n    x_gs = np.zeros(n)\n    K_GS = 0\n    for k in range(k_max):\n        # Calculate residual for stopping criterion\n        residual = b - mat_vec_A(x_gs)\n        if np.linalg.norm(residual, 2) = tol_abs:\n            break\n            \n        x_gs_old = x_gs.copy() # GS can be done in-place, but this is clearer.\n        for i in range(n):\n            sum_L = A_offdiag * x_gs[i-1] if i > 0 else 0\n            sum_U = A_offdiag * x_gs_old[i+1] if i  n - 1 else 0\n            x_gs[i] = (b[i] - sum_L - sum_U) / A_diag\n            \n        K_GS = k + 1\n\n    # --- Accuracy Check ---\n    ok_J = np.linalg.norm(x_j - x_tdma, np.inf) = epsilon\n    ok_GS = np.linalg.norm(x_gs - x_tdma, np.inf) = epsilon\n\n    return [\n        K_J, K_GS,\n        rho_J, rho_GS,\n        str(ok_J).lower(), str(ok_GS).lower(),\n        int(K_J_est), int(K_GS_est)\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (20, 0.1),    # Case 1: Standard\n        (20, 5.0),    # Case 2: Stiff\n        (5, 0.001),   # Case 3: Non-stiff\n        (2, 0.5),     # Case 4: Small-size\n    ]\n\n    results = []\n    for n, r in test_cases:\n        case_result = solve_btcs_iterative(n, r)\n        results.append(case_result)\n\n    final_output = []\n    for res in results:\n        sublist_str = f\"[{res[0]},{res[1]},{res[2]:.10f},{res[3]:.10f},{res[4]},{res[5]},{res[6]},{res[7]}]\"\n        final_output.append(sublist_str)\n    \n    print(f\"[{','.join(final_output)}]\")\n\nsolve()\n```", "id": "3241177"}]}