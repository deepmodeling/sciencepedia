{"hands_on_practices": [{"introduction": "The primary purpose of a Givens rotation is to precisely target and eliminate a single element in a vector. This first exercise [@problem_id:2176490] is the foundational skill for this topic, where you will construct a $2 \\times 2$ Givens matrix from scratch to zero out a specific component of a vector. Mastering this core mechanic is the first step toward applying Givens rotations in more complex algorithms.", "problem": "In numerical linear algebra, a Givens rotation is an operation that rotates a vector in a two-dimensional plane and is often used to introduce zeros into vectors or matrices as part of algorithms like QR decomposition. A 2x2 Givens matrix is an orthogonal matrix of the form\n$$\nG = \\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix}\n$$\nwhere $c$ and $s$ are real numbers that satisfy the condition $c^2 + s^2 = 1$.\n\nConsider the vector $x = \\begin{pmatrix} 7 \\\\ -4 \\end{pmatrix}$. Determine the specific Givens matrix $G$ that transforms this vector $x$ into a new vector $y = Gx$ which has the form $\\begin{pmatrix} r \\\\ 0 \\end{pmatrix}$, under the additional constraint that the resulting component $r$ must be positive.\n\nPresent your answer as a 2x2 matrix with exact numerical entries.", "solution": "Let $G=\\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix}$ with $c^{2}+s^{2}=1$ and $x=\\begin{pmatrix} a \\\\ b \\end{pmatrix}$. Then\n$$\nGx=\\begin{pmatrix} ca+sb \\\\ -sa+cb \\end{pmatrix}.\n$$\nTo obtain $Gx=\\begin{pmatrix} r \\\\ 0 \\end{pmatrix}$, enforce the second component to vanish:\n$$\n-sa+cb=0 \\quad \\Longleftrightarrow \\quad cb=sa.\n$$\nA standard choice satisfying this and $c^{2}+s^{2}=1$ is\n$$\nr=\\sqrt{a^{2}+b^{2}}, \\quad c=\\frac{a}{r}, \\quad s=\\frac{b}{r}.\n$$\nWith this choice,\n$$\n-sa+cb=-\\frac{b}{r}a+\\frac{a}{r}b=0, \\quad ca+sb=\\frac{a^{2}+b^{2}}{r}=r,\n$$\nand since $r=\\sqrt{a^{2}+b^{2}}$ is positive, the requirement $r0$ is satisfied.\n\nFor $x=\\begin{pmatrix} 7 \\\\ -4 \\end{pmatrix}$ we have $a=7$, $b=-4$, hence\n$$\nr=\\sqrt{7^{2}+(-4)^{2}}=\\sqrt{65}, \\quad c=\\frac{7}{\\sqrt{65}}, \\quad s=\\frac{-4}{\\sqrt{65}}.\n$$\nTherefore,\n$$\nG=\\begin{pmatrix} \\frac{7}{\\sqrt{65}}  \\frac{-4}{\\sqrt{65}} \\\\ \\frac{4}{\\sqrt{65}}  \\frac{7}{\\sqrt{65}} \\end{pmatrix}.\n$$\nThis $G$ yields $Gx=\\begin{pmatrix} \\sqrt{65} \\\\ 0 \\end{pmatrix}$ with the positive first component as required.", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{7}{\\sqrt{65}}  \\frac{-4}{\\sqrt{65}} \\\\ \\frac{4}{\\sqrt{65}}  \\frac{7}{\\sqrt{65}} \\end{pmatrix}}$$", "id": "2176490"}, {"introduction": "After learning the mechanics, it is crucial to build intuition about what the Givens parameters tell us. This next problem [@problem_id:2176468] presents a thought experiment where you deduce the properties of the input vector based on the resulting rotation. This exercise strengthens your conceptual understanding by connecting the algebraic components of the rotation, $c$ and $s$, to the geometric orientation of the vector being transformed.", "problem": "In the field of numerical linear algebra, Givens rotations are used to selectively introduce zeros into vectors and matrices. A student is analyzing a numerical routine that takes a non-zero two-dimensional column vector $\\mathbf{v} = \\begin{pmatrix} a \\\\ b \\end{pmatrix}$ and computes parameters $c$ and $s$ for a Givens rotation matrix $G$ given by:\n$$\nG = \\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix}\n$$\nThe purpose of this rotation is to transform $\\mathbf{v}$ into a vector where the second component is zero. That is, the parameters $c$ and $s$ are chosen to satisfy the condition:\n$$\nG \\mathbf{v} = \\begin{pmatrix} r \\\\ 0 \\end{pmatrix}\n$$\nwhere $r = \\sqrt{a^2 + b^2}$, and the parameters must also satisfy $c^2 + s^2 = 1$.\n\nWhile testing the routine with a particular non-zero input vector $\\mathbf{v}$, the student observes that the computed parameters are exactly $c=1$ and $s=0$.\n\nWhich of the following statements completely and accurately describes the original vector $\\mathbf{v} = \\begin{pmatrix} a \\\\ b \\end{pmatrix}$ that would lead to this specific outcome?\n\nA. The vector must be of the form $\\begin{pmatrix} a \\\\ 0 \\end{pmatrix}$ for any real number $a \\neq 0$.\n\nB. The vector must be of the form $\\begin{pmatrix} a \\\\ 0 \\end{pmatrix}$ for any real number $a  0$.\n\nC. The vector must be the zero vector, $\\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$.\n\nD. The vector must be of the form $\\begin{pmatrix} 0 \\\\ b \\end{pmatrix}$ for any real number $b \\neq 0$.\n\nE. The vector can be any vector for which $a=-b$.", "solution": "We are given a non-zero vector $\\mathbf{v} = \\begin{pmatrix} a \\\\ b \\end{pmatrix}$, a Givens matrix $G = \\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix}$ with $c^{2} + s^{2} = 1$, and the condition\n$$\nG \\mathbf{v} = \\begin{pmatrix} r \\\\ 0 \\end{pmatrix}, \\quad r = \\sqrt{a^{2} + b^{2}}.\n$$\nThe observed parameters are $c = 1$ and $s = 0$. Substituting these values into $G$ gives\n$$\nG = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}.\n$$\nTherefore,\n$$\nG \\mathbf{v} = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} a \\\\ b \\end{pmatrix} = \\begin{pmatrix} a \\\\ b \\end{pmatrix}.\n$$\nSince this must equal $\\begin{pmatrix} r \\\\ 0 \\end{pmatrix}$, we obtain the equations\n$$\na = r, \\quad b = 0.\n$$\nWith $b = 0$, the definition of $r$ reduces to\n$$\nr = \\sqrt{a^{2} + 0} = |a|.\n$$\nFrom $a = r$ and $r = |a|$, it follows that\n$$\na = |a| \\quad \\Rightarrow \\quad a \\geq 0.\n$$\nBecause the input vector is non-zero, we cannot have $a = 0$ when $b = 0$. Hence\n$$\na  0, \\quad b = 0.\n$$\nTherefore, the original vector must be of the form $\\begin{pmatrix} a \\\\ 0 \\end{pmatrix}$ with $a  0$. This corresponds exactly to option B. Options A, C, D, and E do not satisfy all the derived conditions under $c = 1$ and $s = 0$ with $r = \\sqrt{a^{2} + b^{2}}$ and a non-zero input vector.", "answer": "$$\\boxed{B}$$", "id": "2176468"}, {"introduction": "Givens rotations reveal their true power when used sequentially in algorithms like QR decomposition. This final practice [@problem_id:3236383] moves from theory to practical, hands-on implementation. Your task is to apply a series of rotations to a vector efficiently, by updating the vector in-place rather than forming the full matrix product, a technique that is essential for writing high-performance numerical code.", "problem": "You are given a sequence of plane rotations in the sense of Givens rotations and a target vector. The goal is to apply the sequence to the vector without explicitly forming the full orthogonal matrix. The fundamental base to use is the definition of orthogonal matrices and the structure of a Givens rotation acting on two coordinates as an identity everywhere except for a single two-dimensional orthogonal block. A Givens rotation is defined on indices $i$ and $j$ with parameters $c$ and $s$ satisfying $c^2 + s^2 = 1$.\n\nDefinitions and constraints:\n- A Givens rotation $G(i,j;c,s)$ acts on a vector $\\mathbf{x} \\in \\mathbb{R}^n$ by transforming only the components $x_i$ and $x_j$ via the two-dimensional orthogonal block\n$$\n\\begin{pmatrix}\nc  s \\\\\n-s  c\n\\end{pmatrix},\n$$\nand leaving all other components unchanged. The parameters satisfy $c^2 + s^2 = 1$.\n- The sequence of rotations is $Q = G_k \\dots G_1$, and the application to a vector is $Q \\mathbf{x}$ in the listed order from $G_1$ to $G_k$ (that is, first apply $G_1$ to $\\mathbf{x}$, then apply $G_2$ to the result, and so on).\n- Use $0$-based indexing for all indices $i$ and $j$.\n- Angles are not used; specify each rotation by its $(c,s)$ values.\n- Do not form the full matrix $Q$. The algorithm must update only the relevant two entries per rotation.\n\nTask:\n- Write a complete program that applies a given sequence of Givens rotations $Q = G_k \\dots G_1$ to a vector $\\mathbf{x}$ of length $n$, without explicitly forming the matrix $Q$.\n- For each rotation $G(i,j;c,s)$, update the two entries $x_i$ and $x_j$ by the rule\n$$\n\\begin{pmatrix}\nx_i' \\\\\nx_j'\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nc  s \\\\\n-s  c\n\\end{pmatrix}\n\\begin{pmatrix}\nx_i \\\\\nx_j\n\\end{pmatrix},\n$$\napplied in sequence from $G_1$ to $G_k$.\n\nTest suite:\nApply your implementation to the following parameter sets. Each test case is specified by dimension $n$, initial vector $\\mathbf{x}$, and the ordered list $\\mathcal{G}$ of rotations, where each rotation is a tuple $(i,j,c,s)$ using $0$-based indices.\n\n- Test case $1$ (general case):\n  - $n = 5$\n  - $\\mathbf{x} = [3.0, -1.0, 2.0, 0.5, -4.0]^\\top$\n  - $\\mathcal{G} = [(0, 1, 0.8, 0.6), (2, 4, 0.6, -0.8), (3, 4, 0.7071067811865476, 0.7071067811865475)]$\n\n- Test case $2$ (boundary case: identity rotation that leaves the vector unchanged):\n  - $n = 4$\n  - $\\mathbf{x} = [1.0, 2.0, 3.0, 4.0]^\\top$\n  - $\\mathcal{G} = [(1, 3, 1.0, 0.0)]$\n\n- Test case $3$ (edge case: zero vector remains zero under any orthogonal transform):\n  - $n = 3$\n  - $\\mathbf{x} = [0.0, 0.0, 0.0]^\\top$\n  - $\\mathcal{G} = [(0, 2, 0.0, 1.0), (0, 1, 0.7071067811865476, -0.7071067811865475)]$\n\n- Test case $4$ (edge case: empty sequence of rotations):\n  - $n = 5$\n  - $\\mathbf{x} = [-2.5, 0.0, 7.25, 1.5, -3.5]^\\top$\n  - $\\mathcal{G} = []$\n\n- Test case $5$ (boundary case: pure $90^\\circ$-equivalents represented by $c = 0$ and $s = \\pm 1$ producing signed swaps):\n  - $n = 4$\n  - $\\mathbf{x} = [0.5, -1.5, 2.0, 3.0]^\\top$\n  - $\\mathcal{G} = [(0, 2, 0.0, 1.0), (1, 3, 0.0, -1.0)]$\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$).\n- Each $\\text{result}_t$ must itself be the resulting vector for test case $t$, formatted as a list with entries rounded to eight decimal places, such as $[x_0,x_1,\\dots,x_{n-1}]$.", "solution": "The problem is valid. It is a well-posed and scientifically grounded task from the field of numerical linear algebra. All provided data are consistent and sufficient to proceed with a solution.\n\nThe problem requires the application of a sequence of Givens rotations to a vector. A Givens rotation is an orthogonal transformation that affects only two components of a vector, rotating them in the plane they define. Given a vector $\\mathbf{x} \\in \\mathbb{R}^n$, a Givens rotation $G(i, j; c, s)$ is designed to modify the components $x_i$ and $x_j$, where $i$ and $j$ are the indices corresponding to the plane of rotation. All other components of the vector $\\mathbf{x}$ remain unchanged.\n\nThe transformation is defined by a $2 \\times 2$ matrix acting on the subvector $\\begin{pmatrix} x_i \\\\ x_j \\end{pmatrix}$. The parameters $c$ and $s$ are the cosine and sine of the angle of rotation, respectively, and must satisfy the condition $c^2 + s^2 = 1$, which ensures the orthogonality of the transformation. The updated components, denoted $x_i'$ and $x_j'$, are calculated as follows:\n$$\n\\begin{pmatrix}\nx_i' \\\\\nx_j'\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nc  s \\\\\n-s  c\n\\end{pmatrix}\n\\begin{pmatrix}\nx_i \\\\\nx_j\n\\end{pmatrix}\n$$\nThis matrix-vector multiplication expands to two scalar equations:\n$$\nx_i' = c \\cdot x_i + s \\cdot x_j \\\\\nx_j' = -s \\cdot x_i + c \\cdot x_j\n$$\nThe problem specifies that a sequence of $k$ such rotations, $G_1, G_2, \\dots, G_k$, must be applied to an initial vector $\\mathbf{x}$. The final vector $\\mathbf{x}_{final}$ is the result of the composite transformation $Q\\mathbf{x}$, where $Q = G_k G_{k-1} \\dots G_1$. The application must be sequential:\n$$\n\\mathbf{x}^{(1)} = G_1 \\mathbf{x}^{(0)} \\\\\n\\mathbf{x}^{(2)} = G_2 \\mathbf{x}^{(1)} \\\\\n\\vdots \\\\\n\\mathbf{x}^{(k)} = G_k \\mathbf{x}^{(k-1)}\n$$\nwhere $\\mathbf{x}^{(0)}$ is the initial vector.\n\nThe key constraint is to perform this operation without explicitly constructing the $n \\times n$ matrix $Q$. This is the standard and efficient method for applying Givens rotations, as it avoids the storage and computational cost of forming and multiplying large dense matrices. The algorithm proceeds by iterating through the given sequence of rotations. For each rotation $G_m(i, j; c, s)$, only the $i$-th and $j$-th elements of the vector are updated.\n\nThe algorithmic procedure is as follows:\n1. Initialize a vector $\\mathbf{x}$ with the provided starting values.\n2. For each rotation $(i, j, c, s)$ in the given sequence $\\mathcal{G}$:\n   a. Extract the current values of the components $x_i$ and $x_j$ from the vector $\\mathbf{x}$.\n   b. Since the calculation of both new values, $x_i'$ and $x_j'$, depends on the original values of $x_i$ and $x_j$, care must be taken to use the original values for both computations. A common way to implement this is to store one of the original values, say $x_i$, in a temporary variable before it is overwritten.\n   c. Calculate the new value $x_i' = c \\cdot x_i + s \\cdot x_j$.\n   d. Calculate the new value $x_j' = -s \\cdot x_i + c \\cdot x_j$ (using the original $x_i$).\n   e. Update the vector $\\mathbf{x}$ by setting its $i$-th component to $x_i'$ and its $j$-th component to $x_j'$.\n3. After all rotations in the sequence have been applied, the resulting vector $\\mathbf{x}$ is the final answer.\n\nThis procedure will be applied to each test case provided. The final numerical results for each resulting vector will be rounded to eight decimal places as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Applies a sequence of Givens rotations to a vector for multiple test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (general case)\n        {\n            \"n\": 5,\n            \"x\": [3.0, -1.0, 2.0, 0.5, -4.0],\n            \"G\": [(0, 1, 0.8, 0.6), \n                  (2, 4, 0.6, -0.8), \n                  (3, 4, 0.7071067811865476, 0.7071067811865475)]\n        },\n        # Test case 2 (boundary case: identity rotation)\n        {\n            \"n\": 4,\n            \"x\": [1.0, 2.0, 3.0, 4.0],\n            \"G\": [(1, 3, 1.0, 0.0)]\n        },\n        # Test case 3 (edge case: zero vector)\n        {\n            \"n\": 3,\n            \"x\": [0.0, 0.0, 0.0],\n            \"G\": [(0, 2, 0.0, 1.0), \n                  (0, 1, 0.7071067811865476, -0.7071067811865475)]\n        },\n        # Test case 4 (edge case: empty sequence)\n        {\n            \"n\": 5,\n            \"x\": [-2.5, 0.0, 7.25, 1.5, -3.5],\n            \"G\": []\n        },\n        # Test case 5 (boundary case: 90-degree rotations)\n        {\n            \"n\": 4,\n            \"x\": [0.5, -1.5, 2.0, 3.0],\n            \"G\": [(0, 2, 0.0, 1.0), \n                  (1, 3, 0.0, -1.0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Initialize vector from the current test case.\n        # Use numpy array for vectorized operations and floating point precision.\n        x = np.array(case[\"x\"], dtype=np.float64)\n        \n        # Apply each Givens rotation in sequence.\n        for rotation in case[\"G\"]:\n            i, j, c, s = rotation\n            \n            # Store original values of x[i] and x[j]\n            xi = x[i]\n            xj = x[j]\n            \n            # Apply the rotation.\n            # The calculation of the new x[j] must use the original xi.\n            x[i] = c * xi + s * xj\n            x[j] = -s * xi + c * xj\n            \n        # Round the final vector to 8 decimal places.\n        rounded_x = np.round(x, 8)\n        \n        # Convert -0.0 to 0.0 for canonical representation, then convert to list.\n        result_list = [0.0 if val == -0.0 else val for val in rounded_x.tolist()]\n        \n        # Append the string representation of the list to the results.\n        results.append(str(result_list))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3236383"}]}