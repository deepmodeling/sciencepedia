{"hands_on_practices": [{"introduction": "To begin, we'll tackle the most fundamental skill: interpreting a matrix stored in the popular Compressed Sparse Row (CSR) format. This exercise involves reconstructing the original dense matrix from its three constituent arrays, giving you direct practice with how the row pointers and column indices work together to map compressed data back to its 2D structure. Mastering this \"decoding\" process is the essential first step toward using sparse formats effectively [@problem_id:2204554].", "problem": "In many scientific and engineering applications, matrices are often \"sparse,\" meaning most of their elements are zero. Storing all these zeros is inefficient. The Compressed Sparse Row (CSR) format is a common method for storing sparse matrices by using three one-dimensional arrays.\n\nConsider a sparse matrix $A$ of size $4 \\times 4$. In the CSR format (using 0-based indexing), this matrix is represented by the following three arrays:\n1.  An array `V` containing the non-zero elements of $A$, read row by row, from left to right.\n2.  An array `C` containing the column index for each corresponding element in `V`.\n3.  An array `R` (the row pointer) of size $m+1$ (where $m$ is the number of rows), where the $i$-th element indicates the index in `V` and `C` where the data for the $i$-th row begins. The last element of `R` is the total number of non-zero elements.\n\nThe three arrays for our $4 \\times 4$ matrix $A$ are given as follows:\n- `V = [5.1, -1.2, 2.0, -3.5, 4.0, 9.8]`\n- `C = [1, 3, 0, 2, 3, 0]`\n- `R = [0, 2, 3, 5, 6]`\n\nReconstruct the original dense $4 \\times 4$ matrix $A$. Present your answer as a $4 \\times 4$ matrix.", "solution": "We use the CSR definition with 0-based indexing. For each row index $i \\in \\{0,1,2,3\\}$, the nonzero entries of row $i$ are stored in the segments of `V` and `C` with indices $j$ from $R[i]$ to $R[i+1]-1$, where the column index is $C[j]$ and the value is $V[j]$. The last element $R[4]=6$ equals the total number of nonzeros, which matches $\\lvert V \\rvert=6$.\n\nRow $0$: indices $j=R[0]\\ldots R[1]-1=0\\ldots 1$.\n- $j=0$: $C[0]=1$, $V[0]=5.1$ gives $A_{0,1}=5.1$.\n- $j=1$: $C[1]=3$, $V[1]=-1.2$ gives $A_{0,3}=-1.2$.\nThus row $0$ is $[0,\\,5.1,\\,0,\\,-1.2]$.\n\nRow $1$: indices $j=R[1]\\ldots R[2]-1=2\\ldots 2$.\n- $j=2$: $C[2]=0$, $V[2]=2.0$ gives $A_{1,0}=2.0$.\nThus row $1$ is $[2.0,\\,0,\\,0,\\,0]$.\n\nRow $2$: indices $j=R[2]\\ldots R[3]-1=3\\ldots 4$.\n- $j=3$: $C[3]=2$, $V[3]=-3.5$ gives $A_{2,2}=-3.5$.\n- $j=4$: $C[4]=3$, $V[4]=4.0$ gives $A_{2,3}=4.0$.\nThus row $2$ is $[0,\\,0,\\,-3.5,\\,4.0]$.\n\nRow $3$: indices $j=R[3]\\ldots R[4]-1=5\\ldots 5$.\n- $j=5$: $C[5]=0$, $V[5]=9.8$ gives $A_{3,0}=9.8$.\nThus row $3$ is $[9.8,\\,0,\\,0,\\,0]$.\n\nTherefore, the reconstructed dense matrix $A$ is\n$$\n\\begin{pmatrix}\n0 & 5.1 & 0 & -1.2 \\\\\n2.0 & 0 & 0 & 0 \\\\\n0 & 0 & -3.5 & 4.0 \\\\\n9.8 & 0 & 0 & 0\n\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0 & 5.1 & 0 & -1.2 \\\\ 2.0 & 0 & 0 & 0 \\\\ 0 & 0 & -3.5 & 4.0 \\\\ 9.8 & 0 & 0 & 0\\end{pmatrix}}$$", "id": "2204554"}, {"introduction": "Beyond simply storing a static matrix, we often need to modify its structure, for instance by adding or removing non-zero entries. This practice explores the practical consequences of such modifications by comparing the \"update cost\" for the Compressed Sparse Row (CSR) and Coordinate (COO) formats [@problem_id:2204564]. By quantifying the number of array elements that must be rewritten, you will gain a concrete understanding of the crucial trade-off between a format's read-time performance and its flexibility.", "problem": "In numerical analysis, sparse matrices (matrices in which most of the elements are zero) are often stored using specialized formats to save memory and computational time. Two such common formats are the Coordinate (COO) format and the Compressed Sparse Row (CSR) format. Assume all array indices are 0-indexed.\n\n-   In the **Coordinate (COO)** format, a matrix is represented by three arrays of length `nnz` (the number of non-zero elements): `values`, `row_indices`, and `col_indices`. For each non-zero element, its value, row index, and column index are stored at the corresponding position in these three arrays. The elements are typically sorted by row, and then by column.\n\n-   In the **Compressed Sparse Row (CSR)** format, a matrix is represented by three arrays: `values` (length `nnz`), `col_indices` (length `nnz`), and `row_ptr` (length `num_rows + 1`). The `values` and `col_indices` arrays store the non-zero values and their column indices, ordered row by row. The `row_ptr` array stores the index in the `values` array where each row begins. Specifically, the non-zero elements of row `i` are stored in `values` from index `row_ptr[i]` to `row_ptr[i+1] - 1`.\n\nConsider the following 5x5 sparse matrix `M`:\n$$\nM = \\begin{pmatrix}\n7 & 0 & 0 & 2 & 0 \\\\\n0 & 0 & 8 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 3 \\\\\n0 & 5 & 0 & 9 & 0 \\\\\n0 & 0 & 4 & 0 & 6\n\\end{pmatrix}\n$$\n\nSuppose this matrix is stored in both COO and CSR formats. A modification is made to the matrix: the non-zero element `M[3, 1]`, which has a value of 5, is set to 0. To reflect this change in the stored formats, the corresponding entries must be removed from the storage arrays to maintain a compact representation (i.e., no explicit zeros are stored). This removal is achieved by shifting all subsequent elements in the relevant arrays to fill the gap.\n\nWe define the \"update cost\" as the total count of individual numbers that must be re-written to new values in the storage arrays (`values`, `row_indices`, `col_indices`, `row_ptr`). This includes the elements being shifted and any pointers that need to be adjusted.\n\nLet `C_COO` be the update cost for the COO format and `C_CSR` be the update cost for the CSR format. Calculate the total update cost, `C_total = C_COO + C_CSR`. Express your answer as a single integer.", "solution": "First count the nonzeros and fix a consistent ordering. The matrix has nonzeros at positions\n$(0,0),(0,3),(1,2),(2,0),(2,4),(3,1),(3,3),(4,2),(4,4)$,\nso $\\mathrm{nnz}=9$. In row-major order (sorted by row, then column), the linear indices $0$ through $8$ correspond to these positions in that order, hence $(3,1)$ is at linear index $k=5$.\n\nCOO update cost: The three arrays $\\text{values}$, $\\text{row\\_indices}$, $\\text{col\\_indices}$ each have length $9$. Removing the entry at index $k=5$ requires shifting every subsequent element left by one position to fill the gap. The number of elements shifted in each array is $\\mathrm{nnz}-(k+1)=9-6=3$. Each shifted element is a rewrite. Therefore,\n$$\nC_{\\mathrm{COO}}=3 \\text{ arrays}\\times 3 \\text{ rewrites per array}=9.\n$$\n\nCSR update cost: The arrays are\n- $\\text{values}=[7,2,8,1,3,5,9,4,6]$,\n- $\\text{col\\_indices}=[0,3,2,0,4,1,3,2,4]$,\n- $\\text{row\\_ptr}=(0,2,3,5,7,9)$,\nwhere $\\text{row\\_ptr}[i+1]-\\text{row\\_ptr}[i]$ equals the number of nonzeros in row $i$.\n\nThe entry $(3,1)$ is the first element of row $3$, located at global index $k=5$. Deleting it forces a left shift of all subsequent elements in the contiguous $\\text{values}$ and $\\text{col\\_indices}$ arrays, i.e., $\\mathrm{nnz}-(k+1)=9-6=3$ rewrites per array. Thus these two arrays contribute $3+3=6$ rewrites.\n\nFor $\\text{row\\_ptr}$, entries for rows strictly after the modified row must decrease by $1$. Specifically, $\\text{row\\_ptr}[4]$ and $\\text{row\\_ptr}[5]$ change (from $7$ to $6$ and from $9$ to $8$), while $\\text{row\\_ptr}[0],\\text{row\\_ptr}[1],\\text{row\\_ptr}[2],\\text{row\\_ptr}[3]$ remain unchanged. Hence there are $2$ pointer rewrites. Therefore,\n$$\nC_{\\mathrm{CSR}}=3+3+2=8.\n$$\n\nSumming both formats gives\n$$\nC_{\\text{total}}=C_{\\mathrm{COO}}+C_{\\mathrm{CSR}}=9+8=17.\n$$", "answer": "$$\\boxed{17}$$", "id": "2204564"}, {"introduction": "We culminate our practice with a true-to-life challenge from scientific computing: implementing an efficient sparse matrix-matrix multiplication (SpGEMM) algorithm. This exercise requires you to compute the product $C = A \\cdot B$ where $A$ is in CSR format and $B$ is in CSC format, a combination that is particularly well-suited for this task [@problem_id:2440279]. By developing an algorithm that leverages the strengths of each format to perform sparse dot products, you will synthesize your knowledge into a practical and powerful computational tool.", "problem": "You must write a complete program that computes the sparse matrix-matrix product $C = A \\cdot B$, where $A$ is given in Compressed Sparse Row (CSR) format and $B$ is given in Compressed Sparse Column (CSC) format. All indices are zero-based. The product must be formed over the real numbers and the output must represent only the nonzero entries of $C$, omitting any entries whose absolute value is strictly less than a prescribed tolerance.\n\nDefinitions and requirements:\n\n- The matrix $A$ has shape $m \\times k$ and is specified in CSR by three arrays: $A_p$ (row pointer of length $m+1$), $A_j$ (column indices of length $\\mathrm{nnz}(A)$), and $A_x$ (values of length $\\mathrm{nnz}(A)$). The $i$-th row of $A$ has its nonzeros in the segment $A_p[i]$ through $A_p[i+1]-1$, with corresponding column indices from $A_j$ and values from $A_x$. Duplicate column indices within a row are allowed and must be interpreted as contributing additively to that matrix entry.\n- The matrix $B$ has shape $k \\times n$ and is specified in CSC by three arrays: $B_p$ (column pointer of length $n+1$), $B_i$ (row indices of length $\\mathrm{nnz}(B)$), and $B_x$ (values of length $\\mathrm{nnz}(B)$). The $c$-th column of $B$ has its nonzeros in the segment $B_p[c]$ through $B_p[c+1]-1$, with corresponding row indices from $B_i$ and values from $B_x$. Duplicate row indices within a column are allowed and must be interpreted as contributing additively to that matrix entry.\n- The product is defined by the fundamental rule\n$$\nC_{i,c} = \\sum_{j=0}^{k-1} A_{i,j} \\, B_{j,c},\n$$\nfor all row indices $i \\in \\{0,\\dots,m-1\\}$ and column indices $c \\in \\{0,\\dots,n-1\\}$.\n- Your program must construct $C$ as a list of nonzeros in Coordinate (COO) form sorted by row then by column: output three lists $I$, $J$, and $V$ where $I[t]$ and $J[t]$ are the row and column indices of the $t$-th nonzero and $V[t]$ is its value, with $(I[t],J[t])$ sorted in lexicographic order by row then column. Any entry with absolute value strictly less than a tolerance $\\tau$ must be omitted; take $\\tau = 10^{-12}$.\n- All indices must be zero-based integers. All values are real numbers. There are no physical units involved.\n\nTest suite:\n\nYour program must compute results for the following four test cases. Each test case provides $m$, $k$, $n$, the CSR arrays for $A$, and the CSC arrays for $B$.\n\n- Test case $1$:\n  - $m = 3$, $k = 4$, $n = 2$.\n  - $A_p = [0,3,4,6]$, $A_j = [0,1,1,2,1,3]$, $A_x = [1.0,-2.0,0.5,3.0,4.0,-1.0]$.\n  - $B_p = [0,4,7]$, $B_i = [0,1,1,3,1,2,3]$, $B_x = [5.0,1.0,-1.0,2.0,-3.0,1.0,4.0]$.\n- Test case $2$:\n  - $m = 2$, $k = 0$, $n = 3$.\n  - $A_p = [0,0,0]$, $A_j = []$, $A_x = []$.\n  - $B_p = [0,0,0,0]$, $B_i = []$, $B_x = []$.\n- Test case $3$:\n  - $m = 2$, $k = 3$, $n = 2$.\n  - $A_p = [0,0,2]$, $A_j = [0,2]$, $A_x = [2.0,-2.0]$.\n  - $B_p = [0,0,2]$, $B_i = [0,2]$, $B_x = [-1.0,-1.0]$.\n- Test case $4$:\n  - $m = 1$, $k = 1$, $n = 1$.\n  - $A_p = [0,1]$, $A_j = [0]$, $A_x = [-7.5]$.\n  - $B_p = [0,1]$, $B_i = [0]$, $B_x = [0.2]$.\n\nAnswer specification:\n\n- For each test case, your program must output the triple of lists $[I,J,V]$ describing the nonzeros of $C$ in row-major order as specified above. Use the zero-based indices exactly as defined by the input arrays, and apply the tolerance $\\tau = 10^{-12}$ to drop entries whose absolute value is strictly less than $\\tau$.\n- Final output format: your program must produce a single line containing the list of results for all four test cases in order. Each test case result is itself a list of three lists. The final line must be a single bracketed list with comma-separated entries and no spaces anywhere. For example, if there were two test cases, the format would be `[[I_1,J_1,V_1],[I_2,J_2,V_2]]`, but with the actual computed lists substituted.\n\nYour program must not read any input and must not write anything other than the single required output line. The only acceptable outputs are integers and floating-point numbers inside lists as described; no additional text is permitted.", "solution": "The problem as stated is valid. It is a well-posed, scientifically grounded problem in numerical linear algebra, a foundational subject in computational science and engineering. The definitions of sparse matrix formats—Compressed Sparse Row (CSR) and Compressed Sparse Column (CSC)—and the operation of matrix multiplication are standard. All necessary parameters and data for the test cases are provided, and the problem is free of ambiguity or contradiction.\n\nThe objective is to compute the matrix product $C = A \\cdot B$, where $A$ is an $m \\times k$ matrix in CSR format and $B$ is a $k \\times n$ matrix in CSC format. The resulting $m \\times n$ matrix $C$ must be represented in Coordinate (COO) format, consisting of three lists for row indices ($I$), column indices ($J$), and values ($V$).\n\nThe fundamental definition of the matrix product gives the element $C_{i,c}$ of the matrix $C$ as the dot product of the $i$-th row of $A$ and the $c$-th column of $B$:\n$$\nC_{i,c} = \\sum_{j=0}^{k-1} A_{i,j} B_{j,c}\n$$\nThe provided storage formats are optimal for this calculation. The CSR format for $A$ allows for efficient, contiguous access to the elements of any given row. The CSC format for $B$ allows for efficient, contiguous access to the elements of any given column. Thus, computing each $C_{i,c}$ involves the dot product of two sparse vectors, both of which are readily available from the input data structures.\n\nA critical preliminary step is to address the specified handling of duplicate indices. The problem states that duplicate indices within a row of $A$ or a column of $B$ imply that their corresponding values should be summed. Before proceeding to the main multiplication, it is therefore necessary to \"canonicalize\" the input matrices. This process involves, for each row of $A$ and each column of $B$:\n1. Aggregating values for any duplicate indices. A temporary map-like structure is suitable for this, mapping an index to its summed value.\n2. Filtering out any resultant entries whose absolute value is strictly less than the tolerance $\\tau = 10^{-12}$.\n3. Sorting the remaining non-zero entries by their index.\nThis canonicalization ensures that each sparse vector (row of $A$ or column of $B$) used in the dot product has unique and sorted indices, which is a prerequisite for the most efficient dot product algorithm.\n\nLet the canonicalized matrices be denoted by primed arrays: $A'_p, A'_j, A'_x$ and $B'_p, B'_i, B'_x$. The core of the algorithm is then to compute each element of $C$. The requirement that the output COO lists be sorted lexicographically by $(I, J)$ pairs is naturally satisfied by iterating through the rows $i$ of $C$ from $0$ to $m-1$ and, for each row, iterating through the columns $c$ of $C$ from $0$ to $n-1$.\n\nFor each pair $(i, c)$, we compute $C_{i,c}$. This is the dot product of the $i$-th (sparse) row of $A$ and the $c$-th (sparse) column of $B$. Since the indices in our canonicalized sparse vectors are sorted, this dot product can be computed highly efficiently using a merge-join-like, two-pointer algorithm. We use one pointer, say $p_A$, for the non-zero elements of row $i$ of $A$, and another, $p_B$, for column $c$ of $B$.\nThe pointers are advanced based on the comparison of the column index from $A$ ($A'_j[p_A]$) and the row index from $B$ ($B'_i[p_B]$). A product term is added to the sum for $C_{i,c}$ only when these indices match.\n\nThe final algorithm is as follows:\n1. Initialize empty lists $I, J, V$ for the output COO matrix $C$.\n2. Canonicalize the input matrix $A$ into a new CSR representation where each row has unique, sorted column indices.\n3. Canonicalize the input matrix $B$ into a new CSC representation where each column has unique, sorted row indices.\n4. Iterate through each row index $i$ from $0$ to $m-1$.\n5. Inside this loop, iterate through each column index $c$ from $0$ to $n-1$.\n6. For each pair $(i, c)$, compute the dot product of the canonical $i$-th row of $A$ and $c$-th column of $B$ using the two-pointer method. Let the result be $v$.\n7. If $|v| \\ge \\tau$, append $i$ to $I$, $c$ to $J$, and $v$ to $V$.\n8. After iterating through all $(i, c)$ pairs, the lists $I, J, V$ represent the matrix $C$ in the required sorted COO format.\nThis procedure is robust, correct, and respects the sparse nature of the input matrices for an efficient computation.", "answer": "[[[0,0,1,2,2],[0,1,1,0,1],[5.0,4.5,3.0,-2.0,-16.0]],[[],[],[]],[[],[],[]],[[0],[0],[-1.5]]]", "id": "2440279"}]}