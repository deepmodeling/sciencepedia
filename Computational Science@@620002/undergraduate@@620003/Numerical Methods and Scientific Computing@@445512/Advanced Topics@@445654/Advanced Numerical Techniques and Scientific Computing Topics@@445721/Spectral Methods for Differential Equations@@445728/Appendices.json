{"hands_on_practices": [{"introduction": "At the heart of spectral collocation methods lies the concept of the differentiation matrix. This powerful tool allows us to approximate the derivative of a function simply by multiplying a vector of its values at specific grid points by a matrix. This practice provides direct experience in constructing a Chebyshev differentiation matrix and applying it to solve a second-order boundary value problem [@problem_id:3277690]. By investigating the matrix's condition number and the solution's accuracy, you will gain insight into both the remarkable precision of spectral methods and the numerical challenges that can arise.", "problem": "Consider the Chebyshev spectral collocation approach for approximating derivatives on the interval $[-1,1]$ using Chebyshev–Gauss–Lobatto points. The goal is to construct a first-order Chebyshev differentiation matrix based on these points, use it to assemble a discrete second derivative operator subject to homogeneous Dirichlet boundary conditions, and then study the conditioning and accuracy of the resulting linear system for a model problem.\n\nStart from the following fundamental base:\n- The Chebyshev polynomials of the first kind satisfy $T_k(x) = \\cos(k \\arccos x)$ for integer $k \\ge 0$.\n- Chebyshev–Gauss–Lobatto collocation points on $[-1,1]$ are defined by $x_j = \\cos\\left(\\frac{\\pi j}{N-1}\\right)$ for integer indices $j = 0,1,\\dots,N-1$, where $N$ is the number of collocation points.\n- Polynomial interpolation in the Lagrange basis represents an approximant $p(x) = \\sum_{j=0}^{N-1} u_j \\ell_j(x)$ where $\\ell_j(x)$ are the Lagrange basis polynomials at the collocation points, and differentiation at nodes is realized by a differentiation matrix $D$ whose entries come from differentiating the interpolant and evaluating at nodes.\n- The spectral collocation method for the second derivative constructs a matrix $D^{(2)} = D D$ that maps nodal values to nodal second derivatives of the interpolant.\n- The $2$-norm condition number of a nonsingular matrix $A$ is $\\kappa_2(A) = \\|A\\|_2 \\|A^{-1}\\|_2$.\n- Trigonometric functions are to be interpreted in radians.\n\nTasks:\n1. For a given integer $N \\ge 3$, construct the Chebyshev–Gauss–Lobatto collocation points $x_j$ for $j = 0,1,\\dots,N-1$ on $[-1,1]$.\n2. Using the definition of Lagrange interpolation and the identity that the derivative of the interpolant evaluated at the nodes can be expressed via a differentiation matrix, derive and implement the Chebyshev first-order differentiation matrix $D \\in \\mathbb{R}^{N \\times N}$ whose off-diagonal entries are rational functions of the nodes and whose diagonal entries enforce exact differentiation of the interpolant at nodes by the requirement that each row sums to zero.\n3. Form the discrete second derivative matrix $D^{(2)} = D D$, and impose the homogeneous Dirichlet boundary conditions $u(-1) = 0$ and $u(1) = 0$ by restricting to the interior indices $1,2,\\dots,N-2$, producing the interior operator $A \\in \\mathbb{R}^{(N-2)\\times(N-2)}$ obtained by deleting the first and last rows and columns of $D^{(2)}$.\n4. Consider the boundary value problem $u''(x) = f(x)$ on $[-1,1]$ with $u(-1)=0$ and $u(1)=0$ where $f(x) = \\pi^2 \\sin(\\pi x)$ and the exact solution is $u(x) = \\sin(\\pi x)$. Assemble the interior right-hand side vector by evaluating $f(x)$ at the interior nodes $x_j$ for $j=1,2,\\dots,N-2$, and solve the linear system $A \\mathbf{u}_{\\mathrm{int}} = \\mathbf{f}_{\\mathrm{int}}$ for the interior nodal values $\\mathbf{u}_{\\mathrm{int}}$. Recover the full nodal vector by setting endpoints to zero and placing the interior solution at the corresponding indices.\n5. Compute the $2$-norm condition number $\\kappa_2(A)$ and the maximum absolute nodal error $\\max_{0 \\le j \\le N-1} |u(x_j) - u_j|$, where $u(x) = \\sin(\\pi x)$ is the exact solution and $u_j$ are the computed nodal values. All trigonometric evaluations must use radians.\n6. Provide results for the following test suite of values of $N$: $N \\in \\{3,8,20,64\\}$, which jointly probe a boundary case with minimal interior ($N=3$), a small problem ($N=8$), a moderate problem ($N=20$), and a larger problem ($N=64$) to examine conditioning growth and accuracy trends.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must aggregate, in order, for each $N$ in the test suite, first the condition number $\\kappa_2(A)$ as a floating-point number, then the maximum absolute nodal error as a floating-point number. The final list should have length $2 \\times 4 = 8$, following the order $[ \\kappa_2(A;N{=}3), \\mathrm{err}(N{=}3), \\kappa_2(A;N{=}8), \\mathrm{err}(N{=}8), \\kappa_2(A;N{=}20), \\mathrm{err}(N{=}20), \\kappa_2(A;N{=}64), \\mathrm{err}(N{=}64) ]$.", "solution": "The user has provided a well-defined computational problem in the field of numerical analysis, specifically concerning the application of Chebyshev spectral collocation methods to solve a second-order boundary value problem. The problem is scientifically grounded, self-contained, and logically consistent. No flaws were identified during validation.\n\nThe problem asks for the construction of a Chebyshev differentiation matrix, its use in discretizing a differential operator, the solution of the resulting linear system for a model problem, and an analysis of the conditioning and accuracy for a specified set of problem sizes.\n\nThe solution proceeds by implementing the steps outlined in the problem statement.\n\n**Step 1: Chebyshev–Gauss–Lobatto Collocation Points**\n\nFor a given number of collocation points, $N$, the Chebyshev–Gauss–Lobatto (CGL) points on the interval $[-1, 1]$ are defined as the extrema of the $(N-1)$-th degree Chebyshev polynomial $T_{N-1}(x)$. These points are given by the formula:\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N-1}\\right) \\quad \\text{for } j = 0, 1, \\dots, N-1.\n$$\nThese points are indexed such that $x_0 = 1$ and $x_{N-1} = -1$. The set of points $\\{x_j\\}$ is symmetric with respect to the origin. For applying homogeneous Dirichlet boundary conditions, the interior points are $\\{x_j\\}_{j=1}^{N-2}$.\n\n**Step 2: First-Order Chebyshev Differentiation Matrix ($D$)**\n\nA function $u(x)$ approximated on the CGL grid $\\{x_j\\}$ is represented by a unique polynomial interpolant $p(x)$ of degree at most $N-1$ passing through the nodal values $\\{u_j\\}$, where $u_j = u(x_j)$. The derivative of this interpolant, when evaluated at the grid points, can be expressed as a matrix-vector product, $\\mathbf{p}' = D\\mathbf{u}$, where $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$ and $\\mathbf{p}' = [p'(x_0), p'(x_1), \\dots, p'(x_{N-1})]^T$. The matrix $D \\in \\mathbb{R}^{N \\times N}$ is the Chebyshev first-order differentiation matrix.\n\nThe entries of $D$, denoted $D_{kj}$, are given by standard formulas. The off-diagonal entries ($k \\neq j$) are:\n$$\nD_{kj} = \\frac{c_k}{c_j} \\frac{(-1)^{k+j}}{x_k - x_j}, \\quad k, j = 0, \\dots, N-1,\n$$\nwhere the weights $c_k$ are defined as:\n$$\nc_k = \\begin{cases} 2 & \\text{if } k=0 \\text{ or } k=N-1 \\\\ 1 & \\text{otherwise} \\end{cases}\n$$\nThe problem specifies that the diagonal entries $D_{kk}$ are to be determined by the property that the differentiation matrix must map a constant function to its zero derivative. This implies that for any row $k$, the sum of its entries must be zero: $\\sum_{j=0}^{N-1} D_{kj} = 0$. Therefore, the diagonal entries can be computed as:\n$$\nD_{kk} = - \\sum_{j=0, j \\neq k}^{N-1} D_{kj}.\n$$\nThis procedure allows for a robust construction of the differentiation matrix $D$.\n\n**Step 3: Second-Order Operator ($A$) for Dirichlet Boundary Conditions**\n\nThe second derivative of the interpolant can be obtained by applying the first-order differentiation matrix twice. The corresponding second-order differentiation matrix is $D^{(2)} = D \\cdot D$. The discretization of the differential equation $u''(x) = f(x)$ at the nodes becomes the linear system $D^{(2)} \\mathbf{u} = \\mathbf{f}$.\n\nThe problem specifies homogeneous Dirichlet boundary conditions, $u(-1) = 0$ and $u(1) = 0$. In our grid, this corresponds to $u(x_{N-1})=0$ and $u(x_0)=0$, or $u_{N-1}=0$ and $u_0=0$. These conditions are imposed on the algebraic system. We only need to solve for the unknown values at the interior nodes, $\\{u_j\\}_{j=1}^{N-2}$.\n\nThe equations for the interior nodes $i=1, \\dots, N-2$ are:\n$$\n\\sum_{j=0}^{N-1} (D^{(2)})_{ij} u_j = f_i\n$$\nSubstituting the known boundary values $u_0 = 0$ and $u_{N-1} = 0$, the system reduces to:\n$$\n\\sum_{j=1}^{N-2} (D^{(2)})_{ij} u_j = f_i\n$$\nThis can be written as a smaller linear system $A \\mathbf{u}_{\\mathrm{int}} = \\mathbf{f}_{\\mathrm{int}}$, where:\n- $A$ is the $(N-2) \\times (N-2)$ submatrix of $D^{(2)}$ obtained by selecting rows and columns with indices $1, \\dots, N-2$.\n- $\\mathbf{u}_{\\mathrm{int}} = [u_1, u_2, \\dots, u_{N-2}]^T$ is the vector of unknown interior nodal values.\n- $\\mathbf{f}_{\\mathrm{int}} = [f_1, f_2, \\dots, f_{N-2}]^T$ is the vector of the forcing function $f(x)$ evaluated at the interior nodes.\n\n**Step 4: Solving the Model Boundary Value Problem**\n\nThe specific BVP is $u''(x) = \\pi^2 \\sin(\\pi x)$ on $[-1, 1]$ with $u(-1) = u(1) = 0$. The exact solution is given as $u(x) = \\sin(\\pi x)$.\nThe forcing function is $f(x) = \\pi^2 \\sin(\\pi x)$. The vector $\\mathbf{f}_{\\mathrm{int}}$ is constructed by evaluating $f(x)$ at the interior CGL points:\n$$\nf_j = \\pi^2 \\sin(\\pi x_j) \\quad \\text{for } j = 1, \\dots, N-2.\n$$\nThe linear system $A \\mathbf{u}_{\\mathrm{int}} = \\mathbf{f}_{\\mathrm{int}}$ is then solved to find the numerical solution $\\mathbf{u}_{\\mathrm{int}}$ at the interior nodes. The full solution vector $\\mathbf{u}$ is assembled by augmenting $\\mathbf{u}_{\\mathrm{int}}$ with the zero boundary values: $\\mathbf{u} = [0, u_1, \\dots, u_{N-2}, 0]^T$.\n\n**Step 5: Computing Condition Number and Error**\n\nTwo quantities are computed to analyze the method's performance:\n1.  **Condition Number:** The $2$-norm condition number of the interior operator $A$, $\\kappa_2(A) = \\|A\\|_2 \\|A^{-1}\\|_2$. This measures the sensitivity of the solution of the linear system to perturbations in the right-hand side. A large condition number indicates potential numerical instability.\n2.  **Maximum Nodal Error:** The accuracy of the spectral method is assessed by comparing the computed nodal values $u_j$ with the exact solution values $u(x_j) = \\sin(\\pi x_j)$. The maximum absolute error over all nodes is calculated as:\n    $$\n    E_{\\max} = \\max_{0 \\le j \\le N-1} |u(x_j) - u_j|.\n    $$\n\n**Step 6: Execution for the Test Suite**\n\nThe procedure described in Steps 1-5 is executed for each value of $N$ in the test suite $\\{3, 8, 20, 64\\}$. For each $N$, the pair of results $(\\kappa_2(A), E_{\\max})$ is computed and stored. The final output is an aggregation of these pairs in the specified order. For $N=3$, the interior operator $A$ is a $1 \\times 1$ matrix (a scalar), so its condition number is $1$. The right-hand side at the single interior point $x_1=0$ is $f(0)=0$, leading to a numerical solution $u_1=0$, which is exact, so the error is $0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Chebyshev spectral collocation problem for a set of N values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [3, 8, 20, 64]\n    results = []\n\n    for N in test_cases:\n        # Step 1: Construct Chebyshev–Gauss–Lobatto collocation points\n        j = np.arange(N)\n        x = np.cos(np.pi * j / (N - 1))\n\n        # Step 2: Construct the Chebyshev first-order differentiation matrix D\n        D = np.zeros((N, N))\n        c = np.ones(N)\n        c[0] = 2.0\n        c[-1] = 2.0\n\n        for k in range(N):\n            for i in range(N):\n                if k != i:\n                    D[k, i] = (c[k] / c[i]) * ((-1)**(k + i)) / (x[k] - x[i])\n        \n        # Enforce zero row sums by setting diagonal elements\n        for k in range(N):\n            D[k, k] = -np.sum(D[k, :])\n\n        # Step 3: Form the discrete second derivative matrix and interior operator A\n        D2 = D @ D\n        A = D2[1:-1, 1:-1]\n\n        # Step 4: Assemble the RHS and solve the linear system for the BVP\n        # BVP: u''(x) = pi^2 * sin(pi*x) with u(-1)=0, u(1)=0\n        x_int = x[1:-1]\n        f_int = (np.pi**2) * np.sin(np.pi * x_int)\n        \n        # For N=3, the interior is one point (x=0), so f_int is a scalar 0.\n        # np.linalg.solve handles 1x1 systems correctly.\n        u_int = np.linalg.solve(A, f_int)\n        \n        # Recover the full nodal solution vector\n        u_computed = np.zeros(N)\n        u_computed[1:-1] = u_int\n\n        # Step 5: Compute the condition number of A and the maximum nodal error\n        # For N=3, A is a scalar, so cond(A) is 1.0.\n        if N == 3:\n            cond_A = 1.0\n        else:\n            cond_A = np.linalg.cond(A, 2)\n            \n        u_exact = np.sin(np.pi * x)\n        max_error = np.max(np.abs(u_exact - u_computed))\n\n        # Append results for the current N\n        results.append(cond_A)\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3277690"}, {"introduction": "When we use spectral methods to discretize time-dependent partial differential equations, we transform the PDE into a large system of ordinary differential equations (ODEs). For problems like the diffusion equation ($u_t = \\nu u_{xx}$), this system is often \"stiff,\" meaning the time step of an explicit integrator is severely restricted for stability. This exercise [@problem_id:3277778] directly contrasts the behavior of an explicit scheme (RK4) with an implicit one (Crank-Nicolson), demonstrating why the choice of time integrator is critically linked to the properties of the spectral operator.", "problem": "You are to implement and compare two time integration schemes combined with a Fourier spectral discretization in space for the one-dimensional diffusion equation\n$$\nu_t(x,t) = \\nu\\,u_{xx}(x,t), \\quad x \\in [0,2\\pi), \\ t \\ge 0,\n$$\nwith periodic boundary condition and a smooth periodic initial condition. The two schemes are the classical fourth-order Runge–Kutta (RK4) method and the Crank–Nicolson method, both applied to the spatially discretized system obtained from the Fourier spectral method. The objective is to quantify and compare the accuracy and practical stability behavior at small viscosity coefficient values.\n\nFundamental base and setting:\n- Use the standard Fourier series representation on a periodic domain, where differentiation corresponds to multiplication in Fourier space. Specifically, for a mode with wavenumber $k$, the second derivative operator corresponds to multiplication by $-k^2$. Implement the spatial discretization using the Fast Fourier Transform (FFT).\n- Use the classical definitions of the RK4 method and the Crank–Nicolson method as time integrators applied to the semi-discrete system. Do not assume any pre-derived closed-form update formulas in Fourier space; derive what is necessary from the definitions.\n- The spatial domain is $[0,2\\pi)$ with periodic boundary conditions. Angles are in radians.\n- The initial condition is\n$$\nu(x,0) = \\sin(3x) + 0.5\\cos(5x) + 0.25\\sin(16x).\n$$\n\nImplementation requirements:\n- Use a uniform grid with $N$ points on $[0,2\\pi)$, $x_j = \\frac{2\\pi j}{N}$ for $j \\in \\{0,1,\\dots,N-1\\}$.\n- Use the Fourier spectral discretization to evaluate $u_{xx}$ as follows: if $\\widehat{u}$ denotes the discrete Fourier transform of $u$, then the Fourier transform of $u_{xx}$ is $-(k^2)\\widehat{u}$, where $k$ is the integer-valued wavenumber associated with each Fourier mode obtained from the FFT frequency conventions on $[0,2\\pi)$.\n- Implement two time steppers for the semi-discrete system:\n  1. Classical fourth-order Runge–Kutta (RK4), using the semi-discrete right-hand side $f(u) = \\nu u_{xx}$ evaluated via the spectral derivative.\n  2. Crank–Nicolson, applied to the linear semi-discrete system, solved exactly per Fourier mode at each step using the diagonalization in Fourier space that follows from the Fourier spectral method.\n- For each run, advance from time $t=0$ to time $t=T$ using exactly $n$ steps of size $\\Delta t = T/n$. For the test suite given below, $T/\\Delta t$ is an integer so that $\\Delta t$ need not be adjusted.\n- Compute the reference solution at $t=T$ spectrally in closed form by evolving the initial spectrum mode-by-mode under the exact linear flow. Specifically, if $\\widehat{u}_k(0)$ denotes the Fourier coefficient of the initial condition at mode $k$, then use the fundamental solution of the linear ordinary differential equation to obtain $\\widehat{u}_k(T)$ and then transform back to obtain $u(x,T)$.\n- Measure the error for each method as the relative discrete $L^2$ error at final time,\n$$\nE = \\frac{\\left\\| u_{\\text{num}}(\\cdot,T) - u_{\\text{exact}}(\\cdot,T) \\right\\|_2}{\\left\\| u_{\\text{exact}}(\\cdot,T) \\right\\|_2},\n$$\nwhere the discrete $L^2$ norm is taken over the grid points. Use a consistent normalization so that any common proportionality constants cancel in the ratio.\n- If the RK4 numerical solution exhibits instability (e.g., non-finite values during time stepping or unbounded growth that is clearly non-physical for diffusion), report a large finite error, for example $10^{99}$, instead of a non-finite value.\n\nTest suite:\nFor each parameter set $(N,\\nu,\\Delta t,T)$ below, compute two numbers: the relative error for RK4 and the relative error for Crank–Nicolson, in that order.\n\n- Test $1$: $N=64$, $\\nu=10^{-3}$, $\\Delta t=5\\times 10^{-3}$, $T=5\\times 10^{-2}$.\n- Test $2$: $N=64$, $\\nu=10^{-5}$, $\\Delta t=5\\times 10^{-2}$, $T=5\\times 10^{-1}$.\n- Test $3$: $N=256$, $\\nu=10^{-3}$, $\\Delta t=5\\times 10^{-3}$, $T=5\\times 10^{-2}$.\n- Test $4$: $N=512$, $\\nu=10^{-3}$, $\\Delta t=4\\times 10^{-2}$, $T=2\\times 10^{-1}$.\n- Test $5$: $N=512$, $\\nu=10^{-3}$, $\\Delta t=6\\times 10^{-2}$, $T=3\\times 10^{-1}$.\n\nFinal output specification:\n- Your program must run all five tests in order and produce a single line of output containing the results as a comma-separated flat list of $10$ floating-point numbers enclosed in square brackets, in the following order:\n$$\n[\\ E_{\\text{RK4}}^{(1)},\\ E_{\\text{CN}}^{(1)},\\ E_{\\text{RK4}}^{(2)},\\ E_{\\text{CN}}^{(2)},\\ E_{\\text{RK4}}^{(3)},\\ E_{\\text{CN}}^{(3)},\\ E_{\\text{RK4}}^{(4)},\\ E_{\\text{CN}}^{(4)},\\ E_{\\text{RK4}}^{(5)},\\ E_{\\text{CN}}^{(5)}\\ ].\n$$\n- Angles must be treated in radians throughout.\n- Each floating-point number should be printed in standard decimal or scientific notation. Do not print any additional text or characters beyond the specified list format.", "solution": "We begin from the periodic diffusion equation\n$$\nu_t(x,t) = \\nu\\,u_{xx}(x,t), \\quad x \\in [0,2\\pi), \\ t \\ge 0,\n$$\nwith periodic boundary conditions and initial condition\n$$\nu(x,0) = \\sin(3x) + 0.5\\cos(5x) + 0.25\\sin(16x),\n$$\nwhere all angles are in radians. The Fourier spectral method expresses $u(x,t)$ as a finite Fourier series on a uniform grid of $N$ points $x_j = 2\\pi j/N$, $j \\in \\{0,1,\\dots,N-1\\}$. Let $\\widehat{u}_k(t)$ denote the discrete Fourier coefficient for wavenumber $k$, with integer $k$ determined by the Fast Fourier Transform (FFT) conventions. For sufficiently smooth solutions, differentiation in physical space corresponds to multiplication by powers of $ik$ in Fourier space. In particular,\n$$\n\\mathcal{F}\\{u_{xx}\\}(k,t) = -(k^2)\\widehat{u}_k(t),\n$$\nso the Fourier coefficients satisfy the linear ordinary differential equation (ODE)\n$$\n\\frac{d}{dt}\\widehat{u}_k(t) = -\\nu k^2 \\widehat{u}_k(t).\n$$\nThis decouples per mode. The exact solution per mode is given by the fundamental theorem for linear ODEs:\n$$\n\\widehat{u}_k(t) = e^{-\\nu k^2 t}\\,\\widehat{u}_k(0).\n$$\nTherefore, the exact solution at time $T$ is obtained by computing $\\widehat{u}_k(0)$ via the FFT of $u(x,0)$, multiplying each coefficient by $e^{-\\nu k^2 T}$, and transforming back via the inverse FFT.\n\nTo time step the semi-discrete system in physical space, we evaluate $u_{xx}$ spectrally. Given a grid function $u$, we compute its discrete Fourier transform $\\widehat{u}$, multiply by $-(k^2)$ mode-wise to obtain the Fourier representation of $u_{xx}$, and transform back to real space. This implements the semi-discrete right-hand side\n$$\nf(u) = \\nu\\,u_{xx},\n$$\nin a spectrally accurate manner for sufficiently smooth $u$.\n\nTime integrators:\n\n1. Classical fourth-order Runge–Kutta (RK4): Given $u^n \\approx u(\\cdot,t_n)$ and time step $\\Delta t$, RK4 computes\n$$\n\\begin{aligned}\nk_1 &= f(u^n),\\\\\nk_2 &= f\\!\\left(u^n + \\tfrac{\\Delta t}{2} k_1\\right),\\\\\nk_3 &= f\\!\\left(u^n + \\tfrac{\\Delta t}{2} k_2\\right),\\\\\nk_4 &= f\\!\\left(u^n + \\Delta t\\, k_3\\right),\\\\\nu^{n+1} &= u^n + \\tfrac{\\Delta t}{6}\\left(k_1 + 2k_2 + 2k_3 + k_4\\right).\n\\end{aligned}\n$$\nFor a linear mode $y'=\\lambda y$, the RK4 amplification factor is\n$$\nG_{\\text{RK4}}(z) = 1 + z + \\tfrac{z^2}{2} + \\tfrac{z^3}{6} + \\tfrac{z^4}{24}, \\quad z=\\lambda \\Delta t.\n$$\nIn our case, $\\lambda_k = -\\nu k^2$ is real and nonpositive, and stability requires $|G_{\\text{RK4}}(z_k)| \\le 1$ for all relevant $k$. Along the negative real axis, this imposes an upper bound on $\\Delta t$ proportional to $1/(\\nu k_{\\max}^2)$. If $\\Delta t$ is too large, the numerical solution can blow up due to exiting the stability region; in such cases we detect non-finite values or explosive growth and report a large finite error surrogate.\n\n2. Crank–Nicolson: Applying the trapezoidal rule to the linear ODE $u_t = \\nu u_{xx}$ yields\n$$\n\\left(I - \\tfrac{\\Delta t}{2}\\nu \\partial_{xx}\\right) u^{n+1} = \\left(I + \\tfrac{\\Delta t}{2}\\nu \\partial_{xx}\\right) u^n.\n$$\nIn Fourier space, since $\\partial_{xx}$ diagonalizes with symbol $-k^2$, the per-mode update becomes\n$$\n\\widehat{u}^{\\,n+1}_k = \\frac{1 - \\tfrac{\\Delta t}{2}\\nu k^2}{1 + \\tfrac{\\Delta t}{2}\\nu k^2}\\,\\widehat{u}^{\\,n}_k.\n$$\nThis is unconditionally stable for the diffusion equation because the magnitude of the factor is strictly less than or equal to $1$ for $\\nu > 0$ and $k \\ne 0$. The method is second-order accurate in time.\n\nReference solution and error:\nThe exact final spectrum is $\\widehat{u}_k(T) = e^{-\\nu k^2 T}\\widehat{u}_k(0)$. Transforming back yields $u_{\\text{exact}}(\\cdot,T)$. For a numerical solution $u_{\\text{num}}(\\cdot,T)$, define the relative discrete $L^2$ error\n$$\nE = \\frac{\\left(\\sum_{j=0}^{N-1} \\left|u_{\\text{num}}(x_j,T) - u_{\\text{exact}}(x_j,T)\\right|^2\\right)^{1/2}}{\\left(\\sum_{j=0}^{N-1} \\left|u_{\\text{exact}}(x_j,T)\\right|^2\\right)^{1/2}}.\n$$\nBecause the same grid and uniform weights are used in numerator and denominator, any common factor from the quadrature cancels in the ratio.\n\nAlgorithmic design:\n- Build the uniform grid on $[0,2\\pi)$ with $N$ points and precompute the wavenumber array $k$ using the FFT frequency conventions, scaled to angular wavenumbers so that the Fourier symbol of $\\partial_x$ is $ik$ and that of $\\partial_{xx}$ is $-k^2$.\n- Implement a function that maps a real grid function $u$ to $u_{xx}$ spectrally by FFT, diagonal multiplication by $-k^2$, and inverse FFT, taking the real part.\n- Implement an RK4 step that calls the spectral right-hand side $f(u)=\\nu u_{xx}$.\n- Implement a Crank–Nicolson step that operates mode-wise in Fourier space via multiplication by the rational factor derived above.\n- For each test case $(N,\\nu,\\Delta t,T)$, construct $u(x,0)$, compute $u_{\\text{exact}}(\\cdot,T)$ by evolving the initial spectrum with $e^{-\\nu k^2 T}$, advance $n=T/\\Delta t$ steps with RK4 and with Crank–Nicolson, and compute the two relative errors. If RK4 exhibits instability (non-finite values or explosive growth inconsistent with diffusion), set its error to a large finite surrogate such as $10^{99}$.\n- Output the $10$ errors for the five tests as a flat list in the prescribed order and format.\n\nExpected qualitative outcomes:\n- For tests with sufficiently small $\\Delta t$, both methods should be stable, with RK4 exhibiting fourth-order temporal accuracy and Crank–Nicolson exhibiting second-order temporal accuracy; therefore RK4 should be more accurate at the same $\\Delta t$ when stable.\n- Near the RK4 stability boundary, RK4 error generally increases and instability can occur if $\\Delta t$ is too large relative to $\\nu$ and the maximum resolved wavenumber. Crank–Nicolson remains stable for all step sizes due to its unconditional stability for linear diffusion, although its temporal accuracy remains second order.\n\nThis completes the derivation and the algorithmic plan consistent with the Fourier spectral method and the properties of the two time integrators.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef spectral_wavenumbers(N, L=2*np.pi):\n    # Angular wavenumbers on [0, L) so that d/dx -> i*k and d2/dx2 -> -(k^2)\n    k = 2.0 * np.pi * np.fft.fftfreq(N, d=L / N)\n    return k\n\ndef laplacian_spectral(u, k2):\n    # Compute u_xx via FFT: F(u_xx) = -(k^2) * F(u)\n    u_hat = np.fft.fft(u)\n    lap_hat = -(k2) * u_hat\n    lap = np.fft.ifft(lap_hat).real\n    return lap\n\ndef rk4_step(u, dt, nu, k2):\n    # One RK4 step for u_t = nu * u_xx, spatial operator via spectral method\n    k1 = nu * laplacian_spectral(u, k2)\n    k2v = nu * laplacian_spectral(u + 0.5 * dt * k1, k2)\n    k3v = nu * laplacian_spectral(u + 0.5 * dt * k2v, k2)\n    k4v = nu * laplacian_spectral(u + dt * k3v, k2)\n    return u + (dt / 6.0) * (k1 + 2.0 * k2v + 2.0 * k3v + k4v)\n\ndef cn_step(u, dt, nu, k2):\n    # One Crank–Nicolson step in Fourier space\n    u_hat = np.fft.fft(u)\n    # Per-mode factor: (1 - 0.5*dt*nu*k^2)/(1 + 0.5*dt*nu*k^2)\n    factor_num = 1.0 - 0.5 * dt * nu * k2\n    factor_den = 1.0 + 0.5 * dt * nu * k2\n    G = factor_num / factor_den\n    u_hat_new = G * u_hat\n    return np.fft.ifft(u_hat_new).real\n\ndef exact_solution(u0, T, nu, k2):\n    # Exact spectral evolution: u_hat(T) = exp(-nu*k^2*T) * u_hat(0)\n    u0_hat = np.fft.fft(u0)\n    decay = np.exp(-nu * k2 * T)\n    uT_hat = decay * u0_hat\n    uT = np.fft.ifft(uT_hat).real\n    return uT\n\ndef rel_l2_error(u_num, u_ref):\n    num = np.linalg.norm(u_num - u_ref)\n    den = np.linalg.norm(u_ref)\n    # Guard against den = 0 (should not happen for given IC and parameters)\n    if den == 0.0:\n        return float('inf') if num != 0.0 else 0.0\n    return num / den\n\ndef initial_condition(x):\n    # Angles in radians\n    return np.sin(3.0 * x) + 0.5 * np.cos(5.0 * x) + 0.25 * np.sin(16.0 * x)\n\ndef run_case(N, nu, dt, T):\n    L = 2.0 * np.pi\n    x = np.linspace(0.0, L, N, endpoint=False)\n    k = spectral_wavenumbers(N, L=L)\n    k2 = k * k\n\n    u0 = initial_condition(x)\n    u_exact = exact_solution(u0, T, nu, k2)\n\n    # Time stepping parameters (T/dt is integer by construction in test suite)\n    nsteps = int(round(T / dt))\n    dt_eff = T / nsteps  # exactly equals dt for provided test cases\n\n    # RK4 time stepping\n    u_rk4 = u0.copy()\n    rk4_unstable = False\n    for _ in range(nsteps):\n        u_rk4 = rk4_step(u_rk4, dt_eff, nu, k2)\n        # Detect instability: non-finite or explosive growth (non-physical for diffusion)\n        if not np.all(np.isfinite(u_rk4)) or np.max(np.abs(u_rk4)) > 1e12:\n            rk4_unstable = True\n            break\n    if rk4_unstable:\n        err_rk4 = 1e99\n    else:\n        err_rk4 = rel_l2_error(u_rk4, u_exact)\n\n    # Crank–Nicolson time stepping\n    u_cn = u0.copy()\n    for _ in range(nsteps):\n        u_cn = cn_step(u_cn, dt_eff, nu, k2)\n    err_cn = rel_l2_error(u_cn, u_exact)\n\n    return err_rk4, err_cn\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, nu, dt, T)\n    test_cases = [\n        (64, 1e-3, 5e-3, 5e-2),   # Test 1\n        (64, 1e-5, 5e-2, 5e-1),   # Test 2\n        (256, 1e-3, 5e-3, 5e-2),  # Test 3\n        (512, 1e-3, 4e-2, 2e-1),  # Test 4\n        (512, 1e-3, 6e-2, 3e-1),  # Test 5 (RK4 expected near/over stability limit)\n    ]\n\n    results = []\n    for N, nu, dt, T in test_cases:\n        err_rk4, err_cn = run_case(N, nu, dt, T)\n        results.append(err_rk4)\n        results.append(err_cn)\n\n    # Final print statement in the exact required format.\n    # Use scientific notation for reproducibility.\n    print(\"[\" + \",\".join(f\"{val:.12e}\" for val in results) + \"]\")\n\nsolve()\n```", "id": "3277778"}, {"introduction": "Moving into the realm of nonlinear dynamics, this practice tackles the Burgers' equation, a fundamental model for phenomena like shock waves and turbulence. You will implement a pseudospectral method, where nonlinear terms are computed in physical space before transforming back to spectral space, a process that introduces a numerical artifact called aliasing error [@problem_id:3277726]. Through this exercise, you will explore how aliasing can lead to instability and test two essential stabilization techniques used in modern scientific computing: the $2/3$ de-aliasing rule and scale-selective hyperviscosity.", "problem": "Consider the one-dimensional inviscid Burgers surrogate for turbulence on a periodic domain with an optional hyperviscosity stabilizer. The governing equation is\n$$\n\\partial_t u(x,t) + \\partial_x \\left(\\tfrac{1}{2} u(x,t)^2\\right) \\;=\\; - \\nu_p \\, (-\\Delta)^p u(x,t),\n$$\nposed on the interval $[0,2\\pi]$ with periodic boundary conditions, where $x \\in [0,2\\pi]$ (angles in radians), $t \\ge 0$, $\\nu_p \\ge 0$ is a hyperviscosity coefficient, and $p \\in \\mathbb{N}$ controls the order of the hyperviscosity. The domain length is $2\\pi$. The initial condition is\n$$\nu(x,0) \\;=\\; \\sin(x) + \\tfrac{1}{2}\\sin(2x).\n$$\nYour task is to design and implement a fully spectral pseudospectral solver based on the following foundational principles and definitions.\n\n1) Fundamental spectral representation and differentiation. Represent $u(x,t)$ by a truncated complex Fourier series with $N$ equispaced grid points $x_j = 2\\pi j/N$ for $j = 0,1,\\dots,N-1$. Denote the discrete Fourier transform by $\\widehat{u}_k(t)$ indexed by integer wavenumbers $k \\in \\{-N/2+1,\\dots,-1,0,1,\\dots,N/2\\}$ (with the usual wrap-around when $N$ is even). The spatial derivative obeys the spectral rule\n$$\n\\widehat{\\partial_x u}_k(t) = i k \\, \\widehat{u}_k(t),\n$$\nbecause $\\partial_x e^{i k x} = i k e^{i k x}$ on $[0,2\\pi]$.\n\n2) Nonlinear term and aliasing. The nonlinearity is the conservative form $-\\partial_x \\left(\\tfrac{1}{2} u^2\\right)$. In a pseudospectral method, compute $u(x_j,t)$ by an inverse transform, form $q(x_j,t) = \\tfrac{1}{2} u(x_j,t)^2$ pointwise, transform to $\\widehat{q}_k(t)$, and then set the nonlinear spectral term to\n$$\n\\widehat{\\mathcal{N}}_k(t) = - i k \\, \\widehat{q}_k(t).\n$$\nAt finite resolution $N$, this pointwise product causes aliasing errors that can corrupt energy transfer and lead to nonphysical backscatter. A classical stabilization is the $2/3$ de-aliasing rule: define a spectral mask that sets to zero all modes with $|k| > N/3$ when evaluating the nonlinear term. Concretely, when de-aliasing is enabled, use the mask twice in the nonlinear evaluation, first by zeroing high modes of $\\widehat{u}_k$ before transforming to physical space, and then by zeroing high modes of $\\widehat{q}_k$ before multiplying by $i k$.\n\n3) Hyperviscosity stabilizer. The hyperviscosity operator is defined spectrally by\n$$\n-\\nu_p \\left(-\\Delta\\right)^p u \\;\\;\\Longleftrightarrow\\;\\; - \\nu_p \\, |k|^{2p}\\, \\widehat{u}_k \\quad \\text{for each mode } k,\n$$\nsince $-\\Delta$ has Fourier symbol $|k|^2$ in one spatial dimension on $[0,2\\pi]$. This term provides scale-selective damping that suppresses high-wavenumber oscillations.\n\n4) Time discretization. Advance the semi-discrete system $\\partial_t \\widehat{u}_k = \\widehat{\\mathcal{N}}_k - \\nu_p |k|^{2p} \\widehat{u}_k$ with a fixed-step explicit Runge–Kutta method of order four (classical Runge–Kutta), using a constant time step $\\Delta t$ over the interval $[0,T]$. All transforms should be evaluated consistently on the same grid. When de-aliasing is enabled, after each full time step also project the updated $\\widehat{u}_k$ onto the $2/3$-retained set of modes by zeroing all modes with $|k| > N/3$.\n\n5) Energy diagnostics. Define the total energy at time $t$ by the spatial average\n$$\nE(t) = \\tfrac{1}{2} \\,\\frac{1}{2\\pi}\\int_{0}^{2\\pi} u(x,t)^2 \\, dx,\n$$\nwhich, in a discrete pseudospectral method with $N$ points, is computed as\n$$\nE(t) = \\tfrac{1}{2} \\cdot \\frac{1}{N} \\sum_{j=0}^{N-1} u(x_j,t)^2.\n$$\nAlso define a low-wavenumber band energy\n$$\nE_{\\mathrm{low}}(t) = \\tfrac{1}{2} \\sum_{1 \\le |k| \\le k_{\\ast}} \\mathcal{E}_k(t),\n$$\nwhere $\\mathcal{E}_k(t)$ is the discrete spectral energy density consistent with Parseval’s theorem. To avoid ambiguity, compute $E_{\\mathrm{low}}(t)$ from the discrete Fourier coefficients $\\widehat{u}_k(t)$ using\n$$\nE_{\\mathrm{low}}(t) = \\tfrac{1}{2} \\cdot \\frac{1}{N^2} \\sum_{1 \\le |k| \\le k_{\\ast}} \\left|\\widehat{u}_k(t)\\right|^2,\n$$\nwhich is consistent with $E(t) = \\tfrac{1}{2} \\cdot \\frac{1}{N^2}\\sum_k |\\widehat{u}_k(t)|^2$ and $E(t) = \\tfrac{1}{2}\\cdot \\frac{1}{N}\\sum_j u(x_j,t)^2$ by discrete Parseval. Use $k_{\\ast} = 4$.\n\n6) Investigation goals. You will investigate aliasing-driven backscatter and the stabilizing effect of hyperviscosity by comparing the drift in total energy and the drift in low-wavenumber band energy across several configurations. For each configuration, compute the two quantitative diagnostics:\n- $\\Delta E = E(T) - E(0)$,\n- $\\Delta E_{\\mathrm{low}} = E_{\\mathrm{low}}(T) - E_{\\mathrm{low}}(0)$.\n\n7) Implementation and test suite. Implement the full program described above and run it on the following parameter sets. All angles are in radians. Use $N=64$, $T=0.4$, and $\\Delta t = 5\\times 10^{-4}$ in every case, with the same initial condition $u(x,0) = \\sin(x) + \\tfrac{1}{2}\\sin(2x)$.\n- Case A (aliased, no hyperviscosity): de-aliasing disabled; $\\nu_p = 0$.\n- Case B (de-aliased, no hyperviscosity): de-aliasing enabled with the $2/3$ rule; $\\nu_p = 0$.\n- Case C (aliased, with hyperviscosity): de-aliasing disabled; hyperviscosity enabled with $p=4$ and $\\nu_p = 10^{-18}$.\n- Case D (de-aliased, with hyperviscosity): de-aliasing enabled with the $2/3$ rule; hyperviscosity enabled with $p=4$ and $\\nu_p = 10^{-18}$.\n\n8) Final output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, the eight floating-point numbers\n$$\n[\\Delta E\\_{\\mathrm{A}}, \\Delta E\\_{\\mathrm{low},\\mathrm{A}}, \\Delta E\\_{\\mathrm{B}}, \\Delta E\\_{\\mathrm{low},\\mathrm{B}}, \\Delta E\\_{\\mathrm{C}}, \\Delta E\\_{\\mathrm{low},\\mathrm{C}}, \\Delta E\\_{\\mathrm{D}}, \\Delta E\\_{\\mathrm{low},\\mathrm{D}}].\n$$\nEach number must be rendered as a decimal floating-point value with up to $10$ significant digits. No other text must be printed.\n\nYour implementation must be a complete, runnable program that performs all computations internally without external input, adheres to the above principles, and follows the specified output format exactly.", "solution": "The problem requires the implementation of a pseudospectral solver for the one-dimensional inviscid Burgers' equation, augmented with a hyperviscosity term, on a periodic domain. The solution will be validated across four distinct configurations to investigate the effects of aliasing and hyperviscosity on energy conservation. The following exposition details the theoretical and numerical foundations of the solver.\n\nThe governing equation is:\n$$\n\\partial_t u(x,t) + \\partial_x \\left(\\tfrac{1}{2} u(x,t)^2\\right) \\;=\\; - \\nu_p \\, (-\\Delta)^p u(x,t)\n$$\non the domain $x \\in [0,2\\pi]$ with periodic boundary conditions and initial condition $u(x,0) = \\sin(x) + \\tfrac{1}{2}\\sin(2x)$.\n\n### Step 1: Problem Validation\nThe problem statement was critically evaluated according to the specified criteria.\n\n-   **Givens Extracted:** All parameters, equations, initial conditions, numerical procedures (discretization, time integration, de-aliasing), and diagnostic definitions were extracted verbatim. This includes the governing PDE, initial condition $u(x,0) = \\sin(x) + \\tfrac{1}{2}\\sin(2x)$, numerical parameters $N=64$, $T=0.4$, $\\Delta t = 5\\times 10^{-4}$, hyperviscosity parameters $p=4, \\nu_p \\in \\{0, 10^{-18}\\}$, and four simulation cases (A, B, C, D) defined by the status of de-aliasing and hyperviscosity. The definitions for the pseudospectral method, Runge-Kutta time stepping, the $2/3$ de-aliasing rule, and energy diagnostics are all explicitly provided.\n-   **Validation Checks:**\n    1.  **Scientific Grounding:** The problem is based on the Burgers' equation, a standard model in fluid dynamics, and employs established numerical techniques (pseudospectral methods, RK4, hyperviscosity, de-aliasing). It is scientifically sound.\n    2.  **Well-Posedness:** The problem constitutes a well-posed initial-boundary value problem. The numerical task is clearly specified with all necessary parameters and definitions, ensuring a unique and computable solution for the given algorithm.\n    3.  **Objectivity:** The problem statement is precise, quantitative, and free of subjective or ambiguous language.\n-   **Verdict:** The problem is **valid**. It is a well-structured, scientifically grounded, and computationally tractable problem in the field of numerical methods for PDEs.\n\n### Step 2: Method and Implementation\nThe solution methodology is a pseudospectral method in space and a fourth-order Runge-Kutta method in time.\n\n**Spatial Discretization and Fourier Representation**\nThe spatial domain $[0,2\\pi]$ is discretized into $N=64$ equispaced points, $x_j = 2\\pi j/N$ for $j=0, 1, \\dots, N-1$. A function $u(x,t)$ is represented by its values $u_j(t) = u(x_j, t)$ on this grid. The spectral representation is based on a truncated Fourier series. The discrete Fourier coefficients $\\widehat{u}_k(t)$ are related to the grid-point values $u_j(t)$ via the Discrete Fourier Transform (DFT) and its inverse:\n$$\n\\widehat{u}_k(t) = \\sum_{j=0}^{N-1} u_j(t) e^{-i k x_j}, \\quad u_j(t) = \\frac{1}{N} \\sum_{k} \\widehat{u}_k(t) e^{i k x_j}\n$$\nThe summation for $k$ is over the set of integer wavenumbers. For an even number of points $N$, these wavenumbers are typically taken as $k \\in \\{-N/2, -N/2+1, \\dots, N/2-1\\}$. For the implementation, we use the standard `numpy.fft` convention, where wavenumbers are ordered as $k=0, 1, \\dots, N/2-1, -N/2, \\dots, -1$ and are obtained by `k = numpy.fft.fftfreq(N) * N`.\n\nIn Fourier space, the spatial derivative $\\partial_x$ becomes a simple multiplication by $ik$:\n$$\n\\widehat{\\partial_x u}_k = ik \\widehat{u}_k\n$$\n\n**Semi-Discretization of the PDE**\nApplying the Fourier transform to the governing equation yields a system of ordinary differential equations (ODEs) for the coefficients $\\widehat{u}_k(t)$:\n$$\n\\frac{d\\widehat{u}_k}{dt} = \\widehat{\\mathcal{N}}_k[\\widehat{u}] + \\widehat{\\mathcal{L}}_k[\\widehat{u}]\n$$\nwhere $\\widehat{\\mathcal{N}}_k$ is the Fourier transform of the nonlinear term and $\\widehat{\\mathcal{L}}_k$ is the hyperviscosity term.\n\n**Hyperviscosity Term (Linear Part)**\nThe hyperviscosity operator $-\\nu_p(-\\Delta)^p$ has a simple representation in Fourier space. Since the Laplacian $\\Delta = \\partial_{xx}$ corresponds to multiplication by $(ik)^2 = -k^2$, the operator $-\\Delta$ corresponds to multiplication by $k^2 = |k|^2$. Therefore, the hyperviscosity term is:\n$$\n\\widehat{\\mathcal{L}}_k[\\widehat{u}] = -\\nu_p |k|^{2p} \\widehat{u}_k\n$$\nThis term is linear in $\\widehat{u}_k$ and applies damping that is highly selective towards large wavenumbers (small scales).\n\n**Nonlinear Term (Pseudospectral Part)**\nThe nonlinear term is $\\mathcal{N}(u) = -\\partial_x (\\frac{1}{2} u^2)$. Its Fourier coefficients are computed pseudospectrally:\n1.  Transform $\\widehat{u}_k(t)$ to physical space to get $u_j(t)$ using an Inverse Fast Fourier Transform (IFFT).\n2.  Compute the quantity $q_j(t) = \\frac{1}{2}u_j(t)^2$ at each grid point.\n3.  Transform $q_j(t)$ back to Fourier space to get $\\widehat{q}_k(t)$ using a Fast Fourier Transform (FFT).\n4.  Apply the spectral derivative to find the nonlinear contribution: $\\widehat{\\mathcal{N}}_k = -ik \\widehat{q}_k(t)$.\n\n**De-aliasing**\nThe pointwise product $u_j \\cdot u_j$ creates aliasing errors, where high-wavenumber components masquerade as low-wavenumber components. The $2/3$ de-aliasing rule mitigates this. A spectral filter (mask) is created to set to zero all Fourier modes with wavenumbers $|k| > K_{\\text{max}}$, where $K_{\\text{max}} = \\lfloor N/3 \\rfloor$. For $N=64$, $K_{\\text{max}}=21$. When de-aliasing is enabled, the procedure for the nonlinear term is modified:\n1.  Apply the de-aliasing mask to $\\widehat{u}_k$ before the IFFT.\n2.  Compute $u_j$ and $q_j$ as before.\n3.  After computing $\\widehat{q}_k$ via FFT, apply the de-aliasing mask again before multiplication by $-ik$.\nFurthermore, after each complete time step, the solution $\\widehat{u}_k$ is projected back onto the un-aliased modes by applying the mask.\n\n**Time Integration**\nThe semi-discrete system $\\frac{d\\widehat{u}}{dt} = F(\\widehat{u})$ is advanced in time using the classical fourth-order Runge-Kutta (RK4) method with a fixed time step $\\Delta t$:\n$$\n\\begin{align*}\n\\mathbf{k}_1 &= F(\\widehat{u}_n) \\\\\n\\mathbf{k}_2 &= F(\\widehat{u}_n + \\tfrac{1}{2}\\Delta t \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 &= F(\\widehat{u}_n + \\tfrac{1}{2}\\Delta t \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 &= F(\\widehat{u}_n + \\Delta t \\mathbf{k}_3) \\\\\n\\widehat{u}_{n+1} &= \\widehat{u}_n + \\tfrac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{align*}\nHere, $\\widehat{u}$ is the vector of all Fourier coefficients, and $F(\\widehat{u})$ is the function that computes the right-hand side (sum of nonlinear and hyperviscosity terms).\n\n**Initial Condition**\nThe initial condition is $u(x,0) = \\sin(x) + \\tfrac{1}{2}\\sin(2x)$. Using the identity $\\sin(\\theta) = (e^{i\\theta} - e^{-i\\theta})/(2i)$, we can find the exact continuous Fourier series coefficients. The DFT coefficients $\\widehat{u}_k(0)$ are proportional to these, and can be derived from orthogonality relations as:\n$$\n\\widehat{u}_k(0) = \\begin{cases} -iN/2 & \\text{if } k=1 \\\\ iN/2 & \\text{if } k=-1 \\\\ -iN/4 & \\text{if } k=2 \\\\ iN/4 & \\text{if } k=-2 \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\nThis allows for an exact, sampling-error-free initialization in Fourier space.\n\n**Energy Diagnostics**\nThe total energy $E(t)$ and low-wavenumber band energy $E_{\\mathrm{low}}(t)$ are computed. By Parseval's theorem, the energy can be calculated from the Fourier coefficients, which is generally more accurate and consistent with the spectral method. The formulas are:\n$$\nE(t) = \\frac{1}{2 N^2} \\sum_{k} |\\widehat{u}_k(t)|^2\n$$\n$$\nE_{\\mathrm{low}}(t) = \\frac{1}{2 N^2} \\sum_{1 \\le |k| \\le k_{\\ast}} |\\widehat{u}_k(t)|^2, \\quad \\text{with } k_{\\ast}=4\n$$\nThe diagnostics to be reported are $\\Delta E = E(T) - E(0)$ and $\\Delta E_{\\mathrm{low}} = E_{\\mathrm{low}}(T) - E_{\\mathrm{low}}(0)$ for each case. For the inviscid, un-forced Burgers' equation, total energy should be conserved. Any deviation in the numerical solution indicates error, such as that caused by aliasing. The change in low-band energy tracks how energy is transferred between large and small scales.\n\nThe overall algorithm proceeds by setting up the initial state in Fourier space, calculating initial energies, and then iterating the RK4 time-stepping loop for the required number of steps. For each of the four cases, the parameters for de-aliasing and hyperviscosity are configured accordingly. Finally, the terminal energies are computed and the required diagnostics are calculated and assembled for output.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D inviscid Burgers' equation with optional hyperviscosity\n    using a pseudospectral method and investigates aliasing effects.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    N = 64\n    T = 0.4\n    dt = 5e-4\n    k_star = 4\n\n    test_cases = [\n        {'name': 'A', 'dealias': False, 'nu_p': 0.0, 'p': 4},\n        {'name': 'B', 'dealias': True,  'nu_p': 0.0, 'p': 4},\n        {'name': 'C', 'dealias': False, 'nu_p': 1e-18, 'p': 4},\n        {'name': 'D', 'dealias': True,  'nu_p': 1e-18, 'p': 4},\n    ]\n\n    # --- Grid and Wavenumber Setup ---\n    # Wavenumbers corresponding to numpy's FFT output order\n    k = np.fft.fftfreq(N) * N\n\n    # --- De-aliasing Mask (2/3 rule) ---\n    k_cutoff = int(np.floor(N / 3.0))\n    dealias_mask = np.ones_like(k, dtype=bool)\n    dealias_mask[np.abs(k) > k_cutoff] = False\n    \n    # --- Energy Calculation Functions ---\n    def calc_E(u_hat):\n        \"\"\"Computes total energy from spectral coefficients.\"\"\"\n        return 0.5 / (N**2) * np.sum(np.abs(u_hat)**2)\n\n    def calc_E_low(u_hat):\n        \"\"\"Computes low-wavenumber band energy.\"\"\"\n        mask = (np.abs(k) >= 1) & (np.abs(k) <= k_star)\n        return 0.5 / (N**2) * np.sum(np.abs(u_hat[mask])**2)\n\n    # --- RHS of the ODE in Fourier space: d(u_hat)/dt = F(u_hat) ---\n    def rhs(u_hat, hypervisc_op, dealias_flag):\n        \"\"\"\n        Computes the right-hand side of the semi-discrete equation.\n        F(u_hat) = NonlinearTerm(u_hat) + LinearTerm(u_hat)\n        \"\"\"\n        # Linear (hyperviscosity) term\n        du_dt_linear = hypervisc_op * u_hat\n        \n        # Nonlinear (pseudospectral) term\n        u_hat_dealiased = u_hat.copy()\n        if dealias_flag:\n            u_hat_dealiased[~dealias_mask] = 0.0\n            \n        u_phys = np.fft.ifft(u_hat_dealiased)\n        \n        # Ensure physical space solution is real before squaring\n        # Small imaginary parts can arise from floating point errors\n        q_phys = 0.5 * np.real(u_phys)**2 \n        \n        q_hat = np.fft.fft(q_phys)\n        \n        if dealias_flag:\n            q_hat[~dealias_mask] = 0.0\n            \n        du_dt_nonlinear = -1j * k * q_hat\n        \n        return du_dt_nonlinear + du_dt_linear\n\n    # --- Main Simulation Loop ---\n    all_results = []\n    num_steps = int(round(T / dt))\n\n    for case in test_cases:\n        dealias_flag = case['dealias']\n        nu_p = case['nu_p']\n        p = case['p']\n\n        # --- Initial Condition in Fourier Space ---\n        u_hat0 = np.zeros(N, dtype=complex)\n        # Using numpy's array indexing for negative wavenumbers\n        u_hat0[1] = -1j * N / 2.0\n        u_hat0[N-1] = 1j * N / 2.0  # k = -1\n        u_hat0[2] = -1j * N / 4.0\n        u_hat0[N-2] = 1j * N / 4.0  # k = -2\n        \n        u_hat = u_hat0.copy()\n\n        # --- Calculate Initial Energies ---\n        E0 = calc_E(u_hat)\n        E_low0 = calc_E_low(u_hat)\n\n        # Pre-compute the hyperviscosity operator for efficiency\n        hypervisc_op = -nu_p * np.abs(k)**(2*p)\n\n        # --- Time-stepping with RK4 ---\n        for _ in range(num_steps):\n            k1 = rhs(u_hat, hypervisc_op, dealias_flag)\n            k2 = rhs(u_hat + dt / 2.0 * k1, hypervisc_op, dealias_flag)\n            k3 = rhs(u_hat + dt / 2.0 * k2, hypervisc_op, dealias_flag)\n            k4 = rhs(u_hat + dt * k3, hypervisc_op, dealias_flag)\n            u_hat += dt / 6.0 * (k1 + 2*k2 + 2*k3 + k4)\n\n            # Post-step projection for de-aliased runs\n            if dealias_flag:\n                u_hat[~dealias_mask] = 0.0\n        \n        # --- Calculate Final Energies and Diagnostics ---\n        ET = calc_E(u_hat)\n        E_lowT = calc_E_low(u_hat)\n\n        delta_E = ET - E0\n        delta_E_low = E_lowT - E0\n\n        all_results.extend([delta_E, delta_E_low])\n\n    # --- Final Output Formatting ---\n    # Format numbers to specifications (up to 10 significant digits)\n    formatted_results = [f\"{val:.10g}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3277726"}]}