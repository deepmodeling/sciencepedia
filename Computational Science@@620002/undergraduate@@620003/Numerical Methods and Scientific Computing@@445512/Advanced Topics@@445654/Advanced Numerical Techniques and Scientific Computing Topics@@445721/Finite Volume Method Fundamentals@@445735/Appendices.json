{"hands_on_practices": [{"introduction": "The choice of a numerical flux is a cornerstone of the Finite Volume Method. While \"upwinding\" is often presented as the standard for advection problems, it is pedagogically vital to understand precisely *why* this choice is so critical. This first practice delves into this question by exploring a physically counter-intuitive \"anti-upwind\" or \"downwind\" scheme, which takes information from the incorrect direction relative to the flow.\n\nThrough the powerful tool of von Neumann stability analysis, you will discover how this improper flux formulation leads to unconditional instability, a scenario where numerical errors grow exponentially without bound, rendering the simulation useless. Completing this exercise [@problem_id:2394340] provides a firm grasp of stability analysis and a deep appreciation for the foundational role that the direction of information propagation plays in constructing robust numerical schemes.", "problem": "Consider the one-dimensional linear advection equation $\\partial_t u + a \\,\\partial_x u = 0$ on a periodic, uniform grid with cell centers indexed by $j \\in \\mathbb{Z}$, uniform cell width $\\Delta x > 0$, and time step $\\Delta t > 0$. Let $u_j^n$ denote the cell average at time level $n$. Define the explicit finite volume update\n$$\nu_j^{n+1} = u_j^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{j+\\frac{1}{2}}^n - F_{j-\\frac{1}{2}}^n\\right),\n$$\nusing the \"anti-upwind\" numerical flux that takes the state from the downwind side of each face:\n- For $a>0$: $F_{j+\\frac{1}{2}}^n = a\\,u_{j+1}^n$ and $F_{j-\\frac{1}{2}}^n = a\\,u_{j}^n$.\n- For $a<0$: $F_{j+\\frac{1}{2}}^n = a\\,u_{j}^n$ and $F_{j-\\frac{1}{2}}^n = a\\,u_{j-1}^n$.\n\nIntroduce the Courant number $C = a\\,\\Delta t/\\Delta x$. For a single Fourier mode initial state $u_j^n = \\hat{u}^n \\exp(i k x_j)$ with $x_j = j\\,\\Delta x$ and wavenumber $k \\in \\mathbb{R}$, define the one-step amplification factor $G(\\theta, C)$ by $\\hat{u}^{n+1} = G(\\theta, C)\\,\\hat{u}^n$, where $\\theta = k\\,\\Delta x$ is the phase angle in radians.\n\nTask: Write a complete, runnable program that, for each specified Courant number $C$, computes the maximum over all phase angles $\\theta \\in [-\\pi,\\pi]$ of the magnitude $\\lvert G(\\theta, C) \\rvert$ associated with the anti-upwind scheme defined above. Your program must return these maxima as floating-point numbers.\n\nTest suite:\n- Use the Courant number values $C \\in \\{0.0, 0.1, 0.5, 1.0, -0.3, 2.0\\}$.\n\nFinal output format:\n- Your program must produce a single line of output containing a list of the six maxima, in the same order as the test suite, rounded to $6$ decimal places, as a comma-separated list enclosed in square brackets (for example, $[x_1,x_2,x_3,x_4,x_5,x_6]$).", "solution": "The problem statement is scientifically grounded, well-posed, and complete. It presents a standard von Neumann stability analysis of a specified numerical scheme for the linear advection equation. The analysis will proceed by deriving the one-step amplification factor $G(\\theta, C)$ and then determining its maximum magnitude over the specified range of the phase angle $\\theta$.\n\nThe finite volume update is given by\n$$u_j^{n+1} = u_j^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{j+\\frac{1}{2}}^n - F_{j-\\frac{1}{2}}^n\\right)$$\nLet $C = a \\frac{\\Delta t}{\\Delta x}$ be the Courant number. The analysis is separated based on the sign of $a$, which is the same as the sign of $C$ since $\\Delta t > 0$ and $\\Delta x > 0$.\n\nCase 1: $a > 0$, implying $C > 0$.\nThe problem specifies the anti-upwind (or downwind) numerical fluxes for this case as $F_{j+\\frac{1}{2}}^n = a u_{j+1}^n$ and $F_{j-\\frac{1}{2}}^n = a u_{j}^n$. Substituting these into the update scheme yields:\n$$u_j^{n+1} = u_j^n - \\frac{\\Delta t}{\\Delta x}\\left(a u_{j+1}^n - a u_j^n\\right)$$\n$$u_j^{n+1} = u_j^n - C \\left(u_{j+1}^n - u_j^n\\right)$$\nTo perform the von Neumann analysis, we substitute a single Fourier mode, $u_j^n = \\hat{u}^n e^{i k x_j} = \\hat{u}^n e^{i j \\theta}$, where $\\theta = k \\Delta x$. The update equation becomes:\n$$\\hat{u}^{n+1} e^{i j \\theta} = \\hat{u}^n e^{i j \\theta} - C \\left(\\hat{u}^n e^{i (j+1) \\theta} - \\hat{u}^n e^{i j \\theta}\\right)$$\nDividing by $\\hat{u}^n e^{i j \\theta}$ gives the amplification factor $G(\\theta, C) = \\frac{\\hat{u}^{n+1}}{\\hat{u}^n}$:\n$$G(\\theta, C) = 1 - C \\left(e^{i \\theta} - 1\\right) = (1+C) - C e^{i\\theta}$$\nWe seek the maximum of the magnitude $|G(\\theta, C)|$. It is equivalent to maximize the magnitude squared, $|G(\\theta, C)|^2$:\n$$|G(\\theta, C)|^2 = \\left| (1+C) - C(\\cos\\theta + i\\sin\\theta) \\right|^2$$\n$$|G(\\theta, C)|^2 = \\left( (1+C) - C\\cos\\theta \\right)^2 + (-C\\sin\\theta)^2$$\n$$|G(\\theta, C)|^2 = (1+C)^2 - 2C(1+C)\\cos\\theta + C^2\\cos^2\\theta + C^2\\sin^2\\theta$$\n$$|G(\\theta, C)|^2 = (1+C)^2 - 2C(1+C)\\cos\\theta + C^2 = 1+2C+2C^2 - (2C+2C^2)\\cos\\theta$$\n$$|G(\\theta, C)|^2 = 1 + 2C(1+C)(1 - \\cos\\theta)$$\nTo maximize this expression for $\\theta \\in [-\\pi, \\pi]$, we analyze the coefficient of the term $(1 - \\cos\\theta)$. Since $C > 0$, the coefficient $2C(1+C)$ is strictly positive. Therefore, the expression is maximized when $(1 - \\cos\\theta)$ is maximized. The maximum value of $(1 - \\cos\\theta)$ is $1 - (-1) = 2$, which occurs at $\\theta = \\pm\\pi$.\nSubstituting $\\cos\\theta = -1$:\n$$\\max_{\\theta} |G(\\theta, C)|^2 = 1 + 2C(1+C)(2) = 1 + 4C + 4C^2 = (1+2C)^2$$\nThe maximum magnitude is the square root:\n$$\\max_{\\theta} |G(\\theta, C)| = \\sqrt{(1+2C)^2} = |1+2C|$$\nSince $C > 0$, this simplifies to $1+2C$.\n\nCase 2: $a < 0$, implying $C < 0$.\nThe specified fluxes are $F_{j+\\frac{1}{2}}^n = a u_{j}^n$ and $F_{j-\\frac{1}{2}}^n = a u_{j-1}^n$. The update scheme is:\n$$u_j^{n+1} = u_j^n - \\frac{\\Delta t}{\\Delta x}\\left(a u_{j}^n - a u_{j-1}^n\\right)$$\n$$u_j^{n+1} = u_j^n - C \\left(u_j^n - u_{j-1}^n\\right)$$\nSubstituting the Fourier mode $u_j^n = \\hat{u}^n e^{i j \\theta}$:\n$$\\hat{u}^{n+1} e^{i j \\theta} = \\hat{u}^n e^{i j \\theta} - C \\left(\\hat{u}^n e^{i j \\theta} - \\hat{u}^n e^{i (j-1) \\theta}\\right)$$\nDividing by $\\hat{u}^n e^{i j \\theta}$ gives the amplification factor:\n$$G(\\theta, C) = 1 - C \\left(1 - e^{-i \\theta}\\right) = (1-C) + C e^{-i\\theta}$$\nWe find the magnitude squared:\n$$|G(\\theta, C)|^2 = \\left| (1-C) + C(\\cos\\theta - i\\sin\\theta) \\right|^2$$\n$$|G(\\theta, C)|^2 = \\left( (1-C) + C\\cos\\theta \\right)^2 + (-C\\sin\\theta)^2$$\n$$|G(\\theta, C)|^2 = (1-C)^2 + 2C(1-C)\\cos\\theta + C^2\\cos^2\\theta + C^2\\sin^2\\theta$$\n$$|G(\\theta, C)|^2 = (1-C)^2 + 2C(1-C)\\cos\\theta + C^2 = 1-2C+2C^2 + (2C-2C^2)\\cos\\theta$$\nIn this case, $C < 0$, which implies $(1-C) > 1$. The coefficient of $\\cos\\theta$, which is $2C(1-C)$, is therefore negative. To maximize $|G(\\theta, C)|^2$, we must minimize $\\cos\\theta$. The minimum value of $\\cos\\theta$ is $-1$, occurring at $\\theta = \\pm\\pi$.\nSubstituting $\\cos\\theta = -1$:\n$$\\max_{\\theta} |G(\\theta, C)|^2 = 1 - 2C + 2C^2 + (2C-2C^2)(-1) = 1-2C+2C^2-2C+2C^2$$\n$$\\max_{\\theta} |G(\\theta, C)|^2 = 1 - 4C + 4C^2 = (1-2C)^2$$\nThe maximum magnitude is:\n$$\\max_{\\theta} |G(\\theta, C)| = \\sqrt{(1-2C)^2} = |1-2C|$$\nSince $C < 0$, we have $-2C > 0$, so $1-2C > 1$. This simplifies to $1-2C$.\n\nSummary of results:\n- For $C>0$: $\\max|G| = 1+2C = 1+2|C|$.\n- For $C<0$: $\\max|G| = 1-2C = 1+2|C|$.\n- For $C=0$: The scheme becomes $u_j^{n+1} = u_j^n$, so $G(\\theta, 0)=1$ for all $\\theta$, and $\\max|G|=1$. The formula $1+2|C|$ also gives $1+2|0|=1$.\n\nThus, for any real value of $C$, the maximum magnitude of the amplification factor is given by the unified formula:\n$$\\max_{\\theta \\in [-\\pi,\\pi]} |G(\\theta, C)| = 1 + 2|C|$$\nThis formula is now applied to the provided test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the maximum amplification factor magnitude for the anti-upwind\n    finite volume scheme for a given set of Courant numbers.\n    \"\"\"\n    # Test suite of Courant numbers from the problem statement.\n    test_cases = [0.0, 0.1, 0.5, 1.0, -0.3, 2.0]\n\n    results = []\n    for C in test_cases:\n        # The derivation shows that the maximum magnitude of the amplification\n        # factor G for the anti-upwind (downwind) scheme is given by the\n        # formula: max|G| = 1 + 2*|C|.\n        # This formula holds for C > 0, C < 0, and C = 0.\n        max_G_magnitude = 1.0 + 2.0 * abs(C)\n        results.append(max_G_magnitude)\n\n    # Format the final output as a comma-separated list of floating-point\n    # numbers with 6 decimal places, enclosed in square brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "2394340"}, {"introduction": "Having established the necessity of a stable scheme like the first-order upwind method, we must now critically evaluate its performance. Although it guarantees stability under the Courant–Friedrichs–Lewy (CFL) condition, this simplicity comes at a cost. The method's primary drawback is the introduction of artificial, or numerical, diffusion.\n\nThis exercise [@problem_id:2394306] makes the abstract concept of numerical diffusion tangible. You will simulate the advection of a sharp, discontinuous profile and quantitatively measure how the upwind scheme artificially \"smears\" this feature over time. This smearing is a direct manifestation of the scheme's leading-order truncation error, which behaves like a physical diffusion term, illustrating a fundamental trade-off between stability and accuracy in numerical methods.", "problem": "Consider the linear advection equation in one spatial dimension,\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\n$$\non a periodic domain of length $L$, that is $x \\in [0,L)$ with periodic boundary conditions. The advection speed $a$ is a positive constant. Starting from the integral conservation law and the definition of finite volume averages on a uniform grid, derive a first-order, explicit, conservative finite volume method that is consistent with the physics of information propagation for $a>0$.\n\nYou will investigate numerical diffusion by simulating the advection of a block step function and quantifying the smearing of the interface over time. Use a uniform mesh of $N$ cells with spatial step $\\Delta x = L/N$ and cell centers $x_i = (i+\\tfrac{1}{2})\\Delta x$, for $i=0,1,\\dots,N-1$. Let the initial condition be the block\n$$\nu(x,0) = \\begin{cases}\n1, & x \\in [x_L, x_R),\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\nwith $x_L = 0.2\\,L$ and $x_R = 0.7\\,L$. Evolve the solution using a first-order finite volume scheme with an explicit time step $\\Delta t$ chosen to satisfy a prescribed Courant–Friedrichs–Lewy (CFL) number $\\nu = a\\,\\Delta t/\\Delta x$. Use the same constant $\\nu$ for all time steps of a given simulation. Let the simulation run for a prescribed final time $T$; use an integer number of time steps $n = \\text{round}(T/\\Delta t)$ so that the simulated time is $t_n = n\\,\\Delta t$.\n\nDefine the \"smearing width\" of a descending interface at time $t_n$ as the minimal spatial distance (measured along the periodic domain) from the point where the cell-centered profile crosses the level $\\theta_{\\text{hi}} = 0.9$ downward to the subsequent point where it crosses the level $\\theta_{\\text{lo}} = 0.1$ downward. Compute these crossing points using linear interpolation of the cell-centered values between neighboring cell centers. In the presence of multiple descending interfaces (due to periodicity), compute the smearing width around each descending interface and report the minimal width. Express the width in the same dimensionless length units as $L$.\n\nImplement the simulation and the width measurement in a single program. For each test case below, output the measured smearing width at time $t_n$, rounded to $8$ decimal places.\n\nUse the following test suite, with parameters $(N,\\ \\nu,\\ T,\\ a,\\ L)$:\n- Case $1$: $(200,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$.\n- Case $2$: $(200,\\ 0.9,\\ 0.2,\\ 1.0,\\ 1.0)$.\n- Case $3$: $(200,\\ 0.2,\\ 0.2,\\ 1.0,\\ 1.0)$.\n- Case $4$: $(50,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$.\n- Case $5$: $(200,\\ 1.0,\\ 0.2,\\ 1.0,\\ 1.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, it should look like\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5],\n$$\nwhere each $\\text{result}_k$ is the smearing width for case $k$ rounded to $8$ decimal places. No other output is permitted.", "solution": "We start from the integral conservation form of the advection equation,\n$$\n\\partial_t u(x,t) + \\partial_x f(u) = 0,\\quad f(u) = a u,\\quad a>0.\n$$\nLet $\\mathcal{C}_i = [x_{i-\\tfrac{1}{2}}, x_{i+\\tfrac{1}{2}}]$ be a control volume of uniform width $\\Delta x = x_{i+\\tfrac{1}{2}} - x_{i-\\tfrac{1}{2}}$, with cell center $x_i = (i+\\tfrac{1}{2})\\Delta x$ and periodic indexing. Define the cell average\n$$\n\\bar{u}_i(t) = \\frac{1}{\\Delta x}\\int_{\\mathcal{C}_i} u(x,t)\\,dx.\n$$\nIntegrating the conservation law over $\\mathcal{C}_i$ gives\n$$\n\\frac{d}{dt}\\left( \\int_{\\mathcal{C}_i} u(x,t)\\,dx \\right) + \\left[ f(u(x_{i+\\tfrac{1}{2}},t)) - f(u(x_{i-\\tfrac{1}{2}},t)) \\right] = 0,\n$$\nor equivalently,\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x}\\left( f_{i+\\tfrac{1}{2}} - f_{i-\\tfrac{1}{2}} \\right),\n$$\nwhere $f_{i\\pm \\tfrac{1}{2}}$ are the fluxes through the cell faces. A first-order explicit time discretization with time step $\\Delta t$ yields\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left( \\hat{f}_{i+\\tfrac{1}{2}}^n - \\hat{f}_{i-\\tfrac{1}{2}}^n \\right),\n$$\nwith a numerical flux $\\hat{f}_{i+\\tfrac{1}{2}}^n$ consistent with the physics. For linear advection with $a>0$, information propagates from left to right, and the exact Riemann solution at each interface depends only on the left state. The Godunov upwind numerical flux is therefore\n$$\n\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n\\quad\\text{for }a>0.\n$$\nIntroducing the Courant–Friedrichs–Lewy (CFL) number $\\nu = a\\,\\Delta t/\\Delta x$, the update simplifies to the first-order upwind scheme\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\nu\\left(\\bar{u}_i^n - \\bar{u}_{i-1}^n\\right),\\quad a>0,\n$$\nwith periodic indexing on $i$.\n\nTo relate this discrete method to a continuous process and expose numerical diffusion, we perform a modified equation analysis. Denote $\\bar{u}_i^n \\approx u(x_i,t^n)$ with $t^n = n\\Delta t$. A Taylor expansion in time gives\n$$\n\\bar{u}_i^{n+1} - \\bar{u}_i^n = \\Delta t\\,u_t(x_i,t^n) + \\mathcal{O}(\\Delta t^2).\n$$\nA Taylor expansion in space for the backward difference yields\n$$\n\\bar{u}_i^n - \\bar{u}_{i-1}^n = \\Delta x\\,u_x(x_i,t^n) - \\frac{\\Delta x^2}{2}u_{xx}(x_i,t^n) + \\frac{\\Delta x^3}{6}u_{xxx}(x_i,t^n) + \\mathcal{O}(\\Delta x^4).\n$$\nSubstituting into the scheme gives\n$$\n\\Delta t\\,u_t = -\\nu\\left[ \\Delta x\\,u_x - \\frac{\\Delta x^2}{2}u_{xx} + \\frac{\\Delta x^3}{6}u_{xxx} + \\cdots \\right] + \\mathcal{O}(\\Delta t^2).\n$$\nDividing by $\\Delta t$ and recalling $\\nu = a\\Delta t/\\Delta x$,\n$$\nu_t + a\\,u_x = \\frac{a\\,\\Delta x}{2}(1 - \\nu)\\,u_{xx} - \\frac{a\\,\\Delta x^2}{6}\\left(1 - 3\\nu + 2\\nu^2\\right)u_{xxx} + \\cdots.\n$$\nThe leading correction is a diffusion term with an effective (artificial) diffusion coefficient\n$$\nD_{\\text{num}} = \\frac{a\\,\\Delta x}{2}(1 - \\nu).\n$$\nThus for $0<\\nu<1$, the first-order upwind method introduces numerical diffusion that smears discontinuities over a width that grows like $\\sqrt{D_{\\text{num}}\\,t}$, whereas for $\\nu=1$ the leading diffusive term vanishes and the method reduces to a pure shift operator on the grid.\n\nTo quantify smearing for a step, we define the $10$–$90$ thickness. Consider a descending interface where $u$ drops from values near $1$ to values near $0$. Let $\\theta_{\\text{hi}} = 0.9$ and $\\theta_{\\text{lo}} = 0.1$. On the piecewise-constant cell-centered profile $\\{\\bar{u}_i^n\\}$, we determine the approximate positions where $u=\\theta$ by linear interpolation between neighboring cell centers. Specifically, for a pair of neighboring indices $(i,i+1)$ on a descending front with $\\bar{u}_i^n \\ge \\theta > \\bar{u}_{i+1}^n$,\n$$\nx(\\theta) \\approx x_i + \\Delta x \\frac{\\bar{u}_i^n - \\theta}{\\bar{u}_i^n - \\bar{u}_{i+1}^n}.\n$$\nWe collect all downward $\\theta_{\\text{hi}}$ crossings and all downward $\\theta_{\\text{lo}}$ crossings across the domain (with periodic wrap), and for each $\\theta_{\\text{hi}}$ crossing we determine the distance along the periodic coordinate to the subsequent $\\theta_{\\text{lo}}$ crossing. The minimal such distance, denoted $w_{10\\text{–}90}$, is the measured smearing width. This width is reported in the same length units as $L$.\n\nAlgorithmic design:\n- Spatial discretization: uniform cells, periodic boundary conditions, first-order upwind flux $\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n$ for $a>0$.\n- Time stepping: forward Euler with fixed $\\Delta t$ satisfying a prescribed $\\nu = a\\,\\Delta t/\\Delta x$; advance for $n=\\text{round}(T/\\Delta t)$ steps.\n- Initialization: block $u(x,0)=1$ on $[0.2L, 0.7L)$ and $0$ elsewhere on $[0,L)$, sampled at cell centers.\n- Width measurement: compute $w_{10\\text{–}90}$ using linear interpolation of cell-centered values and minimal downstream distance between $\\theta_{\\text{hi}}$ and $\\theta_{\\text{lo}}$ crossings along descending interfaces; use periodic unwrapping to handle interfaces near $x=0$.\n\nQualitative expectations based on $D_{\\text{num}}$: for fixed $a$, $L$, and $T$, finer grids (smaller $\\Delta x$) reduce $D_{\\text{num}}$ and thus reduce smearing; larger $\\nu$ (closer to $1$) also reduces $D_{\\text{num}}$, yielding narrower interfaces; at $\\nu=1$, the leading diffusive term vanishes and the interface is limited essentially to a grid-scale thickness. The program implements the scheme and measurement precisely and outputs, for each specified test case $(N,\\nu,T,a,L)$, the smearing width $w_{10\\text{–}90}(t_n)$ rounded to $8$ decimal places, aggregated as a single list on one line as required.", "answer": "```python\nimport numpy as np\n\ndef upwind_fvm_step(u, nu):\n    \"\"\"\n    First-order upwind finite volume update for a > 0:\n    u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n), with periodic indexing.\n    \"\"\"\n    return u - nu * (u - np.roll(u, 1))\n\ndef initialize_block(N, L, xL_frac=0.2, xR_frac=0.7):\n    \"\"\"\n    Initialize u(x,0) = 1 on [x_L, x_R) and 0 elsewhere on [0,L), sampled at cell centers.\n    x_L = xL_frac * L, x_R = xR_frac * L.\n    \"\"\"\n    dx = L / N\n    x = (np.arange(N) + 0.5) * dx\n    xL = xL_frac * L\n    xR = xR_frac * L\n    u0 = np.where((x >= xL) & (x < xR), 1.0, 0.0)\n    return x, u0\n\ndef interpolate_crossing_pos(x_i, x_ip1, u_i, u_ip1, theta, L):\n    \"\"\"\n    Linear interpolation between (x_i, u_i) and (x_ip1, u_ip1) to find x where u=theta.\n    The positions x_i and x_ip1 are assumed to be neighbors on a uniform periodic grid.\n    Returns position wrapped into [0, L).\n    \"\"\"\n    # Handle periodic wrap for positions if necessary (assume uniform spacing)\n    # For uniform grid, x_ip1 - x_i = dx and we do not need special position handling for periodicity;\n    # after computing the position, wrap into [0, L).\n    denom = (u_i - u_ip1)\n    if denom == 0.0:\n        return None\n    frac = (u_i - theta) / denom\n    # x along the straight line between centers\n    xi = x_i + (x_ip1 - x_i) * frac\n    # Wrap into [0, L)\n    xi_wrapped = xi % L\n    return xi_wrapped\n\ndef measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1):\n    \"\"\"\n    Measure the 10-90 smearing width on descending interfaces using linear interpolation\n    between neighboring cell centers. Returns the minimal width among all descending interfaces.\n    \"\"\"\n    N = len(u)\n    dx = L / N\n    # Build arrays of theta_hi and theta_lo crossing positions for descending fronts\n    hi_positions = []\n    lo_positions = []\n    for i in range(N):\n        ip1 = (i + 1) % N\n        u_i = u[i]\n        u_ip1 = u[ip1]\n        # Descending segment if u_i > u_ip1 (strict to avoid degenerate flat segments)\n        if u_i > u_ip1:\n            # theta_hi crossing: u_i >= theta_hi > u_ip1\n            if (u_i >= theta_hi) and (u_ip1 < theta_hi):\n                xi = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_hi, L)\n                if xi is not None:\n                    hi_positions.append(xi)\n            # theta_lo crossing: u_i >= theta_lo > u_ip1\n            if (u_i >= theta_lo) and (u_ip1 < theta_lo):\n                xl = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_lo, L)\n                if xl is not None:\n                    lo_positions.append(xl)\n\n    # Sort positions\n    hi_positions = np.sort(np.array(hi_positions, dtype=float)) if len(hi_positions) > 0 else np.array([], dtype=float)\n    lo_positions = np.sort(np.array(lo_positions, dtype=float)) if len(lo_positions) > 0 else np.array([], dtype=float)\n\n    if hi_positions.size == 0 or lo_positions.size == 0:\n        # No descending interfaces detected; width undefined. Return 0.0 as fallback.\n        return 0.0\n\n    # For each hi crossing, find the next downstream lo crossing (with periodicity)\n    widths = []\n    for h in hi_positions:\n        # Compute downstream distances to all lo positions with periodic wrap\n        dists = []\n        for l in lo_positions:\n            d = l - h\n            if d < 0:\n                d += L\n            dists.append(d)\n        if len(dists) > 0:\n            widths.append(min(dists))\n    if len(widths) == 0:\n        return 0.0\n    return float(min(widths))\n\ndef simulate_and_measure(N, nu, T, a, L):\n    \"\"\"\n    Run the first-order upwind FVM for linear advection with given parameters and\n    measure the 10-90 smearing width at time ~ T.\n    \"\"\"\n    dx = L / N\n    dt = nu * dx / a\n    # Number of steps to approximate T with fixed dt\n    nsteps = int(np.round(T / dt))\n    # Initialize\n    x, u = initialize_block(N, L, xL_frac=0.2, xR_frac=0.7)\n    # Time-stepping\n    for _ in range(nsteps):\n        u = upwind_fvm_step(u, nu)\n    # Measure width\n    width = measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1)\n    return width\n\ndef solve():\n    # Define the test cases: (N, nu, T, a, L)\n    test_cases = [\n        (200, 0.5, 0.2, 1.0, 1.0),  # Case 1\n        (200, 0.9, 0.2, 1.0, 1.0),  # Case 2\n        (200, 0.2, 0.2, 1.0, 1.0),  # Case 3\n        (50,  0.5, 0.2, 1.0, 1.0),  # Case 4\n        (200, 1.0, 0.2, 1.0, 1.0),  # Case 5\n    ]\n\n    results = []\n    for N, nu, T, a, L in test_cases:\n        width = simulate_and_measure(N, nu, T, a, L)\n        # Round to 8 decimal places as required\n        results.append(width)\n\n    # Final print statement in the exact required format with rounding\n    print(\"[\" + \",\".join(f\"{w:.8f}\" for w in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2394306"}, {"introduction": "Moving beyond the linear advection equation brings us to the more complex and realistic realm of nonlinear conservation laws. These equations, which govern phenomena like gas dynamics and traffic flow, can spontaneously develop sharp, discontinuous features known as shock waves. A numerical method's ability to accurately capture these nonlinear phenomena is a key measure of its power and utility.\n\nThis practice tackles the inviscid Burgers' equation, a fundamental prototype for shock-forming dynamics. You will implement and compare a simple upwind-type flux against the more sophisticated Harten-Lax-van Leer (HLL) approximate Riemann solver, evaluating their performance in capturing both shocks and smooth rarefaction waves. This hands-on comparison [@problem_id:2394328] highlights the limitations of naive schemes for nonlinear problems and serves as an excellent introduction to the powerful shock-capturing methods that form the basis of modern computational fluid dynamics.", "problem": "Implement a one-dimensional finite volume solver for the inviscid Burgers equation using two different numerical fluxes and compare their ability to capture shocks and rarefactions. The starting point is the conservation law and its integral form. Begin from the fundamental conservation statement: for a conserved quantity with density $u(x,t)$ and flux $f(u)$, the local conservation law is $u_t + f(u)_x = 0$. Over a control volume $[x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$, the integral form is $\\frac{d}{dt}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t)\\,dx + \\left.f(u)\\right|_{x_{i+\\frac{1}{2}}} - \\left.f(u)\\right|_{x_{i-\\frac{1}{2}}} = 0$. Discretize this to obtain a first-order finite volume update for cell averages $U_i^n$ at time $t^n$ with time step $\\Delta t$ and cell width $\\Delta x$, using the replacement of physical fluxes at interfaces by numerical fluxes that approximate the solution of a local Riemann problem. No additional formulas are provided in the problem statement; you must derive the discrete update and the numerical fluxes from these principles.\n\nUse the specific conservation law $u_t + \\left(\\frac{1}{2}u^2\\right)_x = 0$, that is, the inviscid Burgers equation with $f(u)=\\frac{1}{2}u^2$. Implement two numerical fluxes at each cell interface based on left and right states $u_L$ and $u_R$:\n- An approximate Riemann solver of Harten–Lax–van Leer (HLL), derived by bounding the signal speeds by the minimal and maximal characteristic speeds and integrating the approximate Riemann fan. For the scalar case, this reduces to a Godunov-type flux when the waves are correctly bounded by the left and right characteristic speeds.\n- A basic upwind flux obtained by linearizing the nonlinear flux locally with a single advection speed computed from the interface states, and applying the donor-cell upwinding rule relative to the sign of that speed.\n\nAlgorithmic requirements:\n- Use a uniform grid with $N$ cells over the domain $[x_L,x_R] = [-1,1]$ with cell centers at $x_i = x_L + \\left(i + \\frac{1}{2}\\right)\\Delta x$ for $i=0,1,\\dots,N-1$, where $\\Delta x = \\frac{x_R - x_L}{N}$.\n- Initialize a Riemann problem with a discontinuity at $x=0$: $u(x,0) = u_L$ for $x &lt; 0$ and $u(x,0) = u_R$ for $x \\ge 0$.\n- Advance in time using an explicit forward Euler method for the finite volume update to a final time $T$, enforcing a Courant–Friedrichs–Lewy (CFL) stability condition based on the maximum characteristic speed $|f'(u)| = |u|$ in the domain at each time step. Use $\\Delta t \\le \\nu \\frac{\\Delta x}{\\max_i |u_i|}$, with a chosen CFL number $\\nu$ strictly less than $1$.\n- Apply transmissive (zero-gradient) boundary conditions implemented with one ghost cell on each side by copying the nearest interior value into the corresponding ghost cell at each time step.\n\nReference solution for error evaluation:\n- Derive and use the exact self-similar Riemann solution of the inviscid Burgers equation to compute a reference $u(x_i,T)$ at cell centers. For $u_L &gt; u_R$, the solution is a shock located at speed given by the Rankine–Hugoniot condition. For $u_L &lt; u_R$, the solution is a centered rarefaction fan with linear profile between the left and right characteristic speeds.\n\nTest suite and outputs:\n- Use $N=400$, $\\nu=0.9$, domain $[x_L,x_R]=[-1,1]$, discontinuity at $x=0$, and final time $T=0.3$ for all tests. Define three initial states $(u_L,u_R)$:\n  1. $u_L=2.0$, $u_R=0.0$ (shock-dominant case).\n  2. $u_L=0.0$, $u_R=2.0$ (expanding rarefaction case).\n  3. $u_L=-1.0$, $u_R=1.0$ (transonic rarefaction case).\n- For each test case $k \\in \\{1,2,3\\}$, compute the discrete $L^1$ error for each numerical flux scheme relative to the exact solution:\n  $$E_{\\mathrm{HLL}}^{(k)} = \\Delta x \\sum_{i=0}^{N-1} \\left| U_{i,\\mathrm{HLL}}(T) - u_{\\mathrm{exact}}(x_i,T) \\right|,$$\n  $$E_{\\mathrm{UP}}^{(k)} = \\Delta x \\sum_{i=0}^{N-1} \\left| U_{i,\\mathrm{UP}}(T) - u_{\\mathrm{exact}}(x_i,T) \\right|.$$\n- For each test, also compute an indicator $I^{(k)}$ that is the integer $1$ if $E_{\\mathrm{HLL}}^{(k)} &lt; E_{\\mathrm{UP}}^{(k)}$ and $0$ otherwise.\n\nUnits: All quantities are nondimensional; report dimensionless numbers only.\n\nFinal output format:\n- Your program must produce a single line containing a comma-separated list enclosed in square brackets of the nine results in the order\n  $$\\left[ E_{\\mathrm{HLL}}^{(1)}, E_{\\mathrm{UP}}^{(1)}, I^{(1)}, E_{\\mathrm{HLL}}^{(2)}, E_{\\mathrm{UP}}^{(2)}, I^{(2)}, E_{\\mathrm{HLL}}^{(3)}, E_{\\mathrm{UP}}^{(3)}, I^{(3)} \\right],$$\n  where each error $E_{\\mathrm{HLL}}^{(k)}$ and $E_{\\mathrm{UP}}^{(k)}$ must be rounded to exactly six decimal places, and each indicator $I^{(k)}$ is an integer. For example, the printed string should look like $[\\dots]$ with exactly nine comma-separated entries and no additional text.", "solution": "The problem statement has been rigorously analyzed and is found to be valid. It constitutes a well-posed and scientifically grounded problem within the field of computational physics. All necessary parameters and definitions are provided, allowing for the unambiguous construction and verification of a numerical solution. The requirement to derive fundamental formulas from first principles is a standard pedagogical exercise to test foundational understanding, not a flaw in the problem's specification.\n\nWe proceed with the derivation and implementation of the solution.\n\n**1. Finite Volume Discretization**\n\nThe starting point is the integral form of the conservation law for a quantity $u$ over a control volume, or cell, $C_i = [x_{i-1/2}, x_{i+1/2}]$ of width $\\Delta x = x_{i+1/2} - x_{i-1/2}$:\n$$\n\\frac{d}{dt}\\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t)\\,dx + f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t)) = 0\n$$\nWe define the cell-average of $u$ over cell $C_i$ as $U_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x, t) dx$. Substituting this definition into the integral conservation law yields an exact equation for the evolution of cell averages:\n$$\n\\frac{d}{dt} (\\Delta x U_i(t)) + f_{i+1/2} - f_{i-1/2} = 0\n$$\nwhere $f_{i \\pm 1/2}$ denotes the instantaneous physical flux $f(u)$ at the cell interfaces $x_{i \\pm 1/2}$. Assuming a uniform grid where $\\Delta x$ is constant, this simplifies to:\n$$\n\\frac{dU_i}{dt} = - \\frac{1}{\\Delta x} (f_{i+1/2} - f_{i-1/2})\n$$\nThe core principle of the finite volume method is to replace the unknown point-wise physical fluxes $f_{i \\pm 1/2}$ with numerical fluxes $\\hat{f}_{i \\pm 1/2}$. The numerical flux at the interface between cell $i$ and cell $i+1$, denoted $\\hat{f}_{i+1/2}$, is a function of the cell-averaged states in the adjacent cells, i.e., $\\hat{f}_{i+1/2} = \\hat{f}(U_i, U_{i+1})$. The resulting semi-discrete scheme is:\n$$\n\\frac{dU_i}{dt} = - \\frac{1}{\\Delta x} \\left( \\hat{f}(U_i, U_{i+1}) - \\hat{f}(U_{i-1}, U_i) \\right)\n$$\nTo obtain a fully discrete scheme, we discretize time using the explicit forward Euler method. For a time step $\\Delta t$, the value of the cell average at time step $n+1$ is given in terms of the values at time step $n$:\n$$\n\\frac{U_i^{n+1} - U_i^n}{\\Delta t} = - \\frac{1}{\\Delta x} \\left( \\hat{f}(U_i^n, U_{i+1}^n) - \\hat{f}(U_{i-1}^n, U_i^n) \\right)\n$$\nThis gives the first-order accurate update formula:\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( \\hat{f}(U_i^n, U_{i+1}^n) - \\hat{f}(U_{i-1}^n, U_i^n) \\right)\n$$\n\n**2. Numerical Flux Functions**\n\nThe problem specifies the inviscid Burgers' equation, $u_t + \\left(\\frac{1}{2}u^2\\right)_x = 0$. The flux is $f(u) = \\frac{1}{2}u^2$, and its Jacobian, representing the characteristic speed, is $f'(u) = u$. We derive the two required numerical fluxes, $\\hat{f}(u_L, u_R)$, where $u_L$ and $u_R$ are the reconstructed states to the left and right of a cell interface. For our first-order scheme, these are simply the cell averages of the adjacent cells.\n\n**2.1. Basic Upwind Flux**\nThis flux is based on the solution to the linearized advection equation $u_t + a u_x = 0$, where information propagates with speed $a$. For the nonlinear Burgers' equation, we define a single local advection speed $a(u_L, u_R)$ at the interface. A common choice, which corresponds to the Roe average for this equation, is the arithmetic mean:\n$$\na(u_L, u_R) = \\frac{u_L + u_R}{2}\n$$\nThis speed is also the Rankine-Hugoniot shock speed. The upwind flux selects the flux from the \"upstream\" side, determined by the sign of this advection speed:\n$$\n\\hat{f}_{\\text{upwind}}(u_L, u_R) = \\begin{cases} f(u_L) & \\text{if } a(u_L, u_R) \\ge 0 \\\\ f(u_R) & \\text{if } a(u_L, u_R) < 0 \\end{cases}\n$$\n\n**2.2. Harten-Lax-van Leer (HLL) Flux**\nThe HLL flux is constructed from an approximate Riemann solver that assumes a two-wave model. It presumes the solution at the interface consists of three constant states ($u_L$, $u^*$, $u_R$) separated by two waves with speeds $S_L$ and $S_R$. These speeds must bound all characteristic speeds of the true Riemann solution. For the scalar Burgers' equation, the true wave speeds are bounded by $\\min(u_L, u_R)$ and $\\max(u_L, u_R)$. We therefore choose these as our signal speed estimates:\n$$\nS_L = \\min(u_L, u_R) \\quad \\text{and} \\quad S_R = \\max(u_L, u_R)\n$$\nBy applying the integral conservation law over a control volume encompassing the wave structure, one derives the HLL flux. The formula depends on the direction of wave propagation relative to the cell interface (where $x/t = 0$):\n- If $S_L \\ge 0$, the entire wave structure propagates to the right. The state at the interface is $u_L$, and the flux is $\\hat{f}_{\\text{HLL}} = f(u_L)$.\n- If $S_R \\le 0$, the entire structure propagates to the left. The state at the interface is $u_R$, and the flux is $\\hat{f}_{\\text{HLL}} = f(u_R)$.\n- If $S_L < 0 < S_R$, the interface lies within the two waves. The flux is a weighted average that ensures conservation:\n  $$\n  \\hat{f}_{\\text{HLL}}(u_L, u_R) = \\frac{S_R f(u_L) - S_L f(u_R) + S_L S_R (u_R - u_L)}{S_R - S_L}\n  $$\nThis combined formulation provides a robust and conservative numerical flux.\n\n**3. Exact Riemann Solution for the Inviscid Burgers' Equation**\n\nThe exact solution to the Riemann problem for the Burgers' equation is self-similar, depending only on the variable $\\xi = x/t$. The character of the solution is determined by the relation between the initial left and right states, $u_L$ and $u_R$.\n\n- **Shock Wave ($u_L > u_R$)**: A single discontinuity forms and travels with a constant speed $s$ given by the Rankine-Hugoniot condition:\n  $$\n  s = \\frac{f(u_R) - f(u_L)}{u_R - u_L} = \\frac{\\frac{1}{2}u_R^2 - \\frac{1}{2}u_L^2}{u_R - u_L} = \\frac{u_L + u_R}{2}\n  $$\n  The solution is a step function:\n  $$\n  u(x,t) = \\begin{cases} u_L, & \\text{if } x/t < s \\\\ u_R, & \\text{if } x/t > s \\end{cases}\n  $$\n\n- **Rarefaction Wave ($u_L < u_R$)**: The solution is a continuous \"fan\" that connects the left and right states. Within the fan, the solution is given by $u(x,t) = x/t$. The fan spans the region between the characteristic speeds $\\lambda(u_L)=u_L$ and $\\lambda(u_R)=u_R$. The complete solution is:\n  $$\n  u(x,t) = \\begin{cases} u_L, & \\text{if } x/t \\le u_L \\\\ x/t, & \\text{if } u_L < x/t < u_R \\\\ u_R, & \\text{if } x/t \\ge u_R \\end{cases}\n  $$\nThis exact solution will serve as the reference for computing the $L^1$ error of the numerical schemes.\n\n**4. Numerical Algorithm Summary**\n\nThe solver is implemented based on the following specifications:\n- **Domain and Grid**: $[x_L, x_R] = [-1, 1]$ with $N=400$ cells, so $\\Delta x = (1 - (-1))/400 = 0.005$.\n- **State Vector**: A NumPy array of size $N+2$ is used, with indices $1, \\dots, N$ representing the aformentioned cells and indices $0$ and $N+1$ representing the left and right ghost cells, respectively.\n- **Initial Condition**: Cell averages are initialized based on the position of their cell centers relative to the discontinuity at $x=0$.\n- **Boundary Conditions**: Transmissive (zero-gradient) conditions are enforced at each time step by setting the ghost cell values equal to the adjacent interior cell values: $U_0^n = U_1^n$ and $U_{N+1}^n = U_N^n$.\n- **Time Stepping**: The simulation runs from $t=0$ to $T=0.3$. The time step $\\Delta t$ is dynamically calculated at each step to satisfy the Courant-Friedrichs-Lewy (CFL) condition: $\\Delta t = \\nu \\frac{\\Delta x}{\\max_i |U_i^n|}$, with a CFL number $\\nu=0.9$. The final time step is adjusted to end exactly at $T$.\n- **Error Calculation**: For each test case and flux type, the discrete $L^1$ error is computed as $E = \\Delta x \\sum_{i=0}^{N-1} |U_{i,\\text{num}}(T) - u_{\\text{exact}}(x_i,T)|$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n    \n    # --- Problem Parameters ---\n    N = 400\n    x_L, x_R = -1.0, 1.0\n    T_final = 0.3\n    nu = 0.9  # CFL number\n    \n    test_cases = [\n        (2.0, 0.0),  # Case 1: Shock\n        (0.0, 2.0),  # Case 2: Rarefaction\n        (-1.0, 1.0), # Case 3: Transonic Rarefaction\n    ]\n\n    all_results = []\n\n    for k, (u_L, u_R) in enumerate(test_cases):\n        \n        # --- Run simulation with HLL flux ---\n        u_hll = run_simulation(N, x_L, x_R, T_final, nu, u_L, u_R, 'hll')\n        \n        # --- Run simulation with Upwind flux ---\n        u_upwind = run_simulation(N, x_L, x_R, T_final, nu, u_L, u_R, 'upwind')\n        \n        # --- Compute L1 errors ---\n        dx = (x_R - x_L) / N\n        x_centers = x_L + (np.arange(N) + 0.5) * dx\n\n        # Error for HLL\n        u_exact_vals = exact_solution(x_centers, T_final, u_L, u_R)\n        e_hll = dx * np.sum(np.abs(u_hll - u_exact_vals))\n        \n        # Error for Upwind\n        e_upwind = dx * np.sum(np.abs(u_upwind - u_exact_vals))\n\n        # Indicator\n        indicator = 1 if e_hll < e_upwind else 0\n\n        # Append results for this test case\n        all_results.extend([round(e_hll, 6), round(e_upwind, 6), indicator])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef run_simulation(N, x_L, x_R, T_final, nu, u_L, u_R, flux_type):\n    \"\"\"\n    Runs a single 1D FVM simulation for the Burgers equation.\n    \n    Args:\n        N (int): Number of cells.\n        x_L (float): Left boundary of the domain.\n        x_R (float): Right boundary of the domain.\n        T_final (float): Final simulation time.\n        nu (float): CFL number.\n        u_L (float): Initial left state.\n        u_R (float): Initial right state.\n        flux_type (str): 'hll' or 'upwind'.\n        \n    Returns:\n        numpy.ndarray: The solution array u_n at the final time in the physical domain.\n    \"\"\"\n    dx = (x_R - x_L) / N\n    x_centers = x_L + (np.arange(N) + 0.5) * dx\n\n    # Initialize solution array with 1 ghost cell on each side\n    u_n = np.zeros(N + 2)\n    u_n[1:-1] = np.where(x_centers < 0, u_L, u_R)\n\n    t = 0.0\n    \n    flux_func = get_flux_function(flux_type)\n\n    while t < T_final:\n        # Apply transmissive (zero-gradient) boundary conditions\n        u_n[0] = u_n[1]\n        u_n[-1] = u_n[-2]\n\n        # Calculate time step based on CFL condition\n        max_abs_u = np.max(np.abs(u_n))\n        if max_abs_u < 1e-9:\n            max_abs_u = 1e-9 # Avoid division by zero\n            \n        dt = nu * dx / max_abs_u\n        if t + dt > T_final:\n            dt = T_final - t\n\n        # Calculate fluxes at interfaces\n        # F[j] is the flux at the interface between cell j and j+1 (in the padded array)\n        fluxes = np.zeros(N + 1)\n        for j in range(N + 1):\n            fluxes[j] = flux_func(u_n[j], u_n[j+1])\n        \n        # Update solution using first-order finite volume scheme\n        u_np1 = np.copy(u_n)\n        for i in range(1, N + 1): # Iterate over physical cells\n            u_np1[i] = u_n[i] - (dt / dx) * (fluxes[i] - fluxes[i-1])\n\n        u_n = u_np1\n        t += dt\n\n    return u_n[1:-1] # Return only the physical domain\n\ndef get_flux_function(flux_type):\n    \"\"\"Returns the chosen numerical flux function.\"\"\"\n    if flux_type == 'hll':\n        return hll_flux\n    elif flux_type == 'upwind':\n        return upwind_flux\n    else:\n        raise ValueError(\"Invalid flux type specified.\")\n\ndef flux(u):\n    \"\"\"Physical flux for Burgers' equation.\"\"\"\n    return 0.5 * u**2\n\ndef upwind_flux(u_l, u_r):\n    \"\"\"Computes the basic upwind flux.\"\"\"\n    a = 0.5 * (u_l + u_r) # Roe average speed\n    if a >= 0:\n        return flux(u_l)\n    else:\n        return flux(u_r)\n\ndef hll_flux(u_l, u_r):\n    \"\"\"Computes the HLL flux.\"\"\"\n    if np.isclose(u_l, u_r):\n        return flux(u_l)\n        \n    f_l = flux(u_l)\n    f_r = flux(u_r)\n    \n    # Estimate signal speeds\n    s_l = min(u_l, u_r)\n    s_r = max(u_l, u_r)\n    \n    if s_l >= 0:\n        return f_l\n    elif s_r <= 0:\n        return f_r\n    else: # s_l < 0 < s_r\n        return (s_r * f_l - s_l * f_r + s_l * s_r * (u_r - u_l)) / (s_r - s_l)\n\ndef exact_solution(x, t, u_l, u_r):\n    \"\"\"Computes the exact Riemann solution for the Burgers equation.\"\"\"\n    if np.isclose(t, 0):\n        return np.where(x < 0, u_l, u_r)\n    \n    if u_l > u_r:  # Shock\n        s = 0.5 * (u_l + u_r)\n        return np.where(x / t < s, u_l, u_r)\n    else:  # Rarefaction\n        xi = x / t\n        solution = np.piecewise(xi, [xi <= u_l, (xi > u_l) & (xi < u_r), xi >= u_r],\n                                [u_l, lambda val: val, u_r])\n        return solution\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2394328"}]}