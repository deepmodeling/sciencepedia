{"hands_on_practices": [{"introduction": "To fully appreciate the power of the Convolution Theorem, it is essential to first understand the mechanics of the convolution operation itself. This exercise provides a foundational workout in discrete linear convolution, the process of combining two sequences to produce a third. By manually calculating the output using the \"flip-and-slide\" summation method, you will build a concrete intuition for how one signal modifies another, which is the cornerstone of linear systems analysis.", "problem": "Determine the linear convolution of the sequences $x[n] = \\{1, 3, 2\\}$ and $h[n] = \\{2, -1\\}$. Assume both sequences are defined for $n \\geq 0$ and zero elsewhere. The linear convolution $y[n] = x[n] * h[n]$ is given by:\n\n$$\ny[n] = \\sum_{k=-\\infty}^{\\infty} x[k] \\cdot h[n - k].\n$$\n\nCompute the resulting sequence $y[n]$ for all $n$ where it is non-zero, and express the answer as an ordered sequence of values corresponding to increasing $n$.", "solution": "The convolution sum is defined as:\n\n$$\ny[n] = \\sum_{k=-\\infty}^{\\infty} x[k] \\cdot h[n - k].\n$$\n\nGiven $x[n] = 0$ for $n < 0$ or $n > 2$, and $h[n] = 0$ for $n < 0$ or $n > 1$, the convolution $y[n]$ will be non-zero only for $n$ ranging from $0$ to $3$ (since the length of $y[n]$ is $3 + 2 - 1 = 4$). We compute $y[n]$ for $n = 0, 1, 2, 3$:\n\n- For $n = 0$:\n\n$$\ny[0] = \\sum_{k=0}^{2} x[k] \\cdot h[0 - k] = x[0] \\cdot h[0] + x[1] \\cdot h[-1] + x[2] \\cdot h[-2].\n$$\n\nSince $h[-1] = h[-2] = 0$,\n\n$$\ny[0] = (1) \\cdot (2) + (3) \\cdot (0) + (2) \\cdot (0) = 2.\n$$\n\n\n- For $n = 1$:\n\n$$\ny[1] = \\sum_{k=0}^{2} x[k] \\cdot h[1 - k] = x[0] \\cdot h[1] + x[1] \\cdot h[0] + x[2] \\cdot h[-1].\n$$\n\nSince $h[-1] = 0$,\n\n$$\ny[1] = (1) \\cdot (-1) + (3) \\cdot (2) + (2) \\cdot (0) = -1 + 6 = 5.\n$$\n\n\n- For $n = 2$:\n\n$$\ny[2] = \\sum_{k=0}^{2} x[k] \\cdot h[2 - k] = x[0] \\cdot h[2] + x[1] \\cdot h[1] + x[2] \\cdot h[0].\n$$\n\nSince $h[2] = 0$,\n\n$$\ny[2] = (1) \\cdot (0) + (3) \\cdot (-1) + (2) \\cdot (2) = -3 + 4 = 1.\n$$\n\n\n- For $n = 3$:\n\n$$\ny[3] = \\sum_{k=0}^{2} x[k] \\cdot h[3 - k] = x[0] \\cdot h[3] + x[1] \\cdot h[2] + x[2] \\cdot h[1].\n$$\n\nSince $h[3] = h[2] = 0$,\n\n$$\ny[3] = (1) \\cdot (0) + (3) \\cdot (0) + (2) \\cdot (-1) = -2.\n$$\n\n\n- For $n < 0$ or $n > 3$, $y[n] = 0$.  \n\nThus, the non-zero values of $y[n]$ are $y[0] = 2$, $y[1] = 5$, $y[2] = 1$, $y[3] = -2$.", "answer": "The linear convolution sequence is $y[n] = \\{2, 5, 1, -2\\}$ for $n = 0, 1, 2, 3$.  \n$$\\boxed{(2, 5, 1, -2)}$$", "id": "539926"}, {"introduction": "One of the most powerful applications of the Convolution Theorem is in solving inverse problems, such as deconvolution. This exercise presents a practical scenario where we know a system's impulse response and its output, and our task is to determine the original input signal. While this is a formidable challenge in the time domain, the Convolution Theorem elegantly transforms it into a simple division problem in the frequency domain, showcasing its immense problem-solving utility.", "problem": "Consider a linear time-invariant (LTI) system whose input-output relationship is described by the convolution integral $y(t) = (x * h)(t) = \\int_{-\\infty}^{\\infty} x(\\tau) h(t-\\tau) d\\tau$, where $x(t)$ is the input signal, $h(t)$ is the system's impulse response, and $y(t)$ is the output signal.\n\nThe analysis is to be performed in the continuous-time domain using the Fourier Transform, defined as $F(\\omega) = \\mathcal{F}\\{f(t)\\} = \\int_{-\\infty}^{\\infty} f(t) e^{-i\\omega t} dt$. The inverse transform is given by $f(t) = \\mathcal{F}^{-1}\\{F(\\omega)\\} = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} F(\\omega) e^{i\\omega t} d\\omega$.\n\nLet's define two fundamental pulse shapes:\n1. The unit rectangular pulse: $\\Pi(t) = \\begin{cases} 1, & |t| < 1/2 \\\\ 0, & |t| > 1/2 \\end{cases}$\n2. The unit triangular pulse: $\\Lambda(t) = \\begin{cases} 1 - |t|, & |t| < 1 \\\\ 0, & |t| > 1 \\end{cases}$\n\nThe impulse response of the LTI system is given by a rectangular pulse of amplitude $A$ and width $W$:\n$$h(t) = A \\cdot \\Pi\\left(\\frac{t}{W}\\right)$$\nWhen a certain unknown input signal $x(t)$ is applied to the system, the observed output is a triangular pulse of amplitude $B$ and total base width $4W$:\n$$y(t) = B \\cdot \\Lambda\\left(\\frac{t}{2W}\\right)$$\nHere, $A$, $B$, and $W$ are positive real constants.\n\nYour task is to determine the input signal $x(t)$ that produces this output. Express your final answer as a single closed-form analytic expression in terms of $A$, $B$, $W$, and the unit rectangular pulse function $\\Pi(t)$.", "solution": "The relationship between the input $x(t)$, impulse response $h(t)$, and output $y(t)$ of an LTI system is given by the convolution $y(t) = (x*h)(t)$.\n\nAccording to the Convolution Theorem, the Fourier transform of a convolution of two signals is the product of their individual Fourier transforms. Let $X(\\omega)$, $H(\\omega)$, and $Y(\\omega)$ be the Fourier transforms of $x(t)$, $h(t)$, and $y(t)$ respectively. Then,\n$$Y(\\omega) = X(\\omega) H(\\omega)$$\nTo find the input signal $x(t)$, we can first solve for its Fourier transform $X(\\omega)$:\n$$X(\\omega) = \\frac{Y(\\omega)}{H(\\omega)}$$\nThen, we find $x(t)$ by taking the inverse Fourier transform of $X(\\omega)$.\n\n**Step 1: Compute the Fourier Transform of the impulse response $h(t)$**\nThe impulse response is $h(t) = A \\cdot \\Pi\\left(\\frac{t}{W}\\right)$.\nFirst, we find the Fourier transform of the unit rectangular pulse $\\Pi(t)$:\n$$\\mathcal{F}\\{\\Pi(t)\\} = \\int_{-1/2}^{1/2} 1 \\cdot e^{-i\\omega t} dt = \\left[\\frac{e^{-i\\omega t}}{-i\\omega}\\right]_{-1/2}^{1/2} = \\frac{e^{-i\\omega/2} - e^{i\\omega/2}}{-i\\omega} = \\frac{2\\sin(\\omega/2)}{\\omega} = \\operatorname{sinc}\\left(\\frac{\\omega}{2}\\right)$$\nUsing the scaling property of the Fourier transform, $\\mathcal{F}\\{f(at)\\} = \\frac{1}{|a|}F(\\frac{\\omega}{a})$, with $a=1/W$:\n$$\\mathcal{F}\\left\\{\\Pi\\left(\\frac{t}{W}\\right)\\right\\} = W \\cdot \\frac{2\\sin(W\\omega/2)}{W\\omega} = W \\cdot \\operatorname{sinc}\\left(\\frac{W\\omega}{2}\\right)$$\nTherefore, the Fourier transform of $h(t)$ is:\n$$H(\\omega) = \\mathcal{F}\\left\\{A \\cdot \\Pi\\left(\\frac{t}{W}\\right)\\right\\} = A W \\cdot \\operatorname{sinc}\\left(\\frac{W\\omega}{2}\\right) = A W \\frac{\\sin(W\\omega/2)}{W\\omega/2}$$\n\n**Step 2: Compute the Fourier Transform of the output signal $y(t)$**\nThe output signal is $y(t) = B \\cdot \\Lambda\\left(\\frac{t}{2W}\\right)$.\nThe unit triangular pulse can be expressed as the convolution of the unit rectangular pulse with itself: $\\Lambda(t) = \\Pi(t) * \\Pi(t)$.\nUsing the Convolution Theorem, its Fourier transform is:\n$$\\mathcal{F}\\{\\Lambda(t)\\} = \\mathcal{F}\\{\\Pi(t)\\} \\cdot \\mathcal{F}\\{\\Pi(t)\\} = \\left(\\operatorname{sinc}\\left(\\frac{\\omega}{2}\\right)\\right)^2$$\nNow, we apply the scaling property with $a = 1/(2W)$:\n$$\\mathcal{F}\\left\\{\\Lambda\\left(\\frac{t}{2W}\\right)\\right\\} = 2W \\cdot \\left(\\operatorname{sinc}\\left(\\frac{2W\\omega}{2}\\right)\\right)^2 = 2W \\cdot \\operatorname{sinc}^2(W\\omega)$$\nThus, the Fourier transform of the output $y(t)$ is:\n$$Y(\\omega) = \\mathcal{F}\\left\\{B \\cdot \\Lambda\\left(\\frac{t}{2W}\\right)\\right\\} = 2BW \\cdot \\operatorname{sinc}^2(W\\omega) = 2BW \\left(\\frac{\\sin(W\\omega)}{W\\omega}\\right)^2$$\n\n**Step 3: Solve for $X(\\omega)$**\n$$X(\\omega) = \\frac{Y(\\omega)}{H(\\omega)} = \\frac{2BW \\left(\\frac{\\sin(W\\omega)}{W\\omega}\\right)^2}{AW \\frac{\\sin(W\\omega/2)}{W\\omega/2}} = \\frac{2B}{A} \\frac{\\sin^2(W\\omega)}{(W\\omega)^2} \\frac{W\\omega/2}{\\sin(W\\omega/2)}$$\n$$X(\\omega) = \\frac{B}{A} \\frac{\\sin^2(W\\omega)}{W\\omega \\sin(W\\omega/2)}$$\nUsing the double-angle identity $\\sin(2\\theta) = 2\\sin(\\theta)\\cos(\\theta)$, we have $\\sin(W\\omega) = 2\\sin(W\\omega/2)\\cos(W\\omega/2)$.\n$$X(\\omega) = \\frac{B}{A} \\frac{\\left(2\\sin(W\\omega/2)\\cos(W\\omega/2)\\right)^2}{W\\omega \\sin(W\\omega/2)} = \\frac{B}{A} \\frac{4\\sin^2(W\\omega/2)\\cos^2(W\\omega/2)}{W\\omega \\sin(W\\omega/2)}$$\n$$X(\\omega) = \\frac{4B}{A} \\frac{\\sin(W\\omega/2)\\cos^2(W\\omega/2)}{W\\omega} = \\frac{2B}{A} \\frac{\\sin(W\\omega/2)}{W\\omega/2} \\cos^2(W\\omega/2)$$\nUsing the identity $\\cos^2(\\theta) = \\frac{1+\\cos(2\\theta)}{2}$:\n$$X(\\omega) = \\frac{2B}{A} \\frac{\\sin(W\\omega/2)}{W\\omega/2} \\left(\\frac{1+\\cos(W\\omega)}{2}\\right) = \\frac{B}{A} \\left( \\frac{\\sin(W\\omega/2)}{W\\omega/2} + \\frac{\\sin(W\\omega/2)\\cos(W\\omega)}{W\\omega/2} \\right)$$\nUsing the product-to-sum identity $\\sin(\\alpha)\\cos(\\beta) = \\frac{1}{2}[\\sin(\\alpha+\\beta) + \\sin(\\alpha-\\beta)]$:\n$$\\sin(W\\omega/2)\\cos(W\\omega) = \\frac{1}{2}[\\sin(3W\\omega/2) + \\sin(-W\\omega/2)] = \\frac{1}{2}[\\sin(3W\\omega/2) - \\sin(W\\omega/2)]$$\nSubstituting this back into the expression for $X(\\omega)$:\n$$X(\\omega) = \\frac{B}{A} \\left( \\frac{\\sin(W\\omega/2)}{W\\omega/2} + \\frac{\\frac{1}{2}[\\sin(3W\\omega/2) - \\sin(W\\omega/2)]}{W\\omega/2} \\right)$$\n$$X(\\omega) = \\frac{B}{A} \\left( \\frac{2\\sin(W\\omega/2)}{W\\omega} + \\frac{\\sin(3W\\omega/2)}{W\\omega} - \\frac{\\sin(W\\omega/2)}{W\\omega} \\right)$$\n$$X(\\omega) = \\frac{B}{A W} \\left( \\frac{\\sin(W\\omega/2)}{\\omega} + \\frac{\\sin(3W\\omega/2)}{\\omega} \\right)$$\n\n**Step 4: Compute the inverse Fourier Transform of $X(\\omega)$ to find $x(t)$**\nWe need to find the inverse Fourier transform of terms like $\\frac{\\sin(k\\omega)}{\\omega}$. From the transform pair for a rectangular pulse:\n$$\\mathcal{F}\\left\\{\\Pi\\left(\\frac{t}{2k}\\right)\\right\\} = 2k \\frac{\\sin(k\\omega)}{k\\omega} = \\frac{2\\sin(k\\omega)}{\\omega}$$\nTherefore, the inverse transform is:\n$$\\mathcal{F}^{-1}\\left\\{\\frac{\\sin(k\\omega)}{\\omega}\\right\\} = \\frac{1}{2}\\Pi\\left(\\frac{t}{2k}\\right)$$\nFor the first term in $X(\\omega)$, $k_1 = W/2$:\n$$\\mathcal{F}^{-1}\\left\\{\\frac{\\sin(W\\omega/2)}{\\omega}\\right\\} = \\frac{1}{2}\\Pi\\left(\\frac{t}{2(W/2)}\\right) = \\frac{1}{2}\\Pi\\left(\\frac{t}{W}\\right)$$\nFor the second term, $k_2 = 3W/2$:\n$$\\mathcal{F}^{-1}\\left\\{\\frac{\\sin(3W\\omega/2)}{\\omega}\\right\\} = \\frac{1}{2}\\Pi\\left(\\frac{t}{2(3W/2)}\\right) = \\frac{1}{2}\\Pi\\left(\\frac{t}{3W}\\right)$$\nCombining these results:\n$$x(t) = \\mathcal{F}^{-1}\\{X(\\omega)\\} = \\frac{B}{AW} \\left[ \\frac{1}{2}\\Pi\\left(\\frac{t}{W}\\right) + \\frac{1}{2}\\Pi\\left(\\frac{t}{3W}\\right) \\right]$$\n$$x(t) = \\frac{B}{2AW} \\left[ \\Pi\\left(\\frac{t}{W}\\right) + \\Pi\\left(\\frac{t}{3W}\\right) \\right]$$\nThis expression is the sum of two centered rectangular pulses of different widths. $\\Pi(t/W)$ has width $W$ and $\\Pi(t/3W)$ has width $3W$.\nThe resulting signal is a two-level or 'wedding cake' pulse.\n- For $|t| < W/2$, both $\\Pi(t/W)$ and $\\Pi(t/3W)$ are 1. The height is $\\frac{B}{2AW}(1+1) = \\frac{B}{AW}$.\n- For $W/2 \\le |t| < 3W/2$, $\\Pi(t/W)=0$ and $\\Pi(t/3W)=1$. The height is $\\frac{B}{2AW}(0+1) = \\frac{B}{2AW}$.\n- For $|t| \\ge 3W/2$, both terms are zero.\nThe final expression is the most compact analytical form.", "answer": "$$ \\boxed{\\frac{B}{2AW} \\left[ \\Pi\\left(\\frac{t}{W}\\right) + \\Pi\\left(\\frac{t}{3W}\\right) \\right]} $$", "id": "540096"}, {"introduction": "The theoretical equivalence between time-domain convolution and frequency-domain multiplication is the heart of the Convolution Theorem, and it forms the backbone of modern digital signal processing. This programming challenge asks you to verify this principle numerically by implementing a filter in two distinct ways. By comparing the results of direct circular convolution with the frequency-multiplication approach, you will gain a practical, hands-on confirmation of this fundamental theorem's validity and computational power.", "problem": "Consider a discrete-time, length-$N$ signal $x_n$ and a frequency-domain filter $H_k$ defined for indices $k \\in \\{0,1,\\dots,N-1\\}$. Use the foundational definitions of the Discrete Fourier Transform (DFT) and its inverse, and the definition of circular convolution, to design a program that demonstrates the equivalence between filtering by multiplication in the frequency domain and convolution with the corresponding impulse response in the time domain. The foundational base you must use consists of: the definition of the Discrete Fourier Transform (DFT), the definition of the inverse Discrete Fourier Transform (IDFT), and the definition of circular convolution. No other shortcut formulae or theorems are to be assumed. The definitions are:\n- The Discrete Fourier Transform (DFT) is defined as $X_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2 \\pi i \\, nk/N}$.\n- The inverse Discrete Fourier Transform (IDFT) is defined as $x_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{2 \\pi i \\, nk/N}$.\n- Circular convolution is defined as $(x * h)_n = \\sum_{m=0}^{N-1} x_m \\, h_{(n-m) \\bmod N}$.\n\nYour program must:\n- Construct a noisy test signal $x_n$ for each test case as $x_n = \\sin\\!\\left(2 \\pi m n / N\\right) + \\sigma_{\\text{noise}} \\cdot \\eta_n$, where $\\eta_n$ are independent standard normal samples.\n- Design a filter $H_k$ directly in the frequency domain for each test case.\n- Compute the impulse response $h_n$ by applying the inverse Discrete Fourier Transform (IDFT) to $H_k$.\n- Compute the filtered output in two ways:\n    1. Frequency-domain method: compute $\\widehat{y}_n$ by taking the DFT of $x_n$, multiplying by $H_k$, and then applying the IDFT.\n    2. Time-domain method: compute $y_n$ by circularly convolving $x_n$ with $h_n$.\n- Quantify the difference by computing $\\Delta = \\max_{0 \\le n \\le N-1} \\left|y_n - \\widehat{y}_n\\right|$, using the complex absolute value if needed.\n\nTest Suite:\nImplement and evaluate the following four test cases, covering a typical scenario and boundary cases. Use a fixed random seed to ensure reproducibility.\n1. Happy path low-pass filtering: $N=256$, sinusoid index $m=5$, noise standard deviation $\\sigma_{\\text{noise}}=0.4$, and a Gaussian low-pass magnitude response $H_k = \\exp\\!\\left(-\\frac{d(k)^2}{2 \\sigma_f^2}\\right)$ where $d(k) = \\min(k, N-k)$ and $\\sigma_f=10$.\n2. All-pass filter boundary case: $N=128$, $m=12$, $\\sigma_{\\text{noise}}=0.6$, and $H_k = 1$ for all $k$.\n3. Zero filter boundary case: $N=128$, $m=12$, $\\sigma_{\\text{noise}}=0.6$, and $H_k = 0$ for all $k$.\n4. Notch filter on a targeted sinusoid: $N=256$, $m=40$, $\\sigma_{\\text{noise}}=0.5$, and $H_k = 1$ for all $k$ except $H_{m}=0$ and $H_{N-m}=0$.\n\nAlgorithmic and numerical requirements:\n- Implement circular convolution directly in the time domain using the definition $(x * h)_n = \\sum_{m=0}^{N-1} x_m \\, h_{(n-m) \\bmod N}$, without using frequency-domain multiplication for the convolution step.\n- Use the Discrete Fourier Transform (DFT) and the inverse Discrete Fourier Transform (IDFT) as available numerical routines to compute spectra and impulse responses.\n- Use a fixed seed for random number generation to ensure identical noisy signals across repeated runs.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the four values $\\Delta$ (one per test case) in the order listed above, for example: $[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4]$. All numbers are unitless, and angles in the sinusoid are in radians by definition of the sine function. The output must be reproducible and numerically stable under standard double-precision arithmetic.", "solution": "The problem requires a numerical demonstration of the Convolution Theorem for the Discrete Fourier Transform (DFT). This fundamental theorem states that circular convolution in the time domain corresponds to element-wise multiplication in the frequency domain. We are tasked with implementing both procedures for a set of test cases and verifying their equivalence by computing the maximum absolute difference between their outputs, a value denoted as $\\Delta$. This difference is expected to be non-zero but close to machine precision due to the nature of floating-point arithmetic.\n\nThe foundational definitions provided are:\n-   The Discrete Fourier Transform (DFT): $X_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2 \\pi i \\, nk/N}$ for discrete frequencies $k \\in \\{0, 1, \\dots, N-1\\}$.\n-   The inverse Discrete Fourier Transform (IDFT): $x_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{2 \\pi i \\, nk/N}$ for discrete time points $n \\in \\{0, 1, \\dots, N-1\\}$.\n-   Circular convolution of two length-$N$ signals, $x_n$ and $h_n$: $(x * h)_n = \\sum_{m=0}^{N-1} x_m h_{(n-m) \\bmod N}$.\n\nWe first formally establish the relationship that underpins this problem. Let $y_n$ be the circular convolution of $x_n$ and $h_n$, i.e., $y_n = (x * h)_n$. We take the DFT of $y_n$:\n$$Y_k = \\text{DFT}\\{y_n\\} = \\sum_{n=0}^{N-1} y_n e^{-2 \\pi i nk/N}$$\nSubstituting the definition of $y_n$:\n$$Y_k = \\sum_{n=0}^{N-1} \\left( \\sum_{m=0}^{N-1} x_m h_{(n-m) \\bmod N} \\right) e^{-2 \\pi i nk/N}$$\nBy swapping the order of summation, which is permissible for finite sums:\n$$Y_k = \\sum_{m=0}^{N-1} x_m \\sum_{n=0}^{N-1} h_{(n-m) \\bmod N} e^{-2 \\pi i nk/N}$$\nWe can rewrite the complex exponential term by adding and subtracting $mk$ in the exponent: $e^{-2 \\pi i nk/N} = e^{-2 \\pi i (n-m+m)k/N} = e^{-2 \\pi i (n-m)k/N} e^{-2 \\pi i mk/N}$.\n$$Y_k = \\sum_{m=0}^{N-1} x_m e^{-2 \\pi i mk/N} \\left( \\sum_{n=0}^{N-1} h_{(n-m) \\bmod N} e^{-2 \\pi i (n-m)k/N} \\right)$$\nLet us analyze the inner summation. We introduce a change of variable $p = (n-m) \\bmod N$. As the original index $n$ iterates from $0$ to $N-1$, the new index $p$ also iterates through a complete cycle of indices from $0$ to $N-1$. Thus, the inner summation becomes:\n$$\\sum_{p=0}^{N-1} h_p e^{-2 \\pi i pk/N} = \\text{DFT}\\{h_n\\} = H_k$$\nSubstituting this result back into the expression for $Y_k$:\n$$Y_k = \\left( \\sum_{m=0}^{N-1} x_m e^{-2 \\pi i mk/N} \\right) H_k$$\nThe remaining summation is, by definition, the DFT of the signal $x_n$, which is $X_k$. Therefore, we arrive at the Convolution Theorem:\n$$Y_k = X_k H_k$$\nApplying the IDFT to both sides gives $y_n = \\text{IDFT}\\{X_k H_k\\}$. This proves that the time-domain circular convolution $y_n = (x*h)_n$ is theoretically equivalent to the frequency-domain procedure of taking the DFT of $x_n$, multiplying by $H_k$, and taking the IDFT of the product. The problem asks for a numerical verification of this identity.\n\nThe algorithmic plan proceeds as follows. For each test case, we generate a signal $x_n$ and a filter $H_k$, and then compute the filtered signal via two distinct paths.\n\n1.  **Frequency-Domain Method (computing $\\widehat{y}_n$)**: This method directly applies the consequence of the Convolution Theorem.\n    a.  Compute the DFT of the input signal $x_n$ to obtain its spectrum, $X_k = \\text{DFT}\\{x_n\\}$.\n    b.  Multiply the signal spectrum by the filter's frequency response: $\\widehat{Y}_k = X_k \\cdot H_k$.\n    c.  Compute the IDFT of the resulting spectrum to transform the signal back to the time domain: $\\widehat{y}_n = \\text{IDFT}\\{\\widehat{Y}_k\\}$.\n\n2.  **Time-Domain Method (computing $y_n$)**: This method uses the fundamental definition of convolution.\n    a.  First, the filter's impulse response, $h_n$, which is its time-domain representation, must be found. This is achieved by computing the IDFT of the frequency response $H_k$: $h_n = \\text{IDFT}\\{H_k\\}$.\n    b.  Perform a direct circular convolution of the input signal $x_n$ with the impulse response $h_n$ using the explicit summation formula provided: $y_n = (x * h)_n = \\sum_{m=0}^{N-1} x_m h_{(n-m) \\bmod N}$. As per the problem's requirements, this is implemented algorithmically without recourse to frequency-domain shortcuts.\n\nFinally, we quantify the numerical discrepancy between the two methods by calculating the maximum absolute difference over all signal points, using the complex absolute value to be general:\n$$\\Delta = \\max_{0 \\le n \\le N-1} |y_n - \\widehat{y}_n|$$\nThis value $\\Delta$ serves as the final result for each test case. Due to the finite precision of floating-point arithmetic used in numerical computation, we expect $\\Delta$ to be a very small positive number (e.g., on the order of $10^{-14}$ or smaller), confirming the theorem's validity within the limits of numerical accuracy.\n\nThe implementation will use the `numpy` library for its efficient and standard implementations of the DFT/IDFT (via the Fast Fourier Transform algorithm) and for array manipulation. The direct circular convolution will be implemented manually using nested loops. A fixed random seed is used to ensure the generated noisy signals are reproducible across runs.", "answer": "```python\nimport numpy as np\n\ndef circular_convolution(x: np.ndarray, h: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the circular convolution of two signals x and h based on the definition.\n    (x * h)_n = sum_{m=0}^{N-1} x_m * h_{(n-m) mod N}\n    \"\"\"\n    N = len(x)\n    if len(h) != N:\n        raise ValueError(\"Signals must have the same length for circular convolution.\")\n    \n    y = np.zeros(N, dtype=np.complex128)\n    for n in range(N):\n        accumulator = 0.0 + 0.0j\n        for m in range(N):\n            # The modulo operator % in Python correctly handles negative results,\n            # which is suitable for (n-m) mod N.\n            h_index = (n - m) % N\n            accumulator += x[m] * h[h_index]\n        y[n] = accumulator\n    return y\n\ndef solve_case(N: int, m: int, sigma_noise: float, filter_type: str, sigma_f: float = None):\n    \"\"\"\n    Solves a single test case for demonstrating the convolution theorem.\n    \"\"\"\n    # 1. Construct the noisy test signal\n    n_indices = np.arange(N)\n    signal_component = np.sin(2 * np.pi * m * n_indices / N)\n    noise_component = sigma_noise * np.random.standard_normal(N)\n    x_n = signal_component + noise_component\n\n    # 2. Design the filter H_k\n    k_indices = np.arange(N)\n    if filter_type == 'gaussian':\n        d_k = np.minimum(k_indices, N - k_indices)\n        H_k = np.exp(-(d_k**2) / (2 * sigma_f**2))\n    elif filter_type == 'all-pass':\n        H_k = np.ones(N)\n    elif filter_type == 'zero':\n        H_k = np.zeros(N)\n    elif filter_type == 'notch':\n        H_k = np.ones(N)\n        H_k[m] = 0\n        H_k[N - m] = 0\n    else:\n        raise ValueError(f\"Unknown filter type: {filter_type}\")\n\n    # 3. Compute the filtered output in two ways\n\n    # Method 1: Frequency-domain multiplication\n    X_k = np.fft.fft(x_n)\n    Y_hat_k = X_k * H_k\n    y_hat_n = np.fft.ifft(Y_hat_k)\n\n    # Method 2: Time-domain circular convolution\n    h_n = np.fft.ifft(H_k)\n    y_n = circular_convolution(x_n, h_n)\n\n    # 4. Quantify the difference\n    delta = np.max(np.abs(y_n - y_hat_n))\n    return delta\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Fixed seed for reproducibility as required\n    np.random.seed(0)\n\n    test_cases = [\n        {'N': 256, 'm': 5, 'sigma_noise': 0.4, 'filter_type': 'gaussian', 'sigma_f': 10.0},\n        {'N': 128, 'm': 12, 'sigma_noise': 0.6, 'filter_type': 'all-pass'},\n        {'N': 128, 'm': 12, 'sigma_noise': 0.6, 'filter_type': 'zero'},\n        {'N': 256, 'm': 40, 'sigma_noise': 0.5, 'filter_type': 'notch'}\n    ]\n\n    results = []\n    for case in test_cases:\n        delta = solve_case(\n            N=case['N'], \n            m=case['m'], \n            sigma_noise=case['sigma_noise'], \n            filter_type=case['filter_type'],\n            sigma_f=case.get('sigma_f') # Pass sigma_f only if it exists\n        )\n        results.append(delta)\n\n    # Format the output as specified\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\nsolve()\n```", "id": "3219731"}]}