{"hands_on_practices": [{"introduction": "This first practice grounds us in the fundamental process of matrix assembly by connecting physical properties to mathematical structure. We will manually assemble a stiffness matrix for a simple 1D problem where the material coefficient $k(x)$ varies between elements [@problem_id:3206749]. This exercise not only reinforces the assembly mechanics but also introduces the crucial concept of the spectral condition number, providing insight into how abrupt changes in material properties can affect the numerical stability of the final linear system.", "problem": "Consider the one-dimensional diffusion Partial Differential Equation (PDE) $- \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) = f(x)$ on the domain $[0, 3h]$ with homogeneous Dirichlet boundary conditions $u(0) = 0$ and $u(3h) = 0$. The material coefficient $k(x)$ is piecewise constant and alternates across a uniform mesh of $3$ elements and $4$ nodes at $x_1 = 0$, $x_2 = h$, $x_3 = 2h$, and $x_4 = 3h$ as follows: $k(x) = k_1$ on $[0, h]$, $k(x) = k_2$ on $[h, 2h]$, and $k(x) = k_1$ on $[2h, 3h]$, with $k_1 \\gg k_2 > 0$. Using a standard Galerkin Finite Element Method (FEM) with continuous, piecewise-linear basis functions associated with the nodes, proceed from the weak formulation and the definition of element stiffness entries to assemble the global stiffness matrix. Then, after imposing the homogeneous Dirichlet boundary conditions to eliminate the boundary degrees of freedom at $x_1$ and $x_4$, extract the reduced global stiffness matrix associated with the interior nodes at $x_2$ and $x_3$.\n\nFrom first principles and without invoking pre-assembled formulas, compute the exact spectral condition number in the matrix $2$-norm of this reduced stiffness matrix as a closed-form expression in terms of $k_1$ and $k_2$. Provide your final answer as a single simplified analytical expression. No rounding is required, and no units should be included in the final expression.", "solution": "The user has provided a problem that requires the derivation of the spectral condition number for a reduced stiffness matrix arising from a one-dimensional finite element problem.\n\n### Step 1: Problem Validation\n\n**Extracted Givens:**\n- **PDE:** $- \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) = f(x)$\n- **Domain:** $x \\in [0, 3h]$\n- **Boundary Conditions (BCs):** $u(0) = 0$ and $u(3h) = 0$ (homogeneous Dirichlet).\n- **Mesh:** Uniform mesh with $3$ elements and $4$ nodes: $x_1 = 0$, $x_2 = h$, $x_3 = 2h$, $x_4 = 3h$.\n- **Material Coefficient:** $k(x)$ is piecewise constant:\n  - $k(x) = k_1$ for $x \\in [0, h]$\n  - $k(x) = k_2$ for $x \\in [h, 2h]$\n  - $k(x) = k_1$ for $x \\in [2h, 3h]$\n- **Coefficient Constraint:** $k_1 \\gg k_2 > 0$.\n- **Method:** Standard Galerkin Finite Element Method (FEM) with continuous, piecewise-linear basis functions.\n- **Task:**\n  1. Derive the weak formulation.\n  2. Assemble the global stiffness matrix.\n  3. Impose the BCs to obtain the reduced global stiffness matrix for the interior nodes at $x_2$ and $x_3$.\n  4. Compute the exact spectral condition number in the matrix $2$-norm of this reduced matrix as a closed-form expression in terms of $k_1$ and $k_2$.\n\n**Validation Using Extracted Givens:**\n1.  **Scientifically Grounded:** The problem is a standard exercise in the numerical analysis of partial differential equations using the Finite Element Method. All concepts—the diffusion equation, weak formulation, Galerkin method, stiffness matrix, and condition number—are fundamental and well-established within mathematics and engineering.\n2.  **Well-Posed:** The problem provides all necessary information to construct the stiffness matrix and compute its condition number. The setup is clear, and the objective is to find a specific analytical expression, which constitutes a well-posed mathematical task.\n3.  **Objective:** The problem is stated in precise, technical language, free from any subjective or ambiguous terms.\n4.  **Completeness and Consistency:** The problem is self-contained. The domain, boundary conditions, mesh, basis functions, and material properties are all specified, and there are no internal contradictions.\n5.  **Realism:** The setup corresponds to a physical system, such as heat conduction or fluid flow through a porous medium, composed of a three-layered material where the outer layers have a different property (e.g., conductivity) than the inner layer.\n\n**Verdict:** The problem is valid, scientifically sound, well-posed, and complete. I will proceed with the solution.\n\n### Step 2: Derivation and Solution\n\n**Weak Formulation**\nWe begin with the governing PDE:\n$$ - \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) = f(x) \\quad \\text{for } x \\in (0, 3h) $$\nWe multiply by a test function $v(x)$ from the space of functions that vanish at the Dirichlet boundaries, which is $H_0^1(0, 3h)$. Integrating over the domain yields:\n$$ -\\int_{0}^{3h} v(x) \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) dx = \\int_{0}^{3h} v(x) f(x) dx $$\nApplying integration by parts to the left-hand side:\n$$ \\int_{0}^{3h} \\frac{dv}{dx} k(x) \\frac{du}{dx} dx - \\left[ v(x) k(x) \\frac{du}{dx} \\right]_{0}^{3h} = \\int_{0}^{3h} v(x) f(x) dx $$\nSince the test function $v(x)$ must satisfy the homogeneous Dirichlet boundary conditions, $v(0) = v(3h) = 0$, the boundary term vanishes. The weak formulation is: find $u \\in H_0^1(0, 3h)$ such that for all $v \\in H_0^1(0, 3h)$:\n$$ \\int_{0}^{3h} k(x) \\frac{du}{dx} \\frac{dv}{dx} dx = \\int_{0}^{3h} f(x) v(x) dx $$\nThe left-hand side defines the bilinear form $a(u,v)$, from which the stiffness matrix is derived.\n\n**Finite Element Discretization**\nWe use continuous, piecewise-linear basis functions $\\phi_i(x)$ (hat functions) associated with each node $x_i$, such that $\\phi_i(x_j) = \\delta_{ij}$. The approximate solution is $u_h(x) = \\sum_{j=1}^{4} U_j \\phi_j(x)$.\nThe derivatives of the basis functions are piecewise constant. On an element of length $h$, the derivatives are $\\pm 1/h$.\n- $\\phi'_1(x) = -1/h$ on $[0, h]$\n- $\\phi'_2(x) = 1/h$ on $[0, h]$ and $-1/h$ on $[h, 2h]$\n- $\\phi'_3(x) = 1/h$ on $[h, 2h]$ and $-1/h$ on $[2h, 3h]$\n- $\\phi'_4(x) = 1/h$ on $[2h, 3h]$\n\n**Assembly of the Global Stiffness Matrix**\nThe entries of the global stiffness matrix $K$ are given by $K_{ij} = a(\\phi_j, \\phi_i) = \\int_{0}^{3h} k(x) \\phi'_i(x) \\phi'_j(x) dx$. We compute the non-zero entries by integrating over each element where the product of derivatives is non-zero.\n\n- **Element 1: $[0, h]$ where $k(x) = k_1$**\n  - $K_{11}^{(1)} = \\int_{0}^{h} k_1 (\\phi'_1)^2 dx = \\int_{0}^{h} k_1 (-1/h)^2 dx = \\frac{k_1}{h}$\n  - $K_{22}^{(1)} = \\int_{0}^{h} k_1 (\\phi'_2)^2 dx = \\int_{0}^{h} k_1 (1/h)^2 dx = \\frac{k_1}{h}$\n  - $K_{12}^{(1)} = K_{21}^{(1)} = \\int_{0}^{h} k_1 \\phi'_1 \\phi'_2 dx = \\int_{0}^{h} k_1 (-1/h)(1/h) dx = -\\frac{k_1}{h}$\n\n- **Element 2: $[h, 2h]$ where $k(x) = k_2$**\n  - $K_{22}^{(2)} = \\int_{h}^{2h} k_2 (\\phi'_2)^2 dx = \\int_{h}^{2h} k_2 (-1/h)^2 dx = \\frac{k_2}{h}$\n  - $K_{33}^{(2)} = \\int_{h}^{2h} k_2 (\\phi'_3)^2 dx = \\int_{h}^{2h} k_2 (1/h)^2 dx = \\frac{k_2}{h}$\n  - $K_{23}^{(2)} = K_{32}^{(2)} = \\int_{h}^{2h} k_2 \\phi'_2 \\phi'_3 dx = \\int_{h}^{2h} k_2 (-1/h)(1/h) dx = -\\frac{k_2}{h}$\n\n- **Element 3: $[2h, 3h]$ where $k(x) = k_1$**\n  - $K_{33}^{(3)} = \\int_{2h}^{3h} k_1 (\\phi'_3)^2 dx = \\int_{2h}^{3h} k_1 (-1/h)^2 dx = \\frac{k_1}{h}$\n  - $K_{44}^{(3)} = \\int_{2h}^{3h} k_1 (\\phi'_4)^2 dx = \\int_{2h}^{3h} k_1 (1/h)^2 dx = \\frac{k_1}{h}$\n  - $K_{34}^{(3)} = K_{43}^{(3)} = \\int_{2h}^{3h} k_1 \\phi'_3 \\phi'_4 dx = \\int_{2h}^{3h} k_1 (-1/h)(1/h) dx = -\\frac{k_1}{h}$\n\nThe global stiffness matrix $K$ is assembled by summing the contributions from each element:\n- $K_{11} = K_{11}^{(1)} = \\frac{k_1}{h}$\n- $K_{22} = K_{22}^{(1)} + K_{22}^{(2)} = \\frac{k_1}{h} + \\frac{k_2}{h} = \\frac{k_1+k_2}{h}$\n- $K_{33} = K_{33}^{(2)} + K_{33}^{(3)} = \\frac{k_2}{h} + \\frac{k_1}{h} = \\frac{k_1+k_2}{h}$\n- $K_{44} = K_{44}^{(3)} = \\frac{k_1}{h}$\n- $K_{12} = K_{21} = -\\frac{k_1}{h}$\n- $K_{23} = K_{32} = -\\frac{k_2}{h}$\n- $K_{34} = K_{43} = -\\frac{k_1}{h}$\n\nThe resulting $4 \\times 4$ global stiffness matrix is:\n$$ K = \\frac{1}{h} \\begin{pmatrix} k_1 & -k_1 & 0 & 0 \\\\ -k_1 & k_1+k_2 & -k_2 & 0 \\\\ 0 & -k_2 & k_1+k_2 & -k_1 \\\\ 0 & 0 & -k_1 & k_1 \\end{pmatrix} $$\n\n**Imposing Boundary Conditions and Extracting the Reduced Matrix**\nThe homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(3h)=0$ correspond to setting the nodal values $U_1=0$ and $U_4=0$. This is equivalent to removing the first and fourth rows and columns from the global matrix $K$ to obtain the reduced system for the interior, unknown degrees of freedom $U_2$ and $U_3$. The reduced stiffness matrix, $K_{red}$, is the $2 \\times 2$ submatrix corresponding to nodes $2$ and $3$:\n$$ K_{red} = \\frac{1}{h} \\begin{pmatrix} k_1+k_2 & -k_2 \\\\ -k_2 & k_1+k_2 \\end{pmatrix} $$\n\n**Computing the Spectral Condition Number**\nThe spectral condition number (in the $2$-norm) of a symmetric positive definite matrix is the ratio of its largest eigenvalue to its smallest eigenvalue: $\\kappa_2(A) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)}$.\n\nWe find the eigenvalues of $K_{red}$ by solving the characteristic equation $\\det(K_{red} - \\lambda I) = 0$.\n$$ \\det \\begin{pmatrix} \\frac{k_1+k_2}{h} - \\lambda & -\\frac{k_2}{h} \\\\ -\\frac{k_2}{h} & \\frac{k_1+k_2}{h} - \\lambda \\end{pmatrix} = 0 $$\n$$ \\left(\\frac{k_1+k_2}{h} - \\lambda\\right)^2 - \\left(-\\frac{k_2}{h}\\right)^2 = 0 $$\n$$ \\left(\\frac{k_1+k_2}{h} - \\lambda\\right)^2 = \\frac{k_2^2}{h^2} $$\nTaking the square root of both sides:\n$$ \\frac{k_1+k_2}{h} - \\lambda = \\pm \\frac{k_2}{h} $$\nThis gives two possible values for $\\lambda$:\n1.  $\\lambda_a = \\frac{k_1+k_2}{h} - \\frac{k_2}{h} = \\frac{k_1}{h}$\n2.  $\\lambda_b = \\frac{k_1+k_2}{h} + \\frac{k_2}{h} = \\frac{k_1+2k_2}{h}$\n\nSince $k_1 > 0$ and $k_2 > 0$, it is clear that $\\lambda_b > \\lambda_a$. Therefore:\n- $\\lambda_{\\min}(K_{red}) = \\frac{k_1}{h}$\n- $\\lambda_{\\max}(K_{red}) = \\frac{k_1+2k_2}{h}$\n\nThe spectral condition number of $K_{red}$ is:\n$$ \\kappa_2(K_{red}) = \\frac{\\lambda_{\\max}(K_{red})}{\\lambda_{\\min}(K_{red})} = \\frac{\\frac{k_1+2k_2}{h}}{\\frac{k_1}{h}} $$\n$$ \\kappa_2(K_{red}) = \\frac{k_1+2k_2}{k_1} $$\nSimplifying the expression gives the final answer:\n$$ \\kappa_2(K_{red}) = 1 + \\frac{2k_2}{k_1} $$", "answer": "$$\\boxed{1 + \\frac{2k_2}{k_1}}$$", "id": "3206749"}, {"introduction": "Building on our 1D foundation, this practice scales the assembly process up to a more realistic and complex 3D domain. You will implement the assembly for a mesh of tetrahedral elements, a common choice for modeling intricate geometries in engineering and science [@problem_id:3206634]. This exercise introduces the essential technique of mapping from a simple 'reference' element to a 'physical' element in space using the Jacobian matrix $J$, a cornerstone of modern finite element software.", "problem": "Consider the scalar diffusion Partial Differential Equation (PDE) $- \\nabla \\cdot (\\kappa \\nabla u) = f$ on a polyhedral domain $\\Omega \\subset \\mathbb{R}^3$ with Dirichlet boundary data $u = g$ on $\\partial \\Omega$. Using the standard Galerkin Finite Element Method (FEM) with first-order (piecewise linear) tetrahedral elements, assemble the global stiffness matrix. The assembly must follow from the weak form derived from the PDE, without using any shortcut formulas.\n\nStart from the weak formulation: find $u \\in H^1(\\Omega)$ such that $u = g$ on $\\partial \\Omega$ and\n$$\na(u,v) = \\ell(v) \\quad \\text{for all } v \\in H_0^1(\\Omega),\n$$\nwhere\n$$\na(u,v) = \\int_{\\Omega} \\kappa \\, \\nabla u \\cdot \\nabla v \\, \\mathrm{d}x, \\qquad \\ell(v) = \\int_{\\Omega} f \\, v \\, \\mathrm{d}x.\n$$\nDiscretize with $N$ nodes and $M$ tetrahedra. For each tetrahedron with vertices $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4 \\in \\mathbb{R}^3$, define the affine map from the reference tetrahedron with vertices $(0,0,0)$, $(1,0,0)$, $(0,1,0)$, $(0,0,1)$ via the Jacobian matrix\n$$\nJ = \\begin{bmatrix} \\mathbf{x}_2 - \\mathbf{x}_1 & \\mathbf{x}_3 - \\mathbf{x}_1 & \\mathbf{x}_4 - \\mathbf{x}_1 \\end{bmatrix} \\in \\mathbb{R}^{3 \\times 3}.\n$$\nLet $\\nabla \\hat{N}_1 = (-1,-1,-1)^\\top$, $\\nabla \\hat{N}_2 = (1,0,0)^\\top$, $\\nabla \\hat{N}_3 = (0,1,0)^\\top$, $\\nabla \\hat{N}_4 = (0,0,1)^\\top$ be the gradients of the reference shape functions. The physical gradients are\n$$\n\\nabla N_i = J^{-\\top} \\nabla \\hat{N}_i, \\quad i \\in \\{1,2,3,4\\},\n$$\nand the physical tetrahedron volume is\n$$\n|T| = \\frac{|\\det(J)|}{6}.\n$$\nUsing these, the element stiffness matrix entries are\n$$\nK_e(i,j) = \\kappa_e \\, |T| \\, \\nabla N_i \\cdot \\nabla N_j, \\quad i,j \\in \\{1,2,3,4\\},\n$$\nwhere $\\kappa_e$ is the constant diffusion coefficient on the tetrahedron. Assemble the global stiffness matrix $K \\in \\mathbb{R}^{N \\times N}$ by summing the contributions from all elements according to their connectivity.\n\nTo impose Dirichlet boundary conditions at a set of boundary nodes $G$ with prescribed values $\\{g_k\\}_{k \\in G}$, partition the index set of nodes into free nodes $F$ and boundary nodes $G$, and solve the reduced linear system obtained from the discrete weak form:\n$$\nK_{FF} \\, u_F = b_F - K_{FG} \\, u_G,\n$$\nwhere $b$ is the global load vector with entries $b_i = \\int_{\\Omega} f N_i \\, \\mathrm{d}x$. In this problem, use $f \\equiv 0$, so $b = 0$. The final interior solution on the free nodes is $u_F$, and the complete nodal field is obtained by combining $u_F$ with the prescribed $u_G$.\n\nImplement the described assembly and Dirichlet enforcement and produce specific quantitative outputs for the following test suite. Throughout, use the analytic function $u^\\star(x,y,z) = x + y + z$ to define Dirichlet data $g(\\mathbf{x}) = u^\\star(\\mathbf{x})$ at boundary nodes.\n\nTest suite:\n- Case $A$ (single tetrahedron):\n  - Nodes (indices $0$ to $3$): $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (1,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$.\n  - Elements: one tetrahedron with connectivity $[0,1,2,3]$.\n  - Element diffusion coefficient: $\\kappa = 2$.\n  - Dirichlet boundary nodes: $G = \\{0,1,2,3\\}$ with $u_G = \\{u^\\star(\\mathbf{x}_k)\\}_{k \\in G}$.\n  - Right-hand side: $f \\equiv 0$.\n  - Outputs to compute:\n    1. The Frobenius norm $\\|K\\|_F$ of the assembled global stiffness matrix $K$.\n    2. The maximum absolute error at free nodes, defined as $\\max_{i \\in F} |u_F(i) - u^\\star(\\mathbf{x}_i)|$. If $F$ is empty, define this value to be $0$.\n\n- Case $B$ (a tetrahedron subdivided by one interior node):\n  - Nodes (indices $0$ to $4$): $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (1,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$, $\\mathbf{x}_4 = (0.25,0.25,0.25)$.\n  - Elements: four tetrahedra with connectivity $[4,1,2,3]$, $[4,0,2,3]$, $[4,0,1,3]$, $[4,0,1,2]$.\n  - Element diffusion coefficient: $\\kappa = 1$ for each tetrahedron.\n  - Dirichlet boundary nodes: $G = \\{0,1,2,3\\}$ with $u_G = \\{u^\\star(\\mathbf{x}_k)\\}_{k \\in G}$; the interior node is $4$.\n  - Right-hand side: $f \\equiv 0$.\n  - Outputs to compute:\n    1. The Frobenius norm $\\|K\\|_F$ of the assembled global stiffness matrix $K$.\n    2. The maximum absolute error at the free nodes $F = \\{4\\}$, defined as $|u_F(4) - u^\\star(\\mathbf{x}_4)|$.\n\n- Case $C$ (a near-degenerate sliver tetrahedron):\n  - Nodes (indices $0$ to $3$): $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (10^{-6},0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$.\n  - Elements: one tetrahedron with connectivity $[0,1,2,3]$.\n  - Element diffusion coefficient: $\\kappa = 1$.\n  - Dirichlet boundary nodes: $G = \\{0,1,2,3\\}$ with $u_G = \\{u^\\star(\\mathbf{x}_k)\\}_{k \\in G}$.\n  - Right-hand side: $f \\equiv 0$.\n  - Outputs to compute:\n    1. The Frobenius norm $\\|K\\|_F$ of the assembled global stiffness matrix $K$.\n    2. The maximum absolute error at free nodes; since $F$ is empty, define this value to be $0$.\n\nYour program must implement the finite element assembly for $3$-dimensional tetrahedra as described, construct the global stiffness matrix, enforce Dirichlet boundary conditions via system partitioning, solve for interior nodal values when applicable, and compute for each case the pair of outputs described above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\|K\\|_F^{(A)}, \\mathrm{err}^{(A)}, \\|K\\|_F^{(B)}, \\mathrm{err}^{(B)}, \\|K\\|_F^{(C)}, \\mathrm{err}^{(C)}]$. No physical units are involved; all quantities are dimensionless real numbers. Angles are not used. The outputs are real-valued floats.", "solution": "The problem statement has been meticulously validated and is determined to be valid. It is scientifically grounded in the principles of the Finite Element Method (FEM) for solving partial differential equations, is well-posed with a complete and consistent set of data and definitions, and is expressed in objective, formal language. The provided formulas for the affine mapping, physical gradients, element volume, and element stiffness matrix are standard and correct for first-order (P1) tetrahedral elements. The test cases are well-defined and serve to verify the implementation against a reference element, a mesh with an interior node, and a geometrically degenerate element.\n\nThe task is to implement the assembly of the global stiffness matrix for the scalar diffusion equation, $- \\nabla \\cdot (\\kappa \\nabla u) = f$, discretized using the Finite Element Method with piecewise linear basis functions on a tetrahedral mesh. The assembled matrix is then used to solve for unknown nodal values after enforcing Dirichlet boundary conditions. The specific outputs required are the Frobenius norm of the global stiffness matrix and the maximum error at interior nodes for three distinct test cases.\n\nThe general procedure follows these steps:\n1.  Initialize an $N \\times N$ global stiffness matrix $K$ with all entries set to zero, where $N$ is the total number of nodes in the mesh.\n2.  Iterate through each tetrahedron (element) $T_e$ in the mesh. For each element:\n    a. Identify the global indices of its four vertices, $[n_1, n_2, n_3, n_4]$, from the element connectivity list.\n    b. Retrieve the coordinates of these vertices: $\\mathbf{x}_{n_1}, \\mathbf{x}_{n_2}, \\mathbf{x}_{n_3}, \\mathbf{x}_{n_4}$.\n    c. Form the Jacobian matrix $J_e$ of the affine map from the reference tetrahedron to the physical tetrahedron $T_e$. The problem defines this as $J_e = \\begin{bmatrix} \\mathbf{x}_{n_2} - \\mathbf{x}_{n_1} & \\mathbf{x}_{n_3} - \\mathbf{x}_{n_1} & \\mathbf{x}_{n_4} - \\mathbf{x}_{n_1} \\end{bmatrix}$.\n    d. Calculate the volume of the element, $|T_e| = \\frac{|\\det(J_e)|}{6}$.\n    e. Compute the inverse transpose of the Jacobian, $J_e^{-\\top}$.\n    f. Determine the gradients of the four physical basis functions, $\\nabla N_i$, by transforming the reference gradients, $\\nabla \\hat{N}_i$, using the relation $\\nabla N_i = J_e^{-\\top} \\nabla \\hat{N}_i$. The reference gradients are given as $\\nabla \\hat{N}_1 = (-1,-1,-1)^\\top$, $\\nabla \\hat{N}_2 = (1,0,0)^\\top$, $\\nabla \\hat{N}_3 = (0,1,0)^\\top$, and $\\nabla \\hat{N}_4 = (0,0,1)^\\top$.\n    g. Calculate the $4 \\times 4$ element stiffness matrix $K_e$, whose entries are given by $K_e(i,j) = \\kappa_e |T_e| (\\nabla N_i \\cdot \\nabla N_j)$, where $\\kappa_e$ is the constant diffusion coefficient on element $T_e$. In matrix form, this can be written as $K_e = \\kappa_e |T_e| G_e^\\top G_e$, where $G_e = \\begin{bmatrix} \\nabla N_1 & \\nabla N_2 & \\nabla N_3 & \\nabla N_4 \\end{bmatrix}$ is the $3 \\times 4$ matrix of physical basis function gradients.\n    h. Add the contributions of $K_e$ to the global stiffness matrix $K$. For each entry $K_e(i,j)$, its value is added to the global entry $K(n_i, n_j)$.\n3.  After iterating through all elements, calculate the Frobenius norm of the assembled global matrix $K$, $\\|K\\|_F = \\sqrt{\\sum_{i,j=1}^N |K_{ij}|^2}$.\n4.  To find the solution, partition the nodes into a set of free (interior) nodes $F$ and a set of Dirichlet boundary nodes $G$. The problem uses a source term $f \\equiv 0$, so the load vector is zero. The system to be solved for the free node values $u_F$ is $K_{FF} u_F = -K_{FG} u_G$, where $K_{FF}$ and $K_{FG}$ are submatrices of $K$, and $u_G$ is the vector of prescribed values at the boundary nodes. The prescribed values are derived from the analytic function $u^\\star(x,y,z) = x+y+z$.\n5.  After solving for $u_F$, compute the maximum absolute error at the free nodes: $\\max_{i \\in F} |u_F(i) - u^\\star(\\mathbf{x}_i)|$. If the set $F$ is empty, this error is defined to be $0$.\n\n**Case A: Single Reference Tetrahedron**\n-   Nodes: $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (1,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$. $N=4$.\n-   Connectivity: $[0,1,2,3]$.\n-   The Jacobian matrix is $J = [\\mathbf{x}_1-\\mathbf{x}_0 \\ \\ \\mathbf{x}_2-\\mathbf{x}_0 \\ \\ \\mathbf{x}_3-\\mathbf{x}_0] = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = I_3$.\n-   The element volume is $|T| = |\\det(I_3)|/6 = 1/6$.\n-   The physical gradients are identical to the reference gradients since $J^{-\\top} = I_3$.\n-   The element stiffness matrix is $K_e(i,j) = \\kappa_e |T| (\\nabla \\hat{N}_i \\cdot \\nabla \\hat{N}_j)$. With $\\kappa=2$ and $|T|=1/6$, this is $K_e(i,j) = \\frac{1}{3} (\\nabla \\hat{N}_i \\cdot \\nabla \\hat{N}_j)$.\n-   The matrix of dot products $(\\nabla \\hat{N}_i \\cdot \\nabla \\hat{N}_j)$ is $\\begin{pmatrix} 3 & -1 & -1 & -1 \\\\ -1 & 1 & 0 & 0 \\\\ -1 & 0 & 1 & 0 \\\\ -1 & 0 & 0 & 1 \\end{pmatrix}$.\n-   Thus, $K_e = \\frac{1}{3} \\begin{pmatrix} 3 & -1 & -1 & -1 \\\\ -1 & 1 & 0 & 0 \\\\ -1 & 0 & 1 & 0 \\\\ -1 & 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & -1/3 & -1/3 & -1/3 \\\\ -1/3 & 1/3 & 0 & 0 \\\\ -1/3 & 0 & 1/3 & 0 \\\\ -1/3 & 0 & 0 & 1/3 \\end{pmatrix}$.\n-   Since there is only one element, the global matrix $K$ is equal to $K_e$.\n-   The Frobenius norm is $\\|K\\|_F = \\sqrt{1^2 + 4 \\times (-1/3)^2 + 3 \\times (1/3)^2} = \\sqrt{1 + 4/9 + 3/9} = \\sqrt{16/9} = 4/3$.\n-   All nodes are Dirichlet nodes, so the set of free nodes $F$ is empty. The error is $0$.\n-   Results: $\\|K\\|_F = 4/3 \\approx 1.3333$, error $= 0.0$.\n\n**Case B: Subdivided Tetrahedron**\n-   The domain is the same reference tetrahedron as in Case A, but it is subdivided into four smaller tetrahedra by an interior node $\\mathbf{x}_4 = (0.25, 0.25, 0.25)$.\n-   There are $N=5$ nodes. Node $4$ is the only free node ($F=\\{4\\}$), while nodes $0, 1, 2, 3$ are Dirichlet nodes ($G=\\{0,1,2,3\\}$).\n-   The global stiffness matrix $K$ is a $5 \\times 5$ matrix, assembled from the contributions of the four elements. The calculation of each of the four element stiffness matrices and their summation into $K$ is performed computationally.\n-   The analytic solution for the PDE is $u^\\star(x,y,z) = x+y+z$. Since $u^\\star$ is a linear function, it is perfectly represented by the piecewise linear finite element basis. Therefore, the FEM solution must be exact, meaning the computed value at the interior node $u_4$ must equal the analytic value $u^\\star(\\mathbf{x}_4)$.\n-   $u^\\star(\\mathbf{x}_4) = 0.25 + 0.25 + 0.25 = 0.75$.\n-   The solution for $u_4$ is obtained from the single equation $K_{44}u_4 = -(K_{40}u_0 + K_{41}u_1 + K_{42}u_2 + K_{43}u_3)$. With $u_0=0, u_1=1, u_2=1, u_3=1$, this is $K_{44}u_4 = -(K_{41}+K_{42}+K_{43})$. Due to the barycentric subdivision and mesh symmetry, one can show that $K_{40} = K_{41} = K_{42} = K_{43}$, and also that the row sum is zero ($K_{40}+K_{41}+K_{42}+K_{43}+K_{44}=0$). These properties lead to $u_4 = 0.75$.\n-   Thus, the error is expected to be $0$ (within floating-point precision). The Frobenius norm $\\|K\\|_F$ is computed numerically.\n\n**Case C: Sliver Tetrahedron**\n-   Nodes: $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (\\epsilon,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$, with $\\epsilon=10^{-6}$.\n-   The Jacobian is a diagonal matrix $J = \\text{diag}(\\epsilon, 1, 1)$. Its determinant is $\\det(J) = \\epsilon$.\n-   The element volume is $|T| = |\\det(J)|/6 = \\epsilon/6$.\n-   The inverse transpose is $J^{-\\top} = \\text{diag}(1/\\epsilon, 1, 1)$.\n-   The physical gradients are scaled anisotropically. For instance, $\\nabla N_2 = J^{-\\top}(1,0,0)^\\top = (1/\\epsilon, 0, 0)^\\top$.\n-   With $\\kappa=1$, the element stiffness matrix is $K_e = \\frac{\\epsilon}{6} G_e^\\top G_e$, which evaluates to:\n$$ K = K_e = \\begin{pmatrix} \\frac{1}{6\\epsilon} + \\frac{\\epsilon}{3} & -\\frac{1}{6\\epsilon} & -\\frac{\\epsilon}{6} & -\\frac{\\epsilon}{6} \\\\ -\\frac{1}{6\\epsilon} & \\frac{1}{6\\epsilon} & 0 & 0 \\\\ -\\frac{\\epsilon}{6} & 0 & \\frac{\\epsilon}{6} & 0 \\\\ -\\frac{\\epsilon}{6} & 0 & 0 & \\frac{\\epsilon}{6} \\end{pmatrix} $$\n-   The squared Frobenius norm is $\\|K\\|_F^2 = \\sum_{i,j} K_{ij}^2 = \\frac{1}{9\\epsilon^2} + \\frac{1}{9} + \\frac{2\\epsilon^2}{9} = \\frac{1}{9}(\\frac{1}{\\epsilon^2} + 1 + 2\\epsilon^2)$.\n-   For $\\epsilon=10^{-6}$, $\\|K\\|_F = \\frac{1}{3}\\sqrt{10^{12} + 1 + 2 \\times 10^{-12}} \\approx 10^6/3$.\n-   As in Case A, all nodes are Dirichlet boundary nodes, so $F$ is empty and the error is $0$.\n-   Results: $\\|K\\|_F \\approx 333333.3333$, error $= 0.0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(nodes, elements, kappas, dirichlet_nodes):\n    \"\"\"\n    Assembles the global stiffness matrix and solves the FEM system for a given case.\n\n    Args:\n        nodes (list of tuples): Coordinates of the mesh nodes.\n        elements (list of lists): Connectivity of the mesh elements (tetrahedra).\n        kappas (list of floats): Diffusion coefficient for each element.\n        dirichlet_nodes (set): Set of global indices for nodes with Dirichlet BCs.\n\n    Returns:\n        tuple: A tuple containing (Frobenius norm of K, max absolute error at free nodes).\n    \"\"\"\n    num_nodes = len(nodes)\n    K = np.zeros((num_nodes, num_nodes))\n    node_coords = np.array(nodes)\n\n    # Gradients of the basis functions on the reference tetrahedron\n    grad_N_hat = np.array([\n        [-1, 1, 0, 0],\n        [-1, 0, 1, 0],\n        [-1, 0, 0, 1]\n    ])\n\n    for i, conn in enumerate(elements):\n        # Get element properties\n        kappa_e = kappas[i]\n        \n        # Get coordinates of the element's nodes\n        x0, x1, x2, x3 = node_coords[conn]\n\n        # Form the Jacobian matrix\n        J = np.array([x1 - x0, x2 - x0, x3 - x0]).T\n        \n        if np.linalg.det(J) == 0:\n            # Handle degenerate element if necessary, though not expected in tests\n            continue\n\n        # Compute volume and inverse transpose of Jacobian\n        volume = np.abs(np.linalg.det(J)) / 6.0\n        J_inv_T = np.linalg.inv(J).T\n        \n        # Compute gradients of physical basis functions\n        grad_N_phys = J_inv_T @ grad_N_hat\n        \n        # Compute element stiffness matrix\n        # Ke_ij = kappa * volume * (grad_N_phys_i . grad_N_phys_j)\n        Ke = kappa_e * volume * (grad_N_phys.T @ grad_N_phys)\n\n        # Assemble Ke into the global stiffness matrix K\n        for r_local in range(4):\n            r_global = conn[r_local]\n            for c_local in range(4):\n                c_global = conn[c_local]\n                K[r_global, c_global] += Ke[r_local, c_local]\n    \n    # --- 1. Compute Frobenius norm ---\n    frobenius_norm = np.linalg.norm(K, 'fro')\n\n    # --- 2. Compute solution and error ---\n    all_nodes = set(range(num_nodes))\n    free_nodes = sorted(list(all_nodes - dirichlet_nodes))\n    \n    if not free_nodes:\n        error = 0.0\n    else:\n        # Define the exact solution function\n        def u_star(coord):\n            return sum(coord)\n\n        # Partition the system\n        G = sorted(list(dirichlet_nodes))\n        \n        K_FF = K[np.ix_(free_nodes, free_nodes)]\n        K_FG = K[np.ix_(free_nodes, G)]\n\n        # Get prescribed boundary values from exact solution\n        u_G = np.array([u_star(node_coords[i]) for i in G])\n        \n        # The source term f is zero, so the load vector b is zero\n        # The right-hand side for the reduced system comes from boundary values\n        rhs = -K_FG @ u_G\n        \n        # Solve for the interior nodes\n        u_F = np.linalg.solve(K_FF, rhs)\n\n        # Compute error\n        u_star_F = np.array([u_star(node_coords[i]) for i in free_nodes])\n        error = np.max(np.abs(u_F - u_star_F))\n\n    return frobenius_norm, error\n\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the FEM stiffness matrix assembly problem.\n    \"\"\"\n    test_cases = [\n        # Case A: single tetrahedron\n        {\n            \"nodes\": [(0,0,0), (1,0,0), (0,1,0), (0,0,1)],\n            \"elements\": [[0,1,2,3]],\n            \"kappas\": [2.0],\n            \"dirichlet_nodes\": {0,1,2,3}\n        },\n        # Case B: a tetrahedron subdivided by one interior node\n        {\n            \"nodes\": [(0,0,0), (1,0,0), (0,1,0), (0,0,1), (0.25,0.25,0.25)],\n            \"elements\": [\n                [4,1,2,3], [4,0,2,3], [4,0,1,3], [4,0,1,2]\n            ],\n            \"kappas\": [1.0, 1.0, 1.0, 1.0],\n            \"dirichlet_nodes\": {0,1,2,3}\n        },\n        # Case C: a near-degenerate sliver tetrahedron\n        {\n            \"nodes\": [(0,0,0), (1e-6,0,0), (0,1,0), (0,0,1)],\n            \"elements\": [[0,1,2,3]],\n            \"kappas\": [1.0],\n            \"dirichlet_nodes\": {0,1,2,3}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        norm, err = process_case(**case)\n        results.append(norm)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3206634"}, {"introduction": "A correct assembly algorithm is critical, and subtle bugs in the local-to-global mapping are a common source of error in practice. This final thought experiment moves beyond direct calculation to test your conceptual understanding of the assembly machinery [@problem_id:3206774]. By analyzing how a specific index-swapping error manifests in the final global stiffness matrix $K$, you will develop a deeper intuition for the assembly process and learn how to diagnose potential issues in your own code.", "problem": "Consider the assembly of the global stiffness matrix $K$ for the linear elliptic model problem $-\\nabla \\cdot (\\kappa \\nabla u) = f$ on a bounded domain, using the Finite Element Method (FEM) with conforming elements. The global matrix $K$ is formed by summing contributions of element stiffness matrices $k^{e}$ according to a local-to-global mapping that associates each element’s local degrees of freedom to global indices. Assume each $k^{e}$ is symmetric positive semidefinite, and no boundary conditions have yet been applied to $K$.\n\nSuppose that, due to a programming bug, the local-to-global mapping routine consistently swaps the two global indices $p$ and $q$ everywhere they occur in the mesh. That is, whenever the correct mapping would return the global index $p$, the buggy version returns $q$, and whenever it would return $q$, it returns $p$. All other indices are returned correctly. How would this bug manifest in the assembled matrix $K$, compared to the correctly assembled matrix $K_{\\mathrm{true}}$?\n\nChoose the best description.\n\nA. $K$ becomes nonsymmetric because only the rows $p$ and $q$ are permuted while the corresponding columns remain unaltered.\n\nB. $K$ equals $P K_{\\mathrm{true}} P^{\\top}$, where $P$ is the permutation matrix that swaps indices $p$ and $q$; thus $K$ remains symmetric, its eigenvalues match those of $K_{\\mathrm{true}}$, and the sparsity pattern is identical except that rows and columns $p$ and $q$ are exchanged.\n\nC. Only the diagonal entries $K_{pp}$ and $K_{qq}$ are swapped; all off-diagonal entries remain the same as in $K_{\\mathrm{true}}$.\n\nD. All entries in row and column $p$ of $K$ become zero, while entries in row and column $q$ are doubled relative to $K_{\\mathrm{true}}$.", "solution": "The user wants me to analyze the effect of a specific programming bug on the assembly of a global stiffness matrix in the Finite Element Method (FEM).\n\n### Step 1: Extract Givens\n- **Problem Type**: Linear elliptic model problem $-\\nabla \\cdot (\\kappa \\nabla u) = f$ on a bounded domain.\n- **Numerical Method**: Finite Element Method (FEM) with conforming elements.\n- **Matrix Assembly**: The global stiffness matrix $K$ is assembled by summing element stiffness matrices $k^{e}$.\n- **Mapping**: A local-to-global mapping associates local degrees of freedom to global indices.\n- **Element Matrices**: Each element stiffness matrix $k^{e}$ is symmetric positive semidefinite.\n- **Boundary Conditions**: No boundary conditions have been applied to the global matrix $K$.\n- **The Bug**: A programming error in the local-to-global mapping routine consistently swaps two global indices, $p$ and $q$.\n- **Bug Behavior**:\n    - If the correct mapping for a local degree of freedom is the global index $p$, the buggy routine returns $q$.\n    - If the correct mapping is $q$, the buggy routine returns $p$.\n    - All other global indices are mapped correctly.\n- **Question**: Describe the relationship between the incorrectly assembled matrix, $K$, and the correctly assembled matrix, $K_{\\mathrm{true}}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is scientifically and mathematically sound. It describes a standard procedure in computational engineering (FEM assembly) and postulates a realistic programming error.\n\n- **Scientific Grounding**: The problem is based on the well-established Finite Element Method for solving partial differential equations. The concepts of element matrices, global matrices, and local-to-global mapping are fundamental to FEM. The assumption that element matrices $k^{e}$ are symmetric and positive semidefinite for the given elliptic problem is correct. The resulting global matrix $K$ (before applying boundary conditions) is also symmetric and positive semidefinite. No scientific principles are violated.\n- **Well-Posed**: The effect of the described algorithmic error is deterministic. Given a correct matrix $K_{\\mathrm{true}}$, the bug produces a unique, well-defined matrix $K$. The question asks for a description of this relationship, which is a well-posed mathematical problem.\n- **Objectivity**: The language is precise and technical. The description of the bug is unambiguous.\n- **Completeness**: The problem provides all necessary information to determine the structure of the resulting matrix $K$ in relation to $K_{\\mathrm{true}}$.\n- **No other flaws detected**: The problem is not trivial, unrealistic, or contradictory.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. The solution process will now proceed.\n\n### Derivation\nThe assembly of the global stiffness matrix $K$ is fundamentally an additive process where entries from local element matrices $k^e$ are added into the appropriate locations in $K$. The location is determined by a local-to-global index mapping function, let's call it $\\text{map}(e, \\alpha)$, which returns the global index for the $\\alpha$-th local degree of freedom of element $e$.\n\nThe entry $(I, J)$ of the correctly assembled global stiffness matrix, $K_{\\mathrm{true}}$, is given by the sum of all contributions from element matrices:\n$$ (K_{\\mathrm{true}})_{IJ} = \\sum_{e} \\sum_{\\alpha, \\beta} (k^e)_{\\alpha\\beta} \\, \\delta_{I, \\text{map}_{\\mathrm{true}}(e, \\alpha)} \\, \\delta_{J, \\text{map}_{\\mathrm{true}}(e, \\beta)} $$\nwhere $(k^e)_{\\alpha\\beta}$ is the entry of the local stiffness matrix for element $e$, $\\text{map}_{\\mathrm{true}}$ is the correct mapping function, and $\\delta_{ij}$ is the Kronecker delta.\n\nSince each $k^e$ is symmetric, i.e., $(k^e)_{\\alpha\\beta} = (k^e)_{\\beta\\alpha}$, the resulting matrix $K_{\\mathrm{true}}$ is also symmetric, i.e., $(K_{\\mathrm{true}})_{IJ} = (K_{\\mathrm{true}})_{JI}$.\n\nThe bug introduces an erroneous mapping function, $\\text{map}_{\\mathrm{bug}}$, which swaps the global indices $p$ and $q$. Let $\\pi$ be the permutation operator that swaps $p$ and $q$ and leaves all other indices unchanged:\n$$ \\pi(i) = \\begin{cases} q & \\text{if } i = p \\\\ p & \\text{if } i = q \\\\ i & \\text{otherwise} \\end{cases} $$\nThe buggy mapping can be expressed as $\\text{map}_{\\mathrm{bug}}(e, \\alpha) = \\pi(\\text{map}_{\\mathrm{true}}(e, \\alpha))$.\n\nThe incorrectly assembled matrix, $K$, is therefore constructed as:\n$$ K_{IJ} = \\sum_{e} \\sum_{\\alpha, \\beta} (k^e)_{\\alpha\\beta} \\, \\delta_{I, \\text{map}_{\\mathrm{bug}}(e, \\alpha)} \\, \\delta_{J, \\text{map}_{\\mathrm{bug}}(e, \\beta)} $$\nSubstituting the expression for the buggy map:\n$$ K_{IJ} = \\sum_{e} \\sum_{\\alpha, \\beta} (k^e)_{\\alpha\\beta} \\, \\delta_{I, \\pi(\\text{map}_{\\mathrm{true}}(e, \\alpha))} \\, \\delta_{J, \\pi(\\text{map}_{\\mathrm{true}}(e, \\beta))} $$\nLet's analyze an arbitrary entry $K_{IJ}$ of the buggy matrix. Let $I' = \\pi^{-1}(I)$ and $J' = \\pi^{-1}(J)$. Since $\\pi$ is its own inverse ($\\pi(\\pi(i)) = i$), we have $\\pi^{-1} = \\pi$. Thus, $I' = \\pi(I)$ and $J' = \\pi(J)$.\nThe Kronecker delta has the property $\\delta_{a, \\pi(b)} = \\delta_{\\pi^{-1}(a), b} = \\delta_{\\pi(a), b}$. Applying this, we get:\n$$ K_{IJ} = \\sum_{e} \\sum_{\\alpha, \\beta} (k^e)_{\\alpha\\beta} \\, \\delta_{\\pi(I), \\text{map}_{\\mathrm{true}}(e, \\alpha)} \\, \\delta_{\\pi(J), \\text{map}_{\\mathrm{true}}(e, \\beta)} $$\nComparing this to the formula for $K_{\\mathrm{true}}$, we see that this is precisely the entry $(\\pi(I), \\pi(J))$ of the true matrix:\n$$ K_{IJ} = (K_{\\mathrm{true}})_{\\pi(I), \\pi(J)} $$\nThis relationship means that the buggy matrix $K$ is obtained from the true matrix $K_{\\mathrm{true}}$ by permuting its rows and columns according to $\\pi$. Specifically, row $i$ of $K$ is row $\\pi(i)$ of $K_{\\mathrm{true}}$, and column $j$ of $K$ is column $\\pi(j)$ of $K_{\\mathrm{true}}$. For example, row $p$ of $K$ is row $q$ of $K_{\\mathrm{true}}$, and column $p$ of $K$ is column $q$ of $K_{\\mathrm{true}}$.\n\nIn matrix notation, this operation corresponds to a similarity transformation. Let $P$ be the permutation matrix associated with $\\pi$. A permutation matrix is orthogonal, so $P^{-1} = P^{\\top}$. The transformation is given by:\n$$ K = P^{\\top} K_{\\mathrm{true}} P $$\nor equivalently (since $P$ for a swap is symmetric, $P=P^\\top$):\n$$ K = P K_{\\mathrm{true}} P $$\nWait, the convention for a similarity transformation that results in $A'_{ij} = A_{\\pi(i)\\pi(j)}$ is $A' = P A P^\\top$, where $P_{ij} = \\delta_{i, \\pi(j)}$. Let's re-verify. Let $K' = P K_{\\mathrm{true}} P^{\\top}$.\n$ (K')_{ij} = \\sum_r \\sum_s P_{ir} (K_{\\mathrm{true}})_{rs} (P^{\\top})_{sj} $.\n$P_{ir} = \\delta_{i, \\pi(r)}$, so $r=\\pi^{-1}(i)$.\n$(P^{\\top})_{sj} = P_{js} = \\delta_{j, \\pi(s)}$, so $s=\\pi^{-1}(j)$.\nThen $(K')_{ij} = (K_{\\mathrm{true}})_{\\pi^{-1}(i), \\pi^{-1}(j)}$.\nMy initial derivation gave $K_{IJ} = (K_{\\mathrm{true}})_{\\pi(I), \\pi(J)}$. Let's re-check the definition of the matrix transformation.\nIf we relabel the basis vectors as $e'_i = e_{\\pi(i)}$, the new matrix representation $A'$ is related to the old one $A$ by $A'_{ij} = A_{\\pi(i),\\pi(j)}$. This corresponds to conjugation $A' = P^{-1}AP$ where $(Pe_i) = e_{\\pi(i)}$.\nLet's stick to the concrete formula $K_{IJ} = (K_{\\mathrm{true}})_{\\pi(I), \\pi(J)}$.\nLet's check the relation $K = P K_{\\mathrm{true}} P^{\\top}$ where $P$ is the permutation matrix that swaps rows/columns $p$ and $q$. This matrix acts on a vector $v$ as $(Pv)_i = v_{\\pi(i)}$.\nThen $(P K_{\\mathrm{true}})_{ij} = (K_{\\mathrm{true}})_{\\pi(i), j}$.\nThen $( (P K_{\\mathrm{true}}) P^{\\top} )_{ij} = \\sum_k (P K_{\\mathrm{true}})_{ik} (P^{\\top})_{kj} = \\sum_k (K_{\\mathrm{true}})_{\\pi(i), k} P_{jk}$. The only non-zero term is when $k=\\pi(j)$, so this is $(K_{\\mathrm{true}})_{\\pi(i), \\pi(j)}$.\nThis confirms that $K_{ij} = (K_{\\mathrm{true}})_{\\pi(i), \\pi(j)}$ is equivalent to $K = P K_{\\mathrm{true}} P^{\\top}$. Note that for a swap permutation, $P=P^\\top$, so this is also $K = P K_{\\mathrm{true}} P$.\n\nProperties of this transformation:\n1.  **Symmetry**: If $K_{\\mathrm{true}}$ is symmetric, then $K_{\\mathrm{true}}^{\\top} = K_{\\mathrm{true}}$. The transformed matrix is $K^{\\top} = (P K_{\\mathrm{true}} P^{\\top})^{\\top} = (P^{\\top})^{\\top} K_{\\mathrm{true}}^{\\top} P^{\\top} = P K_{\\mathrm{true}} P^{\\top} = K$. Thus, $K$ remains symmetric. This makes sense, as the bug is applied symmetrically to both row and column indices during assembly.\n2.  **Eigenvalues**: $K$ and $K_{\\mathrm{true}}$ are related by a similarity transformation, since $P$ is an orthogonal matrix ($P^{\\top} = P^{-1}$). Similarity transformations preserve eigenvalues.\n3.  **Sparsity**: The transformation simply permutes the rows and columns. Row $p$ of $K_{\\mathrm{true}}$ is moved to row $q$ of $K$, row $q$ to row $p$, and similarly for columns. The set of non-zero entries is permuted, but the overall number and pattern (up to this re-indexing) is identical.\n\n### Option-by-Option Analysis\n\n**A. $K$ becomes nonsymmetric because only the rows $p$ and $q$ are permuted while the corresponding columns remain unaltered.**\nThis is incorrect. The local-to-global mapping is used for both the row and column indices of the global matrix entry to which an element contribution is added. A bug in this mapping affects both symmetrically. As derived above, the resulting matrix $K$ is symmetric if $K_{\\mathrm{true}}$ is symmetric. An operation that only permutes rows would result in $K = P K_{\\mathrm{true}}$, which is not in general symmetric.\n**Verdict: Incorrect.**\n\n**B. $K$ equals $P K_{\\mathrm{true}} P^{\\top}$, where $P$ is the permutation matrix that swaps indices $p$ and $q$; thus $K$ remains symmetric, its eigenvalues match those of $K_{\\mathrm{true}}$, and the sparsity pattern is identical except that rows and columns $p$ and $q$ are exchanged.**\nThis statement accurately describes the consequences of the bug. The transformation is a similarity transformation $K = P K_{\\mathrm{true}} P^{\\top}$ (or $P K_{\\mathrm{true}} P$ since $P=P^\\top$ for a swap). As established in the derivation, such a transformation preserves symmetry and eigenvalues. The description of the effect on the matrix (\"sparsity pattern is identical except that rows and columns $p$ and $q$ are exchanged\") is a correct qualitative description of this permutation.\n**Verdict: Correct.**\n\n**C. Only the diagonal entries $K_{pp}$ and $K_{qq}$ are swapped; all off-diagonal entries remain the same as in $K_{\\mathrm{true}}$.**\nThis is incorrect. From the relation $K_{IJ} = (K_{\\mathrm{true}})_{\\pi(I), \\pi(J)}$, we can check various entries:\n- $K_{pp} = (K_{\\mathrm{true}})_{\\pi(p), \\pi(p)} = (K_{\\mathrm{true}})_{qq}$. (Diagonal entry swapped)\n- $K_{qq} = (K_{\\mathrm{true}})_{\\pi(q), \\pi(q)} = (K_{\\mathrm{true}})_{pp}$. (Diagonal entry swapped)\n- For an index $i \\ne p, q$, the entry $K_{pi}$ is given by $K_{pi} = (K_{\\mathrm{true}})_{\\pi(p), \\pi(i)} = (K_{\\mathrm{true}})_{qi}$. This is not, in general, equal to $(K_{\\mathrm{true}})_{pi}$. Thus, off-diagonal entries are also changed. Specifically, the entire row $p$ of $K$ is a permutation of row $q$ of $K_{\\mathrm{true}}$, and vice versa.\n**Verdict: Incorrect.**\n\n**D. All entries in row and column $p$ of $K$ become zero, while entries in row and column $q$ are doubled relative to $K_{\\mathrm{true}}$.**\nThis is physically and algorithmically unfounded. The bug does not eliminate or duplicate contributions; it reroutes them. Any contribution that should have gone to an entry involving index $p$ in $K_{\\mathrm{true}}$ is redirected to an entry involving index $q$ in $K$. Conversely, contributions for index $q$ in $K_{\\mathrm{true}}$ are sent to index $p$ in $K$. No entries become zero or are doubled unless they were already zero or the matrix had a very specific, coincidental structure.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{B}$$", "id": "3206774"}]}