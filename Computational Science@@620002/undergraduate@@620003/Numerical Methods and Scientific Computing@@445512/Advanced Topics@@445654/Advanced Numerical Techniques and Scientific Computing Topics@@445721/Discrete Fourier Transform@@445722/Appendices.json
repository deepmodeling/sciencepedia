{"hands_on_practices": [{"introduction": "To truly grasp the Discrete Fourier Transform, we begin with the simplest non-trivial case. This first exercise [@problem_id:1759585] asks you to compute a 2-point DFT directly from its definition, stripping away complexity to reveal the core mechanism of the transform. By working through this problem, you will build a foundational intuition for how the DFT deconstructs a signal into its fundamental frequency componentsâ€”in this case, a static or DC offset and a single oscillatory mode.", "problem": "A Microelectromechanical System (MEMS) accelerometer is used to monitor the high-frequency vibration of a tiny cantilever beam. Due to hardware limitations, the data acquisition system can only capture two consecutive displacement measurements from the beam's motion before its buffer is full. The time-domain signal, a sequence of two samples, is denoted by $x[n]$.\n\nThe two measurements are found to be:\n$x[0] = A_0 + A_1$\n$x[1] = A_0 - A_1$\n\nHere, $A_0$ represents the static equilibrium position (the DC component) of the beam, and $A_1$ represents the amplitude of the dominant vibrational mode at the sampling frequency. Both $A_0$ and $A_1$ are real-valued, non-zero physical constants.\n\nTo analyze the frequency content of this very short signal, you need to compute its 2-point Discrete Fourier Transform (DFT). The N-point DFT of a sequence $x[n]$ is defined as:\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi}{N} kn\\right) \\quad \\text{for } k = 0, 1, \\dots, N-1$$\nwhere $j$ is the imaginary unit such that $j^2 = -1$.\n\nFind the expressions for the two DFT components, $X[0]$ and $X[1]$, in terms of the constants $A_0$ and $A_1$. Present your final answer as a row matrix containing the expressions for $X[0]$ and $X[1]$ in that order.", "solution": "We are given a length-2 sequence with samples $x[0]=A_{0}+A_{1}$ and $x[1]=A_{0}-A_{1}$, and we are to compute its $N=2$ point DFT using\n$$\nX[k]=\\sum_{n=0}^{N-1}x[n]\\exp\\!\\left(-j\\frac{2\\pi}{N}kn\\right),\\quad k\\in\\{0,1\\}.\n$$\nFor $N=2$, this becomes\n$$\nX[k]=\\sum_{n=0}^{1}x[n]\\exp(-j\\pi kn).\n$$\n\nFor $k=0$, the exponential factor is $\\exp(0)=1$ for both $n=0$ and $n=1$, hence\n$$\nX[0]=x[0]+x[1]=(A_{0}+A_{1})+(A_{0}-A_{1})=2A_{0}.\n$$\n\nFor $k=1$, we have\n$$\nX[1]=x[0]\\exp(0)+x[1]\\exp(-j\\pi)=x[0]-x[1]=(A_{0}+A_{1})-(A_{0}-A_{1})=2A_{1}.\n$$\n\nTherefore, the two DFT components arranged as a row matrix in the order $(X[0],X[1])$ are $2A_{0}$ and $2A_{1}$.", "answer": "$$\\boxed{\\begin{pmatrix}2A_{0} & 2A_{1}\\end{pmatrix}}$$", "id": "1759585"}, {"introduction": "With the basic definition in hand, we can explore one of the DFT's most powerful properties: the convolution theorem. This theorem is the cornerstone of efficient signal filtering and system analysis in countless applications. This hands-on coding practice [@problem_id:3222895] challenges you to implement the DFT from first principles and use it to numerically prove that circular convolution in the time domain is equivalent to simple multiplication in the frequency domain, a truly remarkable result.", "problem": "Consider finite-length complex sequences and their discrete transforms. You will start from the definitions of the Discrete Fourier Transform (DFT) and the Inverse Discrete Fourier Transform (IDFT), where for a sequence $x[n]$ of length $N$ the DFT $X[k]$ and the IDFT $x[n]$ are defined by the following fundamental base formulas: $$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right),\\quad k=0,1,\\dots,N-1,$$ $$x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] \\exp\\left(\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right),\\quad n=0,1,\\dots,N-1.$$ The discrete circular convolution of two sequences $x[n]$ and $y[n]$ of common length $N$ is defined by $$z[n] = \\sum_{m=0}^{N-1} x[m]\\,y[(n-m)\\bmod N],\\quad n=0,1,\\dots,N-1.$$ Your task is to implement the DFT and IDFT directly from these definitions and to implement direct circular convolution from its definition. Using only these base formulas and no specialized library routines for transforms or convolution, numerically verify the equivalence of the convolution theorem for discrete sequences by comparing two computational routes: (i) direct circular convolution in the time domain and (ii) circular convolution obtained by transforming to the frequency domain, performing elementwise multiplication there, and transforming back to the time domain. For each test case, compute the maximum absolute elementwise difference between the two resulting sequences and decide whether this difference is less than or equal to the machine epsilon of double-precision floating-point arithmetic. Use complex double precision and treat all quantities as unitless. The angle unit for any exponential arguments is radians. The final result for each test case must be a boolean indicating whether the numerical equivalence holds within machine epsilon.\n\nImplement your program to run the following test suite, where each test case is given by $(N, x, y)$ with $N$ the common length and $x$ and $y$ the sequences:\n- Test $1$: $N=1$, $x=[\\,3\\,]$, $y=[\\,-2\\,]$.\n- Test $2$: $N=2$, $x=[\\,1,\\,2\\,]$, $y=[\\,-1,\\,3\\,]$.\n- Test $3$: $N=4$, $x=[\\,1,\\,0,\\,-1,\\,0\\,]$, $y=[\\,0,\\,2,\\,0,\\,-2\\,]$.\n- Test $4$: $N=4$, $x=[\\,0,\\,0,\\,0,\\,0\\,]$, $y=[\\,5,\\,-7,\\,13,\\,-11\\,]$.\n- Test $5$: $N=4$, $x=[\\,\\mathrm{i},\\,0,\\,-\\mathrm{i},\\,0\\,]$, $y=[\\,2,\\,0,\\,-2,\\,0\\,]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in order for the above five tests (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_j$ is either $True$ or $False$.", "solution": "The objective is to numerically verify the convolution theorem for discrete finite-length sequences. The theorem states that circular convolution in the time domain is equivalent to elementwise multiplication in the frequency domain. We will implement functions for the DFT, IDFT, and circular convolution directly from their mathematical definitions and then use them to compare the two computational paths for each test case.\n\n### 1. Implementation of Core Functions\n\nWe will write three functions corresponding to the definitions provided in the problem statement. All calculations will be performed using complex double-precision numbers (`complex128`).\n\n#### Discrete Fourier Transform (DFT)\nThe DFT of a sequence $x[n]$ of length $N$ is given by:\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right)$$\nThis translates to an algorithm with two nested loops. The outer loop iterates over the frequency indices $k$ from $0$ to $N-1$, and the inner loop computes the sum over the time-domain indices $n$ from $0$ to $N-1$. For each pair of $(n,k)$, we compute the complex exponential term, multiply by $x[n]$, and add to a running sum for $X[k]$.\n\n#### Inverse Discrete Fourier Transform (IDFT)\nThe IDFT of a frequency-domain sequence $X[k]$ is:\n$$x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] \\exp\\left(\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right)$$\nThe implementation is analogous to the DFT, but the sign of the exponent is positive, and the final sum for each $x[n]$ is scaled by a factor of $1/N$.\n\n#### Direct Circular Convolution\nThe circular convolution of two sequences $x[n]$ and $y[n]$ of length $N$ is:\n$$z[n] = \\sum_{m=0}^{N-1} x[m]\\,y[(n-m)\\bmod N]$$\nThe algorithm for this again involves two nested loops. The outer loop iterates over the output index $n$ from $0$ to $N-1$. The inner loop iterates over the summation index $m$ from $0$ to $N-1$. A crucial step is computing the index for the sequence $y$, which is $(n-m) \\pmod N$. This modular arithmetic ensures the periodic (circular) nature of the convolution.\n\n### 2. Verification Procedure\n\nFor each test case $(N, x, y)$, a two-pronged calculation is performed:\n\n- **Route (i): Direct Convolution in the Time Domain**\nThe direct circular convolution function is called with the input sequences $x$ and $y$ to produce the result $z_{\\text{direct}}$.\n$$z_{\\text{direct}}[n] = \\sum_{m=0}^{N-1} x[m]\\,y[(n-m)\\bmod N]$$\n\n- **Route (ii): Convolution via the Frequency Domain**\nThis route involves three steps:\n1.  Compute the DFT of both input sequences: $X = \\text{DFT}(x)$ and $Y = \\text{DFT}(y)$.\n2.  Perform elementwise multiplication of the resulting frequency-domain sequences: $Z[k] = X[k] \\cdot Y[k]$.\n3.  Compute the IDFT of the product sequence $Z$ to transform the result back to the time domain: $z_{\\text{freq}} = \\text{IDFT}(Z)$.\n\n### 3. Comparison and Final Result\n\nThe convolution theorem guarantees that, with infinite precision arithmetic, $z_{\\text{direct}}$ and $z_{\\text{freq}}$ would be identical. However, due to floating-point representation and rounding errors in numerical computation, we expect small differences. The verification consists of checking if these differences are within an acceptable tolerance.\n\nThe problem specifies this tolerance as the machine epsilon for double-precision floating-point numbers, denoted $\\epsilon$. This value represents the smallest number such that $1.0 + \\epsilon \\neq 1.0$ in floating-point arithmetic.\n\nThe comparison is formalized as follows:\n1.  Compute the elementwise absolute difference between the two result vectors: $\\Delta[n] = |z_{\\text{direct}}[n] - z_{\\text{freq}}[n]|$.\n2.  Find the maximum value in this difference vector: $\\Delta_{\\max} = \\max_{n} \\Delta[n]$.\n3.  The equivalence is considered verified if this maximum difference is less than or equal to machine epsilon: $\\Delta_{\\max} \\leq \\epsilon$.\n\nA boolean result ($True$ or $False$) is generated for each test case based on this condition. The final output aggregates these boolean values into the specified list format.", "answer": "```python\nimport numpy as np\n\ndef dft(x_seq: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the Discrete Fourier Transform (DFT) of a sequence.\n    \n    Args:\n        x_seq: A 1D numpy array of complex numbers representing the sequence.\n        \n    Returns:\n        A 1D numpy array representing the DFT of the sequence.\n    \"\"\"\n    N = len(x_seq)\n    X = np.zeros(N, dtype=np.complex128)\n    for k in range(N):\n        sum_val = np.complex128(0)\n        for n in range(N):\n            angle = -1j * 2 * np.pi * n * k / N\n            sum_val += x_seq[n] * np.exp(angle)\n        X[k] = sum_val\n    return X\n\ndef idft(X_seq: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform (IDFT) of a sequence.\n    \n    Args:\n        X_seq: A 1D numpy array of complex numbers representing the frequency-domain sequence.\n        \n    Returns:\n        A 1D numpy array representing the IDFT of the sequence.\n    \"\"\"\n    N = len(X_seq)\n    x = np.zeros(N, dtype=np.complex128)\n    for n in range(N):\n        sum_val = np.complex128(0)\n        for k in range(N):\n            angle = 1j * 2 * np.pi * n * k / N\n            sum_val += X_seq[k] * np.exp(angle)\n        x[n] = sum_val / N\n    return x\n\ndef circular_conv(x_seq: np.ndarray, y_seq: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the direct circular convolution of two sequences.\n    \n    Args:\n        x_seq: The first 1D numpy array of complex numbers.\n        y_seq: The second 1D numpy array of complex numbers.\n        \n    Returns:\n        A 1D numpy array representing the circular convolution of the two sequences.\n    \"\"\"\n    N = len(x_seq)\n    z = np.zeros(N, dtype=np.complex128)\n    for n in range(N):\n        sum_val = np.complex128(0)\n        for m in range(N):\n            y_index = (n - m) % N\n            sum_val += x_seq[m] * y_seq[y_index]\n        z[n] = sum_val\n    return z\n\ndef solve():\n    \"\"\"\n    Runs the test suite to verify the convolution theorem and prints the results.\n    \"\"\"\n    test_cases = [\n        (1, [3], [-2]),\n        (2, [1, 2], [-1, 3]),\n        (4, [1, 0, -1, 0], [0, 2, 0, -2]),\n        (4, [0, 0, 0, 0], [5, -7, 13, -11]),\n        (4, [1j, 0, -1j, 0], [2, 0, -2, 0])\n    ]\n\n    results = []\n    machine_epsilon = np.finfo(np.float64).eps\n\n    for N, x_list, y_list in test_cases:\n        x = np.array(x_list, dtype=np.complex128)\n        y = np.array(y_list, dtype=np.complex128)\n\n        # Route (i): Direct circular convolution\n        z_direct = circular_conv(x, y)\n\n        # Route (ii): Convolution via frequency domain\n        X = dft(x)\n        Y = dft(y)\n        Z = X * Y\n        z_freq = idft(Z)\n\n        # Compare the two results\n        max_abs_diff = np.max(np.abs(z_direct - z_freq))\n        \n        is_equivalent = max_abs_diff <= machine_epsilon\n        results.append(is_equivalent)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3222895"}, {"introduction": "Applying the DFT to real-world signals often reveals practical challenges that are not apparent from theory alone, with one of the most common being an artifact known as spectral leakage. This advanced exercise [@problem_id:3222838] delves into this phenomenon, guiding you to analyze how different window functions can mitigate its effects. You will quantify the fundamental trade-off between reducing leakage and maintaining the ability to resolve two closely spaced frequencies, a crucial consideration in practical spectral analysis.", "problem": "Consider a real-valued, discrete-time signal composed of two sinusoids with closely spaced normalized frequencies. Let $x[n] = A_1 \\sin(2\\pi f_1 n) + A_2 \\sin(2\\pi f_2 n)$ for $n = 0, 1, \\dots, N-1$, where $f_1$ and $f_2$ are in cycles per sample (dimensionless) and the sinusoid arguments use radians. You will analyze the effect of windowing on the Discrete Fourier Transform (DFT) in terms of spectral leakage and resolvability of the two tones.\n\nUse the following fundamental base for your reasoning and algorithm design:\n\n- The Discrete Fourier Transform (DFT) of a length-$N$ sequence $y[n]$ is defined as $Y[k] = \\sum_{n=0}^{N-1} y[n] e^{-j 2\\pi k n / N}$ for $k = 0, 1, \\dots, N-1$, where $j$ is the imaginary unit.\n- Windowing in the time domain multiplies the signal by a window $w[n]$, which corresponds to a convolution in the frequency domain: if $y[n] = x[n] w[n]$, then $Y[k]$ is the sampled convolution of the spectrum of $x[n]$ with the spectrum of $w[n]$. This spreads energy across DFT bins when the window spectrum has nonzero sidelobes.\n- Use two windows:\n  - The rectangular window defined by $w_\\mathrm{rect}[n] = 1$ for $0 \\le n \\le N-1$.\n  - The Hann window defined by $w_\\mathrm{Hann}[n] = \\tfrac{1}{2}\\left(1 - \\cos\\left(\\tfrac{2\\pi n}{N-1}\\right)\\right)$ for $0 \\le n \\le N-1$.\n\nDefine the following quantitative metrics:\n\n1. Spectral leakage ratio for a given window $w$:\n   - Compute the DFT $X_w[k]$ of the windowed signal $x[n] w[n]$ and the power spectrum $P_w[k] = |X_w[k]|^2$ for $k = 0, 1, \\dots, N-1$.\n   - For each sinusoid $f_i$ with $i \\in \\{1,2\\}$, find its nearest positive-frequency DFT bin index $k_i = \\mathrm{round}(f_i N)$ and the corresponding negative-frequency index $k_i^- = (N - k_i) \\bmod N$.\n   - For each of these two indices (positive and negative), refine the peak location by searching for the local maximum of $P_w[k]$ within a small neighborhood around the index. Let the refined peak indices be $k_i^{(+)}$ and $k_i^{(-)}$.\n   - Define the main-lobe half-width in bins as $M_w$, which is $M_\\mathrm{rect} = 1$ for the rectangular window and $M_\\mathrm{Hann} = 2$ for the Hann window. Construct the union of closed index intervals $[k_i^{(+)} - M_w, \\, k_i^{(+)} + M_w]$ and $[k_i^{(-)} - M_w, \\, k_i^{(-)} + M_w]$ for $i=1,2$, clipped to the valid index range $\\{0,1,\\dots,N-1\\}$, and merge any overlaps.\n   - Let $E_\\mathrm{main}(w)$ be the sum of $P_w[k]$ over the union of these intervals, and let $E_\\mathrm{tot}(w) = \\sum_{k=0}^{N-1} P_w[k]$ be the total spectral energy. The leakage ratio is $\\mathrm{LR}(w) = \\dfrac{E_\\mathrm{tot}(w) - E_\\mathrm{main}(w)}{E_\\mathrm{tot}(w)}$, which is dimensionless.\n\n2. Two-tone resolvability criterion for a given window $w$:\n   - Restrict attention to the positive-frequency half-spectrum indices $k \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$.\n   - Using the refined peak indices $k_1^{(+)}$ and $k_2^{(+)}$ found above, check if there is at least one bin strictly between them. If not, they are not resolved.\n   - Let $k_\\mathrm{low} = \\min(k_1^{(+)}, k_2^{(+)})$ and $k_\\mathrm{high} = \\max(k_1^{(+)}, k_2^{(+)})$. Compute the valley power $V = \\min\\{P_w[k] : k_\\mathrm{low} < k < k_\\mathrm{high}\\}$, and the weaker peak power $P_\\mathrm{weak} = \\min(P_w[k_1^{(+)}], P_w[k_2^{(+)}])$.\n   - With threshold parameter $\\alpha = 0.5$, declare the tones resolved if $V < \\alpha \\, P_\\mathrm{weak}$; otherwise, declare them not resolved. Output this as a boolean.\n\nYour program must implement these definitions precisely and evaluate the following test suite. All frequencies $f$ are normalized in cycles per sample, and all angles in sinusoid arguments are in radians. The outputs are dimensionless floats or booleans as specified.\n\nTest suite parameter sets $(N, f_1, f_2, A_1, A_2)$:\n\n- Case 1 (general off-bin, closely spaced): $(1024, \\, 0.100, \\, 0.100 + \\tfrac{1.5}{1024}, \\, 1.0, \\, 1.0)$\n- Case 2 (exact bins, adjacent bins): $(1024, \\, \\tfrac{100}{1024}, \\, \\tfrac{102}{1024}, \\, 1.0, \\, 1.0)$\n- Case 3 (sub-bin spacing): $(1024, \\, 0.200, \\, 0.200 + \\tfrac{0.6}{1024}, \\, 1.0, \\, 1.0)$\n- Case 4 (unequal amplitudes, one-bin spacing at higher $N$): $(2048, \\, 0.123, \\, 0.123 + \\tfrac{1}{2048}, \\, 1.0, \\, 0.2)$\n\nFor each test case, compute and return a list containing four elements: $\\mathrm{LR}(\\mathrm{rect})$ as a float, $\\mathrm{LR}(\\mathrm{Hann})$ as a float, $\\mathrm{R}(\\mathrm{rect})$ as a boolean, and $\\mathrm{R}(\\mathrm{Hann})$ as a boolean.\n\nFinal output format: Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each test case result is itself a list in the order specified above. For example, the output should look like $[[\\dots],[\\dots],[\\dots],[\\dots]]$ with no additional text.", "solution": "The core of this problem lies in the fundamental trade-off in spectral analysis introduced by windowing. The Discrete Fourier Transform (DFT) of a finite-length signal intrinsically assumes the signal is periodic over its length $N$. If the signal's frequencies are not integer multiples of the fundamental frequency resolution $\\frac{1}{N}$, a phenomenon known as spectral leakage occurs. This is equivalent to multiplying the infinite-duration signal by a rectangular window, which has a sinc-function-like spectrum with high sidelobes. These sidelobes spread the energy of the signal's true frequency components across all other DFT bins.\n\nWindow functions other than the rectangular window are designed to mitigate this leakage by tapering the signal smoothly towards zero at its endpoints. This reduces the spectral sidelobes, but at the cost of widening the main lobe. The Hann window is a classic example: it offers significantly lower sidelobes than the rectangular window, but its main lobe is roughly twice as wide. This leads to a direct trade-off: improved amplitude accuracy and less leakage (better for detecting weak signals near strong ones) versus reduced frequency resolution (harder to distinguish two closely spaced tones).\n\nOur algorithm will quantify this trade-off for the given test cases by implementing the two specified metrics: Spectral Leakage Ratio ($\\mathrm{LR}$) and the two-tone resolvability criterion ($\\mathrm{R}$).\n\nThe algorithmic procedure for each test case is as follows:\n\n1.  **Signal Generation**: For a given set of parameters $(N, f_1, f_2, A_1, A_2)$, the discrete-time signal $x[n]$ is generated for $n = 0, 1, \\dots, N-1$ according to the model:\n    $$x[n] = A_1 \\sin(2\\pi f_1 n) + A_2 \\sin(2\\pi f_2 n)$$\n    This process is repeated for each of the two specified window functions.\n\n2.  **Windowing and DFT**:\n    - The signal $x[n]$ is multiplied element-wise by the chosen window function $w[n]$ to produce the windowed signal $y[n] = x[n] w[n]$. The two windows are:\n      - Rectangular window: $w_\\mathrm{rect}[n] = 1$\n      - Hann window: $w_\\mathrm{Hann}[n] = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right)\\right)$\n    - The $N$-point DFT of the windowed signal, $X_w[k]$, is computed using the formula:\n      $$X_w[k] = \\sum_{n=0}^{N-1} y[n] e^{-j 2\\pi k n / N}$$\n      where $j$ is the imaginary unit. The power spectrum is then calculated as $P_w[k] = |X_w[k]|^2$.\n\n3.  **Spectral Leakage Ratio ($\\mathrm{LR}$) Calculation**:\n    - For each frequency component $f_i$ (where $i \\in \\{1, 2\\}$), its expected bin locations in the positive and negative frequency halves of the spectrum are estimated as $k_i = \\mathrm{round}(f_i N)$ and $k_i^- = (N - k_i) \\bmod N$, respectively.\n    - These estimated locations are refined by searching for the local maximum of the power spectrum $P_w[k]$ in a small neighborhood of $\\pm 2$ bins around each estimate. This yields the refined peak indices $\\{ k_1^{(+)}, k_1^{(-)}, k_2^{(+)}, k_2^{(-)} \\}$.\n    - The main-lobe energy, $E_\\mathrm{main}(w)$, is calculated by summing the power spectrum values within defined intervals around these four refined peaks. The intervals are $[k_\\mathrm{peak} - M_w, k_\\mathrm{peak} + M_w]$, where the main-lobe half-width $M_w$ is given as $M_\\mathrm{rect} = 1$ for the rectangular window and $M_\\mathrm{Hann} = 2$ for the Hann window. To handle spectral components from both sinusoids and potential overlaps, the union of all bins in these four intervals is formed, with indices clipped to the valid range $[0, N-1]$.\n    - The total energy $E_\\mathrm{tot}(w) = \\sum_{k=0}^{N-1} P_w[k]$ is also computed.\n    - The leakage ratio is then given by:\n      $$\\mathrm{LR}(w) = \\frac{E_\\mathrm{tot}(w) - E_\\mathrm{main}(w)}{E_\\mathrm{tot}(w)}$$\n      This value represents the fraction of total energy that has \"leaked\" outside the defined main lobes.\n\n4.  **Two-Tone Resolvability ($\\mathrm{R}$) Calculation**:\n    - This metric focuses on the positive-frequency spectrum, $k \\in \\{0, 1, \\dots, \\lfloor N/2 \\rfloor\\}$, using the refined positive-frequency peaks $k_1^{(+)}$ and $k_2^{(+)}$.\n    - Let $k_\\mathrm{low} = \\min(k_1^{(+)}, k_2^{(+)})$ and $k_\\mathrm{high} = \\max(k_1^{(+)}, k_2^{(+)})$.\n    - The tones are considered unresolved if there is no DFT bin strictly between their peaks, i.e., if $k_\\mathrm{high} \\le k_\\mathrm{low} + 1$.\n    - If there is a gap, the minimum power in the valley between the peaks is found: $V = \\min\\{P_w[k] \\mid k_\\mathrm{low} < k < k_\\mathrm{high}\\}$.\n    - The power of the weaker of the two peaks is also identified: $P_\\mathrm{weak} = \\min(P_w[k_1^{(+)}], P_w[k_2^{(+)}])$.\n    - The tones are declared resolved if the valley is sufficiently deep relative to the weaker peak, using the given threshold $\\alpha = 0.5$:\n      $$V < \\alpha \\, P_\\mathrm{weak}$$\n    - The result is a boolean value (True for resolved, False for not resolved).\n\nBy applying this full procedure to each test case for both window types, we generate the required set of four metrics: $\\mathrm{LR}(\\mathrm{rect})$, $\\mathrm{LR}(\\mathrm{Hann})$, $\\mathrm{R}(\\mathrm{rect})$, and $\\mathrm{R}(\\mathrm{Hann})$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT windowing analysis problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General off-bin, closely spaced\n        (1024, 0.100, 0.100 + 1.5/1024, 1.0, 1.0),\n        # Case 2: Exact bins, adjacent bins\n        (1024, 100/1024, 102/1024, 1.0, 1.0),\n        # Case 3: Sub-bin spacing\n        (1024, 0.200, 0.200 + 0.6/1024, 1.0, 1.0),\n        # Case 4: Unequal amplitudes, one-bin spacing at higher N\n        (2048, 0.123, 0.123 + 1/2048, 1.0, 0.2),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N, f1, f2, A1, A2 = case\n        \n        # Generate time vector and signal\n        n = np.arange(N)\n        x = A1 * np.sin(2 * np.pi * f1 * n) + A2 * np.sin(2 * np.pi * f2 * n)\n        \n        # Define window parameters\n        window_params = {\n            'rect': {'func': np.ones(N), 'M_w': 1},\n            'hann': {'func': 0.5 * (1 - np.cos(2 * np.pi * n / (N - 1))), 'M_w': 2}\n        }\n        \n        case_results = []\n\n        for name in ['rect', 'hann']:\n            params = window_params[name]\n            w = params['func']\n            M_w = params['M_w']\n            \n            # Apply window\n            y = x * w\n            \n            # Compute DFT and power spectrum\n            X_w = np.fft.fft(y)\n            P_w = np.abs(X_w)**2\n            \n            # --- METRIC CALCULATIONS ---\n            \n            def find_peak(k_est, P, search_radius=2):\n                \"\"\"Finds the index of the local maximum around an estimated bin.\"\"\"\n                start = max(0, k_est - search_radius)\n                end = min(len(P), k_est + search_radius + 1)\n                \n                # Check for empty search range\n                if start >= end:\n                    return k_est\n                \n                local_P = P[start:end]\n                local_max_idx = np.argmax(local_P)\n                return start + local_max_idx\n\n            # Estimate initial bin locations\n            k1_est = int(np.round(f1 * N))\n            k2_est = int(np.round(f2 * N))\n            \n            # Refine peak locations for positive and negative frequencies\n            k1_p = find_peak(k1_est, P_w)\n            k2_p = find_peak(k2_est, P_w)\n            k1_n = find_peak((N - k1_est) % N, P_w)\n            k2_n = find_peak((N - k2_est) % N, P_w)\n            \n            # --- Spectral Leakage Ratio (LR) ---\n            \n            refined_peak_indices = {k1_p, k1_n, k2_p, k2_n}\n            main_lobe_indices = set()\n            for k_peak in refined_peak_indices:\n                for d in range(-M_w, M_w + 1):\n                    idx = k_peak + d\n                    if 0 <= idx < N:\n                        main_lobe_indices.add(idx)\n\n            E_main = np.sum(P_w[list(main_lobe_indices)])\n            E_tot = np.sum(P_w)\n            \n            lr = (E_tot - E_main) / E_tot if E_tot > 0 else 0.0\n            \n            # --- Two-Tone Resolvability (R) ---\n            \n            k_low = min(k1_p, k2_p)\n            k_high = max(k1_p, k2_p)\n            \n            resolved = False\n            # Check for at least one bin strictly between peaks\n            if k_high > k_low + 1:\n                V = np.min(P_w[k_low + 1 : k_high])\n                P_weak = min(P_w[k_low], P_w[k_high])\n                alpha = 0.5\n                if P_weak > 0:\n                    if V < alpha * P_weak:\n                        resolved = True\n            \n            # Store results for this window\n            case_results.extend([lr, resolved])\n\n        # Arrange results in the specified order: LR(rect), LR(hann), R(rect), R(hann)\n        final_case_results = [case_results[0], case_results[2], case_results[1], case_results[3]]\n        all_results.append(final_case_results)\n\n    # Final print statement in the exact required format.\n    formatted_results = []\n    for res_list in all_results:\n        # Format: float, float, bool, bool\n        r1 = f\"{res_list[0]:.6f}\"\n        r2 = f\"{res_list[1]:.6f}\"\n        r3 = str(res_list[2])\n        r4 = str(res_list[3])\n        formatted_results.append(f\"[{r1},{r2},{r3},{r4}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3222838"}]}