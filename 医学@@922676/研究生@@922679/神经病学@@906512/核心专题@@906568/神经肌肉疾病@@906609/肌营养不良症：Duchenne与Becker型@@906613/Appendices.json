{"hands_on_practices": [{"introduction": "杜氏肌营养不良症（DMD）和贝克型肌营养不良症（BMD）的临床严重程度差异，其分子基础通常遵循“阅读框规则”。这项练习提供了一个实践机会，让您能够运用外显子时相（exon phase）数据来应用这一基本规则，这是一项通过特定基因缺失来预测疾病严重程度的分子诊断核心技能。通过这项练习，您将掌握从基因型推断表型的关键逻辑。 [@problem_id:4499889]", "problem": "一名患者确诊为与杜氏肌营养不良症（DMD）相关的抗肌萎缩蛋白基因多外显子缺失：抗肌萎缩蛋白基因蛋白质编码转录本上外显子 $45$ 至 $47$ 的连续缺失。你需要确定，在外显子 $44$ 直接剪接到外显子 $48$ 形成的新外显子连接处，由此产生的信使核糖核酸（mRNA）是否保持了原始的阅读框，并根据阅读框法则推断可能的表型（框内突变倾向于导致贝克型肌营养不良症（BMD）；框外突变倾向于导致杜氏肌营养不良症（DMD））。\n\n请使用以下基于分子生物学中心法则和真核生物剪接中内含子相位约定的基本定义：\n- 蛋白质翻译以 $3$ 个核苷酸为一组读取密码子；移码会改变分组方式，从而改变下游编码的氨基酸序列。\n- 对于任意外显子 $i$，定义左剪接相位 $p_{L}(i) \\in \\{0,1,2\\}$ 为剪接受体位点前、位于外显子 $5^{\\prime}$ 端的密码子核苷酸数量，定义右剪接相位 $p_{R}(i) \\in \\{0,1,2\\}$ 为剪接供体位点前、位于外显子 $3^{\\prime}$ 端的密码子核苷酸数量。按照惯例，$p=0$ 表示剪接发生在密码子之间。\n\n假设在相关区间内，人类抗肌萎缩蛋白转录本经过整理的外显子相位注释如下：\n- 外显子 $44$: $p_{L}(44)=0$, $p_{R}(44)=0$.\n- 外显子 $45$: $p_{L}(45)=0$, $p_{R}(45)=0$.\n- 外显子 $46$: $p_{L}(46)=0$, $p_{R}(46)=0$.\n- 外显子 $47$: $p_{L}(47)=0$, $p_{R}(47)=0$.\n- 外显子 $48$: $p_{L}(48)=0$, $p_{R}(48)=0$.\n\n基于这些定义，计算在外显子 $45$–$47$ 缺失后，外显子 $44$ 直接剪接到外显子 $48$ 所形成的新连接点处引起的净阅读框偏移量（模 $3$）。用 $k \\in \\{0,1,2\\}$ 表示此偏移量，其中 $k=0$ 表示阅读框在连接处得以保持，而 $k \\in \\{1,2\\}$ 表示在连接处发生了移码。根据此结果，表型预测遵循阅读框法则：$k=0$ 与贝克型肌营养不良症（BMD）样表型一致，而 $k \\in \\{1,2\\}$ 与杜氏肌营养不良症（DMD）样表型一致。\n\n报告单个整数 $k$ 作为你的最终答案。不需要单位。最终答案中不要提供任何文本。", "solution": "用户希望我解决一个问题，该问题要求评估抗肌萎索蛋白基因发生多外显子缺失后阅读框的完整性。\n\n### 步骤1：提取已知条件\n- **遗传变异**：抗肌萎缩蛋白基因中外显子 $45$ 至 $47$ 的连续缺失。\n- **产生的剪接连接**：外显子 $44$ 直接剪接到外显子 $48$。\n- **目标**：确定这个新连接处的净阅读框偏移量，记为 $k \\in \\{0, 1, 2\\}$。\n- **表型关联**：$k=0$ 意味着阅读框保持完整（BMD样表型），而 $k \\in \\{1, 2\\}$ 意味着发生移码（DMD样表型）。\n- **相位定义**：\n    - $p_L(i)$：外显子 $i$ 的左剪接相位（在 $5'$ 端）。\n    - $p_R(i)$：外显子 $i$ 的右剪接相位（在 $3'$ 端）。\n- **提供的相位数据**：\n    - 外显子 $44$: $p_{L}(44)=0$, $p_{R}(44)=0$.\n    - 外显子 $45$: $p_{L}(45)=0$, $p_{R}(45)=0$.\n    - 外显子 $46$: $p_{L}(46)=0$, $p_{R}(46)=0$.\n    - 外显子 $47$: $p_{L}(47)=0$, $p_{R}(47)=0$.\n    - 外显子 $48$: $p_{L}(48)=0$, $p_{R}(48)=0$.\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题基于分子遗传学的核心原理，包括基因剪接、遗传密码的三联体特性以及抗肌萎缩蛋白病的阅读框法则。外显子相位的概念是生物信息学中的标准概念，所提供的特定人类抗肌萎缩蛋白外显子的相位值根据基因组数据库是真实正确的。\n2.  **提问清晰**：问题陈述清晰，提供了所有必要的数据和定义，并要求一个单一、可计算的整数值 $k$。\n3.  **客观性**：该问题使用了精确的技术语言，没有任何主观或模糊的术语。\n\n**结论**：该问题有效。它在科学上是合理的、提问清晰且客观。我将继续进行解答。\n\n### 步骤3：解题\n该问题要求计算因外显子 $45$、$46$ 和 $47$ 缺失而导致的阅读框偏移量 $k$。该偏移量由编码序列中移除的核苷酸总数模 $3$ 决定。如果这个数字不是 $3$ 的倍数，则会发生移码。\n\n设 $L(i)$ 为外显子 $i$ 的核苷酸长度。被删除片段的总长度为 $L_{del} = L(45) + L(46) + L(47)$。缺失下游序列的阅读框会发生一个偏移，其量等于被删除长度的负数模 $3$。因此，偏移量 $k$ 由下式给出：\n$$k = (-L_{del}) \\pmod 3$$\n\n为了找到 $L_{del} \\pmod 3$，我们必须首先确定每个被删除外显子的长度模 $3$。任何给定外显子 $i$ 的长度 $L(i)$ 受其左（进入）和右（退出）剪接相位 $p_L(i)$ 和 $p_R(i)$ 的约束。要使一个外显子成为连续阅读框的有效组成部分，其包含的核苷酸数量必须与其侧翼内含子的相位一致。该关系可表示为：\n$$(L(i) + p_L(i) - p_R(i)) \\pmod 3 = 0$$\n该方程可以重新排列以求出外显子长度模 $3$：\n$$L(i) \\pmod 3 = (p_R(i) - p_L(i)) \\pmod 3$$\n\n我们将此公式应用于使用所提供相位数据的三个被删除的每个外显子。\n\n对于外显子 $45$：\n$$L(45) \\pmod 3 = (p_R(45) - p_L(45)) \\pmod 3 = (0 - 0) \\pmod 3 = 0$$\n\n对于外显子 $46$：\n$$L(46) \\pmod 3 = (p_R(46) - p_L(46)) \\pmod 3 = (0 - 0) \\pmod 3 = 0$$\n\n对于外显子 $47$：\n$$L(47) \\pmod 3 = (p_R(47) - p_L(47)) \\pmod 3 = (0 - 0) \\pmod 3 = 0$$\n\n现在，我们可以计算被删除片段总长度模 $3$：\n$$L_{del} \\pmod 3 = (L(45) + L(46) + L(47)) \\pmod 3$$\n$$L_{del} \\pmod 3 = ( (L(45) \\pmod 3) + (L(46) \\pmod 3) + (L(47) \\pmod 3) ) \\pmod 3$$\n$$L_{del} \\pmod 3 = (0 + 0 + 0) \\pmod 3 = 0$$\n\n被删除的核苷酸总数是 $3$ 的倍数。因此，产生的阅读框偏移量 $k$ 为：\n$$k = (-L_{del}) \\pmod 3 = (-0) \\pmod 3 = 0$$\n\n另一种等效的方法是直接考虑新连接处边界的相位。在修饰后的转录本中，外显子 $44$ 剪接到外显子 $48$。如果上游外显子（$p_R(44)$）的退出相位与下游外显子（$p_L(48)$）的进入相位相同，则阅读框得以保持。偏移量 $k$ 可以计算为上游序列提供的框架与下游序列期望的框架之间的差值：\n$$k = (p_R(\\text{upstream}) - p_L(\\text{downstream})) \\pmod 3$$\n在这种情况下，上游外显子是 $44$，下游外显子是 $48$：\n$$k = (p_R(44) - p_L(48)) \\pmod 3$$\n使用提供的数据，$p_R(44) = 0$ 且 $p_L(48) = 0$。将这些值代入方程：\n$$k = (0 - 0) \\pmod 3 = 0$$\n\n两种方法都得出相同的结果，$k=0$。这表明阅读框在新的外显子 $44-48$ 连接处得以保持。根据所提供的阅读框法则，这种框内缺失预示着贝克型肌营养不良症（BMD）表型，而非杜氏肌营养不良症（DMD）表型。\n\n最终答案是偏移量 $k$ 的整数值。", "answer": "$$\\boxed{0}$$", "id": "4499889"}, {"introduction": "在预测表型之后，量化实际的蛋白质表达水平至关重要。本练习模拟了对蛋白质印迹（Western blot）数据的分析过程，这是一项常用的实验室技术。您将面临的挑战是整合多种校正因子——包括仪器校准、上样量控制和抗体亲和力差异——以精确计算抗肌萎缩蛋白的功能丰度，从而将生物化学数据与临床功能阈值联系起来。 [@problem_id:4499923]", "problem": "一个神经肌肉研究实验室正在使用Western blot光密度测定法，对骨骼肌活检样本中的肌营养不良蛋白丰度进行量化，以比较一名贝克型肌营养不良症（BMD）患者与一名健康对照者。在该检测方法的线性动态范围内，印迹系统表现出带有附加仪器偏移量的线性响应。三个肌营养不良蛋白标准品在同一张膜上进行分析，通过光密度法测定，得到以下几组已知的肌营养不良蛋白质量与测得的积分条带强度对应值：$(0.50,\\ 6.20 \\times 10^{3})$、$(1.00,\\ 1.23 \\times 10^{4})$ 和 $(2.00,\\ 2.45 \\times 10^{4})$，其中质量单位为微克，强度单位为任意单位。健康对照泳道显示的肌营养不良蛋白条带强度为 $1.83 \\times 10^{4}$。BMD泳道显示的肌营养不良蛋白条带强度为 $1.128 \\times 10^{4}$。所使用的抗肌营养不良蛋白抗体结合C-端表位，但与截短的BMD肌营养不良蛋白的亲和力较低；这表现为，相对于BMD泳道中真实的肌营养不良蛋白质量，测量信号均匀地乘法性降低了一个因子 $f_{\\mathrm{BMD}} = 0.80$，而对照泳道的因子为 $f_{\\mathrm{CTRL}} = 1.00$。\n\n为了校正各泳道间总蛋白上样量不等的问题，实验室使用了同一张膜上的α-辅肌动蛋白上样对照的强度，测得对照泳道为 $2.00 \\times 10^{4}$，BMD泳道为 $2.5043 \\times 10^{4}$。光密度计在上样对照通道有一个 $2.00 \\times 10^{3}$ 的附加基线偏移量，在进行归一化之前，必须从测得的上样对照强度中减去该值。\n\n假设以下基本事实成立：在Western blot经过验证的线性动态范围内，积分条带强度与上样的蛋白质量成正比，并带有一个附加偏移量；对稳定的上样对照进行归一化可以校正各泳道总蛋白上样量的差异；当肌营养不良蛋白的恢复量超过某个最低相对丰度时，可以改善肌膜的机械稳定性。将归一化相对肌营养不良蛋白丰度 $R$ 定义为BMD泳道中每单位经上样对照校正强度后的肌营养不良蛋白质量与对照泳道中相应值的比值。进一步定义肌营养不良蛋白丰度的功能充足性阈值 $R^{*} = 0.50$（无量纲），该值是在贝克型肌营养不良症中通常与具有临床意义的机械稳定性相关的最低归一化分数。\n\n计算功能充足性指数 $S = \\frac{R}{R^{*}}$。将最终的 $S$ 值四舍五入至三位有效数字。将 $S$ 表示为无量纲量。", "solution": "该问题被认为是有效的，因为它在科学上基于标准的生物化学原理，提法明确，数据充分且一致，并且表述客观。\n\n目标是计算功能充足性指数 $S$，其定义为 $S = \\frac{R}{R^{*}}$，其中 $R$ 是归一化相对肌营养不良蛋白丰度，$R^{*}$ 是给定的阈值。\n\n首先，我们必须建立肌营养不良蛋白质量 $M$ 与测得的积分条带强度 $I$ 之间的关系。问题陈述了带有附加偏移量的线性响应，可用以下方程建模：\n$$I = kM + I_0$$\n其中 $k$ 是斜率（灵敏度），$I_0$ 是仪器偏移量（y轴截距）。我们可以根据提供的标准品数据确定 $k$ 和 $I_0$。\n\n使用数据点 $(M_1, I_1) = (1.00, 1.23 \\times 10^{4})$ 和 $(M_2, I_2) = (2.00, 2.45 \\times 10^{4})$，斜率 $k$ 为：\n$$k = \\frac{\\Delta I}{\\Delta M} = \\frac{I_2 - I_1}{M_2 - M_1} = \\frac{2.45 \\times 10^{4} - 1.23 \\times 10^{4}}{2.00 - 1.00} = \\frac{1.22 \\times 10^{4}}{1.00} = 1.22 \\times 10^{4}$$\n$k$ 的单位是任意强度单位/微克。\n\n现在，我们使用第一个点 $(0.50, 6.20 \\times 10^{3})$ 求解截距 $I_0$：\n$$I_0 = I - kM = 6.20 \\times 10^{3} - (1.22 \\times 10^{4})(0.50) = 6200 - 6100 = 100$$\n因此，校准方程为 $I = (1.22 \\times 10^{4})M + 100$。为了从测得的强度 $I$ 计算质量 $M$，我们重新整理此方程：\n$$M = \\frac{I - I_0}{k}$$\n\n接下来，我们必须考虑抗体对对照组（全长）和BMD（截短）肌营养不良蛋白的不同亲和力。测得的强度对应于一个*有效*质量，它是真实质量 $M_{\\mathrm{true}}$ 和亲和力因子 $f$ 的乘积。因此，校准方程将强度与有效质量联系起来：\n$$I_{\\mathrm{measured}} = k(f \\cdot M_{\\mathrm{true}}) + I_0$$\n求解真实质量可得：\n$$M_{\\mathrm{true}} = \\frac{I_{\\mathrm{measured}} - I_0}{k \\cdot f}$$\n\n问题将归一化相对肌营养不良蛋白丰度 $R$ 定义为BMD泳道中每单位经上样对照校正强度后的肌营养不良蛋白质量与对照泳道中相应值的比值。设 $M_{\\mathrm{BMD, true}}$ 和 $M_{\\mathrm{CTRL, true}}$ 分别为真实的肌营养不良蛋白质量，设 $LC_{\\mathrm{BMD, corr}}$ 和 $LC_{\\mathrm{CTRL, corr}}$ 分别为BMD泳道和对照泳道校正后的上样对照强度。\n$R$ 的定义为：\n$$R = \\frac{\\left(\\frac{M_{\\mathrm{BMD, true}}}{LC_{\\mathrm{BMD, corr}}}\\right)}{\\left(\\frac{M_{\\mathrm{CTRL, true}}}{LC_{\\mathrm{CTRL, corr}}}\\right)} = \\frac{M_{\\mathrm{BMD, true}}}{M_{\\mathrm{CTRL, true}}} \\cdot \\frac{LC_{\\mathrm{CTRL, corr}}}{LC_{\\mathrm{BMD, corr}}}$$\n\n让我们将真实质量的表达式代入此方程：\n$$R = \\frac{\\left(\\frac{I_{\\mathrm{BMD, measured}} - I_0}{k \\cdot f_{\\mathrm{BMD}}}\\right)}{\\left(\\frac{I_{\\mathrm{CTRL}} - I_0}{k \\cdot f_{\\mathrm{CTRL}}}\\right)} \\cdot \\frac{LC_{\\mathrm{CTRL, corr}}}{LC_{\\mathrm{BMD, corr}}}$$\n校准斜率 $k$ 被消去，表达式简化为：\n$$R = \\frac{I_{\\mathrm{BMD, measured}} - I_0}{I_{\\mathrm{CTRL}} - I_0} \\cdot \\frac{f_{\\mathrm{CTRL}}}{f_{\\mathrm{BMD}}} \\cdot \\frac{LC_{\\mathrm{CTRL, corr}}}{LC_{\\mathrm{BMD, corr}}}$$\n\n现在我们必须计算校正后的上样对照强度。测量值必须根据基线偏移量 $LC_{\\mathrm{offset}} = 2.00 \\times 10^{3}$ 进行校正。\n对于对照泳道：\n$$LC_{\\mathrm{CTRL, corr}} = LC_{\\mathrm{CTRL, measured}} - LC_{\\mathrm{offset}} = 2.00 \\times 10^{4} - 2.00 \\times 10^{3} = 20000 - 2000 = 18000$$\n对于BMD泳道：\n$$LC_{\\mathrm{BMD, corr}} = LC_{\\mathrm{BMD, measured}} - LC_{\\mathrm{offset}} = 2.5043 \\times 10^{4} - 2.00 \\times 10^{3} = 25043 - 2000 = 23043$$\n\n我们现在有了计算 $R$ 所需的所有值。\n已知条件：\n- $I_0 = 100$\n- $I_{\\mathrm{BMD, measured}} = 1.128 \\times 10^{4} = 11280$\n- $I_{\\mathrm{CTRL}} = 1.83 \\times 10^{4} = 18300$\n- $f_{\\mathrm{BMD}} = 0.80$\n- $f_{\\mathrm{CTRL}} = 1.00$\n- $LC_{\\mathrm{CTRL, corr}} = 18000$\n- $LC_{\\mathrm{BMD, corr}} = 23043$\n\n将这些值代入 $R$ 的公式中：\n$$R = \\frac{11280 - 100}{18300 - 100} \\cdot \\frac{1.00}{0.80} \\cdot \\frac{18000}{23043}$$\n$$R = \\frac{11180}{18200} \\cdot \\frac{1}{0.80} \\cdot \\frac{18000}{23043}$$\n$$R = \\left(\\frac{1118}{1820}\\right) \\cdot (1.25) \\cdot \\left(\\frac{18000}{23043}\\right)$$\n计算各项：\n$$R \\approx (0.6142857) \\cdot (1.25) \\cdot (0.7811487)$$\n$$R \\approx (0.7678571) \\cdot (0.7811487) \\approx 0.6000037$$\n我们将在下一步中使用这个更精确的值。\n\n最后，我们使用给定的阈值 $R^{*} = 0.50$ 计算功能充足性指数 $S$。\n$$S = \\frac{R}{R^{*}} = \\frac{0.6000037...}{0.50} = 1.2000074...$$\n问题要求将最终答案四舍五入至三位有效数字。\n$$S \\approx 1.20$$\n这是一个无量纲量。", "answer": "$$\\boxed{1.20}$$", "id": "4499923"}, {"introduction": "基于阅读框规则，现代疗法致力于纠正导致DMD的框外突变。这项练习将您置于治疗策略设计的前沿，要求您构建一个算法来识别哪些外显子可以通过“跳跃”技术被移除，从而恢复阅读框。这项任务旨在将一个严重的DMD致病突变转化为一个较温和的BMD样突变，体现了计算生物学在精准医疗中的强大应用。 [@problem_id:4499934]", "problem": "设计一个程序，根据给定的肌萎缩蛋白基因的患者特异性编码外显子坐标和连续的外显子缺失，确定所提供的候选集中的哪些外显子跳跃靶点能够恢复开放阅读框。使用以下基本原理：分子生物学的中心法则和遗传密码，其中信使核糖核酸（mRNA）以长度为 $3$ 个核苷酸的密码子进行翻译，并且当且仅当移除的编码核苷酸净数量是 $3$ 的倍数时，开放阅读框得以保持。将恢复标准纯粹用算术术语表示：对于编码长度为 $\\{L_k\\}$（单位：核苷酸）的外显子 $i$到 $j$ 的缺失，令 $r = \\left(\\sum_{k=i}^{j} L_k\\right) \\bmod 3$。对于来自候选池的任何额外外显子跳跃集 $S$，恢复阅读框需要满足 $\\left(r + \\sum_{e \\in S} L_e\\right) \\bmod 3 = 0$。你的任务是为每个测试用例计算满足恢复标准的所有最小基数跳跃集 $S$ 的列表。如果缺失本身已在框内（即 $r = 0$），则空集是唯一的最小解，并且必须在外部结果中以 $[\\,]$ 的形式返回。如果候选池中没有子集可以恢复阅读框，则返回一个空的外部列表以表示不存在解决方案。所有外显子坐标都以编码序列上核苷酸的起始和结束位置提供，长度以核苷酸为单位计算为 $L_e = \\text{end} - \\text{start} + 1$；所有长度均使用单位“核苷酸 (nt)”。你的程序不得依赖于这些原则之外的任何生物学捷径。\n\n为了可复现性和可测试性，请将你的算法应用于以下测试套件。对于每个测试用例，输入由以下部分给出：一个外显子坐标字典，将外显子标签（整数）映射到核苷酸单位的（起始，结束）坐标对，一个包含端点的缺失区间 $(i, j)$，以及一个待考虑跳跃的候选外显子列表。每个测试用例所需的输出是一个列表的列表，其中包含外显子标签，代表所有恢复阅读框的最小基数跳跃集，并按字典序排序。外显子长度的单位是核苷酸 (nt)。角度单位不适用。百分比不适用。\n\n测试套件：\n- 案例 1（理想路径，治疗设计适用性）：外显子 $49$–$53$ 的患者特异性坐标以核苷酸为单位给出如下：$49: (7000, 7149)$，$50: (7150, 7307)$，$51: (7308, 7458)$，$52: (7459, 7638)$，$53: (7639, 7838)$。缺失为 $(49, 50)$，候选池为 $[51, 52, 53]$。任务是确定单独跳跃外显子 $51$ 是否能恢复外显子 $49$–$50$ 缺失所导致的阅读框，这与已知的治疗策略一致。\n- 案例 2（边界条件，已在框内）：外显子 $10$–$14$ 的坐标为 $10: (1000, 1119)$，$11: (1120, 1266)$，$12: (1267, 1422)$，$13: (1423, 1550)$，$14: (1551, 1680)$。缺失为 $(10, 12)$，候选池为 $[13, 14]$。由于缺失已在框内，最小解必须是空集。\n- 案例 3（边缘情况，候选池中无解）：外显子 $20$–$22$ 的坐标为 $20: (2000, 2100)$，$21: (2101, 2201)$，$22: (2202, 2324)$。缺失为 $(20, 21)$，候选池为 $[22]$。证明候选池中没有任何跳跃集可以恢复阅读框。\n- 案例 4（覆盖多个最小解）：外显子 $30$–$32$ 的坐标为 $30: (3000, 3148)$，$31: (3149, 3308)$，$32: (3309, 3483)$。缺失为 $(30, 30)$，候选池为 $[31, 32]$。确定所有最小的单外显子跳跃解。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内无空格。每个元素对应一个测试用例，其本身也是一个列表的列表（可能为空）。例如，四个测试用例的输出格式为 $[result\\_1,result\\_2,result\\_3,result\\_4]$，无空格，如 $[[[51]],[[]],[],[[31],[32]]]$。所有计算必须基于上述定义的模运算，长度单位为核苷酸 (nt)。不使用角度，也禁止使用百分比。", "solution": "对所提供的问题陈述进行严格验证。\n\n### 步骤 1：提取已知条件\n\n- **基本原理**：信使核糖核酸（mRNA）翻译成蛋白质的过程以长度为 $3$ 个核苷酸的密码子为单位进行。当且仅当从编码序列中切除的核苷酸净数量是 $3$ 的倍数时，开放阅读框（ORF）才能得以保持。\n- **外显子长度计算**：对于坐标为 $(\\text{start}, \\text{end})$ 的外显子，其长度 $L_e$ 由公式 $L_e = \\text{end} - \\text{start} + 1$ 给出，单位为核苷酸 (nt)。\n- **缺失分析**：对于从外显子 $i$到外显子 $j$ 的连续缺失，缺失的总长度为 $L_{del} = \\sum_{k=i}^{j} L_k$。阅读框的破坏由余数 $r = L_{del} \\bmod 3$ 来表征。\n- **阅读框恢复标准**：当且仅当缺失和跳跃的核苷酸总长度是 $3$ 的倍数时，来自候选池的额外跳跃外显子集 $S$ 才能恢复阅读框。用算术形式表示为 $\\left(r + \\sum_{e \\in S} L_e\\right) \\bmod 3 = 0$。\n- **目标**：为每个测试用例，找出满足恢复标准的所有最小基数集 $S$。\n- **输出规范**：\n    1.  每个案例的结果是所有最小基数解集的列表。\n    2.  如果 $r=0$，唯一的最小解是空集，必须表示为 `[[]]`。\n    3.  如果不存在解，结果为空列表 `[]`。\n    4.  解集列表必须按字典序排序。\n    5.  最终输出是连接所有测试用例结果的单行字符串，例如 `[result_1,result_2,...,result_N]`。\n\n- **测试套件**：\n    - **案例 1**：外显子坐标：$\\{49: (7000, 7149), 50: (7150, 7307), 51: (7308, 7458), 52: (7459, 7638), 53: (7639, 7838)\\}$。缺失：$(49, 50)$。候选池：$[51, 52, 53]$。\n    - **案例 2**：外显子坐标：$\\{10: (1000, 1119), 11: (1120, 1266), 12: (1267, 1422), 13: (1423, 1550), 14: (1551, 1680)\\}$。缺失：$(10, 12)$。候选池：$[13, 14]$。\n    - **案例 3**：外显子坐标：$\\{20: (2000, 2100), 21: (2101, 2201), 22: (2202, 2324)\\}$。缺失：$(20, 21)$。候选池：$[22]$。\n    - **案例 4**：外显子坐标：$\\{30: (3000, 3148), 31: (3149, 3308), 32: (3309, 3483)\\}$。缺失：$(30, 30)$。候选池：$[31, 32]$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n- **科学依据**：该问题正确地基于“阅读框规则”，这是分子遗传学中的一个基本概念，对于理解 Duchenne 和 Becker 肌营养不良症的病理学以及外显子跳跃疗法的机制至关重要。其算术形式化是一个标准且有效的简化。\n- **适定性**：该问题是适定的。目标明确，所有术语均已指定，解的条件清晰无歧义。处理特殊情况（框内缺失、无解）和格式化输出（最小基数、字典序排序）的要求确保了存在唯一且有意义的解，并且该解是可表示的。\n- **客观性**：问题以精确、客观、科学的语言陈述，没有歧义或主观论断。\n\n### 步骤 3：结论与行动\n\n问题陈述在科学上是合理的，在数学上是适定的，并且是客观的。因此判定为**有效**。将制定并实施一个解决方案。\n\n### 解决方案推导\n\n该算法通过将阅读框恢复的生物学原理转化为一个由模运算控制的离散组合搜索问题来执行。\n\n1.  **预处理**：对于每个测试用例，我们首先使用公式 $L_e = \\text{end} - \\text{start} + 1$ 计算所有相关外显子的长度。\n\n2.  **缺失分析**：我们确定指定初始缺失的总长度 $L_{del} = \\sum_{k=i}^{j} L_k$，其中 $[i, j]$ 是缺失外显子的闭区间。对阅读框的影响通过余数 $r = L_{del} \\bmod 3$ 来量化。\n\n3.  **阅读框恢复条件**：如果所有移除外显子的总长度是 $3$ 的倍数，则对一组外显子 $S$ 的治疗性跳跃是成功的。这由给定标准表示：$(L_{del} + \\sum_{e \\in S} L_e) \\bmod 3 = 0$。这等价于要求治疗性跳跃的外显子长度之和 $L_S = \\sum_{e \\in S} L_e$ 满足 $L_S \\bmod 3 = (3 - r) \\bmod 3$。我们将此所需余数定义为 $r_{target}$。\n\n4.  **特殊情况 - 框内缺失**：如果 $r=0$，则缺失已经是“框内的”。阅读框未被破坏。因此，无需跳跃额外的外显子。最小基数解为空集，记为 $\\emptyset$。此情况所需的输出格式是包含一个空列表的列表。\n\n5.  **最小解的组合搜索**：如果 $r \\neq 0$，我们必须在候选池中搜索满足恢复标准的子集 $S$。为找到最小基数的解，我们对逐渐增大的子集大小 $c$ 进行迭代搜索。\n    a.  令 $C$ 为候选外显子池。\n    b.  我们将 $c$ 从 $1$ 迭代到 $|C|$。\n    c.  对于每个 $c$，我们生成所有满足 $|S|=c$ 的外显子组合 $S \\subseteq C$。\n    d.  对于每个组合 $S$，我们计算其总长度 $L_S$ 并检查是否满足 $L_S \\bmod 3 = r_{target}$。\n    e.  如果对于给定的基数 $c$，我们找到了一个或多个这样的集合 $S$，那么这些就是最小基数解。我们收集所有针对此 $c$ 的解，按字典序对它们进行排序，并终止搜索。\n    f.  如果迭代完成所有直至 $|C|$ 的 $c$ 值仍未找到任何解，则表示候选池中不存在这样的集合。结果是一个空列表。\n\n### 应用于测试套件\n\n**案例 1**：\n- 外显子长度（单位 nt）：$L_{49} = 150$，$L_{50} = 158$。候选外显子长度：$L_{51} = 151$，$L_{52} = 180$，$L_{53} = 200$。\n- 缺失：外显子 $49, 50$。$L_{del} = L_{49} + L_{50} = 150 + 158 = 308$ nt。\n- 阅读框破坏：$r = 308 \\bmod 3 = 2$。\n- 目标余数：$r_{target} = (3 - 2) \\bmod 3 = 1$。\n- 我们寻找 $\\{51, 52, 53\\}$ 的一个最小子集，其长度之和模 $3$ 为 $1$。\n- 候选外显子余数：$L_{51} \\bmod 3 = 1$，$L_{52} \\bmod 3 = 0$，$L_{53} \\bmod 3 = 2$。\n- 搜索（基数 $c=1$）：\n    - 集合 $\\{51\\}$：长度和余数为 $1$。这与 $r_{target}$ 匹配。\n- 在最小基数 $c=1$ 处找到了一个解。解集为 $\\{51\\}$。\n- 结果：$[[51]]$。\n\n**案例 2**：\n- 外显子长度（单位 nt）：$L_{10} = 120$，$L_{11} = 147$，$L_{12} = 156$。\n- 缺失：外显子 $10, 11, 12$。$L_{del} = L_{10} + L_{11} + L_{12} = 120 + 147 + 156 = 423$ nt。\n- 阅读框破坏：$r = 423 \\bmod 3 = 0$。\n- 缺失在框内。最小解是空集。\n- 结果：$[[]]$。\n\n**案例 3**：\n- 外显子长度（单位 nt）：$L_{20} = 101$，$L_{21} = 101$。候选外显子长度：$L_{22} = 123$。\n- 缺失：外显子 $20, 21$。$L_{del} = L_{20} + L_{21} = 101 + 101 = 202$ nt。\n- 阅读框破坏：$r = 202 \\bmod 3 = 1$。\n- 目标余数：$r_{target} = (3 - 1) \\bmod 3 = 2$。\n- 我们寻找 $\\{22\\}$ 的一个最小子集，其长度之和模 $3$ 为 $2$。\n- 候选外显子余数：$L_{22} \\bmod 3 = 123 \\bmod 3 = 0$。\n- 搜索（基数 $c=1$）：\n    - 集合 $\\{22\\}$：长度和余数为 $0$。这与 $r_{target}$ 不匹配。\n- 候选池已用尽。不存在解。\n- 结果：[]。\n\n**案例 4**：\n- 外显子长度（单位 nt）：$L_{30} = 149$。候选外显子长度：$L_{31} = 160$，$L_{32} = 175$。\n- 缺失：外显子 $30$。$L_{del} = L_{30} = 149$ nt。\n- 阅读框破坏：$r = 149 \\bmod 3 = 2$。\n- 目标余数：$r_{target} = (3 - 2) \\bmod 3 = 1$。\n- 我们寻找 $\\{31, 32\\}$ 的一个最小子集，其长度之和模 $3$ 为 $1$。\n- 候选外显子余数：$L_{31} \\bmod 3 = 160 \\bmod 3 = 1$。$L_{32} \\bmod 3 = 175 \\bmod 3 = 1$。\n- 搜索（基数 $c=1$）：\n    - 集合 $\\{31\\}$：长度和余数为 $1$。这与 $r_{target}$ 匹配。找到解。\n    - 集合 $\\{32\\}$：长度和余数为 $1$。这与 $r_{target}$ 匹配。找到解。\n- 在最小基数 $c=1$ 处，我们有两个解：$\\{31\\}$ 和 $\\{32\\}$。\n- 按字典序排序后，结果为 $[[31], [32]]$。\n\n这个结构化的、基于原理的算法正确地解决了问题的所有方面，并在以下程序中得以实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and generate the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"coords\": {49: (7000, 7149), 50: (7150, 7307), 51: (7308, 7458), 52: (7459, 7638), 53: (7639, 7838)},\n            \"deletion\": (49, 50),\n            \"candidates\": [51, 52, 53]\n        },\n        {\n            \"coords\": {10: (1000, 1119), 11: (1120, 1266), 12: (1267, 1422), 13: (1423, 1550), 14: (1551, 1680)},\n            \"deletion\": (10, 12),\n            \"candidates\": [13, 14]\n        },\n        {\n            \"coords\": {20: (2000, 2100), 21: (2101, 2201), 22: (2202, 2324)},\n            \"deletion\": (20, 21),\n            \"candidates\": [22]\n        },\n        {\n            \"coords\": {30: (3000, 3148), 31: (3149, 3308), 32: (3309, 3483)},\n            \"deletion\": (30, 30),\n            \"candidates\": [31, 32]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case['coords'], case['deletion'], case['candidates'])\n        results.append(result)\n\n    # Format the final output string according to the problem specification.\n    # It requires a compact representation with no spaces.\n    str_results = []\n    for r in results:\n        str_results.append(str( r ).replace(' ', ''))\n    \n    print(f\"[{','.join(str_results)}]\")\n\ndef process_case(coords, deletion, candidates):\n    \"\"\"\n    Solves a single case for finding minimal-cardinality exon skipping sets.\n\n    Args:\n        coords (dict): A dictionary mapping exon labels to (start, end) coordinates.\n        deletion (tuple): A tuple (i, j) for the inclusive range of deleted exons.\n        candidates (list): A list of exon labels in the candidate pool for skipping.\n\n    Returns:\n        list: A list of lists of exon labels, representing all minimal-cardinality\n              skipping sets that restore the reading frame. Sorted lexicographically.\n              Returns [[]] for in-frame deletions and [] for no solution.\n    \"\"\"\n    # Step 1: Calculate lengths of all relevant exons in nucleotides.\n    lengths = {exon: end - start + 1 for exon, (start, end) in coords.items()}\n\n    # Step 2: Calculate the total length of the primary deletion and its remainder modulo 3.\n    del_start, del_end = deletion\n    deleted_len_sum = 0\n    for exon_num in range(del_start, del_end + 1):\n        deleted_len_sum += lengths[exon_num]\n    \n    r = deleted_len_sum % 3\n\n    # Step 3: Handle the in-frame case.\n    if r == 0:\n        return [[]]\n\n    # Step 4: Determine the target remainder for the therapeutic skip.\n    r_target = (3 - r) % 3\n\n    # Step 5: Search for minimal-cardinality solutions.\n    # Sort candidates to ensure itertools.combinations produces lexicographically ordered tuples.\n    candidates.sort()\n\n    for c in range(1, len(candidates) + 1):\n        minimal_solutions = []\n        for combo in itertools.combinations(candidates, c):\n            skip_len_sum = sum(lengths[e] for e in combo)\n            if skip_len_sum % 3 == r_target:\n                minimal_solutions.append(list(combo))\n        \n        # If solutions are found for cardinality c, this is the minimal cardinality.\n        # Return them and terminate the search for this case.\n        if minimal_solutions:\n            # The solutions are already lexicographically sorted because candidates were sorted\n            # and itertools.combinations preserves that order.\n            return minimal_solutions\n\n    # If the loop completes, no solution was found in the candidate pool.\n    return []\n\n# Execute the solver.\nsolve()\n```", "id": "4499934"}]}