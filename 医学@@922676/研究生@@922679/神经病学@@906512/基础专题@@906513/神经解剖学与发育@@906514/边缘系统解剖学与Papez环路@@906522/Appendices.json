{"hands_on_practices": [{"introduction": "要理解一个神经环路的功能，首先必须掌握其基本的时间尺度。这个练习通过一个基础的计算，引导你估算一个神经冲动完整地遍历Papez环路所需的总时间。通过将环路的解剖结构（通路长度）与基础生理学参数（轴突传导速度和突触延迟）相结合，这项练习能帮助你建立关于记忆和情绪处理所需操作时间的直观感受[@problem_id:4489978]。", "problem": "一个基于神经生理学的巴贝兹回路（Papez circuit）模型提出了以下经典通路：海马结构（下托）通过穹窿投射到乳头体，乳头体通过乳头丘脑束投射到丘脑前核，丘脑前核通过丘脑皮质纤维投射到扣带回，扣带回通过扣带束投射到内嗅皮层，内嗅皮层再通过穿通通路投射回海马结构。假设每个中继都涉及一个化学突觸，并且轴突传导沿着以下具有近似直线路径长度的神经束段进行：穹窿 $\\left(35\\ \\mathrm{mm}\\right)$、乳头丘脑束 $\\left(20\\ \\mathrm{mm}\\right)$、到扣带回的丘脑皮质投射 $\\left(50\\ \\mathrm{mm}\\right)$、从扣带回到内嗅皮层的扣带束段 $\\left(70\\ \\mathrm{mm}\\right)$，以及穿通通路 $\\left(15\\ \\mathrm{mm}\\right)$。假设所有神经束段的轴突传导速度是独立同分布的，服从区间 $\\left[1,3\\right]\\ \\mathrm{m/s}$ 上的连续均匀随机分布，并且每个中继的突触延迟是独立同分布的，服从区间 $\\left[2,5\\right]\\ \\mathrm{ms}$ 上的连续均匀随机分布。该环路中有 $5$ 个中继。请仅使用时间、距离和速度的基本定义，以及独立随机变量期望的性质，计算单个脉冲从海马结构出发，经由内嗅皮层返回，完成一个完整环路所需的期望累积时间。最终答案以 $\\mathrm{ms}$ 为单位，并四舍五入到四位有效数字。", "solution": "### 第 1 步：提取已知条件\n- **通路段及其长度**：\n    - 穹窿：$L_1 = 35\\ \\mathrm{mm}$\n    - 乳头丘脑束：$L_2 = 20\\ \\mathrm{mm}$\n    - 丘脑皮质投射：$L_3 = 50\\ \\mathrm{mm}$\n    - 扣带束段：$L_4 = 70\\ \\mathrm{mm}$\n    - 穿通通路：$L_5 = 15\\ \\mathrm{mm}$\n- **轴突段数量**：$N_{tracts} = 5$。\n- **突触中继数量**：$N_{relays} = 5$。\n- **轴突传导速度分布**：对于每个段 $i$，速度 $V_i$ 是一个随机变量。\n    - $V_i \\sim U(1, 3)$，单位为 $\\mathrm{m/s}$。\n    - 速度 $V_1, V_2, V_3, V_4, V_5$ 是独立同分布（i.i.d.）的。\n- **突触延迟分布**：对于每个中继 $j$，延迟 $D_j$ 是一个随机变量。\n    - $D_j \\sim U(2, 5)$，单位为 $\\mathrm{ms}$。\n    - 延迟 $D_1, D_2, D_3, D_4, D_5$ 是独立同分布的。\n- **目标**：计算完成一个完整环路的期望总时间 $E[T_{total}]$，单位为 $\\mathrm{ms}$，并四舍五入到四位有效数字。\n\n### 解题过程\n脉冲完成巴贝兹回路一个环路的总时间 $T_{total}$ 是沿 $5$ 个轴突束的传导时间与 $5$ 个中继处的突触延迟之和。我们可以将其表示为：\n$$\nT_{total} = \\sum_{i=1}^{5} T_{i} + \\sum_{j=1}^{5} D_{j}\n$$\n其中 $T_i$ 是第 $i$ 个神经束的传导时间，$D_j$ 是第 $j$ 个突触的延迟。\n\n问题要求计算期望累积时间 $E[T_{total}]$。根据期望的线性性质，随机变量之和的期望等于它们各自期望之和：\n$$\nE[T_{total}] = E\\left[\\sum_{i=1}^{5} T_{i} + \\sum_{j=1}^{5} D_{j}\\right] = \\sum_{i=1}^{5} E[T_{i}] + \\sum_{j=1}^{5} E[D_{j}]\n$$\n\n我们将分别计算期望总突触延迟和期望总传导时间。\n\n**1. 期望突触延迟**\n\n突触延迟 $D_j$ 是来自连续均匀分布的独立同分布（i.i.d.）随机变量，$D_j \\sim U(2, 5)\\ \\mathrm{ms}$。\n对于一个随机变量 $X \\sim U(a, b)$，其期望值为 $E[X] = \\frac{a+b}{2}$。\n因此，单个突触的期望延迟为：\n$$\nE[D_j] = \\frac{2\\ \\mathrm{ms} + 5\\ \\mathrm{ms}}{2} = \\frac{7}{2}\\ \\mathrm{ms} = 3.5\\ \\mathrm{ms}\n$$\n由于有 $N_{relays} = 5$ 个独立同分布的中继，总的期望突触延迟为：\n$$\nE[T_{synaptic}] = \\sum_{j=1}^{5} E[D_j] = 5 \\times E[D_j] = 5 \\times 3.5\\ \\mathrm{ms} = 17.5\\ \\mathrm{ms}\n$$\n\n**2. 期望传导时间**\n\n单个神经束 $i$ 的传导时间由基本关系 $T_i = \\frac{L_i}{V_i}$ 给出，其中 $L_i$ 是神经束的长度，$V_i$ 是传导速度。\n神经束 $i$ 的期望传导时间为 $E[T_i] = E\\left[\\frac{L_i}{V_i}\\right]$。由于 $L_i$ 是常数，我们有：\n$$\nE[T_i] = L_i E\\left[\\frac{1}{V_i}\\right]\n$$\n速度 $V_i$ 是来自连续均匀分布的独立同分布随机变量，$V_i \\sim U(1, 3)\\ \\mathrm{m/s}$。为了与以 $\\mathrm{mm}$ 为单位的长度和以 $\\mathrm{ms}$ 为单位的最终答案保持单位一致，我们将速度单位转换为 $\\mathrm{mm/s}$：\n$$\nV_i \\sim U\\left(1 \\frac{\\mathrm{m}}{\\mathrm{s}} \\times \\frac{1000\\ \\mathrm{mm}}{1\\ \\mathrm{m}}, 3 \\frac{\\mathrm{m}}{\\mathrm{s}} \\times \\frac{1000\\ \\mathrm{mm}}{1\\ \\mathrm{m}}\\right) \\implies V_i \\sim U(1000, 3000)\\ \\mathrm{mm/s}\n$$\n设随机变量 $V \\sim U(a, b)$，其中 $a=1000\\ \\mathrm{mm/s}$，$b=3000\\ \\mathrm{mm/s}$。其概率密度函数（PDF）为 $f(v) = \\frac{1}{b-a}$（当 $v \\in [a, b]$ 时），否则为 $0$。\n我们计算速度倒数的期望 $E[1/V]$：\n$$\nE\\left[\\frac{1}{V}\\right] = \\int_{a}^{b} \\frac{1}{v} f(v) dv = \\int_{1000}^{3000} \\frac{1}{v} \\left(\\frac{1}{3000 - 1000}\\right) dv = \\frac{1}{2000} \\int_{1000}^{3000} \\frac{1}{v} dv\n$$\n$$\nE\\left[\\frac{1}{V}\\right] = \\frac{1}{2000} \\left[ \\ln(v) \\right]_{1000}^{3000} = \\frac{1}{2000} \\left( \\ln(3000) - \\ln(1000) \\right) = \\frac{\\ln(3000/1000)}{2000} = \\frac{\\ln(3)}{2000}\\ \\mathrm{s/mm}\n$$\n由于所有 $V_i$ 都是独立同分布的，所以 $E[1/V_i]$ 对所有神经束都相同。\n总的期望传导时间是每个神经束的期望时间之和：\n$$\nE[T_{conduction}] = \\sum_{i=1}^{5} E[T_i] = \\sum_{i=1}^{5} L_i E\\left[\\frac{1}{V_i}\\right] = \\left(\\sum_{i=1}^{5} L_i\\right) E\\left[\\frac{1}{V_i}\\right]\n$$\n总路径长度为 $L_{total} = L_1 + L_2 + L_3 + L_4 + L_5$：\n$$\nL_{total} = 35\\ \\mathrm{mm} + 20\\ \\mathrm{mm} + 50\\ \\mathrm{mm} + 70\\ \\mathrm{mm} + 15\\ \\mathrm{mm} = 190\\ \\mathrm{mm}\n$$\n现在我们计算总的期望传导时间：\n$$\nE[T_{conduction}] = L_{total} \\times E\\left[\\frac{1}{V}\\right] = 190\\ \\mathrm{mm} \\times \\frac{\\ln(3)}{2000}\\ \\frac{\\mathrm{s}}{\\mathrm{mm}} = \\frac{190 \\ln(3)}{2000}\\ \\mathrm{s}\n$$\n问题要求答案以毫秒（$\\mathrm{ms}$）为单位。我们将秒转换为毫秒（$1\\ \\mathrm{s} = 1000\\ \\mathrm{ms}$）：\n$$\nE[T_{conduction}] = \\frac{190 \\ln(3)}{2000}\\ \\mathrm{s} \\times \\frac{1000\\ \\mathrm{ms}}{1\\ \\mathrm{s}} = \\frac{190 \\ln(3)}{2}\\ \\mathrm{ms} = 95 \\ln(3)\\ \\mathrm{ms}\n$$\n\n**3. 总期望时间**\n\n完成一个环路的总期望时间是期望突触延迟和期望传导时间之和：\n$$\nE[T_{total}] = E[T_{synaptic}] + E[T_{conduction}] = 17.5\\ \\mathrm{ms} + 95 \\ln(3)\\ \\mathrm{ms}\n$$\n为了提供数值答案，我们使用 $3$ 的自然对数值：$\\ln(3) \\approx 1.09861228867$。\n$$\nE[T_{total}] \\approx 17.5 + 95 \\times 1.09861228867 \\ \\mathrm{ms}\n$$\n$$\nE[T_{total}] \\approx 17.5 + 104.36816742 \\ \\mathrm{ms}\n$$\n$$\nE[T_{total}] \\approx 121.86816742\\ \\mathrm{ms}\n$$\n四舍五入到四位有效数字，我们得到：\n$$\nE[T_{total}] \\approx 121.9\\ \\mathrm{ms}\n$$", "answer": "$$\n\\boxed{121.9}\n$$", "id": "4489978"}, {"introduction": "现代神经科学的一个强大工具是将复杂的解剖环路抽象为计算图模型。这项练习将引导你从简单的生理计算进入网络层面的建模，学习如何将Papez环路形式化为一个有向图，并利用线性代数来预测其在外部输入下的稳态活动分布[@problem_id:4490045]。通过模拟乳头体丘脑束的损伤，这个实践清晰地展示了计算模型如何量化局部脑损伤的功能性后果，这是临床神经科学中的一个核心方法。", "problem": "要求您形式化一个边缘系统中Papez回路的计算模型，该模型捕捉其标准节点间的定向信息流，然后通过模拟移除一条有向边来量化乳头丘脑束中断所造成的影响。解剖学组件应被抽象为一个有向循环图，其中节点代表区域，边代表神经束。核心区域包括海马体、乳头体、丘脑前核、扣带回和内嗅皮层。乳头丘脑束对应于从乳头体到丘脑前核的有向边。\n\n基本原理和定义：\n- 一个有向图由邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 表示，其中 $A_{ij}$ 是从节点 $i$ 到节点 $j$ 的有向边的权重，$n$ 是节点数量。\n- 有向图上的非负线性传播模型使用离散时间更新形式 $x_{t+1} = \\alpha A^\\top x_t + u$，其中 $x_t \\in \\mathbb{R}^n$ 是时间 $t$ 的激活向量，$A^\\top$ 是邻接矩阵的转置，$\\alpha \\in \\mathbb{R}$ 是一个标量传播因子，满足 $0 \\le \\alpha  1/\\rho(A)$，$u \\in \\mathbb{R}^n$ 是一个非负常数输入向量。这里 $\\rho(A)$ 表示 $A$ 的谱半径。在这些条件下，系统会收敛到一个唯一的不动点 $x^\\ast$，使得 $x^\\ast = \\alpha A^\\top x^\\ast + u$。\n- 解剖结构到矩阵索引的映射固定如下：海马体索引为 $0$，乳头体索引为 $1$，丘脑前核索引为 $2$，扣带回索引为 $3$，内嗅皮层索引为 $4$。主循环是海马体 $\\rightarrow$ 乳头体 $\\rightarrow$ 丘脑前核 $\\rightarrow$ 扣带回 $\\rightarrow$ 内嗅皮层 $\\rightarrow$ 海马体，并附带一条海马体 $\\rightarrow$ 丘脑前核的侧支边。\n\n您的任务：\n1. 对每个测试用例，使用提供的边权重构建一个大小为 $5 \\times 5$ 的邻接矩阵 $A$，所有未指定的条目均设为 $0$。非零条目对应于：\n   - 海马体 $\\rightarrow$ 乳头体: $A_{0,1} = w_{\\mathrm{HPC}\\rightarrow\\mathrm{MB}}$。\n   - 乳头体 $\\rightarrow$ 丘脑前核: $A_{1,2} = w_{\\mathrm{MB}\\rightarrow\\mathrm{ATN}}$。\n   - 丘脑前核 $\\rightarrow$ 扣带回: $A_{2,3} = w_{\\mathrm{ATN}\\rightarrow\\mathrm{CG}}$。\n   - 扣带回 $\\rightarrow$ 内嗅皮层: $A_{3,4} = w_{\\mathrm{CG}\\rightarrow\\mathrm{EC}}$。\n   - 内嗅皮层 $\\rightarrow$ 海马体: $A_{4,0} = w_{\\mathrm{EC}\\rightarrow\\mathrm{HPC}}$。\n   - 海马体 $\\rightarrow$ 丘脑前核 (侧支): $A_{0,2} = w_{\\mathrm{HPC}\\rightarrow\\mathrm{ATN}}$。\n2. 对每个测试用例，计算更新规则 $x_{t+1} = \\alpha A^\\top x_t + u$ 的基线不动点 $x^\\ast_{\\mathrm{base}}$，其中 $u = [s, 0, 0, 0, 0]^\\top$，$s$ 是注入海马体的标量输入大小。不要使用任何未声明的快捷公式；您的程序可以通过任何遵循基本原理的正确方法（例如，模拟迭代直到收敛）来找到 $x^\\ast_{\\mathrm{base}}$。\n3. 通过移除边 乳头体 $\\rightarrow$ 丘脑前核 来模拟乳头丘脑束的中断，即设置 $A_{1,2} = 0$ 并为相同的 $A$、$\\alpha$ 和 $u$ 重新计算不动点 $x^\\ast_{\\mathrm{disrupt}}$。\n4. 对每个测试用例，计算丘脑前核、扣带回和内嗅皮层的下游部分缺损，公式为 $\\left[(x^\\ast_{\\mathrm{base}}[2] - x^\\ast_{\\mathrm{disrupt}}[2]) / x^\\ast_{\\mathrm{base}}[2], (x^\\ast_{\\mathrm{base}}[3] - x^\\ast_{\\mathrm{disrupt}}[3]) / x^\\ast_{\\mathrm{base}}[3], (x^\\ast_{\\mathrm{base}}[4] - x^\\ast_{\\mathrm{disrupt}}[4]) / x^\\ast_{\\mathrm{base}}[4]\\right]$。将这些量表示为小数（而非百分比）。\n\n测试套件：\n每个测试用例是一个形式为 $\\left(w_{\\mathrm{HPC}\\rightarrow\\mathrm{MB}}, w_{\\mathrm{MB}\\rightarrow\\mathrm{ATN}}, w_{\\mathrm{ATN}\\rightarrow\\mathrm{CG}}, w_{\\mathrm{CG}\\rightarrow\\mathrm{EC}}, w_{\\mathrm{EC}\\rightarrow\\mathrm{HPC}}, w_{\\mathrm{HPC}\\rightarrow\\mathrm{ATN}}, \\alpha, s\\right)$ 的元组。\n- 用例 $1$ (具有典型权重的正常路径): $\\left(0.9, 0.8, 0.85, 0.7, 0.6, 0.1, 0.4, 1.0\\right)$。\n- 用例 $2$ (乳头丘脑束基线较弱的边界情况): $\\left(0.9, 0.05, 0.85, 0.7, 0.6, 0.2, 0.4, 1.0\\right)$。\n- 用例 $3$ (海马体 $\\rightarrow$ 丘脑前核侧支较强的边缘情况): $\\left(0.9, 0.8, 0.85, 0.9, 0.6, 0.5, 0.4, 1.0\\right)$。\n- 用例 $4$ (在内嗅皮层 $\\rightarrow$ 海马体处中断循环的边缘情况): $\\left(0.9, 0.8, 0.85, 0.7, 0.0, 0.0, 0.4, 1.0\\right)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个顶级列表，每个测试用例对应一个条目，并按顺序排列。每个条目必须是包含三个小数的列表，分别对应丘脑前核、扣带回和内嗅皮层的部分缺损。该行必须严格遵循格式 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$，其中每个 $\\text{result}_i$ 是一个Python风格的列表。例如：$\\left[[d_{1,ATN}, d_{1,CG}, d_{1,EC}], [d_{2,ATN}, d_{2,CG}, d_{2,EC}], [d_{3,ATN}, d_{3,CG}, d_{3,EC}], [d_{4,ATN}, d_{4,CG}, d_{4,EC}]\\right]$。不涉及物理单位。", "solution": "问题的核心是找到线性系统的不动点 $x^\\ast$。不动点条件由以下方程给出：\n$$x^\\ast = \\alpha A^\\top x^\\ast + u$$\n其中 $x^\\ast \\in \\mathbb{R}^n$ 是不动点激活向量，$A \\in \\mathbb{R}^{n \\times n}$ 是 $n=5$ 个节点的邻接矩阵，$\\alpha$ 是传播因子，$u \\in \\mathbb{R}^n$ 是外部输入向量。\n\n这个方程可以重排为一个标准的线性方程组：\n$$I x^\\ast - \\alpha A^\\top x^\\ast = u$$\n$$(I - \\alpha A^\\top) x^\\ast = u$$\n此处，$I$ 是 $n \\times n$ 的单位矩阵。问题指出条件 $0 \\le \\alpha  1/\\rho(A)$ 成立，这确保了 $\\alpha A^\\top$ 的谱半径小于 $1$。这保证了矩阵 $(I - \\alpha A^\\top)$ 是可逆的，因此存在唯一的解 $x^\\ast$。该解可以通过求解这个关于 $x^\\ast$ 的线性系统得到。\n$$x^\\ast = (I - \\alpha A^\\top)^{-1} u$$\n在计算上，使用数值线性代数求解器求解形如 $Mx=b$ 的系统是最有效和最准确的方法，其中 $M = (I - \\alpha A^\\top)$ 且 $b = u$。\n\n每个测试用例的步骤如下：\n\n1.  **构建矩阵和向量**：对于每个测试用例元组 $(w_{\\mathrm{HPC}\\rightarrow\\mathrm{MB}}, w_{\\mathrm{MB}\\rightarrow\\mathrm{ATN}}, w_{\\mathrm{ATN}\\rightarrow\\mathrm{CG}}, w_{\\mathrm{CG}\\rightarrow\\mathrm{EC}}, w_{\\mathrm{EC}\\rightarrow\\mathrm{HPC}}, w_{\\mathrm{HPC}\\rightarrow\\mathrm{ATN}}, \\alpha, s)$，我们首先构建基线邻接矩阵 $A_{\\mathrm{base}}$。节点索引为海马体 ($0$)、乳头体 ($1$)、丘脑前核 ($2$)、扣带回 ($3$) 和内嗅皮层 ($4$)。$5 \\times 5$ 的矩阵 $A_{\\mathrm{base}}$ 填充如下：\n    $$\n    A_{\\mathrm{base}} = \\begin{pmatrix}\n    0   w_{\\mathrm{HPC}\\rightarrow\\mathrm{MB}}  w_{\\mathrm{HPC}\\rightarrow\\mathrm{ATN}}  0  0 \\\\\n    0   0  w_{\\mathrm{MB}\\rightarrow\\mathrm{ATN}}  0  0 \\\\\n    0   0  0  w_{\\mathrm{ATN}\\rightarrow\\mathrm{CG}}  0 \\\\\n    0   0  0  0  w_{\\mathrm{CG}\\rightarrow\\mathrm{EC}} \\\\\n    w_{\\mathrm{EC}\\rightarrow\\mathrm{HPC}}  0  0  0  0\n    \\end{pmatrix}\n    $$\n    输入向量为 $u = [s, 0, 0, 0, 0]^\\top$。\n\n2.  **计算基线不动点 ($x^\\ast_{\\mathrm{base}}$)**：我们构建线性系统矩阵 $M_{\\mathrm{base}} = (I - \\alpha A_{\\mathrm{base}}^\\top)$ 并求解方程 $M_{\\mathrm{base}} x = u$ 以得到 $x$。解即为基线不动点向量 $x^\\ast_{\\mathrm{base}}$。\n\n3.  **模拟中断**：通过取 $A_{\\mathrm{base}}$ 并将乳头丘脑束对应的条目设为零来创建中断邻接矩阵 $A_{\\mathrm{disrupt}}$：$(A_{\\mathrm{disrupt}})_{1,2} = 0$。\n\n4.  **计算中断不动点 ($x^\\ast_{\\mathrm{disrupt}}$)**：我们构建一个新的系统矩阵 $M_{\\mathrm{disrupt}} = (I - \\alpha A_{\\mathrm{disrupt}}^\\top)$ 并求解 $M_{\\mathrm{disrupt}} x = u$。解即为中断不动点向量 $x^\\ast_{\\mathrm{disrupt}}$。\n\n5.  **计算部分缺损**：对于感兴趣的三个下游节点（丘脑前核，索引 $2$；扣带回，索引 $3$；内嗅皮层，索引 $4$），使用以下公式计算其部分缺损：\n    $$d_i = \\frac{x^\\ast_{\\mathrm{base}}[i] - x^\\ast_{\\mathrm{disrupt}}[i]}{x^\\ast_{\\mathrm{base}}[i]}$$ 对于 $i \\in \\{2, 3, 4\\}$。\n\n该模型的一个关键特性是，从节点 $2$ 到 $3$ 以及从节点 $3$ 到 $4$ 的连接形成一个简单的链。不动点激活值之间存在关系 $x^\\ast[3] = c_{23} x^\\ast[2]$ 和 $x^\\ast[4] = c_{34} x^\\ast[3]$，其中常数 $c_{23}$ 和 $c_{34}$ 取决于 $\\alpha$ 和各自的边权重，但在基线系统和中断系统中是相同的。因此，所有三个节点的部分缺损将是相同的：$d_2 = d_3 = d_4$。这是因为在这个线性链结构中，节点 $2$ 激活的任何百分比变化都会以相同的百分比变化传播到节点 $3$ 和 $4$。\n\n对于用例 $4$，侧支路径 $w_{\\mathrm{HPC}\\rightarrow\\mathrm{ATN}}$ 为零，并且主循环在 $w_{\\mathrm{EC}\\rightarrow\\mathrm{HPC}}=0$ 处断开。激活到达节点 $2$、$3$ 和 $4$ 的唯一路径是通过乳头丘脑束 ($0 \\rightarrow 1 \\rightarrow 2 \\rightarrow \\dots$)。当通过设置 $(A_{\\mathrm{disrupt}})_{1,2}=0$ 来中断此束时，从节点 $0$ 的输入到节点 $2$、$3$ 或 $4$ 不再有任何路径。因此，它们的激活值 $x^\\ast_{\\mathrm{disrupt}}[2]$、$x^\\ast_{\\mathrm{disrupt}}[3]$ 和 $x^\\ast_{\\mathrm{disrupt}}[4]$ 变为零，导致所有三个节点的部分缺损均为 $1.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the impact of mammillothalamic tract disruption in a model of the Papez circuit.\n    \"\"\"\n    # Each test case is a tuple of the form:\n    # (w_HPC-MB, w_MB-ATN, w_ATN-CG, w_CG-EC, w_EC-HPC, w_HPC-ATN, alpha, s)\n    test_cases = [\n        (0.9, 0.8, 0.85, 0.7, 0.6, 0.1, 0.4, 1.0),\n        (0.9, 0.05, 0.85, 0.7, 0.6, 0.2, 0.4, 1.0),\n        (0.9, 0.8, 0.85, 0.9, 0.6, 0.5, 0.4, 1.0),\n        (0.9, 0.8, 0.85, 0.7, 0.0, 0.0, 0.4, 1.0),\n    ]\n\n    all_results = []\n    n_nodes = 5\n\n    for case in test_cases:\n        w_hpc_mb, w_mb_atn, w_atn_cg, w_cg_ec, w_ec_hpc, w_hpc_atn, alpha, s = case\n\n        # 1. Construct the baseline adjacency matrix A_base\n        A_base = np.zeros((n_nodes, n_nodes))\n        # Node indices: HPC=0, MB=1, ATN=2, CG=3, EC=4\n        A_base[0, 1] = w_hpc_mb   # HPC - MB\n        A_base[1, 2] = w_mb_atn    # MB - ATN (mammillothalamic tract)\n        A_base[2, 3] = w_atn_cg    # ATN - CG\n        A_base[3, 4] = w_cg_ec     # CG - EC\n        A_base[4, 0] = w_ec_hpc    # EC - HPC\n        A_base[0, 2] = w_hpc_atn   # HPC - ATN (collateral)\n\n        # Define the input vector u\n        u = np.zeros(n_nodes)\n        u[0] = s # Input to hippocampus\n\n        # 2. Compute the baseline fixed point x_base\n        # Equation to solve: (I - alpha * A.T) @ x = u\n        M_base = np.eye(n_nodes) - alpha * A_base.T\n        x_base = np.linalg.solve(M_base, u)\n\n        # 3. Simulate disruption and compute the new fixed point x_disrupt\n        A_disrupt = A_base.copy()\n        A_disrupt[1, 2] = 0.0  # Remove mammillothalamic tract\n\n        # 4. Compute the disrupted fixed point x_disrupt\n        M_disrupt = np.eye(n_nodes) - alpha * A_disrupt.T\n        x_disrupt = np.linalg.solve(M_disrupt, u)\n\n        # 5. Compute the fractional downstream deficits\n        # Indices of interest: ATN=2, CG=3, EC=4\n        indices_of_interest = [2, 3, 4]\n        deficits = []\n        for i in indices_of_interest:\n            # Handle potential division by zero, although problem setup avoids this.\n            if x_base[i] == 0:\n                # If baseline is 0, deficit is undefined unless disruption is also 0.\n                deficit = 0.0 if x_disrupt[i] == 0 else np.nan\n            else:\n                deficit = (x_base[i] - x_disrupt[i]) / x_base[i]\n            deficits.append(deficit)\n        \n        all_results.append(deficits)\n\n    # Format and print the final output as a single line\n    # Example format: [[d1, d2, d3], [d4, d5, d6]]\n    # This custom formatter avoids extra spaces that default list printing might add.\n    result_str = '[' + ','.join(f\"[{','.join(map(str, res))}]\" for res in all_results) + ']'\n    print(result_str)\n\nsolve()\n```", "id": "4490045"}, {"introduction": "虽然稳态模型在分析网络功能方面很有用，但许多重要的神经系统现象（如癫痫发作）本质上是动态演变的。这个高级练习将指导你使用常微分方程组，建立一个模拟边缘系统内癫痫活动扩散的动态模型[@problem_id:4490018]。通过模拟一个区域的局灶性活动如何随时间扩散到其他相连的脑区，这项实践让你亲身体验用于理解复杂脑疾病时空动态模式的计算方法，为研究网络病理学提供了坚实的基础。", "problem": "您的任务是构建一个关于边缘网络中局灶性癫痫扩散的计算模型，该模型基于 Papez 回路和紧密相关的边缘区域的解剖结构。该网络必须包括海马体、内嗅皮层、杏仁核和丘脑前核。该模型必须从神经元群体动力学和解剖学连接的第一性原理推导得出，并实现为一个程序，以预测局灶性癫痫发作期间每个区域的激活时间。\n\n基本和建模的基本假设：\n- 癫痫发作的起始是在神经元群体的尺度上建模的，其原理是每个区域的群体活动根据一个速率方程演化。设区域中的活动由状态向量 $\\mathbf{x}(t) \\in \\mathbb{R}^4$ 表示，其分量分别为海马体、内嗅皮层、杏仁核和丘脑前核的 $x_{H}(t)$、$x_{EC}(t)$、$x_{A}(t)$ 和 $x_{ATN}(t)$。\n- 在发作起始点附近，群体速率动力学通过一个基于有效连接和泄漏的线性化连续时间系统来近似：\n$$\n\\frac{d\\mathbf{x}(t)}{dt} = \\left(\\mathbf{W} - \\lambda \\mathbf{I}\\right)\\mathbf{x}(t),\n$$\n其中 $\\mathbf{W}$ 是一个有向有效连接矩阵，该矩阵是根据 Papez 回路（及其边缘系统扩展）中已确立的解剖学通路推断出来的，$\\lambda$ 是一个均匀的局部衰减（泄漏）常数，代表突触和神经元的松弛，$\\mathbf{I}$ 是单位矩阵。当非线性增益可以进行局部线性化时，这种近似方法是分析神经元集群模型中不稳定性和初始扩散的标准方法。\n- 解剖学基础：Papez 回路建立了一个从海马体经由穹窿到乳头体，再到丘脑前核，到扣带回，到内嗅皮层，最后回到海马体的环路。内嗅皮层为海马体提供主要输入，杏仁核与海马体和内嗅皮层进行双向交互。丘脑前核投射到扣带皮层，并且是能够影响内嗅-海马交互的边缘环路的一部分。这些事实为所建模的四个节点的 $\\mathbf{W}$ 矩阵的非零项提供了依据。\n\n激活标准和输出：\n- 当一个区域的活动超过指定的阈值 $\\theta$ 时，即对于区域 $i$，首次满足 $x_{i}(t) \\ge \\theta$ 的时间 $t$，该区域被认为已激活。如果 $x_{i}(0) \\ge \\theta$，其激活时间定义为 $0$。\n- 如果一个区域在最大模拟时间 $T_{\\max}$ 内未能达到阈值，则报告该区域的激活时间为 $-1.0$。\n- 所有时间必须以秒为单位报告。每个测试用例的输出必须是一个包含四个激活时间的列表，按 $\\left[x_{H}, x_{EC}, x_{A}, x_{ATN}\\right]$ 激活时间的顺序排列。\n\n数值方法要求：\n- 使用固定时间步长 $\\Delta t$ 的前向欧拉法进行数值积分，更新规则如下：\n$$\n\\mathbf{x}(t+\\Delta t) = \\mathbf{x}(t) + \\Delta t \\left(\\mathbf{W} - \\lambda \\mathbf{I}\\right)\\mathbf{x}(t).\n$$\n- 为了提高时间精度，如果某个分量 $x_{i}(t)$ 在 $t$ 和 $t+\\Delta t$ 之间越过 $\\theta$，则通过线性插值估计穿越时间：\n$$\nt_{\\mathrm{cross},i} = t + \\Delta t \\cdot \\frac{\\theta - x_{i}(t)}{x_{i}(t+\\Delta t) - x_{i}(t)}.\n$$\n- 由于群体放电率是非负的，在每一步通过将负值钳制为 $0$ 来强制活动的非负性。\n\n初始化：\n- 初始条件为局灶性起始：对于焦点节点，$x_{i}(0) = a_{0}$，对于所有 $j \\neq i$，$x_{j}(0) = 0$，其中 $a_{0} = 1.0$。\n\n连接性规范：\n- 使用区域排序 $\\left[H, EC, A, ATN\\right]$，并将 $\\mathbf{W}$ 定义为一个 $4 \\times 4$ 矩阵，其元素 $W_{pq}$ 表示从源 $q$ 到目标 $p$ 的影响。非零元素反映了与 Papez 回路和边缘系统连接一致的解剖学通路：\n    - 内嗅皮层到海马体：$W_{H,EC}$ 是非零且相对较强。\n    - 海马体到内嗅皮层：$W_{EC,H}$ 是非零的。\n    - 海马体到丘脑前核：$W_{ATN,H}$ 是非零的（通过穹窿和乳头体的有效通路）。\n    - 丘脑前核到内嗅皮层：$W_{EC,ATN}$ 是非零的（通过扣带回到内嗅皮层的有效边缘环路交互）。\n    - 杏仁核到海马体：$W_{H,A}$ 是非零的。\n    - 海马体到杏仁核：$W_{A,H}$ 是非零的。\n    - 内嗅皮层到杏仁核：$W_{A,EC}$ 是非零的。\n    - 杏仁核到内嗅皮层：$W_{EC,A}$ 是非零的。\n    - 弱的丘脑前核到海马体：$W_{H,ATN}$ 可以是非零的，以反映间接的环路效应。\n\n测试套件：\n实现该模型并计算以下参数集的激活时间。对于每种情况，报告一个包含四个浮点数的列表 $\\left[t_{H}, t_{EC}, t_{A}, t_{ATN}\\right]$，单位为秒。\n\n- 情况 1（理想路径，海马体焦点）：\n    - $\\mathbf{W}$ 非零项：\n        - $W_{H,EC} = 0.8$, $W_{H,A} = 0.3$, $W_{H,ATN} = 0.1$\n        - $W_{EC,H} = 0.6$, $W_{EC,A} = 0.2$, $W_{EC,ATN} = 0.2$\n        - $W_{A,H} = 0.4$, $W_{A,EC} = 0.35$, $W_{A,ATN} = 0.1$\n        - $W_{ATN,H} = 0.5$, $W_{ATN,EC} = 0.2$, $W_{ATN,A} = 0.1$\n      所有对角线元素均为 $0$。\n    - $\\lambda = 0.4$, $\\theta = 0.6$, $a_{0} = 1.0$, $\\Delta t = 0.001$, $T_{\\max} = 5.0$。\n    - 焦点节点：海马体 ($H$)。\n\n- 情况 2（内嗅皮层焦点，更高的泄漏和阈值）：\n    - $\\mathbf{W}$ 如情况 1 所示。\n    - $\\lambda = 0.5$, $\\theta = 0.7$, $a_{0} = 1.0$, $\\Delta t = 0.001$, $T_{\\max} = 4.0$。\n    - 焦点节点：内嗅皮层 ($EC$)。\n\n- 情况 3（杏仁核焦点，强泄漏限制扩散）：\n    - $\\mathbf{W}$ 如情况 1 所示。\n    - $\\lambda = 1.2$, $\\theta = 0.5$, $a_{0} = 1.0$, $\\Delta t = 0.001$, $T_{\\max} = 3.0$。\n    - 焦点节点：杏仁核 ($A$)。\n\n- 情况 4（海马体焦点，增强的丘脑耦合）：\n    - $\\mathbf{W}$ 非零项：\n        - $W_{H,EC} = 0.8$, $W_{H,A} = 0.3$, $W_{H,ATN} = 0.15$\n        - $W_{EC,H} = 0.6$, $W_{EC,A} = 0.2$, $W_{EC,ATN} = 0.6$\n        - $W_{A,H} = 0.4$, $W_{A,EC} = 0.35$, $W_{A,ATN} = 0.1$\n        - $W_{ATN,H} = 0.9$, $W_{ATN,EC} = 0.6$, $W_{ATN,A} = 0.1$\n      所有对角线元素均为 $0$。\n    - $\\lambda = 0.3$, $\\theta = 0.65$, $a_{0} = 1.0$, $\\Delta t = 0.001$, $T_{\\max} = 3.0$。\n    - 焦点节点：海马体 ($H$)。\n\n程序输出规范：\n- 您的程序应生成单行输出，其中包含一个由逗号分隔的四项列表组成的列表，按情况 1 到 4 的顺序排列，并用方括号括起来。例如，输出应如下所示：\n$[\\,[t_{H,1},t_{EC,1},t_{A,1},t_{ATN,1}],\\,[t_{H,2},t_{EC,2},t_{A,2},t_{ATN,2}],\\,[t_{H,3},t_{EC,3},t_{A,3},t_{ATN,3}],\\,[t_{H,4},t_{EC,4},t_{ATN,4}]\\,]$,\n所有时间均以秒为单位，每个时间都打印为浮点数。如果在 $T_{\\max}$ 内未达到阈值，则为该区域打印 $-1.0$。", "solution": "该问题提出了一个计算神经科学领域中有效且良定的任务。它要求在一个指定的边缘网络中实现一个简化的局灶性癫痫传播模型。该模型基于一个代表神经元群体动力学的线性常微分方程组。所提供的参数、初始条件和数值方法是完整、一致的，并且在科学上基于标准的建模实践。因此，可以推导出一个解。\n\n### 理论框架\n\n该模型描述了四个相互连接的大脑区域中活动的时间演化：海马体（$H$）、内嗅皮层（$EC$）、杏仁核（$A$）和丘脑前核（$ATN$）。系统在时间 $t$ 的状态由活动向量 $\\mathbf{x}(t) \\in \\mathbb{R}^4$ 给出，其中分量 $x_0(t), x_1(t), x_2(t), x_3(t)$ 分别代表 $H, EC, A, ATN$ 的活动。\n\n动力学由一个线性化的连续时间系统控制：\n$$\n\\frac{d\\mathbf{x}(t)}{dt} = \\left(\\mathbf{W} - \\lambda \\mathbf{I}\\right)\\mathbf{x}(t)\n$$\n在这里，$\\mathbf{W}$ 是一个 $4 \\times 4$ 的有效连接矩阵，其中元素 $W_{pq}$ 量化了源区域 $q$ 对目标区域 $p$ 的影响。$\\lambda$ 是一个标量，表示每个区域中活动衰减或泄漏的统一速率，而 $\\mathbf{I}$ 是 $4 \\times 4$ 的单位矩阵。矩阵 $\\mathbf{A} = \\mathbf{W} - \\lambda \\mathbf{I}$ 是系统矩阵，它决定了区域间增长、衰减和相互作用的整体动力学。\n\n### 数值求解方法\n\n为了求解这个常微分方程组，问题指定使用前向欧拉法，这是一种一阶数值方法。给定一个离散的时间步长 $\\Delta t$，系统在时间 $t_{k+1} = t_k + \\Delta t$ 的状态可以从时间 $t_k$ 的状态通过以下更新规则来近似：\n$$\n\\mathbf{x}(t_k + \\Delta t) = \\mathbf{x}(t_k) + \\Delta t \\left(\\mathbf{W} - \\lambda \\mathbf{I}\\right)\\mathbf{x}(t_k)\n$$\n为了计算效率，这可以表示为矩阵-向量乘法：\n$$\n\\mathbf{x}_{k+1} = \\left(\\mathbf{I} + \\Delta t \\left(\\mathbf{W} - \\lambda \\mathbf{I}\\right)\\right) \\mathbf{x}_k = \\mathbf{M} \\mathbf{x}_k\n$$\n其中 $\\mathbf{x}_k = \\mathbf{x}(t_k)$，更新矩阵 $\\mathbf{M} = \\mathbf{I} + \\Delta t(\\mathbf{W} - \\lambda \\mathbf{I})$ 可以预先计算。\n\n模拟受到几个附加条件的约束：\n\n1.  **非负性：** 由于群体活动不能为负，状态向量的任何分量 $x_i$ 在更新步骤后变为负值时，都会被钳制为 $0$。\n\n2.  **激活标准：** 当区域 $i$ 的活动 $x_i(t)$ 首次达到或超过给定阈值 $\\theta$ 时，该区域被视为“已激活”。此事件发生的时间是其激活时间 $t_i$。如果一个区域的初始活动 $x_i(0)$ 已经达到或高于 $\\theta$，其激活时间为 $t=0$。如果一个区域的活动在最大模拟时间 $T_{\\max}$ 之前没有达到 $\\theta$，其激活时间报告为 $-1.0$。\n\n3.  **时间插值：** 为了提高激活时间的估计精度，当检测到区域 $i$ 在时间 $t$ 和 $t + \\Delta t$ 之间发生阈值穿越（即 $x_i(t)  \\theta$ 且 $x_i(t+\\Delta t) \\ge \\theta$）时，使用线性插值计算精确的穿越时间：\n    $$\n    t_{\\mathrm{cross},i} = t + \\Delta t \\cdot \\frac{\\theta - x_{i}(t)}{x_{i}(t+\\Delta t) - x_{i}(t)}\n    $$\n\n### 算法实现\n\n该解决方案实现为一个数值模拟，对每个测试用例按以下步骤进行：\n\n1.  **初始化：**\n    *   设置特定案例的参数（$\\mathbf{W}, \\lambda, \\theta, a_0, \\Delta t, T_{\\max}$, 焦点节点）。索引映射为：$H \\to 0, EC \\to 1, A \\to 2, ATN \\to 3$。\n    *   状态向量 $\\mathbf{x}$ 初始化为全零，但焦点节点除外，其初始活动设置为 $x_{focus}(0) = a_0 = 1.0$。\n    *   初始化一个数组 `activation_times` 以保存结果，每个元素都设置为 $-1.0$。\n    *   检查初始状态。对于焦点节点，由于在所有情况下 $a_0 = 1.0$ 且 $\\theta  1.0$，其激活时间立即设置为 $0.0$。\n\n2.  **时间演化循环：**\n    *   预先计算更新矩阵 $\\mathbf{M}$。\n    *   模拟从 $t=0$ 迭代到 $T_{\\max}$，步长为 $\\Delta t$。步数为 $N = \\lfloor T_{\\max} / \\Delta t \\rfloor$。\n    *   在每次迭代中，使用上一步的状态向量 $\\mathbf{x}_{\\mathrm{prev}}$ 来计算新状态 $\\mathbf{x}_{\\mathrm{next}} = \\mathbf{M} \\mathbf{x}_{\\mathrm{prev}}$。\n    *   应用非负性约束：将 $\\mathbf{x}_{\\mathrm{next}}$ 的所有负分量设置为 $0$。\n    *   对于每个尚未激活的区域 $i$（`activation_times[i] == -1.0`），模拟检查是否发生了阈值穿越（$x_{i, \\mathrm{prev}}  \\theta$ 且 $x_{i, \\mathrm{next}} \\geq \\theta$）。\n    *   如果检测到穿越，则使用上述公式计算插值激活时间，并将其存储在 `activation_times[i]` 中。\n    *   为下一次迭代更新状态向量：$\\mathbf{x}_{\\mathrm{prev}} = \\mathbf{x}_{\\mathrm{next}}$。\n\n3.  **输出：** 循环结束后，`activation_times` 数组包含计算出的四个区域的激活时间，然后收集这些时间以供最终打印。对所有指定的测试用例重复此过程。\n\n以下 Python 代码实现了此算法以解决该问题。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the seizure spread problem for all test cases.\n    \"\"\"\n\n    # Helper function to run the simulation for a single case\n    def run_simulation(W, lam, theta, a0, dt, T_max, focus_idx):\n        \"\"\"\n        Runs the forward Euler simulation for one set of parameters.\n\n        Args:\n            W (np.ndarray): The 4x4 connectivity matrix.\n            lam (float): The leak constant.\n            theta (float): The activation threshold.\n            a0 (float): The initial activity at the focus node.\n            dt (float): The time step for integration.\n            T_max (float): The maximum simulation time.\n            focus_idx (int): The index of the focus node (0-3).\n\n        Returns:\n            list[float]: A list of activation times for [H, EC, A, ATN].\n        \"\"\"\n        num_regions = 4\n        \n        # Initialize state vector x(t)\n        x = np.zeros(num_regions, dtype=np.float64)\n        x[focus_idx] = a0\n\n        # Initialize activation times array with -1.0\n        activation_times = [-1.0] * num_regions\n\n        # Check for activation at t=0\n        for i in range(num_regions):\n            if x[i] = theta:\n                activation_times[i] = 0.0\n\n        # Pre-compute the update matrix for efficiency\n        # M = I + dt * (W - lambda*I)\n        I = np.identity(num_regions)\n        update_matrix = I + dt * (W - lam * I)\n        \n        num_steps = int(T_max / dt)\n        current_time = 0.0\n\n        for step in range(num_steps):\n            x_prev = x.copy()\n            x = update_matrix @ x_prev\n\n            # Enforce non-negativity of activities\n            x[x  0] = 0.0\n            \n            # Check for threshold crossings\n            for i in range(num_regions):\n                # Only process if not already activated\n                if activation_times[i] == -1.0:\n                    if x_prev[i]  theta and x[i] = theta:\n                        # Denominator for interpolation could be zero if x[i] lands exactly on theta.\n                        # This is unlikely with float arithmetic but good to handle.\n                        denominator = x[i] - x_prev[i]\n                        if denominator  1e-9: # a small epsilon to avoid division by zero\n                            # Linearly interpolate to find the crossing time\n                            t_cross = current_time + dt * (theta - x_prev[i]) / denominator\n                            activation_times[i] = t_cross\n                        else:\n                            # If denominator is tiny, activity jump is vertical or tiny.\n                            # Assigning the end of the interval is a reasonable choice.\n                            activation_times[i] = current_time + dt\n            \n            current_time += dt\n\n            # Optional: stop if all regions are activated\n            if all(t != -1.0 for t in activation_times):\n                break\n                \n        return activation_times\n\n    # --- Define Test Cases ---\n\n    region_map = {'H': 0, 'EC': 1, 'A': 2, 'ATN': 3}\n\n    # Case 1, 2, 3 use the same W matrix\n    W1 = np.zeros((4, 4))\n    W1[region_map['H'], region_map['EC']] = 0.8\n    W1[region_map['H'], region_map['A']] = 0.3\n    W1[region_map['H'], region_map['ATN']] = 0.1\n    W1[region_map['EC'], region_map['H']] = 0.6\n    W1[region_map['EC'], region_map['A']] = 0.2\n    W1[region_map['EC'], region_map['ATN']] = 0.2\n    W1[region_map['A'], region_map['H']] = 0.4\n    W1[region_map['A'], region_map['EC']] = 0.35\n    W1[region_map['A'], region_map['ATN']] = 0.1\n    W1[region_map['ATN'], region_map['H']] = 0.5\n    W1[region_map['ATN'], region_map['EC']] = 0.2\n    W1[region_map['ATN'], region_map['A']] = 0.1\n\n    # Case 4 uses a different W matrix\n    W4 = np.zeros((4, 4))\n    W4[region_map['H'], region_map['EC']] = 0.8\n    W4[region_map['H'], region_map['A']] = 0.3\n    W4[region_map['H'], region_map['ATN']] = 0.15\n    W4[region_map['EC'], region_map['H']] = 0.6\n    W4[region_map['EC'], region_map['A']] = 0.2\n    W4[region_map['EC'], region_map['ATN']] = 0.6\n    W4[region_map['A'], region_map['H']] = 0.4\n    W4[region_map['A'], region_map['EC']] = 0.35\n    W4[region_map['A'], region_map['ATN']] = 0.1\n    W4[region_map['ATN'], region_map['H']] = 0.9\n    W4[region_map['ATN'], region_map['EC']] = 0.6\n    W4[region_map['ATN'], region_map['A']] = 0.1\n\n    test_cases = [\n        # (W, lambda, theta, a0, dt, T_max, focus_node_str)\n        {'W': W1, 'lam': 0.4, 'theta': 0.6,  'a0': 1.0, 'dt': 0.001, 'T_max': 5.0, 'focus': 'H'},\n        {'W': W1, 'lam': 0.5, 'theta': 0.7,  'a0': 1.0, 'dt': 0.001, 'T_max': 4.0, 'focus': 'EC'},\n        {'W': W1, 'lam': 1.2, 'theta': 0.5,  'a0': 1.0, 'dt': 0.001, 'T_max': 3.0, 'focus': 'A'},\n        {'W': W4, 'lam': 0.3, 'theta': 0.65, 'a0': 1.0, 'dt': 0.001, 'T_max': 3.0, 'focus': 'H'}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        focus_idx = region_map[case['focus']]\n        result = run_simulation(\n            case['W'],\n            case['lam'],\n            case['theta'],\n            case['a0'],\n            case['dt'],\n            case['T_max'],\n            focus_idx\n        )\n        all_results.append(result)\n\n    # Format the final output string as per requirements\n    # e.g., [[t11,t12,...],[t21,t22,...],...]\n    result_str = ','.join(map(str, all_results))\n    print(f\"[{result_str}]\")\n\n\nsolve()\n\n```", "id": "4490018"}]}