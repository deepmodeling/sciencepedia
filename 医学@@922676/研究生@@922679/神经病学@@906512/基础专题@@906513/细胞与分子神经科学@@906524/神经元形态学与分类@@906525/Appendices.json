{"hands_on_practices": [{"introduction": "树突分支是神经元收集和整合信息方式的基础。跨分支点的信号传输效率取决于阻抗匹配，而Wilfrid Rall的研究表明，在某些理想条件下，这种电学约束意味着母分枝与子分枝的直径之间存在一个简单的几何关系。这个练习将要求你从第一性原理出发推导这个经典的$3/2$次幂法则，从而巩固你对神经元物理结构（形态学）与其电功能（计算）之间联系的理解。[@problem_id:4508610]", "problem": "在一个由电缆理论建模的无源树突树中，其比膜电阻率 $R_{m}$ 和胞内（轴向）电阻率 $R_{i}$ 在空间上是均匀的。在分叉点的形态计量学约束可以从以下要求推导得出：该分叉点是阻抗匹配的，这样就不会发生反射，并且电紧张长度在连接处得以保持。\n\n从单位长度轴向电阻和单位长度膜电阻的基本电缆定义出发，推导在树突分叉处，一个直径为 $d_{0}$ 的母分支与两个直径分别为 $d_{1}$ 和 $d_{2}$ 的子分支之间实现阻抗匹配的直径关系。假设每个分支在连接点附近局部可被视为半无限长，并且膜特性是均匀的。\n\n现给定一个在皮层锥体神经元顶端树突上测得的特定分叉，其母分支直径为 $d_{0} = 3.0\\,\\mu\\text{m}$，子分支直径分别为 $d_{1} = 2.5\\,\\mu\\text{m}$ 和 $d_{2} = 1.2\\,\\mu\\text{m}$。使用您推导出的关系，计算与精确阻抗匹配条件的绝对分数偏差，其定义为\n$$\\varepsilon \\equiv \\frac{\\left|\\,f(d_{1},d_{2}) - f(d_{0})\\,\\right|}{f(d_{0})},$$\n其中 $f(\\cdot)$ 是您推导的阻抗匹配条件所隐含的与直径相关的量。以小数形式报告 $\\varepsilon$（例如，对于百分之五的偏差，报告为 $0.05$）。将您的答案四舍五入到四位有效数字。最终报告值中不要包含任何单位或百分号。", "solution": "该问题要求推导在树突分叉处实现阻抗匹配的直径关系，并计算一个特定情况下的分数偏差。\n\n### 第1部分：直径关系的推导\n\n该问题是在应用于树突树的无源电缆理论的背景下提出的。我们已知比膜电阻率 $R_m$（单位 $\\Omega \\cdot \\text{m}^2$）和比胞内（轴向）电阻率 $R_i$（单位 $\\Omega \\cdot \\text{m}$）在空间上是均匀的。\n\n首先，我们必须为直径为 $d$ 的圆柱形树突定义相关的电学特性。\n单位长度的轴向电阻 $r_a$ 是胞内电阻率 $R_i$ 除以横截面积 $A = \\pi (d/2)^2$。\n$$r_a = \\frac{R_i}{A} = \\frac{R_i}{\\pi (d/2)^2} = \\frac{4 R_i}{\\pi d^2}$$\n单位长度圆柱体的膜电阻 $r_m$ 是比膜电阻率 $R_m$ 除以圆柱体的周长 $\\pi d$。\n$$r_m = \\frac{R_m}{\\pi d}$$\n问题陈述，在分叉处的每个分支局部可被视为一个半无限长的电缆。对于半无限长的无源电缆，其直流或稳态输入电阻 $R_{in}$ 由电缆的特征电阻给出：\n$$R_{in} = \\sqrt{r_a r_m}$$\n将 $r_a$ 和 $r_m$ 的表达式用直径 $d$ 代入：\n$$R_{in}(d) = \\sqrt{\\left(\\frac{4 R_i}{\\pi d^2}\\right) \\left(\\frac{R_m}{\\pi d}\\right)} = \\sqrt{\\frac{4 R_i R_m}{\\pi^2 d^3}} = \\frac{2}{\\pi} \\sqrt{\\frac{R_i R_m}{d^3}}$$\n分叉点的阻抗匹配条件是无反射。当母分支的输入电导等于子分支的输入电导之和时，即可实现此条件。输入电导 $G_{in}$ 是输入电阻的倒数，即 $G_{in} = 1/R_{in}$。\n$$G_{in}(d) = \\frac{1}{R_{in}(d)} = \\frac{\\pi}{2} \\sqrt{\\frac{d^3}{R_i R_m}}$$\n设母分支的直径为 $d_0$，两个子分支的直径分别为 $d_1$ 和 $d_2$。阻抗匹配条件是：\n$$G_{in}(d_0) = G_{in}(d_1) + G_{in}(d_2)$$\n代入 $G_{in}(d)$ 的表达式：\n$$\\frac{\\pi}{2} \\sqrt{\\frac{d_0^3}{R_i R_m}} = \\frac{\\pi}{2} \\sqrt{\\frac{d_1^3}{R_i R_m}} + \\frac{\\pi}{2} \\sqrt{\\frac{d_2^3}{R_i R_m}}$$\n由于问题陈述膜和胞内特性（$R_m$ 和 $R_i$）在整个树突树上是均匀的，常数项 $\\frac{\\pi}{2\\sqrt{R_i R_m}}$ 是所有项的公因子，可以消去。这就得到了所需的直径关系：\n$$\\sqrt{d_0^3} = \\sqrt{d_1^3} + \\sqrt{d_2^3}$$\n这就是通常所说的 Rall's $3/2$ 次方律，也可以写成：\n$$d_0^{3/2} = d_1^{3/2} + d_2^{3/2}$$\n\n### 第2部分：分数偏差的计算\n\n问题将与精确阻抗匹配条件的绝对分数偏差定义为：\n$$\\varepsilon \\equiv \\frac{\\left|\\,f(d_{1},d_{2}) - f(d_{0})\\,\\right|}{f(d_{0})}$$\n根据我们的推导，决定电导的、与直径相关的量 $f(\\cdot)$ 是 $d^{3/2}$。因此，$f(d_0) = d_0^{3/2}$，来自子分支的联合贡献是 $f(d_1, d_2) = d_1^{3/2} + d_2^{3/2}$。$\\varepsilon$ 的公式变为：\n$$\\varepsilon = \\frac{\\left| (d_1^{3/2} + d_2^{3/2}) - d_0^{3/2} \\right|}{d_0^{3/2}} = \\left| \\frac{d_1^{3/2} + d_2^{3/2}}{d_0^{3/2}} - 1 \\right|$$\n我们已知特定分叉的直径如下：\n$d_0 = 3.0\\,\\mu\\text{m}$\n$d_1 = 2.5\\,\\mu\\text{m}$\n$d_2 = 1.2\\,\\mu\\text{m}$\n\n在比率中，单位微米（$\\mu\\text{m}$）会相互抵消，所以我们可以直接使用数值。\n首先，我们计算所需的各项：\n母分支的项是：\n$$f(d_0) = d_0^{3/2} = (3.0)^{3/2} \\approx 5.196152$$\n子分支的各项是：\n$$d_1^{3/2} = (2.5)^{3/2} \\approx 3.952847$$\n$$d_2^{3/2} = (1.2)^{3/2} \\approx 1.314534$$\n子分支各项的和是：\n$$f(d_1, d_2) = d_1^{3/2} + d_2^{3/2} \\approx 3.952847 + 1.314534 = 5.267381$$\n现在，我们将这些值代入 $\\varepsilon$ 的表达式中：\n$$\\varepsilon = \\frac{\\left| 5.267381 - 5.196152 \\right|}{5.196152} = \\frac{0.071229}{5.196152} \\approx 0.01370798$$\n问题要求将答案四舍五入到四位有效数字。\n$$\\varepsilon \\approx 0.01371$$\n这个值表示，对于给定的树突分叉，与理想阻抗匹配条件的绝对分数偏差约为 $1.371\\%$。", "answer": "$$\\boxed{0.01371}$$", "id": "4508610"}, {"introduction": "信号进入树突后，其强度在向胞体传播的过程中会发生衰减。被动电缆理论使用一个特征长度常数 $\\lambda$ 来描述这种电压衰减，而 $\\lambda$ 的值取决于树突的物理特性，包括其直径。通过推导并应用电压衰减公式，你将对树突直径如何关键性地影响突触效能和神经元的整合特性获得定量的理解。[@problem_id:4508620]", "problem": "一个被动树突电缆可以被建模为一个直径为 $d$ 的均匀圆柱形导体，其膜电阻率为 $R_{m}$（单位 $\\Omega \\cdot \\mathrm{cm}^{2}$），胞质（轴向）电阻率为 $R_{i}$（单位 $\\Omega \\cdot \\mathrm{cm}$）。考虑一个沿坐标 $x \\geq 0$ 延伸的有效半无限长树突段，在 $x=0$ 处施加一个局部突触输入，该输入瞬间将局部膜电位设置为 $V(0)=V_{0}$。从圆柱体的电流平衡和几何形状出发，并以稳态被动电缆方程为基本依据，推导沿电缆的膜电位 $V(x)$ 的空间依赖关系以及长度常数 $\\lambda$（用 $d$、$R_{m}$ 和 $R_{i}$ 表示）。然后，对于一个固定的轴向距离 $x$，通过计算两个不同直径下该距离处的衰减电压之比，来量化直径如何影响衰减。\n\n使用以下参数值：\n- 直径 $d_{1} = 2.0 \\times 10^{-4} \\ \\mathrm{cm}$ 和 $d_{2} = 5.0 \\times 10^{-5} \\ \\mathrm{cm}$，\n- 膜电阻率 $R_{m} = 2.0 \\times 10^{4} \\ \\Omega \\cdot \\mathrm{cm}^{2}$，\n- 胞质电阻率 $R_{i} = 150 \\ \\Omega \\cdot \\mathrm{cm}$，\n- 原点处的输入振幅 $V_{0} = 10 \\ \\mathrm{mV}$，\n- 轴向距离 $x = 0.10 \\ \\mathrm{cm}$。\n\n计算比值\n$$\n\\frac{V_{d_{1}}(x)}{V_{d_{2}}(x)},\n$$\n其中 $V_{d}(x)$ 表示直径为 $d$ 的电缆在距离 $x$ 处的衰减膜电位。将最终比值表示为一个纯数（无单位），并将答案四舍五入至四位有效数字。", "solution": "该问题要求推导被动树突电缆的膜电位 $V(x)$ 的空间依赖关系和长度常数 $\\lambda$，然后计算两种不同电缆直径下的衰减电压之比。\n\n首先，我们验证问题陈述的有效性。\n已知条件如下：\n- 模型：一个被动、均匀、圆柱形的树突电缆。\n- 几何形状：一个半无限长段，$x \\ge 0$。\n- 直径：$d_{1} = 2.0 \\times 10^{-4} \\ \\mathrm{cm}$ 和 $d_{2} = 5.0 \\times 10^{-5} \\ \\mathrm{cm}$。\n- 膜电阻率：$R_{m} = 2.0 \\times 10^{4} \\ \\Omega \\cdot \\mathrm{cm}^{2}$。\n- 胞质（轴向）电阻率：$R_{i} = 150 \\ \\Omega \\cdot \\mathrm{cm}$。\n- 边界条件：$V(0) = V_{0} = 10 \\ \\mathrm{mV}$。\n- 用于评估的轴向距离：$x = 0.10 \\ \\mathrm{cm}$。\n- 任务：推导 $V(x)$ 和 $\\lambda$。计算比值 $\\frac{V_{d_{1}}(x)}{V_{d_{2}}(x)}$。\n\n该问题在科学上基于神经生物学中已建立的被动电缆理论，该理论使用电路原理对树突进行建模。所提供的参数在实际的生理范围内。问题是良定的，具有足够的边界条件（$V(0)=V_0$ 以及对于半无限长电缆，当 $x \\to \\infty$ 时 $V(x) \\to 0$ 的隐含条件）以确保唯一解。语言客观而精确。因此，该问题被认为是有效的。\n\n我们从第一性原理开始推导。考虑一个长度为 $\\Delta x$、直径为 $d$ 的树突微小圆柱段。膜电位 $V$ 是相对于静息电位 $0$ 来定义的。\n\n轴向电流 $I_{i}$ 沿x轴在胞质内流动。根据欧姆定律，单位长度的轴向电阻 $r_i$ 由胞质电阻率 $R_i$ 除以横截面积 $A = \\pi (d/2)^2 = \\frac{\\pi d^2}{4}$ 给出。\n$$ r_i = \\frac{R_i}{A} = \\frac{4 R_i}{\\pi d^2} $$\n在位置 $x$ 处的轴向电流与电压梯度相关，关系如下：\n$$ I_i(x) = -\\frac{1}{r_i} \\frac{dV}{dx} = -\\frac{\\pi d^2}{4 R_i} \\frac{dV}{dx} $$\n\n膜电流 $I_m$ 是从该段膜泄漏出去的电流。长度为 $\\Delta x$ 的段的膜电阻是膜电阻率 $R_m$ 除以该段的表面积 $\\pi d \\Delta x$。因此，通过该段膜的电流泄漏为：\n$$ I_m = \\frac{ V }{ \\left( \\frac{R_m}{\\pi d \\Delta x} \\right) } = \\frac{\\pi d}{R_m} V \\Delta x $$\n\n在稳态下，沿该段的轴向电流变化量必须等于通过膜泄漏的电流。根据基尔霍夫电流定律：\n$$ I_i(x) - I_i(x + \\Delta x) = I_m $$\n在极限 $\\Delta x \\to 0$ 时，这变为：\n$$ -\\frac{dI_i}{dx} \\Delta x = I_m $$\n代入 $I_m$ 的表达式：\n$$ -\\frac{dI_i}{dx} = \\frac{\\pi d}{R_m} V $$\n现在我们将 $I_i(x)$ 的表达式对 $x$ 求导：\n$$ \\frac{dI_i}{dx} = -\\frac{\\pi d^2}{4 R_i} \\frac{d^2V}{dx^2} $$\n将此代入电流平衡方程得到：\n$$ - \\left( -\\frac{\\pi d^2}{4 R_i} \\frac{d^2V}{dx^2} \\right) = \\frac{\\pi d}{R_m} V $$\n$$ \\frac{\\pi d^2}{4 R_i} \\frac{d^2V}{dx^2} = \\frac{\\pi d}{R_m} V $$\n重新整理这个方程，得到稳态被动电缆方程：\n$$ \\frac{d^2V}{dx^2} = \\left( \\frac{4 R_i}{d R_m} \\right) V $$\n这个微分方程的形式为 $\\frac{d^2V}{dx^2} - \\frac{1}{\\lambda^2} V = 0$，其中 $\\lambda$ 是长度常数。通过比较，我们确定 $\\frac{1}{\\lambda^2} = \\frac{4 R_i}{d R_m}$。因此，长度常数 $\\lambda$ 是：\n$$ \\lambda = \\sqrt{\\frac{d R_m}{4 R_i}} $$\n电缆方程的通解是 $V(x) = C_1 \\exp(x/\\lambda) + C_2 \\exp(-x/\\lambda)$。我们应用半无限长电缆的边界条件。\n1. 在 $x=0$ 处，电位是固定的：$V(0) = V_0$。所以，$V_0 = C_1 + C_2$。\n2. 当 $x \\to \\infty$ 时，电位必须保持有限（并衰减到静息电位 $0$）。$\\exp(x/\\lambda)$ 项无界增长，因此其系数 $C_1$ 必须为 $0$。\n当 $C_1 = 0$ 时，第一个条件给出 $C_2 = V_0$。膜电位空间依赖关系的解是：\n$$ V(x) = V_0 \\exp(-x/\\lambda) $$\n这个表达式描述了电压随与输入位置距离的增加而呈指数衰减。\n\n问题要求计算两个不同直径 $d_1$ 和 $d_2$ 下的衰减电压之比。设 $V_{d_1}(x)$ 和 $V_{d_2}(x)$ 分别为直径为 $d_1$ 和 $d_2$ 的电缆的电位。它们各自的长度常数为 $\\lambda_{d_1}$ 和 $\\lambda_{d_2}$。\n$$ \\lambda_{d_1} = \\sqrt{\\frac{d_1 R_m}{4 R_i}} \\quad \\text{和} \\quad \\lambda_{d_2} = \\sqrt{\\frac{d_2 R_m}{4 R_i}} $$\n在固定距离 $x$ 处的电位之比为：\n$$ \\frac{V_{d_1}(x)}{V_{d_2}(x)} = \\frac{V_0 \\exp(-x/\\lambda_{d_1})}{V_0 \\exp(-x/\\lambda_{d_2})} = \\exp\\left(-\\frac{x}{\\lambda_{d_1}} + \\frac{x}{\\lambda_{d_2}}\\right) = \\exp\\left(x\\left(\\frac{1}{\\lambda_{d_2}} - \\frac{1}{\\lambda_{d_1}}\\right)\\right) $$\n代入长度常数的表达式：\n$$ \\frac{1}{\\lambda_{d_1}} = \\sqrt{\\frac{4 R_i}{d_1 R_m}} \\quad \\text{和} \\quad \\frac{1}{\\lambda_{d_2}} = \\sqrt{\\frac{4 R_i}{d_2 R_m}} $$\n该比值变为：\n$$ \\frac{V_{d_1}(x)}{V_{d_2}(x)} = \\exp\\left(x \\left(\\sqrt{\\frac{4 R_i}{d_2 R_m}} - \\sqrt{\\frac{4 R_i}{d_1 R_m}}\\right)\\right) = \\exp\\left(x \\sqrt{\\frac{4 R_i}{R_m}} \\left(\\frac{1}{\\sqrt{d_2}} - \\frac{1}{\\sqrt{d_1}}\\right)\\right) $$\n现在，我们代入数值：\n$d_{1} = 2.0 \\times 10^{-4} \\ \\mathrm{cm}$\n$d_{2} = 5.0 \\times 10^{-5} \\ \\mathrm{cm}$\n$R_{m} = 2.0 \\times 10^{4} \\ \\Omega \\cdot \\mathrm{cm}^{2}$\n$R_{i} = 150 \\ \\Omega \\cdot \\mathrm{cm}$\n$x = 0.10 \\ \\mathrm{cm}$\n我们注意到 $d_1 = 4 d_2$。这简化了括号中的项：\n$$ \\frac{1}{\\sqrt{d_2}} - \\frac{1}{\\sqrt{d_1}} = \\frac{1}{\\sqrt{d_2}} - \\frac{1}{\\sqrt{4d_2}} = \\frac{1}{\\sqrt{d_2}} - \\frac{1}{2\\sqrt{d_2}} = \\frac{1}{2\\sqrt{d_2}} $$\n指数函数的指数部分变为：\n$$ \\text{Exponent} = x \\sqrt{\\frac{4 R_i}{R_m}} \\left( \\frac{1}{2\\sqrt{d_2}} \\right) = \\frac{x}{2} \\sqrt{\\frac{4 R_i}{d_2 R_m}} = x \\sqrt{\\frac{R_i}{d_2 R_m}} $$\n现在，我们计算指数的值：\n$$ \\text{Exponent} = (0.10) \\times \\sqrt{\\frac{150}{(5.0 \\times 10^{-5})(2.0 \\times 10^4)}} $$\n$$ = 0.10 \\times \\sqrt{\\frac{150}{10.0 \\times 10^{-1}}} = 0.10 \\times \\sqrt{\\frac{150}{1}} = 0.10 \\sqrt{150} $$\n$$ = 0.10 \\sqrt{25 \\times 6} = 0.10 \\times 5 \\sqrt{6} = 0.5 \\sqrt{6} $$\n指数的数值约为 $0.5 \\times 2.4494897 = 1.22474485$。\n最后，我们计算该比值：\n$$ \\frac{V_{d_{1}}(x)}{V_{d_{2}}(x)} = \\exp(0.5 \\sqrt{6}) \\approx \\exp(1.22474485) \\approx 3.403163 $$\n将结果四舍五入到四位有效数字得到 $3.403$。这表明在 $0.10 \\ \\mathrm{cm}$ 的距离处，较粗树突中的电压是较细树突中的 $3$ 倍多，证明了较大的直径导致较小的信号衰减。", "answer": "$$\\boxed{3.403}$$", "id": "4508620"}, {"introduction": "电缆理论的原理强调了形态学的重要性，而为了对真实的神经元进行分类，我们需要系统性的方法来量化它们复杂的形状。一个神经元错综复杂的3D结构可以被提炼成一个数值特征向量，该向量能捕捉其分支模式、路径长度和弯曲度等关键属性。这项动手编程练习旨在弥合生物物理理论与数据驱动的神经科学之间的鸿沟，要求你实现将原始解剖数据转换为有意义的、可用于机器学习分类的表征的算法。[@problem_id:4004748]", "problem": "您将获得一个神经元重建中各节点的三维坐标，以及每个节点的父指针和半径。该重建定义了三维空间中的一棵有根树，其中每个节点 $i$ 的位置为 $(x_i, y_i, z_i)$（单位为微米，$\\mu m$），半径为 $r_i$（单位为微米，$\\mu m$），父节点索引为 $p_i$，其中 $p_i = -1$ 表示根节点。该树被假定为解剖学上合理的：它是一个具有单一根节点的有向无环图，除根节点外，每个节点都有且只有一个父节点。\n\n您的任务是从基本原理出发，推导并实现一个适用于下游分类的形态学特征向量的计算。从基本的欧几里得几何和由折线离散化的曲线定义开始，您必须构建以下特征：\n\n1. 分支角直方图：\n- 对于任何至少有两个子节点的节点 $b$，为其子节点 $c$ 定义出射段向量为 $\\mathbf{v}_c = \\mathbf{x}_c - \\mathbf{x}_b$，其中 $\\mathbf{x}_j = (x_j, y_j, z_j)$ 是节点 $j$ 的笛卡尔坐标。\n- 对于每对无序子节点 $(c_1, c_2)$，定义分支角\n$$\n\\theta(b; c_1, c_2) = \\arccos\\left(\\frac{\\mathbf{v}_{c_1} \\cdot \\mathbf{v}_{c_2}}{\\|\\mathbf{v}_{c_1}\\| \\, \\|\\mathbf{v}_{c_2}\\|}\\right),\n$$\n其中 $\\theta$ 以弧度为单位。\n- 累加整个树中所有此类角度，并使用以下区间边界计算一个归一化直方图\n$$\nB_\\theta = [0, \\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi],\n$$\n解释为半开区间 $[b_k, b_{k+1})$，但最后一个区间为 $[b_6, b_7]$。直方图必须归一化，使其总和为 $1$。如果没有分叉角，则直方图必须是一个长度为 $6$ 的零向量。\n\n2. 根到叶路径长度分布：\n- 将任何没有子节点的节点定义为叶节点。\n- 对于每个叶节点 $t$，定义从根节点到 $t$ 的唯一路径 $P(t)$ 及其长度\n$$\nL(t) = \\sum_{(i \\rightarrow j) \\in P(t)} \\|\\mathbf{x}_j - \\mathbf{x}_i\\|,\n$$\n其中 $\\|\\cdot\\|$ 是欧几里得范数，长度单位为微米（$\\mu m$）。\n- 使用以下区间边界对集合 $\\{L(t)\\}$ 计算一个归一化直方图\n$$\nB_L = [0, 20, 40, 60, 80, 100],\n$$\n同样解释为半开区间 $[b_k, b_{k+1})$，但最后一个区间为 $[b_5, b_6]$。直方图必须使其总和为 $1$。如果没有叶节点，则直方图必须是一个长度为 $5$ 的零向量。\n\n3. 曲率估计：\n- 对于每个根到叶路径，其有序点为 $(\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_n)$，在内部点 $k = 1, \\dots, n-1$ 处通过以下离散公式近似计算曲率\n$$\n\\kappa_k = \\frac{\\arccos\\left(\\frac{(\\mathbf{x}_k - \\mathbf{x}_{k-1}) \\cdot (\\mathbf{x}_{k+1} - \\mathbf{x}_k)}{\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| \\, \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|}\\right)}{\\frac{1}{2}\\left(\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| + \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|\\right)},\n$$\n其中 $\\kappa_k$ 的单位为弧度/微米。将所有路径的所有曲率样本聚合到一个集合 $\\{\\kappa_k\\}$ 中。定义平均曲率\n$$\n\\bar{\\kappa} = \\frac{1}{M}\\sum_{m=1}^{M} \\kappa_m\n$$\n和总体标准差\n$$\n\\sigma_{\\kappa} = \\sqrt{\\frac{1}{M}\\sum_{m=1}^{M} (\\kappa_m - \\bar{\\kappa})^2},\n$$\n其中 $M$ 是所有路径上曲率样本的总数。如果没有内部点，则将 $\\bar{\\kappa}$ 和 $\\sigma_{\\kappa}$ 均设为 $0$。\n\n4. 锥度剖面：\n- 对于每个根到叶路径，设 $s_k$ 是从根节点沿路径测量的节点 $k$ 处的累积路径长度（单位为微米），$r_k$ 是节点 $k$ 处的半径（单位为微米）。\n- 对于每个至少有 $2$ 个点的路径，计算 $r$ 相对于 $s$ 的普通最小二乘斜率 $m$，其公式为\n$$\nm = \\frac{\\sum_{k}(s_k - \\bar{s})(r_k - \\bar{r})}{\\sum_{k}(s_k - \\bar{s})^2},\n$$\n其中 $\\bar{s}$ 和 $\\bar{r}$ 分别是 $\\{s_k\\}$ 和 $\\{r_k\\}$ 的均值。如果分母为零或路径点数少于 $2$ 个，则定义 $m = 0$。将所有路径的斜率聚合到一个集合 $\\{m\\}$ 中，并定义平均斜率\n$$\n\\bar{m} = \\frac{1}{P}\\sum_{p=1}^{P} m_p\n$$\n和总体标准差\n$$\n\\sigma_m = \\sqrt{\\frac{1}{P}\\sum_{p=1}^{P} (m_p - \\bar{m})^2},\n$$\n其中 $P$ 是路径的数量。\n\n通过按顺序连接分支角直方图（长度 $6$）、路径长度直方图（长度 $5$）、曲率均值和标准差（长度 $2$）以及锥度斜率均值和标准差（长度 $2$）来构建特征向量。总特征向量长度为 $15$。所有长度单位必须为微米（$\\mu m$）；所有角度单位必须为弧度；曲率单位必须为弧度/微米；锥度斜率单位必须为微米/微米。\n\n测试套件：\n使用以下四个测试用例，每个用例由一个节点列表 $(i, x_i, y_i, z_i, r_i, p_i)$ 定义，其中所有坐标和半径的单位均为微米（$\\mu m$），索引为整数。父节点索引 $p_i = -1$ 表示根节点。\n\n- 测试用例 1（直线电缆）：\n  - $(0, 0, 0, 0, 2, -1)$\n  - $(1, 0, 0, 10, 2, 0)$\n  - $(2, 0, 0, 20, 2, 1)$\n  - $(3, 0, 0, 30, 2, 2)$\n\n- 测试用例 2（对称Y形）：\n  - $(0, 0, 0, 0, 3, -1)$\n  - $(1, 0, 0, 10, 2.5, 0)$\n  - $(2, 10, 0, 20, 2, 1)$\n  - $(3, -10, 0, 20, 2, 1)$\n\n- 测试用例 3（带分叉的弯曲路径）：\n  - $(0, 0, 0, 0, 3, -1)$\n  - $(1, 0, 5, 5, 2.8, 0)$\n  - $(2, 0, 10, 10, 2.6, 1)$\n  - $(3, 0, 15, 10, 2.4, 2)$\n  - $(4, 4, 22, 10, 2.2, 3)$\n  - $(5, -2, 22, 10, 2.2, 3)$\n\n- 测试用例 4（长分支）：\n  - $(0, 0, 0, 0, 4, -1)$\n  - $(1, 0, 0, 20, 3.5, 0)$\n  - $(2, 0, 0, 40, 3.0, 1)$\n  - $(3, 10, 0, 55, 2.5, 2)$\n  - $(4, 20, 0, 70, 2.0, 3)$\n  - $(5, -10, 0, 55, 2.5, 2)$\n  - $(6, -20, 0, 70, 2.0, 5)\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素是针对一个测试用例的特征向量（一个包含 $15$ 个浮点数的列表），并聚合到一个顶层列表中。例如：\"[[f1,f2,...,f15],[g1,g2,...,g15],[h1,h2,...,h15],[k1,k2,...,k15]]\"。角度单位必须是弧度；长度单位必须是微米（$\\mu m$）；曲率单位必须是弧度/微米；锥度斜率单位必须是微米/微米。不应打印任何额外文本。\n\n实现必须是一个完整的、可运行的程序，仅使用指定的运行时环境。所有数值答案必须是浮点数。算法必须对边界情况具有鲁棒性，包括没有分叉的节点、半径恒定的路径以及太短而无法定义曲率或斜率的路径。", "solution": "所提出的问题是有效的。它在计算神经科学领域，特别是在神经元重建的形态计量分析方面，具有科学依据。所有提供的定义、公式和条件在数学上和算法上都是合理的、适定的，并且没有歧义或矛盾。任务是从基本原理出发实现一个特征提取流程，这是一个标准且可验证的过程。\n\n该解决方案通过一个系统的、多步骤的过程来开发。首先，将输入数据（一个节点属性列表）解析成一个图数据结构，该结构代表了神经元的树状形态。随后，基于此结构计算四组不同的形态学特征：分支角直方图、根到叶路径长度分布、局部曲率统计和树突锥度统计。最后，将这些特征连接成一个维度为 $15$ 的单一特征向量。\n\n**1. 数据结构化**\n\n初始输入是一个节点列表，每个节点由其索引 $i$、笛卡尔坐标 $\\mathbf{x}_i = (x_i, y_i, z_i)$、半径 $r_i$ 和父节点索引 $p_i$ 定义。为了便于遍历和邻域查询，我们首先将这个扁平列表转换为更结构化的表示。一个将每个节点索引映射到其属性（坐标、半径、父节点）的字典提供了高效的查找。然后构建第二个字典，代表一个邻接表，用于将每个父节点索引映射到其子节点索引的列表。这是通过遍历所有节点，并为每个父节点为 $p_i \\neq -1$ 的节点 $i$ 将 $i$ 追加到 $p_i$ 的子节点列表中来实现的。父节点为 $p_i = -1$ 的单个节点被识别为树的根。\n\n**2. 特征推导与计算**\n\n四个特征组的计算过程如下，严格遵守所提供的定义。\n\n**2.1. 分支角直方图**\n\n该特征量化了树突分叉的几何形状。\n- 一个分支点或分叉节点 $b$ 被定义为任何具有两个或更多子节点的节点。我们通过检查先前构建的子节点映射来识别所有此类节点。\n- 对于每个分叉节点 $b$，我们考虑其每一对无序子节点 $(c_1, c_2)$。\n- 每个子分支初始段的方向由从父节点到子节点的向量给出：$\\mathbf{v}_{c_1} = \\mathbf{x}_{c_1} - \\mathbf{x}_b$ 和 $\\mathbf{v}_{c_2} = \\mathbf{x}_{c_2} - \\mathbf{x}_b$。\n- 这两个向量之间的夹角 $\\theta$ 是衡量分支展开宽度的度量。它根据点积的定义计算得出：\n$$\n\\theta(b; c_1, c_2) = \\arccos\\left(\\frac{\\mathbf{v}_{c_1} \\cdot \\mathbf{v}_{c_2}}{\\|\\mathbf{v}_{c_1}\\| \\|\\mathbf{v}_{c_2}\\|}\\right)\n$$\n其中 $\\|\\cdot\\|$ 表示欧几里得范数。$\\arccos$ 函数的参数被裁剪到 $[-1, 1]$ 范围内，以防止浮点不精确导致的数值错误。\n- 收集树中所有分叉点的所有此类角度到一个列表中。\n- 使用指定的区间边界 $B_\\theta = [0, \\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi]$ 计算这些角度的直方图。这会产生一个 $6$ 维的计数向量。\n- 为了使特征与神经元的大小（即分叉总数）无关，通过将每个区间的计数除以角度总数来对直方图进行归一化，确保各分量之和为 $1$。如果不存在分叉点，则根据问题规范返回一个长度为 $6$ 的零向量。\n\n**2.2. 根到叶路径长度分布**\n\n该特征捕捉了从胞体（根）到树突末梢的电紧张距离分布。\n- 一个叶节点 $t$ 被定义为任何没有子节点的节点。我们识别所有此类节点。\n- 对于每个叶节点 $t$，我们使用父指针追溯其回到根节点的唯一路径。这会产生构成路径的节点序列 $P(t) = (\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_n=t)$。\n- 此路径的总长度 $L(t)$ 是其组成线段的欧几里得长度之和：\n$$\nL(t) = \\sum_{(i \\rightarrow j) \\in P(t)} \\|\\mathbf{x}_j - \\mathbf{x}_i\\|\n$$\n- 收集所有此类根到叶路径的长度。\n- 使用指定的区间边界 $B_L = [0, 20, 40, 60, 80, 100]$ 对这些路径长度计算归一化直方图，得到一个 $5$ 维向量。通过除以叶节点总数进行归一化。如果没有叶节点，则返回一个长度为 $5$ 的零向量。\n\n**2.3. 曲率估计**\n\n该特征测量树突路径的曲折度。\n- 我们重用上一步中识别的根到叶路径。\n- 对于每个至少有 $3$ 个节点的路径 $(\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_n)$，我们可以在内部节点 $k = 1, \\dots, n-1$ 处估计曲率。\n- 节点 $\\mathbf{x}_k$ 处的离散曲率 $\\kappa_k$ 定义为单位路径长度的转角。转角是入向量 $(\\mathbf{x}_k - \\mathbf{x}_{k-1})$ 和出向量 $(\\mathbf{x}_{k+1} - \\mathbf{x}_k)$ 之间的夹角。路径长度单位由这两段的平均长度近似。这给出了公式：\n$$\n\\kappa_k = \\frac{\\arccos\\left(\\frac{(\\mathbf{x}_k - \\mathbf{x}_{k-1}) \\cdot (\\mathbf{x}_{k+1} - \\mathbf{x}_k)}{\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| \\, \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|}\\right)}{\\frac{1}{2}\\left(\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| + \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|\\right)}\n$$\n- 进行检查以确保段长度非零，以避免除以零。\n- 聚合来自所有路径的所有有效曲率样本 $\\kappa_k$。\n- 从这个样本集合中，我们计算两个汇总统计量：平均曲率 $\\bar{\\kappa}$ 和总体标准差 $\\sigma_{\\kappa}$。如果整个树中不存在内部点（即所有路径的节点数少于 $3$ 个），则这两个统计量都设为 $0$。\n\n**2.4. 锥度剖面**\n\n该特征描述了树突分支的半径如何随离根节点的距离而变化，这与 Rall 幂定律有关。\n- 对于每个至少有 $2$ 个节点的根到叶路径，我们分析半径 $r$ 与离根节点的累积路径距离 $s$ 之间的关系。\n- 对于具有节点 $(_0, _1, ..., _n)$ 的路径，节点 $k$ 处的累积距离为 $s_k = \\sum_{i=0}^{k-1} \\|\\mathbf{x}_{i+1} - \\mathbf{x}_i\\|$，其中 $s_0=0$。相应的半径为 $\\{r_0, r_1, \\dots, r_n\\}$。\n- 对于每个路径，我们计算半径 $r$ 对距离 $s$ 的普通最小二乘线性回归的斜率 $m$。该公式由 $s$ 和 $r$ 的协方差与 $s$ 的方差之比给出：\n$$\nm = \\frac{\\sum_{k}(s_k - \\bar{s})(r_k - \\bar{r})}{\\sum_{k}(s_k - \\bar{s})^2}\n$$\n- 按照规定，如果路径的点数少于 $2$ 个或分母为零（即所有累积距离都相同，意味着段长为零），则斜率 $m$ 定义为 $0$。\n- 收集所有有效路径的斜率。\n- 计算平均斜率 $\\bar{m}$ 和斜率的总体标准差 $\\sigma_m$。如果没有可以计算斜率的路径，则这两个统计量都设为 $0$。\n\n**3. 特征向量组装**\n\n最终的 $15$ 维特征向量通过按指定顺序连接上述计算结果来构建：\n1.  分支角直方图（6 个浮点数）\n2.  路径长度直方图（5 个浮点数）\n3.  曲率的均值和标准差（2 个浮点数）\n4.  锥度斜率的均值和标准差（2 个浮点数）\n\n此过程提供了对神经元形态的全面、定量的描述，适用于机器学习模型中的细胞类型分类。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef compute_features(nodes_data):\n    \"\"\"\n    Computes morphological features for a single neuron reconstruction.\n    \"\"\"\n    if not nodes_data:\n        return [0.0] * 15\n\n    # 1. Data Structuring\n    num_nodes = len(nodes_data)\n    nodes = {}\n    children = {i: [] for i in range(num_nodes)}\n    root_id = -1\n\n    node_list = sorted(nodes_data, key=lambda n: n[0])\n\n    for (node_id, x, y, z, r, p) in node_list:\n        nodes[node_id] = {\n            'pos': np.array([x, y, z], dtype=float),\n            'radius': float(r),\n            'parent': int(p)\n        }\n        if p != -1:\n            if p in children:\n                children[p].append(node_id)\n        else:\n            root_id = node_id\n\n    # 2. Feature Calculation\n\n    # 2.1. Branch Angle Histogram\n    branch_angles = []\n    bifurcation_node_ids = [i for i, c in children.items() if len(c) >= 2]\n    for b_id in bifurcation_node_ids:\n        b_pos = nodes[b_id]['pos']\n        for c1_id, c2_id in itertools.combinations(children[b_id], 2):\n            v1 = nodes[c1_id]['pos'] - b_pos\n            v2 = nodes[c2_id]['pos'] - b_pos\n            norm_v1 = np.linalg.norm(v1)\n            norm_v2 = np.linalg.norm(v2)\n            if norm_v1 > 0 and norm_v2 > 0:\n                cos_theta = np.dot(v1, v2) / (norm_v1 * norm_v2)\n                cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                angle = np.arccos(cos_theta)\n                branch_angles.append(angle)\n\n    angle_bins = [0, np.pi/6, np.pi/3, np.pi/2, 2*np.pi/3, 5*np.pi/6, np.pi]\n    if branch_angles:\n        hist_angles, _ = np.histogram(branch_angles, bins=angle_bins)\n        hist_angles = hist_angles.astype(float) / len(branch_angles)\n    else:\n        hist_angles = np.zeros(len(angle_bins) - 1, dtype=float)\n\n    # 2.2, 2.3, 2.4: Path-based features\n    leaf_ids = [i for i in range(num_nodes) if not children.get(i)]\n    \n    path_lengths = []\n    curvatures = []\n    taper_slopes = []\n\n    for leaf_id in leaf_ids:\n        path = []\n        curr_id = leaf_id\n        while curr_id != -1:\n            path.append(curr_id)\n            if nodes[curr_id]['parent'] == -1:\n                break\n            curr_id = nodes[curr_id]['parent']\n        path.reverse()\n        \n        if not path:\n            continue\n        \n        # Path length and cumulative length calculation\n        total_length = 0.0\n        segment_lengths = []\n        if len(path) > 1:\n            for i in range(len(path) - 1):\n                p1_pos = nodes[path[i]]['pos']\n                p2_pos = nodes[path[i+1]]['pos']\n                length = np.linalg.norm(p2_pos - p1_pos)\n                segment_lengths.append(length)\n            total_length = sum(segment_lengths)\n        path_lengths.append(total_length)\n        \n        # Curvature calculation\n        if len(path) >= 3:\n            for i in range(1, len(path) - 1):\n                p_prev_pos = nodes[path[i-1]]['pos']\n                p_curr_pos = nodes[path[i]]['pos']\n                p_next_pos = nodes[path[i+1]]['pos']\n                \n                v_in = p_curr_pos - p_prev_pos\n                v_out = p_next_pos - p_curr_pos\n                \n                norm_in = np.linalg.norm(v_in)\n                norm_out = np.linalg.norm(v_out)\n                \n                if norm_in > 0 and norm_out > 0:\n                    cos_theta = np.dot(v_in, v_out) / (norm_in * norm_out)\n                    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                    angle = np.arccos(cos_theta)\n                    avg_len = (norm_in + norm_out) / 2.0\n                    curvatures.append(angle / avg_len)\n\n        # Tapering calculation\n        if len(path) >= 2:\n            s = np.concatenate(([0.0], np.cumsum(segment_lengths)))\n            r = np.array([nodes[node_id]['radius'] for node_id in path])\n            \n            s_mean = np.mean(s)\n            denominator = np.sum((s - s_mean)**2)\n            \n            if denominator > 0:\n                r_mean = np.mean(r)\n                numerator = np.sum((s - s_mean) * (r - r_mean))\n                slope = numerator / denominator\n                taper_slopes.append(slope)\n            else:\n                taper_slopes.append(0.0)\n        elif len(path) > 0:\n             # Path has only 1 node, so less than 2 points.\n             taper_slopes.append(0.0)\n\n    # Post-processing path features\n    length_bins = [0, 20, 40, 60, 80, 100]\n    if path_lengths:\n        hist_lengths, _ = np.histogram(path_lengths, bins=length_bins)\n        hist_lengths = hist_lengths.astype(float) / len(path_lengths)\n    else:\n        hist_lengths = np.zeros(len(length_bins) - 1, dtype=float)\n\n    if curvatures:\n        mean_kappa = np.mean(curvatures)\n        std_kappa = np.std(curvatures)\n    else:\n        mean_kappa, std_kappa = 0.0, 0.0\n\n    if taper_slopes:\n        mean_m = np.mean(taper_slopes)\n        std_m = np.std(taper_slopes)\n    else:\n        mean_m, std_m = 0.0, 0.0\n    \n    # 3. Assemble Feature Vector\n    feature_vector = np.concatenate([\n        hist_angles,\n        hist_lengths,\n        [mean_kappa, std_kappa],\n        [mean_m, std_m]\n    ])\n    \n    return feature_vector.tolist()\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (straight cable)\n        [\n            (0, 0, 0, 0, 2, -1),\n            (1, 0, 0, 10, 2, 0),\n            (2, 0, 0, 20, 2, 1),\n            (3, 0, 0, 30, 2, 2)\n        ],\n        # Test case 2 (symmetric Y-shape)\n        [\n            (0, 0, 0, 0, 3, -1),\n            (1, 0, 0, 10, 2.5, 0),\n            (2, 10, 0, 20, 2, 1),\n            (3, -10, 0, 20, 2, 1)\n        ],\n        # Test case 3 (curved path with bifurcation)\n        [\n            (0, 0, 0, 0, 3, -1),\n            (1, 0, 5, 5, 2.8, 0),\n            (2, 0, 10, 10, 2.6, 1),\n            (3, 0, 15, 10, 2.4, 2),\n            (4, 4, 22, 10, 2.2, 3),\n            (5, -2, 22, 10, 2.2, 3)\n        ],\n        # Test case 4 (long branches)\n        [\n            (0, 0, 0, 0, 4, -1),\n            (1, 0, 0, 20, 3.5, 0),\n            (2, 0, 0, 40, 3.0, 1),\n            (3, 10, 0, 55, 2.5, 2),\n            (4, 20, 0, 70, 2.0, 3),\n            (5, -10, 0, 55, 2.5, 2),\n            (6, -20, 0, 70, 2.0, 5)\n        ]\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_features(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # We must use list comprehension to avoid extra newlines or spaces.\n    print(f\"[[{','.join(map(str, results[0]))}],[{','.join(map(str, results[1]))}],[{','.join(map(str, results[2]))}],[{','.join(map(str, results[3]))}]]\")\n\nsolve()\n```", "id": "4004748"}]}