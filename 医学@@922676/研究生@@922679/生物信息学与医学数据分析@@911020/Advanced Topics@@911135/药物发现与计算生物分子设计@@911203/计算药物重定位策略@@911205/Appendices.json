{"hands_on_practices": [{"introduction": "药物重定位的一个核心思想是“相似性关联”原则，即化学结构相似的化合物可能具有相似的生物活性。为了在计算上实现这一想法，我们通常将分子表示为二进制“指纹”，并使用相似性系数来量化它们之间的相似度。本练习将通过计算经典的谷本系数（Tanimoto coefficient），帮助你掌握这一基本操作，这是基于结构的药物发现策略的基石 [@problem_id:4549838]。", "problem": "在计算药物重定位中，一种策略是构建化学相似性网络，其中候选化合物通过高的结构相似性与已批准的药物相连接，然后通过该网络传播表型证据。用于此类相似性计算的分子结构的一种常见表示是二进制结构指纹，例如扩展连接性指纹（ECFP），其中每个化合物被编码为一个固定长度的二进制向量，表示特定子结构特征的存在与否。考虑两个由长度为 $1024$ 的二进制指纹表示的化合物，并设 $A$ 和 $B$ 分别表示各自指纹中比特为 $1$ 的特征索引（位置）的集合。一种广泛使用、经过充分检验的集合相似性基本度量是 Jaccard 指数，对于有限集合其定义为 $$J(A,B) = \\frac{|A \\cap B|}{|A \\cup B|}.$$ 从这个基本定义和将二进制指纹解释为活性特征集合出发，根据计数 $a = |A|$、$b = |B|$ 和 $c = |A \\cap B|$，推导出适用于二进制指纹的 Tanimoto 系数的表达式。然后，对于两个 $1024$ 位指纹，当 $a=120$、$b=150$ 和 $c=90$ 时，计算 Tanimoto 系数。提供精确值，无需四舍五入。将最终的相似性表示为一个无量纲的实数。", "solution": "该问题陈述被评估为科学上合理、定义明确且客观。它基于化学信息学和生物信息学中的既定原则，特别是使用分子指纹和相似性度量进行药物发现。所有必要信息都已提供，可得出唯一解。\n\n任务是首先推导出适用于二进制指纹的 Tanimoto 系数的表达式，然后计算其在特定情况下的值。\n\n问题将基本相似性度量定义为两个有限集合 $A$ 和 $B$ 的 Jaccard 指数：\n$$J(A,B) = \\frac{|A \\cap B|}{|A \\cup B|}$$\n在此背景下，$A$ 和 $B$ 是两个不同化合物的二进制指纹中比特为 $1$ 的索引集合。变量定义为这些集合及其交集的基数：\n$a = |A|$，存在于化合物1中的特征数量。\n$b = |B|$，存在于化合物2中的特征数量。\n$c = |A \\cap B|$，同时存在于两种化合物中的特征数量。\n\n推导需要用给定的量 $a$、$b$ 和 $c$ 来表示分母 $|A \\cup B|$。使用两个集合的容斥原理，并集的基数由下式给出：\n$$|A \\cup B| = |A| + |B| - |A \\cap B|$$\n将给定的变量代入此公式，我们得到：\n$$|A \\cup B| = a + b - c$$\n现在，我们可以将分子和分母的表达式代回 Jaccard 指数的定义中：\n$$J(A,B) = \\frac{c}{a + b - c}$$\n在比较二进制向量或指纹的背景下，Jaccard 指数通常被称为 Tanimoto 系数。因此，表示为 $T_c$ 的 Tanimoto 系数的表达式为：\n$$T_c(A,B) = \\frac{c}{a + b - c}$$\n这完成了问题的第一部分。\n\n第二部分要求计算两个长度为 $1024$ 的指纹的此系数，其特征如下：\n$a = |A| = 120$\n$b = |B| = 150$\n$c = |A \\cap B| = 90$\n\n指纹的长度 $1024$ 是关于特征空间的背景信息，但不会进入 Tanimoto 系数的计算中，该系数仅取决于置位比特的计数。\n\n将这些值代入推导出的公式中：\n$$T_c = \\frac{90}{120 + 150 - 90}$$\n首先，我们计算分母：\n$$120 + 150 - 90 = 270 - 90 = 180$$\n现在，我们计算这个分数：\n$$T_c = \\frac{90}{180}$$\n这个分数可以简化为：\n$$T_c = \\frac{1}{2}$$\nTanimoto 系数是一个无量纲的实数，问题要求提供精确值。", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "4549838"}, {"introduction": "除了化学结构，我们还可以通过比较生物响应来寻找新的药物适应症，例如使用转录组数据。一种常见的策略是寻找能够逆转疾病基因表达特征的药物。本练习不仅要求你计算药物与疾病特征之间的重叠，更重要的是，它促使你批判性地思考不同相似性度量（如重叠系数与杰卡德指数）的解释局限性，从而理解选择正确度量方法的重要性 [@problem_id:4549869]。", "problem": "在计算药物重定位的工作流程中，通过比较疾病扰动特征和药物扰动特征，来识别其转录效应能抵消疾病相关变化的候选药物。考虑一个由上调基因集合组成的疾病特征，记为 $S_{\\mathrm{dis}}^{+}$，以及一个由下调基因集合组成的药物特征，记为 $S_{\\mathrm{drug}}^{-}$。这两个集合都源自对高通量转录组数据的差异表达分析，这些数据来自一个通用的检测空间，例如 Connectivity Map (CMap)，这是一个提供扰动基因表达谱的资源。\n\n假设以下通过经验确定的量成立：\n- 疾病上调基因集的基数为 $|S_{\\mathrm{dis}}^{+}| = 200$。\n- 药物下调基因集的基数为 $|S_{\\mathrm{drug}}^{-}| = 150$。\n- 这两个集合之间交集的基数为 $|S_{\\mathrm{dis}}^{+} \\cap S_{\\mathrm{drug}}^{-}| = 46$。\n\n从集合论的第一性原理和有限集之间相似度的核心定义出发，计算 $S_{\\mathrm{dis}}^{+}$ 和 $S_{\\mathrm{drug}}^{-}$ 之间的重叠系数，其中重叠系数定义为交集覆盖较小集合的比例。请用精确分数表示最终答案，不要四舍五入。\n\n此外，在您的推导过程中，请从第一性原理的角度解释该系数在药物-疾病特征比较背景下的解释性局限，特别是与那些同时考虑集合共享和独有元素的对称集合相似性度量相关的局限。您的解释应基于集合基数、交集和并集的定义，并且在生物信息学和医学数据分析领域内是科学上现实的。", "solution": "问题陈述的有效性建立如下。\n\n**步骤1：提取已知条件**\n- 疾病特征是上调基因的集合，$S_{\\mathrm{dis}}^{+}$。\n- 药物特征是下调基因的集合，$S_{\\mathrm{drug}}^{-}$。\n- 疾病上调基因集的基数为 $|S_{\\mathrm{dis}}^{+}| = 200$。\n- 药物下调基因集的基数为 $|S_{\\mathrm{drug}}^{-}| = 150$。\n- 这些集合交集的基数为 $|S_{\\mathrm{dis}}^{+} \\cap S_{\\mathrm{drug}}^{-}| = 46$。\n- 重叠系数定义为“交集覆盖较小集合的比例”。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：**该问题牢固地植根于生物信息学这一成熟领域，特别是在计算药物重定位方面。使用转录组扰动特征（上调/下调基因集）、通过基于集合的度量进行比较，以及提及像 Connectivity Map (CMap) 这样的资源，都是标准方法。所给数值在生物学上是合理的。\n- **适定性：**该问题提供了计算所需系数的所有必要数据和一个清晰、无歧义的定义。对于概念性解释的要求，在集合论及其在该领域应用的背景下，也得到了很好的定义。\n- **客观性：**问题陈述使用了来自集合论和生物信息学的精确、正式的语言。没有主观或模糊的术语。\n- **一致性：**给定的基数与集合论的公理一致。交集的基数 $|S_{\\mathrm{dis}}^{+} \\cap S_{\\mathrm{drug}}^{-}| = 46$ 小于或等于单个集合的基数 $|S_{\\mathrm{dis}}^{+}| = 200$ 和 $|S_{\\mathrm{drug}}^{-}| = 150$，符合要求。\n\n**步骤3：结论与行动**\n该问题是有效的。它在科学上合理，数学上一致，且具有适定性。将提供一个完整的解决方案。\n\n**解题推导**\n\n该问题要求计算两个集合 $S_{\\mathrm{dis}}^{+}$ 和 $S_{\\mathrm{drug}}^{-}$ 的重叠系数，并分析其解释性局限。\n\n设这两个集合分别表示为 $A = S_{\\mathrm{dis}}^{+}$ 和 $B = S_{\\mathrm{drug}}^{-}$。我们已知以下基数：\n- $|A| = |S_{\\mathrm{dis}}^{+}| = 200$\n- $|B| = |S_{\\mathrm{drug}}^{-}| = 150$\n- $|A \\cap B| = |S_{\\mathrm{dis}}^{+} \\cap S_{\\mathrm{drug}}^{-}| = 46$\n\n重叠系数，我们记为 $O(A, B)$，定义为交集的大小除以两个集合中较小者的大小。这可以用最小值函数正式表示为：\n$$O(A, B) = \\frac{|A \\cap B|}{\\min(|A|, |B|)}$$\n该系数也被称为 Szymkiewicz–Simpson 系数。\n\n首先，我们通过比较它们的基数来确定较小的集合：\n$$\\min(|A|, |B|) = \\min(200, 150) = 150$$\n较小的集合是 $B = S_{\\mathrm{drug}}^{-}$。\n\n现在，我们将给定值代入重叠系数的公式中：\n$$O(S_{\\mathrm{dis}}^{+}, S_{\\mathrm{drug}}^{-}) = \\frac{|S_{\\mathrm{dis}}^{+} \\cap S_{\\mathrm{drug}}^{-}|}{\\min(|S_{\\mathrm{dis}}^{+}|, |S_{\\mathrm{drug}}^{-}|)} = \\frac{46}{150}$$\n为了将其表示为最简的精确分数，我们找到分子和分母的最大公约数。$46$ 和 $150$ 都可以被 $2$ 整除：\n$$O(S_{\\mathrm{dis}}^{+}, S_{\\mathrm{drug}}^{-}) = \\frac{46 \\div 2}{150 \\div 2} = \\frac{23}{75}$$\n\n**重叠系数的解释性局限**\n\n从集合论的第一性原理来看，重叠系数衡量的是较小集合被包含在较大集合中的程度。在此背景下，它量化了药物下调的基因中有多大比例存在于疾病上调的基因集合中。我们的结果 $O = \\frac{23}{75}$ 意味着，在药物特征 ($S_{\\mathrm{drug}}^{-}$) 中的 $150$ 个基因中，有 $46$ 个成功地抵消了疾病特征 ($S_{\\mathrm{dis}}^{+}$) 中的基因。\n\n重叠系数的主要局限在于其不对称性以及对较大集合大小的不敏感性。这可以通过将其与对称相似性度量（如 Jaccard 指数 $J(A, B)$）进行比较来理解。Jaccard 指数定义为交集大小与并集大小的比率：\n$$J(A, B) = \\frac{|A \\cap B|}{|A \\cup B|}$$\n根据容斥原理，并集为 $|A \\cup B| = |A| + |B| - |A \\cap B|$。对于给定的问题：\n$$|S_{\\mathrm{dis}}^{+} \\cup S_{\\mathrm{drug}}^{-}| = 200 + 150 - 46 = 304$$\nJaccard 指数将是：\n$$J(S_{\\mathrm{dis}}^{+}, S_{\\mathrm{drug}}^{-}) = \\frac{46}{304} = \\frac{23}{152}$$\n\n解释性局限源于每个系数的分母所代表的含义：\n1.  **重叠系数的分母：** 分母是 $\\min(|A|, |B|)$。该系数忽略了较大集合中不在交集里的元素数量。在我们的案例中，*未被*药物抵消的疾病上调基因数量为 $|S_{\\mathrm{dis}}^{+} \\setminus S_{\\mathrm{drug}}^{-}| = |S_{\\mathrm{dis}}^{+}| - |S_{\\mathrm{dis}}^{+} \\cap S_{\\mathrm{drug}}^{-}| = 200 - 46 = 154$。$\\frac{23}{75}$ 的重叠系数并未反映出大量未被处理的疾病基因。如果疾病特征要大得多，比如 $|S_{\\mathrm{dis}}^{+}| = 2000$，而所有其他值保持不变，重叠系数仍将是 $\\frac{23}{75}$，这可能会误导性地表明该药物同样有效，而实际上它现在只处理了全部疾病病理中一个更小的部分。因此，重叠系数对于回答子集关系问题（例如，“药物的作用机制是否完全包含在疾病机制内？”）很有用，但它未能对逆转的不完整性进行惩罚。\n\n2.  **Jaccard 指数的分母：** 分母是 $|A \\cup B|$，即两个集合中所有独有元素的总数。它既考虑了集合 $A$ 的独有元素 ($A \\setminus B$)，也考虑了集合 $B$ 的独有元素 ($B \\setminus A$)。这些集合分别代表未被药物调节的疾病基因，以及与疾病特征无关的药物调节基因（潜在的“脱靶效应”）。Jaccard 指数对双向的差异都进行惩罚，从而提供了一种更平衡、通常也更保守的整体相似性度量。一个低的 Jaccard 指数，比如我们计算出的 $\\frac{23}{152}$，正确地表明，尽管相对于药物特征的大小有中等程度的重叠，但在考虑所涉及的基因总数时，这两个集合总体上是相当不相似的。\n\n总之，在此科学背景下，重叠系数的主要局限性在于，即使药物只处理了一个大型疾病特征中的一小部分，它也可能产生高分，从而可能夸大药物的治疗相关性。像 Jaccard 指数这样的对称度量，通过考虑共享和非共享元素的全部范围，为全局相似性提供了更稳健的评估。", "answer": "$$\\boxed{\\frac{23}{75}}$$", "id": "4549869"}, {"introduction": "在处理真实世界的观测数据（如药物不良事件报告）时，我们面临着更复杂的挑战。本练习将引导你探讨一种关键的统计陷阱——对撞偏倚（collider bias），它可能导致在分析中出现虚假的药物-疾病关联。通过编写一个模拟程序，你将直观且定量地理解这种偏倚是如何产生的，以及为何在药物重定位研究中识别并处理它至关重要 [@problem_id:4549832]。", "problem": "您正在使用观测数据研究计算药物重定位策略，在这些数据中，药物不良事件（AE）报告很常见。考虑一个包含每个个体三个二元变量的最小概率模型：$D \\in \\{0,1\\}$ 表示药物暴露，$Y \\in \\{0,1\\}$ 表示疾病状态，以及 $E \\in \\{0,1\\}$ 表示存在不良事件报告。假设在人群中 $D$ 和 $Y$ 是独立的，并且都通过逻辑斯谛机制影响 $E$。在这种情况下，请用概率和条件独立性的术语解释，对存在不良事件（即，将分析限制在 $E=1$）进行条件化，如何在 $D$ 和 $Y$ 之间的关联中引入对撞偏倚，在为药物重定位进行药物-疾病关联分析时，避免这种偏倚至关重要。\n\n从以下基本基础和定义出发：\n- 概率的链式法则和贝叶斯法则：对于事件 $A$、$B$ 和 $C$，$P(A,B|C) = \\dfrac{P(C|A,B)P(A)P(B)}{\\sum_{a \\in \\{0,1\\}}\\sum_{b \\in \\{0,1\\}} P(C|a,b)P(a)P(b)}$，以及条件独立性 $A \\perp B$ 意味着 $P(A,B) = P(A)P(B)$。\n- 有向无环图（DAG）中对撞因子的概念：一个变量 $E$，它至少有两个父变量 $D$ 和 $Y$，表示为 $D \\rightarrow E \\leftarrow Y$，其中对对撞因子进行条件化，即使其父变量边际独立，也可能在其父变量之间诱导出依赖关系。\n- 逻辑斯谛函数 $\\sigma(z) = \\dfrac{1}{1+\\exp(-z)}$，广泛用于给定线性预测器 $z$ 的二元事件概率。\n\n实现一个自包含的程序，该程序使用以下生成模型模拟一个包含 $N$ 个独立个体的群体：\n1.  独立地抽样 $D \\sim \\text{Bernoulli}(p_D)$ 和 $Y \\sim \\text{Bernoulli}(p_Y)$。\n2.  给定 $(D,Y)$，抽样 $E \\sim \\text{Bernoulli}(\\sigma(\\alpha + \\beta_D D + \\beta_Y Y + \\beta_{DY} D Y))$。\n\n对于每个模拟数据集，计算 $D$ 和 $Y$ 之间的两种关联度量：\n- 边际对数优势比 $\\log(\\mathrm{OR}_{\\text{marginal}})$，在整个人群上计算，使用 $2 \\times 2$ 列联表计数 $(a,b,c,d)$，其中 $a$ 是 $(D=1,Y=1)$ 的计数，$b$ 是 $(D=1,Y=0)$ 的计数，$c$ 是 $(D=0,Y=1)$ 的计数，$d$ 是 $(D=0,Y=0)$ 的计数，计算公式为 $\\log\\left(\\dfrac{(a+\\delta)(d+\\delta)}{(b+\\delta)(c+\\delta)}\\right)$，并使用连续性校正 $\\delta = 0.5$ 以防止零计数。\n- 条件对数优势比 $\\log(\\mathrm{OR}_{E=1})$，计算方法类似，但仅限于 $E=1$ 的个体。\n\n报告每个测试案例的对撞偏倚大小，定义为 $\\log(\\mathrm{OR}_{E=1}) - \\log(\\mathrm{OR}_{\\text{marginal}})$。此问题不涉及物理单位。所有角度（如果出现）必须以弧度为单位，但此处不需要。所有比例必须表示为十进制数。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试案例的结果必须是三个浮点数的列表，顺序为 $[\\log(\\mathrm{OR}_{\\text{marginal}}), \\log(\\mathrm{OR}_{E=1}), \\log(\\mathrm{OR}_{E=1}) - \\log(\\mathrm{OR}_{\\text{marginal}})]$。因此，最后一行应类似于 $[[x_1,y_1,z_1],[x_2,y_2,z_2],\\dots]$，其中每个 $x_i$、$y_i$ 和 $z_i$ 都是十进制数。\n\n使用以下测试套件以确保覆盖不同情景（每个案例包括 $N$、$p_D$、$p_Y$、$\\alpha$、$\\beta_D$、$\\beta_Y$、$\\beta_{DY}$ 和一个用于可复现性的随机种子）：\n- 案例1（中等选择下的正常路径）：$N=300000, p_D=0.5, p_Y=0.3, \\alpha=-2.5, \\beta_D=2.0, \\beta_Y=1.5, \\beta_{DY}=0.0$, 种子 $17$。\n- 案例2（不存在对撞效应的边界情况）：$N=300000, p_D=0.5, p_Y=0.5, \\alpha=-2.5, \\beta_D=0.0, \\beta_Y=0.0, \\beta_{DY}=0.0$, 种子 $42$。\n- 案例3（具有交互作用的强选择）：$N=300000, p_D=0.4, p_Y=0.2, \\alpha=-4.0, \\beta_D=3.5, \\beta_Y=3.0, \\beta_{DY}=2.0$, 种子 $123$。\n- 案例4（罕见事件但效应强）：$N=500000, p_D=0.1, p_Y=0.1, \\alpha=-6.0, \\beta_D=4.0, \\beta_Y=4.0, \\beta_{DY}=0.0$, 种子 $777$。\n- 案例5（小样本以暴露抽样变异性）：$N=500, p_D=0.4, p_Y=0.4, \\alpha=-2.0, \\beta_D=2.0, \\beta_Y=2.0, \\beta_{DY}=0.0$, 种子 $2048$。\n\n您的最终输出必须将所有提供的测试案例的结果聚合到单行中，并严格按照指定格式。", "solution": "问题陈述按如下方式进行了严格验证。\n\n### 第1步：提取已知信息\n- **变量**：每个个体的三个二元变量：$D \\in \\{0,1\\}$（药物暴露），$Y \\in \\{0,1\\}$（疾病状态）和 $E \\in \\{0,1\\}$（不良事件报告）。\n- **基本假设**：\n    - 在人群中，药物暴露 $D$ 和疾病状态 $Y$ 是独立的，即 $D \\perp Y$。\n    - $D$ 和 $Y$ 都影响 $E$。\n- **概率模型（生成过程）**：\n    1.  $D \\sim \\text{Bernoulli}(p_D)$\n    2.  $Y \\sim \\text{Bernoulli}(p_Y)$\n    3.  $E | D, Y \\sim \\text{Bernoulli}(P(E=1|D,Y))$ 其中 $P(E=1|D,Y) = \\sigma(\\alpha + \\beta_D D + \\beta_Y Y + \\beta_{DY} D Y)$。\n- **定义与公式**：\n    - 逻辑斯谛函数: $\\sigma(z) = \\dfrac{1}{1+\\exp(-z)}$。\n    - 对撞因子：在有向无环图（DAG）中，一个变量 $E$ 有父变量 $D$ 和 $Y$，表示为 $D \\rightarrow E \\leftarrow Y$。\n    - 关联度量：\n        - 边际对数优势比，$\\log(\\mathrm{OR}_{\\text{marginal}})$，在整个人群上计算。\n        - 条件对数优势比，$\\log(\\mathrm{OR}_{E=1})$，在 $E=1$ 的子人群上计算。\n    - 对数优势比计算：$\\log\\left(\\dfrac{(a+\\delta)(d+\\delta)}{(b+\\delta)(c+\\delta)}\\right)$，使用连续性校正 $\\delta = 0.5$。计数 $(a,b,c,d)$ 分别对应 $(D=1,Y=1)$、$(D=1,Y=0)$、$(D=0,Y=1)$ 和 $(D=0,Y=0)$。\n- **任务**：\n    1.  解释以 $E=1$ 为条件如何引入对撞偏倚。\n    2.  实现一个模拟来计算对撞偏倚的大小，定义为 $\\log(\\mathrm{OR}_{E=1}) - \\log(\\mathrm{OR}_{\\text{marginal}})$。\n- **测试套件**：\n    - 案例1：$N=300000, p_D=0.5, p_Y=0.3, \\alpha=-2.5, \\beta_D=2.0, \\beta_Y=1.5, \\beta_{DY}=0.0$, 种子 $17$。\n    - 案例2：$N=300000, p_D=0.5, p_Y=0.5, \\alpha=-2.5, \\beta_D=0.0, \\beta_Y=0.0, \\beta_{DY}=0.0$, 种子 $42$。\n    - 案例3：$N=300000, p_D=0.4, p_Y=0.2, \\alpha=-4.0, \\beta_D=3.5, \\beta_Y=3.0, \\beta_{DY}=2.0$, 种子 $123$。\n    - 案例4：$N=500000, p_D=0.1, p_Y=0.1, \\alpha=-6.0, \\beta_D=4.0, \\beta_Y=4.0, \\beta_{DY}=0.0$, 种子 $777$。\n    - 案例5：$N=500, p_D=0.4, p_Y=0.4, \\alpha=-2.0, \\beta_D=2.0, \\beta_Y=2.0, \\beta_{DY}=0.0$, 种子 $2048$。\n- **输出格式**：单行 `[[x1,y1,z1],[x2,y2,z2],...]`，其中每个内层列表包含 $[\\log(\\mathrm{OR}_{\\text{marginal}}), \\log(\\mathrm{OR}_{E=1}), \\log(\\mathrm{OR}_{E=1}) - \\log(\\mathrm{OR}_{\\text{marginal}})]$。\n\n### 第2步：使用提取的已知信息进行验证\n根据验证标准对问题进行评估。\n- **有科学依据的**：问题在根本上是合理的。它描述了对撞偏倚，这是流行病学、因果推断和统计学中的一个基石概念。使用逻辑斯谛模型表示两个父变量对一个二元子变量的影响是标准做法。药物-疾病-不良事件的情景是这种偏倚在现实世界医疗数据分析中可能出现的典型例子。\n- **良定的**：问题是良定的。生成模型被完整指定，要计算的量有明确定义，并且模拟的所有参数都已提供，包括用于可复现性的随机种子。对于每个测试案例，都存在一个唯一的、稳定的解（在模拟随机性的范围内）。\n- **客观的**：问题使用正式、数学和客观的语言陈述，没有任何主观或基于意见的主张。\n- **缺陷清单**：问题没有表现出任何列出的缺陷。它在科学上是有效的，可形式化的，完整的，对于模拟情景是现实的，并且并非微不足道。其中控制案例（案例2）的设计旨在使对撞效应不存在，这展示了一个结构良好的问题设计。\n\n### 第3步：结论与行动\n问题是**有效的**。将生成一个解决方案。\n\n### 基于原理的解决方案\n当分析以一个作为另外两个变量的共同效应的变量为条件时，就会出现对撞偏倚现象。在这个问题中，不良事件 $E$ 是药物暴露 $D$ 和疾病状态 $Y$ 的一个共同效应（一个“对撞因子”）。问题指定 $D$ 和 $Y$ 在总人群中是独立的。这种形式化的因果结构可以用有向无环图（DAG）表示：$D \\rightarrow E \\leftarrow Y$。对撞偏倚的核心是，即使 $D$ 和 $Y$ 在边际上是独立的（即 $D \\perp Y$），在给定它们的共同效应 $E$ 的条件下，它们也会变得条件相关（即 $D \\not\\perp Y | E$）。\n\n**概率论解释**\n\n我们从边际独立性的前提开始：$P(D,Y) = P(D)P(Y)$。我们的目标是评估在给定 $E=1$ 的条件下 $D$ 和 $Y$ 的独立性。条件独立性当且仅当 $P(D,Y|E=1) = P(D|E=1)P(Y|E=1) $ 时成立。\n\n使用贝叶斯法则，给定 $E=1$ 时 $D$ 和 $Y$ 的联合概率为：\n$$ P(D=d, Y=y | E=1) = \\frac{P(E=1|D=d, Y=y) P(D=d, Y=y)}{P(E=1)} $$\n考虑到 $D$ 和 $Y$ 的边际独立性，这变为：\n$$ P(D=d, Y=y | E=1) = \\frac{P(E=1|D=d, Y=y) P(D=d) P(Y=y)}{P(E=1)} $$\n分母 $P(E=1)$ 是一个归一化常数，通过对 $D$ 和 $Y$ 的所有可能状态求和得到：\n$$ P(E=1) = \\sum_{d' \\in \\{0,1\\}} \\sum_{y' \\in \\{0,1\\}} P(E=1|D=d', Y=y') P(D=d') P(Y=y') $$\n为了使条件独立性成立，联合分布必须能够分解为其边际分布的乘积。让我们检查 $D$ 的条件边际：\n$$ P(D=d | E=1) = \\sum_{y \\in \\{0,1\\}} P(D=d, Y=y|E=1) = \\frac{P(D=d)}{P(E=1)} \\sum_{y \\in \\{0,1\\}} P(E=1|D=d, Y=y) P(Y=y) $$\n$P(Y=y|E=1)$ 也有一个类似的表达式。独立性 $D \\perp Y | E=1$ 将在以下条件下成立：\n$$ \\frac{P(E=1|d,y) P(d) P(y)}{P(E=1)} = \\left( \\frac{P(d)}{P(E=1)} \\sum_{y'} P(E=1|d,y')P(y') \\right) \\left( \\frac{P(y)}{P(E=1)} \\sum_{d'} P(E=1|d',y)P(d') \\right) $$\n这可以简化为：\n$$ P(E=1|d,y) P(E=1) = \\left( \\sum_{y'} P(E=1|d,y')P(y') \\right) \\left( \\sum_{d'} P(E=1|d',y)P(d') \\right) $$\n这个等式通常不成立。它仅在特定情况下成立，例如，如果 $P(E=1|d,y)$ 相对于 $d$ 或 $y$ 是常数（即 $\\beta_D=0$ 或 $\\beta_Y=0$，假设 $\\beta_{DY}=0$）。如果 $D$ 和 $Y$ 都影响 $E$（即 $\\beta_D \\neq 0$ 和 $\\beta_Y \\neq 0$），那么在条件化时独立性就被破坏了。\n\n**直观解释及其与药物重定位的相关性**\n\n这种诱导出的相关性就是产生偏倚的原因。想象一个场景，其中服药（$D=1$）和患有某种疾病（$Y=1$）都会增加发生不良事件（$E=1$）的几率。当我们分析一个只包含报告了不良事件的个体（即我们以 $E=1$ 为条件）的数据库时，我们正在选择人口中一个特定的、非随机的部分。在这个子人群中，如果我们知道一个人有不良事件但没有服药（$D=0$），那么他们患有该疾病（$Y=1$）的可能性就变得更大，以“解释”这个不良事件。反之，知道他们服了药（$D=1$）使得疾病作为一种解释变得“不那么必要”。这就在选定的组中造成了 $D$ 和 $Y$ 之间的伪负相关。\n\n在计算药物重定位中，研究人员经常挖掘大型观测数据库，例如不良事件报告系统（如FAERS），以寻找新的药物-疾病关联。如果一种药物和一种疾病都独立地与不良事件报告率的增加相关，那么仅限于该数据库的分析可能会发现一种伪负相关。这可能错误地暗示该药物对该疾病具有保护作用，这是对撞偏倚的一个典型陷阱。下面的模拟将定量地展示这种效应。\n\n**模拟的算法设计**\n\n为了证明这一点，我们将实现以下算法：\n1. 对于每个测试案例，我们使用指定的种子初始化一个随机数生成器，以保证可复现性。\n2. 我们通过独立抽取 $D \\sim \\text{Bernoulli}(p_D)$ 和 $Y \\sim \\text{Bernoulli}(p_Y)$ 来模拟一个包含 $N$ 个个体的群体。这一步强制执行了 $D$ 和 $Y$ 边际独立的基本事实。\n3. 我们为每个个体计算线性预测器 $z = \\alpha + \\beta_D D + \\beta_Y Y + \\beta_{DY} DY$。\n4. 然后我们计算不良事件的概率 $p_E = \\sigma(z) = (1 + \\exp(-z))^{-1}$。\n5. 我们为每个个体抽样不良事件状态 $E \\sim \\text{Bernoulli}(p_E)$。\n6. 我们定义一个函数，用于根据计数计算对数优势比，并应用指定的连续性校正 $\\delta=0.5$。\n7. a. 我们使用整个人群数据 $(D, Y)$ 计算 $\\log(\\mathrm{OR}_{\\text{marginal}})$。根据设计，这个值应该接近于 $0$。\n7. b. 我们通过只选择 $E=1$ 的个体来创建一个子人群。\n7. c. 我们在这个子人群上计算 $\\log(\\mathrm{OR}_{E=1})$。这个值预期不为零（在给定情景中，当效应为正时，通常为负），反映了诱导出的关联。\n8. 然后，将对撞偏倚计算为差值 $\\log(\\mathrm{OR}_{E=1}) - \\log(\\mathrm{OR}_{\\text{marginal}})$。\n\n这个过程通过生成真实边际关联已知（为零）的数据，并测量在对撞因子上进行条件化后出现的伪关联，直接测试了理论预测。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates collider bias in a drug-disease-adverse event model and\n    reports marginal and conditional log odds ratios.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, p_D, p_Y, alpha, beta_D, beta_Y, beta_DY, seed)\n        (300000, 0.5, 0.3, -2.5, 2.0, 1.5, 0.0, 17),\n        (300000, 0.5, 0.5, -2.5, 0.0, 0.0, 0.0, 42),\n        (300000, 0.4, 0.2, -4.0, 3.5, 3.0, 2.0, 123),\n        (500000, 0.1, 0.1, -6.0, 4.0, 4.0, 0.0, 777),\n        (500, 0.4, 0.4, -2.0, 2.0, 2.0, 0.0, 2048),\n    ]\n\n    results = []\n    \n    def calculate_log_or(d_arr, y_arr, delta=0.5):\n        \"\"\"\n        Calculates the log odds ratio from two binary arrays D and Y.\n        Uses a continuity correction to handle zero counts.\n        \"\"\"\n        if d_arr.size == 0 or y_arr.size == 0:\n            # If the conditioned subset is empty, there's no association to compute.\n            return 0.0\n\n        # Contingency table counts\n        # a: D=1, Y=1\n        # b: D=1, Y=0\n        # c: D=0, Y=1\n        # d: D=0, Y=0\n        a = np.sum((d_arr == 1)  (y_arr == 1))\n        b = np.sum((d_arr == 1)  (y_arr == 0))\n        c = np.sum((d_arr == 0)  (y_arr == 1))\n        d = np.sum((d_arr == 0)  (y_arr == 0))\n        \n        # Apply continuity correction\n        a_corr, b_corr, c_corr, d_corr = a + delta, b + delta, c + delta, d + delta\n        \n        # Calculate log odds ratio\n        log_or = np.log((a_corr * d_corr) / (b_corr * c_corr))\n        return log_or\n\n    for case in test_cases:\n        N, p_D, p_Y, alpha, beta_D, beta_Y, beta_DY, seed = case\n        \n        # for reproducibility\n        rng = np.random.default_rng(seed)\n        \n        # Step 1: Sample D and Y independently\n        D = rng.binomial(1, p_D, size=N)\n        Y = rng.binomial(1, p_Y, size=N)\n        \n        # Step 2: Sample E based on D and Y via a logistic model\n        z = alpha + beta_D * D + beta_Y * Y + beta_DY * D * Y\n        p_E = 1 / (1 + np.exp(-z))\n        E = rng.binomial(1, p_E, size=N)\n        \n        # Compute marginal log odds ratio (full population)\n        log_or_marginal = calculate_log_or(D, Y)\n        \n        # Filter for individuals with the adverse event (E=1)\n        D_cond = D[E == 1]\n        Y_cond = Y[E == 1]\n        \n        # Compute conditional log odds ratio (E=1 subpopulation)\n        log_or_cond = calculate_log_or(D_cond, Y_cond)\n        \n        # Calculate the collider bias magnitude\n        bias = log_or_cond - log_or_marginal\n        \n        results.append([log_or_marginal, log_or_cond, bias])\n\n    # Format the results into the required string representation\n    results_str = \",\".join([str(res) for res in results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```", "id": "4549832"}]}