{"hands_on_practices": [{"introduction": "评分函数通常将复杂的结合自由能分解为多个独立的能量项，以便于计算和理解。本练习将聚焦于其中一个关键的物理化学驱动力——疏水效应，它通过溶剂可及表面积（SASA）的变化来量化。通过亲手计算结合过程中非极性溶剂化能的变化，你将深入理解隐式溶剂模型的核心原理，这是许多现代评分函数的重要组成部分 ([@problem_id:4599774])。", "problem": "一个对接打分函数包含一个非极性溶剂化自由能项，该项被建模为比例常数与溶剂可及表面积（SASA）的乘积，再加上一个偏移量。非极性溶剂化自由能由表达式 $$G_{\\mathrm{np}} = \\gamma A + c,$$ 近似给出，其中 $G_{\\mathrm{np}}$ 是非极性溶剂化自由能，$\\gamma$ 是一个比例常数，$A$ 是溶剂可及表面积（SASA），$c$ 是与溶质相关的偏移常数。溶剂可及表面积（SASA）定义为溶剂探针中心在溶质的范德华表面上滚动时所描绘的面积。\n\n考虑一个配体与蛋白质结合形成一个复合物。自由蛋白质的SASA为 $A_{\\mathrm{protein}} = 8.200 \\times 10^{3}\\ \\text{Å}^2$，自由配体的SASA为 $A_{\\mathrm{ligand}} = 6.50 \\times 10^{2}\\ \\text{Å}^2$，蛋白质-配体复合物的SASA为 $A_{\\mathrm{complex}} = 7.800 \\times 10^{3}\\ \\text{Å}^2$。非极性参数为 $\\gamma = 5.42 \\times 10^{-3}\\ \\text{kcal}\\,\\text{mol}^{-1}\\,\\text{Å}^{-2}$，偏移常数为 $c = 0.92\\ \\text{kcal}\\,\\text{mol}^{-1}$ 每个溶质。假设偏移量 $c$ 对每个不同的溶质实体（自由蛋白质、自由配体和复合物）应用一次，并且数值相同。\n\n从结合自由能变化的定义（复合物的自由能减去孤立组分的自由能之和）出发，推导结合时非极性溶剂化自由能变化的表达式 $$\\Delta G_{\\mathrm{np,bind}} = G_{\\mathrm{np}}(\\mathrm{complex}) - G_{\\mathrm{np}}(\\mathrm{protein}) - G_{\\mathrm{np}}(\\mathrm{ligand}),$$ 并计算其数值。使用 $1\\ \\text{kcal} = 4.184\\ \\text{kJ}$ 将最终能量转换为 $\\text{kJ}\\,\\text{mol}^{-1}$。你的最终答案需要用 $\\text{kJ}\\,\\text{mol}^{-1}$ 表示，并四舍五入到四位有效数字。", "solution": "首先对问题进行验证，以确保其科学上合理、定义明确且客观。\n\n### 步骤 1：提取给定信息\n-   非极性溶剂化自由能的模型为 $G_{\\mathrm{np}} = \\gamma A + c$。\n-   $G_{\\mathrm{np}}$ 是非极性溶剂化自由能。\n-   $\\gamma$ 是比例常数，给定值为 $\\gamma = 5.42 \\times 10^{-3}\\ \\text{kcal}\\,\\text{mol}^{-1}\\,\\text{Å}^{-2}$。\n-   $A$ 是溶剂可及表面积（SASA）。\n-   $c$ 是偏移常数，给定值为 $c = 0.92\\ \\text{kcal}\\,\\text{mol}^{-1}$ 每个溶质。\n-   自由蛋白质的SASA：$A_{\\mathrm{protein}} = 8.200 \\times 10^{3}\\ \\text{Å}^2$。\n-   自由配体的SASA：$A_{\\mathrm{ligand}} = 6.50 \\times 10^{2}\\ \\text{Å}^2$。\n-   蛋白质-配体复合物的SASA：$A_{\\mathrm{complex}} = 7.800 \\times 10^{3}\\ \\text{Å}^2$。\n-   偏移量 $c$ 对每个不同的溶质实体（蛋白质、配体、复合物）应用一次。\n-   结合时非极性溶剂化自由能的变化定义为 $\\Delta G_{\\mathrm{np,bind}} = G_{\\mathrm{np}}(\\mathrm{complex}) - G_{\\mathrm{np}}(\\mathrm{protein}) - G_{\\mathrm{np}}(\\mathrm{ligand})$。\n-   转换因子为 $1\\ \\text{kcal} = 4.184\\ \\text{kJ}$。\n-   最终答案必须以 $\\text{kJ}\\,\\text{mol}^{-1}$ 为单位，并四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的给定信息进行验证\n-   **科学依据**：该问题基于生物物理化学和计算生物学的原理。模型 $G_{\\mathrm{np}} = \\gamma A + c$ 代表了一种计算分子力学力场和对接打分函数中溶剂化自由能非极性分量的标准（尽管简化了的）方法。SASA的概念及其在结合过程中的变化（埋藏表面积）是理解蛋白质-配体相互作用中疏水效应的基础。所提供的SASA数值对于典型的蛋白质-配体系统是现实的，$\\gamma$ 的值也在该类模型的可接受范围内。\n-   **定义明确**：该问题定义明确。它提供了所有必要的数据，清晰地定义了待计算的量，并对最终输出格式给出了明确的说明。存在唯一的解。\n-   **客观性**：该问题以精确、客观和技术性的语言陈述，不含任何主观或偏见内容。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。这是生物信息学和医学数据分析领域的标准计算。现在将推导解答过程。\n\n结合时非极性溶剂化自由能的变化 $\\Delta G_{\\mathrm{np,bind}}$ 定义为产物（复合物）的自由能与反应物（自由蛋白质和自由配体）的自由能之差。\n$$\n\\Delta G_{\\mathrm{np,bind}} = G_{\\mathrm{np}}(\\mathrm{complex}) - (G_{\\mathrm{np}}(\\mathrm{protein}) + G_{\\mathrm{np}}(\\mathrm{ligand}))\n$$\n$$\n\\Delta G_{\\mathrm{np,bind}} = G_{\\mathrm{np}}(\\mathrm{complex}) - G_{\\mathrm{np}}(\\mathrm{protein}) - G_{\\mathrm{np}}(\\mathrm{ligand})\n$$\n问题指定了非极性溶剂化自由能的模型为 $G_{\\mathrm{np}} = \\gamma A + c$，其中 $\\gamma$ 是表面张力系数，$A$ 是溶剂可及表面积（SASA），$c$ 是一个偏移常数。问题明确指出 $c$ 对每个不同的溶质实体应用一次。我们将此模型应用于结合方程中的每一项：\n-   对于复合物（一个溶质实体）：$G_{\\mathrm{np}}(\\mathrm{complex}) = \\gamma A_{\\mathrm{complex}} + c$\n-   对于自由蛋白质（一个溶质实体）：$G_{\\mathrm{np}}(\\mathrm{protein}) = \\gamma A_{\\mathrm{protein}} + c$\n-   对于自由配体（一个溶质实体）：$G_{\\mathrm{np}}(\\mathrm{ligand}) = \\gamma A_{\\mathrm{ligand}} + c$\n\n将这些表达式代入 $\\Delta G_{\\mathrm{np,bind}}$ 的方程中：\n$$\n\\Delta G_{\\mathrm{np,bind}} = (\\gamma A_{\\mathrm{complex}} + c) - (\\gamma A_{\\mathrm{protein}} + c) - (\\gamma A_{\\mathrm{ligand}} + c)\n$$\n分配负号并合并各项：\n$$\n\\Delta G_{\\mathrm{np,bind}} = \\gamma A_{\\mathrm{complex}} + c - \\gamma A_{\\mathrm{protein}} - c - \\gamma A_{\\mathrm{ligand}} - c\n$$\n$$\n\\Delta G_{\\mathrm{np,bind}} = \\gamma (A_{\\mathrm{complex}} - A_{\\mathrm{protein}} - A_{\\mathrm{ligand}}) + (c - c - c)\n$$\n这简化为：\n$$\n\\Delta G_{\\mathrm{np,bind}} = \\gamma (A_{\\mathrm{complex}} - A_{\\mathrm{protein}} - A_{\\mathrm{ligand}}) - c\n$$\n项 $(A_{\\mathrm{complex}} - A_{\\mathrm{protein}} - A_{\\mathrm{ligand}})$ 代表结合时总SASA的变化，我们将其表示为 $\\Delta A_{\\mathrm{bind}}$。\n首先，我们使用所给数值计算 $\\Delta A_{\\mathrm{bind}}$：\n$A_{\\mathrm{protein}} = 8.200 \\times 10^{3}\\ \\text{Å}^2$\n$A_{\\mathrm{ligand}} = 6.50 \\times 10^{2}\\ \\text{Å}^2 = 0.650 \\times 10^{3}\\ \\text{Å}^2$\n$A_{\\mathrm{complex}} = 7.800 \\times 10^{3}\\ \\text{Å}^2$\n$$\n\\Delta A_{\\mathrm{bind}} = (7.800 \\times 10^{3}\\ \\text{Å}^2) - (8.200 \\times 10^{3}\\ \\text{Å}^2) - (0.650 \\times 10^{3}\\ \\text{Å}^2)\n$$\n$$\n\\Delta A_{\\mathrm{bind}} = (7.800 - 8.200 - 0.650) \\times 10^{3}\\ \\text{Å}^2 = -1.050 \\times 10^{3}\\ \\text{Å}^2\n$$\n这个负值表示溶剂暴露表面积的减少，这在结合时是预期的。这种减少通常被称为埋藏表面积（BSA）。\n\n现在，我们将 $\\gamma$、$\\Delta A_{\\mathrm{bind}}$ 和 $c$ 的值代入 $\\Delta G_{\\mathrm{np,bind}}$ 的简化方程中。\n$\\gamma = 5.42 \\times 10^{-3}\\ \\text{kcal}\\,\\text{mol}^{-1}\\,\\text{Å}^{-2}$\n$c = 0.92\\ \\text{kcal}\\,\\text{mol}^{-1}$\n$$\n\\Delta G_{\\mathrm{np,bind}} = (5.42 \\times 10^{-3}\\ \\text{kcal}\\,\\text{mol}^{-1}\\,\\text{Å}^{-2}) \\times (-1.050 \\times 10^{3}\\ \\text{Å}^2) - 0.92\\ \\text{kcal}\\,\\text{mol}^{-1}\n$$\n计算第一项：\n$$\n(5.42 \\times 10^{-3}) \\times (-1.050 \\times 10^{3}) = (5.42 \\times -1.050) = -5.691\\ \\text{kcal}\\,\\text{mol}^{-1}\n$$\n现在，减去偏移常数 $c$：\n$$\n\\Delta G_{\\mathrm{np,bind}} = -5.691\\ \\text{kcal}\\,\\text{mol}^{-1} - 0.92\\ \\text{kcal}\\,\\text{mol}^{-1} = -6.611\\ \\text{kcal}\\,\\text{mol}^{-1}\n$$\n问题要求最终答案以 $\\text{kJ}\\,\\text{mol}^{-1}$ 为单位。我们使用转换因子 $1\\ \\text{kcal} = 4.184\\ \\text{kJ}$。\n$$\n\\Delta G_{\\mathrm{np,bind}}[\\text{kJ}\\,\\text{mol}^{-1}] = -6.611\\ \\text{kcal}\\,\\text{mol}^{-1} \\times 4.184\\ \\frac{\\text{kJ}}{\\text{kcal}}\n$$\n$$\n\\Delta G_{\\mathrm{np,bind}}[\\text{kJ}\\,\\text{mol}^{-1}] = -27.660124\\ \\text{kJ}\\,\\text{mol}^{-1}\n$$\n最后，我们按照题目要求将结果四舍五入到四位有效数字。\n$$\n\\Delta G_{\\mathrm{np,bind}} \\approx -27.66\\ \\text{kJ}\\,\\text{mol}^{-1}\n$$", "answer": "$$\n\\boxed{-27.66}\n$$", "id": "4599774"}, {"introduction": "理解了评分函数的单个能量项后，下一步是学习如何将这些项（或特征）组合成一个有预测能力的完整模型。本练习将指导你构建一个经验评分函数，这需要将线性模型拟合到实验测量的结合亲和力数据上。你将从第一性原理出发推导正规方程，并将其应用于确定不同相互作用特征的最佳权重，这是开发许多广泛使用的评分函数的基础技术 ([@problem_id:4599711])。", "problem": "在经验性的蛋白质-配体对接中，通常使用线性打分函数，从一组概括了分子间相互作用的工程化特征中，近似计算负的标准结合自由能，记作 $-\\Delta G^{\\circ}$。考虑一个形式如下的线性打分函数\n$$\nE(x; w) \\equiv \\sum_{k=0}^{p-1} w_k\\, f_k(x),\n$$\n其中 $f_0(x) \\equiv 1$ 是一个截距特征，当 $k \\geq 1$ 时，$f_k(x)$ 是针对复合物 $x$ 的预计算特征。假设对于 $i \\in \\{1,\\dots,n\\}$ 的复合物，测量值遵循加性噪声模型 $y_i = E(x_i; w) + \\varepsilon_i$，其中 $\\varepsilon_i$ 是独立的、零均值的、具有有限方差的波动。请您从第一性原理出发，推导在普通最小二乘法 (OLS) 意义下，使残差平方和最小化的参数矢量 $w$ 所需满足的必要最优性条件。您的推导必须从最小二乘目标的标量形式定义开始，并进行到严格的矩阵-矢量形式。\n\n然后，使用相同的线性模型 $E(x; w)$，其中有 $p = 3$ 个特征（一个截距加上两个标准化的相互作用特征），将 $w$ 拟合到以下包含 $n = 4$ 个蛋白质-配体复合物的训练集。特征 $f_1$ 和 $f_2$ 已在训练集上被标准化为零均值，并被构造成彼此之间以及与截距均不相关：\n- 复合物 $i=1$：$(f_0, f_1, f_2) = (1, -1, -1)$，测量值 $y_1 = 10\\ \\text{kJ/mol}$。\n- 复合物 $i=2$：$(f_0, f_1, f_2) = (1, -1, 1)$，测量值 $y_2 = 14\\ \\text{kJ/mol}$。\n- 复合物 $i=3$：$(f_0, f_1, f_2) = (1, 1, -1)$，测量值 $y_3 = 18\\ \\text{kJ/mol}$。\n- 复合物 $i=4$：$(f_0, f_1, f_2) = (1, 1, 1)$，测量值 $y_4 = 22\\ \\text{kJ/mol}$。\n\n通过最小二乘法拟合 $w$ 后，为一个具有标准化特征 $(f_0, f_1, f_2) = (1, 0.3, -0.7)$ 的新复合物 $x^{\\ast}$ 预测其得分 $E(x^{\\ast}; w)$（可解释为 $-\\Delta G^{\\circ}$）。将您的最终数值预测四舍五入到四位有效数字。以 $\\text{kJ/mol}$ 为单位表示最终能量。", "solution": "根据既定的验证标准对用户提供的问题进行评估。\n\n### 第 1 步：提取已知条件\n-   **模型**：线性打分函数 $E(x; w) \\equiv \\sum_{k=0}^{p-1} w_k\\, f_k(x)$ 近似负的标准结合自由能 $-\\Delta G^{\\circ}$。\n-   **截距**：第一个特征是截距，$f_0(x) \\equiv 1$。\n-   **数据模型**：测量值遵循加性噪声模型，$y_i = E(x_i; w) + \\varepsilon_i$，其中 $i \\in \\{1,\\dots,n\\}$。\n-   **噪声性质**：噪声项 $\\varepsilon_i$ 是独立的、零均值的、具有有限方差的波动。\n-   **目标**：最小化残差平方和（普通最小二乘法）。\n-   **任务 1**：从第一性原理出发，推导参数矢量 $w$ 的必要最优性条件，从残差平方和的标量形式开始，并进行到矩阵-矢量形式。\n-   **任务 2**：将该方法应用于一个具体的数据集。\n    -   特征数量，$p=3$。\n    -   复合物数量，$n=4$。\n    -   特征性质：$f_1$ 和 $f_2$ 被标准化为零均值，并且与彼此以及与截距不相关。\n    -   训练数据：\n        -   复合物 $i=1$：特征矢量 $(f_0, f_1, f_2) = (1, -1, -1)$；测量值 $y_1 = 10\\ \\text{kJ/mol}$。\n        -   复合物 $i=2$：特征矢量 $(f_0, f_1, f_2) = (1, -1, 1)$；测量值 $y_2 = 14\\ \\text{kJ/mol}$。\n        -   复合物 $i=3$：特征矢量 $(f_0, f_1, f_2) = (1, 1, -1)$；测量值 $y_3 = 18\\ \\text{kJ/mol}$。\n        -   复合物 $i=4$：特征矢量 $(f_0, f_1, f_2) = (1, 1, 1)$；测量值 $y_4 = 22\\ \\text{kJ/mol}$。\n    -   预测任务：为一个具有特征 $(f_0, f_1, f_2) = (1, 0.3, -0.7)$ 的新复合物 $x^{\\ast}$ 预测得分 $E(x^{\\ast}; w)$。\n    -   取整：最终的数值预测必须四舍五入到四位有效数字。\n\n### 第 2 步：使用提取的已知条件进行验证\n-   **科学上合理**：该问题描述了使用普通最小二乘法 (OLS) 拟合线性模型，这是统计学和机器学习中一种基础且广泛使用的技术。将其应用于构建蛋白质-配体对接的经验性打分函数是生物信息学和计算化学中的标准实践。该问题在科学上是合理的。\n-   **良态的**：该问题是良态的。第一部分要求进行线性回归理论中的标准推导。第二部分为特定情况提供了完整的数据集。给定数据的特征矩阵是满秩的，这保证了 OLS 问题存在唯一解。\n-   **客观的**：该问题使用精确的数学和科学语言陈述。它没有歧义、主观性和不可形式化的概念。\n\n### 第 3 步：结论与行动\n该问题是有效的。它在科学上合理、良态且客观。将提供完整的解答。\n\n### 最优性条件（正规方程组）的推导\n\n目标是找到使残差平方和 (SSR) 最小化的参数矢量 $w$。第 $i$ 个观测值的残差是测量值 $y_i$ 与模型预测值 $E(x_i; w)$ 之间的差。\n\nSSR，记作 $S(w)$，定义为：\n$$\nS(w) = \\sum_{i=1}^{n} (y_i - E(x_i; w))^2 = \\sum_{i=1}^{n} \\left(y_i - \\sum_{k=0}^{p-1} w_k f_k(x_i)\\right)^2\n$$\n为了找到这个函数的最小值，我们必须找到其相对于 $w$ 的梯度为零矢量的点。这是必要的最优性条件。我们计算 $S(w)$ 相对于每个参数 $w_j$（其中 $j \\in \\{0, 1, \\dots, p-1\\}$）的偏导数。\n\n使用链式法则：\n$$\n\\frac{\\partial S}{\\partial w_j} = \\sum_{i=1}^{n} 2 \\left(y_i - \\sum_{k=0}^{p-1} w_k f_k(x_i)\\right) \\cdot \\frac{\\partial}{\\partial w_j} \\left(y_i - \\sum_{k=0}^{p-1} w_k f_k(x_i)\\right)\n$$\n内部项的导数是：\n$$\n\\frac{\\partial}{\\partial w_j} \\left(y_i - \\sum_{k=0}^{p-1} w_k f_k(x_i)\\right) = 0 - \\frac{\\partial}{\\partial w_j} (w_0 f_0(x_i) + \\dots + w_j f_j(x_i) + \\dots) = -f_j(x_i)\n$$\n将其代回，我们得到：\n$$\n\\frac{\\partial S}{\\partial w_j} = \\sum_{i=1}^{n} 2 \\left(y_i - \\sum_{k=0}^{p-1} w_k f_k(x_i)\\right) (-f_j(x_i)) = -2 \\sum_{i=1}^{n} f_j(x_i) \\left(y_i - \\sum_{k=0}^{p-1} w_k f_k(x_i)\\right)\n$$\n将每个 $j$ 的偏导数设为零：\n$$\n\\sum_{i=1}^{n} f_j(x_i) \\left(y_i - \\sum_{k=0}^{p-1} w_k f_k(x_i)\\right) = 0\n$$\n整理各项：\n$$\n\\sum_{i=1}^{n} f_j(x_i) y_i = \\sum_{i=1}^{n} f_j(x_i) \\left(\\sum_{k=0}^{p-1} w_k f_k(x_i)\\right)\n$$\n这个方程可以重写为：\n$$\n\\sum_{k=0}^{p-1} \\left(\\sum_{i=1}^{n} f_j(x_i) f_k(x_i)\\right) w_k = \\sum_{i=1}^{n} f_j(x_i) y_i\n$$\n这代表了一个包含 $p$ 个未知数 ($w_0, \\dots, w_{p-1}$) 的 $p$ 个线性方程组。\n\n为了用矩阵-矢量形式表示，我们定义：\n-   设计矩阵 $X$，一个 $n \\times p$ 的矩阵，其元素 $X_{ik} = f_k(x_i)$。\n-   响应矢量 $y$，一个 $n \\times 1$ 的列矢量，其元素为 $y_i$。\n-   参数矢量 $w$，一个 $p \\times 1$ 的列矢量，其元素为 $w_k$。\n$$\nX = \\begin{pmatrix}\nf_0(x_1)  \\dots  f_{p-1}(x_1) \\\\\n\\vdots  \\ddots  \\vdots \\\\\nf_0(x_n)  \\dots  f_{p-1}(x_n)\n\\end{pmatrix}, \\quad\ny = \\begin{pmatrix} y_1 \\\\ \\vdots \\\\ y_n \\end{pmatrix}, \\quad\nw = \\begin{pmatrix} w_0 \\\\ \\vdots \\\\ w_{p-1} \\end{pmatrix}\n$$\n预测值矢量为 $\\hat{y} = Xw$，残差矢量为 $r = y - \\hat{y} = y - Xw$。\nSSR 是残差矢量的欧几里得范数的平方：\n$$\nS(w) = r^T r = (y - Xw)^T (y - Xw)\n$$\n展开此表达式：\n$$\nS(w) = (y^T - w^T X^T)(y - Xw) = y^T y - y^T X w - w^T X^T y + w^T X^T X w\n$$\n因为 $w^T X^T y$ 是一个标量，它等于其转置，即 $(w^T X^T y)^T = y^T X w$。所以我们可以合并中间两项：\n$$\nS(w) = y^T y - 2 w^T X^T y + w^T X^T X w\n$$\n对矢量 $w$ 求梯度（使用矩阵微积分恒等式 $\\nabla_v(v^T a) = a$ 和 $\\nabla_v(v^T A v) = 2Av$（对于对称矩阵 $A$），注意到 $X^T X$ 是对称的）：\n$$\n\\nabla_w S(w) = -2X^T y + 2X^T X w\n$$\n将梯度设为零，得到最小值的必要条件：\n$$\n-2X^T y + 2X^T X w = 0 \\implies X^T X w = X^T y\n$$\n这便是著名的正规方程组，它是最优性条件的矩阵-矢量形式。\n\n### 应用于数据集\n\n对于给定的问题，$n=4$ 且 $p=3$。设计矩阵 $X$ 和响应矢量 $y$ 由所提供的数据构建：\n$$\nX = \\begin{pmatrix}\n1  -1  -1 \\\\\n1  -1  1 \\\\\n1  1  -1 \\\\\n1  1  1\n\\end{pmatrix}, \\quad\ny = \\begin{pmatrix} 10 \\\\ 14 \\\\ 18 \\\\ 22 \\end{pmatrix}\n$$\n待求的参数矢量为 $w = (w_0, w_1, w_2)^T$。我们现在求解正规方程组 $X^T X w = X^T y$。\n\n首先，计算 $X^T X$：\n$$\nX^T X = \\begin{pmatrix}\n1  1  1  1 \\\\\n-1  -1  1  1 \\\\\n-1  1  -1  1\n\\end{pmatrix}\n\\begin{pmatrix}\n1  -1  -1 \\\\\n1  -1  1 \\\\\n1  1  -1 \\\\\n1  1  1\n\\end{pmatrix} = \\begin{pmatrix}\n4  0  0 \\\\\n0  4  0 \\\\\n0  0  4\n\\end{pmatrix} = 4I_3\n$$\n矩阵 $X^T X$ 是对角矩阵，因为 $X$ 的列是相互正交的，这是特征 $f_1$ 和 $f_2$ 在此训练集上经过均值中心化且不相关的结果。\n\n接下来，计算 $X^T y$：\n$$\nX^T y = \\begin{pmatrix}\n1  1  1  1 \\\\\n-1  -1  1  1 \\\\\n-1  1  -1  1\n\\end{pmatrix}\n\\begin{pmatrix} 10 \\\\ 14 \\\\ 18 \\\\ 22 \\end{pmatrix} = \\begin{pmatrix}\n1(10) + 1(14) + 1(18) + 1(22) \\\\\n-1(10) - 1(14) + 1(18) + 1(22) \\\\\n-1(10) + 1(14) - 1(18) + 1(22)\n\\end{pmatrix} = \\begin{pmatrix}\n64 \\\\\n16 \\\\\n8\n\\end{pmatrix}\n$$\n正规方程组变为：\n$$\n\\begin{pmatrix}\n4  0  0 \\\\\n0  4  0 \\\\\n0  0  4\n\\end{pmatrix}\n\\begin{pmatrix} w_0 \\\\ w_1 \\\\ w_2 \\end{pmatrix} =\n\\begin{pmatrix} 64 \\\\ 16 \\\\ 8 \\end{pmatrix}\n$$\n这个方程组很容易求解：\n-   $4w_0 = 64 \\implies w_0 = 16$\n-   $4w_1 = 16 \\implies w_1 = 4$\n-   $4w_2 = 8 \\implies w_2 = 2$\n\n所以，最优参数矢量是 $w = (16, 4, 2)^T$。拟合后的打分函数是 $E(x; w) = 16 + 4f_1(x) + 2f_2(x)$。\n\n### 对新复合物的预测\n\n我们被要求为一个特征矢量为 $f^{\\ast} = (f_0, f_1, f_2)^T = (1, 0.3, -0.7)^T$ 的新复合物 $x^{\\ast}$ 预测其得分。预测的得分是 $E(x^{\\ast}; w) = (f^{\\ast})^T w_k$。\n$$\nE(x^{\\ast}; w) = \\begin{pmatrix} 1  0.3  -0.7 \\end{pmatrix} \\begin{pmatrix} 16 \\\\ 4 \\\\ 2 \\end{pmatrix}\n$$\n$$\nE(x^{\\ast}; w) = 1 \\cdot 16 + 0.3 \\cdot 4 + (-0.7) \\cdot 2 = 16 + 1.2 - 1.4 = 15.8\n$$\n问题规定最终的数值预测必须四舍五入到四位有效数字。预测的能量是 $15.8 \\ \\text{kJ/mol}$。以四位有效数字表示，结果是 $15.80\\ \\text{kJ/mol}$。", "answer": "$$\n\\boxed{15.80}\n$$", "id": "4599711"}, {"introduction": "一个模型的好坏最终取决于其对未见数据的预测能力。最后的这个练习将从模型构建转向严格的模型评估，你将通过一个编程实践来完成这个过程。你将亲手实现k折交叉验证，并计算两个关键的性能指标——用于衡量预测准确性的均方根误差（RMSE）和用于评估排序能力的斯皮尔曼相关系数，从而学会识别这两者之间的重要差异，并对如何评价一个评分函数获得更深刻的理解 ([@problem_id:4599727])。", "problem": "您正在评估一个简单的线性蛋白质-配体对接打分函数，该函数根据特征向量预测结合亲和力。目标是实现$k$-折交叉验证，计算均方根误差 (RMSE) 和斯皮尔曼等级相关系数，然后检测排序质量与绝对准确度不一致的情况。您必须使用一个没有截距项的线性模型，通过最小化平方误差和进行训练。您的程序必须是一个完整的、可运行的程序，不接受任何输入，并打印所需的输出。\n\n基本原理和定义：\n- 给定特征向量 $\\{\\mathbf{x}_i\\}_{i=1}^n$ 和亲和力 $\\{y_i\\}_{i=1}^n$，考虑线性打分函数 $f(\\mathbf{x}) = \\mathbf{w}^{\\top}\\mathbf{x}$，其中 $\\mathbf{w} \\in \\mathbb{R}^d$。模型参数 $\\mathbf{w}$ 通过最小化平方误差和 $\\sum_{i=1}^n \\left(y_i - \\mathbf{w}^{\\top}\\mathbf{x}_i\\right)^2$ 来学习。在交叉验证中，该最小化过程仅在训练折上执行。最小化问题的解可以通过求解正规方程或等效地使用 Moore–Penrose 伪逆获得。\n- $k$-折交叉验证过程将索引 $\\{0,1,\\dots,n-1\\}$ 划分为 $k$ 个不相交的测试集。对于每一折，在测试集的补集上进行训练，并在测试集上进行预测。汇总所有折的预测，使得每个样本 $i$ 都有一个且仅有一个交叉验证预测值 $\\hat{y}_i$。\n- 均方根误差定义为 $\\mathrm{RMSE} = \\sqrt{\\frac{1}{n}\\sum_{i=0}^{n-1} (y_i - \\hat{y}_i)^2}$。\n- 斯皮尔曼等级相关系数是 $\\{y_i\\}$ 和 $\\{\\hat{y}_i\\}$ 的等级变换向量之间的皮尔逊相关系数。必须通过分配平均等级来处理并列情况。如果任一等级向量的方差为零，则定义斯皮尔曼相关系数为 $0$。\n\n排序和绝对误差指标之间的差异检测：\n- 定义两个阈值 $T_{\\text{high}}$ 和 $T_{\\text{low}}$。\n- 定义一个差异指示器 $d$ 如下\n  $$d = \\begin{cases}\n  1,  \\text{如果 } \\rho_s \\ge 0.9 \\text{ 且 } \\mathrm{RMSE} \\ge T_{\\text{high}}, \\\\\n  1,  \\text{如果 } \\rho_s \\le 0.1 \\text{ 且 } \\mathrm{RMSE} \\le T_{\\text{low}}, \\\\\n  0,  \\text{否则,}\n  \\end{cases}$$\n  其中 $\\rho_s$ 是斯皮尔曼等级相关系数。\n- 使用 $T_{\\text{high}} = 5.0$ 和 $T_{\\text{low}} = 0.2$。\n\n实现要求：\n- 对每个测试用例，严格按照提供的测试折来实施 $k$-折交叉验证。\n- 使用不带截距项的线性模型。\n- 对于每个训练集的拟合，使用 Moore–Penrose 伪逆计算 $\\mathbf{w}$，以最小化训练数据上的平方误差。\n- 对每个测试用例，计算整个数据集上的汇总交叉验证 $\\mathrm{RMSE}$ 和斯皮尔曼等级相关系数。\n- 对每个测试用例，输出一个包含三个元素的列表：四舍五入到三位小数的 $\\mathrm{RMSE}$，四舍五入到三位小数的斯皮尔曼相关系数，以及作为布尔值（$d=1$ 为 $\\mathrm{True}$，$d=0$ 为 $\\mathrm{False}$）的差异指示器。\n\n测试套件：\n提供四个独立的测试用例。对于每个用例，给定特征矩阵 $X \\in \\mathbb{R}^{n \\times d}$、亲和力向量 $y \\in \\mathbb{R}^{n}$ 和明确的测试索引折。索引是基于 $0$ 的。所有模型都在没有截距的情况下训练。\n\n- 测试用例 $1$（由于缺少截距，$\\rho_s$ 高，$\\mathrm{RMSE}$ 高）：\n  - $X = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\end{bmatrix}$, $y = \\begin{bmatrix} 11 \\\\ 12 \\\\ 13 \\\\ 14 \\\\ 15 \\\\ 16 \\end{bmatrix}$。\n  - 折：$\\big[\\,[0,1],\\,[2,3],\\,[4,5]\\,\\big]$。\n\n- 测试用例 $2$（由于小数值亲和力的符号不匹配，$\\rho_s$ 低，$\\mathrm{RMSE}$ 低）：\n  - $X = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 1 \\\\ 2 \\\\ 3 \\end{bmatrix}$, $y = \\begin{bmatrix} 0.04 \\\\ 0.08 \\\\ 0.12 \\\\ -0.04 \\\\ -0.08 \\\\ -0.12 \\end{bmatrix}$。\n  - 折：$\\big[\\,[0,1,2],\\,[3,4,5]\\,\\big]$。\n\n- 测试用例 $3$（边界情况：真实等级中方差为零）：\n  - $X = \\begin{bmatrix} -1 \\\\ 0 \\\\ 1 \\\\ 2 \\end{bmatrix}$, $y = \\begin{bmatrix} 0.5 \\\\ 0.5 \\\\ 0.5 \\\\ 0.5 \\end{bmatrix}$。\n  - 折：$\\big[\\,[0,1],\\,[2,3]\\,\\big]$。\n\n- 测试用例 $4$（理想情况：$\\rho_s$ 高，$\\mathrm{RMSE}$ 低）：\n  - $X = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{bmatrix}$, $y = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{bmatrix}$。\n  - 折：$\\big[\\,[0,1],\\,[2,3]\\,\\big]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由四个用例结果组成的逗号分隔列表，每个用例结果为一个三元素列表，形式为 $[\\mathrm{RMSE}, \\rho_s, d]$，其中两个浮点值四舍五入到三位小数，布尔值不带引号。例如：$[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]]$。", "solution": "用户提供了一个生物信息学领域中定义明确的计算问题。任务是使用 $k$-折交叉验证来评估一个简单的线性打分函数，并识别不同性能度量指标之间的差异。\n\n### 步骤 1：提取已知条件\n\n1.  **模型**：一个没有截距项的线性打分函数，$f(\\mathbf{x}) = \\mathbf{w}^{\\top}\\mathbf{x}$。\n2.  **训练**：通过最小化训练数据上的平方误差和 $\\sum_{i \\in \\text{train}} \\left(y_i - \\mathbf{w}^{\\top}\\mathbf{x}_i\\right)^2$ 来找到权重向量 $\\mathbf{w}$。这将使用 Moore-Penrose 伪逆来求解。\n3.  **验证**：使用提供的折分区进行 $k$-折交叉验证。预测结果在所有折上进行汇总。\n4.  **度量指标**：\n    -   均方根误差 (RMSE)：$\\mathrm{RMSE} = \\sqrt{\\frac{1}{n}\\sum_{i=0}^{n-1} (y_i - \\hat{y}_i)^2}$，其中 $\\hat{y}_i$ 是交叉验证的预测值。\n    -   斯皮尔曼等级相关系数 ($\\rho_s$)：真实亲和力 $\\{y_i\\}$ 和预测亲和力 $\\{\\hat{y}_i\\}$ 经过等级变换后的皮尔逊相关系数。并列情况通过平均等级处理。如果任一等级向量的方差为零，则定义 $\\rho_s$ 为 $0$。\n5.  **差异检测**：差异指示器 $d$ 定义为：\n    $$d = \\begin{cases}\n    1,  \\text{如果 } \\rho_s \\ge 0.9 \\text{ 且 } \\mathrm{RMSE} \\ge T_{\\text{high}}, \\\\\n    1,  \\text{如果 } \\rho_s \\le 0.1 \\text{ 且 } \\mathrm{RMSE} \\le T_{\\text{low}}, \\\\\n    0,  \\text{否则。}\n    \\end{cases}$$\n6.  **常数**：阈值 $T_{\\text{high}} = 5.0$ 和 $T_{\\text{low}} = 0.2$。\n7.  **测试用例**：提供了四个具体的测试用例，每个用例都包含一个特征矩阵 $X$、一个亲和力向量 $y$ 和一个测试折列表。\n    -   用例 1：$X = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\end{bmatrix}$， $y = \\begin{bmatrix} 11 \\\\ 12 \\\\ 13 \\\\ 14 \\\\ 15 \\\\ 16 \\end{bmatrix}$，折：$\\big[\\,[0,1],\\,[2,3],\\,[4,5]\\,\\big]$。\n    -   用例 2：$X = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 1 \\\\ 2 \\\\ 3 \\end{bmatrix}$， $y = \\begin{bmatrix} 0.04 \\\\ 0.08 \\\\ 0.12 \\\\ -0.04 \\\\ -0.08 \\\\ -0.12 \\end{bmatrix}$，折：$\\big[\\,[0,1,2],\\,[3,4,5]\\,\\big]$。\n    -   用例 3：$X = \\begin{bmatrix} -1 \\\\ 0 \\\\ 1 \\\\ 2 \\end{bmatrix}$， $y = \\begin{bmatrix} 0.5 \\\\ 0.5 \\\\ 0.5 \\\\ 0.5 \\end{bmatrix}$，折：$\\big[\\,[0,1],\\,[2,3]\\,\\big]$。\n    -   用例 4：$X = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{bmatrix}$， $y = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{bmatrix}$，折：$\\big[\\,[0,1],\\,[2,3]\\,\\big]$。\n8.  **输出格式**：一个单行的列表的列表，`[[rmse1, rho1, d1], [rmse2, rho2, d2], ...]`，其中浮点数四舍五入到三位小数，差异指示器为不带引号的布尔值。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据指定标准对问题进行审查：\n-   **科学基础**：问题描述了一种标准的机器学习方法（$k$-折交叉验证）用于模型评估，这是计算科学中的基本实践。线性模型、RMSE 和斯皮尔曼相关系数都是统计学和机器学习中的基本概念。\n-   **适定性**：该问题是适定的。所有必要的数据（$X$, $y$, 折）、定义（RMSE, $\\rho_s$, $d$）和程序（通过伪逆进行训练，交叉验证）都已明确提供。测试用例是具体的，可以计算出唯一的解。\n-   **客观性**：语言精确且量化。所有指令都清晰明确。\n-   **无缺陷**：问题没有表现出任何无效性缺陷。它是自包含的、事实可靠的、可形式化的，并且计算上是可行的。测试用例旨在测试度量指标的特定行为，这是算法验证中的常见做法。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。将按要求开发并实施解决方案。\n\n### 求解推导\n\n解决方案需要为每个测试用例实现一个计算工作流。该工作流包括交叉验证、度量计算和差异检测。\n\n**1. 模型训练**\n模型是一个没有截距的线性函数：$f(\\mathbf{x}) = \\mathbf{w}^{\\top}\\mathbf{x}$。给定一个训练集，其特征矩阵为 $\\mathbf{X}_{\\text{train}}$（其中每行是一个特征向量 $\\mathbf{x}_i^{\\top}$），目标向量为 $\\mathbf{y}_{\\text{train}}$，我们的目标是找到最小化平方误差和 (SSE) 的权重向量 $\\mathbf{w}$，$L(\\mathbf{w}) = ||\\mathbf{y}_{\\text{train}} - \\mathbf{X}_{\\text{train}}\\mathbf{w}||_2^2$。这个线性最小二乘问题的解由正规方程给出：\n$$ \\mathbf{X}_{\\text{train}}^{\\top}\\mathbf{X}_{\\text{train}}\\mathbf{w} = \\mathbf{X}_{\\text{train}}^{\\top}\\mathbf{y}_{\\text{train}} $$\n权重向量 $\\mathbf{w}$ 可以求解为：\n$$ \\mathbf{w} = (\\mathbf{X}_{\\text{train}}^{\\top}\\mathbf{X}_{\\text{train}})^{-1}\\mathbf{X}_{\\text{train}}^{\\top}\\mathbf{y}_{\\text{train}} $$\n项 $(\\mathbf{X}_{\\text{train}}^{\\top}\\mathbf{X}_{\\text{train}})^{-1}\\mathbf{X}_{\\text{train}}^{\\top}$ 是 $\\mathbf{X}_{\\text{train}}$ 的 Moore-Penrose 伪逆，记作 $\\mathbf{X}_{\\text{train}}^{+}$。因此，训练步骤简化为：\n$$ \\mathbf{w} = \\mathbf{X}_{\\text{train}}^{+} \\mathbf{y}_{\\text{train}} $$\n即使当 $\\mathbf{X}_{\\text{train}}^{\\top}\\mathbf{X}_{\\text{train}}$ 是奇异矩阵时，这种方法也是稳健的。\n\n**2. $k$-折交叉验证**\n数据集被划分为 $k$ 个折。对于每个折 $j \\in \\{1, \\dots, k\\}$：\n-   折 $j$ 中的索引构成测试集。\n-   所有其他索引构成训练集。\n-   使用训练集数据 $(\\mathbf{X}_{\\text{train}}, \\mathbf{y}_{\\text{train}})$ 训练模型，得到一个权重向量 $\\mathbf{w}_j$。\n-   在测试集特征 $\\mathbf{X}_{\\text{test}}$ 上进行预测：$\\hat{\\mathbf{y}}_{\\text{test}} = \\mathbf{X}_{\\text{test}} \\mathbf{w}_j$。\n对所有 $k$ 个折重复此过程。收集每个测试集的预测结果。由于测试折是不相交的，并且它们的并集覆盖了整个数据集，因此我们为原始数据集中的每个样本 $i$ 获得了单个预测值 $\\hat{y}_i$。这些汇总的预测构成了向量 $\\hat{\\mathbf{y}}$。\n\n**3. 性能度量指标**\n一旦获得汇总的预测向量 $\\hat{\\mathbf{y}}$，我们就计算两个所需的度量指标。\n\n-   **均方根误差 (RMSE)**：衡量预测误差平均大小的指标。其计算公式为：\n    $$ \\mathrm{RMSE} = \\sqrt{\\frac{1}{n}\\sum_{i=0}^{n-1} (y_i - \\hat{y}_i)^2} $$\n    其中 $n$ 是样本总数。\n\n-   **斯皮尔曼等级相关系数 ($\\rho_s$)**：一种非参数的等级相关性度量，用于评估两个变量之间的关系能被单调函数描述的程度。它被计算为等级变换后变量的皮尔逊相关系数。\n    设 $R(\\mathbf{y})$ 是 $\\mathbf{y}$ 中元素的等级向量，而 $R(\\hat{\\mathbf{y}})$ 是 $\\hat{\\mathbf{y}}$ 的等级向量。并列情况通过分配给并列值的等级的平均值来解决。\n    两个长度为 $n$ 的向量 $\\mathbf{u}$ 和 $\\mathbf{v}$ 之间的皮尔逊相关系数 $r$ 为：\n    $$ r(\\mathbf{u}, \\mathbf{v}) = \\frac{\\sum_{i=1}^n (u_i - \\bar{u})(v_i - \\bar{v})}{\\sqrt{\\sum_{i=1}^n (u_i - \\bar{u})^2} \\sqrt{\\sum_{i=1}^n (v_i - \\bar{v})^2}} $$\n    其中 $\\bar{u}$ 和 $\\bar{v}$ 是向量的均值。\n    那么，$\\rho_s = r(R(\\mathbf{y}), R(\\hat{\\mathbf{y}}))$。根据问题规范，如果 $R(\\mathbf{y})$ 或 $R(\\hat{\\mathbf{y}})$ 的方差为零（即，原始向量中的所有值都相同），则 $\\rho_s$ 设为 $0$。\n\n**4. 差异指示器 ($d$)**\n指示器 $d$ 是一个布尔标志，如果排序性能和绝对误差不一致，则设置为真 ($1$)。\n-   **情况 1（良好排序，较差准确度）**：高的斯皮尔曼相关系数（$\\rho_s \\ge 0.9$）表示模型正确地对样本进行了排序，但高的 RMSE（$\\ge T_{\\text{high}}=5.0$）表示存在较大的绝对预测误差。这通常发生在存在系统性误差的情况下，例如对于具有远离原点的大偏移量的数据，模型中缺少截距。\n-   **情况 2（较差排序，良好准确度）**：低的斯皮尔曼相关系数（$\\rho_s \\le 0.1$）表示模型未能捕捉到正确的排序，但低的 RMSE（$\\le T_{\\text{low}}=0.2$）表明绝对误差很小。当亲和力本身很小时，即使是显著的错误预测（例如，符号错误）也会导致较小的绝对误差。\n\n最终的实现将封装此逻辑，将其应用于四个测试用例中的每一个，并按规定格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import rankdata\n\ndef solve():\n    \"\"\"\n    Solves the protein docking scoring function evaluation problem.\n    \"\"\"\n    \n    # Define thresholds from the problem statement.\n    T_high = 5.0\n    T_low = 0.2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"X\": np.array([[1], [2], [3], [4], [5], [6]]),\n            \"y\": np.array([11, 12, 13, 14, 15, 16]),\n            \"folds\": [[0, 1], [2, 3], [4, 5]]\n        },\n        {\n            \"X\": np.array([[1], [2], [3], [1], [2], [3]]),\n            \"y\": np.array([0.04, 0.08, 0.12, -0.04, -0.08, -0.12]),\n            \"folds\": [[0, 1, 2], [3, 4, 5]]\n        },\n        {\n            \"X\": np.array([[-1], [0], [1], [2]]),\n            \"y\": np.array([0.5, 0.5, 0.5, 0.5]),\n            \"folds\": [[0, 1], [2, 3]]\n        },\n        {\n            \"X\": np.array([[1], [2], [3], [4]]),\n            \"y\": np.array([1, 2, 3, 4]),\n            \"folds\": [[0, 1], [2, 3]]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        X = case[\"X\"]\n        y = case[\"y\"]\n        folds = case[\"folds\"]\n        n_samples = X.shape[0]\n        all_indices = np.arange(n_samples)\n        \n        y_hat_all = np.zeros(n_samples)\n\n        # k-fold cross-validation\n        for test_indices in folds:\n            train_indices = np.setdiff1d(all_indices, test_indices)\n            \n            X_train, y_train = X[train_indices], y[train_indices]\n            X_test = X[test_indices]\n            \n            # Train model using Moore-Penrose pseudoinverse\n            w = np.linalg.pinv(X_train) @ y_train\n            \n            # Predict on the test set\n            y_hat_test = X_test @ w\n            \n            # Store predictions\n            y_hat_all[test_indices] = y_hat_test\n            \n        # Calculate RMSE\n        rmse = np.sqrt(np.mean((y - y_hat_all)**2))\n        \n        # Calculate Spearman rank correlation\n        rank_y = rankdata(y, method='average')\n        rank_y_hat = rankdata(y_hat_all, method='average')\n        \n        # Handle zero variance case as per problem description\n        if np.var(rank_y) == 0 or np.var(rank_y_hat) == 0:\n            spearman_rho = 0.0\n        else:\n            spearman_rho = np.corrcoef(rank_y, rank_y_hat)[0, 1]\n            \n        # Detect discrepancy\n        discrepancy = (spearman_rho >= 0.9 and rmse >= T_high) or \\\n                      (spearman_rho = 0.1 and rmse = T_low)\n                      \n        results.append([rmse, spearman_rho, discrepancy])\n\n    # Format the final output string\n    output_parts = []\n    for r in results:\n        # Format the numbers to 3 decimal places and the boolean as True/False\n        # Python's str() for a boolean correctly produces 'True' or 'False'\n        output_parts.append(f\"[{r[0]:.3f},{r[1]:.3f},{str(r[2])}]\")\n    \n    final_output_str = f\"[{','.join(output_parts)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```", "id": "4599727"}]}