{"hands_on_practices": [{"introduction": "在分析任何生理时间序列数据之前，我们必须首先理解将其从连续信号转换为离散序列所带来的基本后果。本练习回归到信号处理的第一性原理，推导采样过程中的一个关键现象——混叠。通过亲自推导并将其应用于一个实际场景，你将深刻理解为何必须谨慎选择采样率，以避免对生理信号（如心电或光电容积描记）的频谱内容产生错误解读。[@problem_id:4613653]", "problem": "一个光电容积脉搏波（PPG）传感器记录了一个连续时间生理信号，该信号被一个窄带肌肉伪影所干扰，该伪影被建模为频率为 $f_{0}$（单位 $\\mathrm{Hz}$）的单个实正弦波。该信号以采样周期 $T_{s}$ 进行均匀采样，产生离散时间序列 $x[n]=x_{c}(nT_{s})$，其中 $f_{s}=1/T_{s}$ 是采样频率（单位 $\\mathrm{Hz}$）。假设采样是理想、无噪声的，并且采集过程是线性时不变的。\n\n仅从均匀采样的基本定义（即在连续时间中与脉冲序列相乘）以及狄拉克梳状函数的傅里叶变换的基本性质出发，完成以下任务：\n\n1) 将采样操作建模为 $x_{s}(t)=x_{c}(t)\\sum_{n=-\\infty}^{\\infty}\\delta(t-nT_{s})$，并利用傅里叶变换的卷积-乘法对偶性，推导出采样后信号的频谱 $X_{s}(f)$，用原始频谱 $X_{c}(f)$ 和采样频率 $f_{s}$ 表示。您的推导必须指明并解释以 $f_{s}$ 的整数倍为中心的频谱重复现象的出现。\n\n2) 考虑 $x_{c}(t)$ 是频率为 $f_{0}>0$、具有任意幅度和相位的单个实正弦波的特殊情况。仅利用离散时间复指数的周期性以及实正弦波表示为复指数之和的方法，推导出一个闭式表达式，用于计算当采样序列 $x[n]$ 在奈奎斯特区间 $[0,\\,f_{s}/2]$ 上解释时所观察到的基带频率（单位 $\\mathrm{Hz}$）。您的表达式必须仅用 $f_{0}$、$f_{s}$ 和一个明确选择的整数来表示，该整数确保基带表示在该区间内具有最小的幅度。不要假设任何已知的混叠公式。\n\n3) 一个PPG信号在以 $f_{s}=$ $100$ $\\mathrm{Hz}$ 的频率采样时，受到一个频率为 $f_{0}=$ $70$ $\\mathrm{Hz}$ 的肌肉伪影干扰。使用您在第2部分得到的结果，确定该伪影在采样数据中出现的单一基带频率（单位 $\\mathrm{Hz}$）。最终频率以 $\\mathrm{Hz}$ 为单位表示。无需四舍五入。", "solution": "该问题陈述是关于离散时间信号处理基础理论，特别是关于连续时间信号采样的一个适定练习。它具有科学依据，内部一致，并包含从第一性原理推导唯一解所需的所有信息。因此，该问题被认为是有效的。\n\n**第1部分：采样信号频谱的推导**\n\n该问题将采样过程建模为连续时间信号 $x_c(t)$ 与周期性脉冲序列 $s(t)$ 的乘积，得到采样信号 $x_s(t)$。\n$$x_s(t) = x_c(t) s(t) = x_c(t) \\sum_{n=-\\infty}^{\\infty} \\delta(t-nT_s)$$\n这里，$\\delta(t)$ 是狄拉克δ函数，$T_s$ 是采样周期，$n$ 是一个整数。采样频率为 $f_s = 1/T_s$。\n\n采样信号的傅里叶变换 $X_s(f) = \\mathcal{F}\\{x_s(t)\\}$ 可以通过应用傅里叶变换的卷积-乘法对偶性来求得。该性质指出，时域中的乘法对应于频域中的卷积。\n$$X_s(f) = \\mathcal{F}\\{x_c(t) s(t)\\} = (\\mathcal{F}\\{x_c(t)\\} * \\mathcal{F}\\{s(t)\\})(f) = (X_c * S)(f)$$\n其中 $X_c(f)$ 是 $x_c(t)$ 的傅里叶变换，$S(f)$ 是脉冲序列 $s(t)$ 的傅里叶变换。\n\n为了求 $S(f)$，我们首先用傅里叶级数表示周期性脉冲序列 $s(t)$。$s(t)$ 的周期是 $T_s$。傅里叶级数系数 $c_k$ 由下式给出：\n$$c_k = \\frac{1}{T_s} \\int_{-T_s/2}^{T_s/2} s(t) \\exp(-j 2\\pi k \\frac{t}{T_s}) dt$$\n在积分区间 $[-T_s/2, T_s/2]$ 内，脉冲序列 $s(t)$ 就是 $\\delta(t)$。利用δ函数的筛选性质，我们得到：\n$$c_k = \\frac{1}{T_s} \\int_{-T_s/2}^{T_s/2} \\delta(t) \\exp(-j 2\\pi k f_s t) dt = \\frac{1}{T_s} \\exp(0) = \\frac{1}{T_s} = f_s$$\n$s(t)$ 的傅里叶级数表示因此为：\n$$s(t) = \\sum_{k=-\\infty}^{\\infty} c_k \\exp(j 2\\pi k \\frac{t}{T_s}) = \\sum_{k=-\\infty}^{\\infty} f_s \\exp(j 2\\pi k f_s t)$$\n现在，我们逐项对这个级数进行傅里叶变换以求得 $S(f)$。我们使用标准的傅里叶变换对 $\\mathcal{F}\\{\\exp(j 2\\pi f_{c} t)\\} = \\delta(f-f_{c})$。\n$$S(f) = \\mathcal{F}\\left\\{ f_s \\sum_{k=-\\infty}^{\\infty} \\exp(j 2\\pi k f_s t) \\right\\} = f_s \\sum_{k=-\\infty}^{\\infty} \\mathcal{F}\\{\\exp(j 2\\pi k f_s t)\\} = f_s \\sum_{k=-\\infty}^{\\infty} \\delta(f - kf_s)$$\n这个结果表明，时域中的狄拉克梳状函数，其傅里叶变换是频域中的一个狄拉克梳状函数，间隔为 $f_s$，并由 $f_s$ 进行缩放。\n\n最后，我们执行卷积 $X_s(f) = (X_c * S)(f)$。利用与δ函数卷积的筛选性质 $(g * \\delta(t-t_0))(t) = g(t-t_0)$，我们得到：\n$$X_s(f) = X_c(f) * \\left( f_s \\sum_{k=-\\infty}^{\\infty} \\delta(f - kf_s) \\right)$$\n$$X_s(f) = f_s \\sum_{k=-\\infty}^{\\infty} (X_c(f) * \\delta(f - kf_s))$$\n$$X_s(f) = f_s \\sum_{k=-\\infty}^{\\infty} X_c(f - kf_s)$$\n这个方程是傅里叶变换的泊松求和公式。它表明，采样信号的频谱 $X_s(f)$ 由原始频谱 $X_c(f)$ 的周期性重复副本组成，这些副本按采样频率 $f_s$ 缩放。这些频谱副本以采样频率的整数倍 $k f_s$ 为中心，其中 $k$ 为所有整数。\n\n**第2部分：观测基带频率的推导**\n\n我们现在将连续时间信号具体化为一个频率为 $f_0 > 0$、具有任意幅度 $A$ 和任意相位 $\\phi$ 的单个实正弦波：\n$$x_c(t) = A \\cos(2\\pi f_0 t + \\phi)$$\n使用欧拉公式，我们将此正弦波表示为复指数之和：\n$$x_c(t) = \\frac{A}{2} \\left[ \\exp(j(2\\pi f_0 t + \\phi)) + \\exp(-j(2\\pi f_0 t + \\phi)) \\right]$$\n离散时间序列 $x[n]$ 是通过以均匀速率对 $x_c(t)$ 进行采样得到的，其中 $t = nT_s = n/f_s$：\n$$x[n] = x_c(nT_s) = \\frac{A}{2} \\left[ \\exp(j(2\\pi f_0 \\frac{n}{f_s} + \\phi)) + \\exp(-j(2\\pi f_0 \\frac{n}{f_s} + \\phi)) \\right]$$\n令归一化离散时间频率为 $\\omega_0 = 2\\pi (f_0/f_s)$。该序列可以写成：\n$$x[n] = \\frac{A}{2} \\left[ \\exp(j\\phi)\\exp(j \\omega_0 n) + \\exp(-j\\phi)\\exp(-j \\omega_0 n) \\right]$$\n离散时间复指数的一个基本性质是其在频率上的周期性。对于任何整数 $m$，指数 $\\exp(j\\omega n)$ 与 $\\exp(j(\\omega + 2\\pi m)n)$ 是无法区分的：\n$$\\exp(j(\\omega + 2\\pi m)n) = \\exp(j\\omega n) \\exp(j2\\pi mn) = \\exp(j\\omega n) \\cdot 1 = \\exp(j\\omega n)$$\n因为 $m$ 和 $n$ 都是整数。这意味着如果两个离散时间频率相差 $2\\pi$ 的整数倍，则它们是等效的。\n\n因此，离散时间频率 $\\omega_0$ 与任何频率 $\\omega_0 - 2\\pi k$（对于任何整数 $k$）都是无法区分的。就模拟频率 $f_0$ 而言，这意味着在以频率 $f_s$ 采样后，频率 $f_0$ 与频率 $f_0 - k f_s$ 无法区分。同样，$-f_0$ 与 $-f_0 + k f_s$ 无法区分。采样后正弦波的观测频率将是落入基带范围内的频率分量。\n\n问题要求在奈奎斯特区间 $[0, f_s/2]$ 内的观测频率。这对应于 $[0, \\pi]$ 的离散时间频率范围。设观测到的基带频率为 $f_{obs}$。我们必须找到一个整数 $k$，使得混叠频率（可以看作是 $f_0$ 对 $f_s$ 取模的余数）落入主值范围 $[-f_s/2, f_s/2]$，然后其绝对值即为 $f_{obs}$。\n对于某个整数 $k$，观测频率 $f_{obs}$ 必须满足以下两个条件之一：\n$$f_{obs} = f_0 - k f_s \\quad \\text{或} \\quad f_{obs} = -(f_0 - k f_s)$$\n将这两个条件结合起来，我们得到 $f_{obs} = |f_0 - k f_s|$。\n我们寻求位于区间 $[0, f_s/2]$ 内的 $f_{obs}$ 值。这要求我们选择一个整数 $k$，使得量 $f_0 - k f_s$ 最接近于零。使幅度 $|f_0 - k f_s|$ 最小化的整数 $k$ 是最接近比值 $f_0/f_s$ 的整数。这可以用四舍五入函数正式表示。\n\n设明确选择的整数为 $k = \\text{round}(f_0/f_s)$，可以写成 $k = \\lfloor f_0/f_s + 1/2 \\rfloor$。\n通过选择这样的 $k$，量 $f_0 - k f_s$ 将落在范围 $[-f_s/2, f_s/2]$ 内。观测到的基带频率必须为非负数，是这个量的绝对值。\n因此，观测基带频率的闭式表达式为：\n$$f_{obs} = |f_0 - k f_s|, \\quad \\text{其中} \\quad k = \\left\\lfloor \\frac{f_0}{f_s} + \\frac{1}{2} \\right\\rfloor$$\n该表达式确保 $0 \\le f_{obs} \\le f_s/2$，符合要求。\n\n**第3部分：针对特定频率的计算**\n\n问题提供了以下具体值：\n- 伪影频率：$f_0 = 70 \\ \\mathrm{Hz}$\n- 采样频率：$f_s = 100 \\ \\mathrm{Hz}$\n\n我们应用第2部分推导出的公式。首先，我们确定整数 $k$：\n$$\\frac{f_0}{f_s} = \\frac{70}{100} = 0.7$$\n$$k = \\left\\lfloor 0.7 + \\frac{1}{2} \\right\\rfloor = \\lfloor 1.2 \\rfloor = 1$$\n现在，我们将这个 $k$ 值代入 $f_{obs}$ 的表达式中：\n$$f_{obs} = |f_0 - k f_s| = |70 - (1)(100)| = |70 - 100| = |-30|$$\n$$f_{obs} = 30$$\n肌肉伪影的观测基带频率为 $30 \\ \\mathrm{Hz}$。该值位于指定的奈奎斯特区间 $[0, f_s/2] = [0, 50] \\ \\mathrm{Hz}$ 内。", "answer": "$$\\boxed{30}$$", "id": "4613653"}, {"introduction": "掌握了基本的采样理论后，我们可以进一步探索生理信号分析中常用的具体指标。本练习旨在搭建心率变异性（HRV）分析中时域与频域之间的桥梁，聚焦于两个核心指标：RMSSD 和 SDNN。通过从统计定义出发推导它们之间的关系，你将揭示一个看似简单的时域计算（连续差分）如何等效于一个高通滤波器，从而能够量化自主神经系统的高频活动。[@problem_id:4613609]", "problem": "考虑一个离散时间序列，它是在静息条件下从单个个体采集的正常至正常心跳间隔测量值（R-R间期）$\\{x_t\\}_{t=1}^{N}$，并按均匀心跳采样。假设 $\\{x_t\\}$ 是宽平稳的，其均值为 $\\mu$，方差为 $\\sigma^{2}$，自协方差函数为 $\\gamma(k) = \\mathbb{E}\\!\\left[(x_t-\\mu)(x_{t-k}-\\mu)\\right]$，延迟为1的自相关为 $\\rho_{1} = \\gamma(1)/\\gamma(0) = \\gamma(1)/\\sigma^{2}$。连续差分的均方根（RMSSD）定义为\n$$\n\\mathrm{RMSSD} = \\sqrt{\\frac{1}{N-1}\\sum_{t=2}^{N} \\left(x_t - x_{t-1}\\right)^{2}},\n$$\n正常至正常间期的标准差（SDNN）定义为\n$$\n\\mathrm{SDNN} = \\sqrt{\\frac{1}{N}\\sum_{t=1}^{N} \\left(x_t - \\bar{x}\\right)^{2}},\n$$\n其中 $\\bar{x}$ 是样本均值。\n\n请从宽平稳过程的方差和自协方差的定义出发，并且除了这些定义之外不引用任何预先推导的关系，推导 $\\mathbb{E}\\!\\left[(x_t - x_{t-1})^{2}\\right]$ 在大$N$极限下用 $\\sigma^{2}$ 和 $\\gamma(1)$ 表示的表达式。利用这个结果明确展示 $\\mathrm{RMSSD}^{2}$ 如何与 $\\{x_t\\}$ 的短期方差相关联，并获得 $\\mathrm{RMSSD}$ 和 $\\mathrm{SDNN}$ 之间用 $\\rho_{1}$ 表示的闭式关系。然后，利用一阶差分算子 $d_t = x_t - x_{t-1}$ 的线性时不变滤波解释以及 $\\{x_t\\}$ 的功率谱密度 $S_{x}(\\omega)$ 的定义，解释（无需数值计算）为什么 $\\mathrm{RMSSD}$ 比 $\\mathrm{SDNN}$ 对高频（短时间尺度）波动更敏感。\n\n作为您的最终输出，请提供比率 $\\mathrm{RMSSD}/\\mathrm{SDNN}$ 用延迟为1的自相关 $\\rho_{1}$ 表示的精确闭式解析表达式。最终答案必须是单个表达式。不包含任何单位，也不要提供不等式或方程式。无需四舍五入。", "solution": "该问题是有效的。现给出完整的、带推理过程的解答。\n\n该问题需要一个包含三部分的推导和解释。我们将依次处理每个部分。\n\n首先，我们推导 $\\mathbb{E}\\!\\left[(x_t - x_{t-1})^{2}\\right]$ 的表达式。期望是针对宽平稳过程 $\\{x_t\\}$ 的系综来计算的。\n根据期望算子的线性性质，我们可以展开平方差：\n$$\n\\mathbb{E}\\!\\left[(x_t - x_{t-1})^{2}\\right] = \\mathbb{E}\\!\\left[x_t^2 - 2x_t x_{t-1} + x_{t-1}^2\\right] = \\mathbb{E}\\!\\left[x_t^2\\right] - 2\\mathbb{E}\\!\\left[x_t x_{t-1}\\right] + \\mathbb{E}\\!\\left[x_{t-1}^2\\right]\n$$\n对于一个均值为 $\\mu$、方差为 $\\sigma^2$ 的宽平稳过程，我们有以下关系。方差定义为 $\\sigma^2 = \\gamma(0) = \\mathbb{E}\\!\\left[(x_t - \\mu)^2\\right] = \\mathbb{E}\\!\\left[x_t^2\\right] - \\left(\\mathbb{E}[x_t]\\right)^2 = \\mathbb{E}\\!\\left[x_t^2\\right] - \\mu^2$。这给了我们 $\\mathbb{E}\\!\\left[x_t^2\\right] = \\sigma^2 + \\mu^2$。由于过程是平稳的，矩与时间指数 $t$ 无关，因此 $\\mathbb{E}\\!\\left[x_{t-1}^2\\right] = \\mathbb{E}\\!\\left[x_t^2\\right] = \\sigma^2 + \\mu^2$。\n\n延迟 $k=1$ 处的自协方差定义为 $\\gamma(1) = \\mathbb{E}\\!\\left[(x_t - \\mu)(x_{t-1} - \\mu)\\right]$。展开此式可得：\n$$\n\\gamma(1) = \\mathbb{E}\\!\\left[x_t x_{t-1} - \\mu x_t - \\mu x_{t-1} + \\mu^2\\right] = \\mathbb{E}\\!\\left[x_t x_{t-1}\\right] - \\mu\\mathbb{E}\\!\\left[x_t\\right] - \\mu\\mathbb{E}\\!\\left[x_{t-1}\\right] + \\mu^2\n$$\n由于 $\\mathbb{E}\\!\\left[x_t\\right] = \\mathbb{E}\\!\\left[x_{t-1}\\right] = \\mu$，上式简化为 $\\gamma(1) = \\mathbb{E}\\!\\left[x_t x_{t-1}\\right] - \\mu^2 - \\mu^2 + \\mu^2 = \\mathbb{E}\\!\\left[x_t x_{t-1}\\right] - \\mu^2$。这给了我们交叉矩的表达式：$\\mathbb{E}\\!\\left[x_t x_{t-1}\\right] = \\gamma(1) + \\mu^2$。\n\n将这些结果代回展开的期望中：\n$$\n\\mathbb{E}\\!\\left[(x_t - x_{t-1})^{2}\\right] = (\\sigma^2 + \\mu^2) - 2(\\gamma(1) + \\mu^2) + (\\sigma^2 + \\mu^2)\n$$\n$$\n\\mathbb{E}\\!\\left[(x_t - x_{t-1})^{2}\\right] = \\sigma^2 + \\mu^2 - 2\\gamma(1) - 2\\mu^2 + \\sigma^2 + \\mu^2\n$$\n$$\n\\mathbb{E}\\!\\left[(x_t - x_{t-1})^{2}\\right] = 2\\sigma^2 - 2\\gamma(1) = 2(\\sigma^2 - \\gamma(1))\n$$\n这是用 $\\sigma^2$ 和 $\\gamma(1)$ 表示 $\\mathbb{E}\\!\\left[(x_t - x_{t-1})^{2}\\right]$ 所要求的表达式。\n\n其次，我们建立 RMSSD 和 SDNN 之间的关系。在大样本极限下（$N \\to \\infty$），假设过程是遍历的（对于宽平稳过程通常如此假设），样本平均值会收敛到系综期望。\n因此，$\\mathrm{RMSSD}^2$ 成为 $\\mathbb{E}\\!\\left[(x_t - x_{t-1})^{2}\\right]$ 的一个无偏且一致的估计量：\n$$\n\\lim_{N \\to \\infty} \\mathrm{RMSSD}^2 = \\lim_{N \\to \\infty} \\frac{1}{N-1}\\sum_{t=2}^{N} \\left(x_t - x_{t-1}\\right)^{2} = \\mathbb{E}\\!\\left[(x_t - x_{t-1})^{2}\\right]\n$$\n类似地，$\\mathrm{SDNN}^2$ 是过程方差 $\\sigma^2$ 的一致估计量：\n$$\n\\lim_{N \\to \\infty} \\mathrm{SDNN}^2 = \\lim_{N \\to \\infty} \\frac{1}{N}\\sum_{t=1}^{N} \\left(x_t - \\bar{x}\\right)^{2} = \\sigma^2\n$$\n使用这些大$N$近似，我们可以写出：\n$$\n\\mathrm{RMSSD}^2 \\approx 2(\\sigma^2 - \\gamma(1))\n$$\n$\\mathrm{RMSSD}^2$ 的值与连续差分的方差成正比，因此反映了短期变异性，而这个方程显示了它如何与总过程方差（$\\sigma^2$）及其相关结构（$\\gamma(1)$）相关联。\n现在我们引入延迟为1的自相关系数 $\\rho_1 = \\gamma(1)/\\gamma(0)$。由于 $\\gamma(0)=\\sigma^2$，我们有 $\\gamma(1) = \\rho_1 \\sigma^2$。将此代入 $\\mathrm{RMSSD}^2$ 的表达式中：\n$$\n\\mathrm{RMSSD}^2 \\approx 2(\\sigma^2 - \\rho_1 \\sigma^2) = 2\\sigma^2(1 - \\rho_1)\n$$\n最后，我们代入 $\\sigma^2 \\approx \\mathrm{SDNN}^2$：\n$$\n\\mathrm{RMSSD}^2 \\approx 2 \\cdot \\mathrm{SDNN}^2 (1 - \\rho_1)\n$$\n对两边取平方根，得到 RMSSD 和 SDNN 之间的关系：\n$$\n\\mathrm{RMSSD} \\approx \\sqrt{2(1 - \\rho_1)} \\cdot \\mathrm{SDNN}\n$$\n由此，比率 $\\mathrm{RMSSD}/\\mathrm{SDNN}$ 可以用 $\\rho_1$ 来表示。\n\n第三，我们为 RMSSD 和 SDNN 的不同敏感性提供一个频域解释。产生连续差分序列 $d_t = x_t - x_{t-1}$ 的操作，可以被建模为将信号 $x_t$ 通过一个线性时不变（LTI）滤波器。这个一阶差分滤波器的脉冲响应是 $h[n] = \\delta[n] - \\delta[n-1]$，其中 $\\delta[n]$ 是克罗内克δ函数。\n该滤波器的频率响应 $H(\\omega)$ 是其脉冲响应的离散时间傅里叶变换（DTFT）：\n$$\nH(\\omega) = \\sum_{n=-\\infty}^{\\infty} h[n] \\exp(-i\\omega n) = 1 \\cdot \\exp(-i\\omega \\cdot 0) - 1 \\cdot \\exp(-i\\omega \\cdot 1) = 1 - \\exp(-i\\omega)\n$$\n滤波器的功率传输函数是其频率响应的幅值平方：\n$$\n|H(\\omega)|^2 = |1 - \\cos(\\omega) + i\\sin(\\omega)|^2 = (1-\\cos(\\omega))^2 + \\sin^2(\\omega) = 1 - 2\\cos(\\omega) + \\cos^2(\\omega) + \\sin^2(\\omega) = 2 - 2\\cos(\\omega)\n$$\n使用半角恒等式 $1 - \\cos(\\omega) = 2\\sin^2(\\omega/2)$，上式变为：\n$$\n|H(\\omega)|^2 = 4\\sin^2(\\omega/2)\n$$\n输出信号 $d_t$ 的功率谱密度（PSD）是 $S_d(\\omega) = |H(\\omega)|^2 S_x(\\omega)$，其中 $S_x(\\omega)$ 是输入信号 $x_t$ 的功率谱密度。\n差分序列的均值是 $\\mathbb{E}[d_t] = \\mathbb{E}[x_t - x_{t-1}] = \\mu - \\mu = 0$。因此，其方差为 $\\mathbb{E}[d_t^2]$。在大$N$极限下，$\\mathrm{RMSSD}^2 \\approx \\mathbb{E}[d_t^2]$。根据维纳-辛钦定理，方差是功率谱密度的积分：\n$$\n\\mathrm{RMSSD}^2 \\approx \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} S_d(\\omega) d\\omega = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} |H(\\omega)|^2 S_x(\\omega) d\\omega = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} 4\\sin^2(\\omega/2) S_x(\\omega) d\\omega\n$$\n滤波器的功率传输函数 $|H(\\omega)|^2 = 4\\sin^2(\\omega/2)$，作为一个加权函数。该函数在 $\\omega=0$（直流频率）处为0，并在 $\\omega=\\pm\\pi$（奈奎斯特频率）处增加到其最大值4。这是高通滤波器的特性。因此，RMSSD 是信号 $x_t$ 中经过滤波以强调其高频分量的功率的度量。\n\n相比之下，$\\mathrm{SDNN}^2$ 是总方差 $\\sigma^2$ 的估计量。方差是零均值过程的总功率，即其功率谱密度在所有频率上的积分：\n$$\n\\mathrm{SDNN}^2 \\approx \\sigma^2 = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} S_x(\\omega) d\\omega\n$$\n这等效于使用一个对所有 $\\omega$ 都有 $|H(\\omega)|^2=1$ 的功率传输函数的滤波器。这是一个全通滤波器，意味着它对所有频率同等加权。\n通过比较加权函数——RMSSD 的高通滤波器与 SDNN 的全通滤波器——很明显，RMSSD 内在地对 R-R 间期时间序列中的高频（短时间尺度）波动更为敏感，而 SDNN 则反映了所有频率上的总功率。\n\n最后，问题要求给出比率 $\\mathrm{RMSSD}/\\mathrm{SDNN}$ 的闭式解析表达式。根据我们的推导，我们有：\n$$\n\\frac{\\mathrm{RMSSD}}{\\mathrm{SDNN}} \\approx \\sqrt{2(1 - \\rho_1)}\n$$\n这是基于大$N$近似的最终表达式，这是该关系的标准背景。", "answer": "$$\\boxed{\\sqrt{2(1 - \\rho_{1})}}$$", "id": "4613609"}, {"introduction": "除了线性和稳态假设下的经典分析方法，生理时间序列通常表现出更复杂的动态特性，例如长程相关性。本练习提供了一个高级的计算实践，要求你亲手实现“去趋势波动分析”（DFA）这一强大的非线性方法。通过生成具有已知谱特性（即“有色噪声”）的合成数据并应用DFA算法，你将学习如何估计Hurst指数，并将其用于解释生理调控系统中的持续性或抗持续性记忆效应。[@problem_id:4613598]", "problem": "您的任务是使用去趋势波动分析 (DFA) 方法，量化模拟活动记录仪派生变异性的代理心率时间序列中的长程相关性。目标是利用 DFA 在多个尺度上估计 Hurst 指数，并在自主神经系统 (ANS) 调节的背景下解释长程相关性的存在与否。该设计必须植根于生理数据时间序列分析的基本原理。\n\n理论基础。使用以下物理和统计学基础：\n- 对于具有自仿射特性的时间序列，在尺度 $n$ 上的波动遵循幂律关系，其均方根波动幅度 $F(n)$ 的标度关系为 $F(n) \\propto n^{H}$，其中 $H$ 是 Hurst 指数。这表达了标度不变性，并且是长程相关性的一种经过充分检验的数学表征。\n- 去趋势波动分析 (DFA) 方法通过移除窗口内的多项式趋势并测量残差的均方根来估计波动的标度关系。在一阶 DFA (线性去趋势) 中，计算波动是在每个窗口内减去最佳拟合直线后进行的。\n- 在频域中，功率谱密度为 $S(f)\\propto f^{-\\beta}$ 的过程被广泛用作有色随机动力学的代理；这些过程可以模拟多种调节行为。这类有色噪声代理是用于模拟自主调节和运动相关变异性中的低频生理波动的一种经过充分检验的模型。\n\n待实现的任​​务：\n1. 代理生成。通过使用频域着色方法合成功率谱密度为 $S(f)\\propto f^{-\\beta}$ 的有色噪声，构建四个合成的“活动记录仪派生的心率增量”代理序列。设序列长度为 $N=8192$ 个样本，采样间隔为 $\\Delta t = 1$ 秒。对于单边谱的每个频率仓，分配与 $f^{-\\beta/2}$ 成正比的幅度（直流分量仓设为零），分配在 $[0,2\\pi)$ 上均匀分布的独立随机相位，施加实信号约束，并进行实数逆傅里叶变换。合成后，将每个序列标准化为零均值和单位方差。使用以下 $(\\beta,\\text{seed})$ 对的测试套件：$(0,12345)$, $(1,24680)$, $(2,13579)$, $(-1,98765)$。这些分别代表白、粉红、布朗和蓝色谱着色。\n2. DFA 流程。对于每个代理序列 $x(i)$：\n   - 将序列进行均值中心化，并构建累积“轮廓”$y(k)=\\sum_{i=1}^{k}\\left(x(i)-\\bar{x}\\right)$，其中 $k=1,\\dots,N$。\n   - 对于集合 $\\{4,8,16,32,64,128,256,512,1024\\}$ 中的每个窗口大小 $n$，将 $y(k)$ 从头开始和从尾开始划分为长度为 $n$ 的不重叠段，总共得到 $2\\left\\lfloor N/n\\right\\rfloor$ 个段。在每个段中，拟合一条最小二乘直线，并计算去趋势残差的均方根。将 $F(n)$ 定义为各段均方残差的平均值的平方根。\n   - 使用以上所有尺度 $n$，对 $\\log F(n)$ 与 $\\log n$ 进行普通最小二乘回归，以估计斜率 $H$。以无量纲形式回答。\n3. 解释。对于每个估计的 $H$，生成一个整数标签 $L$ 来编码对长程相关性的解释：\n   - 如果 $H>0.6$，设置 $L=1$（持续性长程相关性，与跨尺度的缓慢、协调的 ANS 动力学一致）。\n   - 如果 $H<0.4$，设置 $L=-1$（反持续性动力学，与交替的校正调节一致）。\n   - 否则，设置 $L=0$（在分析的尺度上近似不相关）。\n4. 数值输出规范。对于四个测试用例中的每一个，返回一个双元素列表 $[H,L]$，其中 $H$ 四舍五入到三位小数，$L$ 是上面定义的整数标签。\n5. 最终输出格式。您的程序应生成单行输出，其中包含一个由逗号分隔并用方括号括起来的列表。该列表必须包含四个双元素列表，分别对应四个测试用例，并按给定的 $(\\beta,\\text{seed})$ 对的顺序排列。确切格式为：\n   - $\\left[\\left[H_1,L_1\\right],\\left[H_2,L_2\\right],\\left[H_3,L_3\\right],\\left[H_4,L_4\\right]\\right]$\n   - 仅为格式示例（非实际值）：$\\left[\\left[0.512,0\\right],\\left[0.984,1\\right],\\left[1.497,1\\right],\\left[0.231,-1\\right]\\right]$\n\n约束和说明：\n- 您必须实现一阶 DFA（段内线性去趋势）。\n- 使用确切的尺度集 $n\\in\\{4,8,16,32,64,128,256,512,1024\\}$。\n- 严格按照指定的种子进行操作，以确保可复现性。\n- 不提供外部输入；所有数据均在内部合成。\n- 除时间采样（为求真实性指定为 $\\Delta t=1$ 秒）外，所有计算都是无量纲的；结果 $H$ 是无量纲的，$L$ 是一个整数。\n- 每个测试用例的答案必须是一个包含一个浮点数和一个整数的列表，最终输出必须是如上所述的、由这些列表组成的单行列表。", "solution": "我们通过整合标度不变性的基本定义以及经过充分检验的谱域和时域程序来构建解决方案。\n\n**自仿射与 DFA 标度。** 对于自仿射时间序列，其在尺度 $n$ 上的波动幅度随尺度呈幂律增长。去趋势波动分析 (DFA) 将此过程形式化：首先构建积分轮廓，然后量化典型的去趋势残差。具体来说，给定一个长度为 $N$ 的离散序列 $x(i)$，定义均值中心化的轮廓 $y(k)=\\sum_{i=1}^{k}(x(i)-\\bar{x})$，其中 $k=1,\\dots,N$。对于每个尺度 $n$，通过从前向后和从后向前扫描，将 $y(k)$ 划分为 $2\\left\\lfloor N/n\\right\\rfloor$ 个段，以减轻边界效应。在索引为 $k=s_0,\\dots,s_0+n-1$ 的段 $s$ 中，拟合一个最小二乘线性多项式 $\\hat{y}_s(k)=a_s k + b_s$，并计算该段的残差方差 $v_s(n)=\\frac{1}{n}\\sum_{k=s_0}^{s_0+n-1}\\left(y(k)-\\hat{y}_s(k)\\right)^2$。尺度 $n$ 处的波动函数则定义为 $F(n)=\\sqrt{\\frac{1}{S}\\sum_{s=1}^{S}v_s(n)}$，其中 $S=2\\left\\lfloor N/n\\right\\rfloor$ 是段的总数。对于表现出长程相关性的自仿射过程，$F(n)$ 遵循幂律标度关系，即 $F(n)\\propto n^{H}$，这意味着对于某个常数 $C$，有 $\\log F(n)=H\\log n + C$。因此，在多个尺度上对 $\\log F(n)$ 与 $\\log n$ 进行普通最小二乘回归，可得到 Hurst 指数 $H$ 的估计值（即斜率）。\n\n**用于代理生成的谱着色。** 为了模拟反映不同自主神经状态的、由活动记录仪派生的心率增量，我们生成功率谱密度为 $S(f)\\propto f^{-\\beta}$ 的随机代理，其中 $\\beta$ 控制谱色。这通过频域合成实现：指定单边频谱幅度 $A(f)\\propto f^{-\\beta/2}$，抽取独立的随机相位 $\\phi(f)\\sim \\mathcal{U}(0,2\\pi)$，施加适用于实信号的厄米共轭对称性，并应用实数逆傅里叶变换。为了避免在 $\\beta>0$ 时出现发散，将 $f=0$ 处的直流分量仓的幅度设为零，并将信号标准化为零均值和单位方差以消除尺度效应。选择四个案例以涵盖从反持续到强持续的状态范围：$\\beta\\in\\{-1,0,1,2\\}$。虽然 $\\beta$ 并不能唯一确定生理状态，但这些谱色可作为经过充分检验的、用于模拟运动和自主调节模式的代理。\n\n**与原理相结合的算法步骤：**\n1. **生成代理。** 对于每个指定的 $(\\beta,\\text{seed})$，合成一个长度为 $N$ 的序列，其频谱幅度与 $f^{-\\beta/2}$ 成正比，具有随机相位，并经过实信号约束、逆变换和标准化处理。\n2. **计算 DFA 波动。** 对于尺度 $n\\in\\{4,8,16,32,64,128,256,512,1024\\}$，构建轮廓 $y(k)$，将其划分为不重叠的前向和后向窗口，并通过在每个窗口中进行线性去趋势来计算 $F(n)$。最小二乘直线的系数可以通过协方差公式 $a_s=\\frac{\\sum_k (k-\\bar{k})(y(k)-\\bar{y})}{\\sum_k (k-\\bar{k})^2}$ 和 $b_s=\\bar{y}-a_s\\bar{k}$ 获得，这源于最小化残差平方和，是线性回归的核心定义。\n3. **估计 $H$。** 通过普通最小二乘法对 $\\log F(n)$ 与 $\\log n$ 进行回归。斜率 $H$ 通过闭式解 $H = \\frac{\\sum (\\log n - \\overline{\\log n})(\\log F(n) - \\overline{\\log F(n)})}{\\sum (\\log n - \\overline{\\log n})^2}$ 获得，这与从标度不变性导出的理论关系 $\\log F(n) = H \\log n + C$ 一致。虽然可以通过残差方差 $\\hat{\\sigma}^2 = \\frac{1}{m-2}\\sum (\\log F(n) - \\widehat{\\log F(n)})^2$（其中 $m$ 为尺度数）和设计方差 $\\sum (\\log n - \\overline{\\log n})^2$ 推导置信区间，但本任务仅要求点估计和解释。\n4. **根据 ANS 术语解释 $H$。** 使用基于持续性质性含义的阈值：\n   - $H>0.6$ 表示持续性长程相关性 ($L=1$)，通常见于缓慢变化的、协调的调节影响，如昼夜节律和低频自主调节。\n   - $H<0.4$ 表示反持续性行为 ($L=-1$)，表明存在频繁的校正反馈动力学，其中增加很可能后随减少。\n   - 中间值 ($0.4\\leq H\\leq 0.6$) 表明在分析的尺度内近似缺乏长程相关性 ($L=0$)。\n   这些阈值平衡了对有限样本变异性的稳健性，并与生理学背景下对 DFA 指数的解释一致。\n\n**测试套件与覆盖范围：**\n- 案例 1：$\\beta=0$，种子固定；预期 $H$ 接近 $0.5$（白噪声基线），用于检验近似不相关的情况。\n- 案例 2：$\\beta=1$，种子固定；预期 $H$ 接近 $1.0$（粉红噪声），用于检验持续性长程相关性。\n- 案例 3：$\\beta=2$，种子固定；预期 $H$ 接近 $1.5$（布朗噪声），用于检验强持续性。\n- 案例 4：$\\beta=-1$，种子固定；预期 $H$ 低于 $0.5$（蓝噪声），用于检验反持续性。\n该套件覆盖了“理想路径”、持续性极端情况和反持续性边界。\n\n**输出。** 对于每个案例，返回 $[H,L]$，其中 $H$ 四舍五入到三位小数，$L\\in\\{-1,0,1\\}$。将所有四个案例的结果汇总成一个单行列表，格式为 $\\left[\\left[H_1,L_1\\right],\\left[H_2,L_2\\right],\\left[H_3,L_3\\right],\\left[H_4,L_4\\right]\\right]$。\n\n最终程序使用指定的种子确定性地实现上述步骤，并仅打印所需的单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_colored_noise(N: int, beta: float, seed: int) -> np.ndarray:\n    \"\"\"\n    Generate a real-valued colored noise time series of length N with PSD ~ f^(-beta).\n    Uses one-sided spectrum (rfft) with random phases and appropriate magnitude shaping.\n    The output is standardized to zero mean and unit variance.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    # One-sided frequency bins for rfft with sampling interval dt=1\n    freqs = np.fft.rfftfreq(N, d=1.0)\n    # Magnitude shaping: amplitude ~ f^(-beta/2)\n    amp = np.zeros_like(freqs, dtype=float)\n    nonzero = freqs > 0.0\n    # Avoid division by zero at DC\n    amp[nonzero] = freqs[nonzero] ** (-beta / 2.0)\n\n    # Random phases in [0, 2pi)\n    phases = rng.uniform(0.0, 2.0 * np.pi, size=freqs.shape)\n\n    # Build complex spectrum for rfft: DC bin is 0; Nyquist bin must be real if N even.\n    spectrum = np.zeros_like(freqs, dtype=np.complex128)\n    # Positive-frequency bins (excluding DC)\n    spectrum[nonzero] = amp[nonzero] * (np.cos(phases[nonzero]) + 1j * np.sin(phases[nonzero]))\n    # Enforce real Nyquist bin if N even: set purely real value with random cosine phase\n    if N % 2 == 0:\n        # Last bin corresponds to Nyquist frequency\n        idx_nyq = spectrum.shape[0] - 1\n        # Replace with real part only to satisfy Hermitian symmetry for irfft\n        spectrum[idx_nyq] = amp[idx_nyq] * np.cos(phases[idx_nyq]) + 0.0j\n\n    # Inverse real FFT to obtain time series\n    x = np.fft.irfft(spectrum, n=N)\n    # Standardize to zero mean and unit variance\n    x = x - np.mean(x)\n    std = np.std(x)\n    if std > 0:\n        x = x / std\n    return x\n\ndef dfa_alpha(x: np.ndarray, scales: np.ndarray) -> float:\n    \"\"\"\n    First-order DFA (linear detrending) to estimate scaling exponent H.\n    Returns the OLS slope of log F(n) vs log n across provided scales.\n    \"\"\"\n    N = x.size\n    # Profile (integrated, mean-centered signal)\n    x_centered = x - np.mean(x)\n    y = np.cumsum(x_centered)\n\n    F_vals = []\n    n_vals = []\n\n    for n in scales:\n        n = int(n)\n        if n  2 or n > N:\n            continue\n        Ns = N // n  # number of segments per direction\n        if Ns  2:\n            continue\n\n        # Precompute regression constants for linear detrending within a window of length n\n        t = np.arange(n, dtype=float)\n        t_mean = (n - 1.0) / 2.0\n        t_centered = t - t_mean\n        Sxx = np.sum(t_centered ** 2)\n\n        seg_vars = []\n\n        # Forward segments\n        for i in range(Ns):\n            start = i * n\n            seg = y[start:start + n]\n            y_mean = np.mean(seg)\n            # Covariance between t and seg\n            Sxy = np.sum(t_centered * (seg - y_mean))\n            slope = Sxy / Sxx\n            intercept = y_mean - slope * t_mean\n            residual = seg - (slope * t + intercept)\n            seg_vars.append(np.mean(residual ** 2))\n\n        # Backward segments (from the end)\n        for i in range(Ns):\n            start = N - (i + 1) * n\n            seg = y[start:start + n]\n            y_mean = np.mean(seg)\n            Sxy = np.sum(t_centered * (seg - y_mean))\n            slope = Sxy / Sxx\n            intercept = y_mean - slope * t_mean\n            residual = seg - (slope * t + intercept)\n            seg_vars.append(np.mean(residual ** 2))\n\n        F_n = np.sqrt(np.mean(seg_vars))\n        if F_n > 0:\n            F_vals.append(F_n)\n            n_vals.append(n)\n\n    n_vals = np.array(n_vals, dtype=float)\n    F_vals = np.array(F_vals, dtype=float)\n\n    # Linear regression in log-log space\n    logn = np.log(n_vals)\n    logF = np.log(F_vals)\n    \n    # Manual OLS for robustness\n    x_mean = np.mean(logn)\n    y_mean = np.mean(logF)\n    Sxx_log = np.sum((logn - x_mean) ** 2)\n    Sxy_log = np.sum((logn - x_mean) * (logF - y_mean))\n    slope_log = Sxy_log / Sxx_log\n    return float(slope_log)\n\ndef classify_persistence(H: float, low: float = 0.4, high: float = 0.6) -> int:\n    \"\"\"\n    Classify long-range dependence based on Hurst exponent H.\n    Returns:\n      1 for H > high (persistent),\n      -1 for H  low (anti-persistent),\n      0 otherwise (approximately uncorrelated).\n    \"\"\"\n    if H > high:\n        return 1\n    elif H  low:\n        return -1\n    else:\n        return 0\n\ndef solve():\n    # Define parameters\n    N = 8192  # number of samples\n    # Scales: powers of two from 4 to 1024 inclusive\n    scales = np.array([2 ** k for k in range(2, 11)], dtype=int)\n\n    # Test cases: (beta, seed)\n    test_cases = [\n        (0.0, 12345),   # White noise\n        (1.0, 24680),   # Pink noise\n        (2.0, 13579),   # Brown noise\n        (-1.0, 98765),  # Blue noise\n    ]\n\n    results = []\n    for beta, seed in test_cases:\n        x = generate_colored_noise(N, beta, seed)\n        H = dfa_alpha(x, scales)\n        label = classify_persistence(H, low=0.4, high=0.6)\n        results.append((H, label))\n\n    # Format output: [[H1,L1],[H2,L2],[H3,L3],[H4,L4]] with H rounded to 3 decimals, no spaces\n    formatted_items = []\n    for H, L in results:\n        formatted_items.append(f\"[{H:.3f},{L}]\")\n    print(f\"[{','.join(formatted_items)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "4613598"}]}