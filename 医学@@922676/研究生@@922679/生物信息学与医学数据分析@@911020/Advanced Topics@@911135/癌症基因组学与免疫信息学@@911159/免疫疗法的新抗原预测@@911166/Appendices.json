{"hands_on_practices": [{"introduction": "肽与主要组织相容性复合体（MHC）分子的结合是T细胞识别的第一步，也是新抗原预测的核心。计算模型，即使是简单的加性模型，也被广泛用于预测这种结合亲和力的大小。本练习 [@problem_id:4589194] 将通过一个基础性的工具——位置特异性评分矩阵（PSSM），来演示如何量化突变对结合能的影响，从而为评估新抗原的潜力提供依据。", "problem": "一个长度为 $9$ 的肿瘤源肽与人类白细胞抗原 (HLA) I类等位基因 HLA-A$^{\\ast}02{:}01$ 结合。在I类主要组织相容性复合体 (MHC) 的提呈过程中，一个9聚体肽的第 $2$ 和第 $9$ 位通常作为锚定位置。考虑9聚体肽序列 $KILGNVYVL$ (位置从 $1$ 到 $9$ 索引)。在一个基于平衡统计热力学的简单、有物理动机的加性模型下，结合自由能 $ \\Delta G_{\\text{bind}} $ 近似为每个位置上氨基酸的位置特异性贡献之和，并且某个位置上发生取代的效应是该位置对 $ \\Delta G_{\\text{bind}} $ 贡献的变化；未改变位置的贡献相对于该取代可以被视为常数。\n\n现给出以下针对 HLA-A$^{\\ast}02{:}01$ 锚定位置的、校准过的位置特异性贡献 (单位为 $\\mathrm{kcal/mol}$)，这些贡献被解释为该位置的氨基酸对肽-MHC结合自由能的贡献。更负的值表示更有利的结合。\n\n- 位置 $2$ 的贡献 $\\varepsilon_{2}(\\cdot)$：\n  - $L{:}\\,-2.5$, $M{:}\\,-2.0$, $I{:}\\,-1.8$, $V{:}\\,-1.5$, $T{:}\\,-0.5$, $A{:}\\,+0.4$, 任何其他残基: $+0.6$。\n- 位置 $9$ 的贡献 $\\varepsilon_{9}(\\cdot)$：\n  - $V{:}\\,-2.0$, $L{:}\\,-1.8$, $I{:}\\,-1.5$, $A{:}\\,-1.0$, $F{:}\\,-0.7$, 任何其他残基: $+0.2$。\n\n假设位置 $2$ 和 $9$ 的取代对其 $ \\Delta G_{\\text{bind}} $ 的影响是独立的，并且其他位置的贡献保持不变，因此在计算结合自由能变化时会相互抵消。\n\n任务：识别给定肽中位置 $2$ 和 $9$ 的残基，然后，使用加性模型，计算当两个锚定残基都被丙氨酸替换时的双重取代(即，同时进行 $2{:}\\,\\text{I} \\to \\text{A}$ 和 $9{:}\\,\\text{L} \\to \\text{A}$)所预测的结合自由能总变化 $ \\Delta\\Delta G $ (突变体减去野生型，单位为 $\\mathrm{kcal/mol}$)。以 $\\mathrm{kcal/mol}$ 为单位表示您的最终答案。无需进行超出上述数值所隐含的精确算术之外的四舍五入。", "solution": "首先根据所需标准对问题陈述进行验证。\n\n### 问题验证\n\n1.  **提取已知信息**：\n    -   肽长度：$9$\n    -   HLA 等位基因：HLA-A$^{\\ast}02{:}01$\n    -   锚定位置：$9$聚体肽的第 $2$ 和第 $9$ 位\n    -   野生型肽序列：$KILGNVYVL$\n    -   结合自由能模型：$\\Delta G_{\\text{bind}}$ 是位置特异性贡献之和，$\\Delta G_{\\text{bind}} = \\sum \\varepsilon_i(\\text{AA}_i)$。\n    -   位置 $2$ 的贡献 $\\varepsilon_{2}(\\cdot)$，单位 $\\mathrm{kcal/mol}$：$L{:}\\,-2.5$, $M{:}\\,-2.0$, $I{:}\\,-1.8$, $V{:}\\,-1.5$, $T{:}\\,-0.5$, $A{:}\\,+0.4$, 其他: $+0.6$。\n    -   位置 $9$ 的贡献 $\\varepsilon_{9}(\\cdot)$，单位 $\\mathrm{kcal/mol}$：$V{:}\\,-2.0$, $L{:}\\,-1.8$, $I{:}\\,-1.5$, $A{:}\\,-1.0$, $F{:}\\,-0.7$, 其他: $+0.2$。\n    -   假设：位置 $2$ 和 $9$ 的取代对 $\\Delta G_{\\text{bind}}$ 的影响是独立的。其他位置的贡献是恒定的。\n    -   任务：计算对于位置 $2$ 的 $I \\to A$ 和位置 $9$ 的 $L \\to A$ 的双重取代，结合自由能的总变化，$\\Delta\\Delta G = \\Delta G_{\\text{mutant}} - \\Delta G_{\\text{wild type}}$。\n\n2.  **验证**：\n    -   **科学依据**：该问题具有科学合理性。它使用了一种在生物信息学和计算免疫学中简化但常用且有效的方法，即位置特异性打分矩阵 (PSSM) 来估计肽-MHC结合自由能。锚定残基、HLA等位基因和加性自由能模型的概念是该领域的核心。\n    -   **适定性**：该问题是适定的。它提供了所有必要的数据（肽序列、特定的突变，以及相关氨基酸和位置的能量贡献的完整表格）。模型被明确定义。\n    -   **客观性**：该问题以客观、定量的术语陈述，没有歧义或主观看法。\n\n3.  **结论**：该问题有效。我们可以继续进行求解。\n\n### 解法\n\n该问题要求计算一个与 HLA-A$^{\\ast}02{:}01$ 分子结合的9聚体肽发生双重取代时的结合自由能变化，即 $\\Delta\\Delta G$。\n\n野生型肽序列为 $KILGNVYVL$。我们从 $1$ 到 $9$ 对位置进行索引。位置 $2$ 的氨基酸是异亮氨酸 ($I$)，位置 $9$ 的氨基酸是亮氨酸 ($L$)。\n\n双重取代将这些锚定残基替换为丙氨酸 ($A$)。因此，突变肽在位置 $2$ 和 $9$ 处是丙氨酸。\n\n总结合自由能 $\\Delta G_{\\text{bind}}$ 被建模为位置特异性贡献的加性总和：\n$$\n\\Delta G_{\\text{bind}} = \\sum_{i=1}^{9} \\varepsilon_{i}(\\text{AA}_i)\n$$\n其中 $\\text{AA}_i$ 是位置 $i$ 的氨基酸，$\\varepsilon_{i}(\\cdot)$ 是该氨基酸在该位置对自由能的贡献。\n\n对于野生型 (WT) 肽，其结合自由能为：\n$$\n\\Delta G_{\\text{WT}} = \\varepsilon_2(I) + \\varepsilon_9(L) + \\sum_{i \\in \\{1,3,4,5,6,7,8\\}} \\varepsilon_{i}(\\text{AA}_i)\n$$\n该和式代表了所有非锚定位置的贡献。我们用 $C$ 表示这个常数和：\n$$\nC = \\sum_{i \\in \\{1,3,4,5,6,7,8\\}} \\varepsilon_{i}(\\text{AA}_i)\n$$\n因此，$\\Delta G_{\\text{WT}} = \\varepsilon_2(I) + \\varepsilon_9(L) + C$。\n\n对于突变体 (MT) 肽，锚定残基被替换为丙氨酸 ($A$)。其结合自由能为：\n$$\n\\Delta G_{\\text{MT}} = \\varepsilon_2(A) + \\varepsilon_9(A) + \\sum_{i \\in \\{1,3,4,5,6,7,8\\}} \\varepsilon_{i}(\\text{AA}_i)\n$$\n由于非锚定位置的残基未发生变化，它们的贡献是相同的常数 $C$。\n因此，$\\Delta G_{\\text{MT}} = \\varepsilon_2(A) + \\varepsilon_9(A) + C$。\n\n结合自由能的变化 $\\Delta\\Delta G$ 定义为 $\\Delta G_{\\text{MT}} - \\Delta G_{\\text{WT}}$：\n$$\n\\Delta\\Delta G = (\\varepsilon_2(A) + \\varepsilon_9(A) + C) - (\\varepsilon_2(I) + \\varepsilon_9(L) + C)\n$$\n常数项 $C$ 被消掉了：\n$$\n\\Delta\\Delta G = (\\varepsilon_2(A) - \\varepsilon_2(I)) + (\\varepsilon_9(A) - \\varepsilon_9(L))\n$$\n这个表达式表明，总的结合能变化是每个被取代位置上变化的总和，这与所述的取代独立性是一致的。\n\n我们分别定义每个位置的变化：\n$\\Delta\\Delta G_2 = \\varepsilon_2(A) - \\varepsilon_2(I)$\n$\\Delta\\Delta G_9 = \\varepsilon_9(A) - \\varepsilon_9(L)$\n因此，$\\Delta\\Delta G = \\Delta\\Delta G_2 + \\Delta\\Delta G_9$。\n\n现在我们使用给定的能量贡献值 (单位为 $\\mathrm{kcal/mol}$)。\n\n对于位置 $2$ 的取代 ($I \\to A$)：\n- 异亮氨酸 ($I$) 的贡献：$\\varepsilon_2(I) = -1.8$\n- 丙氨酸 ($A$) 的贡献：$\\varepsilon_2(A) = +0.4$\n\n位置 $2$ 的变化是：\n$$\n\\Delta\\Delta G_2 = (+0.4) - (-1.8) = 0.4 + 1.8 = 2.2 \\, \\mathrm{kcal/mol}\n$$\n\n对于位置 $9$ 的取代 ($L \\to A$)：\n- 亮氨酸 ($L$) 的贡献：$\\varepsilon_9(L) = -1.8$\n- 丙氨酸 ($A$) 的贡献：$\\varepsilon_9(A) = -1.0$\n\n位置 $9$ 的变化是：\n$$\n\\Delta\\Delta G_9 = (-1.0) - (-1.8) = -1.0 + 1.8 = 0.8 \\, \\mathrm{kcal/mol}\n$$\n\n结合自由能的总变化是各个变化的总和：\n$$\n\\Delta\\Delta G = \\Delta\\Delta G_2 + \\Delta\\Delta G_9 = 2.2 + 0.8 = 3.0 \\, \\mathrm{kcal/mol}\n$$\n$\\Delta\\Delta G$ 的正值表明，该双重突变被预测为不稳定的，使得肽-MHC的结合变得更不利。", "answer": "$$\\boxed{3.0}$$", "id": "4589194"}, {"introduction": "从预测转向数据质量控制至关重要。原始的测序数据充满了噪声，一个关键挑战是区分真实的体细胞突变和技术假象，例如由福尔马林固定石蜡包埋（FFPE）样本处理过程引入的假象。本实践 [@problem_id:4589136] 将引导你构建一个复杂的统计过滤器，它综合利用了链偏好性、序列上下文的证据，并结合p值与控制假发现率，这些都是基因组数据分析师必备的技能。", "problem": "甲醛固定石蜡包埋 (FFPE) 的组织保存方法会诱导胞嘧啶脱氨，将其转化为尿嘧啶。在分子生物学的中心法则过程中，复制机制会将尿嘧啶识别为胸腺嘧啶，这在经过扩增和测序后，表现为正向链上明显的胞嘧啶到胸腺嘧啶的替换，或反向链上鸟嘌呤到腺嘌呤的替换。在新一代测序 (NGS) 用于新抗原预测的变异检测流程中，此类假象会增加表现为 $C \\rightarrow T$ 或 $G \\rightarrow A$ 的候选单核苷酸变异的数量。本问题要求您设计一种统计筛选方法，利用链偏好性和序列上下文来识别由 FFPE 引起的假象，并将假发现率控制在指定水平。\n\n从以下基本依据出发：\n\n- 化学脱氨会引入单链损伤，这些损伤在测序读段的各个方向上分布不均。在一个真实突变且无技术偏见的零假设下，正向链与反向链上的等位基因变异观测遵循一个对称过程。将正向链上的等位基因变异观测计数建模为二项随机变量 $K \\sim \\mathrm{Binomial}(n, p)$，其中 $p = 0.5$，$n$ 是两条链上等位基因变异观测的总数，$K$ 是在正向链上观测到的数量。\n\n- 序列上下文调节脱氨的易感性。我们将易感上下文定义为参考序列中紧邻鸟嘌呤 3' 端的胞嘧啶 (CpG)，或鸟嘌呤的反向互补等价物。在真实突变发生的上下文与局部基因组组成成正比的零假设下，一个随机位置的真实突变落入易感上下文的概率等于从参考序列邻域计算出的局部易感上下文频率 $q \\in [0,1]$。\n\n您的任务：\n\n1. 对每个候选变异，在给定总共 $n$ 个等位基因变异观测和 $k$ 个正向链等位基因变异观测的情况下，根据零假设 $p = 0.5$ 计算链对称性的双边 p 值。请使用精确二项检验。\n\n2. 对每个候选变异，按如下方式计算上下文易感性的单边 p 值。如果事件类型为 $C \\rightarrow T$ 或 $G \\rightarrow A$，并且该位点的三核苷酸参考序列上下文是易感的，则在零假设下观测到易感上下文的概率为 $q$；将此单次试验事件视为一次伯努利成功，并将上下文 p 值设为 $q$。如果事件类型不是 $C \\rightarrow T$ 或 $G \\rightarrow A$，或上下文非易感，则将上下文 p 值设为 $1$，以避免仅因上下文而错误地夸大显著性。\n\n3. 使用 Fisher 方法合并每个变异的链偏好性 p 值和上下文 p 值。设 p 值为 $p_1$ 和 $p_2$。计算统计量 $$X = -2 \\sum_{i=1}^{2} \\ln(p_i),$$ 并将合并后的 p 值计算为具有 $2 \\times 2$ 自由度的卡方分布的生存函数，即 $$p_{\\mathrm{comb}} = \\Pr\\left(\\chi^2_{4} \\ge X\\right)。$$\n\n4. 使用 Benjamini-Hochberg (BH) 程序，在候选变异集合中将假发现率控制在 $\\alpha = 0.05$ 的水平。假设有 $m$ 个变异，其合并后的 p 值按升序排列为 $p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。计算校正后的 p 值 $$\\tilde{p}_{(i)} = \\min\\left\\{1, \\min_{j \\ge i} \\frac{m \\, p_{(j)}}{j}\\right\\},$$ 并将这些值映射回原始顺序。如果一个变异经 BH 校正后的 p 值满足 $\\tilde{p} \\le \\alpha$，则将其标记为假象。\n\n5. 将此实现为一个完整的程序，该程序接受以下指定的测试套件并生成所需的输出格式。\n\n测试套件规范。每个测试用例提供：\n\n- $n$：正向链和反向链上的等位基因变异总观测数。\n- $k$：正向链等位基因变异观测数。\n- $\\mathrm{sus}$：一个布尔值，指示在参考序列下该位点是否处于易感上下文（CpG 或其反向互补等价物）中。\n- $q$：从参考序列邻域计算出的局部易感上下文频率，以小数表示。\n- $\\mathrm{type}$：观测到的替换类型，以字符串表示。\n\n请严格按以下顺序使用六个测试用例：\n\n1. $(n = 20, k = 18, \\mathrm{sus} = \\mathrm{True}, q = 0.12, \\mathrm{type} = \\text{\"CT\"})$\n2. $(n = 20, k = 10, \\mathrm{sus} = \\mathrm{True}, q = 0.12, \\mathrm{type} = \\text{\"CT\"})$\n3. $(n = 10, k = 7, \\mathrm{sus} = \\mathrm{True}, q = 0.12, \\mathrm{type} = \\text{\"CT\"})$\n4. $(n = 20, k = 18, \\mathrm{sus} = \\mathrm{False}, q = 0.12, \\mathrm{type} = \\text{\"CT\"})$\n5. $(n = 8, k = 4, \\mathrm{sus} = \\mathrm{False}, q = 0.12, \\mathrm{type} = \\text{\"CT\"})$\n6. $(n = 15, k = 14, \\mathrm{sus} = \\mathrm{True}, q = 0.05, \\mathrm{type} = \\text{\"CT\"})$\n\n最终输出格式。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个布尔值，指示在 $\\alpha = 0.05$ 的假发现率控制下它是否被标记为假象。例如，如果前两个是假象，其余的不是，则输出必须严格采用 $[\\mathrm{True},\\mathrm{True},\\mathrm{False},\\mathrm{False},\\mathrm{False},\\mathrm{False}]$ 的形式。", "solution": "甲醛固定石蜡包埋 (FFPE) 处理使脱氧核糖核酸暴露于甲醛和高温环境中，这可能导致胞嘧啶发生水解脱氨，转变为尿嘧啶。在聚合酶扩增过程中，尿嘧啶与胸腺嘧啶配对，导致当参考序列为胞嘧啶时出现表观的 $C \\rightarrow T$ 替换，而当参考序列在相反链上为鸟嘌呤时出现表观的 $G \\rightarrow A$ 替换。由于这些损伤通常是单链的，并且在片段方向上分布不均，真实的生物突变在正向与反向链的等位基因变异观测中不应表现出强烈的偏好性，而 FFPE 假象则可能表现出显著的链不对称性。此外，由于甲基化和局部化学环境的影响，CpG 上下文中的脱氨易感性更高，因此在 FFPE 处理下，CpG 中的 $C \\rightarrow T$ 更有可能是假象。\n\n基于对这些现象的统计建模，可以直接得出一个基于原理的筛选方法。\n\n1. 链偏好性检验。在真实突变没有方向偏好的零假设下，正向链与反向链上的等位基因变异观测遵循 $K \\sim \\mathrm{Binomial}(n, p)$ 分布，其中 $p = 0.5$，$n$ 是等位基因变异总观测数，$k$ 是正向链上的变异观测数。观测到至少与 $k$ 一样极端的偏差的精确双边 p 值，可通过参数 $p=0.5$ 的精确二项检验计算得出。该检验源于伯努利试验模型，这是一个经过充分检验的概率框架，适用于独立的链分配观测。\n\n2. 上下文易感性检验。假设易感上下文是参考序列胞嘧啶上的 CpG（或鸟嘌呤的反向互补等价物）。如果一个变异类型为 $C \\rightarrow T$ 或 $G \\rightarrow A$，且其三核苷酸上下文是易感的，则在“落入易感上下文的概率等于局部基因组背景频率 $q$”的零假设下，将该事件视为单次伯努利试验。当事件发生在易感上下文中时，观测到易感上下文的单边 p 值为 $q$，因为在单次伯努利试验模型中，发生一次成功或至少一次成功的概率为 $q$。如果事件非易感或属于不同的替换类型，则将上下文 p 值设为 $1$，以确保上下文不会在不应驱动显著性的地方驱动显著性。\n\n3. 用于合并证据的 Fisher 方法。为了整合两个独立的证据线索（链偏好性和上下文），使用 Fisher 方法。对于 p 值 $p_1$ 和 $p_2$，定义 $$X = -2 \\sum_{i=1}^{2} \\ln(p_i)。$$ 在两个检验的零假设都为真且 p 值独立的条件下，$X$ 遵循一个具有 $2 \\times 2 = 4$ 个自由度的卡方分布。合并后的 p 值为 $$p_{\\mathrm{comb}} = \\Pr\\left(\\chi^2_{4} \\ge X\\right),$$ 即在 $X$ 处求值的生存函数。\n\n4. 通过 Benjamini-Hochberg (BH) 控制假发现率。对于 $m$ 个变异，将其合并后的 p 值按升序排列 $p_{(1)} \\le \\dots \\le p_{(m)}$。BH 校正后的 p 值为 $$\\tilde{p}_{(i)} = \\min\\left\\{1, \\min_{j \\ge i} \\frac{m \\, p_{(j)}}{j}\\right\\}。$$ 这种构造确保了校正后 p 值的单调性，并将假发现的预期比例控制在水平 $\\alpha$，这是多重假设检验中一个经过充分检验的程序。\n\n5. 应用于测试套件。对于六个案例中的每一个，通过 $p=0.5$ 的精确二项检验计算链偏好性 p 值。对于类型为 $C \\rightarrow T$ 且位点易感的案例，将上下文 p 值设为给定的 $q$，否则设 $p_{\\mathrm{context}} = 1$。通过 Fisher 方法合并 p 值，得到每个案例的 $p_{\\mathrm{comb}}$。对这些合并后的 p 值应用 $m=6$ 和 $\\alpha=0.05$ 的 BH 程序。\n\n用于建立直觉的说明性近似计算：\n\n- 对于 $(n = 20, k = 18)$，使用 $p=0.5$ 的双边二项 p 值约为 $0.000402$。当 $q = 0.12$ 时，Fisher 统计量为 $X \\approx -2(\\ln 0.000402 + \\ln 0.12) \\approx 19.874$，在 $\\chi^2_{4}$ 分布上产生的 $p_{\\mathrm{comb}}$ 约为 $10^{-3}$ 的数量级。这是存在假象的强有力证据。\n\n- 对于 $(n = 20, k = 10)$，双边二项 p 值为 $1.0$，因为观测结果与零假设完全匹配；与 $q = 0.12$ 合并后得到 $X \\approx 4.240$， $p_{\\mathrm{comb}}$ 接近 $0.374$，不显著。\n\n- 对于 $(n = 10, k = 7)$，双边二项 p 值约为 $0.343$；与 $q = 0.12$ 合并后得到 $p_{\\mathrm{comb}}$ 接近 $0.15$，在 BH 校正后不显著。\n\n- 对于非易感上下文中的 $(n = 20, k = 18)$，上下文 p 值设为 $1$，因此 Fisher 方法仅反映链证据；$X \\approx -2\\ln 0.000402 \\approx 15.634$ 产生的 $p_{\\mathrm{comb}}$ 约为几个 $10^{-3}$。\n\n- 对于 $(n = 8, k = 4)$，二项 p 值为 $1.0$；当 $p_{\\mathrm{context}} = 1$ 时，$X = 0$ 且 $p_{\\mathrm{comb}} = 1.0$。\n\n- 对于 $(n = 15, k = 14)$，双边二项 p 值约为 $0.000976$；当 $q = 0.05$ 时，Fisher 方法给出 $X \\approx 19.852$ 和一个非常小的合并 p 值。\n\n在对合并后的 p 值进行排序并应用 $m=6$ 的 BH 程序后，第一、第四和第六个案例的校正后 p 值低于 $\\alpha = 0.05$，而其余案例则没有。因此，程序应将案例 1、4 和 6 标记为假象。\n\n最终输出是一行按测试用例顺序排列的布尔值，指示在 $\\alpha = 0.05$ 的 BH 控制下是否为假象。基于以上推理，预期输出为 $[\\mathrm{True},\\mathrm{False},\\mathrm{False},\\mathrm{True},\\mathrm{False},\\mathrm{True}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import binomtest, chi2\n\ndef fisher_combined_p(p_values):\n    \"\"\"\n    Combine p-values using Fisher's method.\n    p_values: list or array of p-values (assumed independent).\n    Returns the combined p-value via chi-square survival function.\n    \"\"\"\n    p_values = np.clip(np.array(p_values, dtype=float), 1e-300, 1.0)\n    X = -2.0 * np.sum(np.log(p_values))\n    df = 2 * len(p_values)\n    return float(chi2.sf(X, df))\n\ndef benjamini_hochberg(pvals, alpha=0.05):\n    \"\"\"\n    Benjamini-Hochberg FDR control.\n    pvals: list of raw p-values.\n    alpha: FDR level.\n    Returns adjusted p-values in the original order and flags (True if adj p = alpha).\n    \"\"\"\n    m = len(pvals)\n    # Sort p-values and keep original indices\n    order = np.argsort(pvals)\n    sorted_p = np.array(pvals)[order]\n    adj = np.empty(m, dtype=float)\n    # Compute BH adjusted p-values with monotonicity\n    prev = 1.0\n    for i in range(m - 1, -1, -1):\n        rank = i + 1  # ranks are 1..m\n        val = (m * sorted_p[i]) / rank\n        prev = min(prev, val)\n        adj[i] = min(prev, 1.0)\n    # Map back to original order\n    adj_full = np.empty(m, dtype=float)\n    adj_full[order] = adj\n    flags = adj_full = alpha\n    return adj_full.tolist(), flags.tolist()\n\ndef context_p_value(is_susceptible, q_bg, mut_type):\n    \"\"\"\n    Compute one-sided context p-value.\n    If mutation type is C>T or G>A and context is susceptible, p = q_bg.\n    Otherwise, p = 1 (neutral).\n    \"\"\"\n    if mut_type in (\"C>T\", \"G>A\") and is_susceptible:\n        return float(q_bg)\n    else:\n        return 1.0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (n_total, k_forward, susceptible_context, q_bg, mutation_type)\n    test_cases = [\n        (20, 18, True, 0.12, \"C>T\"),\n        (20, 10, True, 0.12, \"C>T\"),\n        (10, 7,  True, 0.12, \"C>T\"),\n        (20, 18, False,0.12, \"C>T\"),\n        (8,  4,  False,0.12, \"C>T\"),\n        (15, 14, True, 0.05, \"C>T\"),\n    ]\n\n    combined_pvals = []\n    for n_total, k_fwd, sus, q, mtype in test_cases:\n        # Strand-bias p-value (two-sided exact binomial test with p=0.5)\n        p_strand = binomtest(k_fwd, n_total, 0.5, alternative='two-sided').pvalue\n        # Context p-value\n        p_ctx = context_p_value(sus, q, mtype)\n        # Combine using Fisher's method\n        p_comb = fisher_combined_p([p_strand, p_ctx])\n        combined_pvals.append(p_comb)\n\n    # Apply Benjamini-Hochberg at alpha=0.05\n    _, flags = benjamini_hochberg(combined_pvals, alpha=0.05)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(f).capitalize() for f in flags)}]\")\n\nsolve()\n```", "id": "4589136"}, {"introduction": "在鉴定出一系列高可信度的新抗原候选后，最后的转化步骤是为个性化疫苗挑选最佳的肽组合。这并非简单的排序问题，而是一个带约束的优化问题。本练习 [@problem_id:4589173] 将疫苗设计构建为一个类似于背包问题的优化模型，其目标是在控制疫苗容量和最小化冗余的同时，最大化整体的免疫原性。", "problem": "给定一组候选新抗原肽，每种肽都用与免疫原性相关的特征进行注释：与I类主要组织相容性复合体（MHC）的结合亲和力（以纳摩尔为单位的半数抑制浓度报告，缩写为$IC50$）、基因表达（每百万转录本数，缩写为$TPM$）、变异等位基因频率（缩写为$VAF$；表示为小数）以及抗原加工概率（一个在$[0,1]$范围内的概率）。目标是选择一个肽子集以包含在基于肽的癌症疫苗中，该选择受疫苗氨基酸长度预算$B$的限制，旨在最大化预期免疫原性，同时抑制选择序列高度相似的冗余肽。问题是在以下数学指定的模型和约束条件下，为多个测试用例计算最优子集。\n\n基本原理和定义：\n- 分子生物学中心法则断言，蛋白质表达与转录本丰度成正比；因此，较高的$TPM$可以增加肽的呈递。\n- 与主要组织相容性复合体（MHC）的结合越强，通常会增加肽呈递的可能性；较低的$IC50$意味着更强的结合。\n- 免疫原性可以通过一个结合了各种特征的线性分数的逻辑斯蒂链接函数（sigmoid）来建模，这是生物统计学中处理二元结果的一种经过充分检验的方法。\n- 当事件被建模为独立的伯努利随机变量时，一个集合的预期免疫原性可以通过各个概率的总和来近似。\n- 由序列相似性（例如，重叠的表位竞争相同的T细胞克隆）引起的冗余可以通过一个由$[0,1]$范围内的相似性分数缩放的两两配对项来进行惩罚。\n\n对于每个具有特征 $IC50_i$（单位纳摩尔）、$E_i$（单位$TPM$）、$VAF_i$（在$[0,1]$内的小数）和 $P_i$（在$[0,1]$内的加工概率）的肽 $i$，定义线性分数\n$$\nz_i = \\beta_0 + \\beta_{\\mathrm{aff}} \\log\\left(\\frac{500}{IC50_i}\\right) + \\beta_{\\mathrm{expr}} \\log\\left(1 + E_i\\right) + \\beta_{\\mathrm{vaf}} \\cdot VAF_i + \\beta_{\\mathrm{proc}} \\cdot P_i,\n$$\n其中 $\\log$ 是自然对数。肽 $i$ 的预期免疫原性概率则为\n$$\np_i = \\frac{1}{1 + \\exp(-z_i)}.\n$$\n给定一个对称相似性矩阵 $S$，其条目 $s_{ij} \\in [0,1]$ 且对所有 $i$ 都有 $s_{ii} = 0$，以及一个冗余惩罚系数 $\\lambda \\ge 0$，定义在二元选择 $x_i \\in \\{0,1\\}$ 上的最大化目标：\n$$\n\\text{maximize} \\quad \\sum_{i=1}^{n} x_i p_i \\;-\\; \\lambda \\sum_{1 \\le i  j \\le n} x_i x_j s_{ij},\n$$\n受预算约束\n$$\n\\sum_{i=1}^{n} x_i \\cdot l_i \\le B,\n$$\n其中 $l_i$ 是肽 $i$ 的氨基酸长度，$B$ 是以氨基酸为单位的疫苗长度预算。\n\n平局打破规则：如果多个子集达到相同的目标值（在数值公差范围内），选择索引按升序排列时字典序最小的索引列表（例如，优先选择 $[0,1]$ 而不是 $[0,2]$）。\n\n模型系数（在所有测试用例中均相同使用）：\n- $\\beta_0 = -3.0$,\n- $\\beta_{\\mathrm{aff}} = 1.4$,\n- $\\beta_{\\mathrm{expr}} = 0.7$,\n- $\\beta_{\\mathrm{vaf}} = 0.6$,\n- $\\beta_{\\mathrm{proc}} = 1.1$.\n\n所有对数均为自然对数（以 $e$ 为底）。$IC50$ 必须以纳摩尔（nM）为单位。$TPM$ 和 $VAF$ 必须以不带百分号的小数形式提供。惩罚系数 $\\lambda$ 是无单位的。\n\n您的程序必须为以下每个测试用例精确求解上述优化问题。为符合科学真实性，肽的长度是MHC I类结合的典型长度，相似度值在$[0,1]$范围内预先计算，以反映序列重叠或同一性。\n\n测试套件：\n- 测试用例1（正常路径）：\n  - 长度 $l = [9,9,10,9,10,11]$,\n  - 预算 $B = 28$,\n  - $\\lambda = 0.15$,\n  - $IC50 = [25,400,150,800,60,1200]$ (nM),\n  - $E = [45,10,30,5,60,2]$ ($TPM$),\n  - $VAF = [0.35,0.5,0.2,0.9,0.4,0.15]$,\n  - $P = [0.8,0.6,0.7,0.5,0.85,0.4]$,\n  - 相似性矩阵\n    $$\n    S = \\begin{bmatrix}\n    0  0.6  0.1  0.2  0.05  0.4 \\\\\n    0.6  0  0.2  0.3  0.1  0.5 \\\\\n    0.1  0.2  0  0.15  0.05  0.2 \\\\\n    0.2  0.3  0.15  0  0.3  0.1 \\\\\n    0.05  0.1  0.05  0.3  0  0.25 \\\\\n    0.4  0.5  0.2  0.1  0.25  0\n    \\end{bmatrix}.\n    $$\n- 测试用例2（边界情况，预算为零）：\n  - 特征与测试用例1相同，\n  - 预算 $B = 0$,\n  - $\\lambda = 0.15$.\n- 测试用例3（冗余主导情况）：\n  - 长度 $l = [9,9,9,10,10]$,\n  - 预算 $B = 40$,\n  - $\\lambda = 0.9$,\n  - $IC50 = [30,35,1000,45,55]$ (nM),\n  - $E = [40,42,8,38,39]$ ($TPM$),\n  - $VAF = [0.5,0.48,0.2,0.52,0.51]$,\n  - $P = [0.85,0.83,0.4,0.8,0.82]$,\n  - 相似性矩阵\n    $$\n    S = \\begin{bmatrix}\n    0  0.9  0.15  0.2  0.2 \\\\\n    0.9  0  0.15  0.2  0.2 \\\\\n    0.15  0.15  0  0.1  0.1 \\\\\n    0.2  0.2  0.1  0  0.85 \\\\\n    0.2  0.2  0.1  0.85  0\n    \\end{bmatrix}.\n    $$\n- 测试用例4（预算等于总长度，低相似度）：\n  - 长度 $l = [9,9,10,11]$,\n  - 预算 $B = 39$,\n  - $\\lambda = 0.05$,\n  - $IC50 = [80,90,70,85]$ (nM),\n  - $E = [20,25,22,24]$ ($TPM$),\n  - $VAF = [0.3,0.35,0.32,0.31]$,\n  - $P = [0.7,0.72,0.71,0.69]$,\n  - 相似性矩阵\n    $$\n    S = \\begin{bmatrix}\n    0  0.05  0.05  0.05 \\\\\n    0.05  0  0.05  0.05 \\\\\n    0.05  0.05  0  0.05 \\\\\n    0.05  0.05  0.05  0\n    \\end{bmatrix}.\n    $$\n- 测试用例5（平局打破规则检查）：\n  - 长度 $l = [9,9,9]$,\n  - 预算 $B = 18$,\n  - $\\lambda = 0.0$,\n  - $IC50 = [100,100,100]$ (nM),\n  - $E = [15,15,15]$ ($TPM$),\n  - $VAF = [0.3,0.3,0.3]$,\n  - $P = [0.6,0.6,0.6]$,\n  - 相似性矩阵\n    $$\n    S = \\begin{bmatrix}\n    0  0  0 \\\\\n    0  0  0 \\\\\n    0  0  0\n    \\end{bmatrix}.\n    $$\n\n最终输出格式要求：\n- 对于每个测试用例，输出最优选择的索引，形式为一个非递减顺序的从零开始的索引列表（例如，$[0,2,5]$）。\n- 将所有测试用例的结果汇总到一行，形式为一个用方括号括起来的逗号分隔列表，每个用例的结果本身也用方括号括起来，且不含任何空格。例如，如果有三个测试用例，输出必须是 $[[i_1,\\dots],[j_1,\\dots],[k_1,\\dots]]$ 的形式。\n\n您的程序必须严格按照上述格式生成单行输出。输出中不允许包含任何其他文本。", "solution": "所给问题是一个定义明确且具有科学依据的优化任务，属于计算免疫学和生物信息学领域。它要求为癌症疫苗选择一个最优的新抗原肽子集，在遵守预算约束的同时，最大化预期免疫原性得分并对冗余进行惩罚。\n\n### 问题验证\n\n**结论：有效**\n\n问题的有效性验证如下：\n1.  **科学依据**：问题表述基于免疫学和生物统计学中已确立的原则。所使用的特征（$IC50$、$TPM$、$VAF$、$P_i$）是新抗原优先排序的标准度量。使用逻辑斯蒂函数从特征的线性组合中建模免疫原性概率是标准做法（逻辑斯蒂回归）。对序列相似性进行惩罚是增加诱导免疫应答广度的一种合理方法。\n2.  **良态问题（Well-Posed）**：该问题是一个0-1二次整数规划问题，是一类已知的优化问题。每个测试用例中的肽数量 $n$ 很小（最大为 $n=6$），这使得通过穷举搜索在计算上是可行的。包含平局打破规则确保了唯一解的存在。\n3.  **客观与完整**：问题陈述是客观的，采用了精确的数学语言。为每个测试用例提供了所有必要的数据，包括模型系数、肽特征、长度/预算约束和相似性矩阵，使问题自成体系且可解。\n\n### 解决方法\n\n该问题可以建模为0-1二次背包问题（QKP）。设 $x_i \\in \\{0,1\\}$ 为决策变量，如果选择肽 $i$，则 $x_i=1$，否则 $x_i=0$。任务是找到向量 $x = (x_1, \\dots, x_n)$ 来解决以下优化问题。\n\n首先，从每个肽 $i$ 基于特征的线性分数 $z_i$ 推导出其免疫原性概率 $p_i$。\n线性分数 $z_i$ 由下式给出：\n$$\nz_i = \\beta_0 + \\beta_{\\mathrm{aff}} \\log\\left(\\frac{500}{IC50_i}\\right) + \\beta_{\\mathrm{expr}} \\log\\left(1 + E_i\\right) + \\beta_{\\mathrm{vaf}} \\cdot VAF_i + \\beta_{\\mathrm{proc}} \\cdot P_i\n$$\n然后使用标准的逻辑斯蒂（sigmoid）函数计算免疫原性概率 $p_i$：\n$$\np_i = \\frac{1}{1 + \\exp(-z_i)}\n$$\n目标是最大化函数 $F(x)$，它表示总预期免疫原性减去冗余惩罚：\n$$\n\\text{maximize}_{x \\in \\{0,1\\}^n} \\quad F(x) = \\sum_{i=1}^{n} x_i p_i \\;-\\; \\lambda \\sum_{1 \\le i  j \\le n} x_i x_j s_{ij}\n$$\n此最大化受限于所选肽总长度的预算约束：\n$$\n\\sum_{i=1}^{n} x_i \\cdot l_i \\le B\n$$\n鉴于每个测试用例中的肽数量 $n$ 很小（范围从3到6），可以通过对所有 $2^n$ 个可能的子集进行完全枚举来找到精确解。\n\n算法流程如下：\n1.  **概率预计算**：对于给定测试用例中的每个肽 $i$，计算并存储其免疫原性概率 $p_i$。这些值仅取决于肽自身的特征，并且在该用例的整个优化过程中保持不变。\n\n2.  **穷举子集搜索**：算法遍历 $n$ 个肽的所有可能子集。从 $0$ 到 $2^n-1$ 的每个整数都可用于表示一个唯一的子集，其中整数二进制表示的第 $i$ 位对应于肽 $i$ 的选择状态。\n\n3.  **约束验证**：对于每个生成的子集，计算其肽的总长度 $\\sum x_i l_i$。如果此总和超过预算 $B$，则该子集被视为不可行并被丢弃。\n\n4.  **目标函数评估**：对于每个可行子集，计算目标函数 $F(x)$。这包括对所有选定肽（$x_i=1$）的预计算概率 $p_i$ 求和，并减去惩罚项，该惩罚项是所有选定肽对的相似度 $s_{ij}$ 之和，再乘以系数 $\\lambda$。\n\n5.  **最优子集识别**：算法维护迄今为止找到的具有最高目标值的子集。\n    - 变量 `best_objective` 初始化为 $-\\infty$，列表 `best_subset_indices` 初始化为空。\n    - 在评估每个可行子集时，如果其目标值大于 `best_objective`（在 $10^{-9}$ 的数值公差范围内），则更新 `best_objective` 并将 `best_subset_indices` 替换为当前子集的索引。\n    - 如果一个子集的目标值等于 `best_objective`（在公差范围内），则调用平局打破规则：将当前子集的索引列表与 `best_subset_indices` 进行字典序比较，并保留较小的一个。\n\n此过程保证能根据问题规范找到精确的最优子集。对五个测试用例中的每一个重复此过程，并将得到的索引列表汇总成最终要求的格式。", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the neoantigen selection optimization problem for multiple test cases.\n    \"\"\"\n    # Model coefficients (constant across all test cases)\n    BETA_0 = -3.0\n    BETA_AFF = 1.4\n    BETA_EXPR = 0.7\n    BETA_VAF = 0.6\n    BETA_PROC = 1.1\n    \n    # Numerical tolerance for floating point comparisons\n    TOLERANCE = 1e-9\n\n    test_cases = [\n        # Test Case 1 (happy path)\n        {\n            \"l\": [9, 9, 10, 9, 10, 11],\n            \"B\": 28,\n            \"lambda\": 0.15,\n            \"ic50\": [25, 400, 150, 800, 60, 1200],\n            \"e\": [45, 10, 30, 5, 60, 2],\n            \"vaf\": [0.35, 0.5, 0.2, 0.9, 0.4, 0.15],\n            \"p_proc\": [0.8, 0.6, 0.7, 0.5, 0.85, 0.4],\n            \"S\": np.array([\n                [0, 0.6, 0.1, 0.2, 0.05, 0.4],\n                [0.6, 0, 0.2, 0.3, 0.1, 0.5],\n                [0.1, 0.2, 0, 0.15, 0.05, 0.2],\n                [0.2, 0.3, 0.15, 0, 0.3, 0.1],\n                [0.05, 0.1, 0.05, 0.3, 0, 0.25],\n                [0.4, 0.5, 0.2, 0.1, 0.25, 0]\n            ])\n        },\n        # Test Case 2 (boundary, zero budget)\n        {\n            \"l\": [9, 9, 10, 9, 10, 11],\n            \"B\": 0,\n            \"lambda\": 0.15,\n            \"ic50\": [25, 400, 150, 800, 60, 1200],\n            \"e\": [45, 10, 30, 5, 60, 2],\n            \"vaf\": [0.35, 0.5, 0.2, 0.9, 0.4, 0.15],\n            \"p_proc\": [0.8, 0.6, 0.7, 0.5, 0.85, 0.4],\n            \"S\": np.array([\n                [0, 0.6, 0.1, 0.2, 0.05, 0.4],\n                [0.6, 0, 0.2, 0.3, 0.1, 0.5],\n                [0.1, 0.2, 0, 0.15, 0.05, 0.2],\n                [0.2, 0.3, 0.15, 0, 0.3, 0.1],\n                [0.05, 0.1, 0.05, 0.3, 0, 0.25],\n                [0.4, 0.5, 0.2, 0.1, 0.25, 0]\n            ])\n        },\n        # Test Case 3 (redundancy-dominated regime)\n        {\n            \"l\": [9, 9, 9, 10, 10],\n            \"B\": 40,\n            \"lambda\": 0.9,\n            \"ic50\": [30, 35, 1000, 45, 55],\n            \"e\": [40, 42, 8, 38, 39],\n            \"vaf\": [0.5, 0.48, 0.2, 0.52, 0.51],\n            \"p_proc\": [0.85, 0.83, 0.4, 0.8, 0.82],\n            \"S\": np.array([\n                [0, 0.9, 0.15, 0.2, 0.2],\n                [0.9, 0, 0.15, 0.2, 0.2],\n                [0.15, 0.15, 0, 0.1, 0.1],\n                [0.2, 0.2, 0.1, 0, 0.85],\n                [0.2, 0.2, 0.1, 0.85, 0]\n            ])\n        },\n        # Test Case 4 (budget equals total length, low similarity)\n        {\n            \"l\": [9, 9, 10, 11],\n            \"B\": 39,\n            \"lambda\": 0.05,\n            \"ic50\": [80, 90, 70, 85],\n            \"e\": [20, 25, 22, 24],\n            \"vaf\": [0.3, 0.35, 0.32, 0.31],\n            \"p_proc\": [0.7, 0.72, 0.71, 0.69],\n            \"S\": np.array([\n                [0, 0.05, 0.05, 0.05],\n                [0.05, 0, 0.05, 0.05],\n                [0.05, 0.05, 0, 0.05],\n                [0.05, 0.05, 0.05, 0]\n            ])\n        },\n        # Test Case 5 (tie-breaking check)\n        {\n            \"l\": [9, 9, 9],\n            \"B\": 18,\n            \"lambda\": 0.0,\n            \"ic50\": [100, 100, 100],\n            \"e\": [15, 15, 15],\n            \"vaf\": [0.3, 0.3, 0.3],\n            \"p_proc\": [0.6, 0.6, 0.6],\n            \"S\": np.array([[0,0,0],[0,0,0],[0,0,0]])\n        }\n    ]\n\n    all_results = []\n\n    for case_data in test_cases:\n        l = case_data[\"l\"]\n        B = case_data[\"B\"]\n        lam = case_data[\"lambda\"]\n        ic50 = case_data[\"ic50\"]\n        e = case_data[\"e\"]\n        vaf = case_data[\"vaf\"]\n        p_proc = case_data[\"p_proc\"]\n        S = case_data[\"S\"]\n        \n        n = len(l)\n\n        # 1. Pre-compute immunogenicity probabilities p_i\n        p_imm = np.zeros(n)\n        for i in range(n):\n            z_i = (BETA_0 +\n                   BETA_AFF * np.log(500.0 / ic50[i]) +\n                   BETA_EXPR * np.log(1.0 + e[i]) +\n                   BETA_VAF * vaf[i] +\n                   BETA_PROC * p_proc[i])\n            p_imm[i] = 1.0 / (1.0 + np.exp(-z_i))\n\n        best_objective = -np.inf\n        best_subset_indices = []\n\n        # 2. Iterate through all 2^n subsets\n        for k in range(1  n):\n            current_subset_indices = []\n            current_length = 0\n            \n            # Form subset from integer k's binary representation\n            for i in range(n):\n                if (k >> i)  1:\n                    current_subset_indices.append(i)\n                    current_length += l[i]\n\n            # 3. Check budget constraint\n            if current_length > B:\n                continue\n\n            # 4. Calculate objective value\n            objective_p_sum = sum(p_imm[i] for i in current_subset_indices)\n            \n            objective_penalty = 0.0\n            if len(current_subset_indices) > 1:\n                # Use combinations to get all unique pairs (i, j) with i  j\n                for i1, i2 in combinations(current_subset_indices, 2):\n                    objective_penalty += S[i1, i2]\n            \n            current_objective = objective_p_sum - lam * objective_penalty\n            \n            # 5. Track the best solution found\n            if current_objective > best_objective + TOLERANCE:\n                best_objective = current_objective\n                best_subset_indices = current_subset_indices\n            elif abs(current_objective - best_objective) = TOLERANCE:\n                # Tie-breaking rule: choose lexicographically smallest index list\n                if not best_subset_indices or current_subset_indices  best_subset_indices:\n                    best_subset_indices = current_subset_indices\n        \n        all_results.append(best_subset_indices)\n    \n    # Format and print the final result string\n    result_str_list = []\n    for res in all_results:\n        result_str_list.append(f'[{\",\".join(map(str, res))}]')\n    \n    # The output MUST be a single line with no leading/trailing whitespace.\n    print(f\"[{','.join(result_str_list)}]\")\n\nsolve()\n```", "id": "4589173"}]}