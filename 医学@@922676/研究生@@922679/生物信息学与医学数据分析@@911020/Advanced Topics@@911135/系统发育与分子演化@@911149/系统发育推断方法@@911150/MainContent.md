## 引言
[系统发育推断](@entry_id:182186)是生物信息学和演化生物学的基石，它致力于通过分析分子序列或形态性状数据，重建生命演化的历史图谱——[系统发育树](@entry_id:140506)。这项技术不仅揭示了物种间的亲缘关系，更为了解基因功能演化、追踪疾病传播、探索生命多样性的起源提供了强大的计算框架。然而，从原始数据到一棵可靠的演化树，过程充满了挑战。不同的推断方法基于迥异的假设，可能得出截然不同的结论；而数据本身的复杂性与演化过程的随机性，也为结果的解读带来了不确定性。本文旨在系统性地梳理[系统发育推断](@entry_id:182186)的核心知识体系，解决“如何选择和应用恰当的方法”以及“如何批判性地评估推断结果”这一核心知识缺口。

在接下来的内容中，我们将分三个章节进行深入探索。首先，在“原理与机制”中，我们将剖析系统发育树的数学基础，并详细比较基于距离、[最大简约法](@entry_id:168212)、[最大似然](@entry_id:146147)法及[贝叶斯推断](@entry_id:146958)等主流方法的计算原理和适用场景。随后，在“应用与交叉学科联系”中，我们将通过[分子流行病学](@entry_id:167834)、[癌症演化](@entry_id:155845)和比较基因组学等前沿案例，展示这些方法如何解决真实的科学问题。最后，在“动手实践”部分，你将有机会通过具体的计算练习，亲手应用这些理论知识。通过这一结构化的学习路径，你将能够建立起对[系统发育推断](@entry_id:182186)方法的全面理解。

## 原理与机制

在[系统发育推断](@entry_id:182186)中，我们的核心目标是从观测到的分[子序列](@entry_id:147702)或性状数据中重建演化历史。这一历史通常用一个[系统发育树](@entry_id:140506)来表示。本章将深入探讨推断这些树所依据的核心原理和计算机制。我们将首先剖析树的数学结构及其与[演化距离](@entry_id:177968)的关系，然后系统地考察两类主要的推断方法——基于距离的方法和基于字符的方法——并最终讨论如何评估推断结果的可靠性以及如何识别和理解潜在的系统性误差。

### [系统发育树](@entry_id:140506)的结构与度量

[系统发育树](@entry_id:140506)是一个数学图，其[叶节点](@entry_id:266134)代表我们研究的物种或序列（称为**分类单元**），内部节点代表它们的假想祖先。树的边（或称分支）连接着这些节点，边的长度通常被赋予了生物学意义。

最基本的区别在于**[有根树](@entry_id:266860)（rooted tree）**和**[无根树](@entry_id:199885)（unrooted tree）**。[有根树](@entry_id:266860)指定了一个特殊的节点作为**根**，它代表了树中所有分类单元的[最近共同祖先](@entry_id:136722)。这赋予了树一个时间的维度，演化从根节点流向[叶节点](@entry_id:266134)。边的方向也因此确定。当边长被解释为每个位点上预期的替换数时，从根到任一[叶节点](@entry_id:266134)的路径长度就代表了该谱系从共同祖先至今所累积的演化变化总量。而[无根树](@entry_id:199885)则只描述了分类单元之间的拓扑关系，并未指定根的位置，因此不包含明确的时间方向 [@problem_id:4593208]。

无论是[有根树](@entry_id:266860)还是[无根树](@entry_id:199885)，如果赋予其非负的边长，我们就可以定义任意两个[叶节点](@entry_id:266134) $x$ 和 $y$ 之间的**树度量（tree metric）** $d(x,y)$，即连接它们俩的唯一路径上所有边长之和。这种度量性质被称为**可加性（additivity）** [@problem_id:4593208]。一个[距离矩阵](@entry_id:165295)若能被一个带正边长的树的路径长度完美表示，则称该[距离矩阵](@entry_id:165295)是**可加的（additive）**。

一个重要的特例是**[超度量树](@entry_id:168934)（ultrametric tree）**。这是一种特殊的[有根树](@entry_id:266860)，其所有[叶节点](@entry_id:266134)到根的路径长度都完全相等。这个特性在生物学上对应于**[分子钟假说](@entry_id:164815)（molecular clock hypothesis）**，即所有谱系的[演化速率](@entry_id:202008)恒定。因此，一个[超度量树](@entry_id:168934)不仅是可加的，还满足一个更强的条件 [@problem_id:4593208]。

为了检验一个给定的[距离矩阵](@entry_id:165295)是否是可加的，我们可以使用**四点检验（four-point test）**。该检验是可加性的一个必要且充分条件。对于任意四个不同的分类单元 $\{i,j,k,l\}$，我们计算三对距离之和：$S_1 = d(i,j)+d(k,l)$，$S_2 = d(i,k)+d(j,l)$，以及 $S_3 = d(i,l)+d(j,k)$。如果这些距离是可加的，那么这三个和中数值最大的两个必定相等 [@problem_id:4593208]。如果存在一个严格为正的内部边，那么其中一个和会严格小于另外两个相等的和。例如，如果 $S_1  S_2 = S_3$，这表明这四个分类单元在树上的拓扑结构将 $i$ 和 $j$ 分在一组，将 $k$ 和 $l$ 分在另一组，其对应的[四分体](@entry_id:159406)分裂为 $(i,j)|(k,l)$。

例如，考虑一个包含六个分类单元 $\{A,B,C,D,E,F\}$ 的[距离矩阵](@entry_id:165295) $D$ [@problem_id:4593246]：
$$
D \;=\;\
\begin{pmatrix}
0  0.6  2.0  2.0  1.7  1.7 \\
0.6  0  2.0  2.0  1.7  1.7 \\
2.0  2.0  0  0.8  1.7  1.7 \\
2.0  2.0  0.8  0  1.7  1.7 \\
1.7  1.7  1.7  1.7  0  0.4 \\
1.7  1.7  1.7  1.7  0.4  0
\end{pmatrix}.
$$
我们可以对任意[四分体](@entry_id:159406)进行检验。以[四分体](@entry_id:159406) $\{A,B,C,D\}$ 为例，其距离分别为 $d(A,B)=0.6$, $d(C,D)=0.8$, $d(A,C)=2.0$, $d(A,D)=2.0$, $d(B,C)=2.0$, $d(B,D)=2.0$。三个和为：
$S_1 = d(A,B) + d(C,D) = 0.6 + 0.8 = 1.4$
$S_2 = d(A,C) + d(B,D) = 2.0 + 2.0 = 4.0$
$S_3 = d(A,D) + d(B,C) = 2.0 + 2.0 = 4.0$
由于 $1.4  4.0 = 4.0$，该[四分体](@entry_id:159406)满足四点检验，并唯一地支持分裂 $(A,B)|(C,D)$。通过对所有 $\binom{6}{4}=15$ 个[四分体](@entry_id:159406)进行检验，可以发现它们都满足此条件，这表明该[距离矩阵](@entry_id:165295)是完全可加的，并且可以完美地表示在一棵[无根树](@entry_id:199885)上。

### 推断方法的主要类别

[系统发育](@entry_id:137790)的推断方法在如何使用原始数据上存在根本性的概念差异，主要可分为两大类：**基于距离的方法（distance-based methods）**和**基于字符的方法（character-based methods）** [@problem_id:1953593]。

**基于距离的方法**，如[邻接法](@entry_id:163788)（Neighbor-Joining, NJ），采用两步流程。首先，它们将[多序列比对](@entry_id:176306)[数据压缩](@entry_id:137700)成一个单一的成对**[距离矩阵](@entry_id:165295)**，其中每个元素 $d_{ij}$ 是对分类单元 $i$ 和 $j$ 之间演化差异的量化估计。这个过程可能会使用演化模型来校正观察到的差异。然后，算法仅使用这个[距离矩阵](@entry_id:165295)来构建一棵树，该树的路径长度能最好地拟合输入的[距离矩阵](@entry_id:165295)。一旦[距离矩阵](@entry_id:165295)被计算出来，原始序列中每个位点的具体字符信息就不再被直接使用 [@problem_id:2731381]。

相比之下，**基于字符的方法**直接作用于比对好的字符矩阵（例如，DNA序列比对的每一个碱基位点）。这类方法通过逐个评估不同候选树与原始数据中每个字符的契合度来对树进行排序。这种方法不会将序列间的差异预先概括为单一的距离值，从而保留了更多的信息。最主要的两种基于字符的方法是[最大简约法](@entry_id:168212)和[统计系统发育学](@entry_id:163123)方法（[最大似然](@entry_id:146147)法和[贝叶斯推断](@entry_id:146958)）。

### 基于字符的方法 I：[最大简约法](@entry_id:168212)

**[最大简约法](@entry_id:168212)（Maximum Parsimony, MP）**遵循[奥卡姆剃刀](@entry_id:147174)原则，即在所有可能的解释中，应选择最简单的一个。在[系统发育学](@entry_id:147399)中，这意味着选择能够用最少演化事件（即字符状态变化）来解释观测数据的树 [@problem_id:2731381]。

MP的目标是最小化一棵树的总**简约分数（parsimony score）**。对于给定的[树拓扑](@entry_id:165290)，每个字符的简约分数是解释该字符在所有[叶节点](@entry_id:266134)上的状态所需的最少变化次数。这个最小值是通过为所有未观测的内部节点赋予最优的祖先状态来找到的。总的简约分数是所有字符的简约分数之和。

一个“变化”的成本由一个**[代价矩阵](@entry_id:634848)（cost matrix）** $c(i,j)$ 定义，它规定了从状态 $i$ 变为状态 $j$ 的代价。最简单的模型是**无序（unordered）**编码，其中任何不同状态之间的变化成本都为1（即 $c(i,j)=1$ 如果 $i \neq j$），而没有变化的成本为0。对于可以自然排序的字符状态（例如，0, 1, 2），可以采用**有序（ordered）**编码，其中成本与变化的幅度成正比，例如 $c(i,j)=|i-j|$。在这种模型下，一个大的跳跃（如从0到2）比一个小的跳跃（如从0到1）成本更高 [@problem_id:4593223]。

让我们考虑一个例子来说明这一点。假设有四个分类单元，其[树拓扑](@entry_id:165290)为 $((A,B),(C,D))$，我们观察到一个三状态字符的值为 $A=0, B=2, C=0, D=2$。
- 在**无序编码**下（任何变化成本为1），我们可以通过将 $A,B$ 的[共同祖先](@entry_id:175919)设为0或2，将 $C,D$ 的共同祖先设为0或2来推断。一个最优的方案是将 $A,B$ 的祖先设为0（$A$ 无变化，$B$ 变化 $0 \to 2$，成本1），将 $C,D$ 的祖先设为0（$C$ 无变化，$D$ 变化 $0 \to 2$，成本1），然后在连接这两个祖先的中心边上没有变化。总成本是 $1+1=2$。
- 在**有序编码**下（成本为 $|i-j|$），$0 \leftrightarrow 2$ 的变化成本为2。在上述方案中，从祖先0到[叶节点](@entry_id:266134) $B$ 的变化成本为 $|2-0|=2$，到[叶节点](@entry_id:266134) $D$ 的变化成本也为2。总成本将是 $2+2=4$。这突显了不同的演化假设（通过[代价矩阵](@entry_id:634848)体现）如何影响对树的评估 [@problem_id:4593223]。

### 基于字符的方法 II：[统计系统发育学](@entry_id:163123)

与简约法不同，[统计系统发育学](@entry_id:163123)方法——包括**最大似然法（Maximum Likelihood, ML）**和**贝叶斯推断（Bayesian inference）**——基于一个明确的、概率性的**演化替代模型**。

#### [最大似然](@entry_id:146147)法 (ML)

ML的目标是寻找一棵树的拓扑结构 $T$ 及其相关参数 $\theta$（如边长和替代模型参数），使得观测到的数据 $D$ 出现的概率（即似然值）$L(T, \theta) = P(D | T, \theta)$ 最大化 [@problem_id:2731381]。似然值的计算通常使用 **Felsenstein的剪枝算法（pruning algorithm）**，该算法能够高效地在给定树和参数的情况下，通过从[叶节点](@entry_id:266134)向根节点递归计算，得出整个[序列比对](@entry_id:172191)的似然值。

ML推断面临两大挑战：一是搜索广阔的树空间，二是选择合适的演化模型。

1.  **树空间搜索**：由于可能的[树拓扑](@entry_id:165290)数量随分类单元数量的增加而爆炸式增长，穷举搜索通常是不可行的。因此，ML程序采用**[启发式搜索](@entry_id:637758)算法**，如**爬山法（hill-climbing）**。这种算法从一个初始树开始，迭代地探索其“邻域”中的树，并移动到似然值更高的树上，直到无法找到更好的邻居为止。一个常见的邻域定义是**最近邻交换（Nearest Neighbor Interchange, NNI）**。对于一棵无根[二叉树](@entry_id:270401)的任意一条内部边，NNI操作可以产生两种新的拓扑结构。在每次迭代中，算法会评估当前树的所有NNI邻居，为每个候选树重新优化所有边长，然[后选择](@entry_id:154665)似然值最高的树作为下一次迭代的起点 [@problem_id:4593266]。

    这个过程的计算成本非常高。考虑一棵有 $n$ 个分类单元的树，比对长度为 $L$，字符状态数为 $r$（如DNA为4），使用包含 $k$ 个离散速率类别的模型。一次似然值计算的[时间复杂度](@entry_id:145062)为 $O(n k r^2 L)$。由于一棵树有 $2n-3$ 条边和 $2(n-2)$ 个NNI邻居，并且每条边的优化需要 $t$ 次似然评估，那么一次完整的爬山迭代的复杂度将是 $O(2(n-2) \times (2n-3) \times t \times n k r^2 L)$，约等于 $O(n^3 t k r^2 L)$。这清晰地揭示了ML分析的计算密集性 [@problem_id:4593266]。

2.  **[模型选择](@entry_id:155601)**：ML的性能高度依赖于所选演化模型的准确性。过于简单的模型可能无法捕捉真实的演化过程，而过于复杂的模型则可能[过拟合](@entry_id:139093)数据。为了在模型的[拟合优度](@entry_id:637026)（由最大化[对数似然](@entry_id:273783)值 $\ell(\hat{\theta})$ 体现）和复杂性（由自由参数数量 $k$ 体现）之间取得平衡，研究者们使用**[信息准则](@entry_id:636495)（information criteria）**。

    **[赤池信息准则](@entry_id:139671)（Akaike Information Criterion, AIC）** 的定义为 $\mathrm{AIC} = 2k - 2\ell(\hat{\theta})$。**[贝叶斯信息准则](@entry_id:142416)（Bayesian Information Criterion, BIC）** 的定义为 $\mathrm{BIC} = k \ln(n) - 2\ell(\hat{\theta})$，其中 $n$ 是样本量，在[系统发育学](@entry_id:147399)中通常指[序列比对](@entry_id:172191)的长度（位点数）[@problem_id:4593199]。

    在比较多个候选模型时，我们会选择AIC或BIC值最低的模型。这两种准则的关键优势在于它们能够比较**非[嵌套模型](@entry_id:635829)（non-nested models）**，这是传统的[似然比检验](@entry_id:268070)（LRT）所无法做到的。例如，我们可以使用AIC或BIC来比较一个Jukes-Cantor模型和一个[GTR模型](@entry_id:173230)，或者比较两个完全不同的[树拓扑](@entry_id:165290)。它们提供了一个统一的框架来评估不同复杂度的假设 [@problem_id:4593199]。

#### 贝叶斯推断

[贝叶斯推断](@entry_id:146958)与ML共享相同的演化模型和[似然函数](@entry_id:141927)计算方法，但其哲学基础不同。它不寻求单一的最优树，而是通过[马尔可夫链蒙特卡洛](@entry_id:138779)（MCMC）方法从**后验概率分布** $P(T, \theta | D)$ 中进行抽样。这个后验分布结合了来自数据的证据（似然值）和我们的先验信念（**[先验概率](@entry_id:275634)**）。最终结果是树的集合，其中每棵树的出现频率与其后验概率成正比。

### 评估支持度与识别系统误差

推断出一棵最优树后，至关重要的一步是评估其结果的可靠性，特别是对树中特定**分支（clade）**（即由一个内部节点衍生出的所有后代构成的分组）的支持度。

#### 量化[分支支持度](@entry_id:201765)

在频率学派框架中，最常用的方法是**非[参数自举](@entry_id:178143)法（nonparametric bootstrap）**。该方法通过模拟从原始数据中[重复抽样](@entry_id:274194)的过程来评估推断的稳定性。具体操作如下：从原始[序列比对](@entry_id:172191)的 $L$个位点中，有放回地随机抽取 $L$ 次，形成一个新的、与原始比对大小相同的“自举比对”。在这个新的比对上，用与原始分析完全相同的方法重新推断一棵树。这个过程重复数百或数千次（例如，$B=1000$次）。对于我们关心的任何一个特定分支 $C$，其**[自举支持率](@entry_id:164000)（bootstrap support）**就是它在所有 $B$ 棵自举树中出现的比例 [@problem_id:4593183]。例如，如果在1000次重复中，分支 $C$ 出现了734次，那么其[自举支持率](@entry_id:164000)就是 $0.734$。按照标准定义，那些在相应位置上不包含任何确定分支（即出现多歧分支）的自举树被计入分母，但不计入分子，这是一种保守的计算方式 [@problem_id:4593183]。[自举支持率](@entry_id:164000)可以被解释为：如果我们能从产生我们数据的真实演化过程中获得新的数据集，我们用当前推断方法能够重新得到该分支的概率的一个估计 [@problem_id:4593183][@problem_id:4594015]。

在贝叶斯框架中，[分支支持度](@entry_id:201765)由**后验概率（posterior probability）**给出。一个分支的后验概率是[MCMC采样](@entry_id:751801)得到的所有树中，包含该分支的树所占的比例。它直接表示在给定数据、模型和先验的条件下，该分支为真的概率。

尽管[自举支持率](@entry_id:164000)和后验概率都用于评估分支的可信度，但它们在概念上是不同的，其数值也常常不一致。在模型被正确指定的情况下，随着数据量的无限增加，两者对于真实分支的支持度都会收敛到1。然而，在有限数据下，[贝叶斯后验概率](@entry_id:197730)通常比[自举支持率](@entry_id:164000)显得更为“自信”，即对于同一个分支，后验概率值往往更高 [@problem_id:4594015]。

#### 系统性误差与模型误设

高支持度值并不总能保证结果的正确性，尤其是在我们的推断模型未能准确反映真实演化过程时，即**模型误设（model misspecification）**。

一个经典的系统性误差是**[长枝吸引](@entry_id:141763)（long-branch attraction, LBA）**。当一棵树中存在两条不相关的长末端枝和一条短内部枝时，系统发育方法可能会错误地将这两条长枝聚合在一起。这是因为在长枝上独立发生的平行或趋同演化（**同oplasy**）所产生的随机相似性，在数量上可能超过了标记真实[系统发育](@entry_id:137790)关系的共享衍生性状（**synapomorphy**）[@problem_id:2840521]。

简约法由于不考虑在同一位点发生多次替换的可能性，因此极易受到LBA的影响，它会错误地将同oplasy计为支持错误分组的证据。

令人惊讶的是，即使是复杂的统计方法，如果模型被误设，也同样脆弱。一个常见的模型误设是忽略了**谱系间的成分异质性（compositional heterogeneity among lineages）**。标准的演化模型（如GTR）通常假定在整棵树上，核苷酸（或氨基酸）的[平衡频率](@entry_id:275072)是恒定的（即**[平稳性](@entry_id:143776)（stationarity）**假设）。然而，在真实数据中，不同谱系的碱基组成可能存在显著差异（例如，一些谱系富含A-T，而另一些则富含G-C）。当使用一个假定成分同质性的模型来分析异质性的数据时，该模型为了解释两个不相关但成分相似的谱系（例如，都富含A-T），可能会错误地将它们聚合在一起，因为这样做能更好地拟合模型所假定的那个单一的、平均的碱基组成。这实际上是将趋同的成分演化误解为共同的祖先历史 [@problem_id:2840521]。

在这种情况下，无论是[自举支持率](@entry_id:164000)还是[贝叶斯后验概率](@entry_id:197730)，都可能以高值支持错误的分支。研究表明，在LBA等模型误设的场景中，[贝叶斯后验概率](@entry_id:197730)甚至可能比[自举支持率](@entry_id:164000)更强烈地支持错误结果，部分原因在于先验假设（如对枝长的先验）也可能与真实的演化过程不符，从而加剧偏差 [@problem_id:4594015][@problem_id:2840521]。因此，批判性地评估模型假设，并考虑使用能够解释这些异质性的更复杂模型，对于进行可靠的[系统发育推断](@entry_id:182186)至关重要。