{"hands_on_practices": [{"introduction": "估算突变积累的速率是系统发育学中的一项基本任务，对于确定进化事件的年代至关重要。本练习将通过校准严格分子钟，提供贝叶斯参数估计的动手实践[@problem_id:4542077]。您将学习如何将序列数据与先验知识相结合，推导出替换率的后验分布，展示共轭先验在简化贝叶斯计算中的强大作用。", "problem": "一个实验室正在为一种快速演化的RNA病毒校准严格分子钟，以支持下游的医学分析。研究人员从一次特征明确、起源时间已知（设为 $t=0$）的单一疫情中，采集了 $n$ 个叶端定年序列，并构建了一个长度为 $L$ 个位点的序列比对。对于在时间 $t_i$（自 $t=0$ 以来的年数）采集的每个叶端 $i \\in \\{1,\\dots,n\\}$，研究人员推断出了一个具有已知根节点的最大似然系统发育树，并将沿着从根到叶端路径上的替换数记录为 $K_i$。假设严格分子钟、位点独立，并且沿着每条从根到叶端的路径，替换过程是一个速率为 $\\mu$ (替换数/位点/年) 的时齐泊松过程，因此在给定 $\\mu$ 的条件下，计数 $K_i$ 服从均值为 $\\mu L t_i$ 的泊松随机变量分布。假设在给定 $\\mu$ 的条件下，$K_i$ 是条件独立的。为了完成贝叶斯校准，为替换速率 $\\mu$ 设置一个伽马先验（形状-速率参数化）：$\\mu \\sim \\mathrm{Gamma}(a_0,b_0)$。\n\n仅使用贝叶斯定理和这些模型假设，推导 $\\mu$ 的后验分布，并确定在平方误差损失下的贝叶斯估计量（后验均值）。然后，对以下数据集计算其数值：\n- $n=5$ 个叶端，序列比对长度 $L=10000$ 个位点；\n- 采样时间（自 $t=0$ 以来的年数）：$(t_1,t_2,t_3,t_4,t_5) = (0.8, 1.6, 2.7, 3.9, 5.2)$；\n- 从根到叶端的替换计数：$(K_1,K_2,K_3,K_4,K_5) = (8, 20, 28, 39, 53)$；\n- 先验超参数：$(a_0,b_0) = (2,2000)$。\n\n将你对替换速率的最终数值答案四舍五入到四位有效数字，并以“替换数/位点/年”为单位表示。最终答案必须是一个实数。", "solution": "该问题要求推导替换速率 $\\mu$ 的后验分布，并计算其后验均值，该均值在平方误差损失下作为贝叶斯估计量。我们从贝叶斯定理开始，该定理指出后验分布与似然和先验分布的乘积成正比：\n$$ P(\\mu | \\mathcal{D}) \\propto P(\\mathcal{D} | \\mu) P(\\mu) $$\n其中 $\\mathcal{D} = \\{K_1, \\dots, K_n\\}$ 代表观测数据，具体来说是替换计数。\n\n似然函数 $P(\\mathcal{D} | \\mu)$ 是根据问题的假设构建的。鉴于每个替换计数 $K_i$ 是从均值为 $\\lambda_i = \\mu L t_i$ 的独立泊松分布中抽取的一个样本，总似然是各个泊松概率质量函数的乘积：\n$$ P(\\mathcal{D} | \\mu) = \\prod_{i=1}^{n} P(K_i | \\mu) = \\prod_{i=1}^{n} \\frac{(\\mu L t_i)^{K_i} \\exp(-\\mu L t_i)}{K_i!} $$\n\n$\\mu$ 的先验分布被给定为具有形状参数 $a_0$ 和速率参数 $b_0$ 的伽马分布。其概率密度函数为：\n$$ P(\\mu) = \\mathrm{Gamma}(\\mu | a_0, b_0) = \\frac{b_0^{a_0}}{\\Gamma(a_0)} \\mu^{a_0-1} \\exp(-b_0 \\mu) $$\n\n为了找到后验分布 $P(\\mu | \\mathcal{D})$，我们结合似然和先验。我们可以忽略任何不依赖于 $\\mu$ 的项，因为它们将被并入后验分布的归一化常数中。\n$$ P(\\mu | \\mathcal{D}) \\propto \\left( \\prod_{i=1}^{n} (\\mu L t_i)^{K_i} \\exp(-\\mu L t_i) \\right) \\left( \\mu^{a_0-1} \\exp(-b_0 \\mu) \\right) $$\n我们展开此表达式，并将包含 $\\mu$ 的项组合在一起：\n$$ P(\\mu | \\mathcal{D}) \\propto \\left( \\prod_{i=1}^{n} \\mu^{K_i} \\right) \\left( \\prod_{i=1}^{n} \\exp(-\\mu L t_i) \\right) \\mu^{a_0-1} \\exp(-b_0 \\mu) $$\n$$ P(\\mu | \\mathcal{D}) \\propto \\mu^{\\sum_{i=1}^{n} K_i} \\exp\\left(-\\mu L \\sum_{i=1}^{n} t_i\\right) \\mu^{a_0-1} \\exp(-b_0 \\mu) $$\n结合 $\\mu$ 的指数和指数函数的参数，得到后验分布的核：\n$$ P(\\mu | \\mathcal{D}) \\propto \\mu^{(a_0 + \\sum_{i=1}^{n} K_i) - 1} \\exp\\left( - \\mu \\left(b_0 + L \\sum_{i=1}^{n} t_i\\right) \\right) $$\n\n此表达式是伽马分布的核。这表明伽马分布是泊松似然的速率参数的共轭先验。因此，$\\mu$ 的后验分布也是一个伽马分布，$\\mu | \\mathcal{D} \\sim \\mathrm{Gamma}(a_n, b_n)$，其更新后的参数如下：\n$$ a_n = a_0 + \\sum_{i=1}^{n} K_i $$\n$$ b_n = b_0 + L \\sum_{i=1}^{n} t_i $$\n\n在平方误差损失下，$\\mu$ 的贝叶斯估计量是后验分布的均值。对于一个形状-速率参数化的伽马分布 $\\mathrm{Gamma}(a, b)$，其均值由参数之比 $\\frac{a}{b}$ 给出。因此，估计量 $\\hat{\\mu}_{\\text{Bayes}}$ 为：\n$$ \\hat{\\mu}_{\\text{Bayes}} = E[\\mu | \\mathcal{D}] = \\frac{a_n}{b_n} = \\frac{a_0 + \\sum_{i=1}^{n} K_i}{b_0 + L \\sum_{i=1}^{n} t_i} $$\n\n现在我们代入问题陈述中提供的数值。数据集包含序列比对长度 $L=10000$ 个位点，$n=5$ 个叶端，其采样时间为 $(t_1,t_2,t_3,t_4,t_5) = (0.8, 1.6, 2.7, 3.9, 5.2)$ 年，从根到叶端的替换计数为 $(K_1,K_2,K_3,K_4,K_5) = (8, 20, 28, 39, 53)$。先验超参数为 $(a_0,b_0) = (2,2000)$。\n\n首先，我们计算替换计数的总和以及采样时间的总和：\n$$ \\sum_{i=1}^{5} K_i = 8 + 20 + 28 + 39 + 53 = 148 $$\n$$ \\sum_{i=1}^{5} t_i = 0.8 + 1.6 + 2.7 + 3.9 + 5.2 = 14.2 $$\n\n接下来，我们计算后验参数 $a_n$ 和 $b_n$：\n$$ a_n = a_0 + \\sum_{i=1}^{5} K_i = 2 + 148 = 150 $$\n$$ b_n = b_0 + L \\sum_{i=1}^{5} t_i = 2000 + 10000 \\times 14.2 = 2000 + 142000 = 144000 $$\n\n最后，我们计算后验均值，即 $\\mu$ 的贝叶斯估计量：\n$$ \\hat{\\mu}_{\\text{Bayes}} = \\frac{a_n}{b_n} = \\frac{150}{144000} = \\frac{1}{960} \\approx 0.001041666... $$\n\n问题要求将结果四舍五入到四位有效数字。数值为 $1.041666... \\times 10^{-3}$。四舍五入到四位有效数字得到 $1.042 \\times 10^{-3}$ 替换数/位点/年。", "answer": "$$\\boxed{1.042 \\times 10^{-3}}$$", "id": "4542077"}, {"introduction": "系统发育推断通常涉及比较关于进化关系的竞争性假说。本练习侧重于使用贝叶斯因子进行模型选择，以从单核苷酸多态性（SNP）数据中确定最可能的树拓扑结构[@problem_id:4542022]。它还引入了一个关键的现实世界挑战：校正确定性偏倚（ascertainment bias），这是SNP数据集中常见的问题，从而提升您构建稳健且准确的统计模型的能力。", "problem": "一个研究团队正在对三个分类单元 $\\{A,B,C\\}$ 的双等位基因状态的单核苷酸多态性 (SNP) 数据进行贝叶斯系统发育推断。其抽样方案仅包括了在这三个分类单元中存在变异的位点（即，在样本中所有不变的位点在发现阶段均被排除）。为了明确地对这种抽样偏差进行校正，他们使用了一种在观察到变异位点的条件下进行校正的似然函数。假设采用以下模型选择，团队将其视为推断的基础：\n\n- 序列在各位点上的演化遵循有根三分类单元树上的 Cavender–Farris–Neyman (CFN) 模型（双状态对称连续时间马尔可夫链），各位点独立同分布，且平稳碱基频率为 $P(0)=P(1)=\\tfrac{1}{2}$。\n- 沿着一条边 $e$，状态改变的概率记为 $s_{e} \\in [0, \\tfrac{1}{2}]$，而不改变的概率为 $1 - s_{e}$。不同边的演化是相互独立的。\n- 拓扑结构 $\\mathcal{T}_{1}$ 的有根模型树为 $((A,B),C)$，其中导向 $A$ 的分支、导向 $B$ 的分支和导向 $C$ 的分支的状态改变概率均为 $s$，而 $\\{A,B\\}$ 祖先与 $C$ 之间的内部分支的状态改变概率为 $r$。备选拓扑结构 $\\mathcal{T}_{2}$ 为 $((A,C),B)$，其对应的悬挂分支和内部分支具有相同的边特定改变概率。\n- 每个位点的抽样校正（Lewis 型）似然是普通位点似然除以模型下该位点为可变位点的概率，从而使得推断在可变性的条件下进行。\n\n从 $N$ 个可变 SNP 中，团队统计了简约信息模式的计数，其中 $n_{AB|C}$ 表示 $A$ 和 $B$ 状态相同但与 $C$ 状态不同的可变位点数（合并了两种互补的分配情况），$n_{AC|B}$ 和 $n_{BC|A}$ 的定义与此类似。他们观察到\n$$\nn_{AB|C} = 120,\\quad n_{AC|B} = 80,\\quad n_{BC|A} = 100.\n$$\n假设对于两种拓扑结构，每个悬挂分支的 $s = 0.1$，内部分支的 $r = 0.05$。将各位点视为独立，并对两种拓扑结构采用相等的先验概率。\n\n仅使用上述基本定义和基础概率，推导在 CFN 模型下每种拓扑结构的抽样校正模式概率，并计算支持 $\\mathcal{T}_{1}$ 相对于 $\\mathcal{T}_{2}$ 的贝叶斯因子（边际似然比，在此由于先验相等和分支改变概率固定，它等于抽样校正似然比）。将最终的贝叶斯因子四舍五入到四位有效数字。最终答案必须是一个无单位的实数。", "solution": "支持拓扑结构 $\\mathcal{T}_1$ 相对于 $\\mathcal{T}_2$ 的贝叶斯因子是它们的边际似然之比，$BF_{12} = P(D|\\mathcal{T}_1)/P(D|\\mathcal{T}_2)$。由于模型参数（$s$，$r$）是固定的，并且拓扑结构的先验概率相等，因此这简化为在给定参数值下评估的似然之比。数据 $D$ 是三种可变位点模式的计数，$D=\\{n_{AB|C}, n_{AC|B}, n_{BC|A}\\}$。总位点数是 $N = 120 + 80 + 100 = 300$。\n\n给定拓扑结构 $\\mathcal{T}$ 的似然基于观察到的模式计数的多元分布，条件是位点是可变的。\n$$\nL(D|\\mathcal{T}) \\propto P(AB|C|\\mathcal{T}, \\text{var})^{n_{AB|C}} P(AC|B|\\mathcal{T}, \\text{var})^{n_{AC|B}} P(BC|A|\\mathcal{T}, \\text{var})^{n_{BC|A}}\n$$\n其中 $P(\\text{pattern}|\\mathcal{T}, \\text{var})$ 是观察到特定位点模式的抽样校正概率。它由下式给出：\n$$\nP(\\text{pattern}|\\mathcal{T}, \\text{var}) = \\frac{P(\\text{pattern}|\\mathcal{T})}{P(\\text{site is variable}|\\mathcal{T})}\n$$\n我们的首要任务是计算每种拓扑结构下三种可变位点模式的未校正概率。\n\n**1. 拓扑结构 $\\mathcal{T}_1 = ((A,B),C)$ 的模式概率**\n\n该树结构有一个根节点 $R$、一个内部节点 $U$ 和三个叶节点 $A, B, C$。分支 $(R,U)$ 的改变概率为 $r$，分支 $(U,A)$、$(U,B)$、$(R,C)$ 的改变概率均为 $s$。根节点的状态为 $0$ 或 $1$ 的概率为 $1/2$。由于模型的对称性，$P(\\text{pattern}) = 2 \\times P(\\text{one specific instance of pattern})$。\n\n我们推导出与拓扑结构不一致的模式的概率，例如 $AC|B$。此模式的两种状态分配是 (0,1,0) 和 (1,0,1)。对于 (A=0, B=1, C=0)，其概率 $P(0,1,0|\\mathcal{T}_1)$ 为：\n$P(0,1,0|\\mathcal{T}_1) = \\frac{1}{2}[P(0,1,0|X_R=0) + P(0,1,0|X_R=1)]$。\n$P(0,1,0|X_R=0) = P(C=0|X_R=0)[P(A=0,B=1|X_U=0)P(X_U=0|X_R=0) + P(A=0,B=1|X_U=1)P(X_U=1|X_R=0)] = (1-s)[(1-s)s(1-r) + s(1-s)r] = s(1-s)^2$。\n$P(0,1,0|X_R=1) = P(C=0|X_R=1)[\\dots] = s[ (1-s)s r + s(1-s)(1-r) ] = s^2(1-s)$。\n$P(0,1,0|\\mathcal{T}_1) = \\frac{1}{2}[s(1-s)^2 + s^2(1-s)] = \\frac{1}{2}s(1-s)(1-s+s) = \\frac{1}{2}s(1-s)$。\n因此，$P_{AC|B}(\\mathcal{T}_1) = 2 \\times P(0,1,0|\\mathcal{T}_1) = s(1-s)$。\n根据对称性，$P_{BC|A}(\\mathcal{T}_1) = s(1-s)$。\n\n对于与拓扑结构一致的模式 $AB|C$，其概率为 $P_{AB|C}(\\mathcal{T}_1) = s(1-s) + r(1-2s)^2$。\n\n观察到可变位点的总概率是这些概率之和：\n$P(\\text{var}|\\mathcal{T}_1) = P_{AB|C}(\\mathcal{T}_1) + P_{AC|B}(\\mathcal{T}_1) + P_{BC|A}(\\mathcal{T}_1) = [s(1-s) + r(1-2s)^2] + s(1-s) + s(1-s) = 3s(1-s) + r(1-2s)^2$。\n\n为简洁起见，我们定义两个概率：\n$p_{cong} = s(1-s) + r(1-2s)^2$ (与拓扑结构一致的模式的概率)\n$p_{incong} = s(1-s)$ (与拓扑结构不一致的模式的概率)\n$P_{var} = p_{cong} + 2p_{incong} = 3s(1-s) + r(1-2s)^2$。\n\n$\\mathcal{T}_1$ 的抽样校正概率为：\n$\\pi_1 = P(AB|C|\\mathcal{T}_1, \\text{var}) = \\frac{p_{cong}}{P_{var}}$\n$\\pi_2 = P(AC|B|\\mathcal{T}_1, \\text{var}) = \\frac{p_{incong}}{P_{var}}$\n$\\pi_3 = P(BC|A|\\mathcal{T}_1, \\text{var}) = \\frac{p_{incong}}{P_{var}}$\n\n**2. 拓扑结构 $\\mathcal{T}_2 = ((A,C),B)$ 的模式概率**\n\n这个拓扑结构与 $\\mathcal{T}_1$ 相同，只是分类单元 $B$ 和 $C$ 互换了位置。根据对称性，与 $\\mathcal{T}_2$ 一致的模式是 $AC|B$。不一致的模式是 $AB|C$ 和 $BC|A$。\n$P_{AC|B}(\\mathcal{T}_2) = p_{cong}$\n$P_{AB|C}(\\mathcal{T}_2) = p_{incong}$\n$P_{BC|A}(\\mathcal{T}_2) = p_{incong}$\n\n可变性概率是相同的：$P(\\text{var}|\\mathcal{T}_2) = P_{var}$。\n$\\mathcal{T}_2$ 的抽样校正概率为：\n$\\rho_1 = P(AB|C|\\mathcal{T}_2, \\text{var}) = \\frac{p_{incong}}{P_{var}} = \\pi_2$。\n$\\rho_2 = P(AC|B|\\mathcal{T}_2, \\text{var}) = \\frac{p_{cong}}{P_{var}} = \\pi_1$。\n$\\rho_3 = P(BC|A|\\mathcal{T}_2, \\text{var}) = \\frac{p_{incong}}{P_{var}} = \\pi_2$。\n\n**3. 计算贝叶斯因子**\n\n每种拓扑结构的似然为：\n$L(D|\\mathcal{T}_1) \\propto (\\pi_1)^{n_{AB|C}} (\\pi_2)^{n_{AC|B}} (\\pi_2)^{n_{BC|A}} = (\\pi_1)^{120} (\\pi_2)^{80} (\\pi_2)^{100} = (\\pi_1)^{120} (\\pi_2)^{180}$。\n$L(D|\\mathcal{T}_2) \\propto (\\rho_1)^{n_{AB|C}} (\\rho_2)^{n_{AC|B}} (\\rho_3)^{n_{BC|A}} = (\\pi_2)^{120} (\\pi_1)^{80} (\\pi_2)^{100} = (\\pi_1)^{80} (\\pi_2)^{220}$。\n\n贝叶斯因子是这些似然的比值：\n$$\nBF_{12} = \\frac{L(D|\\mathcal{T}_1)}{L(D|\\mathcal{T}_2)} = \\frac{(\\pi_1)^{120} (\\pi_2)^{180}}{(\\pi_1)^{80} (\\pi_2)^{220}} = (\\pi_1)^{120-80} (\\pi_2)^{180-220} = (\\pi_1)^{40} (\\pi_2)^{-40} = \\left(\\frac{\\pi_1}{\\pi_2}\\right)^{40}\n$$\n\n**4. 数值计算**\n\n我们需要计算比率 $\\pi_1/\\pi_2$：\n$$\n\\frac{\\pi_1}{\\pi_2} = \\frac{p_{cong}/P_{var}}{p_{incong}/P_{var}} = \\frac{p_{cong}}{p_{incong}} = \\frac{s(1-s) + r(1-2s)^2}{s(1-s)} = 1 + \\frac{r(1-2s)^2}{s(1-s)}\n$$\n代入给定值 $s=0.1$ 和 $r=0.05$：\n$s(1-s) = 0.1 \\times (1-0.1) = 0.1 \\times 0.9 = 0.09$。\n$1-2s = 1 - 2 \\times 0.1 = 0.8$。\n$(1-2s)^2 = (0.8)^2 = 0.64$。\n$r(1-2s)^2 = 0.05 \\times 0.64 = 0.032$。\n该比率为：\n$$\n\\frac{\\pi_1}{\\pi_2} = 1 + \\frac{0.032}{0.09} = 1 + \\frac{32}{90} = 1 + \\frac{16}{45} = \\frac{61}{45}\n$$\n现在，我们计算贝叶斯因子：\n$$\nBF_{12} = \\left(\\frac{61}{45}\\right)^{40}\n$$\n使用计算器：\n$$\nBF_{12} \\approx (1.3555...)^{40} \\approx 192618.39\n$$\n四舍五入到四位有效数字，我们得到 $1.926 \\times 10^5$。", "answer": "$$\\boxed{1.926 \\times 10^5}$$", "id": "4542022"}, {"introduction": "要真正掌握贝叶斯系统发育学，理解其计算核心是无价的。这个综合性的编码练习将指导您从基本原理出发，构建一个完整的程序来计算树拓扑的后验概率[@problem_id:4542079]。通过实现Felsenstein剪枝算法并对分支长度进行边缘化，您将对现代系统发育软件如何将序列数据转化为进化见解获得深刻而实际的理解。", "problem": "构建一个完整的、可运行的程序，该程序在给定四个分类单元（标记为 $A$、$B$、$C$ 和 $D$）的固定脱氧核糖核酸 (DNA) 比对的情况下，通过对具有指定先验的分支长度进行边缘化，并使用 Jukes–Cantor 1969 (JC69) 替换模型，在系统发育学的贝叶斯推断下，计算无根分裂 $\\{A,B\\} \\mid \\{C,D\\}$ 的后验概率。目标读者为高等研究生水平，任务是应用贝叶斯推断、连续参数边缘化和通过 Felsenstein 剪枝算法进行似然计算的基本原理。\n\n基础必须是以下经过充分检验的事实和定义：\n- 贝叶斯定理：对于离散拓扑 $T$ 和连续分支长度向量 $\\mathbf{t}$（其先验为 $p(\\mathbf{t} \\mid T)$），给定数据 $D$ 的后验 $p(T \\mid D)$ 满足\n$$\np(T \\mid D) \\propto p(T) \\int p(D \\mid T, \\mathbf{t}) \\, p(\\mathbf{t} \\mid T) \\, d\\mathbf{t}.\n$$\n- JC69 模型的时间可逆连续时间马尔可夫过程：对于分支长度 $t \\ge 0$，速率归一化为 $1$，核苷酸 $i$ 到核苷酸 $j$ 在时间 $t$ 内的转换概率为\n$$\nP_{ij}(t) = \n\\begin{cases}\n\\frac{1}{4} + \\frac{3}{4} e^{-4t/3},  \\text{if } i = j, \\\\\n\\frac{1}{4} - \\frac{1}{4} e^{-4t/3},  \\text{if } i \\ne j,\n\\end{cases}\n$$\n平稳分布是均匀的，$\\pi_i = \\frac{1}{4}$ 对所有 $i$ 成立。\n- Felsenstein 剪枝算法：对于固定的树 $T$ 和分支长度 $\\mathbf{t}$，似然 $p(D \\mid T, \\mathbf{t})$ 在独立性假设下可以跨位点分解，并且可以通过动态规划计算，该算法沿着树从叶节点向根节点传播条件似然向量。\n\n除了这些基础知识，您不得引入任何快捷公式。仅使用这些原理来推导要计算的内容、其正确的原因以及如何构建算法。\n\n假设以下建模选择，必须严格执行：\n- 四个分类单元上存在三种可能的无根二叉拓扑：$T_1 = \\{A,B\\} \\mid \\{C,D\\}$，$T_2 = \\{A,C\\} \\mid \\{B,D\\}$ 和 $T_3 = \\{A,D\\} \\mid \\{B,C\\}$，其先验为 $p(T_k) = \\frac{1}{3}$，其中 $k \\in \\{1,2,3\\}$。\n- 对于每个拓扑 $T$，分支长度为 $\\mathbf{t} = (t_A, t_B, t_{\\text{int}}, t_C, t_D)$，分别对应于每个叶节点的悬挂分支和一个内部自分支。分支长度的先验是速率为 $\\lambda$ 的独立指数分布，即\n$$\np(\\mathbf{t}\\mid T) = \\prod_{x \\in \\{A,B,\\text{int},C,D\\}} \\lambda e^{-\\lambda t_x}.\n$$\n- 使用 JC69 模型进行核苷酸替换，平稳分布为均匀分布 $\\pi_i = \\frac{1}{4}$。\n- 为了计算 $p(D \\mid T)$，通过在提供的网格 $\\mathcal{G} = \\{g_1, g_2, \\dots, g_m\\}$ 上对每个分支进行离散求积来近似 $\\mathbf{t}$ 上的积分，形成 $m^5$ 维的笛卡尔积。使用与先验密度成比例的权重，即近似为\n$$\n\\int p(D \\mid T, \\mathbf{t}) p(\\mathbf{t} \\mid T) \\, d\\mathbf{t} \\approx \\sum_{\\mathbf{t} \\in \\mathcal{G}^5} p(D \\mid T, \\mathbf{t}) \\, e^{-\\lambda \\sum_x t_x},\n$$\n其中，在最终的后验归一化中，所有拓扑中都为常数的因子会抵消。以数值稳定的方式执行所有求和。\n\n通过在与指定分裂兼容的一个内部节点上对树进行定根，并应用 Felsenstein 剪枝算法来定义位点似然：\n- 对于 $T_1 = \\{A,B\\} \\mid \\{C,D\\}$，在连接 $A$、$B$ 和通往节点 $R$ 的内部边的内部节点处定根；节点 $R$ 连接到 $C$ 和 $D$。分支长度为 $(t_A, t_B, t_{\\text{int}}, t_C, t_D)$，分别沿边 $(A, B, \\text{internal}, C, D)$。\n- 对于 $T_2 = \\{A,C\\} \\mid \\{B,D\\}$，在连接 $A$、$C$ 和通往节点 $R$ 的内部边的内部节点处定根；节点 $R$ 连接到 $B$ 和 $D$。\n- 对于 $T_3 = \\{A,D\\} \\mid \\{B,C\\}$，在连接 $A$、$D$ 和通往节点 $R$ 的内部边的内部节点处定根；节点 $R$ 连接到 $B$ 和 $C$。\n\n在一个叶节点上，观察到的核苷酸为 $b \\in \\{A,C,G,T\\}$，分支长度为 $t$，其指向父节点的条件似然向量（以父节点核苷酸 $i$ 为索引）是 $P_{i b}(t)$。在一个内部节点 $R$ 上，有两个子节点信息 $M^{(1)}(k)$ 和 $M^{(2)}(k)$（对于核苷酸 $k$），该节点的似然向量是 $L_R(k) = M^{(1)}(k) M^{(2)}(k)$，而沿着长度为 $t_{\\text{int}}$ 的分支指向其父节点的信息是 $M_R(i) = \\sum_{k} P_{i k}(t_{\\text{int}}) L_R(k)$。在根节点处，位点似然为 $\\sum_i \\pi_i \\prod_{\\text{incident edges}} M_{\\text{edge}}(i)$。\n\n您的程序必须实现上述内容，并为一组给定的测试用例报告分裂 $\\{A,B\\} \\mid \\{C,D\\}$ 的后验概率 $p(T_1 \\mid D)$。\n\n测试套件：\n对于每个测试用例，您将获得分类单元 $A$、$B$、$C$ 和 $D$ 的 DNA 序列、指数速率 $\\lambda$ 以及分支长度网格 $\\mathcal{G}$。\n\n- 测试用例 1（正常路径，分支信号强）：\n  - $A$: \"ACGTACGTACGTACGTACGTACGT\"\n  - $B$: \"ACGTACGTACGTACGTACGTACGT\"\n  - $C$: \"TGCATGCATGCATGCATGCATGCA\"\n  - $D$: \"TGCATGCATGCATGCATGCATGCA\"\n  - $\\lambda = 2.0$\n  - $\\mathcal{G} = \\{0.02, 0.15, 0.5\\}$\n\n- 测试用例 2（信号近乎模糊）：\n  - $A$: \"ACGTACGTACGTACGTACGTACGT\"\n  - $B$: \"CGTACGTACGTACGTACGTACGTA\"\n  - $C$: \"GTACGTACGTACGTACGTACGTAC\"\n  - $D$: \"TACGTACGTACGTACGTACGTACG\"\n  - $\\lambda = 2.0$\n  - $\\mathcal{G} = \\{0.02, 0.15, 0.5\\}$\n\n- 测试用例 3（边界情况，数据最少）：\n  - $A$: \"A\"\n  - $B$: \"A\"\n  - $C$: \"C\"\n  - $D$: \"C\"\n  - $\\lambda = 2.0$\n  - $\\mathcal{G} = \\{0.02, 0.15, 0.5\\}$\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，`[result1,result2,result3]`）。每个结果必须是相应测试用例中分裂 $\\{A,B\\} \\mid \\{C,D\\}$ 的后验概率，表示为保留小数点后 $6$ 位的小数。不得打印任何其他文本。\n\n所有角度在此问题中均不相关。此问题中没有物理单位。不得使用百分比；概率必须以小数表示。", "solution": "所陈述的问题在科学上是合理的、提法明确且内部一致。它提出了计算系统发育学中的一个标准任务：使用贝叶斯推断计算相互竞争的树拓扑的后验概率。为贝叶斯定理、Jukes-Cantor 1969 (JC69) 替换模型和 Felsenstein 剪枝算法提供的定义是正确的，并构成了此类计算的标准理论基础。所有必要的参数和建模选择，包括拓扑和分支长度的先验、演化模型以及数值积分的方法，都得到了明确的规定。因此，该问题被认为是有效的，可以构建一个形式化的解决方案。\n\n我们的目标是计算给定 DNA 序列比对 $D$ 的情况下，无根拓扑 $T_1 = \\{A,B\\} \\mid \\{C,D\\}$ 的后验概率，记为 $p(T_1 \\mid D)$。\n\n根据贝叶斯定理，拓扑 $T_k$ 的后验概率由下式给出：\n$$p(T_k \\mid D) = \\frac{p(D \\mid T_k) p(T_k)}{\\sum_{j=1}^{3} p(D \\mid T_j) p(T_j)}$$\n其中 $D$ 代表观察到的 DNA 序列。问题指定了对四个分类单元的三种可能无根拓扑的均匀先验，因此对于 $k \\in \\{1, 2, 3\\}$，$p(T_k) = \\frac{1}{3}$。这个常数先验概率从分子和分母中抵消，将表达式简化为：\n$$p(T_1 \\mid D) = \\frac{p(D \\mid T_1)}{\\sum_{j=1}^{3} p(D \\mid T_j)}$$\n核心任务是为三种拓扑中的每一种计算边缘似然 $p(D \\mid T_k)$，这三种拓扑为 $T_1 = \\{A,B\\} \\mid \\{C,D\\}$，$T_2 = \\{A,C\\} \\mid \\{B,D\\}$ 和 $T_3 = \\{A,D\\} \\mid \\{B,C\\}$。\n\n边缘似然是通过在所有可能的分支长度 $\\mathbf{t}$上对完整似然进行积分得到的，并由其先验概率密度加权：\n$$p(D \\mid T_k) = \\int p(D \\mid T_k, \\mathbf{t}) \\, p(\\mathbf{t} \\mid T_k) \\, d\\mathbf{t}$$\n五个分支长度向量 $\\mathbf{t} = (t_A, t_B, t_{\\text{int}}, t_C, t_D)$ 的先验被给定为速率为 $\\lambda$ 的独立指数分布的乘积：\n$$p(\\mathbf{t} \\mid T_k) = \\prod_{x \\in \\{A,B,\\text{int},C,D\\}} \\lambda e^{-\\lambda t_x} = \\lambda^5 e^{-\\lambda \\sum_{x} t_x}$$\n问题指定连续积分将通过在分支长度网格 $\\mathcal{G}$ 上的离散和来近似。对于五个分支中的每一个，其长度都从 $\\mathcal{G}$ 中选择。近似公式如下：\n$$p(D \\mid T_k) \\approx C \\sum_{\\mathbf{t} \\in \\mathcal{G}^5} p(D \\mid T_k, \\mathbf{t}) \\, e^{-\\lambda \\sum_{x} t_x}$$\n比例常数 $C$ 包括来自先验的因子（如 $\\lambda^5$）和来自求积法则的任何权重，这些在所有拓扑中都是常数，因此在计算最终后验概率时会抵消。令 $M_k = \\sum_{\\mathbf{t} \\in \\mathcal{G}^5} p(D \\mid T_k, \\mathbf{t}) \\, e^{-\\lambda \\sum_{x} t_x}$。那么后验概率为 $p(T_1 \\mid D) = \\frac{M_1}{M_1 + M_2 + M_3}$。\n\n为避免数值下溢，标准做法是使用对数似然。整个比对 $D$ 的似然是每个独立位点 $s$ 似然的乘积，假设位点独立演化：\n$$p(D \\mid T_k, \\mathbf{t}) = \\prod_{s=1}^{N} p(D_s \\mid T_k, \\mathbf{t})$$\n其中 $N$ 是比对中的位点数。在对数空间中，这变成一个和：\n$$\\log p(D \\mid T_k, \\mathbf{t}) = \\sum_{s=1}^{N} \\log p(D_s \\mid T_k, \\mathbf{t})$$\n位点似然 $p(D_s \\mid T_k, \\mathbf{t})$ 使用 Felsenstein 剪枝算法计算。让我们为拓扑 $T_1 = \\{A,B\\} \\mid \\{C,D\\}$ 详细说明这一点。无根树有一个连接两个内部节点的内部自分支，我们将其标记为 $U$ 和 $V$。节点 $U$ 连接到叶节点 $A$ 和 $B$，节点 $V$ 连接到叶节点 $C$ 和 $D$。悬挂边的分支长度为 $t_A$, $t_B$, $t_C$, $t_D$，内部边 $(U,V)$ 的分支长度为 $t_{\\text{int}}$。\n\n为应用剪枝算法，我们对树进行定根，例如在节点 $U$ 处。对于具有观察到的核苷酸 $(d_A, d_B, d_C, d_D)$ 的单个位点 $s$，算法流程如下：\n$1$。JC$69$ 模型在长度为 $t$ 的分支上的转换概率矩阵是 $P(t)$，其中条目 $P_{ij}(t)$ 为：\n$$P_{ij}(t) = \\begin{cases} \\frac{1}{4} + \\frac{3}{4} e^{-4t/3},  \\text{if } i = j \\\\ \\frac{1}{4} - \\frac{1}{4} e^{-4t/3},  \\text{if } i \\ne j \\end{cases}$$\n索引 $i, j$ 对应于四种核苷酸 $\\{A, C, G, T\\}$。\n\n$2$。在每个叶节点（例如 $A$），定义条件似然向量 $L_A$。这个 4 元素向量表示在该叶节点上观察到核苷酸 $d_A$ 的似然，条件是其父节点 $U$ 处于状态 $i \\in \\{A,C,G,T\\}$。对于叶节点 $A$，这是 $L_A(i) = P_{i,d_A}(t_A)$。这实际上是矩阵 $P(t_A)$ 中对应于核苷酸 $d_A$ 的列。类似地，我们计算 $L_B(i) = P_{i,d_B}(t_B)$、$L_C(i) = P_{i,d_C}(t_C)$ 和 $L_D(i) = P_{i,d_D}(t_D)$。\n\n$3$。算法从叶节点向根节点进行。在内部节点 $V$，我们合并来自其子节点 $C$ 和 $D$ 的信息。节点 $V$ 的条件似然向量 $L_V$ 是传入的条件似然向量的逐元素乘积 (Hadamard product)：对于每个状态 $k$，$L_V(k) = L_C(k) \\cdot L_D(k)$。\n\n$4$。节点 $V$ 的信息沿着长度为 $t_{\\text{int}}$ 的内部自分支向上传递给其父节点 $U$。从 $U$ 看到的这个新的条件似然向量 $M_V$ 是通过对节点 $V$ 所有可能状态 $k$ 求和计算的：\n$$M_V(i) = \\sum_{k \\in \\{A,C,G,T\\}} P_{ik}(t_{\\text{int}}) L_V(k)$$\n这是一个矩阵-向量乘积：$M_V = P(t_{\\text{int}}) \\cdot L_V$。\n\n$5$。在根节点 $U$，我们合并来自其子节点的信息：叶节点 $A$ 和 $B$，以及内部节点 $V$。根节点处的最终条件似然向量 $L_U$ 是逐元素乘积：$L_U(i) = L_A(i) \\cdot L_B(i) \\cdot M_V(i)$。\n\n$6$。通过对根节点的可能状态进行平均，并以其平稳概率 $\\pi_i = \\frac{1}{4}$ 加权，获得位点的总似然：\n$$p(D_s \\mid T_1, \\mathbf{t}) = \\sum_{i \\in \\{A,C,G,T\\}} \\pi_i L_U(i) = \\frac{1}{4} \\sum_{i} L_U(i)$$\n\n对每个位点 $s$ 执行此过程以计算总对数似然 $\\log p(D \\mid T_k, \\mathbf{t})$。整个计算嵌套在对分支长度网格 $\\mathcal{G}^5$ 的循环中。\n\n边缘似然 $M_k$ 的数值稳定计算至关重要。我们计算一个对数项的向量，其中每一项为 $\\log(p(D \\mid T_k, \\mathbf{t}) e^{-\\lambda \\sum t_x}) = \\log p(D \\mid T_k, \\mathbf{t}) - \\lambda \\sum t_x$。然后我们使用 log-sum-exp 技巧计算它们指数和的对数：\n$$\\log M_k = \\log \\left( \\sum_{\\mathbf{t} \\in \\mathcal{G}^5} e^{\\log p(D \\mid T_k, \\mathbf{t}) - \\lambda \\sum t_x} \\right) = Z_{\\text{max}} + \\log \\left( \\sum_{\\mathbf{t} \\in \\mathcal{G}^5} e^{(\\log p(D \\mid T_k, \\mathbf{t}) - \\lambda \\sum t_x) - Z_{\\text{max}}} \\right)$$\n其中 $Z_{\\text{max}}$ 是对数项的最大值。令 $\\log M_k$ 为计算出的拓扑 $T_k$ 的对数边缘似然。\n\n最后，后验概率 $p(T_1 \\mid D)$ 是从 $\\log M_1, \\log M_2, \\log M_3$ 使用 softmax 函数计算得到的，以保证数值稳定性：\n$$p(T_1 \\mid D) = \\frac{M_1}{M_1 + M_2 + M_3} = \\frac{e^{\\log M_1}}{e^{\\log M_1} + e^{\\log M_2} + e^{\\log M_3}} = \\frac{e^{\\log M_1 - LM_{\\text{max}}}}{e^{\\log M_1 - LM_{\\text{max}}} + e^{\\log M_2 - LM_{\\text{max}}} + e^{\\log M_3 - LM_{\\text{max}}}}$$\n其中 $LM_{\\text{max}} = \\max(\\log M_1, \\log M_2, \\log M_3)$。这提供了最终所需的概率。", "answer": "```python\nimport numpy as np\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to solve the phylogenetic inference problem for the given test cases.\n    \"\"\"\n\n    NUC_MAP = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    \n    # Pre-calculate powers of grid size for indexing branch lengths\n    m_powers = None \n    \n    def get_jc69_matrix(t):\n        \"\"\"\n        Computes the JC69 transition probability matrix for a given branch length t.\n        P_ij(t) is the probability of changing from nucleotide i to j.\n        \"\"\"\n        if t  0:\n            raise ValueError(\"Branch length t cannot be negative.\")\n        \n        p_diag = 0.25 + 0.75 * np.exp(-4.0 * t / 3.0)\n        p_off_diag = 0.25 - 0.25 * np.exp(-4.0 * t / 3.0)\n        \n        mat = np.full((4, 4), p_off_diag)\n        np.fill_diagonal(mat, p_diag)\n        return mat\n\n    def compute_site_likelihood(site_data, taxa_split, branch_lengths, p_matrices, nuc_map):\n        \"\"\"\n        Computes the likelihood for a single site using Felsenstein's pruning algorithm.\n        \n        Args:\n            site_data (dict): Nucleotides for each taxon at this site, e.g., {'A': 'C', ...}.\n            taxa_split (tuple): The two clades defining the topology, e.g., (('A', 'B'), ('C', 'D')).\n            branch_lengths (tuple): 5 branch lengths (t_A, t_B, t_int, t_C, t_D).\n            p_matrices (dict): Precomputed transition matrices for all branch lengths in the grid.\n            nuc_map (dict): Mapping from nucleotide characters to integer indices.\n        \n        Returns:\n            float: The likelihood for the site.\n        \"\"\"\n        taxa_u = taxa_split[0]  # E.g., ('A', 'B')\n        taxa_v = taxa_split[1]  # E.g., ('C', 'D')\n        \n        # Branch lengths are ordered according to the alphabetical order of taxa A, B, C, D\n        # mapping to pendant branches, and the last one to the internal branch.\n        # This implementation re-assigns them based on the specific topology for clarity.\n        t_map = {\n            taxa_u[0]: branch_lengths[0],\n            taxa_u[1]: branch_lengths[1],\n            taxa_v[0]: branch_lengths[2],\n            taxa_v[1]: branch_lengths[3],\n            'int': branch_lengths[4],\n        }\n\n        # Step 2: Get conditional likelihood vectors from leaves.\n        # L_X is a 4-element vector of Pr(data at leaf X | parent is in state i)\n        L_leaf_u0 = p_matrices[t_map[taxa_u[0]]][:, nuc_map[site_data[taxa_u[0]]]]\n        L_leaf_u1 = p_matrices[t_map[taxa_u[1]]][:, nuc_map[site_data[taxa_u[1]]]]\n        L_leaf_v0 = p_matrices[t_map[taxa_v[0]]][:, nuc_map[site_data[taxa_v[0]]]]\n        L_leaf_v1 = p_matrices[t_map[taxa_v[1]]][:, nuc_map[site_data[taxa_v[1]]]]\n        \n        # Step 3: Compute conditional likelihood at internal node V\n        # L_V(k) = L_C(k) * L_D(k) (Hadamard product)\n        L_V = L_leaf_v0 * L_leaf_v1\n        \n        # Step 4: Pass message from V to U up the internal branch\n        # M_V(i) = sum_k P_ik(t_int) * L_V(k) (Matrix-vector product)\n        P_int = p_matrices[t_map['int']]\n        M_V = P_int @ L_V\n        \n        # Step 5: Compute conditional likelihood at root node U\n        # L_U(i) = L_A(i) * L_B(i) * M_V(i) (Hadamard product)\n        L_U = L_leaf_u0 * L_leaf_u1 * M_V\n        \n        # Step 6: Compute final site likelihood by averaging over root states\n        # The stationary distribution pi is uniform (1/4 for each state).\n        return np.sum(L_U) * 0.25\n\n    def compute_log_marginal_likelihood(sequences, taxa_split, grid, lmbda, nuc_map):\n        \"\"\"\n        Computes the log of the marginal likelihood for a given topology.\n        This involves summing over all combinations of branch lengths from the grid.\n        \"\"\"\n        num_sites = len(sequences['A'])\n        \n        # Precompute all necessary transition matrices\n        p_matrices = {t: get_jc69_matrix(t) for t in grid}\n\n        grid_size = len(grid)\n        num_combinations = grid_size ** 5\n        log_terms = np.zeros(num_combinations)\n\n        # Iterate over all 5-tuples of branch lengths from the grid\n        for i, branch_lengths in enumerate(product(grid, repeat=5)):\n            \n            # The order of branch lengths corresponds to taxa_split's deep-then-across order\n            # e.g., ((A,B),(C,D)) -> t_A, t_B, t_C, t_D, t_int\n            # For T1 (A,B)|(C,D): (t_A, t_B, t_C, t_D, t_int)\n            # For T2 (A,C)|(B,D): (t_A, t_C, t_B, t_D, t_int)\n            # For T3 (A,D)|(B,C): (t_A, t_D, t_B, t_C, t_int)\n            # The `compute_site_likelihood` maps them correctly based on taxa_split.\n            \n            # For this combination of branch lengths, compute total log-likelihood over all sites\n            total_log_likelihood = 0.0\n            for s in range(num_sites):\n                site_data = {taxon: sequences[taxon][s] for taxon in 'ABCD'}\n                site_likelihood = compute_site_likelihood(site_data, taxa_split, branch_lengths, p_matrices, nuc_map)\n                \n                # To prevent log(0) for extremely unlikely sites, add a small epsilon.\n                if site_likelihood > 0:\n                    total_log_likelihood += np.log(site_likelihood)\n                else:\n                    total_log_likelihood += -np.inf # Effectively makes this branch length combo have 0 probability\n\n            # Calculate the log of the prior term (up to a constant)\n            log_prior_term = -lmbda * sum(branch_lengths)\n            \n            # Store the log of the term to be summed: log(P(D|T,t) * P(t|T))\n            log_terms[i] = total_log_likelihood + log_prior_term\n        \n        # Compute log-sum-exp for numerical stability\n        max_log_term = np.max(log_terms)\n        if max_log_term == -np.inf:\n            return -np.inf\n            \n        log_marginal_lik = max_log_term + np.log(np.sum(np.exp(log_terms - max_log_term)))\n        \n        return log_marginal_lik\n\n    test_cases = [\n        {\n            \"sequences\": {\n                'A': \"ACGTACGTACGTACGTACGTACGT\",\n                'B': \"ACGTACGTACGTACGTACGTACGT\",\n                'C': \"TGCATGCATGCATGCATGCATGCA\",\n                'D': \"TGCATGCATGCATGCATGCATGCA\",\n            },\n            \"lambda\": 2.0,\n            \"grid\": [0.02, 0.15, 0.5]\n        },\n        {\n            \"sequences\": {\n                'A': \"ACGTACGTACGTACGTACGTACGT\",\n                'B': \"CGTACGTACGTACGTACGTACGTA\",\n                'C': \"GTACGTACGTACGTACGTACGTAC\",\n                'D': \"TACGTACGTACGTACGTACGTACG\",\n            },\n            \"lambda\": 2.0,\n            \"grid\": [0.02, 0.15, 0.5]\n        },\n        {\n            \"sequences\": {\n                'A': \"A\",\n                'B': \"A\",\n                'C': \"C\",\n                'D': \"C\",\n            },\n            \"lambda\": 2.0,\n            \"grid\": [0.02, 0.15, 0.5]\n        }\n    ]\n\n    results = []\n    \n    # Define the three unrooted topologies\n    topologies = [\n        (('A', 'B'), ('C', 'D')),  # T1\n        (('A', 'C'), ('B', 'D')),  # T2\n        (('A', 'D'), ('B', 'C')),  # T3\n    ]\n\n    for case in test_cases:\n        sequences = case[\"sequences\"]\n        lmbda = case[\"lambda\"]\n        grid = tuple(sorted(case[\"grid\"])) # Ensure consistent order for memoization of P-matrices\n\n        log_marginal_likelihoods = []\n        for taxa_split in topologies:\n            # Map branch lengths to topology in a consistent way for the calculation\n            # For ((t1,t2),(t3,t4)), we use branch lengths for t1, t2, t3, t4, and internal\n            # Let's define the order based on the alphabetical order of taxa within the split\n            taxa_for_branch_order = sorted(taxa_split[0]) + sorted(taxa_split[1])\n\n            log_ml = compute_log_marginal_likelihood(sequences, taxa_split, grid, lmbda, NUC_MAP)\n            log_marginal_likelihoods.append(log_ml)\n        \n        log_ml_arr = np.array(log_marginal_likelihoods)\n        \n        # Compute posterior probabilities using softmax for numerical stability\n        max_log_ml = np.max(log_ml_arr)\n        \n        # If all log-likelihoods are -inf, posterior is undefined. Assign uniform.\n        if max_log_ml == -np.inf:\n             posteriors = np.full(3, 1.0/3.0)\n        else:\n            exp_terms = np.exp(log_ml_arr - max_log_ml)\n            sum_exp_terms = np.sum(exp_terms)\n            posteriors = exp_terms / sum_exp_terms\n        \n        # Result for T1 = {A,B}|{C,D} is the first one\n        result_t1 = posteriors[0]\n        results.append(f\"{result_t1:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "4542079"}]}