{"hands_on_practices": [{"introduction": "现代蛋白质结构预测模型通常将蛋白质表示为一个图，其中残基是节点，相互作用是边。理解信息如何在这些节点之间传递是掌握这些模型工作原理的关键。本练习将引导您完成一次图神经网络（GNN）信息传递迭代的具体计算，揭示模型如何整合局部信息来更新残基的表征。[@problem_id:4554878]", "problem": "考虑一个包含四个残基的蛋白质接触图，残基索引为 $i \\in \\{1,2,3,4\\}$。残基是节点，无向边代表空间上的接触。每个节点 $i$ 拥有一个二维特征向量 $h_{i} \\in \\mathbb{R}^{2}$，描述学习到的生化属性；每条边 $(i,j)$ 拥有一个二维特征 $e_{ij} \\in \\mathbb{R}^{2}$，编码几何信息和序列分离信息。这种基于图的表示方法与物理原理一致，即残基-残基相互作用沿接触网络传播，并且任何学习到的更新都必须对节点索引的排列保持不变。\n\n初始节点特征为\n$$\nh_{1}=\\begin{pmatrix}1 \\\\ 0\\end{pmatrix},\\quad\nh_{2}=\\begin{pmatrix}0 \\\\ 2\\end{pmatrix},\\quad\nh_{3}=\\begin{pmatrix}1 \\\\ -1\\end{pmatrix},\\quad\nh_{4}=\\begin{pmatrix}2 \\\\ 1\\end{pmatrix}.\n$$\n在点对 $(1,2)$, $(2,3)$, $(3,4)$ 和 $(1,4)$ 之间存在边。对于每条边 $(i,j)$，定义 $e_{ij}=\\begin{pmatrix}1/d_{ij} \\\\ |i-j|\\end{pmatrix}$，其中 $d_{ij}$ 是以埃（Angstroms）为单位的残基间距离（这是一个对残基接触有物理意义的尺度）。距离为\n$$\nd_{12}=4,\\quad d_{23}=5,\\quad d_{34}=4,\\quad d_{14}=8,\n$$\n因此\n$$\ne_{12}=\\begin{pmatrix}\\frac{1}{4} \\\\ 1\\end{pmatrix},\\quad\ne_{23}=\\begin{pmatrix}\\frac{1}{5} \\\\ 1\\end{pmatrix},\\quad\ne_{34}=\\begin{pmatrix}\\frac{1}{4} \\\\ 1\\end{pmatrix},\\quad\ne_{14}=\\begin{pmatrix}\\frac{1}{8} \\\\ 3\\end{pmatrix}.\n$$\n\n使用图神经网络（GNN）执行一次消息传递迭代。其基本原理是，一个残基 $j$ 从其邻居 $i \\in \\mathcal{N}(j)$ 接收消息，每条有向消息 $m_{i\\to j}$ 都由一个门（gate）进行调制，该门源自发送者节点的特征和边的特征。使用以下组件：\n- 修正线性单元（ReLU）非线性函数 $\\phi(x)=\\max(0,x)$，按元素应用。\n- 门控分数 $s_{ij}=a^{\\top}h_{i}+c^{\\top}e_{ij}$，其中 $a=\\begin{pmatrix}1 \\\\ 1\\end{pmatrix}$，$c=\\begin{pmatrix}0 \\\\ 1\\end{pmatrix}$，以及一个标量门 $g_{ij}=\\phi(s_{ij})$。\n- 消息函数 $m_{i\\to j}=g_{ij}\\cdot \\phi\\!\\big(W_{m}h_{i}+U_{m}e_{ij}+b_{m}\\big)$，其中\n$$\nW_{m}=\\begin{pmatrix}1  -1 \\\\ 0  2\\end{pmatrix},\\quad\nU_{m}=\\begin{pmatrix}2  0 \\\\ 1  1\\end{pmatrix},\\quad\nb_{m}=\\begin{pmatrix}0 \\\\ 0\\end{pmatrix}.\n$$\n- 通过求和进行邻居聚合：$s_{j}=\\sum_{i\\in\\mathcal{N}(j)} m_{i\\to j}$。\n- 使用 ReLU 对节点进行残差更新：$h_{j}^{\\text{new}}=\\phi\\!\\big(W_{s}h_{j}+V s_{j}+b_{s}\\big)$，其中\n$$\nW_{s}=\\begin{pmatrix}1  0 \\\\ 0  1\\end{pmatrix},\\quad\nV=\\begin{pmatrix}1  0 \\\\ 0  1\\end{pmatrix},\\quad\nb_{s}=\\begin{pmatrix}0 \\\\ 0\\end{pmatrix}.\n$$\n\n在这一次消息传递迭代后，计算残基 3 的更新后特征 $h_{3}^{\\text{new}}$，然后计算其欧几里得范数的平方 $\\|h_{3}^{\\text{new}}\\|_{2}^{2}$。将你的最终标量答案表示为一个精确的有理数。不需要四舍五入，也不需要报告单位。", "solution": "用户要求计算单次消息传递迭代后更新的特征向量 $h_{3}^{\\text{new}}$ 及其欧几里得范数的平方 $\\|h_{3}^{\\text{new}}\\|_{2}^{2}$。该问题定义明确，在用于蛋白质建模的图神经网络领域具有科学依据，并为获得唯一解提供了所有必要的数据和定义。\n\n该过程涉及计算来自残基 3 邻居的消息，对它们进行聚合，然后使用聚合后的消息来更新残基 3 的特征向量。\n\n根据给定的边 $(2,3)$ 和 $(3,4)$，残基 $j=3$ 的邻居集合是 $\\mathcal{N}(3)=\\{2, 4\\}$。\n\n节点特征向量 $h_j$ 的更新规则由下式给出：\n$$\nh_{j}^{\\text{new}}=\\phi\\!\\big(W_{s}h_{j}+V s_{j}+b_{s}\\big)\n$$\n其中 $s_j$ 是来自 $j$ 的邻居的聚合消息。更新步骤的参数给定为 $W_s$ 和 $V$ 的单位矩阵，以及 $b_s$ 的零向量：\n$$\nW_{s}=\\begin{pmatrix}1  0 \\\\ 0  1\\end{pmatrix}, \\quad V=\\begin{pmatrix}1  0 \\\\ 0  1\\end{pmatrix}, \\quad b_{s}=\\begin{pmatrix}0 \\\\ 0\\end{pmatrix}\n$$\n更新规则简化为：\n$$\nh_{j}^{\\text{new}}=\\phi(h_{j} + s_{j})\n$$\n聚合消息 $s_j$ 是来自其邻居的传入消息的总和：\n$$\ns_{j}=\\sum_{i\\in\\mathcal{N}(j)} m_{i\\to j}\n$$\n对于残基 $j=3$，该值为 $s_{3}=m_{2\\to 3}+m_{4\\to 3}$。\n\n消息函数 $m_{i\\to j}$ 定义为：\n$$\nm_{i\\to j}=g_{ij}\\cdot \\phi\\!\\big(W_{m}h_{i}+U_{m}e_{ij}+b_{m}\\big)\n$$\n其中门 $g_{ij}$ 是 $g_{ij}=\\phi(s_{ij})$，分数 $s_{ij}$ 是 $s_{ij}=a^{\\top}h_{i}+c^{\\top}e_{ij}$。\n\n首先，我们计算从残基 2 到残基 3 的消息，记为 $m_{2\\to 3}$。\n所需的特征是 $h_{2}=\\begin{pmatrix}0 \\\\ 2\\end{pmatrix}$ 和 $e_{23}=\\begin{pmatrix}1/5 \\\\ 1\\end{pmatrix}$。门控参数是 $a=\\begin{pmatrix}1 \\\\ 1\\end{pmatrix}$ 和 $c=\\begin{pmatrix}0 \\\\ 1\\end{pmatrix}$。\n门控分数为：\n$$\ns_{23} = a^{\\top}h_{2}+c^{\\top}e_{23} = \\begin{pmatrix}1  1\\end{pmatrix}\\begin{pmatrix}0 \\\\ 2\\end{pmatrix} + \\begin{pmatrix}0  1\\end{pmatrix}\\begin{pmatrix}\\frac{1}{5} \\\\ 1\\end{pmatrix} = (1 \\cdot 0 + 1 \\cdot 2) + (0 \\cdot \\frac{1}{5} + 1 \\cdot 1) = 2 + 1 = 3\n$$\n门是 $g_{23}=\\phi(s_{23})=\\phi(3)=3$。\n消息函数中 ReLU 的参数是使用 $W_{m}=\\begin{pmatrix}1  -1 \\\\ 0  2\\end{pmatrix}$，$U_{m}=\\begin{pmatrix}2  0 \\\\ 1  1\\end{pmatrix}$ 和 $b_{m}=\\begin{pmatrix}0 \\\\ 0\\end{pmatrix}$ 计算的：\n$$\nW_{m}h_{2} = \\begin{pmatrix}1  -1 \\\\ 0  2\\end{pmatrix}\\begin{pmatrix}0 \\\\ 2\\end{pmatrix} = \\begin{pmatrix}-2 \\\\ 4\\end{pmatrix}\n$$\n$$\nU_{m}e_{23} = \\begin{pmatrix}2  0 \\\\ 1  1\\end{pmatrix}\\begin{pmatrix}\\frac{1}{5} \\\\ 1\\end{pmatrix} = \\begin{pmatrix}\\frac{2}{5} \\\\ \\frac{1}{5}+1\\end{pmatrix} = \\begin{pmatrix}\\frac{2}{5} \\\\ \\frac{6}{5}\\end{pmatrix}\n$$\n预激活向量为：\n$$\nW_{m}h_{2}+U_{m}e_{23}+b_{m} = \\begin{pmatrix}-2 \\\\ 4\\end{pmatrix} + \\begin{pmatrix}\\frac{2}{5} \\\\ \\frac{6}{5}\\end{pmatrix} + \\begin{pmatrix}0 \\\\ 0\\end{pmatrix} = \\begin{pmatrix}-\\frac{10}{5}+\\frac{2}{5} \\\\ \\frac{20}{5}+\\frac{6}{5}\\end{pmatrix} = \\begin{pmatrix}-\\frac{8}{5} \\\\ \\frac{26}{5}\\end{pmatrix}\n$$\n应用 ReLU 并乘以门得到消息：\n$$\nm_{2\\to 3} = g_{23} \\cdot \\phi\\left(\\begin{pmatrix}-\\frac{8}{5} \\\\ \\frac{26}{5}\\end{pmatrix}\\right) = 3 \\cdot \\begin{pmatrix}0 \\\\ \\frac{26}{5}\\end{pmatrix} = \\begin{pmatrix}0 \\\\ \\frac{78}{5}\\end{pmatrix}\n$$\n接下来，我们计算从残基 4 到残基 3 的消息，记为 $m_{4\\to 3}$。\n所需的特征是 $h_{4}=\\begin{pmatrix}2 \\\\ 1\\end{pmatrix}$ 和 $e_{43}=e_{34}=\\begin{pmatrix}1/4 \\\\ 1\\end{pmatrix}$。\n门控分数为：\n$$\ns_{43} = a^{\\top}h_{4}+c^{\\top}e_{43} = \\begin{pmatrix}1  1\\end{pmatrix}\\begin{pmatrix}2 \\\\ 1\\end{pmatrix} + \\begin{pmatrix}0  1\\end{pmatrix}\\begin{pmatrix}\\frac{1}{4} \\\\ 1\\end{pmatrix} = (1 \\cdot 2 + 1 \\cdot 1) + (0 \\cdot \\frac{1}{4} + 1 \\cdot 1) = 3 + 1 = 4\n$$\n门是 $g_{43}=\\phi(s_{43})=\\phi(4)=4$。\n预激活向量为：\n$$\nW_{m}h_{4} = \\begin{pmatrix}1  -1 \\\\ 0  2\\end{pmatrix}\\begin{pmatrix}2 \\\\ 1\\end{pmatrix} = \\begin{pmatrix}1 \\\\ 2\\end{pmatrix}\n$$\n$$\nU_{m}e_{43} = \\begin{pmatrix}2  0 \\\\ 1  1\\end{pmatrix}\\begin{pmatrix}\\frac{1}{4} \\\\ 1\\end{pmatrix} = \\begin{pmatrix}\\frac{2}{4} \\\\ \\frac{1}{4}+1\\end{pmatrix} = \\begin{pmatrix}\\frac{1}{2} \\\\ \\frac{5}{4}\\end{pmatrix}\n$$\n$$\nW_{m}h_{4}+U_{m}e_{43}+b_{m} = \\begin{pmatrix}1 \\\\ 2\\end{pmatrix} + \\begin{pmatrix}\\frac{1}{2} \\\\ \\frac{5}{4}\\end{pmatrix} + \\begin{pmatrix}0 \\\\ 0\\end{pmatrix} = \\begin{pmatrix}\\frac{3}{2} \\\\ \\frac{8}{4}+\\frac{5}{4}\\end{pmatrix} = \\begin{pmatrix}\\frac{3}{2} \\\\ \\frac{13}{4}\\end{pmatrix}\n$$\n应用 ReLU 并乘以门得到消息。由于两个分量都为正，ReLU 不起作用。\n$$\nm_{4\\to 3} = g_{43} \\cdot \\phi\\left(\\begin{pmatrix}\\frac{3}{2} \\\\ \\frac{13}{4}\\end{pmatrix}\\right) = 4 \\cdot \\begin{pmatrix}\\frac{3}{2} \\\\ \\frac{13}{4}\\end{pmatrix} = \\begin{pmatrix}6 \\\\ 13\\end{pmatrix}\n$$\n现在，我们聚合这些消息以获得 $s_3$：\n$$\ns_{3} = m_{2\\to 3} + m_{4\\to 3} = \\begin{pmatrix}0 \\\\ \\frac{78}{5}\\end{pmatrix} + \\begin{pmatrix}6 \\\\ 13\\end{pmatrix} = \\begin{pmatrix}6 \\\\ \\frac{78}{5} + \\frac{65}{5}\\end{pmatrix} = \\begin{pmatrix}6 \\\\ \\frac{143}{5}\\end{pmatrix}\n$$\n我们使用这个聚合消息来更新残基 3 的特征向量，使用其初始状态 $h_{3}=\\begin{pmatrix}1 \\\\ -1\\end{pmatrix}$。\n$$\nh_{3}^{\\text{new}} = \\phi(h_{3} + s_{3}) = \\phi\\left(\\begin{pmatrix}1 \\\\ -1\\end{pmatrix} + \\begin{pmatrix}6 \\\\ \\frac{143}{5}\\end{pmatrix}\\right) = \\phi\\left(\\begin{pmatrix}7 \\\\ -\\frac{5}{5} + \\frac{143}{5}\\end{pmatrix}\\right) = \\phi\\left(\\begin{pmatrix}7 \\\\ \\frac{138}{5}\\end{pmatrix}\\right)\n$$\n由于参数的两个分量都为正，ReLU 非线性函数不起作用。\n$$\nh_{3}^{\\text{new}} = \\begin{pmatrix}7 \\\\ \\frac{138}{5}\\end{pmatrix}\n$$\n最后，我们计算 $h_{3}^{\\text{new}}$ 的欧几里得范数的平方：\n$$\n\\|h_{3}^{\\text{new}}\\|_{2}^{2} = (7)^2 + \\left(\\frac{138}{5}\\right)^2 = 49 + \\frac{138^2}{5^2} = 49 + \\frac{19044}{25}\n$$\n为了将其表示为单个有理数，我们通分：\n$$\n\\|h_{3}^{\\text{new}}\\|_{2}^{2} = \\frac{49 \\times 25}{25} + \\frac{19044}{25} = \\frac{1225}{25} + \\frac{19044}{25} = \\frac{1225 + 19044}{25} = \\frac{20269}{25}\n$$\n这个分数是不可约分的，因为分子不以 0 或 5 结尾，因此不能被 5 整除。\n最终答案是 $\\frac{20269}{25}$。", "answer": "$$\n\\boxed{\\frac{20269}{25}}\n$$", "id": "4554878"}, {"introduction": "精确预测蛋白质三维结构是一项艰巨的任务，需要模型同时优化多个目标。本练习模拟了 AlphaFold2 等先进模型中使用的复合损失函数的设计过程，您将学习如何将来自距离、角度和整体结构准确性的不同误差信号，整合成一个统一且可训练的优化目标。[@problem_id:3842267]", "problem": "你的任务是为基于深度学习的蛋白质结构预测构建一个复合训练损失，该损失融合了四个组成部分：distogram（距离图）交叉熵、Frame Aligned Point Error (FAPE，骨架对齐点误差)、扭转角损失以及一个违规惩罚项。目标是推导、实现并论证一种有原则的、在量纲上保持一致的加权方案，以平衡各项异构部分的贡献。所有角度必须以弧度为单位，所有距离以埃（Angstrom，写作 $\\mathrm{\\AA}$）为单位，所有对数必须是自然对数。你必须编写一个完整的、可运行的程序，为多个测试用例计算复合损失，并将结果输出为单行列表。\n\n从以下基础和核心定义开始：\n\n- 概率公理和交叉熵的定义：对于一个离散分布 $p(k)$ 和一个在区间 $k^\\star$ 上的独热（one-hot）目标，交叉熵为 $-\\log p(k^\\star)$。\n- 三维空间中的刚体坐标系，由一个旋转矩阵 $\\mathbf{R} \\in \\mathbb{R}^{3 \\times 3}$ 和一个平移向量 $\\mathbf{t} \\in \\mathbb{R}^{3}$ 定义，以及欧几里得范数 $\\|\\cdot\\|_2$。\n- 圆上周期性角度差的定义，使用一个以 $2\\pi$ 为周期的环绕（wrap）操作来处理模 $2\\pi$ 的角度等价性。\n- 空间位阻冲突违规惩罚，由一个阈值距离和针对低于该阈值的距离的修正惩罚定义。\n\n你的程序必须为每个测试用例实现以下四个损失组成部分：\n\n1. Distogram 交叉熵。Distogram 是关于成对残基间距离的离散分布。给定 $K$ 个区间边界 $\\{b_0, b_1, \\dots, b_K\\}$，其中 $b_0  b_1  \\dots  b_K$，以及一个预测概率向量 $\\mathbf{p} \\in \\mathbb{R}^K$ 且满足 $\\sum_{k=0}^{K-1} p_k = 1$，通过 $k^\\star = \\max\\{k \\in \\{0,\\dots,K-1\\}: b_k \\le d\\}$ 将真实距离 $d$ 分配到区间索引 $k^\\star$，并对 $d \\ge b_K$ 的情况进行上界截断。每对的交叉熵为 $L_{\\mathrm{dist}} = -\\log p_{k^\\star}$，distogram 损失是所有对的这些值的平均值。\n\n2. Frame Aligned Point Error (FAPE)。对于一组由 $i$ 索引的点，每个点都有预测的全局坐标 $\\mathbf{x}_i^{(p)} \\in \\mathbb{R}^3$、真实的全局坐标 $\\mathbf{x}_i^{(t)} \\in \\mathbb{R}^3$、一个预测的坐标系 $(\\mathbf{R}^{(p)}, \\mathbf{t}^{(p)})$ 和一个真实的坐标系 $(\\mathbf{R}^{(t)}, \\mathbf{t}^{(t)})$，通过 $\\mathbf{y}_i^{(p)} = \\mathbf{R}^{(p)\\top}(\\mathbf{x}_i^{(p)} - \\mathbf{t}^{(p)})$ 和 $\\mathbf{y}_i^{(t)} = \\mathbf{R}^{(t)\\top}(\\mathbf{x}_i^{(t)} - \\mathbf{t}^{(t)})$ 将点转换到各自的局部坐标系中。每个点的 FAPE 为 $e_i = \\min\\{\\tau, \\|\\mathbf{y}_i^{(p)} - \\mathbf{y}_i^{(t)}\\|_2\\}$，其中截断值 $\\tau > 0$，单位为 $\\mathrm{\\AA}$。FAPE 损失是所有点的平均值 $\\overline{e}$。使用绕 $z$ 轴旋转角度 $\\phi$ 的旋转，即 $\\mathbf{R}_z(\\phi) = \\begin{bmatrix} \\cos\\phi  -\\sin\\phi  0 \\\\ \\sin\\phi  \\cos\\phi  0 \\\\ 0  0  1 \\end{bmatrix}$。\n\n3. 扭转角损失。对于预测的扭转角 $\\theta_j^{(p)}$ 和真实的扭转角 $\\theta_j^{(t)}$（均以弧度为单位），计算环绕差 $\\Delta\\theta_j = \\mathrm{wrap}(\\theta_j^{(p)} - \\theta_j^{(t)})$，其中 $\\mathrm{wrap}(\\alpha) = ((\\alpha + \\pi) \\bmod 2\\pi) - \\pi$。每个角度的损失为 $1 - \\cos(\\Delta\\theta_j)$，扭转角损失是所有角度的平均值。\n\n4. 违规惩罚。对于预测的非键合对距离 $d_{ij} \\in \\mathbb{R}_{\\ge 0}$ 和一个以 $\\mathrm{\\AA}$ 为单位的阈值 $r_{\\mathrm{th}} > 0$，定义每对的惩罚为 $v_{ij} = \\max\\{0, r_{\\mathrm{th}} - d_{ij}\\}^2$。对所有满足 $i  j$ 的非键合对，违规损失是这些惩罚的平均值。\n\n量纲和加权：\n- 将 FAPE 损失除以特征长度 $\\ell = 10\\,\\mathrm{\\AA}$ 进行无量纲化。\n- 将违规损失除以 $\\ell^2$ 进行无量纲化。\n- Distogram 损失和扭转角损失本身是无量纲的。\n- 通过一个自适应的、归一化的逆损失加权方案来组合这四个无量纲分量。对于无量纲损失分量 $L_1, L_2, L_3, L_4$，权重 $w_i$ 计算如下：\n$$\n\\tilde{w}_i = \\frac{1}{\\varepsilon + L_i}, \\quad w_i = \\frac{\\tilde{w}_i}{\\sum_{j=1}^{4} \\tilde{w}_j}\n$$\n其中 $\\varepsilon = 10^{-8}$ 是一个小的数值稳定常数。\n- 复合损失是 $L_{\\mathrm{comp}} = \\sum_i w_i L_i$。\n\n测试套件和输出：\n- 您的程序必须使用以下三个测试用例。每个测试用例都包含 distogram、FAPE、扭转角和违规惩罚的输入。\n  - 测试用例1（典型情况）：...\n  - 测试用例2（边界包装和截断情况）：...\n  - 测试用-例3（均匀分布、无FAPE/扭转角误差、严重碰撞）：...\n- 对于每个测试用例，计算并输出复合损失 $L_{\\mathrm{comp}}$。\n- 最终输出必须是一行，其中包含一个用方括号括起来的逗号分隔的复合损失值列表。\n\n交付内容：\n- 一个完整的、可运行的Python 3程序，它精确地实现了上述过程，处理所有测试用例，并打印单行输出。", "solution": "该问题要求构建并实现一个用于蛋白质结构预测的复合损失函数，它包含四个不同的组成部分：distogram 交叉熵损失、Frame Aligned Point Error (FAPE)、扭转角损失和空间位阻违规惩罚。解决方案涉及按照规定细致地实现每个组件，通过一个有原则的无量纲化方案确保量纲一致性，并最终使用自适应加权机制将它们组合起来。\n\n首先，我们定义并实现四个损失分量中的每一个。所有距离以埃（$\\mathrm{\\AA}$）为单位，角度以弧度为单位，对数为自然对数。\n\n1.  **Distogram 交叉熵 ($L_{\\mathrm{dist}}$)**：该分量衡量预测的残基间距离概率分布的误差。Distogram 是一组距离区间上的离散概率分布。给定由 $K+1$ 个边界 $\\{b_0, b_1, \\dots, b_K\\}$ 定义的 $K$ 个区间，一个真实距离 $d$ 被分配到一个特定的区间 $k^\\star$。问题将区间索引定义为 $k^\\star = \\max\\{k \\in \\{0, \\dots, K-1\\} : b_k \\le d\\}$。这个规则能正确处理所有情况，包括将距离 $d \\ge b_K$ 截断到最后一个区间 $k^\\star = K-1$，因为对于这样的 $d$，所有 $k \\le K-1$ 都满足 $b_k \\le d$。对于一个预测的概率向量 $\\mathbf{p} = (p_0, \\dots, p_{K-1})$，单个蛋白质残基对的交叉熵损失由真实区间的负对数概率给出：\n    $$L_{\\mathrm{dist}}^{\\mathrm{(pair)}} = -\\log p_{k^\\star}$$\n    这个损失本身是无量纲的。总的 distogram 损失 $L_{\\mathrm{dist}}$ 是这些单个配对损失在蛋白质中所有相关残基对上的算术平均值。\n\n2.  **Frame Aligned Point Error (FAPE)**：FAPE 通过测量原子预测的三维坐标在局部参考系内与真实坐标的偏差来量化误差。对于每个残基，由一个旋转矩阵 $\\mathbf{R} \\in \\mathbb{R}^{3 \\times 3}$ 和一个平移向量 $\\mathbf{t} \\in \\mathbb{R}^{3}$ 定义一个刚体坐标系。给定一组由 $i$ 索引的原子，设其预测和真实的全局坐标分别为 $\\mathbf{x}_i^{(p)}$ 和 $\\mathbf{x}_i^{(t)}$，对应的预测和真实局部坐标系为 $(\\mathbf{R}^{(p)}, \\mathbf{t}^{(p)})$ 和 $(\\mathbf{R}^{(t)}, \\mathbf{t}^{(t)})$。首先将坐标转换到它们各自的局部坐标系中：\n    $$ \\mathbf{y}_i^{(p)} = \\mathbf{R}^{(p)\\top}(\\mathbf{x}_i^{(p)} - \\mathbf{t}^{(p)}) $$\n    $$ \\mathbf{y}_i^{(t)} = \\mathbf{R}^{(t)\\top}(\\mathbf{x}_i^{(t)} - \\mathbf{t}^{(t)}) $$\n    点 $i$ 的误差是这些局部坐标之间的欧几里得距离，并在最大值 $\\tau$ 处进行截断，以防止单个大误差产生过大的梯度。\n    $$ e_i = \\min\\left\\{\\tau, \\|\\mathbf{y}_i^{(p)} - \\mathbf{y}_i^{(t)}\\|_2\\right\\} $$\n    总 FAPE 损失表示为 $\\overline{e}$，是这些误差 $e_i$ 在所有考虑点上的平均值。该损失的单位是距离（$\\mathrm{\\AA}$）。旋转矩阵由给定的绕 $z$ 轴的旋转角 $\\phi$ 生成，即 $\\mathbf{R}_z(\\phi)$。\n\n3.  **扭转角损失 ($L_{\\mathrm{tors}}$)**：该损失衡量预测的主链和侧链扭转角与其真实值的偏差。由于角度是周期性的，简单的差值是不够的。我们计算每个角度 $j$ 在圆上的周期性差异 $\\Delta\\theta_j$，即预测角度 $\\theta_j^{(p)}$ 和真实角度 $\\theta_j^{(t)}$ 之间的差异：\n    $$ \\Delta\\theta_j = \\mathrm{wrap}(\\theta_j^{(p)} - \\theta_j^{(t)}) $$\n    其中环绕函数 $\\mathrm{wrap}$ 通过 $\\mathrm{wrap}(\\alpha) = ((\\alpha + \\pi) \\bmod 2\\pi) - \\pi$ 将其参数映射到区间 $[-\\pi, \\pi]$。一个合适的损失函数，它在 $\\Delta\\theta_j=0$ 时最小，在 $\\Delta\\theta_j=\\pm\\pi$ 时最大，并且是平滑的，即 $1 - \\cos(\\Delta\\theta_j)$。总扭转角损失 $L_{\\mathrm{tors}}$ 是这些值在所有角度 $j$ 上的平均值：\n    $$ L_{\\mathrm{tors}} = \\frac{1}{J} \\sum_{j=1}^{J} \\left(1 - \\cos(\\Delta\\theta_j)\\right) $$\n    这个量是无量纲的。\n\n4.  **违规惩罚 ($L_{\\mathrm{viol}}$)**：该项惩罚物理上不切实际的结构，特别是非键合原子之间距离过近的空间位阻冲突。对于每一对非键合原子 $(i, j)$，如果它们的预测距离 $d_{ij}$ 小于指定的阈值 $r_{\\mathrm{th}}$，则会产生惩罚。惩罚被定义为一个修正的二次函数：\n    $$ v_{ij} = \\max\\{0, r_{\\mathrm{th}} - d_{ij}\\}^2 $$\n    这样可以更严厉地惩罚较小的距离，并提供平滑的梯度。总违规损失 $L_{\\mathrm{viol}}$ 是这些惩罚在所有唯一的非键合对 $(i, j)$（其中 $i  j$）上的平均值。该损失的单位是距离的平方（$\\mathrm{\\AA}^2$）。\n\n为了将这些异构的损失分量组合成一个单一的标量值，我们首先要确保它们的量纲一致。FAPE 损失 $\\overline{e}$ 和违规损失 $L_{\\mathrm{viol}}$ 分别通过除以一个特征长度尺度 $\\ell = 10\\,\\mathrm{\\AA}$ 及其平方来进行无量纲化。四个无量纲的损失分量是：\n$$ L_1 = L_{\\mathrm{dist}} \\quad (\\text{无量纲}) $$\n$$ L_2 = \\overline{e} / \\ell \\quad (\\text{无量纲}) $$\n$$ L_3 = L_{\\mathrm{tors}} \\quad (\\text{无量纲}) $$\n$$ L_4 = L_{\\mathrm{viol}} / \\ell^2 \\quad (\\text{无量纲}) $$\n然后采用一种自适应加权方案来平衡它们的贡献。权重 $w_i$ 被设计为与其对应的损失分量 $L_i$ 的大小成反比，确保损失值较小的分量（表明在该方面的预测较好）不会被忽略。权重的计算方式如下：\n$$ \\tilde{w}_i = \\frac{1}{\\varepsilon + L_i}, \\quad w_i = \\frac{\\tilde{w}_i}{\\sum_{j=1}^{4} \\tilde{w}_j} $$\n在这里，$L_i$ 代表当前数据样本中相应分量的平均值，$\\varepsilon = 10^{-8}$ 是一个小数常量，用于确保当某个损失分量为零或非常接近零时的数值稳定性。最终的复合损失 $L_{\\mathrm{comp}}$ 是无量纲分量的加权和：\n$$ L_{\\mathrm{comp}} = \\sum_{i=1}^{4} w_i L_i $$\n这种表述方式为训练蛋白质结构预测模型创建了一个平衡且量纲正确的目标函数。提供的程序为三个不同的测试用例实现了这些计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a composite loss for protein structure prediction based on the problem statement.\n    The composite loss is a weighted sum of four components: distogram cross-entropy,\n    Frame Aligned Point Error (FAPE), torsion angle loss, and a violation penalty.\n    \"\"\"\n\n    # --- Constants specified in the problem ---\n    L_SCALE = 10.0  # Characteristic length scale l in Angstroms\n    TAU = 10.0      # FAPE clamp value in Angstroms\n    EPSILON = 1e-8  # Stability constant for weighting\n\n    # --- Test Cases ---\n    test_cases = [\n        {\n            # Case 1 (typical)\n            \"distogram\": {\n                \"bin_edges\": np.array([0, 4, 8, 12, 16], dtype=float),\n                \"true_dists\": np.array([5.2, 8.7, 12.0]),\n                \"pred_probs\": np.array([\n                    [0.05, 0.80, 0.10, 0.05],\n                    [0.10, 0.10, 0.70, 0.10],\n                    [0.05, 0.15, 0.20, 0.60]\n                ])\n            },\n            \"fape\": {\n                \"phi_p\": 0.1, \"t_p\": np.array([0.0, 0.0, 0.0]),\n                \"phi_t\": 0.2, \"t_t\": np.array([0.1, -0.1, 0.0]),\n                \"x_p\": np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]),\n                \"x_t\": np.array([[1.1, -0.1, 0.0], [0.1, 0.9, 0.0]])\n            },\n            \"torsion\": {\n                \"theta_p\": np.array([-2.9, 1.5, 3.1]),\n                \"theta_t\": np.array([-3.0, 1.4, -3.05])\n            },\n            \"violation\": {\n                \"dist_matrix\": np.array([[0, 3.8, 2.9], [3.8, 0, 5.2], [2.9, 5.2, 0]]),\n                \"r_th\": 3.2\n            }\n        },\n        {\n            # Case 2 (boundary wrapping and clamp)\n            \"distogram\": {\n                \"bin_edges\": np.array([0, 4, 8, 12, 16], dtype=float),\n                \"true_dists\": np.array([15.9, 0.5, 20.0]),\n                \"pred_probs\": np.array([\n                    [0.25, 0.25, 0.25, 0.25],\n                    [0.90, 0.05, 0.03, 0.02],\n                    [0.05, 0.05, 0.05, 0.85]\n                ])\n            },\n            \"fape\": {\n                \"phi_p\": 0.0, \"t_p\": np.array([0.0, 0.0, 0.0]),\n                \"phi_t\": 0.0, \"t_t\": np.array([20.0, 0.0, 0.0]),\n                \"x_p\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0]]),\n                \"x_t\": np.array([[20.0, 0.0, 0.0], [21.0, 0.0, 0.0]])\n            },\n            \"torsion\": {\n                \"theta_p\": np.array([-np.pi + 0.01, np.pi - 0.02, 0.0]),\n                \"theta_t\": np.array([np.pi - 0.01, -np.pi + 0.02, 0.0])\n            },\n            \"violation\": {\n                \"dist_matrix\": np.array([[0, 3.2, 3.2], [3.2, 0, 3.2], [3.2, 3.2, 0]]),\n                \"r_th\": 3.2\n            }\n        },\n        {\n            # Case 3 (uniform distogram, no FAPE/torsion error, severe clashes)\n            \"distogram\": {\n                \"bin_edges\": np.array([0, 4, 8, 12, 16], dtype=float),\n                \"true_dists\": np.array([7.0, 7.0, 7.0]),\n                \"pred_probs\": np.array([\n                    [0.25, 0.25, 0.25, 0.25],\n                    [0.25, 0.25, 0.25, 0.25],\n                    [0.25, 0.25, 0.25, 0.25]\n                ])\n            },\n            \"fape\": {\n                \"phi_p\": 0.5, \"t_p\": np.array([1.0, -1.0, 0.0]),\n                \"phi_t\": 0.5, \"t_t\": np.array([1.0, -1.0, 0.0]),\n                \"x_p\": np.array([[2.0, 0.0, 0.0], [0.0, 2.0, 0.0]]),\n                \"x_t\": np.array([[2.0, 0.0, 0.0], [0.0, 2.0, 0.0]])\n            },\n            \"torsion\": {\n                \"theta_p\": np.array([0.5, -1.0, 2.0]),\n                \"theta_t\": np.array([0.5, -1.0, 2.0])\n            },\n            \"violation\": {\n                \"dist_matrix\": np.array([[0, 2.0, 2.0], [2.0, 0, 2.0], [2.0, 2.0, 0]]),\n                \"r_th\": 3.5\n            }\n        }\n    ]\n\n    results = []\n    \n    # --- Helper functions for loss components ---\n    \n    def _calculate_distogram_loss(bin_edges, true_dists, pred_probs):\n        losses = []\n        num_bins = len(pred_probs[0])\n        bin_indices = bin_edges[:num_bins]\n        for d, p in zip(true_dists, pred_probs):\n            # Find bin index k_star = max{k in {0..K-1}: b_k = d}\n            valid_indices = np.where(bin_indices = d)[0]\n            k_star = np.max(valid_indices)\n            loss = -np.log(p[k_star])\n            losses.append(loss)\n        return np.mean(losses) if losses else 0.0\n\n    def _calculate_fape_loss(phi_p, t_p, phi_t, t_t, x_p, x_t):\n        # Rotation matrix for rotation about z-axis\n        def get_rot_mat(phi):\n            c_phi, s_phi = np.cos(phi), np.sin(phi)\n            return np.array([\n                [c_phi, -s_phi, 0],\n                [s_phi,  c_phi, 0],\n                [0,          0, 1]\n            ])\n\n        R_p = get_rot_mat(phi_p)\n        R_t = get_rot_mat(phi_t)\n\n        errors = []\n        for i in range(len(x_p)):\n            y_p = R_p.T @ (x_p[i] - t_p)\n            y_t = R_t.T @ (x_t[i] - t_t)\n            dist = np.linalg.norm(y_p - y_t)\n            error = min(TAU, dist)\n            errors.append(error)\n        return np.mean(errors) if errors else 0.0\n\n    def _calculate_torsion_loss(theta_p, theta_t):\n        diff = theta_p - theta_t\n        # Wrap difference to [-pi, pi]\n        wrapped_diff = (diff + np.pi) % (2 * np.pi) - np.pi\n        losses = 1 - np.cos(wrapped_diff)\n        return np.mean(losses) if len(losses) > 0 else 0.0\n\n    def _calculate_violation_loss(dist_matrix, r_th):\n        penalties = []\n        num_atoms = dist_matrix.shape[0]\n        for i in range(num_atoms):\n            for j in range(i + 1, num_atoms):\n                d_ij = dist_matrix[i, j]\n                penalty = max(0, r_th - d_ij)**2\n                penalties.append(penalty)\n        return np.mean(penalties) if penalties else 0.0\n\n    # --- Main computation loop ---\n    for case in test_cases:\n        # Calculate individual loss components\n        l_dist = _calculate_distogram_loss(**case[\"distogram\"])\n        e_bar = _calculate_fape_loss(**case[\"fape\"])\n        l_tors = _calculate_torsion_loss(**case[\"torsion\"])\n        l_viol = _calculate_violation_loss(**case[\"violation\"])\n        \n        # Nondimensionalize\n        L1 = l_dist\n        L2 = e_bar / L_SCALE\n        L3 = l_tors\n        L4 = l_viol / (L_SCALE**2)\n        \n        losses = np.array([L1, L2, L3, L4])\n        \n        # Calculate adaptive weights\n        unnorm_weights = 1.0 / (EPSILON + losses)\n        sum_unnorm_weights = np.sum(unnorm_weights)\n        weights = unnorm_weights / sum_unnorm_weights\n        \n        # Calculate composite loss\n        composite_loss = np.sum(weights * losses)\n        results.append(composite_loss)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3842267"}, {"introduction": "在输出最终的三维坐标之前，许多模型会先生成一个中间表征，例如残基接触图。准确评估这些中间预测的质量对于模型开发至关重要。本练习将重点介绍如何计算接触图预测的关键精度指标，展示它们如何揭示模型在不同方面的性能，尤其是在识别决定折叠核心的长程相互作用方面的能力。[@problem_id:4554940]", "problem": "您的任务是编写一个程序，以评估蛋白质的预测残基-残基接触。评估需采用结构预测中使用的基于排序的指标。评估必须计算在$L$处的精确率、在$L/2$处的精确率以及前$L$个长程接触的精确率，然后对这些指标之间的差异进行数值解释。评估必须遵循分类指标和排序选择的基本原则，并基于结构生物信息学和统计学习理论中的定义。您必须精确地实现以下定义和规则。\n\n定义和假设：\n- 长度为$L$的蛋白质序列会产生一组可能的残基-残基对$(i,j)$，其中$1 \\le i  j \\le L$。真实接触以索引对的基准真相集（ground-truth set）形式给出。预测接触以带有实值置信度分数的排序对列表形式给出。索引是基于1的。为进行评估，通过在候选空间中要求$j-i \\ge 2$来排除直接相邻的残基。\n- 对于大小为$k$的选定预测集，精确率定义为\n$$\n\\mathrm{Precision} = \\frac{\\text{真阳性（true positives）的数量}}{k},\n$$\n约定当$k=0$时，精确率为$0.0$。\n- 在$L$处的精确率定义为：从长度为$N_{\\mathrm{pred}}$的完整预测列表中按分数降序取前$k=\\min(L, N_{\\mathrm{pred}})$个预测对，并计算这$k$个对的精确率。\n- 在$L/2$处的精确率定义为：取前$k=\\min(\\lfloor L/2 \\rfloor, N_{\\mathrm{pred}})$个预测对，并计算这$k$个对的精确率。\n- 长程接触是指序列间隔$\\Delta = |j-i| \\ge s$的接触，其中$s$是长程间隔阈值。对于前$L$个长程接触的精确率，仅考虑预测对中的长程接触，保持其原始排序顺序，从中选择前$k=\\min(L, N_{\\mathrm{pred,long}})$个，并计算这$k$个对的精确率。如果$N_{\\mathrm{pred,long}}=0$，则定义精确率为$0.0$。\n\n排序规则和并列处理：\n- 预测对按其分数降序排列。在分数相同时，通过$(i,j)$的字典升序来确定性地打破并列。这保证了全序关系，并使评估可复现。\n\n解释规则：\n- 令$P_L$表示在$L$处的精确率，$P_{L/2}$表示在$L/2$处的精确率，$P_{L,\\mathrm{long}}$表示前$L$个长程接触的精确率。定义差异$D_{12} = P_{L/2} - P_L$和$D_{\\mathrm{long}} = P_{L,\\mathrm{long}} - P_L$。使用容差$\\epsilon = 0.05$进行以下二元解释：\n  - 排序改善标志：如果$D_{12} \\ge \\epsilon$，则$\\mathrm{rank\\_good} = \\mathrm{True}$，否则为$\\mathrm{False}$。\n  - 长程弱点标志：如果$P_{L,\\mathrm{long}} \\le P_L - \\epsilon$，则$\\mathrm{long\\_weak} = \\mathrm{True}$，否则为$\\mathrm{False}$。\n\n用于生成预测列表的评分函数：\n- 测试套件中使用两种分数定义。\n  - 扰动间隔分数：对于一对$(i,j)$，其中$j-i \\ge 2$，\n  $$\n  S_{\\mathrm{pert}}(i,j) = \\frac{1}{1 + (j - i)} + 0.0001 \\cdot (i + j).\n  $$\n  - 普通间隔分数（以引发并列）：对于一对$(i,j)$，其中$j-i \\ge 2$，\n  $$\n  S_{\\mathrm{plain}}(i,j) = \\frac{1}{1 + (j - i)}.\n  $$\n- 对于给定的序列长度$L$和请求的预测数量$N_{\\mathrm{pred}}$，生成所有满足$1 \\le i  j \\le L$和$j-i \\ge 2$的候选对$(i,j)$，通过所选的评分函数计算分数，按分数降序（字典序打破并列）排序，并取前$N_{\\mathrm{pred}}$对作为预测的排序列表。\n\n每个测试用例的基准真相生成规则：\n- 对于每个测试用例，基准真相接触集是以下两者的并集：\n  - 一个规则模式：对于指定列表$\\mathcal{I}$中的每个$i$和指定集合$\\mathcal{D}$中的每个偏移量$d$，如果$i+d \\le L$，则包含$(i, i+d)$，以及\n  - 一组显式指定的额外对$\\mathcal{E}$，其中每一对都必须满足$1 \\le i  j \\le L$。\n- 这样可以得到一个定义明确的二元接触图，而无需涉及物理单位。\n\n角度单位和物理单位不适用于此问题。不得使用百分比；将所有精确率报告为0到1之间的小数。\n\n测试套件：\n精确实现以下3个测试用例。对于每个测试，使用长程间隔阈值$s=24$和候选对排除规则$j-i \\ge 2$。\n\n- 测试用例1（存在长程阳性样本的顺利路径）：\n  - $L = 28$, $N_{\\mathrm{pred}} = 120$，评分函数$S_{\\mathrm{pert}}$。\n  - 基准真相：\n    - $\\mathcal{I} = \\{2,4,6,8,10,12,14,16,18,20\\}$,\n    - $\\mathcal{D} = \\{3,4,5\\}$,\n    - $\\mathcal{E} = \\{(1,25),(2,27),(3,27),(4,28)\\}$。\n\n- 测试用例2（预测数量少于$L$且无长程接触可用的边界情况）：\n  - $L = 20$, $N_{\\mathrm{pred}} = 8$，评分函数$S_{\\mathrm{pert}}$。\n  - 基准真相：\n    - $\\mathcal{I} = \\{1,6,11\\}$,\n    - $\\mathcal{D} = \\{2,3\\}$,\n    - $\\mathcal{E} = \\emptyset$。\n\n- 测试用例3（因普通间隔分数导致分数并列）：\n  - $L = 30$, $N_{\\mathrm{pred}} = 40$，评分函数$S_{\\mathrm{plain}}$。\n  - 基准真相：\n    - $\\mathcal{I} = \\{4,6,8,10,12,14,16,18\\}$,\n    - $\\mathcal{D} = \\{2,3\\}$,\n    - $\\mathcal{E} = \\{(1,25),(2,26)\\}$。\n\n要求输出：\n- 对于每个测试用例，计算并按确切顺序输出一个列表：\n$$\n\\left[P_L,\\; P_{L/2},\\; P_{L,\\mathrm{long}},\\; D_{12},\\; D_{\\mathrm{long}},\\; \\mathrm{rank\\_good},\\; \\mathrm{long\\_weak}\\right].\n$$\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的元素本身也是一个按上述顺序排列的列表。例如，输出格式必须如下所示：\n$$\n\\big[ [\\ldots], [\\ldots], [\\ldots] \\big].\n$$\n- 将浮点值表示为四舍五入到6位小数的小数，布尔值表示为字面量True或False。打印的行不得包含任何其他文本。\n\n交付内容：\n- 提供一个完整的、可运行的程序，该程序按照指定的方式构建预测列表和基准真相，为每个测试用例计算所需的指标和解释标志，并按要求的格式打印聚合的单行输出。", "solution": "该问题要求实现一个验证程序，用于根据基准真相（ground truth）评估预测的蛋白质残基-残基接触。该过程涉及计算三个基于排序的精确率指标，然后对其差异进行数值解释。整个过程是算法性的，对于生成输入（基准真相、排序后的预测）和计算输出（指标、解释标志）都有精确的定义。解决方案将通过严格遵循这些定义来得出。\n\n首先，我们形式化生成基准真相接触集的过程。对于长度为$L$的蛋白质，基准真相集$\\mathcal{T}$被构建为两组对$(i,j)$的并集：\n1. 源自规则模式的集合：$\\mathcal{T}_{\\mathrm{pattern}} = \\{(i, i+d) \\mid i \\in \\mathcal{I}, d \\in \\mathcal{D}, 1 \\le i  i+d \\le L\\}$。\n2. 显式提供的对的集合：$\\mathcal{T}_{\\mathrm{extra}} = \\mathcal{E}$。\n完整的基准真相集是$\\mathcal{T} = \\mathcal{T}_{\\mathrm{pattern}} \\cup \\mathcal{T}_{\\mathrm{extra}}$。为提高计算效率，此集合最好存储在哈希集数据结构中，以实现常数时间查找。\n\n其次，我们形式化生成预测接触的排序列表的过程。这包括三个步骤：\n1.  **候选生成**：所有可能的候选对$(i,j)$的空间由约束条件$1 \\le i  j \\le L$和最小序列间隔（指定为$j-i \\ge 2$）定义。\n2.  **评分**：使用两个提供的函数之一为每个候选对分配分数：\n    *   扰动间隔分数：$S_{\\mathrm{pert}}(i,j) = \\frac{1}{1 + (j - i)} + 0.0001 \\cdot (i + j)$。\n    *   普通间隔分数：$S_{\\mathrm{plain}}(i,j) = \\frac{1}{1 + (j - i)}$。\n3.  **排序和选择**：所有候选对根据一个严格的规则进行排序：主要按其分数的降序，其次（为打破并列）按对$(i,j)$的字典升序。从这个完全排序的列表中，选择前$N_{\\mathrm{pred}}$个对，形成最终的预测排序列表，我们将其表示为$\\mathcal{P}$。\n\n第三，我们根据排序列表$\\mathcal{P}$和基准真相集$\\mathcal{T}$计算所需的精确率指标。对于$k$个预测的选择集，精确率定义为$P = \\mathrm{TP}/k$，其中$\\mathrm{TP}$是选择集中真阳性（即在$\\mathcal{T}$中的预测）的数量。如果$k=0$，则$P=0.0$。\n\n*   **在$L$处的精确率，$P_L$**：\n    需要考虑的预测数量是$k_L = \\min(L, N_{\\mathrm{pred}})$。我们从$\\mathcal{P}$中选择前$k_L$个对。设该子集为$\\mathcal{P}_L$。真阳性的数量是$\\mathrm{TP}_L = |\\mathcal{P}_L \\cap \\mathcal{T}|$。精确率是$P_L = \\mathrm{TP}_L / k_L$，特殊情况是如果$k_L=0$，则$P_L=0.0$。\n\n*   **在$L/2$处的精确率，$P_{L/2}$**：\n    需要考虑的预测数量是$k_{L/2} = \\min(\\lfloor L/2 \\rfloor, N_{\\mathrm{pred}})$。我们从$\\mathcal{P}$中选择前$k_{L/2}$个对。设该子集为$\\mathcal{P}_{L/2}$。真阳性的数量是$\\mathrm{TP}_{L/2} = |\\mathcal{P}_{L/2} \\cap \\mathcal{T}|$。精确率是$P_{L/2} = \\mathrm{TP}_{L/2} / k_{L/2}$，如果$k_{L/2}=0$，则$P_{L/2}=0.0$。\n\n*   **前$L$个长程接触的精确率，$P_{L,\\mathrm{long}}$**：\n    该指标涉及预测的一个过滤子集。如果一对$(i,j)$的序列间隔$|j-i|$大于或等于阈值$s$，则定义其为长程接触。\n    1.  首先，我们过滤原始排序列表$\\mathcal{P}$，创建一个新列表$\\mathcal{P}_{\\mathrm{long}}$，其中仅包含长程对，同时保留它们的相对排序顺序。设此列表的大小为$N_{\\mathrm{pred,long}} = |\\mathcal{P}_{\\mathrm{long}}|$。\n    2.  如果$N_{\\mathrm{pred,long}} = 0$，则精确率$P_{L,\\mathrm{long}}$定义为$0.0$。\n    3.  否则，需要考虑的预测数量是$k_{L,\\mathrm{long}} = \\min(L, N_{\\mathrm{pred,long}})$。我们从$\\mathcal{P}_{\\mathrm{long}}$中选择前$k_{L,\\mathrm{long}}$个对。设该子集为$\\mathcal{P}_{L,\\mathrm{long}}^{\\text{top}}$。真阳性的数量是$\\mathrm{TP}_{L,\\mathrm{long}} = |\\mathcal{P}_{L,\\mathrm{long}}^{\\text{top}} \\cap \\mathcal{T}|$。精确率是$P_{L,\\mathrm{long}} = \\mathrm{TP}_{L,\\mathrm{long}} / k_{L,\\mathrm{long}}$。\n\n第四，我们根据计算出的精确率值和给定的容差$\\epsilon = 0.05$推导解释标志。\n*   差异$D_{12} = P_{L/2} - P_L$衡量了真阳性在排序最顶端的集中程度。如果$D_{12} \\ge \\epsilon$，则`rank_good`标志设置为True，表示在被评估集的上半部分具有显著更高的精确率。\n*   差异$D_{\\mathrm{long}} = P_{L,\\mathrm{long}} - P_L$比较了在长程接触上的性能与整体性能。如果$P_{L,\\mathrm{long}} \\le P_L - \\epsilon$，则`long_weak`标志设置为True，表明模型在通常更难预测的长程接触上的准确性显著低于其整体准确性。\n\n最后，对于每个测试用例，我们将结果组合成一个列表：$[P_L, P_{L/2}, P_{L,\\mathrm{long}}, D_{12}, D_{\\mathrm{long}}, \\mathrm{rank\\_good}, \\mathrm{long\\_weak}]$。这些值按指定格式进行格式化（浮点数四舍五入到6位小数，布尔值为字面量）。对所有测试用例重复此过程，并将结果列表汇总成一个最终的列表之列表作为输出。这种对给定规则的结构化、分步应用确保了解决方案的正确性和可复现性。\n\n实现将通过以下步骤处理每个测试用例：\n1.  接收参数：$L, N_{\\mathrm{pred}}$、评分函数类型、基准真相规则$(\\mathcal{I}, \\mathcal{D}, \\mathcal{E})$以及常量$s=24$。\n2.  执行基准真相的构建。\n3.  执行排序列表的生成。\n4.  执行$P_L, P_{L/2}, P_{L,\\mathrm{long}}$的计算。\n5.  计算差异和解释标志。\n6.  返回格式化的结果列表。\n该过程直接映射到一个计算算法，可以在指定的Python环境中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the evaluation of the test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 28, \"N_pred\": 120, \"scoring\": \"S_pert\",\n            \"I_list\": [2, 4, 6, 8, 10, 12, 14, 16, 18, 20],\n            \"D_list\": [3, 4, 5],\n            \"E_list\": [(1, 25), (2, 27), (3, 27), (4, 28)]\n        },\n        {\n            \"L\": 20, \"N_pred\": 8, \"scoring\": \"S_pert\",\n            \"I_list\": [1, 6, 11],\n            \"D_list\": [2, 3],\n            \"E_list\": []\n        },\n        {\n            \"L\": 30, \"N_pred\": 40, \"scoring\": \"S_plain\",\n            \"I_list\": [4, 6, 8, 10, 12, 14, 16, 18],\n            \"D_list\": [2, 3],\n            \"E_list\": [(1, 25), (2, 26)]\n        }\n    ]\n\n    s_threshold = 24\n    epsilon = 0.05\n    \n    results = []\n    for case in test_cases:\n        result = evaluate_case(\n            L=case[\"L\"],\n            N_pred=case[\"N_pred\"],\n            score_func_name=case[\"scoring\"],\n            I_list=case[\"I_list\"],\n            D_list=case[\"D_list\"],\n            E_list=case[\"E_list\"],\n            s=s_threshold,\n            epsilon=epsilon\n        )\n        results.append(result)\n\n    # Format the final output string.\n    # The string representation of list in python is what we need.\n    # For floats, we need 6 decimal places.\n    # For booleans, True/False literals are standard.\n    def format_list(lst):\n        formatted_items = []\n        for item in lst:\n            if isinstance(item, float):\n                # Use format specifier to round correctly to 6 decimal places\n                formatted_items.append(f\"{item:.6f}\")\n            else:\n                formatted_items.append(str(item))\n        return f\"[{','.join(formatted_items)}]\"\n\n    output_str = f\"[{','.join(map(format_list, results))}]\"\n    print(output_str)\n\n\ndef evaluate_case(L, N_pred, score_func_name, I_list, D_list, E_list, s, epsilon):\n    \"\"\"\n    Performs the full evaluation for a single test case.\n    \"\"\"\n    # Step 1: Generate Ground Truth Set\n    true_contacts = set()\n    for i in I_list:\n        for d in D_list:\n            if i + d = L:\n                true_contacts.add((i, i + d))\n    true_contacts.update(E_list)\n\n    # Step 2: Generate Predicted Contact List\n    def s_pert(i, j):\n        return 1.0 / (1.0 + (j - i)) + 0.0001 * (i + j)\n\n    def s_plain(i, j):\n        return 1.0 / (1.0 + (j - i))\n\n    score_func = s_pert if score_func_name == \"S_pert\" else s_plain\n\n    # Generate all candidate pairs with their scores\n    candidate_pairs_with_scores = []\n    for i in range(1, L):\n        for j in range(i + 2, L + 1):\n            score = score_func(i, j)\n            # Use tuple for sorting: (-score, i, j) ensures descending score\n            # and ascending lexicographic (i, j) for tie-breaking.\n            candidate_pairs_with_scores.append((-score, i, j))\n\n    # Sort candidates\n    candidate_pairs_with_scores.sort()\n\n    # Select top N_pred predictions\n    predicted_list = [(i, j) for neg_score, i, j in candidate_pairs_with_scores[:N_pred]]\n\n    # Step 3: Calculate Metrics\n    \n    def calculate_precision(selected_predictions, true_contacts_set):\n        k = len(selected_predictions)\n        if k == 0:\n            return 0.0\n        tp = sum(1 for pred in selected_predictions if pred in true_contacts_set)\n        return tp / k\n\n    # P_L\n    k_L = min(L, N_pred)\n    top_L_preds = predicted_list[:k_L]\n    P_L = calculate_precision(top_L_preds, true_contacts)\n\n    # P_{L/2}\n    k_L_half = min(L // 2, N_pred)\n    top_L_half_preds = predicted_list[:k_L_half]\n    P_L_half = calculate_precision(top_L_half_preds, true_contacts)\n\n    # P_{L, long}\n    long_range_predicted_list = [(i, j) for i, j in predicted_list if (j - i) >= s]\n    N_pred_long = len(long_range_predicted_list)\n    \n    P_L_long = 0.0\n    if N_pred_long > 0:\n        k_L_long = min(L, N_pred_long)\n        top_L_long_preds = long_range_predicted_list[:k_L_long]\n        P_L_long = calculate_precision(top_L_long_preds, true_contacts)\n\n    # Step 4: Interpretation\n    D_12 = P_L_half - P_L\n    D_long = P_L_long - P_L\n    \n    rank_good = D_12 >= epsilon\n    long_weak = P_L_long = P_L - epsilon\n\n    # Step 5: Assemble output\n    return [P_L, P_L_half, P_L_long, D_12, D_long, rank_good, long_weak]\n\nsolve()\n```", "id": "4554940"}]}