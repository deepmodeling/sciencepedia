{"hands_on_practices": [{"introduction": "零样本学习的核心在于利用共享的语义空间来连接“所见”与“未见”的类别。在罕见病诊断中，疾病与表型之间的关系构成了这样一个丰富的语义结构，通常可以用图来表示。本实践将带您探索如何使用图神经网络 (GNN) 从这种结构化知识中为疾病（包括训练中未见的疾病）生成富有表现力的向量表示（即嵌入），这是实现知识迁移的关键一步。您将通过一个微型疾病-表型图，亲手计算一层和两层 GNN 的更新过程，直观地理解网络结构如何被编码为数值化的疾病特征 [@problem_id:4618399]。", "problem": "要求您形式化并计算一个玩具（toy）疾病-表型二部图的单层和双层图神经网络（GNN）更新，以获得一个未见疾病的嵌入，并比较两种深度产生的嵌入。更广泛的背景是罕见病的零样本学习（zero-shot learning），其中未见疾病没有标签，依赖于共享的表型描述来迁移知识。该问题纯粹以线性代数和显式矩阵的形式构建，所有计算都将以数值方式进行。\n\n使用的基本基础包括以下经过充分测试的定义：由邻接矩阵编码的二部图、行归一化的邻居聚合以及修正线性单元（ReLU）非线性函数。假设有 $N_d$ 种疾病，索引为 $i \\in \\{1,\\dots,N_d\\}$，以及 $N_p$ 种表型，索引为 $j \\in \\{1,\\dots,N_p\\}$。令 $A \\in \\{0,1\\}^{N_d \\times N_p}$ 表示疾病到表型的邻接矩阵， $X_p \\in \\mathbb{R}^{N_p \\times F_p}$ 表示表型特征向量，以及 $W_1 \\in \\mathbb{R}^{F_p \\times F_o}$、$U \\in \\mathbb{R}^{F_p \\times F_h}$、$W_2 \\in \\mathbb{R}^{F_h \\times F_o}$ 表示权重矩阵。定义疾病行度矩阵 $D_d \\in \\mathbb{R}^{N_d \\times N_d}$ 为 $D_d(i,i) = \\sum_{j=1}^{N_p} A(i,j)$。定义行归一化邻接矩阵 $\\tilde{A} = D_d^{-1} A$，并约定如果 $D_d(i,i) = 0$，则 $\\tilde{A}$ 的第 $i$ 行为全零行。定义修正线性单元（ReLU）的逐元素非线性函数为 $\\sigma(x) = \\max\\{0,x\\}$。\n\n您必须实现以下更新：\n\n- 单层疾病嵌入：$H_d^{(1)} = \\sigma\\big(\\tilde{A} X_p W_1\\big)$。\n- 通过隐藏层表型转换得到的双层疾病嵌入：首先 $Z_p = \\sigma\\big(X_p U\\big)$，然后 $H_d^{(2)} = \\sigma\\big(\\tilde{A} Z_p W_2\\big)$。\n\n在零样本设置中，未见疾病没有直接的标签信息。在这个玩具（toy）设定中，我们通过不使用任何疾病特征向量，而仅依赖表型特征 $X_p$ 和图结构 $A$ 来对此进行建模。\n\n您必须使用以下方法比较单层和双层模型中固定未见疾病索引 $i^\\star$ 的嵌入：\n- 余弦相似度：$\\mathrm{cos}(a,b) = \\frac{a^\\top b}{\\lVert a\\rVert_2 \\lVert b\\rVert_2}$，并约定如果 $\\lVert a\\rVert_2 = 0$ 或 $\\lVert b\\rVert_2 = 0$，则 $\\mathrm{cos}(a,b) = 0$。\n- 欧几里得距离：$\\lVert a-b\\rVert_2$。\n\n所有运算都是纯数值的；不涉及物理单位。不出现角度，因此不需要角度单位。不出现百分比。\n\n对所有测试用例使用以下固定的维度和矩阵：\n- 疾病数量 $N_d = 3$，表型数量 $N_p = 4$，表型特征维度 $F_p = 3$，隐藏层维度 $F_h = 2$，输出维度 $F_o = 2$。\n- 表型特征 $X_p \\in \\mathbb{R}^{4 \\times 3}$：\n$$\nX_p =\n\\begin{bmatrix}\n1  0  -1 \\\\\n0.5  1  0 \\\\\n0  -0.5  1 \\\\\n1  1  1\n\\end{bmatrix}.\n$$\n- 单层权重 $W_1 \\in \\mathbb{R}^{3 \\times 2}$：\n$$\nW_1 =\n\\begin{bmatrix}\n0.5  0 \\\\\n0  1 \\\\\n-0.5  0.5\n\\end{bmatrix}.\n$$\n- 表型隐藏层权重 $U \\in \\mathbb{R}^{3 \\times 2}$：\n$$\nU =\n\\begin{bmatrix}\n1  -1 \\\\\n0.5  0 \\\\\n0  1\n\\end{bmatrix}.\n$$\n- 双层输出权重 $W_2 \\in \\mathbb{R}^{2 \\times 2}$：\n$$\nW_2 =\n\\begin{bmatrix}\n1  0.5 \\\\\n-0.5  1\n\\end{bmatrix}.\n$$\n\n将未见疾病的索引固定为 $i^\\star = 3$（即第三种疾病）。\n\n为以下包含三个邻接矩阵 $A$ 的测试套件实现上述计算：\n\n- 测试用例 1（一般情况）：\n$$\nA^{(1)} =\n\\begin{bmatrix}\n1  1  0  0 \\\\\n0  1  1  0 \\\\\n1  0  0  1\n\\end{bmatrix}.\n$$\n\n- 测试用例 2（未见疾病的单邻居边界情况）：\n$$\nA^{(2)} =\n\\begin{bmatrix}\n0  1  0  0 \\\\\n0  0  1  0 \\\\\n0  0  0  1\n\\end{bmatrix}.\n$$\n\n- 测试用例 3（边界情况：度为零的未见疾病）：\n$$\nA^{(3)} =\n\\begin{bmatrix}\n1  0  0  0 \\\\\n0  1  1  0 \\\\\n0  0  0  0\n\\end{bmatrix}.\n$$\n\n对于每个测试用例 $t \\in \\{1,2,3\\}$，计算疾病 $i^\\star$ 的单层嵌入向量 $h^{(1)}_{i^\\star} \\in \\mathbb{R}^{2}$ 和双层嵌入向量 $h^{(2)}_{i^\\star} \\in \\mathbb{R}^{2}$，然后计算：\n- $h^{(1)}_{i^\\star}$ 和 $h^{(2)}_{i^\\star}$ 之间的余弦相似度，遵循上述零范数约定。\n- $h^{(1)}_{i^\\star}$ 和 $h^{(2)}_{i^\\star}$ 之间的欧几里得距离。\n\n您的程序必须输出单行文本，该行将三个测试用例的结果聚合为一个用方括号括起来的逗号分隔列表，其中每个测试用例的结果是一个双元素列表 $[\\mathrm{cos}, \\mathrm{dist}]$，两个数字都四舍五入到 $6$ 位小数。例如，输出格式必须与 \"[$[x_1,y_1],[x_2,y_2],[x_3,y_3]$]\" 完全一样，不含空格，其中每个 $x_t$ 和 $y_t$ 都是四舍五入到 $6$ 位的小数浮点数。\n\n不需要用户输入。所有数据已在上方指定。代码必须是确定性的和自包含的。每个测试用例的输出必须是浮点数。", "solution": "该问题是有效的。它提出了一个基于图神经网络（GNN）和线性代数的既定原则的、定义明确的计算任务。所有必要的参数、矩阵和函数都已提供，确保了问题是自包含的，并允许一个唯一的、可验证的解决方案。\n\n目标是为一个由索引 $i^\\star=3$ 标识的特定“未见”疾病，计算并比较来自单层和双层GNN的疾病嵌入。GNN架构在一个连接疾病与表型的二部图上运行。其核心机制是消息传递，其中疾病节点的表示通过聚合其关联表型节点的特征向量来更新。\n\n提供了以下数据和定义：\n- 疾病数量 $N_d = 3$，表型数量 $N_p = 4$。\n- 表型特征维度 $F_p = 3$，隐藏层维度 $F_h = 2$，输出维度 $F_o = 2$。\n- 表型特征 $X_p \\in \\mathbb{R}^{4 \\times 3}$：\n$$\nX_p =\n\\begin{bmatrix}\n1  0  -1 \\\\\n0.5  1  0 \\\\\n0  -0.5  1 \\\\\n1  1  1\n\\end{bmatrix}\n$$\n- 权重矩阵 $W_1 \\in \\mathbb{R}^{3 \\times 2}$，$U \\in \\mathbb{R}^{3 \\times 2}$ 和 $W_2 \\in \\mathbb{R}^{2 \\times 2}$：\n$$\nW_1 =\n\\begin{bmatrix}\n0.5  0 \\\\\n0  1 \\\\\n-0.5  0.5\n\\end{bmatrix}, \\quad\nU =\n\\begin{bmatrix}\n1  -1 \\\\\n0.5  0 \\\\\n0  1\n\\end{bmatrix}, \\quad\nW_2 =\n\\begin{bmatrix}\n1  0.5 \\\\\n-0.5  1\n\\end{bmatrix}\n$$\n- GNN更新规则使用行归一化邻接矩阵 $\\tilde{A}=D_d^{-1}A$ 和逐元素ReLU激活函数 $\\sigma(x) = \\max\\{0,x\\}$。\n- 单层疾病嵌入：$H_d^{(1)} = \\sigma\\big(\\tilde{A} X_p W_1\\big)$。\n- 双层疾病嵌入：$H_d^{(2)} = \\sigma\\big(\\tilde{A} \\sigma(X_p U) W_2\\big)$。\n\n为了简化计算，我们可以预先计算转换后的表型特征，因为它们不依赖于邻接矩阵 $A$。\n\n对于单层模型，转换后的表型特征为 $Y_p = X_p W_1$：\n$$\nY_p = \\begin{bmatrix}\n1  0  -1 \\\\\n0.5  1  0 \\\\\n0  -0.5  1 \\\\\n1  1  1\n\\end{bmatrix}\n\\begin{bmatrix}\n0.5  0 \\\\\n0  1 \\\\\n-0.5  0.5\n\\end{bmatrix}\n= \\begin{bmatrix}\n1  -0.5 \\\\\n0.25  1 \\\\\n-0.5  0 \\\\\n0  1.5\n\\end{bmatrix}\n$$\n对于双层模型，中间隐藏层表型特征为 $Z_p = \\sigma(X_p U)$：\n$$\nX_p U = \\begin{bmatrix}\n1  0  -1 \\\\\n0.5  1  0 \\\\\n0  -0.5  1 \\\\\n1  1  1\n\\end{bmatrix}\n\\begin{bmatrix}\n1  -1 \\\\\n0.5  0 \\\\\n0  1\n\\end{bmatrix}\n= \\begin{bmatrix}\n1  -2 \\\\\n1  -0.5 \\\\\n-0.25  1 \\\\\n1.5  0\n\\end{bmatrix}\n$$\n应用ReLU激活函数，我们得到：\n$$\nZ_p = \\sigma(X_p U) =\n\\begin{bmatrix}\n1  0 \\\\\n1  0 \\\\\n0  1 \\\\\n1.5  0\n\\end{bmatrix}\n$$\n\n我们现在将对所选的疾病索引 $i^\\star = 3$ 进行每个测试用例的处理。\n\n### 测试用例 1\n邻接矩阵为 $A^{(1)} = \\begin{bmatrix} 1  1  0  0 \\\\ 0  1  1  0 \\\\ 1  0  0  1 \\end{bmatrix}$。\n疾病的度（行和）为 $d_1=2$, $d_2=2$, $d_3=2$。归一化的邻接矩阵为：\n$$\n\\tilde{A}^{(1)} = \\begin{bmatrix} 1/2  1/2  0  0 \\\\ 0  1/2  1/2  0 \\\\ 1/2  0  0  1/2 \\end{bmatrix} = \\begin{bmatrix} 0.5  0.5  0  0 \\\\ 0  0.5  0.5  0 \\\\ 0.5  0  0  0.5 \\end{bmatrix}\n$$\n疾病 $i^\\star=3$ 的嵌入由 $\\tilde{A}^{(1)}$ 的第3行确定。\n- **单层嵌入 $h^{(1)}_{3}$**：\n$$ (\\tilde{A}^{(1)} Y_p)_{3,:} = \\begin{bmatrix} 0.5  0  0  0.5 \\end{bmatrix} Y_p = 0.5 \\times \\begin{bmatrix} 1  -0.5 \\end{bmatrix} + 0.5 \\times \\begin{bmatrix} 0  1.5 \\end{bmatrix} = \\begin{bmatrix} 0.5  0.5 \\end{bmatrix} $$\n$$ h^{(1)}_{3} = \\sigma(\\begin{bmatrix} 0.5  0.5 \\end{bmatrix}) = \\begin{bmatrix} 0.5  0.5 \\end{bmatrix} $$\n- **双层嵌入 $h^{(2)}_{3}$**：\n$$ (\\tilde{A}^{(1)} Z_p)_{3,:} = \\begin{bmatrix} 0.5  0  0  0.5 \\end{bmatrix} Z_p = 0.5 \\times \\begin{bmatrix} 1  0 \\end{bmatrix} + 0.5 \\times \\begin{bmatrix} 1.5  0 \\end{bmatrix} = \\begin{bmatrix} 1.25  0 \\end{bmatrix} $$\n$$ (\\tilde{A}^{(1)} Z_p W_2)_{3,:} = \\begin{bmatrix} 1.25  0 \\end{bmatrix} W_2 = \\begin{bmatrix} 1.25  0 \\end{bmatrix} \\begin{bmatrix} 1  0.5 \\\\ -0.5  1 \\end{bmatrix} = \\begin{bmatrix} 1.25  0.625 \\end{bmatrix} $$\n$$ h^{(2)}_{3} = \\sigma(\\begin{bmatrix} 1.25  0.625 \\end{bmatrix}) = \\begin{bmatrix} 1.25  0.625 \\end{bmatrix} $$\n- **比较**：令 $a = h^{(1)}_{3}$ 和 $b = h^{(2)}_{3}$。\n    - 余弦相似度：$\\mathrm{cos}(a, b) = \\frac{a \\cdot b}{\\|a\\| \\|b\\|} = \\frac{0.5(1.25) + 0.5(0.625)}{\\sqrt{0.5^2+0.5^2}\\sqrt{1.25^2+0.625^2}} = \\frac{0.9375}{\\sqrt{0.5}\\sqrt{1.953125}} \\approx 0.948683$。\n    - 欧几里得距离：$\\|a - b\\|_2 = \\sqrt{(0.5-1.25)^2+(0.5-0.625)^2} = \\sqrt{(-0.75)^2+(-0.125)^2} = \\sqrt{0.578125} \\approx 0.760345$。\n\n### 测试用例 2\n邻接矩阵为 $A^{(2)} = \\begin{bmatrix} 0  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  1 \\end{bmatrix}$。\n疾病的度为 $d_1=1$, $d_2=1$, $d_3=1$。因此，$\\tilde{A}^{(2)} = A^{(2)}$。\n$\\tilde{A}^{(2)}$ 的第3行为 $\\begin{bmatrix} 0  0  0  1 \\end{bmatrix}$。\n- **单层嵌入 $h^{(1)}_{3}$**：\n$$ (\\tilde{A}^{(2)} Y_p)_{3,:} = \\begin{bmatrix} 0  0  0  1 \\end{bmatrix} Y_p = \\text{4th row of } Y_p = \\begin{bmatrix} 0  1.5 \\end{bmatrix} $$\n$$ h^{(1)}_{3} = \\sigma(\\begin{bmatrix} 0  1.5 \\end{bmatrix}) = \\begin{bmatrix} 0  1.5 \\end{bmatrix} $$\n- **双层嵌入 $h^{(2)}_{3}$**：\n$$ (\\tilde{A}^{(2)} Z_p)_{3,:} = \\begin{bmatrix} 0  0  0  1 \\end{bmatrix} Z_p = \\text{4th row of } Z_p = \\begin{bmatrix} 1.5  0 \\end{bmatrix} $$\n$$ (\\tilde{A}^{(2)} Z_p W_2)_{3,:} = \\begin{bmatrix} 1.5  0 \\end{bmatrix} \\begin{bmatrix} 1  0.5 \\\\ -0.5  1 \\end{bmatrix} = \\begin{bmatrix} 1.5  0.75 \\end{bmatrix} $$\n$$ h^{(2)}_{3} = \\sigma(\\begin{bmatrix} 1.5  0.75 \\end{bmatrix}) = \\begin{bmatrix} 1.5  0.75 \\end{bmatrix} $$\n- **比较**：令 $a = h^{(1)}_{3}$ 和 $b = h^{(2)}_{3}$。\n    - 余弦相似度：$\\mathrm{cos}(a, b) = \\frac{0(1.5)+1.5(0.75)}{\\sqrt{0^2+1.5^2}\\sqrt{1.5^2+0.75^2}} = \\frac{1.125}{1.5\\sqrt{2.8125}} \\approx 0.447214$。\n    - 欧几里得距离：$\\|a - b\\|_2 = \\sqrt{(0-1.5)^2+(1.5-0.75)^2} = \\sqrt{(-1.5)^2+0.75^2} = \\sqrt{2.8125} \\approx 1.677051$。\n\n### 测试用例 3\n邻接矩阵为 $A^{(3)} = \\begin{bmatrix} 1  0  0  0 \\\\ 0  1  1  0 \\\\ 0  0  0  0 \\end{bmatrix}$。\n疾病的度为 $d_1=1$, $d_2=2$, $d_3=0$。对于疾病 $i=3$，度为 $0$。\n根据约定，归一化邻接矩阵 $\\tilde{A}^{(3)}$ 的第3行为全零向量：\n$$\n\\tilde{A}^{(3)} = \\begin{bmatrix} 1  0  0  0 \\\\ 0  0.5  0.5  0 \\\\ 0  0  0  0 \\end{bmatrix}\n$$\n- **单层嵌入 $h^{(1)}_{3}$**：\n由于 $\\tilde{A}^{(3)}$ 的第3行为零，聚合结果为一个零向量。\n$$ (\\tilde{A}^{(3)} Y_p)_{3,:} = \\begin{bmatrix} 0  0  0  0 \\end{bmatrix} Y_p = \\begin{bmatrix} 0  0 \\end{bmatrix} $$\n$$ h^{(1)}_{3} = \\sigma(\\begin{bmatrix} 0  0 \\end{bmatrix}) = \\begin{bmatrix} 0  0 \\end{bmatrix} $$\n- **双层嵌入 $h^{(2)}_{3}$**：\n同样地，聚合结果是一个零向量。\n$$ (\\tilde{A}^{(3)} Z_p W_2)_{3,:} = (\\begin{bmatrix} 0  0  0  0 \\end{bmatrix} Z_p) W_2 = \\begin{bmatrix} 0  0 \\end{bmatrix} W_2 = \\begin{bmatrix} 0  0 \\end{bmatrix} $$\n$$ h^{(2)}_{3} = \\sigma(\\begin{bmatrix} 0  0 \\end{bmatrix}) = \\begin{bmatrix} 0  0 \\end{bmatrix} $$\n- **比较**：令 $a = h^{(1)}_{3}$ 和 $b = h^{(2)}_{3}$。两者都是零向量。\n    - 余弦相似度：因为 $\\|a\\| = 0$ 且 $\\|b\\| = 0$，根据约定，$\\mathrm{cos}(a, b) = 0$。\n    - 欧几里得距离：$\\|a - b\\|_2 = \\|\\begin{bmatrix} 0  0 \\end{bmatrix}\\|_2 = 0$。\n\n最终结果被收集并按规定格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares one-layer and two-layer GNN embeddings for a toy\n    disease-phenotype graph based on the problem specification.\n    \"\"\"\n    # Define fixed matrices and parameters from the problem statement.\n    Xp = np.array([\n        [1.0, 0.0, -1.0],\n        [0.5, 1.0, 0.0],\n        [0.0, -0.5, 1.0],\n        [1.0, 1.0, 1.0]\n    ])\n\n    W1 = np.array([\n        [0.5, 0.0],\n        [0.0, 1.0],\n        [-0.5, 0.5]\n    ])\n\n    U = np.array([\n        [1.0, -1.0],\n        [0.5, 0.0],\n        [0.0, 1.0]\n    ])\n\n    W2 = np.array([\n        [1.0, 0.5],\n        [-0.5, 1.0]\n    ])\n\n    # Index of the unseen disease (third disease, so index 2 in 0-based system).\n    i_star = 2\n    \n    # Test cases for the adjacency matrix A.\n    test_cases = [\n        # Test case 1\n        np.array([\n            [1, 1, 0, 0],\n            [0, 1, 1, 0],\n            [1, 0, 0, 1]\n        ]),\n        # Test case 2\n        np.array([\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ]),\n        # Test case 3\n        np.array([\n            [1, 0, 0, 0],\n            [0, 1, 1, 0],\n            [0, 0, 0, 0]\n        ])\n    ]\n\n    results = []\n\n    # ReLU activation function\n    relu = lambda x: np.maximum(0, x)\n\n    # Pre-compute phenotype feature transformations\n    Yp = Xp @ W1\n    Zp = relu(Xp @ U)\n\n    for A in test_cases:\n        # 1. Compute the normalized adjacency matrix A_tilde\n        degrees = A.sum(axis=1)\n        A_tilde = np.zeros_like(A, dtype=float)\n        for i in range(A.shape[0]):\n            if degrees[i] > 0:\n                A_tilde[i, :] = A[i, :] / degrees[i]\n        \n        # 2. Compute one-layer embeddings\n        H1 = relu(A_tilde @ Yp)\n        h1_istar = H1[i_star]\n\n        # 3. Compute two-layer embeddings\n        H2 = relu((A_tilde @ Zp) @ W2)\n        h2_istar = H2[i_star]\n        \n        # 4. Compare embeddings\n        norm1 = np.linalg.norm(h1_istar)\n        norm2 = np.linalg.norm(h2_istar)\n\n        # Cosine similarity with zero-norm convention\n        if norm1 == 0 or norm2 == 0:\n            cos_sim = 0.0\n        else:\n            cos_sim = np.dot(h1_istar, h2_istar) / (norm1 * norm2)\n\n        # Euclidean distance\n        euclidean_dist = np.linalg.norm(h1_istar - h2_istar)\n        \n        results.append([cos_sim, euclidean_dist])\n\n    # Format the output string as per the requirements. The problem description\n    # specifies a list of lists format, which is standard. The example format\n    # `[$[...]]` appears to be a typo/artifact, so the standard, well-formed\n    # representation is used.\n    result_strings = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "4618399"}, {"introduction": "在获得了患者和疾病的嵌入向量之后，下一步便是量化它们之间的兼容性，从而进行诊断预测。本实践聚焦于零样本学习推理阶段的核心机制：兼容性评分。我们将使用一个常见的双线性模型 (bilinear model)，通过矩阵运算将患者的特征嵌入和疾病的语义嵌入联系起来。您将为一个新的患者样本计算其与多种未见罕见病的兼容性得分，并学习如何使用 softmax 函数将这些原始得分转换为概率，从而完成从嵌入到最终预测的完整流程 [@problem_id:4618533]。", "problem": "一项基于生物样本库的研究应用零样本学习 (ZSL) 方法，通过利用从一个精心构建的本体中嵌入的疾病语义描述，对训练集中未出现的罕见病进行优先级排序。在一个双线性兼容性框架中，每个患者样本 $x$ 由一个特征嵌入 $\\phi(x) \\in \\mathbb{R}^{d_{x}}$ 表示（例如，基因表达和临床属性的分层摘要），每个疾病标签 $y$ 由一个语义嵌入 $\\psi(y) \\in \\mathbb{R}^{d_{y}}$ 表示（例如，本体衍生的属性），而学习到的跨模态映射是一个矩阵 $W \\in \\mathbb{R}^{d_{x} \\times d_{y}}$。该模型使用双线性形式来为患者 $x$ 和疾病 $y$ 之间的兼容性评分\n$$F(x,y) = \\phi(x)^{\\top} W \\,\\psi(y)。$$\n对于一个留出的患者 $x$ 和一个未见过的罕见病集合 $Y_{\\text{unseen}}=\\{y_{\\mathrm{A}},y_{\\mathrm{B}},y_{\\mathrm{C}},y_{\\mathrm{D}}\\}$，给定\n$$\\phi(x)=\\begin{pmatrix}1 \\\\ -1 \\\\ 2\\end{pmatrix},\\quad W=\\begin{pmatrix}2  -1  0  1 \\\\ 0  1  -2  3 \\\\ 1  2  1  -1\\end{pmatrix},$$\n以及疾病嵌入\n$$\\psi(y_{\\mathrm{A}})=\\begin{pmatrix}1 \\\\ 0 \\\\ 1 \\\\ -1\\end{pmatrix},\\quad \\psi(y_{\\mathrm{B}})=\\begin{pmatrix}0 \\\\ 2 \\\\ -1 \\\\ 0\\end{pmatrix},\\quad \\psi(y_{\\mathrm{C}})=\\begin{pmatrix}1 \\\\ 1 \\\\ 0 \\\\ 1\\end{pmatrix},\\quad \\psi(y_{\\mathrm{D}})=\\begin{pmatrix}-1 \\\\ 0 \\\\ 2 \\\\ 1\\end{pmatrix}。$$\n任务：\n1. 对每个 $y \\in Y_{\\text{unseen}}$ 计算 $F(x,y)$，并选择 $k=2$ 的前 $k$ 个预测结果，按分数降序排名。如果在第 $k$ 个位置出现平分，则按字典序 $y_{\\mathrm{A}} \\prec y_{\\mathrm{B}} \\prec y_{\\mathrm{C}} \\prec y_{\\mathrm{D}}$ 打破平局。\n2. 使用所有四个分数 $\\{F(x,y)\\}_{y \\in Y_{\\text{unseen}}}$，计算分配给排名第一的预测疾病的温度缩放 softmax 概率：\n$$p_{\\text{top}}=\\frac{\\exp\\!\\big(F(x,y_{\\text{top}})/\\tau\\big)}{\\sum\\limits_{y \\in Y_{\\text{unseen}}} \\exp\\!\\big(F(x,y)/\\tau\\big)},$$\n其中温度参数 $\\tau=4$。\n将最终答案表示为 $p_{\\text{top}}$ 的小数值，并四舍五入到四位有效数字。无需单位。", "solution": "用于罕见病优先级排序的零样本学习 (ZSL) 依赖于通过共享语义空间进行知识迁移，其中一个未见过的疾病 $y$ 通过一个兼容性函数与患者 $x$ 相关联。在双线性模型中，兼容性由 $F(x,y)=\\phi(x)^{\\top}W\\psi(y)$ 给出。为了高效地为多个 $y$ 计算 $F(x,y)$，可以方便地先计算中间向量 $s(x)^{\\top}=\\phi(x)^{\\top}W \\in \\mathbb{R}^{d_{y}}$，然后与每个 $\\psi(y)$ 进行点积运算。\n\n步骤1：计算 $s(x)^{\\top}=\\phi(x)^{\\top}W$。\n给定 $\\phi(x)=\\begin{pmatrix}1 \\\\ -1 \\\\ 2\\end{pmatrix}$ 和\n$$W=\\begin{pmatrix}2  -1  0  1 \\\\ 0  1  -2  3 \\\\ 1  2  1  -1\\end{pmatrix},$$\n我们有\n$$s(x)^{\\top}=\\phi(x)^{\\top}W=\\big(1\\cdot \\text{row}_{1}(W)\\big)+\\big((-1)\\cdot \\text{row}_{2}(W)\\big)+\\big(2\\cdot \\text{row}_{3}(W)\\big)。$$\n计算每个加权行：\n- $1\\cdot \\text{row}_{1}(W)=(2,\\,-1,\\,0,\\,1)$，\n- $(-1)\\cdot \\text{row}_{2}(W)=(0,\\,-1,\\,2,\\,-3)$，\n- $2\\cdot \\text{row}_{3}(W)=(2,\\,4,\\,2,\\,-2)$。\n按分量求和，\n$$s(x)^{\\top}=(2+0+2,\\,-1-1+4,\\,0+2+2,\\,1-3-2)=(4,\\,2,\\,4,\\,-4)。$$\n\n步骤2：对每个未见过的疾病计算 $F(x,y)=s(x)^{\\top}\\psi(y)$。\n- 对于 $y_{\\mathrm{A}}$，有 $\\psi(y_{\\mathrm{A}})=\\begin{pmatrix}1 \\\\ 0 \\\\ 1 \\\\ -1\\end{pmatrix}$，\n$$F(x,y_{\\mathrm{A}})=(4,2,4,-4)\\cdot(1,0,1,-1)=4\\cdot 1+2\\cdot 0+4\\cdot 1+(-4)\\cdot(-1)=4+0+4+4=12。$$\n- 对于 $y_{\\mathrm{B}}$，有 $\\psi(y_{\\mathrm{B}})=\\begin{pmatrix}0 \\\\ 2 \\\\ -1 \\\\ 0\\end{pmatrix}$，\n$$F(x,y_{\\mathrm{B}})=(4,2,4,-4)\\cdot(0,2,-1,0)=4\\cdot 0+2\\cdot 2+4\\cdot(-1)+(-4)\\cdot 0=0+4-4+0=0。$$\n- 对于 $y_{\\mathrm{C}}$，有 $\\psi(y_{\\mathrm{C}})=\\begin{pmatrix}1 \\\\ 1 \\\\ 0 \\\\ 1\\end{pmatrix}$，\n$$F(x,y_{\\mathrm{C}})=(4,2,4,-4)\\cdot(1,1,0,1)=4\\cdot 1+2\\cdot 1+4\\cdot 0+(-4)\\cdot 1=4+2+0-4=2。$$\n- 对于 $y_{\\mathrm{D}}$，有 $\\psi(y_{\\mathrm{D}})=\\begin{pmatrix}-1 \\\\ 0 \\\\ 2 \\\\ 1\\end{pmatrix}$，\n$$F(x,y_{\\mathrm{D}})=(4,2,4,-4)\\cdot(-1,0,2,1)=4\\cdot(-1)+2\\cdot 0+4\\cdot 2+(-4)\\cdot 1=-4+0+8-4=0。$$\n\n因此，分数分别为\n$$F(x,y_{\\mathrm{A}})=12,\\quad F(x,y_{\\mathrm{B}})=0,\\quad F(x,y_{\\mathrm{C}})=2,\\quad F(x,y_{\\mathrm{D}})=0。$$\n\n步骤3：选择 $k=2$ 的前 $k$ 个预测结果。\n按分数降序排列，得到 $y_{\\mathrm{A}}$ (分数 $12$)，然后是 $y_{\\mathrm{C}}$ (分数 $2$)，接着是 $y_{\\mathrm{B}}$ 和 $y_{\\mathrm{D}}$ (均为分数 $0$) 并列。因此，排名前2的是 $y_{\\mathrm{A}}$ 和 $y_{\\mathrm{C}}$。\n\n步骤4：使用 $\\tau=4$ 计算排名第一的标签的温度缩放 softmax 概率。\n排名第一的标签是 $y_{\\mathrm{A}}$。温度缩放的 softmax 分配的概率为\n$$p_{\\text{top}}=\\frac{\\exp\\!\\big(F(x,y_{\\mathrm{A}})/4\\big)}{\\exp\\!\\big(F(x,y_{\\mathrm{A}})/4\\big)+\\exp\\!\\big(F(x,y_{\\mathrm{B}})/4\\big)+\\exp\\!\\big(F(x,y_{\\mathrm{C}})/4\\big)+\\exp\\!\\big(F(x,y_{\\mathrm{D}})/4\\big)}。$$\n代入分数：\n$$p_{\\text{top}}=\\frac{\\exp(12/4)}{\\exp(12/4)+\\exp(0/4)+\\exp(2/4)+\\exp(0/4)}=\\frac{\\exp(3)}{\\exp(3)+1+\\exp(0.5)+1}。$$\n首先对指数进行符号计算，然后进行数值计算：\n$$\\exp(3)\\approx 20.0855369232,\\quad \\exp(0.5)\\approx 1.6487212707。$$\n分母为\n$$20.0855369232+1+1.6487212707+1=23.7342581939。$$\n因此，\n$$p_{\\text{top}}\\approx \\frac{20.0855369232}{23.7342581939}\\approx 0.846267735\\ldots。$$\n\n步骤5：以小数形式四舍五入到四位有效数字。\n将 $0.846267735\\ldots$ 四舍五入到四位有效数字得到 $0.8463$。", "answer": "$$\\boxed{0.8463}$$", "id": "4618533"}, {"introduction": "一个强大的模型如果缺乏严格的验证，其价值将大打折扣。在罕见病研究中，由于数据稀缺，对模型性能的准确评估尤为重要。本实践将引导您进入关键的模型评估阶段，重点介绍两个在生物信息学中广泛使用的评估指标：受试者工作特征曲线下面积 (AUROC) 和精确率-召回率曲线下面积 (AUPRC)。更重要的是，本练习模拟了一个在机器学习实践中常见且危险的陷阱——数据泄漏，您将通过移除泄漏数据并重新计算性能指标，亲身体会数据泄漏如何夸大模型表现，并理解建立严谨评估流程的必要性 [@problem_id:4618537]。", "problem": "给定一个用于罕见病表型分析的零样本学习二元评估场景。一个零样本分类器通过患者表型嵌入与疾病属性嵌入之间的语义对齐，为每位患者分配一个针对目标罕见病的相似度分数。对于一组由唯一标识符索引的患者，假设您拥有元组 $(p_i, y_i, s_i)$，其中 $p_i$ 是患者 $i$ 的唯一整数标识符，$y_i \\in \\{0,1\\}$ 是真实疾病标签（ground-truth），$s_i \\in [0,1]$ 是分类器分配的目标疾病相似度分数。已知患者标识符的一个子集 $L$ 已被泄露（例如，由于开发集和评估集在特征构建上存在重叠导致的数据泄露）。您必须使用完整数据集计算原始指标，并在移除 $L$ 中的所有患者后计算校正后的指标，然后量化其变化。\n\n基础和约定：\n- 使用受试者工作特征曲线下面积（Area Under the Receiver Operating Characteristic, AUROC）的标准定义，即随机选择一个正样本的分数高于随机选择一个负样本的分数的概率，其中分数相同时计为0.5。按照惯例，当没有正样本或没有负样本时，返回无信息基线值 $0.5$。\n- 使用精确率-召回率曲线下面积（Area Under the Precision–Recall curve, AUPRC）的标准定义，该定义被解释为在递减分数阈值下，精确率相对于召回率的黎曼-斯蒂尔杰斯积分。其计算方法是：将所有具有相同分数的项目分组，按每个唯一分数累积更新真正例（true positives）和假正例（false positives），并将在每个分数组末尾的精确率乘以召回率的增量进行求和。按照惯例，当没有正样本时，返回 $0.0$。当没有负样本但至少有一个正样本时，AUPRC 等于 $1.0$。\n- 所有计算都是无单位的。不涉及角度。百分比在概念上引用时，必须表示为小数。\n\n需为每个测试用例实现的算法任务：\n1. 给定完整的元组集合 $I$ $(p_i,y_i,s_i)$ 和泄露的标识符集合 $L \\subseteq \\{p_i\\}$，定义过滤后的索引集 $I' = \\{(p_i,y_i,s_i) \\in I : p_i \\notin L\\}$。\n2. 在 $I$ 上计算原始的 AUROC 和 AUPRC。\n3. 在 $I'$ 上计算校正后的 AUROC 和 AUPRC。\n4. 报告变化量 $\\Delta \\text{AUROC} = \\text{AUROC}_{\\text{corrected}} - \\text{AUROC}_{\\text{original}}$ 和 $\\Delta \\text{AUPRC} = \\text{AUPRC}_{\\text{corrected}} - \\text{AUPRC}_{\\text{original}}$。\n\n测试套件：\n对于下述每个案例，数据以三元组的有序列表 $[(p_i,y_i,s_i)]$ 和一个泄露集 $L$ 的形式给出。\n\n- 案例 A（混合泄露的正常路径）：\n  - 数据 $I_A$: $[(1,1,0.90),(2,1,0.85),(3,1,0.80),(4,0,0.70),(5,0,0.60),(6,0,0.55),(7,1,0.50),(8,0,0.40),(9,0,0.30),(10,1,0.20)]$。\n  - 泄露集 $L_A$: $\\{3,7\\}$。\n\n- 案例 B（所有正样本均泄露的边界情况）：\n  - 数据 $I_B$: $[(11,1,0.90),(12,1,0.80),(13,0,0.70),(14,0,0.60),(15,0,0.40),(16,0,0.20)]$。\n  - 泄露集 $L_B$: $\\{11,12\\}$。\n\n- 案例 C（存在分数相同情况及负样本泄露的边缘情况）：\n  - 数据 $I_C$: $[(17,1,0.70),(18,0,0.70),(19,1,0.60),(20,0,0.60),(21,1,0.60),(22,0,0.50),(23,0,0.40),(24,1,0.30)]$。\n  - 泄露集 $L_C$: $\\{18,22\\}$。\n\n最终输出格式要求：\n- 您的程序必须按 A、B、C 的顺序为每个案例计算一个列表 $[\\text{AUROC}_{\\text{corrected}}, \\text{AUPRC}_{\\text{corrected}}, \\Delta \\text{AUROC}, \\Delta \\text{AUPRC}]$，并将每个值四舍五入到 $4$ 位小数。\n- 将这三个案例的列表聚合到一个单独的列表中，并打印一行只包含这个外层列表的内容，其格式为用方括号括起来的逗号分隔形式，例如 $[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],[c_1,c_2,c_3,c_4]]$，其中每个 $a_k, b_k, c_k$ 都被替换为计算出并格式化为小数点后恰好有 $4$ 位数字的小数。\n\n科学真实性和零样本学习背景说明：\n- 该任务假设 $s_i$ 来自患者表型向量与疾病描述符之间的零样本语义匹配。但是，您无需建模或计算 $s_i$；请将 $s_i$ 视为给定值。\n- 移除泄露数据的操作模拟了在一个罕见病场景中校正评估协议的过程，在这种场景下，数据稀缺性和语义泛化使得数据泄露的危害尤其严重。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[[0.1234,0.5678,-0.1111,0.2222],[...],[...]]”）。", "solution": "问题陈述已经过严格验证，并被认定为**有效**。\n\n**1. 问题验证**\n\n*   **步骤1：提取已知信息**\n    *   **数据：** 对于一组患者，提供了形式为 $(p_i, y_i, s_i)$ 的元组，其中 $p_i$ 是唯一的整数患者标识符，$y_i \\in \\{0,1\\}$ 是真实疾病标签（1为阳性，0为阴性），$s_i \\in [0,1]$ 是分类器分配的相似度分数。\n    *   **泄露集：** 指定了一个患者标识符的子集 $L$ 为“已泄露”。\n    *   **AUROC 定义：** 受试者工作特征曲线下面积定义为随机选择的正样本得分高于随机选择的负样本得分的概率。分数相同时计为0.5。如果没有正样本或负样本，AUROC为 $0.5$。\n    *   **AUPRC 定义：** 精确率-召回率曲线下面积定义为精确率关于召回率的黎曼-斯蒂尔杰斯积分。其计算方式为：将相同分数的项目分组，累积更新真正例/假正例，并对每组的精确率与召回率增量之积求和。如果没有正样本，AUPRC为 $0.0$。如果没有负样本（但至少有一个正样本），AUPRC为 $1.0$。\n    *   **任务：**\n        1.  定义完整集 $I$ 和过滤集 $I' = \\{(p_i,y_i,s_i) \\in I : p_i \\notin L\\}$。\n        2.  在 $I$ 上计算原始 AUROC 和 AUPRC。\n        3.  在 $I'$ 上计算校正后的 AUROC 和 AUPRC。\n        4.  报告变化量：$\\Delta \\text{AUROC} = \\text{AUROC}_{\\text{corrected}} - \\text{AUROC}_{\\text{original}}$ 和 $\\Delta \\text{AUPRC} = \\text{AUPRC}_{\\text{corrected}} - \\text{AUPRC}_{\\text{original}}$。\n    *   **测试用例：** 提供了三个具体的案例（A, B, C），包括数据和泄露集。\n    *   **输出格式：** 一个嵌套的结果列表，每个数值四舍五入到4位小数。\n\n*   **步骤2：使用提取的已知信息进行验证**\n    *   **科学性：** 该问题牢固地植根于标准的机器学习评估实践中。AUROC和AUPRC是二元分类的基本指标。数据泄露是模型评估中一个众所周知且关键的问题。在罕见病领域应用零样本学习是生物信息学中一个现实的应用领域。\n    *   **适定性：** 该问题提供了所有必要的数据，并为所需指标提供了明确、标准的定义，包括对边缘情况的处理。任务明确，可以导出一个唯一的、可计算的解。\n    *   **客观性：** 问题以精确、定量的术语陈述。没有主观或基于意见的成分。\n    *   **完整性与一致性：** 问题是自洽的。提供了所有测试用例的数据，算法指令与定义一致。\n    *   **现实性：** 评估分类器并校正数据泄露的场景是应用机器学习中一个实际且常见的任务。\n    *   **结论：** 该问题未违反任何无效性标准。它是一个定义明确、具有科学依据的计算问题。\n\n*   **步骤3：结论与行动**\n    *   问题有效。将提供完整的解决方案。\n\n**2. 原理与算法设计**\n\n这个问题的核心是在两个不同的数据集上计算和比较两种标准分类指标——AUROC和AUPRC：原始数据集 $I$ 和一个移除了泄露数据点的校正数据集 $I'$。\n\n**AUROC（受试者工作特征曲线下面积）**\n问题指定了AUROC的概率性定义。设 $S_P$ 为正样本的分数集，$S_N$ 为负样本的分数集。设 $N_P = |S_P|$ 且 $N_N = |S_N|$。AUROC是从 $S_P$ 中随机抽取的得分 $s_p$ 大于从 $S_N$ 中随机抽取的得分 $s_n$ 的概率。这可以通过枚举所有 $(s_p, s_n)$ 对来计算：\n$$\n\\text{AUROC} = \\frac{1}{N_P N_N} \\sum_{s_p \\in S_P} \\sum_{s_n \\in S_N} \\mathbb{I}(s_p, s_n)\n$$\n其中 $\\mathbb{I}(s_p, s_n)$ 是一个比较函数：\n$$\n\\mathbb{I}(s_p, s_n) = \\begin{cases} 1  \\text{if } s_p > s_n \\\\ 0.5  \\text{if } s_p = s_n \\\\ 0  \\text{if } s_p  s_n \\end{cases}\n$$\n根据问题的约定，如果 $N_P=0$ 或 $N_N=0$，则AUROC取值为 $0.5$。算法将首先将样本分为正样本集和负样本集，然后实现上述双重求和。\n\n**AUPRC（精确率-召回率曲线下面积）**\n问题为AUPRC提供了一个特定的计算过程，这对应于计算PR曲线下的面积，其中精确率在两个连续的召回率点之间被假定为常数。设所有样本的集合按其分数降序排列。算法通过从高到低迭代唯一的得分值（阈值）来进行。\n\n设正样本总数为 $N_P$，负样本总数为 $N_N$。在过程的任何时刻，设真正例（true positives）的累积计数为 $TP$，假正例（false positives）的累积计数为 $FP$。精确率（$P$）和召回率（$R$）定义如下：\n$$\nP = \\frac{TP}{TP + FP} \\quad , \\quad R = \\frac{TP}{N_P}\n$$\n算法如下：\n1.  处理边缘情况：如果 $N_P = 0$，AUPRC为 $0.0$。如果 $N_N = 0$（且 $N_P > 0$），AUPRC为 $1.0$。\n2.  将所有 $(y_i, s_i)$ 对按分数 $s_i$ 降序排序。\n3.  初始化 $\\text{AUPRC} = 0$, $TP = 0$, $FP = 0$ 和 $\\text{last\\_recall} = 0$。\n4.  遍历排序后的列表，将所有具有相同分数的样本作为一个组进行处理。对于每个唯一分数下的样本组：\n    a. 计算该组中正样本（$\\Delta TP$）和负样本（$\\Delta FP$）的数量。\n    b. 更新 $TP \\leftarrow TP + \\Delta TP$ 和 $FP \\leftarrow FP + \\Delta FP$。\n    c. 计算新的召回率 $R_{\\text{new}} = TP / N_P$。\n    d. 如果 $R_{\\text{new}} > \\text{last\\_recall}$：\n        i. 计算此时的精确率：$P_{\\text{new}} = TP / (TP + FP)$。\n        ii. 将此召回率增量对应的矩形面积加到总面积上：$\\text{AUPRC} \\leftarrow \\text{AUPRC} + P_{\\text{new}} \\times (R_{\\text{new}} - \\text{last\\_recall})$。\n        iii. 更新 $\\text{last\\_recall} \\leftarrow R_{\\text{new}}$。\n5.  最终的和即为AUPRC。此过程正确实现了指定的黎曼-斯蒂尔杰斯和近似。\n\n**总体流程**\n对于每个测试用例，执行以下步骤：\n1.  使用 AUROC 和 AUPRC 算法处理完整数据集 $I$，以获得 $\\text{AUROC}_{\\text{original}}$ 和 $\\text{AUPRC}_{\\text{original}}$。\n2.  通过移除所有满足 $p_i$ 在泄露集 $L$ 中的元组 $(p_i,y_i,s_i)$ 来构建过滤后的数据集 $I'$。\n3.  使用相同的 AUROC 和 AUPRC 算法处理过滤后的数据集 $I'$，以获得 $\\text{AUROC}_{\\text{corrected}}$ 和 $\\text{AUPRC}_{\\text{corrected}}$。\n4.  计算差异 $\\Delta \\text{AUROC}$ 和 $\\Delta \\text{AUPRC}$。\n5.  收集这四个结果值，四舍五入到四位小数，并按要求格式化。\n\n这种结构化的方法确保了评估指标是根据所提供的精确定义计算的，并且数据泄露的影响被正确地量化。", "answer": "```python\nimport numpy as np\n\ndef _compute_auroc(labels: list[int], scores: list[float]) - float:\n    \"\"\"Computes AUROC based on the pairwise probabilistic definition.\"\"\"\n    pos_scores = [s for s, y in zip(scores, labels) if y == 1]\n    neg_scores = [s for s, y in zip(scores, labels) if y == 0]\n    \n    n_pos = len(pos_scores)\n    n_neg = len(neg_scores)\n\n    if n_pos == 0 or n_neg == 0:\n        return 0.5\n\n    wins = 0\n    ties = 0\n    for s_pos in pos_scores:\n        for s_neg in neg_scores:\n            if s_pos  s_neg:\n                wins += 1\n            elif s_pos == s_neg:\n                ties += 1\n    \n    return (wins + 0.5 * ties) / (n_pos * n_neg)\n\ndef _compute_auprc(labels: list[int], scores: list[float]) - float:\n    \"\"\"Computes AUPRC by integrating precision over recall increments.\"\"\"\n    n_pos = sum(labels)\n    n_total = len(labels)\n    \n    if n_pos == 0:\n        return 0.0\n    \n    n_neg = n_total - n_pos\n    if n_neg == 0:\n        return 1.0\n\n    # Sort instances by score in descending order\n    sorted_data = sorted(zip(scores, labels), key=lambda x: x[0], reverse=True)\n    \n    tp = 0.0\n    fp = 0.0\n    auprc = 0.0\n    last_recall = 0.0\n    \n    i = 0\n    while i  n_total:\n        current_score = sorted_data[i][0]\n        \n        # Find all instances with the same score\n        j = i\n        while j  n_total and sorted_data[j][0] == current_score:\n            j += 1\n            \n        # Count positives and negatives in the current score group\n        tp_group = sum(y for s, y in sorted_data[i:j])\n        fp_group = (j - i) - tp_group\n        \n        # Update cumulative TP and FP *after* the group\n        tp += tp_group\n        fp += fp_group\n        \n        recall = tp / n_pos\n        precision = tp / (tp + fp) if (tp + fp)  0 else 1.0 # Should not happen with data\n        \n        # Add the area of the rectangle for the new recall segment\n        auprc += precision * (recall - last_recall)\n        \n        # Update for the next iteration\n        last_recall = recall\n        i = j\n        \n    return auprc\n\ndef compute_metrics(data: list[tuple[int, int, float]]) - tuple[float, float]:\n    \"\"\"Computes AUROC and AUPRC for a given dataset.\"\"\"\n    if not data:\n        # No data: return conventional baselines\n        return 0.5, 0.0\n\n    labels = [d[1] for d in data]\n    scores = [d[2] for d in data]\n    \n    auroc = _compute_auroc(labels, scores)\n    auprc = _compute_auprc(labels, scores)\n    \n    return auroc, auprc\n    \ndef solve():\n    \"\"\"\n    Main function to process test cases and produce the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"data\": [\n                (1,1,0.90),(2,1,0.85),(3,1,0.80),(4,0,0.70),(5,0,0.60),\n                (6,0,0.55),(7,1,0.50),(8,0,0.40),(9,0,0.30),(10,1,0.20)\n            ],\n            \"leaked_set\": {3, 7}\n        },\n        {\n            \"data\": [\n                (11,1,0.90),(12,1,0.80),(13,0,0.70),(14,0,0.60),\n                (15,0,0.40),(16,0,0.20)\n            ],\n            \"leaked_set\": {11, 12}\n        },\n        {\n            \"data\": [\n                (17,1,0.70),(18,0,0.70),(19,1,0.60),(20,0,0.60),(21,1,0.60),\n                (22,0,0.50),(23,0,0.40),(24,1,0.30)\n            ],\n            \"leaked_set\": {18, 22}\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        original_data = case[\"data\"]\n        leaked_set = case[\"leaked_set\"]\n        \n        # 1. Compute original metrics\n        auroc_orig, auprc_orig = compute_metrics(original_data)\n        \n        # 2. Filter data and compute corrected metrics\n        filtered_data = [d for d in original_data if d[0] not in leaked_set]\n        auroc_corr, auprc_corr = compute_metrics(filtered_data)\n        \n        # 3. Compute deltas\n        delta_auroc = auroc_corr - auroc_orig\n        delta_auprc = auprc_corr - auprc_orig\n        \n        # 4. Store results\n        case_results = [auroc_corr, auprc_corr, delta_auroc, delta_auprc]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    formatted_cases = []\n    for res_list in all_results:\n        formatted_list = [f\"{val:.4f}\" for val in res_list]\n        formatted_cases.append(f\"[{','.join(formatted_list)}]\")\n    \n    print(f\"[{','.join(formatted_cases)}]\")\n\nsolve()\n```", "id": "4618537"}]}