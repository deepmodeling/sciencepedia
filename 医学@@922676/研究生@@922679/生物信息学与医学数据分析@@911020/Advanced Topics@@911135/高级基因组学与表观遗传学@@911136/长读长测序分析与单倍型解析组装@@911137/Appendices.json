{"hands_on_practices": [{"introduction": "长读长测序的质量通常用读长N50统计量来概括，它反映了读长的分布情况。本练习 [@problem_id:4579363] 提供了从一组给定的读长数据中计算这一基本指标的实践机会。更重要的是，它要求你从第一性原理出发，推断输入数据的这一特性如何直接影响最终基因组组装的连续性，理解这一关键联系对于任何生物信息学家都至关重要。", "problem": "在长读长测序中，读长分布的一个汇总统计量是读长 N50。给定一个测序数据集，包含14条单分子读长，长度（单位为千碱基）分别为：$25$, $20$, $18$, $15$, $12$, $12$, $10$, $9$, $8$, $7$, $6$, $5$, $4$, $3$。根据读长 N50 的正式定义，即长度至少为 $N$ 的读长共同构成了至少一半的总测序碱基数，计算该数据集的读长 N50。以 $\\mathrm{kb}$ 为单位表示读长 N50。无需四舍五入。\n\n然后，在一个理想化的重叠-布局-共有序列（Overlap–Layout–Consensus, OLC）组装器下（重叠-布局-共有序列（OLC）定义了一种组装范式，它构建了读长间重叠的图谱，将读长排序成布局，并推导出共有序列），从第一性原理出发，解释读长 N50 如何影响预期的重叠群（contig）N50。在您的解释中，您可以不加证明地假设以下广泛使用的基础：长度为 $G$ 的基因组上的读长起始位置可以通过覆盖深度为 $c$ 的均匀泊松过程很好地近似；长度为 $R$ 的重复序列需要至少一条读长跨越该重复序列及其两侧总长度为 $2u$ 的独特序列才能被解析；重叠群（contig）倾向于在未解析的重复序列和覆盖缺口处断裂。对于这部分，不要计算任何数值；而是推导并陈述一个符号表达式，将重复序列被解析的概率与读长分布联系起来，并用它来论证增加读长 N50 如何改变预期的重叠群 N50。\n\n您最终报告的答案必须仅为计算出的读长 N50（单位为 kb）。如果需要四舍五入，您需要保留四位有效数字，但对于此数据集则不需要。", "solution": "该问题提出了两个不同的任务。第一个是针对给定数据集计算读长 N50 的数值。第二个是基于基因组组装的第一性原理，从理论上解释读长 N50 和重叠群（contig）N50 之间的关系。\n\n首先，我们处理读长 N50 的计算。正式定义指出，读长 N50 是这样一个长度 $N$，使得长度至少为 $N$ 的测序读长共同贡献了至少一半的总测序碱基数。\n\n给定的数据集包含 14 条读长，其长度（单位为千碱基，kb）如下：$25$, $20$, $18$, $15$, $12$, $12$, $10$, $9$, $8$, $7$, $6$, $5$, $4$, $3$。\n\n计算读长 N50 的步骤如下：\n1.  将所有读长的长度相加，计算测序总碱基数。\n2.  确定目标值，即总碱基数的一半。\n3.  按读长长度降序排列。\n4.  遍历排序后的列表，计算读长长度的累积和。\n5.  N50 是累积和首次达到或超过步骤2中目标值时所对应的读长长度。\n\n让我们执行这些步骤。\n步骤 1：计算所有读长的总长度。\n总长度 $= 25 + 20 + 18 + 15 + 12 + 12 + 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 = 154$ kb。\n\n步骤 2：确定总长度的一半。\n目标长度 $= \\frac{1}{2} \\times 154 = 77$ kb。\n\n步骤 3：按长度降序排列读长。给定的列表已经排好序：\n$L_1 = 25$, $L_2 = 20$, $L_3 = 18$, $L_4 = 15$, $L_5 = 12$, $L_6 = 12$, $L_7 = 10$, $L_8 = 9$, $L_9 = 8$, $L_{10} = 7$, $L_{11} = 6$, $L_{12} = 5$, $L_{13} = 4$, $L_{14} = 3$。\n\n步骤 4：计算长度的累积和，并与 77 kb 的目标长度进行比较。\n-   加上最长的读长 ($L_1 = 25$)：累积和 = $25$ kb。小于 $77$ kb。\n-   加上第二长的读长 ($L_2 = 20$)：累积和 = $25 + 20 = 45$ kb。小于 $77$ kb。\n-   加上第三长的读长 ($L_3 = 18$)：累积和 = $45 + 18 = 63$ kb。小于 $77$ kb。\n-   加上第四长的读长 ($L_4 = 15$)：累积和 = $63 + 15 = 78$ kb。该和大于或等于目标值 $77$ kb。\n\n步骤 5：确定 N50 值。在包含长度为 15 kb 的读长后，累积和首次达到阈值。因此，根据定义，该数据集的读长 N50 为 15 kb。\n\n接下来，我们处理问题的第二部分：从第一性原理出发，解释在一个理想化的 OLC 组装器下，读长 N50 如何影响预期的重叠群 N50。\n\n重叠群 N50 是衡量组装质量的一个指标，其值越高表示组装的连续性越好（即基因组被组装成更少、更长的片段）。问题指出，重叠群在未解析的重复序列和覆盖缺口处断裂。基因组组装中的一个主要挑战是正确解析重复序列。读长 N50 的增加对解析重复序列的能力有直接的积极影响，这反过来又会增加重叠群 N50。\n\n让我们基于给定的假设来形式化这种关系。一个长度为 $R$ 的重复序列需要至少一条读长来跨越它及其两侧总长度为 $2u$ 的独特序列。因此，一条能够解析的读长必须满足长度 $L \\geq R + 2u$。\n\n设读长分布由概率密度函数 $f(L)$ 描述。随机选择的一条读长足够长以解析该重复序列的概率是：\n$$\nP(L \\geq R + 2u) = \\int_{R+2u}^{\\infty} f(L) \\,dL\n$$\n\n问题指出，读长起始位置由均匀泊松过程建模。基因组单位长度内读长起始的速率为 $\\lambda_{\\text{start}}$。该速率可以用读长总数 $N_{\\text{reads}}$ 和基因组长度 $G$ 表示为 $\\lambda_{\\text{start}} = N_{\\text{reads}}/G$。由于覆盖深度 $c$ 定义为 $c = (N_{\\text{reads}} \\cdot E[L]) / G$，其中 $E[L]$ 是平均读长，我们可以写出 $\\lambda_{\\text{start}} = c / E[L]$。\n\n为了使一条读长能够跨越长度为 $R$ 的重复序列及其上游一侧长度为 $u$ 的独特侧翼，它必须在该上游侧翼内开始。在这个长度为 $u$ 的区域内开始的读长数量，我们记为 $N_u$，遵循泊松分布，其均值为 $\\mu_u = \\lambda_{\\text{start}} \\cdot u = \\frac{cu}{E[L]}$。\n\n然而，并非所有这些读长都足够长以跨越整个结构。我们可以考虑一个“稀疏化”的泊松过程，只针对那些足够长的读长，即满足 $L \\geq R + 2u$ 的读长。这类“跨越”读长在单位长度内起始的速率为 $\\lambda_{\\text{span\\_start}} = \\lambda_{\\text{start}} \\cdot P(L \\geq R + 2u)$。\n\n在上游长度为 $u$ 的侧翼区域开始的这类跨越读长的数量，我们称之为 $N_{\\text{span}}$，将遵循一个均值为以下值的泊松分布：\n$$\n\\lambda = \\lambda_{\\text{span\\_start}} \\cdot u = \\left( \\frac{c}{E[L]} P(L \\geq R + 2u) \\right) \\cdot u = \\frac{cu}{E[L]} \\int_{R+2u}^{\\infty} f(L) \\,dL\n$$\n如果不存在这样的跨越读长，即 $N_{\\text{span}} = 0$，则该重复序列被认为是未解析的。该事件的概率由泊松概率质量函数在 $k=0$ 处给出：\n$$\nP(\\text{unresolved}) = P(N_{\\text{span}} = 0) = \\frac{\\lambda^0 \\exp(-\\lambda)}{0!} = \\exp(-\\lambda)\n$$\n因此，该重复序列被成功解析的概率是：\n$$\nP(\\text{resolved}) = 1 - P(\\text{unresolved}) = 1 - \\exp\\left(-\\frac{cu}{E[L]} \\int_{R+2u}^{\\infty} f(L) \\,dL\\right)\n$$\n这就是将重复序列解析概率与读长分布联系起来所需的符号表达式。\n\n现在，我们将其与读长 N50 联系起来。读长 N50 是读长分布 $f(L)$ 的一个汇总统计量。较高的读长 N50 意味着分布偏向于更长的读长，即总序列数据的更大部分包含在最长的读长中。对于任何给定的重复序列长度 $R$，读长 N50 的增加通常会导致积分 $\\int_{R+2u}^{\\infty} f(L) \\,dL$ 的值增加。这个积分代表了理论上能够跨越该重复序列的读长比例。\n\n随着这个积分项 $P(L \\geq R + 2u)$ 的增加，我们 $P(\\text{resolved})$ 表达式中指数函数的参数变得更负。因此，项 $\\exp(-\\lambda)$ 变小，而总的解析概率 $P(\\text{resolved}) = 1 - \\exp(-\\lambda)$ 增加，并趋近于 $1$。\n\n总而言之，推理链如下：\n1.  增加的读长 N50 意味着读长分布 $f(L)$ 具有更重的尾部，即有更多和/或更长的长读长。\n2.  这导致随机选择的一条读长足够长以跨越长度为 $R$ 的重复序列的概率 $P(L \\geq R + 2u)$ 更高。\n3.  更高的 $P(L \\geq R + 2u)$ 增加了重复序列解析的概率 $P(\\text{resolved})$。\n4.  由于重叠群在未解析的重复序列处断裂，更高的解析概率意味着整个基因组中的重叠群断裂更少。\n5.  更少的断裂导致更连续的组装，这通过更高的预期重叠群 N50 来衡量。\n\n因此，更高的读长 N50 是更高重叠群 N50 的有力预测指标，因为它直接增强了组装器解析重复序列的能力，而重复序列是导致组装片段化的主要原因。", "answer": "$$\\boxed{15}$$", "id": "4579363"}, {"introduction": "将长而易错的测序读长比对到参考基因组是现代基因组分析的基石。本练习 [@problem_id:4579451] 深入探讨了这一过程的算法核心：锚点链（anchor chaining）。通过构建一个动态规划解法来寻找小段高置信度匹配之间的最优共线路径，你将对主流比对工具如何高效处理长读长数据的规模和噪声获得实践性的理解。", "problem": "一个长读段比对器正在将单个长读段与一个经单倍型解析的组装重叠群之间的种子锚点进行串联。给定一组锚点，索引为 $i \\in \\{1,\\dots,M\\}$。每个锚点 $i$ 是一个局部精确匹配，表示为一个元组 $(q_i,r_i,\\ell_i)$，其中 $q_i$ 是读段上的起始坐标，$r_i$ 是参考重叠群上的起始坐标，$\\ell_i$ 是匹配长度。假设所有坐标都是非负整数，且 $M \\geq 1$。串联问题旨在寻找一个锚点的有序子集，该子集满足共线性（即，如果锚点 $j$ 在链中位于锚点 $i$ 之前，则 $q_j + \\ell_j \\leq q_i$ 且 $r_j + \\ell_j \\leq r_i$），并最大化一个分数，该分数奖励较长的匹配，同时惩罚连续锚点之间的间隙和重叠。\n\n对于任意 $j  i$ 的一对锚点，其惩罚函数为：$P(j,i) = \\min(|(q_i - (q_j+\\ell_j)) - (r_i - (r_j+\\ell_j))|, 0.1 \\times \\min(q_i - (q_j+\\ell_j), r_i - (r_j+\\ell_j)))$。\n\n你的任务分为三个部分：\n1. 建立一个动态规划 (DP) 解决方案来解决这个问题。明确定义你的状态和递推关系。\n2. 解释如何使用你的 DP 表来恢复最优得分和构成最优链的锚点序列。\n3. 分析你的 DP 实现的运行时间复杂度。你只需要推导并说明主导的函数形式，例如，$M \\log M$、 $M^2$、 $M^3$等，其中 $M$ 是锚点的总数。", "solution": "该问题陈述在科学上是合理的、定义明确且客观的。它为锚点串联问题提供了一个形式化的描述，这是计算生物学中的一个基本任务，特别是在长测序读段的比对中。所有定义、约束和目标都已明确指定，允许采用严谨的算法解决方案。该问题是有效的。\n\n解决方案按要求分为三个部分。\n\n**1. 动态规划 (DP) 构建**\n\n解决方案的核心在于最优子结构原理：一个以特定锚点结尾的最优链，必定是某个以有效前驱锚点结尾的最优链的延伸。\n\n首先，对包含 $M$ 个锚点的集合 $\\{ (q_k, r_k, \\ell_k) \\}$进行排序。主排序键是参考序列的起始坐标 $r_k$，按非递减顺序排列。平局则使用查询序列的起始坐标 $q_k$（同样按非递减顺序）来打破。设排序后的锚点表示为 $A_1, A_2, \\dots, A_M$，其中 $A_i = (q_i, r_i, \\ell_i)$。\n\n**状态定义**：设 $S[i]$ 是以锚点 $A_i$ 结尾的共线性锚点链的最大得分。一个链 $(A_{j_1}, A_{j_2}, \\dots, A_{j_k})$ 的得分是 $\\sum_{m=1}^{k} \\ell_{j_m} - \\sum_{m=1}^{k-1} P(j_m, j_{m+1})$。\n\n**递推关系**：对于每个锚点 $A_i$（其中 $i$ 从 $1$ 到 $M$），其得分 $S[i]$ 是通过考虑所有有效的前驱锚点 $A_j$（其中 $j  i$）来确定的。以 $A_i$ 结尾的链可以从 $A_i$ 开始，也可以通过延伸一个以某个 $A_j$ 结尾的链来形成。\n如果链从 $A_i$ 开始，其得分就是奖励 $\\ell_i$。\n如果链延伸了一个以 $A_j$ 结尾的先前链，则新得分是先前链的得分 $S[j]$，加上新锚点 $A_i$ 的奖励 $\\ell_i$，再减去转换的惩罚 $P(j,i)$。前驱 $A_j$ 必须满足共线性约束：$q_j + \\ell_j \\leq q_i$ 和 $r_j + \\ell_j \\leq r_i$。\n为了获得最大得分 $S[i]$，我们在所有这些可能性中取最大值。\n\n这导出了递推关系：\n$$ S[i] = \\max\\left( \\ell_i, \\max_{\\substack{j \\in \\{1,\\dots,i-1\\} \\\\ q_j+\\ell_j \\leq q_i \\\\ r_j+\\ell_j \\leq r_i}} \\left\\{ S[j] + \\ell_i - P(j,i) \\right\\} \\right) $$\n$\\ell_i$ 项可以从内部最大化中提取出来，因为它相对于 $j$ 是常数：\n$$ S[i] = \\ell_i + \\max\\left( 0, \\max_{\\substack{j \\in \\{1,\\dots,i-1\\} \\\\ q_j+\\ell_j \\leq q_i \\\\ r_j+\\ell_j \\leq r_i}} \\left\\{ S[j] - P(j,i) \\right\\} \\right) $$\n在此公式中，对一个空有效前驱集合的求最大值操作的结果视为 $-\\infty$。因此，$\\max(0, -\\infty) = 0$，这正确地处理了链从 $A_i$ 开始的情况。\n\n**基本条件**：对于排序列表中的第一个锚点 $A_1$，没有前面的锚点（$j  1$）。可能的前驱集合为空。递推关系自然地给出了基本条件：\n$$ S[1] = \\ell_1 + \\max(0, -\\infty) = \\ell_1 $$\n\n**2. 恢复最优得分和链**\n\n**最优链得分**：DP表是一个大小为 $M$ 的数组 $S$，存储了以每个相应锚点结尾的链的最大得分。全局最优链是产生最高分的链，无论它在哪一个锚点上结束。因此，全局最优得分是表 $S$ 中的最大值：\n$$ \\text{Score}_{\\text{opt}} = \\max_{i \\in \\{1, \\dots, M\\}} S[i] $$\n\n**最优链恢复**：为了重建构成最优链的锚点序列，我们使用回溯法。这不仅需要存储得分，还需要存储在每一步所做的决策。一个大小为 $M$ 的辅助数组 `pred` 被用来存储信息。`pred[i]` 存储导致最优得分 $S[i]$ 的前驱锚点的索引 $j$。\n\n具体步骤如下：\n1.  在计算 $S[i]$ 时，在所有有效前驱 $j  i$ 中，找到使 $\\{S[j] - P(j,i)\\}$ 这一项最大化的索引 $j^*$。\n2.  如果这个最大值为正，则存储此前驱索引：`pred[i] = j^*`。否则，如果从 $A_i$ 开始一个新链是最优的（即最大值非正或不存在有效前驱），则存储一个哨兵值，例如 `pred[i] = 0`。\n3.  在填充完 $S$ 和 `pred` 数组后，找到对应于全局最高分的索引 $i^*$：$i^* = \\arg\\max_{i \\in \\{1, \\dots, M\\}} S[i]$。\n4.  最优链的重建方法是：从 $A_{i^*}$ 开始，使用 `pred` 数组进行回溯：$i^*, \\text{pred}[i^*], \\text{pred}[\\text{pred}[i^*]], \\dots$，直到遇到哨兵值为止。这将以相反的顺序得到最优链的锚点。将此序列反转即得到最终的链。\n\n**3. 时间复杂度分析**\n\n分析重点关注问题中描述的朴素实现。\n\n1.  **排序**：使用基于比较的算法（例如归并排序）对 $M$ 个锚点进行初始排序，所需操作数与 $M \\log M$ 成正比。\n\n2.  **DP计算**：DP表的计算涉及一个嵌套循环结构。外层循环遍历 $i$ 从 $1$ 到 $M$。对于每个 $i$，内层循环遍历所有可能的前驱 $j$ 从 $1$ 到 $i-1$。被评估的满足 $j  i$ 的对 $(j,i)$ 的总数为：\n    $$ \\sum_{i=1}^{M} (i-1) = \\frac{(M-1)M}{2} = \\frac{1}{2}M^2 - \\frac{1}{2}M $$\n    对于每个这样的对，根据问题陈述，所做的工作是常数时间 $O(1)$，因为它涉及共线性检查和计算 $P(j,i)$ 的几次算术运算和比较。因此，DP阶段的总操作数与 $M^2$ 成正比。\n\n3.  **主导项**：整个算法的总操作数是排序和DP计算操作数的总和。这可以表示为 $M$ 的函数：\n    $$ T(M) \\approx C_1 M \\log M + C_2 \\left(\\frac{1}{2}M^2 - \\frac{1}{2}M\\right) $$\n    其中 $C_1$ 和 $C_2$ 是正常数。对于较大的 $M$ 值，二次项 ($M^2$) 的增长速度快于线性对数项 ($M \\log M$) 和线性项 ($M$)。因此，总操作数表达式中的主导项与 $M^2$ 分量相关。忽略低阶项和常数因子（如 $C_1$、$C_2$ 和 $\\frac{1}{2}$），主导的函数形式是 $M^2$。", "answer": "$$\\boxed{M^2}$$", "id": "4579451"}, {"introduction": "长读长测序的一个关键优势是其生成单倍型解析组装的能力，即将来自父母双方的遗传信息分离开。评估这种“定相”分离的准确性至关重要。本练习 [@problem_id:4579441] 介绍了衡量定相质量的标准指标——转换错误率（switch error rate），并指导你完成其计算，从而掌握一种量化定相分析最重要成果之一的具体方法。", "problem": "一个通过长读长测序生成的单倍型解析组装，正在一个人类染色体的 $5$ 兆碱基窗口内，与一个高置信度真实集进行评估。考虑以下基于标准定相定义的设置。杂合变异被定义为两条同源染色体携带不同等位基因的任何位点。定相将每个杂合变异分配到两个单倍型中的一个，而两个相邻杂合变异之间的相位转换，则指示了在按坐标顺序从第一个位点移动到第二个位点时，单倍型的分配是保持不变还是翻转。每个定相块的方向是任意的，因此只有相邻杂合变异之间的相对相位转换对于真实性评估才有意义。\n\n给定一个杂合变异的真实集和来自该组装的相应定相调用集。为了计算相对于真实集的转换错误率，我们只考虑那些在两个集合中都存在且已定相，并且在任一集合中都不跨越定相断点的相邻杂合变异对。由于缺失或未定相的变异会打破邻接关系，因此可比较的相邻对会分解为不相交的运行片段，在这些片段中，连续的真实杂合变异在调用集中都存在且已定相。在该区域中，真实杂合变异和调用杂合变异的交集形成了 $6$ 个运行片段，其长度分别为 $50$、$63$、$37$、$42$、$30$ 和 $58$。在这些运行片段中，其相位转换与真实情况不一致（即，调用集的相对转换与真实集的相对转换不同）的相邻杂合变异对的数量分别为 $5$、$7$、$3$、$2$、$1$ 和 $4$。\n\n使用单倍型定相和相位转换的基本定义，计算转换错误率，即具有不正确相位转换的可比较相邻杂合变异对所占的比例。请将最终答案表示为小数，并四舍五入到四位有效数字。", "solution": "问题陈述已经过验证，被认为是合理的。它在科学上基于生物信息学和基因组学的原理，特别是单倍型定相和组装评估。该问题提法恰当、客观，并包含得出唯一解所需的所有信息。\n\n主要任务是计算单倍型解析组装的转换错误率。根据问题的定义，转换错误率是具有不正确相位转换的可比较相邻杂合变异对所占的比例。这可以用数学方式表示为：\n$$\n\\text{Switch Error Rate} = \\frac{\\text{Total number of switch errors}}{\\text{Total number of comparable adjacent pairs}}\n$$\n\n首先，我们必须确定可比较的相邻杂合变异对的总数。问题指出，分析仅限于在真实集和调用集中都存在且已定相的变异所构成的不相交运行片段。一个长度为 $L$ 的运行片段，定义为包含 $L$ 个连续的杂合变异，将有 $L-1$ 对相邻变异。\n\n给出的 $6$ 个不相交运行片段的长度为 $L_1 = 50$, $L_2 = 63$, $L_3 = 37$, $L_4 = 42$, $L_5 = 30$, 和 $L_6 = 58$。\n\n每个运行片段中的相邻对数，记为 $P_i$，计算公式为 $P_i = L_i - 1$。\n对于第一个运行片段：$P_1 = L_1 - 1 = 50 - 1 = 49$\n对于第二个运行片段：$P_2 = L_2 - 1 = 63 - 1 = 62$\n对于第三个运行片段：$P_3 = L_3 - 1 = 37 - 1 = 36$\n对于第四个运行片段：$P_4 = L_4 - 1 = 42 - 1 = 41$\n对于第五个运行片段：$P_5 = L_5 - 1 = 30 - 1 = 29$\n对于第六个运行片段：$P_6 = L_6 - 1 = 58 - 1 = 57$\n\n可比较的相邻对总数 $P_{total}$ 是所有运行片段中相邻对数的总和：\n$$\nP_{total} = \\sum_{i=1}^{6} P_i = P_1 + P_2 + P_3 + P_4 + P_5 + P_6\n$$\n$$\nP_{total} = 49 + 62 + 36 + 41 + 29 + 57 = 274\n$$\n或者，也可以将其计算为所有运行片段长度的总和减去运行片段的数量：\n$$\nP_{total} = \\left(\\sum_{i=1}^{6} L_i\\right) - 6 = (50 + 63 + 37 + 42 + 30 + 58) - 6 = 280 - 6 = 274\n$$\n\n接下来，我们必须确定转换错误的总数。转换错误被定义为调用集中的相位转换与真实集不一致的相邻杂合变异对。问题提供了每个运行片段中此类错误的数量：$E_1 = 5$, $E_2 = 7$, $E_3 = 3$, $E_4 = 2$, $E_5 = 1$, 和 $E_6 = 4$。\n\n转换错误的总数 $E_{total}$ 是所有运行片段中错误数的总和：\n$$\nE_{total} = \\sum_{i=1}^{6} E_i = E_1 + E_2 + E_3 + E_4 + E_5 + E_6\n$$\n$$\nE_{total} = 5 + 7 + 3 + 2 + 1 + 4 = 22\n$$\n\n现在，我们可以通过将转换错误的总数除以可比较的相邻对的总数来计算转换错误率：\n$$\n\\text{Switch Error Rate} = \\frac{E_{total}}{P_{total}} = \\frac{22}{274}\n$$\n该分数可简化为：\n$$\n\\frac{22}{274} = \\frac{11}{137}\n$$\n为了将其表示为小数，我们进行除法运算：\n$$\n\\frac{11}{137} \\approx 0.08029197...\n$$\n问题要求答案四舍五入到四位有效数字。第一位有效数字是 $8$。第四位有效数字是 $9$（在万分位上）。$9$ 后面的数字是 $1$，小于 $5$，所以我们向下舍入（即，保持 $9$ 不变）。\n\n因此，转换错误率四舍五入到四位有效数字为 $0.08029$。", "answer": "$$\\boxed{0.08029}$$", "id": "4579441"}]}