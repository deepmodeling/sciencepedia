{"hands_on_practices": [{"introduction": "为了有效地利用Burrows-Wheeler变换（BWT），我们必须首先从其基本原理出发，理解其构建过程。本练习将引导您手动完成生成文本的循环旋转、按字典序排序，并最终提取BWT字符串（$L$）和主索引（$p$）的完整流程。掌握这一基础构建方法[@problem_id:4573278]是理解BWT如何可逆地重排文本的关键，而这正是其在压缩索引中发挥强大作用的基石。", "problem": "考虑一个文本 $T$，它作用于 DNA 字母表，该字母表用一个唯一的哨兵符号 $\\$$ 进行了扩展，该符号在字典序上小于任何核苷酸。Burrows–Wheeler 变换（BWT）根据第一性原理定义如下：给定一个以哨兵符号 $\\$$ 结尾的文本 $T$，生成 $T$ 的所有循环旋转，在全序关系 $\\$ \\prec \\text{A} \\prec \\text{C} \\prec \\text{G} \\prec \\text{T}$ 下对这些旋转进行字典序排序，并将每个排好序的旋转的最后一个字符收集到一个字符串 $L$ 中，这个字符串 $L$ 就是 $T$ 的 BWT。主索引 $p$ 被定义为原始文本 $T$ 在字典序排序的旋转矩阵中的从零开始的行索引。在基于索引的序列比对中，Ferragina–Manzini 索引（FM-index）使用 $L$ 和 $p$ 来支持在 $T$ 上进行高效的反向搜索，以用于读段映射。\n\n设 $T = \\text{AGGAGA}\\$$，哨兵符号 $\\$$ 在 $T$ 的末尾仅出现一次，并采用全序关系 $\\$ \\prec \\text{A} \\prec \\text{C} \\prec \\text{G} \\prec \\text{T}$。严格根据上述核心定义，构建 $T$ 的完整循环旋转矩阵，对旋转进行字典序排序，并计算 BWT 的最后一列 $L$。找出主索引 $p$，即 $T$ 在排序后的旋转矩阵中的从零开始的位置。在你的推导过程中明确展示排序后的旋转矩阵以及得到的最后一列 $L$。\n\n将主索引 $p$ 作为你的最终数值答案报告。请提供精确的整数，无需四舍五入。", "solution": "该问题是有效的，因为它具有科学依据、问题提出得当且客观。它提出了一个生物信息学中的标准任务——使用清晰、正式的定义为给定文本计算 Burrows-Wheeler 变换（BWT）和主索引。所有必要的信息都已提供，并且该任务是所定义算法的直接应用。\n\n问题要求计算文本 $T = \\text{AGGAGA}\\$$ 的主索引 $p$。我们将遵循所提供的定义来构建 BWT 并找到 $p$。\n\n给定的文本是 $T = \\text{AGGAGA}\\$，其长度为 $n=7$。字母表为 $\\{\\$, \\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$，指定的字典全序为 $\\$ \\prec \\text{A} \\prec \\text{C} \\prec \\text{G} \\prec \\text{T}$。\n\n首先，我们生成文本 $T$ 的所有 $n=7$ 个循环旋转。我们将以 $T$ 的第 $i$ 个字符（从零开始的索引为 $i-1$）开始的旋转表示为 $R_i$。\n\n未排序的旋转列表如下：\n- $R_1: \\text{AGGAGA}\\$$\n- $R_2: \\text{GGAGA\\$A}$\n- $R_3: \\text{GAGA\\$AG}$\n- $R_4: \\text{AGA\\$AGG}$\n- $R_5: \\text{GA\\$AGGA}$\n- $R_6: \\text{A\\$AGGAG}$\n- $R_7: \\text{\\$AGGAGA}$\n\n接下来，我们根据 $\\$ \\prec \\text{A} \\prec \\text{G}$ 的顺序对这些旋转进行字典序排序。这就得到了排序后的旋转矩阵。我们同时确定第一列 $F$ 和最后一列 $L$。\n\n排序过程如下：\n1.  以 $\\$$ 开始的旋转在字典序上是最小的：`\\$AGGAGA`。\n2.  接下来是 `A` 开头的旋转。我们比较 `A$AGGAG`、`AGA$AGG` 和 `AGGAGA$`。根据第二个字符，`A$AGGAG` 排在最前面。比较 `AGA$AGG` 和 `AGGAGA$`，第三个字符分别是 `A` 和 `G`。由于 `A` $\\prec$ `G`，所以 `AGA$AGG` 在 `AGGAGA$` 之前。\n3.  最后，我们对以 `G` 开头的旋转进行排序：`GGAGA$A`、`GAGA$AG`、`GA$AGGA`。根据第二个字符，`GA$AGGA` 和 `GAGA$AG` 在 `GGAGA$A` 之前。比较 `GA$AGGA` 和 `GAGA$AG`，第三个字符分别是 `$` 和 `G`。由于 `$` $\\prec$ `G`，所以 `GA$AGGA` 在 `GAGA$AG` 之前。\n\n这就得到了以下排序后的旋转矩阵。该矩阵的最后一列就是 BWT 字符串 $L$。\n\n$$\n\\begin{array}{c|c|c}\n\\text{索引 } (i) & \\text{排序后的旋转} & \\text{最后一个字符 } (L[i]) \\\\\n\\hline\n0 & \\text{\\$AGGAGA} & \\text{A} \\\\\n1 & \\text{A\\$AGGAG} & \\text{G} \\\\\n2 & \\text{AGA\\$AGG} & \\text{G} \\\\\n3 & \\text{AGGAGA\\$} & \\$ \\\\\n4 & \\text{GA\\$AGGA} & \\text{A} \\\\\n5 & \\text{GAGA\\$AG} & \\text{G} \\\\\n6 & \\text{GGAGA\\$A} & \\text{A} \\\\\n\\end{array}\n$$\n\n从表中可以看出，BWT 的最后一列是 $L = \\text{AGG\\$AGA}$。\n\n主索引 $p$ 被定义为原始文本 $T$ 在排序后的旋转矩阵中的从零开始的行索引。原始文本是 $T = \\text{AGGAGA}\\$。观察排序后的矩阵，我们发现该字符串位于从零开始的索引为 $3$ 的行。\n\n因此，主索引是 $p=3$。", "answer": "$$\\boxed{3}$$", "id": "4573278"}, {"introduction": "在掌握了BWT的构建之后，其真正的实用价值体现在能够实现快速序列比对的FM索引中。本实践的核心是利用一个完整的FM索引来执行后向搜索，这是一种在参考序列中查找查询序列所有精确匹配的核心算法。通过手动识别最大精确匹配（MEMs）和超大最大精确匹配（SMEMs）[@problem_id:4573270]，您将对现代序列比对工具如何在基因组中高效定位保守区域获得深刻的实践理解。", "problem": "在基于索引的序列比对中，一项核心任务是使用 Ferragina–Manzini 指数（FM-index）来刻画查询序列和参考序列之间的精确匹配。FM-index 源自 Burrows–Wheeler 变换（BWT）和后缀数组。考虑一个在 DNA 字母表上的参考基因组字符串 $T$，该字符串增补了一个唯一的文本结束标记符号 `$`，该符号在字典序上小于任何 DNA 字符。设 $T = \\texttt{ATATAT\\$}$，查询字符串 $Q = \\texttt{TATATAT}$。\n\n从标准定义开始：\n- $T$ 的后缀数组 $\\mathrm{SA}$ 是 $T$ 的所有后缀按字典序排序后，其起始位置构成的数组。\n- $T$ 的 Burrows–Wheeler 变换 (BWT) 是一个数组，其第 $k$ 个条目是 $T$ 中位于 $\\mathrm{SA}[k]$ 处后缀的前一个字符，其中 $T[-1]$ 被解释为 $T[|T|-1]=\\texttt{\\$}$。\n- FM-index 由一个对 $(C, \\mathrm{Occ})$ 组成，其中 $C[c]$ 是 $T$ 中字典序上小于 $c$ 的字符总数，而 $\\mathrm{Occ}(c, k)$ 统计字符 $c$ 在 $\\mathrm{BWT}$ 的前 k 个字符（即 BWT[0..k-1]）中出现的次数。后向搜索通过在模式 $P$ 前添加一个字符 $c$ 来扩展当前区间 $[l, r)$，其规则如下：\n$$\nl' = C[c] + \\mathrm{Occ}(c, l), \\quad r' = C[c] + \\mathrm{Occ}(c, r).\n$$\n- $Q$ 和 $T$ 之间的一个最大精确匹配（MEM）是一个子串 $Q[i..j]$，它在 $T$ 中出现（即，具有一个非空的 FM-index 区间），并且使用 $Q$ 中的相应字符向左（当 $i>0$ 时扩展到 $Q[i-1..j]$）或向右（当 $j+1|Q|$ 时扩展到 $Q[i..j+1]$）扩展 $Q[i..j]$ 都会产生一个空的 FM-index 区间。换言之，该子串无法在任一方向上扩展而不失去其精确匹配的性质。\n- 一个超级最大精确匹配（SMEM）是一个精确匹配，它就查询坐标而言，不被包含在任何其他同样在 $T$ 中出现的精确匹配内部。\n\n任务：\n1. 计算给定 $T$ 的 $\\mathrm{SA}$ 和 $\\mathrm{BWT}$。\n2. 构建 $C$ 表并为 $c \\in \\{\\texttt{\\$}, \\texttt{A}, \\texttt{T}\\}$ 和 $k \\in \\{0,1,\\dots,|T|\\}$ 列表计算 $\\mathrm{Occ}(c, k)$。\n3. 使用 FM-index 上的后向搜索，通过区间扩展计算 $Q$ 和 $T$ 之间的所有 MEMs $Q[i..j]$，明确展示每一步的第一个非空区间，以及在达到最大性时左右扩展的失败情况。\n4. 从 MEMs 集合中，通过验证 $Q$ 中精确匹配之间的包含关系来识别所有 SMEMs。\n5. 令 $L_{\\mathrm{SMEM}}$ 为在给定 $T$ 的情况下，在 $Q$ 中找到的所有不同 SMEMs 的长度之和。计算 $L_{\\mathrm{SMEM}}$。\n\n给出 $L_{\\mathrm{SMEM}}$ 的最终数值答案，不进行四舍五入，不带单位。所有中间的数学对象和计算都必须根据上述基础定义进行充分论证，并且所有步骤都必须科学上一致且自洽。", "solution": "该问题具有科学依据、良构、客观且自洽，为获得唯一解提供了所有必要的定义和数据。它基于生物信息学的既定原则，特别是基于索引的序列比对。因此，该问题是有效的。\n\n参考基因组为 $T = \\texttt{ATATAT\\$}$，其长度 $|T|=7$。查询字符串为 $Q = \\texttt{TATATAT}$，其长度 $|Q|=7$。字母表为 $\\Sigma = \\{\\texttt{\\$}, \\texttt{A}, \\texttt{T}\\}$，其字典序为 $\\texttt{\\$} \\prec \\texttt{A} \\prec \\texttt{T}$。\n\n**1. 后缀数组（$SA$）和 Burrows–Wheeler 变换（$BWT$）的计算**\n\n首先，我们列出 $T$ 的所有后缀及其起始位置（0-索引）。\n\\begin{itemize}\n    \\item $0$: $\\texttt{ATATAT\\$}$\n    \\item $1$: $\\texttt{TATAT\\$}$\n    \\item $2$: $\\texttt{ATAT\\$}$\n    \\item $3$: $\\texttt{TAT\\$}$\n    \\item $4$: $\\texttt{AT\\$}$\n    \\item $5$: $\\texttt{T\\$}$\n    \\item $6$: $\\texttt{\\$}$\n\\end{itemize}\n接下来，我们按字典序对这些后缀进行排序：\n\\begin{enumerate}\n    \\item $\\texttt{\\$}$ (来自索引 $6$)\n    \\item $\\texttt{AT\\$}$ (来自索引 $4$)\n    \\item $\\texttt{ATAT\\$}$ (来自索引 $2$)\n    \\item $\\texttt{ATATAT\\$}$ (来自索引 $0$)\n    \\item $\\texttt{T\\$}$ (来自索引 $5$)\n    \\item $\\texttt{TAT\\$}$ (来自索引 $3$)\n    \\item $\\texttt{TATAT\\$}$ (来自索引 $1$)\n\\end{enumerate}\n后缀数组 $SA$ 是排序后后缀的起始位置数组。\n$$ SA = [6, 4, 2, 0, 5, 3, 1] $$\nBurrows–Wheeler 变换 $BWT$ 的构造方式为 $BWT[k] = T[SA[k]-1]$。索引 $-1$ 处的字符被定义为 $T$ 的最后一个字符，即 $T[6] = \\texttt{\\$}$。\n\\begin{itemize}\n    \\item $BWT[0] = T[SA[0]-1] = T[6-1] = T[5] = \\texttt{T}$\n    \\item $BWT[1] = T[SA[1]-1] = T[4-1] = T[3] = \\texttt{T}$\n    \\item $BWT[2] = T[SA[2]-1] = T[2-1] = T[1] = \\texttt{T}$\n    \\item $BWT[3] = T[SA[3]-1] = T[0-1] = T[6] = \\texttt{\\$}$\n    \\item $BWT[4] = T[SA[4]-1] = T[5-1] = T[4] = \\texttt{A}$\n    \\item $BWT[5] = T[SA[5]-1] = T[3-1] = T[2] = \\texttt{A}$\n    \\item $BWT[6] = T[SA[6]-1] = T[1-1] = T[0] = \\texttt{A}$\n\\end{itemize}\n因此，$T$ 的 BWT 为：\n$$ BWT = \\texttt{TTT\\$AAA} $$\n\n**2. $C$ 表和 $\\mathrm{Occ}$ 的构建**\n\n$C$ 表存储 $T$ 中字典序上小于给定字符 $c$ 的字符总数。$T=\\texttt{ATATAT\\$}$ 中的字符计数为：$\\texttt{\\$}$ 有 $1$ 个，$\\texttt{A}$ 有 $3$ 个，$\\texttt{T}$ 有 $3$ 个。\n\\begin{itemize}\n    \\item $C[\\texttt{\\$}] = 0$\n    \\item $C[\\texttt{A}] = \\text{count}(\\texttt{\\$}) = 1$\n    \\item $C[\\texttt{T}] = \\text{count}(\\texttt{\\$}) + \\text{count}(\\texttt{A}) = 1 + 3 = 4$\n\\end{itemize}\n$\\mathrm{Occ}(c, k)$ 函数统计字符 $c$ 在前缀 $BWT[0..k-1]$ 中的出现次数。我们将其对于 $k$ 从 $0$ 到 $7$ 的值制成表格。\n$$ BWT = [\\texttt{T}_0, \\texttt{T}_1, \\texttt{T}_2, \\texttt{\\$}_3, \\texttt{A}_4, \\texttt{A}_5, \\texttt{A}_6] $$\n$\\mathrm{Occ}$ 表如下：\n\\begin{array}{c|c|c|c}\nk  \\mathrm{Occ}(\\texttt{\\$}, k)  \\mathrm{Occ}(\\texttt{A}, k)  \\mathrm{Occ}(\\texttt{T}, k) \\\\\n\\hline\n0  0  0  0 \\\\\n1  0  0  1 \\\\\n2  0  0  2 \\\\\n3  0  0  3 \\\\\n4  1  0  3 \\\\\n5  1  1  3 \\\\\n6  1  2  3 \\\\\n7  1  3  3 \\\\\n\\end{array}\n\n**3. 最大精确匹配（MEMs）的识别**\n\nMEM 是一个在 $T$ 中出现的子串 $Q[i..j]$，但 $Q[i-1..j]$（当 $i0$ 时）和 $Q[i..j+1]$（当 $j+1|Q|$ 时）均不在 $T$ 中出现。我们通过检查所有精确匹配的最大性条件来识别 MEM。一个精确匹配是具有非空 FM-index 区间 $[l, r)$（其中 $r  l$）的子串。任何搜索的初始区间都是 $[0, |T|) = [0, 7)$。\n\n让我们从 $Q$ 的最长子串开始测试候选 MEM。\n首先，我们需要知道 $Q$ 的哪些子串是 $T$ 中的精确匹配。我们使用后向搜索。\n- $Q[0..6] = \\texttt{TATATAT}$：搜索 $\\texttt{T}$，然后是 $\\texttt{A}$，依此类推。反向 $Q$ 的最长匹配前缀是 $\\texttt{ATATAT}$。\n搜索 $\\texttt{ATATAT}$：从 $\\texttt{T}$（$[4,7)$）开始，`AT`（$[1,4)$），`TAT`（$[5,7)$），`ATAT`（$[2,4)$），`TATAT`（$[6,7)$），`ATATAT`（$[3,4)$）。它是一个匹配。\n为了找到 $\\texttt{TATATAT}$，我们用 $\\texttt{T}$ 扩展 $\\texttt{ATATAT}$（区间 $[3,4)$）：\n$l' = C[\\texttt{T}] + \\mathrm{Occ}(\\texttt{T}, 3) = 4 + 3 = 7$\n$r' = C[\\texttt{T}] + \\mathrm{Occ}(\\texttt{T}, 4) = 4 + 3 = 7$\n新的区间是 $[7,7)$，是空的。因此，$\\texttt{TATATAT}$ 不是一个精确匹配。\n- $Q[0..5]=\\texttt{TATATA}$:\n搜索 $\\texttt{A}$，然后是 $\\texttt{T}$，...，$\\texttt{T}$。反向 $Q[0..5]$ 的最长匹配前缀是 $\\texttt{ATATA}$。\n搜索 $\\texttt{ATATA}$：`A`（$[1,4)$），`TA`（$[5,7)$），`ATA`（$[2,4)$），`TATA`（$[6,7)$），`ATATA`（$[3,4)$）。它是一个匹配。\n为了找到 $\\texttt{TATATA}$，我们用 $\\texttt{T}$ 扩展 $\\texttt{ATATA}$（区间 $[3,4)$）：\n$l' = C[\\texttt{T}] + \\mathrm{Occ}(\\texttt{T}, 3) = 4 + 3 = 7$\n$r' = C[\\texttt{T}] + \\mathrm{Occ}(\\texttt{T}, 4) = 4 + 3 = 7$\n新的区间是 $[7,7)$，是空的。因此，$\\texttt{TATATA}$ 不是一个精确匹配。\n\n现在我们检查 $Q$ 中子串的出现是否具有 MEM 属性。\n\n候选 1: $M_1 = Q[1..6] = \\texttt{ATATAT}$。\n- 这是一个精确匹配，如上所示，区间为 $[3,4)$。\n- 左侧扩展（$i=10$）：在前面加上 $Q[0]=\\texttt{T}$ 得到 $Q[0..6]=\\texttt{TATATAT}$。我们发现这不是一个精确匹配。左侧扩展失败。\n- 右侧扩展（$j=6, j+1 = |Q|$）：不适用，因为它位于 $Q$ 的末尾。\n- 结论：$Q[1..6] = \\texttt{ATATAT}$ 是一个 MEM。\n\n候选 2: $M_2 = Q[0..4] = \\texttt{TATAT}$。\n- 对 $\\texttt{TATAT}$ 进行后向搜索：我们发现其区间为 $[6,7)$，因此它是一个精确匹配。\n- 左侧扩展（$i=0$）：不适用。\n- 右侧扩展（$j=4, j+1  |Q|$）：追加 $Q[5]=\\texttt{A}$ 得到 $Q[0..5]=\\texttt{TATATA}$。我们发现这不是一个精确匹配。右侧扩展失败。\n- 结论：$Q[0..4] = \\texttt{TATAT}$ 是一个 MEM。\n\n其他子串不是 MEMs，因为它们可以被扩展。例如，考虑 $Q[2..6]=\\texttt{TATAT}$。\n- 这是一个精确匹配。\n- 左侧扩展（$i=20$）：在前面加上 $Q[1]=\\texttt{A}$ 得到 $Q[1..6]=\\texttt{ATATAT}$。这是一个精确匹配。\n- 由于它可以向左扩展，$Q[2..6]=\\texttt{TATAT}$ 不是一个 MEM。\n\nMEMs 的集合由两个字符串组成，基于它们在 $Q$ 中的出现位置：$\\{\\texttt{ATATAT} \\text{ 在 } Q[1..6], \\texttt{TATAT} \\text{ 在 } Q[0..4]\\}$。\n\n**4. 超级最大精确匹配（SMEMs）的识别**\n\nSMEM 是一个就查询坐标而言，不被包含在任何其他精确匹配内的精确匹配。我们检查 $Q$ 中的所有精确匹配，并检验这个包含性质。\n所有精确匹配的集合包括各种子串：$\\texttt{A, T, AT, TA, ATA, TAT, TATA, ATAT, TATAT, ATATA, ATATAT}$，以及它们在 $Q$ 中的多次出现。\n\n- 考虑匹配 $M_1 = (\\texttt{ATATAT}, \\text{ 在 } Q[1..6])$。其坐标范围是 $[1, 6]$。我们寻找另一个精确匹配 $Q[i'..j']$，使得 $i' \\le 1$ 且 $j' \\ge 6$。唯一的可能性是 $Q[0..6] = \\texttt{TATATAT}$。然而，我们已经证明 $\\texttt{TATATAT}$ 在 $T$ 中不是一个精确匹配。因此，没有其他精确匹配包含 $M_1$。所以，来自 $Q[1..6]$ 的 $\\texttt{ATATAT}$ 是一个 SMEM。\n\n- 考虑匹配 $M_2 = (\\texttt{TATAT}, \\text{ 在 } Q[0..4])$。其坐标范围是 $[0, 4]$。我们寻找一个精确匹配 $Q[i'..j']$，使得 $i' \\le 0$ 且 $j' \\ge 4$。这意味着 $i'=0$。可能包含它的候选者是 $Q[0..5]=\\texttt{TATATA}$ 和 $Q[0..6]=\\texttt{TATATAT}$。这两者在 $T$ 中都不是精确匹配。因此，没有其他精确匹配包含 $M_2$。所以，来自 $Q[0..4]$ 的 $\\texttt{TATAT}$ 是一个 SMEM。\n\n- 考虑匹配 $M_3 = (\\texttt{TATAT}, \\text{ 在 } Q[2..6])$。其坐标范围是 $[2, 6]$。我们寻找一个精确匹配 $Q[i'..j']$，使得 $i' \\le 2$ 且 $j' \\ge 6$。一个这样的候选者是 $Q[1..6]=\\texttt{ATATAT}$。我们已经验证了 $\\texttt{ATATAT}$ 是一个精确匹配。由于 $M_3$ 被包含在位于 $Q[1..6]$ 的精确匹配中，所以 $M_3$ 不是一个 SMEM。\n\n所有其他较短的精确匹配也都被包含在某个较长的精确匹配之内。例如，位于 $Q[1..5]$ 的 $\\texttt{ATATA}$ 被包含在位于 $Q[1..6]$ 的 $\\texttt{ATATAT}$ 中。\n\n因此，不同的 SMEM 字符串是 $\\{\\texttt{ATATAT}, \\texttt{TATAT}\\}$。\n\n**5. $L_{\\mathrm{SMEM}}$ 的计算**\n\n$L_{\\mathrm{SMEM}}$ 是所有不同 SMEMs 的长度之和。\n不同的 SMEMs 是 $\\texttt{ATATAT}$ 和 $\\texttt{TATAT}$。\n$\\texttt{ATATAT}$ 的长度是 $6$。\n$\\texttt{TATAT}$ 的长度是 $5$。\n$$ L_{\\mathrm{SMEM}} = \\text{length}(\\texttt{ATATAT}) + \\text{length}(\\texttt{TATAT}) = 6 + 5 = 11 $$", "answer": "$$\\boxed{11}$$", "id": "4573270"}, {"introduction": "对于生物学中常见的高度重复的基因组，基于BWT的索引效率尤为显著。本练习将探讨BWT的游程编码（run-length encoding）概念，这是针对重复序列的一项关键优化。您将为一个重复字符串计算其BWT中的游程数量，并定量比较经典FM索引与游程压缩版本的空间需求[@problem_id:4573197]，从而揭示现代基因组学工具可扩展性的理论基础。", "problem": "生物信息学和医学数据分析领域的一个核心挑战是为大规模、重复性高的基因组参考序列构建简洁索引，以加速读段比对。考虑Burrows–Wheeler变换 (BWT)，其定义如下：给定一个基于脱氧核糖核酸 (DNA) 字母表的文本 $T$，在其末尾附加一个比所有字母表字符在字典序上都小的唯一哨兵字符 $\\$$，然后对 $T$ 的所有循环移位（或等价地，所有后缀）进行字典序排序，最后取每个排好序的循环移位的前一个字符来构成 BWT。一个“游程”是 BWT 中由相同字符组成的最长子串，游程的数量用 $r$ 表示。Ferragina–Manzini 索引 (FM-index) 是一种经典的基于 BWT 的索引，它将 BWT 存储在零阶压缩结构中，并周期性地采样后缀数组 (SA) 以支持定位操作。一种具有 $O(r)$ 空间表示的游程编码 BWT 会存储每个游程的头部字符和长度，并在游程边界处对 SA 进行采样。\n\n假设示例参考序列为高度重复的字符串 $T = \\text{A}^{255}\\$$，其长度 $N = 256$，基于大小为 $\\sigma = 4$ 的 DNA 字母表。假设 FM-index 采用零阶模型，其中 BWT 存储在类似小波树的结构中，需要 $N \\log_{2} \\sigma$ 比特；后缀数组 (SA) 每 $s = 32$ 个位置采样一次，需要 $(N/s) \\log_{2} N$ 比特。对于 $O(r)$ 表示法，假设它为每个游程存储其字符标签（成本为 $\\log_{2} \\sigma$ 比特）、其长度（成本为 $\\log_{2} N$ 比特）以及在每个游程边界处的一个 SA 样本（成本为 $\\log_{2} N$ 比特）。\n\n计算 $T$ 的 BWT 游程数 $r$，然后在所述的模型假设下，估算经典 FM-index 和 $O(r)$ 表示法的总索引空间（以比特为单位）。最后，给出比率 $\\frac{S_{\\mathrm{FM}}}{S_{r}}$，其中 $S_{\\mathrm{FM}}$ 是 FM-index 的空间，而 $S_{r}$ 是 $O(r)$ 表示法的空间。将最终比率表示为一个无单位的实数，且不要四舍五入。", "solution": "该问题陈述已经过严格验证，被认为是具有科学依据、定义明确且客观的。它基于 Burrows–Wheeler 变换 (BWT) 及其相关索引的既定原理，提出了一个生物信息学数据结构领域中清晰、可解的问题。所有必要的参数和模型均已提供。\n\n解题过程分为四个阶段：\n1.  确定给定文本 $T$ 的 Burrows–Wheeler 变换以及游程数 $r$。\n2.  计算经典 FM-index 的存储空间 $S_{\\mathrm{FM}}$。\n3.  计算 $O(r)$ 游程编码表示法的存储空间 $S_{r}$。\n4.  计算最终比率 $\\frac{S_{\\mathrm{FM}}}{S_{r}}$。\n\n**1. BWT 和游程数 ($r$)**\n\n给定文本为 $T = \\text{A}^{255}\\$$，长度 $N = 256$。我们使用从 0 开始的索引，因此 $T = T_{0}T_{1}...T_{255}$，其中对于 $i \\in \\{0, ..., 254\\}$，$T_{i} = \\text{A}$，而 $T_{255} = \\$$。哨兵字符 `$` 被定义为在字典序上小于 DNA 字母表中的任何字符，包括 `A`。\n\nBWT 的构建方法是：将 $T$ 的所有循环移位（或等价地，所有后缀）按字典序排序，然后从原始文本中（循环地）取每个排好序的后缀的第一个字符的前一个字符，来构成一个新字符串 $L$。这可以形式化地表示为 $L[i] = T[(\\text{SA}[i] - 1) \\pmod{N}]$，其中 $\\text{SA}$ 是后缀数组。后缀数组 $\\text{SA}$ 按字典序存储了 $T$ 的所有后缀的起始索引。\n\n让我们列出 $T$ 的后缀：\n$S_{0} = \\text{A}^{255}\\$$\n$S_{1} = \\text{A}^{254}\\$$\n...\n$S_{254} = \\text{A}\\$$\n$S_{255} = \\$$\n\n为了对这些后缀进行排序，我们逐个字符地比较它们。\n- 后缀 $S_{255} = \\$$ 在字典序上是最小的，因为 `$` 是扩展字母表中的最小字符。因此，$\\text{SA}[0] = 255$。\n- 所有其他后缀都以 `A` 开头。为了对它们进行排序，我们从它们的第二个字符开始比较。最早出现 `$` 的后缀将是最小的。\n  - $S_{254} = \\text{A}\\$$\n  - $S_{253} = \\text{AA}\\$$\n  - ...\n  - $S_{0} = \\text{A}^{255}\\$$\n显然，$\\text{A}\\$ \\prec \\text{AA}\\$ \\prec \\dots \\prec \\text{A}^{255}\\$$，因为 `$` 比 `A` 小。\n因此，后缀的排序顺序对应于其起始索引的降序：\n$S_{255} \\prec S_{254} \\prec S_{253} \\prec \\dots \\prec S_{1} \\prec S_{0}$。\n这就得出了后缀数组：$\\text{SA} = [255, 254, 253, ..., 1, 0]$。\n\n现在，我们构建长度为 $N=256$ 的 BWT 字符串 $L$：\n- $L[0] = T[(\\text{SA}[0]-1)\\pmod{256}] = T[(255-1)\\pmod{256}] = T[254] = \\text{A}$。\n- $L[1] = T[(\\text{SA}[1]-1)\\pmod{256}] = T[(254-1)\\pmod{256}] = T[253] = \\text{A}$。\n- ...\n- $L[254] = T[(\\text{SA}[254]-1)\\pmod{256}] = T[(1-1)\\pmod{256}] = T[0] = \\text{A}$。\n- $L[255] = T[(\\text{SA}[255]-1)\\pmod{256}] = T[(0-1)\\pmod{256}] = T[255] = \\$$。\n\n得到的 BWT 是 $L = \\text{A}^{255}\\$$。\n\n一个游程是由相同字符组成的最长子串。BWT 字符串 $L = \\text{A}^{255}\\$$ 由两个这样的游程组成：\n1.  一个由 255 个 `A` 字符组成的游程。\n2.  一个由 1 个 `$` 字符组成的游程。\n因此，游程数为 $r = 2$。\n\n**2. FM-Index 空间 ($S_{\\mathrm{FM}}$)**\n\n问题为经典 FM-index 的空间复杂度提供了一个模型。总空间 $S_{\\mathrm{FM}}$ 是压缩后的 BWT 空间和采样后的后缀数组空间之和。\n$S_{\\mathrm{FM}} = (\\text{BWT 空间}) + (\\text{SA 采样空间})$\n\n已知条件如下：\n- 文本长度 $N = 256$。\n- 字母表大小 $\\sigma = 4$。\n- SA 采样周期 $s = 32$。\n\nBWT 空间由 $N \\log_{2} \\sigma$ 给出：\n$S_{\\mathrm{BWT}} = 256 \\times \\log_{2}(4) = 256 \\times 2 = 512$ 比特。\n\nSA 采样空间由 $(N/s) \\log_{2} N$ 给出：\n$S_{\\mathrm{SA}} = \\left(\\frac{256}{32}\\right) \\times \\log_{2}(256) = 8 \\times \\log_{2}(2^{8}) = 8 \\times 8 = 64$ 比特。\n\nFM-index 的总空间为：\n$S_{\\mathrm{FM}} = 512 + 64 = 576$ 比特。\n\n**3. $O(r)$ 表示法空间 ($S_{r}$)**\n\n问题为 $O(r)$ 空间索引指定了一个模型。对于 $r$ 个游程中的每一个，它都存储了字符标签、游程长度和一个 SA 样本。短语“在每个游程边界处”按照游程编码 BWT 索引的标准方式进行解释，即为每个游程的开始位置存储一个 SA 样本。对于 $r$ 个游程，这需要存储 $r$ 个样本。\n\n总空间 $S_{r}$ 是单个游程相关数据所需空间的 $r$ 倍：\n$S_{r} = r \\times (\\text{字符空间} + \\text{长度空间} + \\text{SA 采样空间})$\n\n每个游程的空间成本如下：\n- 字符标签：$\\log_{2} \\sigma = \\log_{2}(4) = 2$ 比特。\n- 游程长度：$\\log_{2} N = \\log_{2}(256) = 8$ 比特。\n- SA 样本：$\\log_{2} N = \\log_{2}(256) = 8$ 比特。\n\n使用计算出的值 $r=2$：\n$S_{r} = 2 \\times (2 + 8 + 8) = 2 \\times 18 = 36$ 比特。\n\n**4. 空间使用比率**\n\n最后一步是计算经典 FM-index 所需空间与 $O(r)$ 表示法所需空间的比率。\n比率 = $\\frac{S_{\\mathrm{FM}}}{S_{r}}$\n比率 = $\\frac{576}{36}$\n\n为简化该分数：\n比率 = $\\frac{576 \\div 18}{36 \\div 18} = \\frac{32}{2} = 16$。\n\n该比率恰好为 $16$。这一结果表明，在高度重复的文本上，游程编码压缩能实现显著的空间节省，因为在这种情况下，BWT 的游程数 $r$ 远小于文本长度 $N$。", "answer": "$$\\boxed{16}$$", "id": "4573197"}]}