{"hands_on_practices": [{"introduction": "亚硫酸氢盐处理会系统性地改变DNA序列，这使得标准比对算法无法直接使用。为了解决这个问题，生物信息学分析中的标准方案是，根据亚硫酸氢盐转化原理对参考基因组进行计算机模拟转换。这项练习[@problem_id:4544140]将引导您推导并实现为定向文库创建C到T和G到A转换参考序列的逻辑，从而分别处理源自正向和反向DNA链的测序读段，揭示比对过程的奥秘。", "problem": "给定一个由字母表 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 组成的单链脱氧核糖核酸 (DNA) 参考序列 $S$ 和一组源自定向亚硫酸氢钠测序文库的观测测序读段 $\\{r_i\\}$。请使用以下基本事实作为您推导和程序设计的基础： (i) 亚硫酸氢钠将未甲基化的胞嘧啶 ($\\text{C}$) 转化为尿嘧啶 ($\\text{U}$)，在测序过程中 $\\text{U}$ 被读取为胸腺嘧啶 ($\\text{T}$)，而甲基化的胞嘧啶则保持为胞嘧啶。 (ii) 互补性意味着胞嘧啶 ($\\text{C}$) 与鸟嘌呤 ($\\text{G}$) 配对，腺嘌呤 ($\\text{A}$) 与胸腺嘧啶 ($\\text{T}$) 配对。 (iii) 在全基因组亚硫酸氢盐测序 (WGBS) 的定向文库中，测序读段的方向是保留的，因此源自正向链模板的读段在其序列上表现出 $\\text{C}\\rightarrow\\text{T}$ 的转换，而源自反向链模板的读段在其序列上表现出 $\\text{G}\\rightarrow\\text{A}$ 的转换（这反映了在相对模板链上的 $\\text{C}\\rightarrow\\text{T}$ 转换及随后的碱基配对）。\n\n您的任务是基于这些事实，推导出如何构建两个转换后的参考序列，并从算法上展示对这两个参考序列进行比对如何能捕获定向文库中来自两条链的读段。通过以下定义的函数 $f_{\\text{CT}}$ 和 $f_{\\text{GA}}$ 构建这两个转换后的参考序列：\n- $$f_{\\text{CT}}(S) = \\text{将 } S \\text{ 中的每个 } \\text{C} \\text{ 替换为 } \\text{T}，$$\n- $$f_{\\text{GA}}(S) = \\text{将 } S \\text{ 中的每个 } \\text{G} \\text{ 替换为 } \\text{A}。$$\n\n定义一个读段 $r$ “比对上”一个转换后的参考序列 $R$，当且仅当 $r$ 是 $R$ 的一个无错配的精确子字符串。将模糊碱基 $\\text{N}$ 视为严格错配（即，含有 $\\text{N}$ 的位置不能与 $R$ 中的任何字符匹配）。对于每个包含参考序列 $S$ 和读段集 $\\{r_i\\}$ 的测试用例，使用此定义计算以下整数值：\n- $$M_{\\text{CT}} = \\text{作为 } f_{\\text{CT}}(S) \\text{ 精确子字符串的读段 } r_i \\text{ 的数量，}$$\n- $$M_{\\text{GA}} = \\text{作为 } f_{\\text{GA}}(S) \\text{ 精确子字符串的读段 } r_i \\text{ 的数量，}$$\n- $$M_{\\text{both}} = \\text{作为 } f_{\\text{CT}}(S) \\text{ 或 } f_{\\text{GA}}(S) \\text{ 中至少一个的精确子字符串的读段 } r_i \\text{ 的数量。}$$\n\n您的程序必须实现 $f_{\\text{CT}}(S)$ 和 $f_{\\text{GA}}(S)$ 的构建，使用 $\\text{N}$-错配规则执行精确子字符串比对，并为每个测试用例计算指定的整数。不涉及任何物理单位。所有输出都必须是整数。\n\n测试套件（每个测试用例是一个序对 $(S, \\{r_i\\})$）：\n- 测试用例 $1$：\n  - $S = \\text{\"ACCGTGACCTAGC\"}$\n  - 读段 $\\{r_i\\} = [\\text{\"ATTGTG\"}, \\text{\"ATAACC\"}, \\text{\"TTTAG\"}, \\text{\"ATNGTG\"}, \\text{\"ATTGTGATTTAGTAAAAA\"}, \\text{\"ACCGT\"}]$\n- 测试用例 $2$：\n  - $S = \\text{\"ATATATAT\"}$\n  - 读段 $\\{r_i\\} = [\\text{\"ATATA\"}, \\text{\"TATAT\"}, \\text{\"GATAT\"}, \\text{\"ATATATAT\"}, \\text{\"NATAT\"}]$\n- 测试用例 $3$：\n  - $S = \\text{\"CCCCGGGG\"}$\n  - 读段 $\\{r_i\\} = [\\text{\"TTTTG\"}, \\text{\"CCCAA\"}, \\text{\"CCCCG\"}, \\text{\"AAA\"}, \\text{\"GGGG\"}, \\text{\"TTTTAAAA\"}]$\n- 测试用例 $4$：\n  - $S = \\text{\"AGCT\"}$\n  - 读段 $\\{r_i\\} = [\\text{\"AGTT\"}, \\text{\"AACT\"}, \\text{\"AGCT\"}, \\text{\"NNNN\"}, \\text{\"AGTTA\"}]$\n- 测试用例 $5$：\n  - $S = \\text{\"CGCGCG\"}$\n  - 读段 $\\{r_i\\} = [\\text{\"TGTG\"}, \\text{\"CAC\"}, \\text{\"TGCA\"}, \\text{\"CACACA\"}, \\text{\"TGTGTG\"}, \\text{\"ACAC\"}, \\text{\"GTGT\"}]$\n\n您的程序应生成单行输出，其中包含每个测试用例的列表 $[M_{\\text{CT}}, M_{\\text{GA}}, M_{\\text{both}}]$。将所有测试用例的结果聚合到一个顶层列表中。确切的输出格式是单行无空格，形式为用方括号括起来的逗号分隔列表；例如，$$[[m_{1,\\text{CT}},m_{1,\\text{GA}},m_{1,\\text{both}}],[m_{2,\\text{CT}},m_{2,\\text{GA}},m_{2,\\text{both}}],\\dots]$$ 其中每个 $m_{k,\\cdot}$ 是测试用例 $k$ 的一个整数。", "solution": "该问题要求通过创建两个计算转换的参考序列，推导并实现一个算法来量化定向亚硫酸氢钠测序中的读段比对。验证和解决方案如下。\n\n### **问题验证**\n\n**第 1 步：提取给定条件**\n\n*   **参考序列：** 一个由字母表 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 组成的单链DNA序列 $S$。\n*   **读段：** 一组观测到的测序读段 $\\{r_i\\}$。\n*   **测序背景：** 定向亚硫酸氢钠测序。\n*   **原理 (i)：** 亚硫酸氢钠将未甲基化的胞嘧啶 ($\\text{C}$) 转化为尿嘧啶 ($\\text{U}$)，后者被测序为胸腺嘧啶 ($\\text{T}$)。甲基化的胞嘧啶保持为胞嘧啶 ($\\text{C}$)。\n*   **原理 (ii)：** 碱基互补性为 $\\text{C} \\leftrightarrow \\text{G}$ 和 $\\text{A} \\leftrightarrow \\text{T}$。\n*   **原理 (iii)：** 在定向文库中，源自正向链模板的读段表现出 $\\text{C}\\rightarrow\\text{T}$ 转换；源自反向链模板的读段在其读段序列上相对于正向参考序列 $S$ 表现出 $\\text{G}\\rightarrow\\text{A}$ 转换。\n*   **函数定义：**\n    *   $f_{\\text{CT}}(S) = \\text{将 } S \\text{ 中的每个 } \\text{C} \\text{ 替换为 } \\text{T}$。\n    *   $f_{\\text{GA}}(S) = \\text{将 } S \\text{ 中的每个 } \\text{G} \\text{ 替换为 } \\text{A}$。\n*   **比对定义：** 如果一个读段 $r$ 是参考序列 $R$ 的一个精确子字符串，则称其“比对上”$R$。\n*   **模糊碱基规则：** 碱基 $\\text{N}$ 被视为严格错配。\n*   **要计算的量：**\n    *   $M_{\\text{CT}} = \\text{作为 } f_{\\text{CT}}(S) \\text{ 精确子字符串的读段 } r_i \\text{ 的数量}$。\n    *   $M_{\\text{GA}} = \\text{作为 } f_{\\text{GA}}(S) \\text{ 精确子字符串的读段 } r_i \\text{ 的数量}$。\n    *   $M_{\\text{both}} = \\text{作为 } f_{\\text{CT}}(S) \\text{ 或 } f_{\\text{GA}}(S) \\text{ 中至少一个的精确子字符串的读段 } r_i \\text{ 的数量}$。\n*   **测试套件：** 五个测试用例，每个由一个序对 $(S, \\{r_i\\})$ 组成。\n\n**第 2 步：使用提取的给定条件进行验证**\n\n根据指定的验证标准对问题进行审查。\n*   **科学依据：** 问题陈述基于全基因组亚硫酸氢盐测序 (WGBS) 的公认原理。使用计算机模拟转换的基因组来比对经亚硫酸氢盐处理的读段，是DNA甲基化分析领域的标准和基础技术，被广泛使用的生物信息学工具所采用。该描述是对过程的一个正确（尽管简化了）的模型。\n*   **定义明确：** 所有术语（$S$、$r_i$、$f_{\\text{CT}}$、$f_{\\text{GA}}$、“比对上”）都有精确定义。输入（测试用例）已提供，所需的输出（$M_{\\text{CT}}$、$M_{\\text{GA}}$、$M_{\\text{both}}$）也已明确指定。对于任何给定的输入，都可以计算出一组唯一的、稳定的且有意义的整数输出。\n*   **客观性：** 问题以客观、科学的语言陈述，没有主观看法或含糊之处。\n\n该问题不存在任何列出的缺陷（例如，科学上不健全、不完整、矛盾、不可行）。这是一个可形式化且可解决的问题，与生物信息学直接相关。\n\n**第 3 步：结论与行动**\n\n该问题是**有效的**。将提供解决方案。\n\n### **推导与算法设计**\n\n亚硫酸氢盐测序的核心原理是，它会根据甲基化状态在DNA序列中引入可预测的变化。比对算法必须考虑这些变化，才能将读段正确地比对回参考基因组。该问题要求我们为定向文库将此过程形式化。\n\n**1. 理论基础**\n\n设 $S$ 为原始的正向链参考序列。\n\n*   **正向链读段：** 源自正向链模板的读段会经过亚硫酸氢盐转化。这条链上任何未甲基化的胞嘧啶 ($\\text{C}$) 会变成尿嘧啶 ($\\text{U}$)，随后被测序仪读取为胸腺嘧啶 ($\\text{T}$)。甲基化的胞嘧啶受到保护，并保持为 $\\text{C}$。因此，来自这条链的测序读段将比对到原始参考序列 $S$ 的一个位置，在该位置上，所有原始的 $\\text{T}$ 仍然是 $\\text{T}$，所有甲基化的 $\\text{C}$ 仍然是 $\\text{C}$，但所有未甲基化的 $\\text{C}$ 都变成了 $\\text{T}$。由于我们无法先验地知道甲基化状态，为了找到这类读段所有可能的比对位置，我们必须考虑参考序列中的*任何* $\\text{C}$ 都可能是未甲基化的，从而转化为 $\\text{T}$。函数 $f_{\\text{CT}}(S)$ 通过将 $S$ 中的每个 $\\text{C}$ 替换为 $\\text{T}$ 来创建一个转换后的参考序列，它正确地模拟了这种“所有C都未甲基化”的情景。如果一个源自正向链的读段，其在原始基因组中对应的所有胞嘧啶要么是未甲基化的，要么原本就是胸腺嘧啶，那么它将是 $f_{\\text{CT}}(S)$ 的一个精确子字符串。含有胞嘧啶（来自甲基化位点）的读段将无法与这个完全转换的参考序列匹配，但本问题仅定义了与完全转换的参考序列进行比对。\n\n*   **反向链读段：** 反向链是 $S$ 的互补链。反向链上的一个胞嘧啶对应于正向链 $S$ 上的一个鸟嘌呤 ($\\text{G}$)。当反向链经过亚硫酸氢盐处理时，其未甲基化的胞嘧啶会转化为尿嘧啶（被读取为胸腺嘧啶）。然而，标准的比对实践是将所有读段都比对回单一的正向参考序列 $S$。当读段被定向并与正向参考序列 $S$ 进行比较时，反向互补链上的 $\\text{C} \\rightarrow \\text{T}$ 转换表现为 $\\text{G} \\rightarrow \\text{A}$ 的变化。这是碱基配对规则的直接结果。因此，为了处理源自反向链的读段，我们必须考虑参考序列 $S$ 中的任何 $\\text{G}$（对应于反向链上的一个 $\\text{C}$）都可能被读取为 $\\text{A}$。函数 $f_{\\text{GA}}(S)$ 通过将 $S$ 中的每个 $\\text{G}$ 替换为 $\\text{A}$，正确地模拟了反向链的这种情况。\n\n**2. 算法流程**\n\n基于上述推导，为给定测试用例 $(S, \\{r_i\\})$ 计算所需计数的算法如下：\n\n*   **第 1 步：参考序列转换。**\n    *   构建正向转换参考序列 $R_{\\text{CT}} = f_{\\text{CT}}(S)$。这是通过将字符串 $S$ 中每次出现的字符 '$\\text{C}$' 替换为 '$\\text{T}$' 来实现的。\n    *   构建反向转换参考序列 $R_{\\text{GA}} = f_{\\text{GA}}(S)$。这是通过将字符串 $S$ 中每次出现的字符 '$\\text{G}$' 替换为 '$\\text{A}$' 来实现的。\n\n*   **第 2 步：读段比对和计数。**\n    *   初始化三个整数计数器：$M_{\\text{CT}} \\leftarrow 0$，$M_{\\text{GA}} \\leftarrow 0$ 和 $M_{\\text{both}} \\leftarrow 0$。\n    *   遍历读段集 $\\{r_i\\}$ 中的每个读段 $r$。对于每个 $r$：\n        *   模糊碱基 '$\\text{N}$' 是严格错配的规则意味着，任何包含 '$\\text{N}$' 的读段都不可能是 $R_{\\text{CT}}$ 或 $R_{\\text{GA}}$ 的精确子字符串，因为这些参考序列仅由 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 中的字符组成。标准的子字符串搜索函数能正确处理这种情况；如果使用此类函数，则无需对 '$\\text{N}$' 进行特殊检查。\n        *   确定 $r$ 是否比对到 $R_{\\text{CT}}$。设其为一个布尔变量 `maps_ct`。当且仅当 $r$ 是 $R_{\\text{CT}}$ 的一个精确子字符串时，该变量为真。\n        *   确定 $r$ 是否比对到 $R_{\\text{GA}}$。设其为一个布尔变量 `maps_ga`。当且仅当 $r$ 是 $R_{\\text{GA}}$ 的一个精确子字符串时，该变量为真。\n        *   根据这些发现更新计数器：\n            *   如果 `maps_ct` 为真，则将 $M_{\\text{CT}}$ 增加 1。\n            *   如果 `maps_ga` 为真，则将 $M_{\\text{GA}}$ 增加 1。\n            *   如果 `maps_ct` 为真或 `maps_ga` 为真，则将 $M_{\\text{both}}$ 增加 1。\n\n*   **第 3 步：整理结果。**\n    *   遍历所有读段后，$M_{\\text{CT}}$、$M_{\\text{GA}}$ 和 $M_{\\text{both}}$ 的最终值构成了该测试用例的结果三元组。对套件中的所有测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bisulfite sequencing read mapping problem for a suite of test cases.\n    \"\"\"\n    # Test Suite: Each case is a tuple (S, reads) where S is the reference\n    # sequence and reads is a list of sequencing reads.\n    test_cases = [\n        # Test Case 1\n        (\"ACCGTGACCTAGC\", [\"ATTGTG\", \"ATAACC\", \"TTTAG\", \"ATNGTG\", \"ATTGTGATTTAGTAAAAA\", \"ACCGT\"]),\n        # Test Case 2\n        (\"ATATATAT\", [\"ATATA\", \"TATAT\", \"GATAT\", \"ATATATAT\", \"NATAT\"]),\n        # Test Case 3\n        (\"CCCCGGGG\", [\"TTTTG\", \"CCCAA\", \"CCCCG\", \"AAA\", \"GGGG\", \"TTTTAAAA\"]),\n        # Test Case 4\n        (\"AGCT\", [\"AGTT\", \"AACT\", \"AGCT\", \"NNNN\", \"AGTTA\"]),\n        # Test Case 5\n        (\"CGCGCG\", [\"TGTG\", \"CAC\", \"TGCA\", \"CACACA\", \"TGTGTG\", \"ACAC\", \"GTGT\"])\n    ]\n\n    all_results = []\n\n    for S, reads in test_cases:\n        # Step 1: Construct the two in-silico converted references.\n        # f_CT(S): C -> T conversion for reads from the forward strand.\n        R_CT = S.replace('C', 'T')\n        \n        # f_GA(S): G -> A conversion for reads from the reverse strand.\n        R_GA = S.replace('G', 'A')\n\n        # Step 2: Initialize counters for the current test case.\n        M_CT = 0\n        M_GA = 0\n        M_both = 0\n\n        # Step 3: Iterate through each read and check for exact substring matches.\n        for r in reads:\n            # The problem defines 'N' as a strict mismatch. The 'in' operator\n            # naturally handles this, as a read containing 'N' will not be found\n            # as a substring in a reference that does not contain 'N'.\n            \n            # Check if read r maps to the C->T converted reference.\n            maps_ct = r in R_CT\n            \n            # Check if read r maps to the G->A converted reference.\n            maps_ga = r in R_GA\n            \n            # Update counters based on mapping results.\n            if maps_ct:\n                M_CT += 1\n            \n            if maps_ga:\n                M_GA += 1\n            \n            # M_both counts reads that map to at least one of the references.\n            if maps_ct or maps_ga:\n                M_both += 1\n        \n        all_results.append([M_CT, M_GA, M_both])\n\n    # Format the final output as specified: [[r1_ct,r1_ga,r1_both],[r2_ct,r2_ga,r2_both],...]\n    # Using map(str, ...) converts each inner list to its string representation.\n    # Joining with ',' separates the string representations of the lists.\n    # The outer f-string adds the enclosing brackets.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    \n    # The problem asks for a single line of output with no spaces.\n    # The string representation of a list in Python includes spaces after commas.\n    # To match the specified format precisely, we remove spaces.\n    print(output_str.replace(\" \", \"\"))\n\nsolve()\n\n```", "id": "4544140"}, {"introduction": "原始的比对数据包含来自各种来源的噪声和错误，因此在进行下游分析前必须进行严格过滤。基于比对质量、碱基质量和PCR重复进行数据筛选是确保数据可靠性的关键步骤。这项实践[@problem_id:4544197]将指导您完成这些重要的数据质量控制流程，并挑战您从清理后的数据中推导出一个矩估计量，以计算真实的甲基化水平，同时校正例如亚硫酸氢盐转化不完全等实验噪声。", "problem": "一个胞嘧啶-磷酸-鸟嘌呤 (CpG) 位点通过全基因组亚硫酸氢盐测序进行探查。在亚硫酸氢钠处理中，未甲基化的胞嘧啶会脱氨基转变为尿嘧啶，并在测序中被读取为胸腺嘧啶，而甲基化的胞嘧啶则保持为胞嘧啶。一个 Phred 碱基质量得分 $Q$ 将碱基识别错误的概率编码为 $P(\\text{error}) = 10^{-Q/10}$。一个 Phred 标准化的比对质量 $MQ$ 将读段错误比对的概率编码为 $P(\\text{wrong map}) = 10^{-MQ/10}$。被标记为重复的读段被假定为聚合酶链式反应 (PCR) 重复，并应被排除。给定一组覆盖单个 CpG 位点的 $20$ 条读段，每条读段包含在 CpG 位点观测到的碱基（$C$ 或 $T$）、读段的比对质量 $MQ$、CpG 位置的碱基质量 $Q$ 以及一个重复标记 $\\mathrm{DUP} \\in \\{0,1\\}$：\n- 读段 $1$：碱基 $C$，$MQ=37$，$Q=35$，$\\mathrm{DUP}=0$\n- 读段 $2$：碱基 $C$，$MQ=41$，$Q=32$，$\\mathrm{DUP}=0$\n- 读段 $3$：碱基 $T$，$MQ=38$，$Q=33$，$\\mathrm{DUP}=0$\n- 读段 $4$：碱基 $C$，$MQ=29$，$Q=38$，$\\mathrm{DUP}=0$\n- 读段 $5$：碱基 $T$，$MQ=36$，$Q=28$，$\\mathrm{DUP}=0$\n- 读段 $6$：碱基 $C$，$MQ=60$，$Q=40$，$\\mathrm{DUP}=1$\n- 读段 $7$：碱基 $C$，$MQ=60$，$Q=40$，$\\mathrm{DUP}=0$\n- 读段 $8$：碱基 $T$，$MQ=31$，$Q=31$，$\\mathrm{DUP}=0$\n- 读段 $9$：碱基 $T$，$MQ=34$，$Q=30$，$\\mathrm{DUP}=0$\n- 读段 $10$：碱基 $C$，$MQ=35$，$Q=30$，$\\mathrm{DUP}=0$\n- 读段 $11$：碱基 $T$，$MQ=50$，$Q=39$，$\\mathrm{DUP}=0$\n- 读段 $12$：碱基 $C$，$MQ=33$，$Q=29$，$\\mathrm{DUP}=0$\n- 读段 $13$：碱基 $C$，$MQ=32$，$Q=35$，$\\mathrm{DUP}=0$\n- 读段 $14$：碱基 $T$，$MQ=45$，$Q=35$，$\\mathrm{DUP}=1$\n- 读段 $15$：碱基 $C$，$MQ=42$，$Q=31$，$\\mathrm{DUP}=0$\n- 读段 $16$：碱基 $T$，$MQ=55$，$Q=37$，$\\mathrm{DUP}=0$\n- 读段 $17$：碱基 $C$，$MQ=47$，$Q=30$，$\\mathrm{DUP}=0$\n- 读段 $18$：碱基 $T$，$MQ=30$，$Q=30$，$\\mathrm{DUP}=0$\n- 读段 $19$：碱基 $C$，$MQ=44$，$Q=34$，$\\mathrm{DUP}=0$\n- 读段 $20$：碱基 $T$，$MQ=39$，$Q=31$，$\\mathrm{DUP}=0$\n\n应用以下筛选条件以获得高置信度的观测值：仅保留 $MQ \\geq 30$、CpG 位置的碱基质量 $Q \\geq 30$ 且 $\\mathrm{DUP} = 0$ 的读段。设 $n$ 为保留的读段数，$c$ 为保留的观测到的 $C$ 的计数，$t$ 为保留的观测到的 $T$ 的计数，且 $n=c+t$。\n\n假设亚硫酸氢盐的未转化率为 $r = 0.01$，这意味着一个未甲基化的胞嘧啶在测序前未能转化的概率为 $r$。假设一个对称的碱基识别错误模型，其中每条读段的错误概率 $e$ 等于由最低保留碱基质量阈值所隐含的错误率，即 $e = 10^{-Q_{\\min}/10}$，其中 $Q_{\\min}=30$。在这些假设以及亚硫酸氢盐转化的生化过程下，从第一性原理推导在一条保留的读段中于该位点观测到 $C$ 的概率，使其成为甲基化分数 $m \\in [0,1]$ 的线性函数。然后，使用矩量法，将经验分数 $\\hat{p} = c/n$ 等同于推导出的期望值，求解 $m$ 的估计量 $\\hat{m}$ 的闭式解，并根据筛选后的数据进行数值计算。\n\n简要说明在此背景下，每种筛选条件（比对质量、碱基质量、重复去除）如何影响估计的偏差和方差，但最终答案只需报告 $\\hat{m}$ 的数值（不带百分号）。将最终报告值四舍五入至四位有效数字。", "solution": "该问题被评估为有效，因为它科学地基于亚硫酸氢盐测序的原理，问题设定良好，有足够的数据和明确的目标，并且陈述客观。\n\n求解过程分为五个步骤：第一，筛选所提供的测序数据；第二，推导观测碱基作为甲基化分数函数的概率模型；第三，使用矩量法推导甲基化分数的估计量；第四，计算估计的数值；第五，说明使用数据筛选条件的理由。\n\n首先，必须对原始测序数据进行筛选，以仅保留高置信度的观测值。指定的标准是比对质量 $MQ \\geq 30$，CpG 位置的碱基质量 $Q \\geq 30$，并且没有重复标记（即 $\\mathrm{DUP} = 0$）。我们将这些筛选条件应用于这 $20$ 条读段：\n- 读段 $1$：$C, MQ=37, Q=35, \\mathrm{DUP}=0$。保留。\n- 读段 $2$：$C, MQ=41, Q=32, \\mathrm{DUP}=0$。保留。\n- 读段 $3$：$T, MQ=38, Q=33, \\mathrm{DUP}=0$。保留。\n- 读段 $4$：$C, MQ=29, Q=38, \\mathrm{DUP}=0$。丢弃（$MQ  30$）。\n- 读段 $5$：$T, MQ=36, Q=28, \\mathrm{DUP}=0$。丢弃（$Q  30$）。\n- 读段 $6$：$C, MQ=60, Q=40, \\mathrm{DUP}=1$。丢弃（$\\mathrm{DUP} = 1$）。\n- 读段 $7$：$C, MQ=60, Q=40, \\mathrm{DUP}=0$。保留。\n- 读段 $8$：$T, MQ=31, Q=31, \\mathrm{DUP}=0$。保留。\n- 读段 $9$：$T, MQ=34, Q=30, \\mathrm{DUP}=0$。保留。\n- 读段 $10$：$C, MQ=35, Q=30, \\mathrm{DUP}=0$。保留。\n- 读段 $11$：$T, MQ=50, Q=39, \\mathrm{DUP}=0$。保留。\n- 读段 $12$：$C, MQ=33, Q=29, \\mathrm{DUP}=0$。丢弃（$Q  30$）。\n- 读段 $13$：$C, MQ=32, Q=35, \\mathrm{DUP}=0$。保留。\n- 读段 $14$：$T, MQ=45, Q=35, \\mathrm{DUP}=1$。丢弃（$\\mathrm{DUP} = 1$）。\n- 读段 $15$：$C, MQ=42, Q=31, \\mathrm{DUP}=0$。保留。\n- 读段 $16$：$T, MQ=55, Q=37, \\mathrm{DUP}=0$。保留。\n- 读段 $17$：$C, MQ=47, Q=30, \\mathrm{DUP}=0$。保留。\n- 读段 $18$：$T, MQ=30, Q=30, \\mathrm{DUP}=0$。保留。\n- 读段 $19$：$C, MQ=44, Q=34, \\mathrm{DUP}=0$。保留。\n- 读段 $20$：$T, MQ=39, Q=31, \\mathrm{DUP}=0$。保留。\n\n筛选后，保留的读段数为 $n=15$。观测到的胞嘧啶（$C$）计数为 $c=8$。观测到的胸腺嘧啶（$T$）计数为 $t=7$。总和为 $c+t = 8+7=15=n$，与预期相符。观测到的 $C$ 碱基的经验分数为 $\\hat{p} = \\frac{c}{n} = \\frac{8}{15}$。\n\n第二，我们推导在一条给定的保留读段中于该位点观测到 $C$ 的概率，记为 $P(\\text{obs}=C)$。该概率是真实甲基化分数 $m \\in [0,1]$、亚硫酸氢盐未转化率 $r$ 和碱基识别错误率 $e$ 的函数。设一个 DNA 分子被甲基化的概率为 $m$，未被甲基化的概率为 $1-m$。\n\n观测到 $C$ 可能源于两种基于 DNA 分子真实状态的互斥情况：\n1.  原始胞嘧啶被甲基化（概率为 $m$）。它不受亚硫酸氢盐处理的影响，保持为 $C$。然后它被正确测序为 $C$。正确碱基识别的概率为 $1-e$。此路径的总概率为 $P(\\text{obs}=C \\text{ and methylated}) = m \\times 1 \\times (1-e) = m(1-e)$。\n\n2.  原始胞嘧啶未被甲基化（概率为 $1-m$）。有两条子路径可以导致观测到 $C$：\n    a. 亚硫酸氢盐未转化：未甲基化的 $C$ 未能转化为尿嘧啶（概率为 $r$）。它保持为 $C$，然后被正确测序为 $C$（概率为 $1-e$）。此子路径的概率为 $(1-m) \\times r \\times (1-e)$。\n    b. 转化和测序错误：未甲基化的 $C$ 正确转化为尿嘧啶（被读取为 $T$）（概率为 $1-r$）。这个 $T$ 随后因碱基识别错误而被错误测序为 $C$（概率为 $e$）。此子路径的概率为 $(1-m) \\times (1-r) \\times e$。\n\n观测到 $C$ 的总概率是这些不相交路径的概率之和：\n$$ P(\\text{obs}=C) = m(1-e) + (1-m)r(1-e) + (1-m)(1-r)e $$\n这个表达式可以重排以显示其对 $m$ 的线性依赖性：\n$$ P(\\text{obs}=C) = m(1-e) + (1-m)[r(1-e) + e(1-r)] $$\n$$ P(\\text{obs}=C) = m(1-e) + (1-m)(r - re + e - re) $$\n$$ P(\\text{obs}=C) = m(1-e) + (1-m)(r + e - 2re) $$\n按 $m$ 合并项：\n$$ P(\\text{obs}=C) = m(1-e) - m(r+e-2re) + (r+e-2re) $$\n$$ P(\\text{obs}=C) = m[(1-e) - (r+e-2re)] + (r+e-2re) $$\n$$ P(\\text{obs}=C) = m[1 - 2e - r + 2re] + (r+e-2re) $$\n对 $m$ 的系数进行因式分解得到 $(1-r)(1-2e)$。因此，线性函数为：\n$$ P(\\text{obs}=C) = m(1-r)(1-2e) + (r+e-2re) $$\n\n第三，我们推导 $m$ 的估计量 $\\hat{m}$。矩量法将经验样本矩与相应的理论总体矩相等同。在这里，我们将观测到的 $C$ 的样本比例 $\\hat{p} = c/n$ 与理论概率 $P(\\text{obs}=C)$ 相等同：\n$$ \\hat{p} = \\hat{m}(1-r)(1-2e) + (r+e-2re) $$\n求解估计量 $\\hat{m}$：\n$$ \\hat{p} - (r+e-2re) = \\hat{m}(1-r)(1-2e) $$\n$$ \\hat{m} = \\frac{\\hat{p} - (r+e-2re)}{(1-r)(1-2e)} $$\n这就是甲基化分数 $m$ 的闭式估计量。\n\n第四，我们对 $\\hat{m}$ 进行数值计算。给定参数为未转化率 $r = 0.01$ 和碱基识别错误概率 $e$，该概率由最低质量阈值 $Q_{\\min}=30$ 推导得出：\n$$ e = 10^{-Q_{\\min}/10} = 10^{-30/10} = 10^{-3} = 0.001 $$\n我们有经验分数 $\\hat{p} = 8/15$。\n项 $r+e-2re$ 计算如下：\n$$ r+e-2re = 0.01 + 0.001 - 2(0.01)(0.001) = 0.011 - 0.00002 = 0.01098 $$\n分母项 $(1-r)(1-2e)$ 为：\n$$ (1-r)(1-2e) = (1-0.01)(1-2 \\times 0.001) = (0.99)(1-0.002) = (0.99)(0.998) = 0.98802 $$\n将这些值代入 $\\hat{m}$ 的估计量公式中：\n$$ \\hat{m} = \\frac{\\frac{8}{15} - 0.01098}{0.98802} $$\n$$ \\hat{m} = \\frac{0.53333... - 0.01098}{0.98802} = \\frac{0.522353...}{0.98802} \\approx 0.528687 $$\n四舍五入到四位有效数字，估计的甲基化水平为 $\\hat{m} \\approx 0.5287$。\n\n第五，我们简要说明数据筛选步骤的理由。\n- **比对质量 ($MQ$) 筛选**：此筛选移除了可能并非源自目标基因组位点的读段。包含此类读段可能会引入显著偏差，因为它们的甲基化状态与目标 CpG 位点无关。例如，如果一条错误比对的读段来自一个未甲基化的旁系同源区域，它将贡献一个 $T$ 观测值，从而人为地降低甲基化估计值。移除低 $MQ$ 值的读段可以减少这种偏差来源。\n- **碱基质量 ($Q$) 筛选**：此筛选移除了有很高错误概率的碱基识别结果。包含低质量碱基会增加 $C$ 和 $T$ 计数的噪声，导致最终估计值 $\\hat{m}$ 的方差增大。此外，推导过程假设了一个单一的、低的错误率 $e$。包含错误概率高得多的读段会违反此模型假设，并可能引入偏差。筛选高 $Q$ 值的读段确保了错误模型是一个合理的近似，并提高了估计的精度。\n- **重复读段移除**：PCR 重复是源于单个 DNA 片段扩增产生的多条读段。包含它们会违反独立观测的假设。这会有效高估来自单个原始分子的证据，导致方差估计值被人为地降低，并可能产生严重偏差。如果被过度扩增的单个片段是甲基化的，估计值会向上偏；如果是未甲基化的，则会向下偏。移除重复读段确保每条保留的读段都是对分子群体的独立抽样，从而产生更准确和无偏的 $m$ 估计值。", "answer": "$$\\boxed{0.5287}$$", "id": "4544197"}, {"introduction": "相较于简单的读段计数，我们可以通过构建更精细的统计模型来获得更准确的甲基化估计。贝叶斯框架允许我们整合多种信息来源，例如每个碱基的测序质量和关于甲基化模式的先验生物学知识（如CpG与CH环境下的不同甲基化预期）。这项高级练习[@problem_id:4544155]介绍了一种强大的贝叶斯方法，通过将观测数据、先验预期和详细的错误模型相结合，使您能够为每个胞嘧啶计算出更精确的甲基化后验概率。", "problem": "一条单端全基因组亚硫酸氢盐测序（WGBS）读段已比对到正链上经过胞嘧啶到胸腺嘧啶转换的参考序列。在亚硫酸氢盐化学处理中，未甲基化的胞嘧啶会脱氨基转变为尿嘧啶，在聚合酶延伸后被读取为胸腺嘧啶，而甲基化的胞嘧啶则受到保护，保持为胞嘧啶。假设对于未甲基化的胞嘧啶，亚硫酸氢盐转换效率为 $e = 0.99$，而对于甲基化的胞嘧啶，转换效率为零。测序错误按每个碱基独立建模，使用 Phred 质量分 $Q$，其错误概率为 $p_{\\text{err}} = 10^{-Q/10}$。在发生错误的条件下，被替换的碱基在其他三种核苷酸中等可能出现。\n\n给定跨越基因组位置 $3$ 至 $14$（含）的正链转换参考子序列：\nTTGTTTATGTGT\n\n一个长度为$12$的读段与该子序列的位置完全对齐（无插入缺失），其读段碱基和 Phred 质量分如下（索引 $1$ 对应基因组位置 $3$，索引 $12$ 对应基因组位置 $14$）：\n- 读段碱基：TCGTTCATGTGT\n- 质量分 $Q_{1..12}$：$[35, 30, 40, 25, 32, 28, 37, 33, 39, 20, 36, 30]$\n\n提供一个二元掩码，指示转换后参考序列中的哪些位置源自未转换基因组中的胞嘧啶（即，转换后参考序列因基因组C的转换而显示为T的位置）。在上述子序列（基因组位置 $3$ 至 $14$）中，源于胞嘧啶的位置的索引为 $\\{1, 2, 4, 6, 10\\}$，对应于基因组位置 $\\{3, 4, 6, 8, 12\\}$。对于这些源于胞嘧啶的位置，还给出了它们的上下文分类：基因组位置 $4$ 和 $12$ 是胞嘧啶-磷酸-鸟嘌呤（CpG），而基因组位置 $3$、$6$ 和 $8$ 是C后跟一个非鸟嘌呤碱基（CH）。\n\n使用贝叶斯模型来判断所覆盖的源于胞嘧啶的位置的甲基化状态。设 $M$ 表示胞嘧啶被甲基化的事件，$U$ 表示未甲基化。使用以下先验概率：\n- CpG 先验甲基化概率 $P(M \\mid \\text{CpG}) = 0.7$，\n- CH 先验甲基化概率 $P(M \\mid \\text{CH}) = 0.1$。\n\n从第一性原理出发，为每个被覆盖的源于胞嘧啶的位置 $i$，根据其观测到的碱基 $b_i$ 和质量 $Q_i$，推导出单位点后验概率 $P(M \\mid b_i)$。然后：\n1. 通过将转换后参考序列中每个源于胞嘧啶的位置还原为胞嘧啶，同时保持所有其他位置不变，来重建该区域的原始基因组序列。\n2. 计算所覆盖的源于胞嘧啶的位置的预期甲基化分数，即为单位点后验甲基化概率的平均值：\n$$\\bar{f} = \\frac{1}{N}\\sum_{i \\in \\{\\text{cytosine-origin indices}\\}} P(M \\mid b_i),$$\n其中 $N$ 是所覆盖的源于胞嘧啶的位置的数量。\n\n将最终的预期甲基化分数 $\\bar{f}$ 表示为不带百分号的小数，并将答案四舍五入到四位有效数字。无需单位。", "solution": "该问题具有科学依据，提法明确，并包含得出唯一解所需的所有信息。因此，该问题被认为是有效的。解决方案首先重建原始基因组序列，然后应用贝叶斯模型来确定指定的源于胞嘧啶的位点的预期甲基化分数。\n\n该模型的给定参数如下：\n- 未甲基化胞嘧啶的亚硫酸氢盐转换效率：$e = 0.99$。\n- 具有 Phred 质量分 $Q$ 的碱基的测序错误概率：$p_{\\text{err}} = 10^{-Q/10}$。\n- 在发生错误的条件下，替换为其他三种碱基中任意一种的概率相等。\n- CpG 上下文的先验甲基化概率：$P(M \\mid \\text{CpG}) = 0.7$。\n- CH 上下文的先验甲基化概率：$P(M \\mid \\text{CH}) = 0.1$。\n\n12个碱基对区域（基因组位置 $3$ 到 $14$）的数据如下：\n- 转换后的参考序列：`TTGTTTATGTGT`\n- 读段碱基 ($b_i$): `TCGTTCATGTGT`\n- 质量分 ($Q_i$): $[35, 30, 40, 25, 32, 28, 37, 33, 39, 20, 36, 30]$\n- 源于胞嘧啶的索引（1-基，在子序列内）：$\\{1, 2, 4, 6, 10\\}$。\n- 这些源于胞嘧啶的位点的上下文：\n    - CpG：索引 $2$ 和 $10$。\n    - CH：索引 $1, 4, 6$。\n\n### 第1部分：重建原始基因组序列\n\n转换后的参考序列 `TTGTTTATGTGT` 在原始基因组序列中含有未甲基化的胞嘧啶（`C`）且成功转换的位置显示为胸腺嘧啶（`T`）。问题指出，索引 $\\{1, 2, 4, 6, 10\\}$ 是源于胞嘧啶的位置。在提供的转换后参考序列中，所有这些位置都是 `T`。为了重建原始基因组序列，我们将这些 `T` 还原回 `C`。\n\n- 转换后参考序列：`T T G T T T A T G T G T`\n- 1-基索引：      `1 2 3 4 5 6 7 8 9 10 11 12`\n- C来源位点（用 `*` 标记）： `* *   *   *     *`\n\n还原索引 $1, 2, 4, 6, 10$ 处的碱基：\n- 索引 $1$：`T` $\\rightarrow$ `C`\n- 索引 $2$：`T` $\\rightarrow$ `C`\n- 索引 $4$：`T` $\\rightarrow$ `C`\n- 索引 $6$：`T` $\\rightarrow$ `C`\n- 索引 $10$：`T` $\\rightarrow$ `C`\n\n该区域最终的原始基因组序列是 `CCGCTCATGCGT`。\n\n### 第2部分：计算预期甲基化分数\n\n我们计算预期甲基化分数 $\\bar{f}$，即为 $N=5$ 个源于胞嘧啶的位点的单位点后验甲基化概率 $P(M \\mid b_i)$ 的平均值。\n$$ \\bar{f} = \\frac{1}{N}\\sum_{i \\in \\{1, 2, 4, 6, 10\\}} P(M \\mid b_i) $$\n对于每个位点 $i$，我们使用贝叶斯定理，在给定观测到的碱基 $b_i$ 及其质量分 $Q_i$ 的条件下，求出甲基化（$M$）的后验概率：\n$$ P(M \\mid b_i, Q_i) = \\frac{P(b_i \\mid M, Q_i) P(M)}{P(b_i \\mid Q_i)} $$\n分母，即边缘似然，是所有可能状态（甲基化 $M$ 和未甲基化 $U$）的总和：\n$$ P(b_i \\mid Q_i) = P(b_i \\mid M, Q_i) P(M) + P(b_i \\mid U, Q_i) P(U) $$\n未甲基化的先验概率是 $P(U) = 1 - P(M)$。单位点错误概率为 $p_{\\text{err},i} = 10^{-Q_i/10}$。\n\n似然函数 $P(b_i \\mid \\text{State}, Q_i)$ 取决于胞嘧啶的真实潜在状态。\n\n**给定甲基化（$M$）的似然：**\n如果一个胞嘧啶是甲基化的，它就不会被转换。待测序的碱基是 `C`。\n- 如果观测到的碱基是 `C` ($b_i = \\text{'C'}$)，则测序仪读数正确。\n  $$ P(b_i=\\text{'C'} \\mid M, Q_i) = 1 - p_{\\text{err},i} $$\n- 如果观测到的碱基不是 `C` ($b_i \\in \\{\\text{'A', 'T', 'G'}\\}$)，则这是一个测序错误。\n  $$ P(b_i \\neq \\text{'C'} \\mid M, Q_i) = \\frac{p_{\\text{err},i}}{3} $$\n\n**给定未甲基化（$U$）的似然：**\n如果一个胞嘧啶是未甲基化的，它有 $e=0.99$ 的概率被转换为尿嘧啶（`U`），并被读取为胸腺嘧啶（`T`）。它有 $1-e=0.01$ 的概率转换失败并保持为 `C`。这是一个混合模型，其中待测序的真实碱基有 $e$ 的概率是 `T`，有 $1-e$ 的概率是 `C`。\n设 $L(b_i | \\text{true}, Q_i)$ 是在给定真实碱基的情况下观测到 $b_i$ 的概率。\n$$ P(b_i \\mid U, Q_i) = e \\cdot L(b_i \\mid \\text{true='T'}, Q_i) + (1-e) \\cdot L(b_i \\mid \\text{true='C'}, Q_i) $$\n- 如果观测到的碱基是 `C` ($b_i = \\text{'C'}$)：\n  $$ P(b_i=\\text{'C'} \\mid U, Q_i) = e \\cdot \\frac{p_{\\text{err},i}}{3} + (1-e) \\cdot (1 - p_{\\text{err},i}) $$\n- 如果观测到的碱基是 `T` ($b_i = \\text{'T'}$)：\n  $$ P(b_i=\\text{'T'} \\mid U, Q_i) = e \\cdot (1 - p_{\\text{err},i}) + (1-e) \\cdot \\frac{p_{\\text{err},i}}{3} $$\n- 如果观测到的碱基是 `A` 或 `G` ($b_i \\in \\{\\text{'A', 'G'}\\}$)：\n  $$ P(b_i \\in \\{\\text{'A', 'G'}\\} \\mid U, Q_i) = e \\cdot \\frac{p_{\\text{err},i}}{3} + (1-e) \\cdot \\frac{p_{\\text{err},i}}{3} = \\frac{p_{\\text{err},i}}{3} $$\n\n现在，我们为 $N=5$ 个源于胞嘧啶的位点中的每一个计算 $P(M \\mid b_i)$。\n\n**位点 1 (索引 1)：**\n- 上下文：CH, $P(M)=0.1$, $P(U)=0.9$。\n- 数据：$b_1=\\text{'T'}$, $Q_1=35$。$p_{\\text{err},1} = 10^{-3.5}$。\n- 似然：\n  $L_M = P(b_1=\\text{'T'} \\mid M) = \\frac{p_{\\text{err},1}}{3} = \\frac{10^{-3.5}}{3}$。\n  $L_U = P(b_1=\\text{'T'} \\mid U) = 0.99(1-10^{-3.5}) + 0.01(\\frac{10^{-3.5}}{3})$。\n- 后验：\n  $P(M \\mid b_1) = \\frac{L_M \\cdot 0.1}{L_M \\cdot 0.1 + L_U \\cdot 0.9} \\approx \\frac{(\\frac{3.162 \\times 10^{-4}}{3}) \\cdot 0.1}{(...) \\cdot 0.1 + (0.99(0.99968) + 0.01(\\frac{3.162 \\times 10^{-4}}{3})) \\cdot 0.9} \\approx \\frac{1.054 \\times 10^{-5}}{1.054 \\times 10^{-5} + 0.8907} \\approx 1.1832 \\times 10^{-5}$。\n\n**位点 2 (索引 2)：**\n- 上下文：CpG, $P(M)=0.7$, $P(U)=0.3$。\n- 数据：$b_2=\\text{'C'}$, $Q_2=30$。$p_{\\text{err},2} = 10^{-3}$。\n- 似然：\n  $L_M = P(b_2=\\text{'C'} \\mid M) = 1-10^{-3} = 0.999$。\n  $L_U = P(b_2=\\text{'C'} \\mid U) = 0.99(\\frac{10^{-3}}{3}) + 0.01(1-10^{-3}) = 0.00033 + 0.00999 = 0.01032$。\n- 后验：\n  $P(M \\mid b_2) = \\frac{0.999 \\cdot 0.7}{0.999 \\cdot 0.7 + 0.01032 \\cdot 0.3} = \\frac{0.6993}{0.6993 + 0.003096} = \\frac{0.6993}{0.702396} \\approx 0.995593$。\n\n**位点 3 (索引 4)：**\n- 上下文：CH, $P(M)=0.1$, $P(U)=0.9$。\n- 数据：$b_4=\\text{'T'}$, $Q_4=25$。$p_{\\text{err},4} = 10^{-2.5}$。\n- 似然：\n  $L_M = P(b_4=\\text{'T'} \\mid M) = \\frac{10^{-2.5}}{3}$。\n  $L_U = P(b_4=\\text{'T'} \\mid U) = 0.99(1-10^{-2.5}) + 0.01(\\frac{10^{-2.5}}{3})$。\n- 后验：\n  $P(M \\mid b_4) = \\frac{L_M \\cdot 0.1}{L_M \\cdot 0.1 + L_U \\cdot 0.9} \\approx \\frac{(\\frac{3.162 \\times 10^{-3}}{3}) \\cdot 0.1}{(...) \\cdot 0.1 + (0.99(0.9968) + 0.01(\\frac{3.162 \\times 10^{-3}}{3})) \\cdot 0.9} \\approx \\frac{1.054 \\times 10^{-4}}{1.054 \\times 10^{-4} + 0.8882} \\approx 1.1866 \\times 10^{-4}$。\n\n**位点 4 (索引 6)：**\n- 上下文：CH, $P(M)=0.1$, $P(U)=0.9$。\n- 数据：$b_6=\\text{'C'}$, $Q_6=28$。$p_{\\text{err},6} = 10^{-2.8}$。\n- 似然：\n  $L_M = P(b_6=\\text{'C'} \\mid M) = 1-10^{-2.8} \\approx 0.998415$。\n  $L_U = P(b_6=\\text{'C'} \\mid U) = 0.99(\\frac{10^{-2.8}}{3}) + 0.01(1-10^{-2.8}) \\approx 0.000523 + 0.009984 = 0.010507$。\n- 后验：\n  $P(M \\mid b_6) = \\frac{0.998415 \\cdot 0.1}{0.998415 \\cdot 0.1 + 0.010507 \\cdot 0.9} = \\frac{0.0998415}{0.0998415 + 0.0094563} = \\frac{0.0998415}{0.1092978} \\approx 0.913480$。\n\n**位点 5 (索引 10)：**\n- 上下文：CpG, $P(M)=0.7$, $P(U)=0.3$。\n- 数据：$b_{10}=\\text{'T'}$, $Q_{10}=20$。$p_{\\text{err},10} = 10^{-2} = 0.01$。\n- 似然：\n  $L_M = P(b_{10}=\\text{'T'} \\mid M) = \\frac{0.01}{3}$。\n  $L_U = P(b_{10}=\\text{'T'} \\mid U) = 0.99(1-0.01) + 0.01(\\frac{0.01}{3}) = 0.99(0.99) + \\frac{0.0001}{3} = 0.9801 + 3.\\overline{3} \\times 10^{-5} \\approx 0.980133$。\n- 后验：\n  $P(M \\mid b_{10}) = \\frac{(\\frac{0.01}{3}) \\cdot 0.7}{(\\frac{0.01}{3}) \\cdot 0.7 + 0.980133 \\cdot 0.3} = \\frac{0.002\\overline{3}}{0.002\\overline{3} + 0.29404} = \\frac{0.002\\overline{3}}{0.29637\\overline{3}} \\approx 0.007873$。\n\n最后，我们计算这五个后验概率的平均值：\n$$ \\bar{f} = \\frac{1}{5} \\left( P(M \\mid b_1) + P(M \\mid b_2) + P(M \\mid b_4) + P(M \\mid b_6) + P(M \\mid b_{10}) \\right) $$\n$$ \\bar{f} \\approx \\frac{1}{5} (1.1832 \\times 10^{-5} + 0.995593 + 1.1866 \\times 10^{-4} + 0.913480 + 0.007873) $$\n$$ \\bar{f} \\approx \\frac{1}{5} (0.000011832 + 0.995593 + 0.00011866 + 0.913480 + 0.007873) $$\n$$ \\bar{f} \\approx \\frac{1.917076}{5} \\approx 0.3834152 $$\n将结果四舍五入到四位有效数字，得到 $\\bar{f} = 0.3834$。", "answer": "$$ \\boxed{0.3834} $$", "id": "4544155"}]}