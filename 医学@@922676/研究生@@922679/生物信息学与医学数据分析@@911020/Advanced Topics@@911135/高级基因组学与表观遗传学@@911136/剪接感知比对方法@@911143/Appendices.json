{"hands_on_practices": [{"introduction": "剪接感知比对算法的核心是其评分系统，该系统用于评估RNA测序读段（read）与参考基因组之间每一种可能的比对方式的优劣。这个过程需要在不同的生物学事件之间做出权衡，例如，一个读段的不连续比对可能是由于基因组缺失（需要一个空位罚分）或内含子跨越（需要一个剪接罚分）。通过亲手计算和比较不同比对方案的得分，你将深入理解比对算法在面对模糊情况时是如何做出决策的，这是理解下游分析结果可靠性的基础 `[@problem_id:4609252]`。", "problem": "在将核糖核酸测序（RNA-seq）读长进行剪接感知比对至参考基因组时，目标是选择一个能优化比对分值的映射，该分值是根据序列进化和测序错误的概率模型得出的一个加性得分。一个标准且经过充分检验的评分框架使用仿射空位罚分来模拟插入或删除，并使用一个独特的内含子罚分来模拟剪接点。在此框架中，每个匹配的碱基贡献一个匹配得分，结构事件贡献固定的罚分：\n\n- 每个匹配的碱基为比对分值贡献 $c_{M}$。\n- 长度为 $l$ 的空位（插入或删除）贡献的总罚分为 $c_{\\text{gap\\_open}} + l \\cdot c_{\\text{gap\\_extend}}$，代表一次空位开放事件和 $l$ 次空位延伸步骤。\n- 在这个简化模型中，一个剪接点贡献一个单一的内含子罚分 $c_{I}$，与内含子长度无关。\n\n考虑一个长度为 $150$ 个碱基对的读长，它有两个候选的基因组映射：\n\n1. 候选 A 是一个连续的基因组比对，在读长到参考序列的比对中包含一个长度为 $10$ 的单一删除，有 $140$ 个匹配的碱基且无错配。\n2. 候选 B 是一个剪接比对，其中读长被分成两段，每段 $75$ 个碱基，跨越一个内含子映射到两个外显子上，产生 $150$ 个匹配的碱基和一个剪接点，外显子内部没有错配和基因组空位。\n\n假设评分常数如下：$c_{M}=-2$，$c_{\\text{gap\\_open}}=-5$，$c_{\\text{gap\\_extend}}=-1$ 和 $c_{I}=-20$。将每个候选的比对分值定义为上述所有适用贡献的总和。计算比对分值差 $\\Delta S = S_{\\text{splice}} - S_{\\text{deletion}}$，其中 $S_{\\text{splice}}$ 是候选 B 的得分，$S_{\\text{deletion}}$ 是候选 A 的得分。请以单个实数形式提供最终答案。无需四舍五入。", "solution": "首先验证问题陈述，以确保其科学上合理、内容完整且定义明确。\n\n**步骤 1：提取已知条件**\n- **读长**：$150$ 个碱基对 (bp)。\n- **每个碱基的匹配得分**：$c_{M} = -2$。\n- **长度为 $l$ 的空位的仿射空位罚分**：总贡献为 $c_{\\text{gap\\_open}} + l \\cdot c_{\\text{gap\\_extend}}$。\n- **空位开放罚分**：$c_{\\text{gap\\_open}} = -5$。\n- **空位延伸罚分**：$c_{\\text{gap\\_extend}} = -1$。\n- **每个剪接点的内含子罚分**：$c_{I} = -20$。\n- **候选 A (删除比对)**：一个连续比对，有 $140$ 个匹配碱基和一个长度为 $l=10$ 的单一删除。\n- **候选 B (剪接比对)**：一个剪接比对，有两个各 $75$ 个碱基的片段，总共 $150$ 个匹配碱基和一个剪接点。\n- **目标**：计算比对分值差 $\\Delta S = S_{\\text{splice}} - S_{\\text{deletion}}$，其中 $S_{\\text{splice}}$ 是候选 B 的得分，$S_{\\text{deletion}}$ 是候选 A 的得分。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题描述了一个简化但标准且有科学依据的 RNA-seq 比对评分模型。在剪接感知比对算法中，使用仿射空位罚分和特定的内含子罚分是一种常见做法。所提供的参数和比对情景定义清晰、自洽且客观。读长为 $150$ bp 与两个候选的细节一致（候选 A：$140$ 个匹配 + 从参考序列中删除的 $10$ 个碱基，对应读长的 $150$ 个碱基；候选 B：$75+75 = 150$ 个匹配碱基）。该问题定义明确，因为它包含了计算唯一、有意义的数值解所需的所有信息。该问题不违反任何科学原理，没有歧义，并且可以直接求解。\n\n**步骤 3：结论与行动**\n问题被判定为有效。将推导解答。\n\n**解题过程**\n比对分值 $S$ 是通过对所有比对特征（匹配、空位和内含子）的贡献求和来计算的。\n\n首先，我们计算候选 A 的得分，即带有删除的连续比对，记为 $S_{\\text{deletion}}$。\n候选 A 有 $140$ 个匹配的碱基。来自匹配的总贡献是匹配数乘以每个碱基的匹配得分 $c_{M}$。\n来自匹配的贡献 = $140 \\cdot c_{M}$。\n候选 A 有一个长度为 $l=10$ 的单一删除。这构成了一次空位开放事件和 $10$ 次空位延伸步骤。此空位的总罚分贡献由仿射空位罚分公式给出：$c_{\\text{gap\\_open}} + l \\cdot c_{\\text{gap\\_extend}}$，其中 $l=10$。\n来自空位的贡献 = $c_{\\text{gap\\_open}} + 10 \\cdot c_{\\text{gap\\_extend}}$。\n候选 A 中没有剪接点。\n候选 A 的总分是这些贡献的总和：\n$$S_{\\text{deletion}} = 140 \\cdot c_{M} + (c_{\\text{gap\\_open}} + 10 \\cdot c_{\\text{gap\\_extend}})$$\n代入给定值：\n$$S_{\\text{deletion}} = 140 \\cdot (-2) + (-5 + 10 \\cdot (-1))$$\n$$S_{\\text{deletion}} = -280 + (-5 - 10)$$\n$$S_{\\text{deletion}} = -280 - 15 = -295$$\n\n接下来，我们计算候选 B 的得分，即剪接比对，记为 $S_{\\text{splice}}$。\n候选 B 有 $150$ 个匹配的碱基。来自匹配的贡献是：\n来自匹配的贡献 = $150 \\cdot c_{M}$。\n候选 B 有一个剪接点，贡献了内含子罚分 $c_{I}$。\n来自内含子的贡献 = $c_{I}$。\n候选 B 的外显子内没有空位。\n候选 B 的总分是这些贡献的总和：\n$$S_{\\text{splice}} = 150 \\cdot c_{M} + c_{I}$$\n代入给定值：\n$$S_{\\text{splice}} = 150 \\cdot (-2) + (-20)$$\n$$S_{\\text{splice}} = -300 - 20$$\n$$S_{\\text{splice}} = -320$$\n\n最后，我们计算所要求的比对分值差 $\\Delta S = S_{\\text{splice}} - S_{\\text{deletion}}$。\n$$\\Delta S = (-320) - (-295)$$\n$$\\Delta S = -320 + 295$$\n$$\\Delta S = -25$$\n\n比对分值的差异是 $-25$。这表明，根据指定的评分模型，带有删除的比对（候选 A）优于剪接比对（候选 B），因为它有更高（负得更少）的分数。", "answer": "$$\\boxed{-25}$$", "id": "4609252"}, {"introduction": "在确定了得分最高的比对后，一个关键问题是：我们对这个“最佳”结果有多大的信心？一个读段可能存在多个得分相近的合理解释。比对质量（Mapping Quality, MAPQ）值正是为了量化这种置信度而设计的，它以Phred标度提供了一个概率度量，评估最佳比对实际上是错误的可能性 `[@problem_id:4609207]`。这项练习将揭示MAPQ分数背后的贝叶斯推理过程，它不仅考虑比对得分，还融入了先验知识（例如，经典剪接位点的普遍性），让你明白比对的置信度是如何综合评估所有可能的比对假说而得出的。", "problem": "一个RNA测序（RNA-seq）读段跨越一个假定的剪接点，并由一个使用隐马尔可夫模型（HMM）对剪接比对进行评分的可感知剪接的比对器进行评估。该比对器考虑了关于该读段来源的两个互斥的候选假设：$H_{A}$，一个与该基因已知注释轨道一致的经典供体-受体剪接（$\\mathrm{GT}$–$\\mathrm{AG}$）；以及$H_{B}$，一个注释中不存在的非经典供体-受体剪接（$\\mathrm{GC}$–$\\mathrm{AG}$）。对于观测到的碱基和空位结构，两个假设的HMM似然是相等的，即$P(D \\mid H_{A}) = P(D \\mid H_{B})$，其中$D$表示观测到的读段序列及其比对特征。该位点上经典剪接位点的先验使用情况得到了群体水平剪接点计数的支持，从而得到先验概率$P(H_{A}) = 0.9$和$P(H_{B}) = 0.1$。使用贝叶斯法则以及比对质量（MAPQ）是所报告的最佳比对不正确的概率的Phred标度（PHRED）转换这一定义，计算将$H_{A}$报告为最佳比对时的$MAPQ$。\n\n您可以假设：\n- $P(H_{A} \\mid D) = \\dfrac{P(D \\mid H_{A}) P(H_{A})}{P(D \\mid H_{A}) P(H_{A}) + P(D \\mid H_{B}) P(H_{B})}$，对于$H_{B}$也类似。\n- 所报告的最佳比对的错误概率为$p_{\\mathrm{error}} = 1 - P_{\\mathrm{best}}$，其中$P_{\\mathrm{best}}$是所选最佳假设的后验概率。\n- 对于概率$p$，Phred标度转换为$Q = -10 \\log_{10}(p)$。\n\n将$MAPQ$的最终值表示为一个无需四舍五入的精确整数。", "solution": "可感知剪接的比对器产生了两个假设，$H_{A}$和$H_{B}$，在隐马尔可夫模型下具有相等的似然，因此$P(D \\mid H_{A}) = P(D \\mid H_{B})$。先验概率为$P(H_{A}) = 0.9$和$P(H_{B}) = 0.1$。根据贝叶斯法则，\n$$\nP(H_{A} \\mid D) = \\frac{P(D \\mid H_{A}) P(H_{A})}{P(D \\mid H_{A}) P(H_{A}) + P(D \\mid H_{B}) P(H_{B})}.\n$$\n因为$P(D \\mid H_{A}) = P(D \\mid H_{B})$，将这个共同的似然表示为$L$；那么\n$$\nP(H_{A} \\mid D) = \\frac{L \\cdot 0.9}{L \\cdot 0.9 + L \\cdot 0.1} = \\frac{0.9}{0.9 + 0.1} = 0.9,\n$$\n同样地，\n$$\nP(H_{B} \\mid D) = \\frac{L \\cdot 0.1}{L \\cdot 0.9 + L \\cdot 0.1} = \\frac{0.1}{1.0} = 0.1.\n$$\n要报告的最佳比对是$H_{A}$，其后验概率为$P_{\\mathrm{best}} = P(H_{A} \\mid D) = 0.9$。所报告的最佳比对的错误概率是该报告的比对是错误的概率，即\n$$\np_{\\mathrm{error}} = 1 - P_{\\mathrm{best}} = 1 - 0.9 = 0.1.\n$$\n比对质量（MAPQ）是这个错误概率的Phred标度转换：\n$$\nMAPQ = -10 \\log_{10}(p_{\\mathrm{error}}) = -10 \\log_{10}(0.1).\n$$\n使用恒等式$\\log_{10}(0.1) = \\log_{10}(10^{-1}) = -1$，我们得到\n$$\nMAPQ = -10 \\cdot (-1) = 10.\n$$\n这已经是一个精确的整数，所以不需要四舍五入。", "answer": "$$\\boxed{10}$$", "id": "4609207"}, {"introduction": "许多RNA测序实验的最终目标是量化转录本的丰度，但这一任务因“多重映射读段”（即可能源自多个不同转录本的读段）的存在而变得复杂。期望最大化（Expectation-Maximization, EM）算法为此提供了一个强大的统计框架，用以解决这种模糊性。它通过迭代的方式，在“期望步骤”（E-step）中根据当前的丰度估计重新分配读段的归属概率，在“最大化步骤”（M-step）中根据这些概率更新转录本的丰度估计，直至整体观测数据的似然函数达到最大 `[@problem_id:4609251]`。这项高阶练习将比对得分的底层细节与转录组学中的核心生物学问题联系起来，让你通过构建EM算法，深刻理解现代生物信息学工具是如何完成转录本定量的。", "problem": "要求您在一个可感知剪接的比对设置中，设计、推导并实现一个期望最大化 (EM) 算法，用于在候选转录本之间分配多重比对的核糖核酸测序 (RNA-seq) 读段计数。核心目标是在一个基于转录本的混合模型下，最大化观测到的比对的似然。您的推导必须从最大似然估计和凸分析的基本原理出发，包括混合模型的似然函数定义以及琴生不等式。该算法必须使用从可感知剪接的比对成本计算出的比对似然，这些成本会对剪接点和错配进行惩罚，然后证明其单调性和平稳性收敛性质。\n\n基本基础如下：\n- 读段根据未知的混合比例 $\\pi_j$ 从一个由 $j \\in \\{1,\\dots,T\\}$ 索引的有限转录本集合中生成，其中 $T$ 是转录本的数量。比例 $\\pi_j$ 满足 $\\pi_j \\ge 0$ 且 $\\sum_{j=1}^{T} \\pi_j = 1$。\n- 每个读段 $i \\in \\{1,\\dots,R\\}$（其中 $R$ 是读段数量）都有一组候选转录本比对，每个比对都有一个可感知剪接的比对成本 $s_{ij}$。每个比对成本 $s_{ij}$ 由剪接比对特有的比对特征（错配数 $m_{ij}$ 和剪接点数 $g_{ij}$）的惩罚之和构成，聚合为 $s_{ij} = \\alpha \\cdot g_{ij} + \\beta \\cdot m_{ij}$，其中 $\\alpha$ 和 $\\beta$ 是正惩罚权重。比对似然被设定为与 $\\exp(-s_{ij})$ 成正比，这确保了其值为正，并为较低的比对成本建模了较高的似然。\n- 读段可能以整数或实数值权重 $w_i \\ge 0$（例如，合并的相同读段或唯一分子标识符计数）被观测到，并且只有候选比对（其中 $s_{ij}$ 有定义）对似然有贡献；非候选者被视为具有零比对似然。\n\n基于这些基础，请从第一性原理（本说明中不提供快捷公式）推导出最大化加权对数似然的 EM 更新：\n$$\n\\mathcal{L}(\\pi) = \\sum_{i=1}^{R} w_i \\cdot \\log\\left(\\sum_{j=1}^{T} \\pi_j \\cdot \\ell_{ij}\\right),\n$$\n其中对于候选比对 $\\ell_{ij} = \\exp(-s_{ij})$，否则 $\\ell_{ij} = 0$。您的推导必须明确使用对数、凸性和凹性的标准性质以及琴生不等式，来证明在 EM 算法下单调改进对数似然。您还必须描述收敛条件：跨迭代的单调非递减对数似然，以及在收敛时约束优化（对 $\\pi$ 的单纯形约束）的一阶平稳性。\n\n实现要求：\n- 对于每个提供的测试用例，根据如上定义的可感知剪接成本 $s_{ij} = \\alpha \\cdot g_{ij} + \\beta \\cdot m_{ij}$ 构建比对似然 $\\ell_{ij}$。\n- 在单纯形的内部均匀地初始化混合比例 $\\pi_j$，即对所有 $j$ 都有 $\\pi_j = \\frac{1}{T}$。\n- 迭代 EM 更新，直到对数似然的变化量和由欧几里得范数衡量的混合比例变化量均低于容差 $\\varepsilon$，其中对数似然变化的 $\\varepsilon = 10^{-12}$，混合比例变化的 $\\varepsilon = 10^{-12}$。将最大迭代次数限制在 $N_{\\text{max}} = 10000$。\n- 通过验证对数似然值序列 $\\{\\mathcal{L}^{(t)}\\}_{t=0}^{t_{\\text{final}}}$ 在所有迭代中都满足 $\\mathcal{L}^{(t+1)} \\ge \\mathcal{L}^{(t)} - \\delta$（使用一个微小的数值松弛量 $\\delta = 10^{-12}$）来证明单调性。\n- 通过验证在最终迭代值处，对数似然关于 $\\pi$ 的梯度投影到单纯形的切空间上后在数值上接近于零，来证明平稳性。梯度分量定义为\n$$\ng_j(\\pi) = \\sum_{i=1}^{R} w_i \\cdot \\frac{\\ell_{ij}}{\\sum_{k=1}^{T} \\pi_k \\ell_{ik}},\n$$\n到切空间的投影为 $g_j - \\bar{g}$，其中 $\\bar{g} = \\frac{1}{T} \\sum_{j=1}^{T} g_j$。如果投影梯度的欧几里得范数小于 $\\tau$（其中 $\\tau = 10^{-8}$），则报告平稳性。\n\n测试套件：\n在以下科学上合理、可感知剪接的比对场景中实现您的算法。对于每种情况，为候选比对计算 $\\ell_{ij} = \\exp(-(\\alpha \\cdot g_{ij} + \\beta \\cdot m_{ij}))$；对于非候选者，设置 $\\ell_{ij} = 0$。下面给出的所有数字必须完全按照规定处理。\n\n- 情况 $\\mathbf{A}$（理想路径，多样的多重比对）：\n  - 转录本: $T = 3$\n  - 读段: $R = 4$\n  - 惩罚: $\\alpha = 2.0$, $\\beta = 1.0$\n  - 权重: $w = [1, 1, 1, 1]$\n  - 每个读段 $i$ 和转录本 $j$ 的错配数 $m_{ij}$ 和剪接点数 $g_{ij}$（所有都是候选）：\n    - 读段 $i = 1$: $m = [1, 2, 3]$, $g = [1, 0, 1]$\n    - 读段 $i = 2$: $m = [0, 1, 2]$, $g = [2, 1, 0]$\n    - 读段 $i = 3$: $m = [3, 0, 1]$, $g = [0, 0, 2]$\n    - 读段 $i = 4$: $m = [2, 1, 0]$, $g = [2, 0, 1]$\n\n- 情况 $\\mathbf{B}$（边界情况，包含唯一和部分比对）：\n  - 转录本: $T = 3$\n  - 读段: $R = 3$\n  - 惩罚: $\\alpha = 1.5$, $\\beta = 0.5$\n  - 权重: $w = [1, 1, 2]$\n  - 候选集和特征（使用-1表示非候选，这将导致 $\\ell_{ij} = 0$）：\n    - 读段 $i = 1$: $m = [-1, 0, -1]$, $g = [-1, 0, -1]$（只有转录本 $j = 2$ 是候选）\n    - 读段 $i = 2$: $m = [1, -1, 1]$, $g = [0, -1, 1]$（候选者为 $j = 1$ 和 $j = 3$）\n    - 读段 $i = 3$: $m = [3, 2, 0]$, $g = [0, 1, 0]$（所有转录本都是候选）\n\n- 情况 $\\mathbf{C}$（每个读段在不同转录本上具有相同的似然）：\n  - 转录本: $T = 2$\n  - 读段: $R = 2$\n  - 惩罚: $\\alpha = 1.0$, $\\beta = 1.0$\n  - 权重: $w = [1, 3]$\n  - 候选集和特征：\n    - 读段 $i = 1$: $m = [1, 1]$, $g = [1, 1]$（两个转录本都是候选）\n    - 读段 $i = 2$: $m = [2, 2]$, $g = [0, 0]$（两个转录本都是候选）\n\n- 情况 $\\mathbf{D}$（接近边界，极端的惩罚和并列情况）：\n  - 转录本: $T = 4$\n  - 读段: $R = 3$\n  - 惩罚: $\\alpha = 2.0$, $\\beta = 1.0$\n  - 权重: $w = [2, 1, 1]$\n  - 候选集和特征：\n    - 读段 $i = 1$: $m = [0, 5, -1, -1]$, $g = [0, 1, -1, -1]$（候选者为 $j = 1$ 和 $j = 2$）\n    - 读段 $i = 2$: $m = [-1, 0, 1, -1]$, $g = [-1, 0, 3, -1]$（候选者为 $j = 2$ 和 $j = 3$）\n    - 读段 $i = 3$: $m = [-1, -1, 0, 0]$, $g = [-1, -1, 0, 0]$（候选者为 $j = 3$ 和 $j = 4$；该读段的成本存在并列情况）\n\n输出规格：\n- 对于每个测试用例，报告一个列表，其中包含按转录本索引顺序排列的最终转录本混合比例 $\\pi_j$（每个值在数值上四舍五入到6位小数），后面跟着两个布尔值：一个指示对数似然序列是否在数值松弛量 $\\delta = 10^{-12}$ 内是单调非递减的，另一个指示是否满足了容差为 $\\tau = 10^{-8}$ 的投影梯度平稳性条件。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例。例如，输出应类似于 $[[p_{1},p_{2},\\dots,\\text{True},\\text{True}],\\dots]$，并用实际数值替换。\n\n此问题不涉及物理单位或角度单位；请按所述报告实数，不要使用百分号。算法必须以自包含的方式实现，无需外部输入或文件。", "solution": "用户提供的问题已经过分析，并被认为是有效的。该问题科学上合理、适定、客观且自包含。问题要求推导和实现一个期望最大化 (EM) 算法，用于一个在生物信息学中常用于转录本定量的混合模型。其推导基于最大似然估计的第一性原理，而实现细节，包括测试用例和收敛标准，都得到了精确的指定。\n\n### 期望最大化 (EM) 算法的推导\n\n目标是找到转录本混合比例 $\\pi = (\\pi_1, \\pi_2, \\dots, \\pi_T)$，以最大化加权对数似然函数 $\\mathcal{L}(\\pi)$。这些比例必须满足单纯形约束：对所有 $j \\in \\{1, \\dots, T\\}$ 都有 $\\pi_j \\ge 0$ 且 $\\sum_{j=1}^{T} \\pi_j = 1$。对数似然函数由下式给出：\n$$\n\\mathcal{L}(\\pi) = \\sum_{i=1}^{R} w_i \\cdot \\log\\left(\\sum_{j=1}^{T} \\pi_j \\cdot \\ell_{ij}\\right)\n$$\n其中 $R$ 是读段的数量，$T$ 是转录本的数量，$w_i$ 是读段 $i$ 的权重，而 $\\ell_{ij}$ 是读段 $i$ 比对到转录本 $j$ 的似然。对于候选比对，$\\ell_{ij}$ 定义为 $\\exp(-s_{ij})$，其中 $s_{ij} = \\alpha \\cdot g_{ij} + \\beta \\cdot m_{ij}$，否则 $\\ell_{ij} = 0$。\n\nEM 算法是一种在具有潜变量的模型中寻找最大似然估计的迭代过程。设 $\\pi^{(t)}$ 为第 $t$ 次迭代时的混合比例向量。我们寻求一个新的向量 $\\pi$ 来增加对数似然，即 $\\mathcal{L}(\\pi) \\ge \\mathcal{L}(\\pi^{(t)})$。\n\n#### E-步（期望）\n\n“E-步”涉及计算完全数据对数似然的期望，该期望以观测数据和当前参数估计 $\\pi^{(t)}$ 为条件。这等同于计算在给定当前参数 $\\pi^{(t)}$ 的情况下，读段 $i$ 由转录本 $j$ 生成的后验概率或“责任”。我们将此量表示为 $q_{ij}^{(t)}$：\n$$\nq_{ij}^{(t)} = P(\\text{读段 } i \\text{ 来自转录本 } j | \\text{数据}, \\pi^{(t)}) = \\frac{P(\\text{读段 } i | \\text{转录本 } j) \\cdot P(\\text{转录本 } j | \\pi^{(t)})}{\\sum_{k=1}^{T} P(\\text{读段 } i | \\text{转录本 } k) \\cdot P(\\text{转录本 } k | \\pi^{(t)})}\n$$\n根据我们的模型，$P(\\text{读段 } i | \\text{转录本 } j)$ 与 $\\ell_{ij}$ 成正比，且 $P(\\text{转录本 } j | \\pi^{(t)}) = \\pi_j^{(t)}$。这得出：\n$$\nq_{ij}^{(t)} = \\frac{\\pi_j^{(t)} \\ell_{ij}}{\\sum_{k=1}^{T} \\pi_k^{(t)} \\ell_{ik}}\n$$\n注意，对于每个读段 $i$，这些责任的总和为一：$\\sum_{j=1}^{T} q_{ij}^{(t)} = 1$。\n\n#### M-步（最大化）与单调性证明\n\n“M-步”涉及找到参数 $\\pi$ 以最大化对数似然的一个下界。为了推导这一点，考虑对数似然的变化量：\n$$\n\\mathcal{L}(\\pi) - \\mathcal{L}(\\pi^{(t)}) = \\sum_{i=1}^{R} w_i \\left[ \\log\\left(\\sum_{j=1}^{T} \\pi_j \\ell_{ij}\\right) - \\log\\left(\\sum_{k=1}^{T} \\pi_k^{(t)} \\ell_{ik}\\right) \\right] = \\sum_{i=1}^{R} w_i \\log\\left(\\frac{\\sum_{j=1}^{T} \\pi_j \\ell_{ij}}{\\sum_{k=1}^{T} \\pi_k^{(t)} \\ell_{ik}}\\right)\n$$\n我们可以通过引入责任 $q_{ij}^{(t)}$ 来重写对数内的项：\n$$\n\\frac{\\sum_{j=1}^{T} \\pi_j \\ell_{ij}}{\\sum_{k=1}^{T} \\pi_k^{(t)} \\ell_{ik}} = \\sum_{j=1}^{T} \\frac{\\pi_j^{(t)} \\ell_{ij}}{\\sum_{k=1}^{T} \\pi_k^{(t)} \\ell_{ik}} \\cdot \\frac{\\pi_j}{\\pi_j^{(t)}} = \\sum_{j=1}^{T} q_{ij}^{(t)} \\frac{\\pi_j}{\\pi_j^{(t)}}\n$$\n对数似然的变化量变为：\n$$\n\\mathcal{L}(\\pi) - \\mathcal{L}(\\pi^{(t)}) = \\sum_{i=1}^{R} w_i \\log\\left(\\sum_{j=1}^{T} q_{ij}^{(t)} \\frac{\\pi_j}{\\pi_j^{(t)}}\\right)\n$$\n由于对数函数 $\\log(x)$ 是凹函数，我们可以应用琴生不等式。对于每个读段 $i$，$j=1, \\dots, T$ 的 $q_{ij}^{(t)}$ 值是非负的且总和为1。它们可以被视为凸组合中的权重。琴生不等式指出，对于一个凹函数 $f$，$f(\\sum \\lambda_j x_j) \\ge \\sum \\lambda_j f(x_j)$。将其应用于此处：\n$$\n\\log\\left(\\sum_{j=1}^{T} q_{ij}^{(t)} \\frac{\\pi_j}{\\pi_j^{(t)}}\\right) \\ge \\sum_{j=1}^{T} q_{ij}^{(t)} \\log\\left(\\frac{\\pi_j}{\\pi_j^{(t)}}\\right)\n$$\n这为对数似然的变化量建立了一个下界：\n$$\n\\mathcal{L}(\\pi) - \\mathcal{L}(\\pi^{(t)}) \\ge \\sum_{i=1}^{R} w_i \\sum_{j=1}^{T} q_{ij}^{(t)} \\log\\left(\\frac{\\pi_j}{\\pi_j^{(t)}}\\right)\n$$\nEM 算法的 M-步选择新的参数 $\\pi^{(t+1)}$ 为最大化此下界的 $\\pi$ 值。相对于 $\\pi$ 最大化下界等价于最大化以下目标函数，记为 $\\mathcal{Q}(\\pi | \\pi^{(t)})$：\n$$\n\\mathcal{Q}(\\pi | \\pi^{(t)}) = \\sum_{i=1}^{R} w_i \\sum_{j=1}^{T} q_{ij}^{(t)} \\log(\\pi_j)\n$$\n（我们省略了相对于 $\\pi$ 是常数的项）。我们必须在约束 $\\sum_{j=1}^{T} \\pi_j = 1$ 下最大化 $\\mathcal{Q}(\\pi | \\pi^{(t)})$。我们使用一个拉格朗日乘数 $\\lambda$：\n$$\nL(\\pi, \\lambda) = \\sum_{i=1}^{R} w_i \\sum_{j=1}^{T} q_{ij}^{(t)} \\log(\\pi_j) - \\lambda \\left(\\sum_{j=1}^{T} \\pi_j - 1\\right)\n$$\n对 $\\pi_j$ 求偏导数并将其设为 $0$：\n$$\n\\frac{\\partial L}{\\partial \\pi_j} = \\frac{1}{\\pi_j} \\sum_{i=1}^{R} w_i q_{ij}^{(t)} - \\lambda = 0 \\implies \\pi_j = \\frac{1}{\\lambda} \\sum_{i=1}^{R} w_i q_{ij}^{(t)}\n$$\n为了求 $\\lambda$，我们对所有 $j$ 求和：\n$$\n\\sum_{j=1}^{T} \\pi_j = 1 = \\frac{1}{\\lambda} \\sum_{j=1}^{T} \\sum_{i=1}^{R} w_i q_{ij}^{(t)} = \\frac{1}{\\lambda} \\sum_{i=1}^{R} w_i \\left(\\sum_{j=1}^{T} q_{ij}^{(t)}\\right) = \\frac{1}{\\lambda} \\sum_{i=1}^{R} w_i\n$$\n因此，$\\lambda = \\sum_i w_i$。将其代回，得到 $\\pi^{(t+1)}$ 的 M-步更新规则：\n$$\n\\pi_j^{(t+1)} = \\frac{\\sum_{i=1}^{R} w_i q_{ij}^{(t)}}{\\sum_{k=1}^{R} w_k}\n$$\n通过这种构造，可以保证对数似然在每次迭代中都是非递减的：\n$$\n\\mathcal{L}(\\pi^{(t+1)}) \\ge \\mathcal{L}(\\pi^{(t)}) + \\sum_{i=1}^{R} w_i \\sum_{j=1}^{T} q_{ij}^{(t)} \\log\\left(\\frac{\\pi_j^{(t+1)}}{\\pi_j^{(t)}}\\right) \\ge \\mathcal{L}(\\pi^{(t)}) + \\sum_{i=1}^{R} w_i \\sum_{j=1}^{T} q_{ij}^{(t)} \\log\\left(\\frac{\\pi_j^{(t)}}{\\pi_j^{(t)}}\\right) = \\mathcal{L}(\\pi^{(t)})\n$$\n第一个不等式来自琴生不等式的界，第二个不等式来自于 $\\pi^{(t+1)}$ 最大化该界的事实。这证明了算法的单调非递减性质。\n\n#### 收敛性与平稳性\n\nEM 算法收敛到似然函数的一个平稳点。如果一个点 $\\pi^*$ 满足 Karush-Kuhn-Tucker (KKT) 条件，那么它就是该约束优化问题的平稳点。对于单纯形约束，如果所有 $\\pi^*_j > 0$，这简化为拉格朗日函数的梯度为零的条件。对数似然的梯度由下式给出：\n$$\ng_j(\\pi) = \\frac{\\partial \\mathcal{L}(\\pi)}{\\partial \\pi_j} = \\sum_{i=1}^{R} w_i \\frac{\\ell_{ij}}{\\sum_{k=1}^{T} \\pi_k \\ell_{ik}}\n$$\n在 EM 算法的一个不动点处，$\\pi^{(t+1)} = \\pi^{(t)} = \\pi^*$。M-步更新规则变为：\n$$\n\\pi_j^* = \\frac{\\sum_{i=1}^{R} w_i q_{ij}^*}{\\sum_{k=1}^{R} w_k} = \\frac{1}{\\sum_{k=1}^{R} w_k} \\sum_{i=1}^{R} w_i \\frac{\\pi_j^* \\ell_{ij}}{\\sum_{k=1}^{T} \\pi_k^* \\ell_{ik}}\n$$\n如果 $\\pi_j^* > 0$，我们可以用它来除：\n$$\n1 = \\frac{1}{\\sum_{k=1}^{R} w_k} \\sum_{i=1}^{R} w_i \\frac{\\ell_{ij}}{\\sum_{k=1}^{T} \\pi_k^* \\ell_{ik}} \\implies \\sum_{k=1}^{R} w_k = g_j(\\pi^*)\n$$\n这意味着在收敛时，对于所有 $\\pi_j^* > 0$ 的转录本，梯度分量 $g_j(\\pi^*)$ 都等于一个常数（$\\sum w_k$）。因此，投影梯度 $g_j - \\bar{g}$（其中 $\\bar{g}$ 是梯度分量的均值）将是一个零向量。检查此投影梯度的范数是否接近于零是验证算法是否已达到平稳点的有效方法。\n\n### 实现策略\n\n该算法将使用 Python 和 `numpy` 库来实现，以进行高效的向量化计算。\n1.  **预处理**：对于每个测试用例，构建比对似然矩阵 $\\ell_{ij}$。首先计算比对成本 $s_{ij} = \\alpha g_{ij} + \\beta m_{ij}$。非候选比对（由像 $-1$ 这样的输入指示）通过将其似然设置为 $0$ 来处理。\n2.  **初始化**：混合比例 $\\pi$ 被均匀初始化：对所有 $j$ 都有 $\\pi_j = 1/T$。\n3.  **迭代循环**：EM 算法进行迭代，直到满足收敛标准：\n    *   **E-步**：为每个读段计算分母 $d_i = \\sum_k \\pi_k \\ell_{ik}$。这是一个矩阵-向量积 `l @ pi`。然后计算责任矩阵 $q$ 为 $q_{ij} = \\pi_j \\ell_{ij} / d_i$。这是通过广播完成的。\n    *   **M-步**：计算新的比例 $\\pi_{\\text{new}}$。分子是每个转录本的加权责任之和，可以计算为矩阵-向量积 `q.T @ w`。通过总权重 $\\sum w_k$ 进行归一化得到新的 $\\pi$。\n    *   **收敛性和单调性检查**：计算对数似然的变化量 $|\\mathcal{L}_{\\text{new}} - \\mathcal{L}_{\\text{old}}|$ 和欧几里得距离 $||\\pi_{\\text{new}} - \\pi_{\\text{old}}||_2$。如果两者都低于容差 $\\varepsilon=10^{-12}$，或者达到最大迭代次数（$10000$），则循环终止。通过确保在每一步骤中 $\\mathcal{L}_{\\text{new}} \\ge \\mathcal{L}_{\\text{old}} - \\delta$（数值松弛量 $\\delta=10^{-12}$）来检查单调性。\n4.  **后处理**：收敛后，通过计算投影梯度 $g - \\bar{g}$ 的 L2 范数并将其与容差 $\\tau=10^{-8}$ 进行比较，来执行平稳性的最终检查。\n5.  **输出格式化**：将最终的 $\\pi$ 向量四舍五入到6位小数，并与单调性和平稳性的布尔标志组合成所需的输出格式。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the EM algorithm on the specified test cases.\n    \"\"\"\n    \n    # Define test cases as per the problem statement.\n    # Format: (T, R, alpha, beta, w, m_matrix, g_matrix)\n    test_cases = [\n        # Case A\n        (3, 4, 2.0, 1.0, [1, 1, 1, 1], \n         [[1, 2, 3], [0, 1, 2], [3, 0, 1], [2, 1, 0]], \n         [[1, 0, 1], [2, 1, 0], [0, 0, 2], [2, 0, 1]]),\n        \n        # Case B\n        (3, 3, 1.5, 0.5, [1, 1, 2],\n         [[-1, 0, -1], [1, -1, 1], [3, 2, 0]],\n         [[-1, 0, -1], [0, -1, 1], [0, 1, 0]]),\n        \n        # Case C\n        (2, 2, 1.0, 1.0, [1, 3],\n         [[1, 1], [2, 2]],\n         [[1, 1], [0, 0]]),\n        \n        # Case D\n        (4, 3, 2.0, 1.0, [2, 1, 1],\n         [[0, 5, -1, -1], [-1, 0, 1, -1], [-1, -1, 0, 0]],\n         [[0, 1, -1, -1], [-1, 0, 3, -1], [-1, -1, 0, 0]])\n    ]\n\n    all_results = []\n    \n    # Tolerances and parameters\n    max_iter = 10000\n    ll_tol = 1e-12\n    pi_tol = 1e-12\n    mono_slack = 1e-12\n    stat_tol = 1e-8\n    \n    for case in test_cases:\n        T, R, alpha, beta, w_list, m_list, g_list = case\n        \n        # --- Data Setup ---\n        w = np.array(w_list, dtype=np.float64)\n        m = np.array(m_list, dtype=np.float64)\n        g = np.array(g_list, dtype=np.float64)\n        \n        # Create a mask for valid alignments\n        valid_mask = m != -1\n\n        # Calculate splice-aware alignment costs s_ij\n        s = np.zeros_like(m)\n        s[valid_mask] = alpha * g[valid_mask] + beta * m[valid_mask]\n        \n        # Calculate alignment likelihoods l_ij\n        l = np.zeros_like(s)\n        l[valid_mask] = np.exp(-s[valid_mask])\n        \n        # --- EM Algorithm ---\n        \n        # Initialization\n        pi = np.full(T, 1.0 / T, dtype=np.float64)\n        total_weight = np.sum(w)\n        \n        # Log-likelihood calculation helper\n        def get_log_likelihood(pi_vec, l_mat, w_vec):\n            # Add a small constant to prevent log(0)\n            inner_sum = l_mat @ pi_vec + 1e-30 \n            return np.sum(w_vec * np.log(inner_sum))\n\n        current_ll = get_log_likelihood(pi, l, w)\n        is_monotone = True\n\n        for k in range(max_iter):\n            prev_pi = pi.copy()\n            prev_ll = current_ll\n            \n            # --- E-Step ---\n            # Denominators for q_ij calculation\n            denominators = l @ pi\n            # Prevent division by zero, though unlikely with problem constraints\n            denominators[denominators == 0] = 1.0\n            \n            # Responsibilities q_ij\n            q = (l * pi[np.newaxis, :]) / denominators[:, np.newaxis]\n            \n            # --- M-Step ---\n            # Numerators for pi_j update\n            effective_counts = q.T @ w\n            pi = effective_counts / total_weight\n            \n            # --- Convergence and Monotonicity Check ---\n            current_ll = get_log_likelihood(pi, l, w)\n            \n            # Monotonicity check, allowing for small numerical slack\n            if current_ll  prev_ll - mono_slack:\n                is_monotone = False\n\n            pi_change = np.linalg.norm(pi - prev_pi)\n            ll_change = np.abs(current_ll - prev_ll)\n            \n            if pi_change  pi_tol and ll_change  ll_tol:\n                break\n\n        # --- Stationarity Check ---\n        final_denominators = l @ pi + 1e-30\n        grad_mat = l / final_denominators[:, np.newaxis]\n        grad_vec = grad_mat.T @ w\n        proj_grad = grad_vec - np.mean(grad_vec)\n        proj_grad_norm = np.linalg.norm(proj_grad)\n        is_stationary = proj_grad_norm  stat_tol\n        \n        # Format results for this case\n        rounded_pi = [f'{p:.6f}' for p in pi]\n        result = f'[{\",\".join(rounded_pi)},{str(is_monotone)},{str(is_stationary)}]'\n        all_results.append(result)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "4609251"}]}