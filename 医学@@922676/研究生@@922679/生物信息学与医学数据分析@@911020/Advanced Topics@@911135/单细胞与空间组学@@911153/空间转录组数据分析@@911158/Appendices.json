{"hands_on_practices": [{"introduction": "在进行任何下游分析之前，对原始空间转录组学数据进行预处理至关重要。原始基因计数会受到技术因素的影响，例如每个空间点（spot）的测序深度或捕获效率不同。本练习将指导您完成两个核心的预处理步骤：文库大小因子归一化和对数变换，这些步骤旨在消除此类技术偏差，使不同空间点之间的基因表达水平具有可比性 [@problem_id:4608974]。通过亲手实现这些计算，您将对如何准备用于复杂空间分析的数据有一个扎实的基础。", "problem": "在空间转录组学中，一个组织切片被分割成多个空间点，每个空间点捕获来自附近细胞的信使核糖核酸 (mRNA) 分子。所得数据汇总在一个非负整数矩阵 $X \\in \\mathbb{N}_0^{n \\times p}$ 中，其中 $n$ 是空间点的数量，$p$ 是基因的数量。令 $x_{ij}$ 表示点 $i$ 中基因 $j$ 的原始计数。由于每个点可能具有不同的测序深度或捕获效率，因此使用一个正的、逐点的缩放因子 $s_i \\in \\mathbb{R}_{0}$ 来解释这些差异。一种用于下游分析的常用转换方法是生成大小因子归一化的计数，然后应用带有伪计数和用户指定的缩放参数 $\\alpha \\in \\mathbb{R}_{\\ge 0}$ 的对数转换。使用自然对数。\n\n基本和建模假设：\n- 原始计数为非负整数：对于所有 $i \\in \\{1,\\dots,n\\}$ 和 $j \\in \\{1,\\dots,p\\}$，$x_{ij} \\in \\mathbb{N}_0$。\n- 大小因子为严格正实数：对于所有 $i \\in \\{1,\\dots,n\\}$，$s_i \\in \\mathbb{R}_{0}$。\n- 对数转换使用自然对数和伪计数 $1$，以确保当计数为零时得到有限值；用户提供一个非负缩放参数 $\\alpha \\in \\mathbb{R}_{\\ge 0}$。\n- 大小因子归一化的目的是消除乘性的、点特异性的采样深度效应，同时保留一个点内的相对基因表达。\n- 在归一化之后应用对数转换，以压缩动态范围并稳定方差，同时通过对数的单调性保持顺序。\n\n您的任务是编写一个程序，针对几个指定的测试用例，为每个用例执行以下操作：\n1. 给定 $X$、$s$ 和 $\\alpha$，计算大小因子归一化的计数，其中对于每个点 $i$ 和基因 $j$，归一化值是该条目的原始计数与该点的大小因子之比。\n2. 通过对每个条目的归一化计数值乘以 $\\alpha$ 再加一，然后取自然对数，来计算对数归一化的值。\n3. 将归一化计数和对数归一化值都四舍五入到 $6$ 位小数，并以行主序将它们作为一维列表报告。\n\n使用以下测试套件。每个测试用例提供 $X$、$s$ 和 $\\alpha$：\n\n- 测试用例 $1$（一般情况，中等数值）：\n  - $X = \\begin{bmatrix} 10  0  5 \\\\ 4  6  0 \\end{bmatrix}$，所以 $n = 2$, $p = 3$。\n  - $s = [10, 10]$。\n  - $\\alpha = 1$。\n\n- 测试用例 $2$（大小因子等于行和，检查总数的归一化）：\n  - $X = \\begin{bmatrix} 3  7 \\\\ 0  5 \\\\ 2  3 \\end{bmatrix}$，所以 $n = 3$, $p = 2$。\n  - $s = [10, 5, 5]$。\n  - $\\alpha = 2$。\n\n- 测试用例 $3$（$\\alpha$ 为零，产生零对数归一化值）：\n  - $X = \\begin{bmatrix} 0  1  2 \\\\ 3  0  4 \\end{bmatrix}$，所以 $n = 2$, $p = 3$。\n  - $s = [1, 2]$。\n  - $\\alpha = 0$。\n\n- 测试用例 $4$（极端缩放，非常小的大小因子和非常大的计数）：\n  - $X = \\begin{bmatrix} 0  1000000 \\end{bmatrix}$，所以 $n = 1$, $p = 2$。\n  - $s = [10^{-6}]$。\n  - $\\alpha = 10^{-3}$。\n\n程序规范：\n- 对于每个测试用例，输出一个包含两个列表的列表：\n  - 第一个是大小因子归一化的计数，按行主序扁平化，每个条目四舍五入到 $6$ 位小数。\n  - 第二个是对数归一化的值，按行主序扁平化，每个条目四舍五入到 $6$ 位小数。\n- 将所有测试用例的结果按顺序聚合到一个列表中。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$ [result\\_1,result\\_2,\\dots]$）。每个 $result\\_k$ 必须是如上所述的包含两个实数列表的列表。\n\n本问题中的所有量都是无量纲的；因此，不需要物理单位。不出现角度。不使用百分比。所有对数计算都必须使用自然对数。", "solution": "问题陈述已经过严格验证，并被确定为有效。它在生物信息学领域，特别是空间转录组学方面，具有科学依据，并且在数学上是良构的。所有数据、定义和约束都是自洽且一致的，从而可以计算出唯一、可验证的解。\n\n任务是对原始基因计数矩阵执行两种标准数据转换：大小因子归一化和随后的对数转换。每个测试用例的过程由一组精确的数学运算定义。\n\n设原始计数矩阵表示为 $X \\in \\mathbb{N}_0^{n \\times p}$，其中 $x_{ij}$ 是点 $i$ 和基因 $j$ 的计数。设 $s = [s_1, s_2, \\dots, s_n]$ 是正的、逐点大小因子的向量，其中 $s_i \\in \\mathbb{R}_{0}$。设 $\\alpha \\in \\mathbb{R}_{\\ge 0}$ 是一个用户指定的缩放参数。\n\n**第 1 步：大小因子归一化**\n大小因子归一化的目的是调整不同空间点之间文库大小或测序深度的差异。这是通过将一个点中每个基因的原始计数除以该点对应的大小因子来实现的。\n\n设 $N$ 是大小因子归一化计数的矩阵。该矩阵的一个元素 $n_{ij}$ 计算如下：\n$$\nn_{ij} = \\frac{x_{ij}}{s_i}\n$$\n此操作应用于矩阵 $X$ 中的所有条目。生成的矩阵 $N$ 与 $X$ 具有相同的维度。由于 $x_{ij} \\ge 0$ 且 $s_i  0$，因此 $n_{ij} \\ge 0$。\n\n**第 2 步：对数转换**\n归一化后，应用对数转换来压缩数据范围并稳定方差，在计数数据中，方差通常依赖于均值。该转换包括一个伪计数 $1$ 以防止对零取对数，以及一个缩放参数 $\\alpha$。\n\n设 $L$ 是对数归一化值的矩阵。该矩阵的一个元素 $l_{ij}$ 使用自然对数 ($\\ln$) 计算如下：\n$$\nl_{ij} = \\ln(1 + \\alpha \\cdot n_{ij})\n$$\n由于 $\\alpha \\ge 0$ 且 $n_{ij} \\ge 0$，对数的参数 $1 + \\alpha \\cdot n_{ij}$ 总是大于或等于 $1$。因此，对数归一化值 $l_{ij}$ 总是良定义的且非负 ($l_{ij} \\ge 0$)。\n\n现在将此过程应用于每个提供的测试用例。\n\n**测试用例 1：**\n- 给定：$X = \\begin{bmatrix} 10  0  5 \\\\ 4  6  0 \\end{bmatrix}$, $s = [10, 10]$, $\\alpha = 1$。\n- 归一化计数 $N$：\n$$\nN = \\begin{bmatrix} 10/10  0/10  5/10 \\\\ 4/10  6/10  0/10 \\end{bmatrix} = \\begin{bmatrix} 1.0  0.0  0.5 \\\\ 0.4  0.6  0.0 \\end{bmatrix}\n$$\n- 对数归一化值 $L$：\n$$\nL = \\begin{bmatrix} \\ln(1 + 1 \\cdot 1.0)  \\ln(1 + 1 \\cdot 0.0)  \\ln(1 + 1 \\cdot 0.5) \\\\ \\ln(1 + 1 \\cdot 0.4)  \\ln(1 + 1 \\cdot 0.6)  \\ln(1 + 1 \\cdot 0.0) \\end{bmatrix} = \\begin{bmatrix} \\ln(2.0)  \\ln(1.0)  \\ln(1.5) \\\\ \\ln(1.4)  \\ln(1.6)  \\ln(1.0) \\end{bmatrix}\n$$\n- $L \\approx \\begin{bmatrix} 0.693147  0.0  0.405465 \\\\ 0.336472  0.470004  0.0 \\end{bmatrix}$\n- 扁平化和四舍五入后的结果：\n  - $N_{flat} \\approx [1.000000, 0.000000, 0.500000, 0.400000, 0.600000, 0.000000]$\n  - $L_{flat} \\approx [0.693147, 0.000000, 0.405465, 0.336472, 0.470004, 0.000000]$\n\n**测试用例 2：**\n- 给定：$X = \\begin{bmatrix} 3  7 \\\\ 0  5 \\\\ 2  3 \\end{bmatrix}$, $s = [10, 5, 5]$, $\\alpha = 2$。\n- 归一化计数 $N$：\n$$\nN = \\begin{bmatrix} 3/10  7/10 \\\\ 0/5  5/5 \\\\ 2/5  3/5 \\end{bmatrix} = \\begin{bmatrix} 0.3  0.7 \\\\ 0.0  1.0 \\\\ 0.4  0.6 \\end{bmatrix}\n$$\n- 对数归一化值 $L$：\n$$\nL = \\begin{bmatrix} \\ln(1 + 2 \\cdot 0.3)  \\ln(1 + 2 \\cdot 0.7) \\\\ \\ln(1 + 2 \\cdot 0.0)  \\ln(1 + 2 \\cdot 1.0) \\\\ \\ln(1 + 2 \\cdot 0.4)  \\ln(1 + 2 \\cdot 0.6) \\end{bmatrix} = \\begin{bmatrix} \\ln(1.6)  \\ln(2.4) \\\\ \\ln(1.0)  \\ln(3.0) \\\\ \\ln(1.8)  \\ln(2.2) \\end{bmatrix}\n$$\n- $L \\approx \\begin{bmatrix} 0.470004  0.875469 \\\\ 0.0  1.098612 \\\\ 0.587787  0.788457 \\end{bmatrix}$\n- 扁平化和四舍五入后的结果：\n  - $N_{flat} \\approx [0.300000, 0.700000, 0.000000, 1.000000, 0.400000, 0.600000]$\n  - $L_{flat} \\approx [0.470004, 0.875469, 0.000000, 1.098612, 0.587787, 0.788457]$\n\n**测试用例 3：**\n- 给定：$X = \\begin{bmatrix} 0  1  2 \\\\ 3  0  4 \\end{bmatrix}$, $s = [1, 2]$, $\\alpha = 0$。\n- 归一化计数 $N$：\n$$\nN = \\begin{bmatrix} 0/1  1/1  2/1 \\\\ 3/2  0/2  4/2 \\end{bmatrix} = \\begin{bmatrix} 0.0  1.0  2.0 \\\\ 1.5  0.0  2.0 \\end{bmatrix}\n$$\n- 对数归一化值 $L$：\n$$\nL = \\ln(1 + 0 \\cdot N) = \\ln(\\begin{bmatrix} 1  1  1 \\\\ 1  1  1 \\end{bmatrix}) = \\begin{bmatrix} 0.0  0.0  0.0 \\\\ 0.0  0.0  0.0 \\end{bmatrix}\n$$\n- 扁平化和四舍五入后的结果：\n  - $N_{flat} \\approx [0.000000, 1.000000, 2.000000, 1.500000, 0.000000, 2.000000]$\n  - $L_{flat} \\approx [0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000]$\n\n**测试用例 4：**\n- 给定：$X = \\begin{bmatrix} 0  1000000 \\end{bmatrix}$, $s = [10^{-6}]$, $\\alpha = 10^{-3}$。\n- 归一化计数 $N$：\n$$\nN = \\begin{bmatrix} 0/10^{-6}  10^6/10^{-6} \\end{bmatrix} = \\begin{bmatrix} 0.0  10^{12} \\end{bmatrix}\n$$\n- 对数归一化值 $L$：\n$$\nL = \\begin{bmatrix} \\ln(1 + 10^{-3} \\cdot 0.0)  \\ln(1 + 10^{-3} \\cdot 10^{12}) \\end{bmatrix} = \\begin{bmatrix} \\ln(1.0)  \\ln(1 + 10^9) \\end{bmatrix}\n$$\n- $L \\approx \\begin{bmatrix} 0.0  20.723266 \\end{bmatrix}$（注意，对于大的 $z$，$\\ln(1+z) \\approx \\ln(z)$）。此处，$\\ln(1+10^9) \\approx \\ln(10^9) = 9 \\ln(10) \\approx 9 \\times 2.302585 = 20.723265$。\n- 扁平化和四舍五入后的结果：\n  - $N_{flat} \\approx [0.000000, 1000000000000.000000]$\n  - $L_{flat} \\approx [0.000000, 20.723266]$\n\n实现将遵循这些计算，使用数值库以提高效率和精度，并按规定格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spatial transcriptomics normalization problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"X\": np.array([[10, 0, 5], [4, 6, 0]]),\n            \"s\": np.array([10, 10]),\n            \"alpha\": 1.0\n        },\n        {\n            \"X\": np.array([[3, 7], [0, 5], [2, 3]]),\n            \"s\": np.array([10, 5, 5]),\n            \"alpha\": 2.0\n        },\n        {\n            \"X\": np.array([[0, 1, 2], [3, 0, 4]]),\n            \"s\": np.array([1, 2]),\n            \"alpha\": 0.0\n        },\n        {\n            \"X\": np.array([[0, 1000000]]),\n            \"s\": np.array([1e-6]),\n            \"alpha\": 1e-3\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        X = case[\"X\"]\n        s = case[\"s\"]\n        alpha = case[\"alpha\"]\n        \n        # Ensure s is a column vector for broadcasting.\n        # This divides each row of X by the corresponding element in s.\n        s_col = s.reshape(-1, 1)\n        \n        # Step 1: Compute size-factor-normalized counts.\n        # The result n_ij = x_ij / s_i.\n        normalized_counts = X / s_col\n        \n        # Step 2: Compute log-normalized values.\n        # The result l_ij = log(1 + alpha * n_ij).\n        log_normalized_values = np.log(1 + alpha * normalized_counts)\n        \n        # Step 3: Round, flatten in row-major order, and convert to lists.\n        # Rounding to 6 decimal places.\n        rounded_normalized = np.round(normalized_counts, 6)\n        rounded_log_normalized = np.round(log_normalized_values, 6)\n        \n        # Flattening (default is row-major).\n        flat_normalized = rounded_normalized.flatten().tolist()\n        flat_log_normalized = rounded_log_normalized.flatten().tolist()\n        \n        # Store the result for this test case.\n        results.append([flat_normalized, flat_log_normalized])\n\n    # Final print statement in the exact required format.\n    # The format is a list of results, where each result is a list of two lists.\n    # Example: [[[norm_list_1], [log_norm_list_1]], [[norm_list_2], [log_norm_list_2]]]\n    # Using str() on the list of lists achieves the desired nested structure string representation.\n    # The join and map approach ensures comma separation between the results of test cases.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4608974"}, {"introduction": "空间转录组学的核心价值在于其空间维度信息。为了利用这些信息，我们需要一种形式化的方法来表示空间点之间的邻近关系。本练习介绍了一种强大的工具——$k$-近邻（$k$-NN）图，它将空间坐标转化为一个网络结构，从而捕捉局部邻里信息 [@problem_id:4609021]。您将学习如何构建该图，并计算如图拉普拉斯算子（Laplacian）等关键的图论属性，这些属性是许多高级空间分析（如空间聚类和区域识别）的基石。", "problem": "给定空间转录组学中点的二维坐标，单位为微米。目标是构建一个$k$-近邻图来编码局部空间关系，然后推导出作为下游空间分析基础的图论量。从几何学和图论的核心定义出发，为每个测试用例实现以下步骤：\n\n1. 将点阵列视为具有欧几里得几何的平面中的点。坐标为 $(x_i, y_i)$ 和 $(x_j, y_j)$ 的两点之间的欧几里得距离定义为 $$d_{ij} = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$$\n2. 对于给定的整数 $k$，构建一个无向$k$-近邻图。如果节点 $i$ 是节点 $j$ 的 $k$ 个最近邻之一，或者节点 $j$ 是节点 $i$ 的 $k$ 个最近邻之一，则连接两个不同的节点 $i$ 和 $j$。使用以下平局打破规则以确保确定性：当距离相等时，优先选择节点索引较小者。排除自环。\n3. 令 $A$ 为图的对称邻接矩阵，如果节点 $i$ 和 $j$ 相连，则 $A_{ij} = 1$，否则 $A_{ij} = 0$。定义度向量 $d \\in \\mathbb{R}^N$ 为 $d_i = \\sum_{j=1}^N A_{ij}$，组合图拉普拉斯算子为 $L = D - A$，其中 $D$ 是对角矩阵，其对角线元素为 $D_{ii} = d_i$，$N$ 是节点数。\n4. 将位于点集凸包（包含所有点的最小凸多边形）上的点识别为边界点。令 $B$ 为边界点（凸包顶点）的索引集，$I$ 为内部点的补集。计算内部平均度与边界平均度之差，定义为 $$\\Delta = \\left(\\frac{1}{|I|}\\sum_{i \\in I} d_i\\right) - \\left(\\frac{1}{|B|}\\sum_{b \\in B} d_b\\right)$$如果 $|I| = 0$（即所有点都位于凸包上），则定义 $\\Delta = 0$。\n5. 计算拉普拉斯算子的弗罗贝尼乌斯范数，$$\\|L\\|_F = \\sqrt{\\sum_{i=1}^N \\sum_{j=1}^N L_{ij}^2}$$\n6. 通过检查是否存在一个跨越所有 $N$ 个节点的单一连通分量来确定图是否连通。\n\n基本原理和约束：\n- 使用欧几里得几何计算距离，并使用上述标准的图论定义。\n- 不引入权重；邻接关系是按定义构建的二元无向关系。\n- 坐标以微米（$\\mu$m）为单位提供。由于构建$k$-近邻图仅使用距离的排序，因此输出是无量纲的。\n- 如果需要任何角度，必须以弧度为单位。\n\n测试套件（所有情况均使用 $k = 6$）：\n- 测试用例 $1$（规则网格）：$3 \\times 3$ 网格上的 $N = 9$ 个点，间距为 $100\\,\\mu\\text{m}$：$\\{(x, y) \\mid x \\in \\{0, 100, 200\\}, y \\in \\{0, 100, 200\\}\\}$，按行主序排列：$(0,0)$, $(0,100)$, $(0,200)$, $(100,0)$, $(100,100)$, $(100,200)$, $(200,0)$, $(200,100)$, $(200,200)$。\n- 测试用例 $2$（缺少一个角的网格）：从一个 $4 \\times 4$ 网格中取 $N = 15$ 个点，间距为 $80\\,\\mu\\text{m}$，坐标轴范围为 $\\{0, 80, 160, 240\\}$，排除角点 $(240,240)$；按剩余点的行主序排列。\n- 测试用例 $3$（圆上的点）：$N = 7$ 个点等距分布在以原点为中心、半径为 $150\\,\\mu\\text{m}$ 的圆上，角度为 $\\theta_n = \\frac{2\\pi n}{7}$，$n \\in \\{0,1,2,3,4,5,6\\}$，得到坐标 $(150\\cos \\theta_n, 150\\sin \\theta_n)$。\n\n每个测试用例所需的输出：\n- 度向量 $d$，表示为一个长度为 $N$ 的整数列表。\n- 拉普拉斯算子的弗罗贝尼乌斯范数 $\\|L\\|_F$，表示为一个浮点数，四舍五入到六位小数。\n- 内部减去边界的平均度差 $\\Delta$，表示为一个浮点数，四舍五入到六位小数（如果 $|I| = 0$，则 $\\Delta = 0$）。\n- 一个布尔值，指示图是否连通。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且本身是一个列表，顺序为：$[d, \\|L\\|_F, \\Delta, \\text{connected}]$。例如：$[[\\dots],\\dots]$。\n\n在您的解决方案中，定性讨论在$k$-最近邻构建下，边界点如何影响度向量和拉普拉斯算子。您的讨论必须基于上述核心定义，而不使用这些定义之外的快捷公式。", "solution": "该问题要求从空间坐标构建和分析一个$k$-近邻（$k$-NN）图。此过程涉及计算几何和图论中的几个基本步骤。解决方案将根据所提供的定义系统地构建。\n\n**1. 欧几里得距离计算**\n第一步是计算所有 $N$ 个点（节点）之间的两两欧几里得距离。给定点集 $P = \\{p_1, p_2, \\dots, p_N\\}$，其中每个点 $p_i = (x_i, y_i)$，点 $p_i$ 和 $p_j$ 之间的距离 $d_{ij}$ 由先验公式 $d_{ij} = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$ 给出。我们预先计算所有这些距离，并将它们存储在一个 $N \\times N$ 矩阵中，该矩阵作为邻域搜索的基础。\n\n**2. $k$-近邻图构建**\n构建一个无向$k$-NN图。如果满足以下至少一个条件，则连接两个不同的节点 $i$ 和 $j$：\n- 节点 $i$ 是节点 $j$ 的 $k$ 个最近邻之一。\n- 节点 $j$ 是节点 $i$ 的 $k$ 个最近邻之一。\n\n为实现这一点，我们首先构建一个有向图。对于每个节点 $j$，我们识别其 $k$ 个最近邻。这通过根据所有其他节点 $i \\neq j$ 与 $j$ 的距离 $d_{ji}$ 对它们进行排序来实现。为了确保确定性的结果，任何距离上的平局都通过优先选择索引较小的节点来解决。一旦找到每个节点的 $k$ 个最近邻，我们就为从 $j$ 到其每个邻居定义一条有向边。\n\n最终的无向图是这个有向图的对称闭包。如果存在有向边 $j \\to i$ 或有向边 $i \\to j$，则存在无向边 $(i, j)$。图的结构由一个对称邻接矩阵 $A$ 表示，其中如果 $i$ 和 $j$ 之间存在边，则 $A_{ij} = A_{ji} = 1$，否则为 $0$。根据定义，没有自环，因此 $A_{ii} = 0$。\n\n**3. 图拉普拉斯算子和度**\n从邻接矩阵 $A$，我们推导出基本的图属性。节点 $i$ 的度 $d_i$ 是连接到它的边的数量，计算为 $A$ 的第 $i$ 行之和：$d_i = \\sum_{j=1}^N A_{ij}$。所有度的集合构成了度向量 $d$。\n\n组合图拉普拉斯算子 $L$ 定义为 $L = D - A$，其中 $D$ 是由度向量形成的对角矩阵，即 $D_{ii} = d_i$ 且当 $i \\neq j$ 时 $D_{ij} = 0$。拉普拉斯矩阵是谱图论的基石，编码了关于图的重要结构信息。\n\n**4. 边界点和内部点分析**\n边界点和内部点的区别基于点集的几何形状。边界点定义为所有点的凸包的顶点。凸包是包围所有点的最小凸多边形。我们实现单调链算法来识别这些顶点。\n1. 按字典序（首先按 $x$ 坐标，然后按 $y$ 坐标）对所有点进行排序。\n2. 通过迭代排序后的点并维护一条始终左转的路径来构建下凸包。\n3. 类似地，通过反向迭代构建上凸包。\n这些凸包的并集给出了凸包的顶点，对应于边界点集，记为 $B$。剩余的点构成内部点集 $I$。\n\n然后，问题要求计算 $\\Delta$，即内部点的平均度与边界点的平均度之差：\n$$ \\Delta = \\left(\\frac{1}{|I|}\\sum_{i \\in I} d_i\\right) - \\left(\\frac{1}{|B|}\\sum_{b \\in B} d_b\\right) $$\n如果内部点集 $I$ 为空，则定义 $\\Delta$ 为 $0$。\n\n**关于边界效应的定性讨论：**\n边界点位于点云的外围，其局部环境与内部点有根本不同。一个内部点通常在所有方向上都被其他点包围，而一个边界点则其邻居集中在它“朝内”的一侧。在$k$-NN图的构建中，一个内部点很可能被包含在许多周围点的邻居列表中，从而导致更高的度。相反，一个边界点不太可能被遥远的内部点选为邻居，因为这些内部点有许多更近的替代选择。因此，边界点的度平均而言预计会低于内部点。这意味着对于具有明确内部区域的点集，$\\Delta$（内部减去边界的平均度差）通常会是正数，反映了中心位置节点更高的连通性。这种效应是空间嵌入和$k$-NN定义的局部性的直接结果。\n\n**5. 拉普拉斯算子的弗罗贝尼乌斯范数**\n$L$ 的弗罗贝尼乌斯范数，记为 $\\|L\\|_F$，是其元素平方和的平方根：\n$$ \\|L\\|_F^2 = \\sum_{i=1}^N L_{ii}^2 + \\sum_{i \\neq j} L_{ij}^2 = \\sum_{i=1}^N d_i^2 + \\sum_{i \\neq j} (-A_{ij})^2 = \\sum_{i=1}^N d_i^2 + \\sum_{i \\neq j} A_{ij} $$\n鉴于 $\\sum_{i \\neq j} A_{ij} = \\sum_{i=1}^N d_i$，该公式简化为：\n$$ \\|L\\|_F^2 = \\sum_{i=1}^N (d_i^2 + d_i) $$\n这为得出结果提供了一条计算上高效的路径。\n\n**6. 图的连通性**\n为了确定图是否是连通的，我们必须检查任意两个节点之间是否存在路径。这可以通过图遍历算法来完成，例如广度优先搜索（BFS）或深度优先搜索（DFS）。从一个任意节点（例如，节点 $0$）开始，我们遍历所有可达节点。如果访问过的节点总数等于图中的节点总数 $N$，则图是连通的。否则，它由多个不连通的分量组成。\n\n通过实施这些步骤，我们可以全面分析所提供的测试用例并推导出所需的定量度量。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the spatial transcriptomics analysis problem for all test cases.\n    \"\"\"\n\n    def _generate_test_cases():\n        \"\"\"Generates the coordinates and k-value for each test case.\"\"\"\n        k_val = 6\n        \n        # Test Case 1: 3x3 grid\n        points1 = []\n        for y in [0.0, 100.0, 200.0]:\n            for x in [0.0, 100.0, 200.0]:\n                points1.append((x, y))\n        case1 = (np.array(points1, dtype=float), k_val)\n\n        # Test Case 2: 4x4 grid with a missing corner\n        points2 = []\n        coords = [0.0, 80.0, 160.0, 240.0]\n        for y in coords:\n            for x in coords:\n                if x == 240.0 and y == 240.0:\n                    continue\n                points2.append((x, y))\n        case2 = (np.array(points2, dtype=float), k_val)\n\n        # Test Case 3: Points on a circle\n        points3 = []\n        N3 = 7\n        R = 150.0\n        for n in range(N3):\n            theta = 2.0 * math.pi * n / N3\n            points3.append((R * math.cos(theta), R * math.sin(theta)))\n        case3 = (np.array(points3, dtype=float), k_val)\n        \n        return [case1, case2, case3]\n\n    def _solve_single_case(points, k):\n        \"\"\"\n        Processes a single test case: constructs the k-NN graph and computes all required metrics.\n        \"\"\"\n        N = len(points)\n        if N == 0:\n            return [[], 0.0, 0.0, True]\n\n        # 1. Compute pairwise Euclidean distance matrix\n        dist_matrix = np.zeros((N, N))\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = np.linalg.norm(points[i] - points[j])\n                dist_matrix[i, j] = dist_matrix[j, i] = dist\n\n        # 2. Construct undirected k-NN graph\n        adj_matrix = np.zeros((N, N), dtype=int)\n        for j in range(N):\n            # For each point j, find its k-nearest neighbors\n            neighbors = []\n            for i in range(N):\n                if i == j:\n                    continue\n                # Store (distance, index) for sorting\n                neighbors.append((dist_matrix[j, i], i))\n            \n            # Sort by distance, then by index for tie-breaking\n            neighbors.sort()\n            \n            # Get indices of the k nearest neighbors\n            k_nearest_indices = [neighbor[1] for neighbor in neighbors[:k]]\n            \n            # Add directed edges j - i for each neighbor i\n            for i in k_nearest_indices:\n                adj_matrix[j, i] = 1\n        \n        # Symmetrize the graph: an edge (i,j) exists if j-i OR i-j\n        adj_matrix = ((adj_matrix + adj_matrix.T)  0).astype(int)\n\n        # 3. Compute degree vector and Laplacian\n        degree_vector = np.sum(adj_matrix, axis=1)\n\n        # 4. Identify boundary/interior spots and compute Delta\n        def convex_hull_indices(pts):\n            if len(pts) = 2:\n                return set(range(len(pts)))\n            \n            # Sort points by x, then y, keeping track of original indices\n            indexed_pts = sorted(enumerate(pts), key=lambda item: (item[1][0], item[1][1]))\n            \n            def cross_product(p1, p2, p3):\n                # p1, p2, p3 are points, not indexed points\n                return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n            lower_hull = []\n            for idx, p in indexed_pts:\n                while len(lower_hull) = 2 and cross_product(lower_hull[-2][1], lower_hull[-1][1], p) = 0:\n                    lower_hull.pop()\n                lower_hull.append((idx, p))\n\n            upper_hull = []\n            for idx, p in reversed(indexed_pts):\n                while len(upper_hull) = 2 and cross_product(upper_hull[-2][1], upper_hull[-1][1], p) = 0:\n                    upper_hull.pop()\n                upper_hull.append((idx, p))\n\n            hull_indices = {item[0] for item in lower_hull[:-1]}\n            hull_indices.update({item[0] for item in upper_hull[:-1]})\n            return hull_indices\n\n        boundary_indices = convex_hull_indices(points)\n        interior_indices = set(range(N)) - boundary_indices\n        \n        delta = 0.0\n        if len(interior_indices)  0 and len(boundary_indices)  0:\n            interior_degrees = [degree_vector[i] for i in interior_indices]\n            boundary_degrees = [degree_vector[i] for i in boundary_indices]\n            mean_interior_degree = sum(interior_degrees) / len(interior_degrees)\n            mean_boundary_degree = sum(boundary_degrees) / len(boundary_degrees)\n            delta = mean_interior_degree - mean_boundary_degree\n\n        # 5. Compute Frobenius norm of the Laplacian\n        # ||L||_F^2 = sum(d_i^2 + d_i)\n        l_norm_sq = np.sum(degree_vector**2 + degree_vector)\n        frobenius_norm = np.sqrt(l_norm_sq)\n\n        # 6. Check for graph connectivity using BFS\n        is_connected = False\n        if N  0:\n            q = [0]\n            visited = {0}\n            head = 0\n            while head  len(q):\n                u = q[head]\n                head += 1\n                for v in range(N):\n                    if adj_matrix[u, v] == 1 and v not in visited:\n                        visited.add(v)\n                        q.append(v)\n            is_connected = (len(visited) == N)\n        elif N == 0:\n            is_connected = True\n\n\n        # Format results\n        final_d = [int(d) for d in degree_vector]\n        final_norm = round(frobenius_norm, 6)\n        final_delta = round(delta, 6)\n        \n        return [final_d, final_norm, final_delta, is_connected]\n\n    test_cases = _generate_test_cases()\n    results = []\n    for points, k in test_cases:\n        result = _solve_single_case(points, k)\n        results.append(str(result))\n    \n    # Final print statement must match the specified format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "4609021"}, {"introduction": "空间转录组学分析的最终目标之一是揭示空间背景下的生物学过程。本练习将引导您完成一项高级应用：通过整合基因表达和空间距离数据来推断细胞间的通讯 [@problem_id:4608981]。您将学习如何计算一个考虑了空间邻近性的配体-受体互作得分，并利用置换检验（permutation test）这一关键的非参数统计方法来评估该得分的显著性。这个实践将帮助您理解如何将数据转化为关于组织内细胞如何相互“对话”的生物学洞见。", "problem": "您正在分析空间转录组学数据，其中测量了配体和受体的信使核糖核酸（mRNA）计数，这些计数分布在空间索引的斑点上。设有 $N$ 个空间斑点，由 $i \\in \\{1,\\dots,N\\}$ 和 $j \\in \\{1,\\dots,N\\}$ 索引。给定斑点 $i$ 处的配体表达量 $x_{i,L}$，斑点 $j$ 处的受体表达量 $x_{j,R}$，以及一个空间距离矩阵，其元素为 $d_{ij}$（单位：微米）。其生物学前提是，组织中的配体-受体通讯受到空间邻近性的限制，这与扩散限制信号传导和局部微环境相互作用一致。根据空间生物学和生物物理学中经过充分验证的事实，在各向同性扩散和噪声的影响下，相互作用倾向于随距离衰减。因此，使用以下基于核的权重来模拟空间影响：\n$$\nw_{ij} = \\exp\\left(-\\left(\\frac{d_{ij}}{\\sigma}\\right)^2\\right),\n$$\n其中 $\\sigma$ 是一个非负的长度尺度参数（单位：微米），用于设定相互作用的有效空间范围。旁分泌信号传导排除了自我相互作用；因此只应包括 $i \\ne j$ 的配对。\n\n将加权配体-受体相互作用得分定义为：\n$$\nS = \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\mathbf{1}[i \\ne j] \\, w_{ij} \\, x_{i,L} \\, x_{j,R},\n$$\n其中 $\\mathbf{1}[\\cdot]$ 是指示函数，当条件成立时其值为 $1$，否则为 $0$。\n\n通过置换检验来评估 $S$ 的显著性。其零假设是：受体表达相对于斑点标签是空间可交换的，这意味着配体和受体之间除了偶然性之外没有空间耦合。通过随机置换受体斑点的索引来执行 $B$ 次独立的置换，从而为每个 $b \\in \\{1,\\dots,B\\}$ 产生置换得分 $S^{(b)}$。使用加一校正计算单侧 p 值，以检验观测得分是否大于偶然预期的得分：\n$$\np = \\frac{1 + \\sum_{b=1}^{B} \\mathbf{1}\\left[S^{(b)} \\ge S\\right]}{1 + B}.\n$$\n\n所有距离都必须以微米为单位。相互作用得分 $S$ 是无量纲的（任意单位）。p 值 $p$ 必须表示为 $[0,1]$ 范围内的小数。本问题不涉及角度。您的程序必须精确实现上述定义，并通过将权重矩阵的对角线置零来强制执行 $\\mathbf{1}[i \\ne j]$。\n\n测试套件：\n对于每个测试用例，您将获得 $N$、距离矩阵条目 $d_{ij}$（微米）、配体向量 $x_{i,L}$、受体向量 $x_{j,R}$、核长度尺度 $\\sigma$（微米）、置换次数 $B$ 以及一个伪随机种子以确保可复现性。测试用例如下：\n\n- 测试用例 A（一般情况）：\n  - $N = 5$\n  - $d_{ij}$ 行：\n    - 第 1 行：$0, 10, 20, 15, 30$\n    - 第 2 行：$10, 0, 12, 25, 18$\n    - 第 3 行：$20, 12, 0, 8, 22$\n    - 第 4 行：$15, 25, 8, 0, 16$\n    - 第 5 行：$30, 18, 22, 16, 0$\n  - $x_{i,L} = [2.0, 0.5, 1.2, 0.0, 3.0]$\n  - $x_{j,R} = [0.1, 1.0, 0.0, 2.5, 1.2]$\n  - $\\sigma = 15$\n  - $B = 500$\n  - 种子 $= 123$\n\n- 测试用例 B（边界情况：受体表达为零）：\n  - $N = 4$\n  - $d_{ij}$ 行：\n    - 第 1 行：$0, 5, 10, 15$\n    - 第 2 行：$5, 0, 7, 12$\n    - 第 3 行：$10, 7, 0, 6$\n    - 第 4 行：$15, 12, 6, 0$\n  - $x_{i,L} = [1.0, 2.0, 1.0, 0.5]$\n  - $x_{j,R} = [0.0, 0.0, 0.0, 0.0]$\n  - $\\sigma = 10$\n  - $B = 100$\n  - 种子 $= 999$\n\n- 测试用例 C（边缘情况：由于核尺度非常小，权重几乎为零）：\n  - $N = 4$\n  - $d_{ij}$ 行：\n    - 第 1 行：$0, 100, 150, 200$\n    - 第 2 行：$100, 0, 120, 180$\n    - 第 3 行：$150, 120, 0, 90$\n    - 第 4 行：$200, 180, 90, 0$\n  - $x_{i,L} = [5.0, 3.0, 4.0, 2.0]$\n  - $x_{j,R} = [1.0, 0.5, 2.0, 1.5]$\n  - $\\sigma = 1$\n  - $B = 200$\n  - 种子 $= 7$\n\n- 测试用例 D（边界情况：只有两个斑点）：\n  - $N = 2$\n  - $d_{ij}$ 行：\n    - 第 1 行：$0, 50$\n    - 第 2 行：$50, 0$\n  - $x_{i,L} = [1.0, 2.0]$\n  - $x_{j,R} = [3.0, 4.0]$\n  - $\\sigma = 50$\n  - $B = 10$\n  - 种子 $= 1$\n\n- 测试用例 E（边缘情况：不同斑点间距离为零）：\n  - $N = 3$\n  - $d_{ij}$ 行：\n    - 第 1 行：$0, 0, 10$\n    - 第 2 行：$0, 0, 10$\n    - 第 3 行：$10, 10, 0$\n  - $x_{i,L} = [0.0, 1.0, 2.0]$\n  - $x_{j,R} = [3.0, 0.0, 1.0]$\n  - $\\sigma = 5$\n  - $B = 100$\n  - 种子 $= 101$\n\n输出规格：\n对于每个测试用例，计算上述定义的相互作用得分 $S$ 及其置换 p 值 $p$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是包含两个浮点数 $[S,p]$ 的列表。将测试用例 A、B、C、D、E 的结果按顺序聚合到一个列表的列表中。例如，输出应如下所示：\n$$\n\\text{[[S_A,p_A],[S_B,p_B],[S_C,p_C],[S_D,p_D],[S_E,p_E]]}\n$$\n以单行形式打印，不含其他文本。", "solution": "该问题要求计算一个空间配体-受体相互作用得分（记为 $S$），并通过置换检验评估其统计显著性，从而得出 p 值 $p$。该分析基于空间转录组学数据进行，这些数据包括配体和受体在 $N$ 个空间索引斑点上的表达水平，以及这些斑点之间的距离。\n\n解决方案的结构如下：首先，我们根据所提供的生物学模型计算观测到的相互作用得分 $S$。其次，我们在无空间耦合的零假设下执行置换检验，以生成得分的经验零分布。最后，我们通过将观测得分与此零分布进行比较来计算 p 值。\n\n加权的配体-受体相互作用得分 $S$ 定义为：\n$$\nS = \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\mathbf{1}[i \\ne j] \\, w_{ij} \\, x_{i,L} \\, x_{j,R}\n$$\n此处，$x_{i,L}$ 是斑点 $i$ 处的配体表达量，$x_{j,R}$ 是斑点 $j$ 处的受体表达量，$\\mathbf{1}[i \\ne j]$ 是一个指示函数，强制执行旁分泌信号传导的生物学原理（即排除自我相互作用，其中 $i=j$）。$w_{ij}$ 项是一个源自高斯核的权重，用于模拟相互作用潜力随距离的衰减：\n$$\nw_{ij} = \\exp\\left(-\\left(\\frac{d_{ij}}{\\sigma}\\right)^2\\right)\n$$\n其中 $d_{ij}$ 是斑点 $i$ 和 $j$ 之间的距离，$\\sigma$ 是定义相互作用有效范围的长度尺度参数。\n\n为了计算效率，此计算可以用矩阵代数表示。设 $x_L$ 为配体表达值的 $N \\times 1$ 列向量，$x_R$ 为受体表达值的 $N \\times 1$ 列向量，$D$ 为距离 $d_{ij}$ 的 $N \\times N$ 矩阵。首先，我们计算一个中间权重矩阵 $W'$，其元素为 $w'_{ij} = \\exp(-(d_{ij}/\\sigma)^2)$。然后，为强制执行 $i \\ne j$ 条件，我们通过将 $W'$ 的对角线元素设置为 $0$ 来构建最终的权重矩阵 $W$。这等同于与一个对角线为零、其余元素为一的矩阵进行逐元素相乘。利用这些矩阵，得分 $S$ 可以计算为二次型：\n$$\nS = x_L^T W x_R\n$$\n与嵌套循环相比，这种矩阵形式在计算上更有优势，特别是当斑点数量 $N$ 很大时。\n\n接下来，为评估观测得分 $S$ 的统计显著性，我们采用置换检验。零假设 $H_0$ 是，受体表达的空间位置相对于配体表达是随机的。为模拟此零假设情景，我们生成 $B$ 个置换数据集。在每次置换 $b \\in \\{1, \\dots, B\\}$ 中，随机打乱受体表达向量 $x_R$ 的索引以创建一个新向量 $x_R^{(b)}$。配体表达向量 $x_L$ 和权重矩阵 $W$ 保持不变。为每个置换数据集计算一个新得分 $S^{(b)}$：\n$$\nS^{(b)} = x_L^T W x_R^{(b)}\n$$\n此过程产生一个由 $B$ 个得分 $\\{S^{(1)}, S^{(2)}, \\dots, S^{(B)}\\}$ 组成的分布，该分布代表了在零假设下预期的得分范围。\n\n最后，我们计算一个单侧 p 值，以确定偶然情况下观测到至少与实际得分 $S$ 一样大的得分的概率。问题指定使用加一校正，这是一种标准做法，可以避免 p 值为 $0$，并处理观测得分在置换集中是极值的情况。p 值 $p$ 计算如下：\n$$\np = \\frac{1 + \\sum_{b=1}^{B} \\mathbf{1}\\left[S^{(b)} \\ge S\\right]}{1 + B}\n$$\n分子计算有多少个置换得分大于或等于观测得分，并加 $1$ 以计入观测得分本身。分母是总置换次数加一。为了可复现性，随机打乱过程使用每个测试用例特定的种子进行初始化。\n\n算法的流程是：首先根据给定的距离矩阵 $D$ 和 $\\sigma$ 计算权重矩阵 $W$。然后，使用原始的表达向量 $x_L$ 和 $x_R$ 计算观测得分 $S$。之后，一个循环运行 $B$ 次，在每次迭代中，生成一个置换后的受体向量 $x_R^{(b)}$，计算相应的得分 $S^{(b)}$，并将其与 $S$ 进行比较。循环结束后，根据超过或等于 $S$ 的置换得分总数计算 p 值 $p$。每个测试用例的最终输出是数对 $[S, p]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    def solve_case(N, d_matrix, x_L, x_R, sigma, B, seed):\n        \"\"\"\n        Solves a single test case for the spatial transcriptomics problem.\n\n        Args:\n            N (int): Number of spatial spots.\n            d_matrix (list of list of float): The distance matrix.\n            x_L (list of float): Ligand expression vector.\n            x_R (list of float): Receptor expression vector.\n            sigma (float): Kernel length-scale parameter.\n            B (int): Number of permutations.\n            seed (int): Pseudorandom seed for reproducibility.\n\n        Returns:\n            list: A list containing the calculated score S and p-value p.\n        \"\"\"\n        \n        # Cast inputs to numpy arrays for vectorized operations\n        D = np.array(d_matrix, dtype=float)\n        x_L = np.array(x_L, dtype=float)\n        x_R = np.array(x_R, dtype=float)\n\n        # Step 1: Calculate the weight matrix W\n        if sigma == 0:\n            # Handle sigma=0 as a limit case: weight is 1 if distance is 0, else 0.\n            # This case is not in the test suite but makes the function more robust.\n            W = (D == 0).astype(float)\n        else:\n            # Standard Gaussian kernel for weights\n            W = np.exp(-(D / sigma)**2)\n        \n        # Enforce paracrine signaling (i != j) by zeroing the diagonal of W\n        np.fill_diagonal(W, 0)\n        \n        # Helper function for score calculation using the efficient matrix form\n        def calculate_score(ligand_vec, receptor_vec, weight_matrix):\n            # S = x_L^T * W * x_R\n            return ligand_vec @ weight_matrix @ receptor_vec\n\n        # Step 2: Calculate the observed score S\n        S_obs = calculate_score(x_L, x_R, W)\n        \n        # Step 3: Perform the permutation test\n        count_greater_equal = 0\n        \n        # Initialize a random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n        \n        for _ in range(B):\n            # Generate a permuted receptor vector by shuffling its elements\n            x_R_permuted = rng.permutation(x_R)\n            \n            # Calculate the score for the permuted data\n            S_permuted = calculate_score(x_L, x_R_permuted, W)\n            \n            # Check if the permuted score is greater than or equal to the observed score\n            if S_permuted = S_obs:\n                count_greater_equal += 1\n            \n        # Step 4: Calculate the one-sided p-value with add-one correction\n        p_value = (1 + count_greater_equal) / (1 + B)\n        \n        return [S_obs, p_value]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {\"N\": 5, \"d_matrix\": [[0, 10, 20, 15, 30], [10, 0, 12, 25, 18], [20, 12, 0, 8, 22], [15, 25, 8, 0, 16], [30, 18, 22, 16, 0]], \"x_L\": [2.0, 0.5, 1.2, 0.0, 3.0], \"x_R\": [0.1, 1.0, 0.0, 2.5, 1.2], \"sigma\": 15, \"B\": 500, \"seed\": 123},\n        # Test Case B\n        {\"N\": 4, \"d_matrix\": [[0, 5, 10, 15], [5, 0, 7, 12], [10, 7, 0, 6], [15, 12, 6, 0]], \"x_L\": [1.0, 2.0, 1.0, 0.5], \"x_R\": [0.0, 0.0, 0.0, 0.0], \"sigma\": 10, \"B\": 100, \"seed\": 999},\n        # Test Case C\n        {\"N\": 4, \"d_matrix\": [[0, 100, 150, 200], [100, 0, 120, 180], [150, 120, 0, 90], [200, 180, 90, 0]], \"x_L\": [5.0, 3.0, 4.0, 2.0], \"x_R\": [1.0, 0.5, 2.0, 1.5], \"sigma\": 1, \"B\": 200, \"seed\": 7},\n        # Test Case D\n        {\"N\": 2, \"d_matrix\": [[0, 50], [50, 0]], \"x_L\": [1.0, 2.0], \"x_R\": [3.0, 4.0], \"sigma\": 50, \"B\": 10, \"seed\": 1},\n        # Test Case E\n        {\"N\": 3, \"d_matrix\": [[0, 0, 10], [0, 0, 10], [10, 10, 0]], \"x_L\": [0.0, 1.0, 2.0], \"x_R\": [3.0, 0.0, 1.0], \"sigma\": 5, \"B\": 100, \"seed\": 101}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(\n            case[\"N\"],\n            case[\"d_matrix\"],\n            case[\"x_L\"],\n            case[\"x_R\"],\n            case[\"sigma\"],\n            case[\"B\"],\n            case[\"seed\"]\n        )\n        results.append(result)\n\n    # Format the output string exactly as specified.\n    inner_strings = [f\"[{s},{p}]\" for s, p in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "4608981"}]}