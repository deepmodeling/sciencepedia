{"hands_on_practices": [{"introduction": "为了从测序数据中准确比较不同基因或功能的丰度，我们必须对原始读数进行校正，以消除固有的技术偏差。本练习将引导您实践一种基础且关键的标准化方法——每百万转录本（Transcripts Per Million, TPM），该方法同时考虑了测序深度和基因长度。通过完成这项练习 [@problem_id:4565555]，您将掌握如何计算TPM，并利用信息论中的Kullback-Leibler散度来量化长度校正对功能丰度谱的改变，从而深刻理解为何原始计数在功能分析中可能产生误导。", "problem": "一个来自人类肠道微生物组的宏转录组数据集使用KEGG同源（KO）特征进行了功能丰度分析。短读序列经过质量过滤，并与四个KO特征进行比对，这些特征具有有效的序列长度（已考虑读段的可比对性和剪切）。对于一个样本，记录了以下观察到的比对数和有效长度：\n- KO-A：长度 $900$ 碱基对 (bp)，比对读段数 $360$。\n- KO-B：长度 $1800$ bp，比对读段数 $540$。\n- KO-C：长度 $300$ bp，比对读段数 $120$。\n- KO-D：长度 $1500$ bp，比对读段数 $180$。\n\n假设在功能谱分析中采用TPM（每百万转录本）归一化中使用的标准长度校正和每百万缩放：计数必须根据特征长度进行校正，以得到每千碱基的比率，然后进行缩放，使得所有特征的总和等于$10^{6}$。\n\n从基于测序的定量的基本定义出发（即读段覆盖度与特征长度及其真实丰度的乘积成正比，且缩放产生一个组成性度量），计算这些KO特征的TPM值，并构建这四个特征的TPM组成。根据观察到的计数构建原始计数组成。使用自然对数，通过计算从TPM组成到原始计数组成的Kullback–Leibler散度，来量化长度校正如何改变功能的相对丰度。\n\n将最终答案四舍五入至四位有效数字。最终答案以无单位实数表示。", "solution": "该问题是有效的。它在科学上基于测序数据量化功能丰度的标准生物信息学流程，问题陈述清晰，提供了所有必要信息，并且客观陈述。\n\n任务是计算一组四个KEGG同源（KO）特征中，从TPM（每百万转录本）归一化组成到原始计数组成的Kullback-Leibler（KL）散度。设这组特征由 $i \\in \\{A, B, C, D\\}$ 索引。\n\n提供的数据如下：\n- KO-A ($i=A$)：原始计数 $C_A = 360$，长度 $L_A = 900$ bp。\n- KO-B ($i=B$)：原始计数 $C_B = 540$，长度 $L_B = 1800$ bp。\n- KO-C ($i=C$)：原始计数 $C_C = 120$，长度 $L_C = 300$ bp。\n- KO-D ($i=D$)：原始计数 $C_D = 180$，长度 $L_D = 1500$ bp。\n\n首先，我们计算原始计数组成，记为概率分布 $P = \\{p_i\\}$。这是通过将每个特征的计数除以比对上的总读段数得到的。\n总读段数是：\n$$N = \\sum_{i \\in \\{A,B,C,D\\}} C_i = 360 + 540 + 120 + 180 = 1200$$\n比例 $p_i = \\frac{C_i}{N}$ 分别为：\n$$p_A = \\frac{360}{1200} = \\frac{3}{10} = 0.30$$\n$$p_B = \\frac{540}{1200} = \\frac{9}{20} = 0.45$$\n$$p_C = \\frac{120}{1200} = \\frac{1}{10} = 0.10$$\n$$p_D = \\frac{180}{1200} = \\frac{3}{20} = 0.15$$\n集合 $P = \\{0.30, 0.45, 0.10, 0.15\\}$ 构成了原始计数组成分布。\n\n接下来，我们计算TPM组成，记为概率分布 $Q = \\{q_i\\}$。TPM的计算涉及两个步骤：长度归一化和文库大小缩放。\n首先，我们将原始计数 $C_i$ 按以千碱基为单位的特征长度 $L_{i,kb} = L_i / 1000$ 进行归一化。这给出了一个比率 $R_i$。\n$$L_{A,kb} = \\frac{900}{1000} = 0.9 \\, \\text{kb}$$\n$$L_{B,kb} = \\frac{1800}{1000} = 1.8 \\, \\text{kb}$$\n$$L_{C,kb} = \\frac{300}{1000} = 0.3 \\, \\text{kb}$$\n$$L_{D,kb} = \\frac{1500}{1000} = 1.5 \\, \\text{kb}$$\n比率 $R_i = \\frac{C_i}{L_{i,kb}}$ 分别为：\n$$R_A = \\frac{360}{0.9} = 400$$\n$$R_B = \\frac{540}{1.8} = 300$$\n$$R_C = \\frac{120}{0.3} = 400$$\n$$R_D = \\frac{180}{1.5} = 120$$\n\n其次，将这些比率进行缩放，使其总和为一个常数（对于TPM通常是$10^6$）。TPM组成是经过此长度归一化后每个特征的相对比例。对于组成本身，$10^6$ 这个缩放常数是无关紧要的，因为它会被约掉。组成比例 $q_i$ 是通过将每个比率 $R_i$ 除以所有比率的总和得到的。\n比率的总和是：\n$$S = \\sum_{i \\in \\{A,B,C,D\\}} R_i = 400 + 300 + 400 + 120 = 1220$$\n比例 $q_i = \\frac{R_i}{S}$ 分别为：\n$$q_A = \\frac{400}{1220} = \\frac{20}{61}$$\n$$q_B = \\frac{300}{1220} = \\frac{15}{61}$$\n$$q_C = \\frac{400}{1220} = \\frac{20}{61}$$\n$$q_D = \\frac{120}{1220} = \\frac{6}{61}$$\n集合 $Q = \\{\\frac{20}{61}, \\frac{15}{61}, \\frac{20}{61}, \\frac{6}{61}\\}$ 构成了TPM组成分布。\n\n最后，我们按照规定使用自然对数，计算从TPM组成（$Q$）到原始计数组成（$P$）的Kullback-Leibler散度，记为 $D_{KL}(Q || P)$。\nKL散度的公式是：\n$$D_{KL}(Q || P) = \\sum_{i \\in \\{A,B,C,D\\}} q_i \\ln\\left(\\frac{q_i}{p_i}\\right)$$\n代入计算出的 $p_i$ 和 $q_i$ 值：\n$$D_{KL}(Q || P) = \\frac{20}{61} \\ln\\left(\\frac{20/61}{0.30}\\right) + \\frac{15}{61} \\ln\\left(\\frac{15/61}{0.45}\\right) + \\frac{20}{61} \\ln\\left(\\frac{20/61}{0.10}\\right) + \\frac{6}{61} \\ln\\left(\\frac{6/61}{0.15}\\right)$$\n$$D_{KL}(Q || P) = \\frac{20}{61} \\ln\\left(\\frac{20/61}{3/10}\\right) + \\frac{15}{61} \\ln\\left(\\frac{15/61}{9/20}\\right) + \\frac{20}{61} \\ln\\left(\\frac{20/61}{1/10}\\right) + \\frac{6}{61} \\ln\\left(\\frac{6/61}{3/20}\\right)$$\n$$D_{KL}(Q || P) = \\frac{20}{61} \\ln\\left(\\frac{200}{183}\\right) + \\frac{15}{61} \\ln\\left(\\frac{300}{549}\\right) + \\frac{20}{61} \\ln\\left(\\frac{200}{61}\\right) + \\frac{6}{61} \\ln\\left(\\frac{120}{183}\\right)$$\n简化对数内的分数：\n$$D_{KL}(Q || P) = \\frac{20}{61} \\ln\\left(\\frac{200}{183}\\right) + \\frac{15}{61} \\ln\\left(\\frac{100}{183}\\right) + \\frac{20}{61} \\ln\\left(\\frac{200}{61}\\right) + \\frac{6}{61} \\ln\\left(\\frac{40}{61}\\right)$$\n现在我们计算数值：\n$$D_{KL}(Q || P) \\approx \\left(\\frac{20}{61}\\right)(0.0888358) + \\left(\\frac{15}{61}\\right)(-0.6043254) + \\left(\\frac{20}{61}\\right)(1.1874253) + \\left(\\frac{6}{61}\\right)(-0.4220261)$$\n$$D_{KL}(Q || P) \\approx (0.32786885)(0.0888358) + (0.24590164)(-0.6043254) + (0.32786885)(1.1874253) + (0.09836066)(-0.4220261)$$\n$$D_{KL}(Q || P) \\approx 0.02912977 - 0.14860721 + 0.38927907 - 0.04151121$$\n$$D_{KL}(Q || P) \\approx 0.22829042$$\n将结果四舍五入到四位有效数字，得到 $0.2283$。该值量化了当从原始计数比例修正为经长度校正的比例时所获得的信息增益。", "answer": "$$\\boxed{0.2283}$$", "id": "4565555"}, {"introduction": "功能谱分析的最终目标不仅仅是罗列存在的基因，而是理解哪些复杂的代谢通路在微生物组中是完整且活跃的。此练习模拟了像HUMAnN这样的现代生物信息学工具，如何基于基因家族丰度来重建代谢通路 [@problem_id:4565625]。您将亲手实现一个分层模型，该模型使用“与”（AND）和“或”（OR）逻辑来推断通路的覆盖度（完整性）和丰度，从而深入体会代谢网络中的“瓶颈”原则和功能冗余。", "problem": "您将获得一个受HMP统一代谢分析网络（HMP Unified Metabolic Analysis Network, HUMAnN）启发的简化但有科学依据的建模任务。其目标是形式化地定义从源自测序读数（read-derived）的UniRef90蛋白家族丰度到代谢反应的映射，并计算基于模块的通路覆盖度和通路丰度。该场景的动因源于分子生物学的中心法则，即基因编码催化反应的蛋白家族（酶），这些反应聚合成模块和通路。我们的目标是从第一性原理出发，推导出一个在基于模块的逻辑下对通路覆盖度和丰度进行评分的精确计算流程。\n\n定义一个UniRef90家族的有限集 $F = \\{f_1, f_2, \\dots, f_n\\}$，其丰度值为非负数 $a_{f} \\in \\mathbb{R}_{\\ge 0}$，解释为以测序衍生丰度的任意单位表示的标准化读数丰度值。定义一个反应的有限集 $R = \\{r_1, r_2, \\dots, r_m\\}$。每个反应 $r \\in R$ 都与一个非空集合 $M_r \\subseteq F$ 相关联，该集合指明了哪些UniRef90家族映射到 $r$。反应 $r$ 的丰度由下式给出\n$$\nA_r = \\sum_{f \\in M_r} a_f \\, .\n$$\n给定一个非负阈值 $t \\in \\mathbb{R}_{\\ge 0}$，定义反应存在指示符\n$$\np_r = \\begin{cases}\n1  \\text{如果 } A_r \\ge t \\\\\n0  \\text{其他情况。}\n\\end{cases}\n$$\n\n模块是一个基于反应的逻辑表达式，使用逻辑与（AND）和逻辑或（OR）这两个连接符构建。模块可以是一个叶节点反应 $r \\in R$，也可以是一个内部节点 $X(\\cdot, \\cdot)$，其中 $X \\in \\{\\text{AND}, \\text{OR}\\}$，其两个子节点也是模块。一个通路 $P$ 是模块的有序列表 $\\{m_1, m_2, \\dots, m_k\\}$。\n\n定义两个递归函数来评估模块覆盖度和模块丰度：\n1. 对于模块覆盖度，将模块 $m$ 的 $c(m)$ 定义为\n$$\nc(m) = \\begin{cases}\n1  \\text{如果 } m \\text{ 是叶节点反应 } r \\text{ 且 } p_r = 1 \\\\\n0  \\text{如果 } m \\text{ 是叶节点反应 } r \\text{ 且 } p_r = 0 \\\\\n\\min\\left(c(m_{\\text{left}}), c(m_{\\text{right}})\\right)  \\text{如果 } m = \\text{AND}(m_{\\text{left}}, m_{\\text{right}}) \\\\\n\\max\\left(c(m_{\\text{left}}), c(m_{\\text{right}})\\right)  \\text{如果 } m = \\text{OR}(m_{\\text{left}}, m_{\\text{right}})\n\\end{cases}\n$$\n这将覆盖度推广为模块级别的连续分数，其值在 $[0,1]$ 区间内：叶节点根据其是否存在贡献0或1，AND通过最小值传播限制性覆盖度，而OR通过最大值传播最佳可用覆盖度。\n\n2. 对于模块丰度，将模块 $m$ 的 $b(m)$ 定义为\n$$\nb(m) = \\begin{cases}\nA_r  \\text{如果 } m \\text{ 是叶节点反应 } r \\\\\n\\min\\left(b(m_{\\text{left}}), b(m_{\\text{right}})\\right)  \\text{如果 } m = \\text{AND}(m_{\\text{left}}, m_{\\text{right}}) \\\\\n\\max\\left(b(m_{\\text{left}}), b(m_{\\text{right}})\\right)  \\text{如果 } m = \\text{OR}(m_{\\text{left}}, m_{\\text{right}})\n\\end{cases}\n$$\n这将AND运算符视为瓶颈（限速步骤），将OR运算符视为最大分支。叶节点贡献其反应丰度 $A_r$。\n\n使用瓶颈原理，通过聚合通路中的模块来定义通路覆盖度和通路丰度：\n$$\nC_P = \\min_{i \\in \\{1,\\dots,k\\}} c(m_i), \\qquad B_P = \\min_{i \\in \\{1,\\dots,k\\}} b(m_i).\n$$\n$C_P$ 和 $B_P$ 均为实数值。通路覆盖度 $C_P$ 是一个在 $[0,1]$ 区间内的小数（不是百分比），通路丰度 $B_P$ 与 $A_r$ 使用相同的任意单位。\n\n对于此问题，请使用以下具体的映射和通路：\n- 家族 $F = \\{\\text{U1}, \\text{U2}, \\text{U3}, \\text{U4}, \\text{U5}\\}$。\n- 反应 $R = \\{\\text{R1}, \\text{R2}, \\text{R3}, \\text{R4}, \\text{R5}, \\text{R6}\\}$，其映射关系为\n$$\nM_{\\text{R1}} = \\{\\text{U1}, \\text{U2}\\}, \\quad\nM_{\\text{R2}} = \\{\\text{U2}\\}, \\quad\nM_{\\text{R3}} = \\{\\text{U3}\\}, \\quad\nM_{\\text{R4}} = \\{\\text{U3}, \\text{U4}\\}, \\quad\nM_{\\text{R5}} = \\{\\text{U5}\\}, \\quad\nM_{\\text{R6}} = \\{\\text{U1}\\}.\n$$\n- 通路：\n  - 通路 $\\text{P\\_A}$ 有两个模块：\n    $$\n    m_1 = \\text{AND}\\left(\\text{R1}, \\, \\text{OR}(\\text{R2}, \\text{R3})\\right), \\qquad\n    m_2 = \\text{AND}\\left(\\text{R4}, \\text{R5}\\right).\n    $$\n  - 通路 $\\text{P\\_B}$ 有一个模块：\n    $$\n    m_3 = \\text{OR}\\left(\\text{AND}(\\text{R1}, \\text{R6}), \\, \\text{R3}\\right).\n    $$\n\n测试套件。对于每个测试用例，给定一个阈值 $t$ 和 $f \\in F$ 的丰度 $a_f$。计算每个反应的 $A_r$，然后是 $p_r$，接着是每个模块的 $c(m)$ 和 $b(m)$，最后计算 $\\text{P\\_A}$ 和 $\\text{P\\_B}$ 的 $C_P$ 和 $B_P$。测试套件包含四个案例：\n- 案例 1：阈值 $t = 0.5$ 和家族丰度\n$$\na_{\\text{U1}} = 0.8,\\; a_{\\text{U2}} = 0.4,\\; a_{\\text{U3}} = 0.9,\\; a_{\\text{U4}} = 0.3,\\; a_{\\text{U5}} = 0.5.\n$$\n- 案例 2：阈值 $t = 0.7$ 和家族丰度\n$$\na_{\\text{U1}} = 0.7,\\; a_{\\text{U2}} = 0.0,\\; a_{\\text{U3}} = 0.7,\\; a_{\\text{U4}} = 0.0,\\; a_{\\text{U5}} = 0.7.\n$$\n- 案例 3：阈值 $t = 0.0$ 和家族丰度\n$$\na_{\\text{U1}} = 0.0,\\; a_{\\text{U2}} = 0.0,\\; a_{\\text{U3}} = 0.0,\\; a_{\\text{U4}} = 0.0,\\; a_{\\text{U5}} = 0.0.\n$$\n- 案例 4：阈值 $t = 0.6$ 和家族丰度\n$$\na_{\\text{U1}} = 0.4,\\; a_{\\text{U2}} = 0.3,\\; a_{\\text{U3}} = 0.55,\\; a_{\\text{U4}} = 0.1,\\; a_{\\text{U5}} = 0.0.\n$$\n\n您的程序必须精确实现这些定义，并生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，输出一个包含两个列表的列表：第一个内部列表包含 $[C_{\\text{P\\_A}}, B_{\\text{P\\_A}}]$，第二个内部列表包含 $[C_{\\text{P\\_B}}, B_{\\text{P\\_B}}]$。所有值都必须是实数。因此，最终的输出格式为\n$$\n\\left[ \\left[ [C_{\\text{P\\_A}}^{(1)}, B_{\\text{P\\_A}}^{(1)}], [C_{\\text{P\\_B}}^{(1)}, B_{\\text{P\\_B}}^{(1)}] \\right], \\dots, \\left[ [C_{\\text{P\\_A}}^{(4)}, B_{\\text{P\\_A}}^{(4)}], [C_{\\text{P\\_B}}^{(4)}, B_{\\text{P\\_B}}^{(4)}] \\right] \\right]\n$$\n其中上标表示从 1 到 4 的测试用例索引。不应打印任何其他文本。", "solution": "问题陈述提供了一个形式化的定量模型，用于从基因家族丰度推导通路级功能谱，这是微生物组代谢重建的核心概念。该模型有科学依据，在数学上是适定的，并且其所有组成部分都有明确定义。该问题是有效的。\n\n解决方案的流程是首先实现已定义的数学规则，然后将它们应用于提供的测试用例。该过程分为四个主要的计算步骤。\n\n1.  **计算反应丰度 ($A_r$)**：每个反应 $r$ 的丰度是催化该反应的所有UniRef90蛋白家族 $f$ 的丰度之和。这基于给定的映射 $M_r \\subseteq F$，其中 $F$ 是家族的集合。公式为：\n    $$\n    A_r = \\sum_{f \\in M_r} a_f\n    $$\n    其中 $a_f$ 是家族 $f$ 的丰度。\n\n2.  **确定反应存在性 ($p_r$)**：如果一个反应 $r$ 计算出的丰度 $A_r$ 达到或超过指定的阈值 $t \\in \\mathbb{R}_{\\ge 0}$，则该反应被认为是“存在的”或“活跃的”。这由一个二元指示变量 $p_r$ 来表示：\n    $$\n    p_r = \\begin{cases}\n    1  \\text{如果 } A_r \\ge t \\\\\n    0  \\text{如果 } A_r  t\n    \\end{cases}\n    $$\n    $p_r$ 的值作为模块覆盖度计算的基础。\n\n3.  **模块指标的递归评估 ($c(m)$ 和 $b(m)$)**：模块 $m$ 是反应的逻辑组合。其覆盖度 $c(m)$ 和丰度 $b(m)$ 是通过递归计算的。\n    -   对于叶节点模块（即单个反应 $r$），其覆盖度是其存在指示符 $p_r$，丰度是 $A_r$。\n        $$\n        c(r) = p_r, \\qquad b(r) = A_r\n        $$\n    -   对于复合模块，评估取决于逻辑连接符。`AND` 运算符代表一个瓶颈，要求所有子模块都存在，因此传播最小的覆盖度和丰度。`OR` 运算符代表可替代的路径，因此传播最大的覆盖度和丰度。\n        $$\n        c(\\text{AND}(m_{\\text{left}}, m_{\\text{right}})) = \\min\\left(c(m_{\\text{left}}), c(m_{\\text{right}})\\right)\n        $$\n        $$\n        b(\\text{AND}(m_{\\text{left}}, m_{\\text{right}})) = \\min\\left(b(m_{\\text{left}}), b(m_{\\text{right}})\\right)\n        $$\n        $$\n        c(\\text{OR}(m_{\\text{left}}, m_{\\text{right}})) = \\max\\left(c(m_{\\text{left}}), c(m_{\\text{right}})\\right)\n        $$\n        $$\n        b(\\text{OR}(m_{\\text{left}}, m_{\\text{right}})) = \\max\\left(b(m_{\\text{left}}), b(m_{\\text{right}})\\right)\n        $$\n\n4.  **聚合计算通路分数 ($C_P$ 和 $B_P$)**：一个通路 $P = \\{m_1, m_2, \\dots, m_k\\}$被认为是一系列必需的模块。在通路层面应用瓶颈原理，总体的通路覆盖度 $C_P$ 和丰度 $B_P$ 由其所有组成模块的最低分数决定。\n    $$\n    C_P = \\min_{i \\in \\{1,\\dots,k\\}} c(m_i), \\qquad B_P = \\min_{i \\in \\{1,\\dots,k\\}} b(m_i)\n    $$\n\n为了说明，让我们对**案例 1**进行计算：\n-   **已知条件**：阈值 $t = 0.5$。家族丰度：$a_{\\text{U1}} = 0.8$，$a_{\\text{U2}} = 0.4$，$a_{\\text{U3}} = 0.9$，$a_{\\text{U4}} = 0.3$，$a_{\\text{U5}} = 0.5$。\n-   **步骤 1  2：反应指标**：\n    -   $A_{\\text{R1}} = a_{\\text{U1}} + a_{\\text{U2}} = 0.8 + 0.4 = 1.2 \\implies p_{\\text{R1}} = 1$\n    -   $A_{\\text{R2}} = a_{\\text{U2}} = 0.4 \\implies p_{\\text{R2}} = 0$\n    -   $A_{\\text{R3}} = a_{\\text{U3}} = 0.9 \\implies p_{\\text{R3}} = 1$\n    -   $A_{\\text{R4}} = a_{\\text{U3}} + a_{\\text{U4}} = 0.9 + 0.3 = 1.2 \\implies p_{\\text{R4}} = 1$\n    -   $A_{\\text{R5}} = a_{\\text{U5}} = 0.5 \\implies p_{\\text{R5}} = 1$\n    -   $A_{\\text{R6}} = a_{\\text{U1}} = 0.8 \\implies p_{\\text{R6}} = 1$\n-   **步骤 3  4：通路 $\\text{P\\_A}$**：由模块 $m_1 = \\text{AND}(\\text{R1}, \\text{OR}(\\text{R2}, \\text{R3}))$ 和 $m_2 = \\text{AND}(\\text{R4}, \\text{R5})$ 组成。\n    -   $c(m_1) = \\min(p_{\\text{R1}}, \\max(p_{\\text{R2}}, p_{\\text{R3}})) = \\min(1, \\max(0, 1)) = 1$\n    -   $b(m_1) = \\min(A_{\\text{R1}}, \\max(A_{\\text{R2}}, A_{\\text{R3}})) = \\min(1.2, \\max(0.4, 0.9)) = 0.9$\n    -   $c(m_2) = \\min(p_{\\text{R4}}, p_{\\text{R5}}) = \\min(1, 1) = 1$\n    -   $b(m_2) = \\min(A_{\\text{R4}}, A_{\\text{R5}}) = \\min(1.2, 0.5) = 0.5$\n    -   $C_{\\text{P\\_A}} = \\min(c(m_1), c(m_2)) = \\min(1, 1) = 1.0$\n    -   $B_{\\text{P\\_A}} = \\min(b(m_1), b(m_2)) = \\min(0.9, 0.5) = 0.5$\n-   **步骤 3  4：通路 $\\text{P\\_B}$**：由模块 $m_3 = \\text{OR}(\\text{AND}(\\text{R1}, \\text{R6}), \\text{R3})$ 组成。\n    -   $c(m_3) = \\max(\\min(p_{\\text{R1}}, p_{\\text{R6}}), p_{\\text{R3}}) = \\max(\\min(1, 1), 1) = 1$\n    -   $b(m_3) = \\max(\\min(A_{\\text{R1}}, A_{\\text{R6}}), A_{\\text{R3}}) = \\max(min(1.2, 0.8), 0.9) = \\max(0.8, 0.9) = 0.9$\n    -   $C_{\\text{P\\_B}} = c(m_3) = 1.0$\n    -   $B_{\\text{P\\_B}} = b(m_3) = 0.9$\n-   **案例 1 的结果**：对于 $\\text{P\\_A}$，$[C_{\\text{P\\_A}}, B_{\\text{P\\_A}}] = [1.0, 0.5]$。对于 $\\text{P\\_B}$，$[C_{\\text{P\\_B}}, B_{\\text{P\\_B}}] = [1.0, 0.9]$。\n\n最终的程序为所有四个测试用例实现了这一精确逻辑。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the specified model for pathway coverage and abundance calculation.\n    \"\"\"\n    \n    # Static definitions from the problem statement\n    family_names = ['U1', 'U2', 'U3', 'U4', 'U5']\n    reaction_names = ['R1', 'R2', 'R3', 'R4', 'R5', 'R6']\n    \n    reaction_mappings = {\n        'R1': ['U1', 'U2'],\n        'R2': ['U2'],\n        'R3': ['U3'],\n        'R4': ['U3', 'U4'],\n        'R5': ['U5'],\n        'R6': ['U1']\n    }\n    \n    # Module structures are represented as nested tuples: (operator, child1, child2)\n    # Leaf nodes are reaction name strings.\n    pa_modules = [\n        ('AND', 'R1', ('OR', 'R2', 'R3')),  # m1\n        ('AND', 'R4', 'R5')                 # m2\n    ]\n    pb_modules = [\n        ('OR', ('AND', 'R1', 'R6'), 'R3')   # m3\n    ]\n    \n    test_cases = [\n        {'t': 0.5, 'a': {'U1': 0.8, 'U2': 0.4, 'U3': 0.9, 'U4': 0.3, 'U5': 0.5}},\n        {'t': 0.7, 'a': {'U1': 0.7, 'U2': 0.0, 'U3': 0.7, 'U4': 0.0, 'U5': 0.7}},\n        {'t': 0.0, 'a': {'U1': 0.0, 'U2': 0.0, 'U3': 0.0, 'U4': 0.0, 'U5': 0.0}},\n        {'t': 0.6, 'a': {'U1': 0.4, 'U2': 0.3, 'U3': 0.55, 'U4': 0.1, 'U5': 0.0}},\n    ]\n    \n    all_results = []\n    \n    memo_module_eval = {}\n\n    def evaluate_module(module_struct, Ar_vals, pr_vals):\n        \"\"\"Recursively computes coverage and abundance for a module.\"\"\"\n        # Check memoization table\n        if (module_struct, tuple(sorted(Ar_vals.items())), tuple(sorted(pr_vals.items()))) in memo_module_eval:\n           return memo_module_eval[(module_struct, tuple(sorted(Ar_vals.items())), tuple(sorted(pr_vals.items())))]\n        \n        # Base case: leaf node is a reaction\n        if isinstance(module_struct, str):\n            reaction_name = module_struct\n            coverage = float(pr_vals[reaction_name])\n            abundance = Ar_vals[reaction_name]\n            return coverage, abundance\n        \n        # Recursive step for internal nodes\n        op, left_child, right_child = module_struct\n        \n        c_left, b_left = evaluate_module(left_child, Ar_vals, pr_vals)\n        c_right, b_right = evaluate_module(right_child, Ar_vals, pr_vals)\n        \n        if op == 'AND':\n            c_m = min(c_left, c_right)\n            b_m = min(b_left, b_right)\n        elif op == 'OR':\n            c_m = max(c_left, c_right)\n            b_m = max(b_left, b_right)\n        else:\n            raise ValueError(f\"Unknown operator: {op}\")\n        \n        # Store result in memoization table before returning\n        memo_module_eval[(module_struct, tuple(sorted(Ar_vals.items())), tuple(sorted(pr_vals.items())))] = (c_m, b_m)\n        return c_m, b_m\n\n    for case in test_cases:\n        t = case['t']\n        abundances = case['a']\n        \n        # Step 1: Calculate Reaction Abundances (Ar)\n        Ar = {}\n        for r_name, fam_list in reaction_mappings.items():\n            Ar[r_name] = sum(abundances[f_name] for f_name in fam_list)\n        \n        # Step 2: Calculate Reaction Presences (pr)\n        pr = {r_name: 1 if Ar[r_name] >= t else 0 for r_name in reaction_names}\n        \n        # Step 3  4: Calculate Pathway Scores\n        \n        # Pathway P_A\n        pa_module_scores = [evaluate_module(m, Ar, pr) for m in pa_modules]\n        C_PA = min(score[0] for score in pa_module_scores)\n        B_PA = min(score[1] for score in pa_module_scores)\n        \n        # Pathway P_B\n        pb_module_scores = [evaluate_module(m, Ar, pr) for m in pb_modules]\n        C_PB = min(score[0] for score in pb_module_scores)\n        B_PB = min(score[1] for score in pb_module_scores)\n        \n        case_result = [\n            [float(C_PA), float(B_PA)],\n            [float(C_PB), float(B_PB)]\n        ]\n        all_results.append(case_result)\n        \n    # Final print statement in the exact required format.\n    # The default str() representation of a list of lists matches the required format.\n    print(str(all_results).replace(\"'\", '\"'))\n\nsolve()\n\n```", "id": "4565625"}]}