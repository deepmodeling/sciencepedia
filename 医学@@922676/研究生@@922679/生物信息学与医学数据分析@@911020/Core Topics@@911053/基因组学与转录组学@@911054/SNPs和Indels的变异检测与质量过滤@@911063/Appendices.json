{"hands_on_practices": [{"introduction": "在进行变异发现和质控时，一个基础但至关重要的步骤是确保变异的表示具有一致性。尤其是在基因组的重复区域，不同的变异检测工具可能对同一个插入或缺失（indel）事件给出不同的、但实际上等效的表示，这会严重影响下游的合并、注释和过滤分析。本实践将通过一个思想实验，探讨通过“左对齐”和“削减”操作实现 Indel 规范化表示的原理，这是确保跨工具和分析流程结果可比性的核心技术 [@problem_id:4617283]。", "problem": "参考基因组可以被建模为一个在字母表 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 上的有限字符串 $R$，其坐标以1为基准。变异调用格式 (VCF) 中的一条记录通过提供一个三元组 $(p,\\text{REF},\\text{ALT})$ 来编码对 $R$ 中一个连续子串的替换，其中 $p$ 是 $R$ 中的位置索引，$\\text{REF}$ 是在 $R[p..p+|\\text{REF}|-1]$ 处观察到的参考等位基因字符串，而 $\\text{ALT}$ 是将在该位点替换的备选等位基因字符串。VCF 规范要求 $|\\text{REF}| \\geq 1$。当将 $(p,\\text{REF},\\text{ALT})$ 应用于 $R$ 时，通过用 $\\text{ALT}$ 替换 $R[p..p+|\\text{REF}|-1]$ 得到最终的单倍型字符串 $H$。如果两个 VCF 表示 $(p_1,\\text{REF}_1,\\text{ALT}_1)$ 和 $(p_2,\\text{REF}_2,\\text{ALT}_2)$ 应用于 $R$ 后产生相同的单倍型字符串 $H$，则称它们在 $R$ 上是等效的。在重复区域（例如，同聚物或串联重复序列）中，不同的变异检测算法（caller）可能会在不同的位置 $p$ 报告具有不同 $(\\text{REF},\\text{ALT})$ 的插入或删除，而这些表示在上述意义上是等效的。\n\n在实践中，为了比较、合并和质量筛选由不同算法检测出的变异，需要将每条记录转换为一个规范化表示，该表示对于每个能产生相同单倍型 $H$ 的等效表示类都是唯一的。考虑 $R$ 中一个形式为 $R[i..j] = \\text{\"AAAA\\ldots A\"}$ 的同聚物区域（对于某些索引 $i \\leq j$），以及在 $[i,j]$ 范围内的某处发生的一个单碱基 $\\text{\"A\"}$ 的删除。同样，考虑一个串联重复区域 $R[i..i+m\\cdot k-1] = w^m$，其中某个长度为 $k$ 的基元 $w$ 重复了 $m$ 次，并且发生了一次 $w$ 的插入。\n\n选择所有正确且完整地描述 VCF 中插入和删除的“左对齐”和“修剪”操作的陈述，并论证基于这些操作的确定性规范化表示如何为每个等效表示类（这些表示在不同变异检测算法中产生相同的单倍型 $H$）导出唯一的代表。您的回答应反映 VCF 应用语义和 $R$ 上字符串等效性的基本原理。\n\nA. 插入或删除的左对齐将位置 $p$ 移动到能产生相同单倍型字符串 $H$ 的最小索引（相对于 $\\{1,2,\\ldots,|R|\\}$ 上的自然顺序）；修剪则移除 $\\text{REF}$ 和 $\\text{ALT}$ 的最大公共前缀和后缀（根据修剪掉的前缀长度调整 $p$），并需满足 VCF 的锚定约束 $|\\text{REF}|\\geq 1$，从而产生一个最小化的表示。一个通过确定性的先修剪后左对齐所定义的规范化表示，为每个能诱导相同 $H$ 的等效表示类产生一个唯一的代表，从而实现了跨不同变异检测算法的一致性合并和质量筛选。\n\nB. 左对齐总会改变重复区域中插入或删除的生物学效应，因为移动 $p$ 会改变编码框或调控位置；因此，不同的变异检测算法必须报告不同的位置以保留来源信息，而规范化会破坏跨算法的等效性。\n\nC. VCF 中插入和删除的修剪必须从 $\\text{REF}$ 中移除所有碱基，以便对于插入，$\\text{REF}=\\epsilon$（空字符串），对于删除，$\\text{ALT}=\\epsilon$，因为只有空的锚定才能产生最小化表示。\n\nD. 两个插入/删除表示是等效的，当且仅当它们的位置 $p$ 和参考等位基因 $\\text{REF}$ 相同；$\\text{ALT}$ 的差异不影响等效性，因此规范化只需要标准化 $p$。\n\nE. 在一个同聚物区域 $R[i..j]=\\text{\"AAAA\\ldots A\"}$ 中，无论使用 $[i,j]$ 中的哪个索引删除一个 $\\text{\"A\"}$，都会产生相同的单倍型字符串 $H$，因为被移除的符号在该区域内是无法区分的。左对齐通过向左滑动删除操作直到 $R[p-1]\\neq\\text{\"A\"}$ 来选择最小的有效索引。类似地，在串联重复序列 $R[i..i+m\\cdot k-1]=w^m$ 中，插入一个 $w$ 的拷贝可以在该重复区域内移动而不改变 $H$。通过修剪和左对齐进行的规范化将这些等效表示统一为一个单一的代表，这支持了跨不同变异检测算法对每个位点的质量指标（例如，等位基因深度）进行准确汇总。", "solution": "我们从基本原理出发：变异调用格式 (VCF) 规定，一条变异记录 $(p,\\text{REF},\\text{ALT})$ 编码了在参考基因组字符串 $R$ 中，用 $\\text{ALT}$ 替换子串 $R[p..p+|\\text{REF}|-1]$ 的操作，从而产生一个单倍型字符串 $H$。两条记录在 $R$ 上是等效的，当且仅当它们的应用产生相同的 $H$。插入和删除（统称为 indel）在重复区域中可能存在多种等效表示，因为在相同的上下文中移动位点会产生相同的 $H$。\n\n定义应用算子 $\\mathcal{A}$ 如下：对于 $R$ 和 $(p,\\text{REF},\\text{ALT})$，且 $R[p..p+|\\text{REF}|-1]=\\text{REF}$，\n$$\nH=\\mathcal{A}\\big(R,(p,\\text{REF},\\text{ALT})\\big)=R[1..p-1]\\ \\Vert\\ \\text{ALT}\\ \\Vert\\ R[p+|\\text{REF}|..|R|],\n$$\n其中 $\\Vert$ 表示字符串拼接，索引以1为基准。那么等效性就是如下关系：\n$$\n(p_1,\\text{REF}_1,\\text{ALT}_1)\\sim (p_2,\\text{REF}_2,\\text{ALT}_2)\\iff \\mathcal{A}\\big(R,(p_1,\\text{REF}_1,\\text{ALT}_1)\\big)=\\mathcal{A}\\big(R,(p_2,\\text{REF}_2,\\text{ALT}_2)\\big).\n$$\n\n修剪。令 $\\text{REF}$ 和 $\\text{ALT}$ 为字符串。定义它们的最大公共前缀长度\n$$\n\\ell=\\max\\{t\\in\\mathbb{N}_0:\\ \\text{REF}[1..t]=\\text{ALT}[1..t]\\}\n$$\n和最大公共后缀长度\n$$\ns=\\max\\{u\\in\\mathbb{N}_0:\\ \\text{REF}[|\\text{REF}|-u+1..|\\text{REF}|]=\\text{ALT}[|\\text{ALT}|-u+1..|\\text{ALT}|]\\}.\n$$\n修剪操作移除这些共享区域以产生\n$$\n\\text{REF}'=\\text{REF}[\\ell+1..|\\text{REF}|-s],\\quad \\text{ALT}'=\\text{ALT}[\\ell+1..|\\text{ALT}|-s],\\quad p'=p+\\ell,\n$$\n这需要遵循 VCF 锚定规则 $|\\text{REF}'|\\geq 1$（最左侧的锚定碱基必须保留在 $\\text{REF}'$ 中）。很容易验证\n$$\n\\mathcal{A}\\big(R,(p,\\text{REF},\\text{ALT})\\big)=\\mathcal{A}\\big(R,(p',\\text{REF}',\\text{ALT}')\\big),\n$$\n因为修剪只丢弃了 $\\text{REF}$ 和 $\\text{ALT}$ 中相同的位置，而位置的移动 $p'=p+\\ell$ 在第一个不同的碱基处重新锚定。\n\n左对齐。在重复区域中，一个 indel 可以沿着相同的相邻碱基移动，而不会改变应用后的单倍型 $H$。让我们将同聚物的情况形式化。假设 $R[i..j]=\\text{\"AAAA\\ldots A\"}$（全是 $\\text{\"A\"}$），我们考虑在该区间内某处进行一次单碱基 $\\text{\"A\"}$ 的删除。对于任何 $p\\in[i..j]$，删除 $R[p]$ 会得到\n$$\nH=R[1..p-1]\\ \\Vert\\ R[p+1..|R|],\n$$\n并且由于 $R[i..j]$ 中的所有符号都是 $\\text{\"A\"}$，对于 $[i,j]$ 中的任何 $p$ 选择，这个 $H$ 都是相同的。因此，等效表示的集合包括所有 $(p,\\text{\"A\"},\\epsilon)$，其中 $p\\in[i..j]$，$\\epsilon$ 表示空字符串，这是在修剪公共后缀后从 $\\text{REF}$ 中删除一个碱基的结果（注意，在 VCF 中，由于锚定，记录的 $\\text{REF}$ 字段仍然至少包含一个碱基，但在修剪后，差异体现在不同的那个碱基上）。左对齐选择该等效类中的最小索引：具体来说，我们向左移动 $p$ 只要 $R[p-1]=\\text{\"A\"}$，并在 $R[p-1]\\neq \\text{\"A\"}$ 的第一个位置停止，这就得到了最小的有效 $p$。根据等效性论证，这保留了 $H$，并根据位置上的自然全序关系选择了一个唯一的代表。\n\n类似的论证适用于具有长度为 $k$ 的基元 $w$ 的串联重复序列 $R[i..i+m\\cdot k-1]=w^m$。考虑在重复序列内部插入一个 $w$ 的拷贝。对于任何保持 $w$ 相位的位置 $p$，插入 $w$ 会得到\n$$\nH=R[1..p-1]\\ \\Vert\\ w\\ \\Vert\\ R[p..|R|],\n$$\n并且因为上下文是 $w$ 的拼接，任何与基元边界对齐的插入位置都会产生相同的 $H$。左对齐然后通过向左移动直到前面的上下文破坏了基元的等同性，来选择最小的这样一个 $p$。修剪确保了 $\\text{REF}$ 和 $\\text{ALT}$ 之间没有冗余的共享序列。\n\n规范化表示的唯一性。定义规范化操作 $\\mathcal{N}$，它将任何记录 $(p,\\text{REF},\\text{ALT})$ 映射到 $(\\tilde{p},\\widetilde{\\text{REF}},\\widetilde{\\text{ALT}})$，通过首先修剪公共前缀/后缀以产生 $(p',\\text{REF}',\\text{ALT}')$（同时遵守 $|\\text{REF}'|\\geq 1$），然后在由 $\\mathcal{A}(R,\\cdot)$ 决定的等效类内进行左对齐。在一个给定的等效类中，修剪产生唯一的没有共享前缀或后缀的 $(\\text{REF}',\\text{ALT}')$ 对，而左对齐则在所有产生相同 $H$ 的位置中选择最小的 $\\tilde{p}$。因为位置上的序是一个全序，并且该类包含有限的一组有效移动（受重复区域范围的限制），所以最小元素存在且唯一。因此，$\\mathcal{N}$ 是一个确定性映射，为每个等效类选择一个唯一的代表。这种规范化使得一致的合并和质量筛选成为可能：例如，等位基因深度和链偏向性等指标可以按规范化位点进行汇总，因为等效的记录被映射到了相同的坐标和等位基因字符串。\n\n逐项分析：\n\nA. 该陈述正确地定义了左对齐是选择保留结果单倍型 $H$ 的最小索引 $p$，修剪是移除最大公共前缀和后缀，同时根据修剪的前缀调整 $p$ 并遵守 $|\\text{REF}|\\geq 1$。它正确地指出，一个先修剪后左对齐的确定性过程为每个等效类产生一个唯一的代表，这支持了一致的合并和质量筛选。结论 — 正确。\n\nB. 该陈述声称左对齐会改变生物学效应，并且规范化会破坏等效性。从基本原理来看，在重复区域内进行左对齐，根据等效性的定义，保留了应用后的单倍型 $H$，并且除非变异本身被改变，否则不会改变编码框或调控内容；它仅仅是重新定位一个等效的表示。因此，这是错误的。结论 — 错误。\n\nC. 该陈述声称修剪必须使得对于插入，$\\text{REF}=\\epsilon$，对于删除，$\\text{ALT}=\\epsilon$。VCF 规范要求 $|\\text{REF}|\\geq 1$，修剪只移除共享的前缀/后缀，同时保留锚定在 $p$ 的第一个不同碱基。通常，在有效的 VCF 记录中，$\\text{REF}$ 不可能是空字符串，而对于删除，如果修剪后仍然存在多碱基差异，$\\text{ALT}$ 也不必为空。结论 — 错误。\n\nD. 该陈述将等效性等同于相同的 $p$ 和 $\\text{REF}$，而忽略了 $\\text{ALT}$。等效性是通过应用后的单倍型 $H$ 是否相等来定义的，这取决于 $\\text{REF}$ 和 $\\text{ALT}$ 以及它们的位置。两条记录可以有不同的 $p$ 和不同的 $(\\text{REF},\\text{ALT})$，但如果它们产生相同的 $H$（如同聚物中的情况），它们仍然是等效的；而具有相同 $p$ 和 $\\text{REF}$ 但不同 $\\text{ALT}$ 的记录通常是不等效的。结论 — 错误。\n\nE. 该陈述正确地描述了在 $\\text{\"A\"}$ 的同聚物区域中，在区域内的任何位置删除一个 $\\text{\"A\"}$ 都会产生相同的 $H$，并且左对齐通过向左滑动直到前一个碱基不同来选择最小的索引。它还正确地推广到具有基元 $w$ 的串联重复序列，并指出通过修剪和左对齐进行的规范化将等效表示统一为单一的代表，从而便于汇总等位基因深度等质量指标。结论 — 正确。", "answer": "$$\\boxed{AE}$$", "id": "4617283"}, {"introduction": "在确保了变异表示的唯一性之后，下一步是量化我们对每一个变异位点真实性的信心。本实践将带你深入了解变异质量评估的统计学核心，即推导广泛使用的 QUAL 质量值。你将运用贝叶斯定理，结合测序数据提供的证据（基因型似然，即 PL 值）和先验概率，来计算一个位点不存在变异的后验概率，并最终将其转换为 Phred 质量分值 [@problem_id:4617239]。这个练习将揭示变异发现流程如何将原始的统计不确定性转化为一个可解释的质量指标。", "problem": "对一个可能含有单核苷酸多态性 (SNP) 的双等位基因座上的单个二倍体样本进行测序。令 $g \\in \\{0/0, 0/1, 1/1\\}$ 表示样本的基因型，令 $D$ 表示在该基因座上观测到的读数数据。基因型似然 $L(D \\mid g)$ 是在给定基因型 $g$ 的条件下观测到 $D$ 的概率。广泛使用的Phred标度似然 $PL_g$ 是相对于最可能基因型定义的，其公式为 $PL_g = -10 \\log_{10}\\left(L(D \\mid g)/\\max_{h} L(D \\mid h)\\right)$。假设该基因座报告的 $PL$ 值如下：$PL_{0/0} = 80$，$PL_{0/1} = 0$ 和 $PL_{1/1} = 40$。\n\n一个位点水平的先验表达了“变异”与“无变异”的先验优势比 $O$，其中“无变异”对单个样本而言意味着基因型为 $0/0$。设 $O = 10^{-3}$。在“变异”事件发生的条件下，假设基因型 $0/1$ 和 $1/1$ 之间的先验分配由杂合子分数 $\\alpha = 0.9$ 给出，因此 $P(0/1) = \\alpha \\frac{O}{1+O}$ 且 $P(1/1) = (1-\\alpha)\\frac{O}{1+O}$，而 $P(0/0) = \\frac{1}{1+O}$。\n\n仅使用上述定义和贝叶斯法则，推导后验概率 $P(\\text{无变异} \\mid D)$ 关于 $L(D \\mid g)$ 和 $P(g)$ 的表达式，然后通过对该后验概率应用标准的Phred变换来获得位点质量分数 $Q$。最后，使用提供的 $PL$ 值和先验参数计算该基因座的 $Q$ 值。将最终数值结果四舍五入至四位有效数字。", "solution": "用户要求我解决一个与变异检测相关的生物信息学问题。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n-   考虑一个双等位基因座上的单个二倍体样本。\n-   基因型由 $g \\in \\{0/0, 0/1, 1/1\\}$ 表示。\n-   观测到的读数数据由 $D$ 表示。\n-   基因型似然为 $L(D \\mid g) = P(D \\mid g)$。\n-   基因型 $g$ 的Phred标度似然为 $PL_g = -10 \\log_{10}\\left(L(D \\mid g)/\\max_{h} L(D \\mid h)\\right)$。\n-   观测到的Phred标度似然为 $PL_{0/0} = 80$，$PL_{0/1} = 0$ 和 $PL_{1/1} = 40$。\n-   “变异”与“无变异”的先验优势比为 $O = 10^{-3}$。\n-   “无变异”事件对应于基因型 $g=0/0$。\n-   条件杂合子分数为 $\\alpha = 0.9$。\n-   先验概率给出如下：\n    -   $P(g = 0/0) = \\frac{1}{1+O}$\n    -   $P(g = 0/1) = \\alpha \\frac{O}{1+O}$\n    -   $P(g = 1/1) = (1-\\alpha)\\frac{O}{1+O}$\n-   任务是推导后验概率 $P(\\text{无变异} \\mid D)$ 关于 $L(D \\mid g)$ 和 $P(g)$ 的表达式。\n-   然后，将位点质量分数 $Q$ 定义为该后验概率的Phred变换。\n-   最后，使用所给数据计算 $Q$ 的数值，并四舍五入至四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n\n该问题具有科学依据，提法明确且客观。所提供的关于基因型似然、Phred标度、先验概率以及贝叶斯法则应用的定义，都是生物信息学领域，特别是在统计遗传学和变异检测流程（例如 GATK, SAMtools）中的标准和基本概念。该问题是自洽的，为得到唯一解提供了所有必要的参数和定义。数值是合理的。不存在矛盾、歧义或违反科学原理之处。该问题需要对这些原理进行多步应用，这是一个有效且有意义的练习。\n\n**步骤3：结论与行动**\n\n该问题被认定为有效。将提供完整的解答。\n\n### 解答\n\n主要目标是计算位点质量分数 $Q$，这首先需要确定位点为非变异的后验概率 $P(\\text{无变异} \\mid D)$。\n\n**1. 推导后验概率 $P(\\text{无变异} \\mid D)$ 的表达式**\n\n“无变异”事件等同于样本具有纯合参考基因型 $g=0/0$。我们需要求的是在给定观测数据 $D$ 的条件下此事件的后验概率，即 $P(g=0/0 \\mid D)$。\n\n根据贝叶斯法则，任何给定基因型 $g$ 的后验概率为：\n$$P(g \\mid D) = \\frac{P(D \\mid g) P(g)}{P(D)}$$\n其中 $P(D \\mid g)$ 是给定基因型的数据似然（记为 $L(D \\mid g)$），$P(g)$ 是基因型的先验概率，而 $P(D)$ 是数据的边际概率，作为一个归一化常数。边际概率通过对所有可能的基因型 $h$ 求和来计算：\n$$P(D) = \\sum_{h \\in \\{0/0, 0/1, 1/1\\}} P(D \\mid h) P(h)$$\n\n代入给定的似然和先验的符号，分母变为：\n$$P(D) = L(D \\mid 0/0) P(0/0) + L(D \\mid 0/1) P(0/1) + L(D \\mid 1/1) P(1/1)$$\n\n因此，“无变异”情况（$g=0/0$）的后验概率为：\n$$P(\\text{无变异} \\mid D) = P(g=0/0 \\mid D) = \\frac{L(D \\mid 0/0) P(0/0)}{L(D \\mid 0/0) P(0/0) + L(D \\mid 0/1) P(0/1) + L(D \\mid 1/1) P(1/1)}$$\n这就是所要求的后验概率关于 $L(D \\mid g)$ 和 $P(g)$ 的表达式。\n\n**2. 定义位点质量分数 $Q$**\n\n问题指出，位点质量分数 $Q$ 是通过对“无变异”事件的后验概率应用标准的Phred变换得到的。概率 $p$ 的Phred变换由 $-10 \\log_{10}(p)$ 给出。因此，$Q$ 的定义为：\n$$Q = -10 \\log_{10}(P(\\text{无变异} \\mid D)) = -10 \\log_{10}(P(g=0/0 \\mid D))$$\n\n**3. 计算 $Q$ 的值**\n\n为了计算 $Q$，我们必须首先使用提供的参数计算 $P(g=0/0 \\mid D)$ 的数值。这包括根据 $PL$ 值计算似然比，以及根据 $O$ 和 $\\alpha$ 计算先验概率。\n\n首先，让我们从给定的 $PL$ 值确定相对似然。定义为 $PL_g = -10 \\log_{10}\\left(L(D \\mid g)/ L_{\\max}\\right)$，其中 $L_{\\max} = \\max_{h} L(D \\mid h)$。整理该式可得：\n$$\\frac{L(D \\mid g)}{L_{\\max}} = 10^{-PL_g/10}$$\n提供的 $PL$ 值为 $PL_{0/0} = 80$，$PL_{0/1} = 0$ 和 $PL_{1/1} = 40$。$PL=0$ 的基因型是具有最大似然的基因型，因此 $L_{\\max} = L(D \\mid 0/1)$。相对似然为：\n-   对于 $g=0/0$: $\\frac{L(D \\mid 0/0)}{L_{\\max}} = 10^{-80/10} = 10^{-8}$\n-   对于 $g=0/1$: $\\frac{L(D \\mid 0/1)}{L_{\\max}} = 10^{-0/10} = 10^0 = 1$\n-   对于 $g=1/1$: $\\frac{L(D \\mid 1/1)}{L_{\\max}} = 10^{-40/10} = 10^{-4}$\n\n接下来，我们使用 $O = 10^{-3}$ 和 $\\alpha = 0.9$ 计算先验概率：\n-   $P(0/0) = \\frac{1}{1+O} = \\frac{1}{1+10^{-3}}$\n-   $P(0/1) = \\alpha \\frac{O}{1+O} = 0.9 \\times \\frac{10^{-3}}{1+10^{-3}}$\n-   $P(1/1) = (1-\\alpha) \\frac{O}{1+O} = (1-0.9) \\frac{10^{-3}}{1+10^{-3}} = 0.1 \\times \\frac{10^{-3}}{1+10^{-3}}$\n\n现在我们将这些代入 $P(g=0/0 \\mid D)$ 的表达式中。注意，似然中的 $L_{\\max}$ 项和先验中的 $\\frac{1}{1+O}$ 项将在分子和分母中抵消。我们可以使用与似然成比例的项 $L'_g = L(D \\mid g)/L_{max}$ 和与先验成比例的项 $P'(g) = P(g)(1+O)$ 进行计算。\n-   $L'_{0/0} = 10^{-8}$，$L'_{0/1} = 1$，$L'_{1/1} = 10^{-4}$\n-   $P'(0/0) = 1$，$P'(0/1) = \\alpha O = 0.9 \\times 10^{-3}$，$P'(1/1) = (1-\\alpha)O = 0.1 \\times 10^{-3}$\n\n后验概率为：\n$$P(g=0/0 \\mid D) = \\frac{L'_{0/0} P'(0/0)}{L'_{0/0} P'(0/0) + L'_{0/1} P'(0/1) + L'_{1/1} P'(1/1)}$$\n代入数值：\n$$P(g=0/0 \\mid D) = \\frac{10^{-8} \\times 1}{(10^{-8} \\times 1) + (1 \\times 0.9 \\times 10^{-3}) + (10^{-4} \\times 0.1 \\times 10^{-3})}$$\n$$P(g=0/0 \\mid D) = \\frac{10^{-8}}{10^{-8} + 9 \\times 10^{-4} + 10^{-8}}$$\n$$P(g=0/0 \\mid D) = \\frac{10^{-8}}{9 \\times 10^{-4} + 2 \\times 10^{-8}}$$\n为简化计算，从分母中提出 $10^{-4}$：\n$$P(g=0/0 \\mid D) = \\frac{10^{-8}}{10^{-4} (9 + 2 \\times 10^{-4})} = \\frac{10^{-4}}{9 + 0.0002} = \\frac{10^{-4}}{9.0002}$$\n\n最后，我们计算 $Q$：\n$$Q = -10 \\log_{10} \\left( \\frac{10^{-4}}{9.0002} \\right)$$\n使用对数性质 $\\log_{10}(a/b) = \\log_{10}(a) - \\log_{10}(b)$：\n$$Q = -10 \\left( \\log_{10}(10^{-4}) - \\log_{10}(9.0002) \\right)$$\n$$Q = -10 \\left( -4 - \\log_{10}(9.0002) \\right)$$\n$$Q = 40 + 10 \\log_{10}(9.0002)$$\n使用计算器，$\\log_{10}(9.0002) \\approx 0.95425143$。\n$$Q \\approx 40 + 10 \\times (0.95425143)$$\n$$Q \\approx 40 + 9.5425143$$\n$$Q \\approx 49.5425143$$\n\n问题要求将结果四舍五入至四位有效数字。\n$$Q \\approx 49.54$$", "answer": "$$\\boxed{49.54}$$", "id": "4617239"}, {"introduction": "为每个变异位点赋予质量分值后，最终的挑战是如何为整个变异集设定一个过滤阈值，以在发现真实变异（灵敏度）和引入错误变异（特异性）之间取得最佳平衡。本实践提供了一种解决此问题的实用方法，即通过编写一个算法来控制假发现率（False Discovery Rate, FDR）。你将学习如何利用一个“真实集”（truth set）作为基准，凭经验确定一个最佳的 QUAL 分数阈值，以满足预设的质量目标，从而最大化保留高质量变异的数量 [@problem_id:4617237]。", "problem": "给定一组来自全基因组分析的单核苷酸多态性（SNP）和插入缺失（indel）候选变异的变异检出（variant calls）。每个检出都有一个相关的类 Phred 变异质量分数 $QUAL$，以及一个布尔指标，用于指示该检出是否位于用于基准测试的独立验证的真实区域内。目标是从第一性原理出发，推导出一个关于 $QUAL$ 的阈值规则，该规则将假发现率（FDR）控制在目标值或以下，同时最大化保留的检出数量，然后将其实现为一个程序，为指定的测试套件计算结果。\n\n基本依据和定义：\n- Phred 量表将质量值 $Q$ 解释为错误可能性的单调转换，并广泛用于基因组学中，以按置信度对变异检出进行排序。不假设任何特定的校准；只要求较高的 $Q$ 相对于较低的 $Q$ 不应降低其正确性的合理性。\n- 在统计假设检验中，假发现率（FDR）定义为所有发现中假发现的预期比例。在一个适用于与真实集合进行基准测试的有限计数近似中，对于给定的 $QUAL$ 阈值 $\\tau$ 定义如下：\n  - 设数据集包含 $n$ 个检出，索引为 $i \\in \\{1,\\dots,n\\}$。\n  - 设 $Q_i$ 为检出 $i$ 的 $QUAL$。\n  - 设 $B_i \\in \\{0,1\\}$ 表示在真实区域中的成员关系，其中 $B_i=1$ 表示检出位于真实区域内（代表真阳性候选），$B_i=0$ 表示检出位于真实区域外（代表假阳性候选）。\n  - 通过包含性规则保留检出：当且仅当 $Q_i \\ge \\tau$ 时，检出 $i$ 被保留。\n  - 设 $S(\\tau)=\\{i \\mid Q_i \\ge \\tau\\}$ 为保留检出的集合。\n  - 定义保留的假阳性为 $FP(\\tau) = \\sum_{i \\in S(\\tau)} (1 - B_i)$。\n  - 定义保留的真阳性为 $TP(\\tau) = \\sum_{i \\in S(\\tau)} B_i$。\n  - 定义在阈值 $\\tau$ 下的有限样本 FDR 为\n    $$\\mathrm{FDR}(\\tau) = \\begin{cases}\n    \\dfrac{FP(\\tau)}{FP(\\tau) + TP(\\tau)}  \\text{if } FP(\\tau) + TP(\\tau)  0, \\\\\n    0  \\text{if } FP(\\tau) + TP(\\tau) = 0,\n    \\end{cases}$$\n    当没有保留的检出时，此定义将 FDR 设置为 $0$（没有发现意味着没有假发现）。\n- 在目标 FDR $t$ 下的最优阈值是满足 $\\mathrm{FDR}(\\tau) \\le t$ 的最小 $\\tau$，使用包含性 $QUAL$ 过滤器 $Q_i \\ge \\tau$。最小化通过在 FDR 约束下尽可能多地保留检出，从而提高灵敏度。\n\n算法要求：\n- 考虑由 $\\{Q_i\\}$ 的排序后唯一值给出的候选阈值，记为 $\\tau \\in \\mathcal{T} = \\{\\text{排序后的唯一 }Q_i\\}$。在包含性规则 $Q_i \\ge \\tau$ 下，这些候选阈值枚举了所有不同的保留集合 $S(\\tau)$。\n- 如果没有 $\\tau \\in \\mathcal{T}$ 满足 $\\mathrm{FDR}(\\tau) \\le t$，则定义一个回退阈值\n  $$\\tau^\\mathrm{fallback} = \\max_i(Q_i) + \\epsilon,$$\n  其中 $\\epsilon = 10^{-6}$，这会得到 $S(\\tau^\\mathrm{fallback}) = \\emptyset$，因此 $\\mathrm{FDR}(\\tau^\\mathrm{fallback}) = 0$，保留的检出数量为 $0$。\n- 最优阈值为\n  $$\\tau^\\ast = \\begin{cases}\n  \\min\\{\\tau \\in \\mathcal{T} \\mid \\mathrm{FDR}(\\tau) \\le t\\}  \\text{如果集合非空}, \\\\\n  \\tau^\\mathrm{fallback}  \\text{否则}.\n  \\end{cases}$$\n\n任务：\n- 实现一个程序，为每个测试用例计算 $\\tau^\\ast$、$\\mathrm{FDR}(\\tau^\\ast)$ 和保留的检出计数 $\\lvert S(\\tau^\\ast) \\rvert$。\n- 完全按照上面的定义使用包含性过滤器 $Q_i \\ge \\tau$。\n- 将 $\\tau^\\ast$ 和 $\\mathrm{FDR}(\\tau^\\ast)$ 四舍五入到 $6$ 位小数；保留的检出计数必须是整数。\n\n测试套件：\n在以下测试用例上评估您的程序。每个测试用例由一个 $QUAL$ 值列表、一个相应的真实区域指标 $B_i$ 列表和一个目标 FDR $t$（以小数形式表示）指定。\n\n- 案例 1（一般非单调场景）：\n  - $QUAL$: $\\{12,18,35,42,60,75,90,25,55,40\\}$\n  - $B$: $\\{0,0,1,1,1,1,0,1,1,0\\}$\n  - 目标 $t$: $0.3$\n- 案例 2（所有保留的检出都在真实区域内）：\n  - $QUAL$: $\\{5,10,20,40\\}$\n  - $B$: $\\{1,1,1,1\\}$\n  - 目标 $t$: $0.0$\n- 案例 3（除排除所有检出外，没有可接受的阈值）：\n  - $QUAL$: $\\{30,60,90\\}$\n  - $B$: $\\{0,0,0\\}$\n  - 目标 $t$: $0.0$\n- 案例 4（阈值处存在相等值，采用包含性保留）：\n  - $QUAL$: $\\{20,20,50,50,50\\}$\n  - $B$: $\\{0,1,0,1,1\\}$\n  - 目标 $t$: $0.35$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是 $[\\tau^\\ast,\\mathrm{FDR}(\\tau^\\ast),\\lvert S(\\tau^\\ast) \\rvert]$ 形式的列表，其中 $\\tau^\\ast$ 和 $\\mathrm{FDR}(\\tau^\\ast)$ 四舍五入到 $6$ 位小数，$\\lvert S(\\tau^\\ast) \\rvert$ 为整数。\n- 例如，整体输出应如下所示\n  $$[[\\tau^\\ast_1,\\mathrm{FDR}(\\tau^\\ast_1),\\lvert S(\\tau^\\ast_1)\\rvert],[\\tau^\\ast_2,\\mathrm{FDR}(\\tau^\\ast_2),\\lvert S(\\tau^\\ast_2)\\rvert],\\dots].$$", "solution": "该问题要求推导并实现一个算法，用于确定过滤基因组变异检出的最优质量分数阈值。优化目标是将假发现率（FDR）控制在指定目标水平 $t$ 或以下，同时最大化保留的检出数量，这对应于最大化灵敏度。\n\n所提供的框架基于 FDR 的有限样本近似，该近似使用基准集计算得出。总共 $n$ 个变异检出中的每一个检出 $i$ 都由一个质量分数 $Q_i$ 和一个二进制指标 $B_i$ 来表征。$B_i=1$ 表示该检出位于可信的“真实”区域内（代表真阳性），而 $B_i=0$ 表示其位于区域之外（代表假阳性）。核心假设是 $Q_i$ 是一个类 Phred 分数，意味着它与检出的置信度单调相关；越高的 $Q_i$ 意味着越可靠的检出。\n\n如果一个检出 $i$ 的质量分数 $Q_i$ 达到或超过给定阈值 $\\tau$，即 $Q_i \\ge \\tau$，则该检出被保留。保留的检出集合表示为 $S(\\tau) = \\{i \\mid Q_i \\ge \\tau\\}$。对于这个集合，我们可以计算保留的真阳性数量 $TP(\\tau) = \\sum_{i \\in S(\\tau)} B_i$ 和保留的假阳性数量 $FP(\\tau) = \\sum_{i \\in S(\\tau)} (1 - B_i)$。保留的检出总数，即发现数，为 $|S(\\tau)| = TP(\\tau) + FP(\\tau)$。\n\n对于阈值 $\\tau$ 的有限样本 FDR 定义为所有保留检出中假阳性的比例：\n$$\n\\mathrm{FDR}(\\tau) = \\begin{cases}\n\\dfrac{FP(\\tau)}{FP(\\tau) + TP(\\tau)}  \\text{if } FP(\\tau) + TP(\\tau)  0, \\\\\n0  \\text{if } FP(\\tau) + TP(\\tau) = 0.\n\\end{cases}\n$$\n分母为 $0$ 的情况意味着没有检出被保留，因此没有做出任何发现，所以也就没有假发现。\n\n目标是找到一个最优阈值 $\\tau^\\ast$。为了在约束 $\\mathrm{FDR}(\\tau) \\le t$ 下最大化保留的检出数量（灵敏度），我们应该选择满足该条件的最不严格（即最小）的阈值。较低的阈值会保留更多的检出。\n\n保留的检出集合 $S(\\tau)$ 仅在阈值 $\\tau$ 穿过某个质量分数值 $Q_i$ 时才会改变。因此，我们只需要将 $Q_i$ 的唯一值作为候选阈值来考虑。设 $\\mathcal{T}$ 为唯一质量分数的集合，按升序排序：$\\mathcal{T} = \\{\\tau_1, \\tau_2, \\dots, \\tau_k\\}$ 其中 $\\tau_1  \\tau_2  \\dots  \\tau_k$。\n\n找到最优阈值 $\\tau^\\ast$ 的算法如下：\n\n1.  **识别候选阈值**：从数据集中提取所有唯一的质量分数 $\\{Q_i\\}$，并按升序对其进行排序，以形成候选阈值集合 $\\mathcal{T}$。\n\n2.  **迭代搜索**：从最小的 $\\tau_1$ 开始，遍历候选阈值 $\\tau_j \\in \\mathcal{T}$。对于每个 $\\tau_j$：\n    a.  定义保留的检出集合 $S(\\tau_j) = \\{i \\mid Q_i \\ge \\tau_j\\}$。注意，由于采用包含性不等式，所有质量等于 $\\tau_j$ 的检出都会被包括在内。\n    b.  计算保留的假阳性数量 $FP(\\tau_j) = \\sum_{i \\in S(\\tau_j)} (1-B_i)$，以及保留的检出总数 $|S(\\tau_j)|$。\n    c.  使用上述定义计算 FDR，即 $\\mathrm{FDR}(\\tau_j)$。\n    d.  检查是否满足 FDR 约束：$\\mathrm{FDR}(\\tau_j) \\le t$。\n    e.  如果满足约束，我们便找到了一个有效的阈值。由于我们是从最小的 $\\tau_j$ 向上迭代的，因此这第一个有效的阈值就是最小的阈值。我们设置 $\\tau^\\ast = \\tau_j$ 并完成搜索。记录相应的 $\\mathrm{FDR}(\\tau^\\ast)$ 和 $|S(\\tau^\\ast)|$ 值。\n\n3.  **回退机制**：如果迭代完成并且没有阈值 $\\tau_j \\in \\mathcal{T}$ 满足条件 $\\mathrm{FDR}(\\tau_j) \\le t$，则意味着没有非平凡的过滤能够满足目标 FDR。在这种情况下，问题指定了一个回退规则，以确保严格满足 FDR 约束，尽管这会完全丧失灵敏度。阈值被设置为一个保证拒绝所有检出的值：\n    $$ \\tau^\\ast = \\tau^\\mathrm{fallback} = \\max_i(Q_i) + \\epsilon $$\n    其中 $\\epsilon$ 是一个小的正常数，给定为 $10^{-6}$。对于此阈值，保留的检出集合 $S(\\tau^\\ast)$ 为空。因此， $|S(\\tau^\\ast)| = 0$，并且根据定义，$\\mathrm{FDR}(\\tau^\\ast) = 0$。\n\n对于任何给定的数据集和目标 FDR $t$，此过程保证能找到一个唯一的最优阈值 $\\tau^\\ast$。实现将涉及对唯一的质量分数进行排序，然后遍历它们以执行如上所述的计算。为了提高计算效率，特别是对于大型数据集，按质量分数预先对检出进行排序，并使用 $B_i$ 和 $(1-B_i)$ 的累积和，会比为每个阈值重新扫描整个数据集性能更高。然而，对于指定的测试用例，直接实现上述逻辑就足够了。", "answer": "[[25.000000,0.250000,8],[5.000000,0.000000,4],[90.000001,0.000000,0],[50.000000,0.333333,3]]", "id": "4617237"}]}