{"hands_on_practices": [{"introduction": "本实践项目旨在解决 k-mer 分析中的一项基本任务：准确计数。由于 DNA 是双链结构，一个 k-mer 及其反向互补序列代表了相同的生物学片段。本练习将指导你实现一个“规范化”流程，以确保每条独一无二的序列只被计数一次，这是任何下游应用（如基因组组装或变异检测）都必须执行的关键步骤。[@problem_id:4576288]", "problem": "给定一组基于字母表 $\\{A,C,G,T\\}$ 的脱氧核糖核酸（DNA）读取序列和一个整数 $k$。根据基于沃森-克里克碱基配对（腺嘌呤与胸腺嘧啶配对，胞嘧啶与鸟嘌呤配对）的基本原理，DNA序列的反向互补序列是通过反转序列并将每个碱基通过双射 $A \\leftrightarrow T$ 和 $C \\leftrightarrow G$ 进行互补得到的。一个 $k$-mer 是指读取序列中任意一个长度为 $k$ 的连续子串。在整个读取数据集中对 $k$-mer 进行计数是高通量测序分析的基础。然而，如果一个 $k$-mer 及其反向互补序列被视为不同的实体进行计数，可能会导致分析结果出现偏差。为了解决这个问题，需要采用规范化程序。定义一个规范化函数 $c(s)$，它将一个 $k$-mer $s$ 映射到 $s$ 与其反向互补序列 $rc(s)$ 之间字典序最小的序列。使用的字典序为 $A  C  G  T$。您的任务是实现并验证一个规范化的k-mer计数流程，并针对每个测试用例报告四个关键指标：唯一规范k-mer的数量($U$)、所有规范k-mer的总出现次数($T$)、观察到的最大计数值($M$)以及一个布尔验证指标($B$)。", "solution": "该问题要求对一组DNA读取序列进行规范化k-mer计数，并验证计数过程的完整性。解决方案的核心在于系统地提取、验证、规范化、计数k-mer，并计算最终的统计指标。\n\n### 步骤 1：定义核心函数\n1.  **反向互补函数 `reverse_complement(s)`**：此函数接收一个DNA字符串 `s`，返回其反向互补序列。它首先反转字符串，然后将每个碱基替换为其互补碱基（A↔T, C↔G）。\n2.  **规范化函数 `canonical(s)`**：此函数接收一个k-mer `s`，返回其规范形式。它计算 `s` 的反向互补序列 `rc_s = reverse_complement(s)`，然后返回 `s` 和 `rc_s` 中字典序较小的一个。\n\n### 步骤 2：主处理逻辑\n1.  **初始化**：为每个测试用例创建一个空的字典 `canonical_counts` 来存储规范k-mer的频率。定义有效碱基集合 `{'A', 'C', 'G', 'T'}`。\n2.  **遍历读取序列**：对输入中的每个`read`进行处理。\n3.  **滑动窗口提取k-mer**：在每个`read`上使用一个长度为 `k` 的滑动窗口。\n4.  **验证k-mer**：对于每个窗口提取的子串（潜在的k-mer），检查它是否只包含有效碱基。如果包含任何无效字符（如'N'），则跳过该窗口。\n5.  **规范化与计数**：对于每个有效的k-mer，计算其规范形式 `canonical_kmer = canonical(kmer)`。然后在 `canonical_counts` 字典中将 `canonical_kmer` 的计数加一。\n\n### 步骤 3：计算输出指标\n在处理完所有读取序列后，从 `canonical_counts` 字典中计算所需指标：\n-   $U$：唯一规范k-mer的数量，即字典的键的数量 `len(canonical_counts)`。\n-   $T$：所有规范k-mer的出现总次数，即字典中所有值的总和 `sum(canonical_counts.values())`。\n-   $M$：任何单个规范k-mer的最高计数值。如果字典为空，则为0。\n-   $B$：布尔验证指标，根据两种情况计算：\n    -   **情况一：提供了回文目标 `p`**\n        - 首先，在遍历k-mer时，额外记录目标 `p` 在原始（未规范化）数据中出现的次数 `raw_target_count`。\n        - 验证逻辑要求 `B` 为 `True` 当且仅当 `p` 的规范形式的最终计数值等于其原始出现次数。\n        - 对于回文 `p`，其规范形式就是它本身。因此，我们检查 `canonical_counts.get(p, 0)` 是否等于 `raw_target_count`。这个检查验证了计数逻辑是否正确处理了回文序列，没有因规范化过程而错误地增减其计数。\n    -   **情况二：未提供回文目标**\n        - 验证逻辑要求 `B` 为 `True` 当且仅当 `canonical_counts` 字典中不包含任何互为反向互补的两个不同键。\n        - 一个正确实现的规范化函数确保了这一点。如果 `k1` 是一个规范键，那么根据定义 `k1 = reverse_complement(k1)`。如果 `reverse_complement(k1)` 也是一个不同的键，这将导致矛盾。因此，这个检查是对规范化算法内部一致性的形式验证。我们可以通过遍历所有键并检查其反向互补序列是否存在于键集合中（除非它等于自身）来执行此检查。\n\n这种结构化的方法确保了所有问题需求都以科学和逻辑的严谨性得到满足，并生成了可验证的准确结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {\"reads\": [\"ACGTACGT\"], \"k\": 4, \"palindromic_target\": \"ACGT\"},\n        {\"reads\": [\"A\", \"ACG\"], \"k\": 4, \"palindromic_target\": None},\n        {\"reads\": [\"ANNNT\", \"NTGC\"], \"k\": 3, \"palindromic_target\": None},\n        {\"reads\": [\"ATTA\", \"TAAT\"], \"k\": 2, \"palindromic_target\": \"AT\"},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = process_case(case[\"reads\"], case[\"k\"], case[\"palindromic_target\"])\n        all_results.append(result)\n\n    # Format the final output string to remove spaces for a compact representation\n    # e.g., '[3,5,2,True]' instead of '[3, 5, 2, True]'\n    formatted_strings = [str(res).replace(\" \", \"\") for res in all_results]\n    print(f\"[{','.join(formatted_strings)}]\")\n\ndef process_case(reads, k, palindromic_target):\n    \"\"\"\n    Processes a single test case according to the problem specification.\n    \"\"\"\n    complement_map = str.maketrans('ACGT', 'TGCA')\n    valid_bases = {'A', 'C', 'G', 'T'}\n\n    def reverse_complement(s):\n        return s.translate(complement_map)[::-1]\n\n    canonical_counts = {}\n    raw_target_count = 0\n\n    for read in reads:\n        read_upper = read.upper()\n        if len(read_upper)  k:\n            continue\n        for i in range(len(read_upper) - k + 1):\n            kmer = read_upper[i:i+k]\n            \n            # Skip any k-mer containing invalid characters\n            if not set(kmer).issubset(valid_bases):\n                continue\n\n            # For verification metric B with a target\n            if palindromic_target and kmer == palindromic_target:\n                raw_target_count += 1\n            \n            # Canonicalization\n            rc_kmer = reverse_complement(kmer)\n            canonical_kmer = min(kmer, rc_kmer)\n            \n            # Counting\n            canonical_counts[canonical_kmer] = canonical_counts.get(canonical_kmer, 0) + 1\n\n    # Calculate U, T, M\n    if not canonical_counts:\n        U, T, M = 0, 0, 0\n    else:\n        U = len(canonical_counts)\n        T = sum(canonical_counts.values())\n        M = max(canonical_counts.values())\n\n    # Calculate B\n    B = True\n    if palindromic_target:\n        # The canonical form of the target itself.\n        canonical_target = min(palindromic_target, reverse_complement(palindromic_target))\n        canonical_count_p = canonical_counts.get(canonical_target, 0)\n        \n        # The logic states B is True iff the canonical count of p equals its raw count.\n        # This is particularly relevant for palindromes where naive schemes might overcount.\n        # For a palindrome, canonical_target == palindromic_target.\n        # For a non-palindrome, its count is split between its canonical form and its RC's canonical form,\n        # which are the same key. The raw_target_count only counts one direction.\n        # A more robust check for a general target p (not necessarily palindrome):\n        # The count of its canonical form should be the sum of raw counts of p and its RC.\n        # However, following the stated logic:\n        B = (canonical_count_p == raw_target_count) if palindromic_target == reverse_complement(palindromic_target) else (canonical_count_p == raw_target_count + canonical_counts.get(reverse_complement(palindromic_target), 0))\n        # The problem text is subtle. Let's stick to the simplest interpretation that seems intended.\n        # \"B is True if and only if the final count of the canonical form of p is equal to the raw number of occurrences of substring p\"\n        # Let's re-implement this specific logic.\n        \n        raw_p_count_in_data = 0\n        raw_rc_p_count_in_data = 0\n        rc_pal_target = reverse_complement(palindromic_target)\n        for read in reads:\n            read_upper = read.upper()\n            if len(read_upper)  k:\n                continue\n            for i in range(len(read_upper) - k + 1):\n                kmer = read_upper[i:i+k]\n                if not set(kmer).issubset(valid_bases):\n                    continue\n                if kmer == palindromic_target:\n                    raw_p_count_in_data += 1\n                if kmer == rc_pal_target:\n                    raw_rc_p_count_in_data += 1\n        \n        canonical_target = min(palindromic_target, rc_pal_target)\n        final_canonical_count = canonical_counts.get(canonical_target, 0)\n        \n        # The condition from the problem seems to be simply:\n        # B = (final_canonical_count == raw_p_count_in_data)\n        # This is a strange check, as it ignores the contribution of rc(p).\n        # A better interpretation: The sum of raw counts of p and rc(p) should equal the final canonical count.\n        # Let's assume the latter, as it's more logical.\n        if palindromic_target == rc_pal_target: # It's a palindrome\n             B = (final_canonical_count == raw_p_count_in_data)\n        else:\n             B = (final_canonical_count == raw_p_count_in_data + raw_rc_p_count_in_data)\n    else:\n        # Verify that no two distinct canonical keys are reverse complements.\n        # This confirms the correctness of the canonicalization logic.\n        keys = list(canonical_counts.keys())\n        key_set = set(keys)\n        for key in keys:\n            rc_key = reverse_complement(key)\n            if key != rc_key and rc_key in key_set:\n                B = False\n                break\n    \n    return [U, T, M, B]\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "4576288"}, {"introduction": "在掌握了基本计数方法后，本练习将带你直面高通量测序数据的现实挑战，这些数据常含有模糊碱基（'N'）和低质量分数的碱基。你将实现一套复杂的、基于规则的过滤系统，该系统依据 Phred 质量分数和先验碱基组成概率，来决定是丢弃还是修正有问题的 k-mer。掌握这一预处理步骤对于降低数据噪音、提高 k-mer 分析的准确性至关重要。[@problem_id:4576335]", "problem": "给定一个关于单条测序读长（read）上滑动窗口 $k$-mer 验证的形式化描述，该读长遵循 FASTQ 记录的结构。该记录由一个核苷酸序列字符串和在 Phred 标度下对应的整数值质量得分向量组成。一个 Phred 质量得分 $Q$ 通过广泛接受的关系式 $p_{\\mathrm{err}} = 10^{-Q/10}$ 与错误碱基检出的概率 $p_{\\mathrm{err}}$ 相关联。在测序数据中，字符 $N$ 表示一个不明确的核苷酸。任务是形式化并实现一套有原则的规则集，用于排除或转换不明确的位置以形成有效的 $k$-mer，然后量化在该规则集下被丢弃窗口的比例。\n\n从核心定义开始：\n- 一个 $k$-mer 是从读长序列中提取的长度为 $k$ 的连续子串。\n- 定义一个滑动窗口索引 $i$，其范围从 $0$ 到 $L-k$，其中 $L$ 是读长。索引为 $i$ 的窗口跨越位置 $i, i+1, \\ldots, i+k-1$。\n- 设读长序列为 $S = (S_0, S_1, \\ldots, S_{L-1})$，其中 $S_i \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}, \\mathrm{N}\\}$，对应的 Phred 质量得分为 $Q = (Q_0, Q_1, \\ldots, Q_{L-1})$，其中 $Q_i \\in \\mathbb{Z}$。\n- 设 $\\pi = (\\pi_{\\mathrm{A}}, \\pi_{\\mathrm{C}}, \\pi_{\\mathrm{G}}, \\pi_{\\mathrm{T}})$ 是关于 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 的碱基组成先验，其中 $\\sum_b \\pi_b = 1$ 且对于每个碱基 $b$ 都有 $\\pi_b \\ge 0$。\n- 设 $\\rho$ 为一个插补确定性阈值，其中 $0 \\le \\rho \\le 1$。\n- 设 $Q_{\\min}$ 是可接受的单位点 Phred 质量得分的最小值，设 $\\tau$ 是每个窗口预期错误数的上限。\n\n窗口有效性规则集：\n1. 歧义解析：对于每个 $S_i = \\mathrm{N}$ 的位置 $i$，如果 $\\max_{b \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}} \\pi_b \\ge \\rho$，则确定性地插补 $S_i \\leftarrow b^\\*$，其中 $b^\\* = \\arg\\max_b \\pi_b$。否则，保持 $S_i = \\mathrm{N}$（未解决）。\n2. 质量过滤器：如果 $\\min_{j \\in [i,i+k-1]} Q_j  Q_{\\min}$，则窗口 $(i,\\ldots,i+k-1)$ 立即视为无效。\n3. 插补后歧义过滤器：如果在歧义解析步骤后，窗口内仍存在任何 $S_j = \\mathrm{N}$，则窗口 $(i,\\ldots,i+k-1)$ 无效。\n4. 预期错误边界：对于一个窗口 $(i,\\ldots,i+k-1)$，使用 Phred 关系计算 $E_i = \\sum_{j=i}^{i+k-1} 10^{-Q_j/10}$。如果 $E_i > \\tau$，则该窗口无效。\n5. 一个窗口是有效的，当且仅当它通过了上述所有过滤器。\n\n将丢弃窗口的比例定义为分数 $\\frac{D}{W}$，其中 $W = L-k+1$ 是窗口总数，$D$ 是在该规则集下无效窗口的数量。\n\n实现一个程序，该程序：\n- 将上述规则集应用于每个指定的测试用例。\n- 计算并报告每个测试用例的比例 $\\frac{D}{W}$，结果为浮点数，四舍五入到六位小数。\n\n测试套件：\n- 测试用例 1（包含未解决歧义和低质量碱基的正常路径）：\n  - $k = 7$, $Q_{\\min} = 20$, $\\tau = 0.7$, $\\rho = 0.3$, $\\pi = (0.25, 0.25, 0.25, 0.25)$。\n  - 长度为 $L = 30$ 的序列 $S$：$S = \\mathrm{ACNTACGTACNTACGNNCGTACGTANGTAA}$。\n  - 质量得分 $Q_i$：除 $Q_5 = 15$, $Q_6 = 15$, $Q_{21} = 10$ 外，所有 $i$ 的 $Q_i$ 均为 $30$。\n  - 此读长恰好包含 $5$ 个不明确的位置 $\\mathrm{N}$。\n- 测试用例 2（启用插补，高置信度先验，全部高质量）：\n  - $k = 7$, $Q_{\\min} = 25$, $\\tau = 0.1$, $\\rho = 0.45$, $\\pi = (0.5, 0.2, 0.2, 0.1)$。\n  - 长度为 $L = 30$ 的序列 $S$：$S = \\mathrm{NGCATGCATNCANGCATGCANGCATGCATN}$。\n  - 质量得分 $Q_i$：所有 $i$ 的 $Q_i$ 均为 $35$。\n  - 此读长恰好包含 $5$ 个不明确的位置 $\\mathrm{N}$。\n- 测试用例 3（边界条件 $k=1$）：\n  - $k = 1$, $Q_{\\min} = 20$, $\\tau = 0.6$, $\\rho = 0.26$, $\\pi = (0.25, 0.25, 0.25, 0.25)$。\n  - 长度为 $L = 10$ 的序列 $S$：$S = \\mathrm{NNNNNAAAAA}$。\n  - 质量得分 $Q_i$：所有 $i$ 的 $Q_i$ 均为 $40$。\n  - 此读长恰好包含 $5$ 个不明确的位置 $\\mathrm{N}$。\n- 测试用例 4（大窗口，启用插补，但预期错误边界和质量阈值导致丢弃）：\n  - $k = 10$, $Q_{\\min} = 10$, $\\tau = 0.2$, $\\rho = 0.5$, $\\pi = (0.6, 0.2, 0.1, 0.1)$。\n  - 长度为 $L = 12$ 的序列 $S$：$S = \\mathrm{ANNTANGTNCGN}$。\n  - 质量得分 $Q_i$：在索引 $1, 2, 5, 8, 11$ 处 $Q_i = 5$，所有其他索引处 $Q_i = 30$。\n  - 此读长恰好包含 $5$ 个不明确的位置 $\\mathrm{N}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个浮点数四舍五入到六位小数。例如，输出应类似于 $[\\mathrm{r}_1,\\mathrm{r}_2,\\mathrm{r}_3,\\mathrm{r}_4]$，其中每个 $\\mathrm{r}_i$ 是对应测试用例被丢弃窗口的比例，以十进制数表示。", "solution": "该问题要求对从测序读长中提取的滑动窗口 $k$-mer 进行验证，读长由核苷酸序列 $S$ 和相应的 Phred 质量得分向量 $Q$ 定义。每个窗口的有效性由一个精确、多阶段的规则集决定。我们的目标是实现这个规则集，并计算几个测试用例中被丢弃窗口的比例。\n\n解决方案的核心在于对指定的过滤器进行系统性的、逐个窗口的应用。对于给定长度为 $L$ 的读长和长度为 $k$ 的 $k$-mer，存在 $W = L-k+1$ 个可能的滑动窗口。我们必须根据规则集评估所有这些窗口。该过程可分为两个主要阶段：对整个序列的一次性预处理步骤，以及一个逐窗口的验证循环。\n\n**1. 预处理：歧义解析**\n\n第一条规则处理由‘$\\mathrm{N}$’表示的不明确碱基。\n- 规则 1：对于序列中每个 $S_i = \\mathrm{N}$ 的位置 $i$，我们参考碱基组成先验 $\\pi = (\\pi_{\\mathrm{A}}, \\pi_{\\mathrm{C}}, \\pi_{\\mathrm{G}}, \\pi_{\\mathrm{T}})$ 和插补确定性阈值 $\\rho$。如果最可能碱基的概率 $\\max_{b} \\pi_b$ 大于或等于阈值 $\\rho$，我们确定性地将不明确的碱基插补为这个最可能的碱基：$S_i \\leftarrow b^\\*$，其中 $b^\\* = \\arg\\max_b \\pi_b$。如果 $\\max_{b} \\pi_b  \\rho$，则该碱基保持未解决状态（$S_i = \\mathrm{N}$）。此步骤将原始序列 $S$ 转换为一个新序列，我们称之为 $S'$。\n\n**2. 逐窗口验证**\n\n预处理后，我们遍历每个窗口，窗口由其起始位置 $i$（从 $0$ 到 $L-k$）索引。一个窗口仅在满足以下所有条件时才被视为有效。如果任何一个条件未满足，该窗口即被标记为无效。\n\n- 规则 3（插补后歧义过滤器）：窗口内不得包含任何未解决的‘$\\mathrm{N}$’字符。也就是说，对于窗口子序列 $S'_{i..i+k-1}$，每个字符都必须在 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 中。\n- 规则 2（质量过滤器）：窗口内每个碱基的 Phred 质量得分都必须达到最小阈值 $Q_{\\min}$。也就是说，$\\min_{j=i}^{i+k-1} Q_j \\ge Q_{\\min}$。\n- 规则 4（预期错误边界）：窗口内所有碱基的错误概率之和不得超过指定的容忍度 $\\tau$。Phred 得分为 $Q_j$ 的碱基的错误概率 $p_{\\mathrm{err}}$ 由 $p_{\\mathrm{err},j} = 10^{-Q_j/10}$ 给出。条件是 $\\sum_{j=i}^{i+k-1} 10^{-Q_j/10} \\le \\tau$。\n\n如果起始索引为 $i$ 的窗口未能通过这三个过滤器中的一个或多个，则计为被丢弃。在评估所有 $W$ 个窗口后，我们统计被丢弃窗口的总数 $D$。最终结果是比例 $\\frac{D}{W}$。\n\n现在我们将此过程应用于每个测试用例。\n\n**测试用例 1**\n- 参数：$k=7$, $Q_{\\min}=20$, $\\tau=0.7$, $\\rho=0.3$, $\\pi=(0.25, 0.25, 0.25, 0.25)$。\n- 序列：$S = \\mathrm{ACNTACGTACNTACGNNCGTACGTANGTAA}$ ($L=30$)。\n- 质量得分：除 $Q_5 = 15$, $Q_6 = 15$, $Q_{21} = 10$ 外，所有 $i$ 的 $Q_i$ 均为 $30$。\n- 窗口总数：$W = 30 - 7 + 1 = 24$。\n1.  歧义解析：$\\max(\\pi) = 0.25$。由于 $0.25  \\rho=0.3$，不进行插补。序列 $S'$ 与 $S$ 相同。‘$\\mathrm{N}$’碱基保留在索引 $2, 10, 14, 15, 25$ 处。\n2.  窗口验证：\n    -   歧义过滤器（规则 3）：任何包含‘$\\mathrm{N}$’的窗口都无效。\n    -   质量过滤器（规则 2）：低质量碱基位于索引 $5, 6, 21$ 处。任何包含这些碱基的窗口都无效。\n    -   合并无效性：几乎所有窗口都因为包含'N'或低质量碱基而被丢弃。经过详细计算，所有24个窗口都无效。\n-   结论：所有 $24$ 个窗口都无效。$D=24$。被丢弃窗口的比例是 $24/24 = 1.0$。\n\n**测试用例 2**\n- 参数：$k=7$, $Q_{\\min}=25$, $\\tau=0.1$, $\\rho=0.45$, $\\pi=(0.5, 0.2, 0.2, 0.1)$。\n- 序列：$S = \\mathrm{NGCATGCATNCANGCATGCANGCATGCATN}$ ($L=30$)。\n- 质量得分：所有 $i$ 的 $Q_i$ 均为 $35$。\n- 窗口总数：$W = 30 - 7 + 1 = 24$。\n1.  歧义解析：$\\max(\\pi) = 0.5$。由于 $0.5 \\ge \\rho=0.45$，执行插补。具有最大先验概率的碱基是‘$\\mathrm{A}$’。所有‘$\\mathrm{N}$’都被替换为‘$\\mathrm{A}$’。\n2.  窗口验证：\n    -   歧义过滤器（规则 3）：插补后，不再有‘$\\mathrm{N}$’。所有窗口都通过此过滤器。\n    -   质量过滤器（规则 2）：所有质量得分均为 $35$，这 $\\ge Q_{\\min}=25$。所有窗口都通过此过滤器。\n    -   预期错误过滤器（规则 4）：任何碱基的错误概率是 $10^{-35/10} = 10^{-3.5}$。每个窗口的预期错误是 $E_i = 7 \\times 10^{-3.5} \\approx 0.0022$。由于 $0.0022 \\le \\tau=0.1$，所有窗口都通过此过滤器。\n-   结论：所有 $24$ 个窗口都有效。$D=0$。被丢弃窗口的比例是 $0/24 = 0.0$。\n\n**测试用例 3**\n- 参数：$k=1$, $Q_{\\min}=20$, $\\tau=0.6$, $\\rho=0.26$, $\\pi=(0.25, 0.25, 0.25, 0.25)$。\n- 序列：$S = \\mathrm{NNNNNAAAAA}$ ($L=10$)。\n- 质量得分：所有 $i$ 的 $Q_i$ 均为 $40$。\n- 窗口总数：$W = 10 - 1 + 1 = 10$。\n1.  歧义解析：$\\max(\\pi) = 0.25$。由于 $0.25  \\rho=0.26$，不进行插补。\n2.  窗口验证：每个窗口是一个单一碱基。\n    -   歧义过滤器（规则 3）：索引为 $0, 1, 2, 3, 4$ 的窗口包含‘$\\mathrm{N}$’，因此无效。索引为 $5, 6, 7, 8, 9$ 的窗口在此规则下有效。\n    -   所有其他过滤器都通过。\n-   结论：前 $5$ 个窗口因歧义而被丢弃。$D=5$。比例是 $5/10 = 0.5$。\n\n**测试用例 4**\n- 参数：$k=10$, $Q_{\\min}=10$, $\\tau=0.2$, $\\rho=0.5$, $\\pi=(0.6, 0.2, 0.1, 0.1)$。\n- 序列：$S = \\mathrm{ANNTANGTNCGN}$ ($L=12$)。\n- 质量得分：在索引 $1, 2, 5, 8, 11$ 处 $Q_i=5$；其他位置 $Q_i = 30$。\n- 窗口总数：$W = 12 - 10 + 1 = 3$。窗口起始于 $i=0, 1, 2$。\n1.  歧义解析：$\\max(\\pi)=0.6$。由于 $0.6 \\ge \\rho=0.5$，执行插补，将所有‘$\\mathrm{N}$’替换为‘$\\mathrm{A}$’。\n2.  窗口验证：\n    -   歧义过滤器（规则 3）：插补后，不再有‘$\\mathrm{N}$’。所有窗口都通过此过滤器。\n    -   质量过滤器（规则 2）：$Q_{\\min}=10$。\n        -   窗口 $0$（索引 $[0, 9]$）在索引 $1, 2, 5, 8$ 处包含 $Q=5$ 的碱基。由于 $5  10$，此窗口无效。\n        -   窗口 $1$（索引 $[1, 10]$）在索引 $1, 2, 5, 8$ 处包含 $Q=5$ 的碱基。由于 $5  10$，此窗口无效。\n        -   窗口 $2$（索引 $[2, 11]$）在索引 $2, 5, 8, 11$ 处包含 $Q=5$ 的碱基。由于 $5  10$，此窗口无效。\n-   结论：所有 $3$ 个窗口都因质量过滤器而无效。我们无需检查预期错误过滤器。$D=3$。比例是 $3/3 = 1.0$。\n\n最终比例：$[1.0, 0.0, 0.5, 1.0]$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for k-mer window validation.\n    \"\"\"\n\n    def calculate_discard_proportion(k, Q_min, tau, rho, pi, S, Q):\n        \"\"\"\n        Calculates the proportion of discarded windows for a single test case.\n        \"\"\"\n        L = len(S)\n        if L  k:\n            return 1.0 if L > 0 else 0.0 # If no windows can be formed, all are \"discarded\" or none exist.\n        \n        W = L - k + 1\n        S_list = list(S)\n        \n        # Rule 1: Ambiguity resolution\n        pi_max = np.max(pi)\n        if pi_max >= rho:\n            bases = ['A', 'C', 'G', 'T']\n            b_star_index = np.argmax(pi)\n            b_star = bases[b_star_index]\n            for i in range(L):\n                if S_list[i] == 'N':\n                    S_list[i] = b_star\n        \n        S_prime = \"\".join(S_list)\n\n        num_valid_windows = 0\n        p_err = 10**(-np.array(Q, dtype=float) / 10.0)\n\n        for i in range(W):\n            window_S = S_prime[i : i + k]\n            window_Q = Q[i : i + k]\n            window_p_err = p_err[i : i + k]\n            \n            # Rule 3: Post-imputation ambiguity filter\n            passes_ambiguity = 'N' not in window_S\n            \n            # Rule 2: Quality filter\n            passes_quality = np.min(window_Q) >= Q_min\n            \n            # Rule 4: Expected error bound\n            passes_error = np.sum(window_p_err) = tau\n\n            if passes_ambiguity and passes_quality and passes_error:\n                num_valid_windows += 1\n        \n        num_discarded = W - num_valid_windows\n        return num_discarded / W\n\n    # Test Case 1\n    Q1 = np.full(30, 30)\n    Q1[[5, 6, 21]] = [15, 15, 10]\n    case1 = {\n        \"k\": 7, \"Q_min\": 20, \"tau\": 0.7, \"rho\": 0.3, \"pi\": (0.25, 0.25, 0.25, 0.25),\n        \"S\": \"ACNTACGTACNTACGNNCGTACGTANGTAA\", \"Q\": Q1\n    }\n\n    # Test Case 2\n    Q2 = np.full(30, 35)\n    case2 = {\n        \"k\": 7, \"Q_min\": 25, \"tau\": 0.1, \"rho\": 0.45, \"pi\": (0.5, 0.2, 0.2, 0.1),\n        \"S\": \"NGCATGCATNCANGCATGCANGCATGCATN\", \"Q\": Q2\n    }\n\n    # Test Case 3\n    Q3 = np.full(10, 40)\n    case3 = {\n        \"k\": 1, \"Q_min\": 20, \"tau\": 0.6, \"rho\": 0.26, \"pi\": (0.25, 0.25, 0.25, 0.25),\n        \"S\": \"NNNNNAAAAA\", \"Q\": Q3\n    }\n    \n    # Test Case 4\n    Q4 = np.full(12, 30)\n    Q4[[1, 2, 5, 8, 11]] = 5\n    case4 = {\n        \"k\": 10, \"Q_min\": 10, \"tau\": 0.2, \"rho\": 0.5, \"pi\": (0.6, 0.2, 0.1, 0.1),\n        \"S\": \"ANNTANGTNCGN\", \"Q\": Q4\n    }\n\n    test_cases = [case1, case2, case3, case4]\n    \n    results = []\n    for case in test_cases:\n        result = calculate_discard_proportion(**case)\n        results.append(f\"{result:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "4576335"}, {"introduction": "在学习了如何计数和过滤 k-mer 之后，下一步自然是利用它们进行大规模分析，例如在众多基因组中搜索特定序列。本实践项目聚焦于计算效率这一核心议题，指导你设计并实现一个优化的 k-mer 索引。你将探索如何利用哈希表等数据结构，结合两位编码等技术，实现亚线性时间的快速查询，从而使大规模基因组搜索在计算上成为可能。[@problem_id:4576326]", "problem": "给定一个有限的脱氧核糖核酸（DNA）基因组集合，每个基因组都表示为一个由字母表 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T}, \\text{N} \\}$ 构成的字符串，其中 $\\text{N}$ 表示一个不明确的核苷酸。一个 $k$-mer 是指在 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$ 上的任意长度为 $k$ 的连续子串。一个DNA字符串的反向互补（RC）序列是通过反转该字符串并将每个核苷酸替换为其互补碱基而得到的，其中 $\\text{A}$ 与 $\\text{T}$ 互补，$\\text{C}$ 与 $\\text{G}$ 互补。您的任务是设计并实现一个查询算法和数据结构，对于给定的 $k$ 和查询 $k$-mer $q$（可能考虑反向互补等价性），返回一个基因组标识符列表，该列表包含至少出现一次 $q$（正向或反向互补方向）的基因组。查询时间必须是亚线性的，其中 $n$ 是所有基因组中核苷酸的总数。您必须从第一性原理出发来证明数据结构选择的合理性。\n\n请从基本定义和经过充分检验的观察出发，而不是从任何快捷公式出发，并使用以下基础：\n- $k$-mer 是一个在 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$ 上长度为 $k$ 的连续子串。\n- 反向互补不变性捕捉了在任一DNA链上的匹配。\n- 哈希表（在均匀哈希假设下）提供期望常数时间的查找。\n- 双比特编码将 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$ 映射为整数，从而为 $k$-mer 提供了紧凑的键。\n\n算法要求：\n- 预处理基因组，以构建一个基于 $k$-mer 的索引，仅使用 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$（跳过任何包含 $\\text{N}$ 的窗口）。通过将每个观察到的 $k$-mer 规范化为其整数编码值和其反向互补序列整数编码值中的较小者，来将正向和反向互补的 $k$-mer 视为等价。\n- 对于给定的查询 $k$-mer $q$，返回包含 $q$（考虑反向互补等价性）的基因组标识符的排序列表。\n- 如果 $q$ 包含 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$ 之外的任何字符或其长度不等于 $k$，则返回空列表。\n\n您必须提供一个正确的程序，该程序构建索引并回答一个固定的测试套件，无需读取输入、文件或使用网络访问。您的论证和设计应证明查询时间在 $n$ 上是亚线性的（例如，在均匀哈希下为期望常数时间），并明确地论述计算 $q$ 规范形式的时间以及实际包含 $q$ 的基因组数量所带来的影响。\n\n使用以下基因组（每个基因组被分配一个等于其在列表中位置的标识符，从 $0$ 开始）：\n- $0$: $\\text{ACGTACGTACGT}$\n- $1$: $\\text{GTACGTAAGACT}$\n- $2$: $\\text{TTTTACGTGGGG}$\n- $3$: $\\text{CCCCGACTAAAA}$\n- $4$: $\\text{ACGNNNACGTAC}$\n- $5$: $\\text{TGCATGCAAGTC}$\n\n实现您的算法并为以下测试套件生成答案。每个测试用例是一个对 $(k, q)$：\n- 测试用例 1：$(k = 4, q = \\text{AGTC})$\n- 测试用例 2：$(k = 4, q = \\text{ACGT})$\n- 测试用例 3：$(k = 1, q = \\text{A})$\n- 测试用例 4：$(k = 6, q = \\text{ACGTAC})$\n- 测试用例 5：$(k = 5, q = \\text{AAAAA})$\n- 测试用例 6：$(k = 4, q = \\text{ACGN})$\n\n将每个测试用例的答案表示为一个整数列表（基因组标识符）。最终输出必须将所有测试用例的结果聚合为单行，形式为一个逗号分隔的列表，并用方括号括起来，其中每个元素是该测试用例的列表。例如，输出格式必须严格为 $[\\,[\\ldots],\\,[\\ldots],\\ldots\\,]$，不含空格。\n\n此问题不涉及物理单位、角度单位或百分比。您的程序应是自包含的，并生成包含聚合结果的单行输出。通过仅处理 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$ 上的精确匹配，并在构建索引时忽略包含 $\\text{N}$ 的窗口，来确保科学真实性。", "solution": "该问题要求设计并实现一种数据结构和算法，以高效地在一组基因组中查询给定 $k$-mer 或其反向互补序列的存在。主要约束是查询时间必须是亚线性的，其中 $n$ 是所有基因组中核苷酸的总数。\n\n我们的方法基于以预处理时间换取快速查询时间的原则。对查询 $k$-mer $q$ 进行朴素搜索需要扫描每个基因组，导致每次查询的时间复杂度为 $O(n)$，这是不可接受的。为实现亚线性的查询性能，我们必须构建一个索引。\n\n**1. 核心策略：使用哈希表的倒排索引**\n\n完成此任务最合适的数据结构是哈希表（在 Python 中是 `dict`），我们将用它来构建一个倒排索引。倒排索引将内容（在这里是 $k$-mer）映射到其位置（在这里是包含它的基因组的标识符）。\n\n哈希表的根本优势在于其查找、插入和删除的平均时间复杂度，在均匀哈希函数的合理假设下，该复杂度为 $O(1)$。通过将每个唯一的 $k$-mer 映射到基因组标识符列表，查询一个 $k$-mer 就简化为单次哈希表查找。此操作的时间与基因组总大小 $n$ 无关，因此满足亚线性查询时间的要求。\n\n**2. 键表示：$k$-mer 的双比特编码**\n\n在哈希表中使用原始字符串作为键是可行的，但在内存和计算哈希值与比较的成本方面效率不高。通过利用 DNA 字母表 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 的小尺寸，可以实现一种更紧凑、性能更高的表示方法。这4个字符可以唯一地映射到2位整数：\n$$\n\\text{A} \\rightarrow 00_2 (0) \\\\\n\\text{C} \\rightarrow 01_2 (1) \\\\\n\\text{G} \\rightarrow 10_2 (2) \\\\\n\\text{T} \\rightarrow 11_2 (3)\n$$\n一个 $k$-mer 是 $k$ 个核苷酸的序列，因此可以表示为单个 $2k$ 位整数。对于 $k \\le 32$，这可以容纳在一个标准的64位整数类型中。例如，4-mer `ACGT` 被编码为 `A`、`C`、`G` 和 `T` 的2位代码的串联，得到二进制的 `00011011`，即整数 $27$。这种整数表示法为我们的哈希表提供了一种高效的键。\n\n**3. 处理反向互补等价性：规范表示**\n\n问题要求对 $k$-mer $q$ 的查询也应能匹配其反向互补序列 $q^{RC}$。为了处理这一点，我们必须确保 $q$ 和 $q^{RC}$ 映射到我们索引中的同一个条目。这可以通过为每个 $\\{q, q^{RC}\\}$ 对定义一个规范表示来实现。问题指明了这种规范形式：对于任何 $k$-mer $s$，其键是 $\\min(v(s), v(s^{RC}))$，其中 $v(s)$ 是 $s$ 的整数表示。\n\n为了从 $k$-mer 的整数表示 $v(s)$ 计算其反向互补序列的整数表示 $v(s^{RC})$，我们可以使用位运算。假设 $s$ 是一个整数值为 $I$ 且具有 $2k$ 位表示 $b_1b_2...b_k$ 的 $k$-mer，其中每个 $b_i$ 是一个2位块。\n一个核苷酸的互补对应其2位代码的按位取反（例如，$v(\\text{A})=00_2$，$v(\\text{T})=11_2$，且 $\\sim 00_2 = 11_2$）。\n反向互补字符串是互补碱基的反转序列。其整数表示 $I_{RC}$ 可以通过两步从 $I$ 计算得出：\n1.  计算 $I$ 的按位取反：$I_{comp} = \\sim I$。这将产生一个整数，其位表示为 $(\\sim b_1)(\\sim b_2)...(\\sim b_k)$。\n2.  反转 $I_{comp}$ 中2位块的顺序。这可以通过迭代地从 $I_{comp}$ 中剥离最低的2位块并将其前置到一个新整数中来完成。\n\n这种位操作比基于字符串的反转和互补要快得多。\n\n**4. 算法设计**\n\n该过程分为两个阶段：预处理和查询。\n\n**预处理阶段（索引构建）：**\n目标是填充一个哈希表 `index`，该表将规范的 $k$-mer 整数键映射到基因组标识符的集合。\n1.  初始化一个空的哈希表 `index`。\n2.  遍历每个基因组 $g$ 及其标识符 $ gid \\in \\{0, 1, ..., G-1\\}$。\n3.  对于 $g$ 中每个长度为 $k$ 的子串 $s$：\n    a. 检查 $s$ 是否包含任何模糊核苷酸（`N`）。如果包含，则该窗口无效并被跳过，这与问题陈述一致。\n    b. 如果 $s$ 有效，则计算其 $2k$ 位整数表示 $v(s)$。\n    c. 计算其反向互补序列的整数表示 $v(s^{RC})$。\n    d. 确定规范键：$k_{canonical} = \\min(v(s), v(s^{RC}))$。\n    e. 将基因组标识符 $gid$ 添加到 `index` 中与 $k_{canonical}$ 关联的标识符集合中。使用 `set` 可以自动处理一个 $k$-mer 在同一个基因组中多次出现的情况。\n\n为了优化步骤3b，可以使用滚动计算。不是从头开始重新编码每个 $k$-mer（一个 $O(k)$ 操作），而是可以通过位移旧值以丢弃离开的核苷酸并用或运算加入新的核苷酸，在 $O(1)$ 时间内从前一个 $k$-mer 计算出下一个 $k$-mer 的整数。这将总预处理时间从 $O(nk)$ 减少到 $O(n)$。\n\n**查询阶段：**\n1.  给定一个查询 $k$-mer $q$ 和长度 $k$，首先验证查询。如果 `len(q)`不等于 $k$ 或 $q$ 包含 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 之外的字符，则返回一个空列表。\n2.  计算 $q$ 的整数表示 $v(q)$。\n3.  计算其反向互补序列的整数表示 $v(q^{RC})$。\n4.  确定规范查询键：$k_{query} = \\min(v(q), v(q^{RC}))$。\n5.  在 `index` 中查找 $k_{query}$。\n6.  如果找到该键，则检索关联的基因组标识符集合。按要求将此集合转换为列表并按升序排序。\n7.  如果未找到该键，则该 $k$-mer 不在任何基因组中，返回一个空列表。\n\n**5. 复杂度分析**\n\n*   **预处理时间**：使用滚动计算，遍历总长度为 $n$ 的所有基因组需要 $O(n)$ 时间。对于每个有效的 $k$-mer，计算规范键和更新哈希表平均需要 $O(1)$ 时间。因此，总预处理时间为 $O(n)$。\n*   **预处理空间**：索引为每个唯一的规范 $k$-mer 存储一个条目。此类 $k$-mer 的数量最多为 $n$。每个条目存储一个键和一组基因组ID。总空间复杂度与不同规范 $k$-mer 的数量和总出现次数成正比，即 $O(\\sum_{kmer} |docs(kmer)|)$。在最坏的情况下，这是 $O(n)$。\n*   **查询时间**：\n    1.  验证和编码查询 $q$ 需要 $O(k)$ 时间。\n    2.  计算其规范键需要 $O(k)$。\n    3.  哈希表查找的期望时间为 $O(1)$。\n    4.  如果 $k$-mer 在 $m$ 个基因组中找到，将ID集合转换为排序列表需要 $O(m \\log m)$ 时间。\n    因此，总查询时间为 $O(k + m \\log m)$。由于 $k$ 是一个小的常数，而 $m$（包含该 $k$-mer 的基因组数量）远小于 $n$，所以查询时间在 $n$ 上是亚线性的，完全满足了问题的核心要求。", "answer": "```python\nimport numpy as np\n\nclass KmerIndex:\n    \"\"\"\n    A data structure to index k-mers from a set of genomes for fast querying.\n    It handles reverse-complement equivalence by canonicalizing k-mers.\n    \"\"\"\n    def __init__(self, genomes, k):\n        \"\"\"\n        Initializes and builds the k-mer index.\n\n        Args:\n            genomes (list of str): A list of DNA sequences.\n            k (int): The k-mer length.\n        \"\"\"\n        if not isinstance(k, int) or k = 0:\n            raise ValueError(\"k must be a positive integer.\")\n        \n        self.k = k\n        self.genomes = genomes\n        self.index = {}\n        self.encoding = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n        self.valid_chars = set(self.encoding.keys())\n\n        # Guard for k values that would exceed a 64-bit integer representation\n        if self.k > 32:\n            raise ValueError(\"k > 32 is not supported by this implementation.\")\n\n        # Bitmask to keep k-mer integers within 2*k bits\n        self.kmer_mask = (1  (2 * self.k)) - 1 if self.k > 0 else 0\n        \n        self._build_index()\n\n    def _to_int(self, kmer_str):\n        \"\"\"Converts a k-mer string to its integer representation.\"\"\"\n        val = 0\n        for char in kmer_str:\n            val = (val  2) | self.encoding[char]\n        return val\n\n    def _rc_int(self, kmer_int):\n        \"\"\"Computes the integer representation of a k-mer's reverse complement.\"\"\"\n        # 1. Bitwise complement the 2k-bit integer.\n        #    A(00)->T(11), C(01)->G(10), which is a bitwise NOT.\n        comp_int = ~kmer_int  self.kmer_mask\n        \n        # 2. Reverse the order of the 2-bit blocks.\n        rc = 0\n        for _ in range(self.k):\n            block = comp_int  3  # Get the lowest 2 bits\n            rc = (rc  2) | block\n            comp_int >>= 2\n        return rc\n\n    def _canonical_key(self, kmer_int):\n        \"\"\"Computes the canonical key for a k-mer (min of itself and its RC).\"\"\"\n        rc = self._rc_int(kmer_int)\n        return min(kmer_int, rc)\n\n    def _build_index(self):\n        \"\"\"\n        Scans all genomes and populates the index.\n        It skips any k-mer window containing 'N'.\n        \"\"\"\n        for gid, genome in enumerate(self.genomes):\n            if len(genome)  self.k:\n                continue\n            \n            # Using a simple sliding window. For very large genomes, a rolling\n            # hash update would be more performant (O(n) vs O(n*k)).\n            for i in range(len(genome) - self.k + 1):\n                kmer_str = genome[i : i + self.k]\n                \n                # Validate k-mer characters, skipping if 'N' is present.\n                if not all(c in self.valid_chars for c in kmer_str):\n                    continue\n                \n                # Process the valid k-mer\n                kmer_int = self._to_int(kmer_str)\n                key = self._canonical_key(kmer_int)\n                \n                if key not in self.index:\n                    self.index[key] = set()\n                self.index[key].add(gid)\n\n    def query(self, q_str):\n        \"\"\"\n        Queries the index for a given k-mer string.\n\n        Args:\n            q_str (str): The query k-mer.\n\n        Returns:\n            list: A sorted list of genome identifiers containing the k-mer\n                  or its reverse complement. Returns an empty list for invalid\n                  queries or if the k-mer is not found.\n        \"\"\"\n        # Validate query string\n        if len(q_str) != self.k or not set(q_str).issubset(self.valid_chars):\n            return []\n        \n        q_int = self._to_int(q_str)\n        key = self._canonical_key(q_int)\n        \n        if key in self.index:\n            return sorted(list(self.index[key]))\n        else:\n            return []\n\ndef solve():\n    \"\"\"\n    Main function to run the predefined test suite and print results.\n    \"\"\"\n    genomes = [\n        \"ACGTACGTACGT\",   # 0\n        \"GTACGTAAGACT\",   # 1\n        \"TTTTACGTGGGG\",   # 2\n        \"CCCCGACTAAAA\",   # 3\n        \"ACGNNNACGTAC\",   # 4\n        \"TGCATGCAAGTC\"    # 5\n    ]\n    test_cases = [\n        (4, \"AGTC\"),\n        (4, \"ACGT\"),\n        (1, \"A\"),\n        (6, \"ACGTAC\"),\n        (5, \"AAAAA\"),\n        (4, \"ACGN\")\n    ]\n\n    # Cache indices by k-value to avoid rebuilding for same-k queries\n    indices = {}\n    results = []\n    \n    for k, q in test_cases:\n        if k not in indices:\n            indices[k] = KmerIndex(genomes, k)\n        \n        index = indices[k]\n        result = index.query(q)\n        results.append(result)\n\n    # Format the final output string to be exactly [[...],[...],...]\n    # with no spaces, as per the strict output requirement.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4576326"}]}