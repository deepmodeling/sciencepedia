{"hands_on_practices": [{"introduction": "本练习旨在从第一性原理出发，构建一个区分编码与非编码DNA序列的基础分类器。我们将利用马尔可夫模型捕捉由于密码子结构和选择压力导致在编码区中存在的序列构成偏好性。通过本练习，你将亲手实现一个基于对数似然比（LLR）分数的基因预测引擎，并学习如何根据设定的假阳性率来确定决策阈值，这是从头基因预测（*ab initio* gene prediction）中的一项核心技能。[@problem_id:4567054]", "problem": "给定被标记为编码和非编码的原核与真核生物的脱氧核糖核酸（DNA）序列训练集。目标是使用带有加性平滑的$k$阶马尔可夫模型对一个查询序列进行评分，计算编码模型与非编码模型之间的对数似然比（LLR; log-likelihood ratio）分数，并利用一个非编码序列验证集来确定一个能达到目标假阳性率（FPR; false positive rate）的决策阈值。您的程序必须仅从基本原理出发实现以下内容：分子生物学中心法则（脱氧核糖核酸到核糖核酸到蛋白质）、编码区因密码子结构和选择压力而表现出短程组成和周期性偏好的观察，以及局部依赖性可以通过核苷酸字母表上的有限阶链来近似的马尔可夫假设。基于这些基础，通过对$(k+1)$-聚体进行计数并使用加性平滑来推导条件发射概率的估计，并通过对查询序列上条件概率比值的对数求和来计算LLR。然后，利用非编码序列验证集上的分数经验分布，选择一个满足目标FPR约束的分类阈值。不要假设任何无法从所述基础推导出的公式；需在数学上证明每一步。\n\n您的程序将使用的定义和约定：\n- 字母表为 $\\mathcal{A}=\\{A,C,G,T\\}$。任何其他字符对于本问题均无效。\n- 对于一个$k$阶马尔可夫模型（$k \\in \\{0,1,2,\\dots\\}$），在给定长度为$k$的上下文$c \\in \\mathcal{A}^k$的情况下，观测到碱基$b \\in \\mathcal{A}$的条件概率，是通过在所有训练序列中对$(c,b)$的出现次数进行计数，并应用伪计数为$\\alpha \\in \\mathbb{R}_{0}$的加性平滑来估计的。\n- 对于查询序列$x=x_0 x_1 \\dots x_{n-1}$，LLR分数是从位置$i=k$到$n-1$的各项之和，其中每一项是编码模型条件概率与非编码模型条件概率之比的自然对数，两者均以$x_{i-k} \\dots x_{i-1}$为条件上下文。只有序列内部具有完整$k$长度上下文的位置才被评分。\n- 在阈值$\\theta \\in \\mathbb{R}$下，于非编码序列验证集上评估的经验FPR，定义为LLR分数大于或等于$\\theta$的非编码验证序列所占的比例。为了直接从数据中产生一个确定性的、有限的阈值，将$\\theta$限制在非编码验证序列上观察到的不同分数的集合中，并选择其中使得经验FPR小于或等于目标值的最大$\\theta^\\star$。如果因为目标值小于经验FPR中可实现的最小正增量而导致不存在这样的$\\theta$，则该测试用例是不适定的；所提供的测试套件通过其构造避免了这种情况。\n\n您的程序必须处理以下测试套件。对于每个测试用例，为确保在给定约束下的可复现性，非编码训练集也兼作阈值选择的验证集。\n\n- 测试用例1（类原核生物组成差异，1阶）：\n  - 编码训练集：$[\\text{ATGAAATTTGAA}, \\text{ATGCCCAAAGGGTTT}, \\text{ATGAAAGGGAAGTAG}]$。\n  - 非编码训练与验证集：$[\\text{TATTTAATTAAT}, \\text{GGATTTTAATTA}, \\text{TAATAATATATT}, \\text{TTAATAAATATA}]$。\n  - 查询序列：$\\text{ATGAAAGTTGA}$。\n  - 马尔可夫阶数：$k=1$。\n  - 平滑伪计数：$\\alpha=0.5$。\n  - 目标FPR：$t=0.25$。\n\n- 测试用例2（由平滑处理的未见上下文的边缘情况，2阶）：\n  - 编码训练集：$[\\text{GCGCGCGCGC}, \\text{GCCGCGCCGC}]$。\n  - 非编码训练与验证集：$[\\text{ATATATATAT}, \\text{TATATATATA}, \\text{AAATTTAAAT}]$。\n  - 查询序列：$\\text{GCGATCGCGC}$。\n  - 马尔可夫阶数：$k=2$。\n  - 平滑伪计数：$\\alpha=0.1$。\n  - 目标FPR：$t=0.3333333333333333$。\n\n- 测试用例3（作为基线的零阶模型，0阶）：\n  - 编码训练集：$[\\text{ATGGCC}, \\text{ATGGCG}, \\text{ATGGGC}, \\text{ATGGCCATG}]$。\n  - 非编码训练与验证集：$[\\text{AAAAAA}, \\text{TTTTTT}, \\text{AATTAA}, \\text{TTAAAT}]$。\n  - 查询序列：$\\text{ATGGCCG}$。\n  - 马尔可夫阶数：$k=0$。\n  - 平滑伪计数：$\\alpha=1.0$。\n  - 目标FPR：$t=0.5$。\n\n输出要求：\n- 对每个测试用例，计算：\n  - 查询序列在编码与非编码模型下的LLR分数$s \\in \\mathbb{R}$。\n  - 根据上述规定从非编码验证分数中确定的阈值$\\theta^\\star \\in \\mathbb{R}$。\n  - 一个二元决策$d \\in \\{0,1\\}$，其中如果$s \\ge \\theta^\\star$则$d=1$，否则$d=0$。\n- 在最终输出中，将所有实数值输出$s$和$\\theta^\\star$四舍五入到恰好$6$位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个元素是针对一个测试用例的三元组，格式为$[s,\\theta^\\star,d]$。例如，一个有效的整体输出结构看起来像$[[s_1,\\theta^\\star_1,d_1],[s_2,\\theta^\\star_2,d_2],[s_3,\\theta^\\star_3,d_3]]$，其中每个$s_i$和$\\theta^\\star_i$都四舍五入到$6$位小数，每个$d_i$都是一个整数。", "solution": "所提出的问题是统计生物信息学领域，特别是*de novo*基因预测领域中一个有效且适定的练习。它要求实现一个分类系统来区分编码和非编码的脱氧核糖核酸（DNA）序列。该解决方案基于分子生物学和统计建模的基本原理，我们将逐步推导并形式化这些原理。\n\n此问题的生物学基础是分子生物学中心法则，该法则描述了遗传信息从DNA流向核糖核酸（RNA）再到蛋白质的过程。DNA的蛋白质编码区（基因）使用三联体密码进行转录和翻译成蛋白质，其中称为密码子的3个核苷酸序列指定氨基酸。这个过程给编码序列带来了特定的统计模式，这些模式通常在非编码区中不存在。这些模式包括周期为3的核苷酸组成偏好和对编码相同氨基酸的某些密码子的偏好性使用（密码子使用偏好）。这些组成偏好使我们能够从统计上区分编码DNA和非编码DNA。\n\n问题建议使用一个平稳的$k$阶马尔可夫模型来捕捉这些局部的组成依赖性。一个在字母表$\\mathcal{A}=\\{A,C,G,T\\}$上的DNA序列$x=x_0 x_1 \\dots x_{n-1}$被建模为马尔可夫链的一个实现。一个$k$阶模型的核心假设是，在给定位置观察到一个核苷酸的概率仅取决于前面的$k$个核苷酸。这个长度为$k$的上下文是序列$c = x_{i-k} \\dots x_{i-1}$。在数学上，这表示为：\n$$ P(x_i | x_0 x_1 \\dots x_{i-1}) = P(x_i | x_{i-k} \\dots x_{i-1}) = P(x_i | c) $$\n对于阶数$k=0$的特殊情况，该模型是无记忆的，观察到一个核苷酸的概率与任何上下文无关：$P(x_i | c) = P(x_i)$。\n\n第一步是训练两个独立的马尔可夫模型：一个用于编码序列（$M_{cod}$），一个用于非编码序列（$M_{non}$）。训练包括为每个模型估计条件概率参数$P(b|c)$，其中$b \\in \\mathcal{A}$是一个核苷酸，$c \\in \\mathcal{A}^k$是一个上下文。我们使用提供的训练序列进行此估计。该概率通过在串联的训练数据中对$(k+1)$-聚体$cb$和$k$-聚体$c$的出现次数进行计数来估计。设$N(cb)$为$(k+1)$-聚体的计数，$N(c)$为$k$-聚体上下文的计数。为防止在有限训练集中未见过的事件概率为$0$，我们采用伪计数为$\\alpha  0$的加性（Lidstone）平滑。条件概率的平滑估计是：\n$$ P(b|c) = \\frac{N(cb) + \\alpha}{N(c) + |\\mathcal{A}|\\alpha} $$\n其中$|\\mathcal{A}|=4$是核苷酸字母表的大小。分母$N(c) + |\\mathcal{A}|\\alpha$是所有以上下文$c$开头的$(k+1)$-聚体计数的总和，每个计数都增加了伪计数$\\alpha$。注意，$N(c) = \\sum_{b' \\in \\mathcal{A}} N(cb')$。如果一个上下文$c$从未被观察到（$N(c)=0$），那么对于所有$b$，$N(cb)=0$，平滑后的概率简化为$P(b|c) = \\frac{\\alpha}{|\\mathcal{A}|\\alpha} = \\frac{1}{|\\mathcal{A}|} = 0.25$，表示对下一个核苷酸的均匀置信度。对于$k=0$，上下文为空，该公式估计碱基$b$的边际概率：\n$$ P(b) = \\frac{N(b) + \\alpha}{N_{total} + |\\mathcal{A}|\\alpha} $$\n其中$N(b)$是碱基$b$的计数，$N_{total}$是训练数据中核苷酸的总数。\n\n一旦编码模型（$P_{cod}(b|c)$）和非编码模型（$P_{non}(b|c)$）都训练好了，我们就可以对一个查询序列$x=x_0 x_1 \\dots x_{n-1}$进行评分。问题要求计算对数似然比（LLR）分数。该分数衡量了序列在两个竞争模型下的相对支持度。根据马尔可夫性质，联合概率的对数比简化为在所有从$k$到$n-1$的位置$i$上（即所有具有完整$k$长度上下文的位置）的条件概率对数比之和：\n$$ S(x) = \\sum_{i=k}^{n-1} \\log \\frac{P_{cod}(x_i | x_{i-k} \\dots x_{i-1})}{P_{non}(x_i | x_{i-k} \\dots x_{i-1})} $$\n正分数表明该序列更可能是编码序列，而负分数则表明它更可能是非编码序列。\n\n最后一步是确定用于分类的决策阈值$\\theta^\\star$。如果一个序列的分数$S(x) \\ge \\theta^\\star$，它就被分类为编码序列。选择该阈值是为了控制假阳性率（FPR），即被错误分类为编码序列的非编码序列的比例。我们使用一个非编码序列的验证集来对任何给定阈值$\\theta$的FPR进行经验估计。经验FPR是：\n$$ \\widehat{\\text{FPR}}(\\theta) = \\frac{\\text{分数} \\ge \\theta \\text{的非编码验证序列数量}}{\\text{非编码验证序列总数}} $$\n问题指定了一个确定性程序，用于从验证集上观察到的不同分数集合中选择$\\theta^\\star$。我们必须找到最大的分数$\\theta^\\star$，使得$\\widehat{\\text{FPR}}(\\theta^\\star)$小于或等于目标FPR $t$。为实现此目的，我们可以计算所有非编码验证序列的LLR分数，识别出唯一的分数，并按降序排序。然后我们遍历这个排序后的列表，第一个满足条件$\\widehat{\\text{FPR}}(\\theta) \\le t$的分数$\\theta$就是我们的最优阈值$\\theta^\\star$。\n\n完整的算法如下：\n$1$. 对于给定的测试用例及其参数$k$和$\\alpha$：\n    a. 通过编码训练集计算所有概率$P_{cod}(b|c)$，从而训练编码模型$M_{cod}$。\n    b. 通过非编码训练集计算所有概率$P_{non}(b|c)$，从而训练非编码模型$M_{non}$。\n$2$. 对于非编码验证集中的每个序列：\n    a. 使用训练好的模型计算其LLR分数。\n$3$. 通过从非编码分数集合中找到导致经验FPR不大于目标值$t$的最大分数，来确定阈值$\\theta^\\star$。\n$4$. 对于查询序列：\n    a. 计算其LLR分数$s$。\n    b. 将分数与阈值进行比较以做出决策：如果$s \\ge \\theta^\\star$，则$d=1$；否则$d=0$。\n$5$. 报告三元组$[s, \\theta^\\star, d]$，其中实数四舍五入到$6$位小数。\n\n该过程为解决指定问题提供了一个完整且有科学依据的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases for gene prediction modeling.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"coding_train\": ['ATGAAATTTGAA', 'ATGCCCAAAGGGTTT', 'ATGAAAGGGAAGTAG'],\n            \"noncoding_train\": ['TATTTAATTAAT', 'GGATTTTAATTA', 'TAATAATATATT', 'TTAATAAATATA'],\n            \"query\": 'ATGAAAGTTGA',\n            \"k\": 1,\n            \"alpha\": 0.5,\n            \"target_fpr\": 0.25,\n        },\n        {\n            \"coding_train\": ['GCGCGCGCGC', 'GCCGCGCCGC'],\n            \"noncoding_train\": ['ATATATATAT', 'TATATATATA', 'AAATTTAAAT'],\n            \"query\": 'GCGATCGCGC',\n            \"k\": 2,\n            \"alpha\": 0.1,\n            \"target_fpr\": 1/3,\n        },\n        {\n            \"coding_train\": ['ATGGCC', 'ATGGCG', 'ATGGGC', 'ATGGCCATG'],\n            \"noncoding_train\": ['AAAAAA', 'TTTTTT', 'AATTAA', 'TTAAAT'],\n            \"query\": 'ATGGCCG',\n            \"k\": 0,\n            \"alpha\": 1.0,\n            \"target_fpr\": 0.5,\n        }\n    ]\n\n    alphabet = ['A', 'C', 'G', 'T']\n    \n    def train_model(sequences, k, alpha):\n        \"\"\"\n        Trains an order-k Markov model with additive smoothing.\n\n        Args:\n            sequences (list[str]): A list of DNA training sequences.\n            k (int): The order of the Markov model.\n            alpha (float): The pseudocount for additive smoothing.\n\n        Returns:\n            dict: A dictionary representing the conditional probability table P(base|context).\n        \"\"\"\n        if k == 0:\n            # Handle the zero-order case (memoryless model)\n            counts = {base: 0 for base in alphabet}\n            total_bases = 0\n            for seq in sequences:\n                for base in seq:\n                    counts[base] += 1\n                total_bases += len(seq)\n            \n            probs = {}\n            # Context is empty for k=0\n            probs[''] = {base: (counts[base] + alpha) / (total_bases + len(alphabet) * alpha) for base in alphabet}\n            return probs\n\n        # Handle k > 0\n        kmer_counts = {} # (k+1)-mers\n        context_counts = {} # k-mers\n        \n        for seq in sequences:\n            for i in range(len(seq) - k):\n                context = seq[i:i+k]\n                kmer = seq[i:i+k+1]\n                \n                context_counts[context] = context_counts.get(context, 0) + 1\n                kmer_counts[kmer] = kmer_counts.get(kmer, 0) + 1\n        \n        # Generate all possible contexts\n        contexts = [''.join(p) for p in product(alphabet, repeat=k)]\n        \n        probs = {}\n        for context in contexts:\n            probs[context] = {}\n            n_c = context_counts.get(context, 0)\n            denominator = n_c + len(alphabet) * alpha\n            \n            for base in alphabet:\n                kmer = context + base\n                n_cb = kmer_counts.get(kmer, 0)\n                numerator = n_cb + alpha\n                probs[context][base] = numerator / denominator\n                \n        return probs\n\n    def calculate_llr(sequence, k, prob_cod, prob_non):\n        \"\"\"\n        Calculates the log-likelihood ratio (LLR) score for a query sequence.\n        \n        Args:\n            sequence (str): The query DNA sequence.\n            k (int): The order of the Markov model.\n            prob_cod (dict): The trained coding model probability table.\n            prob_non (dict): The trained noncoding model probability table.\n\n        Returns:\n            float: The LLR score.\n        \"\"\"\n        llr_score = 0.0\n        if len(sequence) = k:\n            return 0.0\n\n        for i in range(k, len(sequence)):\n            context = sequence[i-k:i] if k > 0 else ''\n            base = sequence[i]\n            \n            p_cod = prob_cod[context][base]\n            p_non = prob_non[context][base]\n            \n            llr_score += np.log(p_cod / p_non)\n            \n        return llr_score\n\n    def find_threshold(validation_sequences, k, prob_cod, prob_non, target_fpr):\n        \"\"\"\n        Determines the classification threshold based on a target FPR.\n        \n        Args:\n            validation_sequences (list[str]): A list of noncoding sequences for validation.\n            k (int): The order of the Markov model.\n            prob_cod (dict): The trained coding model.\n            prob_non (dict): The trained noncoding model.\n            target_fpr (float): The target False Positive Rate.\n        \n        Returns:\n            float: The determined threshold theta_star.\n        \"\"\"\n        scores = [calculate_llr(seq, k, prob_cod, prob_non) for seq in validation_sequences]\n        \n        unique_scores = sorted(list(set(scores)), reverse=True)\n        num_validation = len(validation_sequences)\n        \n        np_scores = np.array(scores)\n\n        for theta in unique_scores:\n            num_false_positives = np.sum(np_scores >= theta)\n            fpr = num_false_positives / num_validation\n            if fpr = target_fpr:\n                return theta\n        \n        # As per problem, a solution always exists.\n        # This case would handle if target FPR is smaller than the smallest possible step.\n        return float('inf')\n\n\n    results = []\n    for case in test_cases:\n        # 1. Train models\n        model_cod = train_model(case[\"coding_train\"], case[\"k\"], case[\"alpha\"])\n        model_non = train_model(case[\"noncoding_train\"], case[\"k\"], case[\"alpha\"])\n\n        # 2. Score query sequence\n        s = calculate_llr(case[\"query\"], case[\"k\"], model_cod, model_non)\n\n        # 3. Find threshold using noncoding sequences as validation set\n        theta_star = find_threshold(\n            case[\"noncoding_train\"], case[\"k\"], model_cod, model_non, case[\"target_fpr\"]\n        )\n\n        # 4. Make decision\n        d = 1 if s >= theta_star else 0\n        \n        results.append(f\"[{s:.6f},{theta_star:.6f},{d}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "4567054"}, {"introduction": "在真核生物中，基因预测不仅要识别编码区，还必须正确地将多个外显子拼接成一个完整的转录本。本练习将带你应用动态规划，解决从一系列带有分数的候选剪接位点中寻找最佳外显子链的经典问题。通过解决这个问题，你将掌握如何将生物学约束（如内含子长度和外显子不重叠）转化为算法模型，并体会动态规划在处理组合优化问题时的强大威力。[@problem_id:4567055]", "problem": "给定沿单一基因组坐标轴的有限候选剪接连接点集合。每个候选剪接连接点是一对位置，并关联一个实值分数。其生物学基础是，在真核生物信使核糖核酸（mRNA）加工过程中，外显子通过剪接掉内含子而连接起来，其中每个内含子由一个供体位点和一个受体位点定义。分子生物学中心法则指出，脱氧核糖核酸（DNA）转录为 mRNA，mRNA 再翻译为蛋白质。对于本问题，其形式化如下。\n\n定义与假设：\n- 一个候选连接点 $j$ 由一个供体坐标 $d_j \\in \\mathbb{Z}$、一个受体坐标 $a_j \\in \\mathbb{Z}$ 和一个实值分数 $s_j \\in \\mathbb{R}$ 表示，其中 $d_j  a_j$。\n- 连接点 $j$ 的内含子长度为 $L_j = a_j - d_j - 1$（被剪接掉的中间碱基数）。\n- 如果一个连接点 $j$ 的长度满足 $L_{\\min} \\le L_j \\le L_{\\max}$，则在闭区间边界对 $(L_{\\min}, L_{\\max}) \\in \\mathbb{Z} \\times \\mathbb{Z}$ 下，该连接点是有效的。\n- 一个链（假定的剪接模式）是一个有序的不同有效连接点索引列表 $(j_1, j_2, \\dots, j_k)$，满足对于所有 $t \\in \\{1,\\dots,k-1\\}$ 都有 $a_{j_t}  d_{j_{t+1}}$。这确保了内含子不重叠，且内含子之间的外显子长度为非负。链分数为 $\\sum_{t=1}^{k} s_{j_t}$。\n- 空链（$k=0$）的分数为 $0$。\n\n任务：\n- 对于每个提供的测试用例，计算一个使链分数最大化的链。如果多个链获得相同的最高分，则按以下顺序进行确定性的平局决胜：\n  1. 优先选择连接点数量 $k$ 较少的链。\n  2. 如果仍然平局，则优先选择按元素比较时字典序较小的 0-基索引序列。\n\n您的程序必须实现一个基于原理的动态规划解法，该解法源于基因组坐标约束所导出的偏序关系下链的最优子结构，且不依赖任何外部输入。\n\n嵌入代码中的输入（测试套件）：\n- 测试用例 1：\n  - $L_{\\min} = 20$, $L_{\\max} = 200$。\n  - 候选者（索引 $j$: $(d_j,a_j,s_j)$）：\n    - $0$: $(100,150,3.0)$\n    - $1$: $(140,210,4.0)$\n    - $2$: $(220,300,6.5)$\n    - $3$: $(305,360,2.0)$\n    - $4$: $(170,190,1.0)$\n    - $5$: $(370,430,3.5)$\n    - $6$: $(250,265,2.0)$\n- 测试用例 2：\n  - $L_{\\min} = 50$, $L_{\\max} = 70$。\n  - 候选者：\n    - $0$: $(100,151,1.0)$\n    - $1$: $(160,231,1.0)$\n    - $2$: $(232,283,2.0)$\n    - $3$: $(284,355,2.0)$\n- 测试用例 3：\n  - $L_{\\min} = 10$, $L_{\\max} = 1000$。\n  - 候选者：\n    - $0$: $(100,220,5.0)$\n    - $1$: $(150,230,6.0)$\n    - $2$: $(180,240,4.5)$\n    - $3$: $(190,250,4.0)$\n- 测试用例 4：\n  - $L_{\\min} = 10$, $L_{\\max} = 100$。\n  - 候选者：\n    - $0$: $(100,130,2.0)$\n    - $1$: $(140,170,2.0)$\n    - $2$: $(110,125,1.5)$\n    - $3$: $(126,141,1.0)$\n    - $4$: $(142,157,1.5)$\n- 测试用例 5：\n  - $L_{\\min} = 100$, $L_{\\max} = 120$。\n  - 候选者：\n    - $0$: $(10,80,1.0)$\n    - $1$: $(100,300,2.0)$\n    - $2$: $(400,450,3.0)$\n\n输出规范：\n- 对于每个测试用例，输出一个包含两个元素的列表 $[S, I]$，其中 $S$ 是可实现的最大分数（实数），$I$ 是所选候选者的 0-基索引列表，按基因组顺序递增排列。如果不存在有效的连接点或空链为最优解，则 $I$ 必须为空列表。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个元素的格式为 $[S,[i_1,i_2,\\dots,i_k]]$。例如，输出必须类似于 $[[S_1,[\\dots]],[S_2,[\\dots]],\\dots]$。\n\n算法中需遵守的约束条件：\n- 所有坐标均为整数，并且对于每个候选者都满足 $d_j  a_j$。\n- 唯一需要强制执行的约束是内含子长度边界和非重叠条件 $a_{j_t}  d_{j_{t+1}}$；不模拟任何其他生物学特征。\n- 动态规划必须根据由基因组坐标约束定义的候选者偏序关系所蕴含的最优子结构，从第一性原理出发进行设计。\n\n您的任务是实现一个程序，解决上述测试套件并打印所需的单行输出。答案必须表示为不带任何单位的原始数字，此任务中不涉及角度或百分比。", "solution": "该问题要求找到一个不重叠的剪接连接点的最优链，以最大化累积分数，并遵循特定的平局决胜规则。此问题表现出最优子结构和重叠子问题的特性，因此适合采用动态规划方法。其推导和实现如下。\n\n首先，我们对问题进行形式化。给定一个候选连接点集合 $J$。一个连接点 $j \\in J$ 由一个元组 $(d_j, a_j, s_j)$ 定义，其中 $d_j$ 和 $a_j$ 是整数坐标且 $d_j  a_j$，$s_j$ 是一个实值分数。设 $idx_j$ 为连接点 $j$ 的原始 0-基索引。\n\n解决方案分几个阶段进行：\n\n1.  **筛选**：只有当一个连接点 $j$ 的内含子长度 $L_j = a_j - d_j - 1$ 落在闭区间 $[L_{\\min}, L_{\\max}]$ 内时，该连接点才被视为有效。我们首先筛选初始候选集，只保留这些有效的连接点。如果没有有效的连接点，最优解即为空链，其分数为 $S=0$，索引列表为空 $I=[]$。\n\n2.  **排序与定义偏序关系**：构成链 $(j_1, j_2, \\dots, j_k)$ 的核心约束是，对于任何相邻的连接点对 $(j_t, j_{t+1})$，第一个连接点的受体位点必须在第二个连接点的供体位点之前，即 $a_{j_t}  d_{j_{t+1}}$。此条件在有效连接点集合上定义了一个偏序关系。为了便于动态规划求解，我们必须按照与此偏序一致的顺序处理连接点，这需要进行拓扑排序。一个标准且有效的方法是，主要按其受体坐标 $a_j$ 升序对有效连接点进行排序。如果两个连接点具有相同的受体坐标，则通过对其供体坐标 $d_j$ 进行次要排序来确保确定性的顺序。设排序后的有效连接点列表为 $v_0, v_1, \\dots, v_{m-1}$。此排序保证了对于任何连接点 $v_i$，链中的任何潜在前驱 $v_p$（其中 $a_{v_p}  d_{v_i}$）都必须满足 $a_{v_p}  a_{v_i}$，因此它将在我们的排序列表中出现在 $v_i$ 之前（即 $p  i$）。\n\n3.  **动态规划公式化**：\n    *   **最优子结构**：以连接点 $v_i$ 结尾的最优链，是通过将以某个有效前驱连接点 $v_p$（其中 $a_{v_p}  d_{v_i}$）结尾的最优链进行扩展而形成的。这样一条新链的分数是，以 $v_p$ 结尾的最优链的分数加上 $v_i$ 的分数。\n    *   **状态定义**：设 $DP[i]$ 为以连接点 $v_i$ 结尾的最优链的表示。由于平局决胜规则复杂，此状态必须包含分数之外的更多信息。我们将状态定义为一个元组：$(S_i, k_i, I_i)$，其中 $S_i$ 是以 $v_i$ 结尾的链的最大分数，$k_i$ 是该链中的连接点数量，$I_i$ 是该链中连接点的原始索引序列，按其基因组位置排序。\n    *   **递推关系**：对于排序列表中的每个连接点 $v_i$，我们计算 $DP[i]$。基本情况是仅由 $v_i$ 自身组成的链，其状态为 $(s_{v_i}, 1, [idx_{v_i}])$。然后，我们遍历所有在它之前的连接点 $v_p$（其中 $p  i$），检查它们是否能在物理上位于 $v_i$ 之前（即 $a_{v_p}  d_{v_i}$）。如果可以，我们通过将存储在 $DP[p]$ 中以 $v_p$ 结尾的最优链与 $v_i$ 连接，形成一个新的候选链。此候选链的状态将是 $(S_p + s_{v_i}, k_p + 1, I_p \\oplus [idx_{v_i}])$，其中 $\\oplus$ 表示列表连接。我们使用指定的平局决胜规则将此候选链与当前为 $v_i$ 找到的最佳链进行比较：\n        1.  主要标准：最大化分数 $S$。\n        2.  次要标准（平局决胜）：最小化连接点数量 $k$。\n        3.  第三标准（平局决胜）：优先选择字典序较小的索引序列 $I$。\n\n        该递推关系可表示为：\n        $$ DP[i] = \\max_{\\prec} \\left( (s_{v_i}, 1, [idx_{v_i}]), \\bigcup_{pi, a_{v_p}d_{v_i}} \\{ (S_p + s_{v_i}, k_p + 1, I_p \\oplus [idx_{v_i}]) \\} \\right) $$\n        其中 $\\max_{\\prec}$ 是根据上述平局决胜规则定义的广义最大化算子。\n\n4.  **最终解的提取**：全局最优链要么是以某个连接点 $v_i$ 结尾的最优链中的一条，要么是分数为 $0$ 的空链。因此，我们必须再次使用平局决胜规则，比较所有 $DP[i]$ 以及代表空链的 $(0, 0, [])$，以确定最终的全局最优解。\n\n该算法保证能找到满足所有约束条件的最优链。其时间复杂度为 $O(m^2)$，其中 $m$ 是有效连接点的数量，因为对于每个连接点，我们可能需要检查所有在它之前的连接点。由于 $m$ 通常是可控的，这是一种高效的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the gene chaining problem for a fixed set of test cases\n    using dynamic programming.\n    \"\"\"\n    test_cases = [\n        {\n            \"L_bounds\": (20, 200),\n            \"candidates\": [\n                (100, 150, 3.0), (140, 210, 4.0), (220, 300, 6.5),\n                (305, 360, 2.0), (170, 190, 1.0), (370, 430, 3.5),\n                (250, 265, 2.0)\n            ]\n        },\n        {\n            \"L_bounds\": (50, 70),\n            \"candidates\": [\n                (100, 151, 1.0), (160, 231, 1.0), (232, 283, 2.0),\n                (284, 355, 2.0)\n            ]\n        },\n        {\n            \"L_bounds\": (10, 1000),\n            \"candidates\": [\n                (100, 220, 5.0), (150, 230, 6.0), (180, 240, 4.5),\n                (190, 250, 4.0)\n            ]\n        },\n        {\n            \"L_bounds\": (10, 100),\n            \"candidates\": [\n                (100, 130, 2.0), (140, 170, 2.0), (110, 125, 1.5),\n                (126, 141, 1.0), (142, 157, 1.5)\n            ]\n        },\n        {\n            \"L_bounds\": (100, 120),\n            \"candidates\": [\n                (10, 80, 1.0), (100, 300, 2.0), (400, 450, 3.0)\n            ]\n        }\n    ]\n\n    all_results = []\n\n    def is_chain1_better(chain1, chain2):\n        \"\"\"\n        Compares two chains based on the problem's tie-breaking rules.\n        A chain is a tuple: (score, k, index_list).\n        Returns True if chain1 is better than chain2.\n        \"\"\"\n        score1, k1, indices1 = chain1\n        score2, k2, indices2 = chain2\n\n        if score1 > score2:\n            return True\n        if score1  score2:\n            return False\n        \n        # Scores are equal, prefer smaller k\n        if k1  k2:\n            return True\n        if k1 > k2:\n            return False\n\n        # Scores and k are equal, prefer lexicographically smaller index list\n        if indices1  indices2:\n            return True\n        \n        return False\n\n    for case in test_cases:\n        L_min, L_max = case[\"L_bounds\"]\n        candidates = case[\"candidates\"]\n\n        valid_junctions = []\n        for i, (d, a, s) in enumerate(candidates):\n            length = a - d - 1\n            if L_min = length = L_max:\n                valid_junctions.append({'d': d, 'a': a, 's': s, 'idx': i})\n\n        if not valid_junctions:\n            all_results.append(\"[0.0,[]]\")\n            continue\n\n        valid_junctions.sort(key=lambda j: (j['a'], j['d']))\n\n        dp_states = []\n        for i in range(len(valid_junctions)):\n            current_j = valid_junctions[i]\n            \n            # Base case: a chain of one junction\n            best_chain_for_i = (current_j['s'], 1, [current_j['idx']])\n\n            for p in range(i):\n                pred_j = valid_junctions[p]\n\n                if pred_j['a']  current_j['d']:\n                    pred_chain_score, pred_chain_k, pred_chain_indices = dp_states[p]\n                    \n                    candidate_chain = (\n                        pred_chain_score + current_j['s'],\n                        pred_chain_k + 1,\n                        pred_chain_indices + [current_j['idx']]\n                    )\n\n                    if is_chain1_better(candidate_chain, best_chain_for_i):\n                        best_chain_for_i = candidate_chain\n            \n            dp_states.append(best_chain_for_i)\n\n        # The overall best chain is the best among all ending chains and the empty chain\n        best_overall_chain = (0.0, 0, [])\n        for chain in dp_states:\n            if is_chain1_better(chain, best_overall_chain):\n                best_overall_chain = chain\n\n        final_score = best_overall_chain[0]\n        final_indices = best_overall_chain[2]\n        \n        all_results.append(f\"[{final_score},{final_indices}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "4567055"}, {"introduction": "开发出预测模型后，下一步关键是评估其性能。本练习将指导你计算和解读基因预测任务中的常用评估指标，特别是区分外显子水平和基因水平的准确性。你将通过具体案例分析，理解为何在不同生物学尺度（例如，单个外显子边界的精确度与整个基因结构的完整性）上的评估会得出不同结论，这对于客观评价和比较基因预测工具至关重要。[@problem_id:4567083]", "problem": "一个研究小组正在对一个基因预测流程进行基准测试，该流程用于一个包含真核和原核基因的混合数据集。其生物学基础是，在真核生物中，基因可能含有多个外显子，并且可变剪接会为每个基因产生多个转录本；而在原核生物中，蛋白质编码基因通常是单外显子的开放阅读框。评估在外显子层面使用精确的边界匹配，并且在基因层面，一个基因要被认为是正确预测的，需要其在转录本层面完全正确。对于外显子层面的评估，一个外显子只有在预测的外显子与真实外显子的起始和结束坐标以及链方向完全相同时，才被认为是正确预测的；部分重叠或边界偏移均被视为不正确。对于基因层面的评估，一个基因被认为是正确预测的，前提是存在至少一个预测的转录本，其外显子集合与该基因至少一个真实转录本的外显子集合完全匹配。\n\n真实数据包含$6$个基因：\n- 真核基因 $\\mathrm{E1}$，有$2$个转录本：\n  - $\\mathrm{E1}$ 转录本 $\\mathrm{T1}$ 的外显子：$[100, 200]$, $[301, 400]$, $[501, 600]$。\n  - $\\mathrm{E1}$ 转录本 $\\mathrm{T2}$ 的外显子：$[100, 200]$, $[351, 400]$, $[501, 600]$。\n- 真核基因 $\\mathrm{E2}$，有$1$个转录本：\n  - $\\mathrm{E2}$ 的外显子：$[1000, 1200]$, $[1301, 1400]$。\n- 真核基因 $\\mathrm{E3}$，有$1$个转录本：\n  - $\\mathrm{E3}$ 的外显子：$[2000, 2300]$。\n- 原核基因 $\\mathrm{P1}$，有$1$个转录本（单外显子）：\n  - $\\mathrm{P1}$ 的外显子：$[5000, 5600]$。\n- 原核基因 $\\mathrm{P2}$，有$1$个转录本（单外显子）：\n  - $\\mathrm{P2}$ 的外显子：$[5700, 6200]$。\n- 原核基因 $\\mathrm{P3}$，有$1$个转录本（单外显子）：\n  - $\\mathrm{P3}$ 的外显子：$[6300, 6700]$。\n\n该流程输出以下预测的转录本及其外显子集合：\n- 预测的转录本 $1$：外显子 $[100, 200]$, $[301, 400]$, $[501, 600]$。\n- 预测的转录本 $2$：外显子 $[1000, 1200]$, $[1301, 1405]$。\n- 预测的转录本 $3$：外显子 $[2000, 2300]$。\n- 预测的转录本 $4$：外显子 $[5000, 5600]$。\n- 预测的转录本 $5$：外显子 $[6300, 6700]$, $[6450, 6460]$。\n- 预测的转录本 $6$：外显子 $[450, 480]$。\n\n假设所有坐标表示正确链上的碱基对位置，并且外显子层面的评估是针对所有转录本中唯一的真实外显子集合进行的。遵循上述评估标准，计算该数据集的外显子层面F1分数和基因层面灵敏度（定义为基因层面召回率）。将两个指标均以小数形式表示，并四舍五入至四位有效数字。按以下顺序提供这两个值：外显子层面F1分数，基因层面灵敏度。", "solution": "该问题是有效的，它在生物信息学领域有坚实的科学基础，并提供了计算所需指标的所有必要数据和评估标准。外显子层面和基因层面正确性的定义是明确且无歧义的。\n\n任务是计算两个指标：外显子层面的F1分数和基因层面的灵敏度（召回率）。这需要在两个不同的生物组织层面上，系统地将预测实体与真实实体进行比较。\n\n首先，我们处理外显子层面的评估。此评估的标准指标是精确率、召回率以及它们的调和平均数——F1分数。\n令 $TP_{exon}$ 为真阳性外显子的数量，$FP_{exon}$ 为假阳性外显子的数量，$FN_{exon}$ 为假阴性外显子的数量。\n评估基于起始和结束坐标的精确匹配。\n外显子层面的精确率（$P_{exon}$）和召回率（$R_{exon}$）定义如下：\n$$P_{exon} = \\frac{TP_{exon}}{TP_{exon} + FP_{exon}}$$\n$$R_{exon} = \\frac{TP_{exon}}{TP_{exon} + FN_{exon}}$$\nF1分数（$F_{1,exon}$）则为：\n$$F_{1,exon} = 2 \\cdot \\frac{P_{exon} \\cdot R_{exon}}{P_{exon} + R_{exon}}$$\n\n为了计算这些值，我们必须首先确定唯一的真实外显子集合和所有预测的外显子集合。\n唯一的真实外显子集合 $S_{GT}$ 是通过收集所有真实转录本中的所有外显子并去除重复项而形成的。\n- E1-T1: $[100, 200], [301, 400], [501, 600]$\n- E1-T2: $[100, 200], [351, 400], [501, 600]$\n- E2: $[1000, 1200], [1301, 1400]$\n- E3: $[2000, 2300]$\n- P1: $[5000, 5600]$\n- P2: $[5700, 6200]$\n- P3: $[6300, 6700]$\n$S_{GT} = \\{[100, 200], [301, 400], [501, 600], [351, 400], [1000, 1200], [1301, 1400], [2000, 2300], [5000, 5600], [5700, 6200], [6300, 6700]\\}$。\n唯一的真实外显子总数为 $|S_{GT}| = 10$。这个数字代表阳性实例的总数，因此 $TP_{exon} + FN_{exon} = 10$。\n\n预测的外显子集合 $S_{P}$ 是所有预测转录本中外显子的集合。\n- 预测 1: $[100, 200], [301, 400], [501, 600]$\n- 预测 2: $[1000, 1200], [1301, 1405]$\n- 预测 3: $[2000, 2300]$\n- 预测 4: $[5000, 5600]$\n- 预测 5: $[6300, 6700], [6450, 6460]$\n- 预测 6: $[450, 480]$\n$S_{P} = \\{[100, 200], [301, 400], [501, 600], [1000, 1200], [1301, 1405], [2000, 2300], [5000, 5600], [6300, 6700], [6450, 6460], [450, 480]\\}$。\n预测的外显子总数为 $|S_{P}| = 10$。这个数字代表预测的总数，因此 $TP_{exon} + FP_{exon} = 10$。\n\n$TP_{exon}$ 是 $S_P$ 中也存在于 $S_{GT}$ 中的外显子数量。这是交集 $S_{P} \\cap S_{GT}$ 的大小。\n- $[100, 200]$ 存在于 $S_{GT}$ 中。\n- $[301, 400]$ 存在于 $S_{GT}$ 中。\n- $[501, 600]$ 存在于 $S_{GT}$ 中。\n- $[1000, 1200]$ 存在于 $S_{GT}$ 中。\n- $[1301, 1405]$ 不存在于 $S_{GT}$ 中（真实为 $[1301, 1400]$）。\n- $[2000, 2300]$ 存在于 $S_{GT}$ 中。\n- $[5000, 5600]$ 存在于 $S_{GT}$ 中。\n- $[6300, 6700]$ 存在于 $S_{GT}$ 中。\n- $[6450, 6460]$ 不存在于 $S_{GT}$ 中。\n- $[450, 480]$ 不存在于 $S_{GT}$ 中。\n计算匹配项，我们发现 $TP_{exon} = 7$。\n\n现在我们可以计算 $FP_{exon}$ 和 $FN_{exon}$。\n$FP_{exon} = |S_P| - TP_{exon} = 10 - 7 = 3$。假阳性外显子是 $\\{[1301, 1405], [6450, 6460], [450, 480]\\}$。\n$FN_{exon} = |S_{GT}| - TP_{exon} = 10 - 7 = 3$。假阴性外显子是 $S_{GT}$ 中未被预测的那些：$\\{[351, 400], [1301, 1400], [5700, 6200]\\}$。\n\n我们计算外显子层面的精确率和召回率：\n$P_{exon} = \\frac{7}{10} = 0.7$\n$R_{exon} = \\frac{7}{10} = 0.7$\n\n以及外显子层面的F1分数：\n$F_{1,exon} = 2 \\cdot \\frac{0.7 \\cdot 0.7}{0.7 + 0.7} = 2 \\cdot \\frac{0.49}{1.4} = \\frac{0.98}{1.4} = 0.7$。\n四舍五入到四位有效数字，结果是 $0.7000$。\n\n接下来，我们处理基因层面的评估。我们需要计算基因层面的灵敏度，该值定义为基因层面的召回率。\n令 $N_{genes}$ 为真实基因的总数。令 $TP_{gene}$ 为正确预测的基因数量。\n基因层面灵敏度（$S_{gene}$）由下式给出：\n$$S_{gene} = \\frac{TP_{gene}}{N_{genes}}$$\n总共有 $N_{genes} = 6$ 个真实基因。如果一个预测转录本的外显子集合与该基因至少一个真实转录本的外显子集合完全匹配，则该基因被视为正确预测。\n\n我们逐个评估每个基因：\n1.  基因 E1：有两个真实转录本，外显子集合为 $T_{E1,1} = \\{[100, 200], [301, 400], [501, 600]\\}$ 和 $T_{E1,2} = \\{[100, 200], [351, 400], [501, 600]\\}$。预测的转录本 $1$ 的外显子集合为 $\\{[100, 200], [301, 400], [501, 600]\\}$，与 $T_{E1,1}$ 完全匹配。因此，基因 E1 是一个真阳性。\n2.  基因 E2：有一个真实转录本，外显子集合为 $T_{E2} = \\{[1000, 1200], [1301, 1400]\\}$。预测的转录本 $2$ 的外显子为 $\\{[1000, 1200], [1301, 1405]\\}$。这不是一个精确匹配。没有其他预测的转录本匹配。因此，基因 E2 是一个假阴性。\n3.  基因 E3：有一个真实转录本，外显子集合为 $T_{E3} = \\{[2000, 2300]\\}$。预测的转录本 $3$ 的外显子集合为 $\\{[2000, 2300]\\}$，这是一个精确匹配。因此，基因 E3 是一个真阳性。\n4.  基因 P1：有一个真实转录本，外显子集合为 $T_{P1} = \\{[5000, 5600]\\}$。预测的转录本 $4$ 的外显子集合为 $\\{[5000, 5600]\\}$，这是一个精确匹配。因此，基因 P1 是一个真阳性。\n5.  基因 P2：有一个真实转录本，外显子集合为 $T_{P2} = \\{[5700, 6200]\\}$。没有为该基因预测的转录本。因此，基因 P2 是一个假阴性。\n6.  基因 P3：有一个真实转录本，外显子集合为 $T_{P3} = \\{[6300, 6700]\\}$。预测的转录本 $5$ 的外显子为 $\\{[6300, 6700], [6450, 6460]\\}$。这不是一个精确匹配。因此，基因 P3 是一个假阴性。\n\n正确预测的基因数量为 $TP_{gene} = 3$（E1、E3、P1）。\n基因层面的灵敏度为：\n$S_{gene} = \\frac{TP_{gene}}{N_{genes}} = \\frac{3}{6} = 0.5$。\n四舍五入到四位有效数字，结果是 $0.5000$。\n\n所需的两个值是外显子层面的F1分数（$0.7000$）和基因层面的灵敏度（$0.5000$）。", "answer": "$$\\boxed{\\begin{pmatrix} 0.7000  0.5000 \\end{pmatrix}}$$", "id": "4567083"}]}