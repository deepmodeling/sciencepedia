{"hands_on_practices": [{"introduction": "在将RNA测序读段（read）比对到基因组之前，一个至关重要的步骤是数据预处理。原始的FASTQ文件通常包含测序接头序列和低质量的碱基检出，这些噪音会严重干扰比对的准确性。本练习将指导您从零开始，亲手实现一个标准的预处理流程，包括接头切除和基于质量的滑动窗口修剪，从而为精确的下游分析奠定坚实的基础。[@problem_id:4580665]", "problem": "给定一组 FASTQ 格式的人工合成的脱氧核糖核酸（DNA）测序读段，您需要实现一个严格的预处理和质量过滤流程，该流程与下游的核糖核酸测序（RNA-seq）读段到基因组的比对直接相关。该流程必须严格按照规定实现，并应用于提供的测试套件。目标是基于经过充分检验的生物信息学原理，以纯数学和算法术语将预处理逻辑形式化。\n\n基本概念和定义：\n- Phred 质量分定义：对于每个碱基判读，Phred 分数 $Q$ 定义为 $Q = -10 \\log_{10}(p_{\\mathrm{error}})$，其中 $p_{\\mathrm{error}}$ 是该碱基判读错误的概率。Sanger FASTQ 编码（Phred+33）将质量字符 $q$ 映射到 $Q = \\mathrm{ord}(q) - 33$，其中 $\\mathrm{ord}(\\cdot)$ 是整数代码点函数。\n- 独立性假设：在许多预处理工具中使用的标准近似下，一个读段片段的期望错误数可以计算为所有保留碱基的逐碱基错误概率 $p_i = 10^{-Q_i/10}$ 的总和。\n\n需要实现的目标预处理流程：\n1. $3'$ 端接头切除：\n   - 设接头序列为一个固定字符串 $A$，读段序列为长度为 $n$ 的字符串 $S$，其质量字符为 $q_1,\\dots,q_n$。\n   - 对于重叠长度 $L$（从 $|A|$ 向下迭代到 $k_{\\min}$），计算读段后缀 $S[n-L+1,\\dots,n]$ 与接头前缀 $A[1,\\dots,L]$ 在按位置比较下的错配数。如果对于遇到的第一个这样的 $L$，错配数小于或等于 $m_{\\max}$，则从读段中精确切除最后的 $L$ 个碱基以及对应的最后 $L$ 个质量字符。如果没有找到这样的 $L$，则不进行切除。\n2. 从两端进行滑动窗口质量切除：\n   - 将每个质量字符映射到其 Phred 分数 $Q_i = \\mathrm{ord}(q_i)-33$。\n   - 左端切除规则：对于窗口大小 $w$ 和最低平均质量阈值 $Q_{\\min}$，扫描窗口 $[i,i+w-1]$（其中 $i=0,\\dots,n-w$）。识别使得算术平均值 $\\frac{1}{w}\\sum_{j=i}^{i+w-1} Q_j \\ge Q_{\\min}$ 在 $i=s$ 时成立的最小索引 $s$。将保留的起始位置设为 $s$。如果没有任何窗口满足该阈值，则舍弃该读段并输出零值。\n   - 右端切除规则：从右到左扫描窗口 $[e-w,e-1]$（其中 $e=w,\\dots,n$）。识别使得 $\\frac{1}{w}\\sum_{j=e-w}^{e-1} Q_j \\ge Q_{\\min}$ 成立的最大索引 $e$。将保留的结束位置设为 $e$。如果没有任何窗口满足该阈值，则舍弃该读段并输出零值。\n   - 保留的片段是 $S[s,\\dots,e-1]$，其质量分数为 $Q_s,\\dots,Q_{e-1}$。如果 $s \\ge e$，则舍弃该读段并输出零值。\n3. 模糊碱基和长度过滤器：\n   - 设模糊碱基的比例为 $f_N = \\frac{\\text{count of 'N' in }S[s,\\dots,e-1]}{e-s}$。如果 $f_N > f_{N,\\max}$，则舍弃该读段。\n   - 如果保留长度 $\\ell = e-s$ 严格小于最小长度 $L_{\\min}$，则舍弃该读段。\n4. 为保留的读段报告的指标：\n   - 保留长度 $\\ell$，为整数。\n   - 平均碱基质量 $\\bar{Q} = \\frac{1}{\\ell}\\sum_{i=s}^{e-1} Q_i$，四舍五入到三位小数。\n   - 期望碱基判读错误数 $E = \\sum_{i=s}^{e-1} 10^{-Q_i/10}$，四舍五入到三位小数。\n   - 通过指示符，为布尔值。如果读段被保留，则为 true；如果被任何过滤器舍弃，则为 false。\n5. 为被舍弃的读段的输出：\n   - 如果读段未通过任何过滤器，则输出四元组 $[\\ell,\\bar{Q},E,\\mathrm{pass}]$ 为 $[0,0.0,0.0,\\mathrm{false}]$。\n\n您的程序必须实现上述逻辑并处理以下测试套件。每个测试用例提供 $(S, q\\_str, A, w, Q_{\\min}, L_{\\min}, f_{N,\\max}, k_{\\min}, m_{\\max})$：\n- 测试用例 1（包含接头切除的正常路径）：\n  - $S$：字符串 \"ACGT\" 重复 $15$ 次，后跟 \"AGATCGGAAG\"。即 $S = \\text{\"ACGT\"} \\times 15 \\, \\Vert \\, \\text{\"AGATCGGAAG\"}$。\n  - $q_{str}$：字符 \"I\" 重复 $60$ 次，后跟 \"!\" 重复 $10$ 次。即 $q_{str} = \\text{\"I\"} \\times 60 \\, \\Vert \\, \\text{\"!\"} \\times 10$。\n  - $A$：\"AGATCGGAAGAGC\"。\n  - $w = 5$, $Q_{\\min} = 20$, $L_{\\min} = 30$, $f_{N,\\max} = 0.1$, $k_{\\min} = 8$, $m_{\\max} = 1$。\n- 测试用例 2（高质量但模糊碱基过多）：\n  - $S$：\"N\" 重复 $15$ 次，后跟 \"A\" 重复 $35$ 次。即 $S = \\text{\"N\"} \\times 15 \\, \\Vert \\, \\text{\"A\"} \\times 35$。\n  - $q_{str}$：\"I\" 重复 $50$ 次。即 $q_{str} = \\text{\"I\"} \\times 50$。\n  - $A$：\"AGATCGGAAGAGC\"。\n  - $w = 5$, $Q_{\\min} = 20$, $L_{\\min} = 30$, $f_{N,\\max} = 0.2$, $k_{\\min} = 8$, $m_{\\max} = 1$。\n- 测试用例 3（切除后长度不足）：\n  - $S$：字符串 \"ACGT\" 重复 $10$ 次。即 $S = \\text{\"ACGT\"} \\times 10$。\n  - $q_{str}$：\"!\" 重复 $20$ 次，后跟 \"I\" 重复 $20$ 次。即 $q_{str} = \\text{\"!\"} \\times 20 \\, \\Vert \\, \\text{\"I\"} \\times 20$。\n  - $A$：\"AGATCGGAAGAGC\"。\n  - $w = 5$, $Q_{\\min} = 25$, $L_{\\min} = 30$, $f_{N,\\max} = 0.1$, $k_{\\min} = 8$, $m_{\\max} = 0$。\n- 测试用例 4（无接头，两端质量混合，中等模糊度）：\n  - $S$：字符串 \"ACGT\" 重复 $10$ 次，后跟 \"NNNNN\"，再后跟 \"TGCA\" 重复 $5$ 次，最后是 \"ACGTA\"。即 $S = \\text{\"ACGT\"} \\times 10 \\, \\Vert \\, \\text{\"NNNNN\"} \\, \\Vert \\, \\text{\"TGCA\"} \\times 5 \\, \\Vert \\, \\text{\"ACGTA\"}$。\n  - $q_{str}$：\"!\" 重复 $3$ 次，后跟 \"I\" 重复 $64$ 次，再后跟 \"!\" 重复 $3$ 次。即 $q_{str} = \\text{\"!\"} \\times 3 \\, \\Vert \\, \\text{\"I\"} \\times 64 \\, \\Vert \\, \\text{\"!\"} \\times 3$。\n  - $A$：\"AGATCGGAAGAGC\"。\n  - $w = 4$, $Q_{\\min} = 30$, $L_{\\min} = 50$, $f_{N,\\max} = 0.1$, $k_{\\min} = 8$, $m_{\\max} = 1$。\n- 测试用例 5（$w=1$ 的边界情况，用于逐碱基阈值处理）：\n  - $S$：\"ACGTACGTACGT\"。\n  - $q_{str}$：\"A5?@B?A=A>5?\"，其中每个字符通过 Phred+33 编码进行映射。\n  - $A$：\"AGATCGGAAGAGC\"。\n  - $w = 1$, $Q_{\\min} = 30$, $L_{\\min} = 5$, $f_{N,\\max} = 0.0$, $k_{\\min} = 6$, $m_{\\max} = 0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有五个测试用例的结果，格式为方括号括起来的逗号分隔列表。每个测试用例的结果必须是 $[\\ell,\\bar{Q},E,\\mathrm{pass}]$ 形式的列表，其中 $\\ell$ 是一个整数，$\\bar{Q}$ 和 $E$ 是四舍五入到三位小数的浮点数，$\\mathrm{pass}$ 是一个布尔值。对于被舍弃的读段，输出 $[0,0.0,0.0,\\mathrm{false}]$。\n- 示例格式（非实际答案）：$[[12,35.200,0.015,\\mathrm{true}],[0,0.0,0.0,\\mathrm{false}],\\dots]$。", "solution": "问题陈述提出了一个来自生物信息学领域的、定义明确且有科学依据的任务：为 DNA 测序读段实现一个特定的序列预处理流程。该流程的组成部分——接头切除、滑动窗口质量过滤，以及基于长度和模糊碱基内容的过滤——是为下游分析（如将读段比对到参考基因组）准备原始测序数据的标准程序。所有参数、定义和算法步骤都以足够的精度进行了规定，以允许唯一且确定性的实现。因此，该问题被认为是有效的。\n\n解决方案将以分步算法过程的形式呈现，将问题陈述中描述的逻辑形式化。所有数学实体都按要求使用 LaTeX 渲染。\n\n### I. 预处理算法的形式化\n\n设单个读段由一个碱基序列 $S$ 和一个对应的质量字符字符串 $q_{str}$ 表示。设流程参数为接头序列 $A$、窗口大小 $w$、最低平均质量阈值 $Q_{\\min}$、最小保留长度 $L_{\\min}$、最大模糊碱基比例 $f_{N,\\max}$、最小接头重叠 $k_{\\min}$ 和最大错配数 $m_{\\max}$。\n\n舍弃操作的结果是输出 $[0, 0.0, 0.0, \\mathrm{false}]$。\n\n**步骤 0：初始转换**\n首先，使用 Sanger (Phred+33) 编码将输入质量字符串 $q_{str}$ 转换为一个 Phred 质量分数组 $Q_{arr}$：\n$$\n(Q_{arr})_i = \\mathrm{ord}((q_{str})_i) - 33\n$$\n其中 $\\mathrm{ord}(\\cdot)$ 是 ASCII 码点函数。设初始读段长度为 $n_0 = |S|$。\n\n**步骤 1：3' 端接头切除**\n此步骤从读段的 $3'$ 端移除接头序列。\n1.  设当前读段为 $S'$，质量字符串为 $q'_{str}$。初始时，$S' \\leftarrow S$ 且 $q'_{str} \\leftarrow q_{str}$。\n2.  从 $L_{start} = \\min(|A|, |S'|)$ 开始，将重叠长度 $L$ 向下迭代至 $k_{\\min}$。\n3.  对于每个 $L$，比较读段的长度为 $L$ 的后缀 $S'[\\text{end}-L+1 : \\text{end}]$ 与接头的长度为 $L$ 的前缀 $A[1:L]$。\n4.  设错配数为 $m$。如果 $m \\le m_{\\max}$，则认为匹配成功。由于我们是从最长可能的重叠向下迭代，因此找到的第一个匹配即为我们接受的匹配。\n5.  当找到长度为 $L$ 的匹配时，通过移除最后的 $L$ 个字符来切除读段及其质量字符串。\n    -   $S_{new} \\leftarrow S'[1 : \\text{end}-L]$\n    -   $q_{new\\_str} \\leftarrow q'_{str}[1 : \\text{end}-L]$\n    然后，此读段的该步骤终止，并使用切除后的序列进入下一步。\n6.  如果循环完成仍未找到匹配，则不切除该读段。\n\n设此步骤后的读段序列和质量数组为 $S_1$ 和 $Q_1$，长度为 $n_1 = |S_1|$。如果 $n_1  w$，则该读段无法通过滑动窗口过滤器处理，将被舍弃。\n\n**步骤 2：滑动窗口质量切除**\n此步骤从读段的两端切除低质量区域。\n1.  **左端切除（寻找起始位置 $s$）：**\n    我们从左到右扫描大小为 $w$ 的窗口。第一个平均质量达到阈值 $Q_{\\min}$ 的窗口定义了高质量区域的起点。\n    -   我们寻找最小的索引 $s \\in [0, n_1-w]$，使得：\n        $$\n        \\frac{1}{w} \\sum_{j=s}^{s+w-1} (Q_1)_j \\ge Q_{\\min}\n        $$\n    -   如果不存在这样的索引 $s$，则舍弃该读段。\n2.  **右端切除（寻找结束位置 $e$）：**\n    我们从右到左扫描大小为 $w$ 的窗口。最后一个平均质量达到阈值 $Q_{\\min}$ 的窗口定义了高质量区域的终点。\n    -   我们寻找最大的索引 $e \\in [w, n_1]$，使得结束于 $e-1$ 的窗口满足条件：\n        $$\n        \\frac{1}{w} \\sum_{j=e-w}^{e-1} (Q_1)_j \\ge Q_{\\min}\n        $$\n    -   如果不存在这样的索引 $e$，则舍弃该读段。\n3.  **最终片段：** 保留的片段由区间 $[s, e)$ 定义。新的读段为 $S_2 = S_1[s:e]$，其质量分数为 $Q_2 = Q_1[s:e]$。如果 $s \\ge e$，则结果片段为空或无效，该读段将被舍弃。\n\n**步骤 3：模糊碱基和长度过滤**\n对保留的读段 $S_2$ 进行最终检查。\n1.  **长度过滤器：**\n    保留读段的长度为 $\\ell = |S_2| = e-s$。如果 $\\ell  L_{\\min}$，则该读段过短，将被舍弃。\n2.  **模糊碱基过滤器：**\n    计算保留读段中模糊碱基（'N'）的比例 $f_N$：\n    $$\n    f_N = \\frac{\\text{count of 'N' in } S_2}{\\ell}\n    $$\n    如果 $f_N > f_{N,\\max}$，则该读段的模糊碱基过多，将被舍弃。仅在 $\\ell>0$ 时执行此检查。\n\n**步骤 4：为保留的读段计算指标**\n如果一个读段通过所有过滤器，我们对最终序列 $S_2$ 及其长度为 $\\ell$ 的质量 $Q_2$ 计算以下指标：\n1.  **保留长度：** $\\ell$。\n2.  **平均碱基质量：** 保留碱基的 Phred 分数的算术平均值。\n    $$\n    \\bar{Q} = \\frac{1}{\\ell} \\sum_{i=0}^{\\ell-1} (Q_2)_i\n    $$\n3.  **期望错误数：** 每个保留碱基的错误概率之和。质量分数为 $(Q_2)_i$ 的碱基的错误概率 $p_i$ 为 $p_i = 10^{-(Q_2)_i/10}$。\n    $$\n    E = \\sum_{i=0}^{\\ell-1} 10^{-(Q_2)_i/10}\n    $$\n4.  **通过指示符：** 一个布尔值，`true`。\n\n对于通过的读段，最终输出为 $[\\ell, \\mathrm{round}(\\bar{Q}, 3), \\mathrm{round}(E, 3), \\mathrm{true}]$。\n\n这个严格的多阶段流程确保只有高质量、具有生物学信息的序列被传递给后续的、计算密集度更高的分析。下面的实现将精确遵循此描述的逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_read(S, q_str, A, w, Q_min, L_min, f_N_max, k_min, m_max):\n    \"\"\"\n    Implements the full preprocessing pipeline for a single DNA sequencing read.\n    \"\"\"\n    \n    # --- Step 1: Adapter Trimming ---\n    s_current, q_current = S, q_str\n    \n    # Iterate from longest possible overlap down to the minimum\n    adapter_len = len(A)\n    read_len_initial = len(s_current)\n    \n    trimmed = False\n    for L in range(min(adapter_len, read_len_initial), k_min - 1, -1):\n        if L == 0: continue\n        read_suffix = s_current[read_len_initial - L:]\n        adapter_prefix = A[:L]\n        \n        mismatches = sum(1 for i in range(L) if read_suffix[i] != adapter_prefix[i])\n        \n        if mismatches = m_max:\n            s_current = s_current[:read_len_initial - L]\n            q_current = q_current[:read_len_initial - L]\n            trimmed = True\n            break\n            \n    # --- Step 2: Quality Trimming ---\n    read_len_after_adapter = len(s_current)\n    \n    if read_len_after_adapter  w:\n        return [0, 0.0, 0.0, False]\n        \n    q_scores = np.array([ord(c) - 33 for c in q_current], dtype=float)\n    \n    if read_len_after_adapter == 0:\n        return [0, 0.0, 0.0, False]\n    \n    if read_len_after_adapter == w:\n        window_avgs = np.array([np.mean(q_scores)])\n    else:\n        window_avgs = np.convolve(q_scores, np.ones(w, dtype=float), 'valid') / w\n\n    qualifying_indices = np.where(window_avgs >= Q_min)[0]\n    \n    if qualifying_indices.size == 0:\n        return [0, 0.0, 0.0, False]\n        \n    s = qualifying_indices[0]\n    # The end of the retained segment is the end of the last qualifying window.\n    # The last qualifying window starts at index `qualifying_indices[-1]`.\n    # A window starting at index `i` ends at index `i+w-1`. The slice is `[i:i+w]`.\n    e = qualifying_indices[-1] + w\n    \n    if s >= e:\n        return [0, 0.0, 0.0, False]\n\n    # Apply the trim\n    s_trimmed = s_current[s:e]\n    q_trimmed_scores = q_scores[s:e]\n    \n    # --- Step 3: Ambiguity and Length Filters ---\n    retained_len = len(s_trimmed)\n    \n    if retained_len  L_min:\n        return [0, 0.0, 0.0, False]\n        \n    n_count = s_trimmed.count('N')\n    if retained_len > 0:\n      f_N = n_count / retained_len\n      if f_N > f_N_max:\n          return [0, 0.0, 0.0, False]\n\n    # --- Step 4: Metric Calculation ---\n    ell = retained_len\n    if ell == 0: # Should be caught by s>=e, but as a safeguard\n        return [0, 0.0, 0.0, False]\n\n    q_bar = np.mean(q_trimmed_scores)\n    expected_errors = np.sum(10**(-q_trimmed_scores / 10.0))\n    passed = True\n    \n    return [ell, round(q_bar, 3), round(expected_errors, 3), passed]\n    \n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the pipeline, and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (happy path with adapter trimming)\n        (\"ACGT\" * 15 + \"AGATCGGAAG\", \"I\" * 60 + \"!\" * 10, \"AGATCGGAAGAGC\", 5, 20, 30, 0.1, 8, 1),\n        # Test case 2 (high quality but excessive ambiguity)\n        (\"N\" * 15 + \"A\" * 35, \"I\" * 50, \"AGATCGGAAGAGC\", 5, 20, 30, 0.2, 8, 1),\n        # Test case 3 (insufficient length after trimming)\n        (\"ACGT\" * 10, \"!\" * 20 + \"I\" * 20, \"AGATCGGAAGAGC\", 5, 25, 30, 0.1, 8, 0),\n        # Test case 4 (adapter absent, mixed ends, moderate ambiguity)\n        (\"ACGT\" * 10 + \"NNNNN\" + \"TGCA\" * 5 + \"ACGTA\", \"!\" * 3 + \"I\" * 64 + \"!\" * 3, \"AGATCGGAAGAGC\", 4, 30, 50, 0.1, 8, 1),\n        # Test case 5 (boundary case with w=1 for base-wise thresholding)\n        (\"ACGTACGTACGT\", \"A5?@B?A=A>5?\", \"AGATCGGAAGAGC\", 1, 30, 5, 0.0, 6, 0)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_read(*case)\n        results.append(result)\n\n    # Format the final output string as specified.\n    result_strings = []\n    for res in results:\n        l, q, E, p = res\n        if not p:\n            result_strings.append(\"[0,0.0,0.0,false]\")\n        else:\n            result_strings.append(f\"[{l},{q:.3f},{E:.3f},{str(p).lower()}]\")\n            \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n\n```", "id": "4580665"}, {"introduction": "读段比对中的模糊性是基因组学中的一个核心挑战，尤其是在处理RNA测序数据时。一个读段可能同时高分比对到功能性基因及其衍生的、通常无功能的加工假基因上，这使得确定其真实来源变得困难。本练习将引导您应用贝叶斯推断这一强大工具，学习如何正式地权衡不同类型的证据——即序列相似性（错配数）和结构特征（如剪接信号），从而以概率方式解决这种比对模糊性。[@problem_id:4580753]", "problem": "一条长度为 $L=100$ 个核苷酸的单末端核糖核酸测序（RNA-seq）读段，其每个位置的 Phred 质量分数均为 $Q=30$。考虑关于该读段在基因组中来源的两个互斥假设：$H_G$（它来源于一个已注释的蛋白质编码基因转录本）和 $H_P$（它来源于一个加工过的假基因位点）。该读段有两个候选比对：与基因位点比对时，最佳比对是跨越一个已知外显子-外显子连接点的剪接比对，在 $L$ 个比对碱基中存在 $m_G=1$ 个错配；与加工过的假基因位点比对时，最佳比对是连续的，在 $L$ 个比对碱基中存在 $m_P=0$ 个错配。\n\n使用以下基本假设，从第一性原理推导出支持基因来源假设而非假基因来源假设的后验概率 $P(H_G \\mid D)$，其中 $D$ 表示观测到的碱基检出以及存在与已注释外显子-外显子连接点一致的剪接比对：\n1. 每个碱基的测序错误是独立的，每个碱基的错误概率为 $\\epsilon_i = 10^{-Q_i/10}$。对于与参考序列匹配的碱基，发射概率为 $1-\\epsilon_i$。对于与参考序列错配的碱基，假设错误在三种不正确的核苷酸之间是均一的，其发射概率为 $\\epsilon_i/3$。\n2. 结构比对证据被建模为一个独立的观测：如果读段确实来源于基因并跨越了连接点，那么产生与注释一致的剪接比对的概率为 $\\rho_G$。如果它确实来源于加工过的假基因，那么产生这样一种剪接比对的概率为 $\\rho_P$（加工过的假基因没有内含子，所以 $\\rho_P$ 小到可以忽略不计）。\n3. 来源的先验概率对于 $H_G$ 是 $\\pi_G$，对于 $H_P$ 是 $\\pi_P$，且 $\\pi_G+\\pi_P=1$。\n\n参数值为：对于所有 $i \\in \\{1,\\dots, L\\}$，$Q_i=30$，$\\rho_G=0.9$，$\\rho_P=10^{-6}$，$\\pi_G=0.95$ 以及 $\\pi_P=0.05$。\n\n仅从这些假设出发，推导出后验概率 $P(H_G \\mid D)$ 的精确表达式，并将其计算为一个无单位的小数值。将最终数值答案四舍五入至四位有效数字。", "solution": "用户要求推导和计算一个后验概率，这需要对问题陈述进行初步验证。\n\n### 第 1 步：提取已知条件\n- 读段类型：单末端核糖核酸测序（RNA-seq）\n- 读段长度：$L=100$ 个核苷酸\n- Phred 质量分数：均一，每个位置 $Q=30$。\n- 假设 $H_G$：读段来源是一个已注释的蛋白质编码基因转录本。\n- 假设 $H_P$：读段来源是一个加工过的假基因位点。\n- 假设是互斥的。\n- 对 $H_G$ 的比对：跨越一个已知的外显子-外显子连接点的剪接比对，有 $m_G=1$ 个错配。\n- 对 $H_P$ 的比对：连续比对，有 $m_P=0$ 个错配。\n- 观测数据 $D$：观测到的碱基检出以及存在与已注释外显子-外显子连接点一致的剪接比对。\n- 假设 1（测序错误模型）：错误是独立的。每个碱基的错误概率为 $\\epsilon_i = 10^{-Q_i/10}$。匹配的发射概率为 $1-\\epsilon_i$。错配的发射概率为 $\\epsilon_i/3$。\n- 假设 2（结构比对模型）：给定 $H_G$，产生剪接比对的概率为 $\\rho_G$。给定 $H_P$，产生剪接比对的概率为 $\\rho_P$。这是一个独立的观测。\n- 假设 3（先验）：$H_G$ 的先验概率为 $\\pi_G$。$H_P$ 的先验概率为 $\\pi_P$。$\\pi_G+\\pi_P=1$。\n- 参数值：对于所有 $i$，$Q_i=30$，$L=100$，$m_G=1$，$m_P=0$，$\\rho_G=0.9$，$\\rho_P=10^{-6}$，$\\pi_G=0.95$，$\\pi_P=0.05$。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题具有科学依据，采用了生物信息学中的标准模型和概念，如 Phred 分数、用于读段比对的贝叶斯推断，以及基因与加工过的假基因之间的区别。问题的提法是适定的，提供了推导所求后验概率的唯一解所需的所有必要参数和假设。陈述是客观的，并使用了精确的术语。没有内部矛盾、缺失数据或科学上不合理的值。该问题是贝叶斯概率论在一个现实的基因组学场景中的一个非平凡应用。\n\n### 第 3 步：结论与行动\n问题是**有效的**。将提供完整的解答。\n\n### 解答推导\n目标是计算在给定观测数据 $D$ 的情况下，基因来源假设的后验概率 $P(H_G \\mid D)$。我们将使用 Bayes' 定理。\n\n根据 Bayes' 定理，后验概率为：\n$$ P(H_G \\mid D) = \\frac{P(D \\mid H_G) P(H_G)}{P(D)} $$\n分母 $P(D)$ 是观测到数据的总概率，也称为证据。由于假设 $H_G$ 和 $H_P$ 是互斥的，并且涵盖了整个模型空间（$\\pi_G + \\pi_P = 1$），我们可以使用全概率公式来表示证据：\n$$ P(D) = P(D \\mid H_G) P(H_G) + P(D \\mid H_P) P(H_P) $$\n先验概率给定为 $P(H_G) = \\pi_G$ 和 $P(H_P) = \\pi_P$。将这些代入后验概率的公式中得到：\n$$ P(H_G \\mid D) = \\frac{P(D \\mid H_G) \\pi_G}{P(D \\mid H_G) \\pi_G + P(D \\mid H_P) \\pi_P} $$\n数据 $D$ 由两个独立的部分组成：序列数据（我们将其表示为 $D_{\\text{seq}}$）和结构比对证据（我们将其表示为 $D_{\\text{struct}}$）。根据假设2，这些是独立的观测。因此，似然 $P(D \\mid H)$ 可以被分解为：\n$$ P(D \\mid H) = P(D_{\\text{seq}}, D_{\\text{struct}} \\mid H) = P(D_{\\text{seq}} \\mid H) P(D_{\\text{struct}} \\mid H) $$\n现在我们必须推导每个假设的似然项。\n\n首先，我们根据均一的 Phred 分数 $Q=30$ 计算均一的每碱基错误概率 $\\epsilon$：\n$$ \\epsilon = 10^{-Q/10} = 10^{-30/10} = 10^{-3} $$\n一次正确的碱基检出（匹配）的概率是 $1-\\epsilon$。任何特定的不正确碱基检出（错配）的概率是 $\\epsilon/3$。\n\n假设 $H_G$（基因来源）的似然：\n- 给定读段来源于一个基因，观测到剪接比对的概率为 $P(D_{\\text{struct}} \\mid H_G) = \\rho_G$。\n- 基因比对的序列数据在长度为 $L=100$ 的序列中有 $m_G=1$ 个错配和 $L-m_G = 99$ 个匹配。由于独立性假设，从基因模板生成该特定序列的概率是每个碱基发射概率的乘积：\n$$ P(D_{\\text{seq}} \\mid H_G) = (1-\\epsilon)^{L-m_G} \\left(\\frac{\\epsilon}{3}\\right)^{m_G} $$\n- 结合这些，对 $H_G$ 的总似然为：\n$$ P(D \\mid H_G) = \\rho_G (1-\\epsilon)^{L-m_G} \\left(\\frac{\\epsilon}{3}\\right)^{m_G} $$\n\n假设 $H_P$（假基因来源）的似然：\n- 从一个连续的假基因位点观测到剪接比对的概率为 $P(D_{\\text{struct}} \\mid H_P) = \\rho_P$。\n- 假基因比对的序列数据有 $m_P=0$ 个错配和 $L-m_P=100$ 个匹配。从假基因模板生成该序列的概率为：\n$$ P(D_{\\text{seq}} \\mid H_P) = (1-\\epsilon)^{L-m_P} \\left(\\frac{\\epsilon}{3}\\right)^{m_P} = (1-\\epsilon)^{L} $$\n- 结合这些，对 $H_P$ 的总似然为：\n$$ P(D \\mid H_P) = \\rho_P (1-\\epsilon)^{L} $$\n\n现在，我们将这些完整的似然表达式代回到后验概率公式中：\n$$ P(H_G \\mid D) = \\frac{\\left[\\rho_G (1-\\epsilon)^{L-m_G} \\left(\\frac{\\epsilon}{3}\\right)^{m_G}\\right] \\pi_G}{\\left[\\rho_G (1-\\epsilon)^{L-m_G} \\left(\\frac{\\epsilon}{3}\\right)^{m_G}\\right] \\pi_G + \\left[\\rho_P (1-\\epsilon)^{L}\\right] \\pi_P} $$\n我们可以通过用公因子 $(1-\\epsilon)^{L-m_G}$ 除以分子和分母来简化此表达式：\n$$ P(H_G \\mid D) = \\frac{\\rho_G \\pi_G \\left(\\frac{\\epsilon}{3}\\right)^{m_G}}{\\rho_G \\pi_G \\left(\\frac{\\epsilon}{3}\\right)^{m_G} + \\rho_P \\pi_P (1-\\epsilon)^{L - (L-m_G)}} $$\n$$ P(H_G \\mid D) = \\frac{\\rho_G \\pi_G \\left(\\frac{\\epsilon}{3}\\right)^{m_G}}{\\rho_G \\pi_G \\left(\\frac{\\epsilon}{3}\\right)^{m_G} + \\rho_P \\pi_P (1-\\epsilon)^{m_G}} $$\n这就是后验概率的最终简化解析表达式。\n\n最后，我们将给定的数值代入此表达式：\n- $\\epsilon = 10^{-3}$\n- $m_G = 1$\n- $\\rho_G = 0.9$\n- $\\pi_G = 0.95$\n- $\\rho_P = 10^{-6}$\n- $\\pi_P = 0.05$\n\n令分子为 $A$，分母中的第二项为 $B$。\n$$ A = \\rho_G \\pi_G \\left(\\frac{\\epsilon}{3}\\right)^{1} = (0.9)(0.95)\\left(\\frac{10^{-3}}{3}\\right) = (0.855)\\left(\\frac{1}{3} \\times 10^{-3}\\right) = 0.285 \\times 10^{-3} $$\n$$ B = \\rho_P \\pi_P (1-\\epsilon)^{1} = (10^{-6})(0.05)(1-10^{-3}) = (5 \\times 10^{-8})(0.999) = 4.995 \\times 10^{-8} $$\n现在，我们计算后验概率 $P(H_G \\mid D) = \\frac{A}{A+B}$：\n$$ P(H_G \\mid D) = \\frac{0.285 \\times 10^{-3}}{0.285 \\times 10^{-3} + 4.995 \\times 10^{-8}} $$\n为了计算这个值，我们可以将两个数表示为一致的格式：\n$$ P(H_G \\mid D) = \\frac{2.85 \\times 10^{-4}}{2.85 \\times 10^{-4} + 0.04995 \\times 10^{-6}} = \\frac{2.85 \\times 10^{-4}}{2.85 \\times 10^{-4} + 0.0004995 \\times 10^{-4}} $$\n$$ P(H_G \\mid D) = \\frac{2.85 \\times 10^{-4}}{2.85004995 \\times 10^{-4}} = \\frac{2.85}{2.85004995} $$\n$$ P(H_G \\mid D) \\approx 0.9999824767... $$\n将最终数值答案四舍五入至四位有效数字，我们得到 $0.9998$。", "answer": "$$\\boxed{0.9998}$$", "id": "4580753"}, {"introduction": "完成读段比对后，关键的下一步是进行质量控制，以验证测序文库的特性。其中，文库的“链特异性”（strandedness）是决定基因表达定量准确性的核心参数之一，不同的建库方法会产生不同方向的读段。本练习将向您展示如何利用比对后的汇总统计数据，通过统计模型选择来推断文库的链特异性类型，这是确保所有后续分析正确无误的关键步骤。[@problem_id:4580709]", "problem": "一位开发人员的任务是，在无法访问原始比对记录的情况下，从汇总的比对统计数据中推断RNA测序（RNA-seq）文库的链特异性和配对方向。其应用场景是将RNA测序（RNA-seq）的读段（reads）比对到一个具有已知基因注释的基因组上，这些注释包括每个基因的基因组链信息。该推断过程应被构建为一个基于概率论和分子生物学中心法则（DNA到RNA到蛋白质）的模型选择问题。简而言之，源自特定基因组链上某个基因的信使核糖核酸（mRNA）转录本会产生互补脱氧核糖核酸（cDNA）片段，其测序后的链方向取决于文库制备方案。因此，当测序读段比对到基因组上时，与某个基因重叠的读段所观察到的比对链，能够为判断文库是否具有链特异性、以及（对于双端数据）哪个配对端处于有义方向、呈现何种几何方向（正向-反向 与 反向-正向）提供信息。\n\n使用的基本定义：\n- 分子生物学中心法则断言，遗传信息从脱氧核糖核酸（DNA）流向核糖核酸（RNA），再到蛋白质。对于RNA测序（RNA-seq），互补脱氧核糖核酸（cDNA）的合成和测序产生的读段，其相对于基因链的方向取决于文库制备方案。\n- 在一个注释充分的基因组中，每个基因都有一个基因组链标签，即正链或负链。一个与基因重叠的比对读段有一个观察到的链标签，指示该读段序列与哪条DNA链相匹配。\n- 在有向文库方案下，与基因重叠的读段中，以相对于基因链的有义方向比对的比例，预计将显著不同于以反义方向比对的比例。而在无向（无链特异性）方案下，这些比例预计将大致相等。\n\n需实现的数学建模：\n- 对于单端数据，考虑有 $n$ 个读段与带注释的基因重叠，其中 $k$ 个读段以相对于基因链的有义方向比对。将每个读段视为一次伯努利试验，成功概率 $p$ 等于有义方向匹配的概率。定义三个模型：有义链特异性（$p$ 在区间 $[0.5,1]$ 内），反义链特异性（$p$ 在区间 $[0,0.5]$ 内），以及无链特异性（$p$ 固定为 $0.5$）。在每个模型的约束下使用最大似然估计，并选择最大化对数似然值最大的模型。为防止在边界概率处出现退化情况，使用一个小的正常数 $\\epsilon$ 将任何概率估计值限制在开区间 $(0,1)$ 内。\n- 对于双端数据的链特异性，考虑有 $n$ 个重叠的片段，其中将第一个配对端的链与基因的链进行比较，有 $k$ 个这样的第一配对端以相对于基因的有义方向比对。使用与上述相同的伯努利模型和模型约束，其解释为“第一链”方案对应于第一配对端为有义，“第二链”方案对应于第一配对端为反义。\n- 对于双端数据的几何方向，考虑具有正向-反向（FR）几何构型的正确配对片段计数 $f$ 和具有反向-正向（RF）几何构型的计数 $r$。将每个片段建模为一次伯努利试验，成功概率 $p$ 为FR方向的概率。定义三个模型：FR主导（$p$ 在区间 $[0.5,1]$ 内），RF主导（$p$ 在区间 $[0,0.5]$ 内），以及对称（$p$ 固定为 $0.5$）。在约束条件下使用最大似然估计，并采用相同的限制规则。\n\n决策规则：\n- 设对数似然比（LLR）为最佳约束模型的最大化对数似然与无链特异性或对称模型下的对数似然之差。使用自然对数。如果LLR超过阈值 $T$，则接受该约束模型；否则，返回对应于无链特异性/对称模型的模糊分类。使用阈值 $T = \\ln 100$，要求支持约束模型的优势比至少为 $100$ 比 $1$。\n- 在 $n=0$ 或 $f+r=0$ 的情况下，返回模糊分类。\n\n要求的输出：\n- 对于单端链特异性，返回一个整数代码：有义链特异性为 $1$，反义链特异性为 $-1$，模糊/无链特异性为 $0$。\n- 对于双端链特异性，返回一个整数代码：第一链为 $2$，第二链为 $-2$，模糊/无链特异性为 $0$。\n- 对于双端几何方向，返回一个整数代码：正向-反向（FR）为 $3$，反向-正向（RF）为 $-3$，模糊/对称 为 $0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[result1,result2,\\dots]$）。最终输出必须是如上指定的整数。所有似然计算均使用自然对数。在限制概率时，使用一个固定的小常数 $\\epsilon = 10^{-12}$。\n\n测试套件：\n- 单端链特异性案例：\n    1. $k=950$, $n=1000$。\n    2. $k=50$, $n=1000$。\n    3. $k=51$, $n=100$。\n    4. $k=0$, $n=0$。\n    5. $k=1000$, $n=1000$。\n- 双端链特异性案例（第一配对端相对于基因）：\n    6. $k=900$, $n=1000$。\n    7. $k=100$, $n=1000$。\n    8. $k=505$, $n=1000$。\n- 双端几何方向案例（FR与RF计数）：\n    9. $f=800$, $r=200$。\n    10. $f=500$, $r=500$。\n    11. $f=100$, $r=900$。\n\n您的程序必须实现上述建模和决策规则，将其应用于所有测试案例，并以要求的格式在单行中打印汇总结果。", "solution": "该问题要求实现一个统计模型选择程序，以便从汇总的读段计数数据中推断RNA测序（RNA-seq）文库的属性。解决方案基于伯努利试验框架内的最大似然估计（MLE）以及使用对数似然比（LLR）检验进行模型比较。\n\n### 通用概率与似然框架\n\n所有三个任务（单端链特异性、双端链特异性和双端几何方向）的推断核心是二项分布。我们考虑一系列 $n$ 次独立的伯努利试验，每次试验结果为“成功”（概率为 $p$）或“失败”（概率为 $1-p$）。如果我们观察到 $k$ 次成功，给定概率 $p$ 的情况下观察到此数据的似然为：\n$$ \\mathcal{L}(p | k, n) = \\binom{n}{k} p^k (1-p)^{n-k} $$\n对数似然函数在求最大值时更为方便，其形式为：\n$$ \\ell(p | k, n) = \\ln\\left(\\mathcal{L}(p | k, n)\\right) = \\ln\\binom{n}{k} + k \\ln(p) + (n-k) \\ln(1-p) $$\n当对相同的数据（$k, n$）比较对数似然时，项 $\\ln\\binom{n}{k}$ 是一个常数，可以忽略。因此，我们使用对数似然函数的核心部分：\n$$ \\ell^*(p | k, n) = k \\ln(p) + (n-k) \\ln(1-p) $$\n使 $\\ell^*(p | k, n)$ 最大化的 $p$ 的无约束最大似然估计（MLE）是成功的样本比例，即 $\\hat{p} = k/n$。\n\n### 模型定义与约束最大似然估计\n\n对于每个任务，我们通过将参数 $p$ 约束到 $[0, 1]$ 的不同子区间来评估三个竞争模型。\n\n1.  **类有义 / FR主导模型 ($M_S$):** 该模型假设成功比失败更有可能发生。参数空间被限制在 $p \\in [0.5, 1]$。在此约束下，$p$ 的最大似然估计为 $\\hat{p}_S = \\max(0.5, k/n)$。\n2.  **类反义 / RF主导模型 ($M_A$):** 该模型假设失败比成功更有可能发生。参数空间被限制在 $p \\in [0, 0.5]$。在此约束下，$p$ 的最大似然估计为 $\\hat{p}_A = \\min(0.5, k/n)$。\n3.  **无链特异性 / 对称模型 ($M_0$):** 这是零假设模型，假设对成功或失败没有偏好。参数 $p$ 固定为 $p_0 = 0.5$。\n\n为防止在 $k=0$ 或 $k=n$ 时出现 $\\ln(0)$ 的数值问题，问题要求将概率估计值限制在开区间 $(\\epsilon, 1-\\epsilon)$ 内，其中 $\\epsilon = 10^{-12}$。这意味着无约束估计值 $\\hat{p} = k/n$ 在用于对数似然计算前，被调整为 $p' = \\max(\\epsilon, \\min(\\hat{p}, 1-\\epsilon))$。\n\n### 通过对数似然比检验进行模型选择\n\n支持链特异性/有方向性模型而非无链特异性/对称模型的决策是通过对数似然比（LLR）检验作出的。\n\n零假设模型（$M_0$）的对数似然为：\n$$ \\ell_0 = \\ell^*(0.5 | k, n) = k \\ln(0.5) + (n-k) \\ln(0.5) = n \\ln(0.5) $$\n最拟合的约束模型（$M_S$ 或 $M_A$）的最大化对数似然对应于在限制后的估计值 $p'$ 处计算的无约束对数似然。这是因为似然函数是凹函数，其在 $[0, 1]$ 上的最大值出现在 $\\hat{p}=k/n$ 处。在 $[0.5, 1]$ 上的最大值将位于 $\\max(0.5, k/n)$，而在 $[0, 0.5]$ 上的最大值将位于 $\\min(0.5, k/n)$。只要 $\\hat{p} \\neq 0.5$，这两个最大化似然中较大的一个将是在 $\\hat{p}$ 处评估的值。\n因此，备择假设的最大化对数似然为：\n$$ \\ell_{MLE} = \\ell^*(p' | k, n) = k \\ln(p') + (n-k) \\ln(1-p') $$\n其中 $p' = \\max(\\epsilon, \\min(k/n, 1-\\epsilon))$。\n\nLLR是备择假设和零假设对数似然之间的差值：\n$$ LLR = \\ell_{MLE} - \\ell_0 $$\n通过将LLR与阈值 $T = \\ln(100)$ 进行比较来作出决策。\n-   如果 $LLR > T$，我们接受备择模型。具体的分类（例如，有义 vs. 反义）取决于 $\\hat{p} > 0.5$ 还是 $\\hat{p}  0.5$。\n-   如果 $LLR \\le T$，则证据不足以拒绝零假设模型，结果被分类为模糊/无链特异性。\n\n一个特殊情况是当 $n=0$（或 $f+r=0$）时，根据定义，分类是模糊的。同样，如果 $\\hat{p} = 0.5$，LLR为0，也会导致模糊分类。\n\n### 在特定推断任务中的应用\n\n通过定义 $k$、$n$ 和相应的输出代码，将上述通用过程应用于三种场景中的每一种。\n\n**1. 单端链特异性：**\n-   $n$: 与带注释基因重叠的总读段数。\n-   $k$: 以有义方向比对的读段数。\n-   $p$: 有义方向匹配的概率。\n-   输出代码：有义链特异性（1），反义链特异性（-1），模糊（0）。\n-   步骤：使用给定的 $k$ 和 $n$ 应用LLR检验。如果 $LLR > T$，当 $k/n > 0.5$ 时返回 $1$，当 $k/n  0.5$ 时返回 $-1$。否则，返回 $0$。\n\n**2. 双端链特异性：**\n-   $n$: 重叠片段总数。\n-   $k$: 以有义方向比对的第一配对端数量。\n-   $p$: 第一配对端为有义方向的概率。\n-   输出代码：第一链（2），第二链（-2），模糊（0）。\n-   步骤：应用LLR检验。如果 $LLR > T$，当 $k/n > 0.5$ 时返回 $2$（第一链），当 $k/n  0.5$ 时返回 $-2$（第二链）。否则，返回 $0$。\n\n**3. 双端几何方向：**\n-   计数以 $f$（正向-反向）和 $r$（反向-正向）的形式给出。\n-   映射到通用框架：$n = f+r$ 且 $k = f$。\n-   $p$: FR方向的概率。\n-   输出代码：FR主导（3），RF主导（-3），模糊（0）。\n-   步骤：使用 $k=f$ 和 $n=f+r$ 应用LLR检验。如果 $LLR > T$，当 $f/(f+r) > 0.5$ 时返回 $3$，当 $f/(f+r)  0.5$ 时返回 $-3$。否则，返回 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RNA-seq library inference problem for a given test suite.\n    \"\"\"\n\n    # Global constants defined in the problem statement\n    EPSILON = 1e-12\n    THRESHOLD = np.log(100)\n\n    def classify_model(k, n, code_pos, code_neg, code_amb):\n        \"\"\"\n        General classification function based on Bernoulli model selection.\n\n        Args:\n            k (int): Number of \"success\" observations.\n            n (int): Total number of observations.\n            code_pos (int): Integer code for the positive-bias model (p > 0.5).\n            code_neg (int): Integer code for the negative-bias model (p  0.5).\n            code_amb (int): Integer code for the ambiguous/null model (p = 0.5).\n\n        Returns:\n            int: The integer code representing the selected model.\n        \"\"\"\n        # Handle degenerate case where there are no observations.\n        if n == 0:\n            return code_amb\n\n        # Calculate the unconstrained Maximum Likelihood Estimate (MLE) for p.\n        p_hat = k / n\n\n        # If p_hat is exactly 0.5, the LLR is 0, so the result is ambiguous.\n        if p_hat == 0.5:\n            return code_amb\n\n        # Clamp the probability estimate to avoid log(0)\n        p_clamped = np.clip(p_hat, EPSILON, 1.0 - EPSILON)\n\n        # Calculate the log-likelihood for the best constrained model (alternative hypothesis).\n        # This corresponds to the log-likelihood at the unconstrained (but clamped) MLE.\n        log_likelihood_mle = k * np.log(p_clamped) + (n - k) * np.log(1.0 - p_clamped)\n\n        # Calculate the log-likelihood for the unstranded/symmetric model (null hypothesis).\n        log_likelihood_null = n * np.log(0.5)\n\n        # Calculate the Log-Likelihood Ratio (LLR).\n        llr = log_likelihood_mle - log_likelihood_null\n\n        # Apply the decision rule based on the threshold.\n        if llr > THRESHOLD:\n            if p_hat > 0.5:\n                return code_pos\n            else: # p_hat  0.5\n                return code_neg\n        else:\n            return code_amb\n\n    # Test suite provided in the problem statement.\n    # Each tuple represents a test case with its specific parameters.\n    # Format: (type, k, n) or (type, f, r)\n    test_cases = [\n        # Single-end strandedness cases (type=1)\n        (1, 950, 1000),      # Case 1\n        (1, 50, 1000),       # Case 2\n        (1, 51, 100),        # Case 3\n        (1, 0, 0),           # Case 4\n        (1, 1000, 1000),     # Case 5\n        # Paired-end strandedness cases (type=2)\n        (2, 900, 1000),      # Case 6\n        (2, 100, 1000),      # Case 7\n        (2, 505, 1000),      # Case 8\n        # Paired-end geometric orientation cases (type=3)\n        (3, 800, 200),       # Case 9\n        (3, 500, 500),       # Case 10\n        (3, 100, 900),       # Case 11\n    ]\n\n    results = []\n    for case in test_cases:\n        case_type = case[0]\n        \n        if case_type == 1:  # Single-end strandedness\n            k, n = case[1], case[2]\n            result = classify_model(k, n, code_pos=1, code_neg=-1, code_amb=0)\n        elif case_type == 2:  # Paired-end strandedness\n            k, n = case[1], case[2]\n            result = classify_model(k, n, code_pos=2, code_neg=-2, code_amb=0)\n        elif case_type == 3:  # Paired-end geometric orientation\n            f, r = case[1], case[2]\n            k = f\n            n = f + r\n            result = classify_model(k, n, code_pos=3, code_neg=-3, code_amb=0)\n        \n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4580709"}]}