{"hands_on_practices": [{"introduction": "FM-index 是现代快速比对算法的基石。本练习将引导您亲手实践其核心机制——后向搜索算法，该算法能够高效地找到一个读长的所有出现位置。通过这个实践，您将巩固对 Burrows-Wheeler 变换（BWT）、$C$ 表和 $\\mathrm{Occ}$ 表如何协同工作的理解，从而揭示快速精确匹配的奥秘。[@problem_id:4603992]", "problem": "一个用于短序列的精确读段比对器使用了构建在带有唯一哨兵字符的 DNA 参考文本上的 Ferragina–Manzini 索引 (FM-index)。考虑一个参考字符串 $G = \\text{ACGTACGT}\\$，其中哨兵符号为 $\\$$，并且其字典序最小。字母表顺序为 $\\$  \\text{A}  \\text{C}  \\text{G}  \\text{T}$。一个基于 $G$ 的 FM-index 可用，并包含以下组成部分：\n- Burrows–Wheeler 变换 (BWT) 字符串为 $\\text{TT\\$AACCGG}$。\n- 数组 $C$，对于每个字符 $c$，给出 $G$ 中字典序小于 $c$ 的字符总数，其值为：$C(\\$)=0$，$C(\\text{A})=1$，$C(\\text{C})=3$，$C(\\text{G})=5$，$C(\\text{T})=7$。\n- 对于 $c \\in \\{\\$, \\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 和整数 $i$（$0 \\le i \\le n$，其中 $n$ 是 $G$ 的长度），定义 $\\mathrm{Occ}(c,i)$ 为字符 $c$ 在长度为 $i$ 的 BWT 前缀（位置 $1$ 到 $i$）中出现的次数，并约定 $\\mathrm{Occ}(c,0)=0$。\n\n假设短读段为 $R=\\text{ACGT}$。仅从 FM-index 的核心定义、后对前（Last–First）性质以及 $C$ 和 $\\mathrm{Occ}$ 的含义出发，对 $R$ 执行完整的反向搜索，以确定最终的后缀数组区间 $[l,r]$，该区间对应所有其前缀与 $R$ 完全匹配的后缀数组位置。然后，陈述在一个使用精确 FM-index 匹配的比对器强制执行多重匹配上限 $M$ 的情况下，会从该区间报告匹配结果的原则性条件，其中仅当精确匹配总数 $k$ 满足 $1 \\le k \\le M$ 时才会报告。\n\n当 $M = 3$ 时，报告的精确匹配总数是多少？请以单个整数形式提供答案。无需四舍五入，也无需报告单位。", "solution": "该问题要求使用给定的 Ferragina–Manzini 索引 (FM-index) 对一个短读段执行反向搜索，然后根据一个多重匹配上限确定报告的匹配数。该过程涉及两个主要阶段：验证问题组成部分的有效性和执行搜索算法。\n\n首先，确立问题陈述的有效性。提供的组成部分是：参考字符串 $G = \\text{ACGTACGT}\\$$，字母表顺序 $\\$  \\text{A}  \\text{C}  \\text{G}  \\text{T}$，Burrows–Wheeler 变换 (BWT) 字符串 $\\text{TT\\$AACCGG}$，以及 C 数组：$C(\\$)=0$，$C(\\text{A})=1$，$C(\\text{C})=3$，$C(\\text{G})=5$，$C(\\text{T})=7$。参考字符串的长度为 $n=9$。我们可以验证所给的 BWT 字符串和 C 数组对于给定的参考字符串 $G$ 确实是正确的，这证实了问题数据的内部一致性。该问题具有科学依据，提法得当，客观，并包含了所有必要信息。因此，它是有效的。\n\n解决方案的核心是反向搜索算法，该算法通过反向迭代模式 $R$ 的字符来查找其所有出现。对于每个字符，它都会更新一个后缀数组 (SA) 区间 $[l, r]$，该区间包含了参考文本中所有以前缀为当前已处理模式部分的后缀。更新依赖于后对前 (LF) 映射性质，具体由以下公式体现：\n$$l_{new} = C(c) + \\mathrm{Occ}(c, l_{old} - 1) + 1$$\n$$r_{new} = C(c) + \\mathrm{Occ}(c, r_{old})$$\n此处，$c$ 是前置到搜索模式的字符，$[l_{old}, r_{old}]$ 是上一步的 SA 区间，$C(c)$ 是 $G$ 中字典序小于 $c$ 的字符数，而 $\\mathrm{Occ}(c, i)$ 是字符 $c$ 在长度为 $i$ 的 BWT 字符串前缀（即 $\\text{BWT}[1 \\dots i]$）中出现的次数。搜索从完整的 SA 范围 $[1, n]$ 开始。\n\n待比对的短读段是 $R=\\text{ACGT}$。搜索反向进行，按 $\\text{T}$、$\\text{G}$、$\\text{C}$、$\\text{A}$ 的顺序处理字符。BWT 字符串是 $B = \\text{TT\\$AACCGG}$，其长度为 $n=9$。初始区间为 $[l, r] = [1, 9]$。\n\n**步骤 1：搜索读段的最后一个字符，$c = \\text{T}$。**\n初始区间为 $[l_0, r_0] = [1, 9]$。我们针对 $c = \\text{T}$ 更新它。\n$l_1 = C(\\text{T}) + \\mathrm{Occ}(\\text{T}, l_0 - 1) + 1 = C(\\text{T}) + \\mathrm{Occ}(\\text{T}, 0) + 1$。\n$r_1 = C(\\text{T}) + \\mathrm{Occ}(\\text{T}, r_0) = C(\\text{T}) + \\mathrm{Occ}(\\text{T}, 9)$。\n根据问题给出的条件，$C(\\text{T}) = 7$。根据定义，$\\mathrm{Occ}(\\text{T}, 0) = 0$。通过在 $B = \\text{TT\\$AACCGG}$ 中计数，$\\text{T}$ 在整个 BWT 字符串中出现的次数为 $\\mathrm{Occ}(\\text{T}, 9) = 2$。\n$l_1 = 7 + 0 + 1 = 8$。\n$r_1 = 7 + 2 = 9$。\n以 $\\text{T}$ 开头的后缀的 SA 区间是 $[8, 9]$。\n\n**步骤 2：前置下一个字符 $c = \\text{G}$，搜索 $\\text{GT}$。**\n当前区间为 $[l_1, r_1] = [8, 9]$。我们针对 $c = \\text{G}$ 更新它。\n$l_2 = C(\\text{G}) + \\mathrm{Occ}(\\text{G}, l_1 - 1) + 1 = C(\\text{G}) + \\mathrm{Occ}(\\text{G}, 7) + 1$。\n$r_2 = C(\\text{G}) + \\mathrm{Occ}(\\text{G}, r_1) = C(\\text{G}) + \\mathrm{Occ}(\\text{G}, 9)$。\n已知 $C(\\text{G}) = 5$。我们计算 $\\text{G}$ 在 $B = \\text{TT\\$AACCGG}$ 的前缀中出现的次数：\n应用于 $B[1 \\dots 7] = \\text{TT\\$AACC}$ 的 $\\mathrm{Occ}(\\text{G}, 7)$ 为 $0$。\n应用于 $B[1 \\dots 9] = \\text{TT\\$AACCGG}$ 的 $\\mathrm{Occ}(\\text{G}, 9)$ 为 $2$。\n$l_2 = 5 + 0 + 1 = 6$。\n$r_2 = 5 + 2 = 7$。\n以 $\\text{GT}$ 开头的后缀的 SA 区间是 $[6, 7]$。\n\n**步骤 3：前置下一个字符 $c = \\text{C}$，搜索 $\\text{CGT}$。**\n当前区间为 $[l_2, r_2] = [6, 7]$。我们针对 $c = \\text{C}$ 更新它。\n$l_3 = C(\\text{C}) + \\mathrm{Occ}(\\text{C}, l_2 - 1) + 1 = C(\\text{C}) + \\mathrm{Occ}(\\text{C}, 5) + 1$。\n$r_3 = C(\\text{C}) + \\mathrm{Occ}(\\text{C}, r_2) = C(\\text{C}) + \\mathrm{Occ}(\\text{C}, 7)$。\n已知 $C(\\text{C}) = 3$。我们计算 $\\text{C}$ 在 $B$ 的前缀中出现的次数：\n应用于 $B[1 \\dots 5] = \\text{TT\\$AA}$ 的 $\\mathrm{Occ}(\\text{C}, 5)$ 为 $0$。\n应用于 $B[1 \\dots 7] = \\text{TT\\$AACC}$ 的 $\\mathrm{Occ}(\\text{C}, 7)$ 为 $2$。\n$l_3 = 3 + 0 + 1 = 4$。\n$r_3 = 3 + 2 = 5$。\n以 $\\text{CGT}$ 开头的后缀的 SA 区间是 $[4, 5]$。\n\n**步骤 4：前置第一个字符 $c = \\text{A}$，搜索 $\\text{ACGT}$。**\n当前区间为 $[l_3, r_3] = [4, 5]$。我们针对 $c = \\text{A}$ 更新它。\n$l_4 = C(\\text{A}) + \\mathrm{Occ}(\\text{A}, l_3 - 1) + 1 = C(\\text{A}) + \\mathrm{Occ}(\\text{A}, 3) + 1$。\n$r_4 = C(\\text{A}) + \\mathrm{Occ}(\\text{A}, r_3) = C(\\text{A}) + \\mathrm{Occ}(\\text{A}, 5)$。\n已知 $C(\\text{A}) = 1$。我们计算 $\\text{A}$ 在 $B$ 的前缀中出现的次数：\n应用于 $B[1 \\dots 3] = \\text{TT\\$}$ 的 $\\mathrm{Occ}(\\text{A}, 3)$ 为 $0$。\n应用于 $B[1 \\dots 5] = \\text{TT\\$AA}$ 的 $\\mathrm{Occ}(\\text{A}, 5)$ 为 $2$。\n$l_4 = 1 + 0 + 1 = 2$。\n$r_4 = 1 + 2 = 3$。\n对于读段 $\\text{ACGT}$，最终的 SA 区间是 $[l, r] = [2, 3]$。\n\n精确匹配的数量 $k$ 是这个最终区间的大小。\n$$k = r - l + 1 = 3 - 2 + 1 = 2$$\n这意味着读段 $\\text{ACGT}$ 在参考基因组 $G$ 中作为子串恰好出现 $2$ 次。\n\n问题陈述，一个带有有多重匹配上限 $M$ 的比对器仅在精确匹配总数 $k$ 满足条件 $1 \\le k \\le M$ 时报告匹配结果。如果满足此条件，则报告所有 $k$ 个匹配结果。如果 $k=0$（无匹配）或 $k > M$（匹配过多），则不报告任何结果。\n\n我们已知多重匹配上限为 $M = 3$。我们发现精确匹配的数量为 $k = 2$。我们必须检查是否满足报告条件：\n$$1 \\le k \\le M \\implies 1 \\le 2 \\le 3$$\n该不等式成立。因此，比对器报告这些匹配结果。报告的精确匹配总数等于 $k$。\n\n因此，报告的精确匹配总数为 $2$。", "answer": "$$\\boxed{2}$$", "id": "4603992"}, {"introduction": "找到潜在的比对位置后，我们必须评估读长与参考序列的匹配优劣。本练习探讨了比对打分的精妙之处，特别是在处理插入和删除（indels）时，仿射缺口罚分模型如何正确处理这些常见的变异和测序错误来源，尤其是在如均聚物（homopolymer）这般具有挑战性的区域。这个实践将展示为何一个更复杂的打分模型优于简单的模型。[@problem_id:4603915]", "problem": "考虑一个新一代测序中典型的短读长比对场景，在该场景中，一个读长必须使用带仿射空位罚分模型的动态规划比对方法，与一个参考基因组片段进行比对。从以下基本依据出发：序列比对得分是匹配的奖励与错配和空位的罚分之和，而仿射空位罚分将长度为 $L$ 的空位分解为一个空位开放罚分加上 $L$ 个空位延伸罚分。将插入-缺失（indel）模型定义为在均聚物区域内，读长相对于参考序列发生的一次性缺失事件，这是几种测序技术中一种真实的错误模式。\n\n一个比对软件通过一个精确种子序列将读长锚定到参考序列上，然后在不立即开启空位的情况下跨越均聚物区域延伸比对。设参考序列片段为 5'-CGA TTTTTTTTT ACG-3'，含有 $10$ 个连续的胸腺嘧啶核苷酸；读长为 5'-CGA TTTTTT ACG-3'，含有 $7$ 个连续的胸腺嘧啶核苷酸，因此该读长在均聚物区域内有一个长度为 $L = 3$ 的单次缺失。假设侧翼上下文 \"CGA\" 和 \"ACG\" 在读长和参考序列中是相同的。\n\n在整个延伸过程中使用以下仿射计分方案：一次匹配贡献 $+\\alpha$（$\\alpha = 2$），一次错配贡献 $-\\delta$（$\\delta = 3$），开启一个空位产生 $-\\gamma$ 的罚分（$\\gamma = 4$），每个空位延伸产生 $-\\lambda$ 的罚分（$\\lambda = 1$）。动态规划延伸根据两种策略进行操作：\n\n- 策略 A（在均聚物上强制无空位）：延伸过程中不在均聚物区域内开启空位。由于读长在均聚物区域短了 $L=3$ 个碱基，比对在离开该区域时会发生 $L$ 个位置的偏移，导致边界处的接下来 $L$ 个比对位置在重新同步前发生错配，此后所有后续位置均为匹配。\n\n- 策略 B（在均聚物内使用仿射空位）：延伸过程在均聚物区域内开启一个长度为 $L = 3$ 的单次缺失空位，然后继续进行匹配。\n\n假设在两种策略中，紧邻的均聚物边界之外的所有位置都以匹配方式比对，且种子序列和末端上下文保持完美匹配，因此策略 A 和策略 B 之间的唯一得分差异源于如何处理该单次 indel。\n\n根据上述基本依据和定义，推导策略 A 和策略 B 的比对得分，然后计算策略 B 相对于策略 A 的数值分数提升，定义为策略 B 的得分减去策略 A 的得分。请以单个实数形式提供您的最终答案。无需四舍五入。", "solution": "该问题陈述清晰，具有科学依据，并提供了推导唯一解所需的所有信息。我们首先分析两种指定比对策略的得分计算。\n\n问题陈述指出，策略 A 和策略 B 之间的得分差异仅源于对均聚物区域内 indel 及其紧邻边界的处理方式。完美匹配的侧翼上下文 `CGA` 和 `ACG` 对两种策略的得分贡献相同，在计算差值时将被抵消。因此，我们只需要计算分歧区域的比对得分。\n\n参考序列包含一个由 $10$ 个胸腺嘧啶核苷酸组成的均聚物，而读长包含 $7$ 个。这对应于读长相对于参考序列存在一个长度为 $L = 10 - 7 = 3$ 的缺失。\n\n计分参数如下：\n- 匹配得分：$+\\alpha = +2$\n- 错配罚分：$-\\delta = -3$\n- 空位开放罚分：$-\\gamma = -4$\n- 空位延伸罚分：$-\\lambda = -1$\n\n**策略 A：强制无空位比对**\n\n在此策略中，不引入空位。读长的 $7$ 个胸腺嘧啶与参考序列均聚物区域的前 $7$ 个胸腺嘧啶进行比对。根据问题描述，这会强制比对发生移位，使得“边界处的接下来 $L$ 个比对位置发生错配”。当 $L=3$ 时，这意味着读长的 `ACG` 上下文与参考序列均聚物区域中剩余的 $3$ 个胸腺嘧啶进行比对。\n\n相关区域的比对如下：\n- 首先，来自读长的 $7$ 个胸腺嘧啶与来自参考序列的 $7$ 个胸腺嘧啶比对，产生 $7$ 次匹配。\n- 接着，来自读长的后续 $3$ 个碱基（`A`、`C`、`G`）与参考序列均聚物区域的最后 $3$ 个胸腺嘧啶（`T`、`T`、`T`）比对，产生 $3$ 次错配。\n\n策略 A 的得分，记为 $S_A$，是这些部分得分的总和：\n$$S_A = 7 \\times \\alpha + L \\times (-\\delta)$$\n代入给定值 $L=3$，$\\alpha=2$ 和 $\\delta=3$：\n$$S_A = 7(2) + 3(-3) = 14 - 9 = 5$$\n\n**策略 B：仿射空位比对**\n\n在此策略中，在读长中开启一个长度为 $L=3$ 的单次缺失空位，以解释缺失的碱基。均聚物区域的比对如下：\n- 读长的 $7$ 个胸腺嘧啶与参考序列的前 $7$ 个胸腺嘧啶比对，产生 $7$ 次匹配。\n- 参考序列均聚物中剩余的 $3$ 个胸腺嘧啶与读长中的一个空位比对。这构成了一个长度为 $L=3$ 的单次空位事件。\n\n策略 B 的得分，记为 $S_B$，是匹配得分和仿射空位罚分之和。长度为 $L$ 的空位的仿射空位罚分为 $(-\\gamma) + L \\times (-\\lambda)$。\n$$S_B = 7 \\times \\alpha + (-\\gamma) + L \\times (-\\lambda)$$\n代入给定值 $L=3$，$\\alpha=2$，$\\gamma=4$ 和 $\\lambda=1$：\n$$S_B = 7(2) + (-4) + 3(-1) = 14 - 4 - 3 = 7$$\n\n**策略 B 相对于策略 A 的得分提升**\n\n得分提升定义为策略 B 的得分减去策略 A 的得分。\n$$\\text{得分提升} = S_B - S_A$$\n使用计算出的得分：\n$$\\text{得分提升} = 7 - 5 = 2$$\n\n或者，我们可以以符号形式计算差值：\n$$S_B - S_A = (7\\alpha - \\gamma - L\\lambda) - (7\\alpha - L\\delta)$$\n$$S_B - S_A = 7\\alpha - \\gamma - L\\lambda - 7\\alpha + L\\delta$$\n$$S_B - S_A = L\\delta - \\gamma - L\\lambda$$\n代入数值 $L=3$，$\\delta=3$，$\\gamma=4$ 和 $\\lambda=1$：\n$$S_B - S_A = 3(3) - 4 - 3(1) = 9 - 4 - 3 = 2$$\n两种方法得出相同的结果。与为避免空位而强制错配（策略 A）相比，使用显式的仿射空位罚分（策略 B）会产生更高（更好）的比对得分。", "answer": "$$\\boxed{2}$$", "id": "4603915"}, {"introduction": "一个高的比对分数并不保证比对的正确性，特别是当一个读长可能合理地来源于多个基因组位置时。本练习深入探讨了映射质量（Mapping Quality, MAPQ）的概率基础，这是下游分析中一个至关重要的指标。通过从比对分数推导 MAPQ，本实践将阐明比对质量和映射置信度之间的关键区别。[@problem_id:4603952]", "problem": "一个长度为 $L=75$ 个核苷酸的短脱氧核糖核酸 (DNA) 测序读段被一个比对软件比对到参考基因组上。该比对软件使用一个基于自然对数的逐位对数似然比 (LLR) 模型对候选比对进行评分。对于每个位置 $i$，令 $b_i \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 为参考碱基，$x_i$ 为观测到的读段碱基。假设存在以下经过充分检验的概率性碱基发射模型：\n- 在比对正确的假设下，每个位置的碱基识别错误率为 $\\,\\epsilon\\,$，且各位置之间相互独立。因此 $\\Pr(x_i=b_i \\mid \\text{correct})=1-\\epsilon$ 且 $\\Pr(x_i \\neq b_i \\mid \\text{correct})=\\epsilon$。采用对称错误模型，将错误概率 $\\epsilon$ 平均分配给三个不正确的核苷酸，因此 $\\Pr(x_i=a \\neq b_i \\mid \\text{correct})=\\epsilon/3$。\n- 在比对不正确的假设下，观测到的碱基与 $b_i$ 无关，并遵循均匀背景分布 $\\Pr(x_i=\\mathrm{A})=\\Pr(x_i=\\mathrm{C})=\\Pr(x_i=\\mathrm{G})=\\Pr(x_i=\\mathrm{T})=1/4$。\n\n候选比对 $j$ 的比对得分 $S_j$ 定义为 LLR 在所有位置上的总和，\n$$\nS_j \\equiv \\sum_{i=1}^{L} \\ln\\!\\left(\\frac{\\Pr(x_i \\mid \\text{correct at }j)}{\\Pr(x_i \\mid \\text{incorrect})}\\right),\n$$\n其中 $\\ln$ 表示自然对数。\n\n某个特定的读段产生了两个可能的比对（hits）。对于得分最高的比对（候选 $j=1$），有 $m_1=70$ 个匹配和 $u_1=5$ 个错配。对于得分第二高的比对（候选 $j=2$），有 $m_2=68$ 个匹配和 $u_2=7$ 个错配。假设任一候选是该读段真实来源的先验概率相等，并且任何其他来源的先验概率质量相对于这两者可以忽略不计。\n\n令 Phred-like 比对质量 $Q$ 定义为\n$$\nQ \\equiv -10\\,\\log_{10}\\!\\big(1 - P_{\\text{correct}}\\big),\n$$\n其中 $P_{\\text{correct}}$ 是在上述概率模型下，得分最高的比对是该读段正确来源的后验概率。仅使用已声明的假设，从比对得分 $S_1$ 和 $S_2$ 推导出 $P_{\\text{correct}}$，对 $\\epsilon=0.01$ 的情况计算 $Q$ 的数值，并报告最终的 $Q$ 值，四舍五入到四位有效数字。将 $Q$ 表示为无量纲数（无单位）。", "solution": "该问题已经过验证，被认为是有效的。它在科学上基于生物信息学和概率建模的原理，问题提法明确，信息充分，可得出唯一解，且语言客观。\n\n目标是为得分最高的比对计算 Phred-like 比对质量 $Q$。这需要确定得分最高的比对（候选 $j=1$）是该读段真实来源的后验概率 $P_{\\text{correct}}$。令 $C_j$ 表示候选比对 $j$ 是正确来源的事件，令 $X$ 表示观测到的读段序列数据。我们需要求解 $P_{\\text{correct}} = \\Pr(C_1 \\mid X)$。\n\n根据贝叶斯定理，后验概率由下式给出：\n$$ \\Pr(C_1 \\mid X) = \\frac{\\Pr(X \\mid C_1) \\Pr(C_1)}{\\Pr(X)} $$\n问题陈述两个候选的先验概率相等，即 $\\Pr(C_1) = \\Pr(C_2)$，且任何其他来源的概率可以忽略。这意味着真实来源的样本空间可以限制在 $\\{C_1, C_2\\}$，因此 $\\Pr(C_1) + \\Pr(C_2) \\approx 1$，从而得出 $\\Pr(C_1) = \\Pr(C_2) = 1/2$。数据的边缘概率 $\\Pr(X)$ 是所有可能假设下的总和：\n$$ \\Pr(X) = \\Pr(X \\mid C_1)\\Pr(C_1) + \\Pr(X \\mid C_2)\\Pr(C_2) $$\n将此代入 $\\Pr(C_1 \\mid X)$ 的表达式并使用相等的先验概率：\n$$ P_{\\text{correct}} = \\Pr(C_1 \\mid X) = \\frac{\\Pr(X \\mid C_1) \\Pr(C_1)}{\\Pr(X \\mid C_1)\\Pr(C_1) + \\Pr(X \\mid C_2)\\Pr(C_2)} = \\frac{\\Pr(X \\mid C_1)}{\\Pr(X \\mid C_1) + \\Pr(X \\mid C_2)} $$\n项 $\\Pr(X \\mid C_j)$ 是在比对 $j$ 正确的条件下观测到读段 $X$ 的似然。比对得分 $S_j$ 定义为对数似然比：\n$$ S_j = \\sum_{i=1}^{L} \\ln\\left(\\frac{\\Pr(x_i \\mid C_j)}{\\Pr(x_i \\mid \\text{incorrect})}\\right) $$\n由于各位置碱基识别错误的独立性，这个对数和可以写成乘積的对数：\n$$ S_j = \\ln\\left(\\prod_{i=1}^{L} \\frac{\\Pr(x_i \\mid C_j)}{\\Pr(x_i \\mid \\text{incorrect})}\\right) = \\ln\\left(\\frac{\\prod_{i=1}^{L}\\Pr(x_i \\mid C_j)}{\\prod_{i=1}^{L}\\Pr(x_i \\mid \\text{incorrect})}\\right) = \\ln\\left(\\frac{\\Pr(X \\mid C_j)}{\\Pr(X \\mid \\text{incorrect})}\\right) $$\n对两边取指数，可以得到用得分 $S_j$ 和比对不正确假设下的似然 $\\Pr(X \\mid \\text{incorrect})$ 表示的似然 $\\Pr(X \\mid C_j)$：\n$$ \\Pr(X \\mid C_j) = \\Pr(X \\mid \\text{incorrect}) \\exp(S_j) $$\n将此代入 $P_{\\text{correct}}$ 的方程中：\n$$ P_{\\text{correct}} = \\frac{\\Pr(X \\mid \\text{incorrect}) \\exp(S_1)}{\\Pr(X \\mid \\text{incorrect}) \\exp(S_1) + \\Pr(X \\mid \\text{incorrect}) \\exp(S_2)} = \\frac{\\exp(S_1)}{\\exp(S_1) + \\exp(S_2)} $$\n分子分母同除以 $\\exp(S_1)$，得到用比对得分表示的 $P_{\\text{correct}}$ 的所需表达式：\n$$ P_{\\text{correct}} = \\frac{1}{1 + \\exp(S_2 - S_1)} $$\n接下来，我们必须计算得分差 $S_1 - S_2$。一个比对的总得分是所有位置上对数似然比的总和。这个总和可以分为匹配和错配的贡献。令 $LLR_m$ 为匹配的 LLR，$LLR_u$ 为错配的 LLR。\n对于匹配（$x_i=b_i$）：\n$$ LLR_m = \\ln\\left(\\frac{\\Pr(x_i=b_i \\mid \\text{correct})}{\\Pr(x_i=b_i \\mid \\text{incorrect})}\\right) = \\ln\\left(\\frac{1-\\epsilon}{1/4}\\right) = \\ln(4(1-\\epsilon)) $$\n对于错配（$x_i \\neq b_i$）：\n$$ LLR_u = \\ln\\left(\\frac{\\Pr(x_i \\neq b_i \\mid \\text{correct})}{\\Pr(x_i \\neq b_i \\mid \\text{incorrect})}\\right) = \\ln\\left(\\frac{\\epsilon/3}{1/4}\\right) = \\ln\\left(\\frac{4\\epsilon}{3}\\right) $$\n具有 $m_j$ 个匹配和 $u_j$ 个错配的候选 $j$ 的总比对得分是：\n$$ S_j = m_j LLR_m + u_j LLR_u $$\n于是得分差为：\n$$ S_1 - S_2 = (m_1 - m_2) LLR_m + (u_1 - u_2) LLR_u $$\n已知 $m_1=70, u_1=5$ 和 $m_2=68, u_2=7$。差值为 $m_1-m_2=2$ 和 $u_1-u_2=-2$。\n$$ S_1 - S_2 = 2 \\cdot LLR_m - 2 \\cdot LLR_u = 2(LLR_m - LLR_u) $$\n代入 $LLR_m$ 和 $LLR_u$ 的表达式：\n$$ S_1 - S_2 = 2\\left[\\ln(4(1-\\epsilon)) - \\ln\\left(\\frac{4\\epsilon}{3}\\right)\\right] = 2\\ln\\left(\\frac{4(1-\\epsilon)}{4\\epsilon/3}\\right) = 2\\ln\\left(\\frac{3(1-\\epsilon)}{\\epsilon}\\right) $$\n错误概率（即得分最高的比对不正确的概率）是 $1 - P_{\\text{correct}}$：\n$$ 1 - P_{\\text{correct}} = 1 - \\frac{1}{1 + \\exp(S_2 - S_1)} = \\frac{\\exp(S_2 - S_1)}{1 + \\exp(S_2 - S_1)} = \\frac{1}{\\exp(S_1 - S_2) + 1} $$\n代入 $S_1 - S_2$ 的表达式：\n$$ 1 - P_{\\text{correct}} = \\frac{1}{\\exp\\left(2\\ln\\left(\\frac{3(1-\\epsilon)}{\\epsilon}\\right)\\right) + 1} = \\frac{1}{\\left(\\frac{3(1-\\epsilon)}{\\epsilon}\\right)^2 + 1} $$\n现在我们可以用 $\\epsilon$ 来表示比对质量 $Q$：\n$$ Q = -10\\,\\log_{10}(1 - P_{\\text{correct}}) = -10\\,\\log_{10}\\left(\\frac{1}{1 + \\left(\\frac{3(1-\\epsilon)}{\\epsilon}\\right)^2}\\right) = 10\\,\\log_{10}\\left(1 + \\left(\\frac{3(1-\\epsilon)}{\\epsilon}\\right)^2\\right) $$\n给定 $\\epsilon=0.01$。我们现在可以对此表达式进行数值计算。\n首先，计算括号内的项：\n$$ \\frac{3(1-\\epsilon)}{\\epsilon} = \\frac{3(1-0.01)}{0.01} = \\frac{3 \\times 0.99}{0.01} = 3 \\times 99 = 297 $$\n现在，将此值代入 $Q$ 的表达式：\n$$ Q = 10\\,\\log_{10}(1 + 297^2) = 10\\,\\log_{10}(1 + 88209) = 10\\,\\log_{10}(88210) $$\n使用计算器计算对数：\n$$ \\log_{10}(88210) \\approx 4.945523 $$\n因此，比对质量为：\n$$ Q = 10 \\times 4.945523 \\approx 49.45523 $$\n将结果四舍五入到四位有效数字，得到 $49.46$。", "answer": "$$\\boxed{49.46}$$", "id": "4603952"}]}