{"hands_on_practices": [{"introduction": "本练习将带您深入理解群体遗传学的基础。它将可观察的群体基因型计数与潜在的等位基因频率联系起来。通过从第一性原理推导最大似然估计，并计算在哈迪-温伯格平衡（Hardy-Weinberg equilibrium, HWE）下的期望基因型频率，您将掌握基因组学研究中用于质量控制和群体结构分析的一项核心技能[@problem_id:4569027]。", "problem": "为精准医疗研究而建立的大型临床生物样本库，使用高覆盖度全基因组测序技术，对一个无亲缘关系的个体队列中的一个常染色体、双等位基因的单核苷酸多态性（SNP）进行了基因分型。设这两个等位基因由核苷酸字母 $T$（参考）和 $C$（变异）表示。该队列中观察到的基因型计数为：$n_{TT} = 548$，$n_{TC} = 362$，$n_{CC} = 90$，总共 $n = 1000$ 个二倍体个体。\n\n从基本定义出发，在一个没有选择、突变、迁移或选择性交配的随机交配群体中，每个配子独立地携带等位基因 $C$ 的概率为 $p$，携带等位基因 $T$ 的概率为 $1 - p$，并且该队列中的 $2n$ 个等位基因构成了对群体基因库的抽样。请执行以下操作：\n\n1. 仅使用对 $2n$ 个等位基因进行独立伯努利试验的似然性第一性原理，根据观察到的基因型计数推导等位基因 $C$ 的群体频率 $p$ 的最大似然估计 $\\hat{p}$。\n\n2. 使用哈迪-温伯格平衡（HWE）的定义，即配子的随机结合产生作为等位基因概率乘积的基因型类别，推导 $TT$、$TC$ 和 $CC$ 的预期基因型频率（用 $p$ 表示）。\n\n3. 将您的 $\\hat{p}$ 代入第2部分获得的HWE表达式中，计算该队列中杂合子 $TC$ 的预期数量。将最终结果表示为单个数字。将您的答案四舍五入到四位有效数字。不需要单位。", "solution": "问题陈述已经过验证，被认为是科学上可靠、定义明确、客观且内容完整的。这是一个群体遗传学中的标准练习。因此，我们可以进行正式的解答。\n\n问题分为三个部分。我们将依次解答每个部分。\n\n**第1部分：等位基因频率 $p$ 的最大似然估计（MLE）的推导**\n\n我们被要求推导变异等位基因 $C$ 频率的最大似然估计 $\\hat{p}$。问题明确指出，此推导必须基于对 $n$ 个二倍体个体队列中存在的 $2n$ 个等位基因进行独立伯努利试验的原理。\n\n个体总数为 $n = n_{TT} + n_{TC} + n_{CC} = 548 + 362 + 90 = 1000$。\n因此，样本中的等位基因总数为 $2n = 2000$。\n\n设 $p$ 为等位基因 $C$ 的群体频率。\n设 $1-p$ 为等位基因 $T$ 的群体频率。\n\n样本中的每个 $2n$ 等位基因都可以看作是从群体基因库中的一次独立抽样。抽到一个 $C$ 等位基因的事件是“成功”，概率为 $p$；抽到一个 $T$ 等位基因的事件是“失败”，概率为 $1-p$。这构成了一系列 $2n$ 次独立的伯努利试验。\n\n首先，我们计算样本中 $C$ 等位基因的总数（记为 $N_C$）和 $T$ 等位基因的总数（记为 $N_T$）。\n基因型为 $TT$ 的个体贡献 $0$ 个 $C$ 等位基因。\n基因型为 $TC$ 的个体贡献 $1$ 个 $C$ 等位基因。\n基因型为 $CC$ 的个体贡献 $2$ 个 $C$ 等位基因。\n因此，$C$ 等位基因的总计数为：\n$$N_C = 2 \\cdot n_{CC} + 1 \\cdot n_{TC} + 0 \\cdot n_{TT} = 2n_{CC} + n_{TC}$$\n$T$ 等位基因的总计数为：\n$$N_T = 2 \\cdot n_{TT} + 1 \\cdot n_{TC} + 0 \\cdot n_{CC} = 2n_{TT} + n_{TC}$$\n等位基因总数为 $N_C + N_T = (2n_{CC} + n_{TC}) + (2n_{TT} + n_{TC}) = 2(n_{TT} + n_{TC} + n_{CC}) = 2n$，这与之前一致。\n\n在 $2n$ 次独立试验中观察到恰好 $N_C$ 次成功的概率遵循二项分布。似然函数 $L(p)$ 是在给定参数 $p$ 的情况下观察到当前数据的概率，其表达式为：\n$$L(p | N_C, n) = \\binom{2n}{N_C} p^{N_C} (1-p)^{2n - N_C}$$\n为了找到使该函数最大化的 $p$ 值，计算上更方便的是最大化似然函数的自然对数，即对数似然函数 $\\ell(p) = \\ln(L(p))$：\n$$\\ell(p) = \\ln\\left(\\binom{2n}{N_C}\\right) + N_C \\ln(p) + (2n - N_C) \\ln(1-p)$$\n我们通过求 $\\ell(p)$ 对 $p$ 的一阶导数并将其设为零来找到最大值。项 $\\ln\\left(\\binom{2n}{N_C}\\right)$ 是关于 $p$ 的常数，因此其导数为零。\n$$\\frac{d\\ell}{dp} = \\frac{N_C}{p} - \\frac{2n - N_C}{1-p}$$\n将导数设为零，得到最大似然估计（MLE），记为 $\\hat{p}$：\n$$\\frac{N_C}{\\hat{p}} - \\frac{2n - N_C}{1-\\hat{p}} = 0$$\n$$\\frac{N_C}{\\hat{p}} = \\frac{2n - N_C}{1-\\hat{p}}$$\n$$N_C (1-\\hat{p}) = \\hat{p} (2n - N_C)$$\n$$N_C - N_C \\hat{p} = 2n \\hat{p} - N_C \\hat{p}$$\n$$N_C = 2n \\hat{p}$$\n解出 $\\hat{p}$，我们得到最大似然估计：\n$$\\hat{p} = \\frac{N_C}{2n}$$\n将 $N_C$ 的表达式用基因型计数代入，我们得到 MLE 的最终表达式：\n$$\\hat{p} = \\frac{2n_{CC} + n_{TC}}{2n}$$\n\n**第2部分：哈迪-温伯格平衡（HWE）下预期基因型频率的推导**\n\n问题将 HWE 定义为配子随机结合所产生的状态。在群体的配子库中，等位基因 $C$ 的频率是 $p$，等位基因 $T$ 的频率是 $1-p$。形成二倍体合子的过程涉及两个此类配子的随机组合。\n\n形成 $CC$ 基因型的概率是一个携带 $C$ 的配子与另一个携带 $C$ 的配子结合的概率。由于是随机结合（独立性），这个概率是：\n$$\\text{Freq}(CC) = p \\times p = p^2$$\n形成 $TT$ 基因型的概率是一个携带 $T$ 的配子与另一个携带 $T$ 的配子结合的概率：\n$$\\text{Freq}(TT) = (1-p) \\times (1-p) = (1-p)^2$$\n形成 $TC$ 杂合子的概率可以通过两种互斥的方式发生：\n1. 一个带 $T$ 等位基因的精子使一个带 $C$ 等位基因的卵子受精。概率为 $(1-p) \\times p$。\n2. 一个带 $C$ 等位基因的精子使一个带 $T$ 等位基因的卵子受精。概率为 $p \\times (1-p)$。\n因此，杂合子基因型的总概率是这些概率之和：\n$$\\text{Freq}(TC) = p(1-p) + (1-p)p = 2p(1-p)$$\n因此，HWE 下的预期基因型频率为：\n$$(1-p)^2 \\quad \\text{对于 } TT$$\n$$2p(1-p) \\quad \\text{对于 } TC$$\n$$p^2 \\quad \\text{对于 } CC$$\n\n**第3部分：预期杂合子数量的计算**\n\n首先，我们使用提供的基因型计数 $n_{TT} = 548$，$n_{TC} = 362$，$n_{CC} = 90$ 和 $n = 1000$ 来计算 MLE $\\hat{p}$ 的数值。\n根据第1部分，我们有：\n$$\\hat{p} = \\frac{2n_{CC} + n_{TC}}{2n} = \\frac{2(90) + 362}{2(1000)} = \\frac{180 + 362}{2000} = \\frac{542}{2000} = 0.271$$\n接下来，我们使用这个估计值 $\\hat{p}$，并基于第2部分推导的公式，来计算 HWE 下杂合子（$TC$）的预期频率：\n$$\\text{预期频率}(TC) = 2\\hat{p}(1-\\hat{p})$$\n$$\\text{预期频率}(TC) = 2(0.271)(1 - 0.271) = 2(0.271)(0.729) = 0.395118$$\n最后，在一个大小为 $n=1000$ 的队列中，预期的杂合子数量 $E[n_{TC}]$ 是个体总数乘以该基因型的预期频率：\n$$E[n_{TC}] = n \\times \\text{预期频率}(TC)$$\n$$E[n_{TC}] = 1000 \\times 0.395118 = 395.118$$\n问题要求将答案四舍五入到四位有效数字。\n$$395.118 \\approx 395.1$$\n因此，在该队列中，假设满足 HWE 条件，预期的杂合子数量为 $395.1$。", "answer": "$$\n\\boxed{395.1}\n$$", "id": "4569027"}, {"introduction": "真实的基因组数据常常受到技术性偏差的影响。本练习构建了一个概率模型，以探索参考序列偏置（reference bias）和测序错误如何扭曲杂合位点上观察到的等位基因平衡（allele balance），使其偏离理想值$0.5$。理解并量化这些效应是开发稳健变异检测算法的关键第一步[@problem_id:4568960]。", "problem": "单核苷酸多态性（SNP）是二倍体基因组中的一个双等位基因杂合位点，拥有一个参考等位基因（REF）和一个替代等位基因（ALT）。在高通量测序中，参考偏倚可能导致携带 REF 等位基因的读数比携带 ALT 等位基因的读数更成功地完成比对。考虑以下针对与一个杂合 SNP 重叠的读数的生成模型：\n\n1. 每个原始片段来自 REF 或 ALT 单倍型的可能性相同，概率分别为 $0.5$ 和 $0.5$。\n2. 以其来源单倍型为条件，如果一个片段携带 REF 单倍型，它成功比对并通过所有筛选的概率为 $m_{R}$；如果它携带 ALT 单倍型，则概率为 $m_{A}$。由于比对偏倚，$m_{R} \\neq m_{A}$。\n3. 以成功比对为条件，SNP 位置的碱基识别会受到一个对称替换错误率 $\\epsilon$ 的影响：一个已比对的、源自 REF 的读数报告为 ALT 的概率为 $\\epsilon$，报告为 REF 的概率为 $1-\\epsilon$；一个已比对的、源自 ALT 的读数报告为 ALT 的概率为 $1-\\epsilon$，报告为 REF 的概率为 $\\epsilon$。\n\n将等位基因平衡定义为在所有与 SNP 重叠的已比对读数中，支持 ALT 等位基因的读数的期望比例。请仅使用条件概率、全期望定律的核心定义以及上述生成模型，推导出作为 $m_{R}$、$m_{A}$ 和 $\\epsilon$ 函数的期望等位基因平衡，然后针对 $m_{R}=0.98$、$m_{A}=0.84$ 和 $\\epsilon=0.005$ 进行数值计算。\n\n将最终数值结果表示为四舍五入到四位有效数字的小数。最终答案中不要包含百分号或任何单位。", "solution": "用户希望在一个给定的、包含参考偏倚和碱基识别错误的测序读数生成模型下，推导并计算杂合单核苷酸多态性（SNP）位点上的等位基因平衡表达式。\n\n首先，我将验证问题陈述。\n\n**第 1 步：提取已知条件**\n- SNP 是一个具有参考（REF）和替代（ALT）等位基因的双等位基因杂合位点。\n- 原始片段来自 REF 单倍型的概率为 $P(H_R) = 0.5$。\n- 原始片段来自 ALT 单倍型的概率为 $P(H_A) = 0.5$。\n- 源自 REF 的片段成功比对的概率为 $m_{R} = P(M|H_R)$。\n- 源自 ALT 的片段成功比对的概率为 $m_{A} = P(M|H_A)$。\n- 存在比对偏倚，意味着 $m_{R} \\neq m_{A}$。\n- 对称替换错误率 $\\epsilon$ 控制着已比对读数的碱基识别。\n- 已比对的、源自 REF 的读数报告为 ALT 的概率：$P(A_{obs}|M, H_R) = \\epsilon$。\n- 已比对的、源自 REF 的读数报告为 REF 的概率：$P(R_{obs}|M, H_R) = 1-\\epsilon$。\n- 已比对的、源自 ALT 的读数报告为 ALT 的概率：$P(A_{obs}|M, H_A) = 1-\\epsilon$。\n- 已比对的、源自 ALT 的读数报告为 REF 的概率：$P(R_{obs}|M, H_A) = \\epsilon$。\n- 等位基因平衡定义为支持 ALT 等位基因的已比对读数的期望比例。\n- 用于计算的数值：$m_{R}=0.98$，$m_{A}=0.84$ 以及 $\\epsilon=0.005$。\n- 最终数值结果应四舍五入至四位有效数字。\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题具有科学依据，提法明确且客观。它提出了一个简化但标准且有效的概率模型，该模型在生物信息学中用于解释诸如比对偏倚和碱基识别错误等测序假象。所提供的参数在物理上是现实的。问题是自洽的，没有矛盾或含糊之处。术语在基因组学领域是标准的。因此，该问题是有效的。\n\n**第 3 步：结论与行动**\n问题有效。我将继续进行解答。\n\n**等位基因平衡的推导**\n\n等位基因平衡（$AB$）定义为支持 ALT 等位基因的已比对读数的期望比例。这等同于求单个随机选择的已比对读数报告 ALT 等位基因的概率。我们将读数成功比对的事件表示为 $M$，已比对的读数报告 ALT 等位基因的事件表示为 $A_{obs}$。我们希望求得的量是条件概率 $P(A_{obs}|M)$。\n\n根据条件概率的定义：\n$$ AB = P(A_{obs}|M) = \\frac{P(A_{obs} \\cap M)}{P(M)} $$\n我们可以使用全概率公式，根据读数的来源单倍型（$H_R$ 即 REF 单倍型，或 $H_A$ 即 ALT 单倍型）对样本空间进行划分，从而分别计算分子和分母。\n\n首先，计算分母 $P(M)$，这是一个读数无论其来源如何都能成功比对的总概率。\n$$ P(M) = P(M|H_R)P(H_R) + P(M|H_A)P(H_A) $$\n代入给定的概率：\n$$ P(M) = m_{R}(0.5) + m_{A}(0.5) = 0.5(m_{R} + m_{A}) $$\n\n接下来，计算分子 $P(A_{obs} \\cap M)$，这是一个读数成功比对且报告 ALT 等位基因的联合概率。\n$$ P(A_{obs} \\cap M) = P(A_{obs} \\cap M | H_R)P(H_R) + P(A_{obs} \\cap M | H_A)P(H_A) $$\n使用条件概率的链式法则，$P(A_{obs} \\cap M | H_i) = P(A_{obs}|M, H_i)P(M|H_i)$，我们可以将表达式重写为：\n$$ P(A_{obs} \\cap M) = P(A_{obs}|M, H_R)P(M|H_R)P(H_R) + P(A_{obs}|M, H_A)P(M|H_A)P(H_A) $$\n现在，我们代入生成模型中的参数：\n- 对于来自 REF 单倍型（$H_R$）的读数：它以概率 $m_R$ 成功比对，然后以概率 $\\epsilon$ 被错误地识别为 ALT。\n- 对于来自 ALT 单倍型（$H_A$）的读数：它以概率 $m_A$ 成功比对，然后以概率 $1-\\epsilon$ 被正确地识别为 ALT。\n\n将这些代入 $P(A_{obs} \\cap M)$ 的方程中：\n$$ P(A_{obs} \\cap M) = (\\epsilon)(m_{R})(0.5) + (1-\\epsilon)(m_{A})(0.5) $$\n$$ P(A_{obs} \\cap M) = 0.5(\\epsilon m_{R} + (1-\\epsilon)m_{A}) $$\n\n最后，通过计算分子与分母的比值，我们可以得到等位基因平衡：\n$$ AB = \\frac{P(A_{obs} \\cap M)}{P(M)} = \\frac{0.5(\\epsilon m_{R} + (1-\\epsilon)m_{A})}{0.5(m_{R} + m_{A})} $$\n$0.5$ 的因子相消，得到等位基因平衡的通用表达式：\n$$ AB = \\frac{\\epsilon m_{R} + (1-\\epsilon)m_{A}}{m_{R} + m_{A}} $$\n\n**数值计算**\n\n现在，我们将给定的数值代入推导出的表达式中：$m_{R}=0.98$，$m_{A}=0.84$，以及 $\\epsilon=0.005$。\n$$ AB = \\frac{(0.005)(0.98) + (1-0.005)(0.84)}{0.98 + 0.84} $$\n$$ AB = \\frac{(0.005)(0.98) + (0.995)(0.84)}{1.82} $$\n计算分子中的各项：\n$$ (0.005)(0.98) = 0.0049 $$\n$$ (0.995)(0.84) = 0.8358 $$\n将分子中的各项相加：\n$$ 0.0049 + 0.8358 = 0.8407 $$\n现在，进行最后的除法运算：\n$$ AB = \\frac{0.8407}{1.82} \\approx 0.4619230769... $$\n问题要求结果四舍五入到四位有效数字。前四位有效数字是 $4$、$6$、$1$ 和 $9$。第五位数字是 $2$，所以我们向下舍入。\n$$ AB \\approx 0.4619 $$\n这就是在给定条件下，支持 ALT 等位基因的已比对读数的期望比例。", "answer": "$$\n\\boxed{0.4619}\n$$", "id": "4568960"}, {"introduction": "最后的这项练习将理论与完整的生物信息学应用相结合。您将通过编程实现一种统计方法，从测序深度数据中检测拷贝数变异（Copy Number Variations, CNVs），这是基因组学中的一项常规任务。本练习直接解决了其中的一个关键挑战——如何对基因组可作图性（mappability）进行归一化以避免假阳性，从而在原始统计模型和可靠的计算工具之间架起一座桥梁[@problem_id:4568999]。", "problem": "考虑使用短读长全基因组测序来检测基因组变异，包括单核苷酸多态性（SNP）、插入和缺失（indels）以及结构变异（SV）。读段被比对到参考基因组上，每个基因组位置的读段覆盖度被用来推断拷贝数变异（CNV）。两个基本事实推动了对覆盖度进行统计处理：(i) 在均匀采样和读段起始位点独立的条件下，每碱基的读段计数遵循泊松过程；(ii) 由于包括片段重复在内的重复DNA的存在，比对可图谱性在整个基因组中是变化的。可图谱性轨道为每个基因组位置分配一个介于 $0$ 和 $1$ 之间的分数，该分数表示源于该位置的读段能够被唯一比对的概率；低可图谱性的位置即使在没有真实CNV的情况下也会导致观测到的覆盖度降低，而高度重复的区域也可能根据比对启发式算法表现出异常的堆积。目标是形式化地描述可图谱性和片段重复如何扭曲覆盖度，并设计一个有原则的过滤和归一化方案，利用可图谱性轨道来减少CNV的假阳性。\n\n基本原理和定义：\n- 分子生物学中心法则指出，脱氧核糖核酸（DNA）被转录为核糖核酸（RNA），并被翻译成蛋白质；虽然这不直接决定读段覆盖度，但它为基于测序的基因组变异推断设定了背景。\n- 在短读长测序中，位置 $i$ 处观测到的每碱基覆盖度 $C_i$ 可以被建模为一个均值为 $\\lambda_i$ 的泊松随机变量，记为 $C_i \\sim \\mathrm{Poisson}(\\lambda_i)$，其中 $\\lambda_i$ 取决于总测序深度、拷贝数和可图谱性。\n- 令 $m_i \\in [0,1]$ 表示碱基 $i$ 处的可图谱性。令在唯一可图谱区域中，二倍体拷贝数为 $2$ 时的基线预期覆盖度为 $\\mu$（读段/碱基）。那么，对于碱基 $i$ 处的绝对拷贝数 $\\mathrm{CN}$，在一个非唯一可图谱读段实际上无法用于可信比对的模型下，预期覆盖度满足 $\\mathbb{E}[C_i] = \\lambda_i = \\mu \\cdot m_i \\cdot \\frac{\\mathrm{CN}}{2}$。\n- 拷贝数变异（CNV）检出的目标是通过聚合一个基因组窗口内的证据来检测 $\\mathrm{CN} \\neq 2$。片段重复和其他低可图谱性特征扭曲了基于覆盖度的朴素CNV检出，因为 $\\{m_i\\}$ 变化显著，通常会独立于真实的 $\\mathrm{CN}$ 使 $C_i$ 偏低。\n\n任务：\n1. 从带可图谱性的泊松模型出发，推导一个归一化和检验方案，用于估计一个基因组窗口的 $\\widehat{\\mathrm{CN}}$，并计算一个检验其与零假设 $\\mathrm{CN}_0 = 2$ 偏差的统计量。您的推导不得依赖于快捷公式；它应从 $C_i \\sim \\mathrm{Poisson}(\\lambda_i)$ 和 $\\lambda_i = \\mu \\cdot m_i \\cdot \\frac{\\mathrm{CN}}{2}$ 开始。\n2. 提出并实现一个使用可图谱性轨道的过滤程序，以减少低可图谱性或高度重复窗口中的假阳性。该过滤器必须包括：\n   - 排除 $m_i  t_{\\mathrm{map}}$ 的碱基。\n   - 需要保留的 $m_i \\ge t_{\\mathrm{map}}$ 的碱基达到一个最小比例 $f_{\\min}$，才能尝试进行CNV检出。\n   - 一个最小保留长度 $n_{\\min}$（以碱基为单位），低于该长度的窗口被视为无法得出结论。\n3. 用代码实现最终的估计量和检验统计量。对于每个测试窗口，使用一个对称的显著性阈值 $z_{\\mathrm{thr}}$ 来对CNV状态进行分类：对于缺失输出 $-1$，对于中性（无CNV检出或无法得出结论）输出 $0$，对于重复输出 $+1$。\n\n实现的数学规范：\n- 给定一个窗口，其每碱基覆盖度为 $\\{C_i\\}_{i=1}^n$，可图谱性为 $\\{m_i\\}_{i=1}^n$，以及参数 $\\mu$、 $t_{\\mathrm{map}}$、 $f_{\\min}$、 $n_{\\min}$ 和 $z_{\\mathrm{thr}}$，应用过滤器以保留索引 $\\mathcal{I} = \\{ i \\in \\{1,\\dots,n\\} : m_i \\ge t_{\\mathrm{map}} \\}$。如果 $|\\mathcal{I}|  n_{\\min}$ 或 $\\frac{|\\mathcal{I}|}{n}  f_{\\min}$，则输出 $0$。\n- 对 $i \\in \\mathcal{I}$ 定义归一化的每碱基量 $X_i = \\frac{C_i}{\\mu \\cdot m_i}$。令 $\\widehat{\\mathrm{CN}} = \\frac{2}{|\\mathcal{I}|} \\sum_{i \\in \\mathcal{I}} X_i$。在零假设 $\\mathrm{CN}_0 = 2$ 下，通过泊松到正态的近似，将 $X_i$ 的方差近似为 $\\mathrm{Var}(X_i \\mid \\mathrm{CN}_0) = \\frac{\\mathrm{CN}_0}{2 \\cdot \\mu \\cdot m_i}$。那么 $\\widehat{\\mathrm{CN}}$ 在零假设下的方差是\n$$\n\\mathrm{Var}_0(\\widehat{\\mathrm{CN}}) = \\left( \\frac{2}{|\\mathcal{I}|} \\right)^2 \\sum_{i \\in \\mathcal{I}} \\mathrm{Var}(X_i \\mid \\mathrm{CN}_0) = \\frac{4}{|\\mathcal{I}|^2} \\sum_{i \\in \\mathcal{I}} \\frac{1}{\\mu \\cdot m_i}.\n$$\n- 计算在零假设下的 $z$-分数，\n$$\nz = \\frac{\\widehat{\\mathrm{CN}} - 2}{\\sqrt{\\mathrm{Var}_0(\\widehat{\\mathrm{CN}})}}.\n$$\n根据 $z$ 进行分类：如果 $z \\le -z_{\\mathrm{thr}}$ 则输出 $-1$，如果 $z \\ge z_{\\mathrm{thr}}$ 则输出 $+1$，否则输出 $0$。\n\n测试套件：\n使用以下五个窗口来探测不同场景，其中 $\\{C_i\\}$ 的数组表示为整数序列，$\\{m_i\\}$ 的数组表示为 $[0,1]$ 范围的小数：\n\n- 测试 1（高可图谱性，中性二倍体）：$\\mu = 30$, $t_{\\mathrm{map}} = 0.5$, $f_{\\min} = 0.6$, $n_{\\min} = 5$, $z_{\\mathrm{thr}} = 3.0$, $\\{C_i\\} = \\{31,29,33,30,28,32,31,30,29,34\\}$, $\\{m_i\\} = \\{0.99,0.98,1.0,0.97,0.96,0.99,0.98,1.0,0.95,0.97\\}$。\n- 测试 2（片段重复伴随低可图谱性，中性二倍体但覆盖度下降）：$\\mu = 30$, $t_{\\mathrm{map}} = 0.5$, $f_{\\min} = 0.6$, $n_{\\min} = 5$, $z_{\\mathrm{thr}} = 3.0$, $\\{C_i\\} = \\{9,11,8,12,10,9,10,9,8,10\\}$, $\\{m_i\\} = \\{0.30,0.35,0.25,0.40,0.33,0.28,0.31,0.29,0.27,0.34\\}$。\n- 测试 3（高可图谱性区域的真实杂合性缺失）：$\\mu = 30$, $t_{\\mathrm{map}} = 0.5$, $f_{\\min} = 0.6$, $n_{\\min} = 5$, $z_{\\mathrm{thr}} = 3.0$, $\\{C_i\\} = \\{15,14,16,13,17,15,14,16\\}$, $\\{m_i\\} = \\{0.98,0.97,0.99,0.96,0.97,0.98,0.99,0.97\\}$。\n- 测试 4（混合可图谱性区域的重复；唯一区域比例足以通过过滤器）：$\\mu = 30$, $t_{\\mathrm{map}} = 0.5$, $f_{\\min} = 0.6$, $n_{\\min} = 5$, $z_{\\mathrm{thr}} = 3.0$, $\\{C_i\\} = \\{36,31,27,18,25,41,38,23,20,31,29,27\\}$, $\\{m_i\\} = \\{0.8,0.7,0.6,0.4,0.55,0.9,0.85,0.5,0.45,0.7,0.65,0.6\\}$。\n- 测试 5（边界上的短窗口；因最小长度而无法得出结论）：$\\mu = 30$, $t_{\\mathrm{map}} = 0.5$, $f_{\\min} = 0.6$, $n_{\\min} = 5$, $z_{\\mathrm{thr}} = 3.0$, $\\{C_i\\} = \\{30,31,29\\}$, $\\{m_i\\} = \\{0.95,0.96,0.97\\}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含五个测试的CNV分类，以逗号分隔的列表形式并用方括号括起来，例如 $[\\dots]$。使用整数编码检出结果：$-1$ 表示缺失， $0$ 表示中性或被过滤/无法得出结论，$+1$ 表示重复。输出中不需要单位。程序必须是自包含的，并且不需要用户输入。", "solution": "该问题要求阐述并实现一种统计方法，用于从短读长测序数据中检测拷贝数变异（CNV），同时考虑基因组可图谱性的混杂效应。该解决方案包括三个主要部分：一个用于读段覆盖度的统计模型，一个用于处理低质量数据区域的过滤方案，以及一个用于评估观测到的覆盖度偏差显著性的假设检验框架。\n\n推导和过程如下：\n\n首先，我们为观测到的读段计数建立统计模型。在任何给定的基因组位置 $i$，覆盖该位置的读段数 $C_i$ 被建模为一个泊松分布的随机变量，记为 $C_i \\sim \\mathrm{Poisson}(\\lambda_i)$。参数 $\\lambda_i$ 代表该位置的预期（或平均）覆盖度。\n\n其次，我们通过整合生物和技术因素来对预期覆盖度 $\\lambda_i$ 进行建模。问题假定 $\\lambda_i$ 是三个主要组成部分的函数：\n1.  整体测序深度，由一个“正常”基因组区域中的基线平均覆盖度 $\\mu$ 表示。一个正常区域被定义为二倍体（拷贝数为 2）且完全可图谱。\n2.  位置 $i$ 处真实的、潜在的绝对拷贝数，记为 $\\mathrm{CN}$。覆盖度与拷贝数成正比。我们通过二倍体状态对其进行归一化，得到一个因子 $\\frac{\\mathrm{CN}}{2}$。\n3.  位置 $i$ 处的比对可图谱性 $m_i \\in [0, 1]$。这个分数代表源于位置 $i$ 的读段能够被唯一且正确地比对回参考基因组的概率。非唯一可图谱的读段通常被丢弃或其比对质量分数被降低，导致观测到的覆盖度有效减少。\n结合这些因素，预期覆盖度的模型由下式给出：\n$$\n\\lambda_i = \\mathbb{E}[C_i] = \\mu \\cdot m_i \\cdot \\frac{\\mathrm{CN}}{2}\n$$\n\n目标是为一个包含碱基 $\\{1, \\dots, n\\}$ 的基因组窗口估计 $\\mathrm{CN}$，并检验它是否偏离二倍体零假设 $H_0: \\mathrm{CN} = 2$。\n\n为了推导一个拷贝数估计量，我们首先为每个碱基定义一个归一化量，该量校正了测序深度（$\\mu$）和可图谱性（$m_i$）的已知影响。让我们定义 $X_i$：\n$$\nX_i = \\frac{C_i}{\\mu \\cdot m_i}\n$$\n代入 $C_i$ 的期望， $X_i$ 的期望是：\n$$\n\\mathbb{E}[X_i] = \\frac{\\mathbb{E}[C_i]}{\\mu \\cdot m_i} = \\frac{\\mu \\cdot m_i \\cdot \\frac{\\mathrm{CN}}{2}}{\\mu \\cdot m_i} = \\frac{\\mathrm{CN}}{2}\n$$\n这表明 $X_i$ 是 $\\frac{\\mathrm{CN}}{2}$ 的一个无偏估计量。为了获得一个基因组窗口内更稳健的 $\\mathrm{CN}$ 估计，我们可以对这些单位置估计值进行平均。问题指定在聚合之前进行一个过滤步骤。我们只考虑索引集合 $\\mathcal{I} = \\{ i \\in \\{1,\\dots,n\\} : m_i \\ge t_{\\mathrm{map}} \\}$，其中 $t_{\\mathrm{map}}$ 是一个最小可图谱性阈值。然后，窗口的拷贝数估计量 $\\widehat{\\mathrm{CN}}$ 被定义为集合 $\\mathcal{I}$ 上对 $2 \\cdot X_i$ 的估计量的平均值：\n$$\n\\widehat{\\mathrm{CN}} = \\frac{1}{|\\mathcal{I}|} \\sum_{i \\in \\mathcal{I}} (2 \\cdot X_i) = \\frac{2}{|\\mathcal{I}|} \\sum_{i \\in \\mathcal{I}} \\frac{C_i}{\\mu \\cdot m_i}\n$$\n这是一个针对 $\\mathrm{CN}$ 的矩估计量。根据期望的线性性质，它是无偏的：$\\mathbb{E}[\\widehat{\\mathrm{CN}}] = \\mathrm{CN}$。\n\n为了执行统计检验，我们必须确定在零假设 $H_0: \\mathrm{CN} = 2$ 下 $\\widehat{\\mathrm{CN}}$ 的分布。根据中心极限定理，足够大量独立随机变量的和（以及均值）将近似服从正态分布。我们假设读段计数 $C_i$ 在不同位置之间是独立的。\n在 $H_0$ 下 $\\widehat{\\mathrm{CN}}$ 的均值是 $\\mathbb{E}[\\widehat{\\mathrm{CN}} \\mid H_0] = 2$。\n接下来，我们推导在 $H_0$ 下 $\\widehat{\\mathrm{CN}}$ 的方差，记为 $\\mathrm{Var}_0(\\widehat{\\mathrm{CN}})$。首先，我们求出 $X_i$ 的方差：\n$$\n\\mathrm{Var}(X_i) = \\mathrm{Var}\\left(\\frac{C_i}{\\mu \\cdot m_i}\\right) = \\frac{1}{(\\mu \\cdot m_i)^2} \\mathrm{Var}(C_i)\n$$\n泊松分布的一个关键性质是其方差等于其均值，$\\mathrm{Var}(C_i) = \\lambda_i$。在 $H_0: \\mathrm{CN} = 2$ 下，平均覆盖度为 $\\lambda_{i,0} = \\mu \\cdot m_i \\cdot \\frac{2}{2} = \\mu \\cdot m_i$。因此，在零假设下 $X_i$ 的方差是：\n$$\n\\mathrm{Var}(X_i \\mid H_0) = \\frac{\\lambda_{i,0}}{(\\mu \\cdot m_i)^2} = \\frac{\\mu \\cdot m_i}{(\\mu \\cdot m_i)^2} = \\frac{1}{\\mu \\cdot m_i}\n$$\n这对应于所提供的公式 $\\frac{\\mathrm{CN}_0}{2 \\cdot \\mu \\cdot m_i}$，其中 $\\mathrm{CN}_0 = 2$。\n假设 $X_i$ 变量是独立的，它们的和的方差是它们方差的和。因此，在 $H_0$ 下 $\\widehat{\\mathrm{CN}}$ 的方差是：\n$$\n\\mathrm{Var}_0(\\widehat{\\mathrm{CN}}) = \\mathrm{Var}\\left(\\frac{2}{|\\mathcal{I}|} \\sum_{i \\in \\mathcal{I}} X_i \\mid H_0 \\right) = \\left(\\frac{2}{|\\mathcal{I}|}\\right)^2 \\sum_{i \\in \\mathcal{I}} \\mathrm{Var}(X_i \\mid H_0) = \\frac{4}{|\\mathcal{I}|^2} \\sum_{i \\in \\mathcal{I}} \\frac{1}{\\mu \\cdot m_i}\n$$\n在定义了均值和方差后，我们可以构建一个 $z$-分数检验统计量，它以标准差为单位衡量估计值与其零假设值的偏差：\n$$\nz = \\frac{\\widehat{\\mathrm{CN}} - \\mathbb{E}[\\widehat{\\mathrm{CN}} \\mid H_0]}{\\sqrt{\\mathrm{Var}_0(\\widehat{\\mathrm{CN}})}} = \\frac{\\widehat{\\mathrm{CN}} - 2}{\\sqrt{\\mathrm{Var}_0(\\widehat{\\mathrm{CN}})}}\n$$\n在零假设下，这个 $z$-分数近似遵循标准正态分布 $\\mathcal{N}(0, 1)$。\n\n在进行检验之前，应用一个过滤程序来确保检出结果的可靠性。这是至关重要的，因为低可图谱性区域会产生有噪声和有偏见的覆盖度数据，而非常短的窗口缺乏统计功效。指定的过滤器是：\n1.  每碱基可图谱性过滤器：只有可图谱性 $m_i \\ge t_{\\mathrm{map}}$ 的碱基 $i$ 才被纳入分析。这定义了集合 $\\mathcal{I}$。\n2.  窗口质量过滤器：\n    -   保留的碱基数必须达到一个最小计数：$|\\mathcal{I}| \\ge n_{\\min}$。\n    -   保留的碱基比例必须达到一个最小阈值：$\\frac{|\\mathcal{I}|}{n} \\ge f_{\\min}$，其中 $n$ 是原始窗口中的总碱基数。\n如果一个窗口未能通过这些质量过滤器中的任何一个，它就被视为无法得出结论，输出为 $0$（中性）。\n\n最后，对于通过过滤器的窗口，CNV状态是根据计算出的 $z$-分数和一个预定义的显著性阈值 $z_{\\mathrm{thr}}$ 进行分类的。一个对称的阈值被用来检出缺失或重复：\n- 如果 $z \\ge z_{\\mathrm{thr}}$，覆盖度显著高于零假设下的预期，意味着发生了重复。输出为 $+1$。\n- 如果 $z \\le -z_{\\mathrm{thr}}$，覆盖度显著低于预期，意味着发生了缺失。输出为 $-1$。\n- 如果 $-z_{\\mathrm{thr}}  z  z_{\\mathrm{thr}}$，偏差不具有统计显著性。输出为 $0$（中性）。\n\n这个完整的方案提供了一个有原则、有统计学基础的CNV检测方法，它正确地对可图谱性进行了归一化，并对数据质量进行了过滤，从而减少了常见的假阳性来源。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the CNV detection problem for the given test suite.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"id\": 1,\n            \"mu\": 30.0, \"t_map\": 0.5, \"f_min\": 0.6, \"n_min\": 5, \"z_thr\": 3.0,\n            \"C\": np.array([31, 29, 33, 30, 28, 32, 31, 30, 29, 34]),\n            \"m\": np.array([0.99, 0.98, 1.0, 0.97, 0.96, 0.99, 0.98, 1.0, 0.95, 0.97])\n        },\n        {\n            \"id\": 2,\n            \"mu\": 30.0, \"t_map\": 0.5, \"f_min\": 0.6, \"n_min\": 5, \"z_thr\": 3.0,\n            \"C\": np.array([9, 11, 8, 12, 10, 9, 10, 9, 8, 10]),\n            \"m\": np.array([0.30, 0.35, 0.25, 0.40, 0.33, 0.28, 0.31, 0.29, 0.27, 0.34])\n        },\n        {\n            \"id\": 3,\n            \"mu\": 30.0, \"t_map\": 0.5, \"f_min\": 0.6, \"n_min\": 5, \"z_thr\": 3.0,\n            \"C\": np.array([15, 14, 16, 13, 17, 15, 14, 16]),\n            \"m\": np.array([0.98, 0.97, 0.99, 0.96, 0.97, 0.98, 0.99, 0.97])\n        },\n        {\n            \"id\": 4,\n            \"mu\": 30.0, \"t_map\": 0.5, \"f_min\": 0.6, \"n_min\": 5, \"z_thr\": 3.0,\n            \"C\": np.array([36, 31, 27, 18, 25, 41, 38, 23, 20, 31, 29, 27]),\n            \"m\": np.array([0.8, 0.7, 0.6, 0.4, 0.55, 0.9, 0.85, 0.5, 0.45, 0.7, 0.65, 0.6])\n        },\n        {\n            \"id\": 5,\n            \"mu\": 30.0, \"t_map\": 0.5, \"f_min\": 0.6, \"n_min\": 5, \"z_thr\": 3.0,\n            \"C\": np.array([30, 31, 29]),\n            \"m\": np.array([0.95, 0.96, 0.97])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        C = case[\"C\"]\n        m = case[\"m\"]\n        mu = case[\"mu\"]\n        t_map = case[\"t_map\"]\n        f_min = case[\"f_min\"]\n        n_min = case[\"n_min\"]\n        z_thr = case[\"z_thr\"]\n        \n        n = len(C) # Original window size\n\n        # Step 1: Apply mappability filter to get the set of indices I\n        mappable_indices = np.where(m >= t_map)[0]\n        I_size = len(mappable_indices)\n        \n        # Step 2: Apply window quality filters\n        if I_size  n_min or (I_size / n)  f_min:\n            results.append(0)\n            continue\n            \n        C_I = C[mappable_indices]\n        m_I = m[mappable_indices]\n\n        # Step 3: Calculate the CNV estimate\n        # X_i = C_i / (mu * m_i) for i in I\n        X_I = C_I / (mu * m_I)\n        \n        # CN_hat = (2 / |I|) * sum(X_i) = 2 * mean(X_I)\n        CN_hat = 2.0 * np.mean(X_I)\n        \n        # Step 4: Calculate the variance of the estimator under the null (CN=2)\n        # Var_0(CN_hat) = (4 / |I|^2) * sum(1 / (mu * m_i)) for i in I\n        var_sum_term = np.sum(1.0 / (mu * m_I))\n        var_CN_hat_null = (4.0 / (I_size**2)) * var_sum_term\n        \n        # Step 5: Compute the z-score\n        # Prevent division by zero if variance is somehow zero\n        if var_CN_hat_null == 0:\n            results.append(0) # Inconclusive if variance is not positive\n            continue\n\n        std_dev_CN_hat_null = np.sqrt(var_CN_hat_null)\n        z_score = (CN_hat - 2.0) / std_dev_CN_hat_null\n\n        # Step 6: Classify the CNV state\n        if z_score = -z_thr:\n            results.append(-1) # Deletion\n        elif z_score >= z_thr:\n            results.append(1) # Duplication\n        else:\n            results.append(0) # Neutral\n            \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4568999"}]}