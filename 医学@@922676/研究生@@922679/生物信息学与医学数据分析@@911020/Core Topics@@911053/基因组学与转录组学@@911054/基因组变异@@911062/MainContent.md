## 引言
基因组变异，即DNA序列在个体间的差异，是生命多样性的根源，也是驱动人类健康与疾病的关键因素。随着高通量测序技术的普及，我们能够以前所未有的深度探索个体基因组，但这也带来了巨大的挑战：如何从海量的、充满噪声的测[序数](@entry_id:150084)据中准确地识别出从单个[核苷](@entry_id:195320)酸变化到大规模[染色体重排](@entry_id:268124)的各类变异？弥合[变异检测](@entry_id:177461)的计算原理与其实际生物学及临床应用之间的鸿沟，是现代生物信息学家的核心任务。

本文旨在系统性地应对这一挑战。在接下来的内容中，我们将首先深入“原理与机制”章节，剖析[变异检测](@entry_id:177461)背后的统计学基础和算法设计，从[序列比对](@entry_id:172191)的“种子-延伸”策略到变异检出的[贝叶斯推断](@entry_id:146958)框架。随后，在“应用与跨学科连接”章节中，我们将展示这些理论如何转化为强大的工具，应用于[临床遗传学](@entry_id:260917)、药物基因组学、癌症研究和进化生物学等多个前沿领域。最后，通过一系列精心设计的“动手实践”，您将有机会亲手实现和应用这些关键分析方法。让我们从理解基因组变异分析的基石——其核心原理与机制——开始。

## 原理与机制

本章旨在深入阐述基因组变异分析背后的核心原理和计算机制。我们将从变异的基本分类开始，系统性地探讨如何从原始测[序数](@entry_id:150084)据中检测和解释这些变异。我们将详细介绍序列比对、变异检出、基因分型和质量评估的统计基础，并最终讨论当前方法学的局限性以及旨在克服这些挑战的前沿方法。

### 基因组变异的分类：从SNP到[结构变异](@entry_id:173359)

基因组变异是指个体或群体之间DNA序列的差异。尽管存在多种分类体系，但在[计算基因组学](@entry_id:177664)中，通常根据变异的大小和分子机制将其分为三大类：[单核苷酸多态性](@entry_id:173601)（SNP）、小片段插入和缺失（indels）以及[结构变异](@entry_id:173359)（SV）。

- **[单核苷酸多态性](@entry_id:173601) (Single Nucleotide Polymorphisms, SNPs)** 是指基因组中特定位点上单个[核苷](@entry_id:195320)酸的替换。例如，在某个位点，一部分人是腺嘌呤（A），而另一部分人是鸟嘌呤（G）。这是最简单、最常见的变异类型。

- **小片段插入和缺失 (Insertion-Deletion Variants, indels)** 指的是DNA序列中一个或多个核苷酸的插入或缺失。这些变异的长度范围通常被定义为从 $1$ 个碱基对（bp）到 $49$ 个碱基对。

- **结构变异 (Structural Variants, SVs)** 是指更大规[模的基](@entry_id:156416)因组改变。按照惯例，任何长度大于等于 $50$ bp的变异均被归类为[结构变异](@entry_id:173359)。这个范畴涵盖了多种变异类型，包括大片段的缺失、插入、串联重复（tandem duplications）、倒位（inversions）和易位（translocations）。

您可能会问，为何在indels和SVs之间存在一个像 $50$ bp这样看似武断的界限？这个界限并非源于生物学机制的根本转变，而是主要由检测这些变异的技术手段和算法能力决定的。对于短读长的新一代测序（NGS）数据，检测不同规模变异的方法存在显著差异 [@problem_id:4568974]。

对于SNP和小indels，标准的[序列比对](@entry_id:172191)算法（如基于BWA或[Smith-Waterman](@entry_id:175582)的算法）能够通过在比对中引入错配（mismatch）或小间隙（gap）来处理它们。这些算法可以在近乎单个碱基的精度上确定变异的断点（breakpoint）。然而，当indel的长度增加到几十个碱基时，比对算法引入一个长间隙的罚分会变得非常高，导致读长（read）被“软剪切”（soft-clipped，即部分读长未比对）或完全无法比对。

因此，对于长度超过约 $50$ bp的变异，我们需要依赖不同的信号进行检测。这些信号包括：

1.  **读长对不一致信号（Discordant read-pair signals）**：在[双端测序](@entry_id:272784)中，一对读长（read pair）的插入片段大小（insert size）和方向（orientation）通常遵循一个已知的分布。SVs可以导致读长对比对到[参考基因组](@entry_id:269221)时出现异常的距离或方向。
2.  **分割读长信号（Split-read signals）**：单个读长跨越了一个SV的断点，导致其被比对到[参考基因组](@entry_id:269221)上的两个不连续位置。
3.  **读长深度信号（Read-depth signals）**：大片段的缺失或重复分别导致基因组特定区域的比对读长数量减少或增加。

这些SV检测信号的断点解析度通常受限于测序参数，如读长长度 $L$、插入片段大小的均值 $\mu$ 和标准差 $\sigma$，其精度往往只有几十到几百个碱基。因此，$50$ bp的边界是一个**操作上和实用主义上**的划分，它区分了主要依赖[局部比对](@entry_id:164979)算法的小变异和需要专门的、基于不同信号的SV检测算法的大变异 [@problem_id:4568974]。

### 基础步骤：将读长比对至基因组

在检测任何变异之前，首要任务是将数百万条短测序读长准确地放置回它们在参考基因组上的原始位置。这个过程称为**[序列比对](@entry_id:172191)（sequence alignment）**。现代高通量比对工具，如BWA和Bowtie2，普遍采用一种高效的**“种子-延伸”（seed-and-extend）**策略。

#### “种子-延伸”范式及其计算成本

该策略首先从读长中提取短的、完全匹配的子序列，称为**种子（seeds）**或$k$-mers。然后，使用一种高效的数据结构，如基于**伯罗斯-惠勒变换（Burrows-Wheeler Transform, BWT）**和**[FM索引](@entry_id:273589)（FM-index）**，在整个基因组中快速定位这些种子的所有出现位置。每个种子匹配的位置都成为一个候选的比对区域。最后，在这些候选区域周围，算法执行更精细（但计算成本更高）的动态规划比对（如[Smith-Waterman算法](@entry_id:179006)），以确定最佳的完整比对。

这种方法的计算成本可以被建模分析。假设基因组长度为 $n$，读长长度为 $L$，我们以每碱基 $\rho$ 的密度从读长中提取长度为 $s$ 的种子。使用[FM索引](@entry_id:273589)进行一次种子搜索的成本与种子长度成正比，记为 $c_b s$。对于每个找到的种子匹配，我们执行一次延伸比对，其平均成本为 $c_x$。在一个随机的基因组模型中，一个长度为 $s$ 的特定种子在基因组中出现的期望次数是 $n \cdot 4^{-s}$。因此，比对一条读长的总期望时间 $T_{total}$ 可以表示为所有种子的搜索时间与所有种子匹配的延伸时间的总和 [@problem_id:4569011]：
$$ T_{total} = \rho L (c_b s + n c_x 4^{-s}) $$
这个公式清晰地揭示了算法设计中的一个核心权衡：增加种子长度 $s$ 会增加搜索成本（$c_b s$ 项），但会指数级地减少在基因组中的随机匹配次数（$n c_x 4^{-s}$ 项），从而降低了昂贵的延伸比对步骤的负担。选择最优的 $s$ 是平衡速度和敏感性的关键。

#### [量化不确定性](@entry_id:272064)：[比对质量](@entry_id:170584)（Mapping Quality, MQ）分数

由于重复序列和基因组结构变异（如拷贝数重复）的存在，一条读长有时可以几乎同等好地比对到基因组的多个位置。在这种情况下，我们如何评估比对位置的置信度？这就是**[比对质量](@entry_id:170584)（Mapping Quality, MQ）**的用武之地。MQ是一个Phred标度的分数，它量化了比对位置是错误的的概率。

MQ的计算基于贝叶斯定理。假设一条读长有两个候选比对位置 $A$ 和 $B$。我们需要计算该读长真实来源于位置 $A$ 的后验概率 $P(H_A | D)$，其中 $D$ 是观测到的读长[序列数据](@entry_id:636380)。根据贝叶斯公式：
$$ P(H_A | D) = \frac{P(D | H_A) P(H_A)}{P(D | H_A) P(H_A) + P(D | H_B) P(H_B)} $$
这里，$P(D | H_A)$ 是给定读长来源于 $A$ 时观测到该读长序列的**似然性（likelihood）**，它由比对得分决定。$P(H_A)$ 是读长来源于 $A$ 的**[先验概率](@entry_id:275634)**，它可以由其他信息推断，例如该区域的拷贝数。

考虑一个场景，由于一个已知的拷贝数重复，位置 $A$ 的拷贝数为 $c_A = 3$，而位置 $B$ 的拷贝数为 $c_B = 1$。我们可以假设[先验概率](@entry_id:275634)与拷贝数成正比，即 $P(H_A) = \frac{c_A}{c_A+c_B} = 0.75$，$P(H_B) = \frac{c_B}{c_A+c_B} = 0.25$。如果两个位置的比对得分完全相同，导致它们的似然性 $P(D|H_A)$ 和 $P(D|H_B)$ 相等，那么后验概率将完全由[先验概率](@entry_id:275634)决定，即 $P(H_A|D)=0.75$ 和 $P(H_B|D)=0.25$ [@problem_id:4568975]。

在这种情况下，位置 $A$ 是**最大后验（maximum a posteriori, MAP）**位置。比对错误的概率 $P(\text{mis-map})$ 就是该读长实际上来自所有其他可能位置的概率之和，这里即 $P(H_B|D) = 0.25$。[比对质量](@entry_id:170584)MQ的定义是：
$$ MQ = -10 \log_{10} P(\text{mis-map}) $$
对于这个例子，MQ将是 $-10 \log_{10}(0.25) \approx 6.02$。一个高的M[Q值](@entry_id:265045)（例如，$30$ 对应于 $0.001$ 的错误率）表示比对位置非常可信，而一个低的MQ值则警示我们该读长的比对可能存在歧义，基于该读长的变异检出结果也应被谨慎对待。

### 小变异检出的统计框架

在读长被比对到[参考基因组](@entry_id:269221)后，变异检出器会检查每个位点，以统计学的方式判断是否存在与参考序列不一致的变异。

#### 基因型似然：从数据中量化证据

变异检出的第一步是计算**基因型似然（genotype likelihood）**，即 $P(D|G)$。它表示在给定一个特定候选基因型 $G$（例如，对于二倍体生物，可能是纯合参考型A/A，杂合型A/G，或纯合变异型G/G）的条件下，观测到实际测[序数](@entry_id:150084)据 $D$（即比对到该位点的所有读长的碱基）的概率。

计算基因型似然基于几个核心假设 [@problem_id:4568984]：
1.  **读长的条件独立性**：给定真实基因型，每条读长提供的碱基信息是相互独立的。
2.  **测序错误模型**：每个碱基的测序错误由其对应的**Phred[质量分数](@entry_id:161575)（Q-score）**来量化。$Q = -10 \log_{10}(e)$，其中 $e$ 是该碱基的错误识别概率。一个正确的碱基被观测到的概率是 $1-e$，而一个特定的错误碱基（例如，真实是A，却被读成T）被观测到的概率是 $e/3$（假设三种错误替换是等概率的）。
3.  **等位基因抽样模型**：对于一个[二倍体](@entry_id:268054)杂合基因型（如A/G），我们假设来自父本和母本染色体的等位基因被测序到的概率是均等的，即各为 $0.5$。

基于这些假设，我们可以构建[似然函数](@entry_id:141927)。由于读长是独立的，总似然是每条读长似然的乘积：
$$ P(D|G) = \prod_{i=1}^{n} P(d_i | G) $$
其中 $d_i$ 是第 $i$ 条读长在该位点观测到的碱基。对于单条读长，其似然 $P(d_i | G)$ 通过对基因型中所有等位基因进行边缘化来计算。例如，对于杂合基因型 $G = A_1/A_2$：
$$ P(d_i | G) = \frac{1}{2} P(d_i | \text{真等位基因是 } A_1) + \frac{1}{2} P(d_i | \text{真等位基因是 } A_2) $$
$P(d_i | \text{真等位基因是 } A_k)$ 这一项则由该读长的Phred[质量分数](@entry_id:161575)决定的测序错误模型给出。例如，假设我们评估杂合基因型 $G=\text{A}/\text{G}$，并且在一条质量为Q30（$e=0.001$）的读长上观测到碱基'A'。该观测的似然为：
$$ P(\text{'A'} | \text{A/G}) = \frac{1}{2} P(\text{'A'} | \text{真等位基因是 A}) + \frac{1}{2} P(\text{'A'} | \text{真等位基因是 G}) $$
$$ = \frac{1}{2}(1 - e) + \frac{1}{2}\left(\frac{e}{3}\right) = \frac{1}{2}\left(1 - \frac{2e}{3}\right) = \frac{1}{2}\left(1 - \frac{2 \cdot 0.001}{3}\right) \approx 0.49967 $$
通过将所有覆盖该位点的读长的似然值相乘，我们就得到了该位点支持杂合基因型A/G的总似然值。同理，我们可以计算出纯合参考型（如A/A）和纯合变异型（如G/G）的似然值。

#### 用于基因分型的[贝叶斯推断](@entry_id:146958)

拥有了针对不同候选基因型的似然值 $P(D|G)$ 后，我们如何做出最终的基因型判断？仅凭似然值最大是不够的，因为它没有考虑不同基因型在群体中出现的频率可能存在巨大差异。例如，一个罕见变异的纯合[子基](@entry_id:152709)因型本身就是极小概率事件。这里，我们再次使用[贝叶斯定理](@entry_id:151040)，结合先验知识来计算**基因型后验概率（posterior probability）** $P(G|D)$：
$$ P(G|D) = \frac{P(D|G) P(G)}{P(D)} $$
$P(G)$ 是基因型的**[先验概率](@entry_id:275634)**。一个常见的先验模型是基于**哈迪-温伯格平衡（Hardy–Weinberg Equilibrium, HWE）**。如果一个变异等位基因在群体中的频率为 $p$，那么三种基因型（0/0, 0/1, 1/1）的先验概率分别为 $(1-p)^2$、$2p(1-p)$ 和 $p^2$ [@problem_id:4568980]。

通过将每个候选基因型的似然 $P(D|G)$ 与其先验概率 $P(G)$ 相乘，我们得到一个与后验概率成正比的值。然后通过对所有基因型的该乘积求和进行归一化，即可得到每个基因型的确切后验概率。具有最高后验概率的基因型即为**最大后验（MAP）**估计，也就是我们最终的基因型检出结果。

例如，假设一个位点的备选等位基因频率为 $p=0.20$，测[序数](@entry_id:150084)据（$n=30$ 条读长，其中 $k=27$ 条支持备选等位基因）强烈支持纯合变异基因型 $1/1$（即 $P(D|G=1/1)$ 极高）。然而，该基因型的[先验概率](@entry_id:275634)非常低（$p^2=0.04$）。贝叶斯框架能够平衡这两方面的信息。在这种压倒性的数据证据下，即使先验概率很低，最终的后验概率 $P(G=1/1|D)$ 仍然会是最高的，从而正确地检出 $1/1$ 基因型 [@problem_id:4568980]。

#### 从后验概率到基因型质量（GQ）

正如比对有MQ来[量化不确定性](@entry_id:272064)，基因分型也有一个质量分数——**基因型质量（Genotype Quality, GQ）**。GQ衡量的是我们对检出的MAP基因型有多自信。它的定义与MQ类似，是MAP基因型错误的后验概率的Phred标度值。

如果 $G_{\text{MAP}}$ 是我们检出的基因型，那么该检出是错误的概率就是所有其他基因型后验概率之和，即 $P(\text{error}|D) = 1 - P(G_{\text{MAP}}|D)$。GQ的计算公式为 [@problem_id:4568990]：
$$ \mathrm{GQ} = -10 \log_{10}(P(\text{error} | D)) = -10 \log_{10}(1 - P(G_{\text{MAP}} | D)) $$
例如，如果计算出的MAP基因型 $G_{\text{MAP}} = \text{AB}$ 的后验概率为 $P(\text{AB}|D) = 0.99999589$，那么[错误概率](@entry_id:267618)约为 $4.1 \times 10^{-6}$。对应的G[Q值](@entry_id:265045)为 $-10 \log_{10}(4.1 \times 10^{-6}) \approx 53.87$。这个高GQ值表明，基于数据和先验模型，我们对这个杂合基因型的判断具有极高的[置信度](@entry_id:267904)。在后续分析中，研究人员通常会使用GQ值来过滤掉低质量的基因型检出结果。

#### 基因型的标准化表示

为了实现数据交换和分析的标准化，基因组变异信息通常以**变异检出格式（Variant Call Format, VCF）**文件存储。VCF为表示基因型及其相关属性（如GQ）提供了规范。对于一个有 $k$ 个等位基因（0代表参考，1至$k-1$代表备选）的位点，一个二倍体基因型是一个由两个等位基因组成的无序集合。可能的无序基因型总数为 $\binom{k+1}{2}$ [@problem_id:4569029]。

VCF标准定义了一种对这些基因型进行线性索引的明确顺序。对于一个基因型 $i/j$（其中约定 $i \leq j$），其索引是按 $j$ 主要递增，再按 $i$ 次要递增的顺序排列的。例如，对于3个等位基因（0, 1, 2），顺序是0/0, 0/1, 1/1, 0/2, 1/2, 2/2。一个基因型 $i/j$ 的从零开始的索引 $f(i, j)$ 可以通过计算排在它前面的基因型数量来得出，其公式为：
$$ f(i,j) = \frac{j(j+1)}{2} + i $$
这个公式对于存储和检索与特定基因型相关的似然值数组（如VCF中的PL字段）至关重要，它确保了不同软件工具之间的一致性 [@problem_id:4569029]。

### 检测大规模[基因组重排](@entry_id:184390)：结构变异

与依赖局部错配或小间隙信号的SNP和indel不同，[结构变异](@entry_id:173359)（SVs）的检测依赖于更大尺度上的信号，这些信号通常由[双端测序](@entry_id:272784)数据提供。

#### [双端测序](@entry_id:272784)数据中的[结构变异](@entry_id:173359)信号

在标准的[双端测序](@entry_id:272784)中，DNA片段两端的读长被测序，形成一个读长对。当这些读长对比对到[参考基因组](@entry_id:269221)时，我们期望它们的**插入片段大小**（比对位置间的距离）落在一个特定分布内（例如，均值为 $350$ bp，标准差为 $60$ bp），并且它们的**方向**是向内相对的（`--> --`，即上游读长在正链，下游读长在负链，记为FR）。SVs会破坏这种预期的模式，产生“不一致”的读长对。关键的信号包括：

- **大插入片段（Large insert）**：读长对之间的比对距离远大于预期的 $\mu + 3\sigma$。这通常是**缺失（deletion）**的标志。
- **小插入片段（Small insert）**：比对距离远小于预期。这可能是**插入（insertion）**的标志。
- **方向异常（Orientation anomalies）**：
    - **RR (`-- --`)** 或 **FF (`--> -->`)**：两个读长都比对到同一条链上。
    - **RF (`-- -->`，但顺序反了)**：下游读长在正链，上游读长在负链。

这些不一致的信号组合在一起，可以揭示特定类型的SV。

#### 案例研究：从读长方向推断倒位

考虑一个典型的**倒位（inversion）**事件，即基因组中的一个片段被翻转。这会在该片段的两端产生两个新的连接点。当测序片段跨越这两个连接点时，就会产生特征性的信号 [@problem_id:4568996]。

假设一个片段 $[x_L, x_R]$ 发生了倒位。
- 在左侧断点 $x_L$ 处，一个测序片段的一端位于倒位片段的外部（$x_L$ 的左侧），另一端位于倒位片段的内部（紧邻 $x_L$ 的右侧）。当比对回未倒位的[参考基因组](@entry_id:269221)时，这对读长都会比对到正链上，形成一个 **FF (`--> -->`)** 的方向特征。
- 在右侧断点 $x_R$ 处，一个跨越该断点的测序片段会产生一对都比对到负链上的读长，形成一个 **RR (`-- --)** 的方向特征。

因此，如果在基因组的某个区域，我们在位置 $x_L$ 附近观察到一个FF读长对簇，并在位置 $x_R$ 附近观察到一个RR读长对簇，同时没有观察到提示缺失的大插入片段FR信号，那么这就是一个强有力的证据，表明 $[x_L, x_R]$ 区间发生了一次倒位 [@problem_id:4568996]。通过系统地寻找这些不一致的读长对信号，SV检出工具能够识别和分类各种复杂的[基因组重排](@entry_id:184390)事件。

### 高级主题：应对线性参考的局限性

尽管上述方法构成了基因组变异分析的标准流程，但它们都基于一个核心假设：将所有个体的序列与一个单一的、线性的参考基因组进行比较。这种方法存在固有的局限性，其中最主要的是**参考偏倚**。

#### 参考偏倚的挑战

**参考偏倚（Reference bias）**是指在[序列比对](@entry_id:172191)和变异检出过程中，算法系统性地偏好与参考基因组更相似的序列解释的现象。当一条读长真实地来源于一个包含变异（特别是indel）的等位基因时，如果将这条读长错误地比对到[参考基因组](@entry_id:269221)上（例如，通过引入多个错配或软剪切）能够得到比正确地引入一个indel更高的比对分数，那么这个变异就可能被漏检。

这个问题在[低复杂度区域](@entry_id:176542)（如均聚物，即连续重复的单个碱基）尤为严重 [@problem_id:4569017]。考虑一个场景：参考基因组有一个30个A的均聚物，而某个体的等位基因在此处有一个6 bp的插入，形成了一个36个A的均聚物。一条长为100 bp、来自该变异等位基因的读长，包含了这6个额外的A。

当比对器评估不同的比对可能性时：
1.  **正确模型（有间隙）**：将94个碱基作为匹配，并引入一个6 bp的插入。其得分将因间隙罚分（包括开放罚分和延伸罚分）而降低。
2.  **错误模型（软剪切）**：将94个碱基作为匹配，并将读长末端那6个无法匹配的碱基“软剪切”掉。如果软剪切的罚分为零或很低，这个比对的得分可能会高于正确模型。
3.  **错误模型（错配）**：在均聚物区域，比对器也可能通过轻微移动读长位置，将插入解释为多个错配。

在许多标准比对参数下，软剪切或错配模型的得分可能高于引入一个中等长度间隙的得分。结果，比对器会选择一个不包含indel的错误比对，导致下游的变异检出器无法看到这个真实的插入事件。此外，种子选择策略也加剧了这个问题。在均聚物区域，所有长度为 $k$ 的种子（如$k=21$）都是相同的（例如，21个A），这些种子在基因组中大量重复，会被算法作为无信息种子而丢弃。这进一步降低了在这些挑战性区域正确锚定读长的能力 [@problem_id:4569017]。

#### [泛基因组学](@entry_id:173769)：使用变异图谱构建更完整的表示

为了克服参考偏倚和其他与线性参考相关的限制，**[泛基因组学](@entry_id:173769)（pangenomics）**应运而生。其核心思想是用一个**变异图谱（variation graph）**来表示一个群体中的所有已知基因组变异，而不是选择任意一个序列作为参考。

在一个典型的变异图谱中，节点（node）代表DNA序列片段，有向边（edge）代表这些片段之间的合法连接关系。任何一个单倍型（haplotype）或染色体序列都可以表示为图中的一条路径 [@problem_id:4568950]。例如，一个包含indel的位点可以被建模为一个“气泡”结构：参考路径穿过一个节点（如 $v_{2a}$，代表参考序列），而备选路径穿过另一个平行的节点（如 $v_{2b}$，代表包含indel的序列）。

这种图谱结构从根本上改变了坐标系统的概念。在线性参考中，一个位置由单个整数表示。但在变异图谱中，一个位置必须由一个路径和该路径上的偏移量来共同定义。一个位置可以表示为一个元组 `(path, offset)` 或更底层的 `(node, offset_in_node)`。

考虑一个例子，参考路径 $R$ 依次穿过节点 $v_1, v_{2a}, v_3$，其长度分别为 $10, 5, 12$。备选路径 $A$ 则穿过 $v_1, v_{2b}, v_3$，其中节点 $v_{2b}$ 的长度为 $7$。对于沿路径从头计数的第 $17$ 个碱基（索引为17）：
- 在路径 $R$ 上，它落在节点 $v_3$ 的内部，偏移量为 $17 - (10+5) = 2$。坐标为 $(v_3, 2)$。
- 在路径 $A$ 上，它恰好落在节点 $v_3$ 的起始处，偏移量为 $17 - (10+7) = 0$。坐标为 $(v_3, 0)$。

这个简单的例子表明，在变异图谱中，同一个“线性”索引值在不同单倍型路径上可能对应于不同的节点或节点内的不同位置 [@problem_id:4568950]。这种以图为中心的坐标系统消除了单一参考的特权地位，为实现更公平、更全面的基因组分析提供了理论基础。