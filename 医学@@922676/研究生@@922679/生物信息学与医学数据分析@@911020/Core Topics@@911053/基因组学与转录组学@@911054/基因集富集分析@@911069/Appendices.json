{"hands_on_practices": [{"introduction": "基因集富集分析（Gene Set Enrichment Analysis, GSEA）的核心是其独特的“运行总和”统计量。要真正掌握GSEA，我们必须首先理解这个分数是如何从头计算的。这个练习将引导您手动完成一个简化的GSEA计算过程 ([@problem_id:4567424])，通过在一个小基因列表上追踪运行总和的变化，揭示富集分数（Enrichment Score, ES）的计算机制。这种第一性原理的实践有助于我们建立对GSEA算法内部运作的直观理解，这是解读更复杂分析结果的基础。", "problem": "给定一个来自转录组差异表型分析的预排序基因列表，每个基因都与一个排序指标值相关联，该值被解释为与表型相关的相关系数的绝对值。任务是从第一性原理出发，使用类似于Kolmogorov–Smirnov的运行总和定义，计算权重参数 $p=1$ 时的基因集富集分析（GSEA）富集分数，然后识别出前导子集。请勿使用任何预先记忆的快捷公式；相反，应根据命中和未命中的经验累积分布函数的定义，明确地构建运行总和过程。\n\n基因总数为 $N=10$，从最相关到最不相关的排序列表如下：\n1. MYC，分数 $10$\n2. TP53，分数 $9$\n3. EGFR，分数 $8$\n4. BRCA1，分数 $7$\n5. PTEN，分数 $6$\n6. KRAS，分数 $5$\n7. AKT1，分数 $4$\n8. BRAF，分数 $3$\n9. MDM2，分数 $2$\n10. CDK2，分数 $1$\n\n考虑大小为 $|S|=3$ 的基因集 $S=\\{\\text{TP53}, \\text{KRAS}, \\text{MDM2}\\}$。使用权重参数 $p=1$，使得在命中时，运行总和的增加值与该基因的分数成正比，并按 $S$ 中所有基因的总分进行归一化；而在未命中时，运行总和减少一个常数，使得所有未命中的总减少量等于 $1$。\n\n从命中和未命中的经验累积分布函数及其沿排序列表的差异的定义出发，手动计算：\n- 富集分数（ES），即运行总和与零的最大偏差，以及\n- 达到富集分数位置所对应的前导子集。\n\n将富集分数表示为一个精确的既约分数（不要四舍五入），不带单位。最终答案应仅为富集分数。", "solution": "用户提供的问题陈述经过了验证过程。\n\n### 第1步：提取已知条件\n- 排序列表中的基因总数：$N=10$。\n- 带有分数的基因排序列表（解释为绝对相关性）：\n  1. MYC (分数 $10$)\n  2. TP53 (分数 $9$)\n  3. EGFR (分数 $8$)\n  4. BRCA1 (分数 $7$)\n  5. PTEN (分数 $6$)\n  6. KRAS (分数 $5$)\n  7. AKT1 (分数 $4$)\n  8. BRAF (分数 $3$)\n  9. MDM2 (分数 $2$)\n  10. CDK2 (分数 $1$)\n- 目标基因集：$S=\\{\\text{TP53}, \\text{KRAS}, \\text{MDM2}\\}$。\n- 基因集大小：$N_H = |S|=3$。\n- 权重参数：$p=1$。\n- 命中增量规则：对于 $S$ 中的基因，运行总和增加一个与该基因分数成正比的值，该值按 $S$ 中所有基因的总分进行归一化。\n- 未命中减量规则：对于不在 $S$ 中的基因，运行总和减少一个恒定值，使得所有未命中的总减量等于 $1$。\n- 富集分数（ES）的定义：运行总和与零的最大偏差。\n- 任务：从第一性原理出发，使用由经验累积分布函数定义的运行总和，计算ES和前导子集。\n\n### 第2步：使用提取的已知条件进行验证\n这个问题具有科学依据，因为它描述了基因集富集分析（GSEA）的一个标准（尽管简化了）的流程，而GSEA是生物信息学中一个成熟的方法。使用权重 $p=1$ 的加权类Kolmogorov-Smirnov统计量是一种有效的GSEA变体。所有必要的数据（$N$、排序列表、分数、基因集 $S$ 以及运行总和的规则）都已提供，使得问题定义良好且自洽。语言客观，数据内部一致。该问题不违反任何无效标准。\n\n### 第3步：结论和行动\n问题被判定为 **有效**。将提供解答。\n\n### 解答\n基因集富集分析（GSEA）的富集分数（ES）是通过沿基因排序列表 $L$ 遍历并计算一个运行总和统计量来得到的。ES是这个运行总和与零的最大偏差。排序列表中任意位置 $i$ 的运行总和是存在于基因集 $S$ 中的基因（命中）的加权经验累积分布函数与不在 $S$ 中的基因（未命中）的经验累积分布函数之间的差值。\n\n首先，我们在排序列表中识别出命中和未命中的基因。基因总数为 $N=10$。基因集 $S=\\{\\text{TP53}, \\text{KRAS}, \\text{MDM2}\\}$ 包含 $N_H = |S| = 3$ 个基因（命中）。不在 $S$ 中的基因数量为 $N_M = N - N_H = 10 - 3 = 7$ （未命中）。\n\n带有命中/未命中状态和分数 ($r_j$) 的排序列表如下：\n1. MYC, $r_1=10$ (未命中)\n2. TP53, $r_2=9$ (命中)\n3. EGFR, $r_3=8$ (未命中)\n4. BRCA1, $r_4=7$ (未命中)\n5. PTEN, $r_5=6$ (未命中)\n6. KRAS, $r_6=5$ (命中)\n7. AKT1, $r_7=4$ (未命中)\n8. BRAF, $r_8=3$ (未命中)\n9. MDM2, $r_9=2$ (命中)\n10. CDK2, $r_{10}=1$ (未命中)\n\n排序为 $i$ 时的运行总和，记为 $ES_i$，定义为 $ES_i = P_{hit}(S, i) - P_{miss}(S, i)$。\n\n项 $P_{hit}(S, i)$ 是命中的加权经验累积分布。当权重参数 $p=1$ 时，其计算方式如下：\n$$P_{hit}(S, i) = \\sum_{g_j \\in S, j \\le i} \\frac{r_j}{N_R}$$\n其中 $N_R$ 是归一化因子，等于 $S$ 中所有基因的分数之和：\n$$N_R = \\sum_{g_j \\in S} r_j = r_{\\text{TP53}} + r_{\\text{KRAS}} + r_{\\text{MDM2}} = 9 + 5 + 2 = 16$$\n当我们在排序 $j$ 处遇到一个分数为 $r_j$ 的命中基因 $g_j \\in S$ 时，运行总和增加 $\\frac{r_j}{N_R} = \\frac{r_j}{16}$。\n\n项 $P_{miss}(S, i)$ 是未命中的经验累积分布：\n$$P_{miss}(S, i) = \\sum_{g_j \\notin S, j \\le i} \\frac{1}{N_M}$$\n其中 $N_M = 7$。当我们在排序 $j$ 处遇到一个未命中基因 $g_j \\notin S$ 时，运行总和减少 $\\frac{1}{N_M} = \\frac{1}{7}$。\n\n现在我们计算排序列表中每个基因 $g_i$ 的运行总和 $ES_i$，从 $ES_0=0$ 开始。\n\n1.  **基因 1 (MYC, 未命中):**\n    $P_{hit}(S, 1) = 0$。$P_{miss}(S, 1) = \\frac{1}{7}$。\n    $ES_1 = 0 - \\frac{1}{7} = -\\frac{1}{7} = -\\frac{16}{112}$。\n\n2.  **基因 2 (TP53, 命中, 分数=9):**\n    $P_{hit}(S, 2) = \\frac{9}{16}$。$P_{miss}(S, 2) = \\frac{1}{7}$。\n    $ES_2 = \\frac{9}{16} - \\frac{1}{7} = \\frac{63 - 16}{112} = \\frac{47}{112}$。\n\n3.  **基因 3 (EGFR, 未命中):**\n    $P_{hit}(S, 3) = \\frac{9}{16}$。$P_{miss}(S, 3) = \\frac{2}{7}$。\n    $ES_3 = \\frac{9}{16} - \\frac{2}{7} = \\frac{63 - 32}{112} = \\frac{31}{112}$。\n\n4.  **基因 4 (BRCA1, 未命中):**\n    $P_{hit}(S, 4) = \\frac{9}{16}$。$P_{miss}(S, 4) = \\frac{3}{7}$。\n    $ES_4 = \\frac{9}{16} - \\frac{3}{7} = \\frac{63 - 48}{112} = \\frac{15}{112}$。\n\n5.  **基因 5 (PTEN, 未命中):**\n    $P_{hit}(S, 5) = \\frac{9}{16}$。$P_{miss}(S, 5) = \\frac{4}{7}$。\n    $ES_5 = \\frac{9}{16} - \\frac{4}{7} = \\frac{63 - 64}{112} = -\\frac{1}{112}$。\n\n6.  **基因 6 (KRAS, 命中, 分数=5):**\n    $P_{hit}(S, 6) = \\frac{9}{16} + \\frac{5}{16} = \\frac{14}{16}$。$P_{miss}(S, 6) = \\frac{4}{7}$。\n    $ES_6 = \\frac{14}{16} - \\frac{4}{7} = \\frac{7}{8} - \\frac{4}{7} = \\frac{49 - 32}{56} = \\frac{17}{56} = \\frac{34}{112}$。\n\n7.  **基因 7 (AKT1, 未命中):**\n    $P_{hit}(S, 7) = \\frac{14}{16}$。$P_{miss}(S, 7) = \\frac{5}{7}$。\n    $ES_7 = \\frac{14}{16} - \\frac{5}{7} = \\frac{7}{8} - \\frac{5}{7} = \\frac{49 - 40}{56} = \\frac{9}{56} = \\frac{18}{112}$。\n\n8.  **基因 8 (BRAF, 未命中):**\n    $P_{hit}(S, 8) = \\frac{14}{16}$。$P_{miss}(S, 8) = \\frac{6}{7}$。\n    $ES_8 = \\frac{14}{16} - \\frac{6}{7} = \\frac{7}{8} - \\frac{6}{7} = \\frac{49 - 48}{56} = \\frac{1}{56} = \\frac{2}{112}$。\n\n9.  **基因 9 (MDM2, 命中, 分数=2):**\n    $P_{hit}(S, 9) = \\frac{14}{16} + \\frac{2}{16} = \\frac{16}{16} = 1$。$P_{miss}(S, 9) = \\frac{6}{7}$。\n    $ES_9 = 1 - \\frac{6}{7} = \\frac{1}{7} = \\frac{16}{112}$。\n\n10. **基因 10 (CDK2, 未命中):**\n    $P_{hit}(S, 10) = 1$。$P_{miss}(S, 10) = \\frac{7}{7} = 1$。\n    $ES_{10} = 1 - 1 = 0$。\n\n运行总和值的序列为： $\\{-\\frac{16}{112}, \\frac{47}{112}, \\frac{31}{112}, \\frac{15}{112}, -\\frac{1}{112}, \\frac{34}{112}, \\frac{18}{112}, \\frac{2}{112}, \\frac{16}{112}, 0\\}$。\n\n富集分数（ES）是此运行总和与零的最大偏差。这是运行总和绝对值的最大值：\n$$ES = \\max_{i=1,\\ldots,10} |ES_i|$$\n集合中的最大值为 $ES_2 = \\frac{47}{112}$。最小值为 $ES_1 = -\\frac{16}{112}$。\n与零的最大偏差为 $\\max(\\frac{47}{112}, |-\\frac{16}{112}|) = \\max(\\frac{47}{112}, \\frac{16}{112}) = \\frac{47}{112}$。\n因此，富集分数为 $\\frac{47}{112}$。数字 $47$ 是素数，不能整除 $112 = 2^4 \\times 7$，所以这个分数是其最简形式。\n\n前导子集由基因集 $S$ 中，在排序列表中出现于最大富集分数所在位置（及之前）的基因组成。最大分数 $ES = \\frac{47}{112}$ 出现在排序位置 $i=2$ 处。排序列表到位置 $2$ 为止的基因是 $\\{\\text{MYC}, \\text{TP53}\\}$。这个集合与基因集 $S$ 的交集是 $\\{\\text{TP53}\\}$。因此，前导子集是 $\\{\\text{TP53}\\}$。", "answer": "$$\\boxed{\\frac{47}{112}}$$", "id": "4567424"}, {"introduction": "在通过手动计算掌握了GSEA的基本步骤后，我们可以通过一个思想实验来加深理解。这个练习 ([@problem_id:2393962]) 要求我们推导当基因集仅包含一个基因时富集分数的封闭形式表达式。通过将算法简化到其最核心的逻辑，我们不仅能锻炼分析推理能力，还能直观地揭示富集分数与基因排序之间的确定性关系，从而深化对GSEA行为的洞察。", "problem": "考虑将基因集富集分析（GSEA; Gene Set Enrichment Analysis）应用于一个已排序的基因列表。假设有一个包含 $N$ 个不同基因的排序列表 $\\mathcal{L}$，其排名从 $1$（顶部）到 $N$（底部）。假设基因集 $\\mathcal{S}$ 只包含一个基因（因此 $N_H = |\\mathcal{S}| = 1$），并且这个基因在列表 $\\mathcal{L}$ 中的排名为 $k \\in \\{1,2,\\dots,N\\}$。使用指数为 $p \\ge 0$ 的 GSEA 标准加权移动总和定义：当从 $i=1$ 到 $i=N$ 向下扫描列表时，移动总和 $R(i)$ 定义如下。如果排名第 $i$ 的基因在 $\\mathcal{S}$ 中，则将 $R(i)$ 增加 $|r_i|^{p} / NR$，其中 $NR = \\sum_{g \\in \\mathcal{S}} |r_g|^{p}$；如果不在 $\\mathcal{S}$ 中，则将 $R(i)$ 减少 $1/(N - N_H)$。定义富集分数 $ES$ 为沿途遇到的移动总和的最大值，即 $ES = \\max_{1 \\le i \\le N} R(i)$。请将 $ES$ 表示为仅含 $N$ 和 $k$ 的闭式函数。无需进行数值计算或四舍五入，也无需报告单位。", "solution": "### 步骤1：定义运行总和的增量和减量\n\n根据问题陈述，我们有一个包含 $N$ 个基因的排序列表。基因集 $\\mathcal{S}$ 只包含一个基因，其排名为 $k$。\n\n- **命中 (Hit)**：列表中只有一个命中基因，在排名 $k$ 处。\n  - 基因集大小 $N_H = |\\mathcal{S}| = 1$。\n  - 命中基因的加权分数归一化因子为 $NR = \\sum_{g \\in \\mathcal{S}} |r_g|^p$。因为 $\\mathcal{S}$ 中只有一个基因（我们称之为 $g_k$，其分数为 $r_k$），所以 $NR = |r_k|^p$。\n  - 当遇到这个命中基因时，运行总和的增加值为 $\\Delta_{hit} = |r_k|^p / NR = |r_k|^p / |r_k|^p = 1$。这个增量与权重指数 $p$ 和基因分数 $r_k$ 无关，始终为1。\n\n- **错过 (Miss)**：列表中有 $N_M = N - N_H = N - 1$ 个错过基因。\n  - 当遇到一个错过基因时，运行总和的减少值为 $\\Delta_{miss} = \\frac{1}{N - N_H} = \\frac{1}{N-1}$。这是一个常数。\n\n### 步骤2：追踪运行总和 $R(i)$ 的轨迹\n\n我们从 $R(0) = 0$ 开始，沿着排序列表从 $i=1$ 到 $N$ 遍历。\n\n- **对于 $i  k$ (在命中基因之前)**：\n  - 在列表的前 $k-1$ 个位置，所有基因都是错过基因。\n  - 在第 $i$ 步（其中 $i  k$），我们已经遇到了 $i$ 个错过基因。\n  - 运行总和为 $R(i) = R(0) - i \\times \\Delta_{miss} = 0 - \\frac{i}{N-1} = -\\frac{i}{N-1}$。\n  - 在这个阶段，运行总和是负数并且随着 $i$ 的增加而单调递减。\n\n- **对于 $i = k$ (在命中基因处)**：\n  - 在到达排名为 $k$ 的基因之前，运行总和是 $R(k-1) = -\\frac{k-1}{N-1}$。\n  - 在第 $k$ 步，我们遇到了命中基因，运行总和增加 $\\Delta_{hit} = 1$。\n  - 因此，$R(k) = R(k-1) + \\Delta_{hit} = -\\frac{k-1}{N-1} + 1 = \\frac{-(k-1) + (N-1)}{N-1} = \\frac{-k+1+N-1}{N-1} = \\frac{N-k}{N-1}$。\n\n- **对于 $i > k$ (在命中基因之后)**：\n  - 在第 $i$ 步（其中 $i > k$），我们已经遇到了1个命中基因和 $i-1$ 个错过基因。\n  - 运行总和为 $R(i) = (1 \\times \\Delta_{hit}) - ((i-1) \\times \\Delta_{miss}) = 1 - \\frac{i-1}{N-1}$。\n  - 在这个阶段，随着 $i$ 的增加，$\\frac{i-1}{N-1}$ 也在增加，因此 $R(i)$ 是单调递减的。\n\n### 步骤3：确定最大运行总和 (富集分数)\n\n我们已经分析了运行总和 $R(i)$ 在三个区间的行为：\n1.  在 $[1, k-1]$ 区间， $R(i)$ 从 $-\\frac{1}{N-1}$ 递减到 $-\\frac{k-1}{N-1}$。\n2.  在 $i=k$ 处，$R(k) = \\frac{N-k}{N-1}$。由于 $k \\le N$，$R(k) \\ge 0$。因此，$R(k)$ 大于前一个区间的所有值。\n3.  在 $[k+1, N]$ 区间， $R(i)$ 从 $R(k+1) = 1 - \\frac{k}{N-1} = \\frac{N-1-k}{N-1}$ 开始递减。注意到 $R(k+1)  R(k)$。\n\n由于运行总和在 $i=k$ 之后持续减小，其最大值必然在 $i=k$ 处达到。\n\n富集分数 $ES$ 定义为运行总和的最大值：\n$$ ES = \\max_{1 \\le i \\le N} R(i) = R(k) = \\frac{N-k}{N-1} $$\n\n这是一个只依赖于基因总数 $N$ 和该单个基因在列表中的排名 $k$ 的封闭形式表达式。", "answer": "$$\\boxed{\\frac{N-k}{N-1}}$$", "id": "2393962"}, {"introduction": "理论知识最终需要服务于实际数据分析。这个综合性练习 ([@problem_id:4346070]) 将引导您构建一个完整的分析流程，模拟从原始RNA测序（RNA-seq）计数数据到最终富集分数的真实生物信息学工作流。通过实现数据过滤、归一化、差异表达分析以及最终的GSEA计算，您将获得宝贵的实践经验，深刻理解在真实研究场景中，一个有意义的富集分数是如何产生的，以及其上游分析步骤的重要性。", "problem": "您接到的指令是构建一个流水线，该流水线模拟转录组学分析中基于负二项建模假设的、广泛使用的差异表达工具所生成的各基因统计输出，以产生一个适合基因集富集分析（Gene Set Enrichment Analysis, GSEA）的排序列表。教育背景为系统生物医学，主题为基因集富集分析。该流水线必须基于以下基本原理：将负二项分布作为RNA测序计数的模型，利用成分性概念进行文库大小归一化，以及使用delta方法进行方差传播。任务是为每个提供的测试用例实现一系列步骤，这些步骤需根据明确的假设来论证每个预处理操作的合理性，计算适合在GSEA中排序的各基因统计量，然后为一个提供的基因集计算经典的运行总和富集分数。\n\n使用的基本原理和假设：\n- 将基因 $g$ 在样本 $i$ 中的RNA测序计数数据建模为从均值为 $\\mu_{g,i}$、离散度为 $\\phi_{g}$ 的负二项分布（表示为 $\\operatorname{NB}(\\mu_{g,i}, \\phi_{g})$）中抽样，其方差为 $\\operatorname{Var}(Y_{g,i}) = \\mu_{g,i} + \\phi_{g} \\mu_{g,i}^{2}$。负二项概率质量函数由下式给出\n$$\nP(Y=k \\mid \\mu, \\phi) = \\frac{\\Gamma(k + \\phi^{-1})}{\\Gamma(\\phi^{-1}) \\, k!} \\left(\\frac{\\phi^{-1}}{\\phi^{-1} + \\mu}\\right)^{\\phi^{-1}} \\left(\\frac{\\mu}{\\phi^{-1} + \\mu}\\right)^{k},\n$$\n对于整数 $k \\ge 0$，$\\mu  0$ 和 $\\phi  0$。\n- 假设期望计数可分解为 $\\mu_{g,i} = s_{i} \\, \\theta_{g,i}$，其中 $s_{i}  0$ 是一个未知的样本特异性大小因子，用于捕获文库大小和成分效应，而 $\\theta_{g,i}$ 是潜在的表达水平。此成分性假设意味着，在没有绝对校准的情况下，只有 $\\theta_{g,i}$ 的比率是可识别的。\n- 使用双组设计指示符 $X_{i} \\in \\{0,1\\}$ 和对数链接的广义线性模型 $\\log(\\mu_{g,i}) = \\log(s_{i}) + \\beta_{0,g} + \\beta_{1,g} X_{i}$，将条件效应建模为对均值的倍数变化。\n- 使用delta方法来近似随机变量平滑函数的方差。特别地，对于负二项模型下的样本均值，其对数的方差通过将均值的方差除以均值的平方来近似。\n\n为每个测试用例实现的预处理步骤和统计计算：\n1. 基于可检测性的过滤：移除表达证据不足的基因，特别是那些严格正计数样本少于 $2$ 个或总计数低于所选最小值的基因。其理由是负二项离散度估计和对数倍数变化方差依赖于非退化的样本均值和方差。\n2. 文库大小归一化：使用与分解式 $\\mu_{g,i} = s_{i} \\, \\theta_{g,i}$ 一致的比率中位数原则来估计样本特异性的大小因子 $\\{s_{i}\\}$。即，估计一个伪参考的各基因量，并选择 $s_{i}$，使得对于大多数基因，$Y_{g,i} / s_{i}$ 的值都集中在参考值附近。当大量零值导致无法获得稳定的伪参考时，则退回到使用总计数归一化，即使用与文库大小成比例的 $s_{i}$，并将其标准化至均值为 $1$。\n3. 离散度估计：对于每个基因 $g$，使用矩量法从归一化计数中估计原始离散度 $\\hat{\\phi}_{g} = \\max\\{0, (\\hat{v}_{g} - \\hat{m}_{g}) / \\hat{m}_{g}^{2}\\}$，其中 $\\hat{m}_{g}$ 是归一化计数的跨样本均值，$\\hat{v}_{g}$ 是跨样本方差。然后，通过对所有基因进行最小二乘法拟合，估计一个形式为 $a + b/\\hat{m}_{g}$ 的趋势函数 $\\phi_{\\mathrm{trend}}(\\hat{m}_{g})$，并通过一个权重取决于样本数的凸组合将 $\\hat{\\phi}_{g}$ 向 $\\phi_{\\mathrm{trend}}(\\hat{m}_{g})$ 收缩，以获得一个稳定的离散度 $\\tilde{\\phi}_{g}$。\n4. 各基因效应和Wald统计量：为两种条件计算各基因的组均值 $\\hat{\\mu}_{g,0}$ 和 $\\hat{\\mu}_{g,1}$（在归一化尺度上）。使用一个小的正常数以在必要时避免除以零，从而估计对数倍数变化 $\\widehat{\\mathrm{LFC}}_{g} = \\log\\left(\\frac{\\hat{\\mu}_{g,1}}{\\hat{\\mu}_{g,0}}\\right)$。利用delta方法和负二项方差，将 $\\widehat{\\mathrm{LFC}}_{g}$ 的方差近似为\n$$\n\\widehat{\\operatorname{Var}}(\\widehat{\\mathrm{LFC}}_{g}) \\approx \\frac{\\hat{\\mu}_{g,1} + \\tilde{\\phi}_{g} \\hat{\\mu}_{g,1}^{2}}{n_{1} \\, \\hat{\\mu}_{g,1}^{2}} + \\frac{\\hat{\\mu}_{g,0} + \\tilde{\\phi}_{g} \\hat{\\mu}_{g,0}^{2}}{n_{0} \\, \\hat{\\mu}_{g,0}^{2}},\n$$\n其中 $n_{1}$ 和 $n_{0}$ 分别是处理组和对照组的样本数。定义Wald统计量 $Z_{g} = \\widehat{\\mathrm{LFC}}_{g} / \\sqrt{\\widehat{\\operatorname{Var}}(\\widehat{\\mathrm{LFC}}_{g})}$，当分母为零时，令 $Z_{g} = 0$。\n5. 为GSEA进行排序：使用 $Z_{g}$ 作为排序分数，并为一个提供的基因集计算加权运行总和富集分数。对于一个基因集 $S \\subset \\{1,\\dots,G\\}$ 和分数 $\\{Z_{g}\\}$，按 $Z_{g}$ 降序对基因进行排序，使用权重 $w_{g} = |Z_{g}|^{p}$（其中 $p=1$），并计算一个运行总和：当 $g \\in S$ 时，该总和增加 $w_{g} / \\sum_{h \\in S} w_{h}$；当 $g \\notin S$ 时，该总和减少 $1 / (G - |S|)$。富集分数是此运行总和与零之间的有符号极端偏差。\n\n测试套件：\n对于每个测试用例，您会得到一个维度为 $G \\times S$（基因 × 样本）的计数矩阵、一个长度为 $S$ 的二元条件向量，以及一个作为基因列表索引的基因集。基因名称被隐式地排序为 $G1, G2, \\dots$，对应于索引 $1, 2, \\dots$。\n\n- 测试用例 1（平衡设计，中等计数）：\n  - 计数矩阵，包含 $G = 12$ 个基因和 $S = 6$ 个样本，前三个为对照组，后三个为处理组。对照组样本 $A$、$B$、$C$：\n    - $A$: $[40, 55, 20, 18, 22, 60, 35, 25, 45, 50, 28, 30]$\n    - $B$: $[42, 53, 19, 20, 20, 58, 36, 24, 46, 51, 30, 32]$\n    - $C$: $[39, 57, 18, 19, 21, 62, 34, 26, 44, 49, 29, 31]$\n  - 处理组样本 $D$、$E$、$F$：\n    - $D$: $[41, 56, 36, 40, 44, 61, 37, 50, 45, 52, 55, 33]$\n    - $E$: $[43, 54, 35, 39, 43, 59, 38, 49, 47, 53, 54, 34]$\n    - $F$: $[40, 58, 34, 41, 45, 63, 36, 51, 46, 50, 56, 35]$\n  - 条件向量：$[0,0,0,1,1,1]$。\n  - 基因集：$S_{1} = \\{3,4,5,8,11\\}$。\n  - 要求输出：从上述流水线计算出的单个浮点数富集分数（按规定计算的运行总和）。\n\n- 测试用例 2（稀疏计数，大量零值，平衡设计）：\n  - 计数矩阵，包含 $G = 10$ 个基因和 $S = 4$ 个样本。对照组样本 $A$、$B$：\n    - $A$: $[0,0,1,0,2,1,0,0,0,1]$\n    - $B$: $[0,1,0,0,1,0,0,0,1,0]$\n  - 处理组样本 $C$、$D$：\n    - $C$: $[0,0,0,0,1,1,0,1,0,0]$\n    - $D$: $[1,0,0,0,0,1,0,0,0,0]$\n  - 条件向量：$[0,0,1,1]$。\n  - 基因集：$S_{2} = \\{2,5,9\\}$。\n  - 要求输出：从上述流水线计算出的单个浮点数富集分数。\n\n- 测试用例 3（非平衡设计，基因集中的基因下调）：\n  - 计数矩阵，包含 $G = 12$ 个基因和 $S = 6$ 个样本，前四个为对照组，后两个为处理组。对照组样本 $A$、$B$、$C$、$D$：\n    - $A$: $[30,45,60,55,50,40,35,20,25,18,22,28]$\n    - $B$: $[31,44,62,57,49,39,36,21,26,19,23,29]$\n    - $C$: $[32,46,61,56,51,41,34,22,27,17,24,30]$\n    - $D$: $[29,47,63,54,52,42,33,23,28,20,21,27]$\n  - 处理组样本 $E$、$F$：\n    - $E$: $[15,45,30,28,26,40,35,20,25,18,22,28]$\n    - $F$: $[16,44,31,29,27,39,36,21,26,19,23,29]$\n  - 条件向量：$[0,0,0,0,1,1]$。\n  - 基因集：$S_{3} = \\{1,3,4,5\\}$。\n  - 要求输出：从上述流水线计算出的单个浮点数富集分数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个结果，格式为方括号内的逗号分隔列表（例如 `\"[result1,result2,result3]\"`），每个结果是相应测试用例的浮点数富集分数。不应打印任何额外文本。不涉及角度，也没有物理单位；所有结果都以普通十进制浮点数表示。", "solution": "本解答通过为每个测试用例实现一个包含五个指定阶段的分析流水线来解决问题。该流水线模拟了从原始RNA测序计数到最终GSEA富集分数的标准生物信息学工作流程。\n\n**1. 基因过滤**\n\n第一步是过滤掉表达水平不足的基因，以提高统计功效并减少噪声。根据问题指定，我们移除在少于2个样本中具有严格正计数的基因，或总计数低于2的基因。这个最小总计数阈值是根据测试用例2的稀疏性选择的，以确保有足够的数据进行下游分析。\n\n**2. 文库大小归一化**\n\n为了使不同样本的基因计数具有可比性，必须对测序深度（文库大小）的差异进行校正。我们根据问题描述估计样本特异性的大小因子 $s_i$。主要方法是比率中位数法，它通过计算每个基因相对于在所有样本中均有表达的基因的伪参考样本的比率中位数来估计 $s_i$。当没有基因在所有样本中都表达时（如测试用例2），我们采用备用方案：总计数归一化。该方法使用每个样本的总读数作为其大小因子。最后，所有大小因子都被标准化以使其均值为1。归一化计数即为原始计数除以其对应样本的大小因子。\n\n**3. 离散度估计**\n\nRNA测序数据的过离散性（方差大于均值）通过负二项分布的离散度参数 $\\phi$ 来建模。准确估计 $\\phi$ 对后续统计检验至关重要。\n- **原始离散度**：对于每个基因，使用矩量法从归一化计数中估计一个原始离散度 $\\hat{\\phi}_g$。\n- **趋势拟合**：由于单个基因的离散度估计值噪声很大，我们通过对所有基因的离散度与平均表达量之间的关系拟合一个趋势函数 $\\phi_{\\mathrm{trend}}(\\hat{m}_g) = a + b/\\hat{m}_g$，以获得更稳定的基础估计。\n- **收缩**：最终的离散度估计值 $\\tilde{\\phi}_g$ 是通过将原始估计值 $\\hat{\\phi}_g$ 向趋势值 $\\phi_{\\mathrm{trend}}(\\hat{m}_g)$“收缩”得到的加权平均值。这借用了所有基因的信息，为每个基因提供了更稳健的离散度估计，尤其是在样本量较小时。\n\n**4. 各基因效应和Wald统计量**\n\n此步骤量化了两种条件下的基因表达差异。\n- **对数倍数变化 (LFC)**：我们为对照组和处理组分别计算每个基因的平均归一化表达量（$\\hat{\\mu}_{g,0}$ 和 $\\hat{\\mu}_{g,1}$）。效应大小由对数倍数变化 $\\widehat{\\mathrm{LFC}}_{g} = \\log_e(\\hat{\\mu}_{g,1} / \\hat{\\mu}_{g,0})$ 捕获。为避免对零取对数，计算时会加入一个微小的常数。\n- **LFC方差和Wald统计量**：使用Wald检验评估LFC的显著性。LFC的方差是利用delta方法和负二项方差函数推导出来的。最终的Wald统计量 $Z_g = \\widehat{\\mathrm{LFC}}_{g} / \\sqrt{\\widehat{\\operatorname{Var}}(\\widehat{\\mathrm{LFC}}_{g})}$，它衡量了效应大小与其不确定性的比率。这个 $Z$ 分数将作为GSEA的排序指标。\n\n**5. 基因集富集分析 (GSEA)**\n\n最后一步是确定一个预定义的基因集 $S$ 是否在排序列表中表现出显著的富集。\n- **排序**：所有通过过滤的基因根据其 $Z$ 分数从高到低进行排序。\n- **运行总和**：我们沿着排序列表计算一个加权运行总和。当遇到属于基因集 $S$ 的基因时，总和增加；否则减少。对于命中基因，增加的步长与其绝对 $Z$ 分数成正比。\n- **富集分数 (ES)**：ES是运行总和轨迹中离零点的最大偏差（可以为正或负）。它量化了基因集 $S$ 在排序列表的顶端（通常是上调基因）或底端（通常是下调基因）的富集程度。\n\n将此完整流水线应用于每个测试用例，即可计算出最终的富集分数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis pipeline on the provided test cases.\n    \"\"\"\n\n    def run_pipeline(counts_matrix, condition_vector, gene_set):\n        \"\"\"\n        Executes the full GSEA pipeline for a single test case.\n        \"\"\"\n        # Data setup\n        counts = np.array(counts_matrix).T  # Transpose to get Genes x Samples\n        conditions = np.array(condition_vector)\n        # Convert 1-based gene set to 0-based for Python indexing\n        gene_set_indices = {g - 1 for g in gene_set}\n        \n        # Step 1: Filtering based on detectability\n        min_samples_positive = 2\n        min_total_count = 2  # A reasonable assumption for the provided sparse data\n        \n        positive_samples_per_gene = np.sum(counts > 0, axis=1)\n        total_counts_per_gene = np.sum(counts, axis=1)\n        \n        keep_mask = (positive_samples_per_gene >= min_samples_positive)  \\\n                    (total_counts_per_gene >= min_total_count)\n        \n        filtered_counts = counts[keep_mask]\n        \n        if filtered_counts.shape[0] == 0:\n            return 0.0\n\n        original_indices = np.where(keep_mask)[0]\n        gene_map = {orig_idx: new_idx for new_idx, orig_idx in enumerate(original_indices)}\n        filtered_gene_set = {gene_map[g_idx] for g_idx in gene_set_indices if g_idx in gene_map}\n\n        G_filt, S = filtered_counts.shape\n        \n        # Step 2: Library size normalization\n        genes_all_nonzero_mask = np.all(filtered_counts > 0, axis=1)\n        \n        if np.any(genes_all_nonzero_mask):\n            # Median-of-ratios method\n            pseudo_ref_table = filtered_counts[genes_all_nonzero_mask, :]\n            geo_means = np.exp(np.mean(np.log(pseudo_ref_table), axis=1))\n            \n            # Prevent division by zero if a geo_mean is zero\n            geo_means[geo_means == 0] = 1e-9\n\n            # Ratios are S x num_ref_genes\n            ratios = pseudo_ref_table.T / geo_means\n            size_factors_raw = np.median(ratios, axis=1)\n        else:\n            # Fallback to total-count normalization using original pre-filter counts\n            size_factors_raw = np.sum(counts, axis=0)\n            \n        # Standardize size factors to have a mean of 1\n        size_factors = size_factors_raw / np.mean(size_factors_raw)\n        \n        normalized_counts = filtered_counts / size_factors[np.newaxis, :]\n        \n        # Step 3: Dispersion estimation\n        means_g = np.mean(normalized_counts, axis=1)\n        # ddof=1 for unbiased sample variance\n        vars_g = np.var(normalized_counts, axis=1, ddof=1)\n        \n        # Raw dispersion\n        phi_raw = np.zeros_like(means_g)\n        idx_mean_pos = means_g > 0\n        phi_raw[idx_mean_pos] = (vars_g[idx_mean_pos] - means_g[idx_mean_pos]) / (means_g[idx_mean_pos]**2)\n        phi_raw[phi_raw  0] = 0\n        \n        # Trend fitting\n        phi_trend = np.zeros_like(means_g)\n        fit_idx = idx_mean_pos  np.isfinite(phi_raw)\n        if np.sum(fit_idx) >= 2:\n            means_for_fit = means_g[fit_idx]\n            phi_for_fit = phi_raw[fit_idx]\n            \n            X_fit = np.vstack([np.ones(means_for_fit.shape[0]), 1 / means_for_fit]).T\n            try:\n                coeffs, _, _, _ = np.linalg.lstsq(X_fit, phi_for_fit, rcond=None)\n                a, b = coeffs\n                phi_trend = a + b / means_g\n                phi_trend[phi_trend  0] = 0\n            except np.linalg.LinAlgError:\n                positive_phi_raw = phi_raw[phi_raw > 0]\n                median_phi = np.median(positive_phi_raw) if len(positive_phi_raw) > 0 else 0.01\n                phi_trend[:] = median_phi\n        else:\n           positive_phi_raw = phi_raw[phi_raw > 0]\n           median_phi = np.median(positive_phi_raw) if len(positive_phi_raw) > 0 else 0.01\n           phi_trend[:] = median_phi\n\n        # Shrinkage\n        k = 4.0 # Prior strength parameter assumption\n        alpha = k / (k + S)\n        phi_shrunk = alpha * phi_trend + (1 - alpha) * phi_raw\n        phi_shrunk[phi_shrunk  0] = 0\n\n        # Step 4: Per-gene effect and Wald statistic\n        cond0_mask = conditions == 0\n        cond1_mask = conditions == 1\n        n0, n1 = np.sum(cond0_mask), np.sum(cond1_mask)\n        \n        mu_g0 = np.mean(normalized_counts[:, cond0_mask], axis=1)\n        mu_g1 = np.mean(normalized_counts[:, cond1_mask], axis=1)\n        \n        epsilon = 1e-8 # Small constant for numerical stability\n        LFC = np.log((mu_g1 + epsilon) / (mu_g0 + epsilon))\n        \n        var_LFC_approx = (1/(mu_g1 + epsilon) + phi_shrunk) / n1 + \\\n                         (1/(mu_g0 + epsilon) + phi_shrunk) / n0\n        \n        Z_scores = np.zeros_like(LFC)\n        valid_var_mask = var_LFC_approx > 0\n        Z_scores[valid_var_mask] = LFC[valid_var_mask] / np.sqrt(var_LFC_approx[valid_var_mask])\n\n        # Step 5: Gene Set Enrichment Analysis\n        if len(filtered_gene_set) == 0 or len(filtered_gene_set) == G_filt:\n            return 0.0\n\n        in_set_mask = np.zeros(G_filt, dtype=bool)\n        if filtered_gene_set:\n            in_set_mask[list(filtered_gene_set)] = True\n\n        abs_Z = np.abs(Z_scores)\n        sum_weights_in_set = np.sum(abs_Z[in_set_mask])\n        \n        if sum_weights_in_set == 0:\n            return 0.0\n\n        sorted_indices = np.argsort(Z_scores)[::-1]\n        \n        is_in_set_sorted = in_set_mask[sorted_indices]\n        abs_Z_sorted = abs_Z[sorted_indices]\n        \n        step_hit = abs_Z_sorted / sum_weights_in_set\n        step_miss = 1.0 / (G_filt - len(filtered_gene_set))\n        \n        running_sum = 0.0\n        running_sum_values = [0.0]\n        \n        for i in range(G_filt):\n            if is_in_set_sorted[i]:\n                running_sum += step_hit[i]\n            else:\n                running_sum -= step_miss\n            running_sum_values.append(running_sum)\n            \n        max_rs = np.max(running_sum_values)\n        min_rs = np.min(running_sum_values)\n\n        return max_rs if abs(max_rs) > abs(min_rs) else min_rs\n            \n    test_cases = [\n        {\n            \"counts\": [\n                [40, 55, 20, 18, 22, 60, 35, 25, 45, 50, 28, 30],\n                [42, 53, 19, 20, 20, 58, 36, 24, 46, 51, 30, 32],\n                [39, 57, 18, 19, 21, 62, 34, 26, 44, 49, 29, 31],\n                [41, 56, 36, 40, 44, 61, 37, 50, 45, 52, 55, 33],\n                [43, 54, 35, 39, 43, 59, 38, 49, 47, 53, 54, 34],\n                [40, 58, 34, 41, 45, 63, 36, 51, 46, 50, 56, 35]\n            ],\n            \"conditions\": [0, 0, 0, 1, 1, 1],\n            \"gene_set\": {3, 4, 5, 8, 11}\n        },\n        {\n            \"counts\": [\n                [0, 0, 1, 0, 2, 1, 0, 0, 0, 1],\n                [0, 1, 0, 0, 1, 0, 0, 0, 1, 0],\n                [0, 0, 0, 0, 1, 1, 0, 1, 0, 0],\n                [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]\n            ],\n            \"conditions\": [0, 0, 1, 1],\n            \"gene_set\": {2, 5, 9}\n        },\n        {\n            \"counts\": [\n                [30, 45, 60, 55, 50, 40, 35, 20, 25, 18, 22, 28],\n                [31, 44, 62, 57, 49, 39, 36, 21, 26, 19, 23, 29],\n                [32, 46, 61, 56, 51, 41, 34, 22, 27, 17, 24, 30],\n                [29, 47, 63, 54, 52, 42, 33, 23, 28, 20, 21, 27],\n                [15, 45, 30, 28, 26, 40, 35, 20, 25, 18, 22, 28],\n                [16, 44, 31, 29, 27, 39, 36, 21, 26, 19, 23, 29]\n            ],\n            \"conditions\": [0, 0, 0, 0, 1, 1],\n            \"gene_set\": {1, 3, 4, 5}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_pipeline(case[\"counts\"], case[\"conditions\"], case[\"gene_set\"])\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "4346070"}]}