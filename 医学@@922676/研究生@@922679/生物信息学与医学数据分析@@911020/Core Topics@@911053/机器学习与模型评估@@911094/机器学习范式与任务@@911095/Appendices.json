{"hands_on_practices": [{"introduction": "在生物信息学中，一个常见的任务是预测连续的生物标志物，例如本例中的血清肌酐水平。评估回归模型的性能是至关重要的一步。这个练习 [@problem_id:4579954] 提供了一个动手实践的机会，让学生从汇总的统计数据中计算两个最基本的回归指标：均方根误差（RMSE）和决定系数（$R^2$）。通过这个练习，你将学会如何量化模型的预测误差，并评估其相对于简单基线模型的解释能力。", "problem": "一个转化生物信息学团队训练一个监督学习模型，以根据多组学特征预测血清肌酐（单位：mg/dL）。该模型在一个包含$100$名成年患者的留出验证队列上进行评估。设真实肌酐值为 $\\{y_i\\}_{i=1}^{n}$，模型预测值为 $\\{\\hat{y}_i\\}_{i=1}^{n}$，其中$n=100$。根据该验证队列中匹配的真实值和预测值，获得了以下经验性汇总统计数据：\n- 残差平方和（预测误差的平方和）：$\\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2 = 19.36$。\n- 围绕经验均值 $\\bar{y} = \\frac{1}{n}\\sum_{i=1}^{n} y_i$ 的总平方和：$\\sum_{i=1}^{n} (y_i - \\bar{y})^2 = 48.40$。\n\n一项临床评估计划规定，一个模型在该队列上被认为是充分的，当且仅当以下两个条件同时成立：均方根误差（RMSE）小于或等于$0.5$ mg/dL，且决定系数（记作$R^2$）至少为$0.55$。\n\n从平方损失下的经验风险和相对于基线预测器 $y=\\bar{y}$ 的方差分解的核心定义出发，计算该模型在此验证队列上的RMSE（以mg/dL表示）和$R^2$，并判断该模型是否满足充分性标准。仅报告RMSE和$R^2$的数值作为最终答案，按此顺序，并四舍五入到四位有效数字。以mg/dL表示RMSE。最终方框答案中不要包含任何单位。", "solution": "问题陈述经评估为有效。其科学依据扎根于统计学和机器学习评估的原理，问题表述清晰，提供了所有必要信息，并以客观、明确的语言表达。因此，我们可以着手求解。\n\n任务是为一个监督学习模型计算均方根误差（RMSE）和决定系数（$R^2$），并评估该模型是否满足预定义的充分性标准。\n\n设 $n$ 为验证队列中的患者数量，其中 $n=100$。\n设 $\\{y_i\\}_{i=1}^{n}$ 为真实的血清肌酐值集合，$\\{\\hat{y}_i\\}_{i=1}^{n}$ 为模型预测值集合。\n\n问题提供了两个关键的汇总统计数据：\n1.  残差平方和（RSS），即预测误差的平方和：\n    $$ \\text{RSS} = \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2 = 19.36 $$\n2.  总平方和（TSS），即真实值与其经验均值 $\\bar{y}$ 之间差值的平方和：\n    $$ \\text{TSS} = \\sum_{i=1}^{n} (y_i - \\bar{y})^2 = 48.40 $$\n\n首先，我们计算RMSE。RMSE定义为均方误差（MSE）的平方根。MSE是平方损失下的经验风险，计算方法为平方误差的平均值：\n$$ \\text{MSE} = \\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2 = \\frac{\\text{RSS}}{n} $$\n代入给定的RSS和$n$的值：\n$$ \\text{MSE} = \\frac{19.36}{100} = 0.1936 $$\nMSE的单位是目标变量单位的平方，即 $(\\text{mg/dL})^2$。\n\nRMSE是MSE的平方根，它将误差度量恢复到目标变量的原始单位：\n$$ \\text{RMSE} = \\sqrt{\\text{MSE}} $$\n代入计算出的MSE值：\n$$ \\text{RMSE} = \\sqrt{0.1936} = 0.44 $$\n所以，RMSE为$0.44$ mg/dL。\n\n接下来，我们计算决定系数$R^2$。该度量衡量了因变量中可由模型预测的方差比例。其定义如下：\n$$ R^2 = 1 - \\frac{\\text{RSS}}{\\text{TSS}} $$\n此公式将模型的误差（RSS）与一个始终预测真实值均值的基线模型的误差（TSS）进行比较。\n\n代入给定的RSS和TSS的值：\n$$ R^2 = 1 - \\frac{19.36}{48.40} $$\n该比率可以简化为：\n$$ \\frac{19.36}{48.40} = 0.4 $$\n因此，$R^2$值为：\n$$ R^2 = 1 - 0.4 = 0.6 $$\n$R^2$是一个无量纲的量。\n\n问题陈述了充分性标准为一个包含两部分的条件：\n1. RMSE $\\le 0.5$ mg/dL\n2. $R^2 \\ge 0.55$\n\n我们用计算出的值来核对这些标准：\n1. 对于RMSE：$0.44 \\le 0.5$。此条件满足。\n2. 对于$R^2$：$0.6 \\ge 0.55$。此条件也满足。\n由于两个条件同时成立，该模型在该验证队列上被认为是充分的。\n\n最后一步是报告RMSE和$R^2$的数值，并四舍五入到四位有效数字。\n- RMSE = $0.44$。保留四位有效数字为$0.4400$。\n- $R^2$ = $0.6$。保留四位有效数字为$0.6000$。\n\n最终答案将按指定顺序呈现这两个值。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.4400  0.6000\n\\end{pmatrix}\n}\n$$", "id": "4579954"}, {"introduction": "从回归任务转向分类任务，我们经常会遇到模型输出的是概率值而非最终的二元决策。如何将这些概率转化为临床上有意义的分类（例如“患病”或“健康”）是一个关键步骤。这个练习 [@problem_id:4579975] 将挑战你寻找一个最佳决策阈值，以最大化 $F_1$ 分数——这对于处理医学领域中常见的不平衡数据集至关重要。此过程突显了在精确率（Precision）和召回率（Recall）之间进行权衡的必要性。", "problem": "一个概率分类器被应用于一个包含 $200$ 名患者的队列，以预测某种特定疾病的存在。对于每位患者 $i \\in \\{1,\\dots,200\\}$，模型输出一个校准的预测概率 $p_i \\in [0,1]$，表示疾病存在的可能性。使用一个阈值 $t \\in [0,1]$ 将预测转换为二元决策，规则如下：当且仅当 $p_i \\geq t$ 时，预测为疾病存在。这些患者可以按照相同的预测概率进行分组，如下所示；每个项目列出了预测概率 $p$（以小数形式表示），以及在该 $p$ 值下疾病存在（阳性）和疾病不存在（阴性）的患者数量：\n\n- $p=0.97$：$9$ 名阳性，$1$ 名阴性\n- $p=0.90$：$10$ 名阳性，$6$ 名阴性\n- $p=0.82$：$8$ 名阳性，$10$ 名阴性\n- $p=0.74$：$7$ 名阳性，$13$ 名阴性\n- $p=0.66$：$6$ 名阳性，$10$ 名阴性\n- $p=0.58$：$5$ 名阳性，$13$ 名阴性\n- $p=0.50$：$5$ 名阳性，$15$ 名阴性\n- $p=0.42$：$4$ 名阳性，$18$ 名阴性\n- $p=0.34$：$3$ 名阳性，$17$ 名阴性\n- $p=0.26$：$2$ 名阳性，$12$ 名阴性\n- $p=0.18$：$1$ 名阳性，$9$ 名阴性\n- $p=0.10$：$0$ 名阳性，$16$ 名阴性\n\n假设模型的输出是经过校准的，并且分组计数和标签是准确的。使用真阳性（TP）、假阳性（FP）、假阴性（FN）、精确率（Precision）、召回率（Recall）和 $F_1$分数的标准定义，确定在所有 $t \\in [0,1]$ 中能使 $F_1$分数最大化的单一阈值 $t$。如果存在一个阈值区间都能达到相同的最大 $F_1$分数，请报告该区间中的最大阈值。将你的阈值四舍五入到四位有效数字。此外，从基本原理出发，解释在保持分数分布在其他方面可比的情况下，类别流行率（群体中的阳性比例）通常如何影响使 $F_1$分数最大化的阈值的位置。", "solution": "问题陈述具有科学依据、提法恰当且客观。它为评估一个概率分类器提供了一套完整且一致的数据。给出的患者总数为 $200$。将每组的患者相加：$(9+1) + (10+6) + (8+10) + (7+13) + (6+10) + (5+13) + (5+15) + (4+18) + (3+17) + (2+12) + (1+9) + (0+16) = 10+16+18+20+16+18+20+22+20+14+10+16 = 200$。阳性（疾病存在）的总数为 $P = 9+10+8+7+6+5+5+4+3+2+1+0 = 60$。阴性（疾病不存在）的总数为 $N = 1+6+10+13+10+13+15+18+17+12+9+16 = 140$。总和是一致的。该问题是有效的。\n\n解决方案需要两部分：找到最大化 $F_1$分数的最优阈值 $t$，并解释流行率对这个最优阈值的影响。\n\n**第一部分：找到最优阈值**\n\n$F_1$分数是精确率（$P$）和召回率（$R$）的调和平均数：\n$$ F_1 = 2 \\cdot \\frac{P \\cdot R}{P + R} $$\n其中，精确率和召回率根据真阳性（$TP$）、假阳性（$FP$）和假阴性（$FN$）定义如下：\n$$ P = \\frac{TP}{TP + FP} \\quad \\text{and} \\quad R = \\frac{TP}{TP + FN} $$\n实际阳性病例总数为 $P_{total} = TP+FN = 60$。实际阴性病例总数为 $N_{total} = FP+TN = 140$，其中 $TN$ 是真阴性。\n$F_1$分数可以直接用 $TP$、$FP$ 和 $FN$ 表示：\n$$ F_1 = \\frac{2 \\cdot TP}{2 \\cdot TP + FP + FN} $$\n如果患者的预测概率 $p_i$ 大于或等于阈值 $t$（即 $p_i \\geq t$），则预测其患有该疾病。预测为阳性的集合仅在阈值 $t$ 越过问题中给出的唯一概率值之一时才会改变。因此，我们只需要在与这些唯一概率值相对应的阈值处计算 $F_1$分数。\n\n我们可以通过按降序处理概率分组来计算 $TP$ 和 $FP$ 的累积计数。对于给定的阈值 $t$，所有概率 $p \\ge t$ 的患者都被分类为阳性。\n设 $TP(t)$ 和 $FP(t)$ 分别为阈值 $t$ 对应的真阳性和假阳性数量。\n$TP(t) = \\sum_{p_k \\ge t} \\text{positives}(p_k)$\n$FP(t) = \\sum_{p_k \\ge t} \\text{negatives}(p_k)$\n$FN(t) = P_{total} - TP(t) = 60 - TP(t)$。\n\n计算结果总结在下表中。阈值 $t$ 对应于第一列中的概率值，意味着任何分数大于或等于 $t$ 的患者都被分类为阳性。\n\n$$\n\\begin{array}{|c|c|c|c|c|c|c|}\n\\hline\n\\text{阈值 } t & \\text{累积 } TP & \\text{累积 } FP & FN & \\text{精确率} & \\text{召回率} & F_1\\text{-分数} \\\\\n\\hline\n0.97 & 9 & 1 & 51 & 9/10 = 0.9000 & 9/60 = 0.1500 & 0.2571 \\\\\n0.90 & 19 & 7 & 41 & 19/26 \\approx 0.7308 & 19/60 \\approx 0.3167 & 0.4419 \\\\\n0.82 & 27 & 17 & 33 & 27/44 \\approx 0.6136 & 27/60 = 0.4500 & 0.5192 \\\\\n0.74 & 34 & 30 & 26 & 34/64 \\approx 0.5313 & 34/60 \\approx 0.5667 & 0.5484 \\\\\n\\mathbf{0.66} & \\mathbf{40} & \\mathbf{40} & \\mathbf{20} & \\mathbf{40/80 = 0.5000} & \\mathbf{40/60 \\approx 0.6667} & \\mathbf{0.5714} \\\\\n0.58 & 45 & 53 & 15 & 45/98 \\approx 0.4592 & 45/60 = 0.7500 & 0.5696 \\\\\n0.50 & 50 & 68 & 10 & 50/118 \\approx 0.4237 & 50/60 \\approx 0.8333 & 0.5618 \\\\\n0.42 & 54 & 86 & 6 & 54/140 \\approx 0.3857 & 54/60 = 0.9000 & 0.5400 \\\\\n0.34 & 57 & 103 & 3 & 57/160 \\approx 0.3563 & 57/60 = 0.9500 & 0.5182 \\\\\n0.26 & 59 & 115 & 1 & 59/174 \\approx 0.3391 & 59/60 \\approx 0.9833 & 0.5021 \\\\\n0.18 & 60 & 124 & 0 & 60/184 \\approx 0.3261 & 60/60 = 1.0000 & 0.4918 \\\\\n0.10 & 60 & 140 & 0 & 60/200 = 0.3000 & 60/60 = 1.0000 & 0.4615 \\\\\n\\hline\n\\end{array}\n$$\n\n最大 $F_1$分数约为 $0.5714$（恰好是 $4/7$）。当阈值 $t$ 设置为使得所有分数 $p \\ge 0.66$ 的患者都被分类为阳性时，可以达到这个分数。这对应于区间 $(0.58, 0.66]$ 中的任何阈值 $t$。对于此区间内的任何 $t$，被分类为阳性的患者集合保持不变，从而产生相同的 $F_1$分数。问题要求的是此区间中的最大阈值，即 $t = 0.66$。四舍五入到四位有效数字，阈值为 $0.6600$。\n\n**第二部分：类别流行率对最优阈值的影响**\n\n类别流行率 $\\pi$ 是群体中阳性的比例：$\\pi = P_{total} / (P_{total} + N_{total})$。我们被要求解释，在假设阳性和阴性类别的分数分布保持不变的情况下，$\\pi$ 如何影响使 $F_1$分数最大化的阈值 $t^*$。\n\n设 $f_P(s)$ 和 $f_N(s)$ 分别为阳性群体和阴性群体分类器分数的概率密度函数。对于给定的阈值 $t$：\n召回率，或称真阳性率（$TPR$），是阳性病例被正确识别的概率：\n$$ R(t) = \\text{Recall}(t) = P(\\text{score} \\ge t | \\text{positive}) = \\int_t^1 f_P(s) ds $$\n这个定义表明，召回率是分类器对阳性类别的分数分布的内在属性，并且独立于流行率 $\\pi$。\n\n另一方面，精确率是被预测为阳性的病例确实是阳性的概率。使用贝叶斯定理：\n$$ P(t) = \\text{Precision}(t) = P(\\text{positive} | \\text{score} \\ge t) = \\frac{P(\\text{score} \\ge t | \\text{positive}) P(\\text{positive})}{P(\\text{score} \\ge t)} $$\n分母可以使用全概率定律展开：\n$$ P(\\text{score} \\ge t) = P(\\text{score} \\ge t | \\text{positive})P(\\text{positive}) + P(\\text{score} \\ge t | \\text{negative})P(\\text{negative}) $$\n令 $P(\\text{positive}) = \\pi$，$P(\\text{negative}) = 1-\\pi$，以及 $P(\\text{score} \\ge t | \\text{negative}) = \\int_t^1 f_N(s) ds$（假阳性率, $FPR(t)$），我们得到：\n$$ P(t) = \\frac{R(t) \\cdot \\pi}{R(t) \\cdot \\pi + FPR(t) \\cdot (1-\\pi)} $$\n这个表达式明确显示了精确率是流行率 $\\pi$ 的函数。对于固定的阈值 $t$，随着 $\\pi$ 的增加，项 $(1-\\pi)$ 减小，导致分母减小，从而精确率增加。\n\n$F_1$分数是精确率和召回率之间的一种平衡。最优阈值 $t^*$ 是实现最佳权衡的那个值。\n1.  **低流行率 ($\\pi \\to 0$)：** 在阳性病例非常少的群体中，阴性病例数 $N_{total}$ 远大于阳性病例数 $P_{total}$。即使是很小的假阳性率（$FPR$）也可能导致大量的假阳性（$FP = FPR \\cdot N_{total}$），其数量会远超真阳性（$TP = R \\cdot P_{total}$）。这会严重拉低精确率。为了最大化 $F_1$分数，主要挑战是提高精确率。这可以通过使分类器更严格来实现，即通过**提高阈值 $t$**。更高的阈值会降低 $FPR$，从而减少 $FP$ 并提升精确率，尽管代价是召回率会降低。\n2.  **高流行率 ($\\pi \\to 1$)：** 在阳性病例很多的群体中，阳性病例数 $P_{total}$ 远大于阴性病例数 $N_{total}$。对于宽泛的阈值范围，精确率都倾向于很高，因为假阳性数量 $FP$ 相对于真阳性数量 $TP$ 会很小。$F_1$分数的限制因素变成了召回率。为了最大化 $F_1$分数，重点转移到提高召回率上。这可以通过使分类器更具包容性来实现，即通过**降低阈值 $t$**。更低的阈值可以捕获更多的真阳性，从而提高召回率。\n\n总而言之，随着类别流行率 $\\pi$ 的增加，最大化 $F_1$分数的最优阈值 $t^*$ 通常会降低。相反，流行率的降低则需要提高最优阈值来维持较高的 $F_1$分数。", "answer": "$$\n\\boxed{0.6600}\n$$", "id": "4579975"}, {"introduction": "一个在统计上表现优异的模型，如果不比现有的临床策略（例如“治疗所有患者”或“不治疗任何患者”）更好，那么它在现实世界中可能并无价值。决策曲线分析（Decision Curve Analysis, DCA）正是为评估模型的临床实用性而设计的强大框架。这个练习 [@problem_id:4579973] 更进一步，要求你从基本原理出发推导净获益（net benefit）的计算公式并编程实现DCA，从而确定在哪些临床偏好范围（即风险阈值）内，使用该模型能带来超越标准策略的净收益。", "problem": "您的任务是为脓毒症风险分层中的二元临床预测场景实施决策曲线分析（DCA）。您的目标是计算基于模型的决策策略在一组风险阈值上的标准化净收益，将其与两种基准策略进行比较，并确定模型具有临床实用性的阈值范围。该公式必须从预期效用最大化以及将阈值定义为预期收益和预期伤害之间的无差异点出发，而不使用任何预先提供的净收益公式。\n\n使用的基本基础和定义：\n- 考虑一个大小为 $N$ 的队列，其二元结局为 $y_i \\in \\{0,1\\}$（对于 $i \\in \\{1,\\dots,N\\}$），其中 $y_i=1$ 表示脓毒症，而 $y_i=0$ 表示无脓毒症。\n- 一个预测模型为每个个体 $i$ 输出校准的风险估计值 $\\hat{p}_i \\in [0,1]$。\n- 决策阈值 $t \\in (0,1)$ 导出一个治疗决策规则 $d_i(t) \\in \\{0,1\\}$，其定义为：当且仅当 $\\hat{p}_i \\ge t$ 时 $d_i(t)=1$，否则 $d_i(t)=0$。\n- 在预期效用最大化和归一化（即治疗真阳性病例的收益为 $B=1$，治疗非病例的伤害为一个正量 $H>0$）的条件下，阈值 $t$ 是治疗与不治疗之间的无差异点。这是一个经过充分检验的决策理论事实，它通过 $t$ 处的几率将 $t$ 与伤害-收益比联系起来。您必须利用这一点推导出一个可计算的标准化净收益表达式，该表达式依赖于阈值 $t$ 处的真阳性和假阳性计数。\n- 令 $TP(t)$ 和 $FP(t)$ 分别表示在 $d_i(t)$ 下的真阳性和假阳性计数。令 $N_1=\\sum_{i=1}^N y_i$ 和 $N_0=N-N_1$ 表示病例数和非病例数，事件患病率设为 $\\pi=N_1/N$。\n- 定义三种策略进行比较：在每个阈值 $t$ 下由 $d_i(t)$ 导出的基于模型的策略，一个为所有 $i$ 设置 $d_i(t)=1$ 的全治疗策略，以及一个为所有 $i$ 设置 $d_i(t)=0$ 的不治疗策略。\n- 在上述归一化条件下，任何策略在阈值 $t$ 处的标准化净收益是相对于不治疗基线的每位患者的平均预期效用。您必须将其表示为 $TP(t)$、$FP(t)$、$N$ 以及由 $t$ 隐含并从第一性原理推导出的伤害-收益比的函数。\n\n任务要求：\n1) 从上述基础出发，推导出一个用 $TP(t)$、$FP(t)$ 和 $N$ 表示的模型在阈值 $t$ 处的标准化净收益的可计算表达式，以及全治疗和不治疗策略的相应表达式（在适用时仅使用 $N_1$、$N_0$ 和 $N$）。所有推导都必须遵循以下归一化：正确治疗一个病例的收益为 $B=1$，而治疗一个非病例的伤害与阈值隐含的伤害-收益比一致。\n2) 实现一个程序，对于下面的每个测试用例，在提供的阈值网格中的每个阈值 $t$ 处，计算模型的标准化净收益、全治疗策略的标准化净收益和不治疗策略的标准化净收益。然后，当且仅当模型在阈值 $t$ 处的标准化净收益严格大于全治疗和不治疗策略在 $t$ 处的标准化净收益时，才宣布该阈值 $t$ 具有临床实用性（使用严格不等式）。\n3) 在离散阈值网格上，将连续的具有临床实用性的阈值合并为最大连续区间。如果两个阈值在给定网格中相邻，则它们是连续的。每个区间必须报告为一个双元素列表 $[t_{\\min}, t_{\\max}]$，其中 $t_{\\min}$ 和 $t_{\\max}$ 精确地从提供的阈值中取值。\n4) 对于每个测试用例，输出这些区间的列表。按照“最终输出格式”下的规定，将所有测试用例的结果汇总到一行中。\n\n测试套件：\n- 对所有测试用例使用以下通用阈值网格：$T=\\left[0.1, 0.2, 0.33, 0.5, 0.67, 0.8, 0.9\\right]$。\n- 测试用例 1（中等区分度的模型，$N=10$）：\n  - 预测值 $\\hat{p}$：$[0.9, 0.8, 0.6, 0.55, 0.6, 0.45, 0.3, 0.2, 0.1, 0.05]$\n  - 结局 $y$：$[1,1,1,1,0,0,0,0,0,0]$\n- 测试用例 2（无信息量的恒定模型，$N=10$）：\n  - 预测值 $\\hat{p}$：$[0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3]$\n  - 结局 $y$：$[1,0,0,1,0,0,1,0,0,0]$\n- 测试用例 3（近乎完美的分离，$N=10$）：\n  - 预测值 $\\hat{p}$：$[0.9,0.9,0.9,0.9,0.9, 0.05,0.05,0.05,0.05,0.05]$\n  - 结局 $y$：$[1,1,1,1,1, 0,0,0,0,0]$\n- 测试用例 4（仅在中等阈值范围有用，$N=10$）：\n  - 预测值 $\\hat{p}$：$[0.55, 0.08, 0.45, 0.4, 0.35, 0.3, 0.25, 0.2, 0.12, 0.11]$\n  - 结局 $y$：$[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个元素按顺序对应一个测试用例，其本身是一个区间列表，其中每个区间是一个双元素列表 $[t_{\\min},t_{\\max}]$，浮点数与 $T$ 的成员完全相等。例如：$[[[0.1,0.5],[0.8,0.9]],[],[[0.1,0.9]],[[0.5,0.5]]]$ 表示第一个案例有两个区间，第二个案例没有，第三个案例有一个，第四个案例有一个退化区间。在确定临床实用性时，请确保使用严格不等式，并且不要包括模型与基准持平的任何阈值。", "solution": "用户提供的问题是有效的。它在科学上植根于决策理论和生物统计学，特别是在决策曲线分析（DCA）的方法论中。该问题定义明确，为获得唯一解提供了所有必要的数据、定义和约束。其语言客观，要求可以形式化为一个计算任务。\n\n### 步骤1：标准化净收益公式的推导\n\n这个问题的核心是按要求从预期效用理论的第一性原理推导标准化净收益（Standardized Net Benefit, SNB）的表达式。\n\n我们来定义与二元决策（治疗/不治疗）对二元状况（脓毒症/无脓毒症）的四种可能结果相关的效用：\n- $U_{\\text{TP}}$：治疗脓毒症患者的效用（真阳性）。\n- $U_{\\text{FP}}$：治疗无脓毒症患者的效用（假阳性）。\n- $U_{\\text{FN}}$：不治疗脓毒症患者的效用（假阴性）。\n- $U_{\\text{TN}}$：不治疗无脓毒症患者的效用（真阴性）。\n\n问题提供了一个归一化方案。正确治疗一个病例的收益为 $B=1$。这是治疗脓毒症患者相比不治疗他们的净效用增益：\n$$U_{\\text{TP}} - U_{\\text{FN}} = B = 1$$\n\n错误治疗一个非病例的伤害为一个正量 $H$。这是治疗无脓毒症患者相比不治疗他们的净效用损失：\n$$U_{\\text{TN}} - U_{\\text{FP}} = H \\implies U_{\\text{FP}} - U_{\\text{TN}} = -H$$\n\n决策阈值 $t$ 被定义为疾病的概率，在该概率下，决策者对于治疗和不治疗是无差异的。对于一个疾病风险为 $p$ 的个体，其预期效用为：\n- 治疗的预期效用：$E[U(\\text{treat})] = p \\cdot U_{\\text{TP}} + (1-p) \\cdot U_{\\text{FP}}$\n- 不治疗的预期效用：$E[U(\\text{no treat})] = p \\cdot U_{\\text{FN}} + (1-p) \\cdot U_{\\text{TN}}$\n\n在无差异阈值 $t$ 处，我们设 $p=t$ 并使两个预期效用相等：\n$$t \\cdot U_{\\text{TP}} + (1-t) \\cdot U_{\\text{FP}} = t \\cdot U_{\\text{FN}} + (1-t) \\cdot U_{\\text{TN}}$$\n重新整理各项，按 $t$ 和 $(1-t)$ 分组：\n$$t \\cdot (U_{\\text{TP}} - U_{\\text{FN}}) = (1-t) \\cdot (U_{\\text{TN}} - U_{\\text{FP}})$$\n代入收益 $B=1$ 和伤害 $H$ 的定义：\n$$t \\cdot 1 = (1-t) \\cdot H$$\n这给出了由阈值 $t$ 隐含的伤害-收益比：\n$$H = \\frac{t}{1-t}$$\n该比率表示为了确保治疗一名患病患者，决策者愿意不必要地治疗的无病患者的数量。\n\n接下来，我们为一个应用于 $N$ 个体队列的给定决策策略构建净收益。设 $TP(t)$ 和 $FP(t)$ 为阈值 $t$ 处的真阳性和假阳性计数。被治疗的个体总数为 $TP(t) + FP(t)$。患病个体（病例）数为 $N_1$，无病个体（非病例）数为 $N_0$。队列总大小为 $N = N_1 + N_0$。假阴性数为 $FN(t) = N_1 - TP(t)$，真阴性数为 $TN(t) = N_0 - FP(t)$。\n\n一个策略的总效用是所有个体效用的总和：\n$$U_{\\text{strategy}} = TP(t) \\cdot U_{\\text{TP}} + FP(t) \\cdot U_{\\text{FP}} + FN(t) \\cdot U_{\\text{FN}} + TN(t) \\cdot U_{\\text{TN}}$$\n\n基准策略是“不治疗”。对于此策略，$TP=0$，$FP=0$，$FN=N_1$，且 $TN=N_0$。其总效用为：\n$$U_{\\text{treat-none}} = N_1 \\cdot U_{\\text{FN}} + N_0 \\cdot U_{\\text{TN}}$$\n\n一个策略的净效用是其相对于“不治疗”基线的效用：\n$$\\text{Net Utility} = U_{\\text{strategy}} - U_{\\text{treat-none}}$$\n$$\\text{Net Utility} = (TP(t) \\cdot U_{\\text{TP}} + \\dots) - (N_1 \\cdot U_{\\text{FN}} + N_0 \\cdot U_{\\text{TN}})$$\n代入 $FN(t) = N_1 - TP(t)$ 和 $TN(t) = N_0 - FP(t)$：\n$$\\text{Net Utility} = TP(t) \\cdot U_{\\text{TP}} + FP(t) \\cdot U_{\\text{FP}} + (N_1-TP(t)) \\cdot U_{\\text{FN}} + (N_0-FP(t)) \\cdot U_{\\text{TN}} - N_1 \\cdot U_{\\text{FN}} - N_0 \\cdot U_{\\text{TN}}$$\n展开并简化，涉及 $N_1$ 和 $N_0$ 的项被抵消：\n$$\\text{Net Utility} = TP(t) \\cdot (U_{\\text{TP}} - U_{\\text{FN}}) + FP(t) \\cdot (U_{\\text{FP}} - U_{\\text{TN}})$$\n代入 $B=1$ 和 $-H$：\n$$\\text{Net Utility} = TP(t) \\cdot 1 + FP(t) \\cdot (-H) = TP(t) - FP(t) \\cdot H$$\n\n标准化净收益（SNB）是每位患者的平均净效用，通过除以 $N$ 获得：\n$$SNB(t) = \\frac{TP(t) - FP(t) \\cdot H}{N}$$\n最后，代入 $H = t/(1-t)$，我们得到模型在阈值 $t$ 处的 SNB 的可计算表达式：\n$$SNB_{\\text{model}}(t) = \\frac{TP(t)}{N} - \\frac{FP(t)}{N} \\frac{t}{1-t}$$\n\n我们现在可以推导两种基准策略的 SNB：\n\n1.  **不治疗策略**：在此策略下，无人被治疗，因此对于任何 $t$，都有 $TP(t)=0$ 和 $FP(t)=0$。\n    $$SNB_{\\text{none}}(t) = \\frac{0}{N} - \\frac{0}{N} \\frac{t}{1-t} = 0$$\n    这是预料之中的，因为它作为基线。\n\n2.  **全治疗策略**：在此策略下，每个人都被治疗。真阳性的数量是病例总数 $N_1$，假阳性的数量是非病例总数 $N_0$。\n    $$SNB_{\\text{all}}(t) = \\frac{N_1 - N_0 \\cdot H}{N} = \\frac{N_1}{N} - \\frac{N_0}{N} \\frac{t}{1-t}$$\n\n### 步骤2：实施计划\n\n程序将为每个测试用例执行以下步骤：\n1.  接收预测风险数组 $\\hat{p}$ 和真实结局数组 $y$。\n2.  计算队列常数：$N = \\text{len}(y)$，$N_1 = \\sum y$ 和 $N_0 = N - N_1$。\n3.  遍历提供的阈值网格 $T$ 中的每个阈值 $t$。\n4.  对于每个 $t$，计算：\n    a. 基于规则 $\\hat{p}_i \\ge t$ 的二元决策。\n    b. 模型的真阳性 $TP(t)$ 和假阳性 $FP(t)$ 计数。\n    c. 三种标准化净收益：$SNB_{\\text{model}}(t)$、$SNB_{\\text{all}}(t)$ 和 $SNB_{\\text{none}}(t)=0$，使用上面推导的公式。\n5.  对每个 $t$ 判断模型是否具有临床实用性，这需要满足严格不等式 $SNB_{\\text{model}}(t) > SNB_{\\text{all}}(t)$ 和 $SNB_{\\text{model}}(t) > SNB_{\\text{none}}(t)$。\n6.  从布尔实用性标志的数组中，识别出 `True` 值的最大连续块。“连续”指的是在阈值网格 $T$ 中的相邻索引。\n7.  对于每个这样的块，使用来自 $T$ 的相应阈值形成一个区间 $[t_{\\min}, t_{\\max}]$。\n8.  将这些区间收集到该测试用例的列表中。\n9.  处理完所有测试用例后，将汇总结果格式化为指定的单行字符串。\n\n该实现将使用 `numpy` 对 $TP(t)$ 和 $FP(t)$ 进行高效的基于数组的计算。区间合并逻辑将遍历实用性标志，以找到每个具有临床实用性阈值的连续块的开始和结束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements Decision Curve Analysis from first principles for multiple test cases.\n    \"\"\"\n    \n    # Common threshold grid for all test cases\n    T = np.array([0.1, 0.2, 0.33, 0.5, 0.67, 0.8, 0.9])\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"p_hat\": np.array([0.9, 0.8, 0.6, 0.55, 0.6, 0.45, 0.3, 0.2, 0.1, 0.05]),\n            \"y\": np.array([1, 1, 1, 1, 0, 0, 0, 0, 0, 0])\n        },\n        {\n            \"p_hat\": np.array([0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3]),\n            \"y\": np.array([1, 0, 0, 1, 0, 0, 1, 0, 0, 0])\n        },\n        {\n            \"p_hat\": np.array([0.9, 0.9, 0.9, 0.9, 0.9, 0.05, 0.05, 0.05, 0.05, 0.05]),\n            \"y\": np.array([1, 1, 1, 1, 1, 0, 0, 0, 0, 0])\n        },\n        {\n            \"p_hat\": np.array([0.55, 0.08, 0.45, 0.4, 0.35, 0.3, 0.25, 0.2, 0.12, 0.11]),\n            \"y\": np.array([1, 1, 0, 0, 0, 0, 0, 0, 0, 0])\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        p_hat = case[\"p_hat\"]\n        y = case[\"y\"]\n\n        N = len(y)\n        N_1 = np.sum(y)\n        N_0 = N - N_1\n\n        is_useful = []\n\n        for t in T:\n            # Avoid division by zero for t=1, though not in grid\n            if t == 1.0:\n                is_useful.append(False)\n                continue\n            \n            # Calculate TP and FP for the model at threshold t\n            decisions = p_hat >= t\n            tp = np.sum((decisions == 1)  (y == 1))\n            fp = np.sum((decisions == 1)  (y == 0))\n            \n            # Harm-to-benefit ratio implied by threshold t\n            h = t / (1 - t)\n\n            # Standardized Net Benefit (SNB) for the three strategies\n            snb_model = (tp - fp * h) / N\n            snb_all = (N_1 - N_0 * h) / N\n            snb_none = 0.0\n\n            # Check for clinical usefulness using strict inequality\n            if snb_model  snb_all and snb_model  snb_none:\n                is_useful.append(True)\n            else:\n                is_useful.append(False)\n\n        # Merge consecutive clinically useful thresholds into intervals\n        intervals = []\n        i = 0\n        while i  len(T):\n            if is_useful[i]:\n                # Found the start of a useful interval\n                t_min = T[i]\n                j = i\n                # Find the end of this contiguous block of useful thresholds\n                while j  len(T) and is_useful[j]:\n                    j += 1\n                t_max = T[j-1]\n                # Append the interval [t_min, t_max]\n                intervals.append([t_min, t_max])\n                # Continue searching from where this block ended\n                i = j\n            else:\n                i += 1\n        \n        all_results.append(intervals)\n    \n    # Convert each result item to its string representation for final output\n    # This also handles converting numpy floats to standard Python floats implicitly\n    # The str() on a list of lists works as required by the output format\n    str_results = [str(res) for res in all_results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```", "id": "4579973"}]}