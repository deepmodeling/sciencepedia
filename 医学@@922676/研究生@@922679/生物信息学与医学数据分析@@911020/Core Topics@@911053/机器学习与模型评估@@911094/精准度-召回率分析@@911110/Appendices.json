{"hands_on_practices": [{"introduction": "理论在应用于真实世界数据时才真正具有生命力。第一个实践将通过分析一个假设的癌症筛查测试结果，让您扎根于精确率和召回率的基本指标。通过从混淆矩阵中计算精确率、召回率和 $F_1$-分数，您将对这些数字在高风险临床环境中的实际含义有切实的理解。[@problem_id:4597653]", "problem": "一家临床基因组学实验室开发了一种机器学习分类器，该分类器整合了游离脱氧核糖核酸 (cfDNA) 甲基化谱与临床协变量，用于筛查无症状成年人的结直肠癌。在一项多中心前瞻性研究中，该分类器在一个独立的留出队列上，于一个固定的决策阈值下进行了评估。该研究招募了来自初级保健诊所的 $N$ 名年龄在 $50$–$75$ 岁之间且无既往癌症诊断的参与者；结肠镜检查被用作参考标准。在操作阈值下，来自留出队列的汇总混淆矩阵计数如下：\n- 真阳性 (TP): $180$\n- 假阳性 (FP): $300$\n- 假阴性 (FN): $45$\n- 真阴性 (TN): $4475$\n\n假设这些计数是准确的，并且在研究窗口期内结直肠癌的状态是恒定的。使用适用于生物信息学和医疗数据分析中二元分类的事件频率和条件概率的基本定义，计算在此阈值下的精确率-召回率指标，并推断在本次筛查背景下每项指标的临床意义。在您的推理中，明确地将精确率与检测阳性的个体中患病的概率联系起来，将召回率与患病个体被检测正确识别的概率联系起来，并评论疾病患病率如何影响精确率。\n\n最后，计算此操作点上精确率和召回率的调和平均数（$F_1$-分数），并将此单个标量作为您的最终数值答案报告。将您的最终数值答案四舍五入至四位有效数字，并将其表示为无量纲小数（无百分号）。", "solution": "在尝试任何解答之前，需对问题进行验证。\n\n### 步骤1：提取已知条件\n问题提供了用于结直肠癌筛查的机器学习分类器的混淆矩阵数据：\n- 真阳性 ($TP$): $180$\n- 假阳性 ($FP$): $300$\n- 假阴性 ($FN$): $45$\n- 真阴性 ($TN$): $4475$\n\n任务是计算精确率、召回率和F1分数。它还要求解释在此背景下精确率和召回率的临床意义，包括疾病患病率对精确率的影响。最终的数值答案必须是F1分数，四舍五入到四位有效数字。\n\n### 步骤2：使用提取的已知条件进行验证\n根据既定标准对问题进行评估。\n- **科学性**：该问题设置在医学诊断和机器学习评估的标准且现实的背景中。各项指标——$TP$、$FP$、$FN$、$TN$、精确率、召回率和F1分数——是二元分类性能分析的基础。使用cfDNA甲基化进行癌症筛查的情景是当前生物信息学研究的一个重要领域。所提供的计数在内部是一致的，并且对于一项筛查研究是合理的。\n- **良构性**：问题陈述是自洽的。它提供了计算所要求指标所需的所有必要数据（混淆矩阵计数）。目标是明确的：计算并解释特定的性能指标，并报告F1分数。存在唯一且稳定的解。\n- **客观性**：问题使用精确、定量且无偏见的语言进行阐述，不含任何主观论断。\n- **完整性与一致性**：数据对于此任务是完整的。患病个体总数（$TP + FN = 180 + 45 = 225$）与未患病个体总数（$FP + TN = 300 + 4475 = 4775$）之和等于检测为阳性的个体总数（$TP + FP = 180 + 300 = 480$）与检测为阴性的个体总数（$FN + TN = 45 + 4475 = 4520$）之和，因为 $225 + 4775 = 5000$ 且 $480 + 4520 = 5000$。数据是一致的。\n\n### 步骤3：结论与行动\n问题被判定为**有效**，因为它具有科学性、良构性、客观性且内部一致。我们可以继续进行解答。\n\n***\n\n解答首先根据提供的混淆矩阵计数定义核心指标。设 $D$ 表示个体患有结直肠癌的事件（“阳性”状况），$\\neg D$ 表示未患病的事件。设 $T^+$ 是分类器返回阳性结果的事件，$T^-$ 是返回阴性结果的事件。所提供的计数是：\n- 真阳性 ($TP$)：患病且检测结果为阳性的个体数量。$TP = 180$。\n- 假阳性 ($FP$)：未患病但检测结果为阳性的个体数量。$FP = 300$。\n- 假阴性 ($FN$)：患病但检测结果为阴性的个体数量。$FN = 45$。\n- 真阴性 ($TN$)：未患病且检测结果为阴性的个体数量。$TN = 4475$。\n\n从这些计数中，我们可以确定几个关键群体的总人数：\n- 患病总人数（状况为阳性）：$P = TP + FN = 180 + 45 = 225$。\n- 未患病总人数（状况为阴性）：$N = FP + TN = 300 + 4475 = 4775$。\n- 检测结果为阳性的总人数：$T_{pos} = TP + FP = 180 + 300 = 480$。\n- 检测结果为阴性的总人数：$T_{neg} = FN + TN = 45 + 4475 = 4520$。\n- 研究总人数：$N_{total} = TP + FP + FN + TN = 180 + 300 + 45 + 4475 = 5000$。\n\n问题要求计算和解释精确率和召回率。\n\n**精确率**，也称为阳性预测值 ($PPV$)，是指阳性检测结果中正确的比例。其定义为：\n$$\n\\text{Precision} = \\frac{TP}{TP + FP}\n$$\n从概率上讲，精确率是在检测结果为阳性的条件下患有该疾病的条件概率，即 $P(D|T^+)$。它回答了这样一个问题：“如果一名患者的检测结果为阳性，他实际患有癌症的概率是多少？”\n对于此分类器：\n$$\n\\text{Precision} = \\frac{180}{180 + 300} = \\frac{180}{480} = \\frac{3}{8} = 0.375\n$$\n精确率为 $0.375$ 意味着，在这种筛查环境下，检测结果为阳性的个体中只有 $37.5\\%$ 会经结肠镜检查确诊为结直肠癌。剩下的 $62.5\\%$ 是假阳性。这具有重大的临床意义：低精确率会导致大量健康个体接受不必要的、侵入性的、昂贵的后续检查（结肠镜检查），这会引起患者焦虑并加重医疗系统的负担。\n\n**召回率**，也称为灵敏度或真阳性率 ($TPR$)，是指所有患病个体中被检测正确识别的比例。其定义为：\n$$\n\\text{Recall} = \\frac{TP}{TP + FN}\n$$\n从概率上讲，召回率是在患有该疾病的条件下检测结果为阳性的条件概率，即 $P(T^+|D)$。它回答了这样一个问题：“在所有真正患有癌症的患者中，该检测能正确识别出多大比例？”\n对于此分类器：\n$$\n\\text{Recall} = \\frac{180}{180 + 45} = \\frac{180}{225} = \\frac{4}{5} = 0.8\n$$\n召回率为 $0.8$ 意味着该检测成功识别了研究人群中 $80\\%$ 的结直肠癌患者。剩下的 $20\\%$ 是假阴性——即被检测漏掉的患病个体。在癌症筛查的背景下，高召回率至关重要。漏诊（假阴性）会延误治疗，导致较差的临床结果。因此，召回率为 $0.8$ 表明，尽管该检测是有效的，但它仍然会漏掉五分之一的癌症病例。\n\n问题还要求评论疾病**患病率**如何影响精确率。研究队列中该疾病的患病率是指实际患病个体的比例：\n$$\n\\text{Prevalence} = \\frac{TP + FN}{N_{total}} = \\frac{225}{5000} = 0.045\n$$\n精确率、召回率和患病率之间的关系通过贝叶斯定理形式化。精确率 $P(D|T^+)$ 可以表示为：\n$$\n\\text{Precision} = P(D|T^+) = \\frac{P(T^+|D) P(D)}{P(T^+)}\n$$\n其中 $P(D)$ 是患病率，$P(T^+|D)$ 是召回率。分母 $P(T^+)$ 可以使用全概率公式展开：\n$$\nP(T^+) = P(T^+|D)P(D) + P(T^+|\\neg D)P(\\neg D)\n$$\n这里，$P(T^+|\\neg D)$ 是假阳性率 ($FPR = \\frac{FP}{FP+TN}$)，而 $P(\\neg D) = 1 - \\text{prevalence}$。代入得到：\n$$\n\\text{Precision} = \\frac{\\text{Recall} \\times \\text{Prevalence}}{\\text{Recall} \\times \\text{Prevalence} + \\text{FPR} \\times (1 - \\text{Prevalence})}\n$$\n这个方程表明，精确率高度依赖于患病率。即使对于一个具有优异召回率和低假阳性率的检测，如果疾病的患病率很低（这在无症状筛查人群的癌症检测中很典型），分母中的 $\\text{FPR} \\times (1 - \\text{Prevalence})$ 项相对于 $\\text{Recall} \\times \\text{Prevalence}$ 项可能会很大，从而降低精确率。在本例中，患病率为 $4.5\\%$，健康个体数量（$4775$）相对于患病个体数量（$225$）要多得多，这为假阳性的出现提供了许多机会，从而降低了精确率。\n\n最后，我们计算**F1分数**，它是精确率和召回率的调和平均数。它提供了一个平衡这两方面考量的单一指标。其定义为：\n$$\nF_1 = 2 \\times \\frac{\\text{Precision} \\times \\text{Recall}}{\\text{Precision} + \\text{Recall}}\n$$\n或者，它可以直接从混淆矩阵计数计算得出：\n$$\nF_1 = \\frac{2TP}{2TP + FP + FN}\n$$\n使用后一个公式直接计算：\n$$\nF_1 = \\frac{2 \\times 180}{2 \\times 180 + 300 + 45} = \\frac{360}{360 + 345} = \\frac{360}{705}\n$$\n计算小数值：\n$$\nF_1 = \\frac{360}{705} \\approx 0.51063829...\n$$\n问题要求将此值四舍五入到四位有效数字。\n$$\nF_1 \\approx 0.5106\n$$\n约 $0.5106$ 的F1分数反映了该分类器在此操作阈值下中等精确率（$0.375$）和高召回率（$0.8$）之间的权衡。", "answer": "$$\\boxed{0.5106}$$", "id": "4597653"}, {"introduction": "并非所有的错误都是等价的。虽然 $F_1$-分数同等看待精确率和召回率，但许多生物信息学应用需要更精细的权衡。这个练习挑战您使用广义的 $F_{\\beta}$-分数，它允许您明确地权衡避免假阳性与避免假阴性的重要性——这是临床决策中的一个关键考量。[@problem_id:4597657]", "problem": "一个临床基因变异检出程序在一个经过精心整理的肿瘤测序数据集上进行评估，该数据集具有体细胞突变检测中典型的显著类别不平衡特征。设该检出程序的精确率 $P$ 和召回率 $R$ 根据混淆矩阵计数定义为 $P = \\mathrm{TP}/(\\mathrm{TP}+\\mathrm{FP})$ 和 $R = \\mathrm{TP}/(\\mathrm{TP}+\\mathrm{FN})$，其中 $\\mathrm{TP}$ 表示真阳性，$\\mathrm{FP}$ 表示假阳性，$\\mathrm{FN}$ 表示假阴性。需要一个聚合分数 $F_{\\beta}(P,R)$ 来结合 $P$ 和 $R$，并满足以下要求：它在 $P$ 和 $R$ 上都是单调递增的，如果 $P=0$ 或 $R=0$ 则等于 $0$，当且仅当 $P=R=1$ 时等于 $1$，当 $\\beta=1$ 时在 $P$ 和 $R$ 上是对称的，并且对于一般的 $\\beta>0$，在惩罚 $P$ 和 $R$ 之间的不平衡时，它将召回率的权重视为精确率的 $\\beta$ 倍。从 $P$ 和 $R$ 的基本定义以及对 $F_{\\beta}$ 的规定要求出发，推导出一个与这些性质一致的 $F_{\\beta}(P,R)$ 的闭式表达式。然后，对于一个精确率 $P=0.98$ 且召回率 $R=0.85$ 的变异检出程序，计算 $F_{0.5}$ 和 $F_{2}$。将您的数值结果四舍五入到四位有效数字，并以小数形式表示。最后，阐明在临床变异检出的背景下，$\\beta$ 的哪种选择强调避免假阳性，哪种选择强调避免假阴性，并根据推导出的表达式及其参数依赖性简要证明您的解释。最终报告的值必须仅为计算出的 $F_{0.5}$ 和 $F_{2}$。", "solution": "该问题要求推导 $F_{\\beta}$ 分数，计算其在特定值下的结果，并解释参数 $\\beta$ 的含义。\n\n**1. $F_{\\beta}(P,R)$ 表达式的推导**\n\n问题为结合精确率 ($P$) 和召回率 ($R$) 的聚合分数 $F_{\\beta}(P,R)$ 提供了一系列要求。这些要求是标准 F-度量（F-measure）的特征，F-度量是精确率和召回率的加权调和平均值。调和平均值是合适的，因为它会严重惩罚任一指标较低的情况，从而满足了当 $P=0$ 或 $R=0$ 时 $F_{\\beta}=0$ 的要求。\n\n加权调和平均值的倒数是其各分量倒数的加权算术平均值。因此，我们可以将 $F_{\\beta}^{-1}$ 写成 $P^{-1}$ 和 $R^{-1}$ 的线性组合：\n$$F_{\\beta}^{-1} = \\alpha_P P^{-1} + \\alpha_R R^{-1}$$\n其中 $\\alpha_P$ 和 $\\alpha_R$ 是权重。为满足当 $P=R=1$ 时 $F_{\\beta}=1$ 的要求，权重必须归一化，使得 $\\alpha_P + \\alpha_R = 1$。\n\n关键要求是分数“将召回率的权重视为精确率的 $\\beta$ 倍”。在 F-度量的背景下，这通常通过将召回率倒数的权重与精确率倒数的权重之比设为 $\\beta^2$ 来形式化。这意味着：\n$$\\frac{\\alpha_R}{\\alpha_P} = \\beta^2$$\n使用 $\\beta^2$ 而不是 $\\beta$ 是一个标准惯例，源于 F-度量在检索有效性方面的理论基础。\n我们现在求解由两个方程组成的方程组来得到权重 $\\alpha_P$ 和 $\\alpha_R$：\n$$ \\begin{cases} \\alpha_P + \\alpha_R = 1 \\\\ \\alpha_R = \\beta^2 \\alpha_P \\end{cases} $$\n将第二个方程代入第一个方程得到：\n$$ \\alpha_P + \\beta^2 \\alpha_P = 1 \\implies \\alpha_P(1+\\beta^2) = 1 \\implies \\alpha_P = \\frac{1}{1+\\beta^2} $$\n那么，召回率的权重为：\n$$ \\alpha_R = 1 - \\alpha_P = 1 - \\frac{1}{1+\\beta^2} = \\frac{1+\\beta^2-1}{1+\\beta^2} = \\frac{\\beta^2}{1+\\beta^2} $$\n将这些权重代回 $F_{\\beta}^{-1}$ 的表达式中：\n$$F_{\\beta}^{-1} = \\frac{1}{1+\\beta^2} \\frac{1}{P} + \\frac{\\beta^2}{1+\\beta^2} \\frac{1}{R} = \\frac{1}{1+\\beta^2} \\left( \\frac{1}{P} + \\frac{\\beta^2}{R} \\right)$$\n取倒数以求得 $F_{\\beta}$：\n$$F_{\\beta} = (1+\\beta^2) \\left( \\frac{1}{\\frac{1}{P} + \\frac{\\beta^2}{R}} \\right)$$\n为了得到一个更常见的闭式形式，我们简化括号中的项：\n$$\\frac{1}{P} + \\frac{\\beta^2}{R} = \\frac{R + \\beta^2 P}{PR}$$\n将其代回，得到 $F_{\\beta}$ 分数的最终表达式：\n$$F_{\\beta}(P,R) = (1+\\beta^2) \\frac{PR}{\\beta^2 P + R}$$\n这个推导出的公式满足问题陈述中列出的所有性质。\n\n**2. 计算 $F_{0.5}$ 和 $F_{2}$**\n\n给定精确率 $P=0.98$ 和召回率 $R=0.85$。\n\n对于 $\\beta = 0.5$：\n$$F_{0.5} = (1 + (0.5)^2) \\frac{0.98 \\times 0.85}{(0.5)^2 \\times 0.98 + 0.85}$$\n$$F_{0.5} = (1 + 0.25) \\frac{0.833}{0.25 \\times 0.98 + 0.85}$$\n$$F_{0.5} = 1.25 \\times \\frac{0.833}{0.245 + 0.85} = 1.25 \\times \\frac{0.833}{1.095}$$\n$$F_{0.5} = \\frac{1.04125}{1.095} \\approx 0.9509132...$$\n四舍五入到四位有效数字，我们得到 $F_{0.5} = 0.9509$。\n\n对于 $\\beta = 2$：\n$$F_2 = (1 + 2^2) \\frac{0.98 \\times 0.85}{2^2 \\times 0.98 + 0.85}$$\n$$F_2 = (1 + 4) \\frac{0.833}{4 \\times 0.98 + 0.85}$$\n$$F_2 = 5 \\times \\frac{0.833}{3.92 + 0.85} = 5 \\times \\frac{0.833}{4.77}$$\n$$F_2 = \\frac{4.165}{4.77} \\approx 0.8731656...$$\n四舍五入到四位有效数字，我们得到 $F_2 = 0.8732$。\n\n**3. $\\beta$ 的解释**\n\n为了理解 $\\beta$ 如何与避免假阳性和假阴性相关联，我们可以用混淆矩阵的计数来表示 $F_{\\beta}$：真阳性 ($\\mathrm{TP}$)、假阳性 ($\\mathrm{FP}$) 和假阴性 ($\\mathrm{FN}$)。\n使用 $P = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}}$ 和 $R = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}$， $F_{\\beta}$ 公式变为：\n$$F_\\beta = (1+\\beta^2) \\frac{\\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}} \\cdot \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}}{\\beta^2 \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}} + \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}} = (1+\\beta^2) \\frac{\\mathrm{TP}}{\\beta^2(\\mathrm{TP}+\\mathrm{FN}) + (\\mathrm{TP}+\\mathrm{FP})} = \\frac{(1+\\beta^2)\\mathrm{TP}}{(1+\\beta^2)\\mathrm{TP} + \\beta^2\\mathrm{FN} + \\mathrm{FP}}$$\n从这个表达式中，我们观察到假阴性计数 $\\mathrm{FN}$ 的权重因子是 $\\beta^2$，而假阳性计数 $\\mathrm{FP}$ 的权重因子是 $1$。\n\n-   **避免假阳性 ($\\mathrm{FP}$) 的选择**：为了强调避免假阳性，我们必须更重地惩罚它们。这对应于使 $\\mathrm{FP}$ 上的权重大于或等于 $\\mathrm{FN}$ 上的权重。这意味着 $1 \\ge \\beta^2$，即 $0  \\beta \\le 1$。因此，选择 $\\beta  1$ (例如 $F_{0.5}$) 会更强调精确率，从而更强调避免假阳性。\n\n-   **避免假阴性 ($\\mathrm{FN}$) 的选择**：为了强调避免假阴性，我们必须更重地惩罚它们。这对应于使 $\\mathrm{FN}$ 上的权重大于 $\\mathrm{FP}$ 上的权重。这意味着 $\\beta^2 > 1$，即 $\\beta > 1$。因此，选择 $\\beta > 1$ (例如 $F_2$) 会更强调召回率，从而更强调避免假阴性。\n\n在临床背景下，假阴性可能意味着漏掉一个癌症突变，导致未能诊断或治疗患者。假阳性可能导致不必要的焦虑、活检或有毒治疗。$\\beta$ 的选择反映了对这两种错误类型的相对成本的临床判断。", "answer": "$$\\boxed{\\begin{pmatrix} 0.9509  0.8732 \\end{pmatrix}}$$", "id": "4597657"}, {"introduction": "模型的真实性能很少能通过单一阈值来捕捉。为了获得全貌，我们必须通过构建精确率-召回率曲线来评估其在所有可能工作点上的表现。这个编码挑战要求您从头开始实现PR曲线，并计算两个关键的汇总指标：平均精确率（AP）和曲线下面积（AUPRC），为您提供一个强大的模型比较工具。[@problem_id:4597637]", "problem": "给定遗传变异的排序预测分数和相应的二元基准真相标签，这些标签指明了每个变异是否为真正致病。目标是计算两个总结精确率-召回率性能的指标：平均精确率（AP）和精确率-召回率曲线下面积（AUPRC）。计算必须源自精确率和召回率的基本定义，并明确处理排序、相同分数（平局）以及精确率-召回率曲线的分段特性。\n\n基本假设和定义：\n- 一个二元分类任务会产生真阳性（TP）、假阳性（FP）、真阴性（TN）和假阴性（FN）的计数。对于一个从最高分到最低分扫描的排序预测列表，在任何前缀长度 $k$ 处，累积计数是通过将前 $k$ 个预测项与基准真相进行比较来定义的：一个被标记为致病的项会贡献给累积真阳性（TP），否则它会贡献给累积假阳性（FP）。\n- 在某个前缀处的精确率定义为 $P = \\dfrac{\\text{TP}}{\\text{TP} + \\text{FP}}$，其中真阳性（TP）和假阳性（FP）都是在该前缀处评估的。\n- 在某个前缀处的召回率定义为 $R = \\dfrac{\\text{TP}}{\\text{P}}$，其中 $\\text{P}$ 是数据集中真正阳性项的总数，与前缀无关。\n- 精确率-召回率（PR）曲线是通过按预测分数的降序扫描排序列表，并在召回率增加的每个点（即找到一个真正阳性项时）计算点对 $(R, P)$ 来构建的。预测分数中的相同分数必须通过保留相同分数项之间的原始输入顺序来确定性地处理（稳定排序）。\n\n分步AP要求：\n- 平均精确率（AP）是关于召回率的右连续精确率函数下的面积，其中在每个从识别出新的真阳性点开始的召回率区间内，精确率保持不变。通过聚合所有召回率增量的贡献，使用此分步定义来实现AP。如果数据集包含 $0$ 个真正阳性项，则定义AP为 $0$。\n\n梯形AUPRC要求：\n- 通过梯形法则计算的精确率-召回率曲线下面积（AUPRC）必须基于在召回率变化事件中提取的连续 $(R, P)$ 点之间的线性插值。为了覆盖从 $R = 0$ 到第一个召回率增加点的初始区间，应在前面加上点 $(R_0, P_0)$，其中 $R_0 = 0$ 且 $P_0$ 等于第一个召回率增加点处的精确率。如果数据集包含 $0$ 个真正阳性项，则定义AUPRC为 $0$。\n- 不要使用任何库提供的精确率-召回率积分工具。直接从上述定义推导这两个指标。\n\n排序与平局处理：\n- 按预测分数的降序对项目进行排序。\n- 对于相等的分数，保持原始输入顺序（稳定排序）。\n- 标签是二元的，$1$ 表示真正致病的变异，$0$ 表示良性变异。\n\n单位与输出表示：\n- 所有输出必须表示为小数，而不是百分比。\n- 你的程序必须将每个报告的指标四舍五入到 $6$ 位小数。\n\n测试套件：\n实现你的程序，为以下 $5$ 个测试用例计算这两个指标。在每个案例中，“scores”是预测置信度分数的列表，“labels”是基准真相二元标签（$1$ 表示致病，$0$ 表示良性）的列表。这些列表是逐元素对齐的。\n\n$1.$ 典型的混合情况：\n- 分数 (Scores): $[0.95, 0.90, 0.60, 0.55, 0.40, 0.30]$\n- 标签 (Labels): $[1, 0, 1, 0, 1, 0]$\n\n$2.$ 全为阴性：\n- 分数 (Scores): $[0.80, 0.50, 0.20]$\n- 标签 (Labels): $[0, 0, 0]$\n\n$3.$ 全为阳性：\n- 分数 (Scores): $[0.10, 0.20, 0.30, 0.40]$\n- 标签 (Labels): $[1, 1, 1, 1]$\n\n$4.$ 阴性样本中夹杂单个阳性样本，排名不一：\n- 分数 (Scores): $[0.20, 0.90, 0.50, 0.40, 0.70]$\n- 标签 (Labels): $[0, 0, 1, 0, 0]$\n\n$5.$ 分数存在平局且需要稳定排序：\n- 分数 (Scores): $[0.60, 0.60, 0.40, 0.40, 0.60]$\n- 标签 (Labels): $[1, 0, 1, 0, 1]$\n\n最终输出格式规范：\n- 对于每个测试用例，按 $(\\text{AP}, \\text{AUPRC})$ 的顺序输出两个浮点数，均四舍五入到 $6$ 位小数。\n- 将所有 $5$ 个测试用例的结果汇总到单行输出中，形式为用方括号括起来的逗号分隔列表。顺序必须是\n$$[\\text{AP}_1, \\text{AUPRC}_1, \\text{AP}_2, \\text{AUPRC}_2, \\text{AP}_3, \\text{AUPRC}_3, \\text{AP}_4, \\text{AUPRC}_4, \\text{AP}_5, \\text{AUPRC}_5].$$\n不应打印任何其他文本。", "solution": "用户要求从基本原理出发，为一系列排序的预测分数和二元标签计算平均精确率（AP）和精确率-召回率曲线下面积（AUPRC）。\n\n### 步骤1：提取已知条件\n- **任务**：计算平均精确率（AP）和精确率-召回率曲线下面积（AUPRC）。\n- **输入**：一个预测分数列表和对应的二元基准真相标签列表（$1$ 代表阳性/致病，$0$ 代表阴性/良性）。\n- **定义**：\n    - 在长度为 $k$ 的前缀处，累积真阳性（TP）和假阳性（FP）是通过扫描前 $k$ 个排序项来计算的。\n    - 精确率：$P = \\dfrac{\\text{TP}}{\\text{TP} + \\text{FP}}$。\n    - 召回率：$R = \\dfrac{\\text{TP}}{\\text{P}}$，其中 $\\text{P}$ 是数据集中真阳性的总数。\n- **排序**：项目按分数的降序排序。分数相同的情况通过保持原始输入顺序（稳定排序）来解决。\n- **PR曲线点**：在排序列表中遇到真阳性项（从而导致召回率增加）的每个点上，计算点对 $(R, P)$。\n- **AP规范**：AP是关于召回率的右连续精确率函数下的面积。它通过对每个真阳性实例处的精确率值进行求和来计算，并按召回率的变化进行加权。该公式等价于 $AP = \\sum_{k} P(k) \\Delta R(k)$，其中求和是在所有召回率增加的步骤上进行的。如果 $\\text{P}=0$，则 $AP=0$。\n- **AUPRC规范**：AUPRC需使用梯形法则，对在召回率增加事件中生成的 $(R, P)$ 点序列进行计算。必须前置一个特殊的起始点 $(R_0, P_0)$，其中 $R_0=0$，$P_0$ 是遇到的第一个真阳性处的精确率。如果 $\\text{P}=0$，则 $AUPRC=0$。\n- **输出格式**：结果为四舍五入到 $6$ 位小数的小数。最终输出是所有计算指标的单行逗号分隔列表：$[\\text{AP}_1, \\text{AUPRC}_1, \\dots, \\text{AP}_5, \\text{AUPRC}_5]$。\n- **测试用例**：提供了五对明确的 `scores` 和 `labels` 用于测试。\n\n### 步骤2：使用提取的已知条件进行验证\n根据验证标准对问题陈述进行分析。\n- **科学依据**：该问题基于精确率、召回率、平均精确率（AP）和精确率-召回率曲线下面积（AUPRC）等基本且成熟的概念，这些都是机器学习、统计学和生物信息学中的标准指标。所描述的特定计算方法（AP的分步法，AUPRC的梯形法）是这些指标的公认且有效的解释。\n- **适定性**：该问题是适定的。输入被清晰定义，排序算法（包括平局处理）被明确指定，计算AP和AUPRC的数学过程被无歧义地描述。这确保可以推导出唯一且稳定的解。\n- **客观性**：语言精确、定量，没有任何主观或基于观点的陈述。\n- **完整性与一致性**：问题是自洽的。它提供了所有必要的定义、常数（以测试数据的形式）和边界条件（例如，处理零阳性标签的情况）。没有内部矛盾。\n- **可行性**：所要求的计算在算法上是直接的，在计算上是可行的。提供的测试数据是现实的。\n\n该问题没有表现出科学上不健全、模糊、矛盾或不可行等任何缺陷。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将基于指定的原则开发一个解决方案。\n\n### 解法推导\n\n为给定的一组分数和标签计算AP和AUPRC的程序遵循一个结构化的、多步骤的过程，该过程直接从所提供的定义中推导出来。\n\n#### 1. 数据准备与排序\n首先，我们将分数和标签与其原始索引结合起来，以便进行稳定排序。然后，按预测分数的降序对项目进行排序。如果两个项目得分相同，则保留它们在原始输入中的相对顺序。这个排序后的列表构成了所有后续计算的基础。\n\n设输入为分数 $S = [s_1, s_2, \\dots, s_n]$ 和标签 $L = [l_1, l_2, \\dots, l_n]$。我们创建一个元组列表 $(s_i, l_i, i)$ 并对其进行排序，以获得一个排序后的标签列表 $L' = [l'_1, l'_2, \\dots, l'_n]$。\n\n#### 2. 计算总阳性样本数\n阳性实例的总数，记为 $\\text{P}$，是数据集中所有标签的总和。\n$$ \\text{P} = \\sum_{i=1}^{n} l_i $$\n如果 $\\text{P}=0$，问题规定AP和AUPRC都为 $0$。在这种情况下，过程终止。\n\n#### 3. 迭代计算PR点\n我们从 $k=1$ 到 $n$ 遍历排序后的标签列表 $L'$。在每个排名 $k$ 处，我们维持真阳性（$\\text{TP}_k$）和假阳性（$\\text{FP}_k$）的累积计数。\n$$ \\text{TP}_k = \\sum_{j=1}^{k} l'_j $$\n$$ \\text{FP}_k = k - \\text{TP}_k $$\n当遇到一个真阳性时（即 $l'_k = 1$），就会在精确率-召回率曲线上生成一个新点。在此排名 $k$ 处的精确率 $P_k$ 和召回率 $R_k$ 计算如下：\n$$ P_k = \\frac{\\text{TP}_k}{\\text{TP}_k + \\text{FP}_k} = \\frac{\\text{TP}_k}{k} $$\n$$ R_k = \\frac{\\text{TP}_k}{\\text{P}} $$\n这些点对 $(R_k, P_k)$ 被收集到一个列表中，我们称之为 `pr_points`。\n\n#### 4. 平均精确率 (AP) 计算\nAP是在每个发现真阳性的排名处的精确率的加权平均值，权重是召回率的变化。由于每个真阳性使召回率增加一个固定的量 $\\Delta R = 1/\\text{P}$，AP可以计算为对应于真阳性的每个排名 $k$ 处的精确率值之和，再除以阳性总数。\n设 $K_{pos} = \\{k \\mid l'_k = 1\\}$ 为发现真阳性的排名集合。AP为：\n$$ \\text{AP} = \\sum_{k \\in K_{pos}} P_k \\cdot \\Delta R_k = \\sum_{k \\in K_{pos}} P_k \\cdot \\frac{1}{\\text{P}} = \\frac{1}{\\text{P}} \\sum_{k \\in K_{pos}} P_k $$\n此公式直接实现了所要求的“分步定义”。\n\n#### 5. PR曲线下面积 (AUPRC) 计算\nAUPRC是使用梯形法则在收集的 `pr_points` 上计算的。根据问题规范，我们必须首先前置一个起始点。设 `pr_points` 中的第一个点为 $(R_1, P_1)$。前置的点是 $(R_0, P_0) = (0, P_1)$。\n我们用于积分的点序列变为 $[(0, P_1), (R_1, P_1), (R_2, P_2), \\dots, (R_m, P_m)]$，其中 $m = \\text{P}$。\n两个连续点 $(R_{i-1}, P_{i-1})$ 和 $(R_i, P_i)$ 之间的梯形面积由下式给出：\n$$ \\text{Area}_i = (R_i - R_{i-1}) \\times \\frac{P_i + P_{i-1}}{2} $$\n总AUPRC是增广列表中所有连续点对的这些面积之和。\n$$ \\text{AUPRC} = \\sum_{i=1}^{m} (R_i - R_{i-1}) \\times \\frac{P_i + P_{i-1}}{2} $$\n其中 $(R_0, P_0)$ 是我们特别构造的起始点。\n\n这种基于原理的、逐步的推导源自问题的公理，确保了正确性并遵守所有指定的约束。最终的实现将封装此逻辑。", "answer": "```python\nimport numpy as np\n\ndef compute_metrics(scores, labels):\n    \"\"\"\n    Computes Average Precision (AP) and Area Under the PR Curve (AUPRC)\n    from first principles for a given set of scores and labels.\n\n    Args:\n        scores (list or np.ndarray): A list of prediction scores.\n        labels (list or np.ndarray): A list of binary ground-truth labels (1 for positive, 0 for negative).\n\n    Returns:\n        tuple: A tuple containing (AP, AUPRC), rounded to 6 decimal places.\n    \"\"\"\n    scores = np.array(scores)\n    labels = np.array(labels)\n    \n    total_positives = np.sum(labels)\n    if total_positives == 0:\n        return 0.0, 0.0\n\n    # Stable sort by scores (descending) by using original indices as a secondary sort key\n    indices = np.arange(len(scores))\n    # np.lexsort sorts by the last key first. We use -scores for descending order.\n    sorted_indices = np.lexsort((indices, -scores))\n    sorted_labels = labels[sorted_indices]\n\n    tp_cumulative = 0\n    ap_sum = 0.0\n    pr_points = []\n\n    for i, label in enumerate(sorted_labels):\n        rank = i + 1\n        if label == 1:\n            tp_cumulative += 1\n            precision = tp_cumulative / rank\n            recall = tp_cumulative / total_positives\n            \n            # For AP calculation\n            ap_sum += precision\n            \n            # For AUPRC calculation\n            pr_points.append((recall, precision))\n\n    # Final AP calculation\n    ap = ap_sum / total_positives\n\n    # AUPRC calculation using the trapezoidal rule\n    auprc = 0.0\n    \n    if not pr_points:\n        # This case is covered by total_positives == 0 check, but for logical completeness\n        auprc = 0.0\n    else:\n        # Prepend the special starting point (R0=0, P0=P_first)\n        r_first, p_first = pr_points[0]\n        recall_points = np.array([0.0] + [p[0] for p in pr_points])\n        precision_points = np.array([p_first] + [p[1] for p in pr_points])\n        \n        # Integrate using the trapezoidal rule\n        # Area = sum of (delta_recall * avg_precision) for each segment\n        for i in range(1, len(recall_points)):\n            delta_recall = recall_points[i] - recall_points[i-1]\n            avg_precision = (precision_points[i] + precision_points[i-1]) / 2.0\n            auprc += delta_recall * avg_precision\n\n    return round(ap, 6), round(auprc, 6)\n\ndef solve():\n    \"\"\"\n    Processes the test suite and prints the final results in the specified format.\n    \"\"\"\n    test_cases = [\n        # 1. Typical mixed case\n        {'scores': [0.95, 0.90, 0.60, 0.55, 0.40, 0.30], 'labels': [1, 0, 1, 0, 1, 0]},\n        \n        # 2. All negatives\n        {'scores': [0.80, 0.50, 0.20], 'labels': [0, 0, 0]},\n        \n        # 3. All positives\n        {'scores': [0.10, 0.20, 0.30, 0.40], 'labels': [1, 1, 1, 1]},\n        \n        # 4. Single positive among negatives with varied ranking\n        {'scores': [0.20, 0.90, 0.50, 0.40, 0.70], 'labels': [0, 0, 1, 0, 0]},\n        \n        # 5. Ties in scores with stable ordering\n        {'scores': [0.60, 0.60, 0.40, 0.40, 0.60], 'labels': [1, 0, 1, 0, 1]}\n    ]\n\n    results = []\n    for case in test_cases:\n        ap, auprc = compute_metrics(case['scores'], case['labels'])\n        results.extend([ap, auprc])\n\n    # Final print statement in the exact required format.\n    # The format required is a string representation of a list of floats.\n    # Joining formatted strings is the most reliable way to achieve this.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "4597637"}]}