{"hands_on_practices": [{"introduction": "掌握临床术语的第一步是准确地选择代码。本练习 [@problem_id:4548271] 将挑战您把国际疾病分类 (International Classification of Diseases, ICD) 编码的复杂规则（例如优先选择特异性最高的代码和组合代码）形式化为一个精确的、确定性的算法。这项实践有助于您建立对人工编码和自动编码系统背后逻辑的基础理解。", "problem": "您将获得一个国际疾病分类（ICD，International Classification of Diseases）的简化、完全指定的抽象模型。该模型是一个分层术语体系，其中代码表示为与必需的文档特征和指示其特异性水平的属性相关联的元素。您必须实现一个程序，为每个文档场景选择最合适的单一 ICD 代码索引，并遵循关于特异性的 ICD 编码指南。选择过程必须纯粹用数学和逻辑术语来构建，且不得依赖于外部的文本解释。\n\n推导的基本依据：分层临床术语体系编码了定义递增特异性的父子关系；选择指南要求编码到文档所支持的最高特异性水平；当记录的多个状况可由单个代码涵盖时，必须优先选择组合代码。\n\n定义与形式化：\n- 设 $C = \\{c_0, c_1, \\dots, c_{n-1}\\}$ 是一个有限的代码集合。每个代码 $c_i$ 关联以下内容：\n  1. 一个必需特征集 $R(c_i) \\subseteq \\mathcal{F}$，其中 $\\mathcal{F}$ 是文档特征的全集。\n  2. 一个非负整数深度 $d(c_i) \\in \\mathbb{N}$，表示分层特异性（更大的 $d(c_i)$ 意味着更高的特异性）。\n  3. 一个布尔型未特指标志 $u(c_i) \\in \\{0,1\\}$，其中 $u(c_i) = 1$ 表示该代码包含一个未特指的限定词。\n  4. 一个非负严重性权重 $s(c_i) \\in \\mathbb{R}$，提供一个与临床重要性一致的次要决胜标准。\n  5. 一个索引 $i \\in \\{0,1,\\dots,n-1\\}$，表示代码在列表中的位置。\n- 设一个病例的文档表示为一个有限集合 $D \\subseteq \\mathcal{F}$。\n- 一个代码 $c_i$ 对 $D$ 是可采纳的，当且仅当 $R(c_i) \\subseteq D$。\n- 当 $c_i$ 可采纳时，其相对于 $D$ 的覆盖基数是 $k(c_i, D) = |R(c_i)|$，否则无定义。\n\n源自 ICD 指南的选择原则：\n- 在可采纳的代码中，优先选择那些直接将最多数量的已记录状况作为必需特征来捕获的代码（组合代码由更大的 $|R(c_i)|$ 体现）。\n- 在这些代码中，优先选择具有最大分层特异性 $d(c_i)$ 的代码。\n- 在这些代码中，优先选择不含未特指限定词的代码，即具有最小 $u(c_i)$ 的代码。\n- 在这些代码中，优先选择更大的临床严重性 $s(c_i)$。\n- 如果所有标准都打平，则选择最小的索引 $i$ 以确保确定性。\n\n形式上，对于给定的文档 $D$，定义可采纳集合 $A(D) = \\{c_i \\in C \\mid R(c_i) \\subseteq D\\}$。对于每个 $c_i \\in A(D)$，定义排序元组\n$$\n\\mathbf{r}(c_i, D) = \\left(k(c_i, D), \\; d(c_i), \\; 1 - u(c_i), \\; s(c_i), \\; -i\\right)\n$$\n并通过元组的字典序比较来选择 $c^\\ast = \\arg\\max_{c_i \\in A(D)} \\mathbf{r}(c_i, D)$。如果 $A(D) = \\varnothing$，则选择是无定义的；对于本问题，所有测试场景的构建都保证 $A(D) \\neq \\varnothing$。\n\n本问题的代码目录（每个 $c_i$ 均与其索引 $i$、文本标签、必需特征集 $R(c_i)$、深度 $d(c_i)$、未特指标志 $u(c_i)$ 和严重性 $s(c_i)$ 一同列出）：\n- $i = 0$：标签 \"E11.9\"，$R(c_0) = \\{\\text{diabetes}, \\text{type2}\\}$，$d(c_0) = 2$，$u(c_0) = 0$，$s(c_0) = 1.0$。\n- $i = 1$：标签 \"E11.40\"，$R(c_1) = \\{\\text{diabetes}, \\text{type2}, \\text{neuropathy}\\}$，$d(c_1) = 3$，$u(c_1) = 1$，$s(c_1) = 2.0$。\n- $i = 2$：标签 \"E11.42\"，$R(c_2) = \\{\\text{diabetes}, \\text{type2}, \\text{polyneuropathy}\\}$，$d(c_2) = 3$，$u(c_2) = 0$，$s(c_2) = 3.0$。\n- $i = 3$：标签 \"E10.9\"，$R(c_3) = \\{\\text{diabetes}, \\text{type1}\\}$，$d(c_3) = 2$，$u(c_3) = 0$，$s(c_3) = 1.0$。\n- $i = 4$：标签 \"S52.521A\"，$R(c_4) = \\{\\text{fracture}, \\text{radius}, \\text{left}, \\text{initial}, \\text{closed}\\}$，$d(c_4) = 4$，$u(c_4) = 0$，$s(c_4) = 2.5$。\n- $i = 5$：标签 \"S52.522A\"，$R(c_5) = \\{\\text{fracture}, \\text{radius}, \\text{right}, \\text{initial}, \\text{closed}\\}$，$d(c_5) = 4$，$u(c_5) = 0$，$s(c_5) = 2.5$。\n- $i = 6$：标签 \"S52.529A\"，$R(c_6) = \\{\\text{fracture}, \\text{radius}, \\text{initial}, \\text{closed}\\}$，$d(c_6) = 3$，$u(c_6) = 1$，$s(c_6) = 2.0$。\n- $i = 7$：标签 \"I10\"，$R(c_7) = \\{\\text{hypertension}\\}$，$d(c_7) = 2$，$u(c_7) = 0$，$s(c_7) = 1.0$。\n- $i = 8$：标签 \"I50.9\"，$R(c_8) = \\{\\text{heart\\_failure}\\}$，$d(c_8) = 2$，$u(c_8) = 1$，$s(c_8) = 2.0$。\n- $i = 9$：标签 \"I11.0\"，$R(c_9) = \\{\\text{hypertension}, \\text{heart\\_failure}\\}$，$d(c_9) = 3$，$u(c_9) = 0$，$s(c_9) = 3.5$。\n- $i = 10$：标签 \"S52.521D\"，$R(c_{10}) = \\{\\text{fracture}, \\text{radius}, \\text{left}, \\text{subsequent}\\}$，$d(c_{10}) = 4$，$u(c_{10}) = 0$，$s(c_{10}) = 2.5$。\n- $i = 11$：标签 \"S52.521A\\_open\"，$R(c_{11}) = \\{\\text{fracture}, \\text{radius}, \\text{left}, \\text{initial}, \\text{open}\\}$，$d(c_{11}) = 4$，$u(c_{11}) = 0$，$s(c_{11}) = 2.7$。\n\n测试套件：\n- 案例 1：$D_1 = \\{\\text{diabetes}, \\text{type2}, \\text{polyneuropathy}\\}$。\n- 案例 2：$D_2 = \\{\\text{fracture}, \\text{radius}, \\text{left}, \\text{initial}, \\text{closed}\\}$。\n- 案例 3：$D_3 = \\{\\text{fracture}, \\text{radius}, \\text{initial}, \\text{closed}\\}$。\n- 案例 4：$D_4 = \\{\\text{hypertension}, \\text{heart\\_failure}\\}$。\n- 案例 5：$D_5 = \\{\\text{diabetes}, \\text{type1}\\}$。\n- 案例 6：$D_6 = \\{\\text{hypertension}\\}$。\n- 案例 7：$D_7 = \\{\\text{fracture}, \\text{radius}, \\text{left}, \\text{subsequent}\\}$。\n- 案例 8：$D_8 = \\{\\text{diabetes}, \\text{type2}, \\text{neuropathy}\\}$。\n- 案例 9：$D_9 = \\{\\text{fracture}, \\text{radius}, \\text{left}, \\text{initial}, \\text{open}\\}$。\n\n您的任务：\n- 实现一个完整的、可运行的程序，该程序为每个案例 $D_j$ 计算可采纳集合 $A(D_j)$，应用上面定义的字典序排名 $\\mathbf{r}(c_i, D_j)$，并返回所选代码的索引 $i^\\ast$。\n- 所有输出都必须是整数。不涉及物理单位，也不涉及角度。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的选择索引列表，并用方括号括起来（例如，$[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_9]$）。程序必须是自包含的，且不要求任何输入。\n\n覆盖性设计：\n- 案例 1 练习在特定并发症的糖尿病代码中进行选择。\n- 案例 2 练习具有偏侧性和就诊类型的完全特异性。\n- 案例 3 练习由于缺少偏侧性信息而回退到特异性较低的代码。\n- 案例 4 练习组合代码相对于独立的单一状况代码的优先选择。\n- 案例 5 和案例 6 练习单一状况的选择。\n- 案例 7 练习后续就诊。\n- 案例 8 对比 2 型糖尿病中特指与未特指的神经病变。\n- 案例 9 在初次就诊时区分开放性骨折与闭合性骨折。", "solution": "该问题要求实现一个确定性算法，根据一组给定的文档特征，从一个给定的目录中选择最合适的临床代码。选择过程遵循一套形式化的规则层次，这些规则源自标准的临床编码指南，主要涉及特异性和完整性。该问题定义明确、在数学上自洽，并且是算法可解的。\n\n问题的核心在于将所提供的选择原则转化为一个计算过程。我们获得一个代码目录 $C = \\{c_0, c_1, \\dots, c_{11}\\}$，其中每个代码 $c_i$ 由五个属性来表征：其索引 $i$、一个必需特征集 $R(c_i)$、一个分层深度 $d(c_i)$、一个未特指标志 $u(c_i)$ 和一个严重性权重 $s(c_i)$。我们还获得了一系列文档场景，每个场景都表示为一个特征集 $D_j$。\n\n对于一个给定的文档集 $D$，其选择算法分两个主要阶段进行：筛选和排序。\n\n首先，我们识别可采纳代码的集合，记为 $A(D)$。一个代码 $c_i$ 被定义为可采纳的，当且仅当其所有必需特征都出现在文档中。这是一个集合论的子集条件：\n$$\nA(D) = \\{c_i \\in C \\mid R(c_i) \\subseteq D\\}\n$$\n此步骤确保我们只考虑那些得到可用文档完全支持的代码。\n\n其次，对于每个可采纳代码 $c_i \\in A(D)$，我们必须根据指定的多级标准来评估其适宜性。这些标准被封装在一个排序元组 $\\mathbf{r}(c_i, D)$ 中。问题将此元组定义为：\n$$\n\\mathbf{r}(c_i, D) = \\left( k(c_i, D), \\; d(c_i), \\; 1 - u(c_i), \\; s(c_i), \\; -i \\right)\n$$\n其中 $k(c_i, D) = |R(c_i)|$ 是覆盖基数。最优代码 $c^\\ast$ 是在字典序比较下使该元组最大化的代码。让我们按优先顺序分析元组的各个组成部分：\n\n1.  $k(c_i, D) = |R(c_i)|$：这是首要标准。最大化必需特征集的大小，优先选择能将多个已记录状况合并到单一代码中的“组合代码”，这是一项基本指南。\n2.  $d(c_i)$：这是第二个标准，用于打破第一个标准的平局。最大化深度 $d(c_i)$ 对应于选择层次结构中最具特异性的代码。\n3.  $1 - u(c_i)$：这是第三个标准。对于未特指的代码，$u(c_i)$ 为 1，对于特指的代码则为 0。为了优先选择特指代码，我们必须最小化 $u(c_i)$。最大化转换后的值 $1 - u(c_i)$ 实现了这一点，因为 $1 - 0 = 1$ 大于 $1 - 1 = 0$。\n4.  $s(c_i)$：第四个标准是最大化严重性权重 $s(c_i)$，在前面所有标准都相等时，提供一个临床相关的决胜标准。\n5.  $-i$：这是最后的确定性决胜标准。为了在完全平局的情况下选择索引最小的代码 $i$，我们最大化值 $-i$。\n\n因此，所选代码的索引 $i^\\ast$ 由以下公式给出：\n$$\ni^\\ast = \\text{index of } \\arg\\max_{c_i \\in A(D)} \\mathbf{r}(c_i, D)\n$$\n\n让我们将此过程应用于案例 4，其文档为 $D_4 = \\{\\text{hypertension}, \\text{heart\\_failure}\\}$。\n\n首先，我们确定可采纳集合 $A(D_4)$。我们检查目录中的每个代码：\n- $c_7$: $R(c_7) = \\{\\text{hypertension}\\} \\subseteq D_4$。可采纳。\n- $c_8$: $R(c_8) = \\{\\text{heart\\_failure}\\} \\subseteq D_4$。可采纳。\n- $c_9$: $R(c_9) = \\{\\text{hypertension}, \\text{heart\\_failure}\\} \\subseteq D_4$。可采纳。\n所有其他代码都包含 $D_4$ 中没有的必需特征，因此 $A(D_4) = \\{c_7, c_8, c_9\\}$。\n\n接下来，我们为每个可采纳代码计算排序元组：\n- 对于 $c_7$ ($i=7$)：$k=1$, $d=2$, $u=0$, $s=1.0$。元组为 $\\mathbf{r}(c_7, D_4) = (1, 2, 1-0, 1.0, -7) = (1, 2, 1, 1.0, -7)$。\n- 对于 $c_8$ ($i=8$)：$k=1$, $d=2$, $u=1$, $s=2.0$。元组为 $\\mathbf{r}(c_8, D_4) = (1, 2, 1-1, 2.0, -8) = (1, 2, 0, 2.0, -8)$。\n- 对于 $c_9$ ($i=9$)：$k=2$, $d=3$, $u=0$, $s=3.5$。元组为 $\\mathbf{r}(c_9, D_4) = (2, 3, 1-0, 3.5, -9) = (2, 3, 1, 3.5, -9)$。\n\n最后，我们对这些元组进行字典序比较：\n- $\\mathbf{r}(c_9, D_4)$ vs. $\\mathbf{r}(c_7, D_4)$：$\\mathbf{r}(c_9, D_4)$ 的第一个分量是 2，而 $\\mathbf{r}(c_7, D_4)$ 的是 1。因为 $2 > 1$，所以 $\\mathbf{r}(c_9, D_4)$ 更大。\n- $\\mathbf{r}(c_9, D_4)$ vs. $\\mathbf{r}(c_8, D_4)$：$\\mathbf{r}(c_9, D_4)$ 的第一个分量是 2，而 $\\mathbf{r}(c_8, D_4)$ 的是 1。因为 $2 > 1$，所以 $\\mathbf{r}(c_9, D_4)$ 更大。\n\n组合代码 $c_9$ 被选中，因为它的覆盖基数 $k=2$ 是最高的，这反映了它能够捕获两种已记录状况的能力。比较在第一个标准处就停止了，所选的索引是 9。\n\n对每个测试案例实施此逻辑，以生成最终的结果序列。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ICD code selection problem by implementing the specified\n    ranking and selection algorithm.\n    \"\"\"\n    \n    # Define the code catalog as a list of dictionaries.\n    # R(c_i) is stored as a set for efficient subset checking.\n    code_catalog = [\n        {'i': 0, 'label': 'E11.9', 'R': {'diabetes', 'type2'}, 'd': 2, 'u': 0, 's': 1.0},\n        {'i': 1, 'label': 'E11.40', 'R': {'diabetes', 'type2', 'neuropathy'}, 'd': 3, 'u': 1, 's': 2.0},\n        {'i': 2, 'label': 'E11.42', 'R': {'diabetes', 'type2', 'polyneuropathy'}, 'd': 3, 'u': 0, 's': 3.0},\n        {'i': 3, 'label': 'E10.9', 'R': {'diabetes', 'type1'}, 'd': 2, 'u': 0, 's': 1.0},\n        {'i': 4, 'label': 'S52.521A', 'R': {'fracture', 'radius', 'left', 'initial', 'closed'}, 'd': 4, 'u': 0, 's': 2.5},\n        {'i': 5, 'label': 'S52.522A', 'R': {'fracture', 'radius', 'right', 'initial', 'closed'}, 'd': 4, 'u': 0, 's': 2.5},\n        {'i': 6, 'label': 'S52.529A', 'R': {'fracture', 'radius', 'initial', 'closed'}, 'd': 3, 'u': 1, 's': 2.0},\n        {'i': 7, 'label': 'I10', 'R': {'hypertension'}, 'd': 2, 'u': 0, 's': 1.0},\n        {'i': 8, 'label': 'I50.9', 'R': {'heart_failure'}, 'd': 2, 'u': 1, 's': 2.0},\n        {'i': 9, 'label': 'I11.0', 'R': {'hypertension', 'heart_failure'}, 'd': 3, 'u': 0, 's': 3.5},\n        {'i': 10, 'label': 'S52.521D', 'R': {'fracture', 'radius', 'left', 'subsequent'}, 'd': 4, 'u': 0, 's': 2.5},\n        {'i': 11, 'label': 'S52.521A_open', 'R': {'fracture', 'radius', 'left', 'initial', 'open'}, 'd': 4, 'u': 0, 's': 2.7},\n    ]\n\n    # Define the test suite documentation sets.\n    test_cases = [\n        {'diabetes', 'type2', 'polyneuropathy'}, # Case 1\n        {'fracture', 'radius', 'left', 'initial', 'closed'}, # Case 2\n        {'fracture', 'radius', 'initial', 'closed'}, # Case 3\n        {'hypertension', 'heart_failure'}, # Case 4\n        {'diabetes', 'type1'}, # Case 5\n        {'hypertension'}, # Case 6\n        {'fracture', 'radius', 'left', 'subsequent'}, # Case 7\n        {'diabetes', 'type2', 'neuropathy'}, # Case 8\n        {'fracture', 'radius', 'left', 'initial', 'open'}, # Case 9\n    ]\n\n    results = []\n    for documentation_set in test_cases:\n        admissible_codes = []\n        # Step 1: Find all admissible codes\n        for code in code_catalog:\n            if code['R'].issubset(documentation_set):\n                admissible_codes.append(code)\n\n        # Step 2: For each admissible code, compute its ranking tuple\n        ranked_candidates = []\n        for code in admissible_codes:\n            k = len(code['R'])\n            d = code['d']\n            u_transformed = 1 - code['u']\n            s = code['s']\n            neg_i = -code['i']\n            \n            ranking_tuple = (k, d, u_transformed, s, neg_i)\n            ranked_candidates.append((ranking_tuple, code['i']))\n        \n        # Step 3: Select the code with the lexicographically largest ranking tuple\n        # The max() function on a list of tuples performs this comparison automatically.\n        if ranked_candidates:\n            best_candidate = max(ranked_candidates, key=lambda item: item[0])\n            selected_index = best_candidate[1]\n            results.append(selected_index)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4548271"}, {"introduction": "在学会选择单个代码后，下一步常见任务是为分析定义和检索概念组。本练习 [@problem_id:4548301] 介绍了 SNOMED CT 表达式约束语言 (Expression Constraint Language, ECL)，这是一种用于构建可计算表型的强大工具。通过将复杂的临床查询转化为集合论操作，您将培养从大型临床数据集中精确定义和提取队列所需的逻辑技能。", "problem": "一个研究团队正在设计一个可计算表型管道，该管道使用SNOMED CT表达约束语言（ECL）查询Systematized Nomenclature of Medicine—Clinical Terms (SNOMED CT)。该团队希望识别指定了致病源的肺部炎症性临床发现，并排除肺炎。该查询使用了后代或自身运算符和属性组语义。尽管为了实现互操作性，通常会考虑与国际疾病分类（International Classification of Diseases, ICD）、现行医疗程序术语（Current Procedural Terminology, CPT）以及逻辑观察标识符名称和代码（Logical Observation Identifiers Names and Codes, LOINC）的映射，但它们不属于本次计算的一部分。\n\n假设使用以下ECL（带有属性分组，以使大括号内的所有属性出现在同一个角色组内）：\n\n$$ $404684003$ $|$Clinical finding$|$ $:$ $\\{$ $363698007$ $|$Finding site$|$ $=$ $$ $39607008$ $|$Lung structure$|$, $116676008$ $|$Associated morphology$|$ $=$ $$ $409774005$ $|$Inflammatory morphology$|$, $246075003$ $|$Causative agent$|$ $=$ $\\big($ $$ $49872002$ $|$Virus$|$ OR $$ $410607006$ $|$Bacteria$|$ $\\big)$ $\\}$ MINUS $$ $233604007$ $|$Pneumonia$|$.\n\n请根据其标准的SNOMED CT ECL语义解释这些运算符：$$ 返回包含一个概念及其所有后代的集合；属性分组要求所列属性在概念定义中至少一个共同的角色组内共现；而 MINUS 表示集合差集。\n\n给定来自医院SNOMED CT模块的以下一致计数，这些计数是针对 $404684003$ $|$Clinical finding$|$ 的后代或自身，并且满足上述指定的分组的肺部和炎症属性的概念子集：\n\n- 设 $\\mathcal{L}$ 为满足分组约束 $|$Finding site$|$ $=$ $$ $39607008$ 和 $|$Associated morphology$|$ $=$ $$ $409774005$ 的概念集。那么 $|\\mathcal{L}|$ $=$ $2600$。\n- 设 $\\mathcal{M}$ 为 $\\mathcal{L}$ 中也具有 $|$Causative agent$|$ $=$ $$ $49872002$ $|$Virus$|$ 的子集。那么 $|\\mathcal{M}|$ $=$ $900$。\n- 设 $\\mathcal{B}$ 为 $\\mathcal{L}$ 中也具有 $|$Causative agent$|$ $=$ $$ $410607006$ $|$Bacteria$|$ 的子集。那么 $|\\mathcal{B}|$ $=$ $1100$。\n- 一些概念指定了多个致病源；其交集满足 $|\\mathcal{M} \\cap \\mathcal{B}|$ $=$ $200$。\n- 设 $\\mathcal{P}$ 为集合 $$ $233604007$ $|$Pneumonia$|$。假设 $\\mathcal{P}$ 中的每个概念都在 $\\mathcal{L}$ 中（即，每个这样的概念都满足分组的肺部和炎症约束）。$\\mathcal{P}$ 内的致病源计数为：$|\\mathcal{P} \\cap \\mathcal{M}|$ $=$ $400$， $|\\mathcal{P} \\cap \\mathcal{B}|$ $=$ $700$，以及 $|\\mathcal{P} \\cap \\mathcal{M} \\cap \\mathcal{B}|$ $=$ $100$。\n\n仅使用后代或自身、属性分组、集合并集、交集和差集的形式语义，确定上述ECL返回的SNOMED CT概念的确切数量。请以不带单位的精确整数形式给出最终答案。", "solution": "该问题已经过验证，被认为是一个基于集合论形式原理和SNOMED CT结构的自洽且适定的问题。\n\n目标是确定给定的SNOMED CT表达约束语言（ECL）查询返回的概念数量。我们必须首先将ECL查询转换为一个形式化的集合论表达式，然后使用所提供的数据计算结果集的基数。\n\nECL查询是：\n$$ $404684003$ $|$Clinical finding$|$ $:$ $\\{$ $363698007$ $|$Finding site$|$ $=$ $$ $39607008$ $|$Lung structure$|$, $116676008$ $|$Associated morphology$|$ $=$ $$ $409774005$ $|$Inflammatory morphology$|$, $246075003$ $|$Causative agent$|$ $=$ $\\big($ $$ $49872002$ $|$Virus$|$ OR $$ $410607006$ $|$Bacteria$|$ $\\big)$ $\\}$ MINUS $$ $233604007$ $|$Pneumonia$|$.\n\n让我们将此查询返回的概念集表示为 $\\mathcal{R}$。该查询可以分解如下：\n1. 概念的基础集合由位于肺部结构中的炎症性临床发现组成。问题将此集合定义为 $\\mathcal{L}$，其基数为 $|\\mathcal{L}| = 2600$。查询的这一部分是： `$$ $404684003$ $|$Clinical finding$|$ $:$ $\\{$ $363698007$ $|$Finding site$|$ $=$ $$ $39607008$, $116676008$ $|$Associated morphology$|$ $=$ $$ $409774005$ $\\}$`。\n\n2. 这个基础集合被致病源进一步约束。约束 `$|Causative agent|$ $=$ $\\big($ $$ $49872002$ $|$Virus$|$ OR $$ $410607006$ $|$Bacteria$|$ $\\big)$` 从 $\\mathcal{L}$ 中选择那些致病源是病毒或细菌（或两者都是）的概念。\n设 $\\mathcal{M}$ 为 $\\mathcal{L}$ 中致病源为病毒的子集。问题提供 $|\\mathcal{M}| = 900$。\n设 $\\mathcal{B}$ 为 $\\mathcal{L}$ 中致病源为细菌的子集。问题提供 $|\\mathcal{B}| = 1100$。\n$\\mathcal{L}$ 中满足 `OR` 条件的概念集是这两个集合的并集 $\\mathcal{M} \\cup \\mathcal{B}$。\n\n3. `MINUS` 运算符对应于集合差集。它移除了集合 `$$ $233604007$ $|$Pneumonia$|$` 的所有成员概念。该集合表示为 $\\mathcal{P}$。\n\n结合这些部分，最终的概念集 $\\mathcal{R}$ 由以下表达式给出：\n$$\n\\mathcal{R} = (\\mathcal{M} \\cup \\mathcal{B}) \\setminus \\mathcal{P}\n$$\n我们的目标是找到这个集合的基数 $|\\mathcal{R}|$。\n\n使用集合差集的基数公式 $|A \\setminus B| = |A| - |A \\cap B|$，我们可以写出：\n$$\n|\\mathcal{R}| = |(\\mathcal{M} \\cup \\mathcal{B})| - |(\\mathcal{M} \\cup \\mathcal{B}) \\cap \\mathcal{P}|\n$$\n\n我们将分别计算右侧的两项。\n\n首先，我们使用容斥原理计算 $|\\mathcal{M} \\cup \\mathcal{B}|$：\n$$\n|\\mathcal{M} \\cup \\mathcal{B}| = |\\mathcal{M}| + |\\mathcal{B}| - |\\mathcal{M} \\cap \\mathcal{B}|\n$$\n问题提供了必要的值：$|\\mathcal{M}| = 900$，$|\\mathcal{B}| = 1100$，以及 $|\\mathcal{M} \\cap \\mathcal{B}| = 200$。代入这些值：\n$$\n|\\mathcal{M} \\cup \\mathcal{B}| = 900 + 1100 - 200 = 2000 - 200 = 1800\n$$\n\n其次，我们计算 $|(\\mathcal{M} \\cup \\mathcal{B}) \\cap \\mathcal{P}|$。使用交集对并集的分配律，我们有：\n$$\n(\\mathcal{M} \\cup \\mathcal{B}) \\cap \\mathcal{P} = (\\mathcal{M} \\cap \\mathcal{P}) \\cup (\\mathcal{B} \\cap \\mathcal{P})\n$$\n我们再次应用容斥原理来求这个并集的基数：\n$$\n|(\\mathcal{M} \\cap \\mathcal{P}) \\cup (\\mathcal{B} \\cap \\mathcal{P})| = |\\mathcal{M} \\cap \\mathcal{P}| + |\\mathcal{B} \\cap \\mathcal{P}| - |(\\mathcal{M} \\cap \\mathcal{P}) \\cap (\\mathcal{B} \\cap \\mathcal{P})|\n$$\n这两个集合的交集简化为 $\\mathcal{M} \\cap \\mathcal{B} \\cap \\mathcal{P}$。所以表达式变为：\n$$\n|(\\mathcal{M} \\cup \\mathcal{B}) \\cap \\mathcal{P}| = |\\mathcal{M} \\cap \\mathcal{P}| + |\\mathcal{B} \\cap \\mathcal{P}| - |\\mathcal{M} \\cap \\mathcal{B} \\cap \\mathcal{P}|\n$$\n问题提供了这些交集的值：$|\\mathcal{M} \\cap \\mathcal{P}| = 400$，$|\\mathcal{B} \\cap \\mathcal{P}| = 700$，以及 $|\\mathcal{M} \\cap \\mathcal{B} \\cap \\mathcal{P}| = 100$。代入这些值：\n$$\n|(\\mathcal{M} \\cup \\mathcal{B}) \\cap \\mathcal{P}| = 400 + 700 - 100 = 1100 - 100 = 1000\n$$\n\n最后，我们将计算出的基数代回到 $|\\mathcal{R}|$ 的表达式中：\n$$\n|\\mathcal{R}| = |\\mathcal{M} \\cup \\mathcal{B}| - |(\\mathcal{M} \\cup \\mathcal{B}) \\cap \\mathcal{P}| = 1800 - 1000 = 800\n$$\n指定的ECL查询返回的SNOMED CT概念总数为 $800$。所提供的信息 $|\\mathcal{L}| = 2600$ 用于确保一致性，因为 $|\\mathcal{M} \\cup \\mathcal{B}| = 1800 \\le 2600$，但并未直接用于最终计算。$\\mathcal{P} \\subseteq \\mathcal{L}$ 的假设也确保了模型的逻辑一致性，因为从 $\\mathcal{P}$ 中减去概念是有意义的，因为它们是 $\\mathcal{M}$ 和 $\\mathcal{B}$ 所源自的同一个超集 $\\mathcal{L}$ 的一部分。", "answer": "$$\\boxed{800}$$", "id": "4548301"}, {"introduction": "高级分析不仅需要选择或分组代码，更要求理解不同临床概念之间的*语义关系*。本练习 [@problem_id:4548273] 将指导您实现基于术语集层次结构和语料库中概念统计流行度的基本相似度量化指标。这项技能对于患者相似性分析、队列扩展和预测建模等应用至关重要。", "problem": "实现一个程序，该程序在一个以医学系统命名法临床术语 (Systematized Nomenclature of Medicine Clinical Terms, SNOMED CT) 为模型的小型固定概念层次结构中，为成对的临床概念计算基于原则的语义相似度和基于分类法的度量。目标是从概率和信息内容的基本定义以及分类法的图论属性中推导出这些度量，而不依赖任何外部资源。\n\n基本基础和所需推导：\n- 使用语料库频率的概率定义：对于一个概念 $c$，令 $f(c)$ 表示其传播频率，通过对以 $c$ 为根的子树中所有叶子标注的计数求和得到。令 $N$ 为语料库中叶子标注的总数。$c$ 的经验概率为 $p(c) = f(c)/N$。\n- 使用信息论 (Shannon) 中的自信息定义：一个概念 $c$ 的信息内容为 $\\mathrm{IC}(c) = -\\ln p(c)$，使用自然对数。\n- 使用分类法的定义，即一个有根有向无环图，其偏序由父子（“is-a”）关系的传递闭包导出。对于任意两个节点 $a$ 和 $b$，将最小公共包含者 $\\mathrm{LCS}(a,b)$ 定义为分类法中 $a$ 和 $b$ 的最深（最大深度）共同祖先。假设为树形结构，因此 $\\mathrm{LCS}$ 是唯一的。\n- 基于这些基础，推导并实现两个概念 $a$ 和 $b$ 之间的三种信息论度量：\n  1. 共享信息定义为最小公共包含者的信息内容，即 $\\mathrm{shared\\_IC}(a,b) = \\mathrm{IC}(\\mathrm{LCS}(a,b))$。\n  2. 一种归一化相似度，对于 $a$ 和 $b$ 是对称的，当 $a=b$ 时等于 $1$，当仅共享根节点时减小到 $0$；从共享信息与总自信息的比率推导得出：$\\mathrm{norm\\_sim}(a,b) = \\dfrac{2\\,\\mathrm{IC}(\\mathrm{LCS}(a,b))}{\\mathrm{IC}(a)+\\mathrm{IC}(b)}$，约定当分母为 $0$ 且 $a=b$ 时，值为 $1$，否则为 $0$。\n  3. 对应于非共享信息的信息论距离：$\\mathrm{it\\_dist}(a,b) = \\mathrm{IC}(a)+\\mathrm{IC}(b)-2\\,\\mathrm{IC}(\\mathrm{LCS}(a,b))$。\n- 此外，从分类法无向图上的最短路径长度 $\\ell(a,b)$ 推导出一个基于图论路径的相似度：$\\mathrm{path\\_sim}(a,b) = \\dfrac{1}{1+\\ell(a,b)}$。在一个有根树中，$\\ell(a,b) = \\mathrm{depth}(a)+\\mathrm{depth}(b)-2\\,\\mathrm{depth}(\\mathrm{LCS}(a,b))$，其中 $\\mathrm{depth}(\\text{root})=0$ 且每条边使深度增加 $1$。\n\n使用的分类法、语料库和约束：\n- 概念（节点标识符和非正式标签）：\n  - $\\text{SCT\\_000}$: 临床发现 (根)\n  - $\\text{SCT\\_100}$: 传染病\n  - $\\text{SCT\\_110}$: 呼吸道感染\n  - $\\text{SCT\\_120}$: 胃肠道感染\n  - $\\text{SCT\\_111}$: 流感\n  - $\\text{SCT\\_112}$: 肺炎\n  - $\\text{SCT\\_121}$: 病毒性肠胃炎\n  - $\\text{SCT\\_200}$: 肿瘤\n  - $\\text{SCT\\_210}$: 肺癌\n  - $\\text{SCT\\_220}$: 乳腺癌\n  - $\\text{SCT\\_300}$: 内分泌疾病\n  - $\\text{SCT\\_310}$: 糖尿病\n- 父子（“is-a”）边（从父节点指向子节点）：\n  - $\\text{SCT\\_000} \\to \\text{SCT\\_100}$, $\\text{SCT\\_000} \\to \\text{SCT\\_200}$, $\\text{SCT\\_000} \\to \\text{SCT\\_300}$\n  - $\\text{SCT\\_100} \\to \\text{SCT\\_110}$, $\\text{SCT\\_100} \\to \\text{SCT\\_120}$\n  - $\\text{SCT\\_110} \\to \\text{SCT\\_111}$, $\\text{SCT\\_110} \\to \\text{SCT\\_112}$\n  - $\\text{SCT\\_120} \\to \\text{SCT\\_121}$\n  - $\\text{SCT\\_200} \\to \\text{SCT\\_210}$, $\\text{SCT\\_200} \\to \\text{SCT\\_220}$\n  - $\\text{SCT\\_300} \\to \\text{SCT\\_310}$\n- 语料库叶子标注计数（只有叶子节点有直接标注；内部节点通过对其后代求和来获得传播计数）：\n  - $\\text{SCT\\_111}: f = $ $120$\n  - $\\text{SCT\\_112}: f = $ $80$\n  - $\\text{SCT\\_121}: f = $ $50$\n  - $\\text{SCT\\_210}: f = $ $70$\n  - $\\text{SCT\\_220}: f = $ $60$\n  - $\\text{SCT\\_310}: f = $ $90$\n- 叶子标注总数为 $N = $ $120+80+50+70+60+90 = 470$。对于任何内部节点 $c$，将 $f(c)$ 定义为以 $c$ 为根的子树中所有叶子的 $f(\\cdot)$ 之和。经验概率为 $p(c)=f(c)/N$，信息内容为 $\\mathrm{IC}(c)=-\\ln p(c)$。\n\n测试套件：\n为以下每个有序概念对计算向量 $[\\mathrm{shared\\_IC}, \\mathrm{norm\\_sim}, \\mathrm{it\\_dist}, \\mathrm{path\\_sim}]$：\n- 情况 $1$: $(\\text{SCT\\_111}, \\text{SCT\\_112})$\n- 情况 $2$: $(\\text{SCT\\_111}, \\text{SCT\\_111})$\n- 情况 $3$: $(\\text{SCT\\_111}, \\text{SCT\\_310})$\n- 情况 $4$: $(\\text{SCT\\_210}, \\text{SCT\\_220})$\n- 情况 $5$: $(\\text{SCT\\_110}, \\text{SCT\\_112})$\n- 情况 $6$: $(\\text{SCT\\_121}, \\text{SCT\\_220})$\n\n输出规格：\n- 对于每种情况，按顺序输出四个值 $[\\mathrm{shared\\_IC}, \\mathrm{norm\\_sim}, \\mathrm{it\\_dist}, \\mathrm{path\\_sim}]$，每个值四舍五入到 $6$ 位小数。\n- 你的程序应生成单行输出，其中包含所有情况的结果，形式为由逗号分隔的这些 $4$ 元组列表，并用方括号括起来。例如，要求的格式是像 $[[v\\_{11},v\\_{12},v\\_{13},v\\_{14}],[v\\_{21},v\\_{22},v\\_{23},v\\_{24}],\\dots]$ 这样的单行，不带有多余的空格或文本。\n\n所有对数必须是自然对数。不允许外部输入；上述分类法和计数是固定的并嵌入在程序中。不涉及物理单位或角度。不得使用百分比；应按照上述定义将概率作为小数处理。", "solution": "我们从信息论和图论的基本原理出发，推导出可实现的公式。\n\n1. 概率和信息内容。令 $f(c)$ 为概念 $c$ 的传播频率，通过对以 $c$ 为根的子树中所有叶子的叶子标注计数求和计算得出。令 $N$ 为所有叶子的总标注数。那么 $c$ 的经验概率为 $p(c) = f(c)/N$。根据自信息的定义，信息内容为 $\\mathrm{IC}(c) = -\\ln p(c)$。这一原理基于一个经过充分检验的事实：信息对于独立事件是可加的，并且随着概率的增加而减少。\n\n2. 最小公共包含者和深度。在一个带有父子（“is-a”）边的有根分类法（树）中，一个节点的祖先集合包括该节点本身以及其到根节点路径上的所有节点。最小公共包含者 $\\mathrm{LCS}(a,b)$ 是同时存在于两个祖先集合中的最深（最大深度）节点。在树中，此节点是唯一的，因为从每个节点到根节点都有唯一的路径。深度定义为 $\\mathrm{depth}(\\text{root})=0$，并沿每条远离根节点的边增加 $1$。\n\n3. 信息论度量。考虑两个概念 $a$ 和 $b$ 及其 LCS $c^{\\ast} = \\mathrm{LCS}(a,b)$。共享信息是它们最具体共同泛化的自信息，即 $\\mathrm{shared\\_IC}(a,b) = \\mathrm{IC}(c^{\\ast})$，因为 $-\\ln p(c^{\\ast})$ 是 $a$ 和 $b$ 共同意外程度的上限。一种满足对称性、有界于 $[0,1]$、不可区分者同一性（当 $a=b$ 时等于 $1$）并在仅共享根节点时消失的归一化相似度，是通过比较共享信息与总自信息得到的：$\\mathrm{norm\\_sim}(a,b) = \\dfrac{2\\,\\mathrm{IC}(c^{\\ast})}{\\mathrm{IC}(a)+\\mathrm{IC}(b)}$，约定如果分母为 $0$ 且 $a=b$，则值为 $1$，否则为 $0$。该比率的上界为 $1$，因为 $\\mathrm{IC}(c^{\\ast}) \\le \\min\\{\\mathrm{IC}(a),\\mathrm{IC}(b)\\}$。非共享信息由信息论距离 $\\mathrm{it\\_dist}(a,b) = \\mathrm{IC}(a)+\\mathrm{IC}(b)-2\\,\\mathrm{IC}(c^{\\ast}) \\ge 0$ 捕获，这也遵循相同的单调性。\n\n4. 基于图论路径的相似度。在分类法的无向版本中，$a$ 和 $b$ 之间的最短路径长度为 $\\ell(a,b)$。在有根树中，这等于 $\\mathrm{depth}(a)+\\mathrm{depth}(b)-2\\,\\mathrm{depth}(c^{\\ast})$。一个简单的有界相似度则为 $\\mathrm{path\\_sim}(a,b) = \\dfrac{1}{1+\\ell(a,b)} \\in (0,1]$，当 $a=b$ 时等于 $1$，并随着节点的分离而减小。\n\n算法设计：\n- 将分类法构建为父节点映射和子节点邻接表。将没有子节点的节点识别为叶子节点。\n- 通过从根节点开始的广度优先遍历计算深度。\n- 通过自底向上对叶子计数求和来计算传播频率 $f(c)$。此处，叶子计数为：$\\text{SCT\\_111}: f=$ $120$, $\\text{SCT\\_112}: f=$ $80$, $\\text{SCT\\_121}: f=$ $50$, $\\text{SCT\\_210}: f=$ $70$, $\\text{SCT\\_220}: f=$ $60$, $\\text{SCT\\_310}: f=$ $90$。总数为 $N=$ $470$。通过求和得到的内部节点频率为：$f(\\text{SCT\\_110})=$ $200$, $f(\\text{SCT\\_120})=$ $50$, $f(\\text{SCT\\_100})=$ $250$, $f(\\text{SCT\\_200})=$ $130$, $f(\\text{SCT\\_300})=$ $90$, $f(\\text{SCT\\_000})=$ $470$。\n- 使用自然对数计算 $p(c)=f(c)/N$ 和 $\\mathrm{IC}(c)=-\\ln p(c)$。数值上（为清晰起见，四舍五入到 $9$ 位小数）：$\\mathrm{IC}(\\text{SCT\\_111})=$ $1.365241055$, $\\mathrm{IC}(\\text{SCT\\_112})=$ $1.770706163$, $\\mathrm{IC}(\\text{SCT\\_121})=$ $2.240709793$, $\\mathrm{IC}(\\text{SCT\\_210})=$ $1.904237556$, $\\mathrm{IC}(\\text{SCT\\_220})=$ $2.058388236$, $\\mathrm{IC}(\\text{SCT\\_310})=$ $1.652923128$, $\\mathrm{IC}(\\text{SCT\\_110})=$ $0.854415432$, $\\mathrm{IC}(\\text{SCT\\_120})=$ $2.240709793$, $\\mathrm{IC}(\\text{SCT\\_100})=$ $0.631271880$, $\\mathrm{IC}(\\text{SCT\\_200})=$ $1.285198348$, $\\mathrm{IC}(\\text{SCT\\_300})=$ $1.652923128$, $\\mathrm{IC}(\\text{SCT\\_000})=$ $0$。\n- 对于每个测试用例，找到 $\\mathrm{LCS}$，从深度计算 $\\ell(a,b)$，并评估四个度量，四舍五入到 $6$ 位小数。\n\n指定测试套件的计算结果（每个向量格式为 $[\\mathrm{shared\\_IC}, \\mathrm{norm\\_sim}, \\mathrm{it\\_dist}, \\mathrm{path\\_sim}]$，四舍五入到 $6$ 位小数）：\n- 情况 $1$ $(\\text{SCT\\_111}, \\text{SCT\\_112})$: $[0.854415, 0.544917, 1.427116, 0.333333]$\n- 情况 $2$ $(\\text{SCT\\_111}, \\text{SCT\\_111})$: $[1.365241, 1.000000, 0.000000, 1.000000]$\n- 情况 $3$ $(\\text{SCT\\_111}, \\text{SCT\\_310})$: $[0.000000, 0.000000, 3.018164, 0.166667]$\n- 情况 $4$ $(\\text{SCT\\_210}, \\text{SCT\\_220})$: $[1.285198, 0.648660, 1.392229, 0.333333]$\n- 情况 $5$ $(\\text{SCT\\_110}, \\text{SCT\\_112})$: $[0.854415, 0.650953, 0.916291, 0.500000]$\n- 情况 $6$ $(\\text{SCT\\_121}, \\text{SCT\\_220})$: $[0.000000, 0.000000, 4.299098, 0.166667]$\n\n下面的程序根据提供的分类法和计数确定性地实现这些步骤，并以精确要求的格式打印包含所有六个案例结果的单行。", "answer": "```python\n# Python 3.12 program to compute semantic similarity and taxonomy metrics\n# for a fixed SNOMED-like taxonomy and corpus counts.\n# No external input; outputs a single line list-of-lists as specified.\n\nimport math\n\ndef build_taxonomy():\n    # Define nodes\n    nodes = {\n        'SCT_000': 'Clinical finding',\n        'SCT_100': 'Infectious disease',\n        'SCT_110': 'Respiratory infection',\n        'SCT_120': 'Gastrointestinal infection',\n        'SCT_111': 'Influenza',\n        'SCT_112': 'Pneumonia',\n        'SCT_121': 'Viral gastroenteritis',\n        'SCT_200': 'Neoplasm',\n        'SCT_210': 'Lung cancer',\n        'SCT_220': 'Breast cancer',\n        'SCT_300': 'Endocrine disease',\n        'SCT_310': 'Diabetes mellitus',\n    }\n    # Define parent-child edges\n    edges = [\n        ('SCT_000', 'SCT_100'),\n        ('SCT_000', 'SCT_200'),\n        ('SCT_000', 'SCT_300'),\n        ('SCT_100', 'SCT_110'),\n        ('SCT_100', 'SCT_120'),\n        ('SCT_110', 'SCT_111'),\n        ('SCT_110', 'SCT_112'),\n        ('SCT_120', 'SCT_121'),\n        ('SCT_200', 'SCT_210'),\n        ('SCT_200', 'SCT_220'),\n        ('SCT_300', 'SCT_310'),\n    ]\n    children = {n: [] for n in nodes}\n    parent = {}\n    for p, c in edges:\n        children[p].append(c)\n        parent[c] = p\n    root = 'SCT_000'\n    return nodes, children, parent, root\n\ndef compute_depths(children, root):\n    depths = {root: 0}\n    stack = [root]\n    while stack:\n        u = stack.pop()\n        for v in children.get(u, []):\n            depths[v] = depths[u] + 1\n            stack.append(v)\n    return depths\n\ndef compute_subtree_counts(children, leaf_counts, nodes):\n    # Post-order DFS to sum counts\n    # Initialize counts with leaf counts, zero otherwise\n    counts = {n: 0 for n in nodes}\n    for leaf, cnt in leaf_counts.items():\n        counts[leaf] = cnt\n\n    # We can perform multiple passes since it's a tree of small size\n    # or implement recursion\n    visited = set()\n    def dfs_sum(u):\n        if u in visited:\n            return counts[u]\n        total = counts[u]\n        for v in children.get(u, []):\n            total += dfs_sum(v)\n        counts[u] = total\n        visited.add(u)\n        return total\n\n    # Call for all nodes to ensure coverage\n    for n in nodes:\n        dfs_sum(n)\n    return counts\n\ndef ancestors_with_depth(node, parent, depths):\n    # Return list of (ancestor, depth) including node and root\n    res = []\n    u = node\n    while True:\n        d = depths[u]\n        res.append((u, d))\n        if u not in parent:\n            break\n        u = parent[u]\n    return res\n\ndef lcs(a, b, parent, depths):\n    anc_a = {u: d for u, d in ancestors_with_depth(a, parent, depths)}\n    anc_b = {u: d for u, d in ancestors_with_depth(b, parent, depths)}\n    common = set(anc_a.keys())  set(anc_b.keys())\n    # choose the one with maximum depth\n    best = None\n    best_depth = -1\n    for u in common:\n        d = depths[u]\n        if d > best_depth:\n            best_depth = d\n            best = u\n    return best\n\ndef path_length(a, b, depths, lcs_node):\n    return depths[a] + depths[b] - 2 * depths[lcs_node]\n\ndef compute_metrics_for_pair(a, b, ic, depths, parent):\n    c_star = lcs(a, b, parent, depths)\n    shared_ic = ic[c_star]\n    ia = ic[a]\n    ib = ic[b]\n    denom = ia + ib\n    if denom == 0.0:\n        norm_sim = 1.0 if a == b else 0.0\n    else:\n        norm_sim = (2.0 * shared_ic) / denom\n    it_dist = ia + ib - 2.0 * shared_ic\n    pl = path_length(a, b, depths, c_star)\n    path_sim = 1.0 / (1.0 + pl)\n    return shared_ic, norm_sim, it_dist, path_sim\n\ndef solve():\n    nodes, children, parent, root = build_taxonomy()\n    depths = compute_depths(children, root)\n    # Leaf counts\n    leaf_counts = {\n        'SCT_111': 120,\n        'SCT_112': 80,\n        'SCT_121': 50,\n        'SCT_210': 70,\n        'SCT_220': 60,\n        'SCT_310': 90,\n    }\n    counts = compute_subtree_counts(children, leaf_counts, nodes)\n    N = sum(leaf_counts.values())\n    # Compute IC\n    ic = {}\n    for n in nodes:\n        p = counts[n] / N\n        # Numerical safety: ensure p > 0\n        if p == 0.0:\n            ic[n] = float('inf')\n        else:\n            ic[n] = -math.log(p)\n    # Test cases\n    test_cases = [\n        ('SCT_111', 'SCT_112'),\n        ('SCT_111', 'SCT_111'),\n        ('SCT_111', 'SCT_310'),\n        ('SCT_210', 'SCT_220'),\n        ('SCT_110', 'SCT_112'),\n        ('SCT_121', 'SCT_220'),\n    ]\n    results = []\n    for a, b in test_cases:\n        shared_ic, norm_sim, it_dist, path_sim = compute_metrics_for_pair(a, b, ic, depths, parent)\n        # Round to 6 decimals in string format\n        results.append([\n            f\"{shared_ic:.6f}\",\n            f\"{norm_sim:.6f}\",\n            f\"{it_dist:.6f}\",\n            f\"{path_sim:.6f}\",\n        ])\n    # Format as a single-line JSON-like list\n    inner = [f\"[{','.join(r)}]\" for r in results]\n    output = f\"[{','.join(inner)}]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "4548273"}]}