{"hands_on_practices": [{"introduction": "功能富集分析是解读高通量实验数据（如基因表达谱）的核心生物信息学方法。本练习将带您深入其统计核心，从头开始计算基因集在基因本体（GO）术语上的富集程度。您将应用超几何检验来评估富集的显著性，并使用 Benjamini-Hochberg 方法对多重检验进行校正，这是确保结果稳健性的关键步骤。[@problem_id:4543495]", "problem": "一个研究团队正在研究差异表达结果，并试图在一个经过整理的实验特异性基因全集中，使用基因本体论（GO；Gene Ontology Consortium）来评估生物过程富集情况。在该实验中，分析全集包含 $N=20$ 个蛋白质编码基因，查询基因集（显著上调的基因）包含 $M=6$ 个基因。根据先验知识预选了六个GO生物过程术语，其在全集中的注释计数以及与查询集的观测重叠如下：术语 $T_{1}$ 有 $K_{1}=8$ 个注释基因，观测重叠为 $x_{1}=4$；术语 $T_{2}$ 有 $K_{2}=7$ 个，重叠为 $x_{2}=4$；术语 $T_{3}$ 有 $K_{3}=5$ 个，重叠为 $x_{3}=3$；术语 $T_{4}$ 有 $K_{4}=10$ 个，重叠为 $x_{4}=5$；术语 $T_{5}$ 有 $K_{5}=4$ 个，重叠为 $x_{5}=2$；术语 $T_{6}$ 有 $K_{6}=9$ 个，重叠为 $x_{6}=1$。\n\n从用于注释富集的无放回抽样的组合模型出发，并根据错误发现率（FDR）由Benjamini–Hochberg（BH）程序（Benjamini and Hochberg）控制的原理，推导出每个GO术语的单侧富集$p$值。该$p$值是在原假设（即$M$个基因是从包含$N$个基因的全集中均匀随机抽取的）下，观测到至少与报告重叠数量相同的概率。然后，对这$m=6$个检验应用BH程序以获得$q$值，并确定在$q \\le 0.05$的水平下哪些术语是显著的。\n\n将$q \\le 0.05$水平下显著的GO术语总数作为最终答案。请用一个实数表示最终答案。此计数无需四舍五入。", "solution": "基因本体论（GO）术语的过表达检验（over-representation testing）的适当零模型是从有限全集中进行无放回抽样。在原假设下，从包含$N$个基因的全集中抽取$M$个基因，其中有$K$个基因注释到某个给定术语，这一过程由超几何分布描述。在$M$次抽取中观测到的注释基因数$X$的概率质量函数为\n$$\n\\Pr(X=t) \\;=\\; \\frac{\\binom{K}{t}\\,\\binom{N-K}{M-t}}{\\binom{N}{M}},\n$$\n其中$t$为整数，满足$0 \\le t \\le \\min\\{M,K\\}$且$M-t \\le N-K$。单侧富集检验考虑右尾，\n$$\np\\text{-value} \\;=\\; \\Pr(X \\ge x) \\;=\\; \\sum_{t=x}^{\\min\\{M,K\\}} \\frac{\\binom{K}{t}\\,\\binom{N-K}{M-t}}{\\binom{N}{M}},\n$$\n其中$x$是观测到的重叠数。\n\n我们已知$N=20$和$M=6$，因此所有术语的分母为\n$$\n\\binom{N}{M} \\;=\\; \\binom{20}{6} \\;=\\; 38760.\n$$\n现在我们计算每个术语的尾部概率。\n\n术语 $T_{1}$，$K_{1}=8$，$x_{1}=4$，需要计算 $t=4,5,6$ 的情况：\n\\begin{align*}\n\\Pr(X \\ge 4) = \\frac{\\binom{8}{4}\\binom{12}{2} + \\binom{8}{5}\\binom{12}{1} + \\binom{8}{6}\\binom{12}{0}}{\\binom{20}{6}} \\\\\n= \\frac{70 \\cdot 66 + 56 \\cdot 12 + 28 \\cdot 1}{38760} \\\\\n= \\frac{4620 + 672 + 28}{38760} \\\\\n= \\frac{5320}{38760} \\;=\\; \\frac{133}{969} \\approx 0.1372.\n\\end{align*}\n\n术语 $T_{2}$，$K_{2}=7$，$x_{2}=4$，需要计算 $t=4,5,6$ 的情况：\n\\begin{align*}\n\\Pr(X \\ge 4) = \\frac{\\binom{7}{4}\\binom{13}{2} + \\binom{7}{5}\\binom{13}{1} + \\binom{7}{6}\\binom{13}{0}}{\\binom{20}{6}} \\\\\n= \\frac{35 \\cdot 78 + 21 \\cdot 13 + 7 \\cdot 1}{38760} \\\\\n= \\frac{2730 + 273 + 7}{38760} \\\\\n= \\frac{3010}{38760} \\;=\\; \\frac{301}{3876} \\approx 0.0776.\n\\end{align*}\n\n术语 $T_{3}$，$K_{3}=5$，$x_{3}=3$，需要计算 $t=3,4,5$ 的情况：\n\\begin{align*}\n\\Pr(X \\ge 3) = \\frac{\\binom{5}{3}\\binom{15}{3} + \\binom{5}{4}\\binom{15}{2} + \\binom{5}{5}\\binom{15}{1}}{\\binom{20}{6}} \\\\\n= \\frac{10 \\cdot 455 + 5 \\cdot 105 + 1 \\cdot 15}{38760} \\\\\n= \\frac{4550 + 525 + 15}{38760} \\\\\n= \\frac{5090}{38760} \\;=\\; \\frac{509}{3876} \\approx 0.1313.\n\\end{align*}\n\n术语 $T_{4}$，$K_{4}=10$，$x_{4}=5$，需要计算 $t=5,6$ 的情况：\n\\begin{align*}\n\\Pr(X \\ge 5) = \\frac{\\binom{10}{5}\\binom{10}{1} + \\binom{10}{6}\\binom{10}{0}}{\\binom{20}{6}} \\\\\n= \\frac{252 \\cdot 10 + 210 \\cdot 1}{38760} \\\\\n= \\frac{2520 + 210}{38760} \\\\\n= \\frac{2730}{38760} \\;=\\; \\frac{91}{1292} \\approx 0.0704.\n\\end{align*}\n\n术语 $T_{5}$，$K_{5}=4$，$x_{5}=2$，需要计算 $t=2,3,4$ 的情况：\n\\begin{align*}\n\\Pr(X \\ge 2) = \\frac{\\binom{4}{2}\\binom{16}{4} + \\binom{4}{3}\\binom{16}{3} + \\binom{4}{4}\\binom{16}{2}}{\\binom{20}{6}} \\\\\n= \\frac{6 \\cdot 1820 + 4 \\cdot 560 + 1 \\cdot 120}{38760} \\\\\n= \\frac{10920 + 2240 + 120}{38760} \\\\\n= \\frac{13280}{38760} \\;=\\; \\frac{332}{969} \\approx 0.3426.\n\\end{align*}\n\n术语 $T_{6}$，$K_{6}=9$，$x_{6}=1$，其概率可以用更简单的补集形式计算 $\\Pr(X \\ge 1) = 1 - \\Pr(X=0)$：\n\\begin{align*}\n\\Pr(X \\ge 1) = 1 - \\frac{\\binom{9}{0}\\binom{11}{6}}{\\binom{20}{6}} \\\\\n= 1 - \\frac{462}{38760} \\\\\n= 1 - \\frac{77}{6460} \\approx 1 - 0.0119 \\approx 0.9881.\n\\end{align*}\n\n收集六个$p$值（为便于排序显示其近似值）：\n$$\np_{1} \\approx 0.1372,\\quad p_{2} \\approx 0.0776,\\quad p_{3} \\approx 0.1313,\\quad p_{4} \\approx 0.0704,\\quad p_{5} \\approx 0.3426,\\quad p_{6} \\approx 0.9881.\n$$\n\n对$m=6$个假设应用Benjamini–Hochberg（BH）程序。首先将$p$值按升序排列，并将其索引为$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(6)}$：\n$$\np_{(1)} = p_{4} \\approx 0.0704,\\quad\np_{(2)} = p_{2} \\approx 0.0776,\\quad\np_{(3)} = p_{3} \\approx 0.1313,\\quad\np_{(4)} = p_{1} \\approx 0.1372,\\quad\np_{(5)} = p_{5} \\approx 0.3426,\\quad\np_{(6)} = p_{6} \\approx 0.9881.\n$$\n$q$值的计算方法为：将排序后的p值$p_{(i)}$乘以$m/i$，然后从后向前取累积最小值，即 $q_{(i)} = \\min\\left( \\frac{m}{i} p_{(i)}, q_{(i+1)} \\right)$，且 $q_{(m)} = p_{(m)}$。\n\\begin{align*}\nq_{(6)} &\\approx p_{(6)} = 0.9881 \\\\\nq_{(5)} &\\approx \\min\\left(q_{(6)}, \\frac{6}{5}p_{(5)}\\right) = \\min(0.9881, \\frac{6}{5} \\cdot 0.3426) = \\min(0.9881, 0.4111) = 0.4111 \\\\\nq_{(4)} &\\approx \\min\\left(q_{(5)}, \\frac{6}{4}p_{(4)}\\right) = \\min(0.4111, \\frac{6}{4} \\cdot 0.1372) = \\min(0.4111, 0.2058) = 0.2058 \\\\\nq_{(3)} &\\approx \\min\\left(q_{(4)}, \\frac{6}{3}p_{(3)}\\right) = \\min(0.2058, \\frac{6}{3} \\cdot 0.1313) = \\min(0.2058, 0.2626) = 0.2058 \\\\\nq_{(2)} &\\approx \\min\\left(q_{(3)}, \\frac{6}{2}p_{(2)}\\right) = \\min(0.2058, \\frac{6}{2} \\cdot 0.0776) = \\min(0.2058, 0.2328) = 0.2058 \\\\\nq_{(1)} &\\approx \\min\\left(q_{(2)}, \\frac{6}{1}p_{(1)}\\right) = \\min(0.2058, \\frac{6}{1} \\cdot 0.0704) = \\min(0.2058, 0.4224) = 0.2058\n\\end{align*}\n因此，所有的BH $q$值都大于$0.05$。所以在$q \\le 0.05$的水平下，显著的GO术语数量为$0$。", "answer": "$$\\boxed{0}$$", "id": "4543495"}, {"introduction": "生物医学数据越来越多地以语义网技术（如资源描述框架 RDF）进行组织，这使得复杂的查询和数据集成成为可能。本练习将让您掌握使用 SPARQL（RDF 查询语言）从本体注释数据库中精确检索信息的实用技能。通过构建一个查询来筛选具有特定证据和本体论属性的注释，您将学习如何将生物学问题转化为可在现代知识库上执行的形式化逻辑。[@problem_id:4543585]", "problem": "给定一个简化的、内存中的资源描述框架 (RDF) 数据表示，要求您构建并评估一个RDF结构化查询语言 (SPARQL) 查询，以检索满足特定生物学和本体论约束的基因本体 (GO) 注释。目标是使用RDF图上合取查询评估的语义来形式化该查询，并计算几个测试数据集中每个数据集中匹配的唯一注释的数量。\n\n使用的基础和定义：\n- 资源描述框架 (RDF)：一个RDF图是一个三元组的集合，每个三元组是一个由主语、谓语和宾语组成的有序元组。用集合 $G \\subseteq U \\times U \\times (U \\cup L \\cup B)$ 表示一个图，其中 $U$ 是统一资源标识符 (URI) 的集合，$L$ 是字面量 (literal) 的集合，$B$ 是空白节点的集合。\n- SPARQL基本图模式：一个基本图模式是一个带有变量的三元组模式的有限集合。一个解决方案映射是一个偏函数 $\\mu: V \\to (U \\cup L \\cup B)$，其中 $V$ 是变量的集合。一个三元组模式 $(s,p,o)$ 在映射 $\\mu$ 下匹配一个三元组 $(s',p',o')$，如果对于每个分量，它要么是与三元组中常量相等的常量，要么是一个变量 $v \\in V$ 且 $\\mu(v)$ 等于三元组的相应分量；变量在匹配前可以是未绑定的，并在评估过程中被绑定。一个基本图模式的评估结果是合取地满足所有三元组模式的映射集合。过滤器对映射应用布尔谓词。投影选择指定的变量，DISTINCT对投影后的元组产生集合语义。\n- 基因本体 (GO)：GO术语分为三个方面：分子功能、生物学过程和细胞组分。本任务专注于按分子功能方面筛选注释。\n- 证据代码：在GO中，代码“EXP”表示“从实验推断”。在数据模型中将“EXP”视为一个特定的常量。\n\n您的任务：\n- 构建一个SPARQL查询，检索所有证据代码为“EXP”且相关GO术语属于分子功能命名空间的唯一注释节点。使用以下简化词汇（领域特定术语隐含前缀“ex:”）：\n  - ex:Annotation (注释节点的类)\n  - rdf:type (类型谓词)\n  - ex:hasEvidence (注释到证据代码)\n  - ex:EXP (“从实验推断”的证据代码)\n  - ex:hasGO (注释到GO术语)\n  - ex:hasAspect (GO术语到方面)\n  - ex:MolecularFunction, ex:BiologicalProcess, ex:CellularComponent (GO方面)\n- 您必须通过将每个三元组模式和每个过滤器映射到基于上述定义的必要生物学或语义约束来证明其合理性。\n- 实现一个程序，在多个测试图上根据基本图模式作为同态的形式语义来评估您的查询。对于此问题，您必须将对注释变量使用的 `FILTER isIRI` 视为排除空白节点注释的必要过滤器，从而确保可报告的标识符。对注释变量使用投影和 `DISTINCT` 以避免重复报告相同的注释。\n\n形式化评估要求：\n- 设$G$为一个RDF图，设$P$为查询中的三元组模式集合。评估必须通过从空映射开始，并与每个三元组模式的匹配进行迭代连接来构建解决方案映射集。应用 `FILTER` 条件 $isIRI(?ann)$ 来排除绑定到 $?ann$ 的值不是URI的映射。投影变量 $?ann$ 并应用 `DISTINCT` 以形成一个唯一的注释标识符集合。对于一个图$G$，最终结果是该集合的基数，它是一个非负整数。\n\n测试数据模型：\n- 每个RDF三元组表示为包含三个字符串的元组。URI是诸如“ex:annA”或“rdf:type”之类的字符串。空白节点是以“_:”开头的字符串。字面量是包含在双引号中的字符串（在此测试套件中未使用）。下面的图是根据这些三元组表示的。\n\n测试套件：\n- 有$4$个测试图。对于每个图，计算您的查询评估返回的唯一注释URI的数量，结果为一个整数。\n\n测试图$G_1$（包含合格与不合格注释的混合的一般情况）：\n- (\"ex:annA\",\"rdf:type\",\"ex:Annotation\")\n- (\"ex:annA\",\"ex:hasEvidence\",\"ex:EXP\")\n- (\"ex:annA\",\"ex:hasGO\",\"ex:GO_MF\")\n- (\"ex:GO_MF\",\"ex:hasAspect\",\"ex:MolecularFunction\")\n- (\"ex:annB\",\"rdf:type\",\"ex:Annotation\")\n- (\"ex:annB\",\"ex:hasEvidence\",\"ex:IDA\")\n- (\"ex:annB\",\"ex:hasGO\",\"ex:GO_MF\")\n- (\"ex:annC\",\"rdf:type\",\"ex:Annotation\")\n- (\"ex:annC\",\"ex:hasEvidence\",\"ex:EXP\")\n- (\"ex:annC\",\"ex:hasGO\",\"ex:GO_BP\")\n- (\"ex:GO_BP\",\"ex:hasAspect\",\"ex:BiologicalProcess\")\n- (\"ex:annD\",\"rdf:type\",\"ex:Annotation\")\n- (\"ex:annD\",\"ex:hasEvidence\",\"ex:EXP\")\n- (\"ex:annD\",\"ex:hasGO\",\"ex:GO_MF2\")\n- (\"ex:GO_MF2\",\"ex:hasAspect\",\"ex:MolecularFunction\")\n\n测试图$G_2$（零匹配的边界情况）：\n- (\"ex:annE\",\"rdf:type\",\"ex:Annotation\")\n- (\"ex:annE\",\"ex:hasEvidence\",\"ex:IDA\")\n- (\"ex:annE\",\"ex:hasGO\",\"ex:GO_MF\")\n- (\"ex:GO_MF\",\"ex:hasAspect\",\"ex:MolecularFunction\")\n- (\"ex:annF\",\"rdf:type\",\"ex:Annotation\")\n- (\"ex:annF\",\"ex:hasEvidence\",\"ex:EXP\")\n\n测试图$G_3$（包含空白节点注释和具有多个方面的GO术语的边缘情况）：\n- (\"ex:annG\",\"rdf:type\",\"ex:Annotation\")\n- (\"ex:annG\",\"ex:hasEvidence\",\"ex:EXP\")\n- (\"ex:annG\",\"ex:hasGO\",\"ex:GO_MFCC\")\n- (\"_:b1\",\"rdf:type\",\"ex:Annotation\")\n- (\"_:b1\",\"ex:hasEvidence\",\"ex:EXP\")\n- (\"_:b1\",\"ex:hasGO\",\"ex:GO_MFCC\")\n- (\"ex:GO_MFCC\",\"ex:hasAspect\",\"ex:MolecularFunction\")\n- (\"ex:GO_MFCC\",\"ex:hasAspect\",\"ex:CellularComponent\")\n\n测试图$G_4$（包含多个证据陈述和混合方面的边缘情况）：\n- (\"ex:annH\",\"rdf:type\",\"ex:Annotation\")\n- (\"ex:annH\",\"ex:hasEvidence\",\"ex:EXP\")\n- (\"ex:annH\",\"ex:hasEvidence\",\"ex:IPI\")\n- (\"ex:annH\",\"ex:hasGO\",\"ex:GO_POISED\")\n- (\"ex:GO_POISED\",\"ex:hasAspect\",\"ex:MolecularFunction\")\n- (\"ex:annI\",\"rdf:type\",\"ex:Annotation\")\n- (\"ex:annI\",\"ex:hasEvidence\",\"ex:EXP\")\n- (\"ex:annI\",\"ex:hasGO\",\"ex:GO_BPONLY\")\n- (\"ex:GO_BPONLY\",\"ex:hasAspect\",\"ex:BiologicalProcess\")\n\n编程任务和输出规范：\n- 实现一个完整的程序，该程序：\n  - 构建SPARQL查询字符串，包含适当的 `PREFIX` 声明、对注释变量的 `SELECT DISTINCT` 子句、必要的三元组模式以及确保 $isIRI(?ann)$ 的 `FILTER`。\n  - 如上所述实现一个基本图模式评估器，以针对每个 $G_i$ 评估查询。\n  - 对于每个 $G_i$，计算满足查询的唯一注释URI的数量，结果为一个整数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为 $[|Q(G_1)|,|Q(G_2)|,|Q(G_3)|,|Q(G_4)|]$，其中 $|Q(G_i)|$ 表示图 $G_i$ 的唯一投影解的基数。", "solution": "我们将从资源描述框架 (RDF) 图和RDF结构化查询语言 (SPARQL) 评估的基本原理开始。一个RDF图是一个三元组的集合 $G \\subseteq U \\times U \\times (U \\cup L \\cup B)$，其中 $U$ 是统一资源标识符 (URI) 的集合，$L$ 是字面量 (literal) 的集合，$B$ 是空白节点的集合。一个SPARQL基本图模式是一个三元组模式的有限集合 $P = \\{t_1,\\dots,t_k\\}$，每个 $t_j$ 是一个在 $(U \\cup V) \\times (U \\cup V) \\times (U \\cup L \\cup B \\cup V)$ 上的三元组，其中 $V$ 是变量集合，使得 $V \\cap (U \\cup L \\cup B) = \\emptyset$。一个解决方案映射是一个偏函数 $\\mu: V \\to (U \\cup L \\cup B)$。\n\n一个三元组模式 $t=(s,p,o)$ 在一个映射 $\\mu$ 下匹配一个三元组 $(s',p',o') \\in G$，如果对于每个位置，我们或者有一个常量相等（如果分量在 $U \\cup L \\cup B$ 中），或者有一个变量 $v \\in V$ 使得 $v \\notin \\mathrm{dom}(\\mu)$ 并且我们通过 $\\{v \\mapsto s'\\}$（或酌情使用 $p'$ 或 $o'$）来扩展 $\\mu$，或者 $v \\in \\mathrm{dom}(\\mu)$ 且 $\\mu(v)$ 等于三元组的相应分量。一个基本图模式 $P$ 在 $G$ 上的评估产生集合\n$$\n\\llbracket P \\rrbracket_G = \\{\\mu \\mid \\mu \\text{ is a mapping that makes all } t \\in P \\text{ simultaneously match some triples in } G\\}.\n$$\n一个过滤器条件是一个关于变量的布尔谓词 $\\phi$；应用 `FILTER` 只保留那些使 $\\phi(\\mu)$ 评估为真的 $\\mu \\in \\llbracket P \\rrbracket_G$。对变量 $W \\subseteq V$ 的投影产生元组 $\\mu|_W$ 的多重集或集合（使用 `DISTINCT`）。我们将使用 `DISTINCT` 来确保投影解的集合语义。使用的特定过滤器是 $isIRI(?ann)$，它强制要求 $\\mu(?ann) \\in U$ 并排除 $\\mu(?ann) \\in B$ 或 $\\mu(?ann) \\in L$。\n\n将生物学问题映射到三元组模式：\n- 我们要求结果是一个注释节点。这通过模式 $t_1 = (?ann, rdf{:}type, ex{:}Annotation)$ 来强制执行，该模式确保绑定到变量 $?ann$ 的主语类型为 ex:Annotation。\n- 我们要求注释具有实验证据代码“EXP”。这通过模式 $t_2 = (?ann, ex{:}hasEvidence, ex{:}EXP)$ 来强制执行，使用常量宾语 ex:EXP 来匹配“从实验推断”的证据代码。\n- 我们要求注释引用一个基因本体 (GO) 术语。这通过模式 $t_3 = (?ann, ex{:}hasGO, ?go)$ 来强制执行，该模式将变量 $?go$ 绑定到被引用的GO术语。\n- 我们要求GO术语属于分子功能命名空间（方面）。这通过模式 $t_4 = (?go, ex{:}hasAspect, ex{:}MolecularFunction)$ 来强制执行。\n- 我们必须确保报告的标识符是国际化资源标识符 (IRI)，而不是空白节点，以保证下游的互操作性。这通过过滤器 $\\mathrm{isIRI}(?ann)$ 来强制执行，它是一个只接受满足 $\\mu(?ann) \\in U$ 的 $\\mu$ 的谓词。\n- 如果多个支持性三元组可能产生相同的 $?ann$ 绑定（例如，如果一个GO术语有多个方面，或者注释有多个不改变 $?ann$ 的陈述），我们必须避免重复。因此，我们对 $?ann$ 使用 `SELECT DISTINCT`，以便投影产生一个唯一的注释标识符集合。\n\n将这些元素组合在一起，得到SPARQL查询结构：\n- `ex:` 和 `rdf:` 的 `PREFIX` 声明。\n- `SELECT DISTINCT ?ann`\n- `WHERE` 子句包含 $t_1, t_2, t_3, t_4$ 的合取以及 `FILTER isIRI(?ann)`。\n\n算法评估设计：\n- 设 $P = [t_1, t_2, t_3, t_4]$ 为三元组模式的有序列表。我们通过迭代连接来评估基本图模式：\n  1. 初始化偏映射集合 $M_0 = \\{\\emptyset\\}$。\n  2. 对于 $j = 1$ 到 $4$，计算\n     $$\n     M_j = \\{\\mu' \\mid \\mu \\in M_{j-1},\\ \\exists (s',p',o') \\in G: \\text{$t_j$ matches $(s',p',o')$ under $\\mu$ and $\\mu'$ is $\\mu$ extended consistently}\\}.\n     $$\n  3. 应用过滤器：$M_f = \\{\\mu \\in M_4 \\mid \\mathrm{isIRI}(\\mu(?ann))\\}$。\n  4. 在 $?ann$ 上投影并应用 `DISTINCT` 得到 $S = \\{\\mu(?ann) \\mid \\mu \\in M_f\\}$。\n  5. 结果是整数 $\\lvert S \\rvert$。\n- 函数 $\\mathrm{isIRI}(x)$ 的实现是：当且仅当 $x$ 是一个表示URI的字符串时为真，在我们的表示法中，这意味着它不以空白节点前缀“_:”开头，也不是带引号的字面量。\n\n正确性论证：\n- 根据RDF类型化，$t_1$ 将候选者限制为注释资源，这对于避免将其他节点（如GO术语或通用资源）与注释相混淆是必要的。\n- 根据证据建模，`ex:hasEvidence` 与宾语 `ex:EXP` 精确地挑选出由实验证据支持的注释，这与预期的证据与结论本体 (ECO) 代码“EXP”一致。\n- 根据GO注释的结构，一个注释必须引用一个GO术语；$t_3$ 将此术语绑定到 $?go$。\n- 根据GO方面的定义，`ex:hasAspect` 确保只接受分子功能方面的GO术语；$t_4$ 强制执行生物学命名空间约束。\n- 过滤器 $\\mathrm{isIRI}(?ann)$ 强制要求结果在 $U$ 中，排除了无法解引用或全局引用的空白节点。\n- 对 $?ann$ 使用 `DISTINCT` 确保最终集合 $S$ 中每个注释最多只包含一次，即使多个支持性三元组在其他情况下会产生具有相同 $?ann$ 绑定的多个解决方案映射；因此，输出反映了唯一注释的数量。\n\n应用于测试套件：\n- 对于 $G_1$，注释 ex:annA 和 ex:annD 满足所有模式和过滤器；ex:annB 未通过 $t_2$（证据不是 ex:EXP），ex:annC 未通过 $t_4$（方面是BiologicalProcess）。因此 $\\lvert S \\rvert = 2$。\n- 对于 $G_2$，ex:annE 未通过 $t_2$（证据不是 ex:EXP），ex:annF 未通过 $t_3$（没有GO术语被绑定），因此没有映射满足所有模式；因此 $\\lvert S \\rvert = 0$。\n- 对于 $G_3$，ex:annG 和空白节点 \"_:b1\" 都满足基本图模式，但过滤器 $\\mathrm{isIRI}(?ann)$ 排除了空白节点，只剩下 ex:annG；因此 $\\lvert S \\rvert = 1$。\n- 对于 $G_4$，ex:annH 满足所有模式和过滤器（多个证据陈述中包含 ex:EXP，且GO术语的方面是MolecularFunction），而 ex:annI 未通过 $t_4$（方面是BiologicalProcess）。因此 $\\lvert S \\rvert = 1$。\n\n因此，按顺序 $[|Q(G_1)|,|Q(G_2)|,|Q(G_3)|,|Q(G_4)|]$ 计算出的结果是 $[2, 0, 1, 1]$。\n\n要实现的程序会构建SPARQL查询字符串，在每个 $G_i$ 上使用过滤器和 `DISTINCT` 投影来评估基本图模式，并打印包含四个整数的单行输出，格式为用方括号括起来的逗号分隔列表。", "answer": "[2, 0, 1, 1]", "id": "4543585"}, {"introduction": "富集分析的原始输出通常是一个冗长且高度冗余的基因本体（GO）术语列表，这给生物学解释带来了挑战。本高级练习介绍了一种通过语义相似性聚类来消除冗余并提炼核心生物学主题的计算方法。您将学习如何利用信息论和本体结构来量化术语间的关系，并将富集结果从一个简单的列表转化为一个更具解释性的、结构化的视图。[@problem_id:4543494]", "problem": "您将获得一个以有向无环图 (DAG) 表示的简化基因本体论 (GO) 片段、一个包含每个 GO 术语的直接注释计数的语料库，以及一组富集术语集。目标是构建一个有原则的算法，通过根据语义相似性对富集术语进行聚类，并为每个聚类选择一个代表性术语，从而消除富集术语间的冗余。该方法必须基于本体论注释和信息论的核心定义，其结果必须是完全指定的、确定性的和可测试的。\n\n使用的基本定义如下：\n- 基因本体論 (GO) 是一个有向无环图 (DAG)，表示为 $G=(V,E)$，其中顶点 $V$ 是术语标识符，边 $E$ 表示父子关系。一条有向边 $(u,v)\\in E$ 表示 $u$ 是 $v$ 的子节点（即 $v$ 是 $u$ 的父节点）。\n- 对于任何术语 $t\\in V$，令 $\\mathcal{A}(t)$ 表示包含 $t$ 本身的祖先集合，令 $\\mathcal{D}(t)$ 表示不包含 $t$ 的后代集合。\n- 令 $c(t)$ 表示术语 $t$ 的直接注释数，$c^\\downarrow(t)=c(t)+\\sum_{x\\in \\mathcal{D}(t)} c(x)$ 为 $t$ 的后代聚合计数。令 $N=\\sum_{v\\in V} c(v)$ 为语料库中直接注释的总数。定义概率 $p(t)=\\frac{c^\\downarrow(t)}{N}$ 和信息含量 (IC) $IC(t)=-\\ln p(t)$。\n- 术语 $a$ 和 $b$ 的信息量最丰富的共同祖先 (Most Informative Common Ancestor, MICA) 是 $\\operatorname{MICA}(a,b)=\\arg\\max_{x\\in \\mathcal{A}(a)\\cap \\mathcal{A}(b)} IC(x)$，若存在平局，则选择术语标识符最小者。\n- 定义 $a$ 和 $b$ 之间的 Jiang–Conrath (JC) 语义距离为 $d_{\\mathrm{JC}}(a,b)=IC(a)+IC(b)-2\\,IC\\!\\left(\\operatorname{MICA}(a,b)\\right)$。\n- 对于聚类，给定术语的两个聚类 $A$ 和 $B$，定义完全链接为 $L_{\\mathrm{complete}}(A,B)=\\max_{a\\in A,\\,b\\in B} d_{\\mathrm{JC}}(a,b)$，定义平均链接为 $L_{\\mathrm{average}}(A,B)=\\frac{1}{|A|\\,|B|}\\sum_{a\\in A,\\,b\\in B} d_{\\mathrm{JC}}(a,b)$。\n- 给定一个富集术语集 $E\\subseteq V$，定义成对距离的多重集 $D=\\{d_{\\mathrm{JC}}(a,b)\\,|\\,a,b\\in E,\\,a", "solution": "该解决方案将遵循问题陈述中指定的确定性算法，分为两个主要阶段：预计算和案例处理。\n\n**1. 预计算阶段**\n此阶段只需执行一次，为所有后续计算准备基础数据。\n*   **图结构分析**: 首先，解析GO片段的图结构 $G=(V,E)$。对于每个术语，计算其祖先集合 $\\mathcal{A}(t)$（包含自身）和后代集合 $\\mathcal{D}(t)$（不包含自身）。\n*   **信息含量 (IC) 计算**:\n    1.  计算直接注释总数 $N = \\sum c(t) = 1715$。\n    2.  对于每个术语 $t$，通过累加其自身及其所有后代的直接注释数来计算后代聚合计数 $c^\\downarrow(t)$。例如，$c^\\downarrow(1) = c(1)+c(3)+c(4)+c(7)+c(8)+c(10)+c(11) = 400+200+180+80+60+30+25 = 975$。\n    3.  计算每个术语的概率 $p(t) = c^\\downarrow(t) / N$。\n    4.  最后，计算每个术语的信息含量 $IC(t) = -\\ln p(t)$。例如，$IC(1) = -\\ln(975/1715) \\approx 0.5647$。根术语 $IC(0)=0$，$IC$ 值随着术语的特异性增加而增加。\n\n**2. 案例处理阶段**\n对于每个测试案例，执行以下步骤：\n*   **步骤1：计算成对距离**: 对于富集集 $E$ 中的每一对术语 $(a, b)$，使用预先计算的 $IC$ 值和 $\\mathcal{A}(t)$ 集合来计算 Jiang-Conrath (JC) 距离 $d_{\\mathrm{JC}}(a,b)$。这需要先找到它们的信息量最丰富的共同祖先 (MICA)。\n*   **步骤2：确定聚类阈值 $c$**:\n    1.  收集所有成对距离 $D = \\{d_{\\mathrm{JC}}(a,b) \\mid a, b \\in E, a  b\\}$。\n    2.  计算 $D$ 的中位数 $\\tilde{m}$ 和中位数绝对偏差 (MAD)。\n    3.  根据公式 $c = \\max(0, \\tilde{m} - k \\cdot \\text{MAD})$ 计算聚类截止阈值。\n*   **步骤3：凝聚聚类**:\n    1.  开始时，每个富集术语自成一个聚类。\n    2.  迭代地合并距离最近的两个聚类。聚类间的距离根据指定的链接方法（`complete` 或 `average`）计算。\n    3.  当所有聚类间的最小距离都大于阈值 $c$ 时，停止合并。\n*   **步骤4：选择代表术语**: 对于最终形成的每个聚类，选择其中 $IC$ 值最高的术语作为该聚类的代表。如果存在平局，则选择术语 ID 最小的那个。\n*   **步骤5：格式化输出**: 将所有代表术语的 ID 按升序排序，形成最终的列表。\n\n**案例执行示例：案例1**\n*   $E = \\{3, 4, 7, 8, 10\\}$，链接方法 = `complete`，$k=1.0$。\n*   **距离计算**: 计算 10 个成对 JC 距离。例如，$d_{\\mathrm{JC}}(3,4) = IC(3)+IC(4)-2 \\cdot IC(\\text{MICA}(3,4)=1) \\approx 1.709+1.868-2 \\cdot 0.565 \\approx 2.448$。\n*   **阈值计算**: 距离集合 $D$ 的中位数 $\\tilde{m} \\approx 2.448$，MAD $\\approx 0.762$。因此，阈值 $c = \\max(0, 2.448 - 1.0 \\cdot 0.762) \\approx 1.686$。\n*   **聚类**:\n    1.  初始聚类：$\\{3\\}, \\{4\\}, \\{7\\}, \\{8\\}, \\{10\\}$。\n    2.  距离最小的对是 $(7, 10)$，其 $d_{\\mathrm{JC}} \\approx 0.701  c$。合并为 $\\{7, 10\\}$。当前聚类：$\\{3\\}, \\{4\\}, \\{8\\}, \\{7, 10\\}$。\n    3.  接下来，$(3, 7)$ 的距离最小，但现在需要计算 $\\{3\\}$ 和 $\\{7,10\\}$ 的 `complete` 链接距离，即 $\\max(d_{\\mathrm{JC}}(3,7), d_{\\mathrm{JC}}(3,10)) \\approx \\max(1.709, 2.703) = 2.703 > c$。\n    4.  继续检查其他对，发现 $(4, 8)$ 的距离 $d_{\\mathrm{JC}}(4,8) \\approx 0.968  c$。合并为 $\\{4, 8\\}$。当前聚类：$\\{3\\}, \\{7, 10\\}, \\{4, 8\\}$。\n    5.  此时，所有聚类间的 `complete` 链接距离都大于阈值 $c$。例如，$L_{\\text{complete}}(\\{3\\}, \\{4, 8\\}) = \\max(d_{\\mathrm{JC}}(3,4), d_{\\mathrm{JC}}(3,8)) > c$。聚类过程终止。\n*   **代表选择**:\n    *   聚类 $\\{3\\}$：代表是 $3$。\n    *   聚类 $\\{4, 8\\}$：$IC(8) > IC(4)$，代表是 $8$。\n    *   聚类 $\\{7, 10\\}$：$IC(10) > IC(7)$，代表是 $10$。\n*   **结果**: 代表集是 $\\{3, 8, 10\\}$。\n\n通过对所有三个案例应用此确定性流程，我们得到以下结果：\n1.  案例1 ($E=\\{3,4,7,8,10\\}$): 代表术语为 $\\{3, 8, 10\\}$。\n2.  案例2 ($E=\\{5,6,7,9,11\\}$): 代表术语为 $\\{7, 11\\}$。\n3.  案例3 ($E=\\{1,2,10,11\\}$): 代表术语为 $\\{10, 11\\}$。\n\n将这些结果列表组合并按问题要求格式化，得到最终答案。", "answer": "[[3, 8, 10], [7, 11], [10, 11]]", "id": "4543494"}]}