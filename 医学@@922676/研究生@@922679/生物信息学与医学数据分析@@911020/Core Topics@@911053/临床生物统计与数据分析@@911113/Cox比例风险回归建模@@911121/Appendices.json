{"hands_on_practices": [{"introduction": "在Cox比例风险模型中，估计回归系数 $\\beta$ 仅仅是分析的第一步。为了在临床上做出可靠的推断，量化此估计值的不确定性至关重要。本练习将引导您实践一项基本技能：为风险比（Hazard Ratio, HR）构建置信区间，这是Cox模型中最常用的效应量度。您将学习为何在对数风险尺度上使用Wald方法构建区间，然后通过指数变换得到最终结果，这是解释模型输出的核心步骤。[@problem_id:4551012]", "problem": "一项转化肿瘤学研究使用Cox比例风险模型（CPHM）分析转移性结直肠癌患者的总生存期。令协变量 $X$ 表示与上皮-间质转化相关基因的标准化信使核糖核酸（mRNA）表达分数，该分数在队列中经过缩放，均值为 $0$，方差为 $1$。在CPHM下，具有协变量值 $x$ 的患者的风险建模为 $h(t \\mid x) = h_{0}(t)\\,\\exp(x\\,\\beta_{1})$，其中 $h_{0}(t)$ 是基线风险，$\\beta_{1}$ 是 $X$ 的回归系数。最大偏似然估计量（MPLE）$\\hat{\\beta}_{1}$ 用于推断，在偏似然的标准正则性条件下，它渐近服从正态分布，其均值为 $\\beta_{1}$，方差由观测到的Fisher信息的逆给出。\n\n假设从拟合模型中得到的估计系数及其估计方差分别为 $\\hat{\\beta}_{1} = 0.37$ 和 $\\widehat{\\mathrm{Var}}(\\hat{\\beta}_{1}) = 0.0484$。利用 $\\hat{\\beta}_{1}$ 的渐近正态性以及 $X$ 每增加一个单位的风险比为 $\\exp(\\beta_{1})$ 这一事实，通过在对数尺度上进行计算然后进行适当的变换，来推导风险比的双侧 $95\\%$ Wald置信区间。计算此区间的上端点。使用对应于水平 $\\alpha = 0.05$ 的标准正态分位数，并将最终答案表示为一个纯数字。将您的答案四舍五入到四位有效数字。", "solution": "问题要求计算风险比（$\\mathrm{HR}$）的双侧 $95\\%$ Wald置信区间的上端点。在Cox比例风险模型 $h(t \\mid x) = h_{0}(t)\\,\\exp(x\\,\\beta_{1})$ 的背景下，风险比定义为协变量 $X$ 每增加一个单位时，$\\mathrm{HR} = \\exp(\\beta_{1})$。\n\n正如问题中所述，标准方法是首先为回归系数 $\\beta_{1}$ 构建一个置信区间，然后对其端点进行变换以获得风险比的置信区间。风险比的对数为 $\\ln(\\mathrm{HR}) = \\ln(\\exp(\\beta_{1})) = \\beta_{1}$。因此，我们将在这个“对数尺度”上构建置信区间。\n\n最大偏似然估计量（MPLE）$\\hat{\\beta}_{1}$ 是渐近正态分布的。$\\beta_{1}$ 的一个双侧 $(1-\\alpha) \\times 100\\%$ Wald置信区间由以下公式给出：\n$$ \\hat{\\beta}_{1} \\pm z_{\\alpha/2} \\cdot \\widehat{\\mathrm{SE}}(\\hat{\\beta}_{1}) $$\n其中 $\\hat{\\beta}_{1}$ 是系数的点估计，$\\widehat{\\mathrm{SE}}(\\hat{\\beta}_{1})$ 是估计量的估计标准误，而 $z_{\\alpha/2}$ 是来自标准正态分布的临界值，对应于 $\\alpha/2$ 的上尾概率。\n\n根据问题陈述，我们已知：\n- 系数的点估计：$\\hat{\\beta}_{1} = 0.37$。\n- 系数的估计方差：$\\widehat{\\mathrm{Var}}(\\hat{\\beta}_{1}) = 0.0484$。\n\n首先，我们计算估计的标准误，即估计方差的平方根：\n$$ \\widehat{\\mathrm{SE}}(\\hat{\\beta}_{1}) = \\sqrt{\\widehat{\\mathrm{Var}}(\\hat{\\beta}_{1})} = \\sqrt{0.0484} = 0.22 $$\n对于 $95\\%$ 的置信区间，显著性水平为 $\\alpha = 0.05$。因此，我们需要临界值 $z_{\\alpha/2} = z_{0.05/2} = z_{0.025}$。这是标准正态分位数，其累积概率为 $1 - 0.025 = 0.975$。众所周知，该值约为 $1.96$。\n$$ z_{0.025} \\approx 1.95996 \\dots $$\n我们将使用惯用值 $z_{0.025} = 1.96$。\n\n现在我们可以构建 $\\beta_{1}$ 的 $95\\%$ 置信区间：\n$$ \\mathrm{CI}_{95\\%}(\\beta_{1}) = \\hat{\\beta}_{1} \\pm z_{0.025} \\cdot \\widehat{\\mathrm{SE}}(\\hat{\\beta}_{1}) $$\n$$ \\mathrm{CI}_{95\\%}(\\beta_{1}) = 0.37 \\pm 1.96 \\times 0.22 $$\n误差范围是 $M = 1.96 \\times 0.22 = 0.4312$。\n因此，$\\beta_{1}$ 的区间是：\n$$ [0.37 - 0.4312, 0.37 + 0.4312] = [-0.0612, 0.8012] $$\n风险比为 $\\mathrm{HR} = \\exp(\\beta_{1})$。由于指数函数 $f(y) = \\exp(y)$ 是一个严格单调递增函数，因此可以通过对 $\\beta_{1}$ 置信区间的端点取指数来获得风险比的置信区间。\n令 $\\beta_{1}$ 置信区间的下界和上界分别为 $L_{\\beta}$ 和 $U_{\\beta}$。则风险比的置信区间为 $[\\exp(L_{\\beta}), \\exp(U_{\\beta})]$。\n$$ \\mathrm{CI}_{95\\%}(\\mathrm{HR}) = [\\exp(-0.0612), \\exp(0.8012)] $$\n问题具体要求计算该区间的上端点。\n$$ \\text{上端点} = \\exp(0.8012) $$\n我们现在计算其数值：\n$$ \\exp(0.8012) \\approx 2.22822409\\dots $$\n问题要求答案四舍五入到四位有效数字。前四位有效数字是 $2, 2, 2, 8$。第五位数字是 $2$，所以我们向下舍入。\n$$ \\text{上端点} \\approx 2.228 $$\n这是与标准化的mRNA表达分数每增加一个单位相关的风险比的 $95\\%$ 置信区间的上界。", "answer": "$$\\boxed{2.228}$$", "id": "4551012"}, {"introduction": "一个精确的估计如果来自于一个错误指定的模型，那么它将毫无意义。因此，模型诊断是生存分析中不可或缺的一环。本练习将重点关注如何检验Cox模型的一个关键假设：连续性协变量与对数风险之间存在线性关系。您将通过本练习学习如何使用鞅残差（martingale residuals），这是一种强大的诊断工具，用于直观地评估模型设定的函数形式是否恰当。[@problem_id:4550945]", "problem": "一项转化肿瘤学研究跟踪了一个由 $n$ 名高级别浆液性卵巢癌患者组成的队列，收集了她们的疾病进展时间 $T_i$、右删失指示符 $\\delta_i \\in \\{0,1\\}$，以及一个高维协变量向量 $x_i$。该向量包含来自RNA测序（RNA-seq）的连续基因表达测量值 $G_i$。研究人员拟合了一个 Cox 比例风险 (PH) 回归模型，其风险函数为 $h(t \\mid x_i) = h_0(t)\\exp(x_i^\\top \\beta)$，并使用标准的偏似然估计和 Breslow 型估计量来估计系数向量 $\\hat\\beta$ 和基线累积风险 $\\hat H_0(t)$。将个体水平的鞅残差定义为 $M_i = \\delta_i - \\hat H_0(T_i)\\exp(x_i^\\top \\hat\\beta)$。该团队计划使用 $M_i$ 来诊断 $G_i$ 对对数风险的假定线性效应是否充分，或者是否应考虑非线性变换（例如，样条）。\n\n在这种 Cox PH 设定中，关于鞅残差及其在检测非线性协变量效应方面的应用的以下陈述中，哪些是正确的？\n\nA. 残差 $M_i$ 等于 $\\delta_i - \\hat H_0(T_i)\\exp(x_i^\\top \\hat\\beta)$；在一个正确指定的模型和独立删失的条件下，有 $\\mathbb{E}\\!\\left[M_i \\mid x_i\\right] \\approx 0$，因此在 $G_i$ 的不同取值上，残差对 $0$ 的系统性偏离可以指示函数形式的设定错误。\n\nB. 残差 $M_i$ 关于 $0$ 对称，其支撑集为 $(-1,1)$，这使得 $M_i$ 和 $G_i$ 之间的简单相关性检验足以检测非线性效应。\n\nC. 绘制 $M_i$ 相对于连续协变量 $G_i$ 的非参数平滑曲线，是评估 $G_i$ 在对数风险中线性关系的一种有原则的方法；平滑曲线中的非线性模式表明应为 $G_i$ 添加变换或样条。\n\nD. $M_i$ 的主要作用是诊断随时间变化的比例风险假设的违规情况；如果比例风险假设成立， $M_i$ 对 $T_i$ 的图应是平坦的。\n\nE. 因为对于事件，$M_i$ 取值为 $1$，对于删失观测，$M_i$ 取值为 $0$，所以 $M_i$ 对 $G_i$ 的任何趋势都直接表明 $G_i$ 效应的非线性。\n\nF. 残差 $M_i$ 有上界 $1$ 且无下界，因此其分布通常是偏态的；虽然对于对称的异常值检测，偏差残差可能更可取，但当对 $M_i$ 与 $G_i$ 进行平滑处理时，$M_i$ 仍然保留了对非线性函数形式设定错误的敏感性。\n\n选择所有正确选项。", "solution": "问题陈述在科学上是合理的、定义明确且客观的。它提供了一个生存分析中的标准场景，用于评估来自 Cox 比例风险模型的鞅残差的属性和诊断用途。定义是正确的，问题可以使用既定的统计理论来回答。\n\nCox 比例风险模型将具有协变量 $x_i$ 的个体 $i$ 的风险指定为 $h(t \\mid x_i) = h_0(t)\\exp(x_i^\\top \\beta)$。这里，$h_0(t)$ 是基线风险函数，$\\beta$ 是回归系数向量。该模型的关键假设是协变量对风险起乘法作用，并且它们在对数风险尺度上的效应是线性的。\n\n受试者 $i$ 的鞅残差源自计数过程理论。受试者 $i$ 的真实鞅过程是 $M_i(t) = N_i(t) - \\int_0^t Y_i(u) h(u \\mid x_i) du$，其中 $N_i(t)$ 是事件的计数过程（如果事件发生，它在事件时间从 $0$ 跳到 $1$），$Y_i(t)$ 是风险过程（如果受试者在时间 $t$ 处于风险中，则为 $1$，否则为 $0$）。如果模型被正确指定，$M_i(t)$ 是一个零均值鞅。\n\n问题将受试者 $i$ 在其随访时间 $T_i$ 结束时的估计鞅残差定义为 $M_i = \\delta_i - \\hat H_0(T_i)\\exp(x_i^\\top \\hat\\beta)$。这里，$\\delta_i = N_i(\\infty)$ 是事件指示符，而 $\\hat H_0(T_i)\\exp(x_i^\\top \\hat\\beta)$ 是受试者 $i$ 在其随访期内的估计累积风险，它是预期事件数 $\\int_0^{T_i} h(u \\mid x_i) du$ 的一个估计。因此，鞅残差表示受试者 $i$ 的观测事件数（$\\delta_i$，为 $0$ 或 $1$）与拟合模型预测的预期事件数之间的差异。\n\n模型诊断的关键属性是，如果模型是正确的（包括协变量的函数形式），真实的鞅残差的期望值为零。因此，估计的鞅残差 $M_i$ 应该在零附近随机散布，没有系统性模式。\n\n让我们基于这些原则评估每个选项。\n\n**A. 残差 $M_i$ 等于 $\\delta_i - \\hat H_0(T_i)\\exp(x_i^\\top \\hat\\beta)$；在一个正确指定的模型和独立删失的条件下，有 $\\mathbb{E}\\!\\left[M_i \\mid x_i\\right] \\approx 0$，因此在 $G_i$ 的不同取值上，残差对 $0$ 的系统性偏离可以指示函数形式的设定错误。**\n\n- $M_i$ 的公式根据问题定义被正确陈述。\n- 来自正确指定模型的鞅残差的核心理论属性是，在给定协变量的条件下，它们的期望为零。使用估计参数 $\\hat\\beta$ 和 $\\hat H_0(t)$ 使这成为一个近似值，因此 $\\mathbb{E}\\!\\left[M_i \\mid x_i\\right] \\approx 0$。\n- 如果假定的 $G_i$ 的线性效应不正确，则模型设定错误。这种设定错误通常会导致残差的条件期望 $\\mathbb{E}\\!\\left[M_i \\mid G_i\\right]$ 随 $G_i$ 系统性地变化，而不是恒定为 $0$。例如，对于 $G_i$ 的低值和高值，模型可能一致地低估风险（导致正的平均残差），而对于中间值，模型可能高估风险（导致负的平均残差）。\n- 因此，观察到这种系统性模式是函数形式设定错误的一个公认指标。\n- **结论：正确。**\n\n**B. 残差 $M_i$ 关于 $0$ 对称，其支撑集为 $(-1,1)$，这使得 $M_i$ 和 $G_i$ 之间的简单相关性检验足以检测非线性效应。**\n\n- $M_i$ 的范围不是 $(-1,1)$。如果受试者发生事件（$\\delta_i = 1$），则 $M_i = 1 - \\hat H_0(T_i)\\exp(x_i^\\top \\hat\\beta)$。由于减去项是非负的，所以 $M_i \\le 1$。如果受试者被删失（$\\delta_i = 0$），则 $M_i = -\\hat H_0(T_i)\\exp(x_i^\\top \\hat\\beta)$。由于 $\\hat H_0(t)$ 是无界的，这个值可以是一个很大的负数。因此，$M_i$ 的范围是 $(-\\infty, 1]$。\n- 分布不是对称的。它是高度左偏的（负偏），因为所有被删失的受试者都有负残差，而发生事件的受试者的残差上限为 $1$。\n- 简单的相关性检验（如皮尔逊相关）只测量线性关联的强度。它无法检测残差中的 U 形或其他复杂的非线性模式，而这些正是函数形式设定错误的典型标志。\n- **结论：不正确。**\n\n**C. 绘制 $M_i$ 相对于连续协变量 $G_i$ 的非参数平滑曲线，是评估 $G_i$ 在对数风险中线性关系的一种有原则的方法；平滑曲线中的非线性模式表明应为 $G_i$ 添加变换或样条。**\n\n- 这个陈述描述了选项 A 中原则的实际应用。由于我们期望 $\\mathbb{E}\\!\\left[M_i \\mid G_i\\right] \\approx 0$，我们可以通过绘制 $M_i$ 对 $G_i$ 的散点图并叠加非参数平滑器（例如，LOESS 或平滑样条）来估计这个条件期望。\n- 如果 $G_i$ 的线性假设成立，这条平滑曲线应该是一条接近 $0$ 的水平线。\n- 如果平滑曲线显示出明显的非线性形状（例如，曲线或 U 形），它就提供了图形证据，表明 $G_i$ 与对数风险之间的关系不是线性的。这种模式可以指导模型的重新设定，例如通过为 $G_i$ 添加多项式项或更灵活的回归样条。这是生存分析中一种标准且强烈推荐的诊断程序。\n- **结论：正确。**\n\n**D. $M_i$ 的主要作用是诊断随时间变化的比例风险假设的违规情况；如果比例风险假设成立， $M_i$ 对 $T_i$ 的图应是平坦的。**\n\n- 尽管鞅残差用途广泛，但其主要用途通常不是诊断比例风险 (PH) 假设的违规情况。检查 PH 假设的标准工具是基于 **Schoenfeld 残差**。\n- 对于给定的协变量，通过绘制缩放后的 Schoenfeld 残差与时间函数（例如，$t$ 或 $\\log(t)$）的图来检查 PH 假设。该图中的非零斜率表明该协变量的系数是时间依赖的，从而违反了 PH 假设。\n- 绘制鞅残差 $M_i$ 对其相应的生存时间 $T_i$ 的图不是用于此目的的标准或最直接的方法。与 Schoenfeld 残差图相比，所得的图在解释 PH 假设方面要困难得多。\n- **结论：不正确。**\n\n**E. 因为对于事件，$M_i$ 取值为 $1$，对于删失观测，$M_i$ 取值为 $0$，所以 $M_i$ 对 $G_i$ 的任何趋势都直接表明 $G_i$ 效应的非线性。**\n\n- 这个关于 $M_i$ 值的陈述在事实上是不正确的。鞅残差定义为 $M_i = \\delta_i - (\\text{估计的累积风险})$。\n- 对于事件，$\\delta_i=1$，但 $M_i = 1 - \\hat H_0(T_i)\\exp(x_i^\\top \\hat\\beta)$，它并不固定为 $1$。\n- 对于删失观测，$\\delta_i=0$，但 $M_i = -\\hat H_0(T_i)\\exp(x_i^\\top \\hat\\beta)$，它通常不为 $0$；它是某个负值。\n- 该陈述从根本上误解了鞅残差的定义，将其与原始事件指示符 $\\delta_i$ 混淆了。\n- **结论：不正确。**\n\n**F. 残差 $M_i$ 有上界 $1$ 且无下界，因此其分布通常是偏态的；虽然对于对称的异常值检测，偏差残差可能更可取，但当对 $M_i$ 与 $G_i$ 进行平滑处理时，$M_i$ 仍然保留了对非线性函数形式设定错误的敏感性。**\n\n- 正如在对选项 B 的分析中所确立的，$M_i$ 的范围是 $(-\\infty, 1]$，因为对于具有高预测风险的删失受试者，它可以取任意大的负值，而对于经历事件的受试者，其上界为 $1$。这导致了左偏分布。陈述的这一部分是正确的。\n- 偏差残差是鞅残差的一种变换，$D_i = \\text{sign}(M_i) \\sqrt{-2[M_i + \\delta_i \\log(\\delta_i - M_i)]}$，其设计目的是使其在 $0$ 附近分布更对称。这种对称性使它们更适合于识别单个异常值等任务，因为在这些任务中，人们通常依赖于正态理论模型的直觉。这个比较是准确的。\n- 尽管鞅残差存在偏度，但对于一个正确的模型，$\\mathbb{E}[M_i | x_i] \\approx 0$ 的性质仍然成立。因此，将原始鞅残差 $M_i$ 对协变量 $G_i$ 进行平滑处理，仍然是检测系统性偏差并从而检查函数形式的一种有效且强大的方法。\n- 整个陈述是对鞅残差的属性及其在诊断中地位的正确而细致的总结。\n- **结论：正确。**", "answer": "$$\\boxed{ACF}$$", "id": "4550945"}, {"introduction": "现实世界的医学数据往往比“每位患者一次事件”的简单情景复杂得多，例如患者可能会经历反复住院。为了处理这类复发事件数据，我们需要更高级的模型。本练习将介绍Andersen-Gill（AG）模型，它是Cox模型在复发事件分析中的重要扩展。您将通过从零开始构建AG模型的核心组件，深入了解生存分析软件的“幕后”工作原理，从而巩固对风险集、偏似然和数值优化过程的理解。[@problem_id:4550962]", "problem": "一名开发人员的任务是构建一个程序，该程序使用 Andersen–Gill 计数过程公式来估计复发事件的 Cox 比例风险回归中的回归系数。其生物医学背景是心力衰竭患者的复发性住院。每位患者在随访期间可能会经历多次住院，暴露是一个表示是否接受了护理管理计划的二元指标。该模型应使用风险区间的开始-停止表示法构建，并应使用 Breslow 近似法处理事件时间中的结。开发人员必须从基本原理出发，从风险和风险集的定义开始，实现该估计量，并且不得依赖外部的生存分析库。\n\n基本原理：\n- Cox 比例风险回归模型将个体 $i$ 在时间 $t$ 的风险定义为 $h_i(t) = h_0(t) \\exp\\{\\beta x_i(t)\\}$，其中 $h_0(t)$ 是一个未指定的基线风险，$x_i(t)$ 是可能随时间变化的协变量值，而 $\\beta$ 是待估计的回归系数。\n- 在 Andersen–Gill 计数过程 (AG) 公式中，每个受试者贡献一个或多个他们处于风险中的区间 $\\left[s, t\\right)$。对于每个区间，其右端点关联一个二元事件指标，反映事件是否在该区间的停止时间发生。时间 $t$ 的风险集由所有开始时间严格小于 $t$ 且停止时间大于或等于 $t$ 的区间组成。\n- 估计过程通过最大化从这些定义中推导出的偏似然来进行，并对相同时点发生的多个事件使用适当的结处理方法（Breslow 近似法）。\n\n您的程序必须：\n1. 在 Andersen–Gill 计数过程公式下，通过将原始事件时间转换为每个患者的 $(\\text{start}, \\text{stop}, \\text{event}, x)$ 形式的区间数据，来演示复发事件的开始-停止编码。\n2. 从基本原理出发，使用 Newton–Raphson 迭代、处理事件时间中结的 Breslow 近似法以及上述风险集定义，实现单个系数 $\\beta$ 的最大偏似然估计量。协变量 $x$ 在每个区间内是恒定的，如果患者参与了护理管理计划，则等于 $1$，否则等于 $0$。\n3. 将该实现应用于以下测试套件（三个独立数据集），每个数据集代表一个合理的复发性住院生物医学注册库。时间单位为天。\n\n数据集 A（理想路径；无左截断的复发事件）：\n- 患者 1：第 $0$ 天进入，第 $10, 40, 90$ 天发生事件，第 $120$ 天删失，$x=1$。\n- 患者 2：第 $0$ 天进入，第 $20, 85$ 天发生事件，第 $100$ 天删失，$x=0$。\n- 患者 3：第 $0$ 天进入，无事件，第 $100$ 天删失，$x=1$。\n\n数据集 B（跨受试者的事件时间存在结）：\n- 患者 1：第 $0$ 天进入，第 $30, 60$ 天发生事件，第 $80$ 天删失，$x=0$。\n- 患者 2：第 $0$ 天进入，第 $30$ 天发生事件，第 $50$ 天删失，$x=1$。\n- 患者 3：第 $0$ 天进入，第 $60$ 天发生事件，第 $90$ 天删失，$x=1$。\n- 患者 4：第 $0$ 天进入，无事件，第 $60$ 天删失，$x=0$。\n\n数据集 C（左截断；存在复发事件的交错进入）：\n- 患者 1：第 $20$ 天进入，第 $50$ 天发生事件，第 $60$ 天删失，$x=1$。\n- 患者 2：第 $0$ 天进入，第 $25, 120$ 天发生事件，第 $150$ 天删失，$x=0$。\n- 患者 3：第 $0$ 天进入，无事件，第 $150$ 天删失，$x=1$。\n- 患者 4：第 $60$ 天进入，第 $120$ 天发生事件，第 $160$ 天删失，$x=0$。\n\n开始-停止编码细节：\n- 对于每个进入时间为 $a$，住院事件时间为 $t_1  t_2  \\dots  t_K$，删失时间为 $C$ 的患者，创建以下区间：\n  - 如果 $K \\ge 1$，则为 $(a, t_1]$，事件指标为 $1$；\n  - 对于 $j = 1, \\dots, K-1$，为 $(t_j, t_{j+1}]$，事件指标为 $1$；\n  - 如果 $K \\ge 1$，则为 $(t_K, C]$，事件指标为 $0$；或者如果 $K = 0$，则为 $(a, C]$，事件指标为 $0$。\n- 日历时间 $t$ 的风险集包括满足 $s  t \\le u$ 的每个区间 $(s, u]$。\n\n输出规范：\n- 对于每个数据集，使用上述方法估计护理管理计划的回归系数 $\\hat{\\beta}$。\n- 将每个估计值表示为四舍五入到六位小数的十进制数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序为 [数据集 A 结果, 数据集 B 结果, 数据集 C 结果]。例如：\"[0.123456,-0.010000,0.500000]\"。\n\n程序必须完全自包含，无需任何输入，并可在任何支持 Python 和指定库的现代环境中运行。最终答案为浮点数；无需报告物理单位或角度单位。通过一致的区间构建和如上所述的正确风险集形成来确保科学真实性。", "solution": "该问题是有效的。它提出了生物统计学中一个明确定义的任务：使用 Andersen–Gill (AG) 计数过程公式来估计复发事件的 Cox 比例风险模型的回归系数。该问题提供了清晰的理论基础、数据表示（开始-停止编码）的具体说明、处理事件时间中结的指定方法（Breslow 近似法）以及用于估计的数值算法（Newton-Raphson）。提供的三个数据集是完整、一致的，并代表了医学研究中可能的场景，包括事件时间中的结和左截断（交错进入）。\n\n解决方案首先将患者层面的数据转换为所需的开始-停止区间格式。然后，我们实现 Newton-Raphson 算法来找到偏对数似然函数的最大值。这涉及推导并实现对数似然的得分函数（一阶导数）和观测信息（二阶导数的负值）。\n\n**1. 数据转换：Andersen–Gill 计数过程公式**\n\nAndersen–Gill 模型通过重构数据将 Cox 模型扩展到复发事件。每个患者的随访历史被分解为一系列不相交的时间区间 $(\\text{start}, \\text{stop}]$。对于每个区间，我们记录一个事件指标（如果在停止时间发生事件则为 $1$，否则为 $0$）和相应的协变量值。\n\n对于一个进入时间为 $a$、事件时间为 $t_1  t_2  \\dots  t_K$、删失时间为 $C$ 的患者，区间构造如下：\n- $(\\text{start}_1, \\text{stop}_1] = (a, t_1]$，事件指标为 $1$。\n- $(\\text{start}_j, \\text{stop}_j] = (t_{j-1}, t_j]$，对于 $j=2, \\dots, K$，事件指标为 $1$。\n- $(\\text{start}_{K+1}, \\text{stop}_{K+1}] = (t_K, C]$，事件指标为 $0$。\n如果患者没有事件 ($K=0$)，他们贡献一个单一区间 $(a, C]$，事件指标为 $0$。协变量 $x$ 与每个区间相关联。\n\n**2. 复发事件的 Cox 模型偏似然**\n\nCox 比例风险模型将第 $i$ 个风险区间在时间 $t$ 发生事件的风险率指定为：\n$$ h_i(t) = h_0(t) \\exp(\\beta x_i) $$\n其中 $h_0(t)$ 是基线风险，$x_i$ 是区间 $i$ 的协变量，$\\beta$ 是待估计的对数风险比。\n\n$\\beta$ 的估计是基于最大化偏似然。设唯一的有序事件时间为 $T_1  T_2  \\dots  T_m$。在时间 $T_j$ 的风险集，记为 $R(T_j)$，是所有在该时间点处于活动状态的区间 $k$ 的集合，即其 $(\\text{start}_k, \\text{stop}_k]$ 满足 $\\text{start}_k  T_j \\le \\text{stop}_k$。设 $D_j$ 是在时间 $T_j$ 发生事件的区间集合，并设 $d_j = |D_j|$ 是在时间 $T_j$ 发生的（存在结的）事件数量。\n\n使用 Breslow 近似法处理结，偏对数似然函数由下式给出：\n$$ \\ell(\\beta) = \\sum_{j=1}^{m} \\left( \\sum_{k \\in D_j} \\beta x_k - d_j \\log \\left( \\sum_{l \\in R(T_j)} \\exp(\\beta x_l) \\right) \\right) $$\n\n**3. 通过 Newton-Raphson 进行最大似然估计**\n\n为了找到使 $\\ell(\\beta)$ 最大化的 $\\beta$ 值，我们使用 Newton-Raphson 方法。这是一个迭代算法，用于找到对数似然函数的一阶导数（即得分函数 $U(\\beta)$）的根。更新规则是：\n$$ \\beta_{k+1} = \\beta_k - \\frac{U(\\beta_k)}{\\frac{\\partial^2 \\ell(\\beta_k)}{\\partial \\beta^2}} = \\beta_k + \\frac{U(\\beta_k)}{\\mathcal{I}(\\beta_k)} $$\n其中 $\\mathcal{I}(\\beta) = -\\frac{\\partial^2 \\ell(\\beta)}{\\partial \\beta^2}$ 是观测信息。\n\n要实现这一点，我们需要 $\\ell(\\beta)$ 的一阶和二阶导数。让我们在给定的事件时间 $T_j$ 定义风险集 $R(T_j)$ 上的以下总和：\n- $S^{(0)}(\\beta, T_j) = \\sum_{l \\in R(T_j)} \\exp(\\beta x_l)$\n- $S^{(1)}(\\beta, T_j) = \\sum_{l \\in R(T_j)} x_l \\exp(\\beta x_l)$\n- $S^{(2)}(\\beta, T_j) = \\sum_{l \\in R(T_j)} x_l^2 \\exp(\\beta x_l)$\n\n**得分函数**（一阶导数）是：\n$$ U(\\beta) = \\frac{\\partial \\ell(\\beta)}{\\partial \\beta} = \\sum_{j=1}^{m} \\left( \\sum_{k \\in D_j} x_k - d_j \\frac{S^{(1)}(\\beta, T_j)}{S^{(0)}(\\beta, T_j)} \\right) $$\n\n**观测信息**（二阶导数的负值）是：\n$$ \\mathcal{I}(\\beta) = -\\frac{\\partial^2 \\ell(\\beta)}{\\partial \\beta^2} = \\sum_{j=1}^{m} d_j \\left[ \\frac{S^{(2)}(\\beta, T_j)}{S^{(0)}(\\beta, T_j)} - \\left( \\frac{S^{(1)}(\\beta, T_j)}{S^{(0)}(\\beta, T_j)} \\right)^2 \\right] $$\n方括号中的项是风险集 $R(T_j)$ 成员中协变量 $x$ 的方差，由它们各自的风险贡献 $\\exp(\\beta x_l)$ 加权。\n\n**4. 算法步骤**\n对于每个数据集，该实现将执行以下步骤：\n1.  **数据准备**：将每个数据集的原始患者数据转换为统一的 $(\\text{start}, \\text{stop}, \\text{event}, x)$ 区间列表。\n2.  **事件时间识别**：从区间数据中识别并排序唯一的事件时间 $\\{T_j\\}$。\n3.  **Newton-Raphson 迭代**：\n    a. 初始化系数估计值 $\\beta = 0.0$。\n    b. 迭代固定次数或直到收敛（即 $\\beta$ 的变化可以忽略不计）。\n    c. 在每次迭代中，通过对每个唯一事件时间 $T_j$ 的贡献求和，计算总得分 $U(\\beta)$ 和信息 $\\mathcal{I}(\\beta)$。\n    d. 对于每个 $T_j$，确定风险集 $R(T_j)$、事件集 $D_j$ 和事件计数 $d_j$。\n    e. 在风险集上计算 $S^{(0)}$、$S^{(1)}$ 和 $S^{(2)}$。\n    f. 更新总得分和信息。\n    g. 遍历所有事件时间后，使用公式 $\\beta \\leftarrow \\beta + U(\\beta) / \\mathcal{I}(\\beta)$ 更新 $\\beta$。\n4.  **输出**：报告为所提供的三个数据集中的每一个计算出的最终估计值 $\\hat{\\beta}$，四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _create_ag_intervals(raw_patient_data):\n    \"\"\"\n    Transforms raw patient data into Andersen-Gill start-stop intervals.\n\n    Args:\n        raw_patient_data (list): A list of dictionaries, each representing a patient.\n            Keys: 'entry', 'events' (list of times), 'censor', 'x'.\n\n    Returns:\n        list: A list of dictionaries, each representing a risk interval.\n            Keys: 'start', 'stop', 'event', 'x'.\n    \"\"\"\n    intervals = []\n    for pt in raw_patient_data:\n        event_times = sorted(pt['events'])\n        current_start_time = pt['entry']\n        \n        # Create intervals ending with an event\n        for event_time in event_times:\n            if event_time > current_start_time:\n                intervals.append({\n                    'start': current_start_time,\n                    'stop': event_time,\n                    'event': 1,\n                    'x': pt['x']\n                })\n            current_start_time = event_time\n            \n        # Create final censoring interval\n        if pt['censor'] > current_start_time:\n            intervals.append({\n                'start': current_start_time,\n                'stop': pt['censor'],\n                'event': 0,\n                'x': pt['x']\n            })\n    return intervals\n\ndef calculate_beta_ag(raw_patient_data, max_iter=20, tol=1e-7):\n    \"\"\"\n    Estimates the regression coefficient for a single covariate Cox model\n    with recurrent events using the Andersen-Gill formulation.\n\n    Args:\n        raw_patient_data (list): A list of patient data dictionaries.\n        max_iter (int): Maximum number of Newton-Raphson iterations.\n        tol (float): Tolerance for convergence.\n\n    Returns:\n        float: The estimated regression coefficient beta.\n    \"\"\"\n    intervals = _create_ag_intervals(raw_patient_data)\n    \n    unique_event_times = sorted(list(set(\n        ival['stop'] for ival in intervals if ival['event'] == 1\n    )))\n    \n    beta = 0.0\n    for _ in range(max_iter):\n        score_U = 0.0  # First derivative of log-likelihood\n        info_I = 0.0   # Negative second derivative (information)\n\n        for t_event in unique_event_times:\n            # Identify risk set and event set for the current event time\n            risk_set_covariates, event_set_covariates = [], []\n            \n            for ival in intervals:\n                # Risk set: interval is active at t_event\n                if ival['start']  t_event = ival['stop']:\n                    risk_set_covariates.append(ival['x'])\n                    # Event set: event occurs exactly at t_event\n                    if ival['stop'] == t_event and ival['event'] == 1:\n                        event_set_covariates.append(ival['x'])\n\n            risk_set_x = np.array(risk_set_covariates)\n            d_j = len(event_set_covariates)\n            sum_x_at_event = sum(event_set_covariates)\n\n            if d_j == 0:\n                continue\n\n            # Calculate S_0, S_1, S_2 sums\n            risk_weights = np.exp(beta * risk_set_x)\n            \n            s0 = np.sum(risk_weights)\n            s1 = np.sum(risk_set_x * risk_weights)\n            s2 = np.sum(risk_set_x**2 * risk_weights)\n            \n            if s0 > 0:\n                E1 = s1 / s0\n                E2 = s2 / s0\n                \n                # Update total score and information\n                score_U += sum_x_at_event - d_j * E1\n                info_I += d_j * (E2 - E1**2)\n\n        if info_I = 1e-9:\n            # Information is zero or negative, cannot update.\n            # This can happen with perfect separation or sparse data.\n            break\n\n        delta_beta = score_U / info_I\n        beta += delta_beta\n\n        if abs(delta_beta)  tol:\n            break\n            \n    return beta\n\ndef solve():\n    \"\"\"\n    Main function to define datasets, run the analysis, and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Dataset A\n        [\n            {'id': 1, 'entry': 0, 'events': [10, 40, 90], 'censor': 120, 'x': 1},\n            {'id': 2, 'entry': 0, 'events': [20, 85], 'censor': 100, 'x': 0},\n            {'id': 3, 'entry': 0, 'events': [], 'censor': 100, 'x': 1},\n        ],\n        # Dataset B\n        [\n            {'id': 1, 'entry': 0, 'events': [30, 60], 'censor': 80, 'x': 0},\n            {'id': 2, 'entry': 0, 'events': [30], 'censor': 50, 'x': 1},\n            {'id': 3, 'entry': 0, 'events': [60], 'censor': 90, 'x': 1},\n            {'id': 4, 'entry': 0, 'events': [], 'censor': 60, 'x': 0},\n        ],\n        # Dataset C\n        [\n            {'id': 1, 'entry': 20, 'events': [50], 'censor': 60, 'x': 1},\n            {'id': 2, 'entry': 0, 'events': [25, 120], 'censor': 150, 'x': 0},\n            {'id': 3, 'entry': 0, 'events': [], 'censor': 150, 'x': 1},\n            {'id': 4, 'entry': 60, 'events': [120], 'censor': 160, 'x': 0},\n        ],\n    ]\n\n    results = []\n    for case_data in test_cases:\n        beta_hat = calculate_beta_ag(case_data)\n        results.append(beta_hat)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4550962"}]}