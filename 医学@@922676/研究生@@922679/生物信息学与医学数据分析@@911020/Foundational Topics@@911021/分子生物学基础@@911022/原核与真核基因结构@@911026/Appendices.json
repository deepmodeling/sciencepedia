{"hands_on_practices": [{"introduction": "掌握原核生物和真核生物基因结构的核心区别对于分子生物学和合成生物学至关重要。真核基因通常被非编码的内含子打断，这些内含子在转录后通过剪接过程被移除，而原核基因则没有这个特征。这个练习将通过一个具体案例，计算前体mRNA和成熟mRNA的长度，来巩固您对外显子、内含子和RNA剪接这些基本概念的理解，并将其与实际的基因工程设计联系起来 ([@problem_id:2764248])。", "problem": "一位合成生物学家正在分析一个真核基因，以设计一个等效的原核表达构建体。该真核基因的总基因组跨度为 $4\\,\\text{kb}$，包含 $3$ 个外显子，长度分别为 $150\\,\\text{bp}$、$1200\\,\\text{bp}$ 和 $300\\,\\text{bp}$，由 $2$ 个内含子隔开，长度分别为 $900\\,\\text{bp}$ 和 $1450\\,\\text{bp}$。假设如下：(i) 转录在第一个外显子的上游起始，在最后一个外显子的下游终止，因此初始转录本（信使核糖核酸前体，pre-mRNA）包含所有给定的外显子和内含子；(ii) 真核生物中的信使核糖核酸（mRNA）成熟过程通过剪接体剪接完全去除内含子，无内含子保留；(iii) 忽略超出给定外显子长度的 $5^{\\prime}$ 端加帽、$3^{\\prime}$ 端多聚腺苷酸化和非翻译区（UTR）的贡献；(iv) 在原核设计中，相同的编码区被编码为一个无内含子的单一连续单元，转录产生的mRNA与该编码区共线性，没有额外的非翻译前导序列或尾随序列。\n\n仅使用中心法则（脱氧核糖核酸到核糖核酸到蛋白质）的基本原理、外显子和内含子的定义，以及典型原核基因中公认不存在剪接体内含子这一事实，推导真核pre-mRNA、真核成熟mRNA以及相应原核mRNA的长度表达式（用外显子和内含子的长度表示）。然后，利用所提供的外显子和内含子的大小，计算这些表达式的值。\n\n最终数值答案以核苷酸（nt）为单位的精确整数形式提供。按以下顺序报告这三个值：真核pre-mRNA长度、真核成熟mRNA长度、原核mRNA长度。最终答案以单行矩阵形式表示。无需四舍五入。在最终的方框答案中不要包含单位；在其他地方，长度以nt表示。", "solution": "所述问题是有效的。它在科学上基于分子生物学的基本原理，特别是中心法则以及真核和原核基因的结构差异。给定的条件是自洽、一致且足以推导出一个唯一且有意义的解。我们将着手进行推导。\n\n所考察的核心原理是基因表达的过程。在真核生物中，基因从其脱氧核糖核酸（DNA）模板转录，产生信使核糖核酸前体（pre-mRNA）。这个pre-mRNA分子是基因序列的直接转录本，包含编码区（称为外显子）和非编码的插入序列（称为内含子）。通过一个称为剪接的过程，内含子被切除，外显子连接在一起，形成成熟的信使核糖核酸（mRNA）。相比之下，典型的原核基因不被剪接体内含子打断，转录出的mRNA与编码DNA序列共线性。本题要求我们基于这些原理计算中间和最终RNA产物的长度。\n\n设 $N_E$ 为外显子的数量，$N_I$ 为内含子的数量。设 $L_{E_i}$ 为第 $i$ 个外显子的长度，$L_{I_j}$ 为第 $j$ 个内含子的长度，其中 $i \\in \\{1, \\dots, N_E\\}$ 且 $j \\in \\{1, \\dots, N_I\\}$。长度以碱基对（bp）给出，对于单链RNA的长度，这直接对应于核苷酸（nt）。\n\n给定条件如下：\n$N_E = 3$\n$L_{E_1} = 150\\,\\text{nt}$\n$L_{E_2} = 1200\\,\\text{nt}$\n$L_{E_3} = 300\\,\\text{nt}$\n$N_I = 2$\n$L_{I_1} = 900\\,\\text{nt}$\n$L_{I_2} = 1450\\,\\text{nt}$\n\n首先，我们推导真核pre-mRNA长度的通用表达式，记为 $L_{\\text{pre-mRNA}}$。根据假设(i)，pre-mRNA是包含所有外显子和内含子的初始转录本。因此，其长度是所有单个外显子和内含子长度的总和。\n$$L_{\\text{pre-mRNA}} = \\sum_{i=1}^{N_E} L_{E_i} + \\sum_{j=1}^{N_I} L_{I_j}$$\n\n其次，我们推导真核成熟mRNA长度的表达式，记为 $L_{\\text{mature-mRNA}}$。根据假设(ii)，成熟mRNA是通过剪接产生的，该过程移除了所有内含子。假设(iii)指示我们忽略其他特征，如 $5'$ 端帽和 $3'$ 端poly(A)尾。因此，成熟mRNA的长度就是所有外显子长度的总和。\n$$L_{\\text{mature-mRNA}} = \\sum_{i=1}^{N_E} L_{E_i}$$\n\n第三，我们推导相应的原核mRNA长度的表达式，记为 $L_{\\text{prok-mRNA}}$。题目指定了一个旨在表达相同蛋白质的合成原核构建体。这意味着原核基因的编码序列必须与剪接后的真核mRNA的编码序列相同。在原核生物中，转录是共线性的。假设(iv)指出我们忽略非翻译的前导和尾随序列。因此，原核mRNA的长度必须等于原始真核基因中所有外显子的总长度。\n$$L_{\\text{prok-mRNA}} = \\sum_{i=1}^{N_E} L_{E_i} = L_{\\text{mature-mRNA}}$$\n\n现在我们使用给定的值进行计算。\n外显子的总长度为：\n$$\\sum_{i=1}^{3} L_{E_i} = L_{E_1} + L_{E_2} + L_{E_3} = 150 + 1200 + 300 = 1650\\,\\text{nt}$$\n内含子的总长度为：\n$$\\sum_{j=1}^{2} L_{I_j} = L_{I_1} + L_{I_2} = 900 + 1450 = 2350\\,\\text{nt}$$\n\n使用这些总和，我们计算每种RNA分子的长度。\n\n真核pre-mRNA的长度：\n$$L_{\\text{pre-mRNA}} = \\left(\\sum_{i=1}^{3} L_{E_i}\\right) + \\left(\\sum_{j=1}^{2} L_{I_j}\\right) = 1650 + 2350 = 4000\\,\\text{nt}$$\n该结果与所提供的总基因组跨度 $4\\,\\text{kb}$（即 $4000\\,\\text{bp}$）一致。\n\n真核成熟mRNA的长度：\n$$L_{\\text{mature-mRNA}} = \\sum_{i=1}^{3} L_{E_i} = 1650\\,\\text{nt}$$\n\n原核mRNA的长度：\n$$L_{\\text{prok-mRNA}} = \\sum_{i=1}^{3} L_{E_i} = 1650\\,\\text{nt}$$\n\n题目要求最终答案为一个单行矩阵，按顺序包含三个计算出的长度：真核pre-mRNA长度、真核成熟mRNA长度和原核mRNA长度。这些值分别为 $4000$、$1650$ 和 $1650$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4000 & 1650 & 1650\n\\end{pmatrix}\n}\n$$", "id": "2764248"}, {"introduction": "基因表达的调控是一个精细的量化过程，而非简单的“开”或“关”。在原核生物中，启动子序列的微小差异会显著影响转录起始的速率。本练习将向您介绍位置权重矩阵 (Position Weight Matrix, PWM)，这是生物信息学中用于描述序列模体 (motif) 的一个核心工具。通过使用PWM，您将学习如何量化一个给定的DNA序列与理想结合位点的匹配程度，并利用这个分数来预测基因的相对转录活性 ([@problem_id:4599016])。", "problem": "在细菌转录起始过程中，RNA聚合酶全酶通过σ因子识别启动子DNA，而有效结合的概率取决于启动子基序上的序列特异性相互作用。位置权重矩阵（PWM）编码了基序中每个位置上核苷酸的位置特异性多项式模型。考虑一个识别$12$个碱基对启动子基序（六个碱基对对应$-35$元件，六个碱基对对应$-10$元件）的σ因子。给定一个位置权重矩阵（PWM）和一个固定的背景核苷酸分布。PWM为基序模型下的每个位置 $i \\in \\{1,\\dots,12\\}$ 指定了核苷酸 $\\{A,C,G,T\\}$ 的概率。PWM的行按顺序对应核苷酸 $A$、$C$、$G$、$T$，列对应位置$1$到$12$：\n$$\n\\text{PWM} =\n\\begin{pmatrix}\n0.05 & 0.10 & 0.10 & 0.60 & 0.10 & 0.70 & 0.10 & 0.60 & 0.10 & 0.60 & 0.60 & 0.10 \\\\\n0.10 & 0.10 & 0.10 & 0.10 & 0.60 & 0.10 & 0.10 & 0.10 & 0.10 & 0.10 & 0.10 & 0.10 \\\\\n0.15 & 0.10 & 0.60 & 0.20 & 0.20 & 0.10 & 0.10 & 0.10 & 0.10 & 0.10 & 0.10 & 0.10 \\\\\n0.70 & 0.70 & 0.20 & 0.10 & 0.10 & 0.10 & 0.70 & 0.20 & 0.70 & 0.20 & 0.20 & 0.70\n\\end{pmatrix}.\n$$\n假设一个固定的核苷酸背景分布 $q$ 为 $q(A)=0.30$、$q(C)=0.20$、$q(G)=0.20$ 和 $q(T)=0.30$。将启动子序列的对数优势比分数定义为PWM模型与背景模型下似然比的自然对数，使用跨位置的标准独立性假设。提供了两个长度为$12$的启动子序列：\n- 序列$1$：$\\mathrm{TTGACATATAAT}$，\n- 序列$2$：$\\mathrm{CTGGCGTATCAT}$。\n假设在一个热力学占有模型中，转录起始速率与自然对数对数优势比分数的指数成正比，计算序列$1$相对于序列$2$的预测起始速率之比 $R_{1}/R_{2}$。在所有计算中使用自然对数，并将最终比率表示为无单位的小数。将你的答案四舍五入到四位有效数字。", "solution": "问题要求基于位置权重矩阵（PWM）模型，计算两个DNA序列 $S_1$ 和 $S_2$ 的转录起始速率之比 $R_{1}/R_{2}$。\n\n首先，让我们将所涉及的量形式化。启动子基序的长度为 $L=12$。PWM，记为 $W$，是一个矩阵，其中 $W(b, i)$ 给出在基序模型下，在位置 $i \\in \\{1,\\dots,12\\}$ 观察到核苷酸 $b \\in \\{\\mathrm{A,C,G,T}\\}$ 的概率。背景核苷酸分布由 $q(b)$ 给出。\n\n问题将序列 $S = s_1s_2\\dots s_{12}$ 的对数优势比分数定义为似然比的自然对数。在PWM模型下，序列的似然为 $P(S|W) = \\prod_{i=1}^{12} W(s_i, i)$。在背景模型下，序列的似然为 $P(S|q) = \\prod_{i=1}^{12} q(s_i)$。似然比 $LR(S)$ 由下式给出：\n$$\nLR(S) = \\frac{P(S|W)}{P(S|q)} = \\frac{\\prod_{i=1}^{12} W(s_i, i)}{\\prod_{i=1}^{12} q(s_i)} = \\prod_{i=1}^{12} \\frac{W(s_i, i)}{q(s_i)}\n$$\n对数优势比分数，我们记为 $\\mathcal{S}(S)$，是该比率的自然对数：\n$$\n\\mathcal{S}(S) = \\ln(LR(S)) = \\ln\\left(\\prod_{i=1}^{12} \\frac{W(s_i, i)}{q(s_i)}\\right) = \\sum_{i=1}^{12} \\ln\\left(\\frac{W(s_i, i)}{q(s_i)}\\right)\n$$\n问题指出，转录起始速率 $R$ 与自然对数对数优势比分数的指数成正比。设 $k$ 为比例常数。\n$$\nR(S) = k \\cdot \\exp(\\mathcal{S}(S))\n$$\n代入 $\\mathcal{S}(S)$ 的表达式，我们发现速率与似然比之间存在直接关系：\n$$\nR(S) = k \\cdot \\exp(\\ln(LR(S))) = k \\cdot LR(S)\n$$\n因此，起始速率与似然比本身成正比。序列1 ($S_1$) 和序列2 ($S_2$) 的起始速率之比为：\n$$\n\\frac{R_1}{R_2} = \\frac{R(S_1)}{R(S_2)} = \\frac{k \\cdot LR(S_1)}{k \\cdot LR(S_2)} = \\frac{LR(S_1)}{LR(S_2)}\n$$\n我们的任务简化为计算每个序列的似然比，然后求这两个值的比率。\n\n给定的数据是：\n- 背景分布：$q(\\mathrm{A})=0.30$、$q(\\mathrm{C})=0.20$、$q(\\mathrm{G})=0.20$、$q(\\mathrm{T})=0.30$。\n- PWM矩阵 $W$，行对应A、C、G、T，列对应位置1到12。\n- 序列1：$S_1 = \\mathrm{TTGACATATAAT}$。\n- 序列2：$S_2 = \\mathrm{CTGGCGTATCAT}$。\n\n让我们计算 $LR(S_1)$。对于 $S_1$ 中的每个位置 $i$，我们找到比率 $\\frac{W(s_{1,i}, i)}{q(s_{1,i})}$。\n- $i=1, s_1=\\mathrm{T}$: $\\frac{W(\\mathrm{T},1)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=2, s_2=\\mathrm{T}$: $\\frac{W(\\mathrm{T},2)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=3, s_3=\\mathrm{G}$: $\\frac{W(\\mathrm{G},3)}{q(\\mathrm{G})} = \\frac{0.60}{0.20} = 3$\n- $i=4, s_4=\\mathrm{A}$: $\\frac{W(\\mathrm{A},4)}{q(\\mathrm{A})} = \\frac{0.60}{0.30} = 2$\n- $i=5, s_5=\\mathrm{C}$: $\\frac{W(\\mathrm{C},5)}{q(\\mathrm{C})} = \\frac{0.60}{0.20} = 3$\n- $i=6, s_6=\\mathrm{A}$: $\\frac{W(\\mathrm{A},6)}{q(\\mathrm{A})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=7, s_7=\\mathrm{T}$: $\\frac{W(\\mathrm{T},7)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=8, s_8=\\mathrm{A}$: $\\frac{W(\\mathrm{A},8)}{q(\\mathrm{A})} = \\frac{0.60}{0.30} = 2$\n- $i=9, s_9=\\mathrm{T}$: $\\frac{W(\\mathrm{T},9)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=10, s_{10}=\\mathrm{A}$: $\\frac{W(\\mathrm{A},10)}{q(\\mathrm{A})} = \\frac{0.60}{0.30} = 2$\n- $i=11, s_{11}=\\mathrm{A}$: $\\frac{W(\\mathrm{A},11)}{q(\\mathrm{A})} = \\frac{0.60}{0.30} = 2$\n- $i=12, s_{12}=\\mathrm{T}$: $\\frac{W(\\mathrm{T},12)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n$S_1$ 的似然比是这些值的乘积：\n$$\nLR(S_1) = \\left(\\frac{7}{3}\\right)^6 \\cdot (3)^2 \\cdot (2)^4 = \\frac{7^6 \\cdot 3^2 \\cdot 2^4}{3^6} = \\frac{7^6 \\cdot 2^4}{3^4}\n$$\n\n接下来，我们计算 $S_2 = \\mathrm{CTGGCGTATCAT}$ 的 $LR(S_2)$。\n- $i=1, s_1=\\mathrm{C}$: $\\frac{W(\\mathrm{C},1)}{q(\\mathrm{C})} = \\frac{0.10}{0.20} = \\frac{1}{2}$\n- $i=2, s_2=\\mathrm{T}$: $\\frac{W(\\mathrm{T},2)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=3, s_3=\\mathrm{G}$: $\\frac{W(\\mathrm{G},3)}{q(\\mathrm{G})} = \\frac{0.60}{0.20} = 3$\n- $i=4, s_4=\\mathrm{G}$: $\\frac{W(\\mathrm{G},4)}{q(\\mathrm{G})} = \\frac{0.20}{0.20} = 1$\n- $i=5, s_5=\\mathrm{C}$: $\\frac{W(\\mathrm{C},5)}{q(\\mathrm{C})} = \\frac{0.60}{0.20} = 3$\n- $i=6, s_6=\\mathrm{G}$: $\\frac{W(\\mathrm{G},6)}{q(\\mathrm{G})} = \\frac{0.10}{0.20} = \\frac{1}{2}$\n- $i=7, s_7=\\mathrm{T}$: $\\frac{W(\\mathrm{T},7)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=8, s_8=\\mathrm{A}$: $\\frac{W(\\mathrm{A},8)}{q(\\mathrm{A})} = \\frac{0.60}{0.30} = 2$\n- $i=9, s_9=\\mathrm{T}$: $\\frac{W(\\mathrm{T},9)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=10, s_{10}=\\mathrm{C}$: $\\frac{W(\\mathrm{C},10)}{q(\\mathrm{C})} = \\frac{0.10}{0.20} = \\frac{1}{2}$\n- $i=11, s_{11}=\\mathrm{A}$: $\\frac{W(\\mathrm{A},11)}{q(\\mathrm{A})} = \\frac{0.60}{0.30} = 2$\n- $i=12, s_{12}=\\mathrm{T}$: $\\frac{W(\\mathrm{T},12)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n$S_2$ 的似然比是以下乘积：\n$$\nLR(S_2) = \\left(\\frac{1}{2}\\right)^3 \\cdot \\left(\\frac{7}{3}\\right)^4 \\cdot (3)^2 \\cdot (1)^1 \\cdot (2)^2 = \\frac{1}{2^3} \\cdot \\frac{7^4}{3^4} \\cdot 3^2 \\cdot 1 \\cdot 2^2 = \\frac{7^4 \\cdot 3^2 \\cdot 2^2}{2^3 \\cdot 3^4} = \\frac{7^4}{2 \\cdot 3^2}\n$$\n\n最后，我们计算起始速率的比率：\n$$\n\\frac{R_1}{R_2} = \\frac{LR(S_1)}{LR(S_2)} = \\frac{\\frac{7^6 \\cdot 2^4}{3^4}}{\\frac{7^4}{2 \\cdot 3^2}} = \\frac{7^6 \\cdot 2^4}{3^4} \\cdot \\frac{2 \\cdot 3^2}{7^4}\n$$\n$$\n\\frac{R_1}{R_2} = 7^{(6-4)} \\cdot 2^{(4+1)} \\cdot 3^{(2-4)} = 7^2 \\cdot 2^5 \\cdot 3^{-2} = \\frac{7^2 \\cdot 2^5}{3^2} = \\frac{49 \\cdot 32}{9} = \\frac{1568}{9}\n$$\n现在，我们将这个分数转换为小数值：\n$$\n\\frac{1568}{9} \\approx 174.2222...\n$$\n问题要求将答案四舍五入到四位有效数字。前四位有效数字是$1$、$7$、$4$和$2$。第五位数字是$2$，小于$5$，所以我们向下舍入。\n最终结果是$174.2$。", "answer": "$$\n\\boxed{174.2}\n$$", "id": "4599016"}, {"introduction": "随着基因组测序数据的爆炸式增长，自动化地识别和注释基因结构成为一项关键挑战。这个高级练习将引导您进入计算基因组学的核心领域，使用隐马尔可夫模型 (Hidden Markov Model, HMM) 来解决这一问题。您需要将一个基因看作是由不同功能元件（如外显子、内含子、UTR等）组成的“隐藏”状态序列，并实现经典的维特比 (Viterbi) 算法，从原始的DNA序列中解码出最有可能的基因结构。这不仅是一次编程挑战，更是一次深入理解基因语法和计算建模思想的实践 ([@problem_id:4599035])。", "problem": "您需要实现一个完整的、可运行的程序，该程序对给定的脱氧核糖核酸（DNA）序列执行考虑剪接的隐马尔可夫模型（HMM）的维特比解码，以推断最可能的基因模型。该模型反映了一种简化的真核基因结构，包含以下状态：基因间区、启动子、5' 非翻译区、外显子、内含子和 3' 非翻译区。解码过程必须利用局部序列上下文，整合剪接供体和受体位点的边界基序偏好。解决方案必须从分子生物学中心法则的基本原理和隐马尔可夫模型的定义推导得出。\n\n定义与模型假设：\n- 分子生物学中心法则指出，信息流向为脱氧核糖核酸（DNA）到核糖核酸（RNA）再到蛋白质。在真核生物中，基因包含外显子和内含子；内含子通过剪接过程被移除，而剪接供体和受体基序通常在内含子边界附近富集。\n- 隐马尔可夫模型（HMM）由一个有限的隐藏状态集、一个初始状态分布、一个状态转移概率矩阵以及在一个观测字母表上的发射分布组成。在马尔可夫假设和条件独立性假设下，状态序列和观测序列的联合概率可以分解为初始因子、转移因子和发射因子的乘积。\n- 此处，模型使用一个边界基序因子，在外显子和内含子状态之间转换时，该因子会与转移概率相乘，以反映供体和受体的共有模式；该因子取决于边界周围的相邻观测符号。\n\n状态空间与编码：\n- 输出时，状态被编码为整数：基因间区为 $0$，启动子为 $1$，5' 非翻译区为 $2$，外显子为 $3$，内含子为 $4$，3' 非翻译区为 $5$。\n\n观测与字母表：\n- 观测字母表是核苷酸集合 {A, C, G, T}。将它们映射到索引如下：A $\\rightarrow$ $0$，C $\\rightarrow$ $1$，G $\\rightarrow$ $2$，T $\\rightarrow$ $3$。\n\n模型参数：\n- 设初始分布为 $\\pi \\in \\mathbb{R}^6$，其非零项为 $\\pi_0 = 0.98$ 和 $\\pi_1 = 0.02$，对于所有其他状态 $s$，$\\pi_s = 0$。所有数值均为概率，因此它们位于 $[0,1]$ 区间内且总和为 $1$。\n- 设状态转移概率矩阵为 $A \\in \\mathbb{R}^{6 \\times 6}$，其行由前一状态索引，列由下一状态索引。非零转移如下：\n  - 从基因间区 $0$：到 $0$ 的概率为 $0.995$，到 $1$ 的概率为 $0.005$。\n  - 从启动子 $1$：到 $1$ 的概率为 $0.90$，到 $2$ 的概率为 $0.10$。\n  - 从 5' 非翻译区 $2$：到 $2$ 的概率为 $0.85$，到 $3$ 的概率为 $0.15$。\n  - 从外显子 $3$：到 $3$ 的概率为 $0.90$，到 $4$ 的概率为 $0.08$，到 $5$ 的概率为 $0.02$。\n  - 从内含子 $4$：到 $4$ 的概率为 $0.92$，到 $3$ 的概率为 $0.08$。\n  - 从 3' 非翻译区 $5$：到 $5$ 的概率为 $0.90$，到 $0$ 的概率为 $0.10$。\n  - 所有其他转移的概率为 $0$。\n- 设发射概率矩阵为 $B \\in \\mathbb{R}^{6 \\times 4}$，其行对应状态，列对应核苷酸（顺序为 [A, C, G, T]）。按状态划分的发射概率如下：\n  - 基因间区 $0$：$[0.30, 0.20, 0.20, 0.30]$。\n  - 启动子 $1$：$[0.40, 0.10, 0.10, 0.40]$。\n  - 5' 非翻译区 $2$：$[0.35, 0.15, 0.15, 0.35]$。\n  - 外显子 $3$：$[0.20, 0.30, 0.30, 0.20]$。\n  - 内含子 $4$：$[0.35, 0.15, 0.15, 0.35]$。\n  - 3' 非翻译区 $5$：$[0.35, 0.15, 0.15, 0.35]$。\n- 考虑剪接的边界基序因子：对于在位置 $t-1$ 的状态 $s'$ 到位置 $t$ 的状态 $s$ 的转移，定义一个乘法边界因子 $g(s', s, x_{t-1}, x_t)$：\n  - 如果 $(s', s) = (3, 4)$（外显子到内含子），则当 $(x_{t-1}, x_t) = (\\text{G}, \\text{T})$ 时 $g = 0.9$，否则 $g = 0.1$。\n  - 如果 $(s', s) = (4, 3)$（内含子到外显子），则当 $(x_{t-1}, x_t) = (\\text{A}, \\text{G})$ 时 $g = 0.9$，否则 $g = 0.1$。\n  - 对于所有其他的 $(s', s)$， $g = 1.0$。\n\n推导目标：\n- 根据 HMM 的定义和马尔可夫性质，推导出一个动态规划递推关系，用于在给定观测序列 $x_{1:T}$ 和上述分解式的情况下，得出最可能的状态序列 $y_{1:T}$。为避免数值下溢，请在对数域（使用自然对数）中进行计算。该递推关系应最大化初始对数、转移对数、发射对数和边界对数因子之和，并存储回溯指针以恢复最优路径。\n\n计算任务：\n- 实现所推导的维特比算法，该算法需按上文规定整合边界基序因子 $g(\\cdot)$。您的实现必须为每个测试序列计算出最可能的状态序列 $y_{1:T}$。\n\n测试集：\n- 使用以下三个脱氧核糖核酸序列作为测试集：\n  1. CGCGTTTATAAAATATCCGTTTAGCCATATCG\n  2. GGCGTATATAATATGCCGCCATATTT\n  3. ATTATAATACGTAAGAT\n- 对于每个序列，程序应返回一个整数编码的状态路径，形式为一个整数列表，其长度与序列长度相等。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个解码状态列表，按测试集序列的顺序排列，形式为用方括号括起来的逗号分隔列表。输出格式必须为：一个包含三个整数列表的列表，例如，类似于 \"[[a,b,c,...],[...],[...]]\" 的形式，其中每个内部列表的长度等于相应序列的长度。除此单行外，不允许有任何额外的文本或空白字符。", "solution": "我们基于隐马尔可夫模型（HMM）的定义和概率链式法则，并结合马尔可夫性质以及给定状态下发射的条件独立性来进行推导。设观测序列为 $x_{1:T}$，有 $T$ 个位置，隐藏状态序列为 $y_{1:T}$，其中 $y_t \\in \\{0,1,2,3,4,5\\}$。标准的 HMM 联合概率分解式为\n$$\np(y_{1:T}, x_{1:T}) = \\pi_{y_1} \\cdot b_{y_1}(x_1) \\cdot \\prod_{t=2}^{T} a_{y_{t-1}, y_t} \\cdot b_{y_t}(x_t),\n$$\n其中 $\\pi_s$ 是初始概率，$a_{i,j}$ 是转移概率，$b_s(x)$ 是发射概率。\n\n为了整合考虑剪接的边界偏好，我们引入一个边界因子 $g(y_{t-1}, y_t, x_{t-1}, x_t)$，该因子在每一步与转移概率相乘，以增加可能的供体和受体基序的权重，从而得到一个广义分解式：\n$$\np(y_{1:T}, x_{1:T}) = \\pi_{y_1} \\cdot b_{y_1}(x_1) \\cdot \\prod_{t=2}^{T} \\left[ a_{y_{t-1}, y_t} \\cdot g(y_{t-1}, y_t, x_{t-1}, x_t) \\cdot b_{y_t}(x_t) \\right].\n$$\n边界因子 $g$ 的定义如下：当 $(y_{t-1}, y_t) = (3, 4)$ 且 $(x_{t-1}, x_t) = (\\text{G}, \\text{T})$ 时（供体兼容对），$g=0.9$；或者当 $(y_{t-1}, y_t) = (4, 3)$ 且 $(x_{t-1}, x_t) = (\\text{A}, \\text{G})$ 时（受体兼容对），$g=0.9$；对于这些外显子-内含子转换转移，其他情况下 $g=0.1$；对于所有其他转移，$g=1.0$。这维持了仅对 $(x_{t-1}, x_t)$ 的局部依赖性，因此动态规划仍然有效，因为在时间 $t$ 的每个因子仅依赖于 $(y_{t-1}, y_t)$ 和相邻的观测值。\n\n我们寻求最大化因子\n$$\n\\hat{y}_{1:T} = \\arg\\max_{y_{1:T}} \\; p(y_{1:T}, x_{1:T}).\n$$\n由于概率的乘积可能导致数值下溢，我们在对数概率域中工作，将乘积转换为和。定义\n$$\n\\ell_{\\pi}(s) = \\log \\pi_s,\\quad \\ell_a(i,j) = \\log a_{i,j},\\quad \\ell_b(s,x) = \\log b_s(x),\\quad \\ell_g(i,j,x',x) = \\log g(i,j,x',x).\n$$\n设动态规划表为\n$$\n\\delta_t(s) = \\max_{y_{1:t-1}} \\log \\left[ \\pi_{y_1} b_{y_1}(x_1) \\prod_{k=2}^{t} a_{y_{k-1}, y_k} \\, g(y_{k-1}, y_k, x_{k-1}, x_k) \\, b_{y_k}(x_k) \\right],\n$$\n这是在时间 $t$ 以状态 $s$ 结束的路径的最大对数概率。$t=1$ 时的初始化为\n$$\n\\delta_1(s) = \\ell_{\\pi}(s) + \\ell_b(s, x_1),\n$$\n对于 $t \\ge 2$ 的递推关系为\n$$\n\\delta_t(s) = \\max_{s' \\in \\{0,\\dots,5\\}} \\left[ \\delta_{t-1}(s') + \\ell_a(s', s) + \\ell_g(s', s, x_{t-1}, x_t) + \\ell_b(s, x_t) \\right].\n$$\n为了恢复最大化状态路径，我们存储回溯指针\n$$\n\\psi_t(s) = \\arg\\max_{s' \\in \\{0,\\dots,5\\}} \\left[ \\delta_{t-1}(s') + \\ell_a(s', s) + \\ell_g(s', s, x_{t-1}, x_t) \\right],\n$$\n然后执行回溯：\n- 令 $y_T = \\arg\\max_{s} \\delta_T(s)$。\n- 对于从 $T$ 递减到 $2$ 的 $t$，设置 $y_{t-1} = \\psi_t(y_t)$。\n\n结果 $\\hat{y}_{1:T}$ 是该模型下最可能的序列。\n\n算法设计细节：\n- 不允许的转移具有 $a_{i,j} = 0$，这映射到 $\\ell_a(i,j) = -\\infty$；这些转移在最大化过程中被排除。\n- 观测字母表被映射到索引 $\\{0,1,2,3\\}$，即 A $\\rightarrow$ $0$，C $\\rightarrow$ $1$，G $\\rightarrow$ $2$，T $\\rightarrow$ $3$，$这样 \\ell_b(s, x_t)$ 就可以通过数组索引来访问。\n- 计算在自然对数域中进行，使用 $-\\infty$ 表示 $\\log 0$；标准的浮点处理允许 $\\max$ 操作忽略 $-\\infty$ 项。\n- 边界因子 $\\ell_g$ 是根据 $(x_{t-1}, x_t)$ 为每个候选转移计算的，该值在更新 $\\delta_t(s)$ 时是可用的，从而保留了动态规划的结构。\n\n科学依据：\n- 中心法则和已知的真核基因结构为基因间区、启动子、非翻译区、外显子和内含子等状态的设定提供了动机。\n- HMM 形式体系通过发射分布捕捉了这些状态之间的随机转换以及每个状态中的核苷酸组成偏好。\n- 通过边界因子 $g$ 调节外显子-内含子边界处的转移似然，从而整合了剪接供体和受体的共有基序，并保持了局部性，使得维特比递推仍然有效。\n\n应用此推导，实现过程如下：\n- 使用指定的数值定义 $\\pi$、$A$、$B$ 以及边界因子函数 $g$。\n- 为每个测试序列实现带有回溯指针的对数域维特比算法。\n- 使用从 $0$ 到 $5$ 的整数编码，并以指定的单行输出格式返回解码后的状态序列。\n\n测试集包含三个序列。对于每个序列，算法输出一个整数列表，其长度与序列长度相等，表示每个位置上最可能的状态。最终输出是一个单行，包含这三个列表的列表，用逗号分隔并用方括号括起来，无任何额外文本。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# State indices\nIG, PR, U5, EX, IN, U3 = 0, 1, 2, 3, 4, 5\n\n# Alphabet mapping\nalphabet = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\ndef log_safe(x):\n    \"\"\"Return natural log, handling zeros as -inf.\"\"\"\n    with np.errstate(divide='ignore'):\n        return np.log(x)\n\ndef boundary_log_factor(prev_state, curr_state, prev_char, curr_char):\n    \"\"\"\n    Compute log boundary factor given states and adjacent observed symbols.\n    Splice-aware factors:\n      - EX->IN prefers GT across boundary (prev_char='G', curr_char='T').\n      - IN->EX prefers AG across boundary (prev_char='A', curr_char='G').\n    All other transitions have factor 1.0.\n    \"\"\"\n    if prev_state == EX and curr_state == IN:\n        if prev_char == 'G' and curr_char == 'T':\n            return np.log(0.9)\n        else:\n            return np.log(0.1)\n    elif prev_state == IN and curr_state == EX:\n        if prev_char == 'A' and curr_char == 'G':\n            return np.log(0.9)\n        else:\n            return np.log(0.1)\n    else:\n        return 0.0  # log(1.0)\n\ndef viterbi_decode(seq, pi, A, B):\n    \"\"\"\n    Viterbi decoding with boundary motif factors.\n    seq: string of nucleotides\n    pi: (S,) initial probabilities\n    A: (S,S) transition probabilities\n    B: (S,4) emission probabilities for A,C,G,T\n    Returns: list of state indices\n    \"\"\"\n    S = pi.shape[0]\n    T = len(seq)\n    # Map sequence to indices\n    obs = np.array([alphabet[ch] for ch in seq], dtype=int)\n\n    # Precompute logs\n    log_pi = log_safe(pi)\n    log_A = log_safe(A)\n    log_B = log_safe(B)\n\n    # Initialize DP tables\n    delta = np.full((T, S), -np.inf, dtype=float)\n    psi = np.full((T, S), -1, dtype=int)\n\n    # Initialization at t=0\n    for s in range(S):\n        if log_pi[s] > -np.inf and log_B[s, obs[0]] > -np.inf:\n            delta[0, s] = log_pi[s] + log_B[s, obs[0]]\n            psi[0, s] = -1  # start\n        else:\n            delta[0, s] = -np.inf\n            psi[0, s] = -1\n\n    # Recursion\n    for t in range(1, T):\n        curr_char = seq[t]\n        prev_char = seq[t-1]\n        for s in range(S):\n            emit = log_B[s, obs[t]]\n            if emit == -np.inf:\n                # Impossible emission\n                continue\n            best_score = -np.inf\n            best_prev = -1\n            # Consider all previous states\n            for sp in range(S):\n                trans = log_A[sp, s]\n                if trans == -np.inf:\n                    continue\n                bfactor = boundary_log_factor(sp, s, prev_char, curr_char)\n                score = delta[t-1, sp] + trans + bfactor + emit\n                if score > best_score:\n                    best_score = score\n                    best_prev = sp\n            delta[t, s] = best_score\n            psi[t, s] = best_prev\n\n    # Termination\n    last_state = int(np.argmax(delta[T-1, :]))\n    path = [last_state]\n    # Backtrace\n    for t in range(T-1, 0, -1):\n        last_state = psi[t, last_state]\n        if last_state  0:\n            # No valid backpointer; break (should not happen with provided params)\n            last_state = 0\n        path.append(last_state)\n    path.reverse()\n    return path\n\ndef solve():\n    # Define model parameters\n    S = 6\n\n    # Initial distribution\n    pi = np.zeros(S, dtype=float)\n    pi[IG] = 0.98\n    pi[PR] = 0.02\n\n    # Transition matrix\n    A = np.zeros((S, S), dtype=float)\n    # IG -> IG, PR\n    A[IG, IG] = 0.995\n    A[IG, PR] = 0.005\n    # PR -> PR, U5\n    A[PR, PR] = 0.90\n    A[PR, U5] = 0.10\n    # U5 -> U5, EX\n    A[U5, U5] = 0.85\n    A[U5, EX] = 0.15\n    # EX -> EX, IN, U3\n    A[EX, EX] = 0.90\n    A[EX, IN] = 0.08\n    A[EX, U3] = 0.02\n    # IN -> IN, EX\n    A[IN, IN] = 0.92\n    A[IN, EX] = 0.08\n    # U3 -> U3, IG\n    A[U3, U3] = 0.90\n    A[U3, IG] = 0.10\n\n    # Emission matrix B[state, nucleotide_index]\n    B = np.zeros((S, 4), dtype=float)\n    # IG\n    B[IG, :] = [0.30, 0.20, 0.20, 0.30]\n    # PR\n    B[PR, :] = [0.40, 0.10, 0.10, 0.40]\n    # U5\n    B[U5, :] = [0.35, 0.15, 0.15, 0.35]\n    # EX\n    B[EX, :] = [0.20, 0.30, 0.30, 0.20]\n    # IN\n    B[IN, :] = [0.35, 0.15, 0.15, 0.35]\n    # U3\n    B[U3, :] = [0.35, 0.15, 0.15, 0.35]\n\n    # Test suite sequences\n    test_cases = [\n        \"CGCGTTTATAAAATATCCGTTTAGCCATATCG\",\n        \"GGCGTATATAATATGCCGCCATATTT\",\n        \"ATTATAATACGTAAGAT\",\n    ]\n\n    results = []\n    for seq in test_cases:\n        states = viterbi_decode(seq, pi, A, B)\n        results.append(states)\n\n    # Format as a single line: list of lists of integers\n    # Ensure no extra spaces\n    def format_list(lst):\n        return \"[\" + \",\".join(str(int(x)) for x in lst) + \"]\"\n    output = \"[\" + \",\".join(format_list(r) for r in results) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "4599035"}]}