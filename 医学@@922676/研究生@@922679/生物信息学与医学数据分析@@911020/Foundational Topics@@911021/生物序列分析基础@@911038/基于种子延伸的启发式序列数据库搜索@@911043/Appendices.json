{"hands_on_practices": [{"introduction": "种子-延伸搜索的效率在很大程度上取决于初始种子的选择。过短的种子会导致过多的随机命中，而过长的种子则可能错过真正的同源序列。本练习将引导你运用基本概率论，从第一性原理出发计算随机命中次数的期望值，并确定一个合适的种子长度 $k$ 来平衡灵敏度与特异性。[@problem_id:4571633]", "problem": "在序列数据库搜索（例如基本局部比对搜索工具BLAST）中使用的种子-扩展启发式算法中，初始过滤器通过查找来自查询序列的长度为 $k$ 的连续种子与数据库中长度为 $k$ 的窗口之间的精确匹配来扫描数据库。考虑一个长度为 $L$ 的核苷酸查询序列，其字母表 $\\Sigma$ 为四符号字母表，即 $|\\Sigma|=4$；以及一个由独立同分布序列组成的数据库，其中字符是等概率的。假设采用连续精确种子模型，并且查询和数据库是相互独立的。\n\n从概率论的第一性原理（伯努利试验）、均匀随机序列的独立性假设以及期望的线性性质出发，推导当将查询中所有长度为 $k$ 的连续种子与总长度为 $N$ 的数据库中所有长度为 $k$ 的连续窗口进行扫描时，随机种子命中数的期望值 $E(k)$ 的表达式。然后，施加设计要求，即对于 $L=100$，$N=10^{9}$ 和 $|\\Sigma|=4$，$E(k)$ 必须严格小于 $0.1$ 个随机命中，并选择满足此要求的最小整数 $k$。展示完整的推导和计算过程。最终答案必须是单个整数。无需进行四舍五入。", "solution": "首先验证该问题，以确保其具有科学依据、适定性和客观性。\n\n**步骤1：提取已知条件**\n- 启发式算法：用于序列数据库搜索的种子-扩展算法。\n- 过滤器机制：长度为 $k$ 的连续种子之间的精确匹配。\n- 查询序列长度：$L$。\n- 字母表：$\\Sigma$，一个核苷酸字母表。\n- 字母表大小：$|\\Sigma|=4$。\n- 数据库属性：由独立同分布（i.i.d.）的序列组成，字符等概率出现。总长度为 $N$。\n- 模型：连续精确种子模型。\n- 独立性假设：查询和数据库是独立的。\n- 任务1：推导随机种子命中数的期望值 $E(k)$ 的表达式。\n- 任务2：施加设计要求 $E(k)  0.1$。\n- 特定参数：$L=100$，$N=10^{9}$。\n- 任务3：找到满足要求的最小整数 $k$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题牢固地植根于生物信息学算法的统计基础，特别是广泛使用的BLAST启发式算法。随机序列模型和期望命中数的计算是该领域的标准基本概念。\n- **适定性**：该问题是适定的。它提供了所有必要的参数（$L$、$N$、$|\\Sigma|$）和一个明确的目标（推导 $E(k)$ 并在给定阈值下找到最小整数 $k$）。独立同分布和等概率字符的假设创建了一个可形式化的概率模型，该模型允许唯一解。\n- **客观性**：该问题以精确、客观和技术性的语言陈述，没有歧义或主观论断。\n\n**步骤3：结论与行动**\n该问题是有效的。它是计算生物学中一个标准的、定义明确的问题。将提供一个完整的、合理的解决方案。\n\n**命中数期望值 $E(k)$ 的推导**\n\n我们的目标是推导查询序列中长度为 $k$ 的连续种子在数据库中精确出现的期望次数。我们将使用期望的线性性质原理。\n\n设查询序列的长度为 $L$，数据库的总长度为 $N$。\n查询中长度为 $k$ 的可能连续种子数量为 $L - k + 1$。\n数据库中长度为 $k$ 的可能连续窗口数量为 $N - k + 1$。\n\n让我们定义一个指示随机变量 $X_{ij}$，用于比较查询的第 $i$ 个种子（从位置 $i$ 开始）和数据库的第 $j$ 个窗口（从位置 $j$ 开始）。\n如果第 $i$ 个查询种子与第 $j$ 个数据库窗口匹配，则 $X_{ij} = 1$。\n否则 $X_{ij} = 0$。\n下标范围为 $i=1, \\dots, L-k+1$ 和 $j=1, \\dots, N-k+1$。\n\n总命中数 $H$ 是这些指示变量在所有可能的查询种子和数据库窗口对上的总和：\n$$H = \\sum_{i=1}^{L-k+1} \\sum_{j=1}^{N-k+1} X_{ij}$$\n\n根据期望的线性性质，总命中数的期望值 $E(k) = E[H]$ 为：\n$$E(k) = E\\left[\\sum_{i=1}^{L-k+1} \\sum_{j=1}^{N-k+1} X_{ij}\\right] = \\sum_{i=1}^{L-k+1} \\sum_{j=1}^{N-k+1} E[X_{ij}]$$\n\n指示随机变量的期望是其所指示事件的概率：$E[X_{ij}] = P(X_{ij} = 1)$。这是来自查询的特定 $k$-mer 种子与来自数据库的特定 $k$-mer 窗口匹配的概率。\n\n如果所有 $k$ 个字符完全对齐，则发生匹配。设 $p_m$ 为单个位置上匹配的概率。假设字符位置之间相互独立，则一个 $k$-mer 匹配的概率为 $p_m^k$。\n\n问题陈述数据库字符是独立同分布的，并且在大小为 $|\\Sigma|=4$ 的字母表上是等概率的。设字母表为 $\\{\\text{A, C, G, T}\\}$。数据库中任何位置出现任何特定字符的概率为 $P(\\text{db\\_char}) = \\frac{1}{|\\Sigma|} = \\frac{1}{4}$。\n问题描述了“均匀随机序列”的搜索背景，这意味着为了计算随机背景命中，查询的统计特性可以被同样地建模。因此，查询中任何位置任何特定字符的概率也为 $P(\\text{query\\_char}) = \\frac{1}{4}$。\n\n单个位置匹配的概率 $p_m$ 是查询字符和数据库字符相同的概率。由于查询和数据库是独立的，这个概率是：\n$$p_m = \\sum_{c \\in \\Sigma} P(\\text{query\\_char}=c \\text{ and } \\text{db\\_char}=c)$$\n$$p_m = \\sum_{c \\in \\Sigma} P(\\text{query\\_char}=c) \\cdot P(\\text{db\\_char}=c) = \\sum_{i=1}^{4} \\left(\\frac{1}{4} \\cdot \\frac{1}{4}\\right) = 4 \\cdot \\frac{1}{16} = \\frac{1}{4}$$\n\n因此，一个长度为 $k$ 的特定查询种子与一个长度为 $k$ 的特定数据库窗口匹配的概率是：\n$$P(X_{ij} = 1) = (p_m)^k = \\left(\\frac{1}{4}\\right)^k = 4^{-k}$$\n由于这个概率对于所有的配对 $(i, j)$ 都是相同的，我们可以将其代回 $E(k)$ 的表达式中：\n$$E(k) = \\sum_{i=1}^{L-k+1} \\sum_{j=1}^{N-k+1} 4^{-k}$$\n这个和是对 $(L-k+1)(N-k+1)$ 个相同项求和。\n$$E(k) = (L-k+1)(N-k+1)4^{-k}$$\n这就是推导出的随机种子命中数的期望值表达式。\n\n对于典型应用，$k$ 远小于 $L$ 和 $N$。因此，我们可以使用精确的近似 $L-k+1 \\approx L$ 和 $N-k+1 \\approx N$。\n$$E(k) \\approx L \\cdot N \\cdot 4^{-k}$$\n\n**计算最小整数 $k$**\n\n我们给定的设计要求是 $E(k)  0.1$，参数为 $L=100$，$N=10^9$ 和 $|\\Sigma|=4$。\n使用 $E(k)$ 的近似公式：\n$$100 \\cdot 10^9 \\cdot 4^{-k}  0.1$$\n$$10^2 \\cdot 10^9 \\cdot 4^{-k}  10^{-1}$$\n$$10^{11} \\cdot 4^{-k}  10^{-1}$$\n为了求解 $k$，我们整理不等式：\n$$10^{11}  10^{-1} \\cdot 4^k$$\n$$10^{12}  4^k$$\n\n为了求 $k$，我们对两边取以10为底的对数：\n$$\\log_{10}(10^{12})  \\log_{10}(4^k)$$\n$$12  k \\cdot \\log_{10}(4)$$\n$$k > \\frac{12}{\\log_{10}(4)}$$\n\n我们知道 $\\log_{10}(4) = \\log_{10}(2^2) = 2 \\log_{10}(2)$。$\\log_{10}(2)$ 的值约等于 $0.30103$。\n$$k > \\frac{12}{2 \\log_{10}(2)} = \\frac{6}{\\log_{10}(2)}$$\n$$k > \\frac{6}{0.30103} \\approx 19.9315$$\n\n由于 $k$ 必须是整数，满足此条件的最小整数值是 $20$。\n\n让我们用我们的近似值来检验 $k=19$ 和 $k=20$ 的情况，以验证这个结果。\n对于 $k=19$：\n$E(19) \\approx 10^{11} \\cdot 4^{-19} = \\frac{10^{11}}{274877906944} \\approx \\frac{10^{11}}{2.75 \\times 10^{11}} \\approx 0.364$，不小于 $0.1$。\n对于 $k=20$：\n$E(20) \\approx 10^{11} \\cdot 4^{-20} = \\frac{10^{11}}{1099511627776} \\approx \\frac{10^{11}}{1.10 \\times 10^{12}} \\approx 0.091$，小于 $0.1$。\n\n计算证实了最小整数种子长度 $k$ 是 $20$。使用近似公式 $E(k) \\approx L \\cdot N \\cdot 4^{-k}$ 是合理的，因为修正因子 $(L-k+1)/L$ 和 $(N-k+1)/N$ 非常接近于 $1$，并且不会改变最终的整数结果。\n对于 $k=20$，$L-k+1 = 100-20+1 = 81$。精确期望值为 $E(20) = (81)(10^9-19)4^{-20} \\approx 81 \\cdot 10^9 \\cdot (1.10 \\times 10^{12})^{-1} \\approx 0.0737$，也小于 $0.1$。\n对于 $k=19$，$L-k+1=100-19+1 = 82$。精确期望值为 $E(19) = (82)(10^9-18)4^{-19} \\approx 82 \\cdot 10^9 \\cdot (2.75 \\times 10^{11})^{-1} \\approx 0.298$，不小于 $0.1$。\n因此，确认最小整数 $k$ 为 $20$。", "answer": "$$\\boxed{20}$$", "id": "4571633"}, {"introduction": "找到一个有潜力的种子后，下一步是将其延伸以寻找一个高分片段对（HSP）。本练习将逐步演示经典的无空位延伸算法，并引入关键的“X-drop”启发式规则，该规则能有效防止延伸进入低匹配质量的区域。通过这个练习，你将清楚地了解一个简单的种子匹配是如何被拓展成一个有意义的局部比对的。[@problem_id:4571668]", "problem": "考虑一种用于序列数据库搜索的无空位（ungapped）种子扩展启发式算法，该算法在基础局部比对搜索工具（BLAST）中使用，其中扩展从一个精确匹配的种子开始，不引入空位，并根据“X-drop”规则停止。设查询序列为 Q = TTGCAACGTAATACGTTGCA，数据库序列为 D = GACAAACGTAAGTACGTTCA，两者都从位置 $1$ 开始索引。给定在位置 $(i,j)=(7,7)$ 处有一个长度为 $k=4$ 的精确种子，因此 $Q[7..10]=D[7..10]$。请使用以下经过充分检验的种子扩展评分基础：\n- 将无空位成对比对分数定义为在所有比对位置上的位置分数 $s(x,y)$ 的总和，其中如果核苷酸 $x$ 和 $y$ 匹配，则 $s(x,y)=+1$，如果它们错配，则 $s(x,y)=-2$。\n- 种子贡献其精确匹配分数，扩展从种子的左侧和右侧每次进行一个位置。对于每个方向，维护一个当前扩展分数和一个该方向的迄今为止最佳分数。参数为 $X=3$ 的 X-drop 终止规则分别应用于每一侧：当给定方向的当前扩展分数比该侧的迄今为止最佳分数低 $X$ 以上时，该方向的扩展停止。高分片段对（HSP）的边界取在每个方向上达到迄今为止最佳分数的位置。\n\n从位置 $(i,j)=(7,7)$、长度为 $k=4$ 的种子开始，计算在应用上述评分方案和 X-drop 参数 $X=3$ 的无空位种子扩展后获得的总 HSP 分数。将最终答案表示为单个整数。无需四舍五入，也无需报告单位。", "solution": "用户希望在给定查询序列、数据库序列、一个种子、一种评分方案和一条 X-drop 终止规则的情况下，计算由无空位种子扩展启发式算法生成的高分片段对（HSP）的总分。\n\n首先验证该问题以确保其科学性、适定性和客观性。\n已知条件如下：\n- 查询序列 $Q = \\text{TTGCAACGTAATACGTTGCA}$\n- 数据库序列 $D = \\text{GACAAACGTAAGTACGTTCA}$\n- 两个序列都是从 $1$ 开始索引的。\n- 在位置 $(i,j)=(7,7)$ 处确定了一个长度为 $k=4$ 的种子，对应于 $Q[7..10]$ 和 $D[7..10]$。我们来验证一下：$Q[7..10]=\\text{CGTA}$ 且 $D[7..10]=\\text{CGTA}$。这确实是一个精确匹配。\n- 评分方案：匹配得分 $s_{match} = +1$，错配罚分 $s_{mismatch} = -2$。\n- 终止规则：参数为 $X=3$ 的 X-drop 规则。当某个方向的当前扩展分数比该方向迄今为止达到的最高分数低 $X$ 以上时，该方向的扩展停止。\n\n该问题是 BLAST 种子扩展算法的一个标准应用。所有参数都已提供，在模型背景下前提条件是事实正确的，并且过程是确定性的。因此，该问题是有效的。\n\nHSP 的总分是种子分数与向左和向右扩展的最佳分数之和。\n\n**1. 种子分数**\n种子是一个长度为 $k=4$ 的精确匹配。每次匹配的得分为 $+1$。种子的分数 $S_{seed}$ 为：\n$$S_{seed} = 4 \\times s_{match} = 4 \\times (+1) = 4$$\n\n**2. 向右扩展**\n扩展从种子的末端开始，即从位置 $(i,j)=(11,11)$ 开始。我们为此扩展维护一个当前分数 $S_{run,R}$ 和一个最佳分数 $S_{best,R}$，两者都初始化为 $0$。如果 $S_{run,R}  S_{best,R} - X$（其中 $X=3$），则扩展停止。\n\n| 步骤 | 查询位置 $i$ | 数据库位置 $j$ | $Q[i]$ vs $D[j]$ | 配对分数 $s$ | $S_{run,R}$ | $S_{best,R}$ | 终止条件：$S_{run,R}  S_{best,R} - 3$ |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| 开始 | - | - | - | - | $0$ | $0$ | - |\n| $1$ | $11$ | $11$ | A vs A (匹配) | $+1$ | $0+1=1$ | $\\max(0,1)=1$ | $1 \\not 1 - 3$，继续 |\n| $2$ | $12$ | $12$ | T vs G (错配) | $-2$ | $1-2=-1$ | $\\max(1,-1)=1$ | $-1 \\not 1 - 3$，继续 |\n| $3$ | $13$ | $13$ | A vs T (错配) | $-2$ | $-1-2=-3$ | $\\max(1,-3)=1$ | $-3  1 - 3 \\implies -3  -2$，**停止** |\n\n在向右扩展期间获得的最大分数为 $S_{best,R} = 1$。右侧的 HSP 边界是达到此最佳分数的位置，即 $(i,j)=(11,11)$。\n\n**3. 向左扩展**\n扩展从种子的起始处开始，即从位置 $(i,j)=(6,6)$ 向后进行。我们为此扩展维护一个当前分数 $S_{run,L}$ 和一个最佳分数 $S_{best,L}$，两者都初始化为 $0$。如果 $S_{run,L}  S_{best,L} - X$，则扩展停止。\n\n| 步骤 | 查询位置 $i$ | 数据库位置 $j$ | $Q[i]$ vs $D[j]$ | 配对分数 $s$ | $S_{run,L}$ | $S_{best,L}$ | 终止条件：$S_{run,L}  S_{best,L} - 3$ |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| 开始 | - | - | - | - | $0$ | $0$ | - |\n| $1$ | $6$ | $6$ | A vs A (匹配) | $+1$ | $0+1=1$ | $\\max(0,1)=1$ | $1 \\not 1-3$，继续 |\n| $2$ | $5$ | $5$ | A vs A (匹配) | $+1$ | $1+1=2$ | $\\max(1,2)=2$ | $2 \\not 2-3$，继续 |\n| $3$ | $4$ | $4$ | C vs A (错配) | $-2$ | $2-2=0$ | $\\max(2,0)=2$ | $0 \\not 2-3$，继续 |\n| $4$ | $3$ | $3$ | G vs C (错配) | $-2$ | $0-2=-2$ | $\\max(2,-2)=2$ | $-2 \\not 2-3$，继续 |\n| $5$ | $2$ | $2$ | T vs A (错配) | $-2$ | $-2-2=-4$ | $\\max(2,-4)=2$ | $-4  2-3 \\implies -4  -1$，**停止** |\n\n在向左扩展期间获得的最大分数为 $S_{best,L} = 2$。左侧的 HSP 边界是达到此最佳分数的位置，这发生在 $(i,j)=(5,5)$ 处的比较之后。\n\n**4. HSP 总分**\nHSP 的总分是种子分数与两次扩展的最佳分数之和。\n$$S_{HSP} = S_{seed} + S_{best,L} + S_{best,R}$$\n代入计算出的值：\n$$S_{HSP} = 4 + 2 + 1 = 7$$\n\n另外，我们可以确定完整的 HSP 并直接对其评分。HSP 从左边界 $(i,j)=(5,5)$ 延伸到右边界 $(i,j)=(11,11)$。比对的片段是 $Q[5..11]$ 对 $D[5..11]$。\n- $Q[5..11] = \\text{AACGTAA}$\n- $D[5..11] = \\text{AACGTAA}$\n该比对是一个长度为 $7$ 的完美匹配。分数为 $7 \\times s_{match} = 7 \\times (+1) = 7$。\n两种方法得出相同的结果。HSP 的总分是 $7$。", "answer": "$$\\boxed{7}$$", "id": "4571668"}, {"introduction": "无空位延伸虽然快速，但生物序列比对中常含有插入和缺失，这要求算法能够处理空位。这个高级练习模拟了带空位的延伸算法，它将仿射空位罚分的动态规划与 X-drop 终止规则相结合以提高效率。通过完成这个练习，你将深入了解现代序列比对工具核心计算引擎的运作机制。[@problem_id:4571651]", "problem": "你的任务是实现一个用于种子扩展序列数据库搜索的启发式有空位延伸程序。该延伸使用一种锚定局部比对动态规划方案，该方案采用仿射空位罚分和 $X$-drop 终止启发式。从序列开头的固定种子开始，你将只向右延伸，并根据 $X$-drop 准则确定终止发生的基于零的列索引。所有序列都基于核苷酸字母表，所有位置都以基于零的格式进行索引。\n\n基本基础和评分：延伸必须基于标准的带仿射空位的锚定局部比对。设查询序列为 $Q$，长度为 $n$，主题（数据库）序列为 $S$，长度为 $m$，种子是在 $Q$ 的位置 $i_0 = 0$ 和 $S$ 的位置 $j_0 = 0$ 处长度为 $k$ 的连续精确匹配。延伸在种子之后立即开始，因此要比对的后缀是 $Q_r = Q[k:n]$ 和 $S_r = S[k:m]$，其长度分别为 $n_r = n - k$ 和 $m_r = m - k$。使用仿射空位模型，匹配得分为 $+2$，错配罚分为 $-3$，空位开放罚分为 $-5$，空位延伸罚分为 $-1$。$X$-drop 阈值为 $X = 20$。\n\n锚定仿射空位动态规划：在由 $(i,j)$ 索引的延伸网格上定义三个得分矩阵，其中 $i \\in \\{0,\\ldots,n_r\\}$ 且 $j \\in \\{0,\\ldots,m_r\\}$：\n- $M_{i,j}$ 用于连续比对的碱基对（匹配或错配），\n- $I^x_{i,j}$ 用于主题序列中的空位（查询序列中的插入），以及\n- $I^y_{i,j}$ 用于查询序列中的空位（主题序列中的插入）。\n\n在种子末端使用锚定条件进行初始化：\n- $M_{0,0} = 0$，\n- $I^x_{0,0} = -\\infty$，\n- $I^y_{0,0} = -\\infty$。\n\n边界条件：\n- 对于 $j = 0$ 和 $i > 0$，$M_{i,0} = -\\infty$，$I^y_{i,0} = -\\infty$，并且 $I^x_{i,0}$ 通过沿 $i$ 方向的空位延伸进行传播：\n$$I^x_{i,0} = \\max\\left(M_{i-1,0} + g_o + g_e,\\; I^x_{i-1,0} + g_e\\right),$$\n其中 $g_o = -5$，$g_e = -1$。\n- 对于 $i = 0$ 和 $j > 0$，$M_{0,j} = -\\infty$，$I^x_{0,j} = -\\infty$，并且 $I^y_{0,j}$ 通过沿 $j$ 方向的空位延伸进行传播：\n$$I^y_{0,j} = \\max\\left(M_{0,j-1} + g_o + g_e,\\; I^y_{0,j-1} + g_e\\right).$$\n\n对于 $i > 0$ 和 $j > 0$，递推关系为：\n- 令 $s(q_i, s_j)$ 在 $Q_r[i-1] = S_r[j-1]$ 时为 $+2$，否则为 $-3$。则\n$$M_{i,j} = \\max\\left(M_{i-1,j-1},\\; I^x_{i-1,j-1},\\; I^y_{i-1,j-1}\\right) + s(q_i, s_j).$$\n- 主题序列中的空位（查询序列中的插入）：\n$$I^x_{i,j} = \\max\\left(M_{i-1,j} + g_o + g_e,\\; I^x_{i-1,j} + g_e\\right).$$\n- 查询序列中的空位（主题序列中的插入）：\n$$I^y_{i,j} = \\max\\left(M_{i,j-1} + g_o + g_e,\\; I^y_{i,j-1} + g_e\\right).$$\n\n$X$-drop 终止准则：令 $S_{\\max}$ 为迄今为止在所有已计算的 $M$、$I^x$ 和 $I^y$ 单元中观察到的最大比对得分。对于每个主题列 $j \\in \\{1,\\ldots,m_r\\}$，定义列最佳值\n$$B_j = \\max_{i \\in \\{0,\\ldots,n_r\\}} \\left\\{ M_{i,j},\\; I^x_{i,j},\\; I^y_{i,j} \\right\\}.$$\n终止发生在第一个满足以下条件的列 $j$：\n$$B_j \\le S_{\\max}^{\\text{(prior)}} - X,$$\n其中 $S_{\\max}^{\\text{(prior)}}$ 是在处理列 $j$ 之前的 $S_{\\max}$ 值。当此条件首次成立时，报告基于零的列索引 $j^{*} = j - 1$。如果该条件对于任何 $j \\in \\{1,\\ldots,m_r\\}$ 都不成立，则报告 $j^{*} = m_r$。\n\n以逐次处理主题列并应用所定义的 $X$-drop 终止的方式，实现此锚定仿射空位动态规划。\n\n测试套件：使用 $X = 20$，$s_{\\text{match}} = +2$，$s_{\\text{mismatch}} = -3$，$g_o = -5$，$g_e = -1$，以及 $k = 4$。对于所有测试用例，种子从 $i_0 = 0$，$j_0 = 0$ 开始，覆盖两个序列中的位置 $\\{0,1,2,3\\}$。\n\n以单行输出的形式提供以下四个测试用例的结果：\n\n- 用例 1：$Q = \\text{\"ACGT\"}$ 重复 $12$ 次；$S = \\text{\"ACGT\"}$ 重复 $12$ 次，后跟 $40$ 个 $\\text{\"G\"}$。\n- 用例 2：$Q = \\text{\"ACGT\"}$ 重复 $10$ 次；$S = \\text{\"ACGT\"}$ 重复 $6$ 次，后跟 $50$ 个 $\\text{\"G\"}$。\n- 用例 3：$Q = \\text{\"ACGT\"}$ 重复 $8$ 次；$S = \\text{\"ACGT\"}$ 重复 $8$ 次。\n- 用例 4：$Q = \\text{\"ACGT\"}$ 重复 $10$ 次；$S = \\text{\"ACGT\"}$ 后跟 $30$ 个 $\\text{\"T\"}$，再后跟 $\\text{\"ACGT\"}$ 重复 $9$ 次。\n\n答案规格和格式：对于每个用例，输出所定义的整数 $j^{*}$。你的程序应生成一行输出，其中包含用逗号分隔并用方括号括起来的结果，按四个测试用例的顺序排列（例如，`[result1,result2,result3,result4]`）。不应打印任何其他文本。此问题中没有物理单位或角度。所有测试用例的最终答案都是整数。", "solution": "该问题要求实现一种锚定有空位延伸算法，这是生物信息学序列搜索工具（如 BLAST）中常见的启发式方法。延伸从一个固定的种子开始，并根据 $X$-drop 准则终止。我们将根据提供的动态规划（DP）递推关系和终止规则来形式化算法的设计。\n\n### 1. 锚定有空位延伸原理\n\n该算法是局部序列比对的一种形式，但它是锚定的。这意味着我们从一个假设开始，即已经找到了一个长度为 $k$ 的高分种子，它将 $Q[0 \\dots k-1]$ 与 $S[0 \\dots k-1]$ 对齐。我们的任务是将这个比对向右延伸到序列 $Q_r = Q[k \\dots n-1]$ 和 $S_r = S[k \\dots m-1]$ 中。\n\nDP 网格定义在这些后缀上，由 $i \\in \\{0, \\ldots, n_r\\}$ 和 $j \\in \\{0, \\ldots, m_r\\}$ 索引，其中 $n_r$ 和 $m_r$ 分别是 $Q_r$ 和 $S_r$ 的长度。锚点作为我们新比对的原点。起始单元格 $(i, j) = (0, 0)$（对应于种子之后的位置）的得分为 $0$，我们从那里开始构建比对。\n\n### 2. 仿射空位罚分动态规划\n\n评分使用仿射空位模型，该模型区分了开放一个空位和延伸一个空位的成本。这比线性空位模型更符合生物学实际，并使用三个 DP 矩阵实现，如 Gotoh 算法所述。\n\n令 $g_o = -5$ 为空位开放罚分，$g_e = -1$ 为空位延伸罚分。开放一个长度为 $1$ 的空位的总成本是 $g_o + g_e = -6$。令 $s(q, s)$ 为替换得分，匹配时为 $s_{\\text{match}} = +2$，错配时为 $s_{\\text{mismatch}} = -3$。\n\n三个矩阵是：\n- $M_{i,j}$：$Q_r[0 \\dots i-1]$ 和 $S_r[0 \\dots j-1]$ 的比对得分，该比对以 $Q_r[i-1]$ 与 $S_r[j-1]$ 对齐（匹配或错配）结束。\n- $I^x_{i,j}$：比对的得分，该比对以 $Q_r[i-1]$ 与一个空位对齐（主题序列 $S$ 中的空位）结束。\n- $I^y_{i,j}$：比对的得分，该比对以 $S_r[j-1]$ 与一个空位对齐（查询序列 $Q$ 中的空位）结束。\n\n**锚点处的初始化 $(i=0, j=0)$**：\n比对以零分开始，没有先前的空位。\n$$M_{0,0} = 0$$\n$$I^x_{0,0} = -\\infty$$\n$$I^y_{0,0} = -\\infty$$\n\n**边界条件**：\n对于 DP 网格的边缘，我们只允许延伸空位。\n- 对于 $j = 0$ 和 $i > 0$（从原点向下移动）：\n  $$M_{i,0} = -\\infty, \\quad I^y_{i,0} = -\\infty$$\n  $$I^x_{i,0} = \\max\\left(M_{i-1,0} + g_o + g_e,\\; I^x_{i-1,0} + g_e\\right)$$\n  追溯这个过程，$I^x_{1,0} = M_{0,0} + g_o + g_e = 0 - 5 - 1 = -6$。对于 $i > 1$，$M_{i-1,0}$ 是 $-\\infty$，所以 $I^x_{i,0} = I^x_{i-1,0} + g_e$。这给出了序列 $I^x_{i,0} = -5 - i$。\n- 对于 $i = 0$ 和 $j > 0$（从原点向右移动）：\n  $$M_{0,j} = -\\infty, \\quad I^x_{0,j} = -\\infty$$\n  $$I^y_{0,j} = \\max\\left(M_{0,j-1} + g_o + g_e,\\; I^y_{0,j-1} + g_e\\right)$$\n  对称地，这给出了 $I^y_{0,j} = -5 - j$。\n\n**对于 $i > 0, j > 0$ 的递推关系**：\n1.  要计算 $M_{i,j}$，我们考虑对齐 $Q_r[i-1]$ 和 $S_r[j-1]$。这个状态必须来自 $(i-1,j-1)$ 的一个状态。前一个状态可能是匹配/错配 ($M$)、在 $S$ 中的空位 ($I^x$) 或在 $Q$ 中的空位 ($I^y$)。我们取这些可能性的最大值，并加上替换得分 $s(Q_r[i-1], S_r[j-1])$。\n    $$M_{i,j} = \\max\\left(M_{i-1,j-1},\\; I^x_{i-1,j-1},\\; I^y_{i-1,j-1}\\right) + s(Q_r[i-1], S_r[j-1])$$\n2.  要计算 $I^x_{i,j}$，我们将 $Q_r[i-1]$ 与一个空位对齐。这个状态是从上面一行 $j$ 列的单元格到达的。我们可以从一个匹配/错配（来自 $M_{i-1,j}$）之后开启一个新空位，或者延伸一个现有的空位（来自 $I^x_{i-1,j}$）。\n    $$I^x_{i,j} = \\max\\left(M_{i-1,j} + g_o + g_e,\\; I^x_{i-1,j} + g_e\\right)$$\n3.  要计算 $I^y_{i,j}$，我们将 $S_r[j-1]$ 与一个空位对齐。这个状态是从左边一列 $i$ 行的单元格到达的。我们可以开启一个新空位（来自 $M_{i,j-1}$），或者延伸一个现有的空位（来自 $I^y_{i,j-1}$）。\n    $$I^y_{i,j} = \\max\\left(M_{i,j-1} + g_o + g_e,\\; I^y_{i,j-1} + g_e\\right)$$\n\n### 3. $X$-Drop 终止启发式\n\n计算完整的 DP 网格在计算上可能非常昂贵。$X$-drop 启发式提供了一个规则，如果比对质量显著下降，就提前终止延伸。\n\n该算法通过逐列填充 DP 矩阵（对于 $j=1, 2, \\dots, m_r$）来进行。\n- 令 $S_{\\max}$ 为到目前为止在任何已计算的单元格（$M$、$I^x$ 或 $I^y$）中找到的全局最大得分。初始时，$S_{\\max} = M_{0,0} = 0$。\n- 令 $S_{\\max}^{\\text{(prior)}}$ 为 *在* 计算列 $j$ 之前的 $S_{\\max}$ 值。\n- 对于每个新计算的列 $j$，我们找到该列内的最佳得分，$B_j = \\max_{0 \\le i \\le n_r} \\{ M_{i,j}, I^x_{i,j}, I^y_{i,j} \\}$。\n- 终止条件在第一个满足 $B_j \\le S_{\\max}^{\\text{(prior)}} - X$ 的列 $j$ 处达到，其中 $X=20$ 是下降阈值。\n- 如果在列 $j$ 处发生终止，我们报告基于零的索引 $j^{*} = j-1$。\n- 检查终止后，$S_{\\max}$ 会用当前列的得分进行更新：$S_{\\max} = \\max(S_{\\max}, B_j)$。\n- 如果循环完成而条件未被满足，说明没有发生下降，我们报告 $j^{*} = m_r$。\n\n### 4. 实现策略\n\n为了最小化内存使用，我们不需要存储整个 DP 网格。由于列 $j$ 的计算仅需要来自列 $j-1$ 的值（以及列 $j$ 内部的值），我们只需要在任何时候在内存中保留两列：“前一列”和“当前列”。\n\n总体算法如下：\n1.  根据锚点和边界条件，为 $M$、$I^x$ 和 $I^y$ 初始化代表列 $j=0$ 的 DP 列向量。\n2.  初始化 $S_{\\max} = 0$。\n3.  从 $j=1$ 到 $m_r$ 迭代：\n    a. 将当前的 $S_{\\max}$ 存储为 $S_{\\max}^{\\text{(prior)}}$。\n    b. 为 $M$、$I^x$ 和 $I^y$ 创建新的“当前”列向量。\n    c. 使用“前一列”的数据和递推关系，从 $i=0$ 到 $n_r$ 逐行计算“当前”列 $j$ 的值。依赖关系需要仔细排序：对于每个 $i$，$M_{i,j}$ 和 $I^y_{i,j}$ 可以先计算，然后是 $I^x_{i,j}$，它依赖于当前列中 $i-1$ 的值。\n    d. 计算 $B_j$，即新计算列中的最大得分。\n    e. 检查是否 $B_j \\le S_{\\max}^{\\text{(prior)}} - X$。如果是，返回 $j-1$ 并终止。\n    f. 更新 $S_{\\max} = \\max(S_{\\max}, B_j)$。\n    g. “当前”列向量成为下一次迭代的“前一列”向量。\n4.  如果循环结束，返回 $m_r$。\n\n此过程正确且高效地实现了带有 $X$-drop 启发式的指定锚定比对延伸。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_extension(Q, S, k, s_match, s_mismatch, go, ge, X):\n    \"\"\"\n    Performs anchored gapped extension with an X-drop termination heuristic.\n\n    Args:\n        Q (str): The query sequence.\n        S (str): The subject sequence.\n        k (int): The length of the seed.\n        s_match (int): The score for a character match.\n        s_mismatch (int): The score for a character mismatch.\n        go (int): The gap open penalty (a negative number).\n        ge (int): The gap extend penalty (a negative number).\n        X (int): The drop-off threshold (a positive number).\n\n    Returns:\n        int: The zero-based column index j* where termination occurs.\n    \"\"\"\n    go_ge = go + ge\n    \n    Q_r = Q[k:]\n    S_r = S[k:]\n    n_r = len(Q_r)\n    m_r = len(S_r)\n\n    if m_r == 0:\n        return 0\n\n    # DP columns for j-1, representing M, Ix, Iy scores\n    # Using float64 for -np.inf\n    M_prev = np.full(n_r + 1, -np.inf, dtype=np.float64)\n    Ix_prev = np.full(n_r + 1, -np.inf, dtype=np.float64)\n    Iy_prev = np.full(n_r + 1, -np.inf, dtype=np.float64)\n\n    # Initialization for column j=0 (the anchor point)\n    M_prev[0] = 0.0\n    # Boundary for Ix: opening a gap in S from the anchor\n    # I^x_{i,0} = g_o + g_e + (i-1)*g_e\n    if n_r > 0:\n        Ix_prev[1:] = go_ge + ge * np.arange(0, n_r)\n    \n    s_max = 0.0\n\n    # Iterate through columns of the subject sequence suffix S_r\n    for j in range(1, m_r + 1):\n        s_max_prior = s_max\n        s_char = S_r[j-1]\n        \n        M_curr = np.full(n_r + 1, -np.inf, dtype=np.float64)\n        Ix_curr = np.full(n_r + 1, -np.inf, dtype=np.float64)\n        Iy_curr = np.full(n_r + 1, -np.inf, dtype=np.float64)\n\n        # Boundary for i=0 in current column j\n        # I^y_{0,j} = max(M_{0,j-1} + go_ge, I^y_{0,j-1} + ge)\n        Iy_curr[0] = max(M_prev[0] + go_ge, Iy_prev[0] + ge)\n\n        # Main DP calculation loop for column j, iterating through rows\n        for i in range(1, n_r + 1):\n            q_char = Q_r[i-1]\n            score = s_match if q_char == s_char else s_mismatch\n            \n            # M_ij = max(M, Ix, Iy at i-1, j-1) + score\n            M_curr[i] = max(M_prev[i-1], Ix_prev[i-1], Iy_prev[i-1]) + score\n\n            # I^x_ij = max(open from M at i-1,j, extend from I^x at i-1,j)\n            Ix_curr[i] = max(M_curr[i-1] + go_ge, Ix_curr[i-1] + ge)\n            \n            # I^y_ij = max(open from M at i,j-1, extend from I^y at i,j-1)\n            Iy_curr[i] = max(M_prev[i] + go_ge, Iy_prev[i] + ge)\n\n        # Find B_j, the best score in the current column j\n        col_max = np.nanmax(np.concatenate([M_curr, Ix_curr, Iy_curr]))\n\n        if col_max = s_max_prior - X:\n            return j - 1\n\n        # Update s_max with the best score from the current column\n        s_max = max(s_max, col_max)\n        \n        # Current column becomes previous for the next iteration\n        M_prev, Ix_prev, Iy_prev = M_curr, Ix_curr, Iy_curr\n\n    return m_r\n\ndef solve():\n    # Define the parameters from the problem statement.\n    X = 20\n    s_match = 2\n    s_mismatch = -3\n    go = -5\n    ge = -1\n    k = 4\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"ACGT\" * 12, \"ACGT\" * 12 + \"G\" * 40),\n        (\"ACGT\" * 10, \"ACGT\" * 6 + \"G\" * 50),\n        (\"ACGT\" * 8, \"ACGT\" * 8),\n        (\"ACGT\" * 10, \"ACGT\" + \"T\" * 30 + \"ACGT\" * 9)\n    ]\n\n    results = []\n    for Q, S in test_cases:\n        j_star = run_extension(Q, S, k, s_match, s_mismatch, go, ge, X)\n        results.append(j_star)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4571651"}]}