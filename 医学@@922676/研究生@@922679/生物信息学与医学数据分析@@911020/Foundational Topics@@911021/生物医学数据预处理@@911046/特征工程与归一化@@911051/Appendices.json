{"hands_on_practices": [{"introduction": "在RNA测序数据分析中，原始的读数（read counts）并不能直接用于比较不同基因或不同样本的表达水平，因为它同时受到基因长度和测序深度的影响。本练习将指导您逐步完成百万转录本（Transcripts Per Million, TPM）的手动计算，这是一种标准的归一化方法，通过校正这两个因素，使得基因表达的比较更为公平和准确。通过这个实践，您将深入理解TPM归一化的核心原理及其计算过程 [@problem_id:4562784]。", "problem": "在临床生物信息学中，您正在为RNA测序数据中的下游预后建模构建基因表达特征。特征工程中使用的一个核心归一化方法是每百万转录本 (Transcripts Per Million, TPM)，它通过校正基因长度和文库大小，以产生跨样本可比较的丰度估计值。考虑一个包含3个基因的玩具数据集，标记为 $G_1$、$G_2$ 和 $G_3$，其长度分别为 $L_{G_1} = 1000$ 碱基对 (bp)、$L_{G_2} = 2000$ bp 和 $L_{G_3} = 500$ bp。两个患者样本 $S_1$ 和 $S_2$ 观察到的基因水平读数计数 $r_{g,s}$ 如下：对于 $S_1$，$(r_{G_1,S_1}, r_{G_2,S_1}, r_{G_3,S_1}) = (300, 200, 200)$；对于 $S_2$，$(r_{G_1,S_2}, r_{G_2,S_2}, r_{G_3,S_2}) = (200, 600, 250)$。请使用适用于RNA测序归一化的第一性原理，即表达量估计必须校正基因长度（通过以千碱基为单位的基因长度来缩放计数）和样本特异性的文库大小（通过将样本内的丰度重新缩放到一个固定常数 $10^6$），推导出每个样本中每个基因的每百万转录本 (TPM) 值。作为推导的一部分，请明确验证每个样本内的TPM值总和为 $10^6$。最后，报告样本 $S_2$ 中基因 $G_3$ 的TPM值。将您的最终数值答案四舍五入到四位有效数字，并以纯数字形式表示（无单位）。", "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于RNA测序数据归一化的原理，提法明确，提供了所有必要信息，并且语言客观。该问题要求为一个玩具数据集计算每百万转录本 (TPM) 值，这是生物信息学中的一个标准程序。\n\nTPM的计算是一个两步归一化过程。首先，对读数计数进行基因长度归一化。其次，对它们进行测序深度（文库大小）归一化，以使其在样本间具有可比性。\n\n设 $r_{g,s}$ 为样本 $s$ 中基因 $g$ 的原始读数计数。\n设 $L_g$ 为基因 $g$ 的长度，单位为碱基对 (bp)。\n\n给定数据如下：\n基因长度：\n$L_{G_1} = 1000$ bp\n$L_{G_2} = 2000$ bp\n$L_{G_3} = 500$ bp\n\n样本 $S_1$ 的读数计数：\n$(r_{G_1,S_1}, r_{G_2,S_1}, r_{G_3,S_1}) = (300, 200, 200)$\n\n样本 $S_2$ 的读数计数：\n$(r_{G_1,S_2}, r_{G_2,S_2}, r_{G_3,S_2}) = (200, 600, 250)$\n\nTPM 计算过程如下：\n\n**步骤1：进行基因长度归一化。**\n首先，按照规定，我们将基因长度从碱基对 (bp) 转换为千碱基 (kb)。设 $L'_g$ 为基因 $g$ 的长度，单位为 kb。\n$$L'_g = \\frac{L_g}{1000}$$\n对于我们的3个基因：\n$L'_{G_1} = \\frac{1000}{1000} = 1.0 \\text{ kb}$\n$L'_{G_2} = \\frac{2000}{1000} = 2.0 \\text{ kb}$\n$L'_{G_3} = \\frac{500}{1000} = 0.5 \\text{ kb}$\n\n接下来，我们计算每个样本中每个基因的每千碱基读数 (Reads Per Kilobase, RPK) 率。\n$$RPK_{g,s} = \\frac{r_{g,s}}{L'_g}$$\n\n**样本 $S_1$ 的计算：**\n$RPK_{G_1,S_1} = \\frac{r_{G_1,S_1}}{L'_{G_1}} = \\frac{300}{1.0} = 300$\n$RPK_{G_2,S_1} = \\frac{r_{G_2,S_1}}{L'_{G_2}} = \\frac{200}{2.0} = 100$\n$RPK_{G_3,S_1} = \\frac{r_{G_3,S_1}}{L'_{G_3}} = \\frac{200}{0.5} = 400$\n\n**样本 $S_2$ 的计算：**\n$RPK_{G_1,S_2} = \\frac{r_{G_1,S_2}}{L'_{G_1}} = \\frac{200}{1.0} = 200$\n$RPK_{G_2,S_2} = \\frac{r_{G_2,S_2}}{L'_{G_2}} = \\frac{600}{2.0} = 300$\n$RPK_{G_3,S_2} = \\frac{r_{G_3,S_2}}{L'_{G_3}} = \\frac{250}{0.5} = 500$\n\n**步骤2：进行文库大小归一化并缩放到 $10^6$。**\n我们通过对该样本内所有基因的 RPK 值求和，计算出每个样本的归一化因子 $T_s$。\n$$T_s = \\sum_{g} RPK_{g,s}$$\n然后，通过将其 RPK 除以归一化因子并乘以 $10^6$ 来计算每个基因的 TPM 值。\n$$TPM_{g,s} = \\left(\\frac{RPK_{g,s}}{T_s}\\right) \\times 10^6$$\n\n**样本 $S_1$ 的计算：**\n首先，计算归一化因子 $T_{S_1}$：\n$T_{S_1} = RPK_{G_1,S_1} + RPK_{G_2,S_1} + RPK_{G_3,S_1} = 300 + 100 + 400 = 800$\n\n现在，计算 $S_1$ 中每个基因的 TPM 值：\n$TPM_{G_1,S_1} = \\left(\\frac{300}{800}\\right) \\times 10^6 = 0.375 \\times 10^6 = 375000$\n$TPM_{G_2,S_1} = \\left(\\frac{100}{800}\\right) \\times 10^6 = 0.125 \\times 10^6 = 125000$\n$TPM_{G_3,S_1} = \\left(\\frac{400}{800}\\right) \\times 10^6 = 0.5 \\times 10^6 = 500000$\n\n对 $S_1$ 进行验证：TPM 的总和必须为 $10^6$。\n$\\sum_{g} TPM_{g,S_1} = 375000 + 125000 + 500000 = 1000000 = 10^6$。条件满足。\n\n**样本 $S_2$ 的计算：**\n首先，计算归一化因子 $T_{S_2}$：\n$T_{S_2} = RPK_{G_1,S_2} + RPK_{G_2,S_2} + RPK_{G_3,S_2} = 200 + 300 + 500 = 1000$\n\n现在，计算 $S_2$ 中每个基因的 TPM 值：\n$TPM_{G_1,S_2} = \\left(\\frac{200}{1000}\\right) \\times 10^6 = 0.2 \\times 10^6 = 200000$\n$TPM_{G_2,S_2} = \\left(\\frac{300}{1000}\\right) \\times 10^6 = 0.3 \\times 10^6 = 300000$\n$TPM_{G_3,S_2} = \\left(\\frac{500}{1000}\\right) \\times 10^6 = 0.5 \\times 10^6 = 500000$\n\n对 $S_2$ 进行验证：TPM 的总和必须为 $10^6$。\n$\\sum_{g} TPM_{g,S_2} = 200000 + 300000 + 500000 = 1000000 = 10^6$。条件满足。\n\n问题要求样本 $S_2$ 中基因 $G_3$ 的 TPM 值。根据上述计算：\n$TPM_{G_3,S_2} = 500000$\n\n最终答案必须四舍五入到四位有效数字。精确值为 $500000$。为了用四位有效数字表示，我们使用科学记数法：$5.000 \\times 10^5$。", "answer": "$$\\boxed{5.000 \\times 10^{5}}$$", "id": "4562784"}, {"introduction": "分位数归一化（Quantile Normalization）是一种强大的非参数方法，旨在强制不同样本的数据具有相同的统计分布，从而消除样本间的技术性偏差。这个练习要求您通过编程实现分位数归一化算法，并数值验证其核心特性——即归一化后所有样本都具有完全相同的经验累积分布函数。这不仅能帮助您掌握一种重要的数据预处理技术，还能锻炼您在生物信息学分析中的编程和算法验证能力 [@problem_id:4562739]。", "problem": "考虑一个数据矩阵 $X \\in \\mathbb{R}^{m \\times n}$，其列代表样本，其行代表特征（例如，跨多个测定运行的基因表达强度）。在许多生物信息学流程中，归一化的目标是将每个样本映射到一个共同的边缘分布，以便样本间的比较不会被技术变异所混淆。一种广泛使用的方法是分位数归一化，可以形式化地描述如下。对于每一列 $j \\in \\{1,\\dots,n\\}$，令 $\\pi_j : \\{1,\\dots,m\\} \\to \\{1,\\dots,m\\}$ 为一个排列，它将列 $j$ 的条目按非递减顺序排序，并定义顺序统计量 $x_{(1)j} \\le x_{(2)j} \\le \\dots \\le x_{(m)j}$ 为 $x_{(r)j} = x_{\\pi_j(r), j}$。分位数归一化的列是通过计算每个秩上的跨样本平均值来构建的，\n$$\ns_r = \\frac{1}{n} \\sum_{j=1}^n x_{(r)j} \\quad \\text{for } r \\in \\{1,\\dots,m\\},\n$$\n然后将这些平均值赋回到原始索引，即 $y_{\\pi_j(r), j} = s_r$。归一化后的矩阵为 $Y \\in \\mathbb{R}^{m \\times n}$，其条目为 $y_{ij}$。令 $F_j(t)$ 表示列 $j$ 的经验累积分布函数（empirical CDF），\n$$\nF_j(t) = \\frac{1}{m} \\sum_{i=1}^m \\mathbf{1}\\{ y_{ij} \\le t \\},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。根据构造，Y 的每一列都是多重集 $\\{ s_1, s_2, \\dots, s_m \\}$ 的一个排列，因此当在共同支撑集 $\\{ s_1, \\dots, s_m \\}$ 上求值时，每个 $F_j$ 都是相同的阶梯函数（在重复度上）。为了数值上验证分位数归一化后边缘经验 CDF 的同一性，定义最大成对上确界范数偏差为\n$$\n\\Delta(X) = \\max_{1 \\le j_1 < j_2 \\le n} \\sup_{t \\in \\mathbb{R}} \\left| F_{j_1}(t) - F_{j_2}(t) \\right|.\n$$\n因为 $F_{j}$ 是仅在 $\\{ s_1, \\dots, s_m \\}$ 中的值处有跳跃点的右连续阶梯函数，所以在 $\\{ s_1, \\dots, s_m \\}$ 的排序后唯一值上计算上确界就足够了。实现一个程序，该程序：\n- 通过上述秩平均程序，使用稳定排序处理相同值，从给定的输入矩阵 $X$ 计算分位数归一化的矩阵 $Y$。\n- 在 $\\{ s_1, \\dots, s_m \\}$ 的共同、排序、唯一的支撑集上，计算 $Y$ 的所有列的经验 CDF $F_j$。\n- 计算 $\\Delta(X)$，即在所有列对上，其经验 CDF 在该支撑集上求值的上确界范数差异的最大值。\n您的程序应处理以下矩阵测试套件（每个矩阵由其行给出，每行是一个实数列表；请确保完全按照指定使用它们）：\n- 测试用例 1 ($5 \\times 3$):\n  `[[5.2, 2.0, 8.1], [3.1, -1.0, 7.9], [9.0, 5.5, 0.0], [4.4, 3.3, 1.2], [7.7, 2.2, 9.9]]`\n- 测试用例 2 ($6 \\times 4$, 含常数列):\n  `[[10.0, 1.0, 3.0, 7.0], [10.0, 4.0, 3.5, -2.0], [10.0, -5.0, 10.0, 7.1], [10.0, 2.0, -8.0, 7.2], [10.0, 2.5, 0.0, -2.1], [10.0, 100.0, 5.0, 0.0]]`\n- 测试用例 3 ($4 \\times 2$, 含相同值):\n  `[[1.0, 1.0], [1.0, 2.0], [3.0, 2.0], [3.0, 3.0]]`\n- 测试用例 4 ($1 \\times 3$, 平凡的单行):\n  `[[42.0, -1.0, 100.0]]`\n- 测试用例 5 ($3 \\times 3$, 极端动态范围):\n  `[[1e-9, 1e9, -1e3], [2e-9, -1e9, 0.5], [3e-9, 0.0, 1.5]]`\n对于每个测试用例矩阵 $X$，以浮点数形式计算 $\\Delta(X)$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，`[result1, result2, ...]`）。不涉及物理单位；角度不相关；分数输出必须以小数形式提供。该测试套件旨在涵盖：一般情况、含常数列的边界情况、显式相同值、平凡维度情况以及一个用以探测数值稳定性的极端数量级情况。最终输出必须是浮点数。", "solution": "该问题要求实现分位数归一化算法，并随后对其定义属性进行数值验证：即结果矩阵的所有列（样本）共享相同的经验边缘分布。此验证通过计算 $\\Delta(X)$ 来执行，$\\Delta(X)$ 是归一化后各列的经验累积分布函数（ECDF）之间的最大成对上确界范数偏差。\n\n解决方案分三个阶段进行：首先，对输入矩阵 $X$ 进行分位数归一化；其次，计算归一化矩阵 $Y$ 的每列的 ECDF；第三，计算最大成对偏差 $\\Delta(X)$。\n\n**1. 分位数归一化过程**\n\n给定一个输入数据矩阵 $X \\in \\mathbb{R}^{m \\times n}$，其中 $m$ 是特征数，$n$ 是样本数，分位数归一化矩阵 $Y \\in \\mathbb{R}^{m \\times n}$ 的计算如下：\n\n- **排序和定秩：** 对于每一列 $j \\in \\{1, \\dots, n\\}$，我们确定行索引 $\\{1, \\dots, m\\}$ 的排列 $\\pi_j$，该排列将该列的元素按非递减顺序排序。这为每个秩 $r \\in \\{1, \\dots, m\\}$ 产生了顺序统计量 $x_{(r)j} = x_{\\pi_j(r), j}$，使得 $x_{(1)j} \\le x_{(2)j} \\le \\dots \\le x_{(m)j}$。问题指定使用稳定排序来确保对相同值的确定性处理，其中值相等的元素保持其原始相对顺序。\n\n- **按秩平均：** 通过对每个秩的所有样本值进行平均，得到一个目标分位数集。对于每个秩 $r$，平均值 $s_r$ 计算如下：\n$$\ns_r = \\frac{1}{n} \\sum_{j=1}^{n} x_{(r)j}\n$$\n这些平均值的集合 $\\{s_1, s_2, \\dots, s_m\\}$ 构成了所有样本将被映射到的共同经验分布。\n\n- **值替换：** 通过将 $X$ 中的原始值替换为计算出的按秩平均值来构建归一化矩阵 $Y$。具体来说，列 $j$ 中秩为 $r$ 的元素被替换为 $s_r$。此操作通过赋值 $y_{\\pi_j(r), j} = s_r$ 来形式化。在算法上，这是通过将每个原始值 $x_{ij}$ 与其在列 $j$ 中的秩相关联，然后用向量 $s = (s_1, \\dots, s_m)$ 中的相应值替换它来实现的。一种高效的实现方法是找到每列排序排列的逆排列，并用它来将 $s$ 的元素排列到 $Y$ 的新列中。\n\n**2. ECDF 计算与 $\\Delta(X)$ 度量**\n\n根据上述构造，归一化矩阵 $Y$ 的每一列都是相同值多重集 $S = \\{s_1, s_2, \\dots, s_m\\}$ 的一个排列。一个直接的推论是，每列的经验累积分布函数（ECDF）必须是相同的。$Y$ 的列 $j$ 的 ECDF 定义为：\n$$\nF_j(t) = \\frac{1}{m} \\sum_{i=1}^{m} \\mathbf{1}\\{y_{ij} \\le t\\}\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。由于值多重集 $\\{y_{ij}\\}_{i=1}^m$ 对于每一列 $j$ 都是相同的，因此小于或等于任何给定 $t \\in \\mathbb{R}$ 的值的数量也是相同的。因此，在精确算术中，对于任何列对 $(j_1, j_2)$ 和所有的 $t$，都有 $F_{j_1}(t) = F_{j_2}(t)$。\n\n问题定义了一个度量 $\\Delta(X)$，用以数值上验证此同一性：\n$$\n\\Delta(X) = \\max_{1 \\le j_1 < j_2 \\le n} \\sup_{t \\in \\mathbb{R}} \\left| F_{j_1}(t) - F_{j_2}(t) \\right|\n$$\n由于 ECDF 是阶梯函数，其差值的上确界（sup-norm）只需在发生跳跃的点处进行评估，这些点即归一化列中存在的值。因此，评估可以限制在来自 $\\{s_1, \\dots, s_m\\}$ 的排序后唯一值的集合上。\n\n理论上，$\\Delta(X)$ 应精确为 $0$。该计算可作为对实现是否正确遵守算法定义的确认。即使使用有限精度浮点算术，该过程也涉及创建向量 $s$，然后排列其元素以形成 $Y$ 的列。这意味着 $Y$ 的每一列将包含完全相同的浮点数集合，因此它们的 ECDF 将是相同的，从而得到 $\\Delta(X) = 0.0$ 的数值结果。\n\n**3. 计算算法**\n\n实现将严格遵循所提供的定义。\n\n1.  给定 $m \\times n$ 矩阵 $X$，计算一个 $m \\times n$ 的排序索引矩阵 `sort_idx`，其中 `sort_idx[:, j]` 包含对列 `X[:, j]` 进行排序的行索引。使用稳定排序算法。\n2.  使用 `sort_idx` 创建排序后的矩阵 $X_{sorted}$，其中 $X_{\\text{sorted}}[r, j] = X[\\text{sort\\_idx}[r, j], j]$。\n3.  通过对 $X_{sorted}$ 的行进行平均，计算长度为 $m$ 的按秩平均向量 $s$。\n4.  构建 $m \\times n$ 的归一化矩阵 $Y$。对于每一列 $j$，来自 $s$ 的值被放置到由 $X[:,j]$ 中原始元素的秩所指定的位置。\n5.  通过找到 $s$ 中排序后的唯一值（记为向量 $t_{support}$）来确定 ECDF 的评估点。\n6.  对于每一列 $j \\in \\{1, \\dots, n\\}$，计算其在 $t_{support}$ 中每个点上评估的 ECDF。这会为每列生成一个 ECDF 值向量。\n7.  遍历所有唯一的列对 $(j_1, j_2)$（其中 $j_1 < j_2$）。对于每一对，计算其 ECDF 值向量的逐元素绝对差，并找到最大值（离散支撑集上的上确界范数）。\n8.  最终结果 $\\Delta(X)$ 是所有对的上确界范数差异的最大值。对于所有测试用例，该值预期为 $0.0$。", "answer": "[0.0,0.0,0.0,0.0,0.0]", "id": "4562739"}, {"introduction": "选择合适的归一化方法对于获取准确的生物学结论至关重要，而任何归一化方法都建立在特定的假设之上。本练习是一个批判性思维挑战，通过一个精心设计的反例，展示了一种看似简单且常用的全局缩放方法（如每百万读数计数，CPM）在某些情况下可能产生误导性结果。这个案例揭示了，当用于归一化的“管家基因”实际上受实验处理影响时，会如何掩盖真实的基因表达变化，从而强调了在选择归一化策略时考虑其背后生物学假设的重要性 [@problem_id:4562808]。", "problem": "一个研究团队正在进行RNA测序（RNA-seq），以测量某种处理下的基因表达变化。他们考虑一个目标基因 $G_{T}$ 和一组管家基因 $H_{1}, H_{2}, H_{3}$。管家基因通常用于定义全局表达基线，但在本实验中，这些管家基因在生物学上受到了该处理的影响。该团队使用总读数计数进行全局缩放，类似于百万分之几计数（CPM），方法如下：对于样本 $s$，基因 $g$ 的归一化值为 $x_{g,s}/T_{s}$，其中 $x_{g,s}$ 是观测到的原始计数，$T_{s}=\\sum_{g}x_{g,s}$ 是样本 $s$ 中的总计数。$G_{T}$ 的归一化倍数变化定义为处理组中其归一化值与对照组中其归一化值的比率，而归一化对数（以2为底）倍数变化是该比率以2为底的对数。\n\n假设以下观测到的原始计数在科学上是合理的，并且与测序深度和表达水平自洽：\n- 对照组样本计数：$x_{G_{T},\\mathrm{ctrl}}=100$， $x_{H_{1},\\mathrm{ctrl}}=100$， $x_{H_{2},\\mathrm{ctrl}}=100$， $x_{H_{3},\\mathrm{ctrl}}=100$。\n- 处理组样本计数：$x_{G_{T},\\mathrm{trt}}=200$， $x_{H_{1},\\mathrm{trt}}=150$， $x_{H_{2},\\mathrm{trt}}=150$， $x_{H_{3},\\mathrm{trt}}=150$。\n\n将原始计数视为与真实表达量乘以样本特异性文库大小成正比。你可以假设没有其他基因对总数有贡献。根据第一性原理，计算在使用定义的全局总计数缩放时 $G_{T}$ 的归一化对数（以2为底）倍数变化。将你的答案表示为一个精确的以2为底的对数表达式。不要近似，也不要包含任何单位。", "solution": "RNA测序（RNA-seq）定量的基本前提是，样本 $s$ 中基因 $g$ 的观测原始计数 $x_{g,s}$ 与 $s$ 中 $g$ 的真实表达水平和样本特异性文库大小 $L_{s}$ 成正比。通过总计数进行全局缩放，即通过将每个 $x_{g,s}$ 除以样本总数 $T_{s}=\\sum_{g}x_{g,s}$ 来校正 $L_{s}$ 的差异，从而得到一个归一化值 $x_{g,s}/T_{s}$，该值与样本 $s$ 中基因 $g$ 的真实表达分数成正比。\n\n在给定的归一化方法下，一个基因在处理组和对照组之间的倍数变化定义为归一化处理值与归一化对照值的比率。以2为底的对数倍数变化是该比率的 $\\log_{2}$。\n\n我们根据这些定义逐步进行计算。\n\n首先，计算每个样本中的总计数：\n- 对照组总数：\n$$\nT_{\\mathrm{ctrl}}=x_{G_{T},\\mathrm{ctrl}}+x_{H_{1},\\mathrm{ctrl}}+x_{H_{2},\\mathrm{ctrl}}+x_{H_{3},\\mathrm{ctrl}}=100+100+100+100=400.\n$$\n- 处理组总数：\n$$\nT_{\\mathrm{trt}}=x_{G_{T},\\mathrm{trt}}+x_{H_{1},\\mathrm{trt}}+x_{H_{2},\\mathrm{trt}}+x_{H_{3},\\mathrm{trt}}=200+150+150+150=650.\n$$\n\n接下来，在全局缩放条件下计算 $G_{T}$ 在每种条件下的归一化值：\n- $G_{T}$ 的对照组归一化值：\n$$\n\\frac{x_{G_{T},\\mathrm{ctrl}}}{T_{\\mathrm{ctrl}}}=\\frac{100}{400}=\\frac{1}{4}.\n$$\n- $G_{T}$ 的处理组归一化值：\n$$\n\\frac{x_{G_{T},\\mathrm{trt}}}{T_{\\mathrm{trt}}}=\\frac{200}{650}=\\frac{40}{130}=\\frac{8}{26}=\\frac{4}{13}.\n$$\n\n计算 $G_{T}$ 的归一化倍数变化，即这些归一化值的比率：\n$$\n\\text{FC}_{\\mathrm{norm}}=\\frac{\\frac{x_{G_{T},\\mathrm{trt}}}{T_{\\mathrm{trt}}}}{\\frac{x_{G_{T},\\mathrm{ctrl}}}{T_{\\mathrm{ctrl}}}}=\\frac{\\frac{200}{650}}{\\frac{100}{400}}=\\frac{200}{650}\\cdot\\frac{400}{100}=\\frac{800}{650}=\\frac{16}{13}.\n$$\n\n最后，计算归一化对数（以2为底）倍数变化：\n$$\n\\log_{2}\\left(\\text{FC}_{\\mathrm{norm}}\\right)=\\log_{2}\\left(\\frac{16}{13}\\right).\n$$\n\n为了将此解释为一个证明衰减的反例，请注意 $G_{T}$ 的原始计数中的真实倍数变化是\n$$\n\\text{FC}_{\\mathrm{raw}}=\\frac{200}{100}=2,\n$$\n真实的以2为底的对数倍数变化为 $\\log_{2}(2)=1$。在通过总计数进行全局缩放的情况下，归一化倍数变化变为 $\\frac{16}{13}$，该值严格小于 $2$，而归一化对数（以2为底）倍数变化 $\\log_{2}\\left(\\frac{16}{13}\\right)$ 严格小于 $1$。衰减的产生是因为管家基因 $H_{1},H_{2},H_{3}$ 在处理后增加，导致 $T_{\\mathrm{trt}}$ 相对于 $T_{\\mathrm{ctrl}}$ 膨胀；除以较大的 $T_{\\mathrm{trt}}$ 会使得处理组中 $G_{T}$ 的归一化值相对于对照组减少的程度，比管家基因真正不变时要大。这从第一性原理上证明了，当管家基因差异表达时，全局缩放会衰减真实的处理效应。\n\n因此，所要求的精确的以2为底的对数表达式是 $\\log_{2}\\left(\\frac{16}{13}\\right)$。", "answer": "$$\\boxed{\\log_{2}\\!\\left(\\frac{16}{13}\\right)}$$", "id": "4562808"}]}