{"hands_on_practices": [{"introduction": "在开始任何NGS数据分析之前，确保我们能够正确解析数据是至关重要的第一步。FASTQ文件中的质量分数有两种常见的编码方案，错误地解读它们会导致对所有后续质量控制和分析的严重误判。本练习将引导你设计一个基于基本原理的统计检验，以推断FASTQ文件使用的编码格式，这体现了生物信息学分析中严谨的数据验证过程[@problem_id:4590262]。", "problem": "您将设计并实现一个程序，该程序根据FASTQ格式（FASTQ）文件中质量字符的经验分布，执行假设检验以推断所使用的编码偏移量是Phred加$33$还是Phred加$64$。其背景是生物信息学和医学数据分析中的第二代测序（NGS）数据预处理，其中碱基检出准确率的质量控制至关重要。\n\n假设存在以下基本定义和事实：\n- Phred质量分数（Phred）由关系式$$Q=-10\\log_{10}(p)$$定义，其中$Q$是整数值的质量分数，$p$是碱基检出错误的概率。\n- 在FASTQ中，质量分数使用偏移量$o$表示为美国信息交换标准代码（ASCII）字符，使得每个字符$c$编码一个整数$$q(c,o)=\\mathrm{ord}(c)-o$$。广泛使用的编码是$o=33$（Phred加$33$）和$o=64$（Phred加$64$）。\n- 根据经验和平台规范，观测到的Phred分数被限制在整数范围$$q\\in\\{0,1,2,\\dots,41\\}$$内。\n- 在编码偏移量$o$下，质量字符的有效ASCII支持集是$$\\mathcal{S}_o=\\{c\\in\\text{ASCII}:\\mathrm{ord}(c)\\in[o,o+41]\\}$$。\n\n您的任务是构建一个统计检验，仅基于观测到的质量字符的经验分布，在两个复合假设之间做出决策：\n- $$H_{33}:o=33,$$\n- $$H_{64}:o=64,$$\n该决策受限于映射分数$q(c,o)$对于所有观测字符$c$都必须位于集合$\\{0,\\dots,41\\}$内的约束。该检验必须有章可循，从上述定义和事实中推导出其决策规则，并为每个测试用例返回一个数值决策。如果观测到的经验分布不允许在这些约束下对$H_{33}$和$H_{64}$做出明确选择，则该检验必须根据一个明确合理的规则输出一个未定代码。\n\n输入格式和数据模型：\n- 没有外部输入；您的程序将在内部使用四个测试用例，每个用例以字符串列表的形式提供。每个字符串代表一行FASTQ质量值。程序应将一个用例中所有行的所有字符的多重集视为经验样本$\\{c_1,\\dots,c_n\\}$。\n- 四个测试用例如下：\n    1. 案例A（典型的Phred加$33$场景）：$$[\"!!IIJJ\", \"!IJIJ\"]$$\n    2. 案例B（典型的Phred加$64$场景）：$$[\"@@hhi\", \"hhi@@\"]$$\n    3. 案例C（完全位于重叠区域内的模糊场景）：$$[\"@ABCDEFGHIJ\"]$$\n    4. 案例D（边界模糊场景）：$$[\"@@@III\", \"@I@I@I\"]$$\n\n输出规范：\n- 对于每个案例，输出一个整数决策：\n    - 如果您的检验推断为Phred加$33$，则输出$33$，\n    - 如果您的检验推断为Phred加$64$，则输出$64$，\n    - 如果根据推导出的决策规则检验结果为未定，则输出$0$。\n- 您的程序应生成单行输出，其中包含按四个案例顺序排列的结果，以逗号分隔并用方括号括起，例如$$[33,64,0,0]$$。\n\n设计约束：\n- 推导必须从上述核心定义和广泛接受的事实出发，并进而得出一个逻辑上合理的决策规则。除了所述约束之外，不要假设任何额外的平台特定启发式方法或外部提示。\n- 统计检验必须以纯数学术语定义，仅依赖于观测到的ASCII字符的经验分布（通过其整数代码）和两种编码所隐含的已知支持集约束。\n- 确保完整性、科学真实性和自洽性：决策规则必须是合理的，并且对于所提供的测试套件（包括正常操作、边界条件和边缘情况）是稳健的。", "solution": "该问题要求设计一种统计检验，以确定FASTQ格式数据中Phred质量分数的编码偏移量。决策需要在两个相互竞争的假设之间做出：$H_{33}$假设偏移量为$o=33$（Phred+33），而$H_{64}$假设偏移量为$o=64$（Phred+64）。该决策必须仅基于观测到的质量字符的经验分布，并遵循FASTQ格式和Phred分数的既定约束。\n\n我们的推导从所提供的基本原理开始。Phred质量分数$Q$是一个整数。问题指出，根据经验，这些分数被限制在集合$Q \\in \\{0, 1, 2, \\dots, 41\\}$中。在FASTQ文件中，每个质量分数都使用一个整数偏移量$o$编码为一个美国信息交换标准代码（ASCII）字符$c$。解码规则由下式给出：\n$$q(c, o) = \\mathrm{ord}(c) - o$$\n其中$\\mathrm{ord}(c)$是字符$c$的ASCII序数值。\n\n对于质量字符串中存在的任意给定字符$c$，要在特定编码假设$H_o$下被视为有效，其解码后的质量分数$q(c, o)$必须落在Phred分数的允许范围内。也就是说，对于给定的偏移量$o$，一个字符$c$是有效的，当且仅当：\n$$0 \\le q(c, o) \\le 41$$\n代入$q(c, o)$的定义，我们得到对该字符序数值的约束：\n$$0 \\le \\mathrm{ord}(c) - o \\le 41$$\n这个不等式可以重写为定义给定偏移量$o$的有效ASCII序数值的闭区间：\n$$o \\le \\mathrm{ord}(c) \\le o + 41$$\n\n我们现在可以为我们的两个特定假设定义有效的ASCII序数范围。\n\n对于假设$H_{33}$（Phred+33），其中偏移量为$o=33$：\n有效序数值的范围是$[33, 33+41]$，即$[33, 74]$。让我们将这组序数值表示为$\\mathcal{R}_{33}$。相应的ASCII字符范围从`!`（序数33）到`J`（序数74）。\n\n对于假设$H_{64}$（Phred+64），其中偏移量为$o=64$：\n有效序数值的范围是$[64, 64+41]$，即$[64, 105]$。让我们将这组序数值表示为$\\mathcal{R}_{64}$。相应的ASCII字符范围从`@`（序数64）到`i`（序数105）。\n\n我们统计检验的核心是一致性规则。一个给定的假设$H_o$被认为是可行的，当且仅当观测到的经验样本中的*所有*字符在该假设下都是有效的。设给定测试用例中观测到的字符的多重集为$C_{obs} = \\{c_1, c_2, \\dots, c_n\\}$，并设$O_{obs} = \\{\\mathrm{ord}(c_1), \\mathrm{ord}(c_2), \\dots, \\mathrm{ord}(c_n)\\}$为相应的序数值集合。\n\n假设$H_{33}$是可行的，当且仅当每个观测到的序数值都落在范围$\\mathcal{R}_{33}$内。数学上表示为$O_{obs} \\subseteq \\mathcal{R}_{33}$。\n假设$H_{64}$是可行的，当且仅当每个观测到的序数值都落在范围$\\mathcal{R}_{64}$内。数学上表示为$O_{obs} \\subseteq \\mathcal{R}_{64}$。\n\n这些集合包含条件可以通过检查观测到的序数值的最小值和最大值来高效地进行。设$o_{min} = \\min(O_{obs})$和$o_{max} = \\max(O_{obs})$。\n$H_{33}$的可行性条件，我们将其表示为布尔谓词$V_{33}$，是：\n$$V_{33} \\equiv (o_{min} \\ge 33) \\land (o_{max} \\le 74)$$\n$H_{64}$的可行性条件，表示为$V_{64}$，是：\n$$V_{64} \\equiv (o_{min} \\ge 64) \\land (o_{max} \\le 105)$$\n\n如果观测集$C_{obs}$为空，则$o_{min}$和$o_{max}$未定义。在这种特殊情况下，条件$O_{obs} \\subseteq \\mathcal{R}_{33}$和$O_{obs} \\subseteq \\mathcal{R}_{64}$是空真（vacuously true）的，使得两个假设都可行。\n\n利用这些谓词，我们可以构建一个确定性的决策规则：\n1.  如果$V_{33}$为真且$V_{64}$为假：数据唯一地与Phred+33编码一致。这意味着至少存在一个字符$c$其$\\mathrm{ord}(c)  64$。决策为$33$。\n2.  如果$V_{33}$为假且$V_{64}$为真：数据唯一地与Phred+64编码一致。这意味着至少存在一个字符$c$其$\\mathrm{ord}(c) > 74$。决策为$64$。\n3.  如果$V_{33}$为真且$V_{64}$为真：数据与两种编码方案都一致。这种情况发生当且仅当所有观测到的字符的序数值都在两个有效范围的交集内：$\\mathcal{R}_{33} \\cap \\mathcal{R}_{64} = [33, 74] \\cap [64, 105] = [64, 74]$。在这种情况下，根据给定的约束，编码是模糊的。决策为$0$（未定）。这个逻辑也覆盖了观测集为空的边缘情况。\n4.  如果$V_{33}$为假且$V_{64}$为假：数据与两个假设都不一致。如果样本中包含，例如，一个序数值小于33的字符，或一个跨越两个独立范围之外的字符组合（例如，一个字符的序数64，另一个的序数>74），就会发生这种情况。这样的数据将违反问题的前提，即存在一个有效的编码。由于无法做出明确的选择，这种情况也被归类为未定，决策为$0$。\n\n这套规则为任何给定的质量字符样本，提供了一个完整的、稳健的、且逻辑上推导出的算法，用于在$H_{33}$和$H_{64}$之间做出决策，或声明模糊性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Designs and implements a program to infer FASTQ quality encoding format.\n    The program performs a hypothesis test to decide between Phred+33 and Phred+64.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Typical Phred+33 scenario\n        [\"!!IIJJ\", \"!IJIJ\"],\n        # Case B: Typical Phred+64 scenario\n        [\"@@hhi\", \"hhi@@\"],\n        # Case C: Ambiguous scenario\n        [\"@ABCDEFGHIJ\"],\n        # Case D: Boundary ambiguous scenario\n        [\"@@@III\", \"@I@I@I\"],\n    ]\n\n    results = []\n    \n    # Define constants for the ordinal ranges based on the problem statement.\n    # For Phred+33 (o=33), valid quality scores q in [0, 41] map to ordinals in [33, 74].\n    PHRED33_ORD_MIN = 33\n    PHRED33_ORD_MAX = 74\n    \n    # For Phred+64 (o=64), valid quality scores q in [0, 41] map to ordinals in [64, 105].\n    PHRED64_ORD_MIN = 64\n    PHRED64_ORD_MAX = 105\n\n    for case in test_cases:\n        # Concatenate all quality strings in the case to get the full sample of characters.\n        all_chars = \"\".join(case)\n\n        # Handle the edge case of no character observations.\n        # If there are no characters, the data is consistent with both hypotheses (vacuously true),\n        # so the result is undetermined.\n        if not all_chars:\n            results.append(0)\n            continue\n            \n        # Convert all characters to their ASCII ordinal values.\n        ord_values = np.array([ord(c) for c in all_chars])\n        \n        # Find the minimum and maximum ordinal values in the sample.\n        o_min = ord_values.min()\n        o_max = ord_values.max()\n\n        # Determine if the observed range of ordinals is consistent with Phred+33.\n        # The entire sample must fall within the valid range for Phred+33.\n        is_valid_33 = (o_min >= PHRED33_ORD_MIN) and (o_max = PHRED33_ORD_MAX)\n        \n        # Determine if the observed range of ordinals is consistent with Phred+64.\n        # The entire sample must fall within the valid range for Phred+64.\n        is_valid_64 = (o_min >= PHRED64_ORD_MIN) and (o_max = PHRED64_ORD_MAX)\n\n        # Apply the decision rule derived from the consistency checks.\n        if is_valid_33 and not is_valid_64:\n            # The data is only consistent with Phred+33.\n            decision = 33\n        elif not is_valid_33 and is_valid_64:\n            # The data is only consistent with Phred+64.\n            decision = 64\n        elif is_valid_33 and is_valid_64:\n            # The data is consistent with both. All characters fall in the\n            # overlapping ordinal range [64, 74]. The encoding is ambiguous.\n            decision = 0\n        else: # not is_valid_33 and not is_valid_64\n            # The data is inconsistent with both schemas. This case is also ambiguous\n            # or indicates invalid data; it cannot be determined.\n            decision = 0\n            \n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4590262"}, {"introduction": "一旦我们能够准确地读取碱基质量分数，下一步就是利用这些信息来提升数据质量。测序读段（read）的质量通常会向3'端下降，这些低质量的尾部会干扰比对和变异检测的准确性。本练习将让你亲手应用一种名为“滑动窗口修剪”的核心算法[@problem_id:4590261]，通过计算来决定保留读段的哪些部分，从而确保只有高质量的数据进入后续分析。", "problem": "一个测序中心通过新一代测序（NGS）生成了五条读长（read），每条读长都附有逐个碱基的Phred质量分数。Phred质量分数（Phred）定义为 $Q = -10 \\log_{10}(p)$，其中 $p$ 是碱基被错误判定的概率。在NGS数据质量控制中，一个广泛使用且经过充分检验的启发式方法是滑动窗口修剪：从读长的$5'$端开始，使用一个大小为$w$的固定窗口进行扫描，计算窗口内Phred分数的算术平均值。如果窗口的平均值低于指定的阈值，则从该窗口的起始位置修剪读长（即丢弃该窗口及其所有下游碱基）。这种方法通过移除低置信度区域，提高了下游比对和变异检测的稳健性。\n\n考虑窗口大小$w = 4$和平均质量阈值$Q \\ge 20$。对于每条读长，设其质量序列为$Q_{1}, Q_{2}, \\dots, Q_{n}$，采用从1开始的索引。定义窗口平均值为$M_{i} = \\frac{1}{4}\\left(Q_{i} + Q_{i+1} + Q_{i+2} + Q_{i+3}\\right)$，其中$i = 1, 2, \\dots, n-3$。修剪规则如下：\n- 找到满足$M_{k}  20$的最小索引$k$。如果存在这样的$k$，则从第$k$个碱基开始修剪读长（保留第1到第$k-1$个碱基）；如果不存在这样的$k$，则保留长度为$n$的整条读长。\n\n给定以下五个质量字符串（已转换为Phred $Q$值的数值单位），应用上述修剪规则，并报告每条读长修剪后保留的碱基数量。将最终结果表示为一个包含五个数字的单行矩阵（无单位），按顺序对应于读长1到5。\n\n读长1：$31, 30, 29, 30, 28, 27, 26, 25, 24, 23, 22, 21, 18, 17, 16, 15$\n\n读长2：$25, 24, 23, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29$\n\n读长3：$28, 29, 30, 31, 27, 26, 25, 24, 23, 22, 21, 20, 20, 21, 22, 23$\n\n读长4：$35, 34, 10, 10, 10, 10, 10, 10, 30, 30, 30, 30, 30, 30, 30, 30$\n\n读长5：$20, 20, 20, 20, 20, 19, 19, 19, 19, 18, 18, 18, 21, 22, 23, 24$\n\n无需四舍五入；报告精确的整数形式的保留碱基长度。", "solution": "该问题定义明确，具有生物信息学领域的科学依据，并提供了进行计算所需的所有信息。我们的任务是，对五个Phred质量分数序列应用滑动窗口修剪算法。窗口大小为$w=4$，平均质量阈值为$20$。对于每条由其质量序列$Q_1, Q_2, \\dots, Q_n$描述的读长，我们计算窗口平均值$M_i = \\frac{1}{4}(Q_i + Q_{i+1} + Q_{i+2} + Q_{i+3})$。我们必须找到满足$M_k  20$的最小索引$k$。如果找到这样的$k$，则修剪该读长，保留的碱基数量为$k-1$。如果不存在这样的$k$，则保留长度为$n$的整条读长。所有读长的长度均为$n=16$。\n\n读长1：$Q^{(1)} = (31, 30, 29, 30, 28, 27, 26, 25, 24, 23, 22, 21, 18, 17, 16, 15)$。\n我们依次计算窗口平均值：\n$M_1 = \\frac{1}{4}(31+30+29+30) = \\frac{120}{4} = 30.0 \\ge 20$。\n$M_2 = \\frac{1}{4}(30+29+30+28) = \\frac{117}{4} = 29.25 \\ge 20$。\n$M_3 = \\frac{1}{4}(29+30+28+27) = \\frac{114}{4} = 28.5 \\ge 20$。\n$M_4 = \\frac{1}{4}(30+28+27+26) = \\frac{111}{4} = 27.75 \\ge 20$。\n$M_5 = \\frac{1}{4}(28+27+26+25) = \\frac{106}{4} = 26.5 \\ge 20$。\n$M_6 = \\frac{1}{4}(27+26+25+24) = \\frac{102}{4} = 25.5 \\ge 20$。\n$M_7 = \\frac{1}{4}(26+25+24+23) = \\frac{98}{4} = 24.5 \\ge 20$。\n$M_8 = \\frac{1}{4}(25+24+23+22) = \\frac{94}{4} = 23.5 \\ge 20$。\n$M_9 = \\frac{1}{4}(24+23+22+21) = \\frac{90}{4} = 22.5 \\ge 20$。\n$M_{10} = \\frac{1}{4}(23+22+21+18) = \\frac{84}{4} = 21.0 \\ge 20$。\n$M_{11} = \\frac{1}{4}(22+21+18+17) = \\frac{78}{4} = 19.5  20$。\n平均值小于$20$的最小索引是$k=11$。该读长被修剪，保留第1至$k-1 = 10$个碱基。保留的碱基数量为$10$。\n\n读长2：$Q^{(2)} = (25, 24, 23, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29)$。\n$M_1 = \\frac{1}{4}(25+24+23+15) = \\frac{87}{4} = 21.75 \\ge 20$。\n$M_2 = \\frac{1}{4}(24+23+15+16) = \\frac{78}{4} = 19.5  20$。\n最小索引是$k=2$。该读长被修剪，保留第1至$k-1=1$个碱基。保留的碱基数量为$1$。\n\n读长3：$Q^{(3)} = (28, 29, 30, 31, 27, 26, 25, 24, 23, 22, 21, 20, 20, 21, 22, 23)$。\n$M_1 = \\frac{1}{4}(28+29+30+31) = \\frac{118}{4} = 29.5 \\ge 20$。\n$M_2 = \\frac{1}{4}(29+30+31+27) = \\frac{117}{4} = 29.25 \\ge 20$。\n$M_3 = \\frac{1}{4}(30+31+27+26) = \\frac{114}{4} = 28.5 \\ge 20$。\n...（继续此过程）...\n$M_9 = \\frac{1}{4}(23+22+21+20) = \\frac{86}{4} = 21.5 \\ge 20$。\n$M_{10} = \\frac{1}{4}(22+21+20+20) = \\frac{83}{4} = 20.75 \\ge 20$。\n$M_{11} = \\frac{1}{4}(21+20+20+21) = \\frac{82}{4} = 20.5 \\ge 20$。\n$M_{12} = \\frac{1}{4}(20+20+21+22) = \\frac{83}{4} = 20.75 \\ge 20$。\n$M_{13} = \\frac{1}{4}(20+21+22+23) = \\frac{86}{4} = 21.5 \\ge 20$。\n所有可能的窗口平均值都大于或等于$20$。不进行修剪。保留整条读长。保留的碱基数量为$n=16$。\n\n读长4：$Q^{(4)} = (35, 34, 10, 10, 10, 10, 10, 10, 30, 30, 30, 30, 30, 30, 30, 30)$。\n$M_1 = \\frac{1}{4}(35+34+10+10) = \\frac{89}{4} = 22.25 \\ge 20$。\n$M_2 = \\frac{1}{4}(34+10+10+10) = \\frac{64}{4} = 16  20$。\n最小索引是$k=2$。该读长被修剪，保留第1至$k-1=1$个碱基。保留的碱基数量为$1$。\n\n读长5：$Q^{(5)} = (20, 20, 20, 20, 20, 19, 19, 19, 19, 18, 18, 18, 21, 22, 23, 24)$。\n$M_1 = \\frac{1}{4}(20+20+20+20) = \\frac{80}{4} = 20.0 \\ge 20$。\n$M_2 = \\frac{1}{4}(20+20+20+20) = \\frac{80}{4} = 20.0 \\ge 20$。\n$M_3 = \\frac{1}{4}(20+20+20+19) = \\frac{79}{4} = 19.75  20$。\n最小索引是$k=3$。该读长被修剪，保留第1至$k-1=2$个碱基。保留的碱基数量为$2$。\n\n五条读长各自保留的碱基数量分别为$10, 1, 16, 1, 2$。将这些数字整理成一个单行矩阵。", "answer": "$$ \\boxed{ \\begin{pmatrix} 10  1  16  1  2 \\end{pmatrix} } $$", "id": "4590261"}, {"introduction": "数据预处理的质量控制不仅限于读段本身，还包括评估它们在基因组上的比对置信度。比对质量（Mapping Quality, MAPQ）是衡量这一置信度的关键指标，但它的数学含义常常被误解。本练习通过一个多重比对（multi-mapping）的典型场景，引导你从第一性原理出发，推导MAPQ值[@problem_id:4590216]，从而深刻理解其背后的概率论基础以及它为何是过滤不可靠比对的关键。", "problem": "一份来自人类全基因组测定的单端新一代测序 (NGS) 读段，其长度为 $150$ 个核苷酸，由一个标准的短读段比对器进行处理。该比对器在位置独立的伯努利误差假设下，使用基于碱基的对数似然模型为比对评分。对于这个特定的读段，比对器识别出恰好两个基因组位点具有相同的最优比对分数（相同的错配和缺口模式），这两个位点都位于一个已知的、具有相同可比对性的重复区域。比对器报告其中一个为主比对，并通过打破平局的方式抑制了另一个，而不使用额外的上下文信息。假设序列比对/图谱 (SAM) 规范中使用的比对质量 (MAPQ) 代表报告的比对不正确的Phred定标后验概率。在这些假设下，请首先从第一性原理出发，量化错误比对的后验概率，从而推导出所报告主比对的隐含MAPQ值。然后，解释在典型的预处理流程中，当控制错误比对读段的预期比例时，这样的值如何为下游过滤阈值的设定提供依据。将最终的MAPQ数值四舍五入到四位有效数字。将最终的MAPQ表示为无量纲量。", "solution": "该问题要求推导一个单端新一代测序 (NGS) 读段的比对质量 (MAPQ)，该读段以相同的最优分数比对到恰好两个基因组位点。问题还要求解释该值如何为下游过滤提供信息。\n\n### 步骤1：问题验证\n\n**1.1. 提取已知条件**\n- 读段长度：$150$ 个核苷酸。\n- 等价最优比对位点数：$2$。\n- 这些位点的比对分数：相同且最优。\n- 位点属性：位于已知的重复区域，具有相同的可比对性。\n- 比对器行为：报告一个比对为主比对，并通过打破平局的方式抑制另一个，不使用额外信息。\n- MAPQ的定义：报告的比对不正确的Phred定标后验概率。\n- MAPQ公式：$MAPQ = -10 \\log_{10}(P_{\\text{incorrect}})$。\n- 要求精度：将最终的MAPQ数值四舍五入到四位有效数字。\n\n**1.2. 使用提取的已知条件进行验证**\n该问题具有科学依据，描述了短读段比对中一个标准且常见的场景，即一个读段同等地比对到基因组的多个位置（多重比对），尤其是在重复元件内。MAPQ作为比对错误Phred定标后验概率的概念，是广泛使用的序列比对/图谱 (SAM) 格式的基石。该问题提法明确，提供了一个简化但完整的场景，包含了从第一性原理推导后验概率所需的所有信息。语言客观，并使用了标准的生物信息学术语。前提条件没有矛盾、不切实际或提法不当之处。\n\n**1.3. 结论与行动**\n问题有效。将提供一个合理的解决方案。\n\n### 步骤2：MAPQ的推导\n\n问题的核心在于使用贝叶斯框架计算正确比对的后验概率。\n\n令 $R$ 表示观测到的序列读段。令 $L_1$ 和 $L_2$ 为该读段以相同最优分数比对到的两个不同基因组位点。根据题意，到所有其他可能位点的比对都是次优的，意味着它们的似然与之相比可以忽略不计。因此，我们只需要考虑 $L_1$ 和 $L_2$ 作为读段可能的真实来源。\n\n在给定读段数据 $R$ 的情况下，读段起源于特定位点 $L_i$ 的后验概率由贝叶斯定理给出：\n$$P(L_i | R) = \\frac{P(R | L_i) P(L_i)}{\\sum_{j} P(R | L_j) P(L_j)}$$\n其中：\n- $P(L_i | R)$ 是读段起源于位点 $L_i$ 的后验概率。\n- $P(R | L_i)$ 是在给定读段起源于位点 $L_i$ 的情况下，观测到读段 $R$ 的似然。该项与比对分数直接相关。\n- $P(L_i)$ 是读段起源于位点 $L_i$ 的先验概率。\n\n根据问题陈述：\n1.  对于$L_1$和$L_2$，比对分数是相同的。由于比对器使用对数似然评分模型，相同的分数意味着相同的似然。\n    $$P(R | L_1) = P(R | L_2)$$\n2.  这两个位点具有“相同的可比对性”。在贝叶斯框架下，这被解释为读段起源于任一位点的先验概率相等。\n    $$P(L_1) = P(L_2)$$\n3.  到所有其他位点的比对被认为概率可忽略不计。因此，贝叶斯定理分母中的求和仅限于$L_1$和$L_2$这两个位点。\n\n我们来计算位点$L_1$的后验概率：\n$$P(L_1 | R) = \\frac{P(R | L_1) P(L_1)}{P(R | L_1) P(L_1) + P(R | L_2) P(L_2)}$$\n代入我们假设中的等式：\n$$P(L_1 | R) = \\frac{P(R | L_1) P(L_1)}{P(R | L_1) P(L_1) + P(R | L_1) P(L_1)} = \\frac{P(R | L_1) P(L_1)}{2 \\cdot P(R | L_1) P(L_1)}$$\n由于似然和先验概率非零，我们可以消去分子和分母中的项 $P(R | L_1) P(L_1)$：\n$$P(L_1 | R) = \\frac{1}{2}$$\n根据对称性，位点$L_2$的后验概率也是：\n$$P(L_2 | R) = \\frac{1}{2}$$\n后验概率之和为 $P(L_1 | R) + P(L_2 | R) = \\frac{1}{2} + \\frac{1}{2} = 1$，符合预期。\n\n比对器将其中一个比对——比如说，到$L_1$的比对——报告为主比对。如果读段的真实来源不是$L_1$，则报告的比对被认为是不正确的。在我们的模型中，唯一的另一种可能性是真实来源为$L_2$。\n\n因此，报告的比对不正确的后验概率 $P_{\\text{incorrect}}$，是在给定读段数据$R$的情况下，真实来源为$L_2$的概率：\n$$P_{\\text{incorrect}} = P(\\text{真实来源是 } L_2 | R) = P(L_2 | R) = \\frac{1}{2}$$\n或者，$P_{\\text{incorrect}} = 1 - P_{\\text{correct}} = 1 - P(L_1 | R) = 1 - \\frac{1}{2} = \\frac{1}{2}$。\n\n现在，我们可以使用给定的公式计算比对质量 (MAPQ)：\n$$MAPQ = -10 \\log_{10}(P_{\\text{incorrect}})$$\n代入 $P_{\\text{incorrect}} = \\frac{1}{2}$：\n$$MAPQ = -10 \\log_{10}\\left(\\frac{1}{2}\\right)$$\n使用对数性质 $\\log(1/x) = -\\log(x)$：\n$$MAPQ = 10 \\log_{10}(2)$$\n使用数值 $\\log_{10}(2) \\approx 0.30102999...$：\n$$MAPQ \\approx 10 \\times 0.30102999 \\approx 3.0102999$$\n四舍五入到四位有效数字，我们得到：\n$$MAPQ \\approx 3.010$$\n\n### 步骤3：下游过滤阈值的动机\n\n计算出的MAPQ分数约等于$3$，这是一个极低的值。低的MAPQ分数表示读段定位的高度不确定性。关系式 $P_{\\text{incorrect}} = 10^{-MAPQ/10}$ 量化了这种不确定性。\n- 对于$MAPQ = 3$，$P_{\\text{incorrect}} = 10^{-3/10} = 10^{-0.3} \\approx 0.501$，这基本上是$50\\%$的错误概率。\n- 作为比较，变异检测流程中常用的最低MAPQ阈值是$20$。这对应于错误概率 $P_{\\text{incorrect}} = 10^{-20/10} = 10^{-2} = 0.01$，即$1\\%$的错误概率。\n- 一个更严格的阈值$MAPQ=30$意味着 $P_{\\text{incorrect}} = 10^{-30/10} = 10^{-3} = 0.001$，即$0.1\\%$的错误概率。\n\nMAPQ值直接反映了比对的可靠性。许多下游基因组学分析，如单核苷酸多态性 (SNP) 检测、结构变异检测或差异基因表达分析，都对比对错误高度敏感。一个错误比对的读段可能导致假阳性的变异检出或不正确的表达定量。\n\n通过设置MAPQ阈值（例如，$MAPQ \\ge 20$），生物信息学家可以过滤掉那些位置不明确的读段，比如本问题中描述的这个。这个过程是一个关键的质量控制步骤，旨在控制用于分析的数据集中错误比对读段的预期比例。移除$MAPQ  20$的读段可以有效地丢弃那些错误概率大于$1\\%$的比对，从而提高最终生物学结论的整体准确性和可靠性。$MAPQ \\approx 3$这个值是分配给多重比对读段的一个经典分数示例，几乎所有标准过滤方案都会丢弃这样的读段。", "answer": "$$\n\\boxed{3.010}\n$$", "id": "4590216"}]}