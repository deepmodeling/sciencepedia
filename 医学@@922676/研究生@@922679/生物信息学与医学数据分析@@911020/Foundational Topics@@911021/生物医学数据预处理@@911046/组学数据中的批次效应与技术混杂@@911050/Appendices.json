{"hands_on_practices": [{"introduction": "在分析组学数据时，第一步往往是评估不希望的变异来源。本练习介绍了一种基础但强大的方法：使用方差分析 (ANOVA) 来量化批次效应对总数据变异的贡献。通过将总方差分解为批次间和批次内分量，我们可以得出一个明确的比例，从而直观地了解技术混淆的严重程度。[@problem_id:4541223]", "problem": "一位研究人员正在研究一个转录组学实验中的技术混杂因素，并希望量化在一个看家基因的表达中，观测到的变异性有多大比例可归因于测序批次。一个均质参考样本被分装并在三个测序批次中进行处理。对于每个批次，使用RNA测序（RNA-seq）测量了四个技术重复样本，得到的该基因的对数转换表达值（以$2$为底的每百万转录本）如下：\n\n批次 $1$：$8.2$、$7.9$、$8.3$、$8.0$。\n\n批次 $2$：$9.4$、$9.6$、$9.5$、$9.7$。\n\n批次 $3$：$10.0$、$10.4$、$10.3$、$10.1$。\n\n假设一个固定效应单因素模型，其中批次是唯一的系统性因素，所有其他变异都是独立的测量噪声。运用方差分析（ANOVA）的原理，从第一性原理推导测量值中可归因于批次的总变异性比例，并计算给定数据的数值。将此比例表示为小数，并将答案四舍五入至四位有效数字。计算完该比例后，请结合组学数据中的批次效应和技术混杂因素，简要解释其数值大小的意义。", "solution": "我们使用固定效应单因素模型来建模对数表达测量值：\n$$\ny_{ij} = \\mu + \\beta_{k} + \\epsilon_{ij},\n$$\n其中，$y_{ij}$ 是批次 $k$ 中重复样本 $j$ 的测量值，$\\mu$ 是总均值，$\\beta_{k}$ 是批次 $k$ 的批次效应，$\\epsilon_{ij}$ 是均值为 $0$ 且在各重复样本间独立的残差噪声。\n\n在标准的单因素方差分析（ANOVA）框架下，围绕总均值的总变异性可以分解为批次间和批次内两个部分。设 $y_{\\cdot\\cdot}$ 表示所有 $N$ 个观测值的总均值，设 $y_{k\\cdot}$ 表示有 $n_{k}$ 个重复样本的批次 $k$ 内的均值。总平方和为\n$$\n\\text{SS}_{\\text{total}} = \\sum_{k} \\sum_{j=1}^{n_{k}} \\left(y_{kj} - y_{\\cdot\\cdot}\\right)^{2},\n$$\n批次间（可归因于批次的）平方和为\n$$\n\\text{SS}_{\\text{batch}} = \\sum_{k} n_{k} \\left(y_{k\\cdot} - y_{\\cdot\\cdot}\\right)^{2}.\n$$\n由批次解释的方差比例则为\n$$\nR^{2}_{\\text{batch}} = \\frac{\\text{SS}_{\\text{batch}}}{\\text{SS}_{\\text{total}}}.\n$$\n\n我们现在根据数据计算这些量。\n\n共有 $3$ 个批次，每个批次有 $n_{k} = 4$ 个重复样本，因此总观测值为 $N = 12$。首先计算各批次均值和总均值。\n\n批次 $1$ 的值：$8.2$、$7.9$、$8.3$、$8.0$。批次 $1$ 的均值为\n$$\ny_{1\\cdot} = \\frac{8.2 + 7.9 + 8.3 + 8.0}{4} = \\frac{32.4}{4} = 8.1.\n$$\n批次 $2$ 的值：$9.4$、$9.6$、$9.5$、$9.7$。批次 $2$ 的均值为\n$$\ny_{2\\cdot} = \\frac{9.4 + 9.6 + 9.5 + 9.7}{4} = \\frac{38.2}{4} = 9.55.\n$$\n批次 $3$ 的值：$10.0$、$10.4$、$10.3$、$10.1$。批次 $3$ 的均值为\n$$\ny_{3\\cdot} = \\frac{10.0 + 10.4 + 10.3 + 10.1}{4} = \\frac{40.8}{4} = 10.2.\n$$\n总均值为\n$$\ny_{\\cdot\\cdot} = \\frac{32.4 + 38.2 + 40.8}{12} = \\frac{111.4}{12} = 9.283\\overline{3}.\n$$\n\n计算 $\\text{SS}_{\\text{total}}$：\n对于批次 $1$，与 $y_{\\cdot\\cdot}$ 的偏差为 $8.2 - 9.283\\overline{3} = -1.083\\overline{3}$，$7.9 - 9.283\\overline{3} = -1.383\\overline{3}$，$8.3 - 9.283\\overline{3} = -0.983\\overline{3}$，$8.0 - 9.283\\overline{3} = -1.283\\overline{3}$。偏差的平方和为\n$$\n1.1736111111 + 1.9136111111 + 0.9669444444 + 1.6469444444 = 5.7011111111.\n$$\n对于批次 $2$，偏差为 $9.4 - 9.283\\overline{3} = 0.116\\overline{6}$，$9.6 - 9.283\\overline{3} = 0.316\\overline{6}$，$9.5 - 9.283\\overline{3} = 0.216\\overline{6}$，$9.7 - 9.283\\overline{3} = 0.416\\overline{6}$。偏差的平方和为\n$$\n0.0136111111 + 0.1002777778 + 0.0469444444 + 0.1736111111 = 0.3344444444.\n$$\n对于批次 $3$，偏差为 $10.0 - 9.283\\overline{3} = 0.716\\overline{6}$，$10.4 - 9.283\\overline{3} = 1.116\\overline{6}$，$10.3 - 9.283\\overline{3} = 1.016\\overline{6}$，$10.1 - 9.283\\overline{3} = 0.816\\overline{6}$。偏差的平方和为\n$$\n0.5136111111 + 1.2469444444 + 1.0336111111 + 0.6669444444 = 3.4611111111.\n$$\n因此，\n$$\n\\text{SS}_{\\text{total}} = 5.7011111111 + 0.3344444444 + 3.4611111111 = 9.4966666666\\overline{6}.\n$$\n\n计算 $\\text{SS}_{\\text{batch}}$：\n对每个批次使用 $n_{k} = 4$，\n$$\n\\text{SS}_{\\text{batch}} = \\sum_{k=1}^{3} 4 \\left(y_{k\\cdot} - y_{\\cdot\\cdot}\\right)^{2}\n= 4\\left[(8.1 - 9.283\\overline{3})^{2} + (9.55 - 9.283\\overline{3})^{2} + (10.2 - 9.283\\overline{3})^{2}\\right].\n$$\n计算均值偏差：\n$$\n8.1 - 9.283\\overline{3} = -1.183\\overline{3}, \\quad 9.55 - 9.283\\overline{3} = 0.266\\overline{6}, \\quad 10.2 - 9.283\\overline{3} = 0.916\\overline{6}.\n$$\n平方：\n$$\n(-1.183\\overline{3})^{2} = 1.4002777777\\overline{7}, \\quad (0.266\\overline{6})^{2} = 0.0711111111, \\quad (0.916\\overline{6})^{2} = 0.8402777777\\overline{7}.\n$$\n方括号内的和为\n$$\n1.4002777777\\overline{7} + 0.0711111111 + 0.8402777777\\overline{7} = 2.3116666666\\overline{6}.\n$$\n乘以 $4$ 得到\n$$\n\\text{SS}_{\\text{batch}} = 4 \\times 2.3116666666\\overline{6} = 9.2466666666\\overline{6}.\n$$\n\n因此，\n$$\nR^{2}_{\\text{batch}} = \\frac{\\text{SS}_{\\text{batch}}}{\\text{SS}_{\\text{total}}} = \\frac{9.2466666666\\overline{6}}{9.4966666666\\overline{6}}.\n$$\n为求精确，注意到 $\\text{SS}_{\\text{batch}} = \\frac{8322}{900}$ 且 $\\text{SS}_{\\text{total}} = \\frac{34188}{3600}$，因此\n$$\nR^{2}_{\\text{batch}} = \\frac{8322/900}{34188/3600} = \\frac{33288}{34188} = \\frac{2774}{2849}.\n$$\n数值上，\n$$\nR^{2}_{\\text{batch}} \\approx 0.9736746073.\n$$\n四舍五入至四位有效数字，结果为\n$$\n0.9737.\n$$\n\n解释：$R^{2}_{\\text{batch}} \\approx 0.9737$ 表明，在这些技术重复样本中，批次解释了该基因测量表达值总变异性的大约 $0.9737$。在组学数据的背景下，如此高的比例意味着存在主导性的批次效应，即技术混杂因素是观测变异的主要驱动因素。除非对批次效应进行适当建模和移除（例如，通过考虑批次的线性建模或经验贝叶斯调整），否则下游分析（例如，不同生物条件下的差异表达）将产生严重偏差，因为真实的生物信号在很大程度上被技术变异性所掩盖。", "answer": "$$\\boxed{0.9737}$$", "id": "4541223"}, {"introduction": "在量化了批次效应的潜在影响后，一个更严重的问题是实验设计本身是否存在根本性缺陷。当生物学变量与技术批次完全混淆时，它们的影响在数学上是无法区分的，这使得任何关于生物学效应的结论都无效。本练习将指导您使用线性代数原理，特别是矩阵投影，来设计一个算法，以系统地检测这种“完全混淆”的情况，从而在分析开始之前识别出关键的设计问题。[@problem_id:4541218]", "problem": "给定用于多组学分析场景的两个设计矩阵：每个场景都有一个批次矩阵和一个表型矩阵。批次矩阵将技术批次编码为指示符列，而表型矩阵将生物学分组或结果编码为指示符列或连续列。利用线性代数，设计并实现一个算法，通过确定表型矩阵是否完全位于批次矩阵的列空间内来检测完全混淆。然后，根据检测结果，以整数决策代码的形式，指定在分析或设计阶段应采取的纠正措施。\n\n基本原理：\n- 设 $B \\in \\mathbb{R}^{n \\times b}$ 为批次设计矩阵，有 $n$ 个样本和 $b$ 个批次列（例如，独热编码的批次指示符）。\n- 设 $P \\in \\mathbb{R}^{n \\times p}$ 为表型设计矩阵，有 $p$ 个表型列（例如，指示符或连续编码）。\n- 设 $B^{+}$ 表示 $B$ 的 Moore–Penrose 伪逆。\n- 任何矩阵 $X \\in \\mathbb{R}^{n \\times k}$ 到 $B$ 的列空间上的正交投影为 $\\Pi_{B} X = B B^{+} X$。\n- 矩阵 $X$ 的弗罗贝尼乌斯范数为 $\\lVert X \\rVert_{F} = \\sqrt{\\sum_{i=1}^{n} \\sum_{j=1}^{k} x_{ij}^{2}}$。\n\n检测标准：\n- 计算残差矩阵 $R = P - \\Pi_{B} P = P - B B^{+} P$。\n- 计算相对残差比 $r = \\lVert R \\rVert_{F} / \\lVert P \\rVert_{F}$，约定如果 $\\lVert P \\rVert_{F} = 0$，则 $r = 0$。\n- 如果 $r \\le \\tau$，则判定为完全混淆，其中 $\\tau$ 是一个很小的数值容差。使用 $\\tau = 10^{-12}$。\n- 可选地，如果 $\\tau  r \\le \\eta$，则分类为近似混淆，其中 $\\eta$ 是一个实用阈值，表示表型在很大程度上（但非完全）可由批次解释。使用 $\\eta = 0.05$。\n\n纠正措施映射（决策代码）：\n- 如果检测到完全混淆（即 $r \\le \\tau$），返回决策代码 $1$，表示需要进行设计层面的校正。推荐的措施包括：收集具有不同批次分配的额外样本，重新随机化样本在各批次间的处理，或重新设计研究以确保生物学分组不与批次水平确定性地对齐。仅靠分析调整是不够的，因为模型无法独立于批次来识别生物学效应。\n- 如果检测到近似混淆（即 $\\tau  r \\le \\eta$），返回决策代码 $2$，表示应采用分析层面的校正。推荐的措施包括：在统计模型中将批次作为协变量，使用经验贝叶斯批次校正，或采用移除无用变异框架；此外，还应执行敏感性分析并考虑增加样本量并平衡批次分配。\n- 如果未检测到混淆（即 $r > \\eta$），返回决策代码 $0$，表示标准分析可以继续进行，并酌情将批次作为协变量并进行常规诊断检查。\n\n每个测试用例的输出规范：\n- 对于每个测试用例，输出一个包含两个元素的列表：第一个是布尔值，表示是否存在完全混淆（$\\text{True}$ 或 $\\text{False}$）；第二个是整数决策代码（$0$、$1$ 或 $2$）。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果。结果为一个由方括号括起来的、逗号分隔的二维元素列表，不含额外的空格或文本。例如：$[\\![\\text{True},1],[\\text{False},2]]$ 但不含空格。\n\n测试套件：\n- 使用以下五个场景。所有矩阵均已明确给出。\n\n情况 $1$（二元表型与批次完全混淆）：\n$$\nB_{1} = \\begin{bmatrix}\n1  0 \\\\\n1  0 \\\\\n1  0 \\\\\n1  0 \\\\\n0  1 \\\\\n0  1 \\\\\n0  1 \\\\\n0  1\n\\end{bmatrix}, \\quad\nP_{1} = \\begin{bmatrix}\n0 \\\\\n0 \\\\\n0 \\\\\n0 \\\\\n1 \\\\\n1 \\\\\n1 \\\\\n1\n\\end{bmatrix}.\n$$\n\n情况 $2$（二元表型与批次近似混淆，有少量噪声）：\n$$\nB_{2} = B_{1}, \\quad\nP_{2} = \\begin{bmatrix}\n0 + 0 \\\\\n0 + 0.01 \\\\\n0 - 0.02 \\\\\n0 + 0 \\\\\n1 + 0.015 \\\\\n1 - 0.01 \\\\\n1 + 0.02 \\\\\n1 + 0\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\\n0.01 \\\\\n-0.02 \\\\\n0 \\\\\n1.015 \\\\\n0.99 \\\\\n1.02 \\\\\n1\n\\end{bmatrix}.\n$$\n\n情况 $3$（连续表型与批次无混淆）：\n$$\nB_{3} = \\begin{bmatrix}\n1  0 \\\\\n0  1 \\\\\n1  0 \\\\\n0  1 \\\\\n1  0 \\\\\n0  1 \\\\\n1  0 \\\\\n0  1\n\\end{bmatrix}, \\quad\nP_{3} = \\begin{bmatrix}\n0.5 \\\\\n-0.1 \\\\\n1.2 \\\\\n0.3 \\\\\n-0.7 \\\\\n0.0 \\\\\n1.1 \\\\\n-0.4\n\\end{bmatrix}.\n$$\n\n情况 $4$（多类别表型与多批次完全混淆）：\n$$\nB_{4} = \\begin{bmatrix}\n1  0  0 \\\\\n1  0  0 \\\\\n1  0  0 \\\\\n0  1  0 \\\\\n0  1  0 \\\\\n0  1  0 \\\\\n0  0  1 \\\\\n0  0  1 \\\\\n0  0  1\n\\end{bmatrix}, \\quad\nP_{4} = \\begin{bmatrix}\n1  0  0 \\\\\n1  0  0 \\\\\n1  0  0 \\\\\n0  1  0 \\\\\n0  1  0 \\\\\n0  1  0 \\\\\n0  0  1 \\\\\n0  0  1 \\\\\n0  0  1\n\\end{bmatrix}.\n$$\n\n情况 $5$（边界情况：一个批次水平缺失，表型等于存在的批次指示符）：\n$$\nB_{5} = \\begin{bmatrix}\n1  0  0 \\\\\n1  0  0 \\\\\n0  1  0 \\\\\n0  1  0 \\\\\n1  0  0\n\\end{bmatrix}, \\quad\nP_{5} = \\begin{bmatrix}\n1 \\\\\n1 \\\\\n0 \\\\\n0 \\\\\n1\n\\end{bmatrix}.\n$$\n\n程序要求：\n- 使用上述定义实现算法，计算每个情况的 $r$ 值，并使用 $\\tau = 10^{-12}$ 和 $\\eta = 0.05$ 来决定分类和决策代码。\n- 生成单行输出，包含五个测试用例的结果列表，每个结果格式化为 $[\\text{布尔值},\\text{整数}]$，由逗号分隔，并用方括号括起，不含多余文本。例如：$[[\\text{True},1],[\\text{False},2],[\\text{False},0],[\\text{True},1],[\\text{True},1]]$，但实际值必须反映所提供案例的计算结果。", "solution": "用户提供的问题陈述已经过严格评估，并被确定为有效。它在科学上基于线性代数的既定原理及其在生物信息学统计建模中的应用。该问题定义明确、客观，并为确定性求解提供了一个完整且一致的设置。\n\n该问题要求开发一种算法，以检测组学数据中实验批次与生物表型之间的混淆。混淆会引入一种虚假关联，可能导致不正确的科学结论。在线性模型的情境下，当感兴趣的信号（表型）无法与技术变异源（批次）区分开时，就会发生混淆。此问题的严重程度可以通过表示这些因素的设计矩阵之间的几何关系来量化。\n\n设 $B \\in \\mathbb{R}^{n \\times b}$ 为 $n$ 个样本中 $b$ 个批次的设计矩阵，设 $P \\in \\mathbb{R}^{n \\times p}$ 为 $p$ 个表型的设计矩阵。当表型矩阵的列空间 $\\text{col}(P)$ 是批次矩阵列空间 $\\text{col}(B)$ 的子空间时，即发生完全混淆。此关系表示为 $\\text{col}(P) \\subseteq \\text{col}(B)$。\n\n该条件意味着表型列的任何线性组合也可以表示为批次列的线性组合。因此，任何将批次效应作为协变量的统计模型，例如 $Y = B\\alpha + P\\beta + \\epsilon$ 形式的线性模型，都将无法唯一地估计表型效应 $\\beta$，因为 $P$ 的列与 $B$ 的列线性相关。\n\n为了用算法检测此条件，我们使用正交投影的概念。到 $B$ 的列空间上的正交投影算子由 $\\Pi_{B} = B B^{+}$ 给出，其中 $B^{+}$ 是 $B$ 的 Moore-Penrose 伪逆。矩阵 $B^{+}$ 提供了 $B$ 的列的最佳线性组合的系数，以便在最小二乘意义上近似给定的向量。\n\n如果 $\\text{col}(P) \\subseteq \\text{col}(B)$，那么 $P$ 的每个列向量都已位于 $B$ 的列空间内。将这些向量投影到 $\\text{col}(B)$ 上不会改变它们。因此，完全混淆的条件等价于矩阵方程 $\\Pi_{B} P = P$。\n\n由于浮点运算的性质，直接进行等式检查是不可靠的。一种更稳健的方法是测量残差矩阵 $R$ 的大小，该矩阵捕获了 $P$ 中与 $B$ 的列空间正交的部分：\n$$\nR = P - \\Pi_{B} P = P - B B^{+} P = (I - B B^{+}) P\n$$\n其中 $I$ 是 $n \\times n$ 的单位矩阵。如果 $P$ 完全位于 $B$ 的列空间内，残差 $R$ 应为零矩阵。\n\n为了以一种与尺度无关的方式量化残差的“大小”，我们使用弗罗贝尼乌斯范数 $\\lVert \\cdot \\rVert_{F}$ 来计算相对残差比 $r$：\n$$\nr = \\frac{\\lVert R \\rVert_{F}}{\\lVert P \\rVert_{F}}\n$$\n$r=0$ 的值表示完全混淆。一个小的 $r$ 值表示近似混淆，即表型几乎完全由批次效应解释。问题定义了具体的阈值来分类混淆的程度：\n- 如果 $r \\le \\tau$，则判定为完全混淆，其中 $\\tau = 10^{-12}$ 是一个小的数值容差。这种情况至关重要，需要重新设计研究，因为任何事后统计调整都无法分离混淆的信号。指定的决策代码是 $1$。输出的布尔值为 $\\text{True}$。\n- 如果 $\\tau  r \\le \\eta$，则判定为近似混淆，其中 $\\eta = 0.05$ 是一个实用阈值。这种情况警告说，虽然表型效应在技术上是可估计的，但与批次效应的高度相关性可能导致不稳定的估计和降低的统计功效。细致的分析层面校正是必不可少的。指定的决策代码是 $2$。输出的布尔值为 $\\text{False}$。\n- 如果 $r > \\eta$，则判定为无显著混淆。标准分析可以继续进行，可能包括将批次作为协变量以减少方差。指定的决策代码是 $0$。输出的布尔值为 $\\text{False}$。\n\n对于每个测试用例 $(B, P)$，将实现的算法如下：\n1.  计算批次矩阵 $B$ 的 Moore-Penrose 伪逆 $B^{+}$。\n2.  计算表型矩阵到批次矩阵列空间上的投影：$\\Pi_{B} P = B (B^{+} P)$。\n3.  计算残差矩阵：$R = P - \\Pi_{B} P$。\n4.  计算残差矩阵的弗罗贝尼乌斯范数 $\\lVert R \\rVert_{F}$ 和原始表型矩阵的弗罗贝尼乌斯范数 $\\lVert P \\rVert_{F}$。\n5.  如果 $\\lVert P \\rVert_{F}$ 为零（或非常接近零），则比率定义为 $r=0$。否则，计算相对残差比 $r = \\lVert R \\rVert_{F} / \\lVert P \\rVert_{F}$。\n6.  将 $r$ 与阈值 $\\tau$ 和 $\\eta$ 进行比较，以确定完全混淆状态（布尔值）和适当的决策代码（整数：$0$、$1$ 或 $2$）。\n\n此过程将应用于五个提供的测试用例，以生成所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the confounding detection problem for a suite of test cases.\n    \"\"\"\n\n    # Define the numerical thresholds.\n    tau = 1e-12\n    eta = 0.05\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Binary phenotype perfectly confounded with batch\n        {\n            \"B\": np.array([\n                [1, 0], [1, 0], [1, 0], [1, 0],\n                [0, 1], [0, 1], [0, 1], [0, 1]\n            ], dtype=np.float64),\n            \"P\": np.array([\n                [0], [0], [0], [0],\n                [1], [1], [1], [1]\n            ], dtype=np.float64)\n        },\n        # Case 2: Binary phenotype nearly confounded with batch, small noise\n        {\n            \"B\": np.array([\n                [1, 0], [1, 0], [1, 0], [1, 0],\n                [0, 1], [0, 1], [0, 1], [0, 1]\n            ], dtype=np.float64),\n            \"P\": np.array([\n                [0.0], [0.01], [-0.02], [0.0],\n                [1.015], [0.99], [1.02], [1.0]\n            ], dtype=np.float64).reshape(-1, 1)\n        },\n        # Case 3: Continuous phenotype not confounded with batch\n        {\n            \"B\": np.array([\n                [1, 0], [0, 1], [1, 0], [0, 1],\n                [1, 0], [0, 1], [1, 0], [0, 1]\n            ], dtype=np.float64),\n            \"P\": np.array([\n                [0.5], [-0.1], [1.2], [0.3],\n                [-0.7], [0.0], [1.1], [-0.4]\n            ], dtype=np.float64)\n        },\n        # Case 4: Multi-class phenotype perfectly confounded with multi-batch\n        {\n            \"B\": np.array([\n                [1, 0, 0], [1, 0, 0], [1, 0, 0],\n                [0, 1, 0], [0, 1, 0], [0, 1, 0],\n                [0, 0, 1], [0, 0, 1], [0, 0, 1]\n            ], dtype=np.float64),\n            \"P\": np.array([\n                [1, 0, 0], [1, 0, 0], [1, 0, 0],\n                [0, 1, 0], [0, 1, 0], [0, 1, 0],\n                [0, 0, 1], [0, 0, 1], [0, 0, 1]\n            ], dtype=np.float64)\n        },\n        # Case 5: Boundary condition with an absent batch level\n        {\n            \"B\": np.array([\n                [1, 0, 0], [1, 0, 0],\n                [0, 1, 0], [0, 1, 0],\n                [1, 0, 0]\n            ], dtype=np.float64),\n            \"P\": np.array([\n                [1], [1], [0], [0], [1]\n            ], dtype=np.float64)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        B, P = case[\"B\"], case[\"P\"]\n\n        # Step 1: Compute Moore-Penrose pseudoinverse of B\n        B_plus = np.linalg.pinv(B)\n\n        # Step 2: Compute the projection of P onto the column space of B\n        P_proj = B @ (B_plus @ P)\n        \n        # Step 3: Compute the residual matrix\n        R = P - P_proj\n\n        # Step 4: Calculate the Frobenius norms\n        norm_R = np.linalg.norm(R, 'fro')\n        norm_P = np.linalg.norm(P, 'fro')\n        \n        # Step 5: Compute the relative residual ratio\n        if norm_P == 0:\n            r = 0.0\n        else:\n            r = norm_R / norm_P\n\n        # Step 6: Apply decision logic\n        is_perfect_confounding = (r = tau)\n        \n        if is_perfect_confounding:\n            decision_code = 1\n        elif r = eta:\n            decision_code = 2\n        else:\n            decision_code = 0\n            \n        results.append([is_perfect_confounding, decision_code])\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists adds spaces, so we remove them\n    # to match the strict output specification.\n    output_str = str(results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```", "id": "4541218"}]}