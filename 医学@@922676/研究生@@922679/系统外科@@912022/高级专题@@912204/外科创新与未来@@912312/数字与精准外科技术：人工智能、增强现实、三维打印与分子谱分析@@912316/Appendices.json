{"hands_on_practices": [{"introduction": "增强现实（AR）技术在外科手术中的一个核心挑战是确保虚拟信息与真实世界精确对齐。此练习旨在通过分析“运动到光子”延迟（motion-to-photon latency），将系统工程参数（如显示刷新率和处理时间）与关键的临床精度要求联系起来。通过这个计算实践，您将学习如何量化一个AR系统的性能，并判断其是否满足手术操作中对精度和实时性的严苛标准[@problem_id:5110434]。", "problem": "一个头部追踪光学透视式增强现实（AR）手术导航系统将解剖学引导信息叠加在外科医生的视野中。为确保虚拟叠加层与移动的手术器械尖端之间的精确配准，必须控制运动到光子（motion-to-photon）的延迟。该管线包括：带有曝光积分的相机传感、计算姿态估计与渲染、由显示器刷新引起的垂直同步门控，以及直到目标区域被照亮的光栅扫描输出。\n\n假设硬件特性和操作条件如下：\n- 显示器刷新频率为 $f = 60\\,\\mathrm{Hz}$（采样并保持），因此图像帧仅在刷新边界处呈现。\n- 相机曝光持续时间为 $T_{\\text{exp}} = 10\\,\\mathrm{ms}$，采样数据在曝光结束时可用于处理。\n- 姿态估计和渲染需要 $T_{\\text{proc}} = 20\\,\\mathrm{ms}$。\n- 从帧更新开始到目标区域像素被照亮，扫描输出时间为 $T_{\\text{scan}} = 8\\,\\mathrm{ms}$。\n- 预期的垂直同步（vsync）等待时间在一个刷新周期内均匀分布，因此取其期望值为刷新周期的一半。\n\n术中精度要求规定，相对于器械尖端，叠加层的失准不应超过 $d = 0.5\\,\\mathrm{mm}$。在精细操作期间，尖端速度可达 $v = 30\\,\\mathrm{mm/s}$。使用位移和延迟之间的运动学关系 $d = v \\, t$ 来确定叠加层对齐所允许的最大延迟 $L_{\\max}$。\n\n从第一性原理和核心定义出发，推导：\n1. 此AR管线的预期运动到光子延迟 $L$，其值为曝光完成、处理、预期vsync等待和扫描输出时间之和。\n2. 根据位移约束 $d = v \\, t$ 得出的最大允许延迟 $L_{\\max}$。\n\n将由重投影（异步时间扭曲）引起的所需延迟缩减定义为 $R = \\max\\!\\big(0,\\, L - L_{\\max}\\big)$。\n\n计算 $R$ 并以毫秒为单位表示您的最终数值答案。将答案四舍五入至四位有效数字。在最终的方框答案中不要包含单位。", "solution": "该问题要求计算增强现实（AR）手术导航系统所需的延迟缩减量 $R$。该量定义为 $R = \\max\\!\\big(0,\\, L - L_{\\max}\\big)$，其中 $L$ 是系统的预期运动到光子延迟，而 $L_{\\max}$ 是为满足特定精度要求所允许的最大延迟。求解过程将首先推导 $L$ 和 $L_{\\max}$ 的表达式，然后计算 $R$ 的最终值。\n\n首先，我们确定预期的运动到光子延迟 $L$。问题指出，该延迟是处理管线中几个连续延迟的总和。这些组成部分是：相机曝光、处理、垂直同步（vsync）等待和显示扫描输出。总延迟 $L$ 的模型由下式给出：\n$$L = T_{\\text{exp}} + T_{\\text{proc}} + T_{\\text{vsync\\_wait}} + T_{\\text{scan}}$$\n给定的固定延迟值为：\n- 相机曝光持续时间，$T_{\\text{exp}} = 10\\,\\mathrm{ms}$。问题指明，在一个简单的延迟求和模型中，直接使用此值作为“曝光完成”部分。\n- 姿态估计和渲染时间，$T_{\\text{proc}} = 20\\,\\mathrm{ms}$。\n- 光栅扫描输出时间，$T_{\\text{scan}} = 8\\,\\mathrm{ms}$。\n\nvsync等待时间 $T_{\\text{vsync\\_wait}}$ 是一个可变延迟，取决于渲染完成的帧相对于显示器刷新周期的时刻。给定的显示器刷新频率为 $f = 60\\,\\mathrm{Hz}$。单个刷新周期的持续时间 $T_{\\text{period}}$ 是频率的倒数：\n$$T_{\\text{period}} = \\frac{1}{f} = \\frac{1}{60}\\,\\mathrm{s}$$\n为保持单位一致，我们将此周期转换为毫秒：\n$$T_{\\text{period}} = \\frac{1}{60}\\,\\mathrm{s} \\times \\frac{1000\\,\\mathrm{ms}}{1\\,\\mathrm{s}} = \\frac{100}{6}\\,\\mathrm{ms} = \\frac{50}{3}\\,\\mathrm{ms}$$\n问题指出，vsync等待时间在一个刷新周期内均匀分布。在区间 $[0, T_{\\text{period}}]$ 上均匀分布的随机变量的期望值是该区间长度的一半。因此，预期的vsync等待时间为：\n$$T_{\\text{vsync\\_wait}} = \\frac{1}{2} T_{\\text{period}} = \\frac{1}{2} \\times \\frac{50}{3}\\,\\mathrm{ms} = \\frac{25}{3}\\,\\mathrm{ms}$$\n现在，我们可以通过将各部分相加来计算总预期延迟 $L$：\n$$L = 10\\,\\mathrm{ms} + 20\\,\\mathrm{ms} + \\frac{25}{3}\\,\\mathrm{ms} + 8\\,\\mathrm{ms}$$\n$$L = (10 + 20 + 8)\\,\\mathrm{ms} + \\frac{25}{3}\\,\\mathrm{ms} = 38\\,\\mathrm{ms} + \\frac{25}{3}\\,\\mathrm{ms}$$\n$$L = \\frac{3 \\times 38}{3}\\,\\mathrm{ms} + \\frac{25}{3}\\,\\mathrm{ms} = \\frac{114 + 25}{3}\\,\\mathrm{ms} = \\frac{139}{3}\\,\\mathrm{ms}$$\n\n接下来，我们确定最大允许延迟 $L_{\\max}$。这源于术中精度要求，该要求规定，当器械尖端以高达 $30\\,\\mathrm{mm/s}$ 的速度 $v$ 移动时，动态失准（位移）$d$ 不应超过 $0.5\\,\\mathrm{mm}$。位移、速度和时间（延迟）之间的运动学关系是 $d = v \\, t$。求解时间，即我们的最大允许延迟 $L_{\\max}$，我们得到：\n$$L_{\\max} = \\frac{d}{v}$$\n代入给定值：\n- $d = 0.5\\,\\mathrm{mm}$\n- $v = 30\\,\\mathrm{mm/s}$\n$$L_{\\max} = \\frac{0.5\\,\\mathrm{mm}}{30\\,\\mathrm{mm/s}} = \\frac{0.5}{30}\\,\\mathrm{s}$$\n将此持续时间转换为毫秒：\n$$L_{\\max} = \\frac{0.5}{30}\\,\\mathrm{s} \\times \\frac{1000\\,\\mathrm{ms}}{1\\,\\mathrm{s}} = \\frac{500}{30}\\,\\mathrm{ms} = \\frac{50}{3}\\,\\mathrm{ms}$$\n\n最后，我们使用给定的定义 $R = \\max\\!\\big(0,\\, L - L_{\\max}\\big)$ 来计算所需的延迟缩减量 $R$。\n我们将计算出的系统延迟 $L$ 与最大允许延迟 $L_{\\max}$ 进行比较：\n$$L = \\frac{139}{3}\\,\\mathrm{ms} \\approx 46.33\\,\\mathrm{ms}$$\n$$L_{\\max} = \\frac{50}{3}\\,\\mathrm{ms} \\approx 16.67\\,\\mathrm{ms}$$\n由于 $L > L_{\\max}$，系统的固有延迟超过了可接受的阈值，因此必须进行缩减。所需的缩减量是这两个值之间的差：\n$$R = L - L_{\\max} = \\frac{139}{3}\\,\\mathrm{ms} - \\frac{50}{3}\\,\\mathrm{ms} = \\frac{139 - 50}{3}\\,\\mathrm{ms} = \\frac{89}{3}\\,\\mathrm{ms}$$\n为了提供最终的数值答案，我们计算其十进制值并按要求四舍五入到四位有效数字：\n$$R = \\frac{89}{3}\\,\\mathrm{ms} \\approx 29.6666...\\,\\mathrm{ms}$$\n四舍五入到四位有效数字，得到：\n$$R \\approx 29.67\\,\\mathrm{ms}$$\n这是为满足手术精度要求而必须补偿的延迟量，例如，通过使用预测性追踪或像异步时间扭曲这样的重投影技术。", "answer": "$$\\boxed{29.67}$$", "id": "5110434"}, {"introduction": "人工智能（AI）在术前规划中常用于自动分割器官和病灶，但评估这些分割模型的性能需要超越简单的准确率。本练习将引导您计算两个关键的评估指标：戴斯相似系数（Dice Similarity Coefficient, $DSC$）和豪斯多夫距离（Hausdorff distance）。通过区分体积重叠（$DSC$）和边界偏差（Hausdorff distance），您将深入理解不同评估指标如何揭示模型在临床应用中可能存在的不同类型风险，从而培养对AI模型进行批判性评估的能力[@problem_id:5110408]。", "problem": "一种用于系统性手术规划的人工智能（AI）辅助的计算机断层扫描（CT）器官分割流程，为肝脏生成一个预测的二值掩模 $A$，以及一个由专家标注的基准真相二值掩模 $B$。这些掩模是离散体素晶格的子集，并被视作基数等于体素计数的有限集。测得以下量：$|A|=8000$，$|B|=10000$，$|A\\cap B|=7000$。假设边界 $\\partial A$ 和 $\\partial B$ 在由体素网格间距诱导的欧几里得度量下是紧致的，且边界间差异被测量为边界点之间的最小欧几里得距离。对于两个有限集 $A$ 和 $B$，Dice 相似系数（DSC）被定义为基于重叠的相似性度量。两个紧致集之间的豪斯多夫距离 $H(A,B)$ 定义为两个边界上点之间双向最小距离的上确界。\n\n此外，假设平均边界偏差为 $2$ 毫米，该偏差定义为在 $\\partial A\\cup\\partial B$ 上均匀采样点时，最小边界间距离的期望值。将此平均值视为代表边界差异的非负随机变量 $D$ 的期望。\n\n仅使用重叠度量和度量距离的基本定义，以及针对非负随机变量的经过充分检验的概率不等式，完成以下任务：\n- 计算给定 $A$ 和 $B$ 的 Dice 相似系数。\n- 提供豪斯多夫距离的严格下界（以毫米为单位），以及95百分位鲁棒豪斯多夫距离（即最小的 $t$，使得至少 $0.95$ 的边界差异最多为 $t$）的非参数上界（以毫米为单位），并用给定的平均边界偏差表示。\n\n将豪斯多夫界限以毫米（mm）表示。无需四舍五入；提供精确值。", "solution": "解答根据问题陈述的要求分为三个部分。\n\n**第一部分：计算 Dice 相似系数（DSC）**\n\nDice 相似系数（DSC）是衡量两个有限集之间相似性的统计度量。对于预测的分割掩模 $A$ 和基准真相掩模 $B$，DSC 定义为：\n$$\n\\text{DSC}(A, B) = \\frac{2 |A \\cap B|}{|A| + |B|}\n$$\n其中 $|S|$ 表示集合 $S$ 的基数（即元素或体素的数量）。\n\n问题提供了以下值：\n- 预测掩模的基数, $|A| = 8000$。\n- 基准真相掩模的基数, $|B| = 10000$。\n- 掩模交集的基数, $|A \\cap B| = 7000$。\n\n将这些值代入 DSC 公式：\n$$\n\\text{DSC} = \\frac{2 \\times 7000}{8000 + 10000} = \\frac{14000}{18000}\n$$\n化简分数：\n$$\n\\text{DSC} = \\frac{14}{18} = \\frac{7}{9}\n$$\n\n**第二部分：豪斯多夫距离的下界**\n\n设 $D$ 是一个随机变量，表示从边界的并集 $\\partial A \\cup \\partial B$ 中均匀采样一个点时，最小的边界间距离。问题陈述指出，平均边界偏差，即 $D$ 的期望值，是 $E[D] = 2$ 毫米。\n\n边界之间的豪斯多夫距离 $H(\\partial A, \\partial B)$ 定义为从一个边界上的点到另一个边界上的点集的所有最小距离的上确界（最小上界）。\n$$\nH(\\partial A, \\partial B) = \\max \\left( \\sup_{x \\in \\partial A} \\inf_{y \\in \\partial B} d(x, y), \\sup_{y \\in \\partial B} \\inf_{x \\in \\partial A} d(y, x) \\right)\n$$\n这个值 $H(\\partial A, \\partial B)$ 代表了随机变量 $D$ 可以达到的最大可能值。设 $d_{\\max} = H(\\partial A, \\partial B)$ 为 $D$ 分布支撑集的上确界。\n\n对于任何非负随机变量 $D$，其期望值 $E[D]$ 不能超过其最大可能值 $d_{\\max}$。这可以正式地证明如下：\n$$\nE[D] = \\int_0^{d_{\\max}} x f(x) \\,dx \\le \\int_0^{d_{\\max}} d_{\\max} f(x) \\,dx = d_{\\max} \\int_0^{d_{\\max}} f(x) \\,dx = d_{\\max} \\times 1 = d_{\\max}\n$$\n其中 $f(x)$ 是 $D$ 的概率密度函数。\n\n因此，我们有不等式：\n$$\nH(\\partial A, \\partial B) \\ge E[D]\n$$\n给定 $E[D] = 2$ 毫米，豪斯多夫距离的严格下界是 $2$ 毫米。\n\n**第三部分：95百分位鲁棒豪斯多夫距离的上界**\n\n95百分位鲁棒豪斯多夫距离定义为最小的值 $t$，使得随机采样的边界差异 $D$ 小于或等于 $t$ 的概率至少为 $0.95$。形式上，这写为找到最小的 $t$，使得：\n$$\nP(D \\le t) \\ge 0.95\n$$\n这等价于找到 $D$ 分布的第95百分位数 $t_{0.95}$ 的一个上界。\n\n问题指定使用针对非负随机变量的非参数不等式，而我们只知道其期望 $E[D] = 2$。合适的工具是马尔可夫不等式，它指出对于任何非负随机变量 $X$ 和任何常数 $a > 0$：\n$$\nP(X \\ge a) \\le \\frac{E[X]}{a}\n$$\n条件 $P(D \\le t) \\ge 0.95$ 与 $P(D > t) \\le 0.05$ 互补。假设 $D$ 是一个连续变量，使得 $P(D=t)=0$，则这等价于 $P(D \\ge t) \\le 0.05$。\n\n对随机变量 $D$ 应用马尔可夫不等式：\n$$\nP(D \\ge t) \\le \\frac{E[D]}{t} = \\frac{2}{t}\n$$\n为了保证 $P(D \\ge t) \\le 0.05$，我们必须找到满足此条件的最小 $t$。我们可以通过将不等式提供的上界设置为我们期望的概率阈值来强制执行此条件：\n$$\n\\frac{2}{t} = 0.05\n$$\n解出 $t$：\n$$\nt = \\frac{2}{0.05} = \\frac{2}{\\frac{1}{20}} = 2 \\times 20 = 40\n$$\n对于 $t = 40$ 毫米，马尔可夫不等式保证 $P(D \\ge 40) \\le \\frac{2}{40} = 0.05$。这确保了 $P(D \\le 40) \\ge 1 - 0.05 = 0.95$。因此，$40$ 毫米是95百分位鲁棒豪斯多夫距离的一个有效的非参数上界。\n\n所求的三个值是：\n1.  Dice 相似系数：$\\frac{7}{9}$\n2.  豪斯多夫距离的下界：$2$ 毫米\n3.  95百分位鲁棒豪斯多夫距离的上界：$40$ 毫米", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{7}{9}  2  40 \\end{pmatrix}}\n$$", "id": "5110408"}, {"introduction": "从医学扫描（如CT或MRI）生成的三维数字模型往往存在孔洞、自相交等缺陷，在用于3D打印或AR可视化之前必须进行修复。这个综合性编程练习模拟了一个真实世界中的工程任务，要求您构建一个完整的网格修复算法，以处理这些几何和拓扑缺陷，同时保留关键的解剖标志点。通过实现此练习，您将获得开发和部署精准外科技术所需的数据预处理流水线的宝贵实践经验[@problem_id:5110349]。", "problem": "给定一个三角形网格，它代表一个用于三维（3D）打印和增强现实（AR）辅助系统性外科手术规划的解剖学表面。该网格可能包含拓扑缺陷（由边界边循环引起的孔洞）和几何缺陷（自相交）。某些顶点被指定为解剖学标志点，并且必须在空间中保持固定。您的任务是构建一个完整、可运行的程序，该程序通过闭合孔洞和移除自相交来修复网格，同时在标志点约束下最小化原始形状的几何畸变。程序必须实现以下算法和数学要求，并为测试套件生成指定的输出。\n\n使用的基本基础和定义：\n- 将网格表示为一组顶点 $\\{ \\mathbf{x}_i \\in \\mathbb{R}^3 \\}_{i=1}^n$ 和一组面 $\\{ f_k = (i,j,\\ell) \\}_{k=1}^m$，其中每个面 $f_k$ 是顶点集中的一个索引三元组。\n- 将无向边集 $E$ 定义为出现在任何面中的所有无序对 $\\{i,j\\}$。如果一条边恰好出现在一个面中，则为边界边；否则为内部边。\n- 定义网格配置 $\\mathbf{X} = (\\mathbf{x}_1,\\dots,\\mathbf{x}_n)$ 的离散狄利克雷（调和）能量为 $$E_{\\mathrm{D}}(\\mathbf{X}) = \\sum_{\\{i,j\\} \\in E} w_{ij} \\left\\| \\mathbf{x}_i - \\mathbf{x}_j \\right\\|_2^2,$$ 其中 $w_{ij} > 0$ 是权重；使用均匀权重 $w_{ij} = 1$ 作为与均匀离散拉普拉斯平滑一致的、经过充分测试的基线。\n- 对于非标志点顶点 $i$，约束平滑更新是在固定标志点约束下对 $E_{\\mathrm{D}}$ 进行的梯度下降步骤：$$\\mathbf{x}_i^{(t+1)} = (1 - \\alpha) \\mathbf{x}_i^{(t)} + \\alpha \\cdot \\frac{1}{\\deg(i)} \\sum_{j \\in N(i)} \\mathbf{x}_j^{(t)},$$ 其中 $N(i)$ 是 $i$ 在 $E$ 中的邻居集合，$\\deg(i) = |N(i)|$，$ \\alpha \\in (0,1)$ 是为保证稳定性而选择的步长（例如，$\\alpha  1/\\Delta_{\\max}$，其中 $\\Delta_{\\max}$ 是最大顶点度）。标志点顶点不移动。\n- 孔洞是任何简单的边界边循环，它界定了一个缺失的面区域。闭合孔洞必须通过在循环的质心处插入一个新顶点并形成一个扇形来添加面以三角化该循环；循环质心为 $$\\mathbf{c} = \\frac{1}{k} \\sum_{r=1}^k \\mathbf{x}_{v_r},$$ 其中 $(v_1,\\dots,v_k)$ 是按循环顺序排列的循环顶点。\n- 如果任何一对不相交的面 $(f_a, f_b)$ 中，一个三角形的边与另一个三角形在 $\\mathbb{R}^3$ 中的内部相交，则存在自相交。移除相交必须通过沿连接三角形质心的直线，以一个小的排斥步长 $\\delta > 0$ 来移位非标志点顶点，从而迭代地分离相交的三角形对，重复此过程直到没有相交保留或达到最大迭代次数；这是一种经过充分测试的几何分离启发式方法，与计算几何中的碰撞解决方法一致。\n- 定义相对于原始网格的几何畸变为在修复前限制于原始边集 $E_0$ 的边长最大绝对相对变化：$$D_{\\max} = \\max_{\\{i,j\\}\\in E_0} \\left| \\frac{\\left\\| \\mathbf{x}_i^{\\mathrm{final}} - \\mathbf{x}_j^{\\mathrm{final}} \\right\\|_2}{\\left\\| \\mathbf{x}_i^{\\mathrm{orig}} - \\mathbf{x}_j^{\\mathrm{orig}} \\right\\|_2} - 1 \\right|.$$\n\n要实现的算法任务：\n1. 识别边界边并提取简单的边界循环。通过插入一个质心顶点并形成扇形来三角化每个循环，以闭合孔洞。标志点顶点必须保持固定。\n2. 使用针对所有三角形边对的线段-三角形相交测试来检测三角形-三角形自相交。对于每个相交的三角形对，计算其质心，并沿质心到质心连线的单位向量方向，以 $\\pm \\delta$ 的位移移动两个三角形的非标志点顶点。迭代此过程，直到没有相交保留或达到指定的迭代上限。\n3. 使用上述更新规则，对非标志点顶点执行约束拉普拉斯平滑，迭代指定次数，步长 $\\alpha$ 的选择应旨在最小化畸变同时保持拓扑完整性。\n4. 计算布尔类型的孔洞闭合状态（如果在启用孔洞闭合后没有边界边剩下，则为真）、布尔类型的自相交状态（如果没有相交剩下，则为真），以及根据原始边集 $E_0$ 计算的最终最大畸变 $D_{\\max}$。\n\n您的程序必须使用给定的网格、参数和标志点集运行以下测试套件。在此问题中，所有坐标都是无单位的。为清晰起见，下面的每个数字都是明确给出的。您必须精确使用这些值。\n\n测试用例 1 （一个闭合的八面体，带有一个待闭合的孔洞，所有顶点都是标志点）：\n- 顶点 $\\mathbf{X}$: $[ (1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1) ]$。\n- 面 $F$ （从八面体中移除面 $(1,3,4)$ 以制造一个孔洞）：$[ (0,2,4), (2,1,4), (3,0,4), (2,0,5), (1,2,5), (3,1,5), (0,3,5) ]$。\n- 标志点索引 $L$: $[0,1,2,3,4,5]$。\n- 参数：启用孔洞闭合，$\\alpha = 0.2$，平滑迭代次数 $= 5$，排斥步长 $\\delta = 0.0$，排斥迭代上限 $= 10$。\n\n测试用例 2 （两个相交的三角形，将一个三角形保留为标志点，不进行孔洞闭合）：\n- 顶点 $\\mathbf{X}$: $[ (0,0,0), (1,0,0), (0.5,1,0), (0.5,-0.2,-0.5), (0.5,0.5,0.5), (0.5,1.2,-0.5) ]$。\n- 面 $F$: $[ (0,1,2), (3,4,5) ]$。\n- 标志点索引 $L$: $[0,1,2]$。\n- 参数：禁用孔洞闭合，$\\alpha = 0.05$，平滑迭代次数 $= 5$，排斥步长 $\\delta = 0.05$，排斥迭代上限 $= 100$。\n\n测试用例 3 （一个带有一个孔洞的八面体，允许选定的顶点移动，启用孔洞闭合）：\n- 顶点 $\\mathbf{X}$: $[ (1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1) ]$。\n- 面 $F$ （移除面 $(1,3,4)$）：$[ (0,2,4), (2,1,4), (3,0,4), (2,0,5), (1,2,5), (3,1,5), (0,3,5) ]$。\n- 标志点索引 $L$: $[0,1,3,5]$ (顶点 $2$ 和 $4$ 允许移动)。\n- 参数：启用孔洞闭合，$\\alpha = 0.1$，平滑迭代次数 $= 10$，排斥步长 $\\delta = 0.0$，排斥迭代上限 $= 10$。\n\n最终输出规范：\n- 对于每个测试用例，计算一个列表 $[\\text{holes\\_closed}, \\text{no\\_intersections}, D_{\\max}]$，其中 $\\text{holes\\_closed}$ 和 $\\text{no\\_intersections}$ 是布尔值，$D_{\\max}$ 是一个浮点数。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为这些单个用例列表的逗号分隔列表，并用方括号括起来，不含空格。例如：$[[\\text{true},\\text{true},0.001234],[\\text{false},\\text{true},0.0567],[\\text{true},\\text{true},0.0]]$。使用 Python 规范的布尔值大写形式，即输出 $True$ 或 $False$。\n\n您的解决方案必须从给定的基本基础开始，以科学上现实的方式实现所述算法，并在解决方案部分证明任何参数选择的合理性。最终答案必须是执行环境约束中指定的完整 Python 程序。", "solution": "我们将通过按顺序、模块化的方式实现指定的算法来构建解决方案，并遵循所提供的数学定义。该过程包括三个主要阶段：（1）通过识别和闭合边界循环（孔洞）进行拓扑修复，（2）通过检测和解决自相交进行几何清理，以及（3）通过约束拉普拉斯平滑进行几何优化。最后，我们将计算所需的质量度量。\n\n**1. 网格数据结构和初始处理**\n\n网格由一组顶点 $\\mathbf{X} = \\{\\mathbf{x}_i \\in \\mathbb{R}^3\\}_{i=1}^n$ 和一组面 $F = \\{ f_k = (i,j,\\ell) \\}_{k=1}^m$ 定义。我们使用 NumPy 数组（形状为 $(n, 3)$）来表示顶点，以实现高效的向量操作。面存储为元组列表。\n\n第一步是通过构建边集 $E$ 来建立网格的连通性。一条边由一对顶点索引 $\\{i,j\\}$ 定义。为了正确识别边界边，我们计算每条唯一边在所有面中出现的次数。一条边表示为已排序的索引元组 $(\\min(i,j), \\max(i,j))$，以确保无论方向如何都具有唯一性。出现在一个面中的边是边界边；出现在两个面中的边是内部边。\n\n令 $E_0$ 为输入网格的初始边集。存储此集合是为了计算最终的畸变度量 $D_{\\max}$。\n\n**2. 孔洞识别与三角化**\n\n如果启用了孔洞闭合，我们会识别边界循环。\n首先，我们构建一个数据结构，将边界上的每个顶点映射到其相邻的边界顶点。对于像测试用例中那样的简单、单一的边界循环，这将形成一个简单的循环图。我们遍历此图以提取构成孔洞边界的顶点有序序列 $(v_1, v_2, \\dots, v_k)$。\n\n为了闭合孔洞，在循环顶点的质心处创建一个新顶点 $\\mathbf{x}_{\\text{new}}$：\n$$\n\\mathbf{x}_{\\text{new}} = \\mathbf{c} = \\frac{1}{k} \\sum_{r=1}^k \\mathbf{x}_{v_r}\n$$\n顶点列表 $\\mathbf{X}$ 会追加 $\\mathbf{x}_{\\text{new}}$。然后通过形成新面的“扇形”来对孔洞进行三角化。对于每个边界边 $\\{v_r, v_{r+1}\\}$（其中 $v_{k+1}=v_1$），向面列表 $F$ 中添加一个新的三角形面 $(v_r, v_{r+1}, i_{\\text{new}})$，其中 $i_{\\text{new}}$ 是新质心顶点的索引。此过程保证消除边界循环，从而产生一个拓扑闭合（水密）的表面区域。\n\n**3. 自相交检测与解决**\n\n自相交是一种几何缺陷，其中网格的不相交部分占据了相同的空间。问题指定检测一个三角形的边与另一个三角形内部之间的相交。我们迭代所有不相交的面 $(f_a, f_b)$ 对，即不共享任何顶点的面。对于每个这样的对，我们测试 $f_a$ 的每条边与面 $f_b$ 的相交情况，反之亦然。\n\n使用标准的重心坐标法执行线段-三角形相交测试。设一条边由其端点 $\\mathbf{P}_0$ 和 $\\mathbf{P}_1$ 定义，一个三角形由其顶点 $\\mathbf{T}_0, \\mathbf{T}_1, \\mathbf{T}_2$ 定义。包含该线段的直线可以参数化地写为 $\\mathbf{L}(t) = \\mathbf{P}_0 + t(\\mathbf{P}_1 - \\mathbf{P}_0)$。三角形内部的一个点 $\\mathbf{Q}$ 可以使用重心坐标写为 $\\mathbf{Q}(u,v) = (1-u-v)\\mathbf{T}_0 + u\\mathbf{T}_1 + v\\mathbf{T}_2$。如果能找到 $t, u, v$ 使得 $\\mathbf{L}(t) = \\mathbf{Q}(u,v)$ 并且参数满足位于线段和三角形内部的约束条件：$t \\in (0, 1)$，$u > 0$，$v > 0$ 和 $u+v  1$，则存在相交。这可以表示为一个 $3 \\times 3$ 的线性系统：\n$$\n\\begin{bmatrix}\n|  |  | \\\\\n(\\mathbf{P}_0 - \\mathbf{P}_1)  (\\mathbf{T}_1 - \\mathbf{T}_0)  (\\mathbf{T}_2 - \\mathbf{T}_0) \\\\\n|  |  |\n\\end{bmatrix}\n\\begin{pmatrix} t \\\\ u \\\\ v \\end{pmatrix}\n=\n\\begin{pmatrix} | \\\\ \\mathbf{P}_0 - \\mathbf{T}_0 \\\\ | \\end{pmatrix}\n$$\n如果在面 $f_a$ 和 $f_b$ 之间检测到相交，其顶点分别为 $\\{\\mathbf{v}_{a1}, \\mathbf{v}_{a2}, \\mathbf{v}_{a3}\\}$ 和 $\\{\\mathbf{v}_{b1}, \\mathbf{v}_{b2}, \\mathbf{v}_{b3}\\}$，则计算它们各自的质心：\n$$\n\\mathbf{c}_a = \\frac{1}{3}\\sum_{k=1}^3 \\mathbf{v}_{ak}, \\quad \\mathbf{c}_b = \\frac{1}{3}\\sum_{k=1}^3 \\mathbf{v}_{bk}\n$$\n定义一个排斥向量 $\\mathbf{u}_{ab} = (\\mathbf{c}_b - \\mathbf{c}_a) / \\|\\mathbf{c}_b - \\mathbf{c}_a\\|_2$。面 $f_a$ 的非标志点顶点被位移 $-\\delta \\mathbf{u}_{ab}$，面 $f_b$ 的非标志点顶点被位移 $+\\delta \\mathbf{u}_{ab}$，其中 $\\delta$ 是排斥步长。重复此过程，直到达到指定的迭代次数或未检测到相交。\n\n**4. 约束拉普拉斯平滑**\n\n拉普拉斯平滑是一个迭代过程，它将每个顶点重新定位到其邻居的平均位置，从而有效地平滑网格。这等同于最小化离散狄利克雷能量 $E_{\\mathrm{D}}(\\mathbf{X})$。提供的更新规则是对此能量最小化的一个显式积分步骤：\n$$\n\\mathbf{x}_i^{(t+1)} = (1 - \\alpha) \\mathbf{x}_i^{(t)} + \\alpha \\cdot \\frac{1}{\\deg(i)} \\sum_{j \\in N(i)} \\mathbf{x}_j^{(t)}\n$$\n这里，$N(i)$ 是顶点 $i$ 的1-环邻居集合，$\\deg(i)$ 是其度（邻居数量），$\\alpha \\in (0,1)$ 是控制收敛速率的步长。此更新仅应用于非标志点顶点。标志点顶点 $\\{\\mathbf{x}_j | j \\in L\\}$ 在整个过程中保持固定。为确保正确性，迭代 $t+1$ 时所有顶点的更新必须基于迭代 $t$ 时的顶点位置。这需要在更新主数组之前，使用一个临时的顶点数组副本存储新位置。\n\n**5. 最终度量计算**\n\n在所有修复和平滑操作完成后，我们评估最终网格的质量。\n-   **孔洞闭合状态：** 我们重新计算最终网格上的边界边集。如果此集合为空，则 `holes_closed` 状态为 `True`，否则为 `False`。\n-   **自相交状态：** 我们在最终网格上运行完整的自相交检测算法。如果未发现相交，则 `no_intersections` 状态为 `True`，否则为 `False`。\n-   **几何畸变 ($D_{\\max}$):** 此度量量化了网格相对于其原始形状的变形程度。它是通过仅考虑原始网格中存在的边 $\\{i,j\\}$（即 $E_0$）来计算的。对于每个这样的边，我们计算其在原始网格中的长度 $\\|\\mathbf{x}_i^{\\mathrm{orig}} - \\mathbf{x}_j^{\\mathrm{orig}}\\|_2$，以及在最终修复网格中的长度 $\\|\\mathbf{x}_i^{\\mathrm{final}} - \\mathbf{x}_j^{\\mathrm{final}}\\|_2$。所有原始边上的最大绝对相对变化即为畸变：\n    $$\n    D_{\\max} = \\max_{\\{i,j\\}\\in E_0} \\left| \\frac{\\left\\| \\mathbf{x}_i^{\\mathrm{final}} - \\mathbf{x}_j^{\\mathrm{final}} \\right\\|_2}{\\left\\| \\mathbf{x}_i^{\\mathrm{orig}} - \\mathbf{x}_j^{\\mathrm{orig}} \\right\\|_2} - 1 \\right|\n    $$\n    $D_{\\max}=0$ 的值表示原始边的长度没有变化。\n\n这些算法的组合为修复三角形网格中的常见缺陷提供了一个强大的流程，这是3D打印和用于手术规划的增强现实等应用中的一个关键预处理步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import Counter\n\ndef get_edges_and_boundaries(faces):\n    \"\"\"\n    Identifies all unique edges and boundary edges from a list of faces.\n    An edge is a sorted tuple of vertex indices.\n    \"\"\"\n    edges = []\n    for face in faces:\n        edges.append(tuple(sorted((face[0], face[1]))))\n        edges.append(tuple(sorted((face[1], face[2]))))\n        edges.append(tuple(sorted((face[2], face[0]))))\n    \n    edge_counts = Counter(edges)\n    boundary_edges = [edge for edge, count in edge_counts.items() if count == 1]\n    \n    return set(edges), boundary_edges\n\ndef find_boundary_loops(boundary_edges):\n    \"\"\"\n    Traces boundary edges to form ordered loops of vertices.\n    Assumes simple, non-branching loops for this problem's scope.\n    \"\"\"\n    if not boundary_edges:\n        return []\n\n    adj = {}\n    for u, v in boundary_edges:\n        if u not in adj: adj[u] = []\n        if v not in adj: adj[v] = []\n        adj[u].append(v)\n        adj[v].append(u)\n\n    loops = []\n    visited_edges = set()\n\n    for start_edge in boundary_edges:\n        if start_edge in visited_edges:\n            continue\n        \n        loop = []\n        \n        start_node, second_node = start_edge\n        loop.append(start_node)\n        loop.append(second_node)\n        visited_edges.add(start_edge)\n        \n        prev_node, curr_node = start_node, second_node\n        \n        while curr_node != start_node:\n            found_next = False\n            for next_node in adj[curr_node]:\n                edge = tuple(sorted((curr_node, next_node)))\n                if next_node != prev_node and edge in boundary_edges:\n                    if edge in visited_edges and next_node != start_node:\n                        # Should not happen in simple loops\n                        continue\n\n                    prev_node, curr_node = curr_node, next_node\n                    if curr_node != start_node:\n                        loop.append(curr_node)\n                    visited_edges.add(edge)\n                    found_next = True\n                    break\n            if not found_next:\n                 # Incomplete loop or complex topology, break for robustness\n                break\n        loops.append(loop)\n    return loops\n\ndef segment_triangle_intersect(p0, p1, t0, t1, t2):\n    \"\"\"\n    Möller-Trumbore inspired segment-triangle intersection test.\n    Checks if segment (p0, p1) intersects triangle (t0, t1, t2).\n    Returns True if intersection is in the segment interior and triangle interior.\n    \"\"\"\n    epsilon = 1e-6\n    edge1 = t1 - t0\n    edge2 = t2 - t0\n    direction = p1 - p0\n    \n    h = np.cross(direction, edge2)\n    a = np.dot(edge1, h)\n\n    if -epsilon  a  epsilon:\n        return False  # Parallel\n\n    f = 1.0 / a\n    s = p0 - t0\n    u = f * np.dot(s, h)\n\n    if u  epsilon or u > 1.0 - epsilon:\n        return False\n\n    q = np.cross(s, edge1)\n    v = f * np.dot(direction, q)\n\n    if v  epsilon or u + v > 1.0 - epsilon:\n        return False\n\n    t = f * np.dot(edge2, q)\n\n    if t > epsilon and t  1.0 - epsilon: # t is relative to segment length implicit in direction\n        return True\n    \n    return False\n\ndef detect_intersections(vertices, faces):\n    \"\"\"\n    Detects self-intersections by checking all disjoint face pairs.\n    Returns a list of intersecting face index pairs.\n    \"\"\"\n    intersections = []\n    num_faces = len(faces)\n    face_sets = [set(f) for f in faces]\n\n    for i in range(num_faces):\n        for j in range(i + 1, num_faces):\n            # Check for disjoint faces\n            if not face_sets[i].isdisjoint(face_sets[j]):\n                continue\n\n            f_i = faces[i]\n            f_j = faces[j]\n            v_i = vertices[list(f_i)]\n            v_j = vertices[list(f_j)]\n\n            # Test edges of face i against face j\n            for k in range(3):\n                p0 = v_i[k]\n                p1 = v_i[(k + 1) % 3]\n                if segment_triangle_intersect(p0, p1, v_j[0], v_j[1], v_j[2]):\n                    intersections.append((i, j))\n                    break\n            if (i, j) in intersections: continue\n\n            # Test edges of face j against face i\n            for k in range(3):\n                p0 = v_j[k]\n                p1 = v_j[(k + 1) % 3]\n                if segment_triangle_intersect(p0, p1, v_i[0], v_i[1], v_i[2]):\n                    intersections.append((i, j))\n                    break\n    return intersections\n\ndef solve_case(vertices_orig, faces_orig, landmarks_idx, params):\n    # Convert to NumPy array and list for mutability\n    vertices = np.array(vertices_orig, dtype=float)\n    faces = [list(f) for f in faces_orig]\n    landmarks = set(landmarks_idx)\n\n    # --- Initial state ---\n    E0, _ = get_edges_and_boundaries(faces)\n    original_edge_lengths = {\n        edge: np.linalg.norm(vertices[edge[0]] - vertices[edge[1]]) for edge in E0\n    }\n\n    # --- 1. Hole Closing ---\n    if params['hole_closing_enabled']:\n        _, boundary_edges = get_edges_and_boundaries(faces)\n        loops = find_boundary_loops(boundary_edges)\n        for loop in loops:\n            centroid = np.mean(vertices[loop], axis=0)\n            new_v_idx = len(vertices)\n            vertices = np.vstack([vertices, centroid])\n            for i in range(len(loop)):\n                v1 = loop[i]\n                v2 = loop[(i + 1) % len(loop)]\n                faces.append([v1, v2, new_v_idx])\n\n    # --- 2. Intersection Removal ---\n    if params['delta'] > 0:\n        for _ in range(params['repulsion_iters']):\n            intersecting_pairs = detect_intersections(vertices, faces)\n            if not intersecting_pairs:\n                break\n            \n            # Using set to avoid duplicate updates for a vertex\n            displacements = {}\n\n            for i, j in intersecting_pairs:\n                face_i_indices = faces[i]\n                face_j_indices = faces[j]\n                \n                c_i = np.mean(vertices[face_i_indices], axis=0)\n                c_j = np.mean(vertices[face_j_indices], axis=0)\n                \n                direction_vec = c_j - c_i\n                norm = np.linalg.norm(direction_vec)\n                if norm  1e-9: continue\n                unit_vec = direction_vec / norm\n\n                for v_idx in face_i_indices:\n                    if v_idx not in landmarks:\n                        if v_idx not in displacements: displacements[v_idx] = np.zeros(3)\n                        displacements[v_idx] -= params['delta'] * unit_vec\n                \n                for v_idx in face_j_indices:\n                    if v_idx not in landmarks:\n                        if v_idx not in displacements: displacements[v_idx] = np.zeros(3)\n                        displacements[v_idx] += params['delta'] * unit_vec\n            \n            for v_idx, disp in displacements.items():\n                vertices[v_idx] += disp\n    \n    # --- 3. Laplacian Smoothing ---\n    if params['smoothing_iters'] > 0 and params['alpha'] > 0:\n        # Build adjacency list\n        adj = {i: [] for i in range(len(vertices))}\n        for face in faces:\n            adj[face[0]].extend([face[1], face[2]])\n            adj[face[1]].extend([face[0], face[2]])\n            adj[face[2]].extend([face[0], face[1]])\n\n        # Create unique neighbor lists\n        neighbors = {i: list(set(n)) for i, n in adj.items()}\n        \n        for _ in range(params['smoothing_iters']):\n            new_vertices = vertices.copy()\n            for i in range(len(vertices)):\n                if i in landmarks:\n                    continue\n                \n                neighbor_indices = neighbors.get(i, [])\n                if not neighbor_indices:\n                    continue\n                \n                neighbor_coords = vertices[neighbor_indices]\n                avg_pos = np.mean(neighbor_coords, axis=0)\n                \n                new_vertices[i] = (1 - params['alpha']) * vertices[i] + params['alpha'] * avg_pos\n            vertices = new_vertices\n\n    # --- 4. Final Metrics ---\n    # Hole closure status\n    _, final_boundaries = get_edges_and_boundaries(faces)\n    holes_closed = (not final_boundaries)\n\n    # Intersection status\n    final_intersections = detect_intersections(vertices, faces)\n    no_intersections = (not final_intersections)\n\n    # Distortion\n    max_distortion = 0.0\n    for edge, orig_len in original_edge_lengths.items():\n        if orig_len  1e-9: continue\n        # edge vertices must exist in final mesh\n        if edge[0]  len(vertices) and edge[1]  len(vertices):\n            final_len = np.linalg.norm(vertices[edge[0]] - vertices[edge[1]])\n            distortion = abs(final_len / orig_len - 1.0)\n            if distortion > max_distortion:\n                max_distortion = distortion\n\n    return [holes_closed, no_intersections, max_distortion]\n\ndef solve():\n    test_cases = [\n        {\n            \"vertices\": [(1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)],\n            \"faces\": [(0,2,4), (2,1,4), (3,0,4), (2,0,5), (1,2,5), (3,1,5), (0,3,5)],\n            \"landmarks\": [0,1,2,3,4,5],\n            \"params\": {\n                \"hole_closing_enabled\": True, \"alpha\": 0.2, \"smoothing_iters\": 5,\n                \"delta\": 0.0, \"repulsion_iters\": 10\n            }\n        },\n        {\n            \"vertices\": [(0,0,0), (1,0,0), (0.5,1,0), (0.5,-0.2,-0.5), (0.5,0.5,0.5), (0.5,1.2,-0.5)],\n            \"faces\": [(0,1,2), (3,4,5)],\n            \"landmarks\": [0,1,2],\n            \"params\": {\n                \"hole_closing_enabled\": False, \"alpha\": 0.05, \"smoothing_iters\": 5,\n                \"delta\": 0.05, \"repulsion_iters\": 100\n            }\n        },\n        {\n            \"vertices\": [(1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)],\n            \"faces\": [(0,2,4), (2,1,4), (3,0,4), (2,0,5), (1,2,5), (3,1,5), (0,3,5)],\n            \"landmarks\": [0,1,3,5],\n            \"params\": {\n                \"hole_closing_enabled\": True, \"alpha\": 0.1, \"smoothing_iters\": 10,\n                \"delta\": 0.0, \"repulsion_iters\": 10\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case[\"vertices\"], case[\"faces\"], case[\"landmarks\"], case[\"params\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    result_str = \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "5110349"}]}