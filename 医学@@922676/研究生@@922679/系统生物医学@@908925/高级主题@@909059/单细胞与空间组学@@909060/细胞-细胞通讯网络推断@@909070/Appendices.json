{"hands_on_practices": [{"introduction": "当我们计算出两种细胞类型之间的通讯分数后，首要问题是：这个分数是否具有统计显著性，还是仅仅由随机因素产生？置换检验 (permutation test) 是一种强大的非参数方法，它通过生成一个零分布 (null distribution) 来回答这个问题。这个练习将指导你具体实现一个置换检验，以评估细胞间通讯边的统计意义。[@problem_id:4355885]", "problem": "给定一种基于配体-受体相互作用和空间接触概率的、对发送细胞类型 $a$ 和接收细胞类型 $b$ 之间细胞间通讯的形式化描述。请构建一个经验置换检验，通过在发送细胞类型内部对配体表达进行细胞间重排，为细胞间边缘权重 $W_{ab}$ 构建一个零分布，同时保持配体表达的边际分布不变，并为观测到的边缘计算上尾 $p$ 值。\n\n从以下基本设定开始：\n- 细胞执行分子生物学中心法则，其中基因表达产生蛋白质（例如，配体和受体）。细胞间通讯由配体-受体对介导；接触介导的信号事件的概率随配体和受体丰度的乘积单调增加。\n- 对于两种细胞类型，定义一个接触概率矩阵 $C \\in \\mathbb{R}_{\\ge 0}^{n_a \\times n_b}$，其元素 $C_{ij}$ 是类型为 $a$ 的发送细胞 $i$ 与类型为 $b$ 的接收细胞 $j$ 接触的概率（或归一化权重），其中 $\\sum_{i=1}^{n_a} \\sum_{j=1}^{n_b} C_{ij}$ 是有限的。\n- 对于由 $k \\in \\{1,\\dots,K\\}$ 索引的 $K$ 个配体-受体对，令 $L \\in \\mathbb{R}_{\\ge 0}^{n_a \\times K}$ 表示发送细胞中的配体表达， $R \\in \\mathbb{R}_{\\ge 0}^{n_b \\times K}$ 表示接收细胞中的受体表达， $s \\in \\mathbb{R}_{0}^{K}$ 表示特定配对的结合强度（或权重）。\n\n将细胞间边缘权重 $W_{ab}$ 定义为在接触加权下，所有配体-受体对的预期接触介导信号总量：\n$$\nW_{ab} \\;=\\; \\sum_{k=1}^{K} s_k \\sum_{i=1}^{n_a} \\sum_{j=1}^{n_b} C_{ij} \\, L_{ik} \\, R_{jk}.\n$$\n\n在零假设下，即在一个细胞类型中，配体表达值在各个发送细胞间的分配是可交换的（也就是说，高配体表达与接触结构之间没有特定的细胞水平对齐），通过对每个配体 $k$ 在发送细胞类型内独立地置换配体表达来构建零分布：\n$$\nL^{(r)}_{\\cdot k} \\;=\\; \\pi^{(r)}\\!\\left(L_{\\cdot k}\\right),\n$$\n其中 $\\pi^{(r)}$ 是第 $k$ 个配体列的 $n_a$ 个条目的一个随机置换，$r \\in \\{1,\\dots,R\\}$ 是置换索引。对于每次置换，计算\n$$\nW^{(r)}_{ab} \\;=\\; \\sum_{k=1}^{K} s_k \\sum_{i=1}^{n_a} \\sum_{j=1}^{n_b} C_{ij} \\, L^{(r)}_{ik} \\, R_{jk}.\n$$\n令 $W^{\\text{obs}}_{ab}$ 表示从原始 $L, R, C, s$ 计算出的观测边缘权重。报告带有连续性校正的上尾经验 $p$ 值：\n$$\np \\;=\\; \\frac{1 + \\sum_{r=1}^{R} \\mathbb{I}\\!\\left(W^{(r)}_{ab} \\ge W^{\\text{obs}}_{ab}\\right)}{R + 1},\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数，$R$ 是置换次数。答案以 $[0, 1]$ 区间内的小数形式给出。\n\n你的程序必须实现上述过程，并为以下测试套件计算 $p$ 值。请使用下面给出的确切矩阵和参数。为保证可复现性，请为置换使用指定的随机种子。没有物理单位。不使用角度。不使用百分比。最终数值答案以小数形式表示。\n\n测试用例 1（一般情况）：\n- 维度：$n_a = 4$, $n_b = 5$, $K = 3$。\n- 配体矩阵：\n$$\nL^{(1)} \\;=\\;\n\\begin{bmatrix}\n2.0  0.5  1.0 \\\\\n1.5  2.0  0.0 \\\\\n3.0  1.0  0.5 \\\\\n0.2  3.5  2.0\n\\end{bmatrix}\n$$\n- 受体矩阵：\n$$\nR^{(1)} \\;=\\;\n\\begin{bmatrix}\n0.5  0.0  1.0 \\\\\n1.0  1.5  0.5 \\\\\n0.2  2.0  0.0 \\\\\n1.5  0.5  1.5 \\\\\n0.0  1.0  0.2\n\\end{bmatrix}\n$$\n- 接触矩阵：\n$$\nC^{(1)} \\;=\\;\n\\begin{bmatrix}\n0.9  0.1  0.0  0.0  0.0 \\\\\n0.0  0.8  0.1  0.0  0.0 \\\\\n0.0  0.0  0.7  0.2  0.0 \\\\\n0.0  0.0  0.0  0.6  0.4\n\\end{bmatrix}\n$$\n- 结合强度：\n$$\ns^{(1)} \\;=\\; \\begin{bmatrix} 1.0  0.8  0.5 \\end{bmatrix}\n$$\n- 置换次数：$R^{(1)} = 1000$。\n- 随机种子：$42$。\n\n测试用例 2（边界情况：零接触）：\n- 维度：$n_a = 3$, $n_b = 3$, $K = 2$。\n- 配体矩阵：\n$$\nL^{(2)} \\;=\\;\n\\begin{bmatrix}\n1.0  2.0 \\\\\n0.0  1.5 \\\\\n3.0  0.5\n\\end{bmatrix}\n$$\n- 受体矩阵：\n$$\nR^{(2)} \\;=\\;\n\\begin{bmatrix}\n0.5  1.0 \\\\\n1.0  0.0 \\\\\n0.0  1.5\n\\end{bmatrix}\n$$\n- 接触矩阵：\n$$\nC^{(2)} \\;=\\;\n\\begin{bmatrix}\n0.0  0.0  0.0 \\\\\n0.0  0.0  0.0 \\\\\n0.0  0.0  0.0\n\\end{bmatrix}\n$$\n- 结合强度：\n$$\ns^{(2)} \\;=\\; \\begin{bmatrix} 1.0  1.0 \\end{bmatrix}\n$$\n- 置换次数：$R^{(2)} = 500$。\n- 随机种子：$7$。\n\n测试用例 3（边缘情况：集中接触的单个配体-受体对）：\n- 维度：$n_a = 4$, $n_b = 4$, $K = 1$。\n- 配体矩阵：\n$$\nL^{(3)} \\;=\\;\n\\begin{bmatrix}\n0.0 \\\\\n0.0 \\\\\n10.0 \\\\\n0.0\n\\end{bmatrix}\n$$\n- 受体矩阵：\n$$\nR^{(3)} \\;=\\;\n\\begin{bmatrix}\n0.0 \\\\\n5.0 \\\\\n0.0 \\\\\n0.0\n\\end{bmatrix}\n$$\n- 接触矩阵：\n$$\nC^{(3)} \\;=\\;\n\\begin{bmatrix}\n0.05  0.05  0.05  0.05 \\\\\n0.05  0.05  0.05  0.05 \\\\\n0.05  1.00  0.05  0.05 \\\\\n0.05  0.05  0.05  0.05\n\\end{bmatrix}\n$$\n- 结合强度：\n$$\ns^{(3)} \\;=\\; \\begin{bmatrix} 1.0 \\end{bmatrix}\n$$\n- 置换次数：$R^{(3)} = 1000$。\n- 随机种子：$123$。\n\n测试用例 4（边界情况：单细胞发送者和接收者）：\n- 维度：$n_a = 1$, $n_b = 1$, $K = 2$。\n- 配体矩阵：\n$$\nL^{(4)} \\;=\\;\n\\begin{bmatrix}\n2.0  4.0\n\\end{bmatrix}\n$$\n- 受体矩阵：\n$$\nR^{(4)} \\;=\\;\n\\begin{bmatrix}\n3.0  1.0\n\\end{bmatrix}\n$$\n- 接触矩阵：\n$$\nC^{(4)} \\;=\\;\n\\begin{bmatrix}\n0.5\n\\end{bmatrix}\n$$\n- 结合强度：\n$$\ns^{(4)} \\;=\\; \\begin{bmatrix} 1.0  0.1 \\end{bmatrix}\n$$\n- 置换次数：$R^{(4)} = 1000$。\n- 随机种子：$21$。\n\n你的程序应生成单行输出，其中包含按顺序排列的四个测试用例的 $p$ 值，形式为用方括号括起来的逗号分隔列表，每个值四舍五入到恰好六位小数（例如，$[0.123456,0.654321,0.500000,0.000999]$）。", "solution": "该问题要求实现一个经验置换检验，以评估计算出的发送细胞类型 $a$ 和接收细胞类型 $b$ 之间的细胞间边缘权重 $W_{ab}$ 的统计显著性。该边缘权重基于配体-受体表达、它们的结合强度和空间接触概率，量化了信号相互作用的总潜力。\n\n解决方案的结构如下：\n1.  一个从输入矩阵计算细胞间边缘权重 $W_{ab}$ 的函数。\n2.  一个通过置换配体表达来生成 $W_{ab}$ 的零分布的程序。\n3.  基于此零分布计算经验 $p$ 值。\n\n**1. 观测边缘权重 $W_{ab}^{\\text{obs}}$ 的计算**\n\n细胞间边缘权重 $W_{ab}$ 定义为所有可能的信号相互作用的总和，由配体-受体对结合强度 $s_k$ 和细胞间接触概率 $C_{ij}$ 加权。公式如下：\n$$\nW_{ab} \\;=\\; \\sum_{k=1}^{K} s_k \\sum_{i=1}^{n_a} \\sum_{j=1}^{n_b} C_{ij} \\, L_{ik} \\, R_{jk}\n$$\n其中 $L \\in \\mathbb{R}_{\\ge 0}^{n_a \\times K}$ 是配体表达矩阵，$R \\in \\mathbb{R}_{\\ge 0}^{n_b \\times K}$ 是受体表达矩阵，$C \\in \\mathbb{R}_{\\ge 0}^{n_a \\times n_b}$ 是接触概率矩阵，$s \\in \\mathbb{R}_{0}^{K}$ 是结合强度向量，$n_a$ 和 $n_b$ 分别是发送细胞和接收细胞的数量，$K$ 是配体-受体对的数量。\n\n这个四重求和可以使用张量缩并高效实现。NumPy 库的 `einsum` 函数非常适合此任务。表达式 $\\sum_{k=1}^{K} \\sum_{i=1}^{n_a} \\sum_{j=1}^{n_b} s_k C_{ij} L_{ik} R_{jk}$ 可以直接转换为一个签名为 `'k,ij,ik,jk-'` 的 `einsum` 操作。这里，$i$ 代表发送细胞的索引，$j$ 代表接收细胞的索引，$k$ 代表配体-受体对的索引。输入是具有相应索引的向量/矩阵 $s$、$C$、$L$ 和 $R$。该操作对所有索引 $i$、$j$ 和 $k$ 求和，产生一个标量输出。这为计算观测权重 $W_{ab}^{\\text{obs}}$（使用原始矩阵 $L$）和置换权重 $W_{ab}^{(r)}$ 提供了一种计算高效且数值稳定的方法。\n\n**2. 零分布的生成**\n\n零假设 $H_0$ 假定，发送细胞间的配体表达模式相对于它们的接触概率是随机的。也就是说，将高或低配体表达值分配给单个发送细胞的具体方式不携带任何信息。为了模拟这种零情景，我们通过置换检验为 $W_{ab}$ 生成一个零分布。\n\n该过程涉及为 $r \\in \\{1,\\dots,R\\}$ 生成 $R$ 个置换后的边缘权重 $W_{ab}^{(r)}$。对于每个重复 $r$，我们构建一个置换后的配体矩阵 $L^{(r)}$。关键的是，问题陈述中指出，置换是“对每个配体 $k$ 独立地”执行的。这意味着对于每个置换重复 $r$，以及对于矩阵 $L$ 的每个配体（列）$k$，我们都在 $n_a$ 个发送细胞间独立地重排其表达值。\n\n算法如下：对于每个置换 $r=1, \\dots, R$：\n- 创建一个大小为 $n_a \\times K$ 的新矩阵 $L^{(r)}$。\n- 对于每一列 $k=1, \\dots, K$：\n    - $L^{(r)}$ 的第 $k$ 列，记作 $L_{\\cdot k}^{(r)}$，是 $L$ 的原始第 $k$ 列的一个随机置换，即 $L_{\\cdot k}^{(r)} = \\pi_k^{(r)}(L_{\\cdot k})$。置换 $\\pi_k^{(r)}$ 对于每个 $k$ 和 $r$ 都是独立抽取的。\n- 使用 $L^{(r)}$ 计算置换后的权重 $W_{ab}^{(r)}$：\n$$\nW^{(r)}_{ab} \\;=\\; \\sum_{k=1}^{K} s_k \\sum_{i=1}^{n_a} \\sum_{j=1}^{n_b} C_{ij} \\, L^{(r)}_{ik} \\, R_{jk}\n$$\n\n这个过程保留了每个配体表达的边际分布，但破坏了配体表达模式与细胞间接触概率之间的任何特定相关结构。\n\n一个重要的边缘情况发生在 $n_a=1$ 时。在这种情况下，只有一个发送细胞。对包含单个元素的列表进行置换会得到相同的列表。因此，对于所有 $r$，$L^{(r)} = L$，这意味着 $W_{ab}^{(r)} = W_{ab}^{\\text{obs}}$。\n\n**3. 经验 $p$ 值的计算**\n\n经验 $p$ 值是在零假设下，观测到与观测权重一样极端或更极端的权重的概率。对于上尾检验，我们计算大于或等于观测权重的置换权重的数量。问题指定了使用连续性校正，这是置换检验中的标准做法，以避免 $p$ 值为 $0$ 并确保检验是保守的。公式是：\n$$\np \\;=\\; \\frac{1 + \\sum_{r=1}^{R} \\mathbb{I}\\!\\left(W^{(r)}_{ab} \\ge W^{\\text{obs}}_{ab}\\right)}{R + 1}\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数，如果条件为真则为 $1$，否则为 $0$。分子中的 $1$ 考虑到观测到的统计量本身也是零假设下分布的一个成员。分母中的 $1$ 反映了包括观测统计量在内的分布的总大小。\n\n对于 $n_a=1$ 的边缘情况，每个 $W_{ab}^{(r)}$ 都等于 $W_{ab}^{\\text{obs}}$。条件 $W^{(r)}_{ab} \\ge W^{\\text{obs}}_{ab}$ 总是为真。因此，指示函数的总和变为 $R$。$p$ 值为 $(1+R)/(R+1) = 1$。如果接触矩阵 $C$ 全部为零，同样的逻辑也适用，因为这会迫使所有权重（$W_{ab}^{\\text{obs}}$ 和所有 $W_{ab}^{(r)}$）都为 $0$，使得不等式 $0 \\ge 0$ 总是为真。实现会正确处理这些情况。\n\n一个专用函数封装了这整个过程，它将数据矩阵、置换次数 $R$ 和用于可复现性的随机种子作为输入，并返回最终的 $p$ 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_p_value(L, R_mat, C, s, num_permutations, seed):\n    \"\"\"\n    Computes the empirical p-value for an intercellular edge weight.\n\n    Args:\n        L (np.ndarray): Ligand expression matrix (n_a x K).\n        R_mat (np.ndarray): Receptor expression matrix (n_b x K).\n        C (np.ndarray): Contact probability matrix (n_a x n_b).\n        s (np.ndarray): Binding strengths vector (K,).\n        num_permutations (int): Number of permutations (R).\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        float: The calculated upper-tail p-value.\n    \"\"\"\n\n    def calculate_W_ab(ligand_matrix, receptor_matrix, contact_matrix, strengths_vector):\n        \"\"\"Calculates the edge weight using einsum for efficiency.\"\"\"\n        # W_ab = sum_{k,i,j} s_k * C_ij * L_ik * R_jk\n        # Indices: i=sender cell, j=receiver cell, k=ligand-receptor pair\n        return np.einsum('k,ij,ik,jk->', strengths_vector, contact_matrix, ligand_matrix, receptor_matrix, optimize=True)\n\n    n_a = L.shape[0]\n\n    # Calculate the observed edge weight\n    W_obs = calculate_W_ab(L, R_mat, C, s)\n\n    # Edge case: If n_a=1, permutations are the identity map.\n    # W_perm will always be W_obs. The p-value is 1.\n    # Also handles the case where W_obs is 0 due to C=0, as W_perm will also be 0.\n    if n_a == 1 or W_obs == 0:\n        if W_obs == 0:\n             # If observed weight is zero, all permuted weights will also be zero.\n             # So W_perm >= W_obs is always true.\n             return (1.0 + num_permutations) / (1.0 + num_permutations)\n        return 1.0\n\n\n    # Initialize the random number generator for permutation\n    rng = np.random.default_rng(seed)\n\n    # Perform the permutation test\n    count_ge = 0\n    \n    for _ in range(num_permutations):\n        # Create a new permuted ligand matrix for each permutation replicate\n        L_perm = np.empty_like(L)\n        for k in range(L.shape[1]):\n            # rng.permutation returns a new shuffled array, leaving the original unchanged\n            L_perm[:, k] = rng.permutation(L[:, k])\n        \n        # Calculate the permuted weight\n        W_perm = calculate_W_ab(L_perm, R_mat, C, s)\n\n        if W_perm >= W_obs:\n            count_ge += 1\n\n    # Calculate the empirical p-value with continuity correction\n    p_value = (1.0 + count_ge) / (1.0 + num_permutations)\n    \n    return p_value\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the analysis, and print results.\n    \"\"\"\n    test_cases = [\n        {\n            # Test case 1 (general case)\n            \"L\": np.array([\n                [2.0, 0.5, 1.0],\n                [1.5, 2.0, 0.0],\n                [3.0, 1.0, 0.5],\n                [0.2, 3.5, 2.0]\n            ]),\n            \"R_mat\": np.array([\n                [0.5, 0.0, 1.0],\n                [1.0, 1.5, 0.5],\n                [0.2, 2.0, 0.0],\n                [1.5, 0.5, 1.5],\n                [0.0, 1.0, 0.2]\n            ]),\n            \"C\": np.array([\n                [0.9, 0.1, 0.0, 0.0, 0.0],\n                [0.0, 0.8, 0.1, 0.0, 0.0],\n                [0.0, 0.0, 0.7, 0.2, 0.0],\n                [0.0, 0.0, 0.0, 0.6, 0.4]\n            ]),\n            \"s\": np.array([1.0, 0.8, 0.5]),\n            \"num_permutations\": 1000,\n            \"seed\": 42\n        },\n        {\n            # Test case 2 (boundary: zero contact)\n            \"L\": np.array([\n                [1.0, 2.0],\n                [0.0, 1.5],\n                [3.0, 0.5]\n            ]),\n            \"R_mat\": np.array([\n                [0.5, 1.0],\n                [1.0, 0.0],\n                [0.0, 1.5]\n            ]),\n            \"C\": np.array([\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0]\n            ]),\n            \"s\": np.array([1.0, 1.0]),\n            \"num_permutations\": 500,\n            \"seed\": 7\n        },\n        {\n            # Test case 3 (edge case: single ligand–receptor pair with concentrated contact)\n            \"L\": np.array([\n                [0.0],\n                [0.0],\n                [10.0],\n                [0.0]\n            ]),\n            \"R_mat\": np.array([\n                [0.0],\n                [5.0],\n                [0.0],\n                [0.0]\n            ]),\n            \"C\": np.array([\n                [0.05, 0.05, 0.05, 0.05],\n                [0.05, 0.05, 0.05, 0.05],\n                [0.05, 1.00, 0.05, 0.05],\n                [0.05, 0.05, 0.05, 0.05]\n            ]),\n            \"s\": np.array([1.0]),\n            \"num_permutations\": 1000,\n            \"seed\": 123\n        },\n        {\n            # Test case 4 (boundary: single-cell sender)\n            \"L\": np.array([\n                [2.0, 4.0]\n            ]),\n            \"R_mat\": np.array([\n                [3.0, 1.0]\n            ]),\n            \"C\": np.array([\n                [0.5]\n            ]),\n            \"s\": np.array([1.0, 0.1]),\n            \"num_permutations\": 1000,\n            \"seed\": 21\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p_val = compute_p_value(**case)\n        results.append(p_val)\n\n    # Format the results as a comma-separated list of strings with 6 decimal places\n    formatted_results = [f\"{p:.6f}\" for p in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4355885"}, {"introduction": "生物信息学分析遵循“垃圾进，垃圾出”的原则。单细胞数据中存在着独特的伪影，例如“双细胞 (doublets)”，它们可能产生虚假的通讯信号。本练习将展示如何利用生物学知识（例如，不相容的标记基因）来构建一个统计诊断工具，以估计双细胞率并标记可疑的通讯边。[@problem_id:4355937]", "problem": "一项基于液滴的单细胞核糖核酸测序（scRNA-seq）实验会生成一组条形码（barcodes），理想情况下每个条形码对应一个细胞。然而，一部分条形码是双细胞（doublets），当两个不同的细胞被一同捕获时形成。考虑一个包含两种不相交细胞类型（记为 $C_A$ 和 $C_B$）的组织，其标记基因 $M_A$ 和 $M_B$ 在单细胞（singlets）中是生物学上不相容的（即，真正的 $C_A$ 型单细胞不表达 $M_B$，真正的 $C_B$ 型单细胞不表达 $M_A$）。设 $N$ 为条形码的总数。设 $p_A$ 和 $p_B$ 分别是源自细胞类型 $C_A$ 和 $C_B$ 的单细胞条形码所占的比例，满足 $p_A + p_B \\leq 1$。假设双细胞是由从具有相同群体比例的总体中独立抽样的两个单细胞随机配对形成的。环境污染导致在单细胞中对每个标记基因的假阳性检测概率为 $\\epsilon$（每个标记基因），此事件在不同标记基因和条形码之间独立发生，且 $\\epsilon \\ll 1$。假设所有检测在给定潜在细胞身份和双细胞状态的条件下都是独立的。\n\n一种细胞间通讯推断算法通过聚合所有条形码中的配体-受体共表达证据，构建了 $C_A$ 和 $C_B$ 之间的一条假定存在的边。你怀疑这条边可能因为双细胞的存在而被夸大了，因为双细胞可以在同一个条形码内表现出 $M_A$ 和 $M_B$ 的共表达。为了构建一个诊断工具，你决定使用生物学上不相容标记基因的经验共表达率，记为 $\\hat{p}_{AB}$，其定义为同时检测到 $M_A$ 和 $M_B$ 的条形码所占的观测比例。\n\n给定一个数据集的以下测量值：$N = 10000$，$p_A = 0.35$，$p_B = 0.25$，$\\epsilon = 0.005$，以及 $\\hat{p}_{AB} = 0.02$。通过一种正交方法得到的基线全局双细胞率估计值为 $d_0 = 0.06$。你将在双侧显著性水平 $\\alpha = 0.01$ 下进行分析。\n\n仅使用上述核心定义以及混合过程和二项抽样变异性的标准概率推理，从第一性原理出发，推导共表达的期望概率 $\\Pr(M_A \\land M_B)$（用双细胞率 $d$ 表示），然后得到 $d$ 的一个估计量（用 $\\hat{p}_{AB}$ 和已知量表示）。在 $\\hat{p}_{AB}$ 的二项模型下，使用 delta 方法推导该估计量的相应标准误。最后，选择一个选项，该选项给出了一个正确的诊断规则，用于标记 $C_A$ 和 $C_B$ 之间的通讯边因双细胞而被夸大，该规则需包括正确的估计量和相对于 $d_0$ 在显著性水平 $\\alpha$ 下的正确显著性检验：\n\nA. 计算 $\\hat{d} = \\dfrac{\\hat{p}_{AB} - \\epsilon (p_A + p_B)}{2 p_A p_B - \\epsilon (p_A + p_B)}$，如果 $\\hat{d} - d_0  z_{1-\\alpha/2} \\,\\mathrm{SE}(\\hat{d})$ 则进行标记，其中 $z_{1-\\alpha/2}$ 是标准正态分位数，且 $\\mathrm{SE}(\\hat{d}) = \\sqrt{\\dfrac{\\hat{p}_{AB}(1-\\hat{p}_{AB})}{N}} \\Big/ \\big(2 p_A p_B - \\epsilon (p_A + p_B)\\big)$。\n\nB. 计算 $\\hat{d} = \\dfrac{\\hat{p}_{AB}}{p_A p_B}$，如果 $\\hat{d}  d_0$ 则进行标记，无需任何统计检验，因为该比率已经考虑了随机混合。\n\nC. 计算 $\\hat{d} = \\hat{p}_{AB} - \\epsilon^2$，如果 $\\hat{d} - d_0  z_{1-\\alpha} \\sqrt{\\dfrac{\\hat{p}_{AB}(1-\\hat{p}_{AB})}{N}}$ 则进行标记，因为环境污染以 $\\epsilon^2$ 的速率产生共表达，应将其减去。\n\nD. 计算 $S = \\dfrac{\\hat{p}_{AB}}{\\hat{p}_A \\hat{p}_B}$，其中 $\\hat{p}_A$ 和 $\\hat{p}_B$ 是 $M_A$ 和 $M_B$ 的观测边际检测率，如果 $S  1 + \\delta$（对于某个固定的 $\\delta$）则进行标记，因为 $S$ 衡量了与独立性的偏差。\n\nE. 计算 $\\hat{d} = \\dfrac{\\hat{p}_{AB} - \\epsilon (p_A + p_B)}{p_A + p_B - p_A p_B}$，如果 $\\hat{d} - d_0  z_{1-\\alpha/2} \\,\\mathrm{SE}(\\hat{d})$ 则进行标记，其中 $\\mathrm{SE}(\\hat{d})$ 如选项 A 所示。", "solution": "用户需要对问题陈述进行严格验证，然后从第一性原理推导解决方案，并对所提供的选项进行评估。\n\n### 问题验证\n\n**第1步：提取已知条件**\n- 细胞类型：$C_A$ 和 $C_B$，不相交。\n- 标记基因：$M_A$ 对应 $C_A$，$M_B$ 对应 $C_B$。\n- 生物学不相容性：$C_A$ 型单细胞不表达 $M_B$，而 $C_B$ 型单细胞不表达 $M_A$。\n- $N$：条形码总数，$N = 10000$。\n- $p_A$：来自 $C_A$ 的单细胞条形码比例，$p_A = 0.35$。\n- $p_B$：来自 $C_B$ 的单细胞条形码比例，$p_B = 0.25$。\n- 双细胞形成：两个独立抽样的单细胞随机配对。\n- $\\epsilon$：由于环境污染，在单细胞中每个标记基因的假阳性检测概率，$\\epsilon = 0.005$。检测是独立的。\n- $\\hat{p}_{AB}$：同时检测到 $M_A$ 和 $M_B$ 的条形码的观测比例，$\\hat{p}_{AB} = 0.02$。\n- $d_0$：基线全局双细胞率估计值，$d_0 = 0.06$。\n- $\\alpha$：双侧显著性水平，$\\alpha = 0.01$。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题基于单细胞基因组学中的既定概念。双细胞、环境RNA污染、标记基因以及使用不相容标记基因检测人为产物都是scRNA-seq分析中的标准和现实组成部分。所提供的数值对于一个典型的实验是合理的。\n- **良态问题：** 该问题提供了一个清晰的概率模型，并要求推导估计量、其标准误和统计检验。假设被明确陈述，使得问题可以用唯一答案解决。\n- **客观性：** 问题以精确、定量和无偏见的语言陈述。\n\n**第3步：结论与行动**\n问题陈述在科学上是合理的、良态的且客观的。它没有违反任何无效标准。因此，该问题是**有效的**。我将继续进行推导。\n\n### 解题推导\n\n目标是推导双细胞率 $d$ 的估计量，并用它来构建一个统计检验。我们首先推导观测到 $M_A$ 和 $M_B$ 共表达的理论概率，记为 $p_{AB} = \\Pr(M_A \\land M_B)$。\n\n设 $d$ 为双细胞条形码的真实比例。单细胞的比例是 $(1-d)$。\n设 $S$ 表示一个条形码是单细胞的事件，$D$ 表示它是双细胞的事件。\n使用全概率定律，我们可以将共检测的概率写为：\n$$p_{AB} = \\Pr(M_A \\land M_B) = \\Pr(M_A \\land M_B | S) \\Pr(S) + \\Pr(M_A \\land M_B | D) \\Pr(D)$$\n$$p_{AB} = (1-d) \\Pr(M_A \\land M_B | S) + d \\Pr(M_A \\land M_B | D)$$\n\n**1. 单细胞中的共检测概率：$\\Pr(M_A \\land M_B | S)$**\n一个单细胞可以是 $C_A$ 类型（概率为 $p_A$），$C_B$ 类型（概率为 $p_B$），或者其他类型 $C_{other}$（概率为 $1 - p_A - p_B$）。\n让我们分析每种单细胞类型的检测概率，假设一个真实表达的基因被检测到的概率为 $1$，一个未表达的基因由于污染而被检测到的概率为 $\\epsilon$。每个标记基因的检测是独立的。\n\n- 对于一个 $C_A$ 单细胞：$M_A$ 表达，$M_B$ 不表达。\n  $\\Pr(M_A \\text{ 被检测}) = 1$。$\\Pr(M_B \\text{ 被检测}) = \\epsilon$。\n  $\\Pr(M_A \\land M_B | C_A) = 1 \\cdot \\epsilon = \\epsilon$。\n- 对于一个 $C_B$ 单细胞：$M_B$ 表达，$M_A$ 不表达。\n  $\\Pr(M_A \\text{ 被检测}) = \\epsilon$。$\\Pr(M_B \\text{ 被检测}) = 1$。\n  $\\Pr(M_A \\land M_B | C_B) = \\epsilon \\cdot 1 = \\epsilon$。\n- 对于一个 $C_{other}$ 单细胞：$M_A$ 和 $M_B$ 都不表达。\n  $\\Pr(M_A \\text{ 被检测}) = \\epsilon$。$\\Pr(M_B \\text{ 被检测}) = \\epsilon$。\n  $\\Pr(M_A \\land M_B | C_{other}) = \\epsilon \\cdot \\epsilon = \\epsilon^2$。\n\n对所有类型的单细胞求和：\n$$\\Pr(M_A \\land M_B | S) = p_A \\cdot \\epsilon + p_B \\cdot \\epsilon + (1 - p_A - p_B) \\cdot \\epsilon^2 = \\epsilon(p_A + p_B) + O(\\epsilon^2)$$\n因为 $\\epsilon = 0.005 \\ll 1$，$\\epsilon^2$ 项是可忽略的。我们近似为：\n$$\\Pr(M_A \\land M_B | S) \\approx \\epsilon(p_A + p_B)$$\n\n**2. 双细胞中的共检测概率：$\\Pr(M_A \\land M_B | D)$**\n一个双细胞是由两个单细胞随机配对形成的。真实共表达的关键事件是形成一个 $C_A$-$C_B$ 双细胞。\n- 挑选一个 $C_A$ 单细胞的概率是 $p_A$。\n- 挑选一个 $C_B$ 单细胞的概率是 $p_B$。\n形成一个 $C_A$-$C_B$ 双细胞（不考虑顺序）的概率是 $p_A p_B + p_B p_A = 2 p_A p_B$。在这样的双细胞中，$M_A$ 和 $M_B$ 都真实存在。假设表达的基因的检测概率为 $1$，那么共检测是确定的，即 $\\Pr(M_A \\land M_B | C_A\\text{-}C_B \\text{ 双细胞}) = 1$。\n\n其他类型的双细胞（例如，$C_A$-$C_A$，$C_A$-$C_{other}$）只能通过污染导致共检测。例如，在一个 $C_A$-$C_A$ 双细胞中，$M_A$ 表达而 $M_B$ 不表达。共检测发生的概率为 $\\epsilon$。\n双细胞共检测的完整表达式是 $\\Pr(M_A \\land M_B|D) = 2p_Ap_B \\cdot 1 + (\\text{其他双细胞概率}) \\cdot O(\\epsilon)$。\n考虑到选项的结构，意图是做一个简化假设：忽略双细胞内部的污染效应，因为它们的量级是 $\\epsilon$，而在双细胞中共检测的主要机制是形成 $C_A$-$C_B$ 对。如果 $2p_Ap_B \\gg O(\\epsilon)$，这个近似是合理的。让我们用给定的值来验证：$2p_Ap_B = 2(0.35)(0.25) = 0.175$，远大于 $\\epsilon = 0.005$。\n因此，我们做如下近似：\n$$\\Pr(M_A \\land M_B | D) \\approx 2 p_A p_B$$\n\n**3. 总共表达概率和 $d$ 的估计量**\n将近似值代回主方程：\n$$p_{AB} \\approx (1-d) \\epsilon(p_A + p_B) + d (2 p_A p_B)$$\n重新整理以求解 $d$：\n$$p_{AB} - \\epsilon(p_A + p_B) \\approx d (2 p_A p_B) - d \\epsilon(p_A + p_B)$$\n$$p_{AB} - \\epsilon(p_A + p_B) \\approx d [2 p_A p_B - \\epsilon(p_A + p_B)]$$\n$$d \\approx \\frac{p_{AB} - \\epsilon(p_A + p_B)}{2 p_A p_B - \\epsilon(p_A + p_B)}$$\n这通过用经验估计 $\\hat{p}_{AB}$ 替换理论概率 $p_{AB}$，给出了 $d$ 的估计量：\n$$\\hat{d} = \\frac{\\hat{p}_{AB} - \\epsilon(p_A + p_B)}{2 p_A p_B - \\epsilon(p_A + p_B)}$$\n\n**4. 估计量的标准误**\n我们使用 delta 方法来求 $\\hat{d}$ 的标准误。估计量 $\\hat{d}$ 是 $\\hat{p}_{AB}$ 的函数，形式为 $\\hat{d} = g(\\hat{p}_{AB}) = \\frac{\\hat{p}_{AB} - C_1}{C_2}$，其中 $C_1 = \\epsilon(p_A + p_B)$ 和 $C_2 = 2 p_A p_B - \\epsilon(p_A + p_B)$ 是常数。\n$\\hat{d}$ 的方差近似为：\n$$\\mathrm{Var}(\\hat{d}) \\approx \\left( g'(\\mathbb{E}[\\hat{p}_{AB}]) \\right)^2 \\mathrm{Var}(\\hat{p}_{AB})$$\n导数是 $g'(x) = 1/C_2$。\n在二项抽样模型下，$\\hat{p}_{AB}$ 的方差是 $\\mathrm{Var}(\\hat{p}_{AB}) = \\frac{p_{AB}(1-p_{AB})}{N}$，其估计值为 $\\frac{\\hat{p}_{AB}(1-\\hat{p}_{AB})}{N}$。\n结合这些：\n$$\\mathrm{Var}(\\hat{d}) \\approx \\left( \\frac{1}{2 p_A p_B - \\epsilon(p_A + p_B)} \\right)^2 \\frac{\\hat{p}_{AB}(1-\\hat{p}_{AB})}{N}$$\n标准误 $\\mathrm{SE}(\\hat{d})$ 是方差的平方根：\n$$\\mathrm{SE}(\\hat{d}) \\approx \\frac{1}{|2 p_A p_B - \\epsilon(p_A + p_B)|} \\sqrt{\\frac{\\hat{p}_{AB}(1-\\hat{p}_{AB})}{N}}$$\n使用给定值，$2 p_A p_B - \\epsilon(p_A + p_B) = 0.175 - 0.005(0.6) = 0.172  0$，所以绝对值不是必需的。\n$$\\mathrm{SE}(\\hat{d}) = \\sqrt{\\frac{\\hat{p}_{AB}(1-\\hat{p}_{AB})}{N}} \\bigg/ \\left( 2 p_A p_B - \\epsilon(p_A + p_B) \\right)$$\n\n**5. 显著性检验**\n我们想检验估计的双细胞率 $\\hat{d}$ 是否显著大于基线值 $d_0=0.06$。问题要求一个“标记”夸大的规则，这暗示了一个单侧检验 ($H_a: d  d_0$)。然而，它指定了一个“双侧显著性水平 $\\alpha=0.01$”，并且选项A使用了相应的双侧临界值分位数 $z_{1-\\alpha/2}$。这表明一个程序，其中执行了双侧检验，但只有当结果在正方向上显著时才得出结论。\n检验统计量是 $Z = \\frac{\\hat{d} - d_0}{\\mathrm{SE}(\\hat{d})}$。\n标记规则是，如果 $Z  z_{1-\\alpha/2}$，则拒绝 $H_0: d=d_0$ 并支持 $dd_0$。这等价于如果 $\\hat{d} - d_0  z_{1-\\alpha/2} \\mathrm{SE}(\\hat{d})$ 则进行标记。\n\n### 选项评估\n\n**A. 计算 $\\hat{d} = \\dfrac{\\hat{p}_{AB} - \\epsilon (p_A + p_B)}{2 p_A p_B - \\epsilon (p_A + p_B)}$，如果 $\\hat{d} - d_0  z_{1-\\alpha/2} \\,\\mathrm{SE}(\\hat{d})$ 则进行标记，其中 $z_{1-\\alpha/2}$ 是标准正态分位数，且 $\\mathrm{SE}(\\hat{d}) = \\sqrt{\\dfrac{\\hat{p}_{AB}(1-\\hat{p}_{AB})}{N}} \\Big/ \\big(2 p_A p_B - \\epsilon (p_A + p_B)\\big)$。**\n- 估计量 $\\hat{d}$ 与我们基于一个合理的简化模型得出的推导完全匹配。\n- 标准误 $\\mathrm{SE}(\\hat{d})$ 与应用于此估计量的 delta 方法的结果完全匹配。\n- 统计检验与推导出的量一致，并代表了一个有效（尽管略显非正式）的标记夸大值的程序。\n- **结论：正确。**\n\n**B. 计算 $\\hat{d} = \\dfrac{\\hat{p}_{AB}}{p_A p_B}$，如果 $\\hat{d}  d_0$ 则进行标记，无需任何统计检验，因为该比率已经考虑了随机混合。**\n- 这个估计量是错误的。它忽略了双细胞中 $C_A, C_B$ 两种排序带来的因子 $2$，并且完全忽略了污染 $\\epsilon$ 的贡献。\n- 建议放弃统计检验是不恰当的，因为 $\\hat{d}$ 是一个受抽样变异性影响的估计值。\n- **结论：错误。**\n\n**C. 计算 $\\hat{d} = \\hat{p}_{AB} - \\epsilon^2$，如果 $\\hat{d} - d_0  z_{1-\\alpha} \\sqrt{\\dfrac{\\hat{p}_{AB}(1-\\hat{p}_{AB})}{N}}$ 则进行标记，因为环境污染以 $\\epsilon^2$ 的速率产生共表达，应将其减去。**\n- 估计量 $\\hat{d} = \\hat{p}_{AB} - \\epsilon^2$ 是错误的。它只考虑了既不是 $C_A$ 也不是 $C_B$ 的单细胞中的污染，忽略了来自 $C_A$ 和 $C_B$ 单细胞的量级为 $\\epsilon$ 的大得多的污染项。\n- 使用的标准误是 $\\hat{p}_{AB}$ 的，而不是 $\\hat{d}$ 的。\n- **结论：错误。**\n\n**D. 计算 $S = \\dfrac{\\hat{p}_{AB}}{\\hat{p}_A \\hat{p}_B}$，其中 $\\hat{p}_A$ 和 $\\hat{p}_B$ 是 $M_A$ 和 $M_B$ 的观测边际检测率，如果 $S  1 + \\delta$（对于某个固定的 $\\delta$）则进行标记，因为 $S$ 衡量了与独立性的偏差。**\n- 这种方法计算的是一个得分 $S$，而不是问题所要求的双细胞率 $d$ 的估计量。\n- 它还错误地引入了新的未定义量 $\\hat{p}_A$ 和 $\\hat{p}_B$（问题给出的是 $p_A, p_B$作为已知单细胞的比例，而不是总条形码的比例）。\n- **结论：错误。**\n\n**E. 计算 $\\hat{d} = \\dfrac{\\hat{p}_{AB} - \\epsilon (p_A + p_B)}{p_A + p_B - p_A p_B}$，如果 $\\hat{d} - d_0  z_{1-\\alpha/2} \\,\\mathrm{SE}(\\hat{d})$ 则进行标记，其中 $\\mathrm{SE}(\\hat{d})$ 如选项 A 所示。**\n- 估计量的分子是合理的，代表了校正了主要污染项后的共表达率。\n- 分母 $p_A + p_B - p_A p_B$ 并非从我们的推导中得出，并且在这种情况下缺乏明确的物理解释。分母应该是 $p_{AB}$ 表达式中 $d$ 的系数，我们发现该系数为 $2p_Ap_B - \\epsilon(p_A+p_B)$。\n- **结论：错误。**\n\n总结：只有选项A为估计量、其标准误和统计检验提供了一个一致的框架，该框架基于对潜在过程的一个合理且可推导（尽管简化了）的模型。", "answer": "$$\\boxed{A}$$", "id": "4355937"}, {"introduction": "即使拥有统计上显著且高质量的数据，相关性也不等同于因果性。最后一个练习探讨了因果推断中一个微妙但至关重要的陷阱，即“对撞偏倚 (collider bias)”。通过一个结构模型，本练习将揭示看似合理的统计“控制”（例如对受体表达进行校正）实际上如何引入偏倚，从而导致对配体-细胞响应因果效应的错误结论。[@problem_id:4355888]", "problem": "考虑一个简单的机制模型，用于描述发送细胞 $i$ 和接收细胞 $j$ 之间的细胞间通讯，在该模型中，发送细胞表达配体 $L_i$，接收细胞表达同源受体 $R_j$，该受体介导转录反应 $T_j$。假设存在一个未被观察到的接收细胞状态变量 $U_j$（例如，分化或应激状态），它同时影响 $R_j$ 和 $T_j$。为了研究 $L_i$ 对 $T_j$ 的因果效应，一些分析会控制观察到的受体水平 $R_j$ 以“确保受体可用性”，但这可能会引入对撞偏倚，因为 $R_j$ 可能同时受到 $L_i$ 和 $U_j$ 的影响。您将在线性高斯结构模型下，量化这种由对撞偏倚引起的失真幅度。\n\n假设以下线性结构方程，其中所有变量都中心化至均值为零：\n1. $L_i \\sim \\mathcal{N}(0,\\sigma_L^2)$，$U_j \\sim \\mathcal{N}(0,\\sigma_U^2)$，且 $L_i \\perp U_j$。\n2. $R_j = \\alpha_{LR} L_i + \\alpha_{UR} U_j + \\varepsilon_R$，其中 $\\varepsilon_R \\sim \\mathcal{N}(0,\\sigma_{\\varepsilon_R}^2)$ 且 $\\varepsilon_R$ 独立于 $L_i$ 和 $U_j$。\n3. $T_j = \\gamma_L L_i + \\gamma_R R_j + \\alpha_{UT} U_j + \\varepsilon_T$，其中 $\\varepsilon_T \\sim \\mathcal{N}(0,\\sigma_{\\varepsilon_T}^2)$ 且 $\\varepsilon_T$ 独立于 $L_i$、$U_j$ 和 $\\varepsilon_R$。\n\n您考虑将 $T_j$ 对 $L_i$ 和 $R_j$ 进行普通最小二乘（OLS）回归（即，控制观察到的 $R_j$ 但不控制未观察到的 $U_j$）。设此回归中 $L_i$ 的 OLS 系数的大样本极限表示为 $\\beta_L$。关注的目标因果效应是 $\\gamma_L$。将对撞偏倚引起的渐近偏倚定义为 $B \\equiv \\beta_L - \\gamma_L$。\n\n仅使用上述假设和关于多元正态设定中线性投影的基本事实，推导出一个关于 $\\alpha_{LR}$、$\\alpha_{UR}$、$\\alpha_{UT}$、$\\sigma_U^2$ 和 $\\sigma_{\\varepsilon_R}^2$ 的 $B$ 的闭式表达式。您的最终答案必须是一个仅包含这些参数的、简化的 $B$ 的解析表达式。不要提供中间方程，也不要包含任何单位。请定性地（用文字）解释为什么在这种设定下，当以 $R_j$ 为条件时 $B$ 可以非零，但最终答案只报告 $B$ 的表达式。", "solution": "问题陈述是因果推断领域中一个适定且有科学依据的练习，具体涉及线性结构方程模型框架下的对撞分层偏倚。它为推导一个唯一且有意义的解提供了所有必要的假设和定义。因此，该问题被认为是有效的。\n\n目标是计算渐近偏倚 $B \\equiv \\beta_L - \\gamma_L$，其中 $\\beta_L$ 是在 $T_j$ 对 $L_i$ 和 $R_j$ 的回归中，$L_i$ 的大样本普通最小二乘（OLS）系数。$L_i$ 对 $T_j$ 的目标因果效应由参数 $\\gamma_L$ 给出。\n\n因变量 $Y$ 对一组回归量 $X$ 进行回归的大样本（总体）OLS 系数由公式 $\\beta = (E[XX^T])^{-1}E[XY]$ 给出。在我们的例子中，因变量是 $T_j$，回归量是 $X_1 = L_i$ 和 $X_2 = R_j$。系数向量是 $\\begin{pmatrix} \\beta_L \\\\ \\beta_R \\end{pmatrix}$。公式为：\n$$\n\\begin{pmatrix} \\beta_L \\\\ \\beta_R \\end{pmatrix} = \\begin{pmatrix} E[L_i^2]  E[L_i R_j] \\\\ E[R_j L_i]  E[R_j^2] \\end{pmatrix}^{-1} \\begin{pmatrix} E[L_i T_j] \\\\ E[R_j T_j] \\end{pmatrix}\n$$\n由于所有变量都已中心化至均值为零，因此乘积的期望即为协方差，平方的期望即为方差。设 $\\Sigma_{XX}$ 为回归量的协方差矩阵，$\\Sigma_{XT}$ 为回归量与因变量之间的协方差向量。\n$$\n\\Sigma_{XX} = \\begin{pmatrix} \\text{Var}(L_i)  \\text{Cov}(L_i, R_j) \\\\ \\text{Cov}(L_i, R_j)  \\text{Var}(R_j) \\end{pmatrix}, \\quad \\Sigma_{XT} = \\begin{pmatrix} \\text{Cov}(L_i, T_j) \\\\ \\text{Cov}(R_j, T_j) \\end{pmatrix}\n$$\n我们通过给定的结构方程来计算所需的方差和协方差。\n\n1.  **回归量的协方差矩阵 ($\\Sigma_{XX}$):**\n    *   $\\text{Var}(L_i) = \\sigma_L^2$（给定）。\n    *   $\\text{Cov}(L_i, R_j) = \\text{Cov}(L_i, \\alpha_{LR} L_i + \\alpha_{UR} U_j + \\varepsilon_R)$。利用协方差的线性和独立性假设（$L_i \\perp U_j, L_i \\perp \\varepsilon_R$），我们得到：\n        $\\text{Cov}(L_i, R_j) = \\alpha_{LR} \\text{Var}(L_i) + \\alpha_{UR} \\text{Cov}(L_i, U_j) + \\text{Cov}(L_i, \\varepsilon_R) = \\alpha_{LR} \\sigma_L^2$。\n    *   $\\text{Var}(R_j) = \\text{Var}(\\alpha_{LR} L_i + \\alpha_{UR} U_j + \\varepsilon_R)$。由于 $L_i, U_j, \\varepsilon_R$ 相互独立：\n        $\\text{Var}(R_j) = \\alpha_{LR}^2 \\text{Var}(L_i) + \\alpha_{UR}^2 \\text{Var}(U_j) + \\text{Var}(\\varepsilon_R) = \\alpha_{LR}^2 \\sigma_L^2 + \\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2$。\n\n2.  **协方差向量 ($\\Sigma_{XT}$):**\n    为了计算与 $T_j$ 的协方差，我们首先将 $R_j$ 的表达式代入 $T_j$ 的方程中：\n    $T_j = \\gamma_L L_i + \\gamma_R (\\alpha_{LR} L_i + \\alpha_{UR} U_j + \\varepsilon_R) + \\alpha_{UT} U_j + \\varepsilon_T$\n    $T_j = (\\gamma_L + \\gamma_R \\alpha_{LR}) L_i + (\\gamma_R \\alpha_{UR} + \\alpha_{UT}) U_j + \\gamma_R \\varepsilon_R + \\varepsilon_T$。\n    *   $\\text{Cov}(L_i, T_j) = \\text{Cov}(L_i, (\\gamma_L + \\gamma_R \\alpha_{LR}) L_i + \\dots)$。由于 $L_i$ 独立于 $U_j$、$\\varepsilon_R$ 和 $\\varepsilon_T$：\n        $\\text{Cov}(L_i, T_j) = (\\gamma_L + \\gamma_R \\alpha_{LR}) \\text{Var}(L_i) = (\\gamma_L + \\gamma_R \\alpha_{LR}) \\sigma_L^2$。\n    *   $\\text{Cov}(R_j, T_j) = \\text{Cov}(\\alpha_{LR} L_i + \\alpha_{UR} U_j + \\varepsilon_R, (\\gamma_L + \\gamma_R \\alpha_{LR}) L_i + (\\gamma_R \\alpha_{UR} + \\alpha_{UT}) U_j + \\gamma_R \\varepsilon_R + \\varepsilon_T)$。\n        利用协方差的双线性和注意到 $L_i, U_j, \\varepsilon_R, \\varepsilon_T$ 相互独立（除了 $\\varepsilon_R$ 出现在两项中），展开此式：\n        $\\text{Cov}(R_j, T_j) = \\alpha_{LR} (\\gamma_L + \\gamma_R \\alpha_{LR}) \\text{Var}(L_i) + \\alpha_{UR} (\\gamma_R \\alpha_{UR} + \\alpha_{UT}) \\text{Var}(U_j) + \\gamma_R \\text{Var}(\\varepsilon_R)$\n        $= \\alpha_{LR} (\\gamma_L + \\gamma_R \\alpha_{LR}) \\sigma_L^2 + \\alpha_{UR} (\\gamma_R \\alpha_{UR} + \\alpha_{UT}) \\sigma_U^2 + \\gamma_R \\sigma_{\\varepsilon_R}^2$。\n\n3.  **求解 $\\beta_L$:**\n    系数 $\\beta_L$ 是向量 $\\Sigma_{XX}^{-1} \\Sigma_{XT}$ 的第一个元素。使用 $2 \\times 2$ 矩阵的逆矩阵公式 $\\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}^{-1} = \\frac{1}{ad-bc} \\begin{pmatrix} d  -b \\\\ -c  a \\end{pmatrix}$，我们关心的是 $\\Sigma_{XX}^{-1}$ 的第一行：\n    $\\beta_L = \\frac{1}{\\det(\\Sigma_{XX})} [ \\text{Var}(R_j) \\text{Cov}(L_i, T_j) - \\text{Cov}(L_i, R_j) \\text{Cov}(R_j, T_j) ]$。\n    行列式为：\n    $\\det(\\Sigma_{XX}) = \\text{Var}(L_i) \\text{Var}(R_j) - (\\text{Cov}(L_i, R_j))^2$\n    $= \\sigma_L^2 (\\alpha_{LR}^2 \\sigma_L^2 + \\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2) - (\\alpha_{LR} \\sigma_L^2)^2$\n    $= \\alpha_{LR}^2 \\sigma_L^4 + \\sigma_L^2 (\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2) - \\alpha_{LR}^2 \\sigma_L^4 = \\sigma_L^2 (\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2)$。\n\n    现在，我们计算 $\\beta_L$ 的分子：\n    $\\text{Num}(\\beta_L) = (\\alpha_{LR}^2 \\sigma_L^2 + \\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2) \\cdot ((\\gamma_L + \\gamma_R \\alpha_{LR}) \\sigma_L^2) - (\\alpha_{LR} \\sigma_L^2) \\cdot (\\alpha_{LR}(\\gamma_L + \\gamma_R\\alpha_{LR})\\sigma_L^2 + \\alpha_{UR}(\\gamma_R\\alpha_{UR} + \\alpha_{UT})\\sigma_U^2 + \\gamma_R \\sigma_{\\varepsilon_R}^2)$\n    \n    展开并找出可以消掉的项：\n    第一部分中的项 $(\\alpha_{LR}^2 \\sigma_L^2) \\cdot ((\\gamma_L + \\gamma_R \\alpha_{LR}) \\sigma_L^2)$ 与第二部分中的项 $-(\\alpha_{LR} \\sigma_L^2) \\cdot (\\alpha_{LR}(\\gamma_L + \\gamma_R\\alpha_{LR})\\sigma_L^2)$ 相抵消。\n    \n    剩余的分子为：\n    $\\text{Num}(\\beta_L) = (\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2)(\\gamma_L + \\gamma_R \\alpha_{LR})\\sigma_L^2 - \\alpha_{LR}\\sigma_L^2[\\alpha_{UR}(\\gamma_R\\alpha_{UR} + \\alpha_{UT})\\sigma_U^2 + \\gamma_R \\sigma_{\\varepsilon_R}^2]$\n    \n    除以 $\\det(\\Sigma_{XX}) = \\sigma_L^2 (\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2)$：\n    $\\beta_L = (\\gamma_L + \\gamma_R \\alpha_{LR}) - \\frac{\\alpha_{LR}[\\alpha_{UR}(\\gamma_R\\alpha_{UR} + \\alpha_{UT})\\sigma_U^2 + \\gamma_R \\sigma_{\\varepsilon_R}^2]}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2}$\n    \n    我们来简化被减去的分数：\n    $\\frac{\\alpha_{LR}[\\gamma_R\\alpha_{UR}^2\\sigma_U^2 + \\alpha_{UR}\\alpha_{UT}\\sigma_U^2 + \\gamma_R \\sigma_{\\varepsilon_R}^2]}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2} = \\frac{\\alpha_{LR}\\gamma_R(\\alpha_{UR}^2\\sigma_U^2 + \\sigma_{\\varepsilon_R}^2) + \\alpha_{LR}\\alpha_{UR}\\alpha_{UT}\\sigma_U^2}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2} = \\alpha_{LR}\\gamma_R + \\frac{\\alpha_{LR}\\alpha_{UR}\\alpha_{UT}\\sigma_U^2}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2}$\n    \n    将此代回 $\\beta_L$ 的表达式中：\n    $\\beta_L = (\\gamma_L + \\gamma_R \\alpha_{LR}) - \\left( \\alpha_{LR}\\gamma_R + \\frac{\\alpha_{LR}\\alpha_{UR}\\alpha_{UT}\\sigma_U^2}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2} \\right)$\n    $\\beta_L = \\gamma_L - \\frac{\\alpha_{LR}\\alpha_{UR}\\alpha_{UT}\\sigma_U^2}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2}$\n\n4.  **推导偏倚 B:**\n    渐近偏倚是 $B = \\beta_L - \\gamma_L$。\n    $B = \\left( \\gamma_L - \\frac{\\alpha_{LR}\\alpha_{UR}\\alpha_{UT}\\sigma_U^2}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2} \\right) - \\gamma_L = - \\frac{\\alpha_{LR}\\alpha_{UR}\\alpha_{UT}\\sigma_U^2}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2}$。\n\n从定性上讲，偏倚的产生是由于因果模型的结构。变量 $R_j$ 是一个“对撞因子”，因为它是 $L_i$（我们感兴趣的变量）和 $U_j$（未观察到的混杂因素）的共同结果。根据假设，$L_i$ 和 $U_j$ 是独立的。然而，以它们的共同结果 $R_j$ 为条件（这正是多元回归分析所做的），会在 $L_i$ 和 $U_j$ 之间引入统计关联。这就打开了一条从 $L_i$ 到 $T_j$ 的虚假的、非因果的“后门”路径，即 $L_i \\leftarrow \\text{条件化} \\rightarrow U_j \\rightarrow T_j$。$L_i$ 的系数的 OLS 估计量 $\\beta_L$ 除了包含真实的直接效应 $\\gamma_L$ 外，还错误地包含了这条虚假路径，从而导致了偏倚。只有当构成这条诱导路径的所有环节都存在时，偏倚项才非零：$L_i$ 必须影响 $R_j$（$\\alpha_{LR}\\neq0$），$U_j$ 必须影响 $R_j$（$\\alpha_{UR}\\neq0$），并且 $U_j$ 必须影响 $T_j$（$\\alpha_{UT}\\neq0$）。", "answer": "$$\n\\boxed{- \\frac{\\alpha_{LR}\\alpha_{UR}\\alpha_{UT}\\sigma_U^2}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2}}\n$$", "id": "4355888"}]}