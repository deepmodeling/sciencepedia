{"hands_on_practices": [{"introduction": "理论框架的价值在于其与可测量现象的联系。本练习将作为一个基础实践，展示如何将宏观层面可观测的生物学数据——例如细胞在两种表型之间转换所需的平均时间——与势景和流框架中的核心理论概念直接关联起来，例如势阱的深度。通过这个练习，你可以掌握如何从平均首通时间（Mean First Passage Time, MFPT）这类动态数据中推导出系统的稳态概率和表型间的势垒高度，从而将抽象的理论与具体的实验测量联系起来。[@problem_id:4376534]", "problem": "在细胞命运的势景观和流框架中，考虑一个高维随机基因调控系统，该系统具有两个分别对应于表型状态 $A$ 和 $B$ 的、分离良好的亚稳态盆地。将动力学粗粒化为一个具有两个状态 $A$ 和 $B$ 以及恒定转移速率 $k_{A \\to B}$ 和 $k_{B \\to A}$ 的连续时间马尔可夫跳跃过程。对完整随机动力学的长时间直接模拟得到以下平均首达时间（平均首达时间(MFPT)定义为从给定初始集合出发，首次到达指定目标集合的期望时间）：从盆地 $A$ 开始，到达盆地 $B$ 的 MFPT 为 $\\tau_{A \\to B} = 20~\\mathrm{h}$；从盆地 $B$ 开始，到达盆地 $A$ 的 MFPT 为 $\\tau_{B \\to A} = 5~\\mathrm{h}$。\n\n在以下基本定义和事实的框架内进行分析：\n- 粗粒化的两状态过程被假定为一个具有恒定转移速率的时间均匀连续时间马尔可夫链。\n- 稳态分布 $\\{p_A^{\\mathrm{ss}}, p_B^{\\mathrm{ss}}\\}$ 在稳态下与归一化条件一起求解主方程得到。\n- 粗粒化势景观定义为 $U_i = -\\ln p_i^{\\mathrm{ss}}$（在玻尔兹曼常数乘以温度等于1的单位制下），最多相差一个相加常数。\n- 在边 $A \\rightleftarrows B$ 上的粗粒化稳态概率流为 $J_{A B}^{\\mathrm{ss}} = p_A^{\\mathrm{ss}} k_{A \\to B} - p_B^{\\mathrm{ss}} k_{B \\to A}$。\n\n仅使用这些基础和给定的 MFPTs：\n1. 从 MFPT 推导出速率 $k_{A \\to B}$ 和 $k_{B \\to A}$。\n2. 从速率推导出稳态概率 $p_A^{\\mathrm{ss}}$ 和 $p_B^{\\mathrm{ss}}$。\n3. 将粗粒化势差 $\\Delta U \\equiv U_B - U_A$ 完全用 MFPT 表示，并精确计算其值。\n4. 从第一性原理出发，简要论证粗粒化稳态流 $J_{A B}^{\\mathrm{ss}}$ 的值，并解释这如何与底层非平衡稳态下存在的非零连续空间概率流场 $\\mathbf{J}(\\mathbf{x})$ 相关联。\n\n以自然对数形式给出 $\\Delta U$ 的精确表达式作为你的最终答案。最终答案中不要包含单位。", "solution": "首先验证问题，以确保其科学基础扎实、内容自洽且提法恰当。\n\n**第1步：提取已知条件**\n- 该系统是一个具有两个亚稳态 $A$ 和 $B$ 的高维随机基因调控系统。\n- 动力学被粗粒化为状态 $A$ 和 $B$ 之间的连续时间马尔可夫跳跃过程。\n- 转移速率是恒定的，表示为 $k_{A \\to B}$ 和 $k_{B \\to A}$。\n- 从盆地 $A$ 到盆地 $B$ 的平均首达时间 (MFPT) 为 $\\tau_{A \\to B} = 20~\\mathrm{h}$。\n- 从盆地 $B$ 到盆地 $A$ 的 MFPT 为 $\\tau_{B \\to A} = 5~\\mathrm{h}$。\n- 稳态分布为 $\\{p_A^{\\mathrm{ss}}, p_B^{\\mathrm{ss}}\\}$。\n- 粗粒化势定义为 $U_i = -\\ln p_i^{\\mathrm{ss}}$，单位制中玻尔兹曼常数乘以温度等于1。\n- 粗粒化稳态概率流为 $J_{A B}^{\\mathrm{ss}} = p_A^{\\mathrm{ss}} k_{A \\to B} - p_B^{\\mathrm{ss}} k_{B \\to A}$。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学基础（关键）：** 该问题牢固地植根于分析随机生物系统的既定统计物理框架，特别是 Jin Wang 及其合作者发展的势与流景观理论。粗粒化、连续时间马尔可夫链、平均首达时间以及势和流的定义都是该领域的标准概念。该问题在科学上是合理的。\n- **提法恰当：** 问题提供了两个数据点（两个 MFPT）来确定两个未知数（两个转移速率）。由此，所有其他量都可以被唯一地推导出来。问题是自洽的，并为得到唯一解提供了充分的信息。\n- **客观性（关键）：** 语言精确且定量，没有主观或模糊的术语。\n\n**第3步：结论与行动**\n- **结论：** 问题有效。\n- **行动：** 进行完整解答。\n\n**解答推导**\n\n该问题需要一个分为四个部分的解答，将按顺序进行处理。\n\n**1. 从 MFPT 推导出速率 $k_{A \\to B}$ 和 $k_{B \\to A}$。**\n\n对于一个两状态连续时间马尔可夫过程，系统在任一给定状态停留的时间服从指数分布，然后发生转移。如果系统处于状态 $A$，唯一可能的转移是到状态 $B$。这个转移的速率是 $k_{A \\to B}$。因此，在状态 $A$ 的等待时间是一个速率参数为 $k_{A \\to B}$ 的指数随机变量。该指数分布的均值是速率的倒数。\n\n从状态 $A$ 到状态 $B$ 的平均首达时间 (MFPT)，记作 $\\tau_{A \\to B}$，定义为从状态 $A$ 开始首次到达状态 $B$ 的期望时间。在这个简单的两状态模型中，这恰好是在发生向 $B$ 的跳跃之前在状态 $A$ 中的平均等待时间。因此，MFPT 是从起始状态转移出去的速率的倒数。\n\n数学上，我们有：\n$$ \\tau_{A \\to B} = \\frac{1}{k_{A \\to B}} $$\n对于从 $B$ 到 $A$ 的转移，类似地有：\n$$ \\tau_{B \\to A} = \\frac{1}{k_{B \\to A}} $$\n使用给定的值 $\\tau_{A \\to B} = 20~\\mathrm{h}$ 和 $\\tau_{B \\to A} = 5~\\mathrm{h}$，我们可以计算出速率：\n$$ k_{A \\to B} = \\frac{1}{\\tau_{A \\to B}} = \\frac{1}{20}~\\mathrm{h}^{-1} $$\n$$ k_{B \\to A} = \\frac{1}{\\tau_{B \\to A}} = \\frac{1}{5}~\\mathrm{h}^{-1} $$\n\n**2. 从速率推导出稳态概率 $p_A^{\\mathrm{ss}}$ 和 $p_B^{\\mathrm{ss}}$。**\n\n稳态分布 $\\{p_A^{\\mathrm{ss}}, p_B^{\\mathrm{ss}}\\}$ 是通过求解稳态下的主方程得到的，此时概率的时间导数为零。状态 $A$ 的主方程为：\n$$ \\frac{dp_A}{dt} = -k_{A \\to B} p_A + k_{B \\to A} p_B $$\n在稳态下，$\\frac{dp_A}{dt} = 0$，这意味着：\n$$ p_A^{\\mathrm{ss}} k_{A \\to B} = p_B^{\\mathrm{ss}} k_{B \\to A} $$\n这就是细致平衡条件，表明在稳态下，从 $A$ 到 $B$ 的总概率流等于从 $B$ 到 $A$ 的总概率流。\n\n我们还有归一化条件：\n$$ p_A^{\\mathrm{ss}} + p_B^{\\mathrm{ss}} = 1 $$\n从细致平衡方程中，我们将 $p_B^{\\mathrm{ss}}$ 用 $p_A^{\\mathrm{ss}}$ 表示：\n$$ p_B^{\\mathrm{ss}} = p_A^{\\mathrm{ss}} \\frac{k_{A \\to B}}{k_{B \\to A}} $$\n将此代入归一化条件：\n$$ p_A^{\\mathrm{ss}} + p_A^{\\mathrm{ss}} \\frac{k_{A \\to B}}{k_{B \\to A}} = 1 $$\n$$ p_A^{\\mathrm{ss}} \\left( 1 + \\frac{k_{A \\to B}}{k_{B \\to A}} \\right) = 1 $$\n解出 $p_A^{\\mathrm{ss}}$：\n$$ p_A^{\\mathrm{ss}} = \\frac{1}{1 + \\frac{k_{A \\to B}}{k_{B \\to A}}} = \\frac{k_{B \\to A}}{k_{B \\to A} + k_{A \\to B}} $$\n对于 $p_B^{\\mathrm{ss}}$：\n$$ p_B^{\\mathrm{ss}} = 1 - p_A^{\\mathrm{ss}} = \\frac{k_{A \\to B}}{k_{B \\to A} + k_{A \\to B}} $$\n代入速率的数值 ($k_{A \\to B} = 1/20$ 和 $k_{B \\to A} = 1/5$)：\n$$ p_A^{\\mathrm{ss}} = \\frac{1/5}{1/5 + 1/20} = \\frac{1/5}{(4+1)/20} = \\frac{1}{5} \\cdot \\frac{20}{5} = \\frac{4}{5} $$\n$$ p_B^{\\mathrm{ss}} = \\frac{1/20}{1/5 + 1/20} = \\frac{1/20}{(4+1)/20} = \\frac{1}{20} \\cdot \\frac{20}{5} = \\frac{1}{5} $$\n\n**3. 将粗粒化势差 $\\Delta U \\equiv U_B - U_A$ 完全用 MFPT 表示，并计算其值。**\n\n势的定义为 $U_i = -\\ln p_i^{\\mathrm{ss}}$。因此，势差为：\n$$ \\Delta U = U_B - U_A = (-\\ln p_B^{\\mathrm{ss}}) - (-\\ln p_A^{\\mathrm{ss}}) = \\ln p_A^{\\mathrm{ss}} - \\ln p_B^{\\mathrm{ss}} = \\ln\\left(\\frac{p_A^{\\mathrm{ss}}}{p_B^{\\mathrm{ss}}}\\right) $$\n使用从速率推导出的 $p_A^{\\mathrm{ss}}$ 和 $p_B^{\\mathrm{ss}}$ 的表达式：\n$$ \\frac{p_A^{\\mathrm{ss}}}{p_B^{\\mathrm{ss}}} = \\frac{k_{B \\to A} / (k_{B \\to A} + k_{A \\to B})}{k_{A \\to B} / (k_{B \\to A} + k_{A \\to B})} = \\frac{k_{B \\to A}}{k_{A \\to B}} $$\n这个比率也可以直接从细致平衡条件 $p_A^{\\mathrm{ss}} k_{A \\to B} = p_B^{\\mathrm{ss}} k_{B \\to A}$ 得到。\n将此代入 $\\Delta U$ 的表达式：\n$$ \\Delta U = \\ln\\left(\\frac{k_{B \\to A}}{k_{A \\to B}}\\right) $$\n现在，我们使用 $k_{A \\to B} = 1/\\tau_{A \\to B}$ 和 $k_{B \\to A} = 1/\\tau_{B \\to A}$ 将其用 MFPT 表示：\n$$ \\Delta U = \\ln\\left(\\frac{1/\\tau_{B \\to A}}{1/\\tau_{A \\to B}}\\right) = \\ln\\left(\\frac{\\tau_{A \\to B}}{\\tau_{B \\to A}}\\right) $$\n该表达式纯粹用可测量的 MFPT 表示了势差。用给定数据计算此值：\n$$ \\Delta U = \\ln\\left(\\frac{20}{5}\\right) = \\ln(4) $$\n\n**4. 论证粗粒化稳态流 $J_{A B}^{\\mathrm{ss}}$ 的值，并解释其与底层连续空间概率流场 $\\mathbf{J}(\\mathbf{x})$ 的联系。**\n\n粗粒化稳态流定义为 $J_{A B}^{\\mathrm{ss}} = p_A^{\\mathrm{ss}} k_{A \\to B} - p_B^{\\mathrm{ss}} k_{B \\to A}$。如第2部分所述，该系统达到稳态的条件是细致平衡条件 $p_A^{\\mathrm{ss}} k_{A \\to B} = p_B^{\\mathrm{ss}} k_{B \\to A}$。将此直接代入流的定义，表明净流为零：\n$$ J_{A B}^{\\mathrm{ss}} = p_A^{\\mathrm{ss}} k_{A \\to B} - p_A^{\\mathrm{ss}} k_{A \\to B} = 0 $$\n粗粒化流 $J_{A B}^{\\mathrm{ss}}$ 代表了整个盆地 $A$ 和整个盆地 $B$ 之间的概率质量净转移率。值为 $0$ 意味着从这个宏观视角来看，系统处于平衡状态。从 $A$ 到 $B$ 的流出被从 $B$ 到 $A$ 的流入完美平衡。\n\n然而，底层的多维系统通常是一个非平衡稳态（NESS）。在连续状态空间 $\\mathbf{x}$（例如蛋白质浓度）中，一个 NESS 由一个不随时间变化的概率密度 $P_{\\mathrm{ss}}(\\mathbf{x})$ 和一个非零的、无散度的概率流场 $\\mathbf{J}_{\\mathrm{ss}}(\\mathbf{x})$（即 $\\nabla \\cdot \\mathbf{J}_{\\mathrm{ss}} = 0$，但 $\\mathbf{J}_{\\mathrm{ss}}(\\mathbf{x}) \\neq \\mathbf{0}$）来描述。这种非零流是系统在能量消耗过程（如ATP水解）的驱动下偏离热力学平衡的标志。这种流通常表现为状态空间中的持续循环流。\n\n粗粒化过程对这些微观细节进行了平均。离散状态 $A$ 和 $B$ 对应于连续状态空间中的大片区域（盆地）。虽然微观流 $\\mathbf{J}_{\\mathrm{ss}}(\\mathbf{x})$ 可以在任何地方都非零，在盆地内部和之间形成旋转流，但为了使每个盆地中的总概率（$p_A^{\\mathrm{ss}}$ 和 $p_B^{\\mathrm{ss}}$）随时间保持恒定，整个盆地 $A$ 和整个盆地 $B$ 之间的概率*净*交换必须为零。因此，粗粒化流的值为零（$J_{A B}^{\\mathrm{ss}} = 0$）是粗粒化描述达到稳态的必要条件，并且它与在底层微观水平上存在一个非零的非平衡流场 $\\mathbf{J}_{\\mathrm{ss}}(\\mathbf{x})$ 完全兼容。粗粒化有效地积分掉了非平衡环流，从而得到一个满足细致平衡的描述。", "answer": "$$\n\\boxed{\\ln(4)}\n$$", "id": "4376534"}, {"introduction": "在理解了基本概念之后，下一个挑战是如何为更真实的生物系统构建势景和流的完整图像。本练习将引导你进入一个更复杂的场景：一个经典的基因调控“拨动开关”模型。你将学习如何通过有限体积法等数值方法求解 Fokker-Planck 方程，从而计算出给定基因调控网络的完整稳态概率分布（即势景）以及驱动系统远离平衡态的概率流场。掌握这项计算技能对于可视化和量化细胞命运的决策过程至关重要。[@problem_id:4376575]", "problem": "考虑一个二维随机基因调控网络，它代表一个相互抑制的触发开关。状态向量 $(x,y)$ 的宏观确定性漂移由以下常微分方程（ODE）给出\n$$\n\\frac{dx}{dt} = f_x(x,y),\\quad \\frac{dy}{dt} = f_y(x,y),\n$$\n其中右侧项代表产生、衰减和具有 Hill 型非线性的交叉抑制。在内在噪声下的介观描述中，概率密度 $P(x,y,t)$ 的时间演化由 Fokker–Planck 方程（FPE）控制，该方程也称为 Kolmogorov 前向方程，\n$$\n\\frac{\\partial P(x,y,t)}{\\partial t} = -\\nabla \\cdot \\mathbf{J}(x,y,t),\n$$\n其中概率流 $\\mathbf{J}$ 由下式给出\n$$\n\\mathbf{J}(x,y,t) = \\mathbf{f}(x,y)\\,P(x,y,t) - \\mathbf{D}\\,\\nabla P(x,y,t),\n$$\n其中漂移 $\\mathbf{f}(x,y) = (f_x(x,y), f_y(x,y))$，扩散矩阵 $\\mathbf{D} = \\mathrm{diag}(D_x, D_y)$ 是一个常对角矩阵。在稳态下，稳态分布 $P_{\\text{ss}}(x,y)$ 及其相关的流 $\\mathbf{J}_{\\text{ss}}(x,y)$ 满足无散度条件\n$$\n\\nabla \\cdot \\mathbf{J}_{\\text{ss}}(x,y) = 0.\n$$\n该守恒定律编码了势景（来自概率分布）和非平衡流（来自环形概率流）。\n\n从上述概率的一般守恒定律和流的定义出发，您将使用有限体积法在均匀矩形网格上离散化稳态 Fokker–Planck 方程。离散化必须：\n- 在矩形域 $[0,L]\\times[0,L]$ 上的 $N_x \\times N_y$ 网格上，对 $P_{\\text{ss}}$ 使用单元中心未知数，其中均匀间距为 $\\Delta x = L/N_x$ 和 $\\Delta y = L/N_y$，单元中心位于 $(x_i,y_j) = ((i+\\tfrac{1}{2})\\Delta x,(j+\\tfrac{1}{2})\\Delta y)$，对于 $i=0,\\ldots,N_x-1$，$j=0,\\ldots,N_y-1$。\n- 对每个单元的面通量进行计算，对流部分 $\\mathbf{f}(x,y)\\,P$ 使用迎风格式处理，扩散部分 $-\\mathbf{D}\\,\\nabla P$ 使用中心差分。\n- 在域边界上强制执行零法向通量边界条件（无通量）。\n- 对每个单元强制执行稳态约束 $\\nabla\\cdot\\mathbf{J}_{\\text{ss}}=0$，并施加归一化约束 $\\int P_{\\text{ss}}(x,y)\\,dx\\,dy = 1$ 以封闭线性系统。\n\n对于触发开关网络，使用以下具有 Hill 型抑制的无量纲漂移函数：\n$$\nf_x(x,y) = \\frac{\\alpha}{1 + \\left(\\frac{y}{K}\\right)^n} - x + h,\\qquad\nf_y(x,y) = \\frac{\\alpha}{1 + \\left(\\frac{x}{K}\\right)^m} - y + s,\n$$\n其中 $\\alpha0$ 是最大生产率， $K0$ 是抑制阈值（设 $K=1$），$n,m\\ge 2$ 是 Hill 系数。参数 $h$ 和 $s$ 引入偏置项。\n\n此问题中的所有量都是无量纲的；不需要物理单位。不出现角度；不需要角度单位。最终的数值输出必须是实值标量。\n\n您的程序必须：\n1. 使用上述有限体积法组装并求解离散稳态 FPE，得到 $P_{\\text{ss}}$。\n2. 计算单元中心通量场 $\\mathbf{J}_{\\text{ss}}(x_i,y_j) = \\left(J_x(i,j), J_y(i,j)\\right)$，其中对 $\\nabla P_{\\text{ss}}$ 使用中心差分，漂移在单元中心处评估。\n3. 通过中心差分计算单元中心的离散散度残差，\n$$\nR(i,j) = \\frac{J_x(i+1,j) - J_x(i-1,j)}{2\\Delta x} + \\frac{J_y(i,j+1) - J_y(i,j-1)}{2\\Delta y},\n$$\n在边界处使用适当的单边差分，并报告所有单元上 $R$ 的平均绝对值，作为衡量 $\\nabla\\cdot\\mathbf{J}_{\\text{ss}}=0$ 满足程度的指标。\n\n为以下参数集测试套件实施上述操作，以确保覆盖不同的区域：\n- 测试用例 1（双稳态，对称，低噪声；“理想路径”）：$L=4$, $N_x=N_y=40$, $\\alpha=3.0$, $K=1.0$, $n=4$, $m=4$, $h=0.0$, $s=0.0$, $D_x=D_y=0.03$。报告：\n  - 归一化误差 $E_1 = \\left|1 - \\sum_{i,j} P_{\\text{ss}}(i,j)\\,\\Delta x\\,\\Delta y\\right|$。\n  - 平均绝对散度残差 $M_1 = \\frac{1}{N_x N_y}\\sum_{i,j} |R(i,j)|$。\n  - 双峰平衡度量 $B_1$，定义为高 x/低 y 盆地和低 x/高 y 盆地中两个概率质量中较小的一个，其中盆地分别是矩形区域 $\\{x2.5,\\,y0.5\\}$ 和 $\\{x0.5,\\,y2.5\\}$。每个质量是该区域内 $P_{\\text{ss}}$ 的总和乘以 $\\Delta x\\,\\Delta y$。\n- 测试用例 2（单稳态区域，中等噪声）：$L=4$, $N_x=N_y=40$, $\\alpha=1.0$, $K=1.0$, $n=4$, $m=4$, $h=0.0$, $s=0.0$, $D_x=D_y=0.05$。报告：\n  - 归一化误差 $E_2$。\n  - 平均绝对散度残差 $M_2$。\n  - $P_{\\text{ss}}$ 全局最大值位置到点 $(1,1)$ 的距离 $R_{\\max,2}$，计算公式为 $\\sqrt{(x_{\\max}-1)^2 + (y_{\\max}-1)^2}$。\n- 测试用例 3（有偏双稳态）：$L=4$, $N_x=N_y=40$, $\\alpha=3.0$, $K=1.0$, $n=4$, $m=4$, $h=+0.3$, $s=-0.3$, $D_x=D_y=0.03$。报告：\n  - 归一化误差 $E_3$。\n  - 平均绝对散度残差 $M_3$。\n  - 质量不对称性 $\\Delta_3 = M_{x\\text{-high}} - M_{y\\text{-high}}$，其中 $M_{x\\text{-high}}$ 是 $\\{x2.5,\\,y0.5\\}$ 中的概率质量，$M_{y\\text{-high}}$ 是 $\\{x0.5,\\,y2.5\\}$ 中的质量。\n- 测试用例 4（较粗网格上的边界条件敏感性）：$L=4$, $N_x=N_y=20$, $\\alpha=3.0$, $K=1.0$, $n=4$, $m=4$, $h=0.0$, $s=0.0$, $D_x=D_y=0.03$。报告：\n  - 归一化误差 $E_4$。\n  - 平均绝对散度残差 $M_4$。\n  - 平均绝对边界法向通量 $F_4$，定义为沿左右边界单元中心处的 $|J_x|$ 和沿上下边界单元中心处的 $|J_y|$ 的平均值。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序如下：\n$$\n[E_1,\\,M_1,\\,B_1,\\,E_2,\\,M_2,\\,R_{\\max,2},\\,E_3,\\,M_3,\\,\\Delta_3,\\,E_4,\\,M_4,\\,F_4].\n$$\n所有十二个输出都必须是十进制数（浮点值）。不应打印其他任何文本。", "solution": "该问题要求对基因调控触发开关模型的二维稳态 Fokker-Planck 方程进行数值求解。解将通过在均匀网格上使用有限体积法获得，然后计算几个指定的度量。\n\n稳态下的控制方程是关于概率流的无散度条件，$\\nabla \\cdot \\mathbf{J}_{\\text{ss}} = 0$。通量 $\\mathbf{J}_{\\text{ss}}$ 由一个对流（或漂移）部分和一个扩散部分组成：\n$$\n\\mathbf{J}_{\\text{ss}}(x,y) = \\mathbf{f}(x,y)P_{\\text{ss}}(x,y) - \\mathbf{D} \\nabla P_{\\text{ss}}(x,y)\n$$\n其中 $P_{\\text{ss}}(x,y)$ 是稳态概率分布，$\\mathbf{f}(x,y) = (f_x(x,y), f_y(x,y))$ 是确定性漂移向量，$\\mathbf{D} = \\mathrm{diag}(D_x, D_y)$ 是常对角扩散矩阵。\n\n**有限体积离散化**\n\n该方法的核心是在计算网格的每个单元上以积分形式强制执行守恒定律 $\\nabla \\cdot \\mathbf{J}_{\\text{ss}} = 0$。域 $[0,L] \\times [0,L]$ 被离散化为 $N_x \\times N_y$ 的单元网格。每个单元 $\\Omega_{i,j}$ 是一个以 $(x_i, y_j) = ((i+\\frac{1}{2})\\Delta x, (j+\\frac{1}{2})\\Delta y)$ 为中心的小矩形，尺寸为 $\\Delta x \\times \\Delta y$，其中 $\\Delta x = L/N_x$，$\\Delta y = L/N_y$。\n\n我们在 $\\Omega_{i,j}$ 上对控制方程进行积分，并应用散度定理：\n$$\n\\int_{\\Omega_{i,j}} \\nabla \\cdot \\mathbf{J}_{\\text{ss}} \\,dA = \\oint_{\\partial\\Omega_{i,j}} \\mathbf{J}_{\\text{ss}} \\cdot \\mathbf{n} \\,ds = 0\n$$\n其中 $\\mathbf{n}$ 是指向单元边界 $\\partial\\Omega_{i,j}$ 外侧的法向量。这种积分形式表明，流出单元的总概率通量为零。对于矩形单元，这变为：\n$$\n\\left( J_{x, i+1/2, j} - J_{x, i-1/2, j} \\right) \\Delta y + \\left( J_{y, i, j+1/2} - J_{y, i, j-1/2} \\right) \\Delta x = 0\n$$\n这里，$J_{x, i+1/2, j}$ 表示在单元右侧面中心（位于 $x=(i+1)\\Delta x$）计算的通量的 x 分量，其他三个面（左、上、下）也类似。\n\n**数值通量近似**\n\n为了继续，我们必须用单元中心的概率值 $P_{i,j} \\equiv P_{\\text{ss}}(x_i, y_j)$ 来近似面通量。通量包含两个部分。\n\n1.  **扩散通量**：扩散部分 $-D_x\\frac{\\partial P}{\\partial x}$ 使用二阶中心差分进行近似。在右侧面 $(i+1/2, j)$，这表示为：\n    $$\n    -D_x \\frac{\\partial P}{\\partial x}\\bigg|_{i+1/2, j} \\approx -D_x \\frac{P_{i+1,j} - P_{i,j}}{\\Delta x}\n    $$\n\n2.  **对流通量**：对流部分 $f_x P$ 需要使用迎风格式以保证稳定性，如题所指定。面上的 $P$ 值取自“迎风”单元，即流动的来源单元。设 $f_{x, i+1/2, j} \\equiv f_x(x_{i+1/2}, y_j)$。\n    - 如果 $f_{x, i+1/2, j} > 0$（流动从左到右），我们使用 $P_{i,j}$。\n    - 如果 $f_{x, i+1/2, j}  0$（流动从右到左），我们使用 $P_{i+1,j}$。\n    这可以紧凑地表示为 $f_{x, i+1/2, j}^+ P_{i,j} + f_{x, i+1/2, j}^- P_{i+1,j}$，其中 $f^+ = \\max(f,0)$，$f^- = \\min(f,0)$。\n\n结合这两个部分，通过单元 $(i,j)$ 右侧面的总通量是：\n$$\nJ_{x, i+1/2, j} \\approx \\left( f_{x, i+1/2, j}^+ P_{i,j} + f_{x, i+1/2, j}^- P_{i+1,j} \\right) - D_x \\frac{P_{i+1,j} - P_{i,j}}{\\Delta x}\n$$\n其他三个面（$J_{x, i-1/2, j}$, $J_{y, i, j+1/2}$, $J_{y, i, j-1/2}$）的表达式可以类似地推导出来。\n\n**线性系统的组装**\n\n将这些通量近似值代入每个单元 $(i,j)$ 的通量平衡方程，会得到一个线性代数方程，该方程将 $P_{i,j}$ 与其四个邻居 $P_{i \\pm 1, j}$ 和 $P_{i, j \\pm 1}$ 联系起来。这会产生一个形如 $\\mathbf{A}\\mathbf{p} = \\mathbf{0}$ 的大型稀疏线性方程组，其中 $\\mathbf{p}$ 是一个包含所有未知单元概率 $P_{i,j}$ 的向量（被展平为一个大小为 $N_x N_y$ 的一维数组）。矩阵 $\\mathbf{A}$ 具有五对角结构。\n\n通过在域边界处将法向通量设置为零来引入无通量边界条件。例如，对于左边界上的单元 $(0,j)$，通过其左侧面的通量为零，$J_{x, -1/2, j} = 0$。这会修改边界单元的通量平衡方程。\n\n**封闭系统**\n\n齐次系统 $\\mathbf{A}\\mathbf{p} = \\mathbf{0}$ 有一个非平凡解（因为每行系数之和为零），但此解仅在相差一个乘法常数的意义下是确定的。为了获得唯一的、具有物理意义的概率分布，我们必须施加归一化约束：\n$$\n\\int_0^L \\int_0^L P_{\\text{ss}}(x,y) \\,dx\\,dy = 1\n$$\n其离散形式为 $\\sum_{i,j} P_{i,j} \\Delta x \\Delta y = 1$。该方程用于替换系统中的一个（冗余的）通量平衡方程。通常，最后一个单元的方程被替换。这将系统转换为一个非齐次系统 $\\mathbf{A'}\\mathbf{p} = \\mathbf{b}$，其中 $\\mathbf{A'}$ 的最后一行包含系数 $\\Delta x \\Delta y$，而 $\\mathbf{b}$ 的最后一个元素是 1。该系统有唯一解，可以使用稀疏线性求解器找到。\n\n**后处理与度量计算**\n\n求解向量 $\\mathbf{p}$ 并将其重塑为二维数组 $P_{i,j}$ 后，计算指定的度量：\n1.  **归一化误差 ($E$)**：计算为 $\\left|1 - \\sum_{i,j} P_{i,j}\\Delta x \\Delta y\\right|$，以验证线性求解的准确性。\n2.  **单元中心通量和散度残差 ($M$)**：使用已解出的 $P_{i,j}$ 计算单元中心的通量场 $\\mathbf{J}_{\\text{ss}}(x_i, y_j)$。漂移 $\\mathbf{f}$ 在单元中心进行评估，梯度 $\\nabla P_{\\text{ss}}$ 使用中心差分（在边界处使用单边差分）进行近似。然后计算该通量场的散度 $R(i,j) = (\\nabla \\cdot \\mathbf{J}_{\\text{ss}})_{i,j}$，同样使用中心/单边差分。网格上 $R(i,j)$ 的平均绝对值 $M$ 量化了数值解满足原始无散度条件的程度。\n3.  **盆地度量 ($B_1$, $\\Delta_3$)**：通过对所有中心落入指定矩形区域（盆地）的单元求和 $P_{i,j} \\Delta x \\Delta y$ 来计算这些区域的概率质量。这些质量用于计算双峰平衡度 $B_1$ 和不对称性 $\\Delta_3$。\n4.  **峰值位置 ($R_{\\max,2}$)**：找到 $P_{i,j}$ 最大值的网格索引，将其转换为空间坐标 $(x_{\\max}, y_{\\max})$，并用于计算到参考点的距离。\n5.  **边流通量 ($F_4$)**：平均绝对法向通量是通过对所有边界单元上预先计算的单元中心法向通量分量（垂直边界上的 $|J_x|$，水平边界上的 $|J_y|$）的量值进行平均来计算的。\n\n这一综合程序能够对不同参数区域下触发开关系统的稳态行为进行稳健的数值表征。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main orchestrator function that runs all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: Bistable, symmetric, low noise\n        {\n            \"L\": 4.0, \"Nx\": 40, \"Ny\": 40, \"alpha\": 3.0, \"K\": 1.0, \n            \"n\": 4.0, \"m\": 4.0, \"h\": 0.0, \"s\": 0.0, \n            \"Dx\": 0.03, \"Dy\": 0.03, \"case_id\": 1\n        },\n        # Test Case 2: Monostable, moderate noise\n        {\n            \"L\": 4.0, \"Nx\": 40, \"Ny\": 40, \"alpha\": 1.0, \"K\": 1.0, \n            \"n\": 4.0, \"m\": 4.0, \"h\": 0.0, \"s\": 0.0, \n            \"Dx\": 0.05, \"Dy\": 0.05, \"case_id\": 2\n        },\n        # Test Case 3: Biased bistability\n        {\n            \"L\": 4.0, \"Nx\": 40, \"Ny\": 40, \"alpha\": 3.0, \"K\": 1.0, \n            \"n\": 4.0, \"m\": 4.0, \"h\": 0.3, \"s\": -0.3, \n            \"Dx\": 0.03, \"Dy\": 0.03, \"case_id\": 3\n        },\n        # Test Case 4: Coarser grid sensitivity\n        {\n            \"L\": 4.0, \"Nx\": 20, \"Ny\": 20, \"alpha\": 3.0, \"K\": 1.0, \n            \"n\": 4.0, \"m\": 4.0, \"h\": 0.0, \"s\": 0.0, \n            \"Dx\": 0.03, \"Dy\": 0.03, \"case_id\": 4\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        results = run_case(**params)\n        all_results.extend(results)\n\n    # Format the final output string as specified.\n    print(f\"[{','.join(f'{r:.8e}' for r in all_results)}]\")\n\ndef run_case(L, Nx, Ny, alpha, K, n, m, h, s, Dx, Dy, case_id):\n    \"\"\"\n    Solves the FPE for a single set of parameters and computes the required metrics.\n    \"\"\"\n    dx = L / Nx\n    dy = L / Ny\n    \n    # Cell center coordinates\n    x_centers = (np.arange(Nx) + 0.5) * dx\n    y_centers = (np.arange(Ny) + 0.5) * dy\n    \n    # Face coordinates\n    x_faces = np.arange(Nx + 1) * dx\n    y_faces = np.arange(Ny + 1) * dy\n\n    # Drift functions\n    def fx(x, y):\n        return alpha / (1 + (y / K)**n) - x + h\n    def fy(x, y):\n        return alpha / (1 + (x / K)**m) - y + s\n\n    N_vars = Nx * Ny\n    A = lil_matrix((N_vars, N_vars))\n    \n    # Assemble the matrix A\n    for j in range(Ny):\n        for i in range(Nx):\n            k = i + j * Nx # Flattened index\n            \n            # Coefficients for neighbors\n            # East face (i+1/2)\n            if i  Nx - 1:\n                f_val = fx(x_faces[i + 1], y_centers[j])\n                f_pos = max(f_val, 0)\n                f_neg = min(f_val, 0)\n                A[k, k] += (f_pos + Dx / dx) * dy\n                A[k, k + 1] += (f_neg - Dx / dx) * dy\n\n            # West face (i-1/2)\n            if i > 0:\n                f_val = fx(x_faces[i], y_centers[j])\n                f_pos = max(f_val, 0)\n                f_neg = min(f_val, 0)\n                A[k, k] -= (f_neg - Dx / dx) * dy\n                A[k, k - 1] -= (f_pos + Dx / dx) * dy\n\n            # North face (j+1/2)\n            if j  Ny - 1:\n                f_val = fy(x_centers[i], y_faces[j + 1])\n                f_pos = max(f_val, 0)\n                f_neg = min(f_val, 0)\n                A[k, k] += (f_pos + Dy / dy) * dx\n                A[k, k + j * Nx + Nx] += (f_neg - Dy / dy) * dx\n            \n            # South face (j-1/2)\n            if j > 0:\n                f_val = fy(x_centers[i], y_faces[j])\n                f_pos = max(f_val, 0)\n                f_neg = min(f_val, 0)\n                A[k, k] -= (f_neg - Dy / dy) * dx\n                A[k, k - Nx] -= (f_pos + Dy / dy) * dx\n\n    # Create RHS vector and apply normalization constraint\n    b = np.zeros(N_vars)\n    A[-1, :] = dx * dy  # Replace last equation\n    b[-1] = 1.0\n\n    # Solve the linear system\n    A_csr = A.tocsr()\n    p_vec = spsolve(A_csr, b)\n    P_ss = p_vec.reshape((Ny, Nx))\n\n    # --- Post-processing and Metric Calculation ---\n\n    # Metric: Normalization Error (E)\n    norm_error = np.abs(1.0 - np.sum(P_ss) * dx * dy)\n\n    # Metric: Mean Absolute Divergence Residual (M)\n    # 1. Compute cell-centered flux J\n    yy, xx = np.meshgrid(y_centers, x_centers, indexing='ij')\n    fx_c = fx(xx, yy)\n    fy_c = fy(xx, yy)\n\n    grad_P_y, grad_P_x = np.gradient(P_ss, dy, dx)\n\n    Jx = fx_c * P_ss - Dx * grad_P_x\n    Jy = fy_c * P_ss - Dy * grad_P_y\n    \n    # 2. Compute divergence of J\n    grad_Jy_y_center, _ = np.gradient(Jy, dy, dx)\n    _, grad_Jx_x_center = np.gradient(Jx, dy, dx)\n    \n    R = np.zeros_like(P_ss)\n    R[1:-1, 1:-1] = (Jx[1:-1, 2:] - Jx[1:-1, :-2]) / (2*dx) + (Jy[2:, 1:-1] - Jy[:-2, 1:-1]) / (2*dy)\n    # Handle boundaries with one-sided differences if needed, but question specifies center diff and appropriate one-sided at boundaries.\n    # The numpy gradient approach is simpler and handles boundaries automatically.\n    # We will use the central difference result over the interior for accuracy as requested and ignore boundaries as they are small.\n    # The prompt actually gives a formula for R(i,j) that uses central differences everywhere. This implies periodic BCs for calculation\n    # or using 0 padding. For simplicity, we calculate with numpy.gradient which uses 2nd order accurate differences at boundaries.\n    \n    R = grad_Jx_x_center + grad_Jy_y_center\n    mean_abs_div_residual = np.mean(np.abs(R))\n\n    # --- Case-specific Metrics ---\n    if case_id == 1 or case_id == 3:\n        # Basins for bistability metrics\n        basin_x_high_mask = (xx > 2.5)  (yy  0.5)\n        basin_y_high_mask = (xx  0.5)  (yy > 2.5)\n        \n        mass_x_high = np.sum(P_ss[basin_x_high_mask]) * dx * dy\n        mass_y_high = np.sum(P_ss[basin_y_high_mask]) * dx * dy\n\n        if case_id == 1:\n            # Bimodality balance B1\n            bimodality_balance = min(mass_x_high, mass_y_high)\n            return [norm_error, mean_abs_div_residual, bimodality_balance]\n        else: # case_id == 3\n            # Mass asymmetry Delta3\n            mass_asymmetry = mass_x_high - mass_y_high\n            return [norm_error, mean_abs_div_residual, mass_asymmetry]\n\n    elif case_id == 2:\n        # Distance of max probability from (1,1)\n        j_max, i_max = np.unravel_index(np.argmax(P_ss), P_ss.shape)\n        x_max = x_centers[i_max]\n        y_max = y_centers[j_max]\n        R_max_2 = np.sqrt((x_max - 1.0)**2 + (y_max - 1.0)**2)\n        return [norm_error, mean_abs_div_residual, R_max_2]\n\n    elif case_id == 4:\n        # Average absolute boundary normal flux F4\n        flux_left = np.abs(Jx[:, 0])\n        flux_right = np.abs(Jx[:, -1])\n        flux_bottom = np.abs(Jy[0, :])\n        flux_top = np.abs(Jy[-1, :])\n        \n        total_abs_flux = np.sum(flux_left) + np.sum(flux_right) + np.sum(flux_bottom) + np.sum(flux_top)\n        num_boundary_points = 2 * Nx + 2 * Ny\n        avg_abs_boundary_flux = total_abs_flux / num_boundary_points\n        return [norm_error, mean_abs_div_residual, avg_abs_boundary_flux]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "4376575"}, {"introduction": "计算出势景地形图后，一个自然而然的问题是：细胞是如何在不同命运（势阱）之间发生转变的？本练习将介绍一种强大的计算工具——“弦方法”（String Method），用于寻找连接两个稳定细胞命运状态之间的“山谷隘口”，即最小能量路径（Minimum Energy Path）。通过确定这条路径，我们可以定位决定转变速率的关键点（鞍点），并计算出细胞命运转变所需的激活能（势垒高度），这对于理解细胞的可塑性、分化与重编程动力学至关重要。[@problem_id:4376608]", "problem": "考虑一个细胞状态变量向量 $\\mathbf{x}(t) \\in \\mathbb{R}^2$ 的过阻尼随机动力学，该动力学由一个势能景观 $U(\\mathbf{x})$ 在小噪声下支配，建模为伊藤（Itô）随机微分方程\n$$\n\\frac{d\\mathbf{x}}{dt} = -\\nabla U(\\mathbf{x}) + \\sqrt{2\\epsilon}\\,\\boldsymbol{\\xi}(t),\n$$\n其中 $\\epsilon  0$ 是一个小的无量纲噪声强度，$\\boldsymbol{\\xi}(t)$ 是一个标准高斯白噪声过程。在小噪声极限下，稳定细胞命运（$U$的局部最小值）之间的转变主要由沿最小能量（作用量）路径穿过指数为1的鞍点的轨迹所主导。在梯度系统中，最小能量路径简化为以尽可能小的代价爬升景观以到达两个盆地之间鞍点的路径。从位于 $\\mathbf{x}_\\mathrm{min}$ 的一个命运到位于 $\\mathbf{x}_\\mathrm{sad}$ 的鞍点的转变能垒高度定义为能量差\n$$\n\\Delta U = U(\\mathbf{x}_\\mathrm{sad}) - U(\\mathbf{x}_\\mathrm{min}),\n$$\n以无量纲单位表示（无物理单位）。\n\n请为下面的每个势能函数实现一个基于弦方法（或等效地，概念上的微动弹性带方法）的算法，以近似计算两个给定稳定命运之间的最小能量路径。您的算法必须：\n- 通过从给定的初始猜测开始进行局部优化，识别两个局部最小值。\n- 初始化一条连接两个最小值的离散路径（一条“弦”），并通过将内部点沿垂直于局部路径切线的景观梯度向下移动来迭代演化它，然后进行重新参数化以保持近似均匀的弧长间距。在整个演化过程中，端点必须保持固定在已识别的最小值处。\n- 收敛后，将最终路径上势能值最大的点识别为近似鞍点。然后，通过从该点开始最小化函数 $F(\\mathbf{x}) = \\frac{1}{2}\\|\\nabla U(\\mathbf{x})\\|^2$，求解 $U$ 在该最大值附近的驻点，来精确化鞍点位置。使用 $U$ 的Hessian矩阵对精确化后的点进行分类；如果其Hessian矩阵有一个正特征值和一个负特征值（指数-1鞍点），则接受它；否则，使用路径上的最大值点作为鞍点估计。\n- 计算相对于每个最小值的两个能垒高度：$\\Delta U_1 = U(\\mathbf{x}_\\mathrm{sad}) - U(\\mathbf{x}_{\\mathrm{min},1})$ 和 $\\Delta U_2 = U(\\mathbf{x}_\\mathrm{sad}) - U(\\mathbf{x}_{\\mathrm{min},2})$，单位为无量纲。\n\n测试套件的势能函数（均为无量纲）：\n1. $U_1(x,y) = \\frac{1}{4}\\,(x^2 - 1)^2 + \\frac{1}{2}\\,(y + \\frac{1}{2}x)^2$。\n2. $U_2(x,y) = (x^2 - 1)^2 + y^2 + \\frac{1}{2}\\,x y$。\n3. $U_3(x,y) = (x^2 - 1)^2 + y^2$。\n\n对于每个势能函数，使用以下测试参数以确保覆盖一般情况和边界情况：\n- 情况1（弯曲耦合路径）：势能 $U_1$，最小值的初始猜测为 $\\mathbf{x}_{\\mathrm{min},1}^{(0)} = (-1.2,\\,0.6)$ 和 $\\mathbf{x}_{\\mathrm{min},2}^{(0)} = (1.2,\\,-0.6)$，路径节点数 $N = 101$，弦演化的时间步长 $\\Delta t = 0.05$，最大迭代次数 $K = 400$。\n- 情况2（各向异性耦合双势阱）：势能 $U_2$，最小值的初始猜测为 $\\mathbf{x}_{\\mathrm{min},1}^{(0)} = (-1.2,\\,0.3)$ 和 $\\mathbf{x}_{\\mathrm{min},2}^{(0)} = (1.2,\\,-0.3)$，$N = 101$，$\\Delta t = 0.05$，$K = 600$。\n- 情况3（解耦对称双势阱；边界情况）：势能 $U_3$，最小值的初始猜测为 $\\mathbf{x}_{\\mathrm{min},1}^{(0)} = (-1.2,\\,0.0)$ 和 $\\mathbf{x}_{\\mathrm{min},2}^{(0)} = (1.2,\\,0.0)$，$N = 101$，$\\Delta t = 0.05$，$K = 300$。\n\n您的程序必须：\n- 为每个势能函数实现解析梯度 $\\nabla U$。\n- 使用局部优化器从提供的猜测开始识别最小值。\n- 通过将 $-\\nabla U$ 投影到垂直于局部切线的方向并重新参数化以实现均匀弧长，来演化弦。\n- 通过最小化 $F(\\mathbf{x}) = \\frac{1}{2}\\|\\nabla U(\\mathbf{x})\\|^2$ 来精确化鞍点，并通过对 $\\nabla U$ 进行数值微分得到的 $U$ 的Hessian矩阵进行分类。\n- 对于每种情况，返回两个能垒高度 $\\Delta U_1$ 和 $\\Delta U_2$ 以及鞍点坐标 $(x_\\mathrm{sad}, y_\\mathrm{sad})$，所有值均为浮点数，四舍五入到六位小数。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个情况贡献一个形式为 $[\\Delta U_1,\\Delta U_2,x_\\mathrm{sad},y_\\mathrm{sad}]$ 的子列表。例如，输出必须看起来像：\n$$\n[[\\Delta U_1^{(1)},\\Delta U_2^{(1)},x_\\mathrm{sad}^{(1)},y_\\mathrm{sad}^{(1)}],[\\Delta U_1^{(2)},\\Delta U_2^{(2)},x_\\mathrm{sad}^{(2)},y_\\mathrm{sad}^{(2)}],[\\Delta U_1^{(3)},\\Delta U_2^{(3)},x_\\mathrm{sad}^{(3)},y_\\mathrm{sad}^{(3)}]]\n$$\n所有量都是无量纲的（无单位）。不使用角度。不需要百分比。", "solution": "用户提供的问题是有效的，因为它具有科学依据、问题明确且客观。它概述了一项清晰的计算任务，该任务基于统计物理学和计算化学中的既定原理，特别是使用弦方法在势能面上寻找最小能量路径。所有必要的参数、函数和程序步骤都已提供。\n\n问题的核心是实现一个算法，用于近似给定势能函数 $U(\\mathbf{x})$ 的两个局部最小值之间的最小能量路径（MEP）。MEP是理解随机系统中稳定状态（例如细胞命运）之间转变速率的关键概念，如所提供的伊藤随机微分方程所述。在低噪声极限（$\\epsilon \\to 0$）下，最可能的转变路径就是MEP。\n\n解决方案通过遵循问题陈述中详述的步骤序列来实现。\n\n### 步骤1：势能和梯度的定义\n\n对于每个势能函数 $U_k(x, y)$，推导出其解析梯度 $\\nabla U_k = \\left(\\frac{\\partial U_k}{\\partial x}, \\frac{\\partial U_k}{\\partial y}\\right)$，以用于后续的数值程序。\n1.  对于 $U_1(x,y) = \\frac{1}{4}(x^2 - 1)^2 + \\frac{1}{2}(y + \\frac{1}{2}x)^2$，梯度为：\n    $$ \\nabla U_1(x,y) = \\left( x(x^2 - 1) + \\frac{1}{2}\\left(y + \\frac{1}{2}x\\right), y + \\frac{1}{2}x \\right) = \\left( x^3 - \\frac{3}{4}x + \\frac{1}{2}y, \\frac{1}{2}x + y \\right) $$\n2.  对于 $U_2(x,y) = (x^2 - 1)^2 + y^2 + \\frac{1}{2}xy$，梯度为：\n    $$ \\nabla U_2(x,y) = \\left( 2(x^2 - 1)(2x) + \\frac{1}{2}y, 2y + \\frac{1}{2}x \\right) = \\left( 4x^3 - 4x + \\frac{1}{2}y, \\frac{1}{2}x + 2y \\right) $$\n3.  对于 $U_3(x,y) = (x^2 - 1)^2 + y^2$，梯度为：\n    $$ \\nabla U_3(x,y) = \\left( 2(x^2 - 1)(2x), 2y \\right) = \\left( 4x^3 - 4x, 2y \\right) $$\n这些函数被实现为接受一个二维向量 $\\mathbf{x} = (x, y)$ 作为输入。\n\n### 步骤2：定位最小值\n\n通过执行局部优化来找到对应于细胞命运的两个稳定状态（$U$的局部最小值）。从提供的初始猜测 $\\mathbf{x}_{\\mathrm{min},1}^{(0)}$ 和 $\\mathbf{x}_{\\mathrm{min},2}^{(0)}$ 开始，我们使用拟牛顿优化算法（L-BFGS-B），该算法在 `scipy.optimize.minimize` 中实现。当提供目标函数的解析梯度（雅可比矩阵）时，此方法高效且稳健。目标函数是势能 $U(\\mathbf{x})$，其雅可比矩阵是 $\\nabla U(\\mathbf{x})$。\n\n### 步骤3：弦方法实现\n\n最小能量路径由一条“弦”来近似，它是在构型空间中的 $N$ 个点（节点）的离散序列。\n\n**a. 初始化：** 弦被初始化为一条在 $\\mathbb{R}^2$ 中连接前一步找到的两个最小值 $\\mathbf{x}_{\\mathrm{min},1}$ 和 $\\mathbf{x}_{\\mathrm{min},2}$ 的直线。这 $N$ 个节点沿此线段均匀分布。\n\n**b. 弦演化：** 弦经过 $K$ 次迭代演化。在每次迭代中，弦的两个端点保持固定在最小值处。$N-2$ 个内部节点在两个子步骤中更新：\n1.  **垂直动力学：** 每个内部节点 $\\mathbf{x}_i$ 根据势能导出的力 $\\mathbf{F}(\\mathbf{x}_i) = -\\nabla U(\\mathbf{x}_i)$ 中垂直于该点路径的分量移动。在节点 $\\mathbf{x}_i$ 处的局部切向量 $\\boldsymbol{\\tau}_i$ 使用中心差分格式近似：$\\boldsymbol{\\tau}_i \\propto (\\mathbf{x}_{i+1} - \\mathbf{x}_{i-1})$。然后，垂直力为 $\\mathbf{F}_{\\perp,i} = \\mathbf{F}_i - (\\mathbf{F}_i \\cdot \\hat{\\boldsymbol{\\tau}}_i) \\hat{\\boldsymbol{\\tau}}_i$，其中 $\\hat{\\boldsymbol{\\tau}}_i$ 是单位化切向量。节点通过一个欧拉步更新：$\\mathbf{x}_i \\leftarrow \\mathbf{x}_i + \\Delta t \\, \\mathbf{F}_{\\perp,i}$。此步骤将弦在势能面上“下坡”移动，降低其总势能，而投影操作可防止节点沿路径滑动。\n2.  **重新参数化：** 垂直更新会破坏节点的均匀间距。为保持路径的平滑表示，节点沿当前路径重新分布，以确保它们具有相等的弧长间距。这是通过首先计算沿路径的累积弧长，然后使用线性插值（`numpy.interp`）在总弧长的均匀间隔处找到新节点的坐标来实现的。\n\n### 步骤4：鞍点识别和精确化\n\n经过 $K$ 次迭代后，弦提供了MEP的近似。\n\n**a. 初始估计：** 过渡的鞍点是沿MEP势能最高的点。通过在收敛的弦上识别具有最高势能值 $U$ 的节点来找到初始估计 $\\mathbf{x}_{\\mathrm{sad, initial}}$。\n\n**b. 精确化：** 提高鞍点的准确性。一个真正的鞍点是 $U$ 的一个驻点（即 $\\nabla U = \\mathbf{0}$），且具有特定的Hessian结构。为了找到这个点，我们试图从 $\\mathbf{x}_{\\mathrm{sad, initial}}$ 开始最小化梯度的平方范数 $F(\\mathbf{x}) = \\frac{1}{2}\\|\\nabla U(\\mathbf{x})\\|^2$。再次使用L-BFGS-B算法执行此最小化任务。一个真正的驻点对应于 $F(\\mathbf{x}) = 0$。\n\n**c. 分类：** 通过检查在该点评估的Hessian矩阵 $H_{ij} = \\frac{\\partial^2 U}{\\partial x_i \\partial x_j}$ 的特征值来对精确化后的点 $\\mathbf{x}_{\\mathrm{sad, refined}}$ 进行分类。根据问题说明，Hessian矩阵是使用解析梯度 $\\nabla U$ 的中心有限差分近似来数值计算的。如果一个点的Hessian矩阵有一个负特征值和一个正特征值，则该点被分类为指数-1鞍点。如果精确化后的点被确认为驻点（即 $F(\\mathbf{x}_{\\mathrm{sad, refined}}) \\approx 0$）并且是指数-1鞍点，则接受它作为最终鞍点 $\\mathbf{x}_{\\mathrm{sad}}$。否则，使用路径最大值处的未精确化估计 $\\mathbf{x}_{\\mathrm{sad, initial}}$。\n\n### 步骤5：能垒高度计算和输出格式化\n\n最后，在确定了最小值和鞍点的位置后，计算正向和反向转变的两个能垒为：\n$$ \\Delta U_1 = U(\\mathbf{x}_{\\mathrm{sad}}) - U(\\mathbf{x}_{\\mathrm{min},1}) $$\n$$ \\Delta U_2 = U(\\mathbf{x}_{\\mathrm{sad}}) - U(\\mathbf{x}_{\\mathrm{min},2}) $$\n对于三个测试用例中的每一个，收集计算出的能垒高度和鞍点的坐标。这些数值结果四舍五入到六位小数，并将最终输出格式化为表示列表的列表的单个字符串，不含空格，按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the three specified test cases.\n    It implements the string method to find minimum energy paths and calculates\n    transition barrier heights.\n    \"\"\"\n\n    def get_potential_functions(potential_name):\n        \"\"\"\n        Returns the potential function U and its analytic gradient gradU for a given name.\n        \"\"\"\n        if potential_name == \"U1\":\n            U = lambda p: 0.25 * (p[0]**2 - 1)**2 + 0.5 * (p[1] + 0.5 * p[0])**2\n            gradU = lambda p: np.array([p[0]**3 - 0.75 * p[0] + 0.5 * p[1], 0.5 * p[0] + p[1]])\n        elif potential_name == \"U2\":\n            U = lambda p: (p[0]**2 - 1)**2 + p[1]**2 + 0.5 * p[0] * p[1]\n            gradU = lambda p: np.array([4*p[0]**3 - 4*p[0] + 0.5*p[1], 2*p[1] + 0.5*p[0]])\n        elif potential_name == \"U3\":\n            U = lambda p: (p[0]**2 - 1)**2 + p[1]**2\n            gradU = lambda p: np.array([4*p[0]**3 - 4*p[0], 2*p[1]])\n        else:\n            raise ValueError(f\"Unknown potential: {potential_name}\")\n        return U, gradU\n\n    def find_mep_and_barriers(potential_name, x_guess1, x_guess2, N, dt, K):\n        \"\"\"\n        Calculates the MEP, saddle point, and barrier heights for a given potential and parameters.\n        \"\"\"\n        U, gradU = get_potential_functions(potential_name)\n\n        # 1. Find local minima using L-BFGS-B with analytic gradient\n        res1 = minimize(U, x_guess1, jac=gradU, method='L-BFGS-B')\n        min1 = res1.x\n        res2 = minimize(U, x_guess2, jac=gradU, method='L-BFGS-B')\n        min2 = res2.x\n\n        # 2. Initialize string (path) as a linear interpolation between minima\n        path = np.linspace(min1, min2, N)\n\n        # 3. Evolve string for K iterations\n        for _ in range(K):\n            path_copy = path.copy()\n            # a. Perpendicular gradient step for interior nodes\n            for i in range(1, N - 1):\n                tangent = path[i+1] - path[i-1]\n                norm_tangent = np.linalg.norm(tangent)\n                if norm_tangent > 1e-9:\n                    tangent /= norm_tangent\n                else: \n                    continue\n\n                force = -gradU(path[i])\n                force_perp = force - np.dot(force, tangent) * tangent\n                path_copy[i] += dt * force_perp\n            path = path_copy\n\n            # b. Reparameterization to uniform arc length\n            arc_lengths = np.cumsum(np.linalg.norm(np.diff(path, axis=0), axis=1))\n            arc_lengths = np.insert(arc_lengths, 0, 0)\n            total_length = arc_lengths[-1]\n\n            if total_length  1e-9:\n                path = np.linspace(min1, min2, N)\n                continue\n            \n            target_arc_lengths = np.linspace(0, total_length, N)\n            \n            interp_x = np.interp(target_arc_lengths, arc_lengths, path[:, 0])\n            interp_y = np.interp(target_arc_lengths, arc_lengths, path[:, 1])\n            path = np.vstack([interp_x, interp_y]).T\n            \n            path[0], path[-1] = min1, min2 # Enforce fixed endpoints\n\n        # 4. Identify and refine saddle point\n        # a. Initial estimate from path maximum\n        potentials_on_path = np.array([U(p) for p in path])\n        saddle_idx_initial = np.argmax(potentials_on_path)\n        saddle_initial = path[saddle_idx_initial]\n\n        # b. Refine by minimizing F(x) = 1/2*||gradU(x)||^2\n        f_to_minimize = lambda p: 0.5 * np.dot(gradU(p), gradU(p))\n        res_saddle = minimize(f_to_minimize, saddle_initial, method='L-BFGS-B', tol=1e-10)\n        saddle_refined = res_saddle.x\n\n        # c. Classify refined point using numerical Hessian\n        h = 1e-6\n        hessian = np.zeros((2, 2))\n        hessian[0, 0] = (gradU(saddle_refined + [h, 0])[0] - gradU(saddle_refined - [h, 0])[0]) / (2 * h)\n        hessian[1, 1] = (gradU(saddle_refined + [0, h])[1] - gradU(saddle_refined - [0, h])[1]) / (2 * h)\n        hessian[0, 1] = (gradU(saddle_refined + [0, h])[0] - gradU(saddle_refined - [0, h])[0]) / (2 * h)\n        hessian[1, 0] = (gradU(saddle_refined + [h, 0])[1] - gradU(saddle_refined - [h, 0])[1]) / (2 * h)\n        hessian = 0.5 * (hessian + hessian.T)\n        \n        eigenvalues = np.linalg.eigvalsh(hessian)\n\n        is_stationary = res_saddle.fun  1e-8\n        is_index1_saddle = eigenvalues[0]  0 and eigenvalues[1] > 0\n\n        if is_stationary and is_index1_saddle:\n            saddle_final = saddle_refined\n        else:\n            saddle_final = saddle_initial\n\n        # 5. Compute barrier heights\n        U_min1, U_min2 = U(min1), U(min2)\n        U_sad = U(saddle_final)\n        \n        delta_U1, delta_U2 = U_sad - U_min1, U_sad - U_min2\n        \n        return [round(val, 6) for val in [delta_U1, delta_U2, saddle_final[0], saddle_final[1]]]\n\n    \n    test_cases = [\n        {\"name\": \"U1\", \"guess1\": np.array([-1.2, 0.6]), \"guess2\": np.array([1.2, -0.6]), \"N\": 101, \"dt\": 0.05, \"K\": 400},\n        {\"name\": \"U2\", \"guess1\": np.array([-1.2, 0.3]), \"guess2\": np.array([1.2, -0.3]), \"N\": 101, \"dt\": 0.05, \"K\": 600},\n        {\"name\": \"U3\", \"guess1\": np.array([-1.2, 0.0]), \"guess2\": np.array([1.2, 0.0]), \"N\": 101, \"dt\": 0.05, \"K\": 300},\n    ]\n\n    results = []\n    for case in test_cases:\n        case_result = find_mep_and_barriers(case[\"name\"], case[\"guess1\"], case[\"guess2\"], case[\"N\"], case[\"dt\"], case[\"K\"])\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "4376608"}]}