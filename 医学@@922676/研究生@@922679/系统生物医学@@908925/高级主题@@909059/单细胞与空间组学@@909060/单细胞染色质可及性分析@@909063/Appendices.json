{"hands_on_practices": [{"introduction": "单细胞染色质可及性分析的第一步，是将测序仪产生的原始测序读数（reads）转化为代表开放染色质区域的结构化片段（fragments）文件。本练习将引导你从第一性原理出发，构建一个核心的生物信息学流程，包括序列比对、Tn5转座酶切割位点校正和片段构建[@problem_id:4314894]。完成此练习将帮助你深入理解scATAC-seq基础数据单元的生成过程。", "problem": "您的任务是构建一个自包含的计算流程，该流程将单细胞转座酶可及性染色质测序 (scATAC-seq) 的原始双端测序读段 (reads) 转换为单细胞级别的片段表示。该流程必须遵循以下基本事实和定义，从第一性原理出发：\n\n- 脱氧核糖核酸 (DNA) 可以表示为字母表 $\\{A,C,G,T\\}$ 上的有限字符串。\n- DNA 字符串的反向互补链是通过反转字符串并将每个碱基按 $A \\leftrightarrow T$ 和 $C \\leftrightarrow G$ 的映射关系替换为其互补碱基而获得的。\n- 在 scATAC-seq 中，Tn5 转座酶（常称为 Tn5）会进行交错切割，并对已比对读段的 $5'$ 端应用广泛接受的经验校正偏移量：对于比对到正向链的读段，偏移 $+4$ 个碱基；对于比对到反向链的读段，偏移 $-5$ 个碱基。\n- 基因组坐标将采用每条染色体上 0-起始、半开区间的约定，因此染色体 $X$ 上的一个片段由元组 $(X, s, e)$ 表示，其中 $s$ 是包含性的起始位置， $e$ 是排除性的结束位置，且满足 $0 \\le s \\le e \\le L_X$，$L_X$ 是染色体 $X$ 的长度。\n\n您必须实现以下步骤，不得依赖外部文件或输入；所有数据都将嵌入在程序中：\n\n1. 通过精确匹配进行比对：\n   - 给定一条染色体的基因组字符串、一个长度为 $L$ 的读段字符串 $r$ 及其反向互补链 $rc(r)$，扫描所有位置 $p \\in \\{0,1,\\dots,L_{\\text{chr}}-L\\}$。\n   - 当位于 $[p,p+L)$ 的基因组子串等于 $r$ 时，记录一个正向链位置；当位于 $[p,p+L)$ 的基因组子串等于 $rc(r)$ 时，记录一个反向链位置。\n   - 如果在两条链上存在多个位置，选择 $p$ 值最小的那个；如果正反链上的最小 $p$ 值相同，则优先选择正向链。如果两条链上都没有找到位置，则该读段被视为未比对上。\n\n2. 确定每个已比对读段的切割位点：\n   - 对于在位置 $p$ 处、读段长度为 $L$ 的正向链位置，将未校正的 $5'$ 切割位点定义为 $c = p$。\n   - 对于在位置 $p$ 处、读段长度为 $L$ 的反向链位置，将未校正的 $5'$ 切割位点定义为 $c = p + L$。\n\n3. Tn5 切割位点偏移校正与裁剪：\n   - 应用经验偏移量：正向链使用 $+4$，反向链使用 $-5$。\n   - 偏移后，将所得坐标裁剪到有效范围 $[0, L_{\\text{chr}}]$ 内。\n\n4. 片段构建与去重：\n   - 对于在同一染色体上比对上的每个双端读段 $(r_1, r_2)$，计算它们的两个经裁剪和偏移的切割位点 $o_1$ 和 $o_2$。\n   - 将片段区间定义为 $[s,e)$，其中 $s = \\min(o_1,o_2)$ 且 $e = \\max(o_1,o_2)$。\n   - 丢弃 $s = e$ 的零长度片段。\n   - 将每个片段与其细胞条形码 $b$ 和染色体名称 $X$ 相关联，形成元组 $(X, s, e, b)$。\n   - 通过 $(X, s, e, b)$ 的完全一致性对每个细胞内的片段进行去重；不同细胞条形码之间的重复片段不合并。\n\n5. 聚合与输出：\n   - 对于每个测试用例，计算去重后（身份识别包含条形码）获得的唯一片段数量，并得出一个整数结果。\n\n在单个程序中实现以上步骤，该程序嵌入下面定义的测试套件，为每个测试用例运行流程，并以方括号内的逗号分隔列表形式在单行中打印结果，例如 $[r_1,r_2,r_3]$。\n\n测试套件：\n- 案例 1 (包含按细胞去重的理想路径)：\n  - 基因组：\n    - 染色体名称：\"chr1\"\n    - 序列：\"AAAACCCCGGGGTTTTACGTACGTTTGGCCAAATTTCCCGGG\"\n  - 带条形码的双端读段：\n    - (\"chr1\", $r_1 = \\text{\"ACGTAC\"}$, $r_2 = \\text{\"TTTGGCC\"}$, $b = \\text{\"cellA\"}$)\n    - (\"chr1\", $r_1 = \\text{\"ACGTAC\"}$, $r_2 = \\text{\"TTTGGCC\"}$, $b = \\text{\"cellA\"}$)  [与上一个重复]\n    - (\"chr1\", $r_1 = \\text{\"GGGGTT\"}$, $r_2 = \\text{\"AAAACC\"}$, $b = \\text{\"cellB\"}$)\n  - 预期行为：当身份识别包含条形码时，比对总共产生两个唯一的片段。\n\n- 案例 2 (染色体起始处的边界导致 $-5$ 反向偏移后发生裁剪)：\n  - 基因组：\n    - 染色体名称：\"chr2\"\n    - 序列：\"AAAAC\"\n  - 带条形码的双端读段：\n    - (\"chr2\", $r_1 = \\text{\"AAAA\"}$, $r_2 = \\text{\"TTT\"}$, $b = \\text{\"cellX\"}$)\n  - 预期行为：反向链偏移产生一个负坐标，必须将其裁剪为 0，从而产生一个唯一的片段。\n\n- 案例 3 (染色体末端的边界导致 $+4$ 正向偏移后发生裁剪)：\n  - 基因组：\n    - 染色体名称：\"chr3\"\n    - 序列：\"ACGTAC\"\n  - 带条形码的双端读段：\n    - (\"chr3\", $r_1 = \\text{\"TA\"}$, $r_2 = \\text{\"GT\"}$, $b = \\text{\"cellY\"}$)\n  - 预期行为：正向链偏移超出了染色体长度，必须将其裁剪为 $L_{\\text{chr}}$，从而产生一个唯一的片段。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个案例的结果，格式为方括号括起来的逗号分隔列表，例如 $[2,1,1]$。不应打印任何其他文本。", "solution": "该问题为处理单细胞转座酶可及性染色质测序 (scATAC-seq) 数据的计算流程提供了详细的规范。该过程从原始双端测序读段开始，生成一组唯一的、单细胞级别的染色质片段。解决方案要求忠实地实现指定的步骤，这些步骤基于既定的生物信息学原理。\n\n首先，建立基本定义。DNA 序列是字母表 $\\{\\text{'A'}, \\text{'C'}, \\text{'G'}, \\text{'T'}\\}$ 上的字符串。DNA 字符串的反向互补链，记为 $rc(S)$，是通过反转字符串 $S$ 并将每个碱基替换为其 Watson-Crick 互补碱基（$A \\leftrightarrow T$，$C \\leftrightarrow G$）获得的。基因组位置使用 0-起始、半开区间的约定来表示，其中染色体 $X$ 上一个从起始位置 $s$（含）到结束位置 $e$（不含）的片段记为 $(X, s, e)$。该区间必须符合染色体的边界，$0 \\le s \\le e \\le L_X$，其中 $L_X$ 是染色体 $X$ 的长度。\n\n该流程包括五个连续的步骤：\n\n**1. 通过精确匹配进行比对**\n此步骤将测序读段映射到其在参考基因组上的来源。对于一个给定长度为 $L_r$ 的读段 $r$ 和长度为 $L_{\\text{chr}}$ 的染色体序列 $G$，我们搜索其位置和链。如果基因组子串 $G[p:p+L_r)$ 等于 $r$，则在位置 $p$ 处发生正向链放置。如果 $G[p:p+L_r)$ 等于 $rc(r)$，则发生反向链放置。所有可能的起始位置 $p \\in \\{0, 1, \\dots, L_{\\text{chr}} - L_r\\}$ 都会被扫描。如果存在多种比对可能性，则应用确定性的平局决胜规则：选择基因组坐标 $p$ 最小的比对。如果一个正向和一个反向比对共享相同的最小 $p$ 值，则优先选择正向链比对。没有找到匹配的读段被视为未比对上，不再进一步处理。\n\n**2. 切割位点确定**\nscATAC-seq 通过利用 Tn$5$ 转座酶来识别可及的染色质区域，该酶切割 DNA 并插入测序接头。每个测序读段的起始位置对应于这些切割位点之一。代表读段 $5'$ 端的未校正切割坐标定义如下：\n- 对于在位置 $p$ 比对上的正向链读段，未校正的切割位点为 $c = p$。\n- 对于在位置 $p$ 比对上、长度为 $L_r$ 的反向链读段，其对应的 $5'$ 端位于基因组上比对片段的末端。因此，未校正的切割位点为 $c = p + L_r$。\n\n**3. Tn5 切割位点偏移校正与裁剪**\nTn$5$ 酶以二聚体形式起作用，其两个活性位点在 DNA 中产生交错的切口。这意味着转座子结合事件的精确中心并不恰好位于读段的 $5'$ 端。为了解决这个问题，应用了经验校正：\n- 正向链读段的切割位点偏移 $+4$ 个碱基：$c' = c + 4$。\n- 反向链读段的切割位点偏移 $-5$ 个碱基：$c' = c - 5$。\n所得坐标 $c'$ 必须是染色体上的有效位置。任何落在染色体边界 $[0, L_{\\text{chr}}]$ 之外的坐标都会被裁剪到最近的有效值。最终的偏移坐标 $o$ 由 $o = \\max(0, \\min(c', L_{\\text{chr}}))$ 给出。\n\n**4. 片段构建与去重**\n在双端测序中，两个读段 $r_1$ 和 $r_2$ 从单个 DNA 片段的相反两端生成。在确定一对读段的最终经裁剪和偏移的切割位点 $o_1$ 和 $o_2$ 后，原始片段被重建。该片段由区间 $[s, e)$ 表示，其中 $s = \\min(o_1, o_2)$ 且 $e = \\max(o_1, o_2)$。任何长度为零（$s=e$）的所得片段都将被丢弃。然后将每个有效片段记录为一个元组 $(X, s, e, b)$，其中 $X$ 是染色体名称，$b$ 是细胞条形码。由于文库制备过程中的 PCR 扩增，多个相同的读段对可能源自单个初始片段。为了校正这种扩增偏倚，需要对片段进行去重。唯一性由元组 $(X, s, e, b)$ 的完全一致性确定，这意味着只有来自同一细胞的相同片段才被视为重复。\n\n**5. 聚合与输出**\n最后一步是通过计算整个流程执行后生成的唯一片段数量，来量化每个测试用例的结果。\n\n**测试用例执行：**\n\n**案例 1：** 基因组 `chr1` ($L_{\\text{chr1}} = 46$)。\n- 读段对 $1$：$(r_{1a} = \\text{\"ACGTAC\"}, r_{2a} = \\text{\"TTTGGCC\"}, b = \\text{\"cellA\"})$。\n  - $r_{1a}$ 在 $p_1=16$ 处比对到正向链。校正后切割位点：$o_1 = \\text{clip}(16+4, 0, 46) = 20$。\n  - $r_{2a}$ 在 $p_2=24$ 处比对到正向链。其反向互补链在基因组中没有匹配。校正后切割位点：$o_2 = \\text{clip}(24+4, 0, 46) = 28$。\n  - 片段：$(\\text{\"chr1\"}, \\min(20,28), \\max(20,28), \\text{\"cellA\"}) = (\\text{\"chr1\"}, 20, 28, \\text{\"cellA\"})$。\n- 读段对 $2$：与读段对 1 相同，产生相同的片段 $(\\text{\"chr1\"}, 20, 28, \\text{\"cellA\"})$。\n- 读段对 $3$：$(r_{1c} = \\text{\"GGGGTT\"}, r_{2c} = \\text{\"AAAACC\"}, b = \\text{\"cellB\"})$。\n  - $r_{1c}$ 在 $p_1=8$ 处比对到正向链。校正后切割位点：$o_1 = \\text{clip}(8+4, 0, 46) = 12$。\n  - $r_{2c}$ 在 $p_2=0$ 处比对到正向链。其反向互补链在基因组中没有匹配。校正后切割位点：$o_2 = \\text{clip}(0+4, 0, 46) = 4$。\n  - 片段：$(\\text{\"chr1\"}, \\min(12,4), \\max(12,4), \\text{\"cellB\"}) = (\\text{\"chr1\"}, 4, 12, \\text{\"cellB\"})$。\n- 去重后，唯一片段为 $\\{(\\text{\"chr1\"}, 20, 28, \\text{\"cellA\"}), (\\text{\"chr1\"}, 4, 12, \\text{\"cellB\"})\\}$。总数为 $2$。\n\n**案例 2：** 基因组 `chr2` ($L_{\\text{chr2}} = 5$)。\n- 读段对：$(r_1 = \\text{\"AAAA\"}, r_2 = \\text{\"TTT\"}, b = \\text{\"cellX\"})$。\n  - $r_1$ 在 $p_1=0$ 处比对到正向链。校正后切割位点：$o_1 = \\text{clip}(0+4, 0, 5) = 4$。\n  - $r_2$（长度为 3）在 $p_2=0$ 处比对到反向链。未校正切割位点 $c_2 = p_2+L_2 = 0+3=3$。校正后切割位点：$o_2 = \\text{clip}(3-5, 0, 5) = \\text{clip}(-2, 0, 5) = 0$。\n  - 片段：$(\\text{\"chr2\"}, \\min(4,0), \\max(4,0), \\text{\"cellX\"}) = (\\text{\"chr2\"}, 0, 4, \\text{\"cellX\"})$。\n- 唯一片段总数：$1$。\n\n**案例 3：** 基因组 `chr3` ($L_{\\text{chr3}} = 6$)。\n- 读段对：$(r_1 = \\text{\"TA\"}, r_2 = \\text{\"GT\"}, b = \\text{\"cellY\"})$。\n  - $r_1$ 在 $p_1=3$ 处比对到正向链（优于在相同 $p$ 处的反向链）。校正后切割位点：$o_1 = \\text{clip}(3+4, 0, 6) = \\text{clip}(7, 0, 6) = 6$。\n  - $r_2$（长度为 2）在 $p_2=0$ 处比对到反向链。未校正切割位点 $c_2 = p_2+L_2 = 0+2=2$。校正后切割位点：$o_2 = \\text{clip}(2-5, 0, 6) = \\text{clip}(-3, 0, 6) = 0$。\n  - 片段：$(\\text{\"chr3\"}, \\min(6,0), \\max(6,0), \\text{\"cellY\"}) = (\\text{\"chr3\"}, 0, 6, \\text{\"cellY\"})$。\n- 唯一片段总数：$1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a self-contained computational pipeline for processing scATAC-seq data\n    from raw paired-end reads to a per-cell fragment representation.\n    \"\"\"\n\n    def reverse_complement(dna_string):\n        \"\"\"Computes the reverse complement of a DNA string.\"\"\"\n        complement_map = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n        return \"\".join(complement_map.get(base, base) for base in reversed(dna_string))\n\n    def align_read(read_seq, genome_seq):\n        \"\"\"\n        Aligns a read to a genome sequence by exact matching, applying specified tie-breaking rules.\n        Returns a tuple (position, strand) or None if unaligned.\n        \"\"\"\n        read_len = len(read_seq)\n        genome_len = len(genome_seq)\n        \n        fwd_matches = []\n        rev_matches = []\n        \n        rc_read_seq = reverse_complement(read_seq)\n        \n        for p in range(genome_len - read_len + 1):\n            substring = genome_seq[p:p + read_len]\n            if substring == read_seq:\n                fwd_matches.append(p)\n            if substring == rc_read_seq:\n                rev_matches.append(p)\n                \n        min_p_fwd = min(fwd_matches) if fwd_matches else float('inf')\n        min_p_rev = min(rev_matches) if rev_matches else float('inf')\n        \n        if min_p_fwd == float('inf') and min_p_rev == float('inf'):\n            return None  # Unaligned\n        \n        # Tie-breaking rule: smallest p, then forward strand preferred\n        if min_p_fwd = min_p_rev:\n            return (min_p_fwd, 'fwd')\n        else:\n            return (min_p_rev, 'rev')\n            \n    def process_case(genome, paired_reads):\n        \"\"\"\n        Runs the full pipeline for a single test case.\n        \"\"\"\n        genome_name = genome['name']\n        genome_seq = genome['seq']\n        genome_len = len(genome_seq)\n        \n        unique_fragments = set()\n        \n        for _, r1_seq, r2_seq, barcode in paired_reads:\n            # Align read 1\n            alignment1 = align_read(r1_seq, genome_seq)\n            if not alignment1:\n                continue\n            \n            # Align read 2\n            alignment2 = align_read(r2_seq, genome_seq)\n            if not alignment2:\n                continue\n\n            p1, strand1 = alignment1\n            p2, strand2 = alignment2\n            \n            # Calculate offset cut site for read 1\n            if strand1 == 'fwd':\n                uncorrected_c1 = p1\n                corrected_c1 = uncorrected_c1 + 4\n            else:  # 'rev'\n                uncorrected_c1 = p1 + len(r1_seq)\n                corrected_c1 = uncorrected_c1 - 5\n            o1 = np.clip(corrected_c1, 0, genome_len)\n            \n            # Calculate offset cut site for read 2\n            if strand2 == 'fwd':\n                uncorrected_c2 = p2\n                corrected_c2 = uncorrected_c2 + 4\n            else:  # 'rev'\n                uncorrected_c2 = p2 + len(r2_seq)\n                corrected_c2 = uncorrected_c2 - 5\n            o2 = np.clip(corrected_c2, 0, genome_len)\n            \n            # Construct fragment interval\n            s = min(o1, o2)\n            e = max(o1, o2)\n            \n            # Discard zero-length fragments\n            if s == e:\n                continue\n            \n            fragment = (genome_name, int(s), int(e), barcode)\n            unique_fragments.add(fragment)\n            \n        return len(unique_fragments)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"genome\": {\"name\": \"chr1\", \"seq\": \"AAAACCCCGGGGTTTTACGTACGTTTGGCCAAATTTCCCGGG\"},\n            \"reads\": [\n                (\"chr1\", \"ACGTAC\", \"TTTGGCC\", \"cellA\"),\n                (\"chr1\", \"ACGTAC\", \"TTTGGCC\", \"cellA\"),\n                (\"chr1\", \"GGGGTT\", \"AAAACC\", \"cellB\"),\n            ]\n        },\n        {\n            \"genome\": {\"name\": \"chr2\", \"seq\": \"AAAAC\"},\n            \"reads\": [\n                (\"chr2\", \"AAAA\", \"TTT\", \"cellX\")\n            ]\n        },\n        {\n            \"genome\": {\"name\": \"chr3\", \"seq\": \"ACGTAC\"},\n            \"reads\": [\n                (\"chr3\", \"TA\", \"GT\", \"cellY\")\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case[\"genome\"], case[\"reads\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4314894"}, {"introduction": "在获得每个细胞的片段数据后，下一步关键任务是进行质量控制（QC），以滤除低质量或濒临凋亡的细胞。本练习聚焦于一个核心QC指标——线粒体DNA片段比例，它能够有效识别处于压力或死亡状态的细胞[@problem_id:4314890]。通过这个练习，你将实践如何应用统计学原理来设定数据驱动的过滤阈值，这是单细胞分析中的一项常规且重要的技能。", "problem": "在单细胞转座酶可及性染色质分析 (scATAC-seq) 实验中，每个细胞都会产生一个唯一比对上的片段总数，其中一部分片段会定位到线粒体基因组上。我们定义每个细胞的线粒体分数为 $f_{\\text{mt}} = n_{\\text{mt}}/n_{\\text{total}}$，其中 $n_{\\text{mt}}$ 是线粒体片段的数量，而 $n_{\\text{total}}$ 是该细胞的总片段数。高的 $f_{\\text{mt}}$ 值通常与低质量或凋亡的细胞有关，因为当核染色质降解或细胞核破裂时，线粒体仍然是可及的。\n\n给定七个细胞的片段计数 $(n_{\\text{mt}}, n_{\\text{total}})$：\n- 细胞 $1$：$(300, 5000)$\n- 细胞 $2$：$(295, 5000)$\n- 细胞 $3$：$(305, 5000)$\n- 细胞 $4$：$(290, 5000)$\n- 细胞 $5$：$(310, 5000)$\n- 细胞 $6$：$(280, 5000)$\n- 细胞 $7$：$(1460, 5100)$\n\n任务：\n1. 计算每个细胞的 $f_{\\text{mt}}$。\n2. 使用这七个细胞的 $\\{f_{\\text{mt}}\\}$ 样本中位数作为基线健康细胞线粒体分数 $p_{0}$ 的估计值，并将片段来源建模为成功概率为 $p_{0}$ 的独立伯努利试验，推导出一个 $f_{\\text{mt}}$ 的上阈值 $T$，使得一个总片段数为 $n_{\\text{eff}} = 5000$ 的健康细胞超过该阈值 $T$ 的概率为 $\\alpha = 0.01$。使用二项式模型和中心极限定理作为基本出发点，从第一性原理证明该阈值策略的合理性。\n3. 以小数形式报告 $T$ 的单一数值，四舍五入到四位有效数字。不要使用百分号。", "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于标准的单细胞基因组学质量控制实践，问题提出得当，提供了所有必要信息，并且表述客观。解题过程如下。\n\n问题分为三个任务：\n1.  计算七个细胞中每个细胞的线粒体分数 $f_{\\text{mt}}$。\n2.  建立基线健康细胞线粒体分数 $p_{0}$，并基于一个统计模型推导 $f_{\\text{mt}}$ 的上阈值 $T$。\n3.  报告四舍五入到四位有效数字的 $T$ 的数值。\n\n**任务1：计算线粒体分数**\n\n线粒体分数定义为 $f_{\\text{mt}} = n_{\\text{mt}}/n_{\\text{total}}$，其中 $n_{\\text{mt}}$ 是线粒体片段的数量，$n_{\\text{total}}$ 是总片段数。给定的数据是 $(n_{\\text{mt}}, n_{\\text{total}})$ 对。我们为每个细胞计算 $f_{\\text{mt}}$：\n- 细胞 $1$：$f_{\\text{mt},1} = \\frac{300}{5000} = 0.060$\n- 细胞 $2$：$f_{\\text{mt},2} = \\frac{295}{5000} = 0.059$\n- 细胞 $3$：$f_{\\text{mt},3} = \\frac{305}{5000} = 0.061$\n- 细胞 $4$：$f_{\\text{mt},4} = \\frac{290}{5000} = 0.058$\n- 细胞 $5$：$f_{\\text{mt},5} = \\frac{310}{5000} = 0.062$\n- 细胞 $6$：$f_{\\text{mt},6} = \\frac{280}{5000} = 0.056$\n- 细胞 $7$：$f_{\\text{mt},7} = \\frac{1460}{5100} \\approx 0.28627$\n\n线粒体分数集合为 $\\{0.060, 0.059, 0.061, 0.058, 0.062, 0.056, 0.28627...\\}$。\n\n**任务2：推导上阈值 $T$**\n\n首先，我们使用计算出的 $\\{f_{\\text{mt}}\\}$ 值的样本中位数来估计基线健康细胞线粒体分数 $p_{0}$。使用中位数是一种稳健的统计方法，可以最大限度地减少异常值的影响。在这个数据集中，细胞7的 $f_{\\text{mt}}$ 值明显更高，表明它是一个低质量或凋亡的细胞，将其包含在平均值计算中会使基线估计产生偏差。\n\n为了找到中位数，我们将 $f_{\\text{mt}}$ 值按升序排列：\n$$\n\\{0.056, 0.058, 0.059, 0.060, 0.061, 0.062, 0.28627...\\}\n$$\n对于一个包含7个观测值的数据集，中位数是排序后列表中的第4个值。\n因此，我们对基线健康线粒体分数的估计是 $p_{0} = 0.060$。\n\n接下来，我们对健康细胞中线粒体片段的数量进行建模。对于一个总共有 $n_{\\text{eff}}$ 个片段的细胞，我们可以将每个片段的来源（是否是线粒体）建模为一次独立的伯努利试验。一次“成功”（即片段来自线粒体）的发生概率为 $p_{0}$。因此，线粒体片段的总数，用随机变量 $X$ 表示，服从二项分布：\n$$\nX \\sim \\text{Binomial}(n, p)\n$$\n其中试验次数为 $n = n_{\\text{eff}} = 5000$，成功概率为 $p = p_{0} = 0.06$。\n\n该细胞的线粒体分数是样本比例 $\\hat{p} = X/n_{\\text{eff}}$。我们想要找到一个阈值 $T$，使得这个分数超过 $T$ 的概率很小，具体为 $\\alpha = 0.01$。题目要求使用中心极限定理（CLT）来推导这个阈值。\n\n根据中心极限定理，对于大量的试验次数 $n$，样本比例 $\\hat{p}$ 的分布可以近似为正态分布。这个正态分布的参数是：\n-   均值：$E[\\hat{p}] = p_{0}$\n-   方差：$\\text{Var}(\\hat{p}) = \\frac{p_{0}(1-p_{0})}{n_{\\text{eff}}}$\n\n因此，我们有如下近似：\n$$\n\\hat{p} \\approx \\mathcal{N}\\left(p_{0}, \\frac{p_{0}(1-p_{0})}{n_{\\text{eff}}}\\right)\n$$\n我们需要找到一个阈值 $T$，使得 $P(\\hat{p} > T) = \\alpha$。为了解决这个问题，我们将随机变量 $\\hat{p}$ 标准化为一个标准正态变量 $Z \\sim \\mathcal{N}(0, 1)$：\n$$\nZ = \\frac{\\hat{p} - E[\\hat{p}]}{\\sqrt{\\text{Var}(\\hat{p})}} = \\frac{\\hat{p} - p_{0}}{\\sqrt{\\frac{p_{0}(1-p_{0})}{n_{\\text{eff}}}}}\n$$\n概率陈述变为：\n$$\nP\\left(\\frac{\\hat{p} - p_{0}}{\\sqrt{\\frac{p_{0}(1-p_{0})}{n_{\\text{eff}}}}} > \\frac{T - p_{0}}{\\sqrt{\\frac{p_{0}(1-p_{0})}{n_{\\text{eff}}}}}\\right) = \\alpha\n$$\n这等价于 $P(Z > z_{\\alpha}) = \\alpha$，其中 $z_{\\alpha}$ 是标准正态分布的上 $\\alpha$-分位数，并且\n$$\nz_{\\alpha} = \\frac{T - p_{0}}{\\sqrt{\\frac{p_{0}(1-p_0)}{n_{\\text{eff}}}}}\n$$\n求解 $T$，我们得到：\n$$\nT = p_{0} + z_{\\alpha} \\sqrt{\\frac{p_{0}(1-p_{0})}{n_{\\text{eff}}}}\n$$\n\n**任务3：$T$ 的数值计算**\n\n我们现在将给定和推导出的值代入 $T$ 的表达式中：\n-   $p_{0} = 0.06$\n-   $n_{\\text{eff}} = 5000$\n-   $\\alpha = 0.01$\n\n我们需要找到 $z_{0.01}$ 的值，使得标准正态曲线下其右侧的面积为 $0.01$。这对应于 $1 - 0.01 = 0.99$ 的累积概率。从标准正态分布表或计算函数中，我们得到 $z_{0.01} \\approx 2.3263$。\n\n现在，我们计算比例的标准误差：\n$$\n\\text{SE}_{\\hat{p}} = \\sqrt{\\frac{p_{0}(1-p_{0})}{n_{\\text{eff}}}} = \\sqrt{\\frac{0.06 \\times (1-0.06)}{5000}} = \\sqrt{\\frac{0.06 \\times 0.94}{5000}} = \\sqrt{\\frac{0.0564}{5000}} = \\sqrt{0.00001128}\n$$\n$$\n\\text{SE}_{\\hat{p}} \\approx 0.00335857\n$$\n最后，我们计算 $T$：\n$$\nT = 0.06 + (2.3263) \\times (0.00335857) \\approx 0.06 + 0.0078122\n$$\n$$\nT \\approx 0.0678122\n$$\n题目要求答案四舍五入到四位有效数字。第一个有效数字是 $6$。保留四位有效数字的结果是 $0.06781$。第五位有效数字是 $2$，因此我们向下舍入。\n\n阈值的最终数值为 $0.06781$。", "answer": "$$\n\\boxed{0.06781}\n$$", "id": "4314890"}, {"introduction": "拥有高质量的数据集后，我们便可以开始揭示其背后的生物学机制，例如识别活性的转录因子（TF）。这项高级练习将向你展示如何计算“足迹得分”，该得分通过衡量TF结合基序（motif）处转座酶切割的局部缺失来推断蛋白与DNA的结合[@problem_id:4314918]。此练习涉及实现一个校正酶切序列偏好性的模型，这是足迹分析中的一个关键挑战，能让你体验从可及性数据中提取调控信号的完整过程。", "problem": "您的任务是推导、形式化并实现一个算法，用于计算单细胞转座酶可及性染色质测序数据中转录因子基序的染色质可及性足迹分数，并完全以数学和逻辑术语进行表述。请从基础的概率建模和生物物理定义出发，编写一个程序，为指定的测试用例计算所要求的分数。\n\n基本依据与假设：\n- 设一个基因组位点被离散化为长度为 $L$ 的序列中以碱基为单位的位置，索引为 $i \\in \\{0,1,\\dots,L-1\\}$。在每个位置 $i$ 处，可观测的插入（切割）计数记为 $c_i$。\n- 根据经验，转座酶插入过程可以被建模为一个计数过程，其中 $c_i$ 可以很好地由参数为 $\\lambda_i$ 的泊松随机变量近似，即 $c_i \\sim \\mathrm{Poisson}(\\lambda_i)$。这是基因组学中对计数数据广泛使用的一种近似方法。\n- 假设参数 $\\lambda_i$ 可分解为一个全局缩放因子 $\\mu$（例如，反映细胞深度或文库大小）、一个局部可及性因子 $a_i$（染色质对酶的生物物理可及性）以及一个捕捉序列偏好的序列依赖性转座酶偏好 $b_i$：$$\\lambda_i = \\mu \\, a_i \\, b_i.$$\n- 序列依赖的偏好 $b_i$ 使用 $k$-mer 表示法进行建模。对于一个奇数 $k$ 和一个位置 $i$，通过提取从 $i - \\left\\lfloor k/2 \\right\\rfloor$ 到 $i + \\left\\lfloor k/2 \\right\\rfloor$（包含两端）的子字符串来定义一个以 $i$ 为中心的 $k$-mer，前提是该子字符串在边界内。将每个可能的 $k$-mer $u$ 与一个实值权重 $w_u$ 相关联。位置 $i$ 处的未归一化偏好为 $$\\tilde{b}_i = \\exp\\!\\big(w_{u(i)}\\big),$$ 其中 $u(i)$ 是在边界内以 $i$ 为中心的 $k$-mer，当由于边界条件无法提取 $k$-mer 时，$w_{u(i)} = 0$（因此 $\\tilde{b}_i = 1$）。为了在感兴趣的区域 $R$（定义如下）内实现可比性，将其在 $R$ 内归一化至单位均值：$$b_i = \\frac{\\tilde{b}_i}{\\frac{1}{|R|}\\sum_{j \\in R} \\tilde{b}_j}.$$\n- 在泊松分解下，将观测计数除以归一化偏好，可以得到一个与可及性成正比的自然估计量：$$\\tilde{c}_i = \\frac{c_i}{b_i}.$$ 为了数值稳定性，在计算均值之前，为每个校正后的计数加上一个伪计数 $\\epsilon$：$$\\tilde{c}_i^{(\\epsilon)} = \\tilde{c}_i + \\epsilon,$$ 其中 $\\epsilon > 0$。\n- 使用 0-基索引定义一个基序中心区间 $C = \\{s, s+1, \\dots, e\\}$，其中整数 $s, e$ 满足 $0 \\leq s \\leq e \\leq L-1$。并定义两侧宽度为 $m$ 个碱基的侧翼区域（在序列边界内）为 $F_{\\text{left}} = \\{\\max(0, s-m), \\dots, s-1\\}$ 和 $F_{\\text{right}} = \\{e+1, \\dots, \\min(L-1, e+m)\\}$，合并后的侧翼区域集合为 $F = F_{\\text{left}} \\cup F_{\\text{right}}$。用于偏好归一化的感兴趣区域是 $R = C \\cup F$。\n- 足迹分数在概念上定义为侧翼区域与基序中心区域的平均校正插入计数的比率，这反映了受保护的基序相对于其可及的周围环境，插入预期的减少量。该分数计算如下：$$S = \\frac{\\frac{1}{|F|}\\sum_{i \\in F} \\tilde{c}_i^{(\\epsilon)}}{\\frac{1}{|C|}\\sum_{i \\in C} \\tilde{c}_i^{(\\epsilon)}}.$$\n\n程序要求：\n- 在一个不接受任何输入并使用下面提供的测试套件的单一程序中实现上述模型和计算，为每个案例计算足迹分数 S。\n- 全程使用 0-基索引。\n- 将任何缺失的 k-mer 权重视为 0。\n- 所有测试用例均使用 $k = 3$。\n- 所有测试用例均使用相同的 3-mer 权重字典。该字典将以下 3-mer 与其各自的权重 $w_u$ 关联（所有未指定的 3-mer 的 $w_u = 0$）：\n  - $w_{\\text{AAA}} = -0.4$\n  - $w_{\\text{TTT}} = -0.4$\n  - $w_{\\text{GGG}} = 0.6$\n  - $w_{\\text{CCC}} = 0.6$\n  - $w_{\\text{ACG}} = 0.3$\n  - $w_{\\text{CGT}} = 0.3$\n  - $w_{\\text{GCG}} = 0.5$\n  - $w_{\\text{CGC}} = 0.5$\n  - $w_{\\text{CCG}} = 0.4$\n  - $w_{\\text{GCC}} = 0.4$\n  - $w_{\\text{AGG}} = 0.3$\n  - $w_{\\text{GGA}} = 0.3$\n  - $w_{\\text{CAG}} = 0.2$\n  - $w_{\\text{GTT}} = -0.2$\n  - $w_{\\text{CAT}} = -0.2$\n  - $w_{\\text{ATC}} = -0.1$\n  - $w_{\\text{TAC}} = -0.1$\n  - $w_{\\text{CGG}} = 0.5$\n  - $w_{\\text{GGC}} = 0.5$\n- 使用伪计数 $\\epsilon = 10^{-6}$。\n\n测试套件：\n- 案例 1：\n  - 序列字符串: \"ACGTACGTACGGGCCCTTTACGTACGTAC\"\n  - 长度 $L = 30$\n  - 观测计数 $c_i$ 对于 $i = 0,1,\\dots,29$: $[4,5,4,5,3,4,5,8,9,7,10,9,2,1,3,2,1,2,8,7,9,10,8,4,5,4,5,3,4,5]$\n  - 基序中心索引: $s = 12$, $e = 17$\n  - 侧翼宽度: $m = 5$\n- 案例 2：\n  - 序列字符串: \"GGGACGTACGTACGTACGTACGTT\"\n  - 长度 $L = 24$\n  - 观测计数 $c_i$ 对于 $i = 0,1,\\dots,23$: $[7,8,7,1,2,1,1,8,7,9,5,4,6,5,4,5,6,5,4,5,4,6,5,4]$\n  - 基序中心索引: $s = 3$, $e = 6$\n  - 侧翼宽度: $m = 3$\n- 案例 3：\n  - 序列字符串: \"AAAAAGGGCCCACGTACGTAAAAA\"\n  - 长度 $L = 24$\n  - 观测计数 $c_i$ 对于 $i = 0,1,\\dots,23$: $[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]$\n  - 基序中心索引: $s = 5$, $e = 10$\n  - 侧翼宽度: $m = 4$\n- 案例 4：\n  - 序列字符串: \"ACGTACGTACGTACGTACGT\"\n  - 长度 $L = 20$\n  - 观测计数 $c_i$ 对于 $i = 0,1,\\dots,19$: $[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]$\n  - 基序中心索引: $s = 8$, $e = 11$\n  - 侧翼宽度: $m = 3$\n\n输出规格：\n- 按 1 到 4 的顺序为每个案例计算足迹分数 S。\n- 程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个分数呈现为四舍五入到 6 位小数的十进制数（例如，[1.234567,0.987654,2.000000,1.000000]）。", "solution": "问题陈述经评估是有效的。它在科学上基于生物信息学和基因组学的原理，特别是在染色质可及性数据的分析方面。所提出的模型虽然是对最先进方法的简化，但逻辑上一致、适定，并基于已建立的统计学（泊松过程）和生物物理学（转座酶偏好、转录因子足迹法）概念。该问题以数学精度进行阐述，提供了为每个测试用例计算唯一解所需的所有数据、参数和边界条件。它没有歧义、主观性和事实错误。\n\n任务是根据所提供的模型，形式化并实现一个计算染色质可及性足迹分数 $S$ 的算法。推导过程通过一系列数学上定义的步骤进行。\n\n首先，确定相关的基因组区域。给定一个基序起始位置 $s$、结束位置 $e$、侧翼宽度 $m$ 和总序列长度 $L$，我们定义三组索引：\n1.  基序中心，$C = \\{i \\in \\mathbb{Z} \\mid s \\leq i \\leq e\\}$。该区域的大小为 $|C| = e - s + 1$。\n2.  侧翼区域，由左侧翼 $F_{\\text{left}} = \\{i \\in \\mathbb{Z} \\mid \\max(0, s-m) \\leq i \\leq s-1\\}$ 和右侧翼 $F_{\\text{right}} = \\{i \\in \\mathbb{Z} \\mid e+1 \\leq i \\leq \\min(L-1, e+m)\\}$ 组成。合并的侧翼集合是 $F = F_{\\text{left}} \\cup F_{\\text{right}}$。其大小为 $|F| = |F_{\\text{left}}| + |F_{\\text{right}}|$。\n3.  用于偏好归一化的总感兴趣区域，$R = C \\cup F$。\n\n第二，我们计算在每个位置 $i \\in R$ 的序列依赖性转座酶偏好。这是一个两阶段的过程。我们首先为每个位置 $i \\in R$ 计算一个未归一化的偏好 $\\tilde{b}_i$。该偏好使用 $k$-mer 进行建模，在本问题中 $k=3$。对于每个位置 $i$，从序列中提取一个以 $i$ 为中心的 3-mer $u(i)$。这对应于从索引 $i-1$ 到 $i+1$ 的子字符串。如果 $i-1  0$ 或 $i+1 \\ge L$，则该 $k$-mer 超出边界。未归一化的偏好由下式给出：\n$$ \\tilde{b}_i = \\exp(w_{u(i)}) $$\n其中 $w_{u(i)}$ 是与 $k$-mer $u(i)$ 相关联的权重。如果 $u(i)$ 不在提供的权重字典中或超出边界，其权重被视为 $w_{u(i)}=0$，这意味着 $\\tilde{b}_i = \\exp(0) = 1$。\n\n接下来，对未归一化的偏好值进行归一化，使其在感兴趣区域 $R$ 上的均值为 1。未归一化的平均偏好为 $\\bar{\\tilde{b}}_R = \\frac{1}{|R|}\\sum_{j \\in R} \\tilde{b}_j$。然后，每个位置 $i \\in R$ 的归一化偏好为：\n$$ b_i = \\frac{\\tilde{b}_i}{\\bar{\\tilde{b}}_R} $$\n\n第三，我们对观测到的插入计数 $c_i$ 进行序列依赖性偏好校正。模型假定预期计数与可及性和偏好的乘积成正比，即 $\\lambda_i \\propto a_i b_i$。通过将观测计数 $c_i$ 除以归一化偏好 $b_i$，我们得到一个校正后的计数 $\\tilde{c}_i = \\frac{c_i}{b_i}$，它作为局部可及性的估计量（相差一个缩放因子）。为了数值稳定性，添加一个小的伪计数 $\\epsilon = 10^{-6}$：\n$$ \\tilde{c}_i^{(\\epsilon)} = \\tilde{c}_i + \\epsilon = \\frac{c_i}{b_i} + \\epsilon $$\n此计算对所有位置 $i \\in R$ 执行。\n\n最后，计算足迹分数 $S$。该分数定义为侧翼区域的平均校正计数与基序中心区域的平均校正计数的比率。该比率量化了基序内部插入的相对耗尽，这是由结合蛋白留下的“足迹”。分数计算如下：\n$$ S = \\frac{\\frac{1}{|F|}\\sum_{i \\in F} \\tilde{c}_i^{(\\epsilon)}}{\\frac{1}{|C|}\\sum_{i \\in C} \\tilde{c}_i^{(\\epsilon)}} $$\n伪计数 $\\epsilon > 0$ 确保分母始终为正，即使中心区域的所有计数均为 0，也能防止除以零的错误。\n\n该实现将系统地将这四个步骤应用于提供的每个测试用例，得出一个数值分数 $S$，并按要求进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the chromatin accessibility footprint score for given test cases.\n    The implementation follows the mathematical model specified in the problem.\n    \"\"\"\n    # Define constants and parameters globally from the problem statement.\n    weights = {\n        'AAA': -0.4, 'TTT': -0.4, 'GGG': 0.6, 'CCC': 0.6,\n        'ACG': 0.3, 'CGT': 0.3, 'GCG': 0.5, 'CGC': 0.5,\n        'CCG': 0.4, 'GCC': 0.4, 'AGG': 0.3, 'GGA': 0.3,\n        'CAG': 0.2, 'GTT': -0.2, 'CAT': -0.2, 'ATC': -0.1,\n        'TAC': -0.1, 'CGG': 0.5, 'GGC': 0.5\n    }\n    epsilon = 1e-6\n    k = 3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"seq\": \"ACGTACGTACGGGCCCTTTACGTACGTAC\",\n            \"counts\": np.array([4, 5, 4, 5, 3, 4, 5, 8, 9, 7, 10, 9, 2, 1, 3, 2, 1, 2, 8, 7, 9, 10, 8, 4, 5, 4, 5, 3, 4, 5]),\n            \"s\": 12, \"e\": 17, \"m\": 5\n        },\n        {\n            \"seq\": \"GGGACGTACGTACGTACGTACGTT\",\n            \"counts\": np.array([7, 8, 7, 1, 2, 1, 1, 8, 7, 9, 5, 4, 6, 5, 4, 5, 6, 5, 4, 5, 4, 6, 5, 4]),\n            \"s\": 3, \"e\": 6, \"m\": 3\n        },\n        {\n            \"seq\": \"AAAAAGGGCCCACGTACGTAAAAA\",\n            \"counts\": np.array([5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]),\n            \"s\": 5, \"e\": 10, \"m\": 4\n        },\n        {\n            \"seq\": \"ACGTACGTACGTACGTACGT\",\n            \"counts\": np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n            \"s\": 8, \"e\": 11, \"m\": 3\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        seq = case[\"seq\"]\n        counts = case[\"counts\"]\n        s, e, m = case[\"s\"], case[\"e\"], case[\"m\"]\n        L = len(seq)\n        \n        # Step 1: Define Regions\n        C_indices = list(range(s, e + 1))\n        F_left_indices = list(range(max(0, s - m), s))\n        F_right_indices = list(range(e + 1, min(L, e + m + 1)))\n        F_indices = F_left_indices + F_right_indices\n        R_indices = sorted(list(set(C_indices + F_indices)))\n        \n        # Step 2: Calculate Unnormalized Bias\n        b_tilde = {}\n        half_k = k // 2\n        for i in R_indices:\n            start, end = i - half_k, i + half_k + 1\n            if start >= 0 and end = L:\n                kmer = seq[start:end]\n                weight = weights.get(kmer, 0.0)\n                b_tilde[i] = np.exp(weight)\n            else:\n                # Boundary condition: if k-mer cannot be extracted, weight is 0.\n                b_tilde[i] = 1.0  # np.exp(0)\n        \n        # Step 3: Normalize Bias\n        b_tilde_R_values = np.array([b_tilde[i] for i in R_indices])\n        if len(b_tilde_R_values) == 0:\n            mean_b_tilde_R = 1.0\n        else:\n            mean_b_tilde_R = np.mean(b_tilde_R_values)\n        \n        # Guard against division by zero, though exp() > 0 means mean_b_tilde_R > 0\n        if mean_b_tilde_R == 0: mean_b_tilde_R = 1.0\n\n        b = {i: b_tilde[i] / mean_b_tilde_R for i in R_indices}\n        \n        # Step 4-5: Calculate Corrected Counts and Final Score\n        \n        # Calculate mean corrected count for the Center region (C)\n        c_tilde_eps_C_values = []\n        for i in C_indices:\n            c_i = counts[i]\n            b_i = b[i]\n            # The problem definition implies b_i is never zero.\n            c_tilde_eps = (c_i / b_i) + epsilon\n            c_tilde_eps_C_values.append(c_tilde_eps)\n        \n        mean_C = np.mean(c_tilde_eps_C_values) if c_tilde_eps_C_values else epsilon\n        \n        # Calculate mean corrected count for the Flanking region (F)\n        c_tilde_eps_F_values = []\n        for i in F_indices:\n            c_i = counts[i]\n            b_i = b[i]\n            c_tilde_eps = (c_i / b_i) + epsilon\n            c_tilde_eps_F_values.append(c_tilde_eps)\n\n        mean_F = np.mean(c_tilde_eps_F_values) if c_tilde_eps_F_values else epsilon\n\n        # Compute the final footprint score S\n        # Denominator mean_C is guaranteed to be > 0 because epsilon > 0\n        score = mean_F / mean_C\n        results.append(score)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4314918"}]}