{"hands_on_practices": [{"introduction": "在分析空间转录组数据以识别组织结构域之前，首要任务是理解测量技术本身的物理和信息论限制。本练习将引导你结合信号处理和光学的基本原理，例如卷积、高斯模糊和奈奎斯特定理，来推导空间分辨率的关键约束。通过解决这个问题 [@problem_id:4354059]，你将深入理解在实验设计中，捕获点直径、分子扩散和采样密度之间存在的根本性权衡。", "problem": "一种空间转录组学平台使用一个规则排列的圆形捕获点阵列，捕获点的直径为 $S$，排列间距 $p$ 等于点的直径（即 $p = S$，因此捕获点不重叠）。在一个组织切片中，考虑两个相邻的空间域，它们沿一维横截线的质心之间的中心距为 $d$（单位为微米）。捕获过程中的分子分配和扩散会引入模糊，这可以近似为一个标准差为 $\\sigma_{b}$（单位为微米）的高斯点扩散函数（PSF）。每个捕获点在其区域内整合 RNA 计数；沿横截线，将此整合建模为一个宽度为 $S$ 的一维矩形平均核。\n\n从线性系统和采样的第一性原理出发：\n\n- 独立核的卷积会使方差相加，因此沿横截线的有效 PSF 标准差 $\\sigma_{\\mathrm{eff}}$ 由高斯模糊方差和矩形核方差之和的平方根给出。\n- 成像中一个广泛使用的分辨率判据指出，当两个与标准差为 $\\sigma_{\\mathrm{eff}}$ 的高斯函数卷积后的相同峰值的分离距离等于 $2 \\sigma_{\\mathrm{eff}}$ 时，它们恰好可分辨。\n- 香农-奈奎斯特采样定理要求，为了分辨尺度为 $d$ 的特征，采样间距 $p$ 必须满足 $p \\leq d/2$。\n\n假设 $d  2 \\sigma_{b}$，以便在模糊后物理上仍可能实现分辨。仅使用上述原理和事实，推导出一个封闭形式的解析表达式，表示在给定分离距离 $d$ 和模糊 $\\sigma_{b}$ 的情况下，仍能保证分辨两个相邻域的最大允许捕获点直径 $S_{\\max}$（单位为微米）。这个 $S_{\\max}$ 是由分辨率限制施加在 $S$ 上的严格上限，因此它表征了平台的最小捕获点直径要求，即为了分辨这些域，$S$ 不得超过 $S_{\\max}$。\n\n将你的最终答案表示为关于 $d$ 和 $\\sigma_{b}$ 的单个解析表达式。不需要进行数值计算。", "solution": "我们将穿过两个相邻域边界的一维横截线上的测量信号建模为真实的底层空间信号与两个核的卷积：一个代表分子扩散和错误分配的高斯模糊核，以及一个代表捕获点整合的矩形平均核。两个方差分别为 $\\sigma_{1}^{2}$ 和 $\\sigma_{2}^{2}$ 的独立核的卷积，其有效方差等于方差之和 $\\sigma_{1}^{2} + \\sigma_{2}^{2}$，因为在概率解释中，卷积对应于独立随机变量的和。\n\n首先，我们确定由矩形平均核贡献的方差。一个宽度为 $S$、单位面积的一维矩形（均匀）核具有概率密度函数\n$$\nu(x) = \\begin{cases}\n\\frac{1}{S},  |x| \\leq \\frac{S}{2}, \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n在区间 $\\left[-\\frac{S}{2}, \\frac{S}{2}\\right]$ 上的均匀分布的方差是\n$$\n\\sigma_{\\mathrm{rect}}^{2} = \\frac{S^{2}}{12}.\n$$\n高斯模糊被建模为一个零均值的高斯核，其方差为 $\\sigma_{b}^{2}$（标准差为 $\\sigma_{b}$）。因此，在将高斯模糊与矩形平均核进行卷积后，沿横截线的有效 PSF 标准差为\n$$\n\\sigma_{\\mathrm{eff}} = \\sqrt{\\sigma_{b}^{2} + \\sigma_{\\mathrm{rect}}^{2}} = \\sqrt{\\sigma_{b}^{2} + \\frac{S^{2}}{12}}.\n$$\n\n接下来，我们引用一个经过充分检验的高斯限制系统的可分辨性判据：当两个相同峰值的中心距等于高斯 PSF 标准差的两倍时，它们恰好可分辨。这个针对高斯响应的类瑞利判据是\n$$\nd_{\\mathrm{R}} = 2 \\sigma_{\\mathrm{eff}}.\n$$\n为确保相距为 $d$ 的两个相邻域的可分辨性，我们要求\n$$\nd \\geq 2 \\sigma_{\\mathrm{eff}} = 2 \\sqrt{\\sigma_{b}^{2} + \\frac{S^{2}}{12}}.\n$$\n对该不等式求解 $S$ 可得到捕获点直径的上限。两边平方：\n$$\nd^{2} \\geq 4 \\left( \\sigma_{b}^{2} + \\frac{S^{2}}{12} \\right) = 4 \\sigma_{b}^{2} + \\frac{S^{2}}{3}.\n$$\n重新整理以分离出 $S^{2}$：\n$$\n\\frac{S^{2}}{3} \\leq d^{2} - 4 \\sigma_{b}^{2} \\quad \\Longrightarrow \\quad S^{2} \\leq 3 \\left( d^{2} - 4 \\sigma_{b}^{2} \\right).\n$$\n因此，高斯可分辨性约束得出\n$$\nS \\leq \\sqrt{3 \\left( d^{2} - 4 \\sigma_{b}^{2} \\right)}.\n$$\n这个约束仅在 $d^{2} - 4 \\sigma_{b}^{2}  0$ 时有意义，即 $d  2 \\sigma_{b}$，这是已假设的条件。\n\n除了基于模糊的可分辨性，我们还必须确保捕获点阵列的采样不会对尺度为 $d$ 的特征产生混叠。香农-奈奎斯特采样定理规定，为了分辨尺度为 $d$ 的特征，采样间距 $p$ 必须满足\n$$\np \\leq \\frac{d}{2}.\n$$\n由于平台使用的间距等于捕获点直径（$p = S$），这可转化为\n$$\nS \\leq \\frac{d}{2}.\n$$\n\n为了让系统能够分辨相邻的域，两个独立的约束必须同时满足。因此，最大允许捕获点直径 $S_{\\max}$ 是两个上限中的最小值：\n$$\nS_{\\max}(d, \\sigma_{b}) = \\min \\left( \\frac{d}{2}, \\, \\sqrt{3 \\left( d^{2} - 4 \\sigma_{b}^{2} \\right)} \\right).\n$$\n这个表达式给出了由分辨率约束（高斯限制的可分辨性和奈奎斯特采样）施加在捕获点直径上的严格上限。为保证可分辨性，平台必须选择 $S$ 以满足 $S \\leq S_{\\max}(d, \\sigma_{b})$。由于问题要求的是仍能保证分辨率的最大允许捕获点直径，因此所求的解析表达式正是 $S_{\\max}(d, \\sigma_{b})$。", "answer": "$$\\boxed{\\min\\!\\left(\\frac{d}{2},\\,\\sqrt{3\\left(d^{2}-4\\sigma_{b}^{2}\\right)}\\right)}$$", "id": "4354059"}, {"introduction": "获取空间数据后，下一步是建立能够捕捉其底层空间结构的稳健统计模型。本练习将向你介绍高斯马尔可夫随机场 (GMRF) 和条件自回归 (CAR) 模型，它们是空间统计分析的基石。通过推导并编程实现该模型的精度矩阵 [@problem_id:4354044]，你将亲身体验如何将组织的物理邻接关系（邻接图）转化为数学形式，以模拟基因表达等空间依赖性数据。", "problem": "考虑一个用于系统生物医学中组织结构的空间模型，其中组织位置（例如，斑点或细胞）表示为图上的节点，该图捕捉了物理邻接关系。设邻接关系由一个对称的、非负的加权矩阵 $W \\in \\mathbb{R}^{n \\times n}$ 编码，其中 $w_{ii} = 0$ 且 $w_{ij} = w_{ji} \\ge 0$。将节点 $i$ 的度定义为 $d_i = \\sum_{j=1}^{n} w_{ij}$，度矩阵为 $D = \\operatorname{diag}(d_1,\\dots,d_n)$。考虑通过条件自回归（CAR）模型指定的高斯马尔可夫随机场（GMRF）先验：对于每个节点 $i$，其全条件分布为\n$$\nx_i \\mid x_{-i} \\sim \\mathcal{N}\\left(\\mu_i, \\sigma_i^2\\right),\n\\quad \\text{with} \\quad\n\\mu_i = \\frac{\\rho}{d_i} \\sum_{j \\neq i} w_{ij} x_j,\n\\quad\n\\sigma_i^2 = \\frac{1}{\\tau d_i},\n$$\n其中 $\\tau  0$ 是一个标量精度参数，$\\rho \\in [0,1]$ 是一个空间平滑参数（$\\rho = 1$ 对应于内在CAR，$\\rho  1$ 在适当的谱界下对应于正常CAR）。从多元正态分布的正则精度形式的基本定义和高斯条件分布的结构出发，推导出由上述CAR条件所隐含的GMRF的联合精度矩阵 $Q \\in \\mathbb{R}^{n \\times n}$。利用此推导，实现一个算法，该算法在给定 $(W, \\tau, \\rho)$ 的情况下，构造 $Q$，然后评估 $Q$ 的稀疏模式与由 $W$ 定义的组织邻接图的关系。\n\n您的程序必须为每个测试用例 $(W, \\tau, \\rho)$ 执行以下任务：\n1. 计算由CAR规范所隐含的精度矩阵 $Q$。\n2. 验证 $Q$ 的非对角线稀疏模式是否与 $W$ 的邻接模式匹配，即检查对于所有 $i \\neq j$，$Q_{ij} \\neq 0$ 当且仅当 $w_{ij} \\neq 0$。返回一个布尔值。\n3. 计算 $Q$ 中数值上非零项的总数（包括对角线），对绝对值使用 $10^{-12}$ 的数值容差。返回一个整数。\n4. 通过验证所有特征值是否严格大于 $10^{-12}$ 来确定 $Q$ 是否为正定矩阵。返回一个布尔值。\n5. 通过计算小于或等于 $10^{-10}$ 的特征值数量来计算 $Q$ 的零度（零空间的维度）。返回一个整数。\n\n推导中使用的基本原理：\n- 多元正态分布的正则（精度）形式：具有精度矩阵 $Q$ 的GMRF的密度为 $p(x) \\propto \\exp\\left(-\\frac{1}{2} x^\\top Q x\\right)$，对于一个有效的分布，$Q$ 是对称半正定矩阵。\n- 高斯条件分布在精度矩阵方面的结构：对于具有精度矩阵 $Q$ 的联合正态分布，$x_i$ 给定 $x_{-i}$ 的条件分布是高斯分布，其方差为 $1/Q_{ii}$，均值等于 $x_{-i}$ 的线性组合，系数由 $Q$ 的非对角线项和 $Q_{ii}$ 决定。\n- 条件独立性与精度矩阵中零元素的关系：$Q_{ij} = 0$ 意味着在给定所有其他节点的情况下，节点 $i$ 和 $j$ 是条件独立的。\n\n测试套件：\n- 案例A（连通，正常CAR）：$W$ 是具有4-邻域邻接的无权 $3 \\times 3$ 网格，$\\tau = 2.0$，$\\rho = 0.4$。\n- 案例B（连通，内在CAR）：$W$ 是相同的 $3 \\times 3$ 网格，$\\tau = 1.0$，$\\rho = 1.0$。\n- 案例C（不连通，内在CAR）：$W$ 是由两个不相交的无权 $2 \\times 2$ 网格（每个都具有4-邻域邻接）组成的块对角邻接矩阵，$\\tau = 1.0$，$\\rho = 1.0$。\n- 案例D（加权链，正常CAR）：$W$ 是长度为 $5$ 的一维链，边为 $(1,2)$, $(2,3)$, $(3,4)$, $(4,5)$，单位权重，除了一个弱边界 $w_{2,3} = 0.2$，$\\tau = 1.5$，$\\rho = 0.9$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个测试用例贡献一个形式为 $[\\text{布尔值},\\text{整数},\\text{布尔值},\\text{整数}]$ 的列表。因此，总输出是一个列表的列表，形式为\n$$\n[\\,[b_1,i_1,b_2,i_2],\\,[b_1',i_1',b_2',i_2'],\\,\\ldots\\,].\n$$", "solution": "目标是推导由条件自回归（CAR）模型指定的高斯马尔可夫随机场（GMRF）的联合精度矩阵 $Q$，并随后基于组织邻接图结构分析 $Q$ 的性质。\n\n### 1. 精度矩阵 $Q$ 的推导\n\n推导从多元正态分布的正则形式的基本定义开始。对于一个随机向量 $x \\in \\mathbb{R}^n$，零均值GMRF的概率密度函数（PDF）由下式给出：\n$$\np(x) \\propto \\exp\\left(-\\frac{1}{2} x^\\top Q x\\right)\n$$\n其中 $Q \\in \\mathbb{R}^{n \\times n}$ 是对称、半正定的精度矩阵。该矩阵的结构编码了变量之间的条件独立关系。\n\n为了找到单个变量 $x_i$ 在给定所有其他变量 $x_{-i} = (x_1, \\dots, x_{i-1}, x_{i+1}, \\dots, x_n)^\\top$ 的情况下的全条件分布，我们检查二次型 $x^\\top Q x$ 中涉及 $x_i$ 的项。\n$$\nx^\\top Q x = \\sum_{k=1}^n \\sum_{l=1}^n Q_{kl} x_k x_l = Q_{ii} x_i^2 + 2x_i \\sum_{j \\neq i} Q_{ij} x_j + \\sum_{k \\neq i, l \\neq i} Q_{kl} x_k x_l\n$$\n涉及 $x_i$ 的项是 $Q_{ii} x_i^2 + 2x_i \\sum_{j \\neq i} Q_{ij} x_j$。条件PDF $p(x_i | x_{-i})$ 与 $\\exp(-\\frac{1}{2} (Q_{ii} x_i^2 + 2x_i \\sum_{j \\neq i} Q_{ij} x_j))$ 成正比。我们可以对 $x_i$ 进行配方：\n$$\nQ_{ii} x_i^2 + 2x_i \\sum_{j \\neq i} Q_{ij} x_j = Q_{ii} \\left( x_i^2 + 2x_i \\frac{\\sum_{j \\neq i} Q_{ij} x_j}{Q_{ii}} \\right) = Q_{ii} \\left( x_i + \\frac{\\sum_{j \\neq i} Q_{ij} x_j}{Q_{ii}} \\right)^2 - \\text{不涉及 } x_i \\text{ 的项}\n$$\n因此，条件分布 $p(x_i|x_{-i})$ 是一个高斯分布，其参数为：\n- 条件均值：$E[x_i | x_{-i}] = -\\frac{1}{Q_{ii}} \\sum_{j \\neq i} Q_{ij} x_j$\n- 条件方差：$\\operatorname{Var}(x_i | x_{-i}) = \\frac{1}{Q_{ii}}$\n\n接下来，我们将这些一般形式与CAR模型提供的特定条件分布进行等同：\n$$\nx_i \\mid x_{-i} \\sim \\mathcal{N}\\left(\\mu_i, \\sigma_i^2\\right)\n\\quad \\text{with} \\quad\n\\mu_i = \\frac{\\rho}{d_i} \\sum_{j \\neq i} w_{ij} x_j\n\\quad \\text{and} \\quad\n\\sigma_i^2 = \\frac{1}{\\tau d_i}\n$$\n其中 $d_i = \\sum_{j=1}^n w_{ij}$。\n\n通过比较条件方差，我们找到 $Q$ 的对角线元素：\n$$\n\\frac{1}{Q_{ii}} = \\sigma_i^2 = \\frac{1}{\\tau d_i} \\implies Q_{ii} = \\tau d_i\n$$\n\n通过比较条件均值，我们找到 $Q$ 的非对角线元素：\n$$\n-\\frac{1}{Q_{ii}} \\sum_{j \\neq i} Q_{ij} x_j = \\mu_i = \\frac{\\rho}{d_i} \\sum_{j \\neq i} w_{ij} x_j\n$$\n代入 $Q_{ii} = \\tau d_i$：\n$$\n-\\frac{1}{\\tau d_i} \\sum_{j \\neq i} Q_{ij} x_j = \\frac{\\rho}{d_i} \\sum_{j \\neq i} w_{ij} x_j\n$$\n两边乘以 $-\\tau d_i$ 得：\n$$\n\\sum_{j \\neq i} Q_{ij} x_j = -\\tau \\rho \\sum_{j \\neq i} w_{ij} x_j\n$$\n由于这对任何向量 $x_{-i}$ 都必须成立，因此两边每个 $x_j$（对于 $j \\neq i$）的系数必须相等：\n$$\nQ_{ij} = -\\tau \\rho w_{ij} \\quad \\text{for } i \\neq j\n$$\n\n结合对角线和非对角线项的结果，我们可以用矩阵形式表示精度矩阵 $Q$。设 $D = \\operatorname{diag}(d_1, \\dots, d_n)$ 为对角度矩阵，$W$ 为邻接矩阵。精度矩阵为：\n$$\nQ = \\tau (D - \\rho W)\n$$\n这个推导提供了一个直接的公式，可以从给定的模型参数 $W$、$\\tau$ 和 $\\rho$ 来构造 $Q$。\n\n### 2. 算法流程与性质分析\n\n基于推导出的 $Q$ 的公式，我们可以系统地解决问题的各项任务。\n\n**任务1：计算精度矩阵 $Q$。**\n算法很简单：给定矩阵 $W$ 和标量 $\\tau$、$\\rho$，首先计算每个节点的度 $d_i = \\sum_{j} w_{ij}$ 以形成对角矩阵 $D$。然后，使用公式 $Q = \\tau (D - \\rho W)$ 计算 $Q$。\n\n**任务2：验证稀疏模式。**\n$Q$ 的非对角线项由 $Q_{ij} = -\\tau \\rho w_{ij}$（$i \\neq j$）给出。问题陈述 $\\tau  0$ 和 $\\rho \\in [0, 1]$。对于测试用例，$\\rho  0$。因此，一个非对角线项 $Q_{ij}$ 非零当且仅当 $w_{ij}$ 也非零。这证实了精度矩阵 $Q$ 的非对角线稀疏模式与邻接矩阵 $W$ 的稀疏模式相同。这是GMRF的一个标志性属性，其中精度矩阵中的零项对应于条件独立性。\n\n**任务3：计算 $Q$ 中数值上的非零项数量。**\n由于 $Q_{ii} = \\tau d_i$，并且对于任何连通节点，$d_i  0$ 且 $\\tau  0$，因此 $Q$ 的所有对角线项都将非零。非零的非对角线项直接对应于 $W$ 中的非零项。因此，总数是 $n$（对角线项）加上 $W$ 中非零非对角线项的数量，这是图中边数的两倍。实现时将计算绝对值大于容差 $10^{-12}$ 的所有 $Q$ 的项。\n\n**任务4和5：确定正定性和零度。**\n这些性质通过分析 $Q$ 的特征值来确定。由于 $Q$ 是对称的（$D$ 是对角阵，$W$ 是对称的），其所有特征值都是实数。\n- **正定性**：如果 $Q$ 的所有特征值都严格为正，则 $Q$ 是正定的。算法将检查所有特征值是否大于容差 $10^{-12}$。\n- **零度**：$Q$ 的零度是其零空间的维度，等于零特征值的数量。在数值上，这被计算为小于或等于容差 $10^{-10}$ 的特征值的数量。\n\n$Q$ 的性质严重依赖于参数 $\\rho$：\n- 如果 $\\rho = 1$（内在CAR），$Q = \\tau(D-W) = \\tau L$，其中 $L$ 是图拉普拉斯算子。已知 $L$ 是半正定的。$L$ 的零度等于由 $W$ 定义的图中的连通分量数量。对于一个连通图，零度为 $1$，此时 $Q$ 不是正定的。\n- 如果 $\\rho  1$（正常CAR）且图是连通的，$Q$ 通常是正定的，前提是 $\\rho$ 满足与 $W$ 和 $D$ 相关的某些谱界。对于给定的 $\\rho  1$ 的测试用例，这些条件得到满足，从而得到一个正定的 $Q$ 和零度为零。\n\n这个框架使我们能够将抽象的CAR模型规范转化为具体的矩阵 $Q$，并分析其与底层邻接图相关的结构和数学性质。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_grid_adjacency(height, width):\n    \"\"\"\n    Constructs an unweighted adjacency matrix for a grid graph with 4-neighborhood.\n    \"\"\"\n    n = height * width\n    W = np.zeros((n, n))\n    for r in range(height):\n        for c in range(width):\n            i = r * width + c\n            # Horizontal connection to the right\n            if c  width - 1:\n                j = i + 1\n                W[i, j] = W[j, i] = 1\n            # Vertical connection downwards\n            if r  height - 1:\n                j = i + width\n                W[i, j] = W[j, i] = 1\n    return W\n\ndef process_case(W, tau, rho):\n    \"\"\"\n    Performs all required computations for a single test case.\n    \"\"\"\n    n = W.shape[0]\n\n    # Task 1: Compute the precision matrix Q\n    d = W.sum(axis=1)\n    D = np.diag(d)\n    Q = tau * (D - rho * W)\n\n    # Task 2: Verify the off-diagonal sparsity pattern\n    # The derivation Q_ij = -tau * rho * w_ij shows that for tau, rho > 0,\n    # the off-diagonal sparsity patterns must match. We verify this numerically.\n    q_is_nonzero_offdiag = np.abs(Q) > 1e-12\n    np.fill_diagonal(q_is_nonzero_offdiag, False)\n    w_is_nonzero = np.abs(W) > 1e-12\n    # w_ii is given as 0, so no need to touch the diagonal for W\n    sparsity_match = np.all(q_is_nonzero_offdiag == w_is_nonzero)\n\n    # Task 3: Count the total number of numerically nonzero entries of Q\n    nonzero_count = int(np.sum(np.abs(Q) > 1e-12))\n\n    # For tasks 4 and 5, compute the eigenvalues of Q.\n    # Q is real and symmetric, so its eigenvalues are real. np.linalg.eigvalsh is efficient and stable.\n    eigenvalues = np.linalg.eigvalsh(Q)\n    \n    # Task 4: Determine whether Q is positive definite\n    is_pd = np.all(eigenvalues > 1e-12)\n\n    # Task 5: Compute the nullity (dimension of the null space) of Q\n    nullity = int(np.sum(eigenvalues = 1e-10))\n\n    return [sparsity_match, nonzero_count, is_pd, nullity]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run them, and print the results.\n    \"\"\"\n    # Case A: 3x3 grid, proper CAR\n    W_A = build_grid_adjacency(3, 3)\n    case_A = (W_A, 2.0, 0.4)\n\n    # Case B: 3x3 grid, intrinsic CAR\n    W_B = build_grid_adjacency(3, 3)\n    case_B = (W_B, 1.0, 1.0)\n\n    # Case C: Two disjoint 2x2 grids, intrinsic CAR\n    W_2x2 = build_grid_adjacency(2, 2)\n    W_C = np.block([\n        [W_2x2, np.zeros((4, 4))],\n        [np.zeros((4, 4)), W_2x2]\n    ])\n    case_C = (W_C, 1.0, 1.0)\n    \n    # Case D: Weighted chain, proper CAR.\n    # Nodes are 0-indexed: 0, 1, 2, 3, 4.\n    # The problem statement says w_{2,3}=0.2, which in 1-based indexing is the\n    # edge between node 2 and 3. This corresponds to the edge (1,2) in 0-based indexing.\n    W_D = np.zeros((5, 5))\n    edges = [(0, 1, 1.0), (1, 2, 0.2), (2, 3, 1.0), (3, 4, 1.0)]\n    for i, j, w in edges:\n        W_D[i, j] = W_D[j, i] = w\n    case_D = (W_D, 1.5, 0.9)\n\n    test_cases = [case_A, case_B, case_C, case_D]\n\n    results = []\n    for W_case, tau_case, rho_case in test_cases:\n        result = process_case(W_case, tau_case, rho_case)\n        results.append(result)\n\n    # Format the final output string to match the problem specification\n    # e.g., [[true,33,true,0],[true,33,false,1],...]\n    formatted_results = []\n    for res in results:\n        # Convert python boolean True/False to lowercase true/false\n        b1_str = str(res[0]).lower()\n        i1 = res[1]\n        b2_str = str(res[2]).lower()\n        i2 = res[3]\n        formatted_results.append(f\"[{b1_str},{i1},{b2_str},{i2}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4354044"}, {"introduction": "本章的最终练习旨在追求对组织模式形成的深层机制性理解，代表了从统计推断到生物物理模拟的飞跃。本练习利用连续介质力学和有限元方法，模拟了由不均匀生长引起的机械应力如何能够自发地形成组织域的边界。通过完成这项计算任务 [@problem_id:4354088]，你将洞悉物理力与材料属性是如何共同塑造我们观察到的复杂生物结构的。", "problem": "考虑一个薄的、均匀的弹性片，占据无量纲单位下的单位正方形区域 $\\Omega = [0,1] \\times [0,1]$。该薄片经历空间变化的生长，该生长被建模为一个叠加在微小弹性变形上的特征应变（生长应变）场 $\\boldsymbol{\\varepsilon}^{g}(\\mathbf{x})$。目标是利用简单的有限元（FE）离散化方法，识别由生长场引起的弹性能力密度梯度所产生的薄片内预测的空间域边界。\n\n基本和核心定义：\n- 假设薄片处于小应变、线性各向同性平面应力状态。在每个线性三角形单元内，应变-位移关系为 $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\mathbf{B}\\,\\mathbf{u}_{e}$，其中 $\\mathbf{B}$ 是由形函数梯度构建的标准应变-位移矩阵，$\\mathbf{u}_{e}$ 是单元的节点位移向量。\n- 平面应力状态下，以福格特（Voigt）表示法的弹性本构关系为 $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}^{e}$，其中 $\\boldsymbol{\\varepsilon}^{e} = \\boldsymbol{\\varepsilon}(\\mathbf{u}) - \\boldsymbol{\\varepsilon}^{g}$ 是弹性应变，且\n$$\n\\mathbf{D} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1  \\nu  0 \\\\\n\\nu  1  0 \\\\\n0  0  \\frac{1-\\nu}{2}\n\\end{bmatrix},\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。\n- 单元内的总弹性能力密度为\n$$\nw = \\frac{1}{2}\\,\\boldsymbol{\\varepsilon}^{e\\,\\top} \\mathbf{D}\\, \\boldsymbol{\\varepsilon}^{e}.\n$$\n- 有限元平衡方程通过在狄利克雷（Dirichlet）边界条件下最小化弹性能力泛函 $\\Pi(\\mathbf{u}) = \\frac{1}{2}\\int_{\\Omega} \\boldsymbol{\\varepsilon}^{e\\,\\top} \\mathbf{D}\\, \\boldsymbol{\\varepsilon}^{e}\\, \\mathrm{d}\\Omega$ 得到。在离散情况下，这产生一个线性系统 $\\mathbf{K}\\,\\mathbf{u} = \\mathbf{f}$，其中 $\\mathbf{K}$ 是由单元贡献组装的全局刚度矩阵，由生长引起的等效节点载荷向量为\n$$\n\\mathbf{f} = \\sum_{e} t\\,A_{e}\\,\\mathbf{B}^{\\top}\\mathbf{D}\\,\\boldsymbol{\\varepsilon}^{g}_{e},\n$$\n其中 $t$ 是薄片厚度，$A_{e}$ 是单元面积。通过在左边界 $x=0$ 上的所有节点施加零位移来固定薄片，以消除刚体模式。\n\n域边界识别原则：\n- 空间域边界在操作上定义为弹性能力密度 $w$ 在其上出现大跳跃的内部网格边。令 $\\Delta w_{ij} = \\left| w_{i} - w_{j} \\right|$ 表示共享一条内部边的两个相邻三角形之间 $w$ 的绝对差。对于给定的阈值因子 $\\tau  0$，如果一条内部边满足 $\\Delta w_{ij}  \\tau \\cdot \\mathrm{median}\\left(\\{ \\Delta w_{kl} \\}_{\\text{all interior edges}}\\right)$，则将其分类为预测的域边界。这种基于中位数的方法对于 $w$ 的尺度变化具有鲁棒性。\n\n数值离散化要求：\n- 用一个 $N_x \\times N_y$ 个节点的均匀结构化网格离散化 $\\Omega$，并使用标准连接方式将每个矩形单元细分为两个线性三角形。使用在单元形心处计算的单元常数 $\\boldsymbol{\\varepsilon}^{g}_{e}$。取薄片厚度 $t=1$（无量纲）。\n- 使用材料参数 $E=1$ 和 $\\nu=0.3$（无量纲），并对所有 $x=0$ 的节点施加狄利克雷（Dirichlet）边界条件 $\\mathbf{u}=(0,0)$。\n- 通过组装 $\\mathbf{K}$ 和 $\\mathbf{f}$ 并求解线性系统来计算位移场 $\\mathbf{u}$。计算每个单元的 $w$，使用上述阈值规则确定预测的域边界边集，并报告边界边的数量及其形心的 $x$ 坐标（被标记边的中点的平均值）。如果没有边被标记，则报告形心 $x$ 坐标为 $-1.0$。\n\n测试套件：\n- 案例1（均匀各向同性生长）：$N_x = 20$, $N_y = 20$, $\\tau = 3.0$, $\\boldsymbol{\\varepsilon}^{g}(x,y) = [0.01,\\,0.01,\\,0.0]$。\n- 案例2（带有内部界面的分段生长）：$N_x = 20$, $N_y = 20$, $\\tau = 3.0$, $\\boldsymbol{\\varepsilon}^{g}(x,y) = [0.008,\\,0.008,\\,0.0]$ 对于 $x  0.5$ 以及 $\\boldsymbol{\\varepsilon}^{g}(x,y) = [0.02,\\,0.0,\\,0.0]$ 对于 $x \\ge 0.5$。\n- 案例3（线性变化生长）：$N_x = 20$, $N_y = 20$, $\\tau = 3.0$, $\\boldsymbol{\\varepsilon}^{g}(x,y) = [0.03\\,x,\\,0.005,\\,0.0]$。\n\n答案规格：\n- 对于每个案例，计算预测的域边界边的整数数量，以及这些边的形心 $x$ 坐标，结果为浮点数，保留六位小数（无量纲）。最终输出必须是一行，包含一个逗号分隔的三个子列表的列表，每个子列表的格式为 $[N_{\\text{boundary}}, x_{\\text{centroid}}]$，并用方括号括起来，例如：$[[12,0.503000],[5,0.250000],[8,0.742000]]$。输出中不应包含任何单位。", "solution": "我们从薄片在平面应力下的小应变、线性弹性设置开始。核心定义建立了位移、应变和应力之间的关系，以及生长作为特征应变的角色。在福格特（Voigt）表示法中，平面应力的弹性本构矩阵为\n$$\n\\mathbf{D} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1  \\nu  0 \\\\\n\\nu  1  0 \\\\\n0  0  \\frac{1-\\nu}{2}\n\\end{bmatrix},\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。弹性应变通过从运动学应变中减去生长应变来定义，即 $\\boldsymbol{\\varepsilon}^{e} = \\boldsymbol{\\varepsilon}(\\mathbf{u}) - \\boldsymbol{\\varepsilon}^{g}$。\n\n基于原理的离散系统推导：\n- 总弹性能力为\n$$\n\\Pi(\\mathbf{u}) = \\frac{1}{2}\\int_{\\Omega} \\boldsymbol{\\varepsilon}^{e\\,\\top} \\mathbf{D}\\, \\boldsymbol{\\varepsilon}^{e}\\, \\mathrm{d}\\Omega\n= \\frac{1}{2}\\int_{\\Omega} (\\boldsymbol{\\varepsilon}(\\mathbf{u}) - \\boldsymbol{\\varepsilon}^{g})^{\\top} \\mathbf{D}\\, (\\boldsymbol{\\varepsilon}(\\mathbf{u}) - \\boldsymbol{\\varepsilon}^{g})\\, \\mathrm{d}\\Omega.\n$$\n应用驻定势能原理，我们对容许的虚位移 $\\delta \\mathbf{u}$ 取一阶变分 $\\delta \\Pi = 0$，经过标准步骤后，这会产生弱形式，在线性三角形单元的有限元离散化下，得到线性系统\n$$\n\\mathbf{K}\\,\\mathbf{u} = \\mathbf{f},\n$$\n其中全局刚度矩阵 $\\mathbf{K}$ 由单元贡献组装而成\n$$\n\\mathbf{K}_{e} = t\\,A_{e}\\,\\mathbf{B}^{\\top}\\mathbf{D}\\,\\mathbf{B},\n$$\n其中 $t$ 是厚度，$A_{e}$ 是单元面积，由生长应变引起的等效节点载荷为\n$$\n\\mathbf{f}_{e} = t\\,A_{e}\\,\\mathbf{B}^{\\top}\\mathbf{D}\\,\\boldsymbol{\\varepsilon}^{g}_{e}.\n$$\n这些表达式通过代入 $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\mathbf{B}\\,\\mathbf{u}_{e}$ 并注意到线性形函数在每个单元内产生恒定应变直接得出。符号约定源于最小化 $\\Pi(\\mathbf{u})$；交叉项积分为 $-\\int \\boldsymbol{\\varepsilon}^{g\\,\\top}\\mathbf{D}\\,\\boldsymbol{\\varepsilon}(\\mathbf{u})\\,\\mathrm{d}\\Omega$，其变分对等式右边产生一个正贡献。\n\n网格和单元算子：\n- 我们在 $\\Omega$ 上构建一个具有 $(x_{i}, y_{j})$ 节点的均匀 $N_x \\times N_y$ 结构化网格，并将每个矩形单元分割成两个三角形。对于每个节点位于 $(x_{1},y_{1})$、$(x_{2},y_{2})$、$(x_{3},y_{3})$ 的三角形单元，其面积为 $A_{e} = \\frac{1}{2}\\left| x_{1}(y_{2}-y_{3}) + x_{2}(y_{3}-y_{1}) + x_{3}(y_{1}-y_{2}) \\right|$。线性形函数的导数是常数：\n$$\n\\frac{\\partial N_{i}}{\\partial x} = \\frac{\\beta_{i}}{2A_{e}}, \\quad \\frac{\\partial N_{i}}{\\partial y} = \\frac{\\gamma_{i}}{2A_{e}},\n$$\n其中 $\\beta_{1} = y_{2} - y_{3}$，$\\beta_{2} = y_{3} - y_{1}$，$\\beta_{3} = y_{1} - y_{2}$ 以及 $\\gamma_{1} = x_{3} - x_{2}$，$\\gamma_{2} = x_{1} - x_{3}$，$\\gamma_{3} = x_{2} - x_{1}$。平面应力下以福格特（Voigt）形式表示的应变-位移矩阵 $\\mathbf{B}$ 为\n$$\n\\mathbf{B} =\n\\begin{bmatrix}\n\\frac{\\partial N_{1}}{\\partial x}  0  \\frac{\\partial N_{2}}{\\partial x}  0  \\frac{\\partial N_{3}}{\\partial x}  0 \\\\\n0  \\frac{\\partial N_{1}}{\\partial y}  0  \\frac{\\partial N_{2}}{\\partial y}  0  \\frac{\\partial N_{3}}{\\partial y} \\\\\n\\frac{\\partial N_{1}}{\\partial y}  \\frac{\\partial N_{1}}{\\partial x}  \\frac{\\partial N_{2}}{\\partial y}  \\frac{\\partial N_{2}}{\\partial x}  \\frac{\\partial N_{3}}{\\partial y}  \\frac{\\partial N_{3}}{\\partial x}\n\\end{bmatrix}.\n$$\n\n边界条件和求解：\n- 为了消除刚体模式，对所有 $x=0$ 的节点施加狄利克雷（Dirichlet）边界条件 $\\mathbf{u}=(0,0)$。在离散系统中，这是通过修改与固定自由度对应的行和列，并将这些自由度的对角线元素设置为1、右侧项设置为0来实现的。平衡位移向量 $\\mathbf{u}$ 随后通过求解 $\\mathbf{K}\\mathbf{u}=\\mathbf{f}$ 获得。\n\n能量密度计算：\n- 对每个单元，计算弹性应变\n$$\n\\boldsymbol{\\varepsilon}^{e}_{e} = \\mathbf{B}\\,\\mathbf{u}_{e} - \\boldsymbol{\\varepsilon}^{g}_{e},\n$$\n以及相应的弹性能力密度\n$$\nw_{e} = \\frac{1}{2}\\,\\boldsymbol{\\varepsilon}^{e\\,\\top}_{e}\\,\\mathbf{D}\\,\\boldsymbol{\\varepsilon}^{e}_{e}.\n$$\n\n预测的域边界：\n- 使用三角形连接性构建内部边集。对于由三角形 $i$ 和 $j$ 共享的任何内部边，计算 $\\Delta w_{ij} = |w_{i} - w_{j}|$。令 $m$ 为所有 $\\Delta w_{ij}$ 值的中位数（仅考虑内部边）。如果一条内部边满足 $\\Delta w_{ij}  \\tau \\cdot m$，则被标记为预测的域边界。域边界在 $x$ 方向上的形心计算为所有被标记边的中点的 $x$ 坐标的平均值。如果没有边被标记，则报告 $x_{\\text{centroid}} = -1.0$。\n\n测试套件实现细节：\n- 使用 $E=1$、$\\nu=0.3$ 和 $t=1$（均为无量纲）。所有案例均使用 $N_x=20$、$N_y=20$ 和 $\\tau=3.0$。\n- 生长应变场：\n  - 案例1：$\\boldsymbol{\\varepsilon}^{g}(x,y) = [0.01,\\,0.01,\\,0.0]$（均匀各向同性）。\n  - 案例2：$\\boldsymbol{\\varepsilon}^{g}(x,y) = [0.008,\\,0.008,\\,0.0]$ 对于 $x  0.5$ 以及 $\\boldsymbol{\\varepsilon}^{g}(x,y) = [0.02,\\,0.0,\\,0.0]$ 对于 $x\\ge 0.5$（带有内部界面的分段）。\n  - 案例3：$\\boldsymbol{\\varepsilon}^{g}(x,y) = [0.03\\,x,\\,0.005,\\,0.0]$（线性变化）。\n\n算法步骤摘要：\n- 生成网格和三角形连接性。\n- 使用形心处的 $\\mathbf{B}$ 和 $\\boldsymbol{\\varepsilon}^{g}_{e}$ 组装 $\\mathbf{K}$ 和 $\\mathbf{f}$。\n- 沿 $x=0$ 施加狄利克雷约束并求解 $\\mathbf{u}$。\n- 计算所有单元的 $w_{e}$。\n- 构建内部边邻接关系并计算所有内部边的 $\\Delta w_{ij}$。\n- 使用中位数阈值准则标记域边界边，并计算形心 $x$ 坐标。\n- 对每个案例，输出对 $[N_{\\text{boundary}}, x_{\\text{centroid}}]$，其中 $x_{\\text{centroid}}$ 保留六位小数，并按指定格式聚合到一行中。\n\n该设计将基础弹性力学和生长原理整合到一个可复现的计算程序中，用于识别由组织生长引起的应力和能量梯度所隐含的域边界，这与系统生物医学中对形态弹性效应下空间域和组织结构的分析相一致。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix, lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef generate_mesh(nx, ny):\n    \"\"\"\n    Generate a structured grid on [0,1]x[0,1] with nx x ny nodes,\n    and triangulate each cell into two triangles.\n    Returns:\n        nodes: (N,2) array of coordinates\n        elems: list of triangles, each as a tuple of 3 node indices\n    \"\"\"\n    xs = np.linspace(0.0, 1.0, nx)\n    ys = np.linspace(0.0, 1.0, ny)\n    xv, yv = np.meshgrid(xs, ys, indexing='xy')\n    nodes = np.column_stack([xv.ravel(), yv.ravel()])\n    elems = []\n    def idx(i, j):\n        return j * nx + i\n    for j in range(ny - 1):\n        for i in range(nx - 1):\n            n00 = idx(i, j)\n            n10 = idx(i + 1, j)\n            n01 = idx(i, j + 1)\n            n11 = idx(i + 1, j + 1)\n            # Split into two triangles: (n00, n10, n11) and (n00, n11, n01)\n            elems.append((n00, n10, n11))\n            elems.append((n00, n11, n01))\n    return nodes, elems\n\ndef compute_B_and_area(tri_coords):\n    \"\"\"\n    Compute the B matrix and area for a linear triangular element.\n    tri_coords: (3,2) array with coordinates of the triangle nodes (x,y).\n    Returns:\n        B: (3,6) strain-displacement matrix\n        area: scalar area\n    \"\"\"\n    x1, y1 = tri_coords[0]\n    x2, y2 = tri_coords[1]\n    x3, y3 = tri_coords[2]\n    # Area (signed) and then absolute value\n    det = x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)\n    area = 0.5 * abs(det)\n    if area = 1e-14:\n        # Degenerate triangle; return zeros\n        return np.zeros((3,6)), 0.0\n\n    beta1 = y2 - y3\n    beta2 = y3 - y1\n    beta3 = y1 - y2\n    gamma1 = x3 - x2\n    gamma2 = x1 - x3\n    gamma3 = x2 - x1\n\n    dN1_dx = beta1 / (2.0 * area)\n    dN2_dx = beta2 / (2.0 * area)\n    dN3_dx = beta3 / (2.0 * area)\n    dN1_dy = gamma1 / (2.0 * area)\n    dN2_dy = gamma2 / (2.0 * area)\n    dN3_dy = gamma3 / (2.0 * area)\n\n    B = np.array([\n        [dN1_dx, 0.0,      dN2_dx, 0.0,      dN3_dx, 0.0     ],\n        [0.0,     dN1_dy,  0.0,     dN2_dy,  0.0,     dN3_dy ],\n        [dN1_dy,  dN1_dx,  dN2_dy,  dN2_dx,  dN3_dy,  dN3_dx ]\n    ])\n    return B, area\n\ndef plane_stress_D(E, nu):\n    \"\"\"\n    Constitutive matrix for plane stress in Voigt form.\n    \"\"\"\n    coef = E / (1.0 - nu**2)\n    D = coef * np.array([\n        [1.0, nu,  0.0],\n        [nu,  1.0, 0.0],\n        [0.0, 0.0, (1.0 - nu) / 2.0]\n    ])\n    return D\n\ndef assemble_system(nodes, elems, growth_func, D, thickness=1.0):\n    \"\"\"\n    Assemble global stiffness matrix K and growth-induced load vector f.\n    Returns:\n        K: sparse (2N x 2N) CSC matrix\n        f: (2N,) vector\n        B_list: list of B matrices per element\n        area_list: list of areas per element\n        elem_nodes: list of node index tuples per element\n        eps_g_list: (n_elems,3) array of eigenstrain per element\n    \"\"\"\n    n_nodes = nodes.shape[0]\n    n_dofs = 2 * n_nodes\n    data = []\n    rows = []\n    cols = []\n    f = np.zeros(n_dofs)\n    B_list = []\n    area_list = []\n    eps_g_list = []\n\n    for e_idx, tri in enumerate(elems):\n        tri_coords = nodes[np.array(tri)]\n        B, area = compute_B_and_area(tri_coords)\n        B_list.append(B)\n        area_list.append(area)\n        if area == 0.0:\n            eps_g = np.zeros(3)\n            eps_g_list.append(eps_g)\n            continue\n        # Element centroid\n        cx = np.mean(tri_coords[:, 0])\n        cy = np.mean(tri_coords[:, 1])\n        eps_g = np.array(growth_func(cx, cy), dtype=float)\n        eps_g_list.append(eps_g)\n\n        # Element stiffness and equivalent nodal load due to growth\n        Ke = thickness * area * (B.T @ D @ B)\n        fe = thickness * area * (B.T @ D @ eps_g)\n\n        # Assemble into global K and f\n        elem_dofs = []\n        for n in tri:\n            elem_dofs.extend([2 * n, 2 * n + 1])  # u_x, u_y\n        # Add Ke contributions\n        for i_local, i_global in enumerate(elem_dofs):\n            for j_local, j_global in enumerate(elem_dofs):\n                rows.append(i_global)\n                cols.append(j_global)\n                data.append(Ke[i_local, j_local])\n        # Add fe contributions\n        for i_local, i_global in enumerate(elem_dofs):\n            f[i_global] += fe[i_local]\n\n    K = coo_matrix((data, (rows, cols)), shape=(n_dofs, n_dofs)).tocsc()\n    return K, f, B_list, area_list, elems, np.array(eps_g_list)\n\ndef apply_dirichlet_left_boundary(K, f, nodes, tol=1e-12):\n    \"\"\"\n    Apply u=0, v=0 on all nodes with x=0 (within tolerance).\n    Modify K and f in place.\n    \"\"\"\n    n_nodes = nodes.shape[0]\n    fixed_dofs = []\n    for idx in range(n_nodes):\n        x = nodes[idx, 0]\n        if abs(x - 0.0) = tol:\n            fixed_dofs.append(2 * idx)     # u_x\n            fixed_dofs.append(2 * idx + 1) # u_y\n\n    K_lil = K.tolil()\n    for dof in fixed_dofs:\n        # Zero row and column, set diagonal to 1, RHS to 0\n        K_lil.rows[dof] = [dof]\n        K_lil.data[dof] = [1.0]\n        f[dof] = 0.0\n        # Zero column entries\n        # Iterate over all rows to set K[i, dof] = 0\n        for i in range(K_lil.shape[0]):\n            if i != dof:\n                K_lil[i, dof] = 0.0\n    return K_lil.tocsc(), f\n\ndef solve_system(K, f):\n    \"\"\"\n    Solve K u = f for u.\n    \"\"\"\n    u = spsolve(K, f)\n    return u\n\ndef compute_element_energy(B_list, area_list, elems, nodes, D, u, eps_g_list, thickness=1.0):\n    \"\"\"\n    Compute elastic energy density per element.\n    Returns:\n        w_list: list of energy densities per element\n    \"\"\"\n    w_list = []\n    for e_idx, tri in enumerate(elems):\n        area = area_list[e_idx]\n        if area == 0.0:\n            w_list.append(0.0)\n            continue\n        B = B_list[e_idx]\n        eps_g = eps_g_list[e_idx]\n        # Gather element DOFs\n        elem_dofs = []\n        for n in tri:\n            elem_dofs.extend([2 * n, 2 * n + 1])\n        u_e = u[np.array(elem_dofs)]\n        eps_e = B @ u_e - eps_g\n        w = 0.5 * (eps_e.T @ D @ eps_e)  # energy density\n        w_list.append(float(w))\n    return np.array(w_list)\n\ndef build_edge_adjacency(elems):\n    \"\"\"\n    Build mapping from edges (sorted node index pair) to list of adjacent triangle indices.\n    Returns:\n        edge_to_tris: dict { (n1,n2): [t_idx_1, t_idx_2?] }\n    \"\"\"\n    edge_to_tris = {}\n    for t_idx, tri in enumerate(elems):\n        i, j, k = tri\n        edges = [(min(i, j), max(i, j)), (min(j, k), max(j, k)), (min(k, i), max(k, i))]\n        for e in edges:\n            if e not in edge_to_tris:\n                edge_to_tris[e] = [t_idx]\n            else:\n                edge_to_tris[e].append(t_idx)\n    return edge_to_tris\n\ndef detect_domain_boundaries(nodes, w_list, edge_to_tris, tau):\n    \"\"\"\n    Detect boundary edges based on median threshold of energy differences.\n    Returns:\n        boundary_edges: list of edges ((n1,n2))\n        x_centroid: mean x of midpoints of boundary edges; -1.0 if none\n    \"\"\"\n    diffs = []\n    interior_edges = []\n    for edge, tris in edge_to_tris.items():\n        if len(tris) == 2:\n            t1, t2 = tris\n            dw = abs(w_list[t1] - w_list[t2])\n            diffs.append(dw)\n            interior_edges.append((edge, dw))\n    if len(diffs) == 0:\n        return [], -1.0\n    diffs_arr = np.array(diffs)\n    # Median of positive differences to avoid zero-only cases\n    positive_diffs = diffs_arr[diffs_arr > 0.0]\n    if positive_diffs.size > 0:\n        m = float(np.median(positive_diffs))\n    else:\n        m = 0.0\n    threshold = tau * m\n    boundary_edges = [edge for edge, dw in interior_edges if dw > threshold]\n    if len(boundary_edges) == 0:\n        return [], -1.0\n    # Compute centroid in x of midpoints\n    x_mids = []\n    for n1, n2 in boundary_edges:\n        xmid = 0.5 * (nodes[n1, 0] + nodes[n2, 0])\n        x_mids.append(xmid)\n    x_centroid = float(np.mean(x_mids))\n    return boundary_edges, x_centroid\n\ndef case_growth_functions():\n    \"\"\"\n    Define growth strain functions for the three test cases.\n    Returns a list of callables growth_func(x, y) -> [exx, eyy, exy]\n    \"\"\"\n    def g1(x, y):\n        return [0.01, 0.01, 0.0]\n\n    def g2(x, y):\n        if x  0.5:\n            return [0.008, 0.008, 0.0]\n        else:\n            return [0.02, 0.0, 0.0]\n\n    def g3(x, y):\n        return [0.03 * x, 0.005, 0.0]\n\n    return [g1, g2, g3]\n\ndef run_case(nx, ny, tau, growth_func, E=1.0, nu=0.3, thickness=1.0):\n    nodes, elems = generate_mesh(nx, ny)\n    D = plane_stress_D(E, nu)\n    K, f, B_list, area_list, elem_nodes, eps_g_list = assemble_system(nodes, elems, growth_func, D, thickness=thickness)\n    K_bc, f_bc = apply_dirichlet_left_boundary(K, f, nodes, tol=1e-12)\n    u = solve_system(K_bc, f_bc)\n    w_list = compute_element_energy(B_list, area_list, elem_nodes, nodes, D, u, eps_g_list, thickness=thickness)\n    edge_to_tris = build_edge_adjacency(elem_nodes)\n    boundary_edges, x_centroid = detect_domain_boundaries(nodes, w_list, edge_to_tris, tau)\n    N_boundary = len(boundary_edges)\n    return N_boundary, x_centroid\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (nx, ny, tau, growth_func)\n        (20, 20, 3.0, case_growth_functions()[0]),  # Case 1\n        (20, 20, 3.0, case_growth_functions()[1]),  # Case 2\n        (20, 20, 3.0, case_growth_functions()[2]),  # Case 3\n    ]\n\n    results = []\n    for nx, ny, tau, gfunc in test_cases:\n        N_boundary, x_centroid = run_case(nx, ny, tau, gfunc, E=1.0, nu=0.3, thickness=1.0)\n        results.append((N_boundary, x_centroid))\n\n    # Build the exact required format: a single line with nested lists and x rounded to six decimals.\n    formatted = \"[\" + \",\".join([f\"[{n},{x:.6f}]\" if np.isfinite(x) else f\"[{n},-1.000000]\" for n, x in results]) + \"]\"\n    print(formatted)\n\nsolve()\n```", "id": "4354088"}]}