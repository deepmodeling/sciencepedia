{"hands_on_practices": [{"introduction": "分析空间分辨组学数据的第一步通常是定义不同测量点之间的空间关系。将原始的空间坐标转化为结构化的网络是后续分析的基础。此练习 [@problem_id:4315795] 将指导您构建一个 $\\epsilon$ 半径图，这是一种将空间邻近性转化为图论连接的基本方法，并探索距离阈值 $\\epsilon$ 的选择如何影响图的连通性。", "problem": "给定代表空间分辨组学分析中测量位置的空间坐标，这些坐标被视为二维欧几里得空间中的点。目标是对于以微米（$\\,\\mu \\mathrm{m}\\,$）为单位给定的非负距离阈值 $\\,\\epsilon\\,$，构建点集上的 $\\epsilon$-半径图，计算其邻接矩阵，并评估图连通性作为 $\\,\\epsilon\\,$ 的函数。程序必须从基本原理出发实现以下内容。\n\n基本原理和定义：\n- 分子生物学的中心法则确立了在空间位置上测量分子种类，但为了计算，我们将位置抽象为度量空间中的点。在欧几里得度量空间中，两点 $\\,p_i=(x_i,y_i)\\,$ 和 $\\,p_j=(x_j,y_j)\\,$ 之间的距离由欧几里得度量定义\n$$\nd_{ij} \\equiv \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}.\n$$\n- 一个包含 $\\,N\\,$ 个点的简单无向图由其邻接矩阵 $\\,A^{(\\epsilon)} \\in \\{0,1\\}^{N \\times N}\\,$ 定义，其中\n$$\nA^{(\\epsilon)}_{ij} \\equiv \\begin{cases}\n1,  \\text{if } i \\ne j \\text{ and } d_{ij} \\le \\epsilon,\\\\\n0,  \\text{otherwise.}\n\\end{cases}\n$$\n自环被排除，因此对于所有 $\\,i\\,$，都有 $\\,A^{(\\epsilon)}_{ii} = 0\\,$。\n- 连通性通过连通分量进行评估。令 $\\,K(\\epsilon)\\,$ 表示由 $\\,A^{(\\epsilon)}\\,$ 导出的图的整数连通分量数。令 $\\,L(\\epsilon)\\,$ 表示最大连通分量的整数大小。定义连通性分数\n$$\nF(\\epsilon) \\equiv \\frac{L(\\epsilon)}{N},\n$$\n一个四舍五入到四位小数的实数。\n\n程序要求：\n- 给定一个以 $\\,\\mu \\mathrm{m}\\,$ 为单位的坐标列表 $\\,\\{(x_i,y_i)\\}_{i=1}^N\\,$ 和一个同样以 $\\,\\mu \\mathrm{m}\\,$ 为单位的阈值集合 $\\,\\{\\epsilon_t\\}_{t=1}^T\\,$，为每个 $\\,\\epsilon_t\\,$ 构建 $\\,A^{(\\epsilon_t)}\\,$，并计算 $\\,K(\\epsilon_t)\\,$ 和 $\\,F(\\epsilon_t)\\,$。\n- 最终输出不得包含物理单位；只能包含指定的数字。在内部，距离必须以 $\\,\\mu \\mathrm{m}\\,$ 为单位处理，下面的阈值 $\\,\\epsilon\\,$ 值也全部以 $\\,\\mu \\mathrm{m}\\,$ 为单位。\n\n测试套件与覆盖范围：\n为以下四个独立的测试用例提供结果，每个测试用例包含一个坐标集和一个阈值集。这些测试用例探查了一般情况、边界条件、重复坐标以及带有一个离群点的网格结构。\n\n- 测试用例 $\\,1\\,$ (空间中分离的两个紧凑簇；$\\,N=6\\,$):\n  - 坐标 (单位 $\\,\\mu \\mathrm{m}\\,$): $\\,(0,0),\\,(1,0),\\,(0.5,0.5),\\,(10,0),\\,(11,0),\\,(10.5,-0.5)\\,$。\n  - 阈值 (单位 $\\,\\mu \\mathrm{m}\\,$): $\\,\\epsilon \\in [0.4,\\,0.71,\\,1.0,\\,8.9,\\,9.0]\\,$。\n\n- 测试用例 $\\,2\\,$ (重复坐标和精确距离边界；$\\,N=3\\,$):\n  - 坐标 (单位 $\\,\\mu \\mathrm{m}\\,$): $\\,(0,0),\\,(0,0),\\,(3,4)\\,$。\n  - 阈值 (单位 $\\,\\mu \\mathrm{m}\\,$): $\\,\\epsilon \\in [0.0,\\,0.0001,\\,5.0]\\,$。\n\n- 测试用例 $\\,3\\,$ (等间距的线性链；$\\,N=5\\,$):\n  - 坐标 (单位 $\\,\\mu \\mathrm{m}\\,$): $\\,(0,0),\\,(2,0),\\,(4,0),\\,(6,0),\\,(8,0)\\,$。\n  - 阈值 (单位 $\\,\\mu \\mathrm{m}\\,$): $\\,\\epsilon \\in [1.0,\\,2.0,\\,2.1,\\,8.0]\\,$。\n\n- 测试用例 $\\,4\\,$ (带有一个离群点的网格；$\\,N=5\\,$):\n  - 坐标 (单位 $\\,\\mu \\mathrm{m}\\,$): $\\,(0,0),\\,(0,1),\\,(1,0),\\,(1,1),\\,(4,4)\\,$。\n  - 阈值 (单位 $\\,\\mu \\mathrm{m}\\,$): $\\,\\epsilon \\in [0.9,\\,1.0,\\,1.5,\\,5.0]\\,$。\n\n答案规范：\n- 对每个测试用例，计算列表 $\\,\\{K(\\epsilon_t)\\}_{t=1}^T\\,$ 和列表 $\\,\\{F(\\epsilon_t)\\}_{t=1}^T\\,$，其中 $\\,F(\\epsilon_t)\\,$ 四舍五入到四位小数并表示为小数。\n- 您的程序应生成单行输出，其中按上述顺序包含每个测试用例的一对列表 $\\,\\big([\\text{list of }K],\\,[\\text{list of }F]\\big)\\,$，并将这些对聚合到一个外部列表中。具体来说，输出必须是以下形式的单行内容\n$$\n\\big[\\,\\big([K_{1,1},\\ldots,K_{1,T_1}],\\,[F_{1,1},\\ldots,F_{1,T_1}]\\big),\\,\\ldots,\\,\\big([K_{4,1},\\ldots,K_{4,T_4}],\\,[F_{4,1},\\ldots,F_{4,T_4}]\\big)\\,\\big].\n$$\n输出行中只允许出现数字和括号；不要包含单位或其他文本。", "solution": "用户的请求将通过首先验证问题陈述来解决，然后在问题有效性的基础上，提供一个包含底层科学推理和完整 Python 实现的完整解决方案。\n\n### 问题验证\n\n#### 第 1 步：提取给定信息\n\n- **度量空间**：问题设定在二维欧几里得空间中。\n- **欧几里得距离**：两点 $\\,p_i=(x_i,y_i)\\,$ 和 $\\,p_j=(x_j,y_j)\\,$ 之间的距离定义为 $d_{ij} \\equiv \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$。\n- **图定义**：在 $\\,N\\,$ 个点上构建一个 $\\epsilon$-半径图。其邻接矩阵 $\\,A^{(\\epsilon)} \\in \\{0,1\\}^{N \\times N}\\,$ 由以下规则定义：如果 $\\,i \\ne j\\,$ 且 $\\,d_{ij} \\le \\epsilon\\,$，则 $A^{(\\epsilon)}_{ij} = 1\\,$，否则 $\\,A^{(\\epsilon)}_{ij} = 0\\,$。自环被排除，意味着对于所有 $\\,i\\,$，$\\,A^{(\\epsilon)}_{ii} = 0\\,$。\n- **连通性度量**：\n  - $\\,K(\\epsilon)\\,$：对于给定的 $\\,\\epsilon\\,$，图中连通分量的整数数量。\n  - $\\,L(\\epsilon)\\,$：最大连通分量的整数大小。\n  - $\\,F(\\epsilon) \\equiv \\frac{L(\\epsilon)}{N}\\,$：连通性分数，一个四舍五入到四位小数的实数。\n- **输入数据**：程序接收一个坐标列表 $\\,\\{(x_i,y_i)\\}_{i=1}^N\\,$ 和一个距离阈值集合 $\\,\\{\\epsilon_t\\}_{t=1}^T\\,$。所有空间和距离单位均为微米 ($\\,\\mu \\mathrm{m}\\,$)。\n- **测试用例**：\n    - **用例 1**：$\\,N=6\\,$ 个坐标 $\\,(0,0),\\,(1,0),\\,(0.5,0.5),\\,(10,0),\\,(11,0),\\,(10.5,-0.5)\\,$，阈值为 $\\,\\epsilon \\in [0.4,\\,0.71,\\,1.0,\\,8.9,\\,9.0]\\,$。\n    - **用例 2**：$\\,N=3\\,$ 个坐标 $\\,(0,0),\\,(0,0),\\,(3,4)\\,$，阈值为 $\\,\\epsilon \\in [0.0,\\,0.0001,\\,5.0]\\,$。\n    - **用例 3**：$\\,N=5\\,$ 个坐标 $\\,(0,0),\\,(2,0),\\,(4,0),\\,(6,0),\\,(8,0)\\,$，阈值为 $\\,\\epsilon \\in [1.0,\\,2.0,\\,2.1,\\,8.0]\\,$。\n    - **用例 4**：$\\,N=5\\,$ 个坐标 $\\,(0,0),\\,(0,1),\\,(1,0),\\,(1,1),\\,(4,4)\\,$，阈值为 $\\,\\epsilon \\in [0.9,\\,1.0,\\,1.5,\\,5.0]\\,$。\n- **输出规范**：一个表示元组列表的单行字符串。每个元组对应一个测试用例，并包含两个列表：计算出的 $\\,K\\,$ 值列表和计算出的 $\\,F\\,$ 值列表。指定格式为：$\\big[\\,\\big([K_{1,1},\\ldots],\\,[F_{1,1},\\ldots]\\big),\\,\\ldots,\\,\\big([K_{4,1},\\ldots],\\,[F_{4,1},\\ldots]\\big)\\,\\big]$。\n\n#### 第 2 步：使用提取的给定信息进行验证\n\n根据验证标准对问题陈述进行评估。\n\n- **科学基础**：该问题基于图论（无向图、邻接矩阵、连通分量）和几何学（欧几里得距离）的基本和标准概念。其应用背景——空间分辨组学——是系统生物学中一个有效且重要的研究领域，其中此类基于图的分析被用于模拟细胞间的相互作用。该问题不含任何伪科学或事实错误。\n- **适定性**：对于任何给定的 $\\,N\\,$ 个点的集合和非负阈值 $\\,\\epsilon\\,$，$\\epsilon$-半径图是唯一定义的。连通分量的数量和最大分量的大小是任何图的适定且可计算的属性。问题的结构保证了每个测试用例都有唯一的解。\n- **客观性**：问题陈述使用了精确的数学定义和客观的语言，没有主观解释的余地。\n- **完整性与一致性**：问题是自洽的。它提供了所有必要的定义、数据（坐标和阈值）以及清晰的输出规范。邻接矩阵的定义，包括排除自环（$\\,i \\ne j\\,$）和非严格不等式（$\\,d_{ij} \\le \\epsilon\\,$），是明确且内部一致的。\n- **可行性**：提供的坐标和阈值是现实的。计算任务是可行的，并且可以在合理的时间内用标准算法解决。\n- **结构**：问题结构良好。它要求从基本原理出发实现一个算法，这是一个明确的指令。测试用例经过精心设计，涵盖了各种场景，包括聚类数据、重复坐标（被视为不同节点）、线性结构和带有离群点的网格。\n\n#### 第 3 步：结论与行动\n\n该问题是**有效的**。它具有科学依据，适定且完整。我现在将继续提供解决方案。\n\n### 基于原理的解决方案设计\n\n问题的核心是通过改变距离阈值 $\\,\\epsilon\\,$，分析从一个固定的点集生成的一系列图的连通性。解决方案必须从基本原理出发实现，特别是连通分量的计算。\n\n1.  **距离计算**：对于一个包含 $\\,N\\,$ 个点的集合，第一步是计算所有点对之间的欧几里得距离。为了优化这个过程，我们可以预先计算一个对称的 $\\,N \\times N\\,$ 距离矩阵 $\\,D\\,$，其中 $\\,D_{ij} = d_{ij}\\,$。这样可以避免为每个阈值 $\\,\\epsilon\\,$ 重复计算距离。\n\n2.  **图构建**：对于每个给定的阈值 $\\,\\epsilon_t\\,$，我们构建邻接矩阵 $\\,A^{(\\epsilon_t)}\\,$。根据定义，当且仅当对应的距离 $\\,D_{ij}\\,$ 满足 $\\,0  D_{ij} \\le \\epsilon_t\\,$ 时，元素 $\\,A^{(\\epsilon_t)}_{ij}\\,$ 被设为 $\\,1\\,$。条件 $\\,D_{ij} > 0\\,$ 隐式地处理了 $\\,i \\ne j\\,$ 的要求，因为 $\\,D_{ii} = 0\\,$。这可以通过对预先计算的距离矩阵应用阈值操作来高效实现。\n\n3.  **连通分量算法**：问题要求找到连通分量的数量 $\\,K(\\epsilon_t)\\,$ 和最大连通分量的大小 $\\,L(\\epsilon_t)\\,$。这是一个经典的图遍历问题。我们将从基本原理出发实现一个算法，例如深度优先搜索 (DFS) 或广度优先搜索 (BFS)，来识别这些分量。算法流程如下：\n    a. 初始化一个大小为 $\\,N\\,$ 的 `visited` 数组来跟踪已访问的节点，初始值全部为 `False`。\n    b. 初始化一个空列表 `component_sizes`，用于存储找到的每个分量的大小。\n    c. 遍历从 $\\,0\\,$ 到 $\\,N-1\\,$ 的每个节点 $\\,i\\,$。\n    d. 如果节点 $\\,i\\,$ 尚未被访问，则表示一个新发现的连通分量的开始。\n        i.  从节点 $\\,i\\,$ 开始进行图遍历（例如，使用栈的迭代式 DFS）。\n        ii. 将节点 $\\,i\\,$ 标记为已访问并将其压入栈中。\n        iii. 初始化一个计数器，用于记录当前分量的大小，初值为 $\\,0\\,$。\n        iv. 当栈不为空时，弹出一个节点 $\\,u\\,$，增加大小计数器，并检查其所有邻居 $\\,v\\,$（即 $\\,A^{(\\epsilon_t)}_{uv} = 1\\,$ 的节点）。对于每个未访问的邻居 $\\,v\\,$，将其标记为已访问并压入栈中。\n    e. 从节点 $\\,i\\,$ 开始的遍历完成后，大小计数器的最终值就是该分量的大小。将此大小附加到 `component_sizes` 列表中。\n    f. 遍历完所有节点后，连通分量的数量 $\\,K(\\epsilon_t)\\,$ 就是发起的遍历总次数，即 `component_sizes` 列表的长度。\n    g. 最大连通分量的大小 $\\,L(\\epsilon_t)\\,$ 是 `component_sizes` 列表中的最大值。\n\n4.  **度量计算与格式化**：计算出 $\\,K(\\epsilon_t)\\,$ 和 $\\,L(\\epsilon_t)\\,$ 后，计算连通性分数 $\\,F(\\epsilon_t) = L(\\epsilon_t) / N\\,$，并按要求四舍五入到四位小数。对集合 $\\,\\{\\epsilon_t\\}\\,$ 中的所有阈值重复此过程。\n\n5.  **输出生成**：最后一步是将所有测试用例收集到的 $\\,K\\,$ 和 $\\,F\\,$ 值列表格式化为问题描述中指定的精确字符串格式，确保没有多余字符或不正确的间距。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_connected_components(adj_matrix: np.ndarray):\n    \"\"\"\n    Finds connected components in a graph from its adjacency matrix.\n    Implementation is from first principles using an iterative Depth-First Search (DFS).\n\n    Args:\n        adj_matrix: An N x N numpy array representing the graph's adjacency matrix.\n\n    Returns:\n        A tuple (num_components, largest_component_size).\n    \"\"\"\n    n = adj_matrix.shape[0]\n    if n == 0:\n        return 0, 0\n\n    visited = [False] * n\n    component_sizes = []\n\n    for i in range(n):\n        if not visited[i]:\n            # Found the start of a new component\n            current_component_size = 0\n            stack = [i]\n            visited[i] = True\n\n            while stack:\n                u = stack.pop()\n                current_component_size += 1\n                # Find neighbors of u where there is an edge (value is 1)\n                neighbors = np.where(adj_matrix[u] == 1)[0]\n                for v in neighbors:\n                    if not visited[v]:\n                        visited[v] = True\n                        stack.append(v)\n            \n            component_sizes.append(current_component_size)\n\n    num_components = len(component_sizes)\n    largest_component_size = max(component_sizes) if component_sizes else 0\n\n    return num_components, largest_component_size\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            # Test Case 1\n            [(0, 0), (1, 0), (0.5, 0.5), (10, 0), (11, 0), (10.5, -0.5)],\n            [0.4, 0.71, 1.0, 8.9, 9.0]\n        ),\n        (\n            # Test Case 2\n            [(0, 0), (0, 0), (3, 4)],\n            [0.0, 0.0001, 5.0]\n        ),\n        (\n            # Test Case 3\n            [(0, 0), (2, 0), (4, 0), (6, 0), (8, 0)],\n            [1.0, 2.0, 2.1, 8.0]\n        ),\n        (\n            # Test Case 4\n            [(0, 0), (0, 1), (1, 0), (1, 1), (4, 4)],\n            [0.9, 1.0, 1.5, 5.0]\n        )\n    ]\n\n    all_results = []\n    for coordinates_list, thresholds in test_cases:\n        coords = np.array(coordinates_list, dtype=float)\n        N = coords.shape[0]\n\n        # Use numpy broadcasting to efficiently compute the pairwise distance matrix.\n        # coords[:, np.newaxis, :] - shape (N, 1, 2)\n        # coords[np.newaxis, :, :] - shape (1, N, 2)\n        # Difference results in a shape (N, N, 2) array of coordinate differences.\n        dist_matrix = np.sqrt(np.sum((coords[:, np.newaxis, :] - coords[np.newaxis, :, :])**2, axis=-1))\n\n        k_results = []\n        f_results = []\n\n        for epsilon in thresholds:\n            # Construct adjacency matrix A_ij = 1 if d_ij = epsilon.\n            adj_matrix = (dist_matrix = epsilon).astype(int)\n            # Exclude self-loops as per problem definition (A_ii = 0).\n            np.fill_diagonal(adj_matrix, 0)\n            \n            K, L = find_connected_components(adj_matrix)\n            \n            # For N=0, F would be undefined. Problem constraints ensure N > 0.\n            F = round(L / N, 4) if N > 0 else 0.0\n\n            k_results.append(K)\n            f_results.append(F)\n        \n        all_results.append((k_results, f_results))\n\n    # Construct the final output string exactly as specified.\n    # Manually build the string to control spacing and format.\n    case_strings = []\n    for k_list, f_list in all_results:\n        k_str = f\"[{','.join(map(str, k_list))}]\"\n        f_str = f\"[{','.join(f'{f:.4f}' for f in f_list)}]\"\n        case_strings.append(f\"({k_str},{f_str})\")\n        \n    final_output_string = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string.replace(\" \",\"\"))\n\nsolve()\n```", "id": "4315795"}, {"introduction": "空间生物学中的一个核心问题是，分子特征（如蛋白质或基因表达）在组织中是随机分布，还是呈现出特定的空间模式。空间自相关统计量（如Moran's I指数）能够量化邻近位置具有相似值的倾向。通过此练习 [@problem_id:4315652]，您将学习如何从细胞分割掩模和蛋白质强度数据中计算不同细胞类型的汇总统计量，并评估标记物表达的空间自相关性，这是分析空间分辨图像的核心工作流程。", "problem": "给定一组合成但科学上合理的数据，代表系统生物医学中简化的空间分辨蛋白质组学场景。该场景遵循分子生物学中心法则描述的核心基础，即信息流从脱氧核糖核酸（DNA）流向核糖核酸（RNA），再到蛋白质。组织切片中蛋白质标记物强度的测量可被视为每个已分割细胞的定量变量。分割掩模将每个像素分配给一个细胞标识符，从而能够对细胞位置进行几何推断。任务是计算每种细胞类型的汇总统计数据，并使用基于距离的邻居定义来评估标记物表达的空间自相关性。核心量是每种细胞类型中每个细胞强度的样本均值和无偏样本方差，以及一个使用有限半径内反距离权重计算的、遍及所有细胞的空间自相关度量。\n\n作为此问题基础的基本定律和核心定义包括：随机变量的期望值和方差的定义，通过平均像素中心坐标构建标记区域的质心，以及空间自相关的概念，即邻近观测值趋于相似的趋势。测量值假定为标记物的任意强度单位，而空间距离使用微米。\n\n对于每个测试用例，提供以下数据：\n\n- 一个二维分割掩模，为每个像素指定细胞标识符。背景用 $0$ 标记。\n- 从每个细胞标识符到分类细胞类型标签的映射。\n- 从每个细胞标识符到单个标记物的每细胞蛋白质强度的映射。\n- 以微米为单位的像素大小 $p$，指定一个像素边缘的物理尺寸。\n- 以微米为单位的邻居半径 $r$，定义了空间邻域：如果两个不同细胞的质心之间的欧几里得距离小于或等于 $r$，则它们被视为邻居。邻居对的空间权重定义为其质心距离的倒数，否则为零。\n\n您的程序必须为每个测试用例：\n- 从分割掩模计算每个细胞的质心。标记区域的质心是属于该区域的像素中心的物理坐标的算术平均值，其中位于行索引 $i$ 和列索引 $j$ 的像素中心的坐标为 $\\left((i + 0.5) \\cdot p, (j + 0.5) \\cdot p\\right)$（单位：微米）。\n- 对于每种细胞类型，计算该类型细胞的每细胞强度 $x_c$ 的样本均值和无偏样本方差（对于 $k$ 个样本，除数为 $k - 1$）。如果一种细胞类型只有 $k = 1$ 个样本，则报告方差为 $0$。\n- 使用上述定义的标准基于距离的加权方案，评估所有细胞中标记物表达的空间自相关性。如果细胞少于 $2$ 个，总权重为 $0$，或所有细胞强度的样本方差为 $0$，则报告空间自相关值为 $0$。\n\n所有距离均以微米表示。最终输出为无量纲量。角度单位不适用。\n\n测试套件规范：\n- 测试用例 $1$（正常路径）：\n  - 大小为 $5 \\times 5$ 的分割掩模 $M_1$：\n    - 第 $0$ 行：[$1$, $1$, $2$, $2$, $0$]\n    - 第 $1$ 行：[$1$, $1$, $2$, $2$, $0$]\n    - 第 $2$ 行：[$0$, $0$, $0$, $0$, $0$]\n    - 第 $3$ 行：[$3$, $3$, $4$, $4$, $0$]\n    - 第 $4$ 行：[$3$, $3$, $4$, $4$, $0$]\n  - 像素大小 $p = 1$ 微米。\n  - 邻居半径 $r = 3$ 微米。\n  - 细胞类型映射：$1 \\mapsto$ \"A\", $2 \\mapsto$ \"B\", $3 \\mapsto$ \"A\", $4 \\mapsto$ \"B\"。\n  - 每细胞强度：$x_1 = 1.0$, $x_2 = 2.5$, $x_3 = 1.5$, $x_4 = 3.0$。\n- 测试用例 $2$（无邻居的边界条件）：\n  - 分割掩模 $M_2 = M_1$。\n  - 像素大小 $p = 1$ 微米。\n  - 邻居半径 $r = 1$ 微米。\n  - 细胞类型映射：$1 \\mapsto$ \"A\", $2 \\mapsto$ \"B\", $3 \\mapsto$ \"A\", $4 \\mapsto$ \"B\"。\n  - 每细胞强度：$x_1 = 1.0$, $x_2 = 2.5$, $x_3 = 1.5$, $x_4 = 3.0$。\n- 测试用例 $3$（方差为零的边缘情况）：\n  - 分割掩模 $M_3 = M_1$。\n  - 像素大小 $p = 1$ 微米。\n  - 邻居半径 $r = 3$ 微米。\n  - 细胞类型映射：$1 \\mapsto$ \"A\", $2 \\mapsto$ \"B\", $3 \\mapsto$ \"A\", $4 \\mapsto$ \"B\"。\n  - 每细胞强度：$x_1 = 2.0$, $x_2 = 2.0$, $x_3 = 2.0$, $x_4 = 2.0$。\n\n输出规范：\n- 对于每个测试用例，返回一个包含三个元素的列表：\n  - 按类型标签字典序排列的每种类型的样本均值列表，\n  - 按相同顺序排列的每种类型的无偏样本方差列表，\n  - 空间自相关值（浮点数）。\n- 将所有测试用例的结果汇总到一行中，该行包含一个由这些每案例列表组成的列表。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[[means_case1,vars_case1,moran_case1],[means_case2,vars_case2,moran_case2],[means_case3,vars_case3,moran_case3]]\"）。所有数值结果必须是浮点数或浮点数列表。不应打印其他任何文本。", "solution": "所提供的问题具有科学依据、提法明确且完整。它展示了空间生物信息学中的一个标准计算工作流程，要求从分割掩模中计算细胞质心，计算不同细胞群的汇总统计数据，并使用定义的自相关指数评估空间模式。该问题是有效的，可以通过实施指定的计算来解决。\n\n解决过程分为三个主要部分：\n1.  从分割掩模计算细胞质心。\n2.  计算每种细胞类型的汇总统计数据（均值和方差）。\n3.  计算所有细胞中标记物强度的空间自相关性。\n\n每个步骤都将进行数学描述，然后使用测试用例 1 的数据进行详细示例演算。\n\n### 1. 细胞质心计算\n\n一个细胞的几何质心是属于该细胞的所有像素中心的物理坐标的算术平均值。给定位于矩阵索引 $(i, j)$（行，列）的像素和像素大小为 $p$ 微米，该像素中心的物理坐标为：\n$$ (y, z) = ((i + 0.5) \\cdot p, (j + 0.5) \\cdot p) $$\n对于一个由 $N_c$ 个像素组成的细胞 $c$，其像素索引集合为 $S_c = \\{(i_1, j_1), (i_2, j_2), \\dots, (i_{N_c}, j_{N_c})\\}$，其质心 $(\\bar{y}_c, \\bar{z}_c)$ 计算如下：\n$$ \\bar{y}_c = \\frac{p}{N_c} \\sum_{k=1}^{N_c} (i_k + 0.5) $$\n$$ \\bar{z}_c = \\frac{p}{N_c} \\sum_{k=1}^{N_c} (j_k + 0.5) $$\n\n**示例（测试用例 1）：**\n- 像素大小 $p = 1\n\\mu m$。\n- 细胞 $1$ 由索引为 $(0,0), (0,1), (1,0), (1,1)$ 的像素组成。共有 $N_1 = 4$ 个像素。\n- 质心是：\n  $$ \\bar{y}_1 = \\frac{1}{4} ((0+0.5) + (0+0.5) + (1+0.5) + (1+0.5)) = \\frac{0.5+0.5+1.5+1.5}{4} = 1.0 \\, \\mu m $$\n  $$ \\bar{z}_1 = \\frac{1}{4} ((0+0.5) + (1+0.5) + (0+0.5) + (1+0.5)) = \\frac{0.5+1.5+0.5+1.5}{4} = 1.0 \\, \\mu m $$\n  所以，细胞 $1$ 的质心是 $C_1 = (1.0, 1.0)$。\n- 类似地，我们找到其他细胞的质心：\n  - 细胞 $2$（像素 $(0,2), (0,3), (1,2), (1,3)$）：$C_2 = (1.0, 3.0)$。\n  - 细胞 $3$（像素 $(3,0), (3,1), (4,0), (4,1)$）：$C_3 = (4.0, 1.0)$。\n  - 细胞 $4$（像素 $(3,2), (3,3), (4,2), (4,3)$）：$C_4 = (4.0, 3.0)$。\n\n### 2. 每种类型的汇总统计数据\n\n对于每种细胞类型，我们收集属于该类型的所有细胞的强度，并计算样本均值和无偏样本方差。\n\n- 对于具有 $k$ 个细胞、强度为 $\\{x_1, x_2, \\dots, x_k\\}$ 的细胞类型，其**样本均值**为：\n  $$ \\bar{x}_{\\text{type}} = \\frac{1}{k} \\sum_{i=1}^k x_i $$\n- **无偏样本方差**为：\n  $$ s^2_{\\text{type}} = \\frac{1}{k-1} \\sum_{i=1}^k (x_i - \\bar{x}_{\\text{type}})^2 $$\n  如果 $k=1$，则方差定义为 $0$。\n\n**示例（测试用例 1）：**\n- 细胞类型按字典序排序：\"A\", \"B\"。\n- **\"A\" 型**: 细胞 $1$ 和 $3$，强度为 $x_1=1.0, x_3=1.5$。这里 $k=2$。\n  - 均值：$\\bar{x}_A = \\frac{1.0 + 1.5}{2} = 1.25$。\n  - 方差：$s^2_A = \\frac{(1.0 - 1.25)^2 + (1.5 - 1.25)^2}{2-1} = (-0.25)^2 + (0.25)^2 = 0.0625 + 0.0625 = 0.125$。\n- **\"B\" 型**: 细胞 $2$ 和 $4$，强度为 $x_2=2.5, x_4=3.0$。这里 $k=2$。\n  - 均值：$\\bar{x}_B = \\frac{2.5 + 3.0}{2} = 2.75$。\n  - 方差：$s^2_B = \\frac{(2.5 - 2.75)^2 + (3.0 - 2.75)^2}{2-1} = (-0.25)^2 + (0.25)^2 = 0.0625 + 0.0625 = 0.125$。\n- 结果是 `means = [1.25, 2.75]` 和 `variances = [0.125, 0.125]`。\n\n### 3. 空间自相关（莫兰指数 I）\n\n问题要求使用标准的基于距离的加权方案来评估空间自相关性。这对应于计算莫兰指数 I（Moran's I），定义如下：\n$$ I = \\frac{N}{\\sum_{i=1}^N \\sum_{j=1}^N w_{ij}} \\frac{\\sum_{i=1}^N \\sum_{j=1}^N w_{ij} (x_i - \\bar{x})(x_j - \\bar{x})}{\\sum_{i=1}^N (x_i - \\bar{x})^2} $$\n其中：\n- $N$ 是细胞总数。\n- $x_i$ 是细胞 $i$ 的强度。\n- $\\bar{x}$ 是所有细胞的平均强度。\n- $w_{ij}$ 是细胞 $i$ 和细胞 $j$ 之间的空间权重。\n权重 $w_{ij}$ 定义为细胞 $i$ 和 $j$ 的质心之间的欧几里得距离的倒数，如果该距离小于或等于给定半径 $r$，否则为 $0$。$w_{ii} = 0$。\n\n$$ w_{ij} = \\begin{cases} 1/d_{ij}  \\text{if } 0  d_{ij} \\le r \\\\ 0  \\text{otherwise} \\end{cases} $$\n其中 $d_{ij} = \\sqrt{(\\bar{y}_i - \\bar{y}_j)^2 + (\\bar{z}_i - \\bar{z}_j)^2}$。\n\n如果 $N  2$，总权重 $W=\\sum_i\\sum_j w_{ij}$ 为 $0$，或总方差（与 $\\sum_i (x_i - \\bar{x})^2$ 成正比）为 $0$，则该值报告为 $0$。\n\n**示例（测试用例 1）：**\n- 细胞数 $N=4$。强度为 $\\{1.0, 2.5, 1.5, 3.0\\}$。\n- 全局平均强度：$\\bar{x} = \\frac{1.0+2.5+1.5+3.0}{4} = 2.0$。\n- 与均值的偏差 $(x_i - \\bar{x})$：$\\{-1.0, 0.5, -0.5, 1.0\\}$。\n- 偏差平方和：$\\sum_i (x_i - \\bar{x})^2 = (-1.0)^2 + (0.5)^2 + (-0.5)^2 + (1.0)^2 = 2.5$。\n- 邻居半径 $r = 3.0 \\, \\mu m$。质心：$C_1(1,1), C_2(1,3), C_3(4,1), C_4(4,3)$。\n- 距离和权重 $(w_{ij} = w_{ji})$：\n  - $d_{12} = \\sqrt{(1-1)^2 + (1-3)^2} = 2.0 \\le 3.0 \\implies w_{12} = 1/2.0 = 0.5$。\n  - $d_{13} = \\sqrt{(1-4)^2 + (1-1)^2} = 3.0 \\le 3.0 \\implies w_{13} = 1/3.0$。\n  - $d_{14} = \\sqrt{(1-4)^2 + (1-3)^2} = \\sqrt{13} \\approx 3.61 > 3.0 \\implies w_{14} = 0$。\n  - $d_{24} = \\sqrt{(1-4)^2 + (3-3)^2} = 3.0 \\le 3.0 \\implies w_{24} = 1/3.0$。\n  - $d_{34} = \\sqrt{(4-4)^2 + (1-3)^2} = 2.0 \\le 3.0 \\implies w_{34} = 1/2.0$。\n  - $d_{23} = \\sqrt{(1-4)^2 + (3-1)^2} = \\sqrt{13} \\approx 3.61 > 3.0 \\implies w_{23} = 0$。\n- 总权重 $W = \\sum_i \\sum_j w_{ij} = 2 \\cdot (w_{12} + w_{13} + w_{24} + w_{34}) = 2 \\cdot (0.5 + 1/3 + 1/3 + 0.5) = 2 \\cdot (1 + 2/3) = 10/3$。\n- 莫兰指数 I 的分子：$\\sum_i \\sum_j w_{ij}(x_i - \\bar{x})(x_j - \\bar{x}) = 2 \\cdot [w_{12}(-1.0)(0.5) + w_{13}(-1.0)(-0.5) + w_{24}(0.5)(1.0) + w_{34}(-0.5)(1.0)] = 2 \\cdot [0.5(-0.5) + (1/3)(0.5) + (1/3)(0.5) + 0.5(-0.5)] = 2 \\cdot [-0.25 + 1/6 + 1/6 - 0.25] = 2 \\cdot [-0.5 + 1/3] = 2 \\cdot [-1/6] = -1/3$。\n- 莫兰指数 I：$I = \\frac{4}{10/3} \\frac{-1/3}{2.5} = \\frac{12}{10} \\frac{-1}{7.5} = 1.2 \\cdot (-0.1333...) = -0.16$。\n\n测试用例 1 的最终结果是 `[[1.25, 2.75], [0.125, 0.125], -0.16]`。\n\n- **测试用例 2** 与用例 1 相同，只是 $r=1.0$。所有细胞间距离都大于 $1.0$，因此所有权重 $w_{ij}$ 都为 $0$。总权重 $W=0$，所以根据定义，莫兰指数 I 为 $0.0$。\n- **测试用例 3** 与用例 1 相同，只是所有强度都为 $2.0$。全局均值为 $2.0$，因此所有偏差 $(x_i - \\bar{x})$ 都为 $0$。总方差为 $0$，所以根据定义，莫兰指数 I 为 $0.0$。每种类型的方差也为 $0.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import euclidean\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and generate the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"mask\": np.array([\n                [1, 1, 2, 2, 0],\n                [1, 1, 2, 2, 0],\n                [0, 0, 0, 0, 0],\n                [3, 3, 4, 4, 0],\n                [3, 3, 4, 4, 0]\n            ]),\n            \"pixel_size\": 1.0,\n            \"neighbor_radius\": 3.0,\n            \"type_map\": {1: \"A\", 2: \"B\", 3: \"A\", 4: \"B\"},\n            \"intensity_map\": {1: 1.0, 2: 2.5, 3: 1.5, 4: 3.0}\n        },\n        {\n            \"mask\": np.array([\n                [1, 1, 2, 2, 0],\n                [1, 1, 2, 2, 0],\n                [0, 0, 0, 0, 0],\n                [3, 3, 4, 4, 0],\n                [3, 3, 4, 4, 0]\n            ]),\n            \"pixel_size\": 1.0,\n            \"neighbor_radius\": 1.0,\n            \"type_map\": {1: \"A\", 2: \"B\", 3: \"A\", 4: \"B\"},\n            \"intensity_map\": {1: 1.0, 2: 2.5, 3: 1.5, 4: 3.0}\n        },\n        {\n            \"mask\": np.array([\n                [1, 1, 2, 2, 0],\n                [1, 1, 2, 2, 0],\n                [0, 0, 0, 0, 0],\n                [3, 3, 4, 4, 0],\n                [3, 3, 4, 4, 0]\n            ]),\n            \"pixel_size\": 1.0,\n            \"neighbor_radius\": 3.0,\n            \"type_map\": {1: \"A\", 2: \"B\", 3: \"A\", 4: \"B\"},\n            \"intensity_map\": {1: 2.0, 2: 2.0, 3: 2.0, 4: 2.0}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(\n            case[\"mask\"],\n            case[\"pixel_size\"],\n            case[\"neighbor_radius\"],\n            case[\"type_map\"],\n            case[\"intensity_map\"]\n        )\n        results.append(result)\n\n    # Format output according to specification\n    # str() on a list correctly formats it with brackets, e.g., '[1.0, 2.0]'\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef process_case(segmentation_mask, pixel_size, neighbor_radius, type_map, intensity_map):\n    \"\"\"\n    Processes a single test case to compute statistics and spatial autocorrelation.\n    \"\"\"\n    # Step 1: Collect cell data and compute centroids\n    cell_pixels = {}\n    rows, cols = segmentation_mask.shape\n    for i in range(rows):\n        for j in range(cols):\n            cell_id = segmentation_mask[i, j]\n            if cell_id > 0:\n                if cell_id not in cell_pixels:\n                    cell_pixels[cell_id] = []\n                cell_pixels[cell_id].append((i, j))\n\n    cell_ids = sorted(cell_pixels.keys())\n    centroids = {}\n    for cell_id in cell_ids:\n        pixel_coords = np.array(cell_pixels[cell_id])\n        # Centroid in pixel index space\n        mean_pixel_idx = np.mean(pixel_coords, axis=0)\n        # Convert to physical coordinates\n        centroid_phys = (mean_pixel_idx + 0.5) * pixel_size\n        centroids[cell_id] = centroid_phys\n    \n    # Step 2: Compute per-type statistics\n    type_data = {}\n    for cell_id in cell_ids:\n        cell_type = type_map[cell_id]\n        if cell_type not in type_data:\n            type_data[cell_type] = []\n        type_data[cell_type].append(intensity_map[cell_id])\n\n    sorted_types = sorted(type_data.keys())\n    type_means = []\n    type_vars = []\n    for cell_type in sorted_types:\n        intensities = np.array(type_data[cell_type], dtype=float)\n        type_means.append(np.mean(intensities))\n        if len(intensities) > 1:\n            # ddof=1 for unbiased sample variance\n            type_vars.append(np.var(intensities, ddof=1))\n        else:\n            type_vars.append(0.0)\n\n    # Step 3: Compute spatial autocorrelation (Moran's I)\n    num_cells = len(cell_ids)\n    if num_cells  2:\n        moran_i = 0.0\n    else:\n        intensities_all = np.array([intensity_map[cid] for cid in cell_ids], dtype=float)\n        mean_intensity_all = np.mean(intensities_all)\n        deviations = intensities_all - mean_intensity_all\n        sum_sq_dev = np.sum(deviations**2)\n\n        if sum_sq_dev == 0:\n            moran_i = 0.0\n        else:\n            total_weight = 0.0\n            moran_numerator = 0.0\n\n            for i in range(num_cells):\n                for j in range(num_cells):\n                    if i == j:\n                        continue\n                    \n                    id_i = cell_ids[i]\n                    id_j = cell_ids[j]\n                    \n                    dist = euclidean(centroids[id_i], centroids[id_j])\n                    \n                    weight = 0.0\n                    if dist = neighbor_radius and dist > 0: # dist > 0 is implicit with i!=j\n                        # Inverse distance weight\n                        weight = 1.0 / dist\n                    \n                    total_weight += weight\n                    moran_numerator += weight * deviations[i] * deviations[j]\n\n            if total_weight == 0:\n                moran_i = 0.0\n            else:\n                moran_i = (num_cells / total_weight) * (moran_numerator / sum_sq_dev)\n\n    return [type_means, type_vars, moran_i]\n\nsolve()\n```", "id": "4315652"}, {"introduction": "在空间组学分析中，一个主要目标是根据分子特征将组织切片分割成具有生物学意义的功能域。这个问题可以通过构建一个马尔可夫随机场（MRF）模型，并将其转化为一个能量最小化问题来解决，该模型旨在平衡数据保真度与空间平滑性。这项高级练习 [@problem_id:4315740] 将让您亲身体验这种强大的建模技术，并通过调整正则化参数 $\\beta$ 来探索在拟合数据和强制执行空间连续域之间的权衡。", "problem": "您将执行一个组织的空间分割任务。该组织由一个矩形网格图表示，其中节点对应于测量位置（斑点），标签对应于假定的组织区域。每个斑点的测量值是一个二维向量，代表两种标记基因的丰度。分割被定义为一个标签向量 $z \\in \\{0,1,2\\}^N$，它最小化能量\n$$\nE(z;\\beta) \\;=\\; \\sum_{i=1}^{N} \\ell_i(z_i) \\;+\\; \\beta \\sum_{(i,j)\\in \\mathcal{E}} \\mathbb{1}[z_i \\neq z_j],\n$$\n其中 $N$ 是斑点数量，$\\mathcal{E}$ 是 4-邻域网格的无向边集合，$\\beta \\ge 0$ 是一个加权空间平滑度的标量正则化参数，$\\mathbb{1}[\\cdot]$ 是指示函数。项 $\\ell_i(k)$ 是在具有已知类原型的各向同性高斯观测模型下，如果斑点 $i$ 属于标签 $k$，观测到该斑点数据的负对数似然。具体来说，假设\n$$\n\\ell_i(k) \\;=\\; \\frac{1}{2 \\sigma^2} \\,\\| y_i - \\mu_k \\|_2^2,\n$$\n其中 $y_i \\in \\mathbb{R}^2$ 是在斑点 $i$ 观测到的表达向量，$\\mu_k \\in \\mathbb{R}^2$ 是标签 $k$ 的原型（类均值），$\\sigma^2  0$ 是已知方差。在整个问题中，使用 $\\sigma^2 = 1$（无量纲单位）。\n\n使用以下固定数据：\n- 网格大小：$3 \\times 3$，因此 $N = 9$。使用行主序索引：对于行 $r \\in \\{0,1,2\\}$ 和列 $c \\in \\{0,1,2\\}$，节点索引为 $i = 3r + c \\in \\{0,1,\\dots,8\\}$。\n- 邻接关系 $\\mathcal{E}$：网格上的无向 4-邻域（仅水平和垂直邻居）。\n- 类原型 (均值)：$\\mu_0 = (0,0)$, $\\mu_1 = (3,0)$, $\\mu_2 = (0,3)$。\n- 观测值 $y_i$（对于 $i=0,\\dots,8$，按行主序排列）：\n  - $y_0 = (0.2,-0.1)$, $y_1 = (1.8,0.2)$, $y_2 = (3.1,-0.2)$,\n  - $y_3 = (0.1,0.2)$, $y_4 = (1.8,1.5)$, $y_5 = (2.7,0.4)$,\n  - $y_6 = (0.1,3.1)$, $y_7 = (0.2,2.1)$, $y_8 = (-0.1,2.9)$。\n\n您的任务是编写一个完整、可运行的程序，对于下面指定的测试套件中的每个 $\\beta$，计算一个全局最优标签\n$$\nz^\\star(\\beta) \\in \\arg\\min_{z \\in \\{0,1,2\\}^9} E(z;\\beta),\n$$\n以及相应的最小化能量 $E^\\star(\\beta) = E(z^\\star(\\beta);\\beta)$，连同不一致邻居对的数量\n$$\nM^\\star(\\beta) \\;=\\; \\sum_{(i,j)\\in \\mathcal{E}} \\mathbb{1}\\big[z^\\star(\\beta)_i \\neq z^\\star(\\beta)_j\\big].\n$$\n如果存在多个最小值点，则返回相对于索引顺序 $i=0,1,\\dots,8$ 字典序最小的标签。这里的字典序意味着，如果存在最小索引 $i$ 使得 $z_i \\neq \\tilde{z}_i$ 且 $z_i  \\tilde{z}_i$，则 $z \\prec \\tilde{z}$。\n\n除了报告 $E^\\star(\\beta)$ 和 $M^\\star(\\beta)$ 之外，还需通过使用汉明距离比较连续 $\\beta$ 值的最优标签来评估对 $\\beta$ 的敏感性。对于两个标签 $z, \\tilde{z} \\in \\{0,1,2\\}^9$，定义汉明距离\n$$\nH(z,\\tilde{z}) \\;=\\; \\sum_{i=0}^{8} \\mathbb{1}[z_i \\neq \\tilde{z}_i].\n$$\n\n正则化参数测试套件：\n- $\\beta \\in \\{0.0, 0.4, 1.2, 10.0\\}$。\n\n程序要求：\n- 对于测试套件中的每个 $\\beta$，通过求解 $3 \\times 3$ 网格上的离散最小化问题来精确计算 $E^\\star(\\beta)$ 和 $M^\\star(\\beta)$。\n- 使用指定的数据和定义，不进行任何近似。\n- 如果出现平局，执行上述定义的字典序平局决胜规则。\n- 计算测试套件中连续 $\\beta$ 值的最优标签之间的汉明距离，即 $H\\big(z^\\star(0.0), z^\\star(0.4)\\big)$、$H\\big(z^\\star(0.4), z^\\star(1.2)\\big)$ 和 $H\\big(z^\\star(1.2), z^\\star(10.0)\\big)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。\n- 该列表必须按顺序包含：\n  1. 对于 $\\beta = 0.0, 0.4, 1.2, 10.0$ 的四个最小化能量 $E^\\star(\\beta)$，每个都四舍五入到三位小数并表示为十进制数。\n  2. 对应相同 $\\beta$ 值且顺序相同的四个整数 $M^\\star(\\beta)$。\n  3. 如上所述的连续最优标签之间的三个汉明距离整数。\n- 例如，输出格式应如下所示：$[e_1,e_2,e_3,e_4,m_1,m_2,m_3,m_4,h_{12},h_{23},h_{34}]$，其中 $e_i$ 是四舍五入到三位小数的浮点数，$m_i,h_{ij}$ 是整数。", "solution": "用户希望我解决一个离散优化问题，以在 $3 \\times 3$ 网格上执行空间分割。\n\n### 问题验证\n\n我将首先根据指定标准验证问题陈述。\n\n**步骤 1：提取给定信息**\n\n- **能量函数：** 目标是找到一个标签向量 $z \\in \\{0,1,2\\}^N$ 来最小化能量\n$$\nE(z;\\beta) = \\sum_{i=1}^{N} \\ell_i(z_i) + \\beta \\sum_{(i,j)\\in \\mathcal{E}} \\mathbb{1}[z_i \\neq z_j]\n$$\n- **网格和标签：** 网格为 $3 \\times 3$，所以斑点数量为 $N = 9$。标签 $z_i$ 属于集合 $\\{0, 1, 2\\}$。\n- **索引：** 使用行主序索引：对于行 $r \\in \\{0,1,2\\}$ 和列 $c \\in \\{0,1,2\\}$，节点索引为 $i = 3r + c$。\n- **邻域：** $\\mathcal{E}$ 是 4-邻域网格的无向边集合（水平和垂直邻居）。\n- **正则化：** $\\beta \\ge 0$ 是一个标量正则化参数。\n- **一元项（数据成本）：** 负对数似然为 $\\ell_i(k) = \\frac{1}{2 \\sigma^2} \\| y_i - \\mu_k \\|_2^2$，基于各向同性高斯模型。\n- **模型参数：**\n    - 方差：$\\sigma^2 = 1$（无量纲）。\n    - 类原型：$\\mu_0 = (0,0)$, $\\mu_1 = (3,0)$, $\\mu_2 = (0,3)$。\n- **观测数据 ($y_i$)：**\n    - $y_0 = (0.2,-0.1)$, $y_1 = (1.8,0.2)$, $y_2 = (3.1,-0.2)$\n    - $y_3 = (0.1,0.2)$, $y_4 = (1.8,1.5)$, $y_5 = (2.7,0.4)$\n    - $y_6 = (0.1,3.1)$, $y_7 = (0.2,2.1)$, $y_8 = (-0.1,2.9)$\n- **任务：**\n    - 为每个给定的 $\\beta$ 找到全局最优标签 $z^\\star(\\beta)$。\n    - 如果存在多个最小值点，选择字典序最小的标签。\n    - 计算最小化能量 $E^\\star(\\beta) = E(z^\\star(\\beta);\\beta)$。\n    - 计算不一致邻居的数量 $M^\\star(\\beta) = \\sum_{(i,j)\\in \\mathcal{E}} \\mathbb{1}[z^\\star(\\beta)_i \\neq z^\\star(\\beta)_j]$。\n    - 计算连续 $\\beta$ 值的最优标签之间的汉明距离 $H(z,\\tilde{z}) = \\sum_{i=0}^{8} \\mathbb{1}[z_i \\neq \\tilde{z}_i]$。\n- **测试套件：** $\\beta \\in \\{0.0, 0.4, 1.2, 10.0\\}$。\n- **输出格式：** 一个逗号分隔的列表 `[e1,e2,e3,e4,m1,m2,m3,m4,h12,h23,h34]`，其中 `e` 值为四舍五入到三位小数的能量值。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n- **科学依据：** 该问题描述了马尔可夫随机场 (MRF) 的能量最小化，具体来说是 Potts 模型，这是图像处理、计算机视觉和空间数据分析中的一项标准和基础技术。将其应用于空间“组学”数据是系统生物医学中一个相关且现代的用例。该模型在科学上是合理的。\n- **适定性：** 该问题是在一个有限状态集上找到一个函数的最小值。所有可能标签 $z$ 的集合大小为 $3^9 = 19,683$。由于定义域是有限的，因此保证存在最小能量值。指定的字典序平局决胜规则确保了选择唯一的最佳标签 $z^\\star(\\beta)$。因此，该问题是适定的。\n- **客观性：** 该问题用精确的数学定义和客观的数值数据进行了陈述。所用术语没有歧义。\n\n**缺陷清单：**\n1.  **科学或事实上的不健全：** 无。该模型是标准的。\n2.  **无法形式化或不相关：** 无。该问题已完全形式化，并与指定领域相关。\n3.  **不完整或矛盾的设置：** 无。所有必要信息（网格结构、模型参数、数据）均已提供。\n4.  **不切实际或不可行：** 无。所选的网格大小（$3 \\times 3$）使得通过穷举搜索解决该问题在计算上是可行的。数据值是合理的。\n5.  **不适定或结构不良：** 无。保证存在唯一解。\n6.  **伪深刻、微不足道或同义反复：** 无。虽然可以通过暴力破解解决，但该问题需要仔细实现模型和搜索过程，并且它阐释了数据保真度项和空间平滑先验之间的基本权衡，这是一个核心概念。\n7.  **超出科学可验证性范围：** 无。结果是确定性的，可以通过独立实现进行验证。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。我将继续提供解决方案。\n\n### 基于原则的解决方案设计\n\n该问题要求找到标签向量 $z \\in \\{0, 1, 2\\}^9$，以全局最小化能量函数 $E(z; \\beta)$。这是一个离散优化问题。鉴于配置空间很小（$3^9 = 19,683$ 种可能的标签），可以使用穷举搜索（暴力）算法可靠且精确地找到全局最小值。\n\n算法流程如下：\n\n1.  **数据项的预计算：** 能量函数 $E(z; \\beta)$ 由数据项 $\\sum_{i} \\ell_i(z_i)$ 和平滑项 $\\beta \\sum_{(i,j)} \\mathbb{1}[z_i \\neq z_j]$ 组成。对于每个斑点 $i$ 和每个可能的标签 $k \\in \\{0, 1, 2\\}$，数据项 $\\ell_i(k)$ 独立于其他斑点的标签和参数 $\\beta$。我们可以预先计算这些值并将它们存储在一个 $9 \\times 3$ 的矩阵 $L$ 中，其中 $L_{ik} = \\ell_i(k)$。当 $\\sigma^2=1$ 时，公式为：\n    $$\n    L_{ik} = \\ell_i(k) = \\frac{1}{2} \\|y_i - \\mu_k\\|_2^2\n    $$\n    那么，对于给定的标签 $z = (z_0, \\dots, z_8)$，总数据项为 $\\sum_{i=0}^{8} L_{i, z_i}$。\n\n2.  **邻域定义：** $3 \\times 3$ 网格上的 4-邻域结构是固定的。我们定义连接相邻斑点（水平和垂直）的边集 $\\mathcal{E}$。共有 12 条这样的唯一边。\n\n3.  **对每个 $\\beta$ 进行穷举搜索：** 对于测试套件 $\\{0.0, 0.4, 1.2, 10.0\\}$ 中的每个 $\\beta$ 值，我们对所有 $3^9$ 种可能的标签进行搜索。\n    - 我们将迭代每一种可能的标签 $z$。Python 中的 `itertools.product` 函数非常适合此任务，因为它会按字典序生成所有组合。\n    - 对于每个标签 $z$，我们计算其总能量：\n        a. 数据项通过对预计算的值求和得到：$D(z) = \\sum_{i=0}^{8} L_{i, z_i}$。\n        b. 平滑项的不一致计数计算如下：$M(z) = \\sum_{(i,j) \\in \\mathcal{E}} \\mathbb{1}[z_i \\neq z_j]$。\n        c. 总能量为 $E(z;\\beta) = D(z) + \\beta \\cdot M(z)$。\n    - 我们维护一个运行中的最小能量 `min_energy` 和对应的最优标签 `best_z`。\n    - 当评估一个能量为 $E(z;\\beta)$ 的标签 $z$ 时，我们将其与 `min_energy` 进行比较。如果 $E(z;\\beta)  \\text{min\\_energy}$，我们就将 `min_energy` 更新为 $E(z;\\beta)$，并将 `best_z` 更新为 $z$。\n    - **平局决胜：** 问题指定，在能量相等的情况下，应选择字典序最小的标签。通过按字典序（如 `itertools.product` 所做）迭代标签，并且仅在*严格*不等式 (``) 成立时更新 `best_z`，我们自动满足了此平局决胜规则。找到的第一个最小值点将是字典序最小的。\n\n4.  **计算输出：**\n    - 在完成对给定 $\\beta$ 的穷举搜索后，最终的 `min_energy` 就是 $E^\\star(\\beta)$，最终的 `best_z` 就是 $z^\\star(\\beta)$。\n    - 然后，我们通过计算最终 $z^\\star(\\beta)$ 中的不一致数量来计算 $M^\\star(\\beta)$。\n    - 我们存储每个 $z^\\star(\\beta)$ 以便稍后计算汉明距离。\n\n5.  **敏感性分析：** 在计算完所有 $\\beta$ 值的最优标签 $z^\\star(\\beta)$ 后，我们计算测试套件中连续 $\\beta$ 值的解之间的汉明距离：$H(z^\\star(0.0), z^\\star(0.4))$、$H(z^\\star(0.4), z^\\star(1.2))$ 和 $H(z^\\star(1.2), z^\\star(10.0))$。汉明距离 $H(z, \\tilde{z})$ 是标签不同的位置数量。\n\n6.  **最终格式化：** 计算出的值——四个能量 $E^\\star(\\beta)$、四个不一致计数 $M^\\star(\\beta)$ 和三个汉明距离——被收集到一个列表中。能量值四舍五入到三位小数，所有值都被格式化为所需的逗号分隔字符串。", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the spatial segmentation problem by finding the optimal labeling that minimizes the energy function\n    for a given set of regularization parameters (beta).\n    \"\"\"\n\n    # 1. Define problem data and constants from the problem statement.\n    y_obs = np.array([\n        [0.2, -0.1], [1.8, 0.2], [3.1, -0.2],\n        [0.1, 0.2], [1.8, 1.5], [2.7, 0.4],\n        [0.1, 3.1], [0.2, 2.1], [-0.1, 2.9]\n    ])\n    mu_prototypes = np.array([[0.0, 0.0], [3.0, 0.0], [0.0, 3.0]])\n    beta_values = [0.0, 0.4, 1.2, 10.0]\n    sigma_sq = 1.0\n    N = 9  # Number of spots (3x3 grid)\n    K = 3  # Number of labels {0, 1, 2}\n\n    # 2. Define grid structure: edges for a 4-neighborhood on a 3x3 grid\n    # using 0-indexed row-major nodes 0..8.\n    # Grid: 0 1 2\n    #       3 4 5\n    #       6 7 8\n    edges = [\n        (0, 1), (1, 2),  # Horizontal edges\n        (3, 4), (4, 5),\n        (6, 7), (7, 8),\n        (0, 3), (1, 4), (2, 5),  # Vertical edges\n        (3, 6), (4, 7), (5, 8)\n    ]\n\n    # 3. Pre-compute the data term matrix L, where L[i,k] = l_i(k).\n    # l_i(k) = (1 / (2*sigma^2)) * ||y_i - mu_k||_2^2\n    data_cost_matrix = np.zeros((N, K))\n    for i in range(N):\n        for k in range(K):\n            dist_sq = np.sum((y_obs[i] - mu_prototypes[k])**2)\n            data_cost_matrix[i, k] = 0.5 / sigma_sq * dist_sq\n\n    # 4. Initialize lists to store results for each beta.\n    optimal_labelings = []\n    e_stars = []\n    m_stars = []\n\n    # 5. Iterate over beta values and find the optimal labeling for each.\n    for beta in beta_values:\n        min_energy = float('inf')\n        best_z = None\n\n        # Iterate through all 3^9 = 19,683 possible labelings.\n        # itertools.product generates tuples in lexicographical order.\n        # This handles the tie-breaking rule if we update only on strictly smaller energy.\n        for z in itertools.product(range(K), repeat=N):\n            # Calculate data term using the pre-computed matrix.\n            data_energy = np.sum(data_cost_matrix[np.arange(N), z])\n\n            # Calculate the number of disagreeing neighbors.\n            disagreements = 0\n            for i, j in edges:\n                if z[i] != z[j]:\n                    disagreements += 1\n\n            total_energy = data_energy + beta * disagreements\n\n            if total_energy  min_energy:\n                min_energy = total_energy\n                best_z = z\n\n        # Store results for this beta value.\n        e_stars.append(min_energy)\n        optimal_labelings.append(np.array(best_z))\n        \n        # Calculate M_star for the found optimal labeling.\n        m_star_val = 0\n        for i, j in edges:\n            if best_z[i] != best_z[j]:\n                m_star_val += 1\n        m_stars.append(m_star_val)\n\n    # 6. Calculate Hamming distances between consecutive optimal labelings.\n    h_distances = []\n    for i in range(len(optimal_labelings) - 1):\n        z1 = optimal_labelings[i]\n        z2 = optimal_labelings[i+1]\n        h_dist = np.sum(z1 != z2)\n        h_distances.append(int(h_dist))\n\n    # 7. Format and print the final output as a single line.\n    # Energies must be rounded to three decimal places.\n    formatted_energies = [f\"{e:.3f}\" for e in e_stars]\n    \n    # Combine all results into a single list in the specified order.\n    # [E_vals, M_vals, H_vals]\n    final_results = formatted_energies + m_stars + h_distances\n    \n    # Print in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\n# Execute the solver function.\nsolve()\n```", "id": "4315740"}]}