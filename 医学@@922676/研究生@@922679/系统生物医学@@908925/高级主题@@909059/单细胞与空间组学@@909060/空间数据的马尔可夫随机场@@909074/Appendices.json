{"hands_on_practices": [{"introduction": "要掌握复杂模型，我们首先需要从一个简单且可精确求解的案例入手。本练习将带领我们回到统计力学的基础，通过一个$2 \\times 2$的伊辛模型来实践马尔可夫随机场（MRF）的核心概念。通过手动枚举所有可能的状态来计算配分函数$Z(\\beta,h,J)$，你将具体地理解宏观可观测量（如磁化强度和相关性）是如何从微观相互作用中涌现的，这是所有MRF模型及其在系统生物医学应用中的基石 [@problem_id:4359348]。", "problem": "考虑一个用于系统生物医学中组织微阵列分析的二元空间模型，其中每个位点编码一种二元细胞状态（例如，上调与下调），该模型被建模为一个成对马尔可夫随机场（MRF）。此MRF由一个具有自由边界的 $2 \\times 2$ 晶格上的伊辛模型指定：四个自旋 $s_{11}, s_{12}, s_{21}, s_{22} \\in \\{-1, +1\\}$ 仅与晶格内的最近邻相互作用，耦合强度为 $J \\in \\mathbb{R}$，外场为 $h \\in \\mathbb{R}$。设逆温度为 $\\beta  0$。哈密顿量由基本的吉布斯构造给出\n$$\nH(\\mathbf{s}) \\;=\\; - J \\sum_{\\langle (i,j),(k,\\ell) \\rangle} s_{ij} s_{k\\ell} \\;-\\; h \\sum_{(i,j)} s_{ij},\n$$\n其中相互作用和是对 $2 \\times 2$ 网格内的四个最近邻对进行的，即 $\\langle (1,1),(1,2) \\rangle$、$\\langle (1,1),(2,1) \\rangle$、$\\langle (1,2),(2,2) \\rangle$ 和 $\\langle (2,1),(2,2) \\rangle$。相应的吉布斯分布为\n$$\np(\\mathbf{s}) \\;=\\; \\frac{1}{Z(\\beta,h,J)} \\exp\\!\\big(-\\beta H(\\mathbf{s})\\big),\n$$\n其中配分函数 $Z(\\beta,h,J)$ 对 $p(\\mathbf{s})$ 进行归一化。\n\n仅从上述基本定义和吉布斯分布及 $p(\\mathbf{s})$ 下期望的第一性原理出发，完成以下任务：\n- 通过以科学上一致的方式正确计算所有 $2^4$ 种自旋构型，精确计算具有自由边界的 $2 \\times 2$ 伊辛模型的配分函数 $Z(\\beta,h,J)$。\n- 使用 $p(\\mathbf{s})$ 下的期望定义，并且不调用任何预先推导的快捷恒等式，通过与枚举求和进行显式比较，验证连接宏观可观测量与配分函数的导数关系，即总磁化强度 $\\left\\langle \\sum_{(i,j)} s_{ij} \\right\\rangle$ 等于 $\\frac{\\partial \\ln Z(\\beta,h,J)}{\\partial (\\beta h)}$，以及总最近邻相关性 $\\left\\langle \\sum_{\\langle (i,j),(k,\\ell) \\rangle} s_{ij} s_{k\\ell} \\right\\rangle$ 等于 $\\frac{\\partial \\ln Z(\\beta,h,J)}{\\partial (\\beta J)}$。\n\n将您的最终答案表示为 $Z(\\beta,h,J)$ 的单个闭式解析表达式。无需四舍五入。", "solution": "该问题要求精确计算一个具有自由边界的 $2 \\times 2$ 伊辛模型的配分函数，并从第一性原理验证两个基本的热力学恒等式。\n\n该模型包含四个自旋 $s_{11}, s_{12}, s_{21}, s_{22} \\in \\{-1, +1\\}$。系统的状态由向量 $\\mathbf{s} = (s_{11}, s_{12}, s_{21}, s_{22})$ 给出。总共有 $2^4 = 16$ 种可能的构型。\n\n哈密顿量由下式给出\n$$ H(\\mathbf{s}) = - J \\sum_{\\langle (i,j),(k,\\ell) \\rangle} s_{ij} s_{k\\ell} - h \\sum_{(i,j)} s_{ij} $$\n最近邻求和涉及四对：$\\langle (1,1),(1,2) \\rangle$、$\\langle (1,1),(2,1) \\rangle$、$\\langle (1,2),(2,2) \\rangle$ 和 $\\langle (2,1),(2,2) \\rangle$。我们定义总相互作用能为 $E_{\\text{int}}(\\mathbf{s}) = s_{11}s_{12} + s_{11}s_{21} + s_{12}s_{22} + s_{21}s_{22}$，总磁化强度为 $M(\\mathbf{s}) = s_{11} + s_{12} + s_{21} + s_{22}$。哈密顿量可以写成\n$$ H(\\mathbf{s}) = -J E_{\\text{int}}(\\mathbf{s}) - h M(\\mathbf{s}) $$\n吉布斯分布为 $p(\\mathbf{s}) = \\frac{1}{Z} \\exp(-\\beta H(\\mathbf{s}))$，其中 $Z$ 是配分函数。令 $K = \\beta J$ 和 $B = \\beta h$。一个构型 $\\mathbf{s}$ 的未归一化概率权重为\n$$ \\exp(-\\beta H(\\mathbf{s})) = \\exp(\\beta J E_{\\text{int}}(\\mathbf{s}) + \\beta h M(\\mathbf{s})) = \\exp(K E_{\\text{int}}(\\mathbf{s}) + B M(\\mathbf{s})) $$\n配分函数 $Z$ 是所有16种构型的这些权重之和：\n$$ Z(\\beta, h, J) = \\sum_{\\mathbf{s}} \\exp(K E_{\\text{int}}(\\mathbf{s}) + B M(\\mathbf{s})) $$\n\n**第一部分：配分函数的计算**\n为了计算 $Z$，我们枚举所有16种自旋构型，并根据 $M(\\mathbf{s})$ 和 $E_{\\text{int}}(\\mathbf{s})$ 的值将它们分组。\n\n1.  **所有自旋向上排列：**\n    -   构型：$(+1, +1, +1, +1)$。\n    -   构型数：$1$。\n    -   $M = 1+1+1+1 = 4$。\n    -   $E_{\\text{int}} = 1 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 1 = 4$。\n    -   对 $Z$ 的贡献：$\\exp(4K + 4B)$。\n\n2.  **三个自旋向上，一个自旋向下：**\n    -   构型如 $(-1, +1, +1, +1)$。根据对称性，所有四个位置都是等价的。\n    -   构型数：$\\binom{4}{1} = 4$。\n    -   $M = 1+1+1-1 = 2$。\n    -   $E_{\\text{int}}$ (对于 $\\mathbf{s}=(-1, +1, +1, +1)$)：$(-1)\\cdot 1 + (-1)\\cdot 1 + 1\\cdot 1 + 1\\cdot 1 = -1-1+1+1 = 0$。\n    -   对 $Z$ 的贡献：$4 \\exp(0 \\cdot K + 2B) = 4 \\exp(2B)$。\n\n3.  **两个自旋向上，两个自旋向下：**\n    -   构型数：$\\binom{4}{2} = 6$。\n    -   $M = 1+1-1-1 = 0$，因此在 $Z$ 中的项与 $B$ 无关。\n    -   我们必须根据向下自旋的相对位置区分两种情况：\n        a.  **相邻自旋向下：** 例如，$(-1, -1, +1, +1)$。两个向下自旋共享一条边。有 $4$ 种这样的构型（两对水平，两对垂直）。\n            -   $E_{\\text{int}}$ (对于 $\\mathbf{s}=(-1, -1, +1, +1)$)：$(-1)\\cdot(-1) + (-1)\\cdot 1 + (-1)\\cdot 1 + 1\\cdot 1 = 1-1-1+1 = 0$。\n            -   对 $Z$ 的贡献：$4 \\exp(0 \\cdot K + 0 \\cdot B) = 4$。\n        b.  **对角自旋向下：** 例如，$(-1, +1, +1, -1)$。两个向下自旋位于对角线上。有 $2$ 种这样的构型。\n            -   $E_{\\text{int}}$ (对于 $\\mathbf{s}=(-1, +1, +1, -1)$)：$(-1)\\cdot 1 + (-1)\\cdot 1 + 1\\cdot(-1) + 1\\cdot(-1) = -1-1-1-1 = -4$。\n            -   对 $Z$ 的贡献：$2 \\exp(-4K + 0 \\cdot B) = 2 \\exp(-4K)$。\n\n4.  **一个自旋向上，三个自旋向下：**\n    -   构型如 $(+1, -1, -1, -1)$。根据自旋翻转对称性，与一个自旋向下的情况对称。\n    -   构型数：$\\binom{4}{3} = 4$。\n    -   $M = -1-1-1+1 = -2$。\n    -   $E_{\\text{int}}$ (对于 $\\mathbf{s}=(+1, -1, -1, -1)$)：$1\\cdot(-1) + 1\\cdot(-1) + (-1)\\cdot(-1) + (-1)\\cdot(-1) = -1-1+1+1 = 0$。\n    -   对 $Z$ 的贡献：$4 \\exp(0 \\cdot K - 2B) = 4 \\exp(-2B)$。\n\n5.  **所有自旋向下排列：**\n    -   构型：$(-1, -1, -1, -1)$。\n    -   构型数：$1$。\n    -   $M = -1-1-1-1 = -4$。\n    -   $E_{\\text{int}} = (-1)\\cdot(-1) + (-1)\\cdot(-1) + (-1)\\cdot(-1) + (-1)\\cdot(-1) = 4$。\n    -   对 $Z$ 的贡献：$\\exp(4K - 4B)$。\n\n对所有贡献求和：\n$Z(K,B) = \\exp(4K + 4B) + 4\\exp(2B) + 4 + 2\\exp(-4K) + 4\\exp(-2B) + \\exp(4K - 4B)$。\n我们可以通过组合项并使用双曲余弦的定义 $\\cosh(x) = \\frac{\\exp(x) + \\exp(-x)}{2}$ 来简化此表达式。\n$Z(K,B) = [\\exp(4K + 4B) + \\exp(4K - 4B)] + [4\\exp(2B) + 4\\exp(-2B)] + 4 + 2\\exp(-4K)$\n$Z(K,B) = \\exp(4K)[\\exp(4B) + \\exp(-4B)] + 4[\\exp(2B) + \\exp(-2B)] + 4 + 2\\exp(-4K)$\n$Z(K,B) = 2\\exp(4K)\\cosh(4B) + 8\\cosh(2B) + 4 + 2\\exp(-4K)$。\n将 $K = \\beta J$ 和 $B = \\beta h$ 代回：\n$$ Z(\\beta, h, J) = 2\\exp(4\\beta J)\\cosh(4\\beta h) + 8\\cosh(2\\beta h) + 4 + 2\\exp(-4\\beta J) $$\n\n**第二部分：导数恒等式的验证**\n该问题要求通过显式比较期望值（通过枚举计算）和 $\\ln Z$ 的导数来验证两个恒等式。\n\n**恒等式1：总磁化强度**\n我们必须验证 $\\langle M \\rangle = \\frac{\\partial \\ln Z}{\\partial B}$。\n\n首先，我们计算右侧（RHS），即 $\\ln Z$ 的导数。\n$\\text{RHS} = \\frac{\\partial \\ln Z}{\\partial B} = \\frac{1}{Z} \\frac{\\partial Z}{\\partial B}$。\n$$ \\frac{\\partial Z}{\\partial B} = \\frac{\\partial}{\\partial B} \\left[ 2e^{4K}\\cosh(4B) + 8\\cosh(2B) + 4 + 2e^{-4K} \\right] $$\n$$ \\frac{\\partial Z}{\\partial B} = 2e^{4K} [4\\sinh(4B)] + 8 [2\\sinh(2B)] = 8e^{4K}\\sinh(4B) + 16\\sinh(2B) $$\n所以，$\\text{RHS} = \\frac{8e^{4K}\\sinh(4B) + 16\\sinh(2B)}{Z}$。\n\n接下来，我们从第一性原理计算左侧（LHS）。总磁化强度的期望为 $\\langle M \\rangle = \\sum_{\\mathbf{s}} M(\\mathbf{s}) p(\\mathbf{s}) = \\frac{1}{Z} \\sum_{\\mathbf{s}} M(\\mathbf{s}) \\exp(K E_{\\text{int}}(\\mathbf{s}) + B M(\\mathbf{s}))$。我们使用之前的分类来计算总和 $\\sum_{\\mathbf{s}} M(\\mathbf{s}) \\exp(\\dots)$：\n-   $1$ 个构型，$M=4$：$1 \\cdot (4) \\cdot \\exp(4K+4B) = 4\\exp(4K+4B)$。\n-   $4$ 个构型，$M=2$：$4 \\cdot (2) \\cdot \\exp(2B) = 8\\exp(2B)$。\n-   $6$ 个构型，$M=0$：$6 \\cdot (0) \\cdot (\\dots) = 0$。\n-   $4$ 个构型，$M=-2$：$4 \\cdot (-2) \\cdot \\exp(-2B) = -8\\exp(-2B)$。\n-   $1$ 个构型，$M=-4$：$1 \\cdot (-4) \\cdot \\exp(4K-4B) = -4\\exp(4K-4B)$。\n总和是：$4\\exp(4K+4B) + 8\\exp(2B) - 8\\exp(-2B) - 4\\exp(4K-4B)$。\n让我们使用 $\\sinh(x) = \\frac{\\exp(x) - \\exp(-x)}{2}$ 来简化它：\n总和 $= 4e^{4K}(e^{4B} - e^{-4B}) + 8(e^{2B} - e^{-2B})$\n总和 $= 4e^{4K}(2\\sinh(4B)) + 8(2\\sinh(2B)) = 8e^{4K}\\sinh(4B) + 16\\sinh(2B)$。\n所以，$\\text{LHS} = \\langle M \\rangle = \\frac{8e^{4K}\\sinh(4B) + 16\\sinh(2B)}{Z}$。\n比较这两个表达式，我们看到 LHS = RHS，从而验证了该恒等式。\n\n**恒等式2：总最近邻相关性**\n我们必须验证 $\\langle E_{\\text{int}} \\rangle = \\frac{\\partial \\ln Z}{\\partial K}$。\n\n首先，右侧（RHS）：\n$\\text{RHS} = \\frac{\\partial \\ln Z}{\\partial K} = \\frac{1}{Z} \\frac{\\partial Z}{\\partial K}$。\n$$ \\frac{\\partial Z}{\\partial K} = \\frac{\\partial}{\\partial K} \\left[ 2e^{4K}\\cosh(4B) + 8\\cosh(2B) + 4 + 2e^{-4K} \\right] $$\n$$ \\frac{\\partial Z}{\\partial K} = 2\\cosh(4B) [4e^{4K}] + 2[-4e^{-4K}] = 8e^{4K}\\cosh(4B) - 8e^{-4K} $$\n所以，$\\text{RHS} = \\frac{8e^{4K}\\cosh(4B) - 8e^{-4K}}{Z}$。\n\n接下来，我们通过枚举计算左侧（LHS）：$\\langle E_{\\text{int}} \\rangle = \\frac{1}{Z} \\sum_{\\mathbf{s}} E_{\\text{int}}(\\mathbf{s}) \\exp(K E_{\\text{int}}(\\mathbf{s}) + B M(\\mathbf{s}))$。\n-   $1$ 个构型，$E_{\\text{int}}=4$：$1 \\cdot (4) \\cdot \\exp(4K+4B) = 4\\exp(4K+4B)$。\n-   $4$ 个构型，$E_{\\text{int}}=0$ (来自 $M=2$)：$4 \\cdot (0) \\cdot (\\dots) = 0$。\n-   $4$ 个构型，$E_{\\text{int}}=0$ (来自 $M=0$)：$4 \\cdot (0) \\cdot (\\dots) = 0$。\n-   $2$ 个构型，$E_{\\text{int}}=-4$：$2 \\cdot (-4) \\cdot \\exp(-4K) = -8\\exp(-4K)$。\n-   $4$ 个构型，$E_{\\text{int}}=0$ (来自 $M=-2$)：$4 \\cdot (0) \\cdot (\\dots) = 0$。\n-   $1$ 个构型，$E_{\\text{int}}=4$：$1 \\cdot (4) \\cdot \\exp(4K-4B) = 4\\exp(4K-4B)$。\n总和是：$4\\exp(4K+4B) - 8\\exp(-4K) + 4\\exp(4K-4B)$。\n让我们使用 $\\cosh(x)$ 来简化它：\n总和 $= 4e^{4K}(e^{4B} + e^{-4B}) - 8e^{-4K}$\n总和 $= 4e^{4K}(2\\cosh(4B)) - 8e^{-4K} = 8e^{4K}\\cosh(4B) - 8e^{-4K}$。\n所以，$\\text{LHS} = \\langle E_{\\text{int}} \\rangle = \\frac{8e^{4K}\\cosh(4B) - 8e^{-4K}}{Z}$。\n比较这两个表达式，我们看到 LHS = RHS，从而验证了第二个恒等式。\n\n计算证实了对于这个特定系统，宏观可观测量（平均磁化强度和能量）可以通过对配分函数的对数求导得到，这与统计力学的一般形式相符。问题要求将配分函数的闭式表达式作为最终答案。", "answer": "$$ \\boxed{ 2\\exp(4\\beta J)\\cosh(4\\beta h) + 8\\cosh(2\\beta h) + 4 + 2\\exp(-4\\beta J) } $$", "id": "4359348"}, {"introduction": "接下来，我们从离散模型转向在生物医学成像和空间组学中更为普遍的连续场模型。本练习聚焦于现代空间统计学的主力工具——高斯马尔可夫随机场（GMRF）。你将需要推导单个节点的完整条件分布，这一过程不仅揭示了GMRF中“马尔可夫”性质的精确含义（即条件依赖关系仅限于图上的邻居），同时也是构建吉布斯采样器（Gibbs sampler）这一广泛应用的MCMC推断方法的基础步骤 [@problem_id:4359370]。", "problem": "在空间系统生物医学中，考虑一个被离散化为 $n$ 个空间位置（例如，空间转录组学中的点）的组织域。令 $X \\in \\mathbb{R}^{n}$ 表示单个基因在这些位置上的对数归一化表达向量。假设 $X$ 由一个高斯马尔可夫随机场（GMRF）建模，即一个由均值向量 $\\mu \\in \\mathbb{R}^{n}$ 和一个稀疏、对称正定精度矩阵 $Q \\in \\mathbb{R}^{n \\times n}$ 参数化的多元正态分布，该精度矩阵编码了由空间邻接性引起的条件独立性：\n$$\np(X \\mid \\mu,Q) \\propto |Q|^{1/2} \\exp\\!\\left(-\\frac{1}{2}(X-\\mu)^{\\top} Q (X-\\mu)\\right).\n$$\n当通过图拉普拉斯式先验或相邻位置间的机制性类扩散耦合来惩罚空间粗糙度时，会出现这种设置。\n\n您的任务是：\n- 从上述联合密度出发，且不调用任何预先记忆的条件公式，推导出单个分量 $X_{i}$ 在给定所有其余分量 $X_{-i}$ 下的全条件分布，并用 $Q$ 的元素和 $\\mu$ 的分量明确表示。提供条件均值 $\\mathbb{E}[X_{i}\\mid X_{-i}]$ 和条件方差 $\\operatorname{Var}(X_{i}\\mid X_{-i})$，并解释 $Q$ 中的稀疏性如何将条件集限制为空间邻居。\n- 基于您推导出的条件分布，设计一个单点吉布斯采样器（一种马尔可夫链蒙特卡洛 (MCMC) 方案），通过从其全条件分布中采样来迭代更新每个 $X_{i}$，并解释 $Q$ 的稀疏结构如何带来计算效率。您的设计应根据 $\\mu$、$Q$ 和 $X$ 的当前状态，详细说明一次完整的扫描更新。\n\n作为您报告的最终答案，请陈述条件方差 $\\operatorname{Var}(X_{i}\\mid X_{-i}=x_{-i})$ 的解析表达式，该表达式仅用 $Q$ 的元素表示。无需进行数值评估。最终答案必须是单个闭式表达式。不包含单位。", "solution": "我们从由精度矩阵参数化的多元正态分布的联合密度开始。这是一种经过充分检验的基本表示法：\n$$\np(X \\mid \\mu,Q) \\propto |Q|^{1/2} \\exp\\!\\left(-\\frac{1}{2}(X-\\mu)^{\\top} Q (X-\\mu)\\right),\n$$\n其中 $Q$ 是对称正定的。高斯马尔可夫随机场 (GMRF) 结构由 $Q$ 的稀疏模式编码：如果对于 $i \\neq j$ 有 $Q_{ij} = 0$，那么在给定所有其他分量的情况下，$X_{i}$ 和 $X_{j}$ 是条件独立的，这反映了底层马尔可夫图中一条边的缺失。\n\n为了推导在给定 $X_{-i}$ 时 $X_{i}$ 的全条件分布，我们相对于索引 $i$ 对向量和矩阵进行划分。写出\n$$\nx = \\begin{pmatrix} x_{i} \\\\ x_{-i} \\end{pmatrix}, \\quad \\mu = \\begin{pmatrix} \\mu_{i} \\\\ \\mu_{-i} \\end{pmatrix}, \\quad Q = \\begin{pmatrix} Q_{ii}  Q_{i,-i} \\\\ Q_{-i,i}  Q_{-i,-i} \\end{pmatrix},\n$$\n其中 $Q_{i,-i}$ 表示第 $i$ 行中非对角线元素的 $1 \\times (n-1)$ 行向量，根据对称性有 $Q_{-i,i} = Q_{i,-i}^{\\top}$。定义中心化变量\n$$\nz_{i} = x_{i} - \\mu_{i}, \\quad z_{-i} = x_{-i} - \\mu_{-i}.\n$$\n那么指数中的二次型展开为\n$$\n(x-\\mu)^{\\top} Q (x-\\mu) \\;=\\; \n\\begin{pmatrix} z_{i} \\\\ z_{-i} \\end{pmatrix}^{\\top}\n\\begin{pmatrix} Q_{ii}  Q_{i,-i} \\\\ Q_{-i,i}  Q_{-i,-i} \\end{pmatrix}\n\\begin{pmatrix} z_{i} \\\\ z_{-i} \\end{pmatrix}\n\\;=\\; Q_{ii} z_{i}^{2} + 2 z_{i}\\, Q_{i,-i} z_{-i} + z_{-i}^{\\top} Q_{-i,-i} z_{-i}.\n$$\n当以 $x_{-i}$ 为条件时，只有涉及 $z_{i}$ 的项会影响条件核。因此，在一个与 $z_{i}$ 无关的因子内，\n$$\np(x_{i} \\mid x_{-i},\\mu,Q) \\;\\propto\\; \\exp\\!\\left(-\\frac{1}{2} \\left[ Q_{ii} z_{i}^{2} + 2 z_{i}\\, Q_{i,-i} z_{-i} \\right] \\right).\n$$\n我们现在对 $z_{i}$ 进行配方。令\n$$\na \\;=\\; \\frac{Q_{i,-i} z_{-i}}{Q_{ii}}.\n$$\n那么\n$$\nQ_{ii} z_{i}^{2} + 2 z_{i}\\, Q_{i,-i} z_{-i} \\;=\\; Q_{ii}\\left( z_{i}^{2} + 2 a z_{i} \\right) \\;=\\; Q_{ii}\\left( (z_{i} + a)^{2} - a^{2} \\right).\n$$\n因此，\n$$\np(x_{i} \\mid x_{-i},\\mu,Q) \\;\\propto\\; \\exp\\!\\left( -\\frac{1}{2} Q_{ii} (z_{i} + a)^{2} \\right),\n$$\n省略的因子 $\\exp\\!\\left( \\frac{1}{2} Q_{ii} a^{2} \\right)$ 由于不依赖于 $x_{i}$，被吸收到归一化常数中。识别出单变量正态分布的核，我们得出结论\n$$\nX_{i} \\mid X_{-i}=x_{-i},\\mu,Q \\sim \\mathcal{N}\\!\\left( \\mu_{i} - \\frac{Q_{i,-i} (x_{-i} - \\mu_{-i})}{Q_{ii}}, \\; \\frac{1}{Q_{ii}} \\right).\n$$\n因此，条件均值和方差为\n$$\n\\mathbb{E}[X_{i} \\mid X_{-i}=x_{-i}] \\;=\\; \\mu_{i} \\;-\\; \\frac{1}{Q_{ii}} \\sum_{j \\neq i} Q_{ij} (x_{j} - \\mu_{j}),\n$$\n$$\n\\operatorname{Var}(X_{i} \\mid X_{-i}=x_{-i}) \\;=\\; \\frac{1}{Q_{ii}}.\n$$\n稀疏性解释：如果对于给定的 $j \\neq i$ 有 $Q_{ij} = 0$，那么条件均值中的相应项消失，$x_{j}$ 不会出现在 $X_{i}$ 的条件分布中。因此，只有满足 $Q_{ij} \\neq 0$ 的索引 $j$（即 $i$ 的图邻居）会影响 $X_{i}$ 的条件分布，这就是高斯马尔可夫随机场的马尔可夫性质。\n\n单点吉布斯采样器设计：给定当前状态 $x^{(t)}$，一次更新所有坐标的完整扫描可以按以下方式进行。对于 $i = 1, \\dots, n$，按固定或随机顺序计算\n$$\nm_{i}^{(t)} \\;=\\; \\mu_{i} \\;-\\; \\frac{1}{Q_{ii}} \\sum_{j \\neq i} Q_{ij} \\left( x_{j}^{(\\text{latest})} - \\mu_{j} \\right), \\quad s_{i}^{2} \\;=\\; \\frac{1}{Q_{ii}},\n$$\n然后抽取\n$$\nx_{i}^{(\\text{latest})} \\sim \\mathcal{N}\\!\\left( m_{i}^{(t)}, \\; s_{i}^{2} \\right).\n$$\n这里 $x_{j}^{(\\text{latest})}$ 表示在当前扫描中坐标 $j$ 的最近更新值（对于索引 $j  i$，使用 $x_{j}^{(t+1)}$；对于 $j > i$，使用 $x_{j}^{(t)}$）。因为 $Q$ 是稀疏的，求和 $\\sum_{j \\neq i} Q_{ij}(\\cdot)$ 只涉及满足 $Q_{ij} \\neq 0$ 的邻居 $j$，使得每次更新的计算量为 $\\mathcal{O}(d_{i})$，其中 $d_{i}$ 是马尔可夫图中节点 $i$ 的度。无需矩阵求逆；采样使用局部方差 $s_{i}^{2} = 1/Q_{ii}$ 和一个由 $Q$ 的非对角线元素决定的邻居加权均值。\n\n总而言之，从精度参数化的高斯密度出发，通过配方法可以得到一个单变量正态全条件分布，其方差仅取决于对角元素 $Q_{ii}$，其均值是由 $Q$ 的非对角线元素加权的邻居残差的移位平均。\n\n所要求的最终答案是条件方差 $\\operatorname{Var}(X_{i} \\mid X_{-i}=x_{-i})$ 的解析表达式，该表达式仅用 $Q$ 的元素表示，我们已在上面推导出来。", "answer": "$$\\boxed{\\frac{1}{Q_{ii}}}$$", "id": "4359370"}, {"introduction": "最后，我们将挑战一个更高级且贴近实际应用的场景，处理大规模的时空数据。本练习介绍了一种精密的时空GMRF模型，它使用可分离的（Kronecker积）精度矩阵来高效地捕捉空间和时间上的相关性。你的任务是实现一种高效的、非迭代的推断算法，该算法利用模型后验精度矩阵所特有的块三对角结构。这个练习旨在展示如何将模型的理论特性转化为实际计算中的显著优势，这对于处理真实世界的大规模数据集至关重要 [@problem_id:4359334]。", "problem": "考虑一个离散的时空场，它代表了系统生物医学中一个关注的生物物理量（例如，一个在多个时间点采样的组织内的细胞因子浓度场）。假设该潜场在空间和时间上被建模为一个高斯马尔可夫随机场 (GMRF)。设空间域为一个具有 $n_x$ 列和 $n_y$ 行的矩形格网，因此共有 $n = n_x n_y$ 个空间位置。设有 $T$ 个时间点。潜场向量 $x \\in \\mathbb{R}^{n T}$ 是由 $T$ 个时间点中每个时间点的 $n$ 维空间状态堆叠而成。\n\n潜场的先验精度（协方差的逆）是可分的，并由克罗内克积给出\n$$\nQ = Q_t \\otimes Q_s,\n$$\n其中 $Q_s \\in \\mathbb{R}^{n \\times n}$ 是一个稀疏空间精度矩阵，由一个经单位项正则化的 4-邻居格网拉普拉斯算子导出；而 $Q_t \\in \\mathbb{R}^{T \\times T}$ 是一个稀疏时间精度矩阵，由一个经单位项正则化的路径图拉普拉斯算子导出。具体来说，空间精度构造如下\n$$\nQ_s = \\kappa_s L_s + \\tau_s I_n,\n$$\n其中 $L_s$ 是二维 4-邻居网格的 $n \\times n$ 组合拉普拉斯算子，$I_n$ 是 $n \\times n$ 单位矩阵，$\\kappa_s  0$ 控制空间耦合强度，$\\tau_s  0$ 控制空间正则化。类似地，时间精度为\n$$\nQ_t = \\kappa_t L_t + \\tau_t I_T,\n$$\n其中 $L_t$ 是 $T$ 个节点上的路径图的 $T \\times T$ 拉普拉斯算子，$I_T$ 是 $T \\times T$ 单位矩阵，$\\kappa_t \\ge 0$ 控制时间耦合强度，$\\tau_t  0$ 控制时间正则化。\n\n观测值是在每个位置和时间对潜场的直接带噪测量。设 $y \\in \\mathbb{R}^{n T}$ 为观测向量，其观测模型为\n$$\ny = x + \\varepsilon,\n$$\n其中 $\\varepsilon \\sim \\mathcal{N}(0, \\sigma^2 I_{nT})$ 是方差为 $\\sigma^2  0$ 的独立高斯噪声。任务是利用可分精度产生的块三对角结构，使用一种基于稀疏线性代数的类卡尔曼滤波过程，来推导该线性高斯模型下的后验均值。推导必须从多元高斯条件化和块消元的第一性原理开始。您必须：\n\n1. 定义 4-邻居矩形网格的空间拉普拉斯算子 $L_s$ 和路径图的时间拉普拉斯算子 $L_t$，并使用给定的参数 $(\\kappa_s,\\tau_s)$ 和 $(\\kappa_t,\\tau_t)$ 构建 $Q_s$ 和 $Q_t$。\n2. 证明对于 $Q = Q_t \\otimes Q_s$ 和观测模型，当空间分量被分解出来时，后验精度是稀疏的并且在时间上是块三对角的，这使得一种类似于卡尔曼滤波的前向-后向递归成为可能，该递归使用舒尔补和稀疏求解，而非稠密矩阵求逆。\n3. 实现一个前向消元来计算修改后的对角块和右端项，然后进行后向代入来恢复后验均值 $m \\in \\mathbb{R}^{nT}$，该均值是后验精度和信息向量所蕴含的线性系统的解。\n4. 通过与完整后验系统的直接稀疏求解进行比较，来验证类卡尔曼递归的正确性。\n\n对于下面提供的每个测试用例，您必须生成由类卡尔曼递归计算出的每个时间点后验均值的欧几里得范数。将所有时间点和所有测试用例的范数按顺序汇总到一个列表中，并将此列表作为单行输出打印，其中包含用方括号括起来的、以逗号分隔的结果。\n\n不涉及物理单位。不出现角度。不使用百分比。所有数值答案必须是浮点数。\n\n使用以下参数值和确定性观测值的测试套件。对于每个案例，通过堆叠时间切片 $y_t \\in \\mathbb{R}^n$（其中 $t = 1, \\ldots, T$）来构建 $y \\in \\mathbb{R}^{nT}$，其中索引 $i \\in \\{0,1,\\ldots,n-1\\}$ 以行主序对空间位置进行排序。\n\n- 案例 A (通用耦合，小网格):\n    - $n_x = 2$, $n_y = 2$, $T = 3$, $\\kappa_s = 1.0$, $\\tau_s = 0.1$, $\\kappa_t = 1.2$, $\\tau_t = 0.5$, $\\sigma = 0.4$。\n    - 观测值: $y_t(i) = \\sin(0.5 t) + 0.1 i$。\n- 案例 B (独立时间，大网格):\n    - $n_x = 3$, $n_y = 3$, $T = 2$, $\\kappa_s = 1.5$, $\\tau_s = 0.3$, $\\kappa_t = 0.0$, $\\tau_t = 1.0$, $\\sigma = 0.6$。\n    - 观测值: $y_t(i) = \\cos(0.3 t) - 0.05 i$。\n- 案例 C (强观测噪声，空间一维链):\n    - $n_x = 4$, $n_y = 1$, $T = 4$, $\\kappa_s = 0.8$, $\\tau_s = 0.2$, $\\kappa_t = 0.7$, $\\tau_t = 0.5$, $\\sigma = 5.0$。\n    - 观测值: $y_t(i) = i + 2 t$。\n- 案例 D (单时间和单位置):\n    - $n_x = 1$, $n_y = 1$, $T = 1$, $\\kappa_s = 3.0$, $\\tau_s = 1.0$, $\\kappa_t = 0.0$, $\\tau_t = 1.0$, $\\sigma = 0.3$。\n    - 观测值: $y_1(0) = 1.5$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果（例如，“[result1,result2,...]”）。该列表必须按顺序包含案例 A（三个浮点数）、案例 B（两个浮点数）、案例 C（四个浮点数）和案例 D（一个浮点数）在每个时间点的后验均值的欧几里得范数，总共十个浮点数。", "solution": "该问题要求计算一个被建模为高斯马尔可夫随机场 (GMRF) 的时空场的后验均值。我们给定了一个贝叶斯分层模型，该模型具有 GMRF 先验和针对带噪观测的高斯似然。解决方案需要推导和实现一个计算高效的递归分块求解器，该求解器利用了后验精度矩阵的特定稀疏结构。\n\n潜场由 $x \\in \\mathbb{R}^{nT}$ 表示，观测值由 $y \\in \\mathbb{R}^{nT}$ 表示。模型规定如下：\n先验：$p(x) = \\mathcal{N}(x | 0, Q^{-1})$\n似然：$p(y|x) = \\mathcal{N}(y | x, \\sigma^2 I_{nT})$\n其中 $Q = Q_t \\otimes Q_s$ 是先验精度矩阵，$\\sigma^2$ 是观测噪声方差。\n\n根据贝叶斯定理，后验概率密度为 $p(x|y) \\propto p(y|x)p(x)$。对于这些高斯分布，我们分析概率密度函数的指数部分，忽略归一化常数：\n$$\n\\log p(x|y) = -\\frac{1}{2}(y-x)^\\top (\\sigma^2 I_{nT})^{-1} (y-x) -\\frac{1}{2} x^\\top Q x + \\text{const.}\n$$\n$$\n\\log p(x|y) = -\\frac{1}{2\\sigma^2}(y^\\top y - 2y^\\top x + x^\\top x) - \\frac{1}{2} x^\\top Q x + \\text{const.}\n$$\n$$\n\\log p(x|y) = -\\frac{1}{2} \\left( x^\\top Q x + \\frac{1}{\\sigma^2} x^\\top x - \\frac{2}{\\sigma^2} y^\\top x \\right) + \\text{const.}\n$$\n$$\n\\log p(x|y) = -\\frac{1}{2} x^\\top \\left( Q + \\frac{1}{\\sigma^2} I_{nT} \\right) x + \\left( \\frac{1}{\\sigma^2} y \\right)^\\top x + \\text{const.}\n$$\n这是 $x$ 的一个二次型，证实了后验分布也是高斯分布，$p(x|y) = \\mathcal{N}(x|m, Q_{\\text{post}}^{-1})$。通过配方法，可以确定后验精度矩阵 $Q_{\\text{post}}$ 和后验均值 $m$。后验精度是 $x$ 的二次项的矩阵：\n$$\nQ_{\\text{post}} = Q + \\frac{1}{\\sigma^2} I_{nT} = Q_t \\otimes Q_s + \\frac{1}{\\sigma^2} I_{nT}\n$$\n后验均值 $m$ 是使后验概率最大化的 $x$ 值，通过将对数后验关于 $x$ 的梯度设为零来求得：\n$$\n\\nabla_x \\log p(x|y) = - \\left( Q + \\frac{1}{\\sigma^2} I_{nT} \\right) x + \\frac{1}{\\sigma^2} y = 0\n$$\n因此，后验均值 $m$ 是以下线性系统的解：\n$$\nQ_{\\text{post}} m = b, \\quad \\text{其中} \\quad b = \\frac{1}{\\sigma^2} y\n$$\n由于参数 $\\kappa_s  0, \\tau_s  0, \\kappa_t \\ge 0, \\tau_t  0, \\sigma^2  0$ 确保了 $Q_s$ 和 $Q_t$ 是正定的，先验精度 $Q = Q_t \\otimes Q_s$ 也是正定的。似然精度 $\\frac{1}{\\sigma^2}I_{nT}$ 也是正定的。它们的和 $Q_{\\text{post}}$ 因此是正定且可逆的，保证了 $m$ 的唯一解。\n\n精度矩阵由图拉普拉斯算子构建。时间精度 $Q_t = \\kappa_t L_t + \\tau_t I_T$ 由 $T$ 个节点上的路径图的拉普拉斯算子 $L_t$ 构建。当 $T1$ 时，$L_t$ 是一个 $T \\times T$ 的对称三对角矩阵，其对角线元素为 $(1, 2, \\dots, 2, 1)$，第一上、下对角线上的非对角线元素为 $-1$。当 $T=1$ 时，$L_t=[0]$。\n空间精度 $Q_s = \\kappa_s L_s + \\tau_s I_n$ 由具有 $n=n_x n_y$ 个节点和 4-连通性的二维网格图的拉普拉斯算子 $L_s$ 构建。这个 $n \\times n$ 矩阵可以使用一维拉普拉斯算子的克罗内克和来巧妙地构造：$L_s = I_{n_y} \\otimes L_{n_x} + L_{n_y} \\otimes I_{n_x}$，其中 $L_{n_x}$ 和 $L_{n_y}$ 是一维路径拉普拉斯算子。\n\n高效求解的关键在于 $Q_{\\text{post}}$ 的结构。由于 $Q_t$ 是一个三对角矩阵，克罗内克积 $Q_t \\otimes Q_s$ 是块三对角的，其中每个块都是一个 $n \\times n$ 的矩阵。设 $Q_t$ 的元素为 $(Q_t)_{ij}$。$Q = Q_t \\otimes Q_s$ 的 $(t, t')$ 块是 $(Q_t)_{tt'} Q_s$。后验精度为 $Q_{\\text{post}} = Q_t \\otimes Q_s + \\sigma^{-2} (I_T \\otimes I_n)$。因此，$Q_{\\text{post}}$ 的第 $(t, t')$ 个块是：\n$$\n(Q_{\\text{post}})_{t,t'} = (Q_t)_{t,t'} Q_s + \\sigma^{-2} \\delta_{t,t'} I_n\n$$\n其中 $\\delta_{t,t'}$ 是克罗内克 δ。由于 $Q_t$ 是三对角的，$(Q_t)_{t,t'}$ 仅在 $|t - t'| \\le 1$ 时非零。因此，$(Q_{\\text{post}})_{t,t'}$ 也仅在 $|t - t'| \\le 1$ 时非零，这意味着 $Q_{\\text{post}}$ 是一个块三对角矩阵。线性系统 $Q_{\\text{post}} m = b$ 可以写成块形式：\n$$\n\\begin{pmatrix}\nD_0  U_0   \\\\\nL_0  D_1  U_1  \\\\\n \\ddots  \\ddots  \\ddots \\\\\n  L_{T-2}  D_{T-1}\n\\end{pmatrix}\n\\begin{pmatrix}\nm_0 \\\\ m_1 \\\\ \\vdots \\\\ m_{T-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nb_0 \\\\ b_1 \\\\ \\vdots \\\\ b_{T-1}\n\\end{pmatrix}\n$$\n其中 $m_t, b_t \\in \\mathbb{R}^n$ 是 $m$ 和 $b$ 按时间的划分，而 $n \\times n$ 的块是：\n对角块：$D_t = (Q_t)_{t,t} Q_s + \\sigma^{-2} I_n$\n上对角块：$U_t = (Q_t)_{t, t+1} Q_s$\n下对角块：$L_{t-1} = (Q_t)_{t, t-1} Q_s$。由于 $Q_t$ 是对称的，所以 $L_t = U_t^\\top$。\n\n这个块三对角系统使用块前向消元和后向代入算法求解，这类似于等效状态空间模型上的非因果卡尔曼平滑器（Rauch-Tung-Striebel 平滑器）。这个过程是块 LU 分解的一种形式。\n\n前向消元过程将系统转换为上块双对角形式。我们定义修改后的矩阵 $D'_t$ 和向量 $b'_t$：\n对于 $t=0$:\n$D'_0 = D_0$\n$b'_0 = b_0$\n对于 $t=1, \\dots, T-1$:\n第 $t$ 个块行为 $L_{t-1}m_{t-1} + D_t m_t + U_t m_{t+1} = b_t$。前一个修改后的行为 $D'_{t-1}m_{t-1} + U_{t-1}m_t = b'_{t-1}$。\n从前一个行中，我们表示出 $m_{t-1}$ 并代入，从而得到递推关系：\n$D'_t = D_t - L_{t-1} (D'_{t-1})^{-1} U_{t-1}$\n$b'_t = b_t - L_{t-1} (D'_{t-1})^{-1} b'_{t-1}$\n项 $D'_t$ 是 $D'_{t-1}$ 在前导主子矩阵中的舒尔补。在实现中，我们避免显式矩阵求逆。而是求解线性系统 $D'_{t-1}X = U_{t-1}$ 和 $D'_{t-1}g = b'_{t-1}$，并通过 $D'_t = D_t - L_{t-1}X$ 和 $b'_t = b_t - L_{t-1}g$ 进行更新。\n初始块 $D_0, U_0, L_0$ 是稀疏的。然而，稀疏矩阵的逆通常是稠密的。因此，$(D'_{t-1})^{-1}$ 是稠密的，导致“填充”，使得对于 $t \\ge 1$ 的 $D'_t$ 变为稠密的 $n \\times n$ 矩阵。第一步涉及稀疏求解器，而后续步骤使用稠密求解器，导致复杂度为 $O(T n^3)$。\n\n后向代入过程求解得到的上块双对角系统 $D'_t m_t + U_t m_{t+1} = b'_t$（其中 $U_{T-1}=0$）：\n对于 $t=T-1$: 求解 $D'_{T-1} m_{T-1} = b'_{T-1}$ 以得到 $m_{T-1}$。\n对于 $t = T-2, \\dots, 0$: 求解 $D'_t m_t = b'_t - U_t m_{t+1}$ 以得到 $m_t$。\n\n该算法提供了后验均值 $m = (m_0, \\dots, m_{T-1})$。然后计算每个时间切片的欧几里得范数 $\\|m_t\\|_2$。使用对完整稀疏系统 $Q_{\\text{post}}m=b$ 的直接求解进行验证，以确认递归实现的正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg as sla\n\ndef construct_laplacian_1d(k):\n    \"\"\"Constructs the sparse combinatorial Laplacian for a path graph of size k.\"\"\"\n    if k == 1:\n        return sparse.csc_matrix([[0]], dtype=float)\n    # Tridiagonal structure: -1, 2, -1\n    diagonals = [-1 * np.ones(k-1), 2 * np.ones(k), -1 * np.ones(k-1)]\n    offsets = [-1, 0, 1]\n    L = sparse.diags(diagonals, offsets, shape=(k, k), format='csc')\n    # Boundary conditions for path graph\n    L[0, 0] = 1\n    L[k - 1, k - 1] = 1\n    return L\n\ndef construct_laplacian_2d(nx, ny):\n    \"\"\"Constructs the sparse combinatorial Laplacian for a 2D grid graph.\"\"\"\n    if nx * ny == 1:\n        return sparse.csc_matrix([[0]], dtype=float)\n    L_nx = construct_laplacian_1d(nx)\n    L_ny = construct_laplacian_1d(ny)\n    I_nx = sparse.eye(nx, format='csc')\n    I_ny = sparse.eye(ny, format='csc')\n    # Kronecker sum for grid Laplacians\n    L_s = sparse.kron(L_ny, I_nx) + sparse.kron(I_ny, L_nx)\n    return L_s.asformat('csc')\n\ndef solve_case(nx, ny, T, ks, ts, kt, tt, sigma, y_func):\n    \"\"\"\n    Solves for the posterior mean using the Kalman-like recursion and returns norms.\n    \"\"\"\n    n = nx * ny\n    if n == 0 or T == 0:\n        return []\n\n    # 1. Construct precision matrices and observation vector\n    L_s = construct_laplacian_2d(nx, ny)\n    Q_s = ks * L_s + ts * sparse.eye(n, format='csc')\n    \n    L_t = construct_laplacian_1d(T)\n    Q_t = kt * L_t + tt * sparse.eye(T, format='csc')\n    Q_t_dense = Q_t.toarray()\n\n    y = np.zeros(n * T)\n    for t_idx in range(T):\n        t_val = t_idx + 1  # Problem statement uses 1-based time index\n        for i_idx in range(n):\n            y[t_idx * n + i_idx] = y_func(t_val, i_idx)\n            \n    b = y / (sigma**2)\n    b_blocks = [b[t * n:(t + 1) * n] for t in range(T)]\n\n    # 2. Forward elimination pass\n    D_mod = []\n    b_mod = []\n\n    # Initialize for t=0\n    D_current = Q_t_dense[0, 0] * Q_s + (1 / sigma**2) * sparse.eye(n, format='csc')\n    b_current = b_blocks[0]\n    D_mod.append(D_current)\n    b_mod.append(b_current)\n\n    for t in range(1, T):\n        L_prev = Q_t_dense[t, t - 1] * Q_s\n        U_prev = Q_t_dense[t - 1, t] * Q_s\n        D_t_block = Q_t_dense[t, t] * Q_s + (1 / sigma**2) * sparse.eye(n, format='csc')\n        \n        D_prev_mod = D_mod[t-1]\n        b_prev_mod = b_mod[t-1]\n        \n        if isinstance(D_prev_mod, sparse.spmatrix):\n            # First step: D_prev_mod is sparse\n            X = sla.spsolve(D_prev_mod, U_prev)\n            g = sla.spsolve(D_prev_mod, b_prev_mod)\n        else:\n            # Subsequent steps: D_prev_mod is dense from fill-in\n            X = np.linalg.solve(D_prev_mod, U_prev.toarray())\n            g = np.linalg.solve(D_prev_mod, b_prev_mod)\n            \n        D_current_mod = D_t_block.toarray() - L_prev.toarray() @ X\n        b_current_mod = b_blocks[t] - L_prev.toarray() @ g\n        \n        D_mod.append(D_current_mod)\n        b_mod.append(b_current_mod)\n        \n    # 3. Backward substitution pass\n    m = [None] * T\n    \n    # Solve for the last time step t = T-1\n    if T > 0:\n        if isinstance(D_mod[T - 1], np.ndarray):\n            m[T - 1] = np.linalg.solve(D_mod[T - 1], b_mod[T - 1])\n        else: # T=1, so D_mod[0] is sparse\n            m[T - 1] = sla.spsolve(D_mod[T - 1], b_mod[T - 1])\n\n    # Solve for remaining time steps t = T-2, ..., 0\n    for t in range(T - 2, -1, -1):\n        U_t_block = Q_t_dense[t, t + 1] * Q_s\n        rhs = b_mod[t] - U_t_block @ m[t + 1]\n        \n        if isinstance(D_mod[t], sparse.spmatrix): # Only for t=0\n            m[t] = sla.spsolve(D_mod[t], rhs)\n        else:\n            m[t] = np.linalg.solve(D_mod[t], rhs)\n    \n    # 4. Compute and return norms\n    norms = [np.linalg.norm(m_t) for m_t in m]\n    return norms\n\ndef solve():\n    test_cases = [\n        # Case A\n        {'nx': 2, 'ny': 2, 'T': 3, 'ks': 1.0, 'ts': 0.1, 'kt': 1.2, 'tt': 0.5, 'sigma': 0.4, \n         'y_func': lambda t, i: np.sin(0.5 * t) + 0.1 * i},\n        # Case B\n        {'nx': 3, 'ny': 3, 'T': 2, 'ks': 1.5, 'ts': 0.3, 'kt': 0.0, 'tt': 1.0, 'sigma': 0.6,\n         'y_func': lambda t, i: np.cos(0.3 * t) - 0.05 * i},\n        # Case C\n        {'nx': 4, 'ny': 1, 'T': 4, 'ks': 0.8, 'ts': 0.2, 'kt': 0.7, 'tt': 0.5, 'sigma': 5.0,\n         'y_func': lambda t, i: i + 2 * t},\n        # Case D\n        {'nx': 1, 'ny': 1, 'T': 1, 'ks': 3.0, 'ts': 1.0, 'kt': 0.0, 'tt': 1.0, 'sigma': 0.3,\n         'y_func': lambda t, i: 1.5},\n    ]\n\n    all_norms = []\n    for case in test_cases:\n        norms = solve_case(\n            case['nx'], case['ny'], case['T'], case['ks'], case['ts'],\n            case['kt'], case['tt'], case['sigma'], case['y_func']\n        )\n        all_norms.extend(norms)\n\n    print(f\"[{','.join(map(str, all_norms))}]\")\n\nsolve()\n```", "id": "4359334"}]}