{"hands_on_practices": [{"introduction": "混合离散-连续介质模型通常从理解其连续介质部分的基本行为开始。这个实践练习 [@problem_id:4353438] 为你提供了一个基础性的分析任务：推导由单个点源（例如一个分泌细胞）在一维空间中产生并同时经历降解的信号分子的稳态浓度分布。通过解决这个经典的反应-扩散问题，你将亲身体会扩散和降解之间的平衡如何形成一个稳定的空间梯度，并推导出决定信号传播范围的关键参数——特征衰减长度 $\\ell = \\sqrt{D/\\lambda}$。", "problem": "考虑一个系统生物医学中的一维胞外通道（例如，胶原纤维）上分泌的信号分子的离散-连续混合模型。位于位置 $x=0$ 的单个分泌细胞被离散地表示为一个点源，而胞外浓度场 $C(x,t)$ 则被建模为连续介质。该场遵循质量守恒和菲克扩散定律：通量为 $J(x,t) = -D\\,\\partial C/\\partial x$，其中扩散系数 $D>0$；分子在胞外空间以降解，一级速率常数为 $\\lambda>0$。细胞以恒定速率 $q>0$ 分泌。一维质量平衡得到偏微分方程 (PDE)\n$$\n\\frac{\\partial C}{\\partial t} = -\\frac{\\partial J}{\\partial x} - \\lambda C + q\\,\\delta(x),\n$$\n其中 $\\delta(x)$ 是狄拉克δ分布，且 $x \\in \\mathbb{R}$。假设系统在无穷域上达到稳态，且当 $|x|\\to \\infty$ 时 $C(x)\\to 0$。\n\n从所述的物理定律和定义出发，推导由点源产生的稳态浓度分布 $C(x)$。你的推导必须通过狄拉克δ分布来处理点源，并施加在无穷远处符合物理的边界条件。用空间坐标 $x$ 和参数 $D$、$\\lambda$ 和 $q$ 表示你最终的稳态解 $C(x)$，并使用由连续介质-反应平衡定义的特征衰减长度 $\\ell$ 来书写。在推导过程中简要解释 $\\ell$ 的物理意义，但最终答案只报告 $C(x)$ 的解析表达式。最终表达式中不要包含单位。不需要进行数值计算或四舍五入。", "solution": "该问题要求推导在一维区域内，由一个带有源点的反应扩散方程所描述的信号分子的稳态浓度分布 $C(x)$。\n\n出发点是描述浓度场 $C(x,t)$ 的控制偏微分方程 (PDE)，该方程结合了菲克扩散定律、一级降解和点源分泌：\n$$\n\\frac{\\partial C}{\\partial t} = -\\frac{\\partial J}{\\partial x} - \\lambda C + q\\,\\delta(x)\n$$\n通量 $J(x,t)$ 由菲克定律给出，为 $J(x,t) = -D\\frac{\\partial C}{\\partial x}$。将其代入守恒方程可得：\n$$\n\\frac{\\partial C}{\\partial t} = -\\frac{\\partial}{\\partial x}\\left(-D\\frac{\\partial C}{\\partial x}\\right) - \\lambda C + q\\,\\delta(x)\n$$\n$$\n\\frac{\\partial C}{\\partial t} = D\\frac{\\partial^2 C}{\\partial x^2} - \\lambda C + q\\,\\delta(x)\n$$\n其中 $D > 0$ 是扩散系数，$\\lambda > 0$ 是降解速率常数，$q > 0$ 是分泌速率，$\\delta(x)$ 是表示位于 $x=0$ 的点源的狄拉克δ分布。\n\n问题要求的是稳态解，当浓度分布不再随时间变化时达到稳态。我们将时间导数设为零，即 $\\frac{\\partial C}{\\partial t} = 0$。令 $C(x)$ 表示稳态浓度分布。该偏微分方程简化为一个二阶常微分方程 (ODE)：\n$$\nD\\frac{d^2 C}{dx^2} - \\lambda C + q\\,\\delta(x) = 0\n$$\n为求解此方程，我们首先考虑源项为零的区域，即 $x \\neq 0$ 的情况。在这些区域，该常微分方程是齐次的：\n$$\nD\\frac{d^2 C}{dx^2} - \\lambda C = 0 \\quad \\text{for } x \\neq 0\n$$\n整理此方程可得：\n$$\n\\frac{d^2 C}{dx^2} - \\frac{\\lambda}{D} C = 0\n$$\n该方程揭示了一个由扩散（参数 $D$）和反应（参数 $\\lambda$）之间的平衡所产生的特征长度尺度。我们定义这个特征衰减长度 $\\ell$ 为：\n$$\n\\ell = \\sqrt{\\frac{D}{\\lambda}}\n$$\n在物理上，$\\ell$ 表示一个分子在被降解前扩散的典型距离。较大的 $\\ell$ 意味着信号从源头传播得更远。现在，该常微分方程可以用 $\\ell$ 表示为：\n$$\n\\frac{d^2 C}{dx^2} - \\frac{1}{\\ell^2} C = 0\n$$\n该常微分方程的特征方程为 $r^2 - \\frac{1}{\\ell^2} = 0$，其根为 $r = \\pm \\frac{1}{\\ell}$。通解是指数函数的线性组合：\n$$\nC(x) = A \\exp\\left(\\frac{x}{\\ell}\\right) + B \\exp\\left(-\\frac{x}{\\ell}\\right)\n$$\n其中 $A$ 和 $B$ 是积分常数，对于区域 $x  0$ 和 $x > 0$ 可能不同。我们必须应用为无穷域指定的边界条件：当 $|x| \\to \\infty$ 时，$C(x) \\to 0$。\n\n对于区域 $x > 0$，当 $x \\to \\infty$ 时，项 $\\exp(x/\\ell)$ 会无界增长。为满足边界条件 $C(x) \\to 0$，其系数必须为零。因此，对于 $x > 0$：\n$$\nC(x) = B_+ \\exp\\left(-\\frac{x}{\\ell}\\right)\n$$\n对于区域 $x  0$，当 $x \\to -\\infty$ 时，项 $\\exp(-x/\\ell)$ 会无界增长。为满足边界条件，其系数必须为零。因此，对于 $x  0$：\n$$\nC(x) = A_- \\exp\\left(\\frac{x}{\\ell}\\right)\n$$\n接下来，我们必须在源点位置 $x=0$ 处连接这两个解。需要两个条件。第一个是浓度场在源点必须是物理上连续的：\n$$\n\\lim_{x \\to 0^+} C(x) = \\lim_{x \\to 0^-} C(x)\n$$\n$$\nB_+ \\exp(0) = A_- \\exp(0) \\implies B_+ = A_-\n$$\n我们将这个公共常数记为 $K$。那么解可以用绝对值函数写成一个单一的表达式：\n$$\nC(x) = K \\exp\\left(-\\frac{|x|}{\\ell}\\right)\n$$\n第二个条件通过在源点 $x=0$ 两侧对完整的非齐次常微分方程进行积分得到。我们对某个小的 $\\epsilon > 0$ 从 $-\\epsilon$ 积分到 $+\\epsilon$，然后考虑 $\\epsilon \\to 0$ 的极限：\n$$\n\\int_{-\\epsilon}^{\\epsilon} \\left( D\\frac{d^2 C}{dx^2} - \\lambda C + q\\,\\delta(x) \\right) dx = 0\n$$\n$$\nD \\int_{-\\epsilon}^{\\epsilon} \\frac{d^2 C}{dx^2} dx - \\lambda \\int_{-\\epsilon}^{\\epsilon} C(x) dx + q \\int_{-\\epsilon}^{\\epsilon} \\delta(x) dx = 0\n$$\n在 $\\epsilon \\to 0$ 的极限下计算每一项：\n第一项变为 $D \\left[ \\frac{dC}{dx} \\right]_{-\\epsilon}^{\\epsilon} = D \\left( \\left.\\frac{dC}{dx}\\right|_{x=\\epsilon} - \\left.\\frac{dC}{dx}\\right|_{x=-\\epsilon} \\right)$，在极限情况下是 $x=0$ 处导数的跳跃，即 $D (\\left.C'\\right|_{0^+} - \\left.C'\\right|_{0^-})$。\n第二项消失为零，因为 $C(x)$ 在 $x=0$ 处是连续且有限的，所以当 $\\epsilon \\to 0$ 时，积分 $\\int_{-\\epsilon}^{\\epsilon} C(x) dx \\to 0$。\n第三项，根据狄拉克δ函数的筛选性质，为 $q \\int_{-\\epsilon}^{\\epsilon} \\delta(x) dx = q \\cdot 1 = q$。\n\n因此，积分后的方程给出了导数的跳跃条件：\n$$\nD \\left( \\left.\\frac{dC}{dx}\\right|_{0^+} - \\left.\\frac{dC}{dx}\\right|_{0^-} \\right) + q = 0 \\implies \\left.\\frac{dC}{dx}\\right|_{0^+} - \\left.\\frac{dC}{dx}\\right|_{0^-} = -\\frac{q}{D}\n$$\n该条件反映了源点处的质量守恒：扩散通量 $-D\\frac{dC}{dx}$ 的不连续性必须与源速率 $q$ 相平衡。\n\n现在我们计算解 $C(x) = K \\exp(-|x|/\\ell)$ 的导数：\n对于 $x > 0$，$C(x) = K \\exp(-x/\\ell)$，因此 $\\frac{dC}{dx} = -\\frac{K}{\\ell} \\exp(-x/\\ell)$。于是，$\\left.\\frac{dC}{dx}\\right|_{0^+} = -\\frac{K}{\\ell}$。\n对于 $x  0$，$C(x) = K \\exp(x/\\ell)$，因此 $\\frac{dC}{dx} = \\frac{K}{\\ell} \\exp(x/\\ell)$。于是，$\\left.\\frac{dC}{dx}\\right|_{0^-} = \\frac{K}{\\ell}$。\n\n将这些代入跳跃条件中：\n$$\n\\left(-\\frac{K}{\\ell}\\right) - \\left(\\frac{K}{\\ell}\\right) = -\\frac{q}{D}\n$$\n$$\n-\\frac{2K}{\\ell} = -\\frac{q}{D}\n$$\n解出常数 $K$：\n$$\nK = \\frac{q\\ell}{2D}\n$$\n最后，将这个 $K$ 的值代回到 $C(x)$ 的表达式中，得到稳态浓度分布：\n$$\nC(x) = \\frac{q\\ell}{2D} \\exp\\left(-\\frac{|x|}{\\ell}\\right)\n$$\n该表达式描述了浓度从源点开始呈指数衰减，其特征衰减长度由 $\\ell = \\sqrt{D/\\lambda}$ 决定。", "answer": "$$\\boxed{\\frac{q\\ell}{2D} \\exp\\left(-\\frac{|x|}{\\ell}\\right)}$$", "id": "4353438"}, {"introduction": "在建立了一维模型的基础后，我们将维度提升至二维，来探索一个更为微妙且关键的概念。这个练习 [@problem_id:4353352] 要求你计算一个二维平面中由点源产生的稳态营养场。你会发现，与一维情况不同，二维中的解在源点处呈现出对数奇点 (logarithmic singularity)，这意味着浓度在数学上会趋于无穷。这个奇点并非模型缺陷，而是混合建模的核心动机之一：它揭示了纯连续介质描述在细胞尺度上的局限性，并强调了引入具有有限尺寸的离散单元来“修正”这种非物理行为的必要性。", "problem": "在系统生物医学中，考虑一个混合离散-连续介质模型，其中，位于原点的单个静止细胞作为平面组织中可扩散营养物场的局部源项。连续介质中的营养物浓度 $c(\\mathbf{x})$ 在稳态下由偏微分方程（PDE）控制\n$$\n\\nabla^2 c(\\mathbf{x}) = \\alpha\\,\\delta(\\mathbf{x}),\n$$\n在无限二维域 $\\mathbb{R}^2$ 中，其中 $\\alpha$ 是一个实常数，$\\delta(\\mathbf{x})$ 是以原点为中心的狄拉克δ分布。假设各向同性，因此 $c(\\mathbf{x}) = c(r)$ 仅依赖于径向距离 $r = |\\mathbf{x}|$。由于无限二维域不允许点源在无穷远处有有限的边界条件，我们通过在指定的宏观半径 $R  0$ 处施加参考条件 $c(R) = 0$ 来固定可加常数。\n\n从拉普拉斯算子和狄拉克δ分布的基本性质出发，计算当 $r  0$ 时稳态营养物浓度分布 $c(r)$ 的显式表达式，用 $r$、$R$ 和 $\\alpha$ 表示。此外，仅使用第一性原理，描述 $c(r)$ 在极限 $r \\to 0^+$ 下的主导行为，并解释其在混合离散-连续介质耦合背景下的物理意义。\n\n将您最终的浓度分布 $c(r)$ 表示为单个闭合形式的解析表达式。无需进行数值舍入。", "solution": "问题陈述经评估有效。它在科学上基于偏微分方程理论（特别是泊松方程），由于包含了用于固定积分常数的参考条件而属于适定问题，并且其表述是客观的。该问题代表了理论生物物理学中一个标准的、理想化的模型，并且可以使用第一性原理求解。\n\n稳态营养物浓度 $c(\\mathbf{x})$ 由二维泊松方程控制：\n$$\n\\nabla^2 c(\\mathbf{x}) = \\alpha\\,\\delta(\\mathbf{x})\n$$\n其中 $\\mathbf{x} \\in \\mathbb{R}^2$，$\\alpha$ 是代表源强度的常数，$\\delta(\\mathbf{x})$ 是狄拉克δ分布。问题陈述指出解是各向同性的，即 $c(\\mathbf{x}) = c(r)$，其中 $r = |\\mathbf{x}| = \\sqrt{x_1^2 + x_2^2}$ 是离原点的径向距离。\n\n对于不包括原点的任何区域（即 $r  0$），狄拉克δ项为零，$\\delta(\\mathbf{x}) = 0$。在该区域，控制方程简化为拉普拉斯方程：\n$$\n\\nabla^2 c(r) = 0 \\quad \\text{for } r  0\n$$\n为求解此方程，我们将拉普拉斯算子 $\\nabla^2$ 用极坐标 $(r, \\theta)$ 表示。其一般形式为 $\\nabla^2 = \\frac{1}{r}\\frac{\\partial}{\\partial r}\\left(r\\frac{\\partial}{\\partial r}\\right) + \\frac{1}{r^2}\\frac{\\partial^2}{\\partial \\theta^2}$。由于径向对称性，浓度 $c$ 不依赖于角度 $\\theta$，因此 $\\frac{\\partial^2 c}{\\partial \\theta^2}$ 项为零。这样，偏微分方程就变成了关于 $r$ 的常微分方程（ODE）：\n$$\n\\frac{1}{r}\\frac{d}{dr}\\left(r\\frac{dc}{dr}\\right) = 0\n$$\n为了使该方程在 $r0$ 时成立，括号内的项必须是一个常数。设该常数为 $A$：\n$$\nr\\frac{dc}{dr} = A\n$$\n分离变量并积分得到：\n$$\n\\frac{dc}{dr} = \\frac{A}{r}\n$$\n对 $r$ 进行第二次积分，得到 $c(r)$ 的通解：\n$$\nc(r) = A \\ln(r) + B\n$$\n其中 $A$ 和 $B$ 是积分常数。这是二维拉普拉斯方程在径向对称情况下的基本解。\n\n为了确定常数 $A$，我们必须将其与源强度 $\\alpha$ 联系起来。我们将原始泊松方程在一个以原点为中心、半径为 $\\epsilon$ 的小圆盘 $D_\\epsilon$ 上积分。\n$$\n\\iint_{D_\\epsilon} \\nabla^2 c(\\mathbf{x}) \\, d^2x = \\iint_{D_\\epsilon} \\alpha\\,\\delta(\\mathbf{x}) \\, d^2x\n$$\n根据狄拉克δ分布的定义性质，右侧的积分就是 $\\alpha$。\n$$\n\\iint_{D_\\epsilon} \\alpha\\,\\delta(\\mathbf{x}) \\, d^2x = \\alpha\n$$\n对于左侧，我们应用二维散度定理（格林公式的一个特例），该定理表述为 $\\iint_D \\nabla \\cdot \\mathbf{F} \\, d^2x = \\oint_{\\partial D} \\mathbf{F} \\cdot \\mathbf{\\hat{n}} \\, ds$。令 $\\mathbf{F} = \\nabla c$，我们有：\n$$\n\\iint_{D_\\epsilon} \\nabla^2 c \\, d^2x = \\oint_{\\partial D_\\epsilon} \\nabla c \\cdot \\mathbf{\\hat{n}} \\, ds\n$$\n这里，$\\partial D_\\epsilon$ 是半径为 $\\epsilon$ 的圆周，$\\mathbf{\\hat{n}}$ 是向外的单位法向量（也就是径向单位向量 $\\mathbf{\\hat{r}}$），$ds$ 是弧长元。对于径向对称函数，其在极坐标下的梯度为 $\\nabla c = \\frac{dc}{dr}\\mathbf{\\hat{r}}$。\n积分变为：\n$$\n\\oint_{\\partial D_\\epsilon} \\left(\\frac{dc}{dr}\\mathbf{\\hat{r}}\\right) \\cdot \\mathbf{\\hat{r}} \\, ds = \\oint_{\\partial D_\\epsilon} \\frac{dc}{dr} \\, ds\n$$\n我们代入 $\\frac{dc}{dr} = \\frac{A}{r}$。在 $r=\\epsilon$ 处，被积函数是常数 $\\frac{A}{\\epsilon}$。积分路径是一个周长为 $2\\pi\\epsilon$ 的圆。\n$$\n\\oint_{\\partial D_\\epsilon} \\frac{A}{\\epsilon} \\, ds = \\frac{A}{\\epsilon} \\int_0^{2\\pi} \\epsilon \\, d\\theta = \\frac{A}{\\epsilon}(2\\pi\\epsilon) = 2\\pi A\n$$\n将积分后的泊松方程左右两边的结果相等，得到：\n$$\n2\\pi A = \\alpha \\implies A = \\frac{\\alpha}{2\\pi}\n$$\n因此，浓度分布为 $c(r) = \\frac{\\alpha}{2\\pi}\\ln(r) + B$。\n\n为了确定常数 $B$，我们使用给定的参考条件 $c(R) = 0$（对于给定的半径 $R  0$）。\n$$\nc(R) = \\frac{\\alpha}{2\\pi}\\ln(R) + B = 0\n$$\n求解 $B$：\n$$\nB = -\\frac{\\alpha}{2\\pi}\\ln(R)\n$$\n将 $A$ 和 $B$ 代回 $c(r)$ 的表达式，我们得到浓度分布的最终显式形式：\n$$\nc(r) = \\frac{\\alpha}{2\\pi}\\ln(r) - \\frac{\\alpha}{2\\pi}\\ln(R) = \\frac{\\alpha}{2\\pi}\\left(\\ln(r) - \\ln(R)\\right)\n$$\n利用对数的性质，这可以写成：\n$$\nc(r) = \\frac{\\alpha}{2\\pi}\\ln\\left(\\frac{r}{R}\\right)\n$$\n\n接下来，我们分析 $c(r)$ 在极限 $r \\to 0^+$ 下的主导行为。当 $r$ 从正方向趋近于 $0$ 时，对数的参数 $\\frac{r}{R}$ 也趋近于 $0$。自然对数函数 $\\ln(x)$ 在其参数 $x \\to 0^+$ 时趋近于 $-\\infty$。\n$$\n\\lim_{r\\to 0^+} c(r) = \\lim_{r\\to 0^+} \\frac{\\alpha}{2\\pi}\\left(\\ln(r) - \\ln(R)\\right)\n$$\n当 $r \\to 0^+$ 时，$\\ln(r)$ 项主导了常数项 $-\\ln(R)$。因此，主导行为是一个对数奇点：\n$$\nc(r) \\sim \\frac{\\alpha}{2\\pi}\\ln(r) \\quad \\text{as } r \\to 0^+\n$$\n这表明浓度在点源的位置发散。\n\n这个奇点的物理意义对于理解混合离散-连续介质模型至关重要。连续介质PDE模型将细胞视为一个体积为零的数学点源，由狄拉克δ分布 $\\delta(\\mathbf{x})$ 表示。营养物浓度在 $r=0$ 处的对数发散是这种理想化处理的一个直接且不可避免的数学结果。然而，一个物理上的细胞具有有限的尺寸。营养物的浓度在任何地方都不可能是无限的，包括在细胞表面。这个奇点标志着连续介质描述在与细胞本身相当或更小的长度尺度上失效。\n\n在混合离散-连续介质框架中，这正是离散和连续描述必须耦合的界面。连续介质模型提供了远场浓度，当它接近离散物体（细胞）时，表现出特有的奇点行为。反过来，细胞的离散模型并不会“看到”无限的浓度。相反，需要一个耦合条件。例如，细胞的行为（如其营养物消耗或分泌的速率，这决定了 $\\alpha$）可能依赖于在细胞有限表面上或在特定“耦合半径”处评估的连续介质场的平均浓度。因此，奇点提供了来自连续介质场的必要的局部信息，这些信息驱动离散元素的状态，从而连接了混合模型的两个尺度。它是数学表征的产物，对模型的两个部分必须如何相互作用具有深远的影响。", "answer": "$$\\boxed{\\frac{\\alpha}{2\\pi}\\ln\\left(\\frac{r}{R}\\right)}$$", "id": "4353352"}, {"introduction": "在前两个分析练习中，我们探索了连续介质场的基本属性。现在，是时候将所有部分整合起来，构建一个动态的、完整的混合离散-连续介质模型了。在这个计算实践 [@problem_id:4353262] 中，你将模拟一个离散细胞群体与连续营养场之间的双向相互作用。你需要为扩散-消耗的偏微分方程 (PDE) 实现一个数值求解器，并为细胞的生死决策（凋亡与增殖）编写基于局部营养浓度的离散规则，最终通过插值方法将这两个部分耦合起来。这个练习将让你全面掌握从理论构建到代码实现一个混合模型的关键技能。", "problem": "考虑一个混合离散-连续模型，用于描述扩散的营养场与一组离散生物智能体之间的相互作用。设连续场为在方形域 $\\Omega = [0,1]^2$ 上定义的无量纲营养物浓度 $c(\\mathbf{x},t)$，离散智能体由 $i=1,\\dots,N(t)$ 索引，其位置为 $\\mathbf{x}_i \\in \\Omega$。从 Fick 扩散定律的基本原理出发，该定律指出扩散通量为 $\\mathbf{J} = -D \\nabla c$，其中 $D$ 是一个正的扩散系数；并结合质量守恒定律，该定律指出累积量等于流入量减去流出量加上源项减去汇项。在这些假设下，通过写入一个扩散项并减去由智能体引起的局部吸收（建模为智能体位置处的点汇），可以得到营养物的控制性连续方程。每个智能体的吸收速率是其位置处局部浓度 $c(\\mathbf{x}_i)$ 的函数 $\\lambda(c(\\mathbf{x}_i))$，这导致了以下的混合离散-连续偏微分方程\n$$\n\\partial_t c(\\mathbf{x},t) = D \\nabla^2 c(\\mathbf{x},t) - \\sum_{i=1}^{N(t)} \\lambda\\!\\big(c(\\mathbf{x}_i,t)\\big)\\,\\delta\\!\\big(\\mathbf{x}-\\mathbf{x}_i\\big),\n$$\n其中 $\\delta(\\cdot)$ 是狄拉克 $\\delta$ 分布。假设在 $\\partial \\Omega$ 上为零通量（Neumann）边界条件，因此 $\\partial_{\\mathbf{n}} c = 0$ 成立，其中 $\\mathbf{n}$ 是外法线向量。\n\n通过 Michaelis–Menten 动力学（MM）定义吸收函数：\n$$\n\\lambda(c) = k \\frac{c}{K + c},\n$$\n其中 $k$ 和 $K$ 为正常数。智能体不移动，但其种群根据局部营养物通过两条规则演化：凋亡（死亡）和增殖（分裂）。每个智能体 $i$ 都有一个整数年龄计数器 $a_i(t)$（以时间步为单位）。在每个时间步，规则如下：\n- 如果局部营养物浓度 $c(\\mathbf{x}_i,t)$ 小于或等于阈值 $c_{\\mathrm{apop}}$，则该智能体发生凋亡并被立即移除。\n- 如果局部营养物浓度 $c(\\mathbf{x}_i,t)$ 大于或等于阈值 $c_{\\mathrm{prolif}}$，则该智能体的年龄 $a_i$ 增加一；否则，年龄不变。如果 $a_i$ 达到或超过预设的分裂间隔 $T_{\\mathrm{div}}$，该智能体分裂为两个智能体：原始智能体的年龄重置为零，并在位置 $\\mathbf{x}_i + (\\Delta x,0)$ 处创建一个年龄为零的新智能体（如果该位置在 $\\Omega$ 内）；否则在位置 $\\mathbf{x}_i - (\\Delta x,0)$ 处创建。此处 $\\Delta x$ 表示下文定义的网格间距。如果新位置会超出 $\\Omega$，则必须将其限制在 $\\Omega$ 内部。\n\n使用一个规则的笛卡尔网格对连续场进行数值近似，该网格在 $x$ 方向有 $N_x$ 个节点，在 $y$ 方向有 $N_y$ 个节点，网格间距分别为 $\\Delta x = 1/(N_x-1)$ 和 $\\Delta y = 1/(N_y-1)$。令 $c_{j,k}^n$ 表示在网格索引 $(j,k)$ 和时间步 $n$ 处对 $c$ 的离散近似。使用标准的 $5$ 点模板近似拉普拉斯算子 $ \\nabla^2 c $，并通过使用镜像虚拟值（等效于用边界值填充，以使 $\\partial_{\\mathbf{n}} c = 0$）来强制执行零通量边界条件。通过使用总和为一的双线性权重，将每个智能体的吸收量分配到最近的四个网格节点上，以此来近似 $\\delta(\\mathbf{x}-\\mathbf{x}_i)$。为保持正确的物理尺度，将沉积的吸收量除以单元面积 $\\Delta x \\Delta y$，使得节点上的离散汇项 $S_{j,k}^n$ 代表单位面积的速率。使用显式前向欧拉时间积分方法，\n$$\nc^{n+1}_{j,k} = c^n_{j,k} + \\Delta t \\left( D \\nabla^2_{\\mathrm{FD}} c^n_{j,k} - S^n_{j,k} \\right),\n$$\n其时间步长 $\\Delta t$ 的选择需满足均匀网格上二维扩散的标准稳定性限制。对于相等的间距 $\\Delta x = \\Delta y$，强制执行\n$$\n\\Delta t \\le \\frac{\\Delta x^2}{4 D}\n$$\n对于本任务，选择\n$$\n\\Delta t = 0.2 \\frac{\\Delta x^2}{4 D}\n$$\n以确保数值安全性。初始条件为在 $\\Omega$ 中各处均为均匀的 $c(\\mathbf{x},0) = 1$，且初始智能体年龄为零。\n\n为以下三个测试用例中的每一个，实现上述混合模型并模拟指定的 $T$ 个时间步。所有量均为无量纲；不使用物理单位。对于每个测试用例，输出最终存活的智能体数量 $N(T)$（作为整数）。\n\n测试套件：\n- 用例 A（常规成功路径）：\n  - 域和网格：$N_x = 64$，$N_y = 64$。\n  - 扩散：$D = 10^{-3}$。\n  - 吸收参数：$k = 5 \\times 10^{-2}$，$K = 10^{-1}$。\n  - 智能体规则：$c_{\\mathrm{prolif}} = 0.7$，$c_{\\mathrm{apop}} = 0.2$，$T_{\\mathrm{div}} = 30$。\n  - 时间步数：$T = 220$。\n  - 初始智能体：两个智能体，位置分别为 $\\mathbf{x}_1=(0.5,0.5)$ 和 $\\mathbf{x}_2=(0.55,0.5)$，年龄均为 $0$。\n- 用例 B（边界条件和高消耗压力测试）：\n  - 域和网格：$N_x = 64$，$N_y = 64$。\n  - 扩散：$D = 10^{-3}$。\n  - 吸收参数：$k = 2 \\times 10^{-1}$，$K = 5 \\times 10^{-2}$。\n  - 智能体规则：$c_{\\mathrm{prolif}} = 0.6$，$c_{\\mathrm{apop}} = 0.4$，$T_{\\mathrm{div}} = 40$。\n  - 时间步数：$T = 200$。\n  - 初始智能体：两个智能体，位置分别为 $\\mathbf{x}_1=(0.02,0.02)$ 和 $\\mathbf{x}_2=(0.98,0.98)$，年龄均为 $0$。\n- 用例 C（无智能体的边缘情况）：\n  - 域和网格：$N_x = 64$，$N_y = 64$。\n  - 扩散：$D = 10^{-3}$。\n  - 吸收参数：$k = 10^{-1}$，$K = 10^{-1}$。\n  - 智能体规则：$c_{\\mathrm{prolif}} = 0.9$，$c_{\\mathrm{apop}} = 0.1$，$T_{\\mathrm{div}} = 20$。\n  - 时间步数：$T = 100$。\n  - 初始智能体：无。\n\n您的程序应生成单行输出，其中包含三个测试用例的最终存活智能体数量，格式为方括号内以逗号分隔的列表（例如 `[N_A,N_B,N_C]`）。除此确切格式外，不应打印任何多余的文本或空格。程序必须是自包含的，并且不需要用户输入。", "solution": "用户的问题陈述已经过严格验证，并被认定为**有效**。它在科学上基于反应扩散系统和基于智能体的建模原理，问题提法得当、客观，并包含了获得唯一计算解所需的所有必要信息。\n\n该问题要求实现一个混合离散-连续模型。该模型由两个主要部分组成：一个用于描述营养场的连续偏微分方程（PDE），以及一组用于控制生物智能体种群的离散规则。这两个部分是耦合的：智能体消耗营养物，在连续场中产生局部汇；而局部营养物浓度又反过来决定智能体的生存和增殖。\n\n该解决方案以数值模拟的形式实现，该模拟在指定的 $T$ 个时间步内演化系统状态。算法的核心步骤概述如下。\n\n**1. 系统初始化**\n\n首先，我们根据提供的参数建立模拟环境。\n- 定义一个大小为 $N_y \\times N_x$ 的二维笛卡尔网格，以表示空间域 $\\Omega = [0,1]^2$。网格间距为 $\\Delta x = 1/(N_x-1)$ 和 $\\Delta y = 1/(N_y-1)$。\n- 营养物浓度场 $c(\\mathbf{x}, t)$ 在此网格上离散化，记为 $c_{j,k}^n$，其中 $(j,k)$ 是网格索引，$n$ 是时间步索引。它被初始化为均匀值 $c_{j,k}^0 = 1$。\n- 时间步长 $\\Delta t$ 由扩散的显式欧拉稳定性条件确定，并附加了 $0.2$ 的安全系数：\n$$ \\Delta t = 0.2 \\frac{\\min(\\Delta x^2, \\Delta y^2)}{4D} $$\n对于本问题，$\\Delta x = \\Delta y$，表达式简化为 $\\Delta t = 0.2 \\frac{\\Delta x^2}{4D}$。\n- 离散智能体存储为列表或数组，每个智能体拥有其位置 $\\mathbf{x}_i \\in [0,1]^2$ 和整数年龄 $a_i \\in \\mathbb{N}_0$ 的状态变量。初始智能体位置已给出，初始年龄设置为 $a_i(0)=0$。\n\n**2. 模拟循环**\n\n模拟从 $n = 0, 1, \\dots, T-1$ 迭代进行。每个时间步包括三个主要部分：智能体动力学、汇项计算和偏微分方程场更新。\n\n**2.1. 智能体动力学与耦合（离散部分）**\n\n对于每个位置为 $\\mathbf{x}_i$、年龄为 $a_i$ 的智能体 $i$，其命运由局部营养物浓度 $c(\\mathbf{x}_i, t^n)$ 决定。由于智能体位置是连续的， $c(\\mathbf{x}_i, t^n)$ 通过对围绕 $\\mathbf{x}_i$ 的四个最近网格节点的值进行双线性插值来近似。令 $\\mathbf{x}_i = (x_i, y_i)$，并令 $(j,k)$ 为左下角网格节点的索引，即 $j = \\lfloor x_i/\\Delta x \\rfloor$ 和 $k = \\lfloor y_i/\\Delta y \\rfloor$。令 $u = (x_i/\\Delta x) - j$ 和 $v = (y_i/\\Delta y) - k$ 为小数部分距离。局部浓度为：\n$$ c(\\mathbf{x}_i) \\approx (1-u)(1-v)c_{k,j}^n + u(1-v)c_{k,j+1}^n + (1-u)v c_{k+1,j}^n + u v c_{k+1,j+1}^n $$\n根据此值，应用以下规则：\n- **凋亡：** 如果 $c(\\mathbf{x}_i) \\le c_{\\mathrm{apop}}$，则标记该智能体，以便从种群中移除。\n- **增殖：** 如果智能体存活下来且 $c(\\mathbf{x}_i) \\ge c_{\\mathrm{prolif}}$，其年龄增加：$a_i \\to a_i + 1$。如果更新后的年龄 $a_i$ 达到或超过分裂间隔 $T_{\\mathrm{div}}$，智能体就会分裂。父智能体的年龄重置为 $a_i=0$，并创建一个年龄为 $0$ 的子智能体。新智能体被放置在位置 $\\mathbf{x}_i + (\\Delta x, 0)$（如果该位置在 $\\Omega$ 内），否则放置在 $\\mathbf{x}_i - (\\Delta x, 0)$。最终位置被限制在域边界 $[0,1]^2$ 内。\n\n所有的移除和添加操作都被收集起来，并在智能体更新子步骤结束时同时应用，以确保一致性。\n\n**2.2. 汇项计算（耦合）**\n\n智能体对营养物的消耗在偏微分方程中被建模为汇项 $S^n_{j,k}$。该项对每个存活的智能体进行计算。\n- 对于每个智能体 $i$，其吸收速率由 Michaelis-Menten 函数给出：\n$$ \\lambda_i = \\lambda(c(\\mathbf{x}_i)) = k \\frac{c(\\mathbf{x}_i)}{K + c(\\mathbf{x}_i)} $$\n- 这个点汇使用与插值相同的双线性权重，分配到最近的四个网格节点 $(k,j), (k,j+1), (k+1,j), (k+1,j+1)$。为保持物理一致性，总吸收速率 $\\lambda_i$ 通过除以网格单元面积 $A_{cell} = \\Delta x \\Delta y$ 转换为汇密度。因此，智能体 $i$ 对节点 $(k,j)$ 处汇的贡献为：\n$$ \\Delta S_{k,j} = \\frac{\\lambda_i}{\\Delta x \\Delta y} (1-u)(1-v) $$\n类似项被加到其他三个节点上。总汇项 $S_{k,j}^n$ 是所有智能体贡献的总和。\n\n**2.3. 场更新（连续部分）**\n\n浓度场使用前向欧拉法进行更新：\n$$ c_{j,k}^{n+1} = c_{j,k}^n + \\Delta t \\left( D (\\nabla^2 c^n)_{j,k} - S^n_{j,k} \\right) $$\n- 拉普拉斯算子 $\\nabla^2 c$ 在均匀网格上（$\\Delta x=\\Delta y$）使用标准的 5 点有限差分模板进行近似：\n$$ (\\nabla^2 c^n)_{j,k} \\approx \\frac{c_{j+1,k}^n + c_{j-1,k}^n + c_{j,k+1}^n + c_{j,k-1}^n - 4c_{j,k}^n}{\\Delta x^2} $$\n- 零通量 Neumann 边界条件 $\\partial_{\\mathbf{n}} c = 0$ 通过用其边界值填充浓度网格来实现。这等效于将虚拟单元格的值设置为其相邻内部单元格的值，例如，在左边界上 $c_{-1,k} = c_{1,k}$。\n- 更新后，浓度值被裁剪为非负值，$c_{j,k}^{n+1} = \\max(0, c_{j,k}^{n+1})$，以防止可能由数值不精确性引起的非物理负值。\n\n经过 $T$ 个时间步后，模拟终止，并报告最终存活的智能体数量 $N(T)$。对问题陈述中指定的每个测试用例都执行此过程。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(Nx, Ny, D, k, K, c_prolif, c_apop, T_div, T, initial_agents_pos):\n    \"\"\"\n    Runs a single simulation of the hybrid discrete-continuum model.\n    \"\"\"\n    # 1. Initialization\n    dx = 1.0 / (Nx - 1)\n    dy = 1.0 / (Ny - 1)  # dx is assumed equal to dy in the problem\n    dt = 0.2 * (dx**2) / (4 * D)\n    \n    # Concentration field c[y, x]\n    c = np.ones((Ny, Nx), dtype=np.float64)\n    \n    # Agents array: [x, y, age]\n    if initial_agents_pos:\n        agents = np.array([[pos[0], pos[1], 0.0] for pos in initial_agents_pos], dtype=np.float64)\n    else:\n        agents = np.empty((0, 3), dtype=np.float64)\n\n    # 2. Main simulation loop\n    for _ in range(T):\n        sinks = np.zeros_like(c)\n        \n        if agents.shape[0]  0:\n            # 2.1. Agent Dynamics\n            # Get local concentration for each agent via bilinear interpolation\n            x_pos = agents[:, 0]\n            y_pos = agents[:, 1]\n            \n            x_scaled = x_pos / dx\n            y_scaled = y_pos / dy\n            \n            # Using min with Nx-2/Ny-2 ensures j+1/k+1 are valid indices\n            j = np.minimum(np.floor(x_scaled).astype(int), Nx - 2)\n            k = np.minimum(np.floor(y_scaled).astype(int), Ny - 2)\n\n            u = x_scaled - j\n            v = y_scaled - k\n            \n            # Vectorized bilinear interpolation for local concentration c_local\n            c_local = (1-v) * ((1-u) * c[k, j] + u * c[k, j+1]) + \\\n                      v * ((1-u) * c[k+1, j] + u * c[k+1, j+1])\n\n            # Apoptosis\n            apoptosis_mask = c_local = c_apop\n            surviving_mask = ~apoptosis_mask\n            \n            # Proliferation\n            prolif_mask = c_local = c_prolif\n            \n            # Filter to get data for agents that survive this step\n            agents = agents[surviving_mask]\n            c_local = c_local[surviving_mask]\n            prolif_mask = prolif_mask[surviving_mask]\n\n            if agents.shape[0]  0:\n                # 2.2. Sink Calculation\n                lambda_vals = k * c_local / (K + c_local)\n                sink_per_area = lambda_vals / (dx * dy)\n\n                x_pos = agents[:, 0]\n                y_pos = agents[:, 1]\n                x_scaled = x_pos / dx\n                y_scaled = y_pos / dy\n                j = np.minimum(np.floor(x_scaled).astype(int), Nx - 2)\n                k = np.minimum(np.floor(y_scaled).astype(int), Ny - 2)\n                u = x_scaled - j\n                v = y_scaled - k\n\n                # Distribute sinks to 4 nearest neighbors using bilinear weights.\n                # np.add.at is used to handle multiple agents contributing to the same node.\n                np.add.at(sinks, (k, j), (1-u)*(1-v) * sink_per_area)\n                np.add.at(sinks, (k, j+1), u*(1-v) * sink_per_area)\n                np.add.at(sinks, (k+1, j), (1-u)*v * sink_per_area)\n                np.add.at(sinks, (k+1, j+1), u*v * sink_per_area)\n\n                # Update ages for agents that are in a proliferative environment\n                agents[prolif_mask, 2] += 1\n                \n                # Division\n                division_mask = agents[:, 2] = T_div\n                dividing_agents = agents[division_mask]\n                \n                new_agents_list = []\n                if dividing_agents.shape[0]  0:\n                    # Reset age of parent agents\n                    agents[division_mask, 2] = 0\n                    \n                    for agent in dividing_agents:\n                        x, y, _ = agent\n                        x_new = x + dx\n                        # If new position is outside, choose the other side\n                        if x_new  1.0:\n                            x_new = x - dx\n                        \n                        # Clamp to ensure it remains within [0,1]\n                        x_new = np.clip(x_new, 0.0, 1.0)\n                        y_new = y\n                        \n                        new_agents_list.append([x_new, y_new, 0.0])\n                \n                # Update main agent array with new agents\n                if new_agents_list:\n                    agents = np.vstack([agents, np.array(new_agents_list, dtype=np.float64)])\n\n        # 2.3. Field Update\n        # Laplacian with Neumann BCs (padding with edge values)\n        c_padded = np.pad(c, 1, mode='edge')\n        lap_c = (c_padded[1:-1, :-2] + c_padded[1:-1, 2:] + \n                 c_padded[:-2, 1:-1] + c_padded[2:, 1:-1] - 4*c) / (dx**2)\n        \n        # Forward Euler time step\n        c += dt * (D * lap_c - sinks)\n        \n        # Ensure concentration is non-negative\n        np.clip(c, 0, None, out=c)\n    \n    return agents.shape[0]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the final results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {\n            'Nx': 64, 'Ny': 64, 'D': 1e-3, 'k': 5e-2, 'K': 1e-1,\n            'c_prolif': 0.7, 'c_apop': 0.2, 'T_div': 30, 'T': 220,\n            'initial_agents_pos': [(0.5, 0.5), (0.55, 0.5)]\n        },\n        # Case B\n        {\n            'Nx': 64, 'Ny': 64, 'D': 1e-3, 'k': 2e-1, 'K': 5e-2,\n            'c_prolif': 0.6, 'c_apop': 0.4, 'T_div': 40, 'T': 200,\n            'initial_agents_pos': [(0.02, 0.02), (0.98, 0.98)]\n        },\n        # Case C\n        {\n            'Nx': 64, 'Ny': 64, 'D': 1e-3, 'k': 1e-1, 'K': 1e-1,\n            'c_prolif': 0.9, 'c_apop': 0.1, 'T_div': 20, 'T': 100,\n            'initial_agents_pos': []\n        }\n    ]\n    \n    results = []\n    for params in test_cases:\n        final_agent_count = run_simulation(**params)\n        results.append(final_agent_count)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "4353262"}]}