{"hands_on_practices": [{"introduction": "要研究基因表达噪音，第一步是能够将其定量地分解为内在和外在两个部分。双报告基因实验是实现这一目标的经典实验方法。这项练习将引导你完成从统计学上推导这两个噪音分量的估计量，为理解噪音的构成提供坚实的定量基础。[@problem_id:4357122]", "problem": "在基因表达双报告基因分析中，于同一细胞内测量两个受相同调控的荧光报告基因，以将总变异性分解为内源性和外源性组分。考虑一个由 $N$ 个独立细胞组成的群体，其索引为 $i \\in \\{1,\\dots,N\\}$，两个报告基因的测量表达水平分别为 $X_i$ 和 $Y_i$。假设存在以下基于系统生物医学对基因表达变异性的观点所建立的机制性分解：每个细胞都有一个潜在的外源性状态 $M_i$，它以加性且相同的方式影响两个报告基因，并且每个报告基因在细胞内都有其自身的内源性波动。形式上，假设\n$$\nX_i \\;=\\; M_i \\;+\\; \\epsilon_{x,i}, \n\\qquad\nY_i \\;=\\; M_i \\;+\\; \\epsilon_{y,i},\n$$\n其中，对于不同的 $i$，细胞是独立的；外源性状态 $\\{M_i\\}$ 是独立同分布的，其均值为 $\\mu_m$，方差为 $\\sigma_{e}^{2}$；内源性波动 $\\{\\epsilon_{x,i}\\}$ 和 $\\{\\epsilon_{y,i}\\}$ 是独立同分布的，其均值为零，方差为 $\\sigma_{i}^{2}$；并且对于每个 $i$，$(M_i,\\epsilon_{x,i},\\epsilon_{y,i})$ 是相互独立的。进一步假设联合高斯性，使得 $(X_i,Y_i)$ 服从二元正态分布，其协方差矩阵为 $\\Sigma$，并且样本协方差矩阵服从威沙特分布。\n\n将内源性噪声定义为可归因于细胞内报告基因特异性波动的方差组分，将外源性噪声定义为可归因于潜在状态的细胞间变异的方差组分。利用上述机制性假设和仅关于正态样本的基本统计事实，用观测数据 $\\{(X_i,Y_i)\\}_{i=1}^{N}$ 来推导内源性方差 $\\sigma_{i}^{2}$ 和外源性方差 $\\sigma_{e}^{2}$ 的无偏估计量。然后，在联合高斯假设下，推导这些估计量的抽样方差 $\\operatorname{Var}(\\widehat{\\sigma}_{i}^{2})$ 和 $\\operatorname{Var}(\\widehat{\\sigma}_{e}^{2})$，并将其表示为总体参数 $\\sigma_{i}^{2}$ 和 $\\sigma_{e}^{2}$ 以及样本量 $N$ 的函数。\n\n你的最终答案必须是一个单行矩阵，按顺序包含 $\\sigma_{i}^{2}$ 的无偏估计量、$\\sigma_{e}^{2}$ 的无偏估计量、内源性估计量的抽样方差和外源性估计量的抽样方差，每个都以闭合形式表示。无需数值近似或四舍五入。使用分母为 $N-1$ 的常规样本均值以及无偏样本方差和协方差定义。", "solution": "双报告基因的构造为将变异性分解为内源性和外源性组分提供了机制上合理的依据。其根本基础是加性模型\n$$\nX_i \\;=\\; M_i \\;+\\; \\epsilon_{x,i}, \n\\qquad\nY_i \\;=\\; M_i \\;+\\; \\epsilon_{y,i},\n$$\n其中 $M_i$ 代表外源性的细胞间波动，而 $\\epsilon_{x,i},\\epsilon_{y,i}$ 代表同一细胞内的内源性报告基因特异性波动。根据独立性和相同调控的假设，我们有\n$$\n\\mathbb{E}[M_i] \\;=\\; \\mu_m, \\quad \\operatorname{Var}(M_i) \\;=\\; \\sigma_{e}^{2},\n\\quad \\mathbb{E}[\\epsilon_{x,i}] \\;=\\; \\mathbb{E}[\\epsilon_{y,i}] \\;=\\; 0,\n\\quad \\operatorname{Var}(\\epsilon_{x,i}) \\;=\\; \\operatorname{Var}(\\epsilon_{y,i}) \\;=\\; \\sigma_{i}^{2},\n$$\n且对于每个细胞 $i$，$(M_i,\\epsilon_{x,i},\\epsilon_{y,i})$ 相互独立，并且不同细胞 $i$ 之间也相互独立。\n\n根据这些定义，\n$$\n\\operatorname{Var}(X_i) \\;=\\; \\operatorname{Var}(M_i) + \\operatorname{Var}(\\epsilon_{x,i}) \\;=\\; \\sigma_{e}^{2} + \\sigma_{i}^{2},\n$$\n$$\n\\operatorname{Var}(Y_i) \\;=\\; \\sigma_{e}^{2} + \\sigma_{i}^{2},\n\\qquad\n\\operatorname{Cov}(X_i,Y_i) \\;=\\; \\operatorname{Var}(M_i) \\;=\\; \\sigma_{e}^{2}.\n$$\n定义细胞内差异 $D_i = X_i - Y_i$。那么\n$$\n\\mathbb{E}[D_i] \\;=\\; \\mathbb{E}[X_i - Y_i] \\;=\\; \\mathbb{E}[M_i + \\epsilon_{x,i} - M_i - \\epsilon_{y,i}] \\;=\\; 0,\n$$\n并且，利用 $\\epsilon_{x,i}$ 和 $\\epsilon_{y,i}$ 的独立性，\n$$\n\\operatorname{Var}(D_i) \\;=\\; \\operatorname{Var}(X_i - Y_i) \\;=\\; \\operatorname{Var}(\\epsilon_{x,i} - \\epsilon_{y,i})\n\\;=\\; \\operatorname{Var}(\\epsilon_{x,i}) + \\operatorname{Var}(\\epsilon_{y,i})\n\\;=\\; 2 \\sigma_{i}^{2}.\n$$\n因此，内源性方差组分为 $\\sigma_{i}^{2} = \\frac{1}{2} \\operatorname{Var}(D_i)$，而外源性方差组分是两个报告基因的协方差，即 $\\sigma_{e}^{2} = \\operatorname{Cov}(X_i,Y_i)$。\n\n给定观测数据 $\\{(X_i,Y_i)\\}_{i=1}^{N}$，令\n$$\n\\bar{X} = \\frac{1}{N} \\sum_{i=1}^{N} X_i, \n\\quad\n\\bar{Y} = \\frac{1}{N} \\sum_{i=1}^{N} Y_i,\n\\quad\nD_i = X_i - Y_i,\n\\quad\n\\bar{D} = \\frac{1}{N} \\sum_{i=1}^{N} D_i = \\bar{X} - \\bar{Y}.\n$$\n将差异的无偏样本方差和报告基因的无偏样本协方差定义为\n$$\ns_{D}^{2} = \\frac{1}{N-1} \\sum_{i=1}^{N} (D_i - \\bar{D})^{2},\n\\qquad\ns_{XY} = \\frac{1}{N-1} \\sum_{i=1}^{N} (X_i - \\bar{X})(Y_i - \\bar{Y}).\n$$\n对于独立同分布样本的无偏样本方差和协方差估计量，根据其标准性质，\n$$\n\\mathbb{E}[s_{D}^{2}] = \\operatorname{Var}(D_i) = 2 \\sigma_{i}^{2},\n\\qquad\n\\mathbb{E}[s_{XY}] = \\operatorname{Cov}(X_i,Y_i) = \\sigma_{e}^{2}.\n$$\n因此，内源性和外源性方差组分的无偏估计量是\n$$\n\\widehat{\\sigma}_{i}^{2} = \\frac{1}{2} \\, s_{D}^{2} = \\frac{1}{2(N-1)} \\sum_{i=1}^{N} (D_i - \\bar{D})^{2},\n\\qquad\n\\widehat{\\sigma}_{e}^{2} = s_{XY} = \\frac{1}{N-1} \\sum_{i=1}^{N} (X_i - \\bar{X})(Y_i - \\bar{Y}).\n$$\n\n我们现在在联合高斯假设下推导这些估计量的抽样方差。对于内源性估计量，注意到 $D_i$ 是独立的，且服从均值为 $0$、方差为 $\\sigma_{D}^{2} = \\operatorname{Var}(D_i) = 2 \\sigma_{i}^{2}$ 的正态分布。缩放后的样本方差服从卡方分布：\n$$\n\\frac{(N-1)\\, s_{D}^{2}}{\\sigma_{D}^{2}} \\sim \\chi^{2}_{N-1}.\n$$\n自由度为 $k$ 的卡方随机变量的方差为 $2k$，所以\n$$\n\\operatorname{Var}\\!\\left( (N-1) s_{D}^{2} \\right) = 2 (N-1) \\sigma_{D}^{4},\n$$\n两边除以 $(N-1)^{2}$ 得到\n$$\n\\operatorname{Var}\\!\\left( s_{D}^{2} \\right) = \\frac{2 \\sigma_{D}^{4}}{N-1}.\n$$\n代入 $\\sigma_{D}^{2} = 2 \\sigma_{i}^{2}$ 可得 $\\sigma_{D}^{4} = 4 \\sigma_{i}^{4}$ 并且\n$$\n\\operatorname{Var}\\!\\left( s_{D}^{2} \\right) = \\frac{2 \\cdot 4 \\sigma_{i}^{4}}{N-1} = \\frac{8 \\sigma_{i}^{4}}{N-1}.\n$$\n因为 $\\widehat{\\sigma}_{i}^{2} = \\frac{1}{2} s_{D}^{2}$，所以\n$$\n\\operatorname{Var}\\!\\left( \\widehat{\\sigma}_{i}^{2} \\right) = \\frac{1}{4} \\operatorname{Var}\\!\\left( s_{D}^{2} \\right) = \\frac{1}{4} \\cdot \\frac{8 \\sigma_{i}^{4}}{N-1} = \\frac{2 \\sigma_{i}^{4}}{N-1}.\n$$\n\n对于外源性估计量，考虑无偏样本协方差 $s_{XY}$。在二元正态假设下，协方差矩阵为\n$$\n\\Sigma = \\begin{pmatrix}\n\\sigma_{x}^{2} & \\sigma_{xy} \\\\\n\\sigma_{xy} & \\sigma_{y}^{2}\n\\end{pmatrix}\n= \\begin{pmatrix}\n\\sigma_{e}^{2} + \\sigma_{i}^{2} & \\sigma_{e}^{2} \\\\\n\\sigma_{e}^{2} & \\sigma_{e}^{2} + \\sigma_{i}^{2}\n\\end{pmatrix},\n$$\n缩放后的样本协方差矩阵 $(N-1)\\, S$（其中 $S$ 的元素为 $s_{XX}, s_{XY}, s_{YY}$）服从威沙特分布 $\\mathcal{W}_{2}(N-1, \\Sigma)$。威沙特分布的一个经过验证的公式表明，对于非对角线元素，\n$$\n\\operatorname{Var}\\!\\left( s_{XY} \\right) = \\frac{1}{N-1} \\left( \\sigma_{xy}^{2} + \\sigma_{x}^{2} \\sigma_{y}^{2} \\right).\n$$\n代入 $\\sigma_{xy} = \\sigma_{e}^{2}$ 和 $\\sigma_{x}^{2} = \\sigma_{y}^{2} = \\sigma_{e}^{2} + \\sigma_{i}^{2}$，我们得到\n$$\n\\operatorname{Var}\\!\\left( \\widehat{\\sigma}_{e}^{2} \\right) = \\operatorname{Var}\\!\\left( s_{XY} \\right) = \\frac{1}{N-1} \\left( \\sigma_{e}^{4} + (\\sigma_{e}^{2} + \\sigma_{i}^{2})^{2} \\right)\n= \\frac{1}{N-1} \\left( 2 \\sigma_{e}^{4} + 2 \\sigma_{e}^{2} \\sigma_{i}^{2} + \\sigma_{i}^{4} \\right).\n$$\n\n汇总结果，无偏估计量及其抽样方差为：\n$$\n\\widehat{\\sigma}_{i}^{2} = \\frac{1}{2(N-1)} \\sum_{i=1}^{N} (X_i - Y_i - \\bar{X} + \\bar{Y})^{2},\n\\qquad\n\\widehat{\\sigma}_{e}^{2} = \\frac{1}{N-1} \\sum_{i=1}^{N} (X_i - \\bar{X})(Y_i - \\bar{Y}),\n$$\n$$\n\\operatorname{Var}\\!\\left( \\widehat{\\sigma}_{i}^{2} \\right) = \\frac{2 \\sigma_{i}^{4}}{N-1},\n\\qquad\n\\operatorname{Var}\\!\\left( \\widehat{\\sigma}_{e}^{2} \\right) = \\frac{2 \\sigma_{e}^{4} + 2 \\sigma_{e}^{2} \\sigma_{i}^{2} + \\sigma_{i}^{4}}{N-1}.\n$$\n这些表达式根据内源性和外源性方差组分以及样本量来量化估计量的精度。", "answer": "$$\\boxed{\\begin{pmatrix}\n\\frac{1}{2(N-1)} \\sum_{i=1}^{N} (X_i - Y_i - \\bar{X} + \\bar{Y})^{2} &\n\\frac{1}{N-1} \\sum_{i=1}^{N} (X_i - \\bar{X})(Y_i - \\bar{Y}) &\n\\frac{2 \\sigma_{i}^{4}}{N-1} &\n\\frac{2 \\sigma_{e}^{4} + 2 \\sigma_{e}^{2} \\sigma_{i}^{2} + \\sigma_{i}^{4}}{N-1}\n\\end{pmatrix}}$$", "id": "4357122"}, {"introduction": "在学会如何估计外在噪音后，下一步自然是识别其生物学来源。细胞内的核糖体丰度或细胞体积等因素常被假定为外在噪音的主要驱动因素。本练习提供了一种基于结构方程模型的实践方法，通过对合成数据进行拟合，来检验这些假设，从而教会你如何使用统计模型选择方法，将抽象的噪音分量与具体的生物学机制联系起来。[@problem_id:4357124]", "problem": "您将承担一项系统生物医学领域的建模任务，重点关注基因表达中的内在和外在噪声。该任务的基础包括：分子生物学的中心法则（脱氧核糖核酸到核糖核酸到蛋白质），内在噪声的定义（细胞内反应事件时间的随机波动），外在噪声的定义（共享资源和全局状态在细胞间的变异性），以及高斯线性模型在最大似然估计下的性质。\n\n考虑对 $n$ 个细胞的单细胞测量数据，其中包括两个候选外在驱动因素：核糖体丰度 $R$（每个细胞的分子数）和细胞体积 $V$（飞升），以及 $m$ 个基因的表达水平 $Y_j$（每个细胞的分子数）。内在噪声被建模为每个基因、每个细胞在 $Y_j$ 水平上的独立高斯残差变异。外在协变量 $R$ 和 $V$ 被视为测量误差可忽略的观测外生变量。\n\n定义三个结构方程模型 (SEM)，并在高斯线性模型框架下使用最大似然法对它们进行拟合：\n\n- 模型 $\\mathcal{M}_R$：对于每个基因 $j \\in \\{1,\\dots,m\\}$ 和细胞 $i \\in \\{1,\\dots,n\\}$，其结构方程为\n$$\nY_{ij} = \\alpha_j + \\gamma^{R}_j R_i + \\varepsilon_{ij},\n$$\n其中 $\\varepsilon_{ij} \\sim \\mathcal{N}(0,\\sigma_j^2)$，在 $i$ 和 $j$ 上独立。\n\n- 模型 $\\mathcal{M}_V$：\n$$\nY_{ij} = \\alpha_j + \\gamma^{V}_j V_i + \\varepsilon_{ij},\n$$\n其中 $\\varepsilon_{ij} \\sim \\mathcal{N}(0,\\sigma_j^2)$ 独立。\n\n- 模型 $\\mathcal{M}_{RV}$：\n$$\nY_{ij} = \\alpha_j + \\gamma^{R}_j R_i + \\gamma^{V}_j V_i + \\varepsilon_{ij},\n$$\n其中 $\\varepsilon_{ij} \\sim \\mathcal{N}(0,\\sigma_j^2)$ 独立。\n\n假设所有残差均为高斯分布，并且 $R$ 和 $V$ 在细胞间可能相关。对于给定的模型和基因 $j$，回归系数的最大似然估计量 (MLE) 等于普通最小二乘解，而 $\\sigma_j^2$ 的 MLE 等于残差平方和除以 $n$。对于固定的基因 $j$，在高斯残差模型下的最大化对数似然为\n$$\n\\ell_j = -\\frac{n}{2}\\left(\\log(2\\pi) + \\log(\\hat{\\sigma}_j^2) + 1\\right),\n$$\n其中 $\\hat{\\sigma}_j^2$ 是从该基因的拟合中得到的 $\\sigma_j^2$ 的 MLE。总对数似然是所有基因的总和，\n$$\n\\ell_{\\text{total}} = \\sum_{j=1}^m \\ell_j.\n$$\n\n令 $k$ 表示模型中估计的自由参数总数。对于 $\\mathcal{M}_R$ 和 $\\mathcal{M}_V$，每个基因贡献1个截距、1个斜率和1个方差参数，因此 $k = 3m$。对于 $\\mathcal{M}_{RV}$，每个基因贡献1个截距、2个斜率和1个方差参数，因此 $k = 4m$。对信息准则使用总样本量 $N_{\\text{tot}} = nm$。通过以下公式计算赤池信息准则 (AIC) 和贝叶斯信息准则 (BIC)：\n$$\n\\mathrm{AIC} = 2k - 2\\ell_{\\text{total}}, \\quad \\mathrm{BIC} = k \\log(N_{\\text{tot}}) - 2\\ell_{\\text{total}}.\n$$\n\n为了检验核糖体丰度或细胞体积是否是基因表达变异性的主要外在驱动因素，请拟合所有三个模型，并通过上述信息准则进行比较。此外，对嵌套模型对 $\\mathcal{M}_{RV}$ 与 $\\mathcal{M}_R$ 以及 $\\mathcal{M}_{RV}$ 与 $\\mathcal{M}_V$ 进行似然比检验。嵌套比较的似然比统计量为\n$$\n\\Lambda = 2\\left(\\ell_{\\text{full}} - \\ell_{\\text{reduced}}\\right),\n$$\n在附加参数为零的原假设下，该统计量服从自由度等于参数数量之差（即 $m$）的卡方分布。报告卡方生存函数 $p$ 值（即 $p = P(\\chi^2_m \\ge \\Lambda)$）。\n\n主要外在驱动因素的选择规则：\n- 计算 $\\mathcal{M}_R$、$\\mathcal{M}_V$ 和 $\\mathcal{M}_{RV}$ 的 $\\mathrm{BIC}$。\n- 令 $b^*$ 为三个 $\\mathrm{BIC}$ 值中的最小值。如果最小值出现在 $\\mathcal{M}_{RV}$，则声明两个外在驱动因素都有贡献（输出代码 $2$）。否则，如果最小值出现在 $\\mathcal{M}_R$，则声明核糖体丰度为主要驱动因素（输出代码 $0$），如果出现在 $\\mathcal{M}_V$，则声明细胞体积为主要驱动因素（输出代码 $1$）。\n- 如果在 $\\mathrm{BIC}$ 上出现数值容差 $\\delta = 10^{-8}$ 内的平局，则优先选择更简单的模型（参数更少）。如果 $\\mathcal{M}_R$ 和 $\\mathcal{M}_V$ 之间仍然存在平局，则优先选择 $\\mathcal{M}_R$。\n\n根据以下测试套件生成合成数据集。在所有情况下，从均值为 $(\\mu_R,\\mu_V)$、标准差为 $(\\sigma_R,\\sigma_V)$、相关系数为 $\\rho$ 的二元正态分布中联合抽取 $(R_i, V_i)$，即协方差 $\\mathrm{Cov}(R,V) = \\rho \\sigma_R \\sigma_V$。对于每个基因 $j$，抽取独立的高斯内在残差 $\\varepsilon_{ij} \\sim \\mathcal{N}(0,\\sigma_j^2)$，并使用给定的截距 $\\alpha_j$ 和斜率 $\\gamma^R_j$、$\\gamma^V_j$ 从指定的结构方程构建 $Y_{ij}$。使用指定的种子以确保可复现性。单位：$R$ 的单位是每个细胞的分子数，$V$ 的单位是飞升，$Y$ 的单位是每个细胞的分子数。\n\n测试用例（每个用例都是一个完整的参数规范）：\n- 用例 1 (种子 $101$)：$n=300$, $m=3$, $\\mu_R=50000$, $\\sigma_R=5000$, $\\mu_V=100$, $\\sigma_V=10$, $\\rho=0.3$; 基因参数\n  - $j=1$: $\\alpha_1=5.0$, $\\gamma^R_1=0.00030$, $\\gamma^V_1=0.0$, $\\sigma_1=2.0$;\n  - $j=2$: $\\alpha_2=8.0$, $\\gamma^R_2=0.00025$, $\\gamma^V_2=0.0$, $\\sigma_2=2.5$;\n  - $j=3$: $\\alpha_3=3.0$, $\\gamma^R_3=0.00020$, $\\gamma^V_3=0.0$, $\\sigma_3=1.5$。\n- 用例 2 (种子 $202$)：$n=300$, $m=3$, $\\mu_R=50000$, $\\sigma_R=5000$, $\\mu_V=100$, $\\sigma_V=10$, $\\rho=0.3$; 基因参数\n  - $j=1$: $\\alpha_1=7.0$, $\\gamma^R_1=0.0$, $\\gamma^V_1=0.060$, $\\sigma_1=2.5$;\n  - $j=2$: $\\alpha_2=4.0$, $\\gamma^R_2=0.0$, $\\gamma^V_2=0.050$, $\\sigma_2=2.0$;\n  - $j=3$: $\\alpha_3=6.0$, $\\gamma^R_3=0.0$, $\\gamma^V_3=0.040$, $\\sigma_3=2.5$。\n- 用例 3 (种子 $303$)：$n=400$, $m=4$, $\\mu_R=50000$, $\\sigma_R=6000$, $\\mu_V=100$, $\\sigma_V=12$, $\\rho=0.9$; 基因参数\n  - $j=1$: $\\alpha_1=10.0$, $\\gamma^R_1=0.00025$, $\\gamma^V_1=0.050$, $\\sigma_1=3.0$;\n  - $j=2$: $\\alpha_2=12.0$, $\\gamma^R_2=0.00030$, $\\gamma^V_2=0.040$, $\\sigma_2=3.0$;\n  - $j=3$: $\\alpha_3=8.0$, $\\gamma^R_3=0.00028$, $\\gamma^V_3=0.060$, $\\sigma_3=2.5$;\n  - $j=4$: $\\alpha_4=6.0$, $\\gamma^R_4=0.00027$, $\\gamma^V_4=0.030$, $\\sigma_4=3.5$。\n- 用例 4 (种子 $404$)：$n=30$, $m=5$, $\\mu_R=50000$, $\\sigma_R=5000$, $\\mu_V=100$, $\\sigma_V=10$, $\\rho=0.5$; 基因参数\n  - $j=1$: $\\alpha_1=5.0$, $\\gamma^R_1=0.00010$, $\\gamma^V_1=0.020$, $\\sigma_1=8.0$;\n  - $j=2$: $\\alpha_2=7.0$, $\\gamma^R_2=0.00005$, $\\gamma^V_2=0.000, \\sigma_2=10.0$;\n  - $j=3$: $\\alpha_3=9.0$, $\\gamma^R_3=0.00000$, $\\gamma^V_3=0.030, \\sigma_3=9.0$;\n  - $j=4$: $\\alpha_4=4.0$, $\\gamma^R_4=0.00008$, $\\gamma^V_4=0.010, \\sigma_4=7.0$;\n  - $j=5$: $\\alpha_5=6.0$, $\\gamma^R_5=0.00002$, $\\gamma^V_5=0.000, \\sigma_5=8.0$。\n\n您的程序必须：\n- 为每个测试用例生成指定的数据。\n- 使用最大似然法（对每个基因的系数使用普通最小二乘法，方差使用基于残差的方法）拟合 $\\mathcal{M}_R$、$\\mathcal{M}_V$ 和 $\\mathcal{M}_{RV}$。\n- 计算每个模型的总对数似然 $\\ell_{\\text{total}}$、$\\mathrm{AIC}$、$\\mathrm{BIC}$，以及 $\\mathcal{M}_{RV}$ 与 $\\mathcal{M}_R$ 和 $\\mathcal{M}_{RV}$ 与 $\\mathcal{M}_V$ 比较的似然比 $p$ 值。\n- 根据上述规则选择主要驱动因素，并将其编码为整数：核糖体丰度 $\\to 0$，体积 $\\to 1$，两者皆是 $\\to 2$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个元素对应一个测试用例，并且本身是按以下顺序排列的列表：\n$$\n[\\text{model\\_code},\\ \\ell_R,\\ \\ell_V,\\ \\ell_{RV},\\ \\mathrm{AIC}_R,\\ \\mathrm{AIC}_V,\\ \\mathrm{AIC}_{RV},\\ \\mathrm{BIC}_R,\\ \\mathrm{BIC}_V,\\ \\mathrm{BIC}_{RV},\\ p_{\\mathrm{LR}(RV\\ \\mathrm{vs}\\ R)},\\ p_{\\mathrm{LR}(RV\\ \\mathrm{vs}\\ V)}].\n$$\n所有数值必须打印为 Python 浮点数或整数，$p$ 值必须是浮点数。单行输出必须采用以下格式：\n$$\n[\\text{case1\\_result},\\text{case2\\_result},\\text{case3\\_result},\\text{case4\\_result}],\n$$\n无附加文本。", "solution": "用户提供了一个系统生物医学领域的问题，重点是通过统计模型选择来区分假设的基因表达噪声外在驱动因素。该问题要求生成合成单细胞数据，拟合三个不同的线性模型，并使用信息准则（AIC, BIC）和似然比检验（LRT）对它们进行评估。\n\n### 第 1 步：问题验证\n\n问题陈述已根据指定的验证标准进行了仔细审查。\n\n- **提取给定条件**：所有变量（$n, m, R, V, Y, \\varepsilon$）、模型方程（$\\mathcal{M}_R, \\mathcal{M}_V, \\mathcal{M}_{RV}$）、统计公式（$\\sigma_j^2$ 的 MLE、最大化对数似然 $\\ell_j$、AIC、BIC、LRT 统计量 $\\Lambda$）、参数计数（$k$）、准则的总样本量（$N_{\\text{tot}}$）、模型选择规则（基于 BIC 并有平局打破规则），以及四个合成测试用例的参数（包括随机种子）都已明确无误地提供。\n\n- **验证检查**：\n    1.  **科学依据**：该问题在分子系统生物学和统计学方面有充分的依据。使用线性模型来近似基因表达与细胞因素（如核糖体数量和细胞体积）之间的关系是一种标准且科学上合理的方法。统计方法（MLE, OLS, AIC, BIC, LRT）是统计推断和模型选择的基石。\n    2.  **适定性**：该问题是适定的。它为数据生成、模型拟合、评估和选择提供了完整的规范和确定性算法。这确保了每个测试用例都存在唯一且有意义的解。\n    3.  **客观性**：该问题以精确、客观的数学和计算术语陈述，没有任何主观或模糊的语言。\n    4.  **一致性和完整性**：该问题是自洽的。所有必需的公式和参数都已提供。没有内部矛盾。例如，卡方检验的自由度（$m$）正确地对应于嵌套模型之间参数数量的差异（$k_{RV} - k_R = 4m - 3m = m$）。\n\n- **结论**：该问题是**有效的**。它是一个定义明确的计算和统计任务，植根于既定的科学和数学原理。我们可以着手解决。\n\n### 第 2 步：求解推导\n\n解决方案将是一个程序，它为每个测试用例执行所需的步骤：数据模拟、模型拟合、统计评估和模型选择。\n\n#### 第 1 部分：合成数据生成\n\n对于每个测试用例，我们首先生成合成数据集。\n1.  **设置随机种子**：我们对每个用例使用 `numpy` 的随机数生成器，并设置指定的种子，以确保可复现性。\n2.  **生成外在协变量**：外在驱动因素，即核糖体丰度 $R$ 和细胞体积 $V$，是从一个二元正态分布中为 $n$ 个细胞抽取的。该分布由一个均值向量 $[\\mu_R, \\mu_V]$ 和一个协方差矩阵指定：\n    $$\n    \\Sigma = \\begin{pmatrix} \\sigma_R^2 & \\rho \\sigma_R \\sigma_V \\\\ \\rho \\sigma_R \\sigma_V & \\sigma_V^2 \\end{pmatrix}\n    $$\n3.  **生成基因表达数据**：对于 $m$ 个基因中的每一个，我们为 $n$ 个细胞生成表达水平。细胞 $i$ 中基因 $j$ 的数据 $Y_{ij}$ 是根据测试用例中指定的生成模型构建的。其通用形式为 $Y_{ij} = \\alpha_j + \\gamma^{R}_j R_i + \\gamma^{V}_j V_i + \\varepsilon_{ij}$，其中内在噪声 $\\varepsilon_{ij}$ 从独立的标准高斯分布 $\\mathcal{N}(0, \\sigma_j^2)$ 中抽取。生成的表达数据构成一个 $n \\times m$ 的矩阵 $Y$。\n\n#### 第 2 部分：模型拟合与评估\n\n对于每个测试用例和三个模型（$\\mathcal{M}_R, \\mathcal{M}_V, \\mathcal{M}_{RV}$）中的每一个，我们执行以下步骤。\n\n1.  **普通最小二乘 (OLS) 回归**：对于每个基因 $j \\in \\{1, \\dots, m\\}$，我们拟合指定的线性模型。问题陈述指出，回归系数（$\\alpha_j$ 和 $\\gamma_j$）的最大似然估计 (MLE) 等价于 OLS 解。对于形式为 $\\mathbf{y}_j = X \\boldsymbol{\\beta}_j + \\boldsymbol{\\varepsilon}_j$ 的模型，OLS 估计为 $\\hat{\\boldsymbol{\\beta}}_j = (X^T X)^{-1} X^T \\mathbf{y}_j$。设计矩阵 $X$ 根据模型构建：\n    -   对于 $\\mathcal{M}_R$：$X = [\\mathbf{1}, \\mathbf{R}]$，一个 $n \\times 2$ 的矩阵。\n    -   对于 $\\mathcal{M}_V$：$X = [\\mathbf{1}, \\mathbf{V}]$，一个 $n \\times 2$ 的矩阵。\n    -   对于 $\\mathcal{M}_{RV}$：$X = [\\mathbf{1}, \\mathbf{R}, \\mathbf{V}]$，一个 $n \\times 3$ 的矩阵。\n    其中 $\\mathbf{1}$ 是一个全为1的向量，$\\mathbf{R}$ 和 $\\mathbf{V}$ 是协变量值的向量。\n\n2.  **对数似然计算**：在获得系数估计 $\\hat{\\boldsymbol{\\beta}}_j$ 后，我们计算模型的总对数似然。\n    -   首先，我们计算每个基因的残差：$\\mathbf{e}_j = \\mathbf{y}_j - X\\hat{\\boldsymbol{\\beta}}_j$。\n    -   接着，我们计算残差平方和：$\\mathrm{RSS}_j = \\sum_{i=1}^n e_{ij}^2 = \\mathbf{e}_j^T \\mathbf{e}_j$。\n    -   基因 $j$ 的残差方差的 MLE 由 $\\hat{\\sigma}_j^2 = \\mathrm{RSS}_j / n$ 给出。\n    -   然后使用以下公式计算基因 $j$ 的最大化对数似然：\n        $$\n        \\ell_j = -\\frac{n}{2}\\left(\\log(2\\pi) + \\log(\\hat{\\sigma}_j^2) + 1\\right)\n        $$\n    -   模型的总对数似然是所有基因的总和：$\\ell_{\\text{total}} = \\sum_{j=1}^m \\ell_j$。\n\n#### 第 3 部分：模型比较\n\n利用三个模型的总对数似然（$\\ell_{\\text{total},R}, \\ell_{\\text{total},V}, \\ell_{\\text{total},RV}$），我们开始比较这些模型。\n\n1.  **信息准则 (AIC & BIC)**：\n    -   为每个模型确定自由参数的数量：$k_R = k_V = 3m$ 和 $k_{RV} = 4m$。每个基因的拟合贡献一个截距、一个或多个斜率以及一个方差参数。\n    -   准则的总样本量为 $N_{\\text{tot}} = nm$。\n    -   AIC 和 BIC 计算如下：\n        $$\n        \\mathrm{AIC} = 2k - 2\\ell_{\\text{total}}\n        $$\n        $$\n        \\mathrm{BIC} = k \\log(N_{\\text{tot}}) - 2\\ell_{\\text{total}}\n        $$\n\n2.  **似然比检验 (LRT)**：\n    -   我们比较嵌套模型（$\\mathcal{M}_{RV}$ vs. $\\mathcal{M}_R$ 和 $\\mathcal{M}_{RV}$ vs. $\\mathcal{M}_V$）。\n    -   检验统计量为 $\\Lambda = 2(\\ell_{\\text{full}} - \\ell_{\\text{reduced}})$。\n    -   在原假设（即更简单的模型是充分的）下，$\\Lambda$ 服从自由度等于参数数量之差的 $\\chi^2$ 分布，即 $k_{RV} - k_R = m$（或 $k_{RV} - k_V = m$）。\n    -   我们将 $p$ 值计算为在 $\\Lambda$ 处评估的 $\\chi^2_m$ 分布的生存函数，即 $P(\\chi^2_m \\ge \\Lambda)$。这通过使用 `scipy.stats.chi2.sf` 来完成。\n\n#### 第 4 部分：模型选择与输出格式化\n\n1.  **选择规则**：最终模型根据 BIC 值选择。\n    -   我们找到三个模型中的最小 BIC 值：$b^* = \\min(\\mathrm{BIC}_R, \\mathrm{BIC}_V, \\mathrm{BIC}_{RV})$。\n    -   我们识别出所有 BIC 值在 $b^*$ 的一个容差 $\\delta = 10^{-8}$ 范围内的模型。\n    -   从这组候选模型中，我们根据指定的偏好层次结构选择一个：$\\mathcal{M}_R$ 优先于 $\\mathcal{M}_V$，而两者都优先于更复杂的 $\\mathcal{M}_{RV}$。这通过在候选模型中首先检查 $\\mathcal{M}_R$，然后是 $\\mathcal{M}_V$，最后是 $\\mathcal{M}_{RV}$ 来实现。\n    -   选定的模型被编码为一个整数：$\\mathcal{M}_R$ 为 $0$，$\\mathcal{M}_V$ 为 $1$，$\\mathcal{M}_{RV}$ 为 $2$。\n\n2.  **输出**：对于每个测试用例，我们将十二个计算出的值（模型代码、三个对数似然、三个 AIC、三个 BIC、两个 $p$ 值）收集到一个列表中。最终输出是包含这些结果列表的列表的单行，格式化为字符串。\n\n这个综合性过程在下面的 Python 程序中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for the gene expression modeling problem.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"id\": 1, \"seed\": 101, \"n\": 300, \"m\": 3,\n            \"mu_R\": 50000, \"sigma_R\": 5000, \"mu_V\": 100, \"sigma_V\": 10, \"rho\": 0.3,\n            \"gene_params\": [\n                (5.0, 0.00030, 0.0, 2.0),\n                (8.0, 0.00025, 0.0, 2.5),\n                (3.0, 0.00020, 0.0, 1.5)\n            ]\n        },\n        {\n            \"id\": 2, \"seed\": 202, \"n\": 300, \"m\": 3,\n            \"mu_R\": 50000, \"sigma_R\": 5000, \"mu_V\": 100, \"sigma_V\": 10, \"rho\": 0.3,\n            \"gene_params\": [\n                (7.0, 0.0, 0.060, 2.5),\n                (4.0, 0.0, 0.050, 2.0),\n                (6.0, 0.0, 0.040, 2.5)\n            ]\n        },\n        {\n            \"id\": 3, \"seed\": 303, \"n\": 400, \"m\": 4,\n            \"mu_R\": 50000, \"sigma_R\": 6000, \"mu_V\": 100, \"sigma_V\": 12, \"rho\": 0.9,\n            \"gene_params\": [\n                (10.0, 0.00025, 0.050, 3.0),\n                (12.0, 0.00030, 0.040, 3.0),\n                (8.0, 0.00028, 0.060, 2.5),\n                (6.0, 0.00027, 0.030, 3.5)\n            ]\n        },\n        {\n            \"id\": 4, \"seed\": 404, \"n\": 30, \"m\": 5,\n            \"mu_R\": 50000, \"sigma_R\": 5000, \"mu_V\": 100, \"sigma_V\": 10, \"rho\": 0.5,\n            \"gene_params\": [\n                (5.0, 0.00010, 0.020, 8.0),\n                (7.0, 0.00005, 0.000, 10.0),\n                (9.0, 0.00000, 0.030, 9.0),\n                (4.0, 0.00008, 0.010, 7.0),\n                (6.0, 0.00002, 0.000, 8.0)\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = process_case(case)\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of each result list is joined by commas.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef fit_and_get_logL(Y, X, n, m):\n    \"\"\"\n    Fits a linear model for each gene and calculates the total log-likelihood.\n    \"\"\"\n    total_logL = 0\n    for j in range(m):\n        y_j = Y[:, j]\n        \n        # OLS fit using numpy.linalg.lstsq\n        # It returns coefficients and the residual sum of squares (RSS)\n        _, rss_j_array, _, _ = np.linalg.lstsq(X, y_j, rcond=None)\n        \n        # lstsq returns RSS in an array; handle empty array for perfect fits\n        rss_j = rss_j_array[0] if rss_j_array.size > 0 else 0.0\n\n        # MLE for variance (using n, not n-p)\n        sigma_j_sq_hat = rss_j / n\n        \n        # If variance is non-positive, log-likelihood is -inf.\n        # This shouldn't happen with noisy data.\n        if sigma_j_sq_hat = 0:\n            logL_j = -np.inf\n        else:\n            # Maximized log-likelihood for gene j\n            logL_j = -(n / 2.0) * (np.log(2 * np.pi) + np.log(sigma_j_sq_hat) + 1.0)\n        \n        total_logL += logL_j\n        \n    return total_logL\n\ndef process_case(case_params):\n    \"\"\"\n    Processes a single test case: generates data, fits models, and computes all metrics.\n    \"\"\"\n    n, m, seed = case_params[\"n\"], case_params[\"m\"], case_params[\"seed\"]\n    mu_R, sigma_R = case_params[\"mu_R\"], case_params[\"sigma_R\"]\n    mu_V, sigma_V = case_params[\"mu_V\"], case_params[\"sigma_V\"]\n    rho, gene_params = case_params[\"rho\"], case_params[\"gene_params\"]\n    \n    rng = np.random.default_rng(seed)\n\n    # 1. Generate Data\n    # Generate covariates R, V from a bivariate normal distribution\n    mean_vec = [mu_R, mu_V]\n    cov_matrix = [[sigma_R**2, rho * sigma_R * sigma_V],\n                  [rho * sigma_R * sigma_V, sigma_V**2]]\n    R_V_data = rng.multivariate_normal(mean_vec, cov_matrix, size=n)\n    R = R_V_data[:, 0]\n    V = R_V_data[:, 1]\n\n    # Generate expression data Y\n    Y = np.zeros((n, m))\n    for j in range(m):\n        alpha_j, gamma_R_j, gamma_V_j, sigma_j = gene_params[j]\n        epsilon_ij = rng.normal(0, sigma_j, size=n)\n        Y[:, j] = alpha_j + gamma_R_j * R + gamma_V_j * V + epsilon_ij\n\n    # 2. Fit Models and Calculate Log-Likelihoods\n    # Create design matrices\n    X_ones = np.ones((n, 1))\n    X_R = np.hstack([X_ones, R.reshape(-1, 1)])\n    X_V = np.hstack([X_ones, V.reshape(-1, 1)])\n    X_RV = np.hstack([X_ones, R.reshape(-1, 1), V.reshape(-1, 1)])\n\n    # Get total log-likelihoods for each model\n    logL_R = fit_and_get_logL(Y, X_R, n, m)\n    logL_V = fit_and_get_logL(Y, X_V, n, m)\n    logL_RV = fit_and_get_logL(Y, X_RV, n, m)\n\n    # 3. Calculate Information Criteria and LRTs\n    # Parameter counts\n    k_R = 3 * m\n    k_V = 3 * m\n    k_RV = 4 * m\n    \n    # Total sample size for criteria calculation\n    N_tot = n * m\n\n    # AIC values\n    AIC_R = 2 * k_R - 2 * logL_R\n    AIC_V = 2 * k_V - 2 * logL_V\n    AIC_RV = 2 * k_RV - 2 * logL_RV\n\n    # BIC values\n    BIC_R = k_R * np.log(N_tot) - 2 * logL_R\n    BIC_V = k_V * np.log(N_tot) - 2 * logL_V\n    BIC_RV = k_RV * np.log(N_tot) - 2 * logL_RV\n\n    # Likelihood Ratio Tests\n    df_lrt = m  # k_RV - k_R = 4*m - 3*m = m\n    \n    # LRT for RV vs R\n    lambda_RV_vs_R = 2 * (logL_RV - logL_R)\n    # The chi2.sf function handles lambda_stat  0 correctly, returning 1.0\n    p_RV_vs_R = chi2.sf(lambda_RV_vs_R, df=df_lrt)\n    \n    # LRT for RV vs V\n    lambda_RV_vs_V = 2 * (logL_RV - logL_V)\n    p_RV_vs_V = chi2.sf(lambda_RV_vs_V, df=df_lrt)\n\n    # 4. Model Selection based on BIC\n    min_bic = min(BIC_R, BIC_V, BIC_RV)\n    delta = 1e-8\n    \n    is_R_candidate = (BIC_R - min_bic) = delta\n    is_V_candidate = (BIC_V - min_bic) = delta\n    is_RV_candidate = (BIC_RV - min_bic) = delta\n    \n    model_code = -1 # Default/error value\n    # Apply preference hierarchy: R > V > RV\n    if is_R_candidate:\n        model_code = 0  # Prefer R model\n    elif is_V_candidate:\n        model_code = 1  # Then prefer V model\n    elif is_RV_candidate:\n        model_code = 2  # Finally, the RV model\n    \n    # Assemble the final list of results for this case\n    case_result = [\n        model_code,\n        logL_R, logL_V, logL_RV,\n        AIC_R, AIC_V, AIC_RV,\n        BIC_R, BIC_V, BIC_RV,\n        p_RV_vs_R, p_RV_vs_V\n    ]\n    \n    return case_result\n\nif __name__ == '__main__':\n    solve()\n```", "id": "4357124"}, {"introduction": "在高通量“组学”时代，我们常常可以同时测量成千上万种蛋白质或基因的表达水平。这为我们提供了一个机会，可以用数据驱动的方式来识别外在噪音的来源，而无需预先指定候选因素。本练习将介绍主成分分析（PCA）这一强大工具，用它来发现蛋白质组数据中共享变异的主要模式，这些模式对应着影响细胞状态的主要外在因素。[@problem_id:4357150]", "problem": "给定一个单细胞蛋白质组学的概念模型，该模型研究了许多细胞中许多蛋白质的情况。其中，每个细胞测得的蛋白质丰度受到两种变异性的影响：内在噪声（每个基因或蛋白质所特有，且在蛋白质之间不相关）和外在噪声（共同调节许多蛋白质的共享细胞因子）。本问题要求您基于加spike协方差模型和随机矩阵理论，形式化并实现一个程序，以使用主成分分析（PCA）来识别主要的外在轴，并量化它们对总方差的贡献。\n\n假设数据矩阵 $\\mathbf{X} \\in \\mathbb{R}^{N \\times P}$（其中 $N$ 是细胞数量，$P$ 是蛋白质数量）的生成模型如下：\n1. 内在变异性和测量变异性被建模为各向同性高斯噪声 $\\mathbf{Z} \\in \\mathbb{R}^{N \\times P}$，其元素独立且方差为1，即 $\\mathbf{Z}_{ij} \\sim \\mathcal{N}(0,1)$。\n2. 外在变异性被建模为低秩因子模型：$\\mathbf{F} \\in \\mathbb{R}^{N \\times r}$ 的元素独立且服从 $\\mathbf{F}_{ik} \\sim \\mathcal{N}(0,1)$，以及一个蛋白质载荷矩阵 $\\mathbf{L} \\in \\mathbb{R}^{P \\times r}$，使得 $\\mathbf{L} \\mathbf{L}^{\\top}$ 的秩为 $r$，非零特征值为 $\\{\\beta_1,\\ldots,\\beta_r\\}$（称为群体spike强度）。\n3. 观测数据按以下方式生成\n$$\n\\mathbf{X} \\;=\\; \\mathbf{Z} \\;+\\; \\mathbf{F}\\mathbf{L}^{\\top} \\,,\n$$\n然后对每种蛋白质进行中心化（即每种蛋白质在所有细胞中的均值为零）。在该模型下，蛋白质间的总体协方差为\n$$\n\\boldsymbol{\\Sigma} \\;=\\; \\mathbb{E}\\left[\\frac{1}{N}\\mathbf{X}^{\\top}\\mathbf{X}\\right] \\;=\\; \\mathbf{I}_P \\;+\\; \\mathbf{L}\\mathbf{L}^{\\top},\n$$\n因此，外在轴对应于各向同性基线 $1$ 之上的 $r$ 个spike $\\{1+\\beta_k\\}$ 相关联的特征向量。\n\n给定根据中心化数据计算出的样本协方差估计量\n$$\n\\mathbf{S} \\;=\\; \\frac{1}{N-1}\\,\\mathbf{X}^{\\top}\\mathbf{X} \\;\\in\\; \\mathbb{R}^{P \\times P},\n$$\n主成分分析（PCA）通过特征值 $\\lambda_1 \\ge \\lambda_2 \\ge \\cdots \\ge \\lambda_P \\ge 0$ 和标准正交特征向量对 $\\mathbf{S}$ 进行对角化。在没有外在因素（$r=0$）的情况下，随机矩阵理论（Marchenko–Pastur定律）预测，当 $N,P \\to \\infty$ 且纵横比 $c = P/(N-1)$ 保持固定时，$\\mathbf{S}$ 的特征值分布会集中在\n$$\n\\left[\\lambda_{-}, \\lambda_{+}\\right] \\;=\\; \\left[(1-\\sqrt{c})^2,\\,(1+\\sqrt{c})^2\\right].\n$$\n当存在spike时，与足够强的外在轴相关联的特征值会从随机体（random bulk）中分离出来，出现在其上方，表现为离群值。我们将操作性地定义主要的外在轴为那些样本特征值超过Marchenko–Pastur上界的主成分。\n$$\n\\lambda_{+} \\;=\\; (1+\\sqrt{c})^2 \\quad \\text{with} \\quad c \\;=\\; \\frac{P}{N-1}.\n$$\n\n您的任务是：\n1. 针对一小组参数设置，根据上述模型生成合成数据集。对于每个测试，使用固定的随机种子以确保可复现性。构造 $\\mathbf{L}$，使其具有标准正交列，并进行缩放以匹配所需的spike强度 $\\{\\beta_k\\}$，即，如果 $\\mathbf{Q} \\in \\mathbb{R}^{P \\times r}$ 具有标准正交列，则设置 $\\mathbf{L} = \\mathbf{Q}\\,\\mathrm{diag}(\\sqrt{\\beta_1},\\ldots,\\sqrt{\\beta_r})$，从而使 $\\mathbf{L}\\mathbf{L}^{\\top}$ 的非零特征值恰好为 $\\{\\beta_k\\}$。\n2. 对每种蛋白质（即每列）中心化 $\\mathbf{X}$（使其均值为零），计算 $\\mathbf{S} = \\frac{1}{N-1}\\mathbf{X}^{\\top}\\mathbf{X}$，并通过对 $\\mathbf{S}$ 进行特征分解来执行PCA。\n3. 将严格大于 $\\lambda_{+}$ 的特征值的数量确定为主要外在轴的数量 $\\hat{r}$。\n4. 对于每个检测到的外在轴 $j \\in \\{1,\\ldots,\\hat{r}\\}$，报告其分数以量化其对总方差的贡献。\n$$\nf_j \\;=\\; \\frac{\\lambda_j}{\\sum_{i=1}^{P}\\lambda_i},\n$$\n四舍五入到六位小数。\n\n测试组。对于每种情况，使用基础种子 $s_0 = 20231107$ 和单个案例种子 $s = s_0 + \\Delta$，其中 $\\Delta$ 在下面指定。对于所有情况，如上所述，将 $\\mathbf{Z}$ 和 $\\mathbf{F}$ 的方差设置为 $1$。Spike强度以列表 $\\{\\beta_k\\}$ 的形式给出（可能为空）。\n- 情况A（理想路径）：$N = 1000$, $P = 60$, spikes $\\{\\beta_1,\\beta_2\\} = \\{2.5,\\,1.6\\}$, $\\Delta = 0$。\n- 情况B（零边界）：$N = 800$, $P = 80$, spikes为空（即 $r=0$）, $\\Delta = 1$。\n- 情况C（$N$较小且接近$P$，一个强spike）：$N = 120$, $P = 100$, spikes $\\{\\beta_1,\\beta_2\\} = \\{5.0,\\,0.8\\}$, $\\Delta = 2$。\n- 情况D（多个spike，只有一个超过边界）：$N = 600$, $P = 50$, spikes $\\{\\beta_1,\\beta_2,\\beta_3\\} = \\{1.5,\\,0.4,\\,0.3\\}$, $\\Delta = 3$。\n\n最终输出格式要求。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试案例对应一个内部列表。对于每个测试案例，输出一个内部列表，其第一个元素是整数 $\\hat{r}$，后面跟着 $\\hat{r}$ 个浮点数，即 $f_1,\\ldots,f_{\\hat{r}}$，四舍五入到六位小数。例如，两个案例的输出可能如下所示\n$$\n[[2,0.123456,0.078901],[0]].\n$$\n请注意，本问题不涉及物理单位，也不涉及角度。所有浮点数在输出中必须四舍五入到六位小数。", "solution": "用户提供了一个有效的问题陈述。\n\n该问题在科学上植根于统计信号处理、随机矩阵理论（RMT）及其在系统生物学（特别是单细胞蛋白质组学）中的应用。它概述了一个使用加spike协方差模型来区分结构化外在变异性与非结构化内在噪声的程序。任务设定明确，具有清晰定义的生成模型、确定性的分析流程以及用于测试的特定、客观的参数集。所有术语都经过数学定义，问题本身是自洽的，没有矛盾或歧义。\n\n在此，我们遵循用户的正式要求，提供一个原则性的、分步的解决方案。\n\n### 方法论框架\n\n核心任务是在一个合成的单细胞蛋白质组学数据集中，识别并量化主要外在变异因素的贡献。该方法基于加spike协方差模型，并利用随机矩阵理论的结果来建立一个显著性阈值。整个过程分为四个主要阶段：数据生成、协方差估计与PCA、显著成分识别以及方差贡献量化。\n\n#### 1. 合成数据生成\n\n我们首先根据指定的生成模型，生成一个合成数据矩阵 $\\mathbf{X} \\in \\mathbb{R}^{N \\times P}$，其中 $N$ 是细胞数量，$P$ 是蛋白质数量：\n$$\n\\mathbf{X} \\;=\\; \\mathbf{Z} \\;+\\; \\mathbf{F}\\mathbf{L}^{\\top}\n$$\n- 项 $\\mathbf{Z} \\in \\mathbb{R}^{N \\times P}$ 代表内在噪声和测量误差。它被建模为一个由独立同分布的随机变量组成的矩阵，其中每个元素 $\\mathbf{Z}_{ij}$ 均从标准正态分布中抽取，即 $\\mathbf{Z}_{ij} \\sim \\mathcal{N}(0,1)$。\n- 项 $\\mathbf{F}\\mathbf{L}^{\\top}$ 代表由 $r$ 个共享细胞因子引起的外在变异性。\n  - $\\mathbf{F} \\in \\mathbb{R}^{N \\times r}$ 是因子得分矩阵，其元素 $\\mathbf{F}_{ik}$ 也从标准正态分布中抽取，即 $\\mathbf{F}_{ik} \\sim \\mathcal{N}(0,1)$。\n  - $\\mathbf{L} \\in \\mathbb{R}^{P \\times r}$ 是蛋白质载荷矩阵。它的构建是为了将一个特定的特征谱嵌入到总体协方差中。我们首先通过对一个随机的 $P \\times r$ 矩阵进行QR分解，生成一个具有标准正交列的矩阵 $\\mathbf{Q} \\in \\mathbb{R}^{P \\times r}$。然后，给定一组期望的群体spike强度 $\\{\\beta_1, \\ldots, \\beta_r\\}$，我们设置 $\\mathbf{L} = \\mathbf{Q} \\, \\mathrm{diag}(\\sqrt{\\beta_1}, \\ldots, \\sqrt{\\beta_r})$。这种构造确保了矩阵 $\\mathbf{L}\\mathbf{L}^{\\top} = \\mathbf{Q} \\, \\mathrm{diag}(\\beta_1, \\ldots, \\beta_r) \\, \\mathbf{Q}^{\\top}$ 的非零特征值恰好是所需的 $\\{\\beta_k\\}$。\n- 在没有外在因素的零假设情况下（$r=0$），`spikes` 列表为空，项 $\\mathbf{F}\\mathbf{L}^{\\top}$ 是一个零矩阵，因此 $\\mathbf{X} = \\mathbf{Z}$。\n- 为了可复现性，对于每个测试案例，伪随机数生成器都使用一个特定的值 $s = s_0 + \\Delta$ 进行播种，其中 $s_0 = 20231107$。\n\n#### 2. 协方差估计与主成分分析（PCA）\n\n原始数据矩阵 $\\mathbf{X}$ 首先按每种蛋白质（列）进行中心化，使其均值为零。设 $\\mathbf{X}_{\\text{c}}$ 为中心化矩阵，其中 $(\\mathbf{X}_{\\text{c}})_{ij} = \\mathbf{X}_{ij} - \\frac{1}{N}\\sum_{k=1}^{N} \\mathbf{X}_{kj}$。\n\n根据中心化数据，我们使用无偏估计量计算样本协方差矩阵 $\\mathbf{S} \\in \\mathbb{R}^{P \\times P}$：\n$$\n\\mathbf{S} \\;=\\; \\frac{1}{N-1}\\mathbf{X}_{\\text{c}}^{\\top}\\mathbf{X}_{\\text{c}}\n$$\n然后通过计算 $\\mathbf{S}$ 的特征分解来执行主成分分析。由于 $\\mathbf{S}$ 是一个实对称矩阵，它有 $P$ 个实数非负特征值，我们按降序表示为 $\\lambda_1 \\ge \\lambda_2 \\ge \\cdots \\ge \\lambda_P \\ge 0$。这些特征值代表了每个主成分所捕获的方差。\n\n#### 3. 主要外在轴的识别\n\n为了区分对应于真实外在因素的特征值和纯粹由随机噪声产生的特征值，我们采用随机矩阵理论的一个结果。Marchenko-Pastur（MP）定律描述了由纯随机数据构成的样本协方差矩阵特征值的极限分布。对于一个均值为零、方差为单位的独立同分布随机变量矩阵，在 $N, P \\to \\infty$ 且纵横比 $c = P/(N-1)$ 固定的极限下，$\\mathbf{S}$ 的特征值谱收敛于一个支撑在区间 $[\\lambda_{-}, \\lambda_{+}]$ 上的连续分布，其中：\n$$\n\\lambda_{-} = (1-\\sqrt{c})^2 \\quad \\text{and} \\quad \\lambda_{+} = (1+\\sqrt{c})^2\n$$\n值 $\\lambda_{+}$ 作为由噪声产生的特征值“主体”（bulk）的理论上界。任何严格位于此阈值之上的样本特征值 $\\lambda_j  \\lambda_{+}$，都被认为是对应于非随机、结构化变异源的“spike”——在我们的模型中，即一个主要的外在轴。我们计算这类特征值的数量，以确定检测到的主要轴的数量 $\\hat{r}$。\n\n#### 4. 方差贡献的量化\n\n对于 $\\hat{r}$ 个已识别的主要轴中的每一个，我们量化其对数据中观察到的总方差的贡献。总方差是所有特征值的总和，等于样本协方差矩阵的迹，即 $\\mathrm{Tr}(\\mathbf{S}) = \\sum_{i=1}^{P}\\lambda_i$。因此，第 $j$ 个主成分的贡献分数为：\n$$\nf_j \\;=\\; \\frac{\\lambda_j}{\\sum_{i=1}^{P}\\lambda_i}\n$$\n每个案例的最终结果包括整数计数 $\\hat{r}$，后跟 $\\hat{r}$ 个方差贡献分数 $\\{f_1, \\ldots, f_{\\hat{r}}\\}$，每个分数都四舍五入到六位小数。\n\n### 实现\n\n该程序使用 Python 实现，所有数值运算均使用 `numpy` 库。单个函数封装了每个测试案例的逻辑：它使用指定的参数和随机种子生成数据，计算中心化协方差矩阵，找到其特征值，应用 Marchenko-Pastur 阈值识别spike，并计算相应的方差分数。一个主脚本遍历所提供的测试组，调用此函数，并将收集到的结果格式化为指定的单个输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(N, P, spikes, seed):\n    \"\"\"\n    Processes a single test case according to the problem description.\n\n    Args:\n        N (int): Number of cells.\n        P (int): Number of proteins.\n        spikes (list of float): List of population spike strengths {beta_k}.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        list: A list containing the number of detected extrinsic axes (r_hat)\n              followed by the fractional variance contributions of each axis.\n    \"\"\"\n    # 1. Generate synthetic data\n    rng = np.random.default_rng(seed)\n\n    # Generate intrinsic noise matrix Z\n    Z = rng.standard_normal((N, P))\n\n    # Generate extrinsic variability part if spikes exist\n    r = len(spikes)\n    if r > 0:\n        # Generate factor scores F\n        F = rng.standard_normal((N, r))\n        \n        # Generate protein loading matrix L\n        # First, create a matrix Q with orthonormal columns\n        temp_matrix = rng.standard_normal((P, r))\n        Q, _ = np.linalg.qr(temp_matrix)\n        \n        # Then, construct L\n        sqrt_betas = np.diag(np.sqrt(spikes))\n        L = Q @ sqrt_betas\n        \n        # Combine to form the data matrix X\n        X = Z + F @ L.T\n    else:\n        # If no spikes, X is just the noise matrix\n        X = Z\n\n    # 2. Center data and compute sample covariance S\n    X_centered = X - X.mean(axis=0)\n    S = (X_centered.T @ X_centered) / (N - 1)\n\n    # 3. Perform PCA by eigendecomposition of S\n    # eigvalsh is used for symmetric matrices; it's efficient and guarantees real eigenvalues.\n    eigenvalues = np.linalg.eigvalsh(S)\n    # Sort eigenvalues in descending order\n    eigenvalues = np.sort(eigenvalues)[::-1]\n\n    # 4. Identify dominant extrinsic axes using the Marchenko-Pastur threshold\n    c = P / (N - 1)\n    lambda_plus = (1 + np.sqrt(c))**2\n    \n    # Count eigenvalues strictly greater than the threshold\n    r_hat = np.sum(eigenvalues > lambda_plus)\n\n    # 5. Quantify variance contribution\n    if r_hat > 0:\n        total_variance = np.sum(eigenvalues)\n        dominant_eigenvalues = eigenvalues[:r_hat]\n        variance_fractions = dominant_eigenvalues / total_variance\n        \n        # Round to six decimal places\n        rounded_fractions = np.round(variance_fractions, 6).tolist()\n        \n        result = [r_hat] + rounded_fractions\n    else:\n        result = [0]\n        \n    return result\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    s0 = 20231107\n    test_cases = [\n        # Case A: N=1000, P=60, spikes={2.5, 1.6}, delta=0\n        {'N': 1000, 'P': 60, 'spikes': [2.5, 1.6], 'seed': s0 + 0},\n        # Case B: N=800, P=80, spikes={}, delta=1\n        {'N': 800, 'P': 80, 'spikes': [], 'seed': s0 + 1},\n        # Case C: N=120, P=100, spikes={5.0, 0.8}, delta=2\n        {'N': 120, 'P': 100, 'spikes': [5.0, 0.8], 'seed': s0 + 2},\n        # Case D: N=600, P=50, spikes={1.5, 0.4, 0.3}, delta=3\n        {'N': 600, 'P': 50, 'spikes': [1.5, 0.4, 0.3], 'seed': s0 + 3},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_result = process_case(case['N'], case['P'], case['spikes'], case['seed'])\n        all_results.append(case_result)\n\n    # Format the final output string exactly as required\n    formatted_cases = []\n    for res in all_results:\n        # Convert each element in the inner list to a string\n        stringified_elements = [str(x) for x in res]\n        # Join them with commas and wrap in brackets\n        formatted_cases.append(f\"[{','.join(stringified_elements)}]\")\n    \n    # Join all formatted cases with commas and wrap in outer brackets\n    final_output = f\"[{','.join(formatted_cases)}]\"\n    \n    print(final_output)\n\nsolve()\n\n```", "id": "4357150"}]}