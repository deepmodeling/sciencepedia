{"hands_on_practices": [{"introduction": "细胞信号通路中的开关式响应，即超敏性，其根源往往在于分子层面的协同相互作用。本练习旨在引导您通过第一性原理进行推导，揭示转录因子的二聚化及其与启动子上多个位点的协同结合，如何共同催生出一种高度非线性的响应曲线。通过亲手计算有效希尔系数（Hill coefficient），您将深刻理解分子细节如何转化为宏观的系统功能，这是连接分子生物学与定量模型的基石 [@problem_id:4321507]。", "problem": "哺乳动物细胞中的一个转录因子会进行同源二聚化，并且只有当启动子上的两个相同算子位点都被一个二聚体占据时，才会激活转录。假设所有结合反应都处于快速平衡状态，并且与转录因子库相比，启动子的丰度可以忽略不计（因此启动子的占据不会扰动整体浓度）。设游离单体浓度为 $x$，二聚体浓度为 $d$。二聚化由质量作用平衡 $2X \\rightleftharpoons X_{2}$ 描述，其解离常数为 $K_{d}$，定义为 $K_{d} = \\frac{[X]^{2}}{[X_{2}]}$。每个算子位点通过 $X_{2} + S \\rightleftharpoons X_{2}S$ 结合二聚体，其解离常数为 $K_{b}$，定义为 $K_{b} = \\frac{[X_{2}][S]}{[X_{2}S]}$。只有当两个算子位点都被占据时，启动子才具有转录活性；假设这些位点的结合是独立且相同的。\n\n使用这些定义和平衡时的质量作用原理：\n- 推导启动子活性分数 $y(x)$ 作为游离单体浓度 $x$ 的函数，其中 $y(x)$ 定义为两个位点都被二聚体占据的概率。\n- 将局部 Hill 系数 $n_{H}$ 定义为激活的对数几率相对于输入 $x$ 的对数灵敏度，具体为 $n_{H}(x) = \\frac{d}{d\\ln x}\\ln\\!\\left(\\frac{y(x)}{1-y(x)}\\right)$，并确定在半激活状态 $y=\\frac{1}{2}$ 时 $n_{H}$ 的值。\n\n以单一闭式解析表达式的形式给出半激活状态下 $n_{H}$ 的最终答案。无需进行数值四舍五入。该量是无量纲的。", "solution": "该问题要求针对一个给定的基因调控模型，推导启动子活性分数 $y(x)$ 并计算半激活状态下的局部 Hill 系数 $n_{H}$。求解过程分为两个主要部分。\n\n首先，我们推导启动子活性分数 $y(x)$ 的表达式。该系统涉及一个游离浓度为 $x$ 的单体转录因子 $X$，它形成一个浓度为 $d$ 的同源二聚体 $X_2$。二聚化平衡由以下公式给出：\n$$K_{d} = \\frac{[X]^{2}}{[X_{2}]} = \\frac{x^{2}}{d}$$\n根据这个关系，我们可以将二聚体浓度 $d$ 表示为游离单体浓度 $x$ 的函数：\n$$d(x) = \\frac{x^{2}}{K_{d}}$$\n\n二聚体 $X_2$ 与启动子上的两个相同且独立的算子位点 $S$ 结合。结合平衡由解离常数 $K_{b}$ 描述：\n$$K_{b} = \\frac{[X_{2}][S]}{[X_{2}S]} = \\frac{d [S]}{[X_{2}S]}$$\n单个算子位点被二聚体占据的概率 $p$ 由被占据位点的分数给出：\n$$p = \\frac{[X_{2}S]}{[S] + [X_{2}S]}$$\n通过将 $K_b$ 的定义重新排列为 $[S] = K_b \\frac{[X_{2}S]}{d}$ 并将其代入 $p$ 的表达式中，我们得到：\n$$p = \\frac{[X_{2}S]}{K_b \\frac{[X_{2}S]}{d} + [X_{2}S]} = \\frac{1}{\\frac{K_{b}}{d} + 1} = \\frac{d}{d + K_{b}}$$\n现在，我们将 $d(x)$ 的表达式代入 $p$ 的方程中，以将单位点占据概率表示为 $x$ 的函数：\n$$p(x) = \\frac{\\frac{x^{2}}{K_{d}}}{\\frac{x^{2}}{K_{d}} + K_{b}} = \\frac{x^{2}}{x^{2} + K_{d}K_{b}}$$\n问题陈述，只有当两个算子位点都被占据时，启动子才具有转录活性。由于这些位点是相同且独立结合的，两者都被占据的概率 $y(x)$ 是单位点占据概率 $p(x)$ 的平方：\n$$y(x) = [p(x)]^{2} = \\left(\\frac{x^{2}}{x^{2} + K_{d}K_{b}}\\right)^{2}$$\n这就是所求的启动子活性分数作为游离单体浓度 $x$ 的函数表达式。\n\n接下来，我们确定半激活状态下的局部 Hill 系数 $n_{H}$。局部 Hill 系数定义为：\n$$n_{H}(x) = \\frac{d}{d\\ln x}\\ln\\!\\left(\\frac{y(x)}{1-y(x)}\\right)$$\n让我们首先用 $p = p(x)$ 来表示对数的参数，即激活几率 $\\frac{y}{1-y}$。\n$$\\frac{y}{1-y} = \\frac{p^{2}}{1-p^{2}}$$\n几率的对数为：\n$$\\ln\\left(\\frac{y}{1-y}\\right) = \\ln\\left(\\frac{p^{2}}{1-p^{2}}\\right) = \\ln(p^{2}) - \\ln(1-p^{2}) = 2\\ln(p) - \\ln(1-p^2)$$\n为了计算 $n_H$，我们使用链式法则：$n_{H} = \\frac{d}{d\\ln x} \\ln\\left(\\frac{y}{1-y}\\right) = \\frac{d\\ln(p)}{d\\ln x} \\frac{d}{d\\ln p} \\left( 2\\ln p - \\ln(1-p^2) \\right)$。\n一个更直接的方法是将 $n_H$ 表示为 $p$ 的函数：$n_H = \\frac{d\\ln(\\frac{p^2}{1-p^2})}{d\\ln p} \\cdot \\frac{d\\ln p}{d\\ln x}$。让我们分别求解每一部分。\n首先，我们求单位点占据率 $p$ 对输入 $x$ 的灵敏度。设 $K_{eff} = K_d K_b$。\n$p = \\frac{x^{2}}{x^{2} + K_{eff}}$。取自然对数：$\\ln p = 2\\ln x - \\ln(x^{2} + K_{eff})$。\n对 $\\ln x$ 求导：\n$$\\frac{d\\ln p}{d\\ln x} = \\frac{d(2\\ln x)}{d\\ln x} - \\frac{d\\ln(x^{2} + K_{eff})}{d\\ln x} = 2 - x \\frac{d\\ln(x^{2} + K_{eff})}{dx} = 2 - x \\frac{2x}{x^{2}+K_{eff}}$$\n$$\\frac{d\\ln p}{d\\ln x} = 2 - \\frac{2x^{2}}{x^{2} + K_{eff}} = 2 - 2p = 2(1-p)$$\n现在，我们通过对对数几率关于 $\\ln x$ 求导来计算 $n_H$：\n$$n_{H} = \\frac{d}{d\\ln x} \\left(2\\ln p - \\ln(1-p^{2})\\right) = 2\\frac{d\\ln p}{d\\ln x} - \\frac{d\\ln(1-p^{2})}{d\\ln x}$$\n对第二项使用链式法则：$\\frac{d\\ln(1-p^{2})}{d\\ln x} = \\frac{d\\ln(1-p^{2})}{d\\ln p} \\frac{d\\ln p}{d\\ln x}$。\n$$\\frac{d\\ln(1-p^{2})}{d\\ln p} = p \\frac{d\\ln(1-p^2)}{dp} = p \\frac{-2p}{1-p^2} = \\frac{-2p^2}{1-p^2}$$\n将此代回：\n$$n_{H} = 2\\frac{d\\ln p}{d\\ln x} - \\left(\\frac{-2p^{2}}{1-p^{2}}\\right)\\frac{d\\ln p}{d\\ln x} = \\frac{d\\ln p}{d\\ln x} \\left(2 + \\frac{2p^{2}}{1-p^{2}}\\right)$$\n代入 $\\frac{d\\ln p}{d\\ln x} = 2(1-p)$：\n$$n_{H} = 2(1-p)\\left(\\frac{2(1-p^{2}) + 2p^{2}}{1-p^{2}}\\right) = 2(1-p)\\left(\\frac{2}{1-p^{2}}\\right) = 2(1-p)\\frac{2}{(1-p)(1+p)} = \\frac{4}{1+p}$$\n这给出了 $n_H$ 作为一个关于单位点占据概率 $p$ 的函数的简化表达式。\n\n最后一步是在半激活条件下计算 $n_{H}$ 的值，即条件 $y(x) = \\frac{1}{2}$。\n$$y = p^{2} = \\frac{1}{2} \\implies p = \\frac{1}{\\sqrt{2}}$$\n将这个 $p$ 的值代入我们的 $n_H$ 表达式中：\n$$n_{H}\\bigg|_{y=1/2} = \\frac{4}{1+p} = \\frac{4}{1+\\frac{1}{\\sqrt{2}}}$$\n为了简化，我们将分子和分母同乘以 $\\sqrt{2}$：\n$$n_{H} = \\frac{4\\sqrt{2}}{\\sqrt{2}+1}$$\n为了使分母有理化，我们将分子和分母同乘以其共轭式 $(\\sqrt{2}-1)$：\n$$n_{H} = \\frac{4\\sqrt{2}(\\sqrt{2}-1)}{(\\sqrt{2}+1)(\\sqrt{2}-1)} = \\frac{4(2-\\sqrt{2})}{2-1} = 4(2-\\sqrt{2})$$\n$$n_{H} = 8 - 4\\sqrt{2}$$\n这就是半激活状态下局部 Hill 系数的最终闭式解析表达式。", "answer": "$$\n\\boxed{8 - 4\\sqrt{2}}\n$$", "id": "4321507"}, {"introduction": "双稳态不仅是一个定性的概念，它在动力系统的理论中有着精确的数学定义，其核心是鞍结分岔（saddle-node bifurcation）。本练习将带您深入这一理论核心，通过编程来精确定位导致系统进入或退出双稳态区域的参数阈值 [@problem_id:4321508]。通过这个过程，您将对定义生物开关的数学结构获得深入的、定量的理解，并体会到理论分析在预测复杂生物行为中的威力。", "problem": "考虑一个最小正反馈调控回路，其模型为一个常微分方程 (ODE)。其中，一个无量纲分子活性变量 $x$ 根据质量平衡原理 $dx/dt = \\text{production}(x,u) - \\text{degradation}(x)$ 演化，并带有一个外部无量纲输入 $u$。设其生成过程由一个 Hill 型 S 状激活函数建模，其协同性（Hill 系数）为 $n$，增益为 $\\alpha$；降解过程为线性。具体来说，动力学由以下方程定义：\n$$\n\\frac{dx}{dt} = u + \\alpha \\,\\frac{x^n}{1 + x^n} - x,\n$$\n其中 $x \\ge 0$，$u \\ge 0$，$n \\ge 1$ 和 $\\alpha > 0$ 均为无量纲参数。稳态满足 $dx/dt = 0$，即：\n$$\nf(x;u,\\alpha,n) = u + \\alpha \\,\\frac{x^n}{1 + x^n} - x = 0.\n$$\n当一对稳态碰撞并湮灭时，会在特定的参数值处发生鞍结（折叠）分岔，其条件由 $f(x;u,\\alpha,n) = 0$ 和 $\\partial f/\\partial x = 0$ 且 $\\partial^2 f/\\partial x^2 \\ne 0$ 决定。在该系统中，稳态轨迹可以参数化为：\n$$\nu(x;\\alpha,n) = x - \\alpha \\,\\frac{x^n}{1 + x^n},\n$$\n折叠点 $(x^\\ast,u^\\ast)$ 出现在 $u(x)$ 相对于 $x$ 的转折点处，满足：\n$$\n\\frac{d u}{d x} = 1 - \\alpha \\,\\frac{d}{dx}\\left(\\frac{x^n}{1 + x^n}\\right) = 0.\n$$\n当 $\\frac{d u}{d x} = 0$ 存在两个不同的正解 $x_{\\text{low}}$ 和 $x_{\\text{high}}$ 时，系统存在迟滯现象：当 $u$ 从一个低基线增加时，低表达稳定稳态在上限折叠点 $u_{\\text{on}} = u(x_{\\text{high}})$ 处消失；而当 $u$ 从一个高基线减少时，高表达稳定稳态在下限折叠点 $u_{\\text{off}} = u(x_{\\text{low}})$ 处消失。如果 $\\frac{d u}{d x} = 0$ 没有正解，则系统是单稳态的，不发生迟滯。在边界情况下，Hill 函数的最大斜率恰好满足折叠条件，此时 $\\frac{d u}{d x}$ 在一个非负点处与零相切，产生一个退化（二重）根，且有 $u_{\\text{off}} = u_{\\text{on}}$。\n\n仅根据这些定义和原理，编写一个完整的程序，为每个指定的参数集 $(n,\\alpha)$：\n- 判断 $\\frac{d u}{d x} = 0$ 是否存在两个不同的正解（迟滞情况）、一个非负解（退化边界情况），或无解（单稳态情况）。\n- 通过在折叠点处计算 $u(x)$ 的值，以实数形式计算相应的阈值 $u_{\\text{off}}$ 和 $u_{\\text{on}}$。在退化边界情况下，两个阈值均等于该唯一折叠点处的值。\n- 如果不存在折叠点，则返回一个空列表。\n\n您的实现必须仅使用数学上合理的步骤，不得使用任何假设解的最终形式的启发式方法。请使用稳健的数值方法在 $x>0$ 上定位根，并且对于导数仅与零相切而无符号变化的边界情况，通过定位 Hill 函数斜率的最大值点并确认其退化性来识别退化折叠点。\n\n您必须处理以下参数值的测试套件：\n- 情况 A（预期出现迟滯）：$(n,\\alpha) = (\\,4.0,\\,1.0\\,)$。\n- 情况 B（单稳态）：$(n,\\alpha) = (\\,4.0,\\,0.8\\,)$。\n- 情况 C（退化边界）：$(n,\\alpha) = (\\,4.0,\\,\\alpha_c\\,)$，其中 $\\alpha_c$ 定义为在给定 $n$ 的情况下，首次可能出现折叠条件的临界增益；具体而言，$\\alpha_c$ 等于 $\\frac{d}{dx}\\left(\\frac{x^n}{1 + x^n}\\right)$ 在 $x \\ge 0$ 上的最大值的倒数。\n\n所有量均为无量纲。对于每种情况，如果不存在折叠点，程序应返回一个空列表；如果存在折叠点，则返回一个包含两个阈值 $[u_{\\text{off}},u_{\\text{on}}]$ 的列表（按此顺序）。在退化边界情况下，返回 $[u^\\ast,u^\\ast]$，其中 $u^\\ast = u(x^\\ast)$ 是在唯一折叠点处的值。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有三种情况的结果，形式为一个逗号分隔的列表，并用方括号括起来。每个项目都应是对应于该情况的列表。例如，一个有效的输出可能如下所示：\n$$\n[ [u_{\\text{off},A},u_{\\text{on},A}], [], [u^\\ast,u^\\ast] ].\n$$\n您的程序必须确保任何内部列表中都没有空格，并且不打印任何附加文本。输出必须是严格符合以下格式的单行：\n$$\n[[r_{A,1},r_{A,2}],[],[r_{C,1},r_{C,2}]],\n$$\n其中每个 $r_{\\cdot,\\cdot}$ 都是一个实数。", "solution": "用户希望分析一个简单的正反馈调控回路模型，并确定双稳态和迟滯现象的条件。\n\n系统状态变量 $x$ 的演化由以下常微分方程 (ODE) 描述：\n$$\n\\frac{dx}{dt} = u + \\alpha \\,\\frac{x^n}{1 + x^n} - x\n$$\n其中 $u$ 是输入信号，$\\alpha$ 是反馈增益， $n$ 是代表反馈协同性的 Hill 系数。所有变量和参数（$x$、$u$、$n$、$\\alpha$）均为非负，且 $n \\ge 1$，$ \\alpha > 0$。\n\n系统的稳态是指浓度 $x$ 不随时间变化的点，即 $\\frac{dx}{dt} = 0$。该条件定义了输入 $u$ 和稳态活性 $x$ 之间的关系：\n$$\n0 = u + \\alpha \\,\\frac{x^n}{1 + x^n} - x\n$$\n整理该方程可得出稳態轨迹是 $x$ 的函数：\n$$\nu(x;\\alpha,n) = x - \\alpha \\,\\frac{x^n}{1 + x^n}\n$$\n系统可以表现出双稳态，意味着在一定范围的输入 $u$ 内，可能存在多个稳定的稳态。单稳态和双稳态体系之间的转换发生在鞍结（或折叠）分岔处。这些分岔对应于函数 $u(x)$ 的局部最小值和最大值，即稳态曲线的转折点。在数学上，这些点（表示为 $x^\\ast$）可以通过将 $u(x)$ 对 $x$ 的导数设为零来找到：\n$$\n\\frac{du}{dx} = 0\n$$\n我们来计算这个导数：\n$$\n\\frac{du}{dx} = \\frac{d}{dx}\\left(x - \\alpha \\,\\frac{x^n}{1 + x^n}\\right) = 1 - \\alpha \\,\\frac{d}{dx}\\left(\\frac{x^n}{1 + x^n}\\right)\n$$\n对 Hill 函数项使用微分的商法则，我们得到：\n$$\n\\frac{d}{dx}\\left(\\frac{x^n}{1 + x^n}\\right) = \\frac{(nx^{n-1})(1+x^n) - (x^n)(nx^{n-1})}{(1+x^n)^2} = \\frac{nx^{n-1}}{(1+x^n)^2}\n$$\n将此代回折叠点的条件，得到：\n$$\n1 - \\alpha \\,\\frac{nx^{n-1}}{(1+x^n)^2} = 0\n$$\n该方程可以重新整理以定义折叠点处的 $x$ 值：\n$$\n\\frac{nx^{n-1}}{(1+x^n)^2} = \\frac{1}{\\alpha}\n$$\n我们定义函数 $g(x;n) = \\frac{nx^{n-1}}{(1+x^n)^2}$，它代表动力学中激活 Hill 函数部分的斜率。折叠点的存在性和数量取决于方程 $g(x;n) = 1/\\alpha$ 的正解的数量。\n\n为了分析解的数量，我们必须研究 $g(x;n)$ 在 $x > 0$ 时的形状。对于 $n>1$，$g(0) = 0$，并且当 $x \\to \\infty$ 时，$g(x;n) \\sim \\frac{nx^{n-1}}{x^{2n}} = \\frac{n}{x^{n+1}} \\to 0$。由于 $g(x;n)$ 是非负的，它在 $x > 0$ 时必须至少有一个最大值。为了找到这个最大值，我们求解 $g'(x;n) = 0$。导数在点 $x_{max}$ 处为零，其中：\n$$\nx_{max}^n = \\frac{n-1}{n+1} \\quad \\implies \\quad x_{max} = \\left(\\frac{n-1}{n+1}\\right)^{1/n}\n$$\n只要 $n > 1$，这就给出了 $x_{max}$ 的唯一正实数解。函数的最大值是 $g_{max}(n) = g(x_{max};n)$。\n\n问题将临界增益 $\\alpha_c$ 定义为 Hill 函数斜率最大值的倒数。这恰好对应于：\n$$\n\\alpha_c(n) = \\frac{1}{g_{max}(n)}\n$$\n方程 $g(x;n) = 1/\\alpha$ 的正解数量取决于 $\\alpha$ 和 $\\alpha_c(n)$ 之间的比较：\n1.  **单稳态情况 ($\\alpha  \\alpha_c(n)$):** 在这种情况下，$1/\\alpha > 1/\\alpha_c(n) = g_{max}(n)$。水平线 $y=1/\\alpha$ 位于 $g(x;n)$ 最大值的上方，因此对于 $x$ 没有正解。系统对于所有输入 $u$ 都是单稳态的。\n2.  **退化边界情况 ($\\alpha = \\alpha_c(n)$):** 此时，$1/\\alpha = g_{max}(n)$。在 $x^\\ast = x_{max}$ 处存在一个唯一的正解，它是一个退化（二重）根。这对应于双稳态的起始点。存在一个单一的折叠点，并且开启/关闭阈值重合：$u_{\\text{on}} = u_{\\text{off}} = u(x^\\ast; \\alpha_c, n)$。\n3.  **迟滞情况 ($\\alpha > \\alpha_c(n)$):** 此时，$1/\\alpha  g_{max}(n)$。直线 $y=1/\\alpha$ 与曲线 $g(x;n)$ 在两个不同的正点 $x_{\\text{low}}$ 和 $x_{\\text{high}}$ 相交，其中 $0  x_{\\text{low}}  x_{max}  x_{\\text{high}}$。这些点分别对应于 $u(x)$ 的一个局部最小值和一个局部最大值。系统是双稳态的。阈值分别为 $u_{\\text{off}} = u(x_{\\text{low}}; \\alpha, n)$ 和 $u_{\\text{on}} = u(x_{\\text{high}}; \\alpha, n)$。\n\n每个测试用例 $(n, \\alpha)$ 的算法步骤如下：\n\n首先，我们计算给定 $n$ 的临界增益 $\\alpha_c$。对于测试用例，$n=4.0$。\n1.  计算最大斜率的位置：$x_{max} = \\left(\\frac{4-1}{4+1}\\right)^{1/4} = (0.6)^{1/4}$。\n2.  评估最大斜率：$g_{max}(4) = g(x_{max}; 4) = \\frac{4x_{max}^3}{(1+x_{max}^4)^2}$。\n3.  计算临界增益：$\\alpha_c(4) = 1/g_{max}(4)$。\n\n接下来，我们分析每种情况：\n\n- **情况 A：$(n,\\alpha) = (4.0, 1.0)$**\n  由于 $1.0 > \\alpha_c(4)$，这是迟滞情况。我们必须找到 $g(x; 4) = 1/1.0 = 1$ 的两个正根。求根方程为 $h(x) = \\frac{4x^3}{(1+x^4)^2} - 1 = 0$。我们将通过在区间 $(0, x_{max})$ 和 $(x_{max}, \\infty)$ 中搜索，数值求解出两个根 $x_{\\text{low}}$ 和 $x_{\\text{high}}$。然后，我们计算阈值 $u_{\\text{off}} = u(x_{\\text{low}})$ 和 $u_{\\text{on}} = u(x_{\\text{high}})$。\n\n- **情况 B：$(n,\\alpha) = (4.0, 0.8)$**\n  由于 $0.8  \\alpha_c(4)$，这是单稳态情况。折叠点方程没有正根。结果是一个空列表。\n\n- **情况 C：$(n,\\alpha) = (4.0, \\alpha_c(4))$**\n  根据定义，这是退化边界情况。唯一的折叠点是 $x^\\ast = x_{max} = (0.6)^{1/4}$。相应的阈值是 $u^\\ast = u(x^\\ast; \\alpha_c(4), 4)$。结果是 $[u^\\ast, u^\\ast]$。\n\n该实现将使用 `numpy` 进行数值计算，并使用 `scipy.optimize.root_scalar` 来稳健地找到折叠点方程的根。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves for the bistability thresholds for a positive-feedback regulatory circuit.\n    \"\"\"\n\n    def g(x, n):\n        \"\"\"\n        Calculates the slope of the Hill function term, g(x) = n*x^(n-1) / (1 + x^n)^2.\n        For x=0, if n  1, g(0)=0. If n=1, g(0)=1.\n        We only consider x  0 for root finding.\n        \"\"\"\n        if np.any(x = 0):\n            # Handle arrays, returning 0 for any non-positive x\n            # This is safe for n  1 as assumed by the problem context\n            # and avoids division by zero or negative base to fractional power.\n            is_scalar = np.isscalar(x)\n            x = np.atleast_1d(x)\n            result = np.zeros_like(x, dtype=float)\n            positive_x = x > 0\n            # Guard against potential numerical issues near zero if n is close to 1\n            if np.any(positive_x):\n                x_pos = x[positive_x]\n                result[positive_x] = (n * x_pos**(n - 1)) / (1 + x_pos**n)**2\n            return result if not is_scalar else result.item()\n        return (n * x**(n - 1)) / (1 + x**n)**2\n\n    def u(x, n, alpha):\n        \"\"\"\n        Calculates the steady-state input u for a given state x.\n        u(x) = x - alpha * x^n / (1 + x^n)\n        \"\"\"\n        return x - alpha * (x**n) / (1 + x**n)\n\n    def process_case(n, alpha):\n        \"\"\"\n        Determines the stability regime and computes thresholds for a given (n, alpha).\n        \"\"\"\n        if n = 1:\n          # The analysis of g(x)'s maximum is based on n  1.\n          # For n=1, g(x) is monotonic, having at most one positive root.\n          # The problem's test cases all use n=4.0, so this path is not taken.\n          # Assuming monostability for n=1 as per problem framing.\n          return []\n\n        # Find the x-value where the slope g(x) is maximum\n        x_max = ((n - 1) / (n + 1))**(1 / n)\n        \n        # Calculate the maximum value of the slope\n        g_max = g(x_max, n)\n        \n        # Critical alpha is the reciprocal of the max slope\n        alpha_c = 1.0 / g_max\n\n        # Using a tolerance for floating-point comparison\n        tol = 1e-9\n\n        # Case 1: Monostable (alpha is too small)\n        if alpha  alpha_c - tol:\n            return []\n            \n        # Case 2: Degenerate boundary (alpha is at the critical value)\n        elif abs(alpha - alpha_c) = tol:\n            x_star = x_max\n            u_star = u(x_star, n, alpha)\n            return [u_star, u_star]\n        \n        # Case 3: Hysteresis (alpha is large enough)\n        else: # alpha > alpha_c + tol\n            # Define the function whose roots we need to find: h(x) = g(x) - 1/alpha\n            h = lambda x: g(x, n) - 1.0 / alpha\n\n            # Find the lower root (x_low) in the interval (0, x_max)\n            # Use a small positive number to avoid x=0\n            res_low = root_scalar(h, bracket=(1e-9, x_max), method='brentq')\n            x_low = res_low.root\n\n            # Find the upper root (x_high) in the interval (x_max, infinity)\n            # We use a reasonably large number as the upper bracket.\n            # Value of 100.0 is more than sufficient for typical parameters.\n            res_high = root_scalar(h, bracket=(x_max, 100.0), method='brentq')\n            x_high = res_high.root\n\n            # Calculate the thresholds u_off and u_on\n            u_off = u(x_low, n, alpha)\n            u_on = u(x_high, n, alpha)\n\n            return [u_off, u_on]\n    \n    # Calculate alpha_c for n=4.0\n    n_val = 4.0\n    x_max_val = ((n_val - 1) / (n_val + 1))**(1 / n_val)\n    g_max_val = g(x_max_val, n_val)\n    alpha_c_val = 1.0 / g_max_val\n    \n    # Define the test cases from the problem statement\n    test_cases = [\n        (4.0, 1.0),      # Case A (hysteresis)\n        (4.0, 0.8),      # Case B (monostable)\n        (4.0, alpha_c_val) # Case C (degenerate boundary)\n    ]\n\n    results_str_list = []\n    for n_case, alpha_case in test_cases:\n        result = process_case(n_case, alpha_case)\n        if not result: # Empty list\n            results_str_list.append(\"[]\")\n        else:\n            # Format numbers to avoid excessive precision in output, as is common practice.\n            # Using standard float representation is fine.\n            results_str_list.append(f\"[{result[0]},{result[1]}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str_list)}]\")\n\n\nsolve()\n```", "id": "4321508"}, {"introduction": "虽然理论模型为我们提供了预测，但系统生物学的一个关键任务是从实验数据中推断潜在的调控网络行为。本练习模拟了这一挑战，要求您开发一个算法，通过寻找双稳态独有的“指纹”——迟滞现象（hysteresis），来区分陡峭的超敏响应和真正的双稳态响应 [@problem_id:4321510]。这项实践将帮助您搭建起从理论模型到实际数据分析的重要桥梁，这在解读现代高通量生物学数据时至关重要。", "problem": "您的任务是使用源于质量作用动力学和 Hill 型调控模型的合成稳态数据，通过编程区分超敏性（具有陡峭但连续的剂量-反应曲线的单一稳态）和双稳态（由于正反馈和迟滞现象，在相同输入下存在两个不同稳态）。其基本原理是一维常微分方程 (ODE) 的稳态条件：对于由输入 $x$ 驱动的状态变量 $y$，其稳态满足 $\\frac{dy}{dt} = 0$。对于超敏单稳态回路，其稳态输入-输出关系可以通过 Hill 函数 $H(x; n, K) = \\frac{x^n}{K^n + x^n}$ 来描述，该函数源于准平衡结合和饱和假设。对于双稳态正反馈回路，当有效的自激活产生 S 形静态输入-输出关系时，对于相同的 $x$ 值可以出现多个稳态。在一个形式为 $\\frac{dy}{dt} = -y + G(y; x)$ 的一维常微分方程中，稳态 $y^\\star$ 满足 $y^\\star = G(y^\\star; x)$，其稳定性取决于导数 $\\frac{\\partial}{\\partial y}(-y + G(y; x))$ 在 $y^\\star$ 处的符号。\n\n您必须实现以下数学模型来生成稳态数据：\n\n1) 超敏单稳态数据生成器：\n- 为任意非负的 $z$ 定义 Hill 激活函数 $H(z; n, K) = \\frac{z^n}{K^n + z^n}$。\n- 稳态输出为 $y(x) = H(x; n, K)$，取值范围在闭区间 $[0, 1]$ 内。\n- 包含可选的加性测量噪声 $\\eta$，表示为 $y_{\\mathrm{meas}}(x) = \\mathrm{clip}(y(x) + \\eta, 0, 1)$，其中 $\\eta$ 是一个具有指定标准差的零均值高斯随机变量，并为了保持生物物理真实性，在 $0$ 和 $1$ 处设置了裁剪边界。\n\n2) 双稳态正反馈数据生成器：\n- 考虑一维常微分方程 $\\frac{dy}{dt} = -y + \\left((1 - d)\\,H(x; n_x, K_x) + d\\,H(y; m, K_y)\\right)$，其中 $d \\in (0, 1)$ 是反馈权重，$n_x \\ge 1$ 和 $m \\ge 1$ 分别是输入和反馈的 Hill 系数，$K_x > 0$，$K_y > 0$ 是尺度参数。所有变量和参数都是无量纲的。\n- 对于每个固定的 $x$，函数 $t \\mapsto y(t)$ 从两个不同的初始条件开始积分至稳态，以模拟上行扫描和下行扫描：\n    - 上行扫描：按递增顺序枚举 $x$。对于第一个 $x$，初始化 $y(0) = 0$ 并积分至时间 $T$ 以获得稳态 $y^\\uparrow(x_1)$。对于下一个 $x$，从前一个稳态开始初始化，以此类推，得到分支 $y^\\uparrow(x)$。\n    - 下行扫描：按递减顺序枚举 $x$。对于第一个（最大的）$x$，初始化 $y(0) = 1$ 并积分至时间 $T$ 以获得稳态 $y^\\downarrow(x_N)$。对于下一个 $x$（向下移动），从前一个稳态开始初始化，以此类推，最后重新排序以匹配原始的递增 $x$ 网格，得到分支 $y^\\downarrow(x)$。\n- 数值积分必须足够精确以解析稳态。您可以选择任何合适的刚性或非刚性积分器，其绝对和相对误差容限需足够小，以确保在时间范围 $T$ 内收敛。\n\n超敏性与双稳态的分类规则：\n- 给定在相同输入值下的匹配数组 $\\{x_i\\}_{i=1}^N$、$\\{y^\\uparrow_i\\}_{i=1}^N$ 和 $\\{y^\\downarrow_i\\}_{i=1}^N$，定义逐点绝对差 $\\Delta_i = \\left|y^\\uparrow_i - y^\\downarrow_i\\right|$。\n- 固定一个数值阈值 $\\tau > 0$ 和一个比例阈值 $\\phi \\in (0, 1)$。计算比例 $\\rho = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{1}\\{\\Delta_i > \\tau\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 表示指示函数。\n- 如果 $\\rho > \\phi$，则将数据集分类为双稳态（迟滞的），否则将其分类为超敏单稳态。此规则分离了路径依赖性，并且对小噪声具有鲁棒性。\n\n所有变量和参数都是无量纲的。不涉及物理单位。\n\n测试套件：\n对于下面的每个测试用例，您必须按规定生成数据，应用阈值为 $\\tau = 0.08$ 和 $\\phi = 0.10$ 的分类规则，并为每个测试用例生成一个数字分类，编码为 $1$ 代表双稳态，$0$ 代表超敏单稳态。\n\n- 测试用例 A（超敏，中等陡峭度，无噪声）：\n    - 输入：$x$ 在一个从 $10^{-2}$ 到 $10^{2}$ 的对数网格上，有 $31$ 个点。\n    - 参数：$n = 3$，$K = 1$。\n    - 数据：$y^\\uparrow(x) = y^\\downarrow(x) = H(x; n, K)$。\n\n- 测试用例 B（双稳态，强迟滞窗口）：\n    - 输入：$x$ 在一个从 $0$ 到 $3$ 的线性网格上，有 $41$ 个点。\n    - ODE 参数：$d = 0.8$，$m = 6$，$K_y = 0.5$，$n_x = 2$，$K_x = 1$，每个积分段的时间范围 $T = 200$。\n    - 数据：如上文定义，通过上行扫描和下行扫描计算 $y^\\uparrow(x)$ 和 $y^\\downarrow(x)$。\n\n- 测试用例 C（超敏，非常陡峭，无噪声）：\n    - 输入：与测试用例 A 相同。\n    - 参数：$n = 12$，$K = 1$。\n    - 数据：$y^\\uparrow(x) = y^\\downarrow(x) = H(x; n, K)$。\n\n- 测试用例 D（双稳态，较窄的迟滞窗口）：\n    - 输入：$x$ 在一个从 $0.7$ 到 $1.3$ 的线性网格上，有 $31$ 个点。\n    - ODE 参数：与测试用例 B 相同，时间范围 $T = 200$。\n    - 数据：通过上行扫描和下行扫描计算 $y^\\uparrow(x)$ 和 $y^\\downarrow(x)$。\n\n- 测试用例 E（超敏，中等陡峭度，带测量噪声）：\n    - 输入：与测试用例 A 相同。\n    - 参数：$n = 4$，$K = 1$。\n    - 噪声：独立的零均值高斯噪声，标准差 $\\sigma = 0.02$，添加到每个分支和每个输入，并裁剪到 $[0, 1]$。\n    - 数据：$y^\\uparrow(x) = \\mathrm{clip}(H(x; n, K) + \\eta^{\\uparrow}, 0, 1)$ 和 $y^\\downarrow(x) = \\mathrm{clip}(H(x; n, K) + \\eta^{\\downarrow}, 0, 1)$。\n\n要求的程序行为和输出格式：\n- 根据上述数学规范实现数据生成器和分类器。\n- 使用固定的伪随机数生成器种子以确保确定性输出。\n- 对于每个测试用例，计算分类结果并将其存储为整数 $0$ 或 $1$。\n- 您的程序应生成单行输出，其中包含按测试用例 A 到 E 的顺序排列的结果，格式为方括号括起来的逗号分隔列表（例如，$[0,1,0,1,0]$）。", "solution": "用户提供的问题已经过验证，并被确定为是合理的。它有科学依据、适定、客观且完整。提供了获得唯一、可验证解所需的所有参数和程序。该问题涉及系统生物学中的一个核心主题：区分调控回路中的超敏和双稳态动态行为。\n\n解决方案的步骤是首先为每种类型的回路实现数学模型，然后应用一个清晰、定量的分类规则。\n\n**1. 概念框架：超敏性与双稳态**\n\n在细胞调控网络中，由状态变量 $y$ 表示的组分对刺激或输入 $x$ 的响应可以表现出不同的特征。\n- **超敏性**：这描述了一种 S 形的、开关样的响应，其比简单的双曲线（Michaelis-Menten）响应更陡峭。对于每个输入 $x$，系统有唯一的稳态输出 $y^\\star$。在阈值输入水平附近会发生一个陡峭但连续的转变。\n- **双稳态**：这描述了一个系统，对于相同的输入值 $x$，它可以存在于两个不同的稳定稳态。这种行为源于正反馈等机制。系统的状态取决于其历史，这种现象称为迟滞。一次“上行扫描”（增加 $x$）将描绘出与“下行扫描”（减少 $x$）不同的响应曲线，形成一个迟滞回线。\n\n**2. 用于数据生成的数学模型**\n\n如上所述，所有变量和参数都是无量纲的。\n\n**2.1. 超敏单稳态模型**\n超敏回路的稳态输入-输出关系由 Hill 激活函数建模：\n$$\ny(x) = H(x; n, K) = \\frac{x^n}{K^n + x^n}\n$$\n在这里，$x \\ge 0$ 是输入，$y(x) \\in [0, 1]$ 是输出，$K > 0$ 是激活常数（产生半最大响应的输入水平），$n \\ge 1$ 是 Hill 系数，它量化了响应的陡峭度或“超敏性”。对于单稳态系统，响应曲线与系统历史无关，因此上行扫描和下行扫描分支是相同的：$y^\\uparrow(x) = y^\\downarrow(x) = y(x)$。\n\n为了模拟实验条件，可以添加标准差为 $\\sigma$ 的零均值高斯噪声 $\\eta$。测量的输出 $y_{\\mathrm{meas}}$ 被裁剪到生物物理上现实的范围 $[0, 1]$ 内：\n$$\ny_{\\mathrm{meas}}(x) = \\mathrm{clip}(y(x) + \\eta, 0, 1)\n$$\n对于涉及噪声的测试用例，我们分别为上行扫描和下行扫描分支生成两组独立的噪声样本 $\\eta^\\uparrow$ 和 $\\eta^\\downarrow$。\n\n**2.2. 双稳态正反馈模型**\n一个可以表现出双稳态的、带正自激活的基因回路的简单一维模型由以下常微分方程 (ODE) 给出：\n$$\n\\frac{dy}{dt} = f(y, x) = -y + \\left((1 - d)\\,H(x; n_x, K_x) + d\\,H(y; m, K_y)\\right)\n$$\n$y$ 的变化率 $\\frac{dy}{dt}$ 是线性降解项 ($-y$) 和生产项之间的平衡。生产由外部输入 $x$（权重为 $1-d$）和来自 $y$ 本身的正反馈（权重为 $d \\in (0, 1)$）共同驱动。反馈回路中的高协同性（大的 Hill 系数 $m$）是双稳态的一个关键要素。\n\n稳态 $y^\\star$ 通过求解代数方程 $\\frac{dy}{dt} = 0$ 得到，这等价于找到生产函数的不动点，$y^\\star = G(y^\\star; x)$，其中 $G(y; x) = (1 - d)\\,H(x; n_x, K_x) + d\\,H(y; m, K_y)$。根据参数的不同，该方程在 $[0, 1]$ 范围内对于 $y^\\star$ 可能有一个或三个解。在有三个解的情况下，两个是稳定的，一个是不稳定的。\n\n为了描绘迟滞行为，我们通过对一系列 $x$ 值进行数值积分至稳态来模拟上行扫描和下行扫描。`scipy.integrate.solve_ivp` 函数适用于此任务，因为它为初值问题提供了鲁棒的数值求解器。对于输入网格中的每个 $x_i$，我们在一个足够大的时间间隔 $[0, T]$ 上求解 ODE，以确保收敛到稳态。\n- **上行扫描 ($y^\\uparrow$)**：我们从最小到最大迭代 $x_i$。第一个输入 $x_1$ 的初始条件是 $y(0) = 0$。对于每个后续输入 $x_i$，初始条件是为前一个输入找到的稳态 $y^\\uparrow(x_{i-1})$。这模拟了从“低”状态启动系统。\n- **下行扫描 ($y^\\downarrow$)**：我们从最大到最小迭代 $x_i$。第一个输入（最大的 $x_N$）的初始条件是 $y(0) = 1$。对于每个后续输入 $x_i$（按递减顺序），初始条件是为前一个输入找到的稳态 $y^\\downarrow(x_{i+1})$。这模拟了从“高”状态启动系统。然后将所得分支重新排序以对应于递增的 $x$ 轴。\n\n**3. 分类算法**\n\n区分双稳态和超敏性的核心思想是检测路径依赖（迟滞）。给定生成的成对数据集 $\\{x_i\\}$、$\\{y^\\uparrow_i\\}$ 和 $\\{y^\\downarrow_i\\}$，我们应用以下规则：\n1.  为每个输入索引 $i$ 计算逐点绝对差：$\\Delta_i = |y^\\uparrow_i - y^\\downarrow_i|$。\n2.  计算该差异超过固定数值容差阈值 $\\tau = 0.08$ 的点的数量。设此计数为 $N_{\\text{diff}}$。\n3.  计算这些点的比例：$\\rho = \\frac{N_{\\text{diff}}}{N} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{1}\\{\\Delta_i > \\tau\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n4.  将此比例与第二个阈值 $\\phi = 0.10$ 进行比较。如果 $\\rho > \\phi$，意味着输入范围的很大一部分在上行扫描和下行扫描分支之间表现出显著差异。则该系统被分类为**双稳态**（输出 $1$）。否则，它被分类为**超敏单稳态**（输出 $0$）。\n\n这种双阈值方法提供了鲁棒性。$\\tau$ 阈值确保只计算有意义的差异，滤除小的数值积分误差或微小的噪声波动。$\\phi$ 阈值确保双稳态行为在输入范围的相当大一部分内是持续的，而不仅仅是在一个孤立点上。\n\n**4. 实现策略**\n\nPython 实现将包含几个关键函数：\n- 一个 `hill_function` 实用函数。\n- 一个 `generate_ultrasensitive_data` 函数，用于计算 $H(x; n, K)$ 并添加可选噪声。这将处理测试用例 A、C 和 E。\n- 一个 `generate_bistable_data` 函数，用于实现上行和下行扫描的积分过程。这将需要一个定义 ODE $\\frac{dy}{dt}$ 的内部函数，以传递给 `scipy.integrate.solve_ivp`。该函数处理测试用例 B 和 D。\n- 一个 `classify_system` 函数，它接收 $y^\\uparrow$ 和 $y^\\downarrow$，并根据 $\\tau$ 和 $\\phi$ 阈值返回 $0$ 或 $1$。\n- 一个主 `solve` 函数将协调整个过程：\n    - 它为五个测试用例中的每一个设置参数。\n    - 它在测试用例 E 中使用固定的随机种子以保证可复现性。\n    - 它遍历测试用例，调用相应的数据生成器。\n    - 它对生成的数据调用分类器。\n    - 它收集分类结果并以指定的最终格式打印它们。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for classifying ultrasensitive vs. bistable systems.\n    \"\"\"\n    \n    # --- Helper and Model Functions ---\n\n    def hill_function(z, n, K):\n        \"\"\"Computes the Hill activation function.\"\"\"\n        # Add a small epsilon to avoid division by zero or 0^n issues if K=0 or z=0\n        epsilon = 1e-12\n        if isinstance(z, np.ndarray):\n            z_safe = np.maximum(z, 0)\n        else:\n            z_safe = max(z, 0)\n        \n        return (z_safe**n) / (K**n + z_safe**n + epsilon)\n\n    def generate_ultrasensitive_data(x_grid, n, K, noise_std=0.0, rng=None):\n        \"\"\"\n        Generates data for an ultrasensitive monostable system.\n        The up-scan and down-scan branches are notionally different due to noise.\n        \"\"\"\n        y_base = hill_function(x_grid, n, K)\n        \n        if noise_std > 0 and rng is not None:\n            noise_up = rng.normal(0, noise_std, size=x_grid.shape)\n            noise_down = rng.normal(0, noise_std, size=x_grid.shape)\n            y_up = np.clip(y_base + noise_up, 0, 1)\n            y_down = np.clip(y_base + noise_down, 0, 1)\n        else:\n            y_up = y_base\n            y_down = y_base\n            \n        return y_up, y_down\n\n    def generate_bistable_data(x_grid, params, T):\n        \"\"\"\n        Generates hysteretic data for a bistable system by simulating up- and down-scans.\n        \"\"\"\n        d, m, K_y, n_x, K_x = params['d'], params['m'], params['K_y'], params['n_x'], params['K_x']\n\n        def dydt(t, y, x_val):\n            \"\"\"ODE for the positive feedback circuit.\"\"\"\n            # y is a 1-element array, so we access y[0]\n            val_y = max(y[0], 0) # Ensure y is non-negative for Hill function\n            production = (1 - d) * hill_function(x_val, n_x, K_x) + d * hill_function(val_y, m, K_y)\n            return -y[0] + production\n\n        # Up-scan\n        y_up = np.zeros_like(x_grid)\n        y_initial = np.array([0.0])\n        for i, x_val in enumerate(x_grid):\n            sol = solve_ivp(dydt, [0, T], y_initial, args=(x_val,), method='LSODA', rtol=1e-8, atol=1e-10)\n            y_final = sol.y[0, -1]\n            y_up[i] = y_final\n            y_initial = np.array([y_final])\n            \n        # Down-scan\n        y_down_rev = np.zeros_like(x_grid)\n        y_initial = np.array([1.0])\n        for i, x_val in enumerate(reversed(x_grid)):\n            sol = solve_ivp(dydt, [0, T], y_initial, args=(x_val,), method='LSODA', rtol=1e-8, atol=1e-10)\n            y_final = sol.y[0, -1]\n            y_down_rev[i] = y_final\n            y_initial = np.array([y_final])\n        \n        y_down = np.flip(y_down_rev)\n        \n        return y_up, y_down\n\n    def classify_system(y_up, y_down, tau, phi):\n        \"\"\"\n        Classifies a system as bistable (1) or ultrasensitive (0) based on hysteresis.\n        \"\"\"\n        delta = np.abs(y_up - y_down)\n        N = len(delta)\n        rho = np.sum(delta > tau) / N\n        \n        return 1 if rho > phi else 0\n\n    # --- Test Case Execution ---\n\n    # Fixed classification thresholds\n    TAU = 0.08\n    PHI = 0.10\n    \n    test_cases_defs = [\n        {'id': 'A', 'type': 'ultrasensitive', 'x_grid': np.logspace(-2, 2, 31), 'params': {'n': 3, 'K': 1}, 'noise_std': 0.0},\n        {'id': 'B', 'type': 'bistable', 'x_grid': np.linspace(0, 3, 41), 'params': {'d': 0.8, 'm': 6, 'K_y': 0.5, 'n_x': 2, 'K_x': 1}, 'T': 200},\n        {'id': 'C', 'type': 'ultrasensitive', 'x_grid': np.logspace(-2, 2, 31), 'params': {'n': 12, 'K': 1}, 'noise_std': 0.0},\n        {'id': 'D', 'type': 'bistable', 'x_grid': np.linspace(0.7, 1.3, 31), 'params': {'d': 0.8, 'm': 6, 'K_y': 0.5, 'n_x': 2, 'K_x': 1}, 'T': 200},\n        {'id': 'E', 'type': 'ultrasensitive', 'x_grid': np.logspace(-2, 2, 31), 'params': {'n': 4, 'K': 1}, 'noise_std': 0.02},\n    ]\n\n    results = []\n    # Fixed seed for reproducibility of noise in Test Case E\n    rng = np.random.default_rng(42)\n\n    for case in test_cases_defs:\n        if case['type'] == 'ultrasensitive':\n            y_up, y_down = generate_ultrasensitive_data(\n                x_grid=case['x_grid'],\n                n=case['params']['n'],\n                K=case['params']['K'],\n                noise_std=case['noise_std'],\n                rng=rng\n            )\n        elif case['type'] == 'bistable':\n            y_up, y_down = generate_bistable_data(\n                x_grid=case['x_grid'],\n                params=case['params'],\n                T=case['T']\n            )\n        else:\n            raise ValueError(f\"Unknown test case type: {case['type']}\")\n\n        classification = classify_system(y_up, y_down, TAU, PHI)\n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4321510"}]}