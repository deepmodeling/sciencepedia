{"hands_on_practices": [{"introduction": "系统发育谱分析最直接的方法是将基因在不同物种中的存在与否表示为二进制向量。通过计算这些向量之间的相关性，我们可以量化它们协同演化的程度。这项练习旨在巩固该方法背后的理论基础，它要求您证明在处理二进制数据时，通用的皮尔逊相关系数（Pearson correlation coefficient）在代数上等价于专门用于$2 \\times 2$列联表的phi系数 [@problem_id:4375029]。", "problem": "在系统生物医学中，系统发育分析将一组物种中基因组特征（例如，直系同源基因家族）的存在与否表示为二元向量。考虑两个这样的图谱，$x,y \\in \\{0,1\\}^{N}$，代表 $N$ 个物种。定义经验 $2 \\times 2$ 列联计数如下：\n$$\nn_{11}=\\sum_{i=1}^{N}\\mathbf{1}\\{x_{i}=1,y_{i}=1\\},\\quad\nn_{10}=\\sum_{i=1}^{N}\\mathbf{1}\\{x_{i}=1,y_{i}=0\\},\\quad\nn_{01}=\\sum_{i=1}^{N}\\mathbf{1}\\{x_{i}=0,y_{i}=1\\},\\quad\nn_{00}=\\sum_{i=1}^{N}\\mathbf{1}\\{x_{i}=0,y_{i}=0\\},\n$$\n并注意 $N=n_{11}+n_{10}+n_{01}+n_{00}$。令 $n_{1.}=n_{11}+n_{10}$、$n_{0.}=n_{01}+n_{00}$、$n_{.1}=n_{11}+n_{01}$ 和 $n_{.0}=n_{10}+n_{00}$ 表示边际计数。\n\n从基本定义出发，使用经验数据的 Pearson 相关系数 (PCC) 定义，\n$$\nr_{xy}=\\frac{\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)\\left(y_{i}-\\bar{y}\\right)}{\\sqrt{\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)^{2}}\\sqrt{\\sum_{i=1}^{N}\\left(y_{i}-\\bar{y}\\right)^{2}}},\n$$\n其中 $\\bar{x}=\\frac{1}{N}\\sum_{i=1}^{N}x_{i}$ 且 $\\bar{y}=\\frac{1}{N}\\sum_{i=1}^{N}y_{i}$，以及 phi 系数作为 $2 \\times 2$ 列联表的标准化关联性度量的核心定义，推导出一个完全由四个联合计数 $n_{11}$、$n_{10}$、$n_{01}$ 和 $n_{00}$ 表示的 $r_{xy}$ 的单一闭式解析表达式。然后，在不计算任何额外公式的情况下，用文字解释在何种条件下，Pearson 相关系数和 phi 系数在系统发育分析中对基因对关联产生相同的排序。\n\n最终答案仅用 $n_{11}$、$n_{10}$、$n_{01}$ 和 $n_{00}$ 表示为单一解析表达式。无需单位，也无需四舍五入。", "solution": "本题旨在证明对于二元数据，皮尔逊相关系数在代数上等价于 phi 系数。我们将从皮尔逊相关系数的定义出发，并用列联表计数来表示其各个组成部分，最终推导出完全由联合计数 $n_{11}$、$n_{10}$、$n_{01}$ 和 $n_{00}$ 表示的表达式。\n\n皮尔逊相关系数定义为：\n$$\nr_{xy}=\\frac{\\text{Cov}(x, y)}{\\sigma_x \\sigma_y} = \\frac{\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)\\left(y_{i}-\\bar{y}\\right)}{\\sqrt{\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)^{2}}\\sqrt{\\sum_{i=1}^{N}\\left(y_{i}-\\bar{y}\\right)^{2}}}\n$$\n\n首先，我们用计数来表示样本均值 $\\bar{x}$ 和 $\\bar{y}$。\n总和 $\\sum_{i=1}^{N}x_{i}$ 计算的是基因 $x$ 存在的物种数量（即 $x_i=1$）。这对应于 ($x_i=1, y_i=1$) 或 ($x_i=1, y_i=0$) 的情况。因此，$\\sum_{i=1}^{N}x_{i} = n_{11} + n_{10} = n_{1.}$。均值 $\\bar{x}$ 是：\n$$\n\\bar{x} = \\frac{1}{N}\\sum_{i=1}^{N}x_{i} = \\frac{n_{1.}}{N} = \\frac{n_{11}+n_{10}}{N}\n$$\n根据对称性，均值 $\\bar{y}$ 是：\n$$\n\\bar{y} = \\frac{1}{N}\\sum_{i=1}^{N}y_{i} = \\frac{n_{.1}}{N} = \\frac{n_{11}+n_{01}}{N}\n$$\n\n接下来，我们计算分母中的项，这些项与方差有关。\n对于项 $\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)^{2}$，我们使用恒等式 $\\sum (z - \\bar{z})^2 = \\sum z^2 - N\\bar{z}^2$。由于数据是二元的，$x_i \\in \\{0,1\\}$，我们有 $x_i^2 = x_i$ 这个性质。因此，$\\sum_{i=1}^{N}x_i^2 = \\sum_{i=1}^{N}x_i = n_{1.}$。该项变为：\n$$\n\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)^{2} = \\sum_{i=1}^{N}x_{i}^2 - N\\bar{x}^2 = n_{1.} - N\\left(\\frac{n_{1.}}{N}\\right)^2 = n_{1.} - \\frac{n_{1.}^2}{N} = \\frac{Nn_{1.} - n_{1.}^2}{N} = \\frac{n_{1.}(N-n_{1.})}{N}\n$$\n由于 $N = n_{1.} + n_{0.}$，我们有 $N - n_{1.} = n_{0.}$。所以，我们得到：\n$$\n\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)^{2} = \\frac{n_{1.}n_{0.}}{N}\n$$\n根据变量 $y$ 的对称性：\n$$\n\\sum_{i=1}^{N}\\left(y_{i}-\\bar{y}\\right)^{2} = \\frac{n_{.1}n_{.0}}{N}\n$$\n\n现在，我们计算分子，这与协方差有关。\n我们使用恒等式 $\\sum (x_i - \\bar{x})(y_i - \\bar{y}) = \\sum x_iy_i - N\\bar{x}\\bar{y}$。\n乘积 $x_i y_i$ 等于 $1$ 当且仅当 $x_i=1$ 且 $y_i=1$。在所有其他情况下，乘积为 $0$。因此，总和 $\\sum_{i=1}^{N}x_i y_i$ 只是计算两个基因都存在的物种数量，根据定义，这正是 $n_{11}$。分子项变为：\n$$\n\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)\\left(y_{i}-\\bar{y}\\right) = n_{11} - N\\left(\\frac{n_{1.}}{N}\\right)\\left(\\frac{n_{.1}}{N}\\right) = n_{11} - \\frac{n_{1.}n_{.1}}{N} = \\frac{Nn_{11} - n_{1.}n_{.1}}{N}\n$$\n为简化项 $Nn_{11} - n_{1.}n_{.1}$，我们代入 $N$、$n_{1.}$ 和 $n_{.1}$ 的定义：\n\\begin{align*}\nNn_{11} - n_{1.}n_{.1} &= (n_{11}+n_{10}+n_{01}+n_{00})n_{11} - (n_{11}+n_{10})(n_{11}+n_{01}) \\\\\n&= (n_{11}^2 + n_{10}n_{11} + n_{01}n_{11} + n_{00}n_{11}) - (n_{11}^2 + n_{11}n_{01} + n_{10}n_{11} + n_{10}n_{01}) \\\\\n&= n_{11}n_{00} - n_{10}n_{01}\n\\end{align*}\n所以 $r_{xy}$ 的分子是 $\\frac{n_{11}n_{00} - n_{10}n_{01}}{N}$。\n\n最后，我们组合出 $r_{xy}$ 的完整表达式：\n$$\nr_{xy} = \\frac{\\frac{n_{11}n_{00} - n_{10}n_{01}}{N}}{\\sqrt{\\left(\\frac{n_{1.}n_{0.}}{N}\\right)\\left(\\frac{n_{.1}n_{.0}}{N}\\right)}} = \\frac{n_{11}n_{00} - n_{10}n_{01}}{\\sqrt{n_{1.}n_{0.}n_{.1}n_{.0}}}\n$$\n这个表达式就是 phi 系数 $\\phi$ 的定义。为了只用四个联合计数提供最终答案，我们代入边际计数的定义：\n$$\nr_{xy} = \\frac{n_{11}n_{00} - n_{10}n_{01}}{\\sqrt{(n_{11}+n_{10})(n_{01}+n_{00})(n_{11}+n_{01})(n_{10}+n_{00})}}\n$$\n推导到此完成。\n\n关于问题的第二部分，该推导表明，对于二元变量（如系统发育分析中的存在/缺失向量），皮尔逊相关系数在代数上与 phi 系数完全相同。它们不是在特定条件下碰巧一致的两个不同度量；相反，phi 系数*就是*专用于两个二元变量情况的皮尔逊相关系数。因此，由于在此背景下 $r_{xy}$ 和 $\\phi$ 代表相同的数学量，它们对于任何给定的基因对总是会产生相同的值，因此必然会对任何一组基因对的关联产生相同的排序。此等式成立的唯一条件是所关联的数据必须是二元的，这本身就是问题陈述的一个基本假设。", "answer": "$$\n\\boxed{\\frac{n_{11}n_{00} - n_{10}n_{01}}{\\sqrt{(n_{11}+n_{10})(n_{01}+n_{00})(n_{11}+n_{01})(n_{10}+n_{00})}}}\n$$", "id": "4375029"}, {"introduction": "然而，物种并非独立的观测点，它们通过共同的进化历史联系在一起，因此直接计算相关性会产生系统性偏差。为了获得可靠的关联分数，必须对系统发育关系进行校正。这项编程实践 [@problem_id:4375055] 将指导您实现一种关键的校正技术——系统发育白化（phylogenetic whitening），并利用自举法（bootstrapping）来量化由系统发育树本身的不确定性所带来的关联分数不确定性。", "problem": "您将获得一组物种水平的协方差矩阵，这些矩阵源于在性状演化的布朗运动模型下，对一个估计的物种系统发育树进行自举重复采样。在用于功能注释的系统发育谱分析中，两个跨物种基因谱之间的关联得分应考虑到共同的演化历史。在布朗运动模型下，如果一个连续性状沿着一个总根到叶时间为 $T$ 的物种树演化，那么跨物种的性状协方差矩阵等于物种间的共同演化时间，而这个时间可以从物种树中估计出来。对物种树的自举重复会产生一组协方差矩阵，这些矩阵近似了由树推断引起的不确定性。\n\n您的任务是编写一个程序，该程序针对每个测试用例，通过在自举协方差矩阵中传播变异，来计算两个基因谱之间经过系统发育校正的关联得分，然后报告一个双侧置信区间。该程序必须从基本原理出发实现以下过程：\n\n1. 对于一个给定的对称正定协方差矩阵 $\\mathbf{C} \\in \\mathbb{R}^{n \\times n}$，计算代表 $n$ 个物种的基因谱的两个向量 $\\mathbf{x} \\in \\mathbb{R}^{n}$ 和 $\\mathbf{y} \\in \\mathbb{R}^{n}$ 之间经过系统发育校正的关联得分。使用以下步骤：\n   - 计算 Cholesky 分解 $\\mathbf{C} = \\mathbf{L}\\mathbf{L}^{\\top}$，其中 $\\mathbf{L}$ 是下三角矩阵。\n   - 求解 $\\mathbf{L}\\mathbf{z}_{x} = \\mathbf{x}$ 和 $\\mathbf{L}\\mathbf{z}_{y} = \\mathbf{y}$ 以获得白化向量 $\\mathbf{z}_{x}$ 和 $\\mathbf{z}_{y}$。\n   - 通过减去各自的算术平均值来对每个白化向量进行中心化：$\\tilde{\\mathbf{z}}_{x} = \\mathbf{z}_{x} - \\bar{z}_{x}\\mathbf{1}$ 和 $\\tilde{\\mathbf{z}}_{y} = \\mathbf{z}_{y} - \\bar{z}_{y}\\mathbf{1}$，其中 $\\bar{z}_{x} = \\frac{1}{n}\\sum_{i=1}^{n} z_{x,i}$ 和 $\\bar{z}_{y} = \\frac{1}{n}\\sum_{i=1}^{n} z_{y,i}$，且 $\\mathbf{1}$ 是 $\\mathbb{R}^{n}$ 中的全1向量。\n   - 将经过系统发育校正的关联得分定义为中心化后的白化向量的皮尔逊相关系数，\n     $$ r = \\frac{\\tilde{\\mathbf{z}}_{x}^{\\top}\\tilde{\\mathbf{z}}_{y}}{\\|\\tilde{\\mathbf{z}}_{x}\\|_{2}\\,\\|\\tilde{\\mathbf{z}}_{y}\\|_{2}}. $$\n     如果 $\\|\\tilde{\\mathbf{z}}_{x}\\|_{2} = 0$ 或 $\\|\\tilde{\\mathbf{z}}_{y}\\|_{2} = 0$，则为该重复样本定义 $r = 0$，以避免除以零。\n   这种构造通过白化实现了广义最小二乘法，其合理性由布朗运动模型和高斯增量假设来保证。\n\n2. 对于一组 $K$ 个自举协方差矩阵 $\\{\\mathbf{C}^{(k)}\\}_{k=1}^{K}$，计算 $K$ 个关联得分 $\\{r^{(k)}\\}_{k=1}^{K}$，每个重复协方差矩阵对应一个。对于给定的双侧置信水平 $1-\\alpha$（其中 $\\alpha \\in (0,1)$），计算在 $q_{\\mathrm{low}} = \\alpha/2$ 和 $q_{\\mathrm{high}} = 1 - \\alpha/2$ 处的经验分位数作为置信下限和上限。使用以下分位数定义（顺序统计量之间的分段线性插值，也称为类型7分位数）：\n   - 设排序后的值为 $v_{(1)} \\le \\cdots \\le v_{(K)}$。\n   - 对于分位数水平 $q \\in [0,1]$，计算\n     $$ h = (K - 1)q + 1, \\quad k = \\lfloor h \\rfloor, \\quad \\gamma = h - k. $$\n   - 分位数为\n     $$ Q(q) = \\begin{cases}\n     v_{(k)}  \\text{如果 } \\gamma = 0,\\\\\n     v_{(k)} + \\gamma\\left(v_{(k+1)} - v_{(k)}\\right)  \\text{如果 } \\gamma \\in (0,1).\n     \\end{cases} $$\n\n3. 将此过程应用于下面的每个测试用例，其中 $\\alpha = 0.05$（即 $q_{\\mathrm{low}} = 0.025$ 和 $q_{\\mathrm{high}} = 0.975$）。为保证数值稳定性，如果协方差矩阵接近奇异，您可以在进行 Cholesky 分解之前添加一个小的对角抖动 $\\varepsilon \\mathbf{I}$，其中 $\\varepsilon = 10^{-10}$。\n\n测试套件。每个测试用例包含一对向量 $(\\mathbf{x}, \\mathbf{y})$ 和一个自举协方差矩阵列表。所有数字均为实值。向量按物种顺序 $\\{s_{1}, s_{2}, s_{3}, s_{4}\\}$ 列出。\n\n- 测试用例 1 (正常路径；强一致性):\n  - $\\mathbf{x} = [\\,1,\\,1,\\,0,\\,0\\,]$, $\\mathbf{y} = [\\,1,\\,1,\\,0,\\,0\\,]$.\n  - 自举协方差矩阵 ($K = 5$):\n    - $\\mathbf{C}^{(1)} = \\begin{bmatrix}\n      1.0  0.8  0.2  0.2\\\\\n      0.8  1.0  0.2  0.2\\\\\n      0.2  0.2  1.0  0.7\\\\\n      0.2  0.2  0.7  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(2)} = \\begin{bmatrix}\n      1.0  0.75  0.25  0.25\\\\\n      0.75  1.0  0.25  0.25\\\\\n      0.25  0.25  1.0  0.65\\\\\n      0.25  0.25  0.65  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(3)} = \\begin{bmatrix}\n      1.0  0.85  0.15  0.15\\\\\n      0.85  1.0  0.15  0.15\\\\\n      0.15  0.15  1.0  0.6\\\\\n      0.15  0.15  0.6  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(4)} = \\begin{bmatrix}\n      1.0  0.7  0.3  0.2\\\\\n      0.7  1.0  0.2  0.3\\\\\n      0.3  0.2  1.0  0.55\\\\\n      0.2  0.3  0.55  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(5)} = \\begin{bmatrix}\n      1.0  0.78  0.22  0.22\\\\\n      0.78  1.0  0.22  0.22\\\\\n      0.22  0.22  1.0  0.68\\\\\n      0.22  0.22  0.68  1.0\n      \\end{bmatrix}$.\n\n- 测试用例 2 (边界情况；近星状树，完全一致):\n  - $\\mathbf{x} = [\\,0,\\,1,\\,0,\\,1\\,]$, $\\mathbf{y} = [\\,0,\\,1,\\,0,\\,1\\,]$.\n  - 自举协方差矩阵 ($K = 5$):\n    - $\\mathbf{C}^{(1)} = \\begin{bmatrix}\n      1.0  0.4  0.4  0.4\\\\\n      0.4  1.0  0.4  0.4\\\\\n      0.4  0.4  1.0  0.4\\\\\n      0.4  0.4  0.4  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(2)} = \\begin{bmatrix}\n      1.0  0.3  0.3  0.3\\\\\n      0.3  1.0  0.3  0.3\\\\\n      0.3  0.3  1.0  0.3\\\\\n      0.3  0.3  0.3  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(3)} = \\begin{bmatrix}\n      1.0  0.2  0.2  0.2\\\\\n      0.2  1.0  0.2  0.2\\\\\n      0.2  0.2  1.0  0.2\\\\\n      0.2  0.2  0.2  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(4)} = \\begin{bmatrix}\n      1.0  0.5  0.5  0.5\\\\\n      0.5  1.0  0.5  0.5\\\\\n      0.5  0.5  1.0  0.5\\\\\n      0.5  0.5  0.5  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(5)} = \\begin{bmatrix}\n      1.0  0.35  0.35  0.35\\\\\n      0.35  1.0  0.35  0.35\\\\\n      0.35  0.35  1.0  0.35\\\\\n      0.35  0.35  0.35  1.0\n      \\end{bmatrix}$.\n\n- 测试用例 3 (边缘情况；跨自举树的不一致模式):\n  - $\\mathbf{x} = [\\,1,\\,1,\\,0,\\,0\\,]$, $\\mathbf{y} = [\\,1,\\,0,\\,1,\\,0\\,]$.\n  - 自举协方差矩阵 ($K = 5$):\n    - $\\mathbf{C}^{(1)} = \\begin{bmatrix}\n      1.0  0.8  0.2  0.2\\\\\n      0.8  1.0  0.2  0.2\\\\\n      0.2  0.2  1.0  0.7\\\\\n      0.2  0.2  0.7  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(2)} = \\begin{bmatrix}\n      1.0  0.2  0.8  0.2\\\\\n      0.2  1.0  0.2  0.75\\\\\n      0.8  0.2  1.0  0.2\\\\\n      0.2  0.75  0.2  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(3)} = \\begin{bmatrix}\n      1.0  0.2  0.2  0.8\\\\\n      0.2  1.0  0.75  0.2\\\\\n      0.2  0.75  1.0  0.2\\\\\n      0.8  0.2  0.2  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(4)} = \\begin{bmatrix}\n      1.0  0.6  0.4  0.3\\\\\n      0.6  1.0  0.3  0.4\\\\\n      0.4  0.3  1.0  0.6\\\\\n      0.3  0.4  0.6  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(5)} = \\begin{bmatrix}\n      1.0  0.3  0.3  0.3\\\\\n      0.3  1.0  0.3  0.3\\\\\n      0.3  0.3  1.0  0.3\\\\\n      0.3  0.3  0.3  1.0\n      \\end{bmatrix}$.\n\n实现要求：\n- 使用上述精确的分位数定义，其中 $q_{\\mathrm{low}} = 0.025$ 和 $q_{\\mathrm{high}} = 0.975$。\n- 如果 Cholesky 分解由于数值问题失败，您可以在对角线上添加一个抖动 $\\varepsilon = 10^{-10}$。\n- 对于每个测试用例，将置信区间报告为一对数 $[L, U]$，其中 $L$ 和 $U$ 是四舍五入到6位小数的实数。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含三个测试用例的结果，格式为一个包含三个区间的列表，每个区间本身是一个含两个元素的列表，无空格，且数字四舍五入到6位小数。例如：`[[0.123456,0.654321],[0.100000,0.900000],[\\dots,\\dots]]`。", "solution": "本问题的解决方案基于以下三个核心统计学原理，旨在计算经过系统发育校正的关联得分并量化其不确定性。\n\n1.  **通过数据白化进行系统发育校正**\n    在演化生物学中，对一组相关物种测量的性状在统计上并非独立的。共同的演化历史导致了一种协方差结构，在统计分析中必须予以考虑。性状演化的布朗运动模型假定，$n$ 个物种的连续性状向量 $\\mathbf{x} \\in \\mathbb{R}^{n}$ 服从多元正态分布 $\\mathbf{x} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\mathbf{C})$，其中 $\\mathbf{C} \\in \\mathbb{R}^{n \\times n}$ 是协方差矩阵。该矩阵的元素 $C_{ij}$ 与从系统发育树的根到物种 $i$ 和 $j$ 的最近共同祖先的共同分支长度成正比。\n\n    标准统计方法（如皮尔逊相关）假设观测值是独立同分布的。为了使用这类方法，我们必须首先对数据进行变换以消除系统发育相关性。这个过程被称为“白化”。我们寻求一个线性变换，使得变换后的向量 $\\mathbf{z} = \\mathbf{L}^{-1}\\mathbf{x}$ 的协方差矩阵等于单位矩阵 $\\mathbf{I}$。这可以通过对协方差矩阵 $\\mathbf{C}$ 进行 Cholesky 分解（$\\mathbf{C} = \\mathbf{L}\\mathbf{L}^{\\top}$）来实现，其中 $\\mathbf{L}$ 是一个下三角矩阵。白化向量 $\\mathbf{z}$ 可以通过求解下三角线性系统 $\\mathbf{L}\\mathbf{z} = \\mathbf{x}$ 来高效计算，这在数值上比计算 $\\mathbf{L}^{-1}$ 更稳定。\n\n2.  **计算经过系统发育校正的关联得分**\n    一旦我们将原始基因谱 $\\mathbf{x}$ 和 $\\mathbf{y}$ 转换为它们的白化对应物 $\\mathbf{z}_{x}$ 和 $\\mathbf{z}_{y}$，这些新向量的分量就变得不相关且方差为1。此时，我们可以使用标准的皮尔逊相关系数来计算一个有意义的关联得分。首先，通过减去各自的算术平均值来对白化向量进行中心化：\n    $$ \\tilde{\\mathbf{z}}_{x} = \\mathbf{z}_{x} - \\bar{z}_{x}\\mathbf{1}, \\quad \\tilde{\\mathbf{z}}_{y} = \\mathbf{z}_{y} - \\bar{z}_{y}\\mathbf{1} $$\n    经过系统发育校正的关联得分 $r$ 便是中心化后的白化向量的皮尔逊相关系数，计算公式如下：\n    $$ r = \\frac{\\tilde{\\mathbf{z}}_{x}^{\\top}\\tilde{\\mathbf{z}}_{y}}{\\|\\tilde{\\mathbf{z}}_{x}\\|_{2}\\,\\|\\tilde{\\mathbf{z}}_{y}\\|_{2}} $$\n    如果任一中心化白化向量的范数为零，则相关系数未定义，按规定将得分设为 $r=0$。\n\n3.  **自举置信区间**\n    协方差矩阵 $\\mathbf{C}$ 本身是从一个估计的系统发育树中派生出来的，这个估计存在不确定性。为了将这种不确定性传播到我们的关联得分中，我们使用一组 $K$ 个自举重复的协方差矩阵 $\\{\\mathbf{C}^{(k)}\\}_{k=1}^{K}$。\n\n    对于每个矩阵 $\\mathbf{C}^{(k)}$，我们如上所述计算关联得分 $r^{(k)}$，从而得到一个反映系统发育不确定性的关联得分分布 $\\{r^{(k)}\\}_{k=1}^{K}$。一个置信水平为 $1-\\alpha$ 的双侧置信区间可以通过找到该自举分布的经验分位数来构建。下限是分位数 $q_{\\mathrm{low}} = \\alpha/2$，上限是分位数 $q_{\\mathrm{high}} = 1 - \\alpha/2$。问题指定了类型7分位数定义，它在样本点之间进行线性插值，这是一种从有限样本中估计分位数的标准方法。\n\n    设排序后的得分为 $v_{(1)} \\le v_{(2)} \\le \\cdots \\le v_{(K)}$。对于期望的分位数 $q$，计算一个基于1的索引 $h = (K - 1)q + 1$。其整数部分为 $k = \\lfloor h \\rfloor$，小数部分为 $\\gamma = h - k$。分位数值 $Q(q)$ 通过插值计算：\n    $$ Q(q) = v_{(k)} + \\gamma(v_{(k+1)} - v_{(k)}) $$\n\n该算法为在存在系统发育非独立性的情况下，稳健地估计性状关联及其不确定性提供了一个严谨的框架。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import cholesky, solve_triangular\nfrom scipy.linalg.lapack import dpotrf\n\ndef solve():\n    \"\"\"\n    Computes phylogenetically corrected association scores and confidence intervals\n    for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"x\": np.array([1.0, 1.0, 0.0, 0.0]),\n            \"y\": np.array([1.0, 1.0, 0.0, 0.0]),\n            \"C_list\": [\n                np.array([\n                    [1.0, 0.8, 0.2, 0.2],\n                    [0.8, 1.0, 0.2, 0.2],\n                    [0.2, 0.2, 1.0, 0.7],\n                    [0.2, 0.2, 0.7, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.75, 0.25, 0.25],\n                    [0.75, 1.0, 0.25, 0.25],\n                    [0.25, 0.25, 1.0, 0.65],\n                    [0.25, 0.25, 0.65, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.85, 0.15, 0.15],\n                    [0.85, 1.0, 0.15, 0.15],\n                    [0.15, 0.15, 1.0, 0.6],\n                    [0.15, 0.15, 0.6, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.7, 0.3, 0.2],\n                    [0.7, 1.0, 0.2, 0.3],\n                    [0.3, 0.2, 1.0, 0.55],\n                    [0.2, 0.3, 0.55, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.78, 0.22, 0.22],\n                    [0.78, 1.0, 0.22, 0.22],\n                    [0.22, 0.22, 1.0, 0.68],\n                    [0.22, 0.22, 0.68, 1.0]\n                ])\n            ]\n        },\n        {\n            \"x\": np.array([0.0, 1.0, 0.0, 1.0]),\n            \"y\": np.array([0.0, 1.0, 0.0, 1.0]),\n            \"C_list\": [\n                np.array([\n                    [1.0, 0.4, 0.4, 0.4], [0.4, 1.0, 0.4, 0.4],\n                    [0.4, 0.4, 1.0, 0.4], [0.4, 0.4, 0.4, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.3, 0.3, 0.3], [0.3, 1.0, 0.3, 0.3],\n                    [0.3, 0.3, 1.0, 0.3], [0.3, 0.3, 0.3, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.2, 0.2, 0.2], [0.2, 1.0, 0.2, 0.2],\n                    [0.2, 0.2, 1.0, 0.2], [0.2, 0.2, 0.2, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.5, 0.5, 0.5], [0.5, 1.0, 0.5, 0.5],\n                    [0.5, 0.5, 1.0, 0.5], [0.5, 0.5, 0.5, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.35, 0.35, 0.35], [0.35, 1.0, 0.35, 0.35],\n                    [0.35, 0.35, 1.0, 0.35], [0.35, 0.35, 0.35, 1.0]\n                ])\n            ]\n        },\n        {\n            \"x\": np.array([1.0, 1.0, 0.0, 0.0]),\n            \"y\": np.array([1.0, 0.0, 1.0, 0.0]),\n            \"C_list\": [\n                np.array([\n                    [1.0, 0.8, 0.2, 0.2], [0.8, 1.0, 0.2, 0.2],\n                    [0.2, 0.2, 1.0, 0.7], [0.2, 0.2, 0.7, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.2, 0.8, 0.2], [0.2, 1.0, 0.2, 0.75],\n                    [0.8, 0.2, 1.0, 0.2], [0.2, 0.75, 0.2, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.2, 0.2, 0.8], [0.2, 1.0, 0.75, 0.2],\n                    [0.2, 0.75, 1.0, 0.2], [0.8, 0.2, 0.2, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.6, 0.4, 0.3], [0.6, 1.0, 0.3, 0.4],\n                    [0.4, 0.3, 1.0, 0.6], [0.3, 0.4, 0.6, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.3, 0.3, 0.3], [0.3, 1.0, 0.3, 0.3],\n                    [0.3, 0.3, 1.0, 0.3], [0.3, 0.3, 0.3, 1.0]\n                ])\n            ]\n        }\n    ]\n\n    alpha = 0.05\n    q_low = alpha / 2.0\n    q_high = 1.0 - alpha / 2.0\n    epsilon = 1e-10\n\n    results = []\n    \n    for case in test_cases:\n        x = case[\"x\"]\n        y = case[\"y\"]\n        C_list = case[\"C_list\"]\n        n = x.shape[0]\n\n        r_scores = []\n        for C_orig in C_list:\n            C = C_orig.copy()\n            # Perform Cholesky factorization, adding jitter if not positive definite\n            try:\n                # Use raw LAPACK call to check for non-positive-definiteness\n                # dpotrf returns a positive info value if not positive definite\n                _, info = dpotrf(C, lower=True, overwrite_a=False, clean=True)\n                if info > 0:\n                    raise np.linalg.LinAlgError(\"Matrix is not positive definite\")\n                L = cholesky(C, lower=True)\n            except np.linalg.LinAlgError:\n                C_jittered = C + np.eye(n) * epsilon\n                L = cholesky(C_jittered, lower=True)\n\n            # Whiten the vectors by solving L * z = x (and y)\n            zx = solve_triangular(L, x, lower=True)\n            zy = solve_triangular(L, y, lower=True)\n\n            # Center the whitened vectors\n            zx_tilde = zx - np.mean(zx)\n            zy_tilde = zy - np.mean(zy)\n\n            # Compute norms\n            norm_zx = np.linalg.norm(zx_tilde)\n            norm_zy = np.linalg.norm(zy_tilde)\n\n            # Compute the phylogenetically corrected association score (Pearson correlation)\n            if norm_zx == 0 or norm_zy == 0:\n                r = 0.0\n            else:\n                numerator = np.dot(zx_tilde, zy_tilde)\n                denominator = norm_zx * norm_zy\n                r = numerator / denominator\n            \n            r_scores.append(r)\n\n        # Compute the confidence interval using type-7 quantiles\n        # np.quantile with interpolation='linear' implements type-7\n        lower_bound = np.quantile(r_scores, q_low, interpolation='linear')\n        upper_bound = np.quantile(r_scores, q_high, interpolation='linear')\n        \n        results.append([round(lower_bound, 6), round(upper_bound, 6)])\n\n    # Format the final output string\n    output_str = \"[[\" + \"],[\".join([\",\".join([f\"{v:.6f}\" for v in r]) for r in results]) + \"]]\"\n    print(output_str)\n\nsolve()\n```", "id": "4375055"}, {"introduction": "典型的系统发育谱分析研究涉及数百万对基因的成对检验，这带来了严峻的多重假设检验问题。简单地挑选得分高或$p$值低的基因对在统计上是不可靠的，会导致极高的假阳性率。这项练习 [@problem_id:4374991] 聚焦于数据分析流程中这关键的最后一步，它要求您深入思考，在基因组数据复杂的依赖结构下，为了正确应用Benjamini-Hochberg程序来控制伪发现率（False Discovery Rate, FDR），必须满足哪些前提条件。", "problem": "在功能注释的系统发育谱分析中，假设有 $G$ 个基因和 $S$ 个物种。对于每个基因，观察其在 $S$ 个物种中的二元存在或缺失谱。为了识别候选的功能关系，对所有无序基因对进行共现的成对检验，从而产生 $m = G(G - 1)/2$ 个假设检验和相关的 $p$ 值。目标是将错误发现率（FDR）控制在目标水平 $\\alpha$。\n\n从第一性原理出发，使用核心定义和经过充分检验的事实来推断，在应用 Benjamini–Hochberg (BH) 程序时，为了有效控制 FDR 需要满足哪些条件。具体来说，考虑 $p$ 值之间的依赖性是如何产生的，因为每个检验都重复使用了相同的 $S$ 个物种，并且存在-缺失模式可能受系统发育结构的影响；并考虑这种依赖性是否与已知的 BH FDR 控制的充分条件兼容。\n\n选择一个选项，该选项正确地提出一个基于 BH 的程序来将 FDR 控制在水平 $\\alpha$，并提供一组科学上合理的假设，在这些假设下，该程序在系统发育谱分析的背景下是有效的。\n\nA. 使用一种共现检验，该检验通过对边缘进行条件化并尊重系统发育结构（例如，包含物种系统发育协方差的参数模型，或在分支内约束的置换方案，以使零假设下的可交换性得以保持）来产生有效的零假设 $p$ 值。然后将升阶 Benjamini–Hochberg 法则应用于排序后的 $p$ 值。通过援引以下要求来证明其有效性：零假设 $p$ 值是超均匀的，并且真实零假设间的 $p$ 值依赖性是子集正回归依赖（PRDS），当检验统计量是给定边缘下，底层存在-缺失计数的坐标单调非减函数时，该条件得到满足，因此 BH 将 FDR 控制在水平 $\\alpha$。\n\nB. 将 Benjamini–Hochberg 法则直接应用于所有 $m$ 个 $p$ 值，这些 $p$ 值是通过对原始存在-缺失表进行未经调整的 Fisher 精确检验计算得出的，忽略系统发育的非独立性，并断言无论检验之间存在何种依赖性，BH 都能控制 FDR。\n\nC. 用 Benjamini–Yekutieli (BY) 程序替换 Benjamini–Hochberg 法则，BY 程序能在任意依赖性下控制 FDR，并声称这是一种在存在系统发育引起的依赖性时“使用 BH”来控制 FDR 的可接受方法。\n\nD. 应用加权的 Benjamini–Hochberg 程序，使用的权重是根据观察到的每个基因在 $S$ 个物种中存在的数量构建的，并论证为信息量更大的基因赋予更高权重可以提高功效，同时仍然控制 FDR，因为权重是从产生 $p$ 值的同一数据中导出的。", "solution": "要评估各选项，我们必须首先理解在多重假设检验中控制错误发现率 (FDR) 的基本原则，以及 Benjamini-Hochberg (BH) 程序有效性的条件，特别是在系统发育谱分析这种存在复杂依赖结构的数据背景下。\n\n1.  **FDR 和 BH 程序**：FDR 是在所有被拒绝的假设中，错误拒绝的真实零假设所占比例的期望值。BH 程序是一种旨在控制 FDR 的标准方法，它通过将排序后的 $p_{(i)}$ 值与一个递增的阈值 $\\frac{i}{m}\\alpha$ 进行比较来工作。\n\n2.  **BH 有效性的条件**：BH 程序的有效性依赖于两个关键属性：\n    *   **有效的 $p$ 值**：对于任何真实的零假设，其对应的 $p$ 值必须服从超均匀分布（即，对于所有 $x \\in [0, 1]$，有 $P(p \\le x) \\le x$）。如果一个统计检验的假设（例如，样本独立性）被违反，其产生的 $p$ 值将是无效的，并且 FDR 控制无法得到保证。\n    *   **依赖结构**：BH 程序最初是在假设所有检验独立的条件下被证明的。随后，Benjamini 和 Yekutieli (2001) 证明，在一种称为子集正回归依赖 (PRDS) 的特定正依赖结构下，BH 程序仍然能有效控制 FDR。\n\n在系统发育谱分析的背景下，出现了两个主要的统计挑战：\n1.  **物种间的非独立性**：物种通过系统发育相关联，因此将它们视为独立观测值是错误的。使用忽略这种结构的检验（如标准的 Fisher 精确检验）会产生无效的 $p$ 值，导致假阳性率膨胀。因此，任何有效的程序都**必须**从一个能妥善考虑系统发育非独立性的统计检验开始。\n2.  **检验间的依赖性**：由于对 $(g_1, g_2)$ 和 $(g_1, g_3)$ 的检验都重复使用了基因 $g_1$ 的谱，因此这 $m$ 个假设检验本身并不独立。这种依赖结构必须符合 BH 程序的要求（例如，PRDS），才能保证 FDR 控制。对于许多基于单调统计量的检验，这个条件通常被认为是合理的。\n\n现在我们评估各个选项：\n\n**A.** 此选项正确地识别并解决了这两个核心问题。它首先要求使用一个“尊重系统发育结构”的检验来生成“有效的零假设 $p$ 值”。这是至关重要的第一步。其次，它正确地指出，在生成了有效的 $p$ 值之后，可以应用 BH 程序。最后，它提供了正确的理论依据：$p$ 值必须是超均匀的，并且检验间的依赖性需要满足 PRDS 条件，而这一条件对于许多适当构造的检验统计量是成立的。这是一个完整且统计上严谨的方案。\n\n**B.** 此选项在两个方面都是错误的。首先，它建议使用“未经调整的 Fisher 精确检验”，这会产生无效的 $p$ 值。其次，它错误地声称 BH 程序在任何依赖性下都能控制 FDR，而事实并非如此。\n\n**C.** 此选项建议使用更保守的 Benjamini-Yekutieli (BY) 程序，该程序确实能在任意依赖性下控制 FDR。然而，它未能解决更根本的问题：输入的 $p$ 值必须是有效的。将 BY 程序应用于由不考虑系统发育的检验产生的无效 $p$ 值，同样无法保证 FDR 控制。\n\n**D.** 此选项建议使用加权的 BH 程序，但提出的加权方案是有缺陷的。为了使加权 BH 程序有效，权重必须在零假设下独立于相应的 $p$ 值。根据用于计算 $p$ 值的数据特征（例如每个基因的存在数量）来确定权重，违反了这一核心要求，从而使 FDR 控制的理论保证失效。\n\n**结论**：选项 A 是唯一提出了一个完整且统计上合理的流程的选项，它既解决了生成有效 $p$ 值的必要性，也说明了在何种条件下可以应用 BH 程序来处理检验间的依赖性。", "answer": "$$\\boxed{A}$$", "id": "4374991"}]}