{"hands_on_practices": [{"introduction": "在进行任何时间校准的系统发育分析之前，一个关键的初始步骤是评估数据中是否存在足够的“时间信号”。本练习将指导您实现日期随机化检验（Date Randomization Test, DRT），这是一种评估采样时间与遗传分歧之间相关性是否显著的强大统计方法。通过这个实践[@problem_id:4374506]，您将学习如何构建一个零分布来判断观测到的进化速率是否仅仅是随机产生的，这是确保后续系统动力学建模有效性的重要保障。", "problem": "您的任务是实现一个日期随机化检验（DRT），用于在谱系动力学和病毒演化建模中评估分子钟分析的时间信号。考虑一个包含 $n = 100$ 个病毒序列的数据集，这些序列是在 $3$ 年的时间跨度内取样的。对于每个序列 $i$，您都会得到两个量：相对于一个任意起点的取样时间 $t_i$（以年为单位），以及从一个时间校准的系统发育树中测得的根到尖端遗传距离 $d_i$（以每位点替换数为单位）。在严格分子钟假设下，预期的根到尖端遗传距离与取样时间成线性关系。形式上，一个经过充分检验的模型表明\n$$\n\\mathbb{E}[d_i \\mid t_i] = r \\cdot (t_i - t_0),\n$$\n其中 $r$ 是替换速率（单位为每位点每年替换数），$t_0$ 是根节点的时间（单位与时间相同）。\n\n日期随机化检验（DRT）通过将观测到的 $r$ 估计值与一个零分布进行比较，来评估是否存在时间信号。该零分布是通过随机置换序列间的取样时间，以消除取样时间与遗传分化之间的任何关联而形成的。适用以下定义和程序：\n\n1. 从数据 $\\{(t_i, d_i)\\}_{i=1}^n$ 中得到的时钟速率 $r$ 的普通最小二乘估计值是 $d_i$ 对 $t_i$ 进行回归的斜率，由下式给出\n$$\n\\hat{r} = \\frac{\\sum_{i=1}^{n} (t_i - \\bar{t})(d_i - \\bar{d})}{\\sum_{i=1}^{n} (t_i - \\bar{t})^2},\n$$\n其中 $\\bar{t}$ 和 $\\bar{d}$ 分别是 $t_i$ 和 $d_i$ 的样本均值。\n2. 在没有时间信号的原假设下，取样时间和遗传距离是独立的，置换序列间的 $\\{t_i\\}$ 会生成估计量 $\\hat{r}$ 的零分布。通过对时间进行 $b = 1, \\dots, B$ 次独立的随机置换并计算 $\\hat{r}^{(b)}$，可以获得经验零分布。\n3. 用于检测正向时间信号的单侧p值使用置换分布计算如下：\n$$\np = \\frac{1 + \\sum_{b=1}^{B} \\mathbb{I}\\left(\\hat{r}^{(b)} \\ge \\hat{r}\\right)}{B + 1},\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。然后通过将 $p$ 与显著性阈值 $\\alpha$ 进行比较来做出检测决策；如果 $p  \\alpha$，则判定为检测到信号。\n\n您的程序必须实现上述检验，并为以下测试套件生成结果，其中的合成数据生成方式如下。对于每个测试用例，设 $t_i$ 从区间 $[0, 3]$ 年的均匀分布中独立抽取，共 $n = 100$ 个序列。设 $t_0 = -10$ 年，并根据以下公式生成根到尖端距离：\n$$\nd_i = r_{\\text{true}} \\cdot (t_i - t_0) + \\epsilon_i,\n$$\n其中 $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$ 对所有 $i$ 独立。为确保科学真实性，根到尖端距离必须为非负值；生成后，任何为负的 $d_i$ 都必须替换为一个小的正常数 $10^{-6}$（每位点替换数）。估计速率的单位必须是“每位点每年替换数”，所有输出都应表示为不带百分号的浮点数。为保证可复现性，请使用固定的伪随机数生成器种子 $12345$。\n\n测试套件参数集：\n- 情况 A（理想情况，强时间信号）：$r_{\\text{true}} = 1.0 \\times 10^{-3}$，$\\sigma = 5.0 \\times 10^{-4}$，$B = 1000$，$\\alpha = 0.05$。\n- 情况 B（弱信号）：$r_{\\text{true}} = 2.0 \\times 10^{-4}$，$\\sigma = 1.0 \\times 10^{-3}$，$B = 1000$，$\\alpha = 0.05$。\n- 情况 C（零假设，无信号）：$r_{\\text{true}} = 0$，$\\sigma = 1.0 \\times 10^{-3}$，$B = 1000$，$\\alpha = 0.05$。\n- 情况 D（边缘情况，高噪声掩盖信号）：$r_{\\text{true}} = 1.0 \\times 10^{-3}$，$\\sigma = 5.0 \\times 10^{-3}$，$B = 500$，$\\alpha = 0.05$。\n\n对于每种情况，计算：\n- 如上定义的估计时钟速率 $\\hat{r}$（单位：每位点每年替换数）。\n- 单侧置换p值 $p$。\n- 检测决策，为一个布尔值，指示是否 $p  \\alpha$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，其本身是 $[\\hat{r}, p, \\text{detected}]$ 形式的列表。例如，格式应为 $\\big[\\,[\\hat{r}_A, p_A, \\text{detected}_A], [\\hat{r}_B, p_B, \\text{detected}_B], [\\hat{r}_C, p_C, \\text{detected}_C], [\\hat{r}_D, p_D, \\text{detected}_D]\\,\\big]$，使用标准的 Python 列表语法表示。", "solution": "本解决方案详细说明了如何根据问题陈述的要求，实现一个日期随机化检验（DRT）来评估模拟病毒序列数据中的时间信号。该方法基于谱系动力学中使用的基本统计学原理。\n\n### 1. 基本原理：严格分子钟与时间信号\n\n核心假设是严格分子钟模型，该模型假定一个序列与其共同祖先的遗传分化程度与所经过的时间之间存在线性关系。对于一组序列 $\\{i\\}_{i=1}^n$，其取样时间为 $\\{t_i\\}$，根到尖端遗传距离为 $\\{d_i\\}$，预期的距离由下式给出：\n$$\n\\mathbb{E}[d_i \\mid t_i] = r \\cdot (t_i - t_0)\n$$\n在此，$r$ 是恒定的替换速率（“时钟速率”），$t_0$ 是最近共同祖先的时间（系统发育树的根节点）。如果 $d_i$ 和 $t_i$ 之间存在统计上显著的正相关性，则存在“时间信号”，这意味着时钟速率 $r$ 可测量地大于零。\n\n### 2. 日期随机化检验（DRT）\n\nDRT 是一种基于置换的方法，用于检验不存在时间信号（$r = 0$）的原假设 $H_0$。这等同于陈述遗传距离 $d_i$ 和取样时间 $t_i$ 是独立的。检验过程如下：\n\n- **检验统计量**：时间信号的强度由估计的时钟速率 $\\hat{r}$ 来量化。它被计算为 $d_i$ 对 $t_i$ 进行普通最小二乘（OLS）线性回归的斜率。该估计量的公式为：\n$$\n\\hat{r} = \\frac{\\sum_{i=1}^{n} (t_i - \\bar{t})(d_i - \\bar{d})}{\\sum_{i=1}^{n} (t_i - \\bar{t})^2}\n$$\n其中 $\\bar{t}$ 和 $\\bar{d}$ 分别是时间和距离的样本均值。一个较大的正值 $\\hat{r}$ 表明存在强时间信号。\n\n- **零分布**：为了确定观测到的 $\\hat{r}$ 是否具有统计显著性，需要将其与一个零分布进行比较。这个分布是通过打破时间与距离之间的真实关联来生成的。对于大量的置换，$b = 1, \\dots, B$：\n    1. 将取样时间集合 $\\{t_i\\}$ 随机打乱，创建一个置换后的集合 $\\{t_i^{(b)}\\}$。\n    2. 保持遗传距离 $\\{d_i\\}$ 的原始顺序。\n    3. 使用置换后的时间 $\\{t_i^{(b)}\\}$ 和原始距离 $\\{d_i\\}$ 计算一个新的速率 $\\hat{r}^{(b)}$。\n这些速率的集合 $\\{\\hat{r}^{(b)}\\}$ 构成了在 $H_0$ 下速率估计量的经验零分布。\n\n- **P值与决策**：单侧p值是在原假设下观测到至少与实际观测值 $\\hat{r}$ 一样大的速率的概率，其计算方式如下：\n$$\np = \\frac{1 + \\sum_{b=1}^{B} \\mathbb{I}\\left(\\hat{r}^{(b)} \\ge \\hat{r}\\right)}{B + 1}\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。在分子和分母中包含 $1$ 是为了计入观测统计量本身，并防止p值为 $0$。如果该p值小于预定义的显著性水平 $\\alpha$（即 $p  \\alpha$），则“检测到”时间信号。\n\n### 3. 实现与算法设计\n\n该解决方案使用 Python 的 `numpy` 库实现。所有随机过程均使用一个以 $12345$ 为种子的伪随机数生成器，以确保完全的可复现性。\n\n**步骤1：数据模拟**\n为四个测试用例中的每一个生成一个包含 $n=100$ 个序列的合成数据集。\n- 使用一个以种子 $12345$ 初始化的 `numpy.random.Generator` 实例。\n- 取样时间 $t_i$ 从区间 $[0, 3]$ 上的均匀分布中抽取。\n- 高斯噪声项 $\\epsilon_i$ 从 $\\mathcal{N}(0, \\sigma^2)$ 中抽取，其中 $\\sigma$ 特定于该测试用例。\n- 遗传距离计算为 $d_i = r_{\\text{true}} \\cdot (t_i - t_0) + \\epsilon_i$，其中 $r_{\\text{true}}$ 是该用例的真实时钟速率，$t_0 = -10$。\n- 为了强制物理真实性，任何得到的负距离 $d_i$ 都会被下限裁剪为一个小的正值 $10^{-6}$。\n\n**步骤2：估计与置换**\n一个单独的函数处理每个测试用例。\n- 它首先使用 OLS 公式从模拟的 $(t_i, d_i)$ 对中计算观测速率 $\\hat{r}$。\n- 然后它进入一个进行 $B$ 次迭代的循环（根据用例，$B$ 为 $1000$ 或 $500$）。在每次迭代中，它对时间向量 $t$ 调用生成器的 `permutation` 方法，并重新计算速率，以构建零分布 $\\{\\hat{r}^{(b)}\\}$。\n\n**步骤3：最终计算**\n- 在置换循环之后，通过计算大于或等于观测速率 $\\hat{r}$ 的零分布速率数量，并应用指定公式来计算p值 $p$。\n- 通过将 $p$ 与给定的 $\\alpha$ 值 $0.05$ 进行比较，做出布尔型的检测决策。\n- 收集每个用例的结果—$[\\hat{r}, p, \\text{detected}]$。\n\n**步骤4：输出格式化**\n将最终的结果列表转换为所需的字符串表示形式（一种标准的 Python 列表的列表格式），并打印到标准输出。这种结构化方法确保了复杂的统计过程被转化为一个正确且可验证的计算算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Date Randomization Test (DRT) for assessing temporal signal\n    in simulated viral evolution data, as per the problem specification.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Format: (r_true, sigma, B, alpha)\n    test_cases = [\n        (1.0e-3, 5.0e-4, 1000, 0.05),  # Case A: Strong signal\n        (2.0e-4, 1.0e-3, 1000, 0.05),  # Case B: Weak signal\n        (0.0, 1.0e-3, 1000, 0.05),     # Case C: Null, no signal\n        (1.0e-3, 5.0e-3, 500, 0.05),    # Case D: High noise\n    ]\n\n    # Initialize a single pseudo-random number generator for reproducibility.\n    # All random aspects of the simulation will use this generator instance.\n    rng = np.random.default_rng(12345)\n\n    # General parameters\n    n = 100          # Number of sequences\n    t0 = -10.0       # Time of the root in years\n    t_span_max = 3.0 # Sampling time upper bound in years\n    d_min = 1e-6     # Minimum allowed genetic distance\n\n    results = []\n    \n    def calculate_rate(times, distances):\n        \"\"\"\n        Calculates the OLS slope (rate) of distances regressed on times.\n        \"\"\"\n        t_mean = np.mean(times)\n        d_mean = np.mean(distances)\n        \n        # Denominator of OLS slope formula. Handle case of zero variance in times.\n        # This is extremely unlikely with float uniform random numbers but is good practice.\n        t_var_sum = np.sum((times - t_mean)**2)\n        if t_var_sum == 0:\n            return 0.0\n        \n        # Numerator of OLS slope formula\n        td_cov_sum = np.sum((times - t_mean) * (distances - d_mean))\n        \n        return td_cov_sum / t_var_sum\n\n    for r_true, sigma, B, alpha in test_cases:\n        # Step 1: Generate synthetic data for the current test case\n        # Sampling times t_i are drawn from a uniform distribution.\n        t = rng.uniform(low=0.0, high=t_span_max, size=n)\n\n        # Error terms epsilon_i are drawn from a normal distribution.\n        epsilon = rng.normal(loc=0.0, scale=sigma, size=n)\n\n        # Generate root-to-tip distances d_i based on the strict clock model.\n        d = r_true * (t - t0) + epsilon\n\n        # Enforce non-negativity constraint for genetic distances.\n        d[d  0] = d_min\n        \n        # Step 2: Calculate the observed clock rate\n        r_hat = calculate_rate(t, d)\n        \n        # Step 3: Perform the permutation test\n        null_rates = np.empty(B)\n        for i in range(B):\n            # Permute the sampling times randomly.\n            t_permuted = rng.permutation(t)\n            # Calculate the rate for the permuted data.\n            # This builds the null distribution.\n            null_rates[i] = calculate_rate(t_permuted, d)\n            \n        # Step 4: Compute the one-sided p-value and make a decision\n        # Count how many null rates are greater than or equal to the observed rate.\n        count_ge = np.sum(null_rates >= r_hat)\n        \n        # Calculate p-value. The +1s account for the observed statistic.\n        p_value = (1.0 + count_ge) / (B + 1.0)\n        \n        # Decision: A temporal signal is detected if p  alpha.\n        detected = p_value  alpha\n        \n        results.append([r_hat, p_value, detected])\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists is desired.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4374506"}, {"introduction": "系统动力学推断的核心在于计算在特定人口模型下系统发育树的似然性。本练习将从第一性原理出发，推导并实现一个基于溯祖理论的似然函数，该函数针对一个简单的指数增长人口模型。通过这个练习[@problem_id:4374502]，您将深入理解如何将非齐次泊松过程的理论应用于溯祖事件，并将合并风险（hazard）和区间生存概率（survival probability）这两个核心概念转化为可计算的对数似然值，这构成了许多贝叶斯系统动力学软件的基础。", "problem": "给定一个等时性的、有时间刻度的系统发育树，所有样本均在当前时间采集，且所有溯祖事件的时间已知。考虑在指数增长模型下，具有时变有效种群大小的 Kingman 溯祖模型。令 $t \\ge 0$ 表示从现在开始以年为单位回溯计算的时间。假设有效种群大小轨迹为 $N_{e}(t) = N_{e0} \\exp(- r t)$，其中增长率 $r$ 的单位是 $\\text{year}^{-1}$，当前时间的有效种群大小 $N_{e0}$ 的单位是个体。该系统发育树有 $n$ 个叶尖，于时间 $t=0$ 采样，并且 $n-1$ 个内部节点（溯祖事件）发生在严格递增的时间点 $0  t_1  t_2  \\dots  t_{n-1}$（单位为距今的年数）。在回溯时间 $t \\in [t_{i-1}, t_{i})$（其中 $t_0 = 0$），共有 $k_i = n - (i-1)$ 个谱系。\n\n任务：仅从以下两个基本事实出发：\n- 在具有时变有效种群大小 $N_{e}(t)$ 的 Kingman 溯祖模型中，当存在 $k$ 个谱系时，瞬时总溯祖风险率是二项式系数 $\\binom{k}{2}$ 除以 $N_{e}(t)$，以及\n- 对于风险率为 $h(t)$ 的非齐次泊松过程，在一个区间上的事件时间密度结合了生存因子 $\\exp\\!\\left(- \\int h(u)\\,du \\right)$ 和在事件时间点评估的风险率，\n推导在模型 $N_{e}(t) = N_{e0} \\exp(- r t)$ 下，给定树的溯祖对数似然，并将其表示为 $r$ 和 $N_{e0}$ 的函数。您的推导应清楚说明需要哪些从树中提取的量以及它们如何组合，并且应明确处理边界情况 $r = 0$ 作为指数模型的极限情况。\n\n然后，实现一个程序，为几个指定的测试用例计算自然对数似然（一个无量纲的实数）。每个测试用例提供：叶尖数量 $n$、严格递增的溯祖时间列表 $[t_1, \\dots, t_{n-1}]$（单位为距今的年数）、增长率 $r$（单位为 $\\text{year}^{-1}$）以及 $N_{e0}$（单位为个体）。您的程序必须：\n- 仅使用上述原理和您推导的表达式来计算对数似然，\n- 使用您公式的显式极限来处理 $r = 0$ 的情况，\n- 假设所有时间的单位是年，$r$ 的单位是 $\\text{year}^{-1}$，$N_{e0}$ 的单位是个体，\n- 返回一个包含每个测试用例的对数似然的浮点数列表。\n\n此外，在您的推导中指出，对于该模型，树的哪些统计量是评估似然的充分统计量。\n\n在您的程序中实现的测试套件（不读取输入）：\n- 用例 A（一般情况）：$n = 5$，时间 $[0.2, 0.5, 1.1, 1.8]$，$r = 0.5$，$N_{e0} = 8000$。\n- 用例 B（边界情况 $r=0$）：$n = 5$，时间 $[0.2, 0.5, 1.1, 1.8]$，$r = 0.0$，$N_{e0} = 8000$。\n- 用例 C（谱系少，中度增长）：$n = 3$，时间 $[0.1, 2.0]$，$r = 0.2$，$N_{e0} = 1000$。\n- 用例 D（负增长参数，即顺时间增长）：$n = 4$，时间 $[0.05, 0.07, 0.09]$，$r = -0.1$，$N_{e0} = 2000$。\n- 用例 E（较大的正 $r$）：$n = 4$，时间 $[0.3, 0.6, 1.2]$，$r = 1.5$，$N_{e0} = 500$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[resultA,resultB,resultC,resultD,resultE]”）。每个结果必须是对应测试用例的自然对数似然值，顺序与上面列出的一致。不应打印单位，也不应输出任何额外文本。", "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n- **模型：** 具有时变有效种群大小 $N_{e}(t)$ 的 Kingman 溯祖模型。\n- **种群大小轨迹：** $N_{e}(t) = N_{e0} \\exp(-r t)$，其中 $t \\ge 0$ 是从现在开始以年为单位回溯计算的时间。$N_{e0}$ 是当前时间的有效种群大小，$r$ 是指数增长率，单位为 $\\text{year}^{-1}$。\n- **系统发育树数据：** 一个等时性的、有时间刻度的系统发育树，有 $n$ 个叶尖，于 $t=0$ 采样。\n- **溯祖时间：** 一组 $n-1$ 个严格递增的事件时间：$0  t_1  t_2  \\dots  t_{n-1}$（单位为距今的年数）。\n- **谱系数量：** 在任何回溯时间区间 $[t_{i-1}, t_i)$（其中 $t_0 = 0$），共有 $k_i = n - (i-1)$ 个谱系。\n- **基本事实 1：** 对于 $k$ 个谱系，瞬时总溯祖风险率是 $\\lambda_k(t) = \\binom{k}{2} / N_e(t)$。\n- **基本事实 2：** 对于风险率为 $h(t)$ 的非齐次泊松过程，事件时间的概率密度函数是事件时间点的风险率与生存因子的乘积：$p(t) = h(t) \\exp\\left(-\\int_{t_{start}}^{t} h(u)\\,du \\right)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题基于 Kingman 溯祖模型，这是种群遗传学和系统发育动力学中的一个基本框架。有效种群大小的指数增长模型是一个标准且特性明确的模型。非齐次泊松过程中风险率和似然之间的关系是概率论的核心概念。该问题在科学和数学上是合理的。\n- **良态问题：** 该问题提供了推导对数似然函数所需的所有定义、常数和数据。它要求为确定的输入提供一个特定的输出（对数似然值），使得目标清晰且可在计算上求解。\n- **客观性：** 该问题以精确的数学和科学语言陈述，没有主观性或歧义。\n- **完整性与一致性：** 给定的条件是自洽且一致的。$N_e(t)$、溯祖风险率和似然密度的定义是标准的且相互兼容。\n- **所有其他标准均已满足：** 该问题是可形式化的、现实的、结构良好的且可验证的。\n\n### 步骤 3：结论与行动\n该问题有效。将提供一个完整的、有理有据的解决方案。\n\n## 溯祖对数似然的推导\n\n观测到给定溯祖时间集合 $\\{t_1, \\dots, t_{n-1}\\}$ 的似然是对于每个区间 $[t_{i-1}, t_i)$ 两类事件概率的乘积：(1) 在开区间 $(t_{i-1}, t_i)$ 内没有溯祖事件发生，以及 (2) 在时间 $t_i$ 发生一个溯祖事件。这由非齐次泊松过程的理论所支配。\n\n**1. 定义风险函数**\n时间从现在（$t=0$）开始回溯计算。在区间 $[t_{i-1}, t_i)$ 内，有 $k_i = n-(i-1)$ 个谱系。根据问题陈述，瞬时溯祖风险率为：\n$$ \\lambda_{k_i}(t) = \\frac{\\binom{k_i}{2}}{N_e(t)} $$\n代入有效种群大小的模型 $N_e(t) = N_{e0} \\exp(-rt)$，我们得到：\n$$ \\lambda_{k_i}(t) = \\frac{\\binom{k_i}{2}}{N_{e0} \\exp(-rt)} = \\frac{\\binom{k_i}{2}}{N_{e0}} e^{rt} $$\n\n**2. 构建每个区间的似然贡献**\n使用所提供的关于非齐次泊松过程事件时间密度的规则，观测到第 $i$ 个溯祖事件发生在时间 $t_i$，且以在 $[t_{i-1}, t_i)$ 内没有事件发生为条件的似然贡献是：\n$$ L_i = \\lambda_{k_i}(t_i) \\exp\\left( - \\int_{t_{i-1}}^{t_i} \\lambda_{k_i}(u) \\, du \\right) $$\n\n**3. 构建总对数似然**\n整棵树的总似然是来自每个溯祖事件的似然贡献的乘积，因为这些事件是条件独立的：\n$$ L = \\prod_{i=1}^{n-1} L_i $$\n总对数似然 $\\mathcal{L} = \\ln(L)$ 是各个对数似然的和：\n$$ \\mathcal{L} = \\sum_{i=1}^{n-1} \\ln(L_i) = \\sum_{i=1}^{n-1} \\left[ \\ln(\\lambda_{k_i}(t_i)) - \\int_{t_{i-1}}^{t_i} \\lambda_{k_i}(u) \\, du \\right] $$\n这将对数似然分为两个部分：在事件时间点上评估的对数风险率之和，以及在等待区间上的积分风险率之和。\n\n**4. 情况 1：一般情况 ($r \\neq 0$)**\n我们评估对数似然的两个组成部分。\n\n*   **对数风险率部分：**\n    $$ \\sum_{i=1}^{n-1} \\ln(\\lambda_{k_i}(t_i)) = \\sum_{i=1}^{n-1} \\ln\\left( \\frac{\\binom{k_i}{2}}{N_{e0}} e^{rt_i} \\right) = \\sum_{i=1}^{n-1} \\left[ \\ln\\binom{k_i}{2} - \\ln(N_{e0}) + rt_i \\right] $$\n    $$ = \\left( \\sum_{i=1}^{n-1} \\ln\\binom{k_i}{2} \\right) - (n-1)\\ln(N_{e0}) + r \\sum_{i=1}^{n-1} t_i $$\n\n*   **积分风险率部分：**\n    $$ \\int_{t_{i-1}}^{t_i} \\lambda_{k_i}(u) \\, du = \\int_{t_{i-1}}^{t_i} \\frac{\\binom{k_i}{2}}{N_{e0}} e^{ru} \\, du = \\frac{\\binom{k_i}{2}}{N_{e0}} \\left[ \\frac{e^{ru}}{r} \\right]_{t_{i-1}}^{t_i} = \\frac{\\binom{k_i}{2}}{rN_{e0}} (e^{rt_i} - e^{rt_{i-1}}) $$\n    总积分风险率是所有区间的总和：\n    $$ \\sum_{i=1}^{n-1} \\int_{t_{i-1}}^{t_i} \\lambda_{k_i}(u) \\, du = \\frac{1}{rN_{e0}} \\sum_{i=1}^{n-1} \\binom{k_i}{2} (e^{rt_i} - e^{rt_{i-1}}) $$\n\n*   **$r \\neq 0$ 的完整对数似然：**\n    结合这两个部分得到最终表达式：\n    $$ \\mathcal{L}(r, N_{e0}) = \\left(\\sum_{i=1}^{n-1} \\ln\\binom{k_i}{2}\\right) - (n-1)\\ln(N_{e0}) + r\\sum_{i=1}^{n-1} t_i - \\frac{1}{rN_{e0}} \\sum_{i=1}^{n-1} \\binom{k_i}{2} (e^{rt_i} - e^{rt_{i-1}}) $$\n\n**5. 情况 2：边界情况 ($r = 0$)**\n当 $r=0$ 时，种群大小是恒定的：$N_e(t) = N_{e0}$。在每个有 $k_i$ 个谱系的区间内，风险率也是恒定的：$\\lambda_{k_i}(t) = \\binom{k_i}{2} / N_{e0}$。\n\n*   **对数风险率部分：**\n    $$ \\sum_{i=1}^{n-1} \\ln(\\lambda_{k_i}(t_i)) = \\sum_{i=1}^{n-1} \\ln\\left( \\frac{\\binom{k_i}{2}}{N_{e0}} \\right) = \\left(\\sum_{i=1}^{n-1} \\ln\\binom{k_i}{2}\\right) - (n-1)\\ln(N_{e0}) $$\n\n*   **积分风险率部分：**\n    $$ \\int_{t_{i-1}}^{t_i} \\lambda_{k_i}(u) \\, du = \\int_{t_{i-1}}^{t_i} \\frac{\\binom{k_i}{2}}{N_{e0}} \\, du = \\frac{\\binom{k_i}{2}}{N_{e0}} (t_i - t_{i-1}) $$\n    总积分风险率为：\n    $$ \\sum_{i=1}^{n-1} \\frac{\\binom{k_i}{2}}{N_{e0}} (t_i - t_{i-1}) = \\frac{1}{N_{e0}} \\sum_{i=1}^{n-1} \\binom{k_i}{2} (t_i - t_{i-1}) $$\n\n*   **$r = 0$ 的完整对数似然：**\n    $$ \\mathcal{L}(0, N_{e0}) = \\left(\\sum_{i=1}^{n-1} \\ln\\binom{k_i}{2}\\right) - (n-1)\\ln(N_{e0}) - \\frac{1}{N_{e0}} \\sum_{i=1}^{n-1} \\binom{k_i}{2} (t_i - t_{i-1}) $$\n\n**6. 一致性检验：$r \\to 0$ 的极限**\n为确保一致性，我们取通用公式 $\\mathcal{L}(r, N_{e0})$ 在 $r \\to 0$ 时的极限。关键项是积分风险率。我们对小 $x$ 使用泰勒展开 $e^x \\approx 1+x$：\n$$ \\lim_{r\\to 0} \\frac{1}{rN_{e0}} \\sum_{i=1}^{n-1} \\binom{k_i}{2} (e^{rt_i} - e^{rt_{i-1}}) $$\n$$ = \\lim_{r\\to 0} \\frac{1}{rN_{e0}} \\sum_{i=1}^{n-1} \\binom{k_i}{2} ((1+rt_i) - (1+rt_{i-1}) + O(r^2)) $$\n$$ = \\lim_{r\\to 0} \\frac{1}{rN_{e0}} \\sum_{i=1}^{n-1} \\binom{k_i}{2} (r(t_i - t_{i-1}) + O(r^2)) $$\n$$ = \\frac{1}{N_{e0}} \\sum_{i=1}^{n-1} \\binom{k_i}{2} (t_i - t_{i-1}) $$\n当 $r \\to 0$ 时，项 $r \\sum t_i \\to 0$。因此，通用表达式的极限等于专门为 $r=0$ 推导的表达式，从而证实了公式的正确性。\n\n**7. 充分统计量**\n要评估对数似然，需要样本数 $n$ 和完整的溯祖时间集合 $\\{t_1, t_2, \\dots, t_{n-1}\\}$。表达式中包含的求和项依赖于每个单独的 $t_i$ 和相应的区间长度 $(t_i - t_{i-1})$，这些不能被简化为更小的摘要统计量（例如仅时间的总和或总树高）。因此，对于此模型，数据对 $(n, \\{t_1, \\dots, t_{n-1}\\})$ 构成了该树的充分统计量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_log_likelihood(n: int, times: list[float], r: float, Ne0: float) -> float:\n    \"\"\"\n    Computes the coalescent log-likelihood for a dated phylogeny under an exponential growth model.\n\n    Args:\n        n: The number of tips in the phylogeny.\n        times: A list of n-1 strictly increasing coalescent event times before present.\n        r: The exponential growth rate (r > 0 for population decline backwards in time).\n        Ne0: The effective population size at present (t=0).\n\n    Returns:\n        The natural log-likelihood.\n    \"\"\"\n    if n  2:\n        return 0.0\n\n    num_coalescent_events = n - 1\n    # Prepend t_0 = 0 to the list of coalescent times.\n    all_times = [0.0] + times\n\n    # --- Term 1: Sum of log-hazards at event times ---\n    # This term is of the form:\n    # sum(ln(C(k_i, 2))) - (n-1)*ln(Ne0) + r*sum(t_i)\n    \n    # Calculate sum(ln(C(k_i, 2)))\n    sum_log_binom_k_2 = 0.0\n    for i in range(1, num_coalescent_events + 1):\n        # In the interval [t_{i-1}, t_i), there are k_i = n - (i-1) lineages.\n        k_i = n - (i - 1)\n        binom_k_2 = k_i * (k_i - 1) / 2.0\n        # If binom_k_2 is 0 or less (e.g., k_i  2), its log is -inf.\n        # This only happens if n  2, handled at start.\n        sum_log_binom_k_2 += np.log(binom_k_2)\n\n    # Calculate r * sum(t_i)\n    sum_of_times = sum(times)\n    r_sum_t = r * sum_of_times\n\n    log_hazard_term = sum_log_binom_k_2 - num_coalescent_events * np.log(Ne0) + r_sum_t\n\n    # --- Term 2: Sum of integrated hazards over intervals ---\n    # This term is subtracted from Term 1.\n    \n    # This will hold sum( C(k_i, 2) * (t_i - t_{i-1}) ) for r=0\n    # or sum( C(k_i, 2) * (exp(r*t_i) - exp(r*t_{i-1})) ) for r!=0\n    integrated_hazard_sum_raw = 0.0\n\n    if r == 0.0:\n        # Constant population size case\n        for i in range(1, num_coalescent_events + 1):\n            k_i = n - (i - 1)\n            binom_k_2 = k_i * (k_i - 1) / 2.0\n            t_curr = all_times[i]\n            t_prev = all_times[i-1]\n            interval_length = t_curr - t_prev\n            integrated_hazard_sum_raw += binom_k_2 * interval_length\n        integrated_hazard_term = integrated_hazard_sum_raw / Ne0\n    else:\n        # Exponential growth/decline case\n        for i in range(1, num_coalescent_events + 1):\n            k_i = n - (i - 1)\n            binom_k_2 = k_i * (k_i - 1) / 2.0\n            t_curr = all_times[i]\n            t_prev = all_times[i-1]\n            integrated_hazard_sum_raw += binom_k_2 * (np.exp(r * t_curr) - np.exp(r * t_prev))\n        integrated_hazard_term = integrated_hazard_sum_raw / (r * Ne0)\n    \n    # Final log-likelihood is Term 1 - Term 2\n    log_likelihood = log_hazard_term - integrated_hazard_term\n    \n    return log_likelihood\n\n\ndef solve():\n    \"\"\"\n    Solves for the log-likelihood for the predefined test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (general)\n        {'n': 5, 'times': [0.2, 0.5, 1.1, 1.8], 'r': 0.5, 'Ne0': 8000},\n        # Case B (boundary r=0)\n        {'n': 5, 'times': [0.2, 0.5, 1.1, 1.8], 'r': 0.0, 'Ne0': 8000},\n        # Case C (few lineages, moderate growth)\n        {'n': 3, 'times': [0.1, 2.0], 'r': 0.2, 'Ne0': 1000},\n        # Case D (negative growth parameter)\n        {'n': 4, 'times': [0.05, 0.07, 0.09], 'r': -0.1, 'Ne0': 2000},\n        # Case E (large positive r)\n        {'n': 4, 'times': [0.3, 0.6, 1.2], 'r': 1.5, 'Ne0': 500},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_log_likelihood(case['n'], case['times'], case['r'], case['Ne0'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.8f}' for res in results)}]\")\n\nsolve()\n```", "id": "4374502"}, {"introduction": "真实世界中的病毒种群历史往往比简单的指数增长模型更为复杂。为了捕捉这些动态变化，研究人员常常使用分段式的非参数模型，例如“天际线图”（skyline plots）。本练习[@problem_id:4374557]将前一个练习中的似然计算框架扩展到一个更灵活的分段指数模型，并考虑了非等时采样（heterochronous sampling）的情况。您将学习如何处理跨越不同人口规模区间的积分，并为能够重构更复杂人口动态历史的非参数模型构建似然函数。", "problem": "给定一个有时标的系统发育树，其被总结为一系列事件时间和事件类型，以及一个随时间分段指数变化的有效种群大小函数。考虑标准的 Kingman 溯祖模型，并将其视为一个在回溯时间上的非齐次泊松点过程。现存谱系的数量仅在事件（取样或溯祖）发生时改变，在事件之间保持恒定。有效种群大小函数被指定为覆盖从现在开始的整个回溯时间窗口的分段指数片段。任务是计算在该模型下观测到的溯祖事件时间的对数似然。\n\n从溯祖理论和点过程的基本原理出发。使用以下基础，不要引入任何目标公式：\n- Kingman 溯祖理论指出，当在回溯时间 $t$ 有 $k$ 个现存谱系时，任何一对谱系发生溯祖的瞬时速率是有效种群大小的倒数，总溯祖风险率由无序谱系对的数量与该单位对速率的乘积给出。这产生了一个基于模型定义的时变事件强度。\n- 对于非齐次泊松过程，在某个窗口内观测到特定事件时间的似然，源于具有时变强度的点过程似然的一般定义，该定义结合了事件点上的累积项和无事件区间上的生存因子。\n\n分段指数有效种群大小由索引为 $j$ 的片段定义，每个片段都有一个开始时间 $s_j$、结束时间 $s_{j+1}$、在时间 $s_j$ 的基础水平 $N_j$ 以及片段内的恒定增长率 $g_j$。对于 $t \\in [s_j, s_{j+1})$，定义\n$$\nN_e(t) = N_j \\,\\exp\\!\\big(g_j \\,(t - s_j)\\big).\n$$\n假设所有的 $N_j$ 都严格为正，并且所有片段共同覆盖了事件列表所需的完整时间范围。时间以年为单位，输出的对数似然必须以奈特（nats）为单位报告。\n\n事件以从现在 ($t=0$) 开始的回溯时间中的一个有序时间集合 $t_1  t_2  \\dots  t_m$ 的形式给出，其类型为“取样 (sample)”或“溯祖 (coal)”。$t=0$ 时的初始现存谱系数量是单独提供的。在事件之间，谱系数量 $k(t)$ 保持不变；在取样事件发生时，$k(t)$ 在事件时间之后立即增加 1；在溯祖事件发生时，$k(t)$ 在事件时间之后立即减少 1。只有溯祖事件对似然函数贡献点质量项；取样事件修改 $k(t)$，从而改变事件之间的强度。程序必须：\n- 根据所述原理，推导出给定分段指数 $N_e(t)$ 时观测到的溯祖事件的对数似然的正确表达式，并仔细考虑事件之间的强度以及在溯祖时间的点贡献。\n- 对每个 $k(t)$ 恒定的区间上关于 $1/N_e(t)$ 的时间积分进行稳健的数值评估，包括跨越片段边界的区间和零增长率 ($g_j = 0$) 的特殊情况。\n\n使用以下测试套件，所有时间单位为年，所有对数似然输出单位为奈特：\n- 测试用例 1 (恒定有效种群大小):\n  - 片段: 一个片段， $s_0 = 0$, $s_1 = 3.0$, $N_0 = 10000$, $g_0 = 0$。\n  - 初始谱系: $k(0) = 4$。\n  - 事件: $(0.5,\\text{溯祖})$, $(1.0,\\text{溯祖})$, $(2.0,\\text{溯祖})$。\n- 测试用例 2 (跨越增长率边界):\n  - 片段: 两个片段， $s_0 = 0$, $s_1 = 1.0$, $s_2 = 3.0$, $N_0 = 8000$, $g_0 = 0.3$，以及 $N_1 = N_0 \\exp\\!\\big(g_0 (s_1-s_0)\\big)$, $g_1 = -0.2$。\n  - 初始谱系: $k(0) = 5$。\n  - 事件: $(0.8,\\text{溯祖})$, $(1.5,\\text{溯祖})$, $(2.2,\\text{溯祖})$, $(2.7,\\text{溯祖})$。\n- 测试用例 3 (事件恰好发生在片段边界上):\n  - 片段: 两个片段， $s_0 = 0$, $s_1 = 1.0$, $s_2 = 2.0$, $N_0 = 12000$, $g_0 = 0$，以及 $N_1 = N_0 \\exp\\!\\big(g_0 (s_1-s_0)\\big)$, $g_1 = 0.5$。\n  - 初始谱系: $k(0) = 3$。\n  - 事件: $(1.0,\\text{溯祖})$, $(1.8,\\text{溯祖})$。\n- 测试用例 4 (异时取样):\n  - 片段: 两个片段， $s_0 = 0$, $s_1 = 2.0$, $s_2 = 4.0$, $N_0 = 6000$, $g_0 = -0.1$，以及 $N_1 = N_0 \\exp\\!\\big(g_0 (s_1-s_0)\\big)$, $g_1 = 0$。\n  - 初始谱系: $k(0) = 2$。\n  - 事件: $(0.5,\\text{溯祖})$, $(0.7,\\text{取样})$, $(0.9,\\text{溯祖})$, $(1.3,\\text{取样})$, $(2.8,\\text{溯祖})$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），每个条目是相应测试用例计算出的对数似然，以奈特为单位表示为浮点数。程序不应读取用户输入；所有参数都必须嵌入到程序中。", "solution": "用户的问题是在 Kingman 溯祖模型下，计算一系列溯祖事件的对数似然，其中有效种群大小 $N_e(t)$ 是回溯时间 $t$ 的分段指数函数。该问题定义明确，在系统发育动力学的既定原则上具有科学依据，并为唯一解提供了所有必要的数据。我们接下来进行推导和实现。\n\n### 基于原理的对数似然推导\n\n标准的 Kingman 溯祖过程可以被建模为一个非齐次泊松点过程。这个过程的“事件”就是溯祖事件。在回溯时间 $t$ ，该过程的时变强度或速率（记为 $\\lambda(t)$）由两个因素决定：从当前存在的谱系中选择一对的方式数量，以及任何单对谱系发生溯祖的速率。\n\n令 $k(t)$ 为时间 $t$ 的现存谱系数量。不同谱系对的数量由二项式系数 $\\binom{k(t)}{2}$ 给出。任何特定谱系对的溯祖速率为 $\\frac{1}{N_e(t)}$，其中 $N_e(t)$ 是时间 $t$ 的有效种群大小。因此，任何溯祖事件的总瞬时速率是这两个因素的乘积：\n$$\n\\lambda(t) = \\binom{k(t)}{2} \\frac{1}{N_e(t)}\n$$\n为使此速率为正，必须有 $k(t) \\ge 2$。如果 $k(t)  2$，则速率 $\\lambda(t)$ 为 0。\n\n在时间区间 $[0, T]$ 内，对于一个速率为 $\\lambda(t)$ 的非齐次泊松过程，观测到在时间 $t_1, t_2, \\ldots, t_n$ 发生事件的特定实现的似然由点过程似然的通用公式给出：\n$$\nL = \\left( \\prod_{i=1}^{n} \\lambda(t_i) \\right) \\exp\\left( - \\int_{0}^{T} \\lambda(\\tau) \\, d\\tau \\right)\n$$\n此公式结合了两个部分：事件发生确切时间点的强度乘积，以及一个“生存”概率项，即在观测到的事件之间的区间内没有观测到任何事件的概率。\n\n使用对数似然 $\\ln L$ 更为方便：\n$$\n\\ln L = \\sum_{i=1}^{n} \\ln(\\lambda(t_i)) - \\int_{0}^{T} \\lambda(\\tau) \\, d\\tau\n$$\n在我们的具体问题中，事件以有序的时间序列 $\\tau_1  \\tau_2  \\dots  \\tau_m$ 给出。其中一些是溯祖（'coal'）事件，一些是取样（'sample'）事件。只有溯祖事件对应于泊松过程中的点，并对 $\\ln(\\lambda(t_i))$ 项有贡献。然而，所有事件都定义了谱系数量 $k(t)$ 保持恒定的区间的边界。\n\n设完整的事件时间序列为 $0 = e_0  e_1  e_2  \\dots  e_p$，其中 $e_p$ 是最后一个事件的时间。谱系数量 $k(t)$ 是一个分段常数函数，其值仅在事件时间 $e_i$ 改变。令 $k_i$ 为区间 $[e_{i-1}, e_i)$ 内的谱系数量。积分项可以分解为在这些区间上的总和：\n$$\n\\int_{0}^{e_p} \\lambda(\\tau) \\, d\\tau = \\sum_{i=1}^{p} \\int_{e_{i-1}}^{e_i} \\lambda(\\tau) \\, d\\tau = \\sum_{i=1}^{p} \\binom{k_i}{2} \\int_{e_{i-1}}^{e_i} \\frac{1}{N_e(\\tau)} \\, d\\tau = \\sum_{i=1}^{p} \\binom{k_i}{2} \\int_{e_{i-1}}^{e_i} \\frac{1}{N_e(\\tau)} \\, d\\tau\n$$\n因此，对数似然表达式为：\n$$\n\\ln L = \\sum_{\\substack{\\text{事件 } j \\\\ \\text{在时间 } e_j \\\\ \\text{是 'coal'}}} \\ln\\left( \\binom{k(\\text{在 } e_j \\text{ 之前})}{2} \\frac{1}{N_e(e_j)} \\right) - \\sum_{i=1}^{p} \\binom{k_i}{2} \\int_{e_{i-1}}^{e_i} \\frac{1}{N_e(\\tau)} \\, d\\tau\n$$\n其中 $k(\\text{在 } e_j \\text{ 之前})$ 是事件 $j$ 发生前的谱系数量，即 $k_j$。\n\n### 计算种群大小倒数的积分\n\n核心计算任务是评估在不同时间区间上 $\\int \\frac{1}{N_e(t)} \\, dt$ 的积分。种群大小函数 $N_e(t)$ 是分段指数的，在片段 $[s_j, s_{j+1})$ 上定义为：\n$$\nN_e(t) = N_j \\exp\\big(g_j (t - s_j)\\big)\n$$\n一个积分区间 $(t_a, t_b)$ 可能跨越多个这样的片段。总积分必须通过将 $(t_a, t_b)$ 中落入每个片段的部分的积分相加来计算。对于完全包含在单个片段 $j$ 内的子区间 $[t_{start}, t_{end}]$，我们计算：\n$$\n\\int_{t_{start}}^{t_{end}} \\frac{1}{N_j \\exp\\big(g_j (t - s_j)\\big)} \\, dt = \\frac{1}{N_j} \\int_{t_{start}}^{t_{end}} \\exp\\big(-g_j (t - s_j)\\big) \\, dt\n$$\n我们必须考虑增长率 $g_j$ 的两种情况：\n\n情况 1：$g_j = 0$。种群大小是恒定的，$N_e(t) = N_j$。积分为：\n$$\n\\int_{t_{start}}^{t_{end}} \\frac{1}{N_j} \\, dt = \\frac{t_{end} - t_{start}}{N_j}\n$$\n情况 2：$g_j \\neq 0$。积分为：\n$$\n\\frac{1}{N_j} \\left[ \\frac{\\exp\\big(-g_j (t - s_j)\\big)}{-g_j} \\right]_{t_{start}}^{t_{end}} = \\frac{1}{-g_j N_j} \\left( \\exp\\big(-g_j (t_{end} - s_j)\\big) - \\exp\\big(-g_j (t_{start} - s_j)\\big) \\right)\n$$\n$$\n= \\frac{\\exp\\big(-g_j (t_{start} - s_j)\\big) - \\exp\\big(-g_j (t_{end} - s_j)\\big)}{g_j N_j}\n$$\n为了在 $g_j$ 非常小时保持数值稳定性，我们使用阈值单独处理 $g_j = 0$ 的情况。\n\n### 算法摘要\n\n总体算法流程如下：\n1. 初始化对数似然 $\\ln L = 0$，将当前谱系数量 $k$ 设为时间 $t=0$ 时的初始值，并将前一个事件时间 $t_{prev}$ 设为 0。\n2. 按时间顺序处理事件。对于每个在时间 $t_{curr}$ 发生的事件：\n   a. 计算来自区间 $[t_{prev}, t_{curr}]$ 的贡献。如果 $k \\ge 2$，计算谱系对数 $\\binom{k}{2}$ 和积分 $I = \\int_{t_{prev}}^{t_{curr}} \\frac{1}{N_e(\\tau)} d\\tau$。从 $\\ln L$ 中减去 $\\binom{k}{2} I$。\n   b. 如果在 $t_{curr}$ 的事件是溯祖事件：\n      i. 计算对数强度项 $\\ln\\left(\\binom{k}{2} / N_e(t_{curr})\\right)$ 并将其加到 $\\ln L$ 中。\n      ii. 减少谱系数量：$k \\leftarrow k - 1$。\n   c. 如果在 $t_{curr}$ 的事件是取样事件：\n      i. 增加谱系数量：$k \\leftarrow k + 1$。\n   d. 更新前一个事件时间：$t_{prev} \\leftarrow t_{curr}$。\n3. $\\ln L$ 的最终值就是所求的对数似然。\n\n此过程正确地累积了对数似然公式的所有项，并仔细处理了谱系数量 $k(t)$ 和有效种群大小 $N_e(t)$ 的分段特性。", "answer": "```python\nimport numpy as np\n\ndef _eval_Ne(t, segments):\n    \"\"\"\n    Evaluates the effective population size N_e(t) at a specific time t.\n    Segments are defined as [start, end, N_base, growth_rate].\n    The function N_e(t) = N_base * exp(g * (t - start)) is defined on [start, end).\n    \"\"\"\n    for s_start, s_end, N_base, g in segments:\n        # The interval is [s_start, s_end). A time t==s_end falls in the next segment.\n        if s_start = t  s_end:\n            return N_base * np.exp(g * (t - s_start))\n    \n    # Handle time t being exactly the end time of the last segment.\n    last_s_start, last_s_end, last_N_base, last_g = segments[-1]\n    # Use a small tolerance for floating point comparison.\n    if abs(t - last_s_end)  1e-9:\n        return last_N_base * np.exp(last_g * (t - last_s_start))\n        \n    raise ValueError(f\"Time {t} is outside the defined demographic segments.\")\n\ndef _integrate_inv_Ne(t_start, t_end, segments, epsilon=1e-9):\n    \"\"\"\n    Computes the definite integral of 1/N_e(t) from t_start to t_end.\n    \"\"\"\n    if t_start >= t_end:\n        return 0.0\n\n    total_integral = 0.0\n    current_t = t_start\n\n    for s_start, s_end, N_base, g in segments:\n        # Determine the integration interval within the current segment\n        integration_start = max(current_t, s_start)\n        integration_end = min(t_end, s_end)\n\n        if integration_start >= integration_end:\n            continue\n        \n        if abs(g)  epsilon:\n            # Case g is close to 0: N_e(t) is constant N_base\n            delta_t = integration_end - integration_start\n            total_integral += delta_t / N_base\n        else:\n            # Case g != 0: N_e(t) = N_base * exp(g * (t - s_start))\n            term1 = np.exp(-g * (integration_start - s_start))\n            term2 = np.exp(-g * (integration_end - s_start))\n            total_integral += (term1 - term2) / (g * N_base)\n        \n        current_t = integration_end\n        if current_t >= t_end:\n            break\n            \n    return total_integral\n\ndef _compute_log_likelihood(initial_k, events, segments):\n    \"\"\"\n    Computes the coalescent log-likelihood for a given history.\n    \"\"\"\n    logL = 0.0\n    k = initial_k\n    t_prev = 0.0\n    \n    # Events are assumed to be sorted by time as per problem statement.\n    sorted_events = sorted(events, key=lambda x: x[0])\n\n    for t_curr, event_type in sorted_events:\n        # Survival part: integral over the interval [t_prev, t_curr]\n        if k >= 2:\n            num_pairs = k * (k - 1) / 2.0\n            integral = _integrate_inv_Ne(t_prev, t_curr, segments)\n            logL -= num_pairs * integral\n        \n        # Point mass part for a coalescent event at t_curr\n        if event_type == 'coal':\n            if k  2:\n                # Invalid history: coalescence with fewer than 2 lineages.\n                return -np.inf \n            num_pairs = k * (k - 1) / 2.0\n            Ne_at_event = _eval_Ne(t_curr, segments)\n            logL += np.log(num_pairs) - np.log(Ne_at_event)\n            k -= 1\n        elif event_type == 'sample':\n            k += 1\n        \n        t_prev = t_curr\n        \n    return logL\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = []\n\n    # Test case 1\n    N0_1, g0_1 = 10000.0, 0.0\n    segments1 = [(0.0, 3.0, N0_1, g0_1)]\n    events1 = [(0.5, 'coal'), (1.0, 'coal'), (2.0, 'coal')]\n    k0_1 = 4\n    test_cases.append({'initial_k': k0_1, 'events': events1, 'segments': segments1})\n\n    # Test case 2\n    N0_2, g0_2 = 8000.0, 0.3\n    s1_2 = 1.0\n    N1_2 = N0_2 * np.exp(g0_2 * (s1_2 - 0.0))\n    g1_2 = -0.2\n    segments2 = [(0.0, s1_2, N0_2, g0_2), (s1_2, 3.0, N1_2, g1_2)]\n    events2 = [(0.8, 'coal'), (1.5, 'coal'), (2.2, 'coal'), (2.7, 'coal')]\n    k0_2 = 5\n    test_cases.append({'initial_k': k0_2, 'events': events2, 'segments': segments2})\n    \n    # Test case 3\n    N0_3, g0_3 = 12000.0, 0.0\n    s1_3 = 1.0\n    N1_3 = N0_3 * np.exp(g0_3 * (s1_3 - 0.0))\n    g1_3 = 0.5\n    segments3 = [(0.0, s1_3, N0_3, g0_3), (s1_3, 2.0, N1_3, g1_3)]\n    events3 = [(1.0, 'coal'), (1.8, 'coal')]\n    k0_3 = 3\n    test_cases.append({'initial_k': k0_3, 'events': events3, 'segments': segments3})\n\n    # Test case 4\n    N0_4, g0_4 = 6000.0, -0.1\n    s1_4 = 2.0\n    N1_4 = N0_4 * np.exp(g0_4 * (s1_4 - 0.0))\n    g1_4 = 0.0\n    segments4 = [(0.0, s1_4, N0_4, g0_4), (s1_4, 4.0, N1_4, g1_4)]\n    events4 = [(0.5, 'coal'), (0.7, 'sample'), (0.9, 'coal'), (1.3, 'sample'), (2.8, 'coal')]\n    k0_4 = 2\n    test_cases.append({'initial_k': k0_4, 'events': events4, 'segments': segments4})\n\n    results = []\n    for case in test_cases:\n        result = _compute_log_likelihood(case['initial_k'], case['events'], case['segments'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4374557"}]}