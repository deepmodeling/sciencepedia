{"hands_on_practices": [{"introduction": "在整合来自多个传感器的数据之前，我们必须首先确保每个独立数据流的保真度。这个练习 [@problem_id:4399053] 通过一个关于功耗受限的加速度计的假设但现实的场景，探讨了“混叠”这一关键概念。通过计算欠采样对步数统计等生理指标准确性的影响，你将对奈奎斯特-香农采样定理及其在可穿戴设备数据分析中的实际意义有更深刻的理解。", "problem": "一款用于系统生物医学中步态监测的可穿戴式惯性测量单元 (IMU) 加速度计，采集一个连续时间信号，该信号在步频 $f_{g} = 2$ $\\text{Hz}$ 处有一个主导的窄带分量。由于功率限制，该加速度计以 $f_{s} = 3$ $\\text{Hz}$ 的速率进行均匀采样，其计步算法通过检测采样信号中的主导频率，并将该估计值乘以观测时长 $T$ 来估计步数，假设主导分量的每个周期对应一步。\n\n从采样定理以及“对连续时间信号进行均匀采样会产生按采样率整数倍移位的频谱副本”这一定义出发，推导采样后将观测到的频率内容，并确定落在基带区间 $[0, f_{s}/2]$ 内的混叠频率 $f_{a}$。然后，假设观测窗口 $T$ 渐近长，并且有一个理想的频率估计器可以输出采样后的离散时间数据中的主导频率，推导估计步数相对于真实步数的乘性偏差。将此偏差表示为一个无量纲小数，定义为在极限 $T \\to \\infty$ 下，估计计数值与真实计数值之比。无需四舍五入。", "solution": "该问题陈述经评估有效。其科学依据在于数字信号处理的原理，特别是奈奎斯特-香农采样定理和混叠现象。问题提法严谨、客观，并包含了推导唯一、有意义解所需的所有信息。所描述的场景是系统生物医学和可穿戴技术中的一个标准应用。\n\n这个问题的核心在于以低于奈奎斯特率的速率对连续时间信号进行采样所带来的后果。奈奎斯特-香农采样定理指出，对于一个最高频率为 $f_{max}$ 的带限信号，采样频率 $f_s$ 必须严格大于最高频率的两倍，即 $f_s > 2 f_{max}$，以避免信息丢失并实现完美重建。频率 $2 f_{max}$ 被称为奈奎斯特率。\n\n在本问题中，连续时间信号在步频 $f_g = 2$ Hz 处有一个主导频率分量。因此，需要保留的最高频率是 $f_{max} = f_g = 2$ Hz。为无混叠地采样此信号所需的奈奎斯特率是 $2 \\cdot f_g = 2 \\cdot 2 = 4$ Hz。\n\n然而，该加速度计以 $f_s = 3$ Hz 的速率对信号进行采样。由于采样频率 $f_s = 3$ Hz 小于 $4$ Hz 的奈奎斯特率，信号被欠采样，将发生一种称为混叠的现象。\n\n对一个在频率 $f_g$ 处有频谱分量的连续时间信号进行均匀采样，会产生一个离散时间信号，其频谱包含原始分量的副本，这些副本按采样频率 $f_s$ 的所有整数倍进行了移位。采样信号频谱中出现的频率由以下关系式给出：\n$$\nf_{observed} = |f_g - k \\cdot f_s|\n$$\n其中 $k$ 是任意整数 ($k \\in \\{\\dots, -2, -1, 0, 1, 2, \\dots\\}$)。\n\n频率估计器对采样数据进行操作，因此观测到的是主区间或基带区间内的频率。对于实值信号，此区间定义为 $[0, f_s/2]$。给定 $f_s = 3$ Hz，基带区间为 $[0, 3/2]$ Hz，即 $[0, 1.5]$ Hz。我们必须找到使 $f_{observed}$ 落入此区间的 $k$ 值。\n\n让我们针对不同的整数 $k$ 值计算 $f_{observed}$：\n\\begin{itemize}\n    \\item 当 $k = 0$ 时：$f_{observed} = |2 - 0 \\cdot 3| = 2$ Hz。这在基带 $[0, 1.5]$ Hz 之外。\n    \\item 当 $k = 1$ 时：$f_{observed} = |2 - 1 \\cdot 3| = |-1| = 1$ Hz。此频率位于基带 $[0, 1.5]$ Hz 之内。\n    \\item 当 $k = -1$ 时：$f_{observed} = |2 - (-1) \\cdot 3| = |2 + 3| = 5$ Hz。这在基带之外。\n    \\item 当 $k = 2$ 时：$f_{observed} = |2 - 2 \\cdot 3| = |-4| = 4$ Hz。这在基带之外。\n\\end{itemize}\n唯一出现在所定义的基带区间内的频谱副本是在 $1$ Hz 处。因此，理想频率估计器将检测到的混叠频率 $f_a$ 是：\n$$\nf_a = 1 \\text{ Hz}\n$$\n问题陈述指出，计步算法通过将估计频率乘以观测时长 $T$ 来估计步数。真实的步数 $N_{true}$ 基于实际的步频 $f_g$：\n$$\nN_{true} = f_g \\cdot T\n$$\n估计的步数 $N_{est}$ 基于混叠频率 $f_a$，这是算法从采样数据中检测到的频率：\n$$\nN_{est} = f_a \\cdot T\n$$\n乘性偏差定义为估计计数值与真实计数值之比。在渐近长观测窗口（$T \\to \\infty$）的极限下，时长 $T$ 是一个公因数，可以消去：\n$$\n\\text{Bias} = \\frac{N_{est}}{N_{true}} = \\frac{f_a \\cdot T}{f_g \\cdot T} = \\frac{f_a}{f_g}\n$$\n代入已知的混叠频率 $f_a$ 和真实步频 $f_g$ 的值：\n$$\n\\text{Bias} = \\frac{1 \\text{ Hz}}{2 \\text{ Hz}} = 0.5\n$$\n所得的乘性偏差是一个无量纲小数，符合要求。由于欠采样，该算法估计的步数将是真实步数的一半。", "answer": "$$\\boxed{0.5}$$", "id": "4399053"}, {"introduction": "可穿戴系统常常使用多种传感器测量同一生理参数，例如通过心电图（ECG）和光电容积描记（PPG）来测量心率。本实践 [@problem_id:4399060] 介绍了Bland-Altman分析，这是生物统计学中比较测量方法的基石。通过亲手实现该分析，你将学会一套标准流程来量化两种测量技术之间的偏倚和一致性限度，这对于验证新型传感器或融合其数据至关重要。", "problem": "考虑在系统生物医学中使用可穿戴传感器进行设备间心率整合。心电图（ECG）和光电容积脉搏波（PPG）是两种估计心率的方法。设第 $i$ 次配对观测的潜在真实心率为 $h_i$。ECG导出的心率表示为 $y^{\\mathrm{ECG}}_i$，PPG导出的心率表示为 $y^{\\mathrm{PPG}}_i$，两者均以每分钟心跳次数（bpm）为单位。假设每次观测到的心率是真实心率加上设备特定的测量误差，即 $y^{\\mathrm{ECG}}_i = h_i + \\varepsilon^{\\mathrm{ECG}}_i$ 和 $y^{\\mathrm{PPG}}_i = h_i + \\varepsilon^{\\mathrm{PPG}}_i$，其中 $\\varepsilon^{\\mathrm{ECG}}_i$ 和 $\\varepsilon^{\\mathrm{PPG}}_i$ 是具有有限方差的随机误差。定义配对差异 $d_i = y^{\\mathrm{PPG}}_i - y^{\\mathrm{ECG}}_i$ 和配对均值 $m_i = \\left(y^{\\mathrm{PPG}}_i + y^{\\mathrm{ECG}}_i\\right)/2$。设备间偏倚是差异的期望值 $\\mathbb{E}[d_i]$，而Bland–Altman分析则在差异呈正态模型的假设下描述设备间的一致性。\n\n您的任务是编写一个程序，对每个测试用例从基本原理出发执行以下计算：\n- 在移除任何 $y^{\\mathrm{ECG}}_i$ 或 $y^{\\mathrm{PPG}}_i$ 缺失的配对后，使用配对差异 $d_i$ 估计设备间偏倚。缺失值表示为非数值（not-a-number），应通过逐对删除法排除。\n- 使用无偏样本标准差估计 $d_i$ 的离散度。\n- 假设差异 $d_i$ 独立且近似服从具有恒定方差的正态分布，使用适当的正态分位数计算差异的双侧 $95$%-覆盖率的Bland–Altman一致性界限。\n- 通过拟合普通最小二乘回归 $d_i = a + b\\,m_i + \\eta_i$ 来评估比例偏倚，并使用双侧显著性水平 $\\alpha = 0.05$（以小数表示）检验无比例偏倚的原假设 $b = 0$。报告斜率 $b$ 和一个布尔值，指示在给定水平下比例偏倚是否具有统计显著性。如果由于 $m_i$ 的方差为零或数据不足而导致回归未定义，则将斜率视为 $0$ 且显著性为假（false）。\n\n所有偏倚和一致性界限的答案必须以每分钟心跳次数（bpm）表示。斜率 $b$ 是无量纲的（bpm/bpm）。不涉及角度。百分比必须按小数处理；不要使用百分号。\n\n使用以下配对观测的测试套件（每个值均以bpm为单位）。对于每个案例，ECG列表和PPG列表是在不同会话中测量的对齐配对；请将它们视为每个案例的一个合并数据集。\n\n- 案例 $1$（具有小的正偏倚的一般情况）：\n  - ECG: $\\{\\,72,\\,75,\\,80,\\,78,\\,90,\\,92,\\,88,\\,85,\\,76,\\,84\\,\\}$\n  - PPG: $\\{\\,74,\\,77,\\,83,\\,80,\\,93,\\,94,\\,90,\\,86,\\,78,\\,86\\,\\}$\n\n- 案例 $2$（零偏倚和零离散度的边界情况）：\n  - ECG: $\\{\\,60,\\,65,\\,70,\\,75,\\,80,\\,85\\,\\}$\n  - PPG: $\\{\\,60,\\,65,\\,70,\\,75,\\,80,\\,85\\,\\}$\n\n- 案例 $3$（比例偏倚随心率增加的边缘情况）：\n  - ECG: $\\{\\,50,\\,60,\\,70,\\,80,\\,90,\\,100,\\,110\\,\\}$\n  - PPG: $\\{\\,52,\\,62,\\,74.5,\\,84,\\,92.5,\\,107,\\,115.5\\,\\}$\n\n- 案例 $4$（需要逐对删除缺失值的边缘情况）：\n  - ECG: $\\{\\,70,\\,\\text{NaN},\\,85,\\,95,\\,100\\,\\}$\n  - PPG: $\\{\\,72,\\,78,\\,\\text{NaN},\\,99,\\,102\\,\\}$\n\n您的程序所需的最终输出格式是单行文本，其中包含按顺序排列的四个案例的结果列表，每个案例的结果本身是一个包含以下六个元素的列表，顺序必须完全一致：\n$[\\,\\widehat{B},\\,\\widehat{S}_d,\\,\\mathrm{LOA}_{\\mathrm{lower}},\\,\\mathrm{LOA}_{\\mathrm{upper}},\\,\\widehat{b},\\,\\mathrm{is\\_significant}\\,]$,\n其中 $\\widehat{B}$ 是以bpm为单位的估计偏倚，$\\widehat{S}_d$ 是以bpm为单位的 $d_i$ 的无偏样本标准差，$\\mathrm{LOA}_{\\mathrm{lower}}$ 和 $\\mathrm{LOA}_{\\mathrm{upper}}$ 是以bpm为单位的Bland–Altman一致性界限，$\\widehat{b}$ 是以bpm/bpm为单位的回归斜率，`is_significant` 是在 $\\alpha = 0.05$ 下进行比例偏倚检验的布尔值。\n\n您的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔列表，每个案例的列表也用其自己的方括号括起来，例如：$[[r_{1,1},r_{1,2},\\ldots],[r_{2,1},r_{2,2},\\ldots],[r_{3,1},\\ldots],[r_{4,1},\\ldots]]$。", "solution": "该问题是有效的，因为它以标准的生物统计学方法为科学依据，提法恰当，信息充分且一致，并且表述客观。任务是对来自ECG和PPG传感器的配对心率测量值执行Bland-Altman分析并评估比例偏倚。\n\n解决方案首先实现数据预处理，然后从基本原理出发计算指定的统计量度。\n\n**1. 数据预处理**\n对于每个测试用例，都会处理配对观测值 $(y^{\\mathrm{ECG}}_i, y^{\\mathrm{PPG}}_i)$。任何包含缺失值（表示为非数值NaN）的配对都将被移除。此过程称为逐对删除。设此步骤后剩余的有效配对数量为 $n$。对于所有提供的测试用例，$n \\ge 3$，这足以进行所有后续计算。\n\n**2. 配对差异与均值**\n根据清理后的数据，我们为每个观测值 $i=1, \\dots, n$ 计算配对差异 $d_i$ 和配对均值 $m_i$：\n$$d_i = y^{\\mathrm{PPG}}_i - y^{\\mathrm{ECG}}_i$$\n$$m_i = \\frac{y^{\\mathrm{PPG}}_i + y^{\\mathrm{ECG}}_i}{2}$$\n\n**3. Bland-Altman分析**\nBland-Altman分析量化了两种测量设备之间的一致性。\n\n**3.1. 设备间偏倚估计**\n设备间偏倚 $\\mathbb{E}[d_i]$ 通过差异的样本均值来估计，记为 $\\widehat{B}$：\n$$\\widehat{B} = \\bar{d} = \\frac{1}{n}\\sum_{i=1}^{n} d_i$$\n\n**3.2. 离散度估计**\n差异的离散度使用无偏样本标准差来估计，记为 $\\widehat{S}_d$：\n$$\\widehat{S}_d = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^{n} (d_i - \\bar{d})^2}$$\n此计算至少需要 $n=2$ 个有效配对。\n\n**3.3. 一致性界限（LOA）**\n假设差异 $d_i$ 服从正态分布，计算 $95\\%$ 一致性界限。这些界限定义了一个范围，预计两种方法之间 $95\\%$ 的差异会落入此范围内。\n$$\\mathrm{LOA} = \\bar{d} \\pm z_{1-\\alpha/2} \\cdot \\widehat{S}_d$$\n对于双侧 $95\\%$ 的覆盖率，显著性水平为 $\\alpha=0.05$。我们使用标准正态分布的 $1-\\alpha/2 = 0.975$ 分位数，$z_{0.975} \\approx 1.95996$。下限和上限为：\n$$\\mathrm{LOA}_{\\mathrm{lower}} = \\bar{d} - z_{0.975} \\cdot \\widehat{S}_d$$\n$$\\mathrm{LOA}_{\\mathrm{upper}} = \\bar{d} + z_{0.975} \\cdot \\widehat{S}_d$$\n\n**4. 比例偏倚评估**\n如果两次测量之间的差异随测量值的大小系统地变化，则会发生比例偏倚。这通过拟合普通最小二乘（OLS）回归模型来评估：\n$$d_i = a + b\\,m_i + \\eta_i$$\n其中 $\\eta_i$ 是误差项。\n\n**4.1. 斜率估计**\n斜率系数 $\\widehat{b}$ 使用OLS公式估计：\n$$\\widehat{b} = \\frac{\\sum_{i=1}^{n} (m_i - \\bar{m})(d_i - \\bar{d})}{\\sum_{i=1}^{n} (m_i - \\bar{m})^2} = \\frac{\\mathrm{Cov}(m, d)}{\\mathrm{Var}(m)}$$\n其中 $\\bar{m}$ 是 $m_i$ 的样本均值。如果 $m_i$ 的方差为零，则此计算未定义。在这种情况下，根据问题陈述，我们设置 $\\widehat{b}=0$ 并得出结论，即不存在显著的比例偏倚。\n\n**4.2. 斜率的假设检验**\n我们在显著性水平 $\\alpha = 0.05$ 下检验原假设 $H_0: b = 0$（无比例偏倚）与备择假设 $H_1: b \\neq 0$。检验统计量是t统计量，在 $H_0$ 成立的情况下，它服从具有 $n-2$ 个自由度的t分布：\n$$t = \\frac{\\widehat{b}}{\\mathrm{SE}(\\widehat{b})}$$\n斜率的标准误 $\\mathrm{SE}(\\widehat{b})$ 计算如下：\n$$\\mathrm{SE}(\\widehat{b}) = \\sqrt{\\frac{\\hat{\\sigma}^2}{\\sum_{i=1}^{n} (m_i - \\bar{m})^2}}$$\n其中 $\\hat{\\sigma}^2$ 是残差 $\\eta_i$ 方差的无偏估计量：\n$$\\hat{\\sigma}^2 = \\frac{1}{n-2} \\sum_{i=1}^{n} e_i^2$$\n且 $e_i = d_i - (\\hat{a} + \\hat{b}m_i)$ 是回归残差，其中 $\\hat{a} = \\bar{d} - \\hat{b}\\bar{m}$。此检验在 $n > 2$ 时有效。\n\n如果检验统计量的绝对值超过t分布的临界值，则拒绝原假设：\n$$|t| > t_{n-2, 1-\\alpha/2}$$\n其中 $t_{n-2, 1-\\alpha/2}$ 是双侧检验的上临界值。如果 $|t| \\le t_{n-2, 1-\\alpha/2}$，我们未能拒绝 $H_0$，比例偏倚不具有统计显著性。布尔值 `is_significant` 会相应地设置。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm, t\n\ndef solve():\n    \"\"\"\n    Performs Bland-Altman and proportional bias analysis on paired heart rate data.\n    \"\"\"\n    test_cases = [\n        # Case 1: general case with small positive bias\n        {\n            'ECG': [72, 75, 80, 78, 90, 92, 88, 85, 76, 84],\n            'PPG': [74, 77, 83, 80, 93, 94, 90, 86, 78, 86]\n        },\n        # Case 2: boundary case with zero bias and zero dispersion\n        {\n            'ECG': [60, 65, 70, 75, 80, 85],\n            'PPG': [60, 65, 70, 75, 80, 85]\n        },\n        # Case 3: edge case with proportional bias\n        {\n            'ECG': [50, 60, 70, 80, 90, 100, 110],\n            'PPG': [52, 62, 74.5, 84, 92.5, 107, 115.5]\n        },\n        # Case 4: edge case with missing values\n        {\n            'ECG': [70, np.nan, 85, 95, 100],\n            'PPG': [72, 78, np.nan, 99, 102]\n        },\n    ]\n\n    all_results = []\n\n    for case_data in test_cases:\n        y_ecg = np.array(case_data['ECG'], dtype=float)\n        y_ppg = np.array(case_data['PPG'], dtype=float)\n\n        # Step 1: Pairwise deletion for NaN values\n        valid_mask = ~np.isnan(y_ecg)  ~np.isnan(y_ppg)\n        y_ecg_clean = y_ecg[valid_mask]\n        y_ppg_clean = y_ppg[valid_mask]\n\n        n = len(y_ecg_clean)\n\n        # Step 2: Compute paired differences (d) and means (m)\n        d = y_ppg_clean - y_ecg_clean\n        m = (y_ppg_clean + y_ecg_clean) / 2.0\n\n        # Step 3.1: Estimate inter-device bias\n        bias_est = np.mean(d) if n > 0 else 0.0\n\n        # Step 3.2: Estimate dispersion (unbiased sample standard deviation)\n        sd_est = np.std(d, ddof=1) if n > 1 else 0.0\n\n        # Step 3.3: Compute 95% Bland-Altman limits of agreement\n        z_crit = norm.ppf(0.975)\n        loa_margin = z_crit * sd_est\n        loa_lower = bias_est - loa_margin\n        loa_upper = bias_est + loa_margin\n\n        # Step 4: Assess proportional bias\n        slope_est = 0.0\n        is_significant = False\n\n        # Regression and t-test require n >= 3 and Var(m) > 0\n        if n >= 3 and np.var(m) > 1e-12:\n            # Step 4.1: OLS slope estimation from first principles\n            m_mean = np.mean(m)\n            d_mean = np.mean(d)\n            \n            # Covariance term S_md and variance term S_mm\n            cov_md_sum = np.sum((m - m_mean) * (d - d_mean))\n            var_m_sum = np.sum((m - m_mean) ** 2)\n            \n            slope_est = cov_md_sum / var_m_sum\n\n            # Step 4.2: Hypothesis testing for the slope\n            df = n - 2\n            \n            # Sum of squared residuals (SSR)\n            var_d_sum = np.sum((d - d_mean) ** 2)\n            ssr = var_d_sum - slope_est * cov_md_sum\n            \n            # Handle potential floating point inaccuracies\n            ssr = max(0, ssr)\n\n            # Estimated variance of the residuals\n            residual_var_est = ssr / df\n            \n            # Standard error of the slope\n            se_slope = np.sqrt(residual_var_est / var_m_sum)\n            \n            # Perform t-test if SE is non-zero\n            if se_slope > 1e-12:\n                t_stat = slope_est / se_slope\n                alpha = 0.05\n                t_crit = t.ppf(1 - alpha / 2, df=df)\n                is_significant = np.abs(t_stat) > t_crit\n            # If se_slope is zero, it implies a perfect fit. If slope is also\n            # zero, H0 is not rejected (is_significant remains False).\n\n        all_results.append([\n            bias_est, sd_est, loa_lower, loa_upper, slope_est, is_significant\n        ])\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "4399060"}, {"introduction": "由于传感器脱落、传输错误或节能模式，现实世界中的可穿戴传感器数据经常存在片段缺失的问题。本练习 [@problem_id:4399026] 深入探讨了一种强大的统计技术——期望最大化（EM）算法——来处理这类不完整数据。你将从第一性原理出发，推导并实现EM算法，用以估计一个生理模型的参数，从而学习在面临数据缺口时如何进行稳健的统计推断。", "problem": "您的任务是构建一个完整的、可运行的程序，在系统生物医学的数据融合和不确定性下估计的背景下，实现期望最大化（EM）算法，以处理在从可穿戴传感器推断日常活动能量消耗时缺失的加速计片段。考虑一个单日的分钟级模型，其中在分钟 $t$ 由加速计衍生的活动强度，表示为 $x_t$，被建模为一个独立的、具有已知先验均值 $m_0$ 和先验方差 $s_0^2$ 的高斯随机变量，即 $x_t \\sim \\mathcal{N}(m_0, s_0^2)$ 在所有 $t$ 上独立。分钟级能量消耗 $y_t$（单位为千焦/分钟）通过一个线性高斯校准模型与活动强度相关：以 $x_t$ 为条件，它遵循 $y_t \\mid x_t \\sim \\mathcal{N}(\\beta_0 + \\beta_1 x_t, \\sigma^2)$，其中 $\\beta_0 \\in \\mathbb{R}$，$\\beta_1 \\in \\mathbb{R}$ 和 $\\sigma^2  0$ 是待估计的未知参数。您观测到所有时刻 $t$ 的 $y_t$，但仅观测到部分时刻 $t$ 的加速计数据 $x_t$，其余数据缺失。假设先验超参数 $m_0$ 和 $s_0^2$ 在 EM 迭代过程中是已知且固定的。您的任务是，从第一性原理出发，推导并实现一个 EM 算法，用于在给定观测到的 $y_t$ 和部分观测的 $x_t$ 的情况下，对 $(\\beta_0, \\beta_1, \\sigma^2)$ 进行最大似然估计，然后使用估计出的参数为一个单独的目标日推断每日总活动能量消耗，该目标日仅包含（部分缺失的）加速计数据，而没有 $y_t$ 数据。EM 算法必须从基本概率规则推导得出：贝叶斯法则、高斯分布的性质以及不完整数据的最大似然估计定义。\n\n您的推导必须从以下基本基础开始：\n- 联合密度分解 $p(y, x; \\theta) = \\prod_{t=1}^T p(y_t \\mid x_t; \\theta) p(x_t)$，其中 $p(y_t \\mid x_t; \\theta) = \\mathcal{N}(y_t \\mid \\beta_0 + \\beta_1 x_t, \\sigma^2)$ 且 $p(x_t) = \\mathcal{N}(x_t \\mid m_0, s_0^2)$，这里 $\\theta = (\\beta_0, \\beta_1, \\sigma^2)$。\n- 期望最大化（EM）原则：通过迭代 E 步 $Q(\\theta \\mid \\theta^{(old)}) = \\mathbb{E}[\\log p(y, x; \\theta) \\mid y, x_{\\text{obs}}; \\theta^{(old)}]$ 和 M 步 $\\theta^{(new)} = \\arg\\max_{\\theta} Q(\\theta \\mid \\theta^{(old)})$ 来最大化观测数据的对数似然。\n- 高斯共轭性：对于 $x_t$ 的高斯先验和 $y_t \\mid x_t$ 的高斯似然，在给定 $y_t$ 和固定的 $(\\beta_0, \\beta_1, \\sigma^2, m_0, s_0^2)$ 的情况下，缺失的 $x_t$ 的后验分布是高斯分布，其均值和方差可以解析计算。\n\n仅使用这些基础，并且不使用简化公式，推导 E 步和 M 步的更新，以在某些 $x_t$ 缺失时估计 $(\\beta_0, \\beta_1, \\sigma^2)$。然后，说明如何计算一个只有加速计数据且遵循相同模型的目标日的预测每日总能量消耗。对于没有 $y_t$ 的目标日，您必须提供逐分钟计算 $\\mathbb{E}[y_t \\mid \\text{available data}]$ 并对全天求和的逻辑。最终程序必须实现此 EM 算法，并为以下测试套件生成数值输出。\n\n测试套件和要求输出：\n对于下述每种情况，程序必须：\n- 在校准日上运行 EM 算法，使用观测到的 $y_t$（单位为千焦/分钟）和部分观测的 $x_t$（无单位的加速计强度；存在缺失值），并使用为该情况提供的固定先验超参数 $(m_0, s_0^2)$。\n- 在 EM 收敛后，计算目标日的预测总活动能量消耗，定义为 $\\sum_{t=1}^{T_{\\text{target}}} \\mathbb{E}[y_t \\mid \\text{available accelerometer data at } t]$，以千焦（kJ）为单位表示，并四舍五入至三位小数。对于目标日的某一分钟 $t$，如果 $x_t$ 已观测到，则使用 $\\mathbb{E}[y_t \\mid x_t] = \\beta_0 + \\beta_1 x_t$。对于目标日的某一分钟 $t$，如果 $x_t$ 缺失且没有可用的 $y_t$，则在先验下使用 $\\mathbb{E}[x_t] = m_0$，因此 $\\mathbb{E}[y_t] = \\beta_0 + \\beta_1 m_0$。\n\n情况 A（理想路径）：\n- 超参数：$m_0 = 0.5$, $s_0^2 = 1.0$。\n- 校准日长度 $T = 6$，其中 $y = [\\,1.50,\\,1.75,\\,3.00,\\,0.20,\\,1.05,\\,2.30\\,]$ 和 $x = [\\,0.20,\\,\\text{NaN},\\,1.00,\\,-0.50,\\,\\text{NaN},\\,0.70\\,]$，其中 $\\text{NaN}$ 表示缺失值。\n- 目标日长度 $T_{\\text{target}} = 6$，其中 $x^{\\text{target}} = [\\,0.00,\\,0.50,\\,\\text{NaN},\\,-0.20,\\,0.90,\\,\\text{NaN}\\,]$。\n\n情况 B（校准和目标数据中的加速计数据全部缺失）：\n- 超参数：$m_0 = 0.00$, $s_0^2 = 1.0$。\n- 校准日长度 $T = 4$，其中 $y = [\\,0.50,\\,1.25,\\,-0.25,\\,2.00\\,]$ 和 $x = [\\,\\text{NaN},\\,\\text{NaN},\\,\\text{NaN},\\,\\text{NaN}\\,]$。\n- 目标日长度 $T_{\\text{target}} = 3$，其中 $x^{\\text{target}} = [\\,\\text{NaN},\\,\\text{NaN},\\,\\text{NaN}\\,]$。\n\n情况 C（低观测噪声，部分缺失）：\n- 超参数：$m_0 = 0.30$, $s_0^2 = 0.20$。\n- 校准日长度 $T = 5$，其中 $y = [\\,2.30,\\,2.40,\\,2.005,\\,2.595,\\,2.20\\,]$ 和 $x = [\\,0.30,\\,\\text{NaN},\\,0.00,\\,0.60,\\,\\text{NaN}\\,]$。\n- 目标日长度 $T_{\\text{target}} = 4$，其中 $x^{\\text{target}} = [\\,\\text{NaN},\\,0.10,\\,0.20,\\,\\text{NaN}\\,]$。\n\n角度单位不适用。物理单位：以千焦（kJ）为单位报告每种情况的最终预测总和，四舍五入至三位小数。您的程序应生成单行输出，包含三个结果，形式为用方括号括起来的逗号分隔列表（例如，“[12.345,67.890,1.234]”），顺序与情况 A、B 和 C 相同。\n\n科学真实性约束：\n- 将分钟级 $y_t$ 视为千焦/分钟，将 $x_t$ 视为无单位的加速计强度。\n- EM 算法必须从上述高斯模型推导得出，使用贝叶斯法则和高斯条件分布的性质，并且不得引用未引入的简化公式。\n\n您的最终程序必须是完全自包含的，无需外部输入，并按上述规定为测试套件生成输出。", "solution": "用户提供了一个科学上合理、定义明确的问题，要求在相关应用领域推导并实现一个标准的统计算法。该问题指定了清晰的模型、明确的目标和可验证的测试用例。所有必要的数据和条件都已提供。因此，该问题被认为是有效的。\n\n### 期望最大化（EM）算法的解析推导\n\n本问题旨在解决系统生物医学中的一个核心挑战：整合来自多个来源（如可穿戴传感器）的含噪声和不完整的数据，以推断潜在的生理状态。在这里，我们的目标是通过融合加速计数据（$x_t$）和能量消耗的校准模型（$y_t$）来估计每日活动能量消耗，其中加速计数据流存在缺失片段。我们将使用期望最大化（EM）算法来寻找模型参数的最大似然估计（MLE）。\n\n待估计的参数为 $\\theta = (\\beta_0, \\beta_1, \\sigma^2)$。模型规定如下：\n1.  活动强度的先验分布：$x_t \\sim \\mathcal{N}(m_0, s_0^2)$\n2.  能量消耗的似然：$y_t | x_t \\sim \\mathcal{N}(\\beta_0 + \\beta_1 x_t, \\sigma^2)$\n\n数据包括完整观测的 $y = \\{y_t\\}_{t=1}^T$ 和部分观测的 $x = \\{x_t\\}_{t=1}^T$。设 $\\mathcal{O}$ 为 $x_t$ 被观测到的时间索引集合，$\\mathcal{M}$ 为 $x_t$ 缺失的时间索引集合。完整数据为 $(y, x)$，观测数据为 $(y, x_{\\mathcal{O}})$。\n\nEM 算法通过迭代地最大化期望的完整数据对数似然（以观测数据和当前参数估计为条件）来进行。\n\n**完整数据对数似然**\n\n完整数据 $(y, x)$ 的联合概率密度为 $p(y, x; \\theta) = \\prod_{t=1}^T p(y_t \\mid x_t; \\theta) p(x_t)$。其对数似然 $\\ell(\\theta; y, x) = \\log p(y, x; \\theta)$ 为：\n$$\n\\ell(\\theta; y, x) = \\sum_{t=1}^T \\log p(y_t \\mid x_t; \\theta) + \\sum_{t=1}^T \\log p(x_t)\n$$\n由于 $p(x_t) = \\mathcal{N}(x_t \\mid m_0, s_0^2)$ 不依赖于参数 $\\theta = (\\beta_0, \\beta_1, \\sigma^2)$，在最大化过程中，我们可以将 $\\sum \\log p(x_t)$ 视为一个常数。我们关注第一项：\n$$\n\\sum_{t=1}^T \\log \\mathcal{N}(y_t \\mid \\beta_0 + \\beta_1 x_t, \\sigma^2) = \\sum_{t=1}^T \\left[ -\\frac{1}{2}\\log(2\\pi\\sigma^2) - \\frac{1}{2\\sigma^2}(y_t - \\beta_0 - \\beta_1 x_t)^2 \\right]\n$$\n$$\n\\ell_c(\\theta; y, x) = -\\frac{T}{2}\\log(\\sigma^2) - \\frac{1}{2\\sigma^2}\\sum_{t=1}^T (y_t - \\beta_0 - \\beta_1 x_t)^2 + \\text{const}\n$$\n其中 $\\ell_c(\\theta; y, x)$ 是与 $\\theta$ 相关的对数似然部分。\n\n**E 步：计算 Q 函数**\n\n在第 $k+1$ 次迭代中，E 步计算 Q 函数，即完整数据对数似然关于缺失数据 $x_{\\mathcal{M}}$ 的后验分布（以观测数据和当前参数估计值 $\\theta^{(k)} = (\\beta_0^{(k)}, \\beta_1^{(k)}, (\\sigma^2)^{(k)})$ 为条件）的期望。\n$$\nQ(\\theta \\mid \\theta^{(k)}) = \\mathbb{E}_{x_{\\mathcal{M}}}[\\ell_c(\\theta; y, x) \\mid y, x_{\\mathcal{O}}; \\theta^{(k)}]\n$$\n由于各时间点之间相互独立，期望可以分布到求和项中：\n$$\nQ(\\theta \\mid \\theta^{(k)}) = -\\frac{T}{2}\\log(\\sigma^2) - \\frac{1}{2\\sigma^2} \\sum_{t=1}^T \\mathbb{E}[(y_t - \\beta_0 - \\beta_1 x_t)^2 \\mid y_t, x_t \\text{ if } t \\in \\mathcal{O}; \\theta^{(k)}]\n$$\n对于 $t \\in \\mathcal{O}$，$x_t$ 是已知的，因此期望的计算是平凡的。对于 $t \\in \\mathcal{M}$，我们需要计算涉及缺失 $x_t$ 的项的期望。\n$$\n\\mathbb{E}[(y_t - \\beta_0 - \\beta_1 x_t)^2 \\mid \\dots] = \\mathbb{E}[ (y_t-\\beta_0)^2 - 2\\beta_1(y_t-\\beta_0)x_t + \\beta_1^2 x_t^2 \\mid \\dots]\n$$\n$$\n= (y_t-\\beta_0)^2 - 2\\beta_1(y_t-\\beta_0)\\mathbb{E}[x_t \\mid \\dots] + \\beta_1^2 \\mathbb{E}[x_t^2 \\mid \\dots]\n$$\n因此，E 步需要为每个 $t \\in \\mathcal{M}$ 计算两个条件矩：\n1.  $\\tilde{x}_t^{(k)} = \\mathbb{E}[x_t \\mid y_t; \\theta^{(k)}]$\n2.  $\\widetilde{x_t^2}^{(k)} = \\mathbb{E}[x_t^2 \\mid y_t; \\theta^{(k)}]$\n\n对于 $t \\in \\mathcal{O}$，我们简单地有 $\\tilde{x}_t^{(k)} = x_t$ 和 $\\widetilde{x_t^2}^{(k)} = x_t^2$。\n\n为了找到这些矩对于 $t \\in \\mathcal{M}$ 的值，我们使用贝叶斯法则推导后验分布 $p(x_t \\mid y_t; \\theta^{(k)})$：\n$$\np(x_t \\mid y_t; \\theta^{(k)}) \\propto p(y_t \\mid x_t; \\theta^{(k)}) p(x_t)\n$$\n两者都是高斯分布。两个高斯概率密度函数（PDF）的乘积与另一个高斯 PDF 成正比。后验分布的指数部分是 $x_t$ 的二次型：\n$$\n-\\frac{1}{2} \\left[ \\frac{(y_t - \\beta_0^{(k)} - \\beta_1^{(k)} x_t)^2}{(\\sigma^2)^{(k)}} + \\frac{(x_t - m_0)^2}{s_0^2} \\right]\n$$\n通过对 $x_t$ 进行配方，我们发现后验分布 $p(x_t \\mid y_t; \\theta^{(k)})$ 是一个高斯分布 $\\mathcal{N}(\\mu_{t,\\text{post}}^{(k)}, (s_{t,\\text{post}}^2)^{(k)})$，其方差为：\n$$\n(s_{t,\\text{post}}^2)^{(k)} = \\left( \\frac{(\\beta_1^{(k)})^2}{(\\sigma^2)^{(k)}} + \\frac{1}{s_0^2} \\right)^{-1}\n$$\n其均值为：\n$$\n\\mu_{t,\\text{post}}^{(k)} = (s_{t,\\text{post}}^2)^{(k)} \\left( \\frac{\\beta_1^{(k)}(y_t - \\beta_0^{(k)})}{(\\sigma^2)^{(k)}} + \\frac{m_0}{s_0^2} \\right)\n$$\n所需的矩则为：\n$$\n\\tilde{x}_t^{(k)} = \\mu_{t,\\text{post}}^{(k)}\n$$\n$$\n\\widetilde{x_t^2}^{(k)} = \\text{Var}(x_t|y_t;\\theta^{(k)}) + (\\mathbb{E}[x_t|y_t;\\theta^{(k)}])^2 = (s_{t,\\text{post}}^2)^{(k)} + (\\mu_{t,\\text{post}}^{(k)})^2\n$$\n\n**M 步：最大化 Q 函数**\n\nM 步通过最大化 $Q(\\theta \\mid \\theta^{(k)})$ 来更新参数至 $\\theta^{(k+1)}$。这等价于最小化关于 $\\beta_0$ 和 $\\beta_1$ 的平方误差和项 $S(\\beta_0, \\beta_1)$：\n$$\nS(\\beta_0, \\beta_1) = \\sum_{t=1}^T \\left[ (y_t-\\beta_0)^2 - 2\\beta_1(y_t-\\beta_0)\\tilde{x}_t^{(k)} + \\beta_1^2 \\widetilde{x_t^2}^{(k)} \\right]\n$$\n将偏导数 $\\frac{\\partial S}{\\partial \\beta_0}$ 和 $\\frac{\\partial S}{\\partial \\beta_1}$ 设为零，得到加权最小二乘问题的正规方程：\n$$\n\\begin{pmatrix} T  \\sum_{t=1}^T \\tilde{x}_t^{(k)} \\\\ \\sum_{t=1}^T \\tilde{x}_t^{(k)}  \\sum_{t=1}^T \\widetilde{x_t^2}^{(k)} \\end{pmatrix}\n\\begin{pmatrix} \\beta_0^{(k+1)} \\\\ \\beta_1^{(k+1)} \\end{pmatrix}\n=\n\\begin{pmatrix} \\sum_{t=1}^T y_t \\\\ \\sum_{t=1}^T y_t \\tilde{x}_t^{(k)} \\end{pmatrix}\n$$\n求解这个 $2 \\times 2$ 系统可得到更新公式：\n$$\n\\beta_1^{(k+1)} = \\frac{T \\sum y_t \\tilde{x}_t^{(k)} - (\\sum y_t)(\\sum \\tilde{x}_t^{(k)})}{T \\sum \\widetilde{x_t^2}^{(k)} - (\\sum \\tilde{x}_t^{(k)})^2}\n$$\n$$\n\\beta_0^{(k+1)} = \\frac{1}{T} \\left( \\sum y_t - \\beta_1^{(k+1)} \\sum \\tilde{x}_t^{(k)} \\right)\n$$\n要更新 $\\sigma^2$，我们将 $\\frac{\\partial Q}{\\partial (\\sigma^2)}$ 设为 0，得到：\n$$\n(\\sigma^2)^{(k+1)} = \\frac{1}{T} S(\\beta_0^{(k+1)}, \\beta_1^{(k+1)})\n$$\n$$\n(\\sigma^2)^{(k+1)} = \\frac{1}{T} \\sum_{t=1}^T \\left[ (y_t - \\beta_0^{(k+1)})^2 - 2\\beta_1^{(k+1)}(y_t - \\beta_0^{(k+1)}) \\tilde{x}_t^{(k)} + (\\beta_1^{(k+1)})^2 \\widetilde{x_t^2}^{(k)} \\right]\n$$\n\n**算法初始化和预测**\n\n为参数 $\\theta^{(0)}$ 选择一个合适的初始值至关重要。\n- 如果有足够多的完整观测数据（$t \\in \\mathcal{O}$），我们可以通过对 $t \\in \\mathcal{O}$ 的 $y_t$ 和 $x_t$ 进行简单线性回归来初始化 $\\beta_0^{(0)}$ 和 $\\beta_1^{(0)}$。\n- 如果没有完整观测数据（如情况 B），数据中不存在估计 $\\beta_1$ 的信息。一个有原则的初始化是设置 $\\beta_1^{(0)}=0$，这意味着没有关系。$\\beta_0^{(0)}$ 于是为 $y$ 的样本均值，$(\\sigma^2)^{(0)}$ 为 $y$ 的样本方差。\n- $(\\sigma^2)^{(0)}$ 可以初始化为 $1.0$ 或初始回归的残差方差。\n\n在 EM 算法收敛到最终估计值 $(\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\sigma}^2)$ 之后，计算目标日的预测总能量消耗。对于目标日的每一分钟 $t$：\n- 如果 $x_t^{\\text{target}}$ 被观测到：预测的 $y_t = \\hat{\\beta}_0 + \\hat{\\beta}_1 x_t^{\\text{target}}$。\n- 如果 $x_t^{\\text{target}}$ 缺失：由于没有可用的 $y_t^{\\text{target}}$，我们使用 $x_t$ 的先验期望，即 $m_0$。预测的 $y_t$ 为 $\\mathbb{E}[y_t] = \\mathbb{E}[\\hat{\\beta}_0 + \\hat{\\beta}_1 x_t] = \\hat{\\beta}_0 + \\hat{\\beta}_1 \\mathbb{E}[x_t] = \\hat{\\beta}_0 + \\hat{\\beta}_1 m_0$。\n\n每日总消耗是这些分钟级预测值的总和。", "answer": "```python\nimport numpy as np\n\ndef em_algorithm(y_cal, x_cal, m0, s0_sq, n_iter=100):\n    \"\"\"\n    Implements the EM algorithm for a linear-Gaussian model with missing data.\n\n    Args:\n        y_cal (np.ndarray): Observed energy expenditure data.\n        x_cal (np.ndarray): Partially observed accelerometer data (with np.nan for missing).\n        m0 (float): Prior mean for x.\n        s0_sq (float): Prior variance for x.\n        n_iter (int): Number of EM iterations.\n\n    Returns:\n        tuple: Estimated parameters (beta0, beta1, sigma_sq).\n    \"\"\"\n    T = len(y_cal)\n    obs_indices = np.where(~np.isnan(x_cal))[0]\n    mis_indices = np.where(np.isnan(x_cal))[0]\n\n    # Initialization\n    if len(obs_indices) >= 2:\n        x_obs = x_cal[obs_indices]\n        y_obs = y_cal[obs_indices]\n        # Linear regression on complete cases\n        x_mean, y_mean = np.mean(x_obs), np.mean(y_obs)\n        ss_xy = np.sum((x_obs - x_mean) * (y_obs - y_mean))\n        ss_xx = np.sum((x_obs - x_mean) ** 2)\n        if ss_xx > 1e-9:\n            beta1 = ss_xy / ss_xx\n            beta0 = y_mean - beta1 * x_mean\n        else: # not enough variation in observed x\n            beta1 = 0.0\n            beta0 = y_mean\n        # Initialize sigma_sq based on residuals or simply 1.0\n        y_pred = beta0 + beta1 * x_obs\n        sigma_sq = np.mean((y_obs - y_pred)**2)\n        if sigma_sq  1e-9:\n            sigma_sq = 1.0\n    else: # No or too few complete cases (e.g., Case B)\n        beta1 = 0.0\n        beta0 = np.mean(y_cal)\n        sigma_sq = np.var(y_cal) if T > 1 else 1.0\n    \n    if sigma_sq  1e-9: # ensure variance is positive\n        sigma_sq = 1.0\n    \n    for _ in range(n_iter):\n        # --- E-Step ---\n        # For missing x, calculate posterior mean and variance\n        # then compute E[x] and E[x^2]\n        if sigma_sq = 1e-9 or s0_sq = 1e-9: # Check for invalid variances\n            # If variance collapses, we cannot proceed. This might happen with ill-conditioned data.\n            # Return current estimates.\n             break\n\n        s_t_post_sq_inv = (beta1**2 / sigma_sq) + (1 / s0_sq)\n        s_t_post_sq = 1.0 / s_t_post_sq_inv\n        \n        y_mis = y_cal[mis_indices]\n        mu_t_post = s_t_post_sq * (beta1 * (y_mis - beta0) / sigma_sq + m0 / s0_sq)\n\n        x_tilde = np.copy(x_cal)\n        x_sq_tilde = np.copy(x_cal)**2\n\n        x_tilde[mis_indices] = mu_t_post\n        x_sq_tilde[mis_indices] = s_t_post_sq + mu_t_post**2\n        \n        # --- M-Step ---\n        # Update beta0 and beta1\n        s_x = np.sum(x_tilde)\n        s_xx = np.sum(x_sq_tilde)\n        s_y = np.sum(y_cal)\n        s_yx = np.sum(y_cal * x_tilde)\n\n        # Solve the 2x2 system from the normal equations\n        # Denominator = T * S_xx - S_x^2\n        denominator = T * s_xx - s_x**2\n        if abs(denominator)  1e-9:\n            # This can happen if all x_tilde are the same.\n            # In this case, beta1 is not identifiable from the regression.\n            # Keep beta1 as is, or set to 0. We keep it to avoid oscillations.\n            pass\n        else:\n            beta1 = (T * s_yx - s_y * s_x) / denominator\n        \n        beta0 = (s_y - beta1 * s_x) / T\n\n        # Update sigma_sq\n        term1 = np.sum((y_cal - beta0)**2)\n        term2 = -2 * beta1 * np.sum((y_cal - beta0) * x_tilde)\n        term3 = beta1**2 * np.sum(x_sq_tilde)\n        sigma_sq = (term1 + term2 + term3) / T\n        \n        if sigma_sq = 1e-9: # Prevent variance from collapsing to zero\n            sigma_sq = 1e-9\n\n    return beta0, beta1, sigma_sq\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {\n            \"m0\": 0.5, \"s0_sq\": 1.0,\n            \"y_cal\": np.array([1.50, 1.75, 3.00, 0.20, 1.05, 2.30]),\n            \"x_cal\": np.array([0.20, np.nan, 1.00, -0.50, np.nan, 0.70]),\n            \"x_target\": np.array([0.00, 0.50, np.nan, -0.20, 0.90, np.nan])\n        },\n        # Case B\n        {\n            \"m0\": 0.0, \"s0_sq\": 1.0,\n            \"y_cal\": np.array([0.50, 1.25, -0.25, 2.00]),\n            \"x_cal\": np.array([np.nan, np.nan, np.nan, np.nan]),\n            \"x_target\": np.array([np.nan, np.nan, np.nan])\n        },\n        # Case C\n        {\n            \"m0\": 0.30, \"s0_sq\": 0.20,\n            \"y_cal\": np.array([2.30, 2.40, 2.005, 2.595, 2.20]),\n            \"x_cal\": np.array([0.30, np.nan, 0.00, 0.60, np.nan]),\n            \"x_target\": np.array([np.nan, 0.10, 0.20, np.nan])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m0 = case[\"m0\"]\n        s0_sq = case[\"s0_sq\"]\n        y_cal = case[\"y_cal\"]\n        x_cal = case[\"x_cal\"]\n        x_target = case[\"x_target\"]\n\n        # Run EM algorithm to estimate parameters\n        beta0_hat, beta1_hat, _ = em_algorithm(y_cal, x_cal, m0, s0_sq)\n\n        # Predict total energy expenditure for the target day\n        y_pred_total = 0.0\n        for xt in x_target:\n            if np.isnan(xt):\n                # Use prior mean m0 for missing x_target\n                y_pred_total += beta0_hat + beta1_hat * m0\n            else:\n                # Use observed x_target\n                y_pred_total += beta0_hat + beta1_hat * xt\n        \n        results.append(f\"{y_pred_total:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "4399026"}]}