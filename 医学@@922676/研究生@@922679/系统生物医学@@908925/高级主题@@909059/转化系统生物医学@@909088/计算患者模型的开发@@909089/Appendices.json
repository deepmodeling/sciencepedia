{"hands_on_practices": [{"introduction": "在我们将计算模型与患者数据进行拟合之前，必须首先回答一个根本问题：从我们计划收集的数据类型中，是否可能唯一地确定模型的参数？这个被称为结构可辨识性的属性，是对模型设计的关键初步检验。本练习将指导您使用一种形式化方法 [@problem_id:4335072]，即微分代数方法，来评估一个标准药代动力学模型的此项基本属性。", "problem": "患者药物药代动力学的数字孪生建立在双室线性质量平衡模型之上，该模型具有向中央室的静脉输注输入。设 $x_{1}(t)$ 表示中央室中的药物量，$x_{2}(t)$ 表示外周室中的药物量，$y(t)$ 表示测得的血浆浓度。该模型为\n$$\n\\begin{aligned}\n\\frac{d x_{1}}{d t} = -\\left(k_{10} + k_{12}\\right) x_{1} + k_{21} x_{2} + u(t),\\\\\n\\frac{d x_{2}}{d t} = k_{12} x_{1} - k_{21} x_{2},\\\\\ny(t) = \\frac{x_{1}(t)}{V},\n\\end{aligned}\n$$\n其中 $k_{10}0$ 是从中央室的消除速率，$k_{12}0$ 和 $k_{21}0$ 是室间转移速率，$V0$ 是中央分布容积，$u(t)$ 是已知的解析输注速率。假设测量是理想无噪声的，并且 $u(t)$ 在任何开区间上都不恒为零。\n\n使用微分代数方法，将状态方程和输出关系视为在以 $x_{1}(t)$、$x_{2}(t)$ 和 $y(t)$ 为变量的微分多项式环上生成一个微分理想，其系数在 $\\mathbb{R}(k_{10},k_{12},k_{21},V)$ 中，且导数为 $d/dt$。通过消除未观测状态 $x_{2}(t)$ 并将所有变量表示为 $y(t)$、$u(t)$ 及其时间导数的函数，推导一个形如下式的首一二阶输入-输出常微分方程 (ODE)\n$\ny''(t) + a_{1}\\, y'(t) + a_{0}\\, y(t) = b_{1}\\, u'(t) + b_{0}\\, u(t),\n$\n其中 $a_{1}$、$a_{0}$、$b_{1}$ 和 $b_{0}$ 是生理参数 $k_{10}$、$k_{12}$、$k_{21}$ 和 $V$ 的代数函数。然后，通过分析从参数到系数 $a_{1}$、$a_{0}$、$b_{1}$、$b_{0}$ 的映射，检查几乎所有输入下参数映射的唯一性，来论证结构可辨识性。\n\n最后，根据上述推导的输入-输出常微分方程的系数 $a_{1}$、$a_{0}$、$b_{1}$ 和 $b_{0}$，提供无量纲比率 $k_{12}/k_{21}$ 的封闭形式解析表达式。您的最终答案必须是单一表达式。无需四舍五入，也无需单位，因为所求比率为无量纲。", "solution": "该问题要求推导一个双室药代动力学模型的输入-输出常微分方程 (ODE)，分析其结构可辨识性，并给出一个参数比率的封闭形式表达式。\n\n### 步骤 1：问题验证\n\n首先根据所需标准对问题陈述进行验证。\n\n**1. 提取已知条件：**\n该模型由以下微分方程组和输出方程描述：\n状态方程：\n$$\n\\frac{d x_{1}}{d t} = -\\left(k_{10} + k_{12}\\right) x_{1} + k_{21} x_{2} + u(t) \\quad (\\text{式 1})\n$$\n$$\n\\frac{d x_{2}}{d t} = k_{12} x_{1} - k_{21} x_{2} \\quad (\\text{式 2})\n$$\n输出方程：\n$$\ny(t) = \\frac{x_{1}(t)}{V} \\quad (\\text{式 3})\n$$\n参数：$k_{10}0$，$k_{12}0$，$k_{21}0$，$V0$。\n变量：$x_{1}(t)$ 和 $x_{2}(t)$ 分别是中央室和外周室中的药物量。$y(t)$ 是测得的血浆浓度。\n输入：$u(t)$ 是一个已知的解析输注速率，在任何开区间上都不恒为零。\n任务：推导一个形如 $y''(t) + a_{1}\\, y'(t) + a_{0}\\, y(t) = b_{1}\\, u'(t) + b_{0}\\, u(t)$ 的首一二阶常微分方程，确定系数 $a_1, a_0, b_1, b_0$ 的表达式，论证结构可辨识性，并求出比率 $k_{12}/k_{21}$ 的表达式。\n\n**2. 验证：**\n- **科学依据：** 该问题使用标准的双室线性模型，这是药代动力学中的一个基本概念。使用微分代数和输入-输出关系进行可辨识性分析是系统理论和系统生物学中一种严谨且成熟的方法。\n- **适定性：** 问题陈述清晰，提供了所有必要的方程和约束。目标明确，可以利用给定信息实现。\n- **客观性：** 问题使用精确的数学语言表述，没有歧义或主观性。\n\n**3. 结论：**\n该问题是有效的。它具有科学性、适定性和客观性。我们可以继续进行求解。\n\n### 步骤 2：输入-输出常微分方程的推导\n\n目标是消除未观测的状态变量 $x_1(t)$ 和 $x_2(t)$，从而得到一个关联输出 $y(t)$ 和输入 $u(t)$ 的常微分方程。\n\n根据输出方程（式 3），我们将 $x_1(t)$ 表示为 $y(t)$ 的函数：\n$$\nx_{1}(t) = V y(t)\n$$\n对时间 $t$ 求导，得到 $x_1(t)$ 的导数：\n$$\n\\frac{d x_{1}}{d t} = V \\frac{d y}{d t} = V y'(t)\n$$\n将 $x_1(t)$ 及其导数的这些表达式代入第一个状态方程（式 1）：\n$$\nV y'(t) = -(k_{10} + k_{12}) V y(t) + k_{21} x_{2}(t) + u(t)\n$$\n我们可以重新整理这个方程，以求解未观测状态 $x_2(t)$：\n$$\nk_{21} x_{2}(t) = V y'(t) + (k_{10} + k_{12}) V y(t) - u(t) \\quad (\\text{式 4})\n$$\n为了消除 $x_2(t)$，我们对式 4 关于时间求导：\n$$\nk_{21} \\frac{d x_{2}}{d t} = V y''(t) + (k_{10} + k_{12}) V y'(t) - u'(t)\n$$\n现在我们可以从第二个状态方程（式 2）中代入 $\\frac{dx_2}{dt}$ 的表达式，即 $\\frac{dx_2}{dt} = k_{12}x_1 - k_{21}x_2$：\n$$\nk_{21} (k_{12} x_{1} - k_{21} x_{2}) = V y''(t) + (k_{10} + k_{12}) V y'(t) - u'(t)\n$$\n这得到：\n$$\nk_{12} k_{21} x_{1} - k_{21}^2 x_{2} = V y''(t) + (k_{10} + k_{12}) V y'(t) - u'(t)\n$$\n现在我们有两个变量需要消除，$x_1$ 和 $x_2$。我们使用 $x_1(t) = V y(t)$ 以及来自式 4 的 $k_{21} x_2(t)$ 的表达式。具体来说，我们需要 $k_{21}^2 x_2(t)$ 的表达式，这可以通过将式 4 乘以 $k_{21}$ 得到：\n$$\nk_{21}^2 x_{2}(t) = k_{21} \\left( V y'(t) + (k_{10} + k_{12}) V y(t) - u(t) \\right)\n$$\n将此式与 $x_1 = V y$ 代入微分后的方程：\n$$\nk_{12} k_{21} (V y) - k_{21} \\left( V y' + (k_{10} + k_{12}) V y - u \\right) = V y'' + (k_{10} + k_{12}) V y' - u'\n$$\n让我们展开并分组各项。除了包含 $u$ 和 $u'$ 的项外，所有项都含有一个因子 $V$。我们稍后将除以 $V$。\n$$\nk_{12} k_{21} V y - k_{21} V y' - k_{21}(k_{10} + k_{12}) V y + k_{21} u = V y'' + (k_{10} + k_{12}) V y' - u'\n$$\n将所有含 $y$ 及其导数的项移到左边，将含 $u$ 及其导数的项移到右边：\n$$\n-V y'' - k_{21} V y' - (k_{10} + k_{12}) V y' + [k_{12} k_{21} V - k_{21}(k_{10} + k_{12}) V] y = -k_{21} u - u'\n$$\n乘以 $-1$ 并除以 $V$（因为 $V0$）：\n$$\ny'' + (k_{21} + k_{10} + k_{12}) y' + [k_{21}(k_{10} + k_{12}) - k_{12} k_{21}] y = \\frac{1}{V} u' + \\frac{k_{21}}{V} u\n$$\n简化 $y(t)$ 的系数：\n$$\nk_{21}(k_{10} + k_{12}) - k_{12} k_{21} = k_{10} k_{21} + k_{12} k_{21} - k_{12} k_{21} = k_{10} k_{21}\n$$\n得到的首一二阶输入-输出常微分方程是：\n$$\ny''(t) + (k_{10} + k_{12} + k_{21}) y'(t) + (k_{10} k_{21}) y(t) = \\frac{1}{V} u'(t) + \\frac{k_{21}}{V} u(t)\n$$\n\n### 步骤 3：结构可辨识性分析\n\n通过将推导的常微分方程与一般形式 $y''(t) + a_{1} y'(t) + a_{0} y(t) = b_{1} u'(t) + b_{0} u(t)$ 进行比较，我们建立了从生理参数 $\\theta = (k_{10}, k_{12}, k_{21}, V)$ 到常微分方程系数 $p = (a_1, a_0, b_1, b_0)$ 的以下映射：\n$$\na_1 = k_{10} + k_{12} + k_{21}\n$$\n$$\na_0 = k_{10} k_{21}\n$$\n$$\nb_1 = \\frac{1}{V}\n$$\n$$\nb_0 = \\frac{k_{21}}{V}\n$$\n结构可辨识性要求此映射是单射的，这意味着我们可以从给定的系数集 $p$ 唯一地确定参数集 $\\theta$。让我们求解这个关于参数的代数方程组：\n\n从 $b_1 = 1/V$，我们求得 $V$：\n$$\nV = \\frac{1}{b_1}\n$$\n因为 $V  0$，所以要求 $b_1  0$。\n\n从 $b_0 = k_{21}/V$ 和 $V=1/b_1$，我们求得 $k_{21}$：\n$$\nk_{21} = b_0 V = b_0 \\left(\\frac{1}{b_1}\\right) = \\frac{b_0}{b_1}\n$$\n因为 $k_{21}  0$，所以要求 $b_0/b_1  0$。\n\n从 $a_0 = k_{10} k_{21}$，我们求得 $k_{10}$：\n$$\nk_{10} = \\frac{a_0}{k_{21}} = \\frac{a_0}{b_0/b_1} = \\frac{a_0 b_1}{b_0}\n$$\n因为 $k_{10}  0$，所以要求 $a_0 b_1 / b_0  0$。\n\n最后，从 $a_1 = k_{10} + k_{12} + k_{21}$，我们求得 $k_{12}$：\n$$\nk_{12} = a_1 - k_{10} - k_{21} = a_1 - \\frac{a_0 b_1}{b_0} - \\frac{b_0}{b_1}\n$$\n因为 $k_{12}  0$，所以要求 $a_1  \\frac{a_0 b_1}{b_0} + \\frac{b_0}{b_1}$。\n\n由于可以根据系数 $(a_1, a_0, b_1, b_0)$ 找到每个参数 $(k_{10}, k_{12}, k_{21}, V)$ 的唯一解，因此该映射是单射的。因此，该模型是结构可辨识的，前提是输入 $u(t)$ 足够丰富，能够从输入-输出数据中唯一确定系数，这一点由问题陈述（“已知的解析输注速率……在任何开区间上都不恒为零”）保证。\n\n### 步骤 4：比率 $k_{12}/k_{21}$ 的表达式\n\n最后的任务是根据系数 $a_1, a_0, b_1, b_0$ 提供无量纲比率 $k_{12}/k_{21}$ 的封闭形式表达式。使用在可辨识性分析中推导出的 $k_{12}$ 和 $k_{21}$ 的表达式：\n$$\nk_{12} = a_1 - \\frac{a_0 b_1}{b_0} - \\frac{b_0}{b_1}\n$$\n$$\nk_{21} = \\frac{b_0}{b_1}\n$$\n该比率为：\n$$\n\\frac{k_{12}}{k_{21}} = \\frac{a_1 - \\frac{a_0 b_1}{b_0} - \\frac{b_0}{b_1}}{\\frac{b_0}{b_1}}\n$$\n我们可以通过将分子乘以分母的倒数来简化此表达式：\n$$\n\\frac{k_{12}}{k_{21}} = \\left( a_1 - \\frac{a_0 b_1}{b_0} - \\frac{b_0}{b_1} \\right) \\left( \\frac{b_1}{b_0} \\right)\n$$\n分配项 $\\frac{b_1}{b_0}$：\n$$\n\\frac{k_{12}}{k_{21}} = a_1 \\left( \\frac{b_1}{b_0} \\right) - \\left( \\frac{a_0 b_1}{b_0} \\right) \\left( \\frac{b_1}{b_0} \\right) - \\left( \\frac{b_0}{b_1} \\right) \\left( \\frac{b_1}{b_0} \\right)\n$$\n$$\n\\frac{k_{12}}{k_{21}} = \\frac{a_1 b_1}{b_0} - \\frac{a_0 b_1^2}{b_0^2} - 1\n$$\n这是该比率的最终封闭形式表达式。", "answer": "$$\n\\boxed{\\frac{a_{1} b_{1}}{b_{0}} - \\frac{a_{0} b_{1}^{2}}{b_{0}^{2}} - 1}\n$$", "id": "4335072"}, {"introduction": "一旦我们有了一个结构可辨识的模型，下一步就是理解其预测如何依赖于每个参数。灵敏度分析使我们能够量化这种影响，揭示哪些参数对模型行为至关重要，以及参数估计的难易程度。本练习 [@problem_id:4335020] 介绍并应用了两种强大的技术——前向和伴随灵敏度分析——来计算药物浓度如何响应消除速率常数的变化。", "problem": "一个用于药物处置的计算性患者模型（数字孪生）是基于基本的质量平衡原理建立的，并表示为一个常微分方程（ODE）系统。设状态为 $x(t) \\in \\mathbb{R}^{n}$，其演化遵循 $\\frac{d x}{d t} = f\\!\\left(x(t), \\theta, u(t), t\\right)$，其中 $\\theta \\in \\mathbb{R}^{p}$ 表示模型参数，$u(t)$ 表示已知输入。定义局部灵敏度矩阵 $S(t) \\in \\mathbb{R}^{n \\times p}$ 为 $S_{ij}(t) = \\frac{\\partial x_i(t)}{\\partial \\theta_j}$。从链式法则和 ODE 定义出发，推导适用于前向灵敏度分析的 $S(t)$ 的演化方程和初始条件，并解释对于一个依赖于解的标量目标 $J$，基于伴随的方法如何能高效地计算 $\\frac{\\partial J}{\\partial \\theta}$。\n\n现在将其特化到一个口服给药的双室药代动力学（PK）数字孪生模型。胃肠道药物量 $x_1(t)$ 和中央室药物量 $x_2(t)$ 遵循\n$$\n\\frac{d x_1}{d t} = - k_a x_1, \\quad \\frac{d x_2}{d t} = k_a x_1 - k_e x_2,\n$$\n初始条件为 $x_1(0) = D$ 和 $x_2(0) = 0$。可观测量是血浆浓度 $C(t) = \\frac{x_2(t)}{V}$，其中 $V$ 是表观分布容积。使用前向灵敏度框架，推导在固定时间 $T$ 的局部灵敏度 $\\frac{\\partial C(T)}{\\partial k_e}$ 的闭式表达式，并解释对于终端目标 $J = C(T)$，伴随方法如何得到相同的表达式。\n\n最后，对于 $D = 100$ mg，$k_a = 1$ hour$^{-1}$，$k_e = 0.2$ hour$^{-1}$，$V = 10$ L 和 $T = 4$ hours，数值计算 $\\frac{\\partial C(T)}{\\partial k_e}$。将您的答案四舍五入到 4 位有效数字。以 mg·h/L 为单位表示最终的灵敏度。", "solution": "该问题具有科学依据、良定且客观。它提出了系统理论和计算生物学中的一个标准任务：对常微分方程（ODE）模型进行灵敏度分析的推导和应用。所有提供的信息都是自洽和一致的。\n\n我们首先探讨 ODE 系统的前向和伴随灵敏度分析的一般理论，然后将此框架应用于所提供的特定药代动力学模型。\n\n**1. 前向灵敏度分析**\n\n设系统由状态向量 $x(t) \\in \\mathbb{R}^{n}$ 定义，其演化遵循 ODE：\n$$\n\\frac{d x}{d t} = f(x(t), \\theta, u(t), t)\n$$\n初始条件为 $x(t_0) = x_0(\\theta)$。这里，$\\theta \\in \\mathbb{R}^{p}$ 是模型参数向量，$u(t)$ 是一个已知的输入函数。\n\n局部灵敏度矩阵 $S(t) \\in \\mathbb{R}^{n \\times p}$ 由其分量 $S_{ij}(t) = \\frac{\\partial x_i(t)}{\\partial \\theta_j}$ 定义。为了找到控制 $S(t)$ 的微分方程，我们将系统的 ODE 对参数 $\\theta_j$ 求导。假设有足够的光滑性可以交换微分顺序，我们有：\n$$\n\\frac{\\partial}{\\partial \\theta_j} \\left( \\frac{d x_i}{d t} \\right) = \\frac{d}{d t} \\left( \\frac{\\partial x_i}{\\partial \\theta_j} \\right) = \\frac{d S_{ij}}{d t}\n$$\n对 ODE 的右侧应用链式法则可得：\n$$\n\\frac{\\partial f_i}{\\partial \\theta_j} = \\sum_{k=1}^{n} \\frac{\\partial f_i}{\\partial x_k} \\frac{\\partial x_k}{\\partial \\theta_j} + \\frac{\\partial f_i}{\\partial \\theta_j} \\bigg|_{x, t}\n$$\n在此表达式中，第二项表示 $f_i$ 对 $\\theta_j$ 的显式偏导数。设 $J_x(t) = \\frac{\\partial f}{\\partial x}$ 为系统的雅可比矩阵，其分量为 $(J_x)_{ik} = \\frac{\\partial f_i}{\\partial x_k}$。灵敏度矩阵的第 $j$ 列 $s_j(t) = \\frac{\\partial x(t)}{\\partial \\theta_j}$ 的方程变为：\n$$\n\\frac{d s_j}{d t} = J_x(t) s_j(t) + \\frac{\\partial f}{\\partial \\theta_j}\n$$\n这是一个关于灵敏度的线性时变 ODE 系统。该系统的初始条件通过将初始状态 $x(t_0)$ 对 $\\theta_j$ 求导得到：\n$$\ns_j(t_0) = \\frac{\\partial x(t_0)}{\\partial \\theta_j} = \\frac{\\partial x_0(\\theta)}{\\partial \\theta_j}\n$$\n如果初始条件与参数无关，则 $s_j(t_0) = 0$。这个过程被称为前向灵敏度分析，因为灵敏度方程是随时间正向积分的，通常与原始状态方程一起求解。\n\n**2. 伴随灵敏度分析**\n\n考虑一个依赖于状态演化和参数的标量目标函数 $J$：\n$$\nJ = \\int_{t_0}^{T} g(x(t), \\theta, t) dt + h(x(T), \\theta)\n$$\n$J$ 关于参数 $\\theta$ 的梯度由下式给出：\n$$\n\\frac{dJ}{d\\theta_j} = \\int_{t_0}^{T} \\left( \\frac{\\partial g}{\\partial x} \\frac{\\partial x}{\\partial \\theta_j} + \\frac{\\partial g}{\\partial \\theta_j} \\right) dt + \\frac{\\partial h}{\\partial x(T)} \\frac{\\partial x(T)}{\\partial \\theta_j} + \\frac{\\partial h}{\\partial \\theta_j}\n$$\n这个计算需要灵敏度 $\\frac{\\partial x(t)}{\\partial \\theta_j} = s_j(t)$ 的完整时间历程。对于大量的参数 $p$，这将变得计算成本高昂，因为它需要求解 $p$ 个包含 $n$ 个灵敏度 ODE 的系统。\n\n伴随方法提供了一种更高效的替代方案。我们引入一个伴随变量（或协态）向量 $\\lambda(t) \\in \\mathbb{R}^n$，它满足以下终值问题：\n$$\n\\frac{d\\lambda}{dt} = -J_x(t)^T \\lambda(t) - \\left(\\frac{\\partial g}{\\partial x}\\right)^T, \\quad \\lambda(T) = \\left(\\frac{\\partial h}{\\partial x(T)}\\right)^T\n$$\n这是一个线性 ODE 系统，必须从 $t=T$ 到 $t=t_0$ 随时间反向积分。\n\n通过考虑乘积 $\\lambda(t)^T s_j(t)$ 的时间导数并进行积分，可以证明目标函数的梯度可以表示为：\n$$\n\\frac{dJ}{d\\theta_j} = \\int_{t_0}^{T} \\left( \\lambda(t)^T \\frac{\\partial f}{\\partial \\theta_j} + \\frac{\\partial g}{\\partial \\theta_j} \\right) dt + \\lambda(t_0)^T \\frac{\\partial x(t_0)}{\\partial \\theta_j} + \\frac{\\partial h}{\\partial \\theta_j}\n$$\n伴随方法的效率源于我们只需要随时间正向求解 $n$ 维的状态系统，然后随时间反向求解 $n$ 维的伴随系统。一旦 $x(t)$ 和 $\\lambda(t)$ 已知，就可以通过计算 $p$ 个一维积分（求积）来找到关于所有 $p$ 个参数的梯度。当参数数量 $p$ 远大于状态数量 $n$ 时，这比前向方法的效率要高得多。\n\n**3. 在双室 PK 模型上的应用：前向方法**\n\nPK 模型由下式给出：\n$$\n\\frac{d x_1}{d t} = - k_a x_1, \\quad \\frac{d x_2}{d t} = k_a x_1 - k_e x_2\n$$\n其中 $x_1(0) = D$ 且 $x_2(0) = 0$。可观测量为 $C(t) = x_2(t)/V$。我们想要求解 $\\frac{\\partial C(T)}{\\partial k_e}$。\n\n首先，我们求解状态 $x_1(t)$ 和 $x_2(t)$。$x_1(t)$ 的解是 $x_1(t) = D \\exp(-k_a t)$。将此代入 $x_2$ 的方程并求解线性 ODE（假设 $k_a \\neq k_e$）且 $x_2(0)=0$，得到：\n$$\nx_2(t) = \\frac{k_a D}{k_e - k_a} \\left( \\exp(-k_a t) - \\exp(-k_e t) \\right)\n$$\n我们感兴趣的量是浓度 $C(T) = x_2(T)/V$ 关于 $k_e$ 的灵敏度。即 $\\frac{\\partial C(T)}{\\partial k_e} = \\frac{1}{V} \\frac{\\partial x_2(T)}{\\partial k_e}$。在前向灵敏度框架内找到它的一个直接方法是，对 $x_2(t)$ 的解析解关于 $k_e$ 求导，然后在 $t=T$ 处求值。\n对 $x_2(t)$ 的表达式使用商法则：\n$$\n\\frac{\\partial x_2(t)}{\\partial k_e} = k_a D \\frac{\\partial}{\\partial k_e} \\left( \\frac{\\exp(-k_a t) - \\exp(-k_e t)}{k_e - k_a} \\right)\n$$\n$$\n\\frac{\\partial x_2(t)}{\\partial k_e} = k_a D \\left[ \\frac{(t \\exp(-k_e t))(k_e - k_a) - (\\exp(-k_a t) - \\exp(-k_e t))(1)}{(k_e - k_a)^2} \\right]\n$$\n$$\n\\frac{\\partial x_2(t)}{\\partial k_e} = \\frac{k_a D t \\exp(-k_e t)}{k_e - k_a} - \\frac{k_a D (\\exp(-k_a t) - \\exp(-k_e t))}{(k_e - k_a)^2}\n$$\n因此，在时间 $T$ 的浓度灵敏度为：\n$$\n\\frac{\\partial C(T)}{\\partial k_e} = \\frac{1}{V} \\frac{\\partial x_2(T)}{\\partial k_e} = \\frac{k_a D T \\exp(-k_e T)}{V(k_e-k_a)} - \\frac{k_a D (\\exp(-k_a T) - \\exp(-k_e T))}{V(k_e-k_a)^2}\n$$\n\n**4. 使用伴随方法进行验证**\n\n目标是终端目标，$J = C(T) = x_2(T)/V$。因此，$g=0$ 且 $h(x(T)) = x_2(T)/V$。参数是 $\\theta_j = k_e$。一般的伴随灵敏度公式得以简化。由于初始条件与 $k_e$ 无关，并且 $h$ 不是 $k_e$ 的显函数，我们有：\n$$\n\\frac{dJ}{dk_e} = \\int_{0}^{T} \\lambda(t)^T \\frac{\\partial f}{\\partial k_e} dt\n$$\n向量场为 $f = \\begin{pmatrix} -k_a x_1 \\\\ k_a x_1 - k_e x_2 \\end{pmatrix}$，所以 $\\frac{\\partial f}{\\partial k_e} = \\begin{pmatrix} 0 \\\\ -x_2 \\end{pmatrix}$。被积函数变为 $-\\lambda_2(t) x_2(t)$。\n\n伴随方程为：\n$\\frac{d\\lambda}{dt} = -J_x^T \\lambda$，其中 $J_x = \\begin{pmatrix} -k_a  0 \\\\ k_a  -k_e \\end{pmatrix}$。\n$$\n\\frac{d}{dt} \\begin{pmatrix} \\lambda_1 \\\\ \\lambda_2 \\end{pmatrix} = - \\begin{pmatrix} -k_a  k_a \\\\ 0  -k_e \\end{pmatrix} \\begin{pmatrix} \\lambda_1 \\\\ \\lambda_2 \\end{pmatrix} = \\begin{pmatrix} k_a \\lambda_1 - k_a \\lambda_2 \\\\ k_e \\lambda_2 \\end{pmatrix}\n$$\n终端条件是 $\\lambda(T) = (\\frac{\\partial h}{\\partial x(T)})^T = \\left(\\frac{\\partial}{\\partial x(T)} \\frac{x_2(T)}{V}\\right)^T = \\begin{pmatrix} 0  1/V \\end{pmatrix}^T$。\n因此，$\\lambda_1(T)=0$ 且 $\\lambda_2(T)=1/V$。\n从 $T$ 开始反向求解 $\\lambda_2$：$\\frac{d\\lambda_2}{dt} = k_e \\lambda_2$ 得到 $\\lambda_2(t) = \\lambda_2(T) \\exp(k_e(t-T)) = \\frac{1}{V} \\exp(k_e(t-T))$。\n\n灵敏度是积分：\n$$\n\\frac{dJ}{dk_e} = \\int_{0}^{T} -\\lambda_2(t) x_2(t) dt = \\int_{0}^{T} -\\frac{1}{V}\\exp(k_e(t-T)) \\left( \\frac{k_a D}{k_e-k_a} (\\exp(-k_a t) - \\exp(-k_e t)) \\right) dt\n$$\n$$\n= -\\frac{k_a D \\exp(-k_e T)}{V(k_e-k_a)} \\int_{0}^{T} \\exp(k_e t) (\\exp(-k_a t) - \\exp(-k_e t)) dt\n$$\n$$\n= -\\frac{k_a D \\exp(-k_e T)}{V(k_e-k_a)} \\int_{0}^{T} (\\exp((k_e-k_a)t) - 1) dt\n$$\n$$\n= -\\frac{k_a D \\exp(-k_e T)}{V(k_e-k_a)} \\left[ \\frac{\\exp((k_e-k_a)t)}{k_e-k_a} - t \\right]_0^T\n$$\n$$\n= -\\frac{k_a D \\exp(-k_e T)}{V(k_e-k_a)} \\left[ \\left(\\frac{\\exp((k_e-k_a)T)}{k_e-k_a} - T\\right) - \\left(\\frac{1}{k_e-k_a}\\right) \\right]\n$$\n$$\n= -\\frac{k_a D \\exp(-k_e T)}{V(k_e-k_a)^2} (\\exp(k_e T - k_a T) - 1) + \\frac{k_a D T \\exp(-k_e T)}{V(k_e-k_a)}\n$$\n$$\n= -\\frac{k_a D (\\exp(-k_a T) - \\exp(-k_e T))}{V(k_e-k_a)^2} + \\frac{k_a D T \\exp(-k_e T)}{V(k_e-k_a)}\n$$\n这个表达式与使用前向方法推导出的表达式完全相同，这表明两种方法得出了相同的结果。\n\n**5. 数值计算**\n\n我们使用给定值来计算 $\\frac{\\partial C(T)}{\\partial k_e}$ 的表达式：$D = 100\\,\\text{mg}$，$k_a = 1\\,\\text{h}^{-1}$，$k_e = 0.2\\,\\text{h}^{-1}$，$V = 10\\,\\text{L}$ 以及 $T = 4\\,\\text{h}$。\n$k_e - k_a = 0.2 - 1 = -0.8\\,\\text{h}^{-1}$。\n\n灵敏度是：\n$$\n\\frac{\\partial C(T)}{\\partial k_e} = \\frac{(1)(100)(4) \\exp(-0.2 \\times 4)}{10(-0.8)} - \\frac{(1)(100)(\\exp(-1 \\times 4) - \\exp(-0.2 \\times 4))}{10(-0.8)^2}\n$$\n$$\n= \\frac{400 \\exp(-0.8)}{-8} - \\frac{100(\\exp(-4) - \\exp(-0.8))}{10(0.64)}\n$$\n$$\n= -50 \\exp(-0.8) - \\frac{10}{0.64}(\\exp(-4) - \\exp(-0.8))\n$$\n$$\n= -50 \\exp(-0.8) - 15.625(\\exp(-4) - \\exp(-0.8))\n$$\n$$\n= (-50 + 15.625) \\exp(-0.8) - 15.625 \\exp(-4)\n$$\n$$\n= -34.375 \\exp(-0.8) - 15.625 \\exp(-4)\n$$\n使用指数函数的数值：\n$\\exp(-0.8) \\approx 0.44932896$\n$\\exp(-4) \\approx 0.01831564$\n$$\n\\frac{\\partial C(T)}{\\partial k_e} \\approx -34.375(0.44932896) - 15.625(0.01831564)\n$$\n$$\n\\approx -15.4455547 - 0.28618188\n$$\n$$\n\\approx -15.73173658\n$$\n四舍五入到 4 位有效数字，我们得到 $-15.73$。单位是 $(\\text{mg}/\\text{L}) / (\\text{h}^{-1}) = \\text{mg}\\cdot\\text{h}/\\text{L}$。", "answer": "$$\\boxed{-15.73}$$", "id": "4335020"}, {"introduction": "一个完整的计算患者模型不仅包括模型方程，还包括用于将其与数据拟合的统计方法。我们如何确信我们整个推断流程——从先验假设到数值算法——都正确无误？本动手编程练习 [@problem_id:4334996] 将让您实现基于仿真的校准（SBC），这是一种通过检查其统计有效性来诊断贝叶斯建模工作流程中问题的先进方法，从而建立对模型推断结果的信任。", "problem": "你的任务是设计并实现一个模拟校准 (SBC) 程序，用于在一个计算性患者模型 (数字孪生) 的贝叶斯流程中检测推断病态。考虑一个描述单室药代动力学的单参数机理数字孪生。设患者特异性清除率参数为 $k$，其先验为 $p(k)$，正向模型为 $f(t;k)$，该模型产生带噪声观测的浓度轨迹。生成部分包括：抽取 $k \\sim \\text{LogNormal}(\\mu,\\sigma_k)$，采样观测时间 $\\{t_i\\}_{i=1}^{n}$，并模拟带噪声的观测值 $y_i = f(t_i;k) + \\varepsilon_i$，其中 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma_y^2)$ 独立同分布。机理正向模型为 $f(t;k) = C_0 \\exp(-k t)$。推断部分使用贝叶斯法则生成后验 $p(k \\mid y)$ 和一个标量SBC统计量 $u = F(k \\mid y)$，该统计量定义为在真实样本值处评估的 $k$ 的后验累积分布函数。在一个正确指定的贝叶斯流程下，跨独立模拟的 $u$ 的分布预期在 $[0,1]$ 上是均匀的。偏差表明可能存在推断病态，例如错误指定的噪声或错误指定的正向模型。\n\n从贝叶斯法则出发，在不假设任何闭式后验的情况下，实现一个SBC程序，该程序：\n- 从生成性先验-似然中模拟 $S$ 个独立的配对 $(k^{(s)}, y^{(s)})$，并通过在 $k$ 的网格上数值逼近后验 $p(k \\mid y)$ 来计算 $u^{(s)} = F(k^{(s)} \\mid y^{(s)})$。\n- 对 $H_0$: $u^{(s)} \\sim \\text{Uniform}(0,1)$ 应用单样本柯尔莫哥洛夫-斯米尔诺夫 (KS) 检验，显著性水平为 $\\alpha = 0.01$。\n- 为每个测试用例报告一个布尔值，指示是否检测到病态 (拒绝 $H_0$)。\n\n后验必须在 $k$ 空间的一个网格上进行数值计算，使用先验密度 $p(k)$ 和由正向模型隐含的高斯似然。你可以使用数值积分来近似积分。所有算法选择都必须在你的解决方案中基于基本原理进行论证。\n\n测试套件。使用以下四个测试用例来运行SBC程序：\n- 案例 A (正常路径，正确指定): $S = 500$, $n = 30$, $t_i$ 在 $[0,8]$ 上等间距, $C_0 = 100$, $\\sigma_y = 5$, 先验 $\\log(k) \\sim \\mathcal{N}(\\mu=-2.0, \\sigma_k=0.3)$, 推断使用相同的 $\\sigma_y$ 和精确的正向模型 $f(t;k) = C_0 \\exp(-k t)$。\n- 案例 B (错误指定的噪声，欠分散): 与案例A相同，但推断流程在似然中使用 $\\tilde{\\sigma}_y = 1.0$，而数据是用 $\\sigma_y = 5$ 生成的。\n- 案例 C (错误指定的正向模型): $S = 500$, $n = 31$, $t_i$ 在 $[0,12]$ 上等间距, $C_0 = 100$, $\\sigma_y = 5$, 先验 $\\log(k) \\sim \\mathcal{N}(\\mu=-2.0, \\sigma_k=0.3)$, 推断在似然中假设线性化正向模型 $\\tilde{f}(t;k) = C_0 (1 - k t)$，而数据是用 $f(t;k) = C_0 \\exp(-k t)$ 生成的。\n- 案例 D (边界条件：稀疏、高噪声但正确指定): $S = 500$, $n = 3$, $t_i \\in \\{0.0, 0.5, 1.0\\}$, $C_0 = 100$, $\\sigma_y = 20$, 先验 $\\log(k) \\sim \\mathcal{N}(\\mu=-2.0, \\sigma_k=0.3)$, 推断使用相同的 $\\sigma_y$ 和精确的正向模型 $f(t;k) = C_0 \\exp(-k t)$。\n\n所有模拟都应使用固定的随机种子以确保可复现性。你的程序应生成单行输出，其中包含案例A–D的结果，按顺序以逗号分隔的列表形式放在方括号内，例如 $[r_A,r_B,r_C,r_D]$，其中每个 $r_{\\cdot}$ 是一个布尔值，指示在该案例中是否检测到病态 (在 $\\alpha = 0.01$ 时拒绝 $H_0$)。输出中不需要物理单位。不使用角度。不得使用百分比；统计显著性必须以小数形式 $\\alpha = 0.01$ 陈述。", "solution": "用户要求设计并实现一个模拟校准 (SBC) 程序，以验证一个用于单参数药代动力学模型的贝叶斯推断流程。该过程涉及从已知的真实情况模拟数据，在模拟数据上运行推断流程，然后检查得出的后验分布是否与用于生成它们的已知真实情况在统计上一致。\n\n### 理论框架\n\n问题的核心在于贝叶斯推断的应用及其通过SBC的验证。\n\n**1. 药代动力学模型的贝叶斯推断**\n目标是在给定一组浓度测量值 $Y = \\{y_i\\}_{i=1}^n$ 的情况下，推断患者特异性清除率参数 $k$。根据贝叶斯法则，给定数据 $Y$ 的 $k$ 的后验分布与似然和先验的乘积成正比：\n$$\np(k \\mid Y) \\propto p(Y \\mid k) \\, p(k)\n$$\n\n**生成模型组件：**\n- **先验分布, $p(k)$:** 参数 $k$ 被假定服从对数正态分布。这是通过规定其对数 $\\log(k)$ 服从正态分布来指定的：$\\log(k) \\sim \\mathcal{N}(\\mu, \\sigma_k^2)$。问题提供了 $\\mu = -2.0$ 和 $\\sigma_k = 0.3$。根据标准惯例，这被解释为 $\\sigma_k$ 代表 $\\log(k)$ 的正态分布的标准差。\n- **正向模型, $f(t;k)$:** 在时间 $t$ 某种物质的浓度由单室模型方程给出：$f(t;k) = C_0 \\exp(-k t)$，其中 $C_0$ 是初始浓度。\n- **似然, $p(Y \\mid k)$:** 观测值 $y_i$ 被建模为正向模型的输出加上独立同分布的高斯噪声：$y_i = f(t_i; k) + \\varepsilon_i$，其中 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma_y^2)$。整个数据集 $Y$ 的似然是每个观测概率的乘积：\n$$\np(Y \\mid k) = \\prod_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi\\sigma_y^2}} \\exp\\left(-\\frac{(y_i - f(t_i; k))^2}{2\\sigma_y^2}\\right)\n$$\n\n**2. 模拟校准 (SBC)**\nSBC 是一种用于诊断贝叶斯推断实现中病态的程序。其基本原理是，如果后验分布是从一个良好指定的模型中正确计算出来的，那么它们将是“已校准”的。这种校准通过检查秩统计量的分布来验证。\n\n对于单个模拟实例 $s$：\n1. 从先验分布中抽取一个“真实”参数 $k^{(s)}$：$k^{(s)} \\sim p(k)$。\n2. 使用此参数生成一个合成数据集 $Y^{(s)}$：$Y^{(s)} \\sim p(Y \\mid k^{(s)})$。\n3. 使用推断流程计算后验分布 $p(k \\mid Y^{(s)})$。\n4. 计算 SBC 统计量 $u^{(s)}$。该统计量是在真实参数 $k^{(s)}$ 处评估的后验累积分布函数 (CDF) 的值：\n   $$\n   u^{(s)} = F(k^{(s)} \\mid Y^{(s)}) = \\int_{0}^{k^{(s)}} p(k' \\mid Y^{(s)}) \\, dk'\n   $$\n如果整个流程（先验、似然和后验计算）被正确指定和实现，那么在多次模拟中收集到的一组秩统计量 $\\{u^{(s)}\\}_{s=1}^S$ 将在区间 $[0,1]$ 上均匀分布。\n\n**3. 假设检验**\n为了正式检查均匀性，我们陈述一个零假设：\n- $H_0$：SBC 统计量 $\\{u^{(s)}\\}$ 来自 $\\text{Uniform}(0,1)$ 分布。\n使用单样本柯尔莫哥洛夫-斯米尔诺夫 (KS) 检验来检验此假设。如果 KS 检验返回的 p 值小于所选的显著性水平 $\\alpha = 0.01$，我们就拒绝 $H_0$，并得出推断流程中存在病态的结论。\n\n### 数值实现策略\n\n由于后验分布 $p(k \\mid Y)$ 没有闭式解析解，因此必须进行数值逼近。问题指定了基于网格的方法。\n\n**1. 在网格上计算后验**\n- 在 $k$ 的合理范围内定义一个包含 $N$ 个点的离散网格：$\\{k_j\\}_{j=1}^N$。\n- 对于每个网格点 $k_j$，计算未归一化的后验。为保持数值稳定性，我们使用对数概率：\n  $$\n  \\log p_{\\text{unnorm}}(k_j) = \\log p(Y \\mid k_j) + \\log p(k_j)\n  $$\n  - 对数似然（忽略常数）为：\n    $$\n    \\log p(Y \\mid k_j) \\propto -\\frac{1}{2\\sigma_{y, \\text{inf}}^2} \\sum_{i=1}^{n} (y_i - f_{\\text{inf}}(t_i; k_j))^2\n    $$\n    此处，$\\sigma_{y, \\text{inf}}$ 和 $f_{\\text{inf}}$ 是*推断*流程所假设的噪声标准差和正向模型，它们可能与生成模型不同。\n  - 对数正态分布的对数先验（忽略常数）为：\n    $$\n    \\log p(k_j) \\propto -\\log(k_j) - \\frac{(\\log(k_j) - \\mu)^2}{2\\sigma_k^2}\n    $$\n- 将对数后验值减去其最大值后，通过指数运算转换回线性尺度，以防止数值下溢：$p_{\\text{unnorm}}(k_j) = \\exp(\\log p_{\\text{unnorm}}(k_j) - \\max(\\{\\log p_{\\text{unnorm}}\\}))$。\n- 然后将未归一化的后验进行归一化，以表示一个概率密度函数。这是通过除以其总积分来实现的，该积分使用梯形法则在网格上近似：\n  $$\n  p(k_j \\mid Y) = \\frac{p_{\\text{unnorm}}(k_j)}{\\int p_{\\text{unnorm}}(k) \\, dk} \\approx \\frac{p_{\\text{unnorm}}(k_j)}{\\text{trapezoid}(p_{\\text{unnorm}}, \\{k_j\\})}\n  $$\n\n**2. CDF 和 SBC 统计量计算**\n- 后验 CDF, $F(k \\mid Y)$，是通过使用累积梯形法则对归一化后验密度 $p(k \\mid Y)$ 进行累积积分来计算的。\n- SBC 统计量 $u^{(s)} = F(k^{(s)} \\mid Y^{(s)})$ 是通过在真实参数 $k^{(s)}$ 的位置对计算出的 CDF 值进行线性插值得到的。\n\n### 算法流程\n\n每个测试用例的总体算法如下：\n\n1.  为保证可复现性，设置一个固定的随机种子。\n2.  定义特定测试用例的参数：模拟次数 $S$、样本大小 $n$、时间点 $\\{t_i\\}$、初始浓度 $C_0$、数据生成参数 $(\\sigma_y, f)$ 和推断参数 $(\\tilde{\\sigma}_y, \\tilde{f})$。\n3.  初始化一个空列表 `U_stats`，用于存储 SBC 统计量。\n4.  执行一个循环 $S$ 次：\n    a.  从先验 $k \\sim \\text{LogNormal}(\\mu, \\sigma_k)$ 中抽取一个真实参数值 $k_{\\text{true}}$。\n    b.  使用生成性正向模型 $f(t;k_{\\text{true}})$ 和噪声 $\\sigma_y$ 生成一个合成数据集 $\\{y_i\\}$。\n    c.  在预定义的 $k$ 网格上，使用推断正向模型 $\\tilde{f}$ 和噪声参数 $\\tilde{\\sigma}_y$ 计算数值后验分布 $p(k \\mid \\{y_i\\})$。\n    d.  从后验密度计算后验 CDF。\n    e.  在 $k_{\\text{true}}$ 处对 CDF 进行插值以获得 SBC 统计量 $u$。将 $u$ 附加到 `U_stats`。\n5.  循环结束后，对收集到的 `U_stats` 与 `Uniform(0,1)` 分布进行单样本 KS 检验。\n6.  如果检验的 p 值小于 $\\alpha = 0.01$，则该测试用例的结果为 `True` (检测到病态)，否则为 `False`。\n7.  对所有四个测试用例重复此过程并报告结果。\n\n此程序严格测试了所假设的统计模型与推断机制之间的一致性。通过 KS 检验检测到的 SBC 统计量与均匀分布的偏差，为模型设定错误或实现错误提供了明确的信号。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import kstest\nfrom scipy.integrate import cumulative_trapezoid, trapezoid\n\ndef solve():\n    \"\"\"\n    Main function to run the Simulation-Based Calibration (SBC) procedure\n    for all specified test cases and print the results.\n    \"\"\"\n    # Set a global random seed for reproducibility of the entire simulation.\n    RANDOM_SEED = 42\n    rng = np.random.default_rng(RANDOM_SEED)\n\n    # Define a common grid for the parameter k for all computations.\n    # The prior log(k) ~ N(-2, 0.3^2) suggests k is concentrated around exp(-2) ~ 0.135.\n    # A grid covering several standard deviations on the log scale is appropriate.\n    # log(k) in [-2 - 5*0.3, -2 + 5*0.3] = [-3.5, -0.5] - k in [0.03, 0.61]\n    k_grid = np.linspace(0.01, 0.7, 1000)\n\n    # Common prior parameters for all cases\n    LOGK_MU = -2.0\n    LOGK_SIGMA = 0.3\n\n    # Define the test cases as a list of dictionaries.\n    test_cases_params = [\n        { # Case A: Correctly specified model (Happy Path)\n            \"S\": 500, \"n\": 30, \"t_range\": (0, 8),\n            \"C0\": 100.0, \"sigma_y_gen\": 5.0,\n            \"sigma_y_inf\": 5.0, \"f_inf_type\": \"exponential\"\n        },\n        { # Case B: Mis-specified noise (underdispersion in inference)\n            \"S\": 500, \"n\": 30, \"t_range\": (0, 8),\n            \"C0\": 100.0, \"sigma_y_gen\": 5.0,\n            \"sigma_y_inf\": 1.0, \"f_inf_type\": \"exponential\"\n        },\n        { # Case C: Mis-specified forward model\n            \"S\": 500, \"n\": 31, \"t_range\": (0, 12),\n            \"C0\": 100.0, \"sigma_y_gen\": 5.0,\n            \"sigma_y_inf\": 5.0, \"f_inf_type\": \"linear\"\n        },\n        { # Case D: Sparse, high-noise data (correctly specified)\n            \"S\": 500, \"n\": 3, \"t_values\": np.array([0.0, 0.5, 1.0]),\n            \"C0\": 100.0, \"sigma_y_gen\": 20.0,\n            \"sigma_y_inf\": 20.0, \"f_inf_type\": \"exponential\"\n        }\n    ]\n\n    results = []\n    alpha = 0.01\n\n    for params in test_cases_params:\n        # Generate time points based on case parameters\n        if \"t_range\" in params:\n            t_points = np.linspace(params[\"t_range\"][0], params[\"t_range\"][1], params[\"n\"])\n        else:\n            t_points = params[\"t_values\"]\n\n        # Run the SBC procedure for the current case\n        pathology_detected = run_sbc_for_case(\n            S=params[\"S\"],\n            t_points=t_points,\n            C0=params[\"C0\"],\n            sigma_y_gen=params[\"sigma_y_gen\"],\n            logk_mu=LOGK_MU,\n            logk_sigma=LOGK_SIGMA,\n            sigma_y_inf=params[\"sigma_y_inf\"],\n            f_inf_type=params[\"f_inf_type\"],\n            rng=rng,\n            k_grid=k_grid,\n            alpha=alpha\n        )\n        results.append(pathology_detected)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_sbc_for_case(S, t_points, C0, sigma_y_gen,\n                     logk_mu, logk_sigma,\n                     sigma_y_inf, f_inf_type,\n                     rng, k_grid, alpha):\n    \"\"\"\n    Runs the full SBC procedure for a single test case configuration.\n    Returns True if a pathology is detected, False otherwise.\n    \"\"\"\n    u_statistics = []\n    for _ in range(S):\n        # 1. Draw true parameter from prior: log(k) ~ N(mu, sigma^2)\n        k_true = np.exp(rng.normal(loc=logk_mu, scale=logk_sigma))\n\n        # 2. Generate synthetic data from the generative model\n        y_true = C0 * np.exp(-k_true * t_points)\n        y_observed = y_true + rng.normal(loc=0.0, scale=sigma_y_gen, size=t_points.shape)\n        \n        # 3. Compute SBC statistic (posterior CDF at k_true)\n        u_stat = compute_sbc_statistic(\n            k_true=k_true,\n            y_observed=y_observed,\n            t_points=t_points,\n            C0=C0,\n            logk_mu=logk_mu,\n            logk_sigma=logk_sigma,\n            sigma_y_inf=sigma_y_inf,\n            f_inf_type=f_inf_type,\n            k_grid=k_grid\n        )\n        u_statistics.append(u_stat)\n\n    # 4. Perform Kolmogorov-Smirnov test for uniformity\n    ks_statistic, p_value = kstest(np.array(u_statistics), 'uniform')\n    \n    # 5. Report pathology if H0 (uniformity) is rejected\n    return p_value  alpha\n\ndef compute_sbc_statistic(k_true, y_observed, t_points, C0,\n                        logk_mu, logk_sigma,\n                        sigma_y_inf, f_inf_type, k_grid):\n    \"\"\"\n    Computes the posterior distribution on a grid and returns the SBC statistic u.\n    \"\"\"\n    # Define inference forward model\n    if f_inf_type == \"exponential\":\n        f_inf = C0 * np.exp(-k_grid[:, np.newaxis] * t_points)\n    elif f_inf_type == \"linear\":\n        f_inf = C0 * (1 - k_grid[:, np.newaxis] * t_points)\n    else:\n        raise ValueError(\"Unknown inference model type\")\n\n    # Calculate log-likelihood for each k in the grid\n    # Sum of squared errors for each k\n    sse = np.sum((y_observed - f_inf)**2, axis=1)\n    log_likelihood = -sse / (2 * sigma_y_inf**2)\n\n    # Calculate log-prior for each k in the grid\n    # Log-Normal PDF for k where log(k) is Normal(mu, sigma)\n    log_prior = -np.log(k_grid) - (np.log(k_grid) - logk_mu)**2 / (2 * logk_sigma**2)\n    \n    # Calculate unnormalized log-posterior\n    log_posterior = log_likelihood + log_prior\n    \n    # Normalize posterior for numerical stability\n    log_posterior -= np.max(log_posterior)\n    posterior_unnorm = np.exp(log_posterior)\n    \n    # Normalize to a probability density function using trapezoidal rule\n    total_integral = trapezoid(posterior_unnorm, k_grid)\n    if total_integral == 0:\n        # If integral is zero (underflow or bad grid), cannot compute CDF.\n        # This can happen if the true k is far from the grid.\n        # Return a value that indicates failure, e.g., NaN or a random value.\n        # A random value is better to not bias the KS test.\n        return np.random.uniform(0, 1)\n        \n    posterior_pdf = posterior_unnorm / total_integral\n\n    # Compute the cumulative distribution function (CDF)\n    # cumulative_trapezoid returns N-1 values, so we prepend a 0 for the first grid point.\n    cdf_values = np.concatenate(([0.0], cumulative_trapezoid(posterior_pdf, k_grid)))\n\n    # Interpolate the CDF to find the value at k_true\n    u_stat = np.interp(k_true, k_grid, cdf_values)\n\n    # Clamp the result to [0, 1] to handle potential floating point inaccuracies\n    return np.clip(u_stat, 0.0, 1.0)\n\n\n# Execute the main simulation\nsolve()\n```", "id": "4334996"}]}