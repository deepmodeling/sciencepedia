{"hands_on_practices": [{"introduction": "本练习旨在培养癌症基因组学中的一项基本技能：解读测序数据中的变异等位基因频率（$VAF$）。理解肿瘤纯度、拷贝数变异以及突变发生的时间（例如，相对于全基因组加倍事件的先后顺序）等因素如何影响 $VAF$，对于重建肿瘤的演化历史至关重要。通过这项实践，您将巩固对这些定量关系的理解，并学会如何利用 $VAF$ 解读克隆结构 [@problem_id:4396552]。", "problem": "一个肿瘤样本包含一个主要恶性克隆与非恶性二倍体细胞的混合物。恶性细胞的比例（肿瘤纯度）为 $p=0.8$。在该恶性克隆的一个特定基因组片段中，发生了一次全基因组复制（WGD）事件，导致肿瘤细胞在该片段中的 WGD 后总拷贝数为 $C=4$。考虑该片段中的两种克隆性单核苷酸变异（SNV）情景：(i) SNV 在 WGD 之前获得，因此在 WGD 之后，它存在于 $C=4$ 个拷贝中的 $m=2$ 个上；(ii) SNV 在 WGD 之后获得，因此它存在于 $C=4$ 个拷贝中的 $m=1$ 个上。假设对肿瘤和正常细胞混合物中存在的所有等位基因进行无偏短读长测序抽样，并且正常细胞是二倍体，在该位点没有变异。使用混合抽样的第一性原理和变异等位基因频率（VAF）的定义（即携带变异等位基因的读段在某一位点的所有读段中所占的预期比例），推导 VAF 作为 $p$、$C$ 和 $m$ 的函数的表达式，然后计算所述两种情景下的预期 VAF。以有序对 $(\\text{VAF}_{\\text{pre-WGD}}, \\text{VAF}_{\\text{post-WGD}})$ 的形式提供最终数值答案，表示为保留四位有效数字的小数。不需要单位。", "solution": "该问题是有效的，因为它在科学上基于肿瘤基因组学的原理，问题提出得很好，有足够的信息得到唯一解，并且陈述客观。因此，我们可以进行推导。\n\n变异等位基因频率（$\\text{VAF}$）定义为在覆盖某一特定基因组位点的所有测序读段中，携带变异等位基因的读段所占的预期比例。在肿瘤和正常细胞的混合样本中，一个位点的总等位基因池是来自两种细胞类型的等位基因的加权总和。\n\n设 $p$ 为肿瘤纯度，即样本中恶性细胞的比例。因此，非恶性（正常）细胞的比例是 $1-p$。\n正常细胞是二倍体，意味着它们在任何常染色体位点的总拷贝数为 $C_N = 2$。\n在指定的基因组片段中，肿瘤细胞的总拷贝数为 $C$。\n一个肿瘤细胞中携带单核苷酸变异（SNV）的等位基因的拷贝数是 $m$。正常细胞不携带该变异。\n\n为了推导预期的 VAF，我们计算混合物中变异等位基因和总等位基因的比例贡献。假设从所有细胞中无偏抽样 DNA，混合物中该位点的总等位基因数量与来自每个群体的等位基因总和成正比。\n\n总等位基因数，我们称其比例度量为 $A_{\\text{total}}$，是来自肿瘤细胞和正常细胞贡献的总和：\n$$ A_{\\text{total}} \\propto (\\text{fraction of tumor cells} \\times \\text{copies per tumor cell}) + (\\text{fraction of normal cells} \\times \\text{copies per normal cell}) $$\n$$ A_{\\text{total}} \\propto p \\cdot C + (1-p) \\cdot C_N $$\n鉴于正常细胞是二倍体，$C_N=2$。因此，总等位基因的比例数为：\n$$ A_{\\text{total}} \\propto pC + 2(1-p) $$\n\n接下来，我们计算变异等位基因的总比例数 $A_{\\text{variant}}$。SNV 仅存在于肿瘤细胞中。在每个肿瘤细胞中，有 $m$ 个携带变异的等位基因拷贝。正常细胞贡献的变异等位基因为零。\n$$ A_{\\text{variant}} \\propto (\\text{fraction of tumor cells} \\times \\text{variant copies per tumor cell}) + (\\text{fraction of normal cells} \\times \\text{variant copies per normal cell}) $$\n$$ A_{\\text{variant}} \\propto p \\cdot m + (1-p) \\cdot 0 $$\n$$ A_{\\text{variant}} \\propto pm $$\n\n预期的 VAF 是变异等位基因的比例数与总等位基因的比例数之比：\n$$ \\text{VAF}(p, C, m) = \\frac{A_{\\text{variant}}}{A_{\\text{total}}} = \\frac{pm}{pC + 2(1-p)} $$\n这是预期 VAF 作为肿瘤纯度 $p$、肿瘤特异性总拷贝数 $C$ 和变异等位基因拷贝数 $m$ 的函数的通用表达式。\n\n现在，我们将此公式应用于给定的情景，使用所提供的值：$p=0.8$ 和 $C=4$。\n首先，我们计算分母，这在两种情景中是相同的：\n$$ \\text{Denominator} = pC + 2(1-p) = (0.8)(4) + 2(1-0.8) = 3.2 + 2(0.2) = 3.2 + 0.4 = 3.6 $$\n\n情景 (i)：SNV 在全基因组复制（WGD）之前获得。\n在一个二倍体细胞（WGD 之前）中，一个克隆性杂合突变发生在两条同源染色体中的一条上。WGD 后，所有染色体都被复制。因此，单个突变的等位基因被复制，导致肿瘤细胞中总共 $C=4$ 个等位基因中有 $m=2$ 个变异等位基因。\n使用 $m=2$：\n$$ \\text{VAF}_{\\text{pre-WGD}} = \\frac{pm}{\\text{Denominator}} = \\frac{(0.8)(2)}{3.6} = \\frac{1.6}{3.6} = \\frac{16}{36} = \\frac{4}{9} $$\n作为小数，这是 $0.444444...$。保留四位有效数字，$\\text{VAF}_{\\text{pre-WGD}} = 0.4444$。\n\n情景 (ii)：SNV 在 WGD 之后获得。\nWGD 已经发生，因此肿瘤细胞有 $C=4$ 个拷贝的染色体片段。然后一个新的克隆性突变仅在这四个拷贝中的一个上发生。因此，变异等位基因的数量为 $m=1$。\n使用 $m=1$：\n$$ \\text{VAF}_{\\text{post-WGD}} = \\frac{pm}{\\text{Denominator}} = \\frac{(0.8)(1)}{3.6} = \\frac{0.8}{3.6} = \\frac{8}{36} = \\frac{2}{9} $$\n作为小数，这是 $0.222222...$。保留四位有效数字，$\\text{VAF}_{\\text{post-WGD}} = 0.2222$。\n\n最终答案是有序对 $(\\text{VAF}_{\\text{pre-WGD}}, \\text{VAF}_{\\text{post-WGD}})$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.4444  0.2222\n\\end{pmatrix}\n}\n$$", "id": "4396552"}, {"introduction": "从静态快照转向动态演化，本练习将探讨如何量化克隆选择的驱动力：适应度差异。您将使用模拟的谱系条形码（lineage barcoding）数据，实现一种推断竞争细胞谱系相对生长率的方法。这项实践展示了一种用于实时测量演化过程的强大技术，帮助我们理解为何某些克隆能够在竞争中胜出 [@problem_id:4396518]。", "problem": "您正在使用谱系条形码技术，为肿瘤中的克隆谱系动力学建模。假设初始条形码多样性很大，有 $10^5$ 个不同的条形码，并且每个谱系都遵循连续时间的马尔萨斯增长模型。目标是根据观测到的条形码频率随时间变化的轨迹，推断谱系间的适应性差异，并计算选择系数。\n\n从以下基本原理出发：\n- 指数（马尔萨斯）增长：对于谱系 $i$，其绝对数量 $n_i(t)$ 随时间演变，遵循公式 $n_i(t) = n_i(0)\\,\\exp(r_i t)$，其中 $r_i$ 是谱系特异性指数增长率（在连续时间下的适应度，也称为马尔萨斯参数）。\n- 频率定义为 $f_i(t) = n_i(t) / \\sum_j n_j(t)$，并且在每个时间点 $t$ 都满足 $\\sum_i f_i(t) = 1$。\n- 由于总群体大小未知，经过对数转换的频率提供了一个加性结构，但该结构受到一个依时变动的归一化项的影响。\n\n您的任务是实现一个程序，该程序根据给定的时间点和观测到的条形码频率 $f_i(t_k)$，通过拟合一个与上述原理一致的模型，来推断所有谱系的增长率 $r_i$。由于观测到的仅是频率（而非绝对数量），您的公式必须解决内在的不可辨识性问题。这需要引入并消除任何必要的依时变动的归一化项，以分离出谱系特异性的增长项。在获得推断出的增长率 $r_i$ 后，计算选择系数 $s_i$。选择系数定义为谱系特异性增长率与同一测试案例中所有谱系平均增长率的偏差，即 $s_i = r_i - \\overline{r}$，其中 $\\overline{r}$ 是该测试案例中 $\\{r_i\\}$ 的算术平均值。以单位“天⁻¹”报告 $s_i$，结果为四舍五入到六位小数的十进制数。\n\n输入固定在您的程序中（无用户输入）。请使用以下测试套件。每个测试案例指定一个时间网格（单位：天）和一个观测到的条形码频率矩阵，其中行对应谱系，列对应时间点。频率矩阵的每一列之和在舍入误差范围内为 $1$，且所有频率都严格为正。您的程序必须为每个测试案例独立拟合模型，并为每个测试案例输出选择系数列表。\n\n测试套件：\n- 测试案例A（常规路径；三个具有不同增长率的谱系）：时间 $t = [0, 2, 4, 6]$ 天，频率\n  - 谱系 1: $[0.333333, 0.334502, 0.334942, 0.335617]$\n  - 谱系 2: $[0.266667, 0.272423, 0.278888, 0.285096]$\n  - 谱系 3: $[0.400000, 0.393075, 0.386170, 0.379287]$\n- 测试案例B（边界情况；增长率相同导致频率不随时间变化）：时间 $t = [0, 1, 2, 3]$ 天，频率\n  - 谱系 1: $[0.500000, 0.500000, 0.500000, 0.500000]$\n  - 谱系 2: $[0.300000, 0.300000, 0.300000, 0.300000]$\n  - 谱系 3: $[0.200000, 0.200000, 0.200000, 0.200000]$\n- 测试案例C（边缘情况；四个谱系中一个稀有但快速增长的谱系）：时间 $t = [0, 3, 6]$ 天，频率\n  - 谱系 1: $[0.142835, 0.141609, 0.140375]$\n  - 谱系 2: $[0.142835, 0.139501, 0.136226]$\n  - 谱系 3: $[0.000143, 0.000146, 0.000149]$\n  - 谱系 4: $[0.714187, 0.718744, 0.723250]$\n\n要求：\n1. 推导基础：从 $n_i(t) = n_i(0)\\,\\exp(r_i t)$ 和频率定义 $f_i(t) = n_i(t)/\\sum_j n_j(t)$ 出发。引入处理未知总群体大小所需的任何依时变动的归一化项，以确保仅从 $f_i(t_k)$ 就能辨识谱系特异性参数。使用基于这些原理的估算方法（例如，在对数频率域中进行最小二乘拟合，以处理依时变动的归一化）。\n2. 输出规格：对于每个测试案例，计算选择系数列表 $s_i = r_i - \\overline{r}$，单位为“天⁻¹”。将每个 $s_i$ 四舍五入到六位小数。您的程序应生成单行输出，其中包含三个测试案例（A、B和C）的选择系数列表，格式为单个Python风格的列表的列表，并采用六位小数的定点格式，例如：[[sA1,sA2,sA3],[sB1,sB2,sB3],[sC1,sC2,sC3,sC4]]。\n3. 不涉及角度。单位：时间单位为天，增长率和选择系数单位为天⁻¹。最终数值以十进制形式表示（无百分号）。\n\n您的解决方案必须具有通用性，并且必须能精确处理所给定的所有三个测试案例。最终打印输出必须是符合上述精确格式的单行文本（无额外文字）。", "solution": "该问题要求从肿瘤克隆频率的时间序列数据中，推断谱系特异性增长率及相应的选择系数。该解决方案基于马尔萨斯增长原理，旨在解决仅有频率数据时绝对增长率固有的不可辨识性问题。\n\n出发点是每个克隆谱系 $i$ 的指数增长模型，其在时间 $t$ 的绝对群体大小 $n_i(t)$ 由下式给出：\n$$n_i(t) = n_i(0) e^{r_i t}$$\n此处，$n_i(0)$ 是谱系 $i$ 在时间 $t=0$ 时的初始群体大小，$r_i$ 是马尔萨斯参数，代表谱系特异性的连续时间增长率，即适应度。\n\n观测数据由频率 $f_i(t)$ 构成，而非绝对数量。谱系 $i$ 的频率定义为其在总群体中所占的比例：\n$$f_i(t) = \\frac{n_i(t)}{\\sum_j n_j(t)} = \\frac{n_i(0) e^{r_i t}}{\\sum_j n_j(0) e^{r_j t}}$$\n此公式的一个关键特性是，频率 $f_i(t)$ 对于所有增长率的统一平移是不变的。如果我们将每个 $r_j$ 替换为 $r'_j = r_j + c$（其中 $c$ 为任意常数），频率保持不变：\n$$f_i(t) = \\frac{n_i(0) e^{(r_i+c) t}}{\\sum_j n_j(0) e^{(r_j+c) t}} = \\frac{n_i(0) e^{r_i t} e^{ct}}{e^{ct} \\sum_j n_j(0) e^{r_j t}} = \\frac{n_i(0) e^{r_i t}}{\\sum_j n_j(0) e^{r_j t}}$$\n这表明仅从频率数据无法辨识绝对增长率 $r_i$。只有增长率之间的差异 $r_i-r_j$ 才能被确定。\n\n为了分离出这些可辨识的量，我们可以分析任意两个谱系 $i$ 和 $k$ 之间的频率比。对该比率取自然对数，可以有效地消除包含未知总群体大小的公分母：\n$$\\ln\\left(\\frac{f_i(t)}{f_k(t)}\\right) = \\ln\\left(\\frac{n_i(0) e^{r_i t}}{n_k(0) e^{r_k t}}\\right) = \\ln\\left(\\frac{n_i(0)}{n_k(0)}\\right) + (r_i - r_k)t$$\n认识到 $f_i(0) = n_i(0)/\\sum_j n_j(0)$，第一项可以用初始频率表示：$\\ln(n_i(0)/n_k(0)) = \\ln(f_i(0)/f_k(0))$。因此，我们得到了一个关于时间 $t$ 的线性关系：\n$$y_i(t) = \\ln\\left(\\frac{f_i(t)}{f_k(t)}\\right) = \\ln\\left(\\frac{f_i(0)}{f_k(0)}\\right) + (r_i - r_k)t$$\n该方程具有直线形式 $y=a+bt$，其中变量 $y_i(t)$ 是频率的对数比，自变量是时间 $t$，截距 $a$ 是初始频率的对数比，斜率 $b$ 是相对增长率 $r_i - r_k$。\n\n该公式为估算相对增长率提供了一条直接路径。我们选择一个参考谱系，例如 $k=1$，然后对于其他每个谱系 $i \\in \\{2, \\dots, N\\}$，我们可以通过对观测数据点 $(t_j, \\ln[f_i(t_j)/f_1(t_j)])$ 进行简单线性回归来估计斜率 $m_i = r_i - r_1$。对于参考谱系本身（$i=1$），相对增长率根据定义为 $r_1 - r_1 = 0$。设 $\\hat{m}_i$ 为谱系 $i$ 相对于谱系 1 的估计斜率。因此，我们得到一个估计的相对增长率向量 $\\hat{\\mathbf{m}} = [\\hat{m}_1, \\hat{m}_2, \\dots, \\hat{m}_N]$，其中 $\\hat{m}_1 = 0$。\n\n问题要求计算选择系数，定义为 $s_i = r_i - \\bar{r}$，其中 $\\bar{r} = \\frac{1}{N}\\sum_j r_j$ 是平均增长率。我们可以用估计的相对增长率 $\\hat{m}_i$ 来表示估计的选择系数 $\\hat{s}_i$。$r_i$ 的一个估计可以写为 $\\hat{r}_i = \\hat{r}_1 + \\hat{m}_i$，其中 $\\hat{r}_1$ 是参考谱系的未知绝对增长率。那么，估计的平均增长率为：\n$$\\bar{\\hat{r}} = \\frac{1}{N}\\sum_{j=1}^N \\hat{r}_j = \\frac{1}{N}\\sum_{j=1}^N (\\hat{r}_1 + \\hat{m}_j) = \\hat{r}_1 + \\frac{1}{N}\\sum_{j=1}^N \\hat{m}_j = \\hat{r}_1 + \\bar{\\hat{m}}$$\n谱系 $i$ 的估计选择系数为：\n$$\\hat{s}_i = \\hat{r}_i - \\bar{\\hat{r}} = (\\hat{r}_1 + \\hat{m}_i) - (\\hat{r}_1 + \\bar{\\hat{m}}) = \\hat{m}_i - \\bar{\\hat{m}}$$\n这个 $\\hat{s}_i$ 的最终表达式与未知的 $\\hat{r}_1$ 以及参考谱系的选择无关，提供了一个完全可辨识且可计算的量。\n\n算法如下：\n1.  对每个测试案例，取时间点 $T = [t_1, \\dots, t_M]$ 和频率矩阵 $F$，其中 $F_{ij} = f_i(t_j)$。\n2.  选择一个参考谱系（例如，第一个谱系，$i=1$）。\n3.  对于每个谱系 $i=2, \\dots, N$，计算其在每个时间点的频率与参考谱系频率的对数比：$y_{ij} = \\ln(F_{ij}/F_{1j})$。\n4.  对于每个谱系 $i=2, \\dots, N$，对向量 $(y_{i1}, \\dots, y_{iM})$ 与时间向量 $(t_1, \\dots, t_M)$ 进行简单线性回归。该回归的斜率即为估计值 $\\hat{m}_i = \\widehat{r_i-r_1}$。\n5.  构建相对增长率向量 $\\hat{\\mathbf{m}} = [0, \\hat{m}_2, \\dots, \\hat{m}_N]$。\n6.  计算该向量的平均值：$\\bar{\\hat{m}} = \\frac{1}{N}\\sum_{j=1}^N \\hat{m}_j$。\n7.  计算每个谱系的选择系数为 $\\hat{s}_i = \\hat{m}_i - \\bar{\\hat{m}}$。\n8.  按要求将每个 $\\hat{s}_i$ 四舍五入到六位小数。\n此过程独立应用于每个测试案例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Infers selection coefficients from barcode frequency trajectories.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            # Test Case A (happy-path; three lineages with distinct growth)\n            \"times\": [0, 2, 4, 6],\n            \"freqs\": [\n                [0.333333, 0.334502, 0.334942, 0.335617],\n                [0.266667, 0.272423, 0.278888, 0.285096],\n                [0.400000, 0.393075, 0.386170, 0.379287]\n            ]\n        },\n        {\n            # Test Case B (boundary; identical growth)\n            \"times\": [0, 1, 2, 3],\n            \"freqs\": [\n                [0.500000, 0.500000, 0.500000, 0.500000],\n                [0.300000, 0.300000, 0.300000, 0.300000],\n                [0.200000, 0.200000, 0.200000, 0.200000]\n            ]\n        },\n        {\n            # Test Case C (edge; rare but fast-growing lineage)\n            \"times\": [0, 3, 6],\n            \"freqs\": [\n                [0.142835, 0.141609, 0.140375],\n                [0.142835, 0.139501, 0.136226],\n                [0.000143, 0.000146, 0.000149],\n                [0.714187, 0.718744, 0.723250]\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        times = np.array(case[\"times\"])\n        freqs = np.array(case[\"freqs\"])\n        \n        num_lineages = freqs.shape[0]\n        \n        # Choose the first lineage (index 0) as the reference.\n        ref_freqs = freqs[0, :]\n        \n        # m_hats will store the estimated relative growth rates (r_i - r_ref).\n        m_hats = np.zeros(num_lineages)\n        \n        # For lineage i  0, calculate its growth rate relative to the reference.\n        for i in range(1, num_lineages):\n            # Calculate log-ratio of frequencies against the reference lineage.\n            # Small positive frequencies ensure log is defined.\n            log_ratios = np.log(freqs[i, :] / ref_freqs)\n            \n            # Perform a simple linear regression of log_ratios vs. times.\n            # np.polyfit with degree 1 returns [slope, intercept]. We need the slope.\n            slope = np.polyfit(times, log_ratios, 1)[0]\n            m_hats[i] = slope\n            \n        # m_hats[0] is already 0, which corresponds to r_ref - r_ref = 0.\n        \n        # Calculate the mean of these relative growth rates.\n        m_bar = np.mean(m_hats)\n        \n        # The selection coefficient s_i is calculated as m_i - m_bar.\n        s_coeffs = m_hats - m_bar\n        \n        # Format results to six decimal places for fixed-point representation.\n        formatted_s_coeffs = [f\"{s:.6f}\" for s in s_coeffs]\n        \n        # Create the string representation of the list of coefficients for this case.\n        case_result_str = f\"[{','.join(formatted_s_coeffs)}]\"\n        all_results.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "4396518"}, {"introduction": "对靶向治疗的耐药性常常涉及细胞内信号网络的重编程。本练习深入探讨了这一机制，要求您从时间序列数据中推断信号通路中的因果关系变化。通过将格兰杰因果（Granger causality）分析应用于模拟的磷酸化蛋白质组学数据，您将学习如何识别“反馈解除”（relief-of-feedback）现象，这是肿瘤为规避药物抑制而采用的一种关键适应性策略 [@problem_id:4396571]。", "problem": "给定一个信号反馈回路的概念模型，该模型与系统生物医学中的肿瘤异质性、演化和耐药网络机制相关。考虑一个下游激酶 $X$（例如，细胞外信号调节激酶磷酸化），以及一个上游受体 $Y$（例如，表皮生长因子受体磷酸化）。在使用 v-raf 鼠肉瘤病毒癌基因同源物 B (BRAF) 抑制剂治疗前，$X$ 对 $Y$ 施加负反馈影响。治疗后，对 $X$ 的抑制解除了这种反馈，可能使 $Y$ 得以重新激活。您的任务是基于时间序列因果分析的基本原理，实现一个推断程序，使用格兰杰因果关系 (Granger causality, GC) 或动态贝叶斯网络 (Dynamic Bayesian Network, DBN) 建模来检测反馈解除再激活现象的存在。对于此问题，您必须实现格兰杰因果关系。\n\n使用的基本和模型假设：\n- 格兰杰因果关系 (GC) 由预测能力的提升来定义：如果时间序列 $X$ 的过去值在 $Y$ 自身过去值之外，为预测 $Y$ 提供了额外的预测能力，则称 $X$ 是 $Y$ 的格兰杰原因。\n- 使用具有固定滞后阶数 $p$ 的向量自回归 (VAR) 模型来捕捉 $X$ 和 $Y$ 之间的线性依赖关系。\n- 在误差独立和方差有限的标准条件下，普通最小二乘法 (OLS) 是线性回归的有效估计量。\n\n数据生成协议：\n- 对于每个测试用例，您必须在治疗前和治疗后两个阶段为 $X$ 和 $Y$ 生成时间分辨的磷酸化蛋白质组学信号。使用具有指定系数的二阶 ($p=2$) VAR 模型进行模拟：\n  - 治疗前动态：\n    - $$Y_t = a_{y1} Y_{t-1} + a_{y2} Y_{t-2} + c_{xy1} X_{t-1} + c_{xy2} X_{t-2} + b_y + \\varepsilon^y_t,$$\n    - $$X_t = a_{x1} X_{t-1} + a_{x2} X_{t-2} + d_{y1} Y_{t-1} + b_x + \\varepsilon^x_t.$$\n  - 治疗后动态：\n    - 通过将 $a_{x1}$ 和 $b_x$ 乘以一个因子 $s_x \\in (0,1]$ 来应用 BRAF 抑制剂，同时保持其他系数不变。从治疗前阶段的最后状态继续模拟，以模仿连续性。\n- 噪声项 $\\varepsilon^y_t$ 和 $\\varepsilon^x_t$ 是独立的、均值为零、标准差分别为 $\\sigma_y$ 和 $\\sigma_x$ 的高斯随机变量。\n\n推断程序要求：\n- 对于每个阶段（治疗前和治疗后），使用 $p=2$ 拟合两个关于 $Y_t$ 的 OLS 模型：\n  1. 仅使用 $Y$ 滞后项的受限模型：$$Y_t = \\alpha_0 + \\sum_{i=1}^{p} \\alpha_i Y_{t-i} + \\eta_t.$$\n  2. 使用 $Y$ 和 $X$ 滞后项的非受限模型：$$Y_t = \\beta_0 + \\sum_{i=1}^{p} \\beta_i Y_{t-i} + \\sum_{i=1}^{p} \\gamma_i X_{t-i} + \\nu_t.$$\n- 通过从受限模型到非受限模型时残差平方和的减少分数来量化包含 $X$ 带来的预测增益，定义为 $$G = \\frac{\\mathrm{SSR}_{\\mathrm{restricted}} - \\mathrm{SSR}_{\\mathrm{unrestricted}}}{\\mathrm{SSR}_{\\mathrm{restricted}}}.$$\n- 通过非受限模型中对 $X$ 滞后项的估计系数之和来确定反馈影响的符号，$$S = \\sum_{i=1}^{p} \\hat{\\gamma}_i.$$ 负的 $S$ 表示从 $X$到 $Y$ 的抑制性反馈。\n\n反馈解除再激活检测标准：\n- 当且仅当以下所有条件都成立时，宣布存在反馈解除再激活：\n  1. 治疗前的预测增益满足 $G_{\\mathrm{pre}} \\geq \\tau_{\\mathrm{gain}}$，且影响为负 $S_{\\mathrm{pre}}  0$。\n  2. 治疗后的预测增益满足 $G_{\\mathrm{post}} \\leq \\lambda \\, G_{\\mathrm{pre}}$，表明抑制后从 $X$ 到 $Y$ 的预测影响强度下降。\n  3. 治疗后 $Y$ 的平均水平增加，$\\overline{Y}_{\\mathrm{post}} \\geq (1+\\rho) \\, \\overline{Y}_{\\mathrm{pre}}$，反映了与反馈解除一致的再激活。\n- 使用固定阈值 $\\tau_{\\mathrm{gain}} = 0.05$，$\\lambda = 0.5$ 和 $\\rho = 0.1$。\n\n角度单位不适用。由于结果是布尔值，输出中不需要物理时间单位。所有输出必须是无单位的布尔值。\n\n测试套件（四个用例以确保覆盖：理想路径、无解除、高噪声、小样本边界）：\n- 用例 1（理想路径，强负反馈和强抑制）：\n  - $T_{\\mathrm{pre}}=300$, $T_{\\mathrm{post}}=300$, $p=2$, $\\sigma_y=0.1$, $\\sigma_x=0.1$,\n  - $a_{y1}=0.7$, $a_{y2}=0.2$, $a_{x1}=0.6$, $a_{x2}=0.1$, $c_{xy1}=-0.8$, $c_{xy2}=0.0$, $d_{y1}=0.1$, $b_y=1.0$, $b_x=0.5$, $s_x=0.2$.\n- 用例 2（无解除，弱反馈和无抑制）：\n  - $T_{\\mathrm{pre}}=300$, $T_{\\mathrm{post}}=300$, $p=2$, $\\sigma_y=0.15$, $\\sigma_x=0.15$,\n  - $a_{y1}=0.6$, $a_{y2}=0.2$, $a_{x1}=0.6$, $a_{x2}=0.1$, $c_{xy1}=-0.2$, $c_{xy2}=0.0$, $d_{y1}=0.1$, $b_y=1.0$, $b_x=0.5$, $s_x=1.0$.\n- 用例 3（高噪声，强抑制但可检测性降低）：\n  - $T_{\\mathrm{pre}}=300$, $T_{\\mathrm{post}}=300$, $p=2$, $\\sigma_y=0.5$, $\\sigma_x=0.5$,\n  - $a_{y1}=0.7$, $a_{y2}=0.2$, $a_{x1}=0.6$, $a_{x2}=0.1$, $c_{xy1}=-0.7$, $c_{xy2}=0.0$, $d_{y1}=0.1$, $b_y=1.0$, $b_x=0.5$, $s_x=0.2$.\n- 用例 4（小样本边界，中等噪声）：\n  - $T_{\\mathrm{pre}}=60$, $T_{\\mathrm{post}}=60$, $p=2$, $\\sigma_y=0.3$, $\\sigma_x=0.3$,\n  - $a_{y1}=0.7$, $a_{y2}=0.2$, $a_{x1}=0.6$, $a_{x2}=0.1$, $c_{xy1}=-0.7$, $c_{xy2}=0.0$, $d_{y1}=0.1$, $b_y=1.0$, $b_x=0.5$, $s_x=0.2$.\n\n您的程序必须：\n- 使用固定的随机种子以保证可复现性。\n- 模拟治疗前片段，然后使用缩放后的抑制剂参数继续进入治疗后片段。\n- 对于每个用例，计算 $G_{\\mathrm{pre}}$、$S_{\\mathrm{pre}}$、$G_{\\mathrm{post}}$ 以及 $\\overline{Y}_{\\mathrm{pre}}$、$\\overline{Y}_{\\mathrm{post}}$，然后根据上述标准确定一个布尔值，以指示是否存在反馈解除再激活。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$$[r_1,r_2,r_3,r_4]$$），其中每个 $r_i$ 是对应于用例 $i$ 检测结果的布尔值。", "solution": "此问题的目标是在一个简化的肿瘤信号通路模型中，实现一个用于检测“反馈解除再激活”现象的计算程序。这一现象对于理解靶向治疗的获得性耐药至关重要。所指定的方法基于格兰杰因果关系（Granger causality），这是时间序列分析中的一个概念，用于推断变量之间的方向性影响。我们将使用向量自回归 (VAR) 模型来捕捉系统的动态。\n\n问题的核心涉及一个两步过程：首先，模拟代表上游受体 $Y$ 和下游激酶 $X$ 在治疗前和治疗后条件下活动的时间序列数据；其次，分析这些数据以推断从 $X$ 到 $Y$ 的因果关系的变化。\n\n**1. 通过向量自回归 (VAR) 进行数据模拟**\n\n我们使用一个指定为 $p=2$ 的二阶向量自回归模型来模拟系统的动态。系统在时间 $t$ 的状态由 $Y_t$ 和 $X_t$ 的值定义。\n\n在治疗前阶段，系统的演化由以下耦合差分方程组控制：\n$$Y_t = a_{y1} Y_{t-1} + a_{y2} Y_{t-2} + c_{xy1} X_{t-1} + c_{xy2} X_{t-2} + b_y + \\varepsilon^y_t$$\n$$X_t = a_{x1} X_{t-1} + a_{x2} X_{t-2} + d_{y1} Y_{t-1} + b_x + \\varepsilon^x_t$$\n在这里，系数 $a_{y1}, a_{y2}, a_{x1}, a_{x2}$ 代表自回归依赖性（自身影响），而 $c_{xy1}, c_{xy2}$ 代表过去的 $X$ 对当前 $Y$ 的影响，$d_{y1}$ 代表过去的 $Y$ 对当前 $X$ 的影响。项 $b_y$ 和 $b_x$ 是常数偏置。项 $\\varepsilon^y_t$ 和 $\\varepsilon^x_t$ 是独立同分布的噪声过程，分别从高斯分布 $\\mathcal{N}(0, \\sigma_y^2)$ 和 $\\mathcal{N}(0, \\sigma_x^2)$ 中抽取。$c_{xy}$ 系数之和为负值表示从 $X$ 到 $Y$ 的抑制性反馈。\n\n治疗后阶段模拟了靶向激酶 $X$ 的 BRAF 抑制剂的效果。这是通过将自回归系数 $a_{x1}$ 和偏置项 $b_x$ 乘以一个因子 $s_x \\in (0,1]$ 来模拟的。此修改降低了 $X$ 的活性。模拟从治疗前阶段的最终状态连续进行，以确保时间上的一致性。\n\n**2. 使用普通最小二乘法 (OLS) 推断因果影响**\n\n为了评估序列 $X$ 的过去值是否为预测序列 $Y$ 的未来值提供了统计上显著的信息，我们采用格兰杰因果关系检验框架。这涉及比较两个关于 $Y_t$ 的线性回归模型：\n\n1.  **受限模型：** 该模型仅使用 $Y_t$ 自身的过去值（滞后项）进行预测。对于滞后阶数 $p=2$，模型为：\n    $$Y_t = \\alpha_0 + \\alpha_1 Y_{t-1} + \\alpha_2 Y_{t-2} + \\eta_t$$\n    系数 $\\alpha_i$ 使用普通最小二乘法 (OLS) 进行估计，以最小化残差平方和 $\\mathrm{SSR}_{\\mathrm{restricted}} = \\sum \\hat{\\eta}_t^2$。\n\n2.  **非受限模型：** 该模型将 $Y$ 和 $X$ 的过去值都作为预测变量：\n    $$Y_t = \\beta_0 + \\beta_1 Y_{t-1} + \\beta_2 Y_{t-2} + \\gamma_1 X_{t-1} + \\gamma_2 X_{t-2} + \\nu_t$$\n    同样，系数 $\\beta_i$ 和 $\\gamma_i$ 通过 OLS 进行估计，得到最小残差平方和 $\\mathrm{SSR}_{\\mathrm{unrestricted}} = \\sum \\hat{\\nu}_t^2$。\n\n推断过程分别对治疗前和治疗后的时间序列数据执行。\n\n**3. 反馈和再激活的量化**\n\n两个模型之间的比较使我们能够量化 $X$ 对 $Y$ 的影响。\n\n-   **预测增益 ($G$)：** 通过包含 $X$ 项带来的预测准确性提升，由残差平方和的减少分数来衡量：\n    $$G = \\frac{\\mathrm{SSR}_{\\mathrm{restricted}} - \\mathrm{SSR}_{\\mathrm{unrestricted}}}{\\mathrm{SSR}_{\\mathrm{restricted}}}$$\n    更大的 $G$ 值表示从 $X$ 到 $Y$ 的预测影响更强。\n\n-   **影响符号 ($S$)：** 反馈的性质（抑制性 vs. 激活性）由非受限模型中 $X$ 滞后项的估计系数之和的符号决定：\n    $$S = \\sum_{i=1}^{p} \\hat{\\gamma}_i = \\hat{\\gamma}_1 + \\hat{\\gamma}_2$$\n    $S  0$ 的值平均表示从 $X$ 到 $Y$ 的负反馈或抑制性反馈。\n\n**4. 反馈解除再激活的检测标准**\n\n如果基于上述推导出的指标的三个特定条件同时满足，则宣布存在反馈解除再激活现象。这些标准将生物学假设形式化：\n\n1.  **治疗前负反馈：** 治疗前必须存在从 $X$ 到 $Y$ 的足够强的负反馈。这通过预测增益 $G_{\\mathrm{pre}}$ 超过阈值 $\\tau_{\\mathrm{gain}}$ 并且影响符号为负 $S_{\\mathrm{pre}}  0$ 来体现。\n    $$G_{\\mathrm{pre}} \\geq \\tau_{\\mathrm{gain}} \\quad \\text{and} \\quad S_{\\mathrm{pre}}  0$$\n    其中 $\\tau_{\\mathrm{gain}} = 0.05$。\n\n2.  **治疗后反馈减少：** 对 $X$ 的抑制必须导致其对 $Y$ 影响的显著减少。如果治疗后的预测增益 $G_{\\mathrm{post}}$ 远小于治疗前的增益，则证实了这一点。\n    $$G_{\\mathrm{post}} \\leq \\lambda \\, G_{\\mathrm{pre}}$$\n    其中 $\\lambda = 0.5$。\n\n3.  **治疗后 Y 的再激活：** 从 $X$ 来的负反馈的解除应导致 $Y$ 的活动水平上升。这通过比较治疗前后 $Y$ 的平均水平来验证。\n    $$\\overline{Y}_{\\mathrm{post}} \\geq (1+\\rho) \\, \\overline{Y}_{\\mathrm{pre}}$$\n    其中 $\\rho = 0.1$。\n\n**5. 计算实现**\n\n对于每个测试用例，算法按以下步骤进行：\n-   设置固定随机种子以确保可复现性。\n-   根据指定的 VAR 参数生成包含治疗前和治疗后阶段的 $X$ 和 $Y$ 的连续时间序列。\n-   将完整的时间序列划分为治疗前和治疗后片段进行分析。\n-   对每个片段，应用 OLS 程序拟合受限和非受限模型，并从中计算 $\\mathrm{SSR}$ 值。\n-   为治疗前阶段计算指标 $G$ 和 $S$，为治疗后阶段计算 $G$。同时计算平均水平 $\\overline{Y}_{\\mathrm{pre}}$ 和 $\\overline{Y}_{\\mathrm{post}}$。\n-   评估检测标准的三个条件，为测试用例得出最终的布尔结果。\n-   将所有四个测试用例的结果汇编成一个列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef perform_inference(X_data, Y_data, p):\n    \"\"\"\n    Performs Granger causality inference using OLS.\n\n    Args:\n        X_data (np.ndarray): Time series for variable X.\n        Y_data (np.ndarray): Time series for variable Y.\n        p (int): Lag order.\n\n    Returns:\n        tuple: A tuple containing:\n            - G (float): Predictive gain.\n            - S (float): Sum of influence coefficients.\n    \"\"\"\n    num_points = len(Y_data)\n    num_samples = num_points - p\n\n    if num_samples = 1 + 2 * p: # Not enough data points to fit the unrestricted model\n        return 0.0, 0.0\n\n    # Target variable for regression\n    y_target = Y_data[p:]\n\n    # --- Restricted Model: Y_t ~ 1 + Y_{t-1} + ... ---\n    M_restr = np.ones((num_samples, p + 1))\n    for i in range(p):\n        M_restr[:, i + 1] = Y_data[p - (i + 1) : num_points - (i + 1)]\n\n    _, ssr_restr_list, _, _ = np.linalg.lstsq(M_restr, y_target, rcond=None)\n    ssr_restr = ssr_restr_list[0] if len(ssr_restr_list) > 0 else np.sum((y_target - np.mean(y_target))**2)\n\n    # --- Unrestricted Model: Y_t ~ 1 + Y_lags + X_lags ---\n    M_unrestr = np.ones((num_samples, 1 + 2 * p))\n    # Y lags\n    for i in range(p):\n        M_unrestr[:, i + 1] = Y_data[p - (i + 1) : num_points - (i + 1)]\n    # X lags\n    for i in range(p):\n        M_unrestr[:, p + i + 1] = X_data[p - (i + 1) : num_points - (i + 1)]\n\n    coeffs_unrestr, ssr_unrestr_list, _, _ = np.linalg.lstsq(M_unrestr, y_target, rcond=None)\n    ssr_unrestr = ssr_unrestr_list[0] if len(ssr_unrestr_list) > 0 else np.sum((y_target - np.mean(y_target))**2)\n    \n    # Calculate G (predictive gain)\n    if ssr_restr == 0:\n        G = 0.0 if ssr_unrestr == 0 else 1.0\n    else:\n        G = (ssr_restr - ssr_unrestr) / ssr_restr\n\n    # Calculate S (sum of influence coefficients)\n    # The coefficients for X lags are the last p elements\n    S = np.sum(coeffs_unrestr[p + 1:])\n\n    return G, S\n\ndef simulate_var(params):\n    \"\"\"\n    Simulates time-series data from a VAR(p) model for pre- and post-treatment.\n    \"\"\"\n    T_pre, T_post, p = params['T_pre'], params['T_post'], params['p']\n    sigma_y, sigma_x = params['sigma_y'], params['sigma_x']\n    \n    total_duration = T_pre + T_post\n    X = np.zeros(total_duration + p)\n    Y = np.zeros(total_duration + p)\n    \n    noise_y = np.random.normal(0, sigma_y, total_duration)\n    noise_x = np.random.normal(0, sigma_x, total_duration)\n\n    # Pre-treatment parameters\n    a_y1, a_y2 = params['a_y1'], params['a_y2']\n    c_xy1, c_xy2 = params['c_xy1'], params['c_xy2']\n    b_y = params['b_y']\n    a_x1_pre, a_x2 = params['a_x1'], params['a_x2']\n    d_y1 = params['d_y1']\n    b_x_pre = params['b_x']\n    \n    # Post-treatment parameters (inhibited)\n    s_x = params['s_x']\n    a_x1_post = a_x1_pre * s_x\n    b_x_post = b_x_pre * s_x\n    \n    for t in range(p, total_duration + p):\n        # Determine which set of parameters to use\n        if t  T_pre + p:\n            a_x1_current = a_x1_pre\n            b_x_current = b_x_pre\n        else:\n            a_x1_current = a_x1_post\n            b_x_current = b_x_post\n            \n        noise_idx = t - p\n        \n        Y[t] = (a_y1 * Y[t-1] + a_y2 * Y[t-2] +\n                c_xy1 * X[t-1] + c_xy2 * X[t-2] +\n                b_y + noise_y[noise_idx])\n                \n        X[t] = (a_x1_current * X[t-1] + a_x2 * X[t-2] +\n                d_y1 * Y[t-1] +\n                b_x_current + noise_x[noise_idx])\n                \n    return X, Y\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Use a fixed random seed for reproducibility.\n    np.random.seed(42)\n\n    test_cases = [\n        { # Case 1\n            \"T_pre\": 300, \"T_post\": 300, \"p\": 2, \"sigma_y\": 0.1, \"sigma_x\": 0.1,\n            \"a_y1\": 0.7, \"a_y2\": 0.2, \"a_x1\": 0.6, \"a_x2\": 0.1,\n            \"c_xy1\": -0.8, \"c_xy2\": 0.0, \"d_y1\": 0.1, \"b_y\": 1.0, \"b_x\": 0.5, \"s_x\": 0.2\n        },\n        { # Case 2\n            \"T_pre\": 300, \"T_post\": 300, \"p\": 2, \"sigma_y\": 0.15, \"sigma_x\": 0.15,\n            \"a_y1\": 0.6, \"a_y2\": 0.2, \"a_x1\": 0.6, \"a_x2\": 0.1,\n            \"c_xy1\": -0.2, \"c_xy2\": 0.0, \"d_y1\": 0.1, \"b_y\": 1.0, \"b_x\": 0.5, \"s_x\": 1.0\n        },\n        { # Case 3\n            \"T_pre\": 300, \"T_post\": 300, \"p\": 2, \"sigma_y\": 0.5, \"sigma_x\": 0.5,\n            \"a_y1\": 0.7, \"a_y2\": 0.2, \"a_x1\": 0.6, \"a_x2\": 0.1,\n            \"c_xy1\": -0.7, \"c_xy2\": 0.0, \"d_y1\": 0.1, \"b_y\": 1.0, \"b_x\": 0.5, \"s_x\": 0.2\n        },\n        { # Case 4\n            \"T_pre\": 60, \"T_post\": 60, \"p\": 2, \"sigma_y\": 0.3, \"sigma_x\": 0.3,\n            \"a_y1\": 0.7, \"a_y2\": 0.2, \"a_x1\": 0.6, \"a_x2\": 0.1,\n            \"c_xy1\": -0.7, \"c_xy2\": 0.0, \"d_y1\": 0.1, \"b_y\": 1.0, \"b_x\": 0.5, \"s_x\": 0.2\n        }\n    ]\n\n    results = []\n    \n    # Thresholds for detection criterion\n    tau_gain = 0.05\n    lambda_val = 0.5\n    rho = 0.1\n\n    for case_params in test_cases:\n        p = case_params['p']\n        T_pre = case_params['T_pre']\n        T_post = case_params['T_post']\n\n        X_series, Y_series = simulate_var(case_params)\n\n        # Pre-treatment analysis\n        X_pre_segment = X_series[0 : T_pre + p]\n        Y_pre_segment = Y_series[0 : T_pre + p]\n        G_pre, S_pre = perform_inference(X_pre_segment, Y_pre_segment, p)\n        mean_Y_pre = np.mean(Y_series[p : T_pre + p])\n        \n        # Post-treatment analysis\n        # Segment starts at T_pre to include last p points of pre-treatment as initial lags\n        X_post_segment = X_series[T_pre : T_pre + T_post + p]\n        Y_post_segment = Y_series[T_pre : T_pre + T_post + p]\n        G_post, _ = perform_inference(X_post_segment, Y_post_segment, p)\n        mean_Y_post = np.mean(Y_series[T_pre + p:])\n\n        # Apply detection criterion\n        cond1 = (G_pre >= tau_gain) and (S_pre  0)\n        cond2 = (G_post = lambda_val * G_pre)\n        cond3 = (mean_Y_post >= (1 + rho) * mean_Y_pre)\n        \n        detection_result = cond1 and cond2 and cond3\n        results.append(detection_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4396571"}]}