{"hands_on_practices": [{"introduction": "识别合成致死的第一步是量化协同效应，即两种扰动（如药物或基因敲除）的组合效果是否超过了它们的独立效应之和。Bliss 独立模型为此提供了一个经典的零假设，它假定在没有相互作用的情况下，组合的存活率是单个药物存活率的乘积。这个练习将指导您根据细胞生长速率的实验数据，计算Bliss协同效应分数，并根据明确的操作标准来判断药物组合是否表现出合成致死特性 [@problem_id:4354444]。", "problem": "一个大小为 $N_0$ 的细胞群体在各种条件下均遵循指数增殖规律，这与在无资源限制情况下充分混合群体的第一性原理相符：$N(t) = N_0 \\exp(\\mu t)$，其中 $N(t)$ 是时间 $t$ 时的细胞数量，$\\mu$ 是单位细胞净增长率。在一项评估潜在合成致死效应的药物组合实验中，在 $t = 72$ 小时内测量得到以下净增长率（单位为 $\\text{h}^{-1}$）：\n- 对照组（载体）：$\\mu_C = \\frac{\\ln 2}{24}$。\n- 单独使用药物 A：$\\mu_A = 0.015$。\n- 单独使用药物 B：$\\mu_B = 0.020$。\n- 组合 A+B：$\\mu_{AB} = -0.005$。\n\n定义在条件 $X \\in \\{A, B, AB\\}$ 下的标准化存活率为比率 $W_X = \\frac{N_X(t)}{N_C(t)}$，其中 $N_C(t)$ 是在时间 $t$ 的对照组细胞计数。在效应独立（Bliss 独立性）的假设下，无相互作用时的预期组合存活率等于各单药存活率的乘积。Bliss 协同作用评分定义为在时间 $t$ 观测到的组合存活率与此独立性预期的偏差。\n\n仅使用指数生长定律和独立性原理，计算在 $t = 72$ 小时时的 Bliss 协同作用评分。将您的答案四舍五入至四位有效数字，并以无单位的小数形式报告。\n\n此外，采用以下操作性标准来判断合成致死：如果 (i) 两种单药均非致死性，量化为 $W_A > \\theta$ 和 $W_B > \\theta$ (其中 $\\theta = 0.2$)，(ii) 该组合是致死性的，量化为 $W_{AB} \\le \\lambda$ (其中 $\\lambda = 0.1$)，并且 (iii) Bliss 偏差为严格负值，则该组合被称为合成致死的。根据您计算出的量，确定该组合是否在这些标准下符合合成致死的条件。您最终报告的答案应仅为按要求四舍五入的 Bliss 协同作用评分；最终答案中不要包含任何单位或分类标签。", "solution": "问题要求计算一个药物组合的 Bliss 协同作用评分，并根据一组给定的标准评估该组合是否为合成致死。出发点是细胞群体的指数生长定律。\n\n首先，我将验证问题陈述。\n**步骤 1：提取已知信息**\n- 细胞生长模型：$N(t) = N_0 \\exp(\\mu t)$\n- 分析时间点：$t = 72$ 小时\n- 净增长率（$\\text{h}^{-1}$）：\n  - 对照组：$\\mu_C = \\frac{\\ln 2}{24}$\n  - 药物 A：$\\mu_A = 0.015$\n  - 药物 B：$\\mu_B = 0.020$\n  - 组合 A+B：$\\mu_{AB} = -0.005$\n- 标准化存活率定义：$W_X = \\frac{N_X(t)}{N_C(t)}$，其中 $X \\in \\{A, B, AB\\}$\n- Bliss 独立性模型：预期组合存活率 $W_{AB, \\text{exp}} = W_A \\cdot W_B$\n- Bliss 协同作用评分定义：观测到的组合存活率（$W_{AB, \\text{obs}}$）与独立性预期（$W_{AB, \\text{exp}}$）之间的偏差。\n- 合成致死标准：\n  - (i) 非致死性单药：$W_A > \\theta$ 且 $W_B > \\theta$，其中 $\\theta = 0.2$。\n  - (ii) 致死性组合：$W_{AB} \\le \\lambda$，其中 $\\lambda = 0.1$。\n  - (iii) 协同相互作用：Bliss 偏差为严格负值。\n- 最终答案要求：报告四舍五入至四位有效数字的 Bliss 协同作用评分。\n\n**步骤 2：使用提取的已知信息进行验证**\n该问题具有科学依据，使用了来自定量药理学和系统生物学的标准模型（指数生长）和概念（Bliss 独立性、协同作用评分）。所提供的增长率对于体外细胞培养实验是物理上现实的；例如，$\\mu_C$ 对应于 24 小时的倍增时间，这是一个常见值。该问题定义明确，为得到唯一解提供了所有必要的定义、常数和数据。语言客观而精确。没有内部矛盾或信息缺失。该问题并非微不足道，因为它需要仔细应用所提供的定义并进行多步计算。\n\n**步骤 3：结论与行动**\n问题有效。我将继续进行完整解答。\n\n在时间 $t$，条件 $X$ 下的标准化存活率 $W_X$ 定义为该条件下细胞数量与对照组条件下细胞数量的比值。使用指数生长定律，这可以表示为增长率的函数：\n$$W_X(t) = \\frac{N_X(t)}{N_C(t)} = \\frac{N_0 \\exp(\\mu_X t)}{N_0 \\exp(\\mu_C t)} = \\exp((\\mu_X - \\mu_C) t)$$\n该表达式对 $X \\in \\{A, B, AB\\}$ 均有效。分析在 $t=72$ 小时进行。\n\n首先，我们计算单药的存活率 $W_A$ 和 $W_B$。\n对于药物 A：\n$$W_A = \\exp\\left((\\mu_A - \\mu_C)t\\right) = \\exp\\left(\\left(0.015 - \\frac{\\ln 2}{24}\\right) \\cdot 72\\right)$$\n$$W_A = \\exp\\left(0.015 \\cdot 72 - \\frac{\\ln 2}{24} \\cdot 72\\right) = \\exp(1.08 - 3\\ln 2) = \\exp(1.08) \\exp(-\\ln(2^3)) = \\frac{\\exp(1.08)}{8}$$\n对于药物 B：\n$$W_B = \\exp\\left((\\mu_B - \\mu_C)t\\right) = \\exp\\left(\\left(0.020 - \\frac{\\ln 2}{24}\\right) \\cdot 72\\right)$$\n$$W_B = \\exp\\left(0.020 \\cdot 72 - \\frac{\\ln 2}{24} \\cdot 72\\right) = \\exp(1.44 - 3\\ln 2) = \\exp(1.44) \\exp(-\\ln 8) = \\frac{\\exp(1.44)}{8}$$\n\n接下来，我们计算组合的观测存活率 $W_{AB, \\text{obs}}$。\n$$W_{AB, \\text{obs}} = \\exp\\left((\\mu_{AB} - \\mu_C)t\\right) = \\exp\\left(\\left(-0.005 - \\frac{\\ln 2}{24}\\right) \\cdot 72\\right)$$\n$$W_{AB, \\text{obs}} = \\exp\\left(-0.005 \\cdot 72 - \\frac{\\ln 2}{24} \\cdot 72\\right) = \\exp(-0.36 - 3\\ln 2) = \\exp(-0.36) \\exp(-\\ln 8) = \\frac{\\exp(-0.36)}{8}$$\n\nBliss 独立性模型假定组合的预期存活率是各单药存活率的乘积：\n$$W_{AB, \\text{exp}} = W_A \\cdot W_B = \\left(\\frac{\\exp(1.08)}{8}\\right) \\cdot \\left(\\frac{\\exp(1.44)}{8}\\right) = \\frac{\\exp(1.08 + 1.44)}{64} = \\frac{\\exp(2.52)}{64}$$\n\nBliss 协同作用评分 $S_{\\text{Bliss}}$ 是观测存活率与预期存活率之间的偏差。问题指出，对于合成致死（一种协同作用形式），该偏差必须为负。协同作用意味着观测到的效应（细胞杀伤或生长抑制）比预期的要强，这意味着观测存活率低于预期存活率（$W_{AB, \\text{obs}}  W_{AB, \\text{exp}}$）。因此，评分必须定义为：\n$$S_{\\text{Bliss}} = W_{AB, \\text{obs}} - W_{AB, \\text{exp}}$$\n代入我们推导出的表达式：\n$$S_{\\text{Bliss}} = \\frac{\\exp(-0.36)}{8} - \\frac{\\exp(2.52)}{64}$$\n\n现在，我们计算数值。\n$W_{AB, \\text{obs}} = \\frac{\\exp(-0.36)}{8} \\approx \\frac{0.6976763}{8} \\approx 0.0872095$\n$W_{AB, \\text{exp}} = \\frac{\\exp(2.52)}{64} \\approx \\frac{12.427179}{64} \\approx 0.1941747$\n$$S_{\\text{Bliss}} \\approx 0.0872095 - 0.1941747 \\approx -0.1069652$$\n四舍五入到四位有效数字，Bliss 协同作用评分为 $-0.1070$。\n\n作为推理过程的一部分，我们评估合成致死的标准。\n(i) 非致死性单药：检查是否 $W_A > 0.2$ 和 $W_B > 0.2$。\n$W_A = \\frac{\\exp(1.08)}{8} \\approx \\frac{2.94468}{8} \\approx 0.3681$。由于 $0.3681 > 0.2$，此条件满足。\n$W_B = \\frac{\\exp(1.44)}{8} \\approx \\frac{4.22070}{8} \\approx 0.5276$。由于 $0.5276 > 0.2$，此条件满足。\n条件 (i) 满足。\n\n(ii) 致死性组合：检查是否 $W_{AB} \\le 0.1$。\n$W_{AB, \\text{obs}} \\approx 0.0872$。由于 $0.0872 \\le 0.1$，条件 (ii) 满足。\n\n(iii) 协同相互作用：检查 Bliss 偏差是否为严格负值。\n$S_{\\text{Bliss}} \\approx -0.1070$。由于 $-0.1070  0$，条件 (iii) 满足。\n\n所有三个标准都得到满足，因此根据所提供的操作性定义，该组合符合合成致死的条件。最终答案是 Bliss 协同作用评分本身。", "answer": "$$\\boxed{-0.1070}$$", "id": "4354444"}, {"introduction": "在遗传学背景下，合成致死表现为两个基因突变之间显著的非加性相互作用效应。通过构建一个 $2 \\times 2$ 的因子设计实验（野生型、单个突变体 A、单个突变体 B、双突变体），我们可以使用线性模型来精确地量化这种相互作用。这个练习要求您编写一个程序，分析带有生物学重复的生存力数据，通过对数转换和线性回归来检验相互作用项的统计显著性，从而确定基因对之间是否存在合成致死关系 [@problem_id:4354529]。", "problem": "您将获得针对两个基因的四种基因型的重复活力测量值，这两个基因由二元指标 $a \\in \\{0,1\\}$ 和 $b \\in \\{0,1\\}$ 表示。基因型 $(a,b) = (0,0)$ 是野生型，$(1,0)$ 携带基因 $A$ 的功能缺失，$(0,1)$ 携带基因 $B$ 的功能缺失，而 $(1,1)$ 则同时携带 $A$ 和 $B$ 的功能缺失。活力以无单位分数形式在开区间 $(0,1]$ 内测量，值越高表示存活率越大。将基因型重复的致死性定义为 $E = -\\log(v)$，其中 $v$ 是测得的活力。在生存效应独立的情况下，双突变体的活力相对于单突变体和野生型是乘性的，经过对数转换后，其致死性期望是加性的。如果双突变体的致死性超过加性期望，并且存在一个统计上显著的正交互作用项，则存在合成致死。\n\n您的任务是为每个测试用例实现以下步骤：\n- 对每种基因型的每组重复活力测量值，计算致死性 $E = -\\log(v)$。\n- 使用组均值计算各基因型之间的致死性差异，包括主效应和超出加性部分的双突变体超额致死性。\n- 在重复水平上，拟合一个关于致死性的线性模型，该模型包含截距项、$a$ 和 $b$ 的主效应项及其交互作用项 $ab$。使用普通最小二乘法（OLS；Ordinary Least Squares）以及线性模型的标准假设：$E[\\varepsilon] = 0$、$\\operatorname{Var}(\\varepsilon) = \\sigma^2$ 和独立同分布的误差。\n- 使用显著性水平 $\\alpha = 0.05$ 的单边t检验来检验交互作用系数是否严格大于 $0$。设原假设为 $H_0: \\beta_{AB} = 0$，备择假设为 $H_1: \\beta_{AB} > 0$。如果估计的交互作用项为正且单边p值小于或等于 $\\alpha$，则判定为存在合成致死。\n\n本问题中没有物理单位。所有活力值均为小数，必须视为在 $(0,1]$ 区间内的分数。不使用角度。不使用百分比。\n\n请使用以下重复活力值的测试套件（每个元素都是一个重复样本）。对于每个测试用例，四个列表的顺序为：野生型 $(a=0,b=0)$、单突变体 $A$ $(a=1,b=0)$、单突变体 $B$ $(a=0,b=1)$、双突变体 $AB$ $(a=1,b=1)$：\n- 测试用例1（预期有强合成致死）：\n  $[0.92, 0.90, 0.91, 0.89, 0.93, 0.90]$,\n  $[0.81, 0.79, 0.80, 0.82, 0.78, 0.80]$,\n  $[0.86, 0.84, 0.85, 0.83, 0.86, 0.85]$,\n  $[0.35, 0.32, 0.34, 0.31, 0.33, 0.34]$。\n- 测试用例2（近似加性，无交互作用）：\n  $[0.91, 0.90, 0.92, 0.89, 0.91, 0.90]$,\n  $[0.80, 0.81, 0.79, 0.80, 0.82, 0.78]$,\n  $[0.85, 0.84, 0.86, 0.85, 0.83, 0.85]$,\n  $[0.74, 0.75, 0.76, 0.73, 0.75, 0.74]$。\n- 测试用例3（存在轻微正交互作用和较高方差；显著性处于临界状态）：\n  $[0.90, 0.85, 0.95, 0.88, 0.92]$,\n  $[0.80, 0.75, 0.85, 0.78, 0.82]$,\n  $[0.86, 0.80, 0.90, 0.83, 0.87]$,\n  $[0.70, 0.76, 0.72, 0.68, 0.79]$。\n- 测试用例4（拮抗相互作用；共同作用时致死性较低）：\n  $[0.91, 0.90, 0.92, 0.89, 0.91, 0.90]$,\n  $[0.82, 0.81, 0.83, 0.80, 0.82, 0.81]$,\n  $[0.86, 0.85, 0.87, 0.84, 0.86, 0.85]$,\n  $[0.82, 0.81, 0.83, 0.80, 0.82, 0.82]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是一个布尔值，按顺序1到4指示相应测试用例是否检测到合成致死。例如，输出格式为 $[r_1, r_2, r_3, r_4]$，其中每个 $r_i \\in \\{\\text{True}, \\text{False}\\}$。", "solution": "该问题要求实现一个统计程序，根据重复活力测量值检测两个基因A和B之间的合成致死现象。其核心原理是在线性模型框架内对遗传交互作用进行建模，并检验是否存在一个显著的正交互作用项，该项是合成致死的量化标志。\n\n首先，通过对数转换 $E = -\\log(v)$，将原始活力测量值 $v$ 转换为致死性分数 $E$。这一转换至关重要，因为它将关于活力具有独立乘性效应的原假设，转换为了一个关于致死性的加性模型。对这种加性的偏离，特别是双突变体中出现超出预期的致死性，表明存在合成致死相互作用。\n\n该实验对应于一个 $2 \\times 2$ 析因设计，其因子是基因A的功能状态（指标 $a \\in \\{0,1\\}$）和基因B的功能状态（指标 $b \\in \\{0,1\\}$）。任何重复样本的致死性 $E$ 均通过以下线性方程建模：\n$$E = \\beta_0 + \\beta_A a + \\beta_B b + \\beta_{AB} ab + \\varepsilon$$\n其中 $\\beta_0$ 是截距（野生型致死性），$\\beta_A$ 和 $\\beta_B$ 分别是基因A和B突变的主效应，$\\beta_{AB}$ 是交互作用项，$\\varepsilon$ 是一个随机误差项，假设服从均值为0、方差恒为 $\\sigma^2$ 的正态分布。\n\n在此模型下，四种基因型的平均致死性为：\n- 野生型 $(a=0, b=0)$: $\\mu_{00} = \\beta_0$\n- 单突变体 A $(a=1, b=0)$: $\\mu_{10} = \\beta_0 + \\beta_A$\n- 单突变体 B $(a=0, b=1)$: $\\mu_{01} = \\beta_0 + \\beta_B$\n- 双突变体 AB $(a=1, b=1)$: $\\mu_{11} = \\beta_0 + \\beta_A + \\beta_B + \\beta_{AB}$\n\n这些参数的普通最小二乘法（OLS）估计值可以从每个基因型组的致死性样本均值（记为 $\\bar{E}_{00}, \\bar{E}_{10}, \\bar{E}_{01}, \\bar{E}_{11}$）中导出：\n- $\\hat{\\beta}_0 = \\bar{E}_{00}$\n- $\\hat{\\beta}_A = \\bar{E}_{10} - \\bar{E}_{00}$\n- $\\hat{\\beta}_B = \\bar{E}_{01} - \\bar{E}_{00}$\n- $\\hat{\\beta}_{AB} = \\bar{E}_{11} - (\\bar{E}_{10} - \\bar{E}_{00}) - (\\bar{E}_{01} - \\bar{E}_{00}) - \\bar{E}_{00} = \\bar{E}_{11} - \\bar{E}_{10} - \\bar{E}_{01} + \\bar{E}_{00}$\n\n交互作用项 $\\beta_{AB}$ 量化了与加性模型的偏离程度。一个正的 $\\beta_{AB}$ 意味着双突变体的致死性大于单个效应的总和，这定义了合成致死。我们使用单边t检验来正式检验这一点，原假设为 $H_0: \\beta_{AB} = 0$（加性），备择假设为 $H_1: \\beta_{AB} > 0$（合成致死）。\n\nt统计量的计算公式为：\n$$t = \\frac{\\hat{\\beta}_{AB}}{\\text{SE}(\\hat{\\beta}_{AB})}$$\n交互作用系数估计值的标准误 $\\text{SE}(\\hat{\\beta}_{AB})$，是由样本均值线性组合的方差推导出来的：\n$$\\text{SE}(\\hat{\\beta}_{AB}) = \\sqrt{\\text{Var}(\\bar{E}_{11} - \\bar{E}_{10} - \\bar{E}_{01} + \\bar{E}_{00})}$$\n假设样本独立且方差齐性（各组方差恒为 $\\sigma^2$），则变为：\n$$\\text{SE}(\\hat{\\beta}_{AB}) = \\sqrt{\\sigma^2 \\left( \\frac{1}{n_{00}} + \\frac{1}{n_{10}} + \\frac{1}{n_{01}} + \\frac{1}{n_{11}} \\right)}$$\n其中 $n_{ij}$ 是基因型 $(i,j)$ 的重复数。未知的总体方差 $\\sigma^2$ 使用所有四个组的合并方差进行估计，即模型中的均方误差（MSE）：\n$$\\hat{\\sigma}^2 = \\frac{\\sum_{i,j} \\sum_{k=1}^{n_{ij}} (E_{ijk} - \\bar{E}_{ij})^2}{n - p}$$\n在这里，$E_{ijk}$ 是基因型 $(i,j)$ 的第 $k$ 个重复样本的致死性，$n$ 是总重复数（$n = n_{00} + n_{10} + n_{01} + n_{11}$），$p=4$ 是模型中的参数数量。分母 $n-p$ 代表t检验的自由度（$df$）。\n\n计算出t统计量后，我们确定单边p值，即在原假设为真的前提下，观察到等于或比我们的统计量更极端的值的概率：$p = P(T_{df} > t)$，其中 $T_{df}$ 是一个服从自由度为 $df$ 的t分布的随机变量。\n\n应用最终的决策规则：如果估计的交互作用项为正（$\\hat{\\beta}_{AB} > 0$）且p值小于或等于指定的显著性水平 $\\alpha = 0.05$，则确定存在合成致死。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Main function to process test cases for synthetic lethality detection.\n    \"\"\"\n    # Test suite of replicate viability values.\n    # Order: wild-type (0,0), single mutant A (1,0),\n    # single mutant B (0,1), double mutant AB (1,1).\n    test_cases = [\n        # Test case 1 (strong synthetic lethality expectation)\n        (\n            [0.92, 0.90, 0.91, 0.89, 0.93, 0.90],\n            [0.81, 0.79, 0.80, 0.82, 0.78, 0.80],\n            [0.86, 0.84, 0.85, 0.83, 0.86, 0.85],\n            [0.35, 0.32, 0.34, 0.31, 0.33, 0.34],\n        ),\n        # Test case 2 (approximately additive, no interaction)\n        (\n            [0.91, 0.90, 0.92, 0.89, 0.91, 0.90],\n            [0.80, 0.81, 0.79, 0.80, 0.82, 0.78],\n            [0.85, 0.84, 0.86, 0.85, 0.83, 0.85],\n            [0.74, 0.75, 0.76, 0.73, 0.75, 0.74],\n        ),\n        # Test case 3 (slight positive interaction with higher variance; borderline significance)\n        (\n            [0.90, 0.85, 0.95, 0.88, 0.92],\n            [0.80, 0.75, 0.85, 0.78, 0.82],\n            [0.86, 0.80, 0.90, 0.83, 0.87],\n            [0.70, 0.76, 0.72, 0.68, 0.79],\n        ),\n        # Test case 4 (antagonistic interaction; less lethal together)\n        (\n            [0.91, 0.90, 0.92, 0.89, 0.91, 0.90],\n            [0.82, 0.81, 0.83, 0.80, 0.82, 0.81],\n            [0.86, 0.85, 0.87, 0.84, 0.86, 0.85],\n            [0.82, 0.81, 0.83, 0.80, 0.82, 0.82],\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        v_00, v_10, v_01, v_11 = case\n        result = is_synthetic_lethal(v_00, v_10, v_01, v_11)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef is_synthetic_lethal(v_00, v_10, v_01, v_11, alpha=0.05):\n    \"\"\"\n    Tests for synthetic lethality based on viability measurements.\n\n    Args:\n        v_00: Replicate viabilities for wild-type (a=0, b=0).\n        v_10: Replicate viabilities for single mutant A (a=1, b=0).\n        v_01: Replicate viabilities for single mutant B (a=0, b=1).\n        v_11: Replicate viabilities for double mutant AB (a=1, b=1).\n        alpha: Significance level for the hypothesis test.\n\n    Returns:\n        A boolean indicating if synthetic lethality is detected.\n    \"\"\"\n    # Step 1: Compute essentialities E = -log(v)\n    e_00 = -np.log(np.array(v_00))\n    e_10 = -np.log(np.array(v_10))\n    e_01 = -np.log(np.array(v_01))\n    e_11 = -np.log(np.array(v_11))\n\n    # Get group sizes\n    n_00, n_10, n_01, n_11 = len(e_00), len(e_10), len(e_01), len(e_11)\n    n_total = n_00 + n_10 + n_01 + n_11\n\n    # Step 2: Compute mean essentialities\n    mean_e_00 = np.mean(e_00)\n    mean_e_10 = np.mean(e_10)\n    mean_e_01 = np.mean(e_01)\n    mean_e_11 = np.mean(e_11)\n\n    # Step 3: Compute interaction coefficient estimate\n    hat_beta_ab = mean_e_11 - mean_e_10 - mean_e_01 + mean_e_00\n\n    # Step 4: Compute pooled variance (Mean Squared Error)\n    ss_00 = np.sum((e_00 - mean_e_00)**2)\n    ss_10 = np.sum((e_10 - mean_e_10)**2)\n    ss_01 = np.sum((e_01 - mean_e_01)**2)\n    ss_11 = np.sum((e_11 - mean_e_11)**2)\n    \n    ssr = ss_00 + ss_10 + ss_01 + ss_11\n    \n    num_params = 4\n    df = n_total - num_params\n    \n    if df == 0:\n        # Not enough data to estimate variance\n        return False\n        \n    pooled_variance = ssr / df\n\n    # Step 5: Compute standard error of the interaction coefficient\n    var_sum_term = (1/n_00) + (1/n_10) + (1/n_01) + (1/n_11)\n    se_hat_beta_ab = np.sqrt(pooled_variance * var_sum_term)\n\n    # Step 6: Compute t-statistic\n    if se_hat_beta_ab == 0:\n        # If SE is zero, a positive coefficient implies infinite evidence.\n        t_stat = np.inf if hat_beta_ab > 0 else 0\n    else:\n        t_stat = hat_beta_ab / se_hat_beta_ab\n\n    # Step 7  8: Compute one-sided p-value from t-distribution survival function\n    p_value = t.sf(t_stat, df)\n\n    # Step 9: Make decision\n    # Synthetic lethality requires a positive interaction term AND\n    # statistical significance.\n    is_lethal = (hat_beta_ab > 0) and (p_value = alpha)\n    \n    return is_lethal\n\n# solve() # The solve function should be called in the execution environment.\n# Since this is a library, the final call is commented out.\n\n```", "id": "4354529"}, {"introduction": "除了分析实验数据，系统生物学还致力于通过计算模型来预测合成致死关系。基于约束的建模，特别是通量平衡分析（Flux Balance Analysis, FBA），能够通过模拟代谢网络中的物质流动来预测细胞生长等表型。本练习将引导您在一个简化的代谢网络中，通过系统性地模拟单个和双重反应敲除，来识别那些共同失活会导致细胞死亡（即无法产生生物质）的反应对，从而揭示网络冗余和合成致死背后的机制 [@problem_id:4354454]。", "problem": "您的任务是使用稳态基于约束的建模方法，在小型代谢网络中识别合成致死反应对。起点是细胞内代谢物的基本稳态质量平衡，由化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$ 和通量向量 $v \\in \\mathbb{R}^{n}$ 表示，并受线性系统约束\n$$\nS v = 0,\n$$\n通量边界为\n$$\n\\ell \\le v \\le u,\n$$\n其中 $\\ell, u \\in \\mathbb{R}^{n}$ 分别是下界和上界。生物质产量由一个线性目标函数 $\\max \\; c^{\\top} v$ 建模，其中 $c \\in \\mathbb{R}^{n}$ 除了在生物质输出反应处外，其余分量均为零。可行性（Viability）定义为存在一个可行的稳态，其最大目标值严格大于一个阈值 $\\tau$，其中 $\\tau$ 是一个小的正标量。\n\n本文中，合成致死反应对定义为满足以下四个条件的无序非重复反应对 $\\{i,j\\}$：\n1. 野生型（无删除）的最大目标值严格大于 $\\tau$。\n2. 单独删除反应 $i$ 后的最大目标值严格大于 $\\tau$。\n3. 单独删除反应 $j$ 后的最大目标值严格大于 $\\tau$。\n4. 同时删除反应 $i$ 和 $j$ 后的最大目标值小于或等于 $\\tau$（包括不可行的情况）。\n\n删除反应 $k$ 是通过强制 $v_k = 0$ 来实现的。\n\n对于所有计算，使用以下阈值 $\\tau$：$\\tau = 10^{-6}$。所有线性规划问题都应求解为在 $S v = 0$ 和 $\\ell \\le v \\le u$ 约束下 $c^{\\top} v$ 的精确最大化。如果一个线性规划问题不可行，则将其最大目标值视为 $0$。\n\n您必须实现一个程序，对于下面的每个测试用例，枚举出所有满足上述合成致死定义的无序反应索引对 $\\{i,j\\}$（其中 $0 \\le i  j \\le n-1$）。反应使用从零开始的索引。将每对报告为一个双元素列表 $[i,j]$。对于每个测试用例，返回一个按字典序排序的此类反应对列表。最终输出必须按顺序汇总所有提供的测试用例的列表，生成一个单行，该行是一个列表，每个测试用例对应一个元素。\n\n测试套件：\n每个测试用例都明确提供了 $(S, \\ell, u, c)$。\n\n测试用例 1（通往生物质的冗余平行路径）：\n- 代谢物（$S$ 的行）：$[A, B, C, BM]$。\n- 反应（$S$ 的列）：$0:$ 吸收 $\\rightarrow A$, $1:$ $A \\rightarrow B$, $2:$ $A \\rightarrow C$, $3:$ $B \\rightarrow BM$, $4:$ $C \\rightarrow BM$, $5:$ $BM \\rightarrow$ 输出。\n- 化学计量矩阵 $S \\in \\mathbb{R}^{4 \\times 6}$：\n$$\nS = \\begin{bmatrix}\n1  -1  -1  0  0  0 \\\\\n0  1  0  -1  0  0 \\\\\n0  0  1  0  -1  0 \\\\\n0  0  0  1  1  -1\n\\end{bmatrix}.\n$$\n- 边界 $\\ell, u \\in \\mathbb{R}^{6}$：\n$$\n\\ell = [0, 0, 0, 0, 0, 0], \\quad u = [10, 1000, 1000, 1000, 1000, 1000].\n$$\n- 目标向量 $c \\in \\mathbb{R}^{6}$：\n$$\nc = [0, 0, 0, 0, 0, 1].\n$$\n\n测试用例 2（单一必需线性途径，预计无合成致死）：\n- 代谢物（$S$ 的行）：$[A, D, BM]$。\n- 反应（$S$ 的列）：$0:$ 吸收 $\\rightarrow A$, $1:$ $A \\rightarrow D$, $2:$ $D \\rightarrow BM$, $3:$ $BM \\rightarrow$ 输出。\n- 化学计量矩阵 $S \\in \\mathbb{R}^{3 \\times 4}$：\n$$\nS = \\begin{bmatrix}\n1  -1  0  0 \\\\\n0  1  -1  0 \\\\\n0  0  1  -1\n\\end{bmatrix}.\n$$\n- 边界 $\\ell, u \\in \\mathbb{R}^{4}$：\n$$\n\\ell = [0, 0, 0, 0], \\quad u = [10, 1000, 1000, 1000].\n$$\n- 目标向量 $c \\in \\mathbb{R}^{4}$：\n$$\nc = [0, 0, 0, 1].\n$$\n\n测试用例 3（支持路径重路由的可逆互变）：\n- 代谢物（$S$ 的行）：$[A, B, C, BM]$。\n- 反应（$S$ 的列）：$0:$ 吸收 $\\rightarrow A$, $1:$ $A \\rightarrow B$, $2:$ $B \\leftrightarrow C$（可逆），$3:$ $B \\rightarrow BM$, $4:$ $C \\rightarrow BM$, $5:$ $BM \\rightarrow$ 输出。\n- 化学计量矩阵 $S \\in \\mathbb{R}^{4 \\times 6}$：\n$$\nS = \\begin{bmatrix}\n1  -1  0  0  0  0 \\\\\n0  1  -1  -1  0  0 \\\\\n0  0  1  0  -1  0 \\\\\n0  0  0  1  1  -1\n\\end{bmatrix}.\n$$\n- 边界 $\\ell, u \\in \\mathbb{R}^{6}$：\n$$\n\\ell = [0, 0, -1000, 0, 0, 0], \\quad u = [10, 1000, 1000, 1000, 1000, 1000].\n$$\n- 目标向量 $c \\in \\mathbb{R}^{6}$：\n$$\nc = [0, 0, 0, 0, 0, 1].\n$$\n\n您的程序必须：\n- 为每个测试用例求解线性规划以计算最大目标值。\n- 根据定义，使用 $\\tau = 10^{-6}$ 确定所有合成致死对。\n- 生成一个单行输出，其中包含所有测试用例的列表，格式为用方括号括起来的逗号分隔列表，不含空格。例如，一个有效的输出格式是 $[[[i_1,j_1],[i_2,j_2]],[],[[k_1,\\ell_1]]]$。\n\n最终答案必须是按规定编写的完整、可运行的程序。此问题不涉及任何物理单位、角度或百分比。所有数值均在上面明确给出，不带单位，所有输出均为整数列表。", "solution": "该问题被评估为**有效**。它在科学上植根于代谢网络基于约束的建模这一成熟领域，特别是通量平衡分析（FBA）。该问题定义明确，为求解合成致死性提供了清晰、正式的定义和所有必要参数（$S, \\ell, u, c, \\tau$）。这些定义在数学上是精确和客观的，没有歧义、矛盾或依赖于非科学的前提。\n\n该问题的核心是通过系统地模拟单个和双重反应删除对代谢网络产生生物质能力的影响，来识别合成致死反应对。这是通过通量平衡分析（FBA）实现的，这是一种分析稳态下代谢通量的数学方法。\n\n代谢网络由稳态质量平衡方程描述：\n$$\nS v = 0\n$$\n其中 $S \\in \\mathbb{R}^{m \\times n}$ 是 $m$ 种代谢物和 $n$ 个反应的化学计量矩阵，$v \\in \\mathbb{R}^{n}$ 是反应通量向量。通量还受到下界和上界的约束：\n$$\n\\ell \\le v \\le u\n$$\n细胞目标（通常是生物质产量）被假定为通量的线性组合，我们寻求将其最大化：\n$$\n\\max \\quad c^{\\top} v\n$$\n其中向量 $c \\in \\mathbb{R}^{n}$ 定义了目标函数。这种表述构成了一个线性规划（LP）问题。\n\n删除（或“敲除”）反应 $k$ 是通过将其对应的通量 $v_k$ 设置为零来实现的。具体实现方式是修改其边界，使得 $\\ell_k = u_k = 0$。\n\n该问题基于与网络可行性相关的四个条件来定义合成致死对 $\\{i, j\\}$。可行性是通过将最大目标值（生物质产量）与一个小的正阈值 $\\tau = 10^{-6}$ 进行比较来确定的。设 $Z(\\mathcal{K})$ 表示删除了反应集合 $\\mathcal{K}$ 的网络的最大目标值。一对 $\\{i, j\\}$ 成为合成致死的条件是：\n1.  野生型可行性：$Z(\\emptyset) > \\tau$\n2.  单突变体 $i$ 可行性：$Z(\\{i\\}) > \\tau$\n3.  单突变体 $j$ 可行性：$Z(\\{j\\}) > \\tau$\n4.  双突变体致死性：$Z(\\{i, j\\}) \\le \\tau$\n\n为了解决这个问题，对每个测试用例都遵循一个系统的计算程序：\n\n首先，我们需要一个函数来解决给定参数集的 FBA 问题。标准的 LP 求解器通常设计用于解决 $\\min a^{\\top}x$ 形式的最小化问题。为了解决我们的最大化问题 $\\max c^{\\top}v$，我们可以等效地求解 $\\min (-c)^{\\top}v$。最大化的最优值就是最小化结果的负值。如果 LP 不可行，问题规定将最大目标值视为 $0$。\n\n识别合成致死对的算法如下：\n\n1.  **求解野生型（WT）生长**：使用原始、未修改的边界 $\\ell$ 和 $u$ 求解一个 LP。设结果为 $Z_{WT} = Z(\\emptyset)$。如果 $Z_{WT} \\le \\tau$，则野生型网络不可行。根据条件 1，不可能存在合成致死对，因此该测试用例的处理终止，产生一个空列表。\n\n2.  **评估单次删除**：对于每个反应 $k \\in \\{0, 1, \\dots, n-1\\}$，求解一个单次删除的 LP。创建一个临时边界集 $(\\ell', u')$，其中 $\\ell'_k = u'_k = 0$，并计算最大目标值 $Z_k = Z(\\{k\\})$。\n\n3.  **识别非必需反应**：如果删除反应 $k$ 不会导致网络不可行，即 $Z_k > \\tau$，则该反应是非必需的。合成致死定义的条件 2 和 3 要求合成致死对中的两个反应都必须是非必需的。因此，我们编制一个所有非必需反应索引的列表。\n\n4.  **评估双重删除**：我们遍历所有唯一的非必需反应无序对 $\\{i, j\\}$，确保 $i  j$ 以维持字典序并避免冗余计算。对于每一对，通过将反应 $i$ 和 $j$ 的边界都设置为零（$\\ell'_i = u'_i = 0$ 和 $\\ell'_j = u'_j = 0$）来求解一个双重删除的 LP。\n\n5.  **分类合成致死对**：设对 $\\{i, j\\}$ 的双重删除 LP 的结果为 $Z_{ij} = Z(\\{i, j\\})$。如果 $Z_{ij} \\le \\tau$，则满足条件 4。由于前面的步骤已经满足了条件 1、2 和 3，因此该对 $\\{i, j\\}$ 被分类为合成致死，并添加到我们的结果列表中。\n\n此过程详尽地检查所有有效的候选对是否满足四个标准，确保对每个提供的代谢网络模型都能正确、完整地枚举出合成致死对。最终的实现将利用 `numpy` 进行高效的数组和矩阵运算，并使用 `scipy.optimize.linprog` 来求解所需的线性规划问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    Identifies synthetic lethal reaction pairs in metabolic networks using FBA.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        (\n            np.array([\n                [1, -1, -1, 0, 0, 0],\n                [0, 1, 0, -1, 0, 0],\n                [0, 0, 1, 0, -1, 0],\n                [0, 0, 0, 1, 1, -1]\n            ]),\n            np.array([0, 0, 0, 0, 0, 0], dtype=float),\n            np.array([10, 1000, 1000, 1000, 1000, 1000], dtype=float),\n            np.array([0, 0, 0, 0, 0, 1], dtype=float)\n        ),\n        # Test case 2\n        (\n            np.array([\n                [1, -1, 0, 0],\n                [0, 1, -1, 0],\n                [0, 0, 1, -1]\n            ]),\n            np.array([0, 0, 0, 0], dtype=float),\n            np.array([10, 1000, 1000, 1000], dtype=float),\n            np.array([0, 0, 0, 1], dtype=float)\n        ),\n        # Test case 3\n        (\n            np.array([\n                [1, -1, 0, 0, 0, 0],\n                [0, 1, -1, -1, 0, 0],\n                [0, 0, 1, 0, -1, 0],\n                [0, 0, 0, 1, 1, -1]\n            ]),\n            np.array([0, 0, -1000, 0, 0, 0], dtype=float),\n            np.array([10, 1000, 1000, 1000, 1000, 1000], dtype=float),\n            np.array([0, 0, 0, 0, 0, 1], dtype=float)\n        )\n    ]\n    \n    tau = 1e-6\n    all_results = []\n\n    for S, l, u, c in test_cases:\n        sl_pairs = find_synthetic_lethal_pairs(S, l, u, c, tau)\n        all_results.append(sl_pairs)\n\n    # Format output to be a single string without spaces.\n    results_as_strings = []\n    for res in all_results:\n        # Convert list to string and remove spaces\n        res_str = str(res).replace(\" \", \"\")\n        results_as_strings.append(res_str)\n\n    print(f\"[{','.join(results_as_strings)}]\")\n\ndef solve_fba(c_obj, S, l_bounds, u_bounds):\n    \"\"\"\n    Solves the FBA linear program: max c'v s.t. Sv=0, l = v = u.\n    Returns the maximal objective value. Treats infeasible cases as 0.\n    \"\"\"\n    m, n = S.shape\n    b_eq = np.zeros(m)\n    bounds = list(zip(l_bounds, u_bounds))\n\n    # linprog minimizes, so we minimize -c'v to maximize c'v\n    res = linprog(-c_obj, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs')\n\n    if res.success:\n        # Return the maximum value (negate the minimized value)\n        return -res.fun\n    else:\n        # Per problem spec, treat infeasible or failed optimization as 0 growth.\n        return 0.0\n\ndef find_synthetic_lethal_pairs(S, l, u, c, tau):\n    \"\"\"\n    Finds all synthetic lethal reaction pairs for a given metabolic model.\n    \"\"\"\n    n_reactions = S.shape[1]\n\n    # 1. Check wild-type viability\n    wt_growth = solve_fba(c, S, l, u)\n    if wt_growth = tau:\n        return []\n\n    # 2. Evaluate all single knockouts\n    single_ko_growths = []\n    for i in range(n_reactions):\n        l_ko = np.copy(l)\n        u_ko = np.copy(u)\n        l_ko[i], u_ko[i] = 0.0, 0.0\n        growth = solve_fba(c, S, l_ko, u_ko)\n        single_ko_growths.append(growth)\n\n    # 3. Identify non-essential reactions (Conditions 2  3)\n    non_essential_indices = [\n        i for i, g in enumerate(single_ko_growths) if g > tau\n    ]\n\n    # 4. Evaluate double knockouts of non-essential reactions\n    sl_pairs = []\n    for i_idx, i in enumerate(non_essential_indices):\n        for j in non_essential_indices[i_idx + 1:]:\n            # Pair is (i, j) with i  j, ensuring lexicographical order and uniqueness\n            l_dko = np.copy(l)\n            u_dko = np.copy(u)\n            l_dko[i], u_dko[i] = 0.0, 0.0\n            l_dko[j], u_dko[j] = 0.0, 0.0\n            \n            dko_growth = solve_fba(c, S, l_dko, u_dko)\n            \n            # 5. Check for synthetic lethality (Condition 4)\n            if dko_growth = tau:\n                sl_pairs.append([i, j])\n                \n    return sl_pairs\n\nif __name__ == '__main__':\n    solve()\n```", "id": "4354454"}]}