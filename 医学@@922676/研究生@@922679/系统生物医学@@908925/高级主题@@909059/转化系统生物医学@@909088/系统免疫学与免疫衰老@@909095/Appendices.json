{"hands_on_practices": [{"introduction": "T细胞群体的维持依赖于产生、死亡以及对细胞因子等有限资源的竞争之间的动态平衡。这项实践将引导您从基本原理出发，构建一个动力学系统模型，以理解这些相互竞争的过程如何建立稳定的平衡。通过分析该平衡如何因参数变化（模拟与年龄相关的细胞因子产生下降）而移动，您将深入了解免疫衰老中医源性稳态失调的机制[@problem_id:4391454]。", "problem": "考虑一个简化的系统免疫学模型，该模型描述了在细胞因子受限条件下初始T细胞和记忆T细胞的稳态维持。设 $N(t)$ 表示初始T细胞的丰度，$M(t)$ 表示记忆T细胞的丰度，$C(t)$ 表示一种限制性细胞因子的浓度。假设以下基本依据和定义成立。\n\n- 均匀混合区室的质量作用平衡：生成减去消耗定义了每个物种的时间导数。\n- 细胞因子驱动的细胞源生成遵循类似米氏-门顿方程的饱和依赖关系，该关系取决于细胞因子浓度，反映了受体占有率。半饱和常数为 $K_N$ 和 $K_M$，最大细胞因子驱动源生成速率为 $\\alpha_N$ 和 $\\alpha_M$，线性死亡（损失）速率为 $\\delta_N$ 和 $\\delta_M$。\n- 细胞因子以恒定速率 $\\pi$ 生成，并通过与细胞的质量作用相互作用被消耗，消耗速率与细胞因子丰度和消耗细胞丰度成正比，比例常数为 $p_N$ 和 $p_M$。\n\n任务 A（模型构建）：严格根据上述原理，推导出一个关于 $(N,M,C)$ 的耦合常微分方程组（ODE），其形式为 $\\mathrm{d}N/\\mathrm{d}t = \\ldots$，$\\mathrm{d}M/\\mathrm{d}t = \\ldots$ 和 $\\mathrm{d}C/\\mathrm{d}t = \\ldots$，且与这些依据一致。不要引入超出规定范围的额外过程。\n\n任务 B（平衡点分析）：对于固定参数且 $\\pi > 0$ 的情况，证明存在一个平衡点 $(N^\\ast, M^\\ast, C^\\ast)$ 使得 $C^\\ast > 0$。将 $N^\\ast$ 和 $M^\\ast$ 表示为 $C^\\ast$ 的函数，并将 $C^\\ast$ 的稳态条件简化为仅涉及 $C^\\ast$ 和参数的单个标量方程 $F(C^\\ast) = 0$。证明在给定假设下，当 $C > 0$ 时，$F(C)$ 是严格递减的，因此有唯一的正根。推断降低 $\\pi$（以模拟与年龄相关的细胞因子生成下降）对 $C^\\ast$、$N^\\ast$ 和 $M^\\ast$ 的定性影响。\n\n任务 C（计算实验）：实现一个程序，对于下面测试套件中的每个参数集，计算基线细胞因子生成 $\\pi_0$ 和年龄相关减少的生成 $\\pi_{\\text{aged}} = r \\,\\pi_0$（其中 $r \\in (0,1)$）下的唯一平衡点 $(N^\\ast, M^\\ast, C^\\ast)$。对于每种情况，报告由以下公式定义的平衡丰度的分数变化：\n- $\\Delta_N = (N^\\ast_{\\text{aged}} - N^\\ast_{\\text{base}})/N^\\ast_{\\text{base}}$，\n- $\\Delta_M = (M^\\ast_{\\text{aged}} - M^\\ast_{\\text{base}})/M^\\ast_{\\text{base}}$，\n- $\\Delta_C = (C^\\ast_{\\text{aged}} - C^\\ast_{\\text{base}})/C^\\ast_{\\text{base}}$。\n无需物理单位；将所有变量和参数视为无量纲。不涉及角度。对于数值输出，将每个 $\\Delta$ 表示为四舍五入到6位小数的小数。\n\n测试套件参数化：每个测试用例是一个元组 $(\\alpha_N,\\alpha_M,\\delta_N,\\delta_M,K_N,K_M,p_N,p_M,\\pi_0,r)$，包括以下四种情况，以确保覆盖典型、记忆细胞主导消耗、低生成边缘和较高损失机制等情况：\n\n- 情况 A（典型，平衡）：\n  $(0.6, 0.4, 0.03, 0.02, 1.0, 0.5, 0.05, 0.02, 1.2, 0.6)$.\n- 情况 B（记忆细胞主导消耗）：\n  $(0.6, 0.5, 0.03, 0.02, 1.0, 0.3, 0.02, 0.08, 1.5, 0.5)$.\n- 情况 C（低生成，边缘）：\n  $(0.6, 0.4, 0.03, 0.02, 1.0, 0.5, 0.05, 0.02, 0.3, 0.3)$.\n- 情况 D（较高损失率）：\n  $(0.5, 0.5, 0.1, 0.08, 0.7, 0.7, 0.03, 0.03, 0.8, 0.7)$.\n\n实现和输出规范：\n- 你的程序必须对每种情况，通过求解任务 B 中推导的标量稳态方程的唯一正根来解出 $C^\\ast$，然后计算 $\\pi_0$ 和 $r\\,\\pi_0$ 两种情况下的 $N^\\ast$ 和 $M^\\ast$。\n- 对 $C \\in (0,\\infty)$ 使用稳健的求根区间法和单调求解器，以保证找到唯一的正根。\n- 最终的程序输出应该是一行，包含一个用方括号括起来的逗号分隔列表，其中每个元素是对应一个测试用例的列表 $[\\Delta_N,\\Delta_M,\\Delta_C]$，顺序与上面相同。例如：\"[[x1,y1,z1],[x2,y2,z2],[x3,y3,z3],[x4,y4,z4]]\"，每个值四舍五入到6位小数。", "solution": "这个问题描述了一个简化的T细胞稳态模型，并要求进行其数学推导、平衡性质的解析研究以及在不同条件下的数值模拟。该问题具有科学依据，提法恰当，并且内部一致。\n\n### 任务 A：模型构建\n\n我们的任务是为初始T细胞丰度 $N(t)$、记忆T细胞丰度 $M(t)$ 和细胞因子浓度 $C(t)$ 推导一个常微分方程组（ODE）。该推导基于质量作用平衡原理，即每个物种的变化率是其总生成速率减去其总消耗（或损失）速率。\n\n**1. 初始T细胞方程, $N(t)$:**\n问题规定了两个控制 $N(t)$ 的过程：一个依赖于细胞因子的源生成过程和一个线性死亡过程。\n- **生成：** 生成过程被描述为一个“细胞因子驱动的源”，其对细胞因子浓度 $C$ 的依赖关系类似于米氏-门顿方程。这意味着源项与当前种群大小 $N$ 无关。最大速率为 $\\alpha_N$，半饱和常数为 $K_N$。该项的数学表达式为 $\\alpha_N \\frac{C}{K_N + C}$。例如，这代表了从未建模的前体细胞群以依赖于细胞因子信号的速率进行分化。\n- **消耗（损失）：** 损失是一个线性死亡过程，速率为 $\\delta_N$，意味着细胞以与其当前丰度成正比的速率损失。该项由 $\\delta_N N$ 给出。\n\n结合生成和损失，得到 $N(t)$ 的常微分方程为：\n$$\n\\frac{\\mathrm{d}N}{\\mathrm{d}t} = \\alpha_N \\frac{C}{K_N + C} - \\delta_N N\n$$\n\n**2. 记忆T细胞方程, $M(t)$:**\n$M(t)$ 的逻辑与 $N(t)$ 的逻辑相同，但使用其自己的一套参数。\n- **生成：** 一个源项，最大速率为 $\\alpha_M$，半饱和常数为 $K_M$，写作 $\\alpha_M \\frac{C}{K_M + C}$。\n- **消耗（损失）：** 一个线性死亡过程，速率为 $\\delta_M$，写作 $\\delta_M M$。\n\n结合这些，得到 $M(t)$ 的常微分方程：\n$$\n\\frac{\\mathrm{d}M}{\\mathrm{d}t} = \\alpha_M \\frac{C}{K_M + C} - \\delta_M M\n$$\n\n**3. 细胞因子方程, $C(t)$:**\n细胞因子的动态由恒定的生成以及初始T细胞和记忆T细胞的消耗共同决定。\n- **生成：** 一个恒定的生成速率，由参数 $\\pi$ 表示。\n- **消耗：** 消耗通过“质量作用相互作用”发生，与细胞因子浓度 $C$ 以及消耗细胞的丰度 $N$ 和 $M$ 都成正比。比例常数对于初始细胞是 $p_N$，对于记忆细胞是 $p_M$。这导致了两个消耗项：$p_N N C$ 和 $p_M M C$。\n\n结合这些项，得到 $C(t)$ 的常微分方程：\n$$\n\\frac{\\mathrm{d}C}{\\mathrm{d}t} = \\pi - p_N N C - p_M M C = \\pi - (p_N N + p_M M)C\n$$\n\n**完整的常微分方程组：**\n完整的模型是以下耦合非线性常微分方程组：\n$$\n\\begin{cases}\n\\frac{\\mathrm{d}N}{\\mathrm{d}t} = \\alpha_N \\frac{C}{K_N + C} - \\delta_N N \\\\\n\\frac{\\mathrm{d}M}{\\mathrm{d}t} = \\alpha_M \\frac{C}{K_M + C} - \\delta_M M \\\\\n\\frac{\\mathrm{d}C}{\\mathrm{d}t} = \\pi - (p_N N + p_M M)C\n\\end{cases}\n$$\n\n### 任务 B：平衡点分析\n\n我们寻找一个非平凡平衡点 $(N^\\ast, M^\\ast, C^\\ast)$，其中所有丰度均为正，这要求 $C^\\ast > 0$。在平衡点，所有时间导数均为零。\n\n**1. 将 $N^\\ast$ 和 $M^\\ast$ 表示为 $C^\\ast$ 的函数：**\n根据稳态下的前两个常微分方程（$\\mathrm{d}N/\\mathrm{d}t = 0$, $\\mathrm{d}M/\\mathrm{d}t = 0$）：\n$$\n0 = \\alpha_N \\frac{C^\\ast}{K_N + C^\\ast} - \\delta_N N^\\ast \\implies N^\\ast = \\frac{\\alpha_N}{\\delta_N} \\frac{C^\\ast}{K_N + C^\\ast}\n$$\n$$\n0 = \\alpha_M \\frac{C^\\ast}{K_M + C^\\ast} - \\delta_M M^\\ast \\implies M^\\ast = \\frac{\\alpha_M}{\\delta_M} \\frac{C^\\ast}{K_M + C^\\ast}\n$$\n这些表达式给出了作为平衡细胞因子浓度 $C^\\ast$ 函数的平衡细胞丰度。由于所有参数 $(\\alpha, \\delta, K)$ 均为正，当且仅当 $C^\\ast > 0$ 时，$N^\\ast$ 和 $M^\\ast$ 才为正。\n\n**2. 推导 $C^\\ast$ 的标量方程：**\n将 $N^\\ast$ 和 $M^\\ast$ 的表达式代入第三个平衡方程 $\\mathrm{d}C/\\mathrm{d}t = 0$：\n$$\n0 = \\pi - (p_N N^\\ast + p_M M^\\ast)C^\\ast\n$$\n$$\n\\pi = \\left( p_N \\left(\\frac{\\alpha_N}{\\delta_N} \\frac{C^\\ast}{K_N + C^\\ast}\\right) + p_M \\left(\\frac{\\alpha_M}{\\delta_M} \\frac{C^\\ast}{K_M + C^\\ast}\\right) \\right) C^\\ast\n$$\n我们可以定义一个函数 $G(C)$，表示在给定浓度 $C$ 下的总细胞因子消耗速率：\n$$\nG(C) = C^2 \\left( \\frac{p_N \\alpha_N}{\\delta_N(K_N + C)} + \\frac{p_M \\alpha_M}{\\delta_M(K_M + C)} \\right)\n$$\n平衡条件即为 $G(C^\\ast) = \\pi$。\n为了满足问题要求的形式为 $F(C^\\ast) = 0$ 且 $F(C)$ 严格递减的方程，我们定义：\n$$\nF(C) = \\pi - G(C) = \\pi - C^2 \\left( \\frac{p_N \\alpha_N}{\\delta_N(K_N + C)} + \\frac{p_M \\alpha_M}{\\delta_M(K_M + C)} \\right)\n$$\n\n**3. 唯一正根的证明：**\n为了证明 $F(C)$ 有一个唯一的正根，我们证明它在 $C>0$ 上是连续、严格递减的，并且它在 $0^+$ 和 $\\infty$ 的极限跨越了零。\n一个通用项 $H(C) = A \\frac{C^2}{K+C}$（其中 $A, K > 0$）的导数是：\n$$\nH'(C) = A \\frac{d}{dC} \\left(\\frac{C^2}{K+C}\\right) = A \\frac{2C(K+C) - C^2(1)}{(K+C)^2} = A \\frac{2KC + C^2}{(K+C)^2} = A \\frac{C(2K+C)}{(K+C)^2}\n$$\n对于 $C > 0$，我们有 $H'(C) > 0$。函数 $G(C)$ 是两个具有正系数的此类项之和，因此对于所有 $C > 0$，$G'(C) > 0$。\n$F(C)$ 的导数是 $F'(C) = -G'(C)$。由于 $G'(C) > 0$，我们有对于所有 $C > 0$，$F'(C)  0$。因此，$F(C)$ 是一个在 $C  0$ 上严格递减的函数。\n\n接下来，我们计算 $F(C)$ 的极限：\n- 当 $C \\to 0^+$ 时，项 $\\frac{C}{K+C} \\to 0$，所以 $G(C) \\to 0$。因此，$\\lim_{C \\to 0^+} F(C) = \\pi - 0 = \\pi$。由于 $\\pi  0$，该函数从一个正值开始。\n- 当 $C \\to \\infty$ 时，项 $\\frac{C}{K+C} \\to 1$。$G(C)$ 括号内的项变为 $C \\left( ... \\right)$，它趋向于无穷大，因为它表现得像 $C$ 的一个线性函数。因此，$\\lim_{C \\to \\infty} G(C) = \\infty$。所以，$\\lim_{C \\to \\infty} F(C) = \\pi - \\infty = -\\infty$。\n\n由于 $F(C)$ 是在 $(0, \\infty)$ 上的连续且严格递减的函数，且 $F(0^+)  0$ 和 $F(\\infty)  0$，根据介值定理，必然存在唯一一个值 $C^\\ast \\in (0, \\infty)$ 使得 $F(C^\\ast)=0$。\n\n**4. 降低 $\\pi$ 的影响：**\n平衡点由 $G(C^\\ast) = \\pi$ 定义。我们已经证明 $G(C)$ 是 $C$ 的一个严格递增函数。设 $\\pi_{\\text{base}}$ 为基线生成速率，其对应的平衡点为 $C^\\ast_{\\text{base}}$；设 $\\pi_{\\text{aged}}  \\pi_{\\text{base}}$ 为降低后的速率，其平衡点为 $C^\\ast_{\\text{aged}}$。\n我们有 $G(C^\\ast_{\\text{base}}) = \\pi_{\\text{base}}$ 和 $G(C^\\ast_{\\text{aged}}) = \\pi_{\\text{aged}}$。\n由于 $\\pi_{\\text{aged}}  \\pi_{\\text{base}}$，因此 $G(C^\\ast_{\\text{aged}})  G(C^\\ast_{\\text{base}})$。\n因为 $G(C)$ 是严格递增的，这意味着 $C^\\ast_{\\text{aged}}  C^\\ast_{\\text{base}}$。因此，降低细胞因子生成速率 $\\pi$ 会减少平衡细胞因子浓度 $C^\\ast$。\n\n现在考虑对 $N^\\ast$ 和 $M^\\ast$ 的影响。平衡丰度 $N^\\ast$ 由函数 $N^\\ast(C) = \\frac{\\alpha_N}{\\delta_N} \\frac{C}{K_N+C}$ 给出。我们来考察它对 $C$ 的依赖性。其导数为：\n$$\n\\frac{d N^\\ast}{dC} = \\frac{\\alpha_N}{\\delta_N} \\frac{1(K_N+C) - C(1)}{(K_N+C)^2} = \\frac{\\alpha_N K_N}{\\delta_N(K_N+C)^2}\n$$\n由于所有参数均为正，$\\frac{d N^\\ast}{dC}  0$。所以，$N^\\ast$ 是 $C$ 的一个严格递增函数。由于降低 $\\pi$ 会导致 $C^\\ast$ 减小，因此也必然导致 $N^\\ast$ 减小。\n根据相同的逻辑，$M^\\ast(C) = \\frac{\\alpha_M}{\\delta_M} \\frac{C}{K_M+C}$ 也是 $C$ 的一个严格递增函数，所以降低 $\\pi$ 也会导致 $M^\\ast$ 减小。\n总之，细胞因子生成速率 $\\pi$ 的下降会导致所有三个物种的平衡丰度（$N^\\ast$、$M^\\ast$ 和 $C^\\ast$）降低。\n\n### 任务 C：计算实验\n\n计算任务是为几个参数集求解两种不同 $\\pi$ 值（$\\pi_0$ 和 $\\pi_{\\text{aged}} = r \\pi_0$）下的平衡值。计算的核心是找到方程 $F(C) = 0$ 的唯一正根 $C^\\ast$。正如在任务 B 中所确定的，函数 $F(C)$ 是单调的，这保证了像布伦特方法这样的稳健求根算法，在给定一个合适的区间 $[a, b]$（其中 $F(a)$ 和 $F(b)$ 异号）的情况下，将高效可靠地找到唯一的根。我们已经确定 $F(C)$ 在 $C=0$ 附近为正，对于大的 $C$ 为负，因此像 $[10^{-12}, 10^4]$ 这样的区间对于给定的参数范围是合适的。\n\n一旦为每个测试用例找到了 $C^\\ast_{\\text{base}}$ 和 $C^\\ast_{\\text{aged}}$，就使用任务 B 中推导的公式计算相应的细胞群体 $(N^\\ast, M^\\ast)$。最后，分数变化计算如下：\n- $\\Delta_N = (N^\\ast_{\\text{aged}} - N^\\ast_{\\text{base}})/N^\\ast_{\\text{base}}$\n- $\\Delta_M = (M^\\ast_{\\text{aged}} - M^\\ast_{\\text{base}})/M^\\ast_{\\text{base}}$\n- $\\Delta_C = (C^\\ast_{\\text{aged}} - C^\\ast_{\\text{base}})/C^\\ast_{\\text{base}}$\n\n所需的实现已在最终答案块中提供。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the systems immunology problem by finding equilibrium states\n    and calculating fractional changes due to reduced cytokine production.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    # Each tuple is (alpha_N, alpha_M, delta_N, delta_M, K_N, K_M, p_N, p_M, pi_0, r)\n    test_cases = [\n        (0.6, 0.4, 0.03, 0.02, 1.0, 0.5, 0.05, 0.02, 1.2, 0.6), # Case A\n        (0.6, 0.5, 0.03, 0.02, 1.0, 0.3, 0.02, 0.08, 1.5, 0.5), # Case B\n        (0.6, 0.4, 0.03, 0.02, 1.0, 0.5, 0.05, 0.02, 0.3, 0.3), # Case C\n        (0.5, 0.5, 0.1, 0.08, 0.7, 0.7, 0.03, 0.03, 0.8, 0.7), # Case D\n    ]\n\n    def get_steady_state_function(pi, params):\n        \"\"\"\n        Returns the scalar function F(C) = pi - G(C) for root finding.\n        The root of this function is the equilibrium cytokine concentration C*.\n        \"\"\"\n        alpha_N, alpha_M, delta_N, delta_M, K_N, K_M, p_N, p_M = params\n\n        def F(C):\n            if C == 0:\n                return pi\n            \n            # Cytokine consumption by naive T cells\n            consumption_N = p_N * (alpha_N / delta_N) * (C / (K_N + C))\n            \n            # Cytokine consumption by memory T cells\n            consumption_M = p_M * (alpha_M / delta_M) * (C / (K_M + C))\n            \n            # Total consumption rate, G(C)\n            total_consumption_rate = (consumption_N + consumption_M) * C\n            \n            return pi - total_consumption_rate\n\n        return F\n\n    def calculate_equilibrium(pi, params):\n        \"\"\"\n        Calculates the equilibrium (N*, M*, C*) for a given pi and parameter set.\n        \"\"\"\n        alpha_N, alpha_M, delta_N, delta_M, K_N, K_M, _, _ = params\n        \n        # Define the function whose root we need to find\n        F_C = get_steady_state_function(pi, params)\n        \n        # Find the unique positive root for C* using Brent's method.\n        # The bracket [a, b] is chosen based on the analytical result that\n        # F(C)  0 for C - 0+ and F(C)  0 for C - infinity.\n        # The specific values are a small positive number and a large number\n        # certain to be greater than the root for the given parameter scales.\n        try:\n            C_star = brentq(F_C, a=1e-12, b=1e5)\n        except ValueError:\n            # This should not happen if the analysis is correct and bracket is valid.\n            return (np.nan, np.nan, np.nan)\n        \n        # Calculate N* and M* from C*\n        N_star = (alpha_N / delta_N) * (C_star / (K_N + C_star))\n        M_star = (alpha_M / delta_M) * (C_star / (K_M + C_star))\n        \n        return N_star, M_star, C_star\n\n    results = []\n    for case in test_cases:\n        pi_0, r = case[-2], case[-1]\n        params = case[:-2]\n        \n        # Calculate equilibrium for baseline production pi_0\n        N_base, M_base, C_base = calculate_equilibrium(pi_0, params)\n        \n        # Calculate equilibrium for aged production pi_aged\n        pi_aged = r * pi_0\n        N_aged, M_aged, C_aged = calculate_equilibrium(pi_aged, params)\n        \n        # Calculate fractional changes\n        delta_N = (N_aged - N_base) / N_base if N_base != 0 else 0\n        delta_M = (M_aged - M_base) / M_base if M_base != 0 else 0\n        delta_C = (C_aged - C_base) / C_base if C_base != 0 else 0\n        \n        results.append([delta_N, delta_M, delta_C])\n\n    # Format the final output string exactly as specified.\n    inner_strings = []\n    for sublist in results:\n        num_strings = [f\"{x:.6f}\" for x in sublist]\n        inner_strings.append(f\"[{','.join(num_strings)}]\")\n    \n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "4391454"}, {"introduction": "胸腺功能的衰退是免疫衰老的一个核心特征，导致新初始T细胞的供应减少。T细胞受体切除圈（TRECs）是一种天然的生物标志物，可用于追踪近期的胸腺输出细胞。本练习旨在挑战您基于TREC稀释动力学构建一个数学模型，以量化胸腺功能的衰退速率，这项实践融合了细胞群体动力学原理与数据分析，是定量系统免疫学的一项核心技能[@problem_id:4391475]。", "problem": "考虑人体衰老过程中的初始T细胞区室。设 $N(t)$ 表示在年龄 $t$（以年为单位）时的初始T细胞数量，其受胸腺输出 $E(t)$（细胞/年）和每个细胞的稳态增殖速率 $r$（年$^{-1}$）驱动。将初始区室中T细胞受体切除环（TREC; T-cell Receptor Excision Circle）的总数定义为 $S(t)$，每个初始T细胞的平均TREC含量定义为 $T(t) = S(t)/N(t)$。假设每个近期胸腺移植物（RTE; Recent Thymic Emigrant）在输出时平均携带 $c_0$ 个TREC，并且TREC在细胞分裂过程中不被复制。假设初始T细胞以每个细胞 $\\delta$（年$^{-1}$）的速率丢失。\n\n从第一性原理出发——具体来说，即细胞分裂时TREC含量的守恒、细胞数量的质量平衡以及导数的商法则——推导出一个关于 $E(t)$ 的解析表达式，用 $N(t)$、$T(t)$、$c_0$、$r$ 和 $\\frac{dT}{dt}$ 表示，且不引入任何快捷公式。\n\n然后，使用以下科学上合理的年龄依赖函数和参数来估计胸腺输出随年龄下降的情况：\n- $N(t) = N_0 \\exp(-\\mu t)$，其中 $N_0 = 1.8 \\times 10^{10}$ 细胞，$\\mu = 0.012$ 年$^{-1}$，\n- $T(t) = A \\exp(-\\gamma t) + B$，其中 $A = 0.35$，$\\gamma = 0.025$ 年$^{-1}$，$B = 0.015$，\n- $r = 0.04$ 年$^{-1}$，\n- $c_0 = 1$。\n\n假设 $E(t)$ 随年龄呈指数下降，$E(t) = E_0 \\exp(-\\alpha t)$，其中 $E_0$ 和 $\\alpha$ 为常数。使用您推导的 $E(t)$ 表达式及上述函数，通过在 $t_1 = 20$ 岁和 $t_2 = 50$ 岁时进行求值并消去 $E_0$ 来计算 $\\alpha$。将您的 $\\alpha$ 最终估计值以 年$^{-1}$ 为单位表示，并将答案四舍五入到三位有效数字。", "solution": "该问题需要分两步解决。第一，从第一性原理出发，推导胸腺输出速率 $E(t)$ 的解析表达式。第二，使用此表达式以及给定的函数形式和参数，计算胸腺输出的下降速率 $\\alpha$。\n\n第一部分：$E(t)$ 表达式的推导\n\n我们首先基于质量平衡原理，建立控制初始T细胞群体 $N(t)$ 和总T细胞受体切除环（TREC）含量 $S(t)$ 动态变化的微分方程。\n\n初始T细胞数量的变化率 $\\frac{dN}{dt}$ 是流入总和减去流出总和。来源是速率为 $E(t)$ 的胸腺输出和速率为 $r N(t)$ 的稳态增殖。消耗是速率为 $\\delta N(t)$ 的细胞丢失，其中 $\\delta$ 是单个细胞的丢失速率。这给出了第一个常微分方程（ODE）：\n$$ \\frac{dN}{dt} = E(t) + r N(t) - \\delta N(t) \\quad (1) $$\n\n接下来，我们对总TREC含量 $S(t)$ 进行建模。新TREC的唯一来源是胸腺提供的近期胸腺移植物（RTE）。每年输出的 $E(t)$ 个细胞中，每个细胞平均携带 $c_0$ 个TREC。因此，TREC的流入速率为 $c_0 E(t)$。问题陈述中指出TREC在细胞分裂期间不被复制（分裂时TREC含量守恒），这意味着稳态增殖不会产生新的TREC，它只是将现有的TREC池稀释到更多细胞中。TREC的丢失是通过携带它们的细胞死亡而发生的。细胞总丢失速率为 $\\delta N(t)$。由于每个细胞的平均TREC含量为 $T(t)$，TREC的丢失速率是细胞丢失速率与每个细胞平均TREC含量的乘积：$\\delta N(t) T(t)$。这也可以写成 $\\delta S(t)$，因为 $S(t) = N(t) T(t)$。因此，$S(t)$ 的常微分方程为：\n$$ \\frac{dS}{dt} = c_0 E(t) - \\delta N(t) T(t) \\quad (2) $$\n\n问题要求用 $N(t)$、$T(t)$、$c_0$、$r$ 和 $\\frac{dT}{dt}$ 表示 $E(t)$ 的表达式。这需要我们将这些导数关联起来。平均TREC含量定义为 $T(t) = \\frac{S(t)}{N(t)}$。问题指导我们使用商法则来求其导数：\n$$ \\frac{dT}{dt} = \\frac{d}{dt}\\left(\\frac{S(t)}{N(t)}\\right) = \\frac{N(t)\\frac{dS}{dt} - S(t)\\frac{dN}{dt}}{[N(t)]^2} $$\n两边乘以 $[N(t)]^2$ 并代入 $S(t) = N(t)T(t)$，我们得到：\n$$ [N(t)]^2 \\frac{dT}{dt} = N(t)\\frac{dS}{dt} - N(t)T(t)\\frac{dN}{dt} $$\n两边除以 $N(t)$（假设 $N(t)  0$），我们有：\n$$ N(t)\\frac{dT}{dt} = \\frac{dS}{dt} - T(t)\\frac{dN}{dt} \\quad (3) $$\n现在，我们将方程 $(1)$ 中的 $\\frac{dN}{dt}$ 和方程 $(2)$ 中的 $\\frac{dS}{dt}$ 的表达式代入方程 $(3)$：\n$$ N(t)\\frac{dT}{dt} = \\left( c_0 E(t) - \\delta N(t) T(t) \\right) - T(t)\\left( E(t) + r N(t) - \\delta N(t) \\right) $$\n我们将右侧的 $T(t)$ 项展开：\n$$ N(t)\\frac{dT}{dt} = c_0 E(t) - \\delta N(t) T(t) - T(t) E(t) - r N(t) T(t) + \\delta N(t) T(t) $$\n涉及丢失速率 $\\delta$ 的项，即 $- \\delta N(t) T(t)$ 和 $+ \\delta N(t) T(t)$，相互抵消。这是关键的一步，因为它消除了未知参数 $\\delta$。\n$$ N(t)\\frac{dT}{dt} = c_0 E(t) - T(t) E(t) - r N(t) T(t) $$\n现在，我们重新整理方程以求解 $E(t)$。我们将含有 $E(t)$ 的项归到一边，所有其他项归到另一边：\n$$ N(t)\\frac{dT}{dt} + r N(t) T(t) = c_0 E(t) - T(t) E(t) $$\n在右侧提取公因式 $E(t)$，得到：\n$$ N(t)\\frac{dT}{dt} + r N(t) T(t) = E(t) \\left( c_0 - T(t) \\right) $$\n最后，两边除以 $(c_0 - T(t))$，得到所需的 $E(t)$ 解析表达式：\n$$ E(t) = \\frac{N(t) \\frac{dT}{dt} + r N(t) T(t)}{c_0 - T(t)} $$\n\n第二部分：下降速率 $\\alpha$ 的计算\n\n给定以下函数和参数：\n$N(t) = N_0 \\exp(-\\mu t)$，其中 $N_0 = 1.8 \\times 10^{10}$，$\\mu = 0.012$ 年$^{-1}$。\n$T(t) = A \\exp(-\\gamma t) + B$，其中 $A = 0.35$，$\\gamma = 0.025$ 年$^{-1}$，$B = 0.015$。\n$r = 0.04$ 年$^{-1}$。\n$c_0 = 1$。\n假设胸腺输出 $E(t)$ 是年龄的指数函数：$E(t) = E_0 \\exp(-\\alpha t)$。\n\n首先，我们计算 $T(t)$ 的导数：\n$$ \\frac{dT}{dt} = \\frac{d}{dt} \\left( A \\exp(-\\gamma t) + B \\right) = -A \\gamma \\exp(-\\gamma t) $$\n将 $N(t)$、$T(t)$ 和 $\\frac{dT}{dt}$ 的表达式代入我们推导出的 $E(t)$ 公式中：\n$$ E_0 \\exp(-\\alpha t) = \\frac{[N_0 \\exp(-\\mu t)][-A \\gamma \\exp(-\\gamma t)] + r [N_0 \\exp(-\\mu t)][A \\exp(-\\gamma t) + B]}{c_0 - (A \\exp(-\\gamma t) + B)} $$\n我们可以从分子中提取公因式 $N_0 \\exp(-\\mu t)$：\n$$ E_0 \\exp(-\\alpha t) = \\frac{N_0 \\exp(-\\mu t) \\left( -A \\gamma \\exp(-\\gamma t) + rA \\exp(-\\gamma t) + rB \\right)}{c_0 - B - A \\exp(-\\gamma t)} $$\n$$ E_0 \\exp(-\\alpha t) = N_0 \\exp(-\\mu t) \\left( \\frac{A(r - \\gamma)\\exp(-\\gamma t) + rB}{c_0 - B - A \\exp(-\\gamma t)} \\right) $$\n设 $F(t) = E_0 \\exp(-\\alpha t)$。问题要求通过在 $t_1 = 20$ 岁和 $t_2 = 50$ 岁时求值并消去 $E_0$ 来找到 $\\alpha$。我们可以构建一个比率：\n$$ \\frac{F(t_1)}{F(t_2)} = \\frac{E_0 \\exp(-\\alpha t_1)}{E_0 \\exp(-\\alpha t_2)} = \\exp(-\\alpha(t_1 - t_2)) $$\n从推导出的表达式可知，这个比率也等于：\n$$ \\frac{F(t_1)}{F(t_2)} = \\frac{N_0 \\exp(-\\mu t_1)}{N_0 \\exp(-\\mu t_2)} \\times \\frac{\\frac{A(r-\\gamma)\\exp(-\\gamma t_1) + rB}{c_0-B-A\\exp(-\\gamma t_1)}}{\\frac{A(r-\\gamma)\\exp(-\\gamma t_2) + rB}{c_0-B-A\\exp(-\\gamma t_2)}} $$\n$$ \\exp(-\\alpha(t_1 - t_2)) = \\exp(-\\mu(t_1 - t_2)) \\times \\frac{\\frac{A(r-\\gamma)\\exp(-\\gamma t_1) + rB}{c_0-B-A\\exp(-\\gamma t_1)}}{\\frac{A(r-\\gamma)\\exp(-\\gamma t_2) + rB}{c_0-B-A\\exp(-\\gamma t_2)}} $$\n对两边取自然对数：\n$$ -\\alpha(t_1 - t_2) = -\\mu(t_1 - t_2) + \\ln\\left(\\frac{A(r-\\gamma)\\exp(-\\gamma t_1) + rB}{c_0-B-A\\exp(-\\gamma t_1)}\\right) - \\ln\\left(\\frac{A(r-\\gamma)\\exp(-\\gamma t_2) + rB}{c_0-B-A\\exp(-\\gamma t_2)}\\right) $$\n求解 $\\alpha$：\n$$ \\alpha = \\mu - \\frac{1}{t_1 - t_2} \\left[ \\ln\\left(\\frac{A(r-\\gamma)\\exp(-\\gamma t_1) + rB}{c_0-B-A\\exp(-\\gamma t_1)}\\right) - \\ln\\left(\\frac{A(r-\\gamma)\\exp(-\\gamma t_2) + rB}{c_0-B-A\\exp(-\\gamma t_2)}\\right) \\right] $$\n让我们代入数值：\n$t_1 = 20$，$t_2 = 50$，所以 $t_1 - t_2 = -30$。\n$\\mu = 0.012$，$\\gamma = 0.025$，$r = 0.04$，$c_0 = 1$，$A = 0.35$，$B = 0.015$。\n$r - \\gamma = 0.04 - 0.025 = 0.015$。\n$A(r - \\gamma) = 0.35 \\times 0.015 = 0.00525$。\n$rB = 0.04 \\times 0.015 = 0.0006$。\n$c_0 - B = 1 - 0.015 = 0.985$。\n\n设 $G(t) = \\frac{0.00525\\exp(-0.025 t) + 0.0006}{0.985 - 0.35\\exp(-0.025 t)}$。\n$$ \\alpha = 0.012 - \\frac{1}{-30} \\left[ \\ln(G(20)) - \\ln(G(50)) \\right] = 0.012 + \\frac{1}{30} \\ln\\left(\\frac{G(20)}{G(50)}\\right) $$\n现在，我们计算 $G(20)$ 和 $G(50)$：\n对于 $t_1 = 20$：$\\exp(-0.025 \\times 20) = \\exp(-0.5) \\approx 0.60653066$。\n$$ G(20) = \\frac{0.00525(0.60653066) + 0.0006}{0.985 - 0.35(0.60653066)} = \\frac{0.0031842859 + 0.0006}{0.985 - 0.21228573} = \\frac{0.0037842859}{0.77271427} \\approx 0.00489744 $$\n对于 $t_2 = 50$：$\\exp(-0.025 \\times 50) = \\exp(-1.25) \\approx 0.2865048$。\n$$ G(50) = \\frac{0.00525(0.2865048) + 0.0006}{0.985 - 0.35(0.2865048)} = \\frac{0.0015041502 + 0.0006}{0.985 - 0.10027668} = \\frac{0.0021041502}{0.88472332} \\approx 0.00237840 $$\n现在我们计算 $\\alpha$：\n$$ \\alpha \\approx 0.012 + \\frac{1}{30} \\ln\\left(\\frac{0.00489744}{0.00237840}\\right) $$\n$$ \\alpha \\approx 0.012 + \\frac{1}{30} \\ln(2.05911) $$\n$$ \\alpha \\approx 0.012 + \\frac{1}{30}(0.72225) $$\n$$ \\alpha \\approx 0.012 + 0.024075 $$\n$$ \\alpha \\approx 0.036075 $$\n将最终答案四舍五入到三位有效数字，我们得到 $\\alpha \\approx 0.0361$。单位是 年$^{-1}$。", "answer": "$$\\boxed{0.0361}$$", "id": "4391475"}, {"introduction": "随着年龄的增长，T细胞可能会进入衰竭或衰老等功能失调状态，但区分这些状态可能很复杂，因为它们具有重叠的分子标记。单细胞技术为解析这种异质性提供了所需的高分辨率数据。这项计算实践将指导您建立一个概率分类器，根据T细胞的单细胞蛋白表达谱将其分配到不同的功能状态，您将学习应用贝叶斯原理，不仅量化这些状态的比例，还量化估计的不确定性，这体现了现代数据驱动免疫学的一个关键方面[@problem_id:4391421]。", "problem": "给定四种广泛用于表征衰老过程中 T 细胞功能衰退的标志物的单细胞标准化表达测量值：程序性死亡蛋白 1 (PD-1)、胸腺细胞选择相关高迁移率族蛋白 (TOX)、分化簇 57 (CD57) 和杀伤细胞凝集素样受体亚家族 G 成员 1 (KLRG1)。您将构建一个有原则的概率分类器，将每个细胞分配到与系统免疫学和免疫衰老一致的三个潜在状态之一：耗竭状态 $E$、衰老状态 $S$ 或其他/非功能障碍状态 $N$。然后，您将计算一个老年队列的队列级状态比例和不确定性。\n\n使用以下基本依据、假设和定义：\n- 用于潜在状态推断的贝叶斯定理：对于特征向量为 $x \\in \\mathbb{R}^4$ 的细胞，后验概率满足 $p(z \\mid x) \\propto p(z) \\, p(x \\mid z)$，其中 $z \\in \\{E,S,N\\}$。\n- 在状态条件下各标志物之间的朴素独立性假设：$p(x \\mid z) = \\prod_{m \\in \\{\\text{PD-1}, \\text{TOX}, \\text{CD57}, \\text{KLRG1}\\}} p(x_m \\mid z)$。\n- 对于每个标志物 $m$ 和状态 $z$，使用已知参数将 $x_m \\mid z \\sim \\mathcal{N}(\\mu_{m,z}, \\sigma_{m,z}^2)$ 建模。高斯概率密度函数为 $f(x \\mid \\mu, \\sigma^2) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp\\!\\left( -\\frac{(x - \\mu)^2}{2 \\sigma^2} \\right)$。\n- 老年队列的先验状态概率为 $p(E) = 0.35$，$p(S) = 0.45$ 和 $p(N) = 0.20$。\n- 使用以下反映在耗竭与衰老中观察到的标志物水平趋势的科学上合理的参数化：\n  - 耗竭 $E$：$\\mu_{\\text{PD-1},E} = 3.0$，$\\sigma_{\\text{PD-1},E} = 0.8$；$\\mu_{\\text{TOX},E} = 2.5$，$\\sigma_{\\text{TOX},E} = 0.7$；$\\mu_{\\text{CD57},E} = 0.8$，$\\sigma_{\\text{CD57},E} = 0.5$；$\\mu_{\\text{KLRG1},E} = 0.9$，$\\sigma_{\\text{KLRG1},E} = 0.5$。\n  - 衰老 $S$：$\\mu_{\\text{PD-1},S} = 1.2$，$\\sigma_{\\text{PD-1},S} = 0.6$；$\\mu_{\\text{TOX},S} = 1.0$，$\\sigma_{\\text{TOX},S} = 0.6$；$\\mu_{\\text{CD57},S} = 3.2$，$\\sigma_{\\text{CD57},S} = 0.7$；$\\mu_{\\text{KLRG1},S} = 3.0$，$\\sigma_{\\text{KLRG1},S} = 0.8$。\n  - 其他 $N$：$\\mu_{\\text{PD-1},N} = 0.5$，$\\sigma_{\\text{PD-1},N} = 0.4$；$\\mu_{\\text{TOX},N} = 0.5$，$\\sigma_{\\text{TOX},N} = 0.4$；$\\mu_{\\text{CD57},N} = 0.5$，$\\sigma_{\\text{CD57},N} = 0.4$；$\\mu_{\\text{KLRG1},N} = 0.5$，$\\sigma_{\\text{KLRG1},N} = 0.4$。\n- 为保证数值稳定性，通过对数概率和 log-sum-exp 恒等式计算后验概率：对于向量 $a \\in \\mathbb{R}^K$，$\\log\\!\\left(\\sum_{k=1}^K \\exp(a_k)\\right) = c + \\log\\!\\left(\\sum_{k=1}^K \\exp(a_k - c)\\right)$，其中 $c = \\max_k a_k$。\n- 设状态 $z$ 的队列级期望比例为 $\\hat{\\pi}_z = \\frac{1}{n} \\sum_{i=1}^n p(z \\mid x^{(i)})$，其中 $n$ 是细胞数量，$x^{(i)}$ 是第 $i$ 个细胞的标志物向量。\n- 使用多项式状态比例上的共轭先验来量化不确定性：一个对称狄利克雷先验 $\\mathrm{Dir}(\\alpha_0)$，其中 $\\alpha_0 = (1,1,1)$。后验参数为 $\\alpha = \\alpha_0 + \\sum_{i=1}^n \\big(p(E \\mid x^{(i)}), p(S \\mid x^{(i)}), p(N \\mid x^{(i)})\\big)$。$\\pi_z$ 的边际分布为 $\\mathrm{Beta}(\\alpha_z, \\sum_{k} \\alpha_k - \\alpha_z)$。使用分位数函数报告 $0.95$ 可信区间：下界是相应贝塔分布的 $q_{0.025}$，上界是 $q_{0.975}$。\n\n实现上述分类器和不确定性计算。不要使用任何外部输入；仅对下面提供的测试套件进行操作。\n\n测试套件（每个测试用例是一个单细胞列表；每个细胞是 $x^{(i)} = (\\text{PD-1}, \\text{TOX}, \\text{CD57}, \\text{KLRG1})$）：\n- 案例 A（混合老年队列，一般情况，$n = 12$）：\n  $$\n  \\big(3.6, 2.9, 0.7, 0.8\\big), \\big(3.2, 2.4, 0.6, 1.1\\big), \\big(2.8, 2.6, 1.0, 0.9\\big), \\big(3.0, 2.7, 0.7, 0.6\\big),\n  $$\n  $$\n  \\big(1.0, 0.9, 3.3, 3.2\\big), \\big(1.4, 1.3, 3.0, 2.7\\big), \\big(1.3, 1.1, 3.4, 3.5\\big), \\big(0.8, 0.7, 2.9, 3.0\\big),\n  $$\n  $$\n  \\big(0.6, 0.5, 0.4, 0.5\\big), \\big(0.4, 0.6, 0.6, 0.4\\big), \\big(0.5, 0.5, 0.5, 0.6\\big), \\big(0.3, 0.4, 0.5, 0.5\\big).\n  $$\n- 案例 B（模糊边界情况，$n = 5$）：\n  $$\n  \\big(1.5, 1.6, 1.4, 1.5\\big), \\big(1.7, 1.4, 1.6, 1.5\\big), \\big(1.6, 1.5, 1.5, 1.6\\big), \\big(1.4, 1.6, 1.4, 1.4\\big), \\big(1.5, 1.5, 1.5, 1.5\\big).\n  $$\n- 案例 C（低表达边缘情况，$n = 5$）：\n  $$\n  \\big(0.1, 0.2, 0.1, 0.2\\big), \\big(0.2, 0.1, 0.2, 0.1\\big), \\big(0.0, 0.0, 0.0, 0.0\\big), \\big(0.3, 0.3, 0.2, 0.2\\big), \\big(0.1, 0.1, 0.3, 0.3\\big).\n  $$\n\n每个测试用例的所需输出：\n- 生成一个包含九个浮点数的摘要列表 $[\\hat{\\pi}_E, \\hat{\\pi}_S, \\hat{\\pi}_N, L_E, U_E, L_S, U_S, L_N, U_N]$，其中 $L_z$ 和 $U_z$ 是由狄利克雷后验诱导的贝塔边际分布得出的 $\\pi_z$ 的 $0.95$ 可信区间的下界和上界。\n- 所有浮点数必须四舍五入到 4 位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，列表中的每个元素是对应一个测试用例的摘要列表。例如，最终输出格式必须类似于 $[\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$，但只包含数值和逗号（没有空格）。", "solution": "该问题被评估为有效。这是一个在计算系统生物学领域中定义明确、有科学依据且客观的问题。它提供了一套完整的假设、参数、数据和明确的目标，从而能够得出一个唯一且可验证的解决方案。所规定的方法——一个使用高斯似然的朴素贝叶斯分类器，并通过狄利克雷-多项式模型进行贝叶斯不确定性量化——是处理此类细胞状态分类任务的标准且合适的技术。所有数据和参数都已提供，并且没有内部矛盾或歧义。\n\n解决方案通过实现指定的概率分类器来推进。该方法的核心是贝叶斯定理，该定理指出，在给定细胞标志物表达谱 $x$ 的情况下，一个细胞属于某个潜在状态 $z$ 的后验概率，正比于在状态 $z$ 下观测到 $x$ 的似然乘以状态 $z$ 的先验概率。\n$$\np(z \\mid x) = \\frac{p(x \\mid z) p(z)}{p(x)} \\propto p(x \\mid z) p(z)\n$$\n其中 $z \\in \\{E, S, N\\}$ 分别代表耗竭、衰老和其他/非功能障碍状态。项 $p(x) = \\sum_{z'} p(x \\mid z') p(z')$ 是一个归一化常数，确保后验概率之和为 $1$。\n\n问题陈述要求使用朴素独立性假设，即在给定细胞状态的条件下，标志物表达水平是条件独立的。这简化了似然计算：\n$$\np(x \\mid z) = \\prod_{m} p(x_m \\mid z)\n$$\n其中 $m$ 索引了四个标志物：PD-1, TOX, CD57 和 KLRG1。每个条件似然 $p(x_m \\mid z)$ 都被建模为高斯（正态）分布，$x_m \\mid z \\sim \\mathcal{N}(\\mu_{m,z}, \\sigma_{m,z}^2)$，具有给定的状态特定均值 ($\\mu$) 和标准差 ($\\sigma$) 参数。其概率密度函数 (PDF) 为：\n$$\np(x_m \\mid \\mu_{m,z}, \\sigma^2_{m,z}) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2_{m,z}}} \\exp\\left( -\\frac{(x_m - \\mu_{m,z})^2}{2 \\sigma^2_{m,z}} \\right)\n$$\n为避免因乘以许多小概率而导致的数值下溢，所有计算都在对数空间中执行。对数后验概率正比于对数先验和对数似然之和：\n$$\n\\log p(z \\mid x) \\propto \\log p(z) + \\log p(x \\mid z) = \\log p(z) + \\sum_{m} \\log p(x_m \\mid z)\n$$\n高斯分布的对数概率密度函数 (log-PDF) 是：\n$$\n\\log p(x_m \\mid \\mu_{m,z}, \\sigma^2_{m,z}) = -\\frac{(x_m - \\mu_{m,z})^2}{2 \\sigma^2_{m,z}} - \\log(\\sigma_{m,z}) - \\frac{1}{2}\\log(2\\pi)\n$$\n令 $a_z = \\log p(z) + \\sum_{m} \\log p(x_m \\mid z)$ 为状态 $z$ 的未归一化对数后验。为了获得归一化的后验概率 $p(z \\mid x)$，我们使用 log-sum-exp 技巧来保证数值稳定性。归一化常数（证据）的对数为 $\\log p(x) = \\log(\\sum_{z'} \\exp(a_{z'}))$。其计算方式如下：\n$$\n\\log p(x) = c + \\log\\left(\\sum_{z'} \\exp(a_{z'} - c)\\right), \\quad \\text{where } c = \\max_{z'} a_{z'}\n$$\n最终的对数后验是 $\\log p(z \\mid x) = a_z - \\log p(x)$，而后验概率是 $p(z \\mid x) = \\exp(\\log p(z \\mid x))$。此过程应用于给定队列中的每个细胞 $x^{(i)}$。\n\n在计算完一个队列中所有 $n$ 个细胞的后验概率 $p(z \\mid x^{(i)})$ 后，每个状态的队列级期望比例 $\\hat{\\pi}_z$ 通过对这些后验概率求平均值来计算：\n$$\n\\hat{\\pi}_z = \\frac{1}{n} \\sum_{i=1}^n p(z \\mid x^{(i)})\n$$\n这些比例的不确定性采用贝叶斯方法进行量化。问题指定了状态比例 $\\vec{\\pi} = (\\pi_E, \\pi_S, \\pi_N)$ 上的一个对称狄利克雷先验，参数为 $\\alpha_0 = (1, 1, 1)$。$\\vec{\\pi}$ 上的后验分布也是一个狄利克雷分布，其更新后的参数 $\\alpha = (\\alpha_E, \\alpha_S, \\alpha_N)$ 计算如下：\n$$\n\\alpha_z = \\alpha_{0,z} + \\sum_{i=1}^{n} p(z \\mid x^{(i)})\n$$\n从狄利克雷后验 $\\mathrm{Dir}(\\alpha)$ 中，单个比例 $\\pi_z$ 的边际分布是一个贝塔分布：\n$$\n\\pi_z \\sim \\mathrm{Beta}\\left(\\alpha_z, \\sum_{k \\neq z} \\alpha_k\\right)\n$$\n每个 $\\pi_z$ 的 $0.95$ 可信区间是通过找到其相应边际贝塔分布的 $0.025$ 和 $0.975$ 分位数来获得的。这是通过使用百分点函数 (PPF)，即累积分布函数 (CDF) 的逆函数来实现的。\n\n该实现将通过应用整个流程来处理每个测试用例：计算每个细胞的后验概率，对其求平均以找到队列比例，然后从狄利克雷后验的贝塔边际分布计算可信区间。每个案例的最终输出是一个包含九个四舍五入的浮点数的列表：$[\\hat{\\pi}_E, \\hat{\\pi}_S, \\hat{\\pi}_N, L_E, U_E, L_S, U_S, L_N, U_N]$，其中 $L_z$ 和 $U_z$ 是可信区间的下界和上界。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm, beta\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the problem-solving process.\n    It defines parameters, test cases, and orchestrates the computation\n    and formatting of the final output.\n    \"\"\"\n    \n    # Define parameters for the Gaussian mixture model\n    # States are E (Exhaustion), S (Senescence), N (Other)\n    # Markers are PD-1, TOX, CD57, KLRG1\n    params = {\n        'E': {\n            'prior': 0.35,\n            'mu': np.array([3.0, 2.5, 0.8, 0.9]),\n            'sigma': np.array([0.8, 0.7, 0.5, 0.5])\n        },\n        'S': {\n            'prior': 0.45,\n            'mu': np.array([1.2, 1.0, 3.2, 3.0]),\n            'sigma': np.array([0.6, 0.6, 0.7, 0.8])\n        },\n        'N': {\n            'prior': 0.20,\n            'mu': np.array([0.5, 0.5, 0.5, 0.5]),\n            'sigma': np.array([0.4, 0.4, 0.4, 0.4])\n        }\n    }\n    states = ['E', 'S', 'N']\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: mixed older cohort, general case, n = 12\n        [\n            (3.6, 2.9, 0.7, 0.8), (3.2, 2.4, 0.6, 1.1), (2.8, 2.6, 1.0, 0.9), (3.0, 2.7, 0.7, 0.6),\n            (1.0, 0.9, 3.3, 3.2), (1.4, 1.3, 3.0, 2.7), (1.3, 1.1, 3.4, 3.5), (0.8, 0.7, 2.9, 3.0),\n            (0.6, 0.5, 0.4, 0.5), (0.4, 0.6, 0.6, 0.4), (0.5, 0.5, 0.5, 0.6), (0.3, 0.4, 0.5, 0.5)\n        ],\n        # Case B: ambiguous boundary case, n = 5\n        [\n            (1.5, 1.6, 1.4, 1.5), (1.7, 1.4, 1.6, 1.5), (1.6, 1.5, 1.5, 1.6), (1.4, 1.6, 1.4, 1.4), (1.5, 1.5, 1.5, 1.5)\n        ],\n        # Case C: low-expression edge case, n = 5\n        [\n            (0.1, 0.2, 0.1, 0.2), (0.2, 0.1, 0.2, 0.1), (0.0, 0.0, 0.0, 0.0), (0.3, 0.3, 0.2, 0.2), (0.1, 0.1, 0.3, 0.3)\n        ]\n    ]\n\n    all_results = []\n    for cohort_data in test_cases:\n        result = process_cohort(cohort_data, params, states)\n        all_results.append(result)\n\n    # Format the final output string as per requirements\n    case_strs = []\n    for res_list in all_results:\n        # Format each list of floats into \"[v1,v2,...,v9]\" with 4 decimal places\n        case_str = f\"[{','.join([f'{x:.4f}' for x in res_list])}]\"\n        case_strs.append(case_str)\n    \n    final_output = f\"[{','.join(case_strs)}]\"\n    print(final_output)\n\ndef process_cohort(cohort_data, params, states):\n    \"\"\"\n    Processes a single cohort of cells to compute state proportions and uncertainty.\n\n    Args:\n        cohort_data (list of tuples): A list where each tuple contains the 4 marker\n                                      expression values for a single cell.\n        params (dict): A dictionary containing priors, means (mu), and standard\n                       deviations (sigma) for each state.\n        states (list of str): A list of state keys (e.g., ['E', 'S', 'N']).\n\n    Returns:\n        list of floats: A 9-element list containing the estimated proportions\n                        and credible interval bounds for each state.\n    \"\"\"\n    n_cells = len(cohort_data)\n    n_states = len(states)\n    \n    # Store posterior probabilities for each cell\n    cohort_posteriors = np.zeros((n_cells, n_states))\n    \n    log_priors = np.array([np.log(params[s]['prior']) for s in states])\n\n    for i, cell_data in enumerate(cohort_data):\n        x = np.array(cell_data)\n        \n        # Calculate log-likelihood for each state\n        log_likelihoods = np.zeros(n_states)\n        for j, state in enumerate(states):\n            mu = params[state]['mu']\n            sigma = params[state]['sigma']\n            # Sum of log-pdfs for each marker under Naive Bayes assumption\n            log_likelihoods[j] = np.sum(norm.logpdf(x, loc=mu, scale=sigma))\n            \n        # Calculate unnormalized log-posteriors\n        unnormalized_log_posteriors = log_priors + log_likelihoods\n        \n        # Normalize using log-sum-exp trick for numerical stability\n        c = np.max(unnormalized_log_posteriors)\n        log_sum_exp = c + np.log(np.sum(np.exp(unnormalized_log_posteriors - c)))\n        log_posteriors = unnormalized_log_posteriors - log_sum_exp\n        \n        # Convert back to probabilities and store\n        cohort_posteriors[i, :] = np.exp(log_posteriors)\n\n    # 1. Compute cohort-level expected proportions (pi_hat)\n    pi_hats = np.mean(cohort_posteriors, axis=0)\n    \n    # 2. Compute uncertainty using Dirichlet-Multinomial model\n    # Sum of posterior probabilities across the cohort\n    sum_posteriors = np.sum(cohort_posteriors, axis=0)\n    \n    # Dirichlet prior parameter alpha_0\n    alpha_0 = np.ones(n_states)\n    \n    # Dirichlet posterior parameters alpha\n    alpha_posterior = alpha_0 + sum_posteriors\n    \n    # Sum of posterior alphas\n    alpha_sum = np.sum(alpha_posterior)\n    \n    # Calculate 95% credible intervals from marginal Beta distributions\n    credible_intervals = []\n    for j in range(n_states):\n        alpha_z = alpha_posterior[j]\n        # The second parameter of the Beta distribution is (sum of all alphas) - alpha_z\n        beta_z = alpha_sum - alpha_z\n        # Get lower (0.025) and upper (0.975) bounds\n        ci_bounds = beta.ppf([0.025, 0.975], alpha_z, beta_z)\n        credible_intervals.extend(ci_bounds)\n        \n    # Combine results: [pi_E, pi_S, pi_N, L_E, U_E, L_S, U_S, L_N, U_N]\n    final_results = np.concatenate((pi_hats, np.array(credible_intervals)))\n    \n    return final_results.tolist()\n\nsolve()\n```", "id": "4391421"}]}