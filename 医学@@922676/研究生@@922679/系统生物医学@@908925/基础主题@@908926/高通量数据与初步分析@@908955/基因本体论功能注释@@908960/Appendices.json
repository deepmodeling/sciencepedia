{"hands_on_practices": [{"introduction": "功能富集分析依赖于统计检验（最常见的是超几何检验）来评估功能术语的过表达情况。然而，统计显著性对背景基因集的选择高度敏感。本练习将通过动手计算，向您展示为什么使用整个基因组而非实验中可检测到的基因集作为背景，会导致统计显著性的显著膨胀和错误的发现。", "problem": "在使用基因本体论（Gene Ontology, GO）进行功能注释时，我们会检验一组差异表达基因相较于一个合适的背景基因集，是否在某个GO术语上显著富集。合适的背景基因集是指在该检测方法中可能被检测到的所有基因的集合，而非整个基因组。考虑以下这个为阐明选择错误背景基因集所带来的影响而设计的、具有科学真实性的简化情景。\n\n一项靶向检测分析了一个包含 $N=30$ 个基因的精选基因板。经过严格的质量控制，该基因板中只有 $D=20$ 个基因被认为是可检测的。一个特定的GO术语 $T$ 注释了整个基因板 $N=30$ 个基因中的 $K_{\\mathrm{genome}}=10$ 个，以及 $D=20$ 个可检测基因中的 $K_{\\mathrm{detectable}}=8$ 个。在一个感兴趣的对比分析中，差异分析得到一个大小为 $n=5$ 的基因集，其中有 $k=3$ 个基因被术语 $T$ 注释。\n\n仅从无放回抽样和组合计数的基本原理出发，并将单侧富集显著性视为从一个总共包含 $N$ 个项目、其中有 $K$ 个被注释的项目的背景集中，抽取 $n$ 次，抽到至少 $k$ 个被注释项目的概率，完成以下任务：\n\n1. 推导在参数为 $(N,K)$ 的背景集中抽取 $n$ 次，观测到至少 $k$ 个被注释基因的单侧尾部概率的通用计数表达式。\n2. 使用观测值 $(n=5, k=3)$，分别对两种背景集选择——错误的“基因组”背景 $(N=30, K=10)$ 和正确的可检测基因背景 $(N=20, K=8)$——计算此概率。\n3. 将显著性膨胀因子定义为 $I = p_{\\mathrm{detectable}} / p_{\\mathrm{genome}}$，其中 $p_{\\mathrm{detectable}}$ 是在可检测基因背景下的单侧 $p$ 值，$p_{\\mathrm{genome}}$ 是在基因组背景下的单侧 $p$ 值。计算 $I$。\n\n将 $I$ 以一个无量纲数的形式报告，并四舍五入到四位有效数字。", "solution": "对于一个给定的术语，基因本体论（GO）富集检验会将研究基因集中观测到的被注释基因数量，与从一个特定背景集中进行无放回随机抽样所预期的分布进行比较。一项检测的正确背景集是该检测方法可能检测到的所有基因的集合；使用过大或过小的背景集会改变零分布，并可能使显著性产生偏差。\n\n基本原理：从一个包含 $N$ 个总项目的有限总体中进行无放回抽样，其中 $K$ 个是“被注释的”（成功），$N-K$ 个是“未被注释的”（失败）。无放回地抽取 $n$ 个项目，得到一个随机变量 $X$，其值等于抽中被注释项目的数量。$X$ 的精确分布是超几何分布，它由组合计数推导而来：精确抽中 $i$ 个被注释项目和 $n-i$ 个未被注释项目的方法数，等于选择被注释项目的方法数与选择未被注释项目的方法数的乘积，再除以从 $N$ 个项目中选择 $n$ 个项目的总方法数。\n\n1. 单侧尾部概率的推导。在 $n$ 次抽样中观测到恰好 $i$ 个被注释项目的概率为\n$$\n\\Pr(X=i) = \\frac{\\binom{K}{i}\\,\\binom{N-K}{n-i}}{\\binom{N}{n}},\n$$\n该公式的得出，是通过计算选择 $i$ 个被注释项目的方法数 $\\binom{K}{i}$ 和选择 $n-i$ 个未被注释项目的方法数 $\\binom{N-K}{n-i}$，然后由大小为 $n$ 的子集总数 $\\binom{N}{n}$ 进行归一化。对于观测到 $k$ 个或更多被注释项目的情况，单侧富集显著性即为上尾概率\n$$\np(N,K;n,k) \\equiv \\Pr(X \\ge k) = \\sum_{i=k}^{\\min\\{K,n\\}} \\frac{\\binom{K}{i}\\,\\binom{N-K}{n-i}}{\\binom{N}{n}}.\n$$\n\n2. 使用观测值 $n=5$ 和 $k=3$ 对两种背景集进行评估。\n\n(a) 错误的“基因组”背景：$(N,K)=(30,10)$。\n这里 $\\min\\{K,n\\}=\\min\\{10,5\\}=5$，所以\n$$\np_{\\mathrm{genome}} = \\sum_{i=3}^{5} \\frac{\\binom{10}{i}\\,\\binom{20}{5-i}}{\\binom{30}{5}}.\n$$\n计算每一项：\n- 当 $i=3$ 时：$\\binom{10}{3}=120$，$\\binom{20}{2}=190$，乘积为 $120 \\times 190 = 22800$。\n- 当 $i=4$ 时：$\\binom{10}{4}=210$，$\\binom{20}{1}=20$，乘积为 $210 \\times 20 = 4200$。\n- 当 $i=5$ 时：$\\binom{10}{5}=252$，$\\binom{20}{0}=1$，乘积为 $252 \\times 1 = 252$。\n\n分子之和：$22800 + 4200 + 252 = 27252$。\n\n分母：$\\binom{30}{5} = 142506$。\n\n因此\n$$\np_{\\mathrm{genome}} = \\frac{27252}{142506}。\n$$\n此分数分子分母同除以 $18$ 可化简为：\n$$\n\\frac{27252}{142506} = \\frac{1514}{7917}.\n$$\n\n(b) 正确的可检测基因背景：$(N,K)=(20,8)$。\n这里 $\\min\\{K,n\\}=\\min\\{8,5\\}=5$，所以\n$$\np_{\\mathrm{detectable}} = \\sum_{i=3}^{5} \\frac{\\binom{8}{i}\\,\\binom{12}{5-i}}{\\binom{20}{5}}.\n$$\n计算每一项：\n- 当 $i=3$ 时：$\\binom{8}{3}=56$，$\\binom{12}{2}=66$，乘积为 $56 \\times 66 = 3696$。\n- 当 $i=4$ 时：$\\binom{8}{4}=70$，$\\binom{12}{1}=12$，乘积为 $70 \\times 12 = 840$。\n- 当 $i=5$ 时：$\\binom{8}{5}=56$，$\\binom{12}{0}=1$，乘积为 $56 \\times 1 = 56$。\n\n分子之和：$3696 + 840 + 56 = 4592$。\n\n分母：$\\binom{20}{5} = 15504$。\n\n因此\n$$\np_{\\mathrm{detectable}} = \\frac{4592}{15504}。\n$$\n此分数分子分母同除以 $16$ 可化简为：\n$$\n\\frac{4592}{15504} = \\frac{287}{969}.\n$$\n\n3. 计算定义的显著性膨胀因子 $I$\n$$\nI \\equiv \\frac{p_{\\mathrm{detectable}}}{p_{\\mathrm{genome}}} = \\frac{\\frac{287}{969}}{\\frac{1514}{7917}} = \\frac{287 \\times 7917}{969 \\times 1514}.\n$$\n分别计算分子和分母的乘积：\n$$\n287 \\times 7917 = 2{,}272{,}179, \\quad 969 \\times 1514 = 1{,}467{,}066.\n$$\n因此\n$$\nI = \\frac{2{,}272{,}179}{1{,}467{,}066} \\approx 1.54879\\ldots\n$$\n四舍五入到四位有效数字，\n$$\nI \\approx 1.549.\n$$\n\n解释：因为GO术语在可检测基因中的频率（$K_{\\mathrm{detectable}}/D = 8/20 = 0.4$）高于其在基因组背景中的频率（$K_{\\mathrm{genome}}/N = 10/30 \\approx 0.333\\ldots$），所以使用基因组背景会降低零假设下的期望值，从而产生一个更小的单侧尾部概率。在这个构造的例子中，由此产生的偏差将表观显著性夸大了约 $I \\approx 1.549$ 倍。", "answer": "$$\\boxed{1.549}$$", "id": "4344210"}, {"introduction": "任何GO分析的基础是正确应用由“真实路径规则”管理的注释传播。然而，此规则并非普遍适用，而是取决于连接GO术语的特定关系类型。本练习引导您思考 `is_a`、`part_of` 和 `regulates` 关系之间的逻辑差异，揭示不当的跨非包含关系传播注释会如何夸大注释数量并产生生物学上误导性的结果。", "problem": "在基因本体论（Gene Ontology, GO）的生物过程（Biological Process, BP）领域中，术语被组织成一个有向无环图（Directed Acyclic Graph, DAG），其中的边编码了诸如“is_a”、“part_of”和“regulates”（包括“positively_regulates”和“negatively_regulates”）等关系。广泛使用的“真实路径规则”（true path rule）适用于“is_a”和“part_of”关系，支持将注释从子术语沿这些关系向上层传播至其所有祖先术语。“regulates”关系族并不表示类包含关系，因此根据定义，它不能保证向上层传播的有效性。考虑以下在一个真核模型系统中科学上合理的 BP 子图和基因注释：\n- 术语和关系：\n  - $t_1$：细胞周期过程。\n  - $t_2$：细胞周期过程的调控，且有 $t_2 \\xrightarrow{\\mathrm{regulates}} t_1$。\n  - $t_3$：细胞周期过程的正调控，且有 $t_3 \\xrightarrow{\\mathrm{is\\_a}} t_2$。\n  - $t_4$：DNA 复制，且有 $t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$。\n  - $t_5$：检查点信号传导，且有 $t_5 \\xrightarrow{\\mathrm{regulates}} t_4$。\n- 基因产物注释及证据：\n  - $g_1 \\rightarrow t_5$ 证据为 Inferred from Direct Assay (IDA)。\n  - $g_2 \\rightarrow t_3$ 证据为 Inferred from Mutant Phenotype (IMP)。\n  - $g_3 \\rightarrow t_4$ 证据为 Inferred from Direct Assay (IDA)。\n  - $g_4 \\rightarrow t_1$ 证据为 Traceable Author Statement (TAS)。\n\n假设一个注释引擎执行“无防护”的向上层传播，将“regulates”关系视为与“part_of”和“is_a”相同（即，它遍历任何类型的边，仿佛它们都能证明类包含关系）。仅使用上述核心定义和集合逻辑，从第一性原理出发，推断这种无防护的传播如何导致注释到 $t_1$ 的基因产物集合膨胀。\n\n您的任务有两部分：\n- 首先，使用该图和注释，识别出在无防护传播下，哪些特定路径导致基因产物被添加到 $t_1$ 中，而根据真实路径规则这些基因产物本不应被计入。\n- 其次，选择一个规则集，该规则集能防止这种膨胀，同时保留所有沿“is_a”和“part_of”关系的有效向上层传播。对于您选择的选项，应用该规则集后，注释到 $t_1$ 的唯一基因产物的预测数量必须与定义所蕴含的逻辑正确数量相匹配。\n\n哪个选项既能确定一个防止膨胀的规则集，又能在传播后给出注释到 $t_1$ 的唯一基因产物的正确预测数量？\n\nA. 采用以下规则集：仅沿“is_a”和“part_of”关系进行向上层传播；绝不遍历任何包含“regulates”族系边（即“regulates”、“positively_regulates”或“negatively_regulates”）的路径，无论后续是什么边；如果存在如“NOT”之类的限定词，则将其作为传播的阻断器。传播后 $t_1$ 的预测数量：$2$。\n\nB. 允许沿“is_a”和“part_of”进行向上层传播，并且仅当“regulates”跳跃紧跟着一个“part_of”跳跃时，才允许单个“regulates”跳跃；在所有其他情况下禁止“regulates”。传播后 $t_1$ 的预测数量：$3$。\n\nC. 允许沿所有边类型进行向上层传播，但在传播后，移除那些其直接注释的术语名称包含子字符串“regulation of”的基因产物。传播后 $t_1$ 的预测数量：$3$。\n\nD. 禁止跨“negatively_regulates”边进行向上层传播，但允许跨“regulates”和“positively_regulates”边传播；否则按常规跨“is_a”和“part_of”传播。传播后 $t_1$ 的预测数量：$4$。", "solution": "用户提供了一个关于基因本体论（GO）框架内注释传播的问题。我将首先验证问题陈述，然后进行全面的推导和选项评估。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n\n该问题提供了以下信息：\n\n*   **本体论术语和定义：**\n    *   $t_1$：细胞周期过程\n    *   $t_2$：细胞周期过程的调控\n    *   $t_3$：细胞周期过程的正调控\n    *   $t_4$：DNA 复制\n    *   $t_5$：检查点信号传导\n*   **本体论关系（边）：**\n    *   $t_2 \\xrightarrow{\\mathrm{regulates}} t_1$\n    *   $t_3 \\xrightarrow{\\mathrm{is\\_a}} t_2$\n    *   $t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$\n    *   $t_5 \\xrightarrow{\\mathrm{regulates}} t_4$\n*   **直接基因产物注释：**\n    *   $g_1 \\rightarrow t_5$\n    *   $g_2 \\rightarrow t_3$\n    *   $g_3 \\rightarrow t_4$\n    *   $g_4 \\rightarrow t_1$\n*   **传播规则和定义：**\n    *   “真实路径规则”适用于 `is_a` 和 `part_of` 关系，支持从子术语向上层传播至其祖先。\n    *   `regulates` 关系族不表示类包含关系，向上层传播不保证有效。\n*   **假设情景：**\n    *   一个“无防护”的注释引擎被定义为将 `regulates` 关系视为 justifying 向上层传播（即，像 `is_a` 和 `part_of` 一样）。\n*   **任务：**\n    1.  识别在无防护传播模型下，导致基因产物被错误（“膨胀”）注释到术语 $t_1$ 的特定路径。\n    2.  选择一个规则集以防止这种膨胀，并正确预测应用该规则集后注释到 $t_1$ 的唯一基因产物数量。\n\n**步骤2：使用提取的给定信息进行验证**\n\n1.  **科学基础：** 该问题牢固地建立在基因本体论的真实世界结构和使用之上，基因本体论是生物信息学的基石。有向无环图（DAG）、不同的关系类型（`is_a`、`part_of`、`regulates`）、“真实路径规则”以及围绕`regulates`边传播的语义问题等概念都是标准的、科学上合理的。具体的生物学例子是可信的。该问题没有违反任何科学原则。\n2.  **定义明确：** 该问题提供了一个清晰定义的图结构、一套完整的初始注释，以及对正确传播逻辑（“真实路径规则”）和有缺陷的逻辑（“无防护传播”）的明确区分。它要求一个具体的结果：确定正确的规则集及其产生的数量，这是一个在给定输入下可解的问题。\n3.  **客观性：** 语言是精确和技术性的。所有术语要么在问题中被正式定义（`unguarded propagation`），要么是该领域的标准术语（`Gene Ontology`、`true path rule`）。没有主观或基于意见的陈述。\n\n**步骤3：结论与行动**\n\n问题陈述是有效的。它科学合理、定义明确且客观。我将继续进行解答。\n\n### 推导与分析\n\n问题的核心是确定术语 $t_1$ 的正确基因注释集，然后评估选项中提出的哪个规则集能正确地重现这个集合及其基数。\n\n**1. 图结构与注释路径**\n\n让我们表示从基因注释到目标术语 $t_1$ 的连接：\n*   **直接：** $g_4 \\rightarrow t_1$\n*   **$g_3$ 的路径：** $g_3 \\rightarrow t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$\n*   **$g_2$ 的路径：** $g_2 \\rightarrow t_3 \\xrightarrow{\\mathrm{is\\_a}} t_2 \\xrightarrow{\\mathrm{regulates}} t_1$\n*   **$g_1$ 的路径：** $g_1 \\rightarrow t_5 \\xrightarrow{\\mathrm{regulates}} t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$\n\n**2. $t_1$ 的逻辑正确注释（应用真实路径规则）**\n\n“真实路径规则”规定，要使注释从术语 $C$ 传播到祖先术语 $P$，从 $C$ 到 $P$ 的整个路径必须仅由意味着类包含关系的关系组成，即 `is_a` 和 `part_of`。\n\n*   **$g_4$:** 直接注释到 $t_1$。它被包含。\n*   **$g_3$:** 注释到 $t_4$。路径 $t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$ 仅由一个 `part_of` 边组成。这是一条有效的传播路径。因此，$g_3$ 被正确地注释到 $t_1$。\n*   **$g_2$:** 注释到 $t_3$。到 $t_1$ 的路径是 $t_3 \\xrightarrow{\\mathrm{is\\_a}} t_2 \\xrightarrow{\\mathrm{regulates}} t_1$。此路径包含一个 `regulates` 边。根据真实路径规则，沿此边的传播是无效的。因此，$g_2$ 不應被注释到 $t_1$。\n*   **$g_1$:** 注释到 $t_5$。到 $t_1$ 的路径是 $t_5 \\xrightarrow{\\mathrm{regulates}} t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$。此路径包含一个 `regulates` 边，这破坏了真实路径。因此，$g_1$ 不應被注释到 $t_1$。一个参与检查点信号传导（$t_5$）并调控 DNA 复制（$t_4$）的基因产物，是细胞周期一部分的调控者；它本身并非细胞周期过程（$t_1$）的一部分。\n\n$t_1$ 的逻辑正确注释集是 $\\{g_3, g_4\\}$。$t_1$ 的唯一基因产物的正确数量是 $2$。\n\n**3. $t_1$ 的膨胀注释（无防护传播）**\n\n“无防护”引擎沿所有边类型进行传播。\n*   $g_4$ 被包含（直接）。\n*   $g_3$ 通过 $t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$ 被包含。\n*   $g_2$ 通过 $t_3 \\xrightarrow{\\mathrm{is\\_a}} t_2 \\xrightarrow{\\mathrm{regulates}} t_1$ 被包含。\n*   $g_1$ 通过 $t_5 \\xrightarrow{\\mathrm{regulates}} t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$ 被包含。\n\n膨胀后的集合是 $\\{g_1, g_2, g_3, g_4\\}$，数量为 $4$。膨胀的部分是增加了 $\\{g_1, g_2\\}$。\n\n**4. 逐项分析选项**\n\n目标是找到一个能得出正确集合 $\\{g_3, g_4\\}$ 和数量 $2$ 的规则集。\n\n**A. 采用以下规则集：仅沿“is_a”和“part_of”关系进行向上层传播；绝不遍历任何包含“regulates”族系边的路径…… 传播后 $t_1$ 的预测数量：$2$。**\n\n*   **规则集分析：** 此规则集是对真实路径规则的精确陈述。它只允许沿 `is_a` 和 `part_of` 路径传播。\n*   **路径应用：**\n    *   $g_4$：包含（直接）。\n    *   $g_3 \\rightarrow t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$：路径有效。$g_3$ 被包含。\n    *   $g_2 \\rightarrow t_3 \\rightarrow t_2 \\xrightarrow{\\mathrm{regulates}} t_1$：路径包含 `regulates` 边，被阻断。$g_2$ 被排除。\n    *   $g_1 \\rightarrow t_5 \\xrightarrow{\\mathrm{regulates}} t_4 \\rightarrow t_1$：路径包含 `regulates` 边，被阻断。$g_1$ 被排除。\n*   **结果集和数量：** 结果集为 $\\{g_3, g_4\\}$，数量为 $2$。\n*   **预测数量：** 选项预测的数量为 $2$。这与计算出的正确数量相符。\n*   **结论：** 此选项提供了一个能正确防止膨胀并保留有效注释的规则集。其预测数量也是正确的。这是逻辑上合理的方法。**正确。**\n\n**B. 允许沿“is_a”和“part_of”进行向上层传播，并且仅当“regulates”跳跃紧跟着一个“part_of”跳跃时，才允许单个“regulates”跳跃；在所有其他情况下禁止“regulates”。传播后 $t_1$ 的预测数量：$3$。**\n\n*   **规则集分析：** 这是一个自定义的、非标准的规则。\n*   **路径应用：**\n    *   $g_4$：包含（直接）。\n    *   $g_3 \\rightarrow t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$：有效。$g_3$ 被包含。\n    *   $g_2 \\rightarrow t_3 \\rightarrow t_2 \\xrightarrow{\\mathrm{regulates}} t_1$：`regulates` 跳跃后没有跟 `part_of`。它是不被允许的。$g_2$ 被排除。\n    *   $g_1 \\rightarrow t_5 \\xrightarrow{\\mathrm{regulates}} t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$：`regulates` 跳跃紧跟着一个 `part_of` 跳跃。此规则明确允许这种传播。$g_1$ 被包含。\n*   **结果集和数量：** 结果集为 $\\{g_1, g_3, g_4\\}$，数量为 $3$。\n*   **预测数量：** 选项预测的数量 $3$ 与此计算相符。然而，规则集本身是有缺陷的，因为它未能阻止由 $g_1$ 引起的膨胀。它错误地传播了一个违反“part-of”语义的注释。\n*   **结论：** 该规则集不会导致逻辑上正确的结果。**不正确。**\n\n**C. 允许沿所有边类型进行向上层传播，但在传播后，移除那些其直接注释的术语名称包含子字符串“regulation of”的基因产物。传播后 $t_1$ 的预测数量：$3$。**\n\n*   **规则集分析：** 这是一个基于术语名称中字符串匹配的启发式、后处理方法，而非基于图关系的语义逻辑。\n*   **应用：**\n    1.  全部传播，得到膨胀的集合 $\\{g_1, g_2, g_3, g_4\\}$。\n    2.  根据直接注释术语的名称进行过滤：\n        *   $g_1 \\rightarrow t_5$（“checkpoint signaling”）：名称不包含“regulation of”。保留。\n        *   $g_2 \\rightarrow t_3$（“positive regulation of cell cycle process”）：名称包含“regulation of”。移除。\n        *   $g_3 \\rightarrow t_4$（“DNA replication”）：名称不包含“regulation of”。保留。\n        *   $g_4 \\rightarrow t_1$（“cell cycle process”）：名称不包含“regulation of”。保留。\n*   **结果集和数量：** 结果集为 $\\{g_1, g_3, g_4\\}$，数量为 $3$。\n*   **预测数量：** 预测的数量 $3$ 与计算相符。然而，与选项B一样，此规则集是有缺陷的。它未能过滤掉 $g_1$ 的不正确传播。这种基于名称的规则不够稳健。\n*   **结论：** 该规则集没有原则性，并导致了错误的结果。**不正确。**\n\n**D. 禁止跨“negatively_regulates”边进行向上层传播，但允许跨“regulates”和“positively_regulates”边传播... 传播后 $t_1$ 的预测数量：$4$。**\n\n*   **规则集分析：** 此规则在 `regulates` 族系内做了区分，但仍然允许通过通用的 `regulates` 关系进行传播。\n*   **路径应用：**\n    *   $g_4$：包含（直接）。\n    *   $g_3$：包含（有效的 `part_of` 路径）。\n    *   $g_2 \\rightarrow t_3 \\rightarrow t_2 \\xrightarrow{\\mathrm{regulates}} t_1$：此规则允许跨 `regulates` 进行传播。$g_2$ 被包含。\n    *   $g_1 \\rightarrow t_5 \\xrightarrow{\\mathrm{regulates}} t_4 \\rightarrow t_1$：此规则允许跨 `regulates` 进行传播。$g_1$ 被包含。\n*   **结果集和数量：** 结果集为 $\\{g_1, g_2, g_3, g_4\\}$，即完全膨胀的集合。数量为 $4$。\n*   **预测数量：** 预测的数量 $4$ 与计算相符。然而，此规则集未能纠正此特定问题中存在的任何膨胀。\n*   **结论：** 该规则集没有解决所述的防止膨胀的问题。**不正确。**\n\n**结论**\n\n选项 A 是唯一的选择，它既确定了一个逻辑上合理的规则集（真实路径规则）来防止在非包含关系上的注释膨胀，又正确预测了 $t_1$ 的最终注释数量。", "answer": "$$\\boxed{A}$$", "id": "4344264"}, {"introduction": "在生物信息学这个动态发展的领域，确保分析的可重复性对于科学的严谨性至关重要。本练习超越了理论，进入了一个完整富集分析流程的实际操作，模拟了使用包含冻结数据快照的容器化环境。您将学习如何生成一个加密的“可重复性签名”，以验证您的分析结果在不同时间、不同环境下保持一致，这是现代计算科学的基石。", "problem": "您的任务是编写一个完整的、可运行的程序，该程序模拟系统生物医学中使用基因本体（Gene Ontology, GO）进行功能注释的容器化工作流。目标是展示冻结GO和注释快照如何在稍后复现时产生相同的结果，以及快照中的变化如何导致结果的变化。该程序必须实现一个基于第一性原理的确定性功能富集流程，计算结果的可复现性签名，并针对多个基因集查询比较不同快照对之间的签名。\n\n基本基础包括：\n- 基因本体（GO）被定义为一个有向无环图（DAG），其中每个术语是一个节点，边编码了父子关系，使得“真实路径规则”成立：如果一个基因被注释到一个子术语，那么它也隐含地被注释到沿任何路径到达根节点的所有祖先术语。设GO由一组术语$\\mathcal{T}$和一个父节点映射$P : \\mathcal{T} \\to 2^{\\mathcal{T}}$表示，其中$P(t)$返回术语$t$的父术语集合。一个术语$t$的祖先通过$P$的传递闭包递归定义。\n- 使用超几何分布（HD）定义统计富集检验。给定一个大小为$N$的基因全集，一个大小为$n$的查询（前景）集，对于一个GO术语$t$，注释到$t$的全集基因数量为$M$，假设查询集中的$k$个基因被注释到$t$。在无放回随机抽样下，观察到查询集中至少有$k$个注释基因的概率是超几何分布的右尾概率：\n$$\np_t = \\mathbb{P}(X \\ge k) = \\sum_{i=k}^{\\min(M,n)} \\frac{\\binom{M}{i}\\binom{N-M}{n-i}}{\\binom{N}{n}}.\n$$\n这是一个在固定背景和无放回随机抽样假设下，经过充分检验的基因集富集统计公式。\n\n您的程序必须：\n1.  编码GO结构和基因到GO注释的两个快照，代表不同时间点的冻结状态。每个快照必须包括：\n    -   一个由术语的父子关系给出的GO DAG。\n    -   一个基因到术语的直接注释图。\n    -   一个时间戳字符串和版本字符串，用于模拟一个冻结清单。\n2.  通过传播所有直接注释，使其包含GO DAG中所有祖先术语（传递闭包），来实现真实路径规则。\n3.  对于给定的查询基因集，使用上述给出的超几何右尾概率，为所有至少有一个查询基因被注释的GO术语$t$（即$k > 0$）计算富集$p$值$p_t$。\n4.  为一个快照和一个查询的结果构建一个可复现性签名，方法如下：\n    -   按$p$值升序对术语进行排序，然后按术语标识符排序以解决并列问题。\n    -   将每个$p$值四舍五入到固定的小数位数，以确保确定性的字符串格式化。\n    -   将术语标识符及其四舍五入的$p$值连接成一个单一的规范化字符串，并使用密码学哈希函数（例如SHA-256）对其进行哈希处理。\n    -   该签名仅取决于结果，而不取决于时间戳或环境字符串。\n5.  比较两个快照对于同一查询的签名，生成一个布尔值，指示结果是否相同（如果签名匹配则为$\\text{True}$，否则为$\\text{False}$）。\n\n要嵌入程序中的数据：\n- 时间点$t_1$的快照$\\mathsf{A}$和时间点$t_2$的重复快照$\\mathsf{A}$，内容完全相同：\n  -   术语：$A$（根节点），$B$和$C$是$A$的子节点，$D$和$E$是$B$的子节点，$F$是$C$的子节点。\n    -   形式上，父节点映射为：\n        $P(B) = \\{A\\}$, $P(C) = \\{A\\}$, $P(D) = \\{B\\}$, $P(E) = \\{B\\}$, $P(F) = \\{C\\}$，以及$P(A) = \\emptyset$。\n  -   基因：$\\{g_1,g_2,g_3,g_4,g_5,g_6,g_7,g_8,g_9,g_{10}\\}$。\n  -   直接注释：\n    $g_1 \\mapsto D$, $g_2 \\mapsto E$, $g_3 \\mapsto B$, $g_4 \\mapsto C$, $g_5 \\mapsto F$, $g_6 \\mapsto C$, $g_7 \\mapsto D$, $g_8 \\mapsto E$, $g_9 \\mapsto F$, $g_{10} \\mapsto A$。\n  -   两个快照的时间戳字符串不同，但内容完全相同。\n- 时间点$t_3$的内容已修改的快照$\\mathsf{B}$：\n  -   添加一个术语$G$作为$C$的子节点，即$P(G)=\\{C\\}$。\n  -   将$g_6$的直接注释从$C$移动到$G$。\n  -   将$g_5$的直接注释从$F$移动到$G$。\n  -   所有其他注释和父子关系与快照$\\mathsf{A}$中相同。\n\n您的程序必须定义以下查询基因集：\n- 查询$\\mathsf{Q_1} = \\{g_1,g_2,g_5,g_7,g_9\\}$。\n- 查询$\\mathsf{Q_2} = \\emptyset$（边界情况）。\n- 查询$\\mathsf{Q_3} = \\{g_6\\}$。\n\n超几何参数必须根据每个术语和快照从第一性原理推导得出：\n-   全集大小$N$等于快照中唯一基因的数量（即$N=10$）。\n-   查询大小$n$等于测试中查询集中的基因数量（对于$\\mathsf{Q_1}$，$n=5$；对于$\\mathsf{Q_2}$，$n=0$；对于$\\mathsf{Q_3}$，$n=1$）。\n-   对于每个术语$t$，应用真实路径规则后，将$M$计算为注释到$t$的全集基因数量，将$k$计算为注释到$t$的查询基因数量。\n\n测试套件和要求的输出：\n- 定义以下六个测试用例，每个用例通过比较指定查询在两个快照之间的可复现性签名来生成单个布尔值：\n  1.  比较快照$\\mathsf{A}(t_1)$与快照$\\mathsf{A}(t_2)$对于查询$\\mathsf{Q_1}$的结果。\n  2.  比较快照$\\mathsf{A}(t_1)$与快照$\\mathsf{B}(t_3)$对于查询$\\mathsf{Q_1}$的结果。\n  3.  比较快照$\\mathsf{A}(t_1)$与快照$\\mathsf{A}(t_2)$对于查询$\\mathsf{Q_2}$的结果。\n  4.  比较快照$\\mathsf{A}(t_1)$与快照$\\mathsf{B}(t_3)$对于查询$\\mathsf{Q_2}$的结果。\n  5.  比较快照$\\mathsf{A}(t_1)$与快照$\\mathsf{A}(t_2)$对于查询$\\mathsf{Q_3}$的结果。\n  6.  比较快照$\\mathsf{A}(t_1)$与快照$\\mathsf{B}(t_3)$对于查询$\\mathsf{Q_3}$的结果。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\ldots]$），其中每个$\\text{result}_i$是如上所述计算的布尔值。不涉及任何物理单位或角度。所有$p$值和算术运算必须以小数（浮点数）形式计算，不带任何百分号。输出必须在不同运行中可复现，并且不得依赖于用户输入、外部文件或网络访问。", "solution": "该问题要求实现一个用于基因本体（GO）功能富集分析的确定性生物信息学工作流，以论证计算可复现性的原理。核心任务是创建两个不同的GO数据“快照”，用几个基因查询对它们运行分析流程，并证明相同的快照产生相同的结果，而修改过的快照产生不同的结果。这是通过从分析输出生成一个密码学哈希，即“可复现性签名”来实现的。\n\n该解决方案围绕几个关键原则构建：数据建模、用于逻辑推断的图遍历、统计检验以及为哈希处理而进行的结果规范化。\n\n首先，根据问题规范对每个快照的数据进行建模。一个快照包含一个基因本体结构、一组基因到术语的注释以及一个所有基因的全集。GO被表示为一个有向无环图（DAG），具体使用父节点映射，其中每个术语（一个节点）映射到其一组父节点。例如，关系“术语D是术语B的子节点”被编码为术语$D$映射到包含$B$的集合。基因注释表示为从每个基因标识符到其直接关联的GO术语集的映射。\n\n其次，实现“真实路径规则”。这是基因本体中的一个基本概念，即对一个术语的注释意味着也注释到其所有祖先，直至根节点。为了实现这一点，一种算法首先为GO DAG中的每个术语计算父节点关系的传递闭包。这可以通过从每个术语开始，向上导航至其父节点，收集所有唯一的祖先，使用重复的图遍历（如广度优先或深度优先搜索）来高效地为所有术语完成。一旦知道了每个术语的完整祖先集，就传播直接注释。对于每个基因，其完整的注释集成为其直接注释术语及其各自所有祖先的并集。此过程最终生成一个从每个GO术语到所有注释到它的基因（无论是直接还是隐含）的完整映射。\n\n第三，使用超几何检验进行统计分析。对于每个GO术语$t$和给定的查询基因集，我们计算一个$p$值，$p_t$，它表示观察到查询集与该术语之间关联数量等于或大于随机机会预期的概率。检验的参数推导如下：\n- 全集大小$N$是快照中唯一基因的总数。\n- 查询大小$n$是输入查询集中的基因数量。\n- 对于给定的术语$t$，总体成功数$M$是从全集$N$中注释到术语$t$的基因总数（在真实路径传播之后）。\n- 样本成功数$k$是从查询集$n$中也注释到术语$t$的基因数量。\n富集$p$值是超几何分布的右尾概率，即$\\mathbb{P}(X \\ge k)$，它为每个至少有一个查询基因被注释的术语（$k > 0$）计算。这确保我们只检验与查询相关的术语。\n\n第四，从富集结果生成可复现性签名。这是为整个分析运行的输出创建一个单一、可比较的标识符的关键步骤。过程如下：\n1. 对结果对$(t, p_t)$的列表进行排序。主排序键是$p$值升序。次排序键用于确定性地解决$p$值并列的情况，即按字典序（字母顺序）排列的术语标识符。\n2. 每个$p$值被四舍五入到固定的小数位数。此步骤至关重要，可防止不同机器架构上的微小浮点差异影响最终签名。\n3. 排序和四舍五入后的结果被连接成一个单一的规范化字符串。对于每个结果，术语标识符及其四舍五入的$p$值被无分隔符地追加在一起。\n4. 然后使用SHA-256算法对此规范化字符串进行哈希处理。生成的十六进制摘要作为给定快照和查询的唯一且确定性的可复现性签名。空查询导致空结果集，这确定性地哈希为一个空字符串的签名。\n\n最后，程序执行指定的测试套件。对于每个测试用例，它运行流程并为两个快照-查询组合生成签名。比较两个生成的签名。如果它们相同，则认为分析是可复现的，比较结果为$\\text{True}$；否则，结果为$\\text{False}$。这直接检验了问题的核心假设：相同的输入（冻结的快照$\\mathsf{A}(t_1)$和$\\mathsf{A}(t_2)$）产生相同的结果，而不同的输入（快照$\\mathsf{A}$与快照$\\mathsf{B}$）导致不同的结果，从而验证了容器化工作流模拟的完整性。该逻辑正确处理了空查询集的边界情况，对于这种情况，结果为空，因此无论快照数据如何，签名都相同。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import hypergeom\nimport hashlib\nfrom collections import defaultdict\n\ndef get_reproducibility_signature(snapshot_data, query_set):\n    \"\"\"\n    Computes a deterministic reproducibility signature for a given GO snapshot and gene query.\n\n    The pipeline involves propagating annotations, running a hypergeometric test for enrichment,\n    and hashing a canonical representation of the results.\n    \"\"\"\n    # 1. Unpack snapshot data\n    parent_map = snapshot_data['parents']\n    direct_annotations = snapshot_data['annotations']\n    all_genes = snapshot_data['genes']\n\n    # 2. Pre-compute ancestors for all terms (transitive closure)\n    all_terms = set(parent_map.keys())\n    for term_list in parent_map.values():\n        all_terms.update(term_list)\n    \n    term_ancestors = {}\n    for term in all_terms:\n        # Non-recursive DFS/BFS for ancestor traversal\n        queue = list(parent_map.get(term, set()))\n        visited = set(queue)\n        ancestors = set(queue)\n        head = 0\n        while head  len(queue):\n            current_term = queue[head]\n            head += 1\n            parents = parent_map.get(current_term, set())\n            for p in parents:\n                if p not in visited:\n                    visited.add(p)\n                    ancestors.add(p)\n                    queue.append(p)\n        term_ancestors[term] = ancestors\n\n    # 3. Propagate annotations (true path rule) to get term -> {genes} map\n    term_to_all_genes = defaultdict(set)\n    for gene, terms in direct_annotations.items():\n        for term in terms:\n            # Add gene to its direct term\n            term_to_all_genes[term].add(gene)\n            # Add gene to all ancestors of the direct term\n            for ancestor in term_ancestors.get(term, set()):\n                term_to_all_genes[ancestor].add(gene)\n\n    # 4. Compute enrichment p-values\n    N = len(all_genes)\n    n = len(query_set)\n    \n    enrichment_results = []\n    if n > 0:\n        for term in all_terms:\n            genes_in_term = term_to_all_genes[term]\n            M = len(genes_in_term)\n            k = len(genes_in_term.intersection(query_set))\n            \n            if k > 0:\n                # Scipy's hypergeometric survival function P(X >= k) is sf(k-1, ...)\n                pval = hypergeom.sf(k - 1, N, M, n)\n                enrichment_results.append((term, pval))\n\n    # 5. Construct reproducibility signature\n    # Sort by p-value (asc), then term ID (asc) to break ties\n    enrichment_results.sort(key=lambda x: (x[1], x[0]))\n    \n    # Round p-values to a fixed precision for deterministic string formatting\n    precision = 12\n    canonical_string = \"\".join(f\"{term}{pval:.{precision}f}\" for term, pval in enrichment_results)\n    \n    # Hash the canonical string using SHA-256\n    hasher = hashlib.sha256()\n    hasher.update(canonical_string.encode('utf-8'))\n    return hasher.hexdigest()\n\ndef solve():\n    # Define the universe of genes\n    UNIVERSE_GENES = {f'g_{i}' for i in range(1, 11)}\n\n    # Snapshot A Data\n    SNAPSHOT_A_DATA = {\n        'timestamp': \"2023-01-15T10:00:00Z\",\n        'version': \"GO:2023-01-15, Annotations:v1.0\",\n        'genes': UNIVERSE_GENES,\n        'parents': {\n            'B': {'A'}, 'C': {'A'}, 'D': {'B'}, 'E': {'B'}, 'F': {'C'}\n        },\n        'annotations': {\n            'g_1': {'D'}, 'g_2': {'E'}, 'g_3': {'B'}, 'g_4': {'C'}, 'g_5': {'F'},\n            'g_6': {'C'}, 'g_7': {'D'}, 'g_8': {'E'}, 'g_9': {'F'}, 'g_10': {'A'}\n        }\n    }\n    \n    # Repeated Snapshot A' to simulate a later, identical run\n    SNAPSHOT_A_PRIME_DATA = {\n        'timestamp': \"2023-10-20T14:30:00Z\",\n        'version': \"GO:2023-01-15, Annotations:v1.0\",\n        'genes': UNIVERSE_GENES,\n        'parents': SNAPSHOT_A_DATA['parents'],\n        'annotations': SNAPSHOT_A_DATA['annotations']\n    }\n\n    # Snapshot B Data (modified)\n    SNAPSHOT_B_DATA = {\n        'timestamp': \"2024-03-01T11:00:00Z\",\n        'version': \"GO:2024-03-01, Annotations:v1.1\",\n        'genes': UNIVERSE_GENES,\n        'parents': {\n            'B': {'A'}, 'C': {'A'}, 'D': {'B'}, 'E': {'B'}, 'F': {'C'}, 'G': {'C'} # Added term G\n        },\n        'annotations': {\n            'g_1': {'D'}, 'g_2': {'E'}, 'g_3': {'B'}, 'g_4': {'C'}, 'g_5': {'G'},  # Moved from F to G\n            'g_6': {'G'}, 'g_7': {'D'}, 'g_8': {'E'}, 'g_9': {'F'}, 'g_10': {'A'}  # Moved from C to G\n        }\n    }\n\n    # Define Query Gene Sets\n    QUERY_Q1 = {'g_1', 'g_2', 'g_5', 'g_7', 'g_9'}\n    QUERY_Q2 = set()\n    QUERY_Q3 = {'g_6'}\n\n    # Define the test suite\n    test_cases = [\n        # Snap A vs. Snap A'\n        (SNAPSHOT_A_DATA, QUERY_Q1, SNAPSHOT_A_PRIME_DATA),  # 1. Test Q1, expect True\n        (SNAPSHOT_A_DATA, QUERY_Q1, SNAPSHOT_B_DATA),          # 2. Test Q1, expect False\n        (SNAPSHOT_A_DATA, QUERY_Q2, SNAPSHOT_A_PRIME_DATA),  # 3. Test Q2, expect True\n        (SNAPSHOT_A_DATA, QUERY_Q2, SNAPSHOT_B_DATA),          # 4. Test Q2, expect True (empty query)\n        (SNAPSHOT_A_DATA, QUERY_Q3, SNAPSHOT_A_PRIME_DATA),  # 5. Test Q3, expect True\n        (SNAPSHOT_A_DATA, QUERY_Q3, SNAPSHOT_B_DATA),          # 6. Test Q3, expect False\n    ]\n\n    results = []\n    for snap1_data, query, snap2_data in test_cases:\n        sig1 = get_reproducibility_signature(snap1_data, query)\n        sig2 = get_reproducibility_signature(snap2_data, query)\n        results.append(sig1 == sig2)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4344249"}]}