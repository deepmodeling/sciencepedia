{"hands_on_practices": [{"introduction": "在高通量测序（RNA-seq）实验中，原始读数（raw counts）会受到基因长度和测序深度的影响，直接比较它们会产生误导性的结论。为了获得准确的基因表达量，我们必须进行标准化处理。本练习将通过计算两种最常用的标准化指标——每千碱基每百万读数（Reads Per Kilobase per Million mapped reads, RPKM）和每百万转录本（Transcripts Per Million, TPM），让你亲身体验标准化如何校正这些系统性偏差，并理解为何不同的方法可能导致对基因表达水平排序的不同解读。[@problem_id:4351520]", "problem": "一项系统生物医学领域的队列研究使用高通量测序技术，从两个生物样本中生成了信使核糖核酸（mRNA）表达谱。为进行基因表达的下游分析，其核心处理流程执行质量控制、与参考基因组的比对以及对已比对读数的定量。考虑四个蛋白质编码基因，分别记为 $G_1$、$G_2$、$G_3$ 和 $G_4$，其基因组长度分别为 $L_{1} = 2000$ 碱基对、$L_{2} = 10000$ 碱基对、$L_{3} = 500$ 碱基对和 $L_{4} = 3000$ 碱基对。样本 $1$ 进行单端测序，总共有 $N_1 = 3.0 \\times 10^{7}$ 个已比对的读数，并产生原始的基因水平读数计数 $c_{1}^{(1)} = 600$、$c_{2}^{(1)} = 900$、$c_{3}^{(1)} = 450$ 和 $c_{4}^{(1)} = 300$。样本 $2$ 进行双端测序，总共有 $N_2 = 1.5 \\times 10^{7}$ 个已比对的片段，并产生原始的基因水平片段计数 $c_{1}^{(2)} = 800$、$c_{2}^{(2)} = 300$、$c_{3}^{(2)} = 400$ 和 $c_{4}^{(2)} = 500$。\n\n从转录本定量中长度归一化和文库大小缩放的基本定义出发，执行以下操作：\n\n- 计算样本 $1$ 中每个基因的每千碱基每百万比对读数（RPKM）和每百万转录本（TPM）。\n- 计算样本 $2$ 中每个基因的每千碱基每百万比对片段（FPKM）和每百万转录本（TPM）。\n- 对每个样本分别确定，按原始计数对基因进行的样本内排序是否与按 TPM 进行的排序不同，并使用第一性原理推断简要论证结果。\n\n最后，将同一项目集上两个全序之间的 Kendall tau 距离定义为这两个排序之间的逆序对数量。使用此定义，计算样本 $1$ 的原始计数排序与 TPM 排序之间的 Kendall tau 距离。仅报告此 Kendall tau 距离作为您的最终数值答案。无需四舍五入，最终答案不应提供单位。", "solution": "该问题被评估为有效，因为它在科学上基于转录组学数据分析的标准原则，定义明确且提供了所有必要信息，并且其表述客观。\n\n这个问题的核心涉及应用 RNA 测序（RNA-seq）数据分析中使用的标准归一化技术来比较基因表达水平。两个主要的归一化指标是每千碱基每百万读数/片段（RPKM/FPKM）和每百万转录本（TPM）。\n\n对于基因 $i$ 的基本定义如下：\n设 $c_i$ 为比对到基因 $i$ 的读数（对于单端测序）或片段（对于双端测序）的原始计数。\n设 $L_i$ 为对应于基因 $i$ 的转录本长度，单位为碱基对（bp）。我们通过 $L_i^{\\text{kb}} = L_i / 1000$ 将其转换为千碱基（kb）。\n设 $N$ 为测序文库中已比对的读数或片段的总数。我们通过 $N^{\\text{millions}} = N / 10^6$ 将其转换为百万单位。\n\nRPKM（对于单端测序）或 FPKM（对于双端测序）定义为：\n$$ \\text{RPKM}_i \\text{ or } \\text{FPKM}_i = \\frac{c_i}{L_i^{\\text{kb}} \\cdot N^{\\text{millions}}} = \\frac{10^9 \\cdot c_i}{L_i \\cdot N} $$\n该公式首先按总文库大小（测序深度）对原始计数进行归一化，然后再按基因长度进行归一化。\n\nTPM 的定义采用了不同的操作顺序。首先，对原始计数按基因长度进行归一化，以获得转录本丰度率的度量。然后，将这些比率通过所有比率的总和进行归一化，以消除文库大小的影响。\n1.  比率计算（每千碱基读数）：$R_i = \\frac{c_i}{L_i^{\\text{kb}}} = \\frac{1000 \\cdot c_i}{L_i}$\n2.  所有比率的总和：$T = \\sum_j R_j$\n3.  TPM 计算：$\\text{TPM}_i = \\left(\\frac{R_i}{T}\\right) \\cdot 10^6$\n\n有了这些定义，我们可以对每个样本进行计算。\n\n**样本 1 分析**\n样本 $1$ 的给定数据：\n- 已比对读数总数：$N_1 = 3.0 \\times 10^7$，所以 $N_1^{\\text{millions}} = 30$。\n- 基因长度：$L_1 = 2000$ bp ($2$ kb)，$L_2 = 10000$ bp ($10$ kb)，$L_3 = 500$ bp ($0.5$ kb)，$L_4 = 3000$ bp ($3$ kb)。\n- 原始计数：$c_{1}^{(1)} = 600$, $c_{2}^{(1)} = 900$, $c_{3}^{(1)} = 450$, $c_{4}^{(1)} = 300$。\n\n**样本 1 的 RPKM 计算：**\n- $G_1$: $\\text{RPKM}_1^{(1)} = \\frac{600}{2 \\cdot 30} = 10$\n- $G_2$: $\\text{RPKM}_2^{(1)} = \\frac{900}{10 \\cdot 30} = 3$\n- $G_3$: $\\text{RPKM}_3^{(1)} = \\frac{450}{0.5 \\cdot 30} = \\frac{450}{15} = 30$\n- $G_4$: $\\text{RPKM}_4^{(1)} = \\frac{300}{3 \\cdot 30} = \\frac{300}{90} = \\frac{10}{3}$\n\n**样本 1 的 TPM 计算：**\n首先，我们计算比率 $R_i^{(1)} = c_i^{(1)}/L_i^{\\text{kb}}$：\n- $R_1^{(1)} = \\frac{600}{2} = 300$\n- $R_2^{(1)} = \\frac{900}{10} = 90$\n- $R_3^{(1)} = \\frac{450}{0.5} = 900$\n- $R_4^{(1)} = \\frac{300}{3} = 100$\n比率总和为 $T^{(1)} = 300 + 90 + 900 + 100 = 1390$。\n现在，我们计算 TPM 值：\n- $G_1$: $\\text{TPM}_1^{(1)} = \\left(\\frac{300}{1390}\\right) \\cdot 10^6 \\approx 215827$\n- $G_2$: $\\text{TPM}_2^{(1)} = \\left(\\frac{90}{1390}\\right) \\cdot 10^6 \\approx 64748$\n- $G_3$: $\\text{TPM}_3^{(1)} = \\left(\\frac{900}{1390}\\right) \\cdot 10^6 \\approx 647482$\n- $G_4$: $\\text{TPM}_4^{(1)} = \\left(\\frac{100}{1390}\\right) \\cdot 10^6 \\approx 71942$\n\n**样本 2 分析**\n样本 $2$ 的给定数据：\n- 已比对片段总数：$N_2 = 1.5 \\times 10^7$，所以 $N_2^{\\text{millions}} = 15$。\n- 基因长度与样本 1 相同。\n- 原始计数：$c_{1}^{(2)} = 800$, $c_{2}^{(2)} = 300$, $c_{3}^{(2)} = 400$, $c_{4}^{(2)} = 500$。\n\n**样本 2 的 FPKM 计算：**\n- $G_1$: $\\text{FPKM}_1^{(2)} = \\frac{800}{2 \\cdot 15} = \\frac{800}{30} = \\frac{80}{3}$\n- $G_2$: $\\text{FPKM}_2^{(2)} = \\frac{300}{10 \\cdot 15} = \\frac{300}{150} = 2$\n- $G_3$: $\\text{FPKM}_3^{(2)} = \\frac{400}{0.5 \\cdot 15} = \\frac{400}{7.5} = \\frac{160}{3}$\n- $G_4$: $\\text{FPKM}_4^{(2)} = \\frac{500}{3 \\cdot 15} = \\frac{500}{45} = \\frac{100}{9}$\n\n**样本 2 的 TPM 计算：**\n首先，我们计算比率 $R_i^{(2)} = c_i^{(2)}/L_i^{\\text{kb}}$：\n- $R_1^{(2)} = \\frac{800}{2} = 400$\n- $R_2^{(2)} = \\frac{300}{10} = 30$\n- $R_3^{(2)} = \\frac{400}{0.5} = 800$\n- $R_4^{(2)} = \\frac{500}{3}$\n比率总和为 $T^{(2)} = 400 + 30 + 800 + \\frac{500}{3} = 1230 + \\frac{500}{3} = \\frac{3690 + 500}{3} = \\frac{4190}{3}$。\n现在，我们计算 TPM 值：\n- $G_1$: $\\text{TPM}_1^{(2)} = \\left(\\frac{400}{4190/3}\\right) \\cdot 10^6 = \\frac{1200}{4190} \\cdot 10^6 \\approx 286396$\n- $G_2$: $\\text{TPM}_2^{(2)} = \\left(\\frac{30}{4190/3}\\right) \\cdot 10^6 = \\frac{90}{4190} \\cdot 10^6 \\approx 21480$\n- $G_3$: $\\text{TPM}_3^{(2)} = \\left(\\frac{800}{4190/3}\\right) \\cdot 10^6 = \\frac{2400}{4190} \\cdot 10^6 \\approx 572792$\n- $G_4$: $\\text{TPM}_4^{(2)} = \\left(\\frac{500/3}{4190/3}\\right) \\cdot 10^6 = \\frac{500}{4190} \\cdot 10^6 \\approx 119332$\n\n**排序比较**\n\n对于样本 1：\n- 原始计数排序：$c_2^{(1)}(900) > c_1^{(1)}(600) > c_3^{(1)}(450) > c_4^{(1)}(300) \\implies G_2 > G_1 > G_3 > G_4$。\n- TPM 排序（与比率 $R_i^{(1)}$ 成正比）：$R_3^{(1)}(900) > R_1^{(1)}(300) > R_4^{(1)}(100) > R_2^{(1)}(90) \\implies G_3 > G_1 > G_4 > G_2$。\n按原始计数的样本内排序与按 TPM 的排序不同。\n\n对于样本 2：\n- 原始计数排序：$c_1^{(2)}(800) > c_4^{(2)}(500) > c_3^{(2)}(400) > c_2^{(2)}(300) \\implies G_1 > G_4 > G_3 > G_2$。\n- TPM 排序（与比率 $R_i^{(2)}$ 成正比）：$R_3^{(2)}(800) > R_1^{(2)}(400) > R_4^{(2)}(500/3) > R_2^{(2)}(30) \\implies G_3 > G_1 > G_4 > G_2$。\n按原始计数的样本内排序也与按 TPM 的排序不同。\n\n**基于第一性原理的论证：**\n从机制上讲，一个基因的原始读数计数是其真实转录本丰度（摩尔浓度）与其长度的乘积。即使表达水平相同，较长的基因也为随机片段化和测序提供了更大的目标，因此会比短基因累积更多的读数。这种长度偏差混淆了将原始计数作为表达直接度量的解释。\nTPM 计算纠正了这一点。第一步，$R_i = c_i / L_i^{\\text{kb}}$，明确地除去了基因长度的影响，得到一个与实际转录本丰度成正比的比率。随后的按总比率缩放对文库大小进行了归一化。由于这个最终的缩放因子对样本内的所有基因都是相同的，因此它不会改变由初始长度归一化步骤建立的样本内排序。因此，原始计数排序与 TPM 排序之间的差异根本上是由于对基因长度偏差的校正。例如，在样本 1 中，基因 $G_2$ 最长（$10000$ bp），原始计数最高，但在长度归一化后，其相对表达量最低。相反，基因 $G_3$ 最短（$500$ bp），其不高的原始计数在长度归一化后转化为最高的相对表达量。\n\n**样本 1 的 Kendall Tau 距离**\n两个排序之间的 Kendall tau 距离是在两个排序中相对顺序不同的项目对的数量。项目集是 {$G_1, G_2, G_3, G_4$}。\n- 排序 1（来自原始计数）：$\\pi_1 = (G_2, G_1, G_3, G_4)$\n- 排序 2（来自 TPM）：$\\pi_2 = (G_3, G_1, G_4, G_2)$\n\n我们检查所有 $\\binom{4}{2} = 6$ 对基因：\n1.  对 $(G_1, G_2)$：在 $\\pi_1$ 中，$G_2 > G_1$。在 $\\pi_2$ 中，$G_1 > G_2$。不一致。\n2.  对 $(G_1, G_3)$：在 $\\pi_1$ 中，$G_1 > G_3$。在 $\\pi_2$ 中，$G_3 > G_1$。不一致。\n3.  对 $(G_1, G_4)$：在 $\\pi_1$ 中，$G_1 > G_4$。在 $\\pi_2$ 中，$G_1 > G_4$。一致。\n4.  对 $(G_2, G_3)$：在 $\\pi_1$ 中，$G_2 > G_3$。在 $\\pi_2$ 中，$G_3 > G_2$。不一致。\n5.  对 $(G_2, G_4)$：在 $\\pi_1$ 中，$G_2 > G_4$。在 $\\pi_2$ 中，$G_4 > G_2$。不一致。\n6.  对 $(G_3, G_4)$：在 $\\pi_1$ 中，$G_3 > G_4$。在 $\\pi_2$ 中，$G_3 > G_4$。一致。\n\n共有 $4$ 对不一致的配对。因此，样本 $1$ 的原始计数排序与 TPM 排序之间的 Kendall tau 距离为 $4$。", "answer": "$$\\boxed{4}$$", "id": "4351520"}, {"introduction": "与基因水平的定量相比，转录本水平的定量更为复杂，因为可变剪接产生的测序读数可能同时兼容来自同一个基因的多个转录本。在尝试用算法拆分这些模糊信号之前，我们需要回答一个更根本的问题：从数学角度看，唯一的解是否存在？本练习将引导你运用线性代数工具分析一个等价类关联矩阵（equivalence class incidence matrix）$A$，并根据其性质来判断在给定的线性模型 $\\mathbf{y} = A \\mathbf{x}$ 下，转录本丰度向量 $\\mathbf{x}$ 是否是唯一可识别的（identifiable）。[@problem_id:4351378]", "problem": "在一个针对具有可变剪接的单个基因的链特异性RNA测序（RNA-seq）实验中，高通量测序读数经过了接头修剪、碱基质量过滤和低复杂度读数移除等处理。伪比对将每个读数分配到一个等价类，该等价类定义为与该读数兼容的异构体集合。经过偏差校正后，在无噪声极限下，跨等价类的期望片段计数向量 $\\mathbf{y} \\in \\mathbb{R}^{m}_{\\ge 0}$ 可由线性系统 $\\mathbf{y} = A \\mathbf{x}$ 建模，其中 $A \\in \\{0,1\\}^{m \\times n}$ 是等价类关联矩阵，$\\mathbf{x} \\in \\mathbb{R}^{n}_{\\ge 0}$ 是异构体特异性有效片段计数的向量。文库大小施加了归一化约束 $\\sum_{i=1}^{n} x_{i} = N$，其中 $N \\in \\mathbb{R}_{>0}$ 是已知的。\n\n考虑一个基因，其有 $n = 4$ 个异构体 $(T_{1}, T_{2}, T_{3}, T_{4})$ 和 $m = 5$ 个等价类 $(E_{1},\\dots,E_{5})$。等价类关联矩阵 $A$（行由 $E_{j}$ 索引，列由 $T_{i}$ 索引）为\n$$\nA \\;=\\;\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  1  0  1 \\\\\n1  1  1  1 \\\\\n1  0  0  1 \\\\\n0  1  0  1\n\\end{pmatrix}.\n$$\n\n从等价类和在模型 $\\mathbf{y}=A\\mathbf{x}$ 及归一化约束 $\\sum_{i=1}^{n} x_{i} = N$ 下的线性可辨识性的核心定义出发，完成以下任务：\n\n1. 计算 $A$ 在 $\\mathbb{R}$ 上的秩。\n2. 判断异构体丰度（即向量 $\\mathbf{x}$）是否是可辨识的，即可辨识性意味着在约束 $\\sum_{i=1}^{n} x_{i} = N$ 下，从 $\\mathbf{x}$ 到 $\\mathbf{y}$ 的映射是一对一的。如果可辨识，则可辨识性结论为 $1$，如果不可辨识，则为 $0$。\n\n将你的最终答案表示为一个包含两个条目的行矩阵 $\\begin{pmatrix} r  I \\end{pmatrix}$，其中 $r$ 是 $A$ 的秩，$I \\in \\{0,1\\}$ 是可辨识性指标。无需四舍五入，最终答案框内不报告单位。", "solution": "该问题被评估为有效，因为它科学地基于RNA-seq数据转录本定量的原理，提法明确且提供了所有必要信息，并使用客观、形式化的语言进行表述。我们开始解答。\n\n该问题要求对带有约束 $\\sum_{i=1}^{n} x_{i} = N$ 的线性系统 $\\mathbf{y} = A \\mathbf{x}$ 进行两部分分析。给定参数为异构体数量 $n=4$，等价类数量 $m=5$，以及等价类关联矩阵 $A$：\n$$\nA \\;=\\;\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  1  0  1 \\\\\n1  1  1  1 \\\\\n1  0  0  1 \\\\\n0  1  0  1\n\\end{pmatrix}\n$$\n异构体计数向量为 $\\mathbf{x} = \\begin{pmatrix} x_1  x_2  x_3  x_4 \\end{pmatrix}^T$。\n\n**第一部分：计算 $A$ 的秩**\n\n矩阵的秩是其列空间或等价地其行空间的维数。它是线性无关的列或行的最大数量。我们可以通过将矩阵简化为其行阶梯形来确定秩。\n\n首先，我们观察到第1行与第4行相同，第2行与第5行相同。因此，$A$ 的秩等于由 $A$ 的唯一行组成的矩阵 $A'$ 的秩：\n$$\nA' \\;=\\;\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  1  0  1 \\\\\n1  1  1  1\n\\end{pmatrix}\n$$\n我们对 $A'$ 应用高斯消元法来求其秩。令 $R_1$、$R_2$ 和 $R_3$ 表示 $A'$ 的行。\n我们执行行变换 $R_3 \\leftarrow R_3 - R_1$：\n$$\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  1  0  1 \\\\\n(1-1)  (1-0)  (1-0)  (1-1)\n\\end{pmatrix}\n\\;=\\;\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  1  0  1 \\\\\n0  1  1  0\n\\end{pmatrix}\n$$\n接下来，我们执行行变换 $R_3 \\leftarrow R_3 - R_2$：\n$$\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  1  0  1 \\\\\n(0-0)  (1-1)  (1-0)  (0-1)\n\\end{pmatrix}\n\\;=\\;\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  1  0  1 \\\\\n0  0  1  -1\n\\end{pmatrix}\n$$\n该矩阵是行阶梯形。非零行的数量为 $3$。因此，$A'$ 的秩为 $3$。由于 $A$ 的秩等于 $A'$ 的秩，我们有 $\\text{rank}(A) = 3$。所以，$r=3$。\n\n**第二部分：判断 $\\mathbf{x}$ 的可辨识性**\n\n异构体丰度向量 $\\mathbf{x}$ 是可辨识的，如果从 $\\mathbf{x}$ 到 $\\mathbf{y}$ 的映射在 $\\mathbf{x}$ 的约束下是一对一的。约束条件是 $\\mathbf{x} \\in \\mathbb{R}^{n}_{\\ge 0}$ 和 $\\sum_{i=1}^{n} x_i = N$。\n一对一条件意味着，如果我们有两个解 $\\mathbf{x}_1$ 和 $\\mathbf{x}_2$ 满足：\n1. $A\\mathbf{x}_1 = A\\mathbf{x}_2$\n2. $\\sum_{i=1}^{n} x_{1,i} = N$ 且 $\\sum_{i=1}^{n} x_{2,i} = N$\n3. $\\mathbf{x}_1, \\mathbf{x}_2 \\in \\mathbb{R}^{n}_{\\ge 0}$\n那么必须得出 $\\mathbf{x}_1 = \\mathbf{x}_2$。\n\n我们定义一个差分向量 $\\mathbf{z} = \\mathbf{x}_1 - \\mathbf{x}_2$。从条件1，我们有 $A(\\mathbf{x}_1 - \\mathbf{x}_2) = \\mathbf{0}$，这意味着 $A\\mathbf{z} = \\mathbf{0}$。这表明 $\\mathbf{z}$ 必须在 $A$ 的零空间中，记为 $\\text{ker}(A)$。\n从条件2，我们有 $\\sum_{i=1}^{n} x_{1,i} - \\sum_{i=1}^{n} x_{2,i} = N - N = 0$，这意味着 $\\sum_{i=1}^{n} z_i = 0$。这可以写成 $\\mathbf{1}^T \\mathbf{z} = 0$，其中 $\\mathbf{1}$ 是一个维数适当的全1列向量。\n\n如果唯一满足 $A\\mathbf{z} = \\mathbf{0}$ 和 $\\mathbf{1}^T \\mathbf{z} = 0$ 的向量 $\\mathbf{z}$ 是零向量 $\\mathbf{z} = \\mathbf{0}$，则系统是可辨识的。\n\n我们首先刻画 $A$ 的零空间。根据秩-零度定理，零空间的维数由 $\\text{dim}(\\text{ker}(A)) = n - \\text{rank}(A)$ 给出。\n对于 $n=4$ 和 $\\text{rank}(A)=3$，我们有 $\\text{dim}(\\text{ker}(A)) = 4 - 3 = 1$。零空间是一维的，这意味着存在非零解满足 $A\\mathbf{z} = \\mathbf{0}$。\n\n为了找到 $\\text{ker}(A)$ 的一个基，我们使用我们为 $A'$ 推导出的行阶梯形来解 $A\\mathbf{z} = \\mathbf{0}$：\n$$\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  1  0  1 \\\\\n0  0  1  -1\n\\end{pmatrix}\n\\begin{pmatrix} z_1 \\\\ z_2 \\\\ z_3 \\\\ z_4 \\end{pmatrix}\n=\n\\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n这给出了方程组：\n$z_1 + z_4 = 0 \\implies z_1 = -z_4$\n$z_2 + z_4 = 0 \\implies z_2 = -z_4$\n$z_3 - z_4 = 0 \\implies z_3 = z_4$\n如果我们选择 $z_4 = c$（对于任意标量 $c \\in \\mathbb{R}$），那么零空间中的任何向量 $\\mathbf{z}$ 都具有形式 $\\mathbf{z} = c \\begin{pmatrix} -1 \\\\ -1 \\\\ 1 \\\\ 1 \\end{pmatrix}$。$\\text{ker}(A)$ 的一个基是向量 $\\mathbf{v} = \\begin{pmatrix} -1 \\\\ -1 \\\\ 1 \\\\ 1 \\end{pmatrix}$。\n\n现在，我们检查这个非零向量 $\\mathbf{z}$ 是否也满足第二个条件 $\\mathbf{1}^T \\mathbf{z} = 0$。我们计算基向量 $\\mathbf{v}$ 的分量之和：\n$$\n\\mathbf{1}^T \\mathbf{v} = (-1) + (-1) + 1 + 1 = 0\n$$\n由于 $\\mathbf{1}^T \\mathbf{v} = 0$，对于 $c \\neq 0$ 的任何向量 $\\mathbf{z} = c\\mathbf{v}$ 都是一个同时满足 $A\\mathbf{z} = \\mathbf{0}$ 和 $\\mathbf{1}^T \\mathbf{z} = 0$ 的非零向量。\n这意味着我们可以找到不同的解 $\\mathbf{x}_1$ 和 $\\mathbf{x}_2 = \\mathbf{x}_1 + c\\mathbf{v}$，它们产生相同的观测向量 $\\mathbf{y}$ 并且总和均为 $N$。为了使解在实践中不唯一，我们还必须满足非负约束 $\\mathbf{x} \\ge \\mathbf{0}$。对于一个给定的有效解 $\\mathbf{x}_1$，可以选择一个足够小的 $c$，使得 $\\mathbf{x}_2 = \\mathbf{x}_1 + c\\mathbf{v}$ 也具有所有非负分量。例如，如果 $\\mathbf{x}_1 = \\begin{pmatrix} N/2  N/2  0  0 \\end{pmatrix}^T$，取 $c=N/4$ 会得到 $\\mathbf{x}_2 = \\begin{pmatrix} N/4  N/4  N/4  N/4 \\end{pmatrix}^T$。由于 $\\mathbf{x}_1 \\ne \\mathbf{x}_2$，解不是唯一的。\n\n因此，该系统是不可辨识的。可辨识性指标为 $I=0$。\n\n总之，$A$ 的秩为 $r=3$，系统不可辨识，所以 $I=0$。", "answer": "$$\\boxed{\\begin{pmatrix} 3  0 \\end{pmatrix}}$$", "id": "4351378"}, {"introduction": "在理解了定量模糊性的理论极限之后，我们来动手实现一种现代定量工具的核心算法。期望最大化（Expectation-Maximization, EM）算法是一种强大的统计方法，能够以迭代的方式为那些可能来源于多个转录本的读数分配概率。本编程练习将指导你从构建k-mer等价类（equivalence classes）入手，逐步实现一个简化的EM算法，从而将理论知识转化为解决实际问题的代码，深刻理解定量估计的内在机制。[@problem_id:4351362]", "problem": "给定一个用于转录本定量的高通量测序中的形式化伪比对场景。考虑一个有限的转录本集合 $T = \\{t_1, t_2, \\dots, t_m\\}$，其中每个转录本 $t_i$ 都有一个已知的核苷酸长度 $\\ell_i$。设 $M$ 是一个从读长（read）的 $k$-mer 到包含这些 $k$-mer 的转录本子集的映射。对于每个表示为 $k$-mer 有限列表的读长，将其候选转录本集合 $S(r)$ 定义为其所有组成 $k$-mer 所映射的转录本集合的交集。当 $S(r) = \\varnothing$ 时，读长将被丢弃。等价类被定义为在未被丢弃的读长中观察到的不同集合 $S \\subseteq T$，每个类 $S$ 都有一个计数 $n_S$，等于其 $S(r)$ 等于 $S$ 的读长数量。目标是使用期望最大化（Expectation-Maximization, EM）算法，在标准混合模型下估计转录本丰度比例 $\\theta = (\\theta_1, \\dots, \\theta_m)$，该模型中从转录本 $t_i$ 生成片段的概率与 $\\theta_i / \\ell_i$ 成正比。这意味着，对于一个等价类 $S$，其概率质量为 $\\sum_{j \\in S} \\theta_j / \\ell_j$，并且类 $S$ 对转录本 $t_i \\in S$ 的期望贡献是\n$$\nn_S \\cdot \\frac{\\theta_i/\\ell_i}{\\sum_{j \\in S} \\theta_j/\\ell_j}.\n$$\n一次 EM 更新设置如下\n$$\n\\theta_i^{\\text{new}} \\leftarrow \\frac{1}{N} \\sum_{S \\ni i} n_S \\cdot \\frac{\\theta_i^{\\text{old}}/\\ell_i}{\\sum_{j \\in S} \\theta_j^{\\text{old}}/\\ell_j},\n$$\n其中 $N = \\sum_S n_S$ 是未被丢弃的读长总数，$\\theta^{\\text{old}}$ 表示前一次迭代的结果。在 $T$ 上均匀初始化 $\\theta^{(0)}$，并进行迭代，直到 $\\ell_1$ 范数差 $\\|\\theta^{(k+1)} - \\theta^{(k)}\\|_1$ 小于 $\\varepsilon$ 或达到最大迭代次数。使用 $\\varepsilon = 10^{-10}$ 和最大 $10000$ 次迭代。\n\n构建一个完整的、可运行的程序，对下面的每个测试用例执行以下步骤：\n- 通过对其 $k$-mer 的 $M(k)$ 进行集合交集运算，为每个读长计算 $S(r)$，并丢弃 $S(r) = \\varnothing$ 的读长。\n- 汇总所有不同 $S$ 的等价类计数 $n_S$。\n- 遵循上述模型和指定的停止标准，运行 EM 算法来估计 $\\theta$。\n- 以浮点数列表的形式输出估计的丰度比例 $\\theta$，按每个测试用例中给出的转录本顺序排列，并四舍五入到六位小数。\n\n程序必须使用以下测试套件的精确参数值：\n\n- 测试用例 1：\n    - 转录本 $T = [t_1, t_2, t_3]$，核苷酸长度为：$\\ell_{t_1} = 1000$，$\\ell_{t_2} = 900$，$\\ell_{t_3} = 1100$。\n    - $k$-mer 映射 $M$：\n        - $\\text{'A'} \\mapsto \\{t_1, t_2\\}$，\n        - $\\text{'B'} \\mapsto \\{t_2, t_3\\}$，\n        - $\\text{'C'} \\mapsto \\{t_1, t_3\\}$，\n        - $\\text{'D'} \\mapsto \\{t_1\\}$，\n        - $\\text{'E'} \\mapsto \\{t_3\\}$。\n    - 读长 $R$（每项是一个 $k$-mer 列表）：\n        - $[\\text{'A'}, \\text{'B'}]$, \n        - $[\\text{'C'}, \\text{'E'}]$, \n        - $[\\text{'A'}, \\text{'C'}]$, \n        - $[\\text{'B'}]$, \n        - $[\\text{'A'}]$, \n        - $[\\text{'C'}]$, \n        - $[\\text{'B'}, \\text{'C'}]$, \n        - $[\\text{'A'}, \\text{'B'}, \\text{'C'}]$.\n\n- 测试用例 2（边界情况和富含单一转录本映射的情况）：\n    - 转录本 $T = [t_1, t_2, t_3]$，核苷酸长度为：$\\ell_{t_1} = 2000$，$\\ell_{t_2} = 500$，$\\ell_{t_3} = 1500$。\n    - $k$-mer 映射 $M$：\n        - $\\text{'X'} \\mapsto \\{t_1\\}$，\n        - $\\text{'Y'} \\mapsto \\{t_2\\}$，\n        - $\\text{'Z'} \\mapsto \\{t_2, t_3\\}$，\n        - $\\text{'W'} \\mapsto \\{t_1, t_2, t_3\\}$。\n    - 读长 $R$：\n        - $[\\text{'X'}]$,\n        - $[\\text{'Y'}]$,\n        - $[\\text{'Z'}]$,\n        - $[\\text{'W'}]$,\n        - $[\\text{'W'}, \\text{'Z'}]$,\n        - $[\\text{'W'}, \\text{'X'}]$,\n        - $[\\text{'Q'}]$.\n\n- 测试用例 3（包含丢弃和不对称长度的边缘情况）：\n    - 转录本 $T = [t_1, t_2, t_3]$，核苷酸长度为：$\\ell_{t_1} = 800$，$\\ell_{t_2} = 1200$，$\\ell_{t_3} = 1000$。\n    - $k$-mer 映射 $M$：\n        - $\\text{'K1'} \\mapsto \\{t_1, t_2\\}$，\n        - $\\text{'K2'} \\mapsto \\{t_2\\}$，\n        - $\\text{'K3'} \\mapsto \\{t_1\\}$，\n        - $\\text{'K4'} \\mapsto \\{t_3\\}$，\n        - $\\text{'K5'} \\mapsto \\{t_2, t_3\\}$。\n    - 读长 $R$：\n        - $[\\text{'K1'}, \\text{'K2'}]$,\n        - $[\\text{'K1'}, \\text{'K3'}]$,\n        - $[\\text{'K5'}]$,\n        - $[\\text{'K4'}]$,\n        - $[\\text{'K1'}]$,\n        - $[\\text{'K2'}, \\text{'K4'}]$,\n        - $[\\text{'K1'}, \\text{'K5'}]$,\n        - $[\\text{'K3'}]$.\n\n对于每个测试用例，答案必须是列表 $[\\theta_{t_1}, \\theta_{t_2}, \\theta_{t_3}]$，四舍五入到六位小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，其中每一项对应一个测试用例，并且本身是按转录本顺序列出的三个浮点数列表，例如 $[[0.1,0.2,0.7],[\\dots],[\\dots]]$。不允许外部输入。\n\n最终输出必须是纯粹的无单位比例。浮点数表示时四舍五入到六位小数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result1,result2,result3]$）。", "solution": "该问题要求从高通量测序读长的伪比对数据中估计转录本丰度比例，表示为向量 $\\theta = (\\theta_1, \\dots, \\theta_m)$。每个测试用例的解决方案都包含三个步骤：\n1.  推导等价类及其对应的读长计数。\n2.  使用期望最大化（EM）算法迭代估计 $\\theta$。\n3.  按要求格式化最终估计值。\n\n**步骤1：等价类生成**\n\n首先，我们处理原始读长数据以形成等价类。一个等价类是与给定读长兼容的一组转录本。对于每个读长 $r$（即一个组成的 $k$-mer 列表），其候选转录本集合 $S(r)$ 是通过其所有 $k$-mer 关联的转录本集合的交集来确定的。映射 $M$ 为给定的 k-mer $k$ 提供了转录本集合 $M(k)$。因此，$S(r) = \\bigcap_{k \\in r} M(k)$。\n\n如果此交集产生空集，即 $S(r) = \\varnothing$，则认为该读长不可映射并被丢弃。这种情况发生在读长的 $k$-mer 映射到不相容的转录本集合时。对于所有未被丢弃的读长，我们根据它们的候选集 $S(r)$ 进行聚合。所有共享相同候选集 $S$ 的读长构成一个等价类。我们对每个唯一的等价类 $S$ 统计其读长数量 $n_S$。未被丢弃（可映射）的读长总数为 $N = \\sum_S n_S$。\n\n在程序实现中，转录本标识符（如 $t_1, t_2, \\dots$）被映射到从零开始的整数索引 $0, 1, \\dots, m-1$。然后，等价类 $S$ 被表示为这些索引的集合。为了将这些集合用作计数的字典键，它们被转换为不可变类型，例如 Python 中的 `frozenset`。如果读长中存在一个 $k$-mer 但它不在映射 $M$ 中，则视为其映射到一个空的转录本集合，这会导致该读长被丢弃。\n\n**步骤2：期望最大化（EM）算法**\n\n问题的核心是使用提供的 EM 更新规则来估计 $\\theta$。EM 算法是一种迭代过程，非常适用于含有潜在（未观测）变量的统计模型。在这里，每个读长的潜在变量是其真实的来源转录本。\n\n该模型假设测序片段来源于转录本 $t_i$ 的概率与其有效丰度成正比，有效丰度由 $\\theta_i / \\ell_i$ 给出，其中 $\\ell_i$ 是转录本 $t_i$ 的长度。\n\nEM 算法的流程如下：\n\n- **初始化**：丰度比例被均匀初始化，即对于所有 $i=1, \\dots, m$，$\\theta_i^{(0)} = 1/m$，其中 $m$ 是转录本的数量。\n\n- **迭代**：算法在期望（E）步骤和最大化（M）步骤之间迭代，直到收敛。提供的更新规则结合了这两个步骤。对于每次迭代 $k$：\n\n    - **E-步骤（隐含）**：对于每个包含 $n_S$ 个读长的等价类 $S$，我们估计源自每个转录本 $t_i \\in S$ 的读长数量。类 $S$ 中的一个读长来自转录本 $t_i$ 的概率是 $t_i$ 的有效丰度与 $S$ 中所有转录本有效丰度总和的比率：\n    $$P(t_i | S, \\theta^{(k)}) = \\frac{\\theta_i^{(k)}/\\ell_i}{\\sum_{j \\in S} \\theta_j^{(k)}/\\ell_j}$$\n    因此，来自类 $S$ 且源于 $t_i$ 的期望读长数是 $n_S \\cdot P(t_i | S, \\theta^{(k)})$。\n\n    - **M-步骤（隐含）**：我们更新每个转录本 $t_i$ 的丰度估计值 $\\theta_i^{\\text{new}}$。这是通过对 $t_i$ 所属的所有等价类中 $t_i$ 的期望计数求和，然后用读长总数 $N$ 进行归一化来计算的。这就得到了问题中指定的更新公式：\n    $$\\theta_i^{\\text{new}} \\leftarrow \\frac{1}{N} \\sum_{S \\ni i} n_S \\cdot \\frac{\\theta_i^{(k)}/\\ell_i}{\\sum_{j \\in S} \\theta_j^{(k)}/\\ell_j}$$\n\n- **收敛**：重复此过程，直到连续估计值之间的变化足够小。停止条件是当连续 $\\theta$ 向量之差的 $\\ell_1$ 范数 $\\|\\theta^{(k+1)} - \\theta^{(k)}\\|_1 = \\sum_{i=1}^m |\\theta_i^{(k+1)} - \\theta_i^{(k)}|$ 低于阈值 $\\varepsilon = 10^{-10}$ 时。同时，设置了最大迭代次数为 $10000$ 次以防止无限循环。\n\n在实现中，我们维护一个向量 $\\theta$ 并在每次迭代中更新它。为防止除以零，如果分母 $\\sum_{j \\in S} \\theta_j^{(k)}/\\ell_j$ 为零，则该类的贡献计为零。\n\n**步骤3：最终输出**\n\nEM 算法收敛后，最终向量 $\\theta = (\\theta_1, \\dots, \\theta_m)$ 包含了估计的丰度比例。这些浮点值被四舍五入到六位小数，并根据每个测试用例的初始转录本列表的顺序以列表形式呈现。所有测试用例的结果被编译成一个单一的列表之列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        {\n            \"transcripts\": [\"t1\", \"t2\", \"t3\"],\n            \"lengths\": [1000, 900, 1100],\n            \"kmer_map\": {\n                'A': {'t1', 't2'},\n                'B': {'t2', 't3'},\n                'C': {'t1', 't3'},\n                'D': {'t1'},\n                'E': {'t3'}\n            },\n            \"reads\": [\n                ['A', 'B'], ['C', 'E'], ['A', 'C'], ['B'], ['A'],\n                ['C'], ['B', 'C'], ['A', 'B', 'C']\n            ]\n        },\n        {\n            \"transcripts\": [\"t1\", \"t2\", \"t3\"],\n            \"lengths\": [2000, 500, 1500],\n            \"kmer_map\": {\n                'X': {'t1'},\n                'Y': {'t2'},\n                'Z': {'t2', 't3'},\n                'W': {'t1', 't2', 't3'}\n            },\n            \"reads\": [\n                ['X'], ['Y'], ['Z'], ['W'], ['W', 'Z'], ['W', 'X'], ['Q']\n            ]\n        },\n        {\n            \"transcripts\": [\"t1\", \"t2\", \"t3\"],\n            \"lengths\": [800, 1200, 1000],\n            \"kmer_map\": {\n                'K1': {'t1', 't2'},\n                'K2': {'t2'},\n                'K3': {'t1'},\n                'K4': {'t3'},\n                'K5': {'t2', 't3'}\n            },\n            \"reads\": [\n                ['K1', 'K2'], ['K1', 'K3'], ['K5'], ['K4'], ['K1'],\n                ['K2', 'K4'], ['K1', 'K5'], ['K3']\n            ]\n        }\n    ]\n\n    results = []\n    for case_data in test_cases:\n        result = _solve_single_case(case_data)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef _solve_single_case(case_data):\n    \"\"\"\n    Solves a single test case for transcript abundance estimation.\n    \"\"\"\n    transcripts = case_data[\"transcripts\"]\n    lengths = np.array(case_data[\"lengths\"], dtype=np.float64)\n    kmer_def = case_data[\"kmer_map\"]\n    reads = case_data[\"reads\"]\n    \n    m = len(transcripts)\n    transcript_to_idx = {name: i for i, name in enumerate(transcripts)}\n\n    # Convert k-mer map to use integer indices for transcripts\n    kmer_map = {\n        kmer: frozenset(transcript_to_idx[t] for t in t_set)\n        for kmer, t_set in kmer_def.items()\n    }\n\n    # Step 1: Generate equivalence classes and counts\n    eq_classes = {}\n    total_reads = 0\n\n    for read_kmers in reads:\n        if not read_kmers:\n            continue\n        \n        # Start with the set from the first k-mer in the read\n        candidate_set = kmer_map.get(read_kmers[0], frozenset())\n\n        # Intersect with sets from the remaining k-mers\n        for kmer in read_kmers[1:]:\n            candidate_set = candidate_set.intersection(kmer_map.get(kmer, frozenset()))\n            if not candidate_set:  # Early exit if intersection is empty\n                break\n        \n        if candidate_set:\n            total_reads += 1\n            eq_classes[candidate_set] = eq_classes.get(candidate_set, 0) + 1\n            \n    if total_reads == 0:\n        return [round(1.0 / m, 6)] * m\n\n    # Step 2: Run the EM algorithm\n    theta = np.full(m, 1.0 / m, dtype=np.float64)\n    \n    max_iter = 10000\n    epsilon = 1e-10\n    \n    # Pre-calculate list representation of frozensets for faster indexing in the loop\n    eq_class_items = []\n    for s_frozen, n_s in eq_classes.items():\n        s_list = list(s_frozen)\n        eq_class_items.append((s_list, n_s))\n        \n    for _ in range(max_iter):\n        theta_old = theta\n        \n        effective_thetas = theta_old / lengths\n        \n        # This array will store the sum of expected counts for each transcript\n        total_expected_counts = np.zeros(m, dtype=np.float64)\n        \n        for s_list, n_s in eq_class_items:\n            # Denominator for the E-step probability calculation\n            denominator = np.sum(effective_thetas[s_list])\n            \n            if denominator > 0:\n                # Calculate expected counts from this equivalence class for its members\n                contributions = n_s * effective_thetas[s_list] / denominator\n                # Add these contributions to the respective transcripts\n                np.add.at(total_expected_counts, s_list, contributions)\n\n        # M-step: Update theta by normalizing the expected counts\n        theta = total_expected_counts / total_reads\n        \n        # Check for convergence\n        l1_diff = np.sum(np.abs(theta - theta_old))\n        if l1_diff  epsilon:\n            break\n            \n    # Step 3: Format output to six decimal places\n    return [round(val, 6) for val in theta]\n\n# Execute the main function\nsolve()\n```", "id": "4351362"}]}