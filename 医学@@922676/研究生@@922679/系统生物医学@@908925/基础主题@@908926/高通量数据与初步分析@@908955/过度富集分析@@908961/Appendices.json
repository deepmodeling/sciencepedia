{"hands_on_practices": [{"introduction": "过表达分析（ORA）的核心是超几何检验，它为我们判断基因集是否显著富集提供了统计基础。然而，在处理具有层次结构的本体（如基因本体论，GO）时，直接应用该检验可能会因父子术语间的重叠而产生冗余的证据。本练习 [@problem_id:4371320] 将引导你实践一种更严谨的方法——条件检验。通过在一个假设的系统生物医学研究场景中，你将学习如何将分析范围限定于父术语内，从而更精确地评估子术语的富集情况，这是处理复杂生物学注释时一项至关重要的技能。", "problem": "一项系统生物医学研究对一个转录组学实验进行过表达分析（ORA; Over-Representation Analysis），该分析侧重于一个分层本体论，其中子术语是父术语的严格子集。设表达基因的总集合（基因全集）的大小为 $N$，父术语 $\\mathcal{P}$ 包含 $M_{\\mathcal{P}}$ 个基因。子术语 $\\mathcal{C}$ 是 $\\mathcal{P}$ 的一个子集，包含 $M_{\\mathcal{C}}$ 个基因，且 $\\mathcal{C} \\subset \\mathcal{P}$。现已确定一个大小为 $m$ 的差异表达基因集合 $\\mathcal{D}$。在父术语中，差异表达基因的数量为 $x_{\\mathcal{P}} = |\\mathcal{D} \\cap \\mathcal{P}|$，而在子术语中，该数量为 $x_{\\mathcal{C}} = |\\mathcal{D} \\cap \\mathcal{C}|$。\n\n为了考虑分层结构并避免冗余证据，对子术语使用条件检验：通过将抽样全集限制在 $\\mathcal{P}$ 来以父术语为条件，并检验子术语 $\\mathcal{C}$ 是否在 $\\mathcal{P}$ 内的 $x_{\\mathcal{P}}$ 个差异表达基因中过表达。假设标准的ORA模型是从有限集合中进行无放回抽样，将属于 $\\mathcal{C}$ 视为“成功”，并计算在从 $\\mathcal{P}$ 中抽取的 $x_{\\mathcal{P}}$ 个样本中观察到 $x_{\\mathcal{C}}$ 或更多次成功的单侧尾部概率。\n\n在一次具体分析中，研究报告 $N = 18000$，$M_{\\mathcal{P}} = 20$，$M_{\\mathcal{C}} = 10$，$m = 1200$，$x_{\\mathcal{P}} = 5$，$x_{\\mathcal{C}} = 5$。根据上述条件检验，计算在给定 $\\mathcal{P}$ 的条件下，$\\mathcal{C}$ 过表达的单侧条件 $p$ 值。将答案四舍五入到四位有效数字。最终数字不带任何单位。", "solution": "该问题陈述已经过验证，被认为是合理的、自洽的且定义明确的。它描述了生物信息学中的一个标准场景，需要进行条件超几何检验，所有必要的参数都已提供。无关信息（$N$ 和 $m$）不会产生矛盾，而是为该特定子问题所源于的更宏大的研究提供了背景。\n\n问题要求计算在父术语 $\\mathcal{P}$ 内，子术语 $\\mathcal{C}$ 过表达的单侧条件 $p$ 值。条件化是通过将基因全集限制在父术语中的基因集合 $\\mathcal{P}$ 来实现的。这个场景对应于一个超几何检验，该检验模拟从有限总体中进行无放回抽样。\n\n设 $X$ 为随机变量，表示从父术语 $\\mathcal{P}$ 中抽取给定大小的样本时，所发现的来自子术语 $\\mathcal{C}$ 的基因数量。\n\n在此条件背景下，超几何分布的参数定义如下：\n-   总体大小是父术语 $\\mathcal{P}$ 中的基因数量。设其为 $K = M_{\\mathcal{P}}$。\n-   总体中“成功”项的数量是子术语 $\\mathcal{C}$（$\\mathcal{P}$ 的一个子集）中的基因数量。设其为 $k = M_{\\mathcal{C}}$。\n-   样本大小是在父术语 $\\mathcal{P}$ 内发现的差异表达基因的数量。设其为 $n = x_{\\mathcal{P}}$。\n-   样本中观察到的成功次数是同时也在子术语 $\\mathcal{C}$ 中的差异表达基因的数量。设其为 $x = x_{\\mathcal{C}}$。\n\n提供的值为：\n-   $K = M_{\\mathcal{P}} = 20$\n-   $k = M_{\\mathcal{C}} = 10$\n-   $n = x_{\\mathcal{P}} = 5$\n-   $x = x_{\\mathcal{C}} = 5$\n\n在大小为 $n$ 的样本中观察到恰好 $i$ 次成功的概率质量函数（PMF）由超几何概率公式给出：\n$$P(X=i) = \\frac{\\binom{k}{i} \\binom{K-k}{n-i}}{\\binom{K}{n}}$$\n问题要求计算观察到 $x_{\\mathcal{C}}$ 或更多次成功的单侧尾部概率，这即是过表达检验的 $p$ 值。其计算方式如下：\n$$p = P(X \\ge x) = \\sum_{i=x}^{\\min(n, k)} P(X=i)$$\n代入给定值，我们需要计算 $P(X \\ge 5)$。样本中可能的最大成功次数受限于样本大小 $n$ 和总体中成功项的总数 $k$。最大值为 $\\min(n,k) = \\min(5, 10) = 5$。\n\n由于观察到的成功次数 $x = 5$ 等于可能的最大成功次数，因此 $p$ 值的求和简化为单项：\n$$p = P(X \\ge 5) = P(X=5)$$\n现在我们使用PMF计算这个概率：\n$$p = P(X=5) = \\frac{\\binom{M_{\\mathcal{C}}}{x_{\\mathcal{C}}} \\binom{M_{\\mathcal{P}} - M_{\\mathcal{C}}}{x_{\\mathcal{P}} - x_{\\mathcal{C}}}}{\\binom{M_{\\mathcal{P}}}{x_{\\mathcal{P}}}}$$\n代入数值：\n$$p = \\frac{\\binom{10}{5} \\binom{20 - 10}{5 - 5}}{\\binom{20}{5}} = \\frac{\\binom{10}{5} \\binom{10}{0}}{\\binom{20}{5}}$$\n接下来，我们计算二项式系数：\n-   $\\binom{10}{5} = \\frac{10!}{5!(10-5)!} = \\frac{10 \\cdot 9 \\cdot 8 \\cdot 7 \\cdot 6}{5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1} = 2 \\cdot 9 \\cdot 2 \\cdot 7 = 252$\n-   $\\binom{10}{0} = \\frac{10!}{0!(10-0)!} = 1$\n-   $\\binom{20}{5} = \\frac{20!}{5!(20-5)!} = \\frac{20 \\cdot 19 \\cdot 18 \\cdot 17 \\cdot 16}{5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1} = 19 \\cdot 3 \\cdot 17 \\cdot 16 = 15504$\n\n现在，我们将这些值代回 $p$ 的表达式中：\n$$p = \\frac{252 \\cdot 1}{15504} = \\frac{252}{15504}$$\n进行除法运算：\n$$p \\approx 0.0162538699...$$\n题目要求将答案四舍五入到四位有效数字。前四位有效数字是 $1$、$6$、$2$ 和 $5$。接下来的数字是 $3$，小于 $5$，所以我们舍去。\n$$p \\approx 0.01625$$\n这是在给定术语 $\\mathcal{P}$ 的条件下，术语 $\\mathcal{C}$ 过表达的单侧条件 $p$ 值。", "answer": "$$\\boxed{0.01625}$$", "id": "4371320"}, {"introduction": "虽然超几何检验在数学上是严谨的，但其在生物学分析中的有效性取决于一个关键假设：差异表达基因是从事先定义的基因“全集”中均匀随机抽样的。在真实的实验中，这个假设常常被各种生物学和技术因素所打破。本练习 [@problem_id:4371331] 旨在培养你识别这些混杂因素的敏锐洞察力。通过分析一个涉及不同细胞类型组分和基因长度偏好的实际案例，你将学会批判性地评估ORA结果的可靠性，并理解为何必须对这些潜在的偏好进行校正。", "problem": "一项系统生物医学领域的队列研究使用RNA测序（RNA-seq）来探究疾病特异性的转录变化。病例样本是具有不同程度免疫浸润的批量肿瘤活检样本，而对照组是免疫成分较低的癌旁正常组织。下游分析对差异表达基因（DEG）进行基因本体论（Gene Ontology）生物学过程类别的过表征分析（ORA）。\n\n假设在一次病例与对照组的对比中，存在以下情况：\n- 总基因集包含 $N = 20000$ 个已注释的基因。\n- 差异表达基因的数量为 $K = 800$。\n- 一个典型的免疫激活基因集在完整注释中的大小为 $M = 300$。\n- 在这 $K$ 个差异表达基因中，属于免疫激活基因集的基因数量为 $x = 90$。\n- 由于平台特异性的可检测性和组织背景，病例样本中表达量高于阈值的基因数量为 $N_{\\mathrm{expr}} = 12000$，并且在这些样本中，免疫激活基因集有 $M_{\\mathrm{expr}} = 250$ 个成员被表达。\n- 组间的细胞类型组成不同：病例组的免疫细胞比例为 $f_{\\mathrm{case}} = 0.35$，对照组为 $f_{\\mathrm{ctrl}} = 0.10$。\n- RNA-seq中存在已知的基因长度效应：差异表达基因中长基因的比例为 $p_{L}^{\\mathrm{DE}} = 0.50$，而在整个基因集中该比例为 $p_{L}^{U} = 0.20$，在免疫激活基因集中该比例为 $p_{L}^{S} = 0.60$。\n\n从ORA的第一性原理出发，即零假设模型将 $K$ 个选定的差异表达基因视为从一个大小为 $N$ 的固定基因集（或一个适当定义的背景子集）中均匀无放回抽取的样本，并假设在给定基因集的情况下，基因的选择与基因集类别的成员身份无关，回答以下问题：\n\n关于此情境下病例特异性混杂因素和ORA的有效推断，以下哪些陈述是正确的？\n\nA. 由于 $f_{\\mathrm{case}} \\neq f_{\\mathrm{ctrl}}$，ORA所基于的均匀抽样假设被违反：仅在免疫细胞中表达的基因具有更高的被选择概率，而这与疾病机制无关。一种可行的缓解方法是在差异表达模型中考虑细胞类型组成，和/或执行以细胞类型特异性表达为条件的分层ORA。\n\nB. 将基因集限制为 $N_{\\mathrm{expr}} = 12000$ 个基因，并将基因集大小限制为 $M_{\\mathrm{expr}} = 250$，可以完全解决由细胞类型组成引起的混杂问题，因此此后计算的超几何p值无需进一步调整即为有效。\n\nC. 基因长度偏倚（$p_{L}^{\\mathrm{DE}}  p_{L}^{U}$ 且 $p_{L}^{S}$ 较高）会夸大表观上的过表征；一种有原则的校正方法是使用一个对基因长度进行校正的模型，例如以差异表达和基因长度作为协变量，对类别成员身份进行逻辑回归，或采用匹配长度分布的重抽样方法。\n\nD. 在ORA之前移除重叠或冗余的基因集，可以保证对错误发现率的控制，并消除病例特异性混杂因素，从而使标准的超几何p值变得可靠。", "solution": "问题要求在一个特定的系统生物医学背景下，评估关于过表征分析（ORA）中混杂因素的几个陈述的正确性。ORA的有效性取决于其核心假设：这组 $K$ 个差异表达基因（DEG）代表了从一个大小为 $N$ 的基因集中均匀无放回抽取的随机样本。任何导致基因被选为差异表达基因的概率不均匀的系统性因素都会违反这一假设，并可能导致虚假结果。ORA的标准统计检验是超几何检验，它计算在给定基因集大小为 $N$ 的情况下，在 $K$ 个差异表达基因列表中，观察到来自大小为 $M$ 的特定基因集的基因数量为 $x$ 或更多的概率。观察到恰好 $k$ 次成功的概率公式为：\n$$ P(X=k) = \\frac{\\binom{M}{k} \\binom{N-M}{K-k}}{\\binom{N}{K}} $$\n只有当 $K$ 个基因的抽样确实是均匀的时，该模型才有效。我们将根据这一原则评估每个陈述。\n\n提供的数据如下：\n- 总基因集大小：$N = 20000$\n- 差异表达基因数量：$K = 800$\n- 免疫基因集大小：$M = 300$\n- 免疫基因集中的差异表达基因：$x = 90$\n- 表达基因集：$N_{\\mathrm{expr}} = 12000$\n- 表达的免疫基因集成员：$M_{\\mathrm{expr}} = 250$\n- 病例组中的免疫细胞比例：$f_{\\mathrm{case}} = 0.35$\n- 对照组中的免疫细胞比例：$f_{\\mathrm{ctrl}} = 0.10$\n- 基因长度比例：$p_{L}^{\\mathrm{DE}} = 0.50$（差异表达基因中），$p_{L}^{U} = 0.20$（基因集中），$p_{L}^{S} = 0.60$（免疫基因集中）。\n\n### 选项A分析\n\n该陈述解决了细胞类型组成的混杂问题。问题指出，病例样本中的免疫细胞比例（$f_{\\mathrm{case}} = 0.35$）显著高于对照样本（$f_{\\mathrm{ctrl}} = 0.10$）。批量RNA-seq测量的是组织匀浆中所有细胞中一个基因的平均表达量。对于一个仅在免疫细胞中表达的基因，其在批量样本中测得的表达量将大致与免疫细胞的比例成正比。因此，这样一个基因在病例组与对照组相比会显得上调，这仅仅是由于细胞群体的变化，而不一定是由于任何特定细胞类型内基因调控的变化。这样一个基因的近似倍数变化将是 $f_{\\mathrm{case}} / f_{\\mathrm{ctrl}} = 0.35 / 0.10 = 3.5$。对于整整一类基因（免疫细胞特异性基因）来说，这种巨大的、系统性的倍数变化极大地增加了它们被选为差异表达基因的概率。这直接违反了ORA的均匀抽样假设，即基因集中的每个基因都应该有相等的被选择机会（$K/N$）。因此，差异表达基因列表中免疫基因的富集受到了细胞类型组成差异的混杂影响。该陈述提出了两种有效的缓解策略：（1）在差异表达模型中考虑细胞类型组成，例如，在线性模型中将细胞类型比例作为协变量（例如 `~ condition + immune_fraction`），这有助于将疾病`condition`的影响与细胞类型丰度的影响分离开来；以及（2）进行分层ORA，即在已知于特定细胞类型中表达的基因集内进行富集检验。这两种方法都是公认的、有原则的方法，用于解决这种常见的混杂因素。\n\n该陈述在科学上和统计上都是合理的。\n\n**结论：正确**\n\n### 选项B分析\n\n该陈述表明，将分析限制在表达基因的背景下（$N_{\\mathrm{expr}} = 12000$ 和 $M_{\\mathrm{expr}} = 250$）足以解决细胞类型组成带来的混杂问题。虽然使用表达基因作为背景是一种好的做法（因为不表达的基因不可能差异表达），但这并不能解决在表达基因*之间*存在偏向性选择的问题。细胞类型组成的差异（$f_{\\mathrm{case}} \\neq f_{\\mathrm{ctrl}}$）导致在 $N_{\\mathrm{expr}}$ 个表达基因的集合*内部*，被选为差异表达基因的概率不均匀。由于选项A中描述的细胞群体转移混杂因素，存在于 $N_{\\mathrm{expr}}$ 基因集中的免疫特异性基因仍然比非免疫特异性基因更有可能被判定为差异表达基因。调整背景集的大小使检验更具特异性，但并不能纠正输入差异表达基因列表中的偏倚。超几何p值仍然是无效的，因为从 $N_{\\mathrm{expr}}$ 个基因中产生 $K$ 个差异表达基因的底层抽样过程不是均匀的。\n\n该陈述提供了一种虚假的安全感，并错误地识别了混杂的本质。\n\n**结论：不正确**\n\n### 选项C分析\n\n该陈述解决了基因长度偏倚问题。问题指出，差异表达基因中长基因的比例（$p_{L}^{\\mathrm{DE}} = 0.50$）远高于基因集中的比例（$p_{L}^{U} = 0.20$）。这从经验上证明了较长的基因有更高的概率被鉴定为差异表达基因。这是RNA-seq分析中一个已知的技术性假象，即较长的基因会累积更多的读数，从而增加了检测其表达变化的统计功效。这再次违反了ORA的均匀抽样假设。该陈述进一步指出，免疫激活基因集也富含长基因（$p_{L}^{S} = 0.60$）。这就造成了一个典型的混杂情景：感兴趣的基因集（免疫激活）在差异表达基因列表中被富集，部分或全部原因是因为这两个列表都共享一个与所研究的生物学过程无关的共同属性（长基因）。为了获得有效的结果，必须对这种偏倚进行校正。该陈述提出了有原则的校正方法：使用一个统计模型，如逻辑回归，其中一个基因成为差异表达基因的概率被建模为基因长度的函数；或者使用基于重抽样的方法，通过抽取与测试集长度分布相匹配的随机基因集来构建零分布。这些方法，例如在GOseq R包中实现的方法，是校正基因集分析中基因长度偏倚的标准且合适的方法。\n\n该陈述正确地识别了问题并提出了有效的解决方案。\n\n**结论：正确**\n\n### 选项D分析\n\n该陈述声称，移除重叠或冗余的基因集可以保证对错误发现率（FDR）的控制，并消除病例特异性混杂因素。移除冗余基因集是提高ORA结果可解释性的一个有用的后处理步骤。像基因本体论（Gene Ontology）这样的基因层级结构包含许多相关的术语，报告所有这些术语可能会提供不了多少信息。然而，这一操作对于解决输入数据中的根本性偏倚毫无作用。病例特异性混杂因素，例如来自细胞类型组成或基因长度偏倚等技术性假象，发生在产生 $K$ 个差异表达基因列表的差异表达分析步骤中。这些偏倚使ORA的p值本身失效。事后修剪结果列表并不能纠正被修剪数值的无效性。此外，这并不能“保证”对错误发现率（FDR）的控制。FDR是由像应用于一组p值的Benjamini-Hochberg这样的程序来控制的。如果p值本身存在系统性偏倚（例如，由于混杂因素而偏向显著性），那么由此产生的经FDR调整后的值（q值）也将是不可靠的。\n\n该陈述将用于解释的后处理与上游的偏倚校正混为一谈，并对“保证”FDR控制提出了一个不合理的强有力声明。\n\n**结论：不正确**", "answer": "$$\\boxed{AC}$$", "id": "4371331"}, {"introduction": "在识别了标准ORA方法的局限性之后，下一步是掌握能够克服这些挑战的先进技术。本练习 [@problem_id:4371308] 将指导你通过实现一个基于广义线性模型（GLM）的ORA方法，来处理混杂变量。你将使用逻辑回归来建模一个基因被选中的概率，同时将基因长度和GC含量等潜在的混杂因素作为协变量纳入模型。通过亲手编写代码并完成此项实践，你不仅能深刻理解协变量校正的原理，还将掌握一种比传统超几何检验更为强大和灵活的富集分析工具。", "problem": "在系统生物医学中，过表达分析（Over-Representation Analysis, ORA）旨在确定预定义基因集的成员资格是否与差异表达等结果相关，同时适当校正可能混淆该关联的基因特异性协变量（例如，基因长度和鸟嘌呤-胞嘧啶含量）。实现协变量校正的一种有原则的方法是，通过带有 logit 连接函数的广义线性模型（Generalized Linear Model, GLM）对二元结果的概率进行建模，即逻辑回归。考虑一个由 $i \\in \\{1,\\dots,N\\}$ 索引的基因群体。对于每个基因 $i$，令 $y_i \\in \\{0,1\\}$ 表示基因 $i$ 是否差异表达，$s_i \\in \\{0,1\\}$ 表示基因 $i$ 是否属于待测基因集，$\\ell_i \\in \\mathbb{R}_{+}$ 表示基因长度，$g_i \\in [0,1]$ 表示鸟嘌呤-胞嘧啶含量分数。假设在给定预测变量的情况下，结果是条件独立的。您的任务是使用逻辑回归中基于似然的推断来实现协变量校正的 ORA，并报告统计证据、估计的效应大小以及富集的决策指标。\n\n从基本原理出发：\n- 给定预测变量，$y_i$ 的条件分布是成功概率为 $p_i$ 的伯努利分布，即 $y_i \\sim \\mathrm{Bernoulli}(p_i)$，对于 $i=1,\\dots,N$ 彼此独立。\n- 逻辑连接函数通过 $\\mathrm{logit}(p_i) = \\log\\left(\\frac{p_i}{1-p_i}\\right) = \\mathbf{x}_i^{\\top}\\boldsymbol{\\beta}$ 将 $p_i$ 与线性预测器关联起来，其中 $\\mathbf{x}_i$ 收集了预测变量，$\\boldsymbol{\\beta}$ 是待通过最大化对数似然来估计的未知系数。\n- 为改善数值条件，必须在每个测试用例中通过 $z$-score 对连续协变量进行标准化：对于任何数值向量 $\\mathbf{v} = (v_1,\\dots,v_N)$，定义标准化向量 $\\tilde{\\mathbf{v}}$ 为 $\\tilde{v}_i = (v_i - \\bar{v})/\\sigma_v$，其中 $\\bar{v} = \\frac{1}{N}\\sum_{i=1}^{N} v_i$ 且 $\\sigma_v = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}(v_i - \\bar{v})^2}$。\n\n为每个测试用例定义两个嵌套模型：\n- 简化模型（无富集的零假设）：$\\mathrm{logit}(p_i) = \\beta_0 + \\beta_{\\ell}\\,\\tilde{\\ell}_i + \\beta_{g}\\,\\tilde{g}_i$。\n- 完整模型（具有富集效应的备择假设）：$\\mathrm{logit}(p_i) = \\beta_0 + \\beta_{s}\\,s_i + \\beta_{\\ell}\\,\\tilde{\\ell}_i + \\beta_{g}\\,\\tilde{g}_i$。\n\n对于每个测试用例：\n1. 遵循上述定义，使用迭代二阶方法通过最大化伯努利对数似然来拟合两个模型。\n2. 计算似然比统计量 $\\Delta = 2\\left(\\log L_{\\text{full}} - \\log L_{\\text{reduced}}\\right)$，其中 $\\log L_{\\text{model}}$ 是在该模型下最大化的对数似然。在零假设下，$\\Delta$ 渐近服从自由度为 $1$ 的 $\\chi^2$ 分布，从而得出一个以小数表示的 $p$-值 $p = \\Pr\\{\\chi^2_1 \\ge \\Delta\\}$。\n3. 从完整模型中，提取 $s_i$ 的系数 $\\hat{\\beta}_s$ 并报告以小数表示的比值比 $\\exp(\\hat{\\beta}_s)$。\n4. 报告一个布尔值的富集决策，其定义规则为：当且仅当 $p$-值小于或等于显著性水平 $\\alpha = 0.05$ 且 $\\hat{\\beta}_s  0$ 时为富集。\n\n您的程序必须仅使用指定的运行时环境来实现上述要求。为保证数值稳定性，在每次迭代求解正规方程时，您可以使用 Moore–Penrose 伪逆。对参数更新或对数似然改进使用一个适当小且与浮点精度一致的收敛容差。\n\n测试套件。将您的实现应用于以下四个独立的测试用例。在每个案例中，$N = 20$，数组按基因索引 $i = 1,\\dots,20$ 排序。\n\n测试用例 $1$（明显富集，弱混淆）：\n- $s^{(1)} = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$\n- $y^{(1)} = [1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]$\n- $\\ell^{(1)} = [1400, 1550, 1600, 1500, 1450, 1520, 1580, 1490, 1510, 1470, 1420, 1560, 1495, 1530, 1460, 1505, 1575, 1480, 1525, 1455]$\n- $g^{(1)} = [0.48, 0.52, 0.50, 0.47, 0.49, 0.51, 0.53, 0.46, 0.50, 0.48, 0.47, 0.54, 0.49, 0.52, 0.46, 0.50, 0.55, 0.48, 0.51, 0.47]$\n\n测试用例 $2$（由基因长度混淆驱动的表观富集；校正应能消除它）：\n- $s^{(2)} = [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1]$\n- $y^{(2)} = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1]$\n- $\\ell^{(2)} = [900, 950, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1750, 1800, 1850, 1900, 1950, 2000, 2050, 2100, 2150, 2200]$\n- $g^{(2)} = [0.42, 0.43, 0.44, 0.45, 0.46, 0.47, 0.48, 0.49, 0.50, 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58, 0.59, 0.60, 0.61]$\n\n测试用例 $3$（基因集流行率低，具有中度正相关）：\n- $s^{(3)} = [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]$\n- $y^{(3)} = [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]$\n- $\\ell^{(3)} = [1300, 1600, 1400, 1500, 1550, 1700, 1650, 1350, 1800, 1450, 1750, 1250, 1550, 1600, 1500, 1850, 1400, 1900, 1750, 1600]$\n- $g^{(3)} = [0.50, 0.48, 0.52, 0.49, 0.47, 0.51, 0.46, 0.53, 0.55, 0.50, 0.49, 0.48, 0.47, 0.52, 0.51, 0.54, 0.46, 0.55, 0.50, 0.49]$\n\n测试用例 $4$（基因集成员间的结局率相等的零情况）：\n- $s^{(4)} = [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]$\n- $y^{(4)} = [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0]$\n- $\\ell^{(4)} = [1500, 1600, 1550, 1450, 1520, 1490, 1510, 1480, 1530, 1470, 1505, 1495, 1515, 1485, 1525, 1475, 1500, 1490, 1510, 1480]$\n- $g^{(4)} = [0.50, 0.51, 0.49, 0.48, 0.52, 0.50, 0.49, 0.51, 0.50, 0.48, 0.52, 0.49, 0.50, 0.51, 0.49, 0.50, 0.51, 0.49, 0.50, 0.48]$\n\n对于每个测试用例 $j \\in \\{1,2,3,4\\}$，您的程序必须输出一个三元组 $[p^{(j)}, \\mathrm{OR}^{(j)}, \\mathrm{enriched}^{(j)}]$，其中 $p^{(j)}$ 是从似然比检验计算出的 $p$-值，$\\mathrm{OR}^{(j)} = \\exp(\\hat{\\beta}_s)$ 是来自完整模型的比值比，$\\mathrm{enriched}^{(j)}$ 是如上定义的布尔富集决策。将 $p^{(j)}$ 和 $\\mathrm{OR}^{(j)}$ 表示为四舍五入到六位小数的小数。使用显著性水平 $\\alpha = 0.05$ 作为小数。您的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，顺序与测试用例 $1$ 到 $4$ 相对应，例如：“[[p1,OR1,True],[p2,OR2,False],[p3,OR3,False],[p4,OR4,False]]”。", "solution": "用户的题目已根据指定标准进行审查和验证。\n\n### 步骤1：提取已知条件\n- **总体：** 一组 $N$ 个基因，由 $i \\in \\{1, \\dots, N\\}$ 索引。\n- **基因 $i$ 的变量：**\n    - $y_i \\in \\{0, 1\\}$：二元结果（例如，差异表达）。\n    - $s_i \\in \\{0, 1\\}$：基因集成员的二元指标。\n    - $\\ell_i \\in \\mathbb{R}_{+}$：基因长度（一个连续协变量）。\n    - $g_i \\in [0, 1]$：鸟嘌呤-胞嘧啶含量分数（一个连续协变量）。\n- **统计模型：**\n    - 结果 $y_i$ 在给定预测变量的情况下是条件独立的。\n    - 条件分布是伯努利分布：$y_i \\sim \\mathrm{Bernoulli}(p_i)$。\n    - 成功概率 $p_i$ 通过一个 logit 连接函数与预测变量相关联：$\\mathrm{logit}(p_i) = \\log\\left(\\frac{p_i}{1-p_i}\\right) = \\mathbf{x}_i^{\\top}\\boldsymbol{\\beta}$。\n- **数据预处理：**\n    - 连续协变量（$\\ell_i$, $g_i$）必须使用 z-score 变换进行标准化：$\\tilde{v}_i = (v_i - \\bar{v})/\\sigma_v$，其中 $\\bar{v}$ 和 $\\sigma_v$ 分别是总体均值和标准差。\n- **用于假设检验的嵌套模型：**\n    - **简化模型 ($H_0$)：** $\\mathrm{logit}(p_i) = \\beta_0 + \\beta_{\\ell}\\,\\tilde{\\ell}_i + \\beta_{g}\\,\\tilde{g}_i$。此模型假设基因集成员与结果之间没有关联。\n    - **完整模型 ($H_A$)：** $\\mathrm{logit}(p_i) = \\beta_0 + \\beta_{s}\\,s_i + \\beta_{\\ell}\\,\\tilde{\\ell}_i + \\beta_{g}\\,\\tilde{g}_i$。此模型包含一个基因集成员项。\n- **任务：**\n    1. 使用迭代二阶方法通过最大化伯努利对数似然来拟合两个模型。\n    2. 计算似然比检验统计量 $\\Delta = 2\\left(\\log L_{\\text{full}} - \\log L_{\\text{reduced}}\\right)$ 及其对应的来自 $\\chi^2_1$ 分布的 $p$ 值。\n    3. 从完整模型中提取系数 $\\hat{\\beta}_s$ 并报告比值比 $\\mathrm{OR} = \\exp(\\hat{\\beta}_s)$。\n    4. 做出富集决策：`enriched` 为真当且仅当 $p \\le \\alpha$ 且 $\\hat{\\beta}_s  0$，其中显著性水平为 $\\alpha = 0.05$。\n- **数值方法：** 在求解线性系统时使用 Moore-Penrose 伪逆。\n- **测试套件：** 提供了四个具体的测试用例，每个用例都有 $N=20$ 以及 $s, y, \\ell, g$ 的数据。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据：** 该问题描述了一种标准的生物统计学方法，即使用逻辑回归和似然比检验的协变量校正过表达分析。所有概念都牢固地植根于已建立的统计理论。\n- **良态性：** 该问题是良态的。它提供了具体数据，定义了统计模型，概述了推断过程（MLE, LRT），并指定了期望的输出。可以计算出唯一且有意义的解。\n- **客观性：** 问题陈述使用精确、客观和技术性的语言编写，没有歧义或主观性陈述。\n\n### 步骤3：结论与行动\n该问题是有效的。它在科学上是合理的、良态的、客观的和完整的。将开发并呈现一个解决方案。\n\n### 基于原理的解决方案\n任务是执行协变量校正的过表达分析（ORA）。这涉及检验二元结果 $y_i$（例如差异表达）与基因集 $s_i$ 成员资格之间的关联，同时控制基因长度 $\\ell_i$ 和 GC 含量 $g_i$ 等混淆变量。指定的框架是具有伯努利响应和 logit 连接函数的广义线性模型（GLM），通常称为逻辑回归。\n\n**1. 逻辑回归模型与对数似然**\n\n对于每个基因 $i$，假设结果 $y_i$ 服从成功概率为 $p_i$ 的伯努利分布，记为 $y_i \\sim \\mathrm{Bernoulli}(p_i)$。逻辑回归模型通过 logit 连接函数将概率 $p_i$ 与预测变量 $\\mathbf{x}_i$ 的线性组合联系起来：\n$$\n\\eta_i = \\mathrm{logit}(p_i) = \\log\\left(\\frac{p_i}{1 - p_i}\\right) = \\mathbf{x}_i^\\top\\boldsymbol{\\beta}\n$$\n其中 $\\mathbf{x}_i$ 是基因 $i$ 的预测变量向量，$\\boldsymbol{\\beta}$ 是未知系数向量。反转连接函数可得到概率：\n$$\np_i = \\frac{\\exp(\\eta_i)}{1 + \\exp(\\eta_i)} = \\frac{1}{1 + \\exp(-\\eta_i)}\n$$\n这是 sigmoid 函数 $\\sigma(\\eta_i)$。\n\n单个观测的似然为 $L_i(\\boldsymbol{\\beta}) = p_i^{y_i} (1-p_i)^{1-y_i}$。假设 $N$ 个基因之间条件独立，总对数似然是各个对数似然之和：\n$$\n\\log L(\\boldsymbol{\\beta}) = \\sum_{i=1}^{N} \\left[ y_i \\log(p_i) + (1-y_i) \\log(1-p_i) \\right]\n$$\n代入 $\\log(p_i) = \\eta_i - \\log(1+\\exp(\\eta_i))$ 和 $\\log(1-p_i) = -\\log(1+\\exp(\\eta_i))$，并令 $\\eta_i = \\mathbf{x}_i^\\top\\boldsymbol{\\beta}$，待最大化的对数似然函数为：\n$$\n\\log L(\\boldsymbol{\\beta}) = \\sum_{i=1}^{N} \\left[ y_i (\\mathbf{x}_i^\\top\\boldsymbol{\\beta}) - \\log(1 + \\exp(\\mathbf{x}_i^\\top\\boldsymbol{\\beta})) \\right]\n$$\n\n**2. 通过迭代重加权最小二乘法（IRLS）进行最大似然估计**\n\n为了找到最大似然估计（MLE）$\\hat{\\boldsymbol{\\beta}}$，我们必须解 $\\nabla_{\\boldsymbol{\\beta}} \\log L(\\boldsymbol{\\beta}) = \\mathbf{0}$。这个方程组是非线性的，需要迭代数值方法。问题指定了一种二阶方法，其中 Newton-Raphson 算法是一个经典选择。该算法引出了 GLM 的 IRLS 过程。\n\n对数似然的梯度（得分向量）是：\n$$\n\\nabla_{\\boldsymbol{\\beta}} \\log L(\\boldsymbol{\\beta}) = \\sum_{i=1}^{N} (y_i - p_i)\\mathbf{x}_i = \\mathbf{X}^\\top (\\mathbf{y} - \\mathbf{p})\n$$\nHessian 矩阵（二阶偏导数矩阵）是：\n$$\n\\mathbf{H} = \\nabla^2_{\\boldsymbol{\\beta}} \\log L(\\boldsymbol{\\beta}) = -\\sum_{i=1}^{N} p_i(1-p_i)\\mathbf{x}_i\\mathbf{x}_i^\\top = -\\mathbf{X}^\\top \\mathbf{W} \\mathbf{X}\n$$\n其中 $\\mathbf{W}$ 是一个对角矩阵，其元素为 $W_{ii} = p_i(1 - p_i)$。\n\n第 $t$ 次迭代的 Newton-Raphson 更新是：\n$$\n\\boldsymbol{\\beta}^{(t+1)} = \\boldsymbol{\\beta}^{(t)} - (\\mathbf{H}^{(t)})^{-1} \\nabla_{\\boldsymbol{\\beta}} \\log L(\\boldsymbol{\\beta}^{(t)})\n$$\n代入梯度和 Hessian 矩阵的表达式：\n$$\n\\boldsymbol{\\beta}^{(t+1)} = \\boldsymbol{\\beta}^{(t)} + (\\mathbf{X}^\\top \\mathbf{W}^{(t)} \\mathbf{X})^{-1} \\mathbf{X}^\\top (\\mathbf{y} - \\mathbf{p}^{(t)})\n$$\n此更新从一个初始猜测（例如 $\\boldsymbol{\\beta}^{(0)} = \\mathbf{0}$）开始迭代执行，直到 $\\log L$ 或 $\\boldsymbol{\\beta}$ 的变化量低于指定的容差。根据要求，矩阵逆 $(\\mathbf{X}^\\top \\mathbf{W} \\mathbf{X})^{-1}$ 被 Moore-Penrose 伪逆 $(\\mathbf{X}^\\top \\mathbf{W} \\mathbf{X})^{\\dagger}$ 替换，以确保数值稳定性。\n\n**3. 使用似然比检验（LRT）进行假设检验**\n\n我们通过比较两个嵌套模型来检验基因集成员资格的显著性：\n- 零模型 ($H_0$)，其中基因集成员资格对结果没有影响：$\\mathrm{logit}(p_i) = \\beta_0 + \\beta_{\\ell}\\tilde{\\ell}_i + \\beta_{g}\\tilde{g}_i$。设计矩阵为 $\\mathbf{X}_{\\text{red}} = [\\mathbf{1}, \\tilde{\\boldsymbol{\\ell}}, \\tilde{\\mathbf{g}}]$。\n- 完整模型 ($H_A$)，其中包含了基因集效应：$\\mathrm{logit}(p_i) = \\beta_0 + \\beta_{s}s_i + \\beta_{\\ell}\\tilde{\\ell}_i + \\beta_{g}\\tilde{g}_i$。设计矩阵为 $\\mathbf{X}_{\\text{full}} = [\\mathbf{1}, \\mathbf{s}, \\tilde{\\boldsymbol{\\ell}}, \\tilde{\\mathbf{g}}]$。\n\n我们拟合两个模型以获得它们的最大化对数似然，$\\log L_{\\text{reduced}}$ 和 $\\log L_{\\text{full}}$。似然比检验统计量是：\n$$\n\\Delta = 2 (\\log L_{\\text{full}} - \\log L_{\\text{reduced}})\n$$\n根据 Wilks 定理，在零假设 ($H_0$) 下，$\\Delta$ 渐近服从一个卡方分布，其自由度等于两个模型参数数量之差。这里，完整模型多了一个参数（$\\beta_s$），所以 $\\Delta \\sim \\chi^2_1$。$p$-值是观测到至少与 $\\Delta$ 一样极端的统计量的概率：\n$$\np = \\Pr(\\chi^2_1 \\ge \\Delta)\n$$\n\n**4. 效应大小与决策规则**\n\n从拟合的完整模型中得到的系数 $\\hat{\\beta}_s$ 是与基因集成员资格相关、并经过协变量校正的估计对数比值比。一个正的 $\\hat{\\beta}_s$ 意味着属于该基因集会增加结果为 $y_i=1$ 的几率。比值比（OR）计算如下：\n$$\n\\mathrm{OR} = \\exp(\\hat{\\beta}_s)\n$$\n大于 1 的 OR 表示富集。最终的决策规则结合了统计显著性和效应方向。一个基因集被宣布为富集，当且仅当其关联在统计上是显著的（$p \\le \\alpha$）且效应是正向的（$\\hat{\\beta}_s  0$）。给定的显著性水平为 $\\alpha = 0.05$。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Solves the covariate-adjusted Over-Representation Analysis problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"s\": np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n            \"y\": np.array([1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]),\n            \"ell\": np.array([1400, 1550, 1600, 1500, 1450, 1520, 1580, 1490, 1510, 1470, 1420, 1560, 1495, 1530, 1460, 1505, 1575, 1480, 1525, 1455]),\n            \"g\": np.array([0.48, 0.52, 0.50, 0.47, 0.49, 0.51, 0.53, 0.46, 0.50, 0.48, 0.47, 0.54, 0.49, 0.52, 0.46, 0.50, 0.55, 0.48, 0.51, 0.47]),\n        },\n        {\n            \"s\": np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1]),\n            \"y\": np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1]),\n            \"ell\": np.array([900, 950, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1750, 1800, 1850, 1900, 1950, 2000, 2050, 2100, 2150, 2200]),\n            \"g\": np.array([0.42, 0.43, 0.44, 0.45, 0.46, 0.47, 0.48, 0.49, 0.50, 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58, 0.59, 0.60, 0.61]),\n        },\n        {\n            \"s\": np.array([0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]),\n            \"y\": np.array([0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]),\n            \"ell\": np.array([1300, 1600, 1400, 1500, 1550, 1700, 1650, 1350, 1800, 1450, 1750, 1250, 1550, 1600, 1500, 1850, 1400, 1900, 1750, 1600]),\n            \"g\": np.array([0.50, 0.48, 0.52, 0.49, 0.47, 0.51, 0.46, 0.53, 0.55, 0.50, 0.49, 0.48, 0.47, 0.52, 0.51, 0.54, 0.46, 0.55, 0.50, 0.49]),\n        },\n        {\n            \"s\": np.array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]),\n            \"y\": np.array([1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0]),\n            \"ell\": np.array([1500, 1600, 1550, 1450, 1520, 1490, 1510, 1480, 1530, 1470, 1505, 1495, 1515, 1485, 1525, 1475, 1500, 1490, 1510, 1480]),\n            \"g\": np.array([0.50, 0.51, 0.49, 0.48, 0.52, 0.50, 0.49, 0.51, 0.50, 0.48, 0.52, 0.49, 0.50, 0.51, 0.49, 0.50, 0.51, 0.49, 0.50, 0.48]),\n        },\n    ]\n\n    results = []\n\n    def z_score(v):\n        \"\"\"Computes the z-score of a vector using population standard deviation.\"\"\"\n        return (v - np.mean(v)) / np.std(v, ddof=0)\n\n    def robust_log_likelihood(y, eta):\n        \"\"\"Numerically stable log-likelihood calculation for logistic regression.\"\"\"\n        # This implements logL = sum(y*eta - log(1+exp(eta)))\n        # log(1+exp(x)) can be calculated as x + log(1+exp(-x)) for large x\n        log1pexp = np.zeros_like(eta)\n        pos_mask = eta > 0\n        log1pexp[pos_mask] = eta[pos_mask] + np.log(1 + np.exp(-eta[pos_mask]))\n        log1pexp[~pos_mask] = np.log(1 + np.exp(eta[~pos_mask]))\n        return np.sum(y * eta - log1pexp)\n\n    def fit_logistic_model(X, y, tol=1e-9, max_iter=100):\n        \"\"\"\n        Fits a logistic regression model using Iteratively Reweighted Least Squares (IRLS).\n        Uses Moore-Penrose pseudoinverse for stability.\n        \"\"\"\n        n_samples, n_features = X.shape\n        beta = np.zeros(n_features)\n        \n        logL_old = -np.inf\n        for _ in range(max_iter):\n            eta = X @ beta\n            p = 1 / (1 + np.exp(-eta)) # Sigmoid function\n            \n            logL_new = robust_log_likelihood(y, eta)\n            \n            # Check for convergence based on log-likelihood improvement\n            if abs(logL_new - logL_old)  tol:\n                break\n            logL_old = logL_new\n            \n            # IRLS update\n            # Weights for the diagonal matrix W. Add a small epsilon for stability.\n            weights = p * (1 - p) + 1e-8\n            W = np.diag(weights)\n            \n            # Gradient of the log-likelihood\n            gradient = X.T @ (y - p)\n            \n            # Hessian of the log-likelihood\n            hessian = X.T @ W @ X\n            \n            # Newton-Raphson step using Moore-Penrose pseudoinverse\n            delta_beta = np.linalg.pinv(hessian) @ gradient\n            beta += delta_beta\n\n        final_logL = robust_log_likelihood(y, X @ beta)\n        return beta, final_logL\n\n    for case in test_cases:\n        s, y, ell, g = case[\"s\"], case[\"y\"], case[\"ell\"], case[\"g\"]\n        N = len(y)\n        intercept = np.ones(N)\n\n        # Standardize continuous covariates\n        ell_tilde = z_score(ell)\n        g_tilde = z_score(g)\n\n        # Define design matrices for reduced and full models\n        X_reduced = np.c_[intercept, ell_tilde, g_tilde]\n        X_full = np.c_[intercept, s, ell_tilde, g_tilde]\n\n        # Fit both models\n        beta_reduced, logL_reduced = fit_logistic_model(X_reduced, y)\n        beta_full, logL_full = fit_logistic_model(X_full, y)\n\n        # Likelihood-Ratio Test\n        delta_stat = 2 * (logL_full - logL_reduced)\n        # Handle cases where delta is negative due to numerical precision\n        delta_stat = max(0, delta_stat)\n        p_value = chi2.sf(delta_stat, df=1)\n\n        # Effect size and decision\n        beta_s = beta_full[1] # beta_s is the second coefficient in the full model\n        odds_ratio = np.exp(beta_s)\n        \n        alpha = 0.05\n        is_enriched = (p_value = alpha) and (beta_s > 0)\n        \n        results.append((p_value, odds_ratio, is_enriched))\n\n    # Format the final output string\n    formatted_results = []\n    for p, OR, enriched in results:\n        formatted_results.append(f\"[{p:.6f},{OR:.6f},{'True' if enriched else 'False'}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4371308"}]}