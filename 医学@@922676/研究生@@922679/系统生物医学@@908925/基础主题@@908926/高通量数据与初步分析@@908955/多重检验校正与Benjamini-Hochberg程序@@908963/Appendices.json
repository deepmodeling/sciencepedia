{"hands_on_practices": [{"introduction": "第一个练习提供了一个具体、分步的Benjamini-Hochberg (BH) 程序应用。通过手动处理一个来自假设性系统生物医学实验的小规模 $p$-值数据集，您将对该算法的运作机制获得基本理解，从对 $p$-值进行排序到确定最终的拒绝阈值。这项基础实践对于揭示 BH 程序在实践中如何控制错误发现率 (FDR) 至关重要 [@problem_id:4363527]。", "problem": "在一项关于细胞内信号网络扰动的系统生物医学研究中，您测量了 $m=10$ 个候选基因的信使核糖核酸（mRNA）丰度变化，这些基因被认为可以作为整合应激信号的中枢。对于每个基因，您都进行了一次原假设检验，以检验其在扰动条件下相对于对照组是否无变化，从而获得了以下 $p$ 值向量（按试验设计中使用的基因索引排序，而非按大小排序）：\n$$\n\\mathbf{p} = \\left(0.0009,\\ 0.003,\\ 0.021,\\ 0.055,\\ 0.13,\\ 0.24,\\ 0.0004,\\ 0.0085,\\ 0.041,\\ 0.72\\right).\n$$\n您的目标是使用 Benjamini–Hochberg 程序将错误发现率（FDR）控制在目标水平 $q=0.1$。从 FDR 的基本定义和 Benjamini–Hochberg 程序的典型步骤出发，为给定的 $p$ 值计算在水平 $q=0.1$ 下的 Benjamini–Hochberg 拒绝集。您的推导过程必须明确显示：\n- 按升序排列的 $p$ 值及其原始基因索引，\n- 每个秩次的阈值比较序列，\n- 确定递增（step-up）截断值的最大秩次 $k$ 的识别过程，\n- 映射回原始索引以说明最终拒绝集的过程。\n\n将最终拒绝集表示为按数值升序排列的原始基因索引列表。最终答案必须是一个计算结果，并应使用答案框内的 LaTeX $\\mathrm{pmatrix}$ 环境以单行矩阵的形式给出。无需四舍五入。", "solution": "该问题要求应用 Benjamini-Hochberg (BH) 程序来处理一组来自系统生物医学实验的 $p$ 值，以控制错误发现率（FDR）。\n\n首先，我们来建立基本定义。我们有 $m$ 个原假设检验，$H_1, H_2, \\ldots, H_m$，以及它们对应的 $p$ 值，$p_1, p_2, \\ldots, p_m$。我们将这 $m$ 次检验的结果总结在一个列联表中：\n\n|                  | 原假设为真 | 备择假设为真 | 总计      |\n|------------------|-------------------------|---------------------|-----------|\n| **未拒绝** | $U$ (真阴性)    | $T$ (假阴性) | $m-R$     |\n| **拒绝**     | $V$ (假阳性)   | $S$ (真阳性)  | $R$       |\n| **总计**        | $m_0$                   | $m - m_0$           | $m$       |\n\n在这里，$R$ 是被拒绝的假设总数，$V$ 是被错误拒绝的真实原假设的数量（I 型错误，或错误发现）。错误发现率定义为在所有发现中，错误发现比例的期望值：\n$$\n\\text{FDR} = E\\left[ \\frac{V}{R} \\middle| R > 0 \\right] P(R > 0)\n$$\nBenjamini-Hochberg 程序提供了一种控制 FDR 的方法，使得对于指定的目标水平 $q$，有 $\\text{FDR} \\le q$。\n\n本问题中给定的条件是：\n- 假设检验的总数（基因数）：$m = 10$。\n- $p$ 值向量，索引从 $1$ 到 $10$：\n$$\n\\mathbf{p} = \\left(0.0009,\\ 0.003,\\ 0.021,\\ 0.055,\\ 0.13,\\ 0.24,\\ 0.0004,\\ 0.0085,\\ 0.041,\\ 0.72\\right)\n$$\n- 目标 FDR 水平：$q = 0.1$。\n\nBenjamini-Hochberg 程序包括以下步骤：\n\n1.  **对 $p$ 值进行排序**：设 $p_{(1)} \\le p_{(2)} \\le \\ldots \\le p_{(m)}$ 是按升序排列的 $p$ 值。我们必须记录它们的原始索引。\n\n原始的 $p$ 值及其索引如下：\n- $p_1 = 0.0009$\n- $p_2 = 0.003$\n- $p_3 = 0.021$\n- $p_4 = 0.055$\n- $p_5 = 0.13$\n- $p_6 = 0.24$\n- $p_7 = 0.0004$\n- $p_8 = 0.0085$\n- $p_9 = 0.041$\n- $p_{10} = 0.72$\n\n将这些 $p$ 值按升序排列，我们得到排序后的列表及其原始基因索引：\n\n| 秩次 ($i$) | 原始索引 | 排序后的 $p$ 值 ($p_{(i)}$) |\n|------------|----------------|------------------------------|\n| $1$        | $7$            | $0.0004$                     |\n| $2$        | $1$            | $0.0009$                     |\n| $3$        | $2$            | $0.003$                      |\n| $4$        | $8$            | $0.0085$                     |\n| $5$        | $3$            | $0.021$                      |\n| $6$        | $9$            | $0.041$                      |\n| $7$        | $4$            | $0.055$                      |\n| $8$        | $5$            | $0.13$                       |\n| $9$        | $6$            | $0.24$                       |\n| $10$       | $10$           | $0.72$                       |\n\n2.  **寻找拒绝截断值**：我们找到满足以下条件的最大秩次 $k$：对应的 $p$ 值 $p_{(k)}$ 满足：\n$$\np_{(k)} \\le \\frac{k}{m}q\n$$\n对于我们的问题，$m=10$ 且 $q=0.1$，每个秩次 $i$ 的阈值为 $\\frac{i}{10}(0.1) = 0.01 \\times i$。我们现在对每个秩次 $i=1, \\ldots, 10$ 进行序列比较：\n\n- 对于 $i=1$：$p_{(1)} = 0.0004$。阈值：$\\frac{1}{10}(0.1) = 0.01$。比较：$0.0004 \\le 0.01$ (真)。\n- 对于 $i=2$：$p_{(2)} = 0.0009$。阈值：$\\frac{2}{10}(0.1) = 0.02$。比较：$0.0009 \\le 0.02$ (真)。\n- 对于 $i=3$：$p_{(3)} = 0.003$。阈值：$\\frac{3}{10}(0.1) = 0.03$。比较：$0.003 \\le 0.03$ (真)。\n- 对于 $i=4$：$p_{(4)} = 0.0085$。阈值：$\\frac{4}{10}(0.1) = 0.04$。比较：$0.0085 \\le 0.04$ (真)。\n- 对于 $i=5$：$p_{(5)} = 0.021$。阈值：$\\frac{5}{10}(0.1) = 0.05$。比较：$0.021 \\le 0.05$ (真)。\n- 对于 $i=6$：$p_{(6)} = 0.041$。阈值：$\\frac{6}{10}(0.1) = 0.06$。比较：$0.041 \\le 0.06$ (真)。\n- 对于 $i=7$：$p_{(7)} = 0.055$。阈值：$\\frac{7}{10}(0.1) = 0.07$。比较：$0.055 \\le 0.07$ (真)。\n- 对于 $i=8$：$p_{(8)} = 0.13$。阈值：$\\frac{8}{10}(0.1) = 0.08$。比较：$0.13 \\le 0.08$ (假)。\n- 对于 $i=9$：$p_{(9)} = 0.24$。阈值：$\\frac{9}{10}(0.1) = 0.09$。比较：$0.24 \\le 0.09$ (假)。\n- 对于 $i=10$：$p_{(10)} = 0.72$。阈值：$\\frac{10}{10}(0.1) = 0.1$。比较：$0.72 \\le 0.1$ (假)。\n\n满足条件 $p_{(k)} \\le \\frac{k}{m}q$ 的最大秩次 $k$ 是 $k=7$。\n\n3.  **确定拒绝集**：BH 程序拒绝所有对于 $i=1, \\ldots, k$ 的原假设 $H_{(i)}$。这意味着我们拒绝对应于 $k=7$ 个最小 $p$ 值的原假设。要被宣布为显著的 $p$ 值是 $p_{(1)}, p_{(2)}, p_{(3)}, p_{(4)}, p_{(5)}, p_{(6)}$ 和 $p_{(7)}$。\n\n4.  **映射回原始索引**：我们现在从步骤 1 的表格中，找出与这 7 个显著 $p$ 值相对应的原始基因索引。\n- $p_{(1)}$ 对应于原始索引 $7$。\n- $p_{(2)}$ 对应于原始索引 $1$。\n- $p_{(3)}$ 对应于原始索引 $2$。\n- $p_{(4)}$ 对应于原始索引 $8$。\n- $p_{(5)}$ 对应于原始索引 $3$。\n- $p_{(6)}$ 对应于原始索引 $9$。\n- $p_{(7)}$ 对应于原始索引 $4$。\n\n以原始基因索引表示的拒绝集是 $\\{1, 2, 3, 4, 7, 8, 9\\}$。问题要求将此集合表示为按数值升序排列的索引列表。对这些索引进行排序即可得到最终结果。", "answer": "$$\\boxed{\\begin{pmatrix} 1  2  3  4  7  8  9 \\end{pmatrix}}$$", "id": "4363527"}, {"introduction": "虽然 BH 程序非常强大，但其理论保证依赖于检验是独立的或具有特定的“正”相关结构。本练习探讨了一个关键问题：当这些假设可能不成立时会发生什么？您将对同一数据集同时应用标准的 Benjamini-Hochberg (BH) 程序和更为保守的 Benjamini-Yekutieli (BY) 程序——后者在任意相关性下都能控制 FDR。这将使您能够直接比较它们的结果，并理解在统计功效和方法对数据底层相关性的稳健性之间的关键权衡 [@problem_id:4363605]。", "problem": "一项系统生物医学研究评估了在两个患者队列中测量的 $m=20$ 种血浆蛋白的差异丰度。对每种蛋白质进行一次假设检验，并得到一个 $p$ 值。研究者试图使用 Benjamini–Hochberg (BH) 和 Benjamini–Yekutieli (BY) 两种程序，在 $q=0.05$ 的水平上控制错误发现率 (FDR)。其中，BY 程序旨在检验统计量之间存在任意依赖关系的情况下有效，而 BH 程序在独立性或某些正相关结构下有效。\n\n给你未排序的 $p$ 值向量（每种蛋白质一个）：\n$$\n\\{\\,0.04000,\\;0.01410,\\;0.00030,\\;0.05500,\\;0.01270,\\;0.00150,\\;0.04900,\\;0.00012,\\;0.01900,\\;0.03200,\\;0.00620,\\;0.08000,\\;0.00210,\\;0.01050,\\;0.00410,\\;0.00090,\\;0.02500,\\;0.00840,\\;0.00320,\\;0.04400\\,\\}.\n$$\n\n从错误发现率的核心定义以及升阶程序对升序排列的 $p$ 值进行操作的原理出发，确定对于 $m=20$ 个检验，Benjamini–Hochberg (BH) 程序在 $q=0.05$ 水平下和 Benjamini–Yekutieli (BY) 程序在 $q=0.05$ 水平下所产生的拒绝集。然后通过计算拒绝数量的差异来比较这些集合，该差异定义为\n$$\nR_{\\mathrm{BH}} - R_{\\mathrm{BY}},\n$$\n其中 $R_{\\mathrm{BH}}$ 是 BH 程序拒绝的假设数量，$R_{\\mathrm{BY}}$ 是 BY 程序拒绝的假设数量。\n\n请将此差异报告为单个整数。无需四舍五入。", "solution": "用户提供了一个有效的问题陈述。任务是应用两种不同的多重检验校正程序，即 Benjamini-Hochberg (BH) 程序和 Benjamini-Yekutieli (BY) 程序，到一组给定的 $p$ 值上，并确定被拒绝假设数量的差异。\n\n该问题涉及 $m=20$ 次假设检验，目标是在 $q=0.05$ 的水平上控制错误发现率 (FDR)。提供的未排序 $p$ 值为：\n$$\nP = \\{\\,0.04000,\\;0.01410,\\;0.00030,\\;0.05500,\\;0.01270,\\;0.00150,\\;0.04900,\\;0.00012,\\;0.01900,\\;0.03200,\\;0.00620,\\;0.08000,\\;0.00210,\\;0.01050,\\;0.00410,\\;0.00090,\\;0.02500,\\;0.00840,\\;0.00320,\\;0.04400\\,\\}.\n$$\n\nBH 和 BY 程序都是升阶程序，这意味着它们对按升序排列的 $p$ 值进行操作。设排序后的 $p$ 值表示为 $p_{(1)}, p_{(2)}, \\dots, p_{(m)}$。\n\n首先，我们对提供的 $p$ 值进行排序：\n$p_{(1)} = 0.00012$\n$p_{(2)} = 0.00030$\n$p_{(3)} = 0.00090$\n$p_{(4)} = 0.00150$\n$p_{(5)} = 0.00210$\n$p_{(6)} = 0.00320$\n$p_{(7)} = 0.00410$\n$p_{(8)} = 0.00620$\n$p_{(9)} = 0.00840$\n$p_{(10)} = 0.01050$\n$p_{(11)} = 0.01270$\n$p_{(12)} = 0.01410$\n$p_{(13)} = 0.01900$\n$p_{(14)} = 0.02500$\n$p_{(15)} = 0.03200$\n$p_{(16)} = 0.04000$\n$p_{(17)} = 0.04400$\n$p_{(18)} = 0.04900$\n$p_{(19)} = 0.05500$\n$p_{(20)} = 0.08000$\n\n现在，我们将应用每个程序。\n\n**Benjamini–Hochberg (BH) 程序**\nBH 程序寻找最大的整数 $k$，使得对应的已排序 $p$ 值 $p_{(k)}$ 满足以下条件：\n$$\np_{(k)} \\le \\frac{k}{m}q\n$$\n如果存在这样的 $k$，则拒绝所有对应于 $p_{(1)}, \\dots, p_{(k)}$ 的原假设。被拒绝的假设数量为 $R_{\\mathrm{BH}} = k$。\n\n给定 $m=20$ 和 $q=0.05$，第 $i$ 个排序后的 $p$ 值的 BH 阈值为：\n$$\n\\frac{i}{20} \\times 0.05 = i \\times 0.0025\n$$\n我们必须找到满足 $p_{(k)} \\le k \\times 0.0025$ 的最大索引 $k$。我们从最大的索引开始向下检查排序后的 $p$ 值，或者系统地检查每一个。让我们检查在分析过程中确定的边界情况。\n\n对于 $i=16$：\n$p_{(16)} = 0.04000$。\nBH 阈值为 $\\frac{16}{20} \\times 0.05 = 0.8 \\times 0.05 = 0.04$。\n条件是 $0.04000 \\le 0.04$，该条件成立。\n\n对于 $i=17$：\n$p_{(17)} = 0.04400$。\nBH 阈值为 $\\frac{17}{20} \\times 0.05 = 0.85 \\times 0.05 = 0.0425$。\n条件是 $0.04400 \\le 0.0425$，该条件不成立。\n\n由于该条件对 $k=16$ 成立而对 $k=17$ 不成立，因此满足该不等式的最大索引是 $k=16$。所以，BH 程序拒绝了 16 个假设。\n$$\nR_{\\mathrm{BH}} = 16\n$$\n\n**Benjamini–Yekutieli (BY) 程序**\nBY 程序是一种更保守的方法，它在任意依赖假设下控制 FDR。它寻找最大的整数 $k$，使得：\n$$\np_{(k)} \\le \\frac{k}{m \\cdot C(m)}q\n$$\n其中 $C(m)$ 是从 1 到 $m$ 的整数倒数之和，也称为第 $m$ 个调和数 $H_m$。\n$$\nC(m) = \\sum_{i=1}^{m} \\frac{1}{i}\n$$\n对于 $m=20$，我们必须首先计算 $C(20)$：\n$$\nC(20) = H_{20} = \\sum_{i=1}^{20} \\frac{1}{i} = 1 + \\frac{1}{2} + \\frac{1}{3} + \\dots + \\frac{1}{20}\n$$\n对这个和进行数值计算得出：\n$$\nC(20) \\approx 3.597739657\n$$\n第 $i$ 个排序后的 $p$ 值的 BY 阈值为：\n$$\n\\frac{i}{20 \\cdot C(20)} \\times 0.05 \\approx \\frac{i \\times 0.0025}{3.59774}\n$$\n我们必须找到满足 $p_{(k)} \\le \\frac{k \\times 0.0025}{C(20)}$ 的最大索引 $k$。让我们检查预期临界值附近的 p 值。\n\n对于 $i=7$：\n$p_{(7)} = 0.00410$。\nBY 阈值为 $\\frac{7}{20 \\cdot C(20)} \\times 0.05 \\approx \\frac{7 \\times 0.05}{20 \\times 3.59774} \\approx \\frac{0.35}{71.9548} \\approx 0.004864$。\n条件是 $0.00410 \\le 0.004864$，该条件成立。\n\n对于 $i=8$：\n$p_{(8)} = 0.00620$。\nBY 阈值为 $\\frac{8}{20 \\cdot C(20)} \\times 0.05 \\approx \\frac{8 \\times 0.05}{20 \\times 3.59774} \\approx \\frac{0.40}{71.9548} \\approx 0.005559$。\n条件是 $0.00620 \\le 0.005559$，该条件不成立。\n\n满足 BY 条件的最大索引是 $k=7$。因此，BY 程序拒绝了 7 个假设。\n$$\nR_{\\mathrm{BY}} = 7\n$$\n\n**拒绝数量的差异**\n问题要求计算差异 $R_{\\mathrm{BH}} - R_{\\mathrm{BY}}$。\n$$\nR_{\\mathrm{BH}} - R_{\\mathrm{BY}} = 16 - 7 = 9\n$$\nBenjamini-Hochberg 和 Benjamini-Yekutieli 程序在拒绝数量上的差异是 $9$。", "answer": "$$\\boxed{9}$$", "id": "4363605"}, {"introduction": "超越手动计算，这个高级实践将让您沉浸在一个真实的计算系统生物医学工作流程中。您将通过编程实现一个模拟，不仅应用 Benjamini-Hochberg (BH) 程序，还要从第一性原理出发评估其性能 [@problem_id:4363508]。通过生成具有已知“基准真相”(ground truth)的数据，并计算实际的错误发现比例 (FDP) 和统计功效 (power)，您将对该程序在不同条件下的行为（例如不同的效应大小和检验间的相关性）建立更深刻的直觉。", "problem": "您的任务是为系统生物医学中一个模拟的多端点成簇规律间隔短回文重复序列（CRISPR）扰动数据集，实施一个原则性的多重检验校正计划。该计划包括：在双条件设计（扰动与对照）下生成真实的端点测量值，计算端点水平的假设检验 p 值，应用 Benjamini-Hochberg (BH) 程序来控制错误发现率 (FDR)，并报告实际的错误发现比例 (FDP) 和统计功效。\n\n使用的基础理论：\n- 假设每个端点测量值都来自一个带有加性噪声的测量过程，该过程可由高斯分布充分建模，这与中心极限定理 (CLT) 一致。具体来说，对于每个基因扰动和端点，对照组和处理组中的重复样本被建模为来自多元正态分布的样本，这些分布在所有端点上共享一个协方差，以反映相关的端点噪声和生物耦合。设每个端点的噪声方差为 $\\sigma^2$，跨端点的等相关性为 $\\rho$，因此协方差矩阵为 $ \\Sigma = \\sigma^2\\big((1-\\rho) I_M + \\rho \\mathbf{1}\\mathbf{1}^\\top\\big) $，其中 $I_M$ 是 $M \\times M$ 的单位矩阵，$\\mathbf{1}$ 是长度为 $M$ 的全一向量。\n- 一部分假设为非原假设，并在处理组中相对于对照组表现出均值偏移 $\\delta$。该偏移被施加到那些被指定为确实受到扰动影响的假设的端点上。\n- 对于每个端点水平的假设（基因-端点对），在处理组和对照组的重复样本之间执行独立的双样本比较以获得 p 值。在原假设下，并满足适当的正则性条件时，p 值在 $[0,1]$ 上随机地接近均匀分布，这是进行有效多重检验控制的基础。\n- Benjamini-Hochberg (BH) 程序是一种递升方法，它根据 p 值的排序和目标水平 $ \\alpha \\in (0,1) $ 来确定要拒绝哪些假设。您必须从第一性原理出发实现此程序。\n\n需要报告的定义：\n- 实际错误发现比例 (FDP) 为 $ \\mathrm{FDP} = \\frac{V}{\\max(R,1)} $，其中 $R$ 是拒绝的总数，$V$ 是被错误拒绝的原假设的数量。\n- 统计功效是正确拒绝的真实非原假设的比例，即 $ \\mathrm{power} = \\frac{\\mathrm{TP}}{S} $，其中 $ \\mathrm{TP} $ 是真阳性的数量，$ S $ 是真实非原假设的总数。如果 $ S = 0 $，则将功效定义为 $ 0 $。\n\n模拟设置：\n- 共有 $ N $ 个基因（扰动），每个基因测量 $ M $ 个端点。对于每个基因，您将在对照组和处理组中各模拟 $ n $ 个重复样本。处理组中，对被指定为真实非原假设的端点子集施加均值偏移 $ \\delta $。端点噪声的方差为 $ \\sigma^2 $，跨端点的等相关性为 $ \\rho $，由上述协方差矩阵 $ \\Sigma $ 编码。在所有 $ N \\times M $ 个基因-端点对中，非原假设的比例为 $ \\pi_1 $；在给定 $ \\pi_1 $ 和一个固定的随机种子的条件下，均匀随机地选择非原假设，以确保可复现性。设目标 FDR 水平为 $ \\alpha $。\n\n任务：\n1. 使用指定的协方差 $ \\Sigma $，通过多元正态抽样为每个重复样本生成对照组和处理组的测量值。在端点水平上，为指定的非原假设对应的处理组重复样本施加均值偏移 $ \\delta $。\n2. 对于每个端点水平的假设，使用在高斯假设下有效的双样本检验，计算处理组与对照组比较的 p 值。\n3. 实现 BH 程序，使用排序后的 p 值在水平 $ \\alpha $ 上确定被拒绝的假设。\n4. 使用非原假设的真实标签，计算上文定义的实际 $ \\mathrm{FDP} $ 和功效。\n\n单位和输出要求：\n- 没有物理单位；结果必须是无单位的实数。\n- 将 $ \\mathrm{FDP} $ 和功效表示为 $ [0,1] $ 区间内的小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是一个列表 $ [\\mathrm{FDP}, \\mathrm{power}] $。例如，$ [[0.0,0.75],[0.1,0.5]] $。\n\n测试套件：\n为以下参数集实现上述过程。每个测试用例是一个元组 $ (N, M, n, \\pi_1, \\delta, \\sigma, \\rho, \\alpha, \\mathrm{seed}) $。\n\n- 用例 A（基线，独立端点）：\n  - $ N = 40 $, $ M = 5 $, $ n = 6 $, $ \\pi_1 = 0.15 $, $ \\delta = 1.0 $, $ \\sigma = 1.0 $, $ \\rho = 0.0 $, $ \\alpha = 0.05 $, $ \\mathrm{seed} = 123 $。\n- 用例 B（全为原假设，独立性，较宽松的水平）：\n  - $ N = 50 $, $ M = 10 $, $ n = 4 $, $ \\pi_1 = 0.0 $, $ \\delta = 0.0 $, $ \\sigma = 1.0 $, $ \\rho = 0.0 $, $ \\alpha = 0.10 $, $ \\mathrm{seed} = 456 $。\n- 用例 C（正相关端点，中等效应）：\n  - $ N = 30 $, $ M = 8 $, $ n = 5 $, $ \\pi_1 = 0.20 $, $ \\delta = 0.8 $, $ \\sigma = 1.0 $, $ \\rho = 0.5 $, $ \\alpha = 0.05 $, $ \\mathrm{seed} = 789 $。\n- 用例 D（稀疏强效应，弱相关性，少量重复样本）：\n  - $ N = 100 $, $ M = 3 $, $ n = 3 $, $ \\pi_1 = 0.05 $, $ \\delta = 1.5 $, $ \\sigma = 1.0 $, $ \\rho = 0.2 $, $ \\alpha = 0.05 $, $ \\mathrm{seed} = 321 $。\n\n答案规范：\n- 对于每个用例，输出列表 $ [\\mathrm{FDP}, \\mathrm{power}] $。\n- 将所有四个用例的结果按 A、B、C、D 的顺序汇总到一个列表中。\n- 您的程序应精确地生成一行：$ [[\\mathrm{FDP}_A,\\mathrm{power}_A],[\\mathrm{FDP}_B,\\mathrm{power}_B],[\\mathrm{FDP}_C,\\mathrm{power}_C],[\\mathrm{FDP}_D,\\mathrm{power}_D]] $。", "solution": "问题陈述经过了严格验证，并被确定为 **有效**。它具有科学依据，定义明确，客观且自洽。该问题在系统生物医学和计算统计学领域内提供了一个清晰、可形式化的任务，包含了所有必要的参数和定义，以得到一个唯一的、可复现的解决方案。模拟框架基于标准统计模型和程序，例如用于数据生成的多元正态分布、用于假设检验的双样本 Z 检验，以及用于多重检验校正的 Benjamini-Hochberg 程序。\n\n以下是该问题的原则性、分步解决方案。\n\n**1. 模拟设置和真实情况生成**\n\n对于每个测试用例，我们都给定一组参数：$N$ 个基因，每个基因 $M$ 个端点，每个实验组 $n$ 个重复样本，非原假设比例 $\\pi_1$，平均效应大小 $\\delta$，噪声标准差 $\\sigma$，端点相关性 $\\rho$，目标错误发现率 (FDR) $\\alpha$，以及一个随机种子。\n\n被检验的假设总数为 $m = N \\times M$。真实非原假设的数量 $S$ 由 $S = \\lfloor m \\times \\pi_1 \\rfloor$ 确定。通过随机选择 $S$ 个假设为非原假设，建立一个真实情况向量（表示为长度为 $m$ 的布尔数组）。该选择过程使用由指定种子初始化的随机数生成器执行，以确保可复现性。\n\n$N$ 个基因中的每一个的数据都是独立模拟的。对于一个给定的基因，其 $M$ 个端点是相关的。测量噪声使用一个多元正态分布进行建模，该分布具有一个共享的 $M \\times M$ 协方差矩阵 $\\Sigma$。该矩阵由每个端点的方差 $\\sigma^2$ 和等相关系数 $\\rho$ 定义：\n$$ \\Sigma = \\sigma^2\\big((1-\\rho) I_M + \\rho \\mathbf{1}\\mathbf{1}^\\top\\big) $$\n其中 $I_M$ 是 $M \\times M$ 的单位矩阵，$\\mathbf{1}$ 是长度为 $M$ 的全一向量。\n\n对于 $N$ 个基因中的每一个，我们为对照组定义一个均值向量 $\\boldsymbol{\\mu}_C$，为处理组定义一个均值向量 $\\boldsymbol{\\mu}_T$。对照组的均值向量是长度为 $M$ 的零向量，$\\boldsymbol{\\mu}_C = \\mathbf{0}$。处理组的均值向量 $\\boldsymbol{\\mu}_T$ 也是一个零向量，除非该基因的某个端点对应于一个非原假设，在这种情况下，其均值会偏移 $\\delta$。\n\n最后，对于每个基因，我们从 $\\mathcal{N}(\\boldsymbol{\\mu}_C, \\Sigma)$ 中独立抽取 $n$ 个重复数据向量作为对照组，并从 $\\mathcal{N}(\\boldsymbol{\\mu}_T, \\Sigma)$ 中独立抽取 $n$ 个重复数据向量作为处理组。\n\n**2. 端点水平的假设检验**\n\n对于 $m = N \\times M$ 个基因-端点对中的每一个，我们执行双样本统计检验以获得 p 值。每个检验的原假设是处理组和对照组之间的均值没有差异，即 $H_0: \\mu_{T,j} - \\mu_{C,j} = 0$，其中 $j$ 为特定端点的索引。\n\n由于数据是从正态分布生成的，并且总体方差 $\\sigma^2$ 从模拟参数中已知，因此最有效和最合适的统计检验是双样本 Z 检验。每个假设的检验统计量计算如下：\n$$ Z = \\frac{\\bar{x}_T - \\bar{x}_C}{\\sqrt{\\frac{\\sigma^2}{n} + \\frac{\\sigma^2}{n}}} = \\frac{\\bar{x}_T - \\bar{x}_C}{\\sqrt{\\frac{2\\sigma^2}{n}}} $$\n其中 $\\bar{x}_T$ 和 $\\bar{x}_C$ 分别是处理组和对照组 $n$ 个重复样本的样本均值。\n\n然后从标准正态分布计算双尾 p 值。如果 $\\Phi(z)$ 是标准正态分布的累积分布函数 (CDF)，则 p 值由 $p = 2 \\times (1 - \\Phi(|Z|))$ 给出，这等价于 $p = 2 \\times \\Phi(-|Z|)$。\n\n**3. 使用 Benjamini-Hochberg (BH) 程序进行多重检验校正**\n\n计算出每个假设对应的 $m$ 个 p 值后，我们应用 Benjamini-Hochberg 程序将 FDR 控制在指定的水平 $\\alpha$。BH 程序的实现如下：\n1.  设 $m$ 个 p 值为 $p_1, p_2, \\ldots, p_m$。\n2.  将这些 p 值按升序排序：$p_{(1)} \\le p_{(2)} \\le \\ldots \\le p_{(m)}$。设 $H_{(i)}$ 是与 p 值 $p_{(i)}$ 对应的原假设。\n3.  找到最大的整数 $k$，使其对应的排序后 p 值满足条件：\n    $$ p_{(k)} \\le \\frac{k}{m}\\alpha $$\n4.  如果存在这样的 $k$，则拒绝所有原假设 $H_{(1)}, H_{(2)}, \\ldots, H_{(k)}$。\n5.  如果不存在这样的 $k$（即，对于任何 $k \\ge 1$ 都不满足该条件），则不拒绝任何假设。\n\n被拒绝的假设集合构成了“发现”。\n\n**4. 性能指标计算**\n\n为评估该程序的性能，我们将被拒绝的假设集合与第一步中建立的真实情况进行比较。我们计算以下量：\n-   $R$：被拒绝的假设总数（总发现数）。\n-   $V$：被拒绝的假设中实际为原假设的数量（错误发现或 I 型错误）。\n-   $S$：真实非原假设的总数（总阳性数）。\n-   $\\mathrm{TP}$：被拒绝的假设中实际为非原假设的数量（真阳性）。\n\n使用这些值，我们计算两个所需的性能指标：\n-   **错误发现比例 (FDP)**：在所有发现中错误发现的比例。其定义为：\n    $$ \\mathrm{FDP} = \\frac{V}{\\max(R, 1)} $$\n    当没有假设被拒绝时，分母设置为 $\\max(R, 1)$ 以避免除以零。\n-   **统计功效**：被正确拒绝的真实非原假设的比例（也称为真阳性率或灵敏度）。其定义为：\n    $$ \\mathrm{power} = \\frac{\\mathrm{TP}}{S} $$\n    根据规定，如果 $S=0$（即没有真实的非原假设），则功效定义为 $0$。\n\n对问题中指定的四个测试用例中的每一个执行整个流程，为每个用例生成一对值 $[\\mathrm{FDP}, \\mathrm{power}]$。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef process_case(N, M, n, pi_1, delta, sigma, rho, alpha, seed):\n    \"\"\"\n    Runs the full simulation and analysis pipeline for a single test case.\n\n    Args:\n        N (int): Number of genes.\n        M (int): Number of endpoints.\n        n (int): Number of replicates per group.\n        pi_1 (float): Fraction of non-null hypotheses.\n        delta (float): Mean shift for non-nulls.\n        sigma (float): Standard deviation of endpoint noise.\n        rho (float): Equicorrelation across endpoints.\n        alpha (float): Target False Discovery Rate.\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        list: A list containing the calculated [FDP, power].\n    \"\"\"\n    # Use a dedicated random number generator for this case\n    rng = np.random.default_rng(seed)\n\n    # 1. Simulation Setup and Ground Truth Generation\n    total_hypotheses = N * M\n    S = int(total_hypotheses * pi_1)  # Total number of truly non-null hypotheses\n\n    # Establish ground truth: which hypotheses are non-null\n    is_truly_non_null = np.zeros(total_hypotheses, dtype=bool)\n    if S > 0:\n        true_indices = rng.choice(total_hypotheses, size=S, replace=False)\n        is_truly_non_null[true_indices] = True\n    \n    is_truly_non_null_matrix = is_truly_non_null.reshape((N, M))\n\n    # Construct means and covariance matrix\n    mu_control_base = np.zeros(M)\n    mu_treated_all_genes = np.zeros((N, M))\n    mu_treated_all_genes[is_truly_non_null_matrix] = delta\n\n    I_M = np.identity(M)\n    J_M = np.ones((M, M))\n    cov_matrix = sigma**2 * ((1 - rho) * I_M + rho * J_M)\n\n    p_values = []\n\n    # 2. Data Generation and Hypothesis Testing (gene by gene)\n    for i in range(N):\n        # Generate data for one gene\n        mu_treated_i = mu_treated_all_genes[i, :]\n        control_reps = rng.multivariate_normal(mu_control_base, cov_matrix, size=n)\n        treated_reps = rng.multivariate_normal(mu_treated_i, cov_matrix, size=n)\n\n        # Compute p-values for each endpoint of the current gene\n        for j in range(M):\n            control_samples = control_reps[:, j]\n            treated_samples = treated_reps[:, j]\n\n            # Perform two-sample Z-test (since sigma is known)\n            mean_diff = np.mean(treated_samples) - np.mean(control_samples)\n            std_err_diff = np.sqrt(2 * sigma**2 / n)\n            z_score = mean_diff / std_err_diff\n            \n            # Two-tailed p-value\n            p_val = 2 * norm.sf(np.abs(z_score))\n            p_values.append(p_val)\n\n    p_values = np.array(p_values)\n\n    # 3. Benjamini-Hochberg Procedure\n    m = len(p_values)\n    is_rejected = np.zeros(m, dtype=bool)\n    \n    if m > 0:\n        # Sort p-values while keeping track of their original indices\n        sorted_indices = np.argsort(p_values)\n        sorted_p_values = p_values[sorted_indices]\n\n        # Calculate BH thresholds\n        bh_thresholds = (np.arange(1, m + 1) / m) * alpha\n        \n        # Find p-values that are under the BH threshold line\n        is_significant = sorted_p_values = bh_thresholds\n\n        if np.any(is_significant):\n            # Find the largest k such that p_(k) = (k/m)*alpha\n            k_idx = np.where(is_significant)[0].max()\n            \n            # Reject all hypotheses up to k\n            rejected_original_indices = sorted_indices[:k_idx + 1]\n            is_rejected[rejected_original_indices] = True\n\n    # 4. Performance Metrics Calculation\n    R = np.sum(is_rejected)  # Total number of rejections\n    V = np.sum(is_rejected  ~is_truly_non_null)  # False positives\n    TP = np.sum(is_rejected  is_truly_non_null)  # True positives\n\n    # FDP\n    fdp = V / max(R, 1)\n\n    # Power\n    power = TP / S if S > 0 else 0.0\n\n    return [fdp, power]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement\n    test_cases = [\n        # (N, M, n, pi_1, delta, sigma, rho, alpha, seed)\n        (40, 5, 6, 0.15, 1.0, 1.0, 0.0, 0.05, 123),  # Case A\n        (50, 10, 4, 0.0, 0.0, 1.0, 0.0, 0.10, 456),  # Case B\n        (30, 8, 5, 0.20, 0.8, 1.0, 0.5, 0.05, 789),  # Case C\n        (100, 3, 3, 0.05, 1.5, 1.0, 0.2, 0.05, 321), # Case D\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result_pair = process_case(*case_params)\n        # Round for consistent output, though not strictly required\n        # For this problem, float precision should be fine.\n        results.append(result_pair)\n\n    # Construct the final output string in the exact required format\n    inner_parts = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(inner_parts)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "4363508"}]}