{"hands_on_practices": [{"introduction": "生理控制系统力求精确，但现实世界中的组件并非完美。本练习将探讨一个常见的缺陷——恒定的传感器偏置——如何影响一个包含积分控制的体温调节系统。通过解析推导稳态温度偏差，您将更深入地理解反馈回路如何处理持续的扰动，以及其校正能力的局限性。[@problem_id:4352199]", "problem": "一个核心体温調節回路被建模为一个单输入单输出的负反馈系统。被控变量是核心温度相对于一个固定环境基线的偏差 $y(t)$。效应器输入 $u(t)$ 代表净新陈代谢产热率。对象动态特性遵循能量平衡，其有效热容为 $C_{\\mathrm{th}}$，热损失热导为 $G_{\\mathrm{th}}$：\n$$\nC_{\\mathrm{th}} \\frac{dy(t)}{dt} \\;=\\; u(t) \\;-\\; G_{\\mathrm{th}}\\, y(t),\n$$\n因此，在初始条件为零的情况下进行拉普拉斯变换，从 $u$到 $y$ 的对象传递函数为\n$$\nP(s) \\;=\\; \\frac{Y(s)}{U(s)} \\;=\\; \\frac{1}{C_{\\mathrm{th}} s + G_{\\mathrm{th}}}.\n$$\n下丘脑传感器读数 $y_{m}(t)$ 是真实温度偏差的一个仿射映射，其乘法增益为 $k_{s}$，加性恒定偏置为 $b$：\n$$\ny_{m}(t) \\;=\\; k_{s}\\, y(t) \\;+\\; b,\n$$\n其中 $b$ 不随时间变化。神经控制器实现比例-积分作用，\n$$\nC(s) \\;=\\; K_{p} \\;+\\; \\frac{K_{i}}{s},\n$$\n并根据误差 $e(t) = r(t) - y_{m}(t)$ 计算出 $u(t)$ 来驱动效应器，其中 $r(t)$ 是内部设定点参考值，其选择方式为 $r(t) \\equiv k_{s}\\, y^{\\star}$（恒定值），以对应期望的真实稳态温度 $y^{\\star}$。\n\n假设系统在线性区运行，无饱和现象，且环境条件恒定。取以下生理上合理的参数值：$C_{\\mathrm{th}} = 3.5 \\times 10^{5}\\ \\mathrm{J/K}$，$G_{\\mathrm{th}} = 40\\ \\mathrm{W/K}$，$K_{p} = 40\\ \\mathrm{W/K}$，$K_{i} = 200\\ \\mathrm{W/(K \\cdot s)}$，$k_{s} = 0.8$（无量纲），以及恒定的下丘脑偏置 $b = 0.3\\ \\mathrm{K}$。\n\n从能量平衡和反馈误差的定义出发，根据第一性原理推导，在给定的比例-积分控制器下，由传感器偏置 $b$ 引起的真实核心温度与其期望值之间的稳态偏差 $y_{\\mathrm{ss}} - y^{\\star}$。然后，使用给定的参数数值计算这个偏差。以开尔文（Kelvin）为单位表示最终数值答案，并将答案四舍五入到四位有效数字。", "solution": "能量平衡提供了对象模型。将 $y(t)$ 定义为核心温度相对于固定环境基线的偏差，则能量平衡\n$$\nC_{\\mathrm{th}} \\frac{dy(t)}{dt} \\;=\\; u(t) \\;-\\; G_{\\mathrm{th}}\\, y(t)\n$$\n意味着，在初始条件为零的情况下进行拉普拉斯变换，\n$$\nY(s) \\left(C_{\\mathrm{th}} s + G_{\\mathrm{th}}\\right) \\;=\\; U(s),\n$$\n因此\n$$\nP(s) \\;=\\; \\frac{Y(s)}{U(s)} \\;=\\; \\frac{1}{C_{\\mathrm{th}} s + G_{\\mathrm{th}}}.\n$$\n\n传感器产生\n$$\ny_{m}(t) \\;=\\; k_{s}\\, y(t) \\;+\\; b,\n$$\n控制器使用的误差是\n$$\ne(t) \\;=\\; r(t) \\;-\\; y_{m}(t) \\;=\\; r(t) \\;-\\; k_{s}\\, y(t) \\;-\\; b,\n$$\n其中 $r(t) \\equiv k_{s}\\, y^{\\star}$（恒定值）。控制器是比例-积分型的：\n$$\nC(s) \\;=\\; K_{p} \\;+\\; \\frac{K_{i}}{s},\n$$\n拉普拉斯域中的控制律是\n$$\nU(s) \\;=\\; C(s)\\, E(s) \\;=\\; C(s)\\, \\left(R(s) \\;-\\; k_{s} Y(s) \\;-\\; B(s)\\right),\n$$\n其中 $R(s)$ 和 $B(s)$ 分别是 $r(t)$ 和 $b(t)$ 的拉普拉斯变换。代入对象方程中，\n$$\nY(s) \\;=\\; P(s)\\, U(s) \\;=\\; P(s)\\, C(s)\\, \\left(R(s) \\;-\\; k_{s} Y(s) \\;-\\; B(s)\\right).\n$$\n合并 $Y(s)$ 的项，得到\n$$\nY(s)\\, \\left(1 \\;+\\; P(s)\\, C(s)\\, k_{s}\\right) \\;=\\; P(s)\\, C(s)\\, R(s) \\;-\\; P(s)\\, C(s)\\, B(s),\n$$\n因此\n$$\nY(s) \\;=\\; \\frac{P(s)\\, C(s)}{1 \\;+\\; P(s)\\, C(s)\\, k_{s}}\\, R(s) \\;-\\; \\frac{P(s)\\, C(s)}{1 \\;+\\; P(s)\\, C(s)\\, k_{s}}\\, B(s).\n$$\n\n我们关心的是在恒定参考值和恒定传感器偏置下，真实温度与其期望值之间的稳态偏差 $y_{\\mathrm{ss}} - y^{\\star}$。因为 $r(t)$ 和 $b(t)$ 是常数，它们的拉普拉斯变换为\n$$\nR(s) \\;=\\; \\frac{k_{s}\\, y^{\\star}}{s}, \\qquad B(s) \\;=\\; \\frac{b}{s}.\n$$\n对于比例-积分控制器 $C(s) = K_{p} + K_{i}/s$，积分项的存在意味着闭环在 $s=0$ 处具有无限增益，即\n$$\n\\lim_{s \\to 0} P(s)\\, C(s) \\;=\\; \\lim_{s \\to 0} \\frac{1}{C_{\\mathrm{th}} s + G_{\\mathrm{th}}}\\, \\left(K_{p} + \\frac{K_{i}}{s}\\right) \\;=\\; \\infty,\n$$\n因为当 $s \\to 0$ 时，项 $K_{i}/s$ 占主导地位，而 $P(0) = 1/G_{\\mathrm{th}}$ 是有限的。这个形式上的极限体现了积分作用的标准特性：对于恒定输入，求和点处的稳态误差被驱动到零。\n\n因此，直接进行时域稳态分析是合适的。在恒定 $r$ 和 $b$ 的稳态下，所有导数均为零，并且控制器的积分状态已经调整，使得比较器处的误差满足\n$$\ne_{\\mathrm{ss}} \\;=\\; r \\;-\\; k_{s}\\, y_{\\mathrm{ss}} \\;-\\; b \\;=\\; 0,\n$$\n因为积分作用会累积任何非零的恒定误差并将其驱动到零。解出 $y_{\\mathrm{ss}}$，得到\n$$\ny_{\\mathrm{ss}} \\;=\\; \\frac{r \\;-\\; b}{k_{s}}.\n$$\n当参考值被选择为通过 $r \\equiv k_{s}\\, y^{\\star}$ 来编码期望的真实温度 $y^{\\star}$ 时，我们发现\n$$\ny_{\\mathrm{ss}} \\;=\\; \\frac{k_{s}\\, y^{\\star} \\;-\\; b}{k_{s}} \\;=\\; y^{\\star} \\;-\\; \\frac{b}{k_{s}}.\n$$\n因此，由传感器偏置引起的稳态偏差为\n$$\ny_{\\mathrm{ss}} \\;-\\; y^{\\star} \\;=\\; -\\, \\frac{b}{k_{s}}.\n$$\n\n这个表达式显示了在积分控制下，体温调节对恒定传感器偏置的鲁棒性（或缺乏鲁棒性）：从偏置到真实温度的映射是一个斜率为 $-1/k_{s}$ 的直接缩放，与 $C_{\\mathrm{th}}$、$G_{\\mathrm{th}}$、$K_{p}$ 和 $K_{i}$ 无关。\n\n数值上，当 $b = 0.3\\ \\mathrm{K}$ 和 $k_{s} = 0.8$ 时，\n$$\ny_{\\mathrm{ss}} - y^{\\star} \\;=\\; -\\, \\frac{0.3}{0.8} \\;=\\; -\\, 0.375\\ \\mathrm{K}.\n$$\n四舍五入到四位有效数字并以开尔文表示，稳态偏差为 $-0.3750\\ \\mathrm{K}$。", "answer": "$$\\boxed{-0.3750}$$", "id": "4352199"}, {"introduction": "除了维持稳态，稳态的关键功能之一是从瞬时扰动中恢复。本练习将我们的重点转移到膳食（模型化为一次性输入）后血糖调节的动态响应上。通过实施数值模拟，您将量化关键的性能指标，如血糖峰值和稳定时间，从而培养分析生理系统瞬态行为所必需的计算技能。[@problem_id:4352238]", "problem": "给定一个关于人体受试者葡萄糖稳态的闭环模型，其中血浆葡萄糖浓度相对于基础设定点的偏差由一个通过胰岛素输注作用的比例-积分 (PI) 控制器进行调节。该系统的动力学是围绕基础稳态的偏差变量进行描述的，基于以下假设与基本原理：(i) 质量守恒和一阶葡萄糖清除，(ii) 围绕基础稳态的线性化，以及 (iii) 将误差驱动至零的负反馈控制器。设基础葡萄糖浓度为 $G_b$（单位：mg/dL）。定义葡萄糖偏差为 $x_1(t) = G(t) - G_b$。控制器通过作用于胰岛素输注，经由误差积分状态 $x_2(t) = \\int_0^t x_1(\\tau)\\, d\\tau$ 将 $x_1(t)$ 驱动至零。一餐被建模为在时间 $t = 0$ 时的一个瞬时推注扰动，它将葡萄糖注入血浆室。在这些偏差坐标下，模型为：\n$$\n\\frac{dx_1}{dt} = -\\left(k_g + k_u k_p\\right) x_1(t) - k_u k_i \\, x_2(t) + D_{\\text{bol}}\\, \\delta(t),\n$$\n$$\n\\frac{dx_2}{dt} = x_1(t),\n$$\n推注后的初始条件为 $x_1(0^+) = D_{\\text{bol}}$ 和 $x_2(0^+) = 0$。此处，$k_g$（单位：min$^{-1}$）是内源性一阶葡萄糖清除率，$k_u$（单位：min$^{-1}$ 每单位控制器输出）是胰岛素作用对葡萄糖处置的增益，$k_p$ 和 $k_i$ 分别是控制器的比例和积分增益，$D_{\\text{bol}}$（单位：mg/dL）是膳食推注在葡萄糖偏差变量中的有效幅值。狄拉克δ函数 $\\delta(t)$ 对瞬时推注进行建模，它引起了跳变 $x_1(0^+) = x_1(0^-) + D_{\\text{bol}}$，而 $x_2$ 在 $t = 0$ 时保持连续。\n\n任务。对于下面测试套件中的每一组参数，使用固定步长的四阶 Runge–Kutta 积分器对系统的齐次动力学（$t=0$ 后无其他脉冲输入）进行数值模拟。在指定的时间范围内，使用 $\\Delta t = 0.01$ 分钟的恒定时间步长。根据模拟轨迹，计算：\n- 峰值葡萄糖浓度 $G_{\\text{peak}} = \\max_t G(t)$，单位为 mg/dL。\n- 稳定时间 $t_s$，单位为分钟，定义为满足以下条件的最小时间：对于所有后续直至时间范围结束的时间，误差都保持在零点周围宽度为 $\\pm \\varepsilon$ 的容差带内，其中 $\\varepsilon = \\alpha \\, G_b$，$\\alpha$ 为给定值。如果信号在整个时间范围内从未进入并保持在容差带内，则报告 $t_s$ 等于该时间范围的结束时间。\n\n您必须根据给定的模型以及线性时不变系统和反馈控制的原理来推导您的算法。不要使用任何预先推导的闭式时域解；从状态空间形式开始实现仿真。所有报告的数值答案必须四舍五入到三位小数。\n\n物理和数值单位。报告 $G_{\\text{peak}}$ 的单位为 mg/dL，$t_s$ 的单位为分钟。在本问题中，任何地方都不要使用弧度。容差因子 $\\alpha$ 必须视为一个无单位的小数。\n\n测试套件。使用以下参数集，每组都有其自己的时间范围和容差。在所有情况下，基础葡萄糖浓度均为 $G_b = 90$ mg/dL。对于每种情况，程序应计算并输出两个浮点数：首先是 $G_{\\text{peak}}$ (mg/dL)，然后是 $t_s$ (min)。\n- 情况1（欠阻尼）：$k_g = 0.02$，$k_u = 0.80$，$k_p = 0.50$，$k_i = 0.20$，$D_{\\text{bol}} = 40$，$\\alpha = 0.02$，结束时间 $T_{\\text{end}} = 240$ 分钟。\n- 情况2（近似临界阻尼）：$k_g = 0.02$，$k_u = 0.80$，$k_p = 0.30$，$k_i = 0.021125$，$D_{\\text{bol}} = 40$，$\\alpha = 0.02$，$T_{\\text{end}} = 240$ 分钟。\n- 情况3（过阻尼，具有更快的内源性清除率）：$k_g = 0.04$，$k_u = 0.80$，$k_p = 0.20$，$k_i = 0.005$，$D_{\\text{bol}} = 40$，$\\alpha = 0.02$，$T_{\\text{end}} = 180$ 分钟。\n- 情况4（较小的推注，欠阻尼增益）：$k_g = 0.02$，$k_u = 0.80$，$k_p = 0.50$，$k_i = 0.20$，$D_{\\text{bol}} = 10$，$\\alpha = 0.02$，$T_{\\text{end}} = 180$ 分钟。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须是按顺序将每个案例的两个结果进行扁平化串联而成。例如，格式必须为 $[G_{\\text{peak},1},t_{s,1},G_{\\text{peak},2},t_{s,2},G_{\\text{peak},3},t_{s,3},G_{\\text{peak},4},t_{s,4}]$，每个数值都四舍五入到三位小数。", "solution": "该问题要求对一个模拟葡萄糖稳态的二阶线性时不变 (LTI) 系统进行数值模拟，然后计算两个性能指标：峰值葡萄糖浓度和稳定时间。验证确认该问题具有科学依据、是适定的且是完整的。\n\n系统动力学由关于偏差变量 $x_1(t)$ 和 $x_2(t)$ 的两个耦合一阶常微分方程 (ODE) 给出：\n$$\n\\frac{dx_1}{dt} = -\\left(k_g + k_u k_p\\right) x_1(t) - k_u k_i \\, x_2(t)\n$$\n$$\n\\frac{dx_2}{dt} = x_1(t)\n$$\n这些方程描述了在初始葡萄糖推注后，$t > 0$ 时的系统行为。由狄拉克δ函数 $D_{\\text{bol}}\\delta(t)$ 建模的推注效应，通过 $t=0^+$ 时的初始条件来体现。\n\n我们可以将该系统表示为状态空间形式 $\\dot{\\mathbf{x}}(t) = \\mathbf{A}\\mathbf{x}(t)$，其中状态向量为 $\\mathbf{x}(t) = \\begin{pmatrix} x_1(t) \\\\ x_2(t) \\end{pmatrix}$。状态矩阵 $\\mathbf{A}$ 由下式给出：\n$$\n\\mathbf{A} = \\begin{pmatrix}\n-(k_g + k_u k_p)  -k_u k_i \\\\\n1  0\n\\end{pmatrix}\n$$\n问题指定了在 $t=0$ 时葡萄糖推注后的初始条件：\n$$\n\\mathbf{x}(0) = \\begin{pmatrix} x_1(0^+) \\\\ x_2(0^+) \\end{pmatrix} = \\begin{pmatrix} D_{\\text{bol}} \\\\ 0 \\end{pmatrix}\n$$\n模拟将使用固定时间步长 $\\Delta t$ 的四阶 Runge-Kutta (RK4) 方法进行。对于一个一般的初值问题 $\\dot{\\mathbf{x}} = f(t, \\mathbf{x})$，RK4 算法将解从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$ 的过程如下：\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中中间斜率为：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(t_n, \\mathbf{x}_n) \\\\\n\\mathbf{k}_2 = f(t_n + \\frac{\\Delta t}{2}, \\mathbf{x}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = f(t_n + \\frac{\\Delta t}{2}, \\mathbf{x}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = f(t_n + \\Delta t, \\mathbf{x}_n + \\Delta t \\, \\mathbf{k}_3)\n\\end{aligned}\n$$\n在我们的具体案例中，函数 $f$ 是线性时不变的，即 $f(t, \\mathbf{x}) = \\mathbf{A}\\mathbf{x}$。RK4 的实现将通过将时间范围 $[0, T_{\\text{end}}]$ 离散化为大小为 $\\Delta t = 0.01$ 分钟的步长，并从给定的初始条件 $\\mathbf{x}_0$ 开始，在每个步骤上迭代计算状态向量 $\\mathbf{x}_n$ 来进行。\n\n在模拟得出葡萄糖偏差 $x_1(t)$ 的时间序列后，我们计算所需的指标。\n\n首先是峰值葡萄糖浓度 $G_{\\text{peak}}$。绝对葡萄糖浓度由 $G(t) = x_1(t) + G_b$ 给出，其中 $G_b$ 是基础浓度。峰值葡萄糖浓度是该函数在模拟时间范围内的最大值：\n$$\nG_{\\text{peak}} = \\max_{t \\in [0, T_{\\text{end}}]} G(t) = \\left( \\max_{t \\in [0, T_{\\text{end}}]} x_1(t) \\right) + G_b\n$$\n这是通过在 $x_1(t)$ 的模拟轨迹中找到最大值，并加上基础值 $G_b = 90$ mg/dL 来计算的。\n\n其次是稳定时间 $t_s$。这被定义为最小的时间，使得在时间范围内的所有后续时间 $t' \\geq t_s$，葡萄糖偏差都保持在指定的容差带内：$|x_1(t')| \\le \\varepsilon$。容差 $\\varepsilon$ 由 $\\varepsilon = \\alpha G_b$ 给出。为了找到 $t_s$，我们实现以下算法：\n1.  计算容差值 $\\varepsilon = \\alpha G_b$。\n2.  遍历模拟轨迹 $x_1(t_i)$（其中 $i = 0, 1, \\dots, N-1$，$N$ 是时间点的总数），以找到最后一个违反条件 $|x_1(t_i)| > \\varepsilon$ 的时间点的索引。设此索引为 $k_{\\text{last}}$。如果没有发生违反，则 $k_{\\text{last}}$ 被视为 $-1$。\n3.  根据 $k_{\\text{last}}$ 的值：\n    - 如果 $k_{\\text{last}} = -1$，则轨迹始终在容差带内，因此稳定时间为 $t_s = 0$。\n    - 如果 $k_{\\text{last}} = N-1$（模拟中的最后一个点），则轨迹在时间范围结束时仍未稳定。根据问题陈述，$t_s$ 报告为结束时间 $T_{\\text{end}}$。\n    - 否则，系统被认为从最后一次违反后的紧邻时间点开始稳定。因此，$t_s = t_{k_{\\text{last}}+1} = (k_{\\text{last}}+1)\\Delta t$。\n\n整个过程——通过 RK4 进行模拟以及随后计算 $G_{\\text{peak}}$ 和 $t_s$——将对测试套件中提供的四个参数集中的每一个重复进行。最终的数值结果四舍五入到三位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the glucose homeostasis simulation problem for a given set of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (underdamped)\n        {'kg': 0.02, 'ku': 0.80, 'kp': 0.50, 'ki': 0.20, 'Dbol': 40.0, 'alpha': 0.02, 'Tend': 240.0},\n        # Case 2 (approximately critically damped)\n        {'kg': 0.02, 'ku': 0.80, 'kp': 0.30, 'ki': 0.021125, 'Dbol': 40.0, 'alpha': 0.02, 'Tend': 240.0},\n        # Case 3 (overdamped with faster intrinsic clearance)\n        {'kg': 0.04, 'ku': 0.80, 'kp': 0.20, 'ki': 0.005, 'Dbol': 40.0, 'alpha': 0.02, 'Tend': 180.0},\n        # Case 4 (smaller bolus, underdamped gains)\n        {'kg': 0.02, 'ku': 0.80, 'kp': 0.50, 'ki': 0.20, 'Dbol': 10.0, 'alpha': 0.02, 'Tend': 180.0},\n    ]\n\n    Gb = 90.0  # Basal glucose concentration in mg/dL\n    dt = 0.01  # Time step in minutes\n\n    results = []\n    \n    for case in test_cases:\n        kg, ku, kp, ki = case['kg'], case['ku'], case['kp'], case['ki']\n        Dbol, Tend = case['Dbol'], case['Tend']\n        alpha = case['alpha']\n\n        # State-space matrix A\n        A = np.array([\n            [-(kg + ku * kp), -ku * ki],\n            [1.0, 0.0]\n        ])\n\n        # Derivative function for the ODE system dx/dt = A*x\n        def dynamics(x, A_matrix):\n            return A_matrix @ x\n\n        # Time array\n        num_steps = int(Tend / dt)\n        t_values = np.linspace(0, Tend, num_steps + 1)\n        \n        # State vector initialization\n        x = np.array([Dbol, 0.0])\n        \n        # Array to store the trajectory of x1(t)\n        x1_trajectory = np.zeros(num_steps + 1)\n        x1_trajectory[0] = x[0]\n\n        # RK4 Integration\n        for i in range(num_steps):\n            k1 = dynamics(x, A)\n            k2 = dynamics(x + 0.5 * dt * k1, A)\n            k3 = dynamics(x + 0.5 * dt * k2, A)\n            k4 = dynamics(x + dt * k3, A)\n            x = x + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n            x1_trajectory[i + 1] = x[0]\n\n        # --- Post-processing ---\n        \n        # 1. Calculate Peak Glucose (G_peak)\n        G_peak = np.max(x1_trajectory) + Gb\n\n        # 2. Calculate Settling Time (t_s)\n        tolerance = alpha * Gb\n        \n        # Find the index of the last violation of the tolerance band\n        last_violation_idx = -1\n        for i in range(len(x1_trajectory)):\n            if abs(x1_trajectory[i]) > tolerance:\n                last_violation_idx = i\n\n        if last_violation_idx == -1:\n            # Trajectory was always within the tolerance band\n            t_s = 0.0\n        elif last_violation_idx == len(t_values) - 1:\n            # The last point is a violation, so settling time is the horizon end\n            t_s = Tend\n        else:\n            # Settling time is the time of the sample after the last violation\n            t_s = t_values[last_violation_idx + 1]\n            \n        results.extend([G_peak, t_s])\n\n    # Format the final output string with rounding to three decimal places\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "4352238"}, {"introduction": "稳态有时会发生灾难性的崩溃，导致病理状态。本练习超越了线性调节的范畴，通过非线性动力学和分岔理论的视角，探究这种灾难性转变是如何发生的。您将通过数值计算，确定导致稳定稳态平衡丧失的关键参数阈值，从而深入了解疾病发生机制和生物稳定性的脆弱性。[@problem_id:4352186]", "problem": "考虑一个受负反馈和正反馈共同调控的生理变量 $x(t)$ 的最小无量纲模型。变量 $x(t)$ 的演化遵循一个常微分方程（ODE）：\n$$\n\\frac{dx}{dt} = u - L x + k_p \\, S(x),\n$$\n其中 $u > 0$ 是一个恒定的输入，$L > 0$ 是负反馈和被动清除的有效强度，$k_p \\ge 0$ 是正反馈增益。S形正反馈由希尔函数建模：\n$$\nS(x) = \\frac{x^n}{x^n + x_0^n},\n$$\n其中 $n \\ge 1$ 是希尔系数（无量纲的协同性），$x_0 > 0$ 是半饱和常数。所有变量和参数都是无量纲的。\n\n假设稳态对应于一个稳定的低$x$平衡点的存在。当系统经历鞍结分岔，消除了低$x$平衡点时，就会发生病理性稳态丧失，可能只留下一个高$x$平衡点（双稳态并切换到病理状态）。鞍结分岔发生在满足以下必要条件的参数值 $(x^\\*, k_p^\\*)$ 处：\n$$\nf(x^\\*; k_p^\\*) = 0, \\quad \\frac{\\partial f}{\\partial x}(x^\\*; k_p^\\*) = 0,\n$$\n其中 $f(x; k_p) = u - L x + k_p S(x)$。使用希尔函数 $S(x)$，从鞍结条件中消去 $k_p$，从而得到一个只关于 $x$ 的方程：\n$$\nF(x) = u - L \\frac{n-1}{n}\\,x + \\frac{L}{n x_0^n}\\, x^{n+1} = 0,\n$$\n并且，当 $x$ 是 $F(x)=0$ 的解时，可以恢复相应的临界正反馈增益：\n$$\nk_p^\\*(x) = \\frac{L}{S'(x)} = L\\,\\frac{(x^n + x_0^n)^2}{n x_0^n x^{n-1}}.\n$$\n$F(x)$ 的多个正根（如果存在的话）会产生多个临界增益 $k_p^\\*$；较小的增益对应于双稳态的开始（鞍结对的产生），而较大的增益对应于低$x$稳态平衡的丧失。\n\n任务：对于下面测试套件中提供的每组参数 $(u, L, x_0, n)$，计算 $F(x)=0$ 的所有正解 $x$，并按升序报告相应的临界增益列表 $[k_{p,1}^\\*, k_{p,2}^\\*, \\dots]$。如果没有正解，则报告空列表 $[]$。您的程序必须实现一个鲁棒的数值求根程序，以在 $x \\in (0, X_{\\max}]$ 范围内求解 $F(x)$，其中 $X_{\\max}$ 是根据 $x_0$ 选择的一个科学上合理的数值。\n\n测试套件：\n- 情况1：$(u, L, x_0, n) = (0.4, 1.2, 1.0, 4)$。\n- 情况2：$(u, L, x_0, n) = (0.1, 0.8, 1.0, 2)$。\n- 情况3（边界情况，无协同性）：$(u, L, x_0, n) = (0.5, 1.0, 1.0, 1)$。\n- 情况4：$(u, L, x_0, n) = (0.2, 2.0, 1.0, 3)$。\n\n输出规格：\n- 对于每种情况，按升序输出临界增益 $k_p^\\*$ 的列表（浮点数）。如果不存在，则输出 $[]$。\n- 您的程序应生成一行输出，其中包含一个逗号分隔的列表，并用方括号括起来（例如，$[result_1,result_2,\\dots]$），其中每个 $result_i$ 是情况 $i$ 的列表。不应打印任何额外文本。\n\n注意：所有变量都是无量纲的，因此输出中不需要物理单位。不涉及角度。不涉及百分比；所有数值输出均为浮点数。", "solution": "问题陈述描述了一个生理变量 $x(t)$ 的最小数学模型，该变量由负反馈和正反馈机制的组合调控。核心任务是确定正反馈增益 $k_p$ 的临界值，在这些临界值下，系统会经历鞍结分岔，这种现象可能导致稳定稳态的丧失。该问题在科学和数学上是适定(well-posed)的，提供了进行分析所需的所有必要定义和方程。\n\n生理变量 $x(t)$ 的演化由以下常微分方程（ODE）控制：\n$$\n\\frac{dx}{dt} = f(x; k_p) = u - L x + k_p \\, S(x)\n$$\n其中 $u > 0$ 是一个恒定的产生或输入速率，$L > 0$ 代表线性负反馈和清除的总速率常数，而 $k_p \\ge 0$ 是正反馈回路的增益。S形正反馈项由希尔函数建模：\n$$\nS(x) = \\frac{x^n}{x^n + x_0^n}\n$$\n在此，$n \\ge 1$ 是希尔系数，代表反馈的协同性，$x_0 > 0$ 是反馈达到半最大值时的浓度。\n\n系统的平衡态或稳态，是使变化率为零的 $x$ 值，记为 $x^*$。它们是方程 $f(x; k_p) = 0$ 的根：\n$$\nu - L x^* + k_p S(x^*) = 0\n$$\n平衡点 $x^*$ 的稳定性由导数 $\\frac{\\partial f}{\\partial x}$ 在 $x^*$ 处的值的符号决定。如果 $\\frac{\\partial f}{\\partial x}(x^*)  0$，则平衡点是局部稳定的；如果 $\\frac{\\partial f}{\\partial x}(x^*) > 0$，则是不稳定的。\n\n当一个稳定平衡点和一个不稳定平衡点合并并相互抵消时，就会发生鞍结分岔。在分岔点 $(x^\\*, k_p^\\*)$，平衡条件 $f(x^\\*) = 0$ 得到满足，同时，稳定性发生改变，这意味着导数为零：$\\frac{\\partial f}{\\partial x}(x^\\*) = 0$。这两个条件构成了一个关于临界值 $(x^\\*, k_p^\\*)$ 的方程组：\n1. $f(x^\\*; k_p^\\*) = u - L x^\\* + k_p^\\* S(x^\\*) = 0$\n2. $\\frac{\\partial f}{\\partial x}(x^\\*; k_p^\\*) = -L + k_p^\\* S'(x^\\*) = 0$\n\n其中 $S'(x)$ 是希尔函数的导数：\n$$\nS'(x) = \\frac{d}{dx}\\left(\\frac{x^n}{x^n + x_0^n}\\right) = \\frac{n x^{n-1} (x^n + x_0^n) - x^n (n x^{n-1})}{(x^n + x_0^n)^2} = \\frac{n x_0^n x^{n-1}}{(x^n + x_0^n)^2}\n$$\n从第二个条件，我们可以将临界增益 $k_p^\\*$ 表示为临界状态 $x^\\*$ 的函数：\n$$\nk_p^\\*(x^\\*) = \\frac{L}{S'(x^\\*)} = L \\frac{( (x^\\*)^n + x_0^n )^2}{n x_0^n (x^\\*)^{n-1}}\n$$\n此表达式仅对 $x^\\* > 0$ 和 $n \\ge 1$ 有效。\n\n将 $k_p^\\*$ 的这个表达式代入第一个条件 $f(x^\\*) = 0$，可以消去 $k_p^\\*$ 并得到一个只关于 $x^\\*$ 的方程：\n$$\nu - L x^\\* + \\left(L \\frac{((x^\\*)^n + x_0^n)^2}{n x_0^n (x^\\*)^{n-1}}\\right) \\left(\\frac{(x^\\*)^n}{(x^\\*)^n + x_0^n}\\right) = 0\n$$\n$$\nu - L x^\\* + \\frac{L}{n x_0^n (x^\\*)^{n-1}} (x^\\*)^n ((x^\\*)^n + x_0^n) = 0\n$$\n$$\nu - L x^\\* + \\frac{L x^\\*}{n x_0^n} ((x^\\*)^n + x_0^n) = 0\n$$\n$$\nu - L x^\\* + \\frac{L}{n x_0^n} (x^\\*)^{n+1} + \\frac{L}{n} x^\\* = 0\n$$\n$$\nu - L\\left(1 - \\frac{1}{n}\\right)x^\\* + \\frac{L}{n x_0^n} (x^\\*)^{n+1} = 0\n$$\n这可以简化为方程 $F(x^\\*) = 0$，其中 $F(x)$ 定义为：\n$$\nF(x) = u - L \\frac{n-1}{n} x + \\frac{L}{n x_0^n} x^{n+1} = 0\n$$\n问题现在简化为找到代数方程 $F(x)=0$ 的所有正根 $x > 0$。对于每一个这样的根 $x^\\*$，我们便可以计算出相应的临界增益 $k_p^\\*(x^\\*)$。\n\n为了找到 $F(x)=0$ 的根，我们分析它在 $x>0$ 时的行为：\n- 当 $x \\to 0^+$ 时，$F(x) \\to u$。由于给定 $u>0$，因此 $F(x)$ 在原点附近为正。\n- 当 $x \\to \\infty$ 时，项 $\\frac{L}{n x_0^n} x^{n+1}$ 占主导地位，因此 $F(x) \\to +\\infty$。\n\n要存在正根，$F(x)$ 必须在某个区间内变为负值。这要求 $F(x)$ 有一个局部最小值。我们通过计算导数 $F'(x)$ 来寻找极值点：\n$$\nF'(x) = -L \\frac{n-1}{n} + \\frac{L(n+1)}{n x_0^n} x^n\n$$\n令 $F'(x)=0$ 以找到临界点 $x_{min}$：\n$$\nL \\frac{n-1}{n} = \\frac{L(n+1)}{n x_0^n} x_{min}^n \\implies x_{min}^n = x_0^n \\frac{n-1}{n+1} \\implies x_{min} = x_0 \\left(\\frac{n-1}{n+1}\\right)^{1/n}\n$$\n该分析揭示了两种情况：\n1.  **情况 $n=1$**：项 $\\frac{n-1}{n}$ 为零，得到 $F(x) = u + \\frac{L}{x_0}x^2$。由于 $u>0$ 和 $L>0$，$F(x)$ 对所有 $x$ 都严格为正。因此，不存在实根，这意味着不会发生鞍结分岔。这对应于正反馈回路中没有协同性，这是此类模型中产生双稳态的一个已知要求。\n2.  **情况 $n>1$**：在 $x_{min}$ 处存在一个唯一的正极值点（一个最小值，因为 $F''(x) = \\frac{L(n+1)}{x_0^n} x^{n-1} > 0$）。$F(x)=0$ 的正根数量取决于 $F(x_{min})$ 的符号：\n    - 如果 $F(x_{min}) > 0$，则没有正根。\n    - 如果 $F(x_{min}) = 0$，则在 $x_{min}$ 处有一个正的（二重）根。\n    - 如果 $F(x_{min})  0$，则有两个不同的正根，一个在区间 $(0, x_{min})$ 内，另一个在 $(x_{min}, \\infty)$ 内。\n\n数值策略如下：\n- 对于每组参数 $(u, L, x_0, n)$，首先检查 $n$ 的值。如果 $n=1$，报告无解。\n- 如果 $n>1$，计算 $x_{min}$。然后计算 $F(x_{min})$。\n- 如果 $F(x_{min}) \\ge 0$，报告无解。\n- 如果 $F(x_{min})  0$，则找到两个根。一个鲁棒的数值求根算法，例如 Brent-Dekker 方法（在 SciPy 中为 `brentq`），是合适的。将在两个区间内搜索根：\n    - 根1：在 $(0, x_{min})$ 内。此区间端点的函数值 $F(0^+) = u > 0$ 和 $F(x_{min})  0$ 提供了一个有效的括号区间。\n    - 根2：在 $(x_{min}, \\infty)$ 内。我们需要找到一个上界 $X_{max}$ 使得 $F(X_{max})>0$。由于 $F(x)$ 的增长类似于 $x^{n+1}$，一个足够大的 $x_0$ 的倍数（例如，$X_{max} = 20x_0$）将作为一个可靠的上界，确保 $F(X_{max})>0$。那么区间 $(x_{min}, X_{max})$ 提供了一个有效的括号区间。\n- 一旦找到根 $\\{x_1^*, x_2^*\\}$，计算相应的临界增益 $\\{k_p^\\*(x_1^*), k_p^\\*(x_2^*)\\}$。\n- 最后，按要求将这些增益按升序排序。\n这个系统化的程序确保能找到所有正根，并为每个测试用例正确计算出相应的临界增益。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the critical positive feedback gains for saddle-node bifurcations\n    in a physiological feedback model.\n    \"\"\"\n    test_cases = [\n        # (u, L, x0, n)\n        (0.4, 1.2, 1.0, 4),  # Case 1\n        (0.1, 0.8, 1.0, 2),  # Case 2\n        (0.5, 1.0, 1.0, 1),  # Case 3 (boundary, no cooperativity)\n        (0.2, 2.0, 1.0, 3)   # Case 4\n    ]\n\n    all_results = []\n    for case in test_cases:\n        u, L, x0, n = case\n        results = process_case(u, L, x0, n)\n        all_results.append(results)\n\n    # Format the final output as a single string.\n    # e.g., [[val1, val2], [], [val3, val4]]\n    output_str = '[' + ','.join([f\"[{','.join(map(str, res))}]\" if res else '[]' for res in all_results]) + ']'\n    print(output_str)\n\ndef process_case(u, L, x0, n):\n    \"\"\"\n    Processes a single parameter set to find the critical gains.\n\n    Args:\n        u (float): Constant input.\n        L (float): Negative feedback strength.\n        x0 (float): Half-saturation constant.\n        n (float): Hill coefficient.\n\n    Returns:\n        list: A sorted list of critical gains k_p*. Empty if no solutions exist.\n    \"\"\"\n\n    # The equation for the critical states x: F(x) = 0\n    # F(x) = u - L * ((n-1)/n) * x + (L / (n * x0**n)) * x**(n+1)\n    def F(x, u_p, L_p, x0_p, n_p):\n        if x = 0:\n            return np.inf  # Function is defined for x > 0\n        term1 = u_p\n        term2 = -L_p * (n_p - 1) / n_p * x\n        term3 = (L_p / (n_p * x0_p**n_p)) * x**(n_p + 1)\n        return term1 + term2 + term3\n\n    # The formula for the critical gain k_p*(x)\n    # k_p*(x) = L * (x**n + x0**n)**2 / (n * x0**n * x**(n-1))\n    def k_p_star(x, L_p, x0_p, n_p):\n        if x = 0:\n            return np.inf\n        numerator = L_p * (x**n_p + x0_p**n_p)**2\n        denominator = n_p * x0_p**n_p * x**(n_p - 1)\n        return numerator / denominator\n\n    # For n=1, F(x) is monotonically increasing for x>0 and F(0)=u>0.\n    # So, no positive roots exist.\n    if n == 1:\n        return []\n\n    # For n>1, find the minimum of F(x)\n    # The minimum occurs at x_min = x0 * ((n-1)/(n+1))**(1/n)\n    try:\n        x_min = x0 * ((n - 1) / (n + 1))**(1 / n)\n    except (ValueError, ZeroDivisionError):\n         # This should not happen for n>1, but as a safeguard.\n        return []\n\n    F_at_min = F(x_min, u, L, x0, n)\n\n    # If F(x_min) >= 0, there are no positive roots (or one double root if F_at_min=0).\n    # Since we are looking for the onset/loss of homeostasis, which requires two\n    # distinct bifurcation points, we consider F_at_min >= 0 to yield no relevant solutions.\n    if F_at_min >= -1e-9: # Use a small tolerance for floating point comparison\n        return []\n    \n    # If F(x_min)  0, there are two distinct positive roots.\n    # We use a robust root-finding method (Brent's method) to find them.\n    roots = []\n    \n    # Define a scientifically reasonable search range.\n    # Since F(x -> inf) -> inf, a sufficiently large multiple of x0 is a safe upper bound.\n    # A value of 20*x0 is chosen as a robust, large-enough value.\n    X_max = 20.0 * x0\n    \n    try:\n        # Lower root is in (0, x_min)\n        # Bracket is [epsilon, x_min], as F(epsilon)>0 and F(x_min)0\n        # epsilon must be small and positive\n        epsilon = 1e-12\n        root1 = brentq(F, epsilon, x_min, args=(u, L, x0, n))\n        roots.append(root1)\n\n        # Upper root is in (x_min, infinity)\n        # Bracket is [x_min, X_max], as F(x_min)0 and we expect F(X_max)>0\n        # A check `F(X_max) > 0` would be prudent in a general-purpose library,\n        # but for the given parameters, it holds.\n        root2 = brentq(F, x_min, X_max, args=(u, L, x0, n))\n        roots.append(root2)\n    except ValueError:\n        # This may happen if the bracket is not valid (e.g., F has the same sign\n        # at both ends), indicating an issue with our analysis or numerical precision.\n        # Given the analysis, this is unlikely for the test cases.\n        return []\n\n    # Calculate k_p* for each root and sort them\n    k_p_values = [k_p_star(r, L, x0, n) for r in roots]\n    k_p_values.sort()\n\n    return k_p_values\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "4352186"}]}