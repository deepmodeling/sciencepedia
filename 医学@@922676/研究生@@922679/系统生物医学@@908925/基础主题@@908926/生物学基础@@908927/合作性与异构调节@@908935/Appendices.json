{"hands_on_practices": [{"introduction": "在定量生物学中，将实验数据与数学模型相拟合是理解生物过程基础特性的第一步。Hill 方程是描述协同效应的经典唯象模型，能够简洁地概括配体结合或酶活性的 S 型响应曲线。本练习将引导你运用非线性最小二乘法，将 Hill 方程与模拟的转运蛋白摄取数据进行拟合，从而提取表征协同反应关键特性的两个参数：半激活浓度 $K_{0.5}$ 和 Hill 系数 $n_H$ [@problem_id:4331836]。这个过程不仅能加深你对协同性度量的理解，也是系统生物医学研究中一项核心的数据分析技能。", "problem": "给定某膜转运蛋白的摄取测量数据，其速率对胞外底物浓度呈S型依赖关系。在系统生物医学中，这种行为与多蛋白复合物中功能状态的协同和变构调节相一致。从化学动力学和热力学占有率的基本定义出发，假设稳态摄取速率与处于活性、底物结合状态的转运蛋白分子的比例成正比，并且结合事件之间的协同相互作用导致浓度-响应曲线的有效陡度增加。\n\n将半活化浓度 $K_{0.5}$ 定义为摄取速率等于其最大值一半时的底物浓度，并将希尔系数 $n_H$ 定义为在半活化点处，分数活化的对数优势比（log-odds）对浓度自然对数的局部斜率。您的任务是将一个协同转运蛋白模型拟合到所提供的数据，以估算每个数据集的 $K_{0.5}$ 和 $n_H$。\n\n您的程序必须：\n- 构建一个参数化的浓度-响应模型，该模型与稳态条件下的协同结合相容，并能通过非线性最小二乘法从数据中辨识。\n- 通过最小化测量摄取速率与模型预测值之间的残差平方和，为每个数据集估算最大摄取速率、半活化浓度 $K_{0.5}$ 和有效希尔系数 $n_H$。\n- 生成结果，其中 $K_{0.5}$ 以 $\\mu\\mathrm{M}$ 为单位表示，$n_H$ 为无量纲量。两者均以十进制数报告。\n\n提供的测试套件包含四个数据集，每个数据集都指定为底物浓度 $S$（单位 $\\mu\\mathrm{M}$）和摄取速率 $J$（单位 $\\mathrm{pmol}\\,\\mathrm{s}^{-1}\\,\\mathrm{cell}^{-1}$）的配对。请直接使用这些数据，除了拟合过程所隐含的转换外，不要进行任何其他转换。\n\n数据集 $\\mathcal{A}$（宽浓度范围的一般协同情况）：\n- 浓度 $S$（单位 $\\mu\\mathrm{M}$）：$\\{0.5,1,2,5,10,25,50,100\\}$。\n- 摄取速率 $J$（单位 $\\mathrm{pmol}\\,\\mathrm{s}^{-1}\\,\\mathrm{cell}^{-1}$）：$\\{0.24937656,0.99009901,3.84615385,20.0,50.0,86.20689655,96.15384615,99.00990099\\}$。\n\n数据集 $\\mathcal{B}$（接近非协同行为）：\n- 浓度 $S$（单位 $\\mu\\mathrm{M}$）：$\\{3,6,12,24,48\\}$。\n- 摄取速率 $J$（单位 $\\mathrm{pmol}\\,\\mathrm{s}^{-1}\\,\\mathrm{cell}^{-1}$）：$\\{10.0,17.14285714,26.66666667,36.92307692,45.71428571\\}$。\n\n数据集 $\\mathcal{C}$（具有陡峭活化曲线的高协同性）：\n- 浓度 $S$（单位 $\\mu\\mathrm{M}$）：$\\{5,10,20,30,50,80,120\\}$。\n- 摄取速率 $J$（单位 $\\mathrm{pmol}\\,\\mathrm{s}^{-1}\\,\\mathrm{cell}^{-1}$）：$\\{0.06167046,0.97560976,13.19587629,40.0,70.96774194,78.44654664,79.76403026\\}$。\n\n数据集 $\\mathcal{D}$（包括零浓度和接近饱和的边界情况）：\n- 浓度 $S$（单位 $\\mu\\mathrm{M}$）：$\\{0,1,5,50\\}$。\n- 摄取速率 $J$（单位 $\\mathrm{pmol}\\,\\mathrm{s}^{-1}\\,\\mathrm{cell}^{-1}$）：$\\{0.0,1.92307692,25.0,49.5049505\\}$。\n\n算法要求：\n- 使用一个非线性最小二乘估计器，并设置参数边界以确保所有拟合参数均为正值。\n- 基于观察到的最大摄取速率和接近半最大响应时的浓度，使用数据驱动的启发式方法来初始化参数。\n\n角度单位不适用。所有物理量均已采用其指定单位。请将最终输出表示为十进制数。输出格式必须为单行，包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含数据集 $\\mathcal{A}$ 的估算值 $K_{0.5}$ 和 $n_H$，然后是 $\\mathcal{B}$ 的，接着是 $\\mathcal{C}$ 的，最后是 $\\mathcal{D}$ 的：\n$[K_{0.5}^{(\\mathcal{A})},n_H^{(\\mathcal{A})},K_{0.5}^{(\\mathcal{B})},n_H^{(\\mathcal{B})},K_{0.5}^{(\\mathcal{C})},n_H^{(\\mathcal{C})},K_{0.5}^{(\\mathcal{D})},n_H^{(\\mathcal{D})}]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8]$）。", "solution": "该问题要求将一个协同转运蛋白模型拟合到四个不同的摄取速率与底物浓度的数据集。目标是为每个数据集估算半活化浓度 $K_{0.5}$ 和希尔系数 $n_H$。\n\n### 问题验证\n\n首先，根据所需标准对问题陈述进行验证。\n\n1.  **已知条件提取**：\n    *   **模型**：稳态摄取速率 $J$ 与活性的、底物结合的转运蛋白分子的比例成正比。该系统表现出S型动力学，表明存在协同性。\n    *   **参数**：$K_{0.5}$ 是摄取速率为最大速率 $J_{max}$ 一半时的底物浓度 $S$。希尔系数 $n_H$ 被定义为在 $S=K_{0.5}$ 时，分数活化的对数优势比与浓度自然对数之间的斜率。\n    *   **任务**：使用非线性最小二乘法为四个数据集（$\\mathcal{A}$、$\\mathcal{B}$、$\\mathcal{C}$、$\\mathcal{D}$）估算 $J_{max}$、$K_{0.5}$ 和 $n_H$。报告估算出的 $K_{0.5}$ 和 $n_H$。\n    *   **数据**：提供了四组 $(S, J)$ 配对，其中 $S$ 的单位是 $\\mu\\mathrm{M}$，$J$ 的单位是 $\\mathrm{pmol}\\,\\mathrm{s}^{-1}\\,\\mathrm{cell}^{-1}$。\n    *   **约束**：估计器必须使用非线性最小二乘法，强制参数为正值，并采用数据驱动的启发式方法进行参数初始化。\n\n2.  **验证检查**：\n    *   **科学依据**：该问题基于化学动力学和酶/转运蛋白理论的基本原理。协同结合、S型响应、希尔系数和半活化浓度的概念在生物化学和系统生物学中是标准内容。\n    *   **适定性**：该任务是通过曲线拟合进行参数估计，这是一个标准的、适定的数值问题。所提供的数据足以辨识指定模型的三个参数（$J_{max}$、$K_{0.5}$、$n_H$）。\n    *   **客观性**：问题陈述使用了精确、客观和定量的语言，不存在主观因素。\n\n3.  **结论**：该问题是**有效的**。这是一个定量生物数据分析中标准的、科学上合理的问题。\n\n### 解题推导\n\n#### 1. 数学模型的构建\n\n摄取速率 $J$ 与转运蛋白活性状态的分数占有率 $\\theta$ 成正比。这可以写成：\n$$ J(S) = J_{max} \\cdot \\theta(S) $$\n其中 $S$ 是底物浓度，$J_{max}$ 是最大摄取速率。\n\n对协同结合的描述以及希尔系数 $n_H$ 的定义指向使用**希尔方程**来模拟 $\\theta(S)$。以半活化浓度 $K_{0.5}$ 参数化的标准形式希尔方程为：\n$$ \\theta(S) = \\frac{S^{n_H}}{K_{0.5}^{n_H} + S^{n_H}} $$\n这种形式确保当 $S = K_{0.5}$ 时，$\\theta(K_{0.5}) = \\frac{K_{0.5}^{n_H}}{K_{0.5}^{n_H} + K_{0.5}^{n_H}} = \\frac{1}{2}$，这与 $K_{0.5}$ 的定义一致。\n\n我们来验证该模型与所提供的 $n_H$ 定义的一致性。分数活化的对数优势比由 $\\ln(\\frac{\\theta}{1-\\theta})$ 给出。\n首先，我们求 $1-\\theta$：\n$$ 1 - \\theta(S) = 1 - \\frac{S^{n_H}}{K_{0.5}^{n_H} + S^{n_H}} = \\frac{K_{0.5}^{n_H}}{K_{0.5}^{n_H} + S^{n_H}} $$\n然后，优势比为：\n$$ \\frac{\\theta(S)}{1 - \\theta(S)} = \\frac{S^{n_H}}{K_{0.5}^{n_H}} = \\left(\\frac{S}{K_{0.5}}\\right)^{n_H} $$\n取自然对数得到对数优势比，这种关系被称为希尔图：\n$$ \\ln\\left(\\frac{\\theta(S)}{1 - \\theta(S)}\\right) = n_H \\ln(S) - n_H \\ln(K_{0.5}) $$\n对数优势比关于 $\\ln(S)$ 的导数为：\n$$ \\frac{d}{d(\\ln S)}\\left[ n_H \\ln(S) - n_H \\ln(K_{0.5}) \\right] = n_H $$\n对于所有 $S  0$，包括在 $S = K_{0.5}$ 点，斜率是恒定的且等于 $n_H$。因此，该模型与所有提供的定义完全一致。\n\n将这些结合起来，得到摄取速率 $J(S)$ 的最终模型：\n$$ J(S) = J_{max} \\frac{S^{n_H}}{K_{0.5}^{n_H} + S^{n_H}} $$\n为了数值稳定性，尤其是在计算环境中，最好将其表示为：\n$$ J(S) = \\frac{J_{max}}{1 + \\left(\\frac{K_{0.5}}{S}\\right)^{n_H}} $$\n当 $S$ 很大时，这种形式避免了计算大数值，并且当 $n_H  0$ 且 $S \\to 0$ 时，能正确计算出 $J(S) \\to 0$。\n\n#### 2. 参数估计策略\n\n参数 $J_{max}$、$K_{0.5}$ 和 $n_H$ 将通过最小化每个数据点 $(S_i, J_i)$ 的测量摄取速率 $J_i$ 与模型预测速率 $J(S_i)$ 之间的残差平方和（SSR）来估计：\n$$ \\text{SSR}(J_{max}, K_{0.5}, n_H) = \\sum_{i} \\left( J_i - J(S_i; J_{max}, K_{0.5}, n_H) \\right)^2 $$\n这是一个非线性最小二乘优化问题。我们将使用 `scipy.optimize.curve_fit` 函数，该函数实现了Levenberg-Marquardt算法或信赖域反射算法，以找到最小化SSR的参数值。\n\n#### 3. 算法实现\n\n对每个数据集的实现将按以下步骤进行：\n\n1.  **模型函数**：将定义一个实现希尔方程数值稳定形式的Python函数。它将显式处理 $S=0$ 的情况，以避免除以零并确保 $J(0) = 0$ 的正确输出。\n\n2.  **初始参数 ($p_0$)**：按要求，使用数据驱动的启发式方法为优化算法提供初始猜测值：\n    *   $J_{max, init}$：设置为略大于观察到的最大摄取速率的值，例如 $1.05 \\times \\max(J)$。这考虑了可能尚未达到完全饱和的数据集。\n    *   $K_{0.5, init}$：估计为观察到的摄取速率 $J_i$ 最接近 $0.5 \\times J_{max, init}$ 时的底物浓度 $S_i$。搜索范围限于 $S  0$ 的数据点。\n    *   $n_{H, init}$：选择一个中性起始值 $1.0$，代表非协同的米氏-门顿情况。\n\n3.  **参数边界**：为强制正性，所有三个参数（$J_{max}$、$K_{0.5}$、$n_H$）的下界都设置为 $0$，上界设置为无穷大。\n\n4.  **拟合**：使用模型函数、数据、初始参数和边界调用 `scipy.optimize.curve_fit`。\n\n此过程应用于数据集 $\\mathcal{A}$、$\\mathcal{B}$、$\\mathcal{C}$ 和 $\\mathcal{D}$。从每次拟合中得到的 $K_{0.5}$ 和 $n_H$ 的估计值被收集并格式化为最终输出字符串。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Fits a cooperative transporter model (Hill equation) to concentration-response data\n    to estimate the half-activation concentration (K_0.5) and the Hill coefficient (n_H).\n    \"\"\"\n    # Define the test cases as specified in the problem statement.\n    test_cases = [\n        # Dataset A\n        (np.array([0.5, 1, 2, 5, 10, 25, 50, 100]),\n         np.array([0.24937656, 0.99009901, 3.84615385, 20.0, 50.0, 86.20689655, 96.15384615, 99.00990099])),\n        # Dataset B\n        (np.array([3, 6, 12, 24, 48]),\n         np.array([10.0, 17.14285714, 26.66666667, 36.92307692, 45.71428571])),\n        # Dataset C\n        (np.array([5, 10, 20, 30, 50, 80, 120]),\n         np.array([0.06167046, 0.97560976, 13.19587629, 40.0, 70.96774194, 78.44654664, 79.76403026])),\n        # Dataset D\n        (np.array([0, 1, 5, 50]),\n         np.array([0.0, 1.92307692, 25.0, 49.5049505]))\n    ]\n\n    results = []\n\n    def hill_model(S, J_max, K_0_5, n_H):\n        \"\"\"\n        Numerically stable implementation of the Hill equation for cooperative binding.\n        J(S) = J_max / (1 + (K_0.5 / S)^n_H)\n        \"\"\"\n        # Create an output array initialized to zeros.\n        j_pred = np.zeros_like(S, dtype=float)\n        \n        # Identify where S  0 to avoid division by zero.\n        s_is_positive = S  0\n        \n        # Extract substrate concentrations that are positive.\n        S_pos = S[s_is_positive]\n        \n        # The optimizer may test K_0_5 at the boundary (0). This prevents a division by zero.\n        if K_0_5  0:\n            # Calculate the ratio K_0.5 / S for positive S values.\n            ratio = K_0_5 / S_pos\n            # Calculate the predicted J for these points using the stable formula.\n            j_pred[s_is_positive] = J_max / (1.0 + np.power(ratio, n_H))\n            \n        # For S=0, j_pred remains 0, which is the correct physical limit.\n        return j_pred\n\n    for s_data, j_data in test_cases:\n        # Heuristic for initial parameter guesses (p0) as required by the problem.\n        j_max_obs = np.max(j_data) if len(j_data)  0 else 0\n        \n        # p0 for J_max: A value slightly larger than the observed maximum.\n        p0_jmax = j_max_obs * 1.05 if j_max_obs  0 else 1.0\n\n        # p0 for K_0.5: Substrate concentration where J is closest to half of p0_jmax.\n        # This search is restricted to data points where S is positive.\n        half_max_j = p0_jmax / 2.0\n        \n        s_pos = s_data[s_data  0]\n        j_pos = j_data[s_data  0]\n        \n        if len(s_pos)  0:\n            k05_init_idx = np.argmin(np.abs(j_pos - half_max_j))\n            p0_k05 = s_pos[k05_init_idx]\n        else:\n            # Fallback if all S values are zero.\n            p0_k05 = 1.0\n\n        # Ensure K_0.5 initial guess is a small positive number, not zero.\n        p0_k05 = max(p0_k05, 1e-9)\n        \n        # p0 for n_H: A neutral value of 1.0.\n        p0_nh = 1.0\n\n        p0 = [p0_jmax, p0_k05, p0_nh]\n\n        # Define bounds to enforce positivity of all parameters, as required.\n        lower_bounds = [0.0, 0.0, 0.0]\n        upper_bounds = [np.inf, np.inf, np.inf]\n        \n        try:\n            # Perform nonlinear least squares fitting.\n            params, _ = curve_fit(\n                hill_model,\n                s_data,\n                j_data,\n                p0=p0,\n                bounds=(lower_bounds, upper_bounds),\n                maxfev=10000  # Increased iterations for robustness.\n            )\n            # The returned parameters are (J_max, K_0.5, n_H).\n            _, k05_fit, nh_fit = params\n            results.extend([k05_fit, nh_fit])\n        except RuntimeError:\n            results.extend([np.nan, np.nan])\n\n    # Format the final output as a single-line, comma-separated list of decimal numbers.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "4331836"}, {"introduction": "在描述了协同性的宏观现象之后，我们自然会问：这种行为的分子机制是什么？Monod-Wyman-Changeux (MWC) 模型为变构调控提供了一个优雅的物理化学框架，它假设蛋白质在不同构象状态（T态和R态）之间存在预平衡。本练习将带你从第一性原理出发，推导 MWC 模型的核心方程——分数饱和度函数 $\\theta([L])$，并利用数值方法探索模型参数（如变构常数 $L_0$ 和构象选择性 $c$）如何共同决定蛋白质的结合曲线和协同程度 [@problem_id:4331823]。通过这个实践，你将深刻理解协同性是如何从蛋白质的构象动力学中涌现出来的。", "problem": "要求您实现并使用一个数值求解器，来解决一个由 Monod–Wyman–Changeux (MWC) 协同变构模型控制的配体结合系统。该系统模拟一种具有 $n$ 个相同配体结合位点的蛋白质，该蛋白质可以以两种构象存在：松弛态 $R$ 和紧张态 $T$。在没有配体的情况下，这两种状态处于快速平衡中，其构象平衡常数为 $L_0 = [T_0]/[R_0]$。配体与 $R$ 态和 $T$ 态结合的解离常数分别为 $K_R$ 和 $K_T$。定义 $c = K_R/K_T$ 和 $\\alpha = [L]/K_R$，其中 $[L]$ 是游离配体浓度。假设 $0  c \\leq 1$，因此 $R$ 态对配体的亲和力高于 $T$ 态。\n\n从结合多项式作为微观状态总和的定义以及质量作用定律出发，推导位点分数占据率 $\\theta([L])$ 作为 $[L]$, $n$, $L_0$, $K_R$ 和 $c$ 的函数的可计算表达式，不假定任何预先存在的 $\\theta([L])$ 封闭形式。然后，对于下面的每个测试用例，数值计算达到目标占据率 $\\theta^\\star = 0.5$ 所需的游离配体浓度 $[L]$（单位为 $\\mu\\mathrm{M}$），以及相应的由下式定义的局部希尔系数 $n_H$：\n$$\nn_H \\equiv \\left. \\frac{d \\ln\\!\\left( \\frac{\\theta}{1-\\theta} \\right)}{d \\ln [L]} \\right|_{\\theta=\\theta^\\star}.\n$$\n您必须使用在您找到的 $\\theta^\\star$ 对应的 $[L]$ 处，关于 $\\ln [L]$ 的导数，从 $\\theta([L])$ 数值计算 $n_H$。\n\n您可以使用的基本原理包括：结合平衡的质量作用定律、作为微观状态统计权重总和的配分函数（结合多项式）的定义，以及作为结合多项式对数对相应活度参数的导数的平均可观测量定义。不要使用或假定任何关于 $\\theta([L])$ 的最终“捷径”表达式；请从第一性原理推导它。\n\n数值和输出要求：\n- 对于每个测试用例，使用一种仅依赖于单调性的稳健区间法，在 $[L]  0$ 的范围内求解 $[L]$，使得 $\\theta([L]) = \\theta^\\star$。\n- 在找到的 $[L]$ 处，通过在 $\\ln [L]$ 标度上的数值稳定的对称有限差分来计算 $n_H$。\n- 将 $[L]$ 以 $\\mu\\mathrm{M}$ 为单位表示，将 $n_H$ 表示为无量纲数。将 $[L]$ 和 $n_H$ 都四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为 $[L]_1, n_{H,1}, [L]_2, n_{H,2}, \\dots$，其中下标表示测试用例的索引。\n\n要实现和求解的测试套件：\n1. $n = 4$, $L_0 = 10^4$, $K_R = 1\\,\\mu\\mathrm{M}$, $c = 0.1$, $\\theta^\\star = 0.5$.\n2. $n = 1$, $L_0 = 10^2$, $K_R = 1\\,\\mu\\mathrm{M}$, $c = 10^{-2}$, $\\theta^\\star = 0.5$.\n3. $n = 3$, $L_0 = 10^6$, $K_R = 2\\,\\mu\\mathrm{M}$, $c = 1$, $\\theta^\\star = 0.5$.\n4. $n = 6$, $L_0 = 10^8$, $K_R = 0.5\\,\\mu\\mathrm{M}$, $c = 10^{-2}$, $\\theta^\\star = 0.5$.\n5. $n = 4$, $L_0 = 10^{-2}$, $K_R = 1\\,\\mu\\mathrm{M}$, $c = 0.1$, $\\theta^\\star = 0.5$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$\"[x_1,y_1,x_2,y_2]\"$），其中每个 $x_i$ 是计算出的 $[L]$（单位为 $\\mu\\mathrm{M}$），每个 $y_i$ 是相应的 $n_H$，两者都按上述测试套件的顺序四舍五入到 $6$ 位小数。", "solution": "该问题要求从第一性原理推导 Monod-Wyman-Changeux (MWC) 模型的分数饱和度函数 $\\theta([L])$，然后通过数值实现来找到对应于目标饱和度 $\\theta^\\star=0.5$ 的配体浓度 $[L]$ 以及几个参数集的相关希尔系数 $n_H$。\n\n### 1. 分数饱和度函数 $\\theta([L])$ 的推导\n\nMWC 模型假设一个具有 $n$ 个相同且独立的配体结合位点的大分子，该大分子存在于两种不同的构象状态：松弛态 ($R$) 和紧张态 ($T$)。这些状态处于平衡中，由变构常数 $L_0 = [T_0]/[R_0]$ 表征，其中 $[T_0]$ 和 $[R_0]$ 是在没有配体 ($L$) 时这些状态的浓度。\n\n我们首先定义系统中每个可能微观状态的统计权重，相对于未结合的松弛态 $R_0$，其参考权重设为 $1$。一个微观状态由构象（$R$ 或 $T$）和结合的配体数目（$i$，从 $0$ 到 $n$）定义。\n\n配体与 $R$ 态以微观解离常数 $K_R$ 结合，与 $T$ 态以 $K_T$ 结合。设 $[L]$ 为游离配体浓度。为方便起见，定义归一化配体浓度 $\\alpha = [L]/K_R$。\n\n结合了 $i$ 个配体的 $R$ 态的浓度 $[R_i]$ 通过质量作用定律与 $[R_0]$ 相关联。对于 $n$ 个相同的位点，有 $\\binom{n}{i}$ 种方式来排列 $i$ 个配体。因此，平衡 $R_0 + iL \\rightleftharpoons R_i$ 给出：\n$$\n[R_i] = \\binom{n}{i} [R_0] \\left(\\frac{[L]}{K_R}\\right)^i = \\binom{n}{i} [R_0] \\alpha^i\n$$\n因此，$R_i$ 态相对于 $R_0$ 的统计权重是 $\\binom{n}{i} \\alpha^i$。\n\n类似地，对于 $T$ 态，浓度 $[T_i]$ 由下式给出：\n$$\n[T_i] = \\binom{n}{i} [T_0] \\left(\\frac{[L]}{K_T}\\right)^i\n$$\n使用 $L_0 = [T_0]/[R_0]$ 和定义 $c = K_R/K_T$，我们可以将其表示为相对于 $[R_0]$ 的形式：\n$$\n[T_i] = \\binom{n}{i} (L_0 [R_0]) \\left(\\frac{c[L]}{K_R}\\right)^i = \\binom{n}{i} L_0 [R_0] (c\\alpha)^i\n$$\n$T_i$ 态相对于 $R_0$ 的统计权重是 $L_0 \\binom{n}{i} (c\\alpha)^i$。\n\n结合多项式，或称配分函数 $P$，是所有可能微观状态的统计权重之和：\n$$\nP = \\sum_{i=0}^{n} (\\text{weight of } R_i) + \\sum_{i=0}^{n} (\\text{weight of } T_i) = \\sum_{i=0}^{n} \\binom{n}{i} \\alpha^i + L_0 \\sum_{i=0}^{n} \\binom{n}{i} (c\\alpha)^i\n$$\n应用二项式定理 $\\sum_{i=0}^{n} \\binom{n}{i} x^i = (1+x)^n$，我们得到结合多项式的封闭形式表达式：\n$$\nP = (1+\\alpha)^n + L_0(1+c\\alpha)^n\n$$\n\n分数饱和度 $\\theta$ 是每个蛋白质结合的平均配体数 $\\langle i \\rangle$ 除以总位点数 $n$。平均结合配体数可以从结合多项式推导得出：\n$$\n\\langle i \\rangle = \\frac{d(\\ln P)}{d(\\ln \\alpha)} = \\frac{\\alpha}{P}\\frac{dP}{d\\alpha}\n$$\n计算 $P$ 对 $\\alpha$ 的导数：\n$$\n\\frac{dP}{d\\alpha} = \\frac{d}{d\\alpha} \\left[ (1+\\alpha)^n + L_0(1+c\\alpha)^n \\right] = n(1+\\alpha)^{n-1} + L_0 n(1+c\\alpha)^{n-1}c\n$$\n将此代入 $\\langle i \\rangle$ 的表达式中：\n$$\n\\langle i \\rangle = \\frac{\\alpha}{P} \\left[ n(1+\\alpha)^{n-1} + L_0 n c (1+c\\alpha)^{n-1} \\right] = \\frac{n\\alpha(1+\\alpha)^{n-1} + nL_0 c\\alpha(1+c\\alpha)^{n-1}}{(1+\\alpha)^n + L_0(1+c\\alpha)^n}\n$$\n最后，分数饱和度 $\\theta([L]) = \\langle i \\rangle / n$ 是：\n$$\n\\theta([L]) = \\frac{\\alpha(1+\\alpha)^{n-1} + L_0 c\\alpha(1+c\\alpha)^{n-1}}{(1+\\alpha)^n + L_0(1+c\\alpha)^n} \\quad \\text{其中 } \\alpha = \\frac{[L]}{K_R}\n$$\n这就是从第一性原理推导出的所需 $\\theta$ 的可计算表达式。\n\n### 2. 数值计算策略\n\n**a. 求解 $\\theta^\\star = 0.5$ 时的 $[L]$**\n\n我们需要找到方程 $f([L]) = \\theta([L]) - 0.5 = 0$ 的根。函数 $\\theta([L])$ 随 $[L]$ 从 $\\theta(0)=0$ 单调递增至 $\\lim_{[L]\\to\\infty} \\theta([L])=1$。此性质保证了对于目标饱和度 $\\theta^\\star=0.5$，存在一个唯一的正根 $[L]$。\n\n指定了使用一种稳健的区间法。我们将使用 `scipy.optimize.brentq` 中实现的 Brent 方法，该方法高效且在给定初始区间 $[L_{low}, L_{high}]$（其中 $f(L_{low})$ 和 $f(L_{high})$ 符号相反）的情况下保证收敛。我们可以将 $L_{low}$ 设置为一个非常小的正值（或 $0$），此时 $f(L_{low})  0$。一个使 $f(L_{high})  0$ 的上界 $L_{high}$ 可以通过从一个猜测值（例如 $K_R$）开始并迭代地增加它直到符号改变来找到。\n\n**b. 计算希尔系数 $n_H$**\n\n局部希尔系数定义为：\n$$\nn_H = \\left. \\frac{d \\ln\\!\\left( \\frac{\\theta}{1-\\theta} \\right)}{d \\ln [L]} \\right|_{\\theta=\\theta^\\star}\n$$\n这将使用对称有限差分近似进行数值计算，该方法以其稳定性和准确性（二阶）而闻名。设 $y = \\ln [L]$ 和 $g(y) = \\ln(\\theta(e^y) / (1-\\theta(e^y)))$。导数 $g'(y)$ 近似为：\n$$\nn_H \\approx \\frac{g(y^\\star+h) - g(y^\\star-h)}{2h}\n$$\n其中 $y^\\star = \\ln [L]^\\star$ 是上一步中找到的配体浓度的自然对数，而 $h$ 是一个小的步长（例如 $h=10^{-8}$）。我们计算 $[L]_1 = [L]^\\star e^{-h}$ 和 $[L]_2 = [L]^\\star e^{h}$，计算相应的饱和度 $\\theta_1 = \\theta([L]_1)$ 和 $\\theta_2 = \\theta([L]_2)$，然后评估有限差分公式：\n$$\nn_H \\approx \\frac{\\ln\\left(\\frac{\\theta_2}{1-\\theta_2}\\right) - \\ln\\left(\\frac{\\theta_1}{1-\\theta_1}\\right)}{2h}\n$$\n为确保数值精度，尤其是在有限差分计算中，所有中间浮点运算将使用高精度数据类型（`numpy.longdouble`）执行。最终结果将按要求四舍五入到 $6$ 位小数。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef get_theta(L, n, L0, KR, c):\n    \"\"\"\n    Computes the fractional saturation (theta) for the MWC model.\n\n    Args:\n        L (np.longdouble): Free ligand concentration.\n        n (int): Number of binding sites.\n        L0 (float): Allosteric constant [T0]/[R0].\n        KR (float): Dissociation constant for the R state.\n        c (float): Ratio of dissociation constants, KR/KT.\n\n    Returns:\n        np.longdouble: The fractional saturation theta.\n    \"\"\"\n    if L = 0:\n        return np.longdouble(0.0)\n    \n    # Use longdouble for higher precision in intermediate calculations\n    L, KR, L0, c = np.longdouble(L), np.longdouble(KR), np.longdouble(L0), np.longdouble(c)\n    n = int(n)\n    \n    alpha = L / KR\n    \n    # Numerator of the theta expression\n    num_term_R = alpha * np.power(1 + alpha, n - 1)\n    num_term_T = L0 * c * alpha * np.power(1 + c * alpha, n - 1)\n    numerator = num_term_R + num_term_T\n\n    # Denominator of the theta expression\n    den_term_R = np.power(1 + alpha, n)\n    den_term_T = L0 * np.power(1 + c * alpha, n)\n    denominator = den_term_R + den_term_T\n    \n    if denominator == 0:\n        # This case is unlikely with positive parameters\n        return np.nan\n        \n    return numerator / denominator\n\ndef solve_L_for_theta_star(theta_star, n, L0, KR, c):\n    \"\"\"\n    Solves for the ligand concentration [L] that yields a target saturation.\n\n    Args:\n        theta_star (float): The target fractional saturation.\n        n, L0, KR, c: Parameters for the MWC model.\n\n    Returns:\n        np.longdouble: The ligand concentration [L] in micromolars.\n    \"\"\"\n    def root_func(L):\n        return get_theta(L, n, L0, KR, c) - theta_star\n    \n    # Establish a bracket [a, b] for the root finder\n    # Since theta(0) = 0, root_func(0) = -theta_star  0.\n    a = np.longdouble(0.0)\n    \n    # Find an upper bound b such that root_func(b) > 0\n    b = np.longdouble(KR if KR > 0 else 1.0) # Initial guess for the upper bound\n    \n    max_iter = 100\n    count = 0\n    while root_func(b) = 0 and count  max_iter:\n        b *= 10\n        count += 1\n    if count == max_iter:\n        raise RuntimeError(f\"Failed to find an upper bracket for the root. Params: n={n}, L0={L0}, KR={KR}, c={c}\")\n\n    # Use Brent's method for robust and efficient root finding\n    L_star = brentq(root_func, a, b, xtol=1e-15, rtol=1e-15)\n    return L_star\n\ndef get_hill_coeff(L_star, n, L0, KR, c):\n    \"\"\"\n    Numerically computes the Hill coefficient at a given ligand concentration.\n\n    Args:\n        L_star (np.longdouble): Ligand concentration at which to evaluate nH.\n        n, L0, KR, c: Parameters for the MWC model.\n\n    Returns:\n        np.longdouble: The local Hill coefficient nH.\n    \"\"\"\n    # Small step size in log-space for symmetric finite difference\n    h = np.longdouble(1e-8)\n    \n    L1 = L_star * np.exp(-h)\n    L2 = L_star * np.exp(h)\n    \n    theta1 = get_theta(L1, n, L0, KR, c)\n    theta2 = get_theta(L2, n, L0, KR, c)\n    \n    # Ensure theta values are within (0, 1) to avoid log domain errors\n    if not (0  theta1  1 and 0  theta2  1):\n        raise ValueError(f\"Theta values out of (0,1) for nH calc: theta1={theta1}, theta2={theta2}\")\n\n    # Numerator of the finite difference formula for d(ln(odds))/d(ln(L))\n    y1 = np.log(theta1 / (1 - theta1))\n    y2 = np.log(theta2 / (1 - theta2))\n    \n    # Symmetric finite difference formula\n    nH = (y2 - y1) / (2 * h)\n    return nH\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (n, L0, KR, c)\n        (4, 1e4, 1.0, 0.1),\n        (1, 1e2, 1.0, 1e-2),\n        (3, 1e6, 2.0, 1.0),\n        (6, 1e8, 0.5, 1e-2),\n        (4, 1e-2, 1.0, 0.1),\n    ]\n    theta_star = 0.5\n    \n    results = []\n    \n    for n, L0, KR, c in test_cases:\n        L_star = solve_L_for_theta_star(theta_star, n, L0, KR, c)\n        nH = get_hill_coeff(L_star, n, L0, KR, c)\n        \n        # Format results to 6 decimal places as required\n        results.append(f\"{float(L_star):.6f}\")\n        results.append(f\"{float(nH):.6f}\")\n\n    # Print the final output in the required single-line format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "4331823"}, {"introduction": "变构调控的重要性远不止于单个蛋白质，它更是细胞内复杂调控网络和信号通路功能的基础。当一个具有协同性的变构酶被整合到一个代谢网络中时，其非线性的 S 型响应可以产生复杂的系统级行为。本练习模拟了一个带有变构负反馈的分支代谢通路，要求你分析该系统的动力学特性 [@problem_id:4331910]。你将通过求解稳态、进行线性稳定性分析，最终揭示变构调控如何导致“双稳态”这一重要的非线性现象，从而使一个简单的生化途径转变为一个能够做出“开/关”决策的分子开关。", "problem": "考虑一个最小分支酶促途径，其中固定浓度的共同上游底物被转化为中间代谢物，然后分配到两个分支中，其中一个分支产生一个效应物，该效应物作为上游酶和分支酶的负变构调节剂 (NAM)。设底物浓度为常数，并用 $X$ 表示中间代谢物浓度，用 $A$ 表示效应物 (NAM) 浓度。该途径结构为：一个上游步骤，其有效流入中间产物的速率为 $v_0$，随后是两个消耗中间产物的流出步骤 $v_1$ 和 $v_2$。效应物 $A$ 与分支 $v_1$ 成比例生成，并通过一级动力学被清除。\n\n使用以下基本基础和假设，每项都是系统生物医学和生物化学动力学中广为接受的起点：\n- 中间产物的质量守恒意味着常微分方程 $dX/dt = v_0 - v_1 - v_2$。\n- 效应物平衡意味着 $dA/dt = \\alpha\\, v_1 - k_A A$，其中 $\\alpha$ 是化学计量产率， $k_A$ 是一级清除常数。\n- 单底物酶的 Michaelis–Menten 动力学：对于最大速率为 $V_{\\max}$ 和米氏常数为 $K_M$ 的酶，其速率作为底物 $S$ 的函数是 $V_{\\max}\\, S/(K_M + S)$。\n- 分支 $v_1$ 的 Hill 型协同性，Hill 系数为 $h$：速率为 $V_1\\, X^{h}/(K_1^{h} + X^{h})$。\n- 负变构调节表示为一个形式为 $1/(1 + (A/K_I)^{n})$ 的乘法抑制因子，作用于受影响酶的最大速率，其中 $K_I$ 是抑制常数， $n$ 是调节的 Hill（协同性）系数。\n\n假设上游底物浓度 $S_{\\text{in}}$ 恒定，且上游反应表现出 $A$ 的变构抑制。定义一个有效上游饱和因子 $V_s = V_0\\, S_{\\text{in}}/(K_0 + S_{\\text{in}})$。模型如下：\n- 上游流入：$v_0(A) = \\dfrac{V_s}{1 + \\left(\\dfrac{A}{K_{I0}}\\right)^{n_0}}$。\n- 具有协同性的分支 1 消耗：$v_1(X) = \\dfrac{V_1\\, X^{h}}{K_1^{h} + X^{h}}$。\n- 具有 Michaelis–Menten 和额外 $A$ 变构抑制的分支 2 消耗：$v_2(X,A) = \\dfrac{V_2\\, X}{K_2 + X}\\cdot \\dfrac{1}{1 + \\left(\\dfrac{A}{K_{I2}}\\right)^{n_2}}$。\n- 效应物平衡：$dA/dt = \\alpha\\, v_1(X) - k_A A$。\n\n所有浓度都必须视为非负实数。在整个过程中，将 $X$ 和 $A$ 解释为微摩尔单位 (micromolar)，时间单位为秒，速率单位为微摩尔/秒。任何计算出的通量必须以微摩尔/秒的数值表示。\n\n从上述质量平衡方程和动力学定义出发，执行以下操作：\n1) 通过施加 $dX/dt = 0$ 和 $dA/dt = 0$ 来推导 $(X^{\\ast}, A^{\\ast})$ 的稳态代数系统。\n2) 对于给定的参数集，计算求解稳态方程的所有不同非负稳态 $(X^{\\ast}, A^{\\ast})$。对于每个稳态，计算二维动力系统在 $(X^{\\ast}, A^{\\ast})$ 处的雅可比矩阵，并通过其特征值的实部符号确定局部渐近稳定性。\n3) 对于每个局部渐近稳定的稳态，计算稳态通量 $J_0 = v_0(A^{\\ast})$、$J_1 = v_1(X^{\\ast})$ 和 $J_2 = v_2(X^{\\ast},A^{\\ast})$。\n4) 确定参数集是否表现出双稳态，此处操作性地定义为存在至少两个不同的局部渐近稳定稳态。\n\n您必须实现一个程序，对以下测试套件参数集进行数值化执行上述步骤。在每种情况下，将 $S_{\\text{in}}$ 视为常数，并在模型中构建 $V_s = V_0\\, S_{\\text{in}}/(K_0 + S_{\\text{in}})$，而不是作为一个独立的参数。\n\n- 测试案例 1（基线，预期的单稳态区域）：\n  - $S_{\\text{in}} = 10$ 微摩尔, $V_0 = 6$ 微摩尔/秒, $K_0 = 5$ 微摩尔, $K_{I0} = 100$ 微摩尔, $n_0 = 2$。\n  - $V_1 = 2.0$ 微摩尔/秒, $K_1 = 1.0$ 微摩尔, $h = 2$。\n  - $V_2 = 1.5$ 微摩尔/秒, $K_2 = 1.0$ 微摩尔。\n  - $K_{I2} = 1000000$ 微摩尔, $n_2 = 2$。\n  - $\\alpha = 1.0$, $k_A = 0.5$ /秒。\n\n- 测试案例 2（具有更强非线性和反馈的边缘区域）：\n  - $S_{\\text{in}} = 10$ 微摩尔, $V_0 = 10$ 微摩尔/秒, $K_0 = 5$ 微摩尔, $K_{I0} = 50$ 微摩尔, $n_0 = 2$。\n  - $V_1 = 3.5$ 微摩尔/秒, $K_1 = 1.0$ 微摩尔, $h = 3$。\n  - $V_2 = 2.5$ 微摩尔/秒, $K_2 = 1.0$ 微摩尔。\n  - $K_{I2} = 6.0$ 微摩尔, $n_2 = 4$。\n  - $\\alpha = 1.2$, $k_A = 0.25$ /秒。\n\n- 测试案例 3（强非线性，可能是双稳态区域）：\n  - $S_{\\text{in}} = 10$ 微摩尔, $V_0 = 12$ 微摩尔/秒, $K_0 = 5$ 微摩尔, $K_{I0} = 40$ 微摩尔, $n_0 = 2$。\n  - $V_1 = 4.5$ 微摩尔/秒, $K_1 = 0.8$ 微摩尔, $h = 4$。\n  - $V_2 = 2.0$ 微摩尔/秒, $K_2 = 0.8$ 微摩尔。\n  - $K_{I2} = 2.5$ 微摩尔, $n_2 = 4$。\n  - $\\alpha = 1.5$, $k_A = 0.2$ /秒。\n\n算法要求和数值规范：\n- 通过找到由 $dX/dt$ 和 $dA/dt$ 的右侧定义的向量函数的所有根来求解稳态方程。在 $(X,A)$ 的合理二维网格上使用多个初始猜测来探索状态空间，并通过欧几里得范数中的一个小的容差来去重根。\n- 通过丢弃任何具有负分量或残差范数高于小容差的候选根来强制执行非负约束。\n- 对于每个候选稳态，计算完整二维系统在该点的雅可比矩阵，并通过特征值对其稳定性进行分类。\n- 对于每个稳定稳态，计算通量三元组 $(J_0, J_1, J_2)$。\n- 对于每个测试案例，按 $X^{\\ast}$ 递增的顺序对稳定稳态进行排序，然后以相同的顺序列出相应的通量三元组。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表，每个测试案例对应一个条目。每个条目必须是一个固定长度为 10 的列表，其第一个元素是找到的局部渐近稳定稳态的整数数量，后跟九个浮点数，对应于最多三个稳定稳态的 $(J_0,J_1,J_2)$（按 $X^{\\ast}$ 递增的顺序）；如果找到的稳定稳态少于三个，则用哨兵值 $-1.0$ 填充剩余的通量条目。\n- 输出中的所有浮点数必须四舍五入到小数点后六位。\n- 单行输出必须是语法有效的列表的列表字符串，例如 $[\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$ 并用逗号分隔。\n\n您的程序必须使用上述测试套件，并按规定生成单行输出。不允许用户输入，也不允许访问外部数据文件或网络。", "solution": "该问题要求对一个代表具有变构调节的分支代谢途径的二维动力系统进行综合分析。该分析涉及推导稳态条件，数值计算所有非负稳态，评估它们的局部渐近稳定性，并计算相应的代谢通量。\n\n系统的状态由中间代谢物浓度 $X$ 和变构效应物浓度 $A$ 描述。动力学由一个基于质量守恒原理的耦合常微分方程(ODE)系统控制：\n$$\n\\frac{dX}{dt} = v_0(A) - v_1(X) - v_2(X, A) \\equiv F(X, A)\n$$\n$$\n\\frac{dA}{dt} = \\alpha\\, v_1(X) - k_A A \\equiv G(X, A)\n$$\n其中，组分速率函数由以下公式给出：\n- 上游流入：$v_0(A) = \\dfrac{V_s}{1 + \\left(\\dfrac{A}{K_{I0}}\\right)^{n_0}}$，其中 $V_s = \\dfrac{V_0\\, S_{\\text{in}}}{K_0 + S_{\\text{in}}}$。\n- 分支 1 消耗：$v_1(X) = \\dfrac{V_1\\, X^{h}}{K_1^{h} + X^{h}}$。\n- 分支 2 消耗：$v_2(X,A) = \\dfrac{V_2\\, X}{K_2 + X} \\cdot \\dfrac{1}{1 + \\left(\\dfrac{A}{K_{I2}}\\right)^{n_2}}$。\n\n**步骤 1：推导稳态代数系统**\n\n稳态，表示为 $(X^{\\ast}, A^{\\ast})$，是状态空间中系统停止演化的一个点，即所有时间导数均为零的点。我们施加条件 $dX/dt = 0$ 和 $dA/dt = 0$：\n$$\nF(X^{\\ast}, A^{\\ast}) = v_0(A^{\\ast}) - v_1(X^{\\ast}) - v_2(X^{\\ast}, A^{\\ast}) = 0\n$$\n$$\nG(X^{\\ast}, A^{\\ast}) = \\alpha\\, v_1(X^{\\ast}) - k_A A^{\\ast} = 0\n$$\n这是稳态浓度 $(X^{\\ast}, A^{\\ast})$ 的代数系统。从第二个方程，我们可以将 $A^{\\ast}$ 表示为 $X^{\\ast}$ 的显式函数：\n$$\nA^{\\ast}(X^{\\ast}) = \\frac{\\alpha}{k_A} v_1(X^{\\ast}) = \\frac{\\alpha}{k_A} \\frac{V_1\\, (X^{\\ast})^{h}}{K_1^{h} + (X^{\\ast})^{h}}\n$$\n这种关系被称为变量 $A$ 的零斜线。将这个 $A^{\\ast}$ 的表达式代入第一个稳态方程，消去 $A^{\\ast}$，得到一个单变量 $X^{\\ast}$ 的高度非线性方程：\n$$\nv_0(A^{\\ast}(X^{\\ast})) - v_1(X^{\\ast}) - v_2(X^{\\ast}, A^{\\ast}(X^{\\ast})) = 0\n$$\n该方程的根对应于系统稳态的 $X$ 坐标。我们必须找到所有物理上有意义的根，即非负实数 $X^{\\ast} \\ge 0$。\n\n**步骤 2：局部渐近稳定性分析**\n\n为了确定稳态 $(X^{\\ast}, A^{\\ast})$ 的局部渐近稳定性，我们分析系统在该点附近的行为。这通过线性化常微分方程组来实现，这涉及计算向量场 $(F, G)$ 在稳态下的雅可比矩阵 $J$：\n$$\nJ(X, A) = \\begin{pmatrix} \\frac{\\partial F}{\\partial X}  \\frac{\\partial F}{\\partial A} \\\\ \\frac{\\partial G}{\\partial X}  \\frac{\\partial G}{\\partial A} \\end{pmatrix} = \\begin{pmatrix} -\\frac{\\partial v_1}{\\partial X} - \\frac{\\partial v_2}{\\partial X}  \\frac{\\partial v_0}{\\partial A} - \\frac{\\partial v_2}{\\partial A} \\\\ \\alpha \\frac{\\partial v_1}{\\partial X}  -k_A \\end{pmatrix}\n$$\n一个稳态 $(X^{\\ast}, A^{\\ast})$ 是局部渐近稳定的，当且仅当雅可比矩阵 $J(X^{\\ast}, A^{\\ast})$ 的所有特征值的实部为负。所需的偏导数是：\n- $\\frac{\\partial v_0}{\\partial A} = -V_s \\frac{n_0}{K_{I0}} \\left(\\frac{A}{K_{I0}}\\right)^{n_0-1} \\left(1 + \\left(\\frac{A}{K_{I0}}\\right)^{n_0}\\right)^{-2}$\n- $\\frac{\\partial v_1}{\\partial X} = V_1 \\frac{h K_1^h X^{h-1}}{(K_1^h + X^h)^2}$\n- $\\frac{\\partial v_2}{\\partial X} = \\frac{V_2 K_2}{(K_2 + X)^2} \\frac{1}{1 + \\left(\\frac{A}{K_{I2}}\\right)^{n_2}}$\n- $\\frac{\\partial v_2}{\\partial A} = -\\frac{V_2 X}{K_2 + X} \\frac{n_2}{K_{I2}} \\left(\\frac{A}{K_{I2}}\\right)^{n_2-1} \\left(1 + \\left(\\frac{A}{K_{I2}}\\right)^{n_2}\\right)^{-2}$\n\n对于每个有效的根 $X^{\\ast}$，我们计算相应的 $A^{\\ast}$，在 $(X^{\\ast}, A^{\\ast})$ 处评估偏导数，构建雅可比矩阵，并计算其特征值。如果对于所有特征值 $\\lambda_i$，都有 $\\text{Re}(\\lambda_i)  0$，则该稳态是稳定的。\n\n**步骤 3：计算稳态通量**\n\n对于找到的每个局部渐近稳定的稳态 $(X^{\\ast}, A^{\\ast})$，我们计算通过途径每一步的稳态通量（反应速率）：\n- 流入通量：$J_0 = v_0(A^{\\ast})$\n- 分支 1 通量：$J_1 = v_1(X^{\\ast})$\n- 分支 2 通量：$J_2 = v_2(X^{\\ast}, A^{\\ast})$\n根据第一个稳态方程，必须满足 $J_0 = J_1 + J_2$。这可作为数值解的一致性检查。\n\n**步骤 4：识别双稳态**\n\n双稳态被定义为对于同一组参数存在至少两个不同的、局部渐近稳定的稳态。数值程序将计算找到的稳定稳态的数量。如果此计数为两个或更多，则系统被分类为双稳态。\n\n**数值实现策略**\n\n问题的核心是找到单变量方程 $H(X) = v_0(A(X)) - v_1(X) - v_2(X, A(X)) = 0$ 的所有非负根。这将通过在足够大的 $X  0$ 区间上扫描 $H(X)$ 的符号变化来完成。对于每个 $H(x_i)H(x_{i+1})  0$ 的区间 $[x_i, x_{i+1}]$，应用稳健的数值求根算法（例如 Brent 方法）来找到根 $X^{\\ast}$。找到的根将被去重。\n对于每个唯一的、非负的根 $X^{\\ast}$（及其对应的 $A^{\\ast} \\ge 0$），通过雅可比矩阵的特征值评估其稳定性。然后计算所有稳定状态的通量，并按照指定的输出格式报告。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the metabolic pathway problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (baseline, expected monostable regime)\n        {\n            'S_in': 10.0, 'V0': 6.0, 'K0': 5.0, 'KI0': 100.0, 'n0': 2.0,\n            'V1': 2.0, 'K1': 1.0, 'h': 2.0,\n            'V2': 1.5, 'K2': 1.0, 'KI2': 1000000.0, 'n2': 2.0,\n            'alpha': 1.0, 'kA': 0.5\n        },\n        # Test Case 2 (edge regime with stronger nonlinearity and feedbacks)\n        {\n            'S_in': 10.0, 'V0': 10.0, 'K0': 5.0, 'KI0': 50.0, 'n0': 2.0,\n            'V1': 3.5, 'K1': 1.0, 'h': 3.0,\n            'V2': 2.5, 'K2': 1.0, 'KI2': 6.0, 'n2': 4.0,\n            'alpha': 1.2, 'kA': 0.25\n        },\n        # Test Case 3 (strongly nonlinear, likely bistable regime)\n        {\n            'S_in': 10.0, 'V0': 12.0, 'K0': 5.0, 'KI0': 40.0, 'n0': 2.0,\n            'V1': 4.5, 'K1': 0.8, 'h': 4.0,\n            'V2': 2.0, 'K2': 0.8, 'KI2': 2.5, 'n2': 4.0,\n            'alpha': 1.5, 'kA': 0.2\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = _analyze_case(params)\n        all_results.append(result)\n\n    # Format output\n    output_str = \"[\"\n    for i, res_list in enumerate(all_results):\n        output_str += \"[\"\n        # Add num stable states\n        output_str += str(res_list[0])\n        # Add fluxes\n        if len(res_list) > 1:\n            formatted_fluxes = [f\"{f:.6f}\" for f in res_list[1]]\n            output_str += \",\" + \",\".join(formatted_fluxes)\n        \n        output_str += \"]\"\n        if i  len(all_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    # Replace single quotes from Python list repr with double quotes if any, and remove spaces\n    final_output = output_str.replace(\"'\", '\"').replace(\" \", \"\")\n    \n    print(final_output)\n\n\ndef _analyze_case(params):\n    \"\"\"\n    Analyzes a single parameter set to find stable steady states and fluxes.\n    \"\"\"\n    S_in, V0, K0, KI0, n0 = params['S_in'], params['V0'], params['K0'], params['KI0'], params['n0']\n    V1, K1, h = params['V1'], params['K1'], params['h']\n    V2, K2, KI2, n2 = params['V2'], params['K2'], params['KI2'], params['n2']\n    alpha, kA = params['alpha'], params['kA']\n\n    Vs = V0 * S_in / (K0 + S_in)\n\n    # Rate functions\n    def v0(A):\n        if A  0: A = 0\n        return Vs / (1 + (A / KI0)**n0)\n\n    def v1(X):\n        if X  0: X = 0\n        return V1 * (X**h) / (K1**h + X**h)\n\n    def v2(X, A):\n        if X  0: X = 0\n        if A  0: A = 0\n        inhib_factor = 1 / (1 + (A / KI2)**n2)\n        return (V2 * X / (K2 + X)) * inhib_factor\n\n    # Relationship A(X) from dA/dt = 0\n    def A_of_X(X):\n        return (alpha / kA) * v1(X)\n\n    # Root finding function H(X) = 0\n    def H(X):\n        if X  0: return float('inf') # Penalize negative domain\n        A = A_of_X(X)\n        return v0(A) - v1(X) - v2(X, A)\n\n    # --- Find Roots ---\n    roots = []\n    scan_points = np.logspace(-3, 2, 5000)\n    for i in range(len(scan_points) - 1):\n        x1, x2 = scan_points[i], scan_points[i+1]\n        try:\n            h1, h2 = H(x1), H(x2)\n            if h1 * h2  0:\n                root = brentq(H, x1, x2, xtol=1e-12, rtol=1e-12)\n                if root >= 0 and abs(H(root))  1e-9:\n                    # Deduplicate\n                    is_new_root = True\n                    for r in roots:\n                        if np.isclose(root, r, atol=1e-8):\n                            is_new_root = False\n                            break\n                    if is_new_root:\n                        roots.append(root)\n        except (ValueError, RuntimeError):\n            continue\n    \n    # --- Stability Analysis ---\n    # Partial derivatives for Jacobian\n    def dv0_dA(A):\n        if A = 0: return 0.0\n        term_A_KI0 = A / KI0\n        return -Vs * n0 / KI0 * (term_A_KI0**(n0-1)) / (1 + term_A_KI0**n0)**2\n\n    def dv1_dX(X):\n        if X = 0: return 0.0\n        return V1 * h * (K1**h) * (X**(h-1)) / (K1**h + X**h)**2\n        \n    def dv2_dX(X, A):\n        if X  0: X=0\n        if A  0: A=0\n        inhib_factor = 1 / (1 + (A / KI2)**n2)\n        return (V2 * K2 / (K2 + X)**2) * inhib_factor\n\n    def dv2_dA(X, A):\n        if X  0: X=0\n        if A = 0: return 0.0\n        term_A_KI2 = A / KI2\n        rate_part = V2 * X / (K2 + X)\n        return -rate_part * (n2 / KI2) * (term_A_KI2**(n2-1)) / (1 + term_A_KI2**n2)**2\n\n    stable_states = []\n    for X_star in roots:\n        A_star = A_of_X(X_star)\n        \n        # Jacobian elements\n        J11 = -dv1_dX(X_star) - dv2_dX(X_star, A_star)\n        J12 = dv0_dA(A_star) - dv2_dA(X_star, A_star)\n        J21 = alpha * dv1_dX(X_star)\n        J22 = -kA\n        \n        jacobian = np.array([[J11, J12], [J21, J22]])\n        \n        eigenvalues = np.linalg.eigvals(jacobian)\n        \n        if np.all(np.real(eigenvalues)  0):\n            J0 = v0(A_star)\n            J1 = v1(X_star)\n            J2 = v2(X_star, A_star)\n            stable_states.append({'X_star': X_star, 'fluxes': (J0, J1, J2)})\n\n    # Sort stable states by X_star\n    stable_states.sort(key=lambda s: s['X_star'])\n\n    # Format output for this case\n    num_stable = len(stable_states)\n    flux_list = []\n    for state in stable_states:\n        flux_list.extend(state['fluxes'])\n        \n    # Pad with -1.0 up to 3 stable states (9 flux values)\n    padding_needed = 9 - len(flux_list)\n    if padding_needed > 0:\n        flux_list.extend([-1.0] * padding_needed)\n\n    return [num_stable, flux_list[:9]]\n\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "4331910"}]}