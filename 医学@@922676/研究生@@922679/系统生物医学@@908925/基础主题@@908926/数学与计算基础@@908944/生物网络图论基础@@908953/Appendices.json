{"hands_on_practices": [{"introduction": "在基因调控网络中，反馈回路等网络基序（network motifs）对决定细胞动态行为至关重要。一个优雅的图论结果表明，我们可以通过计算邻接矩阵立方的迹（$\\mathrm{tr}(A^3)$）来量化网络中长度为3的有向环路数量。这项练习将通过一个具体案例，帮助你掌握如何运用矩阵代数来识别和计数生物网络中的关键结构基序[@problem_id:4349908]。", "problem": "考虑一个由六个转录因子（TF）组成的有向基因调控网络，该网络由一个简单有向图（无自环且无多重边）建模，其结构由一个 $6 \\times 6$ 的邻接矩阵 $A$ 编码。其中，如果存在从 TF $i$ 到 TF $j$ 的有向相互作用，则 $A_{ij} = 1$，否则 $A_{ij} = 0$。矩阵 $A$ 如下所示：\n$$\nA \\;=\\;\n\\begin{pmatrix}\n0  1  0  0  1  0 \\\\\n0  0  1  1  0  1 \\\\\n1  0  0  1  0  0 \\\\\n0  1  0  0  1  0 \\\\\n0  0  1  0  0  1 \\\\\n1  0  0  1  0  0\n\\end{pmatrix}.\n$$\n仅使用图论中关于邻接矩阵和有向图中游走的核心定义和公认事实，推导量 $\\mathrm{tr}(A^{3})$ 如何揭示该网络中存在的有向 $3$-环路（三节点反馈回路）。然后对给定的 $A$ 计算 $\\mathrm{tr}(A^{3})$ 的值。您的最终答案必须是 $\\mathrm{tr}(A^{3})$ 的值，表示为一个实数。此外，作为推导的一部分，请简要论证有向 $3$-环路在系统生物医学中的生物学意义。最终数值答案中不要包含任何单位。", "solution": "该问题要求推导邻接矩阵立方的迹 $\\mathrm{tr}(A^3)$ 与图中定向 $3$-环路数量之间的关系，然后对一个特定的基因调控网络计算该值。\n\n首先，我们建立理论基础。图论中的一个基本结果表明，对于一个具有 $n$ 个节点和邻接矩阵 $A$ 的简单有向图，矩阵幂 $A^k$ 的第 $(i,j)$ 个元素 $(A^k)_{ij}$ 给出了从节点 $i$ 到节点 $j$ 的长度为 $k$ 的不同游走（walk）的数量。长度为 $k$ 的游走是一个包含 $k+1$ 个节点的序列 $v_0, v_1, \\dots, v_k$，使得对于所有的 $m \\in \\{1, \\dots, k\\}$，都存在一条从 $v_{m-1}$ 到 $v_m$ 的有向边。\n\n对于 $k=3$，元素 $(A^3)_{ij}$ 是从节点 $i$ 到节点 $j$ 的长度为 $3$ 的不同游走数量。矩阵 $A^3$ 是 $A^2$ 和 $A$ 的乘积，其中 $(A^2)_{ip} = \\sum_{q=1}^{n} A_{iq}A_{qp}$。因此，$A^3$ 的元素由以下公式给出：\n$$ (A^3)_{ij} = \\sum_{p=1}^{n} (A^2)_{ip} A_{pj} = \\sum_{p=1}^{n} \\left( \\sum_{q=1}^{n} A_{iq}A_{qp} \\right) A_{pj} = \\sum_{p=1}^{n}\\sum_{q=1}^{n} A_{iq}A_{qp}A_{pj} $$\n该表达式计算了形如 $i \\to q \\to p \\to j$ 的游走数量。\n\n$A^3$ 的迹，记作 $\\mathrm{tr}(A^3)$，是 $A^3$ 对角线元素之和：\n$$ \\mathrm{tr}(A^3) = \\sum_{i=1}^{n} (A^3)_{ii} $$\n代入对角线元素的表达式，我们得到：\n$$ \\mathrm{tr}(A^3) = \\sum_{i=1}^{n} \\sum_{p=1}^{n}\\sum_{q=1}^{n} A_{iq}A_{qp}A_{pi} $$\n每一项 $A_{iq}A_{qp}A_{pi}$ 等于 $1$ 当且仅当边序列 $(i, q)$、$(q, p)$ 和 $(p, i)$ 均存在于图中，形成一个长度为 $3$ 的闭合游走：$i \\to q \\to p \\to i$。否则，该项为 $0$。因此，$\\mathrm{tr}(A^3)$ 计算了图中长度为 $3$ 的闭合游走的总数。\n\n让我们来分析长度为 $3$ 的闭合游走的类型：\n一个游走 $i \\to q \\to p \\to i$ 可以有重复的节点。\n1. 所有节点都相同：$i=p=q$。游走为 $i \\to i \\to i \\to i$。它的存在需要 $A_{ii}=1$。然而，问题陈述中说明该图没有自环，这一点由给定的矩阵 $A$ 的所有对角线元素都为 $0$ 所证实。因此，这种类型的游走在我们的网络中不存在。\n2. 两个节点相同（例如，$i=p$，$p \\neq q$）。游走为 $i \\to q \\to i \\to i$。这将需要一条从 $i$ 到 $i$ 的边，因此 $A_{ii}=1$，而事实并非如此。同样的逻辑也适用于 $i=q$ 或 $p=q$ 的情况（例如，$i \\to p \\to p \\to i$ 需要 $A_{pp}=1$）。\n3. 所有三个节点 $i, p, q$ 均不相同。游走 $i \\to q \\to p \\to i$ 是一个长度为 $3$ 的有向环路，也称为 $3$-环路。\n\n由于没有自环排除了有重复节点的游走，所以量 $\\mathrm{tr}(A^3)$ 只计算了所有三个节点都不同的长度为 $3$ 的闭合游走。每个这样的游走都对应一个唯一的有向 $3$-环路。一个特定的 $3$-环路，比如说涉及节点 $\\{v_1, v_2, v_3\\}$ 且包含边 $(v_1, v_2)$、$(v_2, v_3)$ 和 $(v_3, v_1)$，在计算 $\\mathrm{tr}(A^3)$ 的总和时将被计数三次：\n- 作为闭合游走 $v_1 \\to v_2 \\to v_3 \\to v_1$ 被计数一次（当 $i=v_1$ 时）。\n- 作为闭合游走 $v_2 \\to v_3 \\to v_1 \\to v_2$ 被计数一次（当 $i=v_2$ 时）。\n- 作为闭合游走 $v_3 \\to v_1 \\to v_2 \\to v_3$ 被计数一次（当 $i=v_3$ 时）。\n\n因此，$\\mathrm{tr}(A^3)$ 等于图中有向 $3$-环路数量的 $3$ 倍。如果我们用 $N_3$ 表示 $3$-环路的数量，则有 $\\mathrm{tr}(A^3) = 3 N_3$。这就证明了该量如何揭示这些结构的存在和丰度。\n\n在系统生物医学中，有向环路是被称为反馈回路的基本网络模体（motif）。一个 $3$-环路代表一个三组分反馈回路（例如，TF $1$ 调控 TF $2$，TF $2$ 调控 TF $3$，而 TF $3$ 反过来调控 TF $1$）。这类模体具有深远的生物学意义，因为它们是复杂动态行为的关键构建模块。例如，负反馈回路（含有奇数个抑制性相互作用的回路）对于促进稳定性和体内平衡至关重要。正反馈回路（含有偶数个抑制性相互作用的回路）可以产生双稳态，使细胞能够在不同的功能状态之间切换，这是细胞分化的核心过程。正负反馈的相互作用可以产生振荡，这是细胞周期和生物钟等生物节律的基础。因此，识别和量化 $3$-环路是解析基因调控网络功能逻辑的关键一步。\n\n现在，我们为给定的邻接矩阵 $A$ 计算 $\\mathrm{tr}(A^3)$：\n$$ A = \\begin{pmatrix} 0  1  0  0  1  0 \\\\ 0  0  1  1  0  1 \\\\ 1  0  0  1  0  0 \\\\ 0  1  0  0  1  0 \\\\ 0  0  1  0  0  1 \\\\ 1  0  0  1  0  0 \\end{pmatrix} $$\n首先，我们计算 $A^2 = A \\times A$：\n$$ A^2 = \\begin{pmatrix} 0  1  0  0  1  0 \\\\ 0  0  1  1  0  1 \\\\ 1  0  0  1  0  0 \\\\ 0  1  0  0  1  0 \\\\ 0  0  1  0  0  1 \\\\ 1  0  0  1  0  0 \\end{pmatrix} \\begin{pmatrix} 0  1  0  0  1  0 \\\\ 0  0  1  1  0  1 \\\\ 1  0  0  1  0  0 \\\\ 0  1  0  0  1  0 \\\\ 0  0  1  0  0  1 \\\\ 1  0  0  1  0  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  2  1  0  2 \\\\ 2  1  0  2  1  0 \\\\ 0  2  0  0  2  0 \\\\ 0  0  2  1  0  2 \\\\ 2  0  0  2  0  0 \\\\ 0  2  0  0  2  0 \\end{pmatrix} $$\n接下来，我们计算 $A^3 = A^2 \\times A$。为了求迹，我们只需要对角线元素。$A^3$ 的第 $i$ 个对角线元素 $(A^3)_{ii}$ 是 $A^2$ 的第 $i$ 行与 $A$ 的第 $i$ 列的点积。\n$(A^3)_{11} = (0)(0) + (0)(0) + (2)(1) + (1)(0) + (0)(0) + (2)(1) = 2+2=4$\n$(A^3)_{22} = (2)(1) + (1)(0) + (0)(0) + (2)(1) + (1)(0) + (0)(0) = 2+2=4$\n$(A^3)_{33} = (0)(0) + (2)(1) + (0)(0) + (0)(0) + (2)(1) + (0)(0) = 2+2=4$\n$(A^3)_{44} = (0)(0) + (0)(1) + (2)(1) + (1)(0) + (0)(0) + (2)(1) = 2+2=4$\n$(A^3)_{55} = (2)(1) + (0)(0) + (0)(0) + (2)(1) + (0)(0) + (0)(0) = 2+2=4$\n$(A^3)_{66} = (0)(0) + (2)(1) + (0)(0) + (0)(0) + (2)(1) + (0)(0) = 2+2=4$\n\n$A^3$ 的对角线元素都等于 $4$。迹是这些元素的和：\n$$ \\mathrm{tr}(A^3) = \\sum_{i=1}^{6} (A^3)_{ii} = 4 + 4 + 4 + 4 + 4 + 4 = 6 \\times 4 = 24 $$\n$\\mathrm{tr}(A^3)$ 的值为 $24$。这表明在这个基因调控网络中，存在 $N_3 = \\frac{24}{3} = 8$ 个不同的有向 $3$-环路。", "answer": "$$\\boxed{24}$$", "id": "4349908"}, {"introduction": "除了局部结构，理解生物系统的整体约束也同样重要，尤其是在代谢网络中。质量守恒定律在化学反应网络中表现为一系列线性守恒关系，这些关系限制了系统可能达到的状态。本练习将指导你如何构建化学计量矩阵，并通过求解其左零空间来系统地推导出网络中所有独立的守恒律[@problem_id:4349885]。", "problem": "考虑一个化学反应网络（CRN），该网络表示为一个有向图，其节点为化学物种，其边为沿链传递单个守恒基团的反应。物种为 $A$、$B$、$C$ 和 $D$，反应为 $R_{1}: A \\to B$、$R_{2}: B \\to C$ 和 $R_{3}: C \\to D$。化学计量矩阵 $N \\in \\mathbb{R}^{4 \\times 3}$ 将反应通量映射到物种浓度的变化，并由每个反应中各物种的净化学计量变化定义（反应物为负，产物为正）。仅使用图论和化学反应网络质量平衡定律的基本定义，执行以下操作：\n\n- 构建该网络的化学计量矩阵 $N$。\n- 通过从第一性原理推导其基和维数，计算化学计量子空间 $\\mathcal{S} = \\mathrm{im}(N)$。\n- 通过强制守恒线性组合在由 $N$ 诱导的所有反应通量下保持不变的条件，推导出所有独立的线性守恒律，这些守恒律是正交补 $\\mathcal{S}^{\\perp}$（等效于左零空间 $\\ker(N^{\\top})$）中的向量。\n- 选择唯一的非零守恒律向量 $c \\in \\mathcal{S}^{\\perp}$，并将其归一化，使其分量之和等于 $1$。\n\n仅报告归一化后的守恒律向量 $c$ 作为最终答案。将最终答案表示为单个 $1 \\times 4$ 的行向量，使用精确的有理数。不允许进行四舍五入。不要包含单位。", "solution": "该任务是为一个给定的化学反应网络确定一个特定的、归一化的守恒律向量。守恒律是物种浓度的线性组合，无论反应速率如何，该组合都随时间保持恒定。\n\n设物种浓度向量为 $x = ([A], [B], [C], [D])^{\\top}$。这些浓度随时间的演化由质量平衡方程 $\\frac{dx}{dt} = Nv$ 控制，其中 $N$ 是化学计量矩阵，$v$ 是反应通量向量。\n\n线性守恒律由向量 $c$ 定义，使得量 $c^{\\top}x$ 是常数。其时间导数必须为零：\n$$ \\frac{d}{dt}(c^{\\top}x) = c^{\\top}\\frac{dx}{dt} = c^{\\top}N v = 0 $$\n为了使该式对任意反应通量向量 $v$ 成立，必须有 $c^{\\top}N = \\mathbf{0}^{\\top}$。这等价于条件 $N^{\\top}c = \\mathbf{0}$，即 $c$ 必须属于 $N$ 的左零空间，记作 $\\ker(N^{\\top})$。$N$ 的左零空间是其列空间（化学计量子空间 $\\mathcal{S}$）的正交补，即 $\\ker(N^{\\top}) = (\\mathrm{im}(N))^{\\perp} = \\mathcal{S}^{\\perp}$。\n\n第一步是构建化学计量矩阵 $N$。物种按 $(A, B, C, D)$ 排序，对应于行；反应按 $(R_1, R_2, R_3)$ 排序，对应于列。$N$ 的维度是 $4 \\times 3$。条目 $N_{ij}$ 表示由于一个单位的反应 $j$ 引起的物种 $i$ 的量的净变化。反应物的系数为负，产物的系数为正。问题陈述指明传递的是单个守恒基团，这意味着所有非零化学计量系数均为 $\\pm 1$。\n\n对于反应 $R_{1}: A \\to B$：\n物种 $A$ 被消耗（系数为 $-1$），物种 $B$ 被生成（系数为 $+1$）。$N$ 的第一列是 $[-1, 1, 0, 0]^{\\top}$。\n\n对于反应 $R_{2}: B \\to C$：\n物种 $B$ 被消耗（系数为 $-1$），物种 $C$ 被生成（系数为 $+1$）。$N$ 的第二列是 $[0, -1, 1, 0]^{\\top}$。\n\n对于反应 $R_{3}: C \\to D$：\n物种 $C$ 被消耗（系数为 $-1$），物种 $D$ 被生成（系数为 $+1$）。$N$ 的第三列是 $[0, 0, -1, 1]^{\\top}$。\n\n组合这些列，我们构建化学计量矩阵 $N$：\n$$ N = \\begin{pmatrix} -1  0  0 \\\\ 1  -1  0 \\\\ 0  1  -1 \\\\ 0  0  1 \\end{pmatrix} $$\n\n接下来，我们通过求解 $N^{\\top}c = \\mathbf{0}$ 来找到守恒律向量 $c$。$N$ 的转置矩阵是：\n$$ N^{\\top} = \\begin{pmatrix} -1  1  0  0 \\\\ 0  -1  1  0 \\\\ 0  0  -1  1 \\end{pmatrix} $$\n\n设守恒律向量为 $c = [c_A, c_B, c_C, c_D]^{\\top}$。线性方程组为：\n$$ N^{\\top}c = \\begin{pmatrix} -1  1  0  0 \\\\ 0  -1  1  0 \\\\ 0  0  -1  1 \\end{pmatrix} \\begin{pmatrix} c_A \\\\ c_B \\\\ c_C \\\\ c_D \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\n这得到以下方程：\n1. $-c_A + c_B = 0 \\implies c_A = c_B$\n2. $-c_B + c_C = 0 \\implies c_B = c_C$\n3. $-c_C + c_D = 0 \\implies c_C = c_D$\n\n从这些方程中，我们推断出 $c$ 的所有分量必须相等：$c_A = c_B = c_C = c_D$。\n$N$ 的左零空间中的任何向量都必须具有形式 $c = [k, k, k, k]^{\\top}$，其中 $k \\in \\mathbb{R}$ 是某个标量。这意味着守恒律空间 $\\mathcal{S}^{\\perp}$ 是由向量 $[1, 1, 1, 1]^{\\top}$ 张成的 $\\mathbb{R}^4$ 的一个一维子空间。这个唯一的独立守恒律对应于系统中守恒基团的总数，即 $[A] + [B] + [C] + [D] = \\text{常数}$。\n\n问题要求我们找到唯一的非零守恒律向量 $c$，该向量经过归一化，使其分量之和等于 $1$。\n我们的一般向量 $c$ 的分量之和是：\n$$ c_A + c_B + c_C + c_D = k + k + k + k = 4k $$\n我们将此和设为 $1$：\n$$ 4k = 1 \\implies k = \\frac{1}{4} $$\n将 $k$ 的这个值代回 $c$ 的一般形式，我们得到特定的归一化向量：\n$$ c = \\begin{pmatrix} 1/4 \\\\ 1/4 \\\\ 1/4 \\\\ 1/4 \\end{pmatrix} $$\n问题要求将其表示为一个 $1 \\times 4$ 的行向量。转置该列向量得到：\n$$ c^{\\top} = \\begin{pmatrix} \\frac{1}{4}  \\frac{1}{4}  \\frac{1}{4}  \\frac{1}{4} \\end{pmatrix} $$\n这就是最终答案。", "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{1}{4}  \\frac{1}{4}  \\frac{1}{4}  \\frac{1}{4} \\end{pmatrix} } $$", "id": "4349885"}, {"introduction": "在复杂的生物网络中，识别出最具影响力的“关键”节点是一项核心任务。PageRank算法，最初为网页排名而设计，为衡量网络中节点的中心性提供了一个强大的框架。这项实践任务要求你从第一性原理出发，实现一个完整的PageRank计算程序，包括处理在生物网络中常见但具有挑战性的“悬挂节点”问题[@problem_id:4349876]。", "problem": "实现一个程序，用于计算小型有向转录网络上的个性化PageRank，并严格处理悬挂节点。目标是从马尔可夫链和图随机性的第一性原理出发，推导并实现该算法，而不是未经论证地引用现有的公式。具体来说，考虑一个代表转录调控网络的有向图，其中节点是基因或转录因子，有向边代表调控关系。设阻尼因子表示为 $\\alpha \\in (0,1)$，个性化向量表示为 $v \\in \\mathbb{R}^n$，满足 $v \\ge 0$ 和 $\\sum_{i=1}^n v_i = 1$。PageRank向量 $p \\in \\mathbb{R}^n$ 被定义为该图上带传送的随机游走的平稳分布。\n\n使用的基本原理：\n- 使用离散时间马尔可夫链的定义，其转移矩阵为列随机矩阵，并利用平稳分布 $p$ 满足 $p = M p$ 的概念，其中 $M$ 是一个合适的列随机矩阵，同时满足 $\\sum_{i=1}^n p_i = 1$ 和 $p \\ge 0$。\n- 使用经过充分验证的观察：在PageRank随机游走中，游走者以概率 $\\alpha$ 随机均匀地沿一条出边移动，以概率 $(1-\\alpha)$ 传送到根据个性化向量 $v$ 抽样的一个节点。\n- 利用以下事实：悬挂节点（出度为零的节点）在原始转移矩阵中对应列的和为零，必须通过根据 $v$ 重新分配其概率质量来处理，以使有效转移矩阵仍然是列随机的。\n\n你的程序必须根据这些原则实现以下内容：\n- 从有向图构建一个列随机转移模型，其中对于每个至少有一条出边的节点，转移到其任一出邻居的概率相等且总和为 $1$。对于任何出度为零的节点（悬挂节点），确保其概率质量根据 $v$ 重新分配。\n- 对于给定的 $\\alpha$ 和 $v$，通过幂迭代法计算唯一的PageRank向量 $p$，直到在 $\\ell_1$ 范数下收敛，收敛容差为 $\\varepsilon = 10^{-12}$，最大迭代次数上限为 $10000$ 次。用 $p^{(0)} = v$ 初始化迭代。\n- 返回结果 $p$，其中每个条目四舍五入到六位小数。\n\n图的表示：\n- 设节点索引为从 $0$ 到 $n-1$。有向边表示法 $j \\to i$ 意为“从节点 $j$ 到节点 $i$”，这对应于一个列随机邻接矩阵中的一个条目，其中第 $j$ 列包含从节点 $j$ 出发的转移概率。\n- 一个包含节点 $\\{A,B,C,D,E\\}$ 的转录网络映射到索引 $A \\mapsto 0$, $B \\mapsto 1$, $C \\mapsto 2$, $D \\mapsto 3$, $E \\mapsto 4$。\n\n测试套件：\n- 测试用例1：图 $G_1$ 包含节点 $\\{0,1,2,3,4\\}$ 和边 $0 \\to 1$, $0 \\to 2$, $1 \\to 2$, $1 \\to 3$, $2 \\to 1$, $3 \\to 2$, $3 \\to 4$，节点 $4$ 是悬挂节点（没有出边）。使用 $\\alpha = 0.85$ 和均匀个性化向量 $v = \\left[\\frac{1}{5},\\frac{1}{5},\\frac{1}{5},\\frac{1}{5},\\frac{1}{5}\\right]$。\n- 测试用例2：与测试用例1相同的图 $G_1$，使用 $\\alpha = 0.95$ 和相同的均匀向量 $v$。\n- 测试用例3：与测试用例1相同的图 $G_1$，使用 $\\alpha = 0.85$ 和非均匀个性化向量 $v = [0.05, 0.05, 0.8, 0.05, 0.05]$。\n- 测试用例4：图 $G_2$ 包含节点 $\\{0,1,2\\}$ 且没有任何边，因此所有节点都是悬挂节点。使用 $\\alpha = 0.85$ 和均匀向量 $v = \\left[\\frac{1}{3},\\frac{1}{3},\\frac{1}{3}\\right]$。\n- 测试用例5：图 $G_3$ 包含节点 $\\{0,1,2\\}$ 和一条边 $0 \\to 1$，其中节点 $1$ 和 $2$ 是悬挂节点。使用 $\\alpha = 0.85$ 和均匀向量 $v = \\left[\\frac{1}{3},\\frac{1}{3},\\frac{1}{3}\\right]$。\n\n收敛性与数值规格：\n- 使用 $\\varepsilon = 10^{-12}$ 作为 $\\ell_1$ 收敛准则。\n- 使用最多 $10000$ 次迭代。\n- 在输出前，将最终PageRank向量的每个条目四舍五入到六位小数。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含按顺序排列的测试用例结果，格式为逗号分隔的列表的列表，不含空格。例如，输出格式必须严格为 \"[[p11,p12,...,p1n],[p21,p22,...],[...],...]\"，其中 $p_{kj}$ 是测试用例 $k$ 的浮点数，四舍五入到六位小数。", "solution": "计算个性化PageRank向量的问题是寻找一个特定离散时间马尔可夫链的平稳分布的问题。解决方案将从第一性原理推导得出，从构建随机游走的转移矩阵开始，最终到幂迭代算法。\n\n### 1. 底层马尔可夫链\n\n在一个有 $n=|V|$ 个节点的有向图 $G = (V, E)$ 上的随机游走可以被建模为一个马尔可夫链。系统在第 $k$ 步的状态是一个概率分布向量 $p^{(k)} \\in \\mathbb{R}^n$，其中 $p_i^{(k)}$ 是随机游走者位于节点 $i$ 的概率。状态根据 $p^{(k+1)} = M p^{(k)}$ 演化，其中 $M$ 是一个列随机转移矩阵。条目 $M_{ij}$ 表示从节点 $j$ 转移到节点 $i$ 的概率。平稳分布 $p$ 满足 $p = M p$，同时满足约束条件 $p \\ge 0$ 和 $\\sum_{i=1}^n p_i = 1$。\n\n### 2. 构建PageRank转移模型\n\nPageRank随机游走者的移动是两种行为的加权组合：\n1.  以概率 $\\alpha$，游走者从当前节点随机选择一条出边进行移动。\n2.  以概率 $1-\\alpha$，游走者“传送”到一个根据个性化向量 $v$ 随机选择的节点。\n\n我们必须构建一个能捕捉这种行为的列随机矩阵 $M$。\n\n#### 2.1. 处理基于图的游走（`S` 矩阵）\n\n让我们首先对纯粹遵循图结构的游走进行建模。\n- 对于非悬挂节点 $j$（出度 $d_j > 0$ 的节点），位于 $j$ 的游走者以均匀概率 $1/d_j$ 移动到其任一邻居 $i$。\n- 对于悬挂节点 $j$（出度 $d_j = 0$ 的节点），游走者被困住。问题规定，这部分概率质量必须根据个性化向量 $v$ 重新分配。这等效于一次强制传送：从悬挂节点 $j$，游走者以概率 $v_i$ 跳转到任意节点 $i$。\n\n让我们构建一个矩阵 $S$ 来表示这种基于图的游走，包括对悬挂节点的修正。\n- 设 $A$ 是一个表示非悬挂节点转移的矩阵。\n$$\nA_{ij} = \\begin{cases} 1/d_j  &\\text{if } j \\to i \\text{ is an edge and } d_j > 0 \\\\ 0  &\\text{otherwise} \\end{cases}\n$$\n矩阵 $A$ 中对应非悬挂节点的列和为 $1$，而对应悬挂节点的列全为零。\n- 为了处理悬挂节点，我们添加一个修正项。设 $d \\in \\{0,1\\}^n$ 是一个指示向量，其中如果节点 $j$ 是悬挂节点，则 $d_j=1$，否则 $d_j=0$。从悬挂节点 $j$ 的转移是跳转到节点 $i$，概率为 $v_i$。这可以由外积 $v d^T$ 表示。\n- 用于图游走的完整随机转移矩阵 $S$ 是这两部分之和：\n$$\nS = A + v d^T\n$$\n我们来验证 $S$ 是列随机的。第 $j$ 列的和是 $\\sum_i S_{ij}$。\n- 如果 $j$ 不是悬挂节点 ($d_j=0$)：$\\sum_i S_{ij} = \\sum_i A_{ij} = \\sum_{i \\in \\text{neighbors}(j)} 1/d_j = d_j \\cdot (1/d_j) = 1$。\n- 如果 $j$ 是悬挂节点 ($d_j=1$)：$\\sum_i S_{ij} = \\sum_i (A_{ij} + v_i d_j) = \\sum_i (0 + v_i) = \\sum_i v_i = 1$。\n因此，$S$ 是一个有效的列随机矩阵。\n\n#### 2.2. 引入传送（`M` 矩阵）\n\n每一步的完整PageRank转移是图游走（由 $S$ 控制）和全局传送（由 $v$ 控制）的组合。\n从任意节点 $j$ 转移到目标节点 $i$ 的概率是：\n$$\nP(j \\to i) = \\alpha \\cdot (\\text{图游走概率}) + (1-\\alpha) \\cdot (\\text{传送概率})\n$$\n通过图游走从 $j$ 转移到 $i$ 的概率由 $S_{ij}$ 给出。传送到节点 $i$ 的概率是 $v_i$，这与起始节点 $j$ 无关。\n因此，最终的谷歌矩阵（Google matrix） $M$ 的条目 $M_{ij}$ 是：\n$$\nM_{ij} = \\alpha S_{ij} + (1-\\alpha)v_i\n$$\n用矩阵表示法，即为 $M = \\alpha S + (1-\\alpha) v \\mathbf{1}^T$，其中 $\\mathbf{1}^T$ 是全为1的行向量。这个矩阵 $M$ 是列随机的，其唯一的（对应于特征值 $1$ 的）主特征向量就是PageRank向量 $p$。\n\n### 3. 幂迭代算法\n\nPageRank向量 $p$ 是满足 $p = M p$ 的平稳分布。这可以通过幂迭代法找到：从一个初始猜测 $p^{(0)}$ 开始，我们重复应用转移矩阵：$p^{(k+1)} = M p^{(k)}$。序列 $p^{(k)}$ 会收敛到 $p$。\n\n我们来推导迭代更新规则：\n$$\np^{(k+1)} = M p^{(k)} = (\\alpha S + (1-\\alpha) v \\mathbf{1}^T) p^{(k)}\n$$\n$$\np^{(k+1)} = \\alpha S p^{(k)} + (1-\\alpha) v (\\mathbf{1}^T p^{(k)})\n$$\n由于 $p^{(k)}$ 是一个概率分布，$\\sum_j p_j^{(k)} = 1$，这意味着 $\\mathbf{1}^T p^{(k)} = 1$。\n$$\np^{(k+1)} = \\alpha S p^{(k)} + (1-\\alpha) v\n$$\n这给了我们一个更直接的迭代更新。为了计算效率，我们可以进一步展开 $S$：\n$$\np^{(k+1)} = \\alpha (A + v d^T) p^{(k)} + (1-\\alpha) v\n$$\n$$\np^{(k+1)} = \\alpha A p^{(k)} + \\alpha v (d^T p^{(k)}) + (1-\\alpha) v\n$$\n设 $m_d^{(k)} = d^T p^{(k)} = \\sum_{j \\text{ is dangling}} p_j^{(k)}$ 为在第 $k$ 步时位于悬挂节点上的总概率质量。方程变为：\n$$\np^{(k+1)} = \\alpha (A p^{(k)}) + (\\alpha m_d^{(k)} + 1 - \\alpha) v\n$$\n这就是最终的、计算上高效的幂迭代更新规则。\n\n**算法：**\n1.  **初始化**：设置初始PageRank向量 $p^{(0)} = v$，迭代计数器 $k=0$。\n2.  **预处理**：从图的边确定出度 $d_j$ 并识别悬挂节点集合 $D = \\{j \\mid d_j=0\\}$。构建非悬挂节点的转移矩阵 $A$，或其等价表示。\n3.  **迭代**：对 $k=0, 1, 2, \\dots$ 重复，最多进行 $10000$ 次迭代：\n    a.  存储当前向量：$p_{\\text{old}} = p^{(k)}$。\n    b.  计算悬挂质量：$m_d = \\sum_{j \\in D} p_j^{\\text{old}}$。\n    c.  计算游走贡献：$p'_{\\text{walk}} = A p_{\\text{old}}$。这是通过对每个节点 $i$ 求和所有传入的概率流来完成的：$(p'_{\\text{walk}})_i = \\sum_{j \\to i, j \\notin D} p_j^{\\text{old}} / d_j$。\n    d.  计算新的PageRank向量：$p^{(k+1)} = \\alpha p'_{\\text{walk}} + (\\alpha m_d + 1 - \\alpha) v$。\n    e.  **检查收敛性**：计算差值的 $\\ell_1$ 范数：$\\Delta = ||p^{(k+1)} - p_{\\text{old}}||_1 = \\sum_i |p_i^{(k+1)} - p_i^{\\text{old}}|$。如果 $\\Delta  \\varepsilon = 10^{-12}$，则终止迭代。\n4.  **结果**：最终的向量 $p^{(k+1)}$ 就是计算出的PageRank向量。将其条目四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef compute_pagerank(edges, n, alpha, v, epsilon, max_iter):\n    \"\"\"\n    Computes the Personalized PageRank vector from first principles.\n\n    Args:\n        edges (list): A list of tuples (from_node, to_node) representing directed edges.\n        n (int): The total number of nodes in the graph.\n        alpha (float): The damping factor.\n        v (np.ndarray):The personalization vector.\n        epsilon (float): The convergence tolerance for the L1 norm.\n        max_iter (int): The maximum number of iterations.\n\n    Returns:\n        np.ndarray: The computed PageRank vector.\n    \"\"\"\n    # 1. Build adjacency list and find out-degrees.\n    adj = [[] for _ in range(n)]\n    out_degrees = np.zeros(n, dtype=int)\n    for j, i in edges:\n        # j - i means from node j to node i\n        adj[j].append(i)\n        out_degrees[j] += 1\n\n    # 2. Identify dangling nodes.\n    dangling_nodes_mask = (out_degrees == 0)\n\n    # 3. Construct the 'A' matrix for transitions from non-dangling nodes.\n    # For small graphs, a dense matrix is acceptable.\n    A = np.zeros((n, n))\n    non_dangling_indices = np.where(out_degrees  0)[0]\n    for j in non_dangling_indices:\n        for i in adj[j]:\n            A[i, j] = 1.0 / out_degrees[j]\n\n    # 4. Power Iteration.\n    p = v.copy()  # Initialize p^(0) = v\n\n    for _ in range(max_iter):\n        p_old = p.copy()\n\n        # Calculate the total probability mass on dangling nodes.\n        dangling_mass = np.sum(p_old[dangling_nodes_mask])\n\n        # Calculate the contribution from the random walk on non-dangling nodes.\n        # This is the A*p_old part of the update rule.\n        p_walk_contribution = np.dot(A, p_old)\n\n        # The teleportation component combines the mass from dangling nodes\n        # and the (1-alpha) global teleportation probability.\n        teleport_factor = alpha * dangling_mass + (1.0 - alpha)\n        teleport_contribution = teleport_factor * v\n\n        # Combine walk and teleportation to get the new PageRank vector.\n        p = alpha * p_walk_contribution + teleport_contribution\n\n        # Check for convergence using the L1 norm.\n        l1_norm_diff = np.linalg.norm(p - p_old, ord=1)\n        if l1_norm_diff  epsilon:\n            break\n            \n    return p\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test cases for the Personalized PageRank computation.\n    \"\"\"\n    # Test case definitions\n    # Graph 1\n    n1 = 5\n    edges1 = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 1), (3, 2), (3, 4)]\n    v1_uniform = np.full(n1, 1.0 / n1)\n    v1_nonuniform = np.array([0.05, 0.05, 0.8, 0.05, 0.05])\n\n    # Graph 2\n    n2 = 3\n    edges2 = []\n    v2_uniform = np.full(n2, 1.0 / n2)\n\n    # Graph 3\n    n3 = 3\n    edges3 = [(0, 1)]\n    v3_uniform = np.full(n3, 1.0 / n3)\n\n    test_cases = [\n        # (graph_edges, num_nodes, alpha, personalization_vector)\n        (edges1, n1, 0.85, v1_uniform),\n        (edges1, n1, 0.95, v1_uniform),\n        (edges1, n1, 0.85, v1_nonuniform),\n        (edges2, n2, 0.85, v2_uniform),\n        (edges3, n3, 0.85, v3_uniform),\n    ]\n\n    epsilon = 1e-12\n    max_iter = 10000\n    results = []\n\n    for edges, n, alpha, v in test_cases:\n        p_vector = compute_pagerank(edges, n, alpha, v, epsilon, max_iter)\n        # Round each element to 6 decimal places as required.\n        rounded_p = [round(val, 6) for val in p_vector]\n        results.append(rounded_p)\n\n    # Format the final output string to be a comma-separated list of lists\n    # with no spaces, e.g., \"[[p1,p2],[q1,q2]]\".\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\nsolve()\n```", "id": "4349876"}]}