{"hands_on_practices": [{"introduction": "矩生成函数 ($MGF$) 是一个强大的数学工具，它不仅能唯一地确定一个概率分布，还能极大地简化其各阶矩的计算。本练习 [@problem_id:4387180] 旨在提供一项基础但至关重要的理论实践：从定义出发，推导在生物医学测量中无处不在的正态分布的矩生成函数。通过掌握这一过程，你将学会如何利用MGF来系统地求解分布的均值、方差、偏度（三阶中心矩）和峰度（四阶中心矩）等关键特征，从而加深对数据分布形态的理解。", "problem": "在一个系统生物医学检测中，一个经过校准的定量生物标志物读数的残余测量误差可以很好地用一个均值为 $\\mu$、方差为 $\\sigma^{2}$ 的正态随机变量 $X$ 来建模。$X$ 的概率密度函数由下式给出\n$$\nf_{X}(x)=\\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(x-\\mu)^{2}}{2\\sigma^{2}}\\right).\n$$\n从矩生成函数 (MGF) 的定义出发，\n$$\nM_{X}(t)=\\mathbb{E}\\!\\left[\\exp(tX)\\right]=\\int_{-\\infty}^{\\infty}\\exp(tx)\\,f_{X}(x)\\,dx,\n$$\n推导出一个对所有实数 $t$ 都有效的 $M_{X}(t)$ 的闭式表达式。然后，仅使用第一性原理（上述定义和证明积分号下微分合理性的标准定理），证明如何通过在 $t=0$ 处对 $M_{X}(t)$ 进行重复微分来得到任意非负整数 $n$ 的原始矩 $\\mathbb{E}[X^{n}]$。最后，将此框架应用于中心化变量 $Y=X-\\mu$，并通过对适当的 MGF 进行微分来显式计算四阶中心矩 $\\mathbb{E}\\!\\left[(X-\\mu)^{4}\\right]$。\n\n以 $\\sigma$ 的单个闭式解析表达式形式给出最终答案。不要四舍五入。", "solution": "该问题是有效的，因为它是概率论和统计学中一个标准的、适定的问题，基于正确的数学和科学原理。我们将按要求分三部分进行推导。\n\n第一部分：正态随机变量的矩生成函数 (MGF) 的推导\n\n问题定义了一个均值为 $\\mu$、方差为 $\\sigma^2$ 的正态随机变量 $X$，其概率密度函数 (PDF) 为：\n$$\nf_{X}(x)=\\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\left(-\\frac{(x-\\mu)^{2}}{2\\sigma^{2}}\\right)\n$$\n矩生成函数 (MGF) $M_X(t)$ 定义为 $\\exp(tX)$ 的期望值：\n$$\nM_{X}(t) = \\mathbb{E}[\\exp(tX)] = \\int_{-\\infty}^{\\infty} \\exp(tx) f_{X}(x) dx\n$$\n将正态分布的 PDF 代入此定义，我们得到：\n$$\nM_{X}(t) = \\int_{-\\infty}^{\\infty} \\exp(tx) \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp\\left(-\\frac{(x-\\mu)^{2}}{2\\sigma^{2}}\\right) dx\n$$\n我们可以合并指数函数的参数：\n$$\nM_{X}(t) = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty} \\exp\\left(tx - \\frac{(x-\\mu)^{2}}{2\\sigma^{2}}\\right) dx\n$$\n为了求解这个积分，我们对指数部分进行配方。让我们关注指数的参数：\n$$\ntx - \\frac{(x-\\mu)^{2}}{2\\sigma^{2}} = tx - \\frac{x^2 - 2\\mu x + \\mu^2}{2\\sigma^2} = \\frac{2\\sigma^2 tx - (x^2 - 2\\mu x + \\mu^2)}{2\\sigma^2}\n$$\n$$\n= -\\frac{1}{2\\sigma^2} \\left[ x^2 - 2\\mu x - 2\\sigma^2 tx + \\mu^2 \\right] = -\\frac{1}{2\\sigma^2} \\left[ x^2 - 2(\\mu + \\sigma^2 t)x + \\mu^2 \\right]\n$$\n现在，我们对包含 $x$ 的项进行配方。我们加上并减去 $(\\mu + \\sigma^2 t)^2$：\n$$\n= -\\frac{1}{2\\sigma^2} \\left[ \\left(x^2 - 2(\\mu + \\sigma^2 t)x + (\\mu + \\sigma^2 t)^2\\right) - (\\mu + \\sigma^2 t)^2 + \\mu^2 \\right]\n$$\n$$\n= -\\frac{1}{2\\sigma^2} \\left[ (x - (\\mu + \\sigma^2 t))^2 - (\\mu^2 + 2\\mu\\sigma^2 t + \\sigma^4 t^2) + \\mu^2 \\right]\n$$\n$$\n= -\\frac{(x - (\\mu + \\sigma^2 t))^2}{2\\sigma^2} + \\frac{2\\mu\\sigma^2 t + \\sigma^4 t^2}{2\\sigma^2} = -\\frac{(x - (\\mu + \\sigma^2 t))^2}{2\\sigma^2} + \\mu t + \\frac{1}{2}\\sigma^2 t^2\n$$\n将此结果代回 $M_X(t)$ 的积分中：\n$$\nM_{X}(t) = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty} \\exp\\left( -\\frac{(x - (\\mu + \\sigma^2 t))^2}{2\\sigma^2} + \\mu t + \\frac{1}{2}\\sigma^2 t^2 \\right) dx\n$$\n项 $\\exp(\\mu t + \\frac{1}{2}\\sigma^2 t^2)$ 不依赖于 $x$，可以从积分中提出：\n$$\nM_{X}(t) = \\exp\\left(\\mu t + \\frac{1}{2}\\sigma^2 t^2\\right) \\int_{-\\infty}^{\\infty} \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp\\left( -\\frac{(x - (\\mu + \\sigma^2 t))^2}{2\\sigma^2} \\right) dx\n$$\n剩下的积分是一个均值为 $\\mu' = \\mu + \\sigma^2 t$、方差为 $\\sigma^2$ 的正态 PDF 在其整个定义域 $(-\\infty, \\infty)$ 上的积分。任何 PDF 下的总面积都等于 $1$。因此，该积分的值为 $1$。\n这样我们就得到了正态分布 MGF 的闭式表达式：\n$$\nM_{X}(t) = \\exp\\left(\\mu t + \\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n此表达式对所有实数 $t$ 均有效。\n\n第二部分：通过微分生成矩的合理性证明\n\n$X$ 的 $n$ 阶原始矩定义为 $\\mathbb{E}[X^n]$。我们需要说明这与 $M_X(t)$ 在 $t=0$ 处的导数有何关系。让我们对 $M_X(t)$ 关于 $t$ 求导：\n$$\n\\frac{d^n}{dt^n} M_X(t) = \\frac{d^n}{dt^n} \\int_{-\\infty}^{\\infty} \\exp(tx) f_X(x) dx\n$$\n在某些正则性条件下，我们可以交换微分和积分的顺序（这一结果可由莱布尼茨积分法则或控制收敛定理等定理形式化证明）。对于正态分布，被积函数关于 $t$ 的偏导数存在且连续。此外，对于 $0$ 附近紧区间内的任何 $t$，导数绝对值的积分是有界的，因为当 $|x| \\to \\infty$ 时，$f_X(x)$ 的指数衰减速度超过了微分带来的任何多项式增长。这证明了交换顺序的合理性。\n$$\n\\frac{d^n}{dt^n} M_X(t) = \\int_{-\\infty}^{\\infty} \\frac{\\partial^n}{\\partial t^n} [\\exp(tx)] f_X(x) dx\n$$\n$\\exp(tx)$ 关于 $t$ 的 $n$ 阶偏导数是 $x^n \\exp(tx)$。\n$$\n\\frac{d^n}{dt^n} M_X(t) = \\int_{-\\infty}^{\\infty} x^n \\exp(tx) f_X(x) dx = \\mathbb{E}[X^n \\exp(tX)]\n$$\n为了求得 $n$ 阶原始矩，我们计算此表达式在 $t=0$ 处的值：\n$$\n\\left. \\frac{d^n}{dt^n} M_X(t) \\right|_{t=0} = \\mathbb{E}[X^n \\exp(0 \\cdot X)] = \\mathbb{E}[X^n \\cdot 1] = \\mathbb{E}[X^n]\n$$\n这表明 $n$ 阶原始矩 $\\mathbb{E}[X^n]$ 可以通过求 MGF $M_X(t)$ 的 $n$ 阶导数并在 $t=0$ 处求值得到。\n\n第三部分：四阶中心矩的计算\n\n四阶中心矩是 $\\mathbb{E}[(X-\\mu)^4]$。我们定义一个中心化随机变量 $Y = X-\\mu$。$Y$ 的矩就是 $X$ 的中心矩。我们需要找到 $Y$ 的 MGF，记为 $M_Y(t)$。\n$$\nM_Y(t) = \\mathbb{E}[\\exp(tY)] = \\mathbb{E}[\\exp(t(X-\\mu))] = \\mathbb{E}[\\exp(tX)\\exp(-t\\mu)]\n$$\n由于 $\\exp(-t\\mu)$ 相对于随机变量 $X$ 是一个常数，我们可以将其从期望值中提出来：\n$$\nM_Y(t) = \\exp(-t\\mu) \\mathbb{E}[\\exp(tX)] = \\exp(-t\\mu) M_X(t)\n$$\n代入我们在第一部分推导出的 $M_X(t)$ 的表达式：\n$$\nM_Y(t) = \\exp(-t\\mu) \\exp\\left(\\mu t + \\frac{1}{2}\\sigma^2 t^2\\right) = \\exp\\left(-t\\mu + \\mu t + \\frac{1}{2}\\sigma^2 t^2\\right) = \\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n注意 $Y$ 是一个均值为 $\\mathbb{E}[Y] = \\mathbb{E}[X-\\mu] = \\mu-\\mu=0$、方差为 $\\mathrm{Var}(Y) = \\mathrm{Var}(X) = \\sigma^2$ 的正态随机变量。我们为 $Y$ 求得的 MGF 与均值为 $0$、方差为 $\\sigma^2$ 的正态分布的一般公式是一致的。\n\n为了求得四阶中心矩 $\\mathbb{E}[Y^4]$，我们必须计算 $M_Y(t)$ 的四阶导数并在 $t=0$ 处求值。\n$$\nM_Y(t) = \\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n一阶导数：\n$$\nM_Y'(t) = \\frac{d}{dt}\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right) = (\\sigma^2 t)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n二阶导数（使用乘法法则）：\n$$\nM_Y''(t) = \\sigma^2 \\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right) + (\\sigma^2 t)(\\sigma^2 t)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right) = (\\sigma^2 + \\sigma^4 t^2)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n三阶导数：\n$$\nM_Y'''(t) = (2\\sigma^4 t)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right) + (\\sigma^2 + \\sigma^4 t^2)(\\sigma^2 t)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n$$\n= (2\\sigma^4 t + \\sigma^4 t + \\sigma^6 t^3)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right) = (3\\sigma^4 t + \\sigma^6 t^3)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n四阶导数：\n$$\nM_Y^{(4)}(t) = (3\\sigma^4 + 3\\sigma^6 t^2)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right) + (3\\sigma^4 t + \\sigma^6 t^3)(\\sigma^2 t)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n$$\n= (3\\sigma^4 + 3\\sigma^6 t^2 + 3\\sigma^6 t^2 + \\sigma^8 t^4)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n$$\n= (3\\sigma^4 + 6\\sigma^6 t^2 + \\sigma^8 t^4)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n最后，我们在 $t=0$ 处计算四阶导数的值，以获得四阶中心矩：\n$$\n\\mathbb{E}[(X-\\mu)^4] = \\mathbb{E}[Y^4] = M_Y^{(4)}(0) = (3\\sigma^4 + 6\\sigma^6(0)^2 + \\sigma^8(0)^4)\\exp(0) = 3\\sigma^4\n$$\n四阶中心矩是 $3\\sigma^4$。", "answer": "$$\n\\boxed{3\\sigma^{4}}\n$$", "id": "4387180"}, {"introduction": "在生物医学研究中，我们常常需要分析由样本统计量经过非线性函数变换后得到的新估计量，例如对数转换后的平均浓度。Delta方法为我们提供了一种关键的分析工具，能够有效地近似这些复杂估计量的方差。本练习 [@problem_id:4387137] 将引导你推导并应用这一重要的大样本近似技术，这对于构造变换后数据的置信区间和进行假设检验至关重要。", "problem": "在一项关于分泌细胞因子浓度的系统生物医学研究中，假设 $X_{1}, X_{2}, \\ldots, X_{n}$ 是来自 $n$ 个不同细胞培养物的独立同分布的浓度测量值，建模为 $X_{i} \\sim \\mathcal{N}(\\mu, \\sigma^{2})$，其中 $\\mu  0$ 以反映浓度严格为正。研究人员通常报告对数转换后的总结数据，以使乘性变异线性化并稳定方差。考虑估计量 $\\hat{\\theta} = g(\\bar{X})$，其中 $g$ 是在 $\\mu$ 的一个邻域内的一阶连续可微函数，而 $\\bar{X} = \\frac{1}{n}\\sum_{i=1}^{n} X_{i}$。\n\n仅从样本均值的定义、其在独立性下的方差以及中心极限定理 (CLT) 出发，通过在 $\\mu$ 周围使用一阶展开对 $g$ 进行线性化，推导一个对大样本 $n$ 有效的 $\\operatorname{Var}(\\hat{\\theta})$ 的渐近近似。然后将你的推导具体化到 $g(x) = \\ln(x)$ 的情况，并提供 $\\operatorname{Var}(\\ln(\\bar{X}))$ 的大样本 $n$ 近似的最终闭式解析表达式，该表达式应以 $\\mu$、$\\sigma^{2}$ 和 $n$ 表示。\n\n将最终答案表示为单个解析表达式。不要进行四舍五入。", "solution": "用户希望找到样本均值函数方差 $\\operatorname{Var}(g(\\bar{X}))$ 的一个渐近近似，然后将此结果具体化到自然对数函数。推导过程必须从问题陈述中概述的基本原理出发。\n\n该问题被认为是有效的。\n- 它在科学上基于标准统计理论（中心极限定理，德尔塔方法）。\n- 它的提法是适定的，提供了所有必要的信息。\n- 语言客观而精确。\n\n我们按要求开始推导。\n\n设 $X_{1}, X_{2}, \\ldots, X_{n}$ 是来自一个分布的独立同分布 (i.i.d.) 随机变量，其均值为 $\\mathbb{E}[X_{i}] = \\mu$，方差为 $\\operatorname{Var}(X_{i}) = \\sigma^{2}$。问题指定了正态分布 $X_{i} \\sim \\mathcal{N}(\\mu, \\sigma^{2})$，但此推导在更一般的情况下也成立。样本均值定义为 $\\bar{X} = \\frac{1}{n}\\sum_{i=1}^{n} X_{i}$。\n\n样本均值的方差 $\\operatorname{Var}(\\bar{X})$ 是使用方差的性质推导出来的。由于 $X_{i}$ 是独立的：\n$$\n\\operatorname{Var}(\\bar{X}) = \\operatorname{Var}\\left(\\frac{1}{n}\\sum_{i=1}^{n} X_{i}\\right) = \\frac{1}{n^{2}} \\operatorname{Var}\\left(\\sum_{i=1}^{n} X_{i}\\right)\n$$\n由于独立性，和的方差是方差的和：\n$$\n\\operatorname{Var}\\left(\\sum_{i=1}^{n} X_{i}\\right) = \\sum_{i=1}^{n} \\operatorname{Var}(X_{i}) = \\sum_{i=1}^{n} \\sigma^{2} = n\\sigma^{2}\n$$\n将此代回，我们得到样本均值的方差：\n$$\n\\operatorname{Var}(\\bar{X}) = \\frac{1}{n^{2}}(n\\sigma^{2}) = \\frac{\\sigma^{2}}{n}\n$$\n问题指明 $n$ 很大。中心极限定理 (CLT) 指出，当 $n \\to \\infty$ 时，样本均值 $\\bar{X}$ 的分布趋近于正态分布。更正式地，$\\sqrt{n}(\\bar{X} - \\mu)$ 依分布收敛于 $\\mathcal{N}(0, \\sigma^{2})$。这意味着对于大样本 $n$，$\\bar{X}$ 集中在其均值 $\\mu$ 的一个小邻域内。这种集中性为在点 $\\mu$ 周围对函数 $g$ 使用线性近似提供了理由。\n\n我们对估计量 $\\hat{\\theta} = g(\\bar{X})$ 感兴趣，其中 $g$ 是一个一阶连续可微函数。我们对 $g(\\bar{X})$ 在点 $\\mu$ 周围进行一阶泰勒展开：\n$$\ng(\\bar{X}) \\approx g(\\mu) + g'(\\mu)(\\bar{X} - \\mu)\n$$\n这是一个我们忽略了高阶项的近似，因为当 $n$ 很大时 $\\bar{X}$ 接近于 $\\mu$，所以这个近似是有效的。现在我们计算这个线性近似的方差：\n$$\n\\operatorname{Var}(\\hat{\\theta}) = \\operatorname{Var}(g(\\bar{X})) \\approx \\operatorname{Var}(g(\\mu) + g'(\\mu)(\\bar{X} - \\mu))\n$$\n利用性质：对于任意随机变量 $Y$ 和常数 $a, b$，我们有 $\\operatorname{Var}(aY + b) = a^{2}\\operatorname{Var}(Y)$。在这里，$g(\\mu)$ 和 $g'(\\mu)$ 是常数，$\\mu$ 也是。令 $Y = \\bar{X}$，$a = g'(\\mu)$，常数项为 $g(\\mu) - g'(\\mu)\\mu$。表达式简化为：\n$$\n\\operatorname{Var}(g(\\bar{X})) \\approx \\operatorname{Var}(g'(\\mu)\\bar{X}) = (g'(\\mu))^{2} \\operatorname{Var}(\\bar{X})\n$$\n代入先前推导的 $\\operatorname{Var}(\\bar{X}) = \\frac{\\sigma^{2}}{n}$ 的表达式，我们得到 $\\hat{\\theta}$ 方差的一般渐近近似：\n$$\n\\operatorname{Var}(g(\\bar{X})) \\approx (g'(\\mu))^{2} \\frac{\\sigma^{2}}{n}\n$$\n这个结果通常被称为德尔塔方法。\n\n接下来，我们将此推导具体化到函数为自然对数 $g(x) = \\ln(x)$ 的情况。问题陈述 $\\mu  0$，这确保了 $\\ln(\\mu)$ 是有定义的。对于大样本 $n$，$\\bar{X}$ 将接近于 $\\mu$，因此 $\\bar{X}$ 也将以高概率为正，从而 $\\ln(\\bar{X})$ 将是有定义的。\n\n首先，我们求 $g(x)$ 的导数：\n$$\ng'(x) = \\frac{d}{dx}(\\ln(x)) = \\frac{1}{x}\n$$\n接下来，我们在点 $x=\\mu$ 处计算这个导数：\n$$\ng'(\\mu) = \\frac{1}{\\mu}\n$$\n现在，我们将这个具体的导数代入我们的一般方差近似公式：\n$$\n\\operatorname{Var}(\\ln(\\bar{X})) \\approx \\left(\\frac{1}{\\mu}\\right)^{2} \\operatorname{Var}(\\bar{X}) = \\frac{1}{\\mu^{2}} \\frac{\\sigma^{2}}{n}\n$$\n这就给出了 $\\operatorname{Var}(\\ln(\\bar{X}))$ 的大样本 $n$ 近似的最终闭式解析表达式：\n$$\n\\operatorname{Var}(\\ln(\\bar{X})) \\approx \\frac{\\sigma^{2}}{n\\mu^{2}}\n$$", "answer": "$$\n\\boxed{\\frac{\\sigma^{2}}{n\\mu^{2}}}\n$$", "id": "4387137"}, {"introduction": "当数据不满足正态分布等传统参数检验的严格假设时，置换检验提供了一种强大而灵活的非参数替代方案。这种方法在处理复杂的生物医学数据时尤其有价值。这项动手编程练习 [@problem_id:4387115] 将指导你从第一性原理出发，实现一个完整的双样本置换检验，从而让你对非参数推断和随机化原则建立起深刻的直觉。", "problem": "考虑一个源于系统生物医学的双样本比较问题，其科学问题是两种生物条件（例如，对照组与处理组）是否会产生不同的平均分子测量值（例如，对数转换后的单细胞蛋白质丰度）。您的任务是，在条件标签可交换性的假设下，为均值差异开发一个严格的置换检验，并且对于小样本，通过枚举所有与观测样本量一致的标签分配来推导精确的零分布。\n\n您的推导应基于以下原则：\n- 在零假设下的可交换性：在两种条件的测量值分布相同的零假设下，观测到的标签不提供信息，任何保持原始组大小的标签重分配都是等可能的。\n- 假设检验的随机化原则：检验统计量的参考零分布是通过在实验设计所允许的所有标签分配下评估该统计量来构建的，并在零假设下将这些分配视为等可能。\n- 以均值差异作为检验统计量的定义：对于合并的观测数据，该统计量是分配给 $A$ 组的测量值平均值与分配给 $B$ 组的测量值平均值之差。\n\n形式上，假设您在 $A$ 组观测到 $n_A$ 个测量值，在 $B$ 组观测到 $n_B$ 个测量值，合并后的数据为 $x_1, x_2, \\dots, x_N$，其中 $N = n_A + n_B$。在零假设和标签可交换性下，所有将合并观测数据中恰好 $n_A$ 个分配给 $A$ 组、 $n_B$ 个分配给 $B$ 组的标签分配都是等可能的。定义检验统计量 $T$ 为均值差异 $T = \\bar{X}_A - \\bar{X}_B$。对于小样本，精确的零分布是通过枚举所有标签分配得到的所有 $T$ 值的多重集，并赋予这些标签分配均匀概率。双边 $p$ 值是在此零分布下，观测到绝对值至少与从原始标签得到的观测统计量一样大的统计量的概率。\n\n您的程序必须：\n- 从提供的带标签数据中计算观测到的均值差异 $T_{\\text{obs}}$。\n- 枚举所有允许的标签分配（即保持原始组大小的分配），并通过计算每个唯一 $T$ 值的频率再除以总标签分配数来计算 $T$ 的精确零分布。\n- 计算精确的双边 $p$ 值，即 $|T| \\geq |T_{\\text{obs}}|$ 的总零概率，表示为小数。\n- 对每个测试用例，输出一个包含三个部分的列表：双边 $p$ 值、精确零分布的唯一支撑点的排序列表，以及与该支撑点对齐的相应概率列表。所有浮点输出必须四舍五入到六位小数，并以小数形式表示（而非分数或百分号）。\n\n将此实现为一个完整的、可运行的程序，为以下测试套件生成结果：\n- 测试用例 1（平衡，中等差异）：$A$ 组测量值 $[1.24, 1.37, 1.51, 1.63]$，$B$ 组测量值 $[1.10, 1.21, 1.28, 1.30]$。\n- 测试用例 2（边界，最小非平凡样本）：$A$ 组测量值 $[2.80]$，$B$ 组测量值 $[2.10]$。\n- 测试用例 3（组大小不等）：$A$ 组测量值 $[0.95, 1.02, 1.08]$，$B$ 组测量值 $[0.89, 0.92, 1.00, 1.05, 1.10]$。\n- 测试用例 4（平衡且有重复值）：$A$ 组测量值 $[3.20, 3.20, 3.40]$，$B$ 组测量值 $[3.10, 3.20, 3.30]$。\n- 测试用例 5（退化的相等值）：$A$ 组测量值 $[1.50, 1.50]$，$B$ 组测量值 $[1.50, 1.50]$。\n\n您的程序应生成一行输出，其中包含所有五个测试用例的结果，形式为方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是 $[p,\\;S,\\;P]$ 形式的列表，其中 $p$ 是双边 $p$ 值，$S$ 是精确零分布的唯一支撑点的排序列表，$P$ 是与 $S$ 对齐的概率列表。例如，您的输出必须具有 $[[p_1,S_1,P_1],[p_2,S_2,P_2],[p_3,S_3,P_3],[p_4,S_4,P_4],[p_5,S_5,P_5]]$ 的形状，所有浮点数四舍五入到六位小数并以小数表示。\n\n无物理单位或角度单位适用。所有概率和 $p$ 值必须是小数（而非分数或百分比）。", "solution": "### 问题验证\n\n#### 第 1 步：提取已知信息\n\n问题提供了以下数据、定义和约束：\n\n*   **主题**：系统生物医学中的双样本比较问题。\n*   **目标**：为均值差异开发一个严格的置换检验。\n*   **假设**：在零假设下条件标签的可交换性。\n*   **核心原则**：\n    1.  **可交换性**：在两种条件具有相同分布的零假设下，任何保持组大小的标签重分配都是等可能的。\n    2.  **随机化原则**：检验统计量的零分布是通过在所有允许的、等可能的标签分配下对其进行评估来构建的。\n*   **形式化设置**：\n    *   $A$ 组有 $n_A$ 个测量值。\n    *   $B$ 组有 $n_B$ 个测量值。\n    *   合并数据：$x_1, x_2, \\dots, x_N$，其中 $N = n_A + n_B$。\n    *   检验统计量：$T = \\bar{X}_A - \\bar{X}_B$。\n    *   零分布：通过枚举所有 $\\binom{N}{n_A}$ 种标签分配得到的所有 $T$ 值的多重集，具有均匀概率。\n*   **要求计算**：\n    1.  观测到的均值差异，$T_{\\text{obs}}$。\n    2.  $T$ 的精确零分布（支撑点及其概率）。\n    3.  精确的双边 $p$ 值：$P(|T| \\geq |T_{\\text{obs}}|)$。\n*   **输出格式**：对每个测试用例，一个列表 $[p, S, P]$，其中 $p$ 是 $p$ 值，$S$ 是零分布的唯一支撑点的排序列表，$P$ 是相应的概率列表。所有浮点数必须四舍五入到六位小数。所有测试用例的最终输出必须是单行：这些结果列表的列表。\n*   **测试用例**：\n    1.  A 组：$[1.24, 1.37, 1.51, 1.63]$，B 组：$[1.10, 1.21, 1.28, 1.30]$。\n    2.  A 组：$[2.80]$，B 组：$[2.10]$。\n    3.  A 组：$[0.95, 1.02, 1.08]$，B 组：$[0.89, 0.92, 1.00, 1.05, 1.10]$。\n    4.  A 组：$[3.20, 3.20, 3.40]$，B 组：$[3.10, 3.20, 3.30]$。\n    5.  A 组：$[1.50, 1.50]$，B 组：$[1.50, 1.50]$。\n\n#### 第 2 步：使用提取的已知信息进行验证\n\n根据验证标准评估问题陈述：\n\n1.  **科学依据**：该问题在根本上是合理的。基于随机化原则和可交换性的置换检验是由 R.A. Fisher 建立的非参数统计的基石。它是一种标准的、有效的、功能强大的假设检验方法，尤其适用于渐近近似可能失效的小样本情况。检验统计量，即均值差异，是比较中心趋势的常用且合适的选择。系统生物医学的背景是恰当的。\n2.  **适定性**：问题是适定的。它提供了所有必要的信息：数据集、检验统计量的精确定义、构建零分布的方法（完全枚举），以及 $p$ 值的定义。样本量足够小，使得所有标签分配的完全枚举在计算上是可行的。所需的输出被明确定义。\n3.  **客观性**：语言完全是客观的、数学的，并且没有主观或基于意见的陈述。\n4.  **完整性和一致性**：设置是完整的且内部一致。没有缺失数据或矛盾的约束。指定的测试用例涵盖了多种场景（平衡、不平衡、重复值、退化情况），可以对所实现的算法进行彻底的验证。\n5.  **现实性和可行性**：测量值的数值对于生物数据（例如，对数转换后的丰度）是现实的。对于给定的'小样本量'，枚举所有置换的任务在计算上是可行的。例如，最大的情况是测试用例3，其中 $n_A=3, n_B=5$，导致 $N=8$。置换的数量是 $\\binom{8}{3} = 56$，这对于计算机来说是微不足道的。\n6.  **无其他缺陷**：该问题并非微不足道（它需要不明显的实现细节），不是隐喻性的，也不是同义反复的。退化情况（测试用例5）为算法的鲁棒性提供了有意义的检验。\n\n#### 第 3 步：结论与行动\n\n问题陈述是**有效的**。它在科学上是合理的、适定的，并基于已建立的统计原则提供了一个清晰、可计算的任务。我现在将继续进行解答。\n\n### 解答\n\n任务是实现一个精确的置换检验，用于检验两个样本（$A$ 组和 $B$ 组）之间的均值差异。解决方案的核心在于随机化原则，该原则假定在零假设（$H_0$）下，即组间没有差异，标签 'A' 和 'B' 是任意的。因此，将合并数据划分为与原始大小 $n_A$ 和 $n_B$ 相同的新组的任何分区都是等可能的。\n\n设观测数据为 $X_A = \\{x_{A,1}, \\dots, x_{A,n_A}\\}$ 和 $X_B = \\{x_{B,1}, \\dots, x_{B,n_B}\\}$。总观测数为 $N = n_A + n_B$。合并数据集为 $X_{pool} = X_A \\cup X_B$。\n\n**1. 观测检验统计量**\n\n检验统计量是样本均值之差，$T = \\bar{X}_A - \\bar{X}_B$。我们首先为原始的、观测到的标签计算这个值。此值记为 $T_{\\text{obs}}$。\n$$\nT_{\\text{obs}} = \\frac{1}{n_A} \\sum_{i=1}^{n_A} x_{A,i} - \\frac{1}{n_B} \\sum_{j=1}^{n_B} x_{B,j}\n$$\n\n**2. 构建精确的零分布**\n\n在 $H_0$ 下，将 'A' 标签中的 $n_A$ 个和 'B' 标签中的 $n_B$ 个分配给 $X_{pool}$ 中 $N$ 个观测值的所有可能方式都是等概率的。此类唯一分配（或标签置换）的总数由二项式系数给出：\n$$\nC_{total} = \\binom{N}{n_A} = \\frac{N!}{n_A! (N-n_A)!} = \\frac{N!}{n_A! n_B!}\n$$\n该算法通过枚举从合并数据 $X_{pool}$ 中形成大小为 $n_A$ 的新组 $A'$ 的每一种可能方式来进行。剩下的 $n_B$ 个元素自动形成互补组 $B'$。对于每个这样的置换 $k = 1, \\dots, C_{total}$，我们计算检验统计量 $T_k'$：\n$$\nT_k' = \\bar{X}_{A',k} - \\bar{X}_{B',k}\n$$\n这些 $C_{total}$ 个值 $\\{T_1', T_2', \\dots, T_{C_{total}}'\\}$ 的集合构成了检验统计量 $T$ 的精确零分布。\n\n一个计算上的注记：设 $S_{pool} = \\sum_{i=1}^{N} x_i$ 为所有合并观测值的总和。对于任何置换，如果 $A'$ 组中元素的总和是 $S_{A'}$，那么 $B'$ 组的总和是 $S_{B'} = S_{pool} - S_{A'}$。统计量 $T'$ 可以写成：\n$$\nT' = \\frac{S_{A'}}{n_A} - \\frac{S_{pool} - S_{A'}}{n_B} = S_{A'} \\left( \\frac{1}{n_A} + \\frac{1}{n_B} \\right) - \\frac{S_{pool}}{n_B}\n$$\n这表明 $T'$ 是 $S_{A'}$ 的单调线性函数。该分布可以通过首先找到所有 $n_A$ 元素子集的和的分布，然后将这些和转换为相应的均值差异值来推导。在实现中，对于给定的约束，直接计算均值是清晰且足够高效的。\n\n**3. 计算支撑集和概率**\n\n$T'$ 值的多重集被处理以找到零分布的支撑集 $S$，即唯一值集合 $\\{t_1, t_2, \\dots, t_m\\}$。我们将这些值按升序排序。对于每个唯一值 $t_j \\in S$，我们在所有 $T'$ 值的多重集中找到其频率 $f_j$。在零假设下观测到 $t_j$ 的概率是：\n$$\nP(T = t_j) = \\frac{f_j}{C_{total}}\n$$\n这就得到了与排序后的支撑集 $S$ 对齐的概率列表 $P = \\{P(T=t_1), \\dots, P(T=t_m)\\}$。\n\n**4. 双边 $p$ 值计算**\n\n双边 $p$ 值是在零分布下，获得一个至少与观测到的统计量一样极端的检验统计量的概率。“一样极端”是通过绝对值来衡量的。$p$ 值计算如下：\n$$\np = P(|T| \\ge |T_{\\text{obs}}|) = \\frac{\\text{Number of permutations } k \\text{ where } |T_k'| \\ge |T_{\\text{obs}}|}{C_{total}}\n$$\n由于潜在的浮点不精确性，比较 $|T_k'| \\ge |T_{\\text{obs}}|$ 应谨慎实现，例如，通过比较到很高的精度，比如，对于一个小的 $\\epsilon0$，$|T_k'| - |T_{\\text{obs}}| \\ge -\\epsilon$。鉴于这些值源于有理数算术，在四舍五入到一个安全的小数位数（例如12位）后进行直接比较是一种稳健的策略。\n\n将要实现的算法将对每个提供的测试用例执行这些步骤。在 Python 中使用 `itertools.combinations` 是枚举合并数据分区的理想选择。", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\nimport math\n\ndef run_permutation_test(data_a, data_b):\n    \"\"\"\n    Performs an exact two-sample permutation test for the difference in means.\n\n    Args:\n        data_a (list): A list of numerical measurements for group A.\n        data_b (list): A list of numerical measurements for group B.\n\n    Returns:\n        list: A list containing [p_value, support, probabilities], where\n              p_value is the two-sided p-value,\n              support is a sorted list of unique values in the null distribution,\n              and probabilities is the list of corresponding probabilities.\n    \"\"\"\n    n_a = len(data_a)\n    n_b = len(data_b)\n    N = n_a + n_b\n\n    # Convert to numpy arrays for vectorized operations\n    data_a = np.array(data_a)\n    data_b = np.array(data_b)\n    \n    # 1. Pool the data\n    pooled_data = np.concatenate((data_a, data_b))\n\n    # 2. Calculate the observed test statistic\n    mean_a_obs = np.mean(data_a) if n_a  0 else 0.0\n    mean_b_obs = np.mean(data_b) if n_b  0 else 0.0\n    T_obs = mean_a_obs - mean_b_obs\n    \n    # Rounding for consistent floating point comparisons later\n    # A high precision is used internally to avoid collapsing distinct but close values.\n    precision = 12\n    T_obs_rounded = round(T_obs, precision)\n\n    # 3. Generate the null distribution by enumerating all permutations\n    null_distribution_T_values = []\n    \n    # Each combination represents a possible group A\n    for indices_a in combinations(range(N), n_a):\n        indices_a = np.array(indices_a)\n        \n        # Create permuted groups A and B using indices\n        perm_a_data = pooled_data[indices_a]\n        \n        # The remaining indices form group B\n        mask = np.ones(N, dtype=bool)\n        mask[indices_a] = False\n        perm_b_data = pooled_data[mask]\n        \n        # Calculate the test statistic for this permutation\n        mean_a_perm = np.mean(perm_a_data) if n_a  0 else 0.0\n        mean_b_perm = np.mean(perm_b_data) if n_b  0 else 0.0\n        T_perm = mean_a_perm - mean_b_perm\n        \n        null_distribution_T_values.append(round(T_perm, precision))\n\n    null_distribution_T_values = np.array(null_distribution_T_values)\n    total_permutations = len(null_distribution_T_values)\n\n    # 4. Calculate the two-sided p-value\n    # Count permutations where |T_perm| is = |T_obs|\n    # Use a small tolerance for floating point comparison robustness\n    # A more robust way, given we rounded, is direct comparison.\n    count_extreme = np.sum(np.abs(null_distribution_T_values) = abs(T_obs_rounded))\n    p_value = count_extreme / total_permutations if total_permutations  0 else 1.0\n\n    # 5. Get the support and probabilities of the null distribution\n    if total_permutations  0:\n        unique_T, counts = np.unique(null_distribution_T_values, return_counts=True)\n        # Sorting is guaranteed by np.unique\n        support = unique_T.tolist()\n        probabilities = (counts / total_permutations).tolist()\n    else:\n        support = [0.0] if T_obs_rounded == 0.0 else [T_obs_rounded]\n        probabilities = [1.0]\n\n    # 6. Round final results to six decimal places for output\n    p_value_rounded = round(p_value, 6)\n    support_rounded = [round(v, 6) for v in support]\n    probabilities_rounded = [round(p, 6) for p in probabilities]\n\n    return [p_value_rounded, support_rounded, probabilities_rounded]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'a': [1.24, 1.37, 1.51, 1.63], 'b': [1.10, 1.21, 1.28, 1.30]},\n        {'a': [2.80], 'b': [2.10]},\n        {'a': [0.95, 1.02, 1.08], 'b': [0.89, 0.92, 1.00, 1.05, 1.10]},\n        {'a': [3.20, 3.20, 3.40], 'b': [3.10, 3.20, 3.30]},\n        {'a': [1.50, 1.50], 'b': [1.50, 1.50]},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = run_permutation_test(case['a'], case['b'])\n        all_results.append(result)\n\n    # Custom formatter to match the precise output format including spacing.\n    def format_float(f):\n        return f\"{f:.6f}\"\n    \n    def format_list_of_floats(lst):\n        return f\"[{','.join(format_float(x) for x in lst)}]\"\n        \n    def format_case_result(res):\n        p, s, P = res\n        p_str = format_float(p)\n        s_str = format_list_of_floats(s)\n        P_str = format_list_of_floats(P)\n        return f\"[{p_str},{s_str},{P_str}]\"\n        \n    output_str = f\"[{','.join(format_case_result(r) for r in all_results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "4387115"}]}