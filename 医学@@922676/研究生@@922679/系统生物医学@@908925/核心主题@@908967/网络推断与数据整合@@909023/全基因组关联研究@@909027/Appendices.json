{"hands_on_practices": [{"introduction": "在全基因组关联研究（GWAS）中，优势比（Odds Ratio, OR）是病例-对照研究中衡量遗传变异与疾病关联强度的核心指标。本练习旨在通过一个假设场景，让您亲手计算OR值，并理解其在揭示等位基因如何影响疾病风险方面的实际意义。[@problem_id:1494345]", "problem": "一个研究团队正在研究影响人类昼夜节律的遗传因素。他们进行了一项病例对照研究，以检验一种特定的单核苷酸多态性（SNP）（一种常见的遗传变异类型）与个体时型之间的潜在关联。该SNP在人群中有两种已知的等位基因，分别标记为“T”和“C”。\n\n该研究包括两组参与者：\n1.  一组“病例”，由被确定为“夜猫子型”的个体组成。\n2.  一组“对照”，由被确定为“百灵鸟型”的个体组成。\n\n该SNP的基因分型结果如下：\n- 在夜猫子型组中，发现有850名个体携带“T”等位基因，而1150名个体携带“C”等位基因。\n- 在百灵鸟型组中，发现有750名个体携带“T”等位基因，而1450名个体携带“C”等位基因。\n\n根据这些数据，计算与百灵鸟型组的个体相比，夜猫子型组的个体携带“T”等位基因（相对于“C”等位基因）的比值的倍数差异。将最终答案四舍五入至三位有效数字。", "solution": "题目要求我们计算夜猫子型（病例组）与百灵鸟型（对照组）之间，携带“T”等位基因相对于“C”等位基因的比值的差异倍数。这就是比值比（odds ratio）。\n\n我们将一个组中携带“T”等位基因与“C”等位基因的比值定义为该组中“T”的计数与“C”的计数之比。对于夜猫子型组，该比值为\n$$\nO_{\\text{evening}}=\\frac{850}{1150}.\n$$\n对于百灵鸟型组，该比值为\n$$\nO_{\\text{morning}}=\\frac{750}{1450}.\n$$\n比值比是这两个比值的比率：\n$$\n\\text{OR}=\\frac{O_{\\text{evening}}}{O_{\\text{morning}}}=\\frac{\\frac{850}{1150}}{\\frac{750}{1450}}=\\frac{850\\cdot 1450}{1150\\cdot 750}.\n$$\n通过约去公因数来简化。将 $850=85\\cdot 10$，$1450=145\\cdot 10$，$1150=115\\cdot 10$，$750=75\\cdot 10$ 代入，得到\n$$\n\\text{OR}=\\frac{85\\cdot 145}{115\\cdot 75}.\n$$\n将分子和分母同除以 $5$：\n$$\n\\text{OR}=\\frac{17\\cdot 29}{23\\cdot 15}=\\frac{493}{345}.\n$$\n计算其小数近似值，并四舍五入至三位有效数字：\n$$\n\\frac{493}{345}\\approx 1.4289855\\ldots \\approx 1.43.\n$$\n因此，在夜猫子型组中，携带“T”等位基因相对于“C”等位基因的比值要高，其倍数约为 $1.43$。", "answer": "$$\\boxed{1.43}$$", "id": "1494345"}, {"introduction": "在GWAS分析中，获得一个统计上显著的结果仅仅是第一步，批判性地审视结果的来源至关重要。此问题模拟了一个由于实验设计不当（即“批次效应”）而导致大量假阳性关联的真实场景，旨在训练您识别和理解这些系统性偏误的能力，这是确保GWAS结论可靠性的关键技能。[@problem_id:1494331]", "problem": "一个大型研究联盟正在进行一项全基因组关联研究（GWAS），以识别与“航空代谢综合征”（Aero-Metabolic Syndrome, AMS）这种复杂呼吸系统疾病相关的遗传变异。研究设计包括从一个专业呼吸科诊所网络招募的 10,000 名病例，以及从普通人群健康登记库中挑选的 10,000 名对照。为了高效地管理大样本量，基因分型过程被分散进行。所有 10,000 名病例的 DNA 样本在一个中心实验室使用“BioArray v2.0”平台进行了处理，并对数百万个单核苷酸多态性（SNP）进行了基因分型。同时，所有 10,000 名对照的 DNA 样本在另一个设施使用“GenoChip v3.5”平台进行了处理和基因分型。\n\n在合并两个平台的数据并进行标准质量控制后，对每个 SNP 进行了统计关联检验。分析揭示了一个惊人的结果：遍布每条染色体的数万个 SNP 显示出与 AMS 存在统计学显著的关联，这远远超过了复杂疾病 GWAS 的典型发现。\n\n以下哪个选项为这种全基因组范围内的显著关联过剩现象提供了最合理的解释？\n\nA. 群体分层：病例组和对照组来自具有系统性不同遗传背景的群体，这些与遗传背景相关的等位基因频率差异被误解为疾病关联。\nB. 多基因结构：AMS 是一种高度多基因的疾病，其遗传风险确实由遍布整个基因组的数万个常见变异的累积微小效应决定。\nC. 选择偏倚：从专业诊所招募病例导致队列中患者的疾病形式更为严重，富集了大量在普通人群对照中未发现的罕见、高影响力的变异。\nD. 系统性基因分型偏倚：两种不同的基因分型平台在等位基因测量上存在微小、一致且平台特异性的不准确性，由于这些不准确性与病例-对照标签完全相关，从而产生了广泛的假阳性信号。\nE. 隐性亲缘关系：病例组在不知情的情况下包含了大量有近亲关系的个体，这违反了样本独立的统计假设，并夸大了家族内部共享位点的关联信号。", "solution": "我们将每个 SNP 的关联检验形式化为等位基因卡方检验或关于基因型的病例状态逻辑斯蒂回归。设 $Y \\in \\{0,1\\}$ 表示病例状态，$G \\in \\{0,1,2\\}$ 表示编码后的基因型，并考虑对于每个 SNP，在逻辑斯蒂模型 $\\ln\\left(\\frac{\\Pr(Y=1 \\mid G)}{\\Pr(Y=0 \\mid G)}\\right) = \\alpha + \\beta_{G} G$ 中的原假设 $H_{0}: \\beta_{G} = 0$。在模型设定正确且无混杂因素的情况下，得分检验或沃尔德检验统计量在 $H_{0}$ 下服从渐近 $\\chi^{2}_{1}$ 分布，因此在原假设下，除了复杂疾病中少数真实的关联外，整个基因组的 $p$ 值应近似呈均匀分布。\n\n观察到的模式是全基因组范围内显著关联的过剩，遍布每条染色体，有数万个 SNP 达到了显著性水平。这种普遍的膨胀表明存在一个系统性的、偏离原假设的偏差，影响了绝大多数的 SNP。我们通过将每个选项与检验行为联系起来进行审查。\n\n选项 B（多基因结构）：对于一个高度多基因的性状，许多变异具有微小的真实效应。在严格的全基因组阈值 $\\alpha_{GW}$（例如 $\\alpha_{GW} \\approx 5 \\times 10^{-8}$）下检测一个 SNP 的统计功效取决于关联检验的非中心化参数 $\\Lambda$。对于一个加性检验，一个标准的近似公式为 $\\Lambda \\approx N_{\\text{eff}} \\cdot 2 p (1 - p) \\cdot (\\ln \\theta)^{2}$，其中 $p$ 是次要等位基因频率，$\\theta$ 是每个等位基因的比值比，而 $N_{\\text{eff}}$ 是一个由病例和对照数量决定的有效样本量函数。对于具有较小 $\\ln \\theta$ 值的现实复杂性状，即使有很大的 $N_{\\text{eff}}$，在 $\\alpha_{GW}$ 水平下的统计功效也有限。因此，仅凭多基因性并不能用这样的样本量产生数万个全基因组显著的命中；它会产生一个可通过连锁不平衡得分回归（LD score regression）或多基因评分等方法检测到的多基因信号，而不是普遍的单 SNP 显著性。\n\n选项 C（偏向严重性的选择偏倚）：招募更严重的病例可能会富集罕见的、高影响力的变异。基因芯片主要针对常见变异；罕见的、效应严重的等位基因通常标记效果不佳。此外，这种富集并不会在整个基因组的常见 SNP 上造成一致的等位基因频率差异；它不会在常见变异上产生广泛的假阳性。\n\n选项 E（隐性亲缘关系）：亲缘关系违反了独立性假设，如果不进行建模，会影响方差估计并夸大检验统计量。然而，这种膨胀通常取决于共享模式，并且并非在所有 SNP 上都一致；在实践中，它会产生一个温和的全基因组膨胀因子和有时是局部的信号，而不是遍布所有染色体的数万个显著关联。此外，亲缘关系会减小有效样本量，在使用正确的标准误后，这通常会减少而不是大规模增加全基因组显著命中的数量。\n\n选项 A（群体分层）：病例和对照之间系统性的遗传背景差异会因人口历史而非疾病，在全基因组范围内引起等位基因频率差异，从而夸大许多 SNP 的关联统计量。如果不加以校正，这很可能造成广泛的显著性。然而，标准的 GWAS 分析流程包括对遗传背景主成分的校正，这通常能减轻大部分的群体分层效应。虽然 A 可以解释广泛的膨胀，但本研究的设计提供了一个更直接、更强的混杂来源。\n\n选项 D（来自不同平台的系统性基因分型偏倚）：在这里，基因分型平台与表型完全混杂：所有病例使用 BioArray v2.0，所有对照使用 GenoChip v3.5。设 $B \\in \\{0,1\\}$ 表示平台，病例为 $B=1$，对照为 $B=0$。设真实的加性基因型为 $G$，但测得的基因型为 $\\tilde{G} = G + \\epsilon_{B}$，其中由于差异性基因型检出（differential calling）、差异性缺失（differential missingness）或探针化学性质的差异，导致 $E[\\epsilon_{1}] \\neq E[\\epsilon_{0}]$ 或误差分布因平台而异。病例和对照之间测得的平均基因型的期望差异为\n$$\nE[\\tilde{G} \\mid Y=1] - E[\\tilde{G} \\mid Y=0] = \\underbrace{E[G \\mid Y=1] - E[G \\mid Y=0]}_{\\Delta \\text{ (真实效应)}} + \\underbrace{E[\\epsilon_{1}] - E[\\epsilon_{0}]}_{\\delta \\text{ (平台偏倚)}}.\n$$\n在大多数 SNP 的原假设下，$\\Delta = 0$，但只要存在平台特异性的检出偏倚，就有 $\\delta \\neq 0$。因为 $B$ 与 $Y$ 完全共线性，所以无法在关联模型中对 $B$ 进行校正；遗漏变量偏倚会将平台引起的差异归因于基因型系数，从而产生虚假的关联。等位基因卡方检验的检验统计量近似为\n$$\nT \\approx \\frac{\\left(\\hat{p}_{\\text{case}} - \\hat{p}_{\\text{control}}\\right)^{2}}{\\hat{V}},\n$$\n其中 $\\hat{p}_{\\text{case}}$ 和 $\\hat{p}_{\\text{control}}$ 是观察到的等位基因频率，$\\hat{V}$ 是原假设下的估计方差。如果由于平台偏倚，在许多 SNP 上都有 $\\hat{p}_{\\text{case}} - \\hat{p}_{\\text{control}} \\approx \\delta$，那么 $T$ 就会在全基因组范围内被夸大。与削弱关联的随机非差异性测量误差不同，这是一种与结果状态相关的差异性错分，它会同时在许多 SNP 上产生偏离原假设的偏倚，这与观察到的遍布所有染色体的数万个显著命中的模式完全吻合。\n\n考虑到所有病例和对照都在不同设施使用不同平台进行基因分型的特定设计细节，与病例-对照状态完全相关的系统性平台特异性基因分型偏倚，是对此全基因组范围内显著关联过剩现象最合理、最直接的解释。\n\n因此，正确选项是 D。", "answer": "$$\\boxed{D}$$", "id": "1494331"}, {"introduction": "GWAS的最终目标之一是利用其发现来预测个体对复杂性状的遗传易感性，而多基因风险评分（Polygenic Risk Score, PRS）是实现这一目标的主要工具。本题是一个高级编程实践，您将从头开始模拟一个完整的GWAS到PRS的流程，包括数据生成、关联分析、以及基于不同显著性阈值构建和评估预测模型。这个练习将综合运用GWAS的核心概念，让您掌握其在转化医学中的强大应用。[@problem_id:2394707]", "problem": "你的任务是在一个模拟的全基因组关联研究 (GWAS) 环境中构建一个多基因风险评分 (PRS)，并评估其预测准确性作为单核苷酸多态性 (SNP) 纳入阈值的函数。目标是为几种参数配置定义、计算并报告预测相关性的平方。\n\n定义与设置：\n\n- 全基因组关联研究 (GWAS) 旨在检验遗传变异与性状之间的关联。考虑 $m$ 个单核苷酸多态性 (SNP)，每个SNP都有一个次要等位基因频率 (MAF)。对于每个SNP $j \\in \\{1,\\ldots,m\\}$，个体的基因型被编码为次要等位基因的数量，其取值在 $\\{0,1,2\\}$ 中。\n- 对于每个SNP $j$，其MAF $p_j$ 从区间 $[0.05, 0.5]$ 上的连续均匀分布中独立抽取。在哈迪-温伯格平衡条件下，将每个基因型条目模拟为从 $\\mathrm{Binomial}(2, p_j)$ 分布中进行的独立抽样。\n- 将样本分为一个大小为 $n_{\\text{train}}$ 的训练队列和一个大小为 $n_{\\text{test}}$ 的测试队列。令 $\\mathbf{G}_{\\text{train}} \\in \\mathbb{R}^{n_{\\text{train}} \\times m}$ 和 $\\mathbf{G}_{\\text{test}} \\in \\mathbb{R}^{n_{\\text{test}} \\times m}$ 为相应的基因型矩阵。\n- 使用训练队列的统计数据对SNP列进行标准化：对于每个SNP $j$，计算 $\\mathbf{G}_{\\text{train}}$ 中第 $j$ 列的训练均值 $\\mu_j$ 和标准差 $\\sigma_j$。通过以下方式定义标准化矩阵 $\\mathbf{X}_{\\text{train}}$ 和 $\\mathbf{X}_{\\text{test}}$：\n  $$X_{\\text{train}}[i,j] = \\begin{cases}\n  \\dfrac{G_{\\text{train}}[i,j] - \\mu_j}{\\sigma_j}  \\text{若 } \\sigma_j  0,\\\\\n  0  \\text{若 } \\sigma_j = 0,\n  \\end{cases}\n  \\qquad\n  X_{\\text{test}}[i,j] = \\begin{cases}\n  \\dfrac{G_{\\text{test}}[i,j] - \\mu_j}{\\sigma_j}  \\text{若 } \\sigma_j  0,\\\\\n  0  \\text{若 } \\sigma_j = 0.\n  \\end{cases}$$\n  如果 $\\sigma_j = 0$，则在两个队列中都将该标准化列视为恒为 $0$。\n- 从 $\\{1,\\ldots,m\\}$ 中无放回地均匀选择 $k$ 个致病SNP索引；定义真实效应向量 $\\boldsymbol{\\beta}^{\\star} \\in \\mathbb{R}^m$，使得对于非致病SNP $j$，$\\beta^{\\star}_j = 0$，并且原始致病效应独立地从 $\\mathcal{N}(0,1)$ 分布中抽取。\n- 设窄义遗传力为 $h^2 \\in [0,1]$。缩放原始效应向量以使训练集中的遗传方差等于 $h^2$，方法如下。计算训练集中的遗传成分 $\\mathbf{g}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}_{\\text{raw}}$，其方差为 $v_g = \\mathrm{Var}(\\mathbf{g}_{\\text{train}})$，并设置\n  $$\\boldsymbol{\\beta}^{\\star} = \\begin{cases}\n  \\boldsymbol{\\beta}_{\\text{raw}} \\sqrt{\\dfrac{h^2}{v_g}}  \\text{若 } v_g  0,\\\\\n  \\mathbf{0}  \\text{若 } v_g = 0.\n  \\end{cases}$$\n  定义环境噪声方差为 $\\sigma_e^2 = 1 - h^2$。\n- 通过以下方式在两个队列中生成表型：\n  $$\\mathbf{y}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{train}}, \\quad \\boldsymbol{\\varepsilon}_{\\text{train}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I}),$$\n  $$\\mathbf{y}_{\\text{test}} = \\mathbf{X}_{\\text{test}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{test}}, \\quad \\boldsymbol{\\varepsilon}_{\\text{test}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I}).$$\n- 在训练队列中，为每个SNP $j$ 进行单变量关联分析，方法是拟合一个带截距的线性模型，并令 $p_j$ 为SNP $j$ 的斜率等于 $0$ 这一零假设的双侧 $p$ 值。等价地，如果 $r_j$ 表示 $\\mathbf{X}_{\\text{train}}$ 的第 $j$ 列与 $\\mathbf{y}_{\\text{train}}$ 之间的皮尔逊相关性，自由度为 $\\nu = n_{\\text{train}} - 2$，定义 $t$ 统计量\n  $$t_j = \\frac{r_j}{\\sqrt{1 - r_j^2}} \\sqrt{\\nu},$$\n  和双侧 $p$ 值\n  $$p_j = 2 \\, \\mathbb{P}\\left(T_{\\nu} \\ge |t_j|\\right),$$\n  其中 $T_{\\nu}$ 是一个具有 $\\nu$ 个自由度的学生t分布随机变量。如果SNP $j$ 在训练集中的方差为零或 $\\mathbf{y}_{\\text{train}}$ 的方差为零，则设 $p_j = 1$。\n- 对于给定的阈值 $p_T \\in (0,1]$，定义纳入的SNP集合 $S(p_T) = \\{j \\in \\{1,\\ldots,m\\} \\mid p_j \\le p_T\\}$。令 $\\hat{\\beta}_j$ 为在训练队列中为SNP $j$ 估计的单变量普通最小二乘法斜率（带截距）。定义测试集在阈值 $p_T$ 下的PRS为\n  $$\\mathrm{PRS}_{\\text{test}}(p_T) = \\sum_{j \\in S(p_T)} \\hat{\\beta}_j \\, X_{\\text{test}}[:,j].$$\n  如果 $S(p_T)$ 为空，则定义 $\\mathrm{PRS}_{\\text{test}}(p_T)$ 为零向量。\n- 将预测准确性定义为测试队列上的决定系数，\n  $$R^2(p_T) = \\left(\\mathrm{Corr}\\left(\\mathrm{PRS}_{\\text{test}}(p_T), \\mathbf{y}_{\\text{test}}\\right)\\right)^2,$$\n  其中 $\\mathrm{Corr}$ 表示皮尔逊相关性。如果在测试队列中 $\\mathrm{PRS}_{\\text{test}}(p_T)$ 或 $\\mathbf{y}_{\\text{test}}$ 的方差为零，则设置 $R^2(p_T) = 0$。\n\n任务：\n\n- 对于下面测试套件中的每个参数集，使用提供的随机种子执行上述模拟和分析。对于每个指定的阈值列表，按给定顺序计算每个 $p_T$ 的 $R^2(p_T)$。\n- 报告每个 $R^2(p_T)$，四舍五入到 $6$ 位小数。\n\n测试套件：\n\n- 情况 A: 种子 $= 42$, $n_{\\text{train}} = 1500$, $n_{\\text{test}} = 1000$, $m = 3000$, $k = 150$, $h^2 = 0.5$, 阈值 $= \\left[10^{-8}, 10^{-5}, 10^{-3}, 10^{-2}, 10^{-1}, 5 \\times 10^{-1}, 1\\right]$。\n- 情况 B: 种子 $= 7$, $n_{\\text{train}} = 300$, $n_{\\text{test}} = 300$, $m = 1500$, $k = 50$, $h^2 = 0.5$, 阈值 $= \\left[10^{-20}, 10^{-5}, 10^{-3}, 10^{-2}, 10^{-1}, 1\\right]$。\n- 情况 C: 种子 $= 2023$, $n_{\\text{train}} = 800$, $n_{\\text{test}} = 800$, $m = 2000$, $k = 0$, $h^2 = 0.0$, 阈值 $= \\left[10^{-5}, 10^{-3}, 10^{-2}, 10^{-1}, 1\\right]$。\n- 情况 D: 种子 $= 99$, $n_{\\text{train}} = 1200$, $n_{\\text{test}} = 800$, $m = 2500$, $k = 100$, $h^2 = 0.8$, 阈值 $= \\left[10^{-8}, 10^{-6}, 10^{-4}, 10^{-2}, 1\\right]$。\n\n边缘情况约定：\n\n- 如果任何SNP列在训练队列中的方差为零，则在两个队列中都将其标准化值设为零，其估计效应 $\\hat{\\beta}_j$ 设为 $0$，其 $p_j$ 设为 $1$。\n- 如果训练表型方差为零，则将所有 $\\hat{\\beta}_j = 0$ 和所有 $p_j = 1$。\n- 如果测试PRS或测试表型的方差为零，则对于该阈值设置 $R^2(p_T) = 0$。\n\n最终输出规范：\n\n- 你的程序应生成单行输出，其中包含一个逗号分隔的列表之列表的结果，不含空格，格式如下：\n  - 对于每种情况，按给定顺序为其阈值输出列表 $\\left[R^2(p_{T,1}), R^2(p_{T,2}), \\ldots \\right]$，每个条目四舍五入到 $6$ 位小数。\n  - 将四种情况 A、B、C、D 的结果按顺序聚合到一个列表中，形成一个嵌套列表。例如：$\\left[[r_{A,1},r_{A,2}], [r_{B,1},r_{B,2}], [r_{C,1},r_{C,2}], [r_{D,1},r_{D,2}]\\right]$。", "solution": "所提出的问题是统计遗传学领域一项全面且有效的模拟研究，具体涉及全基因组关联研究 (GWAS) 和多基因风险评分 (PRS)。任务是实现指定的模拟流程，该流程在科学上基于复杂性状的标准多基因模型，并评估由此产生的PRS的预测准确性。所有参数和程序都定义明确，使得问题客观且算法上易于处理。我将首先详细解释该方法论，然后进行实现。\n\n整个过程可以分解为几个逻辑阶段：数据模拟、关联分析、PRS构建和评估。\n\n首先，我们为两个不同的队列模拟遗传和表型数据：一个大小为 $n_{\\text{train}}$ 的训练队列和一个大小为 $n_{\\text{test}}$ 的测试队列。我们考虑一个包含 $m$ 个单核苷酸多态性 (SNP) 的基因组。对于每个SNP $j$，其次要等位基因频率 (MAF)，表示为 $p_j$，是从均匀分布 $\\mathrm{Uniform}(0.05, 0.5)$ 中抽取的。在哈迪-温伯格平衡的假设下，每个个体在SNP $j$ 处的基因型（即次要等位基因的计数）是从二项分布 $\\mathrm{Binomial}(2, p_j)$ 中进行的独立随机抽样。这个过程生成了原始基因型矩阵 $\\mathbf{G}_{\\text{train}}$ 和 $\\mathbf{G}_{\\text{test}}$。\n\n原始基因型计数通常不直接用于分析，而是需要进行标准化处理。对于每个SNP $j$，我们仅使用训练数据计算其均值 $\\mu_j$ 和标准差 $\\sigma_j$。然后使用这些统计数据来标准化两个队列的基因型矩阵：\n$$X_{\\text{train}}[i,j] = \\frac{G_{\\text{train}}[i,j] - \\mu_j}{\\sigma_j} \\quad \\text{和} \\quad X_{\\text{test}}[i,j] = \\frac{G_{\\text{test}}[i,j] - \\mu_j}{\\sigma_j}$$\n一个关键的边缘情况是当某个SNP在训练队列中的方差为零时（$\\sigma_j = 0$）。在这种情况下，该SNP不提供信息，其标准化值在两个队列中都设置为 $0$。\n\n接下来，我们通过定义性状的遗传结构来为我们的模拟建立基准真相。我们从 $m$ 个SNP中随机选择 $k$ 个作为“致病”SNP。真实遗传效应向量 $\\boldsymbol{\\beta}^{\\star} \\in \\mathbb{R}^m$ 仅在这些致病SNP处有非零项。这 $k$ 个SNP的初始原始效应是从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取的。然后对这些原始效应 $\\boldsymbol{\\beta}_{\\text{raw}}$ 进行缩放，以满足指定的窄义遗传力 $h^2$。遗传力表示可归因于遗传方差的表型方差比例。我们在训练集中计算遗传成分为 $\\mathbf{g}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}_{\\text{raw}}$ 及其方差 $v_g = \\mathrm{Var}(\\mathbf{g}_{\\text{train}})$。最终缩放后的效应向量是：\n$$\\boldsymbol{\\beta}^{\\star} = \\boldsymbol{\\beta}_{\\text{raw}} \\sqrt{\\frac{h^2}{v_g}}$$\n这种缩放确保了训练数据中真实遗传成分的方差 $\\mathrm{Var}(\\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}^{\\star})$恰好为 $h^2$。如果 $v_g=0$，则 $\\boldsymbol{\\beta}^{\\star}$ 是零向量。总表型方差被归一化为 $1$，因此环境噪声的方差为 $\\sigma_e^2 = 1 - h^2$。然后使用线性模型为两个队列生成表型：\n$$\\mathbf{y}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{train}}, \\quad \\text{其中} \\quad \\boldsymbol{\\varepsilon}_{\\text{train}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I})$$\n$$\\mathbf{y}_{\\text{test}} = \\mathbf{X}_{\\text{test}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{test}}, \\quad \\text{其中} \\quad \\boldsymbol{\\varepsilon}_{\\text{test}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I})$$\n\n有了模拟的训练数据 $(\\mathbf{X}_{\\text{train}}, \\mathbf{y}_{\\text{train}})$，我们进行GWAS。对每个SNP $j$，我们检验其与表型无关联的零假设。这是通过拟合一个单变量线性模型来完成的。关联强度由一个 $t$ 统计量来量化。设 $r_j$ 为第 $j$ 个SNP向量 $\\mathbf{X}_{\\text{train}}[:,j]$ 与表型向量 $\\mathbf{y}_{\\text{train}}$ 之间的皮尔逊相关性。$t$ 统计量为：\n$$t_j = \\frac{r_j}{\\sqrt{1 - r_j^2}} \\sqrt{\\nu}$$\n其中 $\\nu = n_{\\text{train}} - 2$ 是自由度。然后从学生t分布计算双侧 $p$ 值 $p_j$：$p_j = 2 \\, \\mathbb{P}(T_{\\nu} \\ge |t_j|)$，其中 $T_{\\nu}$ 是一个服从 $\\nu$ 个自由度t分布的随机变量。同时，我们为每个SNP估计单变量普通最小二乘法 (OLS) 的效应大小 $\\hat{\\beta}_j$。对于一个标准化的预测变量，这个斜率可以被高效计算。\n\n下一步是为测试集构建PRS。基于一个指定的 $p$ 值阈值 $p_T$，我们构建一个被纳入的SNP集合 $S(p_T) = \\{j \\mid p_j \\le p_T\\}$。PRS是测试队列中标准化基因型的加权和，权重是来自训练GWAS的估计效应大小 $\\hat{\\beta}_j$：\n$$\\mathrm{PRS}_{\\text{test}}(p_T) = \\sum_{j \\in S(p_T)} \\hat{\\beta}_j \\, X_{\\text{test}}[:,j]$$\n如果没有SNP满足阈值，则 $S(p_T)$ 为空，PRS是一个零向量。\n\n最后，我们评估PRS的预测准确性。这是通过决定系数 $R^2$ 来衡量的，即测试队列中预测的PRS与实际表型之间的皮尔逊相关性的平方：\n$$R^2(p_T) = \\left(\\mathrm{Corr}\\left(\\mathrm{PRS}_{\\text{test}}(p_T), \\mathbf{y}_{\\text{test}}\\right)\\right)^2$$\n如果PRS或测试表型的方差为零，则相关性未定义，此时 $R^2(p_T)$ 设为 $0$。\n\n该算法将为测试套件中提供的每个参数集系统地执行这整个流程。为提高效率，将使用 `numpy`进行向量化计算，特别是在GWAS摘要统计和PRS计算中。每种情况的随机种子确保了随机模拟的可复现性。最终输出将是计算出的 $R^2(p_T)$ 值，按规定进行四舍五入和格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import t as student_t\n\ndef run_simulation(seed, n_train, n_test, m, k, h2, thresholds):\n    \"\"\"\n    Performs a single GWAS/PRS simulation run for a given set of parameters.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # 1. Simulate MAFs and Genotypes\n    mafs = rng.uniform(0.05, 0.5, size=m)\n    g_train = rng.binomial(2, mafs, size=(n_train, m))\n    g_test = rng.binomial(2, mafs, size=(n_test, m))\n    \n    # 2. Standardize Genotypes\n    mu_train = np.mean(g_train, axis=0)\n    sigma_train = np.std(g_train, axis=0)\n    \n    std_is_zero = (sigma_train == 0)\n    \n    x_train = np.zeros_like(g_train, dtype=float)\n    x_test = np.zeros_like(g_test, dtype=float)\n    \n    non_zero_std_indices = ~std_is_zero\n    \n    # Use np.divide with where clause to avoid runtime warnings\n    if np.any(non_zero_std_indices):\n        x_train[:, non_zero_std_indices] = np.divide(\n            g_train[:, non_zero_std_indices] - mu_train[non_zero_std_indices],\n            sigma_train[non_zero_std_indices]\n        )\n        x_test[:, non_zero_std_indices] = np.divide(\n            g_test[:, non_zero_std_indices] - mu_train[non_zero_std_indices],\n            sigma_train[non_zero_std_indices]\n        )\n\n    # 3. Simulate True Effects and Scale by Heritability\n    beta_raw = np.zeros(m)\n    if k  0:\n        causal_indices = rng.choice(m, size=k, replace=False)\n        beta_raw[causal_indices] = rng.normal(0, 1, size=k)\n    \n    g_train_component = x_train @ beta_raw\n    v_g = np.var(g_train_component)\n    \n    beta_star = np.zeros(m)\n    if v_g  0 and h2  0:\n        scaling_factor = np.sqrt(h2 / v_g)\n        beta_star = beta_raw * scaling_factor\n    \n    # 4. Simulate Phenotypes\n    sigma_e2 = 1.0 - h2\n    sigma_e = np.sqrt(sigma_e2) if sigma_e2  0 else 0.0\n    \n    y_train = x_train @ beta_star + rng.normal(0, sigma_e, size=n_train)\n    y_test = x_test @ beta_star + rng.normal(0, sigma_e, size=n_test)\n    \n    # 5. Perform GWAS in Training Cohort\n    hat_betas = np.zeros(m)\n    p_values = np.ones(m)\n    \n    y_train_var = np.var(y_train, ddof=1)\n    if y_train_var == 0:\n        # If y_train has no variance, all betas are 0 and p-values are 1.\n        # This is handled by hat_betas and p_values being pre-initialized.\n        pass\n    else:\n        y_train_c = y_train - np.mean(y_train)\n        \n        # OLS slope estimates (beta_hat)\n        sum_x_sq = np.sum(x_train**2, axis=0)\n        valid_snps_for_beta = (sum_x_sq  0)\n        \n        if np.any(valid_snps_for_beta):\n            hat_betas[valid_snps_for_beta] = (x_train[:, valid_snps_for_beta].T @ y_train_c) / sum_x_sq[valid_snps_for_beta]\n        \n        # Pearson correlations (r)\n        # r = beta_hat * (std_x / std_y)\n        std_x_train_sample = np.std(x_train, axis=0, ddof=1)\n        std_y_train_sample = np.sqrt(y_train_var)\n        \n        correlations = np.zeros(m)\n        valid_snps_for_corr = (std_x_train_sample  0)\n        if np.any(valid_snps_for_corr):\n            correlations[valid_snps_for_corr] = hat_betas[valid_snps_for_corr] * (std_x_train_sample[valid_snps_for_corr] / std_y_train_sample)\n\n        # Handle perfect correlation case to avoid division by zero in t-statistic\n        correlations = np.clip(correlations, -1.0 + 1e-15, 1.0 - 1e-15)\n\n        # t-statistics and p-values\n        df = n_train - 2\n        if df  0:\n            t_stats = (correlations / np.sqrt(1 - correlations**2)) * np.sqrt(df)\n            p_values = 2 * student_t.sf(np.abs(t_stats), df)\n            \n            # SNPs with zero variance in training must have p-value of 1\n            p_values[std_is_zero] = 1.0\n\n    # 6. Calculate PRS and R^2 for each threshold\n    r2_results = []\n    y_test_var = np.var(y_test)\n    \n    for p_t in thresholds:\n        included_snps_mask = (p_values = p_t)\n        \n        if not np.any(included_snps_mask) or y_test_var == 0:\n            r2_results.append(0.0)\n            continue\n        \n        hat_betas_selected = hat_betas[included_snps_mask]\n        x_test_selected = x_test[:, included_snps_mask]\n        \n        prs_test = x_test_selected @ hat_betas_selected\n        \n        prs_var = np.var(prs_test)\n        \n        if prs_var == 0:\n            r2_results.append(0.0)\n            continue\n            \n        corr_matrix = np.corrcoef(prs_test, y_test)\n        corr = corr_matrix[0, 1]\n        \n        r2 = corr**2\n        r2_results.append(np.round(r2, 6))\n        \n    return r2_results\n\n\ndef solve():\n    test_cases = [\n        {'seed': 42, 'n_train': 1500, 'n_test': 1000, 'm': 3000, 'k': 150, 'h2': 0.5, 'thresholds': [1e-8, 1e-5, 1e-3, 1e-2, 1e-1, 5e-1, 1]},\n        {'seed': 7, 'n_train': 300, 'n_test': 300, 'm': 1500, 'k': 50, 'h2': 0.5, 'thresholds': [1e-20, 1e-5, 1e-3, 1e-2, 1e-1, 1]},\n        {'seed': 2023, 'n_train': 800, 'n_test': 800, 'm': 2000, 'k': 0, 'h2': 0.0, 'thresholds': [1e-5, 1e-3, 1e-2, 1e-1, 1]},\n        {'seed': 99, 'n_train': 1200, 'n_test': 800, 'm': 2500, 'k': 100, 'h2': 0.8, 'thresholds': [1e-8, 1e-6, 1e-4, 1e-2, 1]}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = run_simulation(\n            seed=case['seed'],\n            n_train=case['n_train'],\n            n_test=case['n_test'],\n            m=case['m'],\n            k=case['k'],\n            h2=case['h2'],\n            thresholds=case['thresholds']\n        )\n        all_results.append(results)\n    \n    # Format the final output string exactly as required\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "2394707"}]}