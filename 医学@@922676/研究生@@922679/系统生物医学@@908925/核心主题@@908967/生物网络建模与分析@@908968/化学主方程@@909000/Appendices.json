{"hands_on_practices": [{"introduction": "掌握化学主方程的第一步是学习如何构建它。这个练习将指导您把一个简单的生化反应网络翻译成化学主方程的数学语言。通过推导一个基本生灭过程的方程 [@problem_id:4392634]，您将深入理解概率平衡原理，即任何状态的概率变化率都等于流入该状态的总概率通量减去流出该状态的总概率通量。", "problem": "考虑一个固定体积内充分混合的单物种生化系统，其模型为连续时间马尔可夫链 (CTMC)。在时间 $t$ 时，物种 $A$ 的分子数由整数值随机变量 $n(t) \\in \\{0,1,2,\\dots\\}$ 表示。反应网络包含两个反应：一个速率常数为 $k_b > 0$ 的出生反应 $A \\to A + A$，以及一个速率常数为 $k_d > 0$ 的死亡反应 $A \\to \\varnothing$。在质量作用动力学下，出生反应的倾向函数为 $a_1(n) = k_b n$，死亡反应的倾向函数为 $a_2(n) = k_d n$。从定义化学主方程 (CME) 的概率平衡原理出发，推导在时间 $t$ 处于状态 $n$ 的概率 $P(n,t)$ 的显式 CME，并考虑适当的边界条件。然后，计算从状态 $n$ 到状态 $n+1$ 和 $n-1$ 的单步转移速率。将最终答案表示为一个行矩阵，其中第一个元素是到 $n+1$ 的速率，第二个元素是到 $n-1$ 的速率。最终表达式无需四舍五入，也不应包含单位。", "solution": "该问题陈述已经过验证，被认为是系统生物医学领域中一个提法恰当、有科学依据的问题，具体涉及随机化学动力学。它提供了推导化学主方程和所要求的转移速率所需的所有必要信息。\n\n化学主方程 (CME) 描述了系统在时间 $t$ 拥有 $n$ 个某物种分子的概率 $P(n, t)$ 的时间演化。该方程由连续时间马尔可夫链的概率平衡原理推导而来。处于特定状态 $n$ 的概率变化率等于所有转移*进入*状态 $n$ 的速率之和减去所有转移*离开*状态 $n$ 的速率之和。CME 的一般形式写作：\n$$ \\frac{dP(n,t)}{dt} = \\sum_{n' \\neq n} \\left[ W(n|n')P(n',t) - W(n'|n)P(n,t) \\right] $$\n其中 $W(n'|n)$ 是从状态 $n$ 到状态 $n'$ 的转移速率。在化学反应的背景下，此转移速率由引起状态变化的反应的倾向函数 $a(n)$ 给出。\n\n所考虑的系统涉及单个物种 $A$ 和两个反应：\n1. 出生反应：$A \\to A + A$。此反应使分子数增加一，导致状态从 $n \\to n+1$ 转移。倾向函数为 $a_1(n) = k_b n$。\n2. 死亡反应：$A \\to \\varnothing$。此反应使分子数减少一，导致状态从 $n \\to n-1$ 转移。倾向函数为 $a_2(n) = k_d n$。\n\n现在我们可以为任意整数状态 $n \\ge 1$ 构建 CME。\n\n转移*进入*状态 $n$ 的总速率（增益项）是两个事件概率的和：\n- 通过出生反应从状态 $n-1$ 转移到 $n$。此转移的速率是在状态 $n-1$ 处评估的倾向函数，即 $a_1(n-1) = k_b (n-1)$。因此，从 $n-1$ 进入状态 $n$ 的总通量为 $k_b (n-1) P(n-1, t)$。此项仅在 $n > 1$ 时非零。\n- 通过死亡反应从状态 $n+1$ 转移到 $n$。此转移的速率是在状态 $n+1$ 处评估的倾向函数，即 $a_2(n+1) = k_d (n+1)$。因此，从 $n+1$ 进入状态 $n$ 的总通量为 $k_d (n+1) P(n+1, t)$。\n\n转移*离开*状态 $n$ 的总速率（损失项）是两个事件概率的和：\n- 通过出生反应从状态 $n$ 转移到 $n+1$。速率由倾向函数 $a_1(n) = k_b n$ 给出。从状态 $n$ 到 $n+1$ 的总通量为 $k_b n P(n, t)$。\n- 通过死亡反应从状态 $n$ 转移到 $n-1$。速率由倾向函数 $a_2(n) = k_d n$ 给出。从状态 $n$ 到 $n-1$ 的总通量为 $k_d n P(n, t)$。\n\n结合这些增益和损失项，对于 $n \\ge 1$ 的 CME 为：\n$$ \\frac{dP(n,t)}{dt} = \\left[ k_b (n-1) P(n-1,t) + k_d (n+1) P(n+1,t) \\right] - \\left[ k_b n P(n,t) + k_d n P(n,t) \\right] $$\n$$ \\frac{dP(n,t)}{dt} = k_b (n-1) P(n-1,t) + k_d(n+1)P(n+1,t) - (k_b + k_d) n P(n,t) $$\n\n接下来，我们必须考虑 $n=0$ 时的边界条件。\n- 状态 $n=0$ 的增益项：进入状态 $0$ 的唯一方式是通过死亡反应从状态 $1$ 转移。此转移的速率为 $a_2(1) = k_d \\cdot 1 = k_d$。因此，进入状态 $0$ 的通量为 $k_d P(1,t)$。\n- 状态 $n=0$ 的损失项：要离开状态 $0$，必须发生反应。在 $n=0$ 时，出生和死亡反应的倾向函数分别为 $a_1(0) = k_b \\cdot 0 = 0$ 和 $a_2(0) = k_d \\cdot 0 = 0$。由于两个倾向函数都为零，因此没有反应可以发生。离开状态 $0$ 的总转移速率为 $0$。这意味着 $n=0$ 是一个吸收态。\n\n因此，边界状态 $n=0$ 的 CME 为：\n$$ \\frac{dP(0,t)}{dt} = k_d P(1,t) $$\n\n题目接着要求计算从状态 $n$ 到状态 $n+1$ 和 $n-1$ 的单步转移速率。根据定义，这些速率就是引起这些特定转移的反应的倾向函数。\n- 从状态 $n$ 到状态 $n+1$ 的转移是由出生反应 $A \\to A+A$ 引起的。此转移的速率是其倾向函数，即 $W(n+1|n) = a_1(n) = k_b n$。\n- 从状态 $n$ 到状态 $n-1$ 的转移是由死亡反应 $A \\to \\varnothing$ 引起的。此转移的速率是其倾向函数，即 $W(n-1|n) = a_2(n) = k_d n$。\n\n这些速率对任何状态 $n \\ge 1$ 都有效。对于 $n=0$，两个速率都为 $0$。问题要求的是状态 $n$ 的通用表达式。\n\n最终答案需以行矩阵形式提供，其中第一个元素是到 $n+1$ 的速率，第二个元素是到 $n-1$ 的速率。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nk_b n  k_d n\n\\end{pmatrix}\n}\n$$", "id": "4392634"}, {"introduction": "在构建了化学主方程之后，下一步自然是求解它。这个练习介绍了一种强大的分析工具——概率生成函数(PGF)，用于求解一个典型基因表达模型的稳态解 [@problem_id:4392648]。虽然大多数化学主方程难以解析求解，但对于某些重要的线性系统，PGF可以将无限维的常微分方程组转化为一个可解的偏微分方程，从而揭示出系统在稳态下的完整概率分布特性，例如蛋白质数量的泊松分布特性。", "problem": "考虑一个混合均匀的单细胞基因表达模型，其中单个基因合成蛋白质分子，蛋白质分子独立降解。令 $X(t) \\in \\{0,1,2,\\dots\\}$ 表示在时间 $t$ 的蛋白质拷贝数。假设合成事件以恒定的倾向 $k_s > 0$ 发生，每个蛋白质以倾向 $k_d > 0$ 独立降解，因此当状态为 $n$ 时，总降解倾向为 $k_d n$。概率分布 $P(n,t) = \\mathbb{P}\\{X(t) = n\\}$ 的时间演化由化学主方程（CME）控制，这是一个关于离散状态 $n$ 的平衡方程。使用CME作为基础描述，并以概率生成函数（PGF）$G(z,t) = \\sum_{n=0}^{\\infty} z^{n} P(n,t)$ 为工具，在存在稳态极限的假设下，推导 $n \\in \\mathbb{N}_0$ 的稳态分布 $P_{\\mathrm{st}}(n)$。您的推导必须从CME开始，通过PGF对其进行变换，得到并求解稳态PGF的微分方程，然后从稳态PGF中提取 $P_{\\mathrm{st}}(n)$。最后，从第一性原理验证该稳态分布是泊松分布，并用 $k_s$ 和 $k_d$ 表示其均值。请以包含 $k_s$、$k_d$ 和 $n$ 的单个闭式解析表达式的形式，报告稳态概率质量函数 $P_{\\mathrm{st}}(n)$。不需要进行数值评估，也无需四舍五入。请用精确函数和阶乘表示您的最终答案。", "solution": "用户提供了一个系统生物医学中明确定义的问题，要求使用化学主方程（CME）和概率生成函数（PGF）来推导一个简单基因表达模型的稳态概率分布。\n\n**问题验证**\n\n**步骤1：提取给定条件**\n-   系统：一个混合均匀的单细胞基因表达模型。\n-   状态变量：$X(t) \\in \\{0, 1, 2, \\dots\\}$，在时间 $t$ 的蛋白质拷贝数。\n-   反应和倾向：\n    1.  蛋白质合成：$\\emptyset \\xrightarrow{k_s} \\text{蛋白质}$。倾向为常数 $k_s > 0$。此反应使蛋白质数量 $n$ 增加 1。\n    2.  蛋白质降解：$\\text{蛋白质} \\xrightarrow{k_d} \\emptyset$。单个蛋白质降解的倾向为 $k_d > 0$。对于具有 $n$ 个蛋白质的状态，总降解倾向为 $k_d n$。此反应使蛋白质数量 $n$ 减少 1。\n-   控制方程：概率分布 $P(n,t) = \\mathbb{P}\\{X(t) = n\\}$ 的时间演化由化学主方程（CME）描述。\n-   工具：概率生成函数（PGF）定义为 $G(z,t) = \\sum_{n=0}^{\\infty} z^{n} P(n,t)$。\n-   目标：推导 $n \\in \\mathbb{N}_0$ 的稳态分布 $P_{\\mathrm{st}}(n)$。\n-   假设：当 $t \\to \\infty$ 时存在稳态极限。\n-   要求的方法：\n    1.  从CME开始。\n    2.  使用PGF变换CME，得到关于 $G(z,t)$ 的微分方程。\n    3.  求解稳态PGF，$G_{\\mathrm{st}}(z)$。\n    4.  从 $G_{\\mathrm{st}}(z)$ 中提取 $P_{\\mathrm{st}}(n)$。\n    5.  验证结果为泊松分布并确定其均值。\n-   要求的输出：以单个闭式解析表达式的形式报告 $P_{\\mathrm{st}}(n)$。\n\n**步骤2：使用提取的给定条件进行验证**\n-   **科学依据：** 该问题描述了一个线性生灭过程，这是随机化学动力学和系统生物学中的一个典型基础模型。它在科学上是合理的。\n-   **适定性：** 该问题在数学上是适定的。反应、参数和控制方程都已明确指定。稳态假设是此类分析的标准做法，对于 $k_s, k_d > 0$，已知存在唯一的稳态分布。求解路径已明确概述。\n-   **客观性：** 语言正式、精确，没有任何主观或模糊的元素。\n\n该问题不违反任何无效性标准。它是指定领域内一个标准的、非平凡的、可验证的问题。\n\n**步骤3：结论与行动**\n问题有效。将按要求进行求解。\n\n**稳态分布的推导**\n\n**1. 化学主方程 (CME)**\n系统的状态是蛋白质分子的数量 $n$。处于状态 $n$ 的概率 $P(n,t)$ 的变化由流入和流出该状态的概率通量平衡决定。\n反应是：\n-   合成：从状态 $n-1$ 到 $n$ 的跃迁，速率为 $k_s$。\n-   降解：从状态 $n+1$ 到 $n$ 的跃迁，速率为 $k_d(n+1)$。\n\nCME由下式给出：\n$\\frac{d P(n,t)}{dt} = (\\text{流入通量}) - (\\text{流出通量})$\n$\\frac{d P(n,t)}{dt} = [k_s P(n-1,t) + k_d(n+1)P(n+1,t)] - [(k_s + k_d n)P(n,t)]$\n\n此方程对 $n \\ge 1$ 成立。对于边界情况 $n=0$，从状态 $n=0$ 降解是不可能的，合成也不能从蛋白质数量为负数的状态发生。\n$\\frac{d P(0,t)}{dt} = k_d(1)P(1,t) - k_s P(0,t)$\n如果我们采用约定，对于 $n < 0$ 时 $P(n,t) = 0$，则可以用一个通用方程表示整个系统。\n\n**2. 变换为PGF方程**\n我们使用概率生成函数 $G(z,t) = \\sum_{n=0}^{\\infty} z^n P(n,t)$。其时间导数为 $\\frac{\\partial G}{\\partial t} = \\sum_{n=0}^{\\infty} z^n \\frac{dP(n,t)}{dt}$。\n代入CME：\n$\\frac{\\partial G}{\\partial t} = \\sum_{n=0}^{\\infty} z^n [k_s P(n-1,t) + k_d(n+1)P(n+1,t) - k_s P(n,t) - k_d n P(n,t)]$\n\n我们分别分析求和中的每一项：\n-   $\\sum_{n=0}^{\\infty} z^n k_s P(n-1,t) = k_s z \\sum_{n=0}^{\\infty} z^{n-1} P(n-1,t)$。令 $m = n-1$，则该式变为 $k_s z \\sum_{m=-1}^{\\infty} z^m P(m,t)$。由于 $P(-1,t)=0$，此项为 $k_s z G(z,t)$。\n-   $\\sum_{n=0}^{\\infty} z^n k_d (n+1) P(n+1,t) = k_d \\sum_{n=0}^{\\infty} (n+1) z^n P(n+1,t)$。令 $m = n+1$，则该式变为 $k_d \\sum_{m=1}^{\\infty} m z^{m-1} P(m,t)$。这是PGF关于 $z$ 的导数：$k_d \\frac{\\partial G(z,t)}{\\partial z}$。\n-   $\\sum_{n=0}^{\\infty} z^n (-k_s P(n,t)) = -k_s \\sum_{n=0}^{\\infty} z^n P(n,t) = -k_s G(z,t)$。\n-   $\\sum_{n=0}^{\\infty} z^n (-k_d n P(n,t)) = -k_d z \\sum_{n=0}^{\\infty} n z^{n-1} P(n,t) = -k_d z \\frac{\\partial G(z,t)}{\\partial z}$。\n\n将这些项合并，得到关于 $G(z,t)$ 的偏微分方程：\n$\\frac{\\partial G}{\\partial t} = k_s z G(z,t) + k_d \\frac{\\partial G}{\\partial z} - k_s G(z,t) - k_d z \\frac{\\partial G}{\\partial z}$\n$\\frac{\\partial G}{\\partial t} = (z-1) k_s G(z,t) - (z-1) k_d \\frac{\\partial G}{\\partial z}$\n$\\frac{\\partial G}{\\partial t} = (z-1) \\left( k_s G(z,t) - k_d \\frac{\\partial G}{\\partial z} \\right)$\n\n**3. 稳态PGF**\n在稳态下，概率分布不随时间变化，因此 $\\frac{dP_{\\mathrm{st}}(n)}{dt} = 0$，这意味着 $\\frac{\\partial G_{\\mathrm{st}}(z)}{\\partial t} = 0$。偏微分方程（PDE）变为关于稳态PGF $G_{\\mathrm{st}}(z)$ 的常微分方程（ODE）：\n$0 = (z-1) \\left( k_s G_{\\mathrm{st}}(z) - k_d \\frac{d G_{\\mathrm{st}}(z)}{dz} \\right)$\n\n为了使该方程在其收敛域内的所有 $z$（不仅仅是 $z=1$）上都成立，第二个因子必须为零：\n$k_s G_{\\mathrm{st}}(z) - k_d \\frac{d G_{\\mathrm{st}}(z)}{dz} = 0$\n这是一个一阶可分离常微分方程：\n$\\frac{dG_{\\mathrm{st}}}{G_{\\mathrm{st}}} = \\frac{k_s}{k_d} dz$\n\n对两边积分得到：\n$\\ln(G_{\\mathrm{st}}(z)) = \\frac{k_s}{k_d} z + C_0$\n$G_{\\mathrm{st}}(z) = C \\exp\\left(\\frac{k_s}{k_d} z\\right)$，其中 $C = \\exp(C_0)$ 是积分常数。\n\n为了确定 $C$，我们使用概率的归一化条件：$\\sum_{n=0}^{\\infty} P_{\\mathrm{st}}(n)=1$。用PGF表示，即 $G_{\\mathrm{st}}(1)=1$。\n$1 = C \\exp\\left(\\frac{k_s}{k_d} \\cdot 1\\right) \\implies C = \\exp\\left(-\\frac{k_s}{k_d}\\right)$\n\n将 $C$ 代回，我们得到稳态PGF：\n$G_{\\mathrm{st}}(z) = \\exp\\left(-\\frac{k_s}{k_d}\\right) \\exp\\left(\\frac{k_s}{k_d} z\\right) = \\exp\\left(\\frac{k_s}{k_d}(z-1)\\right)$\n\n**4. 提取稳态分布 $P_{\\mathrm{st}}(n)$**\n概率 $P_{\\mathrm{st}}(n)$ 是 $G_{\\mathrm{st}}(z)$ 在 $z=0$ 附近泰勒级数展开的系数：$G_{\\mathrm{st}}(z) = \\sum_{n=0}^{\\infty} P_{\\mathrm{st}}(n) z^n$。\n令 $\\lambda = \\frac{k_s}{k_d}$。稳态PGF为 $G_{\\mathrm{st}}(z) = \\exp(\\lambda(z-1)) = \\exp(-\\lambda)\\exp(\\lambda z)$。\n我们将 $\\exp(\\lambda z)$ 展开为麦克劳林级数：\n$\\exp(\\lambda z) = \\sum_{n=0}^{\\infty} \\frac{(\\lambda z)^n}{n!} = \\sum_{n=0}^{\\infty} \\frac{\\lambda^n}{n!} z^n$\n\n因此，PGF可以写为：\n$G_{\\mathrm{st}}(z) = \\exp(-\\lambda) \\sum_{n=0}^{\\infty} \\frac{\\lambda^n}{n!} z^n = \\sum_{n=0}^{\\infty} \\left(\\frac{\\lambda^n \\exp(-\\lambda)}{n!}\\right) z^n$\n\n通过将 $z^n$ 的系数与PGF的定义逐项比较，我们确定了稳态概率质量函数：\n$P_{\\mathrm{st}}(n) = \\frac{\\lambda^n \\exp(-\\lambda)}{n!}$\n\n**5. 验证和均值确定**\n将 $\\lambda = \\frac{k_s}{k_d}$ 代回 $P_{\\mathrm{st}}(n)$ 的表达式中：\n$P_{\\mathrm{st}}(n) = \\frac{\\left(\\frac{k_s}{k_d}\\right)^n \\exp\\left(-\\frac{k_s}{k_d}\\right)}{n!}$\n\n这是参数（均值）为 $\\mu = \\frac{k_s}{k_d}$ 的泊松分布的概率质量函数。稳态分布的均值，代表稳态下细胞中蛋白质分子的平均数量，确实是 $\\mathbb{E}[n] = \\frac{k_s}{k_d}$。这样就完成了验证。\n\n稳态概率质量函数 $P_{\\mathrm{st}}(n)$ 的最终解析表达式为：\n$P_{\\mathrm{st}}(n) = \\frac{1}{n!} \\left(\\frac{k_s}{k_d}\\right)^n \\exp\\left(-\\frac{k_s}{k_d}\\right)$", "answer": "$$\n\\boxed{\\frac{\\left(\\frac{k_s}{k_d}\\right)^n}{n!} \\exp\\left(-\\frac{k_s}{k_d}\\right)}\n$$", "id": "4392648"}, {"introduction": "对于复杂的生物系统，解析解往往遥不可及，这时计算方法就显得至关重要。本练习旨在搭建理论与实践之间的桥梁，要求您实现Gillespie随机模拟算法，并通过将其结果与从化学主方程推导出的精确矩方程进行比较来验证其正确性 [@problem_id:4392582]。通过这种方式，我们不仅能够验证我们的计算工具，还能加深对随机过程理论的理解，为探索那些只能通过模拟来研究的更复杂系统建立信心。", "problem": "考虑一个单物种基因表达的生灭过程，该过程在化学主方程 (CME) 的框架下被建模为一个连续时间、离散状态的马尔可夫跳跃过程。令 $X(t) \\in \\mathbb{N}_0$ 表示在时间 $t$ 的分子拷贝数。该系统有两个反应通道：合成（出生），其倾向为常数 $a_1(n) = k_b$，产生反应 $X \\to X + 1$；以及降解（死亡），其倾向为 $a_2(n) = k_d n$，产生反应 $X \\to X - 1$。初始拷贝数为 $X(0) = x_0$。时间单位为秒，速率单位为 $\\mathrm{s^{-1}}$，拷贝数为无量纲的计数值。\n\n仅从 CME 以及期望和方差的定义出发，您必须：\n1. 对上述生灭过程，实现 Gillespie 直接随机模拟算法，以生成直至固定终止时间 $T$ 的轨迹 $X(t)$。\n2. 模拟 $M$ 条独立轨迹，并记录在时间 $T$ 的系综分子数 $\\{X_i(T)\\}_{i=1}^M$。\n3. 计算 $\\{X_i(T)\\}_{i=1}^M$ 的经验均值 $\\hat{m}(T)$ 和经验方差 $\\hat{v}(T)$。\n4. 从 CME 独立推导出在时间 $T$ 的一阶矩和二阶矩的解析表达式，即精确均值 $m(T)$ 和方差 $v(T)$，适用于任意非负参数 $k_b$、$k_d$、$x_0$ 和 $T$。\n5. 通过检查均值的绝对相对误差和方差的绝对相对误差是否均小于或等于一个固定的容差 $\\varepsilon$，来验证模拟结果与 CME 推导出的矩之间的一致性，即是否满足：\n$$\n\\frac{\\lvert \\hat{m}(T) - m(T) \\rvert}{\\max(m(T), 10^{-12})} \\le \\varepsilon\n\\quad \\text{and} \\quad\n\\frac{\\lvert \\hat{v}(T) - v(T) \\rvert}{\\max(v(T), 10^{-12})} \\le \\varepsilon.\n$$\n\n使用 Gillespie 直接法，采用精确的指数等待时间和基于倾向的反应通道选择。为保证可复现性，使用固定的伪随机数种子 $12345$。每个测试用例使用 $M = 6000$ 条轨迹，容差 $\\varepsilon = 0.05$。\n\n实现您的程序以处理以下参数集测试套件，涵盖典型行为和边界情况。对于每种情况，合成速率为 $k_b$ (单位 $\\mathrm{s^{-1}}$)，降解速率为 $k_d$ (单位 $\\mathrm{s^{-1}}$)，初始计数值为 $x_0$ (单位 molecules)，终止时间为 $T$ (单位秒)：\n- 情况 1 (典型)：$k_b = 5.0$, $k_d = 1.0$, $x_0 = 0$, $T = 3.0$。\n- 情况 2 (无合成)：$k_b = 0.0$, $k_d = 0.7$, $x_0 = 50$, $T = 1.5$。\n- 情况 3 (慢降解，长时间)：$k_b = 2.0$, $k_d = 0.1$, $x_0 = 0$, $T = 20.0$。\n- 情况 4 (快降解，中等合成)：$k_b = 9.0$, $k_d = 3.0$, $x_0 = 0$, $T = 1.0$。\n- 情况 5 (非零初始条件)：$k_b = 4.0$, $k_d = 0.5$, $x_0 = 20$, $T = 2.0$。\n- 情况 6 (无降解)：$k_b = 1.5$, $k_d = 0.0$, $x_0 = 3$, $T = 4.0$。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目都是一个布尔值，表示相应的情况是否通过了两个矩的容差检查，顺序与上面列出的一致（例如，“[True,False,True,True,True,False]”）。", "solution": "该问题要求从化学主方程 (CME) 推导单物种生灭过程随时间变化的均值和方差，并使用 Gillespie 直接法通过随机模拟验证这些解析结果。该问题是良定的，具有科学依据，并为完整求解提供了所有必要的参数。\n\n### 1. 从化学主方程推导精确矩\n\n该系统包含物种 $X$（拷贝数为 $n$）的两个反应：\n1.  合成（出生）：$\\emptyset \\xrightarrow{k_b} X$，倾向为 $a_1(n) = k_b$。\n2.  降解（死亡）：$X \\xrightarrow{k_d n} \\emptyset$，倾向为 $a_2(n) = k_d n$。\n\n令 $P(n,t)$ 为系统在时间 $t$ 有 $n$ 个分子的概率。控制 $P(n,t)$ 时间演化的 CME 为：\n$$\n\\frac{dP(n,t)}{dt} = k_b P(n-1,t) + k_d(n+1)P(n+1,t) - (k_b + k_d n)P(n,t)\n$$\n对于 $n \\ge 1$，对于 $n=0$ 有特殊形式：$\\frac{dP(0,t)}{dt} = k_d P(1,t) - k_b P(0,t)$。如果我们定义 $P(-1, t)=0$，则该通用形式对所有 $n \\in \\mathbb{N}_0$ 均成立。\n\n#### 1.1. 平均分子数\n\n分子数的均值（或一阶矩）定义为 $m(t) = \\langle n \\rangle(t) = \\sum_{n=0}^{\\infty} n P(n,t)$。均值的时间演化可通过对其求时间导数并使用 CME 来找到：\n$$\n\\frac{dm(t)}{dt} = \\sum_{n=0}^{\\infty} n \\frac{dP(n,t)}{dt}\n$$\n代入 CME 并逐项计算总和：\n$$\n\\frac{dm(t)}{dt} = \\sum_{n=0}^{\\infty} n \\left[ k_b P(n-1,t) + k_d(n+1)P(n+1,t) - (k_b + k_d n)P(n,t) \\right]\n$$\n$$\n\\frac{dm(t)}{dt} = k_b \\sum_{n=1}^{\\infty} n P(n-1,t) + k_d \\sum_{n=0}^{\\infty} n(n+1)P(n+1,t) - k_b \\sum_{n=0}^{\\infty} n P(n,t) - k_d \\sum_{n=0}^{\\infty} n^2 P(n,t)\n$$\n通过对求和项重新索引（例如，在第一个和式中令 $j=n-1$），我们得到：\n$$\n\\frac{dm(t)}{dt} = k_b \\sum_{j=0}^{\\infty} (j+1) P(j,t) + k_d \\sum_{j=1}^{\\infty} (j-1)j P(j,t) - k_b \\langle n \\rangle - k_d \\langle n^2 \\rangle\n$$\n$$\n\\frac{dm(t)}{dt} = k_b (\\langle n \\rangle + 1) + k_d (\\langle n^2 \\rangle - \\langle n \\rangle) - k_b \\langle n \\rangle - k_d \\langle n^2 \\rangle\n$$\n$$\n\\frac{dm(t)}{dt} = k_b \\langle n \\rangle + k_b + k_d \\langle n^2 \\rangle - k_d \\langle n \\rangle - k_b \\langle n \\rangle - k_d \\langle n^2 \\rangle\n$$\n这可简化为关于均值 $m(t)$ 的一阶线性常微分方程 (ODE)：\n$$\n\\frac{dm(t)}{dt} = k_b - k_d m(t)\n$$\n给定初始条件 $m(0) = X(0) = x_0$，我们可以解这个 ODE。\n- 如果 $k_d > 0$：解为\n  $$\n  m(t) = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) e^{-k_d t}\n  $$\n- 如果 $k_d = 0$：ODE 变为 $\\frac{dm(t)}{dt} = k_b$，积分得到\n  $$\n  m(t) = x_0 + k_b t\n  $$\n\n#### 1.2. 分子数的方差\n\n方差为 $v(t) = \\langle n^2 \\rangle - \\langle n \\rangle^2$。我们首先推导方差的 ODE。方差的时间导数为 $\\frac{dv}{dt} = \\frac{d\\langle n^2 \\rangle}{dt} - 2\\langle n \\rangle \\frac{d\\langle n \\rangle}{dt}$。\n我们需要二阶矩 $\\langle n^2 \\rangle = \\sum_{n=0}^{\\infty} n^2 P(n,t)$ 的 ODE。与均值类似，我们得到：\n$$\n\\frac{d\\langle n^2 \\rangle}{dt} = \\sum_{n=0}^{\\infty} n^2 \\frac{dP(n,t)}{dt} = (2k_b + k_d)m(t) + k_b - 2k_d \\langle n^2 \\rangle\n$$\n将此式和 $m(t)$ 的 ODE 代入 $\\frac{dv}{dt}$ 的表达式中：\n$$\n\\frac{dv}{dt} = \\left[ (2k_b + k_d)m(t) + k_b - 2k_d \\langle n^2 \\rangle \\right] - 2m(t) (k_b - k_d m(t))\n$$\n$$\n\\frac{dv}{dt} = 2k_b m(t) + k_d m(t) + k_b - 2k_d \\langle n^2 \\rangle - 2k_b m(t) + 2k_d m(t)^2\n$$\n$$\n\\frac{dv}{dt} = k_b + k_d m(t) - 2k_d (\\langle n^2 \\rangle - m(t)^2)\n$$\n这就得出了方差 $v(t)$ 的 ODE：\n$$\n\\frac{dv(t)}{dt} = k_b + k_d m(t) - 2k_d v(t)\n$$\n在初始条件 $v(0)=0$（因为初始状态 $x_0$ 是确定性的）下，我们可以通过代入 $m(t)$ 的解来解这个 ODE。\n- 如果 $k_d > 0$：\n  $$\n  \\frac{dv}{dt} + 2k_d v = k_b + k_d \\left[ \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) e^{-k_d t} \\right] = 2k_b + (k_d x_0 - k_b) e^{-k_d t}\n  $$\n  在 $v(0)=0$ 的条件下解此线性一阶 ODE 得到：\n  $$\n  v(t) = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) e^{-k_d t} - x_0 e^{-2k_d t}\n  $$\n  这可以方便地重写为：\n  $$\n  v(t) = \\frac{k_b}{k_d}(1 - e^{-k_d t}) + x_0 e^{-k_d t}(1 - e^{-k_d t})\n  $$\n- 如果 $k_d = 0$：方差的 ODE 变为 $\\frac{dv}{dt} = k_b$。在 $v(0)=0$ 的条件下，积分得到\n  $$\n  v(t) = k_b t\n  $$\n\n### 2. 随机模拟与验证\n\nGillespie 的随机模拟算法 (SSA)，特别是其直接法，被用于生成马尔可夫过程的精确数值实现。\n\n#### 2.1. 算法\n对于从 $t=0$ 时 $n=x_0$ 开始的单条轨迹，直到 $t \\ge T$：\n1.  计算倾向：$a_1 = k_b$， $a_2 = k_d n$。\n2.  计算总倾向：$a_{tot} = a_1 + a_2$。\n3.  如果 $a_{tot} = 0$，则状态是吸收态。模拟时间推进到 $T$，轨迹结束。\n4.  从均匀分布 $U(0,1)$ 中生成两个随机数 $r_1, r_2$。\n5.  计算到下一次反应的时间：$\\tau = \\frac{1}{a_{tot}} \\ln(\\frac{1}{r_1})$。\n6.  如果 $t+\\tau \\ge T$，轨迹结束；状态保持为 $n$。\n7.  否则，推进时间：$t \\leftarrow t + \\tau$。\n8.  选择反应：如果 $r_2 \\cdot a_{tot}  a_1$，则为合成反应（$n \\leftarrow n+1$）；否则为降解反应（$n \\leftarrow n-1$）。\n9.  从步骤 1 开始重复。\n\n#### 2.2. 验证\n对每个参数集，此过程重复进行 $M=6000$ 次独立轨迹的模拟，并使用固定的伪随机数生成器种子 $12345$ 以保证可复现性。收集最终的分子数系综 $\\{X_i(T)\\}_{i=1}^M$。\n\n从该系综计算经验均值 $\\hat{m}(T)$ 和经验方差 $\\hat{v}(T)$：\n$$\n\\hat{m}(T) = \\frac{1}{M}\\sum_{i=1}^{M} X_i(T) \\qquad \\hat{v}(T) = \\frac{1}{M}\\sum_{i=1}^{M} (X_i(T) - \\hat{m}(T))^2\n$$\n通过将这些经验矩与上面推导出的解析矩 $m(T)$ 和 $v(T)$ 进行比较来检查一致性。如果均值和方差的绝对相对误差都小于或等于容差 $\\varepsilon=0.05$，则检查通过：\n$$\n\\frac{\\lvert \\hat{m}(T) - m(T) \\rvert}{\\max(m(T), 10^{-12})} \\le \\varepsilon\n\\quad \\text{and} \\quad\n\\frac{\\lvert \\hat{v}(T) - v(T) \\rvert}{\\max(v(T), 10^{-12})} \\le \\varepsilon\n$$\n使用值 $10^{-12}$ 作为分母的下限，以防止除以零或接近零的值。\n\n实现将对每个测试用例应用这些步骤，生成一个布尔结果，指示一致性检查是否通过。", "answer": "```python\nimport numpy as np\n\ndef gillespie_single_trajectory(kb, kd, x0, T, rng):\n    \"\"\"\n    Simulates a single trajectory of the birth-death process using Gillespie's direct method.\n    \n    Args:\n        kb (float): Synthesis rate.\n        kd (float): Degradation rate.\n        x0 (int): Initial molecule count.\n        T (float): Terminal time.\n        rng (np.random.Generator): A numpy random number generator instance.\n        \n    Returns:\n        int: The molecule count at time T.\n    \"\"\"\n    t = 0.0\n    n = int(x0)\n    \n    while t  T:\n        a1 = kb\n        a2 = kd * n\n        a_tot = a1 + a2\n        \n        if a_tot = 1e-12:  # No more reactions can occur\n            break\n            \n        r1 = rng.random()\n        tau = -np.log(r1) / a_tot\n        \n        if t + tau >= T:\n            # Next reaction occurs after T, so state at T is the current state.\n            break\n            \n        t += tau\n        \n        r2 = rng.random()\n        \n        if r2 * a_tot  a1:\n            n += 1  # Synthesis\n        else:\n            n -= 1  # Degradation\n\n    return n\n\ndef run_simulation_ensemble(kb, kd, x0, T, M, rng):\n    \"\"\"\n    Runs an ensemble of Gillespie simulations and computes empirical moments.\n    \n    Args:\n        kb, kd, x0, T: Parameters for the simulation.\n        M (int): Number of trajectories in the ensemble.\n        rng (np.random.Generator): A numpy random number generator instance.\n        \n    Returns:\n        tuple[float, float]: The empirical mean and variance.\n    \"\"\"\n    final_counts = np.zeros(M, dtype=int)\n    for i in range(M):\n        final_counts[i] = gillespie_single_trajectory(kb, kd, x0, T, rng)\n        \n    m_hat = np.mean(final_counts)\n    v_hat = np.var(final_counts)  # ddof=0 is default, correct for empirical variance\n    return m_hat, v_hat\n\ndef calculate_analytical_moments(kb, kd, x0, T):\n    \"\"\"\n    Calculates the exact analytical mean and variance at time T.\n    \n    Args:\n        kb, kd, x0, T: Parameters for the model.\n        \n    Returns:\n        tuple[float, float]: The analytical mean and variance.\n    \"\"\"\n    if kd > 1e-12:  # General case for kd > 0\n        kb_over_kd = kb / kd\n        exp_term = np.exp(-kd * T)\n        \n        m_T = kb_over_kd + (x0 - kb_over_kd) * exp_term\n        \n        # This form is numerically stable and directly derived\n        v_T = kb_over_kd * (1 - exp_term) + x0 * exp_term * (1 - exp_term)\n    else:  # Special case for kd = 0 (Poisson process)\n        m_T = kb * T + x0\n        v_T = kb * T\n        \n    return m_T, v_T\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (kb, kd, x0, T)\n        (5.0, 1.0, 0, 3.0),\n        (0.0, 0.7, 50, 1.5),\n        (2.0, 0.1, 0, 20.0),\n        (9.0, 3.0, 0, 1.0),\n        (4.0, 0.5, 20, 2.0),\n        (1.5, 0.0, 3, 4.0),\n    ]\n    \n    M = 6000\n    epsilon = 0.05\n    seed = 12345\n    \n    results = []\n    \n    for case in test_cases:\n        kb, kd, x0, T = case\n        \n        # Calculate analytical moments\n        m_T, v_T = calculate_analytical_moments(kb, kd, x0, T)\n        \n        # Run stochastic simulation ensemble\n        # A new RNG is created for each case to ensure independent reproducibility\n        rng = np.random.default_rng(seed)\n        m_hat, v_hat = run_simulation_ensemble(kb, kd, x0, T, M, rng)\n        \n        # Verify consistency\n        err_m = np.abs(m_hat - m_T) / max(m_T, 1e-12)\n        err_v = np.abs(v_hat - v_T) / max(v_T, 1e-12)\n        \n        passes_check = (err_m = epsilon) and (err_v = epsilon)\n        results.append(passes_check)\n        \n    # Format and print the final output exactly as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "4392582"}]}