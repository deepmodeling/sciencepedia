{"hands_on_practices": [{"introduction": "在进行任何统计检验之前，正确定义“基因总体”或背景集是至关重要的一步。本练习将引导你思考一个在通路分析中常见且关键的错误来源，即如何根据不同的实验设计（例如RNA测序与靶向基因面板）选择合适的基因 universe。通过这个思想实验，你将学会如何避免因背景选择不当而导致的统计偏差，从而确保分析结果的有效性。[@problem_id:4343680]", "problem": "在一项精准肿瘤学研究中，您执行了两种不同的富集分析来解释患者肿瘤中的分子发现。在第一项分析中，使用信使RNA测序（RNA-seq）来识别肿瘤与匹配的正常组织中的差异表达基因。经过质量控制和检测筛选后，您保留了$12,000$个基因为表达基因，并以$0.05$的假发现率（FDR）识别出$300$个差异表达基因。在第二项分析中，使用一个检测已知在癌症中频繁改变的$500$个基因的临床基因包（clinical panel）进行靶向DNA测序，并通过队列水平的检验识别出$50$个显著突变基因。您希望使用费希尔精确检验（Fisher’s exact test）评估每个基因列表在分子特征数据库（The Molecular Signatures Database, MSigDB）的精选通路中的过度代表性。\n\n哪一选项最佳地定义了每项分析的适当基因全集，并正确地证明了为何需要使用表达的或检测靶向的全集，而不是基因组中的所有基因，来进行有效的过度代表性检验？\n\nA. 对两项分析都使用人类基因组中所有的蛋白质编码基因（约$19,000$个）作为全集，因为通路是全基因组范围内定义的，且更大的全集本质上更保守，能减少假阳性。\n\nB. 对于RNA测序（RNA-seq）差异表达分析，仅使用数据集中表达水平高于检测阈值的基因作为全集；对于靶向DNA基因包突变分析，仅使用检测包所覆盖的基因作为全集。这将抽样框架与可能被测量的内容对齐，保留了费希尔精确检验中隐含的无放回抽样的假设，并避免了因在背景中包含未测量或无法测量的基因而产生的反保守p值。\n\nC. 对两项分析都仅使用通路数据库中出现在任何通路里的基因作为全集，因为富集必须相对于通路注释空间进行计算，而不管检测实际测量了什么。\n\nD. 对于RNA测序（RNA-seq）分析，使用表达的基因作为全集；对于靶向DNA基因包突变分析，仍然使用所有的蛋白质编码基因作为全集，以避免因基因包内容相对于基因组的非均匀性而引入的偏差。\n\nE. 为每个通路定义一个单独的基因全集，仅包含注释到该通路的基因，因为这能直接控制通路大小并通过将检验集中于相关成员来增加统计功效。", "solution": "用户要求对问题陈述进行批判性验证，然后提供一个详细的解决方案，推导出正确答案并评估所有选项。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n-   **分析1 (RNA-seq)：**\n    -   筛选后表达的基因总数：$12,000$。\n    -   差异表达基因 (DEGs)：$300$。\n    -   差异表达基因的假发现率 (FDR)：$0.05$。\n-   **分析2 (靶向DNA测序)：**\n    -   临床基因包检测的基因总数：$500$。\n    -   显著突变基因：$50$。\n-   **方法论：**\n    -   评估差异表达基因列表和突变基因列表在精选通路中的过度代表性。\n    -   通路数据库：分子特征数据库 (MSigDB)。\n    -   统计检验：费希尔精确检验。\n-   **问题：**\n    -   为这两项分析中的每一项定义合适的基因全集。\n    -   为选择全集提供正确的理由，特别是为什么它不应该是基因组中的所有基因。\n\n**步骤2：使用提取的已知条件进行验证**\n-   **科学合理性：** 问题陈述在科学上是合理的。它描述了分子肿瘤学中的一个标准生物信息学工作流程，包括用于表达分析的RNA-seq，用于突变分析的靶向测序，以及使用费希尔精确检验和信誉良好的数据库 (MSigDB) 进行的过度代表性分析 (ORA)。所提供的数字对于此类实验是现实的。\n-   **问题定义明确：** 问题定义明确。它要求正确定义“基因全集”或“背景集”，这是富集分析的一个关键参数。问题是具体的，并且可以根据所选检验的统计学原理确定一个最佳答案。\n-   **客观性：** 语言是技术性的、精确的和客观的，没有主观或含糊的术语。\n-   **完整性与一致性：** 提供的信息足以确定正确的统计方法。没有内部矛盾。\n-   **现实性与可行性：** 该情景高度真实地代表了精准医学和基因组学研究中的数据分析。\n-   **问题定义不清或结构不良：** 问题结构良好。“基因全集”的核心概念是要解决的关键点，这是该主题的一个标准且不平凡的方面。\n-   **琐碎性：** 这个问题并不琐碎；选择合适的背景/全集是生物信息学中一个常见的错误来源，它对结果有重大影响，理解其基本原理对于有效的推断至关重要。\n\n**步骤3：结论与行动**\n问题陈述是**有效的**。该情景在科学上是合理的，问题定义明确，并包含了进行解答所需的所有必要信息。\n\n**解答推导**\n\n问题的核心在于正确应用费希尔精确检验进行过度代表性分析 (ORA)。该检验评估两组基因——一组是“感兴趣的”基因列表，另一组是预定义的“通路”基因集——交集中的基因数量是否大于随机机会下的预期数量。\n\nORA背后的统计模型是无放回抽样，由超几何分布描述。想象一个瓮，其中包含了明确定义的“全集”中的所有基因。当抽取固定数量的项目（“感兴趣的”基因）时，费希尔精确检验计算出抽到特定数量的“特殊”项目（通路中的基因）的概率。\n\n该检验基于一个 $2 \\times 2$ 列联表：\n\n| | 在通路中 | 不在通路中 | 总计 |\n| :--- | :--- | :--- | :--- |\n| **感兴趣的** | $a$ | $b$ | $k=a+b$ |\n| **不感兴趣的** | $c$ | $d$ | $ N-k$ |\n| **总计** | $m=a+c$ | $N-m$ | $N$ |\n\n这里：\n-   $N$ 是**全集**中的基因总数。\n-   $k$ 是“感兴趣的”基因（例如，差异表达基因或突变基因）的总数。\n-   $m$ 是通路中也存在于全集内的基因总数。\n-   $a$ 是既是感兴趣的基因又在通路中的基因数量。\n\n通过机会观察到恰好 $a$ 个重叠的概率由超几何概率公式给出：\n$$ P(\\text{observing } a) = \\frac{\\binom{m}{a}\\binom{N-m}{k-a}}{\\binom{N}{k}} $$\n然后，通过将与观察到的结果一样极端或更极端的结果的概率相加来计算p值。\n\n关键参数是 $N$，即全集。**该检验的一个基本假设是，包含在全集 $N$ 中的每个基因都必须具有非零的，且理想情况下相等的*先验*概率被选入“感兴趣的”基因列表。** 如果一个基因在实验中无法被检测或测量，它就不可能被包含在感兴趣的基因列表中。将这种无法测量的基因包含在全集 $N$ 中违反了抽样假设。\n\n这种违背会导致统计偏差。当你用永远不会被选中的基因来扩充全集 $N$ 时，你是在与一个人为稀释的背景进行检验。预期的重叠数是 $E[a] = k \\times (m/N)$。通过人为地增加 $N$（以及在较小程度上增加 $m$），全集中通路基因的比例 $(m/N)$ 会减少，从而降低预期的重叠数 $E[a]$。因此，观察到的重叠数 $a$ 相对于这个被人为降低的期望值会显得大得多，从而导致人为地得出较小的p值。这是一种**反保守偏差**，会增加假阳性率。\n\n将此原则应用于两项分析：\n1.  **RNA-seq 分析：** 感兴趣的基因列表是$300$个差异表达基因。一个基因只有在其表达首先被可靠地检测到时，才能被宣布为“差异表达”。问题陈述中提到，经过质量控制和筛选后，有$12,000$个基因被保留为“表达”的。这些是唯一有机会进入差异表达基因列表的基因。因此，此分析的正确全集 $N$ 是这 $12,000$ 个表达基因的集合。\n\n2.  **靶向DNA基因包分析：** 感兴趣的基因列表是$50$个显著突变基因。一个基因只有在它被包含在用于检测的测序包上时，才可能被发现“突变”。问题陈述中提到该基因包检测了$500$个基因。只有这$500$个基因有任何机会出现在最终列表中。因此，此分析的正确全集 $N$ 是该基因包所覆盖的 $500$ 个基因的集合。\n\n**逐项选项分析**\n\n**A. 对两项分析都使用人类基因组中所有的蛋白质编码基因（约$19,000$个）作为全集，因为通路是全基因组范围内定义的，且更大的全集本质上更保守，能减少假阳性。**\n-   这种方法根本上是错误的。对于RNA-seq分析，它包含了数千个未表达因此不可能被识别为差异表达的基因。对于DNA基因包分析，它包含了超过$18,500$个未被检测因此不可能被识别为突变的基因。这违反了统计检验的核心假设。\n-   其理由是不正确的。如上所述，使用一个不恰当的大全集会导致反保守偏差，这会*增加*假阳性，而不是更保守。\n-   **结论：不正确。**\n\n**B. 对于RNA测序（RNA-seq）差异表达分析，仅使用数据集中表达水平高于检测阈值的基因作为全集；对于靶向DNA基因包突变分析，仅使用检测包所覆盖的基因作为全集。这将抽样框架与可能被测量的内容对齐，保留了费希尔精确检验中隐含的无放回抽样的假设，并避免了因在背景中包含未测量或无法测量的基因而产生的反保守p值。**\n-   此选项根据底层的实验设计正确地识别了每项分析的适当全集：对于RNA-seq是$12,000$个表达基因，对于DNA-seq是$500$个基因包基因。\n-   其理由是精确且在统计上正确的。它正确地指出，全集必须限制在可能被测量的范围内，这样做保留了检验的抽样假设，并且不这样做会引入反保守偏差（增加假阳性）。\n-   **结论：正确。**\n\n**C. 对两项分析都仅使用通路数据库中出现在任何通路里的基因作为全集，因为富集必须相对于通路注释空间进行计算，而不管检测实际测量了什么。**\n-   这是不正确的。虽然未注释到任何通路的基因无法对显著性结果做出贡献，但背景仍必须由实验来定义，而不是由注释数据库来定义。一个基因可能在一个通路中，但在感兴趣的组织中不表达（因此无法通过RNA-seq测量），或者未被包含在靶向基因包中。这样的基因没有机会进入“感兴趣的”列表，必须从全集中排除。这种方法将实验样本空间与注释空间混为一谈。\n-   **结论：不正确。**\n\n**D. 对于RNA测序（RNA-seq）分析，使用表达的基因作为全集；对于靶向DNA基因包突变分析，仍然使用所有的蛋白质编码基因作为全集，以避免因基因包内容相对于基因组的非均匀性而引入的偏差。**\n-   此选项为RNA-seq分析正确定义了全集，但对于DNA基因包分析则失败了。靶向基因包的“偏差”是实验设计的明确特征。统计问题必须以该设计为条件，即“在我们检测的基因中，突变的基因是否富集于某个给定的通路？” 试图通过使用整个基因组作为背景来“纠正”基因包的设计，是在问一个不同的、统计上无效的问题，并且如选项A所述，这会引入反保守偏差。\n-   **结论：不正确。**\n\n**E. 为每个通路定义一个单独的基因全集，仅包含注释到该通路的基因，因为这能直接控制通路大小并通过将检验集中于相关成员来增加统计功效。**\n-   这个逻辑是循环的，使检验变得毫无意义。如果全集（$N$）被定义为被检验通路中的基因集（$m$），那么 $N=m$。列联表将变得琐碎，因为没有“不在通路中”的基因。所有在全集中找到的感兴趣的基因，根据定义，都将在该通路中。该检验将不再是将感兴趣列表中通路成员的频率与它们在背景群体中的频率进行比较，从而失去所有意义。\n-   **结论：不正确。**", "answer": "$$\\boxed{B}$$", "id": "4343680"}, {"introduction": "掌握了通路分析的基本概念后，下一步是将其付诸实践。本练习要求你从零开始，仅使用基本统计学定义，实现两种应用最广泛的通路分析算法：富集分析（ORA）和基因集富集分析（GSEA）。通过亲手编写代码，你将深刻理解这些方法背后的数学原理，包括超几何检验、多重检验校正以及加权富集分数的计算，这对于未来进行严谨的生物信息学分析至关重要。[@problem_id:4373311]", "problem": "开发一个完整的、可运行的程序，该程序仅使用第一性原理和经过充分检验的统计定义，实现两种在系统生物医学中广泛使用的基础通路分析流程，其灵感来源于 R/Bioconductor 生态系统中的实用工具。目标是针对一个排序的基因列表和一个显著基因集（两者均定义在一个固定的基因全集上），来分析经整理的通路基因集。对于每个提供的测试用例，您的程序必须计算两个量：(i) 对所有提供的通路进行单边过表达分析，得出最小的 Benjamini–Hochberg 校正 p 值；(ii) 通过加权移动总和富集分析（其精确零假设通过枚举获得）计算出的这些通路中的最大绝对归一化富集分数。所有计算必须是完全确定性的，无需用户输入。\n\n从以下基本原理开始。\n\n1) 经整理的通路作为基因集。一个通路表示为一组经整理的基因，来源如京都基因与基因组百科全书 (Kyoto Encyclopedia of Genes and Genomes, KEGG) 或 Reactome。在算法上，每个通路都是一个大小为 $N$ 的固定基因全集中的一个有限子集。\n\n2) 过表达分析作为无放回抽样。考虑一个大小为 $N$ 的固定基因全集，其中有 $K$ 个基因被标记为“显著”。对于一个大小为 $n$ 的特定通路，假设其中有 $k$ 个基因是显著的。在显著性与通路成员身份无关的零假设下，通路中观察到的显著基因数量遵循超几何分布。单边过表达 p 值是观察到至少 $k$ 个显著基因的概率：\n$$\np_{\\mathrm{ORA}} \\;=\\; \\sum_{j=k}^{\\min(n,K)} \\frac{\\binom{K}{j}\\,\\binom{N-K}{n-j}}{\\binom{N}{n}} \\, .\n$$\n对于 $m$ 个通路，Benjamini–Hochberg 多重检验校正将 p 值 $\\{p_{(1)} \\le \\dots \\le p_{(m)}\\}$ 映射为校正值 $q_{(i)} = \\min_{t \\ge i} \\left( \\frac{m}{t} \\, p_{(t)} \\right)$，然后将这些值恢复到原始顺序，得到 $\\{q_1,\\dots,q_m\\}$。\n\n3) 对排序列表进行加权移动总和基因集富集分析。设全集中的基因按实值分数向量 $r = (r_1,\\dots,r_N)$ 降序排列。对于一个大小为 $N_h = |S|$ 的通路 $S$，定义权重 $w_i = |r_i|^p$，其中指数 $p \\ge 0$。移动总和过程从 $i=1$ 到 $i=N$ 扫描排序列表，并按如下方式更新累积和：\n- 当基因 $i$ 属于 $S$ 时，增加 $w_i / \\mathrm{NR}$，其中 $\\mathrm{NR} = \\sum_{i \\in S} w_i$。\n- 当基因 $i$ 不属于 $S$ 时，减少 $1/(N-N_h)$。\n约定如果 $N_h \\in \\{0,N\\}$，则富集分数为 $0$。\n设移动累积和为 $\\mathrm{RS}_i$。富集分数 $\\mathrm{ES}(S)$ 是 $\\mathrm{RS}_i$ 的最大值和最小值中绝对值更极端的那一个，其符号由更极端偏差的方向决定。为了进行归一化，通过枚举将 $N_h$ 个“命中”位置置于 $N$ 个排序位置中的所有 $\\binom{N}{N_h}$ 种方式来定义精确零假设，在保持 $w_i$ 固定的情况下计算这些 배치下的相应富集分数，并设 $\\mu_+ = \\mathbb{E}[\\mathrm{ES} \\mid \\mathrm{ES}>0]$ 和 $\\mu_- = \\mathbb{E}[-\\mathrm{ES} \\mid \\mathrm{ES} < 0]$。对于一个观测到 $\\mathrm{ES}$ 的通路，其归一化富集分数为：\n$$\n\\mathrm{NES}(S) \\;=\\;\n\\begin{cases}\n\\mathrm{ES}/\\mu_+  &\\text{if } \\mathrm{ES} > 0 \\text{ and } \\mu_+ > 0,\\\\\n-\\mathrm{ES}/\\mu_-  &\\text{if } \\mathrm{ES} < 0 \\text{ and } \\mu_- > 0,\\\\\n0  &\\text{if } N_h \\in \\{0,N\\} \\text{ or the relevant mean is } 0 \\, .\n\\end{cases}\n$$\n在每个测试用例中，报告所有提供通路中的最大绝对归一化富集分数。\n\n您的程序必须根据这些定义来实现上述功能，无需任何用户输入或外部文件，并且必须确定性地执行。\n\n使用以下测试套件。在所有情况下，基因全集为 $\\{1,2,\\dots,N\\}$，排序是根据提供的分数 $r$ 的降序排列，权重指数为 $p=1$。\n\n- 测试用例 1：\n  - 全集大小 $N = 12$。\n  - 排序分数 $r = [2.5, 1.8, 1.2, 0.9, 0.4, -0.2, -0.5, -1.0, -1.3, -1.7, -2.0, -2.6]$。\n  - 显著基因 $G_{\\mathrm{sig}} = \\{1,2,3,8,11,12\\}$，所以 $K = 6$。\n  - 通路（经整理的集合）：$S_1 = \\{1,4,6,8\\}$，$S_2 = \\{2,3,5,7,9\\}$，$S_3 = \\{10,11,12\\}$。\n\n- 测试用例 2：\n  - 全集大小 $N = 10$。\n  - 排序分数 $r = [3.0, 2.2, 1.5, 0.8, 0.1, -0.3, -0.9, -1.4, -2.1, -2.8]$。\n  - 显著基因 $G_{\\mathrm{sig}} = \\{1,2,3,9\\}$，所以 $K = 4$。\n  - 通路：$S_1 = \\{4,5,6\\}$，$S_2 = \\{1,2,3,9\\}$，$S_3 = \\{7\\}$。\n\n- 测试用例 3：\n  - 全集大小 $N = 8$。\n  - 排序分数 $r = [1.2, 0.7, 0.3, -0.1, -0.4, -0.8, -1.1, -1.5]$。\n  - 显著基因 $G_{\\mathrm{sig}} = \\varnothing$，所以 $K = 0$。\n  - 通路：$S_1 = \\{1,2,3\\}$，$S_2 = \\{4,5,6,7,8\\}$，$S_3 = \\{1,2,3,4,5,6,7,8\\}$。\n\n对于每个测试用例，计算：\n- 通过上述过表达分析，在所列通路中得到的最小 Benjamini–Hochberg 校正 p 值，以浮点数形式表示并四舍五入到 $6$ 位小数。\n- 通过使用精确零假设枚举的加权移动总和分析，在所列通路中得到的最大绝对归一化富集分数，以浮点数形式表示并四舍五入到 $6$ 位小数。\n\n最终输出格式。您的程序应生成一行输出，其中包含三个测试用例结果的逗号分隔列表，每个结果本身是按上述顺序排列的双元素列表。具体来说，输出必须是形如\n$[[a_1,b_1],[a_2,b_2],[a_3,b_3]]$\n的一行，其中每个 $a_i$ 和 $b_i$ 都是四舍五入到恰好 $6$ 位小数的浮点数。", "solution": "该问题要求实现两种不同的生物信息学通路分析算法：一种是带有 Benjamini-Hochberg (BH) 校正的单边过表达分析 (ORA)，另一种是带有精确零分布归一化的加权移动总和基因集富集分析 (GSEA)。该解决方案被划分为多个函数，这些函数直接实现了所提供的统计和算法定义。\n\n**1. 过表达分析 (ORA)**\n\nORA 组件用于量化一个通路是否富集了“显著”基因。其统计基础是超几何分布，该分布模拟了无放回抽样。\n\n**1.1. 超几何 p 值**\n\nORA 的核心是计算在一个包含 $K$ 个显著基因、总数为 $N$ 的基因全集中，从一个大小为 $n$ 的通路中观察到至少 $k$ 个显著基因的概率。这个单边 p 值由超几何分布的生存函数给出：\n$$\np_{\\mathrm{ORA}} \\;=\\; P(X \\ge k) \\;=\\; \\sum_{j=k}^{\\min(n,K)} \\frac{\\binom{K}{j}\\,\\binom{N-K}{n-j}}{\\binom{N}{n}}\n$$\n该公式的实现首先是定义一个计算二项式系数 $\\binom{n}{k}$ 的函数，我们可以利用 `scipy.special.comb`。函数 `calculate_hypergeometric_p_value(k, n, K, N)` 从 $j=k$ 迭代到 $\\min(n, K)$，对每个结果的概率求和。分子是两个二项式系数 `comb(K, j)` 和 `comb(N-K, n-j)` 的乘积，分母是 `comb(N, n)`。诸如 $k=0$ 这样的特殊情况会导致 $p_{\\mathrm{ORA}}=1$，这已明确处理。\n\n**1.2. Benjamini-Hochberg (BH) 多重检验校正**\n\n当检验多个通路时，必须对得到的 p 值进行校正以控制假发现率。Benjamini-Hochberg 流程的实现如下：\n1. 设 $m$ 个通路的初始 p 值为 $\\{p_1, p_2, \\dots, p_m\\}$。\n2. 将 p 值按升序排序：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。保留原始索引以便稍后恢复顺序。\n3. 为每个排序后的 p 值计算原始校正 p 值，我们称之为 $q'_{\\text{raw}}$：$q'_{(i)} = \\frac{m}{i} p_{(i)}$，其中 $i$ 是从 $1$ 到 $m$ 的秩。\n4. 为确保校正后的 p 值随原始排序的 p 值单调递增，采用累积最小值。秩为 $i$ 的最终校正 p 值 $q_{(i)}$ 定义为规则 $q_{(i)} = \\min_{t \\ge i} \\left( \\frac{m}{t} p_{(t)} \\right)$。这可以通过从秩 $m$ 开始向后迭代来高效计算：\n    $$\n    q_{(m)} = p_{(m)} \\\\\n    q_{(i)} = \\min\\left(q_{(i+1)}, \\frac{m}{i} p_{(i)}\\right) \\quad \\text{for } i = m-1, m-2, \\dots, 1\n    $$\n5. 计算出的已排序 q 值 $\\{q_{(1)}, \\dots, q_{(m)}\\}$ 随后被重新排序以匹配通路的原始输入顺序。\n该问题 ORA 部分的最终结果是这些校正 p 值 $\\{q_1, \\dots, q_m\\}$ 中的最小值。\n\n**2. 加权移动总和基因集富集分析 (GSEA)**\n\n这个类似 GSEA 的流程评估一个通路的基因是否集中在一个预先排序的所有基因列表的顶部或底部。\n\n**2.1. 富集分数 (ES) 的计算**\n\n对于一个给定的大小为 $N_h$ 的通路 $S$，算法流程如下：\n1. 全集中的基因根据提供的降序分数 $r_i$ 从 $1$ 到 $N$ 排序。\n2. 为每个基因分配一个权重 $w_i = |r_i|^p$，在本问题中 $p=1$。\n3. 初始化一个移动总和 $\\mathrm{RS}$ 为 $0$。算法从 $i=1$ 到 $N$ 遍历已排序的基因列表。\n4. 在每一步 $i$，更新移动总和：\n    - 如果基因 $i$ 在通路 $S$ 中（“命中”），总和增加：$\\mathrm{RS}_i = \\mathrm{RS}_{i-1} + \\frac{w_i}{\\mathrm{NR}}$，其中 $\\mathrm{NR} = \\sum_{j \\in S} w_j$ 是通路中所有基因的权重之和。\n    - 如果基因 $i$ 不在通路 $S$ 中（“未命中”），总和减少：$\\mathrm{RS}_i = \\mathrm{RS}_{i-1} - \\frac{1}{N-N_h}$。\n5. 富集分数 $\\mathrm{ES}(S)$ 是移动总和与 $0$ 的最大偏差。它被定义为所有 $\\mathrm{RS}_i$ 中绝对值最大的那个值，并保留其原始符号。这可以通过计算 $\\max_i(\\mathrm{RS}_i)$ 和 $\\min_i(\\mathrm{RS}_i)$ 并选择绝对值较大的那个来找到。\n6. 根据定义，如果通路为空 ($N_h=0$) 或包含所有基因 ($N_h=N$)，富集分数为 $0$。\n\n**2.2. 通过精确零分布进行归一化**\n\n为了使分数在不同通路和数据集之间具有可比性，观测到的 $\\mathrm{ES}$ 需要被归一化。\n1. 通过计算大小为 $N_h$ 的每一种可能通路对应的 $\\mathrm{ES}$，生成一个富集分数的精确零分布。共有 $\\binom{N}{N_h}$ 种这样的通路。这通过从 $N$ 个基因的全集中生成所有 $N_h$ 个基因的组合来实现。\n2. 对于每个“零”通路，使用上述相同的移动总和方法计算一个 $\\mathrm{ES}_{\\text{null}}$，同时保持基因权重 $w_i$ 固定。\n3. 从得到的所有 $\\mathrm{ES}_{\\text{null}}$ 值集合中，分离正分数和负分数以计算两个归一化因子：\n    - $\\mu_+ = \\mathbb{E}[\\mathrm{ES} \\mid \\mathrm{ES}>0]$：零分布中所有正富集分数的均值。\n    - $\\mu_- = \\mathbb{E}[-\\mathrm{ES} \\mid \\mathrm{ES}<0]$：零分布中所有负富集分数绝对值的均值。\n4. 然后计算观测通路 $S$ 的归一化富集分数 $\\mathrm{NES}(S)$：\n    $$\n    \\mathrm{NES}(S) \\;=\\;\n    \\begin{cases}\n    \\mathrm{ES}(S)/\\mu_+  &\\text{if } \\mathrm{ES}(S) > 0 \\text{ and } \\mu_+ > 0,\\\\\n    -\\mathrm{ES}(S)/\\mu_-  &\\text{if } \\mathrm{ES}(S) < 0 \\text{ and } \\mu_- > 0,\\\\\n    0  &\\text{otherwise.}\n    \\end{cases}\n    $$\n    第二种情况下的负号确保了对于正富集和负富集，NES 都是正值。该问题 GSEA 部分的最终结果是单个测试用例中所有通路的最大绝对 NES 值。\n\n**3. 程序结构与执行**\n\n整个程序被设计为独立处理每个测试用case。\n1. 测试用例被定义在一个列表中，每个条目包含全集大小 $N$、排序分数 $r$、显著基因集 $G_{\\mathrm{sig}}$ 和通路列表。\n2. 对于每个测试用例，程序首先计算最小的 BH 校正 p 值。它为每个通路计算原始 p 值，然后对整套 p 值应用 BH 校正。\n3. 接下来，它计算最大绝对 NES。为优化 GSEA 计算，归一化因子 $\\mu_+$ 和 $\\mu_-$ 被缓存。由于这些因子仅取决于全集大小 $N$、通路大小 $N_h$ 和排序列表权重，因此在一个给定的测试用例中，它们对每个唯一的通路大小只计算一次。\n4. 最后，每个测试用例所需的两个值——最小校正 p 值和最大绝对 NES——被四舍五入到 $6$ 位小数，并格式化为指定的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\nfrom itertools import combinations\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the pathway analysis problem for a suite of test cases.\n    It implements Over-Representation Analysis (ORA) with Benjamini-Hochberg\n    correction and a weighted Gene Set Enrichment Analysis (GSEA) with an\n    exact null distribution, as per the problem definitions.\n    \"\"\"\n\n    # --- ORA Helper Functions ---\n\n    def calculate_hypergeometric_p_value(k, n, K, N):\n        \"\"\"\n        Computes the one-sided ORA p-value using the hypergeometric distribution.\n        p_ORA = P(X >= k) = sum_{j=k to min(n,K)} [C(K,j)*C(N-K,n-j)] / C(N,n)\n        \n        Args:\n            k (int): Number of significant genes in the pathway.\n            n (int): Size of the pathway.\n            K (int): Total number of significant genes in the universe.\n            N (int): Size of the gene universe.\n\n        Returns:\n            float: The hypergeometric p-value.\n        \"\"\"\n        if k  0 or n  k or K  k or N  n or N  K:\n            # Invalid parameters are not expected but good to handle.\n            return 1.0\n\n        # P(X=k) is 1 if k=0\n        if k == 0:\n            return 1.0\n        \n        try:\n            total_combinations = comb(N, n, exact=True)\n            if total_combinations == 0:\n                return 1.0\n        except ValueError: # Occurs if comb returns a non-integer float\n             total_combinations = comb(N, n, exact=False)\n\n        p_sum = 0.0\n        for j in range(k, min(n, K) + 1):\n            try:\n                term = comb(K, j, exact=True) * comb(N - K, n - j, exact=True)\n                p_sum += term\n            except (ValueError, TypeError): # Handle non-integer results if numbers are large\n                term = comb(K, j, exact=False) * comb(N - K, n - j, exact=False)\n                p_sum += term\n                \n        return p_sum / float(total_combinations)\n\n    def benjamini_hochberg(p_values):\n        \"\"\"\n        Applies the Benjamini-Hochberg (BH) multiple testing correction.\n\n        Args:\n            p_values (list[float]): A list of raw p-values.\n\n        Returns:\n            list[float]: A list of BH-adjusted p-values in the original order.\n        \"\"\"\n        m = len(p_values)\n        if m == 0:\n            return []\n        \n        p_values_np = np.array(p_values)\n        sorted_indices = np.argsort(p_values_np)\n        sorted_p_values = p_values_np[sorted_indices]\n        \n        q_values_sorted = np.zeros(m)\n        q_values_sorted[m-1] = sorted_p_values[m-1]\n        for i in range(m - 2, -1, -1):\n            rank = i + 1\n            correction = m / rank\n            q_values_sorted[i] = min(q_values_sorted[i+1], sorted_p_values[i] * correction)\n\n        q_values = np.zeros(m)\n        q_values[sorted_indices] = q_values_sorted\n        \n        return q_values.tolist()\n\n    # --- GSEA Helper Functions ---\n    \n    def calculate_es(pathway, weights, N):\n        \"\"\"\n        Calculates the Enrichment Score (ES) for a a single pathway.\n\n        Args:\n            pathway (set or list): The set of gene indices in the pathway.\n            weights (list[float]): The weights for all genes in the universe.\n            N (int): The size of the gene universe.\n\n        Returns:\n            float: The raw Enrichment Score.\n        \"\"\"\n        pathway_set = set(pathway)\n        N_h = len(pathway_set)\n        \n        if N_h == 0 or N_h == N:\n            return 0.0\n\n        # Calculate NR, sum of weights for genes in the pathway\n        NR_list = [weights[i-1] for i in pathway_set]\n        NR = sum(NR_list)\n\n        # If all weights in pathway are 0, NR is 0, increments are 0; ES should be -1.\n        # But problem states mu+  0 etc, which will fail. Let's rely on problem data not having this.\n        # For given data, all r_i != 0, so w_i  0, NR  0.\n        if NR == 0.0:\n            return -1.0 # The running sum will only decrease.\n\n        miss_penalty = 1.0 / (N - N_h)\n        \n        rs = 0.0\n        max_rs = -np.inf\n        min_rs = np.inf\n\n        for i in range(1, N + 1):\n            if i in pathway_set:\n                rs += weights[i-1] / NR\n            else:\n                rs -= miss_penalty\n            \n            if rs > max_rs:\n                max_rs = rs\n            if rs  min_rs:\n                min_rs = rs\n        \n        # Return the deviation with the larger absolute value\n        if max_rs > -min_rs:\n            return max_rs\n        else:\n            return min_rs\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 12, \"r\": [2.5, 1.8, 1.2, 0.9, 0.4, -0.2, -0.5, -1.0, -1.3, -1.7, -2.0, -2.6],\n            \"G_sig\": {1, 2, 3, 8, 11, 12},\n            \"pathways\": [{1, 4, 6, 8}, {2, 3, 5, 7, 9}, {10, 11, 12}],\n            \"p_exp\": 1\n        },\n        {\n            \"N\": 10, \"r\": [3.0, 2.2, 1.5, 0.8, 0.1, -0.3, -0.9, -1.4, -2.1, -2.8],\n            \"G_sig\": {1, 2, 3, 9},\n            \"pathways\": [{4, 5, 6}, {1, 2, 3, 9}, {7}],\n            \"p_exp\": 1\n        },\n        {\n            \"N\": 8, \"r\": [1.2, 0.7, 0.3, -0.1, -0.4, -0.8, -1.1, -1.5],\n            \"G_sig\": set(),\n            \"pathways\": [{1, 2, 3}, {4, 5, 6, 7, 8}, {1, 2, 3, 4, 5, 6, 7, 8}],\n            \"p_exp\": 1\n        }\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        r = case[\"r\"]\n        G_sig = case[\"G_sig\"]\n        pathways = case[\"pathways\"]\n        p_exp = case[\"p_exp\"]\n        K = len(G_sig)\n        \n        # --- Part 1: ORA Calculation ---\n        ora_p_values = []\n        for S in pathways:\n            n = len(S)\n            k = len(S.intersection(G_sig))\n            p_val = calculate_hypergeometric_p_value(k, n, K, N)\n            ora_p_values.append(p_val)\n        \n        q_values = benjamini_hochberg(ora_p_values)\n        min_q_value = min(q_values) if q_values else 0.0\n        \n        # --- Part 2: GSEA Calculation ---\n        all_nes_values = []\n        gsea_norm_cache = {} \n        weights = [abs(score)**p_exp for score in r]\n        gene_indices = range(1, N + 1)\n        \n        for S in pathways:\n            N_h = len(S)\n            \n            if N_h == 0 or N_h == N:\n                nes = 0.0\n            else:\n                if N_h not in gsea_norm_cache:\n                    # Calculate null distribution for this N_h and cache it\n                    positive_es_sum, negative_es_sum = 0.0, 0.0\n                    n_pos, n_neg = 0, 0\n                    \n                    for null_pathway in combinations(gene_indices, N_h):\n                        es_null = calculate_es(null_pathway, weights, N)\n                        if es_null > 0:\n                            positive_es_sum += es_null\n                            n_pos += 1\n                        elif es_null  0:\n                            negative_es_sum += es_null\n                            n_neg += 1\n                            \n                    mu_plus = positive_es_sum / n_pos if n_pos > 0 else 0.0\n                    mu_minus = -negative_es_sum / n_neg if n_neg > 0 else 0.0\n                    gsea_norm_cache[N_h] = (mu_plus, mu_minus)\n                \n                mu_plus, mu_minus = gsea_norm_cache[N_h]\n                observed_es = calculate_es(S, weights, N)\n                \n                if observed_es > 0 and mu_plus > 0:\n                    nes = observed_es / mu_plus\n                elif observed_es  0 and mu_minus > 0:\n                    nes = -observed_es / mu_minus\n                else:\n                    nes = 0.0\n            \n            all_nes_values.append(nes)\n            \n        max_abs_nes = max([abs(nes) for nes in all_nes_values]) if all_nes_values else 0.0\n        \n        final_results.append([min_q_value, max_abs_nes])\n    \n    # Format the final output as specified\n    formatted_case_results = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in final_results]\n    print(f\"[{','.join(formatted_case_results)}]\")\n\nsolve()\n```", "id": "4373311"}, {"introduction": "通路分析的统计显著性是通过与一个“零假设”模型进行比较来评估的。本练习将带你深入探索置换检验的统计学核心，通过编程实践来区分两种关键的零模型：“竞争性”模型和“自包含”模型。通过对比这两种策略，你将清晰地理解它们分别对应何种生物学问题，以及如何根据研究目标选择最合适的统计检验方法。[@problem_id:4373301]", "problem": "给定一个小型精选通路数据库和一个包含两个表型组的合成基因表达研究。目标是使用置换策略实现两种用于通路富集评估的零假设模型，并为一个已定义的通路水平统计量计算蒙特卡洛 $p$ 值。您的程序必须实现竞争性零假设模型（抽样随机基因集）和自包含零假设模型（置换样本标签），然后评估特定的测试用例。\n\n基本原理：\n- 零假设框架断言，在零假设下，检验统计量的分布对于保持零假设结构（可交换性）的变换是不变的。在置换检验中，这种不变性允许通过重抽样对零分布进行经验估计。\n- 对于具有连续测量值的两个独立组，使用合并方差的非配对双样本 $t$ 统计量为每个基因提供了一个标准化的效应大小。\n\n定义和数据：\n- 基因全集 $\\mathcal{U}$，大小为 $|\\mathcal{U}| = 10$: $\\{\\text{G1}, \\text{G2}, \\text{G3}, \\text{G4}, \\text{G5}, \\text{G6}, \\text{G7}, \\text{G8}, \\text{G9}, \\text{G10}\\}$。\n- 精选通路（每个都是 $\\mathcal{U}$ 的子集）：\n  - 通路 $\\text{P1} = \\{\\text{G1}, \\text{G2}, \\text{G3}, \\text{G4}\\}$。\n  - 通路 $\\text{P2} = \\{\\text{G3}, \\text{G5}, \\text{G7}, \\text{G9}\\}$。\n  - 通路 $\\text{P3} = \\{\\text{G10}\\}$。\n- 表达矩阵 $X \\in \\mathbb{R}^{10 \\times 8}$，其中基因按上述顺序列出，所有基因的样本顺序一致。共有 $8$ 个样本：前 $4$ 个是 A 组（对照组），后 $4$ 个是 B 组（病例组）。对于基因 $\\text{Gi}$，行 $X_{i,\\cdot}$（跨越 $8$ 个样本的值）规定如下：\n  - $\\text{G1}$: $[5.0, 5.2, 4.8, 5.1, 6.8, 7.1, 7.0, 6.9]$。\n  - $\\text{G2}$: $[3.0, 3.1, 3.2, 2.9, 4.0, 4.1, 3.9, 4.2]$。\n  - $\\text{G3}$: $[8.0, 7.9, 8.1, 8.2, 6.8, 6.9, 7.0, 6.7]$。\n  - $\\text{G4}$: $[10.0, 9.8, 10.1, 10.2, 8.9, 9.1, 9.0, 9.2]$。\n  - $\\text{G5}$: $[2.0, 2.1, 2.0, 1.9, 2.0, 2.1, 2.2, 2.1]$。\n  - $\\text{G6}$: $[5.0, 5.0, 5.1, 4.9, 5.0, 5.0, 4.9, 5.1]$。\n  - $\\text{G7}$: $[7.0, 7.1, 6.9, 7.0, 7.2, 7.0, 7.1, 7.1]$。\n  - $\\text{G8}$: $[3.0, 3.1, 2.9, 3.0, 3.0, 3.1, 3.0, 2.9]$。\n  - $\\text{G9}$: $[6.0, 6.1, 5.9, 6.2, 6.0, 6.1, 6.2, 5.8]$。\n  - $\\text{G10}$: $[4.0, 4.2, 4.1, 4.0, 5.0, 5.2, 5.1, 5.1]$。\n- 组标签向量 $y \\in \\{0,1\\}^{8}$ 为 $[0, 0, 0, 0, 1, 1, 1, 1]$。\n\n基因水平统计量：\n- 对于每个基因 $g$，设 A 组的索引为 $\\mathcal{I}_0$，有 $n_0 = 4$ 个样本；B 组的索引为 $\\mathcal{I}_1$，有 $n_1 = 4$ 个样本。\n- 设 $\\bar{x}_{g0}$ 和 $\\bar{x}_{g1}$ 分别为 A 组和 B 组的样本均值， $s^2_{g0}$ 和 $s^2_{g1}$ 为其无偏样本方差。合并方差为\n$$\ns_{p,g}^2 = \\frac{(n_0 - 1)s^2_{g0} + (n_1 - 1)s^2_{g1}}{n_0 + n_1 - 2}.\n$$\n- 方差相等的非配对双样本 $t$ 统计量为\n$$\nt_g = \\frac{\\bar{x}_{g1} - \\bar{x}_{g0}}{\\sqrt{s_{p,g}^2\\left(\\frac{1}{n_0} + \\frac{1}{n_1}\\right)}}.\n$$\n\n通路水平统计量：\n- 对于一个通路 $P \\subset \\mathcal{U}$，定义\n$$\nS(P) = \\frac{1}{|P|}\\sum_{g \\in P} |t_g|.\n$$\n\n零假设模型和置换策略：\n- 竞争性零假设模型：在零假设下，与同样大小的随机基因集相比，观测到的基因水平 $t$ 统计量在 $P$ 中没有异常集中。置换策略是，对于 $r \\in \\{1,\\dots,R\\}$，从 $\\mathcal{U}$ 中无放回地抽取大小为 $|R_r| = |P|$ 的随机子集 $R_r$，并计算 $S(R_r)$。\n- 自包含零假设模型：在零假设下，$P$ 中的基因与表型无关。置换策略是，对于 $r \\in \\{1,\\dots,R\\}$，随机置换样本标签 $y$ 以获得 $y^{(r)}$，使用 $y^{(r)}$ 重新计算基因水平的 $t^{(r)}_g$ 统计量，然后计算 $S^{(r)}(P)$。\n- 蒙特卡洛 $p$ 值：对于单边富集检验，\n$$\n\\hat{p} = \\frac{1 + \\sum_{r=1}^{R} \\mathbf{1}\\{ S^{(r)} \\ge S_{\\text{obs}} \\}}{R + 1},\n$$\n其中 $S^{(r)}$ 在竞争性零假设模型中表示 $S(R_r)$，在自包含零假设模型中表示 $S^{(r)}(P)$，而 $S_{\\text{obs}}$ 是使用给定标签 $y$ 计算的观测值 $S(P)$。\n\n随机性与可复现性：\n- 使用带有 PCG64 位生成器的 NumPy 伪随机数生成器。对于每个测试用例，用指定的种子实例化一个新的生成器，并执行指定次数的恰好 $R$ 次置换。\n\n测试套件：\n实现一个程序，为以下每个参数集计算 $\\hat{p}$。每个参数集是一个元组 $(\\text{null\\_type}, \\text{pathway}, R, \\text{seed})$，其中 $\\text{null\\_type} \\in \\{\\text{\"competitive\"}, \\text{\"self-contained\"}\\}$。\n- 用例 1：$(\\text{\"competitive\"}, \\text{\"P1\"}, 1000, 2023)$。\n- 用例 2：$(\\text{\"self-contained\"}, \\text{\"P1\"}, 200, 7)$。\n- 用例 3：$(\\text{\"competitive\"}, \\text{\"P3\"}, 500, 999)$。\n- 用例 4：$(\\text{\"self-contained\"}, \\text{\"P2\"}, 50, 12345)$。\n- 用例 5：$(\\text{\"competitive\"}, \\text{\"P2\"}, 1, 42)$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与上述用例相同。示例格式：$[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]$。\n- 每个结果必须是一个浮点数，等于蒙特卡洛 $p$ 值 $\\hat{p}$，并精确到小数点后 $6$ 位。", "solution": "我们从置换检验的基本原理开始：在一个零假设下，如果某些数据变换保持不变，那么数据的联合分布对于这些变换是可交换的。在具有两个表型组和精选通路的基因表达背景下，两种不同的零假设很常见。竞争性零假设检验所选通路是否比同样大小的随机基因集更富集强信号，这适用于将一个通路与基因组其余部分或精选数据库进行比较。自包含零假设检验通路内的基因是否与表型有任何关联，这通过打破样本和表型之间的联系，同时保持基因内部结构来评估。\n\n基因水平统计量的推导：\n对于每个基因 $g$，A 组样本集为 $\\mathcal{I}_0$，大小为 $n_0$；B 组样本集为 $\\mathcal{I}_1$，大小为 $n_1$。计算样本均值 $\\bar{x}_{g0}$ 和 $\\bar{x}_{g1}$ 以及无偏方差 $s^2_{g0}$ 和 $s^2_{g1}$。假设两组的总体方差相等，合并方差 $s_{p,g}^2$ 使用以下公式估计共同方差：\n$$\ns_{p,g}^2 = \\frac{(n_0 - 1)s^2_{g0} + (n_1 - 1)s^2_{g1}}{n_0 + n_1 - 2}.\n$$\n标准化的均值差异为\n$$\nt_g = \\frac{\\bar{x}_{g1} - \\bar{x}_{g0}}{\\sqrt{s_{p,g}^2\\left(\\frac{1}{n_0} + \\frac{1}{n_1}\\right)}},\n$$\n这是一种在方差近似相等的情况下比较两个独立组的成熟统计量。我们采用这种方法来量化每个基因的信号，因为在无差异表达的零假设下，$t_g$ 的分布中心在零附近，其大小 $|t_g|$ 反映了效应强度，而与方向无关。\n\n通路水平统计量：\n通路由精选基因 $P \\subset \\mathcal{U}$ 组成。对 $g \\in P$ 的所有 $|t_g|$ 进行聚合得到：\n$$\nS(P) = \\frac{1}{|P|}\\sum_{g \\in P} |t_g|.\n$$\n绝对值将双边敏感性压缩成一个单边富集统计量。均值考虑了通路的大小，从而能够对不同基数的集合进行公平比较，包括 $|P| = 1$ 的边界情况。\n\n通过可交换性构建零假设模型：\n- 竞争性零假设：假设是 $P$ 所包含的信号不比从 $\\mathcal{U}$ 中抽取的典型 $|P|$ 大小的基因集更多。给定使用真实标签 $y$ 计算的观测值 $t_g$，保持该零假设的重抽样过程是，从 $\\mathcal{U}$ 中无放回地随机抽样基因集 $R_r$，且 $|R_r| = |P|$。在零假设下，基因中较大的 $|t_g|$ 值的位置是可交换的，因此 $S(R_r)$ 的分布可以估计 $S(P)$ 的零分布。\n- 自包含零假设：假设是 $P$ 中的基因与表型无关。在零假设下，标签相对于样本是可交换的。因此，将标签 $y$ 置换为 $y^{(r)}$ 并重新计算基因水平统计量 $t^{(r)}_g$，可以在打破任何关联的同时保留零假设结构。$S^{(r)}(P)$ 的分布估计了通路内 $S(P)$ 的零分布。\n\n蒙特卡洛 $p$ 值：\n对于一个单边检验，其中较大的 $S$ 表示更强的富集，蒙特卡洛估计量\n$$\n\\hat{p} = \\frac{1 + \\sum_{r=1}^{R} \\mathbf{1}\\{ S^{(r)} \\ge S_{\\text{obs}} \\}}{R + 1}\n$$\n是通过计算重抽样统计量达到或超过观测值的频率得出的。分子和分母中的 $+1$ 在随机化分布下产生一个无偏估计，并防止在 $R$ 有限时出现零值。指示函数 $\\mathbf{1}\\{\\cdot\\}$ 计算 $S^{(r)}$ 大于或等于 $S_{\\text{obs}}$ 的事件次数，与富集检验的方向性相匹配。\n\n算法设计：\n1. 完全按照规定编码基因全集 $\\mathcal{U}$、精选通路、表达矩阵 $X$ 和标签 $y$。样本大小为 $n_0 = 4$ 和 $n_1 = 4$。\n2. 使用上述合并方差公式计算每个基因的 $t$ 统计量 $t_g$。这可以通过对与 $y=0$ 和 $y=1$ 对应的列进行切片，计算自由度为 1 的均值和方差，然后组装 $t_g$ 来实现基因间的向量化操作。\n3. 对于每个测试用例 $(\\text{null\\_type}, P, R, \\text{seed})$：\n   - 使用提供的整数种子初始化一个带有 PCG64 的 NumPy Generator。\n   - 使用 $|t_g|$ 和通路成员 $P$ 计算观测值 $S_{\\text{obs}} = S(P)$。\n   - 如果 $\\text{null\\_type} = \\text{\"competitive\"}$：\n     - 重复 $R$ 次：使用生成器从 $\\{1,\\dots,|\\mathcal{U}|\\}$ 中均匀无放回地抽样一个大小为 $|P|$ 的基因索引子集。通过对抽样索引上的 $|t_g|$ 求均值来计算 $S(R_r)$。计算 $S(R_r) \\ge S_{\\text{obs}}$ 的次数。\n   - 如果 $\\text{null\\_type} = \\text{\"self-contained\"}$：\n     - 重复 $R$ 次：使用生成器将 $y$ 置换为 $y^{(r)}$。使用置换后的标签通过合并方差公式重新计算 $t^{(r)}_g$，然后通过对 $P$ 中基因的 $|t^{(r)}_g|$ 求均值来计算 $S^{(r)}(P)$。计算 $S^{(r)}(P) \\ge S_{\\text{obs}}$ 的次数。\n   - 通过蒙特卡洛公式计算 $\\hat{p}$，并精确到小数点后 6 位。\n4. 将五个结果汇总到一个列表中，并以要求的无空格单行格式打印它们。\n\n边界情况与覆盖范围：\n- $R = 1$ 的用例测试了边界行为；$+1$ 调整确保了在 $\\{\\frac{1}{2}, 1\\}$ 范围内得到一个有效的概率，具体取决于单次重抽样是否超过 $S_{\\text{obs}}$。\n- 通路 $\\text{P3}$ 的大小为 $|\\text{P3}| = 1$，这测试了通路大小的边界处理，此时 $S(P)$ 对于单个基因简化为 $|t_g|$。\n- 不同的种子确保了独立且可复现的蒙特卡洛估计。\n- 两种零假设模型都在重叠和不同的通路内容上进行了演练，以检验逻辑和实现。\n\n计算考量：\n- 当 $R \\le 1000$ 且 $|\\mathcal{U}| = 10$ 时，该算法是高效且数值稳定的。鉴于所提供表达数据的变异性，合并方差的分母保持为正，从而避免了除以零的错误。\n\n最终程序精确地遵循这些步骤，为每个用例使用指定的种子初始化随机生成器，并输出列表 $[\\hat{p}_1,\\hat{p}_2,\\hat{p}_3,\\hat{p}_4,\\hat{p}_5]$，其中每个 $\\hat{p}_i$ 都四舍五入到 6 位小数。", "answer": "```python\nimport numpy as np\n\ndef compute_t_stats_equal_var(expr_matrix, labels):\n    \"\"\"\n    Compute per-gene two-sample t-statistics with pooled variance.\n    expr_matrix: shape (G, N)\n    labels: array length N with values 0 or 1\n    Returns: array of length G with t statistics (group1 - group0)\n    \"\"\"\n    labels = np.asarray(labels)\n    idx0 = np.where(labels == 0)[0]\n    idx1 = np.where(labels == 1)[0]\n    x0 = expr_matrix[:, idx0]\n    x1 = expr_matrix[:, idx1]\n    n0 = x0.shape[1]\n    n1 = x1.shape[1]\n    mean0 = x0.mean(axis=1)\n    mean1 = x1.mean(axis=1)\n    # Unbiased sample variances with ddof=1\n    var0 = x0.var(axis=1, ddof=1)\n    var1 = x1.var(axis=1, ddof=1)\n    sp2 = (((n0 - 1) * var0) + ((n1 - 1) * var1)) / (n0 + n1 - 2)\n    denom = np.sqrt(sp2 * (1.0 / n0 + 1.0 / n1))\n    # To be safe, handle any potential zero denominators by setting t=0\n    with np.errstate(divide='ignore', invalid='ignore'):\n        t = (mean1 - mean0) / denom\n        t = np.where(np.isfinite(t), t, 0.0)\n    return t\n\ndef s_stat(mean_abs_t_values, indices):\n    \"\"\"\n    Compute S(P) = mean(|t_g|) over indices for a given pathway.\n    mean_abs_t_values: precomputed |t_g| for all genes\n    indices: list/array of gene indices in the pathway\n    \"\"\"\n    if len(indices) == 0:\n        return 0.0\n    return float(np.mean(mean_abs_t_values[indices]))\n\ndef monte_carlo_pvalue_competitive(abs_t, pathway_indices, R, seed):\n    \"\"\"\n    Competitive null: sample random gene sets of same size as pathway, compute S, compare to observed.\n    \"\"\"\n    rng = np.random.Generator(np.random.PCG64(seed))\n    k = len(pathway_indices)\n    S_obs = s_stat(abs_t, pathway_indices)\n    count_ge = 0\n    G = abs_t.shape[0]\n    all_idx = np.arange(G)\n    for _ in range(R):\n        sampled = rng.choice(all_idx, size=k, replace=False)\n        S_perm = s_stat(abs_t, sampled)\n        if S_perm >= S_obs:\n            count_ge += 1\n    p_hat = (1 + count_ge) / (R + 1)\n    return p_hat\n\ndef monte_carlo_pvalue_selfcontained(expr_matrix, labels, pathway_indices, R, seed):\n    \"\"\"\n    Self-contained null: permute labels, recompute t-stats, compute S on pathway, compare to observed S.\n    \"\"\"\n    # Observed S using original labels\n    t_obs = compute_t_stats_equal_var(expr_matrix, labels)\n    abs_t_obs = np.abs(t_obs)\n    S_obs = s_stat(abs_t_obs, pathway_indices)\n\n    rng = np.random.Generator(np.random.PCG64(seed))\n    labels = np.asarray(labels)\n    count_ge = 0\n    for _ in range(R):\n        permuted = rng.permutation(labels)\n        t_perm = compute_t_stats_equal_var(expr_matrix, permuted)\n        abs_t_perm = np.abs(t_perm)\n        S_perm = s_stat(abs_t_perm, pathway_indices)\n        if S_perm >= S_obs:\n            count_ge += 1\n    p_hat = (1 + count_ge) / (R + 1)\n    return p_hat\n\ndef solve():\n    # Gene universe and pathways\n    genes = [\"G1\",\"G2\",\"G3\",\"G4\",\"G5\",\"G6\",\"G7\",\"G8\",\"G9\",\"G10\"]\n    pathway_map = {\n        \"P1\": [\"G1\",\"G2\",\"G3\",\"G4\"],\n        \"P2\": [\"G3\",\"G5\",\"G7\",\"G9\"],\n        \"P3\": [\"G10\"],\n    }\n    # Expression matrix X: shape (10, 8)\n    X = np.array([\n        [5.0, 5.2, 4.8, 5.1, 6.8, 7.1, 7.0, 6.9],  # G1\n        [3.0, 3.1, 3.2, 2.9, 4.0, 4.1, 3.9, 4.2],  # G2\n        [8.0, 7.9, 8.1, 8.2, 6.8, 6.9, 7.0, 6.7],  # G3\n        [10.0, 9.8, 10.1, 10.2, 8.9, 9.1, 9.0, 9.2],  # G4\n        [2.0, 2.1, 2.0, 1.9, 2.0, 2.1, 2.2, 2.1],  # G5\n        [5.0, 5.0, 5.1, 4.9, 5.0, 5.0, 4.9, 5.1],  # G6\n        [7.0, 7.1, 6.9, 7.0, 7.2, 7.0, 7.1, 7.1],  # G7\n        [3.0, 3.1, 2.9, 3.0, 3.0, 3.1, 3.0, 2.9],  # G8\n        [6.0, 6.1, 5.9, 6.2, 6.0, 6.1, 6.2, 5.8],  # G9\n        [4.0, 4.2, 4.1, 4.0, 5.0, 5.2, 5.1, 5.1],  # G10\n    ], dtype=float)\n    # Labels: first 4 controls (0), last 4 cases (1)\n    y = np.array([0,0,0,0,1,1,1,1], dtype=int)\n\n    # Precompute observed gene-level t statistics using provided labels for competitive null\n    t_obs_all = compute_t_stats_equal_var(X, y)\n    abs_t_obs_all = np.abs(t_obs_all)\n\n    # Build pathway index lists\n    gene_index = {g: i for i, g in enumerate(genes)}\n    pathway_indices = {k: np.array([gene_index[g] for g in v], dtype=int) for k, v in pathway_map.items()}\n\n    # Define test cases: (null_type, pathway, R, seed)\n    test_cases = [\n        (\"competitive\", \"P1\", 1000, 2023),\n        (\"self-contained\", \"P1\", 200, 7),\n        (\"competitive\", \"P3\", 500, 999),\n        (\"self-contained\", \"P2\", 50, 12345),\n        (\"competitive\", \"P2\", 1, 42),\n    ]\n\n    results = []\n    for null_type, pathway, R, seed in test_cases:\n        idx = pathway_indices[pathway]\n        if null_type == \"competitive\":\n            p = monte_carlo_pvalue_competitive(abs_t_obs_all, idx, R, seed)\n        elif null_type == \"self-contained\":\n            p = monte_carlo_pvalue_selfcontained(X, y, idx, R, seed)\n        else:\n            raise ValueError(\"Unknown null_type\")\n        results.append(round(p, 6))\n\n    # Print in the exact required format, no spaces, 6 decimals\n    formatted = \"[\" + \",\".join(f\"{v:.6f}\" for v in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "4373301"}]}