{"hands_on_practices": [{"introduction": "掌握生物网络分析的第一步是理解其基础的数学表示方法。本练习将通过一个转录因子-基因调控网络的实例，让您动手实践将生物系统表示为二分图的核心概念。通过构建双邻接矩阵和全邻接矩阵，并验证握手引理，您将为后续所有更高级的二分图结构分析打下坚实的基础[@problem_id:4321176]。", "problem": "在一个转录因子-基因调控系统中，考虑一个二部图，其中包含一组转录因子 (TF) $U = \\{T_1, T_2, T_3\\}$ 和一组基因 $V = \\{G_1, G_2, G_3, G_4\\}$。$T_i \\in U$ 和 $G_j \\in V$ 之间的边表示实验支持的结合。初始证据定义的边集 $E_0$ 为\n$$\nE_0 = \\{(T_1,G_1), (T_1,G_3), (T_2,G_2), (T_2,G_3), (T_2,G_4), (T_3,G_1)\\}.\n$$\n使用以下基本定义：二部图中 $U$ 内部或 $V$ 内部没有边；双邻接矩阵 $B \\in \\{0,1\\}^{|U|\\times|V|}$ 的元素 $B_{ij} = 1$ 表示 $T_i$ 和 $G_j$ 之间有边，否则 $B_{ij} = 0$；在顶点排序为 $(U,V)$ 的情况下，完整邻接矩阵 $A \\in \\{0,1\\}^{(|U|+|V|)\\times(|U|+|V|)}$ 的分块结构为\n$$\nA = \\begin{pmatrix}\n0  B \\\\\nB^{\\top}  0\n\\end{pmatrix};\n$$\n一个顶点的度是与其相连的边的数量；二部图的握手引理指出，$U$ 中所有顶点的度之和等于 $V$ 中所有顶点的度之和，且都等于总边数。\n\n任务：\n- 构建与 $E_0$ 对应的初始双邻接矩阵 $B_0$ 和完整邻接矩阵 $A_0$。\n- 计算初始图中 $U$ 上的度向量，记为 $d_U^{(0)} \\in \\mathbb{N}^{|U|}$，以及 $V$ 上的度向量，记为 $d_V^{(0)} \\in \\mathbb{N}^{|V|}$。验证握手引理对 $E_0$ 成立。\n- 新的染色质免疫沉淀测序证据表明存在另外两个结合：$(T_1,G_2)$ 和 $(T_3,G_4)$。令 $E_1 = E_0 \\cup \\{(T_1,G_2),(T_3,G_4)\\}$。构建更新后的双邻接矩阵 $B_1$ 和完整邻接矩阵 $A_1$，以及更新后的度向量 $d_U^{(1)}$ 和 $d_V^{(1)}$。再次验证握手引理对 $E_1$ 成立。\n\n最后，定义更新矩阵 $\\Delta A = A_1 - A_0$ 并计算标量\n$$\nS = \\|\\Delta A\\|_F^2 = \\operatorname{trace}(\\Delta A^{\\top}\\Delta A).\n$$\n仅报告 $S$ 的值作为最终答案。无需四舍五入。", "solution": "该问题定义明确，具有科学依据，并提供了进行求解所需的所有信息。\n\n转录因子集合为 $U = \\{T_1, T_2, T_3\\}$，所以 $|U|=3$。基因集合为 $V = \\{G_1, G_2, G_3, G_4\\}$，所以 $|V|=4$。二部图中的总顶点数为 $|U|+|V| = 3+4=7$。\n\n首先，我们构建与边集 $E_0 = \\{(T_1,G_1), (T_1,G_3), (T_2,G_2), (T_2,G_3), (T_2,G_4), (T_3,G_1)\\}$ 对应的初始双邻接矩阵 $B_0$。矩阵 $B_0$ 是一个 $3 \\times 4$ 的矩阵，其中行对应 $U$ 的元素，列对应 $V$ 的元素。如果 $T_i$ 和 $G_j$ 之间存在边，则元素 $B_{ij}$ 为 $1$。\n$$\nB_0 = \\begin{pmatrix}\n1  0  1  0 \\\\\n0  1  1  1 \\\\\n1  0  0  0\n\\end{pmatrix}\n$$\n完整邻接矩阵 $A_0$ 是一个 $7 \\times 7$ 的分块矩阵，定义为 $A_0 = \\begin{pmatrix} \\mathbf{0}_{3\\times3} & B_0 \\\\ B_0^{\\top} & \\mathbf{0}_{4\\times4} \\end{pmatrix}$。\n$$\nA_0 = \\left(\\begin{array}{ccc|cccc}\n0  0  0 & 1  0  1  0 \\\\\n0  0  0 & 0  1  1  1 \\\\\n0  0  0 & 1  0  0  0 \\\\\n\\hline\n1  0  1 & 0  0  0  0 \\\\\n0  1  0 & 0  0  0  0 \\\\\n1  1  0 & 0  0  0  0 \\\\\n0  1  0 & 0  0  0  0\n\\end{array}\\right)\n$$\n接下来，我们计算度向量。$U$ 中顶点的度是 $B_0$ 中其对应行的和。$V$ 中顶点的度是 $B_0$ 中其对应列的和。\n$U$ 的度向量为 $d_U^{(0)}$：\n$\\deg(T_1) = 1+0+1+0 = 2$\n$\\deg(T_2) = 0+1+1+1 = 3$\n$\\deg(T_3) = 1+0+0+0 = 1$\n因此，$d_U^{(0)} = (2, 3, 1)^{\\top}$。\n\n$V$ 的度向量为 $d_V^{(0)}$：\n$\\deg(G_1) = 1+0+1 = 2$\n$\\deg(G_2) = 0+1+0 = 1$\n$\\deg(G_3) = 1+1+0 = 2$\n$\\deg(G_4) = 0+1+0 = 1$\n因此，$d_V^{(0)} = (2, 1, 2, 1)^{\\top}$。\n\n为了验证握手引理，我们将每个部分中的度相加，并与边数 $|E_0| = 6$ 进行比较。\n$U$ 中的度之和：$\\sum_{i=1}^{3} (d_U^{(0)})_i = 2+3+1 = 6$。\n$V$ 中的度之和：$\\sum_{j=1}^{4} (d_V^{(0)})_j = 2+1+2+1 = 6$。\n由于两个和都等于 $|E_0|$，因此握手引理对初始图成立。\n\n现在，我们考虑更新后的图，其中有两条新边 $(T_1,G_2)$ 和 $(T_3,G_4)$。新的边集是 $E_1 = E_0 \\cup \\{(T_1,G_2),(T_3,G_4)\\}$，共有 $|E_1| = 6+2 = 8$ 条边。更新后的双邻接矩阵 $B_1$ 是通过在 $B_0$ 中添加这些边得到的，这对应于将条目 $(1,2)$ 和 $(3,4)$ 的值设为 1。\n$$\nB_1 = \\begin{pmatrix}\n1  1  1  0 \\\\\n0  1  1  1 \\\\\n1  0  0  1\n\\end{pmatrix}\n$$\n更新后的完整邻接矩阵是 $A_1 = \\begin{pmatrix} \\mathbf{0}_{3\\times3} & B_1 \\\\ B_1^{\\top} & \\mathbf{0}_{4\\times4} \\end{pmatrix}$。\n\n更新后的度向量 $d_U^{(1)}$ 和 $d_V^{(1)}$ 为：\n$d_U^{(1)}$ ($B_1$ 的行和)：\n$\\deg(T_1) = 1+1+1+0 = 3$\n$\\deg(T_2) = 0+1+1+1 = 3$\n$\\deg(T_3) = 1+0+0+1 = 2$\n因此，$d_U^{(1)} = (3, 3, 2)^{\\top}$。\n\n$d_V^{(1)}$ ($B_1$ 的列和)：\n$\\deg(G_1) = 1+0+1 = 2$\n$\\deg(G_2) = 1+1+0 = 2$\n$\\deg(G_3) = 1+1+0 = 2$\n$\\deg(G_4) = 0+1+1 = 2$\n因此，$d_V^{(1)} = (2, 2, 2, 2)^{\\top}$。\n\n对更新后的图验证握手引理：\n$U$ 中的度之和：$\\sum_{i=1}^{3} (d_U^{(1)})_i = 3+3+2 = 8$。\n$V$ 中的度之和：$\\sum_{j=1}^{4} (d_V^{(1)})_j = 2+2+2+2 = 8$。\n两个和都等于 $|E_1|=8$，因此引理成立。\n\n最后，我们计算标量 $S = \\|\\Delta A\\|_F^2$，其中 $\\Delta A = A_1 - A_0$。\n首先，我们求出差分矩阵 $\\Delta A$。\n$$\n\\Delta A = A_1 - A_0 = \\begin{pmatrix} \\mathbf{0} & B_1 \\\\ B_1^{\\top} & \\mathbf{0} \\end{pmatrix} - \\begin{pmatrix} \\mathbf{0} & B_0 \\\\ B_0^{\\top} & \\mathbf{0} \\end{pmatrix} = \\begin{pmatrix} \\mathbf{0} & B_1 - B_0 \\\\ B_1^{\\top} - B_0^{\\top} & \\mathbf{0} \\end{pmatrix}\n$$\n令 $\\Delta B = B_1 - B_0$。\n$$\n\\Delta B = \\begin{pmatrix}\n1  1  1  0 \\\\\n0  1  1  1 \\\\\n1  0  0  1\n\\end{pmatrix} - \\begin{pmatrix}\n1  0  1  0 \\\\\n0  1  1  1 \\\\\n1  0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  1\n\\end{pmatrix}\n$$\n这个矩阵 $\\Delta B$ 仅在添加的边 $(T_1, G_2)$ 和 $(T_3, G_4)$ 对应的位置上有非零项。\n完整的差分矩阵为 $\\Delta A = \\begin{pmatrix} \\mathbf{0}_{3\\times3} & \\Delta B \\\\ \\Delta B^{\\top} & \\mathbf{0}_{4\\times4} \\end{pmatrix}$。\n具体为：\n$$\n\\Delta A = \\left(\\begin{array}{ccc|cccc}\n0  0  0 & 0  1  0  0 \\\\\n0  0  0 & 0  0  0  0 \\\\\n0  0  0 & 0  0  0  1 \\\\\n\\hline\n0  0  0 & 0  0  0  0 \\\\\n1  0  0 & 0  0  0  0 \\\\\n0  0  0 & 0  0  0  0 \\\\\n0  0  1 & 0  0  0  0\n\\end{array}\\right)\n$$\n弗罗贝尼乌斯范数的平方，$S = \\|\\Delta A\\|_F^2$，是 $\\Delta A$ 中所有元素平方的和。\n$$\nS = \\sum_{i,j} (\\Delta A_{ij})^2\n$$\n$\\Delta A$ 的非零项为 1，位于位置 $(1,5)$、$(3,7)$、$(5,1)$ 和 $(7,3)$。共有 4 个这样的项。\n因此，它们的平方和为：\n$$\nS = 1^2 + 1^2 + 1^2 + 1^2 = 1+1+1+1 = 4\n$$\n这个值也可以使用迹的定义 $S = \\operatorname{trace}(\\Delta A^{\\top}\\Delta A)$ 求得。由于 $\\Delta A$ 是一个实对称矩阵，所以 $\\Delta A^{\\top} = \\Delta A$，因此 $S = \\operatorname{trace}(\\Delta A^2)$。$\\Delta A^2$ 的对角线元素是 $\\Delta A$ 的行与自身的点积。这实际上就是计算每行中非零项的数量。共有 4 行，每行各有一个非零项。所以迹为 $1+1+1+1 = 4$。两种方法得到相同的结果。\n一个基于分块结构的更直接的论证是 $S = \\|\\Delta A\\|_F^2 = \\|\\Delta B\\|_F^2 + \\|\\Delta B^{\\top}\\|_F^2$。\n$\\|\\Delta B\\|_F^2 = 1^2 + 1^2 = 2$。\n由于弗罗贝尼乌斯范数在转置下不变，所以 $\\|\\Delta B^{\\top}\\|_F^2 = 2$。\n因此，$S = 2 + 2 = 4$。", "answer": "$$\\boxed{4}$$", "id": "4321176"}, {"introduction": "除了简单的连接关系，生物网络的局部拓扑结构中还包含着反复出现的模式，即“网络基序”（motif），它们通常对应着特定的生物学功能。本实践聚焦于4-周期（4-cycle）基序，这是二分图中一种常见的结构，可代表共调控或冗余通路等概念。您将推导并实现一个巧妙的算法，利用矩阵代数高效地对这些基序进行计数，从而展示图论与线性代数在系统生物学中的强大结合[@problem_id:4321179]。", "problem": "考虑一个简单的二分图 $G=(V,E)$，其顶点集分为两个不相交的类别 $V_{\\mathrm{enz}}$（酶）和 $V_{\\mathrm{met}}$（代谢物），其中每条边 $e \\in E$ 连接 $V_{\\mathrm{enz}}$ 中的一个顶点和 $V_{\\mathrm{met}}$ 中的一个顶点。设其双邻接矩阵为 $B \\in \\{0,1\\}^{n_{\\mathrm{enz}} \\times n_{\\mathrm{met}}}$，如果酶 $i$ 与代谢物 $j$ 相连，则 $B_{ij} = 1$，否则 $B_{ij} = 0$。假设没有多重边和自环，因此 $B$ 是二值的，描述了一个简单的二分图。一个 $4$-环是一个长度为 $4$ 的简单环，它在 $V_{\\mathrm{enz}}$ 和 $V_{\\mathrm{met}}$ 之间交替，即一个由不同顶点组成的序列 $(e_a, m_u, e_b, m_v)$，其中 $e_a, e_b \\in V_{\\mathrm{enz}}$，$m_u, m_v \\in V_{\\mathrm{met}}$，且边 $(e_a,m_u)$、$(m_u,e_b)$、$(e_b,m_v)$、$(m_v,e_a)$ 都存在于 $E$ 中。\n\n仅从这些核心定义出发，通过将 $C_4$ 表示为矩阵乘积 $B B^{\\top}$ 和 $B^{\\top} B$ 以及基于共享邻居的组合计数论证，推导出一个有原理的算法来计算整数 $C_4$（$G$ 中不同简单 $4$-环的数量）。您的推导必须证明为什么对一个顶点划分中的共享邻居的无序对进行计数，可以得到不同简单 $4$-环的总数，以及为什么在另一个顶点划分上存在一个等价的对称表达式。基于此推导，实现一个程序，为下面的每个测试网络计算 $C_4$。\n\n用一个二值矩阵 $B$ 来表示每个测试网络，其行索引酶，列索引代谢物。这些矩阵是：\n\n- 测试 $1$（一个完全二分子图中的最小 $4$-环）：$B = \\begin{bmatrix} 1  1 \\\\ 1  1 \\end{bmatrix}$。\n- 测试 $2$（无 $4$-环，稀疏连接）：$B = \\begin{bmatrix} 1  0  0 \\\\ 1  0  0 \\\\ 0  1  0 \\end{bmatrix}$。\n- 测试 $3$（多个重叠的 $4$-环）：$B = \\begin{bmatrix} 1  1  1  0 \\\\ 1  1  1  0 \\\\ 0  1  1  1 \\end{bmatrix}$。\n- 测试 $4$（完全二分图 $K_{3,3}$）：$B = \\begin{bmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{bmatrix}$。\n- 测试 $5$（边界情况，单个酶）：$B = \\begin{bmatrix} 1  1  1  1 \\end{bmatrix}$。\n\n您的程序必须对上述每个 $B$ 矩阵，使用从核心定义推导出的有原理的算法计算出整数 $C_4$。此外，为了内部验证，您应该确保通过对酶计数（通过 $B B^{\\top}$）获得的值等于通过对代谢物计数（通过 $B^{\\top} B$）获得的值，并且等于通过检查所有酶和代谢物的无序对进行直接枚举得到的值。最终输出应为单行文本，包含一个计算出的 $C_4$ 值的列表，按测试 $1$ 到 $5$ 的顺序排列，格式为用方括号括起来的逗号分隔列表（例如 `[a,b,c,d,e]`）。不涉及物理单位或角度单位，也不需要百分比；每个输出项必须是整数。\n\n您的程序应只产生一行包含最终列表的输出，不含任何额外文本。", "solution": "在尝试求解之前，评估问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n- **图类型**：一个简单的二分图 $G=(V,E)$，其顶点集分为两个不相交的类别 $V_{\\mathrm{enz}}$（酶）和 $V_{\\mathrm{met}}$（代谢物）。\n- **边定义**：每条边 $e \\in E$ 连接 $V_{\\mathrm{enz}}$ 中的一个顶点和 $V_{\\mathrm{met}}$ 中的一个顶点。\n- **双邻接矩阵**：$B \\in \\{0,1\\}^{n_{\\mathrm{enz}} \\times n_{\\mathrm{met}}}$，其中 $n_{\\mathrm{enz}} = |V_{\\mathrm{enz}}|$ 且 $n_{\\mathrm{met}} = |V_{\\mathrm{met}}|$。如果酶 $i$ 与代谢物 $j$ 相连，则 $B_{ij} = 1$，否则 $B_{ij} = 0$。\n- **环定义**：一个简单 $4$-环是一个由不同顶点组成的序列 $(e_a, m_u, e_b, m_v)$，其中 $e_a, e_b \\in V_{\\mathrm{enz}}$，$m_u, m_v \\in V_{\\mathrm{met}}$，且边 $(e_a,m_u)$、$(m_u,e_b)$、$(e_b,m_v)$、$(m_v,e_a)$ 都存在于 $E$ 中。\n- **目标**：使用矩阵乘积 $B B^{\\top}$ 和 $B^{\\top} B$ 推导出一个算法来计算 $C_4$（不同简单 $4$-环的数量），并加以实现。\n- **测试数据**：\n    - 测试 $1$：$B = \\begin{bmatrix} 1  1 \\\\ 1  1 \\end{bmatrix}$\n    - 测试 $2$：$B = \\begin{bmatrix} 1  0  0 \\\\ 1  0  0 \\\\ 0  1  0 \\end{bmatrix}$\n    - 测试 $3$：$B = \\begin{bmatrix} 1  1  1  0 \\\\ 1  1  1  0 \\\\ 0  1  1  1 \\end{bmatrix}$\n    - 测试 $4$：$B = \\begin{bmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{bmatrix}$\n    - 测试 $5$：$B = \\begin{bmatrix} 1  1  1  1 \\end{bmatrix}$\n- **输出格式**：单行文本，包含一个用逗号分隔的整数结果列表，`[c1,c2,c3,c4,c5]`。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据所需标准评估该问题。\n- **有科学依据**：该问题基于图论和线性代数的基本标准概念。使用双邻接矩阵表示二分图和子图计数是成熟的数学课题。它们在酶-代谢物网络中的应用是系统生物学中常见的抽象方法。\n- **适定的**：问题定义清晰。输入矩阵已明确给出，期望的输出（4-环的数量）对于每个输入都是唯一可确定的整数。\n- **客观性**：问题陈述使用精确、形式化的数学语言，没有歧义或主观性陈述。\n- **缺陷分析**：\n    1.  **科学/事实上不健全**：无。定义和前提都是标准的、数学上合理的。\n    2.  **非形式化/不相关**：无。问题是明确的数学问题，并与所述领域相关。\n    3.  **不完整/矛盾**：无。所有必要的定义和数据都已提供。\n    4.  **不切实际/不可行**：无。该问题处理抽象的图结构，对于给定的矩阵，现代计算机的计算量是微不足道的。\n    5.  **不适定/结构不良**：无。唯一解存在且可从前提中推导得出。\n    6.  **伪深刻/琐碎**：无。该问题需要一个非平凡的推导，将矩阵代数与组合计数联系起来，这是一个标准但概念上有意义的练习。\n    7.  **超出科学可验证范围**：无。结果可以通过直接枚举和推导出的公式进行验证。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将推导并实现一个有原理支持的解法。\n\n### 算法推导\n\n在具有划分 $V_{\\mathrm{enz}}$ 和 $V_{\\mathrm{met}}$ 的二分图中，一个简单 $4$-环由四个不同顶点的序列 $(e_a, m_u, e_b, m_v)$ 定义，其中 $e_a, e_b \\in V_{\\mathrm{enz}}$ 且 $m_u, m_v \\in V_{\\mathrm{met}}$。环的存在意味着四条边的存在：$(e_a, m_u)$、$(e_a, m_v)$、$(e_b, m_u)$ 和 $(e_b, m_v)$。这四个顶点和四条边构成一个完全二分子图 $K_{2,2}$。因此，计算不同简单 $4$-环的数量 $C_4$ 等价于计算 $G$ 中不同 $K_{2,2}$ 子图的数量。\n\n一个 $K_{2,2}$ 子图由一对不同的酶的无序对 $\\{e_a, e_b\\}$ 和一对不同的代谢物的无序对 $\\{m_u, m_v\\}$ 唯一确定，条件是所有四个对应的边都存在。我们可以通过遍历一个划分中的顶点对，并计算另一个划分中有多少对可以完成一个 $K_{2,2}$ 来对这些子图进行计数。\n\n**方法 1：通过酶对计数**\n\n考虑来自 $V_{\\mathrm{enz}}$ 的任意一对不同的酶的无序对 $\\{e_a, e_b\\}$。为了使这两个酶成为 $4$-环的一部分，它们必须共享至少两个共同的代谢物邻居。令 $N(v)$ 表示顶点 $v$ 的邻居集合。$e_a$ 和 $e_b$ 的共同代谢物邻居集合是 $N(e_a) \\cap N(e_b)$。设该集合的大小为 $k_{ab} = |N(e_a) \\cap N(e_b)|$。\n\n要与 $e_a$ 和 $e_b$ 形成一个 $4$-环，我们必须从它们的共同邻居中选择两个不同的代谢物。从这 $k_{ab}$ 个共同邻居中选择一对代谢物的无序对的方式数由二项式系数 $\\binom{k_{ab}}{2}$ 给出。每个这样的选择都与酶对 $\\{e_a, e_b\\}$ 构成一个唯一的 $K_{2,2}$ 子图（从而构成一个 $4$-环）。\n\n为了找到 $4$-环的总数 $C_4$，我们必须将此数量对所有不同的酶的无序对求和：\n$$ C_4 = \\sum_{\\{e_a, e_b\\} \\subseteq V_{\\mathrm{enz}}, |\\{e_a, e_b\\}|=2} \\binom{k_{ab}}{2} = \\sum_{1 \\le a  b \\le n_{\\mathrm{enz}}} \\binom{k_{ab}}{2} $$\n其中 $a$ 和 $b$ 是酶的索引。\n\n我们可以使用双邻接矩阵 $B$ 来表示 $k_{ab}$。$B$ 的第 $i$ 行，表示为 $B_{i,:}$，是一个向量，其第 $j$ 个分量为 $1$ 当且仅当酶 $e_i$ 连接到代谢物 $m_j$。共同邻居的数量 $k_{ab}$ 是 $B_{a,:}$ 和 $B_{b,:}$ 中均为 $1$ 的位置数。这正是这两个行向量的点积：\n$$ k_{ab} = \\sum_{j=1}^{n_{\\mathrm{met}}} B_{aj} B_{bj} $$\n现在，考虑矩阵乘积 $S_{\\mathrm{enz}} = B B^{\\top}$。这是一个 $n_{\\mathrm{enz}} \\times n_{\\mathrm{enz}}$ 的对称矩阵。元素 $(S_{\\mathrm{enz}})_{ab}$ 是 $B$ 的第 $a$ 行与 $B^{\\top}$ 的第 $b$ 列的点积。由于 $B^{\\top}$ 的第 $b$ 列就是 $B$ 的第 $b$ 行，我们有：\n$$ (S_{\\mathrm{enz}})_{ab} = \\sum_{j=1}^{n_{\\mathrm{met}}} B_{aj} B_{bj} = k_{ab} $$\n因此，$S_{\\mathrm{enz}} = B B^{\\top}$ 的非对角线元素计算了酶对之间共享的代谢物邻居数量。对角线元素 $(S_{\\mathrm{enz}})_{aa}$ 计算了酶 $e_a$ 的度，这与本计算无关。\n\n将此代入我们的计数公式，我们得到算法：\n$$ C_4 = \\sum_{1 \\le a  b \\le n_{\\mathrm{enz}}} \\binom{(S_{\\mathrm{enz}})_{ab}}{2} = \\sum_{1 \\le a  b \\le n_{\\mathrm{enz}}} \\frac{(S_{\\mathrm{enz}})_{ab}((S_{\\mathrm{enz}})_{ab} - 1)}{2} $$\n该表达式对矩阵 $S_{\\mathrm{enz}}$ 的上三角（或下三角）中（不包括对角线）的所有元素贡献求和。\n\n**方法 2：通过代谢物对计数（对称论证）**\n\n这个论证是完全对称的。我们可以从考虑来自 $V_{\\mathrm{met}}$ 的一对不同的代谢物的无序对 $\\{m_u, m_v\\}$ 开始。令 $k'_{uv} = |N(m_u) \\cap N(m_v)|$ 为这对代谢物共享的酶邻居数量。要形成一个 $4$-环，我们必须从这个集合中选择两个不同的酶，这可以通过 $\\binom{k'_{uv}}{2}$ 种方式完成。\n\n对所有不同的代谢物的无序对求和得到总数：\n$$ C_4 = \\sum_{\\{m_u, m_v\\} \\subseteq V_{\\mathrm{met}}, |\\{m_u, m_v\\}|=2} \\binom{k'_{uv}}{2} = \\sum_{1 \\le u  v \\le n_{\\mathrm{met}}} \\binom{k'_{uv}}{2} $$\n共享邻居的数量 $k'_{uv}$ 可以从 $B$ 的列中找到。设 $B_{:,j}$ 为第 $j$ 个列向量。那么：\n$$ k'_{uv} = \\sum_{i=1}^{n_{\\mathrm{enz}}} B_{iu} B_{iv} $$\n这对应于矩阵乘积 $S_{\\mathrm{met}} = B^{\\top}B$ 的元素，这是一个 $n_{\\mathrm{met}} \\times n_{\\mathrm{met}}$ 的对称矩阵，其中：\n$$ (S_{\\mathrm{met}})_{uv} = \\sum_{i=1}^{n_{\\mathrm{enz}}} B_{iu} B_{iv} = k'_{uv} $$\n这导致等价的公式：\n$$ C_4 = \\sum_{1 \\le u  v \\le n_{\\mathrm{met}}} \\binom{(S_{\\mathrm{met}})_{uv}}{2} = \\sum_{1 \\le u  v \\le n_{\\mathrm{met}}} \\frac{(S_{\\mathrm{met}})_{uv}((S_{\\mathrm{met}})_{uv} - 1)}{2} $$\n\n**等价性证明**\n两种公式都计算了同一组对象：$K_{2,2}$ 子图，每个子图对应一个唯一的简单 $4$-环。第一个公式基于酶对划分计数，而第二个公式基于代谢物对划分计数。由于每个 $4$-环都恰好涉及一对酶和一对代谢物，所以两个求和必须得到相同的总数 $C_4$。这证实了组合恒等式：\n$$ \\sum_{1 \\le a  b \\le n_{\\mathrm{enz}}} \\binom{(BB^{\\top})_{ab}}{2} = \\sum_{1 \\le u  v \\le n_{\\mathrm{met}}} \\binom{(B^{\\top}B)_{uv}}{2} $$\n\n推导出的算法是首先计算这些“共享邻居”矩阵之一（$S_{\\mathrm{enz}}$ 或 $S_{\\mathrm{met}}$），然后遍历其唯一的非对角线元素 $k$，并对 $\\binom{k}{2}$ 的值求和。这比枚举所有四个顶点的组合在计算上更有效。实现将使用以酶为中心的公式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count_c4(B: np.ndarray) - int:\n    \"\"\"\n    Computes the number of simple 4-cycles (C4) in a bipartite graph.\n\n    The algorithm is derived from a combinatorial argument based on shared neighbors.\n    A 4-cycle is formed by two enzymes {e_a, e_b} and two metabolites {m_u, m_v}.\n    This structure requires that both enzymes are connected to both metabolites.\n    \n    1. The number of 4-cycles can be found by summing contributions from every\n       pair of enzymes {e_a, e_b}.\n    2. For a given pair, if they share k_ab common metabolite neighbors, they can\n       form binom(k_ab, 2) distinct 4-cycles by choosing 2 metabolites from\n       the shared set.\n    3. The number of shared neighbors k_ab for enzymes e_a and e_b is given by\n       the matrix product S_enz = B @ B.T, where (S_enz)_ab = k_ab.\n    4. The total count C4 is the sum of binom(k, 2) over all off-diagonal\n       elements k of the S_enz matrix.\n\n    Args:\n        B: The n_enz x n_met biadjacency matrix of the graph, as a numpy array.\n\n    Returns:\n        The total number of simple 4-cycles (C4) as an integer.\n    \"\"\"\n    if B.shape[0]  2:\n        # A 4-cycle requires at least two enzymes.\n        return 0\n\n    # S_enz is the enzyme-enzyme shared neighbor matrix.\n    # (S_enz)_ab = number of metabolites connected to both enzyme a and enzyme b.\n    S_enz = B @ B.T\n\n    num_enzymes = S_enz.shape[0]\n    c4_count = 0\n\n    # Iterate over the upper triangle of the S_enz matrix (excluding the diagonal).\n    # This corresponds to iterating over all unique pairs of enzymes {a, b}.\n    for i in range(num_enzymes):\n        for j in range(i + 1, num_enzymes):\n            # k is the number of shared neighbors for the enzyme pair {i, j}.\n            k = S_enz[i, j]\n            \n            # If there are k shared neighbors, we can form binom(k, 2) 4-cycles.\n            # binom(k, 2) = k * (k - 1) / 2\n            if k = 2:\n                c4_count += k * (k - 1) // 2\n                \n    return c4_count\n\ndef solve():\n    \"\"\"\n    Defines the test cases, computes C4 for each, and prints the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: a minimal 4-cycle in a complete bipartite subgraph\n        np.array([[1, 1], \n                  [1, 1]]),\n        # Test 2: no 4-cycles, sparse connections\n        np.array([[1, 0, 0],\n                  [1, 0, 0],\n                  [0, 1, 0]]),\n        # Test 3: multiple overlapping 4-cycles\n        np.array([[1, 1, 1, 0],\n                  [1, 1, 1, 0],\n                  [0, 1, 1, 1]]),\n        # Test 4: complete bipartite K_{3,3}\n        np.array([[1, 1, 1],\n                  [1, 1, 1],\n                  [1, 1, 1]]),\n        # Test 5: boundary case, single enzyme\n        np.array([[1, 1, 1, 1]])\n    ]\n\n    results = []\n    for B in test_cases:\n        result = count_c4(B)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4321179"}, {"introduction": "识别对网络完整性至关重要的节点是系统生物学的一项核心任务，其应用范围从药物靶点发现到疾病机理理解。本练习要求您应用一个经典的图算法，在反应-代谢物网络中寻找最小顶点覆盖。通过实现一个基于哥尼定理（Kőnig's theorem）的解决方案，您将看到这一抽象的图论概念如何直接转化为识别潜在的代谢“瓶颈”（choke points）——即那些一旦被移除就可能中断整个代谢通路的关键代谢物[@problem_id:4321211]。", "problem": "考虑一个反应-代谢物二分网络，该网络被建模为一个二分图 $G = (R \\cup M, E)$，其中 $R$ 是反应顶点集，$M$ 是代谢物顶点集，$E \\subseteq R \\times M$ 是连接反应与代谢物的边集，如果一代谢物参与一个反应（作为底物或产物），则它们之间存在一条边。该图是简单、无权且无自环的图。$R$ 中的所有顶点索引从 $0$ 到 $r - 1$，$M$ 中的所有顶点索引从 $0$ 到 $m - 1$，其中 $r = |R|$，$m = |M|$。对于给定的实例，通过指定 $r$、$m$ 以及作为有序对 $(i, j)$（其中 $i \\in \\{0, 1, \\dots, r - 1\\}$ 且 $j \\in \\{0, 1, \\dots, m - 1\\}$）的边列表来提供二分结构。\n\n根据图论的基本原理，一个图的顶点覆盖是一个顶点集合 $C \\subseteq R \\cup M$，使得 $E$ 中的每条边至少有一个端点在 $C$ 中。最小顶点覆盖是基数最小的顶点覆盖。在反应-代谢物二分网络的背景下，最小顶点覆盖中所包含的代谢物顶点子集可以被解释为通路中断的潜在瓶颈点，因为从网络中移除这些代谢物会消除所有与之关联的反应-代谢物边，从而通过被覆盖的边阻断相关的反应连通性。\n\n您的任务是编写一个完整的程序，对每个测试用例，计算该二分图的一个最小顶点覆盖，并输出该覆盖中包含的代谢物顶点（来自 $M$）的索引，按非降序排序。每个测试用例的结果必须是一个整数列表。\n\n从核心定义和广为接受的图论事实出发。不要假设或使用任何没有这些基础的特定技巧。算法应对由给定参数描述的任何二分图实例都是正确的。\n\n不涉及物理单位或角度。所有输出必须是纯数字。\n\n测试套件：\n- 测试用例 1：$r = 4$, $m = 4$, 边 $E = \\{(0, 0), (0, 1), (1, 1), (2, 2), (3, 2), (3, 3)\\}$.\n- 测试用例 2：$r = 3$, $m = 2$, 边 $E = \\{(0, 0), (1, 0), (2, 0)\\}$.\n- 测试用例 3：$r = 2$, $m = 3$, 边 $E = \\{(0, 0), (1, 1)\\}$.\n- 测试用例 4：$r = 4$, $m = 4$, 边 $E = \\{(0, 0), (0, 1), (1, 1), (2, 2), (3, 2)\\}$.\n- 测试用例 5：$r = 2$, $m = 2$, 边 $E = \\emptyset$.\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是计算出的最小顶点覆盖中的代谢物索引列表，按非降序排序。例如，包含两个测试用例的输出可能看起来像 $[[0,1],[2]]$。您的程序必须为所提供的测试套件准确输出这样的一行。", "solution": "该问题要求我们找到给定反应-代谢物二分图 $G = (R \\cup M, E)$ 的最小顶点覆盖中所包含的代谢物顶点集。解决方案必须源于图论的基本原理。\n\n在二分图中，将最小顶点覆盖与另一个关键图结构联系起来的最重要原理是 Kőnig 定理。该定理指出，在任何二分图中，最大匹配中的边数等于最小顶点覆盖中的顶点数。\n令 $\\mathcal{M}_{max}$ 为最大匹配（没有公共顶点的最大边集），$C_{min}$ 为最小顶点覆盖（覆盖每条边的最小顶点集）。Kőnig 定理可表述为：\n$$|\\mathcal{M}_{max}| = |C_{min}|$$\nKőnig 定理的构造性证明提供了一个直接的算法，可以在给定最大匹配的情况下找到一个最小顶点覆盖。我们的策略将遵循这个构造性算法。\n\n该算法主要分两步进行：\n1.  在二分图 $G$ 中找到一个最大匹配 $\\mathcal{M}$。\n2.  使用匹配 $\\mathcal{M}$ 构造一个最小顶点覆盖 $C$。\n\n**第 1 步：寻找最大匹配**\n\n可以通过反复寻找“增广路径”来找到最大匹配。增广路径是图中的一条路径，它在当前匹配之外的边和当前匹配之内的边之间交替，从一个部分中的未匹配顶点开始，到另一个部分中的未匹配顶点结束。通过反转增广路径上边的状态（将非匹配边加入匹配，并移除匹配边），匹配的大小会增加一。我们继续寻找并应用增广路径，直到找不到为止。此时，匹配即为最大匹配。\n\n寻找增广路径的过程可以使用深度优先搜索（DFS）或广度优先搜索（BFS）高效实现。我们将使用基于 DFS 的方法。我们遍历反应集 $R$ 中的每个顶点 $u$。对于每个 $u$，我们执行一次 DFS 来寻找从它开始的增广路径。\n\n设图的两个部分为 $U=R$（反应）和 $V=M$（代谢物）。匹配可以用一个大小为 $m=|M|$ 的数组 `match_M` 表示，其中 `match_M[j]` 存储与代谢物 $j \\in M$ 匹配的 $R$ 中的顶点，如果 $j$ 未匹配，则存为一个特殊值（例如 $-1$）。\n\nDFS 函数 `dfs(u, visited, match_M, adj)` 尝试寻找从反应顶点 $u \\in R$ 开始的增广路径。`visited` 数组记录在当前 DFS 中访问过的代谢物顶点，以防止循环。该函数的工作方式如下：对于 $u$ 的每个邻居 $v \\in M$，如果 $v$ 未被访问过，我们将其标记为已访问。如果 $v$ 未匹配，我们就找到了一条增广路径。我们将 $u$ 与 $v$ 匹配并返回真。如果 $v$ 已经与某个顶点 $u' \\in R$ 匹配，我们递归调用 `dfs(u', ...)`。如果这个递归调用找到了从 $u'$ 开始的增广路径，我们就可以“移动”匹配：$u'$ 获得一个新的配对，从而释放 $v$，然后我们可以将 $v$ 与 $u$ 匹配。\n\n**第 2 步：构造最小顶点覆盖**\n\n一旦找到最大匹配 $\\mathcal{M}$，我们就可以构造一个最小顶点覆盖 $C$。令 $R_u$ 为反应集 $R$ 中的未匹配顶点集。令 $Z$ 为 $G$ 中所有可以从 $R_u$ 中的任意顶点通过交错路径到达的顶点集。交错路径是一条其边在 $\\mathcal{M}$ 之外和 $\\mathcal{M}$ 之内交替的路径。集合 $Z$ 可以通过从 $R_u$ 中所有顶点开始的一次图遍历（DFS 或 BFS）找到：\n- 从一个顶点 $u \\in R \\cap Z$ 出发，如果边 $(u,v)$ **不**在 $\\mathcal{M}$ 中，则遍历到顶点 $v \\in M$。\n- 从一个顶点 $v \\in M \\cap Z$ 出发，如果边 $(u,v)$ **在** $\\mathcal{M}$ 中，则遍历到顶点 $u \\in R$。\n\n找到集合 $Z$ 后（可将其划分为 $Z_R = Z \\cap R$ 和 $Z_M = Z \\cap M$），最小顶点覆盖 $C$ 由 Kőnig 定理的构造性证明中的公式给出：\n$$C = (R \\setminus Z_R) \\cup Z_M$$\n问题要求的是此覆盖中的代谢物顶点索引，这恰好是集合 $Z_M$。\n\n以测试用例 4 为例进行说明：$r=4, m=4, E = \\{(0, 0), (0, 1), (1, 1), (2, 2), (3, 2)\\}$。\n- **第 1 步：**找到一个最大匹配。一个可能的最大匹配是 $\\mathcal{M} = \\{(0,0), (1,1), (2,2)\\}$。该匹配的大小为 3。反应顶点 $r_3$ 和代谢物顶点 $m_3$ 是未匹配的。\n- **第 2 步：**构造顶点覆盖。\n  - $R$ 中的未匹配顶点集为 $R_u = \\{3\\}$。\n  - 从 $R_u$ 开始，通过交错路径寻找可达顶点集 $Z$：\n    1. 将 $r_3$ 加入 $Z$。\n    2. 从 $r_3$ 出发，沿非匹配边 $(3,2)$ 到达 $m_2$。将 $m_2$ 加入 $Z$。\n    3. 从 $m_2$ 出发，沿匹配边 $(2,2)$ 到达 $r_2$。将 $r_2$ 加入 $Z$。\n    4. 从 $r_2$ 出发，没有非匹配边可以遍历（其唯一的邻居 $m_2$ 是通过匹配边 $(2,2)$ 连接的），因此遍历结束。\n  - 最终可达顶点集为 $Z = \\{r_2, r_3, m_2\\}$。\n  - 将 $Z$ 划分为 $Z_R = Z \\cap R = \\{2, 3\\}$ 和 $Z_M = Z \\cap M = \\{2\\}$。\n  - 根据 Kőnig 定理的构造，最小顶点覆盖为 $C = (R \\setminus Z_R) \\cup Z_M = (\\{0,1,2,3\\} \\setminus \\{2,3\\}) \\cup \\{2\\} = \\{r_0, r_1, m_2\\}$。\n  - 覆盖的大小为 3，与最大匹配的大小相等，验证了其最小性。\n- 覆盖中的代谢物顶点是 $Z_M$ 中的顶点，即 $\\{m_2\\}$。所要求的输出是索引列表，按非降序排序：$[2]$。\n\n提供的代码为每个测试用例实现了此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It iterates through test cases, computes the metabolite indices in a minimum\n    vertex cover for each, and prints the results in the specified format.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        (4, 4, [(0, 0), (0, 1), (1, 1), (2, 2), (3, 2), (3, 3)]),\n        # Test case 2\n        (3, 2, [(0, 0), (1, 0), (2, 0)]),\n        # Test case 3\n        (2, 3, [(0, 0), (1, 1)]),\n        # Test case 4\n        (4, 4, [(0, 0), (0, 1), (1, 1), (2, 2), (3, 2)]),\n        # Test case 5\n        (2, 2, [])\n    ]\n\n    results = []\n    for r, m, edges in test_cases:\n        result = compute_mvc_metabolites(r, m, edges)\n        results.append(result)\n\n    # Format the final output string as per requirements, removing spaces in lists.\n    # e.g., [[0,1],[2]] instead of '[[0, 1], [2]]'\n    formatted_results = [str(res).replace(\" \", \"\") for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_mvc_metabolites(r, m, edges):\n    \"\"\"\n    Computes the metabolite indices in a minimum vertex cover of a bipartite graph.\n\n    The function follows the constructive proof of Kőnig's theorem:\n    1. Find a maximum matching using an augmenting path algorithm (DFS-based).\n    2. Construct the minimum vertex cover from the matching by finding all\n       vertices reachable from unmatched R-vertices via alternating paths.\n    3. Return the metabolite vertices from the constructed cover.\n\n    Args:\n        r (int): Number of vertices in the reaction set R.\n        m (int): Number of vertices in the metabolite set M.\n        edges (list of tuples): The set of edges E, where each edge is (i, j)\n                                with i in R and j in M.\n\n    Returns:\n        list of int: A sorted list of indices of metabolite vertices in one\n                     minimum vertex cover.\n    \"\"\"\n    if not edges:\n        return []\n\n    adj = [[] for _ in range(r)]\n    for u, v in edges:\n        adj[u].append(v)\n\n    # `match_m[j]` stores the R-vertex matched with M-vertex j.\n    match_m = np.full(m, -1, dtype=int)\n\n    def dfs_match(u, visited_m_dfs, current_match_m, adj_list):\n        \"\"\"\n        DFS to find an augmenting path starting from an R-vertex u.\n        \"\"\"\n        for v in adj_list[u]:\n            if not visited_m_dfs[v]:\n                visited_m_dfs[v] = True\n                # If v is unmatched, or its partner can find another match\n                if current_match_m[v]  0 or dfs_match(current_match_m[v], visited_m_dfs, current_match_m, adj_list):\n                    current_match_m[v] = u\n                    return True\n        return False\n\n    # Step 1: Find a maximum matching\n    for i in range(r):\n        visited_m_in_dfs = np.zeros(m, dtype=bool)\n        dfs_match(i, visited_m_in_dfs, match_m, adj)\n        \n    # Build reverse matching for convenience\n    match_r = np.full(r, -1, dtype=int)\n    for j in range(m):\n        if match_m[j] != -1:\n            match_r[match_m[j]] = j\n\n    # Step 2: Construct the minimum vertex cover\n    unmatched_r = [i for i in range(r) if match_r[i] == -1]\n\n    # Find the set Z of vertices reachable from unmatched_r via alternating paths\n    z_r = set(unmatched_r)\n    z_m = set()\n    queue = list(unmatched_r)\n    head = 0\n\n    while head  len(queue):\n        u = queue[head]\n        head += 1\n        for v in adj[u]:\n            # Traverse non-matching edge from R to M\n            if v not in z_m and match_r[u] != v:\n                z_m.add(v)\n                u_partner = match_m[v]\n                # If endpoint is matched, traverse matching edge from M to R\n                if u_partner != -1 and u_partner not in z_r:\n                    z_r.add(u_partner)\n                    queue.append(u_partner)\n\n    # The metabolite vertices in the minimum vertex cover are exactly z_m.\n    # The cover C = (R \\ z_r) U z_m\n    mvc_metabolites = sorted(list(z_m))\n    \n    return mvc_metabolites\n\nsolve()\n```", "id": "4321211"}]}