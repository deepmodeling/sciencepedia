{"hands_on_practices": [{"introduction": "本次实践旨在巩固布尔网络最核心的动力学概念：同步更新。通过为一个具体的三节点网络计算单步状态转移，你将直接应用布尔逻辑规则，并将抽象的调控关系转化为网络在离散时间中的具体演化。这项基础练习是理解更复杂的网络行为（如吸引子和状态循环）的必要前提。[@problem_id:4321671]", "problem": "在系统生物医学中，基因调控网络 (GRN) 可被建模为一个布尔网络，其节点代表基因，更新规则编码了调控逻辑。考虑一个具有节点 $A$、$B$ 和 $C$ 的确定性布尔网络，其同步更新函数为 $f_{A} = B \\land \\neg C$、$f_{B} = A \\lor C$ 和 $f_{C} = \\neg A$。使用布尔网络、布尔逻辑（$\\neg$、$\\land$、$\\lor$）和同步更新的基本定义，完成以下任务：\n\n1. 根据以下原则构建网络的连接图：若节点 $X$ 出现在 $f_{Y}$ 中，则存在一条从节点 $X$ 到节点 $Y$ 的有向边。若 $X$ 以非否定形式出现，则该边为正向（激活）；若 $X$ 以否定形式出现，则为负向（抑制）。\n\n2. 从状态 $(A,B,C) = (1,0,1)$ 开始，进行一次同步更新以得到 $(A',B',C')$，其中每个节点都根据其各自函数在当前状态下的求值结果同时更新。\n\n将更新后的状态作为您的最终答案。无需四舍五入，且无单位。最终答案必须表示为使用 LaTeX 括号的单行行向量。", "solution": "该问题陈述被评估为有效。它在科学上基于布尔网络的既有理论，该理论是系统生物学和离散动力系统的基石。该问题是适定的，提供了一套完整且一致的定义、规则和条件——具体来说，即网络节点（$A$、$B$、$C$）、同步更新函数（$f_{A}$、$f_{B}$、$f_{C}$）、初始状态以及构建网络拓扑的规则。其语言客观明确，可得出一个唯一的、可验证的解。\n\n该问题要求完成两项任务。首先，我们构建连接图；其次，我们从给定的初始状态计算一次同步更新。\n\n该系统是一个具有三个节点的布尔网络，其状态由向量 $(A, B, C)$ 表示，其中每个变量的取值范围为 $\\{0, 1\\}$。网络的动力学由以下同步更新函数所支配：\n$$f_{A} = B \\land \\neg C$$\n$$f_{B} = A \\lor C$$\n$$f_{C} = \\neg A$$\n\n**任务1：连接图的构建**\n\n连接图描述了节点之间的调控相互作用。如果节点 $X$ 的状态是节点 $Y$ 更新函数 $f_Y$ 的一个自变量，那么就存在一条从 $X$ 指向 $Y$ 的有向边。如果 $X$ 以非否定形式出现，该相互作用被定义为激活（正向）；如果 $X$ 以否定形式（$\\neg X$）出现，则为抑制（负向）。\n\n1.  **对 $f_{A} = B \\land \\neg C$ 的分析**：\n    *   节点 $A$ 的函数依赖于节点 $B$ 和 $C$。\n    *   $B$ 以非否定形式出现，表示从 $B$ 到 $A$ 的激活相互作用。\n    *   $C$ 以否定形式 $\\neg C$ 出现，表示从 $C$ 到 $A$ 的抑制相互作用。\n\n2.  **对 $f_{B} = A \\lor C$ 的分析**：\n    *   节点 $B$ 的函数依赖于节点 $A$ 和 $C$。\n    *   $A$ 以非否定形式出现，表示从 $A$ 到 $B$ 的激活相互作用。\n    *   $C$ 以非否定形式出现，表示从 $C$ 到 $B$ 的激活相互作用。\n\n3.  **对 $f_{C} = \\neg A$ 的分析**：\n    *   节点 $C$ 的函数依赖于节点 $A$。\n    *   $A$ 以否定形式 $\\neg A$ 出现，表示从 $A$ 到 $C$ 的抑制相互作用。\n\n总结来说，有向边为：$A \\to B$（激活）、$A \\dashv C$（抑制）、$B \\to A$（激活）、$C \\to A$（抑制）和 $C \\to B$（激活）。\n\n**任务2：同步状态更新**\n\n题目要求我们计算在时间 $t$ 的状态为 $(A, B, C) = (1, 0, 1)$ 时，网络在时间 $t+1$ 的状态，记作 $(A', B', C')$。在同步更新方案中，所有节点都根据网络在时间 $t$ 的状态同时进行更新。\n\n设时间 $t$ 的状态为 $(A(t), B(t), C(t)) = (1, 0, 1)$。时间 $t+1$ 的状态 $(A(t+1), B(t+1), C(t+1))$ 的计算过程如下：\n\n1.  **节点 A 的更新**：\n    $A(t+1) = f_{A}(A(t), B(t), C(t)) = B(t) \\land \\neg C(t)$\n    代入给定值：\n    $A(t+1) = 0 \\land \\neg 1$\n    根据布尔逻辑，$\\neg 1 = 0$。因此：\n    $A(t+1) = 0 \\land 0 = 0$\n\n2.  **节点 B 的更新**：\n    $B(t+1) = f_{B}(A(t), B(t), C(t)) = A(t) \\lor C(t)$\n    代入给定值：\n    $B(t+1) = 1 \\lor 1$\n    根据布尔逻辑，$1 \\lor 1 = 1$。因此：\n    $B(t+1) = 1$\n\n3.  **节点 C 的更新**：\n    $C(t+1) = f_{C}(A(t), B(t), C(t)) = \\neg A(t)$\n    代入给定值：\n    $C(t+1) = \\neg 1$\n    根据布尔逻辑，$\\neg 1 = 0$。因此：\n    $C(t+1) = 0$\n\n综合以上结果，网络更新后的状态为 $(A', B', C') = (A(t+1), B(t+1), C(t+1)) = (0, 1, 0)$。", "answer": "$$\\boxed{\\begin{pmatrix} 0  1  0 \\end{pmatrix}}$$", "id": "4321671"}, {"introduction": "在掌握了单步更新后，我们来探讨一个更深层次的问题：更新机制本身如何影响网络的全局行为。本练习要求你比较同步与异步更新两种模式下的网络动力学，通过追踪同一个初始状态的演化轨迹，你将发现可达状态集和最终吸引子的显著差异。这个对比实践揭示了在建模生物系统时，选择合适的更新策略是多么关键。[@problem_id:4321648]", "problem": "考虑一个小型基因调控模块的布尔网络模型，该模型包含三个节点 $A$、$B$ 和 $C$。每个节点代表一个二值调控元件，其中 $0$ 表示非激活状态，$1$ 表示激活状态。该网络通过更新函数 $f_A$、$f_B$ 和 $f_C$ 进行演化，这些函数将当前全局状态映射到每个节点的下一个值。更新函数定义为 $f_A = B$，$f_B = \\neg C$ 和 $f_C = A \\land B$，其中 $\\neg$ 表示逻辑非，$\\land$ 表示逻辑与。全局状态是向量 $(A,B,C) \\in \\{0,1\\}^3$。初始状态是 $(0,1,0)$。\n\n考虑两种更新语义：\n\n- 同步更新：在每个时间步，所有节点 $A$、$B$ 和 $C$ 使用各自的函数 $f_A$、$f_B$ 和 $f_C$ 同时根据当前全局状态进行更新。\n\n- 通用异步更新：在每个时间步，任意选择一个非空节点子集，只有被选中的节点使用其函数根据当前全局状态进行更新；未被选中的节点保持其当前值不变。\n\n从初始状态 $(0,1,0)$ 开始，执行以下操作：\n\n1. 在同步更新下，通过迭代同步更新来枚举轨迹，直到某个状态重复出现，并确定所有不同可达状态的集合及其吸引子（即轨迹中重复出现的模式）。\n\n2. 在通用异步更新下，按如下方式构建从给定状态出发的单步转移可能性：对于当前状态 $(A,B,C)$ 和每个非空子集 $U \\subseteq \\{A,B,C\\}$，通过将 $U$ 中每个节点 $i$ 的值更新为 $f_i(A,B,C)$ 来定义下一个状态，同时保持不在 $U$ 中的节点的值不变。从 $(0,1,0)$ 开始，枚举通过任意有限次此类更新序列可达的所有状态。将吸引子识别为状态转移图中的终端组件，定义为终端强连通分量 (TSCCs)，其中强连通分量 (SCC) 是具有相互可达性的最大状态集，而终端组件没有向该组件外的状态的传出转移。\n\n3. 令 $R_{\\text{sync}}$ 为在同步更新下从 $(0,1,0)$ 开始可达的不同状态的数量，令 $R_{\\text{async}}$ 为在通用异步更新下从 $(0,1,0)$ 开始可达的不同状态的数量。计算比率 $r = \\dfrac{R_{\\text{async}}}{R_{\\text{sync}}}$，结果表示为最简精确分数。\n\n将最终答案以单个值 $r$ 的形式给出。无需四舍五入。将分数表示为最简形式，不要包含任何单位。", "solution": "用户提供了一个关于布尔网络的问题，并要求计算在两种不同更新方案下可达状态数量的比率。\n\n### 第1步：提取已知条件\n- **节点**：$A$、$B$、$C$。\n- **状态空间**：全局状态集合为 $\\{0,1\\}^3$，其中一个状态是一个向量 $(A,B,C)$。\n- **更新函数**：\n  - $f_A(A,B,C) = B$\n  - $f_B(A,B,C) = \\neg C$\n  - $f_C(A,B,C) = A \\land B$\n- **初始状态**：$S_0 = (0,1,0)$。\n- **更新语义**：\n  1.  **同步**：在每个时间步，所有节点同时更新。\n  2.  **通用异步**：在每个时间步，任意非空节点子集可以更新。\n- **任务**：\n  1.  找到同步更新方案下的可达状态集和吸引子。令可达状态的数量为 $R_{\\text{sync}}$。\n  2.  找到通用异步更新方案下的所有可达状态集和吸引子（终端强连通分量，或 TSCCs）。令可达状态的数量为 $R_{\\text{async}}$。\n  3.  计算比率 $r = \\frac{R_{\\text{async}}}{R_{\\text{sync}}}$。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据**：该问题在布尔网络理论中有充分的依据，布尔网络是系统生物学、计算机科学及相关领域的标准建模框架。同步和异步更新、状态转移图、可达性以及吸引子（循环、SCC、TSCC）等概念都是标准的且在数学上是严谨的。\n- **适定性**：该问题定义清晰，具有唯一的初始状态、明确的更新规则和精确的动力学定义。所提出的问题有确定的、可计算的答案。\n- **客观性**：该问题以形式化的数学语言陈述，没有歧义或主观性。\n\n### 第3步：结论与行动\n该问题是有效的。这是一个定义明确的离散动力系统练习。我将继续进行求解。\n\n### 第1部分：同步更新动力学\n\n在同步更新方案下，网络在时间步 $t+1$ 的状态，记为 $S_{t+1} = (A_{t+1}, B_{t+1}, C_{t+1})$，由时间步 $t$ 的状态 $S_t = (A_t, B_t, C_t)$ 通过以下规则确定：\n$A_{t+1} = f_A(S_t) = B_t$\n$B_{t+1} = f_B(S_t) = \\neg C_t = 1 - C_t$\n$C_{t+1} = f_C(S_t) = A_t \\land B_t = A_t \\cdot B_t$\n\n从初始状态 $S_0 = (0,1,0)$ 开始，我们迭代更新映射：\n- **$t=0$**：$S_0 = (0,1,0)$\n- **$t=1$**：$S_1 = (f_A(S_0), f_B(S_0), f_C(S_0)) = (1, \\neg 0, 0 \\land 1) = (1,1,0)$\n- **$t=2$**：$S_2 = (f_A(S_1), f_B(S_1), f_C(S_1)) = (1, \\neg 0, 1 \\land 1) = (1,1,1)$\n- **$t=3$**：$S_3 = (f_A(S_2), f_B(S_2), f_C(S_2)) = (1, \\neg 1, 1 \\land 1) = (1,0,1)$\n- **$t=4$**：$S_4 = (f_A(S_3), f_B(S_3), f_C(S_3)) = (0, \\neg 1, 1 \\land 0) = (0,0,0)$\n- **$t=5$**：$S_5 = (f_A(S_4), f_B(S_4), f_C(S_4)) = (0, \\neg 0, 0 \\land 0) = (0,1,0)$\n\n由于 $S_5=S_0$，系统进入一个循环。轨迹为 $(0,1,0) \\to (1,1,0) \\to (1,1,1) \\to (1,0,1) \\to (0,0,0) \\to (0,1,0) \\dots$。\n不同可达状态的集合是该轨迹中的状态集合：\n$\\mathcal{R}_{\\text{sync}} = \\{(0,1,0), (1,1,0), (1,1,1), (1,0,1), (0,0,0)\\}$.\n在同步更新下，不同可达状态的数量为 $R_{\\text{sync}} = 5$。\n吸引子是这个循环本身，也就是集合 $\\mathcal{R}_{\\text{sync}}$。\n\n### 第2部分：通用异步更新动力学\n\n在通用异步方案下，从当前状态 $S=(A,B,C)$，我们首先计算目标状态 $S' = (f_A(S), f_B(S), f_C(S))$。任意非空节点子集 $U \\subseteq \\{A,B,C\\}$ 都可以被更新。下一个状态 $S_{next}$ 的形成方式是，将 $U$ 中节点 $i$ 的值设为其在 $S'$ 中的值，并保持不在 $U$ 中的节点 $j$ 的值与在 $S$ 中时相同。\n\n我们从初始状态 $S_0 = (0,1,0)$ 开始执行广度优先搜索 (BFS) 来找到所有可达状态。\n令 $\\mathcal{R}_{\\text{async}}$ 为可达状态的集合。初始时，$\\mathcal{R}_{\\text{async}} = \\{(0,1,0)\\}$。我们维护一个待访问状态的队列。\n\n1.  **从 $S=(0,1,0)$ 开始**：\n    - 目标状态 $S' = (1, \\neg 0, 0 \\land 1) = (1,1,0)$。\n    - 当前状态 $(0,1,0)$ 与目标状态 $(1,1,0)$ 仅在分量 $A$ 上不同。\n    - 任何包含 $A$ 的更新集 $U$ 将导致下一个状态为 $(1,1,0)$。任何不包含 $A$ 的更新集（即 $\\{B\\}$、$\\{C\\}$、$\\{B,C\\}$）不会改变状态。\n    - 新的可达状态：$(1,1,0)$。$\\mathcal{R}_{\\text{async}} = \\{(0,1,0), (1,1,0)\\}$。\n\n2.  **从 $S=(1,1,0)$ 开始**：\n    - 目标状态 $S' = (1, \\neg 0, 1 \\land 1) = (1,1,1)$。\n    - 差异仅在分量 $C$ 上。任何包含 $C$ 的更新集将导致状态 $(1,1,1)$。\n    - 新的可达状态：$(1,1,1)$。$\\mathcal{R}_{\\text{async}} = \\{(0,1,0), (1,1,0), (1,1,1)\\}$。\n\n3.  **从 $S=(1,1,1)$ 开始**：\n    - 目标状态 $S' = (1, \\neg 1, 1 \\land 1) = (1,0,1)$。\n    - 差异仅在分量 $B$ 上。任何包含 $B$ 的更新集将导致状态 $(1,0,1)$。\n    - 新的可达状态：$(1,0,1)$。$\\mathcal{R}_{\\text{async}} = \\{(0,1,0), (1,1,0), (1,1,1), (1,0,1)\\}$。\n\n4.  **从 $S=(1,0,1)$ 开始**：\n    - 目标状态 $S' = (0, \\neg 1, 1 \\land 0) = (0,0,0)$。\n    - 当前状态 $(1,0,1)$ 与目标状态 $(0,0,0)$ 在分量 $A$ 和 $C$ 上不同。\n    - 更新 $\\{A\\} \\to (0,0,1)$。新状态。\n    - 更新 $\\{C\\} \\to (1,0,0)$。新状态。\n    - 更新 $\\{A,C\\} \\to (0,0,0)$。新状态。\n    - (其他涉及 $B$ 的更新没有效果，因为 $B$ 已经是 $0$)。\n    - 新的可达状态：$(0,0,1), (1,0,0), (0,0,0)$。$\\mathcal{R}_{\\text{async}} = \\{(0,1,0), (1,1,0), (1,1,1), (1,0,1), (0,0,1), (1,0,0), (0,0,0)\\}$。\n\n5.  **从 $S=(0,0,1)$ 开始**：\n    - 目标状态 $S' = (0, \\neg 1, 0 \\land 0) = (0,0,0)$。\n    - 差异在分量 $C$ 上。任何包含 $C$ 的更新集将导致 $(0,0,0)$，这已在 $\\mathcal{R}_{\\text{async}}$ 中。没有新状态。\n\n6.  **从 $S=(1,0,0)$ 开始**：\n    - 目标状态 $S' = (0, \\neg 0, 1 \\land 0) = (0,1,0)$。\n    - 差异在分量 $A$ 和 $B$ 上。\n    - 更新 $\\{A\\} \\to (0,0,0)$。已找到。\n    - 更新 $\\{B\\} \\to (1,1,0)$。已找到。\n    - 更新 $\\{A,B\\} \\to (0,1,0)$。已找到。没有新状态。\n\n7.  **从 $S=(0,0,0)$ 开始**：\n    - 目标状态 $S' = (0, \\neg 0, 0 \\land 0) = (0,1,0)$。\n    - 差异在分量 $B$ 上。任何包含 $B$ 的更新集将导致 $(0,1,0)$，这已在 $\\mathcal{R}_{\\text{async}}$ 中。没有新状态。\n\n搜索完成。所有可达状态的集合是：\n$\\mathcal{R}_{\\text{async}} = \\{(0,0,0), (0,0,1), (0,1,0), (1,0,0), (1,0,1), (1,1,0), (1,1,1)\\}$.\n共有 $7$ 个可达状态。唯一不可达的状态是 $(0,1,1)$。\n所以，$R_{\\text{async}} = 7$。\n\n为了找到吸引子，我们分析这 $7$ 个状态上的状态转移图以寻找强连通分量 (SCCs)。\n转移关系如下：\n- $(0,1,0) \\to (1,1,0)$\n- $(1,1,0) \\to (1,1,1)$\n- $(1,1,1) \\to (1,0,1)$\n- $(1,0,1) \\to \\{(0,0,1), (1,0,0), (0,0,0)\\}$\n- $(0,0,1) \\to (0,0,0)$\n- $(1,0,0) \\to \\{(0,0,0), (1,1,0), (0,1,0)\\}$\n- $(0,0,0) \\to (0,1,0)$\n\n让我们追踪路径以显示相互可达性：\n- 存在一个循环：$(0,1,0) \\to (1,1,0) \\to (1,1,1) \\to (1,0,1) \\to (1,0,0) \\to (0,1,0)$。这表明 $\\{(0,1,0), (1,1,0), (1,1,1), (1,0,1), (1,0,0)\\}$ 都在同一个 SCC 中。\n- 从这个循环，我们可以到达其他状态。从 $(1,0,1)$，我们可以到达 $(0,0,1)$ 和 $(0,0,0)$。\n- 我们必须检查是否可以返回。从 $(0,0,0)$，我们可以到达 $(0,1,0)$，它在循环中。从 $(0,0,1)$，我们可以到达 $(0,0,0)$，再从那里回到循环。\n- 这表明所有 $7$ 个可达状态都是相互可达的。它们形成一个单一的大型 SCC。\n\n由于这个 SCC 包含了所有可达状态，因此没有向其外部的转移。因此，这个 SCC 是一个终端 SCC (TSCC)。异步动力学有一个吸引子，即集合 $\\mathcal{R}_{\\text{async}}$ 本身。\n\n### 第3部分：计算比率\n\n根据前面部分，我们有：\n- 同步更新下可达的不同状态数量：$R_{\\text{sync}} = 5$。\n- 通用异步更新下可达的不同状态数量：$R_{\\text{async}} = 7$。\n\n所需的比率 $r$ 是：\n$$r = \\frac{R_{\\text{async}}}{R_{\\text{sync}}} = \\frac{7}{5}$$\n这是一个最简精确分数，因为 $5$ 和 $7$ 都是素数。", "answer": "$$\\boxed{\\frac{7}{5}}$$", "id": "4321648"}, {"introduction": "这项编程练习将引导你从手动分析小型网络过渡到对任意网络进行自动化、算法化的分析。你将需要构建一个完整的计算流程，用于解析异步布尔网络的动态特性，这包括将状态转移图、强连通分量（SCC）以及吸引盆等理论概念转化为具体的算法。完成这项任务标志着你已具备构建实用分析工具的能力，这是现代系统生物学研究中一项至关重要的实践技能。[@problem_id:4321637]", "problem": "在系统生物医学的背景下，考虑一个布尔网络，其中一个基因调控网络（GRN）被建模为 $n$ 个二元节点，其状态空间为 $\\{0,1\\}^n$。设节点索引标记为 $1,2,\\dots,n$，一个布尔状态表示为 $x=(x_1,x_2,\\dots,x_n)$，其中每个 $x_i \\in \\{0,1\\}$。对于每个节点 $i$，其布尔更新函数为 $f_i:\\{0,1\\}^n \\to \\{0,1\\}$。异步更新语义定义如下：从一个状态 $x$ 出发，对于每个满足 $f_i(x) \\neq x_i$ 的索引 $i$，存在一个到后继状态 $y^{(i)}$ 的有向转移，该后继状态的分量满足 $y^{(i)}_i = f_i(x)$ 且对于所有 $j \\neq i$ 有 $y^{(i)}_j = x_j$。如果对于所有 $i \\in \\{1,\\dots,n\\}$ 都有 $f_i(x) = x_i$，那么 $x$ 是一个没有出向转移的不动点。异步更新下的全局动态可以表示为一个包含 $2^n$ 个状态的有限有向图。\n\n我们定义有向状态转移图 $G$，其顶点是 $2^n$ 个二元状态，其边 $x \\to y$ 代表如上所述的单节点异步更新。异步语义下的吸引子是图 $G$ 的一个终端强连通分量（SCC），即一个非空子集 $A \\subseteq \\{0,1\\}^n$，它本身是强连通的，并且没有指向 $A$ 外部状态的出边。此处，吸引子 $A$ 的吸引盆定义为所有状态的集合，从这些状态中的任意一个出发，都存在至少一条（在异步更新规则下的）有向路径到达 $A$ 中的某个状态。吸引盆的大小是该集合的基数。我们将使用从二元状态向量到整数索引 $s \\in \\{0,1,\\dots,2^n-1\\}$ 的映射，该映射由下式给出\n$$\ns(x) \\;=\\; \\sum_{i=1}^{n} x_i \\, 2^{\\,n-i},\n$$\n以使 $x_1$ 成为最高有效位，$x_n$ 成为最低有效位。这种整数编码定义了状态上的一个全序关系，我们将用它来根据吸引子包含的最小索引对吸引子进行排序，并对每个吸引子内部的状态按索引升序排序。\n\n你的任务是编写一个完整的程序，该程序能够：\n- 为每个给定的网络枚举所有 $2^n$ 个状态，\n- 根据上述定义构建所有异步转移，\n- 将所有吸引子计算为终端强连通分量，\n- 确定每个吸引子的大小（强连通分量中的状态数），\n- 通过计算能通过有向路径到达吸引子中至少一个状态的状态数量来确定每个吸引盆的大小，\n- 完全按照要求的格式为提供的测试套件输出结果。\n\n从布尔网络、异步更新语义和图论中的强连通分量的基本定义出发，不假设任何专门的快捷公式。确保你的算法推理与这些定义一致。\n\n测试套件：\n对于每个测试用例 $k$，网络由一个整数 $n_k$ 和节点更新函数列表 $(f_1,\\dots,f_{n_k})$ 指定。测试套件包含三个网络：\n\n- 测试用例 1：$n_1 = 3$ 且\n  $f_1(x) = x_2$，$f_2(x) = x_1$，$f_3(x) = x_3$。\n- 测试用例 2：$n_2 = 3$ 且带有负反馈环\n  $f_1(x) = \\neg x_2$，$f_2(x) = \\neg x_3$，$f_3(x) = \\neg x_1$，\n  其中 $\\neg$ 表示逻辑非。\n- 测试用例 3：$n_3 = 2$ 且\n  $f_1(x) = \\neg x_1$，$f_2(x) = x_2$。\n\n答案规范：\n- 对于每个测试用例，你的程序必须生成一个包含四个元素的列表：\n  [$吸引子数量$, $作为状态索引列表的吸引子列表$, $吸引子大小列表$, $吸引盆大小列表$]。\n- 每个吸引子表示为其状态的整数索引列表，根据 $s(x)$ 按升序排序。\n- 在总列表中，吸引子按其包含的最小状态索引值的升序排列。\n- 吸引盆大小的排序与相应的吸引子对齐。\n- 所有数字必须是整数。\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表，例如：\n$[ \\text{result\\_tc1} , \\text{result\\_tc2} , \\text{result\\_tc3} ]$，\n打印的行中不含任何额外的空白字符。\n\n不涉及物理单位，也没有角度或百分比。最终输出是采用上述整数编码的纯组合数据。该问题具有普适性，可以通过构建和分析由异步布尔更新导出的有限有向图，在任何现代编程语言中解决。请通过遵循已定义的语义并返回逻辑上一致的吸引子和吸引盆大小来确保科学真实性。", "solution": "该问题要求对异步布尔网络进行全面分析，包括识别吸引子及其吸引盆。解决方案需要一个基于图论的多步算法方法。具有 $n$ 个节点的布尔网络的状态空间为 $\\{0,1\\}^n$，包含 $2^n$ 个唯一状态。我们将系统动态建模为一个有向状态转移图 $G=(V, E)$，其中顶点集 $V$ 是所有 $2^n$ 个状态的集合，如果状态 $y$ 可以通过一次异步更新从状态 $x$ 到达，则存在一条有向边 $(x, y) \\in E$。\n\n首先，我们形式化状态表示。每个状态 $x = (x_1, x_2, \\dots, x_n)$ 使用指定的公式映射到一个唯一的整数索引 $s \\in \\{0, 1, \\dots, 2^n-1\\}$：\n$$\ns(x) = \\sum_{i=1}^{n} x_i \\, 2^{n-i}\n$$\n该编码将 $(x_1, \\dots, x_n)$ 视为 $s$ 的二进制表示，其中 $x_1$ 是最高有效位。这使我们可以使用整数索引来表示状态，便于实现图算法。\n\n算法流程如下：\n\n1.  **状态转移图的构建**：我们首先构建图 $G$ 的邻接表表示。对于 $2^n$ 个状态中的每一个，用其整数索引 $s$ 标识，我们首先将 $s$ 转换回其二元向量形式 $x=(x_1, \\dots, x_n)$。然后，对于每个节点 $i \\in \\{1, \\dots, n\\}$，我们评估相应的更新函数 $f_i(x)$。如果节点的当前状态 $x_i$ 与目标值不同，即 $x_i \\neq f_i(x)$，则可能发生一次异步转移。此转移导致一个后继状态 $y^{(i)}$，其中只有第 $i$ 个分量被更新：$y^{(i)}_i = f_i(x)$ 且对于所有 $j \\neq i$ 有 $y^{(i)}_j = x_j$。我们将每个这样的后继状态 $y^{(i)}$ 转换为其整数索引，并将其添加到状态 $s$ 的邻接表中。如果一个状态 $x$ 对所有 $i$ 都满足 $f_i(x) = x_i$，它就是一个不动点，没有出向转移。\n\n2.  **强连通分量（SCC）分解**：吸引子被定义为状态转移图 $G$ 的一个终端强连通分量（SCC）。为了找到所有 SCC，我们采用 Tarjan 算法，这是一种基于单次深度优先搜索（DFS）遍历图的标准高效方法。对于每个顶点 $u$，该算法维护两个值：一个发现时间 `disc[u]`，即首次访问的时间；以及一个“低链接”值 `low[u]`，即从 $u$（包括其自身）通过其 DFS 子树可达到的最小发现时间。一个顶点 $u$ 是一个 SCC 的根当且仅当 `disc[u] == low[u]`。当找到这样一个根时，算法堆栈上所有在 $u$ 之上（并包括 $u$）的顶点共同构成一个 SCC。此过程将整个状态集 $V$ 划分成不相交的 SCC。\n\n3.  **吸引子（终端 SCC）的识别**：将图分解为 SCC 后，我们必须识别其中哪些是终端的。一个 SCC（比如 $C$）是终端的，当且仅当不存在任何从 $u \\in C$ 中的状态出发，指向 $v \\notin C$ 的状态的边。我们遍历每个计算出的 SCC。对于 SCC 中的每个状态，我们检查其在原始图 $G$ 中的后继节点。如果该 SCC 中所有状态的所有后继节点也都包含在同一个 SCC 内，那么它就被声明为一个终端 SCC，即一个吸引子。\n\n4.  **吸引盆的计算**：吸引子 $A$ 的吸引盆被定义为所有状态的集合，从这些状态出发，存在至少一条路径可以到达 $A$ 中的任何一个状态。为了计算这个集合的大小，我们可以解决图上的一个可达性问题。能够到达 $A$ 的状态集最有效的查找方法是考虑反向图 $G_{rev}$，其中 $G$ 中的每条边 $(u,v)$ 都被一条边 $(v,u)$ 替代。然后，在 $G_{rev}$ 上从吸引子 $A$ 中的所有状态同时开始图遍历（如广度优先搜索或深度优先搜索），我们就可以发现所有能到达 $A$ 的状态。这次遍历中访问到的所有唯一状态的总数构成了 $A$ 的吸引盆，其基数就是吸引盆的大小。\n\n5.  **输出格式化**：最后，对每个测试用例的结果进行汇总。识别出的吸引子根据它们包含的最小状态索引进行排序。每个吸引子内部的状态也按其索引的升序排序。吸引子大小和吸引盆大小的列表按与排序后的吸引子相对应的顺序列出。然后将这些结构化数据格式化为指定的列表格式以供最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# scipy is available but not required for this problem.\n# from scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to define, solve, and print results for all test cases.\n    \"\"\"\n\n    # Helper function to format lists without whitespace, as per output requirements.\n    def format_list(item):\n        if isinstance(item, list):\n            return f\"[{','.join(format_list(x) for x in item)}]\"\n        else:\n            return str(item)\n\n    test_cases = [\n        {\n            \"n\": 3,\n            \"functions\": [lambda x: x[1], lambda x: x[0], lambda x: x[2]],\n        },\n        {\n            \"n\": 3,\n            \"functions\": [lambda x: 1 - x[1], lambda x: 1 - x[2], lambda x: 1 - x[0]],\n        },\n        {\n            \"n\": 2,\n            \"functions\": [lambda x: 1 - x[0], lambda x: x[1]],\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        functions = case[\"functions\"]\n        result = analyze_network(n, functions)\n        all_results.append(result)\n\n    print(format_list(all_results))\n\ndef analyze_network(n, functions):\n    \"\"\"\n    Analyzes a single Boolean network to find its attractors and their basins.\n\n    Args:\n        n (int): The number of nodes in the network.\n        functions (list of callables): The list of Boolean update functions.\n\n    Returns:\n        list: A list containing [num_attractors, attractors, attractor_sizes, basin_sizes].\n    \"\"\"\n    num_states = 1  n  # Equivalent to 2**n\n\n    # --- 1. Graph Construction ---\n    adj = {i: [] for i in range(num_states)}\n    rev_adj = {i: [] for i in range(num_states)}\n\n    for s in range(num_states):\n        # Convert integer index to binary state tuple\n        state_str = f'{s:0{n}b}'\n        state = tuple(int(c) for c in state_str)\n\n        for i in range(n):\n            target_val = functions[i](state)\n            if state[i] != target_val:\n                next_state_list = list(state)\n                next_state_list[i] = target_val\n                # Convert next state to integer index\n                next_s = int(\"\".join(map(str, next_state_list)), 2)\n                if next_s not in adj[s]:\n                    adj[s].append(next_s)\n                if s not in rev_adj[next_s]:\n                    rev_adj[next_s].append(s)\n    \n    # --- 2. SCC Decomposition (Tarjan's Algorithm) ---\n    disc = [-1] * num_states\n    low = [-1] * num_states\n    on_stack = [False] * num_states\n    stack = []\n    time = 0\n    sccs = []\n\n    def tarjan_dfs(u):\n        nonlocal time\n        disc[u] = low[u] = time\n        time += 1\n        stack.append(u)\n        on_stack[u] = True\n\n        for v in adj[u]:\n            if disc[v] == -1:\n                tarjan_dfs(v)\n                low[u] = min(low[u], low[v])\n            elif on_stack[v]:\n                low[u] = min(low[u], disc[v])\n\n        if low[u] == disc[u]:\n            scc = []\n            while True:\n                node = stack.pop()\n                on_stack[node] = False\n                scc.append(node)\n                if node == u:\n                    break\n            sccs.append(set(scc))\n\n    for i in range(num_states):\n        if disc[i] == -1:\n            tarjan_dfs(i)\n\n    # --- 3. Identify Terminal SCCs (Attractors) ---\n    attractors = []\n    for scc in sccs:\n        is_terminal = True\n        for u in scc:\n            for v in adj[u]:\n                if v not in scc:\n                    is_terminal = False\n                    break\n            if not is_terminal:\n                break\n        if is_terminal:\n            attractors.append(sorted(list(scc)))\n\n    # Sort attractors by their minimum state index\n    attractors.sort(key=lambda a: a[0])\n\n    # --- 4. Basin of Attraction Calculation ---\n    basin_sizes = []\n    for attractor in attractors:\n        queue = list(attractor)\n        visited = set(attractor)\n        head = 0\n        while head  len(queue):\n            u = queue[head]\n            head += 1\n            for p in rev_adj[u]:\n                if p not in visited:\n                    visited.add(p)\n                    queue.append(p)\n        basin_sizes.append(len(visited))\n\n    # --- 5. Format Output ---\n    num_attractors = len(attractors)\n    attractor_sizes = [len(a) for a in attractors]\n    \n    return [num_attractors, attractors, attractor_sizes, basin_sizes]\n\nsolve()\n\n```", "id": "4321637"}]}