{"hands_on_practices": [{"introduction": "蛋白质相互作用网络并非直接观测所得，而是从实验数据中推断出来的。本练习 [@problem_id:1460618] 深入探讨了不同的计算模型，特别是辐条模型（spoke model）和矩阵模型（matrix model），如何解读亲和纯化-质谱（AP-MS）实验的原始数据。通过比较两种模型的结果，您将深入理解初始建模假设如何关键性地塑造最终的网络结构及其生物学解释。", "problem": "一个系统生物学研究团队正在研究一个模式生物的蛋白质相互作用网络。他们进行了一系列三次亲和纯化-质谱（AP-MS）实验来鉴定蛋白质复合物。在每次实验中，使用一个“诱饵”蛋白来下拉其结合伴侣，这些伴侣随后被鉴定为“猎物”蛋白。结果如下：\n\n- 实验 1：诱饵蛋白是 P1。鉴定出的猎物蛋白是 {P2, P3, P4}。\n- 实验 2：诱饵蛋白是 P2。鉴定出的猎物蛋白是 {P1, P4, P5}。\n- 实验 3：诱饵蛋白是 P5。鉴定出的猎物蛋白是 {P2, P6}。\n\n为了从这些数据中构建蛋白质-蛋白质相互作用（PPI）网络，该团队考虑了两种不同的推断模型：轮辐模型和矩阵模型。\n\n- **轮辐模型**：在每次实验中，只推断诱饵蛋白与每个猎物蛋白之间的相互作用。猎物蛋白之间不推断相互作用。\n- **矩阵模型**：在每次实验中，假设所有鉴定出的蛋白（诱饵蛋白及其所有猎物蛋白）形成一个完全连接的复合物（一个集团）。因此，在该集合内每对可能的蛋白之间都推断出存在相互作用。\n\n综合所有三次实验的数据，计算每种模型将推断出的独特蛋白质-蛋白质相互作用的总数。令 $N_{spoke}$ 为轮辐模型推断出的独特相互作用总数，令 $N_{matrix}$ 为矩阵模型推断出的独特相互作用总数。\n\n以一个包含两个元素的行矩阵形式给出你的答案，顺序为 $N_{spoke}$，然后是 $N_{matrix}$。", "solution": "我们将蛋白质-蛋白质相互作用解释为无向对。对于每次实验，我们根据指定的模型形成推断出的相互作用集合，然后取所有实验的并集来计算独特的相互作用数量。\n\n轮辐模型：\n实验 1（诱饵 $\\mathrm{P1}$，猎物 $\\{\\mathrm{P2},\\mathrm{P3},\\mathrm{P4}\\}$）产生\n$$\nE_{1}^{s}=\\{(\\mathrm{P1},\\mathrm{P2}),(\\mathrm{P1},\\mathrm{P3}),(\\mathrm{P1},\\mathrm{P4})\\}.\n$$\n实验 2（诱饵 $\\mathrm{P2}$，猎物 $\\{\\mathrm{P1},\\mathrm{P4},\\mathrm{P5}\\}$）产生\n$$\nE_{2}^{s}=\\{(\\mathrm{P1},\\mathrm{P2}),(\\mathrm{P2},\\mathrm{P4}),(\\mathrm{P2},\\mathrm{P5})\\}.\n$$\n实验 3（诱饵 $\\mathrm{P5}$，猎物 $\\{\\mathrm{P2},\\mathrm{P6}\\}$）产生\n$$\nE_{3}^{s}=\\{(\\mathrm{P2},\\mathrm{P5}),(\\mathrm{P5},\\mathrm{P6})\\}.\n$$\n独特对的并集是\n$$\nE^{s}=E_{1}^{s}\\cup E_{2}^{s}\\cup E_{3}^{s}=\\{(\\mathrm{P1},\\mathrm{P2}),(\\mathrm{P1},\\mathrm{P3}),(\\mathrm{P1},\\mathrm{P4}),(\\mathrm{P2},\\mathrm{P4}),(\\mathrm{P2},\\mathrm{P5}),(\\mathrm{P5},\\mathrm{P6})\\},\n$$\n所以\n$$\nN_{\\text{spoke}}=|E^{s}|=6.\n$$\n\n矩阵模型：\n对于每次实验，所有鉴定出的蛋白质形成一个集团。令鉴定出的集合为\n$$\nS_{1}=\\{\\mathrm{P1},\\mathrm{P2},\\mathrm{P3},\\mathrm{P4}\\},\\quad S_{2}=\\{\\mathrm{P1},\\mathrm{P2},\\mathrm{P4},\\mathrm{P5}\\},\\quad S_{3}=\\{\\mathrm{P2},\\mathrm{P5},\\mathrm{P6}\\}.\n$$\n它们的集团边是\n$$\nE_{1}^{m}=\\{(\\mathrm{P1},\\mathrm{P2}),(\\mathrm{P1},\\mathrm{P3}),(\\mathrm{P1},\\mathrm{P4}),(\\mathrm{P2},\\mathrm{P3}),(\\mathrm{P2},\\mathrm{P4}),(\\mathrm{P3},\\mathrm{P4})\\},\n$$\n$$\nE_{2}^{m}=\\{(\\mathrm{P1},\\mathrm{P2}),(\\mathrm{P1},\\mathrm{P4}),(\\mathrm{P1},\\mathrm{P5}),(\\mathrm{P2},\\mathrm{P4}),(\\mathrm{P2},\\mathrm{P5}),(\\mathrm{P4},\\mathrm{P5})\\},\n$$\n$$\nE_{3}^{m}=\\{(\\mathrm{P2},\\mathrm{P5}),(\\mathrm{P2},\\mathrm{P6}),(\\mathrm{P5},\\mathrm{P6})\\}.\n$$\n取并集，\n$$\nE^{m}=E_{1}^{m}\\cup E_{2}^{m}\\cup E_{3}^{m}=\\{(\\mathrm{P1},\\mathrm{P2}),(\\mathrm{P1},\\mathrm{P3}),(\\mathrm{P1},\\mathrm{P4}),(\\mathrm{P1},\\mathrm{P5}),(\\mathrm{P2},\\mathrm{P3}),(\\mathrm{P2},\\mathrm{P4}),(\\mathrm{P2},\\mathrm{P5}),(\\mathrm{P2},\\mathrm{P6}),(\\mathrm{P3},\\mathrm{P4}),(\\mathrm{P4},\\mathrm{P5}),(\\mathrm{P5},\\mathrm{P6})\\},\n$$\n所以\n$$\nN_{\\text{matrix}}=|E^{m}|=11.\n$$\n\n因此，总数是 $N_{\\text{spoke}}=6$ 和 $N_{\\text{matrix}}=11$。", "answer": "$$\\boxed{\\begin{pmatrix}6  11\\end{pmatrix}}$$", "id": "1460618"}, {"introduction": "网络中的并非所有蛋白质都同等重要；有些蛋白质扮演着关键的枢纽或瓶颈角色。本练习 [@problem_id:4298718] 介绍了介数中心性（betweenness centrality），这是一个用于识别那些位于许多最短路径上、从而连接不同功能模块的蛋白质的关键指标。通过为一个小型的加权网络手动计算此度量，您将巩固对网络拓扑及其与信息流关系的理解。", "problem": "考虑一个蛋白质-蛋白质相互作用网络 (PPIN)，它被定义为一个无向加权图，其中蛋白质是节点，相互作用是边，边的正权重代表有效路径成本，与相互作用亲和力成反比（权重越低表示亲和力越高）。设该网络有节点 $A$、$B$、$C$、$D$、$E$ 和 $F$。无向加权边的集合为\n$\\{(A,B,1), (A,C,1), (B,C,1), (C,D,1), (D,E,1), (D,F,1), (E,F,1), (A,D,2), (B,D,2), (C,E,2)\\}$，\n其中每个元组表示 $(\\text{蛋白质}_1,\\ \\text{蛋白质}_2,\\ \\text{权重})$，且所有权重均为严格正数。最短路径根据路径上的权重之和来定义。\n\n使用网络科学中标准的、非归一化的介数中心性定义，计算蛋白质 $C$ 的介数中心性，计算时考虑不以 $C$ 为端点的不同蛋白质无序对之间的最短路径。此外，根据最短路径结构的第一性原理，解释移除蛋白质 $C$ 如何影响其余蛋白质之间沿最短路径的流动（即测地线路径的冗余度和路由）。\n\n仅需以一个无单位的最简分数形式报告蛋白质 $C$ 的介数中心性。无需四舍五入。", "solution": "该问题经评估有效。它具有网络理论的科学依据，定义完整一致，问题阐述清晰，并且陈述客观。可以开始求解过程。\n\n任务有两部分：首先，计算蛋白质 $C$ 的非归一化介数中心性，记为 $B_C$；其次，解释移除蛋白质 $C$ 对网络内最短路径的结构性影响。\n\n**第一部分：介数中心性的计算**\n\n一个节点 $v$ 的介数中心性 $B(v)$ 定义为所有节点对之间通过 $v$ 的最短路径所占比例的总和。对于无向图，标准公式为：\n$$\nB(v) = \\sum_{s \\neq v \\neq t} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}\n$$\n其中，求和遍及网络中所有不包含 $v$ 的不同节点的无序对 $\\{s, t\\}$。这里，$\\sigma_{st}$ 是节点 $s$ 和节点 $t$ 之间最短路径（测地线）的总数，而 $\\sigma_{st}(v)$ 是这些最短路径中通过节点 $v$ 的数量。\n\n节点集合为 $V = \\{A, B, C, D, E, F\\}$。我们必须通过考虑集合 $V \\setminus \\{C\\} = \\{A, B, D, E, F\\}$ 中所有节点的无序对来计算 $B_C$。这样的节点对数量为 $\\binom{5}{2} = 10$。让我们分析每一对节点的最短路径。\n\n网络边和权重如下：\n$w(A,B) = 1$, $w(A,C) = 1$, $w(B,C) = 1$, $w(C,D) = 1$, $w(D,E) = 1$, $w(D,F) = 1$, $w(E,F) = 1$, $w(A,D) = 2$, $w(B,D) = 2$, $w(C,E) = 2$。\n\n1.  **节点对 $\\{A, B\\}$**：最短路径是权重为 $1$ 的直连边 $A-B$。路径 $A-C-B$ 的权重为 $1+1=2$。因此，$\\sigma_{AB} = 1$，且该路径不经过 $C$。对 $B_C$ 的贡献为 $\\frac{0}{1} = 0$。\n\n2.  **节点对 $\\{D, E\\}$**：最短路径是权重为 $1$ 的直连边 $D-E$。路径 $D-F-E$ 的权重为 $1+1=2$。路径 $D-C-E$ 的权重为 $1+2=3$。因此，$\\sigma_{DE} = 1$，且不经过 $C$。贡献为 $0$。\n\n3.  **节点对 $\\{D, F\\}$**：最短路径是权重为 $1$ 的直连边 $D-F$。路径 $D-E-F$ 的权重为 $1+1=2$。因此，$\\sigma_{DF} = 1$，且不经过 $C$。贡献为 $0$。\n\n4.  **节点对 $\\{E, F\\}$**：最短路径是权重为 $1$ 的直连边 $E-F$。路径 $E-D-F$ 的权重为 $1+1=2$。因此，$\\sigma_{EF} = 1$，且不经过 $C$。贡献为 $0$。\n\n5.  **节点对 $\\{A, D\\}$**：\n    *   路径 $A-C-D$：权重 $w(A,C) + w(C,D) = 1+1=2$。\n    *   路径 $A-D$：权重 $w(A,D) = 2$。\n    *   路径 $A-B-D$：权重 $w(A,B) + w(B,D) = 1+2=3$。\n    存在两条长度为 $2$ 的最短路径：$A-C-D$ 和 $A-D$。因此，$\\sigma_{AD} = 2$。其中一条路径 $A-C-D$ 经过 $C$，所以 $\\sigma_{AD}(C) = 1$。贡献为 $\\frac{1}{2}$。\n\n6.  **节点对 $\\{B, D\\}$**：根据与节点对 $\\{A,D\\}$ 的对称性（节点 $A$ 和 $B$ 相对于网络其余部分的结构是等价的），我们发现两条长度为 $2$ 的最短路径：$B-C-D$ 和 $B-D$。因此，$\\sigma_{BD} = 2$，且 $\\sigma_{BD}(C) = 1$。贡献为 $\\frac{1}{2}$。\n\n7.  **节点对 $\\{A, E\\}$**：\n    *   路径 $A-D-E$：权重 $w(A,D) + w(D,E) = 2+1=3$。\n    *   路径 $A-C-D-E$：权重 $w(A,C) + w(C,D) + w(D,E) = 1+1+1=3$。\n    *   路径 $A-C-E$：权重 $w(A,C) + w(C,E) = 1+2=3$。\n    *   路径 $A-B-D-E$：权重 $1+2+1=4$。\n    存在三条长度为 $3$ 的最短路径。因此，$\\sigma_{AE} = 3$。其中两条，$A-C-D-E$ 和 $A-C-E$，经过 $C$。因此，$\\sigma_{AE}(C) = 2$。贡献为 $\\frac{2}{3}$。\n\n8.  **节点对 $\\{B, E\\}$**：根据与节点对 $\\{A,E\\}$ 的对称性，存在三条长度为 $3$ 的最短路径：$B-D-E$、$B-C-D-E$ 和 $B-C-E$。因此，$\\sigma_{BE} = 3$。其中两条经过 $C$，所以 $\\sigma_{BE}(C) = 2$。贡献为 $\\frac{2}{3}$。\n\n9.  **节点对 $\\{A, F\\}$**：\n    *   路径 $A-D-F$：权重 $w(A,D) + w(D,F) = 2+1=3$。\n    *   路径 $A-C-D-F$：权重 $w(A,C) + w(C,D) + w(D,F) = 1+1+1=3$。\n    *   路径 $A-C-E-F$：权重 $1+2+1=4$。\n    存在两条长度为 $3$ 的最短路径：$A-D-F$ 和 $A-C-D-F$。因此，$\\sigma_{AF} = 2$。一条路径经过 $C$，所以 $\\sigma_{AF}(C) = 1$。贡献为 $\\frac{1}{2}$。\n\n10. **节点对 $\\{B, F\\}$**：根据与节点对 $\\{A,F\\}$ 的对称性，存在两条长度为 $3$ 的最短路径：$B-D-F$ 和 $B-C-D-F$。因此，$\\sigma_{BF} = 2$。一条路径经过 $C$，所以 $\\sigma_{BF}(C) = 1$。贡献为 $\\frac{1}{2}$。\n\n现在，我们将所有非零贡献相加来求得 $B_C$：\n$$\nB_C = \\sum_{\\{s,t\\} \\subset V \\setminus \\{C\\}} \\frac{\\sigma_{st}(C)}{\\sigma_{st}} = 0 + 0 + 0 + 0 + \\frac{1}{2} + \\frac{1}{2} + \\frac{2}{3} + \\frac{2}{3} + \\frac{1}{2} + \\frac{1}{2}\n$$\n$$\nB_C = 4 \\times \\frac{1}{2} + 2 \\times \\frac{2}{3} = 2 + \\frac{4}{3} = \\frac{6}{3} + \\frac{4}{3} = \\frac{10}{3}\n$$\n\n**第二部分：移除蛋白质 C 的影响**\n\n移除蛋白质 $C$ 会同时移除所有与其相连的边：$(A,C)$、$(B,C)$、$(C,D)$ 和 $(C,E)$。这从根本上改变了网络的拓扑结构以及信息或信号流动的可用路径。分析必须基于最短路径结构的第一性原理：任何给定节点对的最短路径集合是通过找到所有能达到最小可能边权重之和的路径来确定的。移除一个节点会消除任何包含该节点的路径，从而迫使在剩余的备选路径中重新评估最短路径。\n\n移除 $C$ 的主要影响在于连接包含节点 $\\{A,B\\}$ 的子网络与包含节点 $\\{D,E,F\\}$ 的子网络之间的路径。对于这些子网络内部的节点对（例如 $\\{A,B\\}$ 或 $\\{D,E\\}$），其最短路径不受影响，因为它们不涉及 $C$。让我们检查那些测地线路径曾由 $C$ 介导的节点对：\n\n*   **节点对 $\\{A,D\\}$ 和 $\\{B,D\\}$**：在移除前，最短路径长度为 $2$，并且有两条冗余路径（例如，$A-D$ 和 $A-C-D$）。移除 $C$ 后，路径 $A-C-D$ 和 $B-C-D$ 被消除。对于这两个节点对，都只剩下一条长度仍为 $2$ 的最短路径（分别为 $A-D$ 和 $B-D$）。其影响是，在 $\\{A,B\\}$ 和 $D$ 之间的最短连接中**完全丧失了冗余性**，而路径长度没有增加。\n\n*   **节点对 $\\{A,E\\}$、$\\{B,E\\}$、$\\{A,F\\}$ 和 $\\{B,F\\}$**：\n    *   对于 $\\{A,E\\}$，移除 $C$ 消除了三条最短路径中的两条（$A-C-D-E$ 和 $A-C-E$）。唯一剩下的最短路径是 $A-D-E$，其长度 $3$ 成为新的唯一测地线距离。\n    *   对于 $\\{A,F\\}$，移除 $C$ 消除了两条最短路径中的一条（$A-C-D-F$）。唯一剩下的最短路径是 $A-D-F$，其长度 $3$ 成为新的唯一测地线距离。\n    *   同样的逻辑对称地适用于节点对 $\\{B,E\\}$ 和 $\\{B,F\\}$。\n\n总之，移除蛋白质 $C$ 对最短路径路由产生以下后果：\n\n1.  **冗余性丧失**：对于每一对蛋白质 $(s,t)$，其中 $s \\in \\{A,B\\}$ 且 $t \\in \\{D,E,F\\}$，不同最短路径的数量 $\\sigma_{st}$ 严格减少。这表示网络鲁棒性的下降。之前分布在多条测地线路径上的流，现在集中到更少的路径上，或者在这些情况下，集中到单一路径上。\n\n2.  **其他节点的中心性增加**：流的重新路由使得其他节点和边变得更加关键。具体来说，从 $\\{A,B\\}$ 到 $\\{D,E,F\\}$ 的所有最短路径现在都必须经过节点 $D$ 并利用边 $(A,D)$ 和 $(B,D)$。节点 $D$ 的介数中心性以及边 $(A,D)$ 和 $(B,D)$ 的边介数将会显著增加。蛋白质 $D$ 成为网络这两个部分之间通信的关键瓶颈或关节点。\n\n3.  **路径距离未增加**：对于这个特定的网络配置，移除 $C$ 并未增加任何剩余节点对的最短路径*长度*。这是一个关键的观察：蛋白质 $C$ 提供了与最佳非 $C$ 路径完全一样高效（在路径权重方面）的替代路线。它充当了并行、同等最优路径的来源，而不是一个“捷径”。如果权重不同（例如，如果 $w(C,D)$ 小于 $1$），移除它可能会增加路径距离。\n\n从最短路径计算的第一性原理来看，移除节点 $C$ 会裁剪候选路径的集合。对于受影响的节点对，这种裁剪移除了属于最小权重路径集合的路径，从而减小了该集合的大小 ($\\sigma_{st}$)。由于至少有一条不涉及 $C$ 的最小权重路径仍然存在，因此最短路径距离本身没有改变。", "answer": "$$\\boxed{\\frac{10}{3}}$$", "id": "4298718"}, {"introduction": "PPI网络的一个强大应用是根据新候选基因与已知疾病基因的网络邻近性，对其进行优先排序。这个高级实践 [@problem_id:2423157] 将指导您实现带重启的随机游走（Random Walk with Restart, RWR）算法，这是一种量化“网络关联性”的复杂方法。通过应用RWR，您将学习如何将网络结构转化为功能性假设，以指导有针对性的生物学研究。", "problem": "一个蛋白质-蛋白质相互作用（PPI）网络被建模为一个包含 $n$ 个节点的有限、无向、简单图，由一个邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 表示，其中当且仅当蛋白质 $i$ 和 $j$ 之间存在相互作用时 $A_{ij} = 1$，否则 $A_{ij} = 0$。令 $S \\subset \\{0,1,\\dots,n-1\\}$ 为一个非空种子索引集合，对应于已知的癌症基因。定义种子分布向量 $s \\in \\mathbb{R}^n$ 为：如果 $i \\in S$，则 $s_i = \\frac{1}{|S|}$，否则 $s_i = 0$。对于度 $d_j = \\sum_{i=1}^n A_{ij}$ 为零的每个节点 $j$，在归一化之前设置 $A_{jj} \\leftarrow 1$（一个自环），以确保随机游走是良定义的。定义列随机转移矩阵 $W \\in \\mathbb{R}^{n \\times n}$ 如下\n$$\nW = A D^{-1},\n$$\n其中 $D \\in \\mathbb{R}^{n \\times n}$ 是一个对角矩阵，其对角元素 $D_{jj} = \\sum_{i=1}^n A_{ij}$ 是在自环调整后计算的，因此对于每一列 $j$，我们有 $\\sum_{i=1}^n W_{ij} = 1$。\n\n给定一个重启概率 $\\alpha \\in [0,1]$，此图上的带重启的随机游走（RWR）过程是一个序列 $\\{p^{(t)}\\}_{t=0}^{\\infty}$，其中 $p^{(0)} = s$ 且对于所有 $t \\geq 0$\n$$\np^{(t+1)} = (1-\\alpha) \\, W \\, p^{(t)} + \\alpha \\, s 。\n$$\n该过程迭代进行，直到在 $\\ell_1$ 范数下收敛，收敛容差为 $\\varepsilon > 0$（即直到 $\\lVert p^{(t+1)} - p^{(t)} \\rVert_1  \\varepsilon$），或者达到 $T_{\\max} \\in \\mathbb{N}$ 次迭代的硬上限。令收敛后的向量表示为 $p^\\star$（如果 $\\alpha = 1$，则 $p^\\star$ 精确等于 $s$）。任务是根据 $p^\\star_i$ 值对候选蛋白质（节点）进行降序排名，并排除 $S$ 中的所有种子索引。排名相同时必须按节点索引的升序来打破。给定一个整数 $k$（$1 \\le k \\le n - |S|$），每个测试用例所需的输出是根据上述排名规则得出的前 $k$ 个非种子节点的索引列表。\n\n您的程序必须精确实现上述数学原理，并将其应用于以下测试套件。所有节点都由从 0 开始的整数索引。每个测试指定了 $(A, S, \\alpha, \\varepsilon, T_{\\max}, k)$。\n\n测试 A（一般连通情况）：\n- 邻接矩阵 $A^{(\\mathrm{A})} \\in \\{0,1\\}^{6 \\times 6}$:\n$$\nA^{(\\mathrm{A})} =\n\\begin{bmatrix}\n0  1  0  0  0  0 \\\\\n1  0  1  0  0  1 \\\\\n0  1  0  1  0  0 \\\\\n0  0  1  0  1  0 \\\\\n0  0  0  1  0  1 \\\\\n0  1  0  0  1  0\n\\end{bmatrix}\n$$\n- 种子节点 $S^{(\\mathrm{A})} = \\{0,2\\}$。\n- 重启概率 $\\alpha^{(\\mathrm{A})} = 0.5$。\n- 容差 $\\varepsilon^{(\\mathrm{A})} = 10^{-10}$。\n- 最大迭代次数 $T_{\\max}^{(\\mathrm{A})} = 10000$。\n- 顶部数量 $k^{(\\mathrm{A})} = 3$。\n\n测试 B（用于测试隔离处理的非连通网络）：\n- 邻接矩阵 $A^{(\\mathrm{B})} \\in \\{0,1\\}^{6 \\times 6}$:\n$$\nA^{(\\mathrm{B})} =\n\\begin{bmatrix}\n0  1  1  0  0  0 \\\\\n1  0  1  0  0  0 \\\\\n1  1  0  0  0  0 \\\\\n0  0  0  0  1  0 \\\\\n0  0  0  1  0  1 \\\\\n0  0  0  0  1  0\n\\end{bmatrix}\n$$\n- 种子节点 $S^{(\\mathrm{B})} = \\{0\\}$。\n- 重启概率 $\\alpha^{(\\mathrm{B})} = 0.7$。\n- 容差 $\\varepsilon^{(\\mathrm{B})} = 10^{-12}$。\n- 最大迭代次数 $T_{\\max}^{(\\mathrm{B})} = 10000$。\n- 顶部数量 $k^{(\\mathrm{B})} = 4$。\n\n测试 C（高重启概率，强调与种子节点的邻近性）：\n- 邻接矩阵 $A^{(\\mathrm{C})} \\in \\{0,1\\}^{5 \\times 5}$:\n$$\nA^{(\\mathrm{C})} =\n\\begin{bmatrix}\n0  1  1  1  0 \\\\\n1  0  0  0  0 \\\\\n1  0  0  0  0 \\\\\n1  0  0  0  1 \\\\\n0  0  0  1  0\n\\end{bmatrix}\n$$\n- 种子节点 $S^{(\\mathrm{C})} = \\{0\\}$。\n- 重启概率 $\\alpha^{(\\mathrm{C})} = 0.95$。\n- 容差 $\\varepsilon^{(\\mathrm{C})} = 10^{-12}$。\n- 最大迭代次数 $T_{\\max}^{(\\mathrm{C})} = 10000$。\n- 顶部数量 $k^{(\\mathrm{C})} = 3$。\n\n测试 D（边界情况 $\\alpha = 1$）：\n- 邻接矩阵 $A^{(\\mathrm{D})} \\in \\{0,1\\}^{4 \\times 4}$:\n$$\nA^{(\\mathrm{D})} =\n\\begin{bmatrix}\n0  1  0  0 \\\\\n1  0  1  0 \\\\\n0  1  0  1 \\\\\n0  0  1  0\n\\end{bmatrix}\n$$\n- 种子节点 $S^{(\\mathrm{D})} = \\{1,2\\}$。\n- 重启概率 $\\alpha^{(\\mathrm{D})} = 1$。\n- 容差 $\\varepsilon^{(\\mathrm{D})} = 10^{-12}$。\n- 最大迭代次数 $T_{\\max}^{(\\mathrm{D})} = 10000$。\n- 顶部数量 $k^{(\\mathrm{D})} = 2$。\n\n对于每个测试，根据上述定义计算 $p^\\star$，并返回按 $p^\\star_i$ 降序排列（索引升序打破平局）的前 $k$ 个非种子节点的索引。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表（例如，$[\\,\\text{resultA},\\text{resultB},\\text{resultC},\\text{resultD}\\,]$）。在此问题中，每个结果都是一个包含 $k$ 个整数的列表，因此最终输出必须是 $[[i_{1},\\dots,i_{k}], [j_{1},\\dots,j_{k}], [\\dots], [\\dots]]$ 形式的单行，其中所有条目都是整数，并且列表的顺序与测试 A、B、C、D 的顺序一致。", "solution": "问题陈述已经过验证，被认为是科学上合理、定义明确且完整的。它展示了带重启的随机游走（RWR）算法在网络中进行节点优先级排序的标准应用，这是计算生物学中的一项常见任务。我们将采用严谨的、分步的解法。\n\n目标是在蛋白质-蛋白质相互作用（PPI）网络中，识别并排序那些最有可能与一组给定的种子蛋白质相关的非种子蛋白质，这些种子蛋白质已知与特定病理（如癌症）有关。该排名基于一个随机游走者的稳态概率分布，该游走者在网络中探索，并以恒定的概率返回到某个种子节点。此方法量化了网络环境中的一种邻近性或相关性。\n\n该算法分三个主要阶段进行：网络预处理、RWR 概率的迭代计算以及结果排名。\n\n**1. 网络预处理和初始化**\n\n首先，我们必须根据给定的输入构建必要的数学对象。每个测试用例的输入是一个邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$、一个种子索引集合 $S$、一个重启概率 $\\alpha \\in [0,1]$、一个收敛容差 $\\varepsilon > 0$、一个最大迭代次数 $T_{\\max}$，以及要报告的顶部候选数量 $k$。\n\n**1.1. 邻接矩阵的修改**\n随机游走在没有出边（孤立节点）的节点上是未定义的。问题指定了一个标准程序来处理这种情况：对于任何度 $d_j = \\sum_{i=0}^{n-1} A_{ij} = 0$ 的节点 $j$，我们通过设置 $A_{jj} \\leftarrow 1$ 来引入一个自环。这确保了每个节点至少有一条出边，使得度矩阵可逆，并且随机游走在任何地方都是良定义的。我们将可能被修改的邻接矩阵表示为 $A'$。\n\n**1.2. 转移矩阵 $W$ 的构建**\n随机游走者以均等概率从一个节点移动到其邻居之一。这通过列随机转移矩阵 $W$ 来形式化。我们首先计算度矩阵 $D'$，它是一个对角矩阵，其中条目 $D'_{jj}$ 是从 $A'$ 计算出的节点 $j$ 的度：\n$$\nD'_{jj} = \\sum_{i=0}^{n-1} A'_{ij}\n$$\n然后通过对 $A'$ 的列进行归一化得到转移矩阵 $W \\in \\mathbb{R}^{n \\times n}$：\n$$\nW = A' (D')^{-1}\n$$\n这等价于将每个元素 $W_{ij}$ 设置为：\n$$\nW_{ij} = \\frac{A'_{ij}}{D'_{jj}} = \\frac{A'_{ij}}{\\sum_{l=0}^{n-1} A'_{lj}}\n$$\n根据构造，$W$ 的每一列之和为 1，即对于所有 $j \\in \\{0, \\dots, n-1\\}$ 都有 $\\sum_{i=0}^{n-1} W_{ij} = 1$，这正确地表示了当前位于节点 $j$ 的游走者下一步的概率分布。\n\n**1.3. 概率向量的初始化**\nRWR 过程追踪图上节点的概率分布，该分布由向量 $p^{(t)} \\in \\mathbb{R}^n$ 表示，其中 $p_i^{(t)}$ 是在迭代步骤 $t$ 时在节点 $i$ 找到游走者的概率。该过程从种子节点开始。初始分布 $p^{(0)}$ 被定义为在种子集合 $S$ 上的均匀分布。这由种子分布向量 $s \\in \\mathbb{R}^n$ 捕获：\n$$\ns_i =\n\\begin{cases}\n\\frac{1}{|S|}  \\text{if } i \\in S \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n我们通过设置 $p^{(0)} = s$ 来初始化该过程。\n\n**2. 带重启的随机游走迭代**\n\n该算法的核心是迭代更新规则。在每一步 $t$，游走者可以以 $1-\\alpha$ 的概率根据转移矩阵 $W$ 移动到一个相邻节点，或者以 $\\alpha$ 的概率“重启”，即跳回到其中一个种子节点（根据分布 $s$）。这由以下递推关系捕获：\n$$\np^{(t+1)} = (1-\\alpha) \\, W \\, p^{(t)} + \\alpha \\, s\n$$\n此迭代一直执行，直到满足终止条件：\n1.  **收敛性：** 概率向量的变化变得可以忽略不计。我们使用 $\\ell_1$ 范数来衡量这一点：$\\lVert p^{(t+1)} - p^{(t)} \\rVert_1 = \\sum_{i=0}^{n-1} |p^{(t+1)}_i - p^{(t)}_i|  \\varepsilon$。\n2.  **最大迭代次数：** 迭代次数达到预定义的上限 $T_{\\max}$。\n\n最终向量，表示为 $p^\\star$，是收敛后的概率分布。该向量表示在每个节点上找到游走者的稳态概率。较高的概率 $p^\\star_i$ 表明节点 $i$ 与初始种子集合 $S$ 的“连接性”或“相关性”更强。\n\n当 $\\alpha = 1$ 时会出现一个特殊情况。更新规则简化为 $p^{(t+1)} = s$。在这种情况下，游走者总是重启，因此分布永远不会偏离初始种子分布。因此，$p^\\star = s$，无需任何迭代。\n\n**3. 候选蛋白质的排名和选择**\n\n一旦计算出稳态概率向量 $p^\\star$，我们就用它来对潜在的候选基因进行排名。候选者是所有不在原始种子集合 $S$ 中的节点。排名标准是：\n1.  **主排序键：** 分数 $p^\\star_i$，降序排列。\n2.  **次排序键（用于打破平局）：** 节点索引 $i$，升序排列。\n\n根据这些规则对所有非种子节点进行排序后，我们从此排序列表中选择前 $k$ 个节点。每个测试用例的最终结果是这 $k$ 个节点索引的列表。\n\n实现将为每个提供的测试用例精确地遵循这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_rwr_case(A_list, S_list, alpha, epsilon, T_max, k):\n    \"\"\"\n    Executes the Random Walk with Restart (RWR) algorithm for a single test case.\n\n    Args:\n        A_list (list of lists): The adjacency matrix as a list of lists.\n        S_list (list): The list of seed node indices.\n        alpha (float): The restart probability.\n        epsilon (float): The convergence tolerance.\n        T_max (int): The maximum number of iterations.\n        k (int): The number of top non-seed nodes to return.\n\n    Returns:\n        list: A list of the top-k non-seed node indices.\n    \"\"\"\n    A = np.array(A_list, dtype=np.float64)\n    n = A.shape[0]\n    S = set(S_list)\n\n    # Step 1.1: Handle isolated nodes by adding self-loops.\n    col_sums = np.sum(A, axis=0)\n    isolated_nodes = np.where(col_sums == 0)[0]\n    if isolated_nodes.size > 0:\n        A[isolated_nodes, isolated_nodes] = 1.0\n\n    # Step 1.2: Construct the column-stochastic transition matrix W.\n    D_diag = np.sum(A, axis=0)\n    # Using broadcasting for efficient column-wise division: W_ij = A_ij / D_jj\n    W = A / D_diag\n\n    # Step 1.3: Initialize seed vector s and probability vector p.\n    s = np.zeros(n, dtype=np.float64)\n    if S:\n        s[list(S)] = 1.0 / len(S)\n    \n    p_star = np.zeros(n, dtype=np.float64)\n\n    # Step 2: The RWR Iteration\n    # Handle the boundary case alpha = 1\n    if alpha == 1.0:\n        p_star = s\n    else:\n        p_current = s.copy()\n        for _ in range(T_max):\n            p_next = (1.0 - alpha) * (W @ p_current) + alpha * s\n            \n            # Check for convergence using the L1 norm\n            l1_norm = np.sum(np.abs(p_next - p_current))\n            \n            p_current = p_next\n            \n            if l1_norm  epsilon:\n                break\n        p_star = p_current\n\n    # Step 3: Ranking and Selection\n    # Identify non-seed candidate nodes\n    candidate_indices = [i for i in range(n) if i not in S]\n    \n    # Create a list of tuples (score, index) for sorting\n    candidates_with_scores = [(p_star[i], i) for i in candidate_indices]\n    \n    # Sort candidates: primary key is score (descending), secondary key is index (ascending)\n    # The key lambda x: (-x[0], x[1]) achieves this.\n    candidates_with_scores.sort(key=lambda x: (-x[0], x[1]))\n    \n    # Select the top-k indices from the sorted list\n    top_k_indices = [index for score, index in candidates_with_scores[:k]]\n    \n    return top_k_indices\n\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results in the required format.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": [\n                [0, 1, 0, 0, 0, 0],\n                [1, 0, 1, 0, 0, 1],\n                [0, 1, 0, 1, 0, 0],\n                [0, 0, 1, 0, 1, 0],\n                [0, 0, 0, 1, 0, 1],\n                [0, 1, 0, 0, 1, 0]\n            ],\n            \"S\": {0, 2},\n            \"alpha\": 0.5,\n            \"epsilon\": 1e-10,\n            \"T_max\": 10000,\n            \"k\": 3\n        },\n        {\n            \"A\": [\n                [0, 1, 1, 0, 0, 0],\n                [1, 0, 1, 0, 0, 0],\n                [1, 1, 0, 0, 0, 0],\n                [0, 0, 0, 0, 1, 0],\n                [0, 0, 0, 1, 0, 1],\n                [0, 0, 0, 0, 1, 0]\n            ],\n            \"S\": {0},\n            \"alpha\": 0.7,\n            \"epsilon\": 1e-12,\n            \"T_max\": 10000,\n            \"k\": 4\n        },\n        {\n            \"A\": [\n                [0, 1, 1, 1, 0],\n                [1, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0],\n                [1, 0, 0, 0, 1],\n                [0, 0, 0, 1, 0]\n            ],\n            \"S\": {0},\n            \"alpha\": 0.95,\n            \"epsilon\": 1e-12,\n            \"T_max\": 10000,\n            \"k\": 3\n        },\n        {\n            \"A\": [\n                [0, 1, 0, 0],\n                [1, 0, 1, 0],\n                [0, 1, 0, 1],\n                [0, 0, 1, 0]\n            ],\n            \"S\": {1, 2},\n            \"alpha\": 1.0,\n            \"epsilon\": 1e-12,\n            \"T_max\": 10000,\n            \"k\": 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_rwr_case(\n            case[\"A\"],\n            list(case[\"S\"]),\n            case[\"alpha\"],\n            case[\"epsilon\"],\n            case[\"T_max\"],\n            case[\"k\"]\n        )\n        results.append(result)\n\n    # Format the final output string as a list of lists of integers.\n    # e.g., [[1,2],[3,4]]\n    result_strings = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2423157"}]}