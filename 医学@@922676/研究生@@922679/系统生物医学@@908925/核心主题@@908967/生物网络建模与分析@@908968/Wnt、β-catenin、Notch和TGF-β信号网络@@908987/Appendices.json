{"hands_on_practices": [{"introduction": "系统生物学的一个核心技能是将复杂的生物相互作用转化为精确的数学模型。本练习将指导您基于质量作用动力学和物质守恒定律等基本原理，为 Wnt 和 TGF-β 信号通路之间通过蛋白复合物形成的串扰建立一个分析模型。通过推导其稳态解，您将深入理解如何将生物学假设与定量预测联系起来。[@problem_id:4399624]", "problem": "在上皮细胞中，Wingless/Integrated (Wnt) 和转化生长因子-β (TGF-$\\beta$) 信号通过由 $\\beta$-catenin 和 Smad 蛋白形成的核转录复合物发生串扰。考虑以下从第一性原理构建的粗粒化、充分混合的核模型：质量作用动力学、守恒定律以及用于生成和降解的常微分方程 (ODE) 平衡。\n\n假设核内可用的 $\\beta$-catenin 池（表示为 $X_{\\mathrm{tot}}(t)$）在所关注的时间尺度上根据一个具有 Wnt 依赖的有效生成和一级损失的 ODE 进行周转，\n$$\n\\frac{d X_{\\mathrm{tot}}}{d t} \\;=\\; p_{W}(L_{W}) \\;-\\; \\delta \\, X_{\\mathrm{tot}} ,\n$$\n其中 $L_{W}$ 是 Wnt 配体水平，$\\delta$ 是 $\\beta$-catenin 部分（游离或复合的）的有效一级周转率，而 Wnt 依赖的生成被建模为在基础速率上的饱和增长，\n$$\np_{W}(L_{W}) \\;=\\; s_{B} \\left( 1 \\;+\\; \\lambda_{W} \\,\\frac{L_{W}}{K_{W} + L_{W}} \\right) .\n$$\n假设 TGF-$\\beta$ 配体 $L_{T}$ 通过饱和激活决定了核内 Smad 可用量 $S_{\\mathrm{tot}}$，\n$$\nS_{\\mathrm{tot}}(L_{T}) \\;=\\; S_{0} \\,\\frac{L_{T}}{K_{T} + L_{T}} .\n$$\n在细胞核内，$\\beta$-catenin 和 Smad 通过反应 $X_{\\mathrm{free}} + S_{\\mathrm{free}} \\rightleftharpoons C$ 可逆地结合形成转录复合物 $C$，该反应处于快速平衡状态，解离常数为 $K_{d}$，并遵循质量作用关系\n$$\nK_{d} \\;=\\; \\frac{X_{\\mathrm{free}} \\, S_{\\mathrm{free}}}{C} .\n$$\n根据守恒定律，我们有 $X_{\\mathrm{tot}} = X_{\\mathrm{free}} + C$ 和 $S_{\\mathrm{tot}} = S_{\\mathrm{free}} + C$。\n\n从这些定义和定律出发，并假设在结合的时间尺度上 $X_{\\mathrm{tot}}$ 处于稳态，推导出稳态核复合物浓度 $C^{\\ast}$ 作为 $L_{W}$、$L_{T}$ 及模型参数 $s_{B}$、$\\lambda_{W}$、$K_{W}$、$\\delta$、$S_{0}$、$K_{T}$ 和 $K_{d}$ 的函数的闭式解析表达式。将您的最终答案表示为单一的简化符号表达式。不需要进行数值计算或四舍五入。", "solution": "用户希望找到核转录复合物的稳态浓度 $C^{\\ast}$，作为外部配体浓度 $L_W$ 和 $L_T$ 的函数。推导将分两个主要阶段进行。首先，我们将确定组成蛋白 $\\beta$-catenin （$X_{\\mathrm{tot}}$）和 Smad （$S_{\\mathrm{tot}}$）的稳态总浓度，作为它们各自配体信号的函数。其次，我们将解决可逆结合平衡问题，以根据这些总蛋白量求出复合物 $C$ 的浓度。\n\n第一步：确定稳态总蛋白浓度。\n\n核内总 $\\beta$-catenin 浓度 $X_{\\mathrm{tot}}$ 由以下常微分方程（ODE）决定：\n$$ \\frac{d X_{\\mathrm{tot}}}{d t} = p_{W}(L_{W}) - \\delta \\, X_{\\mathrm{tot}} $$\n问题要求的是稳态，这可以通过将时间导数设为零（$\\frac{d X_{\\mathrm{tot}}}{d t} = 0$）来找到。令 $X_{\\mathrm{tot}}^{\\ast}$ 表示该稳态浓度。\n$$ 0 = p_{W}(L_{W}) - \\delta \\, X_{\\mathrm{tot}}^{\\ast} $$\n$$ X_{\\mathrm{tot}}^{\\ast} = \\frac{p_{W}(L_{W})}{\\delta} $$\n生成速率 $p_{W}(L_{W})$ 由下式给出：\n$$ p_{W}(L_{W}) = s_{B} \\left( 1 + \\lambda_{W} \\frac{L_{W}}{K_{W} + L_{W}} \\right) $$\n将此式代入 $X_{\\mathrm{tot}}^{\\ast}$ 的表达式中：\n$$ X_{\\mathrm{tot}}^{\\ast}(L_W) = \\frac{s_{B}}{\\delta} \\left( 1 + \\lambda_{W} \\frac{L_{W}}{K_{W} + L_{W}} \\right) $$\n为了代数上的方便，该表达式可以写成一个单一的分数形式：\n$$ X_{\\mathrm{tot}}^{\\ast}(L_W) = \\frac{s_{B}}{\\delta} \\left( \\frac{K_{W} + L_{W} + \\lambda_{W}L_{W}}{K_{W} + L_{W}} \\right) = \\frac{s_{B} \\left( K_{W} + (1+\\lambda_{W})L_{W} \\right)}{\\delta (K_{W} + L_{W})} $$\n核内总 Smad 可用量 $S_{\\mathrm{tot}}$ 直接作为配体 $L_T$ 的函数给出：\n$$ S_{\\mathrm{tot}}(L_{T}) = S_{0} \\frac{L_{T}}{K_{T} + L_{T}} $$\n由于该表达式不涉及微分方程，它代表了由 $L_T$ 决定的 Smad 的准稳态可用量。\n\n第二步：解决结合平衡问题。\n\n复合物 $C$ 由游离的 $\\beta$-catenin （$X_{\\mathrm{free}}$）和游离的 Smad （$S_{\\mathrm{free}}$）通过可逆反应 $X_{\\mathrm{free}} + S_{\\mathrm{free}} \\rightleftharpoons C$ 形成。问题陈述该反应处于快速平衡状态，意味着结合和解离事件比总蛋白浓度的变化快得多。该平衡由解离常数 $K_d$ 表征：\n$$ K_{d} = \\frac{X_{\\mathrm{free}} \\, S_{\\mathrm{free}}}{C} $$\n在结合反应中总浓度是守恒的，从而得出守恒定律：\n$$ X_{\\mathrm{tot}}^{\\ast} = X_{\\mathrm{free}} + C $$\n$$ S_{\\mathrm{tot}} = S_{\\mathrm{free}} + C $$\n根据这些守恒定律，我们可以用总浓度和复合物浓度 $C$ 来表示游离浓度：\n$$ X_{\\mathrm{free}} = X_{\\mathrm{tot}}^{\\ast} - C $$\n$$ S_{\\mathrm{free}} = S_{\\mathrm{tot}} - C $$\n将这些代入 $K_d$ 的表达式中：\n$$ K_{d} = \\frac{(X_{\\mathrm{tot}}^{\\ast} - C)(S_{\\mathrm{tot}} - C)}{C} $$\n必须求解此方程以得到 $C$。令 $C^{\\ast}$ 为解此方程的稳态复合物浓度。为简化符号，我们暂时省略 $X_{\\mathrm{tot}}^{\\ast}$ 和 $C^{\\ast}$ 的上标星号。\n$$ K_{d} C = (X_{\\mathrm{tot}} - C)(S_{\\mathrm{tot}} - C) $$\n$$ K_{d} C = X_{\\mathrm{tot}}S_{\\mathrm{tot}} - X_{\\mathrm{tot}}C - S_{\\mathrm{tot}}C + C^2 $$\n整理成标准的二次方程形式 $aC^2 + bC + c = 0$：\n$$ C^2 - (X_{\\mathrm{tot}} + S_{\\mathrm{tot}} + K_{d})C + X_{\\mathrm{tot}}S_{\\mathrm{tot}} = 0 $$\n$C$ 的解由二次方程求根公式给出：\n$$ C = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n代入 $a=1$，$b = -(X_{\\mathrm{tot}} + S_{\\mathrm{tot}} + K_{d})$ 和 $c = X_{\\mathrm{tot}}S_{\\mathrm{tot}}$：\n$$ C = \\frac{(X_{\\mathrm{tot}} + S_{\\mathrm{tot}} + K_{d}) \\pm \\sqrt{(X_{\\mathrm{tot}} + S_{\\mathrm{tot}} + K_{d})^2 - 4 X_{\\mathrm{tot}}S_{\\mathrm{tot}}}}{2} $$\n我们必须选择具有物理意义的根。复合物的浓度 $C$ 不能超过其任何一个组分的总浓度，即 $C \\le X_{\\mathrm{tot}}$ 且 $C \\le S_{\\mathrm{tot}}$。\n\n我们来检验带有正号的解。平方根下的项是 $\\sqrt{(X_{\\mathrm{tot}} + S_{\\mathrm{tot}} + K_{d})^2 - 4 X_{\\mathrm{tot}}S_{\\mathrm{tot}}} = \\sqrt{(X_{\\mathrm{tot}}-S_{\\mathrm{tot}})^2 + 2K_d(X_{\\mathrm{tot}}+S_{\\mathrm{tot}}) + K_d^2}$。该项总是大于或等于 $|X_{\\mathrm{tot}}-S_{\\mathrm{tot}}|$。因此，带有正号的解给出 $C \\ge \\frac{1}{2}(X_{\\mathrm{tot}} + S_{\\mathrm{tot}} + K_{d} + |X_{\\mathrm{tot}}-S_{\\mathrm{tot}}|)$。如果 $X_{\\mathrm{tot}} \\ge S_{\\mathrm{tot}}$，则变为 $C \\ge \\frac{1}{2}(X_{\\mathrm{tot}} + S_{\\mathrm{tot}} + K_{d} + X_{\\mathrm{tot}}-S_{\\mathrm{tot}}) = X_{\\mathrm{tot}} + \\frac{K_d}{2}$。这违反了条件 $C \\le X_{\\mathrm{tot}}$。如果 $S_{\\mathrm{tot}} \\ge X_{\\mathrm{tot}}$，则变为 $C \\ge \\frac{1}{2}(X_{\\mathrm{tot}} + S_{\\mathrm{tot}} + K_{d} + S_{\\mathrm{tot}}-X_{\\mathrm{tot}}) = S_{\\mathrm{tot}} + \\frac{K_d}{2}$。这违反了条件 $C \\le S_{\\mathrm{tot}}$。因此，带有正号的解是不符合物理实际的。我们必须选择负号。\n\n因此，稳态复合物浓度 $C^{\\ast}$ 的物理上正确的解是：\n$$ C^{\\ast} = \\frac{1}{2} \\left[ (X_{\\mathrm{tot}}^{\\ast} + S_{\\mathrm{tot}} + K_{d}) - \\sqrt{(X_{\\mathrm{tot}}^{\\ast} + S_{\\mathrm{tot}} + K_{d})^2 - 4 X_{\\mathrm{tot}}^{\\ast}S_{\\mathrm{tot}}} \\right] $$\n最后，我们将 $X_{\\mathrm{tot}}^{\\ast}(L_W)$ 和 $S_{\\mathrm{tot}}(L_T)$ 的完整表达式代入，以获得作为单一符号表达式的最终答案。令 $X_{\\mathrm{tot}}^{\\ast} = \\frac{s_{B}}{\\delta} \\left( 1 + \\lambda_{W} \\frac{L_{W}}{K_{W} + L_{W}} \\right)$ 和 $S_{\\mathrm{tot}} = S_{0} \\frac{L_{T}}{K_{T} + L_{T}}$。因此，$C^{\\ast}$ 的最终表达式是通过将这些项代入二次方程的解得到的。", "answer": "$$ \\boxed{ \\frac{1}{2} \\left( \\left[ \\frac{s_{B}}{\\delta} \\left( 1 + \\lambda_{W} \\frac{L_{W}}{K_{W} + L_{W}} \\right) + S_{0} \\frac{L_{T}}{K_{T} + L_{T}} + K_{d} \\right] - \\sqrt{\\left[ \\frac{s_{B}}{\\delta} \\left( 1 + \\lambda_{W} \\frac{L_{W}}{K_{W} + L_{W}} \\right) + S_{0} \\frac{L_{T}}{K_{T} + L_{T}} + K_{d} \\right]^2 - 4 \\left( \\frac{s_{B}}{\\delta} \\left( 1 + \\lambda_{W} \\frac{L_{W}}{K_{W} + L_{W}} \\right) \\right) \\left( S_{0} \\frac{L_{T}}{K_{T} + L_{T}} \\right)} \\right) } $$", "id": "4399624"}, {"introduction": "许多生物过程并非处于静态平衡，而是表现出复杂的动态行为，例如振荡。本练习将带您探索 Notch 信号通路中的一个典型负反馈回路，即 Hes1 的表达调控，它被认为能产生周期性振荡。您将通过编写程序来数值求解一个经典的 Goodwin 振荡器模型，并分析其时间序列输出来判断系统是否表现出持续振荡，从而掌握研究细胞时间调控的关键计算方法。[@problem_id:4399622]", "problem": "考虑一个Notch通路转录反馈的最小动力学系统模型，该模型能够捕捉在Notch信号传导下，Hairy and Enhancer of Split 1 (Hes1)的振荡。该模型平衡了Notch胞内域（NICD）和转化生长因子-β（TGF-β）的转录激活作用与Hes1的自身抑制作用。假设遵循分子生物学中心法则（DNA到信使核糖核酸(mRNA)到蛋白质）以及生成和降解的质量作用动力学。令$M(t)$表示Hes1 mRNA，$P(t)$表示Hes1蛋白质，$R(t)$表示一个有效的抑制子复合物（例如，由蛋白质介导的启动子占据，从而减少转录），所有这些都使用任意浓度单位。时间$t$以分钟为单位。\n\n使用以下经过充分检验的建模选择：\n- 转录受NICD和TGF-β的乘性激活，并通过一个源自平衡结合的Hill函数被抑制子$R(t)$所抑制：转录速率与$\\nu \\big/ \\left(1 + R(t)^h\\right)$成正比，其中$\\nu = \\alpha_0 \\left(1 + \\sigma_N A_N\\right)\\left(1 + \\sigma_T A_T\\right)$，$\\alpha_0$是基础转录速率，$A_N$是无量纲的Notch激活水平，$A_T$是无量纲的TGF-β激活水平，$\\sigma_N$和$\\sigma_T$是比例系数，$h$是代表抑制协同性的Hill系数。所有速率常数均为非负。\n- 翻译和抑制子复合物的形成是线性的，各种物质的降解为一级反应。\n\n由此得到的Goodwin型系统为\n$$\n\\frac{dM}{dt} = \\frac{\\nu}{1 + R^h} - k_1 M,\\quad\n\\frac{dP}{dt} = k_s M - k_2 P,\\quad\n\\frac{dR}{dt} = k_p P - k_3 R,\n$$\n其中$k_1$、$k_2$、$k_3$是降解速率，单位为$\\text{min}^{-1}$；$k_s$和$k_p$是生成速率常数，单位为$\\text{min}^{-1}$；所有变量和参数均为非负。\n\n您的任务是编写一个完整的程序，对于下述测试套件中的每一组参数，从小的正初始条件开始对该系统进行积分，并判断系统在长时间范围内$P(t)$是否表现出持续振荡。如果在舍弃初始瞬态后，$P(t)$轨迹的末端部分包含至少$3$个不同的局部极大值，并且其振幅（该部分的最大值减去最小值）超过一个小的阈值，则该振荡应被归类为持续性的。如果这两个标准都满足，则为该测试用例返回布尔值True；否则返回False。\n\n在所有模拟中，除非另有说明，否则请使用以下常量：初始条件$M(0) = 0.1$、$P(0) = 0.1$、$R(0) = 0.1$，积分时域$T_{\\text{end}} = 1000$分钟，并在评估振荡时舍弃最初500分钟的瞬态。使用足够小的绝对容差和相对容差来解析动力学过程。速率必须以$\\text{min}^{-1}$为单位处理。\n\n测试套件参数集，每个参数集指定为一个元组$\\left(A_N, A_T, h, k_1, k_2, k_3, k_s, k_p, \\alpha_0, \\sigma_N, \\sigma_T\\right)$:\n- 情况1（理想振荡路径）：$\\left(1.0,\\, 0.5,\\, 8.0,\\, 0.02,\\, 0.02,\\, 0.02,\\, 0.4,\\, 0.4,\\, 1.0,\\, 1.0,\\, 0.5\\right)$。\n- 情况2（边界情况，低协同性）：$\\left(1.0,\\, 0.5,\\, 3.0,\\, 0.02,\\, 0.02,\\, 0.02,\\, 0.4,\\, 0.4,\\, 1.0,\\, 1.0,\\, 0.5\\right)$。\n- 情况3（边缘情况，快速降解）：$\\left(1.0,\\, 0.5,\\, 8.0,\\, 0.08,\\, 0.08,\\, 0.08,\\, 0.4,\\, 0.4,\\, 1.0,\\, 1.0,\\, 0.5\\right)$。\n- 情况4（强激活）：$\\left(2.0,\\, 1.0,\\, 8.0,\\, 0.02,\\, 0.02,\\, 0.02,\\, 0.4,\\, 0.4,\\, 1.0,\\, 1.0,\\, 0.5\\right)$。\n\n您的程序应生成单行输出，其中包含四个情况的结果，格式为方括号内的逗号分隔列表（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$），其中每个$\\text{result}_i$是一个布尔值，根据上述标准指示是否存在持续振荡。不应产生任何额外输出。", "solution": "用户提供的问题陈述已经过分析，并被认为是有效的。它在科学上基于生物化学动力学和系统生物学的原理，作为一个数值积分和分析任务，其提法是适定的，并且足够完整和客观，可以得到唯一的解。该模型是一个标准的Goodwin型振荡器，是遗传负反馈回路的典型表示。参数和初始条件都已明确指定。唯一的小歧义是振荡振幅的“小阈值”的定义。在本分析中，选择了一个物理上合理的阈值0.1浓度单位，以区分持续振荡与数值噪声或向不动点的快速衰减。\n\n该问题要求对一个包含三个耦合非线性常微分方程组（ODEs）的系统进行数值积分，该系统模拟了Hes1 mRNA $M(t)$、Hes1蛋白质 $P(t)$ 和一个有效抑制子复合物 $R(t)$ 的动力学。该系统由以下方程给出：\n$$\n\\frac{dM}{dt} = \\frac{\\nu}{1 + R^h} - k_1 M\n$$\n$$\n\\frac{dP}{dt} = k_s M - k_2 P\n$$\n$$\n\\frac{dR}{dt} = k_p P - k_3 R\n$$\n状态变量$M$、$P$和$R$代表浓度，是时间$t$的函数。参数如下：$k_1$、$k_2$、$k_3$是一级降解速率常数；$k_s$和$k_p$是生成速率常数；$h$是抑制作用的Hill系数。项$\\nu$代表受外部信号调控的最大转录速率，其定义为：\n$$\n\\nu = \\alpha_0 (1 + \\sigma_N A_N)(1 + \\sigma_T A_T)\n$$\n其中$\\alpha_0$是基础转录速率，$A_N$和$A_T$分别是Notch和TGF-$\\beta$信号的无量纲激活水平，$\\sigma_N$和$\\sigma_T$是相应的比例系数。\n\n求解方法包括针对每个给定的参数集执行以下步骤：\n1.  **参数设置**：分配来自测试用例元组$\\left(A_N, A_T, h, k_1, k_2, k_3, k_s, k_p, \\alpha_0, \\sigma_N, \\sigma_T\\right)$的参数，并计算复合参数$\\nu$。\n\n2.  **数值积分**：在时间区间$t \\in [0, 1000]$分钟内，从初始条件$M(0) = 0.1$、$P(0) = 0.1$和$R(0) = 0.1$开始，对常微分方程组进行数值积分。使用高质量的自适应步长求解器，特别是SciPy库中的`scipy.integrate.solve_ivp`。请求密集输出以获得状态变量的高分辨率时间序列，这对于准确识别局部极值至关重要。使用高精度的相对和绝对容差（例如，$10^{-9}$）来确保数值解的准确性。\n\n3.  **舍弃瞬态**：根据问题规范，舍弃模拟的初始瞬态阶段。分析仅在$t \\in [500, 1000]$分钟的时间序列数据上进行。这确保了将行为分类为振荡或稳定是基于系统的长期渐近动力学，而不是其初始响应。\n\n4.  **振荡检测**：对后瞬态窗口（$t \\ge 500$）内的Hes1蛋白质$P(t)$的轨迹进行分析，依据两个特定标准来确定是否存在持续振荡。\n    *   **振幅标准**：振荡的振幅计算为分析窗口内$P(t)$的最大值与最小值之差。该振幅必须超过一个预定义的阈值，该阈值设定为0.1浓度单位。此标准确保观察到的波动是显著的，而不是稳定稳态周围的数值误差伪影。如果$\\left( \\max_{t \\ge 500} P(t) - \\min_{t \\ge 500} P(t) \\right) > 0.1$，则此条件满足。\n    *   **峰值计数标准**：计算分析窗口内$P(t)$轨迹中局部极大值（峰值）的数量。如果一个点$P(t_i)$严格大于其紧邻的两个点，即$P(t_{i-1})  P(t_i) > P(t_{i+1})$，则该点被视为局部极大值。问题要求至少有3个不同的局部极大值，才能将行为归类为持续振荡。这确保了系统正在经历多个周期，而不仅仅是在稳定下来之前表现出一次过冲。\n\n5.  **分类**：对于每个参数集，最终输出是一个布尔值。当且仅当振幅标准和峰值计数标准都满足时，结果为`True`。否则，为`False`。所有四个测试用例的结果被汇编成一个列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Integrates the Hes1 oscillator model and detects sustained oscillations\n    for a suite of test case parameters.\n    \"\"\"\n    \n    # Define common constants for the simulation\n    y0 = np.array([0.1, 0.1, 0.1])  # Initial conditions [M(0), P(0), R(0)]\n    t_span = [0, 1000]             # Integration time horizon in minutes\n    transient_time = 500           # Time to discard for transient behavior\n    amp_threshold = 0.1            # Amplitude threshold for oscillation\n    min_peaks = 3                  # Minimum number of peaks for sustained oscillation\n\n    # Test suite parameter sets:\n    # (A_N, A_T, h, k_1, k_2, k_3, k_s, k_p, alpha_0, sigma_N, sigma_T)\n    test_cases = [\n        # Case 1: happy path oscillatory\n        (1.0, 0.5, 8.0, 0.02, 0.02, 0.02, 0.4, 0.4, 1.0, 1.0, 0.5),\n        # Case 2: boundary, low cooperativity\n        (1.0, 0.5, 3.0, 0.02, 0.02, 0.02, 0.4, 0.4, 1.0, 1.0, 0.5),\n        # Case 3: edge case, fast degradation\n        (1.0, 0.5, 8.0, 0.08, 0.08, 0.08, 0.4, 0.4, 1.0, 1.0, 0.5),\n        # Case 4: strong activation\n        (2.0, 1.0, 8.0, 0.02, 0.02, 0.02, 0.4, 0.4, 1.0, 1.0, 0.5),\n    ]\n\n    def hes1_model(t, y, nu, h, k1, k2, k3, ks, kp):\n        \"\"\"\n        Defines the ODE system for the Hes1 oscillator.\n        y = [M, P, R]\n        \"\"\"\n        M, P, R = y\n        dM_dt = nu / (1 + R**h) - k1 * M\n        dP_dt = ks * M - k2 * P\n        dR_dt = kp * P - k3 * R\n        return [dM_dt, dP_dt, dR_dt]\n\n    results = []\n    \n    # Generate time points for evaluation to ensure dense output\n    t_eval = np.linspace(t_span[0], t_span[1], 2000)\n\n    for case in test_cases:\n        A_N, A_T, h, k1, k2, k3, ks, kp, alpha_0, sigma_N, sigma_T = case\n        \n        # Calculate the composite transcription rate nu\n        nu = alpha_0 * (1 + sigma_N * A_N) * (1 + sigma_T * A_T)\n        \n        # Package arguments for the ODE solver\n        args = (nu, h, k1, k2, k3, ks, kp)\n        \n        # Integrate the ODE system\n        sol = solve_ivp(\n            hes1_model, \n            t_span, \n            y0, \n            method='RK45', \n            t_eval=t_eval, \n            args=args,\n            rtol=1e-9, \n            atol=1e-9\n        )\n        \n        # Extract time and P(t) solution\n        t_sol = sol.t\n        P_sol = sol.y[1]\n        \n        # Find the index where the analysis window starts\n        transient_idx = np.searchsorted(t_sol, transient_time, side='left')\n        \n        # Get the post-transient part of the P trajectory\n        P_analysis = P_sol[transient_idx:]\n        \n        is_oscillatory = False\n        if P_analysis.size  2: # Need at least 3 points to find a peak\n            # 1. Amplitude criterion\n            amplitude = np.max(P_analysis) - np.min(P_analysis)\n            amplitude_criterion_met = amplitude  amp_threshold\n            \n            # 2. Peak count criterion\n            peak_count = 0\n            for i in range(1, len(P_analysis) - 1):\n                if P_analysis[i]  P_analysis[i-1] and P_analysis[i]  P_analysis[i+1]:\n                    peak_count += 1\n            peaks_criterion_met = peak_count = min_peaks\n            \n            # Both criteria must be met\n            if amplitude_criterion_met and peaks_criterion_met:\n                is_oscillatory = True\n        \n        results.append(is_oscillatory)\n\n    # Format and print the final output exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4399622"}, {"introduction": "将理论模型与实验数据相结合是系统生物医学的最终目标之一。本练习模拟了一个常见且强大的场景：利用下游靶基因的表达谱数据，反向推断上游信号通路（如 Wnt、Notch 和 TGF-β）的活性水平。您将从贝叶斯推断的第一性原理出发，推导并实现最大后验概率（MAP）估计器来解决这个“逆问题”，这对于从高通量数据中解读生物系统的内部状态至关重要。[@problem_id:4399635]", "problem": "要求您对三种信号通路进行数据驱动的通路活性推断：Wnt/β-catenin信号通路、Notch信号通路和转化生长因子β (TGF-β) 信号通路。在系统生物医学中，根据小信号近似和稳态假设，下游靶基因的转录响应通常被建模为通路活性的线性叠加。形式上，假设 $n$ 个靶基因的测量表达向量（表示为 $\\mathbf{y} \\in \\mathbb{R}^n$）由以下公式生成：\n$$\n\\mathbf{y} = \\mathbf{b} + \\mathbf{S}\\mathbf{a} + \\boldsymbol{\\varepsilon},\n$$\n其中 $\\mathbf{b} \\in \\mathbb{R}^n$ 是基线表达向量，$\\mathbf{S} \\in \\mathbb{R}^{n \\times p}$ 是一个已知的特征（敏感性）矩阵，编码了每条通路对每个基因的影响，$\\mathbf{a} \\in \\mathbb{R}^p$ 是 $p$ 条通路的未知通路活性向量，$\\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I}_n)$ 代表方差为 $\\sigma^2$ 的独立高斯测量噪声。假设我们有一个先验信念，即通路活性集中在 $0$ 附近，这被建模为一个方差为 $\\tau^2$ 的零均值高斯先验 $\\mathbf{a} \\sim \\mathcal{N}(\\mathbf{0}, \\tau^2 \\mathbf{I}_p)$。\n\n从分子生物学中心法则和稳态附近基因调控响应的线性化出发，使用贝叶斯推断、高斯似然和高斯先验，推导出 $\\mathbf{a}$ 的最大后验（MAP）估计量，并在不依赖任何预先推导的快捷公式的情况下，以算法方式实现它。推导过程必须从概率论和优化的第一性原理出发。然后，对下面的每个测试用例，计算通路活性的MAP估计值。所有活性值都是无量纲的，并且必须以浮点数形式报告，保留 $6$ 位小数。\n\n参数值测试套件：\n\n- 案例1（良态，加性激活）：\n  - $n = 6$, $p = 3$\n  - $\\mathbf{S} = \\begin{bmatrix}\n  0.8  0.1  0.2 \\\\\n  0.6  0.2  0.1 \\\\\n  0.1  0.7  0.3 \\\\\n  0.2  0.6  0.4 \\\\\n  0.0  0.1  0.9 \\\\\n  0.3  0.2  0.8\n  \\end{bmatrix}$\n  - $\\mathbf{b} = \\begin{bmatrix}0.0\\\\0.0\\\\0.0\\\\0.0\\\\0.0\\\\0.0\\end{bmatrix}$\n  - $\\mathbf{y} = \\begin{bmatrix}0.99\\\\0.77\\\\0.66\\\\0.78\\\\0.68\\\\0.96\\end{bmatrix}$\n  - $\\sigma^2 = 0.01$, $\\tau^2 = 10.0$\n\n- 案例2（Wnt/β-catenin和Notch特征之间存在强共线性）：\n  - $n = 4$, $p = 3$\n  - $\\mathbf{S} = \\begin{bmatrix}\n  0.5  0.49  0.1 \\\\\n  0.4  0.41  0.2 \\\\\n  0.6  0.6  0.3 \\\\\n  0.55  0.54  0.2\n  \\end{bmatrix}$\n  - $\\mathbf{b} = \\begin{bmatrix}0.0\\\\0.0\\\\0.0\\\\0.0\\end{bmatrix}$\n  - $\\mathbf{y} = \\begin{bmatrix}0.812\\\\0.688\\\\1.02\\\\0.912\\end{bmatrix}$\n  - $\\sigma^2 = 0.1$, $\\tau^2 = 1.0$\n\n- 案例3（特征中存在混合激活和抑制）：\n  - $n = 5$, $p = 3$\n  - $\\mathbf{S} = \\begin{bmatrix}\n  0.7  -0.2  0.1 \\\\\n  0.2  0.5  -0.3 \\\\\n  -0.1  0.6  0.4 \\\\\n  0.3  -0.4  0.7 \\\\\n  -0.2  0.3  0.8\n  \\end{bmatrix}$\n  - $\\mathbf{b} = \\begin{bmatrix}0.0\\\\0.0\\\\0.0\\\\0.0\\\\0.0\\end{bmatrix}$\n  - $\\mathbf{y} = \\begin{bmatrix}0.43\\\\0.05\\\\0.54\\\\0.65\\\\0.72\\end{bmatrix}$\n  - $\\sigma^2 = 0.02$, $\\tau^2 = 2.0$\n\n- 案例4（$n  p$ 的欠定系统）：\n  - $n = 2$, $p = 3$\n  - $\\mathbf{S} = \\begin{bmatrix}\n  0.5  0.2  0.3 \\\\\n  0.1  0.3  0.6\n  \\end{bmatrix}$\n  - $\\mathbf{b} = \\begin{bmatrix}0.0\\\\0.0\\end{bmatrix}$\n  - $\\mathbf{y} = \\begin{bmatrix}0.49\\\\0.55\\end{bmatrix}$\n  - $\\sigma^2 = 0.05$, $\\tau^2 = 0.5$\n\n您的程序必须计算每种情况下的MAP估计值 $\\widehat{\\mathbf{a}}$，并以单行输出的形式返回结果。该输出包含一个列表的列表，其中每个内部列表对应一个案例，并按固定顺序 $\\left[\\text{Wnt/}\\beta\\text{-catenin}, \\text{Notch}, \\text{TGF-}\\beta\\right]$ 包含三种通路活性，每种活性都四舍五入到 $6$ 位小数。例如，输出格式应类似于 $\\left[[a_{11},a_{12},a_{13}],[a_{21},a_{22},a_{23}],\\ldots\\right]$，其中每个 $a_{ij}$ 都打印为四舍五入到 $6$ 位小数的浮点数。", "solution": "该问题是有效的。它在科学上基于系统生物医学的原理，特别是将基因表达建模为对信号通路活性的线性响应。该问题是适定的、客观的，并提供了推导和计算通路活性的最大后验（MAP）估计值所需的所有信息。\n\n解决方案从贝叶斯推断的第一性原理出发，推导MAP估计量。观测到的基因表达向量 $\\mathbf{y} \\in \\mathbb{R}^n$ 的模型由下式给出：\n$$\n\\mathbf{y} = \\mathbf{b} + \\mathbf{S}\\mathbf{a} + \\boldsymbol{\\varepsilon}\n$$\n其中 $\\mathbf{b} \\in \\mathbb{R}^n$ 是基线表达，$\\mathbf{S} \\in \\mathbb{R}^{n \\times p}$ 是特征矩阵，$\\mathbf{a} \\in \\mathbb{R}^p$ 是未知的通路活性向量，而 $\\boldsymbol{\\varepsilon} \\in \\mathbb{R}^n$ 是测量噪声。我们已知噪声和通路活性的概率模型：\n1. 测量噪声服从独立高斯分布：$\\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I}_n)$。\n2. 通路活性的先验信念是一个零均值高斯分布：$\\mathbf{a} \\sim \\mathcal{N}(\\mathbf{0}, \\tau^2 \\mathbf{I}_p)$。\n\n我们的目标是找到 $\\mathbf{a}$ 的MAP估计值，记为 $\\widehat{\\mathbf{a}}_{\\text{MAP}}$，它是使后验概率密度 $p(\\mathbf{a} | \\mathbf{y})$ 最大化的 $\\mathbf{a}$ 的值。根据贝叶斯定理，后验概率与似然和先验的乘积成正比：\n$$\np(\\mathbf{a} | \\mathbf{y}) \\propto p(\\mathbf{y} | \\mathbf{a}) p(\\mathbf{a})\n$$\n最大化后验概率等价于最大化其对数，因为对数是单调递增函数。对数后验为：\n$$\n\\ln p(\\mathbf{a} | \\mathbf{y}) = \\ln p(\\mathbf{y} | \\mathbf{a}) + \\ln p(\\mathbf{a}) + \\text{constant}\n$$\n我们推导对数似然和对数先验的表达式。\n\n首先，我们定义似然 $p(\\mathbf{y} | \\mathbf{a})$。根据模型方程，对于给定的 $\\mathbf{a}$，观测向量 $\\mathbf{y}$ 是一个常数向量 $\\mathbf{b} + \\mathbf{S}\\mathbf{a}$ 和一个随机噪声向量 $\\boldsymbol{\\varepsilon}$ 的和。因此，$\\mathbf{y}$ 也是一个高斯随机向量。\n给定 $\\mathbf{a}$ 时 $\\mathbf{y}$ 的均值为 $E[\\mathbf{y} | \\mathbf{a}] = E[\\mathbf{b} + \\mathbf{S}\\mathbf{a} + \\boldsymbol{\\varepsilon}] = \\mathbf{b} + \\mathbf{S}\\mathbf{a}$。\n给定 $\\mathbf{a}$ 时 $\\mathbf{y}$ 的协方差为 $\\text{Cov}(\\mathbf{y} | \\mathbf{a}) = \\text{Cov}(\\mathbf{b} + \\mathbf{S}\\mathbf{a} + \\boldsymbol{\\varepsilon}) = \\text{Cov}(\\boldsymbol{\\varepsilon}) = \\sigma^2 \\mathbf{I}_n$。\n所以，似然由多元高斯概率密度函数（PDF）给出：\n$$\np(\\mathbf{y} | \\mathbf{a}) = \\mathcal{N}(\\mathbf{y}; \\mathbf{b} + \\mathbf{S}\\mathbf{a}, \\sigma^2\\mathbf{I}_n) = \\frac{1}{(2\\pi\\sigma^2)^{n/2}} \\exp\\left(-\\frac{1}{2\\sigma^2} (\\mathbf{y} - (\\mathbf{b} + \\mathbf{S}\\mathbf{a}))^T (\\mathbf{y} - (\\mathbf{b} + \\mathbf{S}\\mathbf{a}))\\right)\n$$\n对数似然，忽略与 $\\mathbf{a}$ 无关的项，为：\n$$\n\\ln p(\\mathbf{y} | \\mathbf{a}) = -\\frac{1}{2\\sigma^2} \\|\\mathbf{y} - \\mathbf{b} - \\mathbf{S}\\mathbf{a}\\|_2^2 + \\text{constant}\n$$\n\n接下来，我们定义先验 $p(\\mathbf{a})$。已知 $\\mathbf{a} \\sim \\mathcal{N}(\\mathbf{0}, \\tau^2 \\mathbf{I}_p)$。其概率密度函数为：\n$$\np(\\mathbf{a}) = \\mathcal{N}(\\mathbf{a}; \\mathbf{0}, \\tau^2\\mathbf{I}_p) = \\frac{1}{(2\\pi\\tau^2)^{p/2}} \\exp\\left(-\\frac{1}{2\\tau^2} \\mathbf{a}^T \\mathbf{a}\\right)\n$$\n对数先验，同样忽略常数项，为：\n$$\n\\ln p(\\mathbf{a}) = -\\frac{1}{2\\tau^2} \\|\\mathbf{a}\\|_2^2 + \\text{constant}\n$$\n\n结合对数似然和对数先验，需要最大化的对数后验为：\n$$\n\\widehat{\\mathbf{a}}_{\\text{MAP}} = \\arg\\max_{\\mathbf{a}} \\left( -\\frac{1}{2\\sigma^2} \\|\\mathbf{y} - \\mathbf{b} - \\mathbf{S}\\mathbf{a}\\|_2^2 - \\frac{1}{2\\tau^2} \\|\\mathbf{a}\\|_2^2 \\right)\n$$\n最大化此表达式等价于最小化其负数：\n$$\n\\widehat{\\mathbf{a}}_{\\text{MAP}} = \\arg\\min_{\\mathbf{a}} J(\\mathbf{a}) = \\arg\\min_{\\mathbf{a}} \\left( \\frac{1}{2\\sigma^2} \\|\\mathbf{y} - \\mathbf{b} - \\mathbf{S}\\mathbf{a}\\|_2^2 + \\frac{1}{2\\tau^2} \\|\\mathbf{a}\\|_2^2 \\right)\n$$\n我们定义一个修正后的观测向量 $\\mathbf{y}' = \\mathbf{y} - \\mathbf{b}$。目标函数为：\n$$\nJ(\\mathbf{a}) = \\frac{1}{2\\sigma^2} \\|\\mathbf{y}' - \\mathbf{S}\\mathbf{a}\\|_2^2 + \\frac{1}{2\\tau^2} \\|\\mathbf{a}\\|_2^2\n$$\n为了找到最小值，我们计算 $J(\\mathbf{a})$ 关于 $\\mathbf{a}$ 的梯度，并将其设为零向量。\n$$\n\\nabla_{\\mathbf{a}} J(\\mathbf{a}) = \\nabla_{\\mathbf{a}} \\left[ \\frac{1}{2\\sigma^2} (\\mathbf{y}' - \\mathbf{S}\\mathbf{a})^T (\\mathbf{y}' - \\mathbf{S}\\mathbf{a}) + \\frac{1}{2\\tau^2} \\mathbf{a}^T \\mathbf{a} \\right]\n$$\n使用矩阵微积分恒等式 $\\nabla_{\\mathbf{x}} (\\mathbf{c} - \\mathbf{A}\\mathbf{x})^T(\\mathbf{c} - \\mathbf{A}\\mathbf{x}) = -2\\mathbf{A}^T(\\mathbf{c} - \\mathbf{A}\\mathbf{x})$ 和对于对称矩阵 $\\mathbf{B}$ 的 $\\nabla_{\\mathbf{x}} (\\mathbf{x}^T\\mathbf{B}\\mathbf{x}) = 2\\mathbf{B}\\mathbf{x}$：\n$$\n\\nabla_{\\mathbf{a}} J(\\mathbf{a}) = \\frac{1}{2\\sigma^2} (-2\\mathbf{S}^T(\\mathbf{y}' - \\mathbf{S}\\mathbf{a})) + \\frac{1}{2\\tau^2} (2\\mathbf{a}) = -\\frac{1}{\\sigma^2} \\mathbf{S}^T\\mathbf{y}' + \\frac{1}{\\sigma^2} \\mathbf{S}^T\\mathbf{S}\\mathbf{a} + \\frac{1}{\\tau^2} \\mathbf{a}\n$$\n将梯度设为 $\\mathbf{0}$：\n$$\n\\left(\\frac{1}{\\sigma^2} \\mathbf{S}^T\\mathbf{S} + \\frac{1}{\\tau^2} \\mathbf{I}_p\\right) \\mathbf{a} = \\frac{1}{\\sigma^2} \\mathbf{S}^T\\mathbf{y}'\n$$\n两边乘以 $\\sigma^2$ 得：\n$$\n\\left(\\mathbf{S}^T\\mathbf{S} + \\frac{\\sigma^2}{\\tau^2} \\mathbf{I}_p\\right) \\mathbf{a} = \\mathbf{S}^T\\mathbf{y}'\n$$\n矩阵 $\\mathbf{S}^T\\mathbf{S}$ 是半正定的。由于 $\\sigma^2 > 0$ 且 $\\tau^2 > 0$，比率 $\\lambda = \\sigma^2/\\tau^2 > 0$。因此，矩阵 $\\mathbf{S}^T\\mathbf{S} + \\lambda\\mathbf{I}_p$ 是正定的，从而可逆。这保证了 $\\mathbf{a}$ 有唯一解。我们解出 $\\mathbf{a}$ 得到MAP估计量：\n$$\n\\widehat{\\mathbf{a}}_{\\text{MAP}} = \\left(\\mathbf{S}^T\\mathbf{S} + \\frac{\\sigma^2}{\\tau^2} \\mathbf{I}_p\\right)^{-1} \\mathbf{S}^T (\\mathbf{y} - \\mathbf{b})\n$$\n这个结果也称为Tikhonov正则化最小二乘法或岭回归，其中正则化参数由噪声方差与先验方差之比确定。该框架通过确保问题保持适定，正确处理了所有给定的测试用例，包括病态（案例2）和欠定（案例4）的情形。\n\n该算法的实现方式是：对每个案例，根据给定参数构造矩阵和向量，然后求解得到的线性方程组。具体来说，我们求解系统 $A\\mathbf{x}=\\mathbf{v}$，其中 $A = \\mathbf{S}^T\\mathbf{S} + (\\sigma^2/\\tau^2)\\mathbf{I}_p$，$\\mathbf{x} = \\mathbf{a}$，以及 $\\mathbf{v} = \\mathbf{S}^T(\\mathbf{y} - \\mathbf{b})$。使用线性求解器比直接计算矩阵的逆在数值上更稳定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"S\": np.array([\n                [0.8, 0.1, 0.2],\n                [0.6, 0.2, 0.1],\n                [0.1, 0.7, 0.3],\n                [0.2, 0.6, 0.4],\n                [0.0, 0.1, 0.9],\n                [0.3, 0.2, 0.8]\n            ]),\n            \"b\": np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),\n            \"y\": np.array([0.99, 0.77, 0.66, 0.78, 0.68, 0.96]),\n            \"sigma_sq\": 0.01,\n            \"tau_sq\": 10.0\n        },\n        {\n            \"S\": np.array([\n                [0.5, 0.49, 0.1],\n                [0.4, 0.41, 0.2],\n                [0.6, 0.6, 0.3],\n                [0.55, 0.54, 0.2]\n            ]),\n            \"b\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"y\": np.array([0.812, 0.688, 1.02, 0.912]),\n            \"sigma_sq\": 0.1,\n            \"tau_sq\": 1.0\n        },\n        {\n            \"S\": np.array([\n                [0.7, -0.2, 0.1],\n                [0.2, 0.5, -0.3],\n                [-0.1, 0.6, 0.4],\n                [0.3, -0.4, 0.7],\n                [-0.2, 0.3, 0.8]\n            ]),\n            \"b\": np.array([0.0, 0.0, 0.0, 0.0, 0.0]),\n            \"y\": np.array([0.43, 0.05, 0.54, 0.65, 0.72]),\n            \"sigma_sq\": 0.02,\n            \"tau_sq\": 2.0\n        },\n        {\n            \"S\": np.array([\n                [0.5, 0.2, 0.3],\n                [0.1, 0.3, 0.6]\n            ]),\n            \"b\": np.array([0.0, 0.0]),\n            \"y\": np.array([0.49, 0.55]),\n            \"sigma_sq\": 0.05,\n            \"tau_sq\": 0.5\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Extract parameters for the current case\n        S = case[\"S\"]\n        b = case[\"b\"]\n        y = case[\"y\"]\n        sigma_sq = case[\"sigma_sq\"]\n        tau_sq = case[\"tau_sq\"]\n\n        # Number of pathways (columns of S)\n        p = S.shape[1]\n\n        # Shift the observation vector by the baseline\n        y_prime = y - b\n        \n        # Calculate the regularization parameter lambda\n        lambda_reg = sigma_sq / tau_sq\n        \n        # Construct the matrix A = (S^T S + lambda * I)\n        A = S.T @ S + lambda_reg * np.identity(p)\n        \n        # Construct the vector v = S^T (y - b)\n        v = S.T @ y_prime\n        \n        # Solve the linear system A * a = v for a.\n        # This is more numerically stable than computing the inverse of A.\n        a_map = np.linalg.solve(A, v)\n        all_results.append(a_map)\n\n    # Format the final output string according to the problem specification.\n    # The result is a list of lists, with each number as a float rounded to 6 decimals.\n    result_str_parts = []\n    for a_map in all_results:\n        # Format each list of results to \"[val1,val2,...]\" with 6 decimal places\n        inner_list_str = f\"[{','.join([f'{x:.6f}' for x in a_map])}]\"\n        result_str_parts.append(inner_list_str)\n\n    final_output = f\"[{','.join(result_str_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "4399635"}]}