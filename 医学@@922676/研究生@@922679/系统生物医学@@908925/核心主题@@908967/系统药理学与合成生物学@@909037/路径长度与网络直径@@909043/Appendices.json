{"hands_on_practices": [{"introduction": "掌握了路径长度和网络直径的核心定义后，通过一个具体的计算练习来巩固这些概念至关重要。这个实践将引导你为一个信号网络计算所有节点的离心率和整个网络的直径。通过比较在不考虑权重（仅拓扑结构）和考虑权重（如信号转导延迟）两种不同模型下的结果，你将深入理解边权重如何从根本上改变网络的距离特性。[@problem_id:4372739]", "problem": "在一个哺乳动物细胞的信号模块中，考虑一个由六种蛋白质 $v_1,\\ldots,v_6$ 组成的有向网络。每个有向相互作用 $v_i \\to v_j$ 都被赋予一个有效延迟权重 $w_{ij} \\in \\{0,1,2,3,4\\}$，其中 $w_{ij} = 0$ 表示没有直接的相互作用。加权邻接矩阵 $\\mathbf{W} = (w_{ij})$ 为\n$$\n\\mathbf{W} =\n\\begin{pmatrix}\n0  1  0  3  0  0 \\\\\n0  0  1  0  2  0 \\\\\n0  0  0  1  0  2 \\\\\n4  0  0  0  1  0 \\\\\n0  4  0  0  0  1 \\\\\n1  0  4  0  0  0\n\\end{pmatrix}.\n$$\n假设所有存在的边的延迟都为严格正值，并且该网络作为一个有向图是强连通的。通过二元邻接矩阵 $\\mathbf{A} = (a_{ij})$ 定义无权模型，其中如果 $w_{ij}  0$，则 $a_{ij} = 1$，否则 $a_{ij} = 0$。在加权模型中，从 $v_i$ 到 $v_j$ 的最短路径距离是从 $v_i$ 到 $v_j$ 的所有有向路径中的最小总延迟。在无权模型中，每条存在的边的长度为 $1$，最短路径距离是有向路径上的最小边数。\n\n对于两种模型（加权和无权），计算每个节点 $v \\in \\{v_1,\\ldots,v_6\\}$ 的离心率 $\\epsilon(v)$，其定义为从 $v$ 到网络中任何其他节点的最大最短路径距离。然后计算网络直径 $D$，定义为所有节点离心率的最大值。在每个模型中，识别哪些节点是外围节点，其中如果一个节点的离心率等于直径，则该节点是外围节点。\n\n将您的最终答案表示为一个单行矩阵，按顺序连接以下内容：\n- $\\epsilon_{\\mathrm{unw}}(v_1),\\ldots,\\epsilon_{\\mathrm{unw}}(v_6)$，\n- $\\epsilon_{\\mathrm{w}}(v_1),\\ldots,\\epsilon_{\\mathrm{w}}(v_6)$，\n- $D_{\\mathrm{unw}}, D_{\\mathrm{w}}$，\n- 无权模型的外围指示向量 $\\in \\{0,1\\}^6$，按节点顺序 $v_1,\\ldots,v_6$（其中 $1$ 表示外围），\n- 加权模型的外围指示向量 $\\in \\{0,1\\}^6$，按节点顺序 $v_1,\\ldots,v_6$。\n\n提供精确的整数值；不要四舍五入。不需要单位。", "solution": "用户想要在两种不同的模型下分析一个给定的由六种蛋白质组成的有向网络：一个无权模型和一个加权模型。目标是为每个模型计算节点离心率、网络直径并识别外围节点。\n\n**问题设置**\n网络由 $N=6$ 个节点组成，$\\{v_1, v_2, v_3, v_4, v_5, v_6\\}$。相互作用由一个加权邻接矩阵 $\\mathbf{W} = (w_{ij})$ 定义：\n$$\n\\mathbf{W} =\n\\begin{pmatrix}\n0  1  0  3  0  0 \\\\\n0  0  1  0  2  0 \\\\\n0  0  0  1  0  2 \\\\\n4  0  0  0  1  0 \\\\\n0  4  0  0  0  1 \\\\\n1  0  4  0  0  0\n\\end{pmatrix}\n$$\n在这个矩阵中，$w_{ij}$ 表示从 $v_i$ 到 $v_j$ 的有向边的延迟（权重）。权重为 $0$ 表示没有边。\n\n该问题需要基于从 $\\mathbf{W}$ 派生出的两个模型进行两部分分析。\n\n**第1部分：无权模型分析**\n\n在无权模型中，每条存在的边都被赋予长度 $1$。连接性由二元邻接矩阵 $\\mathbf{A} = (a_{ij})$ 描述，其中如果 $w_{ij}  0$，则 $a_{ij} = 1$，否则 $a_{ij} = 0$。\n$$\n\\mathbf{A} =\n\\begin{pmatrix}\n0  1  0  1  0  0 \\\\\n0  0  1  0  1  0 \\\\\n0  0  0  1  0  1 \\\\\n1  0  0  0  1  0 \\\\\n0  1  0  0  0  1 \\\\\n1  0  1  0  0  0\n\\end{pmatrix}\n$$\n最短路径距离 $d_{\\mathrm{unw}}(v_i, v_j)$ 是从 $v_i$ 到 $v_j$ 的有向路径中的最小边数。为了找到离心率，我们必须首先计算所有对最短路径矩阵 $\\mathbf{D}_{\\mathrm{unw}}$。由于该图是无权的，我们可以从每个节点开始运行广度优先搜索（BFS）。\n\n- **从 $v_1$ 出发**：距离为 $(d(v_1,v_1), \\dots, d(v_1,v_6)) = (0, 1, 2, 1, 2, 3)$。\n- **从 $v_2$ 出发**：距离为 $(3, 0, 1, 2, 1, 2)$。\n- **从 $v_3$ 出发**：距离为 $(2, 3, 0, 1, 2, 1)$。\n- **从 $v_4$ 出发**：距离为 $(1, 2, 3, 0, 1, 2)$。\n- **从 $v_5$ 出发**：距离为 $(2, 1, 2, 3, 0, 1)$。\n- **从 $v_6$ 出发**：距离为 $(1, 2, 1, 2, 3, 0)$。\n\n无权模型的所有对最短路径矩阵是：\n$$\n\\mathbf{D}_{\\mathrm{unw}} =\n\\begin{pmatrix}\n0  1  2  1  2  3 \\\\\n3  0  1  2  1  2 \\\\\n2  3  0  1  2  1 \\\\\n1  2  3  0  1  2 \\\\\n2  1  2  3  0  1 \\\\\n1  2  1  2  3  0\n\\end{pmatrix}\n$$\n一个节点 $v$ 的离心率 $\\epsilon(v)$ 是从 $v$ 到网络中任何其他节点的最大最短路径距离。它对应于距离矩阵中 $v$ 所在行的最大值。\n\n- $\\epsilon_{\\mathrm{unw}}(v_1) = \\max(0, 1, 2, 1, 2, 3) = 3$。\n- $\\epsilon_{\\mathrm{unw}}(v_2) = \\max(3, 0, 1, 2, 1, 2) = 3$。\n- $\\epsilon_{\\mathrm{unw}}(v_3) = \\max(2, 3, 0, 1, 2, 1) = 3$。\n- $\\epsilon_{\\mathrm{unw}}(v_4) = \\max(1, 2, 3, 0, 1, 2) = 3$。\n- $\\epsilon_{\\mathrm{unw}}(v_5) = \\max(2, 1, 2, 3, 0, 1) = 3$。\n- $\\epsilon_{\\mathrm{unw}}(v_6) = \\max(1, 2, 1, 2, 3, 0) = 3$。\n\n无权离心率的向量是 $(\\epsilon_{\\mathrm{unw}}(v_1), \\dots, \\epsilon_{\\mathrm{unw}}(v_6)) = (3, 3, 3, 3, 3, 3)$。\n\n网络直径 $D_{\\mathrm{unw}}$ 是所有节点离心率的最大值。\n$$D_{\\mathrm{unw}} = \\max_{i} \\{\\epsilon_{\\mathrm{unw}}(v_i)\\} = 3$$\n如果一个节点的离心率等于直径，则该节点是外围节点。由于所有节点的离心率都为 $3$，等于直径，所以所有节点都是外围节点。外围指示向量是 $(1, 1, 1, 1, 1, 1)$。\n\n**第2部分：加权模型分析**\n\n在加权模型中，从 $v_i$ 到 $v_j$ 的边的长度由延迟 $w_{ij}$ 给出。最短路径距离 $d_{\\mathrm{w}}(v_i, v_j)$ 是从 $v_i$ 到 $v_j$ 的有向路径上权重的最小和。我们可以使用 Floyd-Warshall 算法或从每个节点运行 Dijkstra 算法来计算所有对最短路径矩阵 $\\mathbf{D}_{\\mathrm{w}}$。该图没有负权重环（实际上没有负权重），因此这些算法是适用的。\n\n设 $\\mathbf{D}_{\\mathrm{w}}^{(k)}$ 为仅使用来自 $\\{v_1, \\dots, v_k\\}$ 的中间顶点的最短路径距离矩阵。我们用直接边的给定权重初始化 $\\mathbf{D}_{\\mathrm{w}}^{(0)}$，其他情况为 $\\infty$（对角线上为 $0$）。在对 $k=1, \\dots, 6$ 迭代应用 Floyd-Warshall 更新规则 $D_{ij} = \\min(D_{ij}, D_{ik} + D_{kj})$ 后，我们得到最终的距离矩阵 $\\mathbf{D}_{\\mathrm{w}} = \\mathbf{D}_{\\mathrm{w}}^{(6)}$。\n\n加权模型得到的所有对最短路径矩阵是：\n$$\n\\mathbf{D}_{\\mathrm{w}} =\n\\begin{pmatrix}\n0  1  2  3  3  4 \\\\\n4  0  1  2  2  3 \\\\\n3  4  0  1  2  2 \\\\\n3  4  5  0  1  2 \\\\\n2  3  4  5  0  1 \\\\\n1  2  3  4  4  0\n\\end{pmatrix}\n$$\n现在，我们通过取 $\\mathbf{D}_{\\mathrm{w}}$ 每一行的最大值来计算加权离心率。\n\n- $\\epsilon_{\\mathrm{w}}(v_1) = \\max(0, 1, 2, 3, 3, 4) = 4$。\n- $\\epsilon_{\\mathrm{w}}(v_2) = \\max(4, 0, 1, 2, 2, 3) = 4$。\n- $\\epsilon_{\\mathrm{w}}(v_3) = \\max(3, 4, 0, 1, 2, 2) = 4$。\n- $\\epsilon_{\\mathrm{w}}(v_4) = \\max(3, 4, 5, 0, 1, 2) = 5$。\n- $\\epsilon_{\\mathrm{w}}(v_5) = \\max(2, 3, 4, 5, 0, 1) = 5$。\n- $\\epsilon_{\\mathrm{w}}(v_6) = \\max(1, 2, 3, 4, 4, 0) = 4$。\n\n加权离心率的向量是 $(\\epsilon_{\\mathrm{w}}(v_1), \\dots, \\epsilon_{\\mathrm{w}}(v_6)) = (4, 4, 4, 5, 5, 4)$。\n\n加权网络直径 $D_{\\mathrm{w}}$ 是这些离心率的最大值。\n$$D_{\\mathrm{w}} = \\max_{i} \\{\\epsilon_{\\mathrm{w}}(v_i)\\} = 5$$\n如果一个节点的离心率等于直径（$5$），则该节点是外围节点。离心率为 $5$ 的节点是 $v_4$ 和 $v_5$。因此，加权模型的外围指示向量是 $(0, 0, 0, 1, 1, 0)$。\n\n**最终答案汇总**\n\n问题要求将以下结果按顺序连接成一个单行矩阵：\n1.  无权离心率：$(3, 3, 3, 3, 3, 3)$\n2.  加权离心率：$(4, 4, 4, 5, 5, 4)$\n3.  直径（无权，加权）：$(3, 5)$\n4.  无权外围指示向量：$(1, 1, 1, 1, 1, 1)$\n5.  加权外围指示向量：$(0, 0, 0, 1, 1, 0)$\n这会得到一个包含 $6+6+2+6+6 = 26$ 个元素的行向量。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n3  3  3  3  3  3  4  4  4  5  5  4  3  5  1  1  1  1  1  1  0  0  0  1  1  0\n\\end{pmatrix}\n}\n$$", "id": "4372739"}, {"introduction": "在系统生物医学中，单纯的计算是不够的，我们必须能够解释计算结果的生物学意义。本练习以一个信号级联网络为例，要求你计算其加权和非加权直径，并阐述在评估药物干预可达性时，为何其中一个指标比另一个更具生物学相关性。这项练习旨在培养将数学模型与生物学问题联系起来的关键能力。[@problem_id:4372644]", "problem": "在系统生物医学中，有向信号网络模拟了分子实体（例如，受体、衔接蛋白、激酶和转录因子）之间的因果影响。考虑一个包含节点 $\\{R, A, B, C, D, E, F\\}$ 的有向网络，其中每条有向边 $(u \\rightarrow v)$ 都有一个正的边成本 $c(u,v)$，该成本代表一个有效的信号转导成本（例如，以任意单位计的平均传输延迟）。有向边及其成本如下：\n- $R \\rightarrow A$，成本为 $c(R,A)=0.7$\n- $R \\rightarrow C$，成本为 $c(R,C)=3.2$\n- $A \\rightarrow B$，成本为 $c(A,B)=0.6$\n- $A \\rightarrow D$，成本为 $c(A,D)=1.9$\n- $B \\rightarrow C$，成本为 $c(B,C)=0.5$\n- $B \\rightarrow E$，成本为 $c(B,E)=2.8$\n- $C \\rightarrow D$，成本为 $c(C,D)=0.4$\n- $D \\rightarrow E$，成本为 $c(D,E)=0.3$\n- $D \\rightarrow F$，成本为 $c(D,F)=0.2$\n- $E \\rightarrow F$，成本为 $c(E,F)=0.3$\n- $F \\rightarrow C$，成本为 $c(F,C)=0.4$\n\n采用以下定义，这些定义在图论中是标准的，并且适用于有向信号网络：\n- 无权有向最短路径长度 $\\ell_{s}(u,v)$ 是从 $u$ 到 $v$ 的任何有向路径上的最少有向边数。如果从 $u$ 无法到达 $v$，则在下文求最大值时 $\\ell_{s}(u,v)$ 未定义。\n- 加权有向最短路径长度 $\\ell_{w}(u,v)$ 是从 $u$ 到 $v$ 的所有有向路径 $P$ 上的最小总成本 $\\sum_{e \\in P} c(e)$。如果从 $u$ 无法到达 $v$，则在下文求最大值时 $\\ell_{w}(u,v)$ 未定义。\n- 无权有向直径 $D_{s}$ 是在所有满足 $u \\neq v$ 且 $v$ 可从 $u$ 到达的有序对 $(u,v)$ 中，$\\ell_{s}(u,v)$ 的最大值。\n- 加权有向直径 $D_{w}$ 是在所有满足 $u \\neq v$ 且 $v$ 可从 $u$ 到达的有序对 $(u,v)$ 中，$\\ell_{w}(u,v)$ 的最大值。\n\n任务：\n1. 通过确定最小有向跳数 $\\ell_{s}(u,v)$，然后对所有具有有限可达性的有序对 $(u,v)$ 取最大值，计算该网络的 $D_{s}$。\n2. 通过确定最小有向路径成本 $\\ell_{w}(u,v)$，然后对所有具有有限可达性的有序对 $(u,v)$ 取最大值，计算该网络的 $D_{w}$。\n3. 从信号级联中路径长度的解释以及独立段成本的可加性出发，解释在评估引入单个节点的药理干预的潜在可达性时，偏好使用 $D_{w}$ 或 $D_{s}$ 的生物学原理。\n\n将你的最终数值结果以有序对 $(D_{s}, D_{w})$ 的形式报告。无需四舍五入。", "solution": "用户提供了一个问题，要求计算代表信号网络的有向图的无权和加权直径，并解释这两种度量标准的生物学相关性。\n\n### 步骤1：问题验证\n\n**提取的已知条件：**\n-   **节点：** $V = \\{R, A, B, C, D, E, F\\}$\n-   **有向边和成本：**\n    -   $R \\rightarrow A$, $c(R,A)=0.7$\n    -   $R \\rightarrow C$, $c(R,C)=3.2$\n    -   $A \\rightarrow B$, $c(A,B)=0.6$\n    -   $A \\rightarrow D$, $c(A,D)=1.9$\n    -   $B \\rightarrow C$, $c(B,C)=0.5$\n    -   $B \\rightarrow E$, $c(B,E)=2.8$\n    -   $C \\rightarrow D$, $c(C,D)=0.4$\n    -   $D \\rightarrow E$, $c(D,E)=0.3$\n    -   $D \\rightarrow F$, $c(D,F)=0.2$\n    -   $E \\rightarrow F$, $c(E,F)=0.3$\n    -   $F \\rightarrow C$, $c(F,C)=0.4$\n-   **定义：**\n    -   无权最短路径长度 $\\ell_{s}(u,v)$：从 $u$ 到 $v$ 的路径上的最小边数。\n    -   加权最短路径长度 $\\ell_{w}(u,v)$：从 $u$ 到 $v$ 的路径上的最小成本总和。\n    -   无权直径 $D_{s}$：在所有满足 $u \\neq v$ 且 $v$ 可从 $u$ 到达的有序对 $(u,v)$ 上的 $\\max\\{\\ell_{s}(u,v)\\}$。\n    -   加权直径 $D_{w}$：在所有满足 $u \\neq v$ 且 $v$ 可从 $u$ 到达的有序对 $(u,v)$ 上的 $\\max\\{\\ell_{w}(u,v)\\}$。\n\n**验证结论：**\n该问题是有效的。\n-   它是**有科学依据的**，使用了标准的图论概念（$D_s, D_w$）来分析系统生物医学中公认的模型（信号网络）。\n-   它是**适定的**。该图被完全指定，边成本为正（防止了负成本循环），定义精确且标准。每个计算任务都存在唯一的解。仅在可达对上取最大值的条件正确处理了未定义的路径长度。\n-   它是**客观的**。这些任务是计算性的，需要基于给定的解释进行逻辑推理，没有主观因素。\n-   该问题没有表现出任何列出的缺陷（例如，不完整性、矛盾、歧义）。\n\n### 步骤2：求解推导\n\n该问题要求计算两个网络属性，即无权直径 $D_s$ 和加权直径 $D_w$，然后对它们的生物学效用进行比较分析。这涉及到为给定有向图的无权和加权版本计算所有节点对之间的最短路径。\n\n**任务1：计算无权直径 $D_s$**\n\n任意两个节点 $u$ 和 $v$ 之间的无权最短路径长度 $\\ell_s(u,v)$ 是从 $u$ 到 $v$ 路径上的最小边数（跳数）。我们可以通过从网络中的每个节点开始执行广度优先搜索（BFS）来找到这些长度。\n\n-   我们来寻找强连通分量。集合 $\\{C, D, F\\}$ 构成一个强连通分量，因为 $C \\to D \\to F \\to C$。该环路的长度为 3 跳。所有节点都可以从 $R$ 到达。并非所有节点都能到达 $R$。\n-   通过从 7 个节点中的每一个执行 BFS，我们可以构建无权最短路径长度矩阵 $\\ell_s(u,v)$。条目 $\\infty$ 表示从 $u$ 无法到达 $v$。\n\n$\\ell_s(u,v)$ 矩阵：\n$$\n\\begin{array}{c|ccccccc}\n\\ell_s(u,v)  R  A  B  C  D  E  F \\\\\n\\hline\nR  0  1  2  1  2  3  3 \\\\\nA  \\infty  0  1  2  1  2  2 \\\\\nB  \\infty  \\infty  0  1  2  1  2 \\\\\nC  \\infty  \\infty  \\infty  0  1  2  2 \\\\\nD  \\infty  \\infty  \\infty  2  0  1  1 \\\\\nE  \\infty  \\infty  \\infty  2  3  0  1 \\\\\nF  \\infty  \\infty  \\infty  1  2  3  0 \\\\\n\\end{array}\n$$\n无权直径 $D_s$ 是此矩阵中除对角线条目外的最大有限值。\n$$\nD_s = \\max_{u \\neq v, \\ell_s(u,v)  \\infty} \\ell_s(u,v)\n$$\n检查矩阵，最大值为 $3$。这个值出现在多个节点对上，包括：\n-   $\\ell_s(R,E) = 3$ (路径: $R \\to A \\to B \\to E$)\n-   $\\ell_s(R,F) = 3$ (路径: $R \\to A \\to D \\to F$)\n-   $\\ell_s(E,D) = 3$ (路径: $E \\to F \\to C \\to D$)\n-   $\\ell_s(F,E) = 3$ (路径: $F \\to C \\to D \\to E$)\n\n因此，无权直径为 $D_s = 3$。\n\n**任务2：计算加权直径 $D_w$**\n\n加权最短路径长度 $\\ell_w(u,v)$ 是从 $u$ 到 $v$ 路径上的最小边成本总和。由于所有边成本都是正的，我们可以从每个节点开始使用 Dijkstra 算法来找到所有节点对之间的最短路径。或者，对于小图，也可以使用 Floyd-Warshall 算法。\n\n让我们将从每个节点运行 Dijkstra 算法的结果总结在一个加权最短路径长度矩阵 $\\ell_w(u,v)$ 中。\n\n-   从源点 $R$ 开始：$\\ell_w(R,E) = \\ell_w(R,D) + c(D,E) = (\\ell_w(R,C) + c(C,D)) + c(D,E) = ((\\ell_w(R,B) + c(B,C)) + c(C,D)) + c(D,E) = (((\\ell_w(R,A) + c(A,B)) + c(B,C)) + c(C,D)) + c(D,E) = (((0.7+0.6)+0.5)+0.4)+0.3 = 2.5$。\n... 对所有节点对依此类推。\n\n完整的 $\\ell_w(u,v)$ 矩阵是：\n$$\n\\begin{array}{c|ccccccc}\n\\ell_w(u,v)  R  A  B  C  D  E  F \\\\\n\\hline\nR  0  0.7  1.3  1.8  2.2  2.5  2.4 \\\\\nA  \\infty  0  0.6  1.1  1.5  1.8  1.7 \\\\\nB  \\infty  \\infty  0  0.5  0.9  1.2  1.1 \\\\\nC  \\infty  \\infty  \\infty  0  0.4  0.7  0.6 \\\\\nD  \\infty  \\infty  \\infty  0.6  0  0.3  0.2 \\\\\nE  \\infty  \\infty  \\infty  0.7  1.1  0  0.3 \\\\\nF  \\infty  \\infty  \\infty  0.4  0.8  1.1  0 \\\\\n\\end{array}\n$$\n加权直径 $D_w$ 是此矩阵中除对角线外的最大值。\n$$\nD_w = \\max_{u \\neq v, \\ell_w(u,v)  \\infty} \\ell_w(u,v)\n$$\n通过检查，矩阵中的最大值是 2.5，即 $\\ell_w(R,E)$。与此成本对应的路径是 $R \\to A \\to B \\to C \\to D \\to E$，总成本为 $0.7 + 0.6 + 0.5 + 0.4 + 0.3 = 2.5$。\n\n因此，加权直径为 $D_w = 2.5$。\n\n**任务3：偏好使用 $D_w$ 或 $D_s$ 的生物学原理**\n\n问题要求基于边成本 $c(u,v)$ 被解释为信号转导成本（例如时间延迟）的前提，为评估药理干预的可达性时偏好使用 $D_w$ 或 $D_s$ 提供一个原理。\n\n在节点 $u$ 处的药理干预会沿着有向路径在网络中传播其影响。该干预在下游节点 $v$ 的“可达性”根本上与信号从 $u$ 传播到 $v$ 所需的时间有关。\n\n无权直径 $D_s$ 衡量信号在任意两个可达节点之间传播所需的最大顺序步骤数。该度量标准将每个信号步骤（每条边）视为等同的。它提供了一个纯粹拓扑学的度量，衡量网络的最大“广度”。\n\n加权直径 $D_w$ 衡量信号在任意两个可达节点之间传播的最大累积成本（例如，总时间延迟）。该度量标准明确地包含了信号传导过程的异质性，其中一些步骤可能很快（低成本），而另一些则很慢（高成本）。问题陈述成本代表“有效的信号转导成本”，例如“平均传输延迟”。\n\n鉴于这种解释，$D_w$ 是更具生物学相关性的度量标准。生物信号传导是一个时间过程。信号传播的速度和效率决定了细胞反应的时间尺度和强度。一条包含几个非常缓慢、限速步骤（高成本）的路径，其总延迟可能比一条包含许多快速步骤（低成本）的路径长得多。\n\n例如，比较从 $A$ 直接到 $D$ 的路径与从 $A$ 经由 $B$ 到 $C$ 的路径。\n-   路径 $A \\to D$：$\\ell_s(A,D) = 1$，但 $\\ell_w(A,D) = 1.9$。\n-   路径 $A \\to B \\to C$：$\\ell_s(A,C) = 2$，但 $\\ell_w(A,C) = 0.6 + 0.5 = 1.1$。\n\n在 $A$ 处的干预将比影响节点 $D$（成本 1.9）更快地影响节点 $C$（成本 1.1），尽管 $D$ 在拓扑上“更近”（1 跳 vs. 2 跳）。$D_s$ 度量标准会误导性地表明，从 $A$ 出发，$D$ 比 $C$ 更容易受到影响。\n\n因此，在评估药理干预的潜在可达性（即其影响能传播多远多快）时，加权直径 $D_w$ 更优越。它提供了一个衡量效应在网络中任何地方显现所需的最大时间延迟或累积成本的度量，这在一个动态生物系统中，是比简单地计算中间过程步骤数更现实、更有功能意义的可达性度量。\n\n最终要求的结果是有序对 $(D_s, D_w)$。根据计算，$D_s = 3$ 且 $D_w = 2.5$。", "answer": "$$ \\boxed{ \\begin{pmatrix} 3  2.5 \\end{pmatrix} } $$", "id": "4372644"}, {"introduction": "网络分析的真正威力在于其预测能力，尤其是在模拟系统扰动（如基因突变）的影响时。这个实践要求你通过编程来模拟因功能丧失性突变而移除网络中的“中枢”节点，并计算网络直径在扰动前后的变化。通过这个练习，你将亲身体验网络直径如何作为衡量网络鲁棒性和结构完整性的一个重要指标。[@problem_id:4372650]", "problem": "给定一组无向生物相互作用网络，这些网络模拟大分子间的连接性（例如，蛋白质-蛋白质相互作用（PPI）网络）。每个网络表示为一个简单的图，由有限的节点集和无向边组成。考虑以下应用于系统生物医学的图论基本定义：对于一个简单的无向图 $G = (V, E)$，两节点之间的路径是任何由边连接的、不重复的节点序列，其长度是该序列中边的数量，而最短路径距离 $d(u,v)$ 是连接 $u$ 和 $v$ 的所有存在路径中的最小长度。$G$ 的直径 $D(G)$ 是在给定的目标连通分量中，所有无序节点对之间的最大最短路径距离。在本问题中，目标连通分量定义为基数最大的连通分量；如果多个分量具有相同的最大尺寸，则选择其中直径最大的那个。如果所选分量的节点数少于 $2$ 个，则定义 $D(G) = 0$。所有路径长度都是无单位的边计数，并且必须作为整数处理。\n\n一个与疾病相关的功​​能丧失性突变可以抽象为从网络中移除一个节点（以及所有与其相连的边）。一个中心节点（hub）被定义为在当前图中具有最大度的节点。给定一个整数 $k \\ge 1$，通过移除 $k$ 个度最大的节点来执行中心节点移除操作，若度数相同，则按节点标识符的字典序（升序）来打破平局。移除后，使用与上述相同的规则重新计算最大连通分量的直径。\n\n您的任务是编写一个完整的程序，对每个提供的测试网络，计算直径对 $\\left[D_{\\text{before}}, D_{\\text{after}}\\right]$，其中 $D_{\\text{before}}$ 是原始图的最大连通分量的直径，而 $D_{\\text{after}}$ 是在按规定移除 $k$ 个中心节点后最大连通分量的直径。将所有结果输出到单行，格式为一个用方括号括起来的逗号分隔列表，其中每个元素本身也是一个双元素列表，顺序与测试用例相同。\n\n仅使用上述逻辑和数学定义，不使用任何快捷公式。从第一性原理推导计算最短路径距离和直径的方法。\n\n测试套件（边以无序的字符串对给出；所有图均为简单无向图）：\n\n- 测试用例 1（一个由桥连接的两个中心节点组成的双星型 PPI 类网络），移除参数 $k=1$：\n  - 节点包括：TP53, EGFR, BRCA1, AKT1, PTEN, MAPK1, RB1, PIK3CA, CDK2, MDM2, MYC.\n  - 边：\n    - (\"TP53\",\"EGFR\")\n    - (\"TP53\",\"BRCA1\"), (\"TP53\",\"AKT1\"), (\"TP53\",\"PTEN\"), (\"TP53\",\"MAPK1\"), (\"TP53\",\"RB1\")\n    - (\"EGFR\",\"PIK3CA\"), (\"EGFR\",\"CDK2\"), (\"EGFR\",\"MDM2\"), (\"EGFR\",\"MYC\")\n\n- 测试用例 2（一个由 6 个基因组成的线性链），移除参数 $k=1$：\n  - 节点：G1, G2, G3, G4, G5, G6.\n  - 边：\n    - (\"G1\",\"G2\"), (\"G2\",\"G3\"), (\"G3\",\"G4\"), (\"G4\",\"G5\"), (\"G5\",\"G6\")\n\n- 测试用例 3（一个大小为 5 的完全团），移除参数 $k=1$：\n  - 节点：A, B, C, D, E.\n  - 边：\n    - (\"A\",\"B\"), (\"A\",\"C\"), (\"A\",\"D\"), (\"A\",\"E\"),\n    - (\"B\",\"C\"), (\"B\",\"D\"), (\"B\",\"E\"),\n    - (\"C\",\"D\"), (\"C\",\"E\"),\n    - (\"D\",\"E\")\n\n答案规范：\n- 对于每个测试用例，计算 $D_{\\text{before}}$ 和 $D_{\\text{after}}$ 为整数。\n- 您的程序应生成单行输出，包含方括号括起来的逗号分隔列表形式的结果，格式需严格遵守：$\\left[ [D_{\\text{before}}^{(1)}, D_{\\text{after}}^{(1)}], [D_{\\text{before}}^{(2)}, D_{\\text{after}}^{(2)}], [D_{\\text{before}}^{(3)}, D_{\\text{after}}^{(3)}] \\right]$，不含空格。", "solution": "该问题要求我们计算一个给定的生物网络的最大连通分量（LCC）的直径，该网络表示为一个简单的无向图，计算需在移除指定数量的中心节点之前和之后分别进行。解决方案需要从第一性原理出发，逐步实现图算法。\n\n### 方法论框架\n\n每个测试用例的总体过程涉及两个主要阶段：\n1.  分析初始图以确定其 LCC 的直径 $D_{\\text{before}}$。\n2.  识别并移除 $k$ 个中心节点，然后分析所得图以确定新的 LCC 的直径 $D_{\\text{after}}$。\n\n这需要几个基本的图论算法，我们将推导并实现它们。\n\n#### 1. 图表示\n图 $G = (V, E)$ 由一个节点集 $V$ 和一个边集 $E$ 组成。我们将使用邻接表来表示图。这实现为一个字典，其中每个键是节点标识符，其对应的值是其相邻节点的标识符集合。对于图的遍历和生物学中常见的稀疏网络，这种结构是高效的。\n\n#### 2. 寻找连通分量\n要识别 LCC，我们必须首先将图划分为其连通分量。连通分量是一个子图，其中任意两个节点都通过路径相互连接，并且它不与超图中的任何其他节点相连。我们可以使用图遍历算法（如广度优先搜索（BFS））找到所有分量。\n\n该算法流程如下：\n- 维护一个已访问节点的集合，初始为空。\n- 遍历图中的每个节点。\n- 如果一个节点尚未被访问，则它属于一个新的、未被发现的分量。从此节点开始进行 BFS 遍历。\n- BFS 将访问所有可达节点，这些节点共同形成一个连通分量。将所有这些节点添加到已访问集合中。\n- 存储该分量（作为其节点集合），并重复此过程，直到所有节点都已被访问。\n\n#### 3. 所有节点对最短路径（APSP）与直径\n问题将两节点 $u$ 和 $v$ 之间的最短路径距离 $d(u,v)$ 定义为连接它们的路径中的最小边数。对于无权图，BFS 是计算单源最短路径（SSSP）的最有效算法。从源节点 $s$ 开始进行 BFS，到任何其他节点 $v$ 的距离是其在 BFS 树中的层级，即从 $s$到 $v$ 路径上的边数。\n\n为了找到一个连通分量的直径，我们需要该分量内所有节点对之间的最短路径距离。这可以通过从该分量中的每个节点执行 SSSP（BFS）算法来实现。\n\n连通分量 $G$ 的直径 $D(G)$ 是该分量中所有节点对之间的最大最短路径距离：\n$$\nD(G) = \\max_{u, v \\in V} d(u,v)\n$$\n这等同于找到任意节点的最大偏心率，其中节点 $u$ 的偏心率是 $\\epsilon(u) = \\max_{v \\in V} d(u,v)$。\n\n计算给定分量直径的步骤是：\n1.  如果分量包含的节点少于 $2$ 个，其直径为 $0$。\n2.  否则，将一个最大距离变量初始化为 $0$。\n3.  对于分量中的每个节点 $u$：\n    a. 从 $u$ 开始运行 BFS，以找到到分量中所有其他节点 $v$ 的距离。\n    b. 这些距离中的最大值是 $u$ 的偏心率。如果该偏心率更大，则更新总的最大距离。\n4.  最终的最大距离就是该分量的直径。\n\n#### 4. 最大连通分量（LCC）的选择\n问题为选择目标分量规定了精确的规则：\n1.  找到所有连通分量并确定它们的大小（节点数）。\n2.  在所有分量中确定最大尺寸。\n3.  筛选分量列表，只保留那些具有此最大尺寸的分量。\n4.  如果这样只得到一个分量，那么它就是 LCC。\n5.  如果出现平局（多个分量具有相同的最大尺寸），则计算这些候选分量中每一个的直径。LCC 是其中直径最大的那个。返回的值就是这个最大直径。\n\n#### 5. 中心节点识别与移除\n中心节点被定义为图中度数最大的节点。移除 $k$ 个中心节点的过程如下：\n1.  对于图中的每个节点，计算其度（连接到它的边的数量）。\n2.  识别出具有最高度数的节点列表。\n3.  如果度数存在平局，则按其字符串标识符的字典序（升序）对这些节点进行排序。\n4.  从这个排序列表中选出前 $k$ 个节点作为要移除的中心节点。\n5.  通过删除这 $k$ 个节点及其所有相连的边来构建一个新图。\n\n#### 6. 最终计算\n每个测试用例的总体算法是：\n1.  根据提供的节点和边构建初始图。\n2.  对该图应用 LCC 选择逻辑和直径计算，以找到 $D_{\\text{before}}$。\n3.  从初始图中识别并移除前 $k$ 个中心节点，以创建一个新的、受扰动的图。\n4.  对这个新图应用 LCC 选择和直径计算，以找到 $D_{\\text{after}}$。\n5.  该测试用例的结果是数对 $[D_{\\text{before}}, D_{\\text{after}}]$。对所有测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the network diameter problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: Double-star PPI network\n        {\n            \"nodes\": {\"TP53\", \"EGFR\", \"BRCA1\", \"AKT1\", \"PTEN\", \"MAPK1\", \"RB1\", \"PIK3CA\", \"CDK2\", \"MDM2\", \"MYC\"},\n            \"edges\": [\n                (\"TP53\", \"EGFR\"), (\"TP53\", \"BRCA1\"), (\"TP53\", \"AKT1\"), (\"TP53\", \"PTEN\"),\n                (\"TP53\", \"MAPK1\"), (\"TP53\", \"RB1\"), (\"EGFR\", \"PIK3CA\"), (\"EGFR\", \"CDK2\"),\n                (\"EGFR\", \"MDM2\"), (\"EGFR\", \"MYC\")\n            ],\n            \"k\": 1\n        },\n        # Test Case 2: Linear chain\n        {\n            \"nodes\": {\"G1\", \"G2\", \"G3\", \"G4\", \"G5\", \"G6\"},\n            \"edges\": [(\"G1\", \"G2\"), (\"G2\", \"G3\"), (\"G3\", \"G4\"), (\"G4\", \"G5\"), (\"G5\", \"G6\")],\n            \"k\": 1\n        },\n        # Test Case 3: Complete clique\n        {\n            \"nodes\": {\"A\", \"B\", \"C\", \"D\", \"E\"},\n            \"edges\": [\n                (\"A\", \"B\"), (\"A\", \"C\"), (\"A\", \"D\"), (\"A\", \"E\"),\n                (\"B\", \"C\"), (\"B\", \"D\"), (\"B\", \"E\"),\n                (\"C\", \"D\"), (\"C\", \"E\"),\n                (\"D\", \"E\")\n            ],\n            \"k\": 1\n        }\n    ]\n\n    def build_graph(nodes, edges):\n        \"\"\"Builds an adjacency list representation of the graph.\"\"\"\n        graph = defaultdict(set)\n        for node in nodes:\n            graph[node] # Ensure all nodes are in the graph dict\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n        return graph\n\n    def get_connected_components(graph):\n        \"\"\"Finds all connected components in a graph using BFS.\"\"\"\n        visited = set()\n        components = []\n        for node in graph:\n            if node not in visited:\n                component = set()\n                queue = [node]\n                visited.add(node)\n                component.add(node)\n                head = 0\n                while head  len(queue):\n                    current_node = queue[head]\n                    head += 1\n                    for neighbor in graph[current_node]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            component.add(neighbor)\n                            queue.append(neighbor)\n                components.append(frozenset(component))\n        return components\n\n    def bfs_shortest_paths(graph, start_node):\n        \"\"\"Calculates shortest paths from a start node in an unweighted graph.\"\"\"\n        if start_node not in graph:\n            return {}\n        distances = {start_node: 0}\n        queue = [(start_node, 0)]\n        head = 0\n        while head  len(queue):\n            current_node, dist = queue[head]\n            head += 1\n            for neighbor in graph.get(current_node, set()):\n                if neighbor not in distances:\n                    distances[neighbor] = dist + 1\n                    queue.append((neighbor, dist + 1))\n        return distances\n\n\n    def calculate_diameter(graph, component_nodes):\n        \"\"\"Calculates the diameter of a given connected component.\"\"\"\n        if len(component_nodes)  2:\n            return 0\n        \n        max_dist = 0\n        # The graph passed to bfs must only contain nodes of the component.\n        subgraph = {node: graph[node] for node in component_nodes}\n\n        for start_node in component_nodes:\n            distances = bfs_shortest_paths(subgraph, start_node)\n            if not distances:\n                continue\n            # If component is disconnected, max would be on reachable nodes.\n            # But get_connected_components ensures this is not an issue.\n            current_max = max(distances.values())\n            if current_max > max_dist:\n                max_dist = current_max\n        return max_dist\n\n    def compute_diameter_of_lcc(graph):\n        \"\"\"Computes the diameter of the largest connected component (LCC).\"\"\"\n        if not graph:\n            return 0\n        \n        components = get_connected_components(graph)\n        if not components:\n            return 0\n\n        max_size = 0\n        for comp in components:\n            if len(comp) > max_size:\n                max_size = len(comp)\n\n        largest_components = [comp for comp in components if len(comp) == max_size]\n        \n        if len(largest_components) == 1:\n            lcc_nodes = largest_components[0]\n            return calculate_diameter(graph, lcc_nodes)\n        else:\n            max_diam = -1\n            for comp_nodes in largest_components:\n                diam = calculate_diameter(graph, comp_nodes)\n                if diam > max_diam:\n                    max_diam = diam\n            return max_diam if max_diam != -1 else 0\n\n    def remove_hubs(graph, k):\n        \"\"\"Identifies and removes the top k hubs from a graph.\"\"\"\n        if not graph:\n            return {}\n\n        nodes_with_degrees = []\n        for node in graph:\n            nodes_with_degrees.append((len(graph[node]), node))\n        \n        # Sort by degree (descending) and then node ID (ascending)\n        nodes_with_degrees.sort(key=lambda x: (-x[0], x[1]))\n\n        nodes_to_remove = {item[1] for item in nodes_with_degrees[:k]}\n        \n        new_graph = defaultdict(set)\n        original_nodes = set(graph.keys())\n        remaining_nodes = original_nodes - nodes_to_remove\n\n        for node in remaining_nodes:\n            new_graph[node] # Ensure node exists in new graph\n            for neighbor in graph[node]:\n                if neighbor in remaining_nodes:\n                    new_graph[node].add(neighbor)\n\n        return new_graph\n\n    results = []\n    for case in test_cases:\n        nodes, edges, k = case[\"nodes\"], case[\"edges\"], case[\"k\"]\n\n        # Before removal\n        graph_before = build_graph(nodes, edges)\n        d_before = compute_diameter_of_lcc(graph_before)\n\n        # After removal\n        graph_after = remove_hubs(graph_before, k)\n        d_after = compute_diameter_of_lcc(graph_after)\n        \n        results.append([d_before, d_after])\n\n    # Format the final output string exactly as specified.\n    str_results = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```", "id": "4372650"}]}