{"hands_on_practices": [{"introduction": "在真实的蛋白质相互作用（PPI）网络中，图并非总是完全连通的，这给基于最短路径的邻近性计算带来了挑战，因为不同连通分支中的节点之间距离为无穷大。本练习 [@problem_id:4366923] 旨在探讨一种常见的解决方案——将分析限制在最大连通分支（LCC）内。通过亲手计算并量化这种简化方法可能引入的偏差，你将学会批判性地评估网络分析中的方法学选择。", "problem": "一个蛋白质-蛋白质相互作用（PPI）网络被表示为一个无向、无权的图 $G=(V,E)$，该图可能是不连通的。该网络包含多个连通分量；最大连通分量（LCC）在总共 $18{,}000$ 个节点中包含了 $15{,}000$ 个节点。考虑一个嵌入在图 $G$ 中的药物靶点集 $S$ 和一个疾病蛋白集 $T$，其中 $|S|=10$ 且 $|T|=12$。在这些药物靶点中，有 $7$ 个在 LCC 内， $3$ 个在 LCC 外。在这些疾病蛋白中，有 $9$ 个在 LCC 内， $3$ 个在 LCC 外。\n\n将 $S$ 和 $T$ 之间的网络邻近度定义为从 $S$ 到 $T$ 的平均最近邻最短路径距离：\n$$\n\\delta(S,T)=\\frac{1}{|S|}\\sum_{s\\in S}\\min_{t\\in T} d_G(s,t),\n$$\n其中 $d_G(s,t)$ 表示在图 $G$ 中以跳数计算的最短路径长度。对于处于不同连通分量中的节点对，采用一个有限的惩罚距离 $D_{\\infty}=7$，因此如果节点 $s$ 与所有 $t\\in T$ 均处于与 $s$ 不连通的分量中，则 $\\min_{t\\in T} d_G(s,t)$ 的值取为 $D_{\\infty}$。\n\n为了模拟系统生物医学中常见的限制在最大连通分量（LCC）上的做法，定义 LCC 限制的邻近度\n$$\n\\delta_{\\mathrm{LCC}}(S,T)=\\frac{1}{|S\\cap \\mathrm{LCC}|}\\sum_{s\\in S\\cap \\mathrm{LCC}} \\min_{t\\in T\\cap \\mathrm{LCC}} d_G(s,t),\n$$\n其计算方法是在测量距离之前移除所有不在 LCC 中的节点。\n\n在图 $G$ 上的经验观察结果显示：\n- 对于 $S\\cap \\mathrm{LCC}$ 中的 $7$ 个药物靶点，它们到 $T\\cap \\mathrm{LCC}$ 的最近邻距离为 $\\{1,2,2,3,3,4,5\\}$ 跳。\n- 在 LCC 之外的 $3$ 个药物靶点中，恰好有 1 个与 $T$ 中的一个疾病蛋白共享一个小的连通分量，距离为 $2$ 跳；其余两个药物靶点所在的连通分量中没有疾病蛋白。\n\n从连通分量、最短路径距离以及上述邻近度的基本定义出发，阐述在不连通的 PPI 网络中使用基于最短路径的邻近度时，将计算限制在 LCC 上的理由。然后，计算定义为如下的带符号偏差\n$$\nb=\\delta_{\\mathrm{LCC}}(S,T)-\\delta(S,T),\n$$\n根据以上数据。将你的最终数值答案四舍五入到四位有效数字。不需要单位。", "solution": "该问题陈述经评估具有科学依据、问题明确、客观且自洽。它提出了一个基于网络的系统生物医学中的标准任务，提供了所有必要的定义、数据和约束，以得出一个唯一的、可验证的解。其前提条件一致，术语精确。因此，该问题是有效的。\n\n根据题目要求，解答分为两部分：首先，阐述将网络邻近度计算限制在最大连通分量（LCC）上的理由；其次，计算带符号偏差 $b$。\n\n**第一部分：邻近度计算中 LCC 限制的理由**\n\n最短路径距离 $d_G(s,t)$ 的使用是许多网络邻近度测度的基础。在一个不连通的图 $G$ 中，该图被划分为两个或多个连通分量。根据定义，位于不同分量中的节点之间不存在路径。因此，这些节点之间的最短路径距离是无穷大的，即 $d_G(s,t) = \\infty$。\n\n这对那些需要对这些距离求平均值的邻近度度量标准构成了重大挑战。一个包含哪怕一个无穷大值的平均值本身也是无穷大的，这使得该度量标准不具信息量。例如，如果任何药物靶点 $s \\in S$ 位于一个没有任何来自 $T$ 的疾病蛋白的分量中，那么定义 $\\delta(S,T)=\\frac{1}{|S|}\\sum_{s\\in S}\\min_{t\\in T} d_G(s,t)$ 就会出现问题。在这种情况下，$\\min_{t\\in T} d_G(s,t) = \\infty$，导致 $\\delta(S,T)$ 发散。\n\n有两种主要策略可以解决这个问题：\n1.  **指定一个有限惩罚值：** 这种方法在问题中明确提到，它用一个大的有限惩罚值 $D_{\\infty}$ 来代替无穷大的距离。这里，如果一个源节点 $s$ 与所有目标节点 $t \\in T$ 都不连通，它对总和的贡献被设置为 $D_{\\infty}=7$。虽然这使得计算变得可行，但它引入了对一个任意参数的关键依赖。$D_{\\infty}$ 的选择可以显著改变最终的邻近度分数以及任何后续的统计评估（例如，Z-score）。一个更高的 $D_{\\infty}$ 会更严厉地惩罚不连通性。由于缺乏一个理论上合理的 $D_{\\infty}$ 值，这种方法是主观的，并且可能不稳定。\n\n2.  **限制在 LCC 内：** 源自高通量实验的蛋白质-蛋白质相互作用（PPI）网络通常具有一个“巨型”或最大连通分量（LCC），其中包含了绝大多数节点（在本例中，为 $18,000$ 个节点中的 $15,000$ 个，约占 $83.3\\%$）。其余的节点分散在许多小的、孤立的分量中。将分析限制在 LCC 上的科学理由是，该分量代表了细胞的核心、相互连接的功能机制。较小的分量通常被解释为包含功能上不那么核心的蛋白质，或者可能代表实验假象或不完整的数据。通过聚焦于 LCC，分析范围内的所有节点根据定义都是相互可达的，从而确保所有的最短路径距离 $d_G(s,t)$ 都是有限且良定义的。这种方法消除了像 $D_{\\infty}$ 这样的任意惩罚值的需要，从而实现更稳健、无参数的距离计算。主要缺点是丢失了 LCC 外部节点的信息，而这些节点可能含有相关的生物信号。该问题中偏差的计算旨在量化这种信息丢失的影响。\n\n总之，在系统生物医学中，将计算限制在 LCC 上是一种实用且常见的方法，以确保基于最短路径的度量标准是良定义的，并且不会被任意的惩罚参数所扭曲，其假设是最重要的生物过程被捕获在网络最大的相互连接区域内。\n\n**第二部分：带符号偏差 $b$ 的计算**\n\n带符号偏差定义为 $b=\\delta_{\\mathrm{LCC}}(S,T)-\\delta(S,T)$。我们将分别计算每一项。\n\n**计算 $\\delta_{\\mathrm{LCC}}(S,T)$：**\nLCC 限制的邻近度定义为：\n$$\n\\delta_{\\mathrm{LCC}}(S,T)=\\frac{1}{|S\\cap \\mathrm{LCC}|}\\sum_{s\\in S\\cap \\mathrm{LCC}} \\min_{t\\in T\\cap \\mathrm{LCC}} d_G(s,t)\n$$\n根据题目陈述，LCC 中的药物靶点数量为 $|S\\cap \\mathrm{LCC}| = 7$。这 $7$ 个靶点到 LCC 内疾病蛋白（$T\\cap \\mathrm{LCC}$）的最近邻距离集合已知为 $\\{1,2,2,3,3,4,5\\}$。\n这些距离的总和是：\n$$\n\\sum_{s\\in S\\cap \\mathrm{LCC}} \\min_{t\\in T\\cap \\mathrm{LCC}} d_G(s,t) = 1+2+2+3+3+4+5 = 20\n$$\n因此，LCC 限制的邻近度为：\n$$\n\\delta_{\\mathrm{LCC}}(S,T) = \\frac{20}{7}\n$$\n\n**计算 $\\delta(S,T)$：**\n全局邻近度定义为：\n$$\n\\delta(S,T)=\\frac{1}{|S|}\\sum_{s\\in S}\\min_{t\\in T} d_G(s,t)\n$$\n我们已知 $|S|=10$。该总和可以分解为对 LCC 内靶点的求和与对 LCC 外靶点的求和：\n$$\n\\sum_{s\\in S}\\min_{t\\in T} d_G(s,t) = \\sum_{s\\in S\\cap \\mathrm{LCC}}\\min_{t\\in T} d_G(s,t) + \\sum_{s\\in S\\setminus \\mathrm{LCC}}\\min_{t\\in T} d_G(s,t)\n$$\n对于第一项，考虑一个靶点 $s \\in S\\cap \\mathrm{LCC}$。它与所有 $t \\in T\\cap \\mathrm{LCC}$ 连通，但与所有 $t \\in T\\setminus \\mathrm{LCC}$ 不连通。因此，最小距离将是到其自身分量（LCC）内的一个节点：\n$$\n\\min_{t\\in T} d_G(s,t) = \\min(\\min_{t\\in T\\cap \\mathrm{LCC}} d_G(s,t), \\min_{t\\in T\\setminus \\mathrm{LCC}} d_G(s,t)) = \\min(\\min_{t\\in T\\cap \\mathrm{LCC}} d_G(s,t), \\infty) = \\min_{t\\in T\\cap \\mathrm{LCC}} d_G(s,t)\n$$\n这 $7$ 个靶点的总和与之前计算的相同：\n$$\n\\sum_{s\\in S\\cap \\mathrm{LCC}}\\min_{t\\in T} d_G(s,t) = 20\n$$\n对于第二项，我们考虑 LCC 之外的 $|S\\setminus \\mathrm{LCC}| = 3$ 个靶点。\n- 一个靶点位于一个小分量中，与来自 $T$ 的单个疾病蛋白相距 $2$ 跳。对于这个靶点，它到 $T$ 中任何蛋白的最小距离就是这个值，因为 $T$ 中的所有其他蛋白都在不同的分量中（LCC 或其他分量），因此距离无限远。所以，它的贡献是 $2$。\n- 剩下的两个靶点所在的连通分量中没有来自 $T$ 的疾病蛋白。根据题目的规则，对于这些靶点，最小距离被赋予惩罚值 $D_{\\infty}=7$。这两个靶点每个的贡献是 $7$。\nLCC 之外靶点的总和是：\n$$\n\\sum_{s\\in S\\setminus \\mathrm{LCC}}\\min_{t\\in T} d_G(s,t) = 2 + 7 + 7 = 16\n$$\n$S$ 中所有靶点的总和是 $20 + 16 = 36$。\n因此，全局邻近度为：\n$$\n\\delta(S,T) = \\frac{36}{10} = 3.6\n$$\n\n**计算偏差 $b$：**\n现在我们计算带符号偏差：\n$$\nb = \\delta_{\\mathrm{LCC}}(S,T) - \\delta(S,T) = \\frac{20}{7} - 3.6 = \\frac{20}{7} - \\frac{36}{10} = \\frac{20}{7} - \\frac{18}{5}\n$$\n为了进行分数减法，我们找到一个公分母，即 $35$：\n$$\nb = \\frac{20 \\times 5}{35} - \\frac{18 \\times 7}{35} = \\frac{100 - 126}{35} = -\\frac{26}{35}\n$$\n最后，我们将此分数转换为小数，并四舍五入到四位有效数字：\n$$\nb = -\\frac{26}{35} \\approx -0.742857...\n$$\n四舍五入到四位有效数字得到：\n$$\nb \\approx -0.7429\n$$\n负偏差表明，与包含不连通节点惩罚的全局计算相比，将分析限制在 LCC 内导致了更低的（即更近的）邻近度值。这是因为全局计算被分配给两个完全孤立的药物靶点的高昂惩罚成本（$D_\\infty=7$）所夸大了。", "answer": "$$\\boxed{-0.7429}$$", "id": "4366923"}, {"introduction": "计算出的邻近性分数本身并没有意义，除非我们将其与一个適切な的统计背景进行比较。这个思维实验练习 [@problem_id:4366983] 要求你深入比较两种基本的零模型：标签置換（label permutation）和边重连（edge rewiring）。通过分析它们各自的假设，你将更深刻地理解在检验药物-疾病邻近性时，“控制网络拓扑”的真正含义，以及如何设计一个稳健的统计检验。", "problem": "一个人类蛋白质-蛋白质相互作用网络（Protein-Protein Interaction (PPI) network）被建模为一个简单连通图 $G = (V,E)$，其中 $V$ 是蛋白质集合，$E$ 是物理相互作用集合。令 $|V| = N$，并令 $d(u,v)$ 表示节点 $u \\in V$ 和 $v \\in V$ 之间的无权最短路径距离。考虑一种药物，其特征为一组目标靶点 $T \\subset V$，大小为 $|T| = m$；以及一种疾病，其特征为一组相关基因 $S \\subset V$，大小为 $|S| = n$。一种广泛使用的药物-疾病网络邻近性定义为平均交叉最短路径距离\n$$\n\\Delta(T,S) = \\frac{1}{mn}\\sum_{t \\in T}\\sum_{s \\in S} d(t,s).\n$$\n你的目标是检验观测到的 $\\Delta(T,S)$ 是否显著小于随机期望值，这表明药物靶点和疾病基因之间存在邻近性。正在考虑两种零模型：\n\n零模型1（标签置换零模型）：在固定的网络 $G$ 上，通过在度匹配约束下抽样 $T' \\subset V$（大小为 $|T'| = m$）和 $S' \\subset V$（大小为 $|S'| = n$），来随机化标签，使得 $T'$ 和 $S'$ 的经验度分布与 $T$ 和 $S$ 的度分布相匹配（在允许的容差范围内），并通过多次实现计算 $\\Delta(T',S')$ 来获得经验期望值。\n\n零模型2（边重连零模型）：通过保持度的边重连（精确保持度序列的构型式重连）生成代理网络 $G'$，在每个 $G'$ 上计算 $\\Delta(T,S)$，并汇总以获得经验期望值。\n\n从图上的最短路径距离的定义、度序列保持的意义，以及高阶拓扑结构（例如，聚类、同配性和模块性）在决定路径长度分布中的作用出发，分析在检验药物-疾病邻近性时，哪种零模型能更好地控制网络拓扑结构。你的分析必须从这些核心定义开始，通过推导每种零模型下的期望邻近性表达式，并解释度序列之外的网络特征如何影响 $\\Delta(T,S)$ 来进行。\n\n为使分析更具根据，考虑以下科学上合理的情景：一个人类PPI网络有 $N = 5000$，平均度 $\\langle k \\rangle \\approx 8$，所有节点对的经验平均成对最短路径距离为 $\\bar{d}_G \\approx 3.2$，具有高聚类系数和模块化社区结构。在保持度的重连下，代理网络 $G'$ 的聚类减少，模块性被部分破坏，产生的经验平均成对最短路径距离为 $\\bar{d}_{G'} \\approx 2.7$，且直径分位数相似。对于一种特定的药物和疾病，观测到的邻近性为 $\\Delta(T,S) = 2.9$，其中 $m = 20$，$n = 30$。\n\n在药物-疾病邻近性的统计检验中，关于控制网络拓扑结构，哪个陈述最准确？\n\nA. 带度匹配的标签置换能更好地控制网络拓扑，因为它保持 $G$ 不变，从而保留了由聚类和模块性引起的所有路径距离 $d(u,v)$，同时调整了 $T$ 和 $S$ 中由度驱动的选择偏差，因此是根据 $G$ 的实际拓扑结构来估计期望的 $\\Delta$。\n\nB. 保持度的边重连能更好地控制网络拓扑，因为它消除了聚类和社区结构带来的偏差，只留下度的影响；因此它为任何网络上的 $\\Delta$ 提供了最中性的基线。\n\nC. 如果度序列被保留，两种零模型在控制拓扑方面是等效的，因为最短路径距离仅取决于度序列。\n\nD. 不带度匹配的标签置换在拓扑控制方面更可取，因为 $T'$ 和 $S'$ 是均匀抽样的，从而在 $G$ 上同时抵消了度的影响和社区结构。\n\nE. 通过要求在 $G$ 上的标签置换和在 $G'$ 上的边重连下都具有显著性来结合两种零模型，可以提供比单独使用任何一种都更严格的拓扑控制，因为两种零模型之间的任何差异都反映了真实的生物信号而非结构性伪影。\n\n选择唯一一个最佳选项，该选项正确地描述了在此情景下能更好地控制网络拓扑的零模型，并使用所提供的情景和关于图与最短路径的第一性原理进行论证。", "solution": "该问题要求分析两种用于评估蛋白质-蛋白质相互作用（PPI）网络中药物-疾病邻近性统计显著性的零模型。任务的核心是确定哪种零模型能更好地控制网络拓扑结构。\n\n### 步骤1：问题验证\n\n我将首先提取给定信息并验证问题陈述。\n\n**给定条件：**\n1.  **网络模型：** 一个简单连通图 $G = (V,E)$，其中 $V$ 是蛋白质集合，$E$ 是物理相互作用集合。\n2.  **网络大小：** $|V| = N$。\n3.  **距离度量：** $d(u,v)$ 是节点 $u, v \\in V$ 之间的无权最短路径距离。\n4.  **药物/疾病集合：** 药物由其靶点集合 $T \\subset V$ 表示，大小为 $|T| = m$。疾病由其相关基因集合 $S \\subset V$ 表示，大小为 $|S| = n$。\n5.  **邻近性度量：** 平均交叉最短路径距离定义为 $\\Delta(T,S) = \\frac{1}{mn}\\sum_{t \\in T}\\sum_{s \\in S} d(t,s)$。\n6.  **假设检验：** 目标是检验观测到的 $\\Delta(T,S)$ 是否显著小于随机期望值。\n7.  **零模型1（标签置换）：** 在固定图 $G$ 上，在度匹配约束下抽样随机集合 $T'$ 和 $S'$，其大小分别为 $|T'| = m$ 和 $|S'| = n$。零分布由 $\\Delta(T',S')$ 形成。\n8.  **零模型2（边重连）：** 集合 $T$ 和 $S$ 是固定的，但图 $G$ 通过保持度的边重连被随机化为代理图 $G'$。零分布由在每个 $G'$ 上计算的 $\\Delta(T,S)$ 形成。\n9.  **情景数据：**\n    *   $N = 5000$。\n    *   平均度 $\\langle k \\rangle \\approx 8$。\n    *   $G$ 上的平均成对最短路径距离：$\\bar{d}_G \\approx 3.2$。\n    *   $G$ 具有高聚类和模块化社区结构。\n    *   通过重连生成的代理图 $G'$ 具有降低的聚类和模块性。\n    *   $G'$ 上的平均成对最短路径距离：$\\bar{d}_{G'} \\approx 2.7$。\n    *   特定案例的观测邻近性：$\\Delta(T,S) = 2.9$。\n    *   集合大小：$m = 20$，$n = 30$。\n\n**验证：**\n1.  **科学依据：** 该问题牢固地植根于网络科学和系统生物医学。将PPI网络建模为图、使用最短路径距离表示邻近性以及应用零模型进行统计检验都是标准且成熟的方法论。所描述的两种零模型——带度匹配的标签置换和保持度的边重连——是网络分析中的经典方法。\n2.  **良定性：** 问题是精确的：“分析哪种零模型能更好地控制网络拓扑结构”。定义清晰，所提供的情景数据一致，并用于阐释核心概念。可以推导出一个唯一的、有理有据的答案。\n3.  **客观性：** 问题以客观、正式的语言陈述，没有主观或带偏见的措辞。\n\n**结论：** 问题陈述是有效的。它在科学上是合理的、良定的、客观的和完整的。它提出了一个关于网络分析中统计零模型选择的非平凡的概念性挑战。我现在将进行求解推导。\n\n### 步骤2：推导与分析\n\n核心问题是，在此假设检验的背景下，“控制网络拓扑结构”意味着什么。网络 $G$ 的拓扑结构包含其所有结构特征，从局部（度序列）到中尺度（聚类、模体、社区结构）和全局（路径长度分布、直径）。这些特征共同决定了所有成对最短路径距离的集合 $\\{d(u,v)\\}_{u,v \\in V}$。邻近性度量 $\\Delta(T,S)$ 是这些距离的一个子集的平均值。\n\n零模型的目的是生成一个与观测数据共享某些属性的“随机”构型系综，以便将观测到的统计量与之进行比较。对于这个问题，一个有效的零模型应该保留正在检验的生物学假设所在的结构背景（网络拓扑），同时随机化正在研究的特定元素（基因/靶点的选择）。\n\n**零模型1（带度匹配的标签置换）的分析**\n\n该模型在固定的真实网络 $G$ 上操作。这意味着网络的整个拓扑结构——包括情景中提到的高聚类和模块性——都被保留下来。所有可能的最短路径距离集合 $\\{d(u,v)\\}$ 是不变的。零假设检验的是，特定的节点集 $T$ 和 $S$ 是否比具有相似度特征的随机选择的集合 $T'$ 和 $S'$ *在同一个网络上* 预期的更近。\n\n在此零模型下，邻近性的期望值 $E_{1}[\\Delta(T',S')]$ 表示在图 $G$ 上，两个大小分别为 $m$ 和 $n$ 且具有指定度分布的节点集之间的平均距离。该值将受到 $G$ 的全局路径长度属性的影响。鉴于情景中 $\\bar{d}_G \\approx 3.2$，我们可以预期 $E_{1}[\\Delta(T',S')]$ 会接近这个值，并受到度匹配约束的轻微调节（例如，如果 $T$ 和 $S$ 由高度节点组成，期望距离将小于全局平均值）。\n\n通过将观测到的 $\\Delta(T,S)$ 与 $\\Delta(T',S')$ 的分布进行比较，我们正在将 $T$ 和 $S$ 中节点特定选择的影响与网络的背景结构以及与节点度相关的任何潜在抽样偏差分离开来。这是在生物网络的固定背景下检验特定、局部化关系的正确方法。因此，该模型恰当地控制了整个网络拓扑。\n\n**零模型2（边重连）的分析**\n\n该模型固定了节点集 $T$ 和 $S$，但随机化了网络的边结构，从而创建了一个代理图系综 $\\{G'\\}$。唯一被严格保留的拓扑属性是度序列。正如问题所述，像聚类和模块性这样的高阶结构（真实生物网络的特征）被破坏了。\n\n这种拓扑结构的破坏对最短路径距离有直接而显著的影响。重连过程将一个结构化的、“块状”的网络转变为一个更同质化的随机网络。在这类随机图中，捷径更多，导致路径长度普遍减小。情景量化了这种效应：平均路径长度从 $\\bar{d}_G \\approx 3.2$ 下降到 $\\bar{d}_{G'} \\approx 2.7$。\n\n因此，该零模型下的邻近性期望值 $E_{2}[\\Delta(T,S)_{\\text{on } G'}]$ 将围绕 $\\bar{d}_{G'} \\approx 2.7$ 居中。这里的零假设是：“真实网络 $G$ 上固定集合 $T$ 和 $S$ 之间的距离，与它们在一个仅共享相同度序列的随机图上的期望距离是否不同？”\n\n在我们的情景中，观测到的邻近性是 $\\Delta(T,S) = 2.9$。将其与约 2.7 的零期望值相比，我们发现观测值*大于*期望值。该检验将无法发现显著的邻近性；它甚至可能得出节点显著*分离*的结论。这个反直觉的结果之所以出现，是因为零模型创建了一个所有东西都人为地靠近的基线。检验不再是关于 $T$ 和 $S$ 之间的关系。相反，它实际上是在检验真实网络的模块性和聚类（在 $G'$ 中不存在）是否相对于随机图增加了路径长度。这是一个不同的科学问题，也不是检验药物-疾病邻近性的本意。该模型未能控制相关的拓扑背景；事实上，它主动地将其完全破坏。\n\n**分析结论**\n零模型1（标签置换）在控制网络拓扑方面更优越，因为它保留了网络 $G$ 的整个拓扑结构作为检验的背景。零模型2（边重连）丢弃了关键的高阶拓扑，从根本上改变了路径长度分布，因此提供了一个不合适的比较基线。\n\n### 步骤3：选项评估\n\n**A. 带度匹配的标签置换能更好地控制网络拓扑，因为它保持 $G$ 不变，从而保留了由聚类和模块性引起的所有路径距离 $d(u,v)$，同时调整了 $T$ 和 $S$ 中由度驱动的选择偏差，因此是根据 $G$ 的实际拓扑结构来估计期望的 $\\Delta$。**\n该陈述是对分析的精确和正确的总结。它正确地指出，保持 $G$ 不变可以保留完整的拓扑结构。它准确地描述了度匹配在纠正选择偏差中的作用。它正确地得出结论，即此过程建立了一个以实际网络结构为基准的零假设。该选项是**正确的**。\n\n**B. 保持度的边重连能更好地控制网络拓扑，因为它消除了聚类和社区结构带来的偏差，只留下度的影响；因此它为任何网络上的 $\\Delta$ 提供了最中性的基线。**\n该陈述将聚类和社区结构错误地描述为需要被移除的“偏差”。在生物网络的背景下，这些特征是其组织和功能的基本方面，而不是伪影。破坏它们并不能为原始网络创建一个“中性基线”；它为另一个不同的随机网络创建了一个基线。其推理是有缺陷的。该选项是**不正确的**。\n\n**C. 如果度序列被保留，两种零模型在控制拓扑方面是等效的，因为最短路径距离仅取决于度序列。**\n该陈述的前提在事实上是错误的。最短路径距离并不仅仅取决于度序列。两个具有相同度序列的图可以有截然不同的结构（例如，聚类、直径、路径长度分布）。所提供的情景通过具有相同度序列的图的 $\\bar{d}_G \\approx 3.2$ 和 $\\bar{d}_{G'} \\approx 2.7$ 证明了这一点。因此，关于两种零模型等效的结论也是错误的。该选项是**不正确的**。\n\n**D. 不带度匹配的标签置换在拓扑控制方面更可取，因为 $T'$ 和 $S'$ 是均匀抽样的，从而在 $G$ 上同时抵消了度的影响和社区结构。**\n虽然在固定图 $G$ 上的标签置换正确地保留了拓扑结构，但省略度匹配是一个严重的缺陷。如果真实的集合 $T$ 和 $S$ 偏向于高度节点（一种常见情况），将其邻近性与均匀随机集合的邻近性进行比较，很可能会产生虚假的显著结果。该检验将仅仅是检测到中心节点彼此靠近，而不是一个特定的功能联系。声称这能“抵消……社区结构”也是无稽之谈；抽样不会改变 $G$ 的结构。该选项提出了一个比问题中描述的更弱的零模型。该选项是**不正确的**。\n\n**E. 通过要求在 $G$ 上的标签置换和在 $G'$ 上的边重连下都具有显著性来结合两种零模型，可以提供比单独使用任何一种都更严格的拓扑控制，因为两种零模型之间的任何差异都反映了真实的生物信号而非结构性伪影。**\n这种方法混淆了两个不同的统计问题。如前所述，这两种零模型检验的是不同的假设。它们结果之间的差异不一定是“真实的生物信号”，而是反映了被控制的不同属性。在所提供的情景中，一个药物-疾病对在零模型1下可能显著邻近，但在零模型2下可能显著分离（或不邻近）。要求两者都显著是一个过于保守且概念上混乱的策略，而不是一个“更严格”的策略。该选项是**不正确的**。", "answer": "$$\\boxed{A}$$", "id": "4366983"}, {"introduction": "最后的这个练习将所有概念融会贯通，为你呈现一个贴近现实的综合性编程挑战 [@problem_id:4366944]。你将从零开始实现一个邻近性度量算法，接着整合组织特异性的基因表达数据来精炼网络模型，并最终用实验数据验证你的模型。这个练习模拟了一个完整的、端到端的系统生物学分析流程，是理论联系实际的绝佳实践。", "problem": "您将获得一个在组织特异性蛋白质组约束下，用于描述药物-疾病关系中网络邻近性的形式化设定。计算任务是从核心图论定义出发，推导出一个药物靶点集与疾病模块之间的聚合邻近性度量，通过排除表达水平低于某一阈值的节点来整合组织特异性蛋白质组约束，然后根据跨组织的、源自蛋白质组学的靶点参与度指标来验证邻近性的变化。所有计算必须在明确指定的小型图上执行，以确保可复现性。\n\n从以下基本原理开始，您应使用这些原理来推导出一个严谨的算法：\n- 蛋白质-蛋白质相互作用网络表示为一个无向简单图，其节点集为 $V$，大小为 $|V| = n$，边集为 $E \\subseteq V \\times V$。节点 $u \\in V$ 和 $v \\in V$ 之间的最短路径距离 $d(u,v)$ 定义为图中连接 $u$ 和 $v$ 的任何路径中的最小边数。如果不存在路径，根据纯粹的定义，该距离是未定义的；为了实现稳健的聚合，您必须通过设定一个最大值上限 $d_{\\max}$ 来定义一个有效的有限距离，选择 $d_{\\max} = n$，并在任何出现不连通的情况下使用此上限。\n- 疾病模块是子集 $D \\subseteq V$，药物的靶点集是子集 $T \\subseteq V$。组织将通过为给定组织中的每个节点 $i \\in V$ 提供一个表达水平 $x_i \\in \\mathbb{R}_{\\ge 0}$ 和一个表达阈值 $\\tau \\in \\mathbb{R}_{\\ge 0}$ 来建模为对 $V$ 的约束。组织特异性网络是通过排除表达水平严格低于阈值的节点（即，如果 $x_i \\ge \\tau$，则保留节点 $i$）及其所有关联边而形成的。\n- 源自蛋白质组学的靶点参与度（首次出现）指标（Protein Target Engagement, PTE）将作为每个组织一个连续值 $y_t \\in \\mathbb{R}$ 的向量提供。验证将通过计算跨组织的邻近性变化与参与度值之间的相关性来执行。请使用对单调但非线性关系具有稳健性的基于秩的相关性。\n\n您的推导必须从这些基础出发，不假设任何快捷公式。具体来说：\n1.  仅从最短路径定义 $d(u,v)$ 出发，推导一个有原则的聚合量，该量能够捕捉药物靶点集 $T$ 与疾病模块 $D$ 在图中的邻近程度。您的聚合量必须是集合对集合的，依赖于 $d(u,v)$，并且即使在某些节点不连通的情况下，通过采用上限 $d_{\\max} = n$ 也能保持良定义。\n2.  定义组织特异性蛋白质组约束如何通过移除表达量 $x_i < \\tau$ 的节点来改变图，并因此改变聚合邻近性。如果 $T$ 中的任何靶点因约束而被移除，您的聚合量必须仍然可以通过明确处理缺失的靶点来计算；同样，如果 $D$ 中的所有疾病节点都被移除，您的聚合量必须通过 $d_{\\max}$ 保持定义。\n3.  定义完整图上的基线（无约束）邻近性、约束图上的组织特异性邻近性，以及邻近性变化 $\\Delta$ 为组织特异性邻近性减去基线邻近性。为了根据 PTE 进行验证，计算 $-\\Delta$ 与跨组织的 PTE 值之间的基于秩的相关性，其解释为：相对于基线，更小的组织特异性邻近性（即负 $\\Delta$）应与更强的参与度一致。\n4.  将您的推导实现为一个完整的程序，该程序对下面定义的每个测试用例，计算跨组织的相关性，并以浮点数形式返回相关系数。\n\n重要的实现细节：\n- 使用无权、无向最短路径距离。\n- 对于任何不可达的源-靶点，或者如果疾病集在某个组织中变为空集，请使用上限 $d_{\\max} = n$。\n- 如果某个靶点 $t \\in T$ 在某个组织中缺失（由于 $x_t < \\tau$），您必须将其对聚合的贡献视为 $d_{\\max}$。\n- 使用斯皮尔曼等级相关性（Spearman’s rank correlation）进行验证，这是一种被广泛接受的非参数度量。\n\n测试套件规范：\n您必须实现并评估以下四个测试用例。每个用例使用一个小型图、指定的靶点集和疾病集、三个组织及其每个节点的表达量和每个用例一个共同的阈值，以及一个包含三个实数值的 PTE 向量。所有索引和数值都已明确提供，必须完全按照给定的方式使用。\n\n- 测试用例 1（选择性节点移除的正常流程）：\n  - 节点：$n = 8$，标记为 $0,1,2,3,4,5,6,7$。\n  - 边 $E$：$(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(0,7),(1,5),(2,6)$。\n  - 靶点 $T = \\{0,5\\}$，疾病 $D = \\{3,7\\}$。\n  - 组织和表达量，阈值 $\\tau = 0.5$：\n    - 组织 A：$[1.0,0.8,0.7,0.9,0.4,1.0,0.6,1.0]$。\n    - 组织 B：$[0.9,0.7,0.8,0.6,0.9,1.0,0.8,0.3]$。\n    - 组织 C：$[0.4,0.6,0.9,1.0,0.7,1.0,0.9,0.9]$。\n  - 跨组织的 PTE 向量：$[0.6,0.2,0.1]$。\n\n- 测试用例 2（移除疾病节点及可能出现空疾病集的情况）：\n  - 节点：$n = 6$，标记为 $0,1,2,3,4,5$。\n  - 边 $E$：$(0,1),(1,2),(2,3),(3,4),(4,5),(1,4)$。\n  - 靶点 $T = \\{1,4\\}$，疾病 $D = \\{0,5\\}$。\n  - 组织和表达量，阈值 $\\tau = 0.5$：\n    - 组织 A：$[0.2,1.0,0.9,0.9,1.0,0.8]$。\n    - 组织 B：$[0.9,1.0,0.8,0.7,0.9,0.4]$。\n    - 组织 C：$[0.2,1.0,0.7,0.7,1.0,0.4]$。\n  - 跨组织的 PTE 向量：$[0.5,0.4,0.0]$。\n\n- 测试用例 3（组织中靶点集为空及路径中断的情况）：\n  - 节点：$n = 5$，标记为 $0,1,2,3,4$。\n  - 边 $E$：$(0,1),(1,2),(2,3),(3,4)$。\n  - 靶点 $T = \\{0,2\\}$，疾病 $D = \\{3\\}$。\n  - 组织和表达量，阈值 $\\tau = 0.5$：\n    - 组织 A：$[0.4,0.4,0.3,0.9,0.9]$。\n    - 组织 B：$[1.0,0.4,1.0,1.0,1.0]$。\n    - 组织 C：$[1.0,1.0,1.0,1.0,1.0]$。\n  - 跨组织的 PTE 向量：$[0.05,0.4,0.7]$。\n\n- 测试用例 4（靶点与疾病之间的重叠及移除重叠节点）：\n  - 节点：$n = 6$，标记为 $0,1,2,3,4,5$。\n  - 边 $E$：$(0,1),(1,2),(2,3),(3,4),(4,5)$。\n  - 靶点 $T = \\{2,5\\}$，疾病 $D = \\{2,4\\}$。\n  - 组织和表达量，阈值 $\\tau = 0.5$：\n    - 组织 A：$[1.0,1.0,0.4,1.0,1.0,1.0]$。\n    - 组织 B：$[1.0,1.0,1.0,1.0,0.4,1.0]$。\n    - 组织 C：$[1.0,1.0,1.0,1.0,1.0,1.0]$。\n  - 跨组织的 PTE 向量：$[0.1,0.4,0.9]$。\n\n程序输出规范：\n- 对于每个测试用例，计算完整图上的基线邻近性、三个组织的组织特异性邻近性、每个组织的邻近性变化 $\\Delta$，然后计算向量 $-\\Delta$ 与给定三个组织的 PTE 向量之间的斯皮尔曼相关系数。将四个相关系数按测试用例的顺序聚合到一个 Python 列表中并打印此列表。\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[result1,result2,result3,result4]$）。", "solution": "该问题要求推导并实现一个计算流程，利用网络邻近性来评估药物-疾病关系，并受组织特异性蛋白质组数据的调节。此模型的验证通过计算跨不同组织的邻近性变化与实验指标“蛋白质靶点参与度 (PTE)”之间的相关性来完成。整个过程必须基于基本的图论定义。\n\n### 基于原理的推导与算法设计\n\n**1. 聚合邻近性度量 $P(T, D)$**\n\n问题要求一个有原则的聚合量，用于在蛋白质-蛋白质相互作用网络（表示为图 $G=(V, E)$）中衡量药物靶点集 $T \\subseteq V$ 与疾病模块 $D \\subseteq V$ 的接近程度。该度量必须基于最短路径距离 $d(u,v)$。\n\n一个自然的起点是定义单个靶点节点 $t \\in T$ 到整个疾病集 $D$ 的距离。这在逻辑上被定义为从 $t$ 到 $D$ 中任何节点的最短距离：\n$$d(t, D) = \\min_{d \\in D} d(t, d)$$\n这个量 $d(t, D)$ 代表了单个靶点与疾病模块的邻近性。\n\n为了将这些单独的邻近性聚合成一个针对整个靶点集 $T$ 的单一集合级别度量，一种简单且有原则的方法是计算所有靶点 $t \\in T$ 的个体邻近性的算术平均值。这得出了靶点集到疾病模块的平均邻近性。我们将这个聚合邻近性 $P(T, D)$ 定义为：\n$$P(T, D) = \\frac{1}{|T|} \\sum_{t \\in T} d(t, D)$$\n其中 $|T|$ 是靶点的数量。这个定义是集合对集合的，并且如要求直接从最短路径距离 $d(u,v)$ 推导而来。\n\n问题规定了使用上限 $d_{\\max} = n$ 来处理不连通节点和空集，其中 $n = |V|$ 是原始图中的总节点数。\n- 如果一个靶点 $t$ 与 $D$ 中的所有节点都不连通，那么对于所有 $d \\in D$， $d(t,d)$ 都是无限大。在这种情况下，我们设置 $d(t, D) = d_{\\max}$。\n- 如果疾病集 $D$ 为空，则最小值未定义。我们遵循问题的规则，对于任何靶点 $t$，设置 $d(t, D) = d_{\\max}$。\n\n**2. 整合组织特异性约束**\n\n组织特异性是通过根据节点表达水平过滤网络来引入的。对于一个给定的组织，其每个节点 $i \\in V$ 都有表达值 $x_i$ 和一个阈值 $\\tau$，可以构建组织特异性图 $G_{\\text{tissue}}$。\n组织中存在的节点集是 $V_{\\text{tissue}} = \\{i \\in V \\mid x_i \\ge \\tau\\}$。图 $G_{\\text{tissue}}$ 是由 $V_{\\text{tissue}}$ 诱导的 $G$ 的子图。\n\n计算组织特异性邻近性 $P_{\\text{tissue}}(T, D)$ 必须考虑 $T$ 或 $D$ 中的节点被移除的情况。问题规定聚合必须仍然基于原始靶点集 $T$。\n每个原始靶点 $t \\in T$ 对组织特异性邻近性的贡献定义如下：\n- 如果靶点 $t$ 从网络中被移除（即 $t \\notin V_{\\text{tissue}}$），其对总距离的贡献被明确定义为 $d_{\\max}$。\n- 如果靶点 $t$ 存在于网络中（即 $t \\in V_{\\text{tissue}}$），其邻近性是相对于同样存在的疾病节点 $D_{\\text{tissue}} = D \\cap V_{\\text{tissue}}$ 计算的。距离 $d_{G_{\\text{tissue}}}(t, d)$ 是在子图 $G_{\\text{tissue}}$ 的上下文中计算的。\n  - 如果 $D_{\\text{tissue}}$ 为空，靶点 $t$ 的贡献是 $d_{\\max}$。\n  - 如果 $D_{\\text{tissue}}$ 不为空，贡献是 $\\min_{d \\in D_{\\text{tissue}}} d_{G_{\\text{tissue}}}(t, d)$。如果在 $G_{\\text{tissue}}$ 中 $t$ 与 $D_{\\text{tissue}}$ 中的所有节点都不连通，此值将被上限 $d_{\\max}$ 替代。\n\n结合这些规则，组织特异性邻近性为：\n$$P_{\\text{tissue}}(T, D) = \\frac{1}{|T|} \\sum_{t \\in T} d_{\\text{tissue}}(t, D; V_{\\text{tissue}})$$\n其中 $d_{\\text{tissue}}(t, D; V_{\\text{tissue}})$ 是如上定义的靶点 $t$ 的贡献。\n\n**3. 通过邻近性变化和相关性进行验证**\n\n验证步骤将邻近性的变化与 PTE 指标进行比较。\n- **基线邻近性, $P_{\\text{baseline}}$**：这是在完整的、无约束的图 $G$ 上计算的邻近性 $P(T, D)$。\n- **组织特异性邻近性, $P_k$**：这是为每个组织 $k$ 计算的邻近性，使用相应的组织特异性图 $G_k$。\n- **邻近性变化, $\\Delta_k$**：对于每个组织 $k$，变化为 $\\Delta_k = P_k - P_{\\text{baseline}}$。一个正的 $\\Delta_k$ 表明在该组织的背景下，靶点变得离疾病模块“更远”。\n\n假设是，组织中更强的靶点参与度（更高的 PTE）应对应于更大的邻近性减少（更负的 $\\Delta$）。因此，我们期望 PTE 值 $y_k$ 与负的邻近性变化 $-\\Delta_k$ 之间存在正相关。\n问题指定使用斯皮尔曼等级相关系数 $\\rho$，这是一种对非线性关系具有稳健性的非参数度量。它通过计算秩转换后变量的皮尔逊相关系数得到。对于一组 $m$ 个组织，我们计算：\n$$\\rho = \\text{SpearmanCorr}(\\{-\\Delta_k\\}_{k=1}^m, \\{y_k\\}_{k=1}^m)$$\n\n### 算法实现\n\n解决单个测试用例的逐步算法如下：\n\n1.  **初始化**：给定图数据（$n$, $E$）、集合（$T$, $D$）和组织数据（表达量、$\\tau$、PTE 向量）。设置 $d_{\\max} = n$。\n2.  **最短路径计算**：在无权图上，距离 $d(u,v)$ 是最短路径中的边数。对于给定的图上下文（完整的或组织特异性的），我们可以计算这些距离。从每个所需源节点开始的广度优先搜索 (BFS) 是高效的。\n3.  **邻近性计算函数**：一个函数 `calculate_proximity(n, edges, T, D, nodes_present)` 将实现上述推导的逻辑。\n    a. 它接收主节点数 $n$、所有原始边 $E$、原始集合 $T$ 和 $D$，以及当前上下文的节点集 `nodes_present`。\n    b. 它为由 `nodes_present` 诱导的子图构建一个邻接表。\n    c. 它确定当前疾病集 $D_{\\text{context}} = D \\cap \\text{nodes\\_present}$。\n    d. 初始化总距离和为 $0$。\n    e. 遍历每个靶点 $t \\in T$：\n        i. 如果 $t \\notin \\text{nodes\\_present}$ 或者 $D_{\\text{context}}$ 为空，将 $d_{\\max}$ 加入总和。\n        ii. 否则，在子图上从 $t$ 开始运行 BFS，以找到它到所有可达节点的距离。\n        iii. 找到从 $t$ 到 $D_{\\text{context}}$ 中任何节点的最小距离。如果 $D_{\\text{context}}$ 中的所有节点都不可达，则此距离为 $d_{\\max}$。将此最小距离加入总和。\n    f. 返回总和除以 $|T|$。\n4.  **主执行流程**：\n    a. 通过调用邻近性函数并传入所有节点来计算 $P_{\\text{baseline}}$。\n    b. 创建一个空列表用于存放组织特异性邻近性，`tissue_proximities`。\n    c. 对于每个组织的表达数据：\n        i. 确定 `nodes_present` 集合，其中 $x_i \\ge \\tau$。\n        ii. 使用此集合调用邻近性函数以获得 $P_k$。\n        iii. 将 $P_k$ 添加到 `tissue_proximities`。\n    d. 计算向量 $\\mathbf{\\Delta} = [P_k - P_{\\text{baseline}} \\text{ for } P_k \\text{ in } \\text{tissue\\_proximities}]$。\n    e. 计算向量 $-\\mathbf{\\Delta}$。\n    f. 使用 `scipy.stats.spearmanr` 计算 $-\\mathbf{\\Delta}$ 和给定的 PTE 向量之间的相关性。处理相关性为 `nan`（由于输入向量方差为零）的情况，返回 $0.0$。\n    g. 得到的相关系数即为该测试用例的答案。\n\n这个完整的、逐步的流程严谨地遵循了推导，并遵守了问题陈述中指定的所有约束。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import spearmanr\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n\n    def _calculate_proximity(n_total, all_edges, T, D, nodes_present):\n        \"\"\"\n        Calculates the aggregate proximity of target set T to disease set D\n        in the context of a graph defined by nodes_present.\n        \"\"\"\n        d_max = float(n_total)\n        \n        if not T:\n            return 0.0\n\n        # Build tissue-specific graph using an adjacency list\n        adj_list = {node: [] for node in nodes_present}\n        for u, v in all_edges:\n            if u in nodes_present and v in nodes_present:\n                adj_list[u].append(v)\n                adj_list[v].append(u)\n\n        D_context = D.intersection(nodes_present)\n        total_dist_sum = 0.0\n\n        for t in T:\n            # Case 1: Target is not present in the tissue\n            if t not in nodes_present:\n                total_dist_sum += d_max\n                continue\n\n            # Case 2: Target is present, but disease module is empty in the tissue\n            if not D_context:\n                total_dist_sum += d_max\n                continue\n            \n            # Case 3: Target and disease nodes are present. Use BFS to find shortest paths.\n            q = deque([(t, 0)])\n            # distances from target t to other nodes in the context\n            distances = {node: float('inf') for node in nodes_present}\n            if t in distances:\n                distances[t] = 0\n\n            visited = {t}\n\n            while q:\n                u, dist = q.popleft()\n                for v in adj_list.get(u, []):\n                    if v not in visited:\n                        visited.add(v)\n                        distances[v] = dist + 1\n                        q.append((v, dist + 1))\n            \n            # Find min distance from t to D_context\n            min_dist_for_t = d_max\n            for d in D_context:\n                dist_td = distances.get(d, float('inf'))\n                if dist_td  min_dist_for_t:\n                    min_dist_for_t = dist_td\n            \n            total_dist_sum += min_dist_for_t\n\n        return total_dist_sum / len(T)\n\n    def process_case(case_data):\n        \"\"\"\n        Processes a single test case to compute the correlation.\n        \"\"\"\n        n, edges, T, D, tissues, tau, pte_vector = case_data\n        \n        # Calculate baseline proximity\n        all_nodes = set(range(n))\n        baseline_proximity = _calculate_proximity(n, edges, T, D, all_nodes)\n        \n        tissue_proximities = []\n        for tissue_expr in tissues:\n            nodes_present = {i for i, expr in enumerate(tissue_expr) if expr >= tau}\n            tissue_prox = _calculate_proximity(n, edges, T, D, nodes_present)\n            tissue_proximities.append(tissue_prox)\n            \n        deltas = np.array(tissue_proximities) - baseline_proximity\n        neg_deltas = -deltas\n        \n        # Spearman correlation between -Delta and PTE\n        corr, _ = spearmanr(neg_deltas, pte_vector)\n        \n        # Handle case where correlation is undefined (NaN) due to no variance\n        if np.isnan(corr):\n            return 0.0\n        \n        return corr\n\n    # Test cases defined in the problem\n    test_cases = [\n        (\n            8,  # n\n            {(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (0, 7), (1, 5), (2, 6)},  # E\n            {0, 5},  # T\n            {3, 7},  # D\n            [  # tissues expressions\n                [1.0, 0.8, 0.7, 0.9, 0.4, 1.0, 0.6, 1.0],\n                [0.9, 0.7, 0.8, 0.6, 0.9, 1.0, 0.8, 0.3],\n                [0.4, 0.6, 0.9, 1.0, 0.7, 1.0, 0.9, 0.9],\n            ],\n            0.5,  # tau\n            [0.6, 0.2, 0.1]  # PTE vector\n        ),\n        (\n            6,  # n\n            {(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (1, 4)},  # E\n            {1, 4},  # T\n            {0, 5},  # D\n            [  # tissues expressions\n                [0.2, 1.0, 0.9, 0.9, 1.0, 0.8],\n                [0.9, 1.0, 0.8, 0.7, 0.9, 0.4],\n                [0.2, 1.0, 0.7, 0.7, 1.0, 0.4],\n            ],\n            0.5,  # tau\n            [0.5, 0.4, 0.0]  # PTE vector\n        ),\n        (\n            5,  # n\n            {(0, 1), (1, 2), (2, 3), (3, 4)},  # E\n            {0, 2},  # T\n            {3},  # D\n            [  # tissues expressions\n                [0.4, 0.4, 0.3, 0.9, 0.9],\n                [1.0, 0.4, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0, 1.0],\n            ],\n            0.5,  # tau\n            [0.05, 0.4, 0.7]  # PTE vector\n        ),\n        (\n            6,  # n\n            {(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)},  # E\n            {2, 5},  # T\n            {2, 4},  # D\n            [  # tissues expressions\n                [1.0, 1.0, 0.4, 1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0, 1.0, 0.4, 1.0],\n                [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n            ],\n            0.5,  # tau\n            [0.1, 0.4, 0.9]  # PTE vector\n        ),\n    ]\n\n    results = [process_case(case) for case in test_cases]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "4366944"}]}