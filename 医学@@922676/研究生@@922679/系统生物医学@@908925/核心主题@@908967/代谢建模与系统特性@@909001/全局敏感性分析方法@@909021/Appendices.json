{"hands_on_practices": [{"introduction": "敏感性分析有局部和全局之分，前者在单一“标称”点评估参数影响，而后者则在整个参数空间内进行评估。本练习通过一个简单的解析模型，让您亲手计算并比较这两种方法得出的参数重要性排序。通过这个对比，您将深刻理解为何对于生物医学中常见的、具有非线性和大范围参数不确定性的模型，全局视角是不可或缺的，从而为后续更复杂的全局敏感性分析方法奠定坚实的概念基础 ([@problem_id:4348244])。", "problem": "在系统生物医学中使用的简化通路级抽象中，考虑一个无量纲的读数，其模型为加性输出 $Y=\\sin(X_{1})+X_{2}^{2}$，其中 $X_{1}$ 和 $X_{2}$ 代表独立的上游因子。假设 $X_{1}\\sim\\mathrm{Unif}(0,1)$ 和 $X_{2}\\sim\\mathrm{Unif}(0,1)$ 是独立的，并且三角函数的参数以弧度为单位。这两个输入将根据两种敏感性概念进行排序：\n- 基于梯度的局部排序，评估在名义工作点 $(x_{1}^{\\ast},x_{2}^{\\ast})=(\\tfrac{1}{2},\\tfrac{1}{2})$ 处偏导数的绝对大小。\n- 基于方差的全局排序，使用最初为全局敏感性分析中的独立输入提出的一阶方差敏感性指数，将输出方差中可归因于每个输入的部分分配给该输入。\n\n从期望、方差、独立性和偏导数的基本定义出发，推导模型 $Y=\\sin(X_{1})+X_{2}^{2}$ 的两种排序。然后，报告一个行向量，其中包含在 $(x_{1}^{\\ast},x_{2}^{\\ast})$ 处的局部梯度绝对值，其后是两个一阶方差敏感性指数，顺序为 $\\left(|\\partial Y/\\partial X_{1}|,\\;|\\partial Y/\\partial X_{2}|,\\;S_{1},\\;S_{2}\\right)$。将四个数字中的每一个四舍五入到四位有效数字，并以无单位的形式表示最终的数值。", "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n-   **模型：** 无量纲读数为 $Y=\\sin(X_{1})+X_{2}^{2}$。\n-   **输入：** $X_{1}$ 和 $X_{2}$ 是独立的上游因子。\n-   **分布：** $X_{1}\\sim\\mathrm{Unif}(0,1)$ 和 $X_{2}\\sim\\mathrm{Unif}(0,1)$。正弦函数的参数以弧度为单位。\n-   **局部敏感性分析：** 需要进行基于梯度的局部排序。这涉及在名义工作点 $(x_{1}^{\\ast},x_{2}^{\\ast})=(\\tfrac{1}{2},\\tfrac{1}{2})$ 处评估偏导数的绝对大小 $|\\partial Y/\\partial X_{i}|$。\n-   **全局敏感性分析：** 需要进行基于方差的全局排序。这涉及为每个输入计算一阶方差敏感性指数 $S_i$。\n-   **输出要求：** 报告一个行向量，其中包含按顺序排列的四个值 $\\left(|\\partial Y/\\partial X_{1}|,\\;|\\partial Y/\\partial X_{2}|,\\;S_{1},\\;S_{2}\\right)$，并四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学和数学上是合理的。它在敏感性分析领域提出了一个明确定义的问题，敏感性分析是系统建模（包括系统生物医学）中的标准工具。模型 $Y=\\sin(X_{1})+X_{2}^{2}$ 是一个常见的基准函数。输入由标准概率分布描述。敏感性分析的方法——局部偏导数和全局一阶方差敏感性指数——在文献中有严格的定义。该问题是自洽的、客观的，没有矛盾或歧义。它需要直接应用微积分和概率论。\n\n### 步骤 3：结论与行动\n问题被认为是有效的。将提供一个完整的、有理有据的解答。\n\n***\n\n解答分为两部分，分别对应局部和全局敏感性分析。\n\n### 第一部分：基于梯度的局部敏感性分析\n\n输出 $Y$ 相对于输入 $X_i$ 在特定工作点的局部敏感性，是通过模型函数在该点对该输入的偏导数的量级来量化的。\n\n模型由下式给出：\n$$ Y(X_1, X_2) = \\sin(X_1) + X_2^2 $$\n\n$Y$ 对 $X_1$ 和 $X_2$ 的偏导数是：\n$$ \\frac{\\partial Y}{\\partial X_1} = \\frac{\\partial}{\\partial X_1} \\left( \\sin(X_1) + X_2^2 \\right) = \\cos(X_1) $$\n$$ \\frac{\\partial Y}{\\partial X_2} = \\frac{\\partial}{\\partial X_2} \\left( \\sin(X_1) + X_2^2 \\right) = 2X_2 $$\n\n这些导数在名义工作点 $(x_{1}^{\\ast},x_{2}^{\\ast})=(\\frac{1}{2},\\frac{1}{2})$ 进行评估。\n对于 $X_1$：\n$$ \\left. \\frac{\\partial Y}{\\partial X_1} \\right|_{(1/2, 1/2)} = \\cos\\left(\\frac{1}{2}\\right) $$\n绝对大小为 $|\\cos(\\frac{1}{2})|$。由于 $\\frac{1}{2}$ 弧度在第一象限，$\\cos(\\frac{1}{2})$ 是正的。\n$$ \\left| \\frac{\\partial Y}{\\partial X_1} \\right| = \\cos\\left(\\frac{1}{2}\\right) \\approx 0.87758256... $$\n\n对于 $X_2$：\n$$ \\left. \\frac{\\partial Y}{\\partial X_2} \\right|_{(1/2, 1/2)} = 2 \\times \\frac{1}{2} = 1 $$\n绝对大小为：\n$$ \\left| \\frac{\\partial Y}{\\partial X_2} \\right| = |1| = 1 $$\n\n四舍五入到四位有效数字，局部敏感性度量对于 $X_1$ 是 $0.8776$，对于 $X_2$ 是 $1.000$。局部排序为 $X_2 > X_1$。\n\n### 第二部分：基于方差的全局敏感性分析\n\n全局敏感性分析评估输入在其整个变化范围内的影响。一阶敏感性指数 $S_i$ 衡量了总输出方差 $V(Y)$ 中可归因于输入 $X_i$ 主效应的部分。其定义为：\n$$ S_i = \\frac{V_i}{V(Y)} = \\frac{V(E[Y|X_i])}{V(Y)} $$\n其中 $V_i = V(E[Y|X_i])$ 是 $X_i$ 的一阶效应方差。总方差为 $V(Y) = E[Y^2] - (E[Y])^2$。\n\n模型 $Y=\\sin(X_{1})+X_{2}^{2}$ 是一个形式为 $Y=f_1(X_1) + f_2(X_2)$ 的加性模型，其中 $f_1(X_1) = \\sin(X_1)$ 且 $f_2(X_2) = X_2^2$。由于输入 $X_1$ 和 $X_2$ 是独立的，随机变量 $f_1(X_1)$ 和 $f_2(X_2)$ 也是独立的。对于这样的模型，总方差分解为各项方差之和：\n$$ V(Y) = V(f_1(X_1) + f_2(X_2)) = V(f_1(X_1)) + V(f_2(X_2)) $$\n一阶效应方差也得到简化：\n$V_1 = V(E[Y|X_1]) = V(E[f_1(X_1) + f_2(X_2)|X_1]) = V(f_1(X_1) + E[f_2(X_2)])$。由于 $E[f_2(X_2)]$ 是一个常数，这简化为 $V_1 = V(f_1(X_1))$。\n同样地，$V_2 = V(E[Y|X_2]) = V(f_2(X_2))$。\n\n因此，敏感性指数为：\n$$ S_1 = \\frac{V(f_1(X_1))}{V(f_1(X_1)) + V(f_2(X_2))} $$\n$$ S_2 = \\frac{V(f_2(X_2))}{V(f_1(X_1)) + V(f_2(X_2))} $$\n我们现在必须计算 $V(f_1(X_1)) = V(\\sin(X_1))$ 和 $V(f_2(X_2)) = V(X_2^2)$。\n\n**$V(X_2^2)$ 的计算：**\n$X_2$ 在 $[0, 1]$ 上均匀分布，即 $X_2 \\sim \\mathrm{Unif}(0,1)$。其概率密度函数为 $p(x_2)=1$（对于 $x_2 \\in [0, 1]$）。\n我们需要 $E[X_2^2]$ 和 $E[(X_2^2)^2] = E[X_2^4]$。\n$$ E[X_2^2] = \\int_0^1 x_2^2 p(x_2) \\,dx_2 = \\int_0^1 x_2^2 \\,dx_2 = \\left[ \\frac{x_2^3}{3} \\right]_0^1 = \\frac{1}{3} $$\n$$ E[X_2^4] = \\int_0^1 x_2^4 p(x_2) \\,dx_2 = \\int_0^1 x_2^4 \\,dx_2 = \\left[ \\frac{x_2^5}{5} \\right]_0^1 = \\frac{1}{5} $$\n方差是：\n$$ V(X_2^2) = E[X_2^4] - (E[X_2^2])^2 = \\frac{1}{5} - \\left(\\frac{1}{3}\\right)^2 = \\frac{1}{5} - \\frac{1}{9} = \\frac{9-5}{45} = \\frac{4}{45} $$\n\n**$V(\\sin(X_1))$ 的计算：**\n$X_1$ 也在 $[0, 1]$ 上均匀分布，即 $X_1 \\sim \\mathrm{Unif}(0,1)$。\n我们需要 $E[\\sin(X_1)]$ 和 $E[\\sin^2(X_1)]$。\n$$ E[\\sin(X_1)] = \\int_0^1 \\sin(x_1) \\,dx_1 = [-\\cos(x_1)]_0^1 = -\\cos(1) - (-\\cos(0)) = 1 - \\cos(1) $$\n为了求 $E[\\sin^2(X_1)]$，我们使用恒等式 $\\sin^2(\\theta) = \\frac{1-\\cos(2\\theta)}{2}$。\n$$ E[\\sin^2(X_1)] = \\int_0^1 \\sin^2(x_1) \\,dx_1 = \\int_0^1 \\frac{1-\\cos(2x_1)}{2} \\,dx_1 = \\frac{1}{2} \\left[ x_1 - \\frac{\\sin(2x_1)}{2} \\right]_0^1 $$\n$$ E[\\sin^2(X_1)] = \\frac{1}{2} \\left( \\left(1 - \\frac{\\sin(2)}{2}\\right) - (0-0) \\right) = \\frac{1}{2} - \\frac{\\sin(2)}{4} $$\n方差是：\n$$ V(\\sin(X_1)) = E[\\sin^2(X_1)] - (E[\\sin(X_1)])^2 = \\left(\\frac{1}{2} - \\frac{\\sin(2)}{4}\\right) - (1 - \\cos(1))^2 $$\n\n**数值计算与最终指数：**\n让我们计算数值。\n$V_2 = V(X_2^2) = \\frac{4}{45} \\approx 0.088888...$\n对于 $V_1 = V(\\sin(X_1))$：\n$\\cos(1) \\approx 0.540302$\n$\\sin(2) \\approx 0.909297$\n$V(\\sin(X_1)) \\approx \\left(\\frac{1}{2} - \\frac{0.909297}{4}\\right) - (1 - 0.540302)^2$\n$V(\\sin(X_1)) \\approx (0.5 - 0.227324) - (0.459698)^2$\n$V(\\sin(X_1)) \\approx 0.272676 - 0.211322 \\approx 0.061354$\n所以，$V_1 \\approx 0.061354$。\n\n总方差为 $V(Y) = V_1 + V_2 \\approx 0.061354 + 0.088889 = 0.150243$。\n\n敏感性指数为：\n$$ S_1 = \\frac{V_1}{V(Y)} \\approx \\frac{0.061354}{0.150243} \\approx 0.408366... $$\n$$ S_2 = \\frac{V_2}{V(Y)} \\approx \\frac{0.088889}{0.150243} \\approx 0.591634... $$\n\n四舍五入到四位有效数字，全局敏感性指数为 $S_1 = 0.4084$ 和 $S_2 = 0.5916$。全局排序为 $X_2 > X_1$。\n\n### 结果总结\n所要求的量是：\n1.  在 $(\\frac{1}{2}, \\frac{1}{2})$ 处的 $|\\partial Y/\\partial X_{1}| = \\cos(\\frac{1}{2}) \\approx 0.8776$\n2.  在 $(\\frac{1}{2}, \\frac{1}{2})$ 处的 $|\\partial Y/\\partial X_{2}| = 1 = 1.000$\n3.  $S_1 \\approx 0.4084$\n4.  $S_2 \\approx 0.5916$\n\n最终的行向量由这四个值组成。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.8776  1.000  0.4084  0.5916\n\\end{pmatrix}\n}\n$$", "id": "4348244"}, {"introduction": "从理论转向实践，大多数真实世界的生物医学模型由于其复杂性，无法进行纯粹的解析分析。本练习将指导您应用全局敏感性分析的主力方法——基于蒙特卡洛的 Sobol 指数估计。您将为一个简化的代谢通路模型计算敏感性指数，并利用这些结果来解决一个实际的生物医学问题：在众多不确定性中识别出最稳健的药物干预靶点，从而体验全局敏感性分析在模型引导的科学决策中的强大功用 ([@problem_id:4348228])。", "problem": "给定一个简化的、基于稳态通量的线性代谢途径模型，该途径包含三个不可逆的酶促步骤。该途径通过三种酶（分别记为步骤 $1$、步骤 $2$ 和步骤 $3$）将外部底物转化为最终产物。对于每个步骤 $i \\in \\{1,2,3\\}$，有效通量由一个饱和门近似，该门将输入通量映射为输出通量，这体现了下游通量有界且随上游可用性增加而饱和的思想。该映射被设计为对酶最大速率严格单调递增，对酶饱和参数严格单调递减，这与标准的 Michaelis–Menten 单调性一致，同时在全球敏感性分析中保持计算上的易处理性。\n\n基本原理和定义。设 $Y = f(\\mathbf{X})$ 是一个标量模型输出，它是独立输入参数 $\\mathbf{X} = (X_1,\\dots,X_d)$ 的函数，且其方差 $\\mathrm{Var}(Y)$ 有限。通过基于方差的 Sobol 指数进行的全局敏感性分析由方差分解定义。参数 $X_i$ 的一阶 Sobol 指数为 $S_i = \\mathrm{Var}(\\mathbb{E}[Y \\mid X_i]) / \\mathrm{Var}(Y)$。参数 $X_i$ 的全阶 Sobol 指数为 $S_{T_i} = 1 - \\mathrm{Var}(\\mathbb{E}[Y \\mid \\mathbf{X}_{-i}]) / \\mathrm{Var}(Y)$，其中 $\\mathbf{X}_{-i}$ 表示除 $X_i$ 之外的所有参数。这些指数分别量化了 $X_i$ 的独立主效应以及包括高阶交互作用在内的 $X_i$ 的总体效应。使用 Saltelli–Jansen 方案的蒙特卡罗估计量在独立抽样条件下为这些量提供了相合的近似。\n\n模型与参数。外部底物可用性是一个固定的非负标量 $S_{\\mathrm{in}}$。酶促步骤由最大速率 $V_1$、$V_2$、$V_3$ 和饱和参数 $K_1$、$K_2$、$K_3$ 参数化。途径通量 $J$ 递归定义如下\n$$\nv_1 \\;=\\; \\frac{V_1\\, S_{\\mathrm{in}}}{K_1 + S_{\\mathrm{in}}},\\quad\nv_2 \\;=\\; \\frac{V_2\\, v_1}{K_2 + v_1},\\quad\nv_3 \\;=\\; \\frac{V_3\\, v_2}{K_3 + v_2},\\quad\nJ \\;=\\; v_3.\n$$\n所有量均为无量纲。不确定参数是独立的，并在指定区间上服从均匀分布。您将使用带有 Saltelli–Jansen 估计量的蒙特卡罗抽样方法，为每个参数 $V_1, K_1, V_2, K_2, V_3, K_3$ 估计一阶和全阶 Sobol 指数。对于给定的样本量 $N$，构建两个独立的样本矩阵 $\\mathbf{A}, \\mathbf{B} \\in [0,1]^{N \\times d}$，通过仿射映射将每列变换到其物理范围，并计算以下估计量\n$$\n\\widehat{\\mathrm{Var}}(Y) \\;=\\; \\mathrm{Var}\\big(\\{f(\\mathbf{A}), f(\\mathbf{B})\\}\\big),\\quad\n\\widehat{S}_i \\;=\\; \\frac{\\frac{1}{N}\\sum_{n=1}^{N} f(\\mathbf{B}^{(n)})\\,\\big(f(\\mathbf{A}_{B_i}^{(n)}) - f(\\mathbf{A}^{(n)})\\big)}{\\widehat{\\mathrm{Var}}(Y)},\n$$\n$$\n\\widehat{S}_{T_i} \\;=\\; \\frac{\\frac{1}{N}\\sum_{n=1}^{N} \\big(f(\\mathbf{A}^{(n)}) - f(\\mathbf{A}_{B_i}^{(n)})\\big)^2}{2\\,\\widehat{\\mathrm{Var}}(Y)},\n$$\n其中 $\\mathbf{A}_{B_i}$ 是将矩阵 $\\mathbf{A}$ 的第 $i$ 列替换为矩阵 $\\mathbf{B}$ 的第 $i$ 列后得到的矩阵，而 $f(\\cdot)$ 表示在参数矢量处计算的通量 $J$。\n\n治疗靶点解读。假设一种治疗性抑制会降低某个步骤 $i$ 的 $V_i$，而其他参数在其先验范围内仍然不确定。由于 $J$ 对每个 $V_i$ 都是严格单调递增的，因此 $V_i$ 的全阶指数 $\\widehat{S}_{T_i}$ 越大，表明 $V_i$ 对通量变异性的总体影响（包括交互作用）越强。一个稳健的治疗靶点是步骤索引 $i \\in \\{1,2,3\\}$，其对应的 $V_i$ 具有最大的全阶指数，因为降低该 $V_i$ 将在各种不确定性下最强且最稳健地降低 $J$。\n\n测试套件。使用以下三个测试用例来探究不同的情景：\n- 用例 $1$（平衡情景）：$S_{\\mathrm{in}} = 1.0$，$V_1, V_2, V_3 \\sim \\mathcal{U}[0.5,2.0]$，$K_1, K_2, K_3 \\sim \\mathcal{U}[0.1,1.0]$，样本量 $N=8000$。\n- 用例 $2$（下游限制情景）：$S_{\\mathrm{in}} = 1.0$，$V_1, V_2 \\sim \\mathcal{U}[1.0,2.0]$，$V_3 \\sim \\mathcal{U}[0.1,0.5]$，$K_1, K_2, K_3 \\sim \\mathcal{U}[0.2,1.2]$，样本量 $N=8000$。\n- 用例 $3$（上游限制且第一步弱饱和情景）：$S_{\\mathrm{in}} = 0.5$，$V_1 \\sim \\mathcal{U}[0.4,1.2]$，$V_2, V_3 \\sim \\mathcal{U}[1.0,2.0]$，$K_1 \\sim \\mathcal{U}[1.0,5.0]$，$K_2, K_3 \\sim \\mathcal{U}[0.1,0.5]$，样本量 $N=8000$。\n\n最终输出规范。对于每个测试用例，计算 $V_1、V_2$ 和 $V_3$ 的全阶指数 $\\widehat{S}_{T_i}$，并选择稳健的治疗靶点，即这三个全阶指数中最大值所对应的整数步骤索引 $i \\in \\{1,2,3\\}$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[i_1,i_2,i_3]$），其中 $i_1、i_2$ 和 $i_3$ 分别是用例 $1、2$ 和 $3$ 的选定靶点。不涉及物理单位；所有量都是无量纲的。不使用角度。不使用百分比。所有数值结果均为指定的整数。", "solution": "该问题被认为是有效的，因为它具有科学依据、是适定且客观的。它基于系统生物学和全局敏感性分析的既定原则，提出了一个明确的计算任务。所有必要的数据和定义均已提供。\n\n目标是通过使用全局敏感性分析（GSA），在一个简化的三步代谢途径模型中，识别出最稳健的治疗靶点。治疗靶点被定义为酶促步骤 $i \\in \\{1, 2, 3\\}$，其最大速率 $V_i$ 具有最大的全阶 Sobol 指数 $S_{T_i}$。该指数定量地描述了 $V_i$ 对输出方差的总贡献，包括其直接效应以及与其他所有不确定参数相互作用产生的效应。本分析将针对三种不同的参数情景，采用蒙特卡罗估计方法进行。\n\n该模型描述了通过一条线性途径的稳态通量 $J$。该通量是一系列三个不可逆酶促步骤的输出，其中一个步骤的输出是下一个步骤的输入。系统由以下方程定义：\n$$v_1 = \\frac{V_1 S_{\\mathrm{in}}}{K_1 + S_{\\mathrm{in}}}$$\n$$v_2 = \\frac{V_2 v_1}{K_2 + v_1}$$\n$$v_3 = \\frac{V_3 v_2}{K_3 + v_2}$$\n最终通量，即模型输出 $Y$，由 $J = v_3$ 给出。该模型有 $d=6$ 个不确定输入参数 $\\mathbf{X} = (V_1, K_1, V_2, K_2, V_3, K_3)$，这些参数被假定为独立的，并在指定范围内均匀分布。与问题描述一致，我们将在实现中将这些参数分配给索引 $0$ 到 $5$。用于靶点选择的目标参数是 $V_1、V_2$ 和 $V_3$，对应于索引 $i=0, 2, 4$。\n\n为了估计 Sobol 指数，我们将实现 Saltelli-Jansen 方案，这是一种广泛使用的基于方差的蒙特卡罗方法。对于给定的样本量 $N$，其步骤如下：\n\n1.  **样本生成**：生成两个大小为 $N \\times d$ 的独立样本矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$。这些矩阵中的每个元素都从标准均匀分布 $\\mathcal{U}[0,1]$ 中抽取。\n\n2.  **参数缩放**：必须将单位超立方体中的样本变换到其物理参数范围。对于每个参数 $X_i \\sim \\mathcal{U}[a_i, b_i]$，一个样本 $x_{u} \\in [0,1]$ 被缩放为 $x_{p} = a_i + (b_i - a_i)x_{u}$。此仿射变换应用于 $\\mathbf{A}$ 和 $\\mathbf{B}$ 的每一列，以创建物理参数矩阵 $\\mathbf{A}_{\\text{scaled}}$ 和 $\\mathbf{B}_{\\text{scaled}}$。\n\n3.  **模型评估**：对 $\\mathbf{A}_{\\text{scaled}}$ 和 $\\mathbf{B}_{\\text{scaled}}$ 中的每一行（参数集）评估代谢模型 $f(\\mathbf{X}) = J$，得到两个长度为 $N$ 的输出值向量 $f(\\mathbf{A})$ 和 $f(\\mathbf{B})$。\n\n4.  **总方差估计**：模型输出的总方差 $\\mathrm{Var}(Y)$ 是根据 $2N$ 个模型评估的组合集来估计的。样本方差计算如下：\n    $$\\widehat{\\mathrm{Var}}(Y) = \\mathrm{Var}\\big(\\{f(\\mathbf{A}), f(\\mathbf{B})\\}\\big)$$\n    这是通过连接 $f(\\mathbf{A})$ 和 $f(\\mathbf{B})$ 向量并计算标准样本方差（分母为 $2N-1$）来实现的。\n\n5.  **全阶指数估计**：为了估计参数 $X_i$ 的全阶指数 $\\widehat{S}_{T_i}$，需要创建一个额外的矩阵 $\\mathbf{A}_{B_i}$。该矩阵是 $\\mathbf{A}$ 的一个副本，但其第 $i$ 列被替换为 $\\mathbf{B}$ 的第 $i$ 列。然后对这个新矩阵的缩放版本中的每个参数集评估模型，得到输出向量 $f(\\mathbf{A}_{B_i})$。接着，使用所提供的 Jansen 估计量来估计全阶指数：\n    $$\\widehat{S}_{T_i} = \\frac{\\frac{1}{N}\\sum_{n=1}^{N} \\big(f(\\mathbf{A}^{(n)}) - f(\\mathbf{A}_{B_i}^{(n)})\\big)^2}{2\\,\\widehat{\\mathrm{Var}}(Y)}$$\n    对每个目标参数：$V_1$（索引 $i=0$）、$V_2$（索引 $i=2$）和 $V_3$（索引 $i=4$），执行此计算。\n\n6.  **靶点识别**：对于三个测试用例中的每一个，我们计算 $V_1、V_2$ 和 $V_3$ 的 $\\widehat{S}_{T}$。稳健的治疗靶点是步骤索引（$1、2$ 或 $3$），其对应的参数 $V_i$ 具有最高的 $\\widehat{S}_{T_i}$ 值。\n\n该实现将使用 Python 和 `numpy` 库进行，以实现高效的向量化计算。使用固定的随机种子来确保随机蒙特卡罗模拟是可复现的。算法将遍历三个测试用例中的每一个，执行敏感性分析，为每个用例确定最佳靶点，并汇编成一个最终的结果列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs global sensitivity analysis for a metabolic pathway model to find\n    the most robust therapeutic target for three different parameter regimes.\n    \"\"\"\n    # Set a random seed for reproducibility of the Monte Carlo simulation.\n    np.random.seed(42)\n\n    def model(params, S_in):\n        \"\"\"\n        Computes the flux J for a given set of parameters.\n        The function is vectorized to handle N-dimensional parameter arrays.\n        Parameter order: V1, K1, V2, K2, V3, K3\n        \"\"\"\n        # params is an (N, 6) numpy array. We transpose and unpack.\n        V1, K1, V2, K2, V3, K3 = params.T\n\n        v1 = (V1 * S_in) / (K1 + S_in)\n        v2 = (V2 * v1) / (K2 + v1)\n        v3 = (V3 * v2) / (K3 + v2)\n        J = v3\n        return J\n\n    def scale_samples(samples, bounds):\n        \"\"\"\n        Scales samples from the unit hypercube [0, 1]^d to their physical ranges.\n        \"\"\"\n        N, d = samples.shape\n        scaled = np.zeros_like(samples)\n        for i in range(d):\n            min_val, max_val = bounds[i]\n            scaled[:, i] = min_val + samples[:, i] * (max_val - min_val)\n        return scaled\n\n    # Define the three test cases as specified in the problem statement.\n    # Parameter order is [V1, K1, V2, K2, V3, K3].\n    test_cases = [\n        {\n            \"name\": \"Case 1 (balanced)\",\n            \"S_in\": 1.0,\n            \"N\": 8000,\n            \"bounds\": [\n                (0.5, 2.0), (0.1, 1.0), (0.5, 2.0),\n                (0.1, 1.0), (0.5, 2.0), (0.1, 1.0)\n            ],\n        },\n        {\n            \"name\": \"Case 2 (downstream-limited)\",\n            \"S_in\": 1.0,\n            \"N\": 8000,\n            \"bounds\": [\n                (1.0, 2.0), (0.2, 1.2), (1.0, 2.0),\n                (0.2, 1.2), (0.1, 0.5), (0.2, 1.2)\n            ],\n        },\n        {\n            \"name\": \"Case 3 (upstream-limited)\",\n            \"S_in\": 0.5,\n            \"N\": 8000,\n            \"bounds\": [\n                (0.4, 1.2), (1.0, 5.0), (1.0, 2.0),\n                (0.1, 0.5), (1.0, 2.0), (0.1, 0.5)\n            ],\n        },\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        S_in = case[\"S_in\"]\n        bounds = case[\"bounds\"]\n        d = len(bounds)\n\n        # 1. Generate two independent sample matrices A and B from U[0,1]\n        A_unit = np.random.rand(N, d)\n        B_unit = np.random.rand(N, d)\n\n        # 2. Scale samples to their physical ranges\n        A_scaled = scale_samples(A_unit, bounds)\n        B_scaled = scale_samples(B_unit, bounds)\n\n        # 3. Evaluate the model for matrices A and B\n        y_A = model(A_scaled, S_in)\n        y_B = model(B_scaled, S_in)\n\n        # 4. Estimate the total variance Var(Y) from the combined outputs\n        # We use the sample variance (ddof=1) over the 2N samples.\n        var_Y = np.var(np.concatenate([y_A, y_B]), ddof=1)\n        \n        # Handle the edge case of zero variance to prevent division by zero\n        if var_Y  1e-12: # Using a small tolerance for floating point comparison\n            # If variance is zero, all sensitivity indices are zero.\n            # The choice of target is arbitrary; we can default to 1.\n            final_results.append(1)\n            continue\n            \n        total_indices = {}\n        # The parameters of interest are V1, V2, V3.\n        # Their indices in the parameter array are 0, 2, 4.\n        # We map these to the therapeutic target step indices 1, 2, 3.\n        v_indices_map = {0: 1, 2: 2, 4: 3}\n\n        for param_idx, step_idx in v_indices_map.items():\n            # 5. Construct matrix A_B_i and evaluate the model\n            A_B_i_scaled = A_scaled.copy()\n            A_B_i_scaled[:, param_idx] = B_scaled[:, param_idx]\n            \n            y_A_B_i = model(A_B_i_scaled, S_in)\n            \n            # 6. Estimate the total-order index S_T_i\n            numerator = np.mean((y_A - y_A_B_i)**2)\n            s_ti = numerator / (2 * var_Y)\n            total_indices[step_idx] = s_ti\n\n        # 7. Identify the step with the maximum total-order index\n        best_target = max(total_indices, key=total_indices.get)\n        final_results.append(best_target)\n\n    # Print the results in the required format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "4348228"}, {"introduction": "许多关键的生物过程是动态的，通常由常微分方程 ($ODE$) 描述。本练习将带您进入一个高级主题：如何对这类动态系统进行全局敏感性分析。您将学习并实现一种基于导数的全局敏感性度量 ($DGSM$)，并掌握一项强大的计算技术——自动微分 ($AD$)，它能够精确计算通过数值求解器传播的导数。完成此练习后，您将具备分析复杂动态生物系统的先进技能，并理解如何将敏感性分析扩展到时间依赖的模型中 ([@problem_id:4348260])。", "problem": "给定一个常微分方程（ODE）模型，用于描述一个具有参数和恒定输入的两阶段生物分子信号级联。模型的状态是上游激活 $X(t)$ 和下游激活 $Z(t)$，它们根据以下系统演化：\n$$\n\\frac{dX}{dt} = k_1 \\cdot \\frac{I}{K_I + I} \\cdot \\left(1 - X\\right) - k_2 \\cdot X,\n\\qquad\n\\frac{dZ}{dt} = k_3 \\cdot X \\cdot \\left(1 - Z\\right) - k_4 \\cdot Z,\n$$\n初始条件为 $X(0) = 0$ 和 $Z(0) = 0$，恒定输入为 $I = 1$（无量纲）。参数为 $\\theta = \\left[k_1, K_I, k_2, k_3, k_4\\right]$。感兴趣的可观测量是在一个固定的最终时间 $T$ 时的下游激活，即 $F(\\theta) = Z(T;\\theta)$。\n\n从系统生物医学中的全局敏感性分析的角度来看，研究人员寻求能够量化参数可变性如何影响可观测量可变性的度量。一个广泛使用的类别是基于导数的全局敏感性度量（DGSMs），其中对于每个参数索引 $i$，在指定的参数先验下，考虑可观测量相对于参数 $\\theta_i$ 的期望平方敏感性。\n\n您的任务是通过以下方式，为每个参数 $\\theta_i$ 实现类 DGSM 量 $G_i$ 的完整计算：\n- 通过 ODE 时间步进算法，使用自动微分（AD）对数值解映射 $\\theta \\mapsto Z(T;\\theta)$ 相对于 $\\theta$ 进行微分，并且\n- 通过对参数先验的确定性采样（作为蒙特卡洛积分）来平均偏导数的平方。\n\n形式上，将 $G_i$ 视为偏导数平方期望的蒙特卡洛估计，即在从先验中抽取的样本 $\\theta^{(m)}$ 上 $\\left(\\frac{\\partial F}{\\partial \\theta_i}\\right)^2$ 的经验平均值，其中导数是通过将前向模式 AD 应用于数值 ODE 积分器获得的。\n\n您必须完全在代码中实现以下内容，无需用户输入：\n- 一种前向模式 AD 机制，通过对上述 ODE 系统的 Runge–Kutta 4 (RK4) 积分器进行微分，同时传播 $Z(T)$ 相对于所有参数 $\\theta_i$ 的导数。AD 必须集成到数值解中，而不是通过有限差分计算。\n- 使用低差异序列构造（例如，Halton 型序列）对参数先验进行确定性采样，并映射到下面指定的参数范围。\n- 对于每个测试用例，计算 $i = 1,\\dots,5$ 的 $G_i$，作为样本集上 $\\left(\\frac{\\partial F}{\\partial \\theta_i}\\right)^2$ 的平均值。\n\n使用以下三个测试用例（每个测试用例都必须执行并产生结果）：\n\n- 测试用例 1（一般“正常路径”）：\n  - 先验范围（在闭区间上均匀分布）：$k_1 \\in [0.1, 1.0]$, $K_I \\in [0.05, 0.5]$, $k_2 \\in [0.05, 0.5]$, $k_3 \\in [0.1, 1.0]$, $k_4 \\in [0.05, 0.5]$。\n  - 样本数量：$200$。\n  - 最终时间：$T = 10$。\n  - 固定时间步长：$\\Delta t = 0.01$。\n  - 初始条件：$X(0) = 0$, $Z(0) = 0$。\n\n- 测试用例 2（边界采样情况）：\n  - 与测试用例 1 相同的先验范围。\n  - 样本数量：$1$。\n  - 最终时间：$T = 10$。\n  - 固定时间步长：$\\Delta t = 0.01$。\n  - 初始条件：$X(0) = 0$, $Z(0) = 0$。\n\n- 测试用例 3（饱和常数范围接近零的边缘情况）：\n  - 先验范围（在闭区间上均匀分布）：$k_1 \\in [0.1, 1.0]$, $K_I \\in [10^{-6}, 10^{-4}]$, $k_2 \\in [0.05, 0.5]$, $k_3 \\in [0.1, 1.0]$, $k_4 \\in [0.05, 0.5]$。\n  - 样本数量：$50$。\n  - 最终时间：$T = 10$。\n  - 固定时间步长：$\\Delta t = 0.02$。\n  - 初始条件：$X(0) = 0$, $Z(0) = 0$。\n\n实现要求：\n- 自动微分必须通过前向模式对偶数实现，该对偶数携带相对于 $\\theta$ 中所有参数的完整导数向量。\n- ODE 必须使用经典的 Runge–Kutta 4 方法以固定时间步长 $\\Delta t$ 进行积分，并且 AD 必须通过积分器中的所有算术运算进行传播。\n- 先验的采样必须是确定性的，并且无需外部随机性即可复现。您可以实现一个由整数 $1$ 到 $M$ 索引的类 Halton 序列，其中 $M$ 是样本数量。\n- 对于每个测试用例，计算并返回一个包含 5 个浮点值的列表，对应于 $G_1,\\dots,G_5$，其中每个 $G_i$ 是样本集上平方偏导数的平均值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，列表的每个元素对应一个测试用例，并且本身是一个包含 5 个浮点值的列表。例如，您的输出必须看起来像 $\\left[\\left[g_{11},g_{12},g_{13},g_{14},g_{15}\\right],\\left[g_{21},\\dots\\right],\\left[g_{31},\\dots\\right]\\right]$ 这样的一行。\n\n不涉及物理单位；将所有量视为无量纲。不使用角度。将所有输出表示为浮点数。代码必须完全自包含，无需用户输入，并符合指定的执行环境和库约束。您的实现必须忠实于全局敏感性分析的原理，并且在指定的范围和时间步长下数值稳定。", "solution": "用户要求计算给定两阶段生物分子信号模型的基于导数的全局敏感性度量（DGSM）。问题的核心是确定模型的输出，即最终时间 $T$ 的下游激活水平 $Z$，对模型五个参数 $\\theta = [k_1, K_I, k_2, k_3, k_4]$ 变化的敏感程度。指定的度量 $G_i$ 是输出相对于每个参数 $\\theta_i$ 的偏导数平方的期望值，通过对一组确定性参数样本的蒙特卡洛平均来近似。\n\n该问题需要一个特定且非平凡的计算流程：\n1.  需使用低差异 Halton 序列对参数空间进行采样。\n2.  必须使用四阶 Runge-Kutta（RK4）方法对常微分方程（ODE）系统进行数值求解。\n3.  关键步骤是计算偏导数 $\\frac{\\partial Z(T)}{\\partial \\theta_i}$，这不是通过有限差分，而是通过在整个数值积分过程中传播导数来实现的。这通过使用前向模式自动微分（AD）来完成。\n\n解决方案将逐步构建，从 AD 的基本概念开始，将其集成到数值求解器中，最后将其嵌入到敏感性分析工作流程中。\n\n### 1. 通过对偶数实现前向模式自动微分\n\n前向模式 AD 是一种在计算函数值的同时计算其导数的技术。它基于链式法则，通过定义一种新的数字类型——“对偶数”来实现。\n\n对偶数将实数 $u$ 及其导数信息进行了扩展。在当前的多变量参数背景下，我们需要梯度。一个对偶数 $\\hat{u}$ 由一对 $(u, \\nabla u)$ 表示，其中 $u \\in \\mathbb{R}$ 是原始值，$\\nabla u \\in \\mathbb{R}^p$ 是相对于 $p$ 个输入参数的梯度向量。此处，$p=5$。\n\n对偶数的算术规则源于标准的微分法则：\n-   **加法/减法**：$\\hat{u} \\pm \\hat{v} = (u, \\nabla u) \\pm (v, \\nabla v) = (u \\pm v, \\nabla u \\pm \\nabla v)$\n-   **乘法（乘法法则）**：$\\hat{u} \\cdot \\hat{v} = (u, \\nabla u) \\cdot (v, \\nabla v) = (u \\cdot v, u \\cdot \\nabla v + v \\cdot \\nabla u)$\n-   **除法（除法法则）**：$\\frac{\\hat{u}}{\\hat{v}} = \\frac{(u, \\nabla u)}{(v, \\nabla v)} = \\left(\\frac{u}{v}, \\frac{v \\cdot \\nabla u - u \\cdot \\nabla v}{v^2}\\right)$\n-   **与常数 $c \\in \\mathbb{R}$ 的运算**：$c \\cdot \\hat{u} = (c \\cdot u, c \\cdot \\nabla u)$\n\n这些规则允许任何算术运算序列被“提升”以对对偶数进行操作，从而根据链式法则正确传播导数。我们将实现一个 `Dual` 类来封装此功能。\n\n### 2. 用于 AD 的参数和状态初始化\n\n为了计算敏感性 $\\frac{\\partial Z(T)}{\\partial \\theta_i}$，我们必须为 AD 过程“播种”。\n-   模型参数 $\\theta_i$ 是自变量。对于给定的参数样本 $\\theta^{(m)}$，第 $i$ 个参数 $\\theta_i^{(m)}$ 被初始化为一个对偶数 $\\hat{\\theta}_i^{(m)} = (\\theta_i^{(m)}, \\mathbf{e}_i)$，其中 $\\mathbf{e}_i$ 是 $\\mathbb{R}^5$ 中的第 $i$ 个标准基向量（例如，$\\mathbf{e}_2 = [0, 1, 0, 0, 0]$）。\n-   状态变量 $X(t)$ 和 $Z(t)$ 依赖于参数。它们的初始值给定为 $X(0)=0$ 和 $Z(0)=0$。由于这些初始条件不依赖于 $\\theta$，它们的初始梯度为零。因此，我们将它们初始化为 $\\hat{X}(0) = (0, \\mathbf{0}_5)$ 和 $\\hat{Z}(0) = (0, \\mathbf{0}_5)$，其中 $\\mathbf{0}_5$ 是 $\\mathbb{R}^5$ 中的零向量。\n-   恒定输入 $I=1$ 也不依赖于 $\\theta$，因此它被表示为对偶数 $\\hat{I} = (1, \\mathbf{0}_5)$。\n\n### 3. 使用支持 AD 的 RK4 积分 ODE 系统\n\n任务的核心是在传播导数的同时求解 ODE 系统。我们将使用经典的四阶 Runge-Kutta（RK4）方法。设状态向量为 $\\mathbf{y}(t) = [X(t), Z(t)]^T$，其对偶表示为 $\\hat{\\mathbf{y}}(t) = [\\hat{X}(t), \\hat{Z}(t)]^T$。ODE 系统为 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y}, \\theta)$。其对偶版本为 $\\frac{d\\hat{\\mathbf{y}}}{dt} = \\hat{\\mathbf{f}}(\\hat{\\mathbf{y}}, \\hat{\\theta})$。\n\n从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个 RK4 步骤由以下公式给出：\n$$ \\hat{\\mathbf{k}}_1 = \\hat{\\mathbf{f}}(\\hat{\\mathbf{y}}_n, \\hat{\\theta}) $$\n$$ \\hat{\\mathbf{k}}_2 = \\hat{\\mathbf{f}}(\\hat{\\mathbf{y}}_n + \\frac{\\Delta t}{2}\\hat{\\mathbf{k}}_1, \\hat{\\theta}) $$\n$$ \\hat{\\mathbf{k}}_3 = \\hat{\\mathbf{f}}(\\hat{\\mathbf{y}}_n + \\frac{\\Delta t}{2}\\hat{\\mathbf{k}}_2, \\hat{\\theta}) $$\n$$ \\hat{\\mathbf{k}}_4 = \\hat{\\mathbf{f}}(\\hat{\\mathbf{y}}_n + \\Delta t \\hat{\\mathbf{k}}_3, \\hat{\\theta}) $$\n$$ \\hat{\\mathbf{y}}_{n+1} = \\hat{\\mathbf{y}}_n + \\frac{\\Delta t}{6} (\\hat{\\mathbf{k}}_1 + 2\\hat{\\mathbf{k}}_2 + 2\\hat{\\mathbf{k}}_3 + \\hat{\\mathbf{k}}_4) $$\n这些方程中的所有算术运算都使用定义的对偶数规则执行。从 $\\hat{\\mathbf{y}}_0 = [\\hat{X}(0), \\hat{Z}(0)]^T$ 开始，我们迭代此过程共 $N = T/\\Delta t$ 步。最终结果 $\\hat{\\mathbf{y}}_N = \\hat{\\mathbf{y}}(T)$ 将包含对 $(\\mathbf{y}(T), \\nabla_\\theta \\mathbf{y}(T))$。可观测量的梯度 $\\nabla_\\theta Z(T)$ 就是 $\\hat{\\mathbf{y}}(T)$ 第二个分量的梯度部分。\n\n### 4. 使用 Halton 序列进行确定性采样\n\n为了执行类似蒙特卡洛的平均，我们需要从参数的先验分布中生成样本。问题指定了一个确定性的低差异序列。我们将实现一个 Halton 序列生成器。对于一个 $p$ 维参数空间，我们选择前 $p$ 个素数作为基数（这里，$p=5$，所以我们使用 2, 3, 5, 7, 11）。Halton 序列中的第 $n$ 个点 $\\mathbf{h}(n) = (h_1(n), \\dots, h_p(n))$ 的构造方式是，每个分量 $h_i(n)$ 都使用基数 $p_i$ 生成。这是通过将索引 $n$ 写成 $p_i$ 进制，并围绕小数点反射数字来完成的。\n\n此过程在单位超立方体 $[0, 1)^p$ 中生成 $M$ 个样本。然后，使用线性变换将每个样本 $\\mathbf{h}^{(m)}$ 缩放到每个参数 $\\theta_i$ 的指定先验范围 $[L_i, U_i]$ 内：\n$$ \\theta_i^{(m)} = L_i + (U_i - L_i) \\cdot h_i(m) $$\n\n### 5. 计算类 DGSM 的量 $G_i$\n\n最后一步是组装整个过程以计算敏感性指数 $G_i$。算法如下：\n\n1.  初始化一个用于存放平方梯度之和的向量，$\\mathbf{S} = [0, 0, 0, 0, 0]^T$。\n2.  使用映射到先验范围的 Halton 序列生成 $M$ 个参数样本 $\\{\\theta^{(m)}\\}_{m=1}^M$。\n3.  对于每个样本 $m = 1, \\dots, M$：\n    a. 将参数初始化为对偶数：对于 $i=1,\\dots,5$，$\\hat{\\theta}_i^{(m)} = (\\theta_i^{(m)}, \\mathbf{e}_i)$。\n    b. 将状态初始化为对偶数：$\\hat{X}(0)=(0, \\mathbf{0}_5)$ 和 $\\hat{Z}(0)=(0, \\mathbf{0}_5)$。\n    c. 使用支持 AD 的 RK4 方法将对偶化 ODE 系统从 $t=0$ 积分到 $t=T$，以获得最终状态 $\\hat{Z}(T)$。\n    d. 从 $\\hat{Z}(T)$ 的导数部分提取梯度向量 $\\nabla_\\theta Z^{(m)}$。\n    e. 计算梯度的逐元素平方：$(\\nabla_\\theta Z^{(m)})^2$。\n    f. 将此结果加到累加器中：$\\mathbf{S} = \\mathbf{S} + (\\nabla_\\theta Z^{(m)})^2$。\n4.  遍历所有样本后，计算每个参数的平均值：\n    $$ G_i = \\frac{1}{M} S_i $$\n对问题陈述中指定的三个测试用例中的每一个重复此过程。实现将包含在一个独立的 Python 脚本中，执行这些步骤以产生所需的输出。", "answer": "```python\nimport numpy as np\n\nclass Dual:\n    \"\"\"\n    A class to represent dual numbers for forward-mode automatic differentiation.\n    The gradient is a vector corresponding to partial derivatives w.r.t. all parameters.\n    \"\"\"\n    def __init__(self, value, grad):\n        self.value = float(value)\n        self.grad = np.asarray(grad, dtype=float)\n\n    def __repr__(self):\n        return f\"Dual({self.value}, {self.grad})\"\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value + other.value, self.grad + other.grad)\n        return Dual(self.value + other, self.grad)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value - other.value, self.grad - other.grad)\n        return Dual(self.value - other, self.grad)\n\n    def __rsub__(self, other):\n        return Dual(other - self.value, -self.grad)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            # Product rule: (u*v)' = u'*v + u*v'\n            return Dual(self.value * other.value, self.grad * other.value + self.value * other.grad)\n        return Dual(self.value * other, self.grad * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __truediv__(self, other):\n        if isinstance(other, Dual):\n            # Quotient rule: (u/v)' = (u'*v - u*v') / v^2\n            val = self.value / other.value\n            grad = (self.grad * other.value - self.value * other.grad) / (other.value**2)\n            return Dual(val, grad)\n        return Dual(self.value / other, self.grad / other)\n\n    def __rtruediv__(self, other):\n        val = other / self.value\n        grad = (-other * self.grad) / (self.value**2)\n        return Dual(val, grad)\n\ndef get_halton_sequence(num_samples, dim, bases):\n    \"\"\"\n    Generates a Halton sequence of a given dimension.\n    \"\"\"\n    sequence = np.zeros((num_samples, dim))\n    for d in range(dim):\n        base = bases[d]\n        for i in range(1, num_samples + 1):\n            n = i\n            f = 1.0\n            r = 0.0\n            while n > 0:\n                f /= base\n                r += f * (n % base)\n                n = int(n / base)\n            sequence[i-1, d] = r\n    return sequence\n\ndef ode_system(state, params, I):\n    \"\"\"\n    Defines the ODE system using Dual number arithmetic.\n    state = [X, Z], params = [k1, KI, k2, k3, k4]\n    All inputs are expected to be Dual numbers.\n    \"\"\"\n    X, Z = state\n    k1, KI, k2, k3, k4 = params\n\n    # dX/dt = k1 * (I / (KI + I)) * (1 - X) - k2 * X\n    # dZ/dt = k3 * X * (1 - Z) - k4 * Z\n    \n    term_I = I / (KI + I)\n    dX_dt = k1 * term_I * (1.0 - X) - k2 * X\n    dZ_dt = k3 * X * (1.0 - Z) - k4 * Z\n    \n    return [dX_dt, dZ_dt]\n\ndef rk4_step_ad(state, params, dt, I):\n    \"\"\"\n    Performs a single RK4 step on Dual numbers.\n    \"\"\"\n    k1 = ode_system(state, params, I)\n    \n    state_k2 = [state[i] + k1[i] * (dt / 2.0) for i in range(len(state))]\n    k2 = ode_system(state_k2, params, I)\n\n    state_k3 = [state[i] + k2[i] * (dt / 2.0) for i in range(len(state))]\n    k3 = ode_system(state_k3, params, I)\n\n    state_k4 = [state[i] + k3[i] * dt for i in range(len(state))]\n    k4 = ode_system(state_k4, params, I)\n    \n    next_state = [state[i] + (k1[i] + k2[i] * 2.0 + k3[i] * 2.0 + k4[i]) * (dt / 6.0) for i in range(len(state))]\n    \n    return next_state\n\ndef compute_gsa_for_case(priors, num_samples, T, dt):\n    \"\"\"\n    Computes the DGSM-like quantities G_i for a single test case.\n    \"\"\"\n    num_params = len(priors)\n    bases = [2, 3, 5, 7, 11]\n    \n    # Generate samples in [0, 1)^dim\n    samples_unit_cube = get_halton_sequence(num_samples, num_params, bases)\n    \n    # Scale samples to prior ranges\n    prior_min = np.array([p[0] for p in priors])\n    prior_max = np.array([p[1] for p in priors])\n    param_samples = prior_min + samples_unit_cube * (prior_max - prior_min)\n    \n    sum_sq_grads = np.zeros(num_params)\n    \n    I_dual = Dual(1.0, np.zeros(num_params))\n    \n    time_points = np.arange(0, T, dt)\n    \n    for i in range(num_samples):\n        sample_params = param_samples[i, :]\n        \n        # Initialize parameters as Dual numbers with seeded gradients\n        params_dual = [\n            Dual(sample_params[j], (np.eye(num_params)[j])) for j in range(num_params)\n        ]\n        \n        # Initial conditions with zero gradients\n        state_dual = [\n            Dual(0.0, np.zeros(num_params)),  # X(0)\n            Dual(0.0, np.zeros(num_params))   # Z(0)\n        ]\n        \n        # Integrate ODE using RK4 with AD\n        for _ in time_points:\n            state_dual = rk4_step_ad(state_dual, params_dual, dt, I_dual)\n            \n        # Extract gradient of Z(T) and add its square to the sum\n        final_Z_grad = state_dual[1].grad\n        sum_sq_grads += final_Z_grad**2\n        \n    # Compute the average squared gradient\n    g_indices = (sum_sq_grads / num_samples).tolist()\n    return g_indices\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"priors\": [[0.1, 1.0], [0.05, 0.5], [0.05, 0.5], [0.1, 1.0], [0.05, 0.5]],\n            \"num_samples\": 200,\n            \"T\": 10.0,\n            \"dt\": 0.01\n        },\n        {\n            \"priors\": [[0.1, 1.0], [0.05, 0.5], [0.05, 0.5], [0.1, 1.0], [0.05, 0.5]],\n            \"num_samples\": 1,\n            \"T\": 10.0,\n            \"dt\": 0.01\n        },\n        {\n            \"priors\": [[0.1, 1.0], [1e-6, 1e-4], [0.05, 0.5], [0.1, 1.0], [0.05, 0.5]],\n            \"num_samples\": 50,\n            \"T\": 10.0,\n            \"dt\": 0.02\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        gsa_result = compute_gsa_for_case(case[\"priors\"], case[\"num_samples\"], case[\"T\"], case[\"dt\"])\n        results.append(gsa_result)\n\n    # The required output is a string representation of a list of lists.\n    # The default str() for a list is the desired format '[item1, item2, ...]'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4348260"}]}