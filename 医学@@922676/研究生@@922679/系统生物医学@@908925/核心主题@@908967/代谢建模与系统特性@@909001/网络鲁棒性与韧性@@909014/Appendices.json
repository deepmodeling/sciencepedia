{"hands_on_practices": [{"introduction": "除了静态结构，生物网络还必须对扰动做出动态响应和恢复。本练习将我们的焦点从结构鲁棒性转移到动态回弹力，使用控制理论的工具来分析一个基因调控回路模型。通过构建李雅普诺夫函数，您不仅可以证明系统的稳定性，还能推导出系统恢复到平衡态所需时间的量化估计，这是衡量其回弹力的一个关键指标。[@problem_id:4367859]", "problem": "考虑一个模拟系统生物医学中基因-蛋白质调控回路的最小负反馈模体。令 $x(t)$ 表示一个输出物种的浓度，$y(t)$ 表示一个调控抑制剂，其产生与 $x(t)$ 成正比，并抑制 $x(t)$ 的生成。令上游输入 $u(t)$ 代表一个外部转录驱动。在一个标称工作点附近，对标准的质量作用和一级降解动力学进行线性化，得到二维常微分方程（ODE）模型\n$$\n\\frac{d}{dt}\\begin{pmatrix}x(t)\\\\y(t)\\end{pmatrix} \\;=\\; A\\begin{pmatrix}x(t)\\\\y(t)\\end{pmatrix} \\;+\\; B\\,u(t),\n$$\n其中\n$$\nA \\;=\\; \\begin{pmatrix}-1.5  -1.0 \\\\ 2.0  -3.0\\end{pmatrix},\\quad B \\;=\\; \\begin{pmatrix}1.0 \\\\ 0.0\\end{pmatrix}.\n$$\n所有速率常数的单位均为 $\\text{min}^{-1}$，因此时间以分钟为单位测量，$x(t)$ 和 $y(t)$ 采用一致的浓度单位。假设系统在 $t0$ 时处于对应于恒定输入 $u(t)\\equiv u_{0}$ 的稳态。在 $t=0$ 时，施加一个阶跃扰动，使得对于所有 $t\\ge 0$，输入变为一个新的常数 $u(t)\\equiv u_{1}$。取 $u_{0}=0$ 和 $u_{1}=1$。\n\n从动力系统和控制中的基本稳定性概念出发，特别是 Lyapunov 稳定性理论，完成以下任务：\n\n1. 为 $t\\ge 0$ 时关于新平衡点的误差动力学构建一个 Lyapunov 函数。即，定义误差 $z(t) = \\big(x(t),y(t)\\big)^{\\top} - \\big(x^{\\ast}(u_{1}),y^{\\ast}(u_{1})\\big)^{\\top}$，其中 $\\big(x^{\\ast}(u),y^{\\ast}(u)\\big)$是满足 $A\\begin{pmatrix}x^{\\ast}(u)\\\\y^{\\ast}(u)\\end{pmatrix} + B\\,u = \\begin{pmatrix}0\\\\0\\end{pmatrix}$ 的平衡点。使用形式为 $V(z) = z^{\\top}Pz$ 的二次候选函数，其中 $P\\in\\mathbb{R}^{2\\times 2}$ 是一个对称正定矩阵，通过求解一个右侧为正定矩阵的连续时间 Lyapunov 方程来确定 $P$。\n\n2. 使用您构建的 Lyapunov 函数，推导出一个显式解析上界 $T_{\\delta}$，使得对于所有 $t\\ge T_{\\delta}$，误差的欧几里得范数满足 $\\|z(t)\\|\\le \\delta$，其中 $\\delta = 0.05$。将 $T_{\\delta}$ 用系统矩阵、参数以及由阶跃变化引起的初始误差 $z(0)$ 以闭合形式表示。\n\n3. 代入给定的数值，计算从 $u_{0}=0$到 $u_{1}=1$ 的指定阶跃扰动下的 $T_{\\delta}$ 的数值。将您的答案四舍五入到四位有效数字，并以分钟表示最终时间。最终答案必须是一个实数。", "solution": "问题陈述经评估有效。它具有科学依据，是适定的、客观且自洽的。该模型是遗传调控网络的标准线性化表示，这是系统生物医学中的一种常用方法。系统矩阵 $A$ 是 Hurwitz 矩阵，因为它的迹为 $\\text{tr}(A) = -1.5 - 3.0 = -4.5  0$，其行列式为 $\\det(A) = (-1.5)(-3.0) - (-1.0)(2.0) = 4.5 + 2.0 = 6.5  0$。这确保了对于任何恒定输入都存在一个唯一的稳定平衡点，从而使得问题是适定的。所有必需的参数和条件都已给出，并且没有内部矛盾。我们可以开始求解。\n\n设状态向量为 $\\mathbf{x}(t) = \\begin{pmatrix}x(t) \\\\ y(t)\\end{pmatrix}$。系统动力学由 $\\frac{d\\mathbf{x}}{dt} = A\\mathbf{x}(t) + B u(t)$ 给出。对应于恒定输入 $u$ 的平衡态 $\\mathbf{x}^{\\ast}(u)$ 可以通过将时间导数设为零来找到：$A\\mathbf{x}^{\\ast}(u) + B u = \\mathbf{0}$，这得到 $\\mathbf{x}^{\\ast}(u) = -A^{-1}Bu$。\n\n对于 $t \\ge 0$，输入是恒定的 $u(t) \\equiv u_1 = 1$。新的平衡态为 $\\mathbf{x}^{\\ast}(u_1) = -A^{-1}Bu_1$。误差向量定义为 $z(t) = \\mathbf{x}(t) - \\mathbf{x}^{\\ast}(u_1)$。误差的动力学为：\n$$\n\\frac{dz(t)}{dt} = \\frac{d\\mathbf{x}(t)}{dt} - \\frac{d\\mathbf{x}^{\\ast}(u_1)}{dt} = (A\\mathbf{x}(t) + Bu_1) - \\mathbf{0}\n$$\n由于 $A\\mathbf{x}^{\\ast}(u_1) + Bu_1 = \\mathbf{0}$，我们可以写出 $Bu_1 = -A\\mathbf{x}^{\\ast}(u_1)$。将此代入误差动力学方程：\n$$\n\\frac{dz(t)}{dt} = A\\mathbf{x}(t) - A\\mathbf{x}^{\\ast}(u_1) = A(\\mathbf{x}(t) - \\mathbf{x}^{\\ast}(u_1)) = Az(t)\n$$\n因此，误差动力学由齐次系统 $\\dot{z} = Az$ 控制。\n\n**1. 为误差动力学构建 Lyapunov 函数**\n\n我们寻求一个二次 Lyapunov 函数 $V(z) = z^{\\top}Pz$，其中 $P \\in \\mathbb{R}^{2\\times 2}$ 是一个对称正定矩阵。$V(z)$ 沿着系统轨迹的时间导数为：\n$$\n\\dot{V}(z) = \\frac{d}{dt}(z^{\\top}Pz) = \\dot{z}^{\\top}Pz + z^{\\top}P\\dot{z} = (Az)^{\\top}Pz + z^{\\top}P(Az) = z^{\\top}(A^{\\top}P + PA)z\n$$\n为了实现渐近稳定性，$\\dot{V}(z)$ 必须是负定的。这可以通过选择 $P$ 以使得 $A^{\\top}P + PA = -Q$ 来保证，其中 $Q$ 是某个对称正定矩阵。这就是连续时间 Lyapunov 方程。$Q$ 的一个标准选择是单位矩阵，$Q=I$，它是正定的。我们在方程 $A^{\\top}P + PA = -I$ 中求解 $P$。\n\n设 $P = \\begin{pmatrix} p_{11}  p_{12} \\\\ p_{12}  p_{22} \\end{pmatrix}$。方程变为：\n$$\n\\begin{pmatrix}-1.5  2.0 \\\\ -1.0  -3.0\\end{pmatrix}\\begin{pmatrix} p_{11}  p_{12} \\\\ p_{12}  p_{22} \\end{pmatrix} + \\begin{pmatrix} p_{11}  p_{12} \\\\ p_{12}  p_{22} \\end{pmatrix}\\begin{pmatrix}-1.5  -1.0 \\\\ 2.0  -3.0\\end{pmatrix} = \\begin{pmatrix}-1  0 \\\\ 0  -1\\end{pmatrix}\n$$\n展开矩阵乘积可得：\n$$\n\\begin{pmatrix} -3p_{11} + 4p_{12}  -p_{11} - 4.5p_{12} + 2p_{22} \\\\ -p_{11} - 4.5p_{12} + 2p_{22}  -2p_{12} - 6p_{22} \\end{pmatrix} = \\begin{pmatrix}-1  0 \\\\ 0  -1\\end{pmatrix}\n$$\n这为 $P$ 的元素产生了一个线性方程组：\n1) $-3p_{11} + 4p_{12} = -1$\n2) $-p_{11} - 4.5p_{12} + 2p_{22} = 0$\n3) $-2p_{12} - 6p_{22} = -1 \\implies 2p_{12} + 6p_{22} = 1$\n\n由(1)式，$p_{11} = \\frac{1+4p_{12}}{3}$。由(3)式，$p_{22} = \\frac{1-2p_{12}}{6}$。将这些代入(2)式：\n$$\n-\\left(\\frac{1+4p_{12}}{3}\\right) - 4.5p_{12} + 2\\left(\\frac{1-2p_{12}}{6}\\right) = 0\n$$\n$$\n-\\frac{1}{3} - \\frac{4}{3}p_{12} - \\frac{9}{2}p_{12} + \\frac{1}{3} - \\frac{2}{3}p_{12} = 0\n$$\n$$\n\\left(-\\frac{4}{3} - \\frac{9}{2} - \\frac{2}{3}\\right)p_{12} = 0 \\implies \\left(-2 - \\frac{9}{2}\\right)p_{12} = 0 \\implies -6.5p_{12} = 0\n$$\n因此，$p_{12}=0$。代回后，我们得到 $p_{11} = 1/3$ 和 $p_{22} = 1/6$。\n矩阵 $P$ 为：\n$$\nP = \\begin{pmatrix} 1/3  0 \\\\ 0  1/6 \\end{pmatrix}\n$$\n该矩阵是对角矩阵，且对角元素为正，因此它是正定的。Lyapunov 函数为 $V(z) = \\frac{1}{3}z_1^2 + \\frac{1}{6}z_2^2$，其导数为 $\\dot{V}(z) = -z^{\\top}Iz = -\\|z\\|^2$。\n\n**2. 推导上界 $T_{\\delta}$**\n\nLyapunov 函数 $V(z)$ 可以用欧几里得范数的平方 $\\|z\\|^2 = z^{\\top}z$ 来界定。其边界与 $P$ 的最小和最大特征值 $\\lambda_{\\min}(P)$ 和 $\\lambda_{\\max}(P)$ 相关：\n$$\n\\lambda_{\\min}(P)\\|z\\|^2 \\le V(z) \\le \\lambda_{\\max}(P)\\|z\\|^2\n$$\n对于我们的对角矩阵 $P$，特征值即为对角元素：$\\lambda_{\\min}(P) = 1/6$ 和 $\\lambda_{\\max}(P) = 1/3$。\n从 $\\dot{V}(z) = -\\|z\\|^2$ 和 $\\|z\\|^2 \\ge V(z)/\\lambda_{\\max}(P)$，我们得到微分不等式：\n$$\n\\dot{V}(z) \\le -\\frac{V(z)}{\\lambda_{\\max}(P)}\n$$\n根据 Grönwall 不等式，这意味着 $V(z(t))$呈指数衰减：\n$$\nV(z(t)) \\le V(z(0)) \\exp\\left(-\\frac{t}{\\lambda_{\\max}(P)}\\right)\n$$\n我们希望找到时间的一个上界 $T_{\\delta}$，使得对于所有 $t \\ge T_{\\delta}$，都有 $\\|z(t)\\| \\le \\delta$。如果我们能确保 $\\|z(t)\\|^2 \\le \\delta^2$，这个条件就能得到保证。\n使用 $V(z)$ 的下界，我们有 $\\|z(t)\\|^2 \\le V(z(t))/\\lambda_{\\min}(P)$。\n因此，如果 $V(z(t))/\\lambda_{\\min}(P) \\le \\delta^2$，即 $V(z(t)) \\le \\lambda_{\\min}(P)\\delta^2$，则条件 $\\|z(t)\\| \\le \\delta$ 得到满足。\n我们可以通过将 $V(z(t))$ 的上界设置为此值来找到 $T_{\\delta}$：\n$$\nV(z(0)) \\exp\\left(-\\frac{T_{\\delta}}{\\lambda_{\\max}(P)}\\right) = \\lambda_{\\min}(P)\\delta^2\n$$\n求解 $T_{\\delta}$：\n$$\n\\exp\\left(-\\frac{T_{\\delta}}{\\lambda_{\\max}(P)}\\right) = \\frac{\\lambda_{\\min}(P)\\delta^2}{V(z(0))}\n$$\n$$\n-\\frac{T_{\\delta}}{\\lambda_{\\max}(P)} = \\ln\\left(\\frac{\\lambda_{\\min}(P)\\delta^2}{V(z(0))}\\right)\n$$\n$$\nT_{\\delta} = -\\lambda_{\\max}(P) \\ln\\left(\\frac{\\lambda_{\\min}(P)\\delta^2}{V(z(0))}\\right) = \\lambda_{\\max}(P) \\ln\\left(\\frac{V(z(0))}{\\lambda_{\\min}(P)\\delta^2}\\right)\n$$\n系统初始时处于 $u_0=0$ 的稳态。因此，$\\mathbf{x}(0) = \\mathbf{x}^{\\ast}(u_0) = -A^{-1}Bu_0 = \\mathbf{0}$。新的平衡点为 $\\mathbf{x}^{\\ast}(u_1) = -A^{-1}Bu_1$。\n初始误差为 $z(0) = \\mathbf{x}(0) - \\mathbf{x}^{\\ast}(u_1) = -(-A^{-1}Bu_1) = A^{-1}Bu_1$。\nLyapunov 函数的初始值为 $V(z(0)) = z(0)^{\\top}Pz(0) = (A^{-1}B u_1)^{\\top}P(A^{-1}B u_1)$。\n因为 $u_0=0, u_1=1$, 我们可以写成 $z(0) = -A^{-1}B(u_0 - u_1)$ 并且 $V(z(0)) = (u_1-u_0)^2 (A^{-1}B)^{\\top}P(A^{-1}B)$。\n将此代入 $T_{\\delta}$ 的表达式，得到最终的解析形式。\n\n**3. $T_{\\delta}$ 的数值计算**\n\n首先，我们计算必要的数值。\n$A$ 的逆矩阵为 $A^{-1} = \\frac{1}{\\det(A)}\\begin{pmatrix}-3.0  1.0 \\\\ -2.0  -1.5\\end{pmatrix} = \\frac{1}{6.5}\\begin{pmatrix}-3.0  1.0 \\\\ -2.0  -1.5\\end{pmatrix}$。\n初始误差 $z(0)$ 为：\n$$\nz(0) = -A^{-1}B(u_0 - u_1) = -\\frac{1}{6.5}\\begin{pmatrix}-3.0  1.0 \\\\ -2.0  -1.5\\end{pmatrix}\\begin{pmatrix}1.0 \\\\ 0.0\\end{pmatrix}(0-1) = \\frac{1}{6.5}\\begin{pmatrix}-3.0 \\\\ -2.0\\end{pmatrix} = \\frac{1}{13}\\begin{pmatrix}-6 \\\\ -4\\end{pmatrix}\n$$\n现在，我们计算 $V(z(0)) = z(0)^{\\top}Pz(0)$：\n$$\nV(z(0)) = \\left(\\frac{1}{13}\\begin{pmatrix}-6 \\\\ -4\\end{pmatrix}\\right)^{\\top} \\begin{pmatrix}1/3  0 \\\\ 0  1/6\\end{pmatrix} \\left(\\frac{1}{13}\\begin{pmatrix}-6 \\\\ -4\\end{pmatrix}\\right) = \\frac{1}{169}\\begin{pmatrix}-6  -4\\end{pmatrix}\\begin{pmatrix}1/3  0 \\\\ 0  1/6\\end{pmatrix}\\begin{pmatrix}-6 \\\\ -4\\end{pmatrix}\n$$\n$$\nV(z(0)) = \\frac{1}{169}\\left(\\frac{1}{3}(-6)^2 + \\frac{1}{6}(-4)^2\\right) = \\frac{1}{169}\\left(\\frac{36}{3} + \\frac{16}{6}\\right) = \\frac{1}{169}\\left(12 + \\frac{8}{3}\\right) = \\frac{1}{169}\\left(\\frac{44}{3}\\right) = \\frac{44}{507}\n$$\n我们有以下参数：\n- $\\lambda_{\\max}(P) = 1/3$\n- $\\lambda_{\\min}(P) = 1/6$\n- $V(z(0)) = 44/507$\n- $\\delta = 0.05 = 1/20 \\implies \\delta^2 = 1/400$\n\n我们将这些值代入 $T_{\\delta}$ 的表达式中：\n$$\nT_{\\delta} = \\lambda_{\\max}(P) \\ln\\left(\\frac{V(z(0))}{\\lambda_{\\min}(P)\\delta^2}\\right) = \\frac{1}{3} \\ln\\left(\\frac{44/507}{(1/6)(1/400)}\\right)\n$$\n$$\nT_{\\delta} = \\frac{1}{3} \\ln\\left(\\frac{44/507}{1/2400}\\right) = \\frac{1}{3} \\ln\\left(\\frac{44 \\times 2400}{507}\\right)\n$$\n由于 $507 = 3 \\times 169$ 且 $2400 = 3 \\times 800$，我们可以简化对数的参数：\n$$\n\\frac{44 \\times 2400}{507} = \\frac{44 \\times 3 \\times 800}{3 \\times 169} = \\frac{44 \\times 800}{169} = \\frac{35200}{169}\n$$\n因此，时间的最终解析表达式为：\n$$\nT_{\\delta} = \\frac{1}{3} \\ln\\left(\\frac{35200}{169}\\right)\n$$\n其数值为：\n$$\nT_{\\delta} \\approx \\frac{1}{3} \\ln(208.28402...) \\approx \\frac{1}{3}(5.33890...) \\approx 1.779634...\n$$\n四舍五入到四位有效数字，我们得到 $T_{\\delta} \\approx 1.780$。单位是分钟。", "answer": "$$\\boxed{1.780}$$", "id": "4367859"}, {"introduction": "对于大规模生物网络，我们需要高效的计算方法来识别关键的结构特征。本练习介绍了k-核分解算法，这是一个强大的工具，用于揭示复杂网络中层层嵌套的鲁棒子结构。您将学习实现这种“剥离”算法，并理解为何一个节点的核数是其结构重要性及其在回弹邻域中嵌入程度的有力指标。[@problem_id:4367933]", "problem": "考虑一个由邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 表示的无向简单图，该图没有自环，其邻接矩阵是对称的且对角线元素为零。令 $G = (V,E)$ 表示该图，其中 $V = \\{0,1,\\dots,n-1\\}$ 是节点集，$E$ 是边集，当且仅当 $A_{ij} = 1$ 时，有 $(i,j) \\in E$。节点 $i$ 的度为 $d(i) = \\sum_{j=0}^{n-1} A_{ij}$。由 $S \\subseteq V$ 诱导的子图 $H$ 是点对 $(S, E|_S)$，其中 $E|_S = \\{(i,j) \\in E \\mid i \\in S, j \\in S\\}$。$G$ 的 $k$-核定义为唯一的最大诱导子图 $H_k$，使得 $H_k$ 中的每个节点在相对于 $H_k$ 计算度时，其度至少为 $k$。节点 $i$ 的核数（也称为 coreness）是使得 $i \\in H_k$ 成立的最大整数 $k \\ge 0$。\n\n任务：从上述核的定义和图上迭代约束满足的基本概念（移除违反局部度阈值的节点，直到达到不动点）出发，推导一个算法。该算法对于给定的邻接矩阵 $A$，计算核数向量 $c \\in \\mathbb{Z}_{\\ge 0}^n$，其中 $c_i$ 是节点 $i$ 的核数。您的推导必须阐明为什么不动点迭代剪枝过程会终止，为什么得到的结果子图是最大的，以及为什么节点 $i$ 存留的最大 $k$ 值等于其核数。\n\n认知意义要求：以基于上述定义的形式化术语解释，为什么 $k$-核能够识别出在移除低度节点下具有鲁棒性的子结构，以及这与系统生物医学中的弹性分析有何关系，其中生物相互作用网络表现出模块性和冗余性。\n\n计算要求：实现您推导的算法，并将其应用于以下邻接矩阵测试套件。对于每个测试用例，计算并返回按节点索引顺序 $[0,1,\\dots,n-1]$ 排列的核数列表。\n\n测试套件：\n- 案例 A（混合密集与稀疏结构，$n=6$）：\n$$\nA^{(A)} =\n\\begin{pmatrix}\n0  1  1  1  0  1 \\\\\n1  0  1  0  0  1 \\\\\n1  1  0  0  0  0 \\\\\n1  0  0  0  1  0 \\\\\n0  0  0  1  0  0 \\\\\n1  1  0  0  0  0 \\\\\n\\end{pmatrix}\n$$\n- 案例 B（空图，$n=4$）：\n$$\nA^{(B)} =\n\\begin{pmatrix}\n0  0  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  0 \\\\\n\\end{pmatrix}\n$$\n- 案例 C（完全图 $K_5$，$n=5$）：\n$$\nA^{(C)} =\n\\begin{pmatrix}\n0  1  1  1  1 \\\\\n1  0  1  1  1 \\\\\n1  1  0  1  1 \\\\\n1  1  1  0  1 \\\\\n1  1  1  1  0 \\\\\n\\end{pmatrix}\n$$\n- 案例 D（以节点 0 为中心的星形图，$n=6$）：\n$$\nA^{(D)} =\n\\begin{pmatrix}\n0  1  1  1  1  1 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n\\end{pmatrix}\n$$\n\n最终输出规范：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个结果是对应测试用例的核数列表，按节点索引顺序排列。例如，格式必须为 $[\\,[c^{(A)}_0,\\dots,c^{(A)}_{n_A-1}],\\,[c^{(B)}_0,\\dots,c^{(B)}_{n_B-1}],\\,[c^{(C)}_0,\\dots,c^{(C)}_{n_C-1}],\\,[c^{(D)}_0,\\dots,c^{(D)}_{n_D-1}]\\,]$。所有报告值均为没有物理单位的整数。程序必须在没有用户输入的情况下运行。", "solution": "该问题要求推导并实现一个算法，用以计算由邻接矩阵 $A$ 指定的图中每个节点的核数。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n- **图表示**：无向简单图 $G=(V,E)$，其中 $V=\\{0, 1, \\dots, n-1\\}$，无自环。由对角线上为零的对称邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 表示。当且仅当 $A_{ij}=1$ 时，边 $(i,j) \\in E$ 存在。\n- **节点度**：节点 $i$ 的度为 $d(i) = \\sum_{j=0}^{n-1} A_{ij}$。\n- **诱导子图**：对于顶点子集 $S \\subseteq V$，诱导子图 $H=(S, E|_S)$ 包含节点 $S$ 以及 $E$ 中连接 $S$ 内两个节点的所有边。\n- **$k$-核**：唯一的最大诱导子图 $H_k$，其中 $H_k$ 中的每个节点相对于子图 $H_k$ 的度至少为 $k$。\n- **核数 (coreness)**：节点 $i$ 的核数，记为 $c_i$，是使节点 $i$ 成为 $k$-核 $H_k$ 集成员的最大整数 $k \\ge 0$。\n- **任务**：推导一个算法来计算核数向量 $c \\in \\mathbb{Z}_{\\ge 0}^n$。推导过程必须证明算法的正确性（终止性、最大性等）。\n- **认知要求**：解释 $k$-核、鲁棒性及其在系统生物医学中应用之间的关系。\n- **计算要求**：实现算法并将其应用于四个测试用例：$A^{(A)}$、$A^{(B)}$、$A^{(C)}$ 和 $A^{(D)}$。\n- **输出格式**：一个单行，包含一个由核数列表组成的列表，例如 `[[c_A], [c_B], [c_C], [c_D]]`。\n\n**1.2. 使用提取的已知条件进行验证**\n根据验证标准对问题进行评估：\n- **科学基础**：所有定义（图、邻接矩阵、度、诱导子图、$k$-核、核数）都是图论和网络科学中的标准和基本概念。该问题在科学上和数学上都是合理的。\n- **适定性**：定义精确无歧义。对于任何给定的图，$k$-核是唯一定义的，因此每个节点的核数也是唯一定义的。该问题是适定的。\n- **客观性**：问题以形式化的数学语言陈述，没有主观性或偏见。\n- **完整性与一致性**：问题提供了所有必要的定义和数据（测试用例的邻接矩阵）。没有矛盾之处。\n\n**1.3. 结论与行动**\n问题是**有效的**。将提供解决方案。\n\n### 步骤 2：算法推导与论证\n\n**2.1. 寻找固定 $k$ 值的 $k$-核**\n\n$k$-核的定义提示了一种基于迭代约束满足的算法。其约束条件是目标子图中的每个节点的度必须至少为 $k$。我们可以从整个图 $G$ 开始，迭代地移除任何违反此约束的节点来找到 $k$-核。\n\n令 $G_0 = G$。对于 $t = 0, 1, 2, \\dots$，令 $G_t = (V_t, E_t)$ 为步骤 $t$ 时的图。\n1. 识别要移除的节点集：$S_t = \\{v \\in V_t \\mid \\deg_{G_t}(v)  k\\}$。\n2. 如果 $S_t$ 为空，则过程已达到不动点。当前图 $G_t$ 就是 $k$-核。\n3. 如果 $S_t$ 不为空，则通过移除 $S_t$ 中的节点及其关联的边来形成下一个图 $G_{t+1}$。$G_{t+1}$ 是由顶点集 $V_{t+1} = V_t \\setminus S_t$ 诱导的 $G_t$ 的子图。\n4. 从步骤 1 重复。\n\n**论证：**\n- **终止性**：图是有限的。在 $S_t$ 非空的每一步中，至少有一个节点从图中被移除。由于节点永远不会被添加，该过程必须在最多 $n$ 步内终止。\n- **正确性**：根据构造，得到的结果子图（我们称之为 $H'$）只包含在 $H'$ 内部度至少为 $k$ 的节点。\n- **最大性**：为了证明 $H'$ 是唯一的*最大*此类子图，我们使用反证法。假设存在另一个满足 $k$-核性质（所有节点在 $H''$ 内的度 $\\ge k$）的诱导子图 $H''$，使得 $V(H') \\subset V(H'')$。令 $v$ 为 $V(H'') \\setminus V(H')$ 中的一个节点。由于 $v$ 不在 $H'$ 中，它必然在某个步骤 $t$ 被我们的算法移除了。这意味着它在图 $G_t$ 中的度小于 $k$，即 $\\deg_{G_t}(v)  k$。然而，在步骤 $t$ 时，顶点集 $V_t$ 是 $V(H'')$ 的超集，因为 $v$ 尚未被移除。因此，$v$ 在 $G_t$ 中的度必须大于或等于其在 $H''$ 中的度：$\\deg_{G_t}(v) \\ge \\deg_{H''}(v)$。根据关于 $H''$ 的前提，我们知道 $\\deg_{H''}(v) \\ge k$。这导致了矛盾 $\\deg_{G_t}(v) \\ge k$。因此，不存在这样的 $H''$，算法找到的子图 $H'$ 是唯一的最大 $k$-核。\n\n**2.2. 计算所有节点的核数**\n\n核数 $c_i$ 是使节点 $i$ 属于 $k$-核 $H_k$ 的最大 $k$ 值。这等价于说，如果节点 $i$ 在 $H_k$ 中但不在 $H_{k+1}$ 中，则 $c_i=k$。这直接提出了一个算法。所有核数为 $k$ 的节点的集合是 $V(H_k) \\setminus V(H_{k+1})$。\n\n$k$-核形成一个嵌套的子图序列：$G \\supseteq H_1 \\supseteq H_2 \\supseteq \\dots \\supseteq H_{k_{\\text{max}}}$。我们可以通过迭代地剥离图的最外层来找到核数。\n\n**算法：**\n1. 初始化一个可变的当前度数组 `d_current`，其值为原始图 $G$ 中所有节点的度。\n2. 初始化一个大小为 $n$ 的 `cores` 数组，并用一个哨兵值（例如-1）填充，表示尚未分配核数。\n3. 初始化当前核级别的变量 `k = 0`。\n4. 当仍有未分配核数的节点时：\n    a. 重复查找所有当前度 `d_current[v]` 小于或等于 `k` 的活跃节点 `v`（其中 `cores[v]` 仍为哨兵值）。\n    b. 如果不存在这样的节点，则将 `k` 加一，并转到步骤 4a。\n    c. 对于每个这样的节点 `v`：\n        i. 分配其核数：`cores[v] = k`。\n        ii. 从图中“移除” `v`（概念上，通过将其标记为已处理）。\n        iii. 对于 `v` 的每个邻居 `u`，将其当前度减一：`d_current[u] -= 1`。\n    d. 不增加 `k`，重复步骤 4a，因为度的减少可能导致其他节点现在满足 `d_current = k` 的条件。\n5. `cores` 数组现在包含了每个节点的核数。\n\n这种“逐级”剥离过程确保了当一个节点 `v` 在级别 `k` 被移除时，是因为它的度已经降至 `k`（或更低），并且它不能成为任何更高阶核的一部分。在阶段 `k` 移除的节点集正是那些属于 `k`-核但不属于 `(k+1)`-核的节点。\n\n### 步骤 3：在系统生物医学中的认知意义\n\n$k$-核分解提供了一种基于拓扑学的方法来识别网络中有影响力的或核心的部分，这与生物系统的分析高度相关。\n\n- **鲁棒性与弹性**：在网络理论中，鲁棒性指系统在遭受扰动（如节点或边的移除）后维持其功能的能力。$k$-核结构将这方面的一个特征形式化。最内层的核 $H_{k_{\\text{max}}}$ 代表了网络中最密集互连且最具弹性的部分。移除低度（外围）节点不会影响该核的完整性。一个具有高核数 $c_i$ 的节点在结构上嵌入在一个鲁棒的邻域中，这意味着移除它需要其局部密集社区中许多其他节点的先前或同时失效。\n\n- **生物网络中的模块性与冗余性**：生物网络，如蛋白质-蛋白质相互作用（PPI）网络或基因调控网络，已知具有模块性。这些模块通常对应于协同执行特定生物功能的生物分子群（例如，蛋白质复合物或信号通路）。高阶核常常映射到这些功能模块上。核内的高度互连性提供了冗余；如果一个蛋白质（节点）被敲除，其功能可能由同一核内的众多伙伴代偿，使得整体功能对单点故障具有弹性。例如，在PPI网络中，$k_{\\text{max}}$-核可能包含对细胞存活至关重要的蛋白质，形成一个稳定的复合物。识别这些核有助于研究人员精确定位细胞机器的关键组成部分，这些组成部分可能是药物开发的潜在靶点或疾病的生物标志物。外围节点（低核数）可能参与不太关键或更瞬时的功能，连接不同的模块或响应外部刺激。\n\n### 步骤 4：实现与计算\n\n所推导的算法被实现以处理给定的邻接矩阵测试套件。计算结果并按规定格式化。\n\n实现的算法遵循第 2.2 节中推导的“逐级”剥离逻辑。它从 $0$ 开始向上迭代核心级别 `k`。在每次迭代中，它会重复查找并“移除”所有当前度已降至 `k` 或以下的节点，并为其分配核数 `k`。此过程持续进行，直到所有节点都被分配了核数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the core number computation problem for the given test suite.\n    \"\"\"\n\n    def compute_core_numbers(A: np.ndarray) - list[int]:\n        \"\"\"\n        Computes the core number for each node in a graph given by its adjacency matrix.\n        \n        The algorithm is based on iteratively peeling away nodes. It works by levels.\n        For a level k, it removes all nodes with degree = k. This is repeated until\n        no more nodes at this level can be removed. Then k is incremented. The core\n        number of a node is the level k at which it is removed.\n\n        Args:\n            A: A numpy array representing the symmetric adjacency matrix of the graph.\n\n        Returns:\n            A list of integers representing the core number of each node.\n        \"\"\"\n        n = A.shape[0]\n        if n == 0:\n            return []\n\n        # Make a copy of degrees to be modified during the peeling process.\n        current_degrees = A.sum(axis=1).astype(int)\n        \n        # core_numbers[i] will store the core number of node i.\n        # Initialize with -1 to mark nodes as unprocessed.\n        core_numbers = np.full(n, -1, dtype=int)\n        \n        nodes_processed = 0\n        k = 0 # Start with the 0-core level.\n\n        while nodes_processed  n:\n            # Iteratively remove nodes with degree = k at the current level.\n            # This inner loop continues until no more nodes can be removed at level k.\n            was_node_removed_in_pass = True\n            while was_node_removed_in_pass:\n                was_node_removed_in_pass = False\n                nodes_to_remove_this_pass = []\n                \n                # Find all unprocessed nodes with degree = k.\n                for i in range(n):\n                    if core_numbers[i] == -1 and current_degrees[i] = k:\n                        nodes_to_remove_this_pass.append(i)\n\n                if nodes_to_remove_this_pass:\n                    was_node_removed_in_pass = True\n                    # Process the removal of these nodes.\n                    for v in nodes_to_remove_this_pass:\n                        # Assign core number and mark as processed.\n                        core_numbers[v] = k\n                        nodes_processed += 1\n                        \n                        # Decrement the degrees of its neighbors.\n                        # We iterate through the adjacency matrix row for node v.\n                        for u in range(n):\n                            if A[v, u] == 1:\n                                current_degrees[u] -= 1\n            \n            # Move to the next core level.\n            k += 1\n            \n        return core_numbers.tolist()\n\n\n    # Test Suite from the problem statement.\n    A_A = np.array([\n        [0, 1, 1, 1, 0, 1],\n        [1, 0, 1, 0, 0, 1],\n        [1, 1, 0, 0, 0, 0],\n        [1, 0, 0, 0, 1, 0],\n        [0, 0, 0, 1, 0, 0],\n        [1, 1, 0, 0, 0, 0],\n    ])\n\n    A_B = np.array([\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n    ])\n\n    A_C = np.array([\n        [0, 1, 1, 1, 1],\n        [1, 0, 1, 1, 1],\n        [1, 1, 0, 1, 1],\n        [1, 1, 1, 0, 1],\n        [1, 1, 1, 1, 0],\n    ])\n\n    A_D = np.array([\n        [0, 1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n    ])\n\n    test_cases = [A_A, A_B, A_C, A_D]\n    \n    results = [compute_core_numbers(A) for A in test_cases]\n\n    # Format the results into the required string format.\n    # Ex: [[2,2,2,1,1,2],[0,0,0,0],[4,4,4,4,4],[1,1,1,1,1,1]]\n    result_str = \",\".join(map(str, results))\n    result_str = result_str.replace(\" \", \"\") # Remove spaces for compact representation.\n\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "4367933"}]}